", __VERSION__);(NL)#endif /* llvm */(NL)#elif defined(__HP_aCC)(NL)	g_string_append_printf(str, "	,	L_17
"\n%s"	,	L_9
" in Visual C++.)(NL)	 * XXX? Should we just output the compiler version?(NL)	 */(NL)    int compiler_major_version = (_MSC_FULL_VER / 10000000), visual_studio_ver;(NL)(NL)    if (compiler_major_version &lt; 19) {(NL)        visual_studio_ver = compiler_major_version - 6;(NL)    }else{(NL)        visual_studio_ver = compiler_major_version - 5;(NL)    }(NL)(NL)    g_string_append_printf(str, "	,	L_26
" is called at the end to append any additional(NL) * information; this is required in order to, for example, put the(NL) * Portaudio information at the end of the string, as we currently(NL) * don't use Portaudio in TShark.(NL) */(NL)GString *(NL)get_runtime_version_info(void (*additional_info)(GString *))(NL){(NL)	GString *str;(NL)	gchar *lang;(NL)(NL)	str = g_string_new("	,	L_36
size_t	,	T_2
g_string_append	,	F_2
", __VERSION__);(NL)#elif defined(__llvm__)(NL)	g_string_append_printf(str, "	,	L_15
nExIds	,	V_11
", __INTEL_COMPILER % 10);(NL)#ifdef __INTEL_COMPILER_BUILD_DATE(NL)	g_string_sprinta(str, "	,	L_23
"(64-bit) "	,	L_4
len	,	V_5
_WIN32	,	F_13
" VCSVERSION "	,	L_43
"GLib (version unknown)"	,	L_8
" VCSBRANCH "	,	L_44
", __VERSION__);(NL)#else /* boring old GCC */(NL)	g_string_append_printf(str, "	,	L_16
GlobalMemoryStatusEx	,	F_14
get_mem_info	,	F_12
guint32	,	T_3
" "	,	L_13
",(NL)	    (__SUNPRO_C &gt;&gt; 8) &amp; 0xF, (__SUNPRO_C &gt;&gt; 4) &amp; 0xF);(NL)	if ((__SUNPRO_C &amp; 0xF) != 0)(NL)		g_string_append_printf(str, "	,	L_33
", statex.ullTotalPhys/(1024*1024));(NL)#endif(NL)}(NL)(NL)/*(NL) * Get compiler information, and append it to the GString.(NL) */(NL)static void(NL)get_compiler_info(GString *str)(NL){(NL)	/*(NL)	 * See https://sourceforge.net/apps/mediawiki/predef/index.php?title=Compilers(NL)	 * information on various defined strings.(NL)	 *(NL)	 * GCC's __VERSION__ is a nice text string for humans to(NL)	 * read.  The page at sourceforge.net largely describes(NL)	 * numeric #defines that encode the version; if the compiler(NL)	 * doesn't also offer a nice printable string, we try prettifying(NL)	 * the number somehow.(NL)	 */(NL)#if defined(__GNUC__) &amp;&amp; defined(__VERSION__)(NL)	/*(NL)	 * Clang and llvm-gcc also define __GNUC__ and __VERSION__;(NL)	 * distinguish between them.(NL)	 */(NL)#if defined(__clang__)(NL)	g_string_append_printf(str, "	,	L_14
",(NL)                   visual_studio_ver,(NL)			       (_MSC_FULL_VER / 100000) % 100);(NL)#  if (_MSC_FULL_VER % 100000) != 0(NL)	g_string_append_printf(str, "	,	L_27
GString	,	T_1
CPUBrandString	,	V_10
", __HP_aCC);(NL)#elif defined(__xlC__)(NL)	g_string_append_printf(str, "	,	L_18
",(NL)			       _MSC_FULL_VER % 10000);(NL)#  endif(NL)# endif(NL)	g_string_append_printf(str, "	,	L_30
",(NL)	    __INTEL_COMPILER_BUILD_DATE / 10000,(NL)	    (__INTEL_COMPILER_BUILD_DATE / 100) % 100,(NL)	    __INTEL_COMPILER_BUILD_DATE % 100);(NL)#endif /* __INTEL_COMPILER_BUILD_DATE */(NL)	g_string_append_printf(str, "	,	L_24
str	,	V_1
GLIB_MAJOR_VERSION	,	F_8
",(NL)	    (__xlC__ &gt;&gt; 8) &amp; 0xFF, __xlC__ &amp; 0xFF);(NL)#ifdef __IBMC__(NL)	if ((__IBMC__ % 10) != 0)(NL)		g_string_append_printf(str, "	,	L_19
", __IBMC__ % 10);(NL)#endif /* __IBMC__ */(NL)	g_string_append_printf(str, "	,	L_20
dwLength	,	V_13
"Compiled "	,	L_2
");(NL)#endif(NL)}(NL)(NL)/*(NL) * Get various library run-time versions, and the OS version, and append(NL) * them to the specified GString.(NL) *(NL) * "	,	L_35
");(NL)#elif defined(_MSC_FULL_VER)(NL)# if _MSC_FULL_VER &gt; 99999999(NL)	/* Quote from the web:(NL)	 * Bakersfield: DevDiv's upper management determines the scheduling of new major versions.(NL)	 * They also decided to increment the product version from 12 (for VS 2013) to 14 (for VS 2015).(NL)	 * However, the C++ compiler's version incremented normally, from 18 to 19.(NL)	 * (It's larger because the C++ compiler predates the "	,	L_25
" G_GINT64_MODIFIER "	,	L_12
append_info	,	F_5
MEMORYSTATUSEX	,	T_4
"(32-bit) "	,	L_3
",(NL)	    (_MSC_VER / 100) - 6, _MSC_VER % 100);(NL)#elif defined(__SUNPRO_C)(NL)	g_string_append_printf(str, "	,	L_32
CPUInfo	,	V_9
get_compiled_version_info	,	F_3
"with "	,	L_6
_U_	,	V_8
", __SUNPRO_C &amp; 0xF);(NL)	g_string_append_printf(str, "	,	L_34
statex	,	V_12
GLIB_MINOR_VERSION	,	V_6
point	,	V_2
");(NL)(NL)	get_os_version_info(str);(NL)(NL)	/*(NL)	 * Locale.(NL)	 *(NL)	 * This returns the C language's locale information; this(NL)	 * returns the locale that's actually in effect, even if(NL)	 * it doesn't happen to match the settings of any of the(NL)	 * locale environment variables.(NL)	 *(NL)	 * XXX - what happens on Windows?  If nobody's explicitly(NL)	 * overridden any of the environment variables, does this(NL)	 * reflect the locale settings in the OS?  If so, does(NL)	 * that include the code page?  (We're not using UTF-16(NL)	 * for output to files or the console; using code page(NL)	 * 65001, i.e. UTF-8, as your system code page probably(NL)	 * works best with Wireshark.)(NL)	 */(NL)	if ((lang = setlocale(LC_ALL, NULL)) != NULL)(NL)		g_string_append_printf(str, "	,	L_37
ws_cpuid_sse42	,	F_11
g_string_new	,	F_6
"GLib %d.%d.%d"	,	L_7
");(NL)#elif defined(_MSC_VER)(NL)	/* _MSC_FULL_VER not defined, but _MSC_VER defined */(NL)	g_string_append_printf(str, "	,	L_31
",(NL)	    __INTEL_COMPILER / 100, (__INTEL_COMPILER / 10) % 10);(NL)	if ((__INTEL_COMPILER % 10) != 0)(NL)		g_string_append_printf(str, "	,	L_22
",(NL)	       prog_name_str, get_ws_vcs_version_info(), get_copyright_info(),(NL)	       comp_info_str-&gt;str, runtime_info_str-&gt;str);(NL)}(NL)(NL)/*(NL) * Return a version number string for Wireshark, including, for builds(NL) * from a tree checked out from Wireshark's version control system,(NL) * something identifying what version was checked out.(NL) */(NL)const char *(NL)get_ws_vcs_version_info(void)(NL){(NL)#ifdef VCSVERSION(NL)	return VERSION "	,	L_42
", "	,	L_5
", lang);(NL)	else(NL)		g_string_append(str, "	,	L_38
");(NL)(NL)	/* CPU Info */(NL)	get_cpu_info(str);(NL)(NL)	/* Get info about installed memory Windows only */(NL)	get_mem_info(str);(NL)(NL)	/* Compiler info */(NL)	get_compiler_info(str);(NL)(NL)	end_string(str);(NL)(NL)	return str;(NL)}(NL)(NL)void(NL)show_version(const gchar *prog_name_str, GString *comp_info_str,(NL)	     GString *runtime_info_str)(NL){(NL)	printf("	,	L_40
GLIB_MICRO_VERSION	,	V_7
end_string	,	F_1
" (with SSE4.2)"	,	L_10
",(NL)			       (_MSC_FULL_VER / 1000000) - 6,(NL)			       (_MSC_FULL_VER / 10000) % 100);(NL)#  if (_MSC_FULL_VER % 10000) != 0(NL)	g_string_append_printf(str, "	,	L_29
", with ""	,	L_11
g_string_append_printf	,	F_7
get_cpu_info	,	F_9
p	,	V_3
prepend_info	,	F_4
q	,	V_4
");(NL)#elif defined(__INTEL_COMPILER)(NL)	g_string_append_printf(str, "	,	L_21
",(NL)			       _MSC_FULL_VER % 100000);(NL)#  endif(NL)# else(NL)	g_string_append_printf(str, "	,	L_28
");(NL)(NL)	/* Additional application-dependent information */(NL)	if (additional_info)(NL)		(*additional_info)(str);(NL)(NL)	g_string_append(str, "	,	L_39
ws_cpuid	,	F_10
"\n"	,	L_1
"(NL)	       "	,	L_41
