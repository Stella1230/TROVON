Cdb	,	V_248
atomic_set	,	F_61
ccb	,	V_164
lun	,	V_105
ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK	,	V_308
ARCMSR_MESSAGE_RETURNCODE_OK	,	V_339
",(NL)					acb-&gt;adapter_index, cdb_phyaddr_hi32);(NL)			writel(ARCMSR_SIGNATURE_SET_CONFIG, &amp;reg-&gt;msgcode_rwbuffer[0]);(NL)			writel(cdb_phyaddr_hi32, &amp;reg-&gt;msgcode_rwbuffer[1]);(NL)			writel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &amp;reg-&gt;inbound_msgaddr0);(NL)			writel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &amp;reg-&gt;inbound_doorbell);(NL)			if (!arcmsr_hbc_wait_msgint_ready(acb)) {(NL)				printk(KERN_NOTICE "	,	L_32
scsi_host_remove	,	V_146
arc_cdb_size	,	V_265
my_empty_len	,	V_293
ARCMSR_CCBREPLY_FLAG_ERROR_MODE0	,	V_209
ARCMSR_CCBREPLY_FLAG_ERROR_MODE1	,	V_220
dev	,	V_16
"ccboutstandingcount = %d \n"	,	L_26
retry_count	,	V_59
arcmsr_flush_adapter_cache	,	F_30
acb_flags	,	V_136
pci_release_regions	,	F_69
queue_depth	,	V_3
firm_model	,	V_374
arcmsr_request_device_map	,	V_156
"Areca   "	,	L_16
unlikely	,	F_103
handle_state	,	V_34
KERN_WARNING	,	V_120
firm_cfg_version	,	V_81
arcmsr_hba_postqueue_isr	,	F_124
"arcmsr%d: polling get an illegal ccb"	,	L_24
"arcmsr%d: dma_alloc_coherent got error\n"	,	L_4
diff	,	V_107
ACB_F_MESSAGE_WQBUFFER_CLEARED	,	V_137
rtnval	,	V_160
ACB_F_IOP_INITED	,	V_222
ending_index	,	V_269
" command done ccb = '0x%p'"	,	L_25
ARCMSR_MESSAGE_WRITE_WQBUFFER	,	V_340
ARCMSR_MAX_HBB_POSTQUEUE	,	V_211
inbound_queueport_low	,	V_275
scsicmd	,	V_367
CMD_MESSAGE_FIELD	,	V_321
arcmsr_alloc_sysfs_attr	,	F_65
TYPE_PROCESSOR	,	V_363
pci_read_config_word	,	F_22
ioremap_nocache	,	F_11
IRQ_NONE	,	V_318
arcmsr_get_hba_config	,	F_152
free_irq	,	F_94
pci_disable_dev	,	V_119
ARCMSR_CCB_START	,	V_199
ARCMSR_INBOUND_DRIVER_DATA_READ_OK	,	V_279
arcmsr_hbb_postqueue_isr	,	F_125
GFP_ATOMIC	,	V_332
dma_alloc_coherent	,	F_33
ARCMSR_OUTBOUND_IOP331_DATA_READ_OK	,	V_307
result	,	V_175
abortcmd	,	V_201
AdditionalSenseLength	,	V_345
arcmsr_get_freeccb	,	F_142
sense_data_length	,	V_177
WRITE_BUFFER	,	V_364
pQbuffer	,	V_291
ARCMSR_INBOUND_MESG0_STOP_BGRB	,	V_277
bdev	,	V_36
scsi_device_put	,	F_44
arcmsr_build_ccb	,	F_101
ARCMSR_IOP2DRV_MESSAGE_CMD_DONE	,	V_52
ARCMSR_DRV2IOP_DATA_WRITE_OK	,	V_283
INIT_WORK	,	F_60
address	,	V_254
SUCCESS	,	V_266
polling_hbb_ccb_retry	,	V_404
"arcmsr%d: ""	,	L_27
drv2iop_doorbell	,	V_55
scsi_for_each_sg	,	F_104
irq	,	V_32
i	,	V_48
iop2drv_doorbell	,	V_51
j	,	V_69
adapter_type	,	V_11
EOPNOTSUPP	,	V_6
arcmsr_define_adapter_type	,	F_21
IS_SG64_ADDR	,	V_256
pci_resource_len	,	F_8
ARCMSR_DEFAULT_SG_ENTRIES	,	V_80
u	,	V_236
Length	,	V_335
jiffies	,	V_152
inbound_queueport_high	,	V_274
DeviceStatus	,	V_191
"arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'"	,	L_22
KERN_NOTICE	,	V_22
pqbuffer	,	V_288
msgcode_rwbuffer	,	V_111
postq_index	,	V_215
ARCMSR_INBOUND_MESG0_SET_CONFIG	,	V_407
acb	,	V_10
arcmsr_do_message_isr_bh	,	V_98
arcmsr_flush_hbb_cache	,	F_28
",acb-&gt;host-&gt;host_no);(NL)	}(NL)}(NL)(NL)static void arcmsr_start_hbc_bgrb(struct AdapterControlBlock *pACB)(NL){(NL)	struct MessageUnit_C *phbcmu = (struct MessageUnit_C *)pACB-&gt;pmuC;(NL)	pACB-&gt;acb_flags |= ACB_F_MSG_START_BGRB;(NL)	writel(ARCMSR_INBOUND_MESG0_START_BGRB, &amp;phbcmu-&gt;inbound_msgaddr0);(NL)	writel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &amp;phbcmu-&gt;inbound_doorbell);(NL)	if (!arcmsr_hbc_wait_msgint_ready(pACB)) {(NL)		printk(KERN_NOTICE "	,	L_35
outbound_doorbell	,	V_28
qbuffer	,	V_286
Index	,	V_395
"ccb = '0x%p' ccbacb = '0x%p' startdone = 0x%x"	,	L_12
reg	,	V_47
flag_ccb	,	V_203
messagedatabuffer	,	V_333
ARCMSR_MESSAGE_RETURNCODE_3F	,	V_351
arcmsr_handle_virtual_command	,	F_146
ret	,	V_39
scsi_add_device	,	F_41
sectors	,	V_41
pci_get_drvdata	,	F_90
ARCMSR_MESSAGE_INT_CLEAR_PATTERN	,	V_53
arcmsr_post_ccb	,	F_111
count	,	V_381
");(NL)				timeout = wait_event_timeout(wait_q, (acb-&gt;acb_flags &amp; ACB_F_BUS_RESET) == 0, 220*HZ);(NL)				if (timeout) {(NL)					return SUCCESS;(NL)				}(NL)			}(NL)			acb-&gt;acb_flags |= ACB_F_BUS_RESET;(NL)			if (!arcmsr_iop_reset(acb)) {(NL)				struct MessageUnit_A __iomem *reg;(NL)				reg = acb-&gt;pmuA;(NL)				arcmsr_hardware_reset(acb);(NL)				acb-&gt;acb_flags &amp;= ~ACB_F_IOP_INITED;(NL)sleep_again:(NL)				ssleep(ARCMSR_SLEEPTIME);(NL)				if ((readl(&amp;reg-&gt;outbound_msgaddr1) &amp; ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0) {(NL)					printk(KERN_ERR "	,	L_40
dma_coherent_handle	,	V_66
list	,	V_94
ARCMSR_MESSAGE_STOP_BGRB	,	V_278
ARCMSR_MESSAGE_FLUSH_CACHE	,	V_62
spin_unlock_irqrestore	,	F_82
inbound_doorbell	,	V_64
init_timer	,	F_62
arcmsr_hbb_enable_driver_mode	,	F_76
sg_dma_address	,	F_108
ILLEGAL_REQUEST	,	V_344
SG32ENTRY	,	V_252
ARCMSR_MU_OUTBOUND_DOORBELL_INT	,	V_314
iop_device_map	,	V_380
ARCMSR_MAX_TARGETID	,	V_75
wait_q	,	V_122
work_struct	,	V_96
arcmsr_free_hbb_mu	,	F_3
iounmap	,	F_10
ARECA_RAID_GONE	,	V_78
"Hello! I am ARCMSR"	,	L_15
wqbuf_firstindex	,	V_301
" : ""	,	L_52
intmask_org	,	V_224
arcmsr_ccb_complete	,	F_79
retvalue	,	V_323
arcmsr_handle_hbc_isr	,	F_132
ccb_tmp	,	V_68
ARCMSR_MESSAGE_RETURN_CODE_3F	,	V_350
kmalloc	,	F_140
ARECA_RAID_GOOD	,	V_190
arcmsr_pci_driver	,	V_223
length	,	V_240
DMA_BIT_MASK	,	F_49
ARCMSR_INBOUND_MESG0_ABORT_CMD	,	V_158
message_out	,	V_328
ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK	,	V_281
ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK	,	V_398
outbound_intstatus	,	V_49
arcmsr_polling_hbc_ccbdone	,	F_155
free_hbb_mu	,	V_143
list_entry	,	F_144
ARCMSR_IOP2DRV_DATA_WRITE_OK	,	V_229
ptmpQbuffer	,	V_331
ErrorCode	,	V_180
drv2iop_doorbell_mask	,	V_383
SenseKey	,	V_343
max_lun	,	V_126
ante_token_value	,	V_147
controlcode	,	V_325
ENOMEM	,	V_89
host_interrupt_status	,	V_316
ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE	,	V_185
sg_page	,	F_138
ARCMSR_SIGNATURE_SET_CONFIG	,	V_406
iop_data	,	V_292
pccb_pool	,	V_93
number	,	V_123
HZ	,	V_153
SCSI_QDEPTH_DEFAULT	,	V_5
nseg	,	V_243
ARCMSR_MESSAGE_SAY_HELLO	,	V_352
",(NL)		acb-&gt;host-&gt;host_no, cmd-&gt;device-&gt;id, cmd-&gt;device-&gt;lun);(NL)	acb-&gt;acb_flags |= ACB_F_ABORT;(NL)	acb-&gt;num_aborts++;(NL)	/*(NL)	************************************************(NL)	** the all interrupt service routine is locked(NL)	** we need to handle it as soon as possible and exit(NL)	************************************************(NL)	*/(NL)	if (!atomic_read(&amp;acb-&gt;ccboutstandingcount))(NL)		return rtn;(NL)(NL)	for (i = 0; i &lt; ARCMSR_MAX_FREECCB_NUM; i++) {(NL)		struct CommandControlBlock *ccb = acb-&gt;pccb_pool[i];(NL)		if (ccb-&gt;startdone == ARCMSR_CCB_START &amp;&amp; ccb-&gt;pcmd == cmd) {(NL)			ccb-&gt;startdone = ARCMSR_CCB_ABORTED;(NL)			rtn = arcmsr_abort_one_cmd(acb, ccb);(NL)			break;(NL)		}(NL)	}(NL)	acb-&gt;acb_flags &amp;= ~ACB_F_ABORT;(NL)	return rtn;(NL)}(NL)(NL)static const char *arcmsr_info(struct Scsi_Host *host)(NL){(NL)	struct AdapterControlBlock *acb =(NL)		(struct AdapterControlBlock *) host-&gt;hostdata;(NL)	static char buf[256];(NL)	char *type;(NL)	int raid6 = 1;(NL)	switch (acb-&gt;pdev-&gt;device) {(NL)	case PCI_DEVICE_ID_ARECA_1110:(NL)	case PCI_DEVICE_ID_ARECA_1200:(NL)	case PCI_DEVICE_ID_ARECA_1202:(NL)	case PCI_DEVICE_ID_ARECA_1210:(NL)		raid6 = 0;(NL)		/*FALLTHRU*/(NL)	case PCI_DEVICE_ID_ARECA_1120:(NL)	case PCI_DEVICE_ID_ARECA_1130:(NL)	case PCI_DEVICE_ID_ARECA_1160:(NL)	case PCI_DEVICE_ID_ARECA_1170:(NL)	case PCI_DEVICE_ID_ARECA_1201:(NL)	case PCI_DEVICE_ID_ARECA_1220:(NL)	case PCI_DEVICE_ID_ARECA_1230:(NL)	case PCI_DEVICE_ID_ARECA_1260:(NL)	case PCI_DEVICE_ID_ARECA_1270:(NL)	case PCI_DEVICE_ID_ARECA_1280:(NL)		type = "	,	L_47
arcmsr_unmap_pciregion	,	F_14
arcmsr_get_iop_wqbuffer	,	F_118
arcmsr_hba_doorbell_isr	,	F_121
" signature */(NL)		writel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);(NL)		/* normal should be zero */(NL)		writel(cdb_phyaddr_hi32, rwbuffer++);(NL)		/* postQ size (256 + 8)*4	 */(NL)		writel(post_queue_phyaddr, rwbuffer++);(NL)		/* doneQ size (256 + 8)*4	 */(NL)		writel(post_queue_phyaddr + 1056, rwbuffer++);(NL)		/* ccb maxQ size must be --&gt; [(256 + 8)*4]*/(NL)		writel(1056, rwbuffer);(NL)(NL)		writel(ARCMSR_MESSAGE_SET_CONFIG, reg-&gt;drv2iop_doorbell);(NL)		if (!arcmsr_hbb_wait_msgint_ready(acb)) {(NL)			printk(KERN_NOTICE "	,	L_30
ARCMSR_MU_OUTBOUND_MESSAGE0_INT	,	V_50
id	,	V_113
inqdata	,	V_361
pmuA	,	V_21
pmuB	,	V_18
pmuC	,	V_27
ReturnCode	,	V_337
cmd_len	,	V_250
index	,	V_270
cylinders	,	V_42
arcmsr_abort_hbc_allcmd	,	F_74
IRQ_HANDLED	,	V_319
ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR_MASK	,	V_233
ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR	,	V_218
hello_string	,	V_353
ARCMSR_DRV2IOP_END_OF_INTERRUPT	,	V_54
"arcmsr%d: can't set driver mode. \n"	,	L_8
cmd	,	V_320
arcmsr_bios_param	,	F_17
sg_tablesize	,	V_84
pci_set_dma_mask	,	F_48
poll_count	,	V_221
", acb-&gt;host-&gt;host_no);(NL)				return 1;(NL)			}(NL)		}(NL)		}(NL)	}(NL)	return 0;(NL)}(NL)(NL)static void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb)(NL){(NL)	uint32_t firmware_state = 0;(NL)	switch (acb-&gt;adapter_type) {(NL)(NL)	case ACB_ADAPTER_TYPE_A: {(NL)		struct MessageUnit_A __iomem *reg = acb-&gt;pmuA;(NL)		do {(NL)			firmware_state = readl(&amp;reg-&gt;outbound_msgaddr1);(NL)		} while ((firmware_state &amp; ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0);(NL)		}(NL)		break;(NL)(NL)	case ACB_ADAPTER_TYPE_B: {(NL)		struct MessageUnit_B *reg = acb-&gt;pmuB;(NL)		do {(NL)			firmware_state = readl(reg-&gt;iop2drv_doorbell);(NL)		} while ((firmware_state &amp; ARCMSR_MESSAGE_FIRMWARE_OK) == 0);(NL)		writel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg-&gt;drv2iop_doorbell);(NL)		}(NL)		break;(NL)	case ACB_ADAPTER_TYPE_C: {(NL)		struct MessageUnit_C *reg = (struct MessageUnit_C *)acb-&gt;pmuC;(NL)		do {(NL)			firmware_state = readl(&amp;reg-&gt;outbound_msgaddr1);(NL)		} while ((firmware_state &amp; ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);(NL)		}(NL)	}(NL)}(NL)(NL)static void arcmsr_request_hba_device_map(struct AdapterControlBlock *acb)(NL){(NL)	struct MessageUnit_A __iomem *reg = acb-&gt;pmuA;(NL)	if (unlikely(atomic_read(&amp;acb-&gt;rq_map_token) == 0) || ((acb-&gt;acb_flags &amp; ACB_F_BUS_RESET) != 0 ) || ((acb-&gt;acb_flags &amp; ACB_F_ABORT) != 0 )){(NL)		mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)		return;(NL)	} else {(NL)		acb-&gt;fw_flag = FW_NORMAL;(NL)		if (atomic_read(&amp;acb-&gt;ante_token_value) == atomic_read(&amp;acb-&gt;rq_map_token)){(NL)			atomic_set(&amp;acb-&gt;rq_map_token, 16);(NL)		}(NL)		atomic_set(&amp;acb-&gt;ante_token_value, atomic_read(&amp;acb-&gt;rq_map_token));(NL)		if (atomic_dec_and_test(&amp;acb-&gt;rq_map_token)) {(NL)			mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)			return;(NL)		}(NL)		writel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &amp;reg-&gt;inbound_msgaddr0);(NL)		mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)	}(NL)	return;(NL)}(NL)(NL)static void arcmsr_request_hbb_device_map(struct AdapterControlBlock *acb)(NL){(NL)	struct MessageUnit_B __iomem *reg = acb-&gt;pmuB;(NL)	if (unlikely(atomic_read(&amp;acb-&gt;rq_map_token) == 0) || ((acb-&gt;acb_flags &amp; ACB_F_BUS_RESET) != 0 ) || ((acb-&gt;acb_flags &amp; ACB_F_ABORT) != 0 )){(NL)		mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)		return;(NL)	} else {(NL)		acb-&gt;fw_flag = FW_NORMAL;(NL)		if (atomic_read(&amp;acb-&gt;ante_token_value) == atomic_read(&amp;acb-&gt;rq_map_token)) {(NL)			atomic_set(&amp;acb-&gt;rq_map_token, 16);(NL)		}(NL)		atomic_set(&amp;acb-&gt;ante_token_value, atomic_read(&amp;acb-&gt;rq_map_token));(NL)		if (atomic_dec_and_test(&amp;acb-&gt;rq_map_token)) {(NL)			mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)			return;(NL)		}(NL)		writel(ARCMSR_MESSAGE_GET_CONFIG, reg-&gt;drv2iop_doorbell);(NL)		mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)	}(NL)	return;(NL)}(NL)(NL)static void arcmsr_request_hbc_device_map(struct AdapterControlBlock *acb)(NL){(NL)	struct MessageUnit_C __iomem *reg = acb-&gt;pmuC;(NL)	if (unlikely(atomic_read(&amp;acb-&gt;rq_map_token) == 0) || ((acb-&gt;acb_flags &amp; ACB_F_BUS_RESET) != 0) || ((acb-&gt;acb_flags &amp; ACB_F_ABORT) != 0)) {(NL)		mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)		return;(NL)	} else {(NL)		acb-&gt;fw_flag = FW_NORMAL;(NL)		if (atomic_read(&amp;acb-&gt;ante_token_value) == atomic_read(&amp;acb-&gt;rq_map_token)) {(NL)			atomic_set(&amp;acb-&gt;rq_map_token, 16);(NL)		}(NL)		atomic_set(&amp;acb-&gt;ante_token_value, atomic_read(&amp;acb-&gt;rq_map_token));(NL)		if (atomic_dec_and_test(&amp;acb-&gt;rq_map_token)) {(NL)			mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)			return;(NL)		}(NL)		writel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &amp;reg-&gt;inbound_msgaddr0);(NL)		writel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &amp;reg-&gt;inbound_doorbell);(NL)		mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)	}(NL)	return;(NL)}(NL)(NL)static void arcmsr_request_device_map(unsigned long pacb)(NL){(NL)	struct AdapterControlBlock *acb = (struct AdapterControlBlock *)pacb;(NL)	switch (acb-&gt;adapter_type) {(NL)		case ACB_ADAPTER_TYPE_A: {(NL)			arcmsr_request_hba_device_map(acb);(NL)		}(NL)		break;(NL)		case ACB_ADAPTER_TYPE_B: {(NL)			arcmsr_request_hbb_device_map(acb);(NL)		}(NL)		break;(NL)		case ACB_ADAPTER_TYPE_C: {(NL)			arcmsr_request_hbc_device_map(acb);(NL)		}(NL)	}(NL)}(NL)(NL)static void arcmsr_start_hba_bgrb(struct AdapterControlBlock *acb)(NL){(NL)	struct MessageUnit_A __iomem *reg = acb-&gt;pmuA;(NL)	acb-&gt;acb_flags |= ACB_F_MSG_START_BGRB;(NL)	writel(ARCMSR_INBOUND_MESG0_START_BGRB, &amp;reg-&gt;inbound_msgaddr0);(NL)	if (!arcmsr_hba_wait_msgint_ready(acb)) {(NL)		printk(KERN_NOTICE "	,	L_33
outbound_intmask	,	V_184
pCCB	,	V_198
arcmsr_cdb	,	V_91
ARCMSR_DRV2IOP_DOORBELL_MASK	,	V_384
ARCMSR_MAX_OUTSTANDING_CMD	,	V_208
outbound_doorbell_clear	,	V_31
list_add_tail	,	F_36
scsi_cmnd	,	V_165
unmap_pci_region	,	V_142
ARCMSR_HBCMU_DRV2IOP_POSTQUEUE_THROTTLING	,	V_312
pci_disable_device	,	F_71
psdev	,	V_106
iop2drv_doorbell_mask	,	V_186
pci_set_drvdata	,	F_51
sector_t	,	T_3
flush_work_sync	,	F_92
arcmsr_polling_ccbdone	,	F_156
cmd_per_lun	,	V_130
arcmsr_stop_hbc_bgrb	,	F_114
ARCMSR_DOORBELL_INT_CLEAR_PATTERN	,	V_210
u16	,	T_4
ARCMSR_MAX_TARGETLUN	,	V_76
max_xfer_len	,	V_72
SG64ENTRY	,	V_85
pci_request_regions	,	F_53
device_map	,	V_100
host_int_status	,	V_217
ARCMSR_HBCMU_ALL_INTMASKENABLE	,	V_188
arcmsr_hbc_postqueue_isr	,	F_126
DataLength	,	V_258
dma_free_coherent	,	F_4
outbound_msgaddr1	,	V_397
arcmsr_polling_hba_ccbdone	,	F_153
roundup_ccbsize	,	V_71
pci_release_regs	,	V_141
iop_firm_version	,	V_379
"arcmsr%d: wait 'abort all outstanding command' timeout \n"	,	L_7
scsi_sg_count	,	F_139
acb_firm_model	,	V_373
max_sg_entrys	,	V_73
sense_buffer	,	V_174
scsi_scan_host	,	F_59
sc_data_direction	,	V_262
";(NL)		break;(NL)	case PCI_DEVICE_ID_ARECA_1380:(NL)	case PCI_DEVICE_ID_ARECA_1381:(NL)	case PCI_DEVICE_ID_ARECA_1680:(NL)	case PCI_DEVICE_ID_ARECA_1681:(NL)	case PCI_DEVICE_ID_ARECA_1880:(NL)		type = "	,	L_48
ARCMSR_DEV_INIT_FAIL	,	V_195
pdev	,	V_15
DID_OK	,	V_176
ARCMSR_DRV2IOP_DOORBELL	,	V_382
this_id	,	V_131
u32	,	T_8
QBUFFER	,	V_285
function	,	V_155
host	,	V_23
arcmsr_stop_adapter_bgrb	,	F_67
SYNCHRONIZE_CACHE	,	V_369
buffer	,	V_44
scsi_host_put	,	F_70
ARCMSR_DEV_CHECK_CONDITION	,	V_197
total_capacity	,	V_43
scsi_device_lookup	,	F_42
";(NL)		break;(NL)	}(NL)	sprintf(buf, "	,	L_50
CommandControlBlock	,	V_67
can_queue	,	V_129
ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK	,	V_284
pcmdmessagefld	,	V_322
"Areca RAID Controller%d: F/W %s &amp; Model %s\n"	,	L_21
ARCMSR_MU_OUTBOUND_POSTQUEUE_INT	,	V_315
RESERVATION_CONFLICT	,	V_372
scsi_done	,	V_171
", acb-&gt;host-&gt;host_no, retry_count);(NL)					if (retry_count &gt; ARCMSR_RETRYCOUNT) {(NL)						acb-&gt;fw_flag = FW_DEADLOCK;(NL)						printk(KERN_ERR "	,	L_41
spin_lock_irqsave	,	F_81
arcmsr_report_sense_info	,	F_83
arcmsr_polling_hbb_ccbdone	,	F_154
orig_mask	,	V_183
wqbuf_lastindex	,	V_302
");(NL)				return;(NL)			}(NL)		}(NL)		break;(NL)	case ACB_ADAPTER_TYPE_C:(NL)		return;(NL)	}(NL)	return;(NL)}(NL)(NL)static void arcmsr_hardware_reset(struct AdapterControlBlock *acb)(NL){(NL)	uint8_t value[64];(NL)	int i, count = 0;(NL)	struct MessageUnit_A __iomem *pmuA = acb-&gt;pmuA;(NL)	struct MessageUnit_C __iomem *pmuC = acb-&gt;pmuC;(NL)(NL)	/* backup pci config data */(NL)	printk(KERN_NOTICE "	,	L_37
pACB	,	V_56
kmap_atomic	,	F_137
arcmsr_do_interrupt	,	F_15
ccb_free_list	,	V_95
uncache_size	,	V_86
ARCMSR_MESSAGE_FAIL	,	V_327
arcmsr_drain_donequeue	,	F_86
"arcmsr%d: wait 'get adapter firmware \(NL)			miscellaneous data' timeout \n"	,	L_20
kunmap_atomic	,	F_141
DID_NO_CONNECT	,	V_193
head	,	V_358
ARCMSR_MESSAGE_RWBUFFER	,	V_389
Function	,	V_246
int16_t	,	V_354
ACB_F_IOPDATA_OVERFLOW	,	V_300
doneq_index	,	V_214
arcmsr_iop_message_xfer	,	F_135
writel	,	F_13
firm_config_version	,	V_74
arcmsr_get_firmware_spec	,	F_55
sg_dma_len	,	F_106
dev_id	,	V_33
arcmsr_probe	,	F_45
container_of	,	F_38
arcmsr_message_isr_bh_fn	,	F_37
message_rwbuffer	,	V_102
DID_BAD_TARGET	,	V_196
ccb_cdb_phy	,	V_216
", acb-&gt;host-&gt;host_no);(NL)	for (i = 0; i &lt; 64; i++) {(NL)		pci_read_config_byte(acb-&gt;pdev, i, &amp;value[i]);(NL)	}(NL)	/* hardware reset signal */(NL)	if ((acb-&gt;dev_id == 0x1680)) {(NL)		writel(ARCMSR_ARC1680_BUS_RESET, &amp;pmuA-&gt;reserved1[0]);(NL)	} else if ((acb-&gt;dev_id == 0x1880)) {(NL)		do {(NL)			count++;(NL)			writel(0xF, &amp;pmuC-&gt;write_sequence);(NL)			writel(0x4, &amp;pmuC-&gt;write_sequence);(NL)			writel(0xB, &amp;pmuC-&gt;write_sequence);(NL)			writel(0x2, &amp;pmuC-&gt;write_sequence);(NL)			writel(0x7, &amp;pmuC-&gt;write_sequence);(NL)			writel(0xD, &amp;pmuC-&gt;write_sequence);(NL)		} while (((readl(&amp;pmuC-&gt;host_diagnostic) &amp; ARCMSR_ARC1880_DiagWrite_ENABLE) == 0) &amp;&amp; (count &lt; 5));(NL)		writel(ARCMSR_ARC1880_RESET_ADAPTER, &amp;pmuC-&gt;host_diagnostic);(NL)	} else {(NL)		pci_write_config_byte(acb-&gt;pdev, 0x84, 0x20);(NL)	}(NL)	msleep(2000);(NL)	/* write back pci config data */(NL)	for (i = 0; i &lt; 64; i++) {(NL)		pci_write_config_byte(acb-&gt;pdev, i, value[i]);(NL)	}(NL)	msleep(1000);(NL)	return;(NL)}(NL)static void arcmsr_iop_init(struct AdapterControlBlock *acb)(NL){(NL)	uint32_t intmask_org;(NL)	/* disable all outbound interrupt */(NL)	intmask_org = arcmsr_disable_outbound_ints(acb);(NL)	arcmsr_wait_firmware_ready(acb);(NL)	arcmsr_iop_confirm(acb);(NL)	/*start background rebuild*/(NL)	arcmsr_start_adapter_bgrb(acb);(NL)	/* empty doorbell Qbuffer if door bell ringed */(NL)	arcmsr_clear_doorbell_queue_buffer(acb);(NL)	arcmsr_enable_eoi_mode(acb);(NL)	/* enable outbound Post Queue,outbound doorbell Interrupt */(NL)	arcmsr_enable_outbound_ints(acb, intmask_org);(NL)	acb-&gt;acb_flags |= ACB_F_IOP_INITED;(NL)}(NL)(NL)static uint8_t arcmsr_iop_reset(struct AdapterControlBlock *acb)(NL){(NL)	struct CommandControlBlock *ccb;(NL)	uint32_t intmask_org;(NL)	uint8_t rtnval = 0x00;(NL)	int i = 0;(NL)	unsigned long flags;(NL)(NL)	if (atomic_read(&amp;acb-&gt;ccboutstandingcount) != 0) {(NL)		/* disable all outbound interrupt */(NL)		intmask_org = arcmsr_disable_outbound_ints(acb);(NL)		/* talk to iop 331 outstanding command aborted */(NL)		rtnval = arcmsr_abort_allcmd(acb);(NL)		/* clear all outbound posted Q */(NL)		arcmsr_done4abort_postqueue(acb);(NL)		for (i = 0; i &lt; ARCMSR_MAX_FREECCB_NUM; i++) {(NL)			ccb = acb-&gt;pccb_pool[i];(NL)			if (ccb-&gt;startdone == ARCMSR_CCB_START) {(NL)				scsi_dma_unmap(ccb-&gt;pcmd);(NL)				ccb-&gt;startdone = ARCMSR_CCB_DONE;(NL)				ccb-&gt;ccb_flags = 0;(NL)				spin_lock_irqsave(&amp;acb-&gt;ccblist_lock, flags);(NL)				list_add_tail(&amp;ccb-&gt;list, &amp;acb-&gt;ccb_free_list);(NL)				spin_unlock_irqrestore(&amp;acb-&gt;ccblist_lock, flags);(NL)			}(NL)		}(NL)		atomic_set(&amp;acb-&gt;ccboutstandingcount, 0);(NL)		/* enable all outbound interrupt */(NL)		arcmsr_enable_outbound_ints(acb, intmask_org);(NL)		return rtnval;(NL)	}(NL)	return rtnval;(NL)}(NL)(NL)static int arcmsr_bus_reset(struct scsi_cmnd *cmd)(NL){(NL)	struct AdapterControlBlock *acb;(NL)	uint32_t intmask_org, outbound_doorbell;(NL)	int retry_count = 0;(NL)	int rtn = FAILED;(NL)	acb = (struct AdapterControlBlock *) cmd-&gt;device-&gt;host-&gt;hostdata;(NL)	printk(KERN_ERR "	,	L_38
reason	,	V_4
arcmsr_iop2drv_data_wrote_handle	,	F_119
spin_lock_init	,	F_54
message_wbuffer	,	V_289
allxfer_len	,	V_304
dma_addr_t	,	T_6
arcmsr_done4abort_postqueue	,	F_88
arcmsr_shutdown	,	F_95
ARCMSR_DEV_SELECT_TIMEOUT	,	V_192
ARCMSR_HBCMU_UTILITY_A_ISR_MASK	,	V_232
msleep	,	F_24
arcmsr_iop_init	,	F_56
RAID_controller_stop	,	V_144
ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR_MASK	,	V_234
ARCMSR_CCBPOST_FLAG_SGL_BSIZE	,	V_267
ptmpuserbuffer	,	V_342
READ_BUFFER	,	V_365
pci_unregister_driver	,	F_99
psge	,	V_235
arcmsr_remap_pciregion	,	F_5
"R001"	,	L_18
MSG_ORDERED_TAG	,	V_8
" ccboutstandingcount = %d \n"	,	L_13
pacb	,	V_161
mem_base0	,	V_25
mem_base1	,	V_26
firm_version	,	V_376
prbuffer	,	V_290
request_irq	,	F_58
eternal_timer	,	V_150
ARCMSR_MAX_QBUFFER	,	V_298
devfn	,	V_124
fw_flag	,	V_148
ARCMSR_CDB	,	V_204
arcmsr_interrupt	,	F_16
";(NL)		break;(NL)	default:(NL)		type = "	,	L_49
cdb_phyaddr	,	V_70
polling_hbc_ccb_retry	,	V_405
uint8_t	,	T_5
GFP_KERNEL	,	V_88
arcmsr_iop_parking	,	F_133
acb_device_map	,	V_377
",(NL)			type, raid6 ? "	,	L_51
ARCMSR_MESSAGE_GET_CONFIG	,	V_390
");(NL)			} else {(NL)				acb-&gt;acb_flags &amp;= ~ACB_F_BUS_RESET;(NL)				atomic_set(&amp;acb-&gt;rq_map_token, 16);(NL)				atomic_set(&amp;acb-&gt;ante_token_value, 16);(NL)				acb-&gt;fw_flag = FW_NORMAL;(NL)				mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6*HZ));(NL)				rtn = SUCCESS;(NL)			}(NL)			break;(NL)		}(NL)		case ACB_ADAPTER_TYPE_B:{(NL)			acb-&gt;acb_flags |= ACB_F_BUS_RESET;(NL)			if (!arcmsr_iop_reset(acb)) {(NL)				acb-&gt;acb_flags &amp;= ~ACB_F_BUS_RESET;(NL)				rtn = FAILED;(NL)			} else {(NL)				acb-&gt;acb_flags &amp;= ~ACB_F_BUS_RESET;(NL)				atomic_set(&amp;acb-&gt;rq_map_token, 16);(NL)				atomic_set(&amp;acb-&gt;ante_token_value, 16);(NL)				acb-&gt;fw_flag = FW_NORMAL;(NL)				mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)				rtn = SUCCESS;(NL)			}(NL)			break;(NL)		}(NL)		case ACB_ADAPTER_TYPE_C:{(NL)			if (acb-&gt;acb_flags &amp; ACB_F_BUS_RESET) {(NL)				long timeout;(NL)				printk(KERN_ERR "	,	L_43
roundup	,	F_32
device	,	V_189
scsi_bufflen	,	F_110
address_lo	,	V_237
arcmsr_stop_hbb_bgrb	,	F_113
message_rbuffer	,	V_287
ARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON	,	V_338
arcmsr_hba_wait_msgint_ready	,	F_23
");(NL)				timeout = wait_event_timeout(wait_q, (acb-&gt;acb_flags &amp; ACB_F_BUS_RESET) == 0, 220*HZ);(NL)				if (timeout) {(NL)					return SUCCESS;(NL)				}(NL)			}(NL)			acb-&gt;acb_flags |= ACB_F_BUS_RESET;(NL)			if (!arcmsr_iop_reset(acb)) {(NL)				struct MessageUnit_C __iomem *reg;(NL)				reg = acb-&gt;pmuC;(NL)				arcmsr_hardware_reset(acb);(NL)				acb-&gt;acb_flags &amp;= ~ACB_F_IOP_INITED;(NL)sleep:(NL)				ssleep(ARCMSR_SLEEPTIME);(NL)				if ((readl(&amp;reg-&gt;host_diagnostic) &amp; 0x04) != 0) {(NL)					printk(KERN_ERR "	,	L_44
list_del_init	,	F_145
scsi_remove_host	,	F_66
arcmsr_handle_hba_isr	,	F_130
iop_len	,	V_294
sg	,	V_242
"arcmsr"	,	L_6
ACB_F_MESSAGE_RQBUFFER_CLEARED	,	V_138
max_id	,	V_127
ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK	,	V_309
"arcmsr%d: pCCB ='0x%p' isr got aborted command \n"	,	L_10
scsi_partsize	,	F_19
arcmsr_alloc_ccb_pool	,	F_31
Context	,	V_247
scatterlist	,	V_241
arcmsr_get_iop_rqbuffer	,	F_117
atomic_read	,	F_87
pwbuffer	,	V_303
addresshigh	,	V_255
msgPages	,	V_259
cdb_phyaddr_hi32	,	V_273
uint32_t	,	T_7
Flags	,	V_260
scsi_sglist	,	F_136
iop_firm_model	,	V_378
rtn	,	V_402
arcmsr_iop_message_read	,	F_115
", acb-&gt;host-&gt;host_no);(NL)	}(NL)}(NL)(NL)static void arcmsr_start_hbb_bgrb(struct AdapterControlBlock *acb)(NL){(NL)	struct MessageUnit_B *reg = acb-&gt;pmuB;(NL)	acb-&gt;acb_flags |= ACB_F_MSG_START_BGRB;(NL)	writel(ARCMSR_MESSAGE_START_BGRB, reg-&gt;drv2iop_doorbell);(NL)	if (!arcmsr_hbb_wait_msgint_ready(acb)) {(NL)		printk(KERN_NOTICE "	,	L_34
buf	,	V_408
arcmsr_flush_hbc_cache	,	F_29
ACB_F_MESSAGE_WQBUFFER_READED	,	V_139
bus	,	V_115
__iomem	,	T_1
vir2phy_offset	,	V_90
pARCMSR_CDB	,	V_205
rqbuf_lastindex	,	V_296
arcmsr_hbc_wait_msgint_ready	,	F_26
INIT_LIST_HEAD	,	F_35
DID_ERROR	,	V_366
scsi_host_alloc	,	F_47
pci_set_master	,	F_52
sensebuffer	,	V_173
ARCMSR_MAX_XFER_LEN	,	V_79
ARCMSR_MAX_FREECCB_NUM	,	V_87
firm_sdram_size	,	V_393
arcmsr_hbc_message_isr	,	F_123
dev_fun	,	V_116
acb_firm_version	,	V_375
ARCMSR_HBC_ISR_THROTTLING_LEVEL	,	V_311
add_timer	,	F_64
phbcmu	,	V_58
data_len	,	V_297
ARCMSR_MESSAGE_RBUFFER	,	V_388
" poll command abort successfully \n"	,	L_23
DID_TIME_OUT	,	V_362
"scsi%d: No suitable DMA mask available\n"	,	L_5
SCSI_SENSE_BUFFERSIZE	,	V_178
scsi_dma_map	,	F_102
ioremap	,	F_6
int8_t	,	T_9
arcmsr_disable_outbound_ints	,	F_84
pci_dev	,	V_20
FW_DEADLOCK	,	V_336
max_sectors	,	V_83
SenseData	,	V_179
arccdbsize	,	V_239
", acb-&gt;host-&gt;host_no);(NL)						return FAILED;(NL)					}(NL)					retry_count++;(NL)					goto sleep_again;(NL)				}(NL)				acb-&gt;acb_flags |= ACB_F_IOP_INITED;(NL)				/* disable all outbound interrupt */(NL)				intmask_org = arcmsr_disable_outbound_ints(acb);(NL)				arcmsr_get_firmware_spec(acb);(NL)				arcmsr_start_adapter_bgrb(acb);(NL)				/* clear Qbuffer if door bell ringed */(NL)				outbound_doorbell = readl(&amp;reg-&gt;outbound_doorbell);(NL)				writel(outbound_doorbell, &amp;reg-&gt;outbound_doorbell); /*clear interrupt */(NL)   				writel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &amp;reg-&gt;inbound_doorbell);(NL)				/* enable outbound Post Queue,outbound doorbell Interrupt */(NL)				arcmsr_enable_outbound_ints(acb, intmask_org);(NL)				atomic_set(&amp;acb-&gt;rq_map_token, 16);(NL)				atomic_set(&amp;acb-&gt;ante_token_value, 16);(NL)				acb-&gt;fw_flag = FW_NORMAL;(NL)				mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)				acb-&gt;acb_flags &amp;= ~ACB_F_BUS_RESET;(NL)				rtn = SUCCESS;(NL)				printk(KERN_ERR "	,	L_42
arcmsr_hba_message_isr	,	F_127
wqbuffer	,	V_305
ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK	,	V_282
next	,	V_359
expires	,	V_151
address_hi	,	V_238
host_no	,	V_24
SCSI_MLQUEUE_HOST_BUSY	,	V_371
devicemap	,	V_103
printk	,	F_9
arcmsr_free_sysfs_attr	,	F_91
arcmsr_get_hbb_config	,	F_149
firm_request_len	,	V_391
arcmsr_report_ccb_state	,	F_85
throttling	,	V_310
cpu_to_le32	,	F_105
AdapterControlBlock	,	V_9
ARCMSR_DRV2IOP_CDB_POSTED	,	V_271
ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE	,	V_63
", acb-&gt;num_resets, acb-&gt;num_aborts);(NL)	acb-&gt;num_resets++;(NL)(NL)	switch(acb-&gt;adapter_type){(NL)		case ACB_ADAPTER_TYPE_A:{(NL)			if (acb-&gt;acb_flags &amp; ACB_F_BUS_RESET){(NL)				long timeout;(NL)				printk(KERN_ERR "	,	L_39
scsi_add_host	,	F_57
outbound_queueport_low	,	V_219
mask	,	V_225
dma_coherent_handle_hbb_mu	,	V_19
pdma_sg	,	V_253
MessageUnit_A	,	V_46
MessageUnit_C	,	V_57
MessageUnit_B	,	V_17
target	,	V_104
pci_device_id	,	V_112
arcmsr_abort_hbb_allcmd	,	F_73
__le32	,	T_10
",acb-&gt;host-&gt;host_no);(NL)			return 1;(NL)		}(NL)		arcmsr_hbb_enable_driver_mode(acb);(NL)		arcmsr_enable_outbound_ints(acb, intmask_org);(NL)		}(NL)		break;(NL)	case ACB_ADAPTER_TYPE_C: {(NL)		if (cdb_phyaddr_hi32 != 0) {(NL)			struct MessageUnit_C *reg = (struct MessageUnit_C *)acb-&gt;pmuC;(NL)(NL)			printk(KERN_NOTICE "	,	L_31
arcmsr_stop_hba_bgrb	,	F_112
ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE	,	V_356
arcmsr_queue_command_lck	,	F_147
sdev	,	V_2
arcmsr_iop2drv_data_read_handle	,	F_120
ACB_ADAPTER_TYPE_C	,	V_13
ACB_ADAPTER_TYPE_B	,	V_14
INQUIRY	,	V_360
"arcmsr%d: scsi id = %d lun = %d isr get command error done, \(NL)				but got unknown DeviceStatus = 0x%x \n"	,	L_9
", pACB-&gt;host-&gt;host_no);(NL)	}(NL)	return;(NL)}(NL)static void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb)(NL){(NL)	switch (acb-&gt;adapter_type) {(NL)	case ACB_ADAPTER_TYPE_A:(NL)		arcmsr_start_hba_bgrb(acb);(NL)		break;(NL)	case ACB_ADAPTER_TYPE_B:(NL)		arcmsr_start_hbb_bgrb(acb);(NL)		break;(NL)	case ACB_ADAPTER_TYPE_C:(NL)		arcmsr_start_hbc_bgrb(acb);(NL)	}(NL)}(NL)(NL)static void arcmsr_clear_doorbell_queue_buffer(struct AdapterControlBlock *acb)(NL){(NL)	switch (acb-&gt;adapter_type) {(NL)	case ACB_ADAPTER_TYPE_A: {(NL)		struct MessageUnit_A __iomem *reg = acb-&gt;pmuA;(NL)		uint32_t outbound_doorbell;(NL)		/* empty doorbell Qbuffer if door bell ringed */(NL)		outbound_doorbell = readl(&amp;reg-&gt;outbound_doorbell);(NL)		/*clear doorbell interrupt */(NL)		writel(outbound_doorbell, &amp;reg-&gt;outbound_doorbell);(NL)		writel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &amp;reg-&gt;inbound_doorbell);(NL)		}(NL)		break;(NL)(NL)	case ACB_ADAPTER_TYPE_B: {(NL)		struct MessageUnit_B *reg = acb-&gt;pmuB;(NL)		/*clear interrupt and message state*/(NL)		writel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg-&gt;iop2drv_doorbell);(NL)		writel(ARCMSR_DRV2IOP_DATA_READ_OK, reg-&gt;drv2iop_doorbell);(NL)		/* let IOP know data has been read */(NL)		}(NL)		break;(NL)	case ACB_ADAPTER_TYPE_C: {(NL)		struct MessageUnit_C *reg = (struct MessageUnit_C *)acb-&gt;pmuC;(NL)		uint32_t outbound_doorbell;(NL)		/* empty doorbell Qbuffer if door bell ringed */(NL)		outbound_doorbell = readl(&amp;reg-&gt;outbound_doorbell);(NL)		writel(outbound_doorbell, &amp;reg-&gt;outbound_doorbell_clear);(NL)		writel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &amp;reg-&gt;inbound_doorbell);(NL)		}(NL)	}(NL)}(NL)(NL)static void arcmsr_enable_eoi_mode(struct AdapterControlBlock *acb)(NL){(NL)	switch (acb-&gt;adapter_type) {(NL)	case ACB_ADAPTER_TYPE_A:(NL)		return;(NL)	case ACB_ADAPTER_TYPE_B:(NL)		{(NL)			struct MessageUnit_B *reg = acb-&gt;pmuB;(NL)			writel(ARCMSR_MESSAGE_ACTIVE_EOI_MODE, reg-&gt;drv2iop_doorbell);(NL)			if (!arcmsr_hbb_wait_msgint_ready(acb)) {(NL)				printk(KERN_NOTICE "	,	L_36
eh_lock	,	V_134
ACB_ADAPTER_TYPE_A	,	V_12
pcmd	,	V_166
rqbuffer	,	V_299
ccb_post_stamp	,	V_272
scsi_dma_unmap	,	F_78
scsi_adjust_queue_depth	,	F_2
"arcmsr%d: wait 'flush adapter cache' \(NL)			timeout, retry count down = %d \n"	,	L_2
ARCMSR_MESSAGE_READ_RQBUFFER	,	V_329
list_empty	,	F_143
geom	,	V_38
ARCMSR_SIGNATURE_GET_CONFIG	,	V_109
arcmsr_free_ccb_pool	,	F_68
"arcmsr%d: isr get an illegal ccb command \(NL)				done acb = '0x%p'"	,	L_11
TargetID	,	V_244
ACB_F_MSG_START_BGRB	,	V_276
SCSI_SENSE_CURRENT_ERRORS	,	V_181
done_qbuffer	,	V_212
FAILED	,	V_251
init_waitqueue_head	,	F_50
scsi_device	,	V_1
ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR	,	V_317
DMA_TO_DEVICE	,	V_263
SENSE_DATA	,	V_172
del_timer_sync	,	F_93
arcmsr_flush_hba_cache	,	F_27
out_free_sysfs	,	V_157
ARCMSR_IOP2DRV_DOORBELL_MASK	,	V_386
arcmsr_module_exit	,	F_98
work	,	V_97
ARCMSR_CDB_FLAG_SGL_BSIZE	,	V_261
firm_numbers_queue	,	V_392
ARCMSR_MU_OUTBOUND_HANDLE_INT	,	V_313
devstate	,	V_77
ccblist_lock	,	V_135
arcmsr_abort_hba_allcmd	,	F_72
host_scribble	,	V_368
"RAID controller "	,	L_17
Valid	,	V_182
SEND_DIAGNOSTIC	,	V_370
"arcmsr%d: memory mapping region fail \n"	,	L_1
arcmsr_enable_outbound_ints	,	F_100
max_cmd_len	,	V_128
arcmsr_handle_hbb_isr	,	F_131
ENODEV	,	V_117
poll_ccb	,	V_400
kfree	,	F_20
signature	,	V_101
flags	,	V_167
ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE	,	V_29
hostdata	,	V_125
AdditionalSenseCode	,	V_346
capacity	,	V_37
FW_NORMAL	,	V_149
ARCMSR_CDB_FLAG_WRITE	,	V_264
arcmsr_module_init	,	F_96
arcmsr_pci_unmap_dma	,	F_77
offsetof	,	F_34
arcmsr_remove	,	F_89
rqbuf_firstindex	,	V_295
ARCMSR_INBOUND_MESG0_FLUSH_CACHE	,	V_60
cdb_phyaddr_pattern	,	V_92
inbound_queueport	,	V_268
firmware_state	,	V_396
rq_map_token	,	V_108
scsi_remove_device	,	F_43
DID_ABORT	,	V_202
ARCMSR_MESSAGE_SAY_GOODBYE	,	V_355
ACB_F_SCSISTOPADAPTER	,	V_140
ARCMSR_CDB_SG_PAGE_LENGTH	,	V_82
inbound_msgaddr0	,	V_61
udelay	,	F_151
ARCMSR_MESSAGE_START_DRIVER_MODE	,	V_162
heads	,	V_40
transfer_len	,	V_324
ARCMSR_MESSAGE_ABORT_CMD	,	V_159
outbound_int_enable	,	V_206
user_len	,	V_341
data	,	V_154
ARCMSR_INBOUND_MESG0_GET_CONFIG	,	V_399
ARCMSR_MAX_CMD_PERLUN	,	V_7
atomic_inc	,	F_39
ARCMSR_IOP2DRV_DATA_READ_OK	,	V_230
pci_enable_device	,	F_46
block_device	,	V_35
cmnd	,	V_249
"arcmsr%d: wait 'flush adapter cache' \(NL)			timeout,retry count down = %d \n"	,	L_3
Scsi_Host	,	V_114
arcmsr_abort_allcmd	,	F_75
ARCMSR_IOP2DRV_DOORBELL	,	V_385
arcmsr_hbc_doorbell_isr	,	F_122
ver_addr	,	V_330
",(NL)				acb-&gt;host-&gt;host_no);(NL)				return 1;(NL)			}(NL)			arcmsr_enable_outbound_ints(acb, intmask_org);(NL)		}(NL)		}(NL)		break;(NL)(NL)	case ACB_ADAPTER_TYPE_B: {(NL)		unsigned long post_queue_phyaddr;(NL)		uint32_t __iomem *rwbuffer;(NL)(NL)		struct MessageUnit_B *reg = acb-&gt;pmuB;(NL)		uint32_t intmask_org;(NL)		intmask_org = arcmsr_disable_outbound_ints(acb);(NL)		reg-&gt;postq_index = 0;(NL)		reg-&gt;doneq_index = 0;(NL)		writel(ARCMSR_MESSAGE_SET_POST_WINDOW, reg-&gt;drv2iop_doorbell);(NL)		if (!arcmsr_hbb_wait_msgint_ready(acb)) {(NL)			printk(KERN_NOTICE "	,	L_28
int32_t	,	T_11
", acb-&gt;host-&gt;host_no);(NL)						return FAILED;(NL)					}(NL)					retry_count++;(NL)					goto sleep;(NL)				}(NL)				acb-&gt;acb_flags |= ACB_F_IOP_INITED;(NL)				/* disable all outbound interrupt */(NL)				intmask_org = arcmsr_disable_outbound_ints(acb);(NL)				arcmsr_get_firmware_spec(acb);(NL)				arcmsr_start_adapter_bgrb(acb);(NL)				/* clear Qbuffer if door bell ringed */(NL)				outbound_doorbell = readl(&amp;reg-&gt;outbound_doorbell);(NL)				writel(outbound_doorbell, &amp;reg-&gt;outbound_doorbell_clear); /*clear interrupt */(NL)				writel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &amp;reg-&gt;inbound_doorbell);(NL)				/* enable outbound Post Queue,outbound doorbell Interrupt */(NL)				arcmsr_enable_outbound_ints(acb, intmask_org);(NL)				atomic_set(&amp;acb-&gt;rq_map_token, 16);(NL)				atomic_set(&amp;acb-&gt;ante_token_value, 16);(NL)				acb-&gt;fw_flag = FW_NORMAL;(NL)				mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));(NL)				acb-&gt;acb_flags &amp;= ~ACB_F_BUS_RESET;(NL)				rtn = SUCCESS;(NL)				printk(KERN_ERR "	,	L_45
host_int_mask	,	V_187
atomic_dec	,	F_80
unique_id	,	V_133
offset	,	V_326
dma_addr_hi32	,	F_109
arcmsr_hbb_message_isr	,	F_129
ARCMSR_MESSAGE_CLEAR_WQBUFFER	,	V_348
dma_addr_lo32	,	F_107
dma_coherent	,	V_65
arcmsr_scsi_host_template	,	V_118
scsi_host_release	,	V_121
done	,	F_148
");(NL)			} else {(NL)				acb-&gt;acb_flags &amp;= ~ACB_F_BUS_RESET;(NL)				atomic_set(&amp;acb-&gt;rq_map_token, 16);(NL)				atomic_set(&amp;acb-&gt;ante_token_value, 16);(NL)				acb-&gt;fw_flag = FW_NORMAL;(NL)				mod_timer(&amp;acb-&gt;eternal_timer, jiffies + msecs_to_jiffies(6*HZ));(NL)				rtn = SUCCESS;(NL)			}(NL)			break;(NL)		}(NL)	}(NL)	return rtn;(NL)}(NL)(NL)static int arcmsr_abort_one_cmd(struct AdapterControlBlock *acb,(NL)		struct CommandControlBlock *ccb)(NL){(NL)	int rtn;(NL)	rtn = arcmsr_polling_ccbdone(acb, ccb);(NL)	return rtn;(NL)}(NL)(NL)static int arcmsr_abort(struct scsi_cmnd *cmd)(NL){(NL)	struct AdapterControlBlock *acb =(NL)		(struct AdapterControlBlock *)cmd-&gt;device-&gt;host-&gt;hostdata;(NL)	int i = 0;(NL)	int rtn = FAILED;(NL)	printk(KERN_NOTICE(NL)		"	,	L_46
arcmsr_adjust_disk_queue_depth	,	F_1
pci_resource_start	,	F_7
ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK	,	V_306
arcmsr_post_ioctldata2iop	,	F_134
acb_dev_map	,	V_99
ARCMSR_DEV_ABORTED	,	V_194
pci_register_driver	,	F_97
schedule_work	,	F_128
arcmsr_iop_confirm	,	F_157
post_qbuffer	,	V_213
ARCMSR_CCB_ABORTED	,	V_200
"arcmsr%d: dma_alloc_coherent got error for hbb mu\n"	,	L_19
ARCMSR_MESSAGE_CLEAR_ALLQBUFFER	,	V_349
ARCMSR_SCSI_INITIATOR_ID	,	V_132
arcmsr_get_hbc_config	,	F_150
firm_hd_channels	,	V_394
ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE	,	V_226
polling_hba_ccb_retry	,	V_403
msecs_to_jiffies	,	F_63
ARCMSR_CCB_DONE	,	V_170
outbound_queueport	,	V_207
scsi_bios_ptable	,	F_18
ARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE	,	V_228
", \(NL)				acb-&gt;host-&gt;host_no);(NL)			return 1;(NL)		}(NL)		post_queue_phyaddr = acb-&gt;dma_coherent_handle_hbb_mu;(NL)		rwbuffer = reg-&gt;message_rwbuffer;(NL)		/* driver "	,	L_29
"arcmsr%d: wait 'stop adapter background rebulid' timeout \n"	,	L_14
IRQF_SHARED	,	V_145
PCI_DEVICE_ID	,	V_45
temp	,	V_110
readl	,	F_12
arcmsr_hbb_wait_msgint_ready	,	F_25
LUN	,	V_245
list_head	,	V_357
ARCMSR_MESSAGE_CLEAR_RQBUFFER	,	V_347
ARCMSR_MESSAGE_WBUFFER	,	V_387
irqreturn_t	,	T_2
ARCMSR_DRV2IOP_DATA_READ_OK	,	V_280
cmdmessage	,	V_334
ARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE	,	V_227
ARCMSR_IOP2DRV_CDB_DONE	,	V_231
poll_ccb_done	,	V_401
ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR	,	V_30
ccboutstandingcount	,	V_168
sgcount	,	V_257
arcmsr_iop_message_wrote	,	F_116
KERN_ERR	,	V_163
startdone	,	V_169
readb	,	F_40
