static inline struct capi_ctr *\r\ncapi_ctr_get(struct capi_ctr *ctr)\r\n{\r\nif (!try_module_get(ctr->owner))\r\nreturn NULL;\r\nreturn ctr;\r\n}\r\nstatic inline void\r\ncapi_ctr_put(struct capi_ctr *ctr)\r\n{\r\nmodule_put(ctr->owner);\r\n}\r\nstatic inline struct capi_ctr *get_capi_ctr_by_nr(u16 contr)\r\n{\r\nif (contr - 1 >= CAPI_MAXCONTR)\r\nreturn NULL;\r\nreturn capi_controller[contr - 1];\r\n}\r\nstatic inline struct capi20_appl *__get_capi_appl_by_nr(u16 applid)\r\n{\r\nlockdep_assert_held(&capi_controller_lock);\r\nif (applid - 1 >= CAPI_MAXAPPL)\r\nreturn NULL;\r\nreturn capi_applications[applid - 1];\r\n}\r\nstatic inline struct capi20_appl *get_capi_appl_by_nr(u16 applid)\r\n{\r\nif (applid - 1 >= CAPI_MAXAPPL)\r\nreturn NULL;\r\nreturn rcu_dereference(capi_applications[applid - 1]);\r\n}\r\nstatic inline int capi_cmd_valid(u8 cmd)\r\n{\r\nswitch (cmd) {\r\ncase CAPI_ALERT:\r\ncase CAPI_CONNECT:\r\ncase CAPI_CONNECT_ACTIVE:\r\ncase CAPI_CONNECT_B3_ACTIVE:\r\ncase CAPI_CONNECT_B3:\r\ncase CAPI_CONNECT_B3_T90_ACTIVE:\r\ncase CAPI_DATA_B3:\r\ncase CAPI_DISCONNECT_B3:\r\ncase CAPI_DISCONNECT:\r\ncase CAPI_FACILITY:\r\ncase CAPI_INFO:\r\ncase CAPI_LISTEN:\r\ncase CAPI_MANUFACTURER:\r\ncase CAPI_RESET_B3:\r\ncase CAPI_SELECT_B_PROTOCOL:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int capi_subcmd_valid(u8 subcmd)\r\n{\r\nswitch (subcmd) {\r\ncase CAPI_REQ:\r\ncase CAPI_CONF:\r\ncase CAPI_IND:\r\ncase CAPI_RESP:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nregister_appl(struct capi_ctr *ctr, u16 applid, capi_register_params *rparam)\r\n{\r\nctr = capi_ctr_get(ctr);\r\nif (ctr)\r\nctr->register_appl(ctr, applid, rparam);\r\nelse\r\nprintk(KERN_WARNING "%s: cannot get controller resources\n",\r\n__func__);\r\n}\r\nstatic void release_appl(struct capi_ctr *ctr, u16 applid)\r\n{\r\nDBG("applid %#x", applid);\r\nctr->release_appl(ctr, applid);\r\ncapi_ctr_put(ctr);\r\n}\r\nstatic void notify_up(u32 contr)\r\n{\r\nstruct capi20_appl *ap;\r\nstruct capi_ctr *ctr;\r\nu16 applid;\r\nmutex_lock(&capi_controller_lock);\r\nif (showcapimsgs & 1)\r\nprintk(KERN_DEBUG "kcapi: notify up contr %d\n", contr);\r\nctr = get_capi_ctr_by_nr(contr);\r\nif (ctr) {\r\nif (ctr->state == CAPI_CTR_RUNNING)\r\ngoto unlock_out;\r\nctr->state = CAPI_CTR_RUNNING;\r\nfor (applid = 1; applid <= CAPI_MAXAPPL; applid++) {\r\nap = __get_capi_appl_by_nr(applid);\r\nif (ap)\r\nregister_appl(ctr, applid, &ap->rparam);\r\n}\r\nwake_up_interruptible_all(&ctr->state_wait_queue);\r\n} else\r\nprintk(KERN_WARNING "%s: invalid contr %d\n", __func__, contr);\r\nunlock_out:\r\nmutex_unlock(&capi_controller_lock);\r\n}\r\nstatic void ctr_down(struct capi_ctr *ctr, int new_state)\r\n{\r\nstruct capi20_appl *ap;\r\nu16 applid;\r\nif (ctr->state == CAPI_CTR_DETECTED || ctr->state == CAPI_CTR_DETACHED)\r\nreturn;\r\nctr->state = new_state;\r\nmemset(ctr->manu, 0, sizeof(ctr->manu));\r\nmemset(&ctr->version, 0, sizeof(ctr->version));\r\nmemset(&ctr->profile, 0, sizeof(ctr->profile));\r\nmemset(ctr->serial, 0, sizeof(ctr->serial));\r\nfor (applid = 1; applid <= CAPI_MAXAPPL; applid++) {\r\nap = __get_capi_appl_by_nr(applid);\r\nif (ap)\r\ncapi_ctr_put(ctr);\r\n}\r\nwake_up_interruptible_all(&ctr->state_wait_queue);\r\n}\r\nstatic void notify_down(u32 contr)\r\n{\r\nstruct capi_ctr *ctr;\r\nmutex_lock(&capi_controller_lock);\r\nif (showcapimsgs & 1)\r\nprintk(KERN_DEBUG "kcapi: notify down contr %d\n", contr);\r\nctr = get_capi_ctr_by_nr(contr);\r\nif (ctr)\r\nctr_down(ctr, CAPI_CTR_DETECTED);\r\nelse\r\nprintk(KERN_WARNING "%s: invalid contr %d\n", __func__, contr);\r\nmutex_unlock(&capi_controller_lock);\r\n}\r\nstatic int\r\nnotify_handler(struct notifier_block *nb, unsigned long val, void *v)\r\n{\r\nu32 contr = (long)v;\r\nswitch (val) {\r\ncase CAPICTR_UP:\r\nnotify_up(contr);\r\nbreak;\r\ncase CAPICTR_DOWN:\r\nnotify_down(contr);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void do_notify_work(struct work_struct *work)\r\n{\r\nstruct capictr_event *event =\r\ncontainer_of(work, struct capictr_event, work);\r\nblocking_notifier_call_chain(&ctr_notifier_list, event->type,\r\n(void *)(long)event->controller);\r\nkfree(event);\r\n}\r\nstatic int notify_push(unsigned int event_type, u32 controller)\r\n{\r\nstruct capictr_event *event = kmalloc(sizeof(*event), GFP_ATOMIC);\r\nif (!event)\r\nreturn -ENOMEM;\r\nINIT_WORK(&event->work, do_notify_work);\r\nevent->type = event_type;\r\nevent->controller = controller;\r\nqueue_work(kcapi_wq, &event->work);\r\nreturn 0;\r\n}\r\nint register_capictr_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&ctr_notifier_list, nb);\r\n}\r\nint unregister_capictr_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&ctr_notifier_list, nb);\r\n}\r\nstatic void recv_handler(struct work_struct *work)\r\n{\r\nstruct sk_buff *skb;\r\nstruct capi20_appl *ap =\r\ncontainer_of(work, struct capi20_appl, recv_work);\r\nif ((!ap) || (ap->release_in_progress))\r\nreturn;\r\nmutex_lock(&ap->recv_mtx);\r\nwhile ((skb = skb_dequeue(&ap->recv_queue))) {\r\nif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_IND)\r\nap->nrecvdatapkt++;\r\nelse\r\nap->nrecvctlpkt++;\r\nap->recv_message(ap, skb);\r\n}\r\nmutex_unlock(&ap->recv_mtx);\r\n}\r\nvoid capi_ctr_handle_message(struct capi_ctr *ctr, u16 appl,\r\nstruct sk_buff *skb)\r\n{\r\nstruct capi20_appl *ap;\r\nint showctl = 0;\r\nu8 cmd, subcmd;\r\n_cdebbuf *cdb;\r\nif (ctr->state != CAPI_CTR_RUNNING) {\r\ncdb = capi_message2str(skb->data);\r\nif (cdb) {\r\nprintk(KERN_INFO "kcapi: controller [%03d] not active, got: %s",\r\nctr->cnr, cdb->buf);\r\ncdebbuf_free(cdb);\r\n} else\r\nprintk(KERN_INFO "kcapi: controller [%03d] not active, cannot trace\n",\r\nctr->cnr);\r\ngoto error;\r\n}\r\ncmd = CAPIMSG_COMMAND(skb->data);\r\nsubcmd = CAPIMSG_SUBCOMMAND(skb->data);\r\nif (cmd == CAPI_DATA_B3 && subcmd == CAPI_IND) {\r\nctr->nrecvdatapkt++;\r\nif (ctr->traceflag > 2)\r\nshowctl |= 2;\r\n} else {\r\nctr->nrecvctlpkt++;\r\nif (ctr->traceflag)\r\nshowctl |= 2;\r\n}\r\nshowctl |= (ctr->traceflag & 1);\r\nif (showctl & 2) {\r\nif (showctl & 1) {\r\nprintk(KERN_DEBUG "kcapi: got [%03d] id#%d %s len=%u\n",\r\nctr->cnr, CAPIMSG_APPID(skb->data),\r\ncapi_cmd2str(cmd, subcmd),\r\nCAPIMSG_LEN(skb->data));\r\n} else {\r\ncdb = capi_message2str(skb->data);\r\nif (cdb) {\r\nprintk(KERN_DEBUG "kcapi: got [%03d] %s\n",\r\nctr->cnr, cdb->buf);\r\ncdebbuf_free(cdb);\r\n} else\r\nprintk(KERN_DEBUG "kcapi: got [%03d] id#%d %s len=%u, cannot trace\n",\r\nctr->cnr, CAPIMSG_APPID(skb->data),\r\ncapi_cmd2str(cmd, subcmd),\r\nCAPIMSG_LEN(skb->data));\r\n}\r\n}\r\nrcu_read_lock();\r\nap = get_capi_appl_by_nr(CAPIMSG_APPID(skb->data));\r\nif (!ap) {\r\nrcu_read_unlock();\r\ncdb = capi_message2str(skb->data);\r\nif (cdb) {\r\nprintk(KERN_ERR "kcapi: handle_message: applid %d state released (%s)\n",\r\nCAPIMSG_APPID(skb->data), cdb->buf);\r\ncdebbuf_free(cdb);\r\n} else\r\nprintk(KERN_ERR "kcapi: handle_message: applid %d state released (%s) cannot trace\n",\r\nCAPIMSG_APPID(skb->data),\r\ncapi_cmd2str(cmd, subcmd));\r\ngoto error;\r\n}\r\nskb_queue_tail(&ap->recv_queue, skb);\r\nqueue_work(kcapi_wq, &ap->recv_work);\r\nrcu_read_unlock();\r\nreturn;\r\nerror:\r\nkfree_skb(skb);\r\n}\r\nvoid capi_ctr_ready(struct capi_ctr *ctr)\r\n{\r\nprintk(KERN_NOTICE "kcapi: controller [%03d] \"%s\" ready.\n",\r\nctr->cnr, ctr->name);\r\nnotify_push(CAPICTR_UP, ctr->cnr);\r\n}\r\nvoid capi_ctr_down(struct capi_ctr *ctr)\r\n{\r\nprintk(KERN_NOTICE "kcapi: controller [%03d] down.\n", ctr->cnr);\r\nnotify_push(CAPICTR_DOWN, ctr->cnr);\r\n}\r\nvoid capi_ctr_suspend_output(struct capi_ctr *ctr)\r\n{\r\nif (!ctr->blocked) {\r\nprintk(KERN_DEBUG "kcapi: controller [%03d] suspend\n",\r\nctr->cnr);\r\nctr->blocked = 1;\r\n}\r\n}\r\nvoid capi_ctr_resume_output(struct capi_ctr *ctr)\r\n{\r\nif (ctr->blocked) {\r\nprintk(KERN_DEBUG "kcapi: controller [%03d] resumed\n",\r\nctr->cnr);\r\nctr->blocked = 0;\r\n}\r\n}\r\nint attach_capi_ctr(struct capi_ctr *ctr)\r\n{\r\nint i;\r\nmutex_lock(&capi_controller_lock);\r\nfor (i = 0; i < CAPI_MAXCONTR; i++) {\r\nif (!capi_controller[i])\r\nbreak;\r\n}\r\nif (i == CAPI_MAXCONTR) {\r\nmutex_unlock(&capi_controller_lock);\r\nprintk(KERN_ERR "kcapi: out of controller slots\n");\r\nreturn -EBUSY;\r\n}\r\ncapi_controller[i] = ctr;\r\nctr->nrecvctlpkt = 0;\r\nctr->nrecvdatapkt = 0;\r\nctr->nsentctlpkt = 0;\r\nctr->nsentdatapkt = 0;\r\nctr->cnr = i + 1;\r\nctr->state = CAPI_CTR_DETECTED;\r\nctr->blocked = 0;\r\nctr->traceflag = showcapimsgs;\r\ninit_waitqueue_head(&ctr->state_wait_queue);\r\nsprintf(ctr->procfn, "capi/controllers/%d", ctr->cnr);\r\nctr->procent = proc_create_data(ctr->procfn, 0, NULL, ctr->proc_fops, ctr);\r\nncontrollers++;\r\nmutex_unlock(&capi_controller_lock);\r\nprintk(KERN_NOTICE "kcapi: controller [%03d]: %s attached\n",\r\nctr->cnr, ctr->name);\r\nreturn 0;\r\n}\r\nint detach_capi_ctr(struct capi_ctr *ctr)\r\n{\r\nint err = 0;\r\nmutex_lock(&capi_controller_lock);\r\nctr_down(ctr, CAPI_CTR_DETACHED);\r\nif (capi_controller[ctr->cnr - 1] != ctr) {\r\nerr = -EINVAL;\r\ngoto unlock_out;\r\n}\r\ncapi_controller[ctr->cnr - 1] = NULL;\r\nncontrollers--;\r\nif (ctr->procent)\r\nremove_proc_entry(ctr->procfn, NULL);\r\nprintk(KERN_NOTICE "kcapi: controller [%03d]: %s unregistered\n",\r\nctr->cnr, ctr->name);\r\nunlock_out:\r\nmutex_unlock(&capi_controller_lock);\r\nreturn err;\r\n}\r\nvoid register_capi_driver(struct capi_driver *driver)\r\n{\r\nmutex_lock(&capi_drivers_lock);\r\nlist_add_tail(&driver->list, &capi_drivers);\r\nmutex_unlock(&capi_drivers_lock);\r\n}\r\nvoid unregister_capi_driver(struct capi_driver *driver)\r\n{\r\nmutex_lock(&capi_drivers_lock);\r\nlist_del(&driver->list);\r\nmutex_unlock(&capi_drivers_lock);\r\n}\r\nu16 capi20_isinstalled(void)\r\n{\r\nu16 ret = CAPI_REGNOTINSTALLED;\r\nint i;\r\nmutex_lock(&capi_controller_lock);\r\nfor (i = 0; i < CAPI_MAXCONTR; i++)\r\nif (capi_controller[i] &&\r\ncapi_controller[i]->state == CAPI_CTR_RUNNING) {\r\nret = CAPI_NOERROR;\r\nbreak;\r\n}\r\nmutex_unlock(&capi_controller_lock);\r\nreturn ret;\r\n}\r\nu16 capi20_register(struct capi20_appl *ap)\r\n{\r\nint i;\r\nu16 applid;\r\nDBG("");\r\nif (ap->rparam.datablklen < 128)\r\nreturn CAPI_LOGBLKSIZETOSMALL;\r\nap->nrecvctlpkt = 0;\r\nap->nrecvdatapkt = 0;\r\nap->nsentctlpkt = 0;\r\nap->nsentdatapkt = 0;\r\nmutex_init(&ap->recv_mtx);\r\nskb_queue_head_init(&ap->recv_queue);\r\nINIT_WORK(&ap->recv_work, recv_handler);\r\nap->release_in_progress = 0;\r\nmutex_lock(&capi_controller_lock);\r\nfor (applid = 1; applid <= CAPI_MAXAPPL; applid++) {\r\nif (capi_applications[applid - 1] == NULL)\r\nbreak;\r\n}\r\nif (applid > CAPI_MAXAPPL) {\r\nmutex_unlock(&capi_controller_lock);\r\nreturn CAPI_TOOMANYAPPLS;\r\n}\r\nap->applid = applid;\r\ncapi_applications[applid - 1] = ap;\r\nfor (i = 0; i < CAPI_MAXCONTR; i++) {\r\nif (!capi_controller[i] ||\r\ncapi_controller[i]->state != CAPI_CTR_RUNNING)\r\ncontinue;\r\nregister_appl(capi_controller[i], applid, &ap->rparam);\r\n}\r\nmutex_unlock(&capi_controller_lock);\r\nif (showcapimsgs & 1) {\r\nprintk(KERN_DEBUG "kcapi: appl %d up\n", applid);\r\n}\r\nreturn CAPI_NOERROR;\r\n}\r\nu16 capi20_release(struct capi20_appl *ap)\r\n{\r\nint i;\r\nDBG("applid %#x", ap->applid);\r\nmutex_lock(&capi_controller_lock);\r\nap->release_in_progress = 1;\r\ncapi_applications[ap->applid - 1] = NULL;\r\nsynchronize_rcu();\r\nfor (i = 0; i < CAPI_MAXCONTR; i++) {\r\nif (!capi_controller[i] ||\r\ncapi_controller[i]->state != CAPI_CTR_RUNNING)\r\ncontinue;\r\nrelease_appl(capi_controller[i], ap->applid);\r\n}\r\nmutex_unlock(&capi_controller_lock);\r\nflush_workqueue(kcapi_wq);\r\nskb_queue_purge(&ap->recv_queue);\r\nif (showcapimsgs & 1) {\r\nprintk(KERN_DEBUG "kcapi: appl %d down\n", ap->applid);\r\n}\r\nreturn CAPI_NOERROR;\r\n}\r\nu16 capi20_put_message(struct capi20_appl *ap, struct sk_buff *skb)\r\n{\r\nstruct capi_ctr *ctr;\r\nint showctl = 0;\r\nu8 cmd, subcmd;\r\nDBG("applid %#x", ap->applid);\r\nif (ncontrollers == 0)\r\nreturn CAPI_REGNOTINSTALLED;\r\nif ((ap->applid == 0) || ap->release_in_progress)\r\nreturn CAPI_ILLAPPNR;\r\nif (skb->len < 12\r\n|| !capi_cmd_valid(CAPIMSG_COMMAND(skb->data))\r\n|| !capi_subcmd_valid(CAPIMSG_SUBCOMMAND(skb->data)))\r\nreturn CAPI_ILLCMDORSUBCMDORMSGTOSMALL;\r\nctr = get_capi_ctr_by_nr(CAPIMSG_CONTROLLER(skb->data));\r\nif (!ctr || ctr->state != CAPI_CTR_RUNNING)\r\nreturn CAPI_REGNOTINSTALLED;\r\nif (ctr->blocked)\r\nreturn CAPI_SENDQUEUEFULL;\r\ncmd = CAPIMSG_COMMAND(skb->data);\r\nsubcmd = CAPIMSG_SUBCOMMAND(skb->data);\r\nif (cmd == CAPI_DATA_B3 && subcmd== CAPI_REQ) {\r\nctr->nsentdatapkt++;\r\nap->nsentdatapkt++;\r\nif (ctr->traceflag > 2)\r\nshowctl |= 2;\r\n} else {\r\nctr->nsentctlpkt++;\r\nap->nsentctlpkt++;\r\nif (ctr->traceflag)\r\nshowctl |= 2;\r\n}\r\nshowctl |= (ctr->traceflag & 1);\r\nif (showctl & 2) {\r\nif (showctl & 1) {\r\nprintk(KERN_DEBUG "kcapi: put [%03d] id#%d %s len=%u\n",\r\nCAPIMSG_CONTROLLER(skb->data),\r\nCAPIMSG_APPID(skb->data),\r\ncapi_cmd2str(cmd, subcmd),\r\nCAPIMSG_LEN(skb->data));\r\n} else {\r\n_cdebbuf *cdb = capi_message2str(skb->data);\r\nif (cdb) {\r\nprintk(KERN_DEBUG "kcapi: put [%03d] %s\n",\r\nCAPIMSG_CONTROLLER(skb->data),\r\ncdb->buf);\r\ncdebbuf_free(cdb);\r\n} else\r\nprintk(KERN_DEBUG "kcapi: put [%03d] id#%d %s len=%u cannot trace\n",\r\nCAPIMSG_CONTROLLER(skb->data),\r\nCAPIMSG_APPID(skb->data),\r\ncapi_cmd2str(cmd, subcmd),\r\nCAPIMSG_LEN(skb->data));\r\n}\r\n}\r\nreturn ctr->send_message(ctr, skb);\r\n}\r\nu16 capi20_get_manufacturer(u32 contr, u8 *buf)\r\n{\r\nstruct capi_ctr *ctr;\r\nu16 ret;\r\nif (contr == 0) {\r\nstrlcpy(buf, capi_manufakturer, CAPI_MANUFACTURER_LEN);\r\nreturn CAPI_NOERROR;\r\n}\r\nmutex_lock(&capi_controller_lock);\r\nctr = get_capi_ctr_by_nr(contr);\r\nif (ctr && ctr->state == CAPI_CTR_RUNNING) {\r\nstrlcpy(buf, ctr->manu, CAPI_MANUFACTURER_LEN);\r\nret = CAPI_NOERROR;\r\n} else\r\nret = CAPI_REGNOTINSTALLED;\r\nmutex_unlock(&capi_controller_lock);\r\nreturn ret;\r\n}\r\nu16 capi20_get_version(u32 contr, struct capi_version *verp)\r\n{\r\nstruct capi_ctr *ctr;\r\nu16 ret;\r\nif (contr == 0) {\r\n*verp = driver_version;\r\nreturn CAPI_NOERROR;\r\n}\r\nmutex_lock(&capi_controller_lock);\r\nctr = get_capi_ctr_by_nr(contr);\r\nif (ctr && ctr->state == CAPI_CTR_RUNNING) {\r\nmemcpy(verp, &ctr->version, sizeof(capi_version));\r\nret = CAPI_NOERROR;\r\n} else\r\nret = CAPI_REGNOTINSTALLED;\r\nmutex_unlock(&capi_controller_lock);\r\nreturn ret;\r\n}\r\nu16 capi20_get_serial(u32 contr, u8 *serial)\r\n{\r\nstruct capi_ctr *ctr;\r\nu16 ret;\r\nif (contr == 0) {\r\nstrlcpy(serial, driver_serial, CAPI_SERIAL_LEN);\r\nreturn CAPI_NOERROR;\r\n}\r\nmutex_lock(&capi_controller_lock);\r\nctr = get_capi_ctr_by_nr(contr);\r\nif (ctr && ctr->state == CAPI_CTR_RUNNING) {\r\nstrlcpy(serial, ctr->serial, CAPI_SERIAL_LEN);\r\nret = CAPI_NOERROR;\r\n} else\r\nret = CAPI_REGNOTINSTALLED;\r\nmutex_unlock(&capi_controller_lock);\r\nreturn ret;\r\n}\r\nu16 capi20_get_profile(u32 contr, struct capi_profile *profp)\r\n{\r\nstruct capi_ctr *ctr;\r\nu16 ret;\r\nif (contr == 0) {\r\nprofp->ncontroller = ncontrollers;\r\nreturn CAPI_NOERROR;\r\n}\r\nmutex_lock(&capi_controller_lock);\r\nctr = get_capi_ctr_by_nr(contr);\r\nif (ctr && ctr->state == CAPI_CTR_RUNNING) {\r\nmemcpy(profp, &ctr->profile, sizeof(struct capi_profile));\r\nret = CAPI_NOERROR;\r\n} else\r\nret = CAPI_REGNOTINSTALLED;\r\nmutex_unlock(&capi_controller_lock);\r\nreturn ret;\r\n}\r\nstatic int wait_on_ctr_state(struct capi_ctr *ctr, unsigned int state)\r\n{\r\nDEFINE_WAIT(wait);\r\nint retval = 0;\r\nctr = capi_ctr_get(ctr);\r\nif (!ctr)\r\nreturn -ESRCH;\r\nfor (;;) {\r\nprepare_to_wait(&ctr->state_wait_queue, &wait,\r\nTASK_INTERRUPTIBLE);\r\nif (ctr->state == state)\r\nbreak;\r\nif (ctr->state == CAPI_CTR_DETACHED) {\r\nretval = -ESRCH;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -EINTR;\r\nbreak;\r\n}\r\nmutex_unlock(&capi_controller_lock);\r\nschedule();\r\nmutex_lock(&capi_controller_lock);\r\n}\r\nfinish_wait(&ctr->state_wait_queue, &wait);\r\ncapi_ctr_put(ctr);\r\nreturn retval;\r\n}\r\nstatic int old_capi_manufacturer(unsigned int cmd, void __user *data)\r\n{\r\navmb1_loadandconfigdef ldef;\r\navmb1_extcarddef cdef;\r\navmb1_resetdef rdef;\r\ncapicardparams cparams;\r\nstruct capi_ctr *ctr;\r\nstruct capi_driver *driver = NULL;\r\ncapiloaddata ldata;\r\nstruct list_head *l;\r\nint retval;\r\nswitch (cmd) {\r\ncase AVMB1_ADDCARD:\r\ncase AVMB1_ADDCARD_WITH_TYPE:\r\nif (cmd == AVMB1_ADDCARD) {\r\nif ((retval = copy_from_user(&cdef, data,\r\nsizeof(avmb1_carddef))))\r\nreturn -EFAULT;\r\ncdef.cardtype = AVM_CARDTYPE_B1;\r\n} else {\r\nif ((retval = copy_from_user(&cdef, data,\r\nsizeof(avmb1_extcarddef))))\r\nreturn -EFAULT;\r\n}\r\ncparams.port = cdef.port;\r\ncparams.irq = cdef.irq;\r\ncparams.cardnr = cdef.cardnr;\r\nmutex_lock(&capi_drivers_lock);\r\nswitch (cdef.cardtype) {\r\ncase AVM_CARDTYPE_B1:\r\nlist_for_each(l, &capi_drivers) {\r\ndriver = list_entry(l, struct capi_driver, list);\r\nif (strcmp(driver->name, "b1isa") == 0)\r\nbreak;\r\n}\r\nbreak;\r\ncase AVM_CARDTYPE_T1:\r\nlist_for_each(l, &capi_drivers) {\r\ndriver = list_entry(l, struct capi_driver, list);\r\nif (strcmp(driver->name, "t1isa") == 0)\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ndriver = NULL;\r\nbreak;\r\n}\r\nif (!driver) {\r\nprintk(KERN_ERR "kcapi: driver not loaded.\n");\r\nretval = -EIO;\r\n} else if (!driver->add_card) {\r\nprintk(KERN_ERR "kcapi: driver has no add card function.\n");\r\nretval = -EIO;\r\n} else\r\nretval = driver->add_card(driver, &cparams);\r\nmutex_unlock(&capi_drivers_lock);\r\nreturn retval;\r\ncase AVMB1_LOAD:\r\ncase AVMB1_LOAD_AND_CONFIG:\r\nif (cmd == AVMB1_LOAD) {\r\nif (copy_from_user(&ldef, data,\r\nsizeof(avmb1_loaddef)))\r\nreturn -EFAULT;\r\nldef.t4config.len = 0;\r\nldef.t4config.data = NULL;\r\n} else {\r\nif (copy_from_user(&ldef, data,\r\nsizeof(avmb1_loadandconfigdef)))\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&capi_controller_lock);\r\nctr = get_capi_ctr_by_nr(ldef.contr);\r\nif (!ctr) {\r\nretval = -EINVAL;\r\ngoto load_unlock_out;\r\n}\r\nif (ctr->load_firmware == NULL) {\r\nprintk(KERN_DEBUG "kcapi: load: no load function\n");\r\nretval = -ESRCH;\r\ngoto load_unlock_out;\r\n}\r\nif (ldef.t4file.len <= 0) {\r\nprintk(KERN_DEBUG "kcapi: load: invalid parameter: length of t4file is %d ?\n", ldef.t4file.len);\r\nretval = -EINVAL;\r\ngoto load_unlock_out;\r\n}\r\nif (ldef.t4file.data == NULL) {\r\nprintk(KERN_DEBUG "kcapi: load: invalid parameter: dataptr is 0\n");\r\nretval = -EINVAL;\r\ngoto load_unlock_out;\r\n}\r\nldata.firmware.user = 1;\r\nldata.firmware.data = ldef.t4file.data;\r\nldata.firmware.len = ldef.t4file.len;\r\nldata.configuration.user = 1;\r\nldata.configuration.data = ldef.t4config.data;\r\nldata.configuration.len = ldef.t4config.len;\r\nif (ctr->state != CAPI_CTR_DETECTED) {\r\nprintk(KERN_INFO "kcapi: load: contr=%d not in detect state\n", ldef.contr);\r\nretval = -EBUSY;\r\ngoto load_unlock_out;\r\n}\r\nctr->state = CAPI_CTR_LOADING;\r\nretval = ctr->load_firmware(ctr, &ldata);\r\nif (retval) {\r\nctr->state = CAPI_CTR_DETECTED;\r\ngoto load_unlock_out;\r\n}\r\nretval = wait_on_ctr_state(ctr, CAPI_CTR_RUNNING);\r\nload_unlock_out:\r\nmutex_unlock(&capi_controller_lock);\r\nreturn retval;\r\ncase AVMB1_RESETCARD:\r\nif (copy_from_user(&rdef, data, sizeof(avmb1_resetdef)))\r\nreturn -EFAULT;\r\nretval = 0;\r\nmutex_lock(&capi_controller_lock);\r\nctr = get_capi_ctr_by_nr(rdef.contr);\r\nif (!ctr) {\r\nretval = -ESRCH;\r\ngoto reset_unlock_out;\r\n}\r\nif (ctr->state == CAPI_CTR_DETECTED)\r\ngoto reset_unlock_out;\r\nif (ctr->reset_ctr == NULL) {\r\nprintk(KERN_DEBUG "kcapi: reset: no reset function\n");\r\nretval = -ESRCH;\r\ngoto reset_unlock_out;\r\n}\r\nctr->reset_ctr(ctr);\r\nretval = wait_on_ctr_state(ctr, CAPI_CTR_DETECTED);\r\nreset_unlock_out:\r\nmutex_unlock(&capi_controller_lock);\r\nreturn retval;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint capi20_manufacturer(unsigned int cmd, void __user *data)\r\n{\r\nstruct capi_ctr *ctr;\r\nint retval;\r\nswitch (cmd) {\r\n#ifdef AVMB1_COMPAT\r\ncase AVMB1_LOAD:\r\ncase AVMB1_LOAD_AND_CONFIG:\r\ncase AVMB1_RESETCARD:\r\ncase AVMB1_GET_CARDINFO:\r\ncase AVMB1_REMOVECARD:\r\nreturn old_capi_manufacturer(cmd, data);\r\n#endif\r\ncase KCAPI_CMD_TRACE:\r\n{\r\nkcapi_flagdef fdef;\r\nif (copy_from_user(&fdef, data, sizeof(kcapi_flagdef)))\r\nreturn -EFAULT;\r\nmutex_lock(&capi_controller_lock);\r\nctr = get_capi_ctr_by_nr(fdef.contr);\r\nif (ctr) {\r\nctr->traceflag = fdef.flag;\r\nprintk(KERN_INFO "kcapi: contr [%03d] set trace=%d\n",\r\nctr->cnr, ctr->traceflag);\r\nretval = 0;\r\n} else\r\nretval = -ESRCH;\r\nmutex_unlock(&capi_controller_lock);\r\nreturn retval;\r\n}\r\ncase KCAPI_CMD_ADDCARD:\r\n{\r\nstruct list_head *l;\r\nstruct capi_driver *driver = NULL;\r\ncapicardparams cparams;\r\nkcapi_carddef cdef;\r\nif ((retval = copy_from_user(&cdef, data, sizeof(cdef))))\r\nreturn -EFAULT;\r\ncparams.port = cdef.port;\r\ncparams.irq = cdef.irq;\r\ncparams.membase = cdef.membase;\r\ncparams.cardnr = cdef.cardnr;\r\ncparams.cardtype = 0;\r\ncdef.driver[sizeof(cdef.driver)-1] = 0;\r\nmutex_lock(&capi_drivers_lock);\r\nlist_for_each(l, &capi_drivers) {\r\ndriver = list_entry(l, struct capi_driver, list);\r\nif (strcmp(driver->name, cdef.driver) == 0)\r\nbreak;\r\n}\r\nif (driver == NULL) {\r\nprintk(KERN_ERR "kcapi: driver \"%s\" not loaded.\n",\r\ncdef.driver);\r\nretval = -ESRCH;\r\n} else if (!driver->add_card) {\r\nprintk(KERN_ERR "kcapi: driver \"%s\" has no add card function.\n", cdef.driver);\r\nretval = -EIO;\r\n} else\r\nretval = driver->add_card(driver, &cparams);\r\nmutex_unlock(&capi_drivers_lock);\r\nreturn retval;\r\n}\r\ndefault:\r\nprintk(KERN_ERR "kcapi: manufacturer command %d unknown.\n",\r\ncmd);\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init kcapi_init(void)\r\n{\r\nint err;\r\nkcapi_wq = alloc_workqueue("kcapi", 0, 0);\r\nif (!kcapi_wq)\r\nreturn -ENOMEM;\r\nregister_capictr_notifier(&capictr_nb);\r\nerr = cdebug_init();\r\nif (err) {\r\nunregister_capictr_notifier(&capictr_nb);\r\ndestroy_workqueue(kcapi_wq);\r\nreturn err;\r\n}\r\nkcapi_proc_init();\r\nreturn 0;\r\n}\r\nstatic void __exit kcapi_exit(void)\r\n{\r\nkcapi_proc_exit();\r\nunregister_capictr_notifier(&capictr_nb);\r\ncdebug_exit();\r\ndestroy_workqueue(kcapi_wq);\r\n}
