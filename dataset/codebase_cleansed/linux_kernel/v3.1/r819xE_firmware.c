void firmware_init_param(struct r8192_priv *priv)\r\n{\r\nrt_firmware *pfirmware = priv->pFirmware;\r\npfirmware->cmdpacket_frag_thresold =\r\nGET_COMMAND_PACKET_FRAG_THRESHOLD(MAX_TRANSMIT_BUFFER_SIZE);\r\n}\r\nstatic bool fw_download_code(struct r8192_priv *priv, u8 *code_virtual_address,\r\nu32 buffer_len)\r\n{\r\nbool rt_status = true;\r\nu16 frag_threshold;\r\nu16 frag_length, frag_offset = 0;\r\nint i;\r\nrt_firmware *pfirmware = priv->pFirmware;\r\nstruct sk_buff *skb;\r\nunsigned char *seg_ptr;\r\ncb_desc *tcb_desc;\r\nu8 bLastIniPkt;\r\nfirmware_init_param(priv);\r\nfrag_threshold = pfirmware->cmdpacket_frag_thresold;\r\ndo {\r\nif ((buffer_len - frag_offset) > frag_threshold) {\r\nfrag_length = frag_threshold ;\r\nbLastIniPkt = 0;\r\n} else {\r\nfrag_length = buffer_len - frag_offset;\r\nbLastIniPkt = 1;\r\n}\r\nskb = dev_alloc_skb(frag_length + 4);\r\ntcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;\r\ntcb_desc->bLastIniPkt = bLastIniPkt;\r\nseg_ptr = skb->data;\r\nfor (i = 0; i < frag_length; i += 4) {\r\n*seg_ptr++ = ((i+0) < frag_length) ?\r\ncode_virtual_address[i+3] : 0;\r\n*seg_ptr++ = ((i+1) < frag_length) ?\r\ncode_virtual_address[i+2] : 0;\r\n*seg_ptr++ = ((i+2) < frag_length) ?\r\ncode_virtual_address[i+1] : 0;\r\n*seg_ptr++ = ((i+3) < frag_length) ?\r\ncode_virtual_address[i+0] : 0;\r\n}\r\ntcb_desc->txbuf_size = (u16)i;\r\nskb_put(skb, i);\r\npriv->ieee80211->softmac_hard_start_xmit(skb, priv->ieee80211);\r\ncode_virtual_address += frag_length;\r\nfrag_offset += frag_length;\r\n} while (frag_offset < buffer_len);\r\nreturn rt_status;\r\n}\r\nstatic bool CPUcheck_maincodeok_turnonCPU(struct r8192_priv *priv)\r\n{\r\nunsigned long timeout;\r\nbool rt_status = true;\r\nu32 CPU_status = 0;\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\nCPU_status = read_nic_dword(priv, CPU_GEN);\r\nif (CPU_status & CPU_GEN_PUT_CODE_OK)\r\nbreak;\r\nmsleep(2);\r\n}\r\nif (!(CPU_status & CPU_GEN_PUT_CODE_OK)) {\r\nRT_TRACE(COMP_ERR, "Download Firmware: Put code fail!\n");\r\ngoto CPUCheckMainCodeOKAndTurnOnCPU_Fail;\r\n} else {\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Put code ok!\n");\r\n}\r\nCPU_status = read_nic_dword(priv, CPU_GEN);\r\nwrite_nic_byte(priv, CPU_GEN,\r\n(u8)((CPU_status | CPU_GEN_PWR_STB_CPU) & 0xff));\r\nmdelay(1);\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\nCPU_status = read_nic_dword(priv, CPU_GEN);\r\nif (CPU_status & CPU_GEN_BOOT_RDY)\r\nbreak;\r\nmsleep(2);\r\n}\r\nif (!(CPU_status & CPU_GEN_BOOT_RDY))\r\ngoto CPUCheckMainCodeOKAndTurnOnCPU_Fail;\r\nelse\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Boot ready!\n");\r\nreturn rt_status;\r\nCPUCheckMainCodeOKAndTurnOnCPU_Fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s()\n", __func__);\r\nrt_status = FALSE;\r\nreturn rt_status;\r\n}\r\nstatic bool CPUcheck_firmware_ready(struct r8192_priv *priv)\r\n{\r\nunsigned long timeout;\r\nbool rt_status = true;\r\nu32 CPU_status = 0;\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\nCPU_status = read_nic_dword(priv, CPU_GEN);\r\nif (CPU_status & CPU_GEN_FIRM_RDY)\r\nbreak;\r\nmsleep(2);\r\n}\r\nif (!(CPU_status & CPU_GEN_FIRM_RDY))\r\ngoto CPUCheckFirmwareReady_Fail;\r\nelse\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Firmware ready!\n");\r\nreturn rt_status;\r\nCPUCheckFirmwareReady_Fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s()\n", __func__);\r\nrt_status = false;\r\nreturn rt_status;\r\n}\r\nbool init_firmware(struct r8192_priv *priv)\r\n{\r\nbool rt_status = true;\r\nu32 file_length = 0;\r\nu8 *mapped_file = NULL;\r\nu32 init_step = 0;\r\nenum opt_rst_type rst_opt = OPT_SYSTEM_RESET;\r\nenum firmware_init_step starting_state = FW_INIT_STEP0_BOOT;\r\nrt_firmware *pfirmware = priv->pFirmware;\r\nconst struct firmware *fw_entry;\r\nconst char *fw_name[3] = { "RTL8192E/boot.img",\r\n"RTL8192E/main.img",\r\n"RTL8192E/data.img"};\r\nint rc;\r\nRT_TRACE(COMP_FIRMWARE, " PlatformInitFirmware()==>\n");\r\nif (pfirmware->firmware_status == FW_STATUS_0_INIT) {\r\nrst_opt = OPT_SYSTEM_RESET;\r\nstarting_state = FW_INIT_STEP0_BOOT;\r\n} else if (pfirmware->firmware_status == FW_STATUS_5_READY) {\r\nrst_opt = OPT_FIRMWARE_RESET;\r\nstarting_state = FW_INIT_STEP2_DATA;\r\n} else {\r\nRT_TRACE(COMP_FIRMWARE,\r\n"PlatformInitFirmware: undefined firmware state\n");\r\n}\r\nfor (init_step = starting_state; init_step <= FW_INIT_STEP2_DATA;\r\ninit_step++) {\r\nif (rst_opt == OPT_SYSTEM_RESET) {\r\nif (pfirmware->firmware_buf_size[init_step] == 0) {\r\nrc = request_firmware(&fw_entry,\r\nfw_name[init_step], &priv->pdev->dev);\r\nif (rc < 0) {\r\nRT_TRACE(COMP_FIRMWARE, "request firmware fail!\n");\r\ngoto download_firmware_fail;\r\n}\r\nif (fw_entry->size > sizeof(pfirmware->firmware_buf[init_step])) {\r\nRT_TRACE(COMP_FIRMWARE,\r\n"img file size exceed the container buffer fail!\n");\r\ngoto download_firmware_fail;\r\n}\r\nif (init_step != FW_INIT_STEP1_MAIN) {\r\nmemcpy(pfirmware->firmware_buf[init_step],\r\nfw_entry->data, fw_entry->size);\r\npfirmware->firmware_buf_size[init_step] = fw_entry->size;\r\n} else {\r\nmemset(pfirmware->firmware_buf[init_step], 0, 128);\r\nmemcpy(&pfirmware->firmware_buf[init_step][128], fw_entry->data,\r\nfw_entry->size);\r\npfirmware->firmware_buf_size[init_step] = fw_entry->size+128;\r\n}\r\nif (rst_opt == OPT_SYSTEM_RESET)\r\nrelease_firmware(fw_entry);\r\n}\r\nmapped_file = pfirmware->firmware_buf[init_step];\r\nfile_length = pfirmware->firmware_buf_size[init_step];\r\n} else if (rst_opt == OPT_FIRMWARE_RESET) {\r\nmapped_file = pfirmware->firmware_buf[init_step];\r\nfile_length = pfirmware->firmware_buf_size[init_step];\r\n}\r\nrt_status = fw_download_code(priv, mapped_file, file_length);\r\nif (rt_status != TRUE)\r\ngoto download_firmware_fail;\r\nswitch (init_step) {\r\ncase FW_INIT_STEP0_BOOT:\r\npfirmware->firmware_status = FW_STATUS_1_MOVE_BOOT_CODE;\r\nbreak;\r\ncase FW_INIT_STEP1_MAIN:\r\npfirmware->firmware_status = FW_STATUS_2_MOVE_MAIN_CODE;\r\nrt_status = CPUcheck_maincodeok_turnonCPU(priv);\r\nif (rt_status != TRUE) {\r\nRT_TRACE(COMP_FIRMWARE,\r\n"CPUcheck_maincodeok_turnonCPU fail!\n");\r\ngoto download_firmware_fail;\r\n}\r\npfirmware->firmware_status = FW_STATUS_3_TURNON_CPU;\r\nbreak;\r\ncase FW_INIT_STEP2_DATA:\r\npfirmware->firmware_status = FW_STATUS_4_MOVE_DATA_CODE;\r\nmdelay(1);\r\nrt_status = CPUcheck_firmware_ready(priv);\r\nif (rt_status != TRUE) {\r\nRT_TRACE(COMP_FIRMWARE,\r\n"CPUcheck_firmware_ready fail(%d)!\n",\r\nrt_status);\r\ngoto download_firmware_fail;\r\n}\r\npfirmware->firmware_status = FW_STATUS_5_READY;\r\nbreak;\r\n}\r\n}\r\nRT_TRACE(COMP_FIRMWARE, "Firmware Download Success\n");\r\nreturn rt_status;\r\ndownload_firmware_fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s() step %d\n", __func__, init_step);\r\nrt_status = false;\r\nreturn rt_status;\r\n}
