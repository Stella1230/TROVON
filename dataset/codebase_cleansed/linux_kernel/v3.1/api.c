static inline int crypto_alg_get(struct crypto_alg *alg)\r\n{\r\nreturn try_inc_mod_count(alg->cra_module);\r\n}\r\nstatic inline void crypto_alg_put(struct crypto_alg *alg)\r\n{\r\nif (alg->cra_module)\r\n__MOD_DEC_USE_COUNT(alg->cra_module);\r\n}\r\nstruct crypto_alg *crypto_alg_lookup(const char *name)\r\n{\r\nstruct crypto_alg *q, *alg = NULL;\r\nif (!name)\r\nreturn NULL;\r\ndown_read(&crypto_alg_sem);\r\nlist_for_each_entry(q, &crypto_alg_list, cra_list) {\r\nif (!(strcmp(q->cra_name, name))) {\r\nif (crypto_alg_get(q))\r\nalg = q;\r\nbreak;\r\n}\r\n}\r\nup_read(&crypto_alg_sem);\r\nreturn alg;\r\n}\r\nstatic int crypto_init_flags(struct crypto_tfm *tfm, u32 flags)\r\n{\r\ntfm->crt_flags = 0;\r\nswitch (crypto_tfm_alg_type(tfm)) {\r\ncase CRYPTO_ALG_TYPE_CIPHER:\r\nreturn crypto_init_cipher_flags(tfm, flags);\r\ncase CRYPTO_ALG_TYPE_DIGEST:\r\nreturn crypto_init_digest_flags(tfm, flags);\r\ncase CRYPTO_ALG_TYPE_COMPRESS:\r\nreturn crypto_init_compress_flags(tfm, flags);\r\ndefault:\r\nbreak;\r\n}\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nstatic int crypto_init_ops(struct crypto_tfm *tfm)\r\n{\r\nswitch (crypto_tfm_alg_type(tfm)) {\r\ncase CRYPTO_ALG_TYPE_CIPHER:\r\nreturn crypto_init_cipher_ops(tfm);\r\ncase CRYPTO_ALG_TYPE_DIGEST:\r\nreturn crypto_init_digest_ops(tfm);\r\ncase CRYPTO_ALG_TYPE_COMPRESS:\r\nreturn crypto_init_compress_ops(tfm);\r\ndefault:\r\nbreak;\r\n}\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nstatic void crypto_exit_ops(struct crypto_tfm *tfm)\r\n{\r\nswitch (crypto_tfm_alg_type(tfm)) {\r\ncase CRYPTO_ALG_TYPE_CIPHER:\r\ncrypto_exit_cipher_ops(tfm);\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_DIGEST:\r\ncrypto_exit_digest_ops(tfm);\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_COMPRESS:\r\ncrypto_exit_compress_ops(tfm);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstruct crypto_tfm *crypto_alloc_tfm(const char *name, u32 flags)\r\n{\r\nstruct crypto_tfm *tfm = NULL;\r\nstruct crypto_alg *alg;\r\nalg = crypto_alg_mod_lookup(name);\r\nif (alg == NULL)\r\ngoto out;\r\ntfm = kzalloc(sizeof(*tfm) + alg->cra_ctxsize, GFP_KERNEL);\r\nif (tfm == NULL)\r\ngoto out_put;\r\ntfm->__crt_alg = alg;\r\nif (crypto_init_flags(tfm, flags))\r\ngoto out_free_tfm;\r\nif (crypto_init_ops(tfm)) {\r\ncrypto_exit_ops(tfm);\r\ngoto out_free_tfm;\r\n}\r\ngoto out;\r\nout_free_tfm:\r\nkfree(tfm);\r\ntfm = NULL;\r\nout_put:\r\ncrypto_alg_put(alg);\r\nout:\r\nreturn tfm;\r\n}\r\nvoid crypto_free_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_alg *alg = tfm->__crt_alg;\r\nint size = sizeof(*tfm) + alg->cra_ctxsize;\r\ncrypto_exit_ops(tfm);\r\ncrypto_alg_put(alg);\r\nmemset(tfm, 0, size);\r\nkfree(tfm);\r\n}\r\nint crypto_register_alg(struct crypto_alg *alg)\r\n{\r\nint ret = 0;\r\nstruct crypto_alg *q;\r\ndown_write(&crypto_alg_sem);\r\nlist_for_each_entry(q, &crypto_alg_list, cra_list) {\r\nif (!(strcmp(q->cra_name, alg->cra_name))) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nlist_add_tail(&alg->cra_list, &crypto_alg_list);\r\nout:\r\nup_write(&crypto_alg_sem);\r\nreturn ret;\r\n}\r\nint crypto_unregister_alg(struct crypto_alg *alg)\r\n{\r\nint ret = -ENOENT;\r\nstruct crypto_alg *q;\r\nBUG_ON(!alg->cra_module);\r\ndown_write(&crypto_alg_sem);\r\nlist_for_each_entry(q, &crypto_alg_list, cra_list) {\r\nif (alg == q) {\r\nlist_del(&alg->cra_list);\r\nret = 0;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nup_write(&crypto_alg_sem);\r\nreturn ret;\r\n}\r\nint crypto_alg_available(const char *name, u32 flags)\r\n{\r\nint ret = 0;\r\nstruct crypto_alg *alg = crypto_alg_mod_lookup(name);\r\nif (alg) {\r\ncrypto_alg_put(alg);\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init init_crypto(void)\r\n{\r\nprintk(KERN_INFO "Initializing Cryptographic API\n");\r\ncrypto_init_proc();\r\nreturn 0;\r\n}
