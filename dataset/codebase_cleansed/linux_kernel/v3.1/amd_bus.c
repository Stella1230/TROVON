static void __init get_pci_mmcfg_amd_fam10h_range(void)\r\n{\r\nu32 address;\r\nu64 base, msr;\r\nunsigned segn_busn_bits;\r\nif (boot_cpu_data.x86 < 0x10)\r\nreturn;\r\naddress = MSR_FAM10H_MMIO_CONF_BASE;\r\nrdmsrl(address, msr);\r\nif (!(msr & FAM10H_MMIO_CONF_ENABLE))\r\nreturn;\r\nbase = msr & (FAM10H_MMIO_CONF_BASE_MASK<<FAM10H_MMIO_CONF_BASE_SHIFT);\r\nsegn_busn_bits = (msr >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) &\r\nFAM10H_MMIO_CONF_BUSRANGE_MASK;\r\nfam10h_mmconf_start = base;\r\nfam10h_mmconf_end = base + (1ULL<<(segn_busn_bits + 20)) - 1;\r\n}\r\nstatic int __init early_fill_mp_bus_info(void)\r\n{\r\nint i;\r\nint j;\r\nunsigned bus;\r\nunsigned slot;\r\nint node;\r\nint link;\r\nint def_node;\r\nint def_link;\r\nstruct pci_root_info *info;\r\nu32 reg;\r\nstruct resource *res;\r\nu64 start;\r\nu64 end;\r\nstruct range range[RANGE_NUM];\r\nu64 val;\r\nu32 address;\r\nbool found;\r\nif (!early_pci_allowed())\r\nreturn -1;\r\nfound = false;\r\nfor (i = 0; i < ARRAY_SIZE(pci_probes); i++) {\r\nu32 id;\r\nu16 device;\r\nu16 vendor;\r\nbus = pci_probes[i].bus;\r\nslot = pci_probes[i].slot;\r\nid = read_pci_config(bus, slot, 0, PCI_VENDOR_ID);\r\nvendor = id & 0xffff;\r\ndevice = (id>>16) & 0xffff;\r\nif (pci_probes[i].vendor == vendor &&\r\npci_probes[i].device == device) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn 0;\r\npci_root_num = 0;\r\nfor (i = 0; i < 4; i++) {\r\nint min_bus;\r\nint max_bus;\r\nreg = read_pci_config(bus, slot, 1, 0xe0 + (i << 2));\r\nif ((reg & 7) != 3)\r\ncontinue;\r\nmin_bus = (reg >> 16) & 0xff;\r\nmax_bus = (reg >> 24) & 0xff;\r\nnode = (reg >> 4) & 0x07;\r\n#ifdef CONFIG_NUMA\r\nfor (j = min_bus; j <= max_bus; j++)\r\nset_mp_bus_to_node(j, node);\r\n#endif\r\nlink = (reg >> 8) & 0x03;\r\ninfo = &pci_root_info[pci_root_num];\r\ninfo->bus_min = min_bus;\r\ninfo->bus_max = max_bus;\r\ninfo->node = node;\r\ninfo->link = link;\r\nsprintf(info->name, "PCI Bus #%02x", min_bus);\r\npci_root_num++;\r\n}\r\nreg = read_pci_config(bus, slot, 0, 0x60);\r\ndef_node = (reg >> 8) & 0x07;\r\nreg = read_pci_config(bus, slot, 0, 0x64);\r\ndef_link = (reg >> 8) & 0x03;\r\nmemset(range, 0, sizeof(range));\r\nadd_range(range, RANGE_NUM, 0, 0, 0xffff + 1);\r\nfor (i = 0; i < 4; i++) {\r\nreg = read_pci_config(bus, slot, 1, 0xc0 + (i << 3));\r\nif (!(reg & 3))\r\ncontinue;\r\nstart = reg & 0xfff000;\r\nreg = read_pci_config(bus, slot, 1, 0xc4 + (i << 3));\r\nnode = reg & 0x07;\r\nlink = (reg >> 4) & 0x03;\r\nend = (reg & 0xfff000) | 0xfff;\r\nfor (j = 0; j < pci_root_num; j++) {\r\ninfo = &pci_root_info[j];\r\nif (info->node == node && info->link == link)\r\nbreak;\r\n}\r\nif (j == pci_root_num)\r\ncontinue;\r\ninfo = &pci_root_info[j];\r\nprintk(KERN_DEBUG "node %d link %d: io port [%llx, %llx]\n",\r\nnode, link, start, end);\r\nif (end > 0xffff)\r\nend = 0xffff;\r\nupdate_res(info, start, end, IORESOURCE_IO, 1);\r\nsubtract_range(range, RANGE_NUM, start, end + 1);\r\n}\r\nfor (j = 0; j < pci_root_num; j++) {\r\ninfo = &pci_root_info[j];\r\nif (info->node == def_node && info->link == def_link)\r\nbreak;\r\n}\r\nif (j < pci_root_num) {\r\ninfo = &pci_root_info[j];\r\nfor (i = 0; i < RANGE_NUM; i++) {\r\nif (!range[i].end)\r\ncontinue;\r\nupdate_res(info, range[i].start, range[i].end - 1,\r\nIORESOURCE_IO, 1);\r\n}\r\n}\r\nmemset(range, 0, sizeof(range));\r\nend = cap_resource((0xfdULL<<32) - 1);\r\nend++;\r\nadd_range(range, RANGE_NUM, 0, 0, end);\r\naddress = MSR_K8_TOP_MEM1;\r\nrdmsrl(address, val);\r\nend = (val & 0xffffff800000ULL);\r\nprintk(KERN_INFO "TOM: %016llx aka %lldM\n", end, end>>20);\r\nif (end < (1ULL<<32))\r\nsubtract_range(range, RANGE_NUM, 0, end);\r\nget_pci_mmcfg_amd_fam10h_range();\r\nif (fam10h_mmconf_end) {\r\nprintk(KERN_DEBUG "Fam 10h mmconf [%llx, %llx]\n", fam10h_mmconf_start, fam10h_mmconf_end);\r\nsubtract_range(range, RANGE_NUM, fam10h_mmconf_start,\r\nfam10h_mmconf_end + 1);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nreg = read_pci_config(bus, slot, 1, 0x80 + (i << 3));\r\nif (!(reg & 3))\r\ncontinue;\r\nstart = reg & 0xffffff00;\r\nstart <<= 8;\r\nreg = read_pci_config(bus, slot, 1, 0x84 + (i << 3));\r\nnode = reg & 0x07;\r\nlink = (reg >> 4) & 0x03;\r\nend = (reg & 0xffffff00);\r\nend <<= 8;\r\nend |= 0xffff;\r\nfor (j = 0; j < pci_root_num; j++) {\r\ninfo = &pci_root_info[j];\r\nif (info->node == node && info->link == link)\r\nbreak;\r\n}\r\nif (j == pci_root_num)\r\ncontinue;\r\ninfo = &pci_root_info[j];\r\nprintk(KERN_DEBUG "node %d link %d: mmio [%llx, %llx]",\r\nnode, link, start, end);\r\nif (fam10h_mmconf_end) {\r\nint changed = 0;\r\nu64 endx = 0;\r\nif (start >= fam10h_mmconf_start &&\r\nstart <= fam10h_mmconf_end) {\r\nstart = fam10h_mmconf_end + 1;\r\nchanged = 1;\r\n}\r\nif (end >= fam10h_mmconf_start &&\r\nend <= fam10h_mmconf_end) {\r\nend = fam10h_mmconf_start - 1;\r\nchanged = 1;\r\n}\r\nif (start < fam10h_mmconf_start &&\r\nend > fam10h_mmconf_end) {\r\nendx = fam10h_mmconf_start - 1;\r\nupdate_res(info, start, endx, IORESOURCE_MEM, 0);\r\nsubtract_range(range, RANGE_NUM, start,\r\nendx + 1);\r\nprintk(KERN_CONT " ==> [%llx, %llx]", start, endx);\r\nstart = fam10h_mmconf_end + 1;\r\nchanged = 1;\r\n}\r\nif (changed) {\r\nif (start <= end) {\r\nprintk(KERN_CONT " %s [%llx, %llx]", endx ? "and" : "==>", start, end);\r\n} else {\r\nprintk(KERN_CONT "%s\n", endx?"":" ==> none");\r\ncontinue;\r\n}\r\n}\r\n}\r\nupdate_res(info, cap_resource(start), cap_resource(end),\r\nIORESOURCE_MEM, 1);\r\nsubtract_range(range, RANGE_NUM, start, end + 1);\r\nprintk(KERN_CONT "\n");\r\n}\r\naddress = MSR_K8_SYSCFG;\r\nrdmsrl(address, val);\r\nif (val & (1<<21)) {\r\naddress = MSR_K8_TOP_MEM2;\r\nrdmsrl(address, val);\r\nend = (val & 0xffffff800000ULL);\r\nprintk(KERN_INFO "TOM2: %016llx aka %lldM\n", end, end>>20);\r\nsubtract_range(range, RANGE_NUM, 1ULL<<32, end);\r\n}\r\nfor (j = 0; j < pci_root_num; j++) {\r\ninfo = &pci_root_info[j];\r\nif (info->node == def_node && info->link == def_link)\r\nbreak;\r\n}\r\nif (j < pci_root_num) {\r\ninfo = &pci_root_info[j];\r\nfor (i = 0; i < RANGE_NUM; i++) {\r\nif (!range[i].end)\r\ncontinue;\r\nupdate_res(info, cap_resource(range[i].start),\r\ncap_resource(range[i].end - 1),\r\nIORESOURCE_MEM, 1);\r\n}\r\n}\r\nfor (i = 0; i < pci_root_num; i++) {\r\nint res_num;\r\nint busnum;\r\ninfo = &pci_root_info[i];\r\nres_num = info->res_num;\r\nbusnum = info->bus_min;\r\nprintk(KERN_DEBUG "bus: [%02x, %02x] on node %x link %x\n",\r\ninfo->bus_min, info->bus_max, info->node, info->link);\r\nfor (j = 0; j < res_num; j++) {\r\nres = &info->res[j];\r\nprintk(KERN_DEBUG "bus: %02x index %x %pR\n",\r\nbusnum, j, res);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __cpuinit enable_pci_io_ecs(void *unused)\r\n{\r\nu64 reg;\r\nrdmsrl(MSR_AMD64_NB_CFG, reg);\r\nif (!(reg & ENABLE_CF8_EXT_CFG)) {\r\nreg |= ENABLE_CF8_EXT_CFG;\r\nwrmsrl(MSR_AMD64_NB_CFG, reg);\r\n}\r\n}\r\nstatic int __cpuinit amd_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nint cpu = (long)hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nsmp_call_function_single(cpu, enable_pci_io_ecs, NULL, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init pci_enable_pci_io_ecs(void)\r\n{\r\n#ifdef CONFIG_AMD_NB\r\nunsigned int i, n;\r\nfor (n = i = 0; !n && amd_nb_bus_dev_ranges[i].dev_limit; ++i) {\r\nu8 bus = amd_nb_bus_dev_ranges[i].bus;\r\nu8 slot = amd_nb_bus_dev_ranges[i].dev_base;\r\nu8 limit = amd_nb_bus_dev_ranges[i].dev_limit;\r\nfor (; slot < limit; ++slot) {\r\nu32 val = read_pci_config(bus, slot, 3, 0);\r\nif (!early_is_amd_nb(val))\r\ncontinue;\r\nval = read_pci_config(bus, slot, 3, 0x8c);\r\nif (!(val & (ENABLE_CF8_EXT_CFG >> 32))) {\r\nval |= ENABLE_CF8_EXT_CFG >> 32;\r\nwrite_pci_config(bus, slot, 3, 0x8c, val);\r\n}\r\n++n;\r\n}\r\n}\r\npr_info("Extended Config Space enabled on %u nodes\n", n);\r\n#endif\r\n}\r\nstatic int __init pci_io_ecs_init(void)\r\n{\r\nint cpu;\r\nif (boot_cpu_data.x86 < 0x10)\r\nreturn 0;\r\nif (early_pci_allowed())\r\npci_enable_pci_io_ecs();\r\nregister_cpu_notifier(&amd_cpu_notifier);\r\nfor_each_online_cpu(cpu)\r\namd_cpu_notify(&amd_cpu_notifier, (unsigned long)CPU_ONLINE,\r\n(void *)(long)cpu);\r\npci_probe |= PCI_HAS_IO_ECS;\r\nreturn 0;\r\n}\r\nstatic int __init amd_postcore_init(void)\r\n{\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\r\nreturn 0;\r\nearly_fill_mp_bus_info();\r\npci_io_ecs_init();\r\nreturn 0;\r\n}
