static int\r\nuserspace_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\r\nvoid *data)\r\n{\r\nstruct cpufreq_freqs *freq = data;\r\nif (!per_cpu(cpu_is_managed, freq->cpu))\r\nreturn 0;\r\npr_debug("saving cpu_cur_freq of cpu %u to be %u kHz\n",\r\nfreq->cpu, freq->new);\r\nper_cpu(cpu_cur_freq, freq->cpu) = freq->new;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_set(struct cpufreq_policy *policy, unsigned int freq)\r\n{\r\nint ret = -EINVAL;\r\npr_debug("cpufreq_set for cpu %u, freq %u kHz\n", policy->cpu, freq);\r\nmutex_lock(&userspace_mutex);\r\nif (!per_cpu(cpu_is_managed, policy->cpu))\r\ngoto err;\r\nper_cpu(cpu_set_freq, policy->cpu) = freq;\r\nif (freq < per_cpu(cpu_min_freq, policy->cpu))\r\nfreq = per_cpu(cpu_min_freq, policy->cpu);\r\nif (freq > per_cpu(cpu_max_freq, policy->cpu))\r\nfreq = per_cpu(cpu_max_freq, policy->cpu);\r\nret = __cpufreq_driver_target(policy, freq, CPUFREQ_RELATION_L);\r\nerr:\r\nmutex_unlock(&userspace_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_speed(struct cpufreq_policy *policy, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", per_cpu(cpu_cur_freq, policy->cpu));\r\n}\r\nstatic int cpufreq_governor_userspace(struct cpufreq_policy *policy,\r\nunsigned int event)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nint rc = 0;\r\nswitch (event) {\r\ncase CPUFREQ_GOV_START:\r\nif (!cpu_online(cpu))\r\nreturn -EINVAL;\r\nBUG_ON(!policy->cur);\r\nmutex_lock(&userspace_mutex);\r\nif (cpus_using_userspace_governor == 0) {\r\ncpufreq_register_notifier(\r\n&userspace_cpufreq_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\ncpus_using_userspace_governor++;\r\nper_cpu(cpu_is_managed, cpu) = 1;\r\nper_cpu(cpu_min_freq, cpu) = policy->min;\r\nper_cpu(cpu_max_freq, cpu) = policy->max;\r\nper_cpu(cpu_cur_freq, cpu) = policy->cur;\r\nper_cpu(cpu_set_freq, cpu) = policy->cur;\r\npr_debug("managing cpu %u started "\r\n"(%u - %u kHz, currently %u kHz)\n",\r\ncpu,\r\nper_cpu(cpu_min_freq, cpu),\r\nper_cpu(cpu_max_freq, cpu),\r\nper_cpu(cpu_cur_freq, cpu));\r\nmutex_unlock(&userspace_mutex);\r\nbreak;\r\ncase CPUFREQ_GOV_STOP:\r\nmutex_lock(&userspace_mutex);\r\ncpus_using_userspace_governor--;\r\nif (cpus_using_userspace_governor == 0) {\r\ncpufreq_unregister_notifier(\r\n&userspace_cpufreq_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nper_cpu(cpu_is_managed, cpu) = 0;\r\nper_cpu(cpu_min_freq, cpu) = 0;\r\nper_cpu(cpu_max_freq, cpu) = 0;\r\nper_cpu(cpu_set_freq, cpu) = 0;\r\npr_debug("managing cpu %u stopped\n", cpu);\r\nmutex_unlock(&userspace_mutex);\r\nbreak;\r\ncase CPUFREQ_GOV_LIMITS:\r\nmutex_lock(&userspace_mutex);\r\npr_debug("limit event for cpu %u: %u - %u kHz, "\r\n"currently %u kHz, last set to %u kHz\n",\r\ncpu, policy->min, policy->max,\r\nper_cpu(cpu_cur_freq, cpu),\r\nper_cpu(cpu_set_freq, cpu));\r\nif (policy->max < per_cpu(cpu_set_freq, cpu)) {\r\n__cpufreq_driver_target(policy, policy->max,\r\nCPUFREQ_RELATION_H);\r\n} else if (policy->min > per_cpu(cpu_set_freq, cpu)) {\r\n__cpufreq_driver_target(policy, policy->min,\r\nCPUFREQ_RELATION_L);\r\n} else {\r\n__cpufreq_driver_target(policy,\r\nper_cpu(cpu_set_freq, cpu),\r\nCPUFREQ_RELATION_L);\r\n}\r\nper_cpu(cpu_min_freq, cpu) = policy->min;\r\nper_cpu(cpu_max_freq, cpu) = policy->max;\r\nper_cpu(cpu_cur_freq, cpu) = policy->cur;\r\nmutex_unlock(&userspace_mutex);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init cpufreq_gov_userspace_init(void)\r\n{\r\nreturn cpufreq_register_governor(&cpufreq_gov_userspace);\r\n}\r\nstatic void __exit cpufreq_gov_userspace_exit(void)\r\n{\r\ncpufreq_unregister_governor(&cpufreq_gov_userspace);\r\n}
