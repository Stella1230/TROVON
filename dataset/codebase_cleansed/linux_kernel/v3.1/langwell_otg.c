static inline struct langwell_otg_timer *otg_timer_initializer\r\n(void (*function)(unsigned long), unsigned long expires, unsigned long data)\r\n{\r\nstruct langwell_otg_timer *timer;\r\ntimer = kmalloc(sizeof(struct langwell_otg_timer), GFP_KERNEL);\r\nif (timer == NULL)\r\nreturn timer;\r\ntimer->function = function;\r\ntimer->expires = expires;\r\ntimer->data = data;\r\nreturn timer;\r\n}\r\nvoid langwell_update_transceiver(void)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\ndev_dbg(lnw->dev, "transceiver is updated\n");\r\nif (!lnw->qwork)\r\nreturn ;\r\nqueue_work(lnw->qwork, &lnw->work);\r\n}\r\nstatic int langwell_otg_set_host(struct otg_transceiver *otg,\r\nstruct usb_bus *host)\r\n{\r\notg->host = host;\r\nreturn 0;\r\n}\r\nstatic int langwell_otg_set_peripheral(struct otg_transceiver *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\notg->gadget = gadget;\r\nreturn 0;\r\n}\r\nstatic int langwell_otg_set_power(struct otg_transceiver *otg,\r\nunsigned mA)\r\n{\r\nreturn 0;\r\n}\r\nstatic int langwell_otg_set_vbus(struct otg_transceiver *otg, bool enabled)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nu8 sub_id;\r\ndev_dbg(lnw->dev, "%s <--- %s\n", __func__, enabled ? "on" : "off");\r\nif (enabled)\r\nsub_id = 0x8;\r\nelse\r\nsub_id = 0x9;\r\nif (intel_scu_ipc_simple_command(0xef, sub_id)) {\r\ndev_dbg(lnw->dev, "Failed to set Vbus via IPC commands\n");\r\nreturn -EBUSY;\r\n}\r\ndev_dbg(lnw->dev, "%s --->\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void langwell_otg_chrg_vbus(int on)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nu32 val;\r\nval = readl(lnw->iotg.base + CI_OTGSC);\r\nif (on)\r\nwritel((val & ~OTGSC_INTSTS_MASK) | OTGSC_VC,\r\nlnw->iotg.base + CI_OTGSC);\r\nelse\r\nwritel((val & ~OTGSC_INTSTS_MASK) | OTGSC_VD,\r\nlnw->iotg.base + CI_OTGSC);\r\n}\r\nstatic int langwell_otg_start_srp(struct otg_transceiver *otg)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nu32 val;\r\ndev_dbg(lnw->dev, "%s --->\n", __func__);\r\nval = readl(iotg->base + CI_OTGSC);\r\nwritel((val & ~OTGSC_INTSTS_MASK) | OTGSC_HADP,\r\niotg->base + CI_OTGSC);\r\nmsleep(8);\r\nval = readl(iotg->base + CI_OTGSC);\r\nif (val & (OTGSC_HADP | OTGSC_DP))\r\ndev_dbg(lnw->dev, "DataLine SRP Error\n");\r\nval = readl(iotg->base + CI_OTGSC);\r\nval &= (~(OTGSC_BSVIE | OTGSC_BSEIE));\r\nwritel(val, iotg->base + CI_OTGSC);\r\niotg->otg.set_vbus(&iotg->otg, true);\r\nmsleep(15);\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nval = readl(iotg->base + CI_OTGSC);\r\ndev_dbg(lnw->dev, "after VBUS pulse otgsc = %x\n", val);\r\nval |= (OTGSC_BSVIE | OTGSC_BSEIE);\r\nwritel(val, iotg->base + CI_OTGSC);\r\nif (val & OTGSC_BSV) {\r\ndev_dbg(lnw->dev, "no b_sess_vld interrupt\n");\r\nlnw->iotg.hsm.b_sess_vld = 1;\r\nlangwell_update_transceiver();\r\n}\r\ndev_dbg(lnw->dev, "%s <---\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void langwell_otg_loc_sof(int on)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct usb_hcd *hcd;\r\nint err;\r\ndev_dbg(lnw->dev, "%s ---> %s\n", __func__, on ? "suspend" : "resume");\r\nhcd = bus_to_hcd(lnw->iotg.otg.host);\r\nif (on)\r\nerr = hcd->driver->bus_resume(hcd);\r\nelse\r\nerr = hcd->driver->bus_suspend(hcd);\r\nif (err)\r\ndev_dbg(lnw->dev, "Fail to resume/suspend USB bus - %d\n", err);\r\ndev_dbg(lnw->dev, "%s <---\n", __func__);\r\n}\r\nstatic int langwell_otg_check_otgsc(void)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nu32 otgsc, usbcfg;\r\ndev_dbg(lnw->dev, "check sync OTGSC and USBCFG registers\n");\r\notgsc = readl(lnw->iotg.base + CI_OTGSC);\r\nusbcfg = readl(lnw->usbcfg);\r\ndev_dbg(lnw->dev, "OTGSC = %08x, USBCFG = %08x\n",\r\notgsc, usbcfg);\r\ndev_dbg(lnw->dev, "OTGSC_AVV = %d\n", !!(otgsc & OTGSC_AVV));\r\ndev_dbg(lnw->dev, "USBCFG.VBUSVAL = %d\n",\r\n!!(usbcfg & USBCFG_VBUSVAL));\r\ndev_dbg(lnw->dev, "OTGSC_ASV = %d\n", !!(otgsc & OTGSC_ASV));\r\ndev_dbg(lnw->dev, "USBCFG.AVALID = %d\n",\r\n!!(usbcfg & USBCFG_AVALID));\r\ndev_dbg(lnw->dev, "OTGSC_BSV = %d\n", !!(otgsc & OTGSC_BSV));\r\ndev_dbg(lnw->dev, "USBCFG.BVALID = %d\n",\r\n!!(usbcfg & USBCFG_BVALID));\r\ndev_dbg(lnw->dev, "OTGSC_BSE = %d\n", !!(otgsc & OTGSC_BSE));\r\ndev_dbg(lnw->dev, "USBCFG.SESEND = %d\n",\r\n!!(usbcfg & USBCFG_SESEND));\r\nif (!!(otgsc & OTGSC_AVV) ^ !!(usbcfg & USBCFG_VBUSVAL)) {\r\ndev_dbg(lnw->dev, "OTGSC.AVV != USBCFG.VBUSVAL\n");\r\ngoto err;\r\n}\r\nif (!!(otgsc & OTGSC_ASV) ^ !!(usbcfg & USBCFG_AVALID)) {\r\ndev_dbg(lnw->dev, "OTGSC.ASV != USBCFG.AVALID\n");\r\ngoto err;\r\n}\r\nif (!!(otgsc & OTGSC_BSV) ^ !!(usbcfg & USBCFG_BVALID)) {\r\ndev_dbg(lnw->dev, "OTGSC.BSV != USBCFG.BVALID\n");\r\ngoto err;\r\n}\r\nif (!!(otgsc & OTGSC_BSE) ^ !!(usbcfg & USBCFG_SESEND)) {\r\ndev_dbg(lnw->dev, "OTGSC.BSE != USBCFG.SESSEN\n");\r\ngoto err;\r\n}\r\ndev_dbg(lnw->dev, "OTGSC and USBCFG are synced\n");\r\nreturn 0;\r\nerr:\r\ndev_warn(lnw->dev, "OTGSC isn't equal to USBCFG\n");\r\nreturn -EPIPE;\r\n}\r\nstatic void langwell_otg_phy_low_power(int on)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nu8 val, phcd;\r\nint retval;\r\ndev_dbg(lnw->dev, "%s ---> %s mode\n",\r\n__func__, on ? "Low power" : "Normal");\r\nphcd = 0x40;\r\nval = readb(iotg->base + CI_HOSTPC1 + 2);\r\nif (on) {\r\nretval = langwell_otg_check_otgsc();\r\nif (retval) {\r\ndev_dbg(lnw->dev, "Skip PHCD programming..\n");\r\nreturn ;\r\n}\r\nwriteb(val | phcd, iotg->base + CI_HOSTPC1 + 2);\r\n} else\r\nwriteb(val & ~phcd, iotg->base + CI_HOSTPC1 + 2);\r\ndev_dbg(lnw->dev, "%s <--- done\n", __func__);\r\n}\r\nstatic void langwell_otg_phy_low_power_wait(int on)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\ndev_dbg(lnw->dev, "add 5ms delay before programing PHCD\n");\r\nmdelay(5);\r\nlangwell_otg_phy_low_power(on);\r\n}\r\nstatic void langwell_otg_intr(int on)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nu32 val;\r\ndev_dbg(lnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");\r\nval = readl(iotg->base + CI_OTGSC);\r\nif (on) {\r\nval = val | (OTGSC_INT_MASK);\r\nwritel(val, iotg->base + CI_OTGSC);\r\n} else {\r\nval = val & ~(OTGSC_INT_MASK);\r\nwritel(val, iotg->base + CI_OTGSC);\r\n}\r\ndev_dbg(lnw->dev, "%s <---\n", __func__);\r\n}\r\nstatic void langwell_otg_HAAR(int on)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nu32 val;\r\ndev_dbg(lnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");\r\nval = readl(iotg->base + CI_OTGSC);\r\nif (on)\r\nwritel((val & ~OTGSC_INTSTS_MASK) | OTGSC_HAAR,\r\niotg->base + CI_OTGSC);\r\nelse\r\nwritel((val & ~OTGSC_INTSTS_MASK) & ~OTGSC_HAAR,\r\niotg->base + CI_OTGSC);\r\ndev_dbg(lnw->dev, "%s <---\n", __func__);\r\n}\r\nstatic void langwell_otg_HABA(int on)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nu32 val;\r\ndev_dbg(lnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");\r\nval = readl(iotg->base + CI_OTGSC);\r\nif (on)\r\nwritel((val & ~OTGSC_INTSTS_MASK) | OTGSC_HABA,\r\niotg->base + CI_OTGSC);\r\nelse\r\nwritel((val & ~OTGSC_INTSTS_MASK) & ~OTGSC_HABA,\r\niotg->base + CI_OTGSC);\r\ndev_dbg(lnw->dev, "%s <---\n", __func__);\r\n}\r\nstatic int langwell_otg_check_se0_srp(int on)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nint delay_time = TB_SE0_SRP * 10;\r\nu32 val;\r\ndev_dbg(lnw->dev, "%s --->\n", __func__);\r\ndo {\r\nudelay(100);\r\nif (!delay_time--)\r\nbreak;\r\nval = readl(lnw->iotg.base + CI_PORTSC1);\r\nval &= PORTSC_LS;\r\n} while (!val);\r\ndev_dbg(lnw->dev, "%s <---\n", __func__);\r\nreturn val;\r\n}\r\nstatic void set_tmout(unsigned long indicator)\r\n{\r\n*(int *)indicator = 1;\r\n}\r\nvoid langwell_otg_nsf_msg(unsigned long indicator)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nswitch (indicator) {\r\ncase 2:\r\ncase 4:\r\ncase 6:\r\ncase 7:\r\ndev_warn(lnw->dev,\r\n"OTG:NSF-%lu - deivce not responding\n", indicator);\r\nbreak;\r\ncase 3:\r\ndev_warn(lnw->dev,\r\n"OTG:NSF-%lu - deivce not supported\n", indicator);\r\nbreak;\r\ndefault:\r\ndev_warn(lnw->dev, "Do not have this kind of NSF\n");\r\nbreak;\r\n}\r\n}\r\nstatic int langwell_otg_init_timers(struct otg_hsm *hsm)\r\n{\r\na_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,\r\n(unsigned long)&hsm->a_wait_vrise_tmout);\r\nif (a_wait_vrise_tmr == NULL)\r\nreturn -ENOMEM;\r\na_aidl_bdis_tmr = otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,\r\n(unsigned long)&hsm->a_aidl_bdis_tmout);\r\nif (a_aidl_bdis_tmr == NULL)\r\nreturn -ENOMEM;\r\nb_se0_srp_tmr = otg_timer_initializer(&set_tmout, TB_SE0_SRP,\r\n(unsigned long)&hsm->b_se0_srp);\r\nif (b_se0_srp_tmr == NULL)\r\nreturn -ENOMEM;\r\nb_srp_init_tmr = otg_timer_initializer(&set_tmout, TB_SRP_INIT,\r\n(unsigned long)&hsm->b_srp_init_tmout);\r\nif (b_srp_init_tmr == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void langwell_otg_free_timers(void)\r\n{\r\nkfree(a_wait_vrise_tmr);\r\nkfree(a_aidl_bdis_tmr);\r\nkfree(b_se0_srp_tmr);\r\nkfree(b_srp_init_tmr);\r\n}\r\nstatic void langwell_otg_timer_fn(unsigned long indicator)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\n*(int *)indicator = 1;\r\ndev_dbg(lnw->dev, "kernel timer - timeout\n");\r\nlangwell_update_transceiver();\r\n}\r\nstatic void langwell_otg_add_ktimer(enum langwell_otg_timer_type timers)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nunsigned long j = jiffies;\r\nunsigned long data, time;\r\nswitch (timers) {\r\ncase TA_WAIT_VRISE_TMR:\r\niotg->hsm.a_wait_vrise_tmout = 0;\r\ndata = (unsigned long)&iotg->hsm.a_wait_vrise_tmout;\r\ntime = TA_WAIT_VRISE;\r\nbreak;\r\ncase TA_WAIT_BCON_TMR:\r\niotg->hsm.a_wait_bcon_tmout = 0;\r\ndata = (unsigned long)&iotg->hsm.a_wait_bcon_tmout;\r\ntime = TA_WAIT_BCON;\r\nbreak;\r\ncase TA_AIDL_BDIS_TMR:\r\niotg->hsm.a_aidl_bdis_tmout = 0;\r\ndata = (unsigned long)&iotg->hsm.a_aidl_bdis_tmout;\r\ntime = TA_AIDL_BDIS;\r\nbreak;\r\ncase TB_ASE0_BRST_TMR:\r\niotg->hsm.b_ase0_brst_tmout = 0;\r\ndata = (unsigned long)&iotg->hsm.b_ase0_brst_tmout;\r\ntime = TB_ASE0_BRST;\r\nbreak;\r\ncase TB_SRP_INIT_TMR:\r\niotg->hsm.b_srp_init_tmout = 0;\r\ndata = (unsigned long)&iotg->hsm.b_srp_init_tmout;\r\ntime = TB_SRP_INIT;\r\nbreak;\r\ncase TB_SRP_FAIL_TMR:\r\niotg->hsm.b_srp_fail_tmout = 0;\r\ndata = (unsigned long)&iotg->hsm.b_srp_fail_tmout;\r\ntime = TB_SRP_FAIL;\r\nbreak;\r\ncase TB_BUS_SUSPEND_TMR:\r\niotg->hsm.b_bus_suspend_tmout = 0;\r\ndata = (unsigned long)&iotg->hsm.b_bus_suspend_tmout;\r\ntime = TB_BUS_SUSPEND;\r\nbreak;\r\ndefault:\r\ndev_dbg(lnw->dev, "unknown timer, cannot enable it\n");\r\nreturn;\r\n}\r\nlnw->hsm_timer.data = data;\r\nlnw->hsm_timer.function = langwell_otg_timer_fn;\r\nlnw->hsm_timer.expires = j + time * HZ / 1000;\r\nadd_timer(&lnw->hsm_timer);\r\ndev_dbg(lnw->dev, "add timer successfully\n");\r\n}\r\nstatic void langwell_otg_add_timer(void *gtimer)\r\n{\r\nstruct langwell_otg_timer *timer = (struct langwell_otg_timer *)gtimer;\r\nstruct langwell_otg_timer *tmp_timer;\r\nstruct intel_mid_otg_xceiv *iotg = &the_transceiver->iotg;\r\nu32 val32;\r\nlist_for_each_entry(tmp_timer, &active_timers, list)\r\nif (tmp_timer == timer) {\r\ntimer->count = timer->expires;\r\nreturn;\r\n}\r\ntimer->count = timer->expires;\r\nif (list_empty(&active_timers)) {\r\nval32 = readl(iotg->base + CI_OTGSC);\r\nwritel(val32 | OTGSC_1MSE, iotg->base + CI_OTGSC);\r\n}\r\nlist_add_tail(&timer->list, &active_timers);\r\n}\r\nstatic void langwell_otg_del_timer(void *gtimer)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct langwell_otg_timer *timer = (struct langwell_otg_timer *)gtimer;\r\nstruct langwell_otg_timer *tmp_timer, *del_tmp;\r\nu32 val32;\r\nlist_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list)\r\nif (tmp_timer == timer)\r\nlist_del(&timer->list);\r\nif (list_empty(&active_timers)) {\r\nval32 = readl(lnw->iotg.base + CI_OTGSC);\r\nwritel(val32 & ~OTGSC_1MSE, lnw->iotg.base + CI_OTGSC);\r\n}\r\n}\r\nstatic int langwell_otg_tick_timer(u32 *int_sts)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct langwell_otg_timer *tmp_timer, *del_tmp;\r\nint expired = 0;\r\nlist_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list) {\r\ntmp_timer->count--;\r\nif (!tmp_timer->count) {\r\nlist_del(&tmp_timer->list);\r\ntmp_timer->function(tmp_timer->data);\r\nexpired = 1;\r\n}\r\n}\r\nif (list_empty(&active_timers)) {\r\ndev_dbg(lnw->dev, "tick timer: disable 1ms int\n");\r\n*int_sts = *int_sts & ~OTGSC_1MSE;\r\n}\r\nreturn expired;\r\n}\r\nstatic void reset_otg(void)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nint delay_time = 1000;\r\nu32 val;\r\ndev_dbg(lnw->dev, "reseting OTG controller ...\n");\r\nval = readl(lnw->iotg.base + CI_USBCMD);\r\nwritel(val | USBCMD_RST, lnw->iotg.base + CI_USBCMD);\r\ndo {\r\nudelay(100);\r\nif (!delay_time--)\r\ndev_dbg(lnw->dev, "reset timeout\n");\r\nval = readl(lnw->iotg.base + CI_USBCMD);\r\nval &= USBCMD_RST;\r\n} while (val != 0);\r\ndev_dbg(lnw->dev, "reset done.\n");\r\n}\r\nstatic void set_host_mode(void)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nu32 val;\r\nreset_otg();\r\nval = readl(lnw->iotg.base + CI_USBMODE);\r\nval = (val & (~USBMODE_CM)) | USBMODE_HOST;\r\nwritel(val, lnw->iotg.base + CI_USBMODE);\r\n}\r\nstatic void set_client_mode(void)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nu32 val;\r\nreset_otg();\r\nval = readl(lnw->iotg.base + CI_USBMODE);\r\nval = (val & (~USBMODE_CM)) | USBMODE_DEVICE;\r\nwritel(val, lnw->iotg.base + CI_USBMODE);\r\n}\r\nstatic void init_hsm(void)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nu32 val32;\r\nval32 = readl(lnw->iotg.base + CI_OTGSC);\r\ndev_dbg(lnw->dev, "%s: OTGSC init value = 0x%x\n", __func__, val32);\r\nif (val32 & OTGSC_ID) {\r\niotg->hsm.id = 1;\r\niotg->otg.default_a = 0;\r\nset_client_mode();\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\n} else {\r\niotg->hsm.id = 0;\r\niotg->otg.default_a = 1;\r\nset_host_mode();\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\n}\r\nif (val32 & OTGSC_BSE)\r\niotg->hsm.b_sess_end = 1;\r\nif (val32 & OTGSC_BSV)\r\niotg->hsm.b_sess_vld = 1;\r\nif (val32 & OTGSC_ASV)\r\niotg->hsm.a_sess_vld = 1;\r\nif (val32 & OTGSC_AVV)\r\niotg->hsm.a_vbus_vld = 1;\r\niotg->hsm.a_bus_req = 1;\r\niotg->hsm.a_bus_drop = 0;\r\niotg->hsm.b_bus_req = 0;\r\niotg->hsm.a_clr_err = 0;\r\nlangwell_otg_phy_low_power_wait(1);\r\n}\r\nstatic void update_hsm(void)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nu32 val32;\r\nval32 = readl(lnw->iotg.base + CI_OTGSC);\r\ndev_dbg(lnw->dev, "%s: OTGSC value = 0x%x\n", __func__, val32);\r\niotg->hsm.id = !!(val32 & OTGSC_ID);\r\niotg->hsm.b_sess_end = !!(val32 & OTGSC_BSE);\r\niotg->hsm.b_sess_vld = !!(val32 & OTGSC_BSV);\r\niotg->hsm.a_sess_vld = !!(val32 & OTGSC_ASV);\r\niotg->hsm.a_vbus_vld = !!(val32 & OTGSC_AVV);\r\n}\r\nstatic irqreturn_t otg_dummy_irq(int irq, void *_dev)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nvoid __iomem *reg_base = _dev;\r\nu32 val;\r\nu32 int_mask = 0;\r\nval = readl(reg_base + CI_USBMODE);\r\nif ((val & USBMODE_CM) != USBMODE_DEVICE)\r\nreturn IRQ_NONE;\r\nval = readl(reg_base + CI_USBSTS);\r\nint_mask = val & INTR_DUMMY_MASK;\r\nif (int_mask == 0)\r\nreturn IRQ_NONE;\r\nif (lnw->iotg.hsm.b_conn) {\r\nlnw->iotg.hsm.b_conn = 0;\r\nif (spin_trylock(&lnw->wq_lock)) {\r\nlangwell_update_transceiver();\r\nspin_unlock(&lnw->wq_lock);\r\n}\r\n}\r\nwritel(int_mask, reg_base + CI_USBSTS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t otg_irq(int irq, void *_dev)\r\n{\r\nstruct langwell_otg *lnw = _dev;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nu32 int_sts, int_en;\r\nu32 int_mask = 0;\r\nint flag = 0;\r\nint_sts = readl(lnw->iotg.base + CI_OTGSC);\r\nint_en = (int_sts & OTGSC_INTEN_MASK) >> 8;\r\nint_mask = int_sts & int_en;\r\nif (int_mask == 0)\r\nreturn IRQ_NONE;\r\nif (int_mask & OTGSC_IDIS) {\r\ndev_dbg(lnw->dev, "%s: id change int\n", __func__);\r\niotg->hsm.id = (int_sts & OTGSC_ID) ? 1 : 0;\r\ndev_dbg(lnw->dev, "id = %d\n", iotg->hsm.id);\r\nflag = 1;\r\n}\r\nif (int_mask & OTGSC_DPIS) {\r\ndev_dbg(lnw->dev, "%s: data pulse int\n", __func__);\r\niotg->hsm.a_srp_det = (int_sts & OTGSC_DPS) ? 1 : 0;\r\ndev_dbg(lnw->dev, "data pulse = %d\n", iotg->hsm.a_srp_det);\r\nflag = 1;\r\n}\r\nif (int_mask & OTGSC_BSEIS) {\r\ndev_dbg(lnw->dev, "%s: b session end int\n", __func__);\r\niotg->hsm.b_sess_end = (int_sts & OTGSC_BSE) ? 1 : 0;\r\ndev_dbg(lnw->dev, "b_sess_end = %d\n", iotg->hsm.b_sess_end);\r\nflag = 1;\r\n}\r\nif (int_mask & OTGSC_BSVIS) {\r\ndev_dbg(lnw->dev, "%s: b session valid int\n", __func__);\r\niotg->hsm.b_sess_vld = (int_sts & OTGSC_BSV) ? 1 : 0;\r\ndev_dbg(lnw->dev, "b_sess_vld = %d\n", iotg->hsm.b_sess_end);\r\nflag = 1;\r\n}\r\nif (int_mask & OTGSC_ASVIS) {\r\ndev_dbg(lnw->dev, "%s: a session valid int\n", __func__);\r\niotg->hsm.a_sess_vld = (int_sts & OTGSC_ASV) ? 1 : 0;\r\ndev_dbg(lnw->dev, "a_sess_vld = %d\n", iotg->hsm.a_sess_vld);\r\nflag = 1;\r\n}\r\nif (int_mask & OTGSC_AVVIS) {\r\ndev_dbg(lnw->dev, "%s: a vbus valid int\n", __func__);\r\niotg->hsm.a_vbus_vld = (int_sts & OTGSC_AVV) ? 1 : 0;\r\ndev_dbg(lnw->dev, "a_vbus_vld = %d\n", iotg->hsm.a_vbus_vld);\r\nflag = 1;\r\n}\r\nif (int_mask & OTGSC_1MSS) {\r\nif (langwell_otg_tick_timer(&int_sts))\r\nflag = 1;\r\n}\r\nwritel((int_sts & ~OTGSC_INTSTS_MASK) | int_mask,\r\nlnw->iotg.base + CI_OTGSC);\r\nif (flag)\r\nlangwell_update_transceiver();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int langwell_otg_iotg_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = data;\r\nint flag = 0;\r\nif (iotg == NULL)\r\nreturn NOTIFY_BAD;\r\nif (lnw == NULL)\r\nreturn NOTIFY_BAD;\r\nswitch (action) {\r\ncase MID_OTG_NOTIFY_CONNECT:\r\ndev_dbg(lnw->dev, "Lnw OTG Notify Connect Event\n");\r\nif (iotg->otg.default_a == 1)\r\niotg->hsm.b_conn = 1;\r\nelse\r\niotg->hsm.a_conn = 1;\r\nflag = 1;\r\nbreak;\r\ncase MID_OTG_NOTIFY_DISCONN:\r\ndev_dbg(lnw->dev, "Lnw OTG Notify Disconnect Event\n");\r\nif (iotg->otg.default_a == 1)\r\niotg->hsm.b_conn = 0;\r\nelse\r\niotg->hsm.a_conn = 0;\r\nflag = 1;\r\nbreak;\r\ncase MID_OTG_NOTIFY_HSUSPEND:\r\ndev_dbg(lnw->dev, "Lnw OTG Notify Host Bus suspend Event\n");\r\nif (iotg->otg.default_a == 1)\r\niotg->hsm.a_suspend_req = 1;\r\nelse\r\niotg->hsm.b_bus_req = 0;\r\nflag = 1;\r\nbreak;\r\ncase MID_OTG_NOTIFY_HRESUME:\r\ndev_dbg(lnw->dev, "Lnw OTG Notify Host Bus resume Event\n");\r\nif (iotg->otg.default_a == 1)\r\niotg->hsm.b_bus_resume = 1;\r\nflag = 1;\r\nbreak;\r\ncase MID_OTG_NOTIFY_CSUSPEND:\r\ndev_dbg(lnw->dev, "Lnw OTG Notify Client Bus suspend Event\n");\r\nif (iotg->otg.default_a == 1) {\r\nif (iotg->hsm.b_bus_suspend_vld == 2) {\r\niotg->hsm.b_bus_suspend = 1;\r\niotg->hsm.b_bus_suspend_vld = 0;\r\nflag = 1;\r\n} else {\r\niotg->hsm.b_bus_suspend_vld++;\r\nflag = 0;\r\n}\r\n} else {\r\nif (iotg->hsm.a_bus_suspend == 0) {\r\niotg->hsm.a_bus_suspend = 1;\r\nflag = 1;\r\n}\r\n}\r\nbreak;\r\ncase MID_OTG_NOTIFY_CRESUME:\r\ndev_dbg(lnw->dev, "Lnw OTG Notify Client Bus resume Event\n");\r\nif (iotg->otg.default_a == 0)\r\niotg->hsm.a_bus_suspend = 0;\r\nflag = 0;\r\nbreak;\r\ncase MID_OTG_NOTIFY_HOSTADD:\r\ndev_dbg(lnw->dev, "Lnw OTG Nofity Host Driver Add\n");\r\nflag = 1;\r\nbreak;\r\ncase MID_OTG_NOTIFY_HOSTREMOVE:\r\ndev_dbg(lnw->dev, "Lnw OTG Nofity Host Driver remove\n");\r\nflag = 1;\r\nbreak;\r\ncase MID_OTG_NOTIFY_CLIENTADD:\r\ndev_dbg(lnw->dev, "Lnw OTG Nofity Client Driver Add\n");\r\nflag = 1;\r\nbreak;\r\ncase MID_OTG_NOTIFY_CLIENTREMOVE:\r\ndev_dbg(lnw->dev, "Lnw OTG Nofity Client Driver remove\n");\r\nflag = 1;\r\nbreak;\r\ndefault:\r\ndev_dbg(lnw->dev, "Lnw OTG Nofity unknown notify message\n");\r\nreturn NOTIFY_DONE;\r\n}\r\nif (flag)\r\nlangwell_update_transceiver();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void langwell_otg_work(struct work_struct *work)\r\n{\r\nstruct langwell_otg *lnw;\r\nstruct intel_mid_otg_xceiv *iotg;\r\nint retval;\r\nstruct pci_dev *pdev;\r\nlnw = container_of(work, struct langwell_otg, work);\r\niotg = &lnw->iotg;\r\npdev = to_pci_dev(lnw->dev);\r\ndev_dbg(lnw->dev, "%s: old state = %s\n", __func__,\r\notg_state_string(iotg->otg.state));\r\nswitch (iotg->otg.state) {\r\ncase OTG_STATE_UNDEFINED:\r\ncase OTG_STATE_B_IDLE:\r\nif (!iotg->hsm.id) {\r\nlangwell_otg_del_timer(b_srp_init_tmr);\r\ndel_timer_sync(&lnw->hsm_timer);\r\niotg->otg.default_a = 1;\r\niotg->hsm.a_srp_det = 0;\r\nlangwell_otg_chrg_vbus(0);\r\nset_host_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (iotg->hsm.b_sess_vld) {\r\nlangwell_otg_del_timer(b_srp_init_tmr);\r\ndel_timer_sync(&lnw->hsm_timer);\r\niotg->hsm.b_sess_end = 0;\r\niotg->hsm.a_bus_suspend = 0;\r\nlangwell_otg_chrg_vbus(0);\r\nif (lnw->iotg.start_peripheral) {\r\nlnw->iotg.start_peripheral(&lnw->iotg);\r\niotg->otg.state = OTG_STATE_B_PERIPHERAL;\r\n} else\r\ndev_dbg(lnw->dev, "client driver not loaded\n");\r\n} else if (iotg->hsm.b_srp_init_tmout) {\r\niotg->hsm.b_srp_init_tmout = 0;\r\ndev_warn(lnw->dev, "SRP init timeout\n");\r\n} else if (iotg->hsm.b_srp_fail_tmout) {\r\niotg->hsm.b_srp_fail_tmout = 0;\r\niotg->hsm.b_bus_req = 0;\r\nlangwell_otg_nsf_msg(6);\r\n} else if (iotg->hsm.b_bus_req && iotg->hsm.b_sess_end) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\nretval = langwell_otg_check_se0_srp(0);\r\nif (retval) {\r\niotg->hsm.b_bus_req = 0;\r\ndev_dbg(lnw->dev, "LS isn't SE0, try later\n");\r\n} else {\r\nlangwell_otg_phy_low_power(0);\r\nlangwell_otg_add_timer(b_srp_init_tmr);\r\niotg->otg.start_srp(&iotg->otg);\r\nlangwell_otg_del_timer(b_srp_init_tmr);\r\nlangwell_otg_add_ktimer(TB_SRP_FAIL_TMR);\r\nlangwell_otg_phy_low_power_wait(1);\r\n}\r\n}\r\nbreak;\r\ncase OTG_STATE_B_SRP_INIT:\r\nif (!iotg->hsm.id) {\r\niotg->otg.default_a = 1;\r\niotg->hsm.a_srp_det = 0;\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nlangwell_otg_chrg_vbus(0);\r\nset_host_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (iotg->hsm.b_sess_vld) {\r\nlangwell_otg_chrg_vbus(0);\r\nif (lnw->iotg.start_peripheral) {\r\nlnw->iotg.start_peripheral(&lnw->iotg);\r\niotg->otg.state = OTG_STATE_B_PERIPHERAL;\r\n} else\r\ndev_dbg(lnw->dev, "client driver not loaded\n");\r\n}\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (!iotg->hsm.id) {\r\niotg->otg.default_a = 1;\r\niotg->hsm.a_srp_det = 0;\r\nlangwell_otg_chrg_vbus(0);\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver has been removed.\n");\r\nset_host_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (!iotg->hsm.b_sess_vld) {\r\niotg->hsm.b_hnp_enable = 0;\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver has been removed.\n");\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\n} else if (iotg->hsm.b_bus_req && iotg->otg.gadget &&\r\niotg->otg.gadget->b_hnp_enable &&\r\niotg->hsm.a_bus_suspend) {\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver has been removed.\n");\r\nlangwell_otg_HAAR(1);\r\niotg->hsm.a_conn = 0;\r\nif (lnw->iotg.start_host) {\r\nlnw->iotg.start_host(&lnw->iotg);\r\niotg->otg.state = OTG_STATE_B_WAIT_ACON;\r\n} else\r\ndev_dbg(lnw->dev,\r\n"host driver not loaded.\n");\r\niotg->hsm.a_bus_resume = 0;\r\nlangwell_otg_add_ktimer(TB_ASE0_BRST_TMR);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\nif (!iotg->hsm.id) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\niotg->otg.default_a = 1;\r\niotg->hsm.a_srp_det = 0;\r\nlangwell_otg_chrg_vbus(0);\r\nlangwell_otg_HAAR(0);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\nset_host_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (!iotg->hsm.b_sess_vld) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\niotg->hsm.b_hnp_enable = 0;\r\niotg->hsm.b_bus_req = 0;\r\nlangwell_otg_chrg_vbus(0);\r\nlangwell_otg_HAAR(0);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\nset_client_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\n} else if (iotg->hsm.a_conn) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\nlangwell_otg_HAAR(0);\r\niotg->otg.state = OTG_STATE_B_HOST;\r\nlangwell_update_transceiver();\r\n} else if (iotg->hsm.a_bus_resume ||\r\niotg->hsm.b_ase0_brst_tmout) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\nlangwell_otg_HAAR(0);\r\nlangwell_otg_nsf_msg(7);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->hsm.a_bus_suspend = 0;\r\niotg->hsm.b_bus_req = 0;\r\nif (lnw->iotg.start_peripheral)\r\nlnw->iotg.start_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver not loaded.\n");\r\niotg->otg.state = OTG_STATE_B_PERIPHERAL;\r\n}\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nif (!iotg->hsm.id) {\r\niotg->otg.default_a = 1;\r\niotg->hsm.a_srp_det = 0;\r\nlangwell_otg_chrg_vbus(0);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\nset_host_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (!iotg->hsm.b_sess_vld) {\r\niotg->hsm.b_hnp_enable = 0;\r\niotg->hsm.b_bus_req = 0;\r\nlangwell_otg_chrg_vbus(0);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\nset_client_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\n} else if ((!iotg->hsm.b_bus_req) ||\r\n(!iotg->hsm.a_conn)) {\r\niotg->hsm.b_bus_req = 0;\r\nlangwell_otg_loc_sof(0);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->hsm.a_bus_suspend = 0;\r\nif (lnw->iotg.start_peripheral)\r\nlnw->iotg.start_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver not loaded.\n");\r\niotg->otg.state = OTG_STATE_B_PERIPHERAL;\r\n}\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\niotg->otg.default_a = 1;\r\nif (iotg->hsm.id) {\r\niotg->otg.default_a = 0;\r\niotg->hsm.b_bus_req = 0;\r\niotg->hsm.vbus_srp_up = 0;\r\nlangwell_otg_chrg_vbus(0);\r\nset_client_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (!iotg->hsm.a_bus_drop &&\r\n(iotg->hsm.a_srp_det || iotg->hsm.a_bus_req)) {\r\nlangwell_otg_phy_low_power(0);\r\niotg->otg.set_vbus(&iotg->otg, true);\r\niotg->hsm.vbus_srp_up = 0;\r\niotg->hsm.a_wait_vrise_tmout = 0;\r\nlangwell_otg_add_timer(a_wait_vrise_tmr);\r\niotg->otg.state = OTG_STATE_A_WAIT_VRISE;\r\nlangwell_update_transceiver();\r\n} else if (!iotg->hsm.a_bus_drop && iotg->hsm.a_sess_vld) {\r\niotg->hsm.vbus_srp_up = 1;\r\n} else if (!iotg->hsm.a_sess_vld && iotg->hsm.vbus_srp_up) {\r\nmsleep(10);\r\nlangwell_otg_phy_low_power(0);\r\niotg->otg.set_vbus(&iotg->otg, true);\r\niotg->hsm.a_srp_det = 1;\r\niotg->hsm.vbus_srp_up = 0;\r\niotg->hsm.a_wait_vrise_tmout = 0;\r\nlangwell_otg_add_timer(a_wait_vrise_tmr);\r\niotg->otg.state = OTG_STATE_A_WAIT_VRISE;\r\nlangwell_update_transceiver();\r\n} else if (!iotg->hsm.a_sess_vld &&\r\n!iotg->hsm.vbus_srp_up) {\r\nlangwell_otg_phy_low_power(1);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nif (iotg->hsm.id) {\r\nlangwell_otg_del_timer(a_wait_vrise_tmr);\r\niotg->hsm.b_bus_req = 0;\r\niotg->otg.default_a = 0;\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nset_client_mode();\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\n} else if (iotg->hsm.a_vbus_vld) {\r\nlangwell_otg_del_timer(a_wait_vrise_tmr);\r\niotg->hsm.b_conn = 0;\r\nif (lnw->iotg.start_host)\r\nlnw->iotg.start_host(&lnw->iotg);\r\nelse {\r\ndev_dbg(lnw->dev, "host driver not loaded.\n");\r\nbreak;\r\n}\r\nlangwell_otg_add_ktimer(TA_WAIT_BCON_TMR);\r\niotg->otg.state = OTG_STATE_A_WAIT_BCON;\r\n} else if (iotg->hsm.a_wait_vrise_tmout) {\r\niotg->hsm.b_conn = 0;\r\nif (iotg->hsm.a_vbus_vld) {\r\nif (lnw->iotg.start_host)\r\nlnw->iotg.start_host(&lnw->iotg);\r\nelse {\r\ndev_dbg(lnw->dev,\r\n"host driver not loaded.\n");\r\nbreak;\r\n}\r\nlangwell_otg_add_ktimer(TA_WAIT_BCON_TMR);\r\niotg->otg.state = OTG_STATE_A_WAIT_BCON;\r\n} else {\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_A_VBUS_ERR;\r\n}\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (iotg->hsm.id) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\niotg->otg.default_a = 0;\r\niotg->hsm.b_bus_req = 0;\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nset_client_mode();\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (!iotg->hsm.a_vbus_vld) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_A_VBUS_ERR;\r\n} else if (iotg->hsm.a_bus_drop ||\r\n(iotg->hsm.a_wait_bcon_tmout &&\r\n!iotg->hsm.a_bus_req)) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_WAIT_VFALL;\r\n} else if (iotg->hsm.b_conn) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\niotg->hsm.a_suspend_req = 0;\r\niotg->otg.state = OTG_STATE_A_HOST;\r\nif (iotg->hsm.a_srp_det && iotg->otg.host &&\r\n!iotg->otg.host->b_hnp_enable) {\r\niotg->hsm.a_bus_req = 1;\r\niotg->hsm.a_srp_det = 0;\r\n} else if (!iotg->hsm.a_bus_req && iotg->otg.host &&\r\niotg->otg.host->b_hnp_enable) {\r\nmsleep(10000);\r\nif (iotg->hsm.a_bus_req)\r\nbreak;\r\nif (request_irq(pdev->irq,\r\notg_dummy_irq, IRQF_SHARED,\r\ndriver_name, iotg->base) != 0) {\r\ndev_dbg(lnw->dev,\r\n"request interrupt %d fail\n",\r\npdev->irq);\r\n}\r\nlangwell_otg_HABA(1);\r\niotg->hsm.b_bus_resume = 0;\r\niotg->hsm.a_aidl_bdis_tmout = 0;\r\nlangwell_otg_loc_sof(0);\r\nlangwell_otg_phy_low_power(0);\r\nlangwell_otg_add_timer(a_aidl_bdis_tmr);\r\niotg->otg.state = OTG_STATE_A_SUSPEND;\r\n} else if (!iotg->hsm.a_bus_req && iotg->otg.host &&\r\n!iotg->otg.host->b_hnp_enable) {\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_WAIT_VFALL;\r\n}\r\n}\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nif (iotg->hsm.id) {\r\niotg->otg.default_a = 0;\r\niotg->hsm.b_bus_req = 0;\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nset_client_mode();\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (iotg->hsm.a_bus_drop ||\r\n(iotg->otg.host &&\r\n!iotg->otg.host->b_hnp_enable &&\r\n!iotg->hsm.a_bus_req)) {\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_WAIT_VFALL;\r\n} else if (!iotg->hsm.a_vbus_vld) {\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_A_VBUS_ERR;\r\n} else if (iotg->otg.host &&\r\niotg->otg.host->b_hnp_enable &&\r\n!iotg->hsm.a_bus_req) {\r\nif (request_irq(pdev->irq, otg_dummy_irq, IRQF_SHARED,\r\ndriver_name, iotg->base) != 0) {\r\ndev_dbg(lnw->dev,\r\n"request interrupt %d failed\n",\r\npdev->irq);\r\n}\r\nlangwell_otg_HABA(1);\r\niotg->hsm.b_bus_resume = 0;\r\niotg->hsm.a_aidl_bdis_tmout = 0;\r\nlangwell_otg_loc_sof(0);\r\nlangwell_otg_phy_low_power(0);\r\nlangwell_otg_add_timer(a_aidl_bdis_tmr);\r\niotg->otg.state = OTG_STATE_A_SUSPEND;\r\n} else if (!iotg->hsm.b_conn || !iotg->hsm.a_bus_req) {\r\nlangwell_otg_add_ktimer(TA_WAIT_BCON_TMR);\r\niotg->otg.state = OTG_STATE_A_WAIT_BCON;\r\n}\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nif (iotg->hsm.id) {\r\nlangwell_otg_del_timer(a_aidl_bdis_tmr);\r\nlangwell_otg_HABA(0);\r\nfree_irq(pdev->irq, iotg->base);\r\niotg->otg.default_a = 0;\r\niotg->hsm.b_bus_req = 0;\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nset_client_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (iotg->hsm.a_bus_req ||\r\niotg->hsm.b_bus_resume) {\r\nlangwell_otg_del_timer(a_aidl_bdis_tmr);\r\nlangwell_otg_HABA(0);\r\nfree_irq(pdev->irq, iotg->base);\r\niotg->hsm.a_suspend_req = 0;\r\nlangwell_otg_loc_sof(1);\r\niotg->otg.state = OTG_STATE_A_HOST;\r\n} else if (iotg->hsm.a_aidl_bdis_tmout ||\r\niotg->hsm.a_bus_drop) {\r\nlangwell_otg_del_timer(a_aidl_bdis_tmr);\r\nlangwell_otg_HABA(0);\r\nfree_irq(pdev->irq, iotg->base);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_WAIT_VFALL;\r\n} else if (!iotg->hsm.b_conn && iotg->otg.host &&\r\niotg->otg.host->b_hnp_enable) {\r\nlangwell_otg_del_timer(a_aidl_bdis_tmr);\r\nlangwell_otg_HABA(0);\r\nfree_irq(pdev->irq, iotg->base);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->hsm.b_bus_suspend = 0;\r\niotg->hsm.b_bus_suspend_vld = 0;\r\nif (lnw->iotg.start_peripheral)\r\nlnw->iotg.start_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver not loaded.\n");\r\nlangwell_otg_add_ktimer(TB_BUS_SUSPEND_TMR);\r\niotg->otg.state = OTG_STATE_A_PERIPHERAL;\r\nbreak;\r\n} else if (!iotg->hsm.a_vbus_vld) {\r\nlangwell_otg_del_timer(a_aidl_bdis_tmr);\r\nlangwell_otg_HABA(0);\r\nfree_irq(pdev->irq, iotg->base);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_A_VBUS_ERR;\r\n}\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nif (iotg->hsm.id) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\niotg->otg.default_a = 0;\r\niotg->hsm.b_bus_req = 0;\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nset_client_mode();\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (!iotg->hsm.a_vbus_vld) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\nlangwell_otg_phy_low_power_wait(1);\r\niotg->otg.state = OTG_STATE_A_VBUS_ERR;\r\n} else if (iotg->hsm.a_bus_drop) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver has been removed.\n");\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_WAIT_VFALL;\r\n} else if (iotg->hsm.b_bus_suspend) {\r\ndel_timer_sync(&lnw->hsm_timer);\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver has been removed.\n");\r\nif (lnw->iotg.start_host)\r\nlnw->iotg.start_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver not loaded.\n");\r\nlangwell_otg_add_ktimer(TA_WAIT_BCON_TMR);\r\niotg->otg.state = OTG_STATE_A_WAIT_BCON;\r\n} else if (iotg->hsm.b_bus_suspend_tmout) {\r\nu32 val;\r\nval = readl(lnw->iotg.base + CI_PORTSC1);\r\nif (!(val & PORTSC_SUSP))\r\nbreak;\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"client driver has been removed.\n");\r\nif (lnw->iotg.start_host)\r\nlnw->iotg.start_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev,\r\n"host driver not loaded.\n");\r\nlangwell_otg_add_ktimer(TA_WAIT_BCON_TMR);\r\niotg->otg.state = OTG_STATE_A_WAIT_BCON;\r\n}\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\nif (iotg->hsm.id) {\r\niotg->otg.default_a = 0;\r\niotg->hsm.a_clr_err = 0;\r\niotg->hsm.a_srp_det = 0;\r\nset_client_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (iotg->hsm.a_clr_err) {\r\niotg->hsm.a_clr_err = 0;\r\niotg->hsm.a_srp_det = 0;\r\nreset_otg();\r\ninit_hsm();\r\nif (iotg->otg.state == OTG_STATE_A_IDLE)\r\nlangwell_update_transceiver();\r\n} else {\r\nlangwell_otg_phy_low_power(1);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (iotg->hsm.id) {\r\niotg->otg.default_a = 0;\r\nset_client_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\nlangwell_update_transceiver();\r\n} else if (iotg->hsm.a_bus_req) {\r\niotg->otg.set_vbus(&iotg->otg, true);\r\niotg->hsm.a_wait_vrise_tmout = 0;\r\nlangwell_otg_add_timer(a_wait_vrise_tmr);\r\niotg->otg.state = OTG_STATE_A_WAIT_VRISE;\r\n} else if (!iotg->hsm.a_sess_vld) {\r\niotg->hsm.a_srp_det = 0;\r\nset_host_mode();\r\nlangwell_otg_phy_low_power(1);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\ndev_dbg(lnw->dev, "%s: new state = %s\n", __func__,\r\notg_state_string(iotg->otg.state));\r\n}\r\nstatic ssize_t\r\nshow_registers(struct device *_dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nchar *next;\r\nunsigned size, t;\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size,\r\n"\n"\r\n"USBCMD = 0x%08x\n"\r\n"USBSTS = 0x%08x\n"\r\n"USBINTR = 0x%08x\n"\r\n"ASYNCLISTADDR = 0x%08x\n"\r\n"PORTSC1 = 0x%08x\n"\r\n"HOSTPC1 = 0x%08x\n"\r\n"OTGSC = 0x%08x\n"\r\n"USBMODE = 0x%08x\n",\r\nreadl(lnw->iotg.base + 0x30),\r\nreadl(lnw->iotg.base + 0x34),\r\nreadl(lnw->iotg.base + 0x38),\r\nreadl(lnw->iotg.base + 0x48),\r\nreadl(lnw->iotg.base + 0x74),\r\nreadl(lnw->iotg.base + 0xb4),\r\nreadl(lnw->iotg.base + 0xf4),\r\nreadl(lnw->iotg.base + 0xf8)\r\n);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nshow_hsm(struct device *_dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nchar *next;\r\nunsigned size, t;\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nif (iotg->otg.host)\r\niotg->hsm.a_set_b_hnp_en = iotg->otg.host->b_hnp_enable;\r\nif (iotg->otg.gadget)\r\niotg->hsm.b_hnp_enable = iotg->otg.gadget->b_hnp_enable;\r\nt = scnprintf(next, size,\r\n"\n"\r\n"current state = %s\n"\r\n"a_bus_resume = \t%d\n"\r\n"a_bus_suspend = \t%d\n"\r\n"a_conn = \t%d\n"\r\n"a_sess_vld = \t%d\n"\r\n"a_srp_det = \t%d\n"\r\n"a_vbus_vld = \t%d\n"\r\n"b_bus_resume = \t%d\n"\r\n"b_bus_suspend = \t%d\n"\r\n"b_conn = \t%d\n"\r\n"b_se0_srp = \t%d\n"\r\n"b_sess_end = \t%d\n"\r\n"b_sess_vld = \t%d\n"\r\n"id = \t%d\n"\r\n"a_set_b_hnp_en = \t%d\n"\r\n"b_srp_done = \t%d\n"\r\n"b_hnp_enable = \t%d\n"\r\n"a_wait_vrise_tmout = \t%d\n"\r\n"a_wait_bcon_tmout = \t%d\n"\r\n"a_aidl_bdis_tmout = \t%d\n"\r\n"b_ase0_brst_tmout = \t%d\n"\r\n"a_bus_drop = \t%d\n"\r\n"a_bus_req = \t%d\n"\r\n"a_clr_err = \t%d\n"\r\n"a_suspend_req = \t%d\n"\r\n"b_bus_req = \t%d\n"\r\n"b_bus_suspend_tmout = \t%d\n"\r\n"b_bus_suspend_vld = \t%d\n",\r\notg_state_string(iotg->otg.state),\r\niotg->hsm.a_bus_resume,\r\niotg->hsm.a_bus_suspend,\r\niotg->hsm.a_conn,\r\niotg->hsm.a_sess_vld,\r\niotg->hsm.a_srp_det,\r\niotg->hsm.a_vbus_vld,\r\niotg->hsm.b_bus_resume,\r\niotg->hsm.b_bus_suspend,\r\niotg->hsm.b_conn,\r\niotg->hsm.b_se0_srp,\r\niotg->hsm.b_sess_end,\r\niotg->hsm.b_sess_vld,\r\niotg->hsm.id,\r\niotg->hsm.a_set_b_hnp_en,\r\niotg->hsm.b_srp_done,\r\niotg->hsm.b_hnp_enable,\r\niotg->hsm.a_wait_vrise_tmout,\r\niotg->hsm.a_wait_bcon_tmout,\r\niotg->hsm.a_aidl_bdis_tmout,\r\niotg->hsm.b_ase0_brst_tmout,\r\niotg->hsm.a_bus_drop,\r\niotg->hsm.a_bus_req,\r\niotg->hsm.a_clr_err,\r\niotg->hsm.a_suspend_req,\r\niotg->hsm.b_bus_req,\r\niotg->hsm.b_bus_suspend_tmout,\r\niotg->hsm.b_bus_suspend_vld\r\n);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nget_a_bus_req(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nchar *next;\r\nunsigned size, t;\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d", lnw->iotg.hsm.a_bus_req);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_a_bus_req(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nif (!iotg->otg.default_a)\r\nreturn -1;\r\nif (count > 2)\r\nreturn -1;\r\nif (buf[0] == '0') {\r\niotg->hsm.a_bus_req = 0;\r\ndev_dbg(lnw->dev, "User request: a_bus_req = 0\n");\r\n} else if (buf[0] == '1') {\r\nif (iotg->hsm.a_bus_drop)\r\nreturn -1;\r\niotg->hsm.a_bus_req = 1;\r\ndev_dbg(lnw->dev, "User request: a_bus_req = 1\n");\r\n}\r\nif (spin_trylock(&lnw->wq_lock)) {\r\nlangwell_update_transceiver();\r\nspin_unlock(&lnw->wq_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nget_a_bus_drop(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nchar *next;\r\nunsigned size, t;\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d", lnw->iotg.hsm.a_bus_drop);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_a_bus_drop(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nif (!iotg->otg.default_a)\r\nreturn -1;\r\nif (count > 2)\r\nreturn -1;\r\nif (buf[0] == '0') {\r\niotg->hsm.a_bus_drop = 0;\r\ndev_dbg(lnw->dev, "User request: a_bus_drop = 0\n");\r\n} else if (buf[0] == '1') {\r\niotg->hsm.a_bus_drop = 1;\r\niotg->hsm.a_bus_req = 0;\r\ndev_dbg(lnw->dev, "User request: a_bus_drop = 1\n");\r\ndev_dbg(lnw->dev, "User request: and a_bus_req = 0\n");\r\n}\r\nif (spin_trylock(&lnw->wq_lock)) {\r\nlangwell_update_transceiver();\r\nspin_unlock(&lnw->wq_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nget_b_bus_req(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nchar *next;\r\nunsigned size, t;\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d", lnw->iotg.hsm.b_bus_req);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_b_bus_req(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nif (iotg->otg.default_a)\r\nreturn -1;\r\nif (count > 2)\r\nreturn -1;\r\nif (buf[0] == '0') {\r\niotg->hsm.b_bus_req = 0;\r\ndev_dbg(lnw->dev, "User request: b_bus_req = 0\n");\r\n} else if (buf[0] == '1') {\r\niotg->hsm.b_bus_req = 1;\r\ndev_dbg(lnw->dev, "User request: b_bus_req = 1\n");\r\n}\r\nif (spin_trylock(&lnw->wq_lock)) {\r\nlangwell_update_transceiver();\r\nspin_unlock(&lnw->wq_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nset_a_clr_err(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nif (!iotg->otg.default_a)\r\nreturn -1;\r\nif (count > 2)\r\nreturn -1;\r\nif (buf[0] == '1') {\r\niotg->hsm.a_clr_err = 1;\r\ndev_dbg(lnw->dev, "User request: a_clr_err = 1\n");\r\n}\r\nif (spin_trylock(&lnw->wq_lock)) {\r\nlangwell_update_transceiver();\r\nspin_unlock(&lnw->wq_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic int langwell_otg_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned long resource, len;\r\nvoid __iomem *base = NULL;\r\nint retval;\r\nu32 val32;\r\nstruct langwell_otg *lnw;\r\nchar qname[] = "langwell_otg_queue";\r\nretval = 0;\r\ndev_dbg(&pdev->dev, "\notg controller is detected.\n");\r\nif (pci_enable_device(pdev) < 0) {\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\nlnw = kzalloc(sizeof *lnw, GFP_KERNEL);\r\nif (lnw == NULL) {\r\nretval = -ENOMEM;\r\ngoto done;\r\n}\r\nthe_transceiver = lnw;\r\nresource = pci_resource_start(pdev, 0);\r\nlen = pci_resource_len(pdev, 0);\r\nif (!request_mem_region(resource, len, driver_name)) {\r\nretval = -EBUSY;\r\ngoto err;\r\n}\r\nlnw->region = 1;\r\nbase = ioremap_nocache(resource, len);\r\nif (base == NULL) {\r\nretval = -EFAULT;\r\ngoto err;\r\n}\r\nlnw->iotg.base = base;\r\nif (!request_mem_region(USBCFG_ADDR, USBCFG_LEN, driver_name)) {\r\nretval = -EBUSY;\r\ngoto err;\r\n}\r\nlnw->cfg_region = 1;\r\nbase = ioremap_nocache(USBCFG_ADDR, USBCFG_LEN);\r\nif (base == NULL) {\r\nretval = -EFAULT;\r\ngoto err;\r\n}\r\nlnw->usbcfg = base;\r\nif (!pdev->irq) {\r\ndev_dbg(&pdev->dev, "No IRQ.\n");\r\nretval = -ENODEV;\r\ngoto err;\r\n}\r\nlnw->qwork = create_singlethread_workqueue(qname);\r\nif (!lnw->qwork) {\r\ndev_dbg(&pdev->dev, "cannot create workqueue %s\n", qname);\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nINIT_WORK(&lnw->work, langwell_otg_work);\r\nlnw->dev = &pdev->dev;\r\nlnw->iotg.otg.dev = lnw->dev;\r\nlnw->iotg.otg.label = driver_name;\r\nlnw->iotg.otg.set_host = langwell_otg_set_host;\r\nlnw->iotg.otg.set_peripheral = langwell_otg_set_peripheral;\r\nlnw->iotg.otg.set_power = langwell_otg_set_power;\r\nlnw->iotg.otg.set_vbus = langwell_otg_set_vbus;\r\nlnw->iotg.otg.start_srp = langwell_otg_start_srp;\r\nlnw->iotg.otg.state = OTG_STATE_UNDEFINED;\r\nif (otg_set_transceiver(&lnw->iotg.otg)) {\r\ndev_dbg(lnw->dev, "can't set transceiver\n");\r\nretval = -EBUSY;\r\ngoto err;\r\n}\r\nreset_otg();\r\ninit_hsm();\r\nspin_lock_init(&lnw->lock);\r\nspin_lock_init(&lnw->wq_lock);\r\nINIT_LIST_HEAD(&active_timers);\r\nretval = langwell_otg_init_timers(&lnw->iotg.hsm);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "Failed to init timers\n");\r\ngoto err;\r\n}\r\ninit_timer(&lnw->hsm_timer);\r\nATOMIC_INIT_NOTIFIER_HEAD(&lnw->iotg.iotg_notifier);\r\nlnw->iotg_notifier.notifier_call = langwell_otg_iotg_notify;\r\nretval = intel_mid_otg_register_notifier(&lnw->iotg,\r\n&lnw->iotg_notifier);\r\nif (retval) {\r\ndev_dbg(lnw->dev, "Failed to register notifier\n");\r\ngoto err;\r\n}\r\nif (request_irq(pdev->irq, otg_irq, IRQF_SHARED,\r\ndriver_name, lnw) != 0) {\r\ndev_dbg(lnw->dev, "request interrupt %d failed\n", pdev->irq);\r\nretval = -EBUSY;\r\ngoto err;\r\n}\r\nval32 = OTGSC_DPIE | OTGSC_BSEIE | OTGSC_BSVIE |\r\nOTGSC_ASVIE | OTGSC_AVVIE | OTGSC_IDIE | OTGSC_IDPU;\r\nwritel(val32, lnw->iotg.base + CI_OTGSC);\r\nretval = device_create_file(&pdev->dev, &dev_attr_registers);\r\nif (retval < 0) {\r\ndev_dbg(lnw->dev,\r\n"Can't register sysfs attribute: %d\n", retval);\r\ngoto err;\r\n}\r\nretval = device_create_file(&pdev->dev, &dev_attr_hsm);\r\nif (retval < 0) {\r\ndev_dbg(lnw->dev, "Can't hsm sysfs attribute: %d\n", retval);\r\ngoto err;\r\n}\r\nretval = sysfs_create_group(&pdev->dev.kobj, &debug_dev_attr_group);\r\nif (retval < 0) {\r\ndev_dbg(lnw->dev,\r\n"Can't register sysfs attr group: %d\n", retval);\r\ngoto err;\r\n}\r\nif (lnw->iotg.otg.state == OTG_STATE_A_IDLE)\r\nlangwell_update_transceiver();\r\nreturn 0;\r\nerr:\r\nif (the_transceiver)\r\nlangwell_otg_remove(pdev);\r\ndone:\r\nreturn retval;\r\n}\r\nstatic void langwell_otg_remove(struct pci_dev *pdev)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nif (lnw->qwork) {\r\nflush_workqueue(lnw->qwork);\r\ndestroy_workqueue(lnw->qwork);\r\n}\r\nintel_mid_otg_unregister_notifier(&lnw->iotg, &lnw->iotg_notifier);\r\nlangwell_otg_free_timers();\r\nwritel(0, lnw->iotg.base + CI_OTGSC);\r\nif (pdev->irq)\r\nfree_irq(pdev->irq, lnw);\r\nif (lnw->usbcfg)\r\niounmap(lnw->usbcfg);\r\nif (lnw->cfg_region)\r\nrelease_mem_region(USBCFG_ADDR, USBCFG_LEN);\r\nif (lnw->iotg.base)\r\niounmap(lnw->iotg.base);\r\nif (lnw->region)\r\nrelease_mem_region(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0));\r\notg_set_transceiver(NULL);\r\npci_disable_device(pdev);\r\nsysfs_remove_group(&pdev->dev.kobj, &debug_dev_attr_group);\r\ndevice_remove_file(&pdev->dev, &dev_attr_hsm);\r\ndevice_remove_file(&pdev->dev, &dev_attr_registers);\r\nkfree(lnw);\r\nlnw = NULL;\r\n}\r\nstatic void transceiver_suspend(struct pci_dev *pdev)\r\n{\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nlangwell_otg_phy_low_power(1);\r\n}\r\nstatic int langwell_otg_suspend(struct pci_dev *pdev, pm_message_t message)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nstruct intel_mid_otg_xceiv *iotg = &lnw->iotg;\r\nint ret = 0;\r\nlangwell_otg_intr(0);\r\nif (pdev->irq)\r\nfree_irq(pdev->irq, lnw);\r\nflush_workqueue(lnw->qwork);\r\ndestroy_workqueue(lnw->qwork);\r\nlnw->qwork = NULL;\r\nswitch (iotg->otg.state) {\r\ncase OTG_STATE_A_WAIT_VFALL:\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\ncase OTG_STATE_A_IDLE:\r\ncase OTG_STATE_B_IDLE:\r\ncase OTG_STATE_A_VBUS_ERR:\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nlangwell_otg_del_timer(a_wait_vrise_tmr);\r\niotg->hsm.a_srp_det = 0;\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndel_timer_sync(&lnw->hsm_timer);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(&pdev->dev, "host driver has been removed.\n");\r\niotg->hsm.a_srp_det = 0;\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(&pdev->dev, "host driver has been removed.\n");\r\niotg->hsm.a_srp_det = 0;\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nlangwell_otg_del_timer(a_aidl_bdis_tmr);\r\nlangwell_otg_HABA(0);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(lnw->dev, "host driver has been removed.\n");\r\niotg->hsm.a_srp_det = 0;\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\ndel_timer_sync(&lnw->hsm_timer);\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(&pdev->dev,\r\n"client driver has been removed.\n");\r\niotg->hsm.a_srp_det = 0;\r\niotg->otg.set_vbus(&iotg->otg, false);\r\niotg->otg.state = OTG_STATE_A_IDLE;\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(&pdev->dev, "host driver has been removed.\n");\r\niotg->hsm.b_bus_req = 0;\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (lnw->iotg.stop_peripheral)\r\nlnw->iotg.stop_peripheral(&lnw->iotg);\r\nelse\r\ndev_dbg(&pdev->dev,\r\n"client driver has been removed.\n");\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\ndel_timer_sync(&lnw->hsm_timer);\r\nlangwell_otg_HAAR(0);\r\nif (lnw->iotg.stop_host)\r\nlnw->iotg.stop_host(&lnw->iotg);\r\nelse\r\ndev_dbg(&pdev->dev, "host driver has been removed.\n");\r\niotg->hsm.b_bus_req = 0;\r\niotg->otg.state = OTG_STATE_B_IDLE;\r\ntransceiver_suspend(pdev);\r\nbreak;\r\ndefault:\r\ndev_dbg(lnw->dev, "error state before suspend\n");\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void transceiver_resume(struct pci_dev *pdev)\r\n{\r\npci_restore_state(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\n}\r\nstatic int langwell_otg_resume(struct pci_dev *pdev)\r\n{\r\nstruct langwell_otg *lnw = the_transceiver;\r\nint ret = 0;\r\ntransceiver_resume(pdev);\r\nlnw->qwork = create_singlethread_workqueue("langwell_otg_queue");\r\nif (!lnw->qwork) {\r\ndev_dbg(&pdev->dev, "cannot create langwell otg workqueuen");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (request_irq(pdev->irq, otg_irq, IRQF_SHARED,\r\ndriver_name, lnw) != 0) {\r\ndev_dbg(&pdev->dev, "request interrupt %d failed\n", pdev->irq);\r\nret = -EBUSY;\r\ngoto error;\r\n}\r\nlangwell_otg_intr(1);\r\nupdate_hsm();\r\nlangwell_update_transceiver();\r\nreturn ret;\r\nerror:\r\nlangwell_otg_intr(0);\r\ntransceiver_suspend(pdev);\r\nreturn ret;\r\n}\r\nstatic int __init langwell_otg_init(void)\r\n{\r\nreturn pci_register_driver(&otg_pci_driver);\r\n}\r\nstatic void __exit langwell_otg_cleanup(void)\r\n{\r\npci_unregister_driver(&otg_pci_driver);\r\n}
