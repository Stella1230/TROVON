static unsigned int nf_hashfn(struct inet_frag_queue *q)\r\n{\r\nconst struct nf_ct_frag6_queue *nq;\r\nnq = container_of(q, struct nf_ct_frag6_queue, q);\r\nreturn inet6_hash_frag(nq->id, &nq->saddr, &nq->daddr, nf_frags.rnd);\r\n}\r\nstatic void nf_skb_free(struct sk_buff *skb)\r\n{\r\nif (NFCT_FRAG6_CB(skb)->orig)\r\nkfree_skb(NFCT_FRAG6_CB(skb)->orig);\r\n}\r\nstatic __inline__ void fq_put(struct nf_ct_frag6_queue *fq)\r\n{\r\ninet_frag_put(&fq->q, &nf_frags);\r\n}\r\nstatic __inline__ void fq_kill(struct nf_ct_frag6_queue *fq)\r\n{\r\ninet_frag_kill(&fq->q, &nf_frags);\r\n}\r\nstatic void nf_ct_frag6_evictor(void)\r\n{\r\nlocal_bh_disable();\r\ninet_frag_evictor(&nf_init_frags, &nf_frags);\r\nlocal_bh_enable();\r\n}\r\nstatic void nf_ct_frag6_expire(unsigned long data)\r\n{\r\nstruct nf_ct_frag6_queue *fq;\r\nfq = container_of((struct inet_frag_queue *)data,\r\nstruct nf_ct_frag6_queue, q);\r\nspin_lock(&fq->q.lock);\r\nif (fq->q.last_in & INET_FRAG_COMPLETE)\r\ngoto out;\r\nfq_kill(fq);\r\nout:\r\nspin_unlock(&fq->q.lock);\r\nfq_put(fq);\r\n}\r\nint nf_ct_frag6_queue(struct nf_ct_frag6_queue *fq, struct sk_buff *skb,\r\nconst struct frag_hdr *fhdr, int nhoff)\r\n{\r\nstruct sk_buff *prev, *next;\r\nint offset, end;\r\nif (fq->q.last_in & INET_FRAG_COMPLETE) {\r\npr_debug("Already completed\n");\r\ngoto err;\r\n}\r\noffset = ntohs(fhdr->frag_off) & ~0x7;\r\nend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\r\n((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\r\nif ((unsigned int)end > IPV6_MAXPLEN) {\r\npr_debug("offset is too large.\n");\r\nreturn -1;\r\n}\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\nconst unsigned char *nh = skb_network_header(skb);\r\nskb->csum = csum_sub(skb->csum,\r\ncsum_partial(nh, (u8 *)(fhdr + 1) - nh,\r\n0));\r\n}\r\nif (!(fhdr->frag_off & htons(IP6_MF))) {\r\nif (end < fq->q.len ||\r\n((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len)) {\r\npr_debug("already received last fragment\n");\r\ngoto err;\r\n}\r\nfq->q.last_in |= INET_FRAG_LAST_IN;\r\nfq->q.len = end;\r\n} else {\r\nif (end & 0x7) {\r\npr_debug("end of fragment not rounded to 8 bytes.\n");\r\nreturn -1;\r\n}\r\nif (end > fq->q.len) {\r\nif (fq->q.last_in & INET_FRAG_LAST_IN) {\r\npr_debug("last packet already reached.\n");\r\ngoto err;\r\n}\r\nfq->q.len = end;\r\n}\r\n}\r\nif (end == offset)\r\ngoto err;\r\nif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data)) {\r\npr_debug("queue: message is too short.\n");\r\ngoto err;\r\n}\r\nif (pskb_trim_rcsum(skb, end - offset)) {\r\npr_debug("Can't trim\n");\r\ngoto err;\r\n}\r\nprev = fq->q.fragments_tail;\r\nif (!prev || NFCT_FRAG6_CB(prev)->offset < offset) {\r\nnext = NULL;\r\ngoto found;\r\n}\r\nprev = NULL;\r\nfor (next = fq->q.fragments; next != NULL; next = next->next) {\r\nif (NFCT_FRAG6_CB(next)->offset >= offset)\r\nbreak;\r\nprev = next;\r\n}\r\nfound:\r\nif (prev &&\r\n(NFCT_FRAG6_CB(prev)->offset + prev->len) > offset)\r\ngoto discard_fq;\r\nif (next && NFCT_FRAG6_CB(next)->offset < end)\r\ngoto discard_fq;\r\nNFCT_FRAG6_CB(skb)->offset = offset;\r\nskb->next = next;\r\nif (!next)\r\nfq->q.fragments_tail = skb;\r\nif (prev)\r\nprev->next = skb;\r\nelse\r\nfq->q.fragments = skb;\r\nskb->dev = NULL;\r\nfq->q.stamp = skb->tstamp;\r\nfq->q.meat += skb->len;\r\natomic_add(skb->truesize, &nf_init_frags.mem);\r\nif (offset == 0) {\r\nfq->nhoffset = nhoff;\r\nfq->q.last_in |= INET_FRAG_FIRST_IN;\r\n}\r\nwrite_lock(&nf_frags.lock);\r\nlist_move_tail(&fq->q.lru_list, &nf_init_frags.lru_list);\r\nwrite_unlock(&nf_frags.lock);\r\nreturn 0;\r\ndiscard_fq:\r\nfq_kill(fq);\r\nerr:\r\nreturn -1;\r\n}\r\nstatic struct sk_buff *\r\nnf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)\r\n{\r\nstruct sk_buff *fp, *op, *head = fq->q.fragments;\r\nint payload_len;\r\nfq_kill(fq);\r\nWARN_ON(head == NULL);\r\nWARN_ON(NFCT_FRAG6_CB(head)->offset != 0);\r\npayload_len = ((head->data - skb_network_header(head)) -\r\nsizeof(struct ipv6hdr) + fq->q.len -\r\nsizeof(struct frag_hdr));\r\nif (payload_len > IPV6_MAXPLEN) {\r\npr_debug("payload len is too large.\n");\r\ngoto out_oversize;\r\n}\r\nif (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC)) {\r\npr_debug("skb is cloned but can't expand head");\r\ngoto out_oom;\r\n}\r\nif (skb_has_frag_list(head)) {\r\nstruct sk_buff *clone;\r\nint i, plen = 0;\r\nif ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL) {\r\npr_debug("Can't alloc skb\n");\r\ngoto out_oom;\r\n}\r\nclone->next = head->next;\r\nhead->next = clone;\r\nskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\r\nskb_frag_list_init(head);\r\nfor (i=0; i<skb_shinfo(head)->nr_frags; i++)\r\nplen += skb_shinfo(head)->frags[i].size;\r\nclone->len = clone->data_len = head->data_len - plen;\r\nhead->data_len -= clone->len;\r\nhead->len -= clone->len;\r\nclone->csum = 0;\r\nclone->ip_summed = head->ip_summed;\r\nNFCT_FRAG6_CB(clone)->orig = NULL;\r\natomic_add(clone->truesize, &nf_init_frags.mem);\r\n}\r\nskb_network_header(head)[fq->nhoffset] = skb_transport_header(head)[0];\r\nmemmove(head->head + sizeof(struct frag_hdr), head->head,\r\n(head->data - head->head) - sizeof(struct frag_hdr));\r\nhead->mac_header += sizeof(struct frag_hdr);\r\nhead->network_header += sizeof(struct frag_hdr);\r\nskb_shinfo(head)->frag_list = head->next;\r\nskb_reset_transport_header(head);\r\nskb_push(head, head->data - skb_network_header(head));\r\nfor (fp=head->next; fp; fp = fp->next) {\r\nhead->data_len += fp->len;\r\nhead->len += fp->len;\r\nif (head->ip_summed != fp->ip_summed)\r\nhead->ip_summed = CHECKSUM_NONE;\r\nelse if (head->ip_summed == CHECKSUM_COMPLETE)\r\nhead->csum = csum_add(head->csum, fp->csum);\r\nhead->truesize += fp->truesize;\r\n}\r\natomic_sub(head->truesize, &nf_init_frags.mem);\r\nhead->next = NULL;\r\nhead->dev = dev;\r\nhead->tstamp = fq->q.stamp;\r\nipv6_hdr(head)->payload_len = htons(payload_len);\r\nif (head->ip_summed == CHECKSUM_COMPLETE)\r\nhead->csum = csum_partial(skb_network_header(head),\r\nskb_network_header_len(head),\r\nhead->csum);\r\nfq->q.fragments = NULL;\r\nfq->q.fragments_tail = NULL;\r\nfp = skb_shinfo(head)->frag_list;\r\nif (fp && NFCT_FRAG6_CB(fp)->orig == NULL)\r\nfp = fp->next;\r\nop = NFCT_FRAG6_CB(head)->orig;\r\nfor (; fp; fp = fp->next) {\r\nstruct sk_buff *orig = NFCT_FRAG6_CB(fp)->orig;\r\nop->next = orig;\r\nop = orig;\r\nNFCT_FRAG6_CB(fp)->orig = NULL;\r\n}\r\nreturn head;\r\nout_oversize:\r\nif (net_ratelimit())\r\nprintk(KERN_DEBUG "nf_ct_frag6_reasm: payload len = %d\n", payload_len);\r\ngoto out_fail;\r\nout_oom:\r\nif (net_ratelimit())\r\nprintk(KERN_DEBUG "nf_ct_frag6_reasm: no memory for reassembly\n");\r\nout_fail:\r\nreturn NULL;\r\n}\r\nstatic int\r\nfind_prev_fhdr(struct sk_buff *skb, u8 *prevhdrp, int *prevhoff, int *fhoff)\r\n{\r\nu8 nexthdr = ipv6_hdr(skb)->nexthdr;\r\nconst int netoff = skb_network_offset(skb);\r\nu8 prev_nhoff = netoff + offsetof(struct ipv6hdr, nexthdr);\r\nint start = netoff + sizeof(struct ipv6hdr);\r\nint len = skb->len - start;\r\nu8 prevhdr = NEXTHDR_IPV6;\r\nwhile (nexthdr != NEXTHDR_FRAGMENT) {\r\nstruct ipv6_opt_hdr hdr;\r\nint hdrlen;\r\nif (!ipv6_ext_hdr(nexthdr)) {\r\nreturn -1;\r\n}\r\nif (nexthdr == NEXTHDR_NONE) {\r\npr_debug("next header is none\n");\r\nreturn -1;\r\n}\r\nif (len < (int)sizeof(struct ipv6_opt_hdr)) {\r\npr_debug("too short\n");\r\nreturn -1;\r\n}\r\nif (skb_copy_bits(skb, start, &hdr, sizeof(hdr)))\r\nBUG();\r\nif (nexthdr == NEXTHDR_AUTH)\r\nhdrlen = (hdr.hdrlen+2)<<2;\r\nelse\r\nhdrlen = ipv6_optlen(&hdr);\r\nprevhdr = nexthdr;\r\nprev_nhoff = start;\r\nnexthdr = hdr.nexthdr;\r\nlen -= hdrlen;\r\nstart += hdrlen;\r\n}\r\nif (len < 0)\r\nreturn -1;\r\n*prevhdrp = prevhdr;\r\n*prevhoff = prev_nhoff;\r\n*fhoff = start;\r\nreturn 0;\r\n}\r\nstruct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)\r\n{\r\nstruct sk_buff *clone;\r\nstruct net_device *dev = skb->dev;\r\nstruct frag_hdr *fhdr;\r\nstruct nf_ct_frag6_queue *fq;\r\nstruct ipv6hdr *hdr;\r\nint fhoff, nhoff;\r\nu8 prevhdr;\r\nstruct sk_buff *ret_skb = NULL;\r\nif (ipv6_hdr(skb)->payload_len == 0) {\r\npr_debug("payload len = 0\n");\r\nreturn skb;\r\n}\r\nif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\r\nreturn skb;\r\nclone = skb_clone(skb, GFP_ATOMIC);\r\nif (clone == NULL) {\r\npr_debug("Can't clone skb\n");\r\nreturn skb;\r\n}\r\nNFCT_FRAG6_CB(clone)->orig = skb;\r\nif (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {\r\npr_debug("message is too short.\n");\r\ngoto ret_orig;\r\n}\r\nskb_set_transport_header(clone, fhoff);\r\nhdr = ipv6_hdr(clone);\r\nfhdr = (struct frag_hdr *)skb_transport_header(clone);\r\nif (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)\r\nnf_ct_frag6_evictor();\r\nfq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);\r\nif (fq == NULL) {\r\npr_debug("Can't find and can't create new queue\n");\r\ngoto ret_orig;\r\n}\r\nspin_lock_bh(&fq->q.lock);\r\nif (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {\r\nspin_unlock_bh(&fq->q.lock);\r\npr_debug("Can't insert skb to queue\n");\r\nfq_put(fq);\r\ngoto ret_orig;\r\n}\r\nif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\r\nfq->q.meat == fq->q.len) {\r\nret_skb = nf_ct_frag6_reasm(fq, dev);\r\nif (ret_skb == NULL)\r\npr_debug("Can't reassemble fragmented packets\n");\r\n}\r\nspin_unlock_bh(&fq->q.lock);\r\nfq_put(fq);\r\nreturn ret_skb;\r\nret_orig:\r\nkfree_skb(clone);\r\nreturn skb;\r\n}\r\nvoid nf_ct_frag6_output(unsigned int hooknum, struct sk_buff *skb,\r\nstruct net_device *in, struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct sk_buff *s, *s2;\r\nfor (s = NFCT_FRAG6_CB(skb)->orig; s;) {\r\nnf_conntrack_put_reasm(s->nfct_reasm);\r\nnf_conntrack_get_reasm(skb);\r\ns->nfct_reasm = skb;\r\ns2 = s->next;\r\ns->next = NULL;\r\nNF_HOOK_THRESH(NFPROTO_IPV6, hooknum, s, in, out, okfn,\r\nNF_IP6_PRI_CONNTRACK_DEFRAG + 1);\r\ns = s2;\r\n}\r\nnf_conntrack_put_reasm(skb);\r\n}\r\nint nf_ct_frag6_init(void)\r\n{\r\nnf_frags.hashfn = nf_hashfn;\r\nnf_frags.constructor = ip6_frag_init;\r\nnf_frags.destructor = NULL;\r\nnf_frags.skb_free = nf_skb_free;\r\nnf_frags.qsize = sizeof(struct nf_ct_frag6_queue);\r\nnf_frags.match = ip6_frag_match;\r\nnf_frags.frag_expire = nf_ct_frag6_expire;\r\nnf_frags.secret_interval = 10 * 60 * HZ;\r\nnf_init_frags.timeout = IPV6_FRAG_TIMEOUT;\r\nnf_init_frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\r\nnf_init_frags.low_thresh = IPV6_FRAG_LOW_THRESH;\r\ninet_frags_init_net(&nf_init_frags);\r\ninet_frags_init(&nf_frags);\r\n#ifdef CONFIG_SYSCTL\r\nnf_ct_frag6_sysctl_header = register_sysctl_paths(nf_net_netfilter_sysctl_path,\r\nnf_ct_frag6_sysctl_table);\r\nif (!nf_ct_frag6_sysctl_header) {\r\ninet_frags_fini(&nf_frags);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid nf_ct_frag6_cleanup(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nunregister_sysctl_table(nf_ct_frag6_sysctl_header);\r\nnf_ct_frag6_sysctl_header = NULL;\r\n#endif\r\ninet_frags_fini(&nf_frags);\r\nnf_init_frags.low_thresh = 0;\r\nnf_ct_frag6_evictor();\r\n}
