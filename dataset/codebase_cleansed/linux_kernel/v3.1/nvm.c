static UCHAR ReadEEPROMStatusRegister( PMINI_ADAPTER Adapter )\r\n{\r\nUCHAR uiData = 0;\r\nDWORD dwRetries = MAX_EEPROM_RETRIES*RETRIES_PER_DELAY;\r\nUINT uiStatus = 0;\r\nUINT value = 0;\r\nUINT value1 = 0;\r\nvalue = EEPROM_READ_STATUS_REGISTER ;\r\nwrmalt( Adapter, EEPROM_CMDQ_SPI_REG, &value, sizeof(value));\r\nwhile ( dwRetries != 0 )\r\n{\r\nvalue=0;\r\nuiStatus = 0 ;\r\nrdmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG,&uiStatus, sizeof(uiStatus));\r\nif(Adapter->device_removed == TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Modem has got removed hence exiting....");\r\nbreak;\r\n}\r\nif ( ( uiStatus & EEPROM_READ_DATA_AVAIL) != 0 )\r\n{\r\nvalue = uiStatus & (EEPROM_READ_DATA_AVAIL | EEPROM_READ_DATA_FULL);\r\nwrmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG, &value, sizeof(value));\r\nvalue =0;\r\nrdmalt(Adapter, EEPROM_READ_DATAQ_REG,&value, sizeof(value));\r\nuiData = (UCHAR)value;\r\nbreak;\r\n}\r\ndwRetries-- ;\r\nif ( dwRetries == 0 )\r\n{\r\nrdmalt(Adapter, EEPROM_SPI_Q_STATUS1_REG,&value, sizeof(value));\r\nrdmalt(Adapter, EEPROM_SPI_Q_STATUS_REG,&value1, sizeof(value1));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"0x3004 = %x 0x3008 = %x, retries = %d failed.\n",value,value1, MAX_EEPROM_RETRIES*RETRIES_PER_DELAY);\r\nreturn uiData;\r\n}\r\nif( !(dwRetries%RETRIES_PER_DELAY) )\r\nmsleep(1);\r\nuiStatus = 0 ;\r\n}\r\nreturn uiData;\r\n}\r\nINT ReadBeceemEEPROMBulk( PMINI_ADAPTER Adapter,\r\nDWORD dwAddress,\r\nDWORD *pdwData,\r\nDWORD dwNumWords\r\n)\r\n{\r\nDWORD dwIndex = 0;\r\nDWORD dwRetries = MAX_EEPROM_RETRIES*RETRIES_PER_DELAY;\r\nUINT uiStatus = 0;\r\nUINT value= 0;\r\nUINT value1 = 0;\r\nUCHAR *pvalue;\r\nvalue=( EEPROM_READ_QUEUE_FLUSH | EEPROM_CMD_QUEUE_FLUSH );\r\nwrmalt( Adapter, SPI_FLUSH_REG, &value, sizeof(value) );\r\nvalue=0;\r\nwrmalt( Adapter, SPI_FLUSH_REG, &value, sizeof(value));\r\nvalue=( EEPROM_READ_DATA_AVAIL | EEPROM_READ_DATA_FULL );\r\nwrmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG,&value, sizeof(value));\r\nvalue= dwAddress | ( (dwNumWords == 4) ? EEPROM_16_BYTE_PAGE_READ : EEPROM_4_BYTE_PAGE_READ );\r\nwrmalt( Adapter, EEPROM_CMDQ_SPI_REG, &value, sizeof(value));\r\nwhile ( dwRetries != 0 )\r\n{\r\nuiStatus = 0;\r\nrdmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG, &uiStatus, sizeof(uiStatus));\r\nif(Adapter->device_removed == TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Modem has got Removed.hence exiting from loop...");\r\nreturn -ENODEV;\r\n}\r\nif ( dwNumWords == 4 )\r\n{\r\nif ( ( uiStatus & EEPROM_READ_DATA_FULL ) != 0 )\r\n{\r\nvalue = ( uiStatus & (EEPROM_READ_DATA_AVAIL | EEPROM_READ_DATA_FULL) ) ;\r\nwrmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG,&value, sizeof(value));\r\nbreak;\r\n}\r\n}\r\nelse if ( dwNumWords == 1 )\r\n{\r\nif ( ( uiStatus & EEPROM_READ_DATA_AVAIL ) != 0 )\r\n{\r\nif (Adapter->chip_id == 0xBECE0210 )\r\nudelay(800);\r\nvalue=( uiStatus & (EEPROM_READ_DATA_AVAIL | EEPROM_READ_DATA_FULL) );\r\nwrmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG,&value, sizeof(value));\r\nbreak;\r\n}\r\n}\r\nuiStatus = 0;\r\ndwRetries--;\r\nif(dwRetries == 0)\r\n{\r\nvalue=0;\r\nvalue1=0;\r\nrdmalt(Adapter, EEPROM_SPI_Q_STATUS1_REG,&value, sizeof(value));\r\nrdmalt(Adapter, EEPROM_SPI_Q_STATUS_REG,&value1, sizeof(value1));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "dwNumWords %d 0x3004 = %x 0x3008 = %x retries = %d failed.\n", dwNumWords, value, value1, MAX_EEPROM_RETRIES*RETRIES_PER_DELAY);\r\nreturn STATUS_FAILURE;\r\n}\r\nif( !(dwRetries%RETRIES_PER_DELAY) )\r\nmsleep(1);\r\n}\r\nfor ( dwIndex = 0; dwIndex < dwNumWords ; dwIndex++ )\r\n{\r\npvalue = (PUCHAR)(pdwData + dwIndex);\r\nvalue =0;\r\nrdmalt(Adapter, EEPROM_READ_DATAQ_REG,&value, sizeof(value));\r\npvalue[0] = value;\r\nvalue = 0;\r\nrdmalt(Adapter, EEPROM_READ_DATAQ_REG,&value, sizeof(value));\r\npvalue[1] = value;\r\nvalue =0;\r\nrdmalt(Adapter, EEPROM_READ_DATAQ_REG,&value, sizeof(value));\r\npvalue[2] = value;\r\nvalue = 0;\r\nrdmalt(Adapter, EEPROM_READ_DATAQ_REG,&value, sizeof(value));\r\npvalue[3] = value;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT ReadBeceemEEPROM( PMINI_ADAPTER Adapter,\r\nDWORD uiOffset,\r\nDWORD *pBuffer\r\n)\r\n{\r\nUINT uiData[8] = {0};\r\nUINT uiByteOffset = 0;\r\nUINT uiTempOffset = 0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL," ====> ");\r\nuiTempOffset = uiOffset - (uiOffset % MAX_RW_SIZE);\r\nuiByteOffset = uiOffset - uiTempOffset;\r\nReadBeceemEEPROMBulk(Adapter, uiTempOffset, (PUINT)&uiData[0], 4);\r\nif ( uiByteOffset > 12 )\r\n{\r\nReadBeceemEEPROMBulk(Adapter, uiTempOffset + MAX_RW_SIZE, (PUINT)&uiData[4], 4);\r\n}\r\nmemcpy( (PUCHAR) pBuffer, ( ((PUCHAR)&uiData[0]) + uiByteOffset ), 4);\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT ReadMacAddressFromNVM(PMINI_ADAPTER Adapter)\r\n{\r\nINT Status;\r\nunsigned char puMacAddr[6];\r\nStatus = BeceemNVMRead(Adapter,\r\n(PUINT)&puMacAddr[0],\r\nINIT_PARAMS_1_MACADDRESS_ADDRESS,\r\nMAC_ADDRESS_SIZE);\r\nif(Status == STATUS_SUCCESS)\r\nmemcpy(Adapter->dev->dev_addr, puMacAddr, MAC_ADDRESS_SIZE);\r\nreturn Status;\r\n}\r\nINT BeceemEEPROMBulkRead(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nUINT uiOffset,\r\nUINT uiNumBytes)\r\n{\r\nUINT uiData[4] = {0};\r\nUINT uiBytesRemaining = uiNumBytes;\r\nUINT uiIndex = 0;\r\nUINT uiTempOffset = 0;\r\nUINT uiExtraBytes = 0;\r\nUINT uiFailureRetries = 0;\r\nPUCHAR pcBuff = (PUCHAR)pBuffer;\r\nif(uiOffset%MAX_RW_SIZE&& uiBytesRemaining)\r\n{\r\nuiTempOffset = uiOffset - (uiOffset%MAX_RW_SIZE);\r\nuiExtraBytes = uiOffset-uiTempOffset;\r\nReadBeceemEEPROMBulk(Adapter,uiTempOffset,(PUINT)&uiData[0],4);\r\nif(uiBytesRemaining >= (MAX_RW_SIZE - uiExtraBytes))\r\n{\r\nmemcpy(pBuffer,(((PUCHAR)&uiData[0])+uiExtraBytes),MAX_RW_SIZE - uiExtraBytes);\r\nuiBytesRemaining -= (MAX_RW_SIZE - uiExtraBytes);\r\nuiIndex += (MAX_RW_SIZE - uiExtraBytes);\r\nuiOffset += (MAX_RW_SIZE - uiExtraBytes);\r\n}\r\nelse\r\n{\r\nmemcpy(pBuffer,(((PUCHAR)&uiData[0])+uiExtraBytes),uiBytesRemaining);\r\nuiIndex += uiBytesRemaining;\r\nuiOffset += uiBytesRemaining;\r\nuiBytesRemaining = 0;\r\n}\r\n}\r\nwhile(uiBytesRemaining && uiFailureRetries != 128)\r\n{\r\nif(Adapter->device_removed )\r\n{\r\nreturn -1;\r\n}\r\nif(uiBytesRemaining >= MAX_RW_SIZE)\r\n{\r\nif(0 == ReadBeceemEEPROMBulk(Adapter,uiOffset,&uiData[0],4))\r\n{\r\nmemcpy(pcBuff+uiIndex,&uiData[0],MAX_RW_SIZE);\r\nuiOffset += MAX_RW_SIZE;\r\nuiBytesRemaining -= MAX_RW_SIZE;\r\nuiIndex += MAX_RW_SIZE;\r\n}\r\nelse\r\n{\r\nuiFailureRetries++;\r\nmdelay(3);\r\n}\r\n}\r\nelse if(uiBytesRemaining >= 4)\r\n{\r\nif(0 == ReadBeceemEEPROM(Adapter,uiOffset,&uiData[0]))\r\n{\r\nmemcpy(pcBuff+uiIndex,&uiData[0],4);\r\nuiOffset += 4;\r\nuiBytesRemaining -= 4;\r\nuiIndex +=4;\r\n}\r\nelse\r\n{\r\nuiFailureRetries++;\r\nmdelay(3);\r\n}\r\n}\r\nelse\r\n{\r\nPUCHAR pCharBuff = (PUCHAR)pBuffer;\r\npCharBuff += uiIndex;\r\nif(0 == ReadBeceemEEPROM(Adapter,uiOffset,&uiData[0]))\r\n{\r\nmemcpy(pCharBuff,&uiData[0],uiBytesRemaining);\r\nuiBytesRemaining = 0;\r\n}\r\nelse\r\n{\r\nuiFailureRetries++;\r\nmdelay(3);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic INT BeceemFlashBulkRead(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nUINT uiOffset,\r\nUINT uiNumBytes)\r\n{\r\nUINT uiIndex = 0;\r\nUINT uiBytesToRead = uiNumBytes;\r\nINT Status = 0;\r\nUINT uiPartOffset = 0;\r\nif(Adapter->device_removed )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Device Got Removed ");\r\nreturn -ENODEV;\r\n}\r\n#if defined(BCM_SHM_INTERFACE) && !defined(FLASH_DIRECT_ACCESS)\r\nStatus = bcmflash_raw_read((uiOffset/FLASH_PART_SIZE),(uiOffset % FLASH_PART_SIZE),( unsigned char *)pBuffer,uiNumBytes);\r\nreturn Status;\r\n#endif\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\nif(uiOffset % MAX_RW_SIZE)\r\n{\r\nBcmDoChipSelect(Adapter,uiOffset);\r\nuiPartOffset = (uiOffset & (FLASH_PART_SIZE - 1)) + GetFlashBaseAddr(Adapter);\r\nuiBytesToRead = MAX_RW_SIZE - (uiOffset%MAX_RW_SIZE);\r\nuiBytesToRead = MIN(uiNumBytes,uiBytesToRead);\r\nif(rdm(Adapter,uiPartOffset, (PCHAR)pBuffer+uiIndex,uiBytesToRead))\r\n{\r\nStatus = -1;\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\nreturn Status;\r\n}\r\nuiIndex += uiBytesToRead;\r\nuiOffset += uiBytesToRead;\r\nuiNumBytes -= uiBytesToRead;\r\n}\r\nwhile(uiNumBytes)\r\n{\r\nBcmDoChipSelect(Adapter,uiOffset);\r\nuiPartOffset = (uiOffset & (FLASH_PART_SIZE - 1)) + GetFlashBaseAddr(Adapter);\r\nuiBytesToRead = MIN(uiNumBytes,MAX_RW_SIZE);\r\nif(rdm(Adapter,uiPartOffset, (PCHAR)pBuffer+uiIndex,uiBytesToRead))\r\n{\r\nStatus = -1;\r\nbreak;\r\n}\r\nuiIndex += uiBytesToRead;\r\nuiOffset += uiBytesToRead;\r\nuiNumBytes -= uiBytesToRead;\r\n}\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\nreturn Status;\r\n}\r\nstatic UINT BcmGetFlashSize(PMINI_ADAPTER Adapter)\r\n{\r\nif(IsFlash2x(Adapter))\r\nreturn (Adapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + sizeof(DSD_HEADER));\r\nelse\r\nreturn 32*1024;\r\n}\r\nstatic UINT BcmGetEEPROMSize(PMINI_ADAPTER Adapter)\r\n{\r\nUINT uiData = 0;\r\nUINT uiIndex = 0;\r\nBeceemEEPROMBulkRead(Adapter,&uiData,0x0,4);\r\nif(uiData == BECM)\r\n{\r\nfor(uiIndex = 2;uiIndex <=256; uiIndex*=2)\r\n{\r\nBeceemEEPROMBulkRead(Adapter,&uiData,uiIndex*1024,4);\r\nif(uiData == BECM)\r\n{\r\nreturn uiIndex*1024;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nuiData = 0xBABEFACE;\r\nif(0 == BeceemEEPROMBulkWrite(Adapter,(PUCHAR)&uiData,0,4,TRUE))\r\n{\r\nuiData = 0;\r\nfor(uiIndex = 2;uiIndex <=256; uiIndex*=2)\r\n{\r\nBeceemEEPROMBulkRead(Adapter,&uiData,uiIndex*1024,4);\r\nif(uiData == 0xBABEFACE)\r\n{\r\nreturn uiIndex*1024;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic INT FlashSectorErase(PMINI_ADAPTER Adapter,\r\nUINT addr,\r\nUINT numOfSectors)\r\n{\r\nUINT iIndex = 0, iRetries = 0;\r\nUINT uiStatus = 0;\r\nUINT value;\r\nfor(iIndex=0;iIndex<numOfSectors;iIndex++)\r\n{\r\nvalue = 0x06000000;\r\nwrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value));\r\nvalue = (0xd8000000 | (addr & 0xFFFFFF));\r\nwrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value));\r\niRetries = 0;\r\ndo\r\n{\r\nvalue = (FLASH_CMD_STATUS_REG_READ << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Programing of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nif(rdmalt(Adapter, FLASH_SPI_READQ_REG, &uiStatus, sizeof(uiStatus)) < 0 )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Reading status of FLASH_SPI_READQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\niRetries++;\r\nmsleep(10);\r\n}while((uiStatus & 0x1) && (iRetries < 400));\r\nif(uiStatus & 0x1)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"iRetries crossing the limit of 80000\n");\r\nreturn STATUS_FAILURE;\r\n}\r\naddr += Adapter->uiSectorSize;\r\n}\r\nreturn 0;\r\n}\r\nstatic INT flashByteWrite(\r\nPMINI_ADAPTER Adapter,\r\nUINT uiOffset,\r\nPVOID pData)\r\n{\r\nUINT uiStatus = 0;\r\nINT iRetries = MAX_FLASH_RETRIES * FLASH_PER_RETRIES_DELAY;\r\nUINT value;\r\nULONG ulData = *(PUCHAR)pData;\r\nif(0xFF == ulData)\r\n{\r\nreturn STATUS_SUCCESS;\r\n}\r\nvalue = (FLASH_CMD_WRITE_ENABLE << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG,&value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Write enable in FLASH_SPI_CMDQ_REG register fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nif(wrm(Adapter,FLASH_SPI_WRITEQ_REG, (PCHAR)&ulData, 4) < 0 )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"DATA Write on FLASH_SPI_WRITEQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nvalue = (0x02000000 | (uiOffset & 0xFFFFFF));\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG,&value, sizeof(value)) < 0 )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Programming of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\ndo\r\n{\r\nvalue = (FLASH_CMD_STATUS_REG_READ << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Programing of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nif(rdmalt(Adapter, FLASH_SPI_READQ_REG, &uiStatus, sizeof(uiStatus)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Reading status of FLASH_SPI_READQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\niRetries--;\r\nif( iRetries && ((iRetries % FLASH_PER_RETRIES_DELAY) == 0))\r\nmsleep(1);\r\n}while((uiStatus & 0x1) && (iRetries >0) );\r\nif(uiStatus & 0x1)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Write fails even after checking status for 200 times.");\r\nreturn STATUS_FAILURE ;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic INT flashWrite(\r\nPMINI_ADAPTER Adapter,\r\nUINT uiOffset,\r\nPVOID pData)\r\n{\r\nUINT uiStatus = 0;\r\nINT iRetries = MAX_FLASH_RETRIES * FLASH_PER_RETRIES_DELAY;\r\nUINT value;\r\nUINT uiErasePattern[4] = {0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF};\r\nif (!memcmp(pData, uiErasePattern, MAX_RW_SIZE))\r\n{\r\nreturn 0;\r\n}\r\nvalue = (FLASH_CMD_WRITE_ENABLE << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG,&value, sizeof(value)) < 0 )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Write Enable of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nif(wrm(Adapter, uiOffset, (PCHAR)pData, MAX_RW_SIZE) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Data write fails...");\r\nreturn STATUS_FAILURE;\r\n}\r\ndo\r\n{\r\nvalue = (FLASH_CMD_STATUS_REG_READ << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Programing of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nif(rdmalt(Adapter, FLASH_SPI_READQ_REG, &uiStatus, sizeof(uiStatus)) < 0 )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Reading status of FLASH_SPI_READQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\niRetries--;\r\nif(iRetries && ((iRetries % FLASH_PER_RETRIES_DELAY) == 0))\r\nmsleep(1);\r\n}while((uiStatus & 0x1) && (iRetries > 0));\r\nif(uiStatus & 0x1)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Write fails even after checking status for 200 times.");\r\nreturn STATUS_FAILURE ;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic INT flashByteWriteStatus(\r\nPMINI_ADAPTER Adapter,\r\nUINT uiOffset,\r\nPVOID pData)\r\n{\r\nUINT uiStatus = 0;\r\nINT iRetries = MAX_FLASH_RETRIES * FLASH_PER_RETRIES_DELAY;\r\nULONG ulData = *(PUCHAR)pData;\r\nUINT value;\r\nif(0xFF == ulData)\r\n{\r\nreturn STATUS_SUCCESS;\r\n}\r\nvalue = (FLASH_CMD_WRITE_ENABLE << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG,&value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Write enable in FLASH_SPI_CMDQ_REG register fails");\r\nreturn STATUS_SUCCESS;\r\n}\r\nif(wrm(Adapter,FLASH_SPI_WRITEQ_REG, (PCHAR)&ulData, 4) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"DATA Write on FLASH_SPI_WRITEQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nvalue = (0x02000000 | (uiOffset & 0xFFFFFF));\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG,&value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Programming of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\ndo\r\n{\r\nvalue = (FLASH_CMD_STATUS_REG_READ << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Programing of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nif(rdmalt(Adapter, FLASH_SPI_READQ_REG, &uiStatus, sizeof(uiStatus)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Reading status of FLASH_SPI_READQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\niRetries--;\r\nif( iRetries && ((iRetries % FLASH_PER_RETRIES_DELAY) == 0))\r\nmsleep(1);\r\n}while((uiStatus & 0x1) && (iRetries > 0));\r\nif(uiStatus & 0x1)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Write fails even after checking status for 200 times.");\r\nreturn STATUS_FAILURE ;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic INT flashWriteStatus(\r\nPMINI_ADAPTER Adapter,\r\nUINT uiOffset,\r\nPVOID pData)\r\n{\r\nUINT uiStatus = 0;\r\nINT iRetries = MAX_FLASH_RETRIES * FLASH_PER_RETRIES_DELAY;\r\nUINT value;\r\nUINT uiErasePattern[4] = {0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF};\r\nif (!memcmp(pData,uiErasePattern,MAX_RW_SIZE))\r\n{\r\nreturn 0;\r\n}\r\nvalue = (FLASH_CMD_WRITE_ENABLE << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG,&value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Write Enable of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nif(wrm(Adapter, uiOffset, (PCHAR)pData, MAX_RW_SIZE) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Data write fails...");\r\nreturn STATUS_FAILURE;\r\n}\r\ndo\r\n{\r\nvalue = (FLASH_CMD_STATUS_REG_READ << 24);\r\nif(wrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Programing of FLASH_SPI_CMDQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\nif(rdmalt(Adapter, FLASH_SPI_READQ_REG, &uiStatus, sizeof(uiStatus)) < 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Reading status of FLASH_SPI_READQ_REG fails");\r\nreturn STATUS_FAILURE;\r\n}\r\niRetries--;\r\nif(iRetries && ((iRetries % FLASH_PER_RETRIES_DELAY) == 0))\r\nmsleep(1);\r\n}while((uiStatus & 0x1) && (iRetries >0));\r\nif(uiStatus & 0x1)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Write fails even after checking status for 200 times.");\r\nreturn STATUS_FAILURE ;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic VOID BcmRestoreBlockProtectStatus(PMINI_ADAPTER Adapter,ULONG ulWriteStatus)\r\n{\r\nUINT value;\r\nvalue = (FLASH_CMD_WRITE_ENABLE<< 24);\r\nwrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value));\r\nudelay(20);\r\nvalue = (FLASH_CMD_STATUS_REG_WRITE<<24)|(ulWriteStatus << 16);\r\nwrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value));\r\nudelay(20);\r\n}\r\nstatic ULONG BcmFlashUnProtectBlock(PMINI_ADAPTER Adapter,UINT uiOffset, UINT uiLength)\r\n{\r\nULONG ulStatus = 0;\r\nULONG ulWriteStatus = 0;\r\nUINT value;\r\nuiOffset = uiOffset&0x000FFFFF;\r\nif(FLASH_PART_SST25VF080B == Adapter->ulFlashID)\r\n{\r\nvalue = (FLASH_CMD_STATUS_REG_READ << 24);\r\nwrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value));\r\nudelay(10);\r\nrdmalt(Adapter, FLASH_SPI_READQ_REG, (PUINT)&ulStatus, sizeof(ulStatus));\r\nulStatus >>= 24;\r\nulWriteStatus = ulStatus;\r\nif(ulStatus)\r\n{\r\nif((uiOffset+uiLength) <= 0x80000)\r\n{\r\nulWriteStatus |= (0x4<<2);\r\nulWriteStatus &= ~(0x3<<2);\r\n}\r\nelse if((uiOffset+uiLength) <= 0xC0000)\r\n{\r\nulWriteStatus |= (0x3<<2);\r\nulWriteStatus &= ~(0x1<<4);\r\n}\r\nelse if((uiOffset+uiLength) <= 0xE0000)\r\n{\r\nulWriteStatus |= (0x1<<3);\r\nulWriteStatus &= ~(0x5<<2);\r\n}\r\nelse if((uiOffset+uiLength) <= 0xF0000)\r\n{\r\nulWriteStatus |= (0x1<<2);\r\nulWriteStatus &= ~(0x3<<3);\r\n}\r\nelse\r\n{\r\nulWriteStatus &= ~(0x7<<2);\r\n}\r\nvalue = (FLASH_CMD_WRITE_ENABLE<< 24);\r\nwrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value));\r\nudelay(20);\r\nvalue = (FLASH_CMD_STATUS_REG_WRITE<<24)|(ulWriteStatus << 16);\r\nwrmalt(Adapter, FLASH_SPI_CMDQ_REG, &value, sizeof(value));\r\nudelay(20);\r\n}\r\n}\r\nreturn ulStatus;\r\n}\r\nstatic INT BeceemFlashBulkWrite(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nUINT uiOffset,\r\nUINT uiNumBytes,\r\nBOOLEAN bVerify)\r\n{\r\nPCHAR pTempBuff = NULL;\r\nPUCHAR pcBuffer = (PUCHAR)pBuffer;\r\nUINT uiIndex = 0;\r\nUINT uiOffsetFromSectStart = 0;\r\nUINT uiSectAlignAddr = 0;\r\nUINT uiCurrSectOffsetAddr = 0;\r\nUINT uiSectBoundary = 0;\r\nUINT uiNumSectTobeRead = 0;\r\nUCHAR ucReadBk[16] = {0};\r\nULONG ulStatus = 0;\r\nINT Status = STATUS_SUCCESS;\r\nUINT uiTemp = 0;\r\nUINT index = 0;\r\nUINT uiPartOffset = 0;\r\n#if defined(BCM_SHM_INTERFACE) && !defined(FLASH_DIRECT_ACCESS)\r\nStatus = bcmflash_raw_write((uiOffset/FLASH_PART_SIZE),(uiOffset % FLASH_PART_SIZE),( unsigned char *)pBuffer,uiNumBytes);\r\nreturn Status;\r\n#endif\r\nuiOffsetFromSectStart = uiOffset & ~(Adapter->uiSectorSize - 1);\r\nuiSectAlignAddr = uiOffset & ~(Adapter->uiSectorSize - 1);\r\nuiCurrSectOffsetAddr = uiOffset & (Adapter->uiSectorSize - 1);\r\nuiSectBoundary = uiSectAlignAddr + Adapter->uiSectorSize;\r\npTempBuff = kmalloc(Adapter->uiSectorSize, GFP_KERNEL);\r\nif(NULL == pTempBuff)\r\ngoto BeceemFlashBulkWrite_EXIT;\r\nif(uiOffset+uiNumBytes < uiSectBoundary)\r\n{\r\nuiNumSectTobeRead = 1;\r\n}\r\nelse\r\n{\r\nuiNumSectTobeRead = (uiCurrSectOffsetAddr+uiNumBytes)/Adapter->uiSectorSize;\r\nif((uiCurrSectOffsetAddr+uiNumBytes)%Adapter->uiSectorSize)\r\n{\r\nuiNumSectTobeRead++;\r\n}\r\n}\r\nif(IsFlash2x(Adapter) && (Adapter->bAllDSDWriteAllow == FALSE))\r\n{\r\nindex = 0;\r\nuiTemp = uiNumSectTobeRead ;\r\nwhile(uiTemp)\r\n{\r\nif(IsOffsetWritable(Adapter, uiOffsetFromSectStart + index * Adapter->uiSectorSize ) == FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Sector Starting at offset <0X%X> is not writable",\r\n(uiOffsetFromSectStart + index * Adapter->uiSectorSize));\r\nStatus = SECTOR_IS_NOT_WRITABLE;\r\ngoto BeceemFlashBulkWrite_EXIT;\r\n}\r\nuiTemp = uiTemp - 1;\r\nindex = index + 1 ;\r\n}\r\n}\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\nwhile(uiNumSectTobeRead)\r\n{\r\nuiPartOffset = (uiSectAlignAddr & (FLASH_PART_SIZE - 1)) + GetFlashBaseAddr(Adapter);\r\nBcmDoChipSelect(Adapter,uiSectAlignAddr);\r\nif(0 != BeceemFlashBulkRead(Adapter,\r\n(PUINT)pTempBuff,\r\nuiOffsetFromSectStart,\r\nAdapter->uiSectorSize))\r\n{\r\nStatus = -1;\r\ngoto BeceemFlashBulkWrite_EXIT;\r\n}\r\nulStatus = BcmFlashUnProtectBlock(Adapter,uiSectAlignAddr,Adapter->uiSectorSize);\r\nif(uiNumSectTobeRead > 1)\r\n{\r\nmemcpy(&pTempBuff[uiCurrSectOffsetAddr],pcBuffer,uiSectBoundary-(uiSectAlignAddr+uiCurrSectOffsetAddr));\r\npcBuffer += ((uiSectBoundary-(uiSectAlignAddr+uiCurrSectOffsetAddr)));\r\nuiNumBytes -= (uiSectBoundary-(uiSectAlignAddr+uiCurrSectOffsetAddr));\r\n}\r\nelse\r\n{\r\nmemcpy(&pTempBuff[uiCurrSectOffsetAddr],pcBuffer,uiNumBytes);\r\n}\r\nif(IsFlash2x(Adapter))\r\n{\r\nSaveHeaderIfPresent(Adapter,(PUCHAR)pTempBuff,uiOffsetFromSectStart);\r\n}\r\nFlashSectorErase(Adapter,uiPartOffset,1);\r\nfor(uiIndex = 0; uiIndex < Adapter->uiSectorSize; uiIndex +=Adapter->ulFlashWriteSize)\r\n{\r\nif(Adapter->device_removed)\r\n{\r\nStatus = -1;\r\ngoto BeceemFlashBulkWrite_EXIT;\r\n}\r\nif(STATUS_SUCCESS != (*Adapter->fpFlashWrite)(Adapter,uiPartOffset+uiIndex,(&pTempBuff[uiIndex])))\r\n{\r\nStatus = -1;\r\ngoto BeceemFlashBulkWrite_EXIT;\r\n}\r\n}\r\nfor(uiIndex = 0;uiIndex < Adapter->uiSectorSize;uiIndex += MAX_RW_SIZE)\r\n{\r\nif(STATUS_SUCCESS == BeceemFlashBulkRead(Adapter,(PUINT)ucReadBk,uiOffsetFromSectStart+uiIndex,MAX_RW_SIZE))\r\n{\r\nif(Adapter->ulFlashWriteSize == 1)\r\n{\r\nUINT uiReadIndex = 0;\r\nfor(uiReadIndex = 0; uiReadIndex < 16; uiReadIndex++)\r\n{\r\nif(ucReadBk[uiReadIndex] != pTempBuff[uiIndex+uiReadIndex])\r\n{\r\nif(STATUS_SUCCESS != (*Adapter->fpFlashWriteWithStatusCheck)(Adapter,uiPartOffset+uiIndex+uiReadIndex,&pTempBuff[uiIndex+uiReadIndex]))\r\n{\r\nStatus = STATUS_FAILURE;\r\ngoto BeceemFlashBulkWrite_EXIT;\r\n}\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif(memcmp(ucReadBk,&pTempBuff[uiIndex],MAX_RW_SIZE))\r\n{\r\nif(STATUS_SUCCESS != (*Adapter->fpFlashWriteWithStatusCheck)(Adapter,uiPartOffset+uiIndex,&pTempBuff[uiIndex]))\r\n{\r\nStatus = STATUS_FAILURE;\r\ngoto BeceemFlashBulkWrite_EXIT;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif(ulStatus)\r\n{\r\nBcmRestoreBlockProtectStatus(Adapter,ulStatus);\r\nulStatus = 0;\r\n}\r\nuiCurrSectOffsetAddr = 0;\r\nuiSectAlignAddr = uiSectBoundary;\r\nuiSectBoundary += Adapter->uiSectorSize;\r\nuiOffsetFromSectStart += Adapter->uiSectorSize;\r\nuiNumSectTobeRead--;\r\n}\r\nBeceemFlashBulkWrite_EXIT:\r\nif(ulStatus)\r\n{\r\nBcmRestoreBlockProtectStatus(Adapter,ulStatus);\r\n}\r\nkfree(pTempBuff);\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\nreturn Status;\r\n}\r\nstatic INT BeceemFlashBulkWriteStatus(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nUINT uiOffset,\r\nUINT uiNumBytes,\r\nBOOLEAN bVerify)\r\n{\r\nPCHAR pTempBuff = NULL;\r\nPUCHAR pcBuffer = (PUCHAR)pBuffer;\r\nUINT uiIndex = 0;\r\nUINT uiOffsetFromSectStart = 0;\r\nUINT uiSectAlignAddr = 0;\r\nUINT uiCurrSectOffsetAddr = 0;\r\nUINT uiSectBoundary = 0;\r\nUINT uiNumSectTobeRead = 0;\r\nUCHAR ucReadBk[16] = {0};\r\nULONG ulStatus = 0;\r\nUINT Status = STATUS_SUCCESS;\r\nUINT uiTemp = 0;\r\nUINT index = 0;\r\nUINT uiPartOffset = 0;\r\nuiOffsetFromSectStart = uiOffset & ~(Adapter->uiSectorSize - 1);\r\nuiSectAlignAddr = uiOffset & ~(Adapter->uiSectorSize - 1);\r\nuiCurrSectOffsetAddr = uiOffset & (Adapter->uiSectorSize - 1);\r\nuiSectBoundary = uiSectAlignAddr + Adapter->uiSectorSize;\r\npTempBuff = kmalloc(Adapter->uiSectorSize, GFP_KERNEL);\r\nif(NULL == pTempBuff)\r\ngoto BeceemFlashBulkWriteStatus_EXIT;\r\nif(uiOffset+uiNumBytes < uiSectBoundary)\r\n{\r\nuiNumSectTobeRead = 1;\r\n}\r\nelse\r\n{\r\nuiNumSectTobeRead = (uiCurrSectOffsetAddr+uiNumBytes)/Adapter->uiSectorSize;\r\nif((uiCurrSectOffsetAddr+uiNumBytes)%Adapter->uiSectorSize)\r\n{\r\nuiNumSectTobeRead++;\r\n}\r\n}\r\nif(IsFlash2x(Adapter) && (Adapter->bAllDSDWriteAllow == FALSE))\r\n{\r\nindex = 0;\r\nuiTemp = uiNumSectTobeRead ;\r\nwhile(uiTemp)\r\n{\r\nif(IsOffsetWritable(Adapter,uiOffsetFromSectStart + index * Adapter->uiSectorSize ) == FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Sector Starting at offset <0X%x> is not writable",\r\n(uiOffsetFromSectStart + index * Adapter->uiSectorSize));\r\nStatus = SECTOR_IS_NOT_WRITABLE;\r\ngoto BeceemFlashBulkWriteStatus_EXIT;\r\n}\r\nuiTemp = uiTemp - 1;\r\nindex = index + 1 ;\r\n}\r\n}\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\nwhile(uiNumSectTobeRead)\r\n{\r\nuiPartOffset = (uiSectAlignAddr & (FLASH_PART_SIZE - 1)) + GetFlashBaseAddr(Adapter);\r\nBcmDoChipSelect(Adapter,uiSectAlignAddr);\r\nif(0 != BeceemFlashBulkRead(Adapter,\r\n(PUINT)pTempBuff,\r\nuiOffsetFromSectStart,\r\nAdapter->uiSectorSize))\r\n{\r\nStatus = -1;\r\ngoto BeceemFlashBulkWriteStatus_EXIT;\r\n}\r\nulStatus = BcmFlashUnProtectBlock(Adapter,uiOffsetFromSectStart,Adapter->uiSectorSize);\r\nif(uiNumSectTobeRead > 1)\r\n{\r\nmemcpy(&pTempBuff[uiCurrSectOffsetAddr],pcBuffer,uiSectBoundary-(uiSectAlignAddr+uiCurrSectOffsetAddr));\r\npcBuffer += ((uiSectBoundary-(uiSectAlignAddr+uiCurrSectOffsetAddr)));\r\nuiNumBytes -= (uiSectBoundary-(uiSectAlignAddr+uiCurrSectOffsetAddr));\r\n}\r\nelse\r\n{\r\nmemcpy(&pTempBuff[uiCurrSectOffsetAddr],pcBuffer,uiNumBytes);\r\n}\r\nif(IsFlash2x(Adapter))\r\n{\r\nSaveHeaderIfPresent(Adapter,(PUCHAR)pTempBuff,uiOffsetFromSectStart);\r\n}\r\nFlashSectorErase(Adapter,uiPartOffset,1);\r\nfor(uiIndex = 0; uiIndex < Adapter->uiSectorSize; uiIndex +=Adapter->ulFlashWriteSize)\r\n{\r\nif(Adapter->device_removed)\r\n{\r\nStatus = -1;\r\ngoto BeceemFlashBulkWriteStatus_EXIT;\r\n}\r\nif(STATUS_SUCCESS != (*Adapter->fpFlashWriteWithStatusCheck)(Adapter,uiPartOffset+uiIndex,&pTempBuff[uiIndex]))\r\n{\r\nStatus = -1;\r\ngoto BeceemFlashBulkWriteStatus_EXIT;\r\n}\r\n}\r\nif(bVerify)\r\n{\r\nfor(uiIndex = 0;uiIndex < Adapter->uiSectorSize;uiIndex += MAX_RW_SIZE)\r\n{\r\nif(STATUS_SUCCESS == BeceemFlashBulkRead(Adapter,(PUINT)ucReadBk,uiOffsetFromSectStart+uiIndex,MAX_RW_SIZE))\r\n{\r\nif(memcmp(ucReadBk,&pTempBuff[uiIndex],MAX_RW_SIZE))\r\n{\r\nStatus = STATUS_FAILURE;\r\ngoto BeceemFlashBulkWriteStatus_EXIT;\r\n}\r\n}\r\n}\r\n}\r\nif(ulStatus)\r\n{\r\nBcmRestoreBlockProtectStatus(Adapter,ulStatus);\r\nulStatus = 0;\r\n}\r\nuiCurrSectOffsetAddr = 0;\r\nuiSectAlignAddr = uiSectBoundary;\r\nuiSectBoundary += Adapter->uiSectorSize;\r\nuiOffsetFromSectStart += Adapter->uiSectorSize;\r\nuiNumSectTobeRead--;\r\n}\r\nBeceemFlashBulkWriteStatus_EXIT:\r\nif(ulStatus)\r\n{\r\nBcmRestoreBlockProtectStatus(Adapter,ulStatus);\r\n}\r\nkfree(pTempBuff);\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\nreturn Status;\r\n}\r\nINT PropagateCalParamsFromEEPROMToMemory(PMINI_ADAPTER Adapter)\r\n{\r\nPCHAR pBuff = kmalloc(BUFFER_4K, GFP_KERNEL);\r\nUINT uiEepromSize = 0;\r\nUINT uiIndex = 0;\r\nUINT uiBytesToCopy = 0;\r\nUINT uiCalStartAddr = EEPROM_CALPARAM_START;\r\nUINT uiMemoryLoc = EEPROM_CAL_DATA_INTERNAL_LOC;\r\nUINT value;\r\nINT Status = 0;\r\nif(pBuff == NULL)\r\n{\r\nreturn -1;\r\n}\r\nif(0 != BeceemEEPROMBulkRead(Adapter,&uiEepromSize,EEPROM_SIZE_OFFSET,4))\r\n{\r\nkfree(pBuff);\r\nreturn -1;\r\n}\r\nuiEepromSize >>= 16;\r\nif(uiEepromSize > 1024*1024)\r\n{\r\nkfree(pBuff);\r\nreturn -1;\r\n}\r\nuiBytesToCopy = MIN(BUFFER_4K,uiEepromSize);\r\nwhile(uiBytesToCopy)\r\n{\r\nif(0 != BeceemEEPROMBulkRead(Adapter,(PUINT)pBuff,uiCalStartAddr,uiBytesToCopy))\r\n{\r\nStatus = -1;\r\nbreak;\r\n}\r\nwrm(Adapter,uiMemoryLoc,(PCHAR)(((PULONG)pBuff)+uiIndex),uiBytesToCopy);\r\nuiMemoryLoc += uiBytesToCopy;\r\nuiEepromSize -= uiBytesToCopy;\r\nuiCalStartAddr += uiBytesToCopy;\r\nuiIndex += uiBytesToCopy/4;\r\nuiBytesToCopy = MIN(BUFFER_4K,uiEepromSize);\r\n}\r\nvalue = 0xbeadbead;\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC-4,&value, sizeof(value));\r\nvalue = 0xbeadbead;\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC-8,&value, sizeof(value));\r\nkfree(pBuff);\r\nreturn Status;\r\n}\r\nINT PropagateCalParamsFromFlashToMemory(PMINI_ADAPTER Adapter)\r\n{\r\nPCHAR pBuff, pPtr;\r\nUINT uiEepromSize = 0;\r\nUINT uiBytesToCopy = 0;\r\nUINT uiCalStartAddr = EEPROM_CALPARAM_START;\r\nUINT uiMemoryLoc = EEPROM_CAL_DATA_INTERNAL_LOC;\r\nUINT value;\r\nINT Status = 0;\r\nvalue = 0xbeadbead;\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC - 4, &value, sizeof(value));\r\nvalue = 0xbeadbead;\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC - 8, &value, sizeof(value));\r\nif(0 != BeceemNVMRead(Adapter,&uiEepromSize,EEPROM_SIZE_OFFSET, 4))\r\n{\r\nreturn -1;\r\n}\r\nuiEepromSize = ntohl(uiEepromSize);\r\nuiEepromSize >>= 16;\r\nuiEepromSize -= EEPROM_CALPARAM_START;\r\nif(uiEepromSize > 1024*1024)\r\n{\r\nreturn -1;\r\n}\r\npBuff = kmalloc(uiEepromSize, GFP_KERNEL);\r\nif ( pBuff == NULL )\r\nreturn -1;\r\nif(0 != BeceemNVMRead(Adapter,(PUINT)pBuff,uiCalStartAddr, uiEepromSize))\r\n{\r\nkfree(pBuff);\r\nreturn -1;\r\n}\r\npPtr = pBuff;\r\nuiBytesToCopy = MIN(BUFFER_4K,uiEepromSize);\r\nwhile(uiBytesToCopy)\r\n{\r\nStatus = wrm(Adapter,uiMemoryLoc,(PCHAR)pPtr,uiBytesToCopy);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"wrm failed with status :%d",Status);\r\nbreak;\r\n}\r\npPtr += uiBytesToCopy;\r\nuiEepromSize -= uiBytesToCopy;\r\nuiMemoryLoc += uiBytesToCopy;\r\nuiBytesToCopy = MIN(BUFFER_4K,uiEepromSize);\r\n}\r\nkfree(pBuff);\r\nreturn Status;\r\n}\r\nstatic INT BeceemEEPROMReadBackandVerify(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nUINT uiOffset,\r\nUINT uiNumBytes)\r\n{\r\nUINT uiRdbk = 0;\r\nUINT uiIndex = 0;\r\nUINT uiData = 0;\r\nUINT auiData[4] = {0};\r\nwhile(uiNumBytes)\r\n{\r\nif(Adapter->device_removed )\r\n{\r\nreturn -1;\r\n}\r\nif(uiNumBytes >= MAX_RW_SIZE)\r\n{\r\nBeceemEEPROMBulkRead(Adapter,&auiData[0],uiOffset,MAX_RW_SIZE);\r\nif(memcmp(&pBuffer[uiIndex],&auiData[0],MAX_RW_SIZE))\r\n{\r\nBeceemEEPROMBulkWrite(Adapter,(PUCHAR)(pBuffer+uiIndex),uiOffset,MAX_RW_SIZE,FALSE);\r\nmdelay(3);\r\nBeceemEEPROMBulkRead(Adapter,&auiData[0],uiOffset,MAX_RW_SIZE);\r\nif(memcmp(&pBuffer[uiIndex],&auiData[0],MAX_RW_SIZE))\r\n{\r\nreturn -1;\r\n}\r\n}\r\nuiOffset += MAX_RW_SIZE;\r\nuiNumBytes -= MAX_RW_SIZE;\r\nuiIndex += 4;\r\n}\r\nelse if(uiNumBytes >= 4)\r\n{\r\nBeceemEEPROMBulkRead(Adapter,&uiData,uiOffset,4);\r\nif(uiData != pBuffer[uiIndex])\r\n{\r\nBeceemEEPROMBulkWrite(Adapter,(PUCHAR)(pBuffer+uiIndex),uiOffset,4,FALSE);\r\nmdelay(3);\r\nBeceemEEPROMBulkRead(Adapter,&uiData,uiOffset,4);\r\nif(uiData != pBuffer[uiIndex])\r\n{\r\nreturn -1;\r\n}\r\n}\r\nuiOffset += 4;\r\nuiNumBytes -= 4;\r\nuiIndex++;\r\n}\r\nelse\r\n{\r\nuiData = 0;\r\nmemcpy(&uiData,((PUCHAR)pBuffer)+(uiIndex*sizeof(UINT)),uiNumBytes);\r\nBeceemEEPROMBulkRead(Adapter,&uiRdbk,uiOffset,4);\r\nif(memcmp(&uiData, &uiRdbk, uiNumBytes))\r\nreturn -1;\r\nuiNumBytes = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic VOID BcmSwapWord(UINT *ptr1) {\r\nUINT tempval = (UINT)*ptr1;\r\nchar *ptr2 = (char *)&tempval;\r\nchar *ptr = (char *)ptr1;\r\nptr[0] = ptr2[3];\r\nptr[1] = ptr2[2];\r\nptr[2] = ptr2[1];\r\nptr[3] = ptr2[0];\r\n}\r\nstatic INT BeceemEEPROMWritePage( PMINI_ADAPTER Adapter, UINT uiData[], UINT uiOffset )\r\n{\r\nUINT uiRetries = MAX_EEPROM_RETRIES*RETRIES_PER_DELAY;\r\nUINT uiStatus = 0;\r\nUCHAR uiEpromStatus = 0;\r\nUINT value =0 ;\r\nvalue = ( EEPROM_WRITE_QUEUE_FLUSH | EEPROM_CMD_QUEUE_FLUSH | EEPROM_READ_QUEUE_FLUSH );\r\nwrmalt( Adapter, SPI_FLUSH_REG, &value, sizeof(value));\r\nvalue = 0 ;\r\nwrmalt( Adapter, SPI_FLUSH_REG, &value, sizeof(value) );\r\nvalue = ( EEPROM_WRITE_QUEUE_EMPTY | EEPROM_WRITE_QUEUE_AVAIL | EEPROM_WRITE_QUEUE_FULL | EEPROM_READ_DATA_AVAIL | EEPROM_READ_DATA_FULL ) ;\r\nwrmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG,&value, sizeof(value));\r\nvalue = EEPROM_WRITE_ENABLE ;\r\nwrmalt( Adapter, EEPROM_CMDQ_SPI_REG,&value, sizeof(value) );\r\nvalue = uiData[0];\r\nBcmSwapWord(&value);\r\nwrm( Adapter, EEPROM_WRITE_DATAQ_REG, (PUCHAR)&value, 4);\r\nvalue = uiData[1];\r\nBcmSwapWord(&value);\r\nwrm( Adapter, EEPROM_WRITE_DATAQ_REG, (PUCHAR)&value, 4);\r\nvalue = uiData[2];\r\nBcmSwapWord(&value);\r\nwrm( Adapter, EEPROM_WRITE_DATAQ_REG, (PUCHAR)&value, 4);\r\nvalue = uiData[3];\r\nBcmSwapWord(&value);\r\nwrm( Adapter, EEPROM_WRITE_DATAQ_REG, (PUCHAR)&value, 4);\r\nvalue = EEPROM_16_BYTE_PAGE_WRITE | uiOffset ;\r\nwrmalt( Adapter, EEPROM_CMDQ_SPI_REG, &value, sizeof(value) );\r\nuiStatus = 0;\r\nrdmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG,&uiStatus, sizeof(uiStatus)) ;\r\nwhile ( ( uiStatus & EEPROM_WRITE_QUEUE_EMPTY ) == 0 )\r\n{\r\nuiRetries--;\r\nif ( uiRetries == 0 )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "0x0f003004 = %x, %d retries failed.\n", uiStatus, MAX_EEPROM_RETRIES *RETRIES_PER_DELAY);\r\nreturn STATUS_FAILURE ;\r\n}\r\nif( !(uiRetries%RETRIES_PER_DELAY) )\r\nmsleep(1);\r\nuiStatus = 0;\r\nrdmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG,&uiStatus, sizeof(uiStatus)) ;\r\nif(Adapter->device_removed == TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Modem got removed hence exiting from loop....");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ( uiRetries != 0 )\r\n{\r\nvalue = ( uiStatus & ( EEPROM_WRITE_QUEUE_EMPTY | EEPROM_WRITE_QUEUE_AVAIL | EEPROM_WRITE_QUEUE_FULL ) );\r\nwrmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG, &value, sizeof(value));\r\n}\r\nuiRetries = MAX_EEPROM_RETRIES*RETRIES_PER_DELAY;\r\nuiEpromStatus = 0;\r\nwhile ( uiRetries != 0 )\r\n{\r\nuiEpromStatus = ReadEEPROMStatusRegister( Adapter) ;\r\nif(Adapter->device_removed == TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Modem has got removed hence exiting from loop...");\r\nreturn -ENODEV;\r\n}\r\nif ( ( EEPROM_STATUS_REG_WRITE_BUSY & uiEpromStatus ) == 0 )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "EEPROM status register = %x tries = %d\n", uiEpromStatus, (MAX_EEPROM_RETRIES * RETRIES_PER_DELAY- uiRetries) );\r\nreturn STATUS_SUCCESS ;\r\n}\r\nuiRetries--;\r\nif ( uiRetries == 0 )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "0x0f003004 = %x, for EEPROM status read %d retries failed.\n", uiEpromStatus, MAX_EEPROM_RETRIES *RETRIES_PER_DELAY);\r\nreturn STATUS_FAILURE ;\r\n}\r\nuiEpromStatus = 0;\r\nif( !(uiRetries%RETRIES_PER_DELAY) )\r\nmsleep(1);\r\n}\r\nreturn STATUS_SUCCESS ;\r\n}\r\nINT BeceemEEPROMBulkWrite(\r\nPMINI_ADAPTER Adapter,\r\nPUCHAR pBuffer,\r\nUINT uiOffset,\r\nUINT uiNumBytes,\r\nBOOLEAN bVerify)\r\n{\r\nUINT uiBytesToCopy = uiNumBytes;\r\nUINT uiData[4] = {0};\r\nUINT uiIndex = 0;\r\nUINT uiTempOffset = 0;\r\nUINT uiExtraBytes = 0;\r\nif(uiOffset%MAX_RW_SIZE && uiBytesToCopy)\r\n{\r\nuiTempOffset = uiOffset - (uiOffset%MAX_RW_SIZE);\r\nuiExtraBytes = uiOffset-uiTempOffset;\r\nBeceemEEPROMBulkRead(Adapter,&uiData[0],uiTempOffset,MAX_RW_SIZE);\r\nif(uiBytesToCopy >= (16 -uiExtraBytes))\r\n{\r\nmemcpy((((PUCHAR)&uiData[0])+uiExtraBytes),pBuffer,MAX_RW_SIZE- uiExtraBytes);\r\nif ( STATUS_FAILURE == BeceemEEPROMWritePage( Adapter, uiData, uiTempOffset ) )\r\nreturn STATUS_FAILURE;\r\nuiBytesToCopy -= (MAX_RW_SIZE - uiExtraBytes);\r\nuiIndex += (MAX_RW_SIZE - uiExtraBytes);\r\nuiOffset += (MAX_RW_SIZE - uiExtraBytes);\r\n}\r\nelse\r\n{\r\nmemcpy((((PUCHAR)&uiData[0])+uiExtraBytes),pBuffer,uiBytesToCopy);\r\nif ( STATUS_FAILURE == BeceemEEPROMWritePage( Adapter, uiData, uiTempOffset ) )\r\nreturn STATUS_FAILURE;\r\nuiIndex += uiBytesToCopy;\r\nuiOffset += uiBytesToCopy;\r\nuiBytesToCopy = 0;\r\n}\r\n}\r\nwhile(uiBytesToCopy)\r\n{\r\nif(Adapter->device_removed)\r\n{\r\nreturn -1;\r\n}\r\nif(uiBytesToCopy >= MAX_RW_SIZE)\r\n{\r\nif (STATUS_FAILURE == BeceemEEPROMWritePage( Adapter, (PUINT) &pBuffer[uiIndex], uiOffset ) )\r\nreturn STATUS_FAILURE;\r\nuiIndex += MAX_RW_SIZE;\r\nuiOffset += MAX_RW_SIZE;\r\nuiBytesToCopy -= MAX_RW_SIZE;\r\n}\r\nelse\r\n{\r\nBeceemEEPROMBulkRead(Adapter,&uiData[0],uiOffset,16);\r\nmemcpy(&uiData[0],pBuffer+uiIndex,uiBytesToCopy);\r\nif ( STATUS_FAILURE == BeceemEEPROMWritePage( Adapter, uiData, uiOffset ) )\r\nreturn STATUS_FAILURE;\r\nuiBytesToCopy = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nINT BeceemNVMRead(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nUINT uiOffset,\r\nUINT uiNumBytes)\r\n{\r\nINT Status = 0;\r\n#if !defined(BCM_SHM_INTERFACE) || defined(FLASH_DIRECT_ACCESS)\r\nUINT uiTemp = 0, value;\r\n#endif\r\nif(Adapter->eNVMType == NVM_FLASH)\r\n{\r\nif(Adapter->bFlashRawRead == FALSE)\r\n{\r\nif (IsSectionExistInVendorInfo(Adapter,Adapter->eActiveDSD))\r\nreturn vendorextnReadSection(Adapter,(PUCHAR)pBuffer,Adapter->eActiveDSD,uiOffset,uiNumBytes);\r\nuiOffset = uiOffset+ Adapter->ulFlashCalStart ;\r\n}\r\n#if defined(BCM_SHM_INTERFACE) && !defined(FLASH_DIRECT_ACCESS)\r\nStatus = bcmflash_raw_read((uiOffset/FLASH_PART_SIZE),(uiOffset % FLASH_PART_SIZE),( unsigned char *)pBuffer,uiNumBytes);\r\n#else\r\nrdmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nvalue = 0;\r\nwrmalt(Adapter, 0x0f000C80,&value, sizeof(value));\r\nStatus = BeceemFlashBulkRead(Adapter,\r\npBuffer,\r\nuiOffset,\r\nuiNumBytes);\r\nwrmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\n#endif\r\n}\r\nelse if(Adapter->eNVMType == NVM_EEPROM)\r\n{\r\nStatus = BeceemEEPROMBulkRead(Adapter,\r\npBuffer,\r\nuiOffset,\r\nuiNumBytes);\r\n}\r\nelse\r\n{\r\nStatus = -1;\r\n}\r\nreturn Status;\r\n}\r\nINT BeceemNVMWrite(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nUINT uiOffset,\r\nUINT uiNumBytes,\r\nBOOLEAN bVerify)\r\n{\r\nINT Status = 0;\r\nUINT uiTemp = 0;\r\nUINT uiMemoryLoc = EEPROM_CAL_DATA_INTERNAL_LOC;\r\nUINT uiIndex = 0;\r\n#if !defined(BCM_SHM_INTERFACE) || defined(FLASH_DIRECT_ACCESS)\r\nUINT value;\r\n#endif\r\nUINT uiFlashOffset = 0;\r\nif(Adapter->eNVMType == NVM_FLASH)\r\n{\r\nif (IsSectionExistInVendorInfo(Adapter,Adapter->eActiveDSD))\r\nStatus = vendorextnWriteSection(Adapter,(PUCHAR)pBuffer,Adapter->eActiveDSD,uiOffset,uiNumBytes,bVerify);\r\nelse\r\n{\r\nuiFlashOffset = uiOffset + Adapter->ulFlashCalStart;\r\n#if defined(BCM_SHM_INTERFACE) && !defined(FLASH_DIRECT_ACCESS)\r\nStatus = bcmflash_raw_write((uiFlashOffset/FLASH_PART_SIZE), (uiFlashOffset % FLASH_PART_SIZE), (unsigned char *)pBuffer,uiNumBytes);\r\n#else\r\nrdmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nvalue = 0;\r\nwrmalt(Adapter, 0x0f000C80, &value, sizeof(value));\r\nif(Adapter->bStatusWrite == TRUE)\r\n{\r\nStatus = BeceemFlashBulkWriteStatus(Adapter,\r\npBuffer,\r\nuiFlashOffset,\r\nuiNumBytes ,\r\nbVerify);\r\n}\r\nelse\r\n{\r\nStatus = BeceemFlashBulkWrite(Adapter,\r\npBuffer,\r\nuiFlashOffset,\r\nuiNumBytes,\r\nbVerify);\r\n}\r\n#endif\r\n}\r\nif(uiOffset >= EEPROM_CALPARAM_START)\r\n{\r\nuiMemoryLoc += (uiOffset - EEPROM_CALPARAM_START);\r\nwhile(uiNumBytes)\r\n{\r\nif(uiNumBytes > BUFFER_4K)\r\n{\r\nwrm(Adapter,(uiMemoryLoc+uiIndex),(PCHAR)(pBuffer+(uiIndex/4)),BUFFER_4K);\r\nuiNumBytes -= BUFFER_4K;\r\nuiIndex += BUFFER_4K;\r\n}\r\nelse\r\n{\r\nwrm(Adapter,uiMemoryLoc+uiIndex,(PCHAR)(pBuffer+(uiIndex/4)),uiNumBytes);\r\nuiNumBytes = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif((uiOffset+uiNumBytes) > EEPROM_CALPARAM_START)\r\n{\r\nULONG ulBytesTobeSkipped = 0;\r\nPUCHAR pcBuffer = (PUCHAR)pBuffer;\r\nuiNumBytes -= (EEPROM_CALPARAM_START - uiOffset);\r\nulBytesTobeSkipped += (EEPROM_CALPARAM_START - uiOffset);\r\nuiOffset += (EEPROM_CALPARAM_START - uiOffset);\r\nwhile(uiNumBytes)\r\n{\r\nif(uiNumBytes > BUFFER_4K)\r\n{\r\nwrm(Adapter,uiMemoryLoc+uiIndex,(PCHAR )&pcBuffer[ulBytesTobeSkipped+uiIndex],BUFFER_4K);\r\nuiNumBytes -= BUFFER_4K;\r\nuiIndex += BUFFER_4K;\r\n}\r\nelse\r\n{\r\nwrm(Adapter,uiMemoryLoc+uiIndex,(PCHAR)&pcBuffer[ulBytesTobeSkipped+uiIndex],uiNumBytes);\r\nuiNumBytes = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nwrmalt(Adapter,0x0f000C80,&uiTemp, sizeof(uiTemp));\r\n}\r\nelse if(Adapter->eNVMType == NVM_EEPROM)\r\n{\r\nStatus = BeceemEEPROMBulkWrite(Adapter,\r\n(PUCHAR)pBuffer,\r\nuiOffset,\r\nuiNumBytes,\r\nbVerify);\r\nif(bVerify)\r\n{\r\nStatus = BeceemEEPROMReadBackandVerify(Adapter,(PUINT)pBuffer,uiOffset,uiNumBytes);\r\n}\r\n}\r\nelse\r\n{\r\nStatus = -1;\r\n}\r\nreturn Status;\r\n}\r\nINT BcmUpdateSectorSize(PMINI_ADAPTER Adapter,UINT uiSectorSize)\r\n{\r\nINT Status = -1;\r\nFLASH_CS_INFO sFlashCsInfo = {0};\r\nUINT uiTemp = 0;\r\nUINT uiSectorSig = 0;\r\nUINT uiCurrentSectorSize = 0;\r\nUINT value;\r\nrdmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nvalue = 0;\r\nwrmalt(Adapter, 0x0f000C80,&value, sizeof(value));\r\nBeceemFlashBulkRead(Adapter,(PUINT)&sFlashCsInfo,Adapter->ulFlashControlSectionStart,sizeof(sFlashCsInfo));\r\nuiSectorSig = ntohl(sFlashCsInfo.FlashSectorSizeSig);\r\nuiCurrentSectorSize = ntohl(sFlashCsInfo.FlashSectorSize);\r\nif(uiSectorSig == FLASH_SECTOR_SIZE_SIG)\r\n{\r\nif((uiCurrentSectorSize <= MAX_SECTOR_SIZE) && (uiCurrentSectorSize >= MIN_SECTOR_SIZE))\r\n{\r\nif(uiSectorSize == uiCurrentSectorSize)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Provided sector size is same as programmed in Flash");\r\nStatus = STATUS_SUCCESS;\r\ngoto Restore ;\r\n}\r\n}\r\n}\r\nif((uiSectorSize <= MAX_SECTOR_SIZE) && (uiSectorSize >= MIN_SECTOR_SIZE))\r\n{\r\nsFlashCsInfo.FlashSectorSize = htonl(uiSectorSize);\r\nsFlashCsInfo.FlashSectorSizeSig = htonl(FLASH_SECTOR_SIZE_SIG);\r\nStatus = BeceemFlashBulkWrite(Adapter,\r\n(PUINT)&sFlashCsInfo,\r\nAdapter->ulFlashControlSectionStart,\r\nsizeof(sFlashCsInfo),\r\nTRUE);\r\n}\r\nRestore :\r\nwrmalt(Adapter, 0x0f000C80,&uiTemp, sizeof(uiTemp));\r\nreturn Status;\r\n}\r\nstatic UINT BcmGetFlashSectorSize(PMINI_ADAPTER Adapter, UINT FlashSectorSizeSig, UINT FlashSectorSize)\r\n{\r\nUINT uiSectorSize = 0;\r\nUINT uiSectorSig = 0;\r\nif(Adapter->bSectorSizeOverride &&\r\n(Adapter->uiSectorSizeInCFG <= MAX_SECTOR_SIZE &&\r\nAdapter->uiSectorSizeInCFG >= MIN_SECTOR_SIZE))\r\n{\r\nAdapter->uiSectorSize = Adapter->uiSectorSizeInCFG;\r\n}\r\nelse\r\n{\r\nuiSectorSig = FlashSectorSizeSig;\r\nif(uiSectorSig == FLASH_SECTOR_SIZE_SIG)\r\n{\r\nuiSectorSize = FlashSectorSize;\r\nif(uiSectorSize <= MAX_SECTOR_SIZE && uiSectorSize >= MIN_SECTOR_SIZE)\r\n{\r\nAdapter->uiSectorSize = uiSectorSize;\r\n}\r\nelse if(Adapter->uiSectorSizeInCFG <= MAX_SECTOR_SIZE &&\r\nAdapter->uiSectorSizeInCFG >= MIN_SECTOR_SIZE)\r\n{\r\nAdapter->uiSectorSize = Adapter->uiSectorSizeInCFG;\r\n}\r\nelse\r\n{\r\nAdapter->uiSectorSize = DEFAULT_SECTOR_SIZE;\r\n}\r\n}\r\nelse\r\n{\r\nif(Adapter->uiSectorSizeInCFG <= MAX_SECTOR_SIZE &&\r\nAdapter->uiSectorSizeInCFG >= MIN_SECTOR_SIZE)\r\n{\r\nAdapter->uiSectorSize = Adapter->uiSectorSizeInCFG;\r\n}\r\nelse\r\n{\r\nAdapter->uiSectorSize = DEFAULT_SECTOR_SIZE;\r\n}\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Sector size :%x \n", Adapter->uiSectorSize);\r\nreturn Adapter->uiSectorSize;\r\n}\r\nstatic INT BcmInitEEPROMQueues(PMINI_ADAPTER Adapter)\r\n{\r\nUINT value = 0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Fixing reset value on 0x0f003004 register\n" );\r\nvalue = EEPROM_READ_DATA_AVAIL;\r\nwrmalt( Adapter, EEPROM_SPI_Q_STATUS1_REG, &value, sizeof(value));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, " Flushing the queues\n");\r\nvalue =EEPROM_ALL_QUEUE_FLUSH ;\r\nwrmalt( Adapter, SPI_FLUSH_REG, &value, sizeof(value));\r\nvalue = 0;\r\nwrmalt( Adapter, SPI_FLUSH_REG, &value, sizeof(value) );\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "EEPROM Status register value = %x\n", ReadEEPROMStatusRegister(Adapter) );\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT BcmInitNVM(PMINI_ADAPTER ps_adapter)\r\n{\r\nBcmValidateNvmType(ps_adapter);\r\nBcmInitEEPROMQueues(ps_adapter);\r\nif(ps_adapter->eNVMType == NVM_AUTODETECT)\r\n{\r\nps_adapter->eNVMType = BcmGetNvmType(ps_adapter);\r\nif(ps_adapter->eNVMType == NVM_UNKNOWN)\r\n{\r\nBCM_DEBUG_PRINT(ps_adapter,DBG_TYPE_PRINTK, 0, 0, "NVM Type is unknown!!\n");\r\n}\r\n}\r\nelse if(ps_adapter->eNVMType == NVM_FLASH)\r\n{\r\nBcmGetFlashCSInfo(ps_adapter);\r\n}\r\nBcmGetNvmSize(ps_adapter);\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic INT BcmGetNvmSize(PMINI_ADAPTER Adapter)\r\n{\r\nif(Adapter->eNVMType == NVM_EEPROM)\r\n{\r\nAdapter->uiNVMDSDSize = BcmGetEEPROMSize(Adapter);\r\n}\r\nelse if(Adapter->eNVMType == NVM_FLASH)\r\n{\r\nAdapter->uiNVMDSDSize = BcmGetFlashSize(Adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic VOID BcmValidateNvmType(PMINI_ADAPTER Adapter)\r\n{\r\nif(Adapter->eNVMType == NVM_FLASH &&\r\nAdapter->chip_id < 0xBECE3300)\r\n{\r\nAdapter->eNVMType = NVM_AUTODETECT;\r\n}\r\n}\r\nstatic ULONG BcmReadFlashRDID(PMINI_ADAPTER Adapter)\r\n{\r\nULONG ulRDID = 0;\r\nUINT value;\r\nvalue = (FLASH_CMD_READ_ID<<24);\r\nwrmalt(Adapter, FLASH_SPI_CMDQ_REG,&value, sizeof(value));\r\nudelay(10);\r\nrdmalt(Adapter, FLASH_SPI_READQ_REG,(PUINT)&ulRDID, sizeof(ulRDID));\r\nreturn (ulRDID >>8);\r\n}\r\nINT BcmAllocFlashCSStructure(PMINI_ADAPTER psAdapter)\r\n{\r\nif(psAdapter == NULL)\r\n{\r\nBCM_DEBUG_PRINT(psAdapter,DBG_TYPE_PRINTK, 0, 0, "Adapter structure point is NULL");\r\nreturn -EINVAL;\r\n}\r\npsAdapter->psFlashCSInfo = (PFLASH_CS_INFO)kzalloc(sizeof(FLASH_CS_INFO), GFP_KERNEL);\r\nif(psAdapter->psFlashCSInfo == NULL)\r\n{\r\nBCM_DEBUG_PRINT(psAdapter,DBG_TYPE_PRINTK, 0, 0,"Can't Allocate memory for Flash 1.x");\r\nreturn -ENOMEM;\r\n}\r\npsAdapter->psFlash2xCSInfo = (PFLASH2X_CS_INFO)kzalloc(sizeof(FLASH2X_CS_INFO), GFP_KERNEL);\r\nif(psAdapter->psFlash2xCSInfo == NULL)\r\n{\r\nBCM_DEBUG_PRINT(psAdapter,DBG_TYPE_PRINTK, 0, 0,"Can't Allocate memory for Flash 2.x");\r\nkfree(psAdapter->psFlashCSInfo);\r\nreturn -ENOMEM;\r\n}\r\npsAdapter->psFlash2xVendorInfo = (PFLASH2X_VENDORSPECIFIC_INFO)kzalloc(sizeof(FLASH2X_VENDORSPECIFIC_INFO), GFP_KERNEL);\r\nif(psAdapter->psFlash2xVendorInfo == NULL)\r\n{\r\nBCM_DEBUG_PRINT(psAdapter,DBG_TYPE_PRINTK, 0, 0,"Can't Allocate Vendor Info Memory for Flash 2.x");\r\nkfree(psAdapter->psFlashCSInfo);\r\nkfree(psAdapter->psFlash2xCSInfo);\r\nreturn -ENOMEM;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT BcmDeAllocFlashCSStructure(PMINI_ADAPTER psAdapter)\r\n{\r\nif(psAdapter == NULL)\r\n{\r\nBCM_DEBUG_PRINT(psAdapter,DBG_TYPE_PRINTK, 0, 0," Adapter structure point is NULL");\r\nreturn -EINVAL;\r\n}\r\nkfree(psAdapter->psFlashCSInfo);\r\nkfree(psAdapter->psFlash2xCSInfo);\r\nkfree(psAdapter->psFlash2xVendorInfo);\r\nreturn STATUS_SUCCESS ;\r\n}\r\nstatic INT BcmDumpFlash2XCSStructure(PFLASH2X_CS_INFO psFlash2xCSInfo,PMINI_ADAPTER Adapter)\r\n{\r\nUINT Index = 0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "**********************FLASH2X CS Structure *******************");\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Signature is :%x", (psFlash2xCSInfo->MagicNumber));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Flash Major Version :%d", MAJOR_VERSION(psFlash2xCSInfo->FlashLayoutVersion));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Flash Minor Version :%d", MINOR_VERSION(psFlash2xCSInfo->FlashLayoutVersion));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, " ISOImageMajorVersion:0x%x", (psFlash2xCSInfo->ISOImageVersion));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "SCSIFirmwareMajorVersion :0x%x", (psFlash2xCSInfo->SCSIFirmwareVersion));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForPart1ISOImage :0x%x", (psFlash2xCSInfo->OffsetFromZeroForPart1ISOImage));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForScsiFirmware :0x%x", (psFlash2xCSInfo->OffsetFromZeroForScsiFirmware));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "SizeOfScsiFirmware :0x%x", (psFlash2xCSInfo->SizeOfScsiFirmware ));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForPart2ISOImage :0x%x", (psFlash2xCSInfo->OffsetFromZeroForPart2ISOImage));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForDSDStart :0x%x", (psFlash2xCSInfo->OffsetFromZeroForDSDStart));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForDSDEnd :0x%x", (psFlash2xCSInfo->OffsetFromZeroForDSDEnd));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForVSAStart :0x%x", (psFlash2xCSInfo->OffsetFromZeroForVSAStart));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForVSAEnd :0x%x", (psFlash2xCSInfo->OffsetFromZeroForVSAEnd));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForControlSectionStart :0x%x", (psFlash2xCSInfo->OffsetFromZeroForControlSectionStart));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForControlSectionData :0x%x", (psFlash2xCSInfo->OffsetFromZeroForControlSectionData));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "CDLessInactivityTimeout :0x%x", (psFlash2xCSInfo->CDLessInactivityTimeout));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "NewImageSignature :0x%x", (psFlash2xCSInfo->NewImageSignature));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "FlashSectorSizeSig :0x%x", (psFlash2xCSInfo->FlashSectorSizeSig));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "FlashSectorSize :0x%x", (psFlash2xCSInfo->FlashSectorSize));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "FlashWriteSupportSize :0x%x", (psFlash2xCSInfo->FlashWriteSupportSize));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "TotalFlashSize :0x%X", (psFlash2xCSInfo->TotalFlashSize));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "FlashBaseAddr :0x%x", (psFlash2xCSInfo->FlashBaseAddr));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "FlashPartMaxSize :0x%x", (psFlash2xCSInfo->FlashPartMaxSize));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "IsCDLessDeviceBootSig :0x%x", (psFlash2xCSInfo->IsCDLessDeviceBootSig));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "MassStorageTimeout :0x%x", (psFlash2xCSInfo->MassStorageTimeout));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage1Part1Start :0x%x", (psFlash2xCSInfo->OffsetISOImage1Part1Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage1Part1End :0x%x", (psFlash2xCSInfo->OffsetISOImage1Part1End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage1Part2Start :0x%x", (psFlash2xCSInfo->OffsetISOImage1Part2Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage1Part2End :0x%x", (psFlash2xCSInfo->OffsetISOImage1Part2End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage1Part3Start :0x%x", (psFlash2xCSInfo->OffsetISOImage1Part3Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage1Part3End :0x%x", (psFlash2xCSInfo->OffsetISOImage1Part3End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage2Part1Start :0x%x", (psFlash2xCSInfo->OffsetISOImage2Part1Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage2Part1End :0x%x", (psFlash2xCSInfo->OffsetISOImage2Part1End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage2Part2Start :0x%x", (psFlash2xCSInfo->OffsetISOImage2Part2Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage2Part2End :0x%x", (psFlash2xCSInfo->OffsetISOImage2Part2End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage2Part3Start :0x%x", (psFlash2xCSInfo->OffsetISOImage2Part3Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetISOImage2Part3End :0x%x", (psFlash2xCSInfo->OffsetISOImage2Part3End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromDSDStartForDSDHeader :0x%x", (psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForDSD1Start :0x%x", (psFlash2xCSInfo->OffsetFromZeroForDSD1Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForDSD1End :0x%x", (psFlash2xCSInfo->OffsetFromZeroForDSD1End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForDSD2Start :0x%x", (psFlash2xCSInfo->OffsetFromZeroForDSD2Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForDSD2End :0x%x", (psFlash2xCSInfo->OffsetFromZeroForDSD2End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForVSA1Start :0x%x", (psFlash2xCSInfo->OffsetFromZeroForVSA1Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForVSA1End :0x%x", (psFlash2xCSInfo->OffsetFromZeroForVSA1End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForVSA2Start :0x%x", (psFlash2xCSInfo->OffsetFromZeroForVSA2Start));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "OffsetFromZeroForVSA2End :0x%x", (psFlash2xCSInfo->OffsetFromZeroForVSA2End));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Sector Access Bit Map is Defined as :");\r\nfor(Index =0; Index <(FLASH2X_TOTAL_SIZE/(DEFAULT_SECTOR_SIZE *16)); Index++)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "SectorAccessBitMap[%d] :0x%x", Index,\r\n(psFlash2xCSInfo->SectorAccessBitMap[Index]));\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic INT ConvertEndianOf2XCSStructure(PFLASH2X_CS_INFO psFlash2xCSInfo)\r\n{\r\nUINT Index = 0;\r\npsFlash2xCSInfo->MagicNumber = ntohl(psFlash2xCSInfo->MagicNumber);\r\npsFlash2xCSInfo->FlashLayoutVersion= ntohl(psFlash2xCSInfo->FlashLayoutVersion);\r\npsFlash2xCSInfo->ISOImageVersion = ntohl(psFlash2xCSInfo->ISOImageVersion);\r\npsFlash2xCSInfo->SCSIFirmwareVersion =ntohl(psFlash2xCSInfo->SCSIFirmwareVersion);\r\npsFlash2xCSInfo->OffsetFromZeroForPart1ISOImage = ntohl(psFlash2xCSInfo->OffsetFromZeroForPart1ISOImage);\r\npsFlash2xCSInfo->OffsetFromZeroForScsiFirmware = ntohl(psFlash2xCSInfo->OffsetFromZeroForScsiFirmware);\r\npsFlash2xCSInfo->SizeOfScsiFirmware = ntohl(psFlash2xCSInfo->SizeOfScsiFirmware );\r\npsFlash2xCSInfo->OffsetFromZeroForPart2ISOImage = ntohl(psFlash2xCSInfo->OffsetFromZeroForPart2ISOImage);\r\npsFlash2xCSInfo->OffsetFromZeroForDSDStart = ntohl(psFlash2xCSInfo->OffsetFromZeroForDSDStart);\r\npsFlash2xCSInfo->OffsetFromZeroForDSDEnd = ntohl(psFlash2xCSInfo->OffsetFromZeroForDSDEnd);\r\npsFlash2xCSInfo->OffsetFromZeroForVSAStart = ntohl(psFlash2xCSInfo->OffsetFromZeroForVSAStart);\r\npsFlash2xCSInfo->OffsetFromZeroForVSAEnd = ntohl(psFlash2xCSInfo->OffsetFromZeroForVSAEnd);\r\npsFlash2xCSInfo->OffsetFromZeroForControlSectionStart = ntohl(psFlash2xCSInfo->OffsetFromZeroForControlSectionStart);\r\npsFlash2xCSInfo->OffsetFromZeroForControlSectionData = ntohl(psFlash2xCSInfo->OffsetFromZeroForControlSectionData);\r\npsFlash2xCSInfo->CDLessInactivityTimeout = ntohl(psFlash2xCSInfo->CDLessInactivityTimeout);\r\npsFlash2xCSInfo->NewImageSignature = ntohl(psFlash2xCSInfo->NewImageSignature);\r\npsFlash2xCSInfo->FlashSectorSizeSig = ntohl(psFlash2xCSInfo->FlashSectorSizeSig);\r\npsFlash2xCSInfo->FlashSectorSize = ntohl(psFlash2xCSInfo->FlashSectorSize);\r\npsFlash2xCSInfo->FlashWriteSupportSize = ntohl(psFlash2xCSInfo->FlashWriteSupportSize);\r\npsFlash2xCSInfo->TotalFlashSize = ntohl(psFlash2xCSInfo->TotalFlashSize);\r\npsFlash2xCSInfo->FlashBaseAddr = ntohl(psFlash2xCSInfo->FlashBaseAddr);\r\npsFlash2xCSInfo->FlashPartMaxSize = ntohl(psFlash2xCSInfo->FlashPartMaxSize);\r\npsFlash2xCSInfo->IsCDLessDeviceBootSig = ntohl(psFlash2xCSInfo->IsCDLessDeviceBootSig);\r\npsFlash2xCSInfo->MassStorageTimeout = ntohl(psFlash2xCSInfo->MassStorageTimeout);\r\npsFlash2xCSInfo->OffsetISOImage1Part1Start = ntohl(psFlash2xCSInfo->OffsetISOImage1Part1Start);\r\npsFlash2xCSInfo->OffsetISOImage1Part1End = ntohl(psFlash2xCSInfo->OffsetISOImage1Part1End);\r\npsFlash2xCSInfo->OffsetISOImage1Part2Start = ntohl(psFlash2xCSInfo->OffsetISOImage1Part2Start);\r\npsFlash2xCSInfo->OffsetISOImage1Part2End = ntohl(psFlash2xCSInfo->OffsetISOImage1Part2End);\r\npsFlash2xCSInfo->OffsetISOImage1Part3Start = ntohl(psFlash2xCSInfo->OffsetISOImage1Part3Start);\r\npsFlash2xCSInfo->OffsetISOImage1Part3End = ntohl(psFlash2xCSInfo->OffsetISOImage1Part3End);\r\npsFlash2xCSInfo->OffsetISOImage2Part1Start = ntohl(psFlash2xCSInfo->OffsetISOImage2Part1Start);\r\npsFlash2xCSInfo->OffsetISOImage2Part1End = ntohl(psFlash2xCSInfo->OffsetISOImage2Part1End);\r\npsFlash2xCSInfo->OffsetISOImage2Part2Start = ntohl(psFlash2xCSInfo->OffsetISOImage2Part2Start);\r\npsFlash2xCSInfo->OffsetISOImage2Part2End = ntohl(psFlash2xCSInfo->OffsetISOImage2Part2End);\r\npsFlash2xCSInfo->OffsetISOImage2Part3Start = ntohl(psFlash2xCSInfo->OffsetISOImage2Part3Start);\r\npsFlash2xCSInfo->OffsetISOImage2Part3End = ntohl(psFlash2xCSInfo->OffsetISOImage2Part3End);\r\npsFlash2xCSInfo->OffsetFromDSDStartForDSDHeader = ntohl(psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader);\r\npsFlash2xCSInfo->OffsetFromZeroForDSD1Start = ntohl(psFlash2xCSInfo->OffsetFromZeroForDSD1Start);\r\npsFlash2xCSInfo->OffsetFromZeroForDSD1End = ntohl(psFlash2xCSInfo->OffsetFromZeroForDSD1End);\r\npsFlash2xCSInfo->OffsetFromZeroForDSD2Start = ntohl(psFlash2xCSInfo->OffsetFromZeroForDSD2Start);\r\npsFlash2xCSInfo->OffsetFromZeroForDSD2End = ntohl(psFlash2xCSInfo->OffsetFromZeroForDSD2End);\r\npsFlash2xCSInfo->OffsetFromZeroForVSA1Start = ntohl(psFlash2xCSInfo->OffsetFromZeroForVSA1Start);\r\npsFlash2xCSInfo->OffsetFromZeroForVSA1End = ntohl(psFlash2xCSInfo->OffsetFromZeroForVSA1End);\r\npsFlash2xCSInfo->OffsetFromZeroForVSA2Start = ntohl(psFlash2xCSInfo->OffsetFromZeroForVSA2Start);\r\npsFlash2xCSInfo->OffsetFromZeroForVSA2End = ntohl(psFlash2xCSInfo->OffsetFromZeroForVSA2End);\r\nfor(Index =0; Index <(FLASH2X_TOTAL_SIZE/(DEFAULT_SECTOR_SIZE *16)); Index++)\r\n{\r\npsFlash2xCSInfo->SectorAccessBitMap[Index] = ntohl(psFlash2xCSInfo->SectorAccessBitMap[Index]);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic INT ConvertEndianOfCSStructure(PFLASH_CS_INFO psFlashCSInfo)\r\n{\r\npsFlashCSInfo->MagicNumber =ntohl(psFlashCSInfo->MagicNumber);\r\npsFlashCSInfo->FlashLayoutVersion =ntohl(psFlashCSInfo->FlashLayoutVersion);\r\npsFlashCSInfo->ISOImageVersion = ntohl(psFlashCSInfo->ISOImageVersion);\r\npsFlashCSInfo->SCSIFirmwareVersion =(psFlashCSInfo->SCSIFirmwareVersion);\r\npsFlashCSInfo->OffsetFromZeroForPart1ISOImage = ntohl(psFlashCSInfo->OffsetFromZeroForPart1ISOImage);\r\npsFlashCSInfo->OffsetFromZeroForScsiFirmware = ntohl(psFlashCSInfo->OffsetFromZeroForScsiFirmware);\r\npsFlashCSInfo->SizeOfScsiFirmware = ntohl(psFlashCSInfo->SizeOfScsiFirmware );\r\npsFlashCSInfo->OffsetFromZeroForPart2ISOImage = ntohl(psFlashCSInfo->OffsetFromZeroForPart2ISOImage);\r\npsFlashCSInfo->OffsetFromZeroForCalibrationStart = ntohl(psFlashCSInfo->OffsetFromZeroForCalibrationStart);\r\npsFlashCSInfo->OffsetFromZeroForCalibrationEnd = ntohl(psFlashCSInfo->OffsetFromZeroForCalibrationEnd);\r\npsFlashCSInfo->OffsetFromZeroForVSAStart = ntohl(psFlashCSInfo->OffsetFromZeroForVSAStart);\r\npsFlashCSInfo->OffsetFromZeroForVSAEnd = ntohl(psFlashCSInfo->OffsetFromZeroForVSAEnd);\r\npsFlashCSInfo->OffsetFromZeroForControlSectionStart = ntohl(psFlashCSInfo->OffsetFromZeroForControlSectionStart);\r\npsFlashCSInfo->OffsetFromZeroForControlSectionData = ntohl(psFlashCSInfo->OffsetFromZeroForControlSectionData);\r\npsFlashCSInfo->CDLessInactivityTimeout = ntohl(psFlashCSInfo->CDLessInactivityTimeout);\r\npsFlashCSInfo->NewImageSignature = ntohl(psFlashCSInfo->NewImageSignature);\r\npsFlashCSInfo->FlashSectorSizeSig = ntohl(psFlashCSInfo->FlashSectorSizeSig);\r\npsFlashCSInfo->FlashSectorSize = ntohl(psFlashCSInfo->FlashSectorSize);\r\npsFlashCSInfo->FlashWriteSupportSize = ntohl(psFlashCSInfo->FlashWriteSupportSize);\r\npsFlashCSInfo->TotalFlashSize = ntohl(psFlashCSInfo->TotalFlashSize);\r\npsFlashCSInfo->FlashBaseAddr = ntohl(psFlashCSInfo->FlashBaseAddr);\r\npsFlashCSInfo->FlashPartMaxSize = ntohl(psFlashCSInfo->FlashPartMaxSize);\r\npsFlashCSInfo->IsCDLessDeviceBootSig = ntohl(psFlashCSInfo->IsCDLessDeviceBootSig);\r\npsFlashCSInfo->MassStorageTimeout = ntohl(psFlashCSInfo->MassStorageTimeout);\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic INT IsSectionExistInVendorInfo(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL section)\r\n{\r\nreturn ( Adapter->uiVendorExtnFlag &&\r\n(Adapter->psFlash2xVendorInfo->VendorSection[section].AccessFlags & FLASH2X_SECTION_PRESENT) &&\r\n(Adapter->psFlash2xVendorInfo->VendorSection[section].OffsetFromZeroForSectionStart != UNINIT_PTR_IN_CS) );\r\n}\r\nstatic VOID UpdateVendorInfo(PMINI_ADAPTER Adapter)\r\n{\r\nB_UINT32 i = 0;\r\nUINT uiSizeSection = 0;\r\nAdapter->uiVendorExtnFlag = FALSE;\r\nfor(i = 0;i < TOTAL_SECTIONS;i++)\r\nAdapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionStart = UNINIT_PTR_IN_CS;\r\nif(STATUS_SUCCESS != vendorextnGetSectionInfo(Adapter, Adapter->psFlash2xVendorInfo))\r\nreturn;\r\ni = 0;\r\nwhile(i < TOTAL_SECTIONS)\r\n{\r\nif(!(Adapter->psFlash2xVendorInfo->VendorSection[i].AccessFlags & FLASH2X_SECTION_PRESENT))\r\n{\r\ni++;\r\ncontinue;\r\n}\r\nAdapter->uiVendorExtnFlag = TRUE;\r\nuiSizeSection = (Adapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionEnd -\r\nAdapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionStart);\r\nswitch(i)\r\n{\r\ncase DSD0:\r\nif(( uiSizeSection >= (Adapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + sizeof(DSD_HEADER))) &&\r\n(UNINIT_PTR_IN_CS != Adapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionStart))\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForDSDStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDEnd = VENDOR_PTR_IN_CS;\r\nelse\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForDSDStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDEnd = UNINIT_PTR_IN_CS;\r\nbreak;\r\ncase DSD1:\r\nif(( uiSizeSection >= (Adapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + sizeof(DSD_HEADER))) &&\r\n(UNINIT_PTR_IN_CS != Adapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionStart))\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForDSD1Start = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1End = VENDOR_PTR_IN_CS;\r\nelse\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForDSD1Start = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1End = UNINIT_PTR_IN_CS;\r\nbreak;\r\ncase DSD2:\r\nif(( uiSizeSection >= (Adapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + sizeof(DSD_HEADER))) &&\r\n(UNINIT_PTR_IN_CS != Adapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionStart))\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForDSD2Start = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2End = VENDOR_PTR_IN_CS;\r\nelse\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForDSD2Start = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2End = UNINIT_PTR_IN_CS;\r\nbreak;\r\ncase VSA0:\r\nif(UNINIT_PTR_IN_CS != Adapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionStart)\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForVSAStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForVSAEnd = VENDOR_PTR_IN_CS;\r\nelse\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForVSAStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForVSAEnd = UNINIT_PTR_IN_CS;\r\nbreak;\r\ncase VSA1:\r\nif(UNINIT_PTR_IN_CS != Adapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionStart)\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForVSA1Start = Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA1End = VENDOR_PTR_IN_CS;\r\nelse\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForVSA1Start = Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA1End = UNINIT_PTR_IN_CS;\r\nbreak;\r\ncase VSA2:\r\nif(UNINIT_PTR_IN_CS != Adapter->psFlash2xVendorInfo->VendorSection[i].OffsetFromZeroForSectionStart)\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForVSA2Start = Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA2End = VENDOR_PTR_IN_CS;\r\nelse\r\nAdapter->psFlash2xCSInfo->OffsetFromZeroForVSA2Start = Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA2End = UNINIT_PTR_IN_CS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nstatic INT BcmGetFlashCSInfo(PMINI_ADAPTER Adapter)\r\n{\r\n#if !defined(BCM_SHM_INTERFACE) || defined(FLASH_DIRECT_ACCESS)\r\nUINT value;\r\n#endif\r\nUINT uiFlashLayoutMajorVersion;\r\nAdapter->uiFlashLayoutMinorVersion = 0;\r\nAdapter->uiFlashLayoutMajorVersion = 0;\r\nAdapter->ulFlashControlSectionStart = FLASH_CS_INFO_START_ADDR;\r\nAdapter->uiFlashBaseAdd = 0;\r\nAdapter->ulFlashCalStart = 0;\r\nmemset(Adapter->psFlashCSInfo, 0 ,sizeof(FLASH_CS_INFO));\r\nmemset(Adapter->psFlash2xCSInfo, 0 ,sizeof(FLASH2X_CS_INFO));\r\nif(!Adapter->bDDRInitDone)\r\n{\r\n{\r\nvalue = FLASH_CONTIGIOUS_START_ADDR_BEFORE_INIT;\r\nwrmalt(Adapter, 0xAF00A080, &value, sizeof(value));\r\n}\r\n}\r\nBeceemFlashBulkRead(Adapter,(PUINT)Adapter->psFlashCSInfo,Adapter->ulFlashControlSectionStart,8);\r\nAdapter->psFlashCSInfo->FlashLayoutVersion = ntohl(Adapter->psFlashCSInfo->FlashLayoutVersion);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Flash Layout Version :%X", (Adapter->psFlashCSInfo->FlashLayoutVersion));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Signature is :%x\n", ntohl(Adapter->psFlashCSInfo->MagicNumber));\r\nif(FLASH_CONTROL_STRUCT_SIGNATURE == ntohl(Adapter->psFlashCSInfo->MagicNumber))\r\n{\r\nuiFlashLayoutMajorVersion = MAJOR_VERSION((Adapter->psFlashCSInfo->FlashLayoutVersion));\r\nAdapter->uiFlashLayoutMinorVersion = MINOR_VERSION((Adapter->psFlashCSInfo->FlashLayoutVersion));\r\n}\r\nelse\r\n{\r\nAdapter->uiFlashLayoutMinorVersion = 0;\r\nuiFlashLayoutMajorVersion = 0;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"FLASH LAYOUT MAJOR VERSION :%X", uiFlashLayoutMajorVersion);\r\nif(uiFlashLayoutMajorVersion < FLASH_2X_MAJOR_NUMBER)\r\n{\r\nBeceemFlashBulkRead(Adapter,(PUINT)Adapter->psFlashCSInfo,Adapter->ulFlashControlSectionStart,sizeof(FLASH_CS_INFO));\r\nConvertEndianOfCSStructure(Adapter->psFlashCSInfo);\r\nAdapter->ulFlashCalStart = (Adapter->psFlashCSInfo->OffsetFromZeroForCalibrationStart);\r\nif(!((Adapter->uiFlashLayoutMajorVersion == 1) && (Adapter->uiFlashLayoutMinorVersion == 1)))\r\n{\r\nAdapter->ulFlashControlSectionStart = Adapter->psFlashCSInfo->OffsetFromZeroForControlSectionStart;\r\n}\r\nif((FLASH_CONTROL_STRUCT_SIGNATURE == (Adapter->psFlashCSInfo->MagicNumber)) &&\r\n(SCSI_FIRMWARE_MINOR_VERSION <= MINOR_VERSION(Adapter->psFlashCSInfo->SCSIFirmwareVersion)) &&\r\n(FLASH_SECTOR_SIZE_SIG == (Adapter->psFlashCSInfo->FlashSectorSizeSig)) &&\r\n(BYTE_WRITE_SUPPORT == (Adapter->psFlashCSInfo->FlashWriteSupportSize)))\r\n{\r\nAdapter->ulFlashWriteSize = (Adapter->psFlashCSInfo->FlashWriteSupportSize);\r\nAdapter->fpFlashWrite = flashByteWrite;\r\nAdapter->fpFlashWriteWithStatusCheck = flashByteWriteStatus;\r\n}\r\nelse\r\n{\r\nAdapter->ulFlashWriteSize = MAX_RW_SIZE;\r\nAdapter->fpFlashWrite = flashWrite;\r\nAdapter->fpFlashWriteWithStatusCheck = flashWriteStatus;\r\n}\r\nBcmGetFlashSectorSize(Adapter, (Adapter->psFlashCSInfo->FlashSectorSizeSig),\r\n(Adapter->psFlashCSInfo->FlashSectorSize));\r\nAdapter->uiFlashBaseAdd = Adapter->psFlashCSInfo->FlashBaseAddr & 0xFCFFFFFF;\r\n}\r\nelse\r\n{\r\nif(BcmFlash2xBulkRead(Adapter,(PUINT)Adapter->psFlash2xCSInfo,NO_SECTION_VAL,\r\nAdapter->ulFlashControlSectionStart,sizeof(FLASH2X_CS_INFO)))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Unable to read CS structure \n");\r\nreturn STATUS_FAILURE;\r\n}\r\nConvertEndianOf2XCSStructure(Adapter->psFlash2xCSInfo);\r\nBcmDumpFlash2XCSStructure(Adapter->psFlash2xCSInfo,Adapter);\r\nif((FLASH_CONTROL_STRUCT_SIGNATURE == Adapter->psFlash2xCSInfo->MagicNumber) &&\r\n(SCSI_FIRMWARE_MINOR_VERSION <= MINOR_VERSION(Adapter->psFlash2xCSInfo->SCSIFirmwareVersion)) &&\r\n(FLASH_SECTOR_SIZE_SIG == Adapter->psFlash2xCSInfo->FlashSectorSizeSig) &&\r\n(BYTE_WRITE_SUPPORT == Adapter->psFlash2xCSInfo->FlashWriteSupportSize))\r\n{\r\nAdapter->ulFlashWriteSize = Adapter->psFlash2xCSInfo->FlashWriteSupportSize;\r\nAdapter->fpFlashWrite = flashByteWrite;\r\nAdapter->fpFlashWriteWithStatusCheck = flashByteWriteStatus;\r\n}\r\nelse\r\n{\r\nAdapter->ulFlashWriteSize = MAX_RW_SIZE;\r\nAdapter->fpFlashWrite = flashWrite;\r\nAdapter->fpFlashWriteWithStatusCheck = flashWriteStatus;\r\n}\r\nBcmGetFlashSectorSize(Adapter, Adapter->psFlash2xCSInfo->FlashSectorSizeSig,\r\nAdapter->psFlash2xCSInfo->FlashSectorSize);\r\nUpdateVendorInfo(Adapter);\r\nBcmGetActiveDSD(Adapter);\r\nBcmGetActiveISO(Adapter);\r\nAdapter->uiFlashBaseAdd = Adapter->psFlash2xCSInfo->FlashBaseAddr & 0xFCFFFFFF;\r\nAdapter->ulFlashControlSectionStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForControlSectionStart;\r\n}\r\nAdapter->ulFlashID = BcmReadFlashRDID(Adapter);\r\nAdapter->uiFlashLayoutMajorVersion = uiFlashLayoutMajorVersion;\r\nreturn STATUS_SUCCESS ;\r\n}\r\nstatic NVM_TYPE BcmGetNvmType(PMINI_ADAPTER Adapter)\r\n{\r\nUINT uiData = 0;\r\nBeceemEEPROMBulkRead(Adapter,&uiData,0x0,4);\r\nif(uiData == BECM)\r\n{\r\nreturn NVM_EEPROM;\r\n}\r\nBcmGetFlashCSInfo(Adapter);\r\nBeceemFlashBulkRead(Adapter,&uiData,0x0 + Adapter->ulFlashCalStart,4);\r\nif(uiData == BECM)\r\n{\r\nreturn NVM_FLASH;\r\n}\r\nif(BcmGetEEPROMSize(Adapter))\r\n{\r\nreturn NVM_EEPROM;\r\n}\r\nreturn NVM_UNKNOWN;\r\n}\r\nINT BcmGetSectionValStartOffset(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlashSectionVal)\r\n{\r\nINT SectStartOffset = 0 ;\r\nSectStartOffset = INVALID_OFFSET ;\r\nif(IsSectionExistInVendorInfo(Adapter,eFlashSectionVal))\r\n{\r\nreturn Adapter->psFlash2xVendorInfo->VendorSection[eFlashSectionVal].OffsetFromZeroForSectionStart;\r\n}\r\nswitch(eFlashSectionVal)\r\n{\r\ncase ISO_IMAGE1 :\r\nif((Adapter->psFlash2xCSInfo->OffsetISOImage1Part1Start != UNINIT_PTR_IN_CS) &&\r\n(IsNonCDLessDevice(Adapter) == FALSE))\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage1Part1Start);\r\nbreak;\r\ncase ISO_IMAGE2 :\r\nif((Adapter->psFlash2xCSInfo->OffsetISOImage2Part1Start != UNINIT_PTR_IN_CS) &&\r\n(IsNonCDLessDevice(Adapter) == FALSE))\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage2Part1Start);\r\nbreak;\r\ncase DSD0 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDStart != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDStart);\r\nbreak;\r\ncase DSD1 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1Start != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1Start);\r\nbreak;\r\ncase DSD2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2Start != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2Start);\r\nbreak;\r\ncase VSA0 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSAStart != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForVSAStart);\r\nbreak;\r\ncase VSA1 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA1Start != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA1Start);\r\nbreak;\r\ncase VSA2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA2Start != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA2Start);\r\nbreak;\r\ncase SCSI :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForScsiFirmware != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForScsiFirmware);\r\nbreak;\r\ncase CONTROL_SECTION :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForControlSectionStart != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForControlSectionStart);\r\nbreak;\r\ncase ISO_IMAGE1_PART2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetISOImage1Part2Start != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage1Part2Start);\r\nbreak;\r\ncase ISO_IMAGE1_PART3 :\r\nif(Adapter->psFlash2xCSInfo->OffsetISOImage1Part3Start != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage1Part3Start);\r\nbreak;\r\ncase ISO_IMAGE2_PART2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetISOImage2Part2Start != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage2Part2Start);\r\nbreak;\r\ncase ISO_IMAGE2_PART3 :\r\nif(Adapter->psFlash2xCSInfo->OffsetISOImage2Part3Start != UNINIT_PTR_IN_CS)\r\nSectStartOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage2Part3Start);\r\nbreak;\r\ndefault :\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section Does not exist in Flash 2.x");\r\nSectStartOffset = INVALID_OFFSET;\r\n}\r\nreturn SectStartOffset;\r\n}\r\nINT BcmGetSectionValEndOffset(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSectionVal)\r\n{\r\nINT SectEndOffset = 0 ;\r\nSectEndOffset = INVALID_OFFSET;\r\nif(IsSectionExistInVendorInfo(Adapter,eFlash2xSectionVal))\r\n{\r\nreturn Adapter->psFlash2xVendorInfo->VendorSection[eFlash2xSectionVal].OffsetFromZeroForSectionEnd;\r\n}\r\nswitch(eFlash2xSectionVal)\r\n{\r\ncase ISO_IMAGE1 :\r\nif((Adapter->psFlash2xCSInfo->OffsetISOImage1Part1End!= UNINIT_PTR_IN_CS) &&\r\n(IsNonCDLessDevice(Adapter) == FALSE))\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage1Part1End);\r\nbreak;\r\ncase ISO_IMAGE2 :\r\nif((Adapter->psFlash2xCSInfo->OffsetISOImage2Part1End!= UNINIT_PTR_IN_CS) &&\r\n(IsNonCDLessDevice(Adapter) == FALSE))\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage2Part1End);\r\nbreak;\r\ncase DSD0 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDEnd != UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDEnd);\r\nbreak;\r\ncase DSD1 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1End != UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1End);\r\nbreak;\r\ncase DSD2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2End != UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2End);\r\nbreak;\r\ncase VSA0 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSAEnd != UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForVSAEnd);\r\nbreak;\r\ncase VSA1 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA1End != UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA1End);\r\nbreak;\r\ncase VSA2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA2End != UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA2End);\r\nbreak;\r\ncase SCSI :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForScsiFirmware != UNINIT_PTR_IN_CS)\r\nSectEndOffset = ((Adapter->psFlash2xCSInfo->OffsetFromZeroForScsiFirmware) +\r\n(Adapter->psFlash2xCSInfo->SizeOfScsiFirmware));\r\nbreak;\r\ncase CONTROL_SECTION :\r\nSectEndOffset = STATUS_FAILURE;\r\ncase ISO_IMAGE1_PART2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetISOImage1Part2End!= UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage1Part2End);\r\nbreak;\r\ncase ISO_IMAGE1_PART3 :\r\nif(Adapter->psFlash2xCSInfo->OffsetISOImage1Part3End!= UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage1Part3End);\r\nbreak;\r\ncase ISO_IMAGE2_PART2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetISOImage2Part2End != UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage2Part2End);\r\nbreak;\r\ncase ISO_IMAGE2_PART3 :\r\nif(Adapter->psFlash2xCSInfo->OffsetISOImage2Part3End!= UNINIT_PTR_IN_CS)\r\nSectEndOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage2Part3End);\r\nbreak;\r\ndefault :\r\nSectEndOffset = INVALID_OFFSET;\r\n}\r\nreturn SectEndOffset ;\r\n}\r\nINT BcmFlash2xBulkRead(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nFLASH2X_SECTION_VAL eFlash2xSectionVal,\r\nUINT uiOffsetWithinSectionVal,\r\nUINT uiNumBytes)\r\n{\r\nINT Status = STATUS_SUCCESS;\r\nINT SectionStartOffset = 0;\r\nUINT uiAbsoluteOffset = 0 ;\r\nUINT uiTemp =0, value =0 ;\r\nif(Adapter == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Adapter structure is NULL");\r\nreturn -EINVAL;\r\n}\r\nif(Adapter->device_removed )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Device has been removed");\r\nreturn -ENODEV;\r\n}\r\nif(eFlash2xSectionVal == NO_SECTION_VAL)\r\nSectionStartOffset = 0;\r\nelse\r\nSectionStartOffset = BcmGetSectionValStartOffset(Adapter,eFlash2xSectionVal);\r\nif(SectionStartOffset == STATUS_FAILURE )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"This Section<%d> does not exixt in Flash 2.x Map ",eFlash2xSectionVal);\r\nreturn -EINVAL;\r\n}\r\nif(IsSectionExistInVendorInfo(Adapter,eFlash2xSectionVal))\r\nreturn vendorextnReadSection(Adapter,(PUCHAR)pBuffer, eFlash2xSectionVal, uiOffsetWithinSectionVal, uiNumBytes);\r\nuiAbsoluteOffset = uiOffsetWithinSectionVal + SectionStartOffset;\r\nrdmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nvalue = 0;\r\nwrmalt(Adapter, 0x0f000C80,&value, sizeof(value));\r\nStatus= BeceemFlashBulkRead(Adapter, pBuffer,uiAbsoluteOffset,uiNumBytes) ;\r\nwrmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Flash Read Failed with Status :%d", Status);\r\nreturn Status ;\r\n}\r\nreturn Status;\r\n}\r\nINT BcmFlash2xBulkWrite(\r\nPMINI_ADAPTER Adapter,\r\nPUINT pBuffer,\r\nFLASH2X_SECTION_VAL eFlash2xSectVal,\r\nUINT uiOffset,\r\nUINT uiNumBytes,\r\nUINT bVerify)\r\n{\r\nINT Status = STATUS_SUCCESS;\r\nUINT FlashSectValStartOffset = 0;\r\nUINT uiTemp = 0, value = 0;\r\nif(Adapter == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Adapter structure is NULL");\r\nreturn -EINVAL;\r\n}\r\nif(Adapter->device_removed )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Device has been removed");\r\nreturn -ENODEV;\r\n}\r\nif(eFlash2xSectVal == NO_SECTION_VAL)\r\nFlashSectValStartOffset = 0;\r\nelse\r\nFlashSectValStartOffset = BcmGetSectionValStartOffset(Adapter,eFlash2xSectVal);\r\nif(FlashSectValStartOffset == STATUS_FAILURE )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"This Section<%d> does not exixt in Flash Map 2.x",eFlash2xSectVal);\r\nreturn -EINVAL;\r\n}\r\nif(IsSectionExistInVendorInfo(Adapter,eFlash2xSectVal))\r\nreturn vendorextnWriteSection(Adapter, (PUCHAR)pBuffer, eFlash2xSectVal, uiOffset, uiNumBytes, bVerify);\r\nuiOffset = uiOffset + FlashSectValStartOffset;\r\nrdmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nvalue = 0;\r\nwrmalt(Adapter, 0x0f000C80,&value, sizeof(value));\r\nStatus = BeceemFlashBulkWrite(Adapter, pBuffer,uiOffset,uiNumBytes,bVerify);\r\nwrmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Flash Write failed with Status :%d", Status);\r\nreturn Status ;\r\n}\r\nreturn Status;\r\n}\r\nstatic INT BcmGetActiveDSD(PMINI_ADAPTER Adapter)\r\n{\r\nFLASH2X_SECTION_VAL uiHighestPriDSD = 0 ;\r\nuiHighestPriDSD = getHighestPriDSD(Adapter);\r\nAdapter->eActiveDSD = uiHighestPriDSD;\r\nif(DSD0 == uiHighestPriDSD)\r\nAdapter->ulFlashCalStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDStart;\r\nif(DSD1 == uiHighestPriDSD)\r\nAdapter->ulFlashCalStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1Start;\r\nif(DSD2 == uiHighestPriDSD)\r\nAdapter->ulFlashCalStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2Start;\r\nif(Adapter->eActiveDSD)\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Active DSD :%d", Adapter->eActiveDSD);\r\nif(Adapter->eActiveDSD == 0)\r\n{\r\nif(IsSectionWritable(Adapter,DSD2))\r\n{\r\nAdapter->eActiveDSD = DSD2;\r\nAdapter->ulFlashCalStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2Start;\r\n}\r\nelse if(IsSectionWritable(Adapter,DSD1))\r\n{\r\nAdapter->eActiveDSD = DSD1;\r\nAdapter->ulFlashCalStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1Start;\r\n}\r\nelse if(IsSectionWritable(Adapter,DSD0))\r\n{\r\nAdapter->eActiveDSD = DSD0;\r\nAdapter->ulFlashCalStart = Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDStart;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic INT BcmGetActiveISO(PMINI_ADAPTER Adapter)\r\n{\r\nINT HighestPriISO = 0 ;\r\nHighestPriISO = getHighestPriISO(Adapter);\r\nAdapter->eActiveISO = HighestPriISO ;\r\nif(Adapter->eActiveISO == ISO_IMAGE2)\r\nAdapter->uiActiveISOOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage2Part1Start);\r\nelse if(Adapter->eActiveISO == ISO_IMAGE1)\r\nAdapter->uiActiveISOOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage1Part1Start);\r\nif(Adapter->eActiveISO)\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Active ISO :%x", Adapter->eActiveISO);\r\nreturn STATUS_SUCCESS;\r\n}\r\nB_UINT8 IsOffsetWritable(PMINI_ADAPTER Adapter, UINT uiOffset)\r\n{\r\nUINT uiSectorNum = 0;\r\nUINT uiWordOfSectorPermission =0;\r\nUINT uiBitofSectorePermission = 0;\r\nB_UINT32 permissionBits = 0;\r\nuiSectorNum = uiOffset/Adapter->uiSectorSize;\r\nuiWordOfSectorPermission = Adapter->psFlash2xCSInfo->SectorAccessBitMap[uiSectorNum /16];\r\nuiBitofSectorePermission = 2*(15 - uiSectorNum %16);\r\npermissionBits = uiWordOfSectorPermission & (0x3 << uiBitofSectorePermission) ;\r\npermissionBits = (permissionBits >> uiBitofSectorePermission) & 0x3;\r\nif(permissionBits == SECTOR_READWRITE_PERMISSION)\r\nreturn TRUE;\r\nelse\r\nreturn FALSE;\r\n}\r\nstatic INT BcmDumpFlash2xSectionBitMap(PFLASH2X_BITMAP psFlash2xBitMap)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "***************Flash 2.x Section Bitmap***************");\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"ISO_IMAGE1 :0X%x", psFlash2xBitMap->ISO_IMAGE1);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"ISO_IMAGE2 :0X%x", psFlash2xBitMap->ISO_IMAGE2);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"DSD0 :0X%x", psFlash2xBitMap->DSD0);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"DSD1 :0X%x", psFlash2xBitMap->DSD1);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"DSD2 :0X%x", psFlash2xBitMap->DSD2);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"VSA0 :0X%x", psFlash2xBitMap->VSA0);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"VSA1 :0X%x", psFlash2xBitMap->VSA1);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"VSA2 :0X%x", psFlash2xBitMap->VSA2);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"SCSI :0X%x", psFlash2xBitMap->SCSI);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"CONTROL_SECTION :0X%x", psFlash2xBitMap->CONTROL_SECTION);\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT BcmGetFlash2xSectionalBitMap(PMINI_ADAPTER Adapter, PFLASH2X_BITMAP psFlash2xBitMap)\r\n{\r\nPFLASH2X_CS_INFO psFlash2xCSInfo = Adapter->psFlash2xCSInfo;\r\nFLASH2X_SECTION_VAL uiHighestPriDSD = 0 ;\r\nFLASH2X_SECTION_VAL uiHighestPriISO= 0 ;\r\nBOOLEAN SetActiveDSDDone = FALSE ;\r\nBOOLEAN SetActiveISODone = FALSE ;\r\nif(IsFlash2x(Adapter) == FALSE)\r\n{\r\npsFlash2xBitMap->ISO_IMAGE2 = 0;\r\npsFlash2xBitMap->ISO_IMAGE1 = 0;\r\npsFlash2xBitMap->DSD0 = FLASH2X_SECTION_VALID | FLASH2X_SECTION_ACT | FLASH2X_SECTION_PRESENT;\r\npsFlash2xBitMap->DSD1 = 0 ;\r\npsFlash2xBitMap->DSD2 = 0 ;\r\npsFlash2xBitMap->VSA0 = 0 ;\r\npsFlash2xBitMap->VSA1 = 0 ;\r\npsFlash2xBitMap->VSA2 = 0 ;\r\npsFlash2xBitMap->CONTROL_SECTION = 0 ;\r\npsFlash2xBitMap->SCSI= 0 ;\r\npsFlash2xBitMap->Reserved0 = 0 ;\r\npsFlash2xBitMap->Reserved1 = 0 ;\r\npsFlash2xBitMap->Reserved2 = 0 ;\r\nreturn STATUS_SUCCESS ;\r\n}\r\nuiHighestPriDSD = getHighestPriDSD(Adapter);\r\nuiHighestPriISO = getHighestPriISO(Adapter);\r\nif((psFlash2xCSInfo->OffsetISOImage2Part1Start) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->ISO_IMAGE2= psFlash2xBitMap->ISO_IMAGE2 | FLASH2X_SECTION_PRESENT;\r\nif(ReadISOSignature(Adapter,ISO_IMAGE2)== ISO_IMAGE_MAGIC_NUMBER)\r\npsFlash2xBitMap->ISO_IMAGE2 |= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, ISO_IMAGE2) == FALSE)\r\npsFlash2xBitMap->ISO_IMAGE2 |= FLASH2X_SECTION_RO;\r\nif(SetActiveISODone == FALSE && uiHighestPriISO == ISO_IMAGE2)\r\n{\r\npsFlash2xBitMap->ISO_IMAGE2 |= FLASH2X_SECTION_ACT ;\r\nSetActiveISODone = TRUE;\r\n}\r\n}\r\nif((psFlash2xCSInfo->OffsetISOImage1Part1Start) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->ISO_IMAGE1 = psFlash2xBitMap->ISO_IMAGE1 | FLASH2X_SECTION_PRESENT;\r\nif(ReadISOSignature(Adapter,ISO_IMAGE1) == ISO_IMAGE_MAGIC_NUMBER)\r\npsFlash2xBitMap->ISO_IMAGE1 |= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, ISO_IMAGE1) == FALSE)\r\npsFlash2xBitMap->ISO_IMAGE1 |= FLASH2X_SECTION_RO;\r\nif(SetActiveISODone == FALSE && uiHighestPriISO == ISO_IMAGE1)\r\n{\r\npsFlash2xBitMap->ISO_IMAGE1 |= FLASH2X_SECTION_ACT ;\r\nSetActiveISODone = TRUE;\r\n}\r\n}\r\nif((psFlash2xCSInfo->OffsetFromZeroForDSD2Start) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->DSD2= psFlash2xBitMap->DSD2 | FLASH2X_SECTION_PRESENT;\r\nif(ReadDSDSignature(Adapter,DSD2)== DSD_IMAGE_MAGIC_NUMBER)\r\npsFlash2xBitMap->DSD2 |= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, DSD2) == FALSE)\r\n{\r\npsFlash2xBitMap->DSD2 |= FLASH2X_SECTION_RO;\r\n}\r\nelse\r\n{\r\nif((SetActiveDSDDone == FALSE) && (uiHighestPriDSD == DSD2))\r\n{\r\npsFlash2xBitMap->DSD2 |= FLASH2X_SECTION_ACT ;\r\nSetActiveDSDDone =TRUE ;\r\n}\r\n}\r\n}\r\nif((psFlash2xCSInfo->OffsetFromZeroForDSD1Start) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->DSD1= psFlash2xBitMap->DSD1 | FLASH2X_SECTION_PRESENT;\r\nif(ReadDSDSignature(Adapter,DSD1)== DSD_IMAGE_MAGIC_NUMBER)\r\npsFlash2xBitMap->DSD1 |= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, DSD1) == FALSE)\r\n{\r\npsFlash2xBitMap->DSD1 |= FLASH2X_SECTION_RO;\r\n}\r\nelse\r\n{\r\nif((SetActiveDSDDone == FALSE) && (uiHighestPriDSD == DSD1))\r\n{\r\npsFlash2xBitMap->DSD1 |= FLASH2X_SECTION_ACT ;\r\nSetActiveDSDDone =TRUE ;\r\n}\r\n}\r\n}\r\nif((psFlash2xCSInfo->OffsetFromZeroForDSDStart) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->DSD0 = psFlash2xBitMap->DSD0 | FLASH2X_SECTION_PRESENT;\r\nif(ReadDSDSignature(Adapter,DSD0) == DSD_IMAGE_MAGIC_NUMBER)\r\npsFlash2xBitMap->DSD0 |= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, DSD0) == FALSE)\r\n{\r\npsFlash2xBitMap->DSD0 |= FLASH2X_SECTION_RO;\r\n}\r\nelse\r\n{\r\nif((SetActiveDSDDone == FALSE) &&(uiHighestPriDSD == DSD0))\r\n{\r\npsFlash2xBitMap->DSD0 |= FLASH2X_SECTION_ACT ;\r\nSetActiveDSDDone =TRUE ;\r\n}\r\n}\r\n}\r\nif((psFlash2xCSInfo->OffsetFromZeroForVSAStart) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->VSA0= psFlash2xBitMap->VSA0 | FLASH2X_SECTION_PRESENT;\r\npsFlash2xBitMap->VSA0 |= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, VSA0) == FALSE)\r\npsFlash2xBitMap->VSA0 |= FLASH2X_SECTION_RO;\r\npsFlash2xBitMap->VSA0 |= FLASH2X_SECTION_ACT ;\r\n}\r\nif((psFlash2xCSInfo->OffsetFromZeroForVSA1Start) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->VSA1= psFlash2xBitMap->VSA1 | FLASH2X_SECTION_PRESENT;\r\npsFlash2xBitMap->VSA1|= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, VSA1) == FALSE)\r\npsFlash2xBitMap->VSA1 |= FLASH2X_SECTION_RO;\r\npsFlash2xBitMap->VSA1 |= FLASH2X_SECTION_ACT ;\r\n}\r\nif((psFlash2xCSInfo->OffsetFromZeroForVSA2Start) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->VSA2= psFlash2xBitMap->VSA2 | FLASH2X_SECTION_PRESENT;\r\npsFlash2xBitMap->VSA2 |= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, VSA2) == FALSE)\r\npsFlash2xBitMap->VSA2 |= FLASH2X_SECTION_RO;\r\npsFlash2xBitMap->VSA2 |= FLASH2X_SECTION_ACT ;\r\n}\r\nif((psFlash2xCSInfo->OffsetFromZeroForScsiFirmware) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->SCSI= psFlash2xBitMap->SCSI | FLASH2X_SECTION_PRESENT;\r\npsFlash2xBitMap->SCSI|= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, SCSI) == FALSE)\r\npsFlash2xBitMap->SCSI |= FLASH2X_SECTION_RO;\r\npsFlash2xBitMap->SCSI |= FLASH2X_SECTION_ACT ;\r\n}\r\nif((psFlash2xCSInfo->OffsetFromZeroForControlSectionStart) != UNINIT_PTR_IN_CS)\r\n{\r\npsFlash2xBitMap->CONTROL_SECTION = psFlash2xBitMap->CONTROL_SECTION | (FLASH2X_SECTION_PRESENT);\r\npsFlash2xBitMap->CONTROL_SECTION |= FLASH2X_SECTION_VALID;\r\nif(IsSectionWritable(Adapter, CONTROL_SECTION) == FALSE)\r\npsFlash2xBitMap->CONTROL_SECTION |= FLASH2X_SECTION_RO;\r\npsFlash2xBitMap->CONTROL_SECTION |= FLASH2X_SECTION_ACT ;\r\n}\r\npsFlash2xBitMap->Reserved0 = 0;\r\npsFlash2xBitMap->Reserved0 = 0;\r\npsFlash2xBitMap->Reserved0 = 0;\r\nBcmDumpFlash2xSectionBitMap(psFlash2xBitMap);\r\nreturn STATUS_SUCCESS ;\r\n}\r\nINT BcmSetActiveSection(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSectVal)\r\n{\r\nunsigned int SectImagePriority = 0;\r\nINT Status =STATUS_SUCCESS;\r\nINT HighestPriDSD = 0 ;\r\nINT HighestPriISO = 0;\r\nStatus = IsSectionWritable(Adapter,eFlash2xSectVal) ;\r\nif(Status != TRUE )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Provided Section <%d> is not writable",eFlash2xSectVal);\r\nreturn STATUS_FAILURE;\r\n}\r\nAdapter->bHeaderChangeAllowed = TRUE ;\r\nswitch(eFlash2xSectVal)\r\n{\r\ncase ISO_IMAGE1 :\r\ncase ISO_IMAGE2 :\r\nif(ReadISOSignature(Adapter,eFlash2xSectVal)== ISO_IMAGE_MAGIC_NUMBER )\r\n{\r\nHighestPriISO = getHighestPriISO(Adapter);\r\nif(HighestPriISO == eFlash2xSectVal )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Given ISO<%x> already has highest priority",eFlash2xSectVal );\r\nStatus = STATUS_SUCCESS ;\r\nbreak;\r\n}\r\nSectImagePriority = ReadISOPriority(Adapter, HighestPriISO) + 1;\r\nif((SectImagePriority <= 0) && IsSectionWritable(Adapter,HighestPriISO))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "SectImagePriority wraparound happened, eFlash2xSectVal: 0x%x\n",eFlash2xSectVal);\r\nSectImagePriority = htonl(0x1);\r\nStatus = BcmFlash2xBulkWrite(Adapter,\r\n&SectImagePriority,\r\nHighestPriISO,\r\n0 + FIELD_OFFSET_IN_HEADER(PISO_HEADER, ISOImagePriority),\r\nSIGNATURE_SIZE,\r\nTRUE);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Priority has not been written properly");\r\nStatus = STATUS_FAILURE;\r\nbreak ;\r\n}\r\nHighestPriISO = getHighestPriISO(Adapter);\r\nif(HighestPriISO == eFlash2xSectVal )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Given ISO<%x> already has highest priority",eFlash2xSectVal );\r\nStatus = STATUS_SUCCESS ;\r\nbreak;\r\n}\r\nSectImagePriority = 2;\r\n}\r\nSectImagePriority = htonl(SectImagePriority);\r\nStatus = BcmFlash2xBulkWrite(Adapter,\r\n&SectImagePriority,\r\neFlash2xSectVal,\r\n0 + FIELD_OFFSET_IN_HEADER(PISO_HEADER, ISOImagePriority),\r\nSIGNATURE_SIZE,\r\nTRUE);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Priority has not been written properly");\r\nbreak ;\r\n}\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Signature is currupted. Hence can't increase the priority");\r\nStatus = STATUS_FAILURE ;\r\nbreak;\r\n}\r\nbreak;\r\ncase DSD0 :\r\ncase DSD1 :\r\ncase DSD2 :\r\nif(ReadDSDSignature(Adapter,eFlash2xSectVal)== DSD_IMAGE_MAGIC_NUMBER)\r\n{\r\nHighestPriDSD = getHighestPriDSD(Adapter);\r\nif((HighestPriDSD == eFlash2xSectVal))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Given DSD<%x> already has highest priority", eFlash2xSectVal);\r\nStatus = STATUS_SUCCESS ;\r\nbreak;\r\n}\r\nSectImagePriority = ReadDSDPriority(Adapter, HighestPriDSD) + 1 ;\r\nif(SectImagePriority <= 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, NVM_RW, DBG_LVL_ALL, "SectImagePriority wraparound happened, eFlash2xSectVal: 0x%x\n",eFlash2xSectVal);\r\nSectImagePriority = htonl(0x1);\r\nStatus = BcmFlash2xBulkWrite(Adapter,\r\n&SectImagePriority,\r\nHighestPriDSD,\r\nAdapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + FIELD_OFFSET_IN_HEADER(PDSD_HEADER, DSDImagePriority),\r\nSIGNATURE_SIZE,\r\nTRUE);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Priority has not been written properly");\r\nbreak ;\r\n}\r\nHighestPriDSD = getHighestPriDSD(Adapter);\r\nif((HighestPriDSD == eFlash2xSectVal))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Made the DSD: %x highest by reducing priority of other\n", eFlash2xSectVal);\r\nStatus = STATUS_SUCCESS ;\r\nbreak;\r\n}\r\nSectImagePriority = htonl(0x2);\r\nStatus = BcmFlash2xBulkWrite(Adapter,\r\n&SectImagePriority,\r\nHighestPriDSD,\r\nAdapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + FIELD_OFFSET_IN_HEADER(PDSD_HEADER, DSDImagePriority),\r\nSIGNATURE_SIZE,\r\nTRUE);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Priority has not been written properly");\r\nbreak ;\r\n}\r\nHighestPriDSD = getHighestPriDSD(Adapter);\r\nif((HighestPriDSD == eFlash2xSectVal))\r\n{\r\nStatus = STATUS_SUCCESS ;\r\nbreak;\r\n}\r\nSectImagePriority = 3 ;\r\n}\r\nSectImagePriority = htonl(SectImagePriority);\r\nStatus = BcmFlash2xBulkWrite(Adapter,\r\n&SectImagePriority,\r\neFlash2xSectVal,\r\nAdapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + FIELD_OFFSET_IN_HEADER(PDSD_HEADER, DSDImagePriority),\r\nSIGNATURE_SIZE ,\r\nTRUE);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Priority has not been written properly");\r\nStatus = STATUS_FAILURE ;\r\nbreak ;\r\n}\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Signature is currupted. Hence can't increase the priority");\r\nStatus = STATUS_FAILURE ;\r\nbreak;\r\n}\r\nbreak;\r\ncase VSA0 :\r\ncase VSA1 :\r\ncase VSA2 :\r\nbreak ;\r\ndefault :\r\nStatus = STATUS_FAILURE ;\r\nbreak;\r\n}\r\nAdapter->bHeaderChangeAllowed = FALSE ;\r\nreturn Status;\r\n}\r\nINT BcmCopyISO(PMINI_ADAPTER Adapter, FLASH2X_COPY_SECTION sCopySectStrut)\r\n{\r\nPCHAR Buff = NULL;\r\nFLASH2X_SECTION_VAL eISOReadPart = 0,eISOWritePart = 0;\r\nUINT uiReadOffsetWithinPart = 0, uiWriteOffsetWithinPart = 0;\r\nUINT uiTotalDataToCopy = 0;\r\nBOOLEAN IsThisHeaderSector = FALSE ;\r\nUINT sigOffset = 0;\r\nUINT ISOLength = 0;\r\nUINT Status = STATUS_SUCCESS;\r\nUINT SigBuff[MAX_RW_SIZE];\r\nUINT i = 0;\r\nif(ReadISOSignature(Adapter,sCopySectStrut.SrcSection) != ISO_IMAGE_MAGIC_NUMBER)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "error as Source ISO Section does not have valid signature");\r\nreturn STATUS_FAILURE;\r\n}\r\nStatus = BcmFlash2xBulkRead(Adapter,\r\n&ISOLength,\r\nsCopySectStrut.SrcSection,\r\n0 + FIELD_OFFSET_IN_HEADER(PISO_HEADER,ISOImageSize),\r\n4);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Read failed while copying ISO\n");\r\nreturn Status;\r\n}\r\nISOLength = htonl(ISOLength);\r\nif(ISOLength % Adapter->uiSectorSize)\r\n{\r\nISOLength = Adapter->uiSectorSize*(1 + ISOLength/Adapter->uiSectorSize);\r\n}\r\nsigOffset = FIELD_OFFSET_IN_HEADER(PISO_HEADER, ISOImageMagicNumber);\r\nBuff = kzalloc(Adapter->uiSectorSize, GFP_KERNEL);\r\nif(Buff == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Memory allocation failed for section size");\r\nreturn -ENOMEM;\r\n}\r\nif(sCopySectStrut.SrcSection ==ISO_IMAGE1 && sCopySectStrut.DstSection ==ISO_IMAGE2)\r\n{\r\neISOReadPart = ISO_IMAGE1 ;\r\neISOWritePart = ISO_IMAGE2 ;\r\nuiReadOffsetWithinPart = 0;\r\nuiWriteOffsetWithinPart = 0 ;\r\nuiTotalDataToCopy =(Adapter->psFlash2xCSInfo->OffsetISOImage1Part1End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part1Start)+\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part2End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part2Start)+\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part3End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part3Start);\r\nif(uiTotalDataToCopy < ISOLength)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"error as Source ISO Section does not have valid signature");\r\nreturn STATUS_FAILURE;\r\n}\r\nuiTotalDataToCopy =(Adapter->psFlash2xCSInfo->OffsetISOImage2Part1End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part1Start)+\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part2End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part2Start)+\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part3End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part3Start);\r\nif(uiTotalDataToCopy < ISOLength)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"error as Dest ISO Section does not have enough section size");\r\nreturn STATUS_FAILURE;\r\n}\r\nuiTotalDataToCopy = ISOLength;\r\nCorruptISOSig(Adapter,ISO_IMAGE2);\r\nwhile(uiTotalDataToCopy)\r\n{\r\nif(uiTotalDataToCopy == Adapter->uiSectorSize)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Writing the signature sector");\r\neISOReadPart = ISO_IMAGE1 ;\r\nuiReadOffsetWithinPart = 0;\r\neISOWritePart = ISO_IMAGE2;\r\nuiWriteOffsetWithinPart = 0 ;\r\nIsThisHeaderSector = TRUE ;\r\n}\r\nelse\r\n{\r\nuiReadOffsetWithinPart = uiReadOffsetWithinPart + Adapter->uiSectorSize ;\r\nuiWriteOffsetWithinPart = uiWriteOffsetWithinPart + Adapter->uiSectorSize ;\r\nif((eISOReadPart == ISO_IMAGE1) && (uiReadOffsetWithinPart == (Adapter->psFlash2xCSInfo->OffsetISOImage1Part1End - Adapter->psFlash2xCSInfo->OffsetISOImage1Part1Start) ))\r\n{\r\neISOReadPart = ISO_IMAGE1_PART2 ;\r\nuiReadOffsetWithinPart = 0;\r\n}\r\nif((eISOReadPart == ISO_IMAGE1_PART2) && (uiReadOffsetWithinPart == (Adapter->psFlash2xCSInfo->OffsetISOImage1Part2End - Adapter->psFlash2xCSInfo->OffsetISOImage1Part2Start)))\r\n{\r\neISOReadPart = ISO_IMAGE1_PART3 ;\r\nuiReadOffsetWithinPart = 0;\r\n}\r\nif((eISOWritePart == ISO_IMAGE2) && (uiWriteOffsetWithinPart == (Adapter->psFlash2xCSInfo->OffsetISOImage2Part1End - Adapter->psFlash2xCSInfo->OffsetISOImage2Part1Start)))\r\n{\r\neISOWritePart = ISO_IMAGE2_PART2 ;\r\nuiWriteOffsetWithinPart = 0;\r\n}\r\nif((eISOWritePart == ISO_IMAGE2_PART2) && (uiWriteOffsetWithinPart == (Adapter->psFlash2xCSInfo->OffsetISOImage2Part2End - Adapter->psFlash2xCSInfo->OffsetISOImage2Part2Start)))\r\n{\r\neISOWritePart = ISO_IMAGE2_PART3 ;\r\nuiWriteOffsetWithinPart = 0;\r\n}\r\n}\r\nStatus = BcmFlash2xBulkRead(Adapter,\r\n(PUINT)Buff,\r\neISOReadPart,\r\nuiReadOffsetWithinPart,\r\nAdapter->uiSectorSize\r\n);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Read failed while copying ISO: Part: %x, OffsetWithinPart: %x\n", eISOReadPart, uiReadOffsetWithinPart);\r\nbreak;\r\n}\r\nif(IsThisHeaderSector == TRUE)\r\n{\r\nmemcpy(SigBuff, Buff + sigOffset, MAX_RW_SIZE);\r\nfor(i = 0; i < MAX_RW_SIZE;i++)\r\n*(Buff + sigOffset + i) = 0xFF;\r\n}\r\nAdapter->bHeaderChangeAllowed = TRUE ;\r\nStatus = BcmFlash2xBulkWrite(Adapter,\r\n(PUINT)Buff,\r\neISOWritePart,\r\nuiWriteOffsetWithinPart,\r\nAdapter->uiSectorSize,\r\nTRUE);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Write failed while copying ISO: Part: %x, OffsetWithinPart: %x\n", eISOWritePart, uiWriteOffsetWithinPart);\r\nbreak;\r\n}\r\nAdapter->bHeaderChangeAllowed = FALSE;\r\nif(IsThisHeaderSector == TRUE)\r\n{\r\nWriteToFlashWithoutSectorErase(Adapter,\r\nSigBuff,\r\neISOWritePart,\r\nsigOffset,\r\nMAX_RW_SIZE);\r\nIsThisHeaderSector = FALSE ;\r\n}\r\nuiTotalDataToCopy = uiTotalDataToCopy - Adapter->uiSectorSize ;\r\n}\r\n}\r\nif(sCopySectStrut.SrcSection ==ISO_IMAGE2 && sCopySectStrut.DstSection ==ISO_IMAGE1)\r\n{\r\neISOReadPart = ISO_IMAGE2 ;\r\neISOWritePart = ISO_IMAGE1 ;\r\nuiReadOffsetWithinPart = 0;\r\nuiWriteOffsetWithinPart = 0 ;\r\nuiTotalDataToCopy =(Adapter->psFlash2xCSInfo->OffsetISOImage2Part1End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part1Start)+\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part2End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part2Start)+\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part3End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage2Part3Start);\r\nif(uiTotalDataToCopy < ISOLength)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"error as Source ISO Section does not have valid signature");\r\nreturn STATUS_FAILURE;\r\n}\r\nuiTotalDataToCopy =(Adapter->psFlash2xCSInfo->OffsetISOImage1Part1End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part1Start)+\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part2End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part2Start)+\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part3End) -\r\n(Adapter->psFlash2xCSInfo->OffsetISOImage1Part3Start);\r\nif(uiTotalDataToCopy < ISOLength)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"error as Dest ISO Section does not have enough section size");\r\nreturn STATUS_FAILURE;\r\n}\r\nuiTotalDataToCopy = ISOLength;\r\nCorruptISOSig(Adapter,ISO_IMAGE1);\r\nwhile(uiTotalDataToCopy)\r\n{\r\nif(uiTotalDataToCopy == Adapter->uiSectorSize)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Writing the signature sector");\r\neISOReadPart = ISO_IMAGE2 ;\r\nuiReadOffsetWithinPart = 0;\r\neISOWritePart = ISO_IMAGE1;\r\nuiWriteOffsetWithinPart = 0 ;\r\nIsThisHeaderSector = TRUE;\r\n}\r\nelse\r\n{\r\nuiReadOffsetWithinPart = uiReadOffsetWithinPart + Adapter->uiSectorSize ;\r\nuiWriteOffsetWithinPart = uiWriteOffsetWithinPart + Adapter->uiSectorSize ;\r\nif((eISOReadPart == ISO_IMAGE2) && (uiReadOffsetWithinPart == (Adapter->psFlash2xCSInfo->OffsetISOImage2Part1End - Adapter->psFlash2xCSInfo->OffsetISOImage2Part1Start) ))\r\n{\r\neISOReadPart = ISO_IMAGE2_PART2 ;\r\nuiReadOffsetWithinPart = 0;\r\n}\r\nif((eISOReadPart == ISO_IMAGE2_PART2) && (uiReadOffsetWithinPart == (Adapter->psFlash2xCSInfo->OffsetISOImage2Part2End - Adapter->psFlash2xCSInfo->OffsetISOImage2Part2Start)))\r\n{\r\neISOReadPart = ISO_IMAGE2_PART3 ;\r\nuiReadOffsetWithinPart = 0;\r\n}\r\nif((eISOWritePart == ISO_IMAGE1) && (uiWriteOffsetWithinPart == (Adapter->psFlash2xCSInfo->OffsetISOImage1Part1End - Adapter->psFlash2xCSInfo->OffsetISOImage1Part1Start)))\r\n{\r\neISOWritePart = ISO_IMAGE1_PART2 ;\r\nuiWriteOffsetWithinPart = 0;\r\n}\r\nif((eISOWritePart == ISO_IMAGE1_PART2) && (uiWriteOffsetWithinPart == (Adapter->psFlash2xCSInfo->OffsetISOImage1Part2End - Adapter->psFlash2xCSInfo->OffsetISOImage1Part2Start)))\r\n{\r\neISOWritePart = ISO_IMAGE1_PART3 ;\r\nuiWriteOffsetWithinPart = 0;\r\n}\r\n}\r\nStatus = BcmFlash2xBulkRead(Adapter,\r\n(PUINT)Buff,\r\neISOReadPart,\r\nuiReadOffsetWithinPart,\r\nAdapter->uiSectorSize\r\n);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Read failed while copying ISO: Part: %x, OffsetWithinPart: %x\n", eISOReadPart, uiReadOffsetWithinPart);\r\nbreak;\r\n}\r\nif(IsThisHeaderSector == TRUE)\r\n{\r\nmemcpy(SigBuff, Buff + sigOffset, MAX_RW_SIZE);\r\nfor(i = 0; i < MAX_RW_SIZE;i++)\r\n*(Buff + sigOffset + i) = 0xFF;\r\n}\r\nAdapter->bHeaderChangeAllowed = TRUE ;\r\nStatus = BcmFlash2xBulkWrite(Adapter,\r\n(PUINT)Buff,\r\neISOWritePart,\r\nuiWriteOffsetWithinPart,\r\nAdapter->uiSectorSize,\r\nTRUE);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Write failed while copying ISO: Part: %x, OffsetWithinPart: %x\n", eISOWritePart, uiWriteOffsetWithinPart);\r\nbreak;\r\n}\r\nAdapter->bHeaderChangeAllowed = FALSE ;\r\nif(IsThisHeaderSector == TRUE)\r\n{\r\nWriteToFlashWithoutSectorErase(Adapter,\r\nSigBuff,\r\neISOWritePart,\r\nsigOffset,\r\nMAX_RW_SIZE);\r\nIsThisHeaderSector = FALSE ;\r\n}\r\nuiTotalDataToCopy = uiTotalDataToCopy - Adapter->uiSectorSize ;\r\n}\r\n}\r\nkfree(Buff);\r\nreturn Status;\r\n}\r\nINT BcmFlash2xCorruptSig(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSectionVal)\r\n{\r\nINT Status = STATUS_SUCCESS ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Section Value :%x \n", eFlash2xSectionVal);\r\nif((eFlash2xSectionVal == DSD0) || (eFlash2xSectionVal == DSD1) || (eFlash2xSectionVal == DSD2))\r\n{\r\nStatus = CorruptDSDSig(Adapter, eFlash2xSectionVal);\r\n}\r\nelse if(eFlash2xSectionVal == ISO_IMAGE1 || eFlash2xSectionVal == ISO_IMAGE2)\r\n{\r\nStatus = CorruptISOSig(Adapter, eFlash2xSectionVal);\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Given Section <%d>does not have Header",eFlash2xSectionVal);\r\nreturn STATUS_SUCCESS;\r\n}\r\nreturn Status;\r\n}\r\nINT BcmFlash2xWriteSig(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlashSectionVal)\r\n{\r\nUINT uiSignature = 0 ;\r\nUINT uiOffset = 0;\r\nif(Adapter->bSigCorrupted == FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Signature is not corrupted by driver, hence not restoring\n");\r\nreturn STATUS_SUCCESS;\r\n}\r\nif(Adapter->bAllDSDWriteAllow == FALSE)\r\n{\r\nif(IsSectionWritable(Adapter,eFlashSectionVal) == FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section is not Writable...Hence can't Write signature");\r\nreturn SECTOR_IS_NOT_WRITABLE;\r\n}\r\n}\r\nif((eFlashSectionVal == DSD0) ||(eFlashSectionVal == DSD1) || (eFlashSectionVal == DSD2))\r\n{\r\nuiSignature = htonl(DSD_IMAGE_MAGIC_NUMBER) ;\r\nuiOffset = Adapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader ;\r\nuiOffset += FIELD_OFFSET_IN_HEADER(PDSD_HEADER,DSDImageMagicNumber);\r\nif((ReadDSDSignature(Adapter,eFlashSectionVal) & 0xFF000000) != CORRUPTED_PATTERN)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Corrupted Pattern is not there. Hence won't write sig");\r\nreturn STATUS_FAILURE;\r\n}\r\n}\r\nelse if((eFlashSectionVal == ISO_IMAGE1) || (eFlashSectionVal == ISO_IMAGE2))\r\n{\r\nuiSignature = htonl(ISO_IMAGE_MAGIC_NUMBER);\r\nuiOffset = FIELD_OFFSET_IN_HEADER(PISO_HEADER,ISOImageMagicNumber);\r\nif((ReadISOSignature(Adapter,eFlashSectionVal) & 0xFF000000) != CORRUPTED_PATTERN)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Currupted Pattern is not there. Hence won't write sig");\r\nreturn STATUS_FAILURE;\r\n}\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"GIVEN SECTION< %d > IS NOT VALID FOR SIG WRITE...", eFlashSectionVal);\r\nreturn STATUS_FAILURE;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Restoring the signature");\r\nAdapter->bHeaderChangeAllowed = TRUE;\r\nAdapter->bSigCorrupted = FALSE;\r\nBcmFlash2xBulkWrite(Adapter, &uiSignature,eFlashSectionVal,uiOffset,SIGNATURE_SIZE,TRUE);\r\nAdapter->bHeaderChangeAllowed = FALSE;\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT validateFlash2xReadWrite(PMINI_ADAPTER Adapter, PFLASH2X_READWRITE psFlash2xReadWrite)\r\n{\r\nUINT uiNumOfBytes = 0 ;\r\nUINT uiSectStartOffset = 0 ;\r\nUINT uiSectEndOffset = 0;\r\nuiNumOfBytes = psFlash2xReadWrite->numOfBytes;\r\nif(IsSectionExistInFlash(Adapter,psFlash2xReadWrite->Section) != TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section<%x> does not exixt in Flash",psFlash2xReadWrite->Section);\r\nreturn FALSE;\r\n}\r\nuiSectStartOffset = BcmGetSectionValStartOffset(Adapter,psFlash2xReadWrite->Section);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "Start offset :%x ,section :%d\n",uiSectStartOffset,psFlash2xReadWrite->Section);\r\nif((psFlash2xReadWrite->Section == ISO_IMAGE1) ||(psFlash2xReadWrite->Section == ISO_IMAGE2))\r\n{\r\nif(psFlash2xReadWrite->Section == ISO_IMAGE1)\r\n{\r\nuiSectEndOffset = BcmGetSectionValEndOffset(Adapter,ISO_IMAGE1) -\r\nBcmGetSectionValStartOffset(Adapter,ISO_IMAGE1)+\r\nBcmGetSectionValEndOffset(Adapter,ISO_IMAGE1_PART2) -\r\nBcmGetSectionValStartOffset(Adapter,ISO_IMAGE1_PART2)+\r\nBcmGetSectionValEndOffset(Adapter,ISO_IMAGE1_PART3) -\r\nBcmGetSectionValStartOffset(Adapter,ISO_IMAGE1_PART3);\r\n}\r\nelse if(psFlash2xReadWrite->Section == ISO_IMAGE2)\r\n{\r\nuiSectEndOffset = BcmGetSectionValEndOffset(Adapter,ISO_IMAGE2) -\r\nBcmGetSectionValStartOffset(Adapter,ISO_IMAGE2)+\r\nBcmGetSectionValEndOffset(Adapter,ISO_IMAGE2_PART2) -\r\nBcmGetSectionValStartOffset(Adapter,ISO_IMAGE2_PART2)+\r\nBcmGetSectionValEndOffset(Adapter,ISO_IMAGE2_PART3) -\r\nBcmGetSectionValStartOffset(Adapter,ISO_IMAGE2_PART3);\r\n}\r\nuiSectEndOffset = uiSectStartOffset + uiSectEndOffset ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Total size of the ISO Image :%x",uiSectEndOffset);\r\n}\r\nelse\r\nuiSectEndOffset = BcmGetSectionValEndOffset(Adapter,psFlash2xReadWrite->Section);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "End offset :%x \n",uiSectEndOffset);\r\nif((uiSectStartOffset + psFlash2xReadWrite->offset + uiNumOfBytes) <= uiSectEndOffset)\r\nreturn TRUE;\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Invalid Request....");\r\nreturn FALSE;\r\n}\r\n}\r\nINT IsFlash2x(PMINI_ADAPTER Adapter)\r\n{\r\nif(Adapter->uiFlashLayoutMajorVersion >= FLASH_2X_MAJOR_NUMBER)\r\nreturn TRUE ;\r\nelse\r\nreturn FALSE;\r\n}\r\nstatic INT GetFlashBaseAddr(PMINI_ADAPTER Adapter)\r\n{\r\nUINT uiBaseAddr = 0;\r\nif(Adapter->bDDRInitDone)\r\n{\r\nif(Adapter->uiFlashLayoutMajorVersion && (Adapter->bFlashRawRead == FALSE) &&\r\n!((Adapter->uiFlashLayoutMajorVersion == 1) && (Adapter->uiFlashLayoutMinorVersion == 1))\r\n)\r\nuiBaseAddr = Adapter->uiFlashBaseAdd ;\r\nelse\r\nuiBaseAddr = FLASH_CONTIGIOUS_START_ADDR_AFTER_INIT;\r\n}\r\nelse\r\n{\r\nif(Adapter->uiFlashLayoutMajorVersion && (Adapter->bFlashRawRead == FALSE) &&\r\n!((Adapter->uiFlashLayoutMajorVersion == 1) && (Adapter->uiFlashLayoutMinorVersion == 1))\r\n)\r\nuiBaseAddr = Adapter->uiFlashBaseAdd | FLASH_CONTIGIOUS_START_ADDR_BEFORE_INIT;\r\nelse\r\nuiBaseAddr = FLASH_CONTIGIOUS_START_ADDR_BEFORE_INIT;\r\n}\r\nreturn uiBaseAddr ;\r\n}\r\nINT BcmCopySection(PMINI_ADAPTER Adapter,\r\nFLASH2X_SECTION_VAL SrcSection,\r\nFLASH2X_SECTION_VAL DstSection,\r\nUINT offset,\r\nUINT numOfBytes)\r\n{\r\nUINT BuffSize = 0 ;\r\nUINT BytesToBeCopied = 0;\r\nPUCHAR pBuff = NULL ;\r\nINT Status = STATUS_SUCCESS ;\r\nif(SrcSection == DstSection)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Source and Destination should be different ...try again");\r\nreturn -EINVAL;\r\n}\r\nif((SrcSection != DSD0) && (SrcSection != DSD1) && (SrcSection != DSD2))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Source should be DSD subsection");\r\nreturn -EINVAL;\r\n}\r\nif((DstSection != DSD0) && (DstSection != DSD1) && (DstSection != DSD2))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Destination should be DSD subsection");\r\nreturn -EINVAL;\r\n}\r\nif(numOfBytes == 0)\r\n{\r\nnumOfBytes = BcmGetSectionValEndOffset(Adapter,SrcSection)\r\n- BcmGetSectionValStartOffset(Adapter,SrcSection);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL," Section Size :0x%x",numOfBytes);\r\n}\r\nif((offset + numOfBytes) > BcmGetSectionValEndOffset(Adapter,SrcSection)\r\n- BcmGetSectionValStartOffset(Adapter,SrcSection))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0," Input parameters going beyond the section offS: %x numB: %x of Source Section\n",\r\noffset, numOfBytes);\r\nreturn -EINVAL;\r\n}\r\nif((offset + numOfBytes) > BcmGetSectionValEndOffset(Adapter,DstSection)\r\n- BcmGetSectionValStartOffset(Adapter,DstSection))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0," Input parameters going beyond the section offS: %x numB: %x of Destination Section\n",\r\noffset, numOfBytes);\r\nreturn -EINVAL;\r\n}\r\nif(numOfBytes > Adapter->uiSectorSize )\r\nBuffSize = Adapter->uiSectorSize;\r\nelse\r\nBuffSize = numOfBytes ;\r\npBuff = (PCHAR)kzalloc(BuffSize, GFP_KERNEL);\r\nif(pBuff == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Memory allocation failed.. ");\r\nreturn -ENOMEM;\r\n}\r\nBytesToBeCopied = Adapter->uiSectorSize ;\r\nif(offset % Adapter->uiSectorSize)\r\nBytesToBeCopied = Adapter->uiSectorSize - (offset % Adapter->uiSectorSize);\r\nif(BytesToBeCopied > numOfBytes)\r\nBytesToBeCopied = numOfBytes ;\r\nAdapter->bHeaderChangeAllowed = TRUE;\r\ndo\r\n{\r\nStatus = BcmFlash2xBulkRead(Adapter, (PUINT)pBuff, SrcSection , offset,BytesToBeCopied);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Read failed at offset :%d for NOB :%d", SrcSection,BytesToBeCopied);\r\nbreak;\r\n}\r\nStatus = BcmFlash2xBulkWrite(Adapter,(PUINT)pBuff,DstSection,offset,BytesToBeCopied,FALSE);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Write failed at offset :%d for NOB :%d", DstSection,BytesToBeCopied);\r\nbreak;\r\n}\r\noffset = offset + BytesToBeCopied;\r\nnumOfBytes = numOfBytes - BytesToBeCopied ;\r\nif(numOfBytes)\r\n{\r\nif(numOfBytes > Adapter->uiSectorSize )\r\nBytesToBeCopied = Adapter->uiSectorSize;\r\nelse\r\nBytesToBeCopied = numOfBytes;\r\n}\r\n}while(numOfBytes > 0) ;\r\nkfree(pBuff);\r\nAdapter->bHeaderChangeAllowed = FALSE ;\r\nreturn Status;\r\n}\r\nINT SaveHeaderIfPresent(PMINI_ADAPTER Adapter, PUCHAR pBuff, UINT uiOffset)\r\n{\r\nUINT offsetToProtect = 0,HeaderSizeToProtect =0;\r\nBOOLEAN bHasHeader = FALSE ;\r\nPUCHAR pTempBuff =NULL;\r\nUINT uiSectAlignAddr = 0;\r\nUINT sig = 0;\r\nuiSectAlignAddr = uiOffset & ~(Adapter->uiSectorSize - 1);\r\nif((uiSectAlignAddr == BcmGetSectionValEndOffset(Adapter,DSD2)- Adapter->uiSectorSize)||\r\n(uiSectAlignAddr == BcmGetSectionValEndOffset(Adapter,DSD1)- Adapter->uiSectorSize)||\r\n(uiSectAlignAddr == BcmGetSectionValEndOffset(Adapter,DSD0)- Adapter->uiSectorSize))\r\n{\r\noffsetToProtect = Adapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader % Adapter->uiSectorSize;\r\nHeaderSizeToProtect = sizeof(DSD_HEADER);\r\nbHasHeader = TRUE ;\r\n}\r\nif(uiSectAlignAddr == BcmGetSectionValStartOffset(Adapter,ISO_IMAGE1) ||\r\nuiSectAlignAddr == BcmGetSectionValStartOffset(Adapter,ISO_IMAGE2))\r\n{\r\noffsetToProtect = 0;\r\nHeaderSizeToProtect = sizeof(ISO_HEADER);\r\nbHasHeader = TRUE;\r\n}\r\nif(bHasHeader && (Adapter->bHeaderChangeAllowed == FALSE))\r\n{\r\npTempBuff = (PUCHAR)kzalloc(HeaderSizeToProtect, GFP_KERNEL);\r\nif(pTempBuff == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Memory allocation failed ");\r\nreturn -ENOMEM;\r\n}\r\nBeceemFlashBulkRead(Adapter,(PUINT)pTempBuff,(uiSectAlignAddr + offsetToProtect),HeaderSizeToProtect);\r\nBCM_DEBUG_PRINT_BUFFER(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,pTempBuff ,HeaderSizeToProtect);\r\nmemcpy(pBuff +offsetToProtect,pTempBuff,HeaderSizeToProtect);\r\nkfree(pTempBuff);\r\n}\r\nif(bHasHeader && Adapter->bSigCorrupted)\r\n{\r\nsig = *((PUINT)(pBuff + offsetToProtect + FIELD_OFFSET_IN_HEADER(PDSD_HEADER,DSDImageMagicNumber)));\r\nsig = ntohl(sig);\r\nif((sig & 0xFF000000) != CORRUPTED_PATTERN)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Desired pattern is not at sig offset. Hence won't restore");\r\nAdapter->bSigCorrupted = FALSE;\r\nreturn STATUS_SUCCESS;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL," Corrupted sig is :%X", sig);\r\n*((PUINT)(pBuff + offsetToProtect + FIELD_OFFSET_IN_HEADER(PDSD_HEADER,DSDImageMagicNumber)))= htonl(DSD_IMAGE_MAGIC_NUMBER);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Restoring the signature in Header Write only");\r\nAdapter->bSigCorrupted = FALSE;\r\n}\r\nreturn STATUS_SUCCESS ;\r\n}\r\nstatic INT BcmDoChipSelect(PMINI_ADAPTER Adapter, UINT offset)\r\n{\r\nUINT FlashConfig = 0;\r\nINT ChipNum = 0;\r\nUINT GPIOConfig = 0;\r\nUINT PartNum = 0;\r\nChipNum = offset / FLASH_PART_SIZE ;\r\nif(Adapter->SelectedChip == ChipNum)\r\nreturn STATUS_SUCCESS;\r\nAdapter->SelectedChip = ChipNum ;\r\nrdmalt(Adapter,FLASH_CONFIG_REG, &FlashConfig, 4);\r\nrdmalt(Adapter,FLASH_GPIO_CONFIG_REG, &GPIOConfig, 4);\r\n{\r\nswitch(ChipNum)\r\n{\r\ncase 0:\r\nPartNum = 0;\r\nbreak;\r\ncase 1:\r\nPartNum = 3;\r\nGPIOConfig |= (0x4 << CHIP_SELECT_BIT12);\r\nbreak;\r\ncase 2:\r\nPartNum = 1;\r\nGPIOConfig |= (0x1 << CHIP_SELECT_BIT12);\r\nbreak;\r\ncase 3:\r\nPartNum = 2;\r\nGPIOConfig |= (0x2 << CHIP_SELECT_BIT12);\r\nbreak;\r\n}\r\n}\r\nif(PartNum == ((FlashConfig >> CHIP_SELECT_BIT12) & 0x3))\r\nreturn STATUS_SUCCESS;\r\nFlashConfig &= 0xFFFFCFFF;\r\nFlashConfig = (FlashConfig | (PartNum<<CHIP_SELECT_BIT12));\r\nwrmalt(Adapter,FLASH_GPIO_CONFIG_REG, &GPIOConfig, 4);\r\nudelay(100);\r\nwrmalt(Adapter,FLASH_CONFIG_REG, &FlashConfig, 4);\r\nudelay(100);\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT ReadDSDSignature(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL dsd)\r\n{\r\nUINT uiDSDsig = 0;\r\nif(dsd != DSD0 && dsd != DSD1 && dsd != DSD2)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"passed section value is not for DSDs");\r\nreturn STATUS_FAILURE;\r\n}\r\nBcmFlash2xBulkRead(Adapter,\r\n&uiDSDsig,\r\ndsd,\r\nAdapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + FIELD_OFFSET_IN_HEADER(PDSD_HEADER,DSDImageMagicNumber),\r\nSIGNATURE_SIZE);\r\nuiDSDsig = ntohl(uiDSDsig);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"DSD SIG :%x", uiDSDsig);\r\nreturn uiDSDsig ;\r\n}\r\nINT ReadDSDPriority(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL dsd)\r\n{\r\nunsigned int uiDSDPri = STATUS_FAILURE;\r\nif(IsSectionWritable(Adapter,dsd))\r\n{\r\nif(ReadDSDSignature(Adapter,dsd)== DSD_IMAGE_MAGIC_NUMBER)\r\n{\r\nBcmFlash2xBulkRead(Adapter,\r\n&uiDSDPri,\r\ndsd,\r\nAdapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader +FIELD_OFFSET_IN_HEADER(PDSD_HEADER, DSDImagePriority),\r\n4);\r\nuiDSDPri = ntohl(uiDSDPri);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"DSD<%x> Priority :%x", dsd, uiDSDPri);\r\n}\r\n}\r\nreturn uiDSDPri;\r\n}\r\nFLASH2X_SECTION_VAL getHighestPriDSD(PMINI_ADAPTER Adapter)\r\n{\r\nINT DSDHighestPri = STATUS_FAILURE;\r\nINT DsdPri= 0 ;\r\nFLASH2X_SECTION_VAL HighestPriDSD = 0 ;\r\nif(IsSectionWritable(Adapter,DSD2))\r\n{\r\nDSDHighestPri = ReadDSDPriority(Adapter,DSD2);\r\nHighestPriDSD = DSD2 ;\r\n}\r\nif(IsSectionWritable(Adapter,DSD1))\r\n{\r\nDsdPri = ReadDSDPriority(Adapter,DSD1);\r\nif(DSDHighestPri < DsdPri)\r\n{\r\nDSDHighestPri = DsdPri ;\r\nHighestPriDSD = DSD1;\r\n}\r\n}\r\nif(IsSectionWritable(Adapter,DSD0))\r\n{\r\nDsdPri = ReadDSDPriority(Adapter,DSD0);\r\nif(DSDHighestPri < DsdPri)\r\n{\r\nDSDHighestPri = DsdPri ;\r\nHighestPriDSD = DSD0;\r\n}\r\n}\r\nif(HighestPriDSD)\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Highest DSD :%x , and its Pri :%x", HighestPriDSD, DSDHighestPri);\r\nreturn HighestPriDSD ;\r\n}\r\nINT ReadISOSignature(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL iso)\r\n{\r\nUINT uiISOsig = 0;\r\nif(iso != ISO_IMAGE1 && iso != ISO_IMAGE2)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"passed section value is not for ISOs");\r\nreturn STATUS_FAILURE;\r\n}\r\nBcmFlash2xBulkRead(Adapter,\r\n&uiISOsig,\r\niso,\r\n0 + FIELD_OFFSET_IN_HEADER(PISO_HEADER,ISOImageMagicNumber),\r\nSIGNATURE_SIZE);\r\nuiISOsig = ntohl(uiISOsig);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"ISO SIG :%x", uiISOsig);\r\nreturn uiISOsig ;\r\n}\r\nINT ReadISOPriority(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL iso)\r\n{\r\nunsigned int ISOPri = STATUS_FAILURE;\r\nif(IsSectionWritable(Adapter,iso))\r\n{\r\nif(ReadISOSignature(Adapter,iso)== ISO_IMAGE_MAGIC_NUMBER)\r\n{\r\nBcmFlash2xBulkRead(Adapter,\r\n&ISOPri,\r\niso,\r\n0 + FIELD_OFFSET_IN_HEADER(PISO_HEADER, ISOImagePriority),\r\n4);\r\nISOPri = ntohl(ISOPri);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"ISO<%x> Priority :%x", iso, ISOPri);\r\n}\r\n}\r\nreturn ISOPri;\r\n}\r\nFLASH2X_SECTION_VAL getHighestPriISO(PMINI_ADAPTER Adapter)\r\n{\r\nINT ISOHighestPri = STATUS_FAILURE;\r\nINT ISOPri= 0 ;\r\nFLASH2X_SECTION_VAL HighestPriISO = NO_SECTION_VAL ;\r\nif(IsSectionWritable(Adapter,ISO_IMAGE2))\r\n{\r\nISOHighestPri = ReadISOPriority(Adapter,ISO_IMAGE2);\r\nHighestPriISO = ISO_IMAGE2 ;\r\n}\r\nif(IsSectionWritable(Adapter,ISO_IMAGE1))\r\n{\r\nISOPri = ReadISOPriority(Adapter,ISO_IMAGE1);\r\nif(ISOHighestPri < ISOPri)\r\n{\r\nISOHighestPri = ISOPri ;\r\nHighestPriISO = ISO_IMAGE1;\r\n}\r\n}\r\nif(HighestPriISO)\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Highest ISO :%x and its Pri :%x",HighestPriISO,ISOHighestPri);\r\nreturn HighestPriISO ;\r\n}\r\nINT WriteToFlashWithoutSectorErase(PMINI_ADAPTER Adapter,\r\nPUINT pBuff,\r\nFLASH2X_SECTION_VAL eFlash2xSectionVal,\r\nUINT uiOffset,\r\nUINT uiNumBytes\r\n)\r\n{\r\n#if !defined(BCM_SHM_INTERFACE) || defined(FLASH_DIRECT_ACCESS)\r\nUINT uiTemp = 0, value = 0 ;\r\nUINT i = 0;\r\nUINT uiPartOffset = 0;\r\n#endif\r\nUINT uiStartOffset = 0;\r\nINT Status = STATUS_SUCCESS;\r\nPUCHAR pcBuff = (PUCHAR)pBuff;\r\nif(uiNumBytes % Adapter->ulFlashWriteSize)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Writing without Sector Erase for non-FlashWriteSize number of bytes 0x%x\n", uiNumBytes);\r\nreturn STATUS_FAILURE;\r\n}\r\nuiStartOffset = BcmGetSectionValStartOffset(Adapter,eFlash2xSectionVal);\r\nif(IsSectionExistInVendorInfo(Adapter,eFlash2xSectionVal))\r\n{\r\nreturn vendorextnWriteSectionWithoutErase(Adapter, pcBuff, eFlash2xSectionVal, uiOffset, uiNumBytes);\r\n}\r\nuiOffset = uiOffset + uiStartOffset;\r\n#if defined(BCM_SHM_INTERFACE) && !defined(FLASH_DIRECT_ACCESS)\r\nStatus = bcmflash_raw_writenoerase((uiOffset/FLASH_PART_SIZE),(uiOffset % FLASH_PART_SIZE), pcBuff,uiNumBytes);\r\n#else\r\nrdmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nvalue = 0;\r\nwrmalt(Adapter, 0x0f000C80,&value, sizeof(value));\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\nBcmDoChipSelect(Adapter,uiOffset);\r\nuiPartOffset = (uiOffset & (FLASH_PART_SIZE - 1)) + GetFlashBaseAddr(Adapter);\r\nfor(i = 0 ; i< uiNumBytes; i += Adapter->ulFlashWriteSize)\r\n{\r\nif(Adapter->ulFlashWriteSize == BYTE_WRITE_SUPPORT)\r\nStatus = flashByteWrite(Adapter,uiPartOffset, pcBuff);\r\nelse\r\nStatus = flashWrite(Adapter,uiPartOffset, pcBuff);\r\nif(Status != STATUS_SUCCESS)\r\nbreak;\r\npcBuff = pcBuff + Adapter->ulFlashWriteSize;\r\nuiPartOffset = uiPartOffset + Adapter->ulFlashWriteSize;\r\n}\r\nwrmalt(Adapter, 0x0f000C80, &uiTemp, sizeof(uiTemp));\r\nAdapter->SelectedChip = RESET_CHIP_SELECT;\r\n#endif\r\nreturn Status;\r\n}\r\nBOOLEAN IsSectionExistInFlash(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL section)\r\n{\r\nBOOLEAN SectionPresent = FALSE ;\r\nswitch(section)\r\n{\r\ncase ISO_IMAGE1 :\r\nif((Adapter->psFlash2xCSInfo->OffsetISOImage1Part1Start != UNINIT_PTR_IN_CS) &&\r\n(IsNonCDLessDevice(Adapter) == FALSE))\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase ISO_IMAGE2 :\r\nif((Adapter->psFlash2xCSInfo->OffsetISOImage2Part1Start != UNINIT_PTR_IN_CS) &&\r\n(IsNonCDLessDevice(Adapter) == FALSE))\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase DSD0 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSDStart != UNINIT_PTR_IN_CS)\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase DSD1 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD1Start != UNINIT_PTR_IN_CS)\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase DSD2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForDSD2Start != UNINIT_PTR_IN_CS)\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase VSA0 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSAStart != UNINIT_PTR_IN_CS)\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase VSA1 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA1Start != UNINIT_PTR_IN_CS)\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase VSA2 :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForVSA2Start != UNINIT_PTR_IN_CS)\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase SCSI :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForScsiFirmware != UNINIT_PTR_IN_CS)\r\nSectionPresent = TRUE ;\r\nbreak;\r\ncase CONTROL_SECTION :\r\nif(Adapter->psFlash2xCSInfo->OffsetFromZeroForControlSectionStart != UNINIT_PTR_IN_CS)\r\nSectionPresent = TRUE ;\r\nbreak;\r\ndefault :\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section Does not exist in Flash 2.x");\r\nSectionPresent = FALSE;\r\n}\r\nreturn SectionPresent ;\r\n}\r\nINT IsSectionWritable(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL Section)\r\n{\r\nINT offset = STATUS_FAILURE;\r\nINT Status = FALSE;\r\nif(IsSectionExistInFlash(Adapter,Section) == FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section <%d> does not exixt", Section);\r\nreturn FALSE;\r\n}\r\noffset = BcmGetSectionValStartOffset(Adapter,Section);\r\nif(offset == INVALID_OFFSET)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section<%d> does not exixt", Section);\r\nreturn FALSE;\r\n}\r\nif(IsSectionExistInVendorInfo(Adapter,Section))\r\n{\r\nreturn !(Adapter->psFlash2xVendorInfo->VendorSection[Section].AccessFlags & FLASH2X_SECTION_RO);\r\n}\r\nStatus = IsOffsetWritable(Adapter,offset);\r\nreturn Status ;\r\n}\r\nstatic INT CorruptDSDSig(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSectionVal)\r\n{\r\nPUCHAR pBuff = NULL;\r\nUINT sig = 0;\r\nUINT uiOffset = 0;\r\nUINT BlockStatus = 0;\r\nUINT uiSectAlignAddr = 0;\r\nAdapter->bSigCorrupted = FALSE;\r\nif(Adapter->bAllDSDWriteAllow == FALSE)\r\n{\r\nif(IsSectionWritable(Adapter,eFlash2xSectionVal) != TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section is not Writable...Hence can't Corrupt signature");\r\nreturn SECTOR_IS_NOT_WRITABLE;\r\n}\r\n}\r\npBuff = (PUCHAR)kzalloc(MAX_RW_SIZE, GFP_KERNEL);\r\nif(pBuff == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Can't allocate memorey");\r\nreturn -ENOMEM ;\r\n}\r\nuiOffset = Adapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader + sizeof(DSD_HEADER);\r\nuiOffset -= MAX_RW_SIZE ;\r\nBcmFlash2xBulkRead(Adapter, (PUINT)pBuff,eFlash2xSectionVal,uiOffset,MAX_RW_SIZE);\r\nsig = *((PUINT)(pBuff +12));\r\nsig =ntohl(sig);\r\nBCM_DEBUG_PRINT_BUFFER(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,pBuff,MAX_RW_SIZE);\r\n*(pBuff + 12) = 0;\r\nif(sig == DSD_IMAGE_MAGIC_NUMBER)\r\n{\r\nAdapter->bSigCorrupted = TRUE;\r\nif(Adapter->ulFlashWriteSize == BYTE_WRITE_SUPPORT)\r\n{\r\nuiSectAlignAddr = uiOffset & ~(Adapter->uiSectorSize -1);\r\nBlockStatus = BcmFlashUnProtectBlock(Adapter,uiSectAlignAddr,Adapter->uiSectorSize);\r\nWriteToFlashWithoutSectorErase(Adapter,(PUINT)(pBuff + 12),eFlash2xSectionVal,\r\n(uiOffset + 12),BYTE_WRITE_SUPPORT);\r\nif(BlockStatus)\r\n{\r\nBcmRestoreBlockProtectStatus(Adapter,BlockStatus);\r\nBlockStatus = 0;\r\n}\r\n}\r\nelse\r\n{\r\nWriteToFlashWithoutSectorErase(Adapter,(PUINT)pBuff,eFlash2xSectionVal,\r\nuiOffset ,MAX_RW_SIZE);\r\n}\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"BCM Signature is not present in header");\r\nkfree(pBuff);\r\nreturn STATUS_FAILURE;\r\n}\r\nkfree(pBuff);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Corrupted the signature");\r\nreturn STATUS_SUCCESS ;\r\n}\r\nstatic INT CorruptISOSig(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSectionVal)\r\n{\r\nPUCHAR pBuff = NULL;\r\nUINT sig = 0;\r\nUINT uiOffset = 0;\r\nAdapter->bSigCorrupted = FALSE;\r\nif(IsSectionWritable(Adapter,eFlash2xSectionVal) != TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section is not Writable...Hence can't Corrupt signature");\r\nreturn SECTOR_IS_NOT_WRITABLE;\r\n}\r\npBuff = (PUCHAR)kzalloc(MAX_RW_SIZE, GFP_KERNEL);\r\nif(pBuff == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Can't allocate memorey");\r\nreturn -ENOMEM ;\r\n}\r\nuiOffset = 0;\r\nBcmFlash2xBulkRead(Adapter, (PUINT)pBuff,eFlash2xSectionVal,uiOffset, MAX_RW_SIZE);\r\nsig = *((PUINT)pBuff);\r\nsig =ntohl(sig);\r\n*pBuff = 0;\r\nif(sig == ISO_IMAGE_MAGIC_NUMBER)\r\n{\r\nAdapter->bSigCorrupted = TRUE;\r\nWriteToFlashWithoutSectorErase(Adapter,(PUINT)pBuff,eFlash2xSectionVal,\r\nuiOffset ,Adapter->ulFlashWriteSize);\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"BCM Signature is not present in header");\r\nkfree(pBuff);\r\nreturn STATUS_FAILURE;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,"Corrupted the signature");\r\nBCM_DEBUG_PRINT_BUFFER(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL,pBuff,MAX_RW_SIZE);\r\nkfree(pBuff);\r\nreturn STATUS_SUCCESS ;\r\n}\r\nBOOLEAN IsNonCDLessDevice(PMINI_ADAPTER Adapter)\r\n{\r\nif(Adapter->psFlash2xCSInfo->IsCDLessDeviceBootSig == NON_CDLESS_DEVICE_BOOT_SIG)\r\nreturn TRUE;\r\nelse\r\nreturn FALSE ;\r\n}
