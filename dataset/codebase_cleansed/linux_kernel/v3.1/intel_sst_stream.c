int sst_check_device_type(u32 device, u32 num_chan, u32 *pcm_slot)\r\n{\r\nif (device >= MAX_NUM_STREAMS_MFLD) {\r\npr_debug("device type invalid %d\n", device);\r\nreturn -EINVAL;\r\n}\r\nif (sst_drv_ctx->streams[device].status == STREAM_UN_INIT) {\r\nif (device == SND_SST_DEVICE_VIBRA && num_chan == 1)\r\n*pcm_slot = 0x10;\r\nelse if (device == SND_SST_DEVICE_HAPTIC && num_chan == 1)\r\n*pcm_slot = 0x20;\r\nelse if (device == SND_SST_DEVICE_IHF && num_chan == 1)\r\n*pcm_slot = 0x04;\r\nelse if (device == SND_SST_DEVICE_IHF && num_chan == 2)\r\n*pcm_slot = 0x0C;\r\nelse if (device == SND_SST_DEVICE_HEADSET && num_chan == 1)\r\n*pcm_slot = 0x01;\r\nelse if (device == SND_SST_DEVICE_HEADSET && num_chan == 2)\r\n*pcm_slot = 0x03;\r\nelse if (device == SND_SST_DEVICE_CAPTURE && num_chan == 1)\r\n*pcm_slot = 0x01;\r\nelse if (device == SND_SST_DEVICE_CAPTURE && num_chan == 2)\r\n*pcm_slot = 0x03;\r\nelse if (device == SND_SST_DEVICE_CAPTURE && num_chan == 3)\r\n*pcm_slot = 0x07;\r\nelse if (device == SND_SST_DEVICE_CAPTURE && num_chan == 4)\r\n*pcm_slot = 0x0F;\r\nelse if (device == SND_SST_DEVICE_CAPTURE && num_chan > 4)\r\n*pcm_slot = 0x1F;\r\nelse {\r\npr_debug("No condition satisfied.. ret err\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\npr_debug("this stream state is not uni-init, is %d\n",\r\nsst_drv_ctx->streams[device].status);\r\nreturn -EBADRQC;\r\n}\r\npr_debug("returning slot %x\n", *pcm_slot);\r\nreturn 0;\r\n}\r\nstatic unsigned int get_mrst_stream_id(void)\r\n{\r\nint i;\r\nfor (i = 1; i <= MAX_NUM_STREAMS_MRST; i++) {\r\nif (sst_drv_ctx->streams[i].status == STREAM_UN_INIT)\r\nreturn i;\r\n}\r\npr_debug("Didn't find empty stream for mrst\n");\r\nreturn -EBUSY;\r\n}\r\nint sst_alloc_stream(char *params, unsigned int stream_ops,\r\nu8 codec, unsigned int device)\r\n{\r\nstruct ipc_post *msg = NULL;\r\nstruct snd_sst_alloc_params alloc_param;\r\nunsigned int pcm_slot = 0, num_ch;\r\nint str_id;\r\nstruct snd_sst_stream_params *sparams;\r\nstruct stream_info *str_info;\r\npr_debug("SST DBG:entering sst_alloc_stream\n");\r\npr_debug("SST DBG:%d %d %d\n", stream_ops, codec, device);\r\nBUG_ON(!params);\r\nsparams = (struct snd_sst_stream_params *)params;\r\nnum_ch = sparams->uc.pcm_params.num_chan;\r\nif (sst_drv_ctx->pci_id == SST_MFLD_PCI_ID) {\r\nif (sst_check_device_type(device, num_ch, &pcm_slot))\r\nreturn -EINVAL;\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\nstr_id = device;\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\npr_debug("SST_DBG: slot %x\n", pcm_slot);\r\n} else {\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\nstr_id = get_mrst_stream_id();\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\nif (str_id <= 0)\r\nreturn -EBUSY;\r\n}\r\nsst_init_stream(&sst_drv_ctx->streams[str_id], codec,\r\nstr_id, stream_ops, pcm_slot, device);\r\nif (sst_create_large_msg(&msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&msg->header, IPC_IA_ALLOC_STREAM, 1, str_id);\r\nmsg->header.part.data = sizeof(alloc_param) + sizeof(u32);\r\nalloc_param.str_type.codec_type = codec;\r\nalloc_param.str_type.str_type = SST_STREAM_TYPE_MUSIC;\r\nalloc_param.str_type.operation = stream_ops;\r\nalloc_param.str_type.protected_str = 0;\r\nalloc_param.str_type.time_slots = pcm_slot;\r\nalloc_param.str_type.result = alloc_param.str_type.reserved = 0;\r\nmemcpy(&alloc_param.stream_params, params,\r\nsizeof(struct snd_sst_stream_params));\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), &alloc_param,\r\nsizeof(alloc_param));\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nstr_info->ctrl_blk.condition = false;\r\nstr_info->ctrl_blk.ret_code = 0;\r\nstr_info->ctrl_blk.on = true;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\npr_debug("SST DBG:alloc stream done\n");\r\nreturn str_id;\r\n}\r\nint sst_alloc_stream_response(unsigned int str_id,\r\nstruct snd_sst_alloc_response *resp)\r\n{\r\nint retval = 0;\r\nstruct stream_info *str_info;\r\nstruct snd_sst_lib_download *lib_dnld;\r\npr_debug("SST DEBUG: stream number given = %d\n", str_id);\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (resp->str_type.result == SST_LIB_ERR_LIB_DNLD_REQUIRED) {\r\nlib_dnld = kzalloc(sizeof(*lib_dnld), GFP_KERNEL);\r\nmemcpy(lib_dnld, &resp->lib_dnld, sizeof(*lib_dnld));\r\n} else\r\nlib_dnld = NULL;\r\nif (str_info->ctrl_blk.on == true) {\r\nstr_info->ctrl_blk.on = false;\r\nstr_info->ctrl_blk.data = lib_dnld;\r\nstr_info->ctrl_blk.condition = true;\r\nstr_info->ctrl_blk.ret_code = resp->str_type.result;\r\npr_debug("SST DEBUG: sst_alloc_stream_response: waking up.\n");\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nreturn retval;\r\n}\r\nint sst_get_fw_info(struct snd_sst_fw_info *info)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\npr_debug("SST DBG:sst_get_fw_info called\n");\r\nif (sst_create_short_msg(&msg)) {\r\npr_err("SST ERR: message creation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_GET_FW_INFO, 0, 0);\r\nsst_drv_ctx->fw_info_blk.condition = false;\r\nsst_drv_ctx->fw_info_blk.ret_code = 0;\r\nsst_drv_ctx->fw_info_blk.on = true;\r\nsst_drv_ctx->fw_info_blk.data = info;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&sst_drv_ctx->fw_info_blk, SST_BLOCK_TIMEOUT);\r\nif (retval) {\r\npr_err("SST ERR: error in fw_info = %d\n", retval);\r\nretval = -EIO;\r\n}\r\nreturn retval;\r\n}\r\nint sst_start_stream(int str_id)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct stream_info *str_info;\r\npr_debug("sst_start_stream for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->status != STREAM_INIT)\r\nreturn -EBADRQC;\r\nif (sst_create_short_msg(&msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&msg->header, IPC_IA_START_STREAM, 0, str_id);\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nreturn retval;\r\n}\r\nint sst_pause_stream(int str_id)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct stream_info *str_info;\r\npr_debug("SST DBG:sst_pause_stream for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->status == STREAM_PAUSED)\r\nreturn 0;\r\nif (str_info->status == STREAM_RUNNING ||\r\nstr_info->status == STREAM_INIT) {\r\nif (str_info->prev == STREAM_UN_INIT)\r\nreturn -EBADRQC;\r\nif (str_info->ctrl_blk.on == true) {\r\npr_err("SST ERR: control path is in use\n");\r\nreturn -EINVAL;\r\n}\r\nif (sst_create_short_msg(&msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&msg->header, IPC_IA_PAUSE_STREAM, 0, str_id);\r\nstr_info->ctrl_blk.condition = false;\r\nstr_info->ctrl_blk.ret_code = 0;\r\nstr_info->ctrl_blk.on = true;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node,\r\n&sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&str_info->ctrl_blk, SST_BLOCK_TIMEOUT);\r\nif (retval == 0) {\r\nstr_info->prev = str_info->status;\r\nstr_info->status = STREAM_PAUSED;\r\n} else if (retval == SST_ERR_INVALID_STREAM_ID) {\r\nretval = -EINVAL;\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\nsst_clean_stream(str_info);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\n}\r\n} else {\r\nretval = -EBADRQC;\r\npr_err("SST ERR: BADQRC for stream\n");\r\n}\r\nreturn retval;\r\n}\r\nint sst_resume_stream(int str_id)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct stream_info *str_info;\r\npr_debug("SST DBG:sst_resume_stream for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->status == STREAM_RUNNING)\r\nreturn 0;\r\nif (str_info->status == STREAM_PAUSED) {\r\nif (str_info->ctrl_blk.on == true) {\r\npr_err("SST ERR: control path in use\n");\r\nreturn -EINVAL;\r\n}\r\nif (sst_create_short_msg(&msg)) {\r\npr_err("SST ERR: mem allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_RESUME_STREAM, 0, str_id);\r\nstr_info->ctrl_blk.condition = false;\r\nstr_info->ctrl_blk.ret_code = 0;\r\nstr_info->ctrl_blk.on = true;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node,\r\n&sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&str_info->ctrl_blk, SST_BLOCK_TIMEOUT);\r\nif (!retval) {\r\nif (str_info->prev == STREAM_RUNNING)\r\nstr_info->status = STREAM_RUNNING;\r\nelse\r\nstr_info->status = STREAM_INIT;\r\nstr_info->prev = STREAM_PAUSED;\r\n} else if (retval == -SST_ERR_INVALID_STREAM_ID) {\r\nretval = -EINVAL;\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\nsst_clean_stream(str_info);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\n}\r\n} else {\r\nretval = -EBADRQC;\r\npr_err("SST ERR: BADQRC for stream\n");\r\n}\r\nreturn retval;\r\n}\r\nint sst_drop_stream(int str_id)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct sst_stream_bufs *bufs = NULL, *_bufs;\r\nstruct stream_info *str_info;\r\npr_debug("SST DBG:sst_drop_stream for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->status != STREAM_UN_INIT &&\r\nstr_info->status != STREAM_DECODE) {\r\nif (str_info->ctrl_blk.on == true) {\r\npr_err("SST ERR: control path in use\n");\r\nreturn -EINVAL;\r\n}\r\nif (sst_create_short_msg(&msg)) {\r\npr_err("SST ERR: mem allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_DROP_STREAM, 0, str_id);\r\nstr_info->ctrl_blk.condition = false;\r\nstr_info->ctrl_blk.ret_code = 0;\r\nstr_info->ctrl_blk.on = true;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node,\r\n&sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&str_info->ctrl_blk, SST_BLOCK_TIMEOUT);\r\nif (!retval) {\r\npr_debug("SST DBG:drop success\n");\r\nstr_info->prev = STREAM_UN_INIT;\r\nstr_info->status = STREAM_INIT;\r\nif (str_info->src != MAD_DRV) {\r\nmutex_lock(&str_info->lock);\r\nlist_for_each_entry_safe(bufs, _bufs,\r\n&str_info->bufs, node) {\r\nlist_del(&bufs->node);\r\nkfree(bufs);\r\n}\r\nmutex_unlock(&str_info->lock);\r\n}\r\nstr_info->cumm_bytes += str_info->curr_bytes;\r\n} else if (retval == -SST_ERR_INVALID_STREAM_ID) {\r\nretval = -EINVAL;\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\nsst_clean_stream(str_info);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\n}\r\nif (str_info->data_blk.on == true) {\r\nstr_info->data_blk.condition = true;\r\nstr_info->data_blk.ret_code = retval;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\n} else {\r\nretval = -EBADRQC;\r\npr_err("SST ERR: BADQRC for stream\n");\r\n}\r\nreturn retval;\r\n}\r\nint sst_drain_stream(int str_id)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct stream_info *str_info;\r\npr_debug("SST DBG:sst_drain_stream for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->status != STREAM_RUNNING &&\r\nstr_info->status != STREAM_INIT &&\r\nstr_info->status != STREAM_PAUSED) {\r\npr_err("SST ERR: BADQRC for stream = %d\n",\r\nstr_info->status);\r\nreturn -EBADRQC;\r\n}\r\nif (str_info->status == STREAM_INIT) {\r\nif (sst_create_short_msg(&msg)) {\r\npr_err("SST ERR: mem allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_DRAIN_STREAM, 0, str_id);\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\n} else\r\nstr_info->need_draining = true;\r\nstr_info->data_blk.condition = false;\r\nstr_info->data_blk.ret_code = 0;\r\nstr_info->data_blk.on = true;\r\nretval = sst_wait_interruptible(sst_drv_ctx, &str_info->data_blk);\r\nstr_info->need_draining = false;\r\nreturn retval;\r\n}\r\nint sst_free_stream(int str_id)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct stream_info *str_info;\r\npr_debug("SST DBG:sst_free_stream for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->status != STREAM_UN_INIT) {\r\nif (sst_create_short_msg(&msg)) {\r\npr_err("SST ERR: mem allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_FREE_STREAM, 0, str_id);\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nstr_info->prev = str_info->status;\r\nstr_info->status = STREAM_UN_INIT;\r\nif (str_info->data_blk.on == true) {\r\nstr_info->data_blk.condition = true;\r\nstr_info->data_blk.ret_code = 0;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nstr_info->data_blk.on = true;\r\nstr_info->data_blk.condition = false;\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&str_info->ctrl_blk, SST_BLOCK_TIMEOUT);\r\npr_debug("wait for free returned %d\n", retval);\r\nmsleep(100);\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\nsst_clean_stream(str_info);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\npr_debug("SST DBG:Stream freed\n");\r\n} else {\r\nretval = -EBADRQC;\r\npr_debug("SST DBG:BADQRC for stream\n");\r\n}\r\nreturn retval;\r\n}
