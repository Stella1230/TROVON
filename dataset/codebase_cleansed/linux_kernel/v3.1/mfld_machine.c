static int headset_get_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = hs_switch;\r\nreturn 0;\r\n}\r\nstatic int headset_set_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0] == hs_switch)\r\nreturn 0;\r\nif (ucontrol->value.integer.value[0]) {\r\npr_debug("hs_set HS path\n");\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "Headphones");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "EPOUT");\r\n} else {\r\npr_debug("hs_set EP path\n");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "Headphones");\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "EPOUT");\r\n}\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nhs_switch = ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic void lo_enable_out_pins(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "IHFOUTL");\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "IHFOUTR");\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "LINEOUTL");\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "LINEOUTR");\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "VIB1OUT");\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "VIB2OUT");\r\nif (hs_switch) {\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "Headphones");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "EPOUT");\r\n} else {\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "Headphones");\r\nsnd_soc_dapm_enable_pin(&codec->dapm, "EPOUT");\r\n}\r\n}\r\nstatic int lo_get_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = lo_dac;\r\nreturn 0;\r\n}\r\nstatic int lo_set_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0] == lo_dac)\r\nreturn 0;\r\nlo_enable_out_pins(codec);\r\nswitch (ucontrol->value.integer.value[0]) {\r\ncase 0:\r\npr_debug("set vibra path\n");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "VIB1OUT");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "VIB2OUT");\r\nsnd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0);\r\nbreak;\r\ncase 1:\r\npr_debug("set hs path\n");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "Headphones");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "EPOUT");\r\nsnd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x22);\r\nbreak;\r\ncase 2:\r\npr_debug("set spkr path\n");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "IHFOUTL");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "IHFOUTR");\r\nsnd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x44);\r\nbreak;\r\ncase 3:\r\npr_debug("set null path\n");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "LINEOUTL");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "LINEOUTR");\r\nsnd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x66);\r\nbreak;\r\n}\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nlo_dac = ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic void mfld_jack_check(unsigned int intr_status)\r\n{\r\nstruct mfld_jack_data jack_data;\r\njack_data.mfld_jack = &mfld_jack;\r\njack_data.intr_id = intr_status;\r\nsn95031_jack_detection(&jack_data);\r\n}\r\nstatic int mfld_init(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nstruct snd_soc_codec *codec = runtime->codec;\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint ret_val;\r\nsnd_soc_dapm_new_controls(dapm, mfld_widgets, ARRAY_SIZE(mfld_widgets));\r\nsnd_soc_dapm_add_routes(dapm, mfld_map, ARRAY_SIZE(mfld_map));\r\nsnd_soc_dapm_enable_pin(dapm, "Headphones");\r\nsnd_soc_dapm_enable_pin(dapm, "Mic");\r\nsnd_soc_dapm_sync(dapm);\r\nret_val = snd_soc_add_controls(codec, mfld_snd_controls,\r\nARRAY_SIZE(mfld_snd_controls));\r\nif (ret_val) {\r\npr_err("soc_add_controls failed %d", ret_val);\r\nreturn ret_val;\r\n}\r\nsnd_soc_dapm_disable_pin(dapm, "Headphones");\r\nsnd_soc_dapm_disable_pin(dapm, "LINEOUTL");\r\nsnd_soc_dapm_disable_pin(dapm, "LINEOUTR");\r\nlo_dac = 3;\r\nhs_switch = 0;\r\nsnd_soc_dapm_disable_pin(dapm, "LINEINL");\r\nsnd_soc_dapm_disable_pin(dapm, "LINEINR");\r\nsnd_soc_dapm_sync(dapm);\r\nret_val = snd_soc_jack_new(codec, "Intel(R) MID Audio Jack",\r\nSND_JACK_HEADSET | SND_JACK_BTN_0 |\r\nSND_JACK_BTN_1, &mfld_jack);\r\nif (ret_val) {\r\npr_err("jack creation failed\n");\r\nreturn ret_val;\r\n}\r\nret_val = snd_soc_jack_add_pins(&mfld_jack,\r\nARRAY_SIZE(mfld_jack_pins), mfld_jack_pins);\r\nif (ret_val) {\r\npr_err("adding jack pins failed\n");\r\nreturn ret_val;\r\n}\r\nret_val = snd_soc_jack_add_zones(&mfld_jack,\r\nARRAY_SIZE(mfld_zones), mfld_zones);\r\nif (ret_val) {\r\npr_err("adding jack zones failed\n");\r\nreturn ret_val;\r\n}\r\nmfld_jack_check(MFLD_JACK_INSERT);\r\nreturn ret_val;\r\n}\r\nstatic irqreturn_t snd_mfld_jack_intr_handler(int irq, void *dev)\r\n{\r\nstruct mfld_mc_private *mc_private = (struct mfld_mc_private *) dev;\r\nmemcpy_fromio(&mc_private->interrupt_status,\r\n((void *)(mc_private->int_base)),\r\nsizeof(u8));\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t snd_mfld_jack_detection(int irq, void *data)\r\n{\r\nstruct mfld_mc_private *mc_drv_ctx = (struct mfld_mc_private *) data;\r\nif (mfld_jack.codec == NULL)\r\nreturn IRQ_HANDLED;\r\nmfld_jack_check(mc_drv_ctx->interrupt_status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit snd_mfld_mc_probe(struct platform_device *pdev)\r\n{\r\nint ret_val = 0, irq;\r\nstruct mfld_mc_private *mc_drv_ctx;\r\nstruct resource *irq_mem;\r\npr_debug("snd_mfld_mc_probe called\n");\r\nirq = platform_get_irq(pdev, 0);\r\nmc_drv_ctx = kzalloc(sizeof(*mc_drv_ctx), GFP_ATOMIC);\r\nif (!mc_drv_ctx) {\r\npr_err("allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nirq_mem = platform_get_resource_byname(\r\npdev, IORESOURCE_MEM, "IRQ_BASE");\r\nif (!irq_mem) {\r\npr_err("no mem resource given\n");\r\nret_val = -ENODEV;\r\ngoto unalloc;\r\n}\r\nmc_drv_ctx->int_base = ioremap_nocache(irq_mem->start,\r\nresource_size(irq_mem));\r\nif (!mc_drv_ctx->int_base) {\r\npr_err("Mapping of cache failed\n");\r\nret_val = -ENOMEM;\r\ngoto unalloc;\r\n}\r\nret_val = request_threaded_irq(irq, snd_mfld_jack_intr_handler,\r\nsnd_mfld_jack_detection,\r\nIRQF_SHARED, pdev->dev.driver->name, mc_drv_ctx);\r\nif (ret_val) {\r\npr_err("cannot register IRQ\n");\r\ngoto unalloc;\r\n}\r\nsnd_soc_card_mfld.dev = &pdev->dev;\r\nret_val = snd_soc_register_card(&snd_soc_card_mfld);\r\nif (ret_val) {\r\npr_debug("snd_soc_register_card failed %d\n", ret_val);\r\ngoto freeirq;\r\n}\r\nplatform_set_drvdata(pdev, mc_drv_ctx);\r\npr_debug("successfully exited probe\n");\r\nreturn ret_val;\r\nfreeirq:\r\nfree_irq(irq, mc_drv_ctx);\r\nunalloc:\r\nkfree(mc_drv_ctx);\r\nreturn ret_val;\r\n}\r\nstatic int __devexit snd_mfld_mc_remove(struct platform_device *pdev)\r\n{\r\nstruct mfld_mc_private *mc_drv_ctx = platform_get_drvdata(pdev);\r\npr_debug("snd_mfld_mc_remove called\n");\r\nfree_irq(platform_get_irq(pdev, 0), mc_drv_ctx);\r\nsnd_soc_unregister_card(&snd_soc_card_mfld);\r\nkfree(mc_drv_ctx);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init snd_mfld_driver_init(void)\r\n{\r\npr_debug("snd_mfld_driver_init called\n");\r\nreturn platform_driver_register(&snd_mfld_mc_driver);\r\n}\r\nstatic void __exit snd_mfld_driver_exit(void)\r\n{\r\npr_debug("snd_mfld_driver_exit called\n");\r\nplatform_driver_unregister(&snd_mfld_mc_driver);\r\n}
