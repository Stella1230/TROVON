static int adis16400_spi_read_burst(struct device *dev, u8 *rx)\r\n{\r\nstruct spi_message msg;\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nu32 old_speed_hz = st->us->max_speed_hz;\r\nint ret;\r\nstruct spi_transfer xfers[] = {\r\n{\r\n.tx_buf = st->tx,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n}, {\r\n.rx_buf = rx,\r\n.bits_per_word = 8,\r\n.len = 24,\r\n},\r\n};\r\nmutex_lock(&st->buf_lock);\r\nst->tx[0] = ADIS16400_READ_REG(ADIS16400_GLOB_CMD);\r\nst->tx[1] = 0;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfers[0], &msg);\r\nspi_message_add_tail(&xfers[1], &msg);\r\nst->us->max_speed_hz = min(ADIS16400_SPI_BURST, old_speed_hz);\r\nspi_setup(st->us);\r\nret = spi_sync(st->us, &msg);\r\nif (ret)\r\ndev_err(&st->us->dev, "problem when burst reading");\r\nst->us->max_speed_hz = old_speed_hz;\r\nspi_setup(st->us);\r\nmutex_unlock(&st->buf_lock);\r\nreturn ret;\r\n}\r\nstatic int adis16350_spi_read_all(struct device *dev, u8 *rx)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nstruct spi_message msg;\r\nint i, j = 0, ret;\r\nstruct spi_transfer *xfers;\r\nxfers = kzalloc(sizeof(*xfers)*indio_dev->ring->scan_count + 1,\r\nGFP_KERNEL);\r\nif (xfers == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(read_all_tx_array); i++)\r\nif (indio_dev->ring->scan_mask & (1 << i)) {\r\nxfers[j].tx_buf = &read_all_tx_array[i];\r\nxfers[j].bits_per_word = 16;\r\nxfers[j].len = 2;\r\nxfers[j + 1].rx_buf = rx + j*2;\r\nj++;\r\n}\r\nxfers[j].bits_per_word = 16;\r\nxfers[j].len = 2;\r\nspi_message_init(&msg);\r\nfor (j = 0; j < indio_dev->ring->scan_count + 1; j++)\r\nspi_message_add_tail(&xfers[j], &msg);\r\nret = spi_sync(st->us, &msg);\r\nkfree(xfers);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t adis16400_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->private_data;\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nstruct iio_ring_buffer *ring = indio_dev->ring;\r\nint i = 0, j, ret = 0;\r\ns16 *data;\r\nsize_t datasize = ring->access->get_bytes_per_datum(ring);\r\nunsigned long mask = ring->scan_mask;\r\ndata = kmalloc(datasize , GFP_KERNEL);\r\nif (data == NULL) {\r\ndev_err(&st->us->dev, "memory alloc failed in ring bh");\r\nreturn -ENOMEM;\r\n}\r\nif (ring->scan_count) {\r\nif (st->variant->flags & ADIS16400_NO_BURST) {\r\nret = adis16350_spi_read_all(&indio_dev->dev, st->rx);\r\nif (ret < 0)\r\ngoto err;\r\nfor (; i < ring->scan_count; i++)\r\ndata[i] = *(s16 *)(st->rx + i*2);\r\n} else {\r\nret = adis16400_spi_read_burst(&indio_dev->dev, st->rx);\r\nif (ret < 0)\r\ngoto err;\r\nfor (; i < indio_dev->ring->scan_count; i++) {\r\nj = __ffs(mask);\r\nmask &= ~(1 << j);\r\ndata[i] = be16_to_cpup(\r\n(__be16 *)&(st->rx[j*2]));\r\n}\r\n}\r\n}\r\nif (ring->scan_timestamp)\r\n*((s64 *)(data + ((i + 3)/4)*4)) = pf->timestamp;\r\nring->access->store_to(indio_dev->ring, (u8 *) data, pf->timestamp);\r\niio_trigger_notify_done(indio_dev->trig);\r\nkfree(data);\r\nreturn IRQ_HANDLED;\r\nerr:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nvoid adis16400_unconfigure_ring(struct iio_dev *indio_dev)\r\n{\r\niio_dealloc_pollfunc(indio_dev->pollfunc);\r\niio_sw_rb_free(indio_dev->ring);\r\n}\r\nint adis16400_configure_ring(struct iio_dev *indio_dev)\r\n{\r\nint ret = 0;\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nstruct iio_ring_buffer *ring;\r\nring = iio_sw_rb_allocate(indio_dev);\r\nif (!ring) {\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nindio_dev->ring = ring;\r\nring->access = &ring_sw_access_funcs;\r\nring->bpe = 2;\r\nring->scan_timestamp = true;\r\nring->setup_ops = &adis16400_ring_setup_ops;\r\nring->owner = THIS_MODULE;\r\nring->scan_mask = st->variant->default_scan_mask;\r\nring->scan_count = hweight_long(st->variant->default_scan_mask);\r\nindio_dev->pollfunc = iio_alloc_pollfunc(&iio_pollfunc_store_time,\r\n&adis16400_trigger_handler,\r\nIRQF_ONESHOT,\r\nindio_dev,\r\n"%s_consumer%d",\r\nindio_dev->name,\r\nindio_dev->id);\r\nif (indio_dev->pollfunc == NULL) {\r\nret = -ENOMEM;\r\ngoto error_iio_sw_rb_free;\r\n}\r\nindio_dev->modes |= INDIO_RING_TRIGGERED;\r\nreturn 0;\r\nerror_iio_sw_rb_free:\r\niio_sw_rb_free(indio_dev->ring);\r\nreturn ret;\r\n}
