static inline struct vpx3220 *to_vpx3220(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct vpx3220, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct vpx3220, hdl)->sd;\r\n}\r\nstatic inline int vpx3220_write(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct vpx3220 *decoder = i2c_get_clientdata(client);\r\ndecoder->reg[reg] = value;\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic inline int vpx3220_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int vpx3220_fp_status(struct v4l2_subdev *sd)\r\n{\r\nunsigned char status;\r\nunsigned int i;\r\nfor (i = 0; i < VPX_TIMEOUT_COUNT; i++) {\r\nstatus = vpx3220_read(sd, 0x29);\r\nif (!(status & 4))\r\nreturn 0;\r\nudelay(10);\r\nif (need_resched())\r\ncond_resched();\r\n}\r\nreturn -1;\r\n}\r\nstatic int vpx3220_fp_write(struct v4l2_subdev *sd, u8 fpaddr, u16 data)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (i2c_smbus_write_word_data(client, 0x27, swab16(fpaddr)) == -1) {\r\nv4l2_dbg(1, debug, sd, "%s: failed\n", __func__);\r\nreturn -1;\r\n}\r\nif (vpx3220_fp_status(sd) < 0)\r\nreturn -1;\r\nif (i2c_smbus_write_word_data(client, 0x28, swab16(data)) == -1) {\r\nv4l2_dbg(1, debug, sd, "%s: failed\n", __func__);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 vpx3220_fp_read(struct v4l2_subdev *sd, u16 fpaddr)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\ns16 data;\r\nif (i2c_smbus_write_word_data(client, 0x26, swab16(fpaddr)) == -1) {\r\nv4l2_dbg(1, debug, sd, "%s: failed\n", __func__);\r\nreturn -1;\r\n}\r\nif (vpx3220_fp_status(sd) < 0)\r\nreturn -1;\r\ndata = i2c_smbus_read_word_data(client, 0x28);\r\nif (data == -1) {\r\nv4l2_dbg(1, debug, sd, "%s: failed\n", __func__);\r\nreturn -1;\r\n}\r\nreturn swab16(data);\r\n}\r\nstatic int vpx3220_write_block(struct v4l2_subdev *sd, const u8 *data, unsigned int len)\r\n{\r\nu8 reg;\r\nint ret = -1;\r\nwhile (len >= 2) {\r\nreg = *data++;\r\nret = vpx3220_write(sd, reg, *data++);\r\nif (ret < 0)\r\nbreak;\r\nlen -= 2;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vpx3220_write_fp_block(struct v4l2_subdev *sd,\r\nconst u16 *data, unsigned int len)\r\n{\r\nu8 reg;\r\nint ret = 0;\r\nwhile (len > 1) {\r\nreg = *data++;\r\nret |= vpx3220_fp_write(sd, reg, *data++);\r\nlen -= 2;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vpx3220_init(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct vpx3220 *decoder = to_vpx3220(sd);\r\nvpx3220_write_block(sd, init_common, sizeof(init_common));\r\nvpx3220_write_fp_block(sd, init_fp, sizeof(init_fp) >> 1);\r\nif (decoder->norm & V4L2_STD_NTSC)\r\nvpx3220_write_fp_block(sd, init_ntsc, sizeof(init_ntsc) >> 1);\r\nelse if (decoder->norm & V4L2_STD_PAL)\r\nvpx3220_write_fp_block(sd, init_pal, sizeof(init_pal) >> 1);\r\nelse if (decoder->norm & V4L2_STD_SECAM)\r\nvpx3220_write_fp_block(sd, init_secam, sizeof(init_secam) >> 1);\r\nelse\r\nvpx3220_write_fp_block(sd, init_pal, sizeof(init_pal) >> 1);\r\nreturn 0;\r\n}\r\nstatic int vpx3220_status(struct v4l2_subdev *sd, u32 *pstatus, v4l2_std_id *pstd)\r\n{\r\nint res = V4L2_IN_ST_NO_SIGNAL, status;\r\nv4l2_std_id std = 0;\r\nstatus = vpx3220_fp_read(sd, 0x0f3);\r\nv4l2_dbg(1, debug, sd, "status: 0x%04x\n", status);\r\nif (status < 0)\r\nreturn status;\r\nif ((status & 0x20) == 0) {\r\nres = 0;\r\nswitch (status & 0x18) {\r\ncase 0x00:\r\ncase 0x10:\r\ncase 0x14:\r\ncase 0x18:\r\nstd = V4L2_STD_PAL;\r\nbreak;\r\ncase 0x08:\r\nstd = V4L2_STD_SECAM;\r\nbreak;\r\ncase 0x04:\r\ncase 0x0c:\r\ncase 0x1c:\r\nstd = V4L2_STD_NTSC;\r\nbreak;\r\n}\r\n}\r\nif (pstd)\r\n*pstd = std;\r\nif (pstatus)\r\n*pstatus = status;\r\nreturn 0;\r\n}\r\nstatic int vpx3220_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nv4l2_dbg(1, debug, sd, "querystd\n");\r\nreturn vpx3220_status(sd, NULL, std);\r\n}\r\nstatic int vpx3220_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nv4l2_dbg(1, debug, sd, "g_input_status\n");\r\nreturn vpx3220_status(sd, status, NULL);\r\n}\r\nstatic int vpx3220_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct vpx3220 *decoder = to_vpx3220(sd);\r\nint temp_input;\r\ntemp_input = vpx3220_fp_read(sd, 0xf2);\r\nv4l2_dbg(1, debug, sd, "s_std %llx\n", (unsigned long long)std);\r\nif (std & V4L2_STD_NTSC) {\r\nvpx3220_write_fp_block(sd, init_ntsc, sizeof(init_ntsc) >> 1);\r\nv4l2_dbg(1, debug, sd, "norm switched to NTSC\n");\r\n} else if (std & V4L2_STD_PAL) {\r\nvpx3220_write_fp_block(sd, init_pal, sizeof(init_pal) >> 1);\r\nv4l2_dbg(1, debug, sd, "norm switched to PAL\n");\r\n} else if (std & V4L2_STD_SECAM) {\r\nvpx3220_write_fp_block(sd, init_secam, sizeof(init_secam) >> 1);\r\nv4l2_dbg(1, debug, sd, "norm switched to SECAM\n");\r\n} else {\r\nreturn -EINVAL;\r\n}\r\ndecoder->norm = std;\r\nvpx3220_fp_write(sd, 0xf2, temp_input | 0x0010);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int vpx3220_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nint data;\r\nconst int input_vals[3][2] = {\r\n{0x0c, 0},\r\n{0x0d, 0},\r\n{0x0e, 1}\r\n};\r\nif (input > 2)\r\nreturn -EINVAL;\r\nv4l2_dbg(1, debug, sd, "input switched to %s\n", inputs[input]);\r\nvpx3220_write(sd, 0x33, input_vals[input][0]);\r\ndata = vpx3220_fp_read(sd, 0xf2) & ~(0x0020);\r\nif (data < 0)\r\nreturn data;\r\nvpx3220_fp_write(sd, 0xf2,\r\ndata | (input_vals[input][1] << 5) | 0x0010);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int vpx3220_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nv4l2_dbg(1, debug, sd, "s_stream %s\n", enable ? "on" : "off");\r\nvpx3220_write(sd, 0xf2, (enable ? 0x1b : 0x00));\r\nreturn 0;\r\n}\r\nstatic int vpx3220_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nvpx3220_write(sd, 0xe6, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_CONTRAST:\r\nvpx3220_write(sd, 0xe7, ctrl->val + 192);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\nvpx3220_fp_write(sd, 0xa0, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\nvpx3220_fp_write(sd, 0x1c, ctrl->val);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpx3220_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct vpx3220 *decoder = to_vpx3220(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, decoder->ident, 0);\r\n}\r\nstatic int vpx3220_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct vpx3220 *decoder;\r\nstruct v4l2_subdev *sd;\r\nconst char *name = NULL;\r\nu8 ver;\r\nu16 pn;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\ndecoder = kzalloc(sizeof(struct vpx3220), GFP_KERNEL);\r\nif (decoder == NULL)\r\nreturn -ENOMEM;\r\nsd = &decoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &vpx3220_ops);\r\ndecoder->norm = V4L2_STD_PAL;\r\ndecoder->input = 0;\r\ndecoder->enable = 1;\r\nv4l2_ctrl_handler_init(&decoder->hdl, 4);\r\nv4l2_ctrl_new_std(&decoder->hdl, &vpx3220_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(&decoder->hdl, &vpx3220_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 63, 1, 32);\r\nv4l2_ctrl_new_std(&decoder->hdl, &vpx3220_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 4095, 1, 2048);\r\nv4l2_ctrl_new_std(&decoder->hdl, &vpx3220_ctrl_ops,\r\nV4L2_CID_HUE, -512, 511, 1, 0);\r\nsd->ctrl_handler = &decoder->hdl;\r\nif (decoder->hdl.error) {\r\nint err = decoder->hdl.error;\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nkfree(decoder);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&decoder->hdl);\r\nver = i2c_smbus_read_byte_data(client, 0x00);\r\npn = (i2c_smbus_read_byte_data(client, 0x02) << 8) +\r\ni2c_smbus_read_byte_data(client, 0x01);\r\ndecoder->ident = V4L2_IDENT_VPX3220A;\r\nif (ver == 0xec) {\r\nswitch (pn) {\r\ncase 0x4680:\r\nname = "vpx3220a";\r\nbreak;\r\ncase 0x4260:\r\nname = "vpx3216b";\r\ndecoder->ident = V4L2_IDENT_VPX3216B;\r\nbreak;\r\ncase 0x4280:\r\nname = "vpx3214c";\r\ndecoder->ident = V4L2_IDENT_VPX3214C;\r\nbreak;\r\n}\r\n}\r\nif (name)\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", name,\r\nclient->addr << 1, client->adapter->name);\r\nelse\r\nv4l2_info(sd, "chip (%02x:%04x) found @ 0x%x (%s)\n",\r\nver, pn, client->addr << 1, client->adapter->name);\r\nvpx3220_write_block(sd, init_common, sizeof(init_common));\r\nvpx3220_write_fp_block(sd, init_fp, sizeof(init_fp) >> 1);\r\nvpx3220_write_fp_block(sd, init_pal, sizeof(init_pal) >> 1);\r\nreturn 0;\r\n}\r\nstatic int vpx3220_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct vpx3220 *decoder = to_vpx3220(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nkfree(decoder);\r\nreturn 0;\r\n}\r\nstatic __init int init_vpx3220(void)\r\n{\r\nreturn i2c_add_driver(&vpx3220_driver);\r\n}\r\nstatic __exit void exit_vpx3220(void)\r\n{\r\ni2c_del_driver(&vpx3220_driver);\r\n}
