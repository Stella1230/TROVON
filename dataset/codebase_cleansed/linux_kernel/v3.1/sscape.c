static inline struct soundscape *get_card_soundscape(struct snd_card *c)\r\n{\r\nreturn (struct soundscape *) (c->private_data);\r\n}\r\nstatic struct snd_dma_buffer *get_dmabuf(struct snd_dma_buffer *buf,\r\nunsigned long size)\r\n{\r\nif (buf) {\r\nif (snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\nsize, buf) < 0) {\r\nsnd_printk(KERN_ERR "sscape: Failed to allocate "\r\n"%lu bytes for DMA\n",\r\nsize);\r\nreturn NULL;\r\n}\r\n}\r\nreturn buf;\r\n}\r\nstatic void free_dmabuf(struct snd_dma_buffer *buf)\r\n{\r\nif (buf && buf->area)\r\nsnd_dma_free_pages(buf);\r\n}\r\nstatic inline void sscape_write_unsafe(unsigned io_base, enum GA_REG reg,\r\nunsigned char val)\r\n{\r\noutb(reg, ODIE_ADDR_IO(io_base));\r\noutb(val, ODIE_DATA_IO(io_base));\r\n}\r\nstatic void sscape_write(struct soundscape *s, enum GA_REG reg,\r\nunsigned char val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nsscape_write_unsafe(s->io_base, reg, val);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic inline unsigned char sscape_read_unsafe(unsigned io_base,\r\nenum GA_REG reg)\r\n{\r\noutb(reg, ODIE_ADDR_IO(io_base));\r\nreturn inb(ODIE_DATA_IO(io_base));\r\n}\r\nstatic inline void set_host_mode_unsafe(unsigned io_base)\r\n{\r\noutb(0x0, HOST_CTRL_IO(io_base));\r\n}\r\nstatic inline void set_midi_mode_unsafe(unsigned io_base)\r\n{\r\noutb(0x3, HOST_CTRL_IO(io_base));\r\n}\r\nstatic inline int host_read_unsafe(unsigned io_base)\r\n{\r\nint data = -1;\r\nif ((inb(HOST_CTRL_IO(io_base)) & RX_READY) != 0)\r\ndata = inb(HOST_DATA_IO(io_base));\r\nreturn data;\r\n}\r\nstatic int host_read_ctrl_unsafe(unsigned io_base, unsigned timeout)\r\n{\r\nint data;\r\nwhile (((data = host_read_unsafe(io_base)) < 0) && (timeout != 0)) {\r\nudelay(100);\r\n--timeout;\r\n}\r\nreturn data;\r\n}\r\nstatic inline int host_write_unsafe(unsigned io_base, unsigned char data)\r\n{\r\nif ((inb(HOST_CTRL_IO(io_base)) & TX_READY) != 0) {\r\noutb(data, HOST_DATA_IO(io_base));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int host_write_ctrl_unsafe(unsigned io_base, unsigned char data,\r\nunsigned timeout)\r\n{\r\nint err;\r\nwhile (!(err = host_write_unsafe(io_base, data)) && (timeout != 0)) {\r\nudelay(100);\r\n--timeout;\r\n}\r\nreturn err;\r\n}\r\nstatic inline int verify_mpu401(const struct snd_mpu401 *mpu)\r\n{\r\nreturn ((inb(MPU401C(mpu)) & 0xc0) == 0x80);\r\n}\r\nstatic inline void initialise_mpu401(const struct snd_mpu401 *mpu)\r\n{\r\noutb(0, MPU401D(mpu));\r\n}\r\nstatic void activate_ad1845_unsafe(unsigned io_base)\r\n{\r\nunsigned char val = sscape_read_unsafe(io_base, GA_HMCTL_REG);\r\nsscape_write_unsafe(io_base, GA_HMCTL_REG, (val & 0xcf) | 0x10);\r\nsscape_write_unsafe(io_base, GA_CDCFG_REG, 0x80);\r\n}\r\nstatic void soundscape_free(struct snd_card *c)\r\n{\r\nstruct soundscape *sscape = get_card_soundscape(c);\r\nrelease_and_free_resource(sscape->io_res);\r\nrelease_and_free_resource(sscape->wss_res);\r\nfree_dma(sscape->chip->dma1);\r\n}\r\nstatic void sscape_start_dma_unsafe(unsigned io_base, enum GA_REG reg)\r\n{\r\nsscape_write_unsafe(io_base, reg,\r\nsscape_read_unsafe(io_base, reg) | 0x01);\r\nsscape_write_unsafe(io_base, reg,\r\nsscape_read_unsafe(io_base, reg) & 0xfe);\r\n}\r\nstatic int sscape_wait_dma_unsafe(unsigned io_base, enum GA_REG reg,\r\nunsigned timeout)\r\n{\r\nwhile (!(sscape_read_unsafe(io_base, reg) & 0x01) && (timeout != 0)) {\r\nudelay(100);\r\n--timeout;\r\n}\r\nreturn sscape_read_unsafe(io_base, reg) & 0x01;\r\n}\r\nstatic int obp_startup_ack(struct soundscape *s, unsigned timeout)\r\n{\r\nunsigned long end_time = jiffies + msecs_to_jiffies(timeout);\r\ndo {\r\nunsigned long flags;\r\nint x;\r\nspin_lock_irqsave(&s->lock, flags);\r\nx = host_read_unsafe(s->io_base);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nif (x == 0xfe || x == 0xff)\r\nreturn 1;\r\nmsleep(10);\r\n} while (time_before(jiffies, end_time));\r\nreturn 0;\r\n}\r\nstatic int host_startup_ack(struct soundscape *s, unsigned timeout)\r\n{\r\nunsigned long end_time = jiffies + msecs_to_jiffies(timeout);\r\ndo {\r\nunsigned long flags;\r\nint x;\r\nspin_lock_irqsave(&s->lock, flags);\r\nx = host_read_unsafe(s->io_base);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nif (x == 0xfe)\r\nreturn 1;\r\nmsleep(10);\r\n} while (time_before(jiffies, end_time));\r\nreturn 0;\r\n}\r\nstatic int upload_dma_data(struct soundscape *s, const unsigned char *data,\r\nsize_t size)\r\n{\r\nunsigned long flags;\r\nstruct snd_dma_buffer dma;\r\nint ret;\r\nunsigned char val;\r\nif (!get_dmabuf(&dma, PAGE_ALIGN(32 * 1024)))\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&s->lock, flags);\r\nval = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\r\nsscape_write_unsafe(s->io_base, GA_HMCTL_REG, val & 0x3f);\r\nval = (s->chip->dma1 << 4) | DMA_8BIT;\r\nsscape_write_unsafe(s->io_base, GA_DMAA_REG, val);\r\nsscape_write_unsafe(s->io_base, GA_DMAB_REG, 0x20);\r\nval = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\r\nsscape_write_unsafe(s->io_base, GA_HMCTL_REG, val | 0x80);\r\nwhile (size != 0) {\r\nunsigned long len;\r\nlen = min(size, dma.bytes);\r\nmemcpy(dma.area, data, len);\r\ndata += len;\r\nsize -= len;\r\nsnd_dma_program(s->chip->dma1, dma.addr, len, DMA_MODE_WRITE);\r\nsscape_start_dma_unsafe(s->io_base, GA_DMAA_REG);\r\nif (!sscape_wait_dma_unsafe(s->io_base, GA_DMAA_REG, 5000)) {\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nsnd_printk(KERN_ERR\r\n"sscape: DMA upload has timed out\n");\r\nret = -EAGAIN;\r\ngoto _release_dma;\r\n}\r\n}\r\nset_host_mode_unsafe(s->io_base);\r\noutb(0x0, s->io_base);\r\nval = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\r\nsscape_write_unsafe(s->io_base, GA_HMCTL_REG, val | 0x40);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nret = 0;\r\nif (!obp_startup_ack(s, 5000)) {\r\nsnd_printk(KERN_ERR "sscape: No response "\r\n"from on-board processor after upload\n");\r\nret = -EAGAIN;\r\n} else if (!host_startup_ack(s, 5000)) {\r\nsnd_printk(KERN_ERR\r\n"sscape: SoundScape failed to initialise\n");\r\nret = -EAGAIN;\r\n}\r\n_release_dma:\r\nsscape_write(s, GA_DMAA_REG, (s->ic_type == IC_OPUS ? 0x40 : 0x70));\r\nfree_dmabuf(&dma);\r\nreturn ret;\r\n}\r\nstatic int sscape_upload_bootblock(struct snd_card *card)\r\n{\r\nstruct soundscape *sscape = get_card_soundscape(card);\r\nunsigned long flags;\r\nconst struct firmware *init_fw = NULL;\r\nint data = 0;\r\nint ret;\r\nret = request_firmware(&init_fw, "scope.cod", card->dev);\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR "sscape: Error loading scope.cod");\r\nreturn ret;\r\n}\r\nret = upload_dma_data(sscape, init_fw->data, init_fw->size);\r\nrelease_firmware(init_fw);\r\nspin_lock_irqsave(&sscape->lock, flags);\r\nif (ret == 0)\r\ndata = host_read_ctrl_unsafe(sscape->io_base, 100);\r\nif (data & 0x10)\r\nsscape_write_unsafe(sscape->io_base, GA_SMCFGA_REG, 0x2f);\r\nspin_unlock_irqrestore(&sscape->lock, flags);\r\ndata &= 0xf;\r\nif (ret == 0 && data > 7) {\r\nsnd_printk(KERN_ERR\r\n"sscape: timeout reading firmware version\n");\r\nret = -EAGAIN;\r\n}\r\nreturn (ret == 0) ? data : ret;\r\n}\r\nstatic int sscape_upload_microcode(struct snd_card *card, int version)\r\n{\r\nstruct soundscape *sscape = get_card_soundscape(card);\r\nconst struct firmware *init_fw = NULL;\r\nchar name[14];\r\nint err;\r\nsnprintf(name, sizeof(name), "sndscape.co%d", version);\r\nerr = request_firmware(&init_fw, name, card->dev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "sscape: Error loading sndscape.co%d",\r\nversion);\r\nreturn err;\r\n}\r\nerr = upload_dma_data(sscape, init_fw->data, init_fw->size);\r\nif (err == 0)\r\nsnd_printk(KERN_INFO "sscape: MIDI firmware loaded %d KBs\n",\r\ninit_fw->size >> 10);\r\nrelease_firmware(init_fw);\r\nreturn err;\r\n}\r\nstatic int sscape_midi_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 127;\r\nreturn 0;\r\n}\r\nstatic int sscape_midi_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uctl)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kctl);\r\nstruct snd_card *card = chip->card;\r\nregister struct soundscape *s = get_card_soundscape(card);\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nuctl->value.integer.value[0] = s->midi_vol;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sscape_midi_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uctl)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kctl);\r\nstruct snd_card *card = chip->card;\r\nstruct soundscape *s = get_card_soundscape(card);\r\nunsigned long flags;\r\nint change;\r\nunsigned char new_val;\r\nspin_lock_irqsave(&s->lock, flags);\r\nnew_val = uctl->value.integer.value[0] & 127;\r\nset_host_mode_unsafe(s->io_base);\r\nif (s->midi_vol == new_val) {\r\nchange = 0;\r\ngoto __skip_change;\r\n}\r\nchange = host_write_ctrl_unsafe(s->io_base, CMD_SET_MIDI_VOL, 100)\r\n&& host_write_ctrl_unsafe(s->io_base, new_val, 100)\r\n&& host_write_ctrl_unsafe(s->io_base, CMD_XXX_MIDI_VOL, 100)\r\n&& host_write_ctrl_unsafe(s->io_base, new_val, 100);\r\ns->midi_vol = new_val;\r\n__skip_change:\r\nset_midi_mode_unsafe(s->io_base);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn change;\r\n}\r\nstatic unsigned __devinit get_irq_config(int sscape_type, int irq)\r\n{\r\nstatic const int valid_irq[] = { 9, 5, 7, 10 };\r\nstatic const int old_irq[] = { 9, 7, 5, 15 };\r\nunsigned cfg;\r\nif (sscape_type == MEDIA_FX) {\r\nfor (cfg = 0; cfg < ARRAY_SIZE(old_irq); ++cfg)\r\nif (irq == old_irq[cfg])\r\nreturn cfg;\r\n} else {\r\nfor (cfg = 0; cfg < ARRAY_SIZE(valid_irq); ++cfg)\r\nif (irq == valid_irq[cfg])\r\nreturn cfg;\r\n}\r\nreturn INVALID_IRQ;\r\n}\r\nstatic int __devinit detect_sscape(struct soundscape *s, long wss_io)\r\n{\r\nunsigned long flags;\r\nunsigned d;\r\nint retval = 0;\r\nspin_lock_irqsave(&s->lock, flags);\r\nif ((inb(HOST_CTRL_IO(s->io_base)) & 0x78) != 0)\r\ngoto _done;\r\nd = inb(ODIE_ADDR_IO(s->io_base)) & 0xf0;\r\nif ((d & 0x80) != 0)\r\ngoto _done;\r\nif (d == 0)\r\ns->ic_type = IC_ODIE;\r\nelse if ((d & 0x60) != 0)\r\ns->ic_type = IC_OPUS;\r\nelse\r\ngoto _done;\r\noutb(0xfa, ODIE_ADDR_IO(s->io_base));\r\nif ((inb(ODIE_ADDR_IO(s->io_base)) & 0x9f) != 0x0a)\r\ngoto _done;\r\noutb(0xfe, ODIE_ADDR_IO(s->io_base));\r\nif ((inb(ODIE_ADDR_IO(s->io_base)) & 0x9f) != 0x0e)\r\ngoto _done;\r\noutb(0xfe, ODIE_ADDR_IO(s->io_base));\r\nd = inb(ODIE_DATA_IO(s->io_base));\r\nif (s->type != SSCAPE_VIVO && (d & 0x9f) != 0x0e)\r\ngoto _done;\r\nif (s->ic_type == IC_OPUS)\r\nactivate_ad1845_unsafe(s->io_base);\r\nif (s->type == SSCAPE_VIVO)\r\nwss_io += 4;\r\nd = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\r\nsscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);\r\nfor (d = 0; d < 500; d++) {\r\nif ((inb(wss_io) & 0x80) == 0)\r\nbreak;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nmsleep(1);\r\nspin_lock_irqsave(&s->lock, flags);\r\n}\r\nif ((inb(wss_io) & 0x80) != 0)\r\ngoto _done;\r\nif (inb(wss_io + 2) == 0xff)\r\ngoto _done;\r\nd = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;\r\nsscape_write_unsafe(s->io_base, GA_HMCTL_REG, d);\r\nif ((inb(wss_io) & 0x80) != 0)\r\ns->type = MEDIA_FX;\r\nd = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);\r\nsscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);\r\nfor (d = 0; d < 500; d++) {\r\nif ((inb(wss_io) & 0x80) == 0)\r\nbreak;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nmsleep(1);\r\nspin_lock_irqsave(&s->lock, flags);\r\n}\r\nretval = 1;\r\n_done:\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int mpu401_open(struct snd_mpu401 *mpu)\r\n{\r\nif (!verify_mpu401(mpu)) {\r\nsnd_printk(KERN_ERR "sscape: MIDI disabled, "\r\n"please load firmware\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit create_mpu401(struct snd_card *card, int devnum,\r\nunsigned long port, int irq)\r\n{\r\nstruct soundscape *sscape = get_card_soundscape(card);\r\nstruct snd_rawmidi *rawmidi;\r\nint err;\r\nerr = snd_mpu401_uart_new(card, devnum, MPU401_HW_MPU401, port,\r\nMPU401_INFO_INTEGRATED, irq, IRQF_DISABLED,\r\n&rawmidi);\r\nif (err == 0) {\r\nstruct snd_mpu401 *mpu = rawmidi->private_data;\r\nmpu->open_input = mpu401_open;\r\nmpu->open_output = mpu401_open;\r\nmpu->private_data = sscape;\r\ninitialise_mpu401(mpu);\r\n}\r\nreturn err;\r\n}\r\nstatic int __devinit create_ad1845(struct snd_card *card, unsigned port,\r\nint irq, int dma1, int dma2)\r\n{\r\nregister struct soundscape *sscape = get_card_soundscape(card);\r\nstruct snd_wss *chip;\r\nint err;\r\nint codec_type = WSS_HW_DETECT;\r\nswitch (sscape->type) {\r\ncase MEDIA_FX:\r\ncase SSCAPE:\r\nif (sscape->ic_type != IC_OPUS)\r\ncodec_type = WSS_HW_AD1848;\r\nbreak;\r\ncase SSCAPE_VIVO:\r\nport += 4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr = snd_wss_create(card, port, -1, irq, dma1, dma2,\r\ncodec_type, WSS_HWSHARE_DMA1, &chip);\r\nif (!err) {\r\nunsigned long flags;\r\nstruct snd_pcm *pcm;\r\nif (sscape->type != SSCAPE_VIVO) {\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_out(chip, AD1845_CLOCK, 0x20);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\n}\r\nerr = snd_wss_pcm(chip, 0, &pcm);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "sscape: No PCM device "\r\n"for AD1845 chip\n");\r\ngoto _error;\r\n}\r\nerr = snd_wss_mixer(chip);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "sscape: No mixer device "\r\n"for AD1845 chip\n");\r\ngoto _error;\r\n}\r\nif (chip->hardware != WSS_HW_AD1848) {\r\nerr = snd_wss_timer(chip, 0, NULL);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "sscape: No timer device "\r\n"for AD1845 chip\n");\r\ngoto _error;\r\n}\r\n}\r\nif (sscape->type != SSCAPE_VIVO) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&midi_mixer_ctl, chip));\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "sscape: Could not create "\r\n"MIDI mixer control\n");\r\ngoto _error;\r\n}\r\n}\r\nsscape->chip = chip;\r\n}\r\n_error:\r\nreturn err;\r\n}\r\nstatic int __devinit create_sscape(int dev, struct snd_card *card)\r\n{\r\nstruct soundscape *sscape = get_card_soundscape(card);\r\nunsigned dma_cfg;\r\nunsigned irq_cfg;\r\nunsigned mpu_irq_cfg;\r\nstruct resource *io_res;\r\nstruct resource *wss_res;\r\nunsigned long flags;\r\nint err;\r\nint val;\r\nconst char *name;\r\nio_res = request_region(port[dev], 8, "SoundScape");\r\nif (!io_res) {\r\nsnd_printk(KERN_ERR\r\n"sscape: can't grab port 0x%lx\n", port[dev]);\r\nreturn -EBUSY;\r\n}\r\nwss_res = NULL;\r\nif (sscape->type == SSCAPE_VIVO) {\r\nwss_res = request_region(wss_port[dev], 4, "SoundScape");\r\nif (!wss_res) {\r\nsnd_printk(KERN_ERR "sscape: can't grab port 0x%lx\n",\r\nwss_port[dev]);\r\nerr = -EBUSY;\r\ngoto _release_region;\r\n}\r\n}\r\nerr = request_dma(dma[dev], "SoundScape");\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "sscape: can't grab DMA %d\n", dma[dev]);\r\ngoto _release_region;\r\n}\r\nspin_lock_init(&sscape->lock);\r\nsscape->io_res = io_res;\r\nsscape->wss_res = wss_res;\r\nsscape->io_base = port[dev];\r\nif (!detect_sscape(sscape, wss_port[dev])) {\r\nprintk(KERN_ERR "sscape: hardware not detected at 0x%x\n",\r\nsscape->io_base);\r\nerr = -ENODEV;\r\ngoto _release_dma;\r\n}\r\nswitch (sscape->type) {\r\ncase MEDIA_FX:\r\nname = "MediaFX/SoundFX";\r\nbreak;\r\ncase SSCAPE:\r\nname = "Soundscape";\r\nbreak;\r\ncase SSCAPE_PNP:\r\nname = "Soundscape PnP";\r\nbreak;\r\ncase SSCAPE_VIVO:\r\nname = "Soundscape VIVO";\r\nbreak;\r\ndefault:\r\nname = "unknown Soundscape";\r\nbreak;\r\n}\r\nprintk(KERN_INFO "sscape: %s card detected at 0x%x, using IRQ %d, DMA %d\n",\r\nname, sscape->io_base, irq[dev], dma[dev]);\r\nirq_cfg = get_irq_config(sscape->type, irq[dev]);\r\nif (irq_cfg == INVALID_IRQ) {\r\nsnd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", irq[dev]);\r\nreturn -ENXIO;\r\n}\r\nmpu_irq_cfg = get_irq_config(sscape->type, mpu_irq[dev]);\r\nif (mpu_irq_cfg == INVALID_IRQ) {\r\nsnd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", mpu_irq[dev]);\r\nreturn -ENXIO;\r\n}\r\nspin_lock_irqsave(&sscape->lock, flags);\r\nsscape_write_unsafe(sscape->io_base, GA_SMCFGA_REG, 0x2e);\r\nsscape_write_unsafe(sscape->io_base, GA_SMCFGB_REG, 0x00);\r\nsscape_write_unsafe(sscape->io_base, GA_DMACFG_REG, 0x50);\r\ndma_cfg = (sscape->ic_type == IC_OPUS ? 0x40 : 0x70);\r\nsscape_write_unsafe(sscape->io_base, GA_DMAA_REG, dma_cfg);\r\nsscape_write_unsafe(sscape->io_base, GA_DMAB_REG, 0x20);\r\nmpu_irq_cfg |= mpu_irq_cfg << 2;\r\nval = sscape_read_unsafe(sscape->io_base, GA_HMCTL_REG) & 0xF7;\r\nif (joystick[dev])\r\nval |= 8;\r\nsscape_write_unsafe(sscape->io_base, GA_HMCTL_REG, val | 0x10);\r\nsscape_write_unsafe(sscape->io_base, GA_INTCFG_REG, 0xf0 | mpu_irq_cfg);\r\nsscape_write_unsafe(sscape->io_base,\r\nGA_CDCFG_REG, 0x09 | DMA_8BIT\r\n| (dma[dev] << 4) | (irq_cfg << 1));\r\nsscape_write_unsafe(sscape->io_base, GA_INTENA_REG, 0x80);\r\nspin_unlock_irqrestore(&sscape->lock, flags);\r\nerr = create_ad1845(card, wss_port[dev], irq[dev],\r\ndma[dev], dma2[dev]);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR\r\n"sscape: No AD1845 device at 0x%lx, IRQ %d\n",\r\nwss_port[dev], irq[dev]);\r\ngoto _release_dma;\r\n}\r\nstrcpy(card->driver, "SoundScape");\r\nstrcpy(card->shortname, name);\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s at 0x%lx, IRQ %d, DMA1 %d, DMA2 %d\n",\r\nname, sscape->chip->port, sscape->chip->irq,\r\nsscape->chip->dma1, sscape->chip->dma2);\r\n#define MIDI_DEVNUM 0\r\nif (sscape->type != SSCAPE_VIVO) {\r\nerr = sscape_upload_bootblock(card);\r\nif (err >= 0)\r\nerr = sscape_upload_microcode(card, err);\r\nif (err == 0) {\r\nerr = create_mpu401(card, MIDI_DEVNUM, port[dev],\r\nmpu_irq[dev]);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "sscape: Failed to create "\r\n"MPU-401 device at 0x%lx\n",\r\nport[dev]);\r\ngoto _release_dma;\r\n}\r\nspin_lock_irqsave(&sscape->lock, flags);\r\nsscape->midi_vol = 0;\r\nhost_write_ctrl_unsafe(sscape->io_base,\r\nCMD_SET_MIDI_VOL, 100);\r\nhost_write_ctrl_unsafe(sscape->io_base,\r\nsscape->midi_vol, 100);\r\nhost_write_ctrl_unsafe(sscape->io_base,\r\nCMD_XXX_MIDI_VOL, 100);\r\nhost_write_ctrl_unsafe(sscape->io_base,\r\nsscape->midi_vol, 100);\r\nhost_write_ctrl_unsafe(sscape->io_base,\r\nCMD_SET_EXTMIDI, 100);\r\nhost_write_ctrl_unsafe(sscape->io_base,\r\n0, 100);\r\nhost_write_ctrl_unsafe(sscape->io_base, CMD_ACK, 100);\r\nset_midi_mode_unsafe(sscape->io_base);\r\nspin_unlock_irqrestore(&sscape->lock, flags);\r\n}\r\n}\r\ncard->private_free = soundscape_free;\r\nreturn 0;\r\n_release_dma:\r\nfree_dma(dma[dev]);\r\n_release_region:\r\nrelease_and_free_resource(wss_res);\r\nrelease_and_free_resource(io_res);\r\nreturn err;\r\n}\r\nstatic int __devinit snd_sscape_match(struct device *pdev, unsigned int i)\r\n{\r\nif (port[i] == SNDRV_AUTO_PORT)\r\nreturn 0;\r\nif (irq[i] == SNDRV_AUTO_IRQ ||\r\nmpu_irq[i] == SNDRV_AUTO_IRQ ||\r\ndma[i] == SNDRV_AUTO_DMA) {\r\nprintk(KERN_INFO\r\n"sscape: insufficient parameters, "\r\n"need IO, IRQ, MPU-IRQ and DMA\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)\r\n{\r\nstruct snd_card *card;\r\nstruct soundscape *sscape;\r\nint ret;\r\nret = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct soundscape), &card);\r\nif (ret < 0)\r\nreturn ret;\r\nsscape = get_card_soundscape(card);\r\nsscape->type = SSCAPE;\r\ndma[dev] &= 0x03;\r\nsnd_card_set_dev(card, pdev);\r\nret = create_sscape(dev, card);\r\nif (ret < 0)\r\ngoto _release_card;\r\nret = snd_card_register(card);\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR "sscape: Failed to register sound card\n");\r\ngoto _release_card;\r\n}\r\ndev_set_drvdata(pdev, card);\r\nreturn 0;\r\n_release_card:\r\nsnd_card_free(card);\r\nreturn ret;\r\n}\r\nstatic int __devexit snd_sscape_remove(struct device *devptr, unsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\ndev_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic inline int __devinit get_next_autoindex(int i)\r\n{\r\nwhile (i < SNDRV_CARDS && port[i] != SNDRV_AUTO_PORT)\r\n++i;\r\nreturn i;\r\n}\r\nstatic int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstatic int idx = 0;\r\nstruct pnp_dev *dev;\r\nstruct snd_card *card;\r\nstruct soundscape *sscape;\r\nint ret;\r\nidx = get_next_autoindex(idx);\r\nif (idx >= SNDRV_CARDS)\r\nreturn -ENOSPC;\r\ndev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (!pnp_is_active(dev)) {\r\nif (pnp_activate_dev(dev) < 0) {\r\nsnd_printk(KERN_INFO "sscape: device is inactive\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nret = snd_card_create(index[idx], id[idx], THIS_MODULE,\r\nsizeof(struct soundscape), &card);\r\nif (ret < 0)\r\nreturn ret;\r\nsscape = get_card_soundscape(card);\r\nif (!strncmp("ENS4081", pid->id, 7))\r\nsscape->type = SSCAPE_VIVO;\r\nelse\r\nsscape->type = SSCAPE_PNP;\r\nport[idx] = pnp_port_start(dev, 0);\r\nirq[idx] = pnp_irq(dev, 0);\r\nmpu_irq[idx] = pnp_irq(dev, 1);\r\ndma[idx] = pnp_dma(dev, 0) & 0x03;\r\nif (sscape->type == SSCAPE_PNP) {\r\ndma2[idx] = dma[idx];\r\nwss_port[idx] = CODEC_IO(port[idx]);\r\n} else {\r\nwss_port[idx] = pnp_port_start(dev, 1);\r\ndma2[idx] = pnp_dma(dev, 1);\r\n}\r\nsnd_card_set_dev(card, &pcard->card->dev);\r\nret = create_sscape(idx, card);\r\nif (ret < 0)\r\ngoto _release_card;\r\nret = snd_card_register(card);\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR "sscape: Failed to register sound card\n");\r\ngoto _release_card;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\n++idx;\r\nreturn 0;\r\n_release_card:\r\nsnd_card_free(card);\r\nreturn ret;\r\n}\r\nstatic void __devexit sscape_pnp_remove(struct pnp_card_link * pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int __init sscape_init(void)\r\n{\r\nint err;\r\nerr = isa_register_driver(&snd_sscape_driver, SNDRV_CARDS);\r\n#ifdef CONFIG_PNP\r\nif (!err)\r\nisa_registered = 1;\r\nerr = pnp_register_card_driver(&sscape_pnpc_driver);\r\nif (!err)\r\npnp_registered = 1;\r\nif (isa_registered)\r\nerr = 0;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit sscape_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\npnp_unregister_card_driver(&sscape_pnpc_driver);\r\nif (isa_registered)\r\n#endif\r\nisa_unregister_driver(&snd_sscape_driver);\r\n}
