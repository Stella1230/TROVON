void printk_address(unsigned long address, int reliable)\r\n{\r\nprintk(" [<%p>] %s%pB\n", (void *) address,\r\nreliable ? "" : "? ", (void *) address);\r\n}\r\nstatic void\r\nprint_ftrace_graph_addr(unsigned long addr, void *data,\r\nconst struct stacktrace_ops *ops,\r\nstruct thread_info *tinfo, int *graph)\r\n{\r\nstruct task_struct *task = tinfo->task;\r\nunsigned long ret_addr;\r\nint index = task->curr_ret_stack;\r\nif (addr != (unsigned long)return_to_handler)\r\nreturn;\r\nif (!task->ret_stack || index < *graph)\r\nreturn;\r\nindex -= *graph;\r\nret_addr = task->ret_stack[index].ret;\r\nops->address(data, ret_addr, 1);\r\n(*graph)++;\r\n}\r\nstatic inline void\r\nprint_ftrace_graph_addr(unsigned long addr, void *data,\r\nconst struct stacktrace_ops *ops,\r\nstruct thread_info *tinfo, int *graph)\r\n{ }\r\nstatic inline int valid_stack_ptr(struct thread_info *tinfo,\r\nvoid *p, unsigned int size, void *end)\r\n{\r\nvoid *t = tinfo;\r\nif (end) {\r\nif (p < end && p >= (end-THREAD_SIZE))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nreturn p > t && p < t + THREAD_SIZE - size;\r\n}\r\nunsigned long\r\nprint_context_stack(struct thread_info *tinfo,\r\nunsigned long *stack, unsigned long bp,\r\nconst struct stacktrace_ops *ops, void *data,\r\nunsigned long *end, int *graph)\r\n{\r\nstruct stack_frame *frame = (struct stack_frame *)bp;\r\nwhile (valid_stack_ptr(tinfo, stack, sizeof(*stack), end)) {\r\nunsigned long addr;\r\naddr = *stack;\r\nif (__kernel_text_address(addr)) {\r\nif ((unsigned long) stack == bp + sizeof(long)) {\r\nops->address(data, addr, 1);\r\nframe = frame->next_frame;\r\nbp = (unsigned long) frame;\r\n} else {\r\nops->address(data, addr, 0);\r\n}\r\nprint_ftrace_graph_addr(addr, data, ops, tinfo, graph);\r\n}\r\nstack++;\r\n}\r\nreturn bp;\r\n}\r\nunsigned long\r\nprint_context_stack_bp(struct thread_info *tinfo,\r\nunsigned long *stack, unsigned long bp,\r\nconst struct stacktrace_ops *ops, void *data,\r\nunsigned long *end, int *graph)\r\n{\r\nstruct stack_frame *frame = (struct stack_frame *)bp;\r\nunsigned long *ret_addr = &frame->return_address;\r\nwhile (valid_stack_ptr(tinfo, ret_addr, sizeof(*ret_addr), end)) {\r\nunsigned long addr = *ret_addr;\r\nif (!__kernel_text_address(addr))\r\nbreak;\r\nops->address(data, addr, 1);\r\nframe = frame->next_frame;\r\nret_addr = &frame->return_address;\r\nprint_ftrace_graph_addr(addr, data, ops, tinfo, graph);\r\n}\r\nreturn (unsigned long)frame;\r\n}\r\nstatic int print_trace_stack(void *data, char *name)\r\n{\r\nprintk("%s <%s> ", (char *)data, name);\r\nreturn 0;\r\n}\r\nstatic void print_trace_address(void *data, unsigned long addr, int reliable)\r\n{\r\ntouch_nmi_watchdog();\r\nprintk(data);\r\nprintk_address(addr, reliable);\r\n}\r\nvoid\r\nshow_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,\r\nunsigned long *stack, unsigned long bp, char *log_lvl)\r\n{\r\nprintk("%sCall Trace:\n", log_lvl);\r\ndump_trace(task, regs, stack, bp, &print_trace_ops, log_lvl);\r\n}\r\nvoid show_trace(struct task_struct *task, struct pt_regs *regs,\r\nunsigned long *stack, unsigned long bp)\r\n{\r\nshow_trace_log_lvl(task, regs, stack, bp, "");\r\n}\r\nvoid show_stack(struct task_struct *task, unsigned long *sp)\r\n{\r\nshow_stack_log_lvl(task, NULL, sp, 0, "");\r\n}\r\nvoid dump_stack(void)\r\n{\r\nunsigned long bp;\r\nunsigned long stack;\r\nbp = stack_frame(current, NULL);\r\nprintk("Pid: %d, comm: %.20s %s %s %.*s\n",\r\ncurrent->pid, current->comm, print_tainted(),\r\ninit_utsname()->release,\r\n(int)strcspn(init_utsname()->version, " "),\r\ninit_utsname()->version);\r\nshow_trace(NULL, NULL, &stack, bp);\r\n}\r\nunsigned __kprobes long oops_begin(void)\r\n{\r\nint cpu;\r\nunsigned long flags;\r\noops_enter();\r\nraw_local_irq_save(flags);\r\ncpu = smp_processor_id();\r\nif (!arch_spin_trylock(&die_lock)) {\r\nif (cpu == die_owner)\r\n;\r\nelse\r\narch_spin_lock(&die_lock);\r\n}\r\ndie_nest_count++;\r\ndie_owner = cpu;\r\nconsole_verbose();\r\nbust_spinlocks(1);\r\nreturn flags;\r\n}\r\nvoid __kprobes oops_end(unsigned long flags, struct pt_regs *regs, int signr)\r\n{\r\nif (regs && kexec_should_crash(current))\r\ncrash_kexec(regs);\r\nbust_spinlocks(0);\r\ndie_owner = -1;\r\nadd_taint(TAINT_DIE);\r\ndie_nest_count--;\r\nif (!die_nest_count)\r\narch_spin_unlock(&die_lock);\r\nraw_local_irq_restore(flags);\r\noops_exit();\r\nif (!signr)\r\nreturn;\r\nif (in_interrupt())\r\npanic("Fatal exception in interrupt");\r\nif (panic_on_oops)\r\npanic("Fatal exception");\r\ndo_exit(signr);\r\n}\r\nint __kprobes __die(const char *str, struct pt_regs *regs, long err)\r\n{\r\n#ifdef CONFIG_X86_32\r\nunsigned short ss;\r\nunsigned long sp;\r\n#endif\r\nprintk(KERN_EMERG "%s: %04lx [#%d] ", str, err & 0xffff, ++die_counter);\r\n#ifdef CONFIG_PREEMPT\r\nprintk("PREEMPT ");\r\n#endif\r\n#ifdef CONFIG_SMP\r\nprintk("SMP ");\r\n#endif\r\n#ifdef CONFIG_DEBUG_PAGEALLOC\r\nprintk("DEBUG_PAGEALLOC");\r\n#endif\r\nprintk("\n");\r\nif (notify_die(DIE_OOPS, str, regs, err,\r\ncurrent->thread.trap_no, SIGSEGV) == NOTIFY_STOP)\r\nreturn 1;\r\nshow_registers(regs);\r\n#ifdef CONFIG_X86_32\r\nif (user_mode_vm(regs)) {\r\nsp = regs->sp;\r\nss = regs->ss & 0xffff;\r\n} else {\r\nsp = kernel_stack_pointer(regs);\r\nsavesegment(ss, ss);\r\n}\r\nprintk(KERN_EMERG "EIP: [<%08lx>] ", regs->ip);\r\nprint_symbol("%s", regs->ip);\r\nprintk(" SS:ESP %04x:%08lx\n", ss, sp);\r\n#else\r\nprintk(KERN_ALERT "RIP ");\r\nprintk_address(regs->ip, 1);\r\nprintk(" RSP <%016lx>\n", regs->sp);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid die(const char *str, struct pt_regs *regs, long err)\r\n{\r\nunsigned long flags = oops_begin();\r\nint sig = SIGSEGV;\r\nif (!user_mode_vm(regs))\r\nreport_bug(regs->ip, regs);\r\nif (__die(str, regs, err))\r\nsig = 0;\r\noops_end(flags, regs, sig);\r\n}\r\nstatic int __init kstack_setup(char *s)\r\n{\r\nif (!s)\r\nreturn -EINVAL;\r\nkstack_depth_to_print = simple_strtoul(s, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic int __init code_bytes_setup(char *s)\r\n{\r\ncode_bytes = simple_strtoul(s, NULL, 0);\r\nif (code_bytes > 8192)\r\ncode_bytes = 8192;\r\nreturn 1;\r\n}
