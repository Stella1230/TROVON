int drm_dma_setup(struct drm_device *dev)\r\n{\r\nint i;\r\ndev->dma = kzalloc(sizeof(*dev->dma), GFP_KERNEL);\r\nif (!dev->dma)\r\nreturn -ENOMEM;\r\nfor (i = 0; i <= DRM_MAX_ORDER; i++)\r\nmemset(&dev->dma->bufs[i], 0, sizeof(dev->dma->bufs[0]));\r\nreturn 0;\r\n}\r\nvoid drm_dma_takedown(struct drm_device *dev)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nint i, j;\r\nif (!dma)\r\nreturn;\r\nfor (i = 0; i <= DRM_MAX_ORDER; i++) {\r\nif (dma->bufs[i].seg_count) {\r\nDRM_DEBUG("order %d: buf_count = %d,"\r\n" seg_count = %d\n",\r\ni,\r\ndma->bufs[i].buf_count,\r\ndma->bufs[i].seg_count);\r\nfor (j = 0; j < dma->bufs[i].seg_count; j++) {\r\nif (dma->bufs[i].seglist[j]) {\r\ndrm_pci_free(dev, dma->bufs[i].seglist[j]);\r\n}\r\n}\r\nkfree(dma->bufs[i].seglist);\r\n}\r\nif (dma->bufs[i].buf_count) {\r\nfor (j = 0; j < dma->bufs[i].buf_count; j++) {\r\nkfree(dma->bufs[i].buflist[j].dev_private);\r\n}\r\nkfree(dma->bufs[i].buflist);\r\n}\r\n}\r\nkfree(dma->buflist);\r\nkfree(dma->pagelist);\r\nkfree(dev->dma);\r\ndev->dma = NULL;\r\n}\r\nvoid drm_free_buffer(struct drm_device *dev, struct drm_buf * buf)\r\n{\r\nif (!buf)\r\nreturn;\r\nbuf->waiting = 0;\r\nbuf->pending = 0;\r\nbuf->file_priv = NULL;\r\nbuf->used = 0;\r\nif (drm_core_check_feature(dev, DRIVER_DMA_QUEUE)\r\n&& waitqueue_active(&buf->dma_wait)) {\r\nwake_up_interruptible(&buf->dma_wait);\r\n}\r\n}\r\nvoid drm_core_reclaim_buffers(struct drm_device *dev,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nint i;\r\nif (!dma)\r\nreturn;\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nif (dma->buflist[i]->file_priv == file_priv) {\r\nswitch (dma->buflist[i]->list) {\r\ncase DRM_LIST_NONE:\r\ndrm_free_buffer(dev, dma->buflist[i]);\r\nbreak;\r\ncase DRM_LIST_WAIT:\r\ndma->buflist[i]->list = DRM_LIST_RECLAIM;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\n}
