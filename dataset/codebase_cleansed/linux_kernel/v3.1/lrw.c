static inline void setbit128_bbe(void *b, int bit)\r\n{\r\n__set_bit(bit ^ (0x80 -\r\n#ifdef __BIG_ENDIAN\r\nBITS_PER_LONG\r\n#else\r\nBITS_PER_BYTE\r\n#endif\r\n), b);\r\n}\r\nstatic int setkey(struct crypto_tfm *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct priv *ctx = crypto_tfm_ctx(parent);\r\nstruct crypto_cipher *child = ctx->child;\r\nint err, i;\r\nbe128 tmp = { 0 };\r\nint bsize = crypto_cipher_blocksize(child);\r\ncrypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nif ((err = crypto_cipher_setkey(child, key, keylen - bsize)))\r\nreturn err;\r\ncrypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (ctx->table)\r\ngf128mul_free_64k(ctx->table);\r\nctx->table = gf128mul_init_64k_bbe((be128 *)(key + keylen - bsize));\r\nif (!ctx->table)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 128; i++) {\r\nsetbit128_bbe(&tmp, i);\r\nctx->mulinc[i] = tmp;\r\ngf128mul_64k_bbe(&ctx->mulinc[i], ctx->table);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void inc(be128 *iv)\r\n{\r\nbe64_add_cpu(&iv->b, 1);\r\nif (!iv->b)\r\nbe64_add_cpu(&iv->a, 1);\r\n}\r\nstatic inline void lrw_round(struct sinfo *s, void *dst, const void *src)\r\n{\r\nbe128_xor(dst, &s->t, src);\r\ns->fn(s->tfm, dst, dst);\r\nbe128_xor(dst, dst, &s->t);\r\n}\r\nstatic inline int get_index128(be128 *block)\r\n{\r\nint x;\r\n__be32 *p = (__be32 *) block;\r\nfor (p += 3, x = 0; x < 128; p--, x += 32) {\r\nu32 val = be32_to_cpup(p);\r\nif (!~val)\r\ncontinue;\r\nreturn x + ffz(val);\r\n}\r\nreturn x;\r\n}\r\nstatic int crypt(struct blkcipher_desc *d,\r\nstruct blkcipher_walk *w, struct priv *ctx,\r\nvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *))\r\n{\r\nint err;\r\nunsigned int avail;\r\nconst int bs = crypto_cipher_blocksize(ctx->child);\r\nstruct sinfo s = {\r\n.tfm = crypto_cipher_tfm(ctx->child),\r\n.fn = fn\r\n};\r\nbe128 *iv;\r\nu8 *wsrc;\r\nu8 *wdst;\r\nerr = blkcipher_walk_virt(d, w);\r\nif (!(avail = w->nbytes))\r\nreturn err;\r\nwsrc = w->src.virt.addr;\r\nwdst = w->dst.virt.addr;\r\niv = (be128 *)w->iv;\r\ns.t = *iv;\r\ngf128mul_64k_bbe(&s.t, ctx->table);\r\ngoto first;\r\nfor (;;) {\r\ndo {\r\nbe128_xor(&s.t, &s.t, &ctx->mulinc[get_index128(iv)]);\r\ninc(iv);\r\nfirst:\r\nlrw_round(&s, wdst, wsrc);\r\nwsrc += bs;\r\nwdst += bs;\r\n} while ((avail -= bs) >= bs);\r\nerr = blkcipher_walk_done(d, w, avail);\r\nif (!(avail = w->nbytes))\r\nbreak;\r\nwsrc = w->src.virt.addr;\r\nwdst = w->dst.virt.addr;\r\n}\r\nreturn err;\r\n}\r\nstatic int encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct priv *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk w;\r\nblkcipher_walk_init(&w, dst, src, nbytes);\r\nreturn crypt(desc, &w, ctx,\r\ncrypto_cipher_alg(ctx->child)->cia_encrypt);\r\n}\r\nstatic int decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct priv *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk w;\r\nblkcipher_walk_init(&w, dst, src, nbytes);\r\nreturn crypt(desc, &w, ctx,\r\ncrypto_cipher_alg(ctx->child)->cia_decrypt);\r\n}\r\nstatic int init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_cipher *cipher;\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct priv *ctx = crypto_tfm_ctx(tfm);\r\nu32 *flags = &tfm->crt_flags;\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nif (crypto_cipher_blocksize(cipher) != 16) {\r\n*flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;\r\nreturn -EINVAL;\r\n}\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct priv *ctx = crypto_tfm_ctx(tfm);\r\nif (ctx->table)\r\ngf128mul_free_64k(ctx->table);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic struct crypto_instance *alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_BLKCIPHER);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nalg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn ERR_CAST(alg);\r\ninst = crypto_alloc_instance("lrw", alg);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = alg->cra_blocksize;\r\nif (alg->cra_alignmask < 7) inst->alg.cra_alignmask = 7;\r\nelse inst->alg.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.cra_type = &crypto_blkcipher_type;\r\nif (!(alg->cra_blocksize % 4))\r\ninst->alg.cra_alignmask |= 3;\r\ninst->alg.cra_blkcipher.ivsize = alg->cra_blocksize;\r\ninst->alg.cra_blkcipher.min_keysize =\r\nalg->cra_cipher.cia_min_keysize + alg->cra_blocksize;\r\ninst->alg.cra_blkcipher.max_keysize =\r\nalg->cra_cipher.cia_max_keysize + alg->cra_blocksize;\r\ninst->alg.cra_ctxsize = sizeof(struct priv);\r\ninst->alg.cra_init = init_tfm;\r\ninst->alg.cra_exit = exit_tfm;\r\ninst->alg.cra_blkcipher.setkey = setkey;\r\ninst->alg.cra_blkcipher.encrypt = encrypt;\r\ninst->alg.cra_blkcipher.decrypt = decrypt;\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn inst;\r\n}\r\nstatic void free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int __init crypto_module_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_tmpl);\r\n}\r\nstatic void __exit crypto_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_tmpl);\r\n}
