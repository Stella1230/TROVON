static inline u32 l2c_diag(u32 addr)\r\n{\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_ADDR, addr);\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_CMD, L2C_CMD_DIAG);\r\nwhile (!(mfdcr(dcrbase_l2c + DCRN_L2C0_SR) & L2C_SR_CC))\r\n;\r\nreturn mfdcr(dcrbase_l2c + DCRN_L2C0_DATA);\r\n}\r\nstatic irqreturn_t l2c_error_handler(int irq, void *dev)\r\n{\r\nu32 sr = mfdcr(dcrbase_l2c + DCRN_L2C0_SR);\r\nif (sr & L2C_SR_CPE) {\r\nu32 addr = l2c_diag(0x42000000);\r\nprintk(KERN_EMERG "L2C: Cache Parity Error, addr[16:26] = 0x%08x\n",\r\naddr);\r\n}\r\nif (sr & L2C_SR_TPE) {\r\nu32 addr = l2c_diag(0x82000000) >> 16;\r\nprintk(KERN_EMERG "L2C: Tag Parity Error, addr[16:26] = 0x%08x\n",\r\naddr);\r\n}\r\nif (sr & (L2C_SR_CPE | L2C_SR_TPE)){\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_ADDR, 0);\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_CMD, L2C_CMD_CCP | L2C_CMD_CTE);\r\n} else {\r\nprintk(KERN_EMERG "L2C: LRU error\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init ppc4xx_l2c_probe(void)\r\n{\r\nstruct device_node *np;\r\nu32 r;\r\nunsigned long flags;\r\nint irq;\r\nconst u32 *dcrreg;\r\nu32 dcrbase_isram;\r\nint len;\r\nconst u32 *prop;\r\nu32 l2_size;\r\nnp = of_find_compatible_node(NULL, NULL, "ibm,l2-cache");\r\nif (!np)\r\nreturn 0;\r\nprop = of_get_property(np, "cache-size", NULL);\r\nif (prop == NULL) {\r\nprintk(KERN_ERR "%s: Can't get cache-size!\n", np->full_name);\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nl2_size = prop[0];\r\ndcrreg = of_get_property(np, "dcr-reg", &len);\r\nif (!dcrreg || (len != 4 * sizeof(u32))) {\r\nprintk(KERN_ERR "%s: Can't get DCR register base !",\r\nnp->full_name);\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\ndcrbase_isram = dcrreg[0];\r\ndcrbase_l2c = dcrreg[2];\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq == NO_IRQ) {\r\nprintk(KERN_ERR "irq_of_parse_and_map failed\n");\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nif (request_irq(irq, l2c_error_handler, IRQF_DISABLED, "L2C", 0) < 0) {\r\nprintk(KERN_ERR "Cannot install L2C error handler"\r\n", cache is not enabled\n");\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nlocal_irq_save(flags);\r\nasm volatile ("sync" ::: "memory");\r\nmtdcr(dcrbase_isram + DCRN_SRAM0_DPC,\r\nmfdcr(dcrbase_isram + DCRN_SRAM0_DPC) & ~SRAM_DPC_ENABLE);\r\nmtdcr(dcrbase_isram + DCRN_SRAM0_SB0CR,\r\nmfdcr(dcrbase_isram + DCRN_SRAM0_SB0CR) & ~SRAM_SBCR_BU_MASK);\r\nmtdcr(dcrbase_isram + DCRN_SRAM0_SB1CR,\r\nmfdcr(dcrbase_isram + DCRN_SRAM0_SB1CR) & ~SRAM_SBCR_BU_MASK);\r\nmtdcr(dcrbase_isram + DCRN_SRAM0_SB2CR,\r\nmfdcr(dcrbase_isram + DCRN_SRAM0_SB2CR) & ~SRAM_SBCR_BU_MASK);\r\nmtdcr(dcrbase_isram + DCRN_SRAM0_SB3CR,\r\nmfdcr(dcrbase_isram + DCRN_SRAM0_SB3CR) & ~SRAM_SBCR_BU_MASK);\r\nr = mfdcr(dcrbase_l2c + DCRN_L2C0_CFG) &\r\n~(L2C_CFG_ICU | L2C_CFG_DCU | L2C_CFG_SS_MASK);\r\nr |= L2C_CFG_L2M | L2C_CFG_SS_256;\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_CFG, r);\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_ADDR, 0);\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_CMD, L2C_CMD_HCC);\r\nwhile (!(mfdcr(dcrbase_l2c + DCRN_L2C0_SR) & L2C_SR_CC))\r\n;\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_CMD, L2C_CMD_CCP | L2C_CMD_CTE);\r\nr = mfdcr(dcrbase_l2c + DCRN_L2C0_SNP0) &\r\n~(L2C_SNP_BA_MASK | L2C_SNP_SSR_MASK);\r\nr |= L2C_SNP_SSR_32G | L2C_SNP_ESR;\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_SNP0, r);\r\nr = mfdcr(dcrbase_l2c + DCRN_L2C0_SNP1) &\r\n~(L2C_SNP_BA_MASK | L2C_SNP_SSR_MASK);\r\nr |= 0x80000000 | L2C_SNP_SSR_32G | L2C_SNP_ESR;\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_SNP1, r);\r\nasm volatile ("sync" ::: "memory");\r\nr = mfdcr(dcrbase_l2c + DCRN_L2C0_CFG);\r\nr &= ~(L2C_CFG_DCW_MASK | L2C_CFG_PMUX_MASK | L2C_CFG_PMIM\r\n| L2C_CFG_TPEI | L2C_CFG_CPEI | L2C_CFG_NAM | L2C_CFG_NBRM);\r\nr |= L2C_CFG_ICU | L2C_CFG_DCU | L2C_CFG_TPC | L2C_CFG_CPC | L2C_CFG_FRAN\r\n| L2C_CFG_CPIM | L2C_CFG_TPIM | L2C_CFG_LIM | L2C_CFG_SMCM;\r\nif (of_device_is_compatible(np, "ibm,l2-cache-460ex") ||\r\nof_device_is_compatible(np, "ibm,l2-cache-460gt"))\r\nr |= L2C_CFG_RDBW;\r\nmtdcr(dcrbase_l2c + DCRN_L2C0_CFG, r);\r\nasm volatile ("sync; isync" ::: "memory");\r\nlocal_irq_restore(flags);\r\nprintk(KERN_INFO "%dk L2-cache enabled\n", l2_size >> 10);\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nvoid ppc4xx_reset_system(char *cmd)\r\n{\r\nstruct device_node *np;\r\nu32 reset_type = DBCR0_RST_SYSTEM;\r\nconst u32 *prop;\r\nnp = of_find_node_by_type(NULL, "cpu");\r\nif (np) {\r\nprop = of_get_property(np, "reset-type", NULL);\r\nif ((prop) && ((prop[0] >= 1) && (prop[0] <= 3)))\r\nreset_type = prop[0] << 28;\r\n}\r\nmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) | reset_type);\r\nwhile (1)\r\n;\r\n}
