static int __devinit snd_card_als100_pnp(int dev, struct snd_card_als100 *acard,\r\nstruct pnp_card_link *card,\r\nconst struct pnp_card_device_id *id)\r\n{\r\nstruct pnp_dev *pdev;\r\nint err;\r\nacard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);\r\nif (acard->dev == NULL)\r\nreturn -ENODEV;\r\nacard->devmpu = pnp_request_card_device(card, id->devs[1].id, acard->dev);\r\nacard->devopl = pnp_request_card_device(card, id->devs[2].id, acard->dev);\r\npdev = acard->dev;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR PFX "AUDIO pnp configure failure\n");\r\nreturn err;\r\n}\r\nport[dev] = pnp_port_start(pdev, 0);\r\nif (id->driver_data == SB_HW_DT019X)\r\ndma8[dev] = pnp_dma(pdev, 0);\r\nelse {\r\ndma8[dev] = pnp_dma(pdev, 1);\r\ndma16[dev] = pnp_dma(pdev, 0);\r\n}\r\nirq[dev] = pnp_irq(pdev, 0);\r\npdev = acard->devmpu;\r\nif (pdev != NULL) {\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0)\r\ngoto __mpu_error;\r\nmpu_port[dev] = pnp_port_start(pdev, 0);\r\nmpu_irq[dev] = pnp_irq(pdev, 0);\r\n} else {\r\n__mpu_error:\r\nif (pdev) {\r\npnp_release_card_device(pdev);\r\nsnd_printk(KERN_ERR PFX "MPU401 pnp configure failure, skipping\n");\r\n}\r\nacard->devmpu = NULL;\r\nmpu_port[dev] = -1;\r\n}\r\npdev = acard->devopl;\r\nif (pdev != NULL) {\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0)\r\ngoto __fm_error;\r\nfm_port[dev] = pnp_port_start(pdev, 0);\r\n} else {\r\n__fm_error:\r\nif (pdev) {\r\npnp_release_card_device(pdev);\r\nsnd_printk(KERN_ERR PFX "OPL3 pnp configure failure, skipping\n");\r\n}\r\nacard->devopl = NULL;\r\nfm_port[dev] = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_card_als100_probe(int dev,\r\nstruct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nint error;\r\nstruct snd_sb *chip;\r\nstruct snd_card *card;\r\nstruct snd_card_als100 *acard;\r\nstruct snd_opl3 *opl3;\r\nerror = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_card_als100), &card);\r\nif (error < 0)\r\nreturn error;\r\nacard = card->private_data;\r\nif ((error = snd_card_als100_pnp(dev, acard, pcard, pid))) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nsnd_card_set_dev(card, &pcard->card->dev);\r\nif (pid->driver_data == SB_HW_DT019X)\r\ndma16[dev] = -1;\r\nerror = snd_sbdsp_create(card, port[dev], irq[dev],\r\nsnd_sb16dsp_interrupt,\r\ndma8[dev], dma16[dev],\r\npid->driver_data,\r\n&chip);\r\nif (error < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nacard->chip = chip;\r\nif (pid->driver_data == SB_HW_DT019X) {\r\nstrcpy(card->driver, "DT-019X");\r\nstrcpy(card->shortname, "Diamond Tech. DT-019X");\r\nsprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",\r\ncard->shortname, chip->name, chip->port,\r\nirq[dev], dma8[dev]);\r\n} else {\r\nstrcpy(card->driver, "ALS100");\r\nstrcpy(card->shortname, "Avance Logic ALS100");\r\nsprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",\r\ncard->shortname, chip->name, chip->port,\r\nirq[dev], dma8[dev], dma16[dev]);\r\n}\r\nif ((error = snd_sb16dsp_pcm(chip, 0, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nif ((error = snd_sbmixer_new(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nif (mpu_port[dev] > 0 && mpu_port[dev] != SNDRV_AUTO_PORT) {\r\nint mpu_type = MPU401_HW_ALS100;\r\nif (mpu_irq[dev] == SNDRV_AUTO_IRQ)\r\nmpu_irq[dev] = -1;\r\nif (pid->driver_data == SB_HW_DT019X)\r\nmpu_type = MPU401_HW_MPU401;\r\nif (snd_mpu401_uart_new(card, 0,\r\nmpu_type,\r\nmpu_port[dev], 0,\r\nmpu_irq[dev],\r\nmpu_irq[dev] >= 0 ? IRQF_DISABLED : 0,\r\nNULL) < 0)\r\nsnd_printk(KERN_ERR PFX "no MPU-401 device at 0x%lx\n", mpu_port[dev]);\r\n}\r\nif (fm_port[dev] > 0 && fm_port[dev] != SNDRV_AUTO_PORT) {\r\nif (snd_opl3_create(card,\r\nfm_port[dev], fm_port[dev] + 2,\r\nOPL3_HW_AUTO, 0, &opl3) < 0) {\r\nsnd_printk(KERN_ERR PFX "no OPL device at 0x%lx-0x%lx\n",\r\nfm_port[dev], fm_port[dev] + 2);\r\n} else {\r\nif ((error = snd_opl3_timer_new(opl3, 0, 1)) < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nif ((error = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\n}\r\n}\r\nif ((error = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_als100_pnp_detect(struct pnp_card_link *card,\r\nconst struct pnp_card_device_id *id)\r\n{\r\nstatic int dev;\r\nint res;\r\nfor ( ; dev < SNDRV_CARDS; dev++) {\r\nif (!enable[dev])\r\ncontinue;\r\nres = snd_card_als100_probe(dev, card, id);\r\nif (res < 0)\r\nreturn res;\r\ndev++;\r\nals100_devices++;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void __devexit snd_als100_pnp_remove(struct pnp_card_link * pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int snd_als100_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)\r\n{\r\nstruct snd_card *card = pnp_get_card_drvdata(pcard);\r\nstruct snd_card_als100 *acard = card->private_data;\r\nstruct snd_sb *chip = acard->chip;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_sbmixer_suspend(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_als100_pnp_resume(struct pnp_card_link *pcard)\r\n{\r\nstruct snd_card *card = pnp_get_card_drvdata(pcard);\r\nstruct snd_card_als100 *acard = card->private_data;\r\nstruct snd_sb *chip = acard->chip;\r\nsnd_sbdsp_reset(chip);\r\nsnd_sbmixer_resume(chip);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_als100_init(void)\r\n{\r\nint err;\r\nerr = pnp_register_card_driver(&als100_pnpc_driver);\r\nif (err)\r\nreturn err;\r\nif (!als100_devices) {\r\npnp_unregister_card_driver(&als100_pnpc_driver);\r\n#ifdef MODULE\r\nsnd_printk(KERN_ERR "no Avance Logic based soundcards found\n");\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_card_als100_exit(void)\r\n{\r\npnp_unregister_card_driver(&als100_pnpc_driver);\r\n}
