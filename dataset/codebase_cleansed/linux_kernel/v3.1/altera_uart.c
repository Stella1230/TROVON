static u32 altera_uart_readl(struct uart_port *port, int reg)\r\n{\r\nreturn readl(port->membase + (reg << port->regshift));\r\n}\r\nstatic void altera_uart_writel(struct uart_port *port, u32 dat, int reg)\r\n{\r\nwritel(dat, port->membase + (reg << port->regshift));\r\n}\r\nstatic unsigned int altera_uart_tx_empty(struct uart_port *port)\r\n{\r\nreturn (altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\r\nALTERA_UART_STATUS_TMT_MSK) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int altera_uart_get_mctrl(struct uart_port *port)\r\n{\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\nunsigned int sigs;\r\nsigs = (altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\r\nALTERA_UART_STATUS_CTS_MSK) ? TIOCM_CTS : 0;\r\nsigs |= (pp->sigs & TIOCM_RTS);\r\nreturn sigs;\r\n}\r\nstatic void altera_uart_set_mctrl(struct uart_port *port, unsigned int sigs)\r\n{\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\npp->sigs = sigs;\r\nif (sigs & TIOCM_RTS)\r\npp->imr |= ALTERA_UART_CONTROL_RTS_MSK;\r\nelse\r\npp->imr &= ~ALTERA_UART_CONTROL_RTS_MSK;\r\naltera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);\r\n}\r\nstatic void altera_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\npp->imr |= ALTERA_UART_CONTROL_TRDY_MSK;\r\naltera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);\r\n}\r\nstatic void altera_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\npp->imr &= ~ALTERA_UART_CONTROL_TRDY_MSK;\r\naltera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);\r\n}\r\nstatic void altera_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\npp->imr &= ~ALTERA_UART_CONTROL_RRDY_MSK;\r\naltera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);\r\n}\r\nstatic void altera_uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (break_state == -1)\r\npp->imr |= ALTERA_UART_CONTROL_TRBK_MSK;\r\nelse\r\npp->imr &= ~ALTERA_UART_CONTROL_TRBK_MSK;\r\naltera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void altera_uart_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void altera_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int baud, baudclk;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 4000000);\r\nbaudclk = port->uartclk / baud;\r\nif (old)\r\ntty_termios_copy_hw(termios, old);\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\naltera_uart_writel(port, baudclk, ALTERA_UART_DIVISOR_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void altera_uart_rx_chars(struct altera_uart *pp)\r\n{\r\nstruct uart_port *port = &pp->port;\r\nunsigned char ch, flag;\r\nunsigned short status;\r\nwhile ((status = altera_uart_readl(port, ALTERA_UART_STATUS_REG)) &\r\nALTERA_UART_STATUS_RRDY_MSK) {\r\nch = altera_uart_readl(port, ALTERA_UART_RXDATA_REG);\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (status & ALTERA_UART_STATUS_E_MSK) {\r\naltera_uart_writel(port, status,\r\nALTERA_UART_STATUS_REG);\r\nif (status & ALTERA_UART_STATUS_BRK_MSK) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (status & ALTERA_UART_STATUS_PE_MSK) {\r\nport->icount.parity++;\r\n} else if (status & ALTERA_UART_STATUS_ROE_MSK) {\r\nport->icount.overrun++;\r\n} else if (status & ALTERA_UART_STATUS_FE_MSK) {\r\nport->icount.frame++;\r\n}\r\nstatus &= port->read_status_mask;\r\nif (status & ALTERA_UART_STATUS_BRK_MSK)\r\nflag = TTY_BREAK;\r\nelse if (status & ALTERA_UART_STATUS_PE_MSK)\r\nflag = TTY_PARITY;\r\nelse if (status & ALTERA_UART_STATUS_FE_MSK)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nuart_insert_char(port, status, ALTERA_UART_STATUS_ROE_MSK, ch,\r\nflag);\r\n}\r\ntty_flip_buffer_push(port->state->port.tty);\r\n}\r\nstatic void altera_uart_tx_chars(struct altera_uart *pp)\r\n{\r\nstruct uart_port *port = &pp->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\naltera_uart_writel(port, port->x_char, ALTERA_UART_TXDATA_REG);\r\nport->x_char = 0;\r\nport->icount.tx++;\r\nreturn;\r\n}\r\nwhile (altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\r\nALTERA_UART_STATUS_TRDY_MSK) {\r\nif (xmit->head == xmit->tail)\r\nbreak;\r\naltera_uart_writel(port, xmit->buf[xmit->tail],\r\nALTERA_UART_TXDATA_REG);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (xmit->head == xmit->tail) {\r\npp->imr &= ~ALTERA_UART_CONTROL_TRDY_MSK;\r\naltera_uart_writel(port, pp->imr, ALTERA_UART_CONTROL_REG);\r\n}\r\n}\r\nstatic irqreturn_t altera_uart_interrupt(int irq, void *data)\r\n{\r\nstruct uart_port *port = data;\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\nunsigned int isr;\r\nisr = altera_uart_readl(port, ALTERA_UART_STATUS_REG) & pp->imr;\r\nspin_lock(&port->lock);\r\nif (isr & ALTERA_UART_STATUS_RRDY_MSK)\r\naltera_uart_rx_chars(pp);\r\nif (isr & ALTERA_UART_STATUS_TRDY_MSK)\r\naltera_uart_tx_chars(pp);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_RETVAL(isr);\r\n}\r\nstatic void altera_uart_timer(unsigned long data)\r\n{\r\nstruct uart_port *port = (void *)data;\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\naltera_uart_interrupt(0, port);\r\nmod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));\r\n}\r\nstatic void altera_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nport->type = PORT_ALTERA_UART;\r\naltera_uart_writel(port, 0, ALTERA_UART_CONTROL_REG);\r\naltera_uart_writel(port, 0, ALTERA_UART_STATUS_REG);\r\n}\r\nstatic int altera_uart_startup(struct uart_port *port)\r\n{\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\nunsigned long flags;\r\nint ret;\r\nif (!port->irq) {\r\nsetup_timer(&pp->tmr, altera_uart_timer, (unsigned long)port);\r\nmod_timer(&pp->tmr, jiffies + uart_poll_timeout(port));\r\nreturn 0;\r\n}\r\nret = request_irq(port->irq, altera_uart_interrupt, IRQF_DISABLED,\r\nDRV_NAME, port);\r\nif (ret) {\r\npr_err(DRV_NAME ": unable to attach Altera UART %d "\r\n"interrupt vector=%d\n", port->line, port->irq);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&port->lock, flags);\r\npp->imr = ALTERA_UART_CONTROL_RRDY_MSK;\r\nwritel(pp->imr, port->membase + ALTERA_UART_CONTROL_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void altera_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct altera_uart *pp = container_of(port, struct altera_uart, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\npp->imr = 0;\r\nwritel(pp->imr, port->membase + ALTERA_UART_CONTROL_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (port->irq)\r\nfree_irq(port->irq, port);\r\nelse\r\ndel_timer_sync(&pp->tmr);\r\n}\r\nstatic const char *altera_uart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_ALTERA_UART) ? "Altera UART" : NULL;\r\n}\r\nstatic int altera_uart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void altera_uart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int altera_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif ((ser->type != PORT_UNKNOWN) && (ser->type != PORT_ALTERA_UART))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint __init early_altera_uart_setup(struct altera_uart_platform_uart *platp)\r\n{\r\nstruct uart_port *port;\r\nint i;\r\nfor (i = 0; i < CONFIG_SERIAL_ALTERA_UART_MAXPORTS && platp[i].mapbase; i++) {\r\nport = &altera_uart_ports[i].port;\r\nport->line = i;\r\nport->type = PORT_ALTERA_UART;\r\nport->mapbase = platp[i].mapbase;\r\nport->membase = ioremap(port->mapbase, ALTERA_UART_SIZE);\r\nport->iotype = SERIAL_IO_MEM;\r\nport->irq = platp[i].irq;\r\nport->uartclk = platp[i].uartclk;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->ops = &altera_uart_ops;\r\nport->private_data = platp;\r\n}\r\nreturn 0;\r\n}\r\nstatic void altera_uart_console_putc(struct uart_port *port, const char c)\r\n{\r\nwhile (!(altera_uart_readl(port, ALTERA_UART_STATUS_REG) &\r\nALTERA_UART_STATUS_TRDY_MSK))\r\ncpu_relax();\r\nwritel(c, port->membase + ALTERA_UART_TXDATA_REG);\r\n}\r\nstatic void altera_uart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &(altera_uart_ports + co->index)->port;\r\nfor (; count; count--, s++) {\r\naltera_uart_console_putc(port, *s);\r\nif (*s == '\n')\r\naltera_uart_console_putc(port, '\r');\r\n}\r\n}\r\nstatic int __init altera_uart_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = CONFIG_SERIAL_ALTERA_UART_BAUDRATE;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= CONFIG_SERIAL_ALTERA_UART_MAXPORTS)\r\nreturn -EINVAL;\r\nport = &altera_uart_ports[co->index].port;\r\nif (!port->membase)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init altera_uart_console_init(void)\r\n{\r\nregister_console(&altera_uart_console);\r\nreturn 0;\r\n}\r\nstatic int altera_uart_get_of_uartclk(struct platform_device *pdev,\r\nstruct uart_port *port)\r\n{\r\nint len;\r\nconst __be32 *clk;\r\nclk = of_get_property(pdev->dev.of_node, "clock-frequency", &len);\r\nif (!clk || len < sizeof(__be32))\r\nreturn -ENODEV;\r\nport->uartclk = be32_to_cpup(clk);\r\nreturn 0;\r\n}\r\nstatic int altera_uart_get_of_uartclk(struct platform_device *pdev,\r\nstruct uart_port *port)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit altera_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct altera_uart_platform_uart *platp = pdev->dev.platform_data;\r\nstruct uart_port *port;\r\nstruct resource *res_mem;\r\nstruct resource *res_irq;\r\nint i = pdev->id;\r\nint ret;\r\nif (i == -1) {\r\nfor (i = 0; i < CONFIG_SERIAL_ALTERA_UART_MAXPORTS; i++)\r\nif (altera_uart_ports[i].port.mapbase == 0)\r\nbreak;\r\n}\r\nif (i < 0 || i >= CONFIG_SERIAL_ALTERA_UART_MAXPORTS)\r\nreturn -EINVAL;\r\nport = &altera_uart_ports[i].port;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res_mem)\r\nport->mapbase = res_mem->start;\r\nelse if (platp->mapbase)\r\nport->mapbase = platp->mapbase;\r\nelse\r\nreturn -EINVAL;\r\nres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res_irq)\r\nport->irq = res_irq->start;\r\nelse if (platp->irq)\r\nport->irq = platp->irq;\r\nif (platp)\r\nport->uartclk = platp->uartclk;\r\nelse {\r\nret = altera_uart_get_of_uartclk(pdev, port);\r\nif (ret)\r\nreturn ret;\r\n}\r\nport->membase = ioremap(port->mapbase, ALTERA_UART_SIZE);\r\nif (!port->membase)\r\nreturn -ENOMEM;\r\nif (platp)\r\nport->regshift = platp->bus_shift;\r\nelse\r\nport->regshift = 0;\r\nport->line = i;\r\nport->type = PORT_ALTERA_UART;\r\nport->iotype = SERIAL_IO_MEM;\r\nport->ops = &altera_uart_ops;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\ndev_set_drvdata(&pdev->dev, port);\r\nuart_add_one_port(&altera_uart_driver, port);\r\nreturn 0;\r\n}\r\nstatic int __devexit altera_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = dev_get_drvdata(&pdev->dev);\r\nif (port) {\r\nuart_remove_one_port(&altera_uart_driver, port);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nport->mapbase = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init altera_uart_init(void)\r\n{\r\nint rc;\r\nrc = uart_register_driver(&altera_uart_driver);\r\nif (rc)\r\nreturn rc;\r\nrc = platform_driver_register(&altera_uart_platform_driver);\r\nif (rc) {\r\nuart_unregister_driver(&altera_uart_driver);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit altera_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&altera_uart_platform_driver);\r\nuart_unregister_driver(&altera_uart_driver);\r\n}
