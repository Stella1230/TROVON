static void uic_unmask_irq(struct irq_data *d)\r\n{\r\nstruct uic *uic = irq_data_get_irq_chip_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 er, sr;\r\nsr = 1 << (31-src);\r\nspin_lock_irqsave(&uic->lock, flags);\r\nif (irqd_is_level_type(d))\r\nmtdcr(uic->dcrbase + UIC_SR, sr);\r\ner = mfdcr(uic->dcrbase + UIC_ER);\r\ner |= sr;\r\nmtdcr(uic->dcrbase + UIC_ER, er);\r\nspin_unlock_irqrestore(&uic->lock, flags);\r\n}\r\nstatic void uic_mask_irq(struct irq_data *d)\r\n{\r\nstruct uic *uic = irq_data_get_irq_chip_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 er;\r\nspin_lock_irqsave(&uic->lock, flags);\r\ner = mfdcr(uic->dcrbase + UIC_ER);\r\ner &= ~(1 << (31 - src));\r\nmtdcr(uic->dcrbase + UIC_ER, er);\r\nspin_unlock_irqrestore(&uic->lock, flags);\r\n}\r\nstatic void uic_ack_irq(struct irq_data *d)\r\n{\r\nstruct uic *uic = irq_data_get_irq_chip_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nspin_lock_irqsave(&uic->lock, flags);\r\nmtdcr(uic->dcrbase + UIC_SR, 1 << (31-src));\r\nspin_unlock_irqrestore(&uic->lock, flags);\r\n}\r\nstatic void uic_mask_ack_irq(struct irq_data *d)\r\n{\r\nstruct uic *uic = irq_data_get_irq_chip_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 er, sr;\r\nsr = 1 << (31-src);\r\nspin_lock_irqsave(&uic->lock, flags);\r\ner = mfdcr(uic->dcrbase + UIC_ER);\r\ner &= ~sr;\r\nmtdcr(uic->dcrbase + UIC_ER, er);\r\nif (!irqd_is_level_type(d))\r\nmtdcr(uic->dcrbase + UIC_SR, sr);\r\nspin_unlock_irqrestore(&uic->lock, flags);\r\n}\r\nstatic int uic_set_irq_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct uic *uic = irq_data_get_irq_chip_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nint trigger, polarity;\r\nu32 tr, pr, mask;\r\nswitch (flow_type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_NONE:\r\nuic_mask_irq(d);\r\nreturn 0;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ntrigger = 1; polarity = 1;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ntrigger = 1; polarity = 0;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ntrigger = 0; polarity = 1;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ntrigger = 0; polarity = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask = ~(1 << (31 - src));\r\nspin_lock_irqsave(&uic->lock, flags);\r\ntr = mfdcr(uic->dcrbase + UIC_TR);\r\npr = mfdcr(uic->dcrbase + UIC_PR);\r\ntr = (tr & mask) | (trigger << (31-src));\r\npr = (pr & mask) | (polarity << (31-src));\r\nmtdcr(uic->dcrbase + UIC_PR, pr);\r\nmtdcr(uic->dcrbase + UIC_TR, tr);\r\nspin_unlock_irqrestore(&uic->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int uic_host_map(struct irq_host *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct uic *uic = h->host_data;\r\nirq_set_chip_data(virq, uic);\r\nirq_set_chip_and_handler(virq, &uic_irq_chip, handle_level_irq);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic int uic_host_xlate(struct irq_host *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_type)\r\n{\r\nBUG_ON(intsize != 2);\r\n*out_hwirq = intspec[0];\r\n*out_type = intspec[1];\r\nreturn 0;\r\n}\r\nvoid uic_irq_cascade(unsigned int virq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct irq_data *idata = irq_desc_get_irq_data(desc);\r\nstruct uic *uic = irq_get_handler_data(virq);\r\nu32 msr;\r\nint src;\r\nint subvirq;\r\nraw_spin_lock(&desc->lock);\r\nif (irqd_is_level_type(idata))\r\nchip->irq_mask(idata);\r\nelse\r\nchip->irq_mask_ack(idata);\r\nraw_spin_unlock(&desc->lock);\r\nmsr = mfdcr(uic->dcrbase + UIC_MSR);\r\nif (!msr)\r\ngoto uic_irq_ret;\r\nsrc = 32 - ffs(msr);\r\nsubvirq = irq_linear_revmap(uic->irqhost, src);\r\ngeneric_handle_irq(subvirq);\r\nuic_irq_ret:\r\nraw_spin_lock(&desc->lock);\r\nif (irqd_is_level_type(idata))\r\nchip->irq_ack(idata);\r\nif (!irqd_irq_disabled(idata) && chip->irq_unmask)\r\nchip->irq_unmask(idata);\r\nraw_spin_unlock(&desc->lock);\r\n}\r\nstatic struct uic * __init uic_init_one(struct device_node *node)\r\n{\r\nstruct uic *uic;\r\nconst u32 *indexp, *dcrreg;\r\nint len;\r\nBUG_ON(! of_device_is_compatible(node, "ibm,uic"));\r\nuic = kzalloc(sizeof(*uic), GFP_KERNEL);\r\nif (! uic)\r\nreturn NULL;\r\nspin_lock_init(&uic->lock);\r\nindexp = of_get_property(node, "cell-index", &len);\r\nif (!indexp || (len != sizeof(u32))) {\r\nprintk(KERN_ERR "uic: Device node %s has missing or invalid "\r\n"cell-index property\n", node->full_name);\r\nreturn NULL;\r\n}\r\nuic->index = *indexp;\r\ndcrreg = of_get_property(node, "dcr-reg", &len);\r\nif (!dcrreg || (len != 2*sizeof(u32))) {\r\nprintk(KERN_ERR "uic: Device node %s has missing or invalid "\r\n"dcr-reg property\n", node->full_name);\r\nreturn NULL;\r\n}\r\nuic->dcrbase = *dcrreg;\r\nuic->irqhost = irq_alloc_host(node, IRQ_HOST_MAP_LINEAR,\r\nNR_UIC_INTS, &uic_host_ops, -1);\r\nif (! uic->irqhost)\r\nreturn NULL;\r\nuic->irqhost->host_data = uic;\r\nmtdcr(uic->dcrbase + UIC_ER, 0);\r\nmtdcr(uic->dcrbase + UIC_CR, 0);\r\nmtdcr(uic->dcrbase + UIC_TR, 0);\r\nmtdcr(uic->dcrbase + UIC_SR, 0xffffffff);\r\nprintk ("UIC%d (%d IRQ sources) at DCR 0x%x\n", uic->index,\r\nNR_UIC_INTS, uic->dcrbase);\r\nreturn uic;\r\n}\r\nvoid __init uic_init_tree(void)\r\n{\r\nstruct device_node *np;\r\nstruct uic *uic;\r\nconst u32 *interrupts;\r\nfor_each_compatible_node(np, NULL, "ibm,uic") {\r\ninterrupts = of_get_property(np, "interrupts", NULL);\r\nif (!interrupts)\r\nbreak;\r\n}\r\nBUG_ON(!np);\r\nprimary_uic = uic_init_one(np);\r\nif (!primary_uic)\r\npanic("Unable to initialize primary UIC %s\n", np->full_name);\r\nirq_set_default_host(primary_uic->irqhost);\r\nof_node_put(np);\r\nfor_each_compatible_node(np, NULL, "ibm,uic") {\r\ninterrupts = of_get_property(np, "interrupts", NULL);\r\nif (interrupts) {\r\nint cascade_virq;\r\nuic = uic_init_one(np);\r\nif (! uic)\r\npanic("Unable to initialize a secondary UIC %s\n",\r\nnp->full_name);\r\ncascade_virq = irq_of_parse_and_map(np, 0);\r\nirq_set_handler_data(cascade_virq, uic);\r\nirq_set_chained_handler(cascade_virq, uic_irq_cascade);\r\n}\r\n}\r\n}\r\nunsigned int uic_get_irq(void)\r\n{\r\nu32 msr;\r\nint src;\r\nBUG_ON(! primary_uic);\r\nmsr = mfdcr(primary_uic->dcrbase + UIC_MSR);\r\nsrc = 32 - ffs(msr);\r\nreturn irq_linear_revmap(primary_uic->irqhost, src);\r\n}
