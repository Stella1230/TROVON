static void mpu401_write_port(struct snd_mpu401 *mpu, unsigned char data,\r\nunsigned long addr)\r\n{\r\noutb(data, addr);\r\n}\r\nstatic unsigned char mpu401_read_port(struct snd_mpu401 *mpu,\r\nunsigned long addr)\r\n{\r\nreturn inb(addr);\r\n}\r\nstatic void mpu401_write_mmio(struct snd_mpu401 *mpu, unsigned char data,\r\nunsigned long addr)\r\n{\r\nwriteb(data, (void __iomem *)addr);\r\n}\r\nstatic unsigned char mpu401_read_mmio(struct snd_mpu401 *mpu,\r\nunsigned long addr)\r\n{\r\nreturn readb((void __iomem *)addr);\r\n}\r\nstatic void snd_mpu401_uart_clear_rx(struct snd_mpu401 *mpu)\r\n{\r\nint timeout = 100000;\r\nfor (; timeout > 0 && snd_mpu401_input_avail(mpu); timeout--)\r\nmpu->read(mpu, MPU401D(mpu));\r\n#ifdef CONFIG_SND_DEBUG\r\nif (timeout <= 0)\r\nsnd_printk(KERN_ERR "cmd: clear rx timeout (status = 0x%x)\n",\r\nmpu->read(mpu, MPU401C(mpu)));\r\n#endif\r\n}\r\nstatic void uart_interrupt_tx(struct snd_mpu401 *mpu)\r\n{\r\nunsigned long flags;\r\nif (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode) &&\r\ntest_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode)) {\r\nspin_lock_irqsave(&mpu->output_lock, flags);\r\nsnd_mpu401_uart_output_write(mpu);\r\nspin_unlock_irqrestore(&mpu->output_lock, flags);\r\n}\r\n}\r\nstatic void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)\r\n{\r\nunsigned long flags;\r\nif (mpu->info_flags & MPU401_INFO_INPUT) {\r\nspin_lock_irqsave(&mpu->input_lock, flags);\r\nif (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))\r\nsnd_mpu401_uart_input_read(mpu);\r\nelse\r\nsnd_mpu401_uart_clear_rx(mpu);\r\nspin_unlock_irqrestore(&mpu->input_lock, flags);\r\n}\r\nif (! (mpu->info_flags & MPU401_INFO_TX_IRQ))\r\nuart_interrupt_tx(mpu);\r\n}\r\nirqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_mpu401 *mpu = dev_id;\r\nif (mpu == NULL)\r\nreturn IRQ_NONE;\r\n_snd_mpu401_uart_interrupt(mpu);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t snd_mpu401_uart_interrupt_tx(int irq, void *dev_id)\r\n{\r\nstruct snd_mpu401 *mpu = dev_id;\r\nif (mpu == NULL)\r\nreturn IRQ_NONE;\r\nuart_interrupt_tx(mpu);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void snd_mpu401_uart_timer(unsigned long data)\r\n{\r\nstruct snd_mpu401 *mpu = (struct snd_mpu401 *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mpu->timer_lock, flags);\r\nmpu->timer.expires = 1 + jiffies;\r\nadd_timer(&mpu->timer);\r\nspin_unlock_irqrestore(&mpu->timer_lock, flags);\r\nif (mpu->rmidi)\r\n_snd_mpu401_uart_interrupt(mpu);\r\n}\r\nstatic void snd_mpu401_uart_add_timer (struct snd_mpu401 *mpu, int input)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave (&mpu->timer_lock, flags);\r\nif (mpu->timer_invoked == 0) {\r\ninit_timer(&mpu->timer);\r\nmpu->timer.data = (unsigned long)mpu;\r\nmpu->timer.function = snd_mpu401_uart_timer;\r\nmpu->timer.expires = 1 + jiffies;\r\nadd_timer(&mpu->timer);\r\n}\r\nmpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER :\r\nMPU401_MODE_OUTPUT_TIMER;\r\nspin_unlock_irqrestore (&mpu->timer_lock, flags);\r\n}\r\nstatic void snd_mpu401_uart_remove_timer (struct snd_mpu401 *mpu, int input)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave (&mpu->timer_lock, flags);\r\nif (mpu->timer_invoked) {\r\nmpu->timer_invoked &= input ? ~MPU401_MODE_INPUT_TIMER :\r\n~MPU401_MODE_OUTPUT_TIMER;\r\nif (! mpu->timer_invoked)\r\ndel_timer(&mpu->timer);\r\n}\r\nspin_unlock_irqrestore (&mpu->timer_lock, flags);\r\n}\r\nstatic int snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd,\r\nint ack)\r\n{\r\nunsigned long flags;\r\nint timeout, ok;\r\nspin_lock_irqsave(&mpu->input_lock, flags);\r\nif (mpu->hardware != MPU401_HW_TRID4DWAVE) {\r\nmpu->write(mpu, 0x00, MPU401D(mpu));\r\n}\r\nif (mpu->hardware != MPU401_HW_SB) {\r\nfor (timeout = 1000; timeout > 0 &&\r\n!snd_mpu401_output_ready(mpu); timeout--)\r\nudelay(10);\r\n#ifdef CONFIG_SND_DEBUG\r\nif (!timeout)\r\nsnd_printk(KERN_ERR "cmd: tx timeout (status = 0x%x)\n",\r\nmpu->read(mpu, MPU401C(mpu)));\r\n#endif\r\n}\r\nmpu->write(mpu, cmd, MPU401C(mpu));\r\nif (ack && !(mpu->info_flags & MPU401_INFO_NO_ACK)) {\r\nok = 0;\r\ntimeout = 10000;\r\nwhile (!ok && timeout-- > 0) {\r\nif (snd_mpu401_input_avail(mpu)) {\r\nif (mpu->read(mpu, MPU401D(mpu)) == MPU401_ACK)\r\nok = 1;\r\n}\r\n}\r\nif (!ok && mpu->read(mpu, MPU401D(mpu)) == MPU401_ACK)\r\nok = 1;\r\n} else\r\nok = 1;\r\nspin_unlock_irqrestore(&mpu->input_lock, flags);\r\nif (!ok) {\r\nsnd_printk(KERN_ERR "cmd: 0x%x failed at 0x%lx "\r\n"(status = 0x%x, data = 0x%x)\n", cmd, mpu->port,\r\nmpu->read(mpu, MPU401C(mpu)),\r\nmpu->read(mpu, MPU401D(mpu)));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_mpu401_do_reset(struct snd_mpu401 *mpu)\r\n{\r\nif (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))\r\nreturn -EIO;\r\nif (snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 0))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_mpu401_uart_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_mpu401 *mpu;\r\nint err;\r\nmpu = substream->rmidi->private_data;\r\nif (mpu->open_input && (err = mpu->open_input(mpu)) < 0)\r\nreturn err;\r\nif (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode)) {\r\nif (snd_mpu401_do_reset(mpu) < 0)\r\ngoto error_out;\r\n}\r\nmpu->substream_input = substream;\r\nset_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);\r\nreturn 0;\r\nerror_out:\r\nif (mpu->open_input && mpu->close_input)\r\nmpu->close_input(mpu);\r\nreturn -EIO;\r\n}\r\nstatic int snd_mpu401_uart_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_mpu401 *mpu;\r\nint err;\r\nmpu = substream->rmidi->private_data;\r\nif (mpu->open_output && (err = mpu->open_output(mpu)) < 0)\r\nreturn err;\r\nif (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {\r\nif (snd_mpu401_do_reset(mpu) < 0)\r\ngoto error_out;\r\n}\r\nmpu->substream_output = substream;\r\nset_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);\r\nreturn 0;\r\nerror_out:\r\nif (mpu->open_output && mpu->close_output)\r\nmpu->close_output(mpu);\r\nreturn -EIO;\r\n}\r\nstatic int snd_mpu401_uart_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_mpu401 *mpu;\r\nint err = 0;\r\nmpu = substream->rmidi->private_data;\r\nclear_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);\r\nmpu->substream_input = NULL;\r\nif (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode))\r\nerr = snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);\r\nif (mpu->close_input)\r\nmpu->close_input(mpu);\r\nif (err)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int snd_mpu401_uart_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_mpu401 *mpu;\r\nint err = 0;\r\nmpu = substream->rmidi->private_data;\r\nclear_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);\r\nmpu->substream_output = NULL;\r\nif (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))\r\nerr = snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);\r\nif (mpu->close_output)\r\nmpu->close_output(mpu);\r\nif (err)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nunsigned long flags;\r\nstruct snd_mpu401 *mpu;\r\nint max = 64;\r\nmpu = substream->rmidi->private_data;\r\nif (up) {\r\nif (! test_and_set_bit(MPU401_MODE_BIT_INPUT_TRIGGER,\r\n&mpu->mode)) {\r\nwhile (max-- > 0)\r\nmpu->read(mpu, MPU401D(mpu));\r\nif (mpu->irq < 0)\r\nsnd_mpu401_uart_add_timer(mpu, 1);\r\n}\r\nspin_lock_irqsave(&mpu->input_lock, flags);\r\nsnd_mpu401_uart_input_read(mpu);\r\nspin_unlock_irqrestore(&mpu->input_lock, flags);\r\n} else {\r\nif (mpu->irq < 0)\r\nsnd_mpu401_uart_remove_timer(mpu, 1);\r\nclear_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode);\r\n}\r\n}\r\nstatic void snd_mpu401_uart_input_read(struct snd_mpu401 * mpu)\r\n{\r\nint max = 128;\r\nunsigned char byte;\r\nwhile (max-- > 0) {\r\nif (! snd_mpu401_input_avail(mpu))\r\nbreak;\r\nbyte = mpu->read(mpu, MPU401D(mpu));\r\nif (test_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode))\r\nsnd_rawmidi_receive(mpu->substream_input, &byte, 1);\r\n}\r\n}\r\nstatic void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu)\r\n{\r\nunsigned char byte;\r\nint max = 256;\r\ndo {\r\nif (snd_rawmidi_transmit_peek(mpu->substream_output,\r\n&byte, 1) == 1) {\r\nif (!snd_mpu401_output_ready(mpu) &&\r\n!snd_mpu401_output_ready(mpu))\r\nbreak;\r\nmpu->write(mpu, byte, MPU401D(mpu));\r\nsnd_rawmidi_transmit_ack(mpu->substream_output, 1);\r\n} else {\r\nsnd_mpu401_uart_remove_timer (mpu, 0);\r\nbreak;\r\n}\r\n} while (--max > 0);\r\n}\r\nstatic void\r\nsnd_mpu401_uart_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nunsigned long flags;\r\nstruct snd_mpu401 *mpu;\r\nmpu = substream->rmidi->private_data;\r\nif (up) {\r\nset_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);\r\nif (! (mpu->info_flags & MPU401_INFO_TX_IRQ))\r\nsnd_mpu401_uart_add_timer(mpu, 0);\r\nspin_lock_irqsave(&mpu->output_lock, flags);\r\nsnd_mpu401_uart_output_write(mpu);\r\nspin_unlock_irqrestore(&mpu->output_lock, flags);\r\n} else {\r\nif (! (mpu->info_flags & MPU401_INFO_TX_IRQ))\r\nsnd_mpu401_uart_remove_timer(mpu, 0);\r\nclear_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);\r\n}\r\n}\r\nstatic void snd_mpu401_uart_free(struct snd_rawmidi *rmidi)\r\n{\r\nstruct snd_mpu401 *mpu = rmidi->private_data;\r\nif (mpu->irq_flags && mpu->irq >= 0)\r\nfree_irq(mpu->irq, (void *) mpu);\r\nrelease_and_free_resource(mpu->res);\r\nkfree(mpu);\r\n}\r\nint snd_mpu401_uart_new(struct snd_card *card, int device,\r\nunsigned short hardware,\r\nunsigned long port,\r\nunsigned int info_flags,\r\nint irq, int irq_flags,\r\nstruct snd_rawmidi ** rrawmidi)\r\n{\r\nstruct snd_mpu401 *mpu;\r\nstruct snd_rawmidi *rmidi;\r\nint in_enable, out_enable;\r\nint err;\r\nif (rrawmidi)\r\n*rrawmidi = NULL;\r\nif (! (info_flags & (MPU401_INFO_INPUT | MPU401_INFO_OUTPUT)))\r\ninfo_flags |= MPU401_INFO_INPUT | MPU401_INFO_OUTPUT;\r\nin_enable = (info_flags & MPU401_INFO_INPUT) ? 1 : 0;\r\nout_enable = (info_flags & MPU401_INFO_OUTPUT) ? 1 : 0;\r\nif ((err = snd_rawmidi_new(card, "MPU-401U", device,\r\nout_enable, in_enable, &rmidi)) < 0)\r\nreturn err;\r\nmpu = kzalloc(sizeof(*mpu), GFP_KERNEL);\r\nif (mpu == NULL) {\r\nsnd_printk(KERN_ERR "mpu401_uart: cannot allocate\n");\r\nsnd_device_free(card, rmidi);\r\nreturn -ENOMEM;\r\n}\r\nrmidi->private_data = mpu;\r\nrmidi->private_free = snd_mpu401_uart_free;\r\nspin_lock_init(&mpu->input_lock);\r\nspin_lock_init(&mpu->output_lock);\r\nspin_lock_init(&mpu->timer_lock);\r\nmpu->hardware = hardware;\r\nif (! (info_flags & MPU401_INFO_INTEGRATED)) {\r\nint res_size = hardware == MPU401_HW_PC98II ? 4 : 2;\r\nmpu->res = request_region(port, res_size, "MPU401 UART");\r\nif (mpu->res == NULL) {\r\nsnd_printk(KERN_ERR "mpu401_uart: "\r\n"unable to grab port 0x%lx size %d\n",\r\nport, res_size);\r\nsnd_device_free(card, rmidi);\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (info_flags & MPU401_INFO_MMIO) {\r\nmpu->write = mpu401_write_mmio;\r\nmpu->read = mpu401_read_mmio;\r\n} else {\r\nmpu->write = mpu401_write_port;\r\nmpu->read = mpu401_read_port;\r\n}\r\nmpu->port = port;\r\nif (hardware == MPU401_HW_PC98II)\r\nmpu->cport = port + 2;\r\nelse\r\nmpu->cport = port + 1;\r\nif (irq >= 0 && irq_flags) {\r\nif (request_irq(irq, snd_mpu401_uart_interrupt, irq_flags,\r\n"MPU401 UART", (void *) mpu)) {\r\nsnd_printk(KERN_ERR "mpu401_uart: "\r\n"unable to grab IRQ %d\n", irq);\r\nsnd_device_free(card, rmidi);\r\nreturn -EBUSY;\r\n}\r\n}\r\nmpu->info_flags = info_flags;\r\nmpu->irq = irq;\r\nmpu->irq_flags = irq_flags;\r\nif (card->shortname[0])\r\nsnprintf(rmidi->name, sizeof(rmidi->name), "%s MIDI",\r\ncard->shortname);\r\nelse\r\nsprintf(rmidi->name, "MPU-401 MIDI %d-%d",card->number, device);\r\nif (out_enable) {\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\r\n&snd_mpu401_uart_output);\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;\r\n}\r\nif (in_enable) {\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\r\n&snd_mpu401_uart_input);\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;\r\nif (out_enable)\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;\r\n}\r\nmpu->rmidi = rmidi;\r\nif (rrawmidi)\r\n*rrawmidi = rmidi;\r\nreturn 0;\r\n}\r\nstatic int __init alsa_mpu401_uart_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_mpu401_uart_exit(void)\r\n{\r\n}
