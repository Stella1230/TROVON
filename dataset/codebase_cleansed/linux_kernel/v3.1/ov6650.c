static int ov6650_reg_read(struct i2c_client *client, u8 reg, u8 *val)\r\n{\r\nint ret;\r\nu8 data = reg;\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &data,\r\n};\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0)\r\ngoto err;\r\nmsg.flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0)\r\ngoto err;\r\n*val = data;\r\nreturn 0;\r\nerr:\r\ndev_err(&client->dev, "Failed reading register 0x%02x!\n", reg);\r\nreturn ret;\r\n}\r\nstatic int ov6650_reg_write(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint ret;\r\nunsigned char data[2] = { reg, val };\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = data,\r\n};\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nudelay(100);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed writing register 0x%02x!\n", reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov6650_reg_rmw(struct i2c_client *client, u8 reg, u8 set, u8 mask)\r\n{\r\nu8 val;\r\nint ret;\r\nret = ov6650_reg_read(client, reg, &val);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"[Read]-Modify-Write of register 0x%02x failed!\n",\r\nreg);\r\nreturn ret;\r\n}\r\nval &= ~mask;\r\nval |= set;\r\nret = ov6650_reg_write(client, reg, val);\r\nif (ret)\r\ndev_err(&client->dev,\r\n"Read-Modify-[Write] of register 0x%02x failed!\n",\r\nreg);\r\nreturn ret;\r\n}\r\nstatic struct ov6650 *to_ov6650(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct ov6650, subdev);\r\n}\r\nstatic int ov6650_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ov6650_set_bus_param(struct soc_camera_device *icd,\r\nunsigned long flags)\r\n{\r\nstruct soc_camera_link *icl = to_soc_camera_link(icd);\r\nstruct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));\r\nint ret;\r\nflags = soc_camera_apply_sensor_flags(icl, flags);\r\nif (flags & SOCAM_PCLK_SAMPLE_RISING)\r\nret = ov6650_reg_rmw(client, REG_COMJ, COMJ_PCLK_RISING, 0);\r\nelse\r\nret = ov6650_reg_rmw(client, REG_COMJ, 0, COMJ_PCLK_RISING);\r\nif (ret)\r\nreturn ret;\r\nif (flags & SOCAM_HSYNC_ACTIVE_LOW)\r\nret = ov6650_reg_rmw(client, REG_COMF, COMF_HREF_LOW, 0);\r\nelse\r\nret = ov6650_reg_rmw(client, REG_COMF, 0, COMF_HREF_LOW);\r\nif (ret)\r\nreturn ret;\r\nif (flags & SOCAM_VSYNC_ACTIVE_HIGH)\r\nret = ov6650_reg_rmw(client, REG_COMJ, COMJ_VSYNC_HIGH, 0);\r\nelse\r\nret = ov6650_reg_rmw(client, REG_COMJ, 0, COMJ_VSYNC_HIGH);\r\nreturn ret;\r\n}\r\nstatic unsigned long ov6650_query_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_link *icl = to_soc_camera_link(icd);\r\nunsigned long flags = SOCAM_MASTER |\r\nSOCAM_PCLK_SAMPLE_RISING | SOCAM_PCLK_SAMPLE_FALLING |\r\nSOCAM_HSYNC_ACTIVE_HIGH | SOCAM_HSYNC_ACTIVE_LOW |\r\nSOCAM_VSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\r\nSOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8;\r\nreturn soc_camera_apply_sensor_flags(icl, flags);\r\n}\r\nstatic int ov6650_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nuint8_t reg;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nctrl->value = priv->agc;\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nif (priv->agc) {\r\nret = ov6650_reg_read(client, REG_GAIN, &reg);\r\nctrl->value = reg;\r\n} else {\r\nctrl->value = priv->gain;\r\n}\r\nbreak;\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nctrl->value = priv->awb;\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nif (priv->awb) {\r\nret = ov6650_reg_read(client, REG_BLUE, &reg);\r\nctrl->value = reg;\r\n} else {\r\nctrl->value = priv->blue;\r\n}\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nif (priv->awb) {\r\nret = ov6650_reg_read(client, REG_RED, &reg);\r\nctrl->value = reg;\r\n} else {\r\nctrl->value = priv->red;\r\n}\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->value = priv->saturation;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->value = priv->hue;\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->value = priv->brightness;\r\nbreak;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nctrl->value = priv->aec;\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nif (priv->aec) {\r\nret = ov6650_reg_read(client, REG_AECH, &reg);\r\nctrl->value = reg;\r\n} else {\r\nctrl->value = priv->exposure;\r\n}\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nctrl->value = priv->gamma;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nctrl->value = priv->vflip;\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nctrl->value = priv->hflip;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov6650_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nret = ov6650_reg_rmw(client, REG_COMB,\r\nctrl->value ? COMB_AGC : 0, COMB_AGC);\r\nif (!ret)\r\npriv->agc = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nret = ov6650_reg_write(client, REG_GAIN, ctrl->value);\r\nif (!ret)\r\npriv->gain = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nret = ov6650_reg_rmw(client, REG_COMB,\r\nctrl->value ? COMB_AWB : 0, COMB_AWB);\r\nif (!ret)\r\npriv->awb = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nret = ov6650_reg_write(client, REG_BLUE, ctrl->value);\r\nif (!ret)\r\npriv->blue = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nret = ov6650_reg_write(client, REG_RED, ctrl->value);\r\nif (!ret)\r\npriv->red = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nret = ov6650_reg_rmw(client, REG_SAT, SET_SAT(ctrl->value),\r\nSAT_MASK);\r\nif (!ret)\r\npriv->saturation = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nret = ov6650_reg_rmw(client, REG_HUE, SET_HUE(ctrl->value),\r\nHUE_MASK);\r\nif (!ret)\r\npriv->hue = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\nret = ov6650_reg_write(client, REG_BRT, ctrl->value);\r\nif (!ret)\r\npriv->brightness = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nswitch (ctrl->value) {\r\ncase V4L2_EXPOSURE_AUTO:\r\nret = ov6650_reg_rmw(client, REG_COMB, COMB_AEC, 0);\r\nbreak;\r\ndefault:\r\nret = ov6650_reg_rmw(client, REG_COMB, 0, COMB_AEC);\r\nbreak;\r\n}\r\nif (!ret)\r\npriv->aec = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nret = ov6650_reg_write(client, REG_AECH, ctrl->value);\r\nif (!ret)\r\npriv->exposure = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nret = ov6650_reg_write(client, REG_GAM1, ctrl->value);\r\nif (!ret)\r\npriv->gamma = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nret = ov6650_reg_rmw(client, REG_COMB,\r\nctrl->value ? COMB_FLIP_V : 0, COMB_FLIP_V);\r\nif (!ret)\r\npriv->vflip = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nret = ov6650_reg_rmw(client, REG_COMB,\r\nctrl->value ? COMB_FLIP_H : 0, COMB_FLIP_H);\r\nif (!ret)\r\npriv->hflip = ctrl->value;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov6650_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nid->ident = V4L2_IDENT_OV6650;\r\nid->revision = 0;\r\nreturn 0;\r\n}\r\nstatic int ov6650_get_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nu8 val;\r\nif (reg->reg & ~0xff)\r\nreturn -EINVAL;\r\nreg->size = 1;\r\nret = ov6650_reg_read(client, reg->reg, &val);\r\nif (!ret)\r\nreg->val = (__u64)val;\r\nreturn ret;\r\n}\r\nstatic int ov6650_set_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg & ~0xff || reg->val & ~0xff)\r\nreturn -EINVAL;\r\nreturn ov6650_reg_write(client, reg->reg, reg->val);\r\n}\r\nstatic int ov6650_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->c = priv->rect;\r\nreturn 0;\r\n}\r\nstatic int ov6650_s_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nstruct v4l2_rect *rect = &a->c;\r\nint ret;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nrect->left = ALIGN(rect->left, 2);\r\nrect->width = ALIGN(rect->width, 2);\r\nrect->top = ALIGN(rect->top, 2);\r\nrect->height = ALIGN(rect->height, 2);\r\nsoc_camera_limit_side(&rect->left, &rect->width,\r\nDEF_HSTRT << 1, 2, W_CIF);\r\nsoc_camera_limit_side(&rect->top, &rect->height,\r\nDEF_VSTRT << 1, 2, H_CIF);\r\nret = ov6650_reg_write(client, REG_HSTRT, rect->left >> 1);\r\nif (!ret) {\r\npriv->rect.left = rect->left;\r\nret = ov6650_reg_write(client, REG_HSTOP,\r\n(rect->left + rect->width) >> 1);\r\n}\r\nif (!ret) {\r\npriv->rect.width = rect->width;\r\nret = ov6650_reg_write(client, REG_VSTRT, rect->top >> 1);\r\n}\r\nif (!ret) {\r\npriv->rect.top = rect->top;\r\nret = ov6650_reg_write(client, REG_VSTOP,\r\n(rect->top + rect->height) >> 1);\r\n}\r\nif (!ret)\r\npriv->rect.height = rect->height;\r\nreturn ret;\r\n}\r\nstatic int ov6650_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\na->bounds.left = DEF_HSTRT << 1;\r\na->bounds.top = DEF_VSTRT << 1;\r\na->bounds.width = W_CIF;\r\na->bounds.height = H_CIF;\r\na->defrect = a->bounds;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int ov6650_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nmf->width = priv->rect.width >> priv->half_scale;\r\nmf->height = priv->rect.height >> priv->half_scale;\r\nmf->code = priv->code;\r\nmf->colorspace = priv->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic bool is_unscaled_ok(int width, int height, struct v4l2_rect *rect)\r\n{\r\nreturn width > rect->width >> 1 || height > rect->height >> 1;\r\n}\r\nstatic u8 to_clkrc(struct v4l2_fract *timeperframe,\r\nunsigned long pclk_limit, unsigned long pclk_max)\r\n{\r\nunsigned long pclk;\r\nif (timeperframe->numerator && timeperframe->denominator)\r\npclk = pclk_max * timeperframe->denominator /\r\n(FRAME_RATE_MAX * timeperframe->numerator);\r\nelse\r\npclk = pclk_max;\r\nif (pclk_limit && pclk_limit < pclk)\r\npclk = pclk_limit;\r\nreturn (pclk_max - 1) / pclk;\r\n}\r\nstatic int ov6650_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_device *icd = client->dev.platform_data;\r\nstruct soc_camera_sense *sense = icd->sense;\r\nstruct ov6650 *priv = to_ov6650(client);\r\nbool half_scale = !is_unscaled_ok(mf->width, mf->height, &priv->rect);\r\nstruct v4l2_crop a = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\n.c = {\r\n.left = priv->rect.left + (priv->rect.width >> 1) -\r\n(mf->width >> (1 - half_scale)),\r\n.top = priv->rect.top + (priv->rect.height >> 1) -\r\n(mf->height >> (1 - half_scale)),\r\n.width = mf->width << half_scale,\r\n.height = mf->height << half_scale,\r\n},\r\n};\r\nenum v4l2_mbus_pixelcode code = mf->code;\r\nunsigned long mclk, pclk;\r\nu8 coma_set = 0, coma_mask = 0, coml_set, coml_mask, clkrc;\r\nint ret;\r\nswitch (code) {\r\ncase V4L2_MBUS_FMT_Y8_1X8:\r\ndev_dbg(&client->dev, "pixel format GREY8_1X8\n");\r\ncoma_mask |= COMA_RGB | COMA_WORD_SWAP | COMA_BYTE_SWAP;\r\ncoma_set |= COMA_BW;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\ndev_dbg(&client->dev, "pixel format YUYV8_2X8_LE\n");\r\ncoma_mask |= COMA_RGB | COMA_BW | COMA_BYTE_SWAP;\r\ncoma_set |= COMA_WORD_SWAP;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YVYU8_2X8:\r\ndev_dbg(&client->dev, "pixel format YVYU8_2X8_LE (untested)\n");\r\ncoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP |\r\nCOMA_BYTE_SWAP;\r\nbreak;\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ndev_dbg(&client->dev, "pixel format YUYV8_2X8_BE\n");\r\nif (half_scale) {\r\ncoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP;\r\ncoma_set |= COMA_BYTE_SWAP;\r\n} else {\r\ncoma_mask |= COMA_RGB | COMA_BW;\r\ncoma_set |= COMA_BYTE_SWAP | COMA_WORD_SWAP;\r\n}\r\nbreak;\r\ncase V4L2_MBUS_FMT_VYUY8_2X8:\r\ndev_dbg(&client->dev, "pixel format YVYU8_2X8_BE (untested)\n");\r\nif (half_scale) {\r\ncoma_mask |= COMA_RGB | COMA_BW;\r\ncoma_set |= COMA_BYTE_SWAP | COMA_WORD_SWAP;\r\n} else {\r\ncoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP;\r\ncoma_set |= COMA_BYTE_SWAP;\r\n}\r\nbreak;\r\ncase V4L2_MBUS_FMT_SBGGR8_1X8:\r\ndev_dbg(&client->dev, "pixel format SBGGR8_1X8 (untested)\n");\r\ncoma_mask |= COMA_BW | COMA_BYTE_SWAP | COMA_WORD_SWAP;\r\ncoma_set |= COMA_RAW_RGB | COMA_RGB;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Pixel format not handled: 0x%x\n", code);\r\nreturn -EINVAL;\r\n}\r\npriv->code = code;\r\nif (code == V4L2_MBUS_FMT_Y8_1X8 ||\r\ncode == V4L2_MBUS_FMT_SBGGR8_1X8) {\r\ncoml_mask = COML_ONE_CHANNEL;\r\ncoml_set = 0;\r\npriv->pclk_max = 4000000;\r\n} else {\r\ncoml_mask = 0;\r\ncoml_set = COML_ONE_CHANNEL;\r\npriv->pclk_max = 8000000;\r\n}\r\nif (code == V4L2_MBUS_FMT_SBGGR8_1X8)\r\npriv->colorspace = V4L2_COLORSPACE_SRGB;\r\nelse if (code != 0)\r\npriv->colorspace = V4L2_COLORSPACE_JPEG;\r\nif (half_scale) {\r\ndev_dbg(&client->dev, "max resolution: QCIF\n");\r\ncoma_set |= COMA_QCIF;\r\npriv->pclk_max /= 2;\r\n} else {\r\ndev_dbg(&client->dev, "max resolution: CIF\n");\r\ncoma_mask |= COMA_QCIF;\r\n}\r\npriv->half_scale = half_scale;\r\nif (sense) {\r\nif (sense->master_clock == 8000000) {\r\ndev_dbg(&client->dev, "8MHz input clock\n");\r\nclkrc = CLKRC_6MHz;\r\n} else if (sense->master_clock == 12000000) {\r\ndev_dbg(&client->dev, "12MHz input clock\n");\r\nclkrc = CLKRC_12MHz;\r\n} else if (sense->master_clock == 16000000) {\r\ndev_dbg(&client->dev, "16MHz input clock\n");\r\nclkrc = CLKRC_16MHz;\r\n} else if (sense->master_clock == 24000000) {\r\ndev_dbg(&client->dev, "24MHz input clock\n");\r\nclkrc = CLKRC_24MHz;\r\n} else {\r\ndev_err(&client->dev,\r\n"unspported input clock, check platform data\n");\r\nreturn -EINVAL;\r\n}\r\nmclk = sense->master_clock;\r\npriv->pclk_limit = sense->pixel_clock_max;\r\n} else {\r\nclkrc = CLKRC_24MHz;\r\nmclk = 24000000;\r\npriv->pclk_limit = 0;\r\ndev_dbg(&client->dev, "using default 24MHz input clock\n");\r\n}\r\nclkrc |= to_clkrc(&priv->tpf, priv->pclk_limit, priv->pclk_max);\r\npclk = priv->pclk_max / GET_CLKRC_DIV(clkrc);\r\ndev_dbg(&client->dev, "pixel clock divider: %ld.%ld\n",\r\nmclk / pclk, 10 * mclk % pclk / pclk);\r\nret = ov6650_s_crop(sd, &a);\r\nif (!ret)\r\nret = ov6650_reg_rmw(client, REG_COMA, coma_set, coma_mask);\r\nif (!ret)\r\nret = ov6650_reg_write(client, REG_CLKRC, clkrc);\r\nif (!ret)\r\nret = ov6650_reg_rmw(client, REG_COML, coml_set, coml_mask);\r\nif (!ret) {\r\nmf->colorspace = priv->colorspace;\r\nmf->width = priv->rect.width >> half_scale;\r\nmf->height = priv->rect.height >> half_scale;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov6650_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nif (is_unscaled_ok(mf->width, mf->height, &priv->rect))\r\nv4l_bound_align_image(&mf->width, 2, W_CIF, 1,\r\n&mf->height, 2, H_CIF, 1, 0);\r\nmf->field = V4L2_FIELD_NONE;\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_Y10_1X10:\r\nmf->code = V4L2_MBUS_FMT_Y8_1X8;\r\ncase V4L2_MBUS_FMT_Y8_1X8:\r\ncase V4L2_MBUS_FMT_YVYU8_2X8:\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\ncase V4L2_MBUS_FMT_VYUY8_2X8:\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nbreak;\r\ndefault:\r\nmf->code = V4L2_MBUS_FMT_SBGGR8_1X8;\r\ncase V4L2_MBUS_FMT_SBGGR8_1X8:\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov6650_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(ov6650_codes))\r\nreturn -EINVAL;\r\n*code = ov6650_codes[index];\r\nreturn 0;\r\n}\r\nstatic int ov6650_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemset(cp, 0, sizeof(*cp));\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = GET_CLKRC_DIV(to_clkrc(&priv->tpf,\r\npriv->pclk_limit, priv->pclk_max));\r\ncp->timeperframe.denominator = FRAME_RATE_MAX;\r\ndev_dbg(&client->dev, "Frame interval: %u/%u s\n",\r\ncp->timeperframe.numerator, cp->timeperframe.denominator);\r\nreturn 0;\r\n}\r\nstatic int ov6650_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nstruct v4l2_fract *tpf = &cp->timeperframe;\r\nint div, ret;\r\nu8 clkrc;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cp->extendedmode != 0)\r\nreturn -EINVAL;\r\nif (tpf->numerator == 0 || tpf->denominator == 0)\r\ndiv = 1;\r\nelse\r\ndiv = (tpf->numerator * FRAME_RATE_MAX) / tpf->denominator;\r\nif (div == 0)\r\ndiv = 1;\r\nelse if (div > GET_CLKRC_DIV(CLKRC_DIV_MASK))\r\ndiv = GET_CLKRC_DIV(CLKRC_DIV_MASK);\r\npriv->tpf.numerator = div;\r\npriv->tpf.denominator = FRAME_RATE_MAX;\r\nclkrc = to_clkrc(&priv->tpf, priv->pclk_limit, priv->pclk_max);\r\nret = ov6650_reg_rmw(client, REG_CLKRC, clkrc, CLKRC_DIV_MASK);\r\nif (!ret) {\r\ntpf->numerator = GET_CLKRC_DIV(clkrc);\r\ntpf->denominator = FRAME_RATE_MAX;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov6650_reset(struct i2c_client *client)\r\n{\r\nint ret;\r\ndev_dbg(&client->dev, "reset\n");\r\nret = ov6650_reg_rmw(client, REG_COMA, COMA_RESET, 0);\r\nif (ret)\r\ndev_err(&client->dev,\r\n"An error occurred while entering soft reset!\n");\r\nreturn ret;\r\n}\r\nstatic int ov6650_prog_dflt(struct i2c_client *client)\r\n{\r\nint ret;\r\ndev_dbg(&client->dev, "initializing\n");\r\nret = ov6650_reg_write(client, REG_COMA, 0);\r\nif (!ret)\r\nret = ov6650_reg_rmw(client, REG_COMB, 0, COMB_BAND_FILTER);\r\nreturn ret;\r\n}\r\nstatic int ov6650_video_probe(struct soc_camera_device *icd,\r\nstruct i2c_client *client)\r\n{\r\nu8 pidh, pidl, midh, midl;\r\nint ret = 0;\r\nret = ov6650_reg_read(client, REG_PIDH, &pidh);\r\nif (!ret)\r\nret = ov6650_reg_read(client, REG_PIDL, &pidl);\r\nif (!ret)\r\nret = ov6650_reg_read(client, REG_MIDH, &midh);\r\nif (!ret)\r\nret = ov6650_reg_read(client, REG_MIDL, &midl);\r\nif (ret)\r\nreturn ret;\r\nif ((pidh != OV6650_PIDH) || (pidl != OV6650_PIDL)) {\r\ndev_err(&client->dev, "Product ID error 0x%02x:0x%02x\n",\r\npidh, pidl);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&client->dev,\r\n"ov6650 Product ID 0x%02x:0x%02x Manufacturer ID 0x%02x:0x%02x\n",\r\npidh, pidl, midh, midl);\r\nret = ov6650_reset(client);\r\nif (!ret)\r\nret = ov6650_prog_dflt(client);\r\nreturn ret;\r\n}\r\nstatic int ov6650_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ov6650 *priv;\r\nstruct soc_camera_device *icd = client->dev.platform_data;\r\nstruct soc_camera_link *icl;\r\nint ret;\r\nif (!icd) {\r\ndev_err(&client->dev, "Missing soc-camera data!\n");\r\nreturn -EINVAL;\r\n}\r\nicl = to_soc_camera_link(icd);\r\nif (!icl) {\r\ndev_err(&client->dev, "Missing platform_data for driver\n");\r\nreturn -EINVAL;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&client->dev,\r\n"Failed to allocate memory for private data!\n");\r\nreturn -ENOMEM;\r\n}\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &ov6650_subdev_ops);\r\nicd->ops = &ov6650_ops;\r\npriv->rect.left = DEF_HSTRT << 1;\r\npriv->rect.top = DEF_VSTRT << 1;\r\npriv->rect.width = W_CIF;\r\npriv->rect.height = H_CIF;\r\npriv->half_scale = false;\r\npriv->code = V4L2_MBUS_FMT_YUYV8_2X8;\r\npriv->colorspace = V4L2_COLORSPACE_JPEG;\r\nret = ov6650_video_probe(icd, client);\r\nif (ret) {\r\nicd->ops = NULL;\r\nkfree(priv);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov6650_remove(struct i2c_client *client)\r\n{\r\nstruct ov6650 *priv = to_ov6650(client);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init ov6650_module_init(void)\r\n{\r\nreturn i2c_add_driver(&ov6650_i2c_driver);\r\n}\r\nstatic void __exit ov6650_module_exit(void)\r\n{\r\ni2c_del_driver(&ov6650_i2c_driver);\r\n}
