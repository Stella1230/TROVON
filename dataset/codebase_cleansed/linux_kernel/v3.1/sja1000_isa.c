static u8 sja1000_isa_mem_read_reg(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn readb(priv->reg_base + reg);\r\n}\r\nstatic void sja1000_isa_mem_write_reg(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\nwriteb(val, priv->reg_base + reg);\r\n}\r\nstatic u8 sja1000_isa_port_read_reg(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn inb((unsigned long)priv->reg_base + reg);\r\n}\r\nstatic void sja1000_isa_port_write_reg(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\noutb(val, (unsigned long)priv->reg_base + reg);\r\n}\r\nstatic u8 sja1000_isa_port_read_reg_indirect(const struct sja1000_priv *priv,\r\nint reg)\r\n{\r\nunsigned long base = (unsigned long)priv->reg_base;\r\noutb(reg, base);\r\nreturn inb(base + 1);\r\n}\r\nstatic void sja1000_isa_port_write_reg_indirect(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\nunsigned long base = (unsigned long)priv->reg_base;\r\noutb(reg, base);\r\noutb(val, base + 1);\r\n}\r\nstatic int __devinit sja1000_isa_match(struct device *pdev, unsigned int idx)\r\n{\r\nif (port[idx] || mem[idx]) {\r\nif (irq[idx])\r\nreturn 1;\r\n} else if (idx)\r\nreturn 0;\r\ndev_err(pdev, "insufficient parameters supplied\n");\r\nreturn 0;\r\n}\r\nstatic int __devinit sja1000_isa_probe(struct device *pdev, unsigned int idx)\r\n{\r\nstruct net_device *dev;\r\nstruct sja1000_priv *priv;\r\nvoid __iomem *base = NULL;\r\nint iosize = SJA1000_IOSIZE;\r\nint err;\r\nif (mem[idx]) {\r\nif (!request_mem_region(mem[idx], iosize, DRV_NAME)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\nbase = ioremap_nocache(mem[idx], iosize);\r\nif (!base) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\n} else {\r\nif (indirect[idx] > 0 ||\r\n(indirect[idx] == -1 && indirect[0] > 0))\r\niosize = SJA1000_IOSIZE_INDIRECT;\r\nif (!request_region(port[idx], iosize, DRV_NAME)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\n}\r\ndev = alloc_sja1000dev(0);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_unmap;\r\n}\r\npriv = netdev_priv(dev);\r\ndev->irq = irq[idx];\r\npriv->irq_flags = IRQF_SHARED;\r\nif (mem[idx]) {\r\npriv->reg_base = base;\r\ndev->base_addr = mem[idx];\r\npriv->read_reg = sja1000_isa_mem_read_reg;\r\npriv->write_reg = sja1000_isa_mem_write_reg;\r\n} else {\r\npriv->reg_base = (void __iomem *)port[idx];\r\ndev->base_addr = port[idx];\r\nif (iosize == SJA1000_IOSIZE_INDIRECT) {\r\npriv->read_reg = sja1000_isa_port_read_reg_indirect;\r\npriv->write_reg = sja1000_isa_port_write_reg_indirect;\r\n} else {\r\npriv->read_reg = sja1000_isa_port_read_reg;\r\npriv->write_reg = sja1000_isa_port_write_reg;\r\n}\r\n}\r\nif (clk[idx])\r\npriv->can.clock.freq = clk[idx] / 2;\r\nelse if (clk[0])\r\npriv->can.clock.freq = clk[0] / 2;\r\nelse\r\npriv->can.clock.freq = CLK_DEFAULT / 2;\r\nif (ocr[idx] != -1)\r\npriv->ocr = ocr[idx] & 0xff;\r\nelse if (ocr[0] != -1)\r\npriv->ocr = ocr[0] & 0xff;\r\nelse\r\npriv->ocr = OCR_DEFAULT;\r\nif (cdr[idx] != -1)\r\npriv->cdr = cdr[idx] & 0xff;\r\nelse if (cdr[0] != -1)\r\npriv->cdr = cdr[0] & 0xff;\r\nelse\r\npriv->cdr = CDR_DEFAULT;\r\ndev_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, pdev);\r\nerr = register_sja1000dev(dev);\r\nif (err) {\r\ndev_err(pdev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_unmap;\r\n}\r\ndev_info(pdev, "%s device registered (reg_base=0x%p, irq=%d)\n",\r\nDRV_NAME, priv->reg_base, dev->irq);\r\nreturn 0;\r\nexit_unmap:\r\nif (mem[idx])\r\niounmap(base);\r\nexit_release:\r\nif (mem[idx])\r\nrelease_mem_region(mem[idx], iosize);\r\nelse\r\nrelease_region(port[idx], iosize);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit sja1000_isa_remove(struct device *pdev, unsigned int idx)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(pdev);\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nunregister_sja1000dev(dev);\r\ndev_set_drvdata(pdev, NULL);\r\nif (mem[idx]) {\r\niounmap(priv->reg_base);\r\nrelease_mem_region(mem[idx], SJA1000_IOSIZE);\r\n} else {\r\nif (priv->read_reg == sja1000_isa_port_read_reg_indirect)\r\nrelease_region(port[idx], SJA1000_IOSIZE_INDIRECT);\r\nelse\r\nrelease_region(port[idx], SJA1000_IOSIZE);\r\n}\r\nfree_sja1000dev(dev);\r\nreturn 0;\r\n}\r\nstatic int __init sja1000_isa_init(void)\r\n{\r\nint err = isa_register_driver(&sja1000_isa_driver, MAXDEV);\r\nif (!err)\r\nprintk(KERN_INFO\r\n"Legacy %s driver for max. %d devices registered\n",\r\nDRV_NAME, MAXDEV);\r\nreturn err;\r\n}\r\nstatic void __exit sja1000_isa_exit(void)\r\n{\r\nisa_unregister_driver(&sja1000_isa_driver);\r\n}
