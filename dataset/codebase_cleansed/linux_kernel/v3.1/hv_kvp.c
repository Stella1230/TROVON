static void\r\nkvp_register(void)\r\n{\r\nstruct cn_msg *msg;\r\nmsg = kzalloc(sizeof(*msg) + strlen(HV_DRV_VERSION) + 1 , GFP_ATOMIC);\r\nif (msg) {\r\nmsg->id.idx = CN_KVP_IDX;\r\nmsg->id.val = CN_KVP_VAL;\r\nmsg->seq = KVP_REGISTER;\r\nstrcpy(msg->data, HV_DRV_VERSION);\r\nmsg->len = strlen(HV_DRV_VERSION) + 1;\r\ncn_netlink_send(msg, 0, GFP_ATOMIC);\r\nkfree(msg);\r\n}\r\n}\r\nstatic void\r\nkvp_work_func(struct work_struct *dummy)\r\n{\r\nkvp_respond_to_host("Unknown key", "Guest timed out", timeout_fired);\r\ntimeout_fired = 1;\r\n}\r\nstatic void\r\nkvp_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\r\n{\r\nstruct hv_ku_msg *message;\r\nmessage = (struct hv_ku_msg *)msg->data;\r\nif (msg->seq == KVP_REGISTER) {\r\npr_info("KVP: user-mode registering done.\n");\r\nkvp_register();\r\n}\r\nif (msg->seq == KVP_USER_SET) {\r\nif (cancel_delayed_work_sync(&kvp_work))\r\nkvp_respond_to_host(message->kvp_key,\r\nmessage->kvp_value,\r\n!strlen(message->kvp_key));\r\n}\r\n}\r\nstatic int\r\nkvp_send_key(int index)\r\n{\r\nstruct cn_msg *msg;\r\nmsg = kzalloc(sizeof(*msg) + sizeof(struct hv_kvp_msg) , GFP_ATOMIC);\r\nif (msg) {\r\nmsg->id.idx = CN_KVP_IDX;\r\nmsg->id.val = CN_KVP_VAL;\r\nmsg->seq = KVP_KERNEL_GET;\r\n((struct hv_ku_msg *)msg->data)->kvp_index = index;\r\nmsg->len = sizeof(struct hv_ku_msg);\r\ncn_netlink_send(msg, 0, GFP_ATOMIC);\r\nkfree(msg);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nkvp_respond_to_host(char *key, char *value, int error)\r\n{\r\nstruct hv_kvp_msg *kvp_msg;\r\nstruct hv_kvp_msg_enumerate *kvp_data;\r\nchar *key_name;\r\nstruct icmsg_hdr *icmsghdrp;\r\nint keylen, valuelen;\r\nu32 buf_len;\r\nstruct vmbus_channel *channel;\r\nu64 req_id;\r\nif (!kvp_transaction.active) {\r\npr_warn("KVP: Transaction not active\n");\r\nreturn;\r\n}\r\nbuf_len = kvp_transaction.recv_len;\r\nchannel = kvp_transaction.recv_channel;\r\nreq_id = kvp_transaction.recv_req_id;\r\nicmsghdrp = (struct icmsg_hdr *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr)];\r\nkvp_msg = (struct hv_kvp_msg *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nkvp_data = &kvp_msg->kvp_data;\r\nkey_name = key;\r\nif (error) {\r\nicmsghdrp->status = HV_E_FAIL;\r\ngoto response_done;\r\n}\r\nkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\r\n(wchar_t *)kvp_data->data.key);\r\nkvp_data->data.key_size = 2*(keylen + 1);\r\nvaluelen = utf8s_to_utf16s(value, strlen(value),\r\n(wchar_t *)kvp_data->data.value);\r\nkvp_data->data.value_size = 2*(valuelen + 1);\r\nkvp_data->data.value_type = REG_SZ;\r\nicmsghdrp->status = HV_S_OK;\r\nresponse_done:\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\r\nVM_PKT_DATA_INBAND, 0);\r\nkvp_transaction.active = false;\r\n}\r\nvoid hv_kvp_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct hv_kvp_msg *kvp_msg;\r\nstruct hv_kvp_msg_enumerate *kvp_data;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct icmsg_negotiate *negop = NULL;\r\nif (kvp_transaction.active)\r\nreturn;\r\nvmbus_recvpacket(channel, recv_buffer, PAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nprep_negotiate_resp(icmsghdrp, negop, recv_buffer);\r\n} else {\r\nkvp_msg = (struct hv_kvp_msg *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nkvp_data = &kvp_msg->kvp_data;\r\nif ((kvp_msg->kvp_hdr.pool != KVP_POOL_AUTO) ||\r\n(kvp_msg->kvp_hdr.operation !=\r\nKVP_OP_ENUMERATE)) {\r\nicmsghdrp->status = HV_E_FAIL;\r\ngoto callback_done;\r\n}\r\nkvp_transaction.recv_len = recvlen;\r\nkvp_transaction.recv_channel = channel;\r\nkvp_transaction.recv_req_id = requestid;\r\nkvp_transaction.active = true;\r\nkvp_send_key(kvp_data->index);\r\nschedule_delayed_work(&kvp_work, 100);\r\nreturn;\r\n}\r\ncallback_done:\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nint\r\nhv_kvp_init(void)\r\n{\r\nint err;\r\nerr = cn_add_callback(&kvp_id, kvp_name, kvp_cn_callback);\r\nif (err)\r\nreturn err;\r\nrecv_buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!recv_buffer)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid hv_kvp_deinit(void)\r\n{\r\ncn_del_callback(&kvp_id);\r\ncancel_delayed_work_sync(&kvp_work);\r\nkfree(recv_buffer);\r\n}
