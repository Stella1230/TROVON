static irqreturn_t spear_kbd_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spear_kbd *kbd = dev_id;\r\nstruct input_dev *input = kbd->input;\r\nunsigned int key;\r\nu8 sts, val;\r\nsts = readb(kbd->io_base + STATUS_REG);\r\nif (!(sts & DATA_AVAIL))\r\nreturn IRQ_NONE;\r\nif (kbd->last_key != KEY_RESERVED) {\r\ninput_report_key(input, kbd->last_key, 0);\r\nkbd->last_key = KEY_RESERVED;\r\n}\r\nval = readb(kbd->io_base + DATA_REG);\r\nkey = kbd->keycodes[val];\r\ninput_event(input, EV_MSC, MSC_SCAN, val);\r\ninput_report_key(input, key, 1);\r\ninput_sync(input);\r\nkbd->last_key = key;\r\nwriteb(0, kbd->io_base + STATUS_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spear_kbd_open(struct input_dev *dev)\r\n{\r\nstruct spear_kbd *kbd = input_get_drvdata(dev);\r\nint error;\r\nu16 val;\r\nkbd->last_key = KEY_RESERVED;\r\nerror = clk_enable(kbd->clk);\r\nif (error)\r\nreturn error;\r\nval = SCAN_RATE_80 | MODE_KEYBOARD | PCLK_FREQ_MSK;\r\nwritew(val, kbd->io_base + MODE_REG);\r\nwriteb(1, kbd->io_base + STATUS_REG);\r\nval = readw(kbd->io_base + MODE_REG);\r\nval |= START_SCAN;\r\nwritew(val, kbd->io_base + MODE_REG);\r\nreturn 0;\r\n}\r\nstatic void spear_kbd_close(struct input_dev *dev)\r\n{\r\nstruct spear_kbd *kbd = input_get_drvdata(dev);\r\nu16 val;\r\nval = readw(kbd->io_base + MODE_REG);\r\nval &= ~START_SCAN;\r\nwritew(val, kbd->io_base + MODE_REG);\r\nclk_disable(kbd->clk);\r\nkbd->last_key = KEY_RESERVED;\r\n}\r\nstatic int __devinit spear_kbd_probe(struct platform_device *pdev)\r\n{\r\nconst struct kbd_platform_data *pdata = pdev->dev.platform_data;\r\nconst struct matrix_keymap_data *keymap;\r\nstruct spear_kbd *kbd;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint irq;\r\nint error;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Invalid platform data\n");\r\nreturn -EINVAL;\r\n}\r\nkeymap = pdata->keymap;\r\nif (!keymap) {\r\ndev_err(&pdev->dev, "no keymap defined\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no keyboard resource defined\n");\r\nreturn -EBUSY;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "not able to get irq for the device\n");\r\nreturn irq;\r\n}\r\nkbd = kzalloc(sizeof(*kbd), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!kbd || !input_dev) {\r\ndev_err(&pdev->dev, "out of memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nkbd->input = input_dev;\r\nkbd->irq = irq;\r\nkbd->res = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (!kbd->res) {\r\ndev_err(&pdev->dev, "keyboard region already claimed\n");\r\nerror = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\nkbd->io_base = ioremap(res->start, resource_size(res));\r\nif (!kbd->io_base) {\r\ndev_err(&pdev->dev, "ioremap failed for kbd_region\n");\r\nerror = -ENOMEM;\r\ngoto err_release_mem_region;\r\n}\r\nkbd->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(kbd->clk)) {\r\nerror = PTR_ERR(kbd->clk);\r\ngoto err_iounmap;\r\n}\r\ninput_dev->name = "Spear Keyboard";\r\ninput_dev->phys = "keyboard/input0";\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->open = spear_kbd_open;\r\ninput_dev->close = spear_kbd_close;\r\n__set_bit(EV_KEY, input_dev->evbit);\r\nif (pdata->rep)\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_dev->keycode = kbd->keycodes;\r\ninput_dev->keycodesize = sizeof(kbd->keycodes[0]);\r\ninput_dev->keycodemax = ARRAY_SIZE(kbd->keycodes);\r\nmatrix_keypad_build_keymap(keymap, ROW_SHIFT,\r\ninput_dev->keycode, input_dev->keybit);\r\ninput_set_drvdata(input_dev, kbd);\r\nerror = request_irq(irq, spear_kbd_interrupt, 0, "keyboard", kbd);\r\nif (error) {\r\ndev_err(&pdev->dev, "request_irq fail\n");\r\ngoto err_put_clk;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "Unable to register keyboard device\n");\r\ngoto err_free_irq;\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nplatform_set_drvdata(pdev, kbd);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(kbd->irq, kbd);\r\nerr_put_clk:\r\nclk_put(kbd->clk);\r\nerr_iounmap:\r\niounmap(kbd->io_base);\r\nerr_release_mem_region:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(kbd);\r\nreturn error;\r\n}\r\nstatic int __devexit spear_kbd_remove(struct platform_device *pdev)\r\n{\r\nstruct spear_kbd *kbd = platform_get_drvdata(pdev);\r\nfree_irq(kbd->irq, kbd);\r\ninput_unregister_device(kbd->input);\r\nclk_put(kbd->clk);\r\niounmap(kbd->io_base);\r\nrelease_mem_region(kbd->res->start, resource_size(kbd->res));\r\nkfree(kbd);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int spear_kbd_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spear_kbd *kbd = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kbd->input;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nclk_enable(kbd->clk);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(kbd->irq);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int spear_kbd_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spear_kbd *kbd = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kbd->input;\r\nmutex_lock(&input_dev->mutex);\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(kbd->irq);\r\nif (input_dev->users)\r\nclk_enable(kbd->clk);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int __init spear_kbd_init(void)\r\n{\r\nreturn platform_driver_register(&spear_kbd_driver);\r\n}\r\nstatic void __exit spear_kbd_exit(void)\r\n{\r\nplatform_driver_unregister(&spear_kbd_driver);\r\n}
