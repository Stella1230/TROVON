static void shutdown_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nu8 execute_shutdown = false;\r\nstruct shutdown_msg_data *shutdown_msg;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct icmsg_negotiate *negop = NULL;\r\nvmbus_recvpacket(channel, shut_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&shut_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nprep_negotiate_resp(icmsghdrp, negop, shut_txf_buf);\r\n} else {\r\nshutdown_msg =\r\n(struct shutdown_msg_data *)&shut_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nswitch (shutdown_msg->flags) {\r\ncase 0:\r\ncase 1:\r\nicmsghdrp->status = HV_S_OK;\r\nexecute_shutdown = true;\r\npr_info("Shutdown request received -"\r\n" graceful shutdown initiated\n");\r\nbreak;\r\ndefault:\r\nicmsghdrp->status = HV_E_FAIL;\r\nexecute_shutdown = false;\r\npr_info("Shutdown request received -"\r\n" Invalid request\n");\r\nbreak;\r\n}\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, shut_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nif (execute_shutdown == true)\r\norderly_poweroff(false);\r\n}\r\nstatic inline void do_adj_guesttime(u64 hosttime)\r\n{\r\ns64 host_tns;\r\nstruct timespec host_ts;\r\nhost_tns = (hosttime - WLTIMEDELTA) * 100;\r\nhost_ts = ns_to_timespec(host_tns);\r\ndo_settimeofday(&host_ts);\r\n}\r\nstatic inline void adj_guesttime(u64 hosttime, u8 flags)\r\n{\r\nstatic s32 scnt = 50;\r\nif ((flags & ICTIMESYNCFLAG_SYNC) != 0) {\r\ndo_adj_guesttime(hosttime);\r\nreturn;\r\n}\r\nif ((flags & ICTIMESYNCFLAG_SAMPLE) != 0 && scnt > 0) {\r\nscnt--;\r\ndo_adj_guesttime(hosttime);\r\n}\r\n}\r\nstatic void timesync_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct ictimesync_data *timedatap;\r\nvmbus_recvpacket(channel, time_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&time_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nprep_negotiate_resp(icmsghdrp, NULL, time_txf_buf);\r\n} else {\r\ntimedatap = (struct ictimesync_data *)&time_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nadj_guesttime(timedatap->parenttime, timedatap->flags);\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, time_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nstatic void heartbeat_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct heartbeat_msg_data *heartbeat_msg;\r\nvmbus_recvpacket(channel, hbeat_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&hbeat_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nprep_negotiate_resp(icmsghdrp, NULL, hbeat_txf_buf);\r\n} else {\r\nheartbeat_msg =\r\n(struct heartbeat_msg_data *)&hbeat_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nheartbeat_msg->seq_num += 1;\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, hbeat_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nstatic int __init init_hyperv_utils(void)\r\n{\r\npr_info("Registering HyperV Utility Driver\n");\r\nif (hv_kvp_init())\r\nreturn -ENODEV;\r\nif (!dmi_check_system(hv_utils_dmi_table))\r\nreturn -ENODEV;\r\nshut_txf_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\ntime_txf_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nhbeat_txf_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!shut_txf_buf || !time_txf_buf || !hbeat_txf_buf) {\r\npr_info("Unable to allocate memory for receive buffer\n");\r\nkfree(shut_txf_buf);\r\nkfree(time_txf_buf);\r\nkfree(hbeat_txf_buf);\r\nreturn -ENOMEM;\r\n}\r\nhv_cb_utils[HV_SHUTDOWN_MSG].callback = &shutdown_onchannelcallback;\r\nhv_cb_utils[HV_TIMESYNC_MSG].callback = &timesync_onchannelcallback;\r\nhv_cb_utils[HV_HEARTBEAT_MSG].callback = &heartbeat_onchannelcallback;\r\nhv_cb_utils[HV_KVP_MSG].callback = &hv_kvp_onchannelcallback;\r\nreturn 0;\r\n}\r\nstatic void exit_hyperv_utils(void)\r\n{\r\npr_info("De-Registered HyperV Utility Driver\n");\r\nif (hv_cb_utils[HV_SHUTDOWN_MSG].channel != NULL)\r\nhv_cb_utils[HV_SHUTDOWN_MSG].channel->onchannel_callback =\r\n&chn_cb_negotiate;\r\nhv_cb_utils[HV_SHUTDOWN_MSG].callback = NULL;\r\nif (hv_cb_utils[HV_TIMESYNC_MSG].channel != NULL)\r\nhv_cb_utils[HV_TIMESYNC_MSG].channel->onchannel_callback =\r\n&chn_cb_negotiate;\r\nhv_cb_utils[HV_TIMESYNC_MSG].callback = NULL;\r\nif (hv_cb_utils[HV_HEARTBEAT_MSG].channel != NULL)\r\nhv_cb_utils[HV_HEARTBEAT_MSG].channel->onchannel_callback =\r\n&chn_cb_negotiate;\r\nhv_cb_utils[HV_HEARTBEAT_MSG].callback = NULL;\r\nif (hv_cb_utils[HV_KVP_MSG].channel != NULL)\r\nhv_cb_utils[HV_KVP_MSG].channel->onchannel_callback =\r\n&chn_cb_negotiate;\r\nhv_cb_utils[HV_KVP_MSG].callback = NULL;\r\nhv_kvp_deinit();\r\nkfree(shut_txf_buf);\r\nkfree(time_txf_buf);\r\nkfree(hbeat_txf_buf);\r\n}
