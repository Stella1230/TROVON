int msp_writereg(struct av7110 *av7110, u8 dev, u16 reg, u16 val)\r\n{\r\nu8 msg[5] = { dev, reg >> 8, reg & 0xff, val >> 8 , val & 0xff };\r\nstruct i2c_msg msgs = { .flags = 0, .len = 5, .buf = msg };\r\nswitch (av7110->adac_type) {\r\ncase DVB_ADAC_MSP34x0:\r\nmsgs.addr = 0x40;\r\nbreak;\r\ncase DVB_ADAC_MSP34x5:\r\nmsgs.addr = 0x42;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (i2c_transfer(&av7110->i2c_adap, &msgs, 1) != 1) {\r\ndprintk(1, "dvb-ttpci: failed @ card %d, %u = %u\n",\r\nav7110->dvb_adapter.num, reg, val);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msp_readreg(struct av7110 *av7110, u8 dev, u16 reg, u16 *val)\r\n{\r\nu8 msg1[3] = { dev, reg >> 8, reg & 0xff };\r\nu8 msg2[2];\r\nstruct i2c_msg msgs[2] = {\r\n{ .flags = 0 , .len = 3, .buf = msg1 },\r\n{ .flags = I2C_M_RD, .len = 2, .buf = msg2 }\r\n};\r\nswitch (av7110->adac_type) {\r\ncase DVB_ADAC_MSP34x0:\r\nmsgs[0].addr = 0x40;\r\nmsgs[1].addr = 0x40;\r\nbreak;\r\ncase DVB_ADAC_MSP34x5:\r\nmsgs[0].addr = 0x42;\r\nmsgs[1].addr = 0x42;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (i2c_transfer(&av7110->i2c_adap, &msgs[0], 2) != 2) {\r\ndprintk(1, "dvb-ttpci: failed @ card %d, %u\n",\r\nav7110->dvb_adapter.num, reg);\r\nreturn -EIO;\r\n}\r\n*val = (msg2[0] << 8) | msg2[1];\r\nreturn 0;\r\n}\r\nstatic int ves1820_writereg(struct saa7146_dev *dev, u8 addr, u8 reg, u8 data)\r\n{\r\nstruct av7110 *av7110 = dev->ext_priv;\r\nu8 buf[] = { 0x00, reg, data };\r\nstruct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 3 };\r\ndprintk(4, "dev: %p\n", dev);\r\nif (1 != i2c_transfer(&av7110->i2c_adap, &msg, 1))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int tuner_write(struct saa7146_dev *dev, u8 addr, u8 data [4])\r\n{\r\nstruct av7110 *av7110 = dev->ext_priv;\r\nstruct i2c_msg msg = { .addr = addr, .flags = 0, .buf = data, .len = 4 };\r\ndprintk(4, "dev: %p\n", dev);\r\nif (1 != i2c_transfer(&av7110->i2c_adap, &msg, 1))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int ves1820_set_tv_freq(struct saa7146_dev *dev, u32 freq)\r\n{\r\nu32 div;\r\nu8 config;\r\nu8 buf[4];\r\ndprintk(4, "freq: 0x%08x\n", freq);\r\ndiv = freq + 614;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = 0x8e;\r\nif (freq < (u32) (16 * 168.25))\r\nconfig = 0xa0;\r\nelse if (freq < (u32) (16 * 447.25))\r\nconfig = 0x90;\r\nelse\r\nconfig = 0x30;\r\nconfig &= ~0x02;\r\nbuf[3] = config;\r\nreturn tuner_write(dev, 0x61, buf);\r\n}\r\nstatic int stv0297_set_tv_freq(struct saa7146_dev *dev, u32 freq)\r\n{\r\nstruct av7110 *av7110 = (struct av7110*)dev->ext_priv;\r\nu32 div;\r\nu8 data[4];\r\ndiv = (freq + 38900000 + 31250) / 62500;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0xce;\r\nif (freq < 45000000)\r\nreturn -EINVAL;\r\nelse if (freq < 137000000)\r\ndata[3] = 0x01;\r\nelse if (freq < 403000000)\r\ndata[3] = 0x02;\r\nelse if (freq < 860000000)\r\ndata[3] = 0x04;\r\nelse\r\nreturn -EINVAL;\r\nif (av7110->fe->ops.i2c_gate_ctrl)\r\nav7110->fe->ops.i2c_gate_ctrl(av7110->fe, 1);\r\nreturn tuner_write(dev, 0x63, data);\r\n}\r\nstatic int av7110_dvb_c_switch(struct saa7146_fh *fh)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct av7110 *av7110 = (struct av7110*)dev->ext_priv;\r\nu16 adswitch;\r\nint source, sync, err;\r\ndprintk(4, "%p\n", av7110);\r\nif ((vv->video_status & STATUS_OVERLAY) != 0) {\r\nvv->ov_suspend = vv->video_fh;\r\nerr = saa7146_stop_preview(vv->video_fh);\r\nif (err != 0) {\r\ndprintk(2, "suspending video failed\n");\r\nvv->ov_suspend = NULL;\r\n}\r\n}\r\nif (0 != av7110->current_input) {\r\ndprintk(1, "switching to analog TV:\n");\r\nadswitch = 1;\r\nsource = SAA7146_HPS_SOURCE_PORT_B;\r\nsync = SAA7146_HPS_SYNC_PORT_B;\r\nmemcpy(standard, analog_standard, sizeof(struct saa7146_standard) * 2);\r\nswitch (av7110->current_input) {\r\ncase 1:\r\ndprintk(1, "switching SAA7113 to Analog Tuner Input.\n");\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0000);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0009, 0x0000);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x000a, 0x0000);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x000e, 0x3000);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0x4f00);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0x4f00);\r\nif (av7110->analog_tuner_flags & ANALOG_TUNER_VES1820) {\r\nif (ves1820_writereg(dev, 0x09, 0x0f, 0x60))\r\ndprintk(1, "setting band in demodulator failed.\n");\r\n} else if (av7110->analog_tuner_flags & ANALOG_TUNER_STV0297) {\r\nsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);\r\n}\r\nif (i2c_writereg(av7110, 0x48, 0x02, 0xd0) != 1)\r\ndprintk(1, "saa7113 write failed @ card %d", av7110->dvb_adapter.num);\r\nbreak;\r\ncase 2:\r\ndprintk(1, "switching SAA7113 to Video AV CVBS Input.\n");\r\nif (i2c_writereg(av7110, 0x48, 0x02, 0xd2) != 1)\r\ndprintk(1, "saa7113 write failed @ card %d", av7110->dvb_adapter.num);\r\nbreak;\r\ncase 3:\r\ndprintk(1, "switching SAA7113 to Video AV Y/C Input.\n");\r\nif (i2c_writereg(av7110, 0x48, 0x02, 0xd9) != 1)\r\ndprintk(1, "saa7113 write failed @ card %d", av7110->dvb_adapter.num);\r\nbreak;\r\ndefault:\r\ndprintk(1, "switching SAA7113 to Input: AV7110: SAA7113: invalid input.\n");\r\n}\r\n} else {\r\nadswitch = 0;\r\nsource = SAA7146_HPS_SOURCE_PORT_A;\r\nsync = SAA7146_HPS_SYNC_PORT_A;\r\nmemcpy(standard, dvb_standard, sizeof(struct saa7146_standard) * 2);\r\ndprintk(1, "switching DVB mode\n");\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0220);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0009, 0x0220);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x000a, 0x0220);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x000e, 0x3000);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0x7f00);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0x7f00);\r\nif (av7110->analog_tuner_flags & ANALOG_TUNER_VES1820) {\r\nif (ves1820_writereg(dev, 0x09, 0x0f, 0x20))\r\ndprintk(1, "setting band in demodulator failed.\n");\r\n} else if (av7110->analog_tuner_flags & ANALOG_TUNER_STV0297) {\r\nsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTLO);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\r\n}\r\n}\r\nif (av7110_fw_cmd(av7110, COMTYPE_AUDIODAC, ADSwitch, 1, adswitch))\r\ndprintk(1, "ADSwitch error\n");\r\nsaa7146_set_hps_source_and_sync(dev, source, sync);\r\nif (vv->ov_suspend != NULL) {\r\nsaa7146_start_preview(vv->ov_suspend);\r\nvv->ov_suspend = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *fh, struct v4l2_tuner *t)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\nu16 stereo_det;\r\ns8 stereo;\r\ndprintk(2, "VIDIOC_G_TUNER: %d\n", t->index);\r\nif (!av7110->analog_tuner_flags || t->index != 0)\r\nreturn -EINVAL;\r\nmemset(t, 0, sizeof(*t));\r\nstrcpy((char *)t->name, "Television");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nt->capability = V4L2_TUNER_CAP_NORM | V4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\r\nt->rangelow = 772;\r\nt->rangehigh = 13684;\r\nt->signal = 0xffff;\r\nt->afc = 0;\r\nmsp_readreg(av7110, MSP_RD_DEM, 0x007e, &stereo_det);\r\ndprintk(1, "VIDIOC_G_TUNER: msp3400 TV standard detection: 0x%04x\n", stereo_det);\r\nmsp_readreg(av7110, MSP_RD_DSP, 0x0018, &stereo_det);\r\ndprintk(1, "VIDIOC_G_TUNER: msp3400 stereo detection: 0x%04x\n", stereo_det);\r\nstereo = (s8)(stereo_det >> 8);\r\nif (stereo > 0x10) {\r\nt->rxsubchans = V4L2_TUNER_SUB_STEREO | V4L2_TUNER_SUB_MONO;\r\nt->audmode = V4L2_TUNER_MODE_STEREO;\r\n} else if (stereo < -0x10) {\r\nt->rxsubchans = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\nt->audmode = V4L2_TUNER_MODE_LANG1;\r\n} else\r\nt->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *fh, struct v4l2_tuner *t)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\nu16 fm_matrix, src;\r\ndprintk(2, "VIDIOC_S_TUNER: %d\n", t->index);\r\nif (!av7110->analog_tuner_flags || av7110->current_input != 1)\r\nreturn -EINVAL;\r\nswitch (t->audmode) {\r\ncase V4L2_TUNER_MODE_STEREO:\r\ndprintk(2, "VIDIOC_S_TUNER: V4L2_TUNER_MODE_STEREO\n");\r\nfm_matrix = 0x3001;\r\nsrc = 0x0020;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\ndprintk(2, "VIDIOC_S_TUNER: V4L2_TUNER_MODE_LANG1_LANG2\n");\r\nfm_matrix = 0x3000;\r\nsrc = 0x0020;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\ndprintk(2, "VIDIOC_S_TUNER: V4L2_TUNER_MODE_LANG1\n");\r\nfm_matrix = 0x3000;\r\nsrc = 0x0000;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\ndprintk(2, "VIDIOC_S_TUNER: V4L2_TUNER_MODE_LANG2\n");\r\nfm_matrix = 0x3000;\r\nsrc = 0x0010;\r\nbreak;\r\ndefault:\r\ndprintk(2, "VIDIOC_S_TUNER: TDA9840_SET_MONO\n");\r\nfm_matrix = 0x3000;\r\nsrc = 0x0030;\r\nbreak;\r\n}\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x000e, fm_matrix);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0008, src);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0009, src);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x000a, src);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *fh, struct v4l2_frequency *f)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\ndprintk(2, "VIDIOC_G_FREQ: freq:0x%08x.\n", f->frequency);\r\nif (!av7110->analog_tuner_flags || av7110->current_input != 1)\r\nreturn -EINVAL;\r\nmemset(f, 0, sizeof(*f));\r\nf->type = V4L2_TUNER_ANALOG_TV;\r\nf->frequency = av7110->current_freq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *fh, struct v4l2_frequency *f)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\ndprintk(2, "VIDIOC_S_FREQUENCY: freq:0x%08x.\n", f->frequency);\r\nif (!av7110->analog_tuner_flags || av7110->current_input != 1)\r\nreturn -EINVAL;\r\nif (V4L2_TUNER_ANALOG_TV != f->type)\r\nreturn -EINVAL;\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0xffe0);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0xffe0);\r\nif (av7110->analog_tuner_flags & ANALOG_TUNER_VES1820)\r\nves1820_set_tv_freq(dev, f->frequency);\r\nelse if (av7110->analog_tuner_flags & ANALOG_TUNER_STV0297)\r\nstv0297_set_tv_freq(dev, f->frequency);\r\nav7110->current_freq = f->frequency;\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0015, 0x003f);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0015, 0x0000);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0x4f00);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0x4f00);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\ndprintk(2, "VIDIOC_ENUMINPUT: %d\n", i->index);\r\nif (av7110->analog_tuner_flags) {\r\nif (i->index >= 4)\r\nreturn -EINVAL;\r\n} else {\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\n}\r\nmemcpy(i, &inputs[i->index], sizeof(struct v4l2_input));\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *input)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\n*input = av7110->current_input;\r\ndprintk(2, "VIDIOC_G_INPUT: %d\n", *input);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\ndprintk(2, "VIDIOC_S_INPUT: %d\n", input);\r\nif (!av7110->analog_tuner_flags)\r\nreturn 0;\r\nif (input >= 4)\r\nreturn -EINVAL;\r\nav7110->current_input = input;\r\nreturn av7110_dvb_c_switch(fh);\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *fh, struct v4l2_audio *a)\r\n{\r\ndprintk(2, "VIDIOC_G_AUDIO: %d\n", a->index);\r\nif (a->index != 0)\r\nreturn -EINVAL;\r\nmemcpy(a, &msp3400_v4l2_audio, sizeof(struct v4l2_audio));\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *fh, struct v4l2_audio *a)\r\n{\r\ndprintk(2, "VIDIOC_S_AUDIO: %d\n", a->index);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_sliced_vbi_cap(struct file *file, void *fh,\r\nstruct v4l2_sliced_vbi_cap *cap)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\ndprintk(2, "VIDIOC_G_SLICED_VBI_CAP\n");\r\nif (cap->type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT)\r\nreturn -EINVAL;\r\nif (FW_VERSION(av7110->arm_app) >= 0x2623) {\r\ncap->service_set = V4L2_SLICED_WSS_625;\r\ncap->service_lines[0][23] = V4L2_SLICED_WSS_625;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_sliced_vbi_out(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\ndprintk(2, "VIDIOC_G_FMT:\n");\r\nif (FW_VERSION(av7110->arm_app) < 0x2623)\r\nreturn -EINVAL;\r\nmemset(&f->fmt.sliced, 0, sizeof f->fmt.sliced);\r\nif (av7110->wssMode) {\r\nf->fmt.sliced.service_set = V4L2_SLICED_WSS_625;\r\nf->fmt.sliced.service_lines[0][23] = V4L2_SLICED_WSS_625;\r\nf->fmt.sliced.io_size = sizeof(struct v4l2_sliced_vbi_data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_sliced_vbi_out(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct av7110 *av7110 = (struct av7110 *)dev->ext_priv;\r\ndprintk(2, "VIDIOC_S_FMT\n");\r\nif (FW_VERSION(av7110->arm_app) < 0x2623)\r\nreturn -EINVAL;\r\nif (f->fmt.sliced.service_set != V4L2_SLICED_WSS_625 &&\r\nf->fmt.sliced.service_lines[0][23] != V4L2_SLICED_WSS_625) {\r\nmemset(&f->fmt.sliced, 0, sizeof(f->fmt.sliced));\r\nav7110->wssMode = 0;\r\nav7110->wssData = 0;\r\nreturn av7110_fw_cmd(av7110, COMTYPE_ENCODER,\r\nSetWSSConfig, 1, 0);\r\n} else {\r\nmemset(&f->fmt.sliced, 0, sizeof(f->fmt.sliced));\r\nf->fmt.sliced.service_set = V4L2_SLICED_WSS_625;\r\nf->fmt.sliced.service_lines[0][23] = V4L2_SLICED_WSS_625;\r\nf->fmt.sliced.io_size = sizeof(struct v4l2_sliced_vbi_data);\r\nav7110->wssMode = 1;\r\nav7110->wssData = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int av7110_vbi_reset(struct file *file)\r\n{\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct av7110 *av7110 = (struct av7110*) dev->ext_priv;\r\ndprintk(2, "%s\n", __func__);\r\nav7110->wssMode = 0;\r\nav7110->wssData = 0;\r\nif (FW_VERSION(av7110->arm_app) < 0x2623)\r\nreturn 0;\r\nelse\r\nreturn av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetWSSConfig, 1, 0);\r\n}\r\nstatic ssize_t av7110_vbi_write(struct file *file, const char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct av7110 *av7110 = (struct av7110*) dev->ext_priv;\r\nstruct v4l2_sliced_vbi_data d;\r\nint rc;\r\ndprintk(2, "%s\n", __func__);\r\nif (FW_VERSION(av7110->arm_app) < 0x2623 || !av7110->wssMode || count != sizeof d)\r\nreturn -EINVAL;\r\nif (copy_from_user(&d, data, count))\r\nreturn -EFAULT;\r\nif ((d.id != 0 && d.id != V4L2_SLICED_WSS_625) || d.field != 0 || d.line != 23)\r\nreturn -EINVAL;\r\nif (d.id)\r\nav7110->wssData = ((d.data[1] << 8) & 0x3f00) | d.data[0];\r\nelse\r\nav7110->wssData = 0x8000;\r\nrc = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetWSSConfig, 2, 1, av7110->wssData);\r\nreturn (rc < 0) ? rc : count;\r\n}\r\nint av7110_init_analog_module(struct av7110 *av7110)\r\n{\r\nu16 version1, version2;\r\nif (i2c_writereg(av7110, 0x80, 0x0, 0x80) == 1 &&\r\ni2c_writereg(av7110, 0x80, 0x0, 0) == 1) {\r\nprintk("dvb-ttpci: DVB-C analog module @ card %d detected, initializing MSP3400\n",\r\nav7110->dvb_adapter.num);\r\nav7110->adac_type = DVB_ADAC_MSP34x0;\r\n} else if (i2c_writereg(av7110, 0x84, 0x0, 0x80) == 1 &&\r\ni2c_writereg(av7110, 0x84, 0x0, 0) == 1) {\r\nprintk("dvb-ttpci: DVB-C analog module @ card %d detected, initializing MSP3415\n",\r\nav7110->dvb_adapter.num);\r\nav7110->adac_type = DVB_ADAC_MSP34x5;\r\n} else\r\nreturn -ENODEV;\r\nmsleep(100);\r\nmsp_readreg(av7110, MSP_RD_DSP, 0x001e, &version1);\r\nmsp_readreg(av7110, MSP_RD_DSP, 0x001f, &version2);\r\ndprintk(1, "dvb-ttpci: @ card %d MSP34xx version 0x%04x 0x%04x\n",\r\nav7110->dvb_adapter.num, version1, version2);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0013, 0x0c00);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0000, 0x7f00);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0220);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0009, 0x0220);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0004, 0x7f00);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x000a, 0x0220);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0007, 0x7f00);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x000d, 0x1900);\r\nif (i2c_writereg(av7110, 0x48, 0x01, 0x00)!=1) {\r\nINFO(("saa7113 not accessible.\n"));\r\n} else {\r\nu8 *i = saa7113_init_regs;\r\nif ((av7110->dev->pci->subsystem_vendor == 0x110a) && (av7110->dev->pci->subsystem_device == 0x0000)) {\r\nav7110->analog_tuner_flags |= ANALOG_TUNER_VES1820;\r\n} else if ((av7110->dev->pci->subsystem_vendor == 0x13c2) && (av7110->dev->pci->subsystem_device == 0x0002)) {\r\nav7110->analog_tuner_flags |= ANALOG_TUNER_VES1820;\r\n} else if ((av7110->dev->pci->subsystem_vendor == 0x13c2) && (av7110->dev->pci->subsystem_device == 0x000A)) {\r\nav7110->analog_tuner_flags |= ANALOG_TUNER_STV0297;\r\n}\r\nif (av7110->analog_tuner_flags & ANALOG_TUNER_VES1820) {\r\nif (ves1820_writereg(av7110->dev, 0x09, 0x0f, 0x20))\r\ndprintk(1, "setting band in demodulator failed.\n");\r\n} else if (av7110->analog_tuner_flags & ANALOG_TUNER_STV0297) {\r\nsaa7146_setgpio(av7110->dev, 1, SAA7146_GPIO_OUTLO);\r\nsaa7146_setgpio(av7110->dev, 3, SAA7146_GPIO_OUTLO);\r\n}\r\nwhile (*i != 0xff) {\r\nif (i2c_writereg(av7110, 0x48, i[0], i[1]) != 1) {\r\ndprintk(1, "saa7113 initialization failed @ card %d", av7110->dvb_adapter.num);\r\nbreak;\r\n}\r\ni += 2;\r\n}\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x00bb, 0x02d0);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 3);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 18);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 27);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 48);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 66);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0001, 72);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 4);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 64);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 0);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 3);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 18);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 27);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 48);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 66);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0005, 72);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0083, 0xa000);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0093, 0x00aa);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x009b, 0x04fc);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x00a3, 0x038e);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x00ab, 0x04c6);\r\nmsp_writereg(av7110, MSP_WR_DEM, 0x0056, 0);\r\n}\r\nmemcpy(standard, dvb_standard, sizeof(struct saa7146_standard) * 2);\r\nsaa7146_write(av7110->dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(av7110->dev, DD1_INIT, 0x03000700);\r\nsaa7146_write(av7110->dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nreturn 0;\r\n}\r\nint av7110_init_v4l(struct av7110 *av7110)\r\n{\r\nstruct saa7146_dev* dev = av7110->dev;\r\nstruct saa7146_ext_vv *vv_data;\r\nint ret;\r\nif (av7110->analog_tuner_flags)\r\nvv_data = &av7110_vv_data_c;\r\nelse\r\nvv_data = &av7110_vv_data_st;\r\nret = saa7146_vv_init(dev, vv_data);\r\nif (ret) {\r\nERR(("cannot init capture device. skipping.\n"));\r\nreturn -ENODEV;\r\n}\r\nvv_data->ops.vidioc_enum_input = vidioc_enum_input;\r\nvv_data->ops.vidioc_g_input = vidioc_g_input;\r\nvv_data->ops.vidioc_s_input = vidioc_s_input;\r\nvv_data->ops.vidioc_g_tuner = vidioc_g_tuner;\r\nvv_data->ops.vidioc_s_tuner = vidioc_s_tuner;\r\nvv_data->ops.vidioc_g_frequency = vidioc_g_frequency;\r\nvv_data->ops.vidioc_s_frequency = vidioc_s_frequency;\r\nvv_data->ops.vidioc_g_audio = vidioc_g_audio;\r\nvv_data->ops.vidioc_s_audio = vidioc_s_audio;\r\nvv_data->ops.vidioc_g_sliced_vbi_cap = vidioc_g_sliced_vbi_cap;\r\nvv_data->ops.vidioc_g_fmt_sliced_vbi_out = vidioc_g_fmt_sliced_vbi_out;\r\nvv_data->ops.vidioc_s_fmt_sliced_vbi_out = vidioc_s_fmt_sliced_vbi_out;\r\nif (saa7146_register_device(&av7110->v4l_dev, dev, "av7110", VFL_TYPE_GRABBER)) {\r\nERR(("cannot register capture device. skipping.\n"));\r\nsaa7146_vv_release(dev);\r\nreturn -ENODEV;\r\n}\r\nif (saa7146_register_device(&av7110->vbi_dev, dev, "av7110", VFL_TYPE_VBI))\r\nERR(("cannot register vbi v4l2 device. skipping.\n"));\r\nreturn 0;\r\n}\r\nint av7110_exit_v4l(struct av7110 *av7110)\r\n{\r\nstruct saa7146_dev* dev = av7110->dev;\r\nsaa7146_unregister_device(&av7110->v4l_dev, av7110->dev);\r\nsaa7146_unregister_device(&av7110->vbi_dev, av7110->dev);\r\nsaa7146_vv_release(dev);\r\nreturn 0;\r\n}\r\nstatic int std_callback(struct saa7146_dev* dev, struct saa7146_standard *std)\r\n{\r\nstruct av7110 *av7110 = (struct av7110*) dev->ext_priv;\r\nif (std->id & V4L2_STD_PAL) {\r\nav7110->vidmode = AV7110_VIDEO_MODE_PAL;\r\nav7110_set_vidmode(av7110, av7110->vidmode);\r\n}\r\nelse if (std->id & V4L2_STD_NTSC) {\r\nav7110->vidmode = AV7110_VIDEO_MODE_NTSC;\r\nav7110_set_vidmode(av7110, av7110->vidmode);\r\n}\r\nelse\r\nreturn -1;\r\nreturn 0;\r\n}
