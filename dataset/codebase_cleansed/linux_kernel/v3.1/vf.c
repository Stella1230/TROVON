static s32 e1000_init_mac_params_vf(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nmac->mta_reg_count = 128;\r\nmac->rar_entry_count = 1;\r\nmac->ops.reset_hw = e1000_reset_hw_vf;\r\nmac->ops.init_hw = e1000_init_hw_vf;\r\nmac->ops.check_for_link = e1000_check_for_link_vf;\r\nmac->ops.get_link_up_info = e1000_get_link_up_info_vf;\r\nmac->ops.update_mc_addr_list = e1000_update_mc_addr_list_vf;\r\nmac->ops.rar_set = e1000_rar_set_vf;\r\nmac->ops.read_mac_addr = e1000_read_mac_addr_vf;\r\nmac->ops.set_vfta = e1000_set_vfta_vf;\r\nreturn E1000_SUCCESS;\r\n}\r\nvoid e1000_init_function_pointers_vf(struct e1000_hw *hw)\r\n{\r\nhw->mac.ops.init_params = e1000_init_mac_params_vf;\r\nhw->mbx.ops.init_params = e1000_init_mbx_params_vf;\r\n}\r\nstatic s32 e1000_get_link_up_info_vf(struct e1000_hw *hw, u16 *speed,\r\nu16 *duplex)\r\n{\r\ns32 status;\r\nstatus = er32(STATUS);\r\nif (status & E1000_STATUS_SPEED_1000)\r\n*speed = SPEED_1000;\r\nelse if (status & E1000_STATUS_SPEED_100)\r\n*speed = SPEED_100;\r\nelse\r\n*speed = SPEED_10;\r\nif (status & E1000_STATUS_FD)\r\n*duplex = FULL_DUPLEX;\r\nelse\r\n*duplex = HALF_DUPLEX;\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_reset_hw_vf(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nu32 timeout = E1000_VF_INIT_TIMEOUT;\r\nu32 ret_val = -E1000_ERR_MAC_INIT;\r\nu32 msgbuf[3];\r\nu8 *addr = (u8 *)(&msgbuf[1]);\r\nu32 ctrl;\r\nctrl = er32(CTRL);\r\new32(CTRL, ctrl | E1000_CTRL_RST);\r\nwhile (!mbx->ops.check_for_rst(hw) && timeout) {\r\ntimeout--;\r\nudelay(5);\r\n}\r\nif (timeout) {\r\nmbx->timeout = E1000_VF_MBX_INIT_TIMEOUT;\r\nmsgbuf[0] = E1000_VF_RESET;\r\nmbx->ops.write_posted(hw, msgbuf, 1);\r\nmsleep(10);\r\nret_val = mbx->ops.read_posted(hw, msgbuf, 3);\r\nif (!ret_val) {\r\nif (msgbuf[0] == (E1000_VF_RESET | E1000_VT_MSGTYPE_ACK))\r\nmemcpy(hw->mac.perm_addr, addr, 6);\r\nelse\r\nret_val = -E1000_ERR_MAC_INIT;\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_init_hw_vf(struct e1000_hw *hw)\r\n{\r\ne1000_rar_set_vf(hw, hw->mac.addr, 0);\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic u32 e1000_hash_mc_addr_vf(struct e1000_hw *hw, u8 *mc_addr)\r\n{\r\nu32 hash_value, hash_mask;\r\nu8 bit_shift = 0;\r\nhash_mask = (hw->mac.mta_reg_count * 32) - 1;\r\nwhile (hash_mask >> bit_shift != 0xFF)\r\nbit_shift++;\r\nhash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |\r\n(((u16) mc_addr[5]) << bit_shift)));\r\nreturn hash_value;\r\n}\r\nstatic void e1000_update_mc_addr_list_vf(struct e1000_hw *hw,\r\nu8 *mc_addr_list, u32 mc_addr_count,\r\nu32 rar_used_count, u32 rar_count)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nu32 msgbuf[E1000_VFMAILBOX_SIZE];\r\nu16 *hash_list = (u16 *)&msgbuf[1];\r\nu32 hash_value;\r\nu32 cnt, i;\r\ncnt = (mc_addr_count > 30) ? 30 : mc_addr_count;\r\nmsgbuf[0] = E1000_VF_SET_MULTICAST;\r\nmsgbuf[0] |= cnt << E1000_VT_MSGINFO_SHIFT;\r\nfor (i = 0; i < cnt; i++) {\r\nhash_value = e1000_hash_mc_addr_vf(hw, mc_addr_list);\r\nhash_list[i] = hash_value & 0x0FFFF;\r\nmc_addr_list += ETH_ADDR_LEN;\r\n}\r\nmbx->ops.write_posted(hw, msgbuf, E1000_VFMAILBOX_SIZE);\r\n}\r\nstatic s32 e1000_set_vfta_vf(struct e1000_hw *hw, u16 vid, bool set)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nu32 msgbuf[2];\r\ns32 err;\r\nmsgbuf[0] = E1000_VF_SET_VLAN;\r\nmsgbuf[1] = vid;\r\nif (set)\r\nmsgbuf[0] |= 1 << E1000_VT_MSGINFO_SHIFT;\r\nmbx->ops.write_posted(hw, msgbuf, 2);\r\nerr = mbx->ops.read_posted(hw, msgbuf, 2);\r\nmsgbuf[0] &= ~E1000_VT_MSGTYPE_CTS;\r\nif (!err && (msgbuf[0] == (E1000_VF_SET_VLAN | E1000_VT_MSGTYPE_NACK)))\r\nerr = -E1000_ERR_MAC_INIT;\r\nreturn err;\r\n}\r\nvoid e1000_rlpml_set_vf(struct e1000_hw *hw, u16 max_size)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nu32 msgbuf[2];\r\nmsgbuf[0] = E1000_VF_SET_LPE;\r\nmsgbuf[1] = max_size;\r\nmbx->ops.write_posted(hw, msgbuf, 2);\r\n}\r\nstatic void e1000_rar_set_vf(struct e1000_hw *hw, u8 * addr, u32 index)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nu32 msgbuf[3];\r\nu8 *msg_addr = (u8 *)(&msgbuf[1]);\r\ns32 ret_val;\r\nmemset(msgbuf, 0, 12);\r\nmsgbuf[0] = E1000_VF_SET_MAC_ADDR;\r\nmemcpy(msg_addr, addr, 6);\r\nret_val = mbx->ops.write_posted(hw, msgbuf, 3);\r\nif (!ret_val)\r\nret_val = mbx->ops.read_posted(hw, msgbuf, 3);\r\nmsgbuf[0] &= ~E1000_VT_MSGTYPE_CTS;\r\nif (!ret_val &&\r\n(msgbuf[0] == (E1000_VF_SET_MAC_ADDR | E1000_VT_MSGTYPE_NACK)))\r\ne1000_read_mac_addr_vf(hw);\r\n}\r\nstatic s32 e1000_read_mac_addr_vf(struct e1000_hw *hw)\r\n{\r\nint i;\r\nfor (i = 0; i < ETH_ADDR_LEN; i++)\r\nhw->mac.addr[i] = hw->mac.perm_addr[i];\r\nreturn E1000_SUCCESS;\r\n}\r\nstatic s32 e1000_check_for_link_vf(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nstruct e1000_mac_info *mac = &hw->mac;\r\ns32 ret_val = E1000_SUCCESS;\r\nu32 in_msg = 0;\r\nif (!mbx->ops.check_for_rst(hw) || !mbx->timeout)\r\nmac->get_link_status = true;\r\nif (!mac->get_link_status)\r\ngoto out;\r\nif (!(er32(STATUS) & E1000_STATUS_LU))\r\ngoto out;\r\nif (mbx->ops.read(hw, &in_msg, 1))\r\ngoto out;\r\nif (!(in_msg & E1000_VT_MSGTYPE_CTS)) {\r\nif (in_msg & E1000_VT_MSGTYPE_NACK)\r\nret_val = -E1000_ERR_MAC_INIT;\r\ngoto out;\r\n}\r\nif (!mbx->timeout) {\r\nret_val = -E1000_ERR_MAC_INIT;\r\ngoto out;\r\n}\r\nmac->get_link_status = false;\r\nout:\r\nreturn ret_val;\r\n}
