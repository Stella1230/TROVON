int __hwspin_trylock(struct hwspinlock *hwlock, int mode, unsigned long *flags)\r\n{\r\nint ret;\r\nBUG_ON(!hwlock);\r\nBUG_ON(!flags && mode == HWLOCK_IRQSTATE);\r\nif (mode == HWLOCK_IRQSTATE)\r\nret = spin_trylock_irqsave(&hwlock->lock, *flags);\r\nelse if (mode == HWLOCK_IRQ)\r\nret = spin_trylock_irq(&hwlock->lock);\r\nelse\r\nret = spin_trylock(&hwlock->lock);\r\nif (!ret)\r\nreturn -EBUSY;\r\nret = hwlock->ops->trylock(hwlock);\r\nif (!ret) {\r\nif (mode == HWLOCK_IRQSTATE)\r\nspin_unlock_irqrestore(&hwlock->lock, *flags);\r\nelse if (mode == HWLOCK_IRQ)\r\nspin_unlock_irq(&hwlock->lock);\r\nelse\r\nspin_unlock(&hwlock->lock);\r\nreturn -EBUSY;\r\n}\r\nmb();\r\nreturn 0;\r\n}\r\nint __hwspin_lock_timeout(struct hwspinlock *hwlock, unsigned int to,\r\nint mode, unsigned long *flags)\r\n{\r\nint ret;\r\nunsigned long expire;\r\nexpire = msecs_to_jiffies(to) + jiffies;\r\nfor (;;) {\r\nret = __hwspin_trylock(hwlock, mode, flags);\r\nif (ret != -EBUSY)\r\nbreak;\r\nif (time_is_before_eq_jiffies(expire))\r\nreturn -ETIMEDOUT;\r\nif (hwlock->ops->relax)\r\nhwlock->ops->relax(hwlock);\r\n}\r\nreturn ret;\r\n}\r\nvoid __hwspin_unlock(struct hwspinlock *hwlock, int mode, unsigned long *flags)\r\n{\r\nBUG_ON(!hwlock);\r\nBUG_ON(!flags && mode == HWLOCK_IRQSTATE);\r\nmb();\r\nhwlock->ops->unlock(hwlock);\r\nif (mode == HWLOCK_IRQSTATE)\r\nspin_unlock_irqrestore(&hwlock->lock, *flags);\r\nelse if (mode == HWLOCK_IRQ)\r\nspin_unlock_irq(&hwlock->lock);\r\nelse\r\nspin_unlock(&hwlock->lock);\r\n}\r\nint hwspin_lock_register(struct hwspinlock *hwlock)\r\n{\r\nstruct hwspinlock *tmp;\r\nint ret;\r\nif (!hwlock || !hwlock->ops ||\r\n!hwlock->ops->trylock || !hwlock->ops->unlock) {\r\npr_err("invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_init(&hwlock->lock);\r\nspin_lock(&hwspinlock_tree_lock);\r\nret = radix_tree_insert(&hwspinlock_tree, hwlock->id, hwlock);\r\nif (ret)\r\ngoto out;\r\ntmp = radix_tree_tag_set(&hwspinlock_tree, hwlock->id,\r\nHWSPINLOCK_UNUSED);\r\nWARN_ON(tmp != hwlock);\r\nout:\r\nspin_unlock(&hwspinlock_tree_lock);\r\nreturn ret;\r\n}\r\nstruct hwspinlock *hwspin_lock_unregister(unsigned int id)\r\n{\r\nstruct hwspinlock *hwlock = NULL;\r\nint ret;\r\nspin_lock(&hwspinlock_tree_lock);\r\nret = radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);\r\nif (ret == 0) {\r\npr_err("hwspinlock %d still in use (or not present)\n", id);\r\ngoto out;\r\n}\r\nhwlock = radix_tree_delete(&hwspinlock_tree, id);\r\nif (!hwlock) {\r\npr_err("failed to delete hwspinlock %d\n", id);\r\ngoto out;\r\n}\r\nout:\r\nspin_unlock(&hwspinlock_tree_lock);\r\nreturn hwlock;\r\n}\r\nstatic int __hwspin_lock_request(struct hwspinlock *hwlock)\r\n{\r\nstruct hwspinlock *tmp;\r\nint ret;\r\nif (!try_module_get(hwlock->owner)) {\r\ndev_err(hwlock->dev, "%s: can't get owner\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nret = pm_runtime_get_sync(hwlock->dev);\r\nif (ret < 0) {\r\ndev_err(hwlock->dev, "%s: can't power on device\n", __func__);\r\nreturn ret;\r\n}\r\ntmp = radix_tree_tag_clear(&hwspinlock_tree, hwlock->id,\r\nHWSPINLOCK_UNUSED);\r\nWARN_ON(tmp != hwlock);\r\nreturn ret;\r\n}\r\nint hwspin_lock_get_id(struct hwspinlock *hwlock)\r\n{\r\nif (!hwlock) {\r\npr_err("invalid hwlock\n");\r\nreturn -EINVAL;\r\n}\r\nreturn hwlock->id;\r\n}\r\nstruct hwspinlock *hwspin_lock_request(void)\r\n{\r\nstruct hwspinlock *hwlock;\r\nint ret;\r\nspin_lock(&hwspinlock_tree_lock);\r\nret = radix_tree_gang_lookup_tag(&hwspinlock_tree, (void **)&hwlock,\r\n0, 1, HWSPINLOCK_UNUSED);\r\nif (ret == 0) {\r\npr_warn("a free hwspinlock is not available\n");\r\nhwlock = NULL;\r\ngoto out;\r\n}\r\nWARN_ON(ret > 1);\r\nret = __hwspin_lock_request(hwlock);\r\nif (ret < 0)\r\nhwlock = NULL;\r\nout:\r\nspin_unlock(&hwspinlock_tree_lock);\r\nreturn hwlock;\r\n}\r\nstruct hwspinlock *hwspin_lock_request_specific(unsigned int id)\r\n{\r\nstruct hwspinlock *hwlock;\r\nint ret;\r\nspin_lock(&hwspinlock_tree_lock);\r\nhwlock = radix_tree_lookup(&hwspinlock_tree, id);\r\nif (!hwlock) {\r\npr_warn("hwspinlock %u does not exist\n", id);\r\ngoto out;\r\n}\r\nWARN_ON(hwlock->id != id);\r\nret = radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);\r\nif (ret == 0) {\r\npr_warn("hwspinlock %u is already in use\n", id);\r\nhwlock = NULL;\r\ngoto out;\r\n}\r\nret = __hwspin_lock_request(hwlock);\r\nif (ret < 0)\r\nhwlock = NULL;\r\nout:\r\nspin_unlock(&hwspinlock_tree_lock);\r\nreturn hwlock;\r\n}\r\nint hwspin_lock_free(struct hwspinlock *hwlock)\r\n{\r\nstruct hwspinlock *tmp;\r\nint ret;\r\nif (!hwlock) {\r\npr_err("invalid hwlock\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&hwspinlock_tree_lock);\r\nret = radix_tree_tag_get(&hwspinlock_tree, hwlock->id,\r\nHWSPINLOCK_UNUSED);\r\nif (ret == 1) {\r\ndev_err(hwlock->dev, "%s: hwlock is already free\n", __func__);\r\ndump_stack();\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = pm_runtime_put(hwlock->dev);\r\nif (ret < 0)\r\ngoto out;\r\ntmp = radix_tree_tag_set(&hwspinlock_tree, hwlock->id,\r\nHWSPINLOCK_UNUSED);\r\nWARN_ON(tmp != hwlock);\r\nmodule_put(hwlock->owner);\r\nout:\r\nspin_unlock(&hwspinlock_tree_lock);\r\nreturn ret;\r\n}
