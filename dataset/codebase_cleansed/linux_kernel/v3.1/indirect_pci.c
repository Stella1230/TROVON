static int\r\nindirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,\r\nint len, u32 *val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nvolatile void __iomem *cfg_data;\r\nu8 cfg_type = 0;\r\nu32 bus_no, reg;\r\nif (hose->indirect_type & INDIRECT_TYPE_NO_PCIE_LINK) {\r\nif (bus->number != hose->first_busno)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (devfn != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (hose->indirect_type & INDIRECT_TYPE_SET_CFG_TYPE)\r\nif (bus->number != hose->first_busno)\r\ncfg_type = 1;\r\nbus_no = (bus->number == hose->first_busno) ?\r\nhose->self_busno : bus->number;\r\nif (hose->indirect_type & INDIRECT_TYPE_EXT_REG)\r\nreg = ((offset & 0xf00) << 16) | (offset & 0xfc);\r\nelse\r\nreg = offset & 0xfc;\r\nif (hose->indirect_type & INDIRECT_TYPE_BIG_ENDIAN)\r\nout_be32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |\r\n(devfn << 8) | reg | cfg_type));\r\nelse\r\nout_le32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |\r\n(devfn << 8) | reg | cfg_type));\r\ncfg_data = hose->cfg_data + (offset & 3);\r\nswitch (len) {\r\ncase 1:\r\n*val = in_8(cfg_data);\r\nbreak;\r\ncase 2:\r\n*val = in_le16(cfg_data);\r\nbreak;\r\ndefault:\r\n*val = in_le32(cfg_data);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nindirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,\r\nint len, u32 val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nvolatile void __iomem *cfg_data;\r\nu8 cfg_type = 0;\r\nu32 bus_no, reg;\r\nif (hose->indirect_type & INDIRECT_TYPE_NO_PCIE_LINK) {\r\nif (bus->number != hose->first_busno)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (devfn != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (hose->indirect_type & INDIRECT_TYPE_SET_CFG_TYPE)\r\nif (bus->number != hose->first_busno)\r\ncfg_type = 1;\r\nbus_no = (bus->number == hose->first_busno) ?\r\nhose->self_busno : bus->number;\r\nif (hose->indirect_type & INDIRECT_TYPE_EXT_REG)\r\nreg = ((offset & 0xf00) << 16) | (offset & 0xfc);\r\nelse\r\nreg = offset & 0xfc;\r\nif (hose->indirect_type & INDIRECT_TYPE_BIG_ENDIAN)\r\nout_be32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |\r\n(devfn << 8) | reg | cfg_type));\r\nelse\r\nout_le32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |\r\n(devfn << 8) | reg | cfg_type));\r\nif (hose->indirect_type & INDIRECT_TYPE_SURPRESS_PRIMARY_BUS)\r\nif ((offset == PCI_PRIMARY_BUS) &&\r\n(bus->number == hose->first_busno))\r\nval &= 0xffffff00;\r\nif ((hose->indirect_type & INDIRECT_TYPE_BROKEN_MRM) &&\r\noffset == PCI_CACHE_LINE_SIZE) {\r\nval = 0;\r\n}\r\ncfg_data = hose->cfg_data + (offset & 3);\r\nswitch (len) {\r\ncase 1:\r\nout_8(cfg_data, val);\r\nbreak;\r\ncase 2:\r\nout_le16(cfg_data, val);\r\nbreak;\r\ndefault:\r\nout_le32(cfg_data, val);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid __init\r\nsetup_indirect_pci(struct pci_controller *hose,\r\nresource_size_t cfg_addr,\r\nresource_size_t cfg_data, u32 flags)\r\n{\r\nresource_size_t base = cfg_addr & PAGE_MASK;\r\nvoid __iomem *mbase;\r\nmbase = ioremap(base, PAGE_SIZE);\r\nhose->cfg_addr = mbase + (cfg_addr & ~PAGE_MASK);\r\nif ((cfg_data & PAGE_MASK) != base)\r\nmbase = ioremap(cfg_data & PAGE_MASK, PAGE_SIZE);\r\nhose->cfg_data = mbase + (cfg_data & ~PAGE_MASK);\r\nhose->ops = &indirect_pci_ops;\r\nhose->indirect_type = flags;\r\n}
