static int vesafb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\n#ifdef __i386__\r\nint offset;\r\noffset = (var->yoffset * info->fix.line_length + var->xoffset) / 4;\r\n__asm__ __volatile__(\r\n"call *(%%edi)"\r\n:\r\n: "a" (0x4f07),\r\n"b" (0),\r\n"c" (offset),\r\n"d" (offset >> 16),\r\n"D" (&pmi_start));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int vesa_setpalette(int regno, unsigned red, unsigned green,\r\nunsigned blue)\r\n{\r\nint shift = 16 - depth;\r\nint err = -EINVAL;\r\nif (vga_compat) {\r\noutb_p(regno, dac_reg);\r\noutb_p(red >> shift, dac_val);\r\noutb_p(green >> shift, dac_val);\r\noutb_p(blue >> shift, dac_val);\r\nerr = 0;\r\n}\r\n#ifdef __i386__\r\nif (err && pmi_setpal) {\r\nstruct { u_char blue, green, red, pad; } entry;\r\nentry.red = red >> shift;\r\nentry.green = green >> shift;\r\nentry.blue = blue >> shift;\r\nentry.pad = 0;\r\n__asm__ __volatile__(\r\n"call *(%%esi)"\r\n:\r\n: "a" (0x4f09),\r\n"b" (0),\r\n"c" (1),\r\n"d" (regno),\r\n"D" (&entry),\r\n"S" (&pmi_pal));\r\nerr = 0;\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic int vesafb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nint err = 0;\r\nif (regno >= info->cmap.len)\r\nreturn 1;\r\nif (info->var.bits_per_pixel == 8)\r\nerr = vesa_setpalette(regno,red,green,blue);\r\nelse if (regno < 16) {\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\nif (info->var.red.offset == 10) {\r\n((u32*) (info->pseudo_palette))[regno] =\r\n((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) |\r\n((blue & 0xf800) >> 11);\r\n} else {\r\n((u32*) (info->pseudo_palette))[regno] =\r\n((red & 0xf800) ) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\n}\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\n((u32 *)(info->pseudo_palette))[regno] =\r\n(red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void vesafb_destroy(struct fb_info *info)\r\n{\r\nfb_dealloc_cmap(&info->cmap);\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nrelease_mem_region(info->apertures->ranges[0].base, info->apertures->ranges[0].size);\r\nframebuffer_release(info);\r\n}\r\nstatic int __init vesafb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt) continue;\r\nif (! strcmp(this_opt, "inverse"))\r\ninverse=1;\r\nelse if (! strcmp(this_opt, "redraw"))\r\nypan=0;\r\nelse if (! strcmp(this_opt, "ypan"))\r\nypan=1;\r\nelse if (! strcmp(this_opt, "ywrap"))\r\nypan=2;\r\nelse if (! strcmp(this_opt, "vgapal"))\r\npmi_setpal=0;\r\nelse if (! strcmp(this_opt, "pmipal"))\r\npmi_setpal=1;\r\nelse if (! strncmp(this_opt, "mtrr:", 5))\r\nmtrr = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (! strcmp(this_opt, "nomtrr"))\r\nmtrr=0;\r\nelse if (! strncmp(this_opt, "vtotal:", 7))\r\nvram_total = simple_strtoul(this_opt+7, NULL, 0);\r\nelse if (! strncmp(this_opt, "vremap:", 7))\r\nvram_remap = simple_strtoul(this_opt+7, NULL, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init vesafb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nint i, err;\r\nunsigned int size_vmode;\r\nunsigned int size_remap;\r\nunsigned int size_total;\r\nif (screen_info.orig_video_isVGA != VIDEO_TYPE_VLFB)\r\nreturn -ENODEV;\r\nvga_compat = (screen_info.capabilities & 2) ? 0 : 1;\r\nvesafb_fix.smem_start = screen_info.lfb_base;\r\nvesafb_defined.bits_per_pixel = screen_info.lfb_depth;\r\nif (15 == vesafb_defined.bits_per_pixel)\r\nvesafb_defined.bits_per_pixel = 16;\r\nvesafb_defined.xres = screen_info.lfb_width;\r\nvesafb_defined.yres = screen_info.lfb_height;\r\nvesafb_fix.line_length = screen_info.lfb_linelength;\r\nvesafb_fix.visual = (vesafb_defined.bits_per_pixel == 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\nsize_vmode = vesafb_defined.yres * vesafb_fix.line_length;\r\nsize_total = screen_info.lfb_size * 65536;\r\nif (vram_total)\r\nsize_total = vram_total * 1024 * 1024;\r\nif (size_total < size_vmode)\r\nsize_total = size_vmode;\r\nsize_remap = size_vmode * 2;\r\nif (vram_remap)\r\nsize_remap = vram_remap * 1024 * 1024;\r\nif (size_remap < size_vmode)\r\nsize_remap = size_vmode;\r\nif (size_remap > size_total)\r\nsize_remap = size_total;\r\nvesafb_fix.smem_len = size_remap;\r\n#ifndef __i386__\r\nscreen_info.vesapm_seg = 0;\r\n#endif\r\nif (!request_mem_region(vesafb_fix.smem_start, size_total, "vesafb")) {\r\nprintk(KERN_WARNING\r\n"vesafb: cannot reserve video memory at 0x%lx\n",\r\nvesafb_fix.smem_start);\r\n}\r\ninfo = framebuffer_alloc(sizeof(u32) * 256, &dev->dev);\r\nif (!info) {\r\nrelease_mem_region(vesafb_fix.smem_start, size_total);\r\nreturn -ENOMEM;\r\n}\r\ninfo->pseudo_palette = info->par;\r\ninfo->par = NULL;\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\ninfo->apertures->ranges[0].base = screen_info.lfb_base;\r\ninfo->apertures->ranges[0].size = size_total;\r\nprintk(KERN_INFO "vesafb: mode is %dx%dx%d, linelength=%d, pages=%d\n",\r\nvesafb_defined.xres, vesafb_defined.yres, vesafb_defined.bits_per_pixel, vesafb_fix.line_length, screen_info.pages);\r\nif (screen_info.vesapm_seg) {\r\nprintk(KERN_INFO "vesafb: protected mode interface info at %04x:%04x\n",\r\nscreen_info.vesapm_seg,screen_info.vesapm_off);\r\n}\r\nif (screen_info.vesapm_seg < 0xc000)\r\nypan = pmi_setpal = 0;\r\nif (ypan || pmi_setpal) {\r\nunsigned short *pmi_base;\r\npmi_base = (unsigned short*)phys_to_virt(((unsigned long)screen_info.vesapm_seg << 4) + screen_info.vesapm_off);\r\npmi_start = (void*)((char*)pmi_base + pmi_base[1]);\r\npmi_pal = (void*)((char*)pmi_base + pmi_base[2]);\r\nprintk(KERN_INFO "vesafb: pmi: set display start = %p, set palette = %p\n",pmi_start,pmi_pal);\r\nif (pmi_base[3]) {\r\nprintk(KERN_INFO "vesafb: pmi: ports = ");\r\nfor (i = pmi_base[3]/2; pmi_base[i] != 0xffff; i++)\r\nprintk("%x ",pmi_base[i]);\r\nprintk("\n");\r\nif (pmi_base[i] != 0xffff) {\r\nprintk(KERN_INFO "vesafb: can't handle memory requests, pmi disabled\n");\r\nypan = pmi_setpal = 0;\r\n}\r\n}\r\n}\r\nif (vesafb_defined.bits_per_pixel == 8 && !pmi_setpal && !vga_compat) {\r\nprintk(KERN_WARNING "vesafb: hardware palette is unchangeable,\n"\r\n" colors may be incorrect\n");\r\nvesafb_fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\r\n}\r\nvesafb_defined.xres_virtual = vesafb_defined.xres;\r\nvesafb_defined.yres_virtual = vesafb_fix.smem_len / vesafb_fix.line_length;\r\nif (ypan && vesafb_defined.yres_virtual > vesafb_defined.yres) {\r\nprintk(KERN_INFO "vesafb: scrolling: %s using protected mode interface, yres_virtual=%d\n",\r\n(ypan > 1) ? "ywrap" : "ypan",vesafb_defined.yres_virtual);\r\n} else {\r\nprintk(KERN_INFO "vesafb: scrolling: redraw\n");\r\nvesafb_defined.yres_virtual = vesafb_defined.yres;\r\nypan = 0;\r\n}\r\nvesafb_defined.pixclock = 10000000 / vesafb_defined.xres * 1000 / vesafb_defined.yres;\r\nvesafb_defined.left_margin = (vesafb_defined.xres / 8) & 0xf8;\r\nvesafb_defined.hsync_len = (vesafb_defined.xres / 8) & 0xf8;\r\nvesafb_defined.red.offset = screen_info.red_pos;\r\nvesafb_defined.red.length = screen_info.red_size;\r\nvesafb_defined.green.offset = screen_info.green_pos;\r\nvesafb_defined.green.length = screen_info.green_size;\r\nvesafb_defined.blue.offset = screen_info.blue_pos;\r\nvesafb_defined.blue.length = screen_info.blue_size;\r\nvesafb_defined.transp.offset = screen_info.rsvd_pos;\r\nvesafb_defined.transp.length = screen_info.rsvd_size;\r\nif (vesafb_defined.bits_per_pixel <= 8) {\r\ndepth = vesafb_defined.green.length;\r\nvesafb_defined.red.length =\r\nvesafb_defined.green.length =\r\nvesafb_defined.blue.length =\r\nvesafb_defined.bits_per_pixel;\r\n}\r\nprintk(KERN_INFO "vesafb: %s: "\r\n"size=%d:%d:%d:%d, shift=%d:%d:%d:%d\n",\r\n(vesafb_defined.bits_per_pixel > 8) ?\r\n"Truecolor" : (vga_compat || pmi_setpal) ?\r\n"Pseudocolor" : "Static Pseudocolor",\r\nscreen_info.rsvd_size,\r\nscreen_info.red_size,\r\nscreen_info.green_size,\r\nscreen_info.blue_size,\r\nscreen_info.rsvd_pos,\r\nscreen_info.red_pos,\r\nscreen_info.green_pos,\r\nscreen_info.blue_pos);\r\nvesafb_fix.ypanstep = ypan ? 1 : 0;\r\nvesafb_fix.ywrapstep = (ypan>1) ? 1 : 0;\r\nrequest_region(0x3c0, 32, "vesafb");\r\n#ifdef CONFIG_MTRR\r\nif (mtrr) {\r\nunsigned int temp_size = size_total;\r\nunsigned int type = 0;\r\nswitch (mtrr) {\r\ncase 1:\r\ntype = MTRR_TYPE_UNCACHABLE;\r\nbreak;\r\ncase 2:\r\ntype = MTRR_TYPE_WRBACK;\r\nbreak;\r\ncase 3:\r\ntype = MTRR_TYPE_WRCOMB;\r\nbreak;\r\ncase 4:\r\ntype = MTRR_TYPE_WRTHROUGH;\r\nbreak;\r\ndefault:\r\ntype = 0;\r\nbreak;\r\n}\r\nif (type) {\r\nint rc;\r\ntemp_size = roundup_pow_of_two(temp_size);\r\ndo {\r\nrc = mtrr_add(vesafb_fix.smem_start, temp_size,\r\ntype, 1);\r\ntemp_size >>= 1;\r\n} while (temp_size >= PAGE_SIZE && rc == -EINVAL);\r\n}\r\n}\r\n#endif\r\nswitch (mtrr) {\r\ncase 1:\r\ninfo->screen_base = ioremap_nocache(vesafb_fix.smem_start, vesafb_fix.smem_len);\r\nbreak;\r\ncase 2:\r\ninfo->screen_base = ioremap_cache(vesafb_fix.smem_start, vesafb_fix.smem_len);\r\nbreak;\r\ncase 3:\r\ninfo->screen_base = ioremap_wc(vesafb_fix.smem_start, vesafb_fix.smem_len);\r\nbreak;\r\ncase 4:\r\ndefault:\r\ninfo->screen_base = ioremap(vesafb_fix.smem_start, vesafb_fix.smem_len);\r\nbreak;\r\n}\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR\r\n"vesafb: abort, cannot ioremap video memory 0x%x @ 0x%lx\n",\r\nvesafb_fix.smem_len, vesafb_fix.smem_start);\r\nerr = -EIO;\r\ngoto err;\r\n}\r\nprintk(KERN_INFO "vesafb: framebuffer at 0x%lx, mapped to 0x%p, "\r\n"using %dk, total %dk\n",\r\nvesafb_fix.smem_start, info->screen_base,\r\nsize_remap/1024, size_total/1024);\r\ninfo->fbops = &vesafb_ops;\r\ninfo->var = vesafb_defined;\r\ninfo->fix = vesafb_fix;\r\ninfo->flags = FBINFO_FLAG_DEFAULT | FBINFO_MISC_FIRMWARE |\r\n(ypan ? FBINFO_HWACCEL_YPAN : 0);\r\nif (!ypan)\r\ninfo->fbops->fb_pan_display = NULL;\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nif (register_framebuffer(info)<0) {\r\nerr = -EINVAL;\r\nfb_dealloc_cmap(&info->cmap);\r\ngoto err;\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\nreturn 0;\r\nerr:\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nframebuffer_release(info);\r\nrelease_mem_region(vesafb_fix.smem_start, size_total);\r\nreturn err;\r\n}\r\nstatic int __init vesafb_init(void)\r\n{\r\nint ret;\r\nchar *option = NULL;\r\nfb_get_options("vesafb", &option);\r\nvesafb_setup(option);\r\nvesafb_device = platform_device_alloc("vesafb", 0);\r\nif (!vesafb_device)\r\nreturn -ENOMEM;\r\nret = platform_device_add(vesafb_device);\r\nif (!ret) {\r\nret = platform_driver_probe(&vesafb_driver, vesafb_probe);\r\nif (ret)\r\nplatform_device_del(vesafb_device);\r\n}\r\nif (ret) {\r\nplatform_device_put(vesafb_device);\r\nvesafb_device = NULL;\r\n}\r\nreturn ret;\r\n}
