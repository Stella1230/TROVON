void drm_sman_takedown(struct drm_sman * sman)\r\n{\r\ndrm_ht_remove(&sman->user_hash_tab);\r\ndrm_ht_remove(&sman->owner_hash_tab);\r\nkfree(sman->mm);\r\n}\r\nint\r\ndrm_sman_init(struct drm_sman * sman, unsigned int num_managers,\r\nunsigned int user_order, unsigned int owner_order)\r\n{\r\nint ret = 0;\r\nsman->mm = kcalloc(num_managers, sizeof(*sman->mm), GFP_KERNEL);\r\nif (!sman->mm) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsman->num_managers = num_managers;\r\nINIT_LIST_HEAD(&sman->owner_items);\r\nret = drm_ht_create(&sman->owner_hash_tab, owner_order);\r\nif (ret)\r\ngoto out1;\r\nret = drm_ht_create(&sman->user_hash_tab, user_order);\r\nif (!ret)\r\ngoto out;\r\ndrm_ht_remove(&sman->owner_hash_tab);\r\nout1:\r\nkfree(sman->mm);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void *drm_sman_mm_allocate(void *private, unsigned long size,\r\nunsigned alignment)\r\n{\r\nstruct drm_mm *mm = (struct drm_mm *) private;\r\nstruct drm_mm_node *tmp;\r\ntmp = drm_mm_search_free(mm, size, alignment, 1);\r\nif (!tmp) {\r\nreturn NULL;\r\n}\r\ntmp = drm_mm_get_block(tmp, size, alignment);\r\nreturn tmp;\r\n}\r\nstatic void drm_sman_mm_free(void *private, void *ref)\r\n{\r\nstruct drm_mm_node *node = (struct drm_mm_node *) ref;\r\ndrm_mm_put_block(node);\r\n}\r\nstatic void drm_sman_mm_destroy(void *private)\r\n{\r\nstruct drm_mm *mm = (struct drm_mm *) private;\r\ndrm_mm_takedown(mm);\r\nkfree(mm);\r\n}\r\nstatic unsigned long drm_sman_mm_offset(void *private, void *ref)\r\n{\r\nstruct drm_mm_node *node = (struct drm_mm_node *) ref;\r\nreturn node->start;\r\n}\r\nint\r\ndrm_sman_set_range(struct drm_sman * sman, unsigned int manager,\r\nunsigned long start, unsigned long size)\r\n{\r\nstruct drm_sman_mm *sman_mm;\r\nstruct drm_mm *mm;\r\nint ret;\r\nBUG_ON(manager >= sman->num_managers);\r\nsman_mm = &sman->mm[manager];\r\nmm = kzalloc(sizeof(*mm), GFP_KERNEL);\r\nif (!mm) {\r\nreturn -ENOMEM;\r\n}\r\nsman_mm->private = mm;\r\nret = drm_mm_init(mm, start, size);\r\nif (ret) {\r\nkfree(mm);\r\nreturn ret;\r\n}\r\nsman_mm->allocate = drm_sman_mm_allocate;\r\nsman_mm->free = drm_sman_mm_free;\r\nsman_mm->destroy = drm_sman_mm_destroy;\r\nsman_mm->offset = drm_sman_mm_offset;\r\nreturn 0;\r\n}\r\nint\r\ndrm_sman_set_manager(struct drm_sman * sman, unsigned int manager,\r\nstruct drm_sman_mm * allocator)\r\n{\r\nBUG_ON(manager >= sman->num_managers);\r\nsman->mm[manager] = *allocator;\r\nreturn 0;\r\n}\r\nstatic struct drm_owner_item *drm_sman_get_owner_item(struct drm_sman * sman,\r\nunsigned long owner)\r\n{\r\nint ret;\r\nstruct drm_hash_item *owner_hash_item;\r\nstruct drm_owner_item *owner_item;\r\nret = drm_ht_find_item(&sman->owner_hash_tab, owner, &owner_hash_item);\r\nif (!ret) {\r\nreturn drm_hash_entry(owner_hash_item, struct drm_owner_item,\r\nowner_hash);\r\n}\r\nowner_item = kzalloc(sizeof(*owner_item), GFP_KERNEL);\r\nif (!owner_item)\r\ngoto out;\r\nINIT_LIST_HEAD(&owner_item->mem_blocks);\r\nowner_item->owner_hash.key = owner;\r\nif (drm_ht_insert_item(&sman->owner_hash_tab, &owner_item->owner_hash))\r\ngoto out1;\r\nlist_add_tail(&owner_item->sman_list, &sman->owner_items);\r\nreturn owner_item;\r\nout1:\r\nkfree(owner_item);\r\nout:\r\nreturn NULL;\r\n}\r\nstruct drm_memblock_item *drm_sman_alloc(struct drm_sman *sman, unsigned int manager,\r\nunsigned long size, unsigned alignment,\r\nunsigned long owner)\r\n{\r\nvoid *tmp;\r\nstruct drm_sman_mm *sman_mm;\r\nstruct drm_owner_item *owner_item;\r\nstruct drm_memblock_item *memblock;\r\nBUG_ON(manager >= sman->num_managers);\r\nsman_mm = &sman->mm[manager];\r\ntmp = sman_mm->allocate(sman_mm->private, size, alignment);\r\nif (!tmp) {\r\nreturn NULL;\r\n}\r\nmemblock = kzalloc(sizeof(*memblock), GFP_KERNEL);\r\nif (!memblock)\r\ngoto out;\r\nmemblock->mm_info = tmp;\r\nmemblock->mm = sman_mm;\r\nmemblock->sman = sman;\r\nif (drm_ht_just_insert_please\r\n(&sman->user_hash_tab, &memblock->user_hash,\r\n(unsigned long)memblock, 32, 0, 0))\r\ngoto out1;\r\nowner_item = drm_sman_get_owner_item(sman, owner);\r\nif (!owner_item)\r\ngoto out2;\r\nlist_add_tail(&memblock->owner_list, &owner_item->mem_blocks);\r\nreturn memblock;\r\nout2:\r\ndrm_ht_remove_item(&sman->user_hash_tab, &memblock->user_hash);\r\nout1:\r\nkfree(memblock);\r\nout:\r\nsman_mm->free(sman_mm->private, tmp);\r\nreturn NULL;\r\n}\r\nstatic void drm_sman_free(struct drm_memblock_item *item)\r\n{\r\nstruct drm_sman *sman = item->sman;\r\nlist_del(&item->owner_list);\r\ndrm_ht_remove_item(&sman->user_hash_tab, &item->user_hash);\r\nitem->mm->free(item->mm->private, item->mm_info);\r\nkfree(item);\r\n}\r\nint drm_sman_free_key(struct drm_sman *sman, unsigned int key)\r\n{\r\nstruct drm_hash_item *hash_item;\r\nstruct drm_memblock_item *memblock_item;\r\nif (drm_ht_find_item(&sman->user_hash_tab, key, &hash_item))\r\nreturn -EINVAL;\r\nmemblock_item = drm_hash_entry(hash_item, struct drm_memblock_item,\r\nuser_hash);\r\ndrm_sman_free(memblock_item);\r\nreturn 0;\r\n}\r\nstatic void drm_sman_remove_owner(struct drm_sman *sman,\r\nstruct drm_owner_item *owner_item)\r\n{\r\nlist_del(&owner_item->sman_list);\r\ndrm_ht_remove_item(&sman->owner_hash_tab, &owner_item->owner_hash);\r\nkfree(owner_item);\r\n}\r\nint drm_sman_owner_clean(struct drm_sman *sman, unsigned long owner)\r\n{\r\nstruct drm_hash_item *hash_item;\r\nstruct drm_owner_item *owner_item;\r\nif (drm_ht_find_item(&sman->owner_hash_tab, owner, &hash_item)) {\r\nreturn -1;\r\n}\r\nowner_item = drm_hash_entry(hash_item, struct drm_owner_item, owner_hash);\r\nif (owner_item->mem_blocks.next == &owner_item->mem_blocks) {\r\ndrm_sman_remove_owner(sman, owner_item);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void drm_sman_do_owner_cleanup(struct drm_sman *sman,\r\nstruct drm_owner_item *owner_item)\r\n{\r\nstruct drm_memblock_item *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &owner_item->mem_blocks,\r\nowner_list) {\r\ndrm_sman_free(entry);\r\n}\r\ndrm_sman_remove_owner(sman, owner_item);\r\n}\r\nvoid drm_sman_owner_cleanup(struct drm_sman *sman, unsigned long owner)\r\n{\r\nstruct drm_hash_item *hash_item;\r\nstruct drm_owner_item *owner_item;\r\nif (drm_ht_find_item(&sman->owner_hash_tab, owner, &hash_item)) {\r\nreturn;\r\n}\r\nowner_item = drm_hash_entry(hash_item, struct drm_owner_item, owner_hash);\r\ndrm_sman_do_owner_cleanup(sman, owner_item);\r\n}\r\nvoid drm_sman_cleanup(struct drm_sman *sman)\r\n{\r\nstruct drm_owner_item *entry, *next;\r\nunsigned int i;\r\nstruct drm_sman_mm *sman_mm;\r\nlist_for_each_entry_safe(entry, next, &sman->owner_items, sman_list) {\r\ndrm_sman_do_owner_cleanup(sman, entry);\r\n}\r\nif (sman->mm) {\r\nfor (i = 0; i < sman->num_managers; ++i) {\r\nsman_mm = &sman->mm[i];\r\nif (sman_mm->private) {\r\nsman_mm->destroy(sman_mm->private);\r\nsman_mm->private = NULL;\r\n}\r\n}\r\n}\r\n}
