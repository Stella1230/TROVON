static u32 omap3_voltage_read_reg(u16 mod, u8 offset)\r\n{\r\nreturn omap2_prm_read_mod_reg(mod, offset);\r\n}\r\nstatic void omap3_voltage_write_reg(u32 val, u16 mod, u8 offset)\r\n{\r\nomap2_prm_write_mod_reg(val, mod, offset);\r\n}\r\nstatic u32 omap4_voltage_read_reg(u16 mod, u8 offset)\r\n{\r\nreturn omap4_prminst_read_inst_reg(OMAP4430_PRM_PARTITION,\r\nmod, offset);\r\n}\r\nstatic void omap4_voltage_write_reg(u32 val, u16 mod, u8 offset)\r\n{\r\nomap4_prminst_write_inst_reg(val, OMAP4430_PRM_PARTITION, mod, offset);\r\n}\r\nstatic int __init _config_common_vdd_data(struct omap_vdd_info *vdd)\r\n{\r\nchar *sys_ck_name;\r\nstruct clk *sys_ck;\r\nu32 sys_clk_speed, timeout_val, waittime;\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx())\r\nsys_ck_name = "sys_ck";\r\nelse if (cpu_is_omap44xx())\r\nsys_ck_name = "sys_clkin_ck";\r\nelse\r\nreturn -EINVAL;\r\nsys_ck = clk_get(NULL, sys_ck_name);\r\nif (IS_ERR(sys_ck)) {\r\npr_warning("%s: Could not get the sys clk to calculate"\r\n"various vdd_%s params\n", __func__, vdd->voltdm.name);\r\nreturn -EINVAL;\r\n}\r\nsys_clk_speed = clk_get_rate(sys_ck);\r\nclk_put(sys_ck);\r\nsys_clk_speed /= 1000;\r\nvdd->volt_scale = vp_forceupdate_scale_voltage;\r\nvdd->vp_enabled = false;\r\nvdd->vp_rt_data.vpconfig_erroroffset =\r\n(vdd->pmic_info->vp_erroroffset <<\r\nvdd->vp_data->vp_common->vpconfig_erroroffset_shift);\r\ntimeout_val = (sys_clk_speed * vdd->pmic_info->vp_timeout_us) / 1000;\r\nvdd->vp_rt_data.vlimitto_timeout = timeout_val;\r\nvdd->vp_rt_data.vlimitto_vddmin = vdd->pmic_info->vp_vddmin;\r\nvdd->vp_rt_data.vlimitto_vddmax = vdd->pmic_info->vp_vddmax;\r\nwaittime = ((vdd->pmic_info->step_size / vdd->pmic_info->slew_rate) *\r\nsys_clk_speed) / 1000;\r\nvdd->vp_rt_data.vstepmin_smpswaittimemin = waittime;\r\nvdd->vp_rt_data.vstepmax_smpswaittimemax = waittime;\r\nvdd->vp_rt_data.vstepmin_stepmin = vdd->pmic_info->vp_vstepmin;\r\nvdd->vp_rt_data.vstepmax_stepmax = vdd->pmic_info->vp_vstepmax;\r\nreturn 0;\r\n}\r\nstatic int vp_volt_debug_get(void *data, u64 *val)\r\n{\r\nstruct omap_vdd_info *vdd = (struct omap_vdd_info *) data;\r\nu8 vsel;\r\nif (!vdd) {\r\npr_warning("Wrong paramater passed\n");\r\nreturn -EINVAL;\r\n}\r\nvsel = vdd->read_reg(prm_mod_offs, vdd->vp_data->voltage);\r\nif (!vdd->pmic_info->vsel_to_uv) {\r\npr_warning("PMIC function to convert vsel to voltage"\r\n"in uV not registerd\n");\r\nreturn -EINVAL;\r\n}\r\n*val = vdd->pmic_info->vsel_to_uv(vsel);\r\nreturn 0;\r\n}\r\nstatic int nom_volt_debug_get(void *data, u64 *val)\r\n{\r\nstruct omap_vdd_info *vdd = (struct omap_vdd_info *) data;\r\nif (!vdd) {\r\npr_warning("Wrong paramater passed\n");\r\nreturn -EINVAL;\r\n}\r\n*val = omap_voltage_get_nom_volt(&vdd->voltdm);\r\nreturn 0;\r\n}\r\nstatic void vp_latch_vsel(struct omap_vdd_info *vdd)\r\n{\r\nu32 vpconfig;\r\nunsigned long uvdc;\r\nchar vsel;\r\nuvdc = omap_voltage_get_nom_volt(&vdd->voltdm);\r\nif (!uvdc) {\r\npr_warning("%s: unable to find current voltage for vdd_%s\n",\r\n__func__, vdd->voltdm.name);\r\nreturn;\r\n}\r\nif (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {\r\npr_warning("%s: PMIC function to convert voltage in uV to"\r\n" vsel not registered\n", __func__);\r\nreturn;\r\n}\r\nvsel = vdd->pmic_info->uv_to_vsel(uvdc);\r\nvpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);\r\nvpconfig &= ~(vdd->vp_data->vp_common->vpconfig_initvoltage_mask |\r\nvdd->vp_data->vp_common->vpconfig_initvdd);\r\nvpconfig |= vsel << vdd->vp_data->vp_common->vpconfig_initvoltage_shift;\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\nvdd->write_reg((vpconfig | vdd->vp_data->vp_common->vpconfig_initvdd),\r\nprm_mod_offs, vdd->vp_data->vpconfig);\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\n}\r\nstatic void __init vp_init(struct omap_vdd_info *vdd)\r\n{\r\nu32 vp_val;\r\nif (!vdd->read_reg || !vdd->write_reg) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, vdd->voltdm.name);\r\nreturn;\r\n}\r\nvp_val = vdd->vp_rt_data.vpconfig_erroroffset |\r\n(vdd->vp_rt_data.vpconfig_errorgain <<\r\nvdd->vp_data->vp_common->vpconfig_errorgain_shift) |\r\nvdd->vp_data->vp_common->vpconfig_timeouten;\r\nvdd->write_reg(vp_val, prm_mod_offs, vdd->vp_data->vpconfig);\r\nvp_val = ((vdd->vp_rt_data.vstepmin_smpswaittimemin <<\r\nvdd->vp_data->vp_common->vstepmin_smpswaittimemin_shift) |\r\n(vdd->vp_rt_data.vstepmin_stepmin <<\r\nvdd->vp_data->vp_common->vstepmin_stepmin_shift));\r\nvdd->write_reg(vp_val, prm_mod_offs, vdd->vp_data->vstepmin);\r\nvp_val = ((vdd->vp_rt_data.vstepmax_smpswaittimemax <<\r\nvdd->vp_data->vp_common->vstepmax_smpswaittimemax_shift) |\r\n(vdd->vp_rt_data.vstepmax_stepmax <<\r\nvdd->vp_data->vp_common->vstepmax_stepmax_shift));\r\nvdd->write_reg(vp_val, prm_mod_offs, vdd->vp_data->vstepmax);\r\nvp_val = ((vdd->vp_rt_data.vlimitto_vddmax <<\r\nvdd->vp_data->vp_common->vlimitto_vddmax_shift) |\r\n(vdd->vp_rt_data.vlimitto_vddmin <<\r\nvdd->vp_data->vp_common->vlimitto_vddmin_shift) |\r\n(vdd->vp_rt_data.vlimitto_timeout <<\r\nvdd->vp_data->vp_common->vlimitto_timeout_shift));\r\nvdd->write_reg(vp_val, prm_mod_offs, vdd->vp_data->vlimitto);\r\n}\r\nstatic void __init vdd_debugfs_init(struct omap_vdd_info *vdd)\r\n{\r\nchar *name;\r\nname = kzalloc(VOLTAGE_DIR_SIZE, GFP_KERNEL);\r\nif (!name) {\r\npr_warning("%s: Unable to allocate memory for debugfs"\r\n" directory name for vdd_%s",\r\n__func__, vdd->voltdm.name);\r\nreturn;\r\n}\r\nstrcpy(name, "vdd_");\r\nstrcat(name, vdd->voltdm.name);\r\nvdd->debug_dir = debugfs_create_dir(name, voltage_dir);\r\nkfree(name);\r\nif (IS_ERR(vdd->debug_dir)) {\r\npr_warning("%s: Unable to create debugfs directory for"\r\n" vdd_%s\n", __func__, vdd->voltdm.name);\r\nvdd->debug_dir = NULL;\r\nreturn;\r\n}\r\n(void) debugfs_create_x16("vp_errorgain", S_IRUGO, vdd->debug_dir,\r\n&(vdd->vp_rt_data.vpconfig_errorgain));\r\n(void) debugfs_create_x16("vp_smpswaittimemin", S_IRUGO,\r\nvdd->debug_dir,\r\n&(vdd->vp_rt_data.vstepmin_smpswaittimemin));\r\n(void) debugfs_create_x8("vp_stepmin", S_IRUGO, vdd->debug_dir,\r\n&(vdd->vp_rt_data.vstepmin_stepmin));\r\n(void) debugfs_create_x16("vp_smpswaittimemax", S_IRUGO,\r\nvdd->debug_dir,\r\n&(vdd->vp_rt_data.vstepmax_smpswaittimemax));\r\n(void) debugfs_create_x8("vp_stepmax", S_IRUGO, vdd->debug_dir,\r\n&(vdd->vp_rt_data.vstepmax_stepmax));\r\n(void) debugfs_create_x8("vp_vddmax", S_IRUGO, vdd->debug_dir,\r\n&(vdd->vp_rt_data.vlimitto_vddmax));\r\n(void) debugfs_create_x8("vp_vddmin", S_IRUGO, vdd->debug_dir,\r\n&(vdd->vp_rt_data.vlimitto_vddmin));\r\n(void) debugfs_create_x16("vp_timeout", S_IRUGO, vdd->debug_dir,\r\n&(vdd->vp_rt_data.vlimitto_timeout));\r\n(void) debugfs_create_file("curr_vp_volt", S_IRUGO, vdd->debug_dir,\r\n(void *) vdd, &vp_volt_debug_fops);\r\n(void) debugfs_create_file("curr_nominal_volt", S_IRUGO,\r\nvdd->debug_dir, (void *) vdd,\r\n&nom_volt_debug_fops);\r\n}\r\nstatic int _pre_volt_scale(struct omap_vdd_info *vdd,\r\nunsigned long target_volt, u8 *target_vsel, u8 *current_vsel)\r\n{\r\nstruct omap_volt_data *volt_data;\r\nconst struct omap_vc_common_data *vc_common;\r\nconst struct omap_vp_common_data *vp_common;\r\nu32 vc_cmdval, vp_errgain_val;\r\nvc_common = vdd->vc_data->vc_common;\r\nvp_common = vdd->vp_data->vp_common;\r\nif (!vdd->pmic_info) {\r\npr_err("%s: Insufficient pmic info to scale the vdd_%s\n",\r\n__func__, vdd->voltdm.name);\r\nreturn -EINVAL;\r\n}\r\nif (!vdd->pmic_info->uv_to_vsel) {\r\npr_err("%s: PMIC function to convert voltage in uV to"\r\n"vsel not registered. Hence unable to scale voltage"\r\n"for vdd_%s\n", __func__, vdd->voltdm.name);\r\nreturn -ENODATA;\r\n}\r\nif (!vdd->read_reg || !vdd->write_reg) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, vdd->voltdm.name);\r\nreturn -EINVAL;\r\n}\r\nvolt_data = omap_voltage_get_voltdata(&vdd->voltdm, target_volt);\r\nif (IS_ERR(volt_data))\r\nvolt_data = NULL;\r\n*target_vsel = vdd->pmic_info->uv_to_vsel(target_volt);\r\n*current_vsel = vdd->read_reg(prm_mod_offs, vdd->vp_data->voltage);\r\nvc_cmdval = vdd->read_reg(prm_mod_offs, vdd->vc_data->cmdval_reg);\r\nvc_cmdval &= ~vc_common->cmd_on_mask;\r\nvc_cmdval |= (*target_vsel << vc_common->cmd_on_shift);\r\nvdd->write_reg(vc_cmdval, prm_mod_offs, vdd->vc_data->cmdval_reg);\r\nif (volt_data) {\r\nvp_errgain_val = vdd->read_reg(prm_mod_offs,\r\nvdd->vp_data->vpconfig);\r\nvdd->vp_rt_data.vpconfig_errorgain = volt_data->vp_errgain;\r\nvp_errgain_val &= ~vp_common->vpconfig_errorgain_mask;\r\nvp_errgain_val |= vdd->vp_rt_data.vpconfig_errorgain <<\r\nvp_common->vpconfig_errorgain_shift;\r\nvdd->write_reg(vp_errgain_val, prm_mod_offs,\r\nvdd->vp_data->vpconfig);\r\n}\r\nreturn 0;\r\n}\r\nstatic void _post_volt_scale(struct omap_vdd_info *vdd,\r\nunsigned long target_volt, u8 target_vsel, u8 current_vsel)\r\n{\r\nu32 smps_steps = 0, smps_delay = 0;\r\nsmps_steps = abs(target_vsel - current_vsel);\r\nsmps_delay = ((smps_steps * vdd->pmic_info->step_size) /\r\nvdd->pmic_info->slew_rate) + 2;\r\nudelay(smps_delay);\r\nvdd->curr_volt = target_volt;\r\n}\r\nstatic int vc_bypass_scale_voltage(struct omap_vdd_info *vdd,\r\nunsigned long target_volt)\r\n{\r\nu32 loop_cnt = 0, retries_cnt = 0;\r\nu32 vc_valid, vc_bypass_val_reg, vc_bypass_value;\r\nu8 target_vsel, current_vsel;\r\nint ret;\r\nret = _pre_volt_scale(vdd, target_volt, &target_vsel, &current_vsel);\r\nif (ret)\r\nreturn ret;\r\nvc_valid = vdd->vc_data->vc_common->valid;\r\nvc_bypass_val_reg = vdd->vc_data->vc_common->bypass_val_reg;\r\nvc_bypass_value = (target_vsel << vdd->vc_data->vc_common->data_shift) |\r\n(vdd->pmic_info->pmic_reg <<\r\nvdd->vc_data->vc_common->regaddr_shift) |\r\n(vdd->pmic_info->i2c_slave_addr <<\r\nvdd->vc_data->vc_common->slaveaddr_shift);\r\nvdd->write_reg(vc_bypass_value, prm_mod_offs, vc_bypass_val_reg);\r\nvdd->write_reg(vc_bypass_value | vc_valid, prm_mod_offs,\r\nvc_bypass_val_reg);\r\nvc_bypass_value = vdd->read_reg(prm_mod_offs, vc_bypass_val_reg);\r\nwhile (!(vc_bypass_value & vc_valid)) {\r\nloop_cnt++;\r\nif (retries_cnt > 10) {\r\npr_warning("%s: Retry count exceeded\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (loop_cnt > 50) {\r\nretries_cnt++;\r\nloop_cnt = 0;\r\nudelay(10);\r\n}\r\nvc_bypass_value = vdd->read_reg(prm_mod_offs,\r\nvc_bypass_val_reg);\r\n}\r\n_post_volt_scale(vdd, target_volt, target_vsel, current_vsel);\r\nreturn 0;\r\n}\r\nstatic int vp_forceupdate_scale_voltage(struct omap_vdd_info *vdd,\r\nunsigned long target_volt)\r\n{\r\nu32 vpconfig;\r\nu8 target_vsel, current_vsel, prm_irqst_reg;\r\nint ret, timeout = 0;\r\nret = _pre_volt_scale(vdd, target_volt, &target_vsel, &current_vsel);\r\nif (ret)\r\nreturn ret;\r\nprm_irqst_reg = vdd->vp_data->prm_irqst_data->prm_irqst_reg;\r\nwhile (timeout++ < VP_TRANXDONE_TIMEOUT) {\r\nvdd->write_reg(vdd->vp_data->prm_irqst_data->tranxdone_status,\r\nprm_irqst_ocp_mod_offs, prm_irqst_reg);\r\nif (!(vdd->read_reg(prm_irqst_ocp_mod_offs, prm_irqst_reg) &\r\nvdd->vp_data->prm_irqst_data->tranxdone_status))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout >= VP_TRANXDONE_TIMEOUT) {\r\npr_warning("%s: vdd_%s TRANXDONE timeout exceeded."\r\n"Voltage change aborted", __func__, vdd->voltdm.name);\r\nreturn -ETIMEDOUT;\r\n}\r\nvpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);\r\nvpconfig &= ~(vdd->vp_data->vp_common->vpconfig_initvdd |\r\nvdd->vp_data->vp_common->vpconfig_forceupdate |\r\nvdd->vp_data->vp_common->vpconfig_initvoltage_mask);\r\nvpconfig |= ((target_vsel <<\r\nvdd->vp_data->vp_common->vpconfig_initvoltage_shift));\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\nvpconfig |= vdd->vp_data->vp_common->vpconfig_initvdd;\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\nvpconfig |= vdd->vp_data->vp_common->vpconfig_forceupdate;\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\ntimeout = 0;\r\nomap_test_timeout((vdd->read_reg(prm_irqst_ocp_mod_offs, prm_irqst_reg) &\r\nvdd->vp_data->prm_irqst_data->tranxdone_status),\r\nVP_TRANXDONE_TIMEOUT, timeout);\r\nif (timeout >= VP_TRANXDONE_TIMEOUT)\r\npr_err("%s: vdd_%s TRANXDONE timeout exceeded."\r\n"TRANXDONE never got set after the voltage update\n",\r\n__func__, vdd->voltdm.name);\r\n_post_volt_scale(vdd, target_volt, target_vsel, current_vsel);\r\ntimeout = 0;\r\nwhile (timeout++ < VP_TRANXDONE_TIMEOUT) {\r\nvdd->write_reg(vdd->vp_data->prm_irqst_data->tranxdone_status,\r\nprm_irqst_ocp_mod_offs, prm_irqst_reg);\r\nif (!(vdd->read_reg(prm_irqst_ocp_mod_offs, prm_irqst_reg) &\r\nvdd->vp_data->prm_irqst_data->tranxdone_status))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout >= VP_TRANXDONE_TIMEOUT)\r\npr_warning("%s: vdd_%s TRANXDONE timeout exceeded while trying"\r\n"to clear the TRANXDONE status\n",\r\n__func__, vdd->voltdm.name);\r\nvpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);\r\nvpconfig &= ~vdd->vp_data->vp_common->vpconfig_initvdd;\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\nvpconfig &= ~vdd->vp_data->vp_common->vpconfig_forceupdate;\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\nreturn 0;\r\n}\r\nstatic void __init omap3_vfsm_init(struct omap_vdd_info *vdd)\r\n{\r\nvdd->write_reg(OMAP3_CLKSETUP, prm_mod_offs, OMAP3_PRM_CLKSETUP_OFFSET);\r\nvdd->write_reg(OMAP3_VOLTOFFSET, prm_mod_offs,\r\nOMAP3_PRM_VOLTOFFSET_OFFSET);\r\nvdd->write_reg(OMAP3_VOLTSETUP2, prm_mod_offs,\r\nOMAP3_PRM_VOLTSETUP2_OFFSET);\r\n}\r\nstatic void __init omap3_vc_init(struct omap_vdd_info *vdd)\r\n{\r\nstatic bool is_initialized;\r\nu8 on_vsel, onlp_vsel, ret_vsel, off_vsel;\r\nu32 vc_val;\r\nif (is_initialized)\r\nreturn;\r\non_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->on_volt);\r\nonlp_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->onlp_volt);\r\nret_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->ret_volt);\r\noff_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->off_volt);\r\nvc_val = ((on_vsel << vdd->vc_data->vc_common->cmd_on_shift) |\r\n(onlp_vsel << vdd->vc_data->vc_common->cmd_onlp_shift) |\r\n(ret_vsel << vdd->vc_data->vc_common->cmd_ret_shift) |\r\n(off_vsel << vdd->vc_data->vc_common->cmd_off_shift));\r\nvdd->write_reg(vc_val, prm_mod_offs, vdd->vc_data->cmdval_reg);\r\nvdd->write_reg(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK, prm_mod_offs,\r\nOMAP3_PRM_VC_CH_CONF_OFFSET);\r\nvdd->write_reg(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK, prm_mod_offs,\r\nOMAP3_PRM_VC_I2C_CFG_OFFSET);\r\nomap3_vfsm_init(vdd);\r\nis_initialized = true;\r\n}\r\nstatic void __init omap4_vc_init(struct omap_vdd_info *vdd)\r\n{\r\nstatic bool is_initialized;\r\nu32 vc_val;\r\nif (is_initialized)\r\nreturn;\r\nvc_val = (OMAP4430_RAV_VDD_MPU_L_MASK | OMAP4430_CMD_VDD_MPU_L_MASK |\r\nOMAP4430_RAV_VDD_IVA_L_MASK | OMAP4430_CMD_VDD_IVA_L_MASK |\r\nOMAP4430_RAV_VDD_CORE_L_MASK | OMAP4430_CMD_VDD_CORE_L_MASK);\r\nvdd->write_reg(vc_val, prm_mod_offs, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);\r\nvc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);\r\nvdd->write_reg(vc_val, prm_mod_offs, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);\r\nis_initialized = true;\r\n}\r\nstatic void __init omap_vc_init(struct omap_vdd_info *vdd)\r\n{\r\nu32 vc_val;\r\nif (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {\r\npr_err("%s: PMIC info requried to configure vc for"\r\n"vdd_%s not populated.Hence cannot initialize vc\n",\r\n__func__, vdd->voltdm.name);\r\nreturn;\r\n}\r\nif (!vdd->read_reg || !vdd->write_reg) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, vdd->voltdm.name);\r\nreturn;\r\n}\r\nvc_val = vdd->read_reg(prm_mod_offs,\r\nvdd->vc_data->vc_common->smps_sa_reg);\r\nvc_val &= ~vdd->vc_data->smps_sa_mask;\r\nvc_val |= vdd->pmic_info->i2c_slave_addr << vdd->vc_data->smps_sa_shift;\r\nvdd->write_reg(vc_val, prm_mod_offs,\r\nvdd->vc_data->vc_common->smps_sa_reg);\r\nvc_val = vdd->read_reg(prm_mod_offs,\r\nvdd->vc_data->vc_common->smps_volra_reg);\r\nvc_val &= ~vdd->vc_data->smps_volra_mask;\r\nvc_val |= vdd->pmic_info->pmic_reg << vdd->vc_data->smps_volra_shift;\r\nvdd->write_reg(vc_val, prm_mod_offs,\r\nvdd->vc_data->vc_common->smps_volra_reg);\r\nvc_val = vdd->read_reg(prm_mod_offs, vdd->vfsm->voltsetup_reg);\r\nvc_val &= ~vdd->vfsm->voltsetup_mask;\r\nvc_val |= vdd->pmic_info->volt_setup_time <<\r\nvdd->vfsm->voltsetup_shift;\r\nvdd->write_reg(vc_val, prm_mod_offs, vdd->vfsm->voltsetup_reg);\r\nif (cpu_is_omap34xx())\r\nomap3_vc_init(vdd);\r\nelse if (cpu_is_omap44xx())\r\nomap4_vc_init(vdd);\r\n}\r\nstatic int __init omap_vdd_data_configure(struct omap_vdd_info *vdd)\r\n{\r\nint ret = -EINVAL;\r\nif (!vdd->pmic_info) {\r\npr_err("%s: PMIC info requried to configure vdd_%s not"\r\n"populated.Hence cannot initialize vdd_%s\n",\r\n__func__, vdd->voltdm.name, vdd->voltdm.name);\r\ngoto ovdc_out;\r\n}\r\nif (IS_ERR_VALUE(_config_common_vdd_data(vdd)))\r\ngoto ovdc_out;\r\nif (cpu_is_omap34xx()) {\r\nvdd->read_reg = omap3_voltage_read_reg;\r\nvdd->write_reg = omap3_voltage_write_reg;\r\nret = 0;\r\n} else if (cpu_is_omap44xx()) {\r\nvdd->read_reg = omap4_voltage_read_reg;\r\nvdd->write_reg = omap4_voltage_write_reg;\r\nret = 0;\r\n}\r\novdc_out:\r\nreturn ret;\r\n}\r\nunsigned long omap_voltage_get_nom_volt(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn 0;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nreturn vdd->curr_volt;\r\n}\r\nunsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nu8 curr_vsel;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn 0;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nif (!vdd->read_reg) {\r\npr_err("%s: No read API for reading vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn 0;\r\n}\r\ncurr_vsel = vdd->read_reg(prm_mod_offs, vdd->vp_data->voltage);\r\nif (!vdd->pmic_info || !vdd->pmic_info->vsel_to_uv) {\r\npr_warning("%s: PMIC function to convert vsel to voltage"\r\n"in uV not registerd\n", __func__);\r\nreturn 0;\r\n}\r\nreturn vdd->pmic_info->vsel_to_uv(curr_vsel);\r\n}\r\nvoid omap_vp_enable(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nu32 vpconfig;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nif (!vdd->read_reg || !vdd->write_reg) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nif (vdd->vp_enabled)\r\nreturn;\r\nvp_latch_vsel(vdd);\r\nvpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);\r\nvpconfig |= vdd->vp_data->vp_common->vpconfig_vpenable;\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\nvdd->vp_enabled = true;\r\n}\r\nvoid omap_vp_disable(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nu32 vpconfig;\r\nint timeout;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nif (!vdd->read_reg || !vdd->write_reg) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nif (!vdd->vp_enabled) {\r\npr_warning("%s: Trying to disable VP for vdd_%s when"\r\n"it is already disabled\n", __func__, voltdm->name);\r\nreturn;\r\n}\r\nvpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);\r\nvpconfig &= ~vdd->vp_data->vp_common->vpconfig_vpenable;\r\nvdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);\r\nomap_test_timeout((vdd->read_reg(prm_mod_offs, vdd->vp_data->vstatus)),\r\nVP_IDLE_TIMEOUT, timeout);\r\nif (timeout >= VP_IDLE_TIMEOUT)\r\npr_warning("%s: vdd_%s idle timedout\n",\r\n__func__, voltdm->name);\r\nvdd->vp_enabled = false;\r\nreturn;\r\n}\r\nint omap_voltage_scale_vdd(struct voltagedomain *voltdm,\r\nunsigned long target_volt)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nif (!vdd->volt_scale) {\r\npr_err("%s: No voltage scale API registered for vdd_%s\n",\r\n__func__, voltdm->name);\r\nreturn -ENODATA;\r\n}\r\nreturn vdd->volt_scale(vdd, target_volt);\r\n}\r\nvoid omap_voltage_reset(struct voltagedomain *voltdm)\r\n{\r\nunsigned long target_uvdc;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn;\r\n}\r\ntarget_uvdc = omap_voltage_get_nom_volt(voltdm);\r\nif (!target_uvdc) {\r\npr_err("%s: unable to find current voltage for vdd_%s\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nomap_voltage_scale_vdd(voltdm, target_uvdc);\r\n}\r\nvoid omap_voltage_get_volttable(struct voltagedomain *voltdm,\r\nstruct omap_volt_data **volt_data)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\n*volt_data = vdd->volt_data;\r\n}\r\nstruct omap_volt_data *omap_voltage_get_voltdata(struct voltagedomain *voltdm,\r\nunsigned long volt)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nint i;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nif (!vdd->volt_data) {\r\npr_warning("%s: voltage table does not exist for vdd_%s\n",\r\n__func__, voltdm->name);\r\nreturn ERR_PTR(-ENODATA);\r\n}\r\nfor (i = 0; vdd->volt_data[i].volt_nominal != 0; i++) {\r\nif (vdd->volt_data[i].volt_nominal == volt)\r\nreturn &vdd->volt_data[i];\r\n}\r\npr_notice("%s: Unable to match the current voltage with the voltage"\r\n"table for vdd_%s\n", __func__, voltdm->name);\r\nreturn ERR_PTR(-ENODATA);\r\n}\r\nint omap_voltage_register_pmic(struct voltagedomain *voltdm,\r\nstruct omap_volt_pmic_info *pmic_info)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nvdd->pmic_info = pmic_info;\r\nreturn 0;\r\n}\r\nstruct dentry *omap_voltage_get_dbgdir(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn NULL;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nreturn vdd->debug_dir;\r\n}\r\nvoid omap_change_voltscale_method(struct voltagedomain *voltdm,\r\nint voltscale_method)\r\n{\r\nstruct omap_vdd_info *vdd;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn;\r\n}\r\nvdd = container_of(voltdm, struct omap_vdd_info, voltdm);\r\nswitch (voltscale_method) {\r\ncase VOLTSCALE_VPFORCEUPDATE:\r\nvdd->volt_scale = vp_forceupdate_scale_voltage;\r\nreturn;\r\ncase VOLTSCALE_VCBYPASS:\r\nvdd->volt_scale = vc_bypass_scale_voltage;\r\nreturn;\r\ndefault:\r\npr_warning("%s: Trying to change the method of voltage scaling"\r\n"to an unsupported one!\n", __func__);\r\n}\r\n}\r\nstruct voltagedomain *omap_voltage_domain_lookup(char *name)\r\n{\r\nint i;\r\nif (!vdd_info) {\r\npr_err("%s: Voltage driver init not yet happened.Faulting!\n",\r\n__func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!name) {\r\npr_err("%s: No name to get the votage domain!\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfor (i = 0; i < nr_scalable_vdd; i++) {\r\nif (!(strcmp(name, vdd_info[i]->voltdm.name)))\r\nreturn &vdd_info[i]->voltdm;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nint __init omap_voltage_late_init(void)\r\n{\r\nint i;\r\nif (!vdd_info) {\r\npr_err("%s: Voltage driver support not added\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nvoltage_dir = debugfs_create_dir("voltage", NULL);\r\nif (IS_ERR(voltage_dir))\r\npr_err("%s: Unable to create voltage debugfs main dir\n",\r\n__func__);\r\nfor (i = 0; i < nr_scalable_vdd; i++) {\r\nif (omap_vdd_data_configure(vdd_info[i]))\r\ncontinue;\r\nomap_vc_init(vdd_info[i]);\r\nvp_init(vdd_info[i]);\r\nvdd_debugfs_init(vdd_info[i]);\r\n}\r\nreturn 0;\r\n}\r\nint __init omap_voltage_early_init(s16 prm_mod, s16 prm_irqst_ocp_mod,\r\nstruct omap_vdd_info *omap_vdd_array[],\r\nu8 omap_vdd_count)\r\n{\r\nprm_mod_offs = prm_mod;\r\nprm_irqst_ocp_mod_offs = prm_irqst_ocp_mod;\r\nvdd_info = omap_vdd_array;\r\nnr_scalable_vdd = omap_vdd_count;\r\nreturn 0;\r\n}
