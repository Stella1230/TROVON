static inline void viafb_mmio_write(int reg, u32 v)\r\n{\r\niowrite32(v, global_dev.engine_mmio + reg);\r\n}\r\nstatic inline int viafb_mmio_read(int reg)\r\n{\r\nreturn ioread32(global_dev.engine_mmio + reg);\r\n}\r\nstatic void __devinit viafb_int_init(void)\r\n{\r\nviafb_enabled_ints = 0;\r\nviafb_mmio_write(VDE_INTERRUPT, 0);\r\n}\r\nvoid viafb_irq_enable(u32 mask)\r\n{\r\nviafb_enabled_ints |= mask;\r\nviafb_mmio_write(VDE_INTERRUPT, viafb_enabled_ints | VDE_I_ENABLE);\r\n}\r\nvoid viafb_irq_disable(u32 mask)\r\n{\r\nviafb_enabled_ints &= ~mask;\r\nif (viafb_enabled_ints == 0)\r\nviafb_mmio_write(VDE_INTERRUPT, 0);\r\nelse\r\nviafb_mmio_write(VDE_INTERRUPT,\r\nviafb_enabled_ints | VDE_I_ENABLE);\r\n}\r\nstatic irqreturn_t viafb_dma_irq(int irq, void *data)\r\n{\r\nint csr;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&global_dev.reg_lock);\r\ncsr = viafb_mmio_read(VDMA_CSR0);\r\nif (csr & VDMA_C_DONE) {\r\nviafb_mmio_write(VDMA_CSR0, VDMA_C_DONE);\r\ncomplete(&viafb_dma_completion);\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock(&global_dev.reg_lock);\r\nreturn ret;\r\n}\r\nint viafb_request_dma(void)\r\n{\r\nint ret = 0;\r\nif (global_dev.chip_type != UNICHROME_VX855)\r\nreturn -ENODEV;\r\nmutex_lock(&viafb_dma_lock);\r\nviafb_dma_users++;\r\nif (viafb_dma_users == 1) {\r\nret = request_irq(global_dev.pdev->irq, viafb_dma_irq,\r\nIRQF_SHARED, "via-dma", &viafb_dma_users);\r\nif (ret)\r\nviafb_dma_users--;\r\nelse\r\nviafb_irq_enable(VDE_I_DMA0TDEN);\r\n}\r\nmutex_unlock(&viafb_dma_lock);\r\nreturn ret;\r\n}\r\nvoid viafb_release_dma(void)\r\n{\r\nmutex_lock(&viafb_dma_lock);\r\nviafb_dma_users--;\r\nif (viafb_dma_users == 0) {\r\nviafb_irq_disable(VDE_I_DMA0TDEN);\r\nfree_irq(global_dev.pdev->irq, &viafb_dma_users);\r\n}\r\nmutex_unlock(&viafb_dma_lock);\r\n}\r\nint viafb_dma_copy_out_sg(unsigned int offset, struct scatterlist *sg, int nsg)\r\n{\r\nstruct viafb_vx855_dma_descr *descr;\r\nvoid *descrpages;\r\ndma_addr_t descr_handle;\r\nunsigned long flags;\r\nint i;\r\nstruct scatterlist *sgentry;\r\ndma_addr_t nextdesc;\r\ndescrpages = dma_alloc_coherent(&global_dev.pdev->dev,\r\nnsg*sizeof(struct viafb_vx855_dma_descr),\r\n&descr_handle, GFP_KERNEL);\r\nif (descrpages == NULL) {\r\ndev_err(&global_dev.pdev->dev, "Unable to get descr page.\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&viafb_dma_lock);\r\ndescr = descrpages;\r\nnextdesc = descr_handle + sizeof(struct viafb_vx855_dma_descr);\r\nfor_each_sg(sg, sgentry, nsg, i) {\r\ndma_addr_t paddr = sg_dma_address(sgentry);\r\ndescr->addr_low = paddr & 0xfffffff0;\r\ndescr->addr_high = ((u64) paddr >> 32) & 0x0fff;\r\ndescr->fb_offset = offset;\r\ndescr->seg_size = sg_dma_len(sgentry) >> 4;\r\ndescr->tile_mode = 0;\r\ndescr->next_desc_low = (nextdesc&0xfffffff0) | VIAFB_DMA_MAGIC;\r\ndescr->next_desc_high = ((u64) nextdesc >> 32) & 0x0fff;\r\ndescr->pad = 0xffffffff;\r\noffset += sg_dma_len(sgentry);\r\nnextdesc += sizeof(struct viafb_vx855_dma_descr);\r\ndescr++;\r\n}\r\ndescr[-1].next_desc_low = VIAFB_DMA_FINAL_SEGMENT|VIAFB_DMA_MAGIC;\r\nspin_lock_irqsave(&global_dev.reg_lock, flags);\r\ninit_completion(&viafb_dma_completion);\r\nviafb_mmio_write(VDMA_DQWCR0, 0);\r\nviafb_mmio_write(VDMA_CSR0, VDMA_C_ENABLE|VDMA_C_DONE);\r\nviafb_mmio_write(VDMA_MR0, VDMA_MR_TDIE | VDMA_MR_CHAIN);\r\nviafb_mmio_write(VDMA_DPRL0, descr_handle | VIAFB_DMA_MAGIC);\r\nviafb_mmio_write(VDMA_DPRH0,\r\n(((u64)descr_handle >> 32) & 0x0fff) | 0xf0000);\r\n(void) viafb_mmio_read(VDMA_CSR0);\r\nviafb_mmio_write(VDMA_CSR0, VDMA_C_ENABLE|VDMA_C_START);\r\nspin_unlock_irqrestore(&global_dev.reg_lock, flags);\r\nwait_for_completion_timeout(&viafb_dma_completion, 1);\r\nmsleep(1);\r\nif ((viafb_mmio_read(VDMA_CSR0)&VDMA_C_DONE) == 0)\r\nprintk(KERN_ERR "VIA DMA timeout!\n");\r\nviafb_mmio_write(VDMA_CSR0, VDMA_C_DONE);\r\nviafb_mmio_write(VDMA_MR0, 0);\r\nmutex_unlock(&viafb_dma_lock);\r\ndma_free_coherent(&global_dev.pdev->dev,\r\nnsg*sizeof(struct viafb_vx855_dma_descr), descrpages,\r\ndescr_handle);\r\nreturn 0;\r\n}\r\nstatic int viafb_get_fb_size_from_pci(int chip_type)\r\n{\r\nint i;\r\nu8 offset = 0;\r\nu32 FBSize;\r\nu32 VideoMemSize;\r\nfor (i = 0; i < ARRAY_SIZE(via_function3); i++) {\r\nstruct pci_dev *pdev;\r\npdev = pci_get_device(PCI_VENDOR_ID_VIA, via_function3[i],\r\nNULL);\r\nif (!pdev)\r\ncontinue;\r\nDEBUG_MSG(KERN_INFO "Device ID = %x\n", pdev->device);\r\nswitch (pdev->device) {\r\ncase CLE266_FUNCTION3:\r\ncase KM400_FUNCTION3:\r\noffset = 0xE0;\r\nbreak;\r\ncase CN400_FUNCTION3:\r\ncase CN700_FUNCTION3:\r\ncase CX700_FUNCTION3:\r\ncase KM800_FUNCTION3:\r\ncase KM890_FUNCTION3:\r\ncase P4M890_FUNCTION3:\r\ncase P4M900_FUNCTION3:\r\ncase VX800_FUNCTION3:\r\ncase VX855_FUNCTION3:\r\ncase VX900_FUNCTION3:\r\noffset = 0xA0;\r\nbreak;\r\n}\r\nif (!offset)\r\nbreak;\r\npci_read_config_dword(pdev, offset, &FBSize);\r\npci_dev_put(pdev);\r\n}\r\nif (!offset) {\r\nprintk(KERN_ERR "cannot determine framebuffer size\n");\r\nreturn -EIO;\r\n}\r\nFBSize = FBSize & 0x00007000;\r\nDEBUG_MSG(KERN_INFO "FB Size = %x\n", FBSize);\r\nif (chip_type < UNICHROME_CX700) {\r\nswitch (FBSize) {\r\ncase 0x00004000:\r\nVideoMemSize = (16 << 20);\r\nbreak;\r\ncase 0x00005000:\r\nVideoMemSize = (32 << 20);\r\nbreak;\r\ncase 0x00006000:\r\nVideoMemSize = (64 << 20);\r\nbreak;\r\ndefault:\r\nVideoMemSize = (32 << 20);\r\nbreak;\r\n}\r\n} else {\r\nswitch (FBSize) {\r\ncase 0x00001000:\r\nVideoMemSize = (8 << 20);\r\nbreak;\r\ncase 0x00002000:\r\nVideoMemSize = (16 << 20);\r\nbreak;\r\ncase 0x00003000:\r\nVideoMemSize = (32 << 20);\r\nbreak;\r\ncase 0x00004000:\r\nVideoMemSize = (64 << 20);\r\nbreak;\r\ncase 0x00005000:\r\nVideoMemSize = (128 << 20);\r\nbreak;\r\ncase 0x00006000:\r\nVideoMemSize = (256 << 20);\r\nbreak;\r\ncase 0x00007000:\r\nVideoMemSize = (512 << 20);\r\nbreak;\r\ndefault:\r\nVideoMemSize = (32 << 20);\r\nbreak;\r\n}\r\n}\r\nreturn VideoMemSize;\r\n}\r\nstatic int __devinit via_pci_setup_mmio(struct viafb_dev *vdev)\r\n{\r\nint ret;\r\nvdev->engine_start = pci_resource_start(vdev->pdev, 1);\r\nvdev->engine_len = pci_resource_len(vdev->pdev, 1);\r\nvdev->engine_mmio = ioremap_nocache(vdev->engine_start,\r\nvdev->engine_len);\r\nif (vdev->engine_mmio == NULL)\r\ndev_err(&vdev->pdev->dev,\r\n"Unable to map engine MMIO; operation will be "\r\n"slow and crippled.\n");\r\nif (vdev->chip_type == UNICHROME_VX900)\r\nvdev->fbmem_start = pci_resource_start(vdev->pdev, 2);\r\nelse\r\nvdev->fbmem_start = pci_resource_start(vdev->pdev, 0);\r\nret = vdev->fbmem_len = viafb_get_fb_size_from_pci(vdev->chip_type);\r\nif (ret < 0)\r\ngoto out_unmap;\r\nfor (; vdev->fbmem_len >= 8 << 20; vdev->fbmem_len /= 2) {\r\nvdev->fbmem = ioremap_wc(vdev->fbmem_start, vdev->fbmem_len);\r\nif (vdev->fbmem)\r\nbreak;\r\n}\r\nif (vdev->fbmem == NULL) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nreturn 0;\r\nout_unmap:\r\niounmap(vdev->engine_mmio);\r\nreturn ret;\r\n}\r\nstatic void via_pci_teardown_mmio(struct viafb_dev *vdev)\r\n{\r\niounmap(vdev->fbmem);\r\niounmap(vdev->engine_mmio);\r\n}\r\nstatic int __devinit via_create_subdev(struct viafb_dev *vdev,\r\nstruct viafb_subdev_info *info)\r\n{\r\nint ret;\r\ninfo->platdev = platform_device_alloc(info->name, -1);\r\nif (!info->platdev) {\r\ndev_err(&vdev->pdev->dev, "Unable to allocate pdev %s\n",\r\ninfo->name);\r\nreturn -ENOMEM;\r\n}\r\ninfo->platdev->dev.parent = &vdev->pdev->dev;\r\ninfo->platdev->dev.platform_data = vdev;\r\nret = platform_device_add(info->platdev);\r\nif (ret) {\r\ndev_err(&vdev->pdev->dev, "Unable to add pdev %s\n",\r\ninfo->name);\r\nplatform_device_put(info->platdev);\r\ninfo->platdev = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit via_setup_subdevs(struct viafb_dev *vdev)\r\n{\r\nint i;\r\nfor (i = 0; i < N_SUBDEVS; i++)\r\nvia_create_subdev(vdev, viafb_subdevs + i);\r\nreturn 0;\r\n}\r\nstatic void via_teardown_subdevs(void)\r\n{\r\nint i;\r\nfor (i = 0; i < N_SUBDEVS; i++)\r\nif (viafb_subdevs[i].platdev) {\r\nviafb_subdevs[i].platdev->dev.platform_data = NULL;\r\nplatform_device_unregister(viafb_subdevs[i].platdev);\r\n}\r\n}\r\nvoid viafb_pm_register(struct viafb_pm_hooks *hooks)\r\n{\r\nINIT_LIST_HEAD(&hooks->list);\r\nmutex_lock(&viafb_pm_hooks_lock);\r\nlist_add_tail(&hooks->list, &viafb_pm_hooks);\r\nmutex_unlock(&viafb_pm_hooks_lock);\r\n}\r\nvoid viafb_pm_unregister(struct viafb_pm_hooks *hooks)\r\n{\r\nmutex_lock(&viafb_pm_hooks_lock);\r\nlist_del(&hooks->list);\r\nmutex_unlock(&viafb_pm_hooks_lock);\r\n}\r\nstatic int via_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct viafb_pm_hooks *hooks;\r\nif (state.event != PM_EVENT_SUSPEND)\r\nreturn 0;\r\nmutex_lock(&viafb_pm_hooks_lock);\r\nlist_for_each_entry_reverse(hooks, &viafb_pm_hooks, list)\r\nhooks->suspend(hooks->private);\r\nmutex_unlock(&viafb_pm_hooks_lock);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int via_resume(struct pci_dev *pdev)\r\n{\r\nstruct viafb_pm_hooks *hooks;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif (pci_enable_device(pdev))\r\nreturn 0;\r\npci_set_master(pdev);\r\nmutex_lock(&viafb_pm_hooks_lock);\r\nlist_for_each_entry(hooks, &viafb_pm_hooks, list)\r\nhooks->resume(hooks->private);\r\nmutex_unlock(&viafb_pm_hooks_lock);\r\nreturn 0;\r\n}\r\nstatic int __devinit via_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret;\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nmemset(&global_dev, 0, sizeof(global_dev));\r\nglobal_dev.pdev = pdev;\r\nglobal_dev.chip_type = ent->driver_data;\r\nglobal_dev.port_cfg = adap_configs;\r\nif (machine_is_olpc())\r\nglobal_dev.port_cfg = olpc_adap_configs;\r\nspin_lock_init(&global_dev.reg_lock);\r\nret = via_pci_setup_mmio(&global_dev);\r\nif (ret)\r\ngoto out_disable;\r\nviafb_int_init();\r\nvia_setup_subdevs(&global_dev);\r\nret = via_fb_pci_probe(&global_dev);\r\nif (ret)\r\ngoto out_subdevs;\r\nreturn 0;\r\nout_subdevs:\r\nvia_teardown_subdevs();\r\nvia_pci_teardown_mmio(&global_dev);\r\nout_disable:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void __devexit via_pci_remove(struct pci_dev *pdev)\r\n{\r\nvia_teardown_subdevs();\r\nvia_fb_pci_remove(pdev);\r\nvia_pci_teardown_mmio(&global_dev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init via_core_init(void)\r\n{\r\nint ret;\r\nret = viafb_init();\r\nif (ret)\r\nreturn ret;\r\nviafb_i2c_init();\r\nviafb_gpio_init();\r\nreturn pci_register_driver(&via_driver);\r\n}\r\nstatic void __exit via_core_exit(void)\r\n{\r\npci_unregister_driver(&via_driver);\r\nviafb_gpio_exit();\r\nviafb_i2c_exit();\r\nviafb_exit();\r\n}
