static unsigned long long next_sqnum(struct ubi_device *ubi)\r\n{\r\nunsigned long long sqnum;\r\nspin_lock(&ubi->ltree_lock);\r\nsqnum = ubi->global_sqnum++;\r\nspin_unlock(&ubi->ltree_lock);\r\nreturn sqnum;\r\n}\r\nstatic int ubi_get_compat(const struct ubi_device *ubi, int vol_id)\r\n{\r\nif (vol_id == UBI_LAYOUT_VOLUME_ID)\r\nreturn UBI_LAYOUT_VOLUME_COMPAT;\r\nreturn 0;\r\n}\r\nstatic struct ubi_ltree_entry *ltree_lookup(struct ubi_device *ubi, int vol_id,\r\nint lnum)\r\n{\r\nstruct rb_node *p;\r\np = ubi->ltree.rb_node;\r\nwhile (p) {\r\nstruct ubi_ltree_entry *le;\r\nle = rb_entry(p, struct ubi_ltree_entry, rb);\r\nif (vol_id < le->vol_id)\r\np = p->rb_left;\r\nelse if (vol_id > le->vol_id)\r\np = p->rb_right;\r\nelse {\r\nif (lnum < le->lnum)\r\np = p->rb_left;\r\nelse if (lnum > le->lnum)\r\np = p->rb_right;\r\nelse\r\nreturn le;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ubi_ltree_entry *ltree_add_entry(struct ubi_device *ubi,\r\nint vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le, *le1, *le_free;\r\nle = kmalloc(sizeof(struct ubi_ltree_entry), GFP_NOFS);\r\nif (!le)\r\nreturn ERR_PTR(-ENOMEM);\r\nle->users = 0;\r\ninit_rwsem(&le->mutex);\r\nle->vol_id = vol_id;\r\nle->lnum = lnum;\r\nspin_lock(&ubi->ltree_lock);\r\nle1 = ltree_lookup(ubi, vol_id, lnum);\r\nif (le1) {\r\nle_free = le;\r\nle = le1;\r\n} else {\r\nstruct rb_node **p, *parent = NULL;\r\nle_free = NULL;\r\np = &ubi->ltree.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nle1 = rb_entry(parent, struct ubi_ltree_entry, rb);\r\nif (vol_id < le1->vol_id)\r\np = &(*p)->rb_left;\r\nelse if (vol_id > le1->vol_id)\r\np = &(*p)->rb_right;\r\nelse {\r\nubi_assert(lnum != le1->lnum);\r\nif (lnum < le1->lnum)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\n}\r\nrb_link_node(&le->rb, parent, p);\r\nrb_insert_color(&le->rb, &ubi->ltree);\r\n}\r\nle->users += 1;\r\nspin_unlock(&ubi->ltree_lock);\r\nkfree(le_free);\r\nreturn le;\r\n}\r\nstatic int leb_read_lock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nle = ltree_add_entry(ubi, vol_id, lnum);\r\nif (IS_ERR(le))\r\nreturn PTR_ERR(le);\r\ndown_read(&le->mutex);\r\nreturn 0;\r\n}\r\nstatic void leb_read_unlock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nspin_lock(&ubi->ltree_lock);\r\nle = ltree_lookup(ubi, vol_id, lnum);\r\nle->users -= 1;\r\nubi_assert(le->users >= 0);\r\nup_read(&le->mutex);\r\nif (le->users == 0) {\r\nrb_erase(&le->rb, &ubi->ltree);\r\nkfree(le);\r\n}\r\nspin_unlock(&ubi->ltree_lock);\r\n}\r\nstatic int leb_write_lock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nle = ltree_add_entry(ubi, vol_id, lnum);\r\nif (IS_ERR(le))\r\nreturn PTR_ERR(le);\r\ndown_write(&le->mutex);\r\nreturn 0;\r\n}\r\nstatic int leb_write_trylock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nle = ltree_add_entry(ubi, vol_id, lnum);\r\nif (IS_ERR(le))\r\nreturn PTR_ERR(le);\r\nif (down_write_trylock(&le->mutex))\r\nreturn 0;\r\nspin_lock(&ubi->ltree_lock);\r\nle->users -= 1;\r\nubi_assert(le->users >= 0);\r\nif (le->users == 0) {\r\nrb_erase(&le->rb, &ubi->ltree);\r\nkfree(le);\r\n}\r\nspin_unlock(&ubi->ltree_lock);\r\nreturn 1;\r\n}\r\nstatic void leb_write_unlock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nspin_lock(&ubi->ltree_lock);\r\nle = ltree_lookup(ubi, vol_id, lnum);\r\nle->users -= 1;\r\nubi_assert(le->users >= 0);\r\nup_write(&le->mutex);\r\nif (le->users == 0) {\r\nrb_erase(&le->rb, &ubi->ltree);\r\nkfree(le);\r\n}\r\nspin_unlock(&ubi->ltree_lock);\r\n}\r\nint ubi_eba_unmap_leb(struct ubi_device *ubi, struct ubi_volume *vol,\r\nint lnum)\r\n{\r\nint err, pnum, vol_id = vol->vol_id;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nerr = leb_write_lock(ubi, vol_id, lnum);\r\nif (err)\r\nreturn err;\r\npnum = vol->eba_tbl[lnum];\r\nif (pnum < 0)\r\ngoto out_unlock;\r\ndbg_eba("erase LEB %d:%d, PEB %d", vol_id, lnum, pnum);\r\nvol->eba_tbl[lnum] = UBI_LEB_UNMAPPED;\r\nerr = ubi_wl_put_peb(ubi, pnum, 0);\r\nout_unlock:\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\n}\r\nint ubi_eba_read_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\r\nvoid *buf, int offset, int len, int check)\r\n{\r\nint err, pnum, scrub = 0, vol_id = vol->vol_id;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nuint32_t uninitialized_var(crc);\r\nerr = leb_read_lock(ubi, vol_id, lnum);\r\nif (err)\r\nreturn err;\r\npnum = vol->eba_tbl[lnum];\r\nif (pnum < 0) {\r\ndbg_eba("read %d bytes from offset %d of LEB %d:%d (unmapped)",\r\nlen, offset, vol_id, lnum);\r\nleb_read_unlock(ubi, vol_id, lnum);\r\nubi_assert(vol->vol_type != UBI_STATIC_VOLUME);\r\nmemset(buf, 0xFF, len);\r\nreturn 0;\r\n}\r\ndbg_eba("read %d bytes from offset %d of LEB %d:%d, PEB %d",\r\nlen, offset, vol_id, lnum, pnum);\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME)\r\ncheck = 0;\r\nretry:\r\nif (check) {\r\nvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\r\nif (!vid_hdr) {\r\nerr = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nerr = ubi_io_read_vid_hdr(ubi, pnum, vid_hdr, 1);\r\nif (err && err != UBI_IO_BITFLIPS) {\r\nif (err > 0) {\r\nif (err == UBI_IO_BAD_HDR_EBADMSG ||\r\nerr == UBI_IO_BAD_HDR) {\r\nubi_warn("corrupted VID header at PEB "\r\n"%d, LEB %d:%d", pnum, vol_id,\r\nlnum);\r\nerr = -EBADMSG;\r\n} else\r\nubi_ro_mode(ubi);\r\n}\r\ngoto out_free;\r\n} else if (err == UBI_IO_BITFLIPS)\r\nscrub = 1;\r\nubi_assert(lnum < be32_to_cpu(vid_hdr->used_ebs));\r\nubi_assert(len == be32_to_cpu(vid_hdr->data_size));\r\ncrc = be32_to_cpu(vid_hdr->data_crc);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\n}\r\nerr = ubi_io_read_data(ubi, buf, pnum, offset, len);\r\nif (err) {\r\nif (err == UBI_IO_BITFLIPS) {\r\nscrub = 1;\r\nerr = 0;\r\n} else if (err == -EBADMSG) {\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME)\r\ngoto out_unlock;\r\nscrub = 1;\r\nif (!check) {\r\nubi_msg("force data checking");\r\ncheck = 1;\r\ngoto retry;\r\n}\r\n} else\r\ngoto out_unlock;\r\n}\r\nif (check) {\r\nuint32_t crc1 = crc32(UBI_CRC32_INIT, buf, len);\r\nif (crc1 != crc) {\r\nubi_warn("CRC error: calculated %#08x, must be %#08x",\r\ncrc1, crc);\r\nerr = -EBADMSG;\r\ngoto out_unlock;\r\n}\r\n}\r\nif (scrub)\r\nerr = ubi_wl_scrub_peb(ubi, pnum);\r\nleb_read_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\nout_free:\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nout_unlock:\r\nleb_read_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\n}\r\nstatic int recover_peb(struct ubi_device *ubi, int pnum, int vol_id, int lnum,\r\nconst void *buf, int offset, int len)\r\n{\r\nint err, idx = vol_id2idx(ubi, vol_id), new_pnum, data_size, tries = 0;\r\nstruct ubi_volume *vol = ubi->volumes[idx];\r\nstruct ubi_vid_hdr *vid_hdr;\r\nvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\r\nif (!vid_hdr)\r\nreturn -ENOMEM;\r\nretry:\r\nnew_pnum = ubi_wl_get_peb(ubi, UBI_UNKNOWN);\r\nif (new_pnum < 0) {\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn new_pnum;\r\n}\r\nubi_msg("recover PEB %d, move data to PEB %d", pnum, new_pnum);\r\nerr = ubi_io_read_vid_hdr(ubi, pnum, vid_hdr, 1);\r\nif (err && err != UBI_IO_BITFLIPS) {\r\nif (err > 0)\r\nerr = -EIO;\r\ngoto out_put;\r\n}\r\nvid_hdr->sqnum = cpu_to_be64(next_sqnum(ubi));\r\nerr = ubi_io_write_vid_hdr(ubi, new_pnum, vid_hdr);\r\nif (err)\r\ngoto write_error;\r\ndata_size = offset + len;\r\nmutex_lock(&ubi->buf_mutex);\r\nmemset(ubi->peb_buf1 + offset, 0xFF, len);\r\nif (offset > 0) {\r\nerr = ubi_io_read_data(ubi, ubi->peb_buf1, pnum, 0, offset);\r\nif (err && err != UBI_IO_BITFLIPS)\r\ngoto out_unlock;\r\n}\r\nmemcpy(ubi->peb_buf1 + offset, buf, len);\r\nerr = ubi_io_write_data(ubi, ubi->peb_buf1, new_pnum, 0, data_size);\r\nif (err) {\r\nmutex_unlock(&ubi->buf_mutex);\r\ngoto write_error;\r\n}\r\nmutex_unlock(&ubi->buf_mutex);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nvol->eba_tbl[lnum] = new_pnum;\r\nubi_wl_put_peb(ubi, pnum, 1);\r\nubi_msg("data was successfully recovered");\r\nreturn 0;\r\nout_unlock:\r\nmutex_unlock(&ubi->buf_mutex);\r\nout_put:\r\nubi_wl_put_peb(ubi, new_pnum, 1);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\nwrite_error:\r\nubi_warn("failed to write to PEB %d", new_pnum);\r\nubi_wl_put_peb(ubi, new_pnum, 1);\r\nif (++tries > UBI_IO_RETRIES) {\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\n}\r\nubi_msg("try again");\r\ngoto retry;\r\n}\r\nint ubi_eba_write_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\r\nconst void *buf, int offset, int len, int dtype)\r\n{\r\nint err, pnum, tries = 0, vol_id = vol->vol_id;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nerr = leb_write_lock(ubi, vol_id, lnum);\r\nif (err)\r\nreturn err;\r\npnum = vol->eba_tbl[lnum];\r\nif (pnum >= 0) {\r\ndbg_eba("write %d bytes at offset %d of LEB %d:%d, PEB %d",\r\nlen, offset, vol_id, lnum, pnum);\r\nerr = ubi_io_write_data(ubi, buf, pnum, offset, len);\r\nif (err) {\r\nubi_warn("failed to write data to PEB %d", pnum);\r\nif (err == -EIO && ubi->bad_allowed)\r\nerr = recover_peb(ubi, pnum, vol_id, lnum, buf,\r\noffset, len);\r\nif (err)\r\nubi_ro_mode(ubi);\r\n}\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\n}\r\nvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\r\nif (!vid_hdr) {\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn -ENOMEM;\r\n}\r\nvid_hdr->vol_type = UBI_VID_DYNAMIC;\r\nvid_hdr->sqnum = cpu_to_be64(next_sqnum(ubi));\r\nvid_hdr->vol_id = cpu_to_be32(vol_id);\r\nvid_hdr->lnum = cpu_to_be32(lnum);\r\nvid_hdr->compat = ubi_get_compat(ubi, vol_id);\r\nvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\r\nretry:\r\npnum = ubi_wl_get_peb(ubi, dtype);\r\nif (pnum < 0) {\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn pnum;\r\n}\r\ndbg_eba("write VID hdr and %d bytes at offset %d of LEB %d:%d, PEB %d",\r\nlen, offset, vol_id, lnum, pnum);\r\nerr = ubi_io_write_vid_hdr(ubi, pnum, vid_hdr);\r\nif (err) {\r\nubi_warn("failed to write VID header to LEB %d:%d, PEB %d",\r\nvol_id, lnum, pnum);\r\ngoto write_error;\r\n}\r\nif (len) {\r\nerr = ubi_io_write_data(ubi, buf, pnum, offset, len);\r\nif (err) {\r\nubi_warn("failed to write %d bytes at offset %d of "\r\n"LEB %d:%d, PEB %d", len, offset, vol_id,\r\nlnum, pnum);\r\ngoto write_error;\r\n}\r\n}\r\nvol->eba_tbl[lnum] = pnum;\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn 0;\r\nwrite_error:\r\nif (err != -EIO || !ubi->bad_allowed) {\r\nubi_ro_mode(ubi);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\n}\r\nerr = ubi_wl_put_peb(ubi, pnum, 1);\r\nif (err || ++tries > UBI_IO_RETRIES) {\r\nubi_ro_mode(ubi);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\n}\r\nvid_hdr->sqnum = cpu_to_be64(next_sqnum(ubi));\r\nubi_msg("try another PEB");\r\ngoto retry;\r\n}\r\nint ubi_eba_write_leb_st(struct ubi_device *ubi, struct ubi_volume *vol,\r\nint lnum, const void *buf, int len, int dtype,\r\nint used_ebs)\r\n{\r\nint err, pnum, tries = 0, data_size = len, vol_id = vol->vol_id;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nuint32_t crc;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nif (lnum == used_ebs - 1)\r\nlen = ALIGN(data_size, ubi->min_io_size);\r\nelse\r\nubi_assert(!(len & (ubi->min_io_size - 1)));\r\nvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\r\nif (!vid_hdr)\r\nreturn -ENOMEM;\r\nerr = leb_write_lock(ubi, vol_id, lnum);\r\nif (err) {\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\n}\r\nvid_hdr->sqnum = cpu_to_be64(next_sqnum(ubi));\r\nvid_hdr->vol_id = cpu_to_be32(vol_id);\r\nvid_hdr->lnum = cpu_to_be32(lnum);\r\nvid_hdr->compat = ubi_get_compat(ubi, vol_id);\r\nvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\r\ncrc = crc32(UBI_CRC32_INIT, buf, data_size);\r\nvid_hdr->vol_type = UBI_VID_STATIC;\r\nvid_hdr->data_size = cpu_to_be32(data_size);\r\nvid_hdr->used_ebs = cpu_to_be32(used_ebs);\r\nvid_hdr->data_crc = cpu_to_be32(crc);\r\nretry:\r\npnum = ubi_wl_get_peb(ubi, dtype);\r\nif (pnum < 0) {\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn pnum;\r\n}\r\ndbg_eba("write VID hdr and %d bytes at LEB %d:%d, PEB %d, used_ebs %d",\r\nlen, vol_id, lnum, pnum, used_ebs);\r\nerr = ubi_io_write_vid_hdr(ubi, pnum, vid_hdr);\r\nif (err) {\r\nubi_warn("failed to write VID header to LEB %d:%d, PEB %d",\r\nvol_id, lnum, pnum);\r\ngoto write_error;\r\n}\r\nerr = ubi_io_write_data(ubi, buf, pnum, 0, len);\r\nif (err) {\r\nubi_warn("failed to write %d bytes of data to PEB %d",\r\nlen, pnum);\r\ngoto write_error;\r\n}\r\nubi_assert(vol->eba_tbl[lnum] < 0);\r\nvol->eba_tbl[lnum] = pnum;\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn 0;\r\nwrite_error:\r\nif (err != -EIO || !ubi->bad_allowed) {\r\nubi_ro_mode(ubi);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\n}\r\nerr = ubi_wl_put_peb(ubi, pnum, 1);\r\nif (err || ++tries > UBI_IO_RETRIES) {\r\nubi_ro_mode(ubi);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\n}\r\nvid_hdr->sqnum = cpu_to_be64(next_sqnum(ubi));\r\nubi_msg("try another PEB");\r\ngoto retry;\r\n}\r\nint ubi_eba_atomic_leb_change(struct ubi_device *ubi, struct ubi_volume *vol,\r\nint lnum, const void *buf, int len, int dtype)\r\n{\r\nint err, pnum, tries = 0, vol_id = vol->vol_id;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nuint32_t crc;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nif (len == 0) {\r\nerr = ubi_eba_unmap_leb(ubi, vol, lnum);\r\nif (err)\r\nreturn err;\r\nreturn ubi_eba_write_leb(ubi, vol, lnum, NULL, 0, 0, dtype);\r\n}\r\nvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_NOFS);\r\nif (!vid_hdr)\r\nreturn -ENOMEM;\r\nmutex_lock(&ubi->alc_mutex);\r\nerr = leb_write_lock(ubi, vol_id, lnum);\r\nif (err)\r\ngoto out_mutex;\r\nvid_hdr->sqnum = cpu_to_be64(next_sqnum(ubi));\r\nvid_hdr->vol_id = cpu_to_be32(vol_id);\r\nvid_hdr->lnum = cpu_to_be32(lnum);\r\nvid_hdr->compat = ubi_get_compat(ubi, vol_id);\r\nvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\r\ncrc = crc32(UBI_CRC32_INIT, buf, len);\r\nvid_hdr->vol_type = UBI_VID_DYNAMIC;\r\nvid_hdr->data_size = cpu_to_be32(len);\r\nvid_hdr->copy_flag = 1;\r\nvid_hdr->data_crc = cpu_to_be32(crc);\r\nretry:\r\npnum = ubi_wl_get_peb(ubi, dtype);\r\nif (pnum < 0) {\r\nerr = pnum;\r\ngoto out_leb_unlock;\r\n}\r\ndbg_eba("change LEB %d:%d, PEB %d, write VID hdr to PEB %d",\r\nvol_id, lnum, vol->eba_tbl[lnum], pnum);\r\nerr = ubi_io_write_vid_hdr(ubi, pnum, vid_hdr);\r\nif (err) {\r\nubi_warn("failed to write VID header to LEB %d:%d, PEB %d",\r\nvol_id, lnum, pnum);\r\ngoto write_error;\r\n}\r\nerr = ubi_io_write_data(ubi, buf, pnum, 0, len);\r\nif (err) {\r\nubi_warn("failed to write %d bytes of data to PEB %d",\r\nlen, pnum);\r\ngoto write_error;\r\n}\r\nif (vol->eba_tbl[lnum] >= 0) {\r\nerr = ubi_wl_put_peb(ubi, vol->eba_tbl[lnum], 0);\r\nif (err)\r\ngoto out_leb_unlock;\r\n}\r\nvol->eba_tbl[lnum] = pnum;\r\nout_leb_unlock:\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nout_mutex:\r\nmutex_unlock(&ubi->alc_mutex);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\nwrite_error:\r\nif (err != -EIO || !ubi->bad_allowed) {\r\nubi_ro_mode(ubi);\r\ngoto out_leb_unlock;\r\n}\r\nerr = ubi_wl_put_peb(ubi, pnum, 1);\r\nif (err || ++tries > UBI_IO_RETRIES) {\r\nubi_ro_mode(ubi);\r\ngoto out_leb_unlock;\r\n}\r\nvid_hdr->sqnum = cpu_to_be64(next_sqnum(ubi));\r\nubi_msg("try another PEB");\r\ngoto retry;\r\n}\r\nstatic int is_error_sane(int err)\r\n{\r\nif (err == -EIO || err == -ENOMEM || err == UBI_IO_BAD_HDR ||\r\nerr == UBI_IO_BAD_HDR_EBADMSG || err == -ETIMEDOUT)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint ubi_eba_copy_leb(struct ubi_device *ubi, int from, int to,\r\nstruct ubi_vid_hdr *vid_hdr)\r\n{\r\nint err, vol_id, lnum, data_size, aldata_size, idx;\r\nstruct ubi_volume *vol;\r\nuint32_t crc;\r\nvol_id = be32_to_cpu(vid_hdr->vol_id);\r\nlnum = be32_to_cpu(vid_hdr->lnum);\r\ndbg_wl("copy LEB %d:%d, PEB %d to PEB %d", vol_id, lnum, from, to);\r\nif (vid_hdr->vol_type == UBI_VID_STATIC) {\r\ndata_size = be32_to_cpu(vid_hdr->data_size);\r\naldata_size = ALIGN(data_size, ubi->min_io_size);\r\n} else\r\ndata_size = aldata_size =\r\nubi->leb_size - be32_to_cpu(vid_hdr->data_pad);\r\nidx = vol_id2idx(ubi, vol_id);\r\nspin_lock(&ubi->volumes_lock);\r\nvol = ubi->volumes[idx];\r\nspin_unlock(&ubi->volumes_lock);\r\nif (!vol) {\r\ndbg_wl("volume %d is being removed, cancel", vol_id);\r\nreturn MOVE_CANCEL_RACE;\r\n}\r\nerr = leb_write_trylock(ubi, vol_id, lnum);\r\nif (err) {\r\ndbg_wl("contention on LEB %d:%d, cancel", vol_id, lnum);\r\nreturn MOVE_CANCEL_RACE;\r\n}\r\nif (vol->eba_tbl[lnum] != from) {\r\ndbg_wl("LEB %d:%d is no longer mapped to PEB %d, mapped to "\r\n"PEB %d, cancel", vol_id, lnum, from,\r\nvol->eba_tbl[lnum]);\r\nerr = MOVE_CANCEL_RACE;\r\ngoto out_unlock_leb;\r\n}\r\nmutex_lock(&ubi->buf_mutex);\r\ndbg_wl("read %d bytes of data", aldata_size);\r\nerr = ubi_io_read_data(ubi, ubi->peb_buf1, from, 0, aldata_size);\r\nif (err && err != UBI_IO_BITFLIPS) {\r\nubi_warn("error %d while reading data from PEB %d",\r\nerr, from);\r\nerr = MOVE_SOURCE_RD_ERR;\r\ngoto out_unlock_buf;\r\n}\r\nif (vid_hdr->vol_type == UBI_VID_DYNAMIC)\r\naldata_size = data_size =\r\nubi_calc_data_len(ubi, ubi->peb_buf1, data_size);\r\ncond_resched();\r\ncrc = crc32(UBI_CRC32_INIT, ubi->peb_buf1, data_size);\r\ncond_resched();\r\nif (data_size > 0) {\r\nvid_hdr->copy_flag = 1;\r\nvid_hdr->data_size = cpu_to_be32(data_size);\r\nvid_hdr->data_crc = cpu_to_be32(crc);\r\n}\r\nvid_hdr->sqnum = cpu_to_be64(next_sqnum(ubi));\r\nerr = ubi_io_write_vid_hdr(ubi, to, vid_hdr);\r\nif (err) {\r\nif (err == -EIO)\r\nerr = MOVE_TARGET_WR_ERR;\r\ngoto out_unlock_buf;\r\n}\r\ncond_resched();\r\nerr = ubi_io_read_vid_hdr(ubi, to, vid_hdr, 1);\r\nif (err) {\r\nif (err != UBI_IO_BITFLIPS) {\r\nubi_warn("error %d while reading VID header back from "\r\n"PEB %d", err, to);\r\nif (is_error_sane(err))\r\nerr = MOVE_TARGET_RD_ERR;\r\n} else\r\nerr = MOVE_CANCEL_BITFLIPS;\r\ngoto out_unlock_buf;\r\n}\r\nif (data_size > 0) {\r\nerr = ubi_io_write_data(ubi, ubi->peb_buf1, to, 0, aldata_size);\r\nif (err) {\r\nif (err == -EIO)\r\nerr = MOVE_TARGET_WR_ERR;\r\ngoto out_unlock_buf;\r\n}\r\ncond_resched();\r\nerr = ubi_io_read_data(ubi, ubi->peb_buf2, to, 0, aldata_size);\r\nif (err) {\r\nif (err != UBI_IO_BITFLIPS) {\r\nubi_warn("error %d while reading data back "\r\n"from PEB %d", err, to);\r\nif (is_error_sane(err))\r\nerr = MOVE_TARGET_RD_ERR;\r\n} else\r\nerr = MOVE_CANCEL_BITFLIPS;\r\ngoto out_unlock_buf;\r\n}\r\ncond_resched();\r\nif (memcmp(ubi->peb_buf1, ubi->peb_buf2, aldata_size)) {\r\nubi_warn("read data back from PEB %d and it is "\r\n"different", to);\r\nerr = -EINVAL;\r\ngoto out_unlock_buf;\r\n}\r\n}\r\nubi_assert(vol->eba_tbl[lnum] == from);\r\nvol->eba_tbl[lnum] = to;\r\nout_unlock_buf:\r\nmutex_unlock(&ubi->buf_mutex);\r\nout_unlock_leb:\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\n}\r\nstatic void print_rsvd_warning(struct ubi_device *ubi,\r\nstruct ubi_scan_info *si)\r\n{\r\nif (si->max_sqnum > (1 << 18)) {\r\nint min = ubi->beb_rsvd_level / 10;\r\nif (!min)\r\nmin = 1;\r\nif (ubi->beb_rsvd_pebs > min)\r\nreturn;\r\n}\r\nubi_warn("cannot reserve enough PEBs for bad PEB handling, reserved %d,"\r\n" need %d", ubi->beb_rsvd_pebs, ubi->beb_rsvd_level);\r\nif (ubi->corr_peb_count)\r\nubi_warn("%d PEBs are corrupted and not used",\r\nubi->corr_peb_count);\r\n}\r\nint ubi_eba_init_scan(struct ubi_device *ubi, struct ubi_scan_info *si)\r\n{\r\nint i, j, err, num_volumes;\r\nstruct ubi_scan_volume *sv;\r\nstruct ubi_volume *vol;\r\nstruct ubi_scan_leb *seb;\r\nstruct rb_node *rb;\r\ndbg_eba("initialize EBA sub-system");\r\nspin_lock_init(&ubi->ltree_lock);\r\nmutex_init(&ubi->alc_mutex);\r\nubi->ltree = RB_ROOT;\r\nubi->global_sqnum = si->max_sqnum + 1;\r\nnum_volumes = ubi->vtbl_slots + UBI_INT_VOL_COUNT;\r\nfor (i = 0; i < num_volumes; i++) {\r\nvol = ubi->volumes[i];\r\nif (!vol)\r\ncontinue;\r\ncond_resched();\r\nvol->eba_tbl = kmalloc(vol->reserved_pebs * sizeof(int),\r\nGFP_KERNEL);\r\nif (!vol->eba_tbl) {\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\nfor (j = 0; j < vol->reserved_pebs; j++)\r\nvol->eba_tbl[j] = UBI_LEB_UNMAPPED;\r\nsv = ubi_scan_find_sv(si, idx2vol_id(ubi, i));\r\nif (!sv)\r\ncontinue;\r\nubi_rb_for_each_entry(rb, seb, &sv->root, u.rb) {\r\nif (seb->lnum >= vol->reserved_pebs)\r\nubi_scan_move_to_list(sv, seb, &si->erase);\r\nvol->eba_tbl[seb->lnum] = seb->pnum;\r\n}\r\n}\r\nif (ubi->avail_pebs < EBA_RESERVED_PEBS) {\r\nubi_err("no enough physical eraseblocks (%d, need %d)",\r\nubi->avail_pebs, EBA_RESERVED_PEBS);\r\nif (ubi->corr_peb_count)\r\nubi_err("%d PEBs are corrupted and not used",\r\nubi->corr_peb_count);\r\nerr = -ENOSPC;\r\ngoto out_free;\r\n}\r\nubi->avail_pebs -= EBA_RESERVED_PEBS;\r\nubi->rsvd_pebs += EBA_RESERVED_PEBS;\r\nif (ubi->bad_allowed) {\r\nubi_calculate_reserved(ubi);\r\nif (ubi->avail_pebs < ubi->beb_rsvd_level) {\r\nubi->beb_rsvd_pebs = ubi->avail_pebs;\r\nprint_rsvd_warning(ubi, si);\r\n} else\r\nubi->beb_rsvd_pebs = ubi->beb_rsvd_level;\r\nubi->avail_pebs -= ubi->beb_rsvd_pebs;\r\nubi->rsvd_pebs += ubi->beb_rsvd_pebs;\r\n}\r\ndbg_eba("EBA sub-system is initialized");\r\nreturn 0;\r\nout_free:\r\nfor (i = 0; i < num_volumes; i++) {\r\nif (!ubi->volumes[i])\r\ncontinue;\r\nkfree(ubi->volumes[i]->eba_tbl);\r\nubi->volumes[i]->eba_tbl = NULL;\r\n}\r\nreturn err;\r\n}
