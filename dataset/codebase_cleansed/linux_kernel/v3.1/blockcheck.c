static unsigned int calc_code_bit(unsigned int i, unsigned int *p_cache)\r\n{\r\nunsigned int b, p = 0;\r\nb = i + 1;\r\nif (p_cache)\r\np = *p_cache;\r\nb += p;\r\nfor (; (1 << p) < (b + 1); p++)\r\nb++;\r\nif (p_cache)\r\n*p_cache = p;\r\nreturn b;\r\n}\r\nu32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\r\n{\r\nunsigned int i, b, p = 0;\r\nBUG_ON(!d);\r\nfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\r\n{\r\nb = calc_code_bit(nr + i, &p);\r\nparity ^= b;\r\n}\r\nreturn parity;\r\n}\r\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\r\n{\r\nreturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\r\n}\r\nvoid ocfs2_hamming_fix(void *data, unsigned int d, unsigned int nr,\r\nunsigned int fix)\r\n{\r\nunsigned int i, b;\r\nBUG_ON(!d);\r\nif (hweight32(fix) == 1)\r\nreturn;\r\nif (fix >= calc_code_bit(nr + d, NULL))\r\nreturn;\r\nb = calc_code_bit(nr, NULL);\r\nif (fix < b)\r\nreturn;\r\nfor (i = 0; i < d; i++, b++)\r\n{\r\nwhile (hweight32(b) == 1)\r\nb++;\r\nif (b == fix)\r\n{\r\nif (ocfs2_test_bit(i, data))\r\nocfs2_clear_bit(i, data);\r\nelse\r\nocfs2_set_bit(i, data);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid ocfs2_hamming_fix_block(void *data, unsigned int blocksize,\r\nunsigned int fix)\r\n{\r\nocfs2_hamming_fix(data, blocksize * 8, 0, fix);\r\n}\r\nstatic int blockcheck_u64_get(void *data, u64 *val)\r\n{\r\n*val = *(u64 *)data;\r\nreturn 0;\r\n}\r\nstatic struct dentry *blockcheck_debugfs_create(const char *name,\r\nstruct dentry *parent,\r\nu64 *value)\r\n{\r\nreturn debugfs_create_file(name, S_IFREG | S_IRUSR, parent, value,\r\n&blockcheck_fops);\r\n}\r\nstatic void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\r\n{\r\nif (stats) {\r\ndebugfs_remove(stats->b_debug_check);\r\nstats->b_debug_check = NULL;\r\ndebugfs_remove(stats->b_debug_failure);\r\nstats->b_debug_failure = NULL;\r\ndebugfs_remove(stats->b_debug_recover);\r\nstats->b_debug_recover = NULL;\r\ndebugfs_remove(stats->b_debug_dir);\r\nstats->b_debug_dir = NULL;\r\n}\r\n}\r\nstatic int ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\r\nstruct dentry *parent)\r\n{\r\nint rc = -EINVAL;\r\nif (!stats)\r\ngoto out;\r\nstats->b_debug_dir = debugfs_create_dir("blockcheck", parent);\r\nif (!stats->b_debug_dir)\r\ngoto out;\r\nstats->b_debug_check =\r\nblockcheck_debugfs_create("blocks_checked",\r\nstats->b_debug_dir,\r\n&stats->b_check_count);\r\nstats->b_debug_failure =\r\nblockcheck_debugfs_create("checksums_failed",\r\nstats->b_debug_dir,\r\n&stats->b_failure_count);\r\nstats->b_debug_recover =\r\nblockcheck_debugfs_create("ecc_recoveries",\r\nstats->b_debug_dir,\r\n&stats->b_recover_count);\r\nif (stats->b_debug_check && stats->b_debug_failure &&\r\nstats->b_debug_recover)\r\nrc = 0;\r\nout:\r\nif (rc)\r\nocfs2_blockcheck_debug_remove(stats);\r\nreturn rc;\r\n}\r\nstatic inline int ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\r\nstruct dentry *parent)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\r\n{\r\n}\r\nint ocfs2_blockcheck_stats_debugfs_install(struct ocfs2_blockcheck_stats *stats,\r\nstruct dentry *parent)\r\n{\r\nreturn ocfs2_blockcheck_debug_install(stats, parent);\r\n}\r\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\r\n{\r\nocfs2_blockcheck_debug_remove(stats);\r\n}\r\nstatic void ocfs2_blockcheck_inc_check(struct ocfs2_blockcheck_stats *stats)\r\n{\r\nu64 new_count;\r\nif (!stats)\r\nreturn;\r\nspin_lock(&stats->b_lock);\r\nstats->b_check_count++;\r\nnew_count = stats->b_check_count;\r\nspin_unlock(&stats->b_lock);\r\nif (!new_count)\r\nmlog(ML_NOTICE, "Block check count has wrapped\n");\r\n}\r\nstatic void ocfs2_blockcheck_inc_failure(struct ocfs2_blockcheck_stats *stats)\r\n{\r\nu64 new_count;\r\nif (!stats)\r\nreturn;\r\nspin_lock(&stats->b_lock);\r\nstats->b_failure_count++;\r\nnew_count = stats->b_failure_count;\r\nspin_unlock(&stats->b_lock);\r\nif (!new_count)\r\nmlog(ML_NOTICE, "Checksum failure count has wrapped\n");\r\n}\r\nstatic void ocfs2_blockcheck_inc_recover(struct ocfs2_blockcheck_stats *stats)\r\n{\r\nu64 new_count;\r\nif (!stats)\r\nreturn;\r\nspin_lock(&stats->b_lock);\r\nstats->b_recover_count++;\r\nnew_count = stats->b_recover_count;\r\nspin_unlock(&stats->b_lock);\r\nif (!new_count)\r\nmlog(ML_NOTICE, "ECC recovery count has wrapped\n");\r\n}\r\nvoid ocfs2_block_check_compute(void *data, size_t blocksize,\r\nstruct ocfs2_block_check *bc)\r\n{\r\nu32 crc;\r\nu32 ecc;\r\nmemset(bc, 0, sizeof(struct ocfs2_block_check));\r\ncrc = crc32_le(~0, data, blocksize);\r\necc = ocfs2_hamming_encode_block(data, blocksize);\r\nBUG_ON(ecc > USHRT_MAX);\r\nbc->bc_crc32e = cpu_to_le32(crc);\r\nbc->bc_ecc = cpu_to_le16((u16)ecc);\r\n}\r\nint ocfs2_block_check_validate(void *data, size_t blocksize,\r\nstruct ocfs2_block_check *bc,\r\nstruct ocfs2_blockcheck_stats *stats)\r\n{\r\nint rc = 0;\r\nstruct ocfs2_block_check check;\r\nu32 crc, ecc;\r\nocfs2_blockcheck_inc_check(stats);\r\ncheck.bc_crc32e = le32_to_cpu(bc->bc_crc32e);\r\ncheck.bc_ecc = le16_to_cpu(bc->bc_ecc);\r\nmemset(bc, 0, sizeof(struct ocfs2_block_check));\r\ncrc = crc32_le(~0, data, blocksize);\r\nif (crc == check.bc_crc32e)\r\ngoto out;\r\nocfs2_blockcheck_inc_failure(stats);\r\nmlog(ML_ERROR,\r\n"CRC32 failed: stored: 0x%x, computed 0x%x. Applying ECC.\n",\r\n(unsigned int)check.bc_crc32e, (unsigned int)crc);\r\necc = ocfs2_hamming_encode_block(data, blocksize);\r\nocfs2_hamming_fix_block(data, blocksize, ecc ^ check.bc_ecc);\r\ncrc = crc32_le(~0, data, blocksize);\r\nif (crc == check.bc_crc32e) {\r\nocfs2_blockcheck_inc_recover(stats);\r\ngoto out;\r\n}\r\nmlog(ML_ERROR, "Fixed CRC32 failed: stored: 0x%x, computed 0x%x\n",\r\n(unsigned int)check.bc_crc32e, (unsigned int)crc);\r\nrc = -EIO;\r\nout:\r\nbc->bc_crc32e = cpu_to_le32(check.bc_crc32e);\r\nbc->bc_ecc = cpu_to_le16(check.bc_ecc);\r\nreturn rc;\r\n}\r\nvoid ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\r\nstruct ocfs2_block_check *bc)\r\n{\r\nint i;\r\nu32 crc, ecc;\r\nBUG_ON(nr < 0);\r\nif (!nr)\r\nreturn;\r\nmemset(bc, 0, sizeof(struct ocfs2_block_check));\r\nfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\r\ncrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\r\necc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\r\nbhs[i]->b_size * 8,\r\nbhs[i]->b_size * 8 * i);\r\n}\r\nBUG_ON(ecc > USHRT_MAX);\r\nbc->bc_crc32e = cpu_to_le32(crc);\r\nbc->bc_ecc = cpu_to_le16((u16)ecc);\r\n}\r\nint ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\r\nstruct ocfs2_block_check *bc,\r\nstruct ocfs2_blockcheck_stats *stats)\r\n{\r\nint i, rc = 0;\r\nstruct ocfs2_block_check check;\r\nu32 crc, ecc, fix;\r\nBUG_ON(nr < 0);\r\nif (!nr)\r\nreturn 0;\r\nocfs2_blockcheck_inc_check(stats);\r\ncheck.bc_crc32e = le32_to_cpu(bc->bc_crc32e);\r\ncheck.bc_ecc = le16_to_cpu(bc->bc_ecc);\r\nmemset(bc, 0, sizeof(struct ocfs2_block_check));\r\nfor (i = 0, crc = ~0; i < nr; i++)\r\ncrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\r\nif (crc == check.bc_crc32e)\r\ngoto out;\r\nocfs2_blockcheck_inc_failure(stats);\r\nmlog(ML_ERROR,\r\n"CRC32 failed: stored: %u, computed %u. Applying ECC.\n",\r\n(unsigned int)check.bc_crc32e, (unsigned int)crc);\r\nfor (i = 0, ecc = 0; i < nr; i++) {\r\necc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\r\nbhs[i]->b_size * 8,\r\nbhs[i]->b_size * 8 * i);\r\n}\r\nfix = ecc ^ check.bc_ecc;\r\nfor (i = 0; i < nr; i++) {\r\nocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\r\nbhs[i]->b_size * 8 * i, fix);\r\n}\r\nfor (i = 0, crc = ~0; i < nr; i++)\r\ncrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\r\nif (crc == check.bc_crc32e) {\r\nocfs2_blockcheck_inc_recover(stats);\r\ngoto out;\r\n}\r\nmlog(ML_ERROR, "Fixed CRC32 failed: stored: %u, computed %u\n",\r\n(unsigned int)check.bc_crc32e, (unsigned int)crc);\r\nrc = -EIO;\r\nout:\r\nbc->bc_crc32e = cpu_to_le32(check.bc_crc32e);\r\nbc->bc_ecc = cpu_to_le16(check.bc_ecc);\r\nreturn rc;\r\n}\r\nvoid ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\r\nstruct ocfs2_block_check *bc)\r\n{\r\nif (ocfs2_meta_ecc(OCFS2_SB(sb)))\r\nocfs2_block_check_compute(data, sb->s_blocksize, bc);\r\n}\r\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\r\nstruct ocfs2_block_check *bc)\r\n{\r\nint rc = 0;\r\nstruct ocfs2_super *osb = OCFS2_SB(sb);\r\nif (ocfs2_meta_ecc(osb))\r\nrc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\r\n&osb->osb_ecc_stats);\r\nreturn rc;\r\n}\r\nvoid ocfs2_compute_meta_ecc_bhs(struct super_block *sb,\r\nstruct buffer_head **bhs, int nr,\r\nstruct ocfs2_block_check *bc)\r\n{\r\nif (ocfs2_meta_ecc(OCFS2_SB(sb)))\r\nocfs2_block_check_compute_bhs(bhs, nr, bc);\r\n}\r\nint ocfs2_validate_meta_ecc_bhs(struct super_block *sb,\r\nstruct buffer_head **bhs, int nr,\r\nstruct ocfs2_block_check *bc)\r\n{\r\nint rc = 0;\r\nstruct ocfs2_super *osb = OCFS2_SB(sb);\r\nif (ocfs2_meta_ecc(osb))\r\nrc = ocfs2_block_check_validate_bhs(bhs, nr, bc,\r\n&osb->osb_ecc_stats);\r\nreturn rc;\r\n}
