static void deactivate_buffer(struct go7007_buffer *gobuf)\r\n{\r\nint i;\r\nif (gobuf->state != BUF_STATE_IDLE) {\r\nlist_del(&gobuf->stream);\r\ngobuf->state = BUF_STATE_IDLE;\r\n}\r\nif (gobuf->page_count > 0) {\r\nfor (i = 0; i < gobuf->page_count; ++i)\r\npage_cache_release(gobuf->pages[i]);\r\ngobuf->page_count = 0;\r\n}\r\n}\r\nstatic void abort_queued(struct go7007 *go)\r\n{\r\nstruct go7007_buffer *gobuf, *next;\r\nlist_for_each_entry_safe(gobuf, next, &go->stream, stream) {\r\ndeactivate_buffer(gobuf);\r\n}\r\n}\r\nstatic int go7007_streamoff(struct go7007 *go)\r\n{\r\nint retval = -EINVAL;\r\nunsigned long flags;\r\nmutex_lock(&go->hw_lock);\r\nif (go->streaming) {\r\ngo->streaming = 0;\r\ngo7007_stream_stop(go);\r\nspin_lock_irqsave(&go->spinlock, flags);\r\nabort_queued(go);\r\nspin_unlock_irqrestore(&go->spinlock, flags);\r\ngo7007_reset_encoder(go);\r\nretval = 0;\r\n}\r\nmutex_unlock(&go->hw_lock);\r\nreturn 0;\r\n}\r\nstatic int go7007_open(struct file *file)\r\n{\r\nstruct go7007 *go = video_get_drvdata(video_devdata(file));\r\nstruct go7007_file *gofh;\r\nif (go->status != STATUS_ONLINE)\r\nreturn -EBUSY;\r\ngofh = kmalloc(sizeof(struct go7007_file), GFP_KERNEL);\r\nif (gofh == NULL)\r\nreturn -ENOMEM;\r\n++go->ref_count;\r\ngofh->go = go;\r\nmutex_init(&gofh->lock);\r\ngofh->buf_count = 0;\r\nfile->private_data = gofh;\r\nreturn 0;\r\n}\r\nstatic int go7007_release(struct file *file)\r\n{\r\nstruct go7007_file *gofh = file->private_data;\r\nstruct go7007 *go = gofh->go;\r\nif (gofh->buf_count > 0) {\r\ngo7007_streamoff(go);\r\ngo->in_use = 0;\r\nkfree(gofh->bufs);\r\ngofh->buf_count = 0;\r\n}\r\nkfree(gofh);\r\nif (--go->ref_count == 0)\r\nkfree(go);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic u32 get_frame_type_flag(struct go7007_buffer *gobuf, int format)\r\n{\r\nu8 *f = page_address(gobuf->pages[0]);\r\nswitch (format) {\r\ncase GO7007_FORMAT_MJPEG:\r\nreturn V4L2_BUF_FLAG_KEYFRAME;\r\ncase GO7007_FORMAT_MPEG4:\r\nswitch ((f[gobuf->frame_offset + 4] >> 6) & 0x3) {\r\ncase 0:\r\nreturn V4L2_BUF_FLAG_KEYFRAME;\r\ncase 1:\r\nreturn V4L2_BUF_FLAG_PFRAME;\r\ncase 2:\r\nreturn V4L2_BUF_FLAG_BFRAME;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase GO7007_FORMAT_MPEG1:\r\ncase GO7007_FORMAT_MPEG2:\r\nswitch ((f[gobuf->frame_offset + 5] >> 3) & 0x7) {\r\ncase 1:\r\nreturn V4L2_BUF_FLAG_KEYFRAME;\r\ncase 2:\r\nreturn V4L2_BUF_FLAG_PFRAME;\r\ncase 3:\r\nreturn V4L2_BUF_FLAG_BFRAME;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_capture_size(struct go7007 *go, struct v4l2_format *fmt, int try)\r\n{\r\nint sensor_height = 0, sensor_width = 0;\r\nint width, height, i;\r\nif (fmt != NULL && fmt->fmt.pix.pixelformat != V4L2_PIX_FMT_MJPEG &&\r\nfmt->fmt.pix.pixelformat != V4L2_PIX_FMT_MPEG &&\r\nfmt->fmt.pix.pixelformat != V4L2_PIX_FMT_MPEG4)\r\nreturn -EINVAL;\r\nswitch (go->standard) {\r\ncase GO7007_STD_NTSC:\r\nsensor_width = 720;\r\nsensor_height = 480;\r\nbreak;\r\ncase GO7007_STD_PAL:\r\nsensor_width = 720;\r\nsensor_height = 576;\r\nbreak;\r\ncase GO7007_STD_OTHER:\r\nsensor_width = go->board_info->sensor_width;\r\nsensor_height = go->board_info->sensor_height;\r\nbreak;\r\n}\r\nif (fmt == NULL) {\r\nwidth = sensor_width;\r\nheight = sensor_height;\r\n} else if (go->board_info->sensor_flags & GO7007_SENSOR_SCALING) {\r\nif (fmt->fmt.pix.width > sensor_width)\r\nwidth = sensor_width;\r\nelse if (fmt->fmt.pix.width < 144)\r\nwidth = 144;\r\nelse\r\nwidth = fmt->fmt.pix.width & ~0x0f;\r\nif (fmt->fmt.pix.height > sensor_height)\r\nheight = sensor_height;\r\nelse if (fmt->fmt.pix.height < 96)\r\nheight = 96;\r\nelse\r\nheight = fmt->fmt.pix.height & ~0x0f;\r\n} else {\r\nint requested_size = fmt->fmt.pix.width * fmt->fmt.pix.height;\r\nint sensor_size = sensor_width * sensor_height;\r\nif (64 * requested_size < 9 * sensor_size) {\r\nwidth = sensor_width / 4;\r\nheight = sensor_height / 4;\r\n} else if (64 * requested_size < 36 * sensor_size) {\r\nwidth = sensor_width / 2;\r\nheight = sensor_height / 2;\r\n} else {\r\nwidth = sensor_width;\r\nheight = sensor_height;\r\n}\r\nwidth &= ~0xf;\r\nheight &= ~0xf;\r\n}\r\nif (fmt != NULL) {\r\nu32 pixelformat = fmt->fmt.pix.pixelformat;\r\nmemset(fmt, 0, sizeof(*fmt));\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nfmt->fmt.pix.width = width;\r\nfmt->fmt.pix.height = height;\r\nfmt->fmt.pix.pixelformat = pixelformat;\r\nfmt->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmt->fmt.pix.bytesperline = 0;\r\nfmt->fmt.pix.sizeimage = GO7007_BUF_SIZE;\r\nfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\n}\r\nif (try)\r\nreturn 0;\r\ngo->width = width;\r\ngo->height = height;\r\ngo->encoder_h_offset = go->board_info->sensor_h_offset;\r\ngo->encoder_v_offset = go->board_info->sensor_v_offset;\r\nfor (i = 0; i < 4; ++i)\r\ngo->modet[i].enable = 0;\r\nfor (i = 0; i < 1624; ++i)\r\ngo->modet_map[i] = 0;\r\nif (go->board_info->sensor_flags & GO7007_SENSOR_SCALING) {\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nmbus_fmt.code = V4L2_MBUS_FMT_FIXED;\r\nif (fmt != NULL)\r\nmbus_fmt.width = fmt->fmt.pix.width;\r\nelse\r\nmbus_fmt.width = width;\r\nif (height > sensor_height / 2) {\r\nmbus_fmt.height = height / 2;\r\ngo->encoder_v_halve = 0;\r\n} else {\r\nmbus_fmt.height = height;\r\ngo->encoder_v_halve = 1;\r\n}\r\ncall_all(&go->v4l2_dev, video, s_mbus_fmt, &mbus_fmt);\r\n} else {\r\nif (width <= sensor_width / 4) {\r\ngo->encoder_h_halve = 1;\r\ngo->encoder_v_halve = 1;\r\ngo->encoder_subsample = 1;\r\n} else if (width <= sensor_width / 2) {\r\ngo->encoder_h_halve = 1;\r\ngo->encoder_v_halve = 1;\r\ngo->encoder_subsample = 0;\r\n} else {\r\ngo->encoder_h_halve = 0;\r\ngo->encoder_v_halve = 0;\r\ngo->encoder_subsample = 0;\r\n}\r\n}\r\nif (fmt == NULL)\r\nreturn 0;\r\nswitch (fmt->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_MPEG:\r\nif (go->format == GO7007_FORMAT_MPEG1 ||\r\ngo->format == GO7007_FORMAT_MPEG2 ||\r\ngo->format == GO7007_FORMAT_MPEG4)\r\nbreak;\r\ngo->format = GO7007_FORMAT_MPEG1;\r\ngo->pali = 0;\r\ngo->aspect_ratio = GO7007_RATIO_1_1;\r\ngo->gop_size = go->sensor_framerate / 1000;\r\ngo->ipb = 0;\r\ngo->closed_gop = 1;\r\ngo->repeat_seqhead = 1;\r\ngo->seq_header_enable = 1;\r\ngo->gop_header_enable = 1;\r\ngo->dvd_mode = 0;\r\nbreak;\r\ncase V4L2_PIX_FMT_MPEG4:\r\nif (go->format == GO7007_FORMAT_MPEG4)\r\nbreak;\r\ngo->format = GO7007_FORMAT_MPEG4;\r\ngo->pali = 0xf5;\r\ngo->aspect_ratio = GO7007_RATIO_1_1;\r\ngo->gop_size = go->sensor_framerate / 1000;\r\ngo->ipb = 0;\r\ngo->closed_gop = 1;\r\ngo->repeat_seqhead = 1;\r\ngo->seq_header_enable = 1;\r\ngo->gop_header_enable = 1;\r\ngo->dvd_mode = 0;\r\nbreak;\r\ncase V4L2_PIX_FMT_MJPEG:\r\ngo->format = GO7007_FORMAT_MJPEG;\r\ngo->pali = 0;\r\ngo->aspect_ratio = GO7007_RATIO_1_1;\r\ngo->gop_size = 0;\r\ngo->ipb = 0;\r\ngo->closed_gop = 0;\r\ngo->repeat_seqhead = 0;\r\ngo->seq_header_enable = 0;\r\ngo->gop_header_enable = 0;\r\ngo->dvd_mode = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpeg_query_ctrl(struct v4l2_queryctrl *ctrl)\r\n{\r\nstatic const u32 mpeg_ctrls[] = {\r\nV4L2_CID_MPEG_CLASS,\r\nV4L2_CID_MPEG_STREAM_TYPE,\r\nV4L2_CID_MPEG_VIDEO_ENCODING,\r\nV4L2_CID_MPEG_VIDEO_ASPECT,\r\nV4L2_CID_MPEG_VIDEO_GOP_SIZE,\r\nV4L2_CID_MPEG_VIDEO_GOP_CLOSURE,\r\nV4L2_CID_MPEG_VIDEO_BITRATE,\r\n0\r\n};\r\nstatic const u32 *ctrl_classes[] = {\r\nmpeg_ctrls,\r\nNULL\r\n};\r\nctrl->id = v4l2_ctrl_next(ctrl_classes, ctrl->id);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_CLASS:\r\nreturn v4l2_ctrl_query_fill(ctrl, 0, 0, 0, 0);\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nreturn v4l2_ctrl_query_fill(ctrl,\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_DVD,\r\nV4L2_MPEG_STREAM_TYPE_MPEG_ELEM, 1,\r\nV4L2_MPEG_STREAM_TYPE_MPEG_ELEM);\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nreturn v4l2_ctrl_query_fill(ctrl,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_1,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_4, 1,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_2);\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nreturn v4l2_ctrl_query_fill(ctrl,\r\nV4L2_MPEG_VIDEO_ASPECT_1x1,\r\nV4L2_MPEG_VIDEO_ASPECT_16x9, 1,\r\nV4L2_MPEG_VIDEO_ASPECT_1x1);\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nreturn v4l2_ctrl_query_fill(ctrl, 0, 34, 1, 15);\r\ncase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE:\r\nreturn v4l2_ctrl_query_fill(ctrl, 0, 1, 1, 0);\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nreturn v4l2_ctrl_query_fill(ctrl,\r\n64000,\r\n10000000, 1,\r\n1500000);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpeg_s_ctrl(struct v4l2_control *ctrl, struct go7007 *go)\r\n{\r\nif (go->streaming)\r\nreturn -EBUSY;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nswitch (ctrl->value) {\r\ncase V4L2_MPEG_STREAM_TYPE_MPEG2_DVD:\r\ngo->format = GO7007_FORMAT_MPEG2;\r\ngo->bitrate = 9800000;\r\ngo->gop_size = 15;\r\ngo->pali = 0x48;\r\ngo->closed_gop = 1;\r\ngo->repeat_seqhead = 0;\r\ngo->seq_header_enable = 1;\r\ngo->gop_header_enable = 1;\r\ngo->dvd_mode = 1;\r\nbreak;\r\ncase V4L2_MPEG_STREAM_TYPE_MPEG_ELEM:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nswitch (ctrl->value) {\r\ncase V4L2_MPEG_VIDEO_ENCODING_MPEG_1:\r\ngo->format = GO7007_FORMAT_MPEG1;\r\ngo->pali = 0;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ENCODING_MPEG_2:\r\ngo->format = GO7007_FORMAT_MPEG2;\r\ngo->pali = 0x48;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ENCODING_MPEG_4:\r\ngo->format = GO7007_FORMAT_MPEG4;\r\ngo->pali = 0xf5;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ngo->gop_header_enable =\r\n1;\r\ngo->repeat_seqhead = 0;\r\ngo->dvd_mode = 0;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nif (go->format == GO7007_FORMAT_MJPEG)\r\nreturn -EINVAL;\r\nswitch (ctrl->value) {\r\ncase V4L2_MPEG_VIDEO_ASPECT_1x1:\r\ngo->aspect_ratio = GO7007_RATIO_1_1;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ASPECT_4x3:\r\ngo->aspect_ratio = GO7007_RATIO_4_3;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ASPECT_16x9:\r\ngo->aspect_ratio = GO7007_RATIO_16_9;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ASPECT_221x100:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nif (ctrl->value < 0 || ctrl->value > 34)\r\nreturn -EINVAL;\r\ngo->gop_size = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE:\r\nif (ctrl->value != 0 && ctrl->value != 1)\r\nreturn -EINVAL;\r\ngo->closed_gop = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nif (ctrl->value < 64000 || ctrl->value > 10000000)\r\nreturn -EINVAL;\r\ngo->bitrate = ctrl->value;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpeg_g_ctrl(struct v4l2_control *ctrl, struct go7007 *go)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nif (go->dvd_mode)\r\nctrl->value = V4L2_MPEG_STREAM_TYPE_MPEG2_DVD;\r\nelse\r\nctrl->value = V4L2_MPEG_STREAM_TYPE_MPEG_ELEM;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nswitch (go->format) {\r\ncase GO7007_FORMAT_MPEG1:\r\nctrl->value = V4L2_MPEG_VIDEO_ENCODING_MPEG_1;\r\nbreak;\r\ncase GO7007_FORMAT_MPEG2:\r\nctrl->value = V4L2_MPEG_VIDEO_ENCODING_MPEG_2;\r\nbreak;\r\ncase GO7007_FORMAT_MPEG4:\r\nctrl->value = V4L2_MPEG_VIDEO_ENCODING_MPEG_4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nswitch (go->aspect_ratio) {\r\ncase GO7007_RATIO_1_1:\r\nctrl->value = V4L2_MPEG_VIDEO_ASPECT_1x1;\r\nbreak;\r\ncase GO7007_RATIO_4_3:\r\nctrl->value = V4L2_MPEG_VIDEO_ASPECT_4x3;\r\nbreak;\r\ncase GO7007_RATIO_16_9:\r\nctrl->value = V4L2_MPEG_VIDEO_ASPECT_16x9;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nctrl->value = go->gop_size;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE:\r\nctrl->value = go->closed_gop;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nctrl->value = go->bitrate;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nstrlcpy(cap->driver, "go7007", sizeof(cap->driver));\r\nstrlcpy(cap->card, go->name, sizeof(cap->card));\r\n#if 0\r\nstrlcpy(cap->bus_info, dev_name(&dev->udev->dev), sizeof(cap->bus_info));\r\n#endif\r\ncap->version = KERNEL_VERSION(0, 9, 8);\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING;\r\nif (go->board_info->flags & GO7007_BOARD_HAS_TUNER)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nchar *desc = NULL;\r\nswitch (fmt->index) {\r\ncase 0:\r\nfmt->pixelformat = V4L2_PIX_FMT_MJPEG;\r\ndesc = "Motion-JPEG";\r\nbreak;\r\ncase 1:\r\nfmt->pixelformat = V4L2_PIX_FMT_MPEG;\r\ndesc = "MPEG1/MPEG2/MPEG4";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nfmt->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nstrncpy(fmt->description, desc, sizeof(fmt->description));\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nfmt->fmt.pix.width = go->width;\r\nfmt->fmt.pix.height = go->height;\r\nfmt->fmt.pix.pixelformat = (go->format == GO7007_FORMAT_MJPEG) ?\r\nV4L2_PIX_FMT_MJPEG : V4L2_PIX_FMT_MPEG;\r\nfmt->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmt->fmt.pix.bytesperline = 0;\r\nfmt->fmt.pix.sizeimage = GO7007_BUF_SIZE;\r\nfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nreturn set_capture_size(go, fmt, 1);\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (go->streaming)\r\nreturn -EBUSY;\r\nreturn set_capture_size(go, fmt, 0);\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nstruct go7007_file *gofh = priv;\r\nstruct go7007 *go = gofh->go;\r\nint retval = -EBUSY;\r\nunsigned int count, i;\r\nif (go->streaming)\r\nreturn retval;\r\nif (req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nreq->memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nmutex_lock(&gofh->lock);\r\nfor (i = 0; i < gofh->buf_count; ++i)\r\nif (gofh->bufs[i].mapped > 0)\r\ngoto unlock_and_return;\r\nmutex_lock(&go->hw_lock);\r\nif (go->in_use > 0 && gofh->buf_count == 0) {\r\nmutex_unlock(&go->hw_lock);\r\ngoto unlock_and_return;\r\n}\r\nif (gofh->buf_count > 0)\r\nkfree(gofh->bufs);\r\nretval = -ENOMEM;\r\ncount = req->count;\r\nif (count > 0) {\r\nif (count < 2)\r\ncount = 2;\r\nif (count > 32)\r\ncount = 32;\r\ngofh->bufs = kcalloc(count, sizeof(struct go7007_buffer),\r\nGFP_KERNEL);\r\nif (!gofh->bufs) {\r\nmutex_unlock(&go->hw_lock);\r\ngoto unlock_and_return;\r\n}\r\nfor (i = 0; i < count; ++i) {\r\ngofh->bufs[i].go = go;\r\ngofh->bufs[i].index = i;\r\ngofh->bufs[i].state = BUF_STATE_IDLE;\r\ngofh->bufs[i].mapped = 0;\r\n}\r\ngo->in_use = 1;\r\n} else {\r\ngo->in_use = 0;\r\n}\r\ngofh->buf_count = count;\r\nmutex_unlock(&go->hw_lock);\r\nmutex_unlock(&gofh->lock);\r\nmemset(req, 0, sizeof(*req));\r\nreq->count = count;\r\nreq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreq->memory = V4L2_MEMORY_MMAP;\r\nreturn 0;\r\nunlock_and_return:\r\nmutex_unlock(&gofh->lock);\r\nreturn retval;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct go7007_file *gofh = priv;\r\nint retval = -EINVAL;\r\nunsigned int index;\r\nif (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn retval;\r\nindex = buf->index;\r\nmutex_lock(&gofh->lock);\r\nif (index >= gofh->buf_count)\r\ngoto unlock_and_return;\r\nmemset(buf, 0, sizeof(*buf));\r\nbuf->index = index;\r\nbuf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nswitch (gofh->bufs[index].state) {\r\ncase BUF_STATE_QUEUED:\r\nbuf->flags = V4L2_BUF_FLAG_QUEUED;\r\nbreak;\r\ncase BUF_STATE_DONE:\r\nbuf->flags = V4L2_BUF_FLAG_DONE;\r\nbreak;\r\ndefault:\r\nbuf->flags = 0;\r\n}\r\nif (gofh->bufs[index].mapped)\r\nbuf->flags |= V4L2_BUF_FLAG_MAPPED;\r\nbuf->memory = V4L2_MEMORY_MMAP;\r\nbuf->m.offset = index * GO7007_BUF_SIZE;\r\nbuf->length = GO7007_BUF_SIZE;\r\nmutex_unlock(&gofh->lock);\r\nreturn 0;\r\nunlock_and_return:\r\nmutex_unlock(&gofh->lock);\r\nreturn retval;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct go7007_file *gofh = priv;\r\nstruct go7007 *go = gofh->go;\r\nstruct go7007_buffer *gobuf;\r\nunsigned long flags;\r\nint retval = -EINVAL;\r\nint ret;\r\nif (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nbuf->memory != V4L2_MEMORY_MMAP)\r\nreturn retval;\r\nmutex_lock(&gofh->lock);\r\nif (buf->index < 0 || buf->index >= gofh->buf_count)\r\ngoto unlock_and_return;\r\ngobuf = &gofh->bufs[buf->index];\r\nif (!gobuf->mapped)\r\ngoto unlock_and_return;\r\nretval = -EBUSY;\r\nif (gobuf->state != BUF_STATE_IDLE)\r\ngoto unlock_and_return;\r\ngobuf->offset = gobuf->user_addr & ~PAGE_MASK;\r\ngobuf->bytesused = 0;\r\ngobuf->frame_offset = 0;\r\ngobuf->modet_active = 0;\r\nif (gobuf->offset > 0)\r\ngobuf->page_count = GO7007_BUF_PAGES + 1;\r\nelse\r\ngobuf->page_count = GO7007_BUF_PAGES;\r\nretval = -ENOMEM;\r\ndown_read(&current->mm->mmap_sem);\r\nret = get_user_pages(current, current->mm,\r\ngobuf->user_addr & PAGE_MASK, gobuf->page_count,\r\n1, 1, gobuf->pages, NULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (ret != gobuf->page_count) {\r\nint i;\r\nfor (i = 0; i < ret; ++i)\r\npage_cache_release(gobuf->pages[i]);\r\ngobuf->page_count = 0;\r\ngoto unlock_and_return;\r\n}\r\ngobuf->state = BUF_STATE_QUEUED;\r\nspin_lock_irqsave(&go->spinlock, flags);\r\nlist_add_tail(&gobuf->stream, &go->stream);\r\nspin_unlock_irqrestore(&go->spinlock, flags);\r\nmutex_unlock(&gofh->lock);\r\nreturn 0;\r\nunlock_and_return:\r\nmutex_unlock(&gofh->lock);\r\nreturn retval;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct go7007_file *gofh = priv;\r\nstruct go7007 *go = gofh->go;\r\nstruct go7007_buffer *gobuf;\r\nint retval = -EINVAL;\r\nunsigned long flags;\r\nu32 frame_type_flag;\r\nDEFINE_WAIT(wait);\r\nif (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn retval;\r\nif (buf->memory != V4L2_MEMORY_MMAP)\r\nreturn retval;\r\nmutex_lock(&gofh->lock);\r\nif (list_empty(&go->stream))\r\ngoto unlock_and_return;\r\ngobuf = list_entry(go->stream.next,\r\nstruct go7007_buffer, stream);\r\nretval = -EAGAIN;\r\nif (gobuf->state != BUF_STATE_DONE &&\r\n!(file->f_flags & O_NONBLOCK)) {\r\nfor (;;) {\r\nprepare_to_wait(&go->frame_waitq, &wait,\r\nTASK_INTERRUPTIBLE);\r\nif (gobuf->state == BUF_STATE_DONE)\r\nbreak;\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nfinish_wait(&go->frame_waitq, &wait);\r\n}\r\nif (gobuf->state != BUF_STATE_DONE)\r\ngoto unlock_and_return;\r\nspin_lock_irqsave(&go->spinlock, flags);\r\ndeactivate_buffer(gobuf);\r\nspin_unlock_irqrestore(&go->spinlock, flags);\r\nframe_type_flag = get_frame_type_flag(gobuf, go->format);\r\ngobuf->state = BUF_STATE_IDLE;\r\nmemset(buf, 0, sizeof(*buf));\r\nbuf->index = gobuf->index;\r\nbuf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbuf->bytesused = gobuf->bytesused;\r\nbuf->flags = V4L2_BUF_FLAG_MAPPED | frame_type_flag;\r\nbuf->field = V4L2_FIELD_NONE;\r\nbuf->timestamp = gobuf->timestamp;\r\nbuf->sequence = gobuf->seq;\r\nbuf->memory = V4L2_MEMORY_MMAP;\r\nbuf->m.offset = gobuf->index * GO7007_BUF_SIZE;\r\nbuf->length = GO7007_BUF_SIZE;\r\nbuf->reserved = gobuf->modet_active;\r\nmutex_unlock(&gofh->lock);\r\nreturn 0;\r\nunlock_and_return:\r\nmutex_unlock(&gofh->lock);\r\nreturn retval;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct go7007_file *gofh = priv;\r\nstruct go7007 *go = gofh->go;\r\nint retval = 0;\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmutex_lock(&gofh->lock);\r\nmutex_lock(&go->hw_lock);\r\nif (!go->streaming) {\r\ngo->streaming = 1;\r\ngo->next_seq = 0;\r\ngo->active_buf = NULL;\r\nif (go7007_start_encoder(go) < 0)\r\nretval = -EIO;\r\nelse\r\nretval = 0;\r\n}\r\nmutex_unlock(&go->hw_lock);\r\nmutex_unlock(&gofh->lock);\r\nreturn retval;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct go7007_file *gofh = priv;\r\nstruct go7007 *go = gofh->go;\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmutex_lock(&gofh->lock);\r\ngo7007_streamoff(go);\r\nmutex_unlock(&gofh->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *query)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nint id = query->id;\r\nif (0 == call_all(&go->v4l2_dev, core, queryctrl, query))\r\nreturn 0;\r\nquery->id = id;\r\nreturn mpeg_query_ctrl(query);\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (0 == call_all(&go->v4l2_dev, core, g_ctrl, ctrl))\r\nreturn 0;\r\nreturn mpeg_g_ctrl(ctrl, go);\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (0 == call_all(&go->v4l2_dev, core, s_ctrl, ctrl))\r\nreturn 0;\r\nreturn mpeg_s_ctrl(ctrl, go);\r\n}\r\nstatic int vidioc_g_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nstruct v4l2_fract timeperframe = {\r\n.numerator = 1001 * go->fps_scale,\r\n.denominator = go->sensor_framerate,\r\n};\r\nif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nparm->parm.capture.capability |= V4L2_CAP_TIMEPERFRAME;\r\nparm->parm.capture.timeperframe = timeperframe;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nunsigned int n, d;\r\nif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (parm->parm.capture.capturemode != 0)\r\nreturn -EINVAL;\r\nn = go->sensor_framerate *\r\nparm->parm.capture.timeperframe.numerator;\r\nd = 1001 * parm->parm.capture.timeperframe.denominator;\r\nif (n != 0 && d != 0 && n > d)\r\ngo->fps_scale = (n + d/2) / d;\r\nelse\r\ngo->fps_scale = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *filp, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif ((go->board_info->flags & GO7007_BOARD_HAS_TUNER) ||\r\n(go->board_info->sensor_flags & GO7007_SENSOR_TV))\r\nreturn -EINVAL;\r\nif (fsize->index > 0)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = go->board_info->sensor_width;\r\nfsize->discrete.height = go->board_info->sensor_height;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_frameintervals(struct file *filp, void *priv,\r\nstruct v4l2_frmivalenum *fival)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif ((go->board_info->flags & GO7007_BOARD_HAS_TUNER) ||\r\n(go->board_info->sensor_flags & GO7007_SENSOR_TV))\r\nreturn -EINVAL;\r\nif (fival->index > 0)\r\nreturn -EINVAL;\r\nfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nfival->discrete.numerator = 1001;\r\nfival->discrete.denominator = go->board_info->sensor_framerate;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nswitch (go->standard) {\r\ncase GO7007_STD_NTSC:\r\n*std = V4L2_STD_NTSC;\r\nbreak;\r\ncase GO7007_STD_PAL:\r\n*std = V4L2_STD_PAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (go->streaming)\r\nreturn -EBUSY;\r\nif (!(go->board_info->sensor_flags & GO7007_SENSOR_TV) && *std != 0)\r\nreturn -EINVAL;\r\nif (*std == 0)\r\nreturn -EINVAL;\r\nif ((go->board_info->flags & GO7007_BOARD_HAS_TUNER) &&\r\ngo->input == go->board_info->num_inputs - 1) {\r\nif (!go->i2c_adapter_online)\r\nreturn -EIO;\r\nif (call_all(&go->v4l2_dev, core, s_std, *std) < 0)\r\nreturn -EINVAL;\r\n}\r\nif (*std & V4L2_STD_NTSC) {\r\ngo->standard = GO7007_STD_NTSC;\r\ngo->sensor_framerate = 30000;\r\n} else if (*std & V4L2_STD_PAL) {\r\ngo->standard = GO7007_STD_PAL;\r\ngo->sensor_framerate = 25025;\r\n} else if (*std & V4L2_STD_SECAM) {\r\ngo->standard = GO7007_STD_PAL;\r\ngo->sensor_framerate = 25025;\r\n} else\r\nreturn -EINVAL;\r\ncall_all(&go->v4l2_dev, core, s_std, *std);\r\nset_capture_size(go, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif ((go->board_info->flags & GO7007_BOARD_HAS_TUNER) &&\r\ngo->input == go->board_info->num_inputs - 1) {\r\nif (!go->i2c_adapter_online)\r\nreturn -EIO;\r\nreturn call_all(&go->v4l2_dev, video, querystd, std);\r\n} else if (go->board_info->sensor_flags & GO7007_SENSOR_TV)\r\n*std = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM;\r\nelse\r\n*std = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (inp->index >= go->board_info->num_inputs)\r\nreturn -EINVAL;\r\nstrncpy(inp->name, go->board_info->inputs[inp->index].name,\r\nsizeof(inp->name));\r\nif ((go->board_info->flags & GO7007_BOARD_HAS_TUNER) &&\r\ninp->index == go->board_info->num_inputs - 1)\r\ninp->type = V4L2_INPUT_TYPE_TUNER;\r\nelse\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->audioset = 0;\r\ninp->tuner = 0;\r\nif (go->board_info->sensor_flags & GO7007_SENSOR_TV)\r\ninp->std = V4L2_STD_NTSC | V4L2_STD_PAL |\r\nV4L2_STD_SECAM;\r\nelse\r\ninp->std = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *input)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\n*input = go->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int input)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (input >= go->board_info->num_inputs)\r\nreturn -EINVAL;\r\nif (go->streaming)\r\nreturn -EBUSY;\r\ngo->input = input;\r\nreturn call_all(&go->v4l2_dev, video, s_routing, input, 0, 0);\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (!(go->board_info->flags & GO7007_BOARD_HAS_TUNER))\r\nreturn -EINVAL;\r\nif (t->index != 0)\r\nreturn -EINVAL;\r\nif (!go->i2c_adapter_online)\r\nreturn -EIO;\r\nreturn call_all(&go->v4l2_dev, tuner, g_tuner, t);\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (!(go->board_info->flags & GO7007_BOARD_HAS_TUNER))\r\nreturn -EINVAL;\r\nif (t->index != 0)\r\nreturn -EINVAL;\r\nif (!go->i2c_adapter_online)\r\nreturn -EIO;\r\nswitch (go->board_id) {\r\ncase GO7007_BOARDID_PX_TV402U_NA:\r\ncase GO7007_BOARDID_PX_TV402U_JP:\r\nif (t->audmode != V4L2_TUNER_MODE_STEREO)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn call_all(&go->v4l2_dev, tuner, s_tuner, t);\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (!(go->board_info->flags & GO7007_BOARD_HAS_TUNER))\r\nreturn -EINVAL;\r\nif (!go->i2c_adapter_online)\r\nreturn -EIO;\r\nf->type = V4L2_TUNER_ANALOG_TV;\r\nreturn call_all(&go->v4l2_dev, tuner, g_frequency, f);\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (!(go->board_info->flags & GO7007_BOARD_HAS_TUNER))\r\nreturn -EINVAL;\r\nif (!go->i2c_adapter_online)\r\nreturn -EIO;\r\nreturn call_all(&go->v4l2_dev, tuner, s_frequency, f);\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cropcap)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (cropcap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nswitch (go->standard) {\r\ncase GO7007_STD_NTSC:\r\ncropcap->bounds.top = 0;\r\ncropcap->bounds.left = 0;\r\ncropcap->bounds.width = 720;\r\ncropcap->bounds.height = 480;\r\ncropcap->defrect.top = 0;\r\ncropcap->defrect.left = 0;\r\ncropcap->defrect.width = 720;\r\ncropcap->defrect.height = 480;\r\nbreak;\r\ncase GO7007_STD_PAL:\r\ncropcap->bounds.top = 0;\r\ncropcap->bounds.left = 0;\r\ncropcap->bounds.width = 720;\r\ncropcap->bounds.height = 576;\r\ncropcap->defrect.top = 0;\r\ncropcap->defrect.left = 0;\r\ncropcap->defrect.width = 720;\r\ncropcap->defrect.height = 576;\r\nbreak;\r\ncase GO7007_STD_OTHER:\r\ncropcap->bounds.top = 0;\r\ncropcap->bounds.left = 0;\r\ncropcap->bounds.width = go->board_info->sensor_width;\r\ncropcap->bounds.height = go->board_info->sensor_height;\r\ncropcap->defrect.top = 0;\r\ncropcap->defrect.left = 0;\r\ncropcap->defrect.width = go->board_info->sensor_width;\r\ncropcap->defrect.height = go->board_info->sensor_height;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_crop(struct file *file, void *priv, struct v4l2_crop *crop)\r\n{\r\nstruct go7007 *go = ((struct go7007_file *) priv)->go;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncrop->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nswitch (go->standard) {\r\ncase GO7007_STD_NTSC:\r\ncrop->c.top = 0;\r\ncrop->c.left = 0;\r\ncrop->c.width = 720;\r\ncrop->c.height = 480;\r\nbreak;\r\ncase GO7007_STD_PAL:\r\ncrop->c.top = 0;\r\ncrop->c.left = 0;\r\ncrop->c.width = 720;\r\ncrop->c.height = 576;\r\nbreak;\r\ncase GO7007_STD_OTHER:\r\ncrop->c.top = 0;\r\ncrop->c.left = 0;\r\ncrop->c.width = go->board_info->sensor_width;\r\ncrop->c.height = go->board_info->sensor_height;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_crop(struct file *file, void *priv, struct v4l2_crop *crop)\r\n{\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_jpegcomp(struct file *file, void *priv,\r\nstruct v4l2_jpegcompression *params)\r\n{\r\nmemset(params, 0, sizeof(*params));\r\nparams->quality = 50;\r\nparams->jpeg_markers = V4L2_JPEG_MARKER_DHT |\r\nV4L2_JPEG_MARKER_DQT;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_jpegcomp(struct file *file, void *priv,\r\nstruct v4l2_jpegcompression *params)\r\n{\r\nif (params->quality != 50 ||\r\nparams->jpeg_markers != (V4L2_JPEG_MARKER_DHT |\r\nV4L2_JPEG_MARKER_DQT))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t go7007_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void go7007_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct go7007_buffer *gobuf = vma->vm_private_data;\r\n++gobuf->mapped;\r\n}\r\nstatic void go7007_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct go7007_buffer *gobuf = vma->vm_private_data;\r\nunsigned long flags;\r\nif (--gobuf->mapped == 0) {\r\nspin_lock_irqsave(&gobuf->go->spinlock, flags);\r\ndeactivate_buffer(gobuf);\r\nspin_unlock_irqrestore(&gobuf->go->spinlock, flags);\r\n}\r\n}\r\nstatic int go7007_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct page *page;\r\npage = alloc_page(GFP_USER | __GFP_DMA32);\r\nif (!page)\r\nreturn VM_FAULT_OOM;\r\nclear_user_highpage(page, (unsigned long)vmf->virtual_address);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nstatic int go7007_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct go7007_file *gofh = file->private_data;\r\nunsigned int index;\r\nif (gofh->go->status != STATUS_ONLINE)\r\nreturn -EIO;\r\nif (!(vma->vm_flags & VM_SHARED))\r\nreturn -EINVAL;\r\nif (vma->vm_end - vma->vm_start != GO7007_BUF_SIZE)\r\nreturn -EINVAL;\r\nmutex_lock(&gofh->lock);\r\nindex = vma->vm_pgoff / GO7007_BUF_PAGES;\r\nif (index >= gofh->buf_count) {\r\nmutex_unlock(&gofh->lock);\r\nreturn -EINVAL;\r\n}\r\nif (index * GO7007_BUF_PAGES != vma->vm_pgoff) {\r\nmutex_unlock(&gofh->lock);\r\nreturn -EINVAL;\r\n}\r\nif (gofh->bufs[index].mapped > 0) {\r\nmutex_unlock(&gofh->lock);\r\nreturn -EBUSY;\r\n}\r\ngofh->bufs[index].mapped = 1;\r\ngofh->bufs[index].user_addr = vma->vm_start;\r\nvma->vm_ops = &go7007_vm_ops;\r\nvma->vm_flags |= VM_DONTEXPAND;\r\nvma->vm_flags &= ~VM_IO;\r\nvma->vm_private_data = &gofh->bufs[index];\r\nmutex_unlock(&gofh->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int go7007_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct go7007_file *gofh = file->private_data;\r\nstruct go7007_buffer *gobuf;\r\nif (list_empty(&gofh->go->stream))\r\nreturn POLLERR;\r\ngobuf = list_entry(gofh->go->stream.next, struct go7007_buffer, stream);\r\npoll_wait(file, &gofh->go->frame_waitq, wait);\r\nif (gobuf->state == BUF_STATE_DONE)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic void go7007_vfl_release(struct video_device *vfd)\r\n{\r\nstruct go7007 *go = video_get_drvdata(vfd);\r\nvideo_device_release(vfd);\r\nif (--go->ref_count == 0)\r\nkfree(go);\r\n}\r\nint go7007_v4l2_init(struct go7007 *go)\r\n{\r\nint rv;\r\ngo->video_dev = video_device_alloc();\r\nif (go->video_dev == NULL)\r\nreturn -ENOMEM;\r\n*go->video_dev = go7007_template;\r\ngo->video_dev->parent = go->dev;\r\nrv = video_register_device(go->video_dev, VFL_TYPE_GRABBER, -1);\r\nif (rv < 0) {\r\nvideo_device_release(go->video_dev);\r\ngo->video_dev = NULL;\r\nreturn rv;\r\n}\r\nrv = v4l2_device_register(go->dev, &go->v4l2_dev);\r\nif (rv < 0) {\r\nvideo_device_release(go->video_dev);\r\ngo->video_dev = NULL;\r\nreturn rv;\r\n}\r\nvideo_set_drvdata(go->video_dev, go);\r\n++go->ref_count;\r\nprintk(KERN_INFO "%s: registered device %s [v4l2]\n",\r\ngo->video_dev->name, video_device_node_name(go->video_dev));\r\nreturn 0;\r\n}\r\nvoid go7007_v4l2_remove(struct go7007 *go)\r\n{\r\nunsigned long flags;\r\nmutex_lock(&go->hw_lock);\r\nif (go->streaming) {\r\ngo->streaming = 0;\r\ngo7007_stream_stop(go);\r\nspin_lock_irqsave(&go->spinlock, flags);\r\nabort_queued(go);\r\nspin_unlock_irqrestore(&go->spinlock, flags);\r\n}\r\nmutex_unlock(&go->hw_lock);\r\nif (go->video_dev)\r\nvideo_unregister_device(go->video_dev);\r\nv4l2_device_unregister(&go->v4l2_dev);\r\n}
