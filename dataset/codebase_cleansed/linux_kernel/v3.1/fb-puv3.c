static void unifb_sync(struct fb_info *info)\r\n{\r\nint cnt;\r\nfor (cnt = 0; cnt < 0x10000000; cnt++) {\r\nif (readl(UGE_COMMAND) & 0x1000000)\r\nreturn;\r\n}\r\nif (cnt > 0x8000000)\r\ndev_warn(info->device, "Warning: UniGFX GE time out ...\n");\r\n}\r\nstatic void unifb_prim_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *region)\r\n{\r\nint awidth = region->width;\r\nint aheight = region->height;\r\nint m_iBpp = info->var.bits_per_pixel;\r\nint screen_width = info->var.xres;\r\nint src_sel = 1;\r\nint pat_sel = 1;\r\nint src_x0 = 0;\r\nint dst_x0 = region->dx;\r\nint src_y0 = 0;\r\nint dst_y0 = region->dy;\r\nint rop_alpha_sel = 0;\r\nint rop_alpha_code = 0xCC;\r\nint x_dir = 1;\r\nint y_dir = 1;\r\nint alpha_r = 0;\r\nint alpha_sel = 0;\r\nint dst_pitch = screen_width * (m_iBpp / 8);\r\nint dst_offset = dst_y0 * dst_pitch + dst_x0 * (m_iBpp / 8);\r\nint src_pitch = screen_width * (m_iBpp / 8);\r\nint src_offset = src_y0 * src_pitch + src_x0 * (m_iBpp / 8);\r\nunsigned int command = 0;\r\nint clip_region = 0;\r\nint clip_en = 0;\r\nint tp_en = 0;\r\nint fg_color = 0;\r\nint bottom = info->var.yres - 1;\r\nint right = info->var.xres - 1;\r\nint top = 0;\r\nbottom = (bottom << 16) | right;\r\ncommand = (rop_alpha_sel << 26) | (pat_sel << 18) | (src_sel << 16)\r\n| (x_dir << 20) | (y_dir << 21) | (command << 24)\r\n| (clip_region << 23) | (clip_en << 22) | (tp_en << 27);\r\nsrc_pitch = (dst_pitch << 16) | src_pitch;\r\nawidth = awidth | (aheight << 16);\r\nalpha_r = ((rop_alpha_code & 0xff) << 8) | (alpha_r & 0xff)\r\n| (alpha_sel << 16);\r\nsrc_x0 = (src_x0 & 0x1fff) | ((src_y0 & 0x1fff) << 16);\r\ndst_x0 = (dst_x0 & 0x1fff) | ((dst_y0 & 0x1fff) << 16);\r\nfg_color = region->color;\r\nunifb_sync(info);\r\nwritel(((u32 *)(info->pseudo_palette))[fg_color], UGE_FCOLOR);\r\nwritel(0, UGE_BCOLOR);\r\nwritel(src_pitch, UGE_PITCH);\r\nwritel(src_offset, UGE_SRCSTART);\r\nwritel(dst_offset, UGE_DSTSTART);\r\nwritel(awidth, UGE_WIDHEIGHT);\r\nwritel(top, UGE_CLIP0);\r\nwritel(bottom, UGE_CLIP1);\r\nwritel(alpha_r, UGE_ROPALPHA);\r\nwritel(src_x0, UGE_SRCXY);\r\nwritel(dst_x0, UGE_DSTXY);\r\nwritel(command, UGE_COMMAND);\r\n}\r\nstatic void unifb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *region)\r\n{\r\nstruct fb_fillrect modded;\r\nint vxres, vyres;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\nsys_fillrect(info, region);\r\nreturn;\r\n}\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nmemcpy(&modded, region, sizeof(struct fb_fillrect));\r\nif (!modded.width || !modded.height ||\r\nmodded.dx >= vxres || modded.dy >= vyres)\r\nreturn;\r\nif (modded.dx + modded.width > vxres)\r\nmodded.width = vxres - modded.dx;\r\nif (modded.dy + modded.height > vyres)\r\nmodded.height = vyres - modded.dy;\r\nunifb_prim_fillrect(info, &modded);\r\n}\r\nstatic void unifb_prim_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nint awidth = area->width;\r\nint aheight = area->height;\r\nint m_iBpp = info->var.bits_per_pixel;\r\nint screen_width = info->var.xres;\r\nint src_sel = 2;\r\nint pat_sel = 0;\r\nint src_x0 = area->sx;\r\nint dst_x0 = area->dx;\r\nint src_y0 = area->sy;\r\nint dst_y0 = area->dy;\r\nint rop_alpha_sel = 0;\r\nint rop_alpha_code = 0xCC;\r\nint x_dir = 1;\r\nint y_dir = 1;\r\nint alpha_r = 0;\r\nint alpha_sel = 0;\r\nint dst_pitch = screen_width * (m_iBpp / 8);\r\nint dst_offset = dst_y0 * dst_pitch + dst_x0 * (m_iBpp / 8);\r\nint src_pitch = screen_width * (m_iBpp / 8);\r\nint src_offset = src_y0 * src_pitch + src_x0 * (m_iBpp / 8);\r\nunsigned int command = 0;\r\nint clip_region = 0;\r\nint clip_en = 1;\r\nint tp_en = 0;\r\nint top = 0;\r\nint bottom = info->var.yres;\r\nint right = info->var.xres;\r\nint fg_color = 0;\r\nint bg_color = 0;\r\nif (src_x0 < 0)\r\nsrc_x0 = 0;\r\nif (src_y0 < 0)\r\nsrc_y0 = 0;\r\nif (src_y0 - dst_y0 > 0) {\r\ny_dir = 1;\r\n} else {\r\ny_dir = 0;\r\nsrc_offset = (src_y0 + aheight) * src_pitch +\r\nsrc_x0 * (m_iBpp / 8);\r\ndst_offset = (dst_y0 + aheight) * dst_pitch +\r\ndst_x0 * (m_iBpp / 8);\r\nsrc_y0 += aheight;\r\ndst_y0 += aheight;\r\n}\r\ncommand = (rop_alpha_sel << 26) | (pat_sel << 18) | (src_sel << 16) |\r\n(x_dir << 20) | (y_dir << 21) | (command << 24) |\r\n(clip_region << 23) | (clip_en << 22) | (tp_en << 27);\r\nsrc_pitch = (dst_pitch << 16) | src_pitch;\r\nawidth = awidth | (aheight << 16);\r\nalpha_r = ((rop_alpha_code & 0xff) << 8) | (alpha_r & 0xff) |\r\n(alpha_sel << 16);\r\nsrc_x0 = (src_x0 & 0x1fff) | ((src_y0 & 0x1fff) << 16);\r\ndst_x0 = (dst_x0 & 0x1fff) | ((dst_y0 & 0x1fff) << 16);\r\nbottom = (bottom << 16) | right;\r\nunifb_sync(info);\r\nwritel(src_pitch, UGE_PITCH);\r\nwritel(src_offset, UGE_SRCSTART);\r\nwritel(dst_offset, UGE_DSTSTART);\r\nwritel(awidth, UGE_WIDHEIGHT);\r\nwritel(top, UGE_CLIP0);\r\nwritel(bottom, UGE_CLIP1);\r\nwritel(bg_color, UGE_BCOLOR);\r\nwritel(fg_color, UGE_FCOLOR);\r\nwritel(alpha_r, UGE_ROPALPHA);\r\nwritel(src_x0, UGE_SRCXY);\r\nwritel(dst_x0, UGE_DSTXY);\r\nwritel(command, UGE_COMMAND);\r\n}\r\nstatic void unifb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nstruct fb_copyarea modded;\r\nu32 vxres, vyres;\r\nmodded.sx = area->sx;\r\nmodded.sy = area->sy;\r\nmodded.dx = area->dx;\r\nmodded.dy = area->dy;\r\nmodded.width = area->width;\r\nmodded.height = area->height;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\nsys_copyarea(info, area);\r\nreturn;\r\n}\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nif (!modded.width || !modded.height ||\r\nmodded.sx >= vxres || modded.sy >= vyres ||\r\nmodded.dx >= vxres || modded.dy >= vyres)\r\nreturn;\r\nif (modded.sx + modded.width > vxres)\r\nmodded.width = vxres - modded.sx;\r\nif (modded.dx + modded.width > vxres)\r\nmodded.width = vxres - modded.dx;\r\nif (modded.sy + modded.height > vyres)\r\nmodded.height = vyres - modded.sy;\r\nif (modded.dy + modded.height > vyres)\r\nmodded.height = vyres - modded.dy;\r\nunifb_prim_copyarea(info, &modded);\r\n}\r\nstatic void unifb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nsys_imageblit(info, image);\r\n}\r\nstatic u_long get_line_length(int xres_virtual, int bpp)\r\n{\r\nu_long length;\r\nlength = xres_virtual * bpp;\r\nlength = (length + 31) & ~31;\r\nlength >>= 3;\r\nreturn length;\r\n}\r\nstatic int unifb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nu_long line_length;\r\nif (var->vmode & FB_VMODE_CONUPDATE) {\r\nvar->vmode |= FB_VMODE_YWRAP;\r\nvar->xoffset = info->var.xoffset;\r\nvar->yoffset = info->var.yoffset;\r\n}\r\nif (!var->xres)\r\nvar->xres = 1;\r\nif (!var->yres)\r\nvar->yres = 1;\r\nif (var->xres > var->xres_virtual)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres_virtual = var->yres;\r\nif (var->bits_per_pixel <= 1)\r\nvar->bits_per_pixel = 1;\r\nelse if (var->bits_per_pixel <= 8)\r\nvar->bits_per_pixel = 8;\r\nelse if (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse if (var->bits_per_pixel <= 24)\r\nvar->bits_per_pixel = 24;\r\nelse if (var->bits_per_pixel <= 32)\r\nvar->bits_per_pixel = 32;\r\nelse\r\nreturn -EINVAL;\r\nif (var->xres_virtual < var->xoffset + var->xres)\r\nvar->xres_virtual = var->xoffset + var->xres;\r\nif (var->yres_virtual < var->yoffset + var->yres)\r\nvar->yres_virtual = var->yoffset + var->yres;\r\nline_length =\r\nget_line_length(var->xres_virtual, var->bits_per_pixel);\r\nif (line_length * var->yres_virtual > UNIFB_MEMSIZE)\r\nreturn -ENOMEM;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nif (var->transp.length) {\r\nvar->red.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 10;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 15;\r\nvar->transp.length = 1;\r\n} else {\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\n}\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nbreak;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nreturn 0;\r\n}\r\nstatic int unifb_set_par(struct fb_info *info)\r\n{\r\nint hTotal, vTotal, hSyncStart, hSyncEnd, vSyncStart, vSyncEnd;\r\nint format;\r\n#ifdef CONFIG_PUV3_PM\r\nstruct clk *clk_vga;\r\nu32 pixclk = 0;\r\nint i;\r\nfor (i = 0; i <= 10; i++) {\r\nif (info->var.xres == unifb_modes[i].xres\r\n&& info->var.yres == unifb_modes[i].yres\r\n&& info->var.upper_margin == unifb_modes[i].upper_margin\r\n&& info->var.lower_margin == unifb_modes[i].lower_margin\r\n&& info->var.left_margin == unifb_modes[i].left_margin\r\n&& info->var.right_margin == unifb_modes[i].right_margin\r\n&& info->var.hsync_len == unifb_modes[i].hsync_len\r\n&& info->var.vsync_len == unifb_modes[i].vsync_len) {\r\npixclk = unifb_modes[i].pixclock;\r\nbreak;\r\n}\r\n}\r\nclk_vga = clk_get(info->device, "VGA_CLK");\r\nif (clk_vga == ERR_PTR(-ENOENT))\r\nreturn -ENOENT;\r\nif (pixclk != 0) {\r\nif (clk_set_rate(clk_vga, pixclk)) {\r\ninfo->fix = unifb_fix;\r\ninfo->var = unifb_default;\r\nif (clk_set_rate(clk_vga, unifb_default.pixclock))\r\nreturn -EINVAL;\r\n}\r\n}\r\n#endif\r\ninfo->fix.line_length = get_line_length(info->var.xres_virtual,\r\ninfo->var.bits_per_pixel);\r\nhSyncStart = info->var.xres + info->var.right_margin;\r\nhSyncEnd = hSyncStart + info->var.hsync_len;\r\nhTotal = hSyncEnd + info->var.left_margin;\r\nvSyncStart = info->var.yres + info->var.lower_margin;\r\nvSyncEnd = vSyncStart + info->var.vsync_len;\r\nvTotal = vSyncEnd + info->var.upper_margin;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nformat = UDE_CFG_DST8;\r\nbreak;\r\ncase 16:\r\nformat = UDE_CFG_DST16;\r\nbreak;\r\ncase 24:\r\nformat = UDE_CFG_DST24;\r\nbreak;\r\ncase 32:\r\nformat = UDE_CFG_DST32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(info->fix.smem_start, UDE_FSA);\r\nwritel(info->var.yres, UDE_LS);\r\nwritel(get_line_length(info->var.xres,\r\ninfo->var.bits_per_pixel) >> 3, UDE_PS);\r\nwritel((hTotal << 16) | (info->var.xres), UDE_HAT);\r\nwritel(((hTotal - 1) << 16) | (info->var.xres - 1), UDE_HBT);\r\nwritel(((hSyncEnd - 1) << 16) | (hSyncStart - 1), UDE_HST);\r\nwritel((vTotal << 16) | (info->var.yres), UDE_VAT);\r\nwritel(((vTotal - 1) << 16) | (info->var.yres - 1), UDE_VBT);\r\nwritel(((vSyncEnd - 1) << 16) | (vSyncStart - 1), UDE_VST);\r\nwritel(UDE_CFG_GDEN_ENABLE | UDE_CFG_TIMEUP_ENABLE\r\n| format | 0xC0000001, UDE_CFG);\r\nreturn 0;\r\n}\r\nstatic int unifb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nif (regno >= 256)\r\nreturn 1;\r\nif (info->var.grayscale) {\r\nred = green = blue =\r\n(red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\n#define CNVT_TOHW(val, width) ((((val)<<(width))+0x7FFF-(val))>>16)\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\nbreak;\r\ncase FB_VISUAL_DIRECTCOLOR:\r\nred = CNVT_TOHW(red, 8);\r\ngreen = CNVT_TOHW(green, 8);\r\nblue = CNVT_TOHW(blue, 8);\r\ntransp = CNVT_TOHW(transp, 8);\r\nbreak;\r\n}\r\n#undef CNVT_TOHW\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 v;\r\nif (regno >= 16)\r\nreturn 1;\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nbreak;\r\ncase 16:\r\ncase 24:\r\ncase 32:\r\n((u32 *) (info->pseudo_palette))[regno] = v;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int unifb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (var->yoffset < 0\r\n|| var->yoffset >= info->var.yres_virtual\r\n|| var->xoffset)\r\nreturn -EINVAL;\r\n} else {\r\nif (var->xoffset + var->xres > info->var.xres_virtual ||\r\nvar->yoffset + var->yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\n}\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nreturn 0;\r\n}\r\nint unifb_mmap(struct fb_info *info,\r\nstruct vm_area_struct *vma)\r\n{\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nunsigned long pos = info->fix.smem_start + offset;\r\nif (offset + size > info->fix.smem_len)\r\nreturn -EINVAL;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nif (io_remap_pfn_range(vma, vma->vm_start, pos >> PAGE_SHIFT, size,\r\nvma->vm_page_prot))\r\nreturn -EAGAIN;\r\nvma->vm_flags |= VM_RESERVED;\r\nreturn 0;\r\n}\r\nstatic int unifb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nu32 unifb_regs[UNIFB_REGS_NUM];\r\nint retval = -ENOMEM;\r\nstruct resource *iomem;\r\nvoid *videomemory;\r\nvideomemory = (void *)__get_free_pages(GFP_KERNEL | __GFP_COMP,\r\nget_order(UNIFB_MEMSIZE));\r\nif (!videomemory)\r\ngoto err;\r\nmemset(videomemory, 0, UNIFB_MEMSIZE);\r\nunifb_fix.smem_start = virt_to_phys(videomemory);\r\nunifb_fix.smem_len = UNIFB_MEMSIZE;\r\niomem = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nunifb_fix.mmio_start = iomem->start;\r\ninfo = framebuffer_alloc(sizeof(u32)*256, &dev->dev);\r\nif (!info)\r\ngoto err;\r\ninfo->screen_base = (char __iomem *)videomemory;\r\ninfo->fbops = &unifb_ops;\r\nretval = fb_find_mode(&info->var, info, NULL,\r\nunifb_modes, 10, &unifb_modes[0], 16);\r\nif (!retval || (retval == 4))\r\ninfo->var = unifb_default;\r\ninfo->fix = unifb_fix;\r\ninfo->pseudo_palette = info->par;\r\ninfo->par = NULL;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\n#ifdef FB_ACCEL_PUV3_UNIGFX\r\ninfo->fix.accel = FB_ACCEL_PUV3_UNIGFX;\r\n#endif\r\nretval = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (retval < 0)\r\ngoto err1;\r\nretval = register_framebuffer(info);\r\nif (retval < 0)\r\ngoto err2;\r\nplatform_set_drvdata(dev, info);\r\nplatform_device_add_data(dev, unifb_regs, sizeof(u32) * UNIFB_REGS_NUM);\r\nprintk(KERN_INFO\r\n"fb%d: Virtual frame buffer device, using %dM of video memory\n",\r\ninfo->node, UNIFB_MEMSIZE >> 20);\r\nreturn 0;\r\nerr2:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr1:\r\nframebuffer_release(info);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int unifb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nif (info) {\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int unifb_resume(struct platform_device *dev)\r\n{\r\nint rc = 0;\r\nu32 *unifb_regs = dev->dev.platform_data;\r\nif (dev->dev.power.power_state.event == PM_EVENT_ON)\r\nreturn 0;\r\nconsole_lock();\r\nif (dev->dev.power.power_state.event == PM_EVENT_SUSPEND) {\r\nwritel(unifb_regs[0], UDE_FSA);\r\nwritel(unifb_regs[1], UDE_LS);\r\nwritel(unifb_regs[2], UDE_PS);\r\nwritel(unifb_regs[3], UDE_HAT);\r\nwritel(unifb_regs[4], UDE_HBT);\r\nwritel(unifb_regs[5], UDE_HST);\r\nwritel(unifb_regs[6], UDE_VAT);\r\nwritel(unifb_regs[7], UDE_VBT);\r\nwritel(unifb_regs[8], UDE_VST);\r\nwritel(unifb_regs[9], UDE_CFG);\r\n}\r\ndev->dev.power.power_state = PMSG_ON;\r\nconsole_unlock();\r\nreturn rc;\r\n}\r\nstatic int unifb_suspend(struct platform_device *dev, pm_message_t mesg)\r\n{\r\nu32 *unifb_regs = dev->dev.platform_data;\r\nunifb_regs[0] = readl(UDE_FSA);\r\nunifb_regs[1] = readl(UDE_LS);\r\nunifb_regs[2] = readl(UDE_PS);\r\nunifb_regs[3] = readl(UDE_HAT);\r\nunifb_regs[4] = readl(UDE_HBT);\r\nunifb_regs[5] = readl(UDE_HST);\r\nunifb_regs[6] = readl(UDE_VAT);\r\nunifb_regs[7] = readl(UDE_VBT);\r\nunifb_regs[8] = readl(UDE_VST);\r\nunifb_regs[9] = readl(UDE_CFG);\r\nif (mesg.event == dev->dev.power.power_state.event)\r\nreturn 0;\r\nswitch (mesg.event) {\r\ncase PM_EVENT_FREEZE:\r\ncase PM_EVENT_PRETHAW:\r\ngoto done;\r\n}\r\nconsole_lock();\r\nconsole_unlock();\r\ndone:\r\ndev->dev.power.power_state = mesg;\r\nreturn 0;\r\n}\r\nstatic int __init unifb_init(void)\r\n{\r\n#ifndef MODULE\r\nif (fb_get_options("unifb", NULL))\r\nreturn -ENODEV;\r\n#endif\r\nreturn platform_driver_register(&unifb_driver);\r\n}\r\nstatic void __exit unifb_exit(void)\r\n{\r\nplatform_driver_unregister(&unifb_driver);\r\n}
