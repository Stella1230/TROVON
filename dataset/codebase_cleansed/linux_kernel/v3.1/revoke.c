static inline int hash(journal_t *journal, unsigned long long block)\r\n{\r\nstruct jbd2_revoke_table_s *table = journal->j_revoke;\r\nint hash_shift = table->hash_shift;\r\nint hash = (int)block ^ (int)((block >> 31) >> 1);\r\nreturn ((hash << (hash_shift - 6)) ^\r\n(hash >> 13) ^\r\n(hash << (hash_shift - 12))) & (table->hash_size - 1);\r\n}\r\nstatic int insert_revoke_hash(journal_t *journal, unsigned long long blocknr,\r\ntid_t seq)\r\n{\r\nstruct list_head *hash_list;\r\nstruct jbd2_revoke_record_s *record;\r\nrepeat:\r\nrecord = kmem_cache_alloc(jbd2_revoke_record_cache, GFP_NOFS);\r\nif (!record)\r\ngoto oom;\r\nrecord->sequence = seq;\r\nrecord->blocknr = blocknr;\r\nhash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\r\nspin_lock(&journal->j_revoke_lock);\r\nlist_add(&record->hash, hash_list);\r\nspin_unlock(&journal->j_revoke_lock);\r\nreturn 0;\r\noom:\r\nif (!journal_oom_retry)\r\nreturn -ENOMEM;\r\njbd_debug(1, "ENOMEM in %s, retrying\n", __func__);\r\nyield();\r\ngoto repeat;\r\n}\r\nstatic struct jbd2_revoke_record_s *find_revoke_record(journal_t *journal,\r\nunsigned long long blocknr)\r\n{\r\nstruct list_head *hash_list;\r\nstruct jbd2_revoke_record_s *record;\r\nhash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\r\nspin_lock(&journal->j_revoke_lock);\r\nrecord = (struct jbd2_revoke_record_s *) hash_list->next;\r\nwhile (&(record->hash) != hash_list) {\r\nif (record->blocknr == blocknr) {\r\nspin_unlock(&journal->j_revoke_lock);\r\nreturn record;\r\n}\r\nrecord = (struct jbd2_revoke_record_s *) record->hash.next;\r\n}\r\nspin_unlock(&journal->j_revoke_lock);\r\nreturn NULL;\r\n}\r\nvoid jbd2_journal_destroy_revoke_caches(void)\r\n{\r\nif (jbd2_revoke_record_cache) {\r\nkmem_cache_destroy(jbd2_revoke_record_cache);\r\njbd2_revoke_record_cache = NULL;\r\n}\r\nif (jbd2_revoke_table_cache) {\r\nkmem_cache_destroy(jbd2_revoke_table_cache);\r\njbd2_revoke_table_cache = NULL;\r\n}\r\n}\r\nint __init jbd2_journal_init_revoke_caches(void)\r\n{\r\nJ_ASSERT(!jbd2_revoke_record_cache);\r\nJ_ASSERT(!jbd2_revoke_table_cache);\r\njbd2_revoke_record_cache = kmem_cache_create("jbd2_revoke_record",\r\nsizeof(struct jbd2_revoke_record_s),\r\n0,\r\nSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\r\nNULL);\r\nif (!jbd2_revoke_record_cache)\r\ngoto record_cache_failure;\r\njbd2_revoke_table_cache = kmem_cache_create("jbd2_revoke_table",\r\nsizeof(struct jbd2_revoke_table_s),\r\n0, SLAB_TEMPORARY, NULL);\r\nif (!jbd2_revoke_table_cache)\r\ngoto table_cache_failure;\r\nreturn 0;\r\ntable_cache_failure:\r\njbd2_journal_destroy_revoke_caches();\r\nrecord_cache_failure:\r\nreturn -ENOMEM;\r\n}\r\nstatic struct jbd2_revoke_table_s *jbd2_journal_init_revoke_table(int hash_size)\r\n{\r\nint shift = 0;\r\nint tmp = hash_size;\r\nstruct jbd2_revoke_table_s *table;\r\ntable = kmem_cache_alloc(jbd2_revoke_table_cache, GFP_KERNEL);\r\nif (!table)\r\ngoto out;\r\nwhile((tmp >>= 1UL) != 0UL)\r\nshift++;\r\ntable->hash_size = hash_size;\r\ntable->hash_shift = shift;\r\ntable->hash_table =\r\nkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\r\nif (!table->hash_table) {\r\nkmem_cache_free(jbd2_revoke_table_cache, table);\r\ntable = NULL;\r\ngoto out;\r\n}\r\nfor (tmp = 0; tmp < hash_size; tmp++)\r\nINIT_LIST_HEAD(&table->hash_table[tmp]);\r\nout:\r\nreturn table;\r\n}\r\nstatic void jbd2_journal_destroy_revoke_table(struct jbd2_revoke_table_s *table)\r\n{\r\nint i;\r\nstruct list_head *hash_list;\r\nfor (i = 0; i < table->hash_size; i++) {\r\nhash_list = &table->hash_table[i];\r\nJ_ASSERT(list_empty(hash_list));\r\n}\r\nkfree(table->hash_table);\r\nkmem_cache_free(jbd2_revoke_table_cache, table);\r\n}\r\nint jbd2_journal_init_revoke(journal_t *journal, int hash_size)\r\n{\r\nJ_ASSERT(journal->j_revoke_table[0] == NULL);\r\nJ_ASSERT(is_power_of_2(hash_size));\r\njournal->j_revoke_table[0] = jbd2_journal_init_revoke_table(hash_size);\r\nif (!journal->j_revoke_table[0])\r\ngoto fail0;\r\njournal->j_revoke_table[1] = jbd2_journal_init_revoke_table(hash_size);\r\nif (!journal->j_revoke_table[1])\r\ngoto fail1;\r\njournal->j_revoke = journal->j_revoke_table[1];\r\nspin_lock_init(&journal->j_revoke_lock);\r\nreturn 0;\r\nfail1:\r\njbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\r\nfail0:\r\nreturn -ENOMEM;\r\n}\r\nvoid jbd2_journal_destroy_revoke(journal_t *journal)\r\n{\r\njournal->j_revoke = NULL;\r\nif (journal->j_revoke_table[0])\r\njbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\r\nif (journal->j_revoke_table[1])\r\njbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\r\n}\r\nint jbd2_journal_revoke(handle_t *handle, unsigned long long blocknr,\r\nstruct buffer_head *bh_in)\r\n{\r\nstruct buffer_head *bh = NULL;\r\njournal_t *journal;\r\nstruct block_device *bdev;\r\nint err;\r\nmight_sleep();\r\nif (bh_in)\r\nBUFFER_TRACE(bh_in, "enter");\r\njournal = handle->h_transaction->t_journal;\r\nif (!jbd2_journal_set_features(journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)){\r\nJ_ASSERT (!"Cannot set revoke feature!");\r\nreturn -EINVAL;\r\n}\r\nbdev = journal->j_fs_dev;\r\nbh = bh_in;\r\nif (!bh) {\r\nbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\r\nif (bh)\r\nBUFFER_TRACE(bh, "found on hash");\r\n}\r\n#ifdef JBD2_EXPENSIVE_CHECKING\r\nelse {\r\nstruct buffer_head *bh2;\r\nbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\r\nif (bh2) {\r\nif (bh2 != bh && buffer_revokevalid(bh2))\r\nJ_ASSERT_BH(bh2, buffer_revoked(bh2));\r\nput_bh(bh2);\r\n}\r\n}\r\n#endif\r\nif (bh) {\r\nif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\r\n"inconsistent data on disk")) {\r\nif (!bh_in)\r\nbrelse(bh);\r\nreturn -EIO;\r\n}\r\nset_buffer_revoked(bh);\r\nset_buffer_revokevalid(bh);\r\nif (bh_in) {\r\nBUFFER_TRACE(bh_in, "call jbd2_journal_forget");\r\njbd2_journal_forget(handle, bh_in);\r\n} else {\r\nBUFFER_TRACE(bh, "call brelse");\r\n__brelse(bh);\r\n}\r\n}\r\njbd_debug(2, "insert revoke for block %llu, bh_in=%p\n",blocknr, bh_in);\r\nerr = insert_revoke_hash(journal, blocknr,\r\nhandle->h_transaction->t_tid);\r\nBUFFER_TRACE(bh_in, "exit");\r\nreturn err;\r\n}\r\nint jbd2_journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\r\n{\r\nstruct jbd2_revoke_record_s *record;\r\njournal_t *journal = handle->h_transaction->t_journal;\r\nint need_cancel;\r\nint did_revoke = 0;\r\nstruct buffer_head *bh = jh2bh(jh);\r\njbd_debug(4, "journal_head %p, cancelling revoke\n", jh);\r\nif (test_set_buffer_revokevalid(bh)) {\r\nneed_cancel = test_clear_buffer_revoked(bh);\r\n} else {\r\nneed_cancel = 1;\r\nclear_buffer_revoked(bh);\r\n}\r\nif (need_cancel) {\r\nrecord = find_revoke_record(journal, bh->b_blocknr);\r\nif (record) {\r\njbd_debug(4, "cancelled existing revoke on "\r\n"blocknr %llu\n", (unsigned long long)bh->b_blocknr);\r\nspin_lock(&journal->j_revoke_lock);\r\nlist_del(&record->hash);\r\nspin_unlock(&journal->j_revoke_lock);\r\nkmem_cache_free(jbd2_revoke_record_cache, record);\r\ndid_revoke = 1;\r\n}\r\n}\r\n#ifdef JBD2_EXPENSIVE_CHECKING\r\nrecord = find_revoke_record(journal, bh->b_blocknr);\r\nJ_ASSERT_JH(jh, record == NULL);\r\n#endif\r\nif (need_cancel) {\r\nstruct buffer_head *bh2;\r\nbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\r\nif (bh2) {\r\nif (bh2 != bh)\r\nclear_buffer_revoked(bh2);\r\n__brelse(bh2);\r\n}\r\n}\r\nreturn did_revoke;\r\n}\r\nvoid jbd2_journal_switch_revoke_table(journal_t *journal)\r\n{\r\nint i;\r\nif (journal->j_revoke == journal->j_revoke_table[0])\r\njournal->j_revoke = journal->j_revoke_table[1];\r\nelse\r\njournal->j_revoke = journal->j_revoke_table[0];\r\nfor (i = 0; i < journal->j_revoke->hash_size; i++)\r\nINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\r\n}\r\nvoid jbd2_journal_write_revoke_records(journal_t *journal,\r\ntransaction_t *transaction,\r\nint write_op)\r\n{\r\nstruct journal_head *descriptor;\r\nstruct jbd2_revoke_record_s *record;\r\nstruct jbd2_revoke_table_s *revoke;\r\nstruct list_head *hash_list;\r\nint i, offset, count;\r\ndescriptor = NULL;\r\noffset = 0;\r\ncount = 0;\r\nrevoke = journal->j_revoke == journal->j_revoke_table[0] ?\r\njournal->j_revoke_table[1] : journal->j_revoke_table[0];\r\nfor (i = 0; i < revoke->hash_size; i++) {\r\nhash_list = &revoke->hash_table[i];\r\nwhile (!list_empty(hash_list)) {\r\nrecord = (struct jbd2_revoke_record_s *)\r\nhash_list->next;\r\nwrite_one_revoke_record(journal, transaction,\r\n&descriptor, &offset,\r\nrecord, write_op);\r\ncount++;\r\nlist_del(&record->hash);\r\nkmem_cache_free(jbd2_revoke_record_cache, record);\r\n}\r\n}\r\nif (descriptor)\r\nflush_descriptor(journal, descriptor, offset, write_op);\r\njbd_debug(1, "Wrote %d revoke records\n", count);\r\n}\r\nstatic void write_one_revoke_record(journal_t *journal,\r\ntransaction_t *transaction,\r\nstruct journal_head **descriptorp,\r\nint *offsetp,\r\nstruct jbd2_revoke_record_s *record,\r\nint write_op)\r\n{\r\nstruct journal_head *descriptor;\r\nint offset;\r\njournal_header_t *header;\r\nif (is_journal_aborted(journal))\r\nreturn;\r\ndescriptor = *descriptorp;\r\noffset = *offsetp;\r\nif (descriptor) {\r\nif (offset == journal->j_blocksize) {\r\nflush_descriptor(journal, descriptor, offset, write_op);\r\ndescriptor = NULL;\r\n}\r\n}\r\nif (!descriptor) {\r\ndescriptor = jbd2_journal_get_descriptor_buffer(journal);\r\nif (!descriptor)\r\nreturn;\r\nheader = (journal_header_t *) &jh2bh(descriptor)->b_data[0];\r\nheader->h_magic = cpu_to_be32(JBD2_MAGIC_NUMBER);\r\nheader->h_blocktype = cpu_to_be32(JBD2_REVOKE_BLOCK);\r\nheader->h_sequence = cpu_to_be32(transaction->t_tid);\r\nJBUFFER_TRACE(descriptor, "file as BJ_LogCtl");\r\njbd2_journal_file_buffer(descriptor, transaction, BJ_LogCtl);\r\noffset = sizeof(jbd2_journal_revoke_header_t);\r\n*descriptorp = descriptor;\r\n}\r\nif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT)) {\r\n* ((__be64 *)(&jh2bh(descriptor)->b_data[offset])) =\r\ncpu_to_be64(record->blocknr);\r\noffset += 8;\r\n} else {\r\n* ((__be32 *)(&jh2bh(descriptor)->b_data[offset])) =\r\ncpu_to_be32(record->blocknr);\r\noffset += 4;\r\n}\r\n*offsetp = offset;\r\n}\r\nstatic void flush_descriptor(journal_t *journal,\r\nstruct journal_head *descriptor,\r\nint offset, int write_op)\r\n{\r\njbd2_journal_revoke_header_t *header;\r\nstruct buffer_head *bh = jh2bh(descriptor);\r\nif (is_journal_aborted(journal)) {\r\nput_bh(bh);\r\nreturn;\r\n}\r\nheader = (jbd2_journal_revoke_header_t *) jh2bh(descriptor)->b_data;\r\nheader->r_count = cpu_to_be32(offset);\r\nset_buffer_jwrite(bh);\r\nBUFFER_TRACE(bh, "write");\r\nset_buffer_dirty(bh);\r\nwrite_dirty_buffer(bh, write_op);\r\n}\r\nint jbd2_journal_set_revoke(journal_t *journal,\r\nunsigned long long blocknr,\r\ntid_t sequence)\r\n{\r\nstruct jbd2_revoke_record_s *record;\r\nrecord = find_revoke_record(journal, blocknr);\r\nif (record) {\r\nif (tid_gt(sequence, record->sequence))\r\nrecord->sequence = sequence;\r\nreturn 0;\r\n}\r\nreturn insert_revoke_hash(journal, blocknr, sequence);\r\n}\r\nint jbd2_journal_test_revoke(journal_t *journal,\r\nunsigned long long blocknr,\r\ntid_t sequence)\r\n{\r\nstruct jbd2_revoke_record_s *record;\r\nrecord = find_revoke_record(journal, blocknr);\r\nif (!record)\r\nreturn 0;\r\nif (tid_gt(sequence, record->sequence))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid jbd2_journal_clear_revoke(journal_t *journal)\r\n{\r\nint i;\r\nstruct list_head *hash_list;\r\nstruct jbd2_revoke_record_s *record;\r\nstruct jbd2_revoke_table_s *revoke;\r\nrevoke = journal->j_revoke;\r\nfor (i = 0; i < revoke->hash_size; i++) {\r\nhash_list = &revoke->hash_table[i];\r\nwhile (!list_empty(hash_list)) {\r\nrecord = (struct jbd2_revoke_record_s*) hash_list->next;\r\nlist_del(&record->hash);\r\nkmem_cache_free(jbd2_revoke_record_cache, record);\r\n}\r\n}\r\n}
