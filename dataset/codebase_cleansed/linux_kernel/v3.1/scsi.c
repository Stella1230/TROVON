const char * scsi_device_type(unsigned type)\r\n{\r\nif (type == 0x1e)\r\nreturn "Well-known LUN ";\r\nif (type == 0x1f)\r\nreturn "No Device ";\r\nif (type >= ARRAY_SIZE(scsi_device_types))\r\nreturn "Unknown ";\r\nreturn scsi_device_types[type];\r\n}\r\nstatic struct scsi_cmnd *\r\nscsi_pool_alloc_command(struct scsi_host_cmd_pool *pool, gfp_t gfp_mask)\r\n{\r\nstruct scsi_cmnd *cmd;\r\ncmd = kmem_cache_zalloc(pool->cmd_slab, gfp_mask | pool->gfp_mask);\r\nif (!cmd)\r\nreturn NULL;\r\ncmd->sense_buffer = kmem_cache_alloc(pool->sense_slab,\r\ngfp_mask | pool->gfp_mask);\r\nif (!cmd->sense_buffer) {\r\nkmem_cache_free(pool->cmd_slab, cmd);\r\nreturn NULL;\r\n}\r\nreturn cmd;\r\n}\r\nstatic void\r\nscsi_pool_free_command(struct scsi_host_cmd_pool *pool,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nif (cmd->prot_sdb)\r\nkmem_cache_free(scsi_sdb_cache, cmd->prot_sdb);\r\nkmem_cache_free(pool->sense_slab, cmd->sense_buffer);\r\nkmem_cache_free(pool->cmd_slab, cmd);\r\n}\r\nstatic struct scsi_cmnd *\r\nscsi_host_alloc_command(struct Scsi_Host *shost, gfp_t gfp_mask)\r\n{\r\nstruct scsi_cmnd *cmd;\r\ncmd = scsi_pool_alloc_command(shost->cmd_pool, gfp_mask);\r\nif (!cmd)\r\nreturn NULL;\r\nif (scsi_host_get_prot(shost) >= SHOST_DIX_TYPE0_PROTECTION) {\r\ncmd->prot_sdb = kmem_cache_zalloc(scsi_sdb_cache, gfp_mask);\r\nif (!cmd->prot_sdb) {\r\nscsi_pool_free_command(shost->cmd_pool, cmd);\r\nreturn NULL;\r\n}\r\n}\r\nreturn cmd;\r\n}\r\nstruct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)\r\n{\r\nstruct scsi_cmnd *cmd = scsi_host_alloc_command(shost, gfp_mask);\r\nif (unlikely(!cmd)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&shost->free_list_lock, flags);\r\nif (likely(!list_empty(&shost->free_list))) {\r\ncmd = list_entry(shost->free_list.next,\r\nstruct scsi_cmnd, list);\r\nlist_del_init(&cmd->list);\r\n}\r\nspin_unlock_irqrestore(&shost->free_list_lock, flags);\r\nif (cmd) {\r\nvoid *buf, *prot;\r\nbuf = cmd->sense_buffer;\r\nprot = cmd->prot_sdb;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->sense_buffer = buf;\r\ncmd->prot_sdb = prot;\r\n}\r\n}\r\nreturn cmd;\r\n}\r\nstruct scsi_cmnd *scsi_get_command(struct scsi_device *dev, gfp_t gfp_mask)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nif (!get_device(&dev->sdev_gendev))\r\nreturn NULL;\r\ncmd = __scsi_get_command(dev->host, gfp_mask);\r\nif (likely(cmd != NULL)) {\r\nunsigned long flags;\r\ncmd->device = dev;\r\nINIT_LIST_HEAD(&cmd->list);\r\nspin_lock_irqsave(&dev->list_lock, flags);\r\nlist_add_tail(&cmd->list, &dev->cmd_list);\r\nspin_unlock_irqrestore(&dev->list_lock, flags);\r\ncmd->jiffies_at_alloc = jiffies;\r\n} else\r\nput_device(&dev->sdev_gendev);\r\nreturn cmd;\r\n}\r\nvoid __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,\r\nstruct device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&shost->free_list_lock, flags);\r\nif (unlikely(list_empty(&shost->free_list))) {\r\nlist_add(&cmd->list, &shost->free_list);\r\ncmd = NULL;\r\n}\r\nspin_unlock_irqrestore(&shost->free_list_lock, flags);\r\nif (likely(cmd != NULL))\r\nscsi_pool_free_command(shost->cmd_pool, cmd);\r\nput_device(dev);\r\n}\r\nvoid scsi_put_command(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->device->list_lock, flags);\r\nBUG_ON(list_empty(&cmd->list));\r\nlist_del_init(&cmd->list);\r\nspin_unlock_irqrestore(&cmd->device->list_lock, flags);\r\n__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);\r\n}\r\nstatic struct scsi_host_cmd_pool *scsi_get_host_cmd_pool(gfp_t gfp_mask)\r\n{\r\nstruct scsi_host_cmd_pool *retval = NULL, *pool;\r\nmutex_lock(&host_cmd_pool_mutex);\r\npool = (gfp_mask & __GFP_DMA) ? &scsi_cmd_dma_pool :\r\n&scsi_cmd_pool;\r\nif (!pool->users) {\r\npool->cmd_slab = kmem_cache_create(pool->cmd_name,\r\nsizeof(struct scsi_cmnd), 0,\r\npool->slab_flags, NULL);\r\nif (!pool->cmd_slab)\r\ngoto fail;\r\npool->sense_slab = kmem_cache_create(pool->sense_name,\r\nSCSI_SENSE_BUFFERSIZE, 0,\r\npool->slab_flags, NULL);\r\nif (!pool->sense_slab) {\r\nkmem_cache_destroy(pool->cmd_slab);\r\ngoto fail;\r\n}\r\n}\r\npool->users++;\r\nretval = pool;\r\nfail:\r\nmutex_unlock(&host_cmd_pool_mutex);\r\nreturn retval;\r\n}\r\nstatic void scsi_put_host_cmd_pool(gfp_t gfp_mask)\r\n{\r\nstruct scsi_host_cmd_pool *pool;\r\nmutex_lock(&host_cmd_pool_mutex);\r\npool = (gfp_mask & __GFP_DMA) ? &scsi_cmd_dma_pool :\r\n&scsi_cmd_pool;\r\nBUG_ON(pool->users == 0);\r\nif (!--pool->users) {\r\nkmem_cache_destroy(pool->cmd_slab);\r\nkmem_cache_destroy(pool->sense_slab);\r\n}\r\nmutex_unlock(&host_cmd_pool_mutex);\r\n}\r\nstruct scsi_cmnd *scsi_allocate_command(gfp_t gfp_mask)\r\n{\r\nstruct scsi_host_cmd_pool *pool = scsi_get_host_cmd_pool(gfp_mask);\r\nif (!pool)\r\nreturn NULL;\r\nreturn scsi_pool_alloc_command(pool, gfp_mask);\r\n}\r\nvoid scsi_free_command(gfp_t gfp_mask, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_host_cmd_pool *pool = scsi_get_host_cmd_pool(gfp_mask);\r\nBUG_ON(!pool);\r\nscsi_pool_free_command(pool, cmd);\r\nscsi_put_host_cmd_pool(gfp_mask);\r\nscsi_put_host_cmd_pool(gfp_mask);\r\n}\r\nint scsi_setup_command_freelist(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nconst gfp_t gfp_mask = shost->unchecked_isa_dma ? GFP_DMA : GFP_KERNEL;\r\nspin_lock_init(&shost->free_list_lock);\r\nINIT_LIST_HEAD(&shost->free_list);\r\nshost->cmd_pool = scsi_get_host_cmd_pool(gfp_mask);\r\nif (!shost->cmd_pool)\r\nreturn -ENOMEM;\r\ncmd = scsi_host_alloc_command(shost, gfp_mask);\r\nif (!cmd) {\r\nscsi_put_host_cmd_pool(gfp_mask);\r\nshost->cmd_pool = NULL;\r\nreturn -ENOMEM;\r\n}\r\nlist_add(&cmd->list, &shost->free_list);\r\nreturn 0;\r\n}\r\nvoid scsi_destroy_command_freelist(struct Scsi_Host *shost)\r\n{\r\nif (!shost->cmd_pool)\r\nreturn;\r\nwhile (!list_empty(&shost->free_list)) {\r\nstruct scsi_cmnd *cmd;\r\ncmd = list_entry(shost->free_list.next, struct scsi_cmnd, list);\r\nlist_del_init(&cmd->list);\r\nscsi_pool_free_command(shost->cmd_pool, cmd);\r\n}\r\nshost->cmd_pool = NULL;\r\nscsi_put_host_cmd_pool(shost->unchecked_isa_dma ? GFP_DMA : GFP_KERNEL);\r\n}\r\nvoid scsi_log_send(struct scsi_cmnd *cmd)\r\n{\r\nunsigned int level;\r\nif (unlikely(scsi_logging_level)) {\r\nlevel = SCSI_LOG_LEVEL(SCSI_LOG_MLQUEUE_SHIFT,\r\nSCSI_LOG_MLQUEUE_BITS);\r\nif (level > 1) {\r\nscmd_printk(KERN_INFO, cmd, "Send: ");\r\nif (level > 2)\r\nprintk("0x%p ", cmd);\r\nprintk("\n");\r\nscsi_print_command(cmd);\r\nif (level > 3) {\r\nprintk(KERN_INFO "buffer = 0x%p, bufflen = %d,"\r\n" queuecommand 0x%p\n",\r\nscsi_sglist(cmd), scsi_bufflen(cmd),\r\ncmd->device->host->hostt->queuecommand);\r\n}\r\n}\r\n}\r\n}\r\nvoid scsi_log_completion(struct scsi_cmnd *cmd, int disposition)\r\n{\r\nunsigned int level;\r\nif (unlikely(scsi_logging_level)) {\r\nlevel = SCSI_LOG_LEVEL(SCSI_LOG_MLCOMPLETE_SHIFT,\r\nSCSI_LOG_MLCOMPLETE_BITS);\r\nif (((level > 0) && (cmd->result || disposition != SUCCESS)) ||\r\n(level > 1)) {\r\nscmd_printk(KERN_INFO, cmd, "Done: ");\r\nif (level > 2)\r\nprintk("0x%p ", cmd);\r\nswitch (disposition) {\r\ncase SUCCESS:\r\nprintk("SUCCESS\n");\r\nbreak;\r\ncase NEEDS_RETRY:\r\nprintk("RETRY\n");\r\nbreak;\r\ncase ADD_TO_MLQUEUE:\r\nprintk("MLQUEUE\n");\r\nbreak;\r\ncase FAILED:\r\nprintk("FAILED\n");\r\nbreak;\r\ncase TIMEOUT_ERROR:\r\nprintk("TIMEOUT\n");\r\nbreak;\r\ndefault:\r\nprintk("UNKNOWN\n");\r\n}\r\nscsi_print_result(cmd);\r\nscsi_print_command(cmd);\r\nif (status_byte(cmd->result) & CHECK_CONDITION)\r\nscsi_print_sense("", cmd);\r\nif (level > 3)\r\nscmd_printk(KERN_INFO, cmd,\r\n"scsi host busy %d failed %d\n",\r\ncmd->device->host->host_busy,\r\ncmd->device->host->host_failed);\r\n}\r\n}\r\n}\r\nvoid scsi_cmd_get_serial(struct Scsi_Host *host, struct scsi_cmnd *cmd)\r\n{\r\ncmd->serial_number = host->cmd_serial_number++;\r\nif (cmd->serial_number == 0)\r\ncmd->serial_number = host->cmd_serial_number++;\r\n}\r\nint scsi_dispatch_cmd(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nunsigned long timeout;\r\nint rtn = 0;\r\natomic_inc(&cmd->device->iorequest_cnt);\r\nif (unlikely(cmd->device->sdev_state == SDEV_DEL)) {\r\ncmd->result = DID_NO_CONNECT << 16;\r\nscsi_done(cmd);\r\ngoto out;\r\n}\r\nif (unlikely(scsi_device_blocked(cmd->device))) {\r\nscsi_queue_insert(cmd, SCSI_MLQUEUE_DEVICE_BUSY);\r\nSCSI_LOG_MLQUEUE(3, printk("queuecommand : device blocked \n"));\r\ngoto out;\r\n}\r\nif (cmd->device->scsi_level <= SCSI_2 &&\r\ncmd->device->scsi_level != SCSI_UNKNOWN) {\r\ncmd->cmnd[1] = (cmd->cmnd[1] & 0x1f) |\r\n(cmd->device->lun << 5 & 0xe0);\r\n}\r\ntimeout = host->last_reset + MIN_RESET_DELAY;\r\nif (host->resetting && time_before(jiffies, timeout)) {\r\nint ticks_remaining = timeout - jiffies;\r\nwhile (--ticks_remaining >= 0)\r\nmdelay(1 + 999 / HZ);\r\nhost->resetting = 0;\r\n}\r\nscsi_log_send(cmd);\r\nif (cmd->cmd_len > cmd->device->host->max_cmd_len) {\r\nSCSI_LOG_MLQUEUE(3,\r\nprintk("queuecommand : command too long. "\r\n"cdb_size=%d host->max_cmd_len=%d\n",\r\ncmd->cmd_len, cmd->device->host->max_cmd_len));\r\ncmd->result = (DID_ABORT << 16);\r\nscsi_done(cmd);\r\ngoto out;\r\n}\r\nif (unlikely(host->shost_state == SHOST_DEL)) {\r\ncmd->result = (DID_NO_CONNECT << 16);\r\nscsi_done(cmd);\r\n} else {\r\ntrace_scsi_dispatch_cmd_start(cmd);\r\ncmd->scsi_done = scsi_done;\r\nrtn = host->hostt->queuecommand(host, cmd);\r\n}\r\nif (rtn) {\r\ntrace_scsi_dispatch_cmd_error(cmd, rtn);\r\nif (rtn != SCSI_MLQUEUE_DEVICE_BUSY &&\r\nrtn != SCSI_MLQUEUE_TARGET_BUSY)\r\nrtn = SCSI_MLQUEUE_HOST_BUSY;\r\nscsi_queue_insert(cmd, rtn);\r\nSCSI_LOG_MLQUEUE(3,\r\nprintk("queuecommand : request rejected\n"));\r\n}\r\nout:\r\nSCSI_LOG_MLQUEUE(3, printk("leaving scsi_dispatch_cmnd()\n"));\r\nreturn rtn;\r\n}\r\nstatic void scsi_done(struct scsi_cmnd *cmd)\r\n{\r\ntrace_scsi_dispatch_cmd_done(cmd);\r\nblk_complete_request(cmd->request);\r\n}\r\nstatic struct scsi_driver *scsi_cmd_to_driver(struct scsi_cmnd *cmd)\r\n{\r\nreturn *(struct scsi_driver **)cmd->request->rq_disk->private_data;\r\n}\r\nvoid scsi_finish_command(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct scsi_target *starget = scsi_target(sdev);\r\nstruct Scsi_Host *shost = sdev->host;\r\nstruct scsi_driver *drv;\r\nunsigned int good_bytes;\r\nscsi_device_unbusy(sdev);\r\nshost->host_blocked = 0;\r\nstarget->target_blocked = 0;\r\nsdev->device_blocked = 0;\r\nif (SCSI_SENSE_VALID(cmd))\r\ncmd->result |= (DRIVER_SENSE << 24);\r\nSCSI_LOG_MLCOMPLETE(4, sdev_printk(KERN_INFO, sdev,\r\n"Notifying upper driver of completion "\r\n"(result %x)\n", cmd->result));\r\ngood_bytes = scsi_bufflen(cmd);\r\nif (cmd->request->cmd_type != REQ_TYPE_BLOCK_PC) {\r\nint old_good_bytes = good_bytes;\r\ndrv = scsi_cmd_to_driver(cmd);\r\nif (drv->done)\r\ngood_bytes = drv->done(cmd);\r\nif (good_bytes == old_good_bytes)\r\ngood_bytes -= scsi_get_resid(cmd);\r\n}\r\nscsi_io_completion(cmd, good_bytes);\r\n}\r\nvoid scsi_adjust_queue_depth(struct scsi_device *sdev, int tagged, int tags)\r\n{\r\nunsigned long flags;\r\nif (tags <= 0)\r\nreturn;\r\nspin_lock_irqsave(sdev->request_queue->queue_lock, flags);\r\nif (!sdev->host->bqt) {\r\nif (blk_queue_tagged(sdev->request_queue) &&\r\nblk_queue_resize_tags(sdev->request_queue, tags) != 0)\r\ngoto out;\r\n}\r\nsdev->queue_depth = tags;\r\nswitch (tagged) {\r\ncase MSG_ORDERED_TAG:\r\nsdev->ordered_tags = 1;\r\nsdev->simple_tags = 1;\r\nbreak;\r\ncase MSG_SIMPLE_TAG:\r\nsdev->ordered_tags = 0;\r\nsdev->simple_tags = 1;\r\nbreak;\r\ndefault:\r\nsdev_printk(KERN_WARNING, sdev,\r\n"scsi_adjust_queue_depth, bad queue type, "\r\n"disabled\n");\r\ncase 0:\r\nsdev->ordered_tags = sdev->simple_tags = 0;\r\nsdev->queue_depth = tags;\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);\r\n}\r\nint scsi_track_queue_full(struct scsi_device *sdev, int depth)\r\n{\r\nif ((jiffies >> 4) == (sdev->last_queue_full_time >> 4))\r\nreturn 0;\r\nsdev->last_queue_full_time = jiffies;\r\nif (sdev->last_queue_full_depth != depth) {\r\nsdev->last_queue_full_count = 1;\r\nsdev->last_queue_full_depth = depth;\r\n} else {\r\nsdev->last_queue_full_count++;\r\n}\r\nif (sdev->last_queue_full_count <= 10)\r\nreturn 0;\r\nif (sdev->last_queue_full_depth < 8) {\r\nscsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);\r\nreturn -1;\r\n}\r\nif (sdev->ordered_tags)\r\nscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, depth);\r\nelse\r\nscsi_adjust_queue_depth(sdev, MSG_SIMPLE_TAG, depth);\r\nreturn depth;\r\n}\r\nstatic int scsi_vpd_inquiry(struct scsi_device *sdev, unsigned char *buffer,\r\nu8 page, unsigned len)\r\n{\r\nint result;\r\nunsigned char cmd[16];\r\ncmd[0] = INQUIRY;\r\ncmd[1] = 1;\r\ncmd[2] = page;\r\ncmd[3] = len >> 8;\r\ncmd[4] = len & 0xff;\r\ncmd[5] = 0;\r\nresult = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buffer,\r\nlen, NULL, 30 * HZ, 3, NULL);\r\nif (result)\r\nreturn result;\r\nif (buffer[1] != page)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint scsi_get_vpd_page(struct scsi_device *sdev, u8 page, unsigned char *buf,\r\nint buf_len)\r\n{\r\nint i, result;\r\nresult = scsi_vpd_inquiry(sdev, buf, 0, buf_len);\r\nif (result)\r\ngoto fail;\r\nif (page == 0)\r\nreturn 0;\r\nfor (i = 0; i < min((int)buf[3], buf_len - 4); i++)\r\nif (buf[i + 4] == page)\r\ngoto found;\r\nif (i < buf[3] && i >= buf_len - 4)\r\ngoto found;\r\ngoto fail;\r\nfound:\r\nresult = scsi_vpd_inquiry(sdev, buf, page, buf_len);\r\nif (result)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nint scsi_device_get(struct scsi_device *sdev)\r\n{\r\nif (sdev->sdev_state == SDEV_DEL)\r\nreturn -ENXIO;\r\nif (!get_device(&sdev->sdev_gendev))\r\nreturn -ENXIO;\r\ntry_module_get(sdev->host->hostt->module);\r\nreturn 0;\r\n}\r\nvoid scsi_device_put(struct scsi_device *sdev)\r\n{\r\n#ifdef CONFIG_MODULE_UNLOAD\r\nstruct module *module = sdev->host->hostt->module;\r\nif (module && module_refcount(module) != 0)\r\nmodule_put(module);\r\n#endif\r\nput_device(&sdev->sdev_gendev);\r\n}\r\nstruct scsi_device *__scsi_iterate_devices(struct Scsi_Host *shost,\r\nstruct scsi_device *prev)\r\n{\r\nstruct list_head *list = (prev ? &prev->siblings : &shost->__devices);\r\nstruct scsi_device *next = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nwhile (list->next != &shost->__devices) {\r\nnext = list_entry(list->next, struct scsi_device, siblings);\r\nif (!scsi_device_get(next))\r\nbreak;\r\nnext = NULL;\r\nlist = list->next;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (prev)\r\nscsi_device_put(prev);\r\nreturn next;\r\n}\r\nvoid starget_for_each_device(struct scsi_target *starget, void *data,\r\nvoid (*fn)(struct scsi_device *, void *))\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, shost) {\r\nif ((sdev->channel == starget->channel) &&\r\n(sdev->id == starget->id))\r\nfn(sdev, data);\r\n}\r\n}\r\nvoid __starget_for_each_device(struct scsi_target *starget, void *data,\r\nvoid (*fn)(struct scsi_device *, void *))\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct scsi_device *sdev;\r\n__shost_for_each_device(sdev, shost) {\r\nif ((sdev->channel == starget->channel) &&\r\n(sdev->id == starget->id))\r\nfn(sdev, data);\r\n}\r\n}\r\nstruct scsi_device *__scsi_device_lookup_by_target(struct scsi_target *starget,\r\nuint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nlist_for_each_entry(sdev, &starget->devices, same_target_siblings) {\r\nif (sdev->sdev_state == SDEV_DEL)\r\ncontinue;\r\nif (sdev->lun ==lun)\r\nreturn sdev;\r\n}\r\nreturn NULL;\r\n}\r\nstruct scsi_device *scsi_device_lookup_by_target(struct scsi_target *starget,\r\nuint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nsdev = __scsi_device_lookup_by_target(starget, lun);\r\nif (sdev && scsi_device_get(sdev))\r\nsdev = NULL;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn sdev;\r\n}\r\nstruct scsi_device *__scsi_device_lookup(struct Scsi_Host *shost,\r\nuint channel, uint id, uint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nlist_for_each_entry(sdev, &shost->__devices, siblings) {\r\nif (sdev->channel == channel && sdev->id == id &&\r\nsdev->lun ==lun)\r\nreturn sdev;\r\n}\r\nreturn NULL;\r\n}\r\nstruct scsi_device *scsi_device_lookup(struct Scsi_Host *shost,\r\nuint channel, uint id, uint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nsdev = __scsi_device_lookup(shost, channel, id, lun);\r\nif (sdev && scsi_device_get(sdev))\r\nsdev = NULL;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn sdev;\r\n}\r\nstatic int __init init_scsi(void)\r\n{\r\nint error;\r\nerror = scsi_init_queue();\r\nif (error)\r\nreturn error;\r\nerror = scsi_init_procfs();\r\nif (error)\r\ngoto cleanup_queue;\r\nerror = scsi_init_devinfo();\r\nif (error)\r\ngoto cleanup_procfs;\r\nerror = scsi_init_hosts();\r\nif (error)\r\ngoto cleanup_devlist;\r\nerror = scsi_init_sysctl();\r\nif (error)\r\ngoto cleanup_hosts;\r\nerror = scsi_sysfs_register();\r\nif (error)\r\ngoto cleanup_sysctl;\r\nscsi_netlink_init();\r\nprintk(KERN_NOTICE "SCSI subsystem initialized\n");\r\nreturn 0;\r\ncleanup_sysctl:\r\nscsi_exit_sysctl();\r\ncleanup_hosts:\r\nscsi_exit_hosts();\r\ncleanup_devlist:\r\nscsi_exit_devinfo();\r\ncleanup_procfs:\r\nscsi_exit_procfs();\r\ncleanup_queue:\r\nscsi_exit_queue();\r\nprintk(KERN_ERR "SCSI subsystem failed to initialize, error = %d\n",\r\n-error);\r\nreturn error;\r\n}\r\nstatic void __exit exit_scsi(void)\r\n{\r\nscsi_netlink_exit();\r\nscsi_sysfs_unregister();\r\nscsi_exit_sysctl();\r\nscsi_exit_hosts();\r\nscsi_exit_devinfo();\r\nscsi_exit_procfs();\r\nscsi_exit_queue();\r\n}
