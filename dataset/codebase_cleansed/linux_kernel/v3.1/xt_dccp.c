static inline bool\r\ndccp_find_option(u_int8_t option,\r\nconst struct sk_buff *skb,\r\nunsigned int protoff,\r\nconst struct dccp_hdr *dh,\r\nbool *hotdrop)\r\n{\r\nconst unsigned char *op;\r\nunsigned int optoff = __dccp_hdr_len(dh);\r\nunsigned int optlen = dh->dccph_doff*4 - __dccp_hdr_len(dh);\r\nunsigned int i;\r\nif (dh->dccph_doff * 4 < __dccp_hdr_len(dh))\r\ngoto invalid;\r\nif (!optlen)\r\nreturn false;\r\nspin_lock_bh(&dccp_buflock);\r\nop = skb_header_pointer(skb, protoff + optoff, optlen, dccp_optbuf);\r\nif (op == NULL) {\r\ngoto partial;\r\n}\r\nfor (i = 0; i < optlen; ) {\r\nif (op[i] == option) {\r\nspin_unlock_bh(&dccp_buflock);\r\nreturn true;\r\n}\r\nif (op[i] < 2)\r\ni++;\r\nelse\r\ni += op[i+1]?:1;\r\n}\r\nspin_unlock_bh(&dccp_buflock);\r\nreturn false;\r\npartial:\r\nspin_unlock_bh(&dccp_buflock);\r\ninvalid:\r\n*hotdrop = true;\r\nreturn false;\r\n}\r\nstatic inline bool\r\nmatch_types(const struct dccp_hdr *dh, u_int16_t typemask)\r\n{\r\nreturn typemask & (1 << dh->dccph_type);\r\n}\r\nstatic inline bool\r\nmatch_option(u_int8_t option, const struct sk_buff *skb, unsigned int protoff,\r\nconst struct dccp_hdr *dh, bool *hotdrop)\r\n{\r\nreturn dccp_find_option(option, skb, protoff, dh, hotdrop);\r\n}\r\nstatic bool\r\ndccp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_dccp_info *info = par->matchinfo;\r\nconst struct dccp_hdr *dh;\r\nstruct dccp_hdr _dh;\r\nif (par->fragoff != 0)\r\nreturn false;\r\ndh = skb_header_pointer(skb, par->thoff, sizeof(_dh), &_dh);\r\nif (dh == NULL) {\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nreturn DCCHECK(ntohs(dh->dccph_sport) >= info->spts[0]\r\n&& ntohs(dh->dccph_sport) <= info->spts[1],\r\nXT_DCCP_SRC_PORTS, info->flags, info->invflags)\r\n&& DCCHECK(ntohs(dh->dccph_dport) >= info->dpts[0]\r\n&& ntohs(dh->dccph_dport) <= info->dpts[1],\r\nXT_DCCP_DEST_PORTS, info->flags, info->invflags)\r\n&& DCCHECK(match_types(dh, info->typemask),\r\nXT_DCCP_TYPE, info->flags, info->invflags)\r\n&& DCCHECK(match_option(info->option, skb, par->thoff, dh,\r\n&par->hotdrop),\r\nXT_DCCP_OPTION, info->flags, info->invflags);\r\n}\r\nstatic int dccp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_dccp_info *info = par->matchinfo;\r\nif (info->flags & ~XT_DCCP_VALID_FLAGS)\r\nreturn -EINVAL;\r\nif (info->invflags & ~XT_DCCP_VALID_FLAGS)\r\nreturn -EINVAL;\r\nif (info->invflags & ~info->flags)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init dccp_mt_init(void)\r\n{\r\nint ret;\r\ndccp_optbuf = kmalloc(256 * 4, GFP_KERNEL);\r\nif (!dccp_optbuf)\r\nreturn -ENOMEM;\r\nret = xt_register_matches(dccp_mt_reg, ARRAY_SIZE(dccp_mt_reg));\r\nif (ret)\r\ngoto out_kfree;\r\nreturn ret;\r\nout_kfree:\r\nkfree(dccp_optbuf);\r\nreturn ret;\r\n}\r\nstatic void __exit dccp_mt_exit(void)\r\n{\r\nxt_unregister_matches(dccp_mt_reg, ARRAY_SIZE(dccp_mt_reg));\r\nkfree(dccp_optbuf);\r\n}
