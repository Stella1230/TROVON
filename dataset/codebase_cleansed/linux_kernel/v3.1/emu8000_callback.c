void\r\nsnd_emu8000_ops_setup(struct snd_emu8000 *hw)\r\n{\r\nhw->emu->ops = emu8000_ops;\r\n}\r\nstatic void\r\nrelease_voice(struct snd_emux_voice *vp)\r\n{\r\nint dcysusv;\r\nstruct snd_emu8000 *hw;\r\nhw = vp->hw;\r\ndcysusv = 0x8000 | (unsigned char)vp->reg.parm.modrelease;\r\nEMU8000_DCYSUS_WRITE(hw, vp->ch, dcysusv);\r\ndcysusv = 0x8000 | (unsigned char)vp->reg.parm.volrelease;\r\nEMU8000_DCYSUSV_WRITE(hw, vp->ch, dcysusv);\r\n}\r\nstatic void\r\nterminate_voice(struct snd_emux_voice *vp)\r\n{\r\nstruct snd_emu8000 *hw;\r\nhw = vp->hw;\r\nEMU8000_DCYSUSV_WRITE(hw, vp->ch, 0x807F);\r\n}\r\nstatic void\r\nupdate_voice(struct snd_emux_voice *vp, int update)\r\n{\r\nstruct snd_emu8000 *hw;\r\nhw = vp->hw;\r\nif (update & SNDRV_EMUX_UPDATE_VOLUME)\r\nset_volume(hw, vp);\r\nif (update & SNDRV_EMUX_UPDATE_PITCH)\r\nset_pitch(hw, vp);\r\nif ((update & SNDRV_EMUX_UPDATE_PAN) &&\r\nvp->port->ctrls[EMUX_MD_REALTIME_PAN])\r\nset_pan(hw, vp);\r\nif (update & SNDRV_EMUX_UPDATE_FMMOD)\r\nset_fmmod(hw, vp);\r\nif (update & SNDRV_EMUX_UPDATE_TREMFREQ)\r\nset_tremfreq(hw, vp);\r\nif (update & SNDRV_EMUX_UPDATE_FM2FRQ2)\r\nset_fm2frq2(hw, vp);\r\nif (update & SNDRV_EMUX_UPDATE_Q)\r\nset_filterQ(hw, vp);\r\n}\r\nstatic struct snd_emux_voice *\r\nget_voice(struct snd_emux *emu, struct snd_emux_port *port)\r\n{\r\nint i;\r\nstruct snd_emux_voice *vp;\r\nstruct snd_emu8000 *hw;\r\nenum {\r\nOFF=0, RELEASED, PLAYING, END\r\n};\r\nstruct best {\r\nunsigned int time;\r\nint voice;\r\n} best[END];\r\nstruct best *bp;\r\nhw = emu->hw;\r\nfor (i = 0; i < END; i++) {\r\nbest[i].time = (unsigned int)(-1); ;\r\nbest[i].voice = -1;\r\n}\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nint state, val;\r\nvp = &emu->voices[i];\r\nstate = vp->state;\r\nif (state == SNDRV_EMUX_ST_OFF)\r\nbp = best + OFF;\r\nelse if (state == SNDRV_EMUX_ST_RELEASED ||\r\nstate == SNDRV_EMUX_ST_PENDING) {\r\nbp = best + RELEASED;\r\nval = (EMU8000_CVCF_READ(hw, vp->ch) >> 16) & 0xffff;\r\nif (! val)\r\nbp = best + OFF;\r\n}\r\nelse if (state & SNDRV_EMUX_ST_ON)\r\nbp = best + PLAYING;\r\nelse\r\ncontinue;\r\nif (state != SNDRV_EMUX_ST_OFF &&\r\n(vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_SINGLESHOT)) {\r\nval = EMU8000_CCCA_READ(hw, vp->ch) & 0xffffff;\r\nif (val >= vp->reg.loopstart)\r\nbp = best + OFF;\r\n}\r\nif (vp->time < bp->time) {\r\nbp->time = vp->time;\r\nbp->voice = i;\r\n}\r\n}\r\nfor (i = 0; i < END; i++) {\r\nif (best[i].voice >= 0) {\r\nvp = &emu->voices[best[i].voice];\r\nvp->ch = best[i].voice;\r\nreturn vp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nstart_voice(struct snd_emux_voice *vp)\r\n{\r\nunsigned int temp;\r\nint ch;\r\nint addr;\r\nstruct snd_midi_channel *chan;\r\nstruct snd_emu8000 *hw;\r\nhw = vp->hw;\r\nch = vp->ch;\r\nchan = vp->chan;\r\nEMU8000_DCYSUSV_WRITE(hw, ch, 0x0080);\r\nEMU8000_VTFT_WRITE(hw, ch, 0x0000FFFF);\r\nEMU8000_CVCF_WRITE(hw, ch, 0x0000FFFF);\r\nEMU8000_PTRX_WRITE(hw, ch, 0);\r\nEMU8000_CPF_WRITE(hw, ch, 0);\r\nset_pitch(hw, vp);\r\nEMU8000_ENVVAL_WRITE(hw, ch, vp->reg.parm.moddelay);\r\nEMU8000_ATKHLD_WRITE(hw, ch, vp->reg.parm.modatkhld);\r\nEMU8000_DCYSUS_WRITE(hw, ch, vp->reg.parm.moddcysus);\r\nEMU8000_ENVVOL_WRITE(hw, ch, vp->reg.parm.voldelay);\r\nEMU8000_ATKHLDV_WRITE(hw, ch, vp->reg.parm.volatkhld);\r\nset_volume(hw, vp);\r\nEMU8000_PEFE_WRITE(hw, ch, vp->reg.parm.pefe);\r\nEMU8000_LFO1VAL_WRITE(hw, ch, vp->reg.parm.lfo1delay);\r\nEMU8000_LFO2VAL_WRITE(hw, ch, vp->reg.parm.lfo2delay);\r\nset_fmmod(hw, vp);\r\nset_tremfreq(hw, vp);\r\nset_fm2frq2(hw, vp);\r\nset_pan(hw, vp);\r\naddr = vp->reg.loopend - 1;\r\ntemp = vp->reg.parm.chorus;\r\ntemp += (int)chan->control[MIDI_CTL_E3_CHORUS_DEPTH] * 9 / 10;\r\nLIMITMAX(temp, 255);\r\ntemp = (temp <<24) | (unsigned int)addr;\r\nEMU8000_CSL_WRITE(hw, ch, temp);\r\naddr = vp->reg.start - 1;\r\ntemp = vp->reg.parm.filterQ;\r\ntemp = (temp<<28) | (unsigned int)addr;\r\nEMU8000_CCCA_WRITE(hw, ch, temp);\r\nEMU8000_00A0_WRITE(hw, ch, 0);\r\nEMU8000_0080_WRITE(hw, ch, 0);\r\ntemp = vp->vtarget << 16;\r\nEMU8000_VTFT_WRITE(hw, ch, temp | vp->ftarget);\r\nEMU8000_CVCF_WRITE(hw, ch, temp | 0xff00);\r\nreturn 0;\r\n}\r\nstatic void\r\ntrigger_voice(struct snd_emux_voice *vp)\r\n{\r\nint ch = vp->ch;\r\nunsigned int temp;\r\nstruct snd_emu8000 *hw;\r\nhw = vp->hw;\r\ntemp = vp->reg.parm.reverb;\r\ntemp += (int)vp->chan->control[MIDI_CTL_E1_REVERB_DEPTH] * 9 / 10;\r\nLIMITMAX(temp, 255);\r\ntemp = (temp << 8) | (vp->ptarget << 16) | vp->aaux;\r\nEMU8000_PTRX_WRITE(hw, ch, temp);\r\nEMU8000_CPF_WRITE(hw, ch, vp->ptarget << 16);\r\nEMU8000_DCYSUSV_WRITE(hw, ch, vp->reg.parm.voldcysus);\r\n}\r\nstatic void\r\nreset_voice(struct snd_emux *emu, int ch)\r\n{\r\nstruct snd_emu8000 *hw;\r\nhw = emu->hw;\r\nEMU8000_DCYSUSV_WRITE(hw, ch, 0x807F);\r\nsnd_emu8000_tweak_voice(hw, ch);\r\n}\r\nstatic void\r\nset_pitch(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\r\n{\r\nEMU8000_IP_WRITE(hw, vp->ch, vp->apitch);\r\n}\r\nstatic void\r\nset_volume(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\r\n{\r\nint ifatn;\r\nifatn = (unsigned char)vp->acutoff;\r\nifatn = (ifatn << 8);\r\nifatn |= (unsigned char)vp->avol;\r\nEMU8000_IFATN_WRITE(hw, vp->ch, ifatn);\r\n}\r\nstatic void\r\nset_pan(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\r\n{\r\nunsigned int temp;\r\ntemp = ((unsigned int)vp->apan<<24) | ((unsigned int)vp->reg.loopstart - 1);\r\nEMU8000_PSST_WRITE(hw, vp->ch, temp);\r\n}\r\nstatic void\r\nset_fmmod(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\r\n{\r\nunsigned short fmmod;\r\nshort pitch;\r\nunsigned char cutoff;\r\nint modulation;\r\npitch = (char)(vp->reg.parm.fmmod>>8);\r\ncutoff = (vp->reg.parm.fmmod & 0xff);\r\nmodulation = vp->chan->gm_modulation + vp->chan->midi_pressure;\r\npitch += (MOD_SENSE * modulation) / 1200;\r\nLIMITVALUE(pitch, -128, 127);\r\nfmmod = ((unsigned char)pitch<<8) | cutoff;\r\nEMU8000_FMMOD_WRITE(hw, vp->ch, fmmod);\r\n}\r\nstatic void\r\nset_tremfreq(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\r\n{\r\nEMU8000_TREMFRQ_WRITE(hw, vp->ch, vp->reg.parm.tremfrq);\r\n}\r\nstatic void\r\nset_fm2frq2(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\r\n{\r\nunsigned short fm2frq2;\r\nshort pitch;\r\nunsigned char freq;\r\nint modulation;\r\npitch = (char)(vp->reg.parm.fm2frq2>>8);\r\nfreq = vp->reg.parm.fm2frq2 & 0xff;\r\nmodulation = vp->chan->gm_modulation + vp->chan->midi_pressure;\r\npitch += (MOD_SENSE * modulation) / 1200;\r\nLIMITVALUE(pitch, -128, 127);\r\nfm2frq2 = ((unsigned char)pitch<<8) | freq;\r\nEMU8000_FM2FRQ2_WRITE(hw, vp->ch, fm2frq2);\r\n}\r\nstatic void\r\nset_filterQ(struct snd_emu8000 *hw, struct snd_emux_voice *vp)\r\n{\r\nunsigned int addr;\r\naddr = EMU8000_CCCA_READ(hw, vp->ch) & 0xffffff;\r\naddr |= (vp->reg.parm.filterQ << 28);\r\nEMU8000_CCCA_WRITE(hw, vp->ch, addr);\r\n}\r\nstatic void\r\nsnd_emu8000_tweak_voice(struct snd_emu8000 *emu, int i)\r\n{\r\nEMU8000_ENVVOL_WRITE(emu, i, 0x8000);\r\nEMU8000_ENVVAL_WRITE(emu, i, 0x8000);\r\nEMU8000_DCYSUS_WRITE(emu, i, 0x7F7F);\r\nEMU8000_ATKHLDV_WRITE(emu, i, 0x7F7F);\r\nEMU8000_ATKHLD_WRITE(emu, i, 0x7F7F);\r\nEMU8000_PEFE_WRITE(emu, i, 0);\r\nEMU8000_LFO1VAL_WRITE(emu, i, 0x8000);\r\nEMU8000_LFO2VAL_WRITE(emu, i, 0x8000);\r\nEMU8000_IP_WRITE(emu, i, 0xE000);\r\nEMU8000_IFATN_WRITE(emu, i, 0xFF00);\r\nEMU8000_FMMOD_WRITE(emu, i, 0);\r\nEMU8000_TREMFRQ_WRITE(emu, i, 0);\r\nEMU8000_FM2FRQ2_WRITE(emu, i, 0);\r\n}\r\nstatic void\r\nsysex(struct snd_emux *emu, char *buf, int len, int parsed, struct snd_midi_channel_set *chset)\r\n{\r\nstruct snd_emu8000 *hw;\r\nhw = emu->hw;\r\nswitch (parsed) {\r\ncase SNDRV_MIDI_SYSEX_GS_CHORUS_MODE:\r\nhw->chorus_mode = chset->gs_chorus_mode;\r\nsnd_emu8000_update_chorus_mode(hw);\r\nbreak;\r\ncase SNDRV_MIDI_SYSEX_GS_REVERB_MODE:\r\nhw->reverb_mode = chset->gs_reverb_mode;\r\nsnd_emu8000_update_reverb_mode(hw);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\noss_ioctl(struct snd_emux *emu, int cmd, int p1, int p2)\r\n{\r\nstruct snd_emu8000 *hw;\r\nhw = emu->hw;\r\nswitch (cmd) {\r\ncase _EMUX_OSS_REVERB_MODE:\r\nhw->reverb_mode = p1;\r\nsnd_emu8000_update_reverb_mode(hw);\r\nbreak;\r\ncase _EMUX_OSS_CHORUS_MODE:\r\nhw->chorus_mode = p1;\r\nsnd_emu8000_update_chorus_mode(hw);\r\nbreak;\r\ncase _EMUX_OSS_INITIALIZE_CHIP:\r\nbreak;\r\ncase _EMUX_OSS_EQUALIZER:\r\nhw->bass_level = p1;\r\nhw->treble_level = p2;\r\nsnd_emu8000_update_equalizer(hw);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nload_fx(struct snd_emux *emu, int type, int mode, const void __user *buf, long len)\r\n{\r\nstruct snd_emu8000 *hw;\r\nhw = emu->hw;\r\nbuf += 16;\r\nlen -= 16;\r\nswitch (type) {\r\ncase SNDRV_EMU8000_LOAD_CHORUS_FX:\r\nreturn snd_emu8000_load_chorus_fx(hw, mode, buf, len);\r\ncase SNDRV_EMU8000_LOAD_REVERB_FX:\r\nreturn snd_emu8000_load_reverb_fx(hw, mode, buf, len);\r\n}\r\nreturn -EINVAL;\r\n}
