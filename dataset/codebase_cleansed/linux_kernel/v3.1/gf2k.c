static int gf2k_read_packet(struct gameport *gameport, int length, char *data)\r\n{\r\nunsigned char u, v;\r\nint i;\r\nunsigned int t, p;\r\nunsigned long flags;\r\nt = gameport_time(gameport, GF2K_START);\r\np = gameport_time(gameport, GF2K_STROBE);\r\ni = 0;\r\nlocal_irq_save(flags);\r\ngameport_trigger(gameport);\r\nv = gameport_read(gameport);\r\nwhile (t > 0 && i < length) {\r\nt--; u = v;\r\nv = gameport_read(gameport);\r\nif (v & ~u & 0x10) {\r\ndata[i++] = v >> 5;\r\nt = p;\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nreturn i;\r\n}\r\nstatic void gf2k_trigger_seq(struct gameport *gameport, short *seq)\r\n{\r\nunsigned long flags;\r\nint i, t;\r\nlocal_irq_save(flags);\r\ni = 0;\r\ndo {\r\ngameport_trigger(gameport);\r\nt = gameport_time(gameport, GF2K_TIMEOUT * 1000);\r\nwhile ((gameport_read(gameport) & 1) && t) t--;\r\nudelay(seq[i]);\r\n} while (seq[++i]);\r\ngameport_trigger(gameport);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int gf2k_get_bits(unsigned char *buf, int pos, int num, int shift)\r\n{\r\n__u64 data = 0;\r\nint i;\r\nfor (i = 0; i < num / 3 + 2; i++)\r\ndata |= buf[pos / 3 + i] << (i * 3);\r\ndata >>= pos % 3;\r\ndata &= (1 << num) - 1;\r\ndata <<= shift;\r\nreturn data;\r\n}\r\nstatic void gf2k_read(struct gf2k *gf2k, unsigned char *data)\r\n{\r\nstruct input_dev *dev = gf2k->dev;\r\nint i, t;\r\nfor (i = 0; i < 4 && i < gf2k_axes[gf2k->id]; i++)\r\ninput_report_abs(dev, gf2k_abs[i], GB(i<<3,8,0) | GB(i+46,1,8) | GB(i+50,1,9));\r\nfor (i = 0; i < 2 && i < gf2k_axes[gf2k->id] - 4; i++)\r\ninput_report_abs(dev, gf2k_abs[i], GB(i*9+60,8,0) | GB(i+54,1,9));\r\nt = GB(40,4,0);\r\nfor (i = 0; i < gf2k_hats[gf2k->id]; i++)\r\ninput_report_abs(dev, ABS_HAT0X + i, gf2k_hat_to_axis[t][i]);\r\nt = GB(44,2,0) | GB(32,8,2) | GB(78,2,10);\r\nfor (i = 0; i < gf2k_joys[gf2k->id]; i++)\r\ninput_report_key(dev, gf2k_btn_joy[i], (t >> i) & 1);\r\nfor (i = 0; i < gf2k_pads[gf2k->id]; i++)\r\ninput_report_key(dev, gf2k_btn_pad[i], (t >> i) & 1);\r\ninput_sync(dev);\r\n}\r\nstatic void gf2k_poll(struct gameport *gameport)\r\n{\r\nstruct gf2k *gf2k = gameport_get_drvdata(gameport);\r\nunsigned char data[GF2K_LENGTH];\r\ngf2k->reads++;\r\nif (gf2k_read_packet(gf2k->gameport, gf2k_length[gf2k->id], data) < gf2k_length[gf2k->id])\r\ngf2k->bads++;\r\nelse\r\ngf2k_read(gf2k, data);\r\n}\r\nstatic int gf2k_open(struct input_dev *dev)\r\n{\r\nstruct gf2k *gf2k = input_get_drvdata(dev);\r\ngameport_start_polling(gf2k->gameport);\r\nreturn 0;\r\n}\r\nstatic void gf2k_close(struct input_dev *dev)\r\n{\r\nstruct gf2k *gf2k = input_get_drvdata(dev);\r\ngameport_stop_polling(gf2k->gameport);\r\n}\r\nstatic int gf2k_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nstruct gf2k *gf2k;\r\nstruct input_dev *input_dev;\r\nunsigned char data[GF2K_LENGTH];\r\nint i, err;\r\ngf2k = kzalloc(sizeof(struct gf2k), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!gf2k || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\ngf2k->gameport = gameport;\r\ngf2k->dev = input_dev;\r\ngameport_set_drvdata(gameport, gf2k);\r\nerr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\nif (err)\r\ngoto fail1;\r\ngf2k_trigger_seq(gameport, gf2k_seq_reset);\r\nmsleep(GF2K_TIMEOUT);\r\ngf2k_trigger_seq(gameport, gf2k_seq_digital);\r\nmsleep(GF2K_TIMEOUT);\r\nif (gf2k_read_packet(gameport, GF2K_LENGTH, data) < 12) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\nif (!(gf2k->id = GB(7,2,0) | GB(3,3,2) | GB(0,3,5))) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\n#ifdef RESET_WORKS\r\nif ((gf2k->id != (GB(19,2,0) | GB(15,3,2) | GB(12,3,5))) &&\r\n(gf2k->id != (GB(31,2,0) | GB(27,3,2) | GB(24,3,5)))) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\n#else\r\ngf2k->id = 6;\r\n#endif\r\nif (gf2k->id > GF2K_ID_MAX || !gf2k_axes[gf2k->id]) {\r\nprintk(KERN_WARNING "gf2k.c: Not yet supported joystick on %s. [id: %d type:%s]\n",\r\ngameport->phys, gf2k->id, gf2k->id > GF2K_ID_MAX ? "Unknown" : gf2k_names[gf2k->id]);\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\ngameport_set_poll_handler(gameport, gf2k_poll);\r\ngameport_set_poll_interval(gameport, 20);\r\nsnprintf(gf2k->phys, sizeof(gf2k->phys), "%s/input0", gameport->phys);\r\ngf2k->length = gf2k_lens[gf2k->id];\r\ninput_dev->name = gf2k_names[gf2k->id];\r\ninput_dev->phys = gf2k->phys;\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_GENIUS;\r\ninput_dev->id.product = gf2k->id;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &gameport->dev;\r\ninput_set_drvdata(input_dev, gf2k);\r\ninput_dev->open = gf2k_open;\r\ninput_dev->close = gf2k_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (i = 0; i < gf2k_axes[gf2k->id]; i++)\r\nset_bit(gf2k_abs[i], input_dev->absbit);\r\nfor (i = 0; i < gf2k_hats[gf2k->id]; i++)\r\ninput_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);\r\nfor (i = 0; i < gf2k_joys[gf2k->id]; i++)\r\nset_bit(gf2k_btn_joy[i], input_dev->keybit);\r\nfor (i = 0; i < gf2k_pads[gf2k->id]; i++)\r\nset_bit(gf2k_btn_pad[i], input_dev->keybit);\r\ngf2k_read_packet(gameport, gf2k->length, data);\r\ngf2k_read(gf2k, data);\r\nfor (i = 0; i < gf2k_axes[gf2k->id]; i++) {\r\nint max = i < 2 ?\r\ninput_abs_get_val(input_dev, gf2k_abs[i]) * 2 :\r\ninput_abs_get_val(input_dev, gf2k_abs[0]) +\r\ninput_abs_get_val(input_dev, gf2k_abs[1]);\r\nint flat = i < 2 ? 24 : 0;\r\ninput_set_abs_params(input_dev, gf2k_abs[i],\r\n32, max - 32, 8, flat);\r\n}\r\nerr = input_register_device(gf2k->dev);\r\nif (err)\r\ngoto fail2;\r\nreturn 0;\r\nfail2: gameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\ninput_free_device(input_dev);\r\nkfree(gf2k);\r\nreturn err;\r\n}\r\nstatic void gf2k_disconnect(struct gameport *gameport)\r\n{\r\nstruct gf2k *gf2k = gameport_get_drvdata(gameport);\r\ninput_unregister_device(gf2k->dev);\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nkfree(gf2k);\r\n}\r\nstatic int __init gf2k_init(void)\r\n{\r\nreturn gameport_register_driver(&gf2k_drv);\r\n}\r\nstatic void __exit gf2k_exit(void)\r\n{\r\ngameport_unregister_driver(&gf2k_drv);\r\n}
