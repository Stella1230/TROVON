static void msp430_ir_interrupt(unsigned long data)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) data;\r\nstruct rc_dev *dev = budget_ci->ir.dev;\r\nu32 command = ttpci_budget_debiread(&budget_ci->budget, DEBINOSWAP, DEBIADDR_IR, 2, 1, 0) >> 8;\r\nif (ir_debug)\r\nprintk("budget_ci: received byte 0x%02x\n", command);\r\ncommand = command & 0x7f;\r\nif (command & 0x40) {\r\nbudget_ci->ir.have_command = true;\r\nbudget_ci->ir.ir_key = command & 0x3f;\r\nreturn;\r\n}\r\nif (!budget_ci->ir.have_command)\r\nreturn;\r\nbudget_ci->ir.have_command = false;\r\nif (budget_ci->ir.rc5_device != IR_DEVICE_ANY &&\r\nbudget_ci->ir.rc5_device != (command & 0x1f))\r\nreturn;\r\nif (budget_ci->ir.full_rc5) {\r\nrc_keydown(dev,\r\nbudget_ci->ir.rc5_device <<8 | budget_ci->ir.ir_key,\r\n(command & 0x20) ? 1 : 0);\r\nreturn;\r\n}\r\nrc_keydown(dev, budget_ci->ir.ir_key, (command & 0x20) ? 1 : 0);\r\n}\r\nstatic int msp430_ir_init(struct budget_ci *budget_ci)\r\n{\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nstruct rc_dev *dev;\r\nint error;\r\ndev = rc_allocate_device();\r\nif (!dev) {\r\nprintk(KERN_ERR "budget_ci: IR interface initialisation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(budget_ci->ir.name, sizeof(budget_ci->ir.name),\r\n"Budget-CI dvb ir receiver %s", saa->name);\r\nsnprintf(budget_ci->ir.phys, sizeof(budget_ci->ir.phys),\r\n"pci-%s/ir0", pci_name(saa->pci));\r\ndev->driver_name = MODULE_NAME;\r\ndev->input_name = budget_ci->ir.name;\r\ndev->input_phys = budget_ci->ir.phys;\r\ndev->input_id.bustype = BUS_PCI;\r\ndev->input_id.version = 1;\r\ndev->scanmask = 0xff;\r\nif (saa->pci->subsystem_vendor) {\r\ndev->input_id.vendor = saa->pci->subsystem_vendor;\r\ndev->input_id.product = saa->pci->subsystem_device;\r\n} else {\r\ndev->input_id.vendor = saa->pci->vendor;\r\ndev->input_id.product = saa->pci->device;\r\n}\r\ndev->dev.parent = &saa->pci->dev;\r\nif (rc5_device < 0)\r\nbudget_ci->ir.rc5_device = IR_DEVICE_ANY;\r\nelse\r\nbudget_ci->ir.rc5_device = rc5_device;\r\nswitch (budget_ci->budget.dev->pci->subsystem_device) {\r\ncase 0x100c:\r\ncase 0x100f:\r\ncase 0x1011:\r\ncase 0x1012:\r\ndev->map_name = RC_MAP_HAUPPAUGE;\r\nbudget_ci->ir.full_rc5 = true;\r\nif (rc5_device < 0)\r\nbudget_ci->ir.rc5_device = 0x1f;\r\nbreak;\r\ncase 0x1010:\r\ncase 0x1017:\r\ncase 0x1019:\r\ncase 0x101a:\r\ncase 0x101b:\r\ndev->map_name = RC_MAP_TT_1500;\r\nbreak;\r\ndefault:\r\ndev->map_name = RC_MAP_BUDGET_CI_OLD;\r\nbreak;\r\n}\r\nerror = rc_register_device(dev);\r\nif (error) {\r\nprintk(KERN_ERR "budget_ci: could not init driver for IR device (code %d)\n", error);\r\nrc_free_device(dev);\r\nreturn error;\r\n}\r\nbudget_ci->ir.dev = dev;\r\ntasklet_init(&budget_ci->ir.msp430_irq_tasklet, msp430_ir_interrupt,\r\n(unsigned long) budget_ci);\r\nSAA7146_IER_ENABLE(saa, MASK_06);\r\nsaa7146_setgpio(saa, 3, SAA7146_GPIO_IRQHI);\r\nreturn 0;\r\n}\r\nstatic void msp430_ir_deinit(struct budget_ci *budget_ci)\r\n{\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nSAA7146_IER_DISABLE(saa, MASK_06);\r\nsaa7146_setgpio(saa, 3, SAA7146_GPIO_INPUT);\r\ntasklet_kill(&budget_ci->ir.msp430_irq_tasklet);\r\nrc_unregister_device(budget_ci->ir.dev);\r\n}\r\nstatic int ciintf_read_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) ca->data;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nreturn ttpci_budget_debiread(&budget_ci->budget, DEBICICAM,\r\nDEBIADDR_ATTR | (address & 0xfff), 1, 1, 0);\r\n}\r\nstatic int ciintf_write_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address, u8 value)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) ca->data;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nreturn ttpci_budget_debiwrite(&budget_ci->budget, DEBICICAM,\r\nDEBIADDR_ATTR | (address & 0xfff), 1, value, 1, 0);\r\n}\r\nstatic int ciintf_read_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) ca->data;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nreturn ttpci_budget_debiread(&budget_ci->budget, DEBICICAM,\r\nDEBIADDR_IO | (address & 3), 1, 1, 0);\r\n}\r\nstatic int ciintf_write_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address, u8 value)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) ca->data;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nreturn ttpci_budget_debiwrite(&budget_ci->budget, DEBICICAM,\r\nDEBIADDR_IO | (address & 3), 1, value, 1, 0);\r\n}\r\nstatic int ciintf_slot_reset(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) ca->data;\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nif (budget_ci->ci_irq) {\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);\r\n}\r\nbudget_ci->slot_status = SLOTSTATUS_RESET;\r\nttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 0, 1, 0);\r\nmsleep(1);\r\nttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1,\r\nCICONTROL_RESET, 1, 0);\r\nsaa7146_setgpio(saa, 1, SAA7146_GPIO_OUTHI);\r\nttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTB);\r\nreturn 0;\r\n}\r\nstatic int ciintf_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) ca->data;\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nsaa7146_setgpio(saa, 1, SAA7146_GPIO_OUTHI);\r\nttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTB);\r\nreturn 0;\r\n}\r\nstatic int ciintf_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) ca->data;\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nint tmp;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nsaa7146_setgpio(saa, 1, SAA7146_GPIO_OUTLO);\r\ntmp = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 1, 0);\r\nttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1,\r\ntmp | CICONTROL_ENABLETS, 1, 0);\r\nttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTA);\r\nreturn 0;\r\n}\r\nstatic void ciintf_interrupt(unsigned long data)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) data;\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nunsigned int flags;\r\nif (!budget_ci->budget.ci_present)\r\nreturn;\r\nflags = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 1, 0);\r\nif (flags & CICONTROL_CAMDETECT) {\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQLO);\r\nif (budget_ci->slot_status & SLOTSTATUS_NONE) {\r\nbudget_ci->slot_status = SLOTSTATUS_PRESENT;\r\ndvb_ca_en50221_camchange_irq(&budget_ci->ca, 0,\r\nDVB_CA_EN50221_CAMCHANGE_INSERTED);\r\n} else if (budget_ci->slot_status & SLOTSTATUS_RESET) {\r\nbudget_ci->slot_status = SLOTSTATUS_READY;\r\ndvb_ca_en50221_camready_irq(&budget_ci->ca, 0);\r\n} else if (budget_ci->slot_status & SLOTSTATUS_READY) {\r\ndvb_ca_en50221_frda_irq(&budget_ci->ca, 0);\r\n}\r\n} else {\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);\r\nif (budget_ci->slot_status & SLOTSTATUS_OCCUPIED) {\r\nbudget_ci->slot_status = SLOTSTATUS_NONE;\r\ndvb_ca_en50221_camchange_irq(&budget_ci->ca, 0,\r\nDVB_CA_EN50221_CAMCHANGE_REMOVED);\r\n}\r\n}\r\n}\r\nstatic int ciintf_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) ca->data;\r\nunsigned int flags;\r\nif (!budget_ci->budget.ci_present)\r\nreturn -EINVAL;\r\nflags = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 1, 0);\r\nif (flags & CICONTROL_CAMDETECT) {\r\nif (budget_ci->slot_status & SLOTSTATUS_NONE) {\r\nbudget_ci->slot_status = SLOTSTATUS_PRESENT;\r\n}\r\nif (budget_ci->slot_status & SLOTSTATUS_RESET) {\r\nif (ciintf_read_attribute_mem(ca, slot, 0) == 0x1d) {\r\nbudget_ci->slot_status = SLOTSTATUS_READY;\r\n}\r\n}\r\n} else {\r\nbudget_ci->slot_status = SLOTSTATUS_NONE;\r\n}\r\nif (budget_ci->slot_status != SLOTSTATUS_NONE) {\r\nif (budget_ci->slot_status & SLOTSTATUS_READY) {\r\nreturn DVB_CA_EN50221_POLL_CAM_PRESENT | DVB_CA_EN50221_POLL_CAM_READY;\r\n}\r\nreturn DVB_CA_EN50221_POLL_CAM_PRESENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ciintf_init(struct budget_ci *budget_ci)\r\n{\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nint flags;\r\nint result;\r\nint ci_version;\r\nint ca_flags;\r\nmemset(&budget_ci->ca, 0, sizeof(struct dvb_ca_en50221));\r\nsaa7146_write(saa, MC1, MASK_27 | MASK_11);\r\nci_version = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CIVERSION, 1, 1, 0);\r\nif ((ci_version & 0xa0) != 0xa0) {\r\nresult = -ENODEV;\r\ngoto error;\r\n}\r\nflags = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 1, 0);\r\nbudget_ci->slot_status = SLOTSTATUS_NONE;\r\nif (flags & CICONTROL_CAMDETECT)\r\nbudget_ci->slot_status = SLOTSTATUS_PRESENT;\r\nif (ci_version == 0xa2) {\r\nca_flags = 0;\r\nbudget_ci->ci_irq = 0;\r\n} else {\r\nca_flags = DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE |\r\nDVB_CA_EN50221_FLAG_IRQ_FR |\r\nDVB_CA_EN50221_FLAG_IRQ_DA;\r\nbudget_ci->ci_irq = 1;\r\n}\r\nbudget_ci->ca.owner = THIS_MODULE;\r\nbudget_ci->ca.read_attribute_mem = ciintf_read_attribute_mem;\r\nbudget_ci->ca.write_attribute_mem = ciintf_write_attribute_mem;\r\nbudget_ci->ca.read_cam_control = ciintf_read_cam_control;\r\nbudget_ci->ca.write_cam_control = ciintf_write_cam_control;\r\nbudget_ci->ca.slot_reset = ciintf_slot_reset;\r\nbudget_ci->ca.slot_shutdown = ciintf_slot_shutdown;\r\nbudget_ci->ca.slot_ts_enable = ciintf_slot_ts_enable;\r\nbudget_ci->ca.poll_slot_status = ciintf_poll_slot_status;\r\nbudget_ci->ca.data = budget_ci;\r\nif ((result = dvb_ca_en50221_init(&budget_ci->budget.dvb_adapter,\r\n&budget_ci->ca,\r\nca_flags, 1)) != 0) {\r\nprintk("budget_ci: CI interface detected, but initialisation failed.\n");\r\ngoto error;\r\n}\r\nif (budget_ci->ci_irq) {\r\ntasklet_init(&budget_ci->ciintf_irq_tasklet, ciintf_interrupt, (unsigned long) budget_ci);\r\nif (budget_ci->slot_status != SLOTSTATUS_NONE) {\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQLO);\r\n} else {\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);\r\n}\r\nSAA7146_IER_ENABLE(saa, MASK_03);\r\n}\r\nttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1,\r\nCICONTROL_RESET, 1, 0);\r\nprintk("budget_ci: CI interface initialised\n");\r\nbudget_ci->budget.ci_present = 1;\r\nif (budget_ci->ci_irq) {\r\nflags = DVB_CA_EN50221_CAMCHANGE_REMOVED;\r\nif (budget_ci->slot_status != SLOTSTATUS_NONE)\r\nflags = DVB_CA_EN50221_CAMCHANGE_INSERTED;\r\ndvb_ca_en50221_camchange_irq(&budget_ci->ca, 0, flags);\r\n}\r\nreturn 0;\r\nerror:\r\nsaa7146_write(saa, MC1, MASK_27);\r\nreturn result;\r\n}\r\nstatic void ciintf_deinit(struct budget_ci *budget_ci)\r\n{\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nif (budget_ci->ci_irq) {\r\nSAA7146_IER_DISABLE(saa, MASK_03);\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_INPUT);\r\ntasklet_kill(&budget_ci->ciintf_irq_tasklet);\r\n}\r\nttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 0, 1, 0);\r\nmsleep(1);\r\nttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1,\r\nCICONTROL_RESET, 1, 0);\r\nsaa7146_setgpio(saa, 1, SAA7146_GPIO_INPUT);\r\ndvb_ca_en50221_release(&budget_ci->ca);\r\nsaa7146_write(saa, MC1, MASK_27);\r\n}\r\nstatic void budget_ci_irq(struct saa7146_dev *dev, u32 * isr)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) dev->ext_priv;\r\ndprintk(8, "dev: %p, budget_ci: %p\n", dev, budget_ci);\r\nif (*isr & MASK_06)\r\ntasklet_schedule(&budget_ci->ir.msp430_irq_tasklet);\r\nif (*isr & MASK_10)\r\nttpci_budget_irq10_handler(dev, isr);\r\nif ((*isr & MASK_03) && (budget_ci->budget.ci_present) && (budget_ci->ci_irq))\r\ntasklet_schedule(&budget_ci->ciintf_irq_tasklet);\r\n}\r\nstatic int philips_su1278_tt_set_symbol_rate(struct dvb_frontend *fe, u32 srate, u32 ratio)\r\n{\r\nstv0299_writereg(fe, 0x0e, 0x44);\r\nif (srate >= 10000000) {\r\nstv0299_writereg(fe, 0x13, 0x97);\r\nstv0299_writereg(fe, 0x14, 0x95);\r\nstv0299_writereg(fe, 0x15, 0xc9);\r\nstv0299_writereg(fe, 0x17, 0x8c);\r\nstv0299_writereg(fe, 0x1a, 0xfe);\r\nstv0299_writereg(fe, 0x1c, 0x7f);\r\nstv0299_writereg(fe, 0x2d, 0x09);\r\n} else {\r\nstv0299_writereg(fe, 0x13, 0x99);\r\nstv0299_writereg(fe, 0x14, 0x8d);\r\nstv0299_writereg(fe, 0x15, 0xce);\r\nstv0299_writereg(fe, 0x17, 0x43);\r\nstv0299_writereg(fe, 0x1a, 0x1d);\r\nstv0299_writereg(fe, 0x1c, 0x12);\r\nstv0299_writereg(fe, 0x2d, 0x05);\r\n}\r\nstv0299_writereg(fe, 0x0e, 0x23);\r\nstv0299_writereg(fe, 0x0f, 0x94);\r\nstv0299_writereg(fe, 0x10, 0x39);\r\nstv0299_writereg(fe, 0x15, 0xc9);\r\nstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\r\nstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\r\nstv0299_writereg(fe, 0x21, (ratio) & 0xf0);\r\nreturn 0;\r\n}\r\nstatic int philips_su1278_tt_tuner_set_params(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *params)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) fe->dvb->priv;\r\nu32 div;\r\nu8 buf[4];\r\nstruct i2c_msg msg = {.addr = 0x60,.flags = 0,.buf = buf,.len = sizeof(buf) };\r\nif ((params->frequency < 950000) || (params->frequency > 2150000))\r\nreturn -EINVAL;\r\ndiv = (params->frequency + (500 - 1)) / 500;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = 0x80 | ((div & 0x18000) >> 10) | 2;\r\nbuf[3] = 0x20;\r\nif (params->u.qpsk.symbol_rate < 4000000)\r\nbuf[3] |= 1;\r\nif (params->frequency < 1250000)\r\nbuf[3] |= 0;\r\nelse if (params->frequency < 1550000)\r\nbuf[3] |= 0x40;\r\nelse if (params->frequency < 2050000)\r\nbuf[3] |= 0x80;\r\nelse if (params->frequency < 2150000)\r\nbuf[3] |= 0xC0;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget_ci->budget.i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int philips_tdm1316l_tuner_init(struct dvb_frontend *fe)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) fe->dvb->priv;\r\nstatic u8 td1316_init[] = { 0x0b, 0xf5, 0x85, 0xab };\r\nstatic u8 disable_mc44BC374c[] = { 0x1d, 0x74, 0xa0, 0x68 };\r\nstruct i2c_msg tuner_msg = {.addr = budget_ci->tuner_pll_address,.flags = 0,.buf = td1316_init,.len =\r\nsizeof(td1316_init) };\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1)\r\nreturn -EIO;\r\nmsleep(1);\r\ntuner_msg.addr = 0x65;\r\ntuner_msg.buf = disable_mc44BC374c;\r\ntuner_msg.len = sizeof(disable_mc44BC374c);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\ni2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe, struct dvb_frontend_parameters *params)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) fe->dvb->priv;\r\nu8 tuner_buf[4];\r\nstruct i2c_msg tuner_msg = {.addr = budget_ci->tuner_pll_address,.flags = 0,.buf = tuner_buf,.len = sizeof(tuner_buf) };\r\nint tuner_frequency = 0;\r\nu8 band, cp, filter;\r\ntuner_frequency = params->frequency + 36130000;\r\nif (tuner_frequency < 87000000)\r\nreturn -EINVAL;\r\nelse if (tuner_frequency < 130000000)\r\ncp = 3;\r\nelse if (tuner_frequency < 160000000)\r\ncp = 5;\r\nelse if (tuner_frequency < 200000000)\r\ncp = 6;\r\nelse if (tuner_frequency < 290000000)\r\ncp = 3;\r\nelse if (tuner_frequency < 420000000)\r\ncp = 5;\r\nelse if (tuner_frequency < 480000000)\r\ncp = 6;\r\nelse if (tuner_frequency < 620000000)\r\ncp = 3;\r\nelse if (tuner_frequency < 830000000)\r\ncp = 5;\r\nelse if (tuner_frequency < 895000000)\r\ncp = 7;\r\nelse\r\nreturn -EINVAL;\r\nif (params->frequency < 49000000)\r\nreturn -EINVAL;\r\nelse if (params->frequency < 159000000)\r\nband = 1;\r\nelse if (params->frequency < 444000000)\r\nband = 2;\r\nelse if (params->frequency < 861000000)\r\nband = 4;\r\nelse\r\nreturn -EINVAL;\r\nswitch (params->u.ofdm.bandwidth) {\r\ncase BANDWIDTH_6_MHZ:\r\ntda1004x_writereg(fe, 0x0C, 0x14);\r\nfilter = 0;\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\ntda1004x_writereg(fe, 0x0C, 0x80);\r\nfilter = 0;\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\ntda1004x_writereg(fe, 0x0C, 0x14);\r\nfilter = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntuner_frequency = (((params->frequency / 1000) * 6) + 217280) / 1000;\r\ntuner_buf[0] = tuner_frequency >> 8;\r\ntuner_buf[1] = tuner_frequency & 0xff;\r\ntuner_buf[2] = 0xca;\r\ntuner_buf[3] = (cp << 5) | (filter << 3) | band;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1)\r\nreturn -EIO;\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int philips_tdm1316l_request_firmware(struct dvb_frontend *fe,\r\nconst struct firmware **fw, char *name)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) fe->dvb->priv;\r\nreturn request_firmware(fw, name, &budget_ci->budget.dev->pci->dev);\r\n}\r\nstatic int dvbc_philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe, struct dvb_frontend_parameters *params)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) fe->dvb->priv;\r\nu8 tuner_buf[5];\r\nstruct i2c_msg tuner_msg = {.addr = budget_ci->tuner_pll_address,\r\n.flags = 0,\r\n.buf = tuner_buf,\r\n.len = sizeof(tuner_buf) };\r\nint tuner_frequency = 0;\r\nu8 band, cp, filter;\r\ntuner_frequency = params->frequency + 36125000;\r\nif (tuner_frequency < 87000000)\r\nreturn -EINVAL;\r\nelse if (tuner_frequency < 130000000) {\r\ncp = 3;\r\nband = 1;\r\n} else if (tuner_frequency < 160000000) {\r\ncp = 5;\r\nband = 1;\r\n} else if (tuner_frequency < 200000000) {\r\ncp = 6;\r\nband = 1;\r\n} else if (tuner_frequency < 290000000) {\r\ncp = 3;\r\nband = 2;\r\n} else if (tuner_frequency < 420000000) {\r\ncp = 5;\r\nband = 2;\r\n} else if (tuner_frequency < 480000000) {\r\ncp = 6;\r\nband = 2;\r\n} else if (tuner_frequency < 620000000) {\r\ncp = 3;\r\nband = 4;\r\n} else if (tuner_frequency < 830000000) {\r\ncp = 5;\r\nband = 4;\r\n} else if (tuner_frequency < 895000000) {\r\ncp = 7;\r\nband = 4;\r\n} else\r\nreturn -EINVAL;\r\nfilter = 1;\r\ntuner_frequency = (params->frequency + 36125000 + (62500/2)) / 62500;\r\ntuner_buf[0] = tuner_frequency >> 8;\r\ntuner_buf[1] = tuner_frequency & 0xff;\r\ntuner_buf[2] = 0xc8;\r\ntuner_buf[3] = (cp << 5) | (filter << 3) | band;\r\ntuner_buf[4] = 0x80;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1)\r\nreturn -EIO;\r\nmsleep(50);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1)\r\nreturn -EIO;\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic void frontend_init(struct budget_ci *budget_ci)\r\n{\r\nswitch (budget_ci->budget.dev->pci->subsystem_device) {\r\ncase 0x100c:\r\nbudget_ci->budget.dvb_frontend =\r\ndvb_attach(stv0299_attach, &alps_bsru6_config, &budget_ci->budget.i2c_adap);\r\nif (budget_ci->budget.dvb_frontend) {\r\nbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\r\nbudget_ci->budget.dvb_frontend->tuner_priv = &budget_ci->budget.i2c_adap;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x100f:\r\nbudget_ci->budget.dvb_frontend =\r\ndvb_attach(stv0299_attach, &philips_su1278_tt_config, &budget_ci->budget.i2c_adap);\r\nif (budget_ci->budget.dvb_frontend) {\r\nbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = philips_su1278_tt_tuner_set_params;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1010:\r\nbudget_ci->tuner_pll_address = 0x61;\r\nbudget_ci->budget.dvb_frontend =\r\ndvb_attach(stv0297_attach, &dvbc_philips_tdm1316l_config, &budget_ci->budget.i2c_adap);\r\nif (budget_ci->budget.dvb_frontend) {\r\nbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = dvbc_philips_tdm1316l_tuner_set_params;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1011:\r\nbudget_ci->tuner_pll_address = 0x63;\r\nbudget_ci->budget.dvb_frontend =\r\ndvb_attach(tda10045_attach, &philips_tdm1316l_config, &budget_ci->budget.i2c_adap);\r\nif (budget_ci->budget.dvb_frontend) {\r\nbudget_ci->budget.dvb_frontend->ops.tuner_ops.init = philips_tdm1316l_tuner_init;\r\nbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = philips_tdm1316l_tuner_set_params;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1012:\r\nbudget_ci->tuner_pll_address = 0x60;\r\nbudget_ci->budget.dvb_frontend =\r\ndvb_attach(tda10046_attach, &philips_tdm1316l_config_invert, &budget_ci->budget.i2c_adap);\r\nif (budget_ci->budget.dvb_frontend) {\r\nbudget_ci->budget.dvb_frontend->ops.tuner_ops.init = philips_tdm1316l_tuner_init;\r\nbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = philips_tdm1316l_tuner_set_params;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1017:\r\nbudget_ci->budget.dvb_frontend = dvb_attach(stv0299_attach, &alps_bsbe1_config, &budget_ci->budget.i2c_adap);\r\nif (budget_ci->budget.dvb_frontend) {\r\nbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = alps_bsbe1_tuner_set_params;\r\nbudget_ci->budget.dvb_frontend->tuner_priv = &budget_ci->budget.i2c_adap;\r\nbudget_ci->budget.dvb_frontend->ops.dishnetwork_send_legacy_command = NULL;\r\nif (dvb_attach(lnbp21_attach, budget_ci->budget.dvb_frontend, &budget_ci->budget.i2c_adap, LNBP21_LLC, 0) == NULL) {\r\nprintk("%s: No LNBP21 found!\n", __func__);\r\ndvb_frontend_detach(budget_ci->budget.dvb_frontend);\r\nbudget_ci->budget.dvb_frontend = NULL;\r\n}\r\n}\r\nbreak;\r\ncase 0x101a:\r\nbudget_ci->budget.dvb_frontend = dvb_attach(tda10023_attach, &tda10023_config, &budget_ci->budget.i2c_adap, 0x48);\r\nif (budget_ci->budget.dvb_frontend) {\r\nif (dvb_attach(tda827x_attach, budget_ci->budget.dvb_frontend, 0x61, &budget_ci->budget.i2c_adap, &tda827x_config) == NULL) {\r\nprintk(KERN_ERR "%s: No tda827x found!\n", __func__);\r\ndvb_frontend_detach(budget_ci->budget.dvb_frontend);\r\nbudget_ci->budget.dvb_frontend = NULL;\r\n}\r\n}\r\nbreak;\r\ncase 0x101b:\r\nbudget_ci->budget.dvb_frontend = dvb_attach(stv0288_attach, &stv0288_bsbe1_d01a_config, &budget_ci->budget.i2c_adap);\r\nif (budget_ci->budget.dvb_frontend) {\r\nif (dvb_attach(stb6000_attach, budget_ci->budget.dvb_frontend, 0x63, &budget_ci->budget.i2c_adap)) {\r\nif (!dvb_attach(lnbp21_attach, budget_ci->budget.dvb_frontend, &budget_ci->budget.i2c_adap, 0, 0)) {\r\nprintk(KERN_ERR "%s: No LNBP21 found!\n", __func__);\r\ndvb_frontend_detach(budget_ci->budget.dvb_frontend);\r\nbudget_ci->budget.dvb_frontend = NULL;\r\n}\r\n} else {\r\nprintk(KERN_ERR "%s: No STB6000 found!\n", __func__);\r\ndvb_frontend_detach(budget_ci->budget.dvb_frontend);\r\nbudget_ci->budget.dvb_frontend = NULL;\r\n}\r\n}\r\nbreak;\r\ncase 0x1019:\r\nsaa7146_setgpio(budget_ci->budget.dev, 2, SAA7146_GPIO_OUTLO);\r\nmsleep(50);\r\nsaa7146_setgpio(budget_ci->budget.dev, 2, SAA7146_GPIO_OUTHI);\r\nmsleep(250);\r\nbudget_ci->budget.dvb_frontend = dvb_attach(stb0899_attach, &tt3200_config, &budget_ci->budget.i2c_adap);\r\nif (budget_ci->budget.dvb_frontend) {\r\nif (dvb_attach(stb6100_attach, budget_ci->budget.dvb_frontend, &tt3200_stb6100_config, &budget_ci->budget.i2c_adap)) {\r\nif (!dvb_attach(lnbp21_attach, budget_ci->budget.dvb_frontend, &budget_ci->budget.i2c_adap, 0, 0)) {\r\nprintk("%s: No LNBP21 found!\n", __func__);\r\ndvb_frontend_detach(budget_ci->budget.dvb_frontend);\r\nbudget_ci->budget.dvb_frontend = NULL;\r\n}\r\n} else {\r\ndvb_frontend_detach(budget_ci->budget.dvb_frontend);\r\nbudget_ci->budget.dvb_frontend = NULL;\r\n}\r\n}\r\nbreak;\r\n}\r\nif (budget_ci->budget.dvb_frontend == NULL) {\r\nprintk("budget-ci: A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\n",\r\nbudget_ci->budget.dev->pci->vendor,\r\nbudget_ci->budget.dev->pci->device,\r\nbudget_ci->budget.dev->pci->subsystem_vendor,\r\nbudget_ci->budget.dev->pci->subsystem_device);\r\n} else {\r\nif (dvb_register_frontend\r\n(&budget_ci->budget.dvb_adapter, budget_ci->budget.dvb_frontend)) {\r\nprintk("budget-ci: Frontend registration failed!\n");\r\ndvb_frontend_detach(budget_ci->budget.dvb_frontend);\r\nbudget_ci->budget.dvb_frontend = NULL;\r\n}\r\n}\r\n}\r\nstatic int budget_ci_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\r\n{\r\nstruct budget_ci *budget_ci;\r\nint err;\r\nbudget_ci = kzalloc(sizeof(struct budget_ci), GFP_KERNEL);\r\nif (!budget_ci) {\r\nerr = -ENOMEM;\r\ngoto out1;\r\n}\r\ndprintk(2, "budget_ci: %p\n", budget_ci);\r\ndev->ext_priv = budget_ci;\r\nerr = ttpci_budget_init(&budget_ci->budget, dev, info, THIS_MODULE,\r\nadapter_nr);\r\nif (err)\r\ngoto out2;\r\nerr = msp430_ir_init(budget_ci);\r\nif (err)\r\ngoto out3;\r\nciintf_init(budget_ci);\r\nbudget_ci->budget.dvb_adapter.priv = budget_ci;\r\nfrontend_init(budget_ci);\r\nttpci_budget_init_hooks(&budget_ci->budget);\r\nreturn 0;\r\nout3:\r\nttpci_budget_deinit(&budget_ci->budget);\r\nout2:\r\nkfree(budget_ci);\r\nout1:\r\nreturn err;\r\n}\r\nstatic int budget_ci_detach(struct saa7146_dev *dev)\r\n{\r\nstruct budget_ci *budget_ci = (struct budget_ci *) dev->ext_priv;\r\nstruct saa7146_dev *saa = budget_ci->budget.dev;\r\nint err;\r\nif (budget_ci->budget.ci_present)\r\nciintf_deinit(budget_ci);\r\nmsp430_ir_deinit(budget_ci);\r\nif (budget_ci->budget.dvb_frontend) {\r\ndvb_unregister_frontend(budget_ci->budget.dvb_frontend);\r\ndvb_frontend_detach(budget_ci->budget.dvb_frontend);\r\n}\r\nerr = ttpci_budget_deinit(&budget_ci->budget);\r\nsaa7146_setgpio(saa, 2, SAA7146_GPIO_INPUT);\r\nkfree(budget_ci);\r\nreturn err;\r\n}\r\nstatic int __init budget_ci_init(void)\r\n{\r\nreturn saa7146_register_extension(&budget_extension);\r\n}\r\nstatic void __exit budget_ci_exit(void)\r\n{\r\nsaa7146_unregister_extension(&budget_extension);\r\n}
