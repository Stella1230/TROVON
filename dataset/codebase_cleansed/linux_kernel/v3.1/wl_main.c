int wl_insert( struct net_device *dev )\r\n{\r\nint result = 0;\r\nint hcf_status = HCF_SUCCESS;\r\nint i;\r\nunsigned long flags = 0;\r\nstruct wl_private *lp = wl_priv(dev);\r\nDBG_FUNC( "wl_insert" );\r\nDBG_ENTER( DbgInfo );\r\nmemset( &( lp->hcfCtx ), 0, sizeof( IFB_STRCT ));\r\nspin_lock_init( &( lp->slock ));\r\nlp->is_handling_int = WL_NOT_HANDLING_INT;\r\nlp->firmware_present = WL_FRIMWARE_NOT_PRESENT;\r\nlp->dev = dev;\r\nDBG_PARAM( DbgInfo, "irq_mask", "0x%04x", irq_mask & 0x0FFFF );\r\nDBG_PARAM( DbgInfo, "irq_list", "0x%02x 0x%02x 0x%02x 0x%02x",\r\nirq_list[0] & 0x0FF, irq_list[1] & 0x0FF,\r\nirq_list[2] & 0x0FF, irq_list[3] & 0x0FF );\r\nDBG_PARAM( DbgInfo, PARM_NAME_DESIRED_SSID, "\"%s\"", PARM_DESIRED_SSID );\r\nDBG_PARAM( DbgInfo, PARM_NAME_OWN_SSID, "\"%s\"", PARM_OWN_SSID );\r\nDBG_PARAM( DbgInfo, PARM_NAME_OWN_CHANNEL, "%d", PARM_OWN_CHANNEL);\r\nDBG_PARAM( DbgInfo, PARM_NAME_SYSTEM_SCALE, "%d", PARM_SYSTEM_SCALE );\r\nDBG_PARAM( DbgInfo, PARM_NAME_TX_RATE, "%d", PARM_TX_RATE );\r\nDBG_PARAM( DbgInfo, PARM_NAME_RTS_THRESHOLD, "%d", PARM_RTS_THRESHOLD );\r\nDBG_PARAM( DbgInfo, PARM_NAME_MICROWAVE_ROBUSTNESS, "\"%s\"", PARM_MICROWAVE_ROBUSTNESS );\r\nDBG_PARAM( DbgInfo, PARM_NAME_OWN_NAME, "\"%s\"", PARM_OWN_NAME );\r\nDBG_PARAM( DbgInfo, PARM_NAME_KEY1, "\"%s\"", PARM_KEY1 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_KEY2, "\"%s\"", PARM_KEY2 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_KEY3, "\"%s\"", PARM_KEY3 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_KEY4, "\"%s\"", PARM_KEY4 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_TX_KEY, "%d", PARM_TX_KEY );\r\nDBG_PARAM( DbgInfo, PARM_NAME_MULTICAST_RATE, "%d", PARM_MULTICAST_RATE );\r\nDBG_PARAM( DbgInfo, PARM_NAME_DOWNLOAD_FIRMWARE, "\"%s\"", PARM_DOWNLOAD_FIRMWARE );\r\nDBG_PARAM( DbgInfo, PARM_NAME_AUTH_KEY_MGMT_SUITE, "%d", PARM_AUTH_KEY_MGMT_SUITE );\r\nDBG_PARAM( DbgInfo, PARM_NAME_PM_ENABLED, "%04x", PARM_PM_ENABLED );\r\n#if 1\r\nDBG_PARAM( DbgInfo, PARM_NAME_OWN_DTIM_PERIOD, "%d", PARM_OWN_DTIM_PERIOD );\r\nDBG_PARAM( DbgInfo, PARM_NAME_REJECT_ANY, "\"%s\"", PARM_REJECT_ANY );\r\nDBG_PARAM( DbgInfo, PARM_NAME_EXCLUDE_UNENCRYPTED, "\"%s\"", PARM_EXCLUDE_UNENCRYPTED );\r\nDBG_PARAM( DbgInfo, PARM_NAME_MULTICAST_PM_BUFFERING, "\"%s\"", PARM_MULTICAST_PM_BUFFERING );\r\nDBG_PARAM( DbgInfo, PARM_NAME_INTRA_BSS_RELAY, "\"%s\"", PARM_INTRA_BSS_RELAY );\r\n#ifdef USE_WDS\r\nDBG_PARAM( DbgInfo, PARM_NAME_RTS_THRESHOLD1, "%d", PARM_RTS_THRESHOLD1 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_RTS_THRESHOLD2, "%d", PARM_RTS_THRESHOLD2 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_RTS_THRESHOLD3, "%d", PARM_RTS_THRESHOLD3 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_RTS_THRESHOLD4, "%d", PARM_RTS_THRESHOLD4 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_RTS_THRESHOLD5, "%d", PARM_RTS_THRESHOLD5 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_RTS_THRESHOLD6, "%d", PARM_RTS_THRESHOLD6 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_TX_RATE1, "%d", PARM_TX_RATE1 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_TX_RATE2, "%d", PARM_TX_RATE2 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_TX_RATE3, "%d", PARM_TX_RATE3 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_TX_RATE4, "%d", PARM_TX_RATE4 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_TX_RATE5, "%d", PARM_TX_RATE5 );\r\nDBG_PARAM( DbgInfo, PARM_NAME_TX_RATE6, "%d", PARM_TX_RATE6 );\r\nDBG_PARAM(DbgInfo, PARM_NAME_WDS_ADDRESS1, "\"%pM\"",\r\nPARM_WDS_ADDRESS1);\r\nDBG_PARAM(DbgInfo, PARM_NAME_WDS_ADDRESS2, "\"%pM\"",\r\nPARM_WDS_ADDRESS2);\r\nDBG_PARAM(DbgInfo, PARM_NAME_WDS_ADDRESS3, "\"%pM\"",\r\nPARM_WDS_ADDRESS3);\r\nDBG_PARAM(DbgInfo, PARM_NAME_WDS_ADDRESS4, "\"%pM\"",\r\nPARM_WDS_ADDRESS4);\r\nDBG_PARAM(DbgInfo, PARM_NAME_WDS_ADDRESS5, "\"%pM\"",\r\nPARM_WDS_ADDRESS5);\r\nDBG_PARAM(DbgInfo, PARM_NAME_WDS_ADDRESS6, "\"%pM\"",\r\nPARM_WDS_ADDRESS6);\r\n#endif\r\n#endif\r\nVALID_PARAM( !PARM_DESIRED_SSID || ( strlen( PARM_DESIRED_SSID ) <= PARM_MAX_NAME_LEN ));\r\nVALID_PARAM( !PARM_OWN_SSID || ( strlen( PARM_OWN_SSID ) <= PARM_MAX_NAME_LEN ));\r\nVALID_PARAM(( PARM_OWN_CHANNEL <= PARM_MAX_OWN_CHANNEL ));\r\nVALID_PARAM(( PARM_SYSTEM_SCALE >= PARM_MIN_SYSTEM_SCALE ) && ( PARM_SYSTEM_SCALE <= PARM_MAX_SYSTEM_SCALE ));\r\nVALID_PARAM(( PARM_TX_RATE >= PARM_MIN_TX_RATE ) && ( PARM_TX_RATE <= PARM_MAX_TX_RATE ));\r\nVALID_PARAM(( PARM_RTS_THRESHOLD <= PARM_MAX_RTS_THRESHOLD ));\r\nVALID_PARAM( !PARM_MICROWAVE_ROBUSTNESS || strchr( "NnYy", PARM_MICROWAVE_ROBUSTNESS[0] ) != NULL );\r\nVALID_PARAM( !PARM_OWN_NAME || ( strlen( PARM_NAME_OWN_NAME ) <= PARM_MAX_NAME_LEN ));\r\nVALID_PARAM(( PARM_ENABLE_ENCRYPTION <= PARM_MAX_ENABLE_ENCRYPTION ));\r\nVALID_PARAM( is_valid_key_string( PARM_KEY1 ));\r\nVALID_PARAM( is_valid_key_string( PARM_KEY2 ));\r\nVALID_PARAM( is_valid_key_string( PARM_KEY3 ));\r\nVALID_PARAM( is_valid_key_string( PARM_KEY4 ));\r\nVALID_PARAM(( PARM_TX_KEY >= PARM_MIN_TX_KEY ) && ( PARM_TX_KEY <= PARM_MAX_TX_KEY ));\r\nVALID_PARAM(( PARM_MULTICAST_RATE >= PARM_MIN_MULTICAST_RATE ) &&\r\n( PARM_MULTICAST_RATE <= PARM_MAX_MULTICAST_RATE ));\r\nVALID_PARAM( !PARM_DOWNLOAD_FIRMWARE || ( strlen( PARM_DOWNLOAD_FIRMWARE ) <= 255 ));\r\nVALID_PARAM(( PARM_AUTH_KEY_MGMT_SUITE < PARM_MAX_AUTH_KEY_MGMT_SUITE ));\r\nVALID_PARAM( !PARM_LOAD_BALANCING || strchr( "NnYy", PARM_LOAD_BALANCING[0] ) != NULL );\r\nVALID_PARAM( !PARM_MEDIUM_DISTRIBUTION || strchr( "NnYy", PARM_MEDIUM_DISTRIBUTION[0] ) != NULL );\r\nVALID_PARAM(( PARM_TX_POW_LEVEL <= PARM_MAX_TX_POW_LEVEL ));\r\nVALID_PARAM(( PARM_PORT_TYPE >= PARM_MIN_PORT_TYPE ) && ( PARM_PORT_TYPE <= PARM_MAX_PORT_TYPE ));\r\nVALID_PARAM( PARM_PM_ENABLED <= WVLAN_PM_STATE_STANDARD ||\r\n( PARM_PM_ENABLED & 0x7FFF ) <= WVLAN_PM_STATE_STANDARD );\r\nVALID_PARAM( !PARM_CREATE_IBSS || strchr( "NnYy", PARM_CREATE_IBSS[0] ) != NULL );\r\nVALID_PARAM( !PARM_MULTICAST_RX || strchr( "NnYy", PARM_MULTICAST_RX[0] ) != NULL );\r\nVALID_PARAM(( PARM_MAX_SLEEP <= PARM_MAX_MAX_PM_SLEEP ));\r\nVALID_PARAM(( PARM_AUTHENTICATION <= PARM_MAX_AUTHENTICATION ));\r\nVALID_PARAM(( PARM_OWN_ATIM_WINDOW <= PARM_MAX_OWN_ATIM_WINDOW ));\r\nVALID_PARAM(( PARM_PM_HOLDOVER_DURATION <= PARM_MAX_PM_HOLDOVER_DURATION ));\r\nVALID_PARAM( !PARM_PROMISCUOUS_MODE || strchr( "NnYy", PARM_PROMISCUOUS_MODE[0] ) != NULL );\r\nVALID_PARAM(( PARM_CONNECTION_CONTROL <= PARM_MAX_CONNECTION_CONTROL ));\r\nVALID_PARAM(( PARM_OWN_DTIM_PERIOD >= PARM_MIN_OWN_DTIM_PERIOD ));\r\nVALID_PARAM( !PARM_REJECT_ANY || strchr( "NnYy", PARM_REJECT_ANY[0] ) != NULL );\r\nVALID_PARAM( !PARM_EXCLUDE_UNENCRYPTED || strchr( "NnYy", PARM_EXCLUDE_UNENCRYPTED[0] ) != NULL );\r\nVALID_PARAM( !PARM_MULTICAST_PM_BUFFERING || strchr( "NnYy", PARM_MULTICAST_PM_BUFFERING[0] ) != NULL );\r\nVALID_PARAM( !PARM_INTRA_BSS_RELAY || strchr( "NnYy", PARM_INTRA_BSS_RELAY[0] ) != NULL );\r\n#ifdef USE_WDS\r\nVALID_PARAM(( PARM_RTS_THRESHOLD1 <= PARM_MAX_RTS_THRESHOLD ));\r\nVALID_PARAM(( PARM_RTS_THRESHOLD2 <= PARM_MAX_RTS_THRESHOLD ));\r\nVALID_PARAM(( PARM_RTS_THRESHOLD3 <= PARM_MAX_RTS_THRESHOLD ));\r\nVALID_PARAM(( PARM_RTS_THRESHOLD4 <= PARM_MAX_RTS_THRESHOLD ));\r\nVALID_PARAM(( PARM_RTS_THRESHOLD5 <= PARM_MAX_RTS_THRESHOLD ));\r\nVALID_PARAM(( PARM_RTS_THRESHOLD6 <= PARM_MAX_RTS_THRESHOLD ));\r\nVALID_PARAM(( PARM_TX_RATE1 >= PARM_MIN_TX_RATE ) && (PARM_TX_RATE1 <= PARM_MAX_TX_RATE ));\r\nVALID_PARAM(( PARM_TX_RATE2 >= PARM_MIN_TX_RATE ) && (PARM_TX_RATE2 <= PARM_MAX_TX_RATE ));\r\nVALID_PARAM(( PARM_TX_RATE3 >= PARM_MIN_TX_RATE ) && (PARM_TX_RATE3 <= PARM_MAX_TX_RATE ));\r\nVALID_PARAM(( PARM_TX_RATE4 >= PARM_MIN_TX_RATE ) && (PARM_TX_RATE4 <= PARM_MAX_TX_RATE ));\r\nVALID_PARAM(( PARM_TX_RATE5 >= PARM_MIN_TX_RATE ) && (PARM_TX_RATE5 <= PARM_MAX_TX_RATE ));\r\nVALID_PARAM(( PARM_TX_RATE6 >= PARM_MIN_TX_RATE ) && (PARM_TX_RATE6 <= PARM_MAX_TX_RATE ));\r\n#endif\r\nVALID_PARAM(( PARM_OWN_BEACON_INTERVAL >= PARM_MIN_OWN_BEACON_INTERVAL ) && ( PARM_OWN_BEACON_INTERVAL <= PARM_MAX_OWN_BEACON_INTERVAL ));\r\nVALID_PARAM(( PARM_COEXISTENCE <= PARM_COEXISTENCE ));\r\nlp->Channel = PARM_OWN_CHANNEL;\r\nlp->DistanceBetweenAPs = PARM_SYSTEM_SCALE;\r\nlp->TxRateControl[0] = PARM_DEFAULT_TX_RATE_2GHZ;\r\nlp->TxRateControl[1] = PARM_DEFAULT_TX_RATE_5GHZ;\r\nlp->RTSThreshold = PARM_RTS_THRESHOLD;\r\nlp->MulticastRate[0] = PARM_DEFAULT_MULTICAST_RATE_2GHZ;\r\nlp->MulticastRate[1] = PARM_DEFAULT_MULTICAST_RATE_5GHZ;\r\nif ( strchr( "Yy", PARM_MICROWAVE_ROBUSTNESS[0] ) != NULL ) {\r\nlp->MicrowaveRobustness = 1;\r\n} else {\r\nlp->MicrowaveRobustness = 0;\r\n}\r\nif ( PARM_DESIRED_SSID && ( strlen( PARM_DESIRED_SSID ) <= HCF_MAX_NAME_LEN )) {\r\nstrcpy( lp->NetworkName, PARM_DESIRED_SSID );\r\n}\r\nif ( PARM_OWN_SSID && ( strlen( PARM_OWN_SSID ) <= HCF_MAX_NAME_LEN )) {\r\nstrcpy( lp->NetworkName, PARM_OWN_SSID );\r\n}\r\nif ( PARM_OWN_NAME && ( strlen( PARM_OWN_NAME ) <= HCF_MAX_NAME_LEN )) {\r\nstrcpy( lp->StationName, PARM_OWN_NAME );\r\n}\r\nlp->EnableEncryption = PARM_ENABLE_ENCRYPTION;\r\nif ( PARM_KEY1 && ( strlen( PARM_KEY1 ) <= MAX_KEY_LEN )) {\r\nstrcpy( lp->Key1, PARM_KEY1 );\r\n}\r\nif ( PARM_KEY2 && ( strlen( PARM_KEY2 ) <= MAX_KEY_LEN )) {\r\nstrcpy( lp->Key2, PARM_KEY2 );\r\n}\r\nif ( PARM_KEY3 && ( strlen( PARM_KEY3 ) <= MAX_KEY_LEN )) {\r\nstrcpy( lp->Key3, PARM_KEY3 );\r\n}\r\nif ( PARM_KEY4 && ( strlen( PARM_KEY4 ) <= MAX_KEY_LEN )) {\r\nstrcpy( lp->Key4, PARM_KEY4 );\r\n}\r\nlp->TransmitKeyID = PARM_TX_KEY;\r\nkey_string2key( lp->Key1, &(lp->DefaultKeys.key[0] ));\r\nkey_string2key( lp->Key2, &(lp->DefaultKeys.key[1] ));\r\nkey_string2key( lp->Key3, &(lp->DefaultKeys.key[2] ));\r\nkey_string2key( lp->Key4, &(lp->DefaultKeys.key[3] ));\r\nlp->DownloadFirmware = 1 ;\r\nlp->AuthKeyMgmtSuite = PARM_AUTH_KEY_MGMT_SUITE;\r\nif ( strchr( "Yy", PARM_LOAD_BALANCING[0] ) != NULL ) {\r\nlp->loadBalancing = 1;\r\n} else {\r\nlp->loadBalancing = 0;\r\n}\r\nif ( strchr( "Yy", PARM_MEDIUM_DISTRIBUTION[0] ) != NULL ) {\r\nlp->mediumDistribution = 1;\r\n} else {\r\nlp->mediumDistribution = 0;\r\n}\r\nlp->txPowLevel = PARM_TX_POW_LEVEL;\r\nlp->srsc[0] = PARM_SRSC_2GHZ;\r\nlp->srsc[1] = PARM_SRSC_5GHZ;\r\nlp->brsc[0] = PARM_BRSC_2GHZ;\r\nlp->brsc[1] = PARM_BRSC_5GHZ;\r\n#if 1\r\nlp->PortType = PARM_PORT_TYPE;\r\nlp->MaxSleepDuration = PARM_MAX_SLEEP;\r\nlp->authentication = PARM_AUTHENTICATION;\r\nlp->atimWindow = PARM_OWN_ATIM_WINDOW;\r\nlp->holdoverDuration = PARM_PM_HOLDOVER_DURATION;\r\nlp->PMEnabled = PARM_PM_ENABLED;\r\nif ( strchr( "Yy", PARM_CREATE_IBSS[0] ) != NULL ) {\r\nlp->CreateIBSS = 1;\r\n} else {\r\nlp->CreateIBSS = 0;\r\n}\r\nif ( strchr( "Nn", PARM_MULTICAST_RX[0] ) != NULL ) {\r\nlp->MulticastReceive = 0;\r\n} else {\r\nlp->MulticastReceive = 1;\r\n}\r\nif ( strchr( "Yy", PARM_PROMISCUOUS_MODE[0] ) != NULL ) {\r\nlp->promiscuousMode = 1;\r\n} else {\r\nlp->promiscuousMode = 0;\r\n}\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nlp->MACAddress[i] = PARM_NETWORK_ADDR[i];\r\n}\r\nlp->connectionControl = PARM_CONNECTION_CONTROL;\r\n#endif\r\n#if 1\r\nlp->DTIMPeriod = PARM_OWN_DTIM_PERIOD;\r\nif ( strchr( "Yy", PARM_REJECT_ANY[0] ) != NULL ) {\r\nlp->RejectAny = 1;\r\n} else {\r\nlp->RejectAny = 0;\r\n}\r\nif ( strchr( "Nn", PARM_EXCLUDE_UNENCRYPTED[0] ) != NULL ) {\r\nlp->ExcludeUnencrypted = 0;\r\n} else {\r\nlp->ExcludeUnencrypted = 1;\r\n}\r\nif ( strchr( "Yy", PARM_MULTICAST_PM_BUFFERING[0] ) != NULL ) {\r\nlp->multicastPMBuffering = 1;\r\n} else {\r\nlp->multicastPMBuffering = 0;\r\n}\r\nif ( strchr( "Yy", PARM_INTRA_BSS_RELAY[0] ) != NULL ) {\r\nlp->intraBSSRelay = 1;\r\n} else {\r\nlp->intraBSSRelay = 0;\r\n}\r\nlp->ownBeaconInterval = PARM_OWN_BEACON_INTERVAL;\r\nlp->coexistence = PARM_COEXISTENCE;\r\n#ifdef USE_WDS\r\nlp->wds_port[0].rtsThreshold = PARM_RTS_THRESHOLD1;\r\nlp->wds_port[1].rtsThreshold = PARM_RTS_THRESHOLD2;\r\nlp->wds_port[2].rtsThreshold = PARM_RTS_THRESHOLD3;\r\nlp->wds_port[3].rtsThreshold = PARM_RTS_THRESHOLD4;\r\nlp->wds_port[4].rtsThreshold = PARM_RTS_THRESHOLD5;\r\nlp->wds_port[5].rtsThreshold = PARM_RTS_THRESHOLD6;\r\nlp->wds_port[0].txRateCntl = PARM_TX_RATE1;\r\nlp->wds_port[1].txRateCntl = PARM_TX_RATE2;\r\nlp->wds_port[2].txRateCntl = PARM_TX_RATE3;\r\nlp->wds_port[3].txRateCntl = PARM_TX_RATE4;\r\nlp->wds_port[4].txRateCntl = PARM_TX_RATE5;\r\nlp->wds_port[5].txRateCntl = PARM_TX_RATE6;\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nlp->wds_port[0].wdsAddress[i] = PARM_WDS_ADDRESS1[i];\r\n}\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nlp->wds_port[1].wdsAddress[i] = PARM_WDS_ADDRESS2[i];\r\n}\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nlp->wds_port[2].wdsAddress[i] = PARM_WDS_ADDRESS3[i];\r\n}\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nlp->wds_port[3].wdsAddress[i] = PARM_WDS_ADDRESS4[i];\r\n}\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nlp->wds_port[4].wdsAddress[i] = PARM_WDS_ADDRESS5[i];\r\n}\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nlp->wds_port[5].wdsAddress[i] = PARM_WDS_ADDRESS6[i];\r\n}\r\n#endif\r\n#endif\r\n#ifdef USE_RTS\r\nif ( strchr( "Yy", useRTS[0] ) != NULL ) {\r\nlp->useRTS = 1;\r\n} else {\r\nlp->useRTS = 0;\r\n}\r\n#endif\r\nwl_lock( lp, &flags );\r\nlp->portState = WVLAN_PORT_STATE_DISABLED;\r\nmemset( &( lp->scan_results ), 0, sizeof( lp->scan_results ));\r\nlp->scan_results.scan_complete = FALSE;\r\nmemset( &( lp->probe_results ), 0, sizeof( lp->probe_results ));\r\nlp->probe_results.scan_complete = FALSE;\r\nlp->probe_num_aps = 0;\r\nmemset( lp->txList, 0, sizeof( lp->txList ));\r\nINIT_LIST_HEAD( &( lp->txFree ));\r\nlp->txF.skb = NULL;\r\nlp->txF.port = 0;\r\nfor( i = 0; i < DEFAULT_NUM_TX_FRAMES; i++ ) {\r\nlist_add_tail( &( lp->txList[i].node ), &( lp->txFree ));\r\n}\r\nfor( i = 0; i < WVLAN_MAX_TX_QUEUES; i++ ) {\r\nINIT_LIST_HEAD( &( lp->txQ[i] ));\r\n}\r\nlp->netif_queue_on = TRUE;\r\nlp->txQ_count = 0;\r\n#ifdef WARP\r\n#ifdef ENABLE_DMA\r\nDBG_TRACE( DbgInfo, "HERMES 2.5 BUSMASTER DMA MODE\n" );\r\nlp->use_dma = 1;\r\n#else\r\nDBG_TRACE( DbgInfo, "HERMES 2.5 PORT I/O MODE\n" );\r\nlp->use_dma = 0;\r\n#endif\r\n#endif\r\ntasklet_init(&lp->task, wl_isr_handler, (unsigned long)lp);\r\nDBG_TRACE( DbgInfo, "Calling hcf_connect()...\n" );\r\nhcf_status = hcf_connect( &lp->hcfCtx, dev->base_addr );\r\nif ( hcf_status != HCF_SUCCESS && hcf_status != HCF_ERR_INCOMP_FW ) {\r\nDBG_ERROR( DbgInfo, "hcf_connect() failed, status: 0x%x\n", hcf_status );\r\nwl_unlock( lp, &flags );\r\ngoto hcf_failed;\r\n}\r\nlp->driverInfo.IO_address = dev->base_addr;\r\nlp->driverInfo.IO_range = HCF_NUM_IO_PORTS;\r\nlp->driverInfo.IRQ_number = dev->irq;\r\nlp->driverInfo.card_stat = lp->hcfCtx.IFB_CardStat;\r\nlp->driverIdentity.len = ( sizeof( lp->driverIdentity ) / sizeof( hcf_16 )) - 1;\r\nlp->driverIdentity.typ = CFG_DRV_IDENTITY;\r\nlp->driverIdentity.comp_id = DRV_IDENTITY;\r\nlp->driverIdentity.variant = DRV_VARIANT;\r\nlp->driverIdentity.version_major = DRV_MAJOR_VERSION;\r\nlp->driverIdentity.version_minor = DRV_MINOR_VERSION;\r\nDBG_TRACE( DbgInfo, "Calling wvlan_go() to perform a card reset...\n" );\r\nhcf_status = wl_go( lp );\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, "wl_go() failed\n" );\r\nwl_unlock( lp, &flags );\r\ngoto hcf_failed;\r\n}\r\nwl_put_ltv_init( lp );\r\n#if 0\r\nif ( wl_adapter_is_open( lp->dev )) {\r\nDBG_TRACE( DbgInfo, "Enabling Port 0\n" );\r\nhcf_status = wl_enable( lp );\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "Enable port 0 failed: 0x%x\n", hcf_status );\r\n}\r\n#if (HCF_TYPE) & HCF_TYPE_AP\r\nDBG_TRACE( DbgInfo, "Enabling WDS Ports\n" );\r\n#endif\r\n}\r\n#endif\r\nmemcpy( lp->dev->dev_addr, lp->MACAddress, ETH_ALEN );\r\ndev->addr_len = ETH_ALEN;\r\nlp->is_registered = TRUE;\r\n#ifdef USE_PROFILE\r\nparse_config( dev );\r\n#endif\r\nWL_WDS_NETDEV_REGISTER( lp );\r\nlp->DownloadFirmware = WVLAN_DRV_MODE_STA;\r\n#ifdef USE_RTS\r\nif ( lp->useRTS == 1 ) {\r\nDBG_TRACE( DbgInfo, "ENTERING RTS MODE...\n" );\r\nwl_act_int_off( lp );\r\nlp->is_handling_int = WL_NOT_HANDLING_INT;\r\nwl_disable( lp );\r\nhcf_connect( &lp->hcfCtx, HCF_DISCONNECT);\r\n}\r\n#endif\r\nwl_unlock( lp, &flags );\r\nDBG_TRACE( DbgInfo, "%s: Wireless, io_addr %#03lx, irq %d, ""mac_address ",\r\ndev->name, dev->base_addr, dev->irq );\r\nfor( i = 0; i < ETH_ALEN; i++ ) {\r\nprintk( "%02X%c", dev->dev_addr[i], (( i < ( ETH_ALEN-1 )) ? ':' : '\n' ));\r\n}\r\n#if 0 //SCULL_USE_PROC /* don't waste space if unused */\r\ncreate_proc_read_entry( "wlags", 0, NULL, scull_read_procmem, dev );\r\nproc_mkdir("driver/wlags49", 0);\r\nproc_write("driver/wlags49/wlags49_type", write_int, &lp->wlags49_type);\r\n#endif /* SCULL_USE_PROC */\r\nDBG_LEAVE( DbgInfo );\r\nreturn result;\r\nhcf_failed:\r\nwl_hcf_error( dev, hcf_status );\r\nfailed:\r\nDBG_ERROR( DbgInfo, "wl_insert() FAILED\n" );\r\nif ( lp->is_registered == TRUE ) {\r\nlp->is_registered = FALSE;\r\n}\r\nWL_WDS_NETDEV_DEREGISTER( lp );\r\nresult = -EFAULT;\r\nDBG_LEAVE( DbgInfo );\r\nreturn result;\r\n} // wl_insert\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_reset()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Reset the adapter.\r\n*\r\n* PARAMETERS:\r\n*\r\n* dev - a pointer to the net_device struct of the wireless device\r\n*\r\n* RETURNS:\r\n*\r\n* an HCF status code\r\n*\r\n******************************************************************************/\r\nint wl_reset(struct net_device *dev)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nint hcf_status = HCF_SUCCESS;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_reset" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PARAM( DbgInfo, "dev", "%s (0x%p)", dev->name, dev );\r\nDBG_PARAM( DbgInfo, "dev->base_addr", "(%#03lx)", dev->base_addr );\r\n/*\r\n* The caller should already have a lock and\r\n* disable the interrupts, we do not lock here,\r\n* nor do we enable/disable interrupts!\r\n*/\r\nDBG_TRACE( DbgInfo, "Device Base Address: %#03lx\n", dev->base_addr );\r\nif ( dev->base_addr ) {\r\n/* Shutdown the adapter. */\r\nhcf_connect( &lp->hcfCtx, HCF_DISCONNECT );\r\n/* Reset the driver information. */\r\nlp->txBytes = 0;\r\n/* Connect to the adapter. */\r\nhcf_status = hcf_connect( &lp->hcfCtx, dev->base_addr );\r\nif ( hcf_status != HCF_SUCCESS && hcf_status != HCF_ERR_INCOMP_FW ) {\r\nDBG_ERROR( DbgInfo, "hcf_connect() failed, status: 0x%x\n", hcf_status );\r\ngoto out;\r\n}\r\n/* Check if firmware is present, if not change state */\r\nif ( hcf_status == HCF_ERR_INCOMP_FW ) {\r\nlp->firmware_present = WL_FRIMWARE_NOT_PRESENT;\r\n}\r\n/* Initialize the portState variable */\r\nlp->portState = WVLAN_PORT_STATE_DISABLED;\r\n/* Restart the adapter. */\r\nhcf_status = wl_go( lp );\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, "wl_go() failed, status: 0x%x\n", hcf_status );\r\ngoto out;\r\n}\r\n/* Certain RIDs must be set before enabling the ports */\r\nwl_put_ltv_init( lp );\r\n} else {\r\nDBG_ERROR( DbgInfo, "Device Base Address INVALID!!!\n" );\r\n}\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n} // wl_reset\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_go()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Reset the adapter.\r\n*\r\n* PARAMETERS:\r\n*\r\n* dev - a pointer to the net_device struct of the wireless device\r\n*\r\n* RETURNS:\r\n*\r\n* an HCF status code\r\n*\r\n******************************************************************************/\r\nint wl_go( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nchar *cp = NULL; //fw_image\r\nint retries = 0;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_go" );\r\nDBG_ENTER( DbgInfo );\r\nhcf_status = wl_disable( lp );\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "Disable port 0 failed: 0x%x\n", hcf_status );\r\nwhile (( hcf_status != HCF_SUCCESS ) && (retries < 10)) {\r\nretries++;\r\nhcf_status = wl_disable( lp );\r\n}\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "Disable port 0 succes : %d retries\n", retries );\r\n} else {\r\nDBG_TRACE( DbgInfo, "Disable port 0 failed after: %d retries\n", retries );\r\n}\r\n}\r\n#if 1 //;? (HCF_TYPE) & HCF_TYPE_AP\r\n//DBG_TRACE( DbgInfo, "Disabling WDS Ports\n" );\r\n//wl_disable_wds_ports( lp );\r\n#endif /* (HCF_TYPE) & HCF_TYPE_AP */\r\n//;?what was the purpose of this\r\n// /* load the appropriate firmware image, depending on driver mode */\r\n// lp->ltvRecord.len = ( sizeof( CFG_RANGE20_STRCT ) / sizeof( hcf_16 )) - 1;\r\n// lp->ltvRecord.typ = CFG_DRV_ACT_RANGES_PRI;\r\n// hcf_get_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n#if BIN_DL\r\nif ( strlen( lp->fw_image_filename ) ) {\r\nmm_segment_t fs;\r\nint file_desc;\r\nint rc;\r\nDBG_TRACE( DbgInfo, "F/W image:%s:\n", lp->fw_image_filename );\r\n/* Obtain a user-space process context, storing the original context */\r\nfs = get_fs( );\r\nset_fs( get_ds( ));\r\nfile_desc = open( lp->fw_image_filename, O_RDONLY, 0 );\r\nif ( file_desc == -1 ) {\r\nDBG_ERROR( DbgInfo, "No image file found\n" );\r\n} else {\r\nDBG_TRACE( DbgInfo, "F/W image file found\n" );\r\n#define DHF_ALLOC_SIZE 96000 //just below 96K, let's hope it suffices for now and for the future\r\ncp = (char*)vmalloc( DHF_ALLOC_SIZE );\r\nif ( cp == NULL ) {\r\nDBG_ERROR( DbgInfo, "error in vmalloc\n" );\r\n} else {\r\nrc = read( file_desc, cp, DHF_ALLOC_SIZE );\r\nif ( rc == DHF_ALLOC_SIZE ) {\r\nDBG_ERROR( DbgInfo, "buffer too small, %d\n", DHF_ALLOC_SIZE );\r\n} else if ( rc > 0 ) {\r\nDBG_TRACE( DbgInfo, "read O.K.: %d bytes %.12s\n", rc, cp );\r\nrc = read( file_desc, &cp[rc], 1 );\r\nif ( rc == 0 ) { //;/change to an until-loop at rc<=0\r\nDBG_TRACE( DbgInfo, "no more to read\n" );\r\n}\r\n}\r\nif ( rc != 0 ) {\r\nDBG_ERROR( DbgInfo, "file not read in one swoop or other error"\\r\n", give up, too complicated, rc = %0X\n", rc );\r\nDBG_ERROR( DbgInfo, "still have to change code to get a real download now !!!!!!!!\n" );\r\n} else {\r\nDBG_TRACE( DbgInfo, "before dhf_download_binary\n" );\r\nhcf_status = dhf_download_binary( (memimage *)cp );\r\nDBG_TRACE( DbgInfo, "after dhf_download_binary, before dhf_download_fw\n" );\r\n//;?improve error flow/handling\r\nhcf_status = dhf_download_fw( &lp->hcfCtx, (memimage *)cp );\r\nDBG_TRACE( DbgInfo, "after dhf_download_fw\n" );\r\n}\r\nvfree( cp );\r\n}\r\nclose( file_desc );\r\n}\r\nset_fs( fs ); /* Return to the original context */\r\n}\r\n#endif // BIN_DL\r\n/* If firmware is present but the type is unknown then download anyway */\r\nif ( (lp->firmware_present == WL_FRIMWARE_PRESENT)\r\n&&\r\n( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) != COMP_ID_FW_STA )\r\n&&\r\n( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) != COMP_ID_FW_AP ) ) {\r\n/* Unknown type, download needed. */\r\nlp->firmware_present = WL_FRIMWARE_NOT_PRESENT;\r\n}\r\nif(lp->firmware_present == WL_FRIMWARE_NOT_PRESENT)\r\n{\r\nif ( cp == NULL ) {\r\nDBG_TRACE( DbgInfo, "Downloading STA firmware...\n" );\r\n// hcf_status = dhf_download_fw( &lp->hcfCtx, &station );\r\nhcf_status = dhf_download_fw( &lp->hcfCtx, &fw_image );\r\n}\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, "Firmware Download failed\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\n}\r\n/* Report the FW versions */\r\n//;?obsolete, use the available IFB info:: wl_get_pri_records( lp );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_STA ) {\r\nDBG_TRACE( DbgInfo, "downloaded station F/W\n" );\r\n} else if ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nDBG_TRACE( DbgInfo, "downloaded AP F/W\n" );\r\n} else {\r\nDBG_ERROR( DbgInfo, "unknown F/W type\n" );\r\n}\r\n/*\r\n* Downloaded, no need to repeat this next time, assume the\r\n* contents stays in the card until it is powered off. Note we\r\n* do not switch firmware on the fly, the firmware is fixed in\r\n* the driver for now.\r\n*/\r\nlp->firmware_present = WL_FRIMWARE_PRESENT;\r\nDBG_TRACE( DbgInfo, "ComponentID:%04x variant:%04x major:%04x minor:%04x\n",\r\nCNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ),\r\nCNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.variant ),\r\nCNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.version_major ),\r\nCNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.version_minor ));\r\n/* now we wil get the MAC address of the card */\r\nlp->ltvRecord.len = 4;\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nlp->ltvRecord.typ = CFG_NIC_MAC_ADDR;\r\n} else\r\n{\r\nlp->ltvRecord.typ = CFG_CNF_OWN_MAC_ADDR;\r\n}\r\nhcf_status = hcf_get_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, "Could not retrieve MAC address\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nmemcpy( lp->MACAddress, &lp->ltvRecord.u.u8[0], ETH_ALEN );\r\nDBG_TRACE(DbgInfo, "Card MAC Address: %pM\n", lp->MACAddress);\r\n/* Write out configuration to the device, enable, and reconnect. However,\r\nonly reconnect if in AP mode. For STA mode, need to wait for passive scan\r\ncompletion before a connect can be issued */\r\nwl_put_ltv( lp );\r\n/* Enable the ports */\r\nhcf_status = wl_enable( lp );\r\nif ( lp->DownloadFirmware == WVLAN_DRV_MODE_AP ) {\r\n#ifdef USE_WDS\r\nwl_enable_wds_ports( lp );\r\n#endif // USE_WDS\r\nhcf_status = wl_connect( lp );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n} // wl_go\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_set_wep_keys()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Write TxKeyID and WEP keys to the adapter. This is separated from\r\n* wl_apply() to allow dynamic WEP key updates through the wireless\r\n* extensions.\r\n*\r\n* PARAMETERS:\r\n*\r\n* lp - a pointer to the wireless adapter's private structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nvoid wl_set_wep_keys( struct wl_private *lp )\r\n{\r\nint count = 0;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_set_wep_keys" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PARAM( DbgInfo, "lp", "%s (0x%p)", lp->dev->name, lp );\r\nif ( lp->EnableEncryption ) {\r\n/* NOTE: CFG_CNF_ENCRYPTION is set in wl_put_ltv() as it's a static\r\nRID */\r\n/* set TxKeyID */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_KEY_ID;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->TransmitKeyID - 1);\r\nhcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nDBG_TRACE( DbgInfo, "Key 1 len: %d\n", lp->DefaultKeys.key[0].len );\r\nDBG_TRACE( DbgInfo, "Key 2 len: %d\n", lp->DefaultKeys.key[1].len );\r\nDBG_TRACE( DbgInfo, "Key 3 len: %d\n", lp->DefaultKeys.key[2].len );\r\nDBG_TRACE( DbgInfo, "Key 4 len: %d\n", lp->DefaultKeys.key[3].len );\r\n/* write keys */\r\nlp->DefaultKeys.len = sizeof( lp->DefaultKeys ) / sizeof( hcf_16 ) - 1;\r\nlp->DefaultKeys.typ = CFG_DEFAULT_KEYS;\r\n/* endian translate the appropriate key information */\r\nfor( count = 0; count < MAX_KEYS; count++ ) {\r\nlp->DefaultKeys.key[count].len = CNV_INT_TO_LITTLE( lp->DefaultKeys.key[count].len );\r\n}\r\nhcf_put_info( &lp->hcfCtx, (LTVP)&( lp->DefaultKeys ));\r\n/* Reverse the above endian translation, since these keys are accessed\r\nelsewhere */\r\nfor( count = 0; count < MAX_KEYS; count++ ) {\r\nlp->DefaultKeys.key[count].len = CNV_INT_TO_LITTLE( lp->DefaultKeys.key[count].len );\r\n}\r\nDBG_NOTICE( DbgInfo, "encrypt: %d, ID: %d\n", lp->EnableEncryption, lp->TransmitKeyID );\r\nDBG_NOTICE( DbgInfo, "set key: %s(%d) [%d]\n", lp->DefaultKeys.key[lp->TransmitKeyID-1].key, lp->DefaultKeys.key[lp->TransmitKeyID-1].len, lp->TransmitKeyID-1 );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\n} // wl_set_wep_keys\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_apply()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Write the parameters to the adapter. (re-)enables the card if device is\r\n* open. Returns hcf_status of hcf_enable().\r\n*\r\n* PARAMETERS:\r\n*\r\n* lp - a pointer to the wireless adapter's private structure\r\n*\r\n* RETURNS:\r\n*\r\n* an HCF status code\r\n*\r\n******************************************************************************/\r\nint wl_apply(struct wl_private *lp)\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_apply" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_ASSERT( lp != NULL);\r\nDBG_PARAM( DbgInfo, "lp", "%s (0x%p)", lp->dev->name, lp );\r\nif ( !( lp->flags & WVLAN2_UIL_BUSY )) {\r\n/* The adapter parameters have changed:\r\ndisable card\r\nreload parameters\r\nenable card\r\n*/\r\nif ( wl_adapter_is_open( lp->dev )) {\r\n/* Disconnect and disable if necessary */\r\nhcf_status = wl_disconnect( lp );\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, "Disconnect failed\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn -1;\r\n}\r\nhcf_status = wl_disable( lp );\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, "Disable failed\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn -1;\r\n} else {\r\n/* Write out configuration to the device, enable, and reconnect.\r\nHowever, only reconnect if in AP mode. For STA mode, need to\r\nwait for passive scan completion before a connect can be\r\nissued */\r\nhcf_status = wl_put_ltv( lp );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nhcf_status = wl_enable( lp );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nhcf_status = wl_connect( lp );\r\n}\r\n} else {\r\nDBG_WARNING( DbgInfo, "wl_put_ltv() failed\n" );\r\n}\r\n}\r\n}\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n} // wl_apply\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_put_ltv_init()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Used to set basic parameters for card initialization.\r\n*\r\n* PARAMETERS:\r\n*\r\n* lp - a pointer to the wireless adapter's private structure\r\n*\r\n* RETURNS:\r\n*\r\n* an HCF status code\r\n*\r\n******************************************************************************/\r\nint wl_put_ltv_init( struct wl_private *lp )\r\n{\r\nint i;\r\nint hcf_status;\r\nCFG_RID_LOG_STRCT *RidLog;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_put_ltv_init" );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp == NULL ) {\r\nDBG_ERROR( DbgInfo, "lp pointer is NULL\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn -1;\r\n}\r\n/* DMA/IO */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNTL_OPT;\r\n/* The Card Services build must ALWAYS configure for 16-bit I/O. PCI or\r\nCardBus can be set to either 16/32 bit I/O, or Bus Master DMA, but only\r\nfor Hermes-2.5 */\r\n#ifdef BUS_PCMCIA\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( USE_16BIT );\r\n#else\r\nif ( lp->use_dma ) {\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( USE_DMA );\r\n} else {\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0 );\r\n}\r\n#endif\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nDBG_TRACE( DbgInfo, "CFG_CNTL_OPT : 0x%04x\n",\r\nlp->ltvRecord.u.u16[0] );\r\nDBG_TRACE( DbgInfo, "CFG_CNTL_OPT result : 0x%04x\n",\r\nhcf_status );\r\n/* Register the list of RIDs on which asynchronous notification is\r\nrequired. Note that this mechanism replaces the mailbox, so the mailbox\r\ncan be queried by the host (if desired) without contention from us */\r\ni=0;\r\nlp->RidList[i].len = sizeof( lp->ProbeResp );\r\nlp->RidList[i].typ = CFG_ACS_SCAN;\r\nlp->RidList[i].bufp = (wci_recordp)&lp->ProbeResp;\r\n//lp->ProbeResp.infoType = 0xFFFF;\r\ni++;\r\nlp->RidList[i].len = sizeof( lp->assoc_stat );\r\nlp->RidList[i].typ = CFG_ASSOC_STAT;\r\nlp->RidList[i].bufp = (wci_recordp)&lp->assoc_stat;\r\nlp->assoc_stat.len = 0xFFFF;\r\ni++;\r\nlp->RidList[i].len = 4;\r\nlp->RidList[i].typ = CFG_UPDATED_INFO_RECORD;\r\nlp->RidList[i].bufp = (wci_recordp)&lp->updatedRecord;\r\nlp->updatedRecord.len = 0xFFFF;\r\ni++;\r\nlp->RidList[i].len = sizeof( lp->sec_stat );\r\nlp->RidList[i].typ = CFG_SECURITY_STAT;\r\nlp->RidList[i].bufp = (wci_recordp)&lp->sec_stat;\r\nlp->sec_stat.len = 0xFFFF;\r\ni++;\r\nlp->RidList[i].typ = 0; // Terminate List\r\nRidLog = (CFG_RID_LOG_STRCT *)&lp->ltvRecord;\r\nRidLog->len = 3;\r\nRidLog->typ = CFG_REG_INFO_LOG;\r\nRidLog->recordp = (RID_LOGP)&lp->RidList[0];\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nDBG_TRACE( DbgInfo, "CFG_REG_INFO_LOG\n" );\r\nDBG_TRACE( DbgInfo, "CFG_REG_INFO_LOG result : 0x%04x\n",\r\nhcf_status );\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n} // wl_put_ltv_init\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_put_ltv()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Used by wvlan_apply() and wvlan_go to set the card's configuration.\r\n*\r\n* PARAMETERS:\r\n*\r\n* lp - a pointer to the wireless adapter's private structure\r\n*\r\n* RETURNS:\r\n*\r\n* an HCF status code\r\n*\r\n******************************************************************************/\r\nint wl_put_ltv( struct wl_private *lp )\r\n{\r\nint len;\r\nint hcf_status;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_put_ltv" );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp == NULL ) {\r\nDBG_ERROR( DbgInfo, "lp pointer is NULL\n" );\r\nreturn -1;\r\n}\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nlp->maxPort = 6; //;?why set this here and not as part of download process\r\n} else {\r\nlp->maxPort = 0;\r\n}\r\n/* Send our configuration to the card. Perform any endian translation\r\nnecessary */\r\n/* Register the Mailbox; VxWorks does this elsewhere; why;? */\r\nlp->ltvRecord.len = 4;\r\nlp->ltvRecord.typ = CFG_REG_MB;\r\nlp->ltvRecord.u.u32[0] = (u_long)&( lp->mailbox );\r\nlp->ltvRecord.u.u16[2] = ( MB_SIZE / sizeof( hcf_16 ));\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Max Data Length */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_MAX_DATA_LEN;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( HCF_MAX_PACKET_SIZE );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* System Scale / Distance between APs */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_SYSTEM_SCALE;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->DistanceBetweenAPs );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Channel */\r\nif ( lp->CreateIBSS && ( lp->Channel == 0 )) {\r\nDBG_TRACE( DbgInfo, "Create IBSS" );\r\nlp->Channel = 10;\r\n}\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_OWN_CHANNEL;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->Channel );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Microwave Robustness */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_MICRO_WAVE;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->MicrowaveRobustness );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Load Balancing */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_LOAD_BALANCING;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->loadBalancing );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Medium Distribution */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_MEDIUM_DISTRIBUTION;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->mediumDistribution );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Country Code */\r\n#ifdef WARP\r\n/* Tx Power Level (for supported cards) */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_TX_POW_LVL;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->txPowLevel );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Short Retry Limit */\r\n/*lp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = 0xFC32;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->shortRetryLimit );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n*/\r\n/* Long Retry Limit */\r\n/*lp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = 0xFC33;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->longRetryLimit );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n*/\r\n/* Supported Rate Set Control */\r\nlp->ltvRecord.len = 3;\r\nlp->ltvRecord.typ = CFG_SUPPORTED_RATE_SET_CNTL; //0xFC88;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->srsc[0] );\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->srsc[1] );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Basic Rate Set Control */\r\nlp->ltvRecord.len = 3;\r\nlp->ltvRecord.typ = CFG_BASIC_RATE_SET_CNTL; //0xFC89;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->brsc[0] );\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->brsc[1] );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Frame Burst Limit */\r\n/* Defined, but not currently available in Firmware */\r\n#endif // WARP\r\n#ifdef WARP\r\n/* Multicast Rate */\r\nlp->ltvRecord.len = 3;\r\nlp->ltvRecord.typ = CFG_CNF_MCAST_RATE;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->MulticastRate[0] );\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->MulticastRate[1] );\r\n#else\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_MCAST_RATE;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->MulticastRate[0] );\r\n#endif // WARP\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Own Name (Station Nickname) */\r\nif (( len = ( strlen( lp->StationName ) + 1 ) & ~0x01 ) != 0 ) {\r\n//DBG_TRACE( DbgInfo, "CFG_CNF_OWN_NAME : %s\n",\r\n// lp->StationName );\r\nlp->ltvRecord.len = 2 + ( len / sizeof( hcf_16 ));\r\nlp->ltvRecord.typ = CFG_CNF_OWN_NAME;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( strlen( lp->StationName ));\r\nmemcpy( &( lp->ltvRecord.u.u8[2] ), lp->StationName, len );\r\n} else {\r\n//DBG_TRACE( DbgInfo, "CFG_CNF_OWN_NAME : EMPTY\n" );\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_OWN_NAME;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0 );\r\n}\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n//DBG_TRACE( DbgInfo, "CFG_CNF_OWN_NAME result : 0x%04x\n",\r\n// hcf_status );\r\n/* The following are set in STA mode only */\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_STA ) {\r\n/* RTS Threshold */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_RTS_THRH;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->RTSThreshold );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Port Type */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_PORT_TYPE;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->PortType );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Tx Rate Control */\r\n#ifdef WARP\r\nlp->ltvRecord.len = 3;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->TxRateControl[0] );\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->TxRateControl[1] );\r\n#else\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->TxRateControl[0] );\r\n#endif // WARP\r\n//;?skip temporarily to see whether the RID or something else is the probelm hcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nDBG_TRACE( DbgInfo, "CFG_TX_RATE_CNTL 2.4GHz : 0x%04x\n",\r\nlp->TxRateControl[0] );\r\nDBG_TRACE( DbgInfo, "CFG_TX_RATE_CNTL 5.0GHz : 0x%04x\n",\r\nlp->TxRateControl[1] );\r\nDBG_TRACE( DbgInfo, "CFG_TX_RATE_CNTL result : 0x%04x\n",\r\nhcf_status );\r\n/* Power Management */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_PM_ENABLED;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->PMEnabled );\r\n// lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0x8001 );\r\nDBG_TRACE( DbgInfo, "CFG_CNF_PM_ENABLED : 0x%04x\n", lp->PMEnabled );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Multicast Receive */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_MCAST_RX;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->MulticastReceive );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Max Sleep Duration */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_MAX_SLEEP_DURATION;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->MaxSleepDuration );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Create IBSS */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CREATE_IBSS;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->CreateIBSS );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Desired SSID */\r\nif ((( len = ( strlen( lp->NetworkName ) + 1 ) & ~0x01 ) != 0 ) &&\r\n( strcmp( lp->NetworkName, "ANY" ) != 0 ) &&\r\n( strcmp( lp->NetworkName, "any" ) != 0 )) {\r\n//DBG_TRACE( DbgInfo, "CFG_DESIRED_SSID : %s\n",\r\n// lp->NetworkName );\r\nlp->ltvRecord.len = 2 + (len / sizeof(hcf_16));\r\nlp->ltvRecord.typ = CFG_DESIRED_SSID;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( strlen( lp->NetworkName ));\r\nmemcpy( &( lp->ltvRecord.u.u8[2] ), lp->NetworkName, len );\r\n} else {\r\n//DBG_TRACE( DbgInfo, "CFG_DESIRED_SSID : ANY\n" );\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_DESIRED_SSID;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0 );\r\n}\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n//DBG_TRACE( DbgInfo, "CFG_DESIRED_SSID result : 0x%04x\n",\r\n// hcf_status );\r\n/* Own ATIM window */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_OWN_ATIM_WINDOW;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->atimWindow );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Holdover Duration */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_HOLDOVER_DURATION;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->holdoverDuration );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Promiscuous Mode */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_PROMISCUOUS_MODE;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->promiscuousMode );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Authentication */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_AUTHENTICATION;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->authentication );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n#ifdef WARP\r\n/* Connection Control */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_CONNECTION_CNTL;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->connectionControl );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Probe data rate */\r\n/*lp->ltvRecord.len = 3;\r\nlp->ltvRecord.typ = CFG_PROBE_DATA_RATE;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->probeDataRates[0] );\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->probeDataRates[1] );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nDBG_TRACE( DbgInfo, "CFG_PROBE_DATA_RATE 2.4GHz : 0x%04x\n",\r\nlp->probeDataRates[0] );\r\nDBG_TRACE( DbgInfo, "CFG_PROBE_DATA_RATE 5.0GHz : 0x%04x\n",\r\nlp->probeDataRates[1] );\r\nDBG_TRACE( DbgInfo, "CFG_PROBE_DATA_RATE result : 0x%04x\n",\r\nhcf_status );*/\r\n#endif // WARP\r\n} else {\r\n/* The following are set in AP mode only */\r\n#if 0 //;? (HCF_TYPE) & HCF_TYPE_AP\r\n//;?should we restore this to allow smaller memory footprint\r\n/* DTIM Period */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_OWN_DTIM_PERIOD;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->DTIMPeriod );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Multicast PM Buffering */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_MCAST_PM_BUF;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->multicastPMBuffering );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Reject ANY - Closed System */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_REJECT_ANY;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->RejectAny );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Exclude Unencrypted */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_EXCL_UNENCRYPTED;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->ExcludeUnencrypted );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* IntraBSS Relay */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_INTRA_BSS_RELAY;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->intraBSSRelay );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* RTS Threshold 0 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_RTS_THRH0;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->RTSThreshold );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Tx Rate Control 0 */\r\n#ifdef WARP\r\nlp->ltvRecord.len = 3;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL0;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->TxRateControl[0] );\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( lp->TxRateControl[1] );\r\n#else\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL0;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->TxRateControl[0] );\r\n#endif // WARP\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Own Beacon Interval */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = 0xFC31;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->ownBeaconInterval );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Co-Existence Behavior */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = 0xFCC7;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->coexistence );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n#ifdef USE_WDS\r\n/* RTS Threshold 1 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_RTS_THRH1;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[0].rtsThreshold );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* RTS Threshold 2 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_RTS_THRH2;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[1].rtsThreshold );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* RTS Threshold 3 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_RTS_THRH3;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[2].rtsThreshold );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* RTS Threshold 4 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_RTS_THRH4;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[3].rtsThreshold );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* RTS Threshold 5 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_RTS_THRH5;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[4].rtsThreshold );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* RTS Threshold 6 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_RTS_THRH6;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[5].rtsThreshold );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n#if 0\r\n/* TX Rate Control 1 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL1;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[0].txRateCntl );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* TX Rate Control 2 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL2;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[1].txRateCntl );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* TX Rate Control 3 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL3;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[2].txRateCntl );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* TX Rate Control 4 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL4;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[3].txRateCntl );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* TX Rate Control 5 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL5;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[4].txRateCntl );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* TX Rate Control 6 */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_TX_RATE_CNTL6;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->wds_port[5].txRateCntl );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n#endif\r\n/* WDS addresses. It's okay to blindly send these parameters, because\r\nthe port needs to be enabled, before anything is done with it. */\r\n/* WDS Address 1 */\r\nlp->ltvRecord.len = 4;\r\nlp->ltvRecord.typ = CFG_CNF_WDS_ADDR1;\r\nmemcpy( &lp->ltvRecord.u.u8[0], lp->wds_port[0].wdsAddress, ETH_ALEN );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* WDS Address 2 */\r\nlp->ltvRecord.len = 4;\r\nlp->ltvRecord.typ = CFG_CNF_WDS_ADDR2;\r\nmemcpy( &lp->ltvRecord.u.u8[0], lp->wds_port[1].wdsAddress, ETH_ALEN );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* WDS Address 3 */\r\nlp->ltvRecord.len = 4;\r\nlp->ltvRecord.typ = CFG_CNF_WDS_ADDR3;\r\nmemcpy( &lp->ltvRecord.u.u8[0], lp->wds_port[2].wdsAddress, ETH_ALEN );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* WDS Address 4 */\r\nlp->ltvRecord.len = 4;\r\nlp->ltvRecord.typ = CFG_CNF_WDS_ADDR4;\r\nmemcpy( &lp->ltvRecord.u.u8[0], lp->wds_port[3].wdsAddress, ETH_ALEN );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* WDS Address 5 */\r\nlp->ltvRecord.len = 4;\r\nlp->ltvRecord.typ = CFG_CNF_WDS_ADDR5;\r\nmemcpy( &lp->ltvRecord.u.u8[0], lp->wds_port[4].wdsAddress, ETH_ALEN );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* WDS Address 6 */\r\nlp->ltvRecord.len = 4;\r\nlp->ltvRecord.typ = CFG_CNF_WDS_ADDR6;\r\nmemcpy( &lp->ltvRecord.u.u8[0], lp->wds_port[5].wdsAddress, ETH_ALEN );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n#endif /* USE_WDS */\r\n#endif /* (HCF_TYPE) & HCF_TYPE_AP */\r\n}\r\n/* Own MAC Address */\r\n/*\r\nDBG_TRACE(DbgInfo, "MAC Address : %pM\n",\r\nlp->MACAddress);\r\n*/\r\nif ( WVLAN_VALID_MAC_ADDRESS( lp->MACAddress )) {\r\n/* Make the MAC address valid by:\r\nClearing the multicast bit\r\nSetting the local MAC address bit\r\n*/\r\n//lp->MACAddress[0] &= ~0x03; //;?why is this commented out already in 720\r\n//lp->MACAddress[0] |= 0x02;\r\nlp->ltvRecord.len = 1 + ( ETH_ALEN / sizeof( hcf_16 ));\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\n//DBG_TRACE( DbgInfo, "CFG_NIC_MAC_ADDR\n" );\r\nlp->ltvRecord.typ = CFG_NIC_MAC_ADDR;\r\n} else {\r\n//DBG_TRACE( DbgInfo, "CFG_CNF_OWN_MAC_ADDR\n" );\r\nlp->ltvRecord.typ = CFG_CNF_OWN_MAC_ADDR;\r\n}\r\n/* MAC address is byte aligned, no endian conversion needed */\r\nmemcpy( &( lp->ltvRecord.u.u8[0] ), lp->MACAddress, ETH_ALEN );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n//DBG_TRACE( DbgInfo, "CFG_XXX_MAC_ADDR result : 0x%04x\n",\r\n// hcf_status );\r\n/* Update the MAC address in the netdevice struct */\r\nmemcpy( lp->dev->dev_addr, lp->MACAddress, ETH_ALEN ); //;?what is the purpose of this seemingly complex logic\r\n}\r\n/* Own SSID */\r\nif ((( len = ( strlen( lp->NetworkName ) + 1 ) & ~0x01 ) != 0 ) &&\r\n( strcmp( lp->NetworkName, "ANY" ) != 0 ) &&\r\n( strcmp( lp->NetworkName, "any" ) != 0 )) {\r\n//DBG_TRACE( DbgInfo, "CFG_CNF_OWN_SSID : %s\n",\r\n// lp->NetworkName );\r\nlp->ltvRecord.len = 2 + (len / sizeof(hcf_16));\r\nlp->ltvRecord.typ = CFG_CNF_OWN_SSID;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( strlen( lp->NetworkName ));\r\nmemcpy( &( lp->ltvRecord.u.u8[2] ), lp->NetworkName, len );\r\n} else {\r\n//DBG_TRACE( DbgInfo, "CFG_CNF_OWN_SSID : ANY\n" );\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_OWN_SSID;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0 );\r\n}\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n//DBG_TRACE( DbgInfo, "CFG_CNF_OWN_SSID result : 0x%04x\n",\r\n// hcf_status );\r\n/* enable/disable encryption */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CNF_ENCRYPTION;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->EnableEncryption );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* Set the Authentication Key Management Suite */\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_SET_WPA_AUTH_KEY_MGMT_SUITE;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( lp->AuthKeyMgmtSuite );\r\nhcf_status = hcf_put_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\n/* WEP Keys */\r\nwl_set_wep_keys( lp );\r\n/* Country Code */\r\n/* countryInfo, ltvCountryInfo, CFG_CNF_COUNTRY_INFO */\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n} // wl_put_ltv\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* init_module()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Load the kernel module.\r\n*\r\n* PARAMETERS:\r\n*\r\n* N/A\r\n*\r\n* RETURNS:\r\n*\r\n* 0 on success\r\n* an errno value otherwise\r\n*\r\n******************************************************************************/\r\nstatic int __init wl_module_init( void )\r\n{\r\nint result;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_module_init" );\r\n#if DBG\r\n/* Convert "standard" PCMCIA parameter pc_debug to a reasonable DebugFlag value.\r\n* NOTE: The values all fall through to the lower values. */\r\nDbgInfo->DebugFlag = 0;\r\nDbgInfo->DebugFlag = DBG_TRACE_ON; //;?get this mess resolved one day\r\nif ( pc_debug ) switch( pc_debug ) {\r\ncase 8:\r\nDbgInfo->DebugFlag |= DBG_DS_ON;\r\ncase 7:\r\nDbgInfo->DebugFlag |= DBG_RX_ON | DBG_TX_ON;\r\ncase 6:\r\nDbgInfo->DebugFlag |= DBG_PARAM_ON;\r\ncase 5:\r\nDbgInfo->DebugFlag |= DBG_TRACE_ON;\r\ncase 4:\r\nDbgInfo->DebugFlag |= DBG_VERBOSE_ON;\r\ncase 1:\r\nDbgInfo->DebugFlag |= DBG_DEFAULTS;\r\ndefault:\r\nbreak;\r\n}\r\n#endif /* DBG */\r\nDBG_ENTER( DbgInfo );\r\nprintk(KERN_INFO "%s\n", VERSION_INFO);\r\nprintk(KERN_INFO "*** Modified for kernel 2.6 by Henk de Groot <pe1dnn@amsat.org>\n");\r\nprintk(KERN_INFO "*** Based on 7.18 version by Andrey Borzenkov <arvidjaar@mail.ru> $Revision: 39 $\n");\r\n// ;?#if (HCF_TYPE) & HCF_TYPE_AP\r\n// DBG_PRINT( "Access Point Mode (AP) Support: YES\n" );\r\n// #else\r\n// DBG_PRINT( "Access Point Mode (AP) Support: NO\n" );\r\n// #endif /* (HCF_TYPE) & HCF_TYPE_AP */\r\nresult = wl_adapter_init_module( );\r\nDBG_LEAVE( DbgInfo );\r\nreturn result;\r\n} // init_module\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* cleanup_module()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Unload the kernel module.\r\n*\r\n* PARAMETERS:\r\n*\r\n* N/A\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nstatic void __exit wl_module_exit( void )\r\n{\r\nDBG_FUNC( "wl_module_exit" );\r\nDBG_ENTER(DbgInfo);\r\nwl_adapter_cleanup_module( );\r\n#if 0 //SCULL_USE_PROC /* don't waste space if unused */\r\nremove_proc_entry( "wlags", NULL ); //;?why so a-symmetric compared to location of create_proc_read_entry\r\n#endif\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n} // cleanup_module\r\n/*============================================================================*/\r\nmodule_init(wl_module_init);\r\nmodule_exit(wl_module_exit);\r\n/*******************************************************************************\r\n* wl_isr()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* The Interrupt Service Routine for the driver.\r\n*\r\n* PARAMETERS:\r\n*\r\n* irq - the irq the interrupt came in on\r\n* dev_id - a buffer containing information about the request\r\n* regs -\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nirqreturn_t wl_isr( int irq, void *dev_id, struct pt_regs *regs )\r\n{\r\nint events;\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct wl_private *lp = NULL;\r\n/*------------------------------------------------------------------------*/\r\nif (( dev == NULL ) || ( !netif_device_present( dev ))) {\r\nreturn IRQ_NONE;\r\n}\r\n/* Set the wl_private pointer (lp), now that we know that dev is non-null */\r\nlp = wl_priv(dev);\r\n#ifdef USE_RTS\r\nif ( lp->useRTS == 1 ) {\r\nDBG_PRINT( "EXITING ISR, IN RTS MODE...\n" );\r\nreturn;\r\n}\r\n#endif /* USE_RTS */\r\n/* If we have interrupts pending, then put them on a system task\r\nqueue. Otherwise turn interrupts back on */\r\nevents = hcf_action( &lp->hcfCtx, HCF_ACT_INT_OFF );\r\nif ( events == HCF_INT_PENDING ) {\r\n/* Schedule the ISR handler as a bottom-half task in the\r\ntq_immediate queue */\r\ntasklet_schedule(&lp->task);\r\n} else {\r\n//DBG_PRINT( "NOT OUR INTERRUPT\n" );\r\nhcf_action( &lp->hcfCtx, HCF_ACT_INT_ON );\r\n}\r\nreturn IRQ_RETVAL(events == HCF_INT_PENDING);\r\n} // wl_isr\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_isr_handler()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* The ISR handler, scheduled to run in a deferred context by the ISR. This\r\n* is where the ISR's work actually gets done.\r\n*\r\n* PARAMETERS:\r\n*\r\n* lp - a pointer to the device's private adapter structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\n#define WVLAN_MAX_INT_SERVICES 50\r\nvoid wl_isr_handler( unsigned long p )\r\n{\r\nstruct net_device *dev;\r\nunsigned long flags;\r\nbool_t stop = TRUE;\r\nint count;\r\nint result;\r\nstruct wl_private *lp = (struct wl_private *)p;\r\n/*------------------------------------------------------------------------*/\r\nif ( lp == NULL ) {\r\nDBG_PRINT( "wl_isr_handler lp adapter pointer is NULL!!!\n" );\r\n} else {\r\nwl_lock( lp, &flags );\r\ndev = (struct net_device *)lp->dev;\r\nif ( dev != NULL && netif_device_present( dev ) ) stop = FALSE;\r\nfor( count = 0; stop == FALSE && count < WVLAN_MAX_INT_SERVICES; count++ ) {\r\nstop = TRUE;\r\nresult = hcf_service_nic( &lp->hcfCtx,\r\n(wci_bufp)lp->lookAheadBuf,\r\nsizeof( lp->lookAheadBuf ));\r\nif ( result == HCF_ERR_MIC ) {\r\nwl_wext_event_mic_failed( dev ); /* Send an event that MIC failed */\r\n//;?this seems wrong if HCF_ERR_MIC coincides with another event, stop gets FALSE\r\n//so why not do it always ;?\r\n}\r\n#ifndef USE_MBOX_SYNC\r\nif ( lp->hcfCtx.IFB_MBInfoLen != 0 ) { /* anything in the mailbox */\r\nwl_mbx( lp );\r\nstop = FALSE;\r\n}\r\n#endif\r\n/* Check for a Link status event */\r\nif ( ( lp->hcfCtx.IFB_LinkStat & CFG_LINK_STAT_FW ) != 0 ) {\r\nwl_process_link_status( lp );\r\nstop = FALSE;\r\n}\r\n/* Check for probe response events */\r\nif ( lp->ProbeResp.infoType != 0 &&\r\nlp->ProbeResp.infoType != 0xFFFF ) {\r\nwl_process_probe_response( lp );\r\nmemset( &lp->ProbeResp, 0, sizeof( lp->ProbeResp ));\r\nlp->ProbeResp.infoType = 0xFFFF;\r\nstop = FALSE;\r\n}\r\n/* Check for updated record events */\r\nif ( lp->updatedRecord.len != 0xFFFF ) {\r\nwl_process_updated_record( lp );\r\nlp->updatedRecord.len = 0xFFFF;\r\nstop = FALSE;\r\n}\r\n/* Check for association status events */\r\nif ( lp->assoc_stat.len != 0xFFFF ) {\r\nwl_process_assoc_status( lp );\r\nlp->assoc_stat.len = 0xFFFF;\r\nstop = FALSE;\r\n}\r\n/* Check for security status events */\r\nif ( lp->sec_stat.len != 0xFFFF ) {\r\nwl_process_security_status( lp );\r\nlp->sec_stat.len = 0xFFFF;\r\nstop = FALSE;\r\n}\r\n#ifdef ENABLE_DMA\r\nif ( lp->use_dma ) {\r\n/* Check for DMA Rx packets */\r\nif ( lp->hcfCtx.IFB_DmaPackets & HREG_EV_RDMAD ) {\r\nwl_rx_dma( dev );\r\nstop = FALSE;\r\n}\r\n/* Return Tx DMA descriptors to host */\r\nif ( lp->hcfCtx.IFB_DmaPackets & HREG_EV_TDMAD ) {\r\nwl_pci_dma_hcf_reclaim_tx( lp );\r\nstop = FALSE;\r\n}\r\n}\r\nelse\r\n#endif // ENABLE_DMA\r\n{\r\n/* Check for Rx packets */\r\nif ( lp->hcfCtx.IFB_RxLen != 0 ) {\r\nwl_rx( dev );\r\nstop = FALSE;\r\n}\r\n/* Make sure that queued frames get sent */\r\nif ( wl_send( lp )) {\r\nstop = FALSE;\r\n}\r\n}\r\n}\r\n/* We're done, so turn interrupts which were turned off in wl_isr, back on */\r\nhcf_action( &lp->hcfCtx, HCF_ACT_INT_ON );\r\nwl_unlock( lp, &flags );\r\n}\r\nreturn;\r\n} // wl_isr_handler\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_remove()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Notify the adapter that it has been removed. Since the adapter is gone,\r\n* we should no longer try to talk to it.\r\n*\r\n* PARAMETERS:\r\n*\r\n* dev - a pointer to the device's net_device structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nvoid wl_remove( struct net_device *dev )\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_remove" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PARAM( DbgInfo, "dev", "%s (0x%p)", dev->name, dev );\r\nwl_lock( lp, &flags );\r\n/* stop handling interrupts */\r\nwl_act_int_off( lp );\r\nlp->is_handling_int = WL_NOT_HANDLING_INT;\r\n/*\r\n* Disable the ports: just change state: since the\r\n* card is gone it is useless to talk to it and at\r\n* disconnect all state information is lost anyway.\r\n*/\r\n/* Reset portState */\r\nlp->portState = WVLAN_PORT_STATE_DISABLED;\r\n#if 0 //;? (HCF_TYPE) & HCF_TYPE_AP\r\n#ifdef USE_WDS\r\n//wl_disable_wds_ports( lp );\r\n#endif // USE_WDS\r\n#endif /* (HCF_TYPE) & HCF_TYPE_AP */\r\n/* Mark the device as unregistered */\r\nlp->is_registered = FALSE;\r\n/* Deregister the WDS ports as well */\r\nWL_WDS_NETDEV_DEREGISTER( lp );\r\n#ifdef USE_RTS\r\nif ( lp->useRTS == 1 ) {\r\nwl_unlock( lp, &flags );\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif /* USE_RTS */\r\n/* Inform the HCF that the card has been removed */\r\nhcf_connect( &lp->hcfCtx, HCF_DISCONNECT );\r\nwl_unlock( lp, &flags );\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n} // wl_remove\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_suspend()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Power-down and halt the adapter.\r\n*\r\n* PARAMETERS:\r\n*\r\n* dev - a pointer to the device's net_device structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nvoid wl_suspend( struct net_device *dev )\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_suspend" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PARAM( DbgInfo, "dev", "%s (0x%p)", dev->name, dev );\r\n/* The adapter is suspended:\r\nStop the adapter\r\nPower down\r\n*/\r\nwl_lock( lp, &flags );\r\n/* Disable interrupt handling */\r\nwl_act_int_off( lp );\r\n/* Disconnect */\r\nwl_disconnect( lp );\r\n/* Disable */\r\nwl_disable( lp );\r\n/* Disconnect from the adapter */\r\nhcf_connect( &lp->hcfCtx, HCF_DISCONNECT );\r\n/* Reset portState to be sure (should have been done by wl_disable */\r\nlp->portState = WVLAN_PORT_STATE_DISABLED;\r\nwl_unlock( lp, &flags );\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n} // wl_suspend\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_resume()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Resume a previously suspended adapter.\r\n*\r\n* PARAMETERS:\r\n*\r\n* dev - a pointer to the device's net_device structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nvoid wl_resume(struct net_device *dev)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_resume" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PARAM( DbgInfo, "dev", "%s (0x%p)", dev->name, dev );\r\nwl_lock( lp, &flags );\r\n/* Connect to the adapter */\r\nhcf_connect( &lp->hcfCtx, dev->base_addr );\r\n/* Reset portState */\r\nlp->portState = WVLAN_PORT_STATE_DISABLED;\r\n/* Power might have been off, assume the card lost the firmware*/\r\nlp->firmware_present = WL_FRIMWARE_NOT_PRESENT;\r\n/* Reload the firmware and restart */\r\nwl_reset( dev );\r\n/* Resume interrupt handling */\r\nwl_act_int_on( lp );\r\nwl_unlock( lp, &flags );\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n} // wl_resume\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_release()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* This function perfroms a check on the device and calls wl_remove() if\r\n* necessary. This function can be used for all bus types, but exists mostly\r\n* for the benefit of the Card Services driver, as there are times when\r\n* wl_remove() does not get called.\r\n*\r\n* PARAMETERS:\r\n*\r\n* dev - a pointer to the device's net_device structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nvoid wl_release( struct net_device *dev )\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\n/*------------------------------------------------------------------------*/\r\nDBG_FUNC( "wl_release" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PARAM( DbgInfo, "dev", "%s (0x%p)", dev->name, dev );\r\n/* If wl_remove() hasn't been called (i.e. when Card Services is shut\r\ndown with the card in the slot), then call it */\r\nif ( lp->is_registered == TRUE ) {\r\nDBG_TRACE( DbgInfo, "Calling unregister_netdev(), as it wasn't called yet\n" );\r\nwl_remove( dev );\r\nlp->is_registered = FALSE;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n} // wl_release\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_get_irq_mask()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Accessor function to retrieve the irq_mask module parameter\r\n*\r\n* PARAMETERS:\r\n*\r\n* N/A\r\n*\r\n* RETURNS:\r\n*\r\n* The irq_mask module parameter\r\n*\r\n******************************************************************************/\r\np_u16 wl_get_irq_mask( void )\r\n{\r\nreturn irq_mask;\r\n} // wl_get_irq_mask\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_get_irq_list()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Accessor function to retrieve the irq_list module parameter\r\n*\r\n* PARAMETERS:\r\n*\r\n* N/A\r\n*\r\n* RETURNS:\r\n*\r\n* The irq_list module parameter\r\n*\r\n******************************************************************************/\r\np_s8 * wl_get_irq_list( void )\r\n{\r\nreturn irq_list;\r\n} // wl_get_irq_list\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_enable()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Used to enable MAC ports\r\n*\r\n* PARAMETERS:\r\n*\r\n* lp - pointer to the device's private adapter structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nint wl_enable( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nDBG_FUNC( "wl_enable" );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp->portState == WVLAN_PORT_STATE_ENABLED ) {\r\nDBG_TRACE( DbgInfo, "No action: Card already enabled\n" );\r\n} else if ( lp->portState == WVLAN_PORT_STATE_CONNECTED ) {\r\nDBG_TRACE( DbgInfo, "No action: Card already connected\n" );\r\n} else {\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_ENABLE );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_ENABLED;\r\n#ifdef ENABLE_DMA\r\nif ( lp->use_dma ) {\r\nwl_pci_dma_hcf_supply( lp );\r\n}\r\n#endif\r\n}\r\n}\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "failed: 0x%x\n", hcf_status );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\n#ifdef USE_WDS\r\nvoid wl_enable_wds_ports( struct wl_private * lp )\r\n{\r\nDBG_FUNC( "wl_enable_wds_ports" );\r\nDBG_ENTER( DbgInfo );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ){\r\nDBG_ERROR( DbgInfo, "!!!!;? someone misunderstood something !!!!!\n" );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif\r\nint wl_connect( struct wl_private *lp )\r\n{\r\nint hcf_status;\r\nDBG_FUNC( "wl_connect" );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp->portState != WVLAN_PORT_STATE_ENABLED ) {\r\nDBG_TRACE( DbgInfo, "No action: Not in enabled state\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn HCF_SUCCESS;\r\n}\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_CONNECT );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_CONNECTED;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nint wl_disconnect( struct wl_private *lp )\r\n{\r\nint hcf_status;\r\nDBG_FUNC( "wl_disconnect" );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp->portState != WVLAN_PORT_STATE_CONNECTED ) {\r\nDBG_TRACE( DbgInfo, "No action: Not in connected state\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn HCF_SUCCESS;\r\n}\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_DISCONNECT );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_ENABLED;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nint wl_disable( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nDBG_FUNC( "wl_disable" );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp->portState == WVLAN_PORT_STATE_DISABLED ) {\r\nDBG_TRACE( DbgInfo, "No action: Port state is disabled\n" );\r\n} else {\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_DISABLE );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_DISABLED;\r\n#ifdef ENABLE_DMA\r\nif ( lp->use_dma ) {\r\nwl_pci_dma_hcf_reclaim( lp );\r\n}\r\n#endif\r\n}\r\n}\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "failed: 0x%x\n", hcf_status );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\n#ifdef USE_WDS\r\nvoid wl_disable_wds_ports( struct wl_private * lp )\r\n{\r\nDBG_FUNC( "wl_disable_wds_ports" );\r\nDBG_ENTER( DbgInfo );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ){\r\nDBG_ERROR( DbgInfo, "!!!!;? someone misunderstood something !!!!!\n" );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif\r\n#ifndef USE_MBOX_SYNC\r\nint wl_mbx( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nDBG_FUNC( "wl_mbx" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_TRACE( DbgInfo, "Mailbox Info: IFB_MBInfoLen: %d\n",\r\nlp->hcfCtx.IFB_MBInfoLen );\r\nmemset( &( lp->ltvRecord ), 0, sizeof( ltv_t ));\r\nlp->ltvRecord.len = MB_SIZE;\r\nlp->ltvRecord.typ = CFG_MB_INFO;\r\nhcf_status = hcf_get_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, "hcf_get_info returned 0x%x\n", hcf_status );\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nif ( lp->ltvRecord.typ == CFG_MB_INFO ) {\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nwl_endian_translate_mailbox( &( lp->ltvRecord ));\r\nwl_process_mailbox( lp );\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nvoid wl_endian_translate_mailbox( ltv_t *ltv )\r\n{\r\nDBG_FUNC( "wl_endian_translate_mailbox" );\r\nDBG_ENTER( DbgInfo );\r\nswitch( ltv->typ ) {\r\ncase CFG_TALLIES:\r\nbreak;\r\ncase CFG_SCAN:\r\n{\r\nint num_aps;\r\nSCAN_RS_STRCT *aps = (SCAN_RS_STRCT *)&ltv->u.u8[0];\r\nnum_aps = (hcf_16)(( (size_t)(ltv->len - 1 ) * 2 ) /\r\n( sizeof( SCAN_RS_STRCT )));\r\nwhile( num_aps >= 1 ) {\r\nnum_aps--;\r\naps[num_aps].channel_id =\r\nCNV_LITTLE_TO_INT( aps[num_aps].channel_id );\r\naps[num_aps].noise_level =\r\nCNV_LITTLE_TO_INT( aps[num_aps].noise_level );\r\naps[num_aps].signal_level =\r\nCNV_LITTLE_TO_INT( aps[num_aps].signal_level );\r\naps[num_aps].beacon_interval_time =\r\nCNV_LITTLE_TO_INT( aps[num_aps].beacon_interval_time );\r\naps[num_aps].capability =\r\nCNV_LITTLE_TO_INT( aps[num_aps].capability );\r\naps[num_aps].ssid_len =\r\nCNV_LITTLE_TO_INT( aps[num_aps].ssid_len );\r\naps[num_aps].ssid_val[aps[num_aps].ssid_len] = 0;\r\n}\r\n}\r\nbreak;\r\ncase CFG_ACS_SCAN:\r\n{\r\nPROBE_RESP *probe_resp = (PROBE_RESP *)ltv;\r\nprobe_resp->frameControl = CNV_LITTLE_TO_INT( probe_resp->frameControl );\r\nprobe_resp->durID = CNV_LITTLE_TO_INT( probe_resp->durID );\r\nprobe_resp->sequence = CNV_LITTLE_TO_INT( probe_resp->sequence );\r\nprobe_resp->dataLength = CNV_LITTLE_TO_INT( probe_resp->dataLength );\r\n#ifndef WARP\r\nprobe_resp->lenType = CNV_LITTLE_TO_INT( probe_resp->lenType );\r\n#endif\r\nprobe_resp->beaconInterval = CNV_LITTLE_TO_INT( probe_resp->beaconInterval );\r\nprobe_resp->capability = CNV_LITTLE_TO_INT( probe_resp->capability );\r\nprobe_resp->flags = CNV_LITTLE_TO_INT( probe_resp->flags );\r\n}\r\nbreak;\r\ncase CFG_LINK_STAT:\r\n#define ls ((LINK_STATUS_STRCT *)ltv)\r\nls->linkStatus = CNV_LITTLE_TO_INT( ls->linkStatus );\r\nbreak;\r\n#undef ls\r\ncase CFG_ASSOC_STAT:\r\n{\r\nASSOC_STATUS_STRCT *as = (ASSOC_STATUS_STRCT *)ltv;\r\nas->assocStatus = CNV_LITTLE_TO_INT( as->assocStatus );\r\n}\r\nbreak;\r\ncase CFG_SECURITY_STAT:\r\n{\r\nSECURITY_STATUS_STRCT *ss = (SECURITY_STATUS_STRCT *)ltv;\r\nss->securityStatus = CNV_LITTLE_TO_INT( ss->securityStatus );\r\nss->reason = CNV_LITTLE_TO_INT( ss->reason );\r\n}\r\nbreak;\r\ncase CFG_WMP:\r\nbreak;\r\ncase CFG_NULL:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nvoid wl_process_mailbox( struct wl_private *lp )\r\n{\r\nltv_t *ltv;\r\nhcf_16 ltv_val = 0xFFFF;\r\nDBG_FUNC( "wl_process_mailbox" );\r\nDBG_ENTER( DbgInfo );\r\nltv = &( lp->ltvRecord );\r\nswitch( ltv->typ ) {\r\ncase CFG_TALLIES:\r\nDBG_TRACE( DbgInfo, "CFG_TALLIES\n" );\r\nbreak;\r\ncase CFG_SCAN:\r\nDBG_TRACE( DbgInfo, "CFG_SCAN\n" );\r\n{\r\nint num_aps;\r\nSCAN_RS_STRCT *aps = (SCAN_RS_STRCT *)&ltv->u.u8[0];\r\nnum_aps = (hcf_16)(( (size_t)(ltv->len - 1 ) * 2 ) /\r\n( sizeof( SCAN_RS_STRCT )));\r\nlp->scan_results.num_aps = num_aps;\r\nDBG_TRACE( DbgInfo, "Number of APs: %d\n", num_aps );\r\nwhile( num_aps >= 1 ) {\r\nnum_aps--;\r\nDBG_TRACE( DbgInfo, "AP : %d\n", num_aps );\r\nDBG_TRACE( DbgInfo, "=========================\n" );\r\nDBG_TRACE( DbgInfo, "Channel ID : 0x%04x\n",\r\naps[num_aps].channel_id );\r\nDBG_TRACE( DbgInfo, "Noise Level : 0x%04x\n",\r\naps[num_aps].noise_level );\r\nDBG_TRACE( DbgInfo, "Signal Level : 0x%04x\n",\r\naps[num_aps].signal_level );\r\nDBG_TRACE( DbgInfo, "Beacon Interval : 0x%04x\n",\r\naps[num_aps].beacon_interval_time );\r\nDBG_TRACE( DbgInfo, "Capability : 0x%04x\n",\r\naps[num_aps].capability );\r\nDBG_TRACE( DbgInfo, "SSID Length : 0x%04x\n",\r\naps[num_aps].ssid_len );\r\nDBG_TRACE(DbgInfo, "BSSID : %pM\n",\r\naps[num_aps].bssid);\r\nif ( aps[num_aps].ssid_len != 0 ) {\r\nDBG_TRACE( DbgInfo, "SSID : %s.\n",\r\naps[num_aps].ssid_val );\r\n} else {\r\nDBG_TRACE( DbgInfo, "SSID : %s.\n", "ANY" );\r\n}\r\nDBG_TRACE( DbgInfo, "\n" );\r\nmemcpy( &( lp->scan_results.APTable[num_aps]), &( aps[num_aps] ),\r\nsizeof( SCAN_RS_STRCT ));\r\n}\r\nlp->scan_results.scan_complete = TRUE;\r\n}\r\nbreak;\r\ncase CFG_ACS_SCAN:\r\nDBG_TRACE( DbgInfo, "CFG_ACS_SCAN\n" );\r\n{\r\nPROBE_RESP *probe_rsp = (PROBE_RESP *)ltv;\r\nhcf_8 *wpa_ie = NULL;\r\nhcf_16 wpa_ie_len = 0;\r\nDBG_TRACE( DbgInfo, "(%s) =========================\n",\r\nlp->dev->name );\r\nDBG_TRACE( DbgInfo, "(%s) length : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->length );\r\nif ( probe_rsp->length > 1 ) {\r\nDBG_TRACE( DbgInfo, "(%s) infoType : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->infoType );\r\nDBG_TRACE( DbgInfo, "(%s) signal : 0x%02x.\n",\r\nlp->dev->name, probe_rsp->signal );\r\nDBG_TRACE( DbgInfo, "(%s) silence : 0x%02x.\n",\r\nlp->dev->name, probe_rsp->silence );\r\nDBG_TRACE( DbgInfo, "(%s) rxFlow : 0x%02x.\n",\r\nlp->dev->name, probe_rsp->rxFlow );\r\nDBG_TRACE( DbgInfo, "(%s) rate : 0x%02x.\n",\r\nlp->dev->name, probe_rsp->rate );\r\nDBG_TRACE( DbgInfo, "(%s) frame cntl : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->frameControl );\r\nDBG_TRACE( DbgInfo, "(%s) durID : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->durID );\r\nDBG_TRACE(DbgInfo, "(%s) address1 : %pM\n",\r\nlp->dev->name, probe_rsp->address1);\r\nDBG_TRACE(DbgInfo, "(%s) address2 : %pM\n",\r\nlp->dev->name, probe_rsp->address2);\r\nDBG_TRACE(DbgInfo, "(%s) BSSID : %pM\n",\r\nlp->dev->name, probe_rsp->BSSID);\r\nDBG_TRACE( DbgInfo, "(%s) sequence : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->sequence );\r\nDBG_TRACE(DbgInfo, "(%s) address4 : %pM\n",\r\nlp->dev->name, probe_rsp->address4);\r\nDBG_TRACE( DbgInfo, "(%s) datalength : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->dataLength );\r\nDBG_TRACE(DbgInfo, "(%s) DA : %pM\n",\r\nlp->dev->name, probe_rsp->DA);\r\nDBG_TRACE(DbgInfo, "(%s) SA : %pM\n",\r\nlp->dev->name, probe_rsp->SA);\r\nDBG_TRACE(DbgInfo, "(%s) timeStamp : "\r\n"%d.%d.%d.%d.%d.%d.%d.%d\n",\r\nlp->dev->name,\r\nprobe_rsp->timeStamp[0],\r\nprobe_rsp->timeStamp[1],\r\nprobe_rsp->timeStamp[2],\r\nprobe_rsp->timeStamp[3],\r\nprobe_rsp->timeStamp[4],\r\nprobe_rsp->timeStamp[5],\r\nprobe_rsp->timeStamp[6],\r\nprobe_rsp->timeStamp[7]);\r\nDBG_TRACE( DbgInfo, "(%s) beaconInt : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->beaconInterval );\r\nDBG_TRACE( DbgInfo, "(%s) capability : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->capability );\r\nDBG_TRACE( DbgInfo, "(%s) SSID len : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->rawData[1] );\r\nif ( probe_rsp->rawData[1] > 0 ) {\r\nchar ssid[HCF_MAX_NAME_LEN];\r\nmemset( ssid, 0, sizeof( ssid ));\r\nstrncpy( ssid, &probe_rsp->rawData[2],\r\nprobe_rsp->rawData[1] );\r\nDBG_TRACE( DbgInfo, "(%s) SSID : %s\n",\r\nlp->dev->name, ssid );\r\n}\r\nwpa_ie = wl_parse_wpa_ie( probe_rsp, &wpa_ie_len );\r\nif ( wpa_ie != NULL ) {\r\nDBG_TRACE( DbgInfo, "(%s) WPA-IE : %s\n",\r\nlp->dev->name, wl_print_wpa_ie( wpa_ie, wpa_ie_len ));\r\n}\r\nDBG_TRACE( DbgInfo, "(%s) flags : 0x%04x.\n",\r\nlp->dev->name, probe_rsp->flags );\r\n}\r\nDBG_TRACE( DbgInfo, "\n\n" );\r\nif ( probe_rsp->length == 1 ) {\r\nDBG_TRACE( DbgInfo, "SCAN COMPLETE\n" );\r\nlp->probe_results.num_aps = lp->probe_num_aps;\r\nlp->probe_results.scan_complete = TRUE;\r\nlp->probe_num_aps = 0;\r\nwl_wext_event_scan_complete( lp->dev );\r\n} else {\r\nif ( lp->probe_num_aps == 0 ) {\r\nmemcpy( &( lp->probe_results.ProbeTable[lp->probe_num_aps] ),\r\nprobe_rsp, sizeof( PROBE_RESP ));\r\nlp->probe_num_aps++;\r\n} else {\r\nint count;\r\nint unique = 1;\r\nfor( count = 0; count < lp->probe_num_aps; count++ ) {\r\nif ( memcmp( &( probe_rsp->BSSID ),\r\nlp->probe_results.ProbeTable[count].BSSID,\r\nETH_ALEN ) == 0 ) {\r\nunique = 0;\r\n}\r\n}\r\nif ( unique ) {\r\nif ( lp->probe_num_aps < MAX_NAPS )\r\n{\r\nmemcpy( &( lp->probe_results.ProbeTable[lp->probe_num_aps] ),\r\nprobe_rsp, sizeof( PROBE_RESP ));\r\n}\r\nelse\r\n{\r\nDBG_WARNING( DbgInfo, "Num of scan results exceeds storage, truncating\n" );\r\n}\r\nlp->probe_num_aps++;\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CFG_LINK_STAT:\r\n#define ls ((LINK_STATUS_STRCT *)ltv)\r\nDBG_TRACE( DbgInfo, "CFG_LINK_STAT\n" );\r\nswitch( ls->linkStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, "Link Status : Connected\n" );\r\nwl_wext_event_ap( lp->dev );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, "Link Status : Disconnected\n" );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, "Link Status : Access Point Change\n" );\r\nbreak;\r\ncase 4:\r\nDBG_TRACE( DbgInfo, "Link Status : Access Point Out of Range\n" );\r\nbreak;\r\ncase 5:\r\nDBG_TRACE( DbgInfo, "Link Status : Access Point In Range\n" );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, "Link Status : UNKNOWN (0x%04x)\n",\r\nls->linkStatus );\r\nbreak;\r\n}\r\nbreak;\r\n#undef ls\r\ncase CFG_ASSOC_STAT:\r\nDBG_TRACE( DbgInfo, "CFG_ASSOC_STAT\n" );\r\n{\r\nASSOC_STATUS_STRCT *as = (ASSOC_STATUS_STRCT *)ltv;\r\nswitch( as->assocStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, "Association Status : STA Associated\n" );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, "Association Status : STA Reassociated\n" );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, "Association Status : STA Disassociated\n" );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, "Association Status : UNKNOWN (0x%04x)\n",\r\nas->assocStatus );\r\nbreak;\r\n}\r\nDBG_TRACE(DbgInfo, "STA Address : %pM\n",\r\nas->staAddr);\r\nif (( as->assocStatus == 2 ) && ( as->len == 8 )) {\r\nDBG_TRACE(DbgInfo, "Old AP Address : %pM\n",\r\nas->oldApAddr);\r\n}\r\n}\r\nbreak;\r\ncase CFG_SECURITY_STAT:\r\nDBG_TRACE( DbgInfo, "CFG_SECURITY_STAT\n" );\r\n{\r\nSECURITY_STATUS_STRCT *ss = (SECURITY_STATUS_STRCT *)ltv;\r\nswitch( ss->securityStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, "Security Status : Dissassociate [AP]\n" );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, "Security Status : Deauthenticate [AP]\n" );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, "Security Status : Authenticate Fail [STA] or [AP]\n" );\r\nbreak;\r\ncase 4:\r\nDBG_TRACE( DbgInfo, "Security Status : MIC Fail\n" );\r\nbreak;\r\ncase 5:\r\nDBG_TRACE( DbgInfo, "Security Status : Associate Fail\n" );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, "Security Status : UNKNOWN %d\n",\r\nss->securityStatus );\r\nbreak;\r\n}\r\nDBG_TRACE(DbgInfo, "STA Address : %pM\n",\r\nss->staAddr);\r\nDBG_TRACE(DbgInfo, "Reason : 0x%04x\n",\r\nss->reason);\r\n}\r\nbreak;\r\ncase CFG_WMP:\r\nDBG_TRACE( DbgInfo, "CFG_WMP, size is %d bytes\n", ltv->len );\r\n{\r\nWMP_RSP_STRCT *wmp_rsp = (WMP_RSP_STRCT *)ltv;\r\nDBG_TRACE( DbgInfo, "CFG_WMP, pdu type is 0x%x\n",\r\nwmp_rsp->wmpRsp.wmpHdr.type );\r\nswitch( wmp_rsp->wmpRsp.wmpHdr.type ) {\r\ncase WVLAN_WMP_PDU_TYPE_LT_RSP:\r\n{\r\n#if DBG\r\nLINKTEST_RSP_STRCT *lt_rsp = (LINKTEST_RSP_STRCT *)ltv;\r\n#endif\r\nDBG_TRACE( DbgInfo, "LINK TEST RESULT\n" );\r\nDBG_TRACE( DbgInfo, "================\n" );\r\nDBG_TRACE( DbgInfo, "Length : %d.\n", lt_rsp->len );\r\nDBG_TRACE( DbgInfo, "Name : %s.\n", lt_rsp->ltRsp.ltRsp.name );\r\nDBG_TRACE( DbgInfo, "Signal Level : 0x%02x.\n", lt_rsp->ltRsp.ltRsp.signal );\r\nDBG_TRACE( DbgInfo, "Noise Level : 0x%02x.\n", lt_rsp->ltRsp.ltRsp.noise );\r\nDBG_TRACE( DbgInfo, "Receive Flow : 0x%02x.\n", lt_rsp->ltRsp.ltRsp.rxFlow );\r\nDBG_TRACE( DbgInfo, "Data Rate : 0x%02x.\n", lt_rsp->ltRsp.ltRsp.dataRate );\r\nDBG_TRACE( DbgInfo, "Protocol : 0x%04x.\n", lt_rsp->ltRsp.ltRsp.protocol );\r\nDBG_TRACE( DbgInfo, "Station : 0x%02x.\n", lt_rsp->ltRsp.ltRsp.station );\r\nDBG_TRACE( DbgInfo, "Data Rate Cap : 0x%02x.\n", lt_rsp->ltRsp.ltRsp.dataRateCap );\r\nDBG_TRACE( DbgInfo, "Power Mgmt : 0x%02x 0x%02x 0x%02x 0x%02x.\n",\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[0],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[1],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[2],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[3] );\r\nDBG_TRACE( DbgInfo, "Robustness : 0x%02x 0x%02x 0x%02x 0x%02x.\n",\r\nlt_rsp->ltRsp.ltRsp.robustness[0],\r\nlt_rsp->ltRsp.ltRsp.robustness[1],\r\nlt_rsp->ltRsp.ltRsp.robustness[2],\r\nlt_rsp->ltRsp.ltRsp.robustness[3] );\r\nDBG_TRACE( DbgInfo, "Scaling : 0x%02x.\n", lt_rsp->ltRsp.ltRsp.scaling );\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase CFG_NULL:\r\nDBG_TRACE( DbgInfo, "CFG_NULL\n" );\r\nbreak;\r\ncase CFG_UPDATED_INFO_RECORD:\r\nDBG_TRACE( DbgInfo, "UPDATED INFORMATION RECORD\n" );\r\nltv_val = CNV_INT_TO_LITTLE( ltv->u.u16[0] );\r\nswitch( ltv_val ) {\r\ncase CFG_CUR_COUNTRY_INFO:\r\nDBG_TRACE( DbgInfo, "Updated country info\n" );\r\nwl_connect( lp );\r\nbreak;\r\ncase CFG_PORT_STAT:\r\nbreak;\r\ndefault:\r\nDBG_WARNING( DbgInfo, "Unknown RID: 0x%04x\n", ltv_val );\r\n}\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, "UNKNOWN MESSAGE: 0x%04x\n", ltv->typ );\r\nbreak;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif\r\n#ifdef USE_WDS\r\nvoid wl_wds_netdev_register( struct wl_private *lp )\r\n{\r\nint count;\r\nDBG_FUNC( "wl_wds_netdev_register" );\r\nDBG_ENTER( DbgInfo );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nfor( count = 0; count < NUM_WDS_PORTS; count++ ) {\r\nif ( WVLAN_VALID_MAC_ADDRESS( lp->wds_port[count].wdsAddress )) {\r\nif ( register_netdev( lp->wds_port[count].dev ) != 0 ) {\r\nDBG_WARNING( DbgInfo, "net device for WDS port %d could not be registered\n",\r\n( count + 1 ));\r\n}\r\nlp->wds_port[count].is_registered = TRUE;\r\nmemcpy( lp->wds_port[count].dev->dev_addr, lp->MACAddress, ETH_ALEN );\r\nlp->wds_port[count].dev->addr_len = ETH_ALEN;\r\n}\r\n}\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nvoid wl_wds_netdev_deregister( struct wl_private *lp )\r\n{\r\nint count;\r\nDBG_FUNC( "wl_wds_netdev_deregister" );\r\nDBG_ENTER( DbgInfo );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nfor( count = 0; count < NUM_WDS_PORTS; count++ ) {\r\nif ( WVLAN_VALID_MAC_ADDRESS( lp->wds_port[count].wdsAddress )) {\r\nunregister_netdev( lp->wds_port[count].dev );\r\n}\r\nlp->wds_port[count].is_registered = FALSE;\r\n}\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif\r\n#if 0\r\nint printf_hcf_16( char *s, char *buf, hcf_16* p, int n );\r\nint printf_hcf_16( char *s, char *buf, hcf_16* p, int n ) {\r\nint i, len;\r\nlen = sprintf(buf, "%s", s );\r\nwhile ( len < 20 ) len += sprintf(buf+len, " " );\r\nlen += sprintf(buf+len,": " );\r\nfor ( i = 0; i < n; i++ ) {\r\nif ( len % 80 > 75 ) {\r\nlen += sprintf(buf+len,"\n" );\r\n}\r\nlen += sprintf(buf+len,"%04X ", p[i] );\r\n}\r\nlen += sprintf(buf+len,"\n" );\r\nreturn len;\r\n}\r\nint printf_hcf_8( char *s, char *buf, hcf_8* p, int n );\r\nint printf_hcf_8( char *s, char *buf, hcf_8* p, int n ) {\r\nint i, len;\r\nlen = sprintf(buf, "%s", s );\r\nwhile ( len < 20 ) len += sprintf(buf+len, " " );\r\nlen += sprintf(buf+len,": " );\r\nfor ( i = 0; i <= n; i++ ) {\r\nif ( len % 80 > 77 ) {\r\nlen += sprintf(buf+len,"\n" );\r\n}\r\nlen += sprintf(buf+len,"%02X ", p[i] );\r\n}\r\nlen += sprintf(buf+len,"\n" );\r\nreturn len;\r\n}\r\nint printf_strct( char *s, char *buf, hcf_16* p );\r\nint printf_strct( char *s, char *buf, hcf_16* p ) {\r\nint i, len;\r\nlen = sprintf(buf, "%s", s );\r\nwhile ( len < 20 ) len += sprintf(buf+len, " " );\r\nlen += sprintf(buf+len,": " );\r\nfor ( i = 0; i <= *p; i++ ) {\r\nif ( len % 80 > 75 ) {\r\nlen += sprintf(buf+len,"\n" );\r\n}\r\nlen += sprintf(buf+len,"%04X ", p[i] );\r\n}\r\nlen += sprintf(buf+len,"\n" );\r\nreturn len;\r\n}\r\nint scull_read_procmem(char *buf, char **start, off_t offset, int len, int *eof, void *data )\r\n{\r\nstruct wl_private *lp = NULL;\r\nIFBP ifbp;\r\nCFG_HERMES_TALLIES_STRCT *p;\r\n#define LIMIT (PAGE_SIZE-80)\r\nlen=0;\r\nlp = ((struct net_device *)data)->priv;\r\nif (lp == NULL) {\r\nlen += sprintf(buf+len,"No wl_private in scull_read_procmem\n" );\r\n} else if ( lp->wlags49_type == 0 ){\r\nifbp = &lp->hcfCtx;\r\nlen += sprintf(buf+len,"Magic: 0x%04X\n", ifbp->IFB_Magic );\r\nlen += sprintf(buf+len,"IOBase: 0x%04X\n", ifbp->IFB_IOBase );\r\nlen += sprintf(buf+len,"LinkStat: 0x%04X\n", ifbp->IFB_LinkStat );\r\nlen += sprintf(buf+len,"DSLinkStat: 0x%04X\n", ifbp->IFB_DSLinkStat );\r\nlen += sprintf(buf+len,"TickIni: 0x%08lX\n", ifbp->IFB_TickIni );\r\nlen += sprintf(buf+len,"TickCnt: 0x%04X\n", ifbp->IFB_TickCnt );\r\nlen += sprintf(buf+len,"IntOffCnt: 0x%04X\n", ifbp->IFB_IntOffCnt );\r\nlen += printf_hcf_16( "IFB_FWIdentity", &buf[len],\r\n&ifbp->IFB_FWIdentity.len, ifbp->IFB_FWIdentity.len + 1 );\r\n} else if ( lp->wlags49_type == 1 ) {\r\nlen += sprintf(buf+len,"Channel: 0x%04X\n", lp->Channel );\r\n#ifdef WIRELESS_EXT\r\n#endif\r\nlen += sprintf(buf+len,"IFB: 0x%p\n", &lp->hcfCtx );\r\nlen += sprintf(buf+len,"flags: %#.8lX\n", lp->flags );\r\nlen += sprintf(buf+len,"DebugFlag(wl_private) 0x%04X\n", lp->DebugFlag );\r\n#if DBG\r\nlen += sprintf(buf+len,"DebugFlag (DbgInfo): 0x%08lX\n", DbgInfo->DebugFlag );\r\n#endif\r\nlen += sprintf(buf+len,"is_registered: 0x%04X\n", lp->is_registered );\r\nlen += printf_strct( "driverInfo", &buf[len], (hcf_16*)&lp->driverInfo );\r\nlen += printf_strct( "driverIdentity", &buf[len], (hcf_16*)&lp->driverIdentity );\r\nlen += printf_strct( "StationIdentity", &buf[len], (hcf_16*)&lp->StationIdentity );\r\nlen += printf_strct( "PrimaryIdentity", &buf[len], (hcf_16*)&lp->hcfCtx.IFB_PRIIdentity );\r\nlen += printf_strct( "PrimarySupplier", &buf[len], (hcf_16*)&lp->hcfCtx.IFB_PRISup );\r\nlen += printf_strct( "NICIdentity", &buf[len], (hcf_16*)&lp->NICIdentity );\r\nlen += sprintf(buf+len,"txBytes: 0x%08lX\n", lp->txBytes );\r\nlen += sprintf(buf+len,"maxPort: 0x%04X\n", lp->maxPort );\r\nlen += sprintf(buf+len,"PortType: 0x%04X\n", lp->PortType );\r\nlen += sprintf(buf+len,"Channel: 0x%04X\n", lp->Channel );\r\nlen += sprintf(buf+len,"TxRateControl[2]: 0x%04X 0x%04X\n",\r\nlp->TxRateControl[0], lp->TxRateControl[1] );\r\nlen += sprintf(buf+len,"DistanceBetweenAPs: 0x%04X\n", lp->DistanceBetweenAPs );\r\nlen += sprintf(buf+len,"RTSThreshold: 0x%04X\n", lp->RTSThreshold );\r\nlen += sprintf(buf+len,"PMEnabled: 0x%04X\n", lp->PMEnabled );\r\nlen += sprintf(buf+len,"MicrowaveRobustness: 0x%04X\n", lp->MicrowaveRobustness );\r\nlen += sprintf(buf+len,"CreateIBSS: 0x%04X\n", lp->CreateIBSS );\r\nlen += sprintf(buf+len,"MulticastReceive: 0x%04X\n", lp->MulticastReceive );\r\nlen += sprintf(buf+len,"MaxSleepDuration: 0x%04X\n", lp->MaxSleepDuration );\r\nlen += printf_hcf_8( "MACAddress", &buf[len], lp->MACAddress, ETH_ALEN );\r\nlen += sprintf(buf+len,"NetworkName: %.32s\n", lp->NetworkName );\r\nlen += sprintf(buf+len,"EnableEncryption: 0x%04X\n", lp->EnableEncryption );\r\nlen += printf_hcf_8( "Key1", &buf[len], lp->Key1, MAX_KEY_LEN );\r\nlen += sprintf(buf+len,"TransmitKeyID: 0x%04X\n", lp->TransmitKeyID );\r\nlen += sprintf(buf+len,"driverEnable: 0x%04X\n", lp->driverEnable );\r\nlen += sprintf(buf+len,"wolasEnable: 0x%04X\n", lp->wolasEnable );\r\nlen += sprintf(buf+len,"atimWindow: 0x%04X\n", lp->atimWindow );\r\nlen += sprintf(buf+len,"holdoverDuration: 0x%04X\n", lp->holdoverDuration );\r\nlen += sprintf(buf+len,"authentication: 0x%04X\n", lp->authentication );\r\nlen += sprintf(buf+len,"promiscuousMode: 0x%04X\n", lp->promiscuousMode );\r\nlen += sprintf(buf+len,"DownloadFirmware: 0x%04X\n", lp->DownloadFirmware );\r\nlen += sprintf(buf+len,"AuthKeyMgmtSuite: 0x%04X\n", lp->AuthKeyMgmtSuite );\r\nlen += sprintf(buf+len,"loadBalancing: 0x%04X\n", lp->loadBalancing );\r\nlen += sprintf(buf+len,"mediumDistribution: 0x%04X\n", lp->mediumDistribution );\r\nlen += sprintf(buf+len,"txPowLevel: 0x%04X\n", lp->txPowLevel );\r\nlen += sprintf(buf+len,"connectionControl: 0x%04X\n", lp->connectionControl );\r\nlen += sprintf(buf+len,"ownBeaconInterval: 0x%04X\n", lp->ownBeaconInterval );\r\nlen += sprintf(buf+len,"coexistence: 0x%04X\n", lp->coexistence );\r\nlen += sprintf(buf+len,"netif_queue_on: 0x%04X\n", lp->netif_queue_on );\r\nlen += sprintf(buf+len,"txQ_count: 0x%04X\n", lp->txQ_count );\r\nlen += sprintf(buf+len,"probe_num_aps: 0x%04X\n", lp->probe_num_aps );\r\nlen += sprintf(buf+len,"use_dma: 0x%04X\n", lp->use_dma );\r\n#ifdef USE_RTS\r\nlen += sprintf(buf+len,"useRTS: 0x%04X\n", lp->useRTS );\r\n#endif\r\n#if 1\r\nlen += sprintf(buf+len,"DTIMPeriod: 0x%04X\n", lp->DTIMPeriod );\r\nlen += sprintf(buf+len,"multicastPMBuffering: 0x%04X\n", lp->multicastPMBuffering );\r\nlen += sprintf(buf+len,"RejectAny: 0x%04X\n", lp->RejectAny );\r\nlen += sprintf(buf+len,"ExcludeUnencrypted: 0x%04X\n", lp->ExcludeUnencrypted );\r\nlen += sprintf(buf+len,"intraBSSRelay: 0x%04X\n", lp->intraBSSRelay );\r\nlen += sprintf(buf+len,"wlags49_type: 0x%08lX\n", lp->wlags49_type );\r\n#ifdef USE_WDS\r\n#endif\r\n#endif\r\n} else if ( lp->wlags49_type == 2 ){\r\nlen += sprintf(buf+len,"tallies to be added\n" );\r\np = &lp->hcfCtx.IFB_NIC_Tallies;\r\nlen += sprintf(buf+len,"TxUnicastFrames: %08lX\n", p->TxUnicastFrames );\r\nlen += sprintf(buf+len,"TxMulticastFrames: %08lX\n", p->TxMulticastFrames );\r\nlen += sprintf(buf+len,"TxFragments: %08lX\n", p->TxFragments );\r\nlen += sprintf(buf+len,"TxUnicastOctets: %08lX\n", p->TxUnicastOctets );\r\nlen += sprintf(buf+len,"TxMulticastOctets: %08lX\n", p->TxMulticastOctets );\r\nlen += sprintf(buf+len,"TxDeferredTransmissions: %08lX\n", p->TxDeferredTransmissions );\r\nlen += sprintf(buf+len,"TxSingleRetryFrames: %08lX\n", p->TxSingleRetryFrames );\r\nlen += sprintf(buf+len,"TxMultipleRetryFrames: %08lX\n", p->TxMultipleRetryFrames );\r\nlen += sprintf(buf+len,"TxRetryLimitExceeded: %08lX\n", p->TxRetryLimitExceeded );\r\nlen += sprintf(buf+len,"TxDiscards: %08lX\n", p->TxDiscards );\r\nlen += sprintf(buf+len,"RxUnicastFrames: %08lX\n", p->RxUnicastFrames );\r\nlen += sprintf(buf+len,"RxMulticastFrames: %08lX\n", p->RxMulticastFrames );\r\nlen += sprintf(buf+len,"RxFragments: %08lX\n", p->RxFragments );\r\nlen += sprintf(buf+len,"RxUnicastOctets: %08lX\n", p->RxUnicastOctets );\r\nlen += sprintf(buf+len,"RxMulticastOctets: %08lX\n", p->RxMulticastOctets );\r\nlen += sprintf(buf+len,"RxFCSErrors: %08lX\n", p->RxFCSErrors );\r\nlen += sprintf(buf+len,"RxDiscardsNoBuffer: %08lX\n", p->RxDiscardsNoBuffer );\r\nlen += sprintf(buf+len,"TxDiscardsWrongSA: %08lX\n", p->TxDiscardsWrongSA );\r\nlen += sprintf(buf+len,"RxWEPUndecryptable: %08lX\n", p->RxWEPUndecryptable );\r\nlen += sprintf(buf+len,"RxMsgInMsgFragments: %08lX\n", p->RxMsgInMsgFragments );\r\nlen += sprintf(buf+len,"RxMsgInBadMsgFragments: %08lX\n", p->RxMsgInBadMsgFragments );\r\nlen += sprintf(buf+len,"RxDiscardsWEPICVError: %08lX\n", p->RxDiscardsWEPICVError );\r\nlen += sprintf(buf+len,"RxDiscardsWEPExcluded: %08lX\n", p->RxDiscardsWEPExcluded );\r\n#if (HCF_EXT) & HCF_EXT_TALLIES_FW\r\n#endif\r\n} else if ( lp->wlags49_type & 0x8000 ) {\r\n#if DBG\r\nDbgInfo->DebugFlag = lp->wlags49_type & 0x7FFF;\r\n#endif\r\nlp->wlags49_type = 0;\r\n} else {\r\nlen += sprintf(buf+len,"unknown value for wlags49_type: 0x%08lX\n", lp->wlags49_type );\r\nlen += sprintf(buf+len,"0x0000 - IFB\n" );\r\nlen += sprintf(buf+len,"0x0001 - wl_private\n" );\r\nlen += sprintf(buf+len,"0x0002 - Tallies\n" );\r\nlen += sprintf(buf+len,"0x8xxx - Change debufflag\n" );\r\nlen += sprintf(buf+len,"ERROR 0001\nWARNING 0002\nNOTICE 0004\nTRACE 0008\n" );\r\nlen += sprintf(buf+len,"VERBOSE 0010\nPARAM 0020\nBREAK 0040\nRX 0100\n" );\r\nlen += sprintf(buf+len,"TX 0200\nDS 0400\n" );\r\n}\r\nreturn len;\r\n}\r\nstatic void proc_write(const char *name, write_proc_t *w, void *data)\r\n{\r\nstruct proc_dir_entry * entry = create_proc_entry(name, S_IFREG | S_IWUSR, NULL);\r\nif (entry) {\r\nentry->write_proc = w;\r\nentry->data = data;\r\n}\r\n}\r\nstatic int write_int(struct file *file, const char *buffer, unsigned long count, void *data)\r\n{\r\nstatic char proc_number[11];\r\nunsigned int nr = 0;\r\nDBG_FUNC( "write_int" );\r\nDBG_ENTER( DbgInfo );\r\nif (count > 9) {\r\ncount = -EINVAL;\r\n} else if ( copy_from_user(proc_number, buffer, count) ) {\r\ncount = -EFAULT;\r\n}\r\nif (count > 0 ) {\r\nproc_number[count] = 0;\r\nnr = simple_strtoul(proc_number , NULL, 0);\r\n*(unsigned int *)data = nr;\r\nif ( nr & 0x8000 ) {\r\n#if DBG\r\nDbgInfo->DebugFlag = nr & 0x7FFF;\r\n#endif\r\n}\r\n}\r\nDBG_PRINT( "value: %08X\n", nr );\r\nDBG_LEAVE( DbgInfo );\r\nreturn count;\r\n}\r\n#endif\r\n#ifdef DN554\r\n#define RUN_AT(x) (jiffies+(x))\r\n#define DS_OOR 0x8000\r\nlp->timer_oor_cnt = DS_OOR;\r\ninit_timer( &lp->timer_oor );\r\nlp->timer_oor.function = timer_oor;\r\nlp->timer_oor.data = (unsigned long)lp;\r\nlp->timer_oor.expires = RUN_AT( 3 * HZ );\r\nadd_timer( &lp->timer_oor );\r\nprintk( "<5>wl_enable: %ld\n", jiffies );\r\n#endif\r\n#ifdef DN554\r\nvoid timer_oor( u_long arg )\r\n{\r\nstruct wl_private *lp = (struct wl_private *)arg;\r\nDBG_FUNC( "timer_oor" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PARAM( DbgInfo, "arg", "0x%08lx", arg );\r\nprintk( "<5>timer_oor: %ld 0x%04X\n", jiffies, lp->timer_oor_cnt );\r\nlp->timer_oor_cnt += 10;\r\nif ( (lp->timer_oor_cnt & ~DS_OOR) > 300 ) {\r\nlp->timer_oor_cnt = 300;\r\n}\r\nlp->timer_oor_cnt |= DS_OOR;\r\ninit_timer( &lp->timer_oor );\r\nlp->timer_oor.function = timer_oor;\r\nlp->timer_oor.data = (unsigned long)lp;\r\nlp->timer_oor.expires = RUN_AT( (lp->timer_oor_cnt & ~DS_OOR) * HZ );\r\nadd_timer( &lp->timer_oor );\r\nDBG_LEAVE( DbgInfo );\r\n}\r\n#endif\r\nMODULE_LICENSE("Dual BSD/GPL");
