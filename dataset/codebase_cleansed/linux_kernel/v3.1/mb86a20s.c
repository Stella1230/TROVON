static int mb86a20s_i2c_writereg(struct mb86a20s_state *state,\r\nu8 i2c_addr, int reg, int data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = i2c_addr, .flags = 0, .buf = buf, .len = 2\r\n};\r\nint rc;\r\nrc = i2c_transfer(state->i2c, &msg, 1);\r\nif (rc != 1) {\r\nprintk("%s: writereg error (rc == %i, reg == 0x%02x,"\r\n" data == 0x%02x)\n", __func__, rc, reg, data);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_i2c_writeregdata(struct mb86a20s_state *state,\r\nu8 i2c_addr, struct regdata *rd, int size)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < size; i++) {\r\nrc = mb86a20s_i2c_writereg(state, i2c_addr, rd[i].reg,\r\nrd[i].data);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_i2c_readreg(struct mb86a20s_state *state,\r\nu8 i2c_addr, u8 reg)\r\n{\r\nu8 val;\r\nint rc;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = i2c_addr, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = i2c_addr, .flags = I2C_M_RD, .buf = &val, .len = 1 }\r\n};\r\nrc = i2c_transfer(state->i2c, msg, 2);\r\nif (rc != 2) {\r\nrc("%s: reg=0x%x (error=%d)\n", __func__, reg, rc);\r\nreturn rc;\r\n}\r\nreturn val;\r\n}\r\nstatic int mb86a20s_initfe(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint rc;\r\nu8 regD5 = 1;\r\ndprintk("\n");\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrc = mb86a20s_writeregdata(state, mb86a20s_init);\r\nif (rc < 0)\r\ngoto err;\r\nif (!state->config->is_serial) {\r\nregD5 &= ~1;\r\nrc = mb86a20s_writereg(state, 0x50, 0xd5);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x51, regD5);\r\nif (rc < 0)\r\ngoto err;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nerr:\r\nif (rc < 0) {\r\nstate->need_init = true;\r\nprintk(KERN_INFO "mb86a20s: Init failed. Will try again later\n");\r\n} else {\r\nstate->need_init = false;\r\ndprintk("Initialization succeeded.\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nunsigned rf_max, rf_min, rf;\r\nu8 val;\r\ndprintk("\n");\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrf_max = 0xfff;\r\nrf_min = 0;\r\ndo {\r\nrf = (rf_max + rf_min) / 2;\r\nmb86a20s_writereg(state, 0x04, 0x1f);\r\nmb86a20s_writereg(state, 0x05, rf >> 8);\r\nmb86a20s_writereg(state, 0x04, 0x20);\r\nmb86a20s_writereg(state, 0x04, rf);\r\nval = mb86a20s_readreg(state, 0x02);\r\nif (val & 0x08)\r\nrf_min = (rf_max + rf_min) / 2;\r\nelse\r\nrf_max = (rf_max + rf_min) / 2;\r\nif (rf_max - rf_min < 4) {\r\n*strength = (((rf_max + rf_min) / 2) * 65535) / 4095;\r\nbreak;\r\n}\r\n} while (1);\r\ndprintk("signal strength = %d\n", *strength);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nu8 val;\r\ndprintk("\n");\r\n*status = 0;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nval = mb86a20s_readreg(state, 0x0a) & 0xf;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (val >= 2)\r\n*status |= FE_HAS_SIGNAL;\r\nif (val >= 4)\r\n*status |= FE_HAS_CARRIER;\r\nif (val >= 5)\r\n*status |= FE_HAS_VITERBI;\r\nif (val >= 7)\r\n*status |= FE_HAS_SYNC;\r\nif (val >= 8)\r\n*status |= FE_HAS_LOCK;\r\ndprintk("val = %d, status = 0x%02x\n", val, *status);\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_set_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint rc;\r\ndprintk("\n");\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\ndprintk("Calling tuner set parameters\n");\r\nfe->ops.tuner_ops.set_params(fe, p);\r\nif (state->need_init)\r\nmb86a20s_initfe(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrc = mb86a20s_writeregdata(state, mb86a20s_reset_reception);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_get_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nfe->dtv_property_cache.bandwidth_hz = 6000000;\r\nfe->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_AUTO;\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_AUTO;\r\nfe->dtv_property_cache.isdbt_partial_reception = 0;\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_tune(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *params,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nfe_status_t *status)\r\n{\r\nint rc = 0;\r\ndprintk("\n");\r\nif (params != NULL)\r\nrc = mb86a20s_set_frontend(fe, params);\r\nif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\r\nmb86a20s_read_status(fe, status);\r\nreturn rc;\r\n}\r\nstatic void mb86a20s_release(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\ndprintk("\n");\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *mb86a20s_attach(const struct mb86a20s_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nu8 rev;\r\nstruct mb86a20s_state *state =\r\nkzalloc(sizeof(struct mb86a20s_state), GFP_KERNEL);\r\ndprintk("\n");\r\nif (state == NULL) {\r\nrc("Unable to kzalloc\n");\r\ngoto error;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nmemcpy(&state->frontend.ops, &mb86a20s_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nrev = mb86a20s_readreg(state, 0);\r\nif (rev == 0x13) {\r\nprintk(KERN_INFO "Detected a Fujitsu mb86a20s frontend\n");\r\n} else {\r\nprintk(KERN_ERR "Frontend revision %d is unknown - aborting.\n",\r\nrev);\r\ngoto error;\r\n}\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
