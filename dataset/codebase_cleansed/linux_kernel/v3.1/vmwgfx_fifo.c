bool vmw_fifo_have_3d(struct vmw_private *dev_priv)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t fifo_min, hwversion;\r\nif (!(dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO))\r\nreturn false;\r\nfifo_min = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nif (fifo_min <= SVGA_FIFO_3D_HWVERSION * sizeof(unsigned int))\r\nreturn false;\r\nhwversion = ioread32(fifo_mem + SVGA_FIFO_3D_HWVERSION);\r\nif (hwversion == 0)\r\nreturn false;\r\nif (hwversion < SVGA3D_HWVERSION_WS65_B1)\r\nreturn false;\r\nreturn true;\r\n}\r\nbool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t caps;\r\nif (!(dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO))\r\nreturn false;\r\ncaps = ioread32(fifo_mem + SVGA_FIFO_CAPABILITIES);\r\nif (caps & SVGA_FIFO_CAP_PITCHLOCK)\r\nreturn true;\r\nreturn false;\r\n}\r\nint vmw_fifo_init(struct vmw_private *dev_priv, struct vmw_fifo_state *fifo)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t max;\r\nuint32_t min;\r\nuint32_t dummy;\r\nint ret;\r\nfifo->static_buffer_size = VMWGFX_FIFO_STATIC_SIZE;\r\nfifo->static_buffer = vmalloc(fifo->static_buffer_size);\r\nif (unlikely(fifo->static_buffer == NULL))\r\nreturn -ENOMEM;\r\nfifo->last_buffer_size = VMWGFX_FIFO_STATIC_SIZE;\r\nfifo->last_data_size = 0;\r\nfifo->last_buffer_add = false;\r\nfifo->last_buffer = vmalloc(fifo->last_buffer_size);\r\nif (unlikely(fifo->last_buffer == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nfifo->dynamic_buffer = NULL;\r\nfifo->reserved_size = 0;\r\nfifo->using_bounce_buffer = false;\r\nmutex_init(&fifo->fifo_mutex);\r\ninit_rwsem(&fifo->rwsem);\r\nDRM_INFO("width %d\n", vmw_read(dev_priv, SVGA_REG_WIDTH));\r\nDRM_INFO("height %d\n", vmw_read(dev_priv, SVGA_REG_HEIGHT));\r\nDRM_INFO("bpp %d\n", vmw_read(dev_priv, SVGA_REG_BITS_PER_PIXEL));\r\nmutex_lock(&dev_priv->hw_mutex);\r\ndev_priv->enable_state = vmw_read(dev_priv, SVGA_REG_ENABLE);\r\ndev_priv->config_done_state = vmw_read(dev_priv, SVGA_REG_CONFIG_DONE);\r\ndev_priv->traces_state = vmw_read(dev_priv, SVGA_REG_TRACES);\r\nvmw_write(dev_priv, SVGA_REG_ENABLE, 1);\r\nmin = 4;\r\nif (dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO)\r\nmin = vmw_read(dev_priv, SVGA_REG_MEM_REGS);\r\nmin <<= 2;\r\nif (min < PAGE_SIZE)\r\nmin = PAGE_SIZE;\r\niowrite32(min, fifo_mem + SVGA_FIFO_MIN);\r\niowrite32(dev_priv->mmio_size, fifo_mem + SVGA_FIFO_MAX);\r\nwmb();\r\niowrite32(min, fifo_mem + SVGA_FIFO_NEXT_CMD);\r\niowrite32(min, fifo_mem + SVGA_FIFO_STOP);\r\niowrite32(0, fifo_mem + SVGA_FIFO_BUSY);\r\nmb();\r\nvmw_write(dev_priv, SVGA_REG_CONFIG_DONE, 1);\r\nmutex_unlock(&dev_priv->hw_mutex);\r\nmax = ioread32(fifo_mem + SVGA_FIFO_MAX);\r\nmin = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nfifo->capabilities = ioread32(fifo_mem + SVGA_FIFO_CAPABILITIES);\r\nDRM_INFO("Fifo max 0x%08x min 0x%08x cap 0x%08x\n",\r\n(unsigned int) max,\r\n(unsigned int) min,\r\n(unsigned int) fifo->capabilities);\r\natomic_set(&dev_priv->fence_seq, dev_priv->last_read_sequence);\r\niowrite32(dev_priv->last_read_sequence, fifo_mem + SVGA_FIFO_FENCE);\r\nvmw_fence_queue_init(&fifo->fence_queue);\r\nreturn vmw_fifo_send_fence(dev_priv, &dummy);\r\nout_err:\r\nvfree(fifo->static_buffer);\r\nfifo->static_buffer = NULL;\r\nreturn ret;\r\n}\r\nvoid vmw_fifo_ping_host(struct vmw_private *dev_priv, uint32_t reason)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nmutex_lock(&dev_priv->hw_mutex);\r\nif (unlikely(ioread32(fifo_mem + SVGA_FIFO_BUSY) == 0)) {\r\niowrite32(1, fifo_mem + SVGA_FIFO_BUSY);\r\nvmw_write(dev_priv, SVGA_REG_SYNC, reason);\r\n}\r\nmutex_unlock(&dev_priv->hw_mutex);\r\n}\r\nvoid vmw_fifo_release(struct vmw_private *dev_priv, struct vmw_fifo_state *fifo)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nmutex_lock(&dev_priv->hw_mutex);\r\nwhile (vmw_read(dev_priv, SVGA_REG_BUSY) != 0)\r\nvmw_write(dev_priv, SVGA_REG_SYNC, SVGA_SYNC_GENERIC);\r\ndev_priv->last_read_sequence = ioread32(fifo_mem + SVGA_FIFO_FENCE);\r\nvmw_write(dev_priv, SVGA_REG_CONFIG_DONE,\r\ndev_priv->config_done_state);\r\nvmw_write(dev_priv, SVGA_REG_ENABLE,\r\ndev_priv->enable_state);\r\nvmw_write(dev_priv, SVGA_REG_TRACES,\r\ndev_priv->traces_state);\r\nmutex_unlock(&dev_priv->hw_mutex);\r\nvmw_fence_queue_takedown(&fifo->fence_queue);\r\nif (likely(fifo->last_buffer != NULL)) {\r\nvfree(fifo->last_buffer);\r\nfifo->last_buffer = NULL;\r\n}\r\nif (likely(fifo->static_buffer != NULL)) {\r\nvfree(fifo->static_buffer);\r\nfifo->static_buffer = NULL;\r\n}\r\nif (likely(fifo->dynamic_buffer != NULL)) {\r\nvfree(fifo->dynamic_buffer);\r\nfifo->dynamic_buffer = NULL;\r\n}\r\n}\r\nstatic bool vmw_fifo_is_full(struct vmw_private *dev_priv, uint32_t bytes)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t max = ioread32(fifo_mem + SVGA_FIFO_MAX);\r\nuint32_t next_cmd = ioread32(fifo_mem + SVGA_FIFO_NEXT_CMD);\r\nuint32_t min = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nuint32_t stop = ioread32(fifo_mem + SVGA_FIFO_STOP);\r\nreturn ((max - next_cmd) + (stop - min) <= bytes);\r\n}\r\nstatic int vmw_fifo_wait_noirq(struct vmw_private *dev_priv,\r\nuint32_t bytes, bool interruptible,\r\nunsigned long timeout)\r\n{\r\nint ret = 0;\r\nunsigned long end_jiffies = jiffies + timeout;\r\nDEFINE_WAIT(__wait);\r\nDRM_INFO("Fifo wait noirq.\n");\r\nfor (;;) {\r\nprepare_to_wait(&dev_priv->fifo_queue, &__wait,\r\n(interruptible) ?\r\nTASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\r\nif (!vmw_fifo_is_full(dev_priv, bytes))\r\nbreak;\r\nif (time_after_eq(jiffies, end_jiffies)) {\r\nret = -EBUSY;\r\nDRM_ERROR("SVGA device lockup.\n");\r\nbreak;\r\n}\r\nschedule_timeout(1);\r\nif (interruptible && signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\nfinish_wait(&dev_priv->fifo_queue, &__wait);\r\nwake_up_all(&dev_priv->fifo_queue);\r\nDRM_INFO("Fifo noirq exit.\n");\r\nreturn ret;\r\n}\r\nstatic int vmw_fifo_wait(struct vmw_private *dev_priv,\r\nuint32_t bytes, bool interruptible,\r\nunsigned long timeout)\r\n{\r\nlong ret = 1L;\r\nunsigned long irq_flags;\r\nif (likely(!vmw_fifo_is_full(dev_priv, bytes)))\r\nreturn 0;\r\nvmw_fifo_ping_host(dev_priv, SVGA_SYNC_FIFOFULL);\r\nif (!(dev_priv->capabilities & SVGA_CAP_IRQMASK))\r\nreturn vmw_fifo_wait_noirq(dev_priv, bytes,\r\ninterruptible, timeout);\r\nmutex_lock(&dev_priv->hw_mutex);\r\nif (atomic_add_return(1, &dev_priv->fifo_queue_waiters) > 0) {\r\nspin_lock_irqsave(&dev_priv->irq_lock, irq_flags);\r\noutl(SVGA_IRQFLAG_FIFO_PROGRESS,\r\ndev_priv->io_start + VMWGFX_IRQSTATUS_PORT);\r\nvmw_write(dev_priv, SVGA_REG_IRQMASK,\r\nvmw_read(dev_priv, SVGA_REG_IRQMASK) |\r\nSVGA_IRQFLAG_FIFO_PROGRESS);\r\nspin_unlock_irqrestore(&dev_priv->irq_lock, irq_flags);\r\n}\r\nmutex_unlock(&dev_priv->hw_mutex);\r\nif (interruptible)\r\nret = wait_event_interruptible_timeout\r\n(dev_priv->fifo_queue,\r\n!vmw_fifo_is_full(dev_priv, bytes), timeout);\r\nelse\r\nret = wait_event_timeout\r\n(dev_priv->fifo_queue,\r\n!vmw_fifo_is_full(dev_priv, bytes), timeout);\r\nif (unlikely(ret == 0))\r\nret = -EBUSY;\r\nelse if (likely(ret > 0))\r\nret = 0;\r\nmutex_lock(&dev_priv->hw_mutex);\r\nif (atomic_dec_and_test(&dev_priv->fifo_queue_waiters)) {\r\nspin_lock_irqsave(&dev_priv->irq_lock, irq_flags);\r\nvmw_write(dev_priv, SVGA_REG_IRQMASK,\r\nvmw_read(dev_priv, SVGA_REG_IRQMASK) &\r\n~SVGA_IRQFLAG_FIFO_PROGRESS);\r\nspin_unlock_irqrestore(&dev_priv->irq_lock, irq_flags);\r\n}\r\nmutex_unlock(&dev_priv->hw_mutex);\r\nreturn ret;\r\n}\r\nvoid *vmw_fifo_reserve(struct vmw_private *dev_priv, uint32_t bytes)\r\n{\r\nstruct vmw_fifo_state *fifo_state = &dev_priv->fifo;\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t max;\r\nuint32_t min;\r\nuint32_t next_cmd;\r\nuint32_t reserveable = fifo_state->capabilities & SVGA_FIFO_CAP_RESERVE;\r\nint ret;\r\nmutex_lock(&fifo_state->fifo_mutex);\r\nmax = ioread32(fifo_mem + SVGA_FIFO_MAX);\r\nmin = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nnext_cmd = ioread32(fifo_mem + SVGA_FIFO_NEXT_CMD);\r\nif (unlikely(bytes >= (max - min)))\r\ngoto out_err;\r\nBUG_ON(fifo_state->reserved_size != 0);\r\nBUG_ON(fifo_state->dynamic_buffer != NULL);\r\nfifo_state->reserved_size = bytes;\r\nwhile (1) {\r\nuint32_t stop = ioread32(fifo_mem + SVGA_FIFO_STOP);\r\nbool need_bounce = false;\r\nbool reserve_in_place = false;\r\nif (next_cmd >= stop) {\r\nif (likely((next_cmd + bytes < max ||\r\n(next_cmd + bytes == max && stop > min))))\r\nreserve_in_place = true;\r\nelse if (vmw_fifo_is_full(dev_priv, bytes)) {\r\nret = vmw_fifo_wait(dev_priv, bytes,\r\nfalse, 3 * HZ);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\n} else\r\nneed_bounce = true;\r\n} else {\r\nif (likely((next_cmd + bytes < stop)))\r\nreserve_in_place = true;\r\nelse {\r\nret = vmw_fifo_wait(dev_priv, bytes,\r\nfalse, 3 * HZ);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\n}\r\n}\r\nif (reserve_in_place) {\r\nif (reserveable || bytes <= sizeof(uint32_t)) {\r\nfifo_state->using_bounce_buffer = false;\r\nif (reserveable)\r\niowrite32(bytes, fifo_mem +\r\nSVGA_FIFO_RESERVED);\r\nreturn fifo_mem + (next_cmd >> 2);\r\n} else {\r\nneed_bounce = true;\r\n}\r\n}\r\nif (need_bounce) {\r\nfifo_state->using_bounce_buffer = true;\r\nif (bytes < fifo_state->static_buffer_size)\r\nreturn fifo_state->static_buffer;\r\nelse {\r\nfifo_state->dynamic_buffer = vmalloc(bytes);\r\nreturn fifo_state->dynamic_buffer;\r\n}\r\n}\r\n}\r\nout_err:\r\nfifo_state->reserved_size = 0;\r\nmutex_unlock(&fifo_state->fifo_mutex);\r\nreturn NULL;\r\n}\r\nstatic void vmw_fifo_res_copy(struct vmw_fifo_state *fifo_state,\r\n__le32 __iomem *fifo_mem,\r\nuint32_t next_cmd,\r\nuint32_t max, uint32_t min, uint32_t bytes)\r\n{\r\nuint32_t chunk_size = max - next_cmd;\r\nuint32_t rest;\r\nuint32_t *buffer = (fifo_state->dynamic_buffer != NULL) ?\r\nfifo_state->dynamic_buffer : fifo_state->static_buffer;\r\nif (bytes < chunk_size)\r\nchunk_size = bytes;\r\niowrite32(bytes, fifo_mem + SVGA_FIFO_RESERVED);\r\nmb();\r\nmemcpy_toio(fifo_mem + (next_cmd >> 2), buffer, chunk_size);\r\nrest = bytes - chunk_size;\r\nif (rest)\r\nmemcpy_toio(fifo_mem + (min >> 2), buffer + (chunk_size >> 2),\r\nrest);\r\n}\r\nstatic void vmw_fifo_slow_copy(struct vmw_fifo_state *fifo_state,\r\n__le32 __iomem *fifo_mem,\r\nuint32_t next_cmd,\r\nuint32_t max, uint32_t min, uint32_t bytes)\r\n{\r\nuint32_t *buffer = (fifo_state->dynamic_buffer != NULL) ?\r\nfifo_state->dynamic_buffer : fifo_state->static_buffer;\r\nwhile (bytes > 0) {\r\niowrite32(*buffer++, fifo_mem + (next_cmd >> 2));\r\nnext_cmd += sizeof(uint32_t);\r\nif (unlikely(next_cmd == max))\r\nnext_cmd = min;\r\nmb();\r\niowrite32(next_cmd, fifo_mem + SVGA_FIFO_NEXT_CMD);\r\nmb();\r\nbytes -= sizeof(uint32_t);\r\n}\r\n}\r\nvoid vmw_fifo_commit(struct vmw_private *dev_priv, uint32_t bytes)\r\n{\r\nstruct vmw_fifo_state *fifo_state = &dev_priv->fifo;\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t next_cmd = ioread32(fifo_mem + SVGA_FIFO_NEXT_CMD);\r\nuint32_t max = ioread32(fifo_mem + SVGA_FIFO_MAX);\r\nuint32_t min = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nbool reserveable = fifo_state->capabilities & SVGA_FIFO_CAP_RESERVE;\r\nBUG_ON((bytes & 3) != 0);\r\nBUG_ON(bytes > fifo_state->reserved_size);\r\nfifo_state->reserved_size = 0;\r\nif (fifo_state->using_bounce_buffer) {\r\nif (reserveable)\r\nvmw_fifo_res_copy(fifo_state, fifo_mem,\r\nnext_cmd, max, min, bytes);\r\nelse\r\nvmw_fifo_slow_copy(fifo_state, fifo_mem,\r\nnext_cmd, max, min, bytes);\r\nif (fifo_state->dynamic_buffer) {\r\nvfree(fifo_state->dynamic_buffer);\r\nfifo_state->dynamic_buffer = NULL;\r\n}\r\n}\r\ndown_write(&fifo_state->rwsem);\r\nif (fifo_state->using_bounce_buffer || reserveable) {\r\nnext_cmd += bytes;\r\nif (next_cmd >= max)\r\nnext_cmd -= max - min;\r\nmb();\r\niowrite32(next_cmd, fifo_mem + SVGA_FIFO_NEXT_CMD);\r\n}\r\nif (reserveable)\r\niowrite32(0, fifo_mem + SVGA_FIFO_RESERVED);\r\nmb();\r\nup_write(&fifo_state->rwsem);\r\nvmw_fifo_ping_host(dev_priv, SVGA_SYNC_GENERIC);\r\nmutex_unlock(&fifo_state->fifo_mutex);\r\n}\r\nint vmw_fifo_send_fence(struct vmw_private *dev_priv, uint32_t *sequence)\r\n{\r\nstruct vmw_fifo_state *fifo_state = &dev_priv->fifo;\r\nstruct svga_fifo_cmd_fence *cmd_fence;\r\nvoid *fm;\r\nint ret = 0;\r\nuint32_t bytes = sizeof(__le32) + sizeof(*cmd_fence);\r\nfm = vmw_fifo_reserve(dev_priv, bytes);\r\nif (unlikely(fm == NULL)) {\r\n*sequence = atomic_read(&dev_priv->fence_seq);\r\nret = -ENOMEM;\r\n(void)vmw_fallback_wait(dev_priv, false, true, *sequence,\r\nfalse, 3*HZ);\r\ngoto out_err;\r\n}\r\ndo {\r\n*sequence = atomic_add_return(1, &dev_priv->fence_seq);\r\n} while (*sequence == 0);\r\nif (!(fifo_state->capabilities & SVGA_FIFO_CAP_FENCE)) {\r\nvmw_fifo_commit(dev_priv, 0);\r\nreturn 0;\r\n}\r\n*(__le32 *) fm = cpu_to_le32(SVGA_CMD_FENCE);\r\ncmd_fence = (struct svga_fifo_cmd_fence *)\r\n((unsigned long)fm + sizeof(__le32));\r\niowrite32(*sequence, &cmd_fence->fence);\r\nfifo_state->last_buffer_add = true;\r\nvmw_fifo_commit(dev_priv, bytes);\r\nfifo_state->last_buffer_add = false;\r\n(void) vmw_fence_push(&fifo_state->fence_queue, *sequence);\r\nvmw_update_sequence(dev_priv, fifo_state);\r\nout_err:\r\nreturn ret;\r\n}\r\nstatic int vmw_fifo_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nint ret;\r\nunsigned long address = (unsigned long)vmf->virtual_address;\r\nif (address != vma->vm_start)\r\nreturn VM_FAULT_SIGBUS;\r\nret = vm_insert_pfn(vma, address, vma->vm_pgoff);\r\nif (likely(ret == -EBUSY || ret == 0))\r\nreturn VM_FAULT_NOPAGE;\r\nelse if (ret == -ENOMEM)\r\nreturn VM_FAULT_OOM;\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nint vmw_fifo_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *file_priv;\r\nstruct vmw_private *dev_priv;\r\nfile_priv = filp->private_data;\r\ndev_priv = vmw_priv(file_priv->minor->dev);\r\nif (vma->vm_pgoff != (dev_priv->mmio_start >> PAGE_SHIFT) ||\r\n(vma->vm_end - vma->vm_start) != PAGE_SIZE)\r\nreturn -EINVAL;\r\nvma->vm_flags &= ~(VM_WRITE | VM_MAYWRITE);\r\nvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_SHARED;\r\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\r\nvma->vm_page_prot = ttm_io_prot(TTM_PL_FLAG_UNCACHED,\r\nvma->vm_page_prot);\r\nvma->vm_ops = &vmw_fifo_vm_ops;\r\nreturn 0;\r\n}
