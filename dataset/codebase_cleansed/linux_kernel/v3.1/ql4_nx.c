static inline void __iomem *\r\nqla4_8xxx_pci_base_offsetfset(struct scsi_qla_host *ha, unsigned long off)\r\n{\r\nif ((off < ha->first_page_group_end) &&\r\n(off >= ha->first_page_group_start))\r\nreturn (void __iomem *)(ha->nx_pcibase + off);\r\nreturn NULL;\r\n}\r\nstatic void\r\nqla4_8xxx_crb_addr_transform_setup(void)\r\n{\r\nqla4_8xxx_crb_addr_transform(XDMA);\r\nqla4_8xxx_crb_addr_transform(TIMR);\r\nqla4_8xxx_crb_addr_transform(SRE);\r\nqla4_8xxx_crb_addr_transform(SQN3);\r\nqla4_8xxx_crb_addr_transform(SQN2);\r\nqla4_8xxx_crb_addr_transform(SQN1);\r\nqla4_8xxx_crb_addr_transform(SQN0);\r\nqla4_8xxx_crb_addr_transform(SQS3);\r\nqla4_8xxx_crb_addr_transform(SQS2);\r\nqla4_8xxx_crb_addr_transform(SQS1);\r\nqla4_8xxx_crb_addr_transform(SQS0);\r\nqla4_8xxx_crb_addr_transform(RPMX7);\r\nqla4_8xxx_crb_addr_transform(RPMX6);\r\nqla4_8xxx_crb_addr_transform(RPMX5);\r\nqla4_8xxx_crb_addr_transform(RPMX4);\r\nqla4_8xxx_crb_addr_transform(RPMX3);\r\nqla4_8xxx_crb_addr_transform(RPMX2);\r\nqla4_8xxx_crb_addr_transform(RPMX1);\r\nqla4_8xxx_crb_addr_transform(RPMX0);\r\nqla4_8xxx_crb_addr_transform(ROMUSB);\r\nqla4_8xxx_crb_addr_transform(SN);\r\nqla4_8xxx_crb_addr_transform(QMN);\r\nqla4_8xxx_crb_addr_transform(QMS);\r\nqla4_8xxx_crb_addr_transform(PGNI);\r\nqla4_8xxx_crb_addr_transform(PGND);\r\nqla4_8xxx_crb_addr_transform(PGN3);\r\nqla4_8xxx_crb_addr_transform(PGN2);\r\nqla4_8xxx_crb_addr_transform(PGN1);\r\nqla4_8xxx_crb_addr_transform(PGN0);\r\nqla4_8xxx_crb_addr_transform(PGSI);\r\nqla4_8xxx_crb_addr_transform(PGSD);\r\nqla4_8xxx_crb_addr_transform(PGS3);\r\nqla4_8xxx_crb_addr_transform(PGS2);\r\nqla4_8xxx_crb_addr_transform(PGS1);\r\nqla4_8xxx_crb_addr_transform(PGS0);\r\nqla4_8xxx_crb_addr_transform(PS);\r\nqla4_8xxx_crb_addr_transform(PH);\r\nqla4_8xxx_crb_addr_transform(NIU);\r\nqla4_8xxx_crb_addr_transform(I2Q);\r\nqla4_8xxx_crb_addr_transform(EG);\r\nqla4_8xxx_crb_addr_transform(MN);\r\nqla4_8xxx_crb_addr_transform(MS);\r\nqla4_8xxx_crb_addr_transform(CAS2);\r\nqla4_8xxx_crb_addr_transform(CAS1);\r\nqla4_8xxx_crb_addr_transform(CAS0);\r\nqla4_8xxx_crb_addr_transform(CAM);\r\nqla4_8xxx_crb_addr_transform(C2C1);\r\nqla4_8xxx_crb_addr_transform(C2C0);\r\nqla4_8xxx_crb_addr_transform(SMB);\r\nqla4_8xxx_crb_addr_transform(OCM0);\r\nqla4_8xxx_crb_addr_transform(I2C0);\r\nqla4_8xxx_crb_table_initialized = 1;\r\n}\r\nstatic void\r\nqla4_8xxx_pci_set_crbwindow_2M(struct scsi_qla_host *ha, ulong *off)\r\n{\r\nu32 win_read;\r\nha->crb_win = CRB_HI(*off);\r\nwritel(ha->crb_win,\r\n(void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\r\nwin_read = readl((void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\r\nif (win_read != ha->crb_win) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Written crbwin (0x%x) != Read crbwin (0x%x),"\r\n" off=0x%lx\n", __func__, ha->crb_win, win_read, *off));\r\n}\r\n*off = (*off & MASK(16)) + CRB_INDIRECT_2M + ha->nx_pcibase;\r\n}\r\nvoid\r\nqla4_8xxx_wr_32(struct scsi_qla_host *ha, ulong off, u32 data)\r\n{\r\nunsigned long flags = 0;\r\nint rv;\r\nrv = qla4_8xxx_pci_get_crb_addr_2M(ha, &off);\r\nBUG_ON(rv == -1);\r\nif (rv == 1) {\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nqla4_8xxx_crb_win_lock(ha);\r\nqla4_8xxx_pci_set_crbwindow_2M(ha, &off);\r\n}\r\nwritel(data, (void __iomem *)off);\r\nif (rv == 1) {\r\nqla4_8xxx_crb_win_unlock(ha);\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\n}\r\n}\r\nint\r\nqla4_8xxx_rd_32(struct scsi_qla_host *ha, ulong off)\r\n{\r\nunsigned long flags = 0;\r\nint rv;\r\nu32 data;\r\nrv = qla4_8xxx_pci_get_crb_addr_2M(ha, &off);\r\nBUG_ON(rv == -1);\r\nif (rv == 1) {\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nqla4_8xxx_crb_win_lock(ha);\r\nqla4_8xxx_pci_set_crbwindow_2M(ha, &off);\r\n}\r\ndata = readl((void __iomem *)off);\r\nif (rv == 1) {\r\nqla4_8xxx_crb_win_unlock(ha);\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\n}\r\nreturn data;\r\n}\r\nint qla4_8xxx_crb_win_lock(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= CRB_WIN_LOCK_TIMEOUT)\r\nreturn -1;\r\ntimeout++;\r\nif (!in_interrupt())\r\nschedule();\r\nelse {\r\nfor (i = 0; i < 20; i++)\r\ncpu_relax();\r\n}\r\n}\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_WIN_LOCK_ID, ha->func_num);\r\nreturn 0;\r\n}\r\nvoid qla4_8xxx_crb_win_unlock(struct scsi_qla_host *ha)\r\n{\r\nqla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));\r\n}\r\nint qla4_8xxx_idc_lock(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= IDC_LOCK_TIMEOUT)\r\nreturn -1;\r\ntimeout++;\r\nif (!in_interrupt())\r\nschedule();\r\nelse {\r\nfor (i = 0; i < 20; i++)\r\ncpu_relax();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid qla4_8xxx_idc_unlock(struct scsi_qla_host *ha)\r\n{\r\nqla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_UNLOCK));\r\n}\r\nint\r\nqla4_8xxx_pci_get_crb_addr_2M(struct scsi_qla_host *ha, ulong *off)\r\n{\r\nstruct crb_128M_2M_sub_block_map *m;\r\nif (*off >= QLA82XX_CRB_MAX)\r\nreturn -1;\r\nif (*off >= QLA82XX_PCI_CAMQM && (*off < QLA82XX_PCI_CAMQM_2M_END)) {\r\n*off = (*off - QLA82XX_PCI_CAMQM) +\r\nQLA82XX_PCI_CAMQM_2M_BASE + ha->nx_pcibase;\r\nreturn 0;\r\n}\r\nif (*off < QLA82XX_PCI_CRBSPACE)\r\nreturn -1;\r\n*off -= QLA82XX_PCI_CRBSPACE;\r\nm = &crb_128M_2M_map[CRB_BLK(*off)].sub_block[CRB_SUBBLK(*off)];\r\nif (m->valid && (m->start_128M <= *off) && (m->end_128M > *off)) {\r\n*off = *off + m->start_2M - m->start_128M + ha->nx_pcibase;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned long\r\nqla4_8xxx_pci_mem_bound_check(struct scsi_qla_host *ha,\r\nunsigned long long addr, int size)\r\n{\r\nif (!QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_DDR_NET,\r\nQLA82XX_ADDR_DDR_NET_MAX) ||\r\n!QLA82XX_ADDR_IN_RANGE(addr + size - 1,\r\nQLA82XX_ADDR_DDR_NET, QLA82XX_ADDR_DDR_NET_MAX) ||\r\n((size != 1) && (size != 2) && (size != 4) && (size != 8))) {\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned long\r\nqla4_8xxx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)\r\n{\r\nint window;\r\nu32 win_read;\r\nif (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_DDR_NET,\r\nQLA82XX_ADDR_DDR_NET_MAX)) {\r\nwindow = MN_WIN(addr);\r\nha->ddr_mn_window = window;\r\nqla4_8xxx_wr_32(ha, ha->mn_win_crb |\r\nQLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla4_8xxx_rd_32(ha, ha->mn_win_crb |\r\nQLA82XX_PCI_CRBSPACE);\r\nif ((win_read << 17) != window) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: Written MNwin (0x%x) != Read MNwin (0x%x)\n",\r\n__func__, window, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_DDR_NET;\r\n} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_OCM0,\r\nQLA82XX_ADDR_OCM0_MAX)) {\r\nunsigned int temp1;\r\nif ((addr & 0x00ff800) == 0xff800) {\r\nprintk("%s: QM access not handled.\n", __func__);\r\naddr = -1UL;\r\n}\r\nwindow = OCM_WIN(addr);\r\nha->ddr_mn_window = window;\r\nqla4_8xxx_wr_32(ha, ha->mn_win_crb |\r\nQLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla4_8xxx_rd_32(ha, ha->mn_win_crb |\r\nQLA82XX_PCI_CRBSPACE);\r\ntemp1 = ((window & 0x1FF) << 7) |\r\n((window & 0x0FFFE0000) >> 17);\r\nif (win_read != temp1) {\r\nprintk("%s: Written OCMwin (0x%x) != Read"\r\n" OCMwin (0x%x)\n", __func__, temp1, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_OCM0_2M;\r\n} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_QDR_NET,\r\nQLA82XX_P3_ADDR_QDR_NET_MAX)) {\r\nwindow = MS_WIN(addr);\r\nha->qdr_sn_window = window;\r\nqla4_8xxx_wr_32(ha, ha->ms_win_crb |\r\nQLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla4_8xxx_rd_32(ha,\r\nha->ms_win_crb | QLA82XX_PCI_CRBSPACE);\r\nif (win_read != window) {\r\nprintk("%s: Written MSwin (0x%x) != Read "\r\n"MSwin (0x%x)\n", __func__, window, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_QDR_NET;\r\n} else {\r\nif ((qla4_8xxx_pci_set_window_warning_count++ < 8) ||\r\n(qla4_8xxx_pci_set_window_warning_count%64 == 0)) {\r\nprintk("%s: Warning:%s Unknown address range!\n",\r\n__func__, DRIVER_NAME);\r\n}\r\naddr = -1UL;\r\n}\r\nreturn addr;\r\n}\r\nstatic int qla4_8xxx_pci_is_same_window(struct scsi_qla_host *ha,\r\nunsigned long long addr)\r\n{\r\nint window;\r\nunsigned long long qdr_max;\r\nqdr_max = QLA82XX_P3_ADDR_QDR_NET_MAX;\r\nif (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_DDR_NET,\r\nQLA82XX_ADDR_DDR_NET_MAX)) {\r\nBUG();\r\n} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_OCM0,\r\nQLA82XX_ADDR_OCM0_MAX)) {\r\nreturn 1;\r\n} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_OCM1,\r\nQLA82XX_ADDR_OCM1_MAX)) {\r\nreturn 1;\r\n} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_QDR_NET,\r\nqdr_max)) {\r\nwindow = ((addr - QLA82XX_ADDR_QDR_NET) >> 22) & 0x3f;\r\nif (ha->qdr_sn_window == window)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline __u64 readq(const volatile void __iomem *addr)\r\n{\r\nconst volatile u32 __iomem *p = addr;\r\nu32 low, high;\r\nlow = readl(p);\r\nhigh = readl(p + 1);\r\nreturn low + ((u64)high << 32);\r\n}\r\nstatic inline void writeq(__u64 val, volatile void __iomem *addr)\r\n{\r\nwritel(val, addr);\r\nwritel(val >> 32, addr+4);\r\n}\r\nstatic int qla4_8xxx_pci_mem_read_direct(struct scsi_qla_host *ha,\r\nu64 off, void *data, int size)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr;\r\nint ret = 0;\r\nu64 start;\r\nvoid __iomem *mem_ptr = NULL;\r\nunsigned long mem_base;\r\nunsigned long mem_page;\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nstart = qla4_8xxx_pci_set_window(ha, off);\r\nif ((start == -1UL) ||\r\n(qla4_8xxx_pci_is_same_window(ha, off + size - 1) == 0)) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nprintk(KERN_ERR"%s out of bound pci memory access. "\r\n"offset is 0x%llx\n", DRIVER_NAME, off);\r\nreturn -1;\r\n}\r\naddr = qla4_8xxx_pci_base_offsetfset(ha, start);\r\nif (!addr) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nmem_base = pci_resource_start(ha->pdev, 0);\r\nmem_page = start & PAGE_MASK;\r\nif (mem_page != ((start + size - 1) & PAGE_MASK))\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE * 2);\r\nelse\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\r\nif (mem_ptr == NULL) {\r\n*(u8 *)data = 0;\r\nreturn -1;\r\n}\r\naddr = mem_ptr;\r\naddr += start & (PAGE_SIZE - 1);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\n}\r\nswitch (size) {\r\ncase 1:\r\n*(u8 *)data = readb(addr);\r\nbreak;\r\ncase 2:\r\n*(u16 *)data = readw(addr);\r\nbreak;\r\ncase 4:\r\n*(u32 *)data = readl(addr);\r\nbreak;\r\ncase 8:\r\n*(u64 *)data = readq(addr);\r\nbreak;\r\ndefault:\r\nret = -1;\r\nbreak;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla4_8xxx_pci_mem_write_direct(struct scsi_qla_host *ha, u64 off,\r\nvoid *data, int size)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr;\r\nint ret = 0;\r\nu64 start;\r\nvoid __iomem *mem_ptr = NULL;\r\nunsigned long mem_base;\r\nunsigned long mem_page;\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nstart = qla4_8xxx_pci_set_window(ha, off);\r\nif ((start == -1UL) ||\r\n(qla4_8xxx_pci_is_same_window(ha, off + size - 1) == 0)) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nprintk(KERN_ERR"%s out of bound pci memory access. "\r\n"offset is 0x%llx\n", DRIVER_NAME, off);\r\nreturn -1;\r\n}\r\naddr = qla4_8xxx_pci_base_offsetfset(ha, start);\r\nif (!addr) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nmem_base = pci_resource_start(ha->pdev, 0);\r\nmem_page = start & PAGE_MASK;\r\nif (mem_page != ((start + size - 1) & PAGE_MASK))\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE*2);\r\nelse\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\r\nif (mem_ptr == NULL)\r\nreturn -1;\r\naddr = mem_ptr;\r\naddr += start & (PAGE_SIZE - 1);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\n}\r\nswitch (size) {\r\ncase 1:\r\nwriteb(*(u8 *)data, addr);\r\nbreak;\r\ncase 2:\r\nwritew(*(u16 *)data, addr);\r\nbreak;\r\ncase 4:\r\nwritel(*(u32 *)data, addr);\r\nbreak;\r\ncase 8:\r\nwriteq(*(u64 *)data, addr);\r\nbreak;\r\ndefault:\r\nret = -1;\r\nbreak;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn ret;\r\n}\r\nstatic unsigned long\r\nqla4_8xxx_decode_crb_addr(unsigned long addr)\r\n{\r\nint i;\r\nunsigned long base_addr, offset, pci_base;\r\nif (!qla4_8xxx_crb_table_initialized)\r\nqla4_8xxx_crb_addr_transform_setup();\r\npci_base = ADDR_ERROR;\r\nbase_addr = addr & 0xfff00000;\r\noffset = addr & 0x000fffff;\r\nfor (i = 0; i < MAX_CRB_XFORM; i++) {\r\nif (crb_addr_xform[i] == base_addr) {\r\npci_base = i << 20;\r\nbreak;\r\n}\r\n}\r\nif (pci_base == ADDR_ERROR)\r\nreturn pci_base;\r\nelse\r\nreturn pci_base + offset;\r\n}\r\nstatic int\r\nqla4_8xxx_rom_lock(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= qla4_8xxx_rom_lock_timeout) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: Failed to acquire rom lock", __func__);\r\nreturn -1;\r\n}\r\ntimeout++;\r\nif (!in_interrupt())\r\nschedule();\r\nelse {\r\nfor (i = 0; i < 20; i++)\r\ncpu_relax();\r\n}\r\n}\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROM_LOCK_ID, ROM_LOCK_DRIVER);\r\nreturn 0;\r\n}\r\nstatic void\r\nqla4_8xxx_rom_unlock(struct scsi_qla_host *ha)\r\n{\r\nqla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_UNLOCK));\r\n}\r\nstatic int\r\nqla4_8xxx_wait_rom_done(struct scsi_qla_host *ha)\r\n{\r\nlong timeout = 0;\r\nlong done = 0 ;\r\nwhile (done == 0) {\r\ndone = qla4_8xxx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);\r\ndone &= 2;\r\ntimeout++;\r\nif (timeout >= rom_max_timeout) {\r\nprintk("%s: Timeout reached waiting for rom done",\r\nDRIVER_NAME);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqla4_8xxx_do_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)\r\n{\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, addr);\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, 0xb);\r\nif (qla4_8xxx_wait_rom_done(ha)) {\r\nprintk("%s: Error waiting for rom done\n", DRIVER_NAME);\r\nreturn -1;\r\n}\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\nudelay(10);\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);\r\n*valp = qla4_8xxx_rd_32(ha, QLA82XX_ROMUSB_ROM_RDATA);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla4_8xxx_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)\r\n{\r\nint ret, loops = 0;\r\nwhile ((qla4_8xxx_rom_lock(ha) != 0) && (loops < 50000)) {\r\nudelay(100);\r\nloops++;\r\n}\r\nif (loops >= 50000) {\r\nprintk("%s: qla4_8xxx_rom_lock failed\n", DRIVER_NAME);\r\nreturn -1;\r\n}\r\nret = qla4_8xxx_do_rom_fast_read(ha, addr, valp);\r\nqla4_8xxx_rom_unlock(ha);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla4_8xxx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)\r\n{\r\nint addr, val;\r\nint i ;\r\nstruct crb_addr_pair *buf;\r\nunsigned long off;\r\nunsigned offset, n;\r\nstruct crb_addr_pair {\r\nlong addr;\r\nlong data;\r\n};\r\nqla4_8xxx_rom_lock(ha);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x10, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x14, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x18, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x1c, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x20, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x24, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0x40, 0xff);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0x70000, 0x00);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0x80000, 0x00);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0x90000, 0x00);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0xa0000, 0x00);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0xb0000, 0x00);\r\nval = qla4_8xxx_rd_32(ha, QLA82XX_CRB_SRE + 0x1000);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_SRE + 0x1000, val & (~(0x1)));\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_EPG + 0x1300, 0x1);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x0, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x8, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x10, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x18, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x100, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x200, 0x0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x3c, 1);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x3c, 1);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x3c, 1);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x3c, 1);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_4 + 0x3c, 1);\r\nmsleep(5);\r\nif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);\r\nelse\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);\r\nval = qla4_8xxx_rd_32(ha, QLA82XX_CRB_QDR_NET + 0xe4);\r\nval |= (1 << 1);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_QDR_NET + 0xe4, val);\r\nmsleep(20);\r\nval = qla4_8xxx_rd_32(ha, QLA82XX_CRB_QDR_NET + 0xe4);\r\nval &= ~(1 << 1);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_QDR_NET + 0xe4, val);\r\nmsleep(20);\r\nqla4_8xxx_rom_unlock(ha);\r\nif (qla4_8xxx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||\r\nqla4_8xxx_rom_fast_read(ha, 4, &n) != 0) {\r\nql4_printk(KERN_WARNING, ha,\r\n"[ERROR] Reading crb_init area: n: %08x\n", n);\r\nreturn -1;\r\n}\r\noffset = n & 0xffffU;\r\nn = (n >> 16) & 0xffffU;\r\nif (n >= 1024) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: %s:n=0x%x [ERROR] Card flash not initialized.\n",\r\nDRIVER_NAME, __func__, n);\r\nreturn -1;\r\n}\r\nql4_printk(KERN_INFO, ha,\r\n"%s: %d CRB init values found in ROM.\n", DRIVER_NAME, n);\r\nbuf = kmalloc(n * sizeof(struct crb_addr_pair), GFP_KERNEL);\r\nif (buf == NULL) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: [ERROR] Unable to malloc memory.\n", DRIVER_NAME);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nif (qla4_8xxx_rom_fast_read(ha, 8*i + 4*offset, &val) != 0 ||\r\nqla4_8xxx_rom_fast_read(ha, 8*i + 4*offset + 4, &addr) !=\r\n0) {\r\nkfree(buf);\r\nreturn -1;\r\n}\r\nbuf[i].addr = addr;\r\nbuf[i].data = val;\r\n}\r\nfor (i = 0; i < n; i++) {\r\noff = qla4_8xxx_decode_crb_addr((unsigned long)buf[i].addr) +\r\nQLA82XX_PCI_CRBSPACE;\r\nif (off & 0x1) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"Skip CRB init replay for offset = 0x%lx\n", off));\r\ncontinue;\r\n}\r\nif (off == QLA82XX_CAM_RAM(0x1fc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xbc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xc8))\r\ncontinue;\r\nif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION))\r\ncontinue;\r\nif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION2))\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLA82XX_CRB_SMB)\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLA82XX_CRB_DDR_NET)\r\ncontinue;\r\nif (off == ADDR_ERROR) {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: [ERROR] Unknown addr: 0x%08lx\n",\r\nDRIVER_NAME, buf[i].addr);\r\ncontinue;\r\n}\r\nqla4_8xxx_wr_32(ha, off, buf[i].data);\r\nif (off == QLA82XX_ROMUSB_GLB_SW_RESET)\r\nmsleep(1000);\r\nmsleep(1);\r\n}\r\nkfree(buf);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0xec, 0x1e);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0x4c, 8);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_I+0x4c, 8);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0x8, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0xc, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0x8, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0xc, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0x8, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0xc, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0x8, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0xc, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla4_8xxx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)\r\n{\r\nint i, rval = 0;\r\nlong size = 0;\r\nlong flashaddr, memaddr;\r\nu64 data;\r\nu32 high, low;\r\nflashaddr = memaddr = ha->hw.flt_region_bootload;\r\nsize = (image_start - flashaddr) / 8;\r\nDEBUG2(printk("scsi%ld: %s: bootldr=0x%lx, fw_image=0x%x\n",\r\nha->host_no, __func__, flashaddr, image_start));\r\nfor (i = 0; i < size; i++) {\r\nif ((qla4_8xxx_rom_fast_read(ha, flashaddr, (int *)&low)) ||\r\n(qla4_8xxx_rom_fast_read(ha, flashaddr + 4,\r\n(int *)&high))) {\r\nrval = -1;\r\ngoto exit_load_from_flash;\r\n}\r\ndata = ((u64)high << 32) | low ;\r\nrval = qla4_8xxx_pci_mem_write_2M(ha, memaddr, &data, 8);\r\nif (rval)\r\ngoto exit_load_from_flash;\r\nflashaddr += 8;\r\nmemaddr += 8;\r\nif (i % 0x1000 == 0)\r\nmsleep(1);\r\n}\r\nudelay(100);\r\nread_lock(&ha->hw_lock);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);\r\nread_unlock(&ha->hw_lock);\r\nexit_load_from_flash:\r\nreturn rval;\r\n}\r\nstatic int qla4_8xxx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)\r\n{\r\nu32 rst;\r\nqla4_8xxx_wr_32(ha, CRB_CMDPEG_STATE, 0);\r\nif (qla4_8xxx_pinit_from_rom(ha, 0) != QLA_SUCCESS) {\r\nprintk(KERN_WARNING "%s: Error during CRB Initialization\n",\r\n__func__);\r\nreturn QLA_ERROR;\r\n}\r\nudelay(500);\r\nrst = qla4_8xxx_rd_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET);\r\nrst &= ~(1 << 28);\r\nqla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, rst);\r\nif (qla4_8xxx_load_from_flash(ha, image_start)) {\r\nprintk("%s: Error trying to load fw from flash!\n", __func__);\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla4_8xxx_pci_mem_read_2M(struct scsi_qla_host *ha,\r\nu64 off, void *data, int size)\r\n{\r\nint i, j = 0, k, start, end, loop, sz[2], off0[2];\r\nint shift_amount;\r\nuint32_t temp;\r\nuint64_t off8, val, mem_crb, word[2] = {0, 0};\r\nif (off >= QLA82XX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\r\nmem_crb = QLA82XX_CRB_QDR_NET;\r\nelse {\r\nmem_crb = QLA82XX_CRB_DDR_NET;\r\nif (qla4_8xxx_pci_mem_bound_check(ha, off, size) == 0)\r\nreturn qla4_8xxx_pci_mem_read_direct(ha,\r\noff, data, size);\r\n}\r\noff8 = off & 0xfffffff0;\r\noff0[0] = off & 0xf;\r\nsz[0] = (size < (16 - off0[0])) ? size : (16 - off0[0]);\r\nshift_amount = 4;\r\nloop = ((off0[0] + size - 1) >> shift_amount) + 1;\r\noff0[1] = 0;\r\nsz[1] = size - sz[0];\r\nfor (i = 0; i < loop; i++) {\r\ntemp = off8 + (i << shift_amount);\r\nqla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);\r\ntemp = 0;\r\nqla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);\r\ntemp = MIU_TA_CTL_ENABLE;\r\nqla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\r\ntemp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE;\r\nqla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qla4_8xxx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\r\nif ((temp & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\nql4_printk(KERN_ERR, ha,\r\n"failed to read through agent\n");\r\nbreak;\r\n}\r\nstart = off0[i] >> 2;\r\nend = (off0[i] + sz[i] - 1) >> 2;\r\nfor (k = start; k <= end; k++) {\r\ntemp = qla4_8xxx_rd_32(ha,\r\nmem_crb + MIU_TEST_AGT_RDDATA(k));\r\nword[i] |= ((uint64_t)temp << (32 * (k & 1)));\r\n}\r\n}\r\nif (j >= MAX_CTL_CHECK)\r\nreturn -1;\r\nif ((off0[0] & 7) == 0) {\r\nval = word[0];\r\n} else {\r\nval = ((word[0] >> (off0[0] * 8)) & (~(~0ULL << (sz[0] * 8)))) |\r\n((word[1] & (~(~0ULL << (sz[1] * 8)))) << (sz[0] * 8));\r\n}\r\nswitch (size) {\r\ncase 1:\r\n*(uint8_t *)data = val;\r\nbreak;\r\ncase 2:\r\n*(uint16_t *)data = val;\r\nbreak;\r\ncase 4:\r\n*(uint32_t *)data = val;\r\nbreak;\r\ncase 8:\r\n*(uint64_t *)data = val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nqla4_8xxx_pci_mem_write_2M(struct scsi_qla_host *ha,\r\nu64 off, void *data, int size)\r\n{\r\nint i, j, ret = 0, loop, sz[2], off0;\r\nint scale, shift_amount, startword;\r\nuint32_t temp;\r\nuint64_t off8, mem_crb, tmpw, word[2] = {0, 0};\r\nif (off >= QLA82XX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\r\nmem_crb = QLA82XX_CRB_QDR_NET;\r\nelse {\r\nmem_crb = QLA82XX_CRB_DDR_NET;\r\nif (qla4_8xxx_pci_mem_bound_check(ha, off, size) == 0)\r\nreturn qla4_8xxx_pci_mem_write_direct(ha,\r\noff, data, size);\r\n}\r\noff0 = off & 0x7;\r\nsz[0] = (size < (8 - off0)) ? size : (8 - off0);\r\nsz[1] = size - sz[0];\r\noff8 = off & 0xfffffff0;\r\nloop = (((off & 0xf) + size - 1) >> 4) + 1;\r\nshift_amount = 4;\r\nscale = 2;\r\nstartword = (off & 0xf)/8;\r\nfor (i = 0; i < loop; i++) {\r\nif (qla4_8xxx_pci_mem_read_2M(ha, off8 +\r\n(i << shift_amount), &word[i * scale], 8))\r\nreturn -1;\r\n}\r\nswitch (size) {\r\ncase 1:\r\ntmpw = *((uint8_t *)data);\r\nbreak;\r\ncase 2:\r\ntmpw = *((uint16_t *)data);\r\nbreak;\r\ncase 4:\r\ntmpw = *((uint32_t *)data);\r\nbreak;\r\ncase 8:\r\ndefault:\r\ntmpw = *((uint64_t *)data);\r\nbreak;\r\n}\r\nif (sz[0] == 8)\r\nword[startword] = tmpw;\r\nelse {\r\nword[startword] &=\r\n~((~(~0ULL << (sz[0] * 8))) << (off0 * 8));\r\nword[startword] |= tmpw << (off0 * 8);\r\n}\r\nif (sz[1] != 0) {\r\nword[startword+1] &= ~(~0ULL << (sz[1] * 8));\r\nword[startword+1] |= tmpw >> (sz[0] * 8);\r\n}\r\nfor (i = 0; i < loop; i++) {\r\ntemp = off8 + (i << shift_amount);\r\nqla4_8xxx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_LO, temp);\r\ntemp = 0;\r\nqla4_8xxx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_HI, temp);\r\ntemp = word[i * scale] & 0xffffffff;\r\nqla4_8xxx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_LO, temp);\r\ntemp = (word[i * scale] >> 32) & 0xffffffff;\r\nqla4_8xxx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_HI, temp);\r\ntemp = word[i*scale + 1] & 0xffffffff;\r\nqla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_LO,\r\ntemp);\r\ntemp = (word[i*scale + 1] >> 32) & 0xffffffff;\r\nqla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_HI,\r\ntemp);\r\ntemp = MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;\r\nqla4_8xxx_wr_32(ha, mem_crb+MIU_TEST_AGT_CTRL, temp);\r\ntemp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;\r\nqla4_8xxx_wr_32(ha, mem_crb+MIU_TEST_AGT_CTRL, temp);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qla4_8xxx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\r\nif ((temp & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\nql4_printk(KERN_ERR, ha,\r\n"failed to write through agent\n");\r\nret = -1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int qla4_8xxx_cmdpeg_ready(struct scsi_qla_host *ha, int pegtune_val)\r\n{\r\nu32 val = 0;\r\nint retries = 60;\r\nif (!pegtune_val) {\r\ndo {\r\nval = qla4_8xxx_rd_32(ha, CRB_CMDPEG_STATE);\r\nif ((val == PHAN_INITIALIZE_COMPLETE) ||\r\n(val == PHAN_INITIALIZE_ACK))\r\nreturn 0;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(500);\r\n} while (--retries);\r\nif (!retries) {\r\npegtune_val = qla4_8xxx_rd_32(ha,\r\nQLA82XX_ROMUSB_GLB_PEGTUNE_DONE);\r\nprintk(KERN_WARNING "%s: init failed, "\r\n"pegtune_val = %x\n", __func__, pegtune_val);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qla4_8xxx_rcvpeg_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t state = 0;\r\nint loops = 0;\r\nread_lock(&ha->hw_lock);\r\nstate = qla4_8xxx_rd_32(ha, CRB_RCVPEG_STATE);\r\nread_unlock(&ha->hw_lock);\r\nwhile ((state != PHAN_PEG_RCV_INITIALIZED) && (loops < 30000)) {\r\nudelay(100);\r\nread_lock(&ha->hw_lock);\r\nstate = qla4_8xxx_rd_32(ha, CRB_RCVPEG_STATE);\r\nread_unlock(&ha->hw_lock);\r\nloops++;\r\n}\r\nif (loops >= 30000) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Receive Peg initialization not complete: 0x%x.\n", state));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nvoid\r\nqla4_8xxx_set_drv_active(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_active;\r\ndrv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\ndrv_active |= (1 << (ha->func_num * 4));\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);\r\n}\r\nvoid\r\nqla4_8xxx_clear_drv_active(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_active;\r\ndrv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\ndrv_active &= ~(1 << (ha->func_num * 4));\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);\r\n}\r\nstatic inline int\r\nqla4_8xxx_need_reset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_state, drv_active;\r\nint rval;\r\ndrv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\ndrv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\nrval = drv_state & (1 << (ha->func_num * 4));\r\nif ((test_bit(AF_EEH_BUSY, &ha->flags)) && drv_active)\r\nrval = 1;\r\nreturn rval;\r\n}\r\nstatic inline void\r\nqla4_8xxx_set_rst_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_state;\r\ndrv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_state |= (1 << (ha->func_num * 4));\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);\r\n}\r\nstatic inline void\r\nqla4_8xxx_clear_rst_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_state;\r\ndrv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_state &= ~(1 << (ha->func_num * 4));\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);\r\n}\r\nstatic inline void\r\nqla4_8xxx_set_qsnt_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t qsnt_state;\r\nqsnt_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\nqsnt_state |= (2 << (ha->func_num * 4));\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);\r\n}\r\nstatic int\r\nqla4_8xxx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)\r\n{\r\nint pcie_cap;\r\nuint16_t lnk;\r\nqla4_8xxx_wr_32(ha, CRB_DMA_SHIFT, 0x55555555);\r\nqla4_8xxx_wr_32(ha, CRB_CMDPEG_STATE, 0);\r\nqla4_8xxx_wr_32(ha, CRB_RCVPEG_STATE, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_PEG_HALT_STATUS1, 0);\r\nqla4_8xxx_wr_32(ha, QLA82XX_PEG_HALT_STATUS2, 0);\r\nif (qla4_8xxx_load_fw(ha, image_start) != QLA_SUCCESS) {\r\nprintk("%s: Error trying to start fw!\n", __func__);\r\nreturn QLA_ERROR;\r\n}\r\nif (qla4_8xxx_cmdpeg_ready(ha, 0) != QLA_SUCCESS) {\r\nprintk("%s: Error during card handshake!\n", __func__);\r\nreturn QLA_ERROR;\r\n}\r\npcie_cap = pci_find_capability(ha->pdev, PCI_CAP_ID_EXP);\r\npci_read_config_word(ha->pdev, pcie_cap + PCI_EXP_LNKSTA, &lnk);\r\nha->link_width = (lnk >> 4) & 0x3f;\r\nreturn qla4_8xxx_rcvpeg_ready(ha);\r\n}\r\nstatic int\r\nqla4_8xxx_try_start_fw(struct scsi_qla_host *ha)\r\n{\r\nint rval = QLA_ERROR;\r\nql4_printk(KERN_INFO, ha,\r\n"FW: Retrieving flash offsets from FLT/FDT ...\n");\r\nrval = qla4_8xxx_get_flash_info(ha);\r\nif (rval != QLA_SUCCESS)\r\nreturn rval;\r\nql4_printk(KERN_INFO, ha,\r\n"FW: Attempting to load firmware from flash...\n");\r\nrval = qla4_8xxx_start_firmware(ha, ha->hw.flt_region_fw);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "FW: Load firmware from flash"\r\n" FAILED...\n");\r\nreturn rval;\r\n}\r\nreturn rval;\r\n}\r\nstatic void qla4_8xxx_rom_lock_recovery(struct scsi_qla_host *ha)\r\n{\r\nif (qla4_8xxx_rom_lock(ha)) {\r\ndev_info(&ha->pdev->dev, "Resetting rom_lock\n");\r\n}\r\nqla4_8xxx_rom_unlock(ha);\r\n}\r\nstatic int\r\nqla4_8xxx_device_bootstrap(struct scsi_qla_host *ha)\r\n{\r\nint rval = QLA_ERROR;\r\nint i, timeout;\r\nuint32_t old_count, count;\r\nint need_reset = 0, peg_stuck = 1;\r\nneed_reset = qla4_8xxx_need_reset(ha);\r\nold_count = qla4_8xxx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);\r\nfor (i = 0; i < 10; i++) {\r\ntimeout = msleep_interruptible(200);\r\nif (timeout) {\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_FAILED);\r\nreturn rval;\r\n}\r\ncount = qla4_8xxx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);\r\nif (count != old_count)\r\npeg_stuck = 0;\r\n}\r\nif (need_reset) {\r\nif (peg_stuck)\r\nqla4_8xxx_rom_lock_recovery(ha);\r\ngoto dev_initialize;\r\n} else {\r\nif (peg_stuck) {\r\nqla4_8xxx_rom_lock_recovery(ha);\r\ngoto dev_initialize;\r\n} else {\r\nrval = QLA_SUCCESS;\r\ngoto dev_ready;\r\n}\r\n}\r\ndev_initialize:\r\nql4_printk(KERN_INFO, ha, "HW State: INITIALIZING\n");\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_INITIALIZING);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_IDC_VERSION, QLA82XX_IDC_VERSION);\r\nqla4_8xxx_idc_unlock(ha);\r\nrval = qla4_8xxx_try_start_fw(ha);\r\nqla4_8xxx_idc_lock(ha);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "HW State: FAILED\n");\r\nqla4_8xxx_clear_drv_active(ha);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_FAILED);\r\nreturn rval;\r\n}\r\ndev_ready:\r\nql4_printk(KERN_INFO, ha, "HW State: READY\n");\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_READY);\r\nreturn rval;\r\n}\r\nstatic void\r\nqla4_8xxx_need_reset_handler(struct scsi_qla_host *ha)\r\n{\r\nuint32_t dev_state, drv_state, drv_active;\r\nunsigned long reset_timeout;\r\nql4_printk(KERN_INFO, ha,\r\n"Performing ISP error recovery\n");\r\nif (test_and_clear_bit(AF_ONLINE, &ha->flags)) {\r\nqla4_8xxx_idc_unlock(ha);\r\nha->isp_ops->disable_intrs(ha);\r\nqla4_8xxx_idc_lock(ha);\r\n}\r\nqla4_8xxx_set_rst_ready(ha);\r\nreset_timeout = jiffies + (ha->nx_reset_timeout * HZ);\r\ndrv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\nql4_printk(KERN_INFO, ha,\r\n"%s(%ld): drv_state = 0x%x, drv_active = 0x%x\n",\r\n__func__, ha->host_no, drv_state, drv_active);\r\nwhile (drv_state != drv_active) {\r\nif (time_after_eq(jiffies, reset_timeout)) {\r\nprintk("%s: RESET TIMEOUT!\n", DRIVER_NAME);\r\nbreak;\r\n}\r\nqla4_8xxx_idc_unlock(ha);\r\nmsleep(1000);\r\nqla4_8xxx_idc_lock(ha);\r\ndrv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\n}\r\ndev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nql4_printk(KERN_INFO, ha, "3:Device state is 0x%x = %s\n", dev_state,\r\ndev_state < MAX_STATES ? qdev_state[dev_state] : "Unknown");\r\nif (dev_state != QLA82XX_DEV_INITIALIZING) {\r\nql4_printk(KERN_INFO, ha, "HW State: COLD/RE-INIT\n");\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_COLD);\r\n}\r\n}\r\nvoid\r\nqla4_8xxx_need_qsnt_handler(struct scsi_qla_host *ha)\r\n{\r\nqla4_8xxx_idc_lock(ha);\r\nqla4_8xxx_set_qsnt_ready(ha);\r\nqla4_8xxx_idc_unlock(ha);\r\n}\r\nint qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)\r\n{\r\nuint32_t dev_state;\r\nint rval = QLA_SUCCESS;\r\nunsigned long dev_init_timeout;\r\nif (!test_bit(AF_INIT_DONE, &ha->flags))\r\nqla4_8xxx_set_drv_active(ha);\r\ndev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nql4_printk(KERN_INFO, ha, "1:Device state is 0x%x = %s\n", dev_state,\r\ndev_state < MAX_STATES ? qdev_state[dev_state] : "Unknown");\r\ndev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);\r\nwhile (1) {\r\nqla4_8xxx_idc_lock(ha);\r\nif (time_after_eq(jiffies, dev_init_timeout)) {\r\nql4_printk(KERN_WARNING, ha, "Device init failed!\n");\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_FAILED);\r\n}\r\ndev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nql4_printk(KERN_INFO, ha,\r\n"2:Device state is 0x%x = %s\n", dev_state,\r\ndev_state < MAX_STATES ? qdev_state[dev_state] : "Unknown");\r\nswitch (dev_state) {\r\ncase QLA82XX_DEV_READY:\r\nqla4_8xxx_idc_unlock(ha);\r\ngoto exit;\r\ncase QLA82XX_DEV_COLD:\r\nrval = qla4_8xxx_device_bootstrap(ha);\r\nqla4_8xxx_idc_unlock(ha);\r\ngoto exit;\r\ncase QLA82XX_DEV_INITIALIZING:\r\nqla4_8xxx_idc_unlock(ha);\r\nmsleep(1000);\r\nbreak;\r\ncase QLA82XX_DEV_NEED_RESET:\r\nif (!ql4xdontresethba) {\r\nqla4_8xxx_need_reset_handler(ha);\r\ndev_init_timeout = jiffies +\r\n(ha->nx_dev_init_timeout * HZ);\r\n}\r\nqla4_8xxx_idc_unlock(ha);\r\nbreak;\r\ncase QLA82XX_DEV_NEED_QUIESCENT:\r\nqla4_8xxx_idc_unlock(ha);\r\nqla4_8xxx_need_qsnt_handler(ha);\r\nqla4_8xxx_idc_lock(ha);\r\ncase QLA82XX_DEV_QUIESCENT:\r\nqla4_8xxx_idc_unlock(ha);\r\nmsleep(1000);\r\nbreak;\r\ncase QLA82XX_DEV_FAILED:\r\nqla4_8xxx_idc_unlock(ha);\r\nqla4xxx_dead_adapter_cleanup(ha);\r\nrval = QLA_ERROR;\r\ngoto exit;\r\ndefault:\r\nqla4_8xxx_idc_unlock(ha);\r\nqla4xxx_dead_adapter_cleanup(ha);\r\nrval = QLA_ERROR;\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nreturn rval;\r\n}\r\nint qla4_8xxx_load_risc(struct scsi_qla_host *ha)\r\n{\r\nint retval;\r\nretval = qla4_8xxx_device_state_handler(ha);\r\nif (retval == QLA_SUCCESS && !test_bit(AF_INIT_DONE, &ha->flags))\r\nretval = qla4xxx_request_irqs(ha);\r\nreturn retval;\r\n}\r\nstatic inline uint32_t\r\nflash_conf_addr(struct ql82xx_hw_data *hw, uint32_t faddr)\r\n{\r\nreturn hw->flash_conf_off | faddr;\r\n}\r\nstatic inline uint32_t\r\nflash_data_addr(struct ql82xx_hw_data *hw, uint32_t faddr)\r\n{\r\nreturn hw->flash_data_off | faddr;\r\n}\r\nstatic uint32_t *\r\nqla4_8xxx_read_flash_data(struct scsi_qla_host *ha, uint32_t *dwptr,\r\nuint32_t faddr, uint32_t length)\r\n{\r\nuint32_t i;\r\nuint32_t val;\r\nint loops = 0;\r\nwhile ((qla4_8xxx_rom_lock(ha) != 0) && (loops < 50000)) {\r\nudelay(100);\r\ncond_resched();\r\nloops++;\r\n}\r\nif (loops >= 50000) {\r\nql4_printk(KERN_WARNING, ha, "ROM lock failed\n");\r\nreturn dwptr;\r\n}\r\nfor (i = 0; i < length/4; i++, faddr += 4) {\r\nif (qla4_8xxx_do_rom_fast_read(ha, faddr, &val)) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Do ROM fast read failed\n");\r\ngoto done_read;\r\n}\r\ndwptr[i] = __constant_cpu_to_le32(val);\r\n}\r\ndone_read:\r\nqla4_8xxx_rom_unlock(ha);\r\nreturn dwptr;\r\n}\r\nstatic uint8_t *\r\nqla4_8xxx_read_optrom_data(struct scsi_qla_host *ha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nqla4_8xxx_read_flash_data(ha, (uint32_t *)buf, offset, length);\r\nreturn buf;\r\n}\r\nstatic int\r\nqla4_8xxx_find_flt_start(struct scsi_qla_host *ha, uint32_t *start)\r\n{\r\nconst char *loc, *locations[] = { "DEF", "PCI" };\r\nloc = locations[0];\r\n*start = FA_FLASH_LAYOUT_ADDR_82;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "FLTL[%s] = 0x%x.\n", loc, *start));\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void\r\nqla4_8xxx_get_flt_info(struct scsi_qla_host *ha, uint32_t flt_addr)\r\n{\r\nconst char *loc, *locations[] = { "DEF", "FLT" };\r\nuint16_t *wptr;\r\nuint16_t cnt, chksum;\r\nuint32_t start;\r\nstruct qla_flt_header *flt;\r\nstruct qla_flt_region *region;\r\nstruct ql82xx_hw_data *hw = &ha->hw;\r\nhw->flt_region_flt = flt_addr;\r\nwptr = (uint16_t *)ha->request_ring;\r\nflt = (struct qla_flt_header *)ha->request_ring;\r\nregion = (struct qla_flt_region *)&flt[1];\r\nqla4_8xxx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\r\nflt_addr << 2, OPTROM_BURST_SIZE);\r\nif (*wptr == __constant_cpu_to_le16(0xffff))\r\ngoto no_flash_data;\r\nif (flt->version != __constant_cpu_to_le16(1)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Unsupported FLT detected: "\r\n"version=0x%x length=0x%x checksum=0x%x.\n",\r\nle16_to_cpu(flt->version), le16_to_cpu(flt->length),\r\nle16_to_cpu(flt->checksum)));\r\ngoto no_flash_data;\r\n}\r\ncnt = (sizeof(struct qla_flt_header) + le16_to_cpu(flt->length)) >> 1;\r\nfor (chksum = 0; cnt; cnt--)\r\nchksum += le16_to_cpu(*wptr++);\r\nif (chksum) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Inconsistent FLT detected: "\r\n"version=0x%x length=0x%x checksum=0x%x.\n",\r\nle16_to_cpu(flt->version), le16_to_cpu(flt->length),\r\nchksum));\r\ngoto no_flash_data;\r\n}\r\nloc = locations[1];\r\ncnt = le16_to_cpu(flt->length) / sizeof(struct qla_flt_region);\r\nfor ( ; cnt; cnt--, region++) {\r\nstart = le32_to_cpu(region->start) >> 2;\r\nDEBUG3(ql4_printk(KERN_DEBUG, ha, "FLT[%02x]: start=0x%x "\r\n"end=0x%x size=0x%x.\n", le32_to_cpu(region->code), start,\r\nle32_to_cpu(region->end) >> 2, le32_to_cpu(region->size)));\r\nswitch (le32_to_cpu(region->code) & 0xff) {\r\ncase FLT_REG_FDT:\r\nhw->flt_region_fdt = start;\r\nbreak;\r\ncase FLT_REG_BOOT_CODE_82:\r\nhw->flt_region_boot = start;\r\nbreak;\r\ncase FLT_REG_FW_82:\r\nhw->flt_region_fw = start;\r\nbreak;\r\ncase FLT_REG_BOOTLOAD_82:\r\nhw->flt_region_bootload = start;\r\nbreak;\r\n}\r\n}\r\ngoto done;\r\nno_flash_data:\r\nloc = locations[0];\r\nhw->flt_region_fdt = FA_FLASH_DESCR_ADDR_82;\r\nhw->flt_region_boot = FA_BOOT_CODE_ADDR_82;\r\nhw->flt_region_bootload = FA_BOOT_LOAD_ADDR_82;\r\nhw->flt_region_fw = FA_RISC_CODE_ADDR_82;\r\ndone:\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "FLT[%s]: flt=0x%x fdt=0x%x "\r\n"boot=0x%x bootload=0x%x fw=0x%x\n", loc, hw->flt_region_flt,\r\nhw->flt_region_fdt, hw->flt_region_boot, hw->flt_region_bootload,\r\nhw->flt_region_fw));\r\n}\r\nstatic void\r\nqla4_8xxx_get_fdt_info(struct scsi_qla_host *ha)\r\n{\r\n#define FLASH_BLK_SIZE_4K 0x1000\r\n#define FLASH_BLK_SIZE_32K 0x8000\r\n#define FLASH_BLK_SIZE_64K 0x10000\r\nconst char *loc, *locations[] = { "MID", "FDT" };\r\nuint16_t cnt, chksum;\r\nuint16_t *wptr;\r\nstruct qla_fdt_layout *fdt;\r\nuint16_t mid = 0;\r\nuint16_t fid = 0;\r\nstruct ql82xx_hw_data *hw = &ha->hw;\r\nhw->flash_conf_off = FARX_ACCESS_FLASH_CONF;\r\nhw->flash_data_off = FARX_ACCESS_FLASH_DATA;\r\nwptr = (uint16_t *)ha->request_ring;\r\nfdt = (struct qla_fdt_layout *)ha->request_ring;\r\nqla4_8xxx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\r\nhw->flt_region_fdt << 2, OPTROM_BURST_SIZE);\r\nif (*wptr == __constant_cpu_to_le16(0xffff))\r\ngoto no_flash_data;\r\nif (fdt->sig[0] != 'Q' || fdt->sig[1] != 'L' || fdt->sig[2] != 'I' ||\r\nfdt->sig[3] != 'D')\r\ngoto no_flash_data;\r\nfor (cnt = 0, chksum = 0; cnt < sizeof(struct qla_fdt_layout) >> 1;\r\ncnt++)\r\nchksum += le16_to_cpu(*wptr++);\r\nif (chksum) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Inconsistent FDT detected: "\r\n"checksum=0x%x id=%c version=0x%x.\n", chksum, fdt->sig[0],\r\nle16_to_cpu(fdt->version)));\r\ngoto no_flash_data;\r\n}\r\nloc = locations[1];\r\nmid = le16_to_cpu(fdt->man_id);\r\nfid = le16_to_cpu(fdt->id);\r\nhw->fdt_wrt_disable = fdt->wrt_disable_bits;\r\nhw->fdt_erase_cmd = flash_conf_addr(hw, 0x0300 | fdt->erase_cmd);\r\nhw->fdt_block_size = le32_to_cpu(fdt->block_size);\r\nif (fdt->unprotect_sec_cmd) {\r\nhw->fdt_unprotect_sec_cmd = flash_conf_addr(hw, 0x0300 |\r\nfdt->unprotect_sec_cmd);\r\nhw->fdt_protect_sec_cmd = fdt->protect_sec_cmd ?\r\nflash_conf_addr(hw, 0x0300 | fdt->protect_sec_cmd) :\r\nflash_conf_addr(hw, 0x0336);\r\n}\r\ngoto done;\r\nno_flash_data:\r\nloc = locations[0];\r\nhw->fdt_block_size = FLASH_BLK_SIZE_64K;\r\ndone:\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "FDT[%s]: (0x%x/0x%x) erase=0x%x "\r\n"pro=%x upro=%x wrtd=0x%x blk=0x%x.\n", loc, mid, fid,\r\nhw->fdt_erase_cmd, hw->fdt_protect_sec_cmd,\r\nhw->fdt_unprotect_sec_cmd, hw->fdt_wrt_disable,\r\nhw->fdt_block_size));\r\n}\r\nstatic void\r\nqla4_8xxx_get_idc_param(struct scsi_qla_host *ha)\r\n{\r\n#define QLA82XX_IDC_PARAM_ADDR 0x003e885c\r\nuint32_t *wptr;\r\nif (!is_qla8022(ha))\r\nreturn;\r\nwptr = (uint32_t *)ha->request_ring;\r\nqla4_8xxx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\r\nQLA82XX_IDC_PARAM_ADDR , 8);\r\nif (*wptr == __constant_cpu_to_le32(0xffffffff)) {\r\nha->nx_dev_init_timeout = ROM_DEV_INIT_TIMEOUT;\r\nha->nx_reset_timeout = ROM_DRV_RESET_ACK_TIMEOUT;\r\n} else {\r\nha->nx_dev_init_timeout = le32_to_cpu(*wptr++);\r\nha->nx_reset_timeout = le32_to_cpu(*wptr);\r\n}\r\nDEBUG2(ql4_printk(KERN_DEBUG, ha,\r\n"ha->nx_dev_init_timeout = %d\n", ha->nx_dev_init_timeout));\r\nDEBUG2(ql4_printk(KERN_DEBUG, ha,\r\n"ha->nx_reset_timeout = %d\n", ha->nx_reset_timeout));\r\nreturn;\r\n}\r\nint\r\nqla4_8xxx_get_flash_info(struct scsi_qla_host *ha)\r\n{\r\nint ret;\r\nuint32_t flt_addr;\r\nret = qla4_8xxx_find_flt_start(ha, &flt_addr);\r\nif (ret != QLA_SUCCESS)\r\nreturn ret;\r\nqla4_8xxx_get_flt_info(ha, flt_addr);\r\nqla4_8xxx_get_fdt_info(ha);\r\nqla4_8xxx_get_idc_param(ha);\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla4_8xxx_stop_firmware(struct scsi_qla_host *ha)\r\n{\r\nint status;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_STOP_FW;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1,\r\n&mbox_cmd[0], &mbox_sts[0]);\r\nDEBUG2(printk("scsi%ld: %s: status = %d\n", ha->host_no,\r\n__func__, status));\r\nreturn status;\r\n}\r\nint\r\nqla4_8xxx_isp_reset(struct scsi_qla_host *ha)\r\n{\r\nint rval;\r\nuint32_t dev_state;\r\nqla4_8xxx_idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nif (dev_state == QLA82XX_DEV_READY) {\r\nql4_printk(KERN_INFO, ha, "HW State: NEED RESET\n");\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_NEED_RESET);\r\n} else\r\nql4_printk(KERN_INFO, ha, "HW State: DEVICE INITIALIZING\n");\r\nqla4_8xxx_idc_unlock(ha);\r\nrval = qla4_8xxx_device_state_handler(ha);\r\nqla4_8xxx_idc_lock(ha);\r\nqla4_8xxx_clear_rst_ready(ha);\r\nqla4_8xxx_idc_unlock(ha);\r\nif (rval == QLA_SUCCESS)\r\nclear_bit(AF_FW_RECOVERY, &ha->flags);\r\nreturn rval;\r\n}\r\nint qla4_8xxx_get_sys_info(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nstruct mbx_sys_info *sys_info;\r\ndma_addr_t sys_info_dma;\r\nint status = QLA_ERROR;\r\nsys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),\r\n&sys_info_dma, GFP_KERNEL);\r\nif (sys_info == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",\r\nha->host_no, __func__));\r\nreturn status;\r\n}\r\nmemset(sys_info, 0, sizeof(*sys_info));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_SYS_INFO;\r\nmbox_cmd[1] = LSDW(sys_info_dma);\r\nmbox_cmd[2] = MSDW(sys_info_dma);\r\nmbox_cmd[4] = sizeof(*sys_info);\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 6, &mbox_cmd[0],\r\n&mbox_sts[0]) != QLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: GET_SYS_INFO failed\n",\r\nha->host_no, __func__));\r\ngoto exit_validate_mac82;\r\n}\r\nif (mbox_sts[4] < offsetof(struct mbx_sys_info, reserved)) {\r\nDEBUG2(printk("scsi%ld: %s: GET_SYS_INFO data receive"\r\n" error (%x)\n", ha->host_no, __func__, mbox_sts[4]));\r\ngoto exit_validate_mac82;\r\n}\r\nmemcpy(ha->my_mac, &sys_info->mac_addr[0],\r\nmin(sizeof(ha->my_mac), sizeof(sys_info->mac_addr)));\r\nmemcpy(ha->serial_number, &sys_info->serial_number,\r\nmin(sizeof(ha->serial_number), sizeof(sys_info->serial_number)));\r\nDEBUG2(printk("scsi%ld: %s: "\r\n"mac %02x:%02x:%02x:%02x:%02x:%02x "\r\n"serial %s\n", ha->host_no, __func__,\r\nha->my_mac[0], ha->my_mac[1], ha->my_mac[2],\r\nha->my_mac[3], ha->my_mac[4], ha->my_mac[5],\r\nha->serial_number));\r\nstatus = QLA_SUCCESS;\r\nexit_validate_mac82:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,\r\nsys_info_dma);\r\nreturn status;\r\n}\r\nstatic int\r\nqla4_8xxx_mbx_intr_enable(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s\n", __func__));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_ENABLE_INTRS;\r\nmbox_cmd[1] = INTR_ENABLE;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\r\n&mbox_sts[0]) != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: MBOX_CMD_ENABLE_INTRS failed (0x%04x)\n",\r\n__func__, mbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int\r\nqla4_8xxx_mbx_intr_disable(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s\n", __func__));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_ENABLE_INTRS;\r\nmbox_cmd[1] = INTR_DISABLE;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\r\n&mbox_sts[0]) != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: MBOX_CMD_ENABLE_INTRS failed (0x%04x)\n",\r\n__func__, mbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nvoid\r\nqla4_8xxx_enable_intrs(struct scsi_qla_host *ha)\r\n{\r\nqla4_8xxx_mbx_intr_enable(ha);\r\nspin_lock_irq(&ha->hardware_lock);\r\nqla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\r\nspin_unlock_irq(&ha->hardware_lock);\r\nset_bit(AF_INTERRUPTS_ON, &ha->flags);\r\n}\r\nvoid\r\nqla4_8xxx_disable_intrs(struct scsi_qla_host *ha)\r\n{\r\nif (test_and_clear_bit(AF_INTERRUPTS_ON, &ha->flags))\r\nqla4_8xxx_mbx_intr_disable(ha);\r\nspin_lock_irq(&ha->hardware_lock);\r\nqla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);\r\nspin_unlock_irq(&ha->hardware_lock);\r\n}\r\nvoid\r\nqla4_8xxx_disable_msix(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nstruct ql4_msix_entry *qentry;\r\nfor (i = 0; i < QLA_MSIX_ENTRIES; i++) {\r\nqentry = &ha->msix_entries[qla4_8xxx_msix_entries[i].index];\r\nif (qentry->have_irq) {\r\nfree_irq(qentry->msix_vector, ha);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: %s\n",\r\n__func__, qla4_8xxx_msix_entries[i].name));\r\n}\r\n}\r\npci_disable_msix(ha->pdev);\r\nclear_bit(AF_MSIX_ENABLED, &ha->flags);\r\n}\r\nint\r\nqla4_8xxx_enable_msix(struct scsi_qla_host *ha)\r\n{\r\nint i, ret;\r\nstruct msix_entry entries[QLA_MSIX_ENTRIES];\r\nstruct ql4_msix_entry *qentry;\r\nfor (i = 0; i < QLA_MSIX_ENTRIES; i++)\r\nentries[i].entry = qla4_8xxx_msix_entries[i].entry;\r\nret = pci_enable_msix(ha->pdev, entries, ARRAY_SIZE(entries));\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha,\r\n"MSI-X: Failed to enable support -- %d/%d\n",\r\nQLA_MSIX_ENTRIES, ret);\r\ngoto msix_out;\r\n}\r\nset_bit(AF_MSIX_ENABLED, &ha->flags);\r\nfor (i = 0; i < QLA_MSIX_ENTRIES; i++) {\r\nqentry = &ha->msix_entries[qla4_8xxx_msix_entries[i].index];\r\nqentry->msix_vector = entries[i].vector;\r\nqentry->msix_entry = entries[i].entry;\r\nqentry->have_irq = 0;\r\nret = request_irq(qentry->msix_vector,\r\nqla4_8xxx_msix_entries[i].handler, 0,\r\nqla4_8xxx_msix_entries[i].name, ha);\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha,\r\n"MSI-X: Unable to register handler -- %x/%d.\n",\r\nqla4_8xxx_msix_entries[i].index, ret);\r\nqla4_8xxx_disable_msix(ha);\r\ngoto msix_out;\r\n}\r\nqentry->have_irq = 1;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: %s\n",\r\n__func__, qla4_8xxx_msix_entries[i].name));\r\n}\r\nmsix_out:\r\nreturn ret;\r\n}
