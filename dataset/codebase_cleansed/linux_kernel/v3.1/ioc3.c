static inline unsigned mcr_pack(unsigned pulse, unsigned sample)\r\n{\r\nreturn (pulse << 10) | (sample << 2);\r\n}\r\nstatic int nic_wait(struct ioc3_driver_data *idd)\r\n{\r\nunsigned mcr;\r\ndo {\r\nmcr = readl(&idd->vma->mcr);\r\n} while (!(mcr & 2));\r\nreturn mcr & 1;\r\n}\r\nstatic int nic_reset(struct ioc3_driver_data *idd)\r\n{\r\nint presence;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nwritel(mcr_pack(500, 65), &idd->vma->mcr);\r\npresence = nic_wait(idd);\r\nlocal_irq_restore(flags);\r\nudelay(500);\r\nreturn presence;\r\n}\r\nstatic int nic_read_bit(struct ioc3_driver_data *idd)\r\n{\r\nint result;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nwritel(mcr_pack(6, 13), &idd->vma->mcr);\r\nresult = nic_wait(idd);\r\nlocal_irq_restore(flags);\r\nudelay(500);\r\nreturn result;\r\n}\r\nstatic void nic_write_bit(struct ioc3_driver_data *idd, int bit)\r\n{\r\nif (bit)\r\nwritel(mcr_pack(6, 110), &idd->vma->mcr);\r\nelse\r\nwritel(mcr_pack(80, 30), &idd->vma->mcr);\r\nnic_wait(idd);\r\n}\r\nstatic unsigned nic_read_byte(struct ioc3_driver_data *idd)\r\n{\r\nunsigned result = 0;\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\nresult = (result >> 1) | (nic_read_bit(idd) << 7);\r\nreturn result;\r\n}\r\nstatic void nic_write_byte(struct ioc3_driver_data *idd, int byte)\r\n{\r\nint i, bit;\r\nfor (i = 8; i; i--) {\r\nbit = byte & 1;\r\nbyte >>= 1;\r\nnic_write_bit(idd, bit);\r\n}\r\n}\r\nstatic unsigned long\r\nnic_find(struct ioc3_driver_data *idd, int *last, unsigned long addr)\r\n{\r\nint a, b, index, disc;\r\nnic_reset(idd);\r\nnic_write_byte(idd, 0xF0);\r\nfor (index = 0, disc = 0; index < 64; index++) {\r\na = nic_read_bit(idd);\r\nb = nic_read_bit(idd);\r\nif (a && b) {\r\nprintk(KERN_WARNING "IOC3 NIC search failed.\n");\r\n*last = 0;\r\nreturn 0;\r\n}\r\nif (!a && !b) {\r\nif (index == *last) {\r\naddr |= 1UL << index;\r\n} else if (index > *last) {\r\naddr &= ~(1UL << index);\r\ndisc = index;\r\n} else if ((addr & (1UL << index)) == 0)\r\ndisc = index;\r\nnic_write_bit(idd, (addr>>index)&1);\r\ncontinue;\r\n} else {\r\nif (a)\r\naddr |= 1UL << index;\r\nelse\r\naddr &= ~(1UL << index);\r\nnic_write_bit(idd, a);\r\ncontinue;\r\n}\r\n}\r\n*last = disc;\r\nreturn addr;\r\n}\r\nstatic void nic_addr(struct ioc3_driver_data *idd, unsigned long addr)\r\n{\r\nint index;\r\nnic_reset(idd);\r\nnic_write_byte(idd, 0xF0);\r\nfor (index = 0; index < 64; index++) {\r\nnic_read_bit(idd);\r\nnic_read_bit(idd);\r\nnic_write_bit(idd, (addr>>index)&1);\r\n}\r\n}\r\nstatic void crc16_byte(unsigned int *crc, unsigned char db)\r\n{\r\nint i;\r\nfor(i=0;i<8;i++) {\r\n*crc <<= 1;\r\nif((db^(*crc>>16)) & 1)\r\n*crc ^= 0x8005;\r\ndb >>= 1;\r\n}\r\n*crc &= 0xFFFF;\r\n}\r\nstatic unsigned int crc16_area(unsigned char *dbs, int size, unsigned int crc)\r\n{\r\nwhile(size--)\r\ncrc16_byte(&crc, *(dbs++));\r\nreturn crc;\r\n}\r\nstatic void crc8_byte(unsigned int *crc, unsigned char db)\r\n{\r\nint i,f;\r\nfor(i=0;i<8;i++) {\r\nf = (*crc ^ db) & 1;\r\n*crc >>= 1;\r\ndb >>= 1;\r\nif(f)\r\n*crc ^= 0x8c;\r\n}\r\n*crc &= 0xff;\r\n}\r\nstatic unsigned int crc8_addr(unsigned long addr)\r\n{\r\nint i;\r\nunsigned int crc = 0x00;\r\nfor(i=0;i<8;i++)\r\ncrc8_byte(&crc, addr>>(i<<3));\r\nreturn crc;\r\n}\r\nstatic void\r\nread_redir_page(struct ioc3_driver_data *idd, unsigned long addr, int page,\r\nunsigned char *redir, unsigned char *data)\r\n{\r\nint loops = 16, i;\r\nwhile(redir[page] != 0xFF) {\r\npage = redir[page]^0xFF;\r\nloops--;\r\nif(loops<0) {\r\nprintk(KERN_ERR "IOC3: NIC circular redirection\n");\r\nreturn;\r\n}\r\n}\r\nloops = 3;\r\nwhile(loops>0) {\r\nnic_addr(idd, addr);\r\nnic_write_byte(idd, 0xF0);\r\nnic_write_byte(idd, (page << 5) & 0xE0);\r\nnic_write_byte(idd, (page >> 3) & 0x1F);\r\nfor(i=0;i<0x20;i++)\r\ndata[i] = nic_read_byte(idd);\r\nif(crc16_area(data, 0x20, 0x0000) == 0x800d)\r\nreturn;\r\nloops--;\r\n}\r\nprintk(KERN_ERR "IOC3: CRC error in data page\n");\r\nfor(i=0;i<0x20;i++)\r\ndata[i] = 0x00;\r\n}\r\nstatic void\r\nread_redir_map(struct ioc3_driver_data *idd, unsigned long addr,\r\nunsigned char *redir)\r\n{\r\nint i,j,loops = 3,crc_ok;\r\nunsigned int crc;\r\nwhile(loops>0) {\r\ncrc_ok = 1;\r\nnic_addr(idd, addr);\r\nnic_write_byte(idd, 0xAA);\r\nnic_write_byte(idd, 0x00);\r\nnic_write_byte(idd, 0x01);\r\nfor(i=0;i<64;i+=8) {\r\nfor(j=0;j<8;j++)\r\nredir[i+j] = nic_read_byte(idd);\r\ncrc = crc16_area(redir+i, 8, (i==0)?0x8707:0x0000);\r\ncrc16_byte(&crc, nic_read_byte(idd));\r\ncrc16_byte(&crc, nic_read_byte(idd));\r\nif(crc != 0x800d)\r\ncrc_ok = 0;\r\n}\r\nif(crc_ok)\r\nreturn;\r\nloops--;\r\n}\r\nprintk(KERN_ERR "IOC3: CRC error in redirection page\n");\r\nfor(i=0;i<64;i++)\r\nredir[i] = 0xFF;\r\n}\r\nstatic void read_nic(struct ioc3_driver_data *idd, unsigned long addr)\r\n{\r\nunsigned char redir[64];\r\nunsigned char data[64],part[32];\r\nint i,j;\r\nread_redir_map(idd, addr, redir);\r\nread_redir_page(idd, addr, 0, redir, data);\r\nread_redir_page(idd, addr, 1, redir, data+32);\r\nj=0;\r\nfor(i=0;i<19;i++)\r\nif(data[i+11] != ' ')\r\npart[j++] = data[i+11];\r\nfor(i=0;i<6;i++)\r\nif(data[i+32] != ' ')\r\npart[j++] = data[i+32];\r\npart[j] = 0;\r\nif(!strncmp(part, "060-0035-", 9))\r\nreturn;\r\nif(!strncmp(part, "060-0038-", 9))\r\nreturn;\r\nstrcpy(idd->nic_part, part);\r\nj=0;\r\nfor(i=0;i<10;i++)\r\nif(data[i+1] != ' ')\r\nidd->nic_serial[j++] = data[i+1];\r\nidd->nic_serial[j] = 0;\r\n}\r\nstatic void read_mac(struct ioc3_driver_data *idd, unsigned long addr)\r\n{\r\nint i, loops = 3;\r\nunsigned char data[13];\r\nwhile(loops>0) {\r\nnic_addr(idd, addr);\r\nnic_write_byte(idd, 0xF0);\r\nnic_write_byte(idd, 0x00);\r\nnic_write_byte(idd, 0x00);\r\nnic_read_byte(idd);\r\nfor(i=0;i<13;i++)\r\ndata[i] = nic_read_byte(idd);\r\nif(crc16_area(data, 13, 0x0000) == 0x800d) {\r\nfor(i=10;i>4;i--)\r\nidd->nic_mac[10-i] = data[i];\r\nreturn;\r\n}\r\nloops--;\r\n}\r\nprintk(KERN_ERR "IOC3: CRC error in MAC address\n");\r\nfor(i=0;i<6;i++)\r\nidd->nic_mac[i] = 0x00;\r\n}\r\nstatic void probe_nic(struct ioc3_driver_data *idd)\r\n{\r\nint save = 0, loops = 3;\r\nunsigned long first, addr;\r\nwritel(GPCR_MLAN_EN, &idd->vma->gpcr_s);\r\nwhile(loops>0) {\r\nidd->nic_part[0] = 0;\r\nidd->nic_serial[0] = 0;\r\naddr = first = nic_find(idd, &save, 0);\r\nif(!first)\r\nreturn;\r\nwhile(1) {\r\nif(crc8_addr(addr))\r\nbreak;\r\nelse {\r\nswitch(addr & 0xFF) {\r\ncase 0x0B:\r\nread_nic(idd, addr);\r\nbreak;\r\ncase 0x09:\r\ncase 0x89:\r\ncase 0x91:\r\nread_mac(idd, addr);\r\nbreak;\r\n}\r\n}\r\naddr = nic_find(idd, &save, addr);\r\nif(addr == first)\r\nreturn;\r\n}\r\nloops--;\r\n}\r\nprintk(KERN_ERR "IOC3: CRC error in NIC address\n");\r\n}\r\nstatic void write_ireg(struct ioc3_driver_data *idd, uint32_t val, int which)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&idd->ir_lock, flags);\r\nswitch (which) {\r\ncase IOC3_W_IES:\r\nwritel(val, &idd->vma->sio_ies);\r\nbreak;\r\ncase IOC3_W_IEC:\r\nwritel(val, &idd->vma->sio_iec);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&idd->ir_lock, flags);\r\n}\r\nstatic inline uint32_t get_pending_intrs(struct ioc3_driver_data *idd)\r\n{\r\nunsigned long flag;\r\nuint32_t intrs = 0;\r\nspin_lock_irqsave(&idd->ir_lock, flag);\r\nintrs = readl(&idd->vma->sio_ir);\r\nintrs &= readl(&idd->vma->sio_ies);\r\nspin_unlock_irqrestore(&idd->ir_lock, flag);\r\nreturn intrs;\r\n}\r\nstatic irqreturn_t ioc3_intr_io(int irq, void *arg)\r\n{\r\nunsigned long flags;\r\nstruct ioc3_driver_data *idd = arg;\r\nint handled = 1, id;\r\nunsigned int pending;\r\nread_lock_irqsave(&ioc3_submodules_lock, flags);\r\nif(idd->dual_irq && readb(&idd->vma->eisr)) {\r\nif(ioc3_ethernet && idd->active[ioc3_ethernet->id] &&\r\nioc3_ethernet->intr) {\r\nhandled = handled && !ioc3_ethernet->intr(ioc3_ethernet,\r\nidd, 0);\r\n}\r\n}\r\npending = get_pending_intrs(idd);\r\nfor(id=0;id<IOC3_MAX_SUBMODULES;id++) {\r\nif(idd->active[id] && ioc3_submodules[id]\r\n&& (pending & ioc3_submodules[id]->irq_mask)\r\n&& ioc3_submodules[id]->intr) {\r\nwrite_ireg(idd, ioc3_submodules[id]->irq_mask,\r\nIOC3_W_IEC);\r\nif(!ioc3_submodules[id]->intr(ioc3_submodules[id],\r\nidd, pending & ioc3_submodules[id]->irq_mask))\r\npending &= ~ioc3_submodules[id]->irq_mask;\r\nif (ioc3_submodules[id]->reset_mask)\r\nwrite_ireg(idd, ioc3_submodules[id]->irq_mask,\r\nIOC3_W_IES);\r\n}\r\n}\r\nread_unlock_irqrestore(&ioc3_submodules_lock, flags);\r\nif(pending) {\r\nprintk(KERN_WARNING\r\n"IOC3: Pending IRQs 0x%08x discarded and disabled\n",pending);\r\nwrite_ireg(idd, pending, IOC3_W_IEC);\r\nhandled = 1;\r\n}\r\nreturn handled?IRQ_HANDLED:IRQ_NONE;\r\n}\r\nstatic irqreturn_t ioc3_intr_eth(int irq, void *arg)\r\n{\r\nunsigned long flags;\r\nstruct ioc3_driver_data *idd = (struct ioc3_driver_data *)arg;\r\nint handled = 1;\r\nif(!idd->dual_irq)\r\nreturn IRQ_NONE;\r\nread_lock_irqsave(&ioc3_submodules_lock, flags);\r\nif(ioc3_ethernet && idd->active[ioc3_ethernet->id]\r\n&& ioc3_ethernet->intr)\r\nhandled = handled && !ioc3_ethernet->intr(ioc3_ethernet, idd, 0);\r\nread_unlock_irqrestore(&ioc3_submodules_lock, flags);\r\nreturn handled?IRQ_HANDLED:IRQ_NONE;\r\n}\r\nvoid ioc3_enable(struct ioc3_submodule *is,\r\nstruct ioc3_driver_data *idd, unsigned int irqs)\r\n{\r\nwrite_ireg(idd, irqs & is->irq_mask, IOC3_W_IES);\r\n}\r\nvoid ioc3_ack(struct ioc3_submodule *is, struct ioc3_driver_data *idd,\r\nunsigned int irqs)\r\n{\r\nwritel(irqs & is->irq_mask, &idd->vma->sio_ir);\r\n}\r\nvoid ioc3_disable(struct ioc3_submodule *is,\r\nstruct ioc3_driver_data *idd, unsigned int irqs)\r\n{\r\nwrite_ireg(idd, irqs & is->irq_mask, IOC3_W_IEC);\r\n}\r\nvoid ioc3_gpcr_set(struct ioc3_driver_data *idd, unsigned int val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&idd->gpio_lock, flags);\r\nwritel(val, &idd->vma->gpcr_s);\r\nspin_unlock_irqrestore(&idd->gpio_lock, flags);\r\n}\r\nstatic int find_slot(void **tab, int max)\r\n{\r\nint i;\r\nfor(i=0;i<max;i++)\r\nif(!(tab[i]))\r\nreturn i;\r\nreturn -1;\r\n}\r\nint ioc3_register_submodule(struct ioc3_submodule *is)\r\n{\r\nstruct ioc3_driver_data *idd;\r\nint alloc_id;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&ioc3_submodules_lock, flags);\r\nalloc_id = find_slot((void **)ioc3_submodules, IOC3_MAX_SUBMODULES);\r\nif(alloc_id != -1) {\r\nioc3_submodules[alloc_id] = is;\r\nif(is->ethernet) {\r\nif(ioc3_ethernet==NULL)\r\nioc3_ethernet=is;\r\nelse\r\nprintk(KERN_WARNING\r\n"IOC3 Ethernet module already registered!\n");\r\n}\r\n}\r\nwrite_unlock_irqrestore(&ioc3_submodules_lock, flags);\r\nif(alloc_id == -1) {\r\nprintk(KERN_WARNING "Increase IOC3_MAX_SUBMODULES!\n");\r\nreturn -ENOMEM;\r\n}\r\nis->id=alloc_id;\r\nif (!is->probe)\r\nreturn 0;\r\ndown_read(&ioc3_devices_rwsem);\r\nlist_for_each_entry(idd, &ioc3_devices, list) {\r\nidd->active[alloc_id] = 1;\r\nidd->active[alloc_id] = !is->probe(is, idd);\r\n}\r\nup_read(&ioc3_devices_rwsem);\r\nreturn 0;\r\n}\r\nvoid ioc3_unregister_submodule(struct ioc3_submodule *is)\r\n{\r\nstruct ioc3_driver_data *idd;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&ioc3_submodules_lock, flags);\r\nif(ioc3_submodules[is->id]==is)\r\nioc3_submodules[is->id]=NULL;\r\nelse\r\nprintk(KERN_WARNING\r\n"IOC3 submodule %s has wrong ID.\n",is->name);\r\nif(ioc3_ethernet==is)\r\nioc3_ethernet = NULL;\r\nwrite_unlock_irqrestore(&ioc3_submodules_lock, flags);\r\ndown_read(&ioc3_devices_rwsem);\r\nlist_for_each_entry(idd, &ioc3_devices, list)\r\nif(idd->active[is->id]) {\r\nif(is->remove)\r\nif(is->remove(is, idd))\r\nprintk(KERN_WARNING\r\n"%s: IOC3 submodule %s remove failed "\r\n"for pci_dev %s.\n",\r\n__func__, module_name(is->owner),\r\npci_name(idd->pdev));\r\nidd->active[is->id] = 0;\r\nif(is->irq_mask)\r\nwrite_ireg(idd, is->irq_mask, IOC3_W_IEC);\r\n}\r\nup_read(&ioc3_devices_rwsem);\r\n}\r\nstatic int __devinit ioc3_class(struct ioc3_driver_data *idd)\r\n{\r\nint res = IOC3_CLASS_NONE;\r\nif(!strncmp(idd->nic_part, "030-0891-", 9))\r\nres = IOC3_CLASS_BASE_IP30;\r\nif(!strncmp(idd->nic_part, "030-1155-", 9))\r\nres = IOC3_CLASS_CADDUO;\r\nif(!strncmp(idd->nic_part, "030-1657-", 9))\r\nres = IOC3_CLASS_SERIAL;\r\nif(!strncmp(idd->nic_part, "030-1664-", 9))\r\nres = IOC3_CLASS_SERIAL;\r\n#ifdef CONFIG_SGI_IP27\r\nif(!idd->nic_part[0])\r\nres = IOC3_CLASS_BASE_IP27;\r\n#endif\r\nprintk(KERN_INFO "IOC3 part: [%s], serial: [%s] => class %s\n",\r\nidd->nic_part, idd->nic_serial, ioc3_class_names[res]);\r\nreturn res;\r\n}\r\nstatic int __devinit\r\nioc3_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)\r\n{\r\nstruct ioc3_driver_data *idd;\r\nuint32_t pcmd;\r\nint ret, id;\r\nif ((ret = pci_enable_device(pdev))) {\r\nprintk(KERN_WARNING\r\n"%s: Failed to enable IOC3 device for pci_dev %s.\n",\r\n__func__, pci_name(pdev));\r\ngoto out;\r\n}\r\npci_set_master(pdev);\r\n#ifdef USE_64BIT_DMA\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (!ret) {\r\nret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "%s: Unable to obtain 64 bit DMA "\r\n"for consistent allocations\n",\r\n__func__);\r\n}\r\n}\r\n#endif\r\nidd = kzalloc(sizeof(struct ioc3_driver_data), GFP_KERNEL);\r\nif (!idd) {\r\nprintk(KERN_WARNING\r\n"%s: Failed to allocate IOC3 data for pci_dev %s.\n",\r\n__func__, pci_name(pdev));\r\nret = -ENODEV;\r\ngoto out_idd;\r\n}\r\nspin_lock_init(&idd->ir_lock);\r\nspin_lock_init(&idd->gpio_lock);\r\nidd->pdev = pdev;\r\nidd->pma = pci_resource_start(pdev, 0);\r\nif (!idd->pma) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to find IOC3 resource "\r\n"for pci_dev %s.\n",\r\n__func__, pci_name(pdev));\r\nret = -ENODEV;\r\ngoto out_pci;\r\n}\r\nif (!request_mem_region(idd->pma, IOC3_PCI_SIZE, "ioc3")) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to request IOC3 region "\r\n"for pci_dev %s.\n",\r\n__func__, pci_name(pdev));\r\nret = -ENODEV;\r\ngoto out_pci;\r\n}\r\nidd->vma = ioremap(idd->pma, IOC3_PCI_SIZE);\r\nif (!idd->vma) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to remap IOC3 region "\r\n"for pci_dev %s.\n",\r\n__func__, pci_name(pdev));\r\nret = -ENODEV;\r\ngoto out_misc_region;\r\n}\r\npci_set_drvdata(pdev, idd);\r\ndown_write(&ioc3_devices_rwsem);\r\nlist_add_tail(&idd->list, &ioc3_devices);\r\nidd->id = ioc3_counter++;\r\nup_write(&ioc3_devices_rwsem);\r\nidd->gpdr_shadow = readl(&idd->vma->gpdr);\r\nprobe_nic(idd);\r\nidd->class = ioc3_class(idd);\r\npci_read_config_dword(pdev, PCI_COMMAND, &pcmd);\r\npci_write_config_dword(pdev, PCI_COMMAND,\r\npcmd | PCI_COMMAND_MEMORY |\r\nPCI_COMMAND_PARITY | PCI_COMMAND_SERR |\r\nPCI_SCR_DROP_MODE_EN);\r\nwrite_ireg(idd, ~0, IOC3_W_IEC);\r\nwritel(~0, &idd->vma->sio_ir);\r\nif(idd->class == IOC3_CLASS_BASE_IP30\r\n|| idd->class == IOC3_CLASS_BASE_IP27) {\r\nwritel(0, &idd->vma->eier);\r\nwritel(~0, &idd->vma->eisr);\r\nidd->dual_irq = 1;\r\nif (!request_irq(pdev->irq, ioc3_intr_eth, IRQF_SHARED,\r\n"ioc3-eth", (void *)idd)) {\r\nidd->irq_eth = pdev->irq;\r\n} else {\r\nprintk(KERN_WARNING\r\n"%s : request_irq fails for IRQ 0x%x\n ",\r\n__func__, pdev->irq);\r\n}\r\nif (!request_irq(pdev->irq+2, ioc3_intr_io, IRQF_SHARED,\r\n"ioc3-io", (void *)idd)) {\r\nidd->irq_io = pdev->irq+2;\r\n} else {\r\nprintk(KERN_WARNING\r\n"%s : request_irq fails for IRQ 0x%x\n ",\r\n__func__, pdev->irq+2);\r\n}\r\n} else {\r\nif (!request_irq(pdev->irq, ioc3_intr_io, IRQF_SHARED,\r\n"ioc3", (void *)idd)) {\r\nidd->irq_io = pdev->irq;\r\n} else {\r\nprintk(KERN_WARNING\r\n"%s : request_irq fails for IRQ 0x%x\n ",\r\n__func__, pdev->irq);\r\n}\r\n}\r\nfor(id=0;id<IOC3_MAX_SUBMODULES;id++)\r\nif(ioc3_submodules[id] && ioc3_submodules[id]->probe) {\r\nidd->active[id] = 1;\r\nidd->active[id] = !ioc3_submodules[id]->probe\r\n(ioc3_submodules[id], idd);\r\n}\r\nprintk(KERN_INFO "IOC3 Master Driver loaded for %s\n", pci_name(pdev));\r\nreturn 0;\r\nout_misc_region:\r\nrelease_mem_region(idd->pma, IOC3_PCI_SIZE);\r\nout_pci:\r\nkfree(idd);\r\nout_idd:\r\npci_disable_device(pdev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __devexit ioc3_remove(struct pci_dev *pdev)\r\n{\r\nint id;\r\nstruct ioc3_driver_data *idd;\r\nidd = pci_get_drvdata(pdev);\r\nfor(id=0;id<IOC3_MAX_SUBMODULES;id++)\r\nif(idd->active[id]) {\r\nif(ioc3_submodules[id] && ioc3_submodules[id]->remove)\r\nif(ioc3_submodules[id]->remove(ioc3_submodules[id],\r\nidd))\r\nprintk(KERN_WARNING\r\n"%s: IOC3 submodule 0x%s remove failed "\r\n"for pci_dev %s.\n",\r\n__func__,\r\nmodule_name(ioc3_submodules[id]->owner),\r\npci_name(pdev));\r\nidd->active[id] = 0;\r\n}\r\nwrite_ireg(idd, ~0, IOC3_W_IEC);\r\nwritel(~0, &idd->vma->sio_ir);\r\nfree_irq(idd->irq_io, (void *)idd);\r\nif(idd->dual_irq)\r\nfree_irq(idd->irq_eth, (void *)idd);\r\niounmap(idd->vma);\r\nrelease_mem_region(idd->pma, IOC3_PCI_SIZE);\r\npci_disable_device(pdev);\r\ndown_write(&ioc3_devices_rwsem);\r\nlist_del(&idd->list);\r\nup_write(&ioc3_devices_rwsem);\r\nkfree(idd);\r\n}\r\nstatic int __init ioc3_init(void)\r\n{\r\nif (ia64_platform_is("sn2"))\r\nreturn pci_register_driver(&ioc3_driver);\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit ioc3_exit(void)\r\n{\r\npci_unregister_driver(&ioc3_driver);\r\n}
