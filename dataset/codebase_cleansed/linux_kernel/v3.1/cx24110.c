static int cx24110_writereg (struct cx24110_state* state, int reg, int data)\r\n{\r\nu8 buf [] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\r\nint err;\r\nif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {\r\ndprintk ("%s: writereg error (err == %i, reg == 0x%02x,"\r\n" data == 0x%02x)\n", __func__, err, reg, data);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24110_readreg (struct cx24110_state* state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0 [] = { reg };\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) return ret;\r\nreturn b1[0];\r\n}\r\nstatic int cx24110_set_inversion (struct cx24110_state* state, fe_spectral_inversion_t inversion)\r\n{\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\ncx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);\r\ncx24110_writereg(state,0x5,cx24110_readreg(state,0x5)&0xf7);\r\ncx24110_writereg(state,0x22,cx24110_readreg(state,0x22)&0xef);\r\nbreak;\r\ncase INVERSION_ON:\r\ncx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);\r\ncx24110_writereg(state,0x5,cx24110_readreg(state,0x5)|0x08);\r\ncx24110_writereg(state,0x22,cx24110_readreg(state,0x22)|0x10);\r\nbreak;\r\ncase INVERSION_AUTO:\r\ncx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xfe);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24110_set_fec (struct cx24110_state* state, fe_code_rate_t fec)\r\n{\r\nstatic const int rate[]={-1,1,2,3,5,7,-1};\r\nstatic const int g1[]={-1,0x01,0x02,0x05,0x15,0x45,-1};\r\nstatic const int g2[]={-1,0x01,0x03,0x06,0x1a,0x7a,-1};\r\nif (fec>FEC_AUTO)\r\nfec=FEC_AUTO;\r\nif (fec==FEC_AUTO) {\r\ncx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xdf);\r\ncx24110_writereg(state,0x18,0xae);\r\ncx24110_writereg(state,0x05,(cx24110_readreg(state,0x05)&0xf0)|0x3);\r\ncx24110_writereg(state,0x22,(cx24110_readreg(state,0x22)&0xf0)|0x3);\r\ncx24110_writereg(state,0x1a,0x05); cx24110_writereg(state,0x1b,0x06);\r\nreturn 0;\r\n} else {\r\ncx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x20);\r\nif(rate[fec]>0) {\r\ncx24110_writereg(state,0x05,(cx24110_readreg(state,0x05)&0xf0)|rate[fec]);\r\ncx24110_writereg(state,0x22,(cx24110_readreg(state,0x22)&0xf0)|rate[fec]);\r\ncx24110_writereg(state,0x1a,g1[fec]);\r\ncx24110_writereg(state,0x1b,g2[fec]);\r\n} else\r\nreturn -EOPNOTSUPP;\r\n};\r\nreturn 0;\r\n}\r\nstatic fe_code_rate_t cx24110_get_fec (struct cx24110_state* state)\r\n{\r\nint i;\r\ni=cx24110_readreg(state,0x22)&0x0f;\r\nif(!(i&0x08)) {\r\nreturn FEC_1_2 + i - 1;\r\n} else {\r\nreturn FEC_NONE;\r\n}\r\n}\r\nstatic int cx24110_set_symbolrate (struct cx24110_state* state, u32 srate)\r\n{\r\nu32 ratio;\r\nu32 tmp, fclk, BDRI;\r\nstatic const u32 bands[]={5000000UL,15000000UL,90999000UL/2};\r\nint i;\r\ndprintk("cx24110 debug: entering %s(%d)\n",__func__,srate);\r\nif (srate>90999000UL/2)\r\nsrate=90999000UL/2;\r\nif (srate<500000)\r\nsrate=500000;\r\nfor(i = 0; (i < ARRAY_SIZE(bands)) && (srate>bands[i]); i++)\r\n;\r\ntmp=cx24110_readreg(state,0x07)&0xfc;\r\nif(srate<90999000UL/4) {\r\ncx24110_writereg(state,0x07,tmp);\r\ncx24110_writereg(state,0x06,0x78);\r\nfclk=90999000UL/2;\r\n} else if(srate<60666000UL/2) {\r\ncx24110_writereg(state,0x07,tmp|0x1);\r\ncx24110_writereg(state,0x06,0xa5);\r\nfclk=60666000UL;\r\n} else if(srate<80888000UL/2) {\r\ncx24110_writereg(state,0x07,tmp|0x2);\r\ncx24110_writereg(state,0x06,0x87);\r\nfclk=80888000UL;\r\n} else {\r\ncx24110_writereg(state,0x07,tmp|0x3);\r\ncx24110_writereg(state,0x06,0x78);\r\nfclk=90999000UL;\r\n};\r\ndprintk("cx24110 debug: fclk %d Hz\n",fclk);\r\ntmp=srate<<6;\r\nBDRI=fclk>>2;\r\nratio=(tmp/BDRI);\r\ntmp=(tmp%BDRI)<<8;\r\nratio=(ratio<<8)+(tmp/BDRI);\r\ntmp=(tmp%BDRI)<<8;\r\nratio=(ratio<<8)+(tmp/BDRI);\r\ntmp=(tmp%BDRI)<<1;\r\nratio=(ratio<<1)+(tmp/BDRI);\r\ndprintk("srate= %d (range %d, up to %d)\n", srate,i,bands[i]);\r\ndprintk("fclk = %d\n", fclk);\r\ndprintk("ratio= %08x\n", ratio);\r\ncx24110_writereg(state, 0x1, (ratio>>16)&0xff);\r\ncx24110_writereg(state, 0x2, (ratio>>8)&0xff);\r\ncx24110_writereg(state, 0x3, (ratio)&0xff);\r\nreturn 0;\r\n}\r\nstatic int _cx24110_pll_write (struct dvb_frontend* fe, const u8 buf[], int len)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nif (len != 3)\r\nreturn -EINVAL;\r\ncx24110_writereg(state,0x6d,0x30);\r\ncx24110_writereg(state,0x70,0x15);\r\nwhile (cx24110_readreg(state,0x6d)&0x80)\r\ncx24110_writereg(state,0x72,0);\r\ncx24110_writereg(state,0x72,buf[0]);\r\nwhile ((cx24110_readreg(state,0x6d)&0xc0)==0x80)\r\n;\r\ncx24110_writereg(state,0x72,buf[1]);\r\nwhile ((cx24110_readreg(state,0x6d)&0xc0)==0x80)\r\n;\r\ncx24110_writereg(state,0x72,buf[2]);\r\nwhile ((cx24110_readreg(state,0x6d)&0xc0)==0x80)\r\n;\r\ncx24110_writereg(state,0x6d,0x32);\r\ncx24110_writereg(state,0x6d,0x30);\r\nreturn 0;\r\n}\r\nstatic int cx24110_initfe(struct dvb_frontend* fe)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nint i;\r\ndprintk("%s: init chip\n", __func__);\r\nfor(i = 0; i < ARRAY_SIZE(cx24110_regdata); i++) {\r\ncx24110_writereg(state, cx24110_regdata[i].reg, cx24110_regdata[i].data);\r\n};\r\nreturn 0;\r\n}\r\nstatic int cx24110_set_voltage (struct dvb_frontend* fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\nreturn cx24110_writereg(state,0x76,(cx24110_readreg(state,0x76)&0x3b)|0xc0);\r\ncase SEC_VOLTAGE_18:\r\nreturn cx24110_writereg(state,0x76,(cx24110_readreg(state,0x76)&0x3b)|0x40);\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\n}\r\nstatic int cx24110_diseqc_send_burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t burst)\r\n{\r\nint rv, bit;\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nunsigned long timeout;\r\nif (burst == SEC_MINI_A)\r\nbit = 0x00;\r\nelse if (burst == SEC_MINI_B)\r\nbit = 0x08;\r\nelse\r\nreturn -EINVAL;\r\nrv = cx24110_readreg(state, 0x77);\r\nif (!(rv & 0x04))\r\ncx24110_writereg(state, 0x77, rv | 0x04);\r\nrv = cx24110_readreg(state, 0x76);\r\ncx24110_writereg(state, 0x76, ((rv & 0x90) | 0x40 | bit));\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (!time_after(jiffies, timeout) && !(cx24110_readreg(state, 0x76) & 0x40))\r\n;\r\nreturn 0;\r\n}\r\nstatic int cx24110_send_diseqc_msg(struct dvb_frontend* fe,\r\nstruct dvb_diseqc_master_cmd *cmd)\r\n{\r\nint i, rv;\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nunsigned long timeout;\r\nif (cmd->msg_len < 3 || cmd->msg_len > 6)\r\nreturn -EINVAL;\r\nfor (i = 0; i < cmd->msg_len; i++)\r\ncx24110_writereg(state, 0x79 + i, cmd->msg[i]);\r\nrv = cx24110_readreg(state, 0x77);\r\nif (rv & 0x04) {\r\ncx24110_writereg(state, 0x77, rv & ~0x04);\r\nmsleep(30);\r\n}\r\nrv = cx24110_readreg(state, 0x76);\r\ncx24110_writereg(state, 0x76, ((rv & 0x90) | 0x40) | ((cmd->msg_len-3) & 3));\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (!time_after(jiffies, timeout) && !(cx24110_readreg(state, 0x76) & 0x40))\r\n;\r\nreturn 0;\r\n}\r\nstatic int cx24110_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nint sync = cx24110_readreg (state, 0x55);\r\n*status = 0;\r\nif (sync & 0x10)\r\n*status |= FE_HAS_SIGNAL;\r\nif (sync & 0x08)\r\n*status |= FE_HAS_CARRIER;\r\nsync = cx24110_readreg (state, 0x08);\r\nif (sync & 0x40)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 0x20)\r\n*status |= FE_HAS_SYNC;\r\nif ((sync & 0x60) == 0x60)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int cx24110_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nif(cx24110_readreg(state,0x24)&0x10) {\r\ncx24110_writereg(state,0x24,0x04);\r\nstate->lastber=cx24110_readreg(state,0x25)|\r\n(cx24110_readreg(state,0x26)<<8);\r\ncx24110_writereg(state,0x24,0x04);\r\ncx24110_writereg(state,0x24,0x14);\r\n}\r\n*ber = state->lastber;\r\nreturn 0;\r\n}\r\nstatic int cx24110_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nu8 signal = cx24110_readreg (state, 0x27)+128;\r\n*signal_strength = (signal << 8) | signal;\r\nreturn 0;\r\n}\r\nstatic int cx24110_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nif(cx24110_readreg(state,0x6a)&0x80) {\r\nstate->lastesn0=cx24110_readreg(state,0x69)|\r\n(cx24110_readreg(state,0x68)<<8);\r\ncx24110_writereg(state,0x6a,0x84);\r\n}\r\n*snr = state->lastesn0;\r\nreturn 0;\r\n}\r\nstatic int cx24110_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nu32 lastbyer;\r\nif(cx24110_readreg(state,0x10)&0x40) {\r\ncx24110_writereg(state,0x10,0x60);\r\nlastbyer=cx24110_readreg(state,0x12)|\r\n(cx24110_readreg(state,0x13)<<8)|\r\n(cx24110_readreg(state,0x14)<<16);\r\ncx24110_writereg(state,0x10,0x70);\r\nstate->lastbler=cx24110_readreg(state,0x12)|\r\n(cx24110_readreg(state,0x13)<<8)|\r\n(cx24110_readreg(state,0x14)<<16);\r\ncx24110_writereg(state,0x10,0x20);\r\n}\r\n*ucblocks = state->lastbler;\r\nreturn 0;\r\n}\r\nstatic int cx24110_set_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe, p);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ncx24110_set_inversion (state, p->inversion);\r\ncx24110_set_fec (state, p->u.qpsk.fec_inner);\r\ncx24110_set_symbolrate (state, p->u.qpsk.symbol_rate);\r\ncx24110_writereg(state,0x04,0x05);\r\nreturn 0;\r\n}\r\nstatic int cx24110_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\ns32 afc; unsigned sclk;\r\nsclk = cx24110_readreg (state, 0x07) & 0x03;\r\nif (sclk==0) sclk=90999000L/2L;\r\nelse if (sclk==1) sclk=60666000L;\r\nelse if (sclk==2) sclk=80888000L;\r\nelse sclk=90999000L;\r\nsclk>>=8;\r\nafc = sclk*(cx24110_readreg (state, 0x44)&0x1f)+\r\n((sclk*cx24110_readreg (state, 0x45))>>8)+\r\n((sclk*cx24110_readreg (state, 0x46))>>16);\r\np->frequency += afc;\r\np->inversion = (cx24110_readreg (state, 0x22) & 0x10) ?\r\nINVERSION_ON : INVERSION_OFF;\r\np->u.qpsk.fec_inner = cx24110_get_fec (state);\r\nreturn 0;\r\n}\r\nstatic int cx24110_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct cx24110_state *state = fe->demodulator_priv;\r\nreturn cx24110_writereg(state,0x76,(cx24110_readreg(state,0x76)&~0x10)|(((tone==SEC_TONE_ON))?0x10:0));\r\n}\r\nstatic void cx24110_release(struct dvb_frontend* fe)\r\n{\r\nstruct cx24110_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* cx24110_attach(const struct cx24110_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct cx24110_state* state = NULL;\r\nint ret;\r\nstate = kzalloc(sizeof(struct cx24110_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->lastber = 0;\r\nstate->lastbler = 0;\r\nstate->lastesn0 = 0;\r\nret = cx24110_readreg(state, 0x00);\r\nif ((ret != 0x5a) && (ret != 0x69)) goto error;\r\nmemcpy(&state->frontend.ops, &cx24110_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
