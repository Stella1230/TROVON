static u32\r\ni2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)\r\n{\r\nif (cond)\r\nreturn (ic_clk * tSYMBOL + 5000) / 10000 - 8 + offset;\r\nelse\r\nreturn (ic_clk * (tSYMBOL + tf) + 5000) / 10000 - 3 + offset;\r\n}\r\nstatic u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)\r\n{\r\nreturn ((ic_clk * (tLOW + tf) + 5000) / 10000) - 1 + offset;\r\n}\r\nstatic void i2c_dw_init(struct dw_i2c_dev *dev)\r\n{\r\nu32 input_clock_khz = clk_get_rate(dev->clk) / 1000;\r\nu32 ic_con, hcnt, lcnt;\r\nwritel(0, dev->base + DW_IC_ENABLE);\r\nhcnt = i2c_dw_scl_hcnt(input_clock_khz,\r\n40,\r\n3,\r\n0,\r\n0);\r\nlcnt = i2c_dw_scl_lcnt(input_clock_khz,\r\n47,\r\n3,\r\n0);\r\nwritel(hcnt, dev->base + DW_IC_SS_SCL_HCNT);\r\nwritel(lcnt, dev->base + DW_IC_SS_SCL_LCNT);\r\ndev_dbg(dev->dev, "Standard-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);\r\nhcnt = i2c_dw_scl_hcnt(input_clock_khz,\r\n6,\r\n3,\r\n0,\r\n0);\r\nlcnt = i2c_dw_scl_lcnt(input_clock_khz,\r\n13,\r\n3,\r\n0);\r\nwritel(hcnt, dev->base + DW_IC_FS_SCL_HCNT);\r\nwritel(lcnt, dev->base + DW_IC_FS_SCL_LCNT);\r\ndev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);\r\nwritel(dev->tx_fifo_depth - 1, dev->base + DW_IC_TX_TL);\r\nwritel(0, dev->base + DW_IC_RX_TL);\r\nic_con = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |\r\nDW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;\r\nwritel(ic_con, dev->base + DW_IC_CON);\r\n}\r\nstatic int i2c_dw_wait_bus_not_busy(struct dw_i2c_dev *dev)\r\n{\r\nint timeout = TIMEOUT;\r\nwhile (readl(dev->base + DW_IC_STATUS) & DW_IC_STATUS_ACTIVITY) {\r\nif (timeout <= 0) {\r\ndev_warn(dev->dev, "timeout waiting for bus ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ntimeout--;\r\nmdelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void i2c_dw_xfer_init(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 ic_con;\r\nwritel(0, dev->base + DW_IC_ENABLE);\r\nwritel(msgs[dev->msg_write_idx].addr, dev->base + DW_IC_TAR);\r\nic_con = readl(dev->base + DW_IC_CON);\r\nif (msgs[dev->msg_write_idx].flags & I2C_M_TEN)\r\nic_con |= DW_IC_CON_10BITADDR_MASTER;\r\nelse\r\nic_con &= ~DW_IC_CON_10BITADDR_MASTER;\r\nwritel(ic_con, dev->base + DW_IC_CON);\r\nwritel(1, dev->base + DW_IC_ENABLE);\r\nwritel(DW_IC_INTR_DEFAULT_MASK, dev->base + DW_IC_INTR_MASK);\r\n}\r\nstatic void\r\ni2c_dw_xfer_msg(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 intr_mask;\r\nint tx_limit, rx_limit;\r\nu32 addr = msgs[dev->msg_write_idx].addr;\r\nu32 buf_len = dev->tx_buf_len;\r\nu8 *buf = dev->tx_buf;;\r\nintr_mask = DW_IC_INTR_DEFAULT_MASK;\r\nfor (; dev->msg_write_idx < dev->msgs_num; dev->msg_write_idx++) {\r\nif (msgs[dev->msg_write_idx].addr != addr) {\r\ndev_err(dev->dev,\r\n"%s: invalid target address\n", __func__);\r\ndev->msg_err = -EINVAL;\r\nbreak;\r\n}\r\nif (msgs[dev->msg_write_idx].len == 0) {\r\ndev_err(dev->dev,\r\n"%s: invalid message length\n", __func__);\r\ndev->msg_err = -EINVAL;\r\nbreak;\r\n}\r\nif (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {\r\nbuf = msgs[dev->msg_write_idx].buf;\r\nbuf_len = msgs[dev->msg_write_idx].len;\r\n}\r\ntx_limit = dev->tx_fifo_depth - readl(dev->base + DW_IC_TXFLR);\r\nrx_limit = dev->rx_fifo_depth - readl(dev->base + DW_IC_RXFLR);\r\nwhile (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {\r\nif (msgs[dev->msg_write_idx].flags & I2C_M_RD) {\r\nwritel(0x100, dev->base + DW_IC_DATA_CMD);\r\nrx_limit--;\r\n} else\r\nwritel(*buf++, dev->base + DW_IC_DATA_CMD);\r\ntx_limit--; buf_len--;\r\n}\r\ndev->tx_buf = buf;\r\ndev->tx_buf_len = buf_len;\r\nif (buf_len > 0) {\r\ndev->status |= STATUS_WRITE_IN_PROGRESS;\r\nbreak;\r\n} else\r\ndev->status &= ~STATUS_WRITE_IN_PROGRESS;\r\n}\r\nif (dev->msg_write_idx == dev->msgs_num)\r\nintr_mask &= ~DW_IC_INTR_TX_EMPTY;\r\nif (dev->msg_err)\r\nintr_mask = 0;\r\nwritel(intr_mask, dev->base + DW_IC_INTR_MASK);\r\n}\r\nstatic void\r\ni2c_dw_read(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nint rx_valid;\r\nfor (; dev->msg_read_idx < dev->msgs_num; dev->msg_read_idx++) {\r\nu32 len;\r\nu8 *buf;\r\nif (!(msgs[dev->msg_read_idx].flags & I2C_M_RD))\r\ncontinue;\r\nif (!(dev->status & STATUS_READ_IN_PROGRESS)) {\r\nlen = msgs[dev->msg_read_idx].len;\r\nbuf = msgs[dev->msg_read_idx].buf;\r\n} else {\r\nlen = dev->rx_buf_len;\r\nbuf = dev->rx_buf;\r\n}\r\nrx_valid = readl(dev->base + DW_IC_RXFLR);\r\nfor (; len > 0 && rx_valid > 0; len--, rx_valid--)\r\n*buf++ = readl(dev->base + DW_IC_DATA_CMD);\r\nif (len > 0) {\r\ndev->status |= STATUS_READ_IN_PROGRESS;\r\ndev->rx_buf_len = len;\r\ndev->rx_buf = buf;\r\nreturn;\r\n} else\r\ndev->status &= ~STATUS_READ_IN_PROGRESS;\r\n}\r\n}\r\nstatic int i2c_dw_handle_tx_abort(struct dw_i2c_dev *dev)\r\n{\r\nunsigned long abort_source = dev->abort_source;\r\nint i;\r\nif (abort_source & DW_IC_TX_ABRT_NOACK) {\r\nfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\r\ndev_dbg(dev->dev,\r\n"%s: %s\n", __func__, abort_sources[i]);\r\nreturn -EREMOTEIO;\r\n}\r\nfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\r\ndev_err(dev->dev, "%s: %s\n", __func__, abort_sources[i]);\r\nif (abort_source & DW_IC_TX_ARB_LOST)\r\nreturn -EAGAIN;\r\nelse if (abort_source & DW_IC_TX_ABRT_GCALL_READ)\r\nreturn -EINVAL;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int\r\ni2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\r\nint ret;\r\ndev_dbg(dev->dev, "%s: msgs: %d\n", __func__, num);\r\nmutex_lock(&dev->lock);\r\nINIT_COMPLETION(dev->cmd_complete);\r\ndev->msgs = msgs;\r\ndev->msgs_num = num;\r\ndev->cmd_err = 0;\r\ndev->msg_write_idx = 0;\r\ndev->msg_read_idx = 0;\r\ndev->msg_err = 0;\r\ndev->status = STATUS_IDLE;\r\ndev->abort_source = 0;\r\nret = i2c_dw_wait_bus_not_busy(dev);\r\nif (ret < 0)\r\ngoto done;\r\ni2c_dw_xfer_init(dev);\r\nret = wait_for_completion_interruptible_timeout(&dev->cmd_complete, HZ);\r\nif (ret == 0) {\r\ndev_err(dev->dev, "controller timed out\n");\r\ni2c_dw_init(dev);\r\nret = -ETIMEDOUT;\r\ngoto done;\r\n} else if (ret < 0)\r\ngoto done;\r\nif (dev->msg_err) {\r\nret = dev->msg_err;\r\ngoto done;\r\n}\r\nif (likely(!dev->cmd_err)) {\r\nwritel(0, dev->base + DW_IC_ENABLE);\r\nret = num;\r\ngoto done;\r\n}\r\nif (dev->cmd_err == DW_IC_ERR_TX_ABRT) {\r\nret = i2c_dw_handle_tx_abort(dev);\r\ngoto done;\r\n}\r\nret = -EIO;\r\ndone:\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic u32 i2c_dw_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C |\r\nI2C_FUNC_10BIT_ADDR |\r\nI2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK;\r\n}\r\nstatic u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)\r\n{\r\nu32 stat;\r\nstat = readl(dev->base + DW_IC_INTR_STAT);\r\nif (stat & DW_IC_INTR_RX_UNDER)\r\nreadl(dev->base + DW_IC_CLR_RX_UNDER);\r\nif (stat & DW_IC_INTR_RX_OVER)\r\nreadl(dev->base + DW_IC_CLR_RX_OVER);\r\nif (stat & DW_IC_INTR_TX_OVER)\r\nreadl(dev->base + DW_IC_CLR_TX_OVER);\r\nif (stat & DW_IC_INTR_RD_REQ)\r\nreadl(dev->base + DW_IC_CLR_RD_REQ);\r\nif (stat & DW_IC_INTR_TX_ABRT) {\r\ndev->abort_source = readl(dev->base + DW_IC_TX_ABRT_SOURCE);\r\nreadl(dev->base + DW_IC_CLR_TX_ABRT);\r\n}\r\nif (stat & DW_IC_INTR_RX_DONE)\r\nreadl(dev->base + DW_IC_CLR_RX_DONE);\r\nif (stat & DW_IC_INTR_ACTIVITY)\r\nreadl(dev->base + DW_IC_CLR_ACTIVITY);\r\nif (stat & DW_IC_INTR_STOP_DET)\r\nreadl(dev->base + DW_IC_CLR_STOP_DET);\r\nif (stat & DW_IC_INTR_START_DET)\r\nreadl(dev->base + DW_IC_CLR_START_DET);\r\nif (stat & DW_IC_INTR_GEN_CALL)\r\nreadl(dev->base + DW_IC_CLR_GEN_CALL);\r\nreturn stat;\r\n}\r\nstatic irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)\r\n{\r\nstruct dw_i2c_dev *dev = dev_id;\r\nu32 stat;\r\nstat = i2c_dw_read_clear_intrbits(dev);\r\ndev_dbg(dev->dev, "%s: stat=0x%x\n", __func__, stat);\r\nif (stat & DW_IC_INTR_TX_ABRT) {\r\ndev->cmd_err |= DW_IC_ERR_TX_ABRT;\r\ndev->status = STATUS_IDLE;\r\nwritel(0, dev->base + DW_IC_INTR_MASK);\r\ngoto tx_aborted;\r\n}\r\nif (stat & DW_IC_INTR_RX_FULL)\r\ni2c_dw_read(dev);\r\nif (stat & DW_IC_INTR_TX_EMPTY)\r\ni2c_dw_xfer_msg(dev);\r\ntx_aborted:\r\nif ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err)\r\ncomplete(&dev->cmd_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit dw_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct dw_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *mem, *ioarea;\r\nint irq, r;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\nioarea = request_mem_region(mem->start, resource_size(mem),\r\npdev->name);\r\nif (!ioarea) {\r\ndev_err(&pdev->dev, "I2C region already claimed\n");\r\nreturn -EBUSY;\r\n}\r\ndev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);\r\nif (!dev) {\r\nr = -ENOMEM;\r\ngoto err_release_region;\r\n}\r\ninit_completion(&dev->cmd_complete);\r\nmutex_init(&dev->lock);\r\ndev->dev = get_device(&pdev->dev);\r\ndev->irq = irq;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\nr = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\nclk_enable(dev->clk);\r\ndev->base = ioremap(mem->start, resource_size(mem));\r\nif (dev->base == NULL) {\r\ndev_err(&pdev->dev, "failure mapping io resources\n");\r\nr = -EBUSY;\r\ngoto err_unuse_clocks;\r\n}\r\n{\r\nu32 param1 = readl(dev->base + DW_IC_COMP_PARAM_1);\r\ndev->tx_fifo_depth = ((param1 >> 16) & 0xff) + 1;\r\ndev->rx_fifo_depth = ((param1 >> 8) & 0xff) + 1;\r\n}\r\ni2c_dw_init(dev);\r\nwritel(0, dev->base + DW_IC_INTR_MASK);\r\nr = request_irq(dev->irq, i2c_dw_isr, IRQF_DISABLED, pdev->name, dev);\r\nif (r) {\r\ndev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);\r\ngoto err_iounmap;\r\n}\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_HWMON;\r\nstrlcpy(adap->name, "Synopsys DesignWare I2C adapter",\r\nsizeof(adap->name));\r\nadap->algo = &i2c_dw_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->nr = pdev->id;\r\nr = i2c_add_numbered_adapter(adap);\r\nif (r) {\r\ndev_err(&pdev->dev, "failure adding adapter\n");\r\ngoto err_free_irq;\r\n}\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_iounmap:\r\niounmap(dev->base);\r\nerr_unuse_clocks:\r\nclk_disable(dev->clk);\r\nclk_put(dev->clk);\r\ndev->clk = NULL;\r\nerr_free_mem:\r\nplatform_set_drvdata(pdev, NULL);\r\nput_device(&pdev->dev);\r\nkfree(dev);\r\nerr_release_region:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn r;\r\n}\r\nstatic int __devexit dw_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct dw_i2c_dev *dev = platform_get_drvdata(pdev);\r\nstruct resource *mem;\r\nplatform_set_drvdata(pdev, NULL);\r\ni2c_del_adapter(&dev->adapter);\r\nput_device(&pdev->dev);\r\nclk_disable(dev->clk);\r\nclk_put(dev->clk);\r\ndev->clk = NULL;\r\nwritel(0, dev->base + DW_IC_ENABLE);\r\nfree_irq(dev->irq, dev);\r\nkfree(dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn 0;\r\n}\r\nstatic int __init dw_i2c_init_driver(void)\r\n{\r\nreturn platform_driver_probe(&dw_i2c_driver, dw_i2c_probe);\r\n}\r\nstatic void __exit dw_i2c_exit_driver(void)\r\n{\r\nplatform_driver_unregister(&dw_i2c_driver);\r\n}
