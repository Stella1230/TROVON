static inline const struct cpumask *cpu_core_mask(int cpu)\r\n{\r\nreturn cpumask_of(0);\r\n}\r\nstatic u32 find_freq_from_fid(u32 fid)\r\n{\r\nreturn 800 + (fid * 100);\r\n}\r\nstatic u32 find_khz_freq_from_fid(u32 fid)\r\n{\r\nreturn 1000 * find_freq_from_fid(fid);\r\n}\r\nstatic u32 find_khz_freq_from_pstate(struct cpufreq_frequency_table *data,\r\nu32 pstate)\r\n{\r\nreturn data[pstate].frequency;\r\n}\r\nstatic u32 convert_fid_to_vco_fid(u32 fid)\r\n{\r\nif (fid < HI_FID_TABLE_BOTTOM)\r\nreturn 8 + (2 * fid);\r\nelse\r\nreturn fid;\r\n}\r\nstatic int pending_bit_stuck(void)\r\n{\r\nu32 lo, hi;\r\nif (cpu_family == CPU_HW_PSTATE)\r\nreturn 0;\r\nrdmsr(MSR_FIDVID_STATUS, lo, hi);\r\nreturn lo & MSR_S_LO_CHANGE_PENDING ? 1 : 0;\r\n}\r\nstatic int query_current_values_with_pending_wait(struct powernow_k8_data *data)\r\n{\r\nu32 lo, hi;\r\nu32 i = 0;\r\nif (cpu_family == CPU_HW_PSTATE) {\r\nrdmsr(MSR_PSTATE_STATUS, lo, hi);\r\ni = lo & HW_PSTATE_MASK;\r\ndata->currpstate = i;\r\nif ((boot_cpu_data.x86 == 0x11) && (i >= data->numps))\r\ndata->currpstate = HW_PSTATE_0;\r\nreturn 0;\r\n}\r\ndo {\r\nif (i++ > 10000) {\r\npr_debug("detected change pending stuck\n");\r\nreturn 1;\r\n}\r\nrdmsr(MSR_FIDVID_STATUS, lo, hi);\r\n} while (lo & MSR_S_LO_CHANGE_PENDING);\r\ndata->currvid = hi & MSR_S_HI_CURRENT_VID;\r\ndata->currfid = lo & MSR_S_LO_CURRENT_FID;\r\nreturn 0;\r\n}\r\nstatic void count_off_irt(struct powernow_k8_data *data)\r\n{\r\nudelay((1 << data->irt) * 10);\r\nreturn;\r\n}\r\nstatic void count_off_vst(struct powernow_k8_data *data)\r\n{\r\nudelay(data->vstable * VST_UNITS_20US);\r\nreturn;\r\n}\r\nstatic void fidvid_msr_init(void)\r\n{\r\nu32 lo, hi;\r\nu8 fid, vid;\r\nrdmsr(MSR_FIDVID_STATUS, lo, hi);\r\nvid = hi & MSR_S_HI_CURRENT_VID;\r\nfid = lo & MSR_S_LO_CURRENT_FID;\r\nlo = fid | (vid << MSR_C_LO_VID_SHIFT);\r\nhi = MSR_C_HI_STP_GNT_BENIGN;\r\npr_debug("cpu%d, init lo 0x%x, hi 0x%x\n", smp_processor_id(), lo, hi);\r\nwrmsr(MSR_FIDVID_CTL, lo, hi);\r\n}\r\nstatic int write_new_fid(struct powernow_k8_data *data, u32 fid)\r\n{\r\nu32 lo;\r\nu32 savevid = data->currvid;\r\nu32 i = 0;\r\nif ((fid & INVALID_FID_MASK) || (data->currvid & INVALID_VID_MASK)) {\r\nprintk(KERN_ERR PFX "internal error - overflow on fid write\n");\r\nreturn 1;\r\n}\r\nlo = fid;\r\nlo |= (data->currvid << MSR_C_LO_VID_SHIFT);\r\nlo |= MSR_C_LO_INIT_FID_VID;\r\npr_debug("writing fid 0x%x, lo 0x%x, hi 0x%x\n",\r\nfid, lo, data->plllock * PLL_LOCK_CONVERSION);\r\ndo {\r\nwrmsr(MSR_FIDVID_CTL, lo, data->plllock * PLL_LOCK_CONVERSION);\r\nif (i++ > 100) {\r\nprintk(KERN_ERR PFX\r\n"Hardware error - pending bit very stuck - "\r\n"no further pstate changes possible\n");\r\nreturn 1;\r\n}\r\n} while (query_current_values_with_pending_wait(data));\r\ncount_off_irt(data);\r\nif (savevid != data->currvid) {\r\nprintk(KERN_ERR PFX\r\n"vid change on fid trans, old 0x%x, new 0x%x\n",\r\nsavevid, data->currvid);\r\nreturn 1;\r\n}\r\nif (fid != data->currfid) {\r\nprintk(KERN_ERR PFX\r\n"fid trans failed, fid 0x%x, curr 0x%x\n", fid,\r\ndata->currfid);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_new_vid(struct powernow_k8_data *data, u32 vid)\r\n{\r\nu32 lo;\r\nu32 savefid = data->currfid;\r\nint i = 0;\r\nif ((data->currfid & INVALID_FID_MASK) || (vid & INVALID_VID_MASK)) {\r\nprintk(KERN_ERR PFX "internal error - overflow on vid write\n");\r\nreturn 1;\r\n}\r\nlo = data->currfid;\r\nlo |= (vid << MSR_C_LO_VID_SHIFT);\r\nlo |= MSR_C_LO_INIT_FID_VID;\r\npr_debug("writing vid 0x%x, lo 0x%x, hi 0x%x\n",\r\nvid, lo, STOP_GRANT_5NS);\r\ndo {\r\nwrmsr(MSR_FIDVID_CTL, lo, STOP_GRANT_5NS);\r\nif (i++ > 100) {\r\nprintk(KERN_ERR PFX "internal error - pending bit "\r\n"very stuck - no further pstate "\r\n"changes possible\n");\r\nreturn 1;\r\n}\r\n} while (query_current_values_with_pending_wait(data));\r\nif (savefid != data->currfid) {\r\nprintk(KERN_ERR PFX "fid changed on vid trans, old "\r\n"0x%x new 0x%x\n",\r\nsavefid, data->currfid);\r\nreturn 1;\r\n}\r\nif (vid != data->currvid) {\r\nprintk(KERN_ERR PFX "vid trans failed, vid 0x%x, "\r\n"curr 0x%x\n",\r\nvid, data->currvid);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int decrease_vid_code_by_step(struct powernow_k8_data *data,\r\nu32 reqvid, u32 step)\r\n{\r\nif ((data->currvid - reqvid) > step)\r\nreqvid = data->currvid - step;\r\nif (write_new_vid(data, reqvid))\r\nreturn 1;\r\ncount_off_vst(data);\r\nreturn 0;\r\n}\r\nstatic int transition_pstate(struct powernow_k8_data *data, u32 pstate)\r\n{\r\nwrmsr(MSR_PSTATE_CTRL, pstate, 0);\r\ndata->currpstate = pstate;\r\nreturn 0;\r\n}\r\nstatic int transition_fid_vid(struct powernow_k8_data *data,\r\nu32 reqfid, u32 reqvid)\r\n{\r\nif (core_voltage_pre_transition(data, reqvid, reqfid))\r\nreturn 1;\r\nif (core_frequency_transition(data, reqfid))\r\nreturn 1;\r\nif (core_voltage_post_transition(data, reqvid))\r\nreturn 1;\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif ((reqfid != data->currfid) || (reqvid != data->currvid)) {\r\nprintk(KERN_ERR PFX "failed (cpu%d): req 0x%x 0x%x, "\r\n"curr 0x%x 0x%x\n",\r\nsmp_processor_id(),\r\nreqfid, reqvid, data->currfid, data->currvid);\r\nreturn 1;\r\n}\r\npr_debug("transitioned (cpu%d): new fid 0x%x, vid 0x%x\n",\r\nsmp_processor_id(), data->currfid, data->currvid);\r\nreturn 0;\r\n}\r\nstatic int core_voltage_pre_transition(struct powernow_k8_data *data,\r\nu32 reqvid, u32 reqfid)\r\n{\r\nu32 rvosteps = data->rvo;\r\nu32 savefid = data->currfid;\r\nu32 maxvid, lo, rvomult = 1;\r\npr_debug("ph1 (cpu%d): start, currfid 0x%x, currvid 0x%x, "\r\n"reqvid 0x%x, rvo 0x%x\n",\r\nsmp_processor_id(),\r\ndata->currfid, data->currvid, reqvid, data->rvo);\r\nif ((savefid < LO_FID_TABLE_TOP) && (reqfid < LO_FID_TABLE_TOP))\r\nrvomult = 2;\r\nrvosteps *= rvomult;\r\nrdmsr(MSR_FIDVID_STATUS, lo, maxvid);\r\nmaxvid = 0x1f & (maxvid >> 16);\r\npr_debug("ph1 maxvid=0x%x\n", maxvid);\r\nif (reqvid < maxvid)\r\nreqvid = maxvid;\r\nwhile (data->currvid > reqvid) {\r\npr_debug("ph1: curr 0x%x, req vid 0x%x\n",\r\ndata->currvid, reqvid);\r\nif (decrease_vid_code_by_step(data, reqvid, data->vidmvs))\r\nreturn 1;\r\n}\r\nwhile ((rvosteps > 0) &&\r\n((rvomult * data->rvo + data->currvid) > reqvid)) {\r\nif (data->currvid == maxvid) {\r\nrvosteps = 0;\r\n} else {\r\npr_debug("ph1: changing vid for rvo, req 0x%x\n",\r\ndata->currvid - 1);\r\nif (decrease_vid_code_by_step(data, data->currvid-1, 1))\r\nreturn 1;\r\nrvosteps--;\r\n}\r\n}\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif (savefid != data->currfid) {\r\nprintk(KERN_ERR PFX "ph1 err, currfid changed 0x%x\n",\r\ndata->currfid);\r\nreturn 1;\r\n}\r\npr_debug("ph1 complete, currfid 0x%x, currvid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nreturn 0;\r\n}\r\nstatic int core_frequency_transition(struct powernow_k8_data *data, u32 reqfid)\r\n{\r\nu32 vcoreqfid, vcocurrfid, vcofiddiff;\r\nu32 fid_interval, savevid = data->currvid;\r\nif (data->currfid == reqfid) {\r\nprintk(KERN_ERR PFX "ph2 null fid transition 0x%x\n",\r\ndata->currfid);\r\nreturn 0;\r\n}\r\npr_debug("ph2 (cpu%d): starting, currfid 0x%x, currvid 0x%x, "\r\n"reqfid 0x%x\n",\r\nsmp_processor_id(),\r\ndata->currfid, data->currvid, reqfid);\r\nvcoreqfid = convert_fid_to_vco_fid(reqfid);\r\nvcocurrfid = convert_fid_to_vco_fid(data->currfid);\r\nvcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid\r\n: vcoreqfid - vcocurrfid;\r\nif ((reqfid <= LO_FID_TABLE_TOP) && (data->currfid <= LO_FID_TABLE_TOP))\r\nvcofiddiff = 0;\r\nwhile (vcofiddiff > 2) {\r\n(data->currfid & 1) ? (fid_interval = 1) : (fid_interval = 2);\r\nif (reqfid > data->currfid) {\r\nif (data->currfid > LO_FID_TABLE_TOP) {\r\nif (write_new_fid(data,\r\ndata->currfid + fid_interval))\r\nreturn 1;\r\n} else {\r\nif (write_new_fid\r\n(data,\r\n2 + convert_fid_to_vco_fid(data->currfid)))\r\nreturn 1;\r\n}\r\n} else {\r\nif (write_new_fid(data, data->currfid - fid_interval))\r\nreturn 1;\r\n}\r\nvcocurrfid = convert_fid_to_vco_fid(data->currfid);\r\nvcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid\r\n: vcoreqfid - vcocurrfid;\r\n}\r\nif (write_new_fid(data, reqfid))\r\nreturn 1;\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif (data->currfid != reqfid) {\r\nprintk(KERN_ERR PFX\r\n"ph2: mismatch, failed fid transition, "\r\n"curr 0x%x, req 0x%x\n",\r\ndata->currfid, reqfid);\r\nreturn 1;\r\n}\r\nif (savevid != data->currvid) {\r\nprintk(KERN_ERR PFX "ph2: vid changed, save 0x%x, curr 0x%x\n",\r\nsavevid, data->currvid);\r\nreturn 1;\r\n}\r\npr_debug("ph2 complete, currfid 0x%x, currvid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nreturn 0;\r\n}\r\nstatic int core_voltage_post_transition(struct powernow_k8_data *data,\r\nu32 reqvid)\r\n{\r\nu32 savefid = data->currfid;\r\nu32 savereqvid = reqvid;\r\npr_debug("ph3 (cpu%d): starting, currfid 0x%x, currvid 0x%x\n",\r\nsmp_processor_id(),\r\ndata->currfid, data->currvid);\r\nif (reqvid != data->currvid) {\r\nif (write_new_vid(data, reqvid))\r\nreturn 1;\r\nif (savefid != data->currfid) {\r\nprintk(KERN_ERR PFX\r\n"ph3: bad fid change, save 0x%x, curr 0x%x\n",\r\nsavefid, data->currfid);\r\nreturn 1;\r\n}\r\nif (data->currvid != reqvid) {\r\nprintk(KERN_ERR PFX\r\n"ph3: failed vid transition\n, "\r\n"req 0x%x, curr 0x%x",\r\nreqvid, data->currvid);\r\nreturn 1;\r\n}\r\n}\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif (savereqvid != data->currvid) {\r\npr_debug("ph3 failed, currvid 0x%x\n", data->currvid);\r\nreturn 1;\r\n}\r\nif (savefid != data->currfid) {\r\npr_debug("ph3 failed, currfid changed 0x%x\n",\r\ndata->currfid);\r\nreturn 1;\r\n}\r\npr_debug("ph3 complete, currfid 0x%x, currvid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nreturn 0;\r\n}\r\nstatic void check_supported_cpu(void *_rc)\r\n{\r\nu32 eax, ebx, ecx, edx;\r\nint *rc = _rc;\r\n*rc = -ENODEV;\r\nif (__this_cpu_read(cpu_info.x86_vendor) != X86_VENDOR_AMD)\r\nreturn;\r\neax = cpuid_eax(CPUID_PROCESSOR_SIGNATURE);\r\nif (((eax & CPUID_XFAM) != CPUID_XFAM_K8) &&\r\n((eax & CPUID_XFAM) < CPUID_XFAM_10H))\r\nreturn;\r\nif ((eax & CPUID_XFAM) == CPUID_XFAM_K8) {\r\nif (((eax & CPUID_USE_XFAM_XMOD) != CPUID_USE_XFAM_XMOD) ||\r\n((eax & CPUID_XMOD) > CPUID_XMOD_REV_MASK)) {\r\nprintk(KERN_INFO PFX\r\n"Processor cpuid %x not supported\n", eax);\r\nreturn;\r\n}\r\neax = cpuid_eax(CPUID_GET_MAX_CAPABILITIES);\r\nif (eax < CPUID_FREQ_VOLT_CAPABILITIES) {\r\nprintk(KERN_INFO PFX\r\n"No frequency change capabilities detected\n");\r\nreturn;\r\n}\r\ncpuid(CPUID_FREQ_VOLT_CAPABILITIES, &eax, &ebx, &ecx, &edx);\r\nif ((edx & P_STATE_TRANSITION_CAPABLE)\r\n!= P_STATE_TRANSITION_CAPABLE) {\r\nprintk(KERN_INFO PFX\r\n"Power state transitions not supported\n");\r\nreturn;\r\n}\r\n} else {\r\ncpuid(CPUID_FREQ_VOLT_CAPABILITIES, &eax, &ebx, &ecx, &edx);\r\nif ((edx & USE_HW_PSTATE) == USE_HW_PSTATE)\r\ncpu_family = CPU_HW_PSTATE;\r\nelse\r\nreturn;\r\n}\r\n*rc = 0;\r\n}\r\nstatic int check_pst_table(struct powernow_k8_data *data, struct pst_s *pst,\r\nu8 maxvid)\r\n{\r\nunsigned int j;\r\nu8 lastfid = 0xff;\r\nfor (j = 0; j < data->numps; j++) {\r\nif (pst[j].vid > LEAST_VID) {\r\nprintk(KERN_ERR FW_BUG PFX "vid %d invalid : 0x%x\n",\r\nj, pst[j].vid);\r\nreturn -EINVAL;\r\n}\r\nif (pst[j].vid < data->rvo) {\r\nprintk(KERN_ERR FW_BUG PFX "0 vid exceeded with pstate"\r\n" %d\n", j);\r\nreturn -ENODEV;\r\n}\r\nif (pst[j].vid < maxvid + data->rvo) {\r\nprintk(KERN_ERR FW_BUG PFX "maxvid exceeded with pstate"\r\n" %d\n", j);\r\nreturn -ENODEV;\r\n}\r\nif (pst[j].fid > MAX_FID) {\r\nprintk(KERN_ERR FW_BUG PFX "maxfid exceeded with pstate"\r\n" %d\n", j);\r\nreturn -ENODEV;\r\n}\r\nif (j && (pst[j].fid < HI_FID_TABLE_BOTTOM)) {\r\nprintk(KERN_ERR FW_BUG PFX "two low fids - %d : "\r\n"0x%x\n", j, pst[j].fid);\r\nreturn -EINVAL;\r\n}\r\nif (pst[j].fid < lastfid)\r\nlastfid = pst[j].fid;\r\n}\r\nif (lastfid & 1) {\r\nprintk(KERN_ERR FW_BUG PFX "lastfid invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif (lastfid > LO_FID_TABLE_TOP)\r\nprintk(KERN_INFO FW_BUG PFX\r\n"first fid not from lo freq table\n");\r\nreturn 0;\r\n}\r\nstatic void invalidate_entry(struct cpufreq_frequency_table *powernow_table,\r\nunsigned int entry)\r\n{\r\npowernow_table[entry].frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\nstatic void print_basics(struct powernow_k8_data *data)\r\n{\r\nint j;\r\nfor (j = 0; j < data->numps; j++) {\r\nif (data->powernow_table[j].frequency !=\r\nCPUFREQ_ENTRY_INVALID) {\r\nif (cpu_family == CPU_HW_PSTATE) {\r\nprintk(KERN_INFO PFX\r\n" %d : pstate %d (%d MHz)\n", j,\r\ndata->powernow_table[j].index,\r\ndata->powernow_table[j].frequency/1000);\r\n} else {\r\nprintk(KERN_INFO PFX\r\n"fid 0x%x (%d MHz), vid 0x%x\n",\r\ndata->powernow_table[j].index & 0xff,\r\ndata->powernow_table[j].frequency/1000,\r\ndata->powernow_table[j].index >> 8);\r\n}\r\n}\r\n}\r\nif (data->batps)\r\nprintk(KERN_INFO PFX "Only %d pstates on battery\n",\r\ndata->batps);\r\n}\r\nstatic u32 freq_from_fid_did(u32 fid, u32 did)\r\n{\r\nu32 mhz = 0;\r\nif (boot_cpu_data.x86 == 0x10)\r\nmhz = (100 * (fid + 0x10)) >> did;\r\nelse if (boot_cpu_data.x86 == 0x11)\r\nmhz = (100 * (fid + 8)) >> did;\r\nelse\r\nBUG();\r\nreturn mhz * 1000;\r\n}\r\nstatic int fill_powernow_table(struct powernow_k8_data *data,\r\nstruct pst_s *pst, u8 maxvid)\r\n{\r\nstruct cpufreq_frequency_table *powernow_table;\r\nunsigned int j;\r\nif (data->batps) {\r\nprintk(KERN_WARNING PFX\r\n"Only %d pstates usable (use ACPI driver for full "\r\n"range\n", data->batps);\r\ndata->numps = data->batps;\r\n}\r\nfor (j = 1; j < data->numps; j++) {\r\nif (pst[j-1].fid >= pst[j].fid) {\r\nprintk(KERN_ERR PFX "PST out of sequence\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data->numps < 2) {\r\nprintk(KERN_ERR PFX "no p states to transition\n");\r\nreturn -ENODEV;\r\n}\r\nif (check_pst_table(data, pst, maxvid))\r\nreturn -EINVAL;\r\npowernow_table = kmalloc((sizeof(struct cpufreq_frequency_table)\r\n* (data->numps + 1)), GFP_KERNEL);\r\nif (!powernow_table) {\r\nprintk(KERN_ERR PFX "powernow_table memory alloc failure\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (j = 0; j < data->numps; j++) {\r\nint freq;\r\npowernow_table[j].index = pst[j].fid;\r\npowernow_table[j].index |= (pst[j].vid << 8);\r\nfreq = find_khz_freq_from_fid(pst[j].fid);\r\npowernow_table[j].frequency = freq;\r\n}\r\npowernow_table[data->numps].frequency = CPUFREQ_TABLE_END;\r\npowernow_table[data->numps].index = 0;\r\nif (query_current_values_with_pending_wait(data)) {\r\nkfree(powernow_table);\r\nreturn -EIO;\r\n}\r\npr_debug("cfid 0x%x, cvid 0x%x\n", data->currfid, data->currvid);\r\ndata->powernow_table = powernow_table;\r\nif (cpumask_first(cpu_core_mask(data->cpu)) == data->cpu)\r\nprint_basics(data);\r\nfor (j = 0; j < data->numps; j++)\r\nif ((pst[j].fid == data->currfid) &&\r\n(pst[j].vid == data->currvid))\r\nreturn 0;\r\npr_debug("currfid/vid do not match PST, ignoring\n");\r\nreturn 0;\r\n}\r\nstatic int find_psb_table(struct powernow_k8_data *data)\r\n{\r\nstruct psb_s *psb;\r\nunsigned int i;\r\nu32 mvs;\r\nu8 maxvid;\r\nu32 cpst = 0;\r\nu32 thiscpuid;\r\nfor (i = 0xc0000; i < 0xffff0; i += 0x10) {\r\npsb = phys_to_virt(i);\r\nif (memcmp(psb, PSB_ID_STRING, PSB_ID_STRING_LEN) != 0)\r\ncontinue;\r\npr_debug("found PSB header at 0x%p\n", psb);\r\npr_debug("table vers: 0x%x\n", psb->tableversion);\r\nif (psb->tableversion != PSB_VERSION_1_4) {\r\nprintk(KERN_ERR FW_BUG PFX "PSB table is not v1.4\n");\r\nreturn -ENODEV;\r\n}\r\npr_debug("flags: 0x%x\n", psb->flags1);\r\nif (psb->flags1) {\r\nprintk(KERN_ERR FW_BUG PFX "unknown flags\n");\r\nreturn -ENODEV;\r\n}\r\ndata->vstable = psb->vstable;\r\npr_debug("voltage stabilization time: %d(*20us)\n",\r\ndata->vstable);\r\npr_debug("flags2: 0x%x\n", psb->flags2);\r\ndata->rvo = psb->flags2 & 3;\r\ndata->irt = ((psb->flags2) >> 2) & 3;\r\nmvs = ((psb->flags2) >> 4) & 3;\r\ndata->vidmvs = 1 << mvs;\r\ndata->batps = ((psb->flags2) >> 6) & 3;\r\npr_debug("ramp voltage offset: %d\n", data->rvo);\r\npr_debug("isochronous relief time: %d\n", data->irt);\r\npr_debug("maximum voltage step: %d - 0x%x\n", mvs, data->vidmvs);\r\npr_debug("numpst: 0x%x\n", psb->num_tables);\r\ncpst = psb->num_tables;\r\nif ((psb->cpuid == 0x00000fc0) ||\r\n(psb->cpuid == 0x00000fe0)) {\r\nthiscpuid = cpuid_eax(CPUID_PROCESSOR_SIGNATURE);\r\nif ((thiscpuid == 0x00000fc0) ||\r\n(thiscpuid == 0x00000fe0))\r\ncpst = 1;\r\n}\r\nif (cpst != 1) {\r\nprintk(KERN_ERR FW_BUG PFX "numpst must be 1\n");\r\nreturn -ENODEV;\r\n}\r\ndata->plllock = psb->plllocktime;\r\npr_debug("plllocktime: 0x%x (units 1us)\n", psb->plllocktime);\r\npr_debug("maxfid: 0x%x\n", psb->maxfid);\r\npr_debug("maxvid: 0x%x\n", psb->maxvid);\r\nmaxvid = psb->maxvid;\r\ndata->numps = psb->numps;\r\npr_debug("numpstates: 0x%x\n", data->numps);\r\nreturn fill_powernow_table(data,\r\n(struct pst_s *)(psb+1), maxvid);\r\n}\r\nprintk(KERN_ERR FW_BUG PFX "No PSB or ACPI _PSS objects\n");\r\nprintk(KERN_ERR PFX "Make sure that your BIOS is up to date"\r\n" and Cool'N'Quiet support is enabled in BIOS setup\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void powernow_k8_acpi_pst_values(struct powernow_k8_data *data,\r\nunsigned int index)\r\n{\r\nu64 control;\r\nif (!data->acpi_data.state_count || (cpu_family == CPU_HW_PSTATE))\r\nreturn;\r\ncontrol = data->acpi_data.states[index].control;\r\ndata->irt = (control >> IRT_SHIFT) & IRT_MASK;\r\ndata->rvo = (control >> RVO_SHIFT) & RVO_MASK;\r\ndata->exttype = (control >> EXT_TYPE_SHIFT) & EXT_TYPE_MASK;\r\ndata->plllock = (control >> PLL_L_SHIFT) & PLL_L_MASK;\r\ndata->vidmvs = 1 << ((control >> MVS_SHIFT) & MVS_MASK);\r\ndata->vstable = (control >> VST_SHIFT) & VST_MASK;\r\n}\r\nstatic int powernow_k8_cpu_init_acpi(struct powernow_k8_data *data)\r\n{\r\nstruct cpufreq_frequency_table *powernow_table;\r\nint ret_val = -ENODEV;\r\nu64 control, status;\r\nif (acpi_processor_register_performance(&data->acpi_data, data->cpu)) {\r\npr_debug("register performance failed: bad ACPI data\n");\r\nreturn -EIO;\r\n}\r\nif (data->acpi_data.state_count <= 1) {\r\npr_debug("No ACPI P-States\n");\r\ngoto err_out;\r\n}\r\ncontrol = data->acpi_data.control_register.space_id;\r\nstatus = data->acpi_data.status_register.space_id;\r\nif ((control != ACPI_ADR_SPACE_FIXED_HARDWARE) ||\r\n(status != ACPI_ADR_SPACE_FIXED_HARDWARE)) {\r\npr_debug("Invalid control/status registers (%llx - %llx)\n",\r\ncontrol, status);\r\ngoto err_out;\r\n}\r\npowernow_table = kmalloc((sizeof(struct cpufreq_frequency_table)\r\n* (data->acpi_data.state_count + 1)), GFP_KERNEL);\r\nif (!powernow_table) {\r\npr_debug("powernow_table memory alloc failure\n");\r\ngoto err_out;\r\n}\r\ndata->numps = data->acpi_data.state_count;\r\npowernow_k8_acpi_pst_values(data, 0);\r\nif (cpu_family == CPU_HW_PSTATE)\r\nret_val = fill_powernow_table_pstate(data, powernow_table);\r\nelse\r\nret_val = fill_powernow_table_fidvid(data, powernow_table);\r\nif (ret_val)\r\ngoto err_out_mem;\r\npowernow_table[data->acpi_data.state_count].frequency =\r\nCPUFREQ_TABLE_END;\r\npowernow_table[data->acpi_data.state_count].index = 0;\r\ndata->powernow_table = powernow_table;\r\nif (cpumask_first(cpu_core_mask(data->cpu)) == data->cpu)\r\nprint_basics(data);\r\nacpi_processor_notify_smm(THIS_MODULE);\r\nif (!zalloc_cpumask_var(&data->acpi_data.shared_cpu_map, GFP_KERNEL)) {\r\nprintk(KERN_ERR PFX\r\n"unable to alloc powernow_k8_data cpumask\n");\r\nret_val = -ENOMEM;\r\ngoto err_out_mem;\r\n}\r\nreturn 0;\r\nerr_out_mem:\r\nkfree(powernow_table);\r\nerr_out:\r\nacpi_processor_unregister_performance(&data->acpi_data, data->cpu);\r\ndata->acpi_data.state_count = 0;\r\nreturn ret_val;\r\n}\r\nstatic int fill_powernow_table_pstate(struct powernow_k8_data *data,\r\nstruct cpufreq_frequency_table *powernow_table)\r\n{\r\nint i;\r\nu32 hi = 0, lo = 0;\r\nrdmsr(MSR_PSTATE_CUR_LIMIT, lo, hi);\r\ndata->max_hw_pstate = (lo & HW_PSTATE_MAX_MASK) >> HW_PSTATE_MAX_SHIFT;\r\nfor (i = 0; i < data->acpi_data.state_count; i++) {\r\nu32 index;\r\nindex = data->acpi_data.states[i].control & HW_PSTATE_MASK;\r\nif (index > data->max_hw_pstate) {\r\nprintk(KERN_ERR PFX "invalid pstate %d - "\r\n"bad value %d.\n", i, index);\r\nprintk(KERN_ERR PFX "Please report to BIOS "\r\n"manufacturer\n");\r\ninvalidate_entry(powernow_table, i);\r\ncontinue;\r\n}\r\nrdmsr(MSR_PSTATE_DEF_BASE + index, lo, hi);\r\nif (!(hi & HW_PSTATE_VALID_MASK)) {\r\npr_debug("invalid pstate %d, ignoring\n", index);\r\ninvalidate_entry(powernow_table, i);\r\ncontinue;\r\n}\r\npowernow_table[i].index = index;\r\nif ((boot_cpu_data.x86 == 0x10 && boot_cpu_data.x86_model < 10)\r\n|| boot_cpu_data.x86 == 0x11) {\r\npowernow_table[i].frequency =\r\nfreq_from_fid_did(lo & 0x3f, (lo >> 6) & 7);\r\n} else\r\npowernow_table[i].frequency =\r\ndata->acpi_data.states[i].core_frequency * 1000;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fill_powernow_table_fidvid(struct powernow_k8_data *data,\r\nstruct cpufreq_frequency_table *powernow_table)\r\n{\r\nint i;\r\nfor (i = 0; i < data->acpi_data.state_count; i++) {\r\nu32 fid;\r\nu32 vid;\r\nu32 freq, index;\r\nu64 status, control;\r\nif (data->exttype) {\r\nstatus = data->acpi_data.states[i].status;\r\nfid = status & EXT_FID_MASK;\r\nvid = (status >> VID_SHIFT) & EXT_VID_MASK;\r\n} else {\r\ncontrol = data->acpi_data.states[i].control;\r\nfid = control & FID_MASK;\r\nvid = (control >> VID_SHIFT) & VID_MASK;\r\n}\r\npr_debug(" %d : fid 0x%x, vid 0x%x\n", i, fid, vid);\r\nindex = fid | (vid<<8);\r\npowernow_table[i].index = index;\r\nfreq = find_khz_freq_from_fid(fid);\r\npowernow_table[i].frequency = freq;\r\nif ((freq > (MAX_FREQ * 1000)) || (freq < (MIN_FREQ * 1000))) {\r\npr_debug("invalid freq %u kHz, ignoring\n", freq);\r\ninvalidate_entry(powernow_table, i);\r\ncontinue;\r\n}\r\nif (vid == VID_OFF) {\r\npr_debug("invalid vid %u, ignoring\n", vid);\r\ninvalidate_entry(powernow_table, i);\r\ncontinue;\r\n}\r\nif (freq != (data->acpi_data.states[i].core_frequency * 1000)) {\r\nprintk(KERN_INFO PFX "invalid freq entries "\r\n"%u kHz vs. %u kHz\n", freq,\r\n(unsigned int)\r\n(data->acpi_data.states[i].core_frequency\r\n* 1000));\r\ninvalidate_entry(powernow_table, i);\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void powernow_k8_cpu_exit_acpi(struct powernow_k8_data *data)\r\n{\r\nif (data->acpi_data.state_count)\r\nacpi_processor_unregister_performance(&data->acpi_data,\r\ndata->cpu);\r\nfree_cpumask_var(data->acpi_data.shared_cpu_map);\r\n}\r\nstatic int get_transition_latency(struct powernow_k8_data *data)\r\n{\r\nint max_latency = 0;\r\nint i;\r\nfor (i = 0; i < data->acpi_data.state_count; i++) {\r\nint cur_latency = data->acpi_data.states[i].transition_latency\r\n+ data->acpi_data.states[i].bus_master_latency;\r\nif (cur_latency > max_latency)\r\nmax_latency = cur_latency;\r\n}\r\nif (max_latency == 0) {\r\nif (boot_cpu_data.x86 < 0x11)\r\nprintk(KERN_ERR FW_WARN PFX "Invalid zero transition "\r\n"latency\n");\r\nmax_latency = 1;\r\n}\r\nreturn 1000 * max_latency;\r\n}\r\nstatic int transition_frequency_fidvid(struct powernow_k8_data *data,\r\nunsigned int index)\r\n{\r\nu32 fid = 0;\r\nu32 vid = 0;\r\nint res, i;\r\nstruct cpufreq_freqs freqs;\r\npr_debug("cpu %d transition to index %u\n", smp_processor_id(), index);\r\nfid = data->powernow_table[index].index & 0xFF;\r\nvid = (data->powernow_table[index].index & 0xFF00) >> 8;\r\npr_debug("table matched fid 0x%x, giving vid 0x%x\n", fid, vid);\r\nif (query_current_values_with_pending_wait(data))\r\nreturn 1;\r\nif ((data->currvid == vid) && (data->currfid == fid)) {\r\npr_debug("target matches current values (fid 0x%x, vid 0x%x)\n",\r\nfid, vid);\r\nreturn 0;\r\n}\r\npr_debug("cpu %d, changing to fid 0x%x, vid 0x%x\n",\r\nsmp_processor_id(), fid, vid);\r\nfreqs.old = find_khz_freq_from_fid(data->currfid);\r\nfreqs.new = find_khz_freq_from_fid(fid);\r\nfor_each_cpu(i, data->available_cores) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\n}\r\nres = transition_fid_vid(data, fid, vid);\r\nif (res)\r\nreturn res;\r\nfreqs.new = find_khz_freq_from_fid(data->currfid);\r\nfor_each_cpu(i, data->available_cores) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n}\r\nreturn res;\r\n}\r\nstatic int transition_frequency_pstate(struct powernow_k8_data *data,\r\nunsigned int index)\r\n{\r\nu32 pstate = 0;\r\nint res, i;\r\nstruct cpufreq_freqs freqs;\r\npr_debug("cpu %d transition to index %u\n", smp_processor_id(), index);\r\npstate = index & HW_PSTATE_MASK;\r\nif (pstate > data->max_hw_pstate)\r\nreturn -EINVAL;\r\nfreqs.old = find_khz_freq_from_pstate(data->powernow_table,\r\ndata->currpstate);\r\nfreqs.new = find_khz_freq_from_pstate(data->powernow_table, pstate);\r\nfor_each_cpu(i, data->available_cores) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\n}\r\nres = transition_pstate(data, pstate);\r\nfreqs.new = find_khz_freq_from_pstate(data->powernow_table, pstate);\r\nfor_each_cpu(i, data->available_cores) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n}\r\nreturn res;\r\n}\r\nstatic int powernowk8_target(struct cpufreq_policy *pol,\r\nunsigned targfreq, unsigned relation)\r\n{\r\ncpumask_var_t oldmask;\r\nstruct powernow_k8_data *data = per_cpu(powernow_data, pol->cpu);\r\nu32 checkfid;\r\nu32 checkvid;\r\nunsigned int newstate;\r\nint ret = -EIO;\r\nif (!data)\r\nreturn -EINVAL;\r\ncheckfid = data->currfid;\r\ncheckvid = data->currvid;\r\nif (!alloc_cpumask_var(&oldmask, GFP_KERNEL))\r\nreturn -ENOMEM;\r\ncpumask_copy(oldmask, tsk_cpus_allowed(current));\r\nset_cpus_allowed_ptr(current, cpumask_of(pol->cpu));\r\nif (smp_processor_id() != pol->cpu) {\r\nprintk(KERN_ERR PFX "limiting to cpu %u failed\n", pol->cpu);\r\ngoto err_out;\r\n}\r\nif (pending_bit_stuck()) {\r\nprintk(KERN_ERR PFX "failing targ, change pending bit set\n");\r\ngoto err_out;\r\n}\r\npr_debug("targ: cpu %d, %d kHz, min %d, max %d, relation %d\n",\r\npol->cpu, targfreq, pol->min, pol->max, relation);\r\nif (query_current_values_with_pending_wait(data))\r\ngoto err_out;\r\nif (cpu_family != CPU_HW_PSTATE) {\r\npr_debug("targ: curr fid 0x%x, vid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nif ((checkvid != data->currvid) ||\r\n(checkfid != data->currfid)) {\r\nprintk(KERN_INFO PFX\r\n"error - out of sync, fix 0x%x 0x%x, "\r\n"vid 0x%x 0x%x\n",\r\ncheckfid, data->currfid,\r\ncheckvid, data->currvid);\r\n}\r\n}\r\nif (cpufreq_frequency_table_target(pol, data->powernow_table,\r\ntargfreq, relation, &newstate))\r\ngoto err_out;\r\nmutex_lock(&fidvid_mutex);\r\npowernow_k8_acpi_pst_values(data, newstate);\r\nif (cpu_family == CPU_HW_PSTATE)\r\nret = transition_frequency_pstate(data, newstate);\r\nelse\r\nret = transition_frequency_fidvid(data, newstate);\r\nif (ret) {\r\nprintk(KERN_ERR PFX "transition frequency failed\n");\r\nret = 1;\r\nmutex_unlock(&fidvid_mutex);\r\ngoto err_out;\r\n}\r\nmutex_unlock(&fidvid_mutex);\r\nif (cpu_family == CPU_HW_PSTATE)\r\npol->cur = find_khz_freq_from_pstate(data->powernow_table,\r\nnewstate);\r\nelse\r\npol->cur = find_khz_freq_from_fid(data->currfid);\r\nret = 0;\r\nerr_out:\r\nset_cpus_allowed_ptr(current, oldmask);\r\nfree_cpumask_var(oldmask);\r\nreturn ret;\r\n}\r\nstatic int powernowk8_verify(struct cpufreq_policy *pol)\r\n{\r\nstruct powernow_k8_data *data = per_cpu(powernow_data, pol->cpu);\r\nif (!data)\r\nreturn -EINVAL;\r\nreturn cpufreq_frequency_table_verify(pol, data->powernow_table);\r\n}\r\nstatic void __cpuinit powernowk8_cpu_init_on_cpu(void *_init_on_cpu)\r\n{\r\nstruct init_on_cpu *init_on_cpu = _init_on_cpu;\r\nif (pending_bit_stuck()) {\r\nprintk(KERN_ERR PFX "failing init, change pending bit set\n");\r\ninit_on_cpu->rc = -ENODEV;\r\nreturn;\r\n}\r\nif (query_current_values_with_pending_wait(init_on_cpu->data)) {\r\ninit_on_cpu->rc = -ENODEV;\r\nreturn;\r\n}\r\nif (cpu_family == CPU_OPTERON)\r\nfidvid_msr_init();\r\ninit_on_cpu->rc = 0;\r\n}\r\nstatic int __cpuinit powernowk8_cpu_init(struct cpufreq_policy *pol)\r\n{\r\nstatic const char ACPI_PSS_BIOS_BUG_MSG[] =\r\nKERN_ERR FW_BUG PFX "No compatible ACPI _PSS objects found.\n"\r\nFW_BUG PFX "Try again with latest BIOS.\n";\r\nstruct powernow_k8_data *data;\r\nstruct init_on_cpu init_on_cpu;\r\nint rc;\r\nstruct cpuinfo_x86 *c = &cpu_data(pol->cpu);\r\nif (!cpu_online(pol->cpu))\r\nreturn -ENODEV;\r\nsmp_call_function_single(pol->cpu, check_supported_cpu, &rc, 1);\r\nif (rc)\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(struct powernow_k8_data), GFP_KERNEL);\r\nif (!data) {\r\nprintk(KERN_ERR PFX "unable to alloc powernow_k8_data");\r\nreturn -ENOMEM;\r\n}\r\ndata->cpu = pol->cpu;\r\ndata->currpstate = HW_PSTATE_INVALID;\r\nif (powernow_k8_cpu_init_acpi(data)) {\r\nif (num_online_cpus() != 1) {\r\nprintk_once(ACPI_PSS_BIOS_BUG_MSG);\r\ngoto err_out;\r\n}\r\nif (pol->cpu != 0) {\r\nprintk(KERN_ERR FW_BUG PFX "No ACPI _PSS objects for "\r\n"CPU other than CPU0. Complain to your BIOS "\r\n"vendor.\n");\r\ngoto err_out;\r\n}\r\nrc = find_psb_table(data);\r\nif (rc)\r\ngoto err_out;\r\npol->cpuinfo.transition_latency = (\r\n((data->rvo + 8) * data->vstable * VST_UNITS_20US) +\r\n((1 << data->irt) * 30)) * 1000;\r\n} else\r\npol->cpuinfo.transition_latency = get_transition_latency(data);\r\ninit_on_cpu.data = data;\r\nsmp_call_function_single(data->cpu, powernowk8_cpu_init_on_cpu,\r\n&init_on_cpu, 1);\r\nrc = init_on_cpu.rc;\r\nif (rc != 0)\r\ngoto err_out_exit_acpi;\r\nif (cpu_family == CPU_HW_PSTATE)\r\ncpumask_copy(pol->cpus, cpumask_of(pol->cpu));\r\nelse\r\ncpumask_copy(pol->cpus, cpu_core_mask(pol->cpu));\r\ndata->available_cores = pol->cpus;\r\nif (cpu_family == CPU_HW_PSTATE)\r\npol->cur = find_khz_freq_from_pstate(data->powernow_table,\r\ndata->currpstate);\r\nelse\r\npol->cur = find_khz_freq_from_fid(data->currfid);\r\npr_debug("policy current frequency %d kHz\n", pol->cur);\r\nif (cpufreq_frequency_table_cpuinfo(pol, data->powernow_table)) {\r\nprintk(KERN_ERR FW_BUG PFX "invalid powernow_table\n");\r\npowernow_k8_cpu_exit_acpi(data);\r\nkfree(data->powernow_table);\r\nkfree(data);\r\nreturn -EINVAL;\r\n}\r\nif (cpu_has(c, X86_FEATURE_APERFMPERF))\r\ncpufreq_amd64_driver.getavg = cpufreq_get_measured_perf;\r\ncpufreq_frequency_table_get_attr(data->powernow_table, pol->cpu);\r\nif (cpu_family == CPU_HW_PSTATE)\r\npr_debug("cpu_init done, current pstate 0x%x\n",\r\ndata->currpstate);\r\nelse\r\npr_debug("cpu_init done, current fid 0x%x, vid 0x%x\n",\r\ndata->currfid, data->currvid);\r\nper_cpu(powernow_data, pol->cpu) = data;\r\nreturn 0;\r\nerr_out_exit_acpi:\r\npowernow_k8_cpu_exit_acpi(data);\r\nerr_out:\r\nkfree(data);\r\nreturn -ENODEV;\r\n}\r\nstatic int __devexit powernowk8_cpu_exit(struct cpufreq_policy *pol)\r\n{\r\nstruct powernow_k8_data *data = per_cpu(powernow_data, pol->cpu);\r\nif (!data)\r\nreturn -EINVAL;\r\npowernow_k8_cpu_exit_acpi(data);\r\ncpufreq_frequency_table_put_attr(pol->cpu);\r\nkfree(data->powernow_table);\r\nkfree(data);\r\nper_cpu(powernow_data, pol->cpu) = NULL;\r\nreturn 0;\r\n}\r\nstatic void query_values_on_cpu(void *_err)\r\n{\r\nint *err = _err;\r\nstruct powernow_k8_data *data = __this_cpu_read(powernow_data);\r\n*err = query_current_values_with_pending_wait(data);\r\n}\r\nstatic unsigned int powernowk8_get(unsigned int cpu)\r\n{\r\nstruct powernow_k8_data *data = per_cpu(powernow_data, cpu);\r\nunsigned int khz = 0;\r\nint err;\r\nif (!data)\r\nreturn 0;\r\nsmp_call_function_single(cpu, query_values_on_cpu, &err, true);\r\nif (err)\r\ngoto out;\r\nif (cpu_family == CPU_HW_PSTATE)\r\nkhz = find_khz_freq_from_pstate(data->powernow_table,\r\ndata->currpstate);\r\nelse\r\nkhz = find_khz_freq_from_fid(data->currfid);\r\nout:\r\nreturn khz;\r\n}\r\nstatic void _cpb_toggle_msrs(bool t)\r\n{\r\nint cpu;\r\nget_online_cpus();\r\nrdmsr_on_cpus(cpu_online_mask, MSR_K7_HWCR, msrs);\r\nfor_each_cpu(cpu, cpu_online_mask) {\r\nstruct msr *reg = per_cpu_ptr(msrs, cpu);\r\nif (t)\r\nreg->l &= ~BIT(25);\r\nelse\r\nreg->l |= BIT(25);\r\n}\r\nwrmsr_on_cpus(cpu_online_mask, MSR_K7_HWCR, msrs);\r\nput_online_cpus();\r\n}\r\nstatic void cpb_toggle(bool t)\r\n{\r\nif (!cpb_capable)\r\nreturn;\r\nif (t && !cpb_enabled) {\r\ncpb_enabled = true;\r\n_cpb_toggle_msrs(t);\r\nprintk(KERN_INFO PFX "Core Boosting enabled.\n");\r\n} else if (!t && cpb_enabled) {\r\ncpb_enabled = false;\r\n_cpb_toggle_msrs(t);\r\nprintk(KERN_INFO PFX "Core Boosting disabled.\n");\r\n}\r\n}\r\nstatic ssize_t store_cpb(struct cpufreq_policy *policy, const char *buf,\r\nsize_t count)\r\n{\r\nint ret = -EINVAL;\r\nunsigned long val = 0;\r\nret = strict_strtoul(buf, 10, &val);\r\nif (!ret && (val == 0 || val == 1) && cpb_capable)\r\ncpb_toggle(val);\r\nelse\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic ssize_t show_cpb(struct cpufreq_policy *policy, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", cpb_enabled);\r\n}\r\nstatic int cpb_notify(struct notifier_block *nb, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nunsigned cpu = (long)hcpu;\r\nu32 lo, hi;\r\nswitch (action) {\r\ncase CPU_UP_PREPARE:\r\ncase CPU_UP_PREPARE_FROZEN:\r\nif (!cpb_enabled) {\r\nrdmsr_on_cpu(cpu, MSR_K7_HWCR, &lo, &hi);\r\nlo |= BIT(25);\r\nwrmsr_on_cpu(cpu, MSR_K7_HWCR, lo, hi);\r\n}\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\ncase CPU_DOWN_PREPARE_FROZEN:\r\nrdmsr_on_cpu(cpu, MSR_K7_HWCR, &lo, &hi);\r\nlo &= ~BIT(25);\r\nwrmsr_on_cpu(cpu, MSR_K7_HWCR, lo, hi);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __cpuinit powernowk8_init(void)\r\n{\r\nunsigned int i, supported_cpus = 0, cpu;\r\nint rv;\r\nfor_each_online_cpu(i) {\r\nint rc;\r\nsmp_call_function_single(i, check_supported_cpu, &rc, 1);\r\nif (rc == 0)\r\nsupported_cpus++;\r\n}\r\nif (supported_cpus != num_online_cpus())\r\nreturn -ENODEV;\r\nprintk(KERN_INFO PFX "Found %d %s (%d cpu cores) (" VERSION ")\n",\r\nnum_online_nodes(), boot_cpu_data.x86_model_id, supported_cpus);\r\nif (boot_cpu_has(X86_FEATURE_CPB)) {\r\ncpb_capable = true;\r\nmsrs = msrs_alloc();\r\nif (!msrs) {\r\nprintk(KERN_ERR "%s: Error allocating msrs!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nregister_cpu_notifier(&cpb_nb);\r\nrdmsr_on_cpus(cpu_online_mask, MSR_K7_HWCR, msrs);\r\nfor_each_cpu(cpu, cpu_online_mask) {\r\nstruct msr *reg = per_cpu_ptr(msrs, cpu);\r\ncpb_enabled |= !(!!(reg->l & BIT(25)));\r\n}\r\nprintk(KERN_INFO PFX "Core Performance Boosting: %s.\n",\r\n(cpb_enabled ? "on" : "off"));\r\n}\r\nrv = cpufreq_register_driver(&cpufreq_amd64_driver);\r\nif (rv < 0 && boot_cpu_has(X86_FEATURE_CPB)) {\r\nunregister_cpu_notifier(&cpb_nb);\r\nmsrs_free(msrs);\r\nmsrs = NULL;\r\n}\r\nreturn rv;\r\n}\r\nstatic void __exit powernowk8_exit(void)\r\n{\r\npr_debug("exit\n");\r\nif (boot_cpu_has(X86_FEATURE_CPB)) {\r\nmsrs_free(msrs);\r\nmsrs = NULL;\r\nunregister_cpu_notifier(&cpb_nb);\r\n}\r\ncpufreq_unregister_driver(&cpufreq_amd64_driver);\r\n}
