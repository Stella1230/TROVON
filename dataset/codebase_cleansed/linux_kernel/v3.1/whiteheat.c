static int whiteheat_firmware_download(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nint response, ret = -ENOENT;\r\nconst struct firmware *loader_fw = NULL, *firmware_fw = NULL;\r\nconst struct ihex_binrec *record;\r\ndbg("%s", __func__);\r\nif (request_ihex_firmware(&firmware_fw, "whiteheat.fw",\r\n&serial->dev->dev)) {\r\ndev_err(&serial->dev->dev,\r\n"%s - request \"whiteheat.fw\" failed\n", __func__);\r\ngoto out;\r\n}\r\nif (request_ihex_firmware(&loader_fw, "whiteheat_loader.fw",\r\n&serial->dev->dev)) {\r\ndev_err(&serial->dev->dev,\r\n"%s - request \"whiteheat_loader.fw\" failed\n",\r\n__func__);\r\ngoto out;\r\n}\r\nret = 0;\r\nresponse = ezusb_set_reset (serial, 1);\r\nrecord = (const struct ihex_binrec *)loader_fw->data;\r\nwhile (record) {\r\nresponse = ezusb_writememory (serial, be32_to_cpu(record->addr),\r\n(unsigned char *)record->data,\r\nbe16_to_cpu(record->len), 0xa0);\r\nif (response < 0) {\r\ndev_err(&serial->dev->dev, "%s - ezusb_writememory "\r\n"failed for loader (%d %04X %p %d)\n",\r\n__func__, response, be32_to_cpu(record->addr),\r\nrecord->data, be16_to_cpu(record->len));\r\nbreak;\r\n}\r\nrecord = ihex_next_binrec(record);\r\n}\r\nresponse = ezusb_set_reset(serial, 0);\r\nrecord = (const struct ihex_binrec *)firmware_fw->data;\r\nwhile (record && be32_to_cpu(record->addr) < 0x1b40)\r\nrecord = ihex_next_binrec(record);\r\nwhile (record) {\r\nresponse = ezusb_writememory (serial, be32_to_cpu(record->addr),\r\n(unsigned char *)record->data,\r\nbe16_to_cpu(record->len), 0xa3);\r\nif (response < 0) {\r\ndev_err(&serial->dev->dev, "%s - ezusb_writememory "\r\n"failed for first firmware step "\r\n"(%d %04X %p %d)\n", __func__, response,\r\nbe32_to_cpu(record->addr), record->data,\r\nbe16_to_cpu(record->len));\r\nbreak;\r\n}\r\n++record;\r\n}\r\nresponse = ezusb_set_reset(serial, 1);\r\nrecord = (const struct ihex_binrec *)firmware_fw->data;\r\nwhile (record && be32_to_cpu(record->addr) < 0x1b40) {\r\nresponse = ezusb_writememory (serial, be32_to_cpu(record->addr),\r\n(unsigned char *)record->data,\r\nbe16_to_cpu(record->len), 0xa0);\r\nif (response < 0) {\r\ndev_err(&serial->dev->dev, "%s - ezusb_writememory "\r\n"failed for second firmware step "\r\n"(%d %04X %p %d)\n", __func__, response,\r\nbe32_to_cpu(record->addr), record->data,\r\nbe16_to_cpu(record->len));\r\nbreak;\r\n}\r\n++record;\r\n}\r\nret = 0;\r\nresponse = ezusb_set_reset (serial, 0);\r\nout:\r\nrelease_firmware(loader_fw);\r\nrelease_firmware(firmware_fw);\r\nreturn ret;\r\n}\r\nstatic int whiteheat_firmware_attach(struct usb_serial *serial)\r\n{\r\nreturn 1;\r\n}\r\nstatic int whiteheat_attach(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_command_private *command_info;\r\nstruct usb_serial_port *port;\r\nstruct whiteheat_private *info;\r\nstruct whiteheat_hw_info *hw_info;\r\nint pipe;\r\nint ret;\r\nint alen;\r\n__u8 *command;\r\n__u8 *result;\r\nint i;\r\nint j;\r\nstruct urb *urb;\r\nint buf_size;\r\nstruct whiteheat_urb_wrap *wrap;\r\nstruct list_head *tmp;\r\ncommand_port = serial->port[COMMAND_PORT];\r\npipe = usb_sndbulkpipe(serial->dev,\r\ncommand_port->bulk_out_endpointAddress);\r\ncommand = kmalloc(2, GFP_KERNEL);\r\nif (!command)\r\ngoto no_command_buffer;\r\ncommand[0] = WHITEHEAT_GET_HW_INFO;\r\ncommand[1] = 0;\r\nresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\r\nif (!result)\r\ngoto no_result_buffer;\r\nusb_clear_halt(serial->dev, pipe);\r\nret = usb_bulk_msg(serial->dev, pipe, command, 2,\r\n&alen, COMMAND_TIMEOUT_MS);\r\nif (ret) {\r\ndev_err(&serial->dev->dev, "%s: Couldn't send command [%d]\n",\r\nserial->type->description, ret);\r\ngoto no_firmware;\r\n} else if (alen != 2) {\r\ndev_err(&serial->dev->dev, "%s: Send command incomplete [%d]\n",\r\nserial->type->description, alen);\r\ngoto no_firmware;\r\n}\r\npipe = usb_rcvbulkpipe(serial->dev,\r\ncommand_port->bulk_in_endpointAddress);\r\nusb_clear_halt(serial->dev, pipe);\r\nret = usb_bulk_msg(serial->dev, pipe, result,\r\nsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\r\nif (ret) {\r\ndev_err(&serial->dev->dev, "%s: Couldn't get results [%d]\n",\r\nserial->type->description, ret);\r\ngoto no_firmware;\r\n} else if (alen != sizeof(*hw_info) + 1) {\r\ndev_err(&serial->dev->dev, "%s: Get results incomplete [%d]\n",\r\nserial->type->description, alen);\r\ngoto no_firmware;\r\n} else if (result[0] != command[0]) {\r\ndev_err(&serial->dev->dev, "%s: Command failed [%d]\n",\r\nserial->type->description, result[0]);\r\ngoto no_firmware;\r\n}\r\nhw_info = (struct whiteheat_hw_info *)&result[1];\r\ndev_info(&serial->dev->dev, "%s: Driver %s: Firmware v%d.%02d\n",\r\nserial->type->description, DRIVER_VERSION,\r\nhw_info->sw_major_rev, hw_info->sw_minor_rev);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\ninfo = kmalloc(sizeof(struct whiteheat_private), GFP_KERNEL);\r\nif (info == NULL) {\r\ndev_err(&port->dev,\r\n"%s: Out of memory for port structures\n",\r\nserial->type->description);\r\ngoto no_private;\r\n}\r\nspin_lock_init(&info->lock);\r\nmutex_init(&info->deathwarrant);\r\ninfo->flags = 0;\r\ninfo->mcr = 0;\r\nINIT_WORK(&info->rx_work, rx_data_softint);\r\ninfo->port = port;\r\nINIT_LIST_HEAD(&info->rx_urbs_free);\r\nINIT_LIST_HEAD(&info->rx_urbs_submitted);\r\nINIT_LIST_HEAD(&info->rx_urb_q);\r\nINIT_LIST_HEAD(&info->tx_urbs_free);\r\nINIT_LIST_HEAD(&info->tx_urbs_submitted);\r\nfor (j = 0; j < urb_pool_size; j++) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(&port->dev, "No free urbs available\n");\r\ngoto no_rx_urb;\r\n}\r\nbuf_size = port->read_urb->transfer_buffer_length;\r\nurb->transfer_buffer = kmalloc(buf_size, GFP_KERNEL);\r\nif (!urb->transfer_buffer) {\r\ndev_err(&port->dev,\r\n"Couldn't allocate urb buffer\n");\r\ngoto no_rx_buf;\r\n}\r\nwrap = kmalloc(sizeof(*wrap), GFP_KERNEL);\r\nif (!wrap) {\r\ndev_err(&port->dev,\r\n"Couldn't allocate urb wrapper\n");\r\ngoto no_rx_wrap;\r\n}\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nurb->transfer_buffer, buf_size,\r\nwhiteheat_read_callback, port);\r\nwrap->urb = urb;\r\nlist_add(&wrap->list, &info->rx_urbs_free);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(&port->dev, "No free urbs available\n");\r\ngoto no_tx_urb;\r\n}\r\nbuf_size = port->write_urb->transfer_buffer_length;\r\nurb->transfer_buffer = kmalloc(buf_size, GFP_KERNEL);\r\nif (!urb->transfer_buffer) {\r\ndev_err(&port->dev,\r\n"Couldn't allocate urb buffer\n");\r\ngoto no_tx_buf;\r\n}\r\nwrap = kmalloc(sizeof(*wrap), GFP_KERNEL);\r\nif (!wrap) {\r\ndev_err(&port->dev,\r\n"Couldn't allocate urb wrapper\n");\r\ngoto no_tx_wrap;\r\n}\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->bulk_out_endpointAddress),\r\nurb->transfer_buffer, buf_size,\r\nwhiteheat_write_callback, port);\r\nwrap->urb = urb;\r\nlist_add(&wrap->list, &info->tx_urbs_free);\r\n}\r\nusb_set_serial_port_data(port, info);\r\n}\r\ncommand_info = kmalloc(sizeof(struct whiteheat_command_private),\r\nGFP_KERNEL);\r\nif (command_info == NULL) {\r\ndev_err(&serial->dev->dev,\r\n"%s: Out of memory for port structures\n",\r\nserial->type->description);\r\ngoto no_command_private;\r\n}\r\nmutex_init(&command_info->mutex);\r\ncommand_info->port_running = 0;\r\ninit_waitqueue_head(&command_info->wait_command);\r\nusb_set_serial_port_data(command_port, command_info);\r\ncommand_port->write_urb->complete = command_port_write_callback;\r\ncommand_port->read_urb->complete = command_port_read_callback;\r\nkfree(result);\r\nkfree(command);\r\nreturn 0;\r\nno_firmware:\r\ndev_err(&serial->dev->dev,\r\n"%s: Unable to retrieve firmware version, try replugging\n",\r\nserial->type->description);\r\ndev_err(&serial->dev->dev,\r\n"%s: If the firmware is not running (status led not blinking)\n",\r\nserial->type->description);\r\ndev_err(&serial->dev->dev,\r\n"%s: please contact support@connecttech.com\n",\r\nserial->type->description);\r\nkfree(result);\r\nreturn -ENODEV;\r\nno_command_private:\r\nfor (i = serial->num_ports - 1; i >= 0; i--) {\r\nport = serial->port[i];\r\ninfo = usb_get_serial_port_data(port);\r\nfor (j = urb_pool_size - 1; j >= 0; j--) {\r\ntmp = list_first(&info->tx_urbs_free);\r\nlist_del(tmp);\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nkfree(wrap);\r\nno_tx_wrap:\r\nkfree(urb->transfer_buffer);\r\nno_tx_buf:\r\nusb_free_urb(urb);\r\nno_tx_urb:\r\ntmp = list_first(&info->rx_urbs_free);\r\nlist_del(tmp);\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nkfree(wrap);\r\nno_rx_wrap:\r\nkfree(urb->transfer_buffer);\r\nno_rx_buf:\r\nusb_free_urb(urb);\r\nno_rx_urb:\r\n;\r\n}\r\nkfree(info);\r\nno_private:\r\n;\r\n}\r\nkfree(result);\r\nno_result_buffer:\r\nkfree(command);\r\nno_command_buffer:\r\nreturn -ENOMEM;\r\n}\r\nstatic void whiteheat_release(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct usb_serial_port *port;\r\nstruct whiteheat_private *info;\r\nstruct whiteheat_urb_wrap *wrap;\r\nstruct urb *urb;\r\nstruct list_head *tmp;\r\nstruct list_head *tmp2;\r\nint i;\r\ndbg("%s", __func__);\r\ncommand_port = serial->port[COMMAND_PORT];\r\nkfree(usb_get_serial_port_data(command_port));\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\ninfo = usb_get_serial_port_data(port);\r\nlist_for_each_safe(tmp, tmp2, &info->rx_urbs_free) {\r\nlist_del(tmp);\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nkfree(wrap);\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\nlist_for_each_safe(tmp, tmp2, &info->tx_urbs_free) {\r\nlist_del(tmp);\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nkfree(wrap);\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\nkfree(info);\r\n}\r\n}\r\nstatic int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint retval = 0;\r\ndbg("%s - port %d", __func__, port->number);\r\nretval = start_command_port(port->serial);\r\nif (retval)\r\ngoto exit;\r\nif (tty)\r\ntty->low_latency = 1;\r\nretval = firm_open(port);\r\nif (retval) {\r\nstop_command_port(port->serial);\r\ngoto exit;\r\n}\r\nretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\r\nif (retval) {\r\nfirm_close(port);\r\nstop_command_port(port->serial);\r\ngoto exit;\r\n}\r\nif (tty)\r\nfirm_setup_port(tty);\r\nusb_clear_halt(port->serial->dev, port->read_urb->pipe);\r\nusb_clear_halt(port->serial->dev, port->write_urb->pipe);\r\nretval = start_port_read(port);\r\nif (retval) {\r\ndev_err(&port->dev,\r\n"%s - failed submitting read urb, error %d\n",\r\n__func__, retval);\r\nfirm_close(port);\r\nstop_command_port(port->serial);\r\ngoto exit;\r\n}\r\nexit:\r\ndbg("%s - exit, retval = %d", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic void whiteheat_close(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nstruct whiteheat_urb_wrap *wrap;\r\nstruct urb *urb;\r\nstruct list_head *tmp;\r\nstruct list_head *tmp2;\r\ndbg("%s - port %d", __func__, port->number);\r\nfirm_report_tx_done(port);\r\nfirm_close(port);\r\nmutex_lock(&info->deathwarrant);\r\nspin_lock_irq(&info->lock);\r\nlist_for_each_safe(tmp, tmp2, &info->rx_urbs_submitted) {\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nlist_del(tmp);\r\nspin_unlock_irq(&info->lock);\r\nusb_kill_urb(urb);\r\nspin_lock_irq(&info->lock);\r\nlist_add(tmp, &info->rx_urbs_free);\r\n}\r\nlist_for_each_safe(tmp, tmp2, &info->rx_urb_q)\r\nlist_move(tmp, &info->rx_urbs_free);\r\nlist_for_each_safe(tmp, tmp2, &info->tx_urbs_submitted) {\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nlist_del(tmp);\r\nspin_unlock_irq(&info->lock);\r\nusb_kill_urb(urb);\r\nspin_lock_irq(&info->lock);\r\nlist_add(tmp, &info->tx_urbs_free);\r\n}\r\nspin_unlock_irq(&info->lock);\r\nmutex_unlock(&info->deathwarrant);\r\nstop_command_port(port->serial);\r\n}\r\nstatic int whiteheat_write(struct tty_struct *tty,\r\nstruct usb_serial_port *port, const unsigned char *buf, int count)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nstruct whiteheat_urb_wrap *wrap;\r\nstruct urb *urb;\r\nint result;\r\nint bytes;\r\nint sent = 0;\r\nunsigned long flags;\r\nstruct list_head *tmp;\r\ndbg("%s - port %d", __func__, port->number);\r\nif (count == 0) {\r\ndbg("%s - write request of 0 bytes", __func__);\r\nreturn (0);\r\n}\r\nwhile (count) {\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (list_empty(&info->tx_urbs_free)) {\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nbreak;\r\n}\r\ntmp = list_first(&info->tx_urbs_free);\r\nlist_del(tmp);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nbytes = (count > port->bulk_out_size) ?\r\nport->bulk_out_size : count;\r\nmemcpy(urb->transfer_buffer, buf + sent, bytes);\r\nusb_serial_debug_data(debug, &port->dev,\r\n__func__, bytes, urb->transfer_buffer);\r\nurb->dev = serial->dev;\r\nurb->transfer_buffer_length = bytes;\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - failed submitting write urb, error %d\n",\r\n__func__, result);\r\nsent = result;\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_add(tmp, &info->tx_urbs_free);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nbreak;\r\n} else {\r\nsent += bytes;\r\ncount -= bytes;\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_add(tmp, &info->tx_urbs_submitted);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\n}\r\n}\r\nreturn sent;\r\n}\r\nstatic int whiteheat_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nstruct list_head *tmp;\r\nint room = 0;\r\nunsigned long flags;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_for_each(tmp, &info->tx_urbs_free)\r\nroom++;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nroom *= port->bulk_out_size;\r\ndbg("%s - returns %d", __func__, room);\r\nreturn (room);\r\n}\r\nstatic int whiteheat_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nunsigned int modem_signals = 0;\r\ndbg("%s - port %d", __func__, port->number);\r\nfirm_get_dtr_rts(port);\r\nif (info->mcr & UART_MCR_DTR)\r\nmodem_signals |= TIOCM_DTR;\r\nif (info->mcr & UART_MCR_RTS)\r\nmodem_signals |= TIOCM_RTS;\r\nreturn modem_signals;\r\n}\r\nstatic int whiteheat_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\ndbg("%s - port %d", __func__, port->number);\r\nif (set & TIOCM_RTS)\r\ninfo->mcr |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->mcr |= UART_MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->mcr &= ~UART_MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->mcr &= ~UART_MCR_DTR;\r\nfirm_set_dtr(port, info->mcr & UART_MCR_DTR);\r\nfirm_set_rts(port, info->mcr & UART_MCR_RTS);\r\nreturn 0;\r\n}\r\nstatic int whiteheat_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct serial_struct serstruct;\r\nvoid __user *user_arg = (void __user *)arg;\r\ndbg("%s - port %d, cmd 0x%.4x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmemset(&serstruct, 0, sizeof(serstruct));\r\nserstruct.type = PORT_16654;\r\nserstruct.line = port->serial->minor;\r\nserstruct.port = port->number;\r\nserstruct.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\nserstruct.xmit_fifo_size = port->bulk_out_size;\r\nserstruct.custom_divisor = 0;\r\nserstruct.baud_base = 460800;\r\nserstruct.close_delay = CLOSING_DELAY;\r\nserstruct.closing_wait = CLOSING_DELAY;\r\nif (copy_to_user(user_arg, &serstruct, sizeof(serstruct)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void whiteheat_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nfirm_setup_port(tty);\r\n}\r\nstatic void whiteheat_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nfirm_set_break(port, break_state);\r\n}\r\nstatic int whiteheat_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nstruct list_head *tmp;\r\nstruct whiteheat_urb_wrap *wrap;\r\nint chars = 0;\r\nunsigned long flags;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_for_each(tmp, &info->tx_urbs_submitted) {\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nchars += wrap->urb->transfer_buffer_length;\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\ndbg("%s - returns %d", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic void whiteheat_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irq(&info->lock);\r\ninfo->flags |= THROTTLED;\r\nspin_unlock_irq(&info->lock);\r\n}\r\nstatic void whiteheat_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nint actually_throttled;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irq(&info->lock);\r\nactually_throttled = info->flags & ACTUALLY_THROTTLED;\r\ninfo->flags &= ~(THROTTLED | ACTUALLY_THROTTLED);\r\nspin_unlock_irq(&info->lock);\r\nif (actually_throttled)\r\nrx_data_softint(&info->rx_work);\r\n}\r\nstatic void command_port_write_callback(struct urb *urb)\r\n{\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nif (status) {\r\ndbg("nonzero urb status: %d", status);\r\nreturn;\r\n}\r\n}\r\nstatic void command_port_read_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *command_port = urb->context;\r\nstruct whiteheat_command_private *command_info;\r\nint status = urb->status;\r\nunsigned char *data = urb->transfer_buffer;\r\nint result;\r\ndbg("%s", __func__);\r\ncommand_info = usb_get_serial_port_data(command_port);\r\nif (!command_info) {\r\ndbg("%s - command_info is NULL, exiting.", __func__);\r\nreturn;\r\n}\r\nif (status) {\r\ndbg("%s - nonzero urb status: %d", __func__, status);\r\nif (status != -ENOENT)\r\ncommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\r\nwake_up(&command_info->wait_command);\r\nreturn;\r\n}\r\nusb_serial_debug_data(debug, &command_port->dev,\r\n__func__, urb->actual_length, data);\r\nif (data[0] == WHITEHEAT_CMD_COMPLETE) {\r\ncommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\r\nwake_up(&command_info->wait_command);\r\n} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\r\ncommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\r\nwake_up(&command_info->wait_command);\r\n} else if (data[0] == WHITEHEAT_EVENT) {\r\ndbg("%s - event received", __func__);\r\n} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\r\nmemcpy(command_info->result_buffer, &data[1],\r\nurb->actual_length - 1);\r\ncommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\r\nwake_up(&command_info->wait_command);\r\n} else\r\ndbg("%s - bad reply from firmware", __func__);\r\ncommand_port->read_urb->dev = command_port->serial->dev;\r\nresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\r\nif (result)\r\ndbg("%s - failed resubmitting read urb, error %d",\r\n__func__, result);\r\n}\r\nstatic void whiteheat_read_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct whiteheat_urb_wrap *wrap;\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nint status = urb->status;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock(&info->lock);\r\nwrap = urb_to_wrap(urb, &info->rx_urbs_submitted);\r\nif (!wrap) {\r\nspin_unlock(&info->lock);\r\ndev_err(&port->dev, "%s - Not my urb!\n", __func__);\r\nreturn;\r\n}\r\nlist_del(&wrap->list);\r\nspin_unlock(&info->lock);\r\nif (status) {\r\ndbg("%s - nonzero read bulk status received: %d",\r\n__func__, status);\r\nspin_lock(&info->lock);\r\nlist_add(&wrap->list, &info->rx_urbs_free);\r\nspin_unlock(&info->lock);\r\nreturn;\r\n}\r\nusb_serial_debug_data(debug, &port->dev,\r\n__func__, urb->actual_length, data);\r\nspin_lock(&info->lock);\r\nlist_add_tail(&wrap->list, &info->rx_urb_q);\r\nif (info->flags & THROTTLED) {\r\ninfo->flags |= ACTUALLY_THROTTLED;\r\nspin_unlock(&info->lock);\r\nreturn;\r\n}\r\nspin_unlock(&info->lock);\r\nschedule_work(&info->rx_work);\r\n}\r\nstatic void whiteheat_write_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nstruct whiteheat_urb_wrap *wrap;\r\nint status = urb->status;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock(&info->lock);\r\nwrap = urb_to_wrap(urb, &info->tx_urbs_submitted);\r\nif (!wrap) {\r\nspin_unlock(&info->lock);\r\ndev_err(&port->dev, "%s - Not my urb!\n", __func__);\r\nreturn;\r\n}\r\nlist_move(&wrap->list, &info->tx_urbs_free);\r\nspin_unlock(&info->lock);\r\nif (status) {\r\ndbg("%s - nonzero write bulk status received: %d",\r\n__func__, status);\r\nreturn;\r\n}\r\nusb_serial_port_softint(port);\r\n}\r\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\r\n__u8 *data, __u8 datasize)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_command_private *command_info;\r\nstruct whiteheat_private *info;\r\n__u8 *transfer_buffer;\r\nint retval = 0;\r\nint t;\r\ndbg("%s - command %d", __func__, command);\r\ncommand_port = port->serial->port[COMMAND_PORT];\r\ncommand_info = usb_get_serial_port_data(command_port);\r\nmutex_lock(&command_info->mutex);\r\ncommand_info->command_finished = false;\r\ntransfer_buffer = (__u8 *)command_port->write_urb->transfer_buffer;\r\ntransfer_buffer[0] = command;\r\nmemcpy(&transfer_buffer[1], data, datasize);\r\ncommand_port->write_urb->transfer_buffer_length = datasize + 1;\r\ncommand_port->write_urb->dev = port->serial->dev;\r\nretval = usb_submit_urb(command_port->write_urb, GFP_NOIO);\r\nif (retval) {\r\ndbg("%s - submit urb failed", __func__);\r\ngoto exit;\r\n}\r\nt = wait_event_timeout(command_info->wait_command,\r\n(bool)command_info->command_finished, COMMAND_TIMEOUT);\r\nif (!t)\r\nusb_kill_urb(command_port->write_urb);\r\nif (command_info->command_finished == false) {\r\ndbg("%s - command timed out.", __func__);\r\nretval = -ETIMEDOUT;\r\ngoto exit;\r\n}\r\nif (command_info->command_finished == WHITEHEAT_CMD_FAILURE) {\r\ndbg("%s - command failed.", __func__);\r\nretval = -EIO;\r\ngoto exit;\r\n}\r\nif (command_info->command_finished == WHITEHEAT_CMD_COMPLETE) {\r\ndbg("%s - command completed.", __func__);\r\nswitch (command) {\r\ncase WHITEHEAT_GET_DTR_RTS:\r\ninfo = usb_get_serial_port_data(port);\r\nmemcpy(&info->mcr, command_info->result_buffer,\r\nsizeof(struct whiteheat_dr_info));\r\nbreak;\r\n}\r\n}\r\nexit:\r\nmutex_unlock(&command_info->mutex);\r\nreturn retval;\r\n}\r\nstatic int firm_open(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_simple open_command;\r\nopen_command.port = port->number - port->serial->minor + 1;\r\nreturn firm_send_command(port, WHITEHEAT_OPEN,\r\n(__u8 *)&open_command, sizeof(open_command));\r\n}\r\nstatic int firm_close(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_simple close_command;\r\nclose_command.port = port->number - port->serial->minor + 1;\r\nreturn firm_send_command(port, WHITEHEAT_CLOSE,\r\n(__u8 *)&close_command, sizeof(close_command));\r\n}\r\nstatic void firm_setup_port(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_port_settings port_settings;\r\nunsigned int cflag = tty->termios->c_cflag;\r\nport_settings.port = port->number + 1;\r\nswitch (cflag & CSIZE) {\r\ncase CS5: port_settings.bits = 5; break;\r\ncase CS6: port_settings.bits = 6; break;\r\ncase CS7: port_settings.bits = 7; break;\r\ndefault:\r\ncase CS8: port_settings.bits = 8; break;\r\n}\r\ndbg("%s - data bits = %d", __func__, port_settings.bits);\r\nif (cflag & PARENB)\r\nif (cflag & CMSPAR)\r\nif (cflag & PARODD)\r\nport_settings.parity = WHITEHEAT_PAR_MARK;\r\nelse\r\nport_settings.parity = WHITEHEAT_PAR_SPACE;\r\nelse\r\nif (cflag & PARODD)\r\nport_settings.parity = WHITEHEAT_PAR_ODD;\r\nelse\r\nport_settings.parity = WHITEHEAT_PAR_EVEN;\r\nelse\r\nport_settings.parity = WHITEHEAT_PAR_NONE;\r\ndbg("%s - parity = %c", __func__, port_settings.parity);\r\nif (cflag & CSTOPB)\r\nport_settings.stop = 2;\r\nelse\r\nport_settings.stop = 1;\r\ndbg("%s - stop bits = %d", __func__, port_settings.stop);\r\nif (cflag & CRTSCTS)\r\nport_settings.hflow = (WHITEHEAT_HFLOW_CTS |\r\nWHITEHEAT_HFLOW_RTS);\r\nelse\r\nport_settings.hflow = WHITEHEAT_HFLOW_NONE;\r\ndbg("%s - hardware flow control = %s %s %s %s", __func__,\r\n(port_settings.hflow & WHITEHEAT_HFLOW_CTS) ? "CTS" : "",\r\n(port_settings.hflow & WHITEHEAT_HFLOW_RTS) ? "RTS" : "",\r\n(port_settings.hflow & WHITEHEAT_HFLOW_DSR) ? "DSR" : "",\r\n(port_settings.hflow & WHITEHEAT_HFLOW_DTR) ? "DTR" : "");\r\nif (I_IXOFF(tty))\r\nport_settings.sflow = WHITEHEAT_SFLOW_RXTX;\r\nelse\r\nport_settings.sflow = WHITEHEAT_SFLOW_NONE;\r\ndbg("%s - software flow control = %c", __func__, port_settings.sflow);\r\nport_settings.xon = START_CHAR(tty);\r\nport_settings.xoff = STOP_CHAR(tty);\r\ndbg("%s - XON = %2x, XOFF = %2x",\r\n__func__, port_settings.xon, port_settings.xoff);\r\nport_settings.baud = tty_get_baud_rate(tty);\r\ndbg("%s - baud rate = %d", __func__, port_settings.baud);\r\ntty_encode_baud_rate(tty, port_settings.baud, port_settings.baud);\r\nport_settings.lloop = 0;\r\nfirm_send_command(port, WHITEHEAT_SETUP_PORT,\r\n(__u8 *)&port_settings, sizeof(port_settings));\r\n}\r\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\r\n{\r\nstruct whiteheat_set_rdb rts_command;\r\nrts_command.port = port->number - port->serial->minor + 1;\r\nrts_command.state = onoff;\r\nreturn firm_send_command(port, WHITEHEAT_SET_RTS,\r\n(__u8 *)&rts_command, sizeof(rts_command));\r\n}\r\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff)\r\n{\r\nstruct whiteheat_set_rdb dtr_command;\r\ndtr_command.port = port->number - port->serial->minor + 1;\r\ndtr_command.state = onoff;\r\nreturn firm_send_command(port, WHITEHEAT_SET_DTR,\r\n(__u8 *)&dtr_command, sizeof(dtr_command));\r\n}\r\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff)\r\n{\r\nstruct whiteheat_set_rdb break_command;\r\nbreak_command.port = port->number - port->serial->minor + 1;\r\nbreak_command.state = onoff;\r\nreturn firm_send_command(port, WHITEHEAT_SET_BREAK,\r\n(__u8 *)&break_command, sizeof(break_command));\r\n}\r\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx)\r\n{\r\nstruct whiteheat_purge purge_command;\r\npurge_command.port = port->number - port->serial->minor + 1;\r\npurge_command.what = rxtx;\r\nreturn firm_send_command(port, WHITEHEAT_PURGE,\r\n(__u8 *)&purge_command, sizeof(purge_command));\r\n}\r\nstatic int firm_get_dtr_rts(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_simple get_dr_command;\r\nget_dr_command.port = port->number - port->serial->minor + 1;\r\nreturn firm_send_command(port, WHITEHEAT_GET_DTR_RTS,\r\n(__u8 *)&get_dr_command, sizeof(get_dr_command));\r\n}\r\nstatic int firm_report_tx_done(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_simple close_command;\r\nclose_command.port = port->number - port->serial->minor + 1;\r\nreturn firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,\r\n(__u8 *)&close_command, sizeof(close_command));\r\n}\r\nstatic int start_command_port(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_command_private *command_info;\r\nint retval = 0;\r\ncommand_port = serial->port[COMMAND_PORT];\r\ncommand_info = usb_get_serial_port_data(command_port);\r\nmutex_lock(&command_info->mutex);\r\nif (!command_info->port_running) {\r\nusb_clear_halt(serial->dev, command_port->read_urb->pipe);\r\ncommand_port->read_urb->dev = serial->dev;\r\nretval = usb_submit_urb(command_port->read_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&serial->dev->dev,\r\n"%s - failed submitting read urb, error %d\n",\r\n__func__, retval);\r\ngoto exit;\r\n}\r\n}\r\ncommand_info->port_running++;\r\nexit:\r\nmutex_unlock(&command_info->mutex);\r\nreturn retval;\r\n}\r\nstatic void stop_command_port(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_command_private *command_info;\r\ncommand_port = serial->port[COMMAND_PORT];\r\ncommand_info = usb_get_serial_port_data(command_port);\r\nmutex_lock(&command_info->mutex);\r\ncommand_info->port_running--;\r\nif (!command_info->port_running)\r\nusb_kill_urb(command_port->read_urb);\r\nmutex_unlock(&command_info->mutex);\r\n}\r\nstatic int start_port_read(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nstruct whiteheat_urb_wrap *wrap;\r\nstruct urb *urb;\r\nint retval = 0;\r\nunsigned long flags;\r\nstruct list_head *tmp;\r\nstruct list_head *tmp2;\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_for_each_safe(tmp, tmp2, &info->rx_urbs_free) {\r\nlist_del(tmp);\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nurb->dev = port->serial->dev;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (retval) {\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_add(tmp, &info->rx_urbs_free);\r\nlist_for_each_safe(tmp, tmp2, &info->rx_urbs_submitted) {\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nlist_del(tmp);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nusb_kill_urb(urb);\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_add(tmp, &info->rx_urbs_free);\r\n}\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_add(tmp, &info->rx_urbs_submitted);\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nreturn retval;\r\n}\r\nstatic struct whiteheat_urb_wrap *urb_to_wrap(struct urb *urb,\r\nstruct list_head *head)\r\n{\r\nstruct whiteheat_urb_wrap *wrap;\r\nstruct list_head *tmp;\r\nlist_for_each(tmp, head) {\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nif (wrap->urb == urb)\r\nreturn wrap;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct list_head *list_first(struct list_head *head)\r\n{\r\nreturn head->next;\r\n}\r\nstatic void rx_data_softint(struct work_struct *work)\r\n{\r\nstruct whiteheat_private *info =\r\ncontainer_of(work, struct whiteheat_private, rx_work);\r\nstruct usb_serial_port *port = info->port;\r\nstruct tty_struct *tty = tty_port_tty_get(&port->port);\r\nstruct whiteheat_urb_wrap *wrap;\r\nstruct urb *urb;\r\nunsigned long flags;\r\nstruct list_head *tmp;\r\nstruct list_head *tmp2;\r\nint result;\r\nint sent = 0;\r\nspin_lock_irqsave(&info->lock, flags);\r\nif (info->flags & THROTTLED) {\r\nspin_unlock_irqrestore(&info->lock, flags);\r\ngoto out;\r\n}\r\nlist_for_each_safe(tmp, tmp2, &info->rx_urb_q) {\r\nlist_del(tmp);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nwrap = list_entry(tmp, struct whiteheat_urb_wrap, list);\r\nurb = wrap->urb;\r\nif (tty && urb->actual_length)\r\nsent += tty_insert_flip_string(tty,\r\nurb->transfer_buffer, urb->actual_length);\r\nurb->dev = port->serial->dev;\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - failed resubmitting read urb, error %d\n",\r\n__func__, result);\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_add(tmp, &info->rx_urbs_free);\r\ncontinue;\r\n}\r\nspin_lock_irqsave(&info->lock, flags);\r\nlist_add(tmp, &info->rx_urbs_submitted);\r\n}\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nif (sent)\r\ntty_flip_buffer_push(tty);\r\nout:\r\ntty_kref_put(tty);\r\n}\r\nstatic int __init whiteheat_init(void)\r\n{\r\nint retval;\r\nretval = usb_serial_register(&whiteheat_fake_device);\r\nif (retval)\r\ngoto failed_fake_register;\r\nretval = usb_serial_register(&whiteheat_device);\r\nif (retval)\r\ngoto failed_device_register;\r\nretval = usb_register(&whiteheat_driver);\r\nif (retval)\r\ngoto failed_usb_register;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nreturn 0;\r\nfailed_usb_register:\r\nusb_serial_deregister(&whiteheat_device);\r\nfailed_device_register:\r\nusb_serial_deregister(&whiteheat_fake_device);\r\nfailed_fake_register:\r\nreturn retval;\r\n}\r\nstatic void __exit whiteheat_exit(void)\r\n{\r\nusb_deregister(&whiteheat_driver);\r\nusb_serial_deregister(&whiteheat_fake_device);\r\nusb_serial_deregister(&whiteheat_device);\r\n}
