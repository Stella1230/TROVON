static int __init do_eepro_probe(struct net_device *dev)\r\n{\r\nint i;\r\nint base_addr = dev->base_addr;\r\nint irq = dev->irq;\r\n#ifdef PnPWakeup\r\n#define WakeupPort 0x279\r\n#define WakeupSeq {0x6A, 0xB5, 0xDA, 0xED, 0xF6, 0xFB, 0x7D, 0xBE,\\r\n0xDF, 0x6F, 0x37, 0x1B, 0x0D, 0x86, 0xC3, 0x61,\\r\n0xB0, 0x58, 0x2C, 0x16, 0x8B, 0x45, 0xA2, 0xD1,\\r\n0xE8, 0x74, 0x3A, 0x9D, 0xCE, 0xE7, 0x73, 0x43}\r\n{\r\nunsigned short int WS[32]=WakeupSeq;\r\nif (request_region(WakeupPort, 2, "eepro wakeup")) {\r\nif (net_debug>5)\r\nprintk(KERN_DEBUG "Waking UP\n");\r\noutb_p(0,WakeupPort);\r\noutb_p(0,WakeupPort);\r\nfor (i=0; i<32; i++) {\r\noutb_p(WS[i],WakeupPort);\r\nif (net_debug>5) printk(KERN_DEBUG ": %#x ",WS[i]);\r\n}\r\nrelease_region(WakeupPort, 2);\r\n} else\r\nprintk(KERN_WARNING "PnP wakeup region busy!\n");\r\n}\r\n#endif\r\nif (base_addr > 0x1ff)\r\nreturn eepro_probe1(dev, 0);\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\nfor (i = 0; eepro_portlist[i]; i++) {\r\ndev->base_addr = eepro_portlist[i];\r\ndev->irq = irq;\r\nif (eepro_probe1(dev, 1) == 0)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init eepro_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct eepro_local));\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_eepro_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void __init printEEPROMInfo(struct net_device *dev)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned short Word;\r\nint i,j;\r\nj = ee_Checksum;\r\nfor (i = 0; i < 8; i++)\r\nj += lp->word[i];\r\nfor ( ; i < ee_SIZE; i++)\r\nj += read_eeprom(ioaddr, i, dev);\r\nprintk(KERN_DEBUG "Checksum: %#x\n",j&0xffff);\r\nWord = lp->word[0];\r\nprintk(KERN_DEBUG "Word0:\n");\r\nprintk(KERN_DEBUG " Plug 'n Pray: %d\n",GetBit(Word,ee_PnP));\r\nprintk(KERN_DEBUG " Buswidth: %d\n",(GetBit(Word,ee_BusWidth)+1)*8 );\r\nprintk(KERN_DEBUG " AutoNegotiation: %d\n",GetBit(Word,ee_AutoNeg));\r\nprintk(KERN_DEBUG " IO Address: %#x\n", (Word>>ee_IO0)<<4);\r\nif (net_debug>4) {\r\nWord = lp->word[1];\r\nprintk(KERN_DEBUG "Word1:\n");\r\nprintk(KERN_DEBUG " INT: %d\n", Word & ee_IntMask);\r\nprintk(KERN_DEBUG " LI: %d\n", GetBit(Word,ee_LI));\r\nprintk(KERN_DEBUG " PC: %d\n", GetBit(Word,ee_PC));\r\nprintk(KERN_DEBUG " TPE/AUI: %d\n", GetBit(Word,ee_TPE_AUI));\r\nprintk(KERN_DEBUG " Jabber: %d\n", GetBit(Word,ee_Jabber));\r\nprintk(KERN_DEBUG " AutoPort: %d\n", !GetBit(Word,ee_AutoPort));\r\nprintk(KERN_DEBUG " Duplex: %d\n", GetBit(Word,ee_Duplex));\r\n}\r\nWord = lp->word[5];\r\nprintk(KERN_DEBUG "Word5:\n");\r\nprintk(KERN_DEBUG " BNC: %d\n",GetBit(Word,ee_BNC_TPE));\r\nprintk(KERN_DEBUG " NumConnectors: %d\n",GetBit(Word,ee_NumConn));\r\nprintk(KERN_DEBUG " Has ");\r\nif (GetBit(Word,ee_PortTPE)) printk(KERN_DEBUG "TPE ");\r\nif (GetBit(Word,ee_PortBNC)) printk(KERN_DEBUG "BNC ");\r\nif (GetBit(Word,ee_PortAUI)) printk(KERN_DEBUG "AUI ");\r\nprintk(KERN_DEBUG "port(s)\n");\r\nWord = lp->word[6];\r\nprintk(KERN_DEBUG "Word6:\n");\r\nprintk(KERN_DEBUG " Stepping: %d\n",Word & ee_StepMask);\r\nprintk(KERN_DEBUG " BoardID: %d\n",Word>>ee_BoardID);\r\nWord = lp->word[7];\r\nprintk(KERN_DEBUG "Word7:\n");\r\nprintk(KERN_DEBUG " INT to IRQ:\n");\r\nfor (i=0, j=0; i<15; i++)\r\nif (GetBit(Word,i)) printk(KERN_DEBUG " INT%d -> IRQ %d;",j++,i);\r\nprintk(KERN_DEBUG "\n");\r\n}\r\nstatic void eepro_recalc (struct net_device *dev)\r\n{\r\nstruct eepro_local * lp;\r\nlp = netdev_priv(dev);\r\nlp->xmt_ram = RAM_SIZE - lp->rcv_ram;\r\nif (lp->eepro == LAN595FX_10ISA) {\r\nlp->xmt_lower_limit = XMT_START_10;\r\nlp->xmt_upper_limit = (lp->xmt_ram - 2);\r\nlp->rcv_lower_limit = lp->xmt_ram;\r\nlp->rcv_upper_limit = (RAM_SIZE - 2);\r\n}\r\nelse {\r\nlp->rcv_lower_limit = RCV_START_PRO;\r\nlp->rcv_upper_limit = (lp->rcv_ram - 2);\r\nlp->xmt_lower_limit = lp->rcv_ram;\r\nlp->xmt_upper_limit = (RAM_SIZE - 2);\r\n}\r\n}\r\nstatic void __init eepro_print_info (struct net_device *dev)\r\n{\r\nstruct eepro_local * lp = netdev_priv(dev);\r\nint i;\r\nconst char * ifmap[] = {"AUI", "10Base2", "10BaseT"};\r\ni = inb(dev->base_addr + ID_REG);\r\nprintk(KERN_DEBUG " id: %#x ",i);\r\nprintk(" io: %#x ", (unsigned)dev->base_addr);\r\nswitch (lp->eepro) {\r\ncase LAN595FX_10ISA:\r\nprintk("%s: Intel EtherExpress 10 ISA\n at %#x,",\r\ndev->name, (unsigned)dev->base_addr);\r\nbreak;\r\ncase LAN595FX:\r\nprintk("%s: Intel EtherExpress Pro/10+ ISA\n at %#x,",\r\ndev->name, (unsigned)dev->base_addr);\r\nbreak;\r\ncase LAN595TX:\r\nprintk("%s: Intel EtherExpress Pro/10 ISA at %#x,",\r\ndev->name, (unsigned)dev->base_addr);\r\nbreak;\r\ncase LAN595:\r\nprintk("%s: Intel 82595-based lan card at %#x,",\r\ndev->name, (unsigned)dev->base_addr);\r\nbreak;\r\n}\r\nprintk(" %pM", dev->dev_addr);\r\nif (net_debug > 3)\r\nprintk(KERN_DEBUG ", %dK RCV buffer",\r\n(int)(lp->rcv_ram)/1024);\r\nif (dev->irq > 2)\r\nprintk(", IRQ %d, %s.\n", dev->irq, ifmap[dev->if_port]);\r\nelse\r\nprintk(", %s.\n", ifmap[dev->if_port]);\r\nif (net_debug > 3) {\r\ni = lp->word[5];\r\nif (i & 0x2000)\r\nprintk(KERN_DEBUG "%s: Concurrent Processing is "\r\n"enabled but not used!\n", dev->name);\r\n}\r\nif (net_debug>3)\r\nprintEEPROMInfo(dev);\r\n}\r\nstatic int __init eepro_probe1(struct net_device *dev, int autoprobe)\r\n{\r\nunsigned short station_addr[3], id, counter;\r\nint i;\r\nstruct eepro_local *lp;\r\nint ioaddr = dev->base_addr;\r\nint err;\r\nif (!request_region(ioaddr, EEPRO_IO_EXTENT, DRV_NAME)) {\r\nif (!autoprobe)\r\nprintk(KERN_WARNING "EEPRO: io-port 0x%04x in use\n",\r\nioaddr);\r\nreturn -EBUSY;\r\n}\r\nid = inb(ioaddr + ID_REG);\r\nif ((id & ID_REG_MASK) != ID_REG_SIG)\r\ngoto exit;\r\ncounter = id & R_ROBIN_BITS;\r\nif ((inb(ioaddr + ID_REG) & R_ROBIN_BITS) != (counter + 0x40))\r\ngoto exit;\r\nlp = netdev_priv(dev);\r\nmemset(lp, 0, sizeof(struct eepro_local));\r\nlp->xmt_bar = XMT_BAR_PRO;\r\nlp->xmt_lower_limit_reg = XMT_LOWER_LIMIT_REG_PRO;\r\nlp->xmt_upper_limit_reg = XMT_UPPER_LIMIT_REG_PRO;\r\nlp->eeprom_reg = EEPROM_REG_PRO;\r\nspin_lock_init(&lp->lock);\r\nstation_addr[0] = read_eeprom(ioaddr, 2, dev);\r\nif (station_addr[0] == 0x0000 || station_addr[0] == 0xffff) {\r\nlp->eepro = LAN595FX_10ISA;\r\nlp->eeprom_reg = EEPROM_REG_10;\r\nlp->xmt_lower_limit_reg = XMT_LOWER_LIMIT_REG_10;\r\nlp->xmt_upper_limit_reg = XMT_UPPER_LIMIT_REG_10;\r\nlp->xmt_bar = XMT_BAR_10;\r\nstation_addr[0] = read_eeprom(ioaddr, 2, dev);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nlp->word[i] = read_eeprom(ioaddr, i, dev);\r\n}\r\nstation_addr[1] = lp->word[3];\r\nstation_addr[2] = lp->word[4];\r\nif (!lp->eepro) {\r\nif (lp->word[7] == ee_FX_INT2IRQ)\r\nlp->eepro = 2;\r\nelse if (station_addr[2] == SA_ADDR1)\r\nlp->eepro = 1;\r\n}\r\nfor (i=0; i < 6; i++)\r\ndev->dev_addr[i] = ((unsigned char *) station_addr)[5-i];\r\nif (dev->mem_end < 3072 || dev->mem_end > 29696)\r\nlp->rcv_ram = RCV_DEFAULT_RAM;\r\neepro_recalc(dev);\r\nif (GetBit(lp->word[5], ee_BNC_TPE))\r\ndev->if_port = BNC;\r\nelse\r\ndev->if_port = TPE;\r\nif (dev->irq < 2 && lp->eepro != 0) {\r\nint count = lp->word[1] & 7;\r\nunsigned irqMask = lp->word[7];\r\nwhile (count--)\r\nirqMask &= irqMask - 1;\r\ncount = ffs(irqMask);\r\nif (count)\r\ndev->irq = count - 1;\r\nif (dev->irq < 2) {\r\nprintk(KERN_ERR " Duh! illegal interrupt vector stored in EEPROM.\n");\r\ngoto exit;\r\n} else if (dev->irq == 2) {\r\ndev->irq = 9;\r\n}\r\n}\r\ndev->netdev_ops = &eepro_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ethtool_ops = &eepro_ethtool_ops;\r\neepro_print_info(dev);\r\neepro_reset(ioaddr);\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto err;\r\nreturn 0;\r\nexit:\r\nerr = -ENODEV;\r\nerr:\r\nrelease_region(dev->base_addr, EEPRO_IO_EXTENT);\r\nreturn err;\r\n}\r\nstatic int eepro_grab_irq(struct net_device *dev)\r\n{\r\nstatic const int irqlist[] = { 3, 4, 5, 7, 9, 10, 11, 12, 0 };\r\nconst int *irqp = irqlist;\r\nint temp_reg, ioaddr = dev->base_addr;\r\neepro_sw2bank1(ioaddr);\r\neepro_en_intline(ioaddr);\r\neepro_sw2bank0(ioaddr);\r\neepro_clear_int(ioaddr);\r\neepro_en_intexec(ioaddr);\r\ndo {\r\neepro_sw2bank1(ioaddr);\r\ntemp_reg = inb(ioaddr + INT_NO_REG);\r\noutb((temp_reg & 0xf8) | irqrmap[*irqp], ioaddr + INT_NO_REG);\r\neepro_sw2bank0(ioaddr);\r\nif (request_irq (*irqp, NULL, IRQF_SHARED, "bogus", dev) != EBUSY) {\r\nunsigned long irq_mask;\r\nirq_mask = probe_irq_on();\r\neepro_diag(ioaddr);\r\nmdelay(20);\r\nif (*irqp == probe_irq_off(irq_mask))\r\nbreak;\r\neepro_clear_int(ioaddr);\r\n}\r\n} while (*++irqp);\r\neepro_sw2bank1(ioaddr);\r\neepro_dis_intline(ioaddr);\r\neepro_sw2bank0(ioaddr);\r\neepro_dis_int(ioaddr);\r\neepro_clear_int(ioaddr);\r\nreturn dev->irq;\r\n}\r\nstatic int eepro_open(struct net_device *dev)\r\n{\r\nunsigned short temp_reg, old8, old9;\r\nint irqMask;\r\nint i, ioaddr = dev->base_addr;\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nif (net_debug > 3)\r\nprintk(KERN_DEBUG "%s: entering eepro_open routine.\n", dev->name);\r\nirqMask = lp->word[7];\r\nif (lp->eepro == LAN595FX_10ISA) {\r\nif (net_debug > 3) printk(KERN_DEBUG "p->eepro = 3;\n");\r\n}\r\nelse if (irqMask == ee_FX_INT2IRQ)\r\n{\r\nlp->eepro = 2;\r\nif (net_debug > 3) printk(KERN_DEBUG "p->eepro = 2;\n");\r\n}\r\nelse if ((dev->dev_addr[0] == SA_ADDR0 &&\r\ndev->dev_addr[1] == SA_ADDR1 &&\r\ndev->dev_addr[2] == SA_ADDR2))\r\n{\r\nlp->eepro = 1;\r\nif (net_debug > 3) printk(KERN_DEBUG "p->eepro = 1;\n");\r\n}\r\nelse lp->eepro = 0;\r\nif (dev->irq < 2 && eepro_grab_irq(dev) == 0) {\r\nprintk(KERN_ERR "%s: unable to get IRQ %d.\n", dev->name, dev->irq);\r\nreturn -EAGAIN;\r\n}\r\nif (request_irq(dev->irq , eepro_interrupt, 0, dev->name, dev)) {\r\nprintk(KERN_ERR "%s: unable to get IRQ %d.\n", dev->name, dev->irq);\r\nreturn -EAGAIN;\r\n}\r\neepro_sw2bank2(ioaddr);\r\ntemp_reg = inb(ioaddr + lp->eeprom_reg);\r\nlp->stepping = temp_reg >> 5;\r\nif (net_debug > 3)\r\nprintk(KERN_DEBUG "The stepping of the 82595 is %d\n", lp->stepping);\r\nif (temp_reg & 0x10)\r\noutb(temp_reg & 0xef, ioaddr + lp->eeprom_reg);\r\nfor (i=0; i < 6; i++)\r\noutb(dev->dev_addr[i] , ioaddr + I_ADD_REG0 + i);\r\ntemp_reg = inb(ioaddr + REG1);\r\noutb(temp_reg | XMT_Chain_Int | XMT_Chain_ErrStop\r\n| RCV_Discard_BadFrame, ioaddr + REG1);\r\ntemp_reg = inb(ioaddr + REG2);\r\noutb(temp_reg | 0x14, ioaddr + REG2);\r\ntemp_reg = inb(ioaddr + REG3);\r\noutb(temp_reg & 0x3f, ioaddr + REG3);\r\neepro_sw2bank1(ioaddr);\r\ntemp_reg = inb(ioaddr + INT_NO_REG);\r\nif (lp->eepro == LAN595FX || lp->eepro == LAN595FX_10ISA)\r\noutb((temp_reg & 0xf8) | irqrmap2[dev->irq], ioaddr + INT_NO_REG);\r\nelse outb((temp_reg & 0xf8) | irqrmap[dev->irq], ioaddr + INT_NO_REG);\r\ntemp_reg = inb(ioaddr + INT_NO_REG);\r\nif (lp->eepro == LAN595FX || lp->eepro == LAN595FX_10ISA)\r\noutb((temp_reg & 0xf0) | irqrmap2[dev->irq] | 0x08,ioaddr+INT_NO_REG);\r\nelse outb((temp_reg & 0xf8) | irqrmap[dev->irq], ioaddr + INT_NO_REG);\r\nif (net_debug > 3)\r\nprintk(KERN_DEBUG "eepro_open: content of INT Reg is %x\n", temp_reg);\r\noutb(lp->rcv_lower_limit >> 8, ioaddr + RCV_LOWER_LIMIT_REG);\r\noutb(lp->rcv_upper_limit >> 8, ioaddr + RCV_UPPER_LIMIT_REG);\r\noutb(lp->xmt_lower_limit >> 8, ioaddr + lp->xmt_lower_limit_reg);\r\noutb(lp->xmt_upper_limit >> 8, ioaddr + lp->xmt_upper_limit_reg);\r\neepro_en_intline(ioaddr);\r\neepro_sw2bank0(ioaddr);\r\neepro_en_int(ioaddr);\r\neepro_clear_int(ioaddr);\r\noutw(lp->rcv_lower_limit, ioaddr + RCV_BAR);\r\nlp->rx_start = lp->rcv_lower_limit;\r\noutw(lp->rcv_upper_limit | 0xfe, ioaddr + RCV_STOP);\r\noutw(lp->xmt_lower_limit, ioaddr + lp->xmt_bar);\r\nlp->tx_start = lp->tx_end = lp->xmt_lower_limit;\r\nlp->tx_last = 0;\r\nold8 = inb(ioaddr + 8);\r\noutb(~old8, ioaddr + 8);\r\nif ((temp_reg = inb(ioaddr + 8)) == old8) {\r\nif (net_debug > 3)\r\nprintk(KERN_DEBUG "i82595 detected!\n");\r\nlp->version = LAN595;\r\n}\r\nelse {\r\nlp->version = LAN595TX;\r\noutb(old8, ioaddr + 8);\r\nold9 = inb(ioaddr + 9);\r\nif (irqMask==ee_FX_INT2IRQ) {\r\nif (net_debug > 3) {\r\nprintk(KERN_DEBUG "IrqMask: %#x\n",irqMask);\r\nprintk(KERN_DEBUG "i82595FX detected!\n");\r\n}\r\nlp->version = LAN595FX;\r\noutb(old9, ioaddr + 9);\r\nif (dev->if_port != TPE) {\r\neepro_sw2bank2(ioaddr);\r\ntemp_reg = inb(ioaddr + REG13);\r\noutb(temp_reg & ~(FDX | A_N_ENABLE), REG13);\r\neepro_sw2bank0(ioaddr);\r\n}\r\n}\r\nelse if (net_debug > 3) {\r\nprintk(KERN_DEBUG "temp_reg: %#x ~old9: %#x\n",temp_reg,((~old9)&0xff));\r\nprintk(KERN_DEBUG "i82595TX detected!\n");\r\n}\r\n}\r\neepro_sel_reset(ioaddr);\r\nnetif_start_queue(dev);\r\nif (net_debug > 3)\r\nprintk(KERN_DEBUG "%s: exiting eepro_open routine.\n", dev->name);\r\neepro_en_rx(ioaddr);\r\nreturn 0;\r\n}\r\nstatic void eepro_tx_timeout (struct net_device *dev)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nprintk (KERN_ERR "%s: transmit timed out, %s?\n", dev->name,\r\n"network cable problem");\r\nprintk (KERN_DEBUG "%s: transmit timed out, %s?\n", dev->name,\r\n"network cable problem");\r\neepro_complete_selreset(ioaddr);\r\n}\r\nstatic netdev_tx_t eepro_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nint ioaddr = dev->base_addr;\r\nshort length = skb->len;\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG "%s: entering eepro_send_packet routine.\n", dev->name);\r\nif (length < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\nnetif_stop_queue (dev);\r\neepro_dis_int(ioaddr);\r\nspin_lock_irqsave(&lp->lock, flags);\r\n{\r\nunsigned char *buf = skb->data;\r\nif (hardware_send_packet(dev, buf, length))\r\ndev->stats.tx_dropped++;\r\nelse {\r\ndev->stats.tx_bytes+=skb->len;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\ndev_kfree_skb (skb);\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG "%s: exiting eepro_send_packet routine.\n", dev->name);\r\neepro_en_int(ioaddr);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\neepro_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct eepro_local *lp;\r\nint ioaddr, status, boguscount = 20;\r\nint handled = 0;\r\nlp = netdev_priv(dev);\r\nspin_lock(&lp->lock);\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG "%s: entering eepro_interrupt routine.\n", dev->name);\r\nioaddr = dev->base_addr;\r\nwhile (((status = inb(ioaddr + STATUS_REG)) & (RX_INT|TX_INT)) && (boguscount--))\r\n{\r\nhandled = 1;\r\nif (status & RX_INT) {\r\nif (net_debug > 4)\r\nprintk(KERN_DEBUG "%s: packet received interrupt.\n", dev->name);\r\neepro_dis_int(ioaddr);\r\neepro_ack_rx(ioaddr);\r\neepro_rx(dev);\r\neepro_en_int(ioaddr);\r\n}\r\nif (status & TX_INT) {\r\nif (net_debug > 4)\r\nprintk(KERN_DEBUG "%s: packet transmit interrupt.\n", dev->name);\r\neepro_dis_int(ioaddr);\r\neepro_ack_tx(ioaddr);\r\neepro_transmit_interrupt(dev);\r\neepro_en_int(ioaddr);\r\n}\r\n}\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG "%s: exiting eepro_interrupt routine.\n", dev->name);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int eepro_close(struct net_device *dev)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nshort temp_reg;\r\nnetif_stop_queue(dev);\r\neepro_sw2bank1(ioaddr);\r\ntemp_reg = inb(ioaddr + REG1);\r\noutb(temp_reg & 0x7f, ioaddr + REG1);\r\neepro_sw2bank0(ioaddr);\r\noutb(STOP_RCV_CMD, ioaddr);\r\nlp->tx_start = lp->tx_end = lp->xmt_lower_limit;\r\nlp->tx_last = 0;\r\neepro_dis_int(ioaddr);\r\neepro_clear_int(ioaddr);\r\neepro_reset(ioaddr);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nset_multicast_list(struct net_device *dev)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nshort ioaddr = dev->base_addr;\r\nunsigned short mode;\r\nstruct netdev_hw_addr *ha;\r\nint mc_count = netdev_mc_count(dev);\r\nif (dev->flags&(IFF_ALLMULTI|IFF_PROMISC) || mc_count > 63)\r\n{\r\neepro_sw2bank2(ioaddr);\r\nmode = inb(ioaddr + REG2);\r\noutb(mode | PRMSC_Mode, ioaddr + REG2);\r\nmode = inb(ioaddr + REG3);\r\noutb(mode, ioaddr + REG3);\r\neepro_sw2bank0(ioaddr);\r\n}\r\nelse if (mc_count == 0)\r\n{\r\neepro_sw2bank2(ioaddr);\r\nmode = inb(ioaddr + REG2);\r\noutb(mode & 0xd6, ioaddr + REG2);\r\nmode = inb(ioaddr + REG3);\r\noutb(mode, ioaddr + REG3);\r\neepro_sw2bank0(ioaddr);\r\n}\r\nelse\r\n{\r\nunsigned short status, *eaddrs;\r\nint i, boguscount = 0;\r\neepro_dis_int(ioaddr);\r\neepro_sw2bank2(ioaddr);\r\nmode = inb(ioaddr + REG2);\r\noutb(mode | Multi_IA, ioaddr + REG2);\r\nmode = inb(ioaddr + REG3);\r\noutb(mode, ioaddr + REG3);\r\neepro_sw2bank0(ioaddr);\r\noutw(lp->tx_end, ioaddr + HOST_ADDRESS_REG);\r\noutw(MC_SETUP, ioaddr + IO_PORT);\r\noutw(0, ioaddr + IO_PORT);\r\noutw(0, ioaddr + IO_PORT);\r\noutw(6 * (mc_count + 1), ioaddr + IO_PORT);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\neaddrs = (unsigned short *) ha->addr;\r\noutw(*eaddrs++, ioaddr + IO_PORT);\r\noutw(*eaddrs++, ioaddr + IO_PORT);\r\noutw(*eaddrs++, ioaddr + IO_PORT);\r\n}\r\neaddrs = (unsigned short *) dev->dev_addr;\r\noutw(eaddrs[0], ioaddr + IO_PORT);\r\noutw(eaddrs[1], ioaddr + IO_PORT);\r\noutw(eaddrs[2], ioaddr + IO_PORT);\r\noutw(lp->tx_end, ioaddr + lp->xmt_bar);\r\noutb(MC_SETUP, ioaddr);\r\ni = lp->tx_end + XMT_HEADER + 6 * (mc_count + 1);\r\nif (lp->tx_start != lp->tx_end)\r\n{\r\noutw(lp->tx_last + XMT_CHAIN, ioaddr + HOST_ADDRESS_REG);\r\noutw(i, ioaddr + IO_PORT);\r\noutw(lp->tx_last + XMT_COUNT, ioaddr + HOST_ADDRESS_REG);\r\nstatus = inw(ioaddr + IO_PORT);\r\noutw(status | CHAIN_BIT, ioaddr + IO_PORT);\r\nlp->tx_end = i ;\r\n}\r\nelse {\r\nlp->tx_start = lp->tx_end = i ;\r\n}\r\ndo {\r\nSLOW_DOWN;\r\nSLOW_DOWN;\r\nif (inb(ioaddr + STATUS_REG) & 0x08)\r\n{\r\ni = inb(ioaddr);\r\noutb(0x08, ioaddr + STATUS_REG);\r\nif (i & 0x20) {\r\nprintk(KERN_NOTICE "%s: multicast setup failed.\n",\r\ndev->name);\r\nbreak;\r\n} else if ((i & 0x0f) == 0x03) {\r\nprintk(KERN_DEBUG "%s: set Rx mode to %d address%s.\n",\r\ndev->name, mc_count,\r\nmc_count > 1 ? "es":"");\r\nbreak;\r\n}\r\n}\r\n} while (++boguscount < 100);\r\neepro_en_int(ioaddr);\r\n}\r\nif (lp->eepro == LAN595FX_10ISA) {\r\neepro_complete_selreset(ioaddr);\r\n}\r\nelse\r\neepro_en_rx(ioaddr);\r\n}\r\nstatic int\r\nread_eeprom(int ioaddr, int location, struct net_device *dev)\r\n{\r\nint i;\r\nunsigned short retval = 0;\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nshort ee_addr = ioaddr + lp->eeprom_reg;\r\nint read_cmd = location | EE_READ_CMD;\r\nshort ctrl_val = EECS ;\r\neepro_sw2bank1(ioaddr);\r\noutb(0x00, ioaddr + STATUS_REG);\r\neepro_sw2bank2(ioaddr);\r\noutb(ctrl_val, ee_addr);\r\nfor (i = 8; i >= 0; i--) {\r\nshort outval = (read_cmd & (1 << i)) ? ctrl_val | EEDI\r\n: ctrl_val;\r\noutb(outval, ee_addr);\r\noutb(outval | EESK, ee_addr);\r\neeprom_delay();\r\noutb(outval, ee_addr);\r\neeprom_delay();\r\n}\r\noutb(ctrl_val, ee_addr);\r\nfor (i = 16; i > 0; i--) {\r\noutb(ctrl_val | EESK, ee_addr); eeprom_delay();\r\nretval = (retval << 1) | ((inb(ee_addr) & EEDO) ? 1 : 0);\r\noutb(ctrl_val, ee_addr); eeprom_delay();\r\n}\r\nctrl_val &= ~EECS;\r\noutb(ctrl_val | EESK, ee_addr);\r\neeprom_delay();\r\noutb(ctrl_val, ee_addr);\r\neeprom_delay();\r\neepro_sw2bank0(ioaddr);\r\nreturn retval;\r\n}\r\nstatic int\r\nhardware_send_packet(struct net_device *dev, void *buf, short length)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nshort ioaddr = dev->base_addr;\r\nunsigned status, tx_available, last, end;\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG "%s: entering hardware_send_packet routine.\n", dev->name);\r\nif (lp->tx_end > lp->tx_start)\r\ntx_available = lp->xmt_ram - (lp->tx_end - lp->tx_start);\r\nelse if (lp->tx_end < lp->tx_start)\r\ntx_available = lp->tx_start - lp->tx_end;\r\nelse tx_available = lp->xmt_ram;\r\nif (((((length + 3) >> 1) << 1) + 2*XMT_HEADER) >= tx_available) {\r\nreturn 1;\r\n}\r\nlast = lp->tx_end;\r\nend = last + (((length + 3) >> 1) << 1) + XMT_HEADER;\r\nif (end >= lp->xmt_upper_limit + 2) {\r\nif ((lp->xmt_upper_limit + 2 - last) <= XMT_HEADER) {\r\nlast = lp->xmt_lower_limit;\r\nend = last + (((length + 3) >> 1) << 1) + XMT_HEADER;\r\n}\r\nelse end = lp->xmt_lower_limit + (end -\r\nlp->xmt_upper_limit + 2);\r\n}\r\noutw(last, ioaddr + HOST_ADDRESS_REG);\r\noutw(XMT_CMD, ioaddr + IO_PORT);\r\noutw(0, ioaddr + IO_PORT);\r\noutw(end, ioaddr + IO_PORT);\r\noutw(length, ioaddr + IO_PORT);\r\nif (lp->version == LAN595)\r\noutsw(ioaddr + IO_PORT, buf, (length + 3) >> 1);\r\nelse {\r\nunsigned short temp = inb(ioaddr + INT_MASK_REG);\r\noutb(temp | IO_32_BIT, ioaddr + INT_MASK_REG);\r\noutsl(ioaddr + IO_PORT_32_BIT, buf, (length + 3) >> 2);\r\noutb(temp & ~(IO_32_BIT), ioaddr + INT_MASK_REG);\r\n}\r\nstatus = inw(ioaddr + IO_PORT);\r\nif (lp->tx_start == lp->tx_end) {\r\noutw(last, ioaddr + lp->xmt_bar);\r\noutb(XMT_CMD, ioaddr);\r\nlp->tx_start = last;\r\n}\r\nelse {\r\nif (lp->tx_end != last) {\r\noutw(lp->tx_last + XMT_CHAIN, ioaddr + HOST_ADDRESS_REG);\r\noutw(last, ioaddr + IO_PORT);\r\n}\r\noutw(lp->tx_last + XMT_COUNT, ioaddr + HOST_ADDRESS_REG);\r\nstatus = inw(ioaddr + IO_PORT);\r\noutw(status | CHAIN_BIT, ioaddr + IO_PORT);\r\noutb(RESUME_XMT_CMD, ioaddr);\r\n}\r\nlp->tx_last = last;\r\nlp->tx_end = end;\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG "%s: exiting hardware_send_packet routine.\n", dev->name);\r\nreturn 0;\r\n}\r\nstatic void\r\neepro_rx(struct net_device *dev)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nshort ioaddr = dev->base_addr;\r\nshort boguscount = 20;\r\nshort rcv_car = lp->rx_start;\r\nunsigned rcv_event, rcv_status, rcv_next_frame, rcv_size;\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG "%s: entering eepro_rx routine.\n", dev->name);\r\noutw(rcv_car, ioaddr + HOST_ADDRESS_REG);\r\nrcv_event = inw(ioaddr + IO_PORT);\r\nwhile (rcv_event == RCV_DONE) {\r\nrcv_status = inw(ioaddr + IO_PORT);\r\nrcv_next_frame = inw(ioaddr + IO_PORT);\r\nrcv_size = inw(ioaddr + IO_PORT);\r\nif ((rcv_status & (RX_OK | RX_ERROR)) == RX_OK) {\r\nstruct sk_buff *skb;\r\ndev->stats.rx_bytes+=rcv_size;\r\nrcv_size &= 0x3fff;\r\nskb = dev_alloc_skb(rcv_size+5);\r\nif (skb == NULL) {\r\nprintk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nrcv_car = lp->rx_start + RCV_HEADER + rcv_size;\r\nlp->rx_start = rcv_next_frame;\r\noutw(rcv_next_frame, ioaddr + HOST_ADDRESS_REG);\r\nbreak;\r\n}\r\nskb_reserve(skb,2);\r\nif (lp->version == LAN595)\r\ninsw(ioaddr+IO_PORT, skb_put(skb,rcv_size), (rcv_size + 3) >> 1);\r\nelse {\r\nunsigned short temp = inb(ioaddr + INT_MASK_REG);\r\noutb(temp | IO_32_BIT, ioaddr + INT_MASK_REG);\r\ninsl(ioaddr+IO_PORT_32_BIT, skb_put(skb,rcv_size),\r\n(rcv_size + 3) >> 2);\r\noutb(temp & ~(IO_32_BIT), ioaddr + INT_MASK_REG);\r\n}\r\nskb->protocol = eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nelse {\r\ndev->stats.rx_errors++;\r\nif (rcv_status & 0x0100)\r\ndev->stats.rx_over_errors++;\r\nelse if (rcv_status & 0x0400)\r\ndev->stats.rx_frame_errors++;\r\nelse if (rcv_status & 0x0800)\r\ndev->stats.rx_crc_errors++;\r\nprintk(KERN_DEBUG "%s: event = %#x, status = %#x, next = %#x, size = %#x\n",\r\ndev->name, rcv_event, rcv_status, rcv_next_frame, rcv_size);\r\n}\r\nif (rcv_status & 0x1000)\r\ndev->stats.rx_length_errors++;\r\nrcv_car = lp->rx_start + RCV_HEADER + rcv_size;\r\nlp->rx_start = rcv_next_frame;\r\nif (--boguscount == 0)\r\nbreak;\r\noutw(rcv_next_frame, ioaddr + HOST_ADDRESS_REG);\r\nrcv_event = inw(ioaddr + IO_PORT);\r\n}\r\nif (rcv_car == 0)\r\nrcv_car = lp->rcv_upper_limit | 0xff;\r\noutw(rcv_car - 1, ioaddr + RCV_STOP);\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG "%s: exiting eepro_rx routine.\n", dev->name);\r\n}\r\nstatic void\r\neepro_transmit_interrupt(struct net_device *dev)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\nshort ioaddr = dev->base_addr;\r\nshort boguscount = 25;\r\nshort xmt_status;\r\nwhile ((lp->tx_start != lp->tx_end) && boguscount--) {\r\noutw(lp->tx_start, ioaddr + HOST_ADDRESS_REG);\r\nxmt_status = inw(ioaddr+IO_PORT);\r\nif (!(xmt_status & TX_DONE_BIT))\r\nbreak;\r\nxmt_status = inw(ioaddr+IO_PORT);\r\nlp->tx_start = inw(ioaddr+IO_PORT);\r\nnetif_wake_queue (dev);\r\nif (xmt_status & TX_OK)\r\ndev->stats.tx_packets++;\r\nelse {\r\ndev->stats.tx_errors++;\r\nif (xmt_status & 0x0400) {\r\ndev->stats.tx_carrier_errors++;\r\nprintk(KERN_DEBUG "%s: carrier error\n",\r\ndev->name);\r\nprintk(KERN_DEBUG "%s: XMT status = %#x\n",\r\ndev->name, xmt_status);\r\n}\r\nelse {\r\nprintk(KERN_DEBUG "%s: XMT status = %#x\n",\r\ndev->name, xmt_status);\r\nprintk(KERN_DEBUG "%s: XMT status = %#x\n",\r\ndev->name, xmt_status);\r\n}\r\n}\r\nif (xmt_status & 0x000f) {\r\ndev->stats.collisions += (xmt_status & 0x000f);\r\n}\r\nif ((xmt_status & 0x0040) == 0x0) {\r\ndev->stats.tx_heartbeat_errors++;\r\n}\r\n}\r\n}\r\nstatic int eepro_ethtool_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct eepro_local *lp = netdev_priv(dev);\r\ncmd->supported = SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_Autoneg;\r\ncmd->advertising = ADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_Autoneg;\r\nif (GetBit(lp->word[5], ee_PortTPE)) {\r\ncmd->supported |= SUPPORTED_TP;\r\ncmd->advertising |= ADVERTISED_TP;\r\n}\r\nif (GetBit(lp->word[5], ee_PortBNC)) {\r\ncmd->supported |= SUPPORTED_BNC;\r\ncmd->advertising |= ADVERTISED_BNC;\r\n}\r\nif (GetBit(lp->word[5], ee_PortAUI)) {\r\ncmd->supported |= SUPPORTED_AUI;\r\ncmd->advertising |= ADVERTISED_AUI;\r\n}\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\nif (dev->if_port == TPE && lp->word[1] & ee_Duplex) {\r\ncmd->duplex = DUPLEX_FULL;\r\n}\r\nelse {\r\ncmd->duplex = DUPLEX_HALF;\r\n}\r\ncmd->port = dev->if_port;\r\ncmd->phy_address = dev->base_addr;\r\ncmd->transceiver = XCVR_INTERNAL;\r\nif (lp->word[0] & ee_AutoNeg) {\r\ncmd->autoneg = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void eepro_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstrcpy(drvinfo->driver, DRV_NAME);\r\nstrcpy(drvinfo->version, DRV_VERSION);\r\nsprintf(drvinfo->bus_info, "ISA 0x%lx", dev->base_addr);\r\n}\r\nint __init init_module(void)\r\n{\r\nstruct net_device *dev;\r\nint i;\r\nif (io[0] == -1 && autodetect == 0) {\r\nprintk(KERN_WARNING "eepro_init_module: Probe is very dangerous in ISA boards!\n");\r\nprintk(KERN_WARNING "eepro_init_module: Please add \"autodetect=1\" to force probe\n");\r\nreturn -ENODEV;\r\n}\r\nelse if (autodetect) {\r\nfor (i = 0; i < MAX_EEPRO; i++) {\r\nio[i] = 0;\r\n}\r\nprintk(KERN_INFO "eepro_init_module: Auto-detecting boards (May God protect us...)\n");\r\n}\r\nfor (i = 0; i < MAX_EEPRO && io[i] != -1; i++) {\r\ndev = alloc_etherdev(sizeof(struct eepro_local));\r\nif (!dev)\r\nbreak;\r\ndev->mem_end = mem[i];\r\ndev->base_addr = io[i];\r\ndev->irq = irq[i];\r\nif (do_eepro_probe(dev) == 0) {\r\ndev_eepro[n_eepro++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\nif (n_eepro)\r\nprintk(KERN_INFO "%s", version);\r\nreturn n_eepro ? 0 : -ENODEV;\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nint i;\r\nfor (i=0; i<n_eepro; i++) {\r\nstruct net_device *dev = dev_eepro[i];\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, EEPRO_IO_EXTENT);\r\nfree_netdev(dev);\r\n}\r\n}
