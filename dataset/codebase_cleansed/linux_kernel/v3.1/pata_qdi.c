static void qdi6500_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ata_timing t;\r\nstruct qdi_data *qdi = ap->host->private_data;\r\nint active, recovery;\r\nu8 timing;\r\nata_timing_compute(adev, adev->pio_mode, &t, 30303, 1000);\r\nif (qdi->fast) {\r\nactive = 8 - clamp_val(t.active, 1, 8);\r\nrecovery = 18 - clamp_val(t.recover, 3, 18);\r\n} else {\r\nactive = 9 - clamp_val(t.active, 2, 9);\r\nrecovery = 15 - clamp_val(t.recover, 0, 15);\r\n}\r\ntiming = (recovery << 4) | active | 0x08;\r\nqdi->clock[adev->devno] = timing;\r\noutb(timing, qdi->timing);\r\n}\r\nstatic void qdi6580_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ata_timing t;\r\nstruct qdi_data *qdi = ap->host->private_data;\r\nint active, recovery;\r\nu8 timing;\r\nata_timing_compute(adev, adev->pio_mode, &t, 30303, 1000);\r\nif (qdi->fast) {\r\nactive = 8 - clamp_val(t.active, 1, 8);\r\nrecovery = 18 - clamp_val(t.recover, 3, 18);\r\n} else {\r\nactive = 9 - clamp_val(t.active, 2, 9);\r\nrecovery = 15 - clamp_val(t.recover, 0, 15);\r\n}\r\ntiming = (recovery << 4) | active | 0x08;\r\nqdi->clock[adev->devno] = timing;\r\noutb(timing, qdi->timing);\r\nif (adev->class != ATA_DEV_ATA)\r\noutb(0x5F, (qdi->timing & 0xFFF0) + 3);\r\n}\r\nstatic unsigned int qdi_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nstruct qdi_data *qdi = ap->host->private_data;\r\nif (qdi->clock[adev->devno] != qdi->last) {\r\nif (adev->pio_mode) {\r\nqdi->last = qdi->clock[adev->devno];\r\noutb(qdi->clock[adev->devno], qdi->timing);\r\n}\r\n}\r\nreturn ata_sff_qc_issue(qc);\r\n}\r\nstatic unsigned int qdi_data_xfer(struct ata_device *dev, unsigned char *buf,\r\nunsigned int buflen, int rw)\r\n{\r\nif (ata_id_has_dword_io(dev->id)) {\r\nstruct ata_port *ap = dev->link->ap;\r\nint slop = buflen & 3;\r\nif (rw == READ)\r\nioread32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\r\nelse\r\niowrite32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\r\nif (unlikely(slop)) {\r\n__le32 pad;\r\nif (rw == READ) {\r\npad = cpu_to_le32(ioread32(ap->ioaddr.data_addr));\r\nmemcpy(buf + buflen - slop, &pad, slop);\r\n} else {\r\nmemcpy(&pad, buf + buflen - slop, slop);\r\niowrite32(le32_to_cpu(pad), ap->ioaddr.data_addr);\r\n}\r\nbuflen += 4 - slop;\r\n}\r\n} else\r\nbuflen = ata_sff_data_xfer(dev, buf, buflen, rw);\r\nreturn buflen;\r\n}\r\nstatic __init int qdi_init_one(unsigned long port, int type, unsigned long io, int irq, int fast)\r\n{\r\nunsigned long ctl = io + 0x206;\r\nstruct platform_device *pdev;\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nvoid __iomem *io_addr, *ctl_addr;\r\nint ret;\r\npdev = platform_device_register_simple(DRV_NAME, nr_qdi_host, NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nret = -ENOMEM;\r\nio_addr = devm_ioport_map(&pdev->dev, io, 8);\r\nctl_addr = devm_ioport_map(&pdev->dev, ctl, 1);\r\nif (!io_addr || !ctl_addr)\r\ngoto fail;\r\nret = -ENOMEM;\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host)\r\ngoto fail;\r\nap = host->ports[0];\r\nif (type == 6580) {\r\nap->ops = &qdi6580_port_ops;\r\nap->pio_mask = ATA_PIO4;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\n} else {\r\nap->ops = &qdi6500_port_ops;\r\nap->pio_mask = ATA_PIO2;\r\nap->flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_NO_IORDY;\r\n}\r\nap->ioaddr.cmd_addr = io_addr;\r\nap->ioaddr.altstatus_addr = ctl_addr;\r\nap->ioaddr.ctl_addr = ctl_addr;\r\nata_sff_std_ports(&ap->ioaddr);\r\nata_port_desc(ap, "cmd %lx ctl %lx", io, ctl);\r\nap->private_data = &qdi_data[nr_qdi_host];\r\nqdi_data[nr_qdi_host].timing = port;\r\nqdi_data[nr_qdi_host].fast = fast;\r\nqdi_data[nr_qdi_host].platform_dev = pdev;\r\nprintk(KERN_INFO DRV_NAME": qd%d at 0x%lx.\n", type, io);\r\nret = ata_host_activate(host, irq, ata_sff_interrupt, 0, &qdi_sht);\r\nif (ret)\r\ngoto fail;\r\nqdi_host[nr_qdi_host++] = dev_get_drvdata(&pdev->dev);\r\nreturn 0;\r\nfail:\r\nplatform_device_unregister(pdev);\r\nreturn ret;\r\n}\r\nstatic __init int qdi_init(void)\r\n{\r\nunsigned long flags;\r\nstatic const unsigned long qd_port[2] = { 0x30, 0xB0 };\r\nstatic const unsigned long ide_port[2] = { 0x170, 0x1F0 };\r\nstatic const int ide_irq[2] = { 14, 15 };\r\nint ct = 0;\r\nint i;\r\nif (probe_qdi == 0)\r\nreturn -ENODEV;\r\nfor (i = 0; i < 2; i++) {\r\nunsigned long port = qd_port[i];\r\nu8 r, res;\r\nif (request_region(port, 2, "pata_qdi")) {\r\nlocal_irq_save(flags);\r\nr = inb_p(port);\r\noutb_p(0x19, port);\r\nres = inb_p(port);\r\noutb_p(r, port);\r\nlocal_irq_restore(flags);\r\nif (res == 0x19)\r\n{\r\nrelease_region(port, 2);\r\ncontinue;\r\n}\r\nr = inb_p(port + 1);\r\nif ((r & 2) >> 1 != i) {\r\nrelease_region(port, 2);\r\ncontinue;\r\n}\r\nif ((r & 0xF0) == 0xC0) {\r\nif (r & 8) {\r\nrelease_region(port, 2);\r\ncontinue;\r\n}\r\nif (qdi_init_one(port, 6500, ide_port[r & 0x01], ide_irq[r & 0x01], r & 0x04) == 0)\r\nct++;\r\n}\r\nif (((r & 0xF0) == 0xA0) || (r & 0xF0) == 0x50) {\r\nif (!request_region(port + 2 , 2, "pata_qdi"))\r\n{\r\nrelease_region(port, 2);\r\ncontinue;\r\n}\r\nres = inb(port + 3);\r\nif (res & 1) {\r\nif (qdi_init_one(port, 6580, ide_port[r & 0x01], ide_irq[r & 0x01], r & 0x04) == 0)\r\nct++;\r\n} else {\r\nif (qdi_init_one(port, 6580, 0x1F0, 14, r & 0x04) == 0)\r\nct++;\r\nif (qdi_init_one(port + 2, 6580, 0x170, 15, r & 0x04) == 0)\r\nct++;\r\n}\r\n}\r\n}\r\n}\r\nif (ct != 0)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic __exit void qdi_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_qdi_host; i++) {\r\nata_host_detach(qdi_host[i]);\r\nrelease_region(qdi_data[i].timing, 2);\r\nplatform_device_unregister(qdi_data[i].platform_dev);\r\n}\r\n}
