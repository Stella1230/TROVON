int w1_ds2780_io(struct device *dev, char *buf, int addr, size_t count,\r\nint io)\r\n{\r\nstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&sl->master->mutex);\r\nif (addr > DS2780_DATA_SIZE || addr < 0) {\r\ncount = 0;\r\ngoto out;\r\n}\r\ncount = min_t(int, count, DS2780_DATA_SIZE - addr);\r\nif (w1_reset_select_slave(sl) == 0) {\r\nif (io) {\r\nw1_write_8(sl->master, W1_DS2780_WRITE_DATA);\r\nw1_write_8(sl->master, addr);\r\nw1_write_block(sl->master, buf, count);\r\n} else {\r\nw1_write_8(sl->master, W1_DS2780_READ_DATA);\r\nw1_write_8(sl->master, addr);\r\ncount = w1_read_block(sl->master, buf, count);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&sl->master->mutex);\r\nreturn count;\r\n}\r\nint w1_ds2780_eeprom_cmd(struct device *dev, int addr, int cmd)\r\n{\r\nstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\r\nif (!dev)\r\nreturn -EINVAL;\r\nmutex_lock(&sl->master->mutex);\r\nif (w1_reset_select_slave(sl) == 0) {\r\nw1_write_8(sl->master, cmd);\r\nw1_write_8(sl->master, addr);\r\n}\r\nmutex_unlock(&sl->master->mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t w1_ds2780_read_bin(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nreturn w1_ds2780_io(dev, buf, off, count, 0);\r\n}\r\nstatic int new_bat_id(void)\r\n{\r\nint ret;\r\nwhile (1) {\r\nint id;\r\nret = idr_pre_get(&bat_idr, GFP_KERNEL);\r\nif (ret == 0)\r\nreturn -ENOMEM;\r\nmutex_lock(&bat_idr_lock);\r\nret = idr_get_new(&bat_idr, NULL, &id);\r\nmutex_unlock(&bat_idr_lock);\r\nif (ret == 0) {\r\nret = id & MAX_ID_MASK;\r\nbreak;\r\n} else if (ret == -EAGAIN) {\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void release_bat_id(int id)\r\n{\r\nmutex_lock(&bat_idr_lock);\r\nidr_remove(&bat_idr, id);\r\nmutex_unlock(&bat_idr_lock);\r\n}\r\nstatic int w1_ds2780_add_slave(struct w1_slave *sl)\r\n{\r\nint ret;\r\nint id;\r\nstruct platform_device *pdev;\r\nid = new_bat_id();\r\nif (id < 0) {\r\nret = id;\r\ngoto noid;\r\n}\r\npdev = platform_device_alloc("ds2780-battery", id);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto pdev_alloc_failed;\r\n}\r\npdev->dev.parent = &sl->dev;\r\nret = platform_device_add(pdev);\r\nif (ret)\r\ngoto pdev_add_failed;\r\nret = sysfs_create_bin_file(&sl->dev.kobj, &w1_ds2780_bin_attr);\r\nif (ret)\r\ngoto bin_attr_failed;\r\ndev_set_drvdata(&sl->dev, pdev);\r\nreturn 0;\r\nbin_attr_failed:\r\npdev_add_failed:\r\nplatform_device_unregister(pdev);\r\npdev_alloc_failed:\r\nrelease_bat_id(id);\r\nnoid:\r\nreturn ret;\r\n}\r\nstatic void w1_ds2780_remove_slave(struct w1_slave *sl)\r\n{\r\nstruct platform_device *pdev = dev_get_drvdata(&sl->dev);\r\nint id = pdev->id;\r\nplatform_device_unregister(pdev);\r\nrelease_bat_id(id);\r\nsysfs_remove_bin_file(&sl->dev.kobj, &w1_ds2780_bin_attr);\r\n}\r\nstatic int __init w1_ds2780_init(void)\r\n{\r\nidr_init(&bat_idr);\r\nreturn w1_register_family(&w1_ds2780_family);\r\n}\r\nstatic void __exit w1_ds2780_exit(void)\r\n{\r\nw1_unregister_family(&w1_ds2780_family);\r\nidr_destroy(&bat_idr);\r\n}
