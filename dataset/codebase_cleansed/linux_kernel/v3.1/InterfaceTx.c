static void write_bulk_callback(struct urb *urb)\r\n{\r\nPUSB_TCB pTcb= (PUSB_TCB)urb->context;\r\nPS_INTERFACE_ADAPTER psIntfAdapter = pTcb->psIntfAdapter;\r\nCONTROL_MESSAGE *pControlMsg = (CONTROL_MESSAGE *)urb->transfer_buffer;\r\nPMINI_ADAPTER psAdapter = psIntfAdapter->psAdapter ;\r\nBOOLEAN bpowerDownMsg = FALSE ;\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif (unlikely(netif_msg_tx_done(Adapter)))\r\npr_info(PFX "%s: transmit status %d\n", Adapter->dev->name, urb->status);\r\nif(urb->status != STATUS_SUCCESS)\r\n{\r\nif(urb->status == -EPIPE)\r\n{\r\npsIntfAdapter->psAdapter->bEndPointHalted = TRUE ;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,"Tx URB has got cancelled. status :%d", urb->status);\r\n}\r\n}\r\npTcb->bUsed = FALSE;\r\natomic_dec(&psIntfAdapter->uNumTcbUsed);\r\nif(TRUE == psAdapter->bPreparingForLowPowerMode)\r\n{\r\nif(((pControlMsg->szData[0] == GO_TO_IDLE_MODE_PAYLOAD) &&\r\n(pControlMsg->szData[1] == TARGET_CAN_GO_TO_IDLE_MODE)))\r\n{\r\nbpowerDownMsg = TRUE ;\r\nif(urb->status != STATUS_SUCCESS)\r\n{\r\npsAdapter->bPreparingForLowPowerMode = FALSE ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,"Idle Mode Request msg failed to reach to Modem");\r\nwake_up(&psAdapter->lowpower_mode_wait_queue);\r\nStartInterruptUrb(psIntfAdapter);\r\ngoto err_exit;\r\n}\r\nif(psAdapter->bDoSuspend == FALSE)\r\n{\r\npsAdapter->IdleMode = TRUE;\r\npsAdapter->bPreparingForLowPowerMode = FALSE ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL, "Host Entered in Idle Mode State...");\r\nwake_up(&psAdapter->lowpower_mode_wait_queue);\r\n}\r\n}\r\nelse if((pControlMsg->Leader.Status == LINK_UP_CONTROL_REQ) &&\r\n(pControlMsg->szData[0] == LINK_UP_ACK) &&\r\n(pControlMsg->szData[1] == LINK_SHUTDOWN_REQ_FROM_FIRMWARE) &&\r\n(pControlMsg->szData[2] == SHUTDOWN_ACK_FROM_DRIVER))\r\n{\r\nif(urb->status != STATUS_SUCCESS)\r\n{\r\npsAdapter->bPreparingForLowPowerMode = FALSE ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,"Shutdown Request Msg failed to reach to Modem");\r\nwake_up(&psAdapter->lowpower_mode_wait_queue);\r\nStartInterruptUrb(psIntfAdapter);\r\ngoto err_exit;\r\n}\r\nbpowerDownMsg = TRUE ;\r\nif(psAdapter->bDoSuspend == FALSE)\r\n{\r\npsAdapter->bShutStatus = TRUE;\r\npsAdapter->bPreparingForLowPowerMode = FALSE ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,"Host Entered in shutdown Mode State...");\r\nwake_up(&psAdapter->lowpower_mode_wait_queue);\r\n}\r\n}\r\nif(psAdapter->bDoSuspend && bpowerDownMsg)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,"Issuing the Bus suspend request to USB stack");\r\npsIntfAdapter->bPreparingForBusSuspend = TRUE;\r\nschedule_work(&psIntfAdapter->usbSuspendWork);\r\n}\r\n}\r\nerr_exit :\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\n}\r\nstatic PUSB_TCB GetBulkOutTcb(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nPUSB_TCB pTcb = NULL;\r\nUINT index = 0;\r\nif((atomic_read(&psIntfAdapter->uNumTcbUsed) < MAXIMUM_USB_TCB) &&\r\n(psIntfAdapter->psAdapter->StopAllXaction ==FALSE))\r\n{\r\nindex = atomic_read(&psIntfAdapter->uCurrTcb);\r\npTcb = &psIntfAdapter->asUsbTcb[index];\r\npTcb->bUsed = TRUE;\r\npTcb->psIntfAdapter= psIntfAdapter;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL, "Got Tx desc %d used %d",\r\nindex, atomic_read(&psIntfAdapter->uNumTcbUsed));\r\nindex = (index + 1) % MAXIMUM_USB_TCB;\r\natomic_set(&psIntfAdapter->uCurrTcb, index);\r\natomic_inc(&psIntfAdapter->uNumTcbUsed);\r\n}\r\nreturn pTcb;\r\n}\r\nstatic int TransmitTcb(PS_INTERFACE_ADAPTER psIntfAdapter, PUSB_TCB pTcb, PVOID data, int len)\r\n{\r\nstruct urb *urb = pTcb->urb;\r\nint retval = 0;\r\nurb->transfer_buffer = usb_alloc_coherent(psIntfAdapter->udev, len,\r\nGFP_ATOMIC, &urb->transfer_dma);\r\nif (!urb->transfer_buffer)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_PRINTK, 0, 0, "Error allocating memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(urb->transfer_buffer, data, len);\r\nurb->transfer_buffer_length = len;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL, "Sending Bulk out packet\n");\r\nif((psIntfAdapter->psAdapter->chip_id == T3B) && (psIntfAdapter->bHighSpeedDevice == TRUE))\r\n{\r\nusb_fill_int_urb(urb, psIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut.bulk_out_pipe,\r\nurb->transfer_buffer, len, write_bulk_callback, pTcb,\r\npsIntfAdapter->sBulkOut.int_out_interval);\r\n}\r\nelse\r\n{\r\nusb_fill_bulk_urb(urb, psIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut.bulk_out_pipe,\r\nurb->transfer_buffer, len, write_bulk_callback, pTcb);\r\n}\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif(FALSE == psIntfAdapter->psAdapter->device_removed &&\r\nFALSE == psIntfAdapter->psAdapter->bEndPointHalted &&\r\nFALSE == psIntfAdapter->bSuspended &&\r\nFALSE == psIntfAdapter->bPreparingForBusSuspend)\r\n{\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL, "failed submitting write urb, error %d", retval);\r\nif(retval == -EPIPE)\r\n{\r\npsIntfAdapter->psAdapter->bEndPointHalted = TRUE ;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nint InterfaceTransmitPacket(PVOID arg, PVOID data, UINT len)\r\n{\r\nPUSB_TCB pTcb= NULL;\r\nPS_INTERFACE_ADAPTER psIntfAdapter = (PS_INTERFACE_ADAPTER)arg;\r\npTcb= GetBulkOutTcb(psIntfAdapter);\r\nif(pTcb == NULL)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_PRINTK, 0, 0, "No URB to transmit packet, dropping packet");\r\nreturn -EFAULT;\r\n}\r\nreturn TransmitTcb(psIntfAdapter, pTcb, data, len);\r\n}
