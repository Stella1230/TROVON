static unsigned long vsmp_save_fl(void)\r\n{\r\nunsigned long flags = native_save_fl();\r\nif (!(flags & X86_EFLAGS_IF) || (flags & X86_EFLAGS_AC))\r\nflags &= ~X86_EFLAGS_IF;\r\nreturn flags;\r\n}\r\nstatic void vsmp_restore_fl(unsigned long flags)\r\n{\r\nif (flags & X86_EFLAGS_IF)\r\nflags &= ~X86_EFLAGS_AC;\r\nelse\r\nflags |= X86_EFLAGS_AC;\r\nnative_restore_fl(flags);\r\n}\r\nstatic void vsmp_irq_disable(void)\r\n{\r\nunsigned long flags = native_save_fl();\r\nnative_restore_fl((flags & ~X86_EFLAGS_IF) | X86_EFLAGS_AC);\r\n}\r\nstatic void vsmp_irq_enable(void)\r\n{\r\nunsigned long flags = native_save_fl();\r\nnative_restore_fl((flags | X86_EFLAGS_IF) & (~X86_EFLAGS_AC));\r\n}\r\nstatic unsigned __init_or_module vsmp_patch(u8 type, u16 clobbers, void *ibuf,\r\nunsigned long addr, unsigned len)\r\n{\r\nswitch (type) {\r\ncase PARAVIRT_PATCH(pv_irq_ops.irq_enable):\r\ncase PARAVIRT_PATCH(pv_irq_ops.irq_disable):\r\ncase PARAVIRT_PATCH(pv_irq_ops.save_fl):\r\ncase PARAVIRT_PATCH(pv_irq_ops.restore_fl):\r\nreturn paravirt_patch_default(type, clobbers, ibuf, addr, len);\r\ndefault:\r\nreturn native_patch(type, clobbers, ibuf, addr, len);\r\n}\r\n}\r\nstatic void __init set_vsmp_pv_ops(void)\r\n{\r\nvoid __iomem *address;\r\nunsigned int cap, ctl, cfg;\r\ncfg = read_pci_config(0, 0x1f, 0, PCI_BASE_ADDRESS_0);\r\naddress = early_ioremap(cfg, 8);\r\ncap = readl(address);\r\nctl = readl(address + 4);\r\nprintk(KERN_INFO "vSMP CTL: capabilities:0x%08x control:0x%08x\n",\r\ncap, ctl);\r\nif (cap & ctl & (1 << 4)) {\r\npv_irq_ops.irq_disable = PV_CALLEE_SAVE(vsmp_irq_disable);\r\npv_irq_ops.irq_enable = PV_CALLEE_SAVE(vsmp_irq_enable);\r\npv_irq_ops.save_fl = PV_CALLEE_SAVE(vsmp_save_fl);\r\npv_irq_ops.restore_fl = PV_CALLEE_SAVE(vsmp_restore_fl);\r\npv_init_ops.patch = vsmp_patch;\r\nctl &= ~(1 << 4);\r\nwritel(ctl, address + 4);\r\nctl = readl(address + 4);\r\nprintk(KERN_INFO "vSMP CTL: control set to:0x%08x\n", ctl);\r\n}\r\nearly_iounmap(address, 8);\r\n}\r\nstatic void __init set_vsmp_pv_ops(void)\r\n{\r\n}\r\nstatic void __init detect_vsmp_box(void)\r\n{\r\nis_vsmp = 0;\r\nif (!early_pci_allowed())\r\nreturn;\r\nif (read_pci_config(0, 0x1f, 0, PCI_VENDOR_ID) ==\r\n(PCI_VENDOR_ID_SCALEMP | (PCI_DEVICE_ID_SCALEMP_VSMP_CTL << 16)))\r\nis_vsmp = 1;\r\n}\r\nint is_vsmp_box(void)\r\n{\r\nif (is_vsmp != -1)\r\nreturn is_vsmp;\r\nelse {\r\nWARN_ON_ONCE(1);\r\nreturn 0;\r\n}\r\n}\r\nstatic void __init detect_vsmp_box(void)\r\n{\r\n}\r\nint is_vsmp_box(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid __init vsmp_init(void)\r\n{\r\ndetect_vsmp_box();\r\nif (!is_vsmp_box())\r\nreturn;\r\nset_vsmp_pv_ops();\r\nreturn;\r\n}
