static int snd_intelmad_pcm_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nint ret_val = 0, str_id;\r\nstruct snd_intelmad *intelmaddata;\r\nstruct mad_stream_pvt *stream;\r\nstruct intel_sst_pcm_control *sst_ops;\r\nWARN_ON(!substream);\r\nintelmaddata = snd_pcm_substream_chip(substream);\r\nstream = substream->runtime->private_data;\r\nWARN_ON(!intelmaddata->sstdrv_ops);\r\nWARN_ON(!intelmaddata->sstdrv_ops->scard_ops);\r\nsst_ops = intelmaddata->sstdrv_ops->pcm_control;\r\nstr_id = stream->stream_info.str_id;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\npr_debug("Trigger Start\n");\r\nret_val = sst_ops->device_control(SST_SND_START, &str_id);\r\nif (ret_val)\r\nreturn ret_val;\r\nstream->stream_status = RUNNING;\r\nstream->substream = substream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\npr_debug("in stop\n");\r\nret_val = sst_ops->device_control(SST_SND_DROP, &str_id);\r\nif (ret_val)\r\nreturn ret_val;\r\nstream->stream_status = DROPPED;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\npr_debug("in pause\n");\r\nret_val = sst_ops->device_control(SST_SND_PAUSE, &str_id);\r\nif (ret_val)\r\nreturn ret_val;\r\nstream->stream_status = PAUSED;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\npr_debug("in pause release\n");\r\nret_val = sst_ops->device_control(SST_SND_RESUME, &str_id);\r\nif (ret_val)\r\nreturn ret_val;\r\nstream->stream_status = RUNNING;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int snd_intelmad_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct mad_stream_pvt *stream;\r\nint ret_val = 0;\r\nstruct snd_intelmad *intelmaddata;\r\npr_debug("pcm_prepare called\n");\r\nWARN_ON(!substream);\r\nstream = substream->runtime->private_data;\r\nintelmaddata = snd_pcm_substream_chip(substream);\r\npr_debug("pb cnt = %d cap cnt = %d\n",\\r\nintelmaddata->playback_cnt,\r\nintelmaddata->capture_cnt);\r\nif (stream->stream_info.str_id) {\r\npr_debug("Prepare called for already set stream\n");\r\nret_val = intelmaddata->sstdrv_ops->pcm_control->device_control(\r\nSST_SND_DROP, &stream->stream_info.str_id);\r\nreturn ret_val;\r\n}\r\nret_val = snd_intelmad_alloc_stream(substream);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nstream->dbg_cum_bytes = 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nintelmaddata->playback_cnt++;\r\nelse\r\nintelmaddata->capture_cnt++;\r\nsnprintf(substream->pcm->id, sizeof(substream->pcm->id),\r\n"%d", stream->stream_info.str_id);\r\npr_debug("stream id to user = %s\n",\r\nsubstream->pcm->id);\r\nret_val = snd_intelmad_init_stream(substream);\r\nif (ret_val)\r\nreturn ret_val;\r\nsubstream->runtime->hw.info = SNDRV_PCM_INFO_BLOCK_TRANSFER;\r\nreturn ret_val;\r\n}\r\nstatic int snd_intelmad_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint ret_val;\r\npr_debug("snd_intelmad_hw_params called\n");\r\nret_val = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nmemset(substream->runtime->dma_area, 0,\r\nparams_buffer_bytes(hw_params));\r\nreturn ret_val;\r\n}\r\nstatic int snd_intelmad_hw_free(struct snd_pcm_substream *substream)\r\n{\r\npr_debug("snd_intelmad_hw_free called\n");\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic snd_pcm_uframes_t snd_intelmad_pcm_pointer\r\n(struct snd_pcm_substream *substream)\r\n{\r\nstruct mad_stream_pvt *stream;\r\nstruct snd_intelmad *intelmaddata;\r\nint ret_val;\r\nWARN_ON(!substream);\r\nintelmaddata = snd_pcm_substream_chip(substream);\r\nstream = substream->runtime->private_data;\r\nif (stream->stream_status == INIT)\r\nreturn 0;\r\nret_val = intelmaddata->sstdrv_ops->pcm_control->device_control(\r\nSST_SND_BUFFER_POINTER, &stream->stream_info);\r\nif (ret_val) {\r\npr_err("error code = 0x%x\n", ret_val);\r\nreturn ret_val;\r\n}\r\npr_debug("samples reported out 0x%llx\n",\r\nstream->stream_info.buffer_ptr);\r\npr_debug("Frame bits:: %d period_count :: %d\n",\r\n(int)substream->runtime->frame_bits,\r\n(int)substream->runtime->period_size);\r\nreturn stream->stream_info.buffer_ptr;\r\n}\r\nstatic int snd_intelmad_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_intelmad *intelmaddata;\r\nstruct mad_stream_pvt *stream;\r\nint ret_val = 0, str_id;\r\nWARN_ON(!substream);\r\nstream = substream->runtime->private_data;\r\nstr_id = stream->stream_info.str_id;\r\npr_debug("sst: snd_intelmad_close called for %d\n", str_id);\r\nintelmaddata = snd_pcm_substream_chip(substream);\r\npr_debug("str id = %d\n", stream->stream_info.str_id);\r\nif (stream->stream_info.str_id) {\r\nret_val = intelmaddata->sstdrv_ops->pcm_control->close(str_id);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nintelmaddata->playback_cnt--;\r\nelse\r\nintelmaddata->capture_cnt--;\r\n}\r\npr_debug("snd_intelmad_close : pb cnt = %d cap cnt = %d\n",\r\nintelmaddata->playback_cnt, intelmaddata->capture_cnt);\r\nkfree(substream->runtime->private_data);\r\nreturn ret_val;\r\n}\r\nstatic int snd_intelmad_open(struct snd_pcm_substream *substream,\r\nenum snd_sst_audio_device_type type)\r\n{\r\nstruct snd_intelmad *intelmaddata;\r\nstruct snd_pcm_runtime *runtime;\r\nstruct mad_stream_pvt *stream;\r\nWARN_ON(!substream);\r\npr_debug("snd_intelmad_open called\n");\r\nintelmaddata = snd_pcm_substream_chip(substream);\r\nruntime = substream->runtime;\r\nruntime->hw = snd_intelmad_stream;\r\nif (intelmaddata->cpu_id == CPU_CHIP_LINCROFT) {\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nruntime->hw.formats = (SNDRV_PCM_FMTBIT_S16 |\r\nSNDRV_PCM_FMTBIT_U16);\r\nruntime->hw.channels_max = 1;\r\n}\r\n}\r\nif (intelmaddata->cpu_id == CPU_CHIP_PENWELL) {\r\nruntime->hw = snd_intelmad_stream;\r\nruntime->hw.rates = SNDRV_PCM_RATE_48000;\r\nruntime->hw.rate_min = MAX_RATE;\r\nruntime->hw.formats = (SNDRV_PCM_FMTBIT_S24 |\r\nSNDRV_PCM_FMTBIT_U24);\r\nif (intelmaddata->sstdrv_ops->scard_ops->input_dev_id == AMIC)\r\nruntime->hw.channels_max = MAX_CHANNEL_AMIC;\r\nelse\r\nruntime->hw.channels_max = MAX_CHANNEL_DMIC;\r\n}\r\nstream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (!stream)\r\nreturn -ENOMEM;\r\nstream->stream_info.str_id = 0;\r\nstream->device = type;\r\nstream->stream_status = INIT;\r\nruntime->private_data = stream;\r\nreturn snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\n}\r\nstatic int snd_intelmad_headset_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_intelmad_open(substream, SND_SST_DEVICE_HEADSET);\r\n}\r\nstatic int snd_intelmad_ihf_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_intelmad_open(substream, SND_SST_DEVICE_IHF);\r\n}\r\nstatic int snd_intelmad_vibra_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_intelmad_open(substream, SND_SST_DEVICE_VIBRA);\r\n}\r\nstatic int snd_intelmad_haptic_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_intelmad_open(substream, SND_SST_DEVICE_HAPTIC);\r\n}\r\nint intelmad_get_mic_bias(void)\r\n{\r\nstruct snd_pmic_ops *pmic_ops;\r\nif (!intelmad_drv || !intelmad_drv->sstdrv_ops)\r\nreturn -ENODEV;\r\npmic_ops = intelmad_drv->sstdrv_ops->scard_ops;\r\nif (pmic_ops && pmic_ops->pmic_get_mic_bias)\r\nreturn pmic_ops->pmic_get_mic_bias(intelmad_drv);\r\nelse\r\nreturn -ENODEV;\r\n}\r\nint intelmad_set_headset_state(int state)\r\n{\r\nstruct snd_pmic_ops *pmic_ops;\r\nif (!intelmad_drv || !intelmad_drv->sstdrv_ops)\r\nreturn -ENODEV;\r\npmic_ops = intelmad_drv->sstdrv_ops->scard_ops;\r\nif (pmic_ops && pmic_ops->pmic_set_headset_state)\r\nreturn pmic_ops->pmic_set_headset_state(state);\r\nelse\r\nreturn -ENODEV;\r\n}\r\nvoid sst_process_mad_jack_detection(struct work_struct *work)\r\n{\r\nu8 interrupt_status;\r\nstruct mad_jack_msg_wq *mad_jack_detect =\r\ncontainer_of(work, struct mad_jack_msg_wq, wq);\r\nstruct snd_intelmad *intelmaddata =\r\nmad_jack_detect->intelmaddata;\r\nif (!intelmaddata)\r\nreturn;\r\ninterrupt_status = mad_jack_detect->intsts;\r\nif (intelmaddata->sstdrv_ops && intelmaddata->sstdrv_ops->scard_ops\r\n&& intelmaddata->sstdrv_ops->scard_ops->pmic_irq_cb) {\r\nintelmaddata->sstdrv_ops->scard_ops->pmic_irq_cb(\r\n(void *)intelmaddata, interrupt_status);\r\nintelmaddata->sstdrv_ops->scard_ops->pmic_jack_enable();\r\n}\r\nkfree(mad_jack_detect);\r\n}\r\nstatic irqreturn_t snd_intelmad_intr_handler(int irq, void *dev)\r\n{\r\nstruct snd_intelmad *intelmaddata =\r\n(struct snd_intelmad *)dev;\r\nu8 interrupt_status;\r\nstruct mad_jack_msg_wq *mad_jack_msg;\r\nmemcpy_fromio(&interrupt_status,\r\n((void *)(intelmaddata->int_base)),\r\nsizeof(u8));\r\nmad_jack_msg = kzalloc(sizeof(*mad_jack_msg), GFP_ATOMIC);\r\nmad_jack_msg->intsts = interrupt_status;\r\nmad_jack_msg->intelmaddata = intelmaddata;\r\nINIT_WORK(&mad_jack_msg->wq, sst_process_mad_jack_detection);\r\nqueue_work(intelmaddata->mad_jack_wq, &mad_jack_msg->wq);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid sst_mad_send_jack_report(struct snd_jack *jack,\r\nint buttonpressevent , int status)\r\n{\r\nif (!jack) {\r\npr_debug("MAD error jack empty\n");\r\n} else {\r\nsnd_jack_report(jack, status);\r\nif (buttonpressevent)\r\nsnd_jack_report(jack, 0);\r\npr_debug("MAD sending jack report Done !!!\n");\r\n}\r\n}\r\nstatic int __devinit snd_intelmad_register_irq(\r\nstruct snd_intelmad *intelmaddata, unsigned int regbase,\r\nunsigned int regsize)\r\n{\r\nint ret_val;\r\nchar *drv_name;\r\npr_debug("irq reg regbase 0x%x, regsize 0x%x\n",\r\nregbase, regsize);\r\nintelmaddata->int_base = ioremap_nocache(regbase, regsize);\r\nif (!intelmaddata->int_base)\r\npr_err("Mapping of cache failed\n");\r\npr_debug("irq = 0x%x\n", intelmaddata->irq);\r\nif (intelmaddata->cpu_id == CPU_CHIP_PENWELL)\r\ndrv_name = DRIVER_NAME_MFLD;\r\nelse\r\ndrv_name = DRIVER_NAME_MRST;\r\nret_val = request_irq(intelmaddata->irq,\r\nsnd_intelmad_intr_handler,\r\nIRQF_SHARED, drv_name,\r\nintelmaddata);\r\nif (ret_val)\r\npr_err("cannot register IRQ\n");\r\nreturn ret_val;\r\n}\r\nstatic int __devinit snd_intelmad_sst_register(\r\nstruct snd_intelmad *intelmaddata)\r\n{\r\nint ret_val = 0;\r\nstruct snd_pmic_ops *intelmad_vendor_ops[MAX_VENDORS] = {\r\n&snd_pmic_ops_fs,\r\n&snd_pmic_ops_mx,\r\n&snd_pmic_ops_nc,\r\n&snd_msic_ops\r\n};\r\nstruct sc_reg_access vendor_addr = {0x00, 0x00, 0x00};\r\nif (intelmaddata->cpu_id == CPU_CHIP_LINCROFT) {\r\nret_val = sst_sc_reg_access(&vendor_addr, PMIC_READ, 1);\r\nif (ret_val)\r\nreturn ret_val;\r\nsst_card_vendor_id = (vendor_addr.value & (MASK2|MASK1|MASK0));\r\npr_debug("original n extrated vendor id = 0x%x %d\n",\r\nvendor_addr.value, sst_card_vendor_id);\r\nif (sst_card_vendor_id < 0 || sst_card_vendor_id > 2) {\r\npr_err("vendor card not supported!!\n");\r\nreturn -EIO;\r\n}\r\n} else\r\nsst_card_vendor_id = 0x3;\r\nintelmaddata->sstdrv_ops->module_name = SST_CARD_NAMES;\r\nintelmaddata->sstdrv_ops->vendor_id = sst_card_vendor_id;\r\nBUG_ON(!intelmad_vendor_ops[sst_card_vendor_id]);\r\nintelmaddata->sstdrv_ops->scard_ops =\r\nintelmad_vendor_ops[sst_card_vendor_id];\r\nif (intelmaddata->cpu_id == CPU_CHIP_PENWELL) {\r\nintelmaddata->sstdrv_ops->scard_ops->pb_on = 0;\r\nintelmaddata->sstdrv_ops->scard_ops->cap_on = 0;\r\nintelmaddata->sstdrv_ops->scard_ops->input_dev_id = DMIC;\r\nintelmaddata->sstdrv_ops->scard_ops->output_dev_id =\r\nSTEREO_HEADPHONE;\r\nintelmaddata->sstdrv_ops->scard_ops->lineout_dev_id = NONE;\r\n}\r\nret_val = register_sst_card(intelmaddata->sstdrv_ops);\r\nif (ret_val) {\r\npr_err("sst card registration failed\n");\r\nreturn ret_val;\r\n}\r\nsst_card_vendor_id = intelmaddata->sstdrv_ops->vendor_id;\r\nintelmaddata->pmic_status = PMIC_UNINIT;\r\nreturn ret_val;\r\n}\r\nstatic void snd_intelmad_page_free(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic int __devinit snd_intelmad_pcm_new(struct snd_card *card,\r\nstruct snd_intelmad *intelmaddata,\r\nunsigned int pb, unsigned int cap, unsigned int index)\r\n{\r\nint ret_val = 0;\r\nstruct snd_pcm *pcm;\r\nchar name[32] = INTEL_MAD;\r\nstruct snd_pcm_ops *pb_ops = NULL, *cap_ops = NULL;\r\npr_debug("called for pb %d, cp %d, idx %d\n", pb, cap, index);\r\nret_val = snd_pcm_new(card, name, index, pb, cap, &pcm);\r\nif (ret_val)\r\nreturn ret_val;\r\nswitch (index) {\r\ncase 0:\r\npb_ops = &snd_intelmad_headset_ops;\r\ncap_ops = &snd_intelmad_capture_ops;\r\nbreak;\r\ncase 1:\r\npb_ops = &snd_intelmad_ihf_ops;\r\ncap_ops = &snd_intelmad_capture_ops;\r\nbreak;\r\ncase 2:\r\npb_ops = &snd_intelmad_vibra_ops;\r\ncap_ops = &snd_intelmad_capture_ops;\r\nbreak;\r\ncase 3:\r\npb_ops = &snd_intelmad_haptic_ops;\r\ncap_ops = &snd_intelmad_capture_ops;\r\nbreak;\r\n}\r\nif (pb)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, pb_ops);\r\nif (cap)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, cap_ops);\r\npcm->private_data = intelmaddata;\r\npcm->private_free = snd_intelmad_page_free;\r\npcm->info_flags = 0;\r\nstrncpy(pcm->name, card->shortname, strlen(card->shortname));\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\nMIN_BUFFER, MAX_BUFFER);\r\nreturn ret_val;\r\n}\r\nstatic int __devinit snd_intelmad_pcm(struct snd_card *card,\r\nstruct snd_intelmad *intelmaddata)\r\n{\r\nint ret_val = 0;\r\nWARN_ON(!card);\r\nWARN_ON(!intelmaddata);\r\npr_debug("snd_intelmad_pcm called\n");\r\nret_val = snd_intelmad_pcm_new(card, intelmaddata, 1, 1, 0);\r\nif (intelmaddata->cpu_id == CPU_CHIP_LINCROFT)\r\nreturn ret_val;\r\nret_val = snd_intelmad_pcm_new(card, intelmaddata, 1, 0, 1);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = snd_intelmad_pcm_new(card, intelmaddata, 1, 0, 2);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn snd_intelmad_pcm_new(card, intelmaddata, 1, 0, 3);\r\n}\r\nstatic int snd_intelmad_jack(struct snd_intelmad *intelmaddata)\r\n{\r\nstruct snd_jack *jack;\r\nint retval;\r\npr_debug("snd_intelmad_jack called\n");\r\njack = &intelmaddata->jack[0].jack;\r\nsnd_jack_set_key(jack, SND_JACK_BTN_0, KEY_PHONE);\r\nretval = snd_jack_new(intelmaddata->card, "Intel(R) MID Audio Jack",\r\nSND_JACK_HEADPHONE | SND_JACK_HEADSET |\r\nSW_JACK_PHYSICAL_INSERT | SND_JACK_BTN_0\r\n| SND_JACK_BTN_1, &jack);\r\npr_debug("snd_intelmad_jack called\n");\r\nif (retval < 0)\r\nreturn retval;\r\nsnd_jack_report(jack, 0);\r\njack->private_data = jack;\r\nintelmaddata->jack[0].jack = *jack;\r\nreturn retval;\r\n}\r\nstatic int __devinit snd_intelmad_mixer(struct snd_intelmad *intelmaddata)\r\n{\r\nstruct snd_card *card;\r\nunsigned int idx;\r\nint ret_val = 0, max_controls = 0;\r\nchar *mixername = "IntelMAD Controls";\r\nstruct snd_kcontrol_new *controls;\r\nWARN_ON(!intelmaddata);\r\ncard = intelmaddata->card;\r\nstrncpy(card->mixername, mixername, sizeof(card->mixername)-1);\r\nif (intelmaddata->cpu_id == CPU_CHIP_PENWELL) {\r\nmax_controls = MAX_CTRL_MFLD;\r\ncontrols = snd_intelmad_controls_mfld;\r\n} else {\r\nmax_controls = MAX_CTRL_MRST;\r\ncontrols = snd_intelmad_controls_mrst;\r\n}\r\nfor (idx = 0; idx < max_controls; idx++) {\r\nret_val = snd_ctl_add(card,\r\nsnd_ctl_new1(&controls[idx],\r\nintelmaddata));\r\npr_debug("mixer[idx]=%d added\n", idx);\r\nif (ret_val) {\r\npr_err("in adding of control index = %d\n", idx);\r\nbreak;\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int snd_intelmad_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_intelmad *intelmaddata;\r\nWARN_ON(!device);\r\nintelmaddata = device->device_data;\r\npr_debug("snd_intelmad_dev_free called\n");\r\nunregister_sst_card(intelmaddata->sstdrv_ops);\r\ndestroy_workqueue(intelmaddata->mad_jack_wq);\r\ndevice->device_data = NULL;\r\nkfree(intelmaddata->sstdrv_ops);\r\nkfree(intelmaddata);\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_intelmad_create(\r\nstruct snd_intelmad *intelmaddata,\r\nstruct snd_card *card)\r\n{\r\nint ret_val;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_intelmad_dev_free,\r\n};\r\nWARN_ON(!intelmaddata);\r\nWARN_ON(!card);\r\nret_val = snd_device_new(card, SNDRV_DEV_LOWLEVEL, intelmaddata, &ops);\r\nreturn ret_val;\r\n}\r\nint __devinit snd_intelmad_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card;\r\nint ret_val;\r\nstruct snd_intelmad *intelmaddata;\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\nstruct snd_intelmad_probe_info *info = (void *)id->driver_data;\r\npr_debug("probe for %s cpu_id %d\n", pdev->name, info->cpu_id);\r\npr_debug("rq_chache %x of size %x\n", info->irq_cache, info->size);\r\nif (!strcmp(pdev->name, DRIVER_NAME_MRST))\r\npr_debug("detected MRST\n");\r\nelse if (!strcmp(pdev->name, DRIVER_NAME_MFLD))\r\npr_debug("detected MFLD\n");\r\nelse {\r\npr_err("detected unknown device abort!!\n");\r\nreturn -EIO;\r\n}\r\nif ((info->cpu_id < CPU_CHIP_LINCROFT) ||\r\n(info->cpu_id > CPU_CHIP_PENWELL)) {\r\npr_err("detected unknown cpu_id abort!!\n");\r\nreturn -EIO;\r\n}\r\nintelmaddata = kzalloc(sizeof(*intelmaddata), GFP_KERNEL);\r\nif (!intelmaddata) {\r\npr_debug("mem alloctn fail\n");\r\nreturn -ENOMEM;\r\n}\r\nintelmad_drv = intelmaddata;\r\nintelmaddata->sstdrv_ops = kzalloc(sizeof(struct intel_sst_card_ops),\r\nGFP_KERNEL);\r\nif (!intelmaddata->sstdrv_ops) {\r\npr_err("mem allocation for ops fail\n");\r\nkfree(intelmaddata);\r\nreturn -ENOMEM;\r\n}\r\nintelmaddata->cpu_id = info->cpu_id;\r\nret_val = snd_card_create(card_index, card_id, THIS_MODULE, 0, &card);\r\nif (ret_val) {\r\npr_err("snd_card_create fail\n");\r\ngoto free_allocs;\r\n}\r\nintelmaddata->pdev = pdev;\r\nintelmaddata->irq = platform_get_irq(pdev, 0);\r\nplatform_set_drvdata(pdev, intelmaddata);\r\nintelmaddata->card = card;\r\nintelmaddata->card_id = card_id;\r\nintelmaddata->card_index = card_index;\r\nintelmaddata->master_mute = UNMUTE;\r\nintelmaddata->playback_cnt = intelmaddata->capture_cnt = 0;\r\nstrncpy(card->driver, INTEL_MAD, strlen(INTEL_MAD));\r\nstrncpy(card->shortname, INTEL_MAD, strlen(INTEL_MAD));\r\nintelmaddata->sstdrv_ops->module_name = SST_CARD_NAMES;\r\nret_val = snd_intelmad_sst_register(intelmaddata);\r\nif (ret_val) {\r\npr_err("snd_intelmad_sst_register failed\n");\r\ngoto set_null_data;\r\n}\r\nintelmaddata->pmic_status = PMIC_INIT;\r\nret_val = snd_intelmad_pcm(card, intelmaddata);\r\nif (ret_val) {\r\npr_err("snd_intelmad_pcm failed\n");\r\ngoto free_sst;\r\n}\r\nret_val = snd_intelmad_mixer(intelmaddata);\r\nif (ret_val) {\r\npr_err("snd_intelmad_mixer failed\n");\r\ngoto free_card;\r\n}\r\nret_val = snd_intelmad_jack(intelmaddata);\r\nif (ret_val) {\r\npr_err("snd_intelmad_jack failed\n");\r\ngoto free_card;\r\n}\r\nintelmaddata->adc_address = mid_initialize_adc();\r\nINIT_WORK(&intelmaddata->mad_jack_msg.wq,\r\nsst_process_mad_jack_detection);\r\nintelmaddata->mad_jack_wq = create_workqueue("sst_mad_jack_wq");\r\nif (!intelmaddata->mad_jack_wq)\r\ngoto free_card;\r\nret_val = snd_intelmad_register_irq(intelmaddata,\r\ninfo->irq_cache, info->size);\r\nif (ret_val) {\r\npr_err("snd_intelmad_register_irq fail\n");\r\ngoto free_mad_jack_wq;\r\n}\r\nret_val = snd_intelmad_create(intelmaddata, card);\r\nif (ret_val) {\r\npr_err("snd_intelmad_create failed\n");\r\ngoto set_pvt_data;\r\n}\r\ncard->private_data = &intelmaddata;\r\nsnd_card_set_dev(card, &pdev->dev);\r\nret_val = snd_card_register(card);\r\nif (ret_val) {\r\npr_err("snd_card_register failed\n");\r\ngoto set_pvt_data;\r\n}\r\nif (pdev->dev.platform_data) {\r\nint gpio_amp = *(int *)pdev->dev.platform_data;\r\nif (gpio_request_one(gpio_amp, GPIOF_OUT_INIT_LOW, "amp power"))\r\ngpio_amp = 0;\r\nintelmaddata->sstdrv_ops->scard_ops->gpio_amp = gpio_amp;\r\n}\r\npr_debug("snd_intelmad_probe complete\n");\r\nreturn ret_val;\r\nset_pvt_data:\r\ncard->private_data = NULL;\r\nfree_mad_jack_wq:\r\ndestroy_workqueue(intelmaddata->mad_jack_wq);\r\nfree_card:\r\nsnd_card_free(intelmaddata->card);\r\nfree_sst:\r\nunregister_sst_card(intelmaddata->sstdrv_ops);\r\nset_null_data:\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_allocs:\r\npr_err("probe failed\n");\r\nsnd_card_free(card);\r\nkfree(intelmaddata->sstdrv_ops);\r\nkfree(intelmaddata);\r\nreturn ret_val;\r\n}\r\nstatic int snd_intelmad_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_intelmad *intelmaddata = platform_get_drvdata(pdev);\r\nif (intelmaddata) {\r\nif (intelmaddata->sstdrv_ops->scard_ops->gpio_amp)\r\ngpio_free(intelmaddata->sstdrv_ops->scard_ops->gpio_amp);\r\nfree_irq(intelmaddata->irq, intelmaddata);\r\nsnd_card_free(intelmaddata->card);\r\n}\r\nintelmad_drv = NULL;\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_intelmad_init(void)\r\n{\r\npr_debug("mad_init called\n");\r\nreturn platform_driver_register(&snd_intelmad_driver);\r\n}\r\nstatic void __exit alsa_card_intelmad_exit(void)\r\n{\r\npr_debug("mad_exit called\n");\r\nreturn platform_driver_unregister(&snd_intelmad_driver);\r\n}
