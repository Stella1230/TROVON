static irqreturn_t ibmtr_interrupt(int irq, void *dev_id) {\r\nibmtr_dev_t *info = dev_id;\r\nstruct net_device *dev = info->dev;\r\nreturn tok_interrupt(irq, dev);\r\n}\r\nstatic int __devinit ibmtr_attach(struct pcmcia_device *link)\r\n{\r\nibmtr_dev_t *info;\r\nstruct net_device *dev;\r\ndev_dbg(&link->dev, "ibmtr_attach()\n");\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) return -ENOMEM;\r\ndev = alloc_trdev(sizeof(struct tok_info));\r\nif (!dev) {\r\nkfree(info);\r\nreturn -ENOMEM;\r\n}\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\ninfo->ti = netdev_priv(dev);\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nlink->resource[0]->end = 4;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\nlink->config_regs = PRESENT_OPTION;\r\ninfo->dev = dev;\r\nreturn ibmtr_config(link);\r\n}\r\nstatic void ibmtr_detach(struct pcmcia_device *link)\r\n{\r\nstruct ibmtr_dev_t *info = link->priv;\r\nstruct net_device *dev = info->dev;\r\nstruct tok_info *ti = netdev_priv(dev);\r\ndev_dbg(&link->dev, "ibmtr_detach\n");\r\nti->sram_phys |= 1;\r\nunregister_netdev(dev);\r\ndel_timer_sync(&(ti->tr_timer));\r\nibmtr_release(link);\r\nfree_netdev(dev);\r\nkfree(info);\r\n}\r\nstatic int __devinit ibmtr_config(struct pcmcia_device *link)\r\n{\r\nibmtr_dev_t *info = link->priv;\r\nstruct net_device *dev = info->dev;\r\nstruct tok_info *ti = netdev_priv(dev);\r\nint i, ret;\r\ndev_dbg(&link->dev, "ibmtr_config\n");\r\nlink->io_lines = 16;\r\nlink->config_index = 0x61;\r\nlink->resource[0]->start = 0xA20;\r\ni = pcmcia_request_io(link);\r\nif (i != 0) {\r\nlink->resource[0]->start = 0xA24;\r\nret = pcmcia_request_io(link);\r\nif (ret)\r\ngoto failed;\r\n}\r\ndev->base_addr = link->resource[0]->start;\r\nret = pcmcia_request_exclusive_irq(link, ibmtr_interrupt);\r\nif (ret)\r\ngoto failed;\r\ndev->irq = link->irq;\r\nti->irq = link->irq;\r\nti->global_int_enable=GLOBAL_INT_ENABLE+((dev->irq==9) ? 2 : dev->irq);\r\nlink->resource[2]->flags |= WIN_DATA_WIDTH_16|WIN_MEMORY_TYPE_CM|WIN_ENABLE;\r\nlink->resource[2]->flags |= WIN_USE_WAIT;\r\nlink->resource[2]->start = 0;\r\nlink->resource[2]->end = 0x2000;\r\nret = pcmcia_request_window(link, link->resource[2], 250);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_map_mem_page(link, link->resource[2], mmiobase);\r\nif (ret)\r\ngoto failed;\r\nti->mmio = ioremap(link->resource[2]->start,\r\nresource_size(link->resource[2]));\r\nlink->resource[3]->flags = WIN_DATA_WIDTH_16|WIN_MEMORY_TYPE_CM|WIN_ENABLE;\r\nlink->resource[3]->flags |= WIN_USE_WAIT;\r\nlink->resource[3]->start = 0;\r\nlink->resource[3]->end = sramsize * 1024;\r\nret = pcmcia_request_window(link, link->resource[3], 250);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_map_mem_page(link, link->resource[3], srambase);\r\nif (ret)\r\ngoto failed;\r\nti->sram_base = srambase >> 12;\r\nti->sram_virt = ioremap(link->resource[3]->start,\r\nresource_size(link->resource[3]));\r\nti->sram_phys = link->resource[3]->start;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\nibmtr_hw_setup(dev, mmiobase);\r\nSET_NETDEV_DEV(dev, &link->dev);\r\ni = ibmtr_probe_card(dev);\r\nif (i != 0) {\r\npr_notice("register_netdev() failed\n");\r\ngoto failed;\r\n}\r\nnetdev_info(dev, "port %#3lx, irq %d, mmio %#5lx, sram %#5lx, hwaddr=%pM\n",\r\ndev->base_addr, dev->irq,\r\n(u_long)ti->mmio, (u_long)(ti->sram_base << 12),\r\ndev->dev_addr);\r\nreturn 0;\r\nfailed:\r\nibmtr_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void ibmtr_release(struct pcmcia_device *link)\r\n{\r\nibmtr_dev_t *info = link->priv;\r\nstruct net_device *dev = info->dev;\r\ndev_dbg(&link->dev, "ibmtr_release\n");\r\nif (link->resource[2]->end) {\r\nstruct tok_info *ti = netdev_priv(dev);\r\niounmap(ti->mmio);\r\n}\r\npcmcia_disable_device(link);\r\n}\r\nstatic int ibmtr_suspend(struct pcmcia_device *link)\r\n{\r\nibmtr_dev_t *info = link->priv;\r\nstruct net_device *dev = info->dev;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int __devinit ibmtr_resume(struct pcmcia_device *link)\r\n{\r\nibmtr_dev_t *info = link->priv;\r\nstruct net_device *dev = info->dev;\r\nif (link->open) {\r\nibmtr_probe(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ibmtr_hw_setup(struct net_device *dev, u_int mmiobase)\r\n{\r\nint i;\r\ni = (mmiobase >> 16) & 0x0F;\r\noutb(i, dev->base_addr);\r\ni = 0x10 | ((mmiobase >> 12) & 0x0E);\r\noutb(i, dev->base_addr);\r\ni = 0x26;\r\noutb(i, dev->base_addr);\r\ni = (sramsize >> 4) & 0x07;\r\ni = ((i == 4) ? 3 : i) << 2;\r\ni |= 0x30;\r\nif (ringspeed == 16)\r\ni |= 2;\r\nif (dev->base_addr == 0xA24)\r\ni |= 1;\r\noutb(i, dev->base_addr);\r\noutb(0x40, dev->base_addr);\r\n}\r\nstatic int __init init_ibmtr_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&ibmtr_cs_driver);\r\n}\r\nstatic void __exit exit_ibmtr_cs(void)\r\n{\r\npcmcia_unregister_driver(&ibmtr_cs_driver);\r\n}
