static int get_mca_info_helper(struct mca_device *mca_dev, char *page, int len)\r\n{\r\nint j;\r\nfor(j=0; j<8; j++)\r\nlen += sprintf(page+len, "%02x ",\r\nmca_dev ? mca_dev->pos[j] : 0xff);\r\nlen += sprintf(page+len, " %s\n", mca_dev ? mca_dev->name : "");\r\nreturn len;\r\n}\r\nstatic int get_mca_info(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nint i, len = 0;\r\nif(MCA_bus) {\r\nstruct mca_device *mca_dev;\r\nfor(i=0; i<MCA_MAX_SLOT_NR; i++) {\r\nmca_dev = mca_find_device_by_slot(i);\r\nlen += sprintf(page+len, "Slot %d: ", i+1);\r\nlen = get_mca_info_helper(mca_dev, page, len);\r\n}\r\nmca_dev = mca_find_device_by_slot(MCA_INTEGVIDEO);\r\nlen += sprintf(page+len, "Video : ");\r\nlen = get_mca_info_helper(mca_dev, page, len);\r\nmca_dev = mca_find_device_by_slot(MCA_INTEGSCSI);\r\nlen += sprintf(page+len, "SCSI : ");\r\nlen = get_mca_info_helper(mca_dev, page, len);\r\nmca_dev = mca_find_device_by_slot(MCA_MOTHERBOARD);\r\nlen += sprintf(page+len, "Planar: ");\r\nlen = get_mca_info_helper(mca_dev, page, len);\r\n} else {\r\n}\r\nif (len <= off+count) *eof = 1;\r\n*start = page + off;\r\nlen -= off;\r\nif (len>count) len = count;\r\nif (len<0) len = 0;\r\nreturn len;\r\n}\r\nstatic int mca_default_procfn(char* buf, struct mca_device *mca_dev)\r\n{\r\nint len = 0, i;\r\nint slot = mca_dev->slot;\r\nif(slot < MCA_MAX_SLOT_NR) {\r\nlen += sprintf(buf+len, "Slot: %d\n", slot+1);\r\n} else if(slot == MCA_INTEGSCSI) {\r\nlen += sprintf(buf+len, "Integrated SCSI Adapter\n");\r\n} else if(slot == MCA_INTEGVIDEO) {\r\nlen += sprintf(buf+len, "Integrated Video Adapter\n");\r\n} else if(slot == MCA_MOTHERBOARD) {\r\nlen += sprintf(buf+len, "Motherboard\n");\r\n}\r\nif (mca_dev->name[0]) {\r\nlen += sprintf(buf+len, "Adapter Name: %s\n",\r\nmca_dev->name);\r\n} else {\r\nlen += sprintf(buf+len, "Adapter Name: Unknown\n");\r\n}\r\nlen += sprintf(buf+len, "Id: %02x%02x\n",\r\nmca_dev->pos[1], mca_dev->pos[0]);\r\nlen += sprintf(buf+len, "Enabled: %s\nPOS: ",\r\nmca_device_status(mca_dev) == MCA_ADAPTER_NORMAL ?\r\n"Yes" : "No");\r\nfor(i=0; i<8; i++) {\r\nlen += sprintf(buf+len, "%02x ", mca_dev->pos[i]);\r\n}\r\nlen += sprintf(buf+len, "\nDriver Installed: %s",\r\nmca_device_claimed(mca_dev) ? "Yes" : "No");\r\nbuf[len++] = '\n';\r\nbuf[len] = 0;\r\nreturn len;\r\n}\r\nstatic int get_mca_machine_info(char* page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nint len = 0;\r\nlen += sprintf(page+len, "Model Id: 0x%x\n", machine_id);\r\nlen += sprintf(page+len, "Submodel Id: 0x%x\n", machine_submodel_id);\r\nlen += sprintf(page+len, "BIOS Revision: 0x%x\n", BIOS_revision);\r\nif (len <= off+count) *eof = 1;\r\n*start = page + off;\r\nlen -= off;\r\nif (len>count) len = count;\r\nif (len<0) len = 0;\r\nreturn len;\r\n}\r\nstatic int mca_read_proc(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nstruct mca_device *mca_dev = (struct mca_device *)data;\r\nint len = 0;\r\nlen = mca_default_procfn(page, mca_dev);\r\nif(mca_dev->procfn) {\r\nlen += mca_dev->procfn(page+len, mca_dev->slot,\r\nmca_dev->proc_dev);\r\n}\r\nif (len <= off+count) *eof = 1;\r\n*start = page + off;\r\nlen -= off;\r\nif (len>count) len = count;\r\nif (len<0) len = 0;\r\nreturn len;\r\n}\r\nvoid __init mca_do_proc_init(void)\r\n{\r\nint i;\r\nstruct proc_dir_entry *proc_mca;\r\nstruct proc_dir_entry* node = NULL;\r\nstruct mca_device *mca_dev;\r\nproc_mca = proc_mkdir("mca", NULL);\r\ncreate_proc_read_entry("pos",0,proc_mca,get_mca_info,NULL);\r\ncreate_proc_read_entry("machine",0,proc_mca,get_mca_machine_info,NULL);\r\nfor(i = 0; i < MCA_NUMADAPTERS; i++) {\r\nenum MCA_AdapterStatus status;\r\nmca_dev = mca_find_device_by_slot(i);\r\nif(!mca_dev)\r\ncontinue;\r\nmca_dev->procfn = NULL;\r\nif(i < MCA_MAX_SLOT_NR) sprintf(mca_dev->procname,"slot%d", i+1);\r\nelse if(i == MCA_INTEGVIDEO) sprintf(mca_dev->procname,"video");\r\nelse if(i == MCA_INTEGSCSI) sprintf(mca_dev->procname,"scsi");\r\nelse if(i == MCA_MOTHERBOARD) sprintf(mca_dev->procname,"planar");\r\nstatus = mca_device_status(mca_dev);\r\nif (status != MCA_ADAPTER_NORMAL &&\r\nstatus != MCA_ADAPTER_DISABLED)\r\ncontinue;\r\nnode = create_proc_read_entry(mca_dev->procname, 0, proc_mca,\r\nmca_read_proc, (void *)mca_dev);\r\nif(node == NULL) {\r\nprintk("Failed to allocate memory for MCA proc-entries!");\r\nreturn;\r\n}\r\n}\r\n}\r\nvoid mca_set_adapter_procfn(int slot, MCA_ProcFn procfn, void* proc_dev)\r\n{\r\nstruct mca_device *mca_dev = mca_find_device_by_slot(slot);\r\nif(!mca_dev)\r\nreturn;\r\nmca_dev->procfn = procfn;\r\nmca_dev->proc_dev = proc_dev;\r\n}
