static int\r\nsnd_emux_hwdep_load_patch(struct snd_emux *emu, void __user *arg)\r\n{\r\nint err;\r\nstruct soundfont_patch_info patch;\r\nif (copy_from_user(&patch, arg, sizeof(patch)))\r\nreturn -EFAULT;\r\nif (patch.type >= SNDRV_SFNT_LOAD_INFO &&\r\npatch.type <= SNDRV_SFNT_PROBE_DATA) {\r\nerr = snd_soundfont_load(emu->sflist, arg, patch.len + sizeof(patch), TMP_CLIENT_ID);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nif (emu->ops.load_fx)\r\nreturn emu->ops.load_fx(emu, patch.type, patch.optarg, arg, patch.len + sizeof(patch));\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_emux_hwdep_misc_mode(struct snd_emux *emu, void __user *arg)\r\n{\r\nstruct snd_emux_misc_mode info;\r\nint i;\r\nif (copy_from_user(&info, arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.mode < 0 || info.mode >= EMUX_MD_END)\r\nreturn -EINVAL;\r\nif (info.port < 0) {\r\nfor (i = 0; i < emu->num_ports; i++)\r\nemu->portptrs[i]->ctrls[info.mode] = info.value;\r\n} else {\r\nif (info.port < emu->num_ports)\r\nemu->portptrs[info.port]->ctrls[info.mode] = info.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_emux_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_emux *emu = hw->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_EMUX_IOCTL_VERSION:\r\nreturn put_user(SNDRV_EMUX_VERSION, (unsigned int __user *)arg);\r\ncase SNDRV_EMUX_IOCTL_LOAD_PATCH:\r\nreturn snd_emux_hwdep_load_patch(emu, (void __user *)arg);\r\ncase SNDRV_EMUX_IOCTL_RESET_SAMPLES:\r\nsnd_soundfont_remove_samples(emu->sflist);\r\nbreak;\r\ncase SNDRV_EMUX_IOCTL_REMOVE_LAST_SAMPLES:\r\nsnd_soundfont_remove_unlocked(emu->sflist);\r\nbreak;\r\ncase SNDRV_EMUX_IOCTL_MEM_AVAIL:\r\nif (emu->memhdr) {\r\nint size = snd_util_mem_avail(emu->memhdr);\r\nreturn put_user(size, (unsigned int __user *)arg);\r\n}\r\nbreak;\r\ncase SNDRV_EMUX_IOCTL_MISC_MODE:\r\nreturn snd_emux_hwdep_misc_mode(emu, (void __user *)arg);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nsnd_emux_init_hwdep(struct snd_emux *emu)\r\n{\r\nstruct snd_hwdep *hw;\r\nint err;\r\nif ((err = snd_hwdep_new(emu->card, SNDRV_EMUX_HWDEP_NAME, emu->hwdep_idx, &hw)) < 0)\r\nreturn err;\r\nemu->hwdep = hw;\r\nstrcpy(hw->name, SNDRV_EMUX_HWDEP_NAME);\r\nhw->iface = SNDRV_HWDEP_IFACE_EMUX_WAVETABLE;\r\nhw->ops.ioctl = snd_emux_hwdep_ioctl;\r\nhw->ops.ioctl_compat = snd_emux_hwdep_ioctl;\r\nhw->exclusive = 1;\r\nhw->private_data = emu;\r\nif ((err = snd_card_register(emu->card)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_emux_delete_hwdep(struct snd_emux *emu)\r\n{\r\nif (emu->hwdep) {\r\nsnd_device_free(emu->card, emu->hwdep);\r\nemu->hwdep = NULL;\r\n}\r\n}
