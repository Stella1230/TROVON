int ad7606_reset(struct ad7606_state *st)\r\n{\r\nif (st->have_reset) {\r\ngpio_set_value(st->pdata->gpio_reset, 1);\r\nndelay(100);\r\ngpio_set_value(st->pdata->gpio_reset, 0);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int ad7606_scan_direct(struct iio_dev *indio_dev, unsigned ch)\r\n{\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nint ret;\r\nst->done = false;\r\ngpio_set_value(st->pdata->gpio_convst, 1);\r\nret = wait_event_interruptible(st->wq_data_avail, st->done);\r\nif (ret)\r\ngoto error_ret;\r\nif (st->have_frstdata) {\r\nret = st->bops->read_block(st->dev, 1, st->data);\r\nif (ret)\r\ngoto error_ret;\r\nif (!gpio_get_value(st->pdata->gpio_frstdata)) {\r\nad7606_reset(st);\r\nret = -EIO;\r\ngoto error_ret;\r\n}\r\nret = st->bops->read_block(st->dev,\r\nst->chip_info->num_channels - 1, &st->data[1]);\r\nif (ret)\r\ngoto error_ret;\r\n} else {\r\nret = st->bops->read_block(st->dev,\r\nst->chip_info->num_channels, st->data);\r\nif (ret)\r\ngoto error_ret;\r\n}\r\nret = st->data[ch];\r\nerror_ret:\r\ngpio_set_value(st->pdata->gpio_convst, 0);\r\nreturn ret;\r\n}\r\nstatic int ad7606_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nint ret;\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nunsigned int scale_uv;\r\nswitch (m) {\r\ncase 0:\r\nmutex_lock(&indio_dev->mlock);\r\nif (iio_ring_enabled(indio_dev))\r\nret = ad7606_scan_from_ring(indio_dev, chan->address);\r\nelse\r\nret = ad7606_scan_direct(indio_dev, chan->address);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (short) ret;\r\nreturn IIO_VAL_INT;\r\ncase (1 << IIO_CHAN_INFO_SCALE_SHARED):\r\nscale_uv = (st->range * 1000 * 2)\r\n>> st->chip_info->channels[0].scan_type.realbits;\r\n*val = scale_uv / 1000;\r\n*val2 = (scale_uv % 1000) * 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ad7606_show_range(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%u\n", st->range);\r\n}\r\nstatic ssize_t ad7606_store_range(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nunsigned long lval;\r\nif (strict_strtoul(buf, 10, &lval))\r\nreturn -EINVAL;\r\nif (!(lval == 5000 || lval == 10000)) {\r\ndev_err(dev, "range is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&indio_dev->mlock);\r\ngpio_set_value(st->pdata->gpio_range, lval == 10000);\r\nst->range = lval;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn count;\r\n}\r\nstatic ssize_t ad7606_show_oversampling_ratio(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%u\n", st->oversampling);\r\n}\r\nstatic int ad7606_oversampling_get_index(unsigned val)\r\n{\r\nunsigned char supported[] = {0, 2, 4, 8, 16, 32, 64};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(supported); i++)\r\nif (val == supported[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ad7606_store_oversampling_ratio(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nunsigned long lval;\r\nint ret;\r\nif (strict_strtoul(buf, 10, &lval))\r\nreturn -EINVAL;\r\nret = ad7606_oversampling_get_index(lval);\r\nif (ret < 0) {\r\ndev_err(dev, "oversampling %lu is not supported\n", lval);\r\nreturn ret;\r\n}\r\nmutex_lock(&indio_dev->mlock);\r\ngpio_set_value(st->pdata->gpio_os0, (ret >> 0) & 1);\r\ngpio_set_value(st->pdata->gpio_os1, (ret >> 1) & 1);\r\ngpio_set_value(st->pdata->gpio_os1, (ret >> 2) & 1);\r\nst->oversampling = lval;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn count;\r\n}\r\nstatic mode_t ad7606_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nmode_t mode = attr->mode;\r\nif (!st->have_os &&\r\n(attr == &iio_dev_attr_oversampling_ratio.dev_attr.attr ||\r\nattr ==\r\n&iio_const_attr_oversampling_ratio_available.dev_attr.attr))\r\nmode = 0;\r\nelse if (!st->have_range &&\r\n(attr == &iio_dev_attr_range.dev_attr.attr ||\r\nattr == &iio_const_attr_range_available.dev_attr.attr))\r\nmode = 0;\r\nreturn mode;\r\n}\r\nstatic int ad7606_request_gpios(struct ad7606_state *st)\r\n{\r\nstruct gpio gpio_array[3] = {\r\n[0] = {\r\n.gpio = st->pdata->gpio_os0,\r\n.flags = GPIOF_DIR_OUT | ((st->oversampling & 1) ?\r\nGPIOF_INIT_HIGH : GPIOF_INIT_LOW),\r\n.label = "AD7606_OS0",\r\n},\r\n[1] = {\r\n.gpio = st->pdata->gpio_os1,\r\n.flags = GPIOF_DIR_OUT | ((st->oversampling & 2) ?\r\nGPIOF_INIT_HIGH : GPIOF_INIT_LOW),\r\n.label = "AD7606_OS1",\r\n},\r\n[2] = {\r\n.gpio = st->pdata->gpio_os2,\r\n.flags = GPIOF_DIR_OUT | ((st->oversampling & 4) ?\r\nGPIOF_INIT_HIGH : GPIOF_INIT_LOW),\r\n.label = "AD7606_OS2",\r\n},\r\n};\r\nint ret;\r\nret = gpio_request_one(st->pdata->gpio_convst, GPIOF_OUT_INIT_LOW,\r\n"AD7606_CONVST");\r\nif (ret) {\r\ndev_err(st->dev, "failed to request GPIO CONVST\n");\r\nreturn ret;\r\n}\r\nret = gpio_request_array(gpio_array, ARRAY_SIZE(gpio_array));\r\nif (!ret) {\r\nst->have_os = true;\r\n}\r\nret = gpio_request_one(st->pdata->gpio_reset, GPIOF_OUT_INIT_LOW,\r\n"AD7606_RESET");\r\nif (!ret)\r\nst->have_reset = true;\r\nret = gpio_request_one(st->pdata->gpio_range, GPIOF_DIR_OUT |\r\n((st->range == 10000) ? GPIOF_INIT_HIGH :\r\nGPIOF_INIT_LOW), "AD7606_RANGE");\r\nif (!ret)\r\nst->have_range = true;\r\nret = gpio_request_one(st->pdata->gpio_stby, GPIOF_OUT_INIT_HIGH,\r\n"AD7606_STBY");\r\nif (!ret)\r\nst->have_stby = true;\r\nif (gpio_is_valid(st->pdata->gpio_frstdata)) {\r\nret = gpio_request_one(st->pdata->gpio_frstdata, GPIOF_IN,\r\n"AD7606_FRSTDATA");\r\nif (!ret)\r\nst->have_frstdata = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ad7606_free_gpios(struct ad7606_state *st)\r\n{\r\nif (st->have_range)\r\ngpio_free(st->pdata->gpio_range);\r\nif (st->have_stby)\r\ngpio_free(st->pdata->gpio_stby);\r\nif (st->have_os) {\r\ngpio_free(st->pdata->gpio_os0);\r\ngpio_free(st->pdata->gpio_os1);\r\ngpio_free(st->pdata->gpio_os2);\r\n}\r\nif (st->have_reset)\r\ngpio_free(st->pdata->gpio_reset);\r\nif (st->have_frstdata)\r\ngpio_free(st->pdata->gpio_frstdata);\r\ngpio_free(st->pdata->gpio_convst);\r\n}\r\nstatic irqreturn_t ad7606_interrupt(int irq, void *dev_id)\r\n{\r\nstruct iio_dev *indio_dev = dev_id;\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nif (iio_ring_enabled(indio_dev)) {\r\nif (!work_pending(&st->poll_work))\r\nschedule_work(&st->poll_work);\r\n} else {\r\nst->done = true;\r\nwake_up_interruptible(&st->wq_data_avail);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct iio_dev *ad7606_probe(struct device *dev, int irq,\r\nvoid __iomem *base_address,\r\nunsigned id,\r\nconst struct ad7606_bus_ops *bops)\r\n{\r\nstruct ad7606_platform_data *pdata = dev->platform_data;\r\nstruct ad7606_state *st;\r\nint ret, regdone = 0;\r\nstruct iio_dev *indio_dev = iio_allocate_device(sizeof(*st));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nst = iio_priv(indio_dev);\r\nst->dev = dev;\r\nst->id = id;\r\nst->irq = irq;\r\nst->bops = bops;\r\nst->base_address = base_address;\r\nst->range = pdata->default_range == 10000 ? 10000 : 5000;\r\nret = ad7606_oversampling_get_index(pdata->default_os);\r\nif (ret < 0) {\r\ndev_warn(dev, "oversampling %d is not supported\n",\r\npdata->default_os);\r\nst->oversampling = 0;\r\n} else {\r\nst->oversampling = pdata->default_os;\r\n}\r\nst->reg = regulator_get(dev, "vcc");\r\nif (!IS_ERR(st->reg)) {\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\ngoto error_put_reg;\r\n}\r\nst->pdata = pdata;\r\nst->chip_info = &ad7606_chip_info_tbl[id];\r\nindio_dev->dev.parent = dev;\r\nindio_dev->info = &ad7606_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = st->chip_info->name;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\ninit_waitqueue_head(&st->wq_data_avail);\r\nret = ad7606_request_gpios(st);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad7606_reset(st);\r\nif (ret)\r\ndev_warn(st->dev, "failed to RESET: no RESET GPIO specified\n");\r\nret = request_irq(st->irq, ad7606_interrupt,\r\nIRQF_TRIGGER_FALLING, st->chip_info->name, indio_dev);\r\nif (ret)\r\ngoto error_free_gpios;\r\nret = ad7606_register_ring_funcs_and_init(indio_dev);\r\nif (ret)\r\ngoto error_free_irq;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_free_irq;\r\nregdone = 1;\r\nret = iio_ring_buffer_register_ex(indio_dev->ring, 0,\r\nindio_dev->channels,\r\nindio_dev->num_channels);\r\nif (ret)\r\ngoto error_cleanup_ring;\r\nreturn indio_dev;\r\nerror_cleanup_ring:\r\nad7606_ring_cleanup(indio_dev);\r\nerror_free_irq:\r\nfree_irq(st->irq, indio_dev);\r\nerror_free_gpios:\r\nad7606_free_gpios(st);\r\nerror_disable_reg:\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nerror_put_reg:\r\nif (!IS_ERR(st->reg))\r\nregulator_put(st->reg);\r\nif (regdone)\r\niio_device_unregister(indio_dev);\r\nelse\r\niio_free_device(indio_dev);\r\nerror_ret:\r\nreturn ERR_PTR(ret);\r\n}\r\nint ad7606_remove(struct iio_dev *indio_dev)\r\n{\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\niio_ring_buffer_unregister(indio_dev->ring);\r\nad7606_ring_cleanup(indio_dev);\r\nfree_irq(st->irq, indio_dev);\r\nif (!IS_ERR(st->reg)) {\r\nregulator_disable(st->reg);\r\nregulator_put(st->reg);\r\n}\r\nad7606_free_gpios(st);\r\niio_device_unregister(indio_dev);\r\nreturn 0;\r\n}\r\nvoid ad7606_suspend(struct iio_dev *indio_dev)\r\n{\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nif (st->have_stby) {\r\nif (st->have_range)\r\ngpio_set_value(st->pdata->gpio_range, 1);\r\ngpio_set_value(st->pdata->gpio_stby, 0);\r\n}\r\n}\r\nvoid ad7606_resume(struct iio_dev *indio_dev)\r\n{\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nif (st->have_stby) {\r\nif (st->have_range)\r\ngpio_set_value(st->pdata->gpio_range,\r\nst->range == 10000);\r\ngpio_set_value(st->pdata->gpio_stby, 1);\r\nad7606_reset(st);\r\n}\r\n}
