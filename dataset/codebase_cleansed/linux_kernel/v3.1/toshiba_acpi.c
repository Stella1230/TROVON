static __inline__ void _set_bit(u32 * word, u32 mask, int value)\r\n{\r\n*word = (*word & ~mask) | (mask * value);\r\n}\r\nstatic int is_valid_acpi_path(const char *methodName)\r\n{\r\nacpi_handle handle;\r\nacpi_status status;\r\nstatus = acpi_get_handle(NULL, (char *)methodName, &handle);\r\nreturn !ACPI_FAILURE(status);\r\n}\r\nstatic int write_acpi_int(const char *methodName, int val)\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_objs[1];\r\nacpi_status status;\r\nparams.count = ARRAY_SIZE(in_objs);\r\nparams.pointer = in_objs;\r\nin_objs[0].type = ACPI_TYPE_INTEGER;\r\nin_objs[0].integer.value = val;\r\nstatus = acpi_evaluate_object(NULL, (char *)methodName, &params, NULL);\r\nreturn (status == AE_OK);\r\n}\r\nstatic acpi_status hci_raw(const u32 in[HCI_WORDS], u32 out[HCI_WORDS])\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_objs[HCI_WORDS];\r\nstruct acpi_buffer results;\r\nunion acpi_object out_objs[HCI_WORDS + 1];\r\nacpi_status status;\r\nint i;\r\nparams.count = HCI_WORDS;\r\nparams.pointer = in_objs;\r\nfor (i = 0; i < HCI_WORDS; ++i) {\r\nin_objs[i].type = ACPI_TYPE_INTEGER;\r\nin_objs[i].integer.value = in[i];\r\n}\r\nresults.length = sizeof(out_objs);\r\nresults.pointer = out_objs;\r\nstatus = acpi_evaluate_object(NULL, (char *)method_hci, &params,\r\n&results);\r\nif ((status == AE_OK) && (out_objs->package.count <= HCI_WORDS)) {\r\nfor (i = 0; i < out_objs->package.count; ++i) {\r\nout[i] = out_objs->package.elements[i].integer.value;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status hci_write1(u32 reg, u32 in1, u32 * result)\r\n{\r\nu32 in[HCI_WORDS] = { HCI_SET, reg, in1, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status = hci_raw(in, out);\r\n*result = (status == AE_OK) ? out[0] : HCI_FAILURE;\r\nreturn status;\r\n}\r\nstatic acpi_status hci_read1(u32 reg, u32 * out1, u32 * result)\r\n{\r\nu32 in[HCI_WORDS] = { HCI_GET, reg, 0, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status = hci_raw(in, out);\r\n*out1 = out[2];\r\n*result = (status == AE_OK) ? out[0] : HCI_FAILURE;\r\nreturn status;\r\n}\r\nstatic acpi_status hci_write2(u32 reg, u32 in1, u32 in2, u32 *result)\r\n{\r\nu32 in[HCI_WORDS] = { HCI_SET, reg, in1, in2, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status = hci_raw(in, out);\r\n*result = (status == AE_OK) ? out[0] : HCI_FAILURE;\r\nreturn status;\r\n}\r\nstatic acpi_status hci_read2(u32 reg, u32 *out1, u32 *out2, u32 *result)\r\n{\r\nu32 in[HCI_WORDS] = { HCI_GET, reg, *out1, *out2, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status = hci_raw(in, out);\r\n*out1 = out[2];\r\n*out2 = out[3];\r\n*result = (status == AE_OK) ? out[0] : HCI_FAILURE;\r\nreturn status;\r\n}\r\nstatic int toshiba_illumination_available(void)\r\n{\r\nu32 in[HCI_WORDS] = { 0, 0, 0, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status;\r\nin[0] = 0xf100;\r\nstatus = hci_raw(in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Illumination device not available\n");\r\nreturn 0;\r\n}\r\nin[0] = 0xf400;\r\nstatus = hci_raw(in, out);\r\nreturn 1;\r\n}\r\nstatic void toshiba_illumination_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nu32 in[HCI_WORDS] = { 0, 0, 0, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status;\r\nin[0] = 0xf100;\r\nstatus = hci_raw(in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Illumination device not available\n");\r\nreturn;\r\n}\r\nif (brightness) {\r\nin[0] = 0xf400;\r\nin[1] = 0x14e;\r\nin[2] = 1;\r\nstatus = hci_raw(in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("ACPI call for illumination failed\n");\r\nreturn;\r\n}\r\n} else {\r\nin[0] = 0xf400;\r\nin[1] = 0x14e;\r\nin[2] = 0;\r\nstatus = hci_raw(in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("ACPI call for illumination failed.\n");\r\nreturn;\r\n}\r\n}\r\nin[0] = 0xf200;\r\nin[1] = 0;\r\nin[2] = 0;\r\nhci_raw(in, out);\r\n}\r\nstatic enum led_brightness toshiba_illumination_get(struct led_classdev *cdev)\r\n{\r\nu32 in[HCI_WORDS] = { 0, 0, 0, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status;\r\nenum led_brightness result;\r\nin[0] = 0xf100;\r\nstatus = hci_raw(in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Illumination device not available\n");\r\nreturn LED_OFF;\r\n}\r\nin[0] = 0xf300;\r\nin[1] = 0x14e;\r\nstatus = hci_raw(in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("ACPI call for illumination failed.\n");\r\nreturn LED_OFF;\r\n}\r\nresult = out[2] ? LED_FULL : LED_OFF;\r\nin[0] = 0xf200;\r\nin[1] = 0;\r\nin[2] = 0;\r\nhci_raw(in, out);\r\nreturn result;\r\n}\r\nstatic u32 hci_get_bt_present(bool *present)\r\n{\r\nu32 hci_result;\r\nu32 value, value2;\r\nvalue = 0;\r\nvalue2 = 0;\r\nhci_read2(HCI_WIRELESS, &value, &value2, &hci_result);\r\nif (hci_result == HCI_SUCCESS)\r\n*present = (value & HCI_WIRELESS_BT_PRESENT) ? true : false;\r\nreturn hci_result;\r\n}\r\nstatic u32 hci_get_radio_state(bool *radio_state)\r\n{\r\nu32 hci_result;\r\nu32 value, value2;\r\nvalue = 0;\r\nvalue2 = 0x0001;\r\nhci_read2(HCI_WIRELESS, &value, &value2, &hci_result);\r\n*radio_state = value & HCI_WIRELESS_KILL_SWITCH;\r\nreturn hci_result;\r\n}\r\nstatic int bt_rfkill_set_block(void *data, bool blocked)\r\n{\r\nstruct toshiba_acpi_dev *dev = data;\r\nu32 result1, result2;\r\nu32 value;\r\nint err;\r\nbool radio_state;\r\nvalue = (blocked == false);\r\nmutex_lock(&dev->mutex);\r\nif (hci_get_radio_state(&radio_state) != HCI_SUCCESS) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (!radio_state) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nhci_write2(HCI_WIRELESS, value, HCI_WIRELESS_BT_POWER, &result1);\r\nhci_write2(HCI_WIRELESS, value, HCI_WIRELESS_BT_ATTACH, &result2);\r\nif (result1 != HCI_SUCCESS || result2 != HCI_SUCCESS)\r\nerr = -EBUSY;\r\nelse\r\nerr = 0;\r\nout:\r\nmutex_unlock(&dev->mutex);\r\nreturn err;\r\n}\r\nstatic void bt_rfkill_poll(struct rfkill *rfkill, void *data)\r\n{\r\nbool new_rfk_state;\r\nbool value;\r\nu32 hci_result;\r\nstruct toshiba_acpi_dev *dev = data;\r\nmutex_lock(&dev->mutex);\r\nhci_result = hci_get_radio_state(&value);\r\nif (hci_result != HCI_SUCCESS) {\r\nmutex_unlock(&dev->mutex);\r\nreturn;\r\n}\r\nnew_rfk_state = value;\r\nmutex_unlock(&dev->mutex);\r\nif (rfkill_set_hw_state(rfkill, !new_rfk_state))\r\nbt_rfkill_set_block(data, true);\r\n}\r\nstatic int get_lcd(struct backlight_device *bd)\r\n{\r\nu32 hci_result;\r\nu32 value;\r\nhci_read1(HCI_LCD_BRIGHTNESS, &value, &hci_result);\r\nif (hci_result == HCI_SUCCESS) {\r\nreturn (value >> HCI_LCD_BRIGHTNESS_SHIFT);\r\n} else\r\nreturn -EFAULT;\r\n}\r\nstatic int lcd_proc_show(struct seq_file *m, void *v)\r\n{\r\nint value = get_lcd(NULL);\r\nif (value >= 0) {\r\nseq_printf(m, "brightness: %d\n", value);\r\nseq_printf(m, "brightness_levels: %d\n",\r\nHCI_LCD_BRIGHTNESS_LEVELS);\r\n} else {\r\npr_err("Error reading LCD brightness\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int lcd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, lcd_proc_show, NULL);\r\n}\r\nstatic int set_lcd(int value)\r\n{\r\nu32 hci_result;\r\nvalue = value << HCI_LCD_BRIGHTNESS_SHIFT;\r\nhci_write1(HCI_LCD_BRIGHTNESS, value, &hci_result);\r\nif (hci_result != HCI_SUCCESS)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_lcd_status(struct backlight_device *bd)\r\n{\r\nreturn set_lcd(bd->props.brightness);\r\n}\r\nstatic ssize_t lcd_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar cmd[42];\r\nsize_t len;\r\nint value;\r\nint ret;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nif (sscanf(cmd, " brightness : %i", &value) == 1 &&\r\nvalue >= 0 && value < HCI_LCD_BRIGHTNESS_LEVELS) {\r\nret = set_lcd(value);\r\nif (ret == 0)\r\nret = count;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int video_proc_show(struct seq_file *m, void *v)\r\n{\r\nu32 hci_result;\r\nu32 value;\r\nhci_read1(HCI_VIDEO_OUT, &value, &hci_result);\r\nif (hci_result == HCI_SUCCESS) {\r\nint is_lcd = (value & HCI_VIDEO_OUT_LCD) ? 1 : 0;\r\nint is_crt = (value & HCI_VIDEO_OUT_CRT) ? 1 : 0;\r\nint is_tv = (value & HCI_VIDEO_OUT_TV) ? 1 : 0;\r\nseq_printf(m, "lcd_out: %d\n", is_lcd);\r\nseq_printf(m, "crt_out: %d\n", is_crt);\r\nseq_printf(m, "tv_out: %d\n", is_tv);\r\n} else {\r\npr_err("Error reading video out status\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int video_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, video_proc_show, NULL);\r\n}\r\nstatic ssize_t video_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar *cmd, *buffer;\r\nint value;\r\nint remain = count;\r\nint lcd_out = -1;\r\nint crt_out = -1;\r\nint tv_out = -1;\r\nu32 hci_result;\r\nu32 video_out;\r\ncmd = kmalloc(count + 1, GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nif (copy_from_user(cmd, buf, count)) {\r\nkfree(cmd);\r\nreturn -EFAULT;\r\n}\r\ncmd[count] = '\0';\r\nbuffer = cmd;\r\nwhile (remain) {\r\nif (sscanf(buffer, " lcd_out : %i", &value) == 1)\r\nlcd_out = value & 1;\r\nelse if (sscanf(buffer, " crt_out : %i", &value) == 1)\r\ncrt_out = value & 1;\r\nelse if (sscanf(buffer, " tv_out : %i", &value) == 1)\r\ntv_out = value & 1;\r\ndo {\r\n++buffer;\r\n--remain;\r\n}\r\nwhile (remain && *(buffer - 1) != ';');\r\n}\r\nkfree(cmd);\r\nhci_read1(HCI_VIDEO_OUT, &video_out, &hci_result);\r\nif (hci_result == HCI_SUCCESS) {\r\nunsigned int new_video_out = video_out;\r\nif (lcd_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_LCD, lcd_out);\r\nif (crt_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_CRT, crt_out);\r\nif (tv_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_TV, tv_out);\r\nif (new_video_out != video_out)\r\nwrite_acpi_int(METHOD_VIDEO_OUT, new_video_out);\r\n} else {\r\nreturn -EFAULT;\r\n}\r\nreturn count;\r\n}\r\nstatic int fan_proc_show(struct seq_file *m, void *v)\r\n{\r\nu32 hci_result;\r\nu32 value;\r\nhci_read1(HCI_FAN, &value, &hci_result);\r\nif (hci_result == HCI_SUCCESS) {\r\nseq_printf(m, "running: %d\n", (value > 0));\r\nseq_printf(m, "force_on: %d\n", force_fan);\r\n} else {\r\npr_err("Error reading fan status\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int fan_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fan_proc_show, NULL);\r\n}\r\nstatic ssize_t fan_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar cmd[42];\r\nsize_t len;\r\nint value;\r\nu32 hci_result;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nif (sscanf(cmd, " force_on : %i", &value) == 1 &&\r\nvalue >= 0 && value <= 1) {\r\nhci_write1(HCI_FAN, value, &hci_result);\r\nif (hci_result != HCI_SUCCESS)\r\nreturn -EFAULT;\r\nelse\r\nforce_fan = value;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic int keys_proc_show(struct seq_file *m, void *v)\r\n{\r\nu32 hci_result;\r\nu32 value;\r\nif (!key_event_valid) {\r\nhci_read1(HCI_SYSTEM_EVENT, &value, &hci_result);\r\nif (hci_result == HCI_SUCCESS) {\r\nkey_event_valid = 1;\r\nlast_key_event = value;\r\n} else if (hci_result == HCI_EMPTY) {\r\n} else if (hci_result == HCI_NOT_SUPPORTED) {\r\nhci_write1(HCI_SYSTEM_EVENT, 1, &hci_result);\r\npr_notice("Re-enabled hotkeys\n");\r\n} else {\r\npr_err("Error reading hotkey status\n");\r\ngoto end;\r\n}\r\n}\r\nseq_printf(m, "hotkey_ready: %d\n", key_event_valid);\r\nseq_printf(m, "hotkey: 0x%04x\n", last_key_event);\r\nend:\r\nreturn 0;\r\n}\r\nstatic int keys_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, keys_proc_show, NULL);\r\n}\r\nstatic ssize_t keys_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar cmd[42];\r\nsize_t len;\r\nint value;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nif (sscanf(cmd, " hotkey_ready : %i", &value) == 1 && value == 0) {\r\nkey_event_valid = 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic int version_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "driver: %s\n", TOSHIBA_ACPI_VERSION);\r\nseq_printf(m, "proc_interface: %d\n", PROC_INTERFACE_VERSION);\r\nreturn 0;\r\n}\r\nstatic int version_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, version_proc_show, PDE(inode)->data);\r\n}\r\nstatic void __init create_toshiba_proc_entries(void)\r\n{\r\nproc_create("lcd", S_IRUGO | S_IWUSR, toshiba_proc_dir, &lcd_proc_fops);\r\nproc_create("video", S_IRUGO | S_IWUSR, toshiba_proc_dir, &video_proc_fops);\r\nproc_create("fan", S_IRUGO | S_IWUSR, toshiba_proc_dir, &fan_proc_fops);\r\nproc_create("keys", S_IRUGO | S_IWUSR, toshiba_proc_dir, &keys_proc_fops);\r\nproc_create("version", S_IRUGO, toshiba_proc_dir, &version_proc_fops);\r\n}\r\nstatic void remove_toshiba_proc_entries(void)\r\n{\r\nremove_proc_entry("lcd", toshiba_proc_dir);\r\nremove_proc_entry("video", toshiba_proc_dir);\r\nremove_proc_entry("fan", toshiba_proc_dir);\r\nremove_proc_entry("keys", toshiba_proc_dir);\r\nremove_proc_entry("version", toshiba_proc_dir);\r\n}\r\nstatic void toshiba_acpi_notify(acpi_handle handle, u32 event, void *context)\r\n{\r\nu32 hci_result, value;\r\nif (event != 0x80)\r\nreturn;\r\ndo {\r\nhci_read1(HCI_SYSTEM_EVENT, &value, &hci_result);\r\nif (hci_result == HCI_SUCCESS) {\r\nif (value == 0x100)\r\ncontinue;\r\nif (value & 0x80)\r\ncontinue;\r\nif (!sparse_keymap_report_event(toshiba_acpi.hotkey_dev,\r\nvalue, 1, true)) {\r\npr_info("Unknown key %x\n",\r\nvalue);\r\n}\r\n} else if (hci_result == HCI_NOT_SUPPORTED) {\r\nhci_write1(HCI_SYSTEM_EVENT, 1, &hci_result);\r\npr_notice("Re-enabled hotkeys\n");\r\n}\r\n} while (hci_result != HCI_EMPTY);\r\n}\r\nstatic int __init toshiba_acpi_setup_keyboard(char *device)\r\n{\r\nacpi_status status;\r\nint error;\r\nstatus = acpi_get_handle(NULL, device, &toshiba_acpi.handle);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Unable to get notification device\n");\r\nreturn -ENODEV;\r\n}\r\ntoshiba_acpi.hotkey_dev = input_allocate_device();\r\nif (!toshiba_acpi.hotkey_dev) {\r\npr_info("Unable to register input device\n");\r\nreturn -ENOMEM;\r\n}\r\ntoshiba_acpi.hotkey_dev->name = "Toshiba input device";\r\ntoshiba_acpi.hotkey_dev->phys = device;\r\ntoshiba_acpi.hotkey_dev->id.bustype = BUS_HOST;\r\nerror = sparse_keymap_setup(toshiba_acpi.hotkey_dev,\r\ntoshiba_acpi_keymap, NULL);\r\nif (error)\r\ngoto err_free_dev;\r\nstatus = acpi_install_notify_handler(toshiba_acpi.handle,\r\nACPI_DEVICE_NOTIFY, toshiba_acpi_notify, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Unable to install hotkey notification\n");\r\nerror = -ENODEV;\r\ngoto err_free_keymap;\r\n}\r\nstatus = acpi_evaluate_object(toshiba_acpi.handle, "ENAB", NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Unable to enable hotkeys\n");\r\nerror = -ENODEV;\r\ngoto err_remove_notify;\r\n}\r\nerror = input_register_device(toshiba_acpi.hotkey_dev);\r\nif (error) {\r\npr_info("Unable to register input device\n");\r\ngoto err_remove_notify;\r\n}\r\nreturn 0;\r\nerr_remove_notify:\r\nacpi_remove_notify_handler(toshiba_acpi.handle,\r\nACPI_DEVICE_NOTIFY, toshiba_acpi_notify);\r\nerr_free_keymap:\r\nsparse_keymap_free(toshiba_acpi.hotkey_dev);\r\nerr_free_dev:\r\ninput_free_device(toshiba_acpi.hotkey_dev);\r\ntoshiba_acpi.hotkey_dev = NULL;\r\nreturn error;\r\n}\r\nstatic void toshiba_acpi_exit(void)\r\n{\r\nif (toshiba_acpi.hotkey_dev) {\r\nacpi_remove_notify_handler(toshiba_acpi.handle,\r\nACPI_DEVICE_NOTIFY, toshiba_acpi_notify);\r\nsparse_keymap_free(toshiba_acpi.hotkey_dev);\r\ninput_unregister_device(toshiba_acpi.hotkey_dev);\r\n}\r\nif (toshiba_acpi.bt_rfk) {\r\nrfkill_unregister(toshiba_acpi.bt_rfk);\r\nrfkill_destroy(toshiba_acpi.bt_rfk);\r\n}\r\nif (toshiba_backlight_device)\r\nbacklight_device_unregister(toshiba_backlight_device);\r\nremove_toshiba_proc_entries();\r\nif (toshiba_proc_dir)\r\nremove_proc_entry(PROC_TOSHIBA, acpi_root_dir);\r\nif (toshiba_acpi.illumination_installed)\r\nled_classdev_unregister(&toshiba_led);\r\nplatform_device_unregister(toshiba_acpi.p_dev);\r\nreturn;\r\n}\r\nstatic int __init toshiba_acpi_init(void)\r\n{\r\nu32 hci_result;\r\nbool bt_present;\r\nint ret = 0;\r\nstruct backlight_properties props;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nif (is_valid_acpi_path(TOSH_INTERFACE_1 GHCI_METHOD)) {\r\nmethod_hci = TOSH_INTERFACE_1 GHCI_METHOD;\r\nif (toshiba_acpi_setup_keyboard(TOSH_INTERFACE_1))\r\npr_info("Unable to activate hotkeys\n");\r\n} else if (is_valid_acpi_path(TOSH_INTERFACE_2 GHCI_METHOD)) {\r\nmethod_hci = TOSH_INTERFACE_2 GHCI_METHOD;\r\nif (toshiba_acpi_setup_keyboard(TOSH_INTERFACE_2))\r\npr_info("Unable to activate hotkeys\n");\r\n} else\r\nreturn -ENODEV;\r\npr_info("Toshiba Laptop ACPI Extras version %s\n",\r\nTOSHIBA_ACPI_VERSION);\r\npr_info(" HCI method: %s\n", method_hci);\r\nmutex_init(&toshiba_acpi.mutex);\r\ntoshiba_acpi.p_dev = platform_device_register_simple("toshiba_acpi",\r\n-1, NULL, 0);\r\nif (IS_ERR(toshiba_acpi.p_dev)) {\r\nret = PTR_ERR(toshiba_acpi.p_dev);\r\npr_err("unable to register platform device\n");\r\ntoshiba_acpi.p_dev = NULL;\r\ntoshiba_acpi_exit();\r\nreturn ret;\r\n}\r\nforce_fan = 0;\r\nkey_event_valid = 0;\r\nhci_write1(HCI_SYSTEM_EVENT, 1, &hci_result);\r\ntoshiba_proc_dir = proc_mkdir(PROC_TOSHIBA, acpi_root_dir);\r\nif (!toshiba_proc_dir) {\r\ntoshiba_acpi_exit();\r\nreturn -ENODEV;\r\n} else {\r\ncreate_toshiba_proc_entries();\r\n}\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = HCI_LCD_BRIGHTNESS_LEVELS - 1;\r\ntoshiba_backlight_device = backlight_device_register("toshiba",\r\n&toshiba_acpi.p_dev->dev,\r\nNULL,\r\n&toshiba_backlight_data,\r\n&props);\r\nif (IS_ERR(toshiba_backlight_device)) {\r\nret = PTR_ERR(toshiba_backlight_device);\r\npr_err("Could not register toshiba backlight device\n");\r\ntoshiba_backlight_device = NULL;\r\ntoshiba_acpi_exit();\r\nreturn ret;\r\n}\r\nif (hci_get_bt_present(&bt_present) == HCI_SUCCESS && bt_present) {\r\ntoshiba_acpi.bt_rfk = rfkill_alloc(toshiba_acpi.bt_name,\r\n&toshiba_acpi.p_dev->dev,\r\nRFKILL_TYPE_BLUETOOTH,\r\n&toshiba_rfk_ops,\r\n&toshiba_acpi);\r\nif (!toshiba_acpi.bt_rfk) {\r\npr_err("unable to allocate rfkill device\n");\r\ntoshiba_acpi_exit();\r\nreturn -ENOMEM;\r\n}\r\nret = rfkill_register(toshiba_acpi.bt_rfk);\r\nif (ret) {\r\npr_err("unable to register rfkill device\n");\r\nrfkill_destroy(toshiba_acpi.bt_rfk);\r\ntoshiba_acpi_exit();\r\nreturn ret;\r\n}\r\n}\r\ntoshiba_acpi.illumination_installed = 0;\r\nif (toshiba_illumination_available()) {\r\nif (!led_classdev_register(&(toshiba_acpi.p_dev->dev),\r\n&toshiba_led))\r\ntoshiba_acpi.illumination_installed = 1;\r\n}\r\nreturn 0;\r\n}
