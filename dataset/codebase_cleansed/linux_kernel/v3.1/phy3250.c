static int lpc32xx_clcd_setup(struct clcd_fb *fb)\r\n{\r\ndma_addr_t dma;\r\nfb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev,\r\nPANEL_SIZE, &dma, GFP_KERNEL);\r\nif (!fb->fb.screen_base) {\r\nprintk(KERN_ERR "CLCD: unable to map framebuffer\n");\r\nreturn -ENOMEM;\r\n}\r\nfb->fb.fix.smem_start = dma;\r\nfb->fb.fix.smem_len = PANEL_SIZE;\r\nfb->panel = &conn_lcd_panel;\r\nif (gpio_request(LCD_POWER_GPIO, "LCD power"))\r\nprintk(KERN_ERR "Error requesting gpio %u",\r\nLCD_POWER_GPIO);\r\nelse if (gpio_direction_output(LCD_POWER_GPIO, 1))\r\nprintk(KERN_ERR "Error setting gpio %u to output",\r\nLCD_POWER_GPIO);\r\nif (gpio_request(BKL_POWER_GPIO, "LCD backlight power"))\r\nprintk(KERN_ERR "Error requesting gpio %u",\r\nBKL_POWER_GPIO);\r\nelse if (gpio_direction_output(BKL_POWER_GPIO, 1))\r\nprintk(KERN_ERR "Error setting gpio %u to output",\r\nBKL_POWER_GPIO);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)\r\n{\r\nreturn dma_mmap_writecombine(&fb->dev->dev, vma,\r\nfb->fb.screen_base, fb->fb.fix.smem_start,\r\nfb->fb.fix.smem_len);\r\n}\r\nstatic void lpc32xx_clcd_remove(struct clcd_fb *fb)\r\n{\r\ndma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,\r\nfb->fb.screen_base, fb->fb.fix.smem_start);\r\n}\r\nstatic void clcd_disable(struct clcd_fb *fb)\r\n{\r\ngpio_set_value(BKL_POWER_GPIO, 0);\r\ngpio_set_value(LCD_POWER_GPIO, 0);\r\n}\r\nstatic void clcd_enable(struct clcd_fb *fb)\r\n{\r\ngpio_set_value(BKL_POWER_GPIO, 1);\r\ngpio_set_value(LCD_POWER_GPIO, 1);\r\n}\r\nstatic void phy3250_spi_cs_set(u32 control)\r\n{\r\ngpio_set_value(SPI0_CS_GPIO, (int) control);\r\n}\r\nstatic int __init phy3250_spi_board_register(void)\r\n{\r\n#if defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_SPI_SPIDEV_MODULE)\r\nstatic struct spi_board_info info[] = {\r\n{\r\n.modalias = "spidev",\r\n.max_speed_hz = 5000000,\r\n.bus_num = 0,\r\n.chip_select = 0,\r\n.controller_data = &spi0_chip_info,\r\n},\r\n};\r\n#else\r\nstatic struct spi_eeprom eeprom = {\r\n.name = "at25256a",\r\n.byte_len = 0x8000,\r\n.page_size = 64,\r\n.flags = EE_ADDR2,\r\n};\r\nstatic struct spi_board_info info[] = {\r\n{\r\n.modalias = "at25",\r\n.max_speed_hz = 5000000,\r\n.bus_num = 0,\r\n.chip_select = 0,\r\n.mode = SPI_MODE_0,\r\n.platform_data = &eeprom,\r\n.controller_data = &spi0_chip_info,\r\n},\r\n};\r\n#endif\r\nreturn spi_register_board_info(info, ARRAY_SIZE(info));\r\n}\r\nstatic void __init phy3250_board_init(void)\r\n{\r\nu32 tmp;\r\nint i;\r\nlpc32xx_gpio_init();\r\nif (gpio_request(SPI0_CS_GPIO, "spi0 cs"))\r\nprintk(KERN_ERR "Error requesting gpio %u",\r\nSPI0_CS_GPIO);\r\nelse if (gpio_direction_output(SPI0_CS_GPIO, 1))\r\nprintk(KERN_ERR "Error setting gpio %u to output",\r\nSPI0_CS_GPIO);\r\ntmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);\r\ntmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;\r\ntmp |= LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS;\r\n__raw_writel(tmp, LPC32XX_CLKPWR_MACCLK_CTRL);\r\n__raw_writel(LPC32XX_CLKPWR_NANDCLK_SEL_SLC,\r\nLPC32XX_CLKPWR_NAND_CLK_CTRL);\r\ntmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL) &\r\n~(LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_MSK |\r\nLPC32XX_CLKPWR_LCDCTRL_PSCALE_MSK);\r\ntmp |= LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT16;\r\n__raw_writel(tmp, LPC32XX_CLKPWR_LCDCLK_CTRL);\r\ntmp = __raw_readl(LPC32XX_CLKPWR_I2C_CLK_CTRL);\r\ntmp |= LPC32XX_CLKPWR_I2CCLK_USBI2CHI_DRIVE |\r\nLPC32XX_CLKPWR_I2CCLK_I2C2HI_DRIVE;\r\n__raw_writel(tmp, LPC32XX_CLKPWR_I2C_CLK_CTRL);\r\ntmp = __raw_readl(LPC32XX_UARTCTL_CTRL);\r\ntmp |= LPC32XX_UART_UART6_IRDAMOD_BYPASS;\r\n__raw_writel(tmp, LPC32XX_UARTCTL_CTRL);\r\ntmp = __raw_readl(LPC32XX_CLKPWR_I2S_CLK_CTRL);\r\ntmp = LPC32XX_CLKPWR_I2SCTRL_I2S1_USE_DMA;\r\n__raw_writel(tmp, LPC32XX_CLKPWR_I2S_CLK_CTRL);\r\nlpc32xx_serial_init();\r\n#ifdef CONFIG_FB_ARMCLCD\r\ntmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL);\r\n__raw_writel((tmp | LPC32XX_CLKPWR_LCDCTRL_CLK_EN),\r\nLPC32XX_CLKPWR_LCDCLK_CTRL);\r\n#endif\r\n#ifdef CONFIG_SPI_PL022\r\ntmp = __raw_readl(LPC32XX_CLKPWR_SSP_CLK_CTRL);\r\n__raw_writel((tmp | LPC32XX_CLKPWR_SSPCTRL_SSPCLK0_EN),\r\nLPC32XX_CLKPWR_SSP_CLK_CTRL);\r\n#endif\r\nplatform_add_devices(phy3250_devs, ARRAY_SIZE(phy3250_devs));\r\nfor (i = 0; i < ARRAY_SIZE(amba_devs); i++) {\r\nstruct amba_device *d = amba_devs[i];\r\namba_device_register(d, &iomem_resource);\r\n}\r\n__raw_writel(LPC32XX_CLKPWR_TESTCLK2_SEL_MOSC |\r\nLPC32XX_CLKPWR_TESTCLK_TESTCLK2_EN,\r\nLPC32XX_CLKPWR_TEST_CLK_SEL);\r\ni2c_register_board_info(0, phy3250_i2c_board_info,\r\nARRAY_SIZE(phy3250_i2c_board_info));\r\n}\r\nstatic int __init lpc32xx_display_uid(void)\r\n{\r\nu32 uid[4];\r\nlpc32xx_get_uid(uid);\r\nprintk(KERN_INFO "LPC32XX unique ID: %08x%08x%08x%08x\n",\r\nuid[3], uid[2], uid[1], uid[0]);\r\nreturn 1;\r\n}
