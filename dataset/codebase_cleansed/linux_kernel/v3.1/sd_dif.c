static __u16 sd_dif_crc_fn(void *data, unsigned int len)\r\n{\r\nreturn cpu_to_be16(crc_t10dif(data, len));\r\n}\r\nstatic __u16 sd_dif_ip_fn(void *data, unsigned int len)\r\n{\r\nreturn ip_compute_csum(data, len);\r\n}\r\nstatic void sd_dif_type1_generate(struct blk_integrity_exchg *bix, csum_fn *fn)\r\n{\r\nvoid *buf = bix->data_buf;\r\nstruct sd_dif_tuple *sdt = bix->prot_buf;\r\nsector_t sector = bix->sector;\r\nunsigned int i;\r\nfor (i = 0 ; i < bix->data_size ; i += bix->sector_size, sdt++) {\r\nsdt->guard_tag = fn(buf, bix->sector_size);\r\nsdt->ref_tag = cpu_to_be32(sector & 0xffffffff);\r\nsdt->app_tag = 0;\r\nbuf += bix->sector_size;\r\nsector++;\r\n}\r\n}\r\nstatic void sd_dif_type1_generate_crc(struct blk_integrity_exchg *bix)\r\n{\r\nsd_dif_type1_generate(bix, sd_dif_crc_fn);\r\n}\r\nstatic void sd_dif_type1_generate_ip(struct blk_integrity_exchg *bix)\r\n{\r\nsd_dif_type1_generate(bix, sd_dif_ip_fn);\r\n}\r\nstatic int sd_dif_type1_verify(struct blk_integrity_exchg *bix, csum_fn *fn)\r\n{\r\nvoid *buf = bix->data_buf;\r\nstruct sd_dif_tuple *sdt = bix->prot_buf;\r\nsector_t sector = bix->sector;\r\nunsigned int i;\r\n__u16 csum;\r\nfor (i = 0 ; i < bix->data_size ; i += bix->sector_size, sdt++) {\r\nif (sdt->app_tag == 0xffff)\r\nreturn 0;\r\nif (sdt->ref_tag == 0xffffffff) {\r\nprintk(KERN_ERR\r\n"%s: bad phys ref tag on sector %lu\n",\r\nbix->disk_name, (unsigned long)sector);\r\nreturn -EIO;\r\n}\r\nif (be32_to_cpu(sdt->ref_tag) != (sector & 0xffffffff)) {\r\nprintk(KERN_ERR\r\n"%s: ref tag error on sector %lu (rcvd %u)\n",\r\nbix->disk_name, (unsigned long)sector,\r\nbe32_to_cpu(sdt->ref_tag));\r\nreturn -EIO;\r\n}\r\ncsum = fn(buf, bix->sector_size);\r\nif (sdt->guard_tag != csum) {\r\nprintk(KERN_ERR "%s: guard tag error on sector %lu " \\r\n"(rcvd %04x, data %04x)\n", bix->disk_name,\r\n(unsigned long)sector,\r\nbe16_to_cpu(sdt->guard_tag), be16_to_cpu(csum));\r\nreturn -EIO;\r\n}\r\nbuf += bix->sector_size;\r\nsector++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_dif_type1_verify_crc(struct blk_integrity_exchg *bix)\r\n{\r\nreturn sd_dif_type1_verify(bix, sd_dif_crc_fn);\r\n}\r\nstatic int sd_dif_type1_verify_ip(struct blk_integrity_exchg *bix)\r\n{\r\nreturn sd_dif_type1_verify(bix, sd_dif_ip_fn);\r\n}\r\nstatic void sd_dif_type1_set_tag(void *prot, void *tag_buf, unsigned int sectors)\r\n{\r\nstruct sd_dif_tuple *sdt = prot;\r\nu8 *tag = tag_buf;\r\nunsigned int i, j;\r\nfor (i = 0, j = 0 ; i < sectors ; i++, j += 2, sdt++) {\r\nsdt->app_tag = tag[j] << 8 | tag[j+1];\r\nBUG_ON(sdt->app_tag == 0xffff);\r\n}\r\n}\r\nstatic void sd_dif_type1_get_tag(void *prot, void *tag_buf, unsigned int sectors)\r\n{\r\nstruct sd_dif_tuple *sdt = prot;\r\nu8 *tag = tag_buf;\r\nunsigned int i, j;\r\nfor (i = 0, j = 0 ; i < sectors ; i++, j += 2, sdt++) {\r\ntag[j] = (sdt->app_tag & 0xff00) >> 8;\r\ntag[j+1] = sdt->app_tag & 0xff;\r\n}\r\n}\r\nstatic void sd_dif_type3_generate(struct blk_integrity_exchg *bix, csum_fn *fn)\r\n{\r\nvoid *buf = bix->data_buf;\r\nstruct sd_dif_tuple *sdt = bix->prot_buf;\r\nunsigned int i;\r\nfor (i = 0 ; i < bix->data_size ; i += bix->sector_size, sdt++) {\r\nsdt->guard_tag = fn(buf, bix->sector_size);\r\nsdt->ref_tag = 0;\r\nsdt->app_tag = 0;\r\nbuf += bix->sector_size;\r\n}\r\n}\r\nstatic void sd_dif_type3_generate_crc(struct blk_integrity_exchg *bix)\r\n{\r\nsd_dif_type3_generate(bix, sd_dif_crc_fn);\r\n}\r\nstatic void sd_dif_type3_generate_ip(struct blk_integrity_exchg *bix)\r\n{\r\nsd_dif_type3_generate(bix, sd_dif_ip_fn);\r\n}\r\nstatic int sd_dif_type3_verify(struct blk_integrity_exchg *bix, csum_fn *fn)\r\n{\r\nvoid *buf = bix->data_buf;\r\nstruct sd_dif_tuple *sdt = bix->prot_buf;\r\nsector_t sector = bix->sector;\r\nunsigned int i;\r\n__u16 csum;\r\nfor (i = 0 ; i < bix->data_size ; i += bix->sector_size, sdt++) {\r\nif (sdt->app_tag == 0xffff && sdt->ref_tag == 0xffffffff)\r\nreturn 0;\r\ncsum = fn(buf, bix->sector_size);\r\nif (sdt->guard_tag != csum) {\r\nprintk(KERN_ERR "%s: guard tag error on sector %lu " \\r\n"(rcvd %04x, data %04x)\n", bix->disk_name,\r\n(unsigned long)sector,\r\nbe16_to_cpu(sdt->guard_tag), be16_to_cpu(csum));\r\nreturn -EIO;\r\n}\r\nbuf += bix->sector_size;\r\nsector++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_dif_type3_verify_crc(struct blk_integrity_exchg *bix)\r\n{\r\nreturn sd_dif_type3_verify(bix, sd_dif_crc_fn);\r\n}\r\nstatic int sd_dif_type3_verify_ip(struct blk_integrity_exchg *bix)\r\n{\r\nreturn sd_dif_type3_verify(bix, sd_dif_ip_fn);\r\n}\r\nstatic void sd_dif_type3_set_tag(void *prot, void *tag_buf, unsigned int sectors)\r\n{\r\nstruct sd_dif_tuple *sdt = prot;\r\nu8 *tag = tag_buf;\r\nunsigned int i, j;\r\nfor (i = 0, j = 0 ; i < sectors ; i++, j += 6, sdt++) {\r\nsdt->app_tag = tag[j] << 8 | tag[j+1];\r\nsdt->ref_tag = tag[j+2] << 24 | tag[j+3] << 16 |\r\ntag[j+4] << 8 | tag[j+5];\r\n}\r\n}\r\nstatic void sd_dif_type3_get_tag(void *prot, void *tag_buf, unsigned int sectors)\r\n{\r\nstruct sd_dif_tuple *sdt = prot;\r\nu8 *tag = tag_buf;\r\nunsigned int i, j;\r\nfor (i = 0, j = 0 ; i < sectors ; i++, j += 2, sdt++) {\r\ntag[j] = (sdt->app_tag & 0xff00) >> 8;\r\ntag[j+1] = sdt->app_tag & 0xff;\r\ntag[j+2] = (sdt->ref_tag & 0xff000000) >> 24;\r\ntag[j+3] = (sdt->ref_tag & 0xff0000) >> 16;\r\ntag[j+4] = (sdt->ref_tag & 0xff00) >> 8;\r\ntag[j+5] = sdt->ref_tag & 0xff;\r\nBUG_ON(sdt->app_tag == 0xffff || sdt->ref_tag == 0xffffffff);\r\n}\r\n}\r\nvoid sd_dif_config_host(struct scsi_disk *sdkp)\r\n{\r\nstruct scsi_device *sdp = sdkp->device;\r\nstruct gendisk *disk = sdkp->disk;\r\nu8 type = sdkp->protection_type;\r\nint dif, dix;\r\ndif = scsi_host_dif_capable(sdp->host, type);\r\ndix = scsi_host_dix_capable(sdp->host, type);\r\nif (!dix && scsi_host_dix_capable(sdp->host, 0)) {\r\ndif = 0; dix = 1;\r\n}\r\nif (!dix)\r\nreturn;\r\nif (scsi_host_get_guard(sdkp->device->host) & SHOST_DIX_GUARD_IP)\r\nif (type == SD_DIF_TYPE3_PROTECTION)\r\nblk_integrity_register(disk, &dif_type3_integrity_ip);\r\nelse\r\nblk_integrity_register(disk, &dif_type1_integrity_ip);\r\nelse\r\nif (type == SD_DIF_TYPE3_PROTECTION)\r\nblk_integrity_register(disk, &dif_type3_integrity_crc);\r\nelse\r\nblk_integrity_register(disk, &dif_type1_integrity_crc);\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"Enabling DIX %s protection\n", disk->integrity->name);\r\nif (dif && type && sdkp->ATO) {\r\nif (type == SD_DIF_TYPE3_PROTECTION)\r\ndisk->integrity->tag_size = sizeof(u16) + sizeof(u32);\r\nelse\r\ndisk->integrity->tag_size = sizeof(u16);\r\nsd_printk(KERN_NOTICE, sdkp, "DIF application tag size %u\n",\r\ndisk->integrity->tag_size);\r\n}\r\n}\r\nint sd_dif_prepare(struct request *rq, sector_t hw_sector, unsigned int sector_sz)\r\n{\r\nconst int tuple_sz = sizeof(struct sd_dif_tuple);\r\nstruct bio *bio;\r\nstruct scsi_disk *sdkp;\r\nstruct sd_dif_tuple *sdt;\r\nunsigned int i, j;\r\nu32 phys, virt;\r\nsdkp = rq->bio->bi_bdev->bd_disk->private_data;\r\nif (sdkp->protection_type == SD_DIF_TYPE3_PROTECTION)\r\nreturn 0;\r\nphys = hw_sector & 0xffffffff;\r\n__rq_for_each_bio(bio, rq) {\r\nstruct bio_vec *iv;\r\nif (bio_flagged(bio, BIO_MAPPED_INTEGRITY))\r\nbreak;\r\nvirt = bio->bi_integrity->bip_sector & 0xffffffff;\r\nbip_for_each_vec(iv, bio->bi_integrity, i) {\r\nsdt = kmap_atomic(iv->bv_page, KM_USER0)\r\n+ iv->bv_offset;\r\nfor (j = 0 ; j < iv->bv_len ; j += tuple_sz, sdt++) {\r\nif (be32_to_cpu(sdt->ref_tag) != virt)\r\ngoto error;\r\nsdt->ref_tag = cpu_to_be32(phys);\r\nvirt++;\r\nphys++;\r\n}\r\nkunmap_atomic(sdt, KM_USER0);\r\n}\r\nbio->bi_flags |= BIO_MAPPED_INTEGRITY;\r\n}\r\nreturn 0;\r\nerror:\r\nkunmap_atomic(sdt, KM_USER0);\r\nsd_printk(KERN_ERR, sdkp, "%s: virt %u, phys %u, ref %u, app %4x\n",\r\n__func__, virt, phys, be32_to_cpu(sdt->ref_tag),\r\nbe16_to_cpu(sdt->app_tag));\r\nreturn -EILSEQ;\r\n}\r\nvoid sd_dif_complete(struct scsi_cmnd *scmd, unsigned int good_bytes)\r\n{\r\nconst int tuple_sz = sizeof(struct sd_dif_tuple);\r\nstruct scsi_disk *sdkp;\r\nstruct bio *bio;\r\nstruct sd_dif_tuple *sdt;\r\nunsigned int i, j, sectors, sector_sz;\r\nu32 phys, virt;\r\nsdkp = scsi_disk(scmd->request->rq_disk);\r\nif (sdkp->protection_type == SD_DIF_TYPE3_PROTECTION || good_bytes == 0)\r\nreturn;\r\nsector_sz = scmd->device->sector_size;\r\nsectors = good_bytes / sector_sz;\r\nphys = blk_rq_pos(scmd->request) & 0xffffffff;\r\nif (sector_sz == 4096)\r\nphys >>= 3;\r\n__rq_for_each_bio(bio, scmd->request) {\r\nstruct bio_vec *iv;\r\nvirt = bio->bi_integrity->bip_sector & 0xffffffff;\r\nbip_for_each_vec(iv, bio->bi_integrity, i) {\r\nsdt = kmap_atomic(iv->bv_page, KM_USER0)\r\n+ iv->bv_offset;\r\nfor (j = 0 ; j < iv->bv_len ; j += tuple_sz, sdt++) {\r\nif (sectors == 0) {\r\nkunmap_atomic(sdt, KM_USER0);\r\nreturn;\r\n}\r\nif (be32_to_cpu(sdt->ref_tag) != phys &&\r\nsdt->app_tag != 0xffff)\r\nsdt->ref_tag = 0xffffffff;\r\nelse\r\nsdt->ref_tag = cpu_to_be32(virt);\r\nvirt++;\r\nphys++;\r\nsectors--;\r\n}\r\nkunmap_atomic(sdt, KM_USER0);\r\n}\r\n}\r\n}
