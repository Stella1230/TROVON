static void dump_one_vdso_page(struct page *pg, struct page *upg)\r\n{\r\nprintk("kpg: %p (c:%d,f:%08lx)", __va(page_to_pfn(pg) << PAGE_SHIFT),\r\npage_count(pg),\r\npg->flags);\r\nif (upg && !IS_ERR(upg) ) {\r\nprintk(" upg: %p (c:%d,f:%08lx)", __va(page_to_pfn(upg)\r\n<< PAGE_SHIFT),\r\npage_count(upg),\r\nupg->flags);\r\n}\r\nprintk("\n");\r\n}\r\nstatic void dump_vdso_pages(struct vm_area_struct * vma)\r\n{\r\nint i;\r\nif (!vma || is_32bit_task()) {\r\nprintk("vDSO32 @ %016lx:\n", (unsigned long)vdso32_kbase);\r\nfor (i=0; i<vdso32_pages; i++) {\r\nstruct page *pg = virt_to_page(vdso32_kbase +\r\ni*PAGE_SIZE);\r\nstruct page *upg = (vma && vma->vm_mm) ?\r\nfollow_page(vma, vma->vm_start + i*PAGE_SIZE, 0)\r\n: NULL;\r\ndump_one_vdso_page(pg, upg);\r\n}\r\n}\r\nif (!vma || !is_32bit_task()) {\r\nprintk("vDSO64 @ %016lx:\n", (unsigned long)vdso64_kbase);\r\nfor (i=0; i<vdso64_pages; i++) {\r\nstruct page *pg = virt_to_page(vdso64_kbase +\r\ni*PAGE_SIZE);\r\nstruct page *upg = (vma && vma->vm_mm) ?\r\nfollow_page(vma, vma->vm_start + i*PAGE_SIZE, 0)\r\n: NULL;\r\ndump_one_vdso_page(pg, upg);\r\n}\r\n}\r\n}\r\nint arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct page **vdso_pagelist;\r\nunsigned long vdso_pages;\r\nunsigned long vdso_base;\r\nint rc;\r\nif (!vdso_ready)\r\nreturn 0;\r\n#ifdef CONFIG_PPC64\r\nif (is_32bit_task()) {\r\nvdso_pagelist = vdso32_pagelist;\r\nvdso_pages = vdso32_pages;\r\nvdso_base = VDSO32_MBASE;\r\n} else {\r\nvdso_pagelist = vdso64_pagelist;\r\nvdso_pages = vdso64_pages;\r\nvdso_base = 0;\r\n}\r\n#else\r\nvdso_pagelist = vdso32_pagelist;\r\nvdso_pages = vdso32_pages;\r\nvdso_base = VDSO32_MBASE;\r\n#endif\r\ncurrent->mm->context.vdso_base = 0;\r\nif (vdso_pages == 0)\r\nreturn 0;\r\nvdso_pages ++;\r\ndown_write(&mm->mmap_sem);\r\nvdso_base = get_unmapped_area(NULL, vdso_base,\r\n(vdso_pages << PAGE_SHIFT) +\r\n((VDSO_ALIGNMENT - 1) & PAGE_MASK),\r\n0, 0);\r\nif (IS_ERR_VALUE(vdso_base)) {\r\nrc = vdso_base;\r\ngoto fail_mmapsem;\r\n}\r\nvdso_base = ALIGN(vdso_base, VDSO_ALIGNMENT);\r\ncurrent->mm->context.vdso_base = vdso_base;\r\nrc = install_special_mapping(mm, vdso_base, vdso_pages << PAGE_SHIFT,\r\nVM_READ|VM_EXEC|\r\nVM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC|\r\nVM_ALWAYSDUMP,\r\nvdso_pagelist);\r\nif (rc) {\r\ncurrent->mm->context.vdso_base = 0;\r\ngoto fail_mmapsem;\r\n}\r\nup_write(&mm->mmap_sem);\r\nreturn 0;\r\nfail_mmapsem:\r\nup_write(&mm->mmap_sem);\r\nreturn rc;\r\n}\r\nconst char *arch_vma_name(struct vm_area_struct *vma)\r\n{\r\nif (vma->vm_mm && vma->vm_start == vma->vm_mm->context.vdso_base)\r\nreturn "[vdso]";\r\nreturn NULL;\r\n}\r\nstatic void * __init find_section32(Elf32_Ehdr *ehdr, const char *secname,\r\nunsigned long *size)\r\n{\r\nElf32_Shdr *sechdrs;\r\nunsigned int i;\r\nchar *secnames;\r\nsechdrs = (void *)ehdr + ehdr->e_shoff;\r\nsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\r\nfor (i = 1; i < ehdr->e_shnum; i++) {\r\nif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\r\nif (size)\r\n*size = sechdrs[i].sh_size;\r\nreturn (void *)ehdr + sechdrs[i].sh_offset;\r\n}\r\n}\r\n*size = 0;\r\nreturn NULL;\r\n}\r\nstatic Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\r\nconst char *symname)\r\n{\r\nunsigned int i;\r\nchar name[MAX_SYMNAME], *c;\r\nfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\r\nif (lib->dynsym[i].st_name == 0)\r\ncontinue;\r\nstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\r\nMAX_SYMNAME);\r\nc = strchr(name, '@');\r\nif (c)\r\n*c = 0;\r\nif (strcmp(symname, name) == 0)\r\nreturn &lib->dynsym[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned long __init find_function32(struct lib32_elfinfo *lib,\r\nconst char *symname)\r\n{\r\nElf32_Sym *sym = find_symbol32(lib, symname);\r\nif (sym == NULL) {\r\nprintk(KERN_WARNING "vDSO32: function %s not found !\n",\r\nsymname);\r\nreturn 0;\r\n}\r\nreturn sym->st_value - VDSO32_LBASE;\r\n}\r\nstatic int __init vdso_do_func_patch32(struct lib32_elfinfo *v32,\r\nstruct lib64_elfinfo *v64,\r\nconst char *orig, const char *fix)\r\n{\r\nElf32_Sym *sym32_gen, *sym32_fix;\r\nsym32_gen = find_symbol32(v32, orig);\r\nif (sym32_gen == NULL) {\r\nprintk(KERN_ERR "vDSO32: Can't find symbol %s !\n", orig);\r\nreturn -1;\r\n}\r\nif (fix == NULL) {\r\nsym32_gen->st_name = 0;\r\nreturn 0;\r\n}\r\nsym32_fix = find_symbol32(v32, fix);\r\nif (sym32_fix == NULL) {\r\nprintk(KERN_ERR "vDSO32: Can't find symbol %s !\n", fix);\r\nreturn -1;\r\n}\r\nsym32_gen->st_value = sym32_fix->st_value;\r\nsym32_gen->st_size = sym32_fix->st_size;\r\nsym32_gen->st_info = sym32_fix->st_info;\r\nsym32_gen->st_other = sym32_fix->st_other;\r\nsym32_gen->st_shndx = sym32_fix->st_shndx;\r\nreturn 0;\r\n}\r\nstatic void * __init find_section64(Elf64_Ehdr *ehdr, const char *secname,\r\nunsigned long *size)\r\n{\r\nElf64_Shdr *sechdrs;\r\nunsigned int i;\r\nchar *secnames;\r\nsechdrs = (void *)ehdr + ehdr->e_shoff;\r\nsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\r\nfor (i = 1; i < ehdr->e_shnum; i++) {\r\nif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\r\nif (size)\r\n*size = sechdrs[i].sh_size;\r\nreturn (void *)ehdr + sechdrs[i].sh_offset;\r\n}\r\n}\r\nif (size)\r\n*size = 0;\r\nreturn NULL;\r\n}\r\nstatic Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\r\nconst char *symname)\r\n{\r\nunsigned int i;\r\nchar name[MAX_SYMNAME], *c;\r\nfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\r\nif (lib->dynsym[i].st_name == 0)\r\ncontinue;\r\nstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\r\nMAX_SYMNAME);\r\nc = strchr(name, '@');\r\nif (c)\r\n*c = 0;\r\nif (strcmp(symname, name) == 0)\r\nreturn &lib->dynsym[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned long __init find_function64(struct lib64_elfinfo *lib,\r\nconst char *symname)\r\n{\r\nElf64_Sym *sym = find_symbol64(lib, symname);\r\nif (sym == NULL) {\r\nprintk(KERN_WARNING "vDSO64: function %s not found !\n",\r\nsymname);\r\nreturn 0;\r\n}\r\n#ifdef VDS64_HAS_DESCRIPTORS\r\nreturn *((u64 *)(vdso64_kbase + sym->st_value - VDSO64_LBASE)) -\r\nVDSO64_LBASE;\r\n#else\r\nreturn sym->st_value - VDSO64_LBASE;\r\n#endif\r\n}\r\nstatic int __init vdso_do_func_patch64(struct lib32_elfinfo *v32,\r\nstruct lib64_elfinfo *v64,\r\nconst char *orig, const char *fix)\r\n{\r\nElf64_Sym *sym64_gen, *sym64_fix;\r\nsym64_gen = find_symbol64(v64, orig);\r\nif (sym64_gen == NULL) {\r\nprintk(KERN_ERR "vDSO64: Can't find symbol %s !\n", orig);\r\nreturn -1;\r\n}\r\nif (fix == NULL) {\r\nsym64_gen->st_name = 0;\r\nreturn 0;\r\n}\r\nsym64_fix = find_symbol64(v64, fix);\r\nif (sym64_fix == NULL) {\r\nprintk(KERN_ERR "vDSO64: Can't find symbol %s !\n", fix);\r\nreturn -1;\r\n}\r\nsym64_gen->st_value = sym64_fix->st_value;\r\nsym64_gen->st_size = sym64_fix->st_size;\r\nsym64_gen->st_info = sym64_fix->st_info;\r\nsym64_gen->st_other = sym64_fix->st_other;\r\nsym64_gen->st_shndx = sym64_fix->st_shndx;\r\nreturn 0;\r\n}\r\nstatic __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\r\nstruct lib64_elfinfo *v64)\r\n{\r\nvoid *sect;\r\nv32->dynsym = find_section32(v32->hdr, ".dynsym", &v32->dynsymsize);\r\nv32->dynstr = find_section32(v32->hdr, ".dynstr", NULL);\r\nif (v32->dynsym == NULL || v32->dynstr == NULL) {\r\nprintk(KERN_ERR "vDSO32: required symbol section not found\n");\r\nreturn -1;\r\n}\r\nsect = find_section32(v32->hdr, ".text", NULL);\r\nif (sect == NULL) {\r\nprintk(KERN_ERR "vDSO32: the .text section was not found\n");\r\nreturn -1;\r\n}\r\nv32->text = sect - vdso32_kbase;\r\n#ifdef CONFIG_PPC64\r\nv64->dynsym = find_section64(v64->hdr, ".dynsym", &v64->dynsymsize);\r\nv64->dynstr = find_section64(v64->hdr, ".dynstr", NULL);\r\nif (v64->dynsym == NULL || v64->dynstr == NULL) {\r\nprintk(KERN_ERR "vDSO64: required symbol section not found\n");\r\nreturn -1;\r\n}\r\nsect = find_section64(v64->hdr, ".text", NULL);\r\nif (sect == NULL) {\r\nprintk(KERN_ERR "vDSO64: the .text section was not found\n");\r\nreturn -1;\r\n}\r\nv64->text = sect - vdso64_kbase;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic __init void vdso_setup_trampolines(struct lib32_elfinfo *v32,\r\nstruct lib64_elfinfo *v64)\r\n{\r\n#ifdef CONFIG_PPC64\r\nvdso64_rt_sigtramp = find_function64(v64, "__kernel_sigtramp_rt64");\r\n#endif\r\nvdso32_sigtramp = find_function32(v32, "__kernel_sigtramp32");\r\nvdso32_rt_sigtramp = find_function32(v32, "__kernel_sigtramp_rt32");\r\n}\r\nstatic __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\r\nstruct lib64_elfinfo *v64)\r\n{\r\nElf32_Sym *sym32;\r\n#ifdef CONFIG_PPC64\r\nElf64_Sym *sym64;\r\nsym64 = find_symbol64(v64, "__kernel_datapage_offset");\r\nif (sym64 == NULL) {\r\nprintk(KERN_ERR "vDSO64: Can't find symbol "\r\n"__kernel_datapage_offset !\n");\r\nreturn -1;\r\n}\r\n*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\r\n(vdso64_pages << PAGE_SHIFT) -\r\n(sym64->st_value - VDSO64_LBASE);\r\n#endif\r\nsym32 = find_symbol32(v32, "__kernel_datapage_offset");\r\nif (sym32 == NULL) {\r\nprintk(KERN_ERR "vDSO32: Can't find symbol "\r\n"__kernel_datapage_offset !\n");\r\nreturn -1;\r\n}\r\n*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\r\n(vdso32_pages << PAGE_SHIFT) -\r\n(sym32->st_value - VDSO32_LBASE);\r\nreturn 0;\r\n}\r\nstatic __init int vdso_fixup_features(struct lib32_elfinfo *v32,\r\nstruct lib64_elfinfo *v64)\r\n{\r\nvoid *start32;\r\nunsigned long size32;\r\n#ifdef CONFIG_PPC64\r\nvoid *start64;\r\nunsigned long size64;\r\nstart64 = find_section64(v64->hdr, "__ftr_fixup", &size64);\r\nif (start64)\r\ndo_feature_fixups(cur_cpu_spec->cpu_features,\r\nstart64, start64 + size64);\r\nstart64 = find_section64(v64->hdr, "__mmu_ftr_fixup", &size64);\r\nif (start64)\r\ndo_feature_fixups(cur_cpu_spec->mmu_features,\r\nstart64, start64 + size64);\r\nstart64 = find_section64(v64->hdr, "__fw_ftr_fixup", &size64);\r\nif (start64)\r\ndo_feature_fixups(powerpc_firmware_features,\r\nstart64, start64 + size64);\r\nstart64 = find_section64(v64->hdr, "__lwsync_fixup", &size64);\r\nif (start64)\r\ndo_lwsync_fixups(cur_cpu_spec->cpu_features,\r\nstart64, start64 + size64);\r\n#endif\r\nstart32 = find_section32(v32->hdr, "__ftr_fixup", &size32);\r\nif (start32)\r\ndo_feature_fixups(cur_cpu_spec->cpu_features,\r\nstart32, start32 + size32);\r\nstart32 = find_section32(v32->hdr, "__mmu_ftr_fixup", &size32);\r\nif (start32)\r\ndo_feature_fixups(cur_cpu_spec->mmu_features,\r\nstart32, start32 + size32);\r\n#ifdef CONFIG_PPC64\r\nstart32 = find_section32(v32->hdr, "__fw_ftr_fixup", &size32);\r\nif (start32)\r\ndo_feature_fixups(powerpc_firmware_features,\r\nstart32, start32 + size32);\r\n#endif\r\nstart32 = find_section32(v32->hdr, "__lwsync_fixup", &size32);\r\nif (start32)\r\ndo_lwsync_fixups(cur_cpu_spec->cpu_features,\r\nstart32, start32 + size32);\r\nreturn 0;\r\n}\r\nstatic __init int vdso_fixup_alt_funcs(struct lib32_elfinfo *v32,\r\nstruct lib64_elfinfo *v64)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vdso_patches); i++) {\r\nstruct vdso_patch_def *patch = &vdso_patches[i];\r\nint match = (cur_cpu_spec->cpu_features & patch->ftr_mask)\r\n== patch->ftr_value;\r\nif (!match)\r\ncontinue;\r\nDBG("replacing %s with %s...\n", patch->gen_name,\r\npatch->fix_name ? "NONE" : patch->fix_name);\r\nvdso_do_func_patch32(v32, v64, patch->gen_name,\r\npatch->fix_name);\r\n#ifdef CONFIG_PPC64\r\nvdso_do_func_patch64(v32, v64, patch->gen_name,\r\npatch->fix_name);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int vdso_setup(void)\r\n{\r\nstruct lib32_elfinfo v32;\r\nstruct lib64_elfinfo v64;\r\nv32.hdr = vdso32_kbase;\r\n#ifdef CONFIG_PPC64\r\nv64.hdr = vdso64_kbase;\r\n#endif\r\nif (vdso_do_find_sections(&v32, &v64))\r\nreturn -1;\r\nif (vdso_fixup_datapage(&v32, &v64))\r\nreturn -1;\r\nif (vdso_fixup_features(&v32, &v64))\r\nreturn -1;\r\nif (vdso_fixup_alt_funcs(&v32, &v64))\r\nreturn -1;\r\nvdso_setup_trampolines(&v32, &v64);\r\nreturn 0;\r\n}\r\nstatic void __init vdso_setup_syscall_map(void)\r\n{\r\nunsigned int i;\r\nextern unsigned long *sys_call_table;\r\nextern unsigned long sys_ni_syscall;\r\nfor (i = 0; i < __NR_syscalls; i++) {\r\n#ifdef CONFIG_PPC64\r\nif (sys_call_table[i*2] != sys_ni_syscall)\r\nvdso_data->syscall_map_64[i >> 5] |=\r\n0x80000000UL >> (i & 0x1f);\r\nif (sys_call_table[i*2+1] != sys_ni_syscall)\r\nvdso_data->syscall_map_32[i >> 5] |=\r\n0x80000000UL >> (i & 0x1f);\r\n#else\r\nif (sys_call_table[i] != sys_ni_syscall)\r\nvdso_data->syscall_map_32[i >> 5] |=\r\n0x80000000UL >> (i & 0x1f);\r\n#endif\r\n}\r\n}\r\nstatic int __init vdso_init(void)\r\n{\r\nint i;\r\n#ifdef CONFIG_PPC64\r\nstrcpy((char *)vdso_data->eye_catcher, "SYSTEMCFG:PPC64");\r\nvdso_data->version.major = SYSTEMCFG_MAJOR;\r\nvdso_data->version.minor = SYSTEMCFG_MINOR;\r\nvdso_data->processor = mfspr(SPRN_PVR);\r\nvdso_data->platform = machine_is(iseries) ? 0x200 : 0x100;\r\nif (firmware_has_feature(FW_FEATURE_LPAR))\r\nvdso_data->platform |= 1;\r\nvdso_data->physicalMemorySize = memblock_phys_mem_size();\r\nvdso_data->dcache_size = ppc64_caches.dsize;\r\nvdso_data->dcache_line_size = ppc64_caches.dline_size;\r\nvdso_data->icache_size = ppc64_caches.isize;\r\nvdso_data->icache_line_size = ppc64_caches.iline_size;\r\nvdso_data->dcache_block_size = ppc64_caches.dline_size;\r\nvdso_data->icache_block_size = ppc64_caches.iline_size;\r\nvdso_data->dcache_log_block_size = ppc64_caches.log_dline_size;\r\nvdso_data->icache_log_block_size = ppc64_caches.log_iline_size;\r\nvdso64_pages = (&vdso64_end - &vdso64_start) >> PAGE_SHIFT;\r\nDBG("vdso64_kbase: %p, 0x%x pages\n", vdso64_kbase, vdso64_pages);\r\n#else\r\nvdso_data->dcache_block_size = L1_CACHE_BYTES;\r\nvdso_data->dcache_log_block_size = L1_CACHE_SHIFT;\r\nvdso_data->icache_block_size = L1_CACHE_BYTES;\r\nvdso_data->icache_log_block_size = L1_CACHE_SHIFT;\r\n#endif\r\nvdso32_pages = (&vdso32_end - &vdso32_start) >> PAGE_SHIFT;\r\nDBG("vdso32_kbase: %p, 0x%x pages\n", vdso32_kbase, vdso32_pages);\r\nvdso_setup_syscall_map();\r\nif (vdso_setup()) {\r\nprintk(KERN_ERR "vDSO setup failure, not enabled !\n");\r\nvdso32_pages = 0;\r\n#ifdef CONFIG_PPC64\r\nvdso64_pages = 0;\r\n#endif\r\nreturn 0;\r\n}\r\nvdso32_pagelist = kzalloc(sizeof(struct page *) * (vdso32_pages + 2),\r\nGFP_KERNEL);\r\nBUG_ON(vdso32_pagelist == NULL);\r\nfor (i = 0; i < vdso32_pages; i++) {\r\nstruct page *pg = virt_to_page(vdso32_kbase + i*PAGE_SIZE);\r\nClearPageReserved(pg);\r\nget_page(pg);\r\nvdso32_pagelist[i] = pg;\r\n}\r\nvdso32_pagelist[i++] = virt_to_page(vdso_data);\r\nvdso32_pagelist[i] = NULL;\r\n#ifdef CONFIG_PPC64\r\nvdso64_pagelist = kzalloc(sizeof(struct page *) * (vdso64_pages + 2),\r\nGFP_KERNEL);\r\nBUG_ON(vdso64_pagelist == NULL);\r\nfor (i = 0; i < vdso64_pages; i++) {\r\nstruct page *pg = virt_to_page(vdso64_kbase + i*PAGE_SIZE);\r\nClearPageReserved(pg);\r\nget_page(pg);\r\nvdso64_pagelist[i] = pg;\r\n}\r\nvdso64_pagelist[i++] = virt_to_page(vdso_data);\r\nvdso64_pagelist[i] = NULL;\r\n#endif\r\nget_page(virt_to_page(vdso_data));\r\nsmp_wmb();\r\nvdso_ready = 1;\r\nreturn 0;\r\n}\r\nint in_gate_area_no_mm(unsigned long addr)\r\n{\r\nreturn 0;\r\n}\r\nint in_gate_area(struct mm_struct *mm, unsigned long addr)\r\n{\r\nreturn 0;\r\n}\r\nstruct vm_area_struct *get_gate_vma(struct mm_struct *mm)\r\n{\r\nreturn NULL;\r\n}
