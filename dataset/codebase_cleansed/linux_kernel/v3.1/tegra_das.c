static inline void tegra_das_write(u32 reg, u32 val)\r\n{\r\n__raw_writel(val, das->regs + reg);\r\n}\r\nstatic inline u32 tegra_das_read(u32 reg)\r\n{\r\nreturn __raw_readl(das->regs + reg);\r\n}\r\nint tegra_das_connect_dap_to_dac(int dap, int dac)\r\n{\r\nu32 addr;\r\nu32 reg;\r\nif (!das)\r\nreturn -ENODEV;\r\naddr = TEGRA_DAS_DAP_CTRL_SEL +\r\n(dap * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);\r\nreg = dac << TEGRA_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P;\r\ntegra_das_write(addr, reg);\r\nreturn 0;\r\n}\r\nint tegra_das_connect_dap_to_dap(int dap, int otherdap, int master,\r\nint sdata1rx, int sdata2rx)\r\n{\r\nu32 addr;\r\nu32 reg;\r\nif (!das)\r\nreturn -ENODEV;\r\naddr = TEGRA_DAS_DAP_CTRL_SEL +\r\n(dap * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);\r\nreg = otherdap << TEGRA_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P |\r\n!!sdata2rx << TEGRA_DAS_DAP_CTRL_SEL_DAP_SDATA2_TX_RX_P |\r\n!!sdata1rx << TEGRA_DAS_DAP_CTRL_SEL_DAP_SDATA1_TX_RX_P |\r\n!!master << TEGRA_DAS_DAP_CTRL_SEL_DAP_MS_SEL_P;\r\ntegra_das_write(addr, reg);\r\nreturn 0;\r\n}\r\nint tegra_das_connect_dac_to_dap(int dac, int dap)\r\n{\r\nu32 addr;\r\nu32 reg;\r\nif (!das)\r\nreturn -ENODEV;\r\naddr = TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL +\r\n(dac * TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);\r\nreg = dap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_CLK_SEL_P |\r\ndap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA1_SEL_P |\r\ndap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA2_SEL_P;\r\ntegra_das_write(addr, reg);\r\nreturn 0;\r\n}\r\nstatic int tegra_das_show(struct seq_file *s, void *unused)\r\n{\r\nint i;\r\nu32 addr;\r\nu32 reg;\r\nfor (i = 0; i < TEGRA_DAS_DAP_CTRL_SEL_COUNT; i++) {\r\naddr = TEGRA_DAS_DAP_CTRL_SEL +\r\n(i * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);\r\nreg = tegra_das_read(addr);\r\nseq_printf(s, "TEGRA_DAS_DAP_CTRL_SEL[%d] = %08x\n", i, reg);\r\n}\r\nfor (i = 0; i < TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_COUNT; i++) {\r\naddr = TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL +\r\n(i * TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);\r\nreg = tegra_das_read(addr);\r\nseq_printf(s, "TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL[%d] = %08x\n",\r\ni, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_das_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, tegra_das_show, inode->i_private);\r\n}\r\nstatic void tegra_das_debug_add(struct tegra_das *das)\r\n{\r\ndas->debug = debugfs_create_file(DRV_NAME, S_IRUGO,\r\nsnd_soc_debugfs_root, das,\r\n&tegra_das_debug_fops);\r\n}\r\nstatic void tegra_das_debug_remove(struct tegra_das *das)\r\n{\r\nif (das->debug)\r\ndebugfs_remove(das->debug);\r\n}\r\nstatic inline void tegra_das_debug_add(struct tegra_das *das)\r\n{\r\n}\r\nstatic inline void tegra_das_debug_remove(struct tegra_das *das)\r\n{\r\n}\r\nstatic int __devinit tegra_das_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res, *region;\r\nint ret = 0;\r\nif (das)\r\nreturn -ENODEV;\r\ndas = kzalloc(sizeof(struct tegra_das), GFP_KERNEL);\r\nif (!das) {\r\ndev_err(&pdev->dev, "Can't allocate tegra_das\n");\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\ndas->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "No memory resource\n");\r\nret = -ENODEV;\r\ngoto err_free;\r\n}\r\nregion = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (!region) {\r\ndev_err(&pdev->dev, "Memory region already claimed\n");\r\nret = -EBUSY;\r\ngoto err_free;\r\n}\r\ndas->regs = ioremap(res->start, resource_size(res));\r\nif (!das->regs) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_release;\r\n}\r\ntegra_das_debug_add(das);\r\nplatform_set_drvdata(pdev, das);\r\nreturn 0;\r\nerr_release:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_free:\r\nkfree(das);\r\ndas = 0;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int __devexit tegra_das_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nif (!das)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, NULL);\r\ntegra_das_debug_remove(das);\r\niounmap(das->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(das);\r\ndas = 0;\r\nreturn 0;\r\n}\r\nstatic int __init tegra_das_modinit(void)\r\n{\r\nreturn platform_driver_register(&tegra_das_driver);\r\n}\r\nstatic void __exit tegra_das_modexit(void)\r\n{\r\nplatform_driver_unregister(&tegra_das_driver);\r\n}
