static int qt2_calc_num_ports(struct usb_serial *serial)\r\n{\r\nint num_ports;\r\nint flag_as_400;\r\nswitch (serial->dev->descriptor.idProduct) {\r\ncase QUATECH_SSU2_100:\r\nnum_ports = 1;\r\nbreak;\r\ncase QUATECH_DSU2_400:\r\nflag_as_400 = true;\r\ncase QUATECH_DSU2_100:\r\nnum_ports = 2;\r\nbreak;\r\ncase QUATECH_QSU2_400:\r\nflag_as_400 = true;\r\ncase QUATECH_QSU2_100:\r\nnum_ports = 4;\r\nbreak;\r\ncase QUATECH_ESU2_400:\r\nflag_as_400 = true;\r\ncase QUATECH_ESU2_100:\r\nnum_ports = 8;\r\nbreak;\r\ndefault:\r\nnum_ports = 1;\r\nbreak;\r\n}\r\nreturn num_ports;\r\n}\r\nstatic int qt2_attach(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct quatech2_port *qt2_port;\r\nstruct quatech2_dev *qt2_dev;\r\nint i;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_serial_port *port0;\r\ndbg("%s(): Endpoints: %d bulk in, %d bulk out, %d interrupt in",\r\n__func__, serial->num_bulk_in,\r\nserial->num_bulk_out, serial->num_interrupt_in);\r\nif ((serial->num_bulk_in != 1) || (serial->num_bulk_out != 1)) {\r\ndbg("Device has wrong number of bulk endpoints!");\r\nreturn -ENODEV;\r\n}\r\niface_desc = serial->interface->cur_altsetting;\r\nqt2_dev = kzalloc(sizeof(*qt2_dev), GFP_KERNEL);\r\nif (!qt2_dev) {\r\ndbg("%s: kmalloc for quatech2_dev failed!",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nqt2_dev->open_ports = 0;\r\nqt2_set_dev_private(serial, qt2_dev);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nqt2_port = kzalloc(sizeof(*qt2_port), GFP_KERNEL);\r\nif (!qt2_port) {\r\ndbg("%s: kmalloc for quatech2_port (%d) failed!.",\r\n__func__, i);\r\nreturn -ENOMEM;\r\n}\r\nqt2_port->open_count = 0;\r\nspin_lock_init(&qt2_port->lock);\r\nmutex_init(&qt2_port->modelock);\r\nqt2_set_port_private(port, qt2_port);\r\n}\r\nif (serial_paranoia_check(serial, __func__))\r\nreturn -ENODEV;\r\nport0 = serial->port[0];\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif ((endpoint->bEndpointAddress & 0x80) &&\r\n((endpoint->bmAttributes & 3) == 0x02)) {\r\ndbg("found bulk in at %#.2x",\r\nendpoint->bEndpointAddress);\r\n}\r\nif (((endpoint->bEndpointAddress & 0x80) == 0x00) &&\r\n((endpoint->bmAttributes & 3) == 0x02)) {\r\ndbg("found bulk out at %#.2x",\r\nendpoint->bEndpointAddress);\r\nqt2_dev->buffer_size = endpoint->wMaxPacketSize;\r\n}\r\n}\r\nif (qt2_boxpoweron(serial) < 0) {\r\ndbg("qt2_boxpoweron() failed");\r\ngoto startup_error;\r\n}\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nif (qt2_boxsetQMCR(serial, i, QU2BOX232) < 0) {\r\ndbg("qt2_boxsetQMCR() on port %d failed",\r\ni);\r\ngoto startup_error;\r\n}\r\n}\r\nreturn 0;\r\nstartup_error:\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nqt2_port = qt2_get_port_private(port);\r\nkfree(qt2_port);\r\nqt2_set_port_private(port, NULL);\r\n}\r\nqt2_dev = qt2_get_dev_private(serial);\r\nkfree(qt2_dev);\r\nqt2_set_dev_private(serial, NULL);\r\ndbg("Exit fail %s\n", __func__);\r\nreturn -EIO;\r\n}\r\nstatic void qt2_release(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct quatech2_port *qt_port;\r\nint i;\r\ndbg("enterting %s", __func__);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nif (!port)\r\ncontinue;\r\nqt_port = usb_get_serial_port_data(port);\r\nkfree(qt_port);\r\nusb_set_serial_port_data(port, NULL);\r\n}\r\n}\r\nint qt2_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port0;\r\nstruct quatech2_port *port_extra;\r\nstruct quatech2_port *port0_extra;\r\nstruct quatech2_dev *dev_extra;\r\nstruct qt2_status_data ChannelData;\r\nunsigned short default_divisor = QU2BOXSPD9600;\r\nunsigned char default_LCR = QT2_SERIAL_8_DATA;\r\nint status;\r\nint result;\r\nif (port_paranoia_check(port, __func__))\r\nreturn -ENODEV;\r\ndbg("%s(): port %d", __func__, port->number);\r\nserial = port->serial;\r\nif (serial_paranoia_check(serial, __func__)) {\r\ndbg("usb_serial struct failed sanity check");\r\nreturn -ENODEV;\r\n}\r\ndev_extra = qt2_get_dev_private(serial);\r\nif (dev_extra == NULL) {\r\ndbg("device extra data pointer is null");\r\nreturn -ENODEV;\r\n}\r\nport0 = serial->port[0];\r\nif (port_paranoia_check(port0, __func__)) {\r\ndbg("port0 usb_serial_port struct failed sanity check");\r\nreturn -ENODEV;\r\n}\r\nport_extra = qt2_get_port_private(port);\r\nport0_extra = qt2_get_port_private(port0);\r\nif (port_extra == NULL || port0_extra == NULL) {\r\ndbg("failed to get private data for port or port0");\r\nreturn -ENODEV;\r\n}\r\nstatus = qt2_openboxchannel(serial, port->number,\r\n&ChannelData);\r\nif (status < 0) {\r\ndbg("qt2_openboxchannel on channel %d failed",\r\nport->number);\r\nreturn status;\r\n}\r\nport_extra->shadowLSR = ChannelData.line_status &\r\n(QT2_SERIAL_LSR_OE | QT2_SERIAL_LSR_PE |\r\nQT2_SERIAL_LSR_FE | QT2_SERIAL_LSR_BI);\r\nport_extra->shadowMSR = ChannelData.modem_status &\r\n(QT2_SERIAL_MSR_CTS | QT2_SERIAL_MSR_DSR |\r\nQT2_SERIAL_MSR_RI | QT2_SERIAL_MSR_CD);\r\ndbg("qt2_openboxchannel on channel %d completed.",\r\nport->number);\r\nstatus = qt2_conf_uart(serial, port->number, default_divisor,\r\ndefault_LCR);\r\nif (status < 0) {\r\ndbg("qt2_conf_uart() failed on channel %d",\r\nport->number);\r\nreturn status;\r\n}\r\ndbg("qt2_conf_uart() completed on channel %d",\r\nport->number);\r\ndbg("port0 bulk in endpoint is %#.2x", port0->bulk_in_endpointAddress);\r\ndbg("port0 bulk out endpoint is %#.2x",\r\nport0->bulk_out_endpointAddress);\r\nif (port->write_urb == NULL) {\r\ndbg("port->write_urb == NULL, allocating one");\r\nport->write_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!port->write_urb) {\r\nerr("Allocating write URB failed");\r\nreturn -ENOMEM;\r\n}\r\nport->bulk_out_size = dev_extra->buffer_size;\r\nport->bulk_out_buffer = kmalloc(port->bulk_out_size,\r\nGFP_KERNEL);\r\nif (!port->bulk_out_buffer) {\r\nerr("Couldn't allocate bulk_out_buffer");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (serial->dev == NULL)\r\ndbg("serial->dev == NULL");\r\ndbg("port->bulk_out_size is %d", port->bulk_out_size);\r\nusb_fill_bulk_urb(port->write_urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport0->bulk_out_endpointAddress),\r\nport->bulk_out_buffer,\r\nport->bulk_out_size,\r\nqt2_write_bulk_callback,\r\nport);\r\nport_extra->tx_pending_bytes = 0;\r\nif (dev_extra->open_ports == 0) {\r\nusb_fill_bulk_urb(port0->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport0->bulk_in_endpointAddress),\r\nport0->bulk_in_buffer,\r\nport0->bulk_in_size,\r\nqt2_read_bulk_callback, serial);\r\ndbg("port0 bulk in URB initialised");\r\ndev_extra->ReadBulkStopped = false;\r\nport_extra->read_urb_busy = true;\r\nresult = usb_submit_urb(port->read_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s(): Error %d submitting bulk in urb",\r\n__func__, result);\r\nport_extra->read_urb_busy = false;\r\ndev_extra->ReadBulkStopped = true;\r\n}\r\ndev_extra->current_port = port;\r\n}\r\ninit_waitqueue_head(&port_extra->wait);\r\nport_extra->open_count++;\r\nqt2_set_port_private(port, port_extra);\r\nqt2_set_port_private(serial->port[0], port0_extra);\r\nqt2_set_dev_private(serial, dev_extra);\r\ndev_extra->open_ports++;\r\nreturn 0;\r\n}\r\nstatic void qt2_close(struct usb_serial_port *port)\r\n{\r\nunsigned long jift;\r\nstruct quatech2_port *port_extra;\r\nstruct usb_serial *serial;\r\nstruct quatech2_dev *dev_extra;\r\n__u8 lsr_value = 0;\r\nint status;\r\ndbg("%s(): port %d", __func__, port->number);\r\nserial = port->serial;\r\ndev_extra = qt2_get_dev_private(serial);\r\nport_extra = qt2_get_port_private(port);\r\nport_extra->close_pending = true;\r\ndbg("%s(): port_extra->close_pending = true", __func__);\r\njift = jiffies + (10 * HZ);\r\ndo {\r\nstatus = qt2_box_get_register(serial, port->number,\r\nQT2_LINE_STATUS_REGISTER, &lsr_value);\r\nif (status < 0) {\r\ndbg("%s(): qt2_box_get_register failed", __func__);\r\nbreak;\r\n}\r\nif ((lsr_value & QT2_LSR_TEMT)) {\r\ndbg("UART done sending");\r\nbreak;\r\n}\r\nschedule();\r\n} while (jiffies <= jift);\r\nstatus = qt2_closeboxchannel(serial, port->number);\r\nif (status < 0)\r\ndbg("%s(): port %d qt2_box_open_close_channel failed",\r\n__func__, port->number);\r\nusb_free_urb(port->write_urb);\r\nkfree(port->bulk_out_buffer);\r\nport->bulk_out_buffer = NULL;\r\nport->bulk_out_size = 0;\r\nport_extra->open_count--;\r\ndev_extra->open_ports--;\r\ndbg("%s(): Exit, dev_extra->open_ports = %d", __func__,\r\ndev_extra->open_ports);\r\n}\r\nstatic int qt2_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct usb_serial *serial;\r\n__u8 header_array[5];\r\nstruct quatech2_port *port_extra;\r\nint result;\r\nserial = port->serial;\r\nport_extra = qt2_get_port_private(port);\r\nif (serial == NULL)\r\nreturn -ENODEV;\r\ndbg("%s(): port %d, requested to write %d bytes, %d already pending",\r\n__func__, port->number, count, port_extra->tx_pending_bytes);\r\nif (count <= 0) {\r\ndbg("%s(): write request of <= 0 bytes", __func__);\r\nreturn 0;\r\n}\r\nif ((port->write_urb->status == -EINPROGRESS)) {\r\ndbg("%s(): already writing, port->write_urb->status == "\r\n"-EINPROGRESS", __func__);\r\nreturn 0;\r\n} else if (port_extra->tx_pending_bytes >= QT2_FIFO_DEPTH) {\r\ndbg("%s(): port transmit buffer is full!", __func__);\r\nreturn 0;\r\n}\r\nif (count > port->bulk_out_size - QT2_TX_HEADER_LENGTH) {\r\ncount = port->bulk_out_size - QT2_TX_HEADER_LENGTH;\r\ndbg("%s(): write request bigger than urb, only accepting "\r\n"%d bytes", __func__, count);\r\n}\r\nif (count > (QT2_FIFO_DEPTH - port_extra->tx_pending_bytes)) {\r\ncount = QT2_FIFO_DEPTH - port_extra->tx_pending_bytes;\r\ndbg("%s(): not enough room in buffer, only accepting %d bytes",\r\n__func__, count);\r\n}\r\nheader_array[0] = 0x1b;\r\nheader_array[1] = 0x1b;\r\nheader_array[2] = (__u8)port->number;\r\nheader_array[3] = (__u8)count;\r\nheader_array[4] = (__u8)count >> 8;\r\nmemcpy(port->write_urb->transfer_buffer, header_array,\r\nQT2_TX_HEADER_LENGTH);\r\nmemcpy(port->write_urb->transfer_buffer + 5, buf, count);\r\ndbg("%s(): first data byte to send = %#.2x", __func__, *buf);\r\nusb_fill_bulk_urb(port->write_urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, count + 5,\r\n(qt2_write_bulk_callback), port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (result) {\r\nresult = 0;\r\ndbg("%s(): failed submitting write urb, error %d",\r\n__func__, result);\r\n} else {\r\nport_extra->tx_pending_bytes += count;\r\nresult = count;\r\ndbg("%s(): submitted write urb, wrote %d bytes, "\r\n"total pending bytes %d",\r\n__func__, result, port_extra->tx_pending_bytes);\r\n}\r\nreturn result;\r\n}\r\nstatic int qt2_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct quatech2_port *port_extra;\r\nint room = 0;\r\nport_extra = qt2_get_port_private(port);\r\nif (port_extra->close_pending == true) {\r\ndbg("%s(): port_extra->close_pending == true", __func__);\r\nreturn -ENODEV;\r\n}\r\nroom = (QT2_FIFO_DEPTH - port_extra->tx_pending_bytes);\r\nif (room > port->bulk_out_size - QT2_TX_HEADER_LENGTH)\r\nroom = port->bulk_out_size - QT2_TX_HEADER_LENGTH;\r\ndbg("%s(): port %d: write room is %d", __func__, port->number, room);\r\nreturn room;\r\n}\r\nstatic int qt2_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct quatech2_port *port_extra;\r\nport_extra = qt2_get_port_private(port);\r\ndbg("%s(): port %d: chars_in_buffer = %d", __func__,\r\nport->number, port_extra->tx_pending_bytes);\r\nreturn port_extra->tx_pending_bytes;\r\n}\r\nstatic int qt2_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\n__u8 mcr_value;\r\n__u8 msr_value;\r\nunsigned short prev_msr_value;\r\nstruct quatech2_port *port_extra;\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned int value;\r\nunsigned int UartNumber;\r\nif (serial == NULL)\r\nreturn -ENODEV;\r\nUartNumber = tty->index - serial->minor;\r\nport_extra = qt2_get_port_private(port);\r\ndbg("%s(): port %d, UartNumber %d, tty =0x%p", __func__,\r\nport->number, UartNumber, tty);\r\nif (cmd == TIOCMBIS || cmd == TIOCMBIC) {\r\nif (qt2_box_get_register(port->serial, UartNumber,\r\nQT2_MODEM_CONTROL_REGISTER, &mcr_value) < 0)\r\nreturn -ESPIPE;\r\nif (copy_from_user(&value, (unsigned int *)arg,\r\nsizeof(value)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase TIOCMBIS:\r\nif (value & TIOCM_RTS)\r\nmcr_value |= QT2_SERIAL_MCR_RTS;\r\nif (value & TIOCM_DTR)\r\nmcr_value |= QT2_SERIAL_MCR_DTR;\r\nif (value & TIOCM_LOOP)\r\nmcr_value |= QT2_SERIAL_MCR_LOOP;\r\nbreak;\r\ncase TIOCMBIC:\r\nif (value & TIOCM_RTS)\r\nmcr_value &= ~QT2_SERIAL_MCR_RTS;\r\nif (value & TIOCM_DTR)\r\nmcr_value &= ~QT2_SERIAL_MCR_DTR;\r\nif (value & TIOCM_LOOP)\r\nmcr_value &= ~QT2_SERIAL_MCR_LOOP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (qt2_box_set_register(port->serial, UartNumber,\r\nQT2_MODEM_CONTROL_REGISTER, mcr_value) < 0) {\r\nreturn -ESPIPE;\r\n} else {\r\nport_extra->shadowMCR = mcr_value;\r\nreturn 0;\r\n}\r\n} else if (cmd == TIOCMIWAIT) {\r\ndbg("%s() port %d, cmd == TIOCMIWAIT enter",\r\n__func__, port->number);\r\nprev_msr_value = port_extra->shadowMSR & QT2_SERIAL_MSR_MASK;\r\nwhile (1) {\r\nadd_wait_queue(&port_extra->wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\ndbg("%s(): port %d, cmd == TIOCMIWAIT here\n",\r\n__func__, port->number);\r\nremove_wait_queue(&port_extra->wait, &wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nmsr_value = port_extra->shadowMSR & QT2_SERIAL_MSR_MASK;\r\nif (msr_value == prev_msr_value)\r\nreturn -EIO;\r\nif ((arg & TIOCM_RNG &&\r\n((prev_msr_value & QT2_SERIAL_MSR_RI) ==\r\n(msr_value & QT2_SERIAL_MSR_RI))) ||\r\n(arg & TIOCM_DSR &&\r\n((prev_msr_value & QT2_SERIAL_MSR_DSR) ==\r\n(msr_value & QT2_SERIAL_MSR_DSR))) ||\r\n(arg & TIOCM_CD &&\r\n((prev_msr_value & QT2_SERIAL_MSR_CD) ==\r\n(msr_value & QT2_SERIAL_MSR_CD))) ||\r\n(arg & TIOCM_CTS &&\r\n((prev_msr_value & QT2_SERIAL_MSR_CTS) ==\r\n(msr_value & QT2_SERIAL_MSR_CTS)))) {\r\nreturn 0;\r\n}\r\n}\r\n} else {\r\ndbg("%s(): No ioctl for that one. port = %d", __func__,\r\nport->number);\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic void qt2_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial;\r\nint baud, divisor, remainder;\r\nunsigned char LCR_change_to = 0;\r\nint status;\r\n__u16 UartNumber;\r\ndbg("%s(): port %d", __func__, port->number);\r\nserial = port->serial;\r\nUartNumber = port->number;\r\nif (old_termios && !tty_termios_hw_change(old_termios, tty->termios))\r\nreturn;\r\nswitch (tty->termios->c_cflag) {\r\ncase CS5:\r\nLCR_change_to |= QT2_SERIAL_5_DATA;\r\nbreak;\r\ncase CS6:\r\nLCR_change_to |= QT2_SERIAL_6_DATA;\r\nbreak;\r\ncase CS7:\r\nLCR_change_to |= QT2_SERIAL_7_DATA;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nLCR_change_to |= QT2_SERIAL_8_DATA;\r\nbreak;\r\n}\r\nif (tty->termios->c_cflag & PARENB) {\r\nif (tty->termios->c_cflag & PARODD)\r\nLCR_change_to |= QT2_SERIAL_ODD_PARITY;\r\nelse\r\nLCR_change_to |= QT2_SERIAL_EVEN_PARITY;\r\n}\r\ntty->termios->c_cflag &= ~CMSPAR;\r\nif (tty->termios->c_cflag & CSTOPB)\r\nLCR_change_to |= QT2_SERIAL_TWO_STOPB;\r\nelse\r\nLCR_change_to |= QT2_SERIAL_ONE_STOPB;\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud) {\r\nbaud = 9600;\r\n}\r\ndbg("%s(): got baud = %d", __func__, baud);\r\ndivisor = QT2_MAX_BAUD_RATE / baud;\r\nremainder = QT2_MAX_BAUD_RATE % baud;\r\nif (((remainder * 2) >= baud) && (baud != 110))\r\ndivisor++;\r\ndbg("%s(): setting divisor = %d, QT2_MAX_BAUD_RATE = %d , LCR = %#.2x",\r\n__func__, divisor, QT2_MAX_BAUD_RATE, LCR_change_to);\r\nstatus = qt2_boxsetuart(serial, UartNumber, (unsigned short) divisor,\r\nLCR_change_to);\r\nif (status < 0) {\r\ndbg("qt2_boxsetuart() failed");\r\nreturn;\r\n} else {\r\nbaud = QT2_MAX_BAUD_RATE / divisor;\r\ntty_encode_baud_rate(tty, baud, baud);\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\ndbg("%s(): Enabling HW flow control port %d", __func__,\r\nport->number);\r\nstatus = qt2_boxsethw_flowctl(serial, UartNumber, true);\r\nif (status < 0) {\r\ndbg("qt2_boxsethw_flowctl() failed");\r\nreturn;\r\n}\r\n} else {\r\ndbg("%s(): disabling HW flow control port %d", __func__,\r\nport->number);\r\nstatus = qt2_boxsethw_flowctl(serial, UartNumber, false);\r\nif (status < 0) {\r\ndbg("qt2_boxsethw_flowctl failed");\r\nreturn;\r\n}\r\n}\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus = qt2_boxsetsw_flowctl(serial, UartNumber, stop_char,\r\nstart_char);\r\nif (status < 0)\r\ndbg("qt2_boxsetsw_flowctl (enabled) failed");\r\n} else {\r\nstatus = qt2_boxunsetsw_flowctl(serial, UartNumber);\r\nif (status < 0)\r\ndbg("qt2_boxunsetsw_flowctl (disabling) failed");\r\n}\r\n}\r\nstatic int qt2_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\n__u8 mcr_value;\r\n__u8 msr_value;\r\nunsigned int result = 0;\r\nint status;\r\nunsigned int UartNumber;\r\nif (serial == NULL)\r\nreturn -ENODEV;\r\ndbg("%s(): port %d, tty =0x%p", __func__, port->number, tty);\r\nUartNumber = tty->index - serial->minor;\r\ndbg("UartNumber is %d", UartNumber);\r\nstatus = qt2_box_get_register(port->serial, UartNumber,\r\nQT2_MODEM_CONTROL_REGISTER, &mcr_value);\r\nif (status >= 0) {\r\nstatus = qt2_box_get_register(port->serial, UartNumber,\r\nQT2_MODEM_STATUS_REGISTER, &msr_value);\r\n}\r\nif (status >= 0) {\r\nresult = ((mcr_value & QT2_SERIAL_MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr_value & QT2_SERIAL_MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((msr_value & QT2_SERIAL_MSR_CTS) ? TIOCM_CTS : 0)\r\n| ((msr_value & QT2_SERIAL_MSR_CD) ? TIOCM_CAR : 0)\r\n| ((msr_value & QT2_SERIAL_MSR_RI) ? TIOCM_RI : 0)\r\n| ((msr_value & QT2_SERIAL_MSR_DSR) ? TIOCM_DSR : 0);\r\nreturn result;\r\n} else {\r\nreturn -ESPIPE;\r\n}\r\n}\r\nstatic int qt2_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\n__u8 mcr_value;\r\nint status;\r\nunsigned int UartNumber;\r\nif (serial == NULL)\r\nreturn -ENODEV;\r\nUartNumber = tty->index - serial->minor;\r\ndbg("%s(): port %d, UartNumber %d", __func__, port->number, UartNumber);\r\nstatus = qt2_box_get_register(port->serial, UartNumber,\r\nQT2_MODEM_CONTROL_REGISTER, &mcr_value);\r\nif (status < 0)\r\nreturn -ESPIPE;\r\nmcr_value &= ~(QT2_SERIAL_MCR_RTS | QT2_SERIAL_MCR_DTR |\r\nQT2_SERIAL_MCR_LOOP);\r\nif (set & TIOCM_RTS)\r\nmcr_value |= QT2_SERIAL_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr_value |= QT2_SERIAL_MCR_DTR;\r\nif (set & TIOCM_LOOP)\r\nmcr_value |= QT2_SERIAL_MCR_LOOP;\r\nstatus = qt2_box_set_register(port->serial, UartNumber,\r\nQT2_MODEM_CONTROL_REGISTER, mcr_value);\r\nif (status < 0)\r\nreturn -ESPIPE;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void qt2_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nstruct quatech2_port *port_extra;\r\n__u16 break_value;\r\nunsigned int result;\r\nport_extra = qt2_get_port_private(port);\r\nif (!serial) {\r\ndbg("%s(): port %d: no serial object", __func__, port->number);\r\nreturn;\r\n}\r\nif (break_state == -1)\r\nbreak_value = 1;\r\nelse\r\nbreak_value = 0;\r\ndbg("%s(): port %d, break_value %d", __func__, port->number,\r\nbreak_value);\r\nmutex_lock(&port_extra->modelock);\r\nif (!port_extra->open_count) {\r\ndbg("%s(): port not open", __func__);\r\ngoto exit;\r\n}\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_BREAK_CONTROL, 0x40, break_value,\r\nport->number, NULL, 0, 300);\r\nexit:\r\nmutex_unlock(&port_extra->modelock);\r\ndbg("%s(): exit port %d", __func__, port->number);\r\n}\r\nstatic void qt2_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nstruct quatech2_port *port_extra;\r\ndbg("%s(): port %d", __func__, port->number);\r\nport_extra = qt2_get_port_private(port);\r\nif (!serial) {\r\ndbg("%s(): enter port %d no serial object", __func__,\r\nport->number);\r\nreturn;\r\n}\r\nmutex_lock(&port_extra->modelock);\r\nif (!port_extra->open_count) {\r\ndbg("%s(): port not open", __func__);\r\ngoto exit;\r\n}\r\nif (serial->dev->descriptor.idProduct != QUATECH_SSU2_100)\r\nqt2_boxstoprx(serial, port->number, 1);\r\nport->throttled = 1;\r\nexit:\r\nmutex_unlock(&port_extra->modelock);\r\ndbg("%s(): port %d: setting port->throttled", __func__, port->number);\r\nreturn;\r\n}\r\nstatic void qt2_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nstruct quatech2_port *port_extra;\r\nstruct usb_serial_port *port0;\r\nstruct quatech2_dev *dev_extra;\r\nif (!serial) {\r\ndbg("%s() enter port %d no serial object!", __func__,\r\nport->number);\r\nreturn;\r\n}\r\ndbg("%s(): enter port %d", __func__, port->number);\r\ndev_extra = qt2_get_dev_private(serial);\r\nport_extra = qt2_get_port_private(port);\r\nport0 = serial->port[0];\r\nmutex_lock(&port_extra->modelock);\r\nif (!port_extra->open_count) {\r\ndbg("%s(): port %d not open", __func__, port->number);\r\ngoto exit;\r\n}\r\nif (port->throttled != 0) {\r\ndbg("%s(): port %d: unsetting port->throttled", __func__,\r\nport->number);\r\nport->throttled = 0;\r\nif (serial->dev->descriptor.idProduct != QUATECH_SSU2_100) {\r\nqt2_boxstoprx(serial, port->number, 0);\r\n} else if (dev_extra->ReadBulkStopped == true) {\r\nusb_fill_bulk_urb(port0->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport0->bulk_in_endpointAddress),\r\nport0->bulk_in_buffer,\r\nport0->bulk_in_size,\r\nqt2_read_bulk_callback,\r\nserial);\r\n}\r\n}\r\nexit:\r\nmutex_unlock(&port_extra->modelock);\r\ndbg("%s(): exit port %d", __func__, port->number);\r\nreturn;\r\n}\r\nstatic int qt2_boxpoweron(struct usb_serial *serial)\r\n{\r\nint result;\r\n__u8 Direcion;\r\nunsigned int pipe;\r\nDirecion = USBD_TRANSFER_DIRECTION_OUT;\r\npipe = usb_rcvctrlpipe(serial->dev, 0);\r\nresult = usb_control_msg(serial->dev, pipe, QT_SET_GET_DEVICE,\r\nDirecion, QU2BOXPWRON, 0x00, NULL, 0x00,\r\n5000);\r\nreturn result;\r\n}\r\nstatic int qt2_boxsetQMCR(struct usb_serial *serial, __u16 Uart_Number,\r\n__u8 QMCR_Value)\r\n{\r\nint result;\r\n__u16 PortSettings;\r\nPortSettings = (__u16)(QMCR_Value);\r\ndbg("%s(): Port = %d, PortSettings = 0x%x", __func__,\r\nUart_Number, PortSettings);\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_GET_SET_QMCR, 0x40, PortSettings,\r\n(__u16)Uart_Number, NULL, 0, 5000);\r\nreturn result;\r\n}\r\nstatic int port_paranoia_check(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port) {\r\ndbg("%s - port == NULL", function);\r\nreturn -1;\r\n}\r\nif (!port->serial) {\r\ndbg("%s - port->serial == NULL\n", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial_paranoia_check(struct usb_serial *serial,\r\nconst char *function)\r\n{\r\nif (!serial) {\r\ndbg("%s - serial == NULL\n", function);\r\nreturn -1;\r\n}\r\nif (!serial->type) {\r\ndbg("%s - serial->type == NULL!", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct quatech2_port *qt2_get_port_private(struct usb_serial_port\r\n*port)\r\n{\r\nreturn (struct quatech2_port *)usb_get_serial_port_data(port);\r\n}\r\nstatic inline void qt2_set_port_private(struct usb_serial_port *port,\r\nstruct quatech2_port *data)\r\n{\r\nusb_set_serial_port_data(port, (void *)data);\r\n}\r\nstatic inline struct quatech2_dev *qt2_get_dev_private(struct usb_serial\r\n*serial)\r\n{\r\nreturn (struct quatech2_dev *)usb_get_serial_data(serial);\r\n}\r\nstatic inline void qt2_set_dev_private(struct usb_serial *serial,\r\nstruct quatech2_dev *data)\r\n{\r\nusb_set_serial_data(serial, (void *)data);\r\n}\r\nstatic int qt2_openboxchannel(struct usb_serial *serial, __u16\r\nUart_Number, struct qt2_status_data *status)\r\n{\r\nint result;\r\n__u16 length;\r\n__u8 Direcion;\r\nunsigned int pipe;\r\nlength = sizeof(struct qt2_status_data);\r\nDirecion = USBD_TRANSFER_DIRECTION_IN;\r\npipe = usb_rcvctrlpipe(serial->dev, 0);\r\nresult = usb_control_msg(serial->dev, pipe, QT_OPEN_CLOSE_CHANNEL,\r\nDirecion, 0x00, Uart_Number, status, length, 5000);\r\nreturn result;\r\n}\r\nstatic int qt2_closeboxchannel(struct usb_serial *serial, __u16 Uart_Number)\r\n{\r\nint result;\r\n__u8 direcion;\r\nunsigned int pipe;\r\ndirecion = USBD_TRANSFER_DIRECTION_OUT;\r\npipe = usb_sndctrlpipe(serial->dev, 0);\r\nresult = usb_control_msg(serial->dev, pipe, QT_OPEN_CLOSE_CHANNEL,\r\ndirecion, 0, Uart_Number, NULL, 0, 5000);\r\nreturn result;\r\n}\r\nstatic int qt2_conf_uart(struct usb_serial *serial, unsigned short Uart_Number,\r\nunsigned short divisor, unsigned char LCR)\r\n{\r\nint result;\r\nunsigned short UartNumandLCR;\r\nUartNumandLCR = (LCR << 8) + Uart_Number;\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_GET_SET_UART, 0x40, divisor, UartNumandLCR,\r\nNULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic void qt2_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial *serial = urb->context;\r\nstruct quatech2_dev *dev_extra = qt2_get_dev_private(serial);\r\nstruct usb_serial_port *port0 = serial->port[0];\r\nstruct usb_serial_port *active = dev_extra->current_port;\r\nstruct quatech2_port *port0_extra = qt2_get_port_private(port0);\r\nstruct quatech2_port *active_extra = qt2_get_port_private(active);\r\nstruct tty_struct *tty_st;\r\nunsigned int RxCount;\r\nunsigned int i;\r\nint result;\r\nbool escapeflag;\r\ndbg("%s(): callback running, active port is %d", __func__,\r\nactive->number);\r\nif (urb->status) {\r\ndev_extra->ReadBulkStopped = true;\r\ndbg("%s(): nonzero bulk read status received: %d",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\nif (port_paranoia_check(port0, __func__) != 0) {\r\ndbg("%s - port_paranoia_check on port0 failed, exiting\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (port_paranoia_check(active, __func__) != 0) {\r\ndbg("%s - port_paranoia_check on current_port "\r\n"failed, exiting", __func__);\r\nreturn;\r\n}\r\nif (active_extra->close_pending == true) {\r\ndbg("%s - (active->close_pending == true", __func__);\r\nif (dev_extra->open_ports <= 0) {\r\ndev_extra->ReadBulkStopped = true;\r\ndbg("%s - (ReadBulkStopped == true;", __func__);\r\nreturn;\r\n}\r\n}\r\nif ((port0_extra->RxHolding == true) &&\r\n(serial->dev->descriptor.idProduct == QUATECH_SSU2_100)) {\r\ndev_extra->ReadBulkStopped = true;\r\nreturn;\r\n}\r\ntty_st = tty_port_tty_get(&active->port);\r\nif (!tty_st) {\r\ndbg("%s - bad tty pointer - exiting", __func__);\r\nreturn;\r\n}\r\nRxCount = urb->actual_length;\r\nif (RxCount) {\r\nfor (i = 0; i < RxCount ; ++i) {\r\nif ((i <= (RxCount - 3)) && (THISCHAR == 0x1b)\r\n&& (NEXTCHAR == 0x1b)) {\r\nescapeflag = false;\r\nswitch (THIRDCHAR) {\r\ncase 0x00:\r\nif (i > (RxCount - 4)) {\r\ndbg("Illegal escape sequences "\r\n"in received data");\r\nbreak;\r\n}\r\nqt2_process_line_status(active,\r\nFOURTHCHAR);\r\ni += 3;\r\nescapeflag = true;\r\nbreak;\r\ncase 0x01:\r\nif (i > (RxCount - 4)) {\r\ndbg("Illegal escape sequences "\r\n"in received data");\r\nbreak;\r\n}\r\nqt2_process_modem_status(active,\r\nFOURTHCHAR);\r\ni += 3;\r\nescapeflag = true;\r\nbreak;\r\ncase 0x02:\r\nif (i > (RxCount - 4)) {\r\ndbg("Illegal escape sequences "\r\n"in received data");\r\nbreak;\r\n}\r\nqt2_process_xmit_empty(active,\r\nFOURTHCHAR, FIFTHCHAR);\r\ni += 4;\r\nescapeflag = true;\r\nbreak;\r\ncase 0x03:\r\nif (i > (RxCount - 4)) {\r\ndbg("Illegal escape sequences "\r\n"in received data");\r\nbreak;\r\n}\r\nif (active_extra->open_count > 0)\r\ntty_flip_buffer_push(tty_st);\r\ndbg("Port Change: new port = %d",\r\nFOURTHCHAR);\r\nqt2_process_port_change(active,\r\nFOURTHCHAR);\r\ni += 3;\r\nescapeflag = true;\r\nactive = dev_extra->current_port;\r\nactive_extra =\r\nqt2_get_port_private(active);\r\ntty_st = tty_port_tty_get(\r\n&active->port);\r\nbreak;\r\ncase 0x04:\r\nif (i > (RxCount - 3)) {\r\ndbg("Illegal escape sequences "\r\n"in received data");\r\nbreak;\r\n}\r\nqt2_process_rcv_flush(active);\r\ni += 2;\r\nescapeflag = true;\r\nbreak;\r\ncase 0x05:\r\nif (i > (RxCount - 3)) {\r\ndbg("Illegal escape sequences "\r\n"in received data");\r\nbreak;\r\n}\r\nqt2_process_xmit_flush(active);\r\ni += 2;\r\nescapeflag = true;\r\nbreak;\r\ncase 0xff:\r\ndbg("No status sequence");\r\nqt2_process_rx_char(active, THISCHAR);\r\nqt2_process_rx_char(active, NEXTCHAR);\r\ni += 2;\r\nbreak;\r\ndefault:\r\nqt2_process_rx_char(active, THISCHAR);\r\ni += 1;\r\nbreak;\r\n}\r\nif (escapeflag == true)\r\ncontinue;\r\n}\r\nif (tty_st && urb->actual_length) {\r\ntty_buffer_request_room(tty_st, 1);\r\ntty_insert_flip_string(tty_st, &(\r\n(unsigned char *)\r\n(urb->transfer_buffer)\r\n)[i], 1);\r\n}\r\n}\r\ntty_flip_buffer_push(tty_st);\r\n}\r\nusb_fill_bulk_urb(port0->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev, port0->bulk_in_endpointAddress),\r\nport0->bulk_in_buffer, port0->bulk_in_size,\r\nqt2_read_bulk_callback, serial);\r\nresult = usb_submit_urb(port0->read_urb, GFP_ATOMIC);\r\nif (result) {\r\ndbg("%s(): failed resubmitting read urb, error %d",\r\n__func__, result);\r\n} else {\r\ndbg("%s() successfully resubmitted read urb", __func__);\r\nif (tty_st && RxCount) {\r\ntty_flip_buffer_push(tty_st);\r\ntty_schedule_flip(tty_st);\r\n}\r\n}\r\ndbg("%s() completed", __func__);\r\nreturn;\r\n}\r\nstatic void qt2_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = (struct usb_serial_port *)urb->context;\r\nstruct usb_serial *serial = port->serial;\r\ndbg("%s(): port %d", __func__, port->number);\r\nif (!serial) {\r\ndbg("%s(): bad serial pointer, exiting", __func__);\r\nreturn;\r\n}\r\nif (urb->status) {\r\ndbg("%s(): nonzero write bulk status received: %d",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\nschedule_work(&port->work);\r\ndbg("%s(): port %d exit", __func__, port->number);\r\nreturn;\r\n}\r\nstatic void qt2_process_line_status(struct usb_serial_port *port,\r\nunsigned char LineStatus)\r\n{\r\nstruct quatech2_port *port_extra = qt2_get_port_private(port);\r\nport_extra->shadowLSR = LineStatus & (QT2_SERIAL_LSR_OE |\r\nQT2_SERIAL_LSR_PE | QT2_SERIAL_LSR_FE | QT2_SERIAL_LSR_BI);\r\n}\r\nstatic void qt2_process_modem_status(struct usb_serial_port *port,\r\nunsigned char ModemStatus)\r\n{\r\nstruct quatech2_port *port_extra = qt2_get_port_private(port);\r\nport_extra->shadowMSR = ModemStatus;\r\nwake_up_interruptible(&port_extra->wait);\r\n}\r\nstatic void qt2_process_xmit_empty(struct usb_serial_port *port,\r\nunsigned char fourth_char, unsigned char fifth_char)\r\n{\r\nint byte_count;\r\nstruct quatech2_port *port_extra = qt2_get_port_private(port);\r\nbyte_count = (int)(fifth_char * 16);\r\nbyte_count += (int)fourth_char;\r\nport_extra->tx_pending_bytes -= byte_count;\r\ndbg("port %d: %d bytes reported sent, %d still pending", port->number,\r\nbyte_count, port_extra->tx_pending_bytes);\r\n}\r\nstatic void qt2_process_port_change(struct usb_serial_port *port,\r\nunsigned char New_Current_Port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct quatech2_dev *dev_extra = qt2_get_dev_private(serial);\r\ndev_extra->current_port = serial->port[New_Current_Port];\r\n}\r\nstatic void qt2_process_rcv_flush(struct usb_serial_port *port)\r\n{\r\nstruct quatech2_port *port_extra = qt2_get_port_private(port);\r\nport_extra->rcv_flush = true;\r\n}\r\nstatic void qt2_process_xmit_flush(struct usb_serial_port *port)\r\n{\r\nstruct quatech2_port *port_extra = qt2_get_port_private(port);\r\nport_extra->xmit_flush = true;\r\n}\r\nstatic void qt2_process_rx_char(struct usb_serial_port *port,\r\nunsigned char data)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&(port->port));\r\nstruct urb *urb = port->serial->port[0]->read_urb;\r\nif (tty && urb->actual_length) {\r\ntty_buffer_request_room(tty, 1);\r\ntty_insert_flip_string(tty, &data, 1);\r\n}\r\n}\r\nstatic int qt2_box_get_register(struct usb_serial *serial,\r\nunsigned char uart_number, unsigned short register_num,\r\n__u8 *pValue)\r\n{\r\nint result;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT2_GET_SET_REGISTER, 0xC0, register_num,\r\nuart_number, (void *)pValue, sizeof(*pValue), 300);\r\nreturn result;\r\n}\r\nstatic int qt2_box_set_register(struct usb_serial *serial,\r\nunsigned short Uart_Number, unsigned short Register_Num,\r\nunsigned short Value)\r\n{\r\nint result;\r\nunsigned short reg_and_byte;\r\nreg_and_byte = Value;\r\nreg_and_byte = reg_and_byte << 8;\r\nreg_and_byte = reg_and_byte + Register_Num;\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_GET_SET_REGISTER, 0x40, reg_and_byte,\r\nUart_Number, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt2_boxsetuart(struct usb_serial *serial, unsigned short Uart_Number,\r\nunsigned short default_divisor, unsigned char default_LCR)\r\n{\r\nunsigned short UartNumandLCR;\r\nUartNumandLCR = (default_LCR << 8) + Uart_Number;\r\nreturn usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_GET_SET_UART, 0x40, default_divisor, UartNumandLCR,\r\nNULL, 0, 300);\r\n}\r\nstatic int qt2_boxsethw_flowctl(struct usb_serial *serial,\r\nunsigned int UartNumber, bool bSet)\r\n{\r\n__u8 MCR_Value = 0;\r\n__u8 MSR_Value = 0;\r\n__u16 MOUT_Value = 0;\r\nif (bSet == true) {\r\nMCR_Value = QT2_SERIAL_MCR_RTS;\r\n} else {\r\nMCR_Value = 0;\r\n}\r\nMOUT_Value = MCR_Value << 8;\r\nif (bSet == true) {\r\nMSR_Value = QT2_SERIAL_MSR_CTS;\r\n} else {\r\nMSR_Value = 0;\r\n}\r\nMOUT_Value |= MSR_Value;\r\nreturn usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_HW_FLOW_CONTROL_MASK, 0x40, MOUT_Value, UartNumber,\r\nNULL, 0, 300);\r\n}\r\nstatic int qt2_boxsetsw_flowctl(struct usb_serial *serial, __u16 UartNumber,\r\nunsigned char stop_char, unsigned char start_char)\r\n{\r\n__u16 nSWflowout;\r\nnSWflowout = start_char << 8;\r\nnSWflowout = (unsigned short)stop_char;\r\nreturn usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_SW_FLOW_CONTROL_MASK, 0x40, nSWflowout, UartNumber,\r\nNULL, 0, 300);\r\n}\r\nstatic int qt2_boxunsetsw_flowctl(struct usb_serial *serial, __u16 UartNumber)\r\n{\r\nreturn usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_SW_FLOW_CONTROL_DISABLE, 0x40, 0, UartNumber, NULL,\r\n0, 300);\r\n}\r\nstatic int qt2_boxstoprx(struct usb_serial *serial, unsigned short uart_number,\r\nunsigned short stop)\r\n{\r\nreturn usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT2_STOP_RECEIVE, 0x40, stop, uart_number, NULL, 0, 300);\r\n}\r\nstatic int __init quausb2_usb_init(void)\r\n{\r\nint retval;\r\ndbg("%s\n", __func__);\r\nretval = usb_serial_register(&quatech2_device);\r\nif (retval)\r\ngoto failed_usb_serial_register;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nretval = usb_register(&quausb2_usb_driver);\r\nif (retval == 0)\r\nreturn 0;\r\nusb_serial_deregister(&quatech2_device);\r\nfailed_usb_serial_register:\r\nreturn retval;\r\n}\r\nstatic void __exit quausb2_usb_exit(void)\r\n{\r\nusb_deregister(&quausb2_usb_driver);\r\nusb_serial_deregister(&quatech2_device);\r\n}
