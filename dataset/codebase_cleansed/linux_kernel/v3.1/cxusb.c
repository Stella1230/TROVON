static int cxusb_ctrl_msg(struct dvb_usb_device *d,\r\nu8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nint wo = (rbuf == NULL || rlen == 0);\r\nu8 sndbuf[1+wlen];\r\nmemset(sndbuf, 0, 1+wlen);\r\nsndbuf[0] = cmd;\r\nmemcpy(&sndbuf[1], wbuf, wlen);\r\nif (wo)\r\nreturn dvb_usb_generic_write(d, sndbuf, 1+wlen);\r\nelse\r\nreturn dvb_usb_generic_rw(d, sndbuf, 1+wlen, rbuf, rlen, 0);\r\n}\r\nstatic void cxusb_gpio_tuner(struct dvb_usb_device *d, int onoff)\r\n{\r\nstruct cxusb_state *st = d->priv;\r\nu8 o[2], i;\r\nif (st->gpio_write_state[GPIO_TUNER] == onoff)\r\nreturn;\r\no[0] = GPIO_TUNER;\r\no[1] = onoff;\r\ncxusb_ctrl_msg(d, CMD_GPIO_WRITE, o, 2, &i, 1);\r\nif (i != 0x01)\r\ndeb_info("gpio_write failed.\n");\r\nst->gpio_write_state[GPIO_TUNER] = onoff;\r\n}\r\nstatic int cxusb_bluebird_gpio_rw(struct dvb_usb_device *d, u8 changemask,\r\nu8 newval)\r\n{\r\nu8 o[2], gpio_state;\r\nint rc;\r\no[0] = 0xff & ~changemask;\r\no[1] = newval & changemask;\r\nrc = cxusb_ctrl_msg(d, CMD_BLUEBIRD_GPIO_RW, o, 2, &gpio_state, 1);\r\nif (rc < 0 || (gpio_state & changemask) != (newval & changemask))\r\ndeb_info("bluebird_gpio_write failed.\n");\r\nreturn rc < 0 ? rc : gpio_state;\r\n}\r\nstatic void cxusb_bluebird_gpio_pulse(struct dvb_usb_device *d, u8 pin, int low)\r\n{\r\ncxusb_bluebird_gpio_rw(d, pin, low ? 0 : pin);\r\nmsleep(5);\r\ncxusb_bluebird_gpio_rw(d, pin, low ? pin : 0);\r\n}\r\nstatic void cxusb_nano2_led(struct dvb_usb_device *d, int onoff)\r\n{\r\ncxusb_bluebird_gpio_rw(d, 0x40, onoff ? 0 : 0x40);\r\n}\r\nstatic int cxusb_d680_dmb_gpio_tuner(struct dvb_usb_device *d,\r\nu8 addr, int onoff)\r\n{\r\nu8 o[2] = {addr, onoff};\r\nu8 i;\r\nint rc;\r\nrc = cxusb_ctrl_msg(d, CMD_GPIO_WRITE, o, 2, &i, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nif (i == 0x01)\r\nreturn 0;\r\nelse {\r\ndeb_info("gpio_write failed.\n");\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int cxusb_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nif (d->udev->descriptor.idVendor == USB_VID_MEDION)\r\nswitch (msg[i].addr) {\r\ncase 0x63:\r\ncxusb_gpio_tuner(d, 0);\r\nbreak;\r\ndefault:\r\ncxusb_gpio_tuner(d, 1);\r\nbreak;\r\n}\r\nif (msg[i].flags & I2C_M_RD) {\r\nu8 obuf[3], ibuf[1+msg[i].len];\r\nobuf[0] = 0;\r\nobuf[1] = msg[i].len;\r\nobuf[2] = msg[i].addr;\r\nif (cxusb_ctrl_msg(d, CMD_I2C_READ,\r\nobuf, 3,\r\nibuf, 1+msg[i].len) < 0) {\r\nwarn("i2c read failed");\r\nbreak;\r\n}\r\nmemcpy(msg[i].buf, &ibuf[1], msg[i].len);\r\n} else if (i+1 < num && (msg[i+1].flags & I2C_M_RD) &&\r\nmsg[i].addr == msg[i+1].addr) {\r\nu8 obuf[3+msg[i].len], ibuf[1+msg[i+1].len];\r\nobuf[0] = msg[i].len;\r\nobuf[1] = msg[i+1].len;\r\nobuf[2] = msg[i].addr;\r\nmemcpy(&obuf[3], msg[i].buf, msg[i].len);\r\nif (cxusb_ctrl_msg(d, CMD_I2C_READ,\r\nobuf, 3+msg[i].len,\r\nibuf, 1+msg[i+1].len) < 0)\r\nbreak;\r\nif (ibuf[0] != 0x08)\r\ndeb_i2c("i2c read may have failed\n");\r\nmemcpy(msg[i+1].buf, &ibuf[1], msg[i+1].len);\r\ni++;\r\n} else {\r\nu8 obuf[2+msg[i].len], ibuf;\r\nobuf[0] = msg[i].addr;\r\nobuf[1] = msg[i].len;\r\nmemcpy(&obuf[2], msg[i].buf, msg[i].len);\r\nif (cxusb_ctrl_msg(d, CMD_I2C_WRITE, obuf,\r\n2+msg[i].len, &ibuf,1) < 0)\r\nbreak;\r\nif (ibuf != 0x08)\r\ndeb_i2c("i2c write may have failed\n");\r\n}\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i == num ? num : -EREMOTEIO;\r\n}\r\nstatic u32 cxusb_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int cxusb_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 b = 0;\r\nif (onoff)\r\nreturn cxusb_ctrl_msg(d, CMD_POWER_ON, &b, 1, NULL, 0);\r\nelse\r\nreturn cxusb_ctrl_msg(d, CMD_POWER_OFF, &b, 1, NULL, 0);\r\n}\r\nstatic int cxusb_aver_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint ret;\r\nif (!onoff)\r\nreturn cxusb_ctrl_msg(d, CMD_POWER_OFF, NULL, 0, NULL, 0);\r\nif (d->state == DVB_USB_STATE_INIT &&\r\nusb_set_interface(d->udev, 0, 0) < 0)\r\nerr("set interface failed");\r\ndo {} while (!(ret = cxusb_ctrl_msg(d, CMD_POWER_ON, NULL, 0, NULL, 0)) &&\r\n!(ret = cxusb_ctrl_msg(d, 0x15, NULL, 0, NULL, 0)) &&\r\n!(ret = cxusb_ctrl_msg(d, 0x17, NULL, 0, NULL, 0)) && 0);\r\nif (!ret) {\r\nint i;\r\nu8 buf, bufs[] = {\r\n0x0e, 0x2, 0x00, 0x7f,\r\n0x0e, 0x2, 0x02, 0xfe,\r\n0x0e, 0x2, 0x02, 0x01,\r\n0x0e, 0x2, 0x00, 0x03,\r\n0x0e, 0x2, 0x0d, 0x40,\r\n0x0e, 0x2, 0x0e, 0x87,\r\n0x0e, 0x2, 0x0f, 0x8e,\r\n0x0e, 0x2, 0x10, 0x01,\r\n0x0e, 0x2, 0x14, 0xd7,\r\n0x0e, 0x2, 0x47, 0x88,\r\n};\r\nmsleep(20);\r\nfor (i = 0; i < sizeof(bufs)/sizeof(u8); i += 4/sizeof(u8)) {\r\nret = cxusb_ctrl_msg(d, CMD_I2C_WRITE,\r\nbufs+i, 4, &buf, 1);\r\nif (ret)\r\nbreak;\r\nif (buf != 0x8)\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxusb_bluebird_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 b = 0;\r\nif (onoff)\r\nreturn cxusb_ctrl_msg(d, CMD_POWER_ON, &b, 1, NULL, 0);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int cxusb_nano2_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint rc = 0;\r\nrc = cxusb_power_ctrl(d, onoff);\r\nif (!onoff)\r\ncxusb_nano2_led(d, 0);\r\nreturn rc;\r\n}\r\nstatic int cxusb_d680_dmb_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint ret;\r\nu8 b;\r\nret = cxusb_power_ctrl(d, onoff);\r\nif (!onoff)\r\nreturn ret;\r\nmsleep(128);\r\ncxusb_ctrl_msg(d, CMD_DIGITAL, NULL, 0, &b, 1);\r\nmsleep(100);\r\nreturn ret;\r\n}\r\nstatic int cxusb_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nu8 buf[2] = { 0x03, 0x00 };\r\nif (onoff)\r\ncxusb_ctrl_msg(adap->dev, CMD_STREAMING_ON, buf, 2, NULL, 0);\r\nelse\r\ncxusb_ctrl_msg(adap->dev, CMD_STREAMING_OFF, NULL, 0, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic int cxusb_aver_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nif (onoff)\r\ncxusb_ctrl_msg(adap->dev, CMD_AVER_STREAM_ON, NULL, 0, NULL, 0);\r\nelse\r\ncxusb_ctrl_msg(adap->dev, CMD_AVER_STREAM_OFF,\r\nNULL, 0, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic void cxusb_d680_dmb_drain_message(struct dvb_usb_device *d)\r\n{\r\nint ep = d->props.generic_bulk_ctrl_endpoint;\r\nconst int timeout = 100;\r\nconst int junk_len = 32;\r\nu8 *junk;\r\nint rd_count;\r\njunk = kmalloc(junk_len, GFP_KERNEL);\r\nif (!junk)\r\nreturn;\r\nwhile (1) {\r\nif (usb_bulk_msg(d->udev,\r\nusb_rcvbulkpipe(d->udev, ep),\r\njunk, junk_len, &rd_count, timeout) < 0)\r\nbreak;\r\nif (!rd_count)\r\nbreak;\r\n}\r\nkfree(junk);\r\n}\r\nstatic void cxusb_d680_dmb_drain_video(struct dvb_usb_device *d)\r\n{\r\nstruct usb_data_stream_properties *p = &d->props.adapter[0].stream;\r\nconst int timeout = 100;\r\nconst int junk_len = p->u.bulk.buffersize;\r\nu8 *junk;\r\nint rd_count;\r\njunk = kmalloc(junk_len, GFP_KERNEL);\r\nif (!junk)\r\nreturn;\r\nwhile (1) {\r\nif (usb_bulk_msg(d->udev,\r\nusb_rcvbulkpipe(d->udev, p->endpoint),\r\njunk, junk_len, &rd_count, timeout) < 0)\r\nbreak;\r\nif (!rd_count)\r\nbreak;\r\n}\r\nkfree(junk);\r\n}\r\nstatic int cxusb_d680_dmb_streaming_ctrl(\r\nstruct dvb_usb_adapter *adap, int onoff)\r\n{\r\nif (onoff) {\r\nu8 buf[2] = { 0x03, 0x00 };\r\ncxusb_d680_dmb_drain_video(adap->dev);\r\nreturn cxusb_ctrl_msg(adap->dev, CMD_STREAMING_ON,\r\nbuf, sizeof(buf), NULL, 0);\r\n} else {\r\nint ret = cxusb_ctrl_msg(adap->dev,\r\nCMD_STREAMING_OFF, NULL, 0, NULL, 0);\r\nreturn ret;\r\n}\r\n}\r\nstatic int cxusb_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\r\nu8 ircode[4];\r\nint i;\r\ncxusb_ctrl_msg(d, CMD_GET_IR_CODE, NULL, 0, ircode, 4);\r\n*event = 0;\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {\r\nif (rc5_custom(&keymap[i]) == ircode[2] &&\r\nrc5_data(&keymap[i]) == ircode[3]) {\r\n*event = keymap[i].keycode;\r\n*state = REMOTE_KEY_PRESSED;\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxusb_bluebird2_rc_query(struct dvb_usb_device *d, u32 *event,\r\nint *state)\r\n{\r\nstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\r\nu8 ircode[4];\r\nint i;\r\nstruct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,\r\n.buf = ircode, .len = 4 };\r\n*event = 0;\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nif (cxusb_i2c_xfer(&d->i2c_adap, &msg, 1) != 1)\r\nreturn 0;\r\nfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {\r\nif (rc5_custom(&keymap[i]) == ircode[1] &&\r\nrc5_data(&keymap[i]) == ircode[2]) {\r\n*event = keymap[i].keycode;\r\n*state = REMOTE_KEY_PRESSED;\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxusb_d680_dmb_rc_query(struct dvb_usb_device *d, u32 *event,\r\nint *state)\r\n{\r\nstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\r\nu8 ircode[2];\r\nint i;\r\n*event = 0;\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nif (cxusb_ctrl_msg(d, 0x10, NULL, 0, ircode, 2) < 0)\r\nreturn 0;\r\nfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {\r\nif (rc5_custom(&keymap[i]) == ircode[0] &&\r\nrc5_data(&keymap[i]) == ircode[1]) {\r\n*event = keymap[i].keycode;\r\n*state = REMOTE_KEY_PRESSED;\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxusb_dee1601_demod_init(struct dvb_frontend* fe)\r\n{\r\nstatic u8 clock_config [] = { CLOCK_CTL, 0x38, 0x28 };\r\nstatic u8 reset [] = { RESET, 0x80 };\r\nstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1, 0x40 };\r\nstatic u8 agc_cfg [] = { AGC_TARGET, 0x28, 0x20 };\r\nstatic u8 gpp_ctl_cfg [] = { GPP_CTL, 0x33 };\r\nstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\r\nmt352_write(fe, clock_config, sizeof(clock_config));\r\nudelay(200);\r\nmt352_write(fe, reset, sizeof(reset));\r\nmt352_write(fe, adc_ctl_1_cfg, sizeof(adc_ctl_1_cfg));\r\nmt352_write(fe, agc_cfg, sizeof(agc_cfg));\r\nmt352_write(fe, gpp_ctl_cfg, sizeof(gpp_ctl_cfg));\r\nmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\r\nreturn 0;\r\n}\r\nstatic int cxusb_mt352_demod_init(struct dvb_frontend* fe)\r\n{\r\nstatic u8 clock_config [] = { CLOCK_CTL, 0x38, 0x29 };\r\nstatic u8 reset [] = { RESET, 0x80 };\r\nstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1, 0x40 };\r\nstatic u8 agc_cfg [] = { AGC_TARGET, 0x24, 0x20 };\r\nstatic u8 gpp_ctl_cfg [] = { GPP_CTL, 0x33 };\r\nstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\r\nmt352_write(fe, clock_config, sizeof(clock_config));\r\nudelay(200);\r\nmt352_write(fe, reset, sizeof(reset));\r\nmt352_write(fe, adc_ctl_1_cfg, sizeof(adc_ctl_1_cfg));\r\nmt352_write(fe, agc_cfg, sizeof(agc_cfg));\r\nmt352_write(fe, gpp_ctl_cfg, sizeof(gpp_ctl_cfg));\r\nmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\r\nreturn 0;\r\n}\r\nstatic int cxusb_fmd1216me_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(simple_tuner_attach, adap->fe,\r\n&adap->dev->i2c_adap, 0x61,\r\nTUNER_PHILIPS_FMD1216ME_MK3);\r\nreturn 0;\r\n}\r\nstatic int cxusb_dee1601_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(dvb_pll_attach, adap->fe, 0x61,\r\nNULL, DVB_PLL_THOMSON_DTT7579);\r\nreturn 0;\r\n}\r\nstatic int cxusb_lgz201_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(dvb_pll_attach, adap->fe, 0x61, NULL, DVB_PLL_LG_Z201);\r\nreturn 0;\r\n}\r\nstatic int cxusb_dtt7579_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(dvb_pll_attach, adap->fe, 0x60,\r\nNULL, DVB_PLL_THOMSON_DTT7579);\r\nreturn 0;\r\n}\r\nstatic int cxusb_lgh064f_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(simple_tuner_attach, adap->fe,\r\n&adap->dev->i2c_adap, 0x61, TUNER_LG_TDVS_H06XF);\r\nreturn 0;\r\n}\r\nstatic int dvico_bluebird_xc2028_callback(void *ptr, int component,\r\nint command, int arg)\r\n{\r\nstruct dvb_usb_adapter *adap = ptr;\r\nstruct dvb_usb_device *d = adap->dev;\r\nswitch (command) {\r\ncase XC2028_TUNER_RESET:\r\ndeb_info("%s: XC2028_TUNER_RESET %d\n", __func__, arg);\r\ncxusb_bluebird_gpio_pulse(d, 0x01, 1);\r\nbreak;\r\ncase XC2028_RESET_CLK:\r\ndeb_info("%s: XC2028_RESET_CLK %d\n", __func__, arg);\r\nbreak;\r\ndefault:\r\ndeb_info("%s: unknown command %d, arg %d\n", __func__,\r\ncommand, arg);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxusb_dvico_xc3028_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &adap->dev->i2c_adap,\r\n.i2c_addr = 0x61,\r\n};\r\nstatic struct xc2028_ctrl ctl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = XC3028_FE_ZARLINK456,\r\n};\r\nadap->fe->callback = dvico_bluebird_xc2028_callback;\r\nfe = dvb_attach(xc2028_attach, adap->fe, &cfg);\r\nif (fe == NULL || fe->ops.tuner_ops.set_config == NULL)\r\nreturn -EIO;\r\nfe->ops.tuner_ops.set_config(fe, &ctl);\r\nreturn 0;\r\n}\r\nstatic int cxusb_mxl5003s_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(mxl5005s_attach, adap->fe,\r\n&adap->dev->i2c_adap, &aver_a868r_tuner);\r\nreturn 0;\r\n}\r\nstatic int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_frontend *fe;\r\nfe = dvb_attach(mxl5005s_attach, adap->fe,\r\n&adap->dev->i2c_adap, &d680_dmb_tuner);\r\nreturn (fe == NULL) ? -EIO : 0;\r\n}\r\nstatic int cxusb_mygica_d689_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_frontend *fe;\r\nfe = dvb_attach(max2165_attach, adap->fe,\r\n&adap->dev->i2c_adap, &mygica_d689_max2165_cfg);\r\nreturn (fe == NULL) ? -EIO : 0;\r\n}\r\nstatic int cxusb_cx22702_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nu8 b;\r\nif (usb_set_interface(adap->dev->udev, 0, 6) < 0)\r\nerr("set interface failed");\r\ncxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, &b, 1);\r\nif ((adap->fe = dvb_attach(cx22702_attach, &cxusb_cx22702_config,\r\n&adap->dev->i2c_adap)) != NULL)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int cxusb_lgdt3303_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (usb_set_interface(adap->dev->udev, 0, 7) < 0)\r\nerr("set interface failed");\r\ncxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\r\nif ((adap->fe = dvb_attach(lgdt330x_attach, &cxusb_lgdt3303_config,\r\n&adap->dev->i2c_adap)) != NULL)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int cxusb_aver_lgdt3303_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nadap->fe = dvb_attach(lgdt330x_attach, &cxusb_aver_lgdt3303_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe != NULL)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int cxusb_mt352_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (usb_set_interface(adap->dev->udev, 0, 0) < 0)\r\nerr("set interface failed");\r\ncxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\r\nif ((adap->fe = dvb_attach(mt352_attach, &cxusb_mt352_config,\r\n&adap->dev->i2c_adap)) != NULL)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int cxusb_dee1601_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (usb_set_interface(adap->dev->udev, 0, 0) < 0)\r\nerr("set interface failed");\r\ncxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\r\nif (((adap->fe = dvb_attach(mt352_attach, &cxusb_dee1601_config,\r\n&adap->dev->i2c_adap)) != NULL) ||\r\n((adap->fe = dvb_attach(zl10353_attach,\r\n&cxusb_zl10353_dee1601_config,\r\n&adap->dev->i2c_adap)) != NULL))\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int cxusb_dualdig4_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nu8 ircode[4];\r\nint i;\r\nstruct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,\r\n.buf = ircode, .len = 4 };\r\nif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\r\nerr("set interface failed");\r\ncxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\r\ncxusb_bluebird_gpio_rw(adap->dev, 0x04, 0);\r\ncxusb_bluebird_gpio_pulse(adap->dev, 0x01, 1);\r\ncxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\r\nif ((adap->fe = dvb_attach(zl10353_attach,\r\n&cxusb_zl10353_xc3028_config_no_i2c_gate,\r\n&adap->dev->i2c_adap)) == NULL)\r\nreturn -EIO;\r\nfor (i = 0; adap->dev->props.rc.legacy.rc_map_table != NULL && i < 5; i++) {\r\nmsleep(20);\r\nif (cxusb_i2c_xfer(&adap->dev->i2c_adap, &msg, 1) != 1)\r\ngoto no_IR;\r\nif (ircode[0] == 0 && ircode[1] == 0)\r\ncontinue;\r\nif (ircode[2] + ircode[3] != 0xff) {\r\nno_IR:\r\nadap->dev->props.rc.legacy.rc_map_table = NULL;\r\ninfo("No IR receiver detected on this device.");\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxusb_dualdig4_rev2_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\r\nerr("set interface failed");\r\ncxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\r\ncxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\r\nif (dib7000p_i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\r\n&cxusb_dualdig4_rev2_config) < 0) {\r\nprintk(KERN_WARNING "Unable to enumerate dib7000p\n");\r\nreturn -ENODEV;\r\n}\r\nadap->fe = dvb_attach(dib7000p_attach, &adap->dev->i2c_adap, 0x80,\r\n&cxusb_dualdig4_rev2_config);\r\nif (adap->fe == NULL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)\r\n{\r\nreturn dib7000p_set_gpio(fe, 8, 0, !onoff);\r\n}\r\nstatic int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dib7070_set_param_override(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *fep)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dib0700_adapter_state *state = adap->priv;\r\nu16 offset;\r\nu8 band = BAND_OF_FREQUENCY(fep->frequency/1000);\r\nswitch (band) {\r\ncase BAND_VHF: offset = 950; break;\r\ndefault:\r\ncase BAND_UHF: offset = 550; break;\r\n}\r\ndib7000p_set_wbd_ref(fe, offset + dib0070_wbd_offset(fe));\r\nreturn state->set_param_save(fe, fep);\r\n}\r\nstatic int cxusb_dualdig4_rev2_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dib0700_adapter_state *st = adap->priv;\r\nstruct i2c_adapter *tun_i2c =\r\ndib7000p_get_i2c_master(adap->fe,\r\nDIBX000_I2C_INTERFACE_TUNER, 1);\r\nif (dvb_attach(dib0070_attach, adap->fe, tun_i2c,\r\n&dib7070p_dib0070_config) == NULL)\r\nreturn -ENODEV;\r\nst->set_param_save = adap->fe->ops.tuner_ops.set_params;\r\nadap->fe->ops.tuner_ops.set_params = dib7070_set_param_override;\r\nreturn 0;\r\n}\r\nstatic int cxusb_nano2_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\r\nerr("set interface failed");\r\ncxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\r\ncxusb_bluebird_gpio_rw(adap->dev, 0x04, 0);\r\ncxusb_bluebird_gpio_pulse(adap->dev, 0x01, 1);\r\ncxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\r\nif ((adap->fe = dvb_attach(zl10353_attach,\r\n&cxusb_zl10353_xc3028_config,\r\n&adap->dev->i2c_adap)) != NULL)\r\nreturn 0;\r\nif ((adap->fe = dvb_attach(mt352_attach,\r\n&cxusb_mt352_xc3028_config,\r\n&adap->dev->i2c_adap)) != NULL)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int cxusb_d680_dmb_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nint n;\r\nif (usb_set_interface(d->udev, 0, 0) < 0)\r\nerr("set interface failed");\r\nusb_clear_halt(d->udev,\r\nusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\r\nusb_clear_halt(d->udev,\r\nusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\r\nusb_clear_halt(d->udev,\r\nusb_rcvbulkpipe(d->udev, d->props.adapter[0].stream.endpoint));\r\nfor (n = 0; n < 5; n++) {\r\ncxusb_d680_dmb_drain_message(d);\r\ncxusb_d680_dmb_drain_video(d);\r\nmsleep(200);\r\n}\r\nif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 0) < 0) {\r\nerr("clear tuner gpio failed");\r\nreturn -EIO;\r\n}\r\nmsleep(100);\r\nif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 1) < 0) {\r\nerr("set tuner gpio failed");\r\nreturn -EIO;\r\n}\r\nmsleep(100);\r\nadap->fe = dvb_attach(lgs8gxx_attach, &d680_lgs8gl5_cfg, &d->i2c_adap);\r\nif (adap->fe == NULL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int cxusb_mygica_d689_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nif (usb_set_interface(d->udev, 0, 0) < 0)\r\nerr("set interface failed");\r\nusb_clear_halt(d->udev,\r\nusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\r\nusb_clear_halt(d->udev,\r\nusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\r\nusb_clear_halt(d->udev,\r\nusb_rcvbulkpipe(d->udev, d->props.adapter[0].stream.endpoint));\r\nif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 0) < 0) {\r\nerr("clear tuner gpio failed");\r\nreturn -EIO;\r\n}\r\nmsleep(100);\r\nif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 1) < 0) {\r\nerr("set tuner gpio failed");\r\nreturn -EIO;\r\n}\r\nmsleep(100);\r\nadap->fe = dvb_attach(atbm8830_attach, &mygica_d689_atbm8830_cfg,\r\n&d->i2c_adap);\r\nif (adap->fe == NULL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int bluebird_fx2_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\nint wascold = *cold;\r\n*cold = udev->descriptor.bDeviceClass == 0xff &&\r\nudev->descriptor.bDeviceSubClass == 0xff &&\r\nudev->descriptor.bDeviceProtocol == 0xff;\r\nif (*cold && !wascold)\r\n*desc = NULL;\r\nreturn 0;\r\n}\r\nstatic int bluebird_patch_dvico_firmware_download(struct usb_device *udev,\r\nconst struct firmware *fw)\r\n{\r\nint pos;\r\nfor (pos = 0; pos < ARRAY_SIZE(dvico_firmware_id_offsets); pos++) {\r\nint idoff = dvico_firmware_id_offsets[pos];\r\nif (fw->size < idoff + 4)\r\ncontinue;\r\nif (fw->data[idoff] == (USB_VID_DVICO & 0xff) &&\r\nfw->data[idoff + 1] == USB_VID_DVICO >> 8) {\r\nstruct firmware new_fw;\r\nu8 *new_fw_data = vmalloc(fw->size);\r\nint ret;\r\nif (!new_fw_data)\r\nreturn -ENOMEM;\r\nmemcpy(new_fw_data, fw->data, fw->size);\r\nnew_fw.size = fw->size;\r\nnew_fw.data = new_fw_data;\r\nnew_fw_data[idoff + 2] =\r\nle16_to_cpu(udev->descriptor.idProduct) + 1;\r\nnew_fw_data[idoff + 3] =\r\nle16_to_cpu(udev->descriptor.idProduct) >> 8;\r\nret = usb_cypress_load_firmware(udev, &new_fw,\r\nCYPRESS_FX2);\r\nvfree(new_fw_data);\r\nreturn ret;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cxusb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nif (0 == dvb_usb_device_init(intf, &cxusb_medion_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_bluebird_lgh064f_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_bluebird_dee1601_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_bluebird_lgz201_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_bluebird_dtt7579_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_bluebird_dualdig4_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_bluebird_nano2_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&cxusb_bluebird_nano2_needsfirmware_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_aver_a868r_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&cxusb_bluebird_dualdig4_rev2_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_d680_dmb_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &cxusb_mygica_d689_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int __init cxusb_module_init(void)\r\n{\r\nint result;\r\nif ((result = usb_register(&cxusb_driver))) {\r\nerr("usb_register failed. Error number %d",result);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cxusb_module_exit(void)\r\n{\r\nusb_deregister(&cxusb_driver);\r\n}
