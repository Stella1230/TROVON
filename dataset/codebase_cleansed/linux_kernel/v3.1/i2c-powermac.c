static s32 i2c_powermac_smbus_xfer( struct i2c_adapter* adap,\r\nu16 addr,\r\nunsigned short flags,\r\nchar read_write,\r\nu8 command,\r\nint size,\r\nunion i2c_smbus_data* data)\r\n{\r\nstruct pmac_i2c_bus *bus = i2c_get_adapdata(adap);\r\nint rc = 0;\r\nint read = (read_write == I2C_SMBUS_READ);\r\nint addrdir = (addr << 1) | read;\r\nint mode, subsize, len;\r\nu32 subaddr;\r\nu8 *buf;\r\nu8 local[2];\r\nif (size == I2C_SMBUS_QUICK || size == I2C_SMBUS_BYTE) {\r\nmode = pmac_i2c_mode_std;\r\nsubsize = 0;\r\nsubaddr = 0;\r\n} else {\r\nmode = read ? pmac_i2c_mode_combined : pmac_i2c_mode_stdsub;\r\nsubsize = 1;\r\nsubaddr = command;\r\n}\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nbuf = NULL;\r\nlen = 0;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\nbuf = &data->byte;\r\nlen = 1;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nif (!read) {\r\nlocal[0] = data->word & 0xff;\r\nlocal[1] = (data->word >> 8) & 0xff;\r\n}\r\nbuf = local;\r\nlen = 2;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nbuf = data->block;\r\nlen = data->block[0] + 1;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nbuf = &data->block[1];\r\nlen = data->block[0];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrc = pmac_i2c_open(bus, 0);\r\nif (rc) {\r\ndev_err(&adap->dev, "Failed to open I2C, err %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = pmac_i2c_setmode(bus, mode);\r\nif (rc) {\r\ndev_err(&adap->dev, "Failed to set I2C mode %d, err %d\n",\r\nmode, rc);\r\ngoto bail;\r\n}\r\nrc = pmac_i2c_xfer(bus, addrdir, subsize, subaddr, buf, len);\r\nif (rc) {\r\nif (rc == -ENXIO)\r\ndev_dbg(&adap->dev,\r\n"I2C transfer at 0x%02x failed, size %d, "\r\n"err %d\n", addrdir >> 1, size, rc);\r\nelse\r\ndev_err(&adap->dev,\r\n"I2C transfer at 0x%02x failed, size %d, "\r\n"err %d\n", addrdir >> 1, size, rc);\r\ngoto bail;\r\n}\r\nif (size == I2C_SMBUS_WORD_DATA && read) {\r\ndata->word = ((u16)local[1]) << 8;\r\ndata->word |= local[0];\r\n}\r\nbail:\r\npmac_i2c_close(bus);\r\nreturn rc;\r\n}\r\nstatic int i2c_powermac_master_xfer( struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct pmac_i2c_bus *bus = i2c_get_adapdata(adap);\r\nint rc = 0;\r\nint read;\r\nint addrdir;\r\nif (num != 1) {\r\ndev_err(&adap->dev,\r\n"Multi-message I2C transactions not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (msgs->flags & I2C_M_TEN)\r\nreturn -EINVAL;\r\nread = (msgs->flags & I2C_M_RD) != 0;\r\naddrdir = (msgs->addr << 1) | read;\r\nrc = pmac_i2c_open(bus, 0);\r\nif (rc) {\r\ndev_err(&adap->dev, "Failed to open I2C, err %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = pmac_i2c_setmode(bus, pmac_i2c_mode_std);\r\nif (rc) {\r\ndev_err(&adap->dev, "Failed to set I2C mode %d, err %d\n",\r\npmac_i2c_mode_std, rc);\r\ngoto bail;\r\n}\r\nrc = pmac_i2c_xfer(bus, addrdir, 0, 0, msgs->buf, msgs->len);\r\nif (rc < 0) {\r\nif (rc == -ENXIO)\r\ndev_dbg(&adap->dev, "I2C %s 0x%02x failed, err %d\n",\r\naddrdir & 1 ? "read from" : "write to",\r\naddrdir >> 1, rc);\r\nelse\r\ndev_err(&adap->dev, "I2C %s 0x%02x failed, err %d\n",\r\naddrdir & 1 ? "read from" : "write to",\r\naddrdir >> 1, rc);\r\n}\r\nbail:\r\npmac_i2c_close(bus);\r\nreturn rc < 0 ? rc : 1;\r\n}\r\nstatic u32 i2c_powermac_func(struct i2c_adapter * adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_I2C;\r\n}\r\nstatic int __devexit i2c_powermac_remove(struct platform_device *dev)\r\n{\r\nstruct i2c_adapter *adapter = platform_get_drvdata(dev);\r\nint rc;\r\nrc = i2c_del_adapter(adapter);\r\nif (rc)\r\nprintk(KERN_WARNING\r\n"i2c-powermac.c: Failed to remove bus %s !\n",\r\nadapter->name);\r\nplatform_set_drvdata(dev, NULL);\r\nmemset(adapter, 0, sizeof(*adapter));\r\nreturn 0;\r\n}\r\nstatic int __devinit i2c_powermac_probe(struct platform_device *dev)\r\n{\r\nstruct pmac_i2c_bus *bus = dev->dev.platform_data;\r\nstruct device_node *parent = NULL;\r\nstruct i2c_adapter *adapter;\r\nconst char *basename;\r\nint rc;\r\nif (bus == NULL)\r\nreturn -EINVAL;\r\nadapter = pmac_i2c_get_adapter(bus);\r\nswitch(pmac_i2c_get_type(bus)) {\r\ncase pmac_i2c_bus_keywest:\r\nparent = of_get_parent(pmac_i2c_get_controller(bus));\r\nif (parent == NULL)\r\nreturn -EINVAL;\r\nbasename = parent->name;\r\nbreak;\r\ncase pmac_i2c_bus_pmu:\r\nbasename = "pmu";\r\nbreak;\r\ncase pmac_i2c_bus_smu:\r\nbasename = "smu";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnprintf(adapter->name, sizeof(adapter->name), "%s %d", basename,\r\npmac_i2c_get_channel(bus));\r\nof_node_put(parent);\r\nplatform_set_drvdata(dev, adapter);\r\nadapter->algo = &i2c_powermac_algorithm;\r\ni2c_set_adapdata(adapter, bus);\r\nadapter->dev.parent = &dev->dev;\r\nrc = i2c_add_adapter(adapter);\r\nif (rc) {\r\nprintk(KERN_ERR "i2c-powermac: Adapter %s registration "\r\n"failed\n", adapter->name);\r\nmemset(adapter, 0, sizeof(*adapter));\r\n}\r\nprintk(KERN_INFO "PowerMac i2c bus %s registered\n", adapter->name);\r\nif (!strncmp(basename, "uni-n", 5)) {\r\nstruct device_node *np;\r\nconst u32 *prop;\r\nstruct i2c_board_info info;\r\nnp = of_find_node_by_name(NULL, "accelerometer");\r\nif (np && of_device_is_compatible(np, "AAPL,accelerometer_1") &&\r\n(prop = of_get_property(np, "reg", NULL))) {\r\nint i2c_bus;\r\nconst char *tmp_bus;\r\ntmp_bus = strstr(np->full_name, "/i2c-bus@");\r\nif (tmp_bus)\r\ni2c_bus = *(tmp_bus + 9) - '0';\r\nelse\r\ni2c_bus = ((*prop) >> 8) & 0x0f;\r\nif (pmac_i2c_get_channel(bus) == i2c_bus) {\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = ((*prop) & 0xff) >> 1;\r\nstrlcpy(info.type, "ams", I2C_NAME_SIZE);\r\ni2c_new_device(adapter, &info);\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init i2c_powermac_init(void)\r\n{\r\nplatform_driver_register(&i2c_powermac_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit i2c_powermac_cleanup(void)\r\n{\r\nplatform_driver_unregister(&i2c_powermac_driver);\r\n}
