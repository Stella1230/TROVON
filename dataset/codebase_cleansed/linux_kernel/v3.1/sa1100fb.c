static struct sa1100fb_mach_info * __init\r\nsa1100fb_get_machine_info(struct sa1100fb_info *fbi)\r\n{\r\nstruct sa1100fb_mach_info *inf = NULL;\r\n#ifdef CONFIG_SA1100_ASSABET\r\nif (machine_is_assabet()) {\r\n#ifndef ASSABET_PAL_VIDEO\r\ninf = &lq039q2ds54_info;\r\n#else\r\ninf = &pal_info;\r\n#endif\r\n}\r\n#endif\r\n#ifdef CONFIG_SA1100_H3100\r\nif (machine_is_h3100()) {\r\ninf = &h3100_info;\r\n}\r\n#endif\r\n#ifdef CONFIG_SA1100_H3600\r\nif (machine_is_h3600()) {\r\ninf = &h3600_info;\r\nfbi->rgb[RGB_16] = &h3600_rgb_16;\r\n}\r\n#endif\r\n#ifdef CONFIG_SA1100_COLLIE\r\nif (machine_is_collie()) {\r\ninf = &collie_info;\r\n}\r\n#endif\r\n#ifdef CONFIG_SA1100_LART\r\nif (machine_is_lart()) {\r\n#ifdef LART_GREY_LCD\r\ninf = &lart_grey_info;\r\n#endif\r\n#ifdef LART_COLOR_LCD\r\ninf = &lart_color_info;\r\n#endif\r\n#ifdef LART_VIDEO_OUT\r\ninf = &lart_video_info;\r\n#endif\r\n#ifdef LART_KIT01_LCD\r\ninf = &lart_kit01_info;\r\n#endif\r\n}\r\n#endif\r\n#ifdef CONFIG_SA1100_SHANNON\r\nif (machine_is_shannon()) {\r\ninf = &shannon_info;\r\n}\r\n#endif\r\nreturn inf;\r\n}\r\nstatic inline void sa1100fb_schedule_work(struct sa1100fb_info *fbi, u_int state)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (fbi->task_state == C_ENABLE && state == C_REENABLE)\r\nstate = (u_int) -1;\r\nif (fbi->task_state == C_DISABLE && state == C_ENABLE)\r\nstate = C_REENABLE;\r\nif (state != (u_int)-1) {\r\nfbi->task_state = state;\r\nschedule_work(&fbi->task);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic inline u_int palette_pbs(struct fb_var_screeninfo *var)\r\n{\r\nint ret = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 4: ret = 0 << 12; break;\r\ncase 8: ret = 1 << 12; break;\r\ncase 16: ret = 2 << 12; break;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nsa1100fb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nstruct sa1100fb_info *fbi = (struct sa1100fb_info *)info;\r\nu_int val, ret = 1;\r\nif (regno < fbi->palette_size) {\r\nval = ((red >> 4) & 0xf00);\r\nval |= ((green >> 8) & 0x0f0);\r\nval |= ((blue >> 12) & 0x00f);\r\nif (regno == 0)\r\nval |= palette_pbs(&fbi->fb.var);\r\nfbi->palette_cpu[regno] = val;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nsa1100fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nstruct sa1100fb_info *fbi = (struct sa1100fb_info *)info;\r\nunsigned int val;\r\nint ret = 1;\r\nif (fbi->cmap_inverse) {\r\nred = 0xffff - red;\r\ngreen = 0xffff - green;\r\nblue = 0xffff - blue;\r\n}\r\nif (fbi->fb.var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (fbi->fb.fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = fbi->fb.pseudo_palette;\r\nval = chan_to_field(red, &fbi->fb.var.red);\r\nval |= chan_to_field(green, &fbi->fb.var.green);\r\nval |= chan_to_field(blue, &fbi->fb.var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_STATIC_PSEUDOCOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nret = sa1100fb_setpalettereg(regno, red, green, blue, trans, info);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline unsigned int sa1100fb_display_dma_period(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->pixclock * 8 * 16 / var->bits_per_pixel;\r\n}\r\nstatic int\r\nsa1100fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct sa1100fb_info *fbi = (struct sa1100fb_info *)info;\r\nint rgbidx;\r\nif (var->xres < MIN_XRES)\r\nvar->xres = MIN_XRES;\r\nif (var->yres < MIN_YRES)\r\nvar->yres = MIN_YRES;\r\nif (var->xres > fbi->max_xres)\r\nvar->xres = fbi->max_xres;\r\nif (var->yres > fbi->max_yres)\r\nvar->yres = fbi->max_yres;\r\nvar->xres_virtual = max(var->xres_virtual, var->xres);\r\nvar->yres_virtual = max(var->yres_virtual, var->yres);\r\nDPRINTK("var->bits_per_pixel=%d\n", var->bits_per_pixel);\r\nswitch (var->bits_per_pixel) {\r\ncase 4:\r\nrgbidx = RGB_4;\r\nbreak;\r\ncase 8:\r\nrgbidx = RGB_8;\r\nbreak;\r\ncase 16:\r\nrgbidx = RGB_16;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nvar->red = fbi->rgb[rgbidx]->red;\r\nvar->green = fbi->rgb[rgbidx]->green;\r\nvar->blue = fbi->rgb[rgbidx]->blue;\r\nvar->transp = fbi->rgb[rgbidx]->transp;\r\nDPRINTK("RGBT length = %d:%d:%d:%d\n",\r\nvar->red.length, var->green.length, var->blue.length,\r\nvar->transp.length);\r\nDPRINTK("RGBT offset = %d:%d:%d:%d\n",\r\nvar->red.offset, var->green.offset, var->blue.offset,\r\nvar->transp.offset);\r\n#ifdef CONFIG_CPU_FREQ\r\nprintk(KERN_DEBUG "dma period = %d ps, clock = %d kHz\n",\r\nsa1100fb_display_dma_period(var),\r\ncpufreq_get(smp_processor_id()));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline void sa1100fb_set_truecolor(u_int is_true_color)\r\n{\r\nif (machine_is_assabet()) {\r\n#if 1\r\nif (is_true_color)\r\nASSABET_BCR_set(ASSABET_BCR_LCD_12RGB);\r\nelse\r\nASSABET_BCR_clear(ASSABET_BCR_LCD_12RGB);\r\n#else\r\nif (is_true_color)\r\nASSABET_BCR_clear(ASSABET_BCR_LCD_12RGB);\r\nelse\r\nASSABET_BCR_set(ASSABET_BCR_LCD_12RGB);\r\n#endif\r\n}\r\n}\r\nstatic int sa1100fb_set_par(struct fb_info *info)\r\n{\r\nstruct sa1100fb_info *fbi = (struct sa1100fb_info *)info;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nunsigned long palette_mem_size;\r\nDPRINTK("set_par\n");\r\nif (var->bits_per_pixel == 16)\r\nfbi->fb.fix.visual = FB_VISUAL_TRUECOLOR;\r\nelse if (!fbi->cmap_static)\r\nfbi->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse {\r\nfbi->fb.fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\r\n}\r\nfbi->fb.fix.line_length = var->xres_virtual *\r\nvar->bits_per_pixel / 8;\r\nfbi->palette_size = var->bits_per_pixel == 8 ? 256 : 16;\r\npalette_mem_size = fbi->palette_size * sizeof(u16);\r\nDPRINTK("palette_mem_size = 0x%08lx\n", (u_long) palette_mem_size);\r\nfbi->palette_cpu = (u16 *)(fbi->map_cpu + PAGE_SIZE - palette_mem_size);\r\nfbi->palette_dma = fbi->map_dma + PAGE_SIZE - palette_mem_size;\r\nsa1100fb_set_truecolor(fbi->fb.fix.visual == FB_VISUAL_TRUECOLOR);\r\nsa1100fb_activate_var(var, fbi);\r\nreturn 0;\r\n}\r\nstatic int sa1100fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct sa1100fb_info *fbi = (struct sa1100fb_info *)info;\r\nint i;\r\nDPRINTK("sa1100fb_blank: blank=%d\n", blank);\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nif (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR ||\r\nfbi->fb.fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\r\nfor (i = 0; i < fbi->palette_size; i++)\r\nsa1100fb_setpalettereg(i, 0, 0, 0, 0, info);\r\nsa1100fb_schedule_work(fbi, C_DISABLE);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nif (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR ||\r\nfbi->fb.fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\r\nfb_set_cmap(&fbi->fb.cmap, info);\r\nsa1100fb_schedule_work(fbi, C_ENABLE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sa1100fb_mmap(struct fb_info *info,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct sa1100fb_info *fbi = (struct sa1100fb_info *)info;\r\nunsigned long start, len, off = vma->vm_pgoff << PAGE_SHIFT;\r\nif (off < info->fix.smem_len) {\r\nvma->vm_pgoff += 1;\r\nreturn dma_mmap_writecombine(fbi->dev, vma, fbi->map_cpu,\r\nfbi->map_dma, fbi->map_size);\r\n}\r\nstart = info->fix.mmio_start;\r\nlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\r\nif ((vma->vm_end - vma->vm_start + off) > len)\r\nreturn -EINVAL;\r\noff += start & PAGE_MASK;\r\nvma->vm_pgoff = off >> PAGE_SHIFT;\r\nvma->vm_flags |= VM_IO;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nreturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot);\r\n}\r\nstatic inline unsigned int get_pcd(unsigned int pixclock, unsigned int cpuclock)\r\n{\r\nunsigned int pcd = cpuclock / 100;\r\npcd *= pixclock;\r\npcd /= 10000000;\r\nreturn pcd + 1;\r\n}\r\nstatic int sa1100fb_activate_var(struct fb_var_screeninfo *var, struct sa1100fb_info *fbi)\r\n{\r\nstruct sa1100fb_lcd_reg new_regs;\r\nu_int half_screen_size, yres, pcd;\r\nu_long flags;\r\nDPRINTK("Configuring SA1100 LCD\n");\r\nDPRINTK("var: xres=%d hslen=%d lm=%d rm=%d\n",\r\nvar->xres, var->hsync_len,\r\nvar->left_margin, var->right_margin);\r\nDPRINTK("var: yres=%d vslen=%d um=%d bm=%d\n",\r\nvar->yres, var->vsync_len,\r\nvar->upper_margin, var->lower_margin);\r\n#if DEBUG_VAR\r\nif (var->xres < 16 || var->xres > 1024)\r\nprintk(KERN_ERR "%s: invalid xres %d\n",\r\nfbi->fb.fix.id, var->xres);\r\nif (var->hsync_len < 1 || var->hsync_len > 64)\r\nprintk(KERN_ERR "%s: invalid hsync_len %d\n",\r\nfbi->fb.fix.id, var->hsync_len);\r\nif (var->left_margin < 1 || var->left_margin > 255)\r\nprintk(KERN_ERR "%s: invalid left_margin %d\n",\r\nfbi->fb.fix.id, var->left_margin);\r\nif (var->right_margin < 1 || var->right_margin > 255)\r\nprintk(KERN_ERR "%s: invalid right_margin %d\n",\r\nfbi->fb.fix.id, var->right_margin);\r\nif (var->yres < 1 || var->yres > 1024)\r\nprintk(KERN_ERR "%s: invalid yres %d\n",\r\nfbi->fb.fix.id, var->yres);\r\nif (var->vsync_len < 1 || var->vsync_len > 64)\r\nprintk(KERN_ERR "%s: invalid vsync_len %d\n",\r\nfbi->fb.fix.id, var->vsync_len);\r\nif (var->upper_margin < 0 || var->upper_margin > 255)\r\nprintk(KERN_ERR "%s: invalid upper_margin %d\n",\r\nfbi->fb.fix.id, var->upper_margin);\r\nif (var->lower_margin < 0 || var->lower_margin > 255)\r\nprintk(KERN_ERR "%s: invalid lower_margin %d\n",\r\nfbi->fb.fix.id, var->lower_margin);\r\n#endif\r\nnew_regs.lccr0 = fbi->lccr0 |\r\nLCCR0_LEN | LCCR0_LDM | LCCR0_BAM |\r\nLCCR0_ERM | LCCR0_LtlEnd | LCCR0_DMADel(0);\r\nnew_regs.lccr1 =\r\nLCCR1_DisWdth(var->xres) +\r\nLCCR1_HorSnchWdth(var->hsync_len) +\r\nLCCR1_BegLnDel(var->left_margin) +\r\nLCCR1_EndLnDel(var->right_margin);\r\nyres = var->yres;\r\nif (fbi->lccr0 & LCCR0_Dual)\r\nyres /= 2;\r\nnew_regs.lccr2 =\r\nLCCR2_DisHght(yres) +\r\nLCCR2_VrtSnchWdth(var->vsync_len) +\r\nLCCR2_BegFrmDel(var->upper_margin) +\r\nLCCR2_EndFrmDel(var->lower_margin);\r\npcd = get_pcd(var->pixclock, cpufreq_get(0));\r\nnew_regs.lccr3 = LCCR3_PixClkDiv(pcd) | fbi->lccr3 |\r\n(var->sync & FB_SYNC_HOR_HIGH_ACT ? LCCR3_HorSnchH : LCCR3_HorSnchL) |\r\n(var->sync & FB_SYNC_VERT_HIGH_ACT ? LCCR3_VrtSnchH : LCCR3_VrtSnchL);\r\nDPRINTK("nlccr0 = 0x%08lx\n", new_regs.lccr0);\r\nDPRINTK("nlccr1 = 0x%08lx\n", new_regs.lccr1);\r\nDPRINTK("nlccr2 = 0x%08lx\n", new_regs.lccr2);\r\nDPRINTK("nlccr3 = 0x%08lx\n", new_regs.lccr3);\r\nhalf_screen_size = var->bits_per_pixel;\r\nhalf_screen_size = half_screen_size * var->xres * var->yres / 16;\r\nlocal_irq_save(flags);\r\nfbi->dbar1 = fbi->palette_dma;\r\nfbi->dbar2 = fbi->screen_dma + half_screen_size;\r\nfbi->reg_lccr0 = new_regs.lccr0;\r\nfbi->reg_lccr1 = new_regs.lccr1;\r\nfbi->reg_lccr2 = new_regs.lccr2;\r\nfbi->reg_lccr3 = new_regs.lccr3;\r\nlocal_irq_restore(flags);\r\nif ((LCCR0 != fbi->reg_lccr0) || (LCCR1 != fbi->reg_lccr1) ||\r\n(LCCR2 != fbi->reg_lccr2) || (LCCR3 != fbi->reg_lccr3) ||\r\n(DBAR1 != fbi->dbar1) || (DBAR2 != fbi->dbar2))\r\nsa1100fb_schedule_work(fbi, C_REENABLE);\r\nreturn 0;\r\n}\r\nstatic inline void __sa1100fb_backlight_power(struct sa1100fb_info *fbi, int on)\r\n{\r\nDPRINTK("backlight o%s\n", on ? "n" : "ff");\r\nif (sa1100fb_backlight_power)\r\nsa1100fb_backlight_power(on);\r\n}\r\nstatic inline void __sa1100fb_lcd_power(struct sa1100fb_info *fbi, int on)\r\n{\r\nDPRINTK("LCD power o%s\n", on ? "n" : "ff");\r\nif (sa1100fb_lcd_power)\r\nsa1100fb_lcd_power(on);\r\n}\r\nstatic void sa1100fb_setup_gpio(struct sa1100fb_info *fbi)\r\n{\r\nu_int mask = 0;\r\nif ((fbi->reg_lccr0 & LCCR0_CMS) == LCCR0_Color &&\r\n(fbi->reg_lccr0 & (LCCR0_Dual|LCCR0_Act)) != 0) {\r\nmask = GPIO_LDD11 | GPIO_LDD10 | GPIO_LDD9 | GPIO_LDD8;\r\nif (fbi->fb.var.bits_per_pixel > 8 ||\r\n(fbi->reg_lccr0 & (LCCR0_Dual|LCCR0_Act)) == LCCR0_Dual)\r\nmask |= GPIO_LDD15 | GPIO_LDD14 | GPIO_LDD13 | GPIO_LDD12;\r\n}\r\nif (mask) {\r\nGPDR |= mask;\r\nGAFR |= mask;\r\n}\r\n}\r\nstatic void sa1100fb_enable_controller(struct sa1100fb_info *fbi)\r\n{\r\nDPRINTK("Enabling LCD controller\n");\r\nfbi->palette_cpu[0] &= 0xcfff;\r\nfbi->palette_cpu[0] |= palette_pbs(&fbi->fb.var);\r\nLCCR3 = fbi->reg_lccr3;\r\nLCCR2 = fbi->reg_lccr2;\r\nLCCR1 = fbi->reg_lccr1;\r\nLCCR0 = fbi->reg_lccr0 & ~LCCR0_LEN;\r\nDBAR1 = fbi->dbar1;\r\nDBAR2 = fbi->dbar2;\r\nLCCR0 |= LCCR0_LEN;\r\nif (machine_is_shannon()) {\r\nGPDR |= SHANNON_GPIO_DISP_EN;\r\nGPSR |= SHANNON_GPIO_DISP_EN;\r\n}\r\nDPRINTK("DBAR1 = 0x%08x\n", DBAR1);\r\nDPRINTK("DBAR2 = 0x%08x\n", DBAR2);\r\nDPRINTK("LCCR0 = 0x%08x\n", LCCR0);\r\nDPRINTK("LCCR1 = 0x%08x\n", LCCR1);\r\nDPRINTK("LCCR2 = 0x%08x\n", LCCR2);\r\nDPRINTK("LCCR3 = 0x%08x\n", LCCR3);\r\n}\r\nstatic void sa1100fb_disable_controller(struct sa1100fb_info *fbi)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nDPRINTK("Disabling LCD controller\n");\r\nif (machine_is_shannon()) {\r\nGPCR |= SHANNON_GPIO_DISP_EN;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&fbi->ctrlr_wait, &wait);\r\nLCSR = 0xffffffff;\r\nLCCR0 &= ~LCCR0_LDM;\r\nLCCR0 &= ~LCCR0_LEN;\r\nschedule_timeout(20 * HZ / 1000);\r\nremove_wait_queue(&fbi->ctrlr_wait, &wait);\r\n}\r\nstatic irqreturn_t sa1100fb_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct sa1100fb_info *fbi = dev_id;\r\nunsigned int lcsr = LCSR;\r\nif (lcsr & LCSR_LDD) {\r\nLCCR0 |= LCCR0_LDM;\r\nwake_up(&fbi->ctrlr_wait);\r\n}\r\nLCSR = lcsr;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void set_ctrlr_state(struct sa1100fb_info *fbi, u_int state)\r\n{\r\nu_int old_state;\r\nmutex_lock(&fbi->ctrlr_lock);\r\nold_state = fbi->state;\r\nif (old_state == C_STARTUP && state == C_REENABLE)\r\nstate = C_ENABLE;\r\nswitch (state) {\r\ncase C_DISABLE_CLKCHANGE:\r\nif (old_state != C_DISABLE && old_state != C_DISABLE_PM) {\r\nfbi->state = state;\r\nsa1100fb_disable_controller(fbi);\r\n}\r\nbreak;\r\ncase C_DISABLE_PM:\r\ncase C_DISABLE:\r\nif (old_state != C_DISABLE) {\r\nfbi->state = state;\r\n__sa1100fb_backlight_power(fbi, 0);\r\nif (old_state != C_DISABLE_CLKCHANGE)\r\nsa1100fb_disable_controller(fbi);\r\n__sa1100fb_lcd_power(fbi, 0);\r\n}\r\nbreak;\r\ncase C_ENABLE_CLKCHANGE:\r\nif (old_state == C_DISABLE_CLKCHANGE) {\r\nfbi->state = C_ENABLE;\r\nsa1100fb_enable_controller(fbi);\r\n}\r\nbreak;\r\ncase C_REENABLE:\r\nif (old_state == C_ENABLE) {\r\nsa1100fb_disable_controller(fbi);\r\nsa1100fb_setup_gpio(fbi);\r\nsa1100fb_enable_controller(fbi);\r\n}\r\nbreak;\r\ncase C_ENABLE_PM:\r\nif (old_state != C_DISABLE_PM)\r\nbreak;\r\ncase C_ENABLE:\r\nif (old_state != C_ENABLE) {\r\nfbi->state = C_ENABLE;\r\nsa1100fb_setup_gpio(fbi);\r\n__sa1100fb_lcd_power(fbi, 1);\r\nsa1100fb_enable_controller(fbi);\r\n__sa1100fb_backlight_power(fbi, 1);\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&fbi->ctrlr_lock);\r\n}\r\nstatic void sa1100fb_task(struct work_struct *w)\r\n{\r\nstruct sa1100fb_info *fbi = container_of(w, struct sa1100fb_info, task);\r\nu_int state = xchg(&fbi->task_state, -1);\r\nset_ctrlr_state(fbi, state);\r\n}\r\nstatic unsigned int sa1100fb_min_dma_period(struct sa1100fb_info *fbi)\r\n{\r\n#if 0\r\nunsigned int min_period = (unsigned int)-1;\r\nint i;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nstruct display *disp = &fb_display[i];\r\nunsigned int period;\r\nif (disp->fb_info != &fbi->fb)\r\ncontinue;\r\nperiod = sa1100fb_display_dma_period(&disp->var);\r\nif (period < min_period)\r\nmin_period = period;\r\n}\r\nreturn min_period;\r\n#else\r\nreturn sa1100fb_display_dma_period(&fbi->fb.var);\r\n#endif\r\n}\r\nstatic int\r\nsa1100fb_freq_transition(struct notifier_block *nb, unsigned long val,\r\nvoid *data)\r\n{\r\nstruct sa1100fb_info *fbi = TO_INF(nb, freq_transition);\r\nstruct cpufreq_freqs *f = data;\r\nu_int pcd;\r\nswitch (val) {\r\ncase CPUFREQ_PRECHANGE:\r\nset_ctrlr_state(fbi, C_DISABLE_CLKCHANGE);\r\nbreak;\r\ncase CPUFREQ_POSTCHANGE:\r\npcd = get_pcd(fbi->fb.var.pixclock, f->new);\r\nfbi->reg_lccr3 = (fbi->reg_lccr3 & ~0xff) | LCCR3_PixClkDiv(pcd);\r\nset_ctrlr_state(fbi, C_ENABLE_CLKCHANGE);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsa1100fb_freq_policy(struct notifier_block *nb, unsigned long val,\r\nvoid *data)\r\n{\r\nstruct sa1100fb_info *fbi = TO_INF(nb, freq_policy);\r\nstruct cpufreq_policy *policy = data;\r\nswitch (val) {\r\ncase CPUFREQ_ADJUST:\r\ncase CPUFREQ_INCOMPATIBLE:\r\nprintk(KERN_DEBUG "min dma period: %d ps, "\r\n"new clock %d kHz\n", sa1100fb_min_dma_period(fbi),\r\npolicy->max);\r\nbreak;\r\ncase CPUFREQ_NOTIFY:\r\ndo {} while(0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sa1100fb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct sa1100fb_info *fbi = platform_get_drvdata(dev);\r\nset_ctrlr_state(fbi, C_DISABLE_PM);\r\nreturn 0;\r\n}\r\nstatic int sa1100fb_resume(struct platform_device *dev)\r\n{\r\nstruct sa1100fb_info *fbi = platform_get_drvdata(dev);\r\nset_ctrlr_state(fbi, C_ENABLE_PM);\r\nreturn 0;\r\n}\r\nstatic int __init sa1100fb_map_video_memory(struct sa1100fb_info *fbi)\r\n{\r\nfbi->map_size = PAGE_ALIGN(fbi->fb.fix.smem_len + PAGE_SIZE);\r\nfbi->map_cpu = dma_alloc_writecombine(fbi->dev, fbi->map_size,\r\n&fbi->map_dma, GFP_KERNEL);\r\nif (fbi->map_cpu) {\r\nfbi->fb.screen_base = fbi->map_cpu + PAGE_SIZE;\r\nfbi->screen_dma = fbi->map_dma + PAGE_SIZE;\r\nfbi->fb.fix.smem_start = fbi->screen_dma;\r\n}\r\nreturn fbi->map_cpu ? 0 : -ENOMEM;\r\n}\r\nstatic struct sa1100fb_info * __init sa1100fb_init_fbinfo(struct device *dev)\r\n{\r\nstruct sa1100fb_mach_info *inf;\r\nstruct sa1100fb_info *fbi;\r\nfbi = kmalloc(sizeof(struct sa1100fb_info) + sizeof(u32) * 16,\r\nGFP_KERNEL);\r\nif (!fbi)\r\nreturn NULL;\r\nmemset(fbi, 0, sizeof(struct sa1100fb_info));\r\nfbi->dev = dev;\r\nstrcpy(fbi->fb.fix.id, SA1100_NAME);\r\nfbi->fb.fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbi->fb.fix.type_aux = 0;\r\nfbi->fb.fix.xpanstep = 0;\r\nfbi->fb.fix.ypanstep = 0;\r\nfbi->fb.fix.ywrapstep = 0;\r\nfbi->fb.fix.accel = FB_ACCEL_NONE;\r\nfbi->fb.var.nonstd = 0;\r\nfbi->fb.var.activate = FB_ACTIVATE_NOW;\r\nfbi->fb.var.height = -1;\r\nfbi->fb.var.width = -1;\r\nfbi->fb.var.accel_flags = 0;\r\nfbi->fb.var.vmode = FB_VMODE_NONINTERLACED;\r\nfbi->fb.fbops = &sa1100fb_ops;\r\nfbi->fb.flags = FBINFO_DEFAULT;\r\nfbi->fb.monspecs = monspecs;\r\nfbi->fb.pseudo_palette = (fbi + 1);\r\nfbi->rgb[RGB_4] = &rgb_4;\r\nfbi->rgb[RGB_8] = &rgb_8;\r\nfbi->rgb[RGB_16] = &def_rgb_16;\r\ninf = sa1100fb_get_machine_info(fbi);\r\nif (inf->lccr3 & (LCCR3_VrtSnchL|LCCR3_HorSnchL|0xff) ||\r\ninf->pixclock == 0)\r\npanic("sa1100fb error: invalid LCCR3 fields set or zero "\r\n"pixclock.");\r\nfbi->max_xres = inf->xres;\r\nfbi->fb.var.xres = inf->xres;\r\nfbi->fb.var.xres_virtual = inf->xres;\r\nfbi->max_yres = inf->yres;\r\nfbi->fb.var.yres = inf->yres;\r\nfbi->fb.var.yres_virtual = inf->yres;\r\nfbi->max_bpp = inf->bpp;\r\nfbi->fb.var.bits_per_pixel = inf->bpp;\r\nfbi->fb.var.pixclock = inf->pixclock;\r\nfbi->fb.var.hsync_len = inf->hsync_len;\r\nfbi->fb.var.left_margin = inf->left_margin;\r\nfbi->fb.var.right_margin = inf->right_margin;\r\nfbi->fb.var.vsync_len = inf->vsync_len;\r\nfbi->fb.var.upper_margin = inf->upper_margin;\r\nfbi->fb.var.lower_margin = inf->lower_margin;\r\nfbi->fb.var.sync = inf->sync;\r\nfbi->fb.var.grayscale = inf->cmap_greyscale;\r\nfbi->cmap_inverse = inf->cmap_inverse;\r\nfbi->cmap_static = inf->cmap_static;\r\nfbi->lccr0 = inf->lccr0;\r\nfbi->lccr3 = inf->lccr3;\r\nfbi->state = C_STARTUP;\r\nfbi->task_state = (u_char)-1;\r\nfbi->fb.fix.smem_len = fbi->max_xres * fbi->max_yres *\r\nfbi->max_bpp / 8;\r\ninit_waitqueue_head(&fbi->ctrlr_wait);\r\nINIT_WORK(&fbi->task, sa1100fb_task);\r\nmutex_init(&fbi->ctrlr_lock);\r\nreturn fbi;\r\n}\r\nstatic int __devinit sa1100fb_probe(struct platform_device *pdev)\r\n{\r\nstruct sa1100fb_info *fbi;\r\nint ret, irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -EINVAL;\r\nif (!request_mem_region(0xb0100000, 0x10000, "LCD"))\r\nreturn -EBUSY;\r\nfbi = sa1100fb_init_fbinfo(&pdev->dev);\r\nret = -ENOMEM;\r\nif (!fbi)\r\ngoto failed;\r\nret = sa1100fb_map_video_memory(fbi);\r\nif (ret)\r\ngoto failed;\r\nret = request_irq(irq, sa1100fb_handle_irq, IRQF_DISABLED,\r\n"LCD", fbi);\r\nif (ret) {\r\nprintk(KERN_ERR "sa1100fb: request_irq failed: %d\n", ret);\r\ngoto failed;\r\n}\r\n#ifdef ASSABET_PAL_VIDEO\r\nif (machine_is_assabet())\r\nASSABET_BCR_clear(ASSABET_BCR_LCD_ON);\r\n#endif\r\nsa1100fb_check_var(&fbi->fb.var, &fbi->fb);\r\nplatform_set_drvdata(pdev, fbi);\r\nret = register_framebuffer(&fbi->fb);\r\nif (ret < 0)\r\ngoto err_free_irq;\r\n#ifdef CONFIG_CPU_FREQ\r\nfbi->freq_transition.notifier_call = sa1100fb_freq_transition;\r\nfbi->freq_policy.notifier_call = sa1100fb_freq_policy;\r\ncpufreq_register_notifier(&fbi->freq_transition, CPUFREQ_TRANSITION_NOTIFIER);\r\ncpufreq_register_notifier(&fbi->freq_policy, CPUFREQ_POLICY_NOTIFIER);\r\n#endif\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq, fbi);\r\nfailed:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(fbi);\r\nrelease_mem_region(0xb0100000, 0x10000);\r\nreturn ret;\r\n}\r\nint __init sa1100fb_init(void)\r\n{\r\nif (fb_get_options("sa1100fb", NULL))\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&sa1100fb_driver);\r\n}\r\nint __init sa1100fb_setup(char *options)\r\n{\r\n#if 0\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "bpp:", 4))\r\ncurrent_par.max_bpp =\r\nsimple_strtoul(this_opt + 4, NULL, 0);\r\nif (!strncmp(this_opt, "lccr0:", 6))\r\nlcd_shadow.lccr0 =\r\nsimple_strtoul(this_opt + 6, NULL, 0);\r\nif (!strncmp(this_opt, "lccr1:", 6)) {\r\nlcd_shadow.lccr1 =\r\nsimple_strtoul(this_opt + 6, NULL, 0);\r\ncurrent_par.max_xres =\r\n(lcd_shadow.lccr1 & 0x3ff) + 16;\r\n}\r\nif (!strncmp(this_opt, "lccr2:", 6)) {\r\nlcd_shadow.lccr2 =\r\nsimple_strtoul(this_opt + 6, NULL, 0);\r\ncurrent_par.max_yres =\r\n(lcd_shadow.\r\nlccr0 & LCCR0_SDS) ? ((lcd_shadow.\r\nlccr2 & 0x3ff) +\r\n1) *\r\n2 : ((lcd_shadow.lccr2 & 0x3ff) + 1);\r\n}\r\nif (!strncmp(this_opt, "lccr3:", 6))\r\nlcd_shadow.lccr3 =\r\nsimple_strtoul(this_opt + 6, NULL, 0);\r\n}\r\n#endif\r\nreturn 0;\r\n}
