void\r\nBMIInit(void)\r\n{\r\nbmiDone = false;\r\npendingEventsFuncCheck = false;\r\nif (!pBMICmdCredits) {\r\npBMICmdCredits = (u32 *)A_MALLOC_NOWAIT(4);\r\nA_ASSERT(pBMICmdCredits);\r\n}\r\nif (!pBMICmdBuf) {\r\npBMICmdBuf = (u8 *)A_MALLOC_NOWAIT(MAX_BMI_CMDBUF_SZ);\r\nA_ASSERT(pBMICmdBuf);\r\n}\r\nA_REGISTER_MODULE_DEBUG_INFO(bmi);\r\n}\r\nvoid\r\nBMICleanup(void)\r\n{\r\nif (pBMICmdCredits) {\r\nkfree(pBMICmdCredits);\r\npBMICmdCredits = NULL;\r\n}\r\nif (pBMICmdBuf) {\r\nkfree(pBMICmdBuf);\r\npBMICmdBuf = NULL;\r\n}\r\n}\r\nint\r\nBMIDone(struct hif_device *device)\r\n{\r\nint status;\r\nu32 cid;\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF (ATH_DEBUG_BMI, ("BMIDone skipped\n"));\r\nreturn 0;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Done: Enter (device: 0x%p)\n", device));\r\nbmiDone = true;\r\ncid = BMI_DONE;\r\nstatus = bmiBufferSend(device, (u8 *)&cid, sizeof(cid));\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nif (pBMICmdCredits) {\r\nkfree(pBMICmdCredits);\r\npBMICmdCredits = NULL;\r\n}\r\nif (pBMICmdBuf) {\r\nkfree(pBMICmdBuf);\r\npBMICmdBuf = NULL;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Done: Exit\n"));\r\nreturn 0;\r\n}\r\nint\r\nBMIGetTargetInfo(struct hif_device *device, struct bmi_target_info *targ_info)\r\n{\r\nint status;\r\nu32 cid;\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Get Target Info: Enter (device: 0x%p)\n", device));\r\ncid = BMI_GET_TARGET_INFO;\r\nstatus = bmiBufferSend(device, (u8 *)&cid, sizeof(cid));\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nstatus = bmiBufferReceive(device, (u8 *)&targ_info->target_ver,\r\nsizeof(targ_info->target_ver), true);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Version from the device\n"));\r\nreturn A_ERROR;\r\n}\r\nif (targ_info->target_ver == TARGET_VERSION_SENTINAL) {\r\nstatus = bmiBufferReceive(device, (u8 *)&targ_info->target_info_byte_count,\r\nsizeof(targ_info->target_info_byte_count), true);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Info Byte Count from the device\n"));\r\nreturn A_ERROR;\r\n}\r\nA_ASSERT(targ_info->target_info_byte_count == sizeof(*targ_info));\r\nstatus = bmiBufferReceive(device,\r\n((u8 *)targ_info)+sizeof(targ_info->target_info_byte_count),\r\nsizeof(*targ_info)-sizeof(targ_info->target_info_byte_count), true);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Info (%d bytes) from the device\n",\r\ntarg_info->target_info_byte_count));\r\nreturn A_ERROR;\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Get Target Info: Exit (ver: 0x%x type: 0x%x)\n",\r\ntarg_info->target_ver, targ_info->target_type));\r\nreturn 0;\r\n}\r\nint\r\nBMIReadMemory(struct hif_device *device,\r\nu32 address,\r\nu8 *buffer,\r\nu32 length)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nu32 remaining, rxlen;\r\nA_ASSERT(BMI_COMMAND_FITS(BMI_DATASZ_MAX + sizeof(cid) + sizeof(address) + sizeof(length)));\r\nmemset (pBMICmdBuf, 0, BMI_DATASZ_MAX + sizeof(cid) + sizeof(address) + sizeof(length));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI Read Memory: Enter (device: 0x%p, address: 0x%x, length: %d)\n",\r\ndevice, address, length));\r\ncid = BMI_READ_MEMORY;\r\nremaining = length;\r\nwhile (remaining)\r\n{\r\nrxlen = (remaining < BMI_DATASZ_MAX) ? remaining : BMI_DATASZ_MAX;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &address, sizeof(address));\r\noffset += sizeof(address);\r\nmemcpy(&(pBMICmdBuf[offset]), &rxlen, sizeof(rxlen));\r\noffset += sizeof(length);\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nstatus = bmiBufferReceive(device, pBMICmdBuf, rxlen, true);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));\r\nreturn A_ERROR;\r\n}\r\nmemcpy(&buffer[length - remaining], pBMICmdBuf, rxlen);\r\nremaining -= rxlen; address += rxlen;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read Memory: Exit\n"));\r\nreturn 0;\r\n}\r\nint\r\nBMIWriteMemory(struct hif_device *device,\r\nu32 address,\r\nu8 *buffer,\r\nu32 length)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nu32 remaining, txlen;\r\nconst u32 header = sizeof(cid) + sizeof(address) + sizeof(length);\r\nu8 alignedBuffer[BMI_DATASZ_MAX];\r\nu8 *src;\r\nA_ASSERT(BMI_COMMAND_FITS(BMI_DATASZ_MAX + header));\r\nmemset (pBMICmdBuf, 0, BMI_DATASZ_MAX + header);\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI Write Memory: Enter (device: 0x%p, address: 0x%x, length: %d)\n",\r\ndevice, address, length));\r\ncid = BMI_WRITE_MEMORY;\r\nremaining = length;\r\nwhile (remaining)\r\n{\r\nsrc = &buffer[length - remaining];\r\nif (remaining < (BMI_DATASZ_MAX - header)) {\r\nif (remaining & 3) {\r\nremaining = remaining + (4 - (remaining & 3));\r\nmemcpy(alignedBuffer, src, remaining);\r\nsrc = alignedBuffer;\r\n}\r\ntxlen = remaining;\r\n} else {\r\ntxlen = (BMI_DATASZ_MAX - header);\r\n}\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &address, sizeof(address));\r\noffset += sizeof(address);\r\nmemcpy(&(pBMICmdBuf[offset]), &txlen, sizeof(txlen));\r\noffset += sizeof(txlen);\r\nmemcpy(&(pBMICmdBuf[offset]), src, txlen);\r\noffset += txlen;\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nremaining -= txlen; address += txlen;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Write Memory: Exit\n"));\r\nreturn 0;\r\n}\r\nint\r\nBMIExecute(struct hif_device *device,\r\nu32 address,\r\nu32 *param)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nA_ASSERT(BMI_COMMAND_FITS(sizeof(cid) + sizeof(address) + sizeof(param)));\r\nmemset (pBMICmdBuf, 0, sizeof(cid) + sizeof(address) + sizeof(param));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI Execute: Enter (device: 0x%p, address: 0x%x, param: %d)\n",\r\ndevice, address, *param));\r\ncid = BMI_EXECUTE;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &address, sizeof(address));\r\noffset += sizeof(address);\r\nmemcpy(&(pBMICmdBuf[offset]), param, sizeof(*param));\r\noffset += sizeof(*param);\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nstatus = bmiBufferReceive(device, pBMICmdBuf, sizeof(*param), false);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));\r\nreturn A_ERROR;\r\n}\r\nmemcpy(param, pBMICmdBuf, sizeof(*param));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Execute: Exit (param: %d)\n", *param));\r\nreturn 0;\r\n}\r\nint\r\nBMISetAppStart(struct hif_device *device,\r\nu32 address)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nA_ASSERT(BMI_COMMAND_FITS(sizeof(cid) + sizeof(address)));\r\nmemset (pBMICmdBuf, 0, sizeof(cid) + sizeof(address));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI Set App Start: Enter (device: 0x%p, address: 0x%x)\n",\r\ndevice, address));\r\ncid = BMI_SET_APP_START;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &address, sizeof(address));\r\noffset += sizeof(address);\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Set App Start: Exit\n"));\r\nreturn 0;\r\n}\r\nint\r\nBMIReadSOCRegister(struct hif_device *device,\r\nu32 address,\r\nu32 *param)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nA_ASSERT(BMI_COMMAND_FITS(sizeof(cid) + sizeof(address)));\r\nmemset (pBMICmdBuf, 0, sizeof(cid) + sizeof(address));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI Read SOC Register: Enter (device: 0x%p, address: 0x%x)\n",\r\ndevice, address));\r\ncid = BMI_READ_SOC_REGISTER;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &address, sizeof(address));\r\noffset += sizeof(address);\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nstatus = bmiBufferReceive(device, pBMICmdBuf, sizeof(*param), true);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));\r\nreturn A_ERROR;\r\n}\r\nmemcpy(param, pBMICmdBuf, sizeof(*param));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read SOC Register: Exit (value: %d)\n", *param));\r\nreturn 0;\r\n}\r\nint\r\nBMIWriteSOCRegister(struct hif_device *device,\r\nu32 address,\r\nu32 param)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nA_ASSERT(BMI_COMMAND_FITS(sizeof(cid) + sizeof(address) + sizeof(param)));\r\nmemset (pBMICmdBuf, 0, sizeof(cid) + sizeof(address) + sizeof(param));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI Write SOC Register: Enter (device: 0x%p, address: 0x%x, param: %d)\n",\r\ndevice, address, param));\r\ncid = BMI_WRITE_SOC_REGISTER;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &address, sizeof(address));\r\noffset += sizeof(address);\r\nmemcpy(&(pBMICmdBuf[offset]), &param, sizeof(param));\r\noffset += sizeof(param);\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read SOC Register: Exit\n"));\r\nreturn 0;\r\n}\r\nint\r\nBMIrompatchInstall(struct hif_device *device,\r\nu32 ROM_addr,\r\nu32 RAM_addr,\r\nu32 nbytes,\r\nu32 do_activate,\r\nu32 *rompatch_id)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nA_ASSERT(BMI_COMMAND_FITS(sizeof(cid) + sizeof(ROM_addr) + sizeof(RAM_addr) +\r\nsizeof(nbytes) + sizeof(do_activate)));\r\nmemset(pBMICmdBuf, 0, sizeof(cid) + sizeof(ROM_addr) + sizeof(RAM_addr) +\r\nsizeof(nbytes) + sizeof(do_activate));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI rompatch Install: Enter (device: 0x%p, ROMaddr: 0x%x, RAMaddr: 0x%x length: %d activate: %d)\n",\r\ndevice, ROM_addr, RAM_addr, nbytes, do_activate));\r\ncid = BMI_ROMPATCH_INSTALL;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &ROM_addr, sizeof(ROM_addr));\r\noffset += sizeof(ROM_addr);\r\nmemcpy(&(pBMICmdBuf[offset]), &RAM_addr, sizeof(RAM_addr));\r\noffset += sizeof(RAM_addr);\r\nmemcpy(&(pBMICmdBuf[offset]), &nbytes, sizeof(nbytes));\r\noffset += sizeof(nbytes);\r\nmemcpy(&(pBMICmdBuf[offset]), &do_activate, sizeof(do_activate));\r\noffset += sizeof(do_activate);\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nstatus = bmiBufferReceive(device, pBMICmdBuf, sizeof(*rompatch_id), true);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));\r\nreturn A_ERROR;\r\n}\r\nmemcpy(rompatch_id, pBMICmdBuf, sizeof(*rompatch_id));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI rompatch Install: (rompatch_id=%d)\n", *rompatch_id));\r\nreturn 0;\r\n}\r\nint\r\nBMIrompatchUninstall(struct hif_device *device,\r\nu32 rompatch_id)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nA_ASSERT(BMI_COMMAND_FITS(sizeof(cid) + sizeof(rompatch_id)));\r\nmemset (pBMICmdBuf, 0, sizeof(cid) + sizeof(rompatch_id));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI rompatch Uninstall: Enter (device: 0x%p, rompatch_id: %d)\n",\r\ndevice, rompatch_id));\r\ncid = BMI_ROMPATCH_UNINSTALL;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &rompatch_id, sizeof(rompatch_id));\r\noffset += sizeof(rompatch_id);\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI rompatch UNinstall: (rompatch_id=0x%x)\n", rompatch_id));\r\nreturn 0;\r\n}\r\nstatic int\r\n_BMIrompatchChangeActivation(struct hif_device *device,\r\nu32 rompatch_count,\r\nu32 *rompatch_list,\r\nu32 do_activate)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nu32 length;\r\nA_ASSERT(BMI_COMMAND_FITS(BMI_DATASZ_MAX + sizeof(cid) + sizeof(rompatch_count)));\r\nmemset(pBMICmdBuf, 0, BMI_DATASZ_MAX + sizeof(cid) + sizeof(rompatch_count));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI Change rompatch Activation: Enter (device: 0x%p, count: %d)\n",\r\ndevice, rompatch_count));\r\ncid = do_activate ? BMI_ROMPATCH_ACTIVATE : BMI_ROMPATCH_DEACTIVATE;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &rompatch_count, sizeof(rompatch_count));\r\noffset += sizeof(rompatch_count);\r\nlength = rompatch_count * sizeof(*rompatch_list);\r\nmemcpy(&(pBMICmdBuf[offset]), rompatch_list, length);\r\noffset += length;\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Change rompatch Activation: Exit\n"));\r\nreturn 0;\r\n}\r\nint\r\nBMIrompatchActivate(struct hif_device *device,\r\nu32 rompatch_count,\r\nu32 *rompatch_list)\r\n{\r\nreturn _BMIrompatchChangeActivation(device, rompatch_count, rompatch_list, 1);\r\n}\r\nint\r\nBMIrompatchDeactivate(struct hif_device *device,\r\nu32 rompatch_count,\r\nu32 *rompatch_list)\r\n{\r\nreturn _BMIrompatchChangeActivation(device, rompatch_count, rompatch_list, 0);\r\n}\r\nint\r\nBMILZData(struct hif_device *device,\r\nu8 *buffer,\r\nu32 length)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nu32 remaining, txlen;\r\nconst u32 header = sizeof(cid) + sizeof(length);\r\nA_ASSERT(BMI_COMMAND_FITS(BMI_DATASZ_MAX+header));\r\nmemset (pBMICmdBuf, 0, BMI_DATASZ_MAX+header);\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI Send LZ Data: Enter (device: 0x%p, length: %d)\n",\r\ndevice, length));\r\ncid = BMI_LZ_DATA;\r\nremaining = length;\r\nwhile (remaining)\r\n{\r\ntxlen = (remaining < (BMI_DATASZ_MAX - header)) ?\r\nremaining : (BMI_DATASZ_MAX - header);\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &txlen, sizeof(txlen));\r\noffset += sizeof(txlen);\r\nmemcpy(&(pBMICmdBuf[offset]), &buffer[length - remaining], txlen);\r\noffset += txlen;\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nremaining -= txlen;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI LZ Data: Exit\n"));\r\nreturn 0;\r\n}\r\nint\r\nBMILZStreamStart(struct hif_device *device,\r\nu32 address)\r\n{\r\nu32 cid;\r\nint status;\r\nu32 offset;\r\nA_ASSERT(BMI_COMMAND_FITS(sizeof(cid) + sizeof(address)));\r\nmemset (pBMICmdBuf, 0, sizeof(cid) + sizeof(address));\r\nif (bmiDone) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI,\r\n("BMI LZ Stream Start: Enter (device: 0x%p, address: 0x%x)\n",\r\ndevice, address));\r\ncid = BMI_LZ_STREAM_START;\r\noffset = 0;\r\nmemcpy(&(pBMICmdBuf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(pBMICmdBuf[offset]), &address, sizeof(address));\r\noffset += sizeof(address);\r\nstatus = bmiBufferSend(device, pBMICmdBuf, offset);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to Start LZ Stream to the device\n"));\r\nreturn A_ERROR;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI LZ Stream Start: Exit\n"));\r\nreturn 0;\r\n}\r\nint\r\nbmiBufferSend(struct hif_device *device,\r\nu8 *buffer,\r\nu32 length)\r\n{\r\nint status;\r\nu32 timeout;\r\nu32 address;\r\nu32 mboxAddress[HTC_MAILBOX_NUM_MAX];\r\nHIFConfigureDevice(device, HIF_DEVICE_GET_MBOX_ADDR,\r\n&mboxAddress[0], sizeof(mboxAddress));\r\n*pBMICmdCredits = 0;\r\ntimeout = BMI_COMMUNICATION_TIMEOUT;\r\nwhile(timeout-- && !(*pBMICmdCredits)) {\r\naddress = COUNT_DEC_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 4;\r\nstatus = HIFReadWrite(device, address, (u8 *)pBMICmdCredits, 4,\r\nHIF_RD_SYNC_BYTE_INC, NULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to decrement the command credit count register\n"));\r\nreturn A_ERROR;\r\n}\r\n(*pBMICmdCredits) &= 0xFF;\r\n}\r\nif (*pBMICmdCredits) {\r\naddress = mboxAddress[ENDPOINT1];\r\nstatus = HIFReadWrite(device, address, buffer, length,\r\nHIF_WR_SYNC_BYTE_INC, NULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to send the BMI data to the device\n"));\r\nreturn A_ERROR;\r\n}\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("BMI Communication timeout - bmiBufferSend\n"));\r\nreturn A_ERROR;\r\n}\r\nreturn status;\r\n}\r\nint\r\nbmiBufferReceive(struct hif_device *device,\r\nu8 *buffer,\r\nu32 length,\r\nbool want_timeout)\r\n{\r\nint status;\r\nu32 address;\r\nu32 mboxAddress[HTC_MAILBOX_NUM_MAX];\r\nstruct hif_pending_events_info hifPendingEvents;\r\nstatic HIF_PENDING_EVENTS_FUNC getPendingEventsFunc = NULL;\r\nif (!pendingEventsFuncCheck) {\r\nHIFConfigureDevice(device,\r\nHIF_DEVICE_GET_PENDING_EVENTS_FUNC,\r\n&getPendingEventsFunc,\r\nsizeof(getPendingEventsFunc));\r\npendingEventsFuncCheck = true;\r\n}\r\nHIFConfigureDevice(device, HIF_DEVICE_GET_MBOX_ADDR,\r\n&mboxAddress[0], sizeof(mboxAddress));\r\nif (length >= 4) {\r\nstatic u32 word_available;\r\nu32 timeout;\r\nword_available = 0;\r\ntimeout = BMI_COMMUNICATION_TIMEOUT;\r\nwhile((!want_timeout || timeout--) && !word_available) {\r\nif (getPendingEventsFunc != NULL) {\r\nstatus = getPendingEventsFunc(device,\r\n&hifPendingEvents,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("BMI: Failed to get pending events \n"));\r\nbreak;\r\n}\r\nif (hifPendingEvents.AvailableRecvBytes >= sizeof(u32)) {\r\nword_available = 1;\r\n}\r\ncontinue;\r\n}\r\nstatus = HIFReadWrite(device, RX_LOOKAHEAD_VALID_ADDRESS, (u8 *)&word_available,\r\nsizeof(word_available), HIF_RD_SYNC_BYTE_INC, NULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read RX_LOOKAHEAD_VALID register\n"));\r\nreturn A_ERROR;\r\n}\r\nword_available &= (1 << ENDPOINT1);\r\n}\r\nif (!word_available) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("BMI Communication timeout - bmiBufferReceive FIFO empty\n"));\r\nreturn A_ERROR;\r\n}\r\n}\r\n#define CONSERVATIVE_BMI_READ 0\r\n#if CONSERVATIVE_BMI_READ\r\nif ((length > 4) && (length < 128)) {\r\nu32 timeout;\r\n*pBMICmdCredits = 0;\r\ntimeout = BMI_COMMUNICATION_TIMEOUT;\r\nwhile((!want_timeout || timeout--) && !(*pBMICmdCredits) {\r\naddress = COUNT_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 1;\r\nstatus = HIFReadWrite(device, address, (u8 *)pBMICmdCredits, sizeof(*pBMICmdCredits),\r\nHIF_RD_SYNC_BYTE_FIX, NULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read the command credit count register\n"));\r\nreturn A_ERROR;\r\n}\r\n(*pBMICmdCredits) &= 0xFF;\r\n}\r\nif (!(*pBMICmdCredits)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("BMI Communication timeout- bmiBufferReceive no credit\n"));\r\nreturn A_ERROR;\r\n}\r\n}\r\n#endif\r\naddress = mboxAddress[ENDPOINT1];\r\nstatus = HIFReadWrite(device, address, buffer, length, HIF_RD_SYNC_BYTE_INC, NULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read the BMI data from the device\n"));\r\nreturn A_ERROR;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nBMIFastDownload(struct hif_device *device, u32 address, u8 *buffer, u32 length)\r\n{\r\nint status = A_ERROR;\r\nu32 lastWord = 0;\r\nu32 lastWordOffset = length & ~0x3;\r\nu32 unalignedBytes = length & 0x3;\r\nstatus = BMILZStreamStart (device, address);\r\nif (status) {\r\nreturn A_ERROR;\r\n}\r\nif (unalignedBytes) {\r\nmemcpy(&lastWord, &buffer[lastWordOffset], unalignedBytes);\r\n}\r\nstatus = BMILZData(device, buffer, lastWordOffset);\r\nif (status) {\r\nreturn A_ERROR;\r\n}\r\nif (unalignedBytes) {\r\nstatus = BMILZData(device, (u8 *)&lastWord, 4);\r\n}\r\nif (!status) {\r\nstatus = BMILZStreamStart (device, 0x00);\r\nif (status) {\r\nreturn A_ERROR;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint\r\nBMIRawWrite(struct hif_device *device, u8 *buffer, u32 length)\r\n{\r\nreturn bmiBufferSend(device, buffer, length);\r\n}\r\nint\r\nBMIRawRead(struct hif_device *device, u8 *buffer, u32 length, bool want_timeout)\r\n{\r\nreturn bmiBufferReceive(device, buffer, length, want_timeout);\r\n}
