static unsigned long get_elapsed_seconds(int year)\r\n{\r\nunsigned long secs;\r\nstruct rtc_time tm = {\r\n.tm_year = year - 1900,\r\n.tm_mday = 1,\r\n};\r\nrtc_tm_to_time(&tm, &secs);\r\nreturn secs;\r\n}\r\nstatic int ab8500_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nunsigned long timeout = jiffies + HZ;\r\nint retval, i;\r\nunsigned long mins, secs;\r\nunsigned char buf[ARRAY_SIZE(ab8500_rtc_time_regs)];\r\nu8 value;\r\nretval = abx500_set_register_interruptible(dev,\r\nAB8500_RTC, AB8500_RTC_READ_REQ_REG, RTC_READ_REQUEST);\r\nif (retval < 0)\r\nreturn retval;\r\nif (abx500_get_chip_id(dev) == 0) {\r\nmsleep(1);\r\n} else {\r\nwhile (time_before(jiffies, timeout)) {\r\nretval = abx500_get_register_interruptible(dev,\r\nAB8500_RTC, AB8500_RTC_READ_REQ_REG, &value);\r\nif (retval < 0)\r\nreturn retval;\r\nif (!(value & RTC_READ_REQUEST))\r\nbreak;\r\nmsleep(1);\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_time_regs); i++) {\r\nretval = abx500_get_register_interruptible(dev,\r\nAB8500_RTC, ab8500_rtc_time_regs[i], &value);\r\nif (retval < 0)\r\nreturn retval;\r\nbuf[i] = value;\r\n}\r\nmins = (buf[0] << 16) | (buf[1] << 8) | buf[2];\r\nsecs = (buf[3] << 8) | buf[4];\r\nsecs = secs / COUNTS_PER_SEC;\r\nsecs = secs + (mins * 60);\r\nsecs += get_elapsed_seconds(AB8500_RTC_EPOCH);\r\nrtc_time_to_tm(secs, tm);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int ab8500_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nint retval, i;\r\nunsigned char buf[ARRAY_SIZE(ab8500_rtc_time_regs)];\r\nunsigned long no_secs, no_mins, secs = 0;\r\nif (tm->tm_year < (AB8500_RTC_EPOCH - 1900)) {\r\ndev_dbg(dev, "year should be equal to or greater than %d\n",\r\nAB8500_RTC_EPOCH);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm_to_time(tm, &secs);\r\nsecs -= get_elapsed_seconds(AB8500_RTC_EPOCH);\r\nno_mins = secs / 60;\r\nno_secs = secs % 60;\r\nno_secs = no_secs * COUNTS_PER_SEC;\r\nbuf[4] = no_secs & 0xFF;\r\nbuf[3] = (no_secs >> 8) & 0xFF;\r\nbuf[2] = no_mins & 0xFF;\r\nbuf[1] = (no_mins >> 8) & 0xFF;\r\nbuf[0] = (no_mins >> 16) & 0xFF;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_time_regs); i++) {\r\nretval = abx500_set_register_interruptible(dev, AB8500_RTC,\r\nab8500_rtc_time_regs[i], buf[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn abx500_set_register_interruptible(dev, AB8500_RTC,\r\nAB8500_RTC_READ_REQ_REG, RTC_WRITE_REQUEST);\r\n}\r\nstatic int ab8500_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nint retval, i;\r\nu8 rtc_ctrl, value;\r\nunsigned char buf[ARRAY_SIZE(ab8500_rtc_alarm_regs)];\r\nunsigned long secs, mins;\r\nretval = abx500_get_register_interruptible(dev, AB8500_RTC,\r\nAB8500_RTC_STAT_REG, &rtc_ctrl);\r\nif (retval < 0)\r\nreturn retval;\r\nif (rtc_ctrl & RTC_ALARM_ENA)\r\nalarm->enabled = 1;\r\nelse\r\nalarm->enabled = 0;\r\nalarm->pending = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_alarm_regs); i++) {\r\nretval = abx500_get_register_interruptible(dev, AB8500_RTC,\r\nab8500_rtc_alarm_regs[i], &value);\r\nif (retval < 0)\r\nreturn retval;\r\nbuf[i] = value;\r\n}\r\nmins = (buf[0] << 16) | (buf[1] << 8) | (buf[2]);\r\nsecs = mins * 60;\r\nsecs += get_elapsed_seconds(AB8500_RTC_EPOCH);\r\nrtc_time_to_tm(secs, &alarm->time);\r\nreturn rtc_valid_tm(&alarm->time);\r\n}\r\nstatic int ab8500_rtc_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nreturn abx500_mask_and_set_register_interruptible(dev, AB8500_RTC,\r\nAB8500_RTC_STAT_REG, RTC_ALARM_ENA,\r\nenabled ? RTC_ALARM_ENA : 0);\r\n}\r\nstatic int ab8500_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nint retval, i;\r\nunsigned char buf[ARRAY_SIZE(ab8500_rtc_alarm_regs)];\r\nunsigned long mins, secs = 0;\r\nif (alarm->time.tm_year < (AB8500_RTC_EPOCH - 1900)) {\r\ndev_dbg(dev, "year should be equal to or greater than %d\n",\r\nAB8500_RTC_EPOCH);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm_to_time(&alarm->time, &secs);\r\nsecs -= get_elapsed_seconds(AB8500_RTC_EPOCH);\r\nmins = secs / 60;\r\nbuf[2] = mins & 0xFF;\r\nbuf[1] = (mins >> 8) & 0xFF;\r\nbuf[0] = (mins >> 16) & 0xFF;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_alarm_regs); i++) {\r\nretval = abx500_set_register_interruptible(dev, AB8500_RTC,\r\nab8500_rtc_alarm_regs[i], buf[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn ab8500_rtc_irq_enable(dev, alarm->enabled);\r\n}\r\nstatic irqreturn_t rtc_alarm_handler(int irq, void *data)\r\n{\r\nstruct rtc_device *rtc = data;\r\nunsigned long events = RTC_IRQF | RTC_AF;\r\ndev_dbg(&rtc->dev, "%s\n", __func__);\r\nrtc_update_irq(rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit ab8500_rtc_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct rtc_device *rtc;\r\nu8 rtc_ctrl;\r\nint irq;\r\nirq = platform_get_irq_byname(pdev, "ALARM");\r\nif (irq < 0)\r\nreturn irq;\r\nerr = abx500_mask_and_set_register_interruptible(&pdev->dev, AB8500_RTC,\r\nAB8500_RTC_STAT_REG, RTC_STATUS_DATA, RTC_STATUS_DATA);\r\nif (err < 0)\r\nreturn err;\r\nmsleep(1);\r\nerr = abx500_get_register_interruptible(&pdev->dev, AB8500_RTC,\r\nAB8500_RTC_STAT_REG, &rtc_ctrl);\r\nif (err < 0)\r\nreturn err;\r\nif (!(rtc_ctrl & RTC_STATUS_DATA)) {\r\ndev_err(&pdev->dev, "RTC supply failure\n");\r\nreturn -ENODEV;\r\n}\r\nrtc = rtc_device_register("ab8500-rtc", &pdev->dev, &ab8500_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc)) {\r\ndev_err(&pdev->dev, "Registration failed\n");\r\nerr = PTR_ERR(rtc);\r\nreturn err;\r\n}\r\nerr = request_threaded_irq(irq, NULL, rtc_alarm_handler, 0,\r\n"ab8500-rtc", rtc);\r\nif (err < 0) {\r\nrtc_device_unregister(rtc);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nreturn 0;\r\n}\r\nstatic int __devexit ab8500_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtc = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq_byname(pdev, "ALARM");\r\nfree_irq(irq, rtc);\r\nrtc_device_unregister(rtc);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init ab8500_rtc_init(void)\r\n{\r\nreturn platform_driver_register(&ab8500_rtc_driver);\r\n}\r\nstatic void __exit ab8500_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&ab8500_rtc_driver);\r\n}
