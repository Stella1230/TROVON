static inline char *link_typetostr(int type)\r\n{\r\nswitch (type) {\r\ncase ACL_LINK:\r\nreturn "ACL";\r\ncase SCO_LINK:\r\nreturn "SCO";\r\ncase ESCO_LINK:\r\nreturn "eSCO";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic ssize_t show_link_type(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_conn *conn = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", link_typetostr(conn->type));\r\n}\r\nstatic ssize_t show_link_address(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_conn *conn = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", batostr(&conn->dst));\r\n}\r\nstatic ssize_t show_link_features(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_conn *conn = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\nconn->features[0], conn->features[1],\r\nconn->features[2], conn->features[3],\r\nconn->features[4], conn->features[5],\r\nconn->features[6], conn->features[7]);\r\n}\r\nstatic void bt_link_release(struct device *dev)\r\n{\r\nvoid *data = dev_get_drvdata(dev);\r\nkfree(data);\r\n}\r\nstatic void add_conn(struct work_struct *work)\r\n{\r\nstruct hci_conn *conn = container_of(work, struct hci_conn, work_add);\r\nstruct hci_dev *hdev = conn->hdev;\r\ndev_set_name(&conn->dev, "%s:%d", hdev->name, conn->handle);\r\ndev_set_drvdata(&conn->dev, conn);\r\nif (device_add(&conn->dev) < 0) {\r\nBT_ERR("Failed to register connection device");\r\nreturn;\r\n}\r\nhci_dev_hold(hdev);\r\n}\r\nstatic int __match_tty(struct device *dev, void *data)\r\n{\r\nreturn !strncmp(dev_name(dev), "rfcomm", 6);\r\n}\r\nstatic void del_conn(struct work_struct *work)\r\n{\r\nstruct hci_conn *conn = container_of(work, struct hci_conn, work_del);\r\nstruct hci_dev *hdev = conn->hdev;\r\nif (!device_is_registered(&conn->dev))\r\nreturn;\r\nwhile (1) {\r\nstruct device *dev;\r\ndev = device_find_child(&conn->dev, NULL, __match_tty);\r\nif (!dev)\r\nbreak;\r\ndevice_move(dev, NULL, DPM_ORDER_DEV_LAST);\r\nput_device(dev);\r\n}\r\ndevice_del(&conn->dev);\r\nput_device(&conn->dev);\r\nhci_dev_put(hdev);\r\n}\r\nvoid hci_conn_init_sysfs(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("conn %p", conn);\r\nconn->dev.type = &bt_link;\r\nconn->dev.class = bt_class;\r\nconn->dev.parent = &hdev->dev;\r\ndevice_initialize(&conn->dev);\r\nINIT_WORK(&conn->work_add, add_conn);\r\nINIT_WORK(&conn->work_del, del_conn);\r\n}\r\nvoid hci_conn_add_sysfs(struct hci_conn *conn)\r\n{\r\nBT_DBG("conn %p", conn);\r\nqueue_work(conn->hdev->workqueue, &conn->work_add);\r\n}\r\nvoid hci_conn_del_sysfs(struct hci_conn *conn)\r\n{\r\nBT_DBG("conn %p", conn);\r\nqueue_work(conn->hdev->workqueue, &conn->work_del);\r\n}\r\nstatic inline char *host_bustostr(int bus)\r\n{\r\nswitch (bus) {\r\ncase HCI_VIRTUAL:\r\nreturn "VIRTUAL";\r\ncase HCI_USB:\r\nreturn "USB";\r\ncase HCI_PCCARD:\r\nreturn "PCCARD";\r\ncase HCI_UART:\r\nreturn "UART";\r\ncase HCI_RS232:\r\nreturn "RS232";\r\ncase HCI_PCI:\r\nreturn "PCI";\r\ncase HCI_SDIO:\r\nreturn "SDIO";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic inline char *host_typetostr(int type)\r\n{\r\nswitch (type) {\r\ncase HCI_BREDR:\r\nreturn "BR/EDR";\r\ncase HCI_AMP:\r\nreturn "AMP";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic ssize_t show_bus(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", host_bustostr(hdev->bus));\r\n}\r\nstatic ssize_t show_type(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", host_typetostr(hdev->dev_type));\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nchar name[HCI_MAX_NAME_LENGTH + 1];\r\nint i;\r\nfor (i = 0; i < HCI_MAX_NAME_LENGTH; i++)\r\nname[i] = hdev->dev_name[i];\r\nname[HCI_MAX_NAME_LENGTH] = '\0';\r\nreturn sprintf(buf, "%s\n", name);\r\n}\r\nstatic ssize_t show_class(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "0x%.2x%.2x%.2x\n",\r\nhdev->dev_class[2], hdev->dev_class[1], hdev->dev_class[0]);\r\n}\r\nstatic ssize_t show_address(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", batostr(&hdev->bdaddr));\r\n}\r\nstatic ssize_t show_features(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\nhdev->features[0], hdev->features[1],\r\nhdev->features[2], hdev->features[3],\r\nhdev->features[4], hdev->features[5],\r\nhdev->features[6], hdev->features[7]);\r\n}\r\nstatic ssize_t show_manufacturer(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", hdev->manufacturer);\r\n}\r\nstatic ssize_t show_hci_version(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", hdev->hci_ver);\r\n}\r\nstatic ssize_t show_hci_revision(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", hdev->hci_rev);\r\n}\r\nstatic ssize_t show_idle_timeout(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", hdev->idle_timeout);\r\n}\r\nstatic ssize_t store_idle_timeout(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nunsigned int val;\r\nint rv;\r\nrv = kstrtouint(buf, 0, &val);\r\nif (rv < 0)\r\nreturn rv;\r\nif (val != 0 && (val < 500 || val > 3600000))\r\nreturn -EINVAL;\r\nhdev->idle_timeout = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_sniff_max_interval(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", hdev->sniff_max_interval);\r\n}\r\nstatic ssize_t store_sniff_max_interval(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nu16 val;\r\nint rv;\r\nrv = kstrtou16(buf, 0, &val);\r\nif (rv < 0)\r\nreturn rv;\r\nif (val == 0 || val % 2 || val < hdev->sniff_min_interval)\r\nreturn -EINVAL;\r\nhdev->sniff_max_interval = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_sniff_min_interval(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", hdev->sniff_min_interval);\r\n}\r\nstatic ssize_t store_sniff_min_interval(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hci_dev *hdev = dev_get_drvdata(dev);\r\nu16 val;\r\nint rv;\r\nrv = kstrtou16(buf, 0, &val);\r\nif (rv < 0)\r\nreturn rv;\r\nif (val == 0 || val % 2 || val > hdev->sniff_max_interval)\r\nreturn -EINVAL;\r\nhdev->sniff_min_interval = val;\r\nreturn count;\r\n}\r\nstatic void bt_host_release(struct device *dev)\r\n{\r\nvoid *data = dev_get_drvdata(dev);\r\nkfree(data);\r\n}\r\nstatic int inquiry_cache_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct inquiry_cache *cache = &hdev->inq_cache;\r\nstruct inquiry_entry *e;\r\nhci_dev_lock_bh(hdev);\r\nfor (e = cache->list; e; e = e->next) {\r\nstruct inquiry_data *data = &e->data;\r\nseq_printf(f, "%s %d %d %d 0x%.2x%.2x%.2x 0x%.4x %d %d %u\n",\r\nbatostr(&data->bdaddr),\r\ndata->pscan_rep_mode, data->pscan_period_mode,\r\ndata->pscan_mode, data->dev_class[2],\r\ndata->dev_class[1], data->dev_class[0],\r\n__le16_to_cpu(data->clock_offset),\r\ndata->rssi, data->ssp_mode, e->timestamp);\r\n}\r\nhci_dev_unlock_bh(hdev);\r\nreturn 0;\r\n}\r\nstatic int inquiry_cache_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, inquiry_cache_show, inode->i_private);\r\n}\r\nstatic int blacklist_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct list_head *l;\r\nhci_dev_lock_bh(hdev);\r\nlist_for_each(l, &hdev->blacklist) {\r\nstruct bdaddr_list *b;\r\nb = list_entry(l, struct bdaddr_list, list);\r\nseq_printf(f, "%s\n", batostr(&b->bdaddr));\r\n}\r\nhci_dev_unlock_bh(hdev);\r\nreturn 0;\r\n}\r\nstatic int blacklist_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, blacklist_show, inode->i_private);\r\n}\r\nstatic void print_bt_uuid(struct seq_file *f, u8 *uuid)\r\n{\r\nu32 data0, data4;\r\nu16 data1, data2, data3, data5;\r\nmemcpy(&data0, &uuid[0], 4);\r\nmemcpy(&data1, &uuid[4], 2);\r\nmemcpy(&data2, &uuid[6], 2);\r\nmemcpy(&data3, &uuid[8], 2);\r\nmemcpy(&data4, &uuid[10], 4);\r\nmemcpy(&data5, &uuid[14], 2);\r\nseq_printf(f, "%.8x-%.4x-%.4x-%.4x-%.8x%.4x\n",\r\nntohl(data0), ntohs(data1), ntohs(data2),\r\nntohs(data3), ntohl(data4), ntohs(data5));\r\n}\r\nstatic int uuids_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct list_head *l;\r\nhci_dev_lock_bh(hdev);\r\nlist_for_each(l, &hdev->uuids) {\r\nstruct bt_uuid *uuid;\r\nuuid = list_entry(l, struct bt_uuid, list);\r\nprint_bt_uuid(f, uuid->uuid);\r\n}\r\nhci_dev_unlock_bh(hdev);\r\nreturn 0;\r\n}\r\nstatic int uuids_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, uuids_show, inode->i_private);\r\n}\r\nstatic int auto_accept_delay_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock_bh(hdev);\r\nhdev->auto_accept_delay = val;\r\nhci_dev_unlock_bh(hdev);\r\nreturn 0;\r\n}\r\nstatic int auto_accept_delay_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock_bh(hdev);\r\n*val = hdev->auto_accept_delay;\r\nhci_dev_unlock_bh(hdev);\r\nreturn 0;\r\n}\r\nint hci_register_sysfs(struct hci_dev *hdev)\r\n{\r\nstruct device *dev = &hdev->dev;\r\nint err;\r\nBT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);\r\ndev->type = &bt_host;\r\ndev->class = bt_class;\r\ndev->parent = hdev->parent;\r\ndev_set_name(dev, "%s", hdev->name);\r\ndev_set_drvdata(dev, hdev);\r\nerr = device_register(dev);\r\nif (err < 0)\r\nreturn err;\r\nif (!bt_debugfs)\r\nreturn 0;\r\nhdev->debugfs = debugfs_create_dir(hdev->name, bt_debugfs);\r\nif (!hdev->debugfs)\r\nreturn 0;\r\ndebugfs_create_file("inquiry_cache", 0444, hdev->debugfs,\r\nhdev, &inquiry_cache_fops);\r\ndebugfs_create_file("blacklist", 0444, hdev->debugfs,\r\nhdev, &blacklist_fops);\r\ndebugfs_create_file("uuids", 0444, hdev->debugfs, hdev, &uuids_fops);\r\ndebugfs_create_file("auto_accept_delay", 0444, hdev->debugfs, hdev,\r\n&auto_accept_delay_fops);\r\nreturn 0;\r\n}\r\nvoid hci_unregister_sysfs(struct hci_dev *hdev)\r\n{\r\nBT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);\r\ndebugfs_remove_recursive(hdev->debugfs);\r\ndevice_del(&hdev->dev);\r\n}\r\nint __init bt_sysfs_init(void)\r\n{\r\nbt_debugfs = debugfs_create_dir("bluetooth", NULL);\r\nbt_class = class_create(THIS_MODULE, "bluetooth");\r\nif (IS_ERR(bt_class))\r\nreturn PTR_ERR(bt_class);\r\nreturn 0;\r\n}\r\nvoid bt_sysfs_cleanup(void)\r\n{\r\nclass_destroy(bt_class);\r\ndebugfs_remove_recursive(bt_debugfs);\r\n}
