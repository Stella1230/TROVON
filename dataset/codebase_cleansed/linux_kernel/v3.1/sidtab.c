int sidtab_init(struct sidtab *s)\r\n{\r\nint i;\r\ns->htable = kmalloc(sizeof(*(s->htable)) * SIDTAB_SIZE, GFP_ATOMIC);\r\nif (!s->htable)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < SIDTAB_SIZE; i++)\r\ns->htable[i] = NULL;\r\ns->nel = 0;\r\ns->next_sid = 1;\r\ns->shutdown = 0;\r\nspin_lock_init(&s->lock);\r\nreturn 0;\r\n}\r\nint sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\r\n{\r\nint hvalue, rc = 0;\r\nstruct sidtab_node *prev, *cur, *newnode;\r\nif (!s) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nhvalue = SIDTAB_HASH(sid);\r\nprev = NULL;\r\ncur = s->htable[hvalue];\r\nwhile (cur && sid > cur->sid) {\r\nprev = cur;\r\ncur = cur->next;\r\n}\r\nif (cur && sid == cur->sid) {\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\nnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\r\nif (newnode == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nnewnode->sid = sid;\r\nif (context_cpy(&newnode->context, context)) {\r\nkfree(newnode);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (prev) {\r\nnewnode->next = prev->next;\r\nwmb();\r\nprev->next = newnode;\r\n} else {\r\nnewnode->next = s->htable[hvalue];\r\nwmb();\r\ns->htable[hvalue] = newnode;\r\n}\r\ns->nel++;\r\nif (sid >= s->next_sid)\r\ns->next_sid = sid + 1;\r\nout:\r\nreturn rc;\r\n}\r\nstatic struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)\r\n{\r\nint hvalue;\r\nstruct sidtab_node *cur;\r\nif (!s)\r\nreturn NULL;\r\nhvalue = SIDTAB_HASH(sid);\r\ncur = s->htable[hvalue];\r\nwhile (cur && sid > cur->sid)\r\ncur = cur->next;\r\nif (force && cur && sid == cur->sid && cur->context.len)\r\nreturn &cur->context;\r\nif (cur == NULL || sid != cur->sid || cur->context.len) {\r\nsid = SECINITSID_UNLABELED;\r\nhvalue = SIDTAB_HASH(sid);\r\ncur = s->htable[hvalue];\r\nwhile (cur && sid > cur->sid)\r\ncur = cur->next;\r\nif (!cur || sid != cur->sid)\r\nreturn NULL;\r\n}\r\nreturn &cur->context;\r\n}\r\nstruct context *sidtab_search(struct sidtab *s, u32 sid)\r\n{\r\nreturn sidtab_search_core(s, sid, 0);\r\n}\r\nstruct context *sidtab_search_force(struct sidtab *s, u32 sid)\r\n{\r\nreturn sidtab_search_core(s, sid, 1);\r\n}\r\nint sidtab_map(struct sidtab *s,\r\nint (*apply) (u32 sid,\r\nstruct context *context,\r\nvoid *args),\r\nvoid *args)\r\n{\r\nint i, rc = 0;\r\nstruct sidtab_node *cur;\r\nif (!s)\r\ngoto out;\r\nfor (i = 0; i < SIDTAB_SIZE; i++) {\r\ncur = s->htable[i];\r\nwhile (cur) {\r\nrc = apply(cur->sid, &cur->context, args);\r\nif (rc)\r\ngoto out;\r\ncur = cur->next;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)\r\n{\r\nBUG_ON(loc >= SIDTAB_CACHE_LEN);\r\nwhile (loc > 0) {\r\ns->cache[loc] = s->cache[loc - 1];\r\nloc--;\r\n}\r\ns->cache[0] = n;\r\n}\r\nstatic inline u32 sidtab_search_context(struct sidtab *s,\r\nstruct context *context)\r\n{\r\nint i;\r\nstruct sidtab_node *cur;\r\nfor (i = 0; i < SIDTAB_SIZE; i++) {\r\ncur = s->htable[i];\r\nwhile (cur) {\r\nif (context_cmp(&cur->context, context)) {\r\nsidtab_update_cache(s, cur, SIDTAB_CACHE_LEN - 1);\r\nreturn cur->sid;\r\n}\r\ncur = cur->next;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\r\n{\r\nint i;\r\nstruct sidtab_node *node;\r\nfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\r\nnode = s->cache[i];\r\nif (unlikely(!node))\r\nreturn 0;\r\nif (context_cmp(&node->context, context)) {\r\nsidtab_update_cache(s, node, i);\r\nreturn node->sid;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint sidtab_context_to_sid(struct sidtab *s,\r\nstruct context *context,\r\nu32 *out_sid)\r\n{\r\nu32 sid;\r\nint ret = 0;\r\nunsigned long flags;\r\n*out_sid = SECSID_NULL;\r\nsid = sidtab_search_cache(s, context);\r\nif (!sid)\r\nsid = sidtab_search_context(s, context);\r\nif (!sid) {\r\nspin_lock_irqsave(&s->lock, flags);\r\nsid = sidtab_search_context(s, context);\r\nif (sid)\r\ngoto unlock_out;\r\nif (s->next_sid == UINT_MAX || s->shutdown) {\r\nret = -ENOMEM;\r\ngoto unlock_out;\r\n}\r\nsid = s->next_sid++;\r\nif (context->len)\r\nprintk(KERN_INFO\r\n"SELinux: Context %s is not valid (left unmapped).\n",\r\ncontext->str);\r\nret = sidtab_insert(s, sid, context);\r\nif (ret)\r\ns->next_sid--;\r\nunlock_out:\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nif (ret)\r\nreturn ret;\r\n*out_sid = sid;\r\nreturn 0;\r\n}\r\nvoid sidtab_hash_eval(struct sidtab *h, char *tag)\r\n{\r\nint i, chain_len, slots_used, max_chain_len;\r\nstruct sidtab_node *cur;\r\nslots_used = 0;\r\nmax_chain_len = 0;\r\nfor (i = 0; i < SIDTAB_SIZE; i++) {\r\ncur = h->htable[i];\r\nif (cur) {\r\nslots_used++;\r\nchain_len = 0;\r\nwhile (cur) {\r\nchain_len++;\r\ncur = cur->next;\r\n}\r\nif (chain_len > max_chain_len)\r\nmax_chain_len = chain_len;\r\n}\r\n}\r\nprintk(KERN_DEBUG "%s: %d entries and %d/%d buckets used, longest "\r\n"chain length %d\n", tag, h->nel, slots_used, SIDTAB_SIZE,\r\nmax_chain_len);\r\n}\r\nvoid sidtab_destroy(struct sidtab *s)\r\n{\r\nint i;\r\nstruct sidtab_node *cur, *temp;\r\nif (!s)\r\nreturn;\r\nfor (i = 0; i < SIDTAB_SIZE; i++) {\r\ncur = s->htable[i];\r\nwhile (cur) {\r\ntemp = cur;\r\ncur = cur->next;\r\ncontext_destroy(&temp->context);\r\nkfree(temp);\r\n}\r\ns->htable[i] = NULL;\r\n}\r\nkfree(s->htable);\r\ns->htable = NULL;\r\ns->nel = 0;\r\ns->next_sid = 1;\r\n}\r\nvoid sidtab_set(struct sidtab *dst, struct sidtab *src)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&src->lock, flags);\r\ndst->htable = src->htable;\r\ndst->nel = src->nel;\r\ndst->next_sid = src->next_sid;\r\ndst->shutdown = 0;\r\nfor (i = 0; i < SIDTAB_CACHE_LEN; i++)\r\ndst->cache[i] = NULL;\r\nspin_unlock_irqrestore(&src->lock, flags);\r\n}\r\nvoid sidtab_shutdown(struct sidtab *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\ns->shutdown = 1;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}
