static inline unsigned int serial_in(struct uart_hsu_port *up, int offset)\r\n{\r\nunsigned int val;\r\nif (offset > UART_MSR) {\r\noffset <<= 2;\r\nval = readl(up->port.membase + offset);\r\n} else\r\nval = (unsigned int)readb(up->port.membase + offset);\r\nreturn val;\r\n}\r\nstatic inline void serial_out(struct uart_hsu_port *up, int offset, int value)\r\n{\r\nif (offset > UART_MSR) {\r\noffset <<= 2;\r\nwritel(value, up->port.membase + offset);\r\n} else {\r\nunsigned char val = value & 0xff;\r\nwriteb(val, up->port.membase + offset);\r\n}\r\n}\r\nstatic int hsu_show_regs_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t port_show_regs(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uart_hsu_port *up = file->private_data;\r\nchar *buf;\r\nu32 len = 0;\r\nssize_t ret;\r\nbuf = kzalloc(HSU_REGS_BUFSIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"MFD HSU port[%d] regs:\n", up->index);\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"=================================\n");\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"IER: \t\t0x%08x\n", serial_in(up, UART_IER));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"IIR: \t\t0x%08x\n", serial_in(up, UART_IIR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"LCR: \t\t0x%08x\n", serial_in(up, UART_LCR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"MCR: \t\t0x%08x\n", serial_in(up, UART_MCR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"LSR: \t\t0x%08x\n", serial_in(up, UART_LSR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"MSR: \t\t0x%08x\n", serial_in(up, UART_MSR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"FOR: \t\t0x%08x\n", serial_in(up, UART_FOR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"PS: \t\t0x%08x\n", serial_in(up, UART_PS));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"MUL: \t\t0x%08x\n", serial_in(up, UART_MUL));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"DIV: \t\t0x%08x\n", serial_in(up, UART_DIV));\r\nif (len > HSU_REGS_BUFSIZE)\r\nlen = HSU_REGS_BUFSIZE;\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t dma_show_regs(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hsu_dma_chan *chan = file->private_data;\r\nchar *buf;\r\nu32 len = 0;\r\nssize_t ret;\r\nbuf = kzalloc(HSU_REGS_BUFSIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"MFD HSU DMA channel [%d] regs:\n", chan->id);\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"=================================\n");\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"CR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_CR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"DCR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_DCR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"BSR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_BSR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"MOTSR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_MOTSR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"D0SAR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_D0SAR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"D0TSR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_D0TSR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"D0SAR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_D1SAR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"D0TSR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_D1TSR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"D0SAR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_D2SAR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"D0TSR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_D2TSR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"D0SAR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_D3SAR));\r\nlen += snprintf(buf + len, HSU_REGS_BUFSIZE - len,\r\n"D0TSR: \t\t0x%08x\n", chan_readl(chan, HSU_CH_D3TSR));\r\nif (len > HSU_REGS_BUFSIZE)\r\nlen = HSU_REGS_BUFSIZE;\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int hsu_debugfs_init(struct hsu_port *hsu)\r\n{\r\nint i;\r\nchar name[32];\r\nhsu->debugfs = debugfs_create_dir("hsu", NULL);\r\nif (!hsu->debugfs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 3; i++) {\r\nsnprintf(name, sizeof(name), "port_%d_regs", i);\r\ndebugfs_create_file(name, S_IFREG | S_IRUGO,\r\nhsu->debugfs, (void *)(&hsu->port[i]), &port_regs_ops);\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nsnprintf(name, sizeof(name), "dma_chan_%d_regs", i);\r\ndebugfs_create_file(name, S_IFREG | S_IRUGO,\r\nhsu->debugfs, (void *)&hsu->chans[i], &dma_regs_ops);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hsu_debugfs_remove(struct hsu_port *hsu)\r\n{\r\nif (hsu->debugfs)\r\ndebugfs_remove_recursive(hsu->debugfs);\r\n}\r\nstatic inline int hsu_debugfs_init(struct hsu_port *hsu)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void hsu_debugfs_remove(struct hsu_port *hsu)\r\n{\r\n}\r\nstatic void serial_hsu_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nvoid hsu_dma_tx(struct uart_hsu_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nstruct hsu_dma_buffer *dbuf = &up->txbuf;\r\nint count;\r\nif (up->dma_tx_on)\r\nreturn;\r\nxmit->tail += dbuf->ofs;\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\nup->port.icount.tx += dbuf->ofs;\r\ndbuf->ofs = 0;\r\nchan_writel(up->txc, HSU_CH_CR, 0x0);\r\nif (!uart_circ_empty(xmit) && !uart_tx_stopped(&up->port)) {\r\ndma_sync_single_for_device(up->port.dev,\r\ndbuf->dma_addr,\r\ndbuf->dma_size,\r\nDMA_TO_DEVICE);\r\ncount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\ndbuf->ofs = count;\r\nchan_writel(up->txc, HSU_CH_D0SAR, dbuf->dma_addr + xmit->tail);\r\nchan_writel(up->txc, HSU_CH_D0TSR, count);\r\nchan_writel(up->txc, HSU_CH_DCR, 0x1\r\n| (0x1 << 8)\r\n| (0x1 << 16)\r\n| (0x1 << 24));\r\nup->dma_tx_on = 1;\r\nchan_writel(up->txc, HSU_CH_CR, 0x1);\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\n}\r\nvoid hsu_dma_start_rx_chan(struct hsu_dma_chan *rxc, struct hsu_dma_buffer *dbuf)\r\n{\r\ndbuf->ofs = 0;\r\nchan_writel(rxc, HSU_CH_BSR, 32);\r\nchan_writel(rxc, HSU_CH_MOTSR, 4);\r\nchan_writel(rxc, HSU_CH_D0SAR, dbuf->dma_addr);\r\nchan_writel(rxc, HSU_CH_D0TSR, dbuf->dma_size);\r\nchan_writel(rxc, HSU_CH_DCR, 0x1 | (0x1 << 8)\r\n| (0x1 << 16)\r\n| (0x1 << 24)\r\n);\r\nchan_writel(rxc, HSU_CH_CR, 0x3);\r\n}\r\nstatic void serial_hsu_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nif (up->use_dma) {\r\nhsu_dma_tx(up);\r\n} else if (!(up->ier & UART_IER_THRI)) {\r\nup->ier |= UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n}\r\nstatic void serial_hsu_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nstruct hsu_dma_chan *txc = up->txc;\r\nif (up->use_dma)\r\nchan_writel(txc, HSU_CH_CR, 0x0);\r\nelse if (up->ier & UART_IER_THRI) {\r\nup->ier &= ~UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n}\r\nvoid hsu_dma_rx(struct uart_hsu_port *up, u32 int_sts)\r\n{\r\nstruct hsu_dma_buffer *dbuf = &up->rxbuf;\r\nstruct hsu_dma_chan *chan = up->rxc;\r\nstruct uart_port *port = &up->port;\r\nstruct tty_struct *tty = port->state->port.tty;\r\nint count;\r\nif (!tty)\r\nreturn;\r\nif (int_sts & 0xf00)\r\nudelay(2);\r\nchan_writel(chan, HSU_CH_CR, 0x0);\r\ncount = chan_readl(chan, HSU_CH_D0SAR) - dbuf->dma_addr;\r\nif (!count) {\r\nchan_writel(chan, HSU_CH_CR, 0x3);\r\nreturn;\r\n}\r\ndma_sync_single_for_cpu(port->dev, dbuf->dma_addr,\r\ndbuf->dma_size, DMA_FROM_DEVICE);\r\ntty_insert_flip_string(tty, dbuf->buf, count);\r\nport->icount.rx += count;\r\ndma_sync_single_for_device(up->port.dev, dbuf->dma_addr,\r\ndbuf->dma_size, DMA_FROM_DEVICE);\r\nchan_writel(chan, HSU_CH_D0SAR, dbuf->dma_addr);\r\nchan_writel(chan, HSU_CH_D0TSR, dbuf->dma_size);\r\nchan_writel(chan, HSU_CH_DCR, 0x1\r\n| (0x1 << 8)\r\n| (0x1 << 16)\r\n| (0x1 << 24)\r\n);\r\ntty_flip_buffer_push(tty);\r\nchan_writel(chan, HSU_CH_CR, 0x3);\r\n}\r\nstatic void serial_hsu_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nstruct hsu_dma_chan *chan = up->rxc;\r\nif (up->use_dma)\r\nchan_writel(chan, HSU_CH_CR, 0x2);\r\nelse {\r\nup->ier &= ~UART_IER_RLSI;\r\nup->port.read_status_mask &= ~UART_LSR_DR;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n}\r\nstatic inline void receive_chars(struct uart_hsu_port *up, int *status)\r\n{\r\nstruct tty_struct *tty = up->port.state->port.tty;\r\nunsigned int ch, flag;\r\nunsigned int max_count = 256;\r\nif (!tty)\r\nreturn;\r\ndo {\r\nch = serial_in(up, UART_RX);\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nif (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |\r\nUART_LSR_FE | UART_LSR_OE))) {\r\ndev_warn(up->dev, "We really rush into ERR/BI case"\r\n"status = 0x%02x", *status);\r\nif (*status & UART_LSR_BI) {\r\n*status &= ~(UART_LSR_FE | UART_LSR_PE);\r\nup->port.icount.brk++;\r\nif (uart_handle_break(&up->port))\r\ngoto ignore_char;\r\n} else if (*status & UART_LSR_PE)\r\nup->port.icount.parity++;\r\nelse if (*status & UART_LSR_FE)\r\nup->port.icount.frame++;\r\nif (*status & UART_LSR_OE)\r\nup->port.icount.overrun++;\r\n*status &= up->port.read_status_mask;\r\n#ifdef CONFIG_SERIAL_MFD_HSU_CONSOLE\r\nif (up->port.cons &&\r\nup->port.cons->index == up->port.line) {\r\n*status |= up->lsr_break_flag;\r\nup->lsr_break_flag = 0;\r\n}\r\n#endif\r\nif (*status & UART_LSR_BI) {\r\nflag = TTY_BREAK;\r\n} else if (*status & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (*status & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&up->port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(&up->port, *status, UART_LSR_OE, ch, flag);\r\nignore_char:\r\n*status = serial_in(up, UART_LSR);\r\n} while ((*status & UART_LSR_DR) && max_count--);\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic void transmit_chars(struct uart_hsu_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint count;\r\nif (up->port.x_char) {\r\nserial_out(up, UART_TX, up->port.x_char);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\r\nserial_hsu_stop_tx(&up->port);\r\nreturn;\r\n}\r\ncount = up->port.fifosize / 2;\r\ndo {\r\nserial_out(up, UART_TX, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (uart_circ_empty(xmit))\r\nserial_hsu_stop_tx(&up->port);\r\n}\r\nstatic inline void check_modem_status(struct uart_hsu_port *up)\r\n{\r\nint status;\r\nstatus = serial_in(up, UART_MSR);\r\nif ((status & UART_MSR_ANY_DELTA) == 0)\r\nreturn;\r\nif (status & UART_MSR_TERI)\r\nup->port.icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nup->port.icount.dsr++;\r\nif (status & UART_MSR_DDCD)\r\nuart_handle_dcd_change(&up->port, status & UART_MSR_DCD);\r\nif (status & UART_MSR_DCTS)\r\nuart_handle_cts_change(&up->port, status & UART_MSR_CTS);\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t port_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_hsu_port *up = dev_id;\r\nunsigned int iir, lsr;\r\nunsigned long flags;\r\nif (unlikely(!up->running))\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (up->use_dma) {\r\nlsr = serial_in(up, UART_LSR);\r\nif (unlikely(lsr & (UART_LSR_BI | UART_LSR_PE |\r\nUART_LSR_FE | UART_LSR_OE)))\r\ndev_warn(up->dev,\r\n"Got lsr irq while using DMA, lsr = 0x%2x\n",\r\nlsr);\r\ncheck_modem_status(up);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\niir = serial_in(up, UART_IIR);\r\nif (iir & UART_IIR_NO_INT) {\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nlsr = serial_in(up, UART_LSR);\r\nif (lsr & UART_LSR_DR)\r\nreceive_chars(up, &lsr);\r\ncheck_modem_status(up);\r\nif (lsr & UART_LSR_THRE)\r\ntransmit_chars(up);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void dma_chan_irq(struct hsu_dma_chan *chan)\r\n{\r\nstruct uart_hsu_port *up = chan->uport;\r\nunsigned long flags;\r\nu32 int_sts;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (!up->use_dma || !up->running)\r\ngoto exit;\r\nint_sts = chan_readl(chan, HSU_CH_SR);\r\nif (chan->dirt == DMA_FROM_DEVICE)\r\nhsu_dma_rx(up, int_sts);\r\nif (chan->dirt == DMA_TO_DEVICE) {\r\nchan_writel(chan, HSU_CH_CR, 0x0);\r\nup->dma_tx_on = 0;\r\nhsu_dma_tx(up);\r\n}\r\nexit:\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn;\r\n}\r\nstatic irqreturn_t dma_irq(int irq, void *dev_id)\r\n{\r\nstruct hsu_port *hsu = dev_id;\r\nu32 int_sts, i;\r\nint_sts = mfd_readl(hsu, HSU_GBL_DMAISR);\r\nfor (i = 0; i < 6; i++) {\r\nif (int_sts & 0x1)\r\ndma_chan_irq(&hsu->chans[i]);\r\nint_sts >>= 1;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int serial_hsu_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nunsigned long flags;\r\nunsigned int ret;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int serial_hsu_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nunsigned char status;\r\nunsigned int ret;\r\nstatus = serial_in(up, UART_MSR);\r\nret = 0;\r\nif (status & UART_MSR_DCD)\r\nret |= TIOCM_CAR;\r\nif (status & UART_MSR_RI)\r\nret |= TIOCM_RNG;\r\nif (status & UART_MSR_DSR)\r\nret |= TIOCM_DSR;\r\nif (status & UART_MSR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void serial_hsu_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nunsigned char mcr = 0;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nmcr |= up->mcr;\r\nserial_out(up, UART_MCR, mcr);\r\n}\r\nstatic void serial_hsu_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (break_state == -1)\r\nup->lcr |= UART_LCR_SBC;\r\nelse\r\nup->lcr &= ~UART_LCR_SBC;\r\nserial_out(up, UART_LCR, up->lcr);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int serial_hsu_startup(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nunsigned long flags;\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nserial_out(up, UART_FCR, 0);\r\n(void) serial_in(up, UART_LSR);\r\n(void) serial_in(up, UART_RX);\r\n(void) serial_in(up, UART_IIR);\r\n(void) serial_in(up, UART_MSR);\r\nserial_out(up, UART_LCR, UART_LCR_WLEN8);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl |= TIOCM_OUT2;\r\nserial_hsu_set_mctrl(&up->port, up->port.mctrl);\r\nif (!up->use_dma)\r\nup->ier = UART_IER_RLSI | UART_IER_RDI | UART_IER_RTOIE;\r\nelse\r\nup->ier = 0;\r\nserial_out(up, UART_IER, up->ier);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nif (up->use_dma) {\r\nstruct hsu_dma_buffer *dbuf;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nup->dma_tx_on = 0;\r\ndbuf = &up->rxbuf;\r\ndbuf->buf = kzalloc(HSU_DMA_BUF_SIZE, GFP_KERNEL);\r\nif (!dbuf->buf) {\r\nup->use_dma = 0;\r\ngoto exit;\r\n}\r\ndbuf->dma_addr = dma_map_single(port->dev,\r\ndbuf->buf,\r\nHSU_DMA_BUF_SIZE,\r\nDMA_FROM_DEVICE);\r\ndbuf->dma_size = HSU_DMA_BUF_SIZE;\r\nhsu_dma_start_rx_chan(up->rxc, dbuf);\r\ndbuf = &up->txbuf;\r\ndbuf->buf = xmit->buf;\r\ndbuf->dma_addr = dma_map_single(port->dev,\r\ndbuf->buf,\r\nUART_XMIT_SIZE,\r\nDMA_TO_DEVICE);\r\ndbuf->dma_size = UART_XMIT_SIZE;\r\nchan_writel(up->txc, HSU_CH_BSR, 32);\r\nchan_writel(up->txc, HSU_CH_MOTSR, 4);\r\ndbuf->ofs = 0;\r\n}\r\nexit:\r\n(void) serial_in(up, UART_LSR);\r\n(void) serial_in(up, UART_RX);\r\n(void) serial_in(up, UART_IIR);\r\n(void) serial_in(up, UART_MSR);\r\nup->running = 1;\r\nreturn 0;\r\n}\r\nstatic void serial_hsu_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nunsigned long flags;\r\nup->ier = 0;\r\nserial_out(up, UART_IER, 0);\r\nup->running = 0;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl &= ~TIOCM_OUT2;\r\nserial_hsu_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nserial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT);\r\nserial_out(up, UART_FCR, 0);\r\n}\r\nstatic void\r\nserial_hsu_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nstruct tty_struct *tty = port->state->port.tty;\r\nunsigned char cval, fcr = 0;\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nu32 ps, mul;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncval = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\ncval = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\ncval = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (tty)\r\ntty->termios->c_cflag &= ~CMSPAR;\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= UART_LCR_STOP;\r\nif (termios->c_cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(termios->c_cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 4000000);\r\nquot = 1;\r\nps = 0x10;\r\nmul = 0x3600;\r\nswitch (baud) {\r\ncase 3500000:\r\nmul = 0x3345;\r\nps = 0xC;\r\nbreak;\r\ncase 1843200:\r\nmul = 0x2400;\r\nbreak;\r\ncase 3000000:\r\ncase 2500000:\r\ncase 2000000:\r\ncase 1500000:\r\ncase 1000000:\r\ncase 500000:\r\nmul = baud / 500000 * 0x9C4;\r\nbreak;\r\ndefault:\r\nquot = 0;\r\n}\r\nif (!quot)\r\nquot = uart_get_divisor(port, baud);\r\nif ((up->port.uartclk / quot) < (2400 * 16))\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_HSU_64_1B;\r\nelse if ((up->port.uartclk / quot) < (230400 * 16))\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_HSU_64_16B;\r\nelse\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_HSU_64_32B;\r\nfcr |= UART_FCR_HSU_64B_FIFO;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (termios->c_iflag & INPCK)\r\nup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nup->port.read_status_mask |= UART_LSR_BI;\r\nup->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= UART_LSR_BI;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= UART_LSR_DR;\r\nup->ier &= ~UART_IER_MSI;\r\nif (UART_ENABLE_MS(&up->port, termios->c_cflag))\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\nif (termios->c_cflag & CRTSCTS)\r\nup->mcr |= UART_MCR_AFE | UART_MCR_RTS;\r\nelse\r\nup->mcr &= ~UART_MCR_AFE;\r\nserial_out(up, UART_LCR, cval | UART_LCR_DLAB);\r\nserial_out(up, UART_DLL, quot & 0xff);\r\nserial_out(up, UART_DLM, quot >> 8);\r\nserial_out(up, UART_LCR, cval);\r\nserial_out(up, UART_MUL, mul);\r\nserial_out(up, UART_PS, ps);\r\nup->lcr = cval;\r\nserial_hsu_set_mctrl(&up->port, up->port.mctrl);\r\nserial_out(up, UART_FCR, fcr);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void\r\nserial_hsu_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\n}\r\nstatic void serial_hsu_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int serial_hsu_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void serial_hsu_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nup->port.type = PORT_MFD;\r\n}\r\nstatic int\r\nserial_hsu_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic const char *\r\nserial_hsu_type(struct uart_port *port)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nreturn up->name;\r\n}\r\nstatic inline void wait_for_xmitr(struct uart_hsu_port *up)\r\n{\r\nunsigned int status, tmout = 1000;\r\ndo {\r\nstatus = serial_in(up, UART_LSR);\r\nif (status & UART_LSR_BI)\r\nup->lsr_break_flag = UART_LSR_BI;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while (!(status & BOTH_EMPTY));\r\nif (up->port.flags & UPF_CONS_FLOW) {\r\ntmout = 1000000;\r\nwhile (--tmout &&\r\n((serial_in(up, UART_MSR) & UART_MSR_CTS) == 0))\r\nudelay(1);\r\n}\r\n}\r\nstatic void serial_hsu_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_hsu_port *up =\r\ncontainer_of(port, struct uart_hsu_port, port);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_TX, ch);\r\n}\r\nstatic void\r\nserial_hsu_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_hsu_port *up = serial_hsu_ports[co->index];\r\nunsigned long flags;\r\nunsigned int ier;\r\nint locked = 1;\r\nlocal_irq_save(flags);\r\nif (up->port.sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress) {\r\nlocked = spin_trylock(&up->port.lock);\r\n} else\r\nspin_lock(&up->port.lock);\r\nier = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, 0);\r\nuart_console_write(&up->port, s, count, serial_hsu_console_putchar);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_IER, ier);\r\nif (locked)\r\nspin_unlock(&up->port.lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init\r\nserial_hsu_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_hsu_port *up;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (co->index == -1 || co->index >= serial_hsu_reg.nr)\r\nco->index = 0;\r\nup = serial_hsu_ports[co->index];\r\nif (!up)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nret = uart_set_options(&up->port, co, baud, parity, bits, flow);\r\nreturn ret;\r\n}\r\nstatic int serial_hsu_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nvoid *priv = pci_get_drvdata(pdev);\r\nstruct uart_hsu_port *up;\r\nif (priv && (pdev->device != 0x081E)) {\r\nup = priv;\r\nuart_suspend_port(&serial_hsu_reg, &up->port);\r\n}\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int serial_hsu_resume(struct pci_dev *pdev)\r\n{\r\nvoid *priv = pci_get_drvdata(pdev);\r\nstruct uart_hsu_port *up;\r\nint ret;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\ndev_warn(&pdev->dev,\r\n"HSU: can't re-enable device, try to continue\n");\r\nif (priv && (pdev->device != 0x081E)) {\r\nup = priv;\r\nuart_resume_port(&serial_hsu_reg, &up->port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial_hsu_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct uart_hsu_port *uport;\r\nint index, ret;\r\nprintk(KERN_INFO "HSU: found PCI Serial controller(ID: %04x:%04x)\n",\r\npdev->vendor, pdev->device);\r\nswitch (pdev->device) {\r\ncase 0x081B:\r\nindex = 0;\r\nbreak;\r\ncase 0x081C:\r\nindex = 1;\r\nbreak;\r\ncase 0x081D:\r\nindex = 2;\r\nbreak;\r\ncase 0x081E:\r\nindex = 3;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "HSU: out of index!");\r\nreturn -ENODEV;\r\n}\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nif (index == 3) {\r\nret = request_irq(pdev->irq, dma_irq, 0, "hsu_dma", phsu);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can not get IRQ\n");\r\ngoto err_disable;\r\n}\r\npci_set_drvdata(pdev, phsu);\r\n} else {\r\nuport = &phsu->port[index];\r\nuport->port.irq = pdev->irq;\r\nuport->port.dev = &pdev->dev;\r\nuport->dev = &pdev->dev;\r\nret = request_irq(pdev->irq, port_irq, 0, uport->name, uport);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can not get IRQ\n");\r\ngoto err_disable;\r\n}\r\nuart_add_one_port(&serial_hsu_reg, &uport->port);\r\n#ifdef CONFIG_SERIAL_MFD_HSU_CONSOLE\r\nif (index == 2) {\r\nregister_console(&serial_hsu_console);\r\nuport->port.cons = &serial_hsu_console;\r\n}\r\n#endif\r\npci_set_drvdata(pdev, uport);\r\n}\r\nreturn 0;\r\nerr_disable:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void hsu_global_init(void)\r\n{\r\nstruct hsu_port *hsu;\r\nstruct uart_hsu_port *uport;\r\nstruct hsu_dma_chan *dchan;\r\nint i, ret;\r\nhsu = kzalloc(sizeof(struct hsu_port), GFP_KERNEL);\r\nif (!hsu)\r\nreturn;\r\nhsu->paddr = 0xffa28000;\r\nhsu->iolen = 0x1000;\r\nif (!(request_mem_region(hsu->paddr, hsu->iolen, "HSU global")))\r\npr_warning("HSU: error in request mem region\n");\r\nhsu->reg = ioremap_nocache((unsigned long)hsu->paddr, hsu->iolen);\r\nif (!hsu->reg) {\r\npr_err("HSU: error in ioremap\n");\r\nret = -ENOMEM;\r\ngoto err_free_region;\r\n}\r\nuport = hsu->port;\r\nfor (i = 0; i < 3; i++) {\r\nuport->port.type = PORT_MFD;\r\nuport->port.iotype = UPIO_MEM;\r\nuport->port.mapbase = (resource_size_t)hsu->paddr\r\n+ HSU_PORT_REG_OFFSET\r\n+ i * HSU_PORT_REG_LENGTH;\r\nuport->port.membase = hsu->reg + HSU_PORT_REG_OFFSET\r\n+ i * HSU_PORT_REG_LENGTH;\r\nsprintf(uport->name, "hsu_port%d", i);\r\nuport->port.fifosize = 64;\r\nuport->port.ops = &serial_hsu_pops;\r\nuport->port.line = i;\r\nuport->port.flags = UPF_IOREMAP;\r\nuport->port.uartclk = 115200 * 24 * 16;\r\nuport->running = 0;\r\nuport->txc = &hsu->chans[i * 2];\r\nuport->rxc = &hsu->chans[i * 2 + 1];\r\nserial_hsu_ports[i] = uport;\r\nuport->index = i;\r\nif (hsu_dma_enable & (1<<i))\r\nuport->use_dma = 1;\r\nelse\r\nuport->use_dma = 0;\r\nuport++;\r\n}\r\ndchan = hsu->chans;\r\nfor (i = 0; i < 6; i++) {\r\ndchan->id = i;\r\ndchan->dirt = (i & 0x1) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\ndchan->uport = &hsu->port[i/2];\r\ndchan->reg = hsu->reg + HSU_DMA_CHANS_REG_OFFSET +\r\ni * HSU_DMA_CHANS_REG_LENGTH;\r\ndchan++;\r\n}\r\nphsu = hsu;\r\nhsu_debugfs_init(hsu);\r\nreturn;\r\nerr_free_region:\r\nrelease_mem_region(hsu->paddr, hsu->iolen);\r\nkfree(hsu);\r\nreturn;\r\n}\r\nstatic void serial_hsu_remove(struct pci_dev *pdev)\r\n{\r\nvoid *priv = pci_get_drvdata(pdev);\r\nstruct uart_hsu_port *up;\r\nif (!priv)\r\nreturn;\r\nif (pdev->device != 0x081E) {\r\nup = priv;\r\nuart_remove_one_port(&serial_hsu_reg, &up->port);\r\n}\r\npci_set_drvdata(pdev, NULL);\r\nfree_irq(pdev->irq, priv);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init hsu_pci_init(void)\r\n{\r\nint ret;\r\nhsu_global_init();\r\nret = uart_register_driver(&serial_hsu_reg);\r\nif (ret)\r\nreturn ret;\r\nreturn pci_register_driver(&hsu_pci_driver);\r\n}\r\nstatic void __exit hsu_pci_exit(void)\r\n{\r\npci_unregister_driver(&hsu_pci_driver);\r\nuart_unregister_driver(&serial_hsu_reg);\r\nhsu_debugfs_remove(phsu);\r\nkfree(phsu);\r\n}
