static void envtrl_i2c_test_pin(void)\r\n{\r\nint limit = 1000000;\r\nwhile (--limit > 0) {\r\nif (!(readb(i2c + PCF8584_CSR) & STATUS_PIN))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (limit <= 0)\r\nprintk(KERN_INFO PFX "Pin status will not clear.\n");\r\n}\r\nstatic void envctrl_i2c_test_bb(void)\r\n{\r\nint limit = 1000000;\r\nwhile (--limit > 0) {\r\nif (readb(i2c + PCF8584_CSR) & STATUS_BB)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (limit <= 0)\r\nprintk(KERN_INFO PFX "Busy bit will not clear.\n");\r\n}\r\nstatic int envctrl_i2c_read_addr(unsigned char addr)\r\n{\r\nenvctrl_i2c_test_bb();\r\nwriteb(addr + 1, i2c + PCF8584_DATA);\r\nenvctrl_i2c_test_bb();\r\nwriteb(OBD_SEND_START, i2c + PCF8584_CSR);\r\nenvtrl_i2c_test_pin();\r\nif (!(readb(i2c + PCF8584_CSR) & STATUS_LRB)) {\r\nreturn readb(i2c + PCF8584_DATA);\r\n} else {\r\nwriteb(OBD_SEND_STOP, i2c + PCF8584_CSR);\r\nreturn 0;\r\n}\r\n}\r\nstatic void envctrl_i2c_write_addr(unsigned char addr)\r\n{\r\nenvctrl_i2c_test_bb();\r\nwriteb(addr, i2c + PCF8584_DATA);\r\nwriteb(OBD_SEND_START, i2c + PCF8584_CSR);\r\n}\r\nstatic unsigned char envctrl_i2c_read_data(void)\r\n{\r\nenvtrl_i2c_test_pin();\r\nwriteb(CONTROL_ES0, i2c + PCF8584_CSR);\r\nreturn readb(i2c + PCF8584_DATA);\r\n}\r\nstatic void envctrl_i2c_write_data(unsigned char port)\r\n{\r\nenvtrl_i2c_test_pin();\r\nwriteb(port, i2c + PCF8584_DATA);\r\n}\r\nstatic void envctrl_i2c_stop(void)\r\n{\r\nenvtrl_i2c_test_pin();\r\nwriteb(OBD_SEND_STOP, i2c + PCF8584_CSR);\r\n}\r\nstatic unsigned char envctrl_i2c_read_8591(unsigned char addr, unsigned char port)\r\n{\r\nenvctrl_i2c_write_addr(addr);\r\nenvctrl_i2c_write_data(port);\r\nenvctrl_i2c_stop();\r\nenvctrl_i2c_read_addr(addr);\r\nenvctrl_i2c_read_data();\r\nenvctrl_i2c_stop();\r\nreturn readb(i2c + PCF8584_DATA);\r\n}\r\nstatic unsigned char envctrl_i2c_read_8574(unsigned char addr)\r\n{\r\nunsigned char rd;\r\nenvctrl_i2c_read_addr(addr);\r\nrd = envctrl_i2c_read_data();\r\nenvctrl_i2c_stop();\r\nreturn rd;\r\n}\r\nstatic int envctrl_i2c_data_translate(unsigned char data, int translate_type,\r\nint scale, char *tbl, char *bufdata)\r\n{\r\nint len = 0;\r\nswitch (translate_type) {\r\ncase ENVCTRL_TRANSLATE_NO:\r\nlen = 1;\r\nbufdata[0] = data;\r\nbreak;\r\ncase ENVCTRL_TRANSLATE_FULL:\r\nlen = 1;\r\nbufdata[0] = tbl[data];\r\nbreak;\r\ncase ENVCTRL_TRANSLATE_SCALE:\r\nsprintf(bufdata,"%d ", (tbl[data] * 10) / (scale));\r\nlen = strlen(bufdata);\r\nbufdata[len - 1] = bufdata[len - 2];\r\nbufdata[len - 2] = '.';\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\nreturn len;\r\n}\r\nstatic int envctrl_read_cpu_info(int cpu, struct i2c_child_t *pchild,\r\nchar mon_type, unsigned char *bufdata)\r\n{\r\nunsigned char data;\r\nint i;\r\nchar *tbl, j = -1;\r\nfor (i = 0; i < PCF8584_MAX_CHANNELS; i++) {\r\nif (pchild->mon_type[i] == mon_type) {\r\nif (++j == cpu) {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (j != cpu)\r\nreturn 0;\r\ndata = envctrl_i2c_read_8591((unsigned char)pchild->addr,\r\n(unsigned char)pchild->chnl_array[i].chnl_no);\r\ntbl = pchild->tables + pchild->tblprop_array[i].offset;\r\nreturn envctrl_i2c_data_translate(data, pchild->tblprop_array[i].type,\r\npchild->tblprop_array[i].scale,\r\ntbl, bufdata);\r\n}\r\nstatic int envctrl_read_noncpu_info(struct i2c_child_t *pchild,\r\nchar mon_type, unsigned char *bufdata)\r\n{\r\nunsigned char data;\r\nint i;\r\nchar *tbl = NULL;\r\nfor (i = 0; i < PCF8584_MAX_CHANNELS; i++) {\r\nif (pchild->mon_type[i] == mon_type)\r\nbreak;\r\n}\r\nif (i >= PCF8584_MAX_CHANNELS)\r\nreturn 0;\r\ndata = envctrl_i2c_read_8591((unsigned char)pchild->addr,\r\n(unsigned char)pchild->chnl_array[i].chnl_no);\r\ntbl = pchild->tables + pchild->tblprop_array[i].offset;\r\nreturn envctrl_i2c_data_translate(data, pchild->tblprop_array[i].type,\r\npchild->tblprop_array[i].scale,\r\ntbl, bufdata);\r\n}\r\nstatic int envctrl_i2c_fan_status(struct i2c_child_t *pchild,\r\nunsigned char data,\r\nchar *bufdata)\r\n{\r\nunsigned char tmp, ret = 0;\r\nint i, j = 0;\r\ntmp = data & pchild->fan_mask;\r\nif (tmp == pchild->fan_mask) {\r\nret = ENVCTRL_ALL_FANS_GOOD;\r\n} else if (tmp == 0) {\r\nret = ENVCTRL_ALL_FANS_BAD;\r\n} else {\r\nfor (i = 0; i < PCF8584_MAX_CHANNELS;i++) {\r\nif (pchild->fan_mask & chnls_mask[i]) {\r\nif (!(chnls_mask[i] & tmp))\r\nret |= chnls_mask[j];\r\nj++;\r\n}\r\n}\r\n}\r\nbufdata[0] = ret;\r\nreturn 1;\r\n}\r\nstatic int envctrl_i2c_globaladdr(struct i2c_child_t *pchild,\r\nunsigned char data,\r\nchar *bufdata)\r\n{\r\nbufdata[0] = (data & ENVCTRL_GLOBALADDR_ADDR_MASK);\r\nreturn 1;\r\n}\r\nstatic unsigned char envctrl_i2c_voltage_status(struct i2c_child_t *pchild,\r\nunsigned char data,\r\nchar *bufdata)\r\n{\r\nunsigned char tmp, ret = 0;\r\nint i, j = 0;\r\ntmp = data & pchild->voltage_mask;\r\nif (tmp == pchild->voltage_mask) {\r\nret = ENVCTRL_VOLTAGE_POWERSUPPLY_GOOD;\r\n} else if (tmp == 0) {\r\nret = ENVCTRL_VOLTAGE_POWERSUPPLY_BAD;\r\n} else {\r\nfor (i = 0; i < PCF8584_MAX_CHANNELS; i++) {\r\nif (pchild->voltage_mask & chnls_mask[i]) {\r\nj++;\r\nif (!(chnls_mask[i] & tmp))\r\nbreak;\r\n}\r\n}\r\nif (j == 1)\r\nret = ENVCTRL_VOLTAGE_BAD;\r\nelse\r\nret = ENVCTRL_POWERSUPPLY_BAD;\r\n}\r\nbufdata[0] = ret;\r\nreturn 1;\r\n}\r\nstatic ssize_t\r\nenvctrl_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct i2c_child_t *pchild;\r\nunsigned char data[10];\r\nint ret = 0;\r\nswitch ((int)(long)file->private_data) {\r\ncase ENVCTRL_RD_WARNING_TEMPERATURE:\r\nif (warning_temperature == 0)\r\nreturn 0;\r\ndata[0] = (unsigned char)(warning_temperature);\r\nret = 1;\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_SHUTDOWN_TEMPERATURE:\r\nif (shutdown_temperature == 0)\r\nreturn 0;\r\ndata[0] = (unsigned char)(shutdown_temperature);\r\nret = 1;\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_MTHRBD_TEMPERATURE:\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_MTHRBDTEMP_MON)))\r\nreturn 0;\r\nret = envctrl_read_noncpu_info(pchild, ENVCTRL_MTHRBDTEMP_MON, data);\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_CPU_TEMPERATURE:\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_CPUTEMP_MON)))\r\nreturn 0;\r\nret = envctrl_read_cpu_info(read_cpu, pchild, ENVCTRL_CPUTEMP_MON, data);\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_CPU_VOLTAGE:\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_CPUVOLTAGE_MON)))\r\nreturn 0;\r\nret = envctrl_read_cpu_info(read_cpu, pchild, ENVCTRL_CPUVOLTAGE_MON, data);\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_SCSI_TEMPERATURE:\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_SCSITEMP_MON)))\r\nreturn 0;\r\nret = envctrl_read_noncpu_info(pchild, ENVCTRL_SCSITEMP_MON, data);\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_ETHERNET_TEMPERATURE:\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_ETHERTEMP_MON)))\r\nreturn 0;\r\nret = envctrl_read_noncpu_info(pchild, ENVCTRL_ETHERTEMP_MON, data);\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_FAN_STATUS:\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_FANSTAT_MON)))\r\nreturn 0;\r\ndata[0] = envctrl_i2c_read_8574(pchild->addr);\r\nret = envctrl_i2c_fan_status(pchild,data[0], data);\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_GLOBALADDRESS:\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_GLOBALADDR_MON)))\r\nreturn 0;\r\ndata[0] = envctrl_i2c_read_8574(pchild->addr);\r\nret = envctrl_i2c_globaladdr(pchild, data[0], data);\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ncase ENVCTRL_RD_VOLTAGE_STATUS:\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_VOLTAGESTAT_MON)))\r\nif (!(pchild = envctrl_get_i2c_child(ENVCTRL_GLOBALADDR_MON)))\r\nreturn 0;\r\ndata[0] = envctrl_i2c_read_8574(pchild->addr);\r\nret = envctrl_i2c_voltage_status(pchild, data[0], data);\r\nif (copy_to_user(buf, data, ret))\r\nret = -EFAULT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\nreturn ret;\r\n}\r\nstatic long\r\nenvctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nchar __user *infobuf;\r\nswitch (cmd) {\r\ncase ENVCTRL_RD_WARNING_TEMPERATURE:\r\ncase ENVCTRL_RD_SHUTDOWN_TEMPERATURE:\r\ncase ENVCTRL_RD_MTHRBD_TEMPERATURE:\r\ncase ENVCTRL_RD_FAN_STATUS:\r\ncase ENVCTRL_RD_VOLTAGE_STATUS:\r\ncase ENVCTRL_RD_ETHERNET_TEMPERATURE:\r\ncase ENVCTRL_RD_SCSI_TEMPERATURE:\r\ncase ENVCTRL_RD_GLOBALADDRESS:\r\nfile->private_data = (void *)(long)cmd;\r\nbreak;\r\ncase ENVCTRL_RD_CPU_TEMPERATURE:\r\ncase ENVCTRL_RD_CPU_VOLTAGE:\r\ninfobuf = (char __user *) arg;\r\nif (infobuf == NULL) {\r\nread_cpu = 0;\r\n}else {\r\nget_user(read_cpu, infobuf);\r\n}\r\nfile->private_data = (void *)(long)cmd;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nreturn 0;\r\n}\r\nstatic int\r\nenvctrl_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nenvctrl_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic void envctrl_set_mon(struct i2c_child_t *pchild,\r\nconst char *chnl_desc,\r\nint chnl_no)\r\n{\r\nif (!(strcmp(chnl_desc,"temp,cpu")) ||\r\n!(strcmp(chnl_desc,"temp,cpu0")) ||\r\n!(strcmp(chnl_desc,"temp,cpu1")) ||\r\n!(strcmp(chnl_desc,"temp,cpu2")) ||\r\n!(strcmp(chnl_desc,"temp,cpu3")))\r\npchild->mon_type[chnl_no] = ENVCTRL_CPUTEMP_MON;\r\nif (!(strcmp(chnl_desc,"vddcore,cpu0")) ||\r\n!(strcmp(chnl_desc,"vddcore,cpu1")) ||\r\n!(strcmp(chnl_desc,"vddcore,cpu2")) ||\r\n!(strcmp(chnl_desc,"vddcore,cpu3")))\r\npchild->mon_type[chnl_no] = ENVCTRL_CPUVOLTAGE_MON;\r\nif (!(strcmp(chnl_desc,"temp,motherboard")))\r\npchild->mon_type[chnl_no] = ENVCTRL_MTHRBDTEMP_MON;\r\nif (!(strcmp(chnl_desc,"temp,scsi")))\r\npchild->mon_type[chnl_no] = ENVCTRL_SCSITEMP_MON;\r\nif (!(strcmp(chnl_desc,"temp,ethernet")))\r\npchild->mon_type[chnl_no] = ENVCTRL_ETHERTEMP_MON;\r\n}\r\nstatic void envctrl_init_adc(struct i2c_child_t *pchild, struct device_node *dp)\r\n{\r\nint i = 0, len;\r\nconst char *pos;\r\nconst unsigned int *pval;\r\npos = of_get_property(dp, "channels-description", &len);\r\nwhile (len > 0) {\r\nint l = strlen(pos) + 1;\r\nenvctrl_set_mon(pchild, pos, i++);\r\nlen -= l;\r\npos += l;\r\n}\r\npval = of_get_property(dp, "warning-temp", NULL);\r\nif (pval)\r\nwarning_temperature = *pval;\r\npval = of_get_property(dp, "shutdown-temp", NULL);\r\nif (pval)\r\nshutdown_temperature = *pval;\r\n}\r\nstatic void envctrl_init_fanstat(struct i2c_child_t *pchild)\r\n{\r\nint i;\r\nfor (i = 0; i < pchild->total_chnls; i++)\r\npchild->fan_mask |= chnls_mask[(pchild->chnl_array[i]).chnl_no];\r\npchild->mon_type[0] = ENVCTRL_FANSTAT_MON;\r\n}\r\nstatic void envctrl_init_globaladdr(struct i2c_child_t *pchild)\r\n{\r\nint i;\r\nfor (i = 0; i < pchild->total_chnls; i++) {\r\nif (PCF8584_VOLTAGE_TYPE == pchild->chnl_array[i].type) {\r\npchild->voltage_mask |= chnls_mask[i];\r\n}\r\n}\r\npchild->mon_type[0] = ENVCTRL_GLOBALADDR_MON;\r\n}\r\nstatic void envctrl_init_voltage_status(struct i2c_child_t *pchild)\r\n{\r\nint i;\r\nfor (i = 0; i < pchild->total_chnls; i++)\r\npchild->voltage_mask |= chnls_mask[(pchild->chnl_array[i]).chnl_no];\r\npchild->mon_type[0] = ENVCTRL_VOLTAGESTAT_MON;\r\n}\r\nstatic void envctrl_init_i2c_child(struct device_node *dp,\r\nstruct i2c_child_t *pchild)\r\n{\r\nint len, i, tbls_size = 0;\r\nconst void *pval;\r\npval = of_get_property(dp, "reg", &len);\r\nmemcpy(&pchild->addr, pval, len);\r\npval = of_get_property(dp, "translation", &len);\r\nif (pval && len > 0) {\r\nmemcpy(pchild->tblprop_array, pval, len);\r\npchild->total_tbls = len / sizeof(struct pcf8584_tblprop);\r\nfor (i = 0; i < pchild->total_tbls; i++) {\r\nif ((pchild->tblprop_array[i].size + pchild->tblprop_array[i].offset) > tbls_size) {\r\ntbls_size = pchild->tblprop_array[i].size + pchild->tblprop_array[i].offset;\r\n}\r\n}\r\npchild->tables = kmalloc(tbls_size, GFP_KERNEL);\r\nif (pchild->tables == NULL){\r\nprintk(KERN_ERR PFX "Failed to allocate table.\n");\r\nreturn;\r\n}\r\npval = of_get_property(dp, "tables", &len);\r\nif (!pval || len <= 0) {\r\nprintk(KERN_ERR PFX "Failed to get table.\n");\r\nreturn;\r\n}\r\nmemcpy(pchild->tables, pval, len);\r\n}\r\nif (ENVCTRL_CPCI_IGNORED_NODE == pchild->addr) {\r\nstruct device_node *root_node;\r\nint len;\r\nroot_node = of_find_node_by_path("/");\r\nif (!strcmp(root_node->name, "SUNW,UltraSPARC-IIi-cEngine")) {\r\nfor (len = 0; len < PCF8584_MAX_CHANNELS; ++len) {\r\npchild->mon_type[len] = ENVCTRL_NOMON;\r\n}\r\nreturn;\r\n}\r\n}\r\npval = of_get_property(dp, "channels-in-use", &len);\r\nmemcpy(pchild->chnl_array, pval, len);\r\npchild->total_chnls = len / sizeof(struct pcf8584_channel);\r\nfor (i = 0; i < pchild->total_chnls; i++) {\r\nswitch (pchild->chnl_array[i].type) {\r\ncase PCF8584_TEMP_TYPE:\r\nenvctrl_init_adc(pchild, dp);\r\nbreak;\r\ncase PCF8584_GLOBALADDR_TYPE:\r\nenvctrl_init_globaladdr(pchild);\r\ni = pchild->total_chnls;\r\nbreak;\r\ncase PCF8584_FANSTAT_TYPE:\r\nenvctrl_init_fanstat(pchild);\r\ni = pchild->total_chnls;\r\nbreak;\r\ncase PCF8584_VOLTAGE_TYPE:\r\nif (pchild->i2ctype == I2C_ADC) {\r\nenvctrl_init_adc(pchild,dp);\r\n} else {\r\nenvctrl_init_voltage_status(pchild);\r\n}\r\ni = pchild->total_chnls;\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\n}\r\n}\r\nstatic struct i2c_child_t *envctrl_get_i2c_child(unsigned char mon_type)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ENVCTRL_MAX_CPU*2; i++) {\r\nfor (j = 0; j < PCF8584_MAX_CHANNELS; j++) {\r\nif (i2c_childlist[i].mon_type[j] == mon_type) {\r\nreturn (struct i2c_child_t *)(&(i2c_childlist[i]));\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void envctrl_do_shutdown(void)\r\n{\r\nstatic int inprog = 0;\r\nint ret;\r\nif (inprog != 0)\r\nreturn;\r\ninprog = 1;\r\nprintk(KERN_CRIT "kenvctrld: WARNING: Shutting down the system now.\n");\r\nret = orderly_poweroff(true);\r\nif (ret < 0) {\r\nprintk(KERN_CRIT "kenvctrld: WARNING: system shutdown failed!\n");\r\ninprog = 0;\r\n}\r\n}\r\nstatic int kenvctrld(void *__unused)\r\n{\r\nint poll_interval;\r\nint whichcpu;\r\nchar tempbuf[10];\r\nstruct i2c_child_t *cputemp;\r\nif (NULL == (cputemp = envctrl_get_i2c_child(ENVCTRL_CPUTEMP_MON))) {\r\nprintk(KERN_ERR PFX\r\n"kenvctrld unable to monitor CPU temp-- exiting\n");\r\nreturn -ENODEV;\r\n}\r\npoll_interval = 5000;\r\nprintk(KERN_INFO PFX "%s starting...\n", current->comm);\r\nfor (;;) {\r\nmsleep_interruptible(poll_interval);\r\nif (kthread_should_stop())\r\nbreak;\r\nfor (whichcpu = 0; whichcpu < ENVCTRL_MAX_CPU; ++whichcpu) {\r\nif (0 < envctrl_read_cpu_info(whichcpu, cputemp,\r\nENVCTRL_CPUTEMP_MON,\r\ntempbuf)) {\r\nif (tempbuf[0] >= shutdown_temperature) {\r\nprintk(KERN_CRIT\r\n"%s: WARNING: CPU%i temperature %i C meets or exceeds "\\r\n"shutdown threshold %i C\n",\r\ncurrent->comm, whichcpu,\r\ntempbuf[0], shutdown_temperature);\r\nenvctrl_do_shutdown();\r\n}\r\n}\r\n}\r\n}\r\nprintk(KERN_INFO PFX "%s exiting...\n", current->comm);\r\nreturn 0;\r\n}\r\nstatic int __devinit envctrl_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp;\r\nint index, err;\r\nif (i2c)\r\nreturn -EINVAL;\r\ni2c = of_ioremap(&op->resource[0], 0, 0x2, DRIVER_NAME);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nindex = 0;\r\ndp = op->dev.of_node->child;\r\nwhile (dp) {\r\nif (!strcmp(dp->name, "gpio")) {\r\ni2c_childlist[index].i2ctype = I2C_GPIO;\r\nenvctrl_init_i2c_child(dp, &(i2c_childlist[index++]));\r\n} else if (!strcmp(dp->name, "adc")) {\r\ni2c_childlist[index].i2ctype = I2C_ADC;\r\nenvctrl_init_i2c_child(dp, &(i2c_childlist[index++]));\r\n}\r\ndp = dp->sibling;\r\n}\r\nwriteb(CONTROL_PIN, i2c + PCF8584_CSR);\r\nwriteb(PCF8584_ADDRESS, i2c + PCF8584_DATA);\r\nwriteb(CONTROL_PIN | CONTROL_ES1, i2c + PCF8584_CSR);\r\nwriteb(CLK_4_43 | BUS_CLK_90, i2c + PCF8584_DATA);\r\nwriteb(CONTROL_PIN | CONTROL_ES0 | CONTROL_ACK, i2c + PCF8584_CSR);\r\nudelay(200);\r\nerr = misc_register(&envctrl_dev);\r\nif (err) {\r\nprintk(KERN_ERR PFX "Unable to get misc minor %d\n",\r\nenvctrl_dev.minor);\r\ngoto out_iounmap;\r\n}\r\nprintk(KERN_INFO PFX "Initialized ");\r\nfor (--index; index >= 0; --index) {\r\nprintk("[%s 0x%lx]%s",\r\n(I2C_ADC == i2c_childlist[index].i2ctype) ? "adc" :\r\n((I2C_GPIO == i2c_childlist[index].i2ctype) ? "gpio" : "unknown"),\r\ni2c_childlist[index].addr, (0 == index) ? "\n" : " ");\r\n}\r\nkenvctrld_task = kthread_run(kenvctrld, NULL, "kenvctrld");\r\nif (IS_ERR(kenvctrld_task)) {\r\nerr = PTR_ERR(kenvctrld_task);\r\ngoto out_deregister;\r\n}\r\nreturn 0;\r\nout_deregister:\r\nmisc_deregister(&envctrl_dev);\r\nout_iounmap:\r\nof_iounmap(&op->resource[0], i2c, 0x2);\r\nfor (index = 0; index < ENVCTRL_MAX_CPU * 2; index++)\r\nkfree(i2c_childlist[index].tables);\r\nreturn err;\r\n}\r\nstatic int __devexit envctrl_remove(struct platform_device *op)\r\n{\r\nint index;\r\nkthread_stop(kenvctrld_task);\r\nof_iounmap(&op->resource[0], i2c, 0x2);\r\nmisc_deregister(&envctrl_dev);\r\nfor (index = 0; index < ENVCTRL_MAX_CPU * 2; index++)\r\nkfree(i2c_childlist[index].tables);\r\nreturn 0;\r\n}\r\nstatic int __init envctrl_init(void)\r\n{\r\nreturn platform_driver_register(&envctrl_driver);\r\n}\r\nstatic void __exit envctrl_exit(void)\r\n{\r\nplatform_driver_unregister(&envctrl_driver);\r\n}
