struct mtd_info *lpddr_cmdset(struct map_info *map)\r\n{\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nstruct flchip_shared *shared;\r\nstruct flchip *chip;\r\nstruct mtd_info *mtd;\r\nint numchips;\r\nint i, j;\r\nmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\r\nif (!mtd) {\r\nprintk(KERN_ERR "Failed to allocate memory for MTD device\n");\r\nreturn NULL;\r\n}\r\nmtd->priv = map;\r\nmtd->type = MTD_NORFLASH;\r\nmtd->read = lpddr_read;\r\nmtd->type = MTD_NORFLASH;\r\nmtd->flags = MTD_CAP_NORFLASH;\r\nmtd->flags &= ~MTD_BIT_WRITEABLE;\r\nmtd->erase = lpddr_erase;\r\nmtd->write = lpddr_write_buffers;\r\nmtd->writev = lpddr_writev;\r\nmtd->read_oob = NULL;\r\nmtd->write_oob = NULL;\r\nmtd->sync = NULL;\r\nmtd->lock = lpddr_lock;\r\nmtd->unlock = lpddr_unlock;\r\nmtd->suspend = NULL;\r\nmtd->resume = NULL;\r\nif (map_is_linear(map)) {\r\nmtd->point = lpddr_point;\r\nmtd->unpoint = lpddr_unpoint;\r\n}\r\nmtd->block_isbad = NULL;\r\nmtd->block_markbad = NULL;\r\nmtd->size = 1 << lpddr->qinfo->DevSizeShift;\r\nmtd->erasesize = 1 << lpddr->qinfo->UniformBlockSizeShift;\r\nmtd->writesize = 1 << lpddr->qinfo->BufSizeShift;\r\nshared = kmalloc(sizeof(struct flchip_shared) * lpddr->numchips,\r\nGFP_KERNEL);\r\nif (!shared) {\r\nkfree(lpddr);\r\nkfree(mtd);\r\nreturn NULL;\r\n}\r\nchip = &lpddr->chips[0];\r\nnumchips = lpddr->numchips / lpddr->qinfo->HWPartsNum;\r\nfor (i = 0; i < numchips; i++) {\r\nshared[i].writing = shared[i].erasing = NULL;\r\nmutex_init(&shared[i].lock);\r\nfor (j = 0; j < lpddr->qinfo->HWPartsNum; j++) {\r\n*chip = lpddr->chips[i];\r\nchip->start += j << lpddr->chipshift;\r\nchip->oldstate = chip->state = FL_READY;\r\nchip->priv = &shared[i];\r\ninit_waitqueue_head(&chip->wq);\r\nmutex_init(&chip->mutex);\r\nchip++;\r\n}\r\n}\r\nreturn mtd;\r\n}\r\nstatic int wait_for_ready(struct map_info *map, struct flchip *chip,\r\nunsigned int chip_op_time)\r\n{\r\nunsigned int timeo, reset_timeo, sleep_time;\r\nunsigned int dsr;\r\nflstate_t chip_state = chip->state;\r\nint ret = 0;\r\ntimeo = chip_op_time * 8;\r\nif (!timeo)\r\ntimeo = 500000;\r\nreset_timeo = timeo;\r\nsleep_time = chip_op_time / 2;\r\nfor (;;) {\r\ndsr = CMDVAL(map_read(map, map->pfow_base + PFOW_DSR));\r\nif (dsr & DSR_READY_STATUS)\r\nbreak;\r\nif (!timeo) {\r\nprintk(KERN_ERR "%s: Flash timeout error state %d \n",\r\nmap->name, chip_state);\r\nret = -ETIME;\r\nbreak;\r\n}\r\nmutex_unlock(&chip->mutex);\r\nif (sleep_time >= 1000000/HZ) {\r\nmsleep(sleep_time/1000);\r\ntimeo -= sleep_time;\r\nsleep_time = 1000000/HZ;\r\n} else {\r\nudelay(1);\r\ncond_resched();\r\ntimeo--;\r\n}\r\nmutex_lock(&chip->mutex);\r\nwhile (chip->state != chip_state) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\n}\r\nif (chip->erase_suspended || chip->write_suspended) {\r\ntimeo = reset_timeo;\r\nchip->erase_suspended = chip->write_suspended = 0;\r\n}\r\n}\r\nif (dsr & DSR_ERR) {\r\nmap_write(map, CMD(~(DSR_ERR)), map->pfow_base + PFOW_DSR);\r\nprintk(KERN_WARNING"%s: Bad status on wait: 0x%x \n",\r\nmap->name, dsr);\r\nprint_drs_error(dsr);\r\nret = -EIO;\r\n}\r\nchip->state = FL_READY;\r\nreturn ret;\r\n}\r\nstatic int get_chip(struct map_info *map, struct flchip *chip, int mode)\r\n{\r\nint ret;\r\nDECLARE_WAITQUEUE(wait, current);\r\nretry:\r\nif (chip->priv && (mode == FL_WRITING || mode == FL_ERASING)\r\n&& chip->state != FL_SYNCING) {\r\nstruct flchip_shared *shared = chip->priv;\r\nstruct flchip *contender;\r\nmutex_lock(&shared->lock);\r\ncontender = shared->writing;\r\nif (contender && contender != chip) {\r\nret = mutex_trylock(&contender->mutex);\r\nmutex_unlock(&shared->lock);\r\nif (!ret)\r\ngoto retry;\r\nmutex_unlock(&chip->mutex);\r\nret = chip_ready(map, contender, mode);\r\nmutex_lock(&chip->mutex);\r\nif (ret == -EAGAIN) {\r\nmutex_unlock(&contender->mutex);\r\ngoto retry;\r\n}\r\nif (ret) {\r\nmutex_unlock(&contender->mutex);\r\nreturn ret;\r\n}\r\nmutex_lock(&shared->lock);\r\nif (chip->state == FL_SYNCING) {\r\nput_chip(map, contender);\r\nmutex_unlock(&contender->mutex);\r\ngoto retry;\r\n}\r\nmutex_unlock(&contender->mutex);\r\n}\r\nif (mode == FL_ERASING && shared->erasing\r\n&& shared->erasing->oldstate == FL_ERASING) {\r\nmutex_unlock(&shared->lock);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\ngoto retry;\r\n}\r\nshared->writing = chip;\r\nif (mode == FL_ERASING)\r\nshared->erasing = chip;\r\nmutex_unlock(&shared->lock);\r\n}\r\nret = chip_ready(map, chip, mode);\r\nif (ret == -EAGAIN)\r\ngoto retry;\r\nreturn ret;\r\n}\r\nstatic int chip_ready(struct map_info *map, struct flchip *chip, int mode)\r\n{\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint ret = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (FL_SYNCING == mode && FL_READY != chip->oldstate)\r\ngoto sleep;\r\nswitch (chip->state) {\r\ncase FL_READY:\r\ncase FL_JEDEC_QUERY:\r\nreturn 0;\r\ncase FL_ERASING:\r\nif (!lpddr->qinfo->SuspEraseSupp ||\r\n!(mode == FL_READY || mode == FL_POINT))\r\ngoto sleep;\r\nmap_write(map, CMD(LPDDR_SUSPEND),\r\nmap->pfow_base + PFOW_PROGRAM_ERASE_SUSPEND);\r\nchip->oldstate = FL_ERASING;\r\nchip->state = FL_ERASE_SUSPENDING;\r\nret = wait_for_ready(map, chip, 0);\r\nif (ret) {\r\nput_chip(map, chip);\r\nprintk(KERN_ERR "%s: suspend operation failed."\r\n"State may be wrong \n", map->name);\r\nreturn -EIO;\r\n}\r\nchip->erase_suspended = 1;\r\nchip->state = FL_READY;\r\nreturn 0;\r\ncase FL_POINT:\r\nif (mode == FL_READY && chip->oldstate == FL_READY)\r\nreturn 0;\r\ndefault:\r\nsleep:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic void put_chip(struct map_info *map, struct flchip *chip)\r\n{\r\nif (chip->priv) {\r\nstruct flchip_shared *shared = chip->priv;\r\nmutex_lock(&shared->lock);\r\nif (shared->writing == chip && chip->oldstate == FL_READY) {\r\nshared->writing = shared->erasing;\r\nif (shared->writing && shared->writing != chip) {\r\nstruct flchip *loaner = shared->writing;\r\nmutex_lock(&loaner->mutex);\r\nmutex_unlock(&shared->lock);\r\nmutex_unlock(&chip->mutex);\r\nput_chip(map, loaner);\r\nmutex_lock(&chip->mutex);\r\nmutex_unlock(&loaner->mutex);\r\nwake_up(&chip->wq);\r\nreturn;\r\n}\r\nshared->erasing = NULL;\r\nshared->writing = NULL;\r\n} else if (shared->erasing == chip && shared->writing != chip) {\r\nmutex_unlock(&shared->lock);\r\nwake_up(&chip->wq);\r\nreturn;\r\n}\r\nmutex_unlock(&shared->lock);\r\n}\r\nswitch (chip->oldstate) {\r\ncase FL_ERASING:\r\nmap_write(map, CMD(LPDDR_RESUME),\r\nmap->pfow_base + PFOW_COMMAND_CODE);\r\nmap_write(map, CMD(LPDDR_START_EXECUTION),\r\nmap->pfow_base + PFOW_COMMAND_EXECUTE);\r\nchip->oldstate = FL_READY;\r\nchip->state = FL_ERASING;\r\nbreak;\r\ncase FL_READY:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: put_chip() called with oldstate %d!\n",\r\nmap->name, chip->oldstate);\r\n}\r\nwake_up(&chip->wq);\r\n}\r\nint do_write_buffer(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, const struct kvec **pvec,\r\nunsigned long *pvec_seek, int len)\r\n{\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nmap_word datum;\r\nint ret, wbufsize, word_gap, words;\r\nconst struct kvec *vec;\r\nunsigned long vec_seek;\r\nunsigned long prog_buf_ofs;\r\nwbufsize = 1 << lpddr->qinfo->BufSizeShift;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, FL_WRITING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nword_gap = (-adr & (map_bankwidth(map)-1));\r\nwords = (len - word_gap + map_bankwidth(map) - 1) / map_bankwidth(map);\r\nif (!word_gap) {\r\nwords--;\r\n} else {\r\nword_gap = map_bankwidth(map) - word_gap;\r\nadr -= word_gap;\r\ndatum = map_word_ff(map);\r\n}\r\nprog_buf_ofs = map->pfow_base + CMDVAL(map_read(map,\r\nmap->pfow_base + PFOW_PROGRAM_BUFFER_OFFSET));\r\nvec = *pvec;\r\nvec_seek = *pvec_seek;\r\ndo {\r\nint n = map_bankwidth(map) - word_gap;\r\nif (n > vec->iov_len - vec_seek)\r\nn = vec->iov_len - vec_seek;\r\nif (n > len)\r\nn = len;\r\nif (!word_gap && (len < map_bankwidth(map)))\r\ndatum = map_word_ff(map);\r\ndatum = map_word_load_partial(map, datum,\r\nvec->iov_base + vec_seek, word_gap, n);\r\nlen -= n;\r\nword_gap += n;\r\nif (!len || word_gap == map_bankwidth(map)) {\r\nmap_write(map, datum, prog_buf_ofs);\r\nprog_buf_ofs += map_bankwidth(map);\r\nword_gap = 0;\r\n}\r\nvec_seek += n;\r\nif (vec_seek == vec->iov_len) {\r\nvec++;\r\nvec_seek = 0;\r\n}\r\n} while (len);\r\n*pvec = vec;\r\n*pvec_seek = vec_seek;\r\nsend_pfow_command(map, LPDDR_BUFF_PROGRAM, adr, wbufsize, NULL);\r\nchip->state = FL_WRITING;\r\nret = wait_for_ready(map, chip, (1<<lpddr->qinfo->ProgBufferTime));\r\nif (ret) {\r\nprintk(KERN_WARNING"%s Buffer program error: %d at %lx; \n",\r\nmap->name, ret, adr);\r\ngoto out;\r\n}\r\nout: put_chip(map, chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nint do_erase_oneblock(struct mtd_info *mtd, loff_t adr)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint chipnum = adr >> lpddr->chipshift;\r\nstruct flchip *chip = &lpddr->chips[chipnum];\r\nint ret;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, FL_ERASING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nsend_pfow_command(map, LPDDR_BLOCK_ERASE, adr, 0, NULL);\r\nchip->state = FL_ERASING;\r\nret = wait_for_ready(map, chip, (1<<lpddr->qinfo->BlockEraseTime)*1000);\r\nif (ret) {\r\nprintk(KERN_WARNING"%s Erase block error %d at : %llx\n",\r\nmap->name, ret, adr);\r\ngoto out;\r\n}\r\nout: put_chip(map, chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int lpddr_read(struct mtd_info *mtd, loff_t adr, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint chipnum = adr >> lpddr->chipshift;\r\nstruct flchip *chip = &lpddr->chips[chipnum];\r\nint ret = 0;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, FL_READY);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nmap_copy_from(map, buf, adr, len);\r\n*retlen = len;\r\nput_chip(map, chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int lpddr_point(struct mtd_info *mtd, loff_t adr, size_t len,\r\nsize_t *retlen, void **mtdbuf, resource_size_t *phys)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint chipnum = adr >> lpddr->chipshift;\r\nunsigned long ofs, last_end = 0;\r\nstruct flchip *chip = &lpddr->chips[chipnum];\r\nint ret = 0;\r\nif (!map->virt || (adr + len > mtd->size))\r\nreturn -EINVAL;\r\nofs = adr - (chipnum << lpddr->chipshift);\r\n*mtdbuf = (void *)map->virt + chip->start + ofs;\r\n*retlen = 0;\r\nwhile (len) {\r\nunsigned long thislen;\r\nif (chipnum >= lpddr->numchips)\r\nbreak;\r\nif (!last_end)\r\nlast_end = chip->start;\r\nelse if (chip->start != last_end)\r\nbreak;\r\nif ((len + ofs - 1) >> lpddr->chipshift)\r\nthislen = (1<<lpddr->chipshift) - ofs;\r\nelse\r\nthislen = len;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, FL_POINT);\r\nmutex_unlock(&chip->mutex);\r\nif (ret)\r\nbreak;\r\nchip->state = FL_POINT;\r\nchip->ref_point_counter++;\r\n*retlen += thislen;\r\nlen -= thislen;\r\nofs = 0;\r\nlast_end += 1 << lpddr->chipshift;\r\nchipnum++;\r\nchip = &lpddr->chips[chipnum];\r\n}\r\nreturn 0;\r\n}\r\nstatic void lpddr_unpoint (struct mtd_info *mtd, loff_t adr, size_t len)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint chipnum = adr >> lpddr->chipshift;\r\nunsigned long ofs;\r\nofs = adr - (chipnum << lpddr->chipshift);\r\nwhile (len) {\r\nunsigned long thislen;\r\nstruct flchip *chip;\r\nchip = &lpddr->chips[chipnum];\r\nif (chipnum >= lpddr->numchips)\r\nbreak;\r\nif ((len + ofs - 1) >> lpddr->chipshift)\r\nthislen = (1<<lpddr->chipshift) - ofs;\r\nelse\r\nthislen = len;\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_POINT) {\r\nchip->ref_point_counter--;\r\nif (chip->ref_point_counter == 0)\r\nchip->state = FL_READY;\r\n} else\r\nprintk(KERN_WARNING "%s: Warning: unpoint called on non"\r\n"pointed region\n", map->name);\r\nput_chip(map, chip);\r\nmutex_unlock(&chip->mutex);\r\nlen -= thislen;\r\nofs = 0;\r\nchipnum++;\r\n}\r\n}\r\nstatic int lpddr_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct kvec vec;\r\nvec.iov_base = (void *) buf;\r\nvec.iov_len = len;\r\nreturn lpddr_writev(mtd, &vec, 1, to, retlen);\r\n}\r\nstatic int lpddr_writev(struct mtd_info *mtd, const struct kvec *vecs,\r\nunsigned long count, loff_t to, size_t *retlen)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint ret = 0;\r\nint chipnum;\r\nunsigned long ofs, vec_seek, i;\r\nint wbufsize = 1 << lpddr->qinfo->BufSizeShift;\r\nsize_t len = 0;\r\nfor (i = 0; i < count; i++)\r\nlen += vecs[i].iov_len;\r\n*retlen = 0;\r\nif (!len)\r\nreturn 0;\r\nchipnum = to >> lpddr->chipshift;\r\nofs = to;\r\nvec_seek = 0;\r\ndo {\r\nint size = wbufsize - (ofs & (wbufsize-1));\r\nif (size > len)\r\nsize = len;\r\nret = do_write_buffer(map, &lpddr->chips[chipnum],\r\nofs, &vecs, &vec_seek, size);\r\nif (ret)\r\nreturn ret;\r\nofs += size;\r\n(*retlen) += size;\r\nlen -= size;\r\ncond_resched();\r\n} while (len);\r\nreturn 0;\r\n}\r\nstatic int lpddr_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nunsigned long ofs, len;\r\nint ret;\r\nstruct map_info *map = mtd->priv;\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint size = 1 << lpddr->qinfo->UniformBlockSizeShift;\r\nofs = instr->addr;\r\nlen = instr->len;\r\nif (ofs > mtd->size || (len + ofs) > mtd->size)\r\nreturn -EINVAL;\r\nwhile (len > 0) {\r\nret = do_erase_oneblock(mtd, ofs);\r\nif (ret)\r\nreturn ret;\r\nofs += size;\r\nlen -= size;\r\n}\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nint do_xxlock(struct mtd_info *mtd, loff_t adr, uint32_t len, int thunk)\r\n{\r\nint ret = 0;\r\nstruct map_info *map = mtd->priv;\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint chipnum = adr >> lpddr->chipshift;\r\nstruct flchip *chip = &lpddr->chips[chipnum];\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, FL_LOCKING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nif (thunk == DO_XXLOCK_LOCK) {\r\nsend_pfow_command(map, LPDDR_LOCK_BLOCK, adr, adr + len, NULL);\r\nchip->state = FL_LOCKING;\r\n} else if (thunk == DO_XXLOCK_UNLOCK) {\r\nsend_pfow_command(map, LPDDR_UNLOCK_BLOCK, adr, adr + len, NULL);\r\nchip->state = FL_UNLOCKING;\r\n} else\r\nBUG();\r\nret = wait_for_ready(map, chip, 1);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: block unlock error status %d \n",\r\nmap->name, ret);\r\ngoto out;\r\n}\r\nout: put_chip(map, chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int lpddr_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nreturn do_xxlock(mtd, ofs, len, DO_XXLOCK_LOCK);\r\n}\r\nstatic int lpddr_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nreturn do_xxlock(mtd, ofs, len, DO_XXLOCK_UNLOCK);\r\n}\r\nint word_program(struct map_info *map, loff_t adr, uint32_t curval)\r\n{\r\nint ret;\r\nstruct lpddr_private *lpddr = map->fldrv_priv;\r\nint chipnum = adr >> lpddr->chipshift;\r\nstruct flchip *chip = &lpddr->chips[chipnum];\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, FL_WRITING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nsend_pfow_command(map, LPDDR_WORD_PROGRAM, adr, 0x00, (map_word *)&curval);\r\nret = wait_for_ready(map, chip, (1<<lpddr->qinfo->SingleWordProgTime));\r\nif (ret) {\r\nprintk(KERN_WARNING"%s word_program error at: %llx; val: %x\n",\r\nmap->name, adr, curval);\r\ngoto out;\r\n}\r\nout: put_chip(map, chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}
