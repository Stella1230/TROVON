static int __init load_ramdisk(char *str)\r\n{\r\nrd_doload = simple_strtol(str,NULL,0) & 3;\r\nreturn 1;\r\n}\r\nstatic int __init readonly(char *str)\r\n{\r\nif (*str)\r\nreturn 0;\r\nroot_mountflags |= MS_RDONLY;\r\nreturn 1;\r\n}\r\nstatic int __init readwrite(char *str)\r\n{\r\nif (*str)\r\nreturn 0;\r\nroot_mountflags &= ~MS_RDONLY;\r\nreturn 1;\r\n}\r\nstatic int match_dev_by_uuid(struct device *dev, void *data)\r\n{\r\nu8 *uuid = data;\r\nstruct hd_struct *part = dev_to_part(dev);\r\nif (!part->info)\r\ngoto no_match;\r\nif (memcmp(uuid, part->info->uuid, sizeof(part->info->uuid)))\r\ngoto no_match;\r\nreturn 1;\r\nno_match:\r\nreturn 0;\r\n}\r\nstatic dev_t devt_from_partuuid(char *uuid_str)\r\n{\r\ndev_t res = 0;\r\nstruct device *dev = NULL;\r\nu8 uuid[16];\r\npart_pack_uuid(uuid_str, uuid);\r\ndev = class_find_device(&block_class, NULL, uuid, &match_dev_by_uuid);\r\nif (!dev)\r\ngoto done;\r\nres = dev->devt;\r\nput_device(dev);\r\ndone:\r\nreturn res;\r\n}\r\ndev_t name_to_dev_t(char *name)\r\n{\r\nchar s[32];\r\nchar *p;\r\ndev_t res = 0;\r\nint part;\r\n#ifdef CONFIG_BLOCK\r\nif (strncmp(name, "PARTUUID=", 9) == 0) {\r\nname += 9;\r\nif (strlen(name) != 36)\r\ngoto fail;\r\nres = devt_from_partuuid(name);\r\nif (!res)\r\ngoto fail;\r\ngoto done;\r\n}\r\n#endif\r\nif (strncmp(name, "/dev/", 5) != 0) {\r\nunsigned maj, min;\r\nif (sscanf(name, "%u:%u", &maj, &min) == 2) {\r\nres = MKDEV(maj, min);\r\nif (maj != MAJOR(res) || min != MINOR(res))\r\ngoto fail;\r\n} else {\r\nres = new_decode_dev(simple_strtoul(name, &p, 16));\r\nif (*p)\r\ngoto fail;\r\n}\r\ngoto done;\r\n}\r\nname += 5;\r\nres = Root_NFS;\r\nif (strcmp(name, "nfs") == 0)\r\ngoto done;\r\nres = Root_RAM0;\r\nif (strcmp(name, "ram") == 0)\r\ngoto done;\r\nif (strlen(name) > 31)\r\ngoto fail;\r\nstrcpy(s, name);\r\nfor (p = s; *p; p++)\r\nif (*p == '/')\r\n*p = '!';\r\nres = blk_lookup_devt(s, 0);\r\nif (res)\r\ngoto done;\r\nwhile (p > s && isdigit(p[-1]))\r\np--;\r\nif (p == s || !*p || *p == '0')\r\ngoto fail;\r\npart = simple_strtoul(p, NULL, 10);\r\n*p = '\0';\r\nres = blk_lookup_devt(s, part);\r\nif (res)\r\ngoto done;\r\nif (p < s + 2 || !isdigit(p[-2]) || p[-1] != 'p')\r\ngoto fail;\r\np[-1] = '\0';\r\nres = blk_lookup_devt(s, part);\r\nif (res)\r\ngoto done;\r\nfail:\r\nreturn 0;\r\ndone:\r\nreturn res;\r\n}\r\nstatic int __init root_dev_setup(char *line)\r\n{\r\nstrlcpy(saved_root_name, line, sizeof(saved_root_name));\r\nreturn 1;\r\n}\r\nstatic int __init rootwait_setup(char *str)\r\n{\r\nif (*str)\r\nreturn 0;\r\nroot_wait = 1;\r\nreturn 1;\r\n}\r\nstatic int __init root_data_setup(char *str)\r\n{\r\nroot_mount_data = str;\r\nreturn 1;\r\n}\r\nstatic int __init fs_names_setup(char *str)\r\n{\r\nroot_fs_names = str;\r\nreturn 1;\r\n}\r\nstatic int __init root_delay_setup(char *str)\r\n{\r\nroot_delay = simple_strtoul(str, NULL, 0);\r\nreturn 1;\r\n}\r\nstatic void __init get_fs_names(char *page)\r\n{\r\nchar *s = page;\r\nif (root_fs_names) {\r\nstrcpy(page, root_fs_names);\r\nwhile (*s++) {\r\nif (s[-1] == ',')\r\ns[-1] = '\0';\r\n}\r\n} else {\r\nint len = get_filesystem_list(page);\r\nchar *p, *next;\r\npage[len] = '\0';\r\nfor (p = page-1; p; p = next) {\r\nnext = strchr(++p, '\n');\r\nif (*p++ != '\t')\r\ncontinue;\r\nwhile ((*s++ = *p++) != '\n')\r\n;\r\ns[-1] = '\0';\r\n}\r\n}\r\n*s = '\0';\r\n}\r\nstatic int __init do_mount_root(char *name, char *fs, int flags, void *data)\r\n{\r\nint err = sys_mount(name, "/root", fs, flags, data);\r\nif (err)\r\nreturn err;\r\nsys_chdir((const char __user __force *)"/root");\r\nROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;\r\nprintk(KERN_INFO\r\n"VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",\r\ncurrent->fs->pwd.mnt->mnt_sb->s_type->name,\r\ncurrent->fs->pwd.mnt->mnt_sb->s_flags & MS_RDONLY ?\r\n" readonly" : "", MAJOR(ROOT_DEV), MINOR(ROOT_DEV));\r\nreturn 0;\r\n}\r\nvoid __init mount_block_root(char *name, int flags)\r\n{\r\nchar *fs_names = __getname_gfp(GFP_KERNEL\r\n| __GFP_NOTRACK_FALSE_POSITIVE);\r\nchar *p;\r\n#ifdef CONFIG_BLOCK\r\nchar b[BDEVNAME_SIZE];\r\n#else\r\nconst char *b = name;\r\n#endif\r\nget_fs_names(fs_names);\r\nretry:\r\nfor (p = fs_names; *p; p += strlen(p)+1) {\r\nint err = do_mount_root(name, p, flags, root_mount_data);\r\nswitch (err) {\r\ncase 0:\r\ngoto out;\r\ncase -EACCES:\r\nflags |= MS_RDONLY;\r\ngoto retry;\r\ncase -EINVAL:\r\ncontinue;\r\n}\r\n#ifdef CONFIG_BLOCK\r\n__bdevname(ROOT_DEV, b);\r\n#endif\r\nprintk("VFS: Cannot open root device \"%s\" or %s\n",\r\nroot_device_name, b);\r\nprintk("Please append a correct \"root=\" boot option; here are the available partitions:\n");\r\nprintk_all_partitions();\r\n#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT\r\nprintk("DEBUG_BLOCK_EXT_DEVT is enabled, you need to specify "\r\n"explicit textual name for \"root=\" boot option.\n");\r\n#endif\r\npanic("VFS: Unable to mount root fs on %s", b);\r\n}\r\nprintk("List of all partitions:\n");\r\nprintk_all_partitions();\r\nprintk("No filesystem could mount root, tried: ");\r\nfor (p = fs_names; *p; p += strlen(p)+1)\r\nprintk(" %s", p);\r\nprintk("\n");\r\n#ifdef CONFIG_BLOCK\r\n__bdevname(ROOT_DEV, b);\r\n#endif\r\npanic("VFS: Unable to mount root fs on %s", b);\r\nout:\r\nputname(fs_names);\r\n}\r\nstatic int __init mount_nfs_root(void)\r\n{\r\nchar *root_dev, *root_data;\r\nif (nfs_root_data(&root_dev, &root_data) != 0)\r\nreturn 0;\r\nif (do_mount_root(root_dev, "nfs", root_mountflags, root_data) != 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid __init change_floppy(char *fmt, ...)\r\n{\r\nstruct termios termios;\r\nchar buf[80];\r\nchar c;\r\nint fd;\r\nva_list args;\r\nva_start(args, fmt);\r\nvsprintf(buf, fmt, args);\r\nva_end(args);\r\nfd = sys_open("/dev/root", O_RDWR | O_NDELAY, 0);\r\nif (fd >= 0) {\r\nsys_ioctl(fd, FDEJECT, 0);\r\nsys_close(fd);\r\n}\r\nprintk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);\r\nfd = sys_open("/dev/console", O_RDWR, 0);\r\nif (fd >= 0) {\r\nsys_ioctl(fd, TCGETS, (long)&termios);\r\ntermios.c_lflag &= ~ICANON;\r\nsys_ioctl(fd, TCSETSF, (long)&termios);\r\nsys_read(fd, &c, 1);\r\ntermios.c_lflag |= ICANON;\r\nsys_ioctl(fd, TCSETSF, (long)&termios);\r\nsys_close(fd);\r\n}\r\n}\r\nvoid __init mount_root(void)\r\n{\r\n#ifdef CONFIG_ROOT_NFS\r\nif (MAJOR(ROOT_DEV) == UNNAMED_MAJOR) {\r\nif (mount_nfs_root())\r\nreturn;\r\nprintk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");\r\nROOT_DEV = Root_FD0;\r\n}\r\n#endif\r\n#ifdef CONFIG_BLK_DEV_FD\r\nif (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {\r\nif (rd_doload==2) {\r\nif (rd_load_disk(1)) {\r\nROOT_DEV = Root_RAM1;\r\nroot_device_name = NULL;\r\n}\r\n} else\r\nchange_floppy("root floppy");\r\n}\r\n#endif\r\n#ifdef CONFIG_BLOCK\r\ncreate_dev("/dev/root", ROOT_DEV);\r\nmount_block_root("/dev/root", root_mountflags);\r\n#endif\r\n}\r\nvoid __init prepare_namespace(void)\r\n{\r\nint is_floppy;\r\nif (root_delay) {\r\nprintk(KERN_INFO "Waiting %dsec before mounting root device...\n",\r\nroot_delay);\r\nssleep(root_delay);\r\n}\r\nwait_for_device_probe();\r\nmd_run_setup();\r\nif (saved_root_name[0]) {\r\nroot_device_name = saved_root_name;\r\nif (!strncmp(root_device_name, "mtd", 3) ||\r\n!strncmp(root_device_name, "ubi", 3)) {\r\nmount_block_root(root_device_name, root_mountflags);\r\ngoto out;\r\n}\r\nROOT_DEV = name_to_dev_t(root_device_name);\r\nif (strncmp(root_device_name, "/dev/", 5) == 0)\r\nroot_device_name += 5;\r\n}\r\nif (initrd_load())\r\ngoto out;\r\nif ((ROOT_DEV == 0) && root_wait) {\r\nprintk(KERN_INFO "Waiting for root device %s...\n",\r\nsaved_root_name);\r\nwhile (driver_probe_done() != 0 ||\r\n(ROOT_DEV = name_to_dev_t(saved_root_name)) == 0)\r\nmsleep(100);\r\nasync_synchronize_full();\r\n}\r\nis_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR;\r\nif (is_floppy && rd_doload && rd_load_disk(0))\r\nROOT_DEV = Root_RAM0;\r\nmount_root();\r\nout:\r\ndevtmpfs_mount("dev");\r\nsys_mount(".", "/", NULL, MS_MOVE, NULL);\r\nsys_chroot((const char __user __force *)".");\r\n}
