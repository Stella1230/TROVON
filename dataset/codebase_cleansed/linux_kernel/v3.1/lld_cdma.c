u16 CDMA_Data_CMD(u8 cmd, u8 *data, u32 block, u16 page, u16 num, u16 flags)\r\n{\r\nu8 bank;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (0 == cmd)\r\nnand_dbg_print(NAND_DBG_DEBUG,\r\n"%s, Line %d, Illegal cmd (0)\n", __FILE__, __LINE__);\r\nbank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nif (bank != info.flash_bank) {\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"Will access new bank. old bank: %d, new bank: %d\n",\r\ninfo.flash_bank, bank);\r\nif (CDMA_Execute_CMDs()) {\r\nprintk(KERN_ERR "CDMA_Execute_CMDs fail!\n");\r\nreturn FAIL;\r\n}\r\ninfo.flash_bank = bank;\r\n}\r\ninfo.pcmds[info.pcmds_num].CMD = cmd;\r\ninfo.pcmds[info.pcmds_num].DataAddr = data;\r\ninfo.pcmds[info.pcmds_num].Block = block;\r\ninfo.pcmds[info.pcmds_num].Page = page;\r\ninfo.pcmds[info.pcmds_num].PageCount = num;\r\ninfo.pcmds[info.pcmds_num].DataDestAddr = 0;\r\ninfo.pcmds[info.pcmds_num].DataSrcAddr = 0;\r\ninfo.pcmds[info.pcmds_num].MemCopyByteCnt = 0;\r\ninfo.pcmds[info.pcmds_num].Flags = flags;\r\ninfo.pcmds[info.pcmds_num].Status = 0xB0B;\r\nswitch (cmd) {\r\ncase WRITE_MAIN_SPARE_CMD:\r\nConv_Main_Spare_Data_Log2Phy_Format(data, num);\r\nbreak;\r\ncase WRITE_SPARE_CMD:\r\nConv_Spare_Data_Log2Phy_Format(data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ninfo.pcmds_num++;\r\nif (info.pcmds_num >= MAX_PENDING_CMDS) {\r\nif (CDMA_Execute_CMDs()) {\r\nprintk(KERN_ERR "CDMA_Execute_CMDs fail!\n");\r\nreturn FAIL;\r\n}\r\n}\r\nreturn PASS;\r\n}\r\nu16 CDMA_MemCopy_CMD(u8 *dest, u8 *src, u32 byte_cnt, u16 flags)\r\n{\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\ninfo.pcmds[info.pcmds_num].CMD = MEMCOPY_CMD;\r\ninfo.pcmds[info.pcmds_num].DataAddr = 0;\r\ninfo.pcmds[info.pcmds_num].Block = 0;\r\ninfo.pcmds[info.pcmds_num].Page = 0;\r\ninfo.pcmds[info.pcmds_num].PageCount = 0;\r\ninfo.pcmds[info.pcmds_num].DataDestAddr = dest;\r\ninfo.pcmds[info.pcmds_num].DataSrcAddr = src;\r\ninfo.pcmds[info.pcmds_num].MemCopyByteCnt = byte_cnt;\r\ninfo.pcmds[info.pcmds_num].Flags = flags;\r\ninfo.pcmds[info.pcmds_num].Status = 0xB0B;\r\ninfo.pcmds_num++;\r\nif (info.pcmds_num >= MAX_PENDING_CMDS) {\r\nif (CDMA_Execute_CMDs()) {\r\nprintk(KERN_ERR "CDMA_Execute_CMDs fail!\n");\r\nreturn FAIL;\r\n}\r\n}\r\nreturn PASS;\r\n}\r\nstatic void reset_cdma_desc(int i)\r\n{\r\nstruct cdma_descriptor *ptr;\r\nBUG_ON(i >= MAX_DESCS);\r\nptr = (struct cdma_descriptor *)info.cdma_desc_buf;\r\nptr[i].NxtPointerHi = 0;\r\nptr[i].NxtPointerLo = 0;\r\nptr[i].FlashPointerHi = 0;\r\nptr[i].FlashPointerLo = 0;\r\nptr[i].CommandType = 0;\r\nptr[i].MemAddrHi = 0;\r\nptr[i].MemAddrLo = 0;\r\nptr[i].CommandFlags = 0;\r\nptr[i].Channel = 0;\r\nptr[i].Status = 0;\r\nptr[i].MemCopyPointerHi = 0;\r\nptr[i].MemCopyPointerLo = 0;\r\n}\r\nvoid CDMA_UpdateEventStatus(void)\r\n{\r\nint i, j, active_chan;\r\nstruct cdma_descriptor *ptr;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nptr = (struct cdma_descriptor *)info.cdma_desc_buf;\r\nfor (j = 0; j < info.cdma_num; j++) {\r\nif ((ptr[j].Status & CMD_DMA_DESC_FAIL))\r\nbreak;\r\n}\r\nfor (i = 0; i < j; i++) {\r\nif (ptr[i].pcmd != 0xff)\r\ninfo.pcmds[ptr[i].pcmd].Status = CMD_PASS;\r\n}\r\nactive_chan = ioread32(FlashReg + CHNL_ACTIVE);\r\nif ((active_chan & (1 << info.flash_bank)) == (1 << info.flash_bank)) {\r\niowrite32(MODE_02 | (0 << 4), FlashMem);\r\niowrite32((0xF << 4) | info.flash_bank, FlashMem + 0x10);\r\n} else {\r\nprintk(KERN_ERR "Error! Used bank is not set in"\r\n" reg CHNL_ACTIVE\n");\r\n}\r\n}\r\nstatic void cdma_trans(u16 chan)\r\n{\r\nu32 addr;\r\naddr = info.cdma_desc;\r\niowrite32(MODE_10 | (chan << 24), FlashMem);\r\niowrite32((1 << 7) | chan, FlashMem + 0x10);\r\niowrite32(MODE_10 | (chan << 24) | ((0x0FFFF & (addr >> 16)) << 8),\r\nFlashMem);\r\niowrite32((1 << 7) | (1 << 4) | 0, FlashMem + 0x10);\r\niowrite32(MODE_10 | (chan << 24) | ((0x0FFFF & addr) << 8), FlashMem);\r\niowrite32((1 << 7) | (1 << 5) | 0, FlashMem + 0x10);\r\niowrite32(MODE_10 | (chan << 24), FlashMem);\r\niowrite32((1 << 7) | (1 << 5) | (1 << 4) | 0, FlashMem + 0x10);\r\n}\r\nu16 CDMA_Execute_CMDs(void)\r\n{\r\nint i, ret;\r\nu64 flash_add;\r\nu32 ptr;\r\ndma_addr_t map_addr, next_ptr;\r\nu16 status = PASS;\r\nu16 tmp_c;\r\nstruct cdma_descriptor *pc;\r\nstruct memcpy_descriptor *pm;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (0 == info.pcmds_num) {\r\nnand_dbg_print(NAND_DBG_TRACE,\r\n"No pending cmds to execute. Just exit.\n");\r\nreturn PASS;\r\n}\r\nfor (i = 0; i < MAX_DESCS; i++)\r\nreset_cdma_desc(i);\r\npc = (struct cdma_descriptor *)info.cdma_desc_buf;\r\npm = (struct memcpy_descriptor *)info.memcp_desc_buf;\r\ninfo.cdma_desc = virt_to_bus(info.cdma_desc_buf);\r\ninfo.memcp_desc = virt_to_bus(info.memcp_desc_buf);\r\nnext_ptr = info.cdma_desc;\r\ninfo.cdma_num = 0;\r\nfor (i = 0; i < info.pcmds_num; i++) {\r\nif (info.pcmds[i].Block >= DeviceInfo.wTotalBlocks) {\r\ninfo.pcmds[i].Status = CMD_NOT_DONE;\r\ncontinue;\r\n}\r\nnext_ptr += sizeof(struct cdma_descriptor);\r\npc[info.cdma_num].NxtPointerHi = next_ptr >> 16;\r\npc[info.cdma_num].NxtPointerLo = next_ptr & 0xffff;\r\ntmp_c = info.pcmds[i].Block /\r\n(DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nflash_add = (u64)(info.pcmds[i].Block - tmp_c *\r\n(DeviceInfo.wTotalBlocks / totalUsedBanks)) *\r\nDeviceInfo.wBlockDataSize +\r\n(u64)(info.pcmds[i].Page) *\r\nDeviceInfo.wPageDataSize;\r\nptr = MODE_10 | (info.flash_bank << 24) |\r\n(u32)GLOB_u64_Div(flash_add,\r\nDeviceInfo.wPageDataSize);\r\npc[info.cdma_num].FlashPointerHi = ptr >> 16;\r\npc[info.cdma_num].FlashPointerLo = ptr & 0xffff;\r\nif ((info.pcmds[i].CMD == WRITE_MAIN_SPARE_CMD) ||\r\n(info.pcmds[i].CMD == READ_MAIN_SPARE_CMD)) {\r\npc[info.cdma_num].CommandType = 0x43;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (1 << 9) | (0 << 8) | 0x40;\r\npc[info.cdma_num].MemAddrHi = 0;\r\npc[info.cdma_num].MemAddrLo = 0;\r\npc[info.cdma_num].Channel = 0;\r\npc[info.cdma_num].Status = 0;\r\npc[info.cdma_num].pcmd = i;\r\ninfo.cdma_num++;\r\nBUG_ON(info.cdma_num >= MAX_DESCS);\r\nreset_cdma_desc(info.cdma_num);\r\nnext_ptr += sizeof(struct cdma_descriptor);\r\npc[info.cdma_num].NxtPointerHi = next_ptr >> 16;\r\npc[info.cdma_num].NxtPointerLo = next_ptr & 0xffff;\r\npc[info.cdma_num].FlashPointerHi = ptr >> 16;\r\npc[info.cdma_num].FlashPointerLo = ptr & 0xffff;\r\n}\r\nswitch (info.pcmds[i].CMD) {\r\ncase ERASE_CMD:\r\npc[info.cdma_num].CommandType = 1;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (1 << 9) | (0 << 8) | 0x40;\r\npc[info.cdma_num].MemAddrHi = 0;\r\npc[info.cdma_num].MemAddrLo = 0;\r\nbreak;\r\ncase WRITE_MAIN_CMD:\r\npc[info.cdma_num].CommandType =\r\n0x2100 | info.pcmds[i].PageCount;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (1 << 9) | (0 << 8) | 0x40;\r\nmap_addr = virt_to_bus(info.pcmds[i].DataAddr);\r\npc[info.cdma_num].MemAddrHi = map_addr >> 16;\r\npc[info.cdma_num].MemAddrLo = map_addr & 0xffff;\r\nbreak;\r\ncase READ_MAIN_CMD:\r\npc[info.cdma_num].CommandType =\r\n0x2000 | info.pcmds[i].PageCount;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (1 << 9) | (0 << 8) | 0x40;\r\nmap_addr = virt_to_bus(info.pcmds[i].DataAddr);\r\npc[info.cdma_num].MemAddrHi = map_addr >> 16;\r\npc[info.cdma_num].MemAddrLo = map_addr & 0xffff;\r\nbreak;\r\ncase WRITE_MAIN_SPARE_CMD:\r\npc[info.cdma_num].CommandType =\r\n0x2100 | info.pcmds[i].PageCount;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (1 << 9) | (0 << 8) | 0x40;\r\nmap_addr = virt_to_bus(info.pcmds[i].DataAddr);\r\npc[info.cdma_num].MemAddrHi = map_addr >> 16;\r\npc[info.cdma_num].MemAddrLo = map_addr & 0xffff;\r\nbreak;\r\ncase READ_MAIN_SPARE_CMD:\r\npc[info.cdma_num].CommandType =\r\n0x2000 | info.pcmds[i].PageCount;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (1 << 9) | (0 << 8) | 0x40;\r\nmap_addr = virt_to_bus(info.pcmds[i].DataAddr);\r\npc[info.cdma_num].MemAddrHi = map_addr >> 16;\r\npc[info.cdma_num].MemAddrLo = map_addr & 0xffff;\r\nbreak;\r\ncase MEMCOPY_CMD:\r\npc[info.cdma_num].CommandType = 0xFFFF;\r\npc[info.cdma_num].CommandFlags = 0x0E40;\r\nmap_addr = info.memcp_desc + info.cdma_num *\r\nsizeof(struct memcpy_descriptor);\r\npc[info.cdma_num].MemCopyPointerHi = map_addr >> 16;\r\npc[info.cdma_num].MemCopyPointerLo = map_addr & 0xffff;\r\npm[info.cdma_num].NxtPointerHi = 0;\r\npm[info.cdma_num].NxtPointerLo = 0;\r\nmap_addr = virt_to_bus(info.pcmds[i].DataSrcAddr);\r\npm[info.cdma_num].SrcAddrHi = map_addr >> 16;\r\npm[info.cdma_num].SrcAddrLo = map_addr & 0xffff;\r\nmap_addr = virt_to_bus(info.pcmds[i].DataDestAddr);\r\npm[info.cdma_num].DestAddrHi = map_addr >> 16;\r\npm[info.cdma_num].DestAddrLo = map_addr & 0xffff;\r\npm[info.cdma_num].XferSize =\r\ninfo.pcmds[i].MemCopyByteCnt;\r\npm[info.cdma_num].MemCopyFlags =\r\n(0 << 15 | 0 << 14 | 27 << 8 | 0x40);\r\npm[info.cdma_num].MemCopyStatus = 0;\r\nbreak;\r\ncase DUMMY_CMD:\r\ndefault:\r\npc[info.cdma_num].CommandType = 0XFFFF;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (1 << 9) | (0 << 8) | 0x40;\r\npc[info.cdma_num].MemAddrHi = 0;\r\npc[info.cdma_num].MemAddrLo = 0;\r\nbreak;\r\n}\r\npc[info.cdma_num].Channel = 0;\r\npc[info.cdma_num].Status = 0;\r\npc[info.cdma_num].pcmd = i;\r\ninfo.cdma_num++;\r\nBUG_ON(info.cdma_num >= MAX_DESCS);\r\nif ((info.pcmds[i].CMD == WRITE_MAIN_SPARE_CMD) ||\r\n(info.pcmds[i].CMD == READ_MAIN_SPARE_CMD)) {\r\nreset_cdma_desc(info.cdma_num);\r\nnext_ptr += sizeof(struct cdma_descriptor);\r\npc[info.cdma_num].NxtPointerHi = next_ptr >> 16;\r\npc[info.cdma_num].NxtPointerLo = next_ptr & 0xffff;\r\npc[info.cdma_num].FlashPointerHi = ptr >> 16;\r\npc[info.cdma_num].FlashPointerLo = ptr & 0xffff;\r\npc[info.cdma_num].CommandType = 0x42;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (1 << 9) | (0 << 8) | 0x40;\r\npc[info.cdma_num].MemAddrHi = 0;\r\npc[info.cdma_num].MemAddrLo = 0;\r\npc[info.cdma_num].Channel = 0;\r\npc[info.cdma_num].Status = 0;\r\npc[info.cdma_num].pcmd = i;\r\ninfo.cdma_num++;\r\nBUG_ON(info.cdma_num >= MAX_DESCS);\r\n}\r\n}\r\nreset_cdma_desc(info.cdma_num);\r\nptr = MODE_10 | (info.flash_bank << 24);\r\npc[info.cdma_num].FlashPointerHi = ptr >> 16;\r\npc[info.cdma_num].FlashPointerLo = ptr & 0xffff;\r\npc[info.cdma_num].CommandType = 0xFFFF;\r\npc[info.cdma_num].CommandFlags =\r\n(0 << 10) | (0 << 9) | (1 << 8) | 0x40;\r\npc[info.cdma_num].pcmd = 0xff;\r\ninfo.cdma_num++;\r\nBUG_ON(info.cdma_num >= MAX_DESCS);\r\niowrite32(1, FlashReg + GLOBAL_INT_ENABLE);\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\ncdma_trans(info.flash_bank);\r\nret = wait_for_completion_timeout(&info.complete, 50 * HZ);\r\nif (!ret)\r\nprintk(KERN_ERR "Wait for completion timeout "\r\n"in %s, Line %d\n", __FILE__, __LINE__);\r\nstatus = info.ret;\r\ninfo.pcmds_num = 0;\r\nreturn status;\r\n}\r\nint is_cdma_interrupt(void)\r\n{\r\nu32 ints_b0, ints_b1, ints_b2, ints_b3, ints_cdma;\r\nu32 int_en_mask;\r\nu32 cdma_int_en_mask;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\ncdma_int_en_mask = (DMA_INTR__DESC_COMP_CHANNEL0 |\r\nDMA_INTR__DESC_COMP_CHANNEL1 |\r\nDMA_INTR__DESC_COMP_CHANNEL2 |\r\nDMA_INTR__DESC_COMP_CHANNEL3 |\r\nDMA_INTR__MEMCOPY_DESC_COMP);\r\nint_en_mask = (INTR_STATUS0__ECC_ERR |\r\nINTR_STATUS0__PROGRAM_FAIL |\r\nINTR_STATUS0__ERASE_FAIL);\r\nints_b0 = ioread32(FlashReg + INTR_STATUS0) & int_en_mask;\r\nints_b1 = ioread32(FlashReg + INTR_STATUS1) & int_en_mask;\r\nints_b2 = ioread32(FlashReg + INTR_STATUS2) & int_en_mask;\r\nints_b3 = ioread32(FlashReg + INTR_STATUS3) & int_en_mask;\r\nints_cdma = ioread32(FlashReg + DMA_INTR) & cdma_int_en_mask;\r\nnand_dbg_print(NAND_DBG_WARN, "ints_bank0 to ints_bank3: "\r\n"0x%x, 0x%x, 0x%x, 0x%x, ints_cdma: 0x%x\n",\r\nints_b0, ints_b1, ints_b2, ints_b3, ints_cdma);\r\nif (ints_b0 || ints_b1 || ints_b2 || ints_b3 || ints_cdma) {\r\nreturn 1;\r\n} else {\r\niowrite32(ints_b0, FlashReg + INTR_STATUS0);\r\niowrite32(ints_b1, FlashReg + INTR_STATUS1);\r\niowrite32(ints_b2, FlashReg + INTR_STATUS2);\r\niowrite32(ints_b3, FlashReg + INTR_STATUS3);\r\nnand_dbg_print(NAND_DBG_DEBUG,\r\n"Not a NAND controller interrupt! Ignore it.\n");\r\nreturn 0;\r\n}\r\n}\r\nstatic void update_event_status(void)\r\n{\r\nint i;\r\nstruct cdma_descriptor *ptr;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nptr = (struct cdma_descriptor *)info.cdma_desc_buf;\r\nfor (i = 0; i < info.cdma_num; i++) {\r\nif (ptr[i].pcmd != 0xff)\r\ninfo.pcmds[ptr[i].pcmd].Status = CMD_PASS;\r\nif ((ptr[i].CommandType == 0x41) ||\r\n(ptr[i].CommandType == 0x42) ||\r\n(ptr[i].CommandType == 0x43))\r\ncontinue;\r\nswitch (info.pcmds[ptr[i].pcmd].CMD) {\r\ncase READ_MAIN_SPARE_CMD:\r\nConv_Main_Spare_Data_Phy2Log_Format(\r\ninfo.pcmds[ptr[i].pcmd].DataAddr,\r\ninfo.pcmds[ptr[i].pcmd].PageCount);\r\nbreak;\r\ncase READ_SPARE_CMD:\r\nConv_Spare_Data_Phy2Log_Format(\r\ninfo.pcmds[ptr[i].pcmd].DataAddr);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic u16 do_ecc_for_desc(u32 ch, u8 *buf, u16 page)\r\n{\r\nu16 event = EVENT_NONE;\r\nu16 err_byte;\r\nu16 err_page = 0;\r\nu8 err_sector;\r\nu8 err_device;\r\nu16 ecc_correction_info;\r\nu16 err_address;\r\nu32 eccSectorSize;\r\nu8 *err_pos;\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\neccSectorSize = ECC_SECTOR_SIZE * (DeviceInfo.wDevicesConnected);\r\ndo {\r\nif (0 == ch)\r\nerr_page = ioread32(FlashReg + ERR_PAGE_ADDR0);\r\nelse if (1 == ch)\r\nerr_page = ioread32(FlashReg + ERR_PAGE_ADDR1);\r\nelse if (2 == ch)\r\nerr_page = ioread32(FlashReg + ERR_PAGE_ADDR2);\r\nelse if (3 == ch)\r\nerr_page = ioread32(FlashReg + ERR_PAGE_ADDR3);\r\nerr_address = ioread32(FlashReg + ECC_ERROR_ADDRESS);\r\nerr_byte = err_address & ECC_ERROR_ADDRESS__OFFSET;\r\nerr_sector = ((err_address &\r\nECC_ERROR_ADDRESS__SECTOR_NR) >> 12);\r\necc_correction_info = ioread32(FlashReg + ERR_CORRECTION_INFO);\r\nerr_device = ((ecc_correction_info &\r\nERR_CORRECTION_INFO__DEVICE_NR) >> 8);\r\nif (ecc_correction_info & ERR_CORRECTION_INFO__ERROR_TYPE) {\r\nevent = EVENT_UNCORRECTABLE_DATA_ERROR;\r\n} else {\r\nevent = EVENT_CORRECTABLE_DATA_ERROR_FIXED;\r\nif (err_byte < ECC_SECTOR_SIZE) {\r\nerr_pos = buf +\r\n(err_page - page) *\r\nDeviceInfo.wPageDataSize +\r\nerr_sector * eccSectorSize +\r\nerr_byte *\r\nDeviceInfo.wDevicesConnected +\r\nerr_device;\r\n*err_pos ^= ecc_correction_info &\r\nERR_CORRECTION_INFO__BYTEMASK;\r\n}\r\n}\r\n} while (!(ecc_correction_info & ERR_CORRECTION_INFO__LAST_ERR_INFO));\r\nreturn event;\r\n}\r\nstatic u16 process_ecc_int(u32 c, u16 *p_desc_num)\r\n{\r\nstruct cdma_descriptor *ptr;\r\nu16 j;\r\nint event = EVENT_PASS;\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (c != info.flash_bank)\r\nprintk(KERN_ERR "Error!info.flash_bank is %d, while c is %d\n",\r\ninfo.flash_bank, c);\r\nptr = (struct cdma_descriptor *)info.cdma_desc_buf;\r\nfor (j = 0; j < info.cdma_num; j++)\r\nif ((ptr[j].Status & CMD_DMA_DESC_COMP) != CMD_DMA_DESC_COMP)\r\nbreak;\r\n*p_desc_num = j;\r\nif (j >= info.cdma_num) {\r\nprintk(KERN_ERR "Can not find the correct descriptor number "\r\n"when ecc interrupt triggered!"\r\n"info.cdma_num: %d, j: %d\n", info.cdma_num, j);\r\nreturn EVENT_UNCORRECTABLE_DATA_ERROR;\r\n}\r\nevent = do_ecc_for_desc(c, info.pcmds[ptr[j].pcmd].DataAddr,\r\ninfo.pcmds[ptr[j].pcmd].Page);\r\nif (EVENT_UNCORRECTABLE_DATA_ERROR == event) {\r\nprintk(KERN_ERR "Uncorrectable ECC error!"\r\n"info.cdma_num: %d, j: %d, "\r\n"pending cmd CMD: 0x%x, "\r\n"Block: 0x%x, Page: 0x%x, PageCount: 0x%x\n",\r\ninfo.cdma_num, j,\r\ninfo.pcmds[ptr[j].pcmd].CMD,\r\ninfo.pcmds[ptr[j].pcmd].Block,\r\ninfo.pcmds[ptr[j].pcmd].Page,\r\ninfo.pcmds[ptr[j].pcmd].PageCount);\r\nif (ptr[j].pcmd != 0xff)\r\ninfo.pcmds[ptr[j].pcmd].Status = CMD_FAIL;\r\nCDMA_UpdateEventStatus();\r\n}\r\nreturn event;\r\n}\r\nstatic void process_prog_erase_fail_int(u16 desc_num)\r\n{\r\nstruct cdma_descriptor *ptr;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nptr = (struct cdma_descriptor *)info.cdma_desc_buf;\r\nif (ptr[desc_num].pcmd != 0xFF)\r\ninfo.pcmds[ptr[desc_num].pcmd].Status = CMD_FAIL;\r\nCDMA_UpdateEventStatus();\r\n}\r\nu16 CDMA_Event_Status(void)\r\n{\r\nu32 ints_addr[4] = {INTR_STATUS0, INTR_STATUS1,\r\nINTR_STATUS2, INTR_STATUS3};\r\nu32 dma_intr_bit[4] = {DMA_INTR__DESC_COMP_CHANNEL0,\r\nDMA_INTR__DESC_COMP_CHANNEL1,\r\nDMA_INTR__DESC_COMP_CHANNEL2,\r\nDMA_INTR__DESC_COMP_CHANNEL3};\r\nu32 cdma_int_status, int_status;\r\nu32 ecc_enable = 0;\r\nu16 event = EVENT_PASS;\r\nu16 cur_desc = 0;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\necc_enable = ioread32(FlashReg + ECC_ENABLE);\r\nwhile (1) {\r\nint_status = ioread32(FlashReg + ints_addr[info.flash_bank]);\r\nif (ecc_enable && (int_status & INTR_STATUS0__ECC_ERR)) {\r\nevent = process_ecc_int(info.flash_bank, &cur_desc);\r\niowrite32(INTR_STATUS0__ECC_ERR,\r\nFlashReg + ints_addr[info.flash_bank]);\r\nif (EVENT_UNCORRECTABLE_DATA_ERROR == event) {\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"ints_bank0 to ints_bank3: "\r\n"0x%x, 0x%x, 0x%x, 0x%x, "\r\n"ints_cdma: 0x%x\n",\r\nioread32(FlashReg + INTR_STATUS0),\r\nioread32(FlashReg + INTR_STATUS1),\r\nioread32(FlashReg + INTR_STATUS2),\r\nioread32(FlashReg + INTR_STATUS3),\r\nioread32(FlashReg + DMA_INTR));\r\nbreak;\r\n}\r\n} else if (int_status & INTR_STATUS0__PROGRAM_FAIL) {\r\nprintk(KERN_ERR "NAND program fail interrupt!\n");\r\nprocess_prog_erase_fail_int(cur_desc);\r\nevent = EVENT_PROGRAM_FAILURE;\r\nbreak;\r\n} else if (int_status & INTR_STATUS0__ERASE_FAIL) {\r\nprintk(KERN_ERR "NAND erase fail interrupt!\n");\r\nprocess_prog_erase_fail_int(cur_desc);\r\nevent = EVENT_ERASE_FAILURE;\r\nbreak;\r\n} else {\r\ncdma_int_status = ioread32(FlashReg + DMA_INTR);\r\nif (cdma_int_status & dma_intr_bit[info.flash_bank]) {\r\niowrite32(dma_intr_bit[info.flash_bank],\r\nFlashReg + DMA_INTR);\r\nupdate_event_status();\r\nevent = EVENT_PASS;\r\nbreak;\r\n}\r\n}\r\n}\r\nint_status = ioread32(FlashReg + ints_addr[info.flash_bank]);\r\niowrite32(int_status, FlashReg + ints_addr[info.flash_bank]);\r\ncdma_int_status = ioread32(FlashReg + DMA_INTR);\r\niowrite32(cdma_int_status, FlashReg + DMA_INTR);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile ((ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\nreturn event;\r\n}
