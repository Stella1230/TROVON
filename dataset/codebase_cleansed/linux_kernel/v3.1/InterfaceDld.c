int InterfaceFileDownload( PVOID arg,\r\nstruct file *flp,\r\nunsigned int on_chip_loc)\r\n{\r\nmm_segment_t oldfs={0};\r\nint errno=0, len=0 ;\r\nloff_t pos=0;\r\nPS_INTERFACE_ADAPTER psIntfAdapter = (PS_INTERFACE_ADAPTER)arg;\r\nchar *buff=kmalloc(MAX_TRANSFER_CTRL_BYTE_USB, GFP_KERNEL);\r\nif(!buff)\r\n{\r\nreturn -ENOMEM;\r\n}\r\nwhile(1)\r\n{\r\noldfs=get_fs(); set_fs(get_ds());\r\nlen=vfs_read(flp, (void __force __user *)buff, MAX_TRANSFER_CTRL_BYTE_USB, &pos);\r\nset_fs(oldfs);\r\nif(len<=0)\r\n{\r\nif(len<0)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "len < 0");\r\nerrno=len;\r\n}\r\nelse\r\n{\r\nerrno = 0;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Got end of file!");\r\n}\r\nbreak;\r\n}\r\nerrno = InterfaceWRM(psIntfAdapter, on_chip_loc, buff, len) ;\r\nif(errno)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_PRINTK, 0, 0, "WRM Failed! status: %d", errno);\r\nbreak;\r\n}\r\non_chip_loc+=MAX_TRANSFER_CTRL_BYTE_USB;\r\n}\r\nkfree(buff);\r\nreturn errno;\r\n}\r\nint InterfaceFileReadbackFromChip( PVOID arg,\r\nstruct file *flp,\r\nunsigned int on_chip_loc)\r\n{\r\nchar *buff, *buff_readback;\r\nunsigned int reg=0;\r\nmm_segment_t oldfs={0};\r\nint errno=0, len=0, is_config_file = 0;\r\nloff_t pos=0;\r\nstatic int fw_down = 0;\r\nINT Status = STATUS_SUCCESS;\r\nPS_INTERFACE_ADAPTER psIntfAdapter = (PS_INTERFACE_ADAPTER)arg;\r\nbuff=kmalloc(MAX_TRANSFER_CTRL_BYTE_USB, GFP_DMA);\r\nbuff_readback=kmalloc(MAX_TRANSFER_CTRL_BYTE_USB , GFP_DMA);\r\nif(!buff || !buff_readback)\r\n{\r\nkfree(buff);\r\nkfree(buff_readback);\r\nreturn -ENOMEM;\r\n}\r\nis_config_file = (on_chip_loc == CONFIG_BEGIN_ADDR)? 1:0;\r\nmemset(buff_readback, 0, MAX_TRANSFER_CTRL_BYTE_USB);\r\nmemset(buff, 0, MAX_TRANSFER_CTRL_BYTE_USB);\r\nwhile(1)\r\n{\r\noldfs=get_fs(); set_fs(get_ds());\r\nlen=vfs_read(flp, (void __force __user *)buff, MAX_TRANSFER_CTRL_BYTE_USB, &pos);\r\nset_fs(oldfs);\r\nfw_down++;\r\nif(len<=0)\r\n{\r\nif(len<0)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "len < 0");\r\nerrno=len;\r\n}\r\nelse\r\n{\r\nerrno = 0;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Got end of file!");\r\n}\r\nbreak;\r\n}\r\nStatus = InterfaceRDM(psIntfAdapter, on_chip_loc, buff_readback, len);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "RDM of len %d Failed! %d", len, reg);\r\ngoto exit;\r\n}\r\nreg++;\r\nif((len-sizeof(unsigned int))<4)\r\n{\r\nif(memcmp(buff_readback, buff, len))\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Firmware Download is not proper %d", fw_down);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT,DBG_LVL_ALL,"Length is: %d",len);\r\nStatus = -EIO;\r\ngoto exit;\r\n}\r\n}\r\nelse\r\n{\r\nlen-=4;\r\nwhile(len)\r\n{\r\nif(*(unsigned int*)&buff_readback[len] != *(unsigned int *)&buff[len])\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Firmware Download is not proper %d", fw_down);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Val from Binary %x, Val From Read Back %x ", *(unsigned int *)&buff[len], *(unsigned int*)&buff_readback[len]);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "len =%x!!!", len);\r\nStatus = -EIO;\r\ngoto exit;\r\n}\r\nlen-=4;\r\n}\r\n}\r\non_chip_loc+=MAX_TRANSFER_CTRL_BYTE_USB;\r\n}\r\nexit:\r\nkfree(buff);\r\nkfree(buff_readback);\r\nreturn Status;\r\n}\r\nstatic int bcm_download_config_file(PMINI_ADAPTER Adapter,\r\nFIRMWARE_INFO *psFwInfo)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nB_UINT32 value = 0;\r\nif(Adapter->pstargetparams == NULL)\r\n{\r\nif((Adapter->pstargetparams =\r\nkmalloc(sizeof(STARGETPARAMS), GFP_KERNEL)) == NULL)\r\n{\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif(psFwInfo->u32FirmwareLength != sizeof(STARGETPARAMS))\r\n{\r\nreturn -EIO;\r\n}\r\nretval = copy_from_user(Adapter->pstargetparams,\r\npsFwInfo->pvMappedFirmwareAddress, psFwInfo->u32FirmwareLength);\r\nif(retval)\r\n{\r\nkfree(Adapter->pstargetparams);\r\nAdapter->pstargetparams = NULL;\r\nreturn -EFAULT;\r\n}\r\nbeceem_parse_target_struct(Adapter);\r\nBcmInitNVM(Adapter);\r\nretval = InitLedSettings (Adapter);\r\nif(retval)\r\n{\r\nBCM_DEBUG_PRINT (Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "INIT LED Failed\n");\r\nreturn retval;\r\n}\r\nif(Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY)\r\n{\r\nAdapter->LEDInfo.bLedInitDone = FALSE;\r\nAdapter->DriverState = DRIVER_INIT;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\nif(Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY)\r\n{\r\nAdapter->DriverState = FW_DOWNLOAD;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\nretval = ddr_init(Adapter);\r\nif(retval)\r\n{\r\nBCM_DEBUG_PRINT (Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "DDR Init Failed\n");\r\nreturn retval;\r\n}\r\nvalue = 0;\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC - 4, &value, sizeof(value));\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC - 8, &value, sizeof(value));\r\nif(Adapter->eNVMType == NVM_FLASH)\r\n{\r\nretval = PropagateCalParamsFromFlashToMemory(Adapter);\r\nif(retval)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL,"propagaion of cal param failed with status :%d", retval);\r\nreturn retval;\r\n}\r\n}\r\nretval =buffDnldVerify(Adapter,(PUCHAR)Adapter->pstargetparams,sizeof(STARGETPARAMS),CONFIG_BEGIN_ADDR);\r\nif(retval)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "configuration file not downloaded properly");\r\n}\r\nelse\r\nAdapter->bCfgDownloaded = TRUE;\r\nreturn retval;\r\n}\r\nstatic int bcm_compare_buff_contents(unsigned char *readbackbuff,\r\nunsigned char *buff,unsigned int len)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif((len-sizeof(unsigned int))<4)\r\n{\r\nif(memcmp(readbackbuff , buff, len))\r\n{\r\nretval=-EINVAL;\r\n}\r\n}\r\nelse\r\n{\r\nlen-=4;\r\nwhile(len)\r\n{\r\nif(*(unsigned int*)&readbackbuff[len] !=\r\n*(unsigned int *)&buff[len])\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Firmware Download is not proper");\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Val from Binary %x, Val From Read Back %x ", *(unsigned int *)&buff[len], *(unsigned int*)&readbackbuff[len]);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "len =%x!!!", len);\r\nretval=-EINVAL;\r\nbreak;\r\n}\r\nlen-=4;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nint bcm_ioctl_fw_download(PMINI_ADAPTER Adapter, FIRMWARE_INFO *psFwInfo)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nPUCHAR buff = NULL;\r\natomic_set (&Adapter->uiMBupdate, FALSE);\r\nif(!Adapter->bCfgDownloaded &&\r\npsFwInfo->u32StartingAddress != CONFIG_BEGIN_ADDR)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL,"Download the config File first\n");\r\nreturn -EINVAL;\r\n}\r\nif(psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)\r\n{\r\nretval = bcm_download_config_file (Adapter, psFwInfo);\r\n}\r\nelse\r\n{\r\nbuff = kzalloc(psFwInfo->u32FirmwareLength,GFP_KERNEL);\r\nif(buff==NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL,"Failed in allocation memory");\r\nreturn -ENOMEM;\r\n}\r\nretval = copy_from_user(buff,psFwInfo->pvMappedFirmwareAddress, psFwInfo->u32FirmwareLength);\r\nif(retval != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "copying buffer from user space failed");\r\nretval = -EFAULT;\r\ngoto error ;\r\n}\r\nretval = buffDnldVerify(Adapter,\r\nbuff,\r\npsFwInfo->u32FirmwareLength,\r\npsFwInfo->u32StartingAddress);\r\nif(retval != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL,"f/w download failed status :%d", retval);\r\ngoto error;\r\n}\r\n}\r\nerror:\r\nkfree(buff);\r\nreturn retval;\r\n}\r\nstatic INT buffDnld(PMINI_ADAPTER Adapter, PUCHAR mappedbuffer, UINT u32FirmwareLength,\r\nULONG u32StartingAddress)\r\n{\r\nunsigned int len = 0;\r\nint retval = STATUS_SUCCESS;\r\nlen = u32FirmwareLength;\r\nwhile(u32FirmwareLength)\r\n{\r\nlen = MIN_VAL (u32FirmwareLength, MAX_TRANSFER_CTRL_BYTE_USB);\r\nretval = wrm (Adapter, u32StartingAddress, mappedbuffer, len);\r\nif(retval)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "wrm failed with status :%d", retval);\r\nbreak;\r\n}\r\nu32StartingAddress += len;\r\nu32FirmwareLength -= len;\r\nmappedbuffer +=len;\r\n}\r\nreturn retval;\r\n}\r\nstatic INT buffRdbkVerify(PMINI_ADAPTER Adapter,\r\nPUCHAR mappedbuffer, UINT u32FirmwareLength,\r\nULONG u32StartingAddress)\r\n{\r\nUINT len = u32FirmwareLength;\r\nINT retval = STATUS_SUCCESS;\r\nPUCHAR readbackbuff = kzalloc(MAX_TRANSFER_CTRL_BYTE_USB,GFP_KERNEL);\r\nif(NULL == readbackbuff)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "MEMORY ALLOCATION FAILED");\r\nreturn -ENOMEM;\r\n}\r\nwhile (u32FirmwareLength && !retval)\r\n{\r\nlen = MIN_VAL (u32FirmwareLength, MAX_TRANSFER_CTRL_BYTE_USB);\r\nretval = rdm (Adapter, u32StartingAddress, readbackbuff, len);\r\nif(retval)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "rdm failed with status %d" ,retval);\r\nbreak;\r\n}\r\nif (STATUS_SUCCESS != (retval = bcm_compare_buff_contents (readbackbuff, mappedbuffer, len)))\r\n{\r\nbreak;\r\n}\r\nu32StartingAddress += len;\r\nu32FirmwareLength -= len;\r\nmappedbuffer +=len;\r\n}\r\nkfree(readbackbuff);\r\nreturn retval;\r\n}\r\nINT buffDnldVerify(PMINI_ADAPTER Adapter, unsigned char *mappedbuffer, unsigned int u32FirmwareLength,\r\nunsigned long u32StartingAddress)\r\n{\r\nINT status = STATUS_SUCCESS;\r\nstatus = buffDnld(Adapter,mappedbuffer,u32FirmwareLength,u32StartingAddress);\r\nif(status != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL,"Buffer download failed");\r\ngoto error;\r\n}\r\nstatus= buffRdbkVerify(Adapter,mappedbuffer,u32FirmwareLength,u32StartingAddress);\r\nif(status != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL,"Buffer readback verifier failed");\r\ngoto error;\r\n}\r\nerror:\r\nreturn status;\r\n}
