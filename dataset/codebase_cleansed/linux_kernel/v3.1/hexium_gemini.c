static int hexium_init_done(struct saa7146_dev *dev)\r\n{\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nunion i2c_smbus_data data;\r\nint i = 0;\r\nDEB_D(("hexium_init_done called.\n"));\r\nfor (i = 0; i < sizeof(hexium_ks0127b); i++) {\r\ndata.byte = hexium_ks0127b[i];\r\nif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, i, I2C_SMBUS_BYTE_DATA, &data)) {\r\nprintk("hexium_gemini: hexium_init_done() failed for address 0x%02x\n", i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hexium_set_input(struct hexium *hexium, int input)\r\n{\r\nunion i2c_smbus_data data;\r\nDEB_D((".\n"));\r\ndata.byte = hexium_input_select[input].byte;\r\nif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, hexium_input_select[input].adr, I2C_SMBUS_BYTE_DATA, &data)) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hexium_set_standard(struct hexium *hexium, struct hexium_data *vdec)\r\n{\r\nunion i2c_smbus_data data;\r\nint i = 0;\r\nDEB_D((".\n"));\r\nwhile (vdec[i].adr != -1) {\r\ndata.byte = vdec[i].byte;\r\nif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, vdec[i].adr, I2C_SMBUS_BYTE_DATA, &data)) {\r\nprintk("hexium_init_done: hexium_set_standard() failed for address 0x%02x\n", i);\r\nreturn -1;\r\n}\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\r\n{\r\nDEB_EE(("VIDIOC_ENUMINPUT %d.\n", i->index));\r\nif (i->index >= HEXIUM_INPUTS)\r\nreturn -EINVAL;\r\nmemcpy(i, &hexium_inputs[i->index], sizeof(struct v4l2_input));\r\nDEB_D(("v4l2_ioctl: VIDIOC_ENUMINPUT %d.\n", i->index));\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *input)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\n*input = hexium->cur_input;\r\nDEB_D(("VIDIOC_G_INPUT: %d\n", *input));\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nDEB_EE(("VIDIOC_S_INPUT %d.\n", input));\r\nif (input >= HEXIUM_INPUTS)\r\nreturn -EINVAL;\r\nhexium->cur_input = input;\r\nhexium_set_input(hexium, input);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *fh, struct v4l2_queryctrl *qc)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nint i;\r\nfor (i = HEXIUM_CONTROLS - 1; i >= 0; i--) {\r\nif (hexium_controls[i].id == qc->id) {\r\n*qc = hexium_controls[i];\r\nDEB_D(("VIDIOC_QUERYCTRL %d.\n", qc->id));\r\nreturn 0;\r\n}\r\n}\r\nreturn dev->ext_vv_data->core_ops->vidioc_queryctrl(file, fh, qc);\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *vc)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nint i;\r\nfor (i = HEXIUM_CONTROLS - 1; i >= 0; i--) {\r\nif (hexium_controls[i].id == vc->id)\r\nbreak;\r\n}\r\nif (i < 0)\r\nreturn dev->ext_vv_data->core_ops->vidioc_g_ctrl(file, fh, vc);\r\nif (vc->id == V4L2_CID_PRIVATE_BASE) {\r\nvc->value = hexium->cur_bw;\r\nDEB_D(("VIDIOC_G_CTRL BW:%d.\n", vc->value));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *vc)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nint i = 0;\r\nfor (i = HEXIUM_CONTROLS - 1; i >= 0; i--) {\r\nif (hexium_controls[i].id == vc->id)\r\nbreak;\r\n}\r\nif (i < 0)\r\nreturn dev->ext_vv_data->core_ops->vidioc_s_ctrl(file, fh, vc);\r\nif (vc->id == V4L2_CID_PRIVATE_BASE)\r\nhexium->cur_bw = vc->value;\r\nDEB_D(("VIDIOC_S_CTRL BW:%d.\n", hexium->cur_bw));\r\nif (0 == hexium->cur_bw && V4L2_STD_PAL == hexium->cur_std) {\r\nhexium_set_standard(hexium, hexium_pal);\r\nreturn 0;\r\n}\r\nif (0 == hexium->cur_bw && V4L2_STD_NTSC == hexium->cur_std) {\r\nhexium_set_standard(hexium, hexium_ntsc);\r\nreturn 0;\r\n}\r\nif (0 == hexium->cur_bw && V4L2_STD_SECAM == hexium->cur_std) {\r\nhexium_set_standard(hexium, hexium_secam);\r\nreturn 0;\r\n}\r\nif (1 == hexium->cur_bw && V4L2_STD_PAL == hexium->cur_std) {\r\nhexium_set_standard(hexium, hexium_pal_bw);\r\nreturn 0;\r\n}\r\nif (1 == hexium->cur_bw && V4L2_STD_NTSC == hexium->cur_std) {\r\nhexium_set_standard(hexium, hexium_ntsc_bw);\r\nreturn 0;\r\n}\r\nif (1 == hexium->cur_bw && V4L2_STD_SECAM == hexium->cur_std)\r\nreturn -EINVAL;\r\nreturn -EINVAL;\r\n}\r\nstatic int hexium_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\r\n{\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nint ret;\r\nDEB_EE((".\n"));\r\nhexium = kzalloc(sizeof(struct hexium), GFP_KERNEL);\r\nif (NULL == hexium) {\r\nprintk("hexium_gemini: not enough kernel memory in hexium_attach().\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->ext_priv = hexium;\r\nsaa7146_write(dev, MC1, (MASK_08 | MASK_24 | MASK_10 | MASK_26));\r\nhexium->i2c_adapter = (struct i2c_adapter) {\r\n.name = "hexium gemini",\r\n};\r\nsaa7146_i2c_adapter_prepare(dev, &hexium->i2c_adapter, SAA7146_I2C_BUS_BIT_RATE_480);\r\nif (i2c_add_adapter(&hexium->i2c_adapter) < 0) {\r\nDEB_S(("cannot register i2c-device. skipping.\n"));\r\nkfree(hexium);\r\nreturn -EFAULT;\r\n}\r\nsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);\r\nsaa7146_write(dev, DD1_INIT, 0x07000700);\r\nsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nhexium->cur_input = 0;\r\nhexium_init_done(dev);\r\nhexium_set_standard(hexium, hexium_pal);\r\nhexium->cur_std = V4L2_STD_PAL;\r\nhexium_set_input(hexium, 0);\r\nhexium->cur_input = 0;\r\nsaa7146_vv_init(dev, &vv_data);\r\nvv_data.ops.vidioc_queryctrl = vidioc_queryctrl;\r\nvv_data.ops.vidioc_g_ctrl = vidioc_g_ctrl;\r\nvv_data.ops.vidioc_s_ctrl = vidioc_s_ctrl;\r\nvv_data.ops.vidioc_enum_input = vidioc_enum_input;\r\nvv_data.ops.vidioc_g_input = vidioc_g_input;\r\nvv_data.ops.vidioc_s_input = vidioc_s_input;\r\nret = saa7146_register_device(&hexium->video_dev, dev, "hexium gemini", VFL_TYPE_GRABBER);\r\nif (ret < 0) {\r\nprintk("hexium_gemini: cannot register capture v4l2 device. skipping.\n");\r\nreturn ret;\r\n}\r\nprintk("hexium_gemini: found 'hexium gemini' frame grabber-%d.\n", hexium_num);\r\nhexium_num++;\r\nreturn 0;\r\n}\r\nstatic int hexium_detach(struct saa7146_dev *dev)\r\n{\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nDEB_EE(("dev:%p\n", dev));\r\nsaa7146_unregister_device(&hexium->video_dev, dev);\r\nsaa7146_vv_release(dev);\r\nhexium_num--;\r\ni2c_del_adapter(&hexium->i2c_adapter);\r\nkfree(hexium);\r\nreturn 0;\r\n}\r\nstatic int std_callback(struct saa7146_dev *dev, struct saa7146_standard *std)\r\n{\r\nstruct hexium *hexium = (struct hexium *) dev->ext_priv;\r\nif (V4L2_STD_PAL == std->id) {\r\nhexium_set_standard(hexium, hexium_pal);\r\nhexium->cur_std = V4L2_STD_PAL;\r\nreturn 0;\r\n} else if (V4L2_STD_NTSC == std->id) {\r\nhexium_set_standard(hexium, hexium_ntsc);\r\nhexium->cur_std = V4L2_STD_NTSC;\r\nreturn 0;\r\n} else if (V4L2_STD_SECAM == std->id) {\r\nhexium_set_standard(hexium, hexium_secam);\r\nhexium->cur_std = V4L2_STD_SECAM;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init hexium_init_module(void)\r\n{\r\nif (0 != saa7146_register_extension(&hexium_extension)) {\r\nDEB_S(("failed to register extension.\n"));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hexium_cleanup_module(void)\r\n{\r\nsaa7146_unregister_extension(&hexium_extension);\r\n}
