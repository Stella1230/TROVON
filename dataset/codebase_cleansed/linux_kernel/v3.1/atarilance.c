static void *slow_memcpy( void *dst, const void *src, size_t len )\r\n{ char *cto = dst;\r\nconst char *cfrom = src;\r\nwhile( len-- ) {\r\n*cto++ = *cfrom++;\r\nMFPDELAY();\r\n}\r\nreturn dst;\r\n}\r\nstruct net_device * __init atarilance_probe(int unit)\r\n{\r\nint i;\r\nstatic int found;\r\nstruct net_device *dev;\r\nint err = -ENODEV;\r\nif (!MACH_IS_ATARI || found)\r\nreturn ERR_PTR(-ENODEV);\r\ndev = alloc_etherdev(sizeof(struct lance_private));\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\nfor( i = 0; i < N_LANCE_ADDR; ++i ) {\r\nif (lance_probe1( dev, &lance_addr_list[i] )) {\r\nfound = 1;\r\nerr = register_netdev(dev);\r\nif (!err)\r\nreturn dev;\r\nfree_irq(dev->irq, dev);\r\nbreak;\r\n}\r\n}\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic noinline int __init addr_accessible(volatile void *regp, int wordflag,\r\nint writeflag)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nlong *vbr, save_berr;\r\nlocal_irq_save(flags);\r\n__asm__ __volatile__ ( "movec %/vbr,%0" : "=r" (vbr) : );\r\nsave_berr = vbr[2];\r\n__asm__ __volatile__\r\n( "movel %/sp,%/d1\n\t"\r\n"movel #Lberr,%2@\n\t"\r\n"moveq #0,%0\n\t"\r\n"tstl %3\n\t"\r\n"bne 1f\n\t"\r\n"moveb %1@,%/d0\n\t"\r\n"nop \n\t"\r\n"bra 2f\n"\r\n"1: movew %1@,%/d0\n\t"\r\n"nop \n"\r\n"2: tstl %4\n\t"\r\n"beq 2f\n\t"\r\n"tstl %3\n\t"\r\n"bne 1f\n\t"\r\n"clrb %1@\n\t"\r\n"nop \n\t"\r\n"moveb %/d0,%1@\n\t"\r\n"nop \n\t"\r\n"bra 2f\n"\r\n"1: clrw %1@\n\t"\r\n"nop \n\t"\r\n"movew %/d0,%1@\n\t"\r\n"nop \n"\r\n"2: moveq #1,%0\n"\r\n"Lberr: movel %/d1,%/sp"\r\n: "=&d" (ret)\r\n: "a" (regp), "a" (&vbr[2]), "rm" (wordflag), "rm" (writeflag)\r\n: "d0", "d1", "memory"\r\n);\r\nvbr[2] = save_berr;\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nstatic unsigned long __init lance_probe1( struct net_device *dev,\r\nstruct lance_addr *init_rec )\r\n{\r\nvolatile unsigned short *memaddr =\r\n(volatile unsigned short *)init_rec->memaddr;\r\nvolatile unsigned short *ioaddr =\r\n(volatile unsigned short *)init_rec->ioaddr;\r\nstruct lance_private *lp;\r\nstruct lance_ioreg *IO;\r\nint i;\r\nstatic int did_version;\r\nunsigned short save1, save2;\r\nPROBE_PRINT(( "Probing for Lance card at mem %#lx io %#lx\n",\r\n(long)memaddr, (long)ioaddr ));\r\nPROBE_PRINT(( "lance_probe1: testing memory to be accessible\n" ));\r\nif (!addr_accessible( memaddr, 1, 1 )) goto probe_fail;\r\nPROBE_PRINT(( "lance_probe1: testing memory to be writable (1)\n" ));\r\nsave1 = *memaddr;\r\n*memaddr = 0x0001;\r\nif (*memaddr != 0x0001) goto probe_fail;\r\nPROBE_PRINT(( "lance_probe1: testing memory to be writable (2)\n" ));\r\n*memaddr = 0x0000;\r\nif (*memaddr != 0x0000) goto probe_fail;\r\n*memaddr = save1;\r\nPROBE_PRINT(( "lance_probe1: testing ioport to be accessible\n" ));\r\nif (!addr_accessible( ioaddr, 1, 1 )) goto probe_fail;\r\nPROBE_PRINT(( "lance_probe1: testing ioport to be writeable\n" ));\r\nsave2 = ioaddr[1];\r\nioaddr[1] = 0x0001;\r\nif (ioaddr[1] != 0x0001) goto probe_fail;\r\nPROBE_PRINT(( "lance_probe1: testing CSR0 register function (1)\n" ));\r\nsave1 = ioaddr[0];\r\nioaddr[1] = CSR0;\r\nioaddr[0] = CSR0_INIT | CSR0_STOP;\r\nif (ioaddr[0] != CSR0_STOP) {\r\nioaddr[0] = save1;\r\nioaddr[1] = save2;\r\ngoto probe_fail;\r\n}\r\nPROBE_PRINT(( "lance_probe1: testing CSR0 register function (2)\n" ));\r\nioaddr[0] = CSR0_STOP;\r\nif (ioaddr[0] != CSR0_STOP) {\r\nioaddr[0] = save1;\r\nioaddr[1] = save2;\r\ngoto probe_fail;\r\n}\r\nPROBE_PRINT(( "lance_probe1: Lance card detected\n" ));\r\ngoto probe_ok;\r\nprobe_fail:\r\nreturn 0;\r\nprobe_ok:\r\nlp = netdev_priv(dev);\r\nMEM = (struct lance_memory *)memaddr;\r\nIO = lp->iobase = (struct lance_ioreg *)ioaddr;\r\ndev->base_addr = (unsigned long)ioaddr;\r\nlp->memcpy_f = init_rec->slow_flag ? slow_memcpy : memcpy;\r\nREGA( CSR0 ) = CSR0_STOP;\r\nif (addr_accessible( &(IO->eeprom), 0, 0 )) {\r\ni = IO->mem;\r\nlp->cardtype = PAM_CARD;\r\n}\r\nelse if (*RIEBL_MAGIC_ADDR == RIEBL_MAGIC) {\r\nlp->cardtype = NEW_RIEBL;\r\n}\r\nelse\r\nlp->cardtype = OLD_RIEBL;\r\nif (lp->cardtype == PAM_CARD ||\r\nmemaddr == (unsigned short *)0xffe00000) {\r\nif (request_irq(IRQ_AUTO_5, lance_interrupt, IRQ_TYPE_PRIO,\r\n"PAM,Riebl-ST Ethernet", dev)) {\r\nprintk( "Lance: request for irq %d failed\n", IRQ_AUTO_5 );\r\nreturn 0;\r\n}\r\ndev->irq = (unsigned short)IRQ_AUTO_5;\r\n}\r\nelse {\r\nunsigned long irq = atari_register_vme_int();\r\nif (!irq) {\r\nprintk( "Lance: request for VME interrupt failed\n" );\r\nreturn 0;\r\n}\r\nif (request_irq(irq, lance_interrupt, IRQ_TYPE_PRIO,\r\n"Riebl-VME Ethernet", dev)) {\r\nprintk( "Lance: request for irq %ld failed\n", irq );\r\nreturn 0;\r\n}\r\ndev->irq = irq;\r\n}\r\nprintk("%s: %s at io %#lx, mem %#lx, irq %d%s, hwaddr ",\r\ndev->name, lance_names[lp->cardtype],\r\n(unsigned long)ioaddr,\r\n(unsigned long)memaddr,\r\ndev->irq,\r\ninit_rec->slow_flag ? " (slow memcpy)" : "" );\r\nswitch( lp->cardtype ) {\r\ncase OLD_RIEBL:\r\nmemcpy( dev->dev_addr, OldRieblDefHwaddr, 6 );\r\nbreak;\r\ncase NEW_RIEBL:\r\nlp->memcpy_f( dev->dev_addr, RIEBL_HWADDR_ADDR, 6 );\r\nbreak;\r\ncase PAM_CARD:\r\ni = IO->eeprom;\r\nfor( i = 0; i < 6; ++i )\r\ndev->dev_addr[i] =\r\n((((unsigned short *)MEM)[i*2] & 0x0f) << 4) |\r\n((((unsigned short *)MEM)[i*2+1] & 0x0f));\r\ni = IO->mem;\r\nbreak;\r\n}\r\nprintk("%pM\n", dev->dev_addr);\r\nif (lp->cardtype == OLD_RIEBL) {\r\nprintk( "%s: Warning: This is a default ethernet address!\n",\r\ndev->name );\r\nprintk( " Use \"ifconfig hw ether ...\" to set the address.\n" );\r\n}\r\nspin_lock_init(&lp->devlock);\r\nMEM->init.mode = 0x0000;\r\nfor( i = 0; i < 6; i++ )\r\nMEM->init.hwaddr[i] = dev->dev_addr[i^1];\r\nMEM->init.filter[0] = 0x00000000;\r\nMEM->init.filter[1] = 0x00000000;\r\nMEM->init.rx_ring.adr_lo = offsetof( struct lance_memory, rx_head );\r\nMEM->init.rx_ring.adr_hi = 0;\r\nMEM->init.rx_ring.len = RX_RING_LEN_BITS;\r\nMEM->init.tx_ring.adr_lo = offsetof( struct lance_memory, tx_head );\r\nMEM->init.tx_ring.adr_hi = 0;\r\nMEM->init.tx_ring.len = TX_RING_LEN_BITS;\r\nif (lp->cardtype == PAM_CARD)\r\nIO->ivec = IRQ_SOURCE_TO_VECTOR(dev->irq);\r\nelse\r\n*RIEBL_IVEC_ADDR = IRQ_SOURCE_TO_VECTOR(dev->irq);\r\nif (did_version++ == 0)\r\nDPRINTK( 1, ( version ));\r\ndev->netdev_ops = &lance_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nreturn 1;\r\n}\r\nstatic int lance_open( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_ioreg *IO = lp->iobase;\r\nint i;\r\nDPRINTK( 2, ( "%s: lance_open()\n", dev->name ));\r\nlance_init_ring(dev);\r\nREGA( CSR3 ) = CSR3_BSWP | (lp->cardtype == PAM_CARD ? CSR3_ACON : 0);\r\nREGA( CSR2 ) = 0;\r\nREGA( CSR1 ) = 0;\r\nREGA( CSR0 ) = CSR0_INIT;\r\ni = 1000000;\r\nwhile (--i > 0)\r\nif (DREG & CSR0_IDON)\r\nbreak;\r\nif (i <= 0 || (DREG & CSR0_ERR)) {\r\nDPRINTK( 2, ( "lance_open(): opening %s failed, i=%d, csr0=%04x\n",\r\ndev->name, i, DREG ));\r\nDREG = CSR0_STOP;\r\nreturn -EIO;\r\n}\r\nDREG = CSR0_IDON;\r\nDREG = CSR0_STRT;\r\nDREG = CSR0_INEA;\r\nnetif_start_queue (dev);\r\nDPRINTK( 2, ( "%s: LANCE is open, csr0 %04x\n", dev->name, DREG ));\r\nreturn 0;\r\n}\r\nstatic void lance_init_ring( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint i;\r\nunsigned offset;\r\nlp->tx_full = 0;\r\nlp->cur_rx = lp->cur_tx = 0;\r\nlp->dirty_tx = 0;\r\noffset = offsetof( struct lance_memory, packet_area );\r\n#define CHECK_OFFSET(o) \\r\ndo { \\r\nif (lp->cardtype == OLD_RIEBL || lp->cardtype == NEW_RIEBL) { \\r\nif (((o) < RIEBL_RSVD_START) ? (o)+PKT_BUF_SZ > RIEBL_RSVD_START \\r\n: (o) < RIEBL_RSVD_END) \\r\n(o) = RIEBL_RSVD_END; \\r\n} \\r\n} while(0)\r\nfor( i = 0; i < TX_RING_SIZE; i++ ) {\r\nCHECK_OFFSET(offset);\r\nMEM->tx_head[i].base = offset;\r\nMEM->tx_head[i].flag = TMD1_OWN_HOST;\r\nMEM->tx_head[i].base_hi = 0;\r\nMEM->tx_head[i].length = 0;\r\nMEM->tx_head[i].misc = 0;\r\noffset += PKT_BUF_SZ;\r\n}\r\nfor( i = 0; i < RX_RING_SIZE; i++ ) {\r\nCHECK_OFFSET(offset);\r\nMEM->rx_head[i].base = offset;\r\nMEM->rx_head[i].flag = TMD1_OWN_CHIP;\r\nMEM->rx_head[i].base_hi = 0;\r\nMEM->rx_head[i].buf_length = -PKT_BUF_SZ;\r\nMEM->rx_head[i].msg_length = 0;\r\noffset += PKT_BUF_SZ;\r\n}\r\n}\r\nstatic void lance_tx_timeout (struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_ioreg *IO = lp->iobase;\r\nAREG = CSR0;\r\nDPRINTK( 1, ( "%s: transmit timed out, status %04x, resetting.\n",\r\ndev->name, DREG ));\r\nDREG = CSR0_STOP;\r\nREGA( CSR3 ) = CSR3_BSWP | (lp->cardtype == PAM_CARD ? CSR3_ACON : 0);\r\ndev->stats.tx_errors++;\r\n#ifndef final_version\r\n{ int i;\r\nDPRINTK( 2, ( "Ring data: dirty_tx %d cur_tx %d%s cur_rx %d\n",\r\nlp->dirty_tx, lp->cur_tx,\r\nlp->tx_full ? " (full)" : "",\r\nlp->cur_rx ));\r\nfor( i = 0 ; i < RX_RING_SIZE; i++ )\r\nDPRINTK( 2, ( "rx #%d: base=%04x blen=%04x mlen=%04x\n",\r\ni, MEM->rx_head[i].base,\r\n-MEM->rx_head[i].buf_length,\r\nMEM->rx_head[i].msg_length ));\r\nfor( i = 0 ; i < TX_RING_SIZE; i++ )\r\nDPRINTK( 2, ( "tx #%d: base=%04x len=%04x misc=%04x\n",\r\ni, MEM->tx_head[i].base,\r\n-MEM->tx_head[i].length,\r\nMEM->tx_head[i].misc ));\r\n}\r\n#endif\r\nlance_init_ring(dev);\r\nREGA( CSR0 ) = CSR0_INEA | CSR0_INIT | CSR0_STRT;\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int lance_start_xmit( struct sk_buff *skb, struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_ioreg *IO = lp->iobase;\r\nint entry, len;\r\nstruct lance_tx_head *head;\r\nunsigned long flags;\r\nDPRINTK( 2, ( "%s: lance_start_xmit() called, csr0 %4.4x.\n",\r\ndev->name, DREG ));\r\nlen = skb->len;\r\nif (len < ETH_ZLEN)\r\nlen = ETH_ZLEN;\r\nelse if (lp->cardtype == PAM_CARD && (len & 1))\r\n++len;\r\nif (len > skb->len) {\r\nif (skb_padto(skb, len))\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue (dev);\r\nif (lance_debug >= 3) {\r\nprintk( "%s: TX pkt type 0x%04x from %pM to %pM"\r\n" data at 0x%08x len %d\n",\r\ndev->name, ((u_short *)skb->data)[6],\r\n&skb->data[6], skb->data,\r\n(int)skb->data, (int)skb->len );\r\n}\r\nspin_lock_irqsave (&lp->devlock, flags);\r\nentry = lp->cur_tx & TX_RING_MOD_MASK;\r\nhead = &(MEM->tx_head[entry]);\r\nhead->length = -len;\r\nhead->misc = 0;\r\nlp->memcpy_f( PKTBUF_ADDR(head), (void *)skb->data, skb->len );\r\nhead->flag = TMD1_OWN_CHIP | TMD1_ENP | TMD1_STP;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb( skb );\r\nlp->cur_tx++;\r\nwhile( lp->cur_tx >= TX_RING_SIZE && lp->dirty_tx >= TX_RING_SIZE ) {\r\nlp->cur_tx -= TX_RING_SIZE;\r\nlp->dirty_tx -= TX_RING_SIZE;\r\n}\r\nDREG = CSR0_INEA | CSR0_TDMD;\r\nif ((MEM->tx_head[(entry+1) & TX_RING_MOD_MASK].flag & TMD1_OWN) ==\r\nTMD1_OWN_HOST)\r\nnetif_start_queue (dev);\r\nelse\r\nlp->tx_full = 1;\r\nspin_unlock_irqrestore (&lp->devlock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t lance_interrupt( int irq, void *dev_id )\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct lance_private *lp;\r\nstruct lance_ioreg *IO;\r\nint csr0, boguscnt = 10;\r\nint handled = 0;\r\nif (dev == NULL) {\r\nDPRINTK( 1, ( "lance_interrupt(): interrupt for unknown device.\n" ));\r\nreturn IRQ_NONE;\r\n}\r\nlp = netdev_priv(dev);\r\nIO = lp->iobase;\r\nspin_lock (&lp->devlock);\r\nAREG = CSR0;\r\nwhile( ((csr0 = DREG) & (CSR0_ERR | CSR0_TINT | CSR0_RINT)) &&\r\n--boguscnt >= 0) {\r\nhandled = 1;\r\nDREG = csr0 & ~(CSR0_INIT | CSR0_STRT | CSR0_STOP |\r\nCSR0_TDMD | CSR0_INEA);\r\nDPRINTK( 2, ( "%s: interrupt csr0=%04x new csr=%04x.\n",\r\ndev->name, csr0, DREG ));\r\nif (csr0 & CSR0_RINT)\r\nlance_rx( dev );\r\nif (csr0 & CSR0_TINT) {\r\nint dirty_tx = lp->dirty_tx;\r\nwhile( dirty_tx < lp->cur_tx) {\r\nint entry = dirty_tx & TX_RING_MOD_MASK;\r\nint status = MEM->tx_head[entry].flag;\r\nif (status & TMD1_OWN_CHIP)\r\nbreak;\r\nMEM->tx_head[entry].flag = 0;\r\nif (status & TMD1_ERR) {\r\nint err_status = MEM->tx_head[entry].misc;\r\ndev->stats.tx_errors++;\r\nif (err_status & TMD3_RTRY) dev->stats.tx_aborted_errors++;\r\nif (err_status & TMD3_LCAR) dev->stats.tx_carrier_errors++;\r\nif (err_status & TMD3_LCOL) dev->stats.tx_window_errors++;\r\nif (err_status & TMD3_UFLO) {\r\ndev->stats.tx_fifo_errors++;\r\nDPRINTK( 1, ( "%s: Tx FIFO error! Status %04x\n",\r\ndev->name, csr0 ));\r\nDREG = CSR0_STRT;\r\n}\r\n} else {\r\nif (status & (TMD1_MORE | TMD1_ONE | TMD1_DEF))\r\ndev->stats.collisions++;\r\ndev->stats.tx_packets++;\r\n}\r\ndirty_tx++;\r\n}\r\n#ifndef final_version\r\nif (lp->cur_tx - dirty_tx >= TX_RING_SIZE) {\r\nDPRINTK( 0, ( "out-of-sync dirty pointer,"\r\n" %d vs. %d, full=%ld.\n",\r\ndirty_tx, lp->cur_tx, lp->tx_full ));\r\ndirty_tx += TX_RING_SIZE;\r\n}\r\n#endif\r\nif (lp->tx_full && (netif_queue_stopped(dev)) &&\r\ndirty_tx > lp->cur_tx - TX_RING_SIZE + 2) {\r\nlp->tx_full = 0;\r\nnetif_wake_queue (dev);\r\n}\r\nlp->dirty_tx = dirty_tx;\r\n}\r\nif (csr0 & CSR0_BABL) dev->stats.tx_errors++;\r\nif (csr0 & CSR0_MISS) dev->stats.rx_errors++;\r\nif (csr0 & CSR0_MERR) {\r\nDPRINTK( 1, ( "%s: Bus master arbitration failure (?!?), "\r\n"status %04x.\n", dev->name, csr0 ));\r\nDREG = CSR0_STRT;\r\n}\r\n}\r\nDREG = CSR0_BABL | CSR0_CERR | CSR0_MISS | CSR0_MERR |\r\nCSR0_IDON | CSR0_INEA;\r\nDPRINTK( 2, ( "%s: exiting interrupt, csr0=%#04x.\n",\r\ndev->name, DREG ));\r\nspin_unlock (&lp->devlock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int lance_rx( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint entry = lp->cur_rx & RX_RING_MOD_MASK;\r\nint i;\r\nDPRINTK( 2, ( "%s: rx int, flag=%04x\n", dev->name,\r\nMEM->rx_head[entry].flag ));\r\nwhile( (MEM->rx_head[entry].flag & RMD1_OWN) == RMD1_OWN_HOST ) {\r\nstruct lance_rx_head *head = &(MEM->rx_head[entry]);\r\nint status = head->flag;\r\nif (status != (RMD1_ENP|RMD1_STP)) {\r\nif (status & RMD1_ENP)\r\ndev->stats.rx_errors++;\r\nif (status & RMD1_FRAM) dev->stats.rx_frame_errors++;\r\nif (status & RMD1_OFLO) dev->stats.rx_over_errors++;\r\nif (status & RMD1_CRC) dev->stats.rx_crc_errors++;\r\nif (status & RMD1_BUFF) dev->stats.rx_fifo_errors++;\r\nhead->flag &= (RMD1_ENP|RMD1_STP);\r\n} else {\r\nshort pkt_len = head->msg_length & 0xfff;\r\nstruct sk_buff *skb;\r\nif (pkt_len < 60) {\r\nprintk( "%s: Runt packet!\n", dev->name );\r\ndev->stats.rx_errors++;\r\n}\r\nelse {\r\nskb = dev_alloc_skb( pkt_len+2 );\r\nif (skb == NULL) {\r\nDPRINTK( 1, ( "%s: Memory squeeze, deferring packet.\n",\r\ndev->name ));\r\nfor( i = 0; i < RX_RING_SIZE; i++ )\r\nif (MEM->rx_head[(entry+i) & RX_RING_MOD_MASK].flag &\r\nRMD1_OWN_CHIP)\r\nbreak;\r\nif (i > RX_RING_SIZE - 2) {\r\ndev->stats.rx_dropped++;\r\nhead->flag |= RMD1_OWN_CHIP;\r\nlp->cur_rx++;\r\n}\r\nbreak;\r\n}\r\nif (lance_debug >= 3) {\r\nu_char *data = PKTBUF_ADDR(head);\r\nprintk(KERN_DEBUG "%s: RX pkt type 0x%04x from %pM to %pM "\r\n"data %02x %02x %02x %02x %02x %02x %02x %02x "\r\n"len %d\n",\r\ndev->name, ((u_short *)data)[6],\r\n&data[6], data,\r\ndata[15], data[16], data[17], data[18],\r\ndata[19], data[20], data[21], data[22],\r\npkt_len);\r\n}\r\nskb_reserve( skb, 2 );\r\nskb_put( skb, pkt_len );\r\nlp->memcpy_f( skb->data, PKTBUF_ADDR(head), pkt_len );\r\nskb->protocol = eth_type_trans( skb, dev );\r\nnetif_rx( skb );\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\n}\r\nhead->flag |= RMD1_OWN_CHIP;\r\nentry = (++lp->cur_rx) & RX_RING_MOD_MASK;\r\n}\r\nlp->cur_rx &= RX_RING_MOD_MASK;\r\nreturn 0;\r\n}\r\nstatic int lance_close( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_ioreg *IO = lp->iobase;\r\nnetif_stop_queue (dev);\r\nAREG = CSR0;\r\nDPRINTK( 2, ( "%s: Shutting down ethercard, status was %2.2x.\n",\r\ndev->name, DREG ));\r\nDREG = CSR0_STOP;\r\nreturn 0;\r\n}\r\nstatic void set_multicast_list( struct net_device *dev )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_ioreg *IO = lp->iobase;\r\nif (netif_running(dev))\r\nreturn;\r\nDREG = CSR0_STOP;\r\nif (dev->flags & IFF_PROMISC) {\r\nDPRINTK( 2, ( "%s: Promiscuous mode enabled.\n", dev->name ));\r\nREGA( CSR15 ) = 0x8000;\r\n} else {\r\nshort multicast_table[4];\r\nint num_addrs = netdev_mc_count(dev);\r\nint i;\r\nmemset( multicast_table, (num_addrs == 0) ? 0 : -1,\r\nsizeof(multicast_table) );\r\nfor( i = 0; i < 4; i++ )\r\nREGA( CSR8+i ) = multicast_table[i];\r\nREGA( CSR15 ) = 0;\r\n}\r\nREGA( CSR3 ) = CSR3_BSWP | (lp->cardtype == PAM_CARD ? CSR3_ACON : 0);\r\nREGA( CSR0 ) = CSR0_IDON | CSR0_INEA | CSR0_STRT;\r\n}\r\nstatic int lance_set_mac_address( struct net_device *dev, void *addr )\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct sockaddr *saddr = addr;\r\nint i;\r\nif (lp->cardtype != OLD_RIEBL && lp->cardtype != NEW_RIEBL)\r\nreturn -EOPNOTSUPP;\r\nif (netif_running(dev)) {\r\nDPRINTK( 1, ( "%s: hwaddr can be set only while card isn't open.\n",\r\ndev->name ));\r\nreturn -EIO;\r\n}\r\nmemcpy( dev->dev_addr, saddr->sa_data, dev->addr_len );\r\nfor( i = 0; i < 6; i++ )\r\nMEM->init.hwaddr[i] = dev->dev_addr[i^1];\r\nlp->memcpy_f( RIEBL_HWADDR_ADDR, dev->dev_addr, 6 );\r\n*RIEBL_MAGIC_ADDR = RIEBL_MAGIC;\r\nreturn 0;\r\n}\r\nstatic int __init atarilance_module_init(void)\r\n{\r\natarilance_dev = atarilance_probe(-1);\r\nif (IS_ERR(atarilance_dev))\r\nreturn PTR_ERR(atarilance_dev);\r\nreturn 0;\r\n}\r\nstatic void __exit atarilance_module_exit(void)\r\n{\r\nunregister_netdev(atarilance_dev);\r\nfree_irq(atarilance_dev->irq, atarilance_dev);\r\nfree_netdev(atarilance_dev);\r\n}
