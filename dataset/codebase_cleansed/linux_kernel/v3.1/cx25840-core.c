int cx25840_write(struct i2c_client *client, u16 addr, u8 value)\r\n{\r\nu8 buffer[3];\r\nbuffer[0] = addr >> 8;\r\nbuffer[1] = addr & 0xff;\r\nbuffer[2] = value;\r\nreturn i2c_master_send(client, buffer, 3);\r\n}\r\nint cx25840_write4(struct i2c_client *client, u16 addr, u32 value)\r\n{\r\nu8 buffer[6];\r\nbuffer[0] = addr >> 8;\r\nbuffer[1] = addr & 0xff;\r\nbuffer[2] = value & 0xff;\r\nbuffer[3] = (value >> 8) & 0xff;\r\nbuffer[4] = (value >> 16) & 0xff;\r\nbuffer[5] = value >> 24;\r\nreturn i2c_master_send(client, buffer, 6);\r\n}\r\nu8 cx25840_read(struct i2c_client * client, u16 addr)\r\n{\r\nstruct i2c_msg msgs[2];\r\nu8 tx_buf[2], rx_buf[1];\r\ntx_buf[0] = addr >> 8;\r\ntx_buf[1] = addr & 0xff;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = 2;\r\nmsgs[0].buf = (char *) tx_buf;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = 1;\r\nmsgs[1].buf = (char *) rx_buf;\r\nif (i2c_transfer(client->adapter, msgs, 2) < 2)\r\nreturn 0;\r\nreturn rx_buf[0];\r\n}\r\nu32 cx25840_read4(struct i2c_client * client, u16 addr)\r\n{\r\nstruct i2c_msg msgs[2];\r\nu8 tx_buf[2], rx_buf[4];\r\ntx_buf[0] = addr >> 8;\r\ntx_buf[1] = addr & 0xff;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = 2;\r\nmsgs[0].buf = (char *) tx_buf;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = 4;\r\nmsgs[1].buf = (char *) rx_buf;\r\nif (i2c_transfer(client->adapter, msgs, 2) < 2)\r\nreturn 0;\r\nreturn (rx_buf[3] << 24) | (rx_buf[2] << 16) | (rx_buf[1] << 8) |\r\nrx_buf[0];\r\n}\r\nint cx25840_and_or(struct i2c_client *client, u16 addr, unsigned and_mask,\r\nu8 or_value)\r\n{\r\nreturn cx25840_write(client, addr,\r\n(cx25840_read(client, addr) & and_mask) |\r\nor_value);\r\n}\r\nint cx25840_and_or4(struct i2c_client *client, u16 addr, u32 and_mask,\r\nu32 or_value)\r\n{\r\nreturn cx25840_write4(client, addr,\r\n(cx25840_read4(client, addr) & and_mask) |\r\nor_value);\r\n}\r\nstatic int cx23885_s_io_pin_config(struct v4l2_subdev *sd, size_t n,\r\nstruct v4l2_subdev_io_pin_config *p)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint i;\r\nu32 pin_ctrl;\r\nu8 gpio_oe, gpio_data, strength;\r\npin_ctrl = cx25840_read4(client, 0x120);\r\ngpio_oe = cx25840_read(client, 0x160);\r\ngpio_data = cx25840_read(client, 0x164);\r\nfor (i = 0; i < n; i++) {\r\nstrength = p[i].strength;\r\nif (strength > CX25840_PIN_DRIVE_FAST)\r\nstrength = CX25840_PIN_DRIVE_FAST;\r\nswitch (p[i].pin) {\r\ncase CX23885_PIN_IRQ_N_GPIO16:\r\nif (p[i].function != CX23885_PAD_IRQ_N) {\r\npin_ctrl &= ~(0x1 << 25);\r\n} else {\r\nif (p[i].flags &\r\n(V4L2_SUBDEV_IO_PIN_DISABLE |\r\nV4L2_SUBDEV_IO_PIN_INPUT)) {\r\npin_ctrl &= ~(0x1 << 25);\r\n} else {\r\npin_ctrl |= (0x1 << 25);\r\n}\r\nif (p[i].flags &\r\nV4L2_SUBDEV_IO_PIN_ACTIVE_LOW) {\r\npin_ctrl &= ~(0x1 << 24);\r\n} else {\r\npin_ctrl |= (0x1 << 24);\r\n}\r\n}\r\nbreak;\r\ncase CX23885_PIN_IR_RX_GPIO19:\r\nif (p[i].function != CX23885_PAD_GPIO19) {\r\ngpio_oe |= (0x1 << 0);\r\npin_ctrl &= ~(0x3 << 18);\r\npin_ctrl |= (strength << 18);\r\n} else {\r\ngpio_oe &= ~(0x1 << 0);\r\nif (p[i].flags & V4L2_SUBDEV_IO_PIN_SET_VALUE) {\r\ngpio_data &= ~(0x1 << 0);\r\ngpio_data |= ((p[i].value & 0x1) << 0);\r\n}\r\npin_ctrl &= ~(0x3 << 12);\r\npin_ctrl |= (strength << 12);\r\n}\r\nbreak;\r\ncase CX23885_PIN_IR_TX_GPIO20:\r\nif (p[i].function != CX23885_PAD_GPIO20) {\r\ngpio_oe |= (0x1 << 1);\r\nif (p[i].flags & V4L2_SUBDEV_IO_PIN_DISABLE)\r\npin_ctrl &= ~(0x1 << 10);\r\nelse\r\npin_ctrl |= (0x1 << 10);\r\npin_ctrl &= ~(0x3 << 18);\r\npin_ctrl |= (strength << 18);\r\n} else {\r\ngpio_oe &= ~(0x1 << 1);\r\nif (p[i].flags & V4L2_SUBDEV_IO_PIN_SET_VALUE) {\r\ngpio_data &= ~(0x1 << 1);\r\ngpio_data |= ((p[i].value & 0x1) << 1);\r\n}\r\npin_ctrl &= ~(0x3 << 12);\r\npin_ctrl |= (strength << 12);\r\n}\r\nbreak;\r\ncase CX23885_PIN_I2S_SDAT_GPIO21:\r\nif (p[i].function != CX23885_PAD_GPIO21) {\r\ngpio_oe |= (0x1 << 2);\r\npin_ctrl &= ~(0x3 << 22);\r\npin_ctrl |= (strength << 22);\r\n} else {\r\ngpio_oe &= ~(0x1 << 2);\r\nif (p[i].flags & V4L2_SUBDEV_IO_PIN_SET_VALUE) {\r\ngpio_data &= ~(0x1 << 2);\r\ngpio_data |= ((p[i].value & 0x1) << 2);\r\n}\r\npin_ctrl &= ~(0x3 << 12);\r\npin_ctrl |= (strength << 12);\r\n}\r\nbreak;\r\ncase CX23885_PIN_I2S_WCLK_GPIO22:\r\nif (p[i].function != CX23885_PAD_GPIO22) {\r\ngpio_oe |= (0x1 << 3);\r\npin_ctrl &= ~(0x3 << 22);\r\npin_ctrl |= (strength << 22);\r\n} else {\r\ngpio_oe &= ~(0x1 << 3);\r\nif (p[i].flags & V4L2_SUBDEV_IO_PIN_SET_VALUE) {\r\ngpio_data &= ~(0x1 << 3);\r\ngpio_data |= ((p[i].value & 0x1) << 3);\r\n}\r\npin_ctrl &= ~(0x3 << 12);\r\npin_ctrl |= (strength << 12);\r\n}\r\nbreak;\r\ncase CX23885_PIN_I2S_BCLK_GPIO23:\r\nif (p[i].function != CX23885_PAD_GPIO23) {\r\ngpio_oe |= (0x1 << 4);\r\npin_ctrl &= ~(0x3 << 22);\r\npin_ctrl |= (strength << 22);\r\n} else {\r\ngpio_oe &= ~(0x1 << 4);\r\nif (p[i].flags & V4L2_SUBDEV_IO_PIN_SET_VALUE) {\r\ngpio_data &= ~(0x1 << 4);\r\ngpio_data |= ((p[i].value & 0x1) << 4);\r\n}\r\npin_ctrl &= ~(0x3 << 12);\r\npin_ctrl |= (strength << 12);\r\n}\r\nbreak;\r\n}\r\n}\r\ncx25840_write(client, 0x164, gpio_data);\r\ncx25840_write(client, 0x160, gpio_oe);\r\ncx25840_write4(client, 0x120, pin_ctrl);\r\nreturn 0;\r\n}\r\nstatic int common_s_io_pin_config(struct v4l2_subdev *sd, size_t n,\r\nstruct v4l2_subdev_io_pin_config *pincfg)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nif (is_cx2388x(state))\r\nreturn cx23885_s_io_pin_config(sd, n, pincfg);\r\nreturn 0;\r\n}\r\nstatic void init_dll1(struct i2c_client *client)\r\n{\r\ncx25840_write(client, 0x159, 0x23);\r\ncx25840_write(client, 0x15a, 0x87);\r\ncx25840_write(client, 0x15b, 0x06);\r\nudelay(10);\r\ncx25840_write(client, 0x159, 0xe1);\r\nudelay(10);\r\ncx25840_write(client, 0x15a, 0x86);\r\ncx25840_write(client, 0x159, 0xe0);\r\ncx25840_write(client, 0x159, 0xe1);\r\ncx25840_write(client, 0x15b, 0x10);\r\n}\r\nstatic void init_dll2(struct i2c_client *client)\r\n{\r\ncx25840_write(client, 0x15d, 0xe3);\r\ncx25840_write(client, 0x15e, 0x86);\r\ncx25840_write(client, 0x15f, 0x06);\r\nudelay(10);\r\ncx25840_write(client, 0x15d, 0xe1);\r\ncx25840_write(client, 0x15d, 0xe0);\r\ncx25840_write(client, 0x15d, 0xe1);\r\n}\r\nstatic void cx25836_initialize(struct i2c_client *client)\r\n{\r\ncx25840_and_or(client, 0x000, ~0x01, 0x01);\r\ncx25840_and_or(client, 0x000, ~0x01, 0x00);\r\ncx25840_and_or(client, 0x15a, ~0x70, 0x00);\r\ncx25840_and_or(client, 0x15b, ~0x1e, 0x06);\r\ncx25840_and_or(client, 0x159, ~0x02, 0x02);\r\nudelay(10);\r\ncx25840_and_or(client, 0x159, ~0x02, 0x00);\r\ncx25840_and_or(client, 0x159, ~0xc0, 0xc0);\r\ncx25840_and_or(client, 0x159, ~0x01, 0x00);\r\ncx25840_and_or(client, 0x159, ~0x01, 0x01);\r\ncx25840_and_or(client, 0x15b, ~0x1e, 0x10);\r\n}\r\nstatic void cx25840_work_handler(struct work_struct *work)\r\n{\r\nstruct cx25840_state *state = container_of(work, struct cx25840_state, fw_work);\r\ncx25840_loadfw(state->c);\r\nwake_up(&state->fw_wait);\r\n}\r\nstatic void cx25840_initialize(struct i2c_client *client)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nstruct workqueue_struct *q;\r\ncx25840_and_or(client, 0x803, ~0x10, 0x00);\r\ncx25840_write(client, 0x000, 0x04);\r\ninit_dll1(client);\r\ninit_dll2(client);\r\ncx25840_write(client, 0x136, 0x0a);\r\ncx25840_write(client, 0x13c, 0x01);\r\ncx25840_write(client, 0x13c, 0x00);\r\nINIT_WORK(&state->fw_work, cx25840_work_handler);\r\ninit_waitqueue_head(&state->fw_wait);\r\nq = create_singlethread_workqueue("cx25840_fw");\r\nprepare_to_wait(&state->fw_wait, &wait, TASK_UNINTERRUPTIBLE);\r\nqueue_work(q, &state->fw_work);\r\nschedule();\r\nfinish_wait(&state->fw_wait, &wait);\r\ndestroy_workqueue(q);\r\ncx25840_write(client, 0x115, 0x8c);\r\ncx25840_write(client, 0x116, 0x07);\r\ncx25840_write(client, 0x118, 0x02);\r\ncx25840_write(client, 0x4a5, 0x80);\r\ncx25840_write(client, 0x4a5, 0x00);\r\ncx25840_write(client, 0x402, 0x00);\r\ncx25840_and_or(client, 0x401, ~0x18, 0);\r\ncx25840_and_or(client, 0x4a2, ~0x10, 0x10);\r\ncx25840_write(client, 0x8d3, 0x1f);\r\ncx25840_write(client, 0x8e3, 0x03);\r\ncx25840_std_setup(client);\r\ncx25840_write(client, 0x914, 0xa0);\r\ncx25840_write(client, 0x918, 0xa0);\r\ncx25840_write(client, 0x919, 0x01);\r\ncx25840_write(client, 0x809, 0x04);\r\ncx25840_write(client, 0x8cf, 0x0f);\r\nset_input(client, state->vid_input, state->aud_input);\r\ncx25840_and_or(client, 0x803, ~0x10, 0x10);\r\n}\r\nstatic void cx23885_initialize(struct i2c_client *client)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nstruct workqueue_struct *q;\r\ncx25840_write(client, 0x000, 0);\r\ncx25840_and_or(client, 0x102, ~0x01, 0x01);\r\ncx25840_and_or(client, 0x102, ~0x01, 0x00);\r\ncx25840_and_or(client, 0x803, ~0x10, 0x00);\r\ncx25840_write(client, 0x398, 0);\r\ncx25840_write(client, 0x2, 0x76);\r\ncx25840_write(client, 0x1, 0x40);\r\nswitch (state->id) {\r\ncase V4L2_IDENT_CX23888_AV:\r\ncx25840_write4(client, 0x11c, 0x00e8ba26);\r\ncx25840_write4(client, 0x118, 0x0000040b);\r\nbreak;\r\ncase V4L2_IDENT_CX23887_AV:\r\ncx25840_write4(client, 0x11c, 0x01d1744c);\r\ncx25840_write4(client, 0x118, 0x00000416);\r\nbreak;\r\ncase V4L2_IDENT_CX23885_AV:\r\ndefault:\r\ncx25840_write4(client, 0x11c, 0x00000000);\r\ncx25840_write4(client, 0x118, 0x00000414);\r\nbreak;\r\n}\r\ncx25840_write4(client, 0x33c, 0x00000001);\r\ncx25840_write4(client, 0x340, 0x0df7df83);\r\ncx25840_write4(client, 0x10c, 0x002be2c9);\r\ncx25840_write4(client, 0x108, 0x0000040f);\r\ncx25840_write4(client, 0x414, 0x00107d12);\r\ncx25840_write4(client, 0x420, 0x3d008282);\r\nswitch (state->id) {\r\ncase V4L2_IDENT_CX23888_AV:\r\ncx25840_write4(client, 0x114, 0x00bedfa4);\r\ncx25840_write4(client, 0x110, 0x000a0307);\r\nbreak;\r\ncase V4L2_IDENT_CX23887_AV:\r\ncx25840_write4(client, 0x114, 0x017dbf48);\r\ncx25840_write4(client, 0x110, 0x000a030e);\r\nbreak;\r\ncase V4L2_IDENT_CX23885_AV:\r\ndefault:\r\ncx25840_write4(client, 0x114, 0x01bf0c9e);\r\ncx25840_write4(client, 0x110, 0x000a030c);\r\nbreak;\r\n};\r\ncx25840_write(client, 0x102, 0x10);\r\ncx25840_write(client, 0x103, 0x11);\r\ncx25840_write(client, 0x400, 0);\r\ncx25840_write(client, 0x401, 0xe8);\r\ncx25840_write(client, 0x144, 0x05);\r\ncx25840_write(client, 0x160, 0x1d);\r\ncx25840_write(client, 0x164, 0x00);\r\nINIT_WORK(&state->fw_work, cx25840_work_handler);\r\ninit_waitqueue_head(&state->fw_wait);\r\nq = create_singlethread_workqueue("cx25840_fw");\r\nprepare_to_wait(&state->fw_wait, &wait, TASK_UNINTERRUPTIBLE);\r\nqueue_work(q, &state->fw_work);\r\nschedule();\r\nfinish_wait(&state->fw_wait, &wait);\r\ndestroy_workqueue(q);\r\ncx25840_std_setup(client);\r\nset_input(client, state->vid_input, state->aud_input);\r\ncx25840_and_or(client, 0x803, ~0x10, 0x10);\r\ncx25840_write4(client, CX25840_VID_INT_STAT_REG, 0xffffffff);\r\ncx25840_write(client, CX25840_AUD_INT_CTRL_REG, 0xff);\r\ncx25840_write(client, CX25840_AUD_INT_STAT_REG, 0xff);\r\n}\r\nstatic void cx231xx_initialize(struct i2c_client *client)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nstruct workqueue_struct *q;\r\ncx25840_and_or(client, 0x102, ~0x01, 0x01);\r\ncx25840_and_or(client, 0x102, ~0x01, 0x00);\r\ncx25840_and_or(client, 0x803, ~0x10, 0x00);\r\ncx25840_write(client, 0x398, 0);\r\ncx25840_write(client, 0x2, 0x76);\r\ncx25840_write(client, 0x1, 0x40);\r\ncx25840_write4(client, 0x33c, 0x00000001);\r\ncx25840_write4(client, 0x340, 0x0df7df83);\r\ncx25840_write4(client, 0x414, 0x00107d12);\r\ncx25840_write4(client, 0x420, 0x3d008282);\r\ncx25840_write(client, 0x102, 0x10);\r\ncx25840_write(client, 0x103, 0x11);\r\ncx25840_write(client, 0x400, 0);\r\ncx25840_write(client, 0x401, 0xe8);\r\nINIT_WORK(&state->fw_work, cx25840_work_handler);\r\ninit_waitqueue_head(&state->fw_wait);\r\nq = create_singlethread_workqueue("cx25840_fw");\r\nprepare_to_wait(&state->fw_wait, &wait, TASK_UNINTERRUPTIBLE);\r\nqueue_work(q, &state->fw_work);\r\nschedule();\r\nfinish_wait(&state->fw_wait, &wait);\r\ndestroy_workqueue(q);\r\ncx25840_std_setup(client);\r\nset_input(client, state->vid_input, state->aud_input);\r\ncx25840_and_or(client, 0x803, ~0x10, 0x10);\r\n}\r\nvoid cx25840_std_setup(struct i2c_client *client)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nv4l2_std_id std = state->std;\r\nint hblank, hactive, burst, vblank, vactive, sc;\r\nint vblank656, src_decimation;\r\nint luma_lpf, uv_lpf, comb;\r\nu32 pll_int, pll_frac, pll_post;\r\nif (std & ~V4L2_STD_NTSC)\r\ncx25840_write(client, 0x49f, 0x11);\r\nelse\r\ncx25840_write(client, 0x49f, 0x14);\r\nif (std & V4L2_STD_625_50) {\r\nhblank = 132;\r\nhactive = 720;\r\nburst = 93;\r\nvblank = 36;\r\nvactive = 580;\r\nvblank656 = 40;\r\nsrc_decimation = 0x21f;\r\nluma_lpf = 2;\r\nif (std & V4L2_STD_SECAM) {\r\nuv_lpf = 0;\r\ncomb = 0;\r\nsc = 0x0a425f;\r\n} else if (std == V4L2_STD_PAL_Nc) {\r\nuv_lpf = 1;\r\ncomb = 0x20;\r\nsc = 556453;\r\n} else {\r\nuv_lpf = 1;\r\ncomb = 0x20;\r\nsc = 688739;\r\n}\r\n} else {\r\nhactive = 720;\r\nhblank = 122;\r\nvactive = 487;\r\nluma_lpf = 1;\r\nuv_lpf = 1;\r\nsrc_decimation = 0x21f;\r\nif (std == V4L2_STD_PAL_60) {\r\nvblank = 26;\r\nvblank656 = 26;\r\nburst = 0x5b;\r\nluma_lpf = 2;\r\ncomb = 0x20;\r\nsc = 688739;\r\n} else if (std == V4L2_STD_PAL_M) {\r\nvblank = 20;\r\nvblank656 = 24;\r\nburst = 0x61;\r\ncomb = 0x20;\r\nsc = 555452;\r\n} else {\r\nvblank = 26;\r\nvblank656 = 26;\r\nburst = 0x5b;\r\ncomb = 0x66;\r\nsc = 556063;\r\n}\r\n}\r\nif (!is_cx231xx(state)) {\r\npll_int = cx25840_read(client, 0x108);\r\npll_frac = cx25840_read4(client, 0x10c) & 0x1ffffff;\r\npll_post = cx25840_read(client, 0x109);\r\nv4l_dbg(1, cx25840_debug, client,\r\n"PLL regs = int: %u, frac: %u, post: %u\n",\r\npll_int, pll_frac, pll_post);\r\nif (pll_post) {\r\nint fin, fsc;\r\nint pll = (28636363L * ((((u64)pll_int) << 25L) + pll_frac)) >> 25L;\r\npll /= pll_post;\r\nv4l_dbg(1, cx25840_debug, client, "PLL = %d.%06d MHz\n",\r\npll / 1000000, pll % 1000000);\r\nv4l_dbg(1, cx25840_debug, client, "PLL/8 = %d.%06d MHz\n",\r\npll / 8000000, (pll / 8) % 1000000);\r\nfin = ((u64)src_decimation * pll) >> 12;\r\nv4l_dbg(1, cx25840_debug, client,\r\n"ADC Sampling freq = %d.%06d MHz\n",\r\nfin / 1000000, fin % 1000000);\r\nfsc = (((u64)sc) * pll) >> 24L;\r\nv4l_dbg(1, cx25840_debug, client,\r\n"Chroma sub-carrier freq = %d.%06d MHz\n",\r\nfsc / 1000000, fsc % 1000000);\r\nv4l_dbg(1, cx25840_debug, client, "hblank %i, hactive %i, "\r\n"vblank %i, vactive %i, vblank656 %i, src_dec %i, "\r\n"burst 0x%02x, luma_lpf %i, uv_lpf %i, comb 0x%02x, "\r\n"sc 0x%06x\n",\r\nhblank, hactive, vblank, vactive, vblank656,\r\nsrc_decimation, burst, luma_lpf, uv_lpf, comb, sc);\r\n}\r\n}\r\ncx25840_write(client, 0x470, hblank);\r\ncx25840_write(client, 0x471,\r\n0xff & (((hblank >> 8) & 0x3) | (hactive << 4)));\r\ncx25840_write(client, 0x472, hactive >> 4);\r\ncx25840_write(client, 0x473, burst);\r\ncx25840_write(client, 0x474, vblank);\r\ncx25840_write(client, 0x475,\r\n0xff & (((vblank >> 8) & 0x3) | (vactive << 4)));\r\ncx25840_write(client, 0x476, vactive >> 4);\r\ncx25840_write(client, 0x477, vblank656);\r\ncx25840_write(client, 0x478, 0xff & src_decimation);\r\ncx25840_write(client, 0x479, 0xff & (src_decimation >> 8));\r\ncx25840_write(client, 0x47a, luma_lpf << 6 | ((uv_lpf << 4) & 0x30));\r\ncx25840_write(client, 0x47b, comb);\r\ncx25840_write(client, 0x47c, sc);\r\ncx25840_write(client, 0x47d, 0xff & sc >> 8);\r\ncx25840_write(client, 0x47e, 0xff & sc >> 16);\r\nif (std & V4L2_STD_625_50) {\r\ncx25840_write(client, 0x47f, 0x01);\r\nstate->vbi_line_offset = 5;\r\n} else {\r\ncx25840_write(client, 0x47f, 0x00);\r\nstate->vbi_line_offset = 8;\r\n}\r\n}\r\nstatic void input_change(struct i2c_client *client)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nv4l2_std_id std = state->std;\r\nif (std & V4L2_STD_SECAM) {\r\ncx25840_write(client, 0x402, 0);\r\n}\r\nelse {\r\ncx25840_write(client, 0x402, 0x04);\r\ncx25840_write(client, 0x49f, (std & V4L2_STD_NTSC) ? 0x14 : 0x11);\r\n}\r\ncx25840_and_or(client, 0x401, ~0x60, 0);\r\ncx25840_and_or(client, 0x401, ~0x60, 0x60);\r\nif (is_cx2583x(state))\r\nreturn;\r\ncx25840_and_or(client, 0x810, ~0x01, 1);\r\nif (state->radio) {\r\ncx25840_write(client, 0x808, 0xf9);\r\ncx25840_write(client, 0x80b, 0x00);\r\n}\r\nelse if (std & V4L2_STD_525_60) {\r\nint hw_fix = state->pvr150_workaround;\r\nif (std == V4L2_STD_NTSC_M_JP) {\r\ncx25840_write(client, 0x808, hw_fix ? 0x2f : 0xf7);\r\n} else if (std == V4L2_STD_NTSC_M_KR) {\r\ncx25840_write(client, 0x808, hw_fix ? 0x3f : 0xf8);\r\n} else {\r\ncx25840_write(client, 0x808, hw_fix ? 0x1f : 0xf6);\r\n}\r\ncx25840_write(client, 0x80b, 0x00);\r\n} else if (std & V4L2_STD_PAL) {\r\ncx25840_write(client, 0x808, 0xff);\r\ncx25840_write(client, 0x80b, 0x00);\r\n} else if (std & V4L2_STD_SECAM) {\r\ncx25840_write(client, 0x808, 0xff);\r\nif ((std & V4L2_STD_SECAM_DK) &&\r\n!(std & (V4L2_STD_SECAM_L | V4L2_STD_SECAM_LC))) {\r\ncx25840_write(client, 0x80b, 0x00);\r\n} else if (!(std & V4L2_STD_SECAM_DK) &&\r\n(std & (V4L2_STD_SECAM_L | V4L2_STD_SECAM_LC))) {\r\ncx25840_write(client, 0x80b, 0x08);\r\n} else {\r\ncx25840_write(client, 0x80b, 0x10);\r\n}\r\n}\r\ncx25840_and_or(client, 0x810, ~0x01, 0);\r\n}\r\nstatic int set_input(struct i2c_client *client, enum cx25840_video_input vid_input,\r\nenum cx25840_audio_input aud_input)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nu8 is_composite = (vid_input >= CX25840_COMPOSITE1 &&\r\nvid_input <= CX25840_COMPOSITE8);\r\nu8 is_component = (vid_input & CX25840_COMPONENT_ON) ==\r\nCX25840_COMPONENT_ON;\r\nint luma = vid_input & 0xf0;\r\nint chroma = vid_input & 0xf00;\r\nu8 reg;\r\nv4l_dbg(1, cx25840_debug, client,\r\n"decoder set video input %d, audio input %d\n",\r\nvid_input, aud_input);\r\nif (vid_input >= CX25840_VIN1_CH1) {\r\nv4l_dbg(1, cx25840_debug, client, "vid_input 0x%x\n",\r\nvid_input);\r\nreg = vid_input & 0xff;\r\nis_composite = !is_component &&\r\n((vid_input & CX25840_SVIDEO_ON) != CX25840_SVIDEO_ON);\r\nv4l_dbg(1, cx25840_debug, client, "mux cfg 0x%x comp=%d\n",\r\nreg, is_composite);\r\n} else if (is_composite) {\r\nreg = 0xf0 + (vid_input - CX25840_COMPOSITE1);\r\n} else {\r\nif ((vid_input & ~0xff0) ||\r\nluma < CX25840_SVIDEO_LUMA1 || luma > CX25840_SVIDEO_LUMA8 ||\r\nchroma < CX25840_SVIDEO_CHROMA4 || chroma > CX25840_SVIDEO_CHROMA8) {\r\nv4l_err(client, "0x%04x is not a valid video input!\n",\r\nvid_input);\r\nreturn -EINVAL;\r\n}\r\nreg = 0xf0 + ((luma - CX25840_SVIDEO_LUMA1) >> 4);\r\nif (chroma >= CX25840_SVIDEO_CHROMA7) {\r\nreg &= 0x3f;\r\nreg |= (chroma - CX25840_SVIDEO_CHROMA7) >> 2;\r\n} else {\r\nreg &= 0xcf;\r\nreg |= (chroma - CX25840_SVIDEO_CHROMA4) >> 4;\r\n}\r\n}\r\nif (!is_cx2388x(state) && !is_cx231xx(state)) {\r\nswitch (aud_input) {\r\ncase CX25840_AUDIO_SERIAL:\r\nbreak;\r\ncase CX25840_AUDIO4: reg &= ~0x30; break;\r\ncase CX25840_AUDIO5: reg &= ~0x30; reg |= 0x10; break;\r\ncase CX25840_AUDIO6: reg &= ~0x30; reg |= 0x20; break;\r\ncase CX25840_AUDIO7: reg &= ~0xc0; break;\r\ncase CX25840_AUDIO8: reg &= ~0xc0; reg |= 0x40; break;\r\ndefault:\r\nv4l_err(client, "0x%04x is not a valid audio input!\n",\r\naud_input);\r\nreturn -EINVAL;\r\n}\r\n}\r\ncx25840_write(client, 0x103, reg);\r\nif (is_component)\r\ncx25840_and_or(client, 0x401, ~0x6, 0x6);\r\nelse\r\ncx25840_and_or(client, 0x401, ~0x6, is_composite ? 0 : 0x02);\r\nif (!is_cx2388x(state) && !is_cx231xx(state)) {\r\ncx25840_and_or(client, 0x102, ~0x2, (reg & 0x80) == 0 ? 2 : 0);\r\nif ((reg & 0xc0) != 0xc0 && (reg & 0x30) != 0x30)\r\ncx25840_and_or(client, 0x102, ~0x4, 4);\r\nelse\r\ncx25840_and_or(client, 0x102, ~0x4, 0);\r\n} else {\r\ncx25840_and_or(client, 0x102, ~0x4, is_component ? 0x4 : 0x0);\r\nif (is_composite) {\r\ncx25840_and_or(client, 0x102, ~0x2, 0);\r\n} else if (!is_component) {\r\nif (chroma >= CX25840_SVIDEO_CHROMA7) {\r\ncx25840_and_or(client, 0x102, ~0x2, 2);\r\n} else {\r\ncx25840_and_or(client, 0x102, ~0x2, 0);\r\n}\r\n}\r\n}\r\nstate->vid_input = vid_input;\r\nstate->aud_input = aud_input;\r\ncx25840_audio_set_path(client);\r\ninput_change(client);\r\nif (is_cx2388x(state)) {\r\ncx25840_write(client, 0x124, 0x03);\r\ncx25840_write(client, 0x144, 0x05);\r\ncx25840_write(client, 0x914, 0xa0);\r\ncx25840_write(client, 0x918, 0xa0);\r\ncx25840_write(client, 0x919, 0x01);\r\n} else if (is_cx231xx(state)) {\r\ncx25840_write(client, 0x124, 0x03);\r\ncx25840_write(client, 0x914, 0xa0);\r\ncx25840_write(client, 0x918, 0xa0);\r\ncx25840_write(client, 0x919, 0x01);\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_v4lstd(struct i2c_client *client)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nu8 fmt = 0;\r\nu8 pal_m = 0;\r\nif (state->std == V4L2_STD_NTSC_M_JP) {\r\nfmt = 0x2;\r\n} else if (state->std == V4L2_STD_NTSC_443) {\r\nfmt = 0x3;\r\n} else if (state->std == V4L2_STD_PAL_M) {\r\npal_m = 1;\r\nfmt = 0x5;\r\n} else if (state->std == V4L2_STD_PAL_N) {\r\nfmt = 0x6;\r\n} else if (state->std == V4L2_STD_PAL_Nc) {\r\nfmt = 0x7;\r\n} else if (state->std == V4L2_STD_PAL_60) {\r\nfmt = 0x8;\r\n} else {\r\nif (state->std & V4L2_STD_NTSC)\r\nfmt = 0x1;\r\nelse if (state->std & V4L2_STD_PAL)\r\nfmt = 0x4;\r\nelse if (state->std & V4L2_STD_SECAM)\r\nfmt = 0xc;\r\n}\r\nv4l_dbg(1, cx25840_debug, client, "changing video std to fmt %i\n",fmt);\r\nif (fmt >= 4 && fmt < 8) {\r\ncx25840_and_or(client, 0x400, ~0xf, 1);\r\ncx25840_and_or(client, 0x47b, ~6, 0);\r\n}\r\ncx25840_and_or(client, 0x400, ~0xf, fmt);\r\ncx25840_and_or(client, 0x403, ~0x3, pal_m);\r\ncx25840_std_setup(client);\r\nif (!is_cx2583x(state))\r\ninput_change(client);\r\nreturn 0;\r\n}\r\nstatic int cx25840_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncx25840_write(client, 0x414, ctrl->val - 128);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ncx25840_write(client, 0x415, ctrl->val << 1);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ncx25840_write(client, 0x420, ctrl->val << 1);\r\ncx25840_write(client, 0x421, ctrl->val << 1);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ncx25840_write(client, 0x422, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx25840_s_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint HSC, VSC, Vsrc, Hsrc, filter, Vlines;\r\nint is_50Hz = !(state->std & V4L2_STD_525_60);\r\nif (fmt->code != V4L2_MBUS_FMT_FIXED)\r\nreturn -EINVAL;\r\nfmt->field = V4L2_FIELD_INTERLACED;\r\nfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nVsrc = (cx25840_read(client, 0x476) & 0x3f) << 4;\r\nVsrc |= (cx25840_read(client, 0x475) & 0xf0) >> 4;\r\nHsrc = (cx25840_read(client, 0x472) & 0x3f) << 4;\r\nHsrc |= (cx25840_read(client, 0x471) & 0xf0) >> 4;\r\nVlines = fmt->height + (is_50Hz ? 4 : 7);\r\nif ((fmt->width * 16 < Hsrc) || (Hsrc < fmt->width) ||\r\n(Vlines * 8 < Vsrc) || (Vsrc < Vlines)) {\r\nv4l_err(client, "%dx%d is not a valid size!\n",\r\nfmt->width, fmt->height);\r\nreturn -ERANGE;\r\n}\r\nHSC = (Hsrc * (1 << 20)) / fmt->width - (1 << 20);\r\nVSC = (1 << 16) - (Vsrc * (1 << 9) / Vlines - (1 << 9));\r\nVSC &= 0x1fff;\r\nif (fmt->width >= 385)\r\nfilter = 0;\r\nelse if (fmt->width > 192)\r\nfilter = 1;\r\nelse if (fmt->width > 96)\r\nfilter = 2;\r\nelse\r\nfilter = 3;\r\nv4l_dbg(1, cx25840_debug, client, "decoder set size %dx%d -> scale %ux%u\n",\r\nfmt->width, fmt->height, HSC, VSC);\r\ncx25840_write(client, 0x418, HSC & 0xff);\r\ncx25840_write(client, 0x419, (HSC >> 8) & 0xff);\r\ncx25840_write(client, 0x41a, HSC >> 16);\r\ncx25840_write(client, 0x41c, VSC & 0xff);\r\ncx25840_write(client, 0x41d, VSC >> 8);\r\ncx25840_write(client, 0x41e, 0x8 | filter);\r\nreturn 0;\r\n}\r\nstatic void log_video_status(struct i2c_client *client)\r\n{\r\nstatic const char *const fmt_strs[] = {\r\n"0x0",\r\n"NTSC-M", "NTSC-J", "NTSC-4.43",\r\n"PAL-BDGHI", "PAL-M", "PAL-N", "PAL-Nc", "PAL-60",\r\n"0x9", "0xA", "0xB",\r\n"SECAM",\r\n"0xD", "0xE", "0xF"\r\n};\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nu8 vidfmt_sel = cx25840_read(client, 0x400) & 0xf;\r\nu8 gen_stat1 = cx25840_read(client, 0x40d);\r\nu8 gen_stat2 = cx25840_read(client, 0x40e);\r\nint vid_input = state->vid_input;\r\nv4l_info(client, "Video signal: %spresent\n",\r\n(gen_stat2 & 0x20) ? "" : "not ");\r\nv4l_info(client, "Detected format: %s\n",\r\nfmt_strs[gen_stat1 & 0xf]);\r\nv4l_info(client, "Specified standard: %s\n",\r\nvidfmt_sel ? fmt_strs[vidfmt_sel] : "automatic detection");\r\nif (vid_input >= CX25840_COMPOSITE1 &&\r\nvid_input <= CX25840_COMPOSITE8) {\r\nv4l_info(client, "Specified video input: Composite %d\n",\r\nvid_input - CX25840_COMPOSITE1 + 1);\r\n} else {\r\nv4l_info(client, "Specified video input: S-Video (Luma In%d, Chroma In%d)\n",\r\n(vid_input & 0xf0) >> 4, (vid_input & 0xf00) >> 8);\r\n}\r\nv4l_info(client, "Specified audioclock freq: %d Hz\n", state->audclk_freq);\r\n}\r\nstatic void log_audio_status(struct i2c_client *client)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nu8 download_ctl = cx25840_read(client, 0x803);\r\nu8 mod_det_stat0 = cx25840_read(client, 0x804);\r\nu8 mod_det_stat1 = cx25840_read(client, 0x805);\r\nu8 audio_config = cx25840_read(client, 0x808);\r\nu8 pref_mode = cx25840_read(client, 0x809);\r\nu8 afc0 = cx25840_read(client, 0x80b);\r\nu8 mute_ctl = cx25840_read(client, 0x8d3);\r\nint aud_input = state->aud_input;\r\nchar *p;\r\nswitch (mod_det_stat0) {\r\ncase 0x00: p = "mono"; break;\r\ncase 0x01: p = "stereo"; break;\r\ncase 0x02: p = "dual"; break;\r\ncase 0x04: p = "tri"; break;\r\ncase 0x10: p = "mono with SAP"; break;\r\ncase 0x11: p = "stereo with SAP"; break;\r\ncase 0x12: p = "dual with SAP"; break;\r\ncase 0x14: p = "tri with SAP"; break;\r\ncase 0xfe: p = "forced mode"; break;\r\ndefault: p = "not defined";\r\n}\r\nv4l_info(client, "Detected audio mode: %s\n", p);\r\nswitch (mod_det_stat1) {\r\ncase 0x00: p = "not defined"; break;\r\ncase 0x01: p = "EIAJ"; break;\r\ncase 0x02: p = "A2-M"; break;\r\ncase 0x03: p = "A2-BG"; break;\r\ncase 0x04: p = "A2-DK1"; break;\r\ncase 0x05: p = "A2-DK2"; break;\r\ncase 0x06: p = "A2-DK3"; break;\r\ncase 0x07: p = "A1 (6.0 MHz FM Mono)"; break;\r\ncase 0x08: p = "AM-L"; break;\r\ncase 0x09: p = "NICAM-BG"; break;\r\ncase 0x0a: p = "NICAM-DK"; break;\r\ncase 0x0b: p = "NICAM-I"; break;\r\ncase 0x0c: p = "NICAM-L"; break;\r\ncase 0x0d: p = "BTSC/EIAJ/A2-M Mono (4.5 MHz FMMono)"; break;\r\ncase 0x0e: p = "IF FM Radio"; break;\r\ncase 0x0f: p = "BTSC"; break;\r\ncase 0x10: p = "high-deviation FM"; break;\r\ncase 0x11: p = "very high-deviation FM"; break;\r\ncase 0xfd: p = "unknown audio standard"; break;\r\ncase 0xfe: p = "forced audio standard"; break;\r\ncase 0xff: p = "no detected audio standard"; break;\r\ndefault: p = "not defined";\r\n}\r\nv4l_info(client, "Detected audio standard: %s\n", p);\r\nv4l_info(client, "Audio microcontroller: %s\n",\r\n(download_ctl & 0x10) ?\r\n((mute_ctl & 0x2) ? "detecting" : "running") : "stopped");\r\nswitch (audio_config >> 4) {\r\ncase 0x00: p = "undefined"; break;\r\ncase 0x01: p = "BTSC"; break;\r\ncase 0x02: p = "EIAJ"; break;\r\ncase 0x03: p = "A2-M"; break;\r\ncase 0x04: p = "A2-BG"; break;\r\ncase 0x05: p = "A2-DK1"; break;\r\ncase 0x06: p = "A2-DK2"; break;\r\ncase 0x07: p = "A2-DK3"; break;\r\ncase 0x08: p = "A1 (6.0 MHz FM Mono)"; break;\r\ncase 0x09: p = "AM-L"; break;\r\ncase 0x0a: p = "NICAM-BG"; break;\r\ncase 0x0b: p = "NICAM-DK"; break;\r\ncase 0x0c: p = "NICAM-I"; break;\r\ncase 0x0d: p = "NICAM-L"; break;\r\ncase 0x0e: p = "FM radio"; break;\r\ncase 0x0f: p = "automatic detection"; break;\r\ndefault: p = "undefined";\r\n}\r\nv4l_info(client, "Configured audio standard: %s\n", p);\r\nif ((audio_config >> 4) < 0xF) {\r\nswitch (audio_config & 0xF) {\r\ncase 0x00: p = "MONO1 (LANGUAGE A/Mono L+R channel for BTSC, EIAJ, A2)"; break;\r\ncase 0x01: p = "MONO2 (LANGUAGE B)"; break;\r\ncase 0x02: p = "MONO3 (STEREO forced MONO)"; break;\r\ncase 0x03: p = "MONO4 (NICAM ANALOG-Language C/Analog Fallback)"; break;\r\ncase 0x04: p = "STEREO"; break;\r\ncase 0x05: p = "DUAL1 (AB)"; break;\r\ncase 0x06: p = "DUAL2 (AC) (FM)"; break;\r\ncase 0x07: p = "DUAL3 (BC) (FM)"; break;\r\ncase 0x08: p = "DUAL4 (AC) (AM)"; break;\r\ncase 0x09: p = "DUAL5 (BC) (AM)"; break;\r\ncase 0x0a: p = "SAP"; break;\r\ndefault: p = "undefined";\r\n}\r\nv4l_info(client, "Configured audio mode: %s\n", p);\r\n} else {\r\nswitch (audio_config & 0xF) {\r\ncase 0x00: p = "BG"; break;\r\ncase 0x01: p = "DK1"; break;\r\ncase 0x02: p = "DK2"; break;\r\ncase 0x03: p = "DK3"; break;\r\ncase 0x04: p = "I"; break;\r\ncase 0x05: p = "L"; break;\r\ncase 0x06: p = "BTSC"; break;\r\ncase 0x07: p = "EIAJ"; break;\r\ncase 0x08: p = "A2-M"; break;\r\ncase 0x09: p = "FM Radio"; break;\r\ncase 0x0f: p = "automatic standard and mode detection"; break;\r\ndefault: p = "undefined";\r\n}\r\nv4l_info(client, "Configured audio system: %s\n", p);\r\n}\r\nif (aud_input) {\r\nv4l_info(client, "Specified audio input: Tuner (In%d)\n", aud_input);\r\n} else {\r\nv4l_info(client, "Specified audio input: External\n");\r\n}\r\nswitch (pref_mode & 0xf) {\r\ncase 0: p = "mono/language A"; break;\r\ncase 1: p = "language B"; break;\r\ncase 2: p = "language C"; break;\r\ncase 3: p = "analog fallback"; break;\r\ncase 4: p = "stereo"; break;\r\ncase 5: p = "language AC"; break;\r\ncase 6: p = "language BC"; break;\r\ncase 7: p = "language AB"; break;\r\ndefault: p = "undefined";\r\n}\r\nv4l_info(client, "Preferred audio mode: %s\n", p);\r\nif ((audio_config & 0xf) == 0xf) {\r\nswitch ((afc0 >> 3) & 0x3) {\r\ncase 0: p = "system DK"; break;\r\ncase 1: p = "system L"; break;\r\ncase 2: p = "autodetect"; break;\r\ndefault: p = "undefined";\r\n}\r\nv4l_info(client, "Selected 65 MHz format: %s\n", p);\r\nswitch (afc0 & 0x7) {\r\ncase 0: p = "chroma"; break;\r\ncase 1: p = "BTSC"; break;\r\ncase 2: p = "EIAJ"; break;\r\ncase 3: p = "A2-M"; break;\r\ncase 4: p = "autodetect"; break;\r\ndefault: p = "undefined";\r\n}\r\nv4l_info(client, "Selected 45 MHz format: %s\n", p);\r\n}\r\n}\r\nstatic int cx25840_load_fw(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!state->is_initialized) {\r\nstate->is_initialized = 1;\r\nif (is_cx2583x(state))\r\ncx25836_initialize(client);\r\nelse if (is_cx2388x(state))\r\ncx23885_initialize(client);\r\nelse if (is_cx231xx(state))\r\ncx231xx_initialize(client);\r\nelse\r\ncx25840_initialize(client);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx25840_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->size = 1;\r\nreg->val = cx25840_read(client, reg->reg & 0x0fff);\r\nreturn 0;\r\n}\r\nstatic int cx25840_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ncx25840_write(client, reg->reg & 0x0fff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int cx25840_s_audio_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 v;\r\nif (is_cx2583x(state) || is_cx2388x(state) || is_cx231xx(state))\r\nreturn 0;\r\nv4l_dbg(1, cx25840_debug, client, "%s audio output\n",\r\nenable ? "enable" : "disable");\r\nif (enable) {\r\nv = cx25840_read(client, 0x115) | 0x80;\r\ncx25840_write(client, 0x115, v);\r\nv = cx25840_read(client, 0x116) | 0x03;\r\ncx25840_write(client, 0x116, v);\r\n} else {\r\nv = cx25840_read(client, 0x115) & ~(0x80);\r\ncx25840_write(client, 0x115, v);\r\nv = cx25840_read(client, 0x116) & ~(0x03);\r\ncx25840_write(client, 0x116, v);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx25840_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 v;\r\nv4l_dbg(1, cx25840_debug, client, "%s video output\n",\r\nenable ? "enable" : "disable");\r\nif (enable) {\r\nif (is_cx2388x(state) || is_cx231xx(state)) {\r\nv = cx25840_read(client, 0x421) | 0x0b;\r\ncx25840_write(client, 0x421, v);\r\n} else {\r\nv = cx25840_read(client, 0x115) | 0x0c;\r\ncx25840_write(client, 0x115, v);\r\nv = cx25840_read(client, 0x116) | 0x04;\r\ncx25840_write(client, 0x116, v);\r\n}\r\n} else {\r\nif (is_cx2388x(state) || is_cx231xx(state)) {\r\nv = cx25840_read(client, 0x421) & ~(0x0b);\r\ncx25840_write(client, 0x421, v);\r\n} else {\r\nv = cx25840_read(client, 0x115) & ~(0x0c);\r\ncx25840_write(client, 0x115, v);\r\nv = cx25840_read(client, 0x116) & ~(0x04);\r\ncx25840_write(client, 0x116, v);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx25840_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (state->radio == 0 && state->std == std)\r\nreturn 0;\r\nstate->radio = 0;\r\nstate->std = std;\r\nreturn set_v4lstd(client);\r\n}\r\nstatic int cx25840_s_radio(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstate->radio = 1;\r\nreturn 0;\r\n}\r\nstatic int cx25840_s_video_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn set_input(client, input, state->aud_input);\r\n}\r\nstatic int cx25840_s_audio_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn set_input(client, state->vid_input, input);\r\n}\r\nstatic int cx25840_s_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *freq)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\ninput_change(client);\r\nreturn 0;\r\n}\r\nstatic int cx25840_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 vpres = cx25840_read(client, 0x40e) & 0x20;\r\nu8 mode;\r\nint val = 0;\r\nif (state->radio)\r\nreturn 0;\r\nvt->signal = vpres ? 0xffff : 0x0;\r\nif (is_cx2583x(state))\r\nreturn 0;\r\nvt->capability |=\r\nV4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LANG1 |\r\nV4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\r\nmode = cx25840_read(client, 0x804);\r\nif ((mode & 0xf) == 1)\r\nval |= V4L2_TUNER_SUB_STEREO;\r\nelse\r\nval |= V4L2_TUNER_SUB_MONO;\r\nif (mode == 2 || mode == 4)\r\nval = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\nif (mode & 0x10)\r\nval |= V4L2_TUNER_SUB_SAP;\r\nvt->rxsubchans = val;\r\nvt->audmode = state->audmode;\r\nreturn 0;\r\n}\r\nstatic int cx25840_s_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (state->radio || is_cx2583x(state))\r\nreturn 0;\r\nswitch (vt->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\ncx25840_and_or(client, 0x809, ~0xf, 0x00);\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\ncase V4L2_TUNER_MODE_LANG1:\r\ncx25840_and_or(client, 0x809, ~0xf, 0x04);\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\ncx25840_and_or(client, 0x809, ~0xf, 0x07);\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\ncx25840_and_or(client, 0x809, ~0xf, 0x01);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->audmode = vt->audmode;\r\nreturn 0;\r\n}\r\nstatic int cx25840_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (is_cx2583x(state))\r\ncx25836_initialize(client);\r\nelse if (is_cx2388x(state))\r\ncx23885_initialize(client);\r\nelse if (is_cx231xx(state))\r\ncx231xx_initialize(client);\r\nelse\r\ncx25840_initialize(client);\r\nreturn 0;\r\n}\r\nstatic int cx25840_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, state->id, state->rev);\r\n}\r\nstatic int cx25840_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nlog_video_status(client);\r\nif (!is_cx2583x(state))\r\nlog_audio_status(client);\r\ncx25840_ir_log_status(sd);\r\nv4l2_ctrl_handler_log_status(&state->hdl, sd->name);\r\nreturn 0;\r\n}\r\nstatic int cx23885_irq_handler(struct v4l2_subdev *sd, u32 status,\r\nbool *handled)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nu8 irq_stat, aud_stat, aud_en, ir_stat, ir_en;\r\nu32 vid_stat, aud_mc_stat;\r\nbool block_handled;\r\nint ret = 0;\r\nirq_stat = cx25840_read(c, CX23885_PIN_CTRL_IRQ_REG);\r\nv4l_dbg(2, cx25840_debug, c, "AV Core IRQ status (entry): %s %s %s\n",\r\nirq_stat & CX23885_PIN_CTRL_IRQ_IR_STAT ? "ir" : " ",\r\nirq_stat & CX23885_PIN_CTRL_IRQ_AUD_STAT ? "aud" : " ",\r\nirq_stat & CX23885_PIN_CTRL_IRQ_VID_STAT ? "vid" : " ");\r\nif ((is_cx23885(state) || is_cx23887(state))) {\r\nir_stat = cx25840_read(c, CX25840_IR_STATS_REG);\r\nir_en = cx25840_read(c, CX25840_IR_IRQEN_REG);\r\nv4l_dbg(2, cx25840_debug, c,\r\n"AV Core ir IRQ status: %#04x disables: %#04x\n",\r\nir_stat, ir_en);\r\nif (irq_stat & CX23885_PIN_CTRL_IRQ_IR_STAT) {\r\nblock_handled = false;\r\nret = cx25840_ir_irq_handler(sd,\r\nstatus, &block_handled);\r\nif (block_handled)\r\n*handled = true;\r\n}\r\n}\r\naud_stat = cx25840_read(c, CX25840_AUD_INT_STAT_REG);\r\naud_en = cx25840_read(c, CX25840_AUD_INT_CTRL_REG);\r\nv4l_dbg(2, cx25840_debug, c,\r\n"AV Core audio IRQ status: %#04x disables: %#04x\n",\r\naud_stat, aud_en);\r\naud_mc_stat = cx25840_read4(c, CX23885_AUD_MC_INT_MASK_REG);\r\nv4l_dbg(2, cx25840_debug, c,\r\n"AV Core audio MC IRQ status: %#06x enables: %#06x\n",\r\naud_mc_stat >> CX23885_AUD_MC_INT_STAT_SHFT,\r\naud_mc_stat & CX23885_AUD_MC_INT_CTRL_BITS);\r\nif (irq_stat & CX23885_PIN_CTRL_IRQ_AUD_STAT) {\r\nif (aud_stat) {\r\ncx25840_write(c, CX25840_AUD_INT_STAT_REG, aud_stat);\r\n*handled = true;\r\n}\r\n}\r\nvid_stat = cx25840_read4(c, CX25840_VID_INT_STAT_REG);\r\nv4l_dbg(2, cx25840_debug, c,\r\n"AV Core video IRQ status: %#06x disables: %#06x\n",\r\nvid_stat & CX25840_VID_INT_STAT_BITS,\r\nvid_stat >> CX25840_VID_INT_MASK_SHFT);\r\nif (irq_stat & CX23885_PIN_CTRL_IRQ_VID_STAT) {\r\nif (vid_stat & CX25840_VID_INT_STAT_BITS) {\r\ncx25840_write4(c, CX25840_VID_INT_STAT_REG, vid_stat);\r\n*handled = true;\r\n}\r\n}\r\nirq_stat = cx25840_read(c, CX23885_PIN_CTRL_IRQ_REG);\r\nv4l_dbg(2, cx25840_debug, c, "AV Core IRQ status (exit): %s %s %s\n",\r\nirq_stat & CX23885_PIN_CTRL_IRQ_IR_STAT ? "ir" : " ",\r\nirq_stat & CX23885_PIN_CTRL_IRQ_AUD_STAT ? "aud" : " ",\r\nirq_stat & CX23885_PIN_CTRL_IRQ_VID_STAT ? "vid" : " ");\r\nreturn ret;\r\n}\r\nstatic int cx25840_irq_handler(struct v4l2_subdev *sd, u32 status,\r\nbool *handled)\r\n{\r\nstruct cx25840_state *state = to_state(sd);\r\n*handled = false;\r\nif (is_cx2388x(state))\r\nreturn cx23885_irq_handler(sd, status, handled);\r\nreturn -ENODEV;\r\n}\r\nstatic u32 get_cx2388x_ident(struct i2c_client *client)\r\n{\r\nu32 ret;\r\ncx25840_write(client, 0x000, 0);\r\nif (cx25840_read4(client, 0x204) & 0xffff) {\r\nret = cx25840_read4(client, 0x300);\r\nif (((ret & 0xffff0000) >> 16) == (ret & 0xffff)) {\r\nret = V4L2_IDENT_CX23885_AV;\r\n} else {\r\nret = V4L2_IDENT_CX23887_AV;\r\n}\r\n} else if (cx25840_read4(client, 0x300) & 0x0fffffff) {\r\nret = V4L2_IDENT_CX23888_AV;\r\n} else {\r\nv4l_err(client, "Unable to detect h/w, assuming cx23887\n");\r\nret = V4L2_IDENT_CX23887_AV;\r\n}\r\ncx25840_write(client, 0x000, 2);\r\nreturn ret;\r\n}\r\nstatic int cx25840_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct cx25840_state *state;\r\nstruct v4l2_subdev *sd;\r\nint default_volume;\r\nu32 id = V4L2_IDENT_NONE;\r\nu16 device_id;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_dbg(1, cx25840_debug, client, "detecting cx25840 client on address 0x%x\n", client->addr << 1);\r\ndevice_id = cx25840_read(client, 0x101) << 8;\r\ndevice_id |= cx25840_read(client, 0x100);\r\nv4l_dbg(1, cx25840_debug, client, "device_id = 0x%04x\n", device_id);\r\nif ((device_id & 0xff00) == 0x8300) {\r\nid = V4L2_IDENT_CX25836 + ((device_id >> 4) & 0xf) - 6;\r\n} else if ((device_id & 0xff00) == 0x8400) {\r\nid = V4L2_IDENT_CX25840 + ((device_id >> 4) & 0xf);\r\n} else if (device_id == 0x0000) {\r\nid = get_cx2388x_ident(client);\r\n} else if ((device_id & 0xfff0) == 0x5A30) {\r\nid = V4L2_IDENT_CX2310X_AV;\r\n} else if ((device_id & 0xff) == (device_id >> 8)) {\r\nv4l_err(client,\r\n"likely a confused/unresponsive cx2388[578] A/V decoder"\r\n" found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nv4l_err(client, "A method to reset it from the cx25840 driver"\r\n" software is not known at this time\n");\r\nreturn -ENODEV;\r\n} else {\r\nv4l_dbg(1, cx25840_debug, client, "cx25840 not found\n");\r\nreturn -ENODEV;\r\n}\r\nstate = kzalloc(sizeof(struct cx25840_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &cx25840_ops);\r\nswitch (id) {\r\ncase V4L2_IDENT_CX23885_AV:\r\nv4l_info(client, "cx23885 A/V decoder found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nbreak;\r\ncase V4L2_IDENT_CX23887_AV:\r\nv4l_info(client, "cx23887 A/V decoder found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nbreak;\r\ncase V4L2_IDENT_CX23888_AV:\r\nv4l_info(client, "cx23888 A/V decoder found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nbreak;\r\ncase V4L2_IDENT_CX2310X_AV:\r\nv4l_info(client, "cx%d A/V decoder found @ 0x%x (%s)\n",\r\ndevice_id, client->addr << 1, client->adapter->name);\r\nbreak;\r\ncase V4L2_IDENT_CX25840:\r\ncase V4L2_IDENT_CX25841:\r\ncase V4L2_IDENT_CX25842:\r\ncase V4L2_IDENT_CX25843:\r\nv4l_info(client, "cx25%3x-2%x found @ 0x%x (%s)\n",\r\n(device_id & 0xfff0) >> 4,\r\n(device_id & 0x0f) < 3 ? (device_id & 0x0f) + 1\r\n: (device_id & 0x0f),\r\nclient->addr << 1, client->adapter->name);\r\nbreak;\r\ncase V4L2_IDENT_CX25836:\r\ncase V4L2_IDENT_CX25837:\r\ndefault:\r\nv4l_info(client, "cx25%3x-%x found @ 0x%x (%s)\n",\r\n(device_id & 0xfff0) >> 4, device_id & 0x0f,\r\nclient->addr << 1, client->adapter->name);\r\nbreak;\r\n}\r\nstate->c = client;\r\nstate->vid_input = CX25840_COMPOSITE7;\r\nstate->aud_input = CX25840_AUDIO8;\r\nstate->audclk_freq = 48000;\r\nstate->audmode = V4L2_TUNER_MODE_LANG1;\r\nstate->vbi_line_offset = 8;\r\nstate->id = id;\r\nstate->rev = device_id;\r\nv4l2_ctrl_handler_init(&state->hdl, 9);\r\nv4l2_ctrl_new_std(&state->hdl, &cx25840_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&state->hdl, &cx25840_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(&state->hdl, &cx25840_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(&state->hdl, &cx25840_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nif (!is_cx2583x(state)) {\r\ndefault_volume = cx25840_read(client, 0x8d4);\r\nif (default_volume > 228) {\r\ndefault_volume = 228;\r\ncx25840_write(client, 0x8d4, 228);\r\n}\r\nelse if (default_volume < 20) {\r\ndefault_volume = 20;\r\ncx25840_write(client, 0x8d4, 20);\r\n}\r\ndefault_volume = (((228 - default_volume) >> 1) + 23) << 9;\r\nstate->volume = v4l2_ctrl_new_std(&state->hdl,\r\n&cx25840_audio_ctrl_ops, V4L2_CID_AUDIO_VOLUME,\r\n0, 65535, 65535 / 100, default_volume);\r\nstate->mute = v4l2_ctrl_new_std(&state->hdl,\r\n&cx25840_audio_ctrl_ops, V4L2_CID_AUDIO_MUTE,\r\n0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&state->hdl, &cx25840_audio_ctrl_ops,\r\nV4L2_CID_AUDIO_BALANCE,\r\n0, 65535, 65535 / 100, 32768);\r\nv4l2_ctrl_new_std(&state->hdl, &cx25840_audio_ctrl_ops,\r\nV4L2_CID_AUDIO_BASS,\r\n0, 65535, 65535 / 100, 32768);\r\nv4l2_ctrl_new_std(&state->hdl, &cx25840_audio_ctrl_ops,\r\nV4L2_CID_AUDIO_TREBLE,\r\n0, 65535, 65535 / 100, 32768);\r\n}\r\nsd->ctrl_handler = &state->hdl;\r\nif (state->hdl.error) {\r\nint err = state->hdl.error;\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(state);\r\nreturn err;\r\n}\r\nif (!is_cx2583x(state))\r\nv4l2_ctrl_cluster(2, &state->volume);\r\nv4l2_ctrl_handler_setup(&state->hdl);\r\nif (client->dev.platform_data) {\r\nstruct cx25840_platform_data *pdata = client->dev.platform_data;\r\nstate->pvr150_workaround = pdata->pvr150_workaround;\r\n}\r\ncx25840_ir_probe(sd);\r\nreturn 0;\r\n}\r\nstatic int cx25840_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct cx25840_state *state = to_state(sd);\r\ncx25840_ir_remove(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic __init int init_cx25840(void)\r\n{\r\nreturn i2c_add_driver(&cx25840_driver);\r\n}\r\nstatic __exit void exit_cx25840(void)\r\n{\r\ni2c_del_driver(&cx25840_driver);\r\n}
