static void wa_notif_dispatch(struct work_struct *ws)\r\n{\r\nvoid *itr;\r\nu8 missing = 0;\r\nstruct wa_notif_work *nw = container_of(ws, struct wa_notif_work, work);\r\nstruct wahc *wa = nw->wa;\r\nstruct wa_notif_hdr *notif_hdr;\r\nsize_t size;\r\nstruct device *dev = &wa->usb_iface->dev;\r\n#if 0\r\nif (usb_hcd->state == HC_STATE_QUIESCING)\r\ngoto out;\r\n#endif\r\natomic_dec(&wa->notifs_queued);\r\ndev = &wa->usb_iface->dev;\r\nsize = nw->size;\r\nitr = nw->data;\r\nwhile (size) {\r\nif (size < sizeof(*notif_hdr)) {\r\nmissing = sizeof(*notif_hdr) - size;\r\ngoto exhausted_buffer;\r\n}\r\nnotif_hdr = itr;\r\nif (size < notif_hdr->bLength)\r\ngoto exhausted_buffer;\r\nitr += notif_hdr->bLength;\r\nsize -= notif_hdr->bLength;\r\nswitch (notif_hdr->bNotifyType) {\r\ncase HWA_NOTIF_DN: {\r\nstruct hwa_notif_dn *hwa_dn;\r\nhwa_dn = container_of(notif_hdr, struct hwa_notif_dn,\r\nhdr);\r\nwusbhc_handle_dn(wa->wusb, hwa_dn->bSourceDeviceAddr,\r\nhwa_dn->dndata,\r\nnotif_hdr->bLength - sizeof(*hwa_dn));\r\nbreak;\r\n}\r\ncase WA_NOTIF_TRANSFER:\r\nwa_handle_notif_xfer(wa, notif_hdr);\r\nbreak;\r\ncase DWA_NOTIF_RWAKE:\r\ncase DWA_NOTIF_PORTSTATUS:\r\ncase HWA_NOTIF_BPST_ADJ:\r\ndefault:\r\ndev_err(dev, "HWA: unknown notification 0x%x, "\r\n"%zu bytes; discarding\n",\r\nnotif_hdr->bNotifyType,\r\n(size_t)notif_hdr->bLength);\r\nbreak;\r\n}\r\n}\r\nout:\r\nwa_put(wa);\r\nkfree(nw);\r\nreturn;\r\nexhausted_buffer:\r\ndev_warn(dev, "HWA: device sent short notification, "\r\n"%d bytes missing; discarding %d bytes.\n",\r\nmissing, (int)size);\r\ngoto out;\r\n}\r\nstatic int wa_nep_queue(struct wahc *wa, size_t size)\r\n{\r\nint result = 0;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nstruct wa_notif_work *nw;\r\nBUG_ON(size > wa->nep_buffer_size);\r\nif (size == 0)\r\ngoto out;\r\nif (atomic_read(&wa->notifs_queued) > 200) {\r\nif (printk_ratelimit())\r\ndev_err(dev, "Too many notifications queued, "\r\n"throttling back\n");\r\ngoto out;\r\n}\r\nnw = kzalloc(sizeof(*nw) + size, GFP_ATOMIC);\r\nif (nw == NULL) {\r\nif (printk_ratelimit())\r\ndev_err(dev, "No memory to queue notification\n");\r\ngoto out;\r\n}\r\nINIT_WORK(&nw->work, wa_notif_dispatch);\r\nnw->wa = wa_get(wa);\r\nnw->size = size;\r\nmemcpy(nw->data, wa->nep_buffer, size);\r\natomic_inc(&wa->notifs_queued);\r\nqueue_work(wusbd, &nw->work);\r\nout:\r\nreturn result;\r\n}\r\nstatic void wa_nep_cb(struct urb *urb)\r\n{\r\nint result;\r\nstruct wahc *wa = urb->context;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nswitch (result = urb->status) {\r\ncase 0:\r\nresult = wa_nep_queue(wa, urb->actual_length);\r\nif (result < 0)\r\ndev_err(dev, "NEP: unable to process notification(s): "\r\n"%d\n", result);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "NEP: going down %d\n", urb->status);\r\ngoto out;\r\ndefault:\r\nif (edc_inc(&wa->nep_edc, EDC_MAX_ERRORS,\r\nEDC_ERROR_TIMEFRAME)) {\r\ndev_err(dev, "NEP: URB max acceptable errors "\r\n"exceeded, resetting device\n");\r\nwa_reset_all(wa);\r\ngoto out;\r\n}\r\ndev_err(dev, "NEP: URB error %d\n", urb->status);\r\n}\r\nresult = wa_nep_arm(wa, GFP_ATOMIC);\r\nif (result < 0) {\r\ndev_err(dev, "NEP: cannot submit URB: %d\n", result);\r\nwa_reset_all(wa);\r\n}\r\nout:\r\nreturn;\r\n}\r\nint wa_nep_create(struct wahc *wa, struct usb_interface *iface)\r\n{\r\nint result;\r\nstruct usb_endpoint_descriptor *epd;\r\nstruct usb_device *usb_dev = interface_to_usbdev(iface);\r\nstruct device *dev = &iface->dev;\r\nedc_init(&wa->nep_edc);\r\nepd = &iface->cur_altsetting->endpoint[0].desc;\r\nwa->nep_buffer_size = 1024;\r\nwa->nep_buffer = kmalloc(wa->nep_buffer_size, GFP_KERNEL);\r\nif (wa->nep_buffer == NULL) {\r\ndev_err(dev, "Unable to allocate notification's read buffer\n");\r\ngoto error_nep_buffer;\r\n}\r\nwa->nep_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (wa->nep_urb == NULL) {\r\ndev_err(dev, "Unable to allocate notification URB\n");\r\ngoto error_urb_alloc;\r\n}\r\nusb_fill_int_urb(wa->nep_urb, usb_dev,\r\nusb_rcvintpipe(usb_dev, epd->bEndpointAddress),\r\nwa->nep_buffer, wa->nep_buffer_size,\r\nwa_nep_cb, wa, epd->bInterval);\r\nresult = wa_nep_arm(wa, GFP_KERNEL);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot submit notification URB: %d\n", result);\r\ngoto error_nep_arm;\r\n}\r\nreturn 0;\r\nerror_nep_arm:\r\nusb_free_urb(wa->nep_urb);\r\nerror_urb_alloc:\r\nkfree(wa->nep_buffer);\r\nerror_nep_buffer:\r\nreturn -ENOMEM;\r\n}\r\nvoid wa_nep_destroy(struct wahc *wa)\r\n{\r\nwa_nep_disarm(wa);\r\nusb_free_urb(wa->nep_urb);\r\nkfree(wa->nep_buffer);\r\n}
