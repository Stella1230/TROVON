static int osd_uld_open(struct inode *inode, struct file *file)\r\n{\r\nstruct osd_uld_device *oud = container_of(inode->i_cdev,\r\nstruct osd_uld_device, cdev);\r\nget_device(&oud->class_dev);\r\nfile->private_data = oud;\r\nOSD_DEBUG("osd_uld_open %p\n", oud);\r\nreturn 0;\r\n}\r\nstatic int osd_uld_release(struct inode *inode, struct file *file)\r\n{\r\nstruct osd_uld_device *oud = file->private_data;\r\nOSD_DEBUG("osd_uld_release %p\n", file->private_data);\r\nfile->private_data = NULL;\r\nput_device(&oud->class_dev);\r\nreturn 0;\r\n}\r\nint osduld_register_test(unsigned ioctl, do_test_fn *do_test)\r\n{\r\nif (g_test_ioctl)\r\nreturn -EINVAL;\r\ng_test_ioctl = ioctl;\r\ng_do_test = do_test;\r\nreturn 0;\r\n}\r\nvoid osduld_unregister_test(unsigned ioctl)\r\n{\r\nif (ioctl == g_test_ioctl) {\r\ng_test_ioctl = 0;\r\ng_do_test = NULL;\r\n}\r\n}\r\nstatic do_test_fn *_find_ioctl(unsigned cmd)\r\n{\r\nif (g_test_ioctl == cmd)\r\nreturn g_do_test;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic long osd_uld_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct osd_uld_device *oud = file->private_data;\r\nint ret;\r\ndo_test_fn *do_test;\r\ndo_test = _find_ioctl(cmd);\r\nif (do_test)\r\nret = do_test(&oud->od, cmd, arg);\r\nelse {\r\nOSD_ERR("Unknown ioctl %d: osd_uld_device=%p\n", cmd, oud);\r\nret = -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}\r\nstruct osd_dev *osduld_path_lookup(const char *name)\r\n{\r\nstruct osd_uld_device *oud;\r\nstruct osd_dev_handle *odh;\r\nstruct file *file;\r\nint error;\r\nif (!name || !*name) {\r\nOSD_ERR("Mount with !path || !*path\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nodh = kzalloc(sizeof(*odh), GFP_KERNEL);\r\nif (unlikely(!odh))\r\nreturn ERR_PTR(-ENOMEM);\r\nfile = filp_open(name, O_RDWR, 0);\r\nif (IS_ERR(file)) {\r\nerror = PTR_ERR(file);\r\ngoto free_od;\r\n}\r\nif (file->f_op != &osd_fops){\r\nerror = -EINVAL;\r\ngoto close_file;\r\n}\r\noud = file->private_data;\r\nodh->od = oud->od;\r\nodh->file = file;\r\nodh->oud = oud;\r\nreturn &odh->od;\r\nclose_file:\r\nfput(file);\r\nfree_od:\r\nkfree(odh);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic inline bool _the_same_or_null(const u8 *a1, unsigned a1_len,\r\nconst u8 *a2, unsigned a2_len)\r\n{\r\nif (!a2_len)\r\nreturn true;\r\nif (a1_len != a2_len)\r\nreturn false;\r\nreturn 0 == memcmp(a1, a2, a1_len);\r\n}\r\nint _mach_odi(struct device *dev, void *find_data)\r\n{\r\nstruct osd_uld_device *oud = container_of(dev, struct osd_uld_device,\r\nclass_dev);\r\nstruct find_oud_t *fot = find_data;\r\nconst struct osd_dev_info *odi = fot->odi;\r\nif (_the_same_or_null(oud->odi.systemid, oud->odi.systemid_len,\r\nodi->systemid, odi->systemid_len) &&\r\n_the_same_or_null(oud->odi.osdname, oud->odi.osdname_len,\r\nodi->osdname, odi->osdname_len)) {\r\nOSD_DEBUG("found device sysid_len=%d osdname=%d\n",\r\nodi->systemid_len, odi->osdname_len);\r\nfot->oud = oud;\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstruct osd_dev *osduld_info_lookup(const struct osd_dev_info *odi)\r\n{\r\nstruct find_oud_t find = {.odi = odi};\r\nfind.dev = class_find_device(&osd_uld_class, NULL, &find, _mach_odi);\r\nif (likely(find.dev)) {\r\nstruct osd_dev_handle *odh = kzalloc(sizeof(*odh), GFP_KERNEL);\r\nif (unlikely(!odh)) {\r\nput_device(find.dev);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nodh->od = find.oud->od;\r\nodh->oud = find.oud;\r\nreturn &odh->od;\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nvoid osduld_put_device(struct osd_dev *od)\r\n{\r\nif (od && !IS_ERR(od)) {\r\nstruct osd_dev_handle *odh =\r\ncontainer_of(od, struct osd_dev_handle, od);\r\nstruct osd_uld_device *oud = odh->oud;\r\nBUG_ON(od->scsi_device != oud->od.scsi_device);\r\nif (odh->file) {\r\nget_device(&oud->class_dev);\r\nfput(odh->file);\r\n}\r\nput_device(&oud->class_dev);\r\nkfree(odh);\r\n}\r\n}\r\nconst struct osd_dev_info *osduld_device_info(struct osd_dev *od)\r\n{\r\nstruct osd_dev_handle *odh =\r\ncontainer_of(od, struct osd_dev_handle, od);\r\nreturn &odh->oud->odi;\r\n}\r\nbool osduld_device_same(struct osd_dev *od, const struct osd_dev_info *odi)\r\n{\r\nstruct osd_dev_handle *odh =\r\ncontainer_of(od, struct osd_dev_handle, od);\r\nstruct osd_uld_device *oud = odh->oud;\r\nreturn (oud->odi.systemid_len == odi->systemid_len) &&\r\n_the_same_or_null(oud->odi.systemid, oud->odi.systemid_len,\r\nodi->systemid, odi->systemid_len) &&\r\n(oud->odi.osdname_len == odi->osdname_len) &&\r\n_the_same_or_null(oud->odi.osdname, oud->odi.osdname_len,\r\nodi->osdname, odi->osdname_len);\r\n}\r\nstatic int __detect_osd(struct osd_uld_device *oud)\r\n{\r\nstruct scsi_device *scsi_device = oud->od.scsi_device;\r\nchar caps[OSD_CAP_LEN];\r\nint error;\r\nOSD_DEBUG("start scsi_test_unit_ready %p %p %p\n",\r\noud, scsi_device, scsi_device->request_queue);\r\nerror = scsi_test_unit_ready(scsi_device, 10*HZ, 5, NULL);\r\nif (error)\r\nOSD_ERR("warning: scsi_test_unit_ready failed\n");\r\nosd_sec_init_nosec_doall_caps(caps, &osd_root_object, false, true);\r\nif (osd_auto_detect_ver(&oud->od, caps, &oud->odi))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __remove(struct device *dev)\r\n{\r\nstruct osd_uld_device *oud = container_of(dev, struct osd_uld_device,\r\nclass_dev);\r\nstruct scsi_device *scsi_device = oud->od.scsi_device;\r\nkfree(oud->odi.osdname);\r\nif (oud->cdev.owner)\r\ncdev_del(&oud->cdev);\r\nosd_dev_fini(&oud->od);\r\nscsi_device_put(scsi_device);\r\nOSD_INFO("osd_remove %s\n",\r\noud->disk ? oud->disk->disk_name : NULL);\r\nif (oud->disk)\r\nput_disk(oud->disk);\r\nida_remove(&osd_minor_ida, oud->minor);\r\nkfree(oud);\r\n}\r\nstatic int osd_probe(struct device *dev)\r\n{\r\nstruct scsi_device *scsi_device = to_scsi_device(dev);\r\nstruct gendisk *disk;\r\nstruct osd_uld_device *oud;\r\nint minor;\r\nint error;\r\nif (scsi_device->type != TYPE_OSD)\r\nreturn -ENODEV;\r\ndo {\r\nif (!ida_pre_get(&osd_minor_ida, GFP_KERNEL))\r\nreturn -ENODEV;\r\nerror = ida_get_new(&osd_minor_ida, &minor);\r\n} while (error == -EAGAIN);\r\nif (error)\r\nreturn error;\r\nif (minor >= SCSI_OSD_MAX_MINOR) {\r\nerror = -EBUSY;\r\ngoto err_retract_minor;\r\n}\r\nerror = -ENOMEM;\r\noud = kzalloc(sizeof(*oud), GFP_KERNEL);\r\nif (NULL == oud)\r\ngoto err_retract_minor;\r\ndev_set_drvdata(dev, oud);\r\noud->minor = minor;\r\ndisk = alloc_disk(1);\r\nif (!disk) {\r\nOSD_ERR("alloc_disk failed\n");\r\ngoto err_free_osd;\r\n}\r\ndisk->major = SCSI_OSD_MAJOR;\r\ndisk->first_minor = oud->minor;\r\nsprintf(disk->disk_name, "osd%d", oud->minor);\r\noud->disk = disk;\r\nscsi_device_get(scsi_device);\r\nosd_dev_init(&oud->od, scsi_device);\r\nerror = __detect_osd(oud);\r\nif (error) {\r\nOSD_ERR("osd detection failed, non-compatible OSD device\n");\r\ngoto err_put_disk;\r\n}\r\ncdev_init(&oud->cdev, &osd_fops);\r\noud->cdev.owner = THIS_MODULE;\r\nerror = cdev_add(&oud->cdev,\r\nMKDEV(SCSI_OSD_MAJOR, oud->minor), 1);\r\nif (error) {\r\nOSD_ERR("cdev_add failed\n");\r\ngoto err_put_disk;\r\n}\r\noud->class_dev.devt = oud->cdev.dev;\r\noud->class_dev.class = &osd_uld_class;\r\noud->class_dev.parent = dev;\r\noud->class_dev.release = __remove;\r\nerror = dev_set_name(&oud->class_dev, disk->disk_name);\r\nif (error) {\r\nOSD_ERR("dev_set_name failed => %d\n", error);\r\ngoto err_put_cdev;\r\n}\r\nerror = device_register(&oud->class_dev);\r\nif (error) {\r\nOSD_ERR("device_register failed => %d\n", error);\r\ngoto err_put_cdev;\r\n}\r\nget_device(&oud->class_dev);\r\nOSD_INFO("osd_probe %s\n", disk->disk_name);\r\nreturn 0;\r\nerr_put_cdev:\r\ncdev_del(&oud->cdev);\r\nerr_put_disk:\r\nscsi_device_put(scsi_device);\r\nput_disk(disk);\r\nerr_free_osd:\r\ndev_set_drvdata(dev, NULL);\r\nkfree(oud);\r\nerr_retract_minor:\r\nida_remove(&osd_minor_ida, minor);\r\nreturn error;\r\n}\r\nstatic int osd_remove(struct device *dev)\r\n{\r\nstruct scsi_device *scsi_device = to_scsi_device(dev);\r\nstruct osd_uld_device *oud = dev_get_drvdata(dev);\r\nif (!oud || (oud->od.scsi_device != scsi_device)) {\r\nOSD_ERR("Half cooked osd-device %p,%p || %p!=%p",\r\ndev, oud, oud ? oud->od.scsi_device : NULL,\r\nscsi_device);\r\n}\r\ndevice_unregister(&oud->class_dev);\r\nput_device(&oud->class_dev);\r\nreturn 0;\r\n}\r\nstatic int __init osd_uld_init(void)\r\n{\r\nint err;\r\nerr = class_register(&osd_uld_class);\r\nif (err) {\r\nOSD_ERR("Unable to register sysfs class => %d\n", err);\r\nreturn err;\r\n}\r\nerr = register_chrdev_region(MKDEV(SCSI_OSD_MAJOR, 0),\r\nSCSI_OSD_MAX_MINOR, osd_name);\r\nif (err) {\r\nOSD_ERR("Unable to register major %d for osd ULD => %d\n",\r\nSCSI_OSD_MAJOR, err);\r\ngoto err_out;\r\n}\r\nerr = scsi_register_driver(&osd_driver.gendrv);\r\nif (err) {\r\nOSD_ERR("scsi_register_driver failed => %d\n", err);\r\ngoto err_out_chrdev;\r\n}\r\nOSD_INFO("LOADED %s\n", osd_version_string);\r\nreturn 0;\r\nerr_out_chrdev:\r\nunregister_chrdev_region(MKDEV(SCSI_OSD_MAJOR, 0), SCSI_OSD_MAX_MINOR);\r\nerr_out:\r\nclass_unregister(&osd_uld_class);\r\nreturn err;\r\n}\r\nstatic void __exit osd_uld_exit(void)\r\n{\r\nscsi_unregister_driver(&osd_driver.gendrv);\r\nunregister_chrdev_region(MKDEV(SCSI_OSD_MAJOR, 0), SCSI_OSD_MAX_MINOR);\r\nclass_unregister(&osd_uld_class);\r\nOSD_INFO("UNLOADED %s\n", osd_version_string);\r\n}
