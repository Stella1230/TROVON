static void reg_r(struct gspca_dev *gspca_dev,\r\n__u16 index,\r\n__u16 len)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\n#ifdef GSPCA_DEBUG\r\nif (len > USB_BUF_SZ) {\r\nerr("reg_r: buffer overflow");\r\nreturn;\r\n}\r\n#endif\r\nusb_control_msg(dev,\r\nusb_rcvctrlpipe(dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex, gspca_dev->usb_buf, len,\r\n500);\r\nPDEBUG(D_USBI, "reg read [%02x] -> %02x ..",\r\nindex, gspca_dev->usb_buf[0]);\r\n}\r\nstatic void reg_w_val(struct gspca_dev *gspca_dev,\r\n__u16 index,\r\n__u8 val)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\ngspca_dev->usb_buf[0] = val;\r\nusb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex, gspca_dev->usb_buf, 1, 500);\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\n__u16 index,\r\nconst __u8 *buffer,\r\n__u16 len)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\n#ifdef GSPCA_DEBUG\r\nif (len > USB_BUF_SZ) {\r\nerr("reg_w: buffer overflow");\r\nreturn;\r\n}\r\nPDEBUG(D_USBO, "reg write [%02x] = %02x..", index, *buffer);\r\n#endif\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nusb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex, gspca_dev->usb_buf, len, 500);\r\n}\r\nstatic void cx11646_fw(struct gspca_dev*gspca_dev)\r\n{\r\nint i = 0;\r\nreg_w_val(gspca_dev, 0x006a, 0x02);\r\nwhile (cx11646_fw1[i][1]) {\r\nreg_w(gspca_dev, 0x006b, cx11646_fw1[i], 3);\r\ni++;\r\n}\r\nreg_w_val(gspca_dev, 0x006a, 0x00);\r\n}\r\nstatic void cx_sensor(struct gspca_dev*gspca_dev)\r\n{\r\nint i = 0;\r\nint length;\r\nconst __u8 *ptsensor = cxsensor;\r\nreg_w(gspca_dev, 0x0020, reg20, 8);\r\nreg_w(gspca_dev, 0x0028, reg28, 8);\r\nreg_w(gspca_dev, 0x0010, reg10, 8);\r\nreg_w_val(gspca_dev, 0x0092, 0x03);\r\nswitch (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv) {\r\ncase 0:\r\nreg_w(gspca_dev, 0x0071, reg71a, 4);\r\nbreak;\r\ncase 1:\r\nreg_w(gspca_dev, 0x0071, reg71b, 4);\r\nbreak;\r\ndefault:\r\nreg_w(gspca_dev, 0x0071, reg71c, 4);\r\nbreak;\r\ncase 3:\r\nreg_w(gspca_dev, 0x0071, reg71d, 4);\r\nbreak;\r\n}\r\nreg_w(gspca_dev, 0x007b, reg7b, 6);\r\nreg_w_val(gspca_dev, 0x00f8, 0x00);\r\nreg_w(gspca_dev, 0x0010, reg10, 8);\r\nreg_w_val(gspca_dev, 0x0098, 0x41);\r\nfor (i = 0; i < 11; i++) {\r\nif (i == 3 || i == 5 || i == 8)\r\nlength = 8;\r\nelse\r\nlength = 4;\r\nreg_w(gspca_dev, 0x00e5, ptsensor, length);\r\nif (length == 4)\r\nreg_r(gspca_dev, 0x00e8, 1);\r\nelse\r\nreg_r(gspca_dev, 0x00e8, length);\r\nptsensor += length;\r\n}\r\nreg_r(gspca_dev, 0x00e7, 8);\r\n}\r\nstatic void cx11646_initsize(struct gspca_dev *gspca_dev)\r\n{\r\nconst __u8 *cxinit;\r\nstatic const __u8 reg12[] = { 0x08, 0x05, 0x07, 0x04, 0x24 };\r\nstatic const __u8 reg17[] =\r\n{ 0x0a, 0x00, 0xf2, 0x01, 0x0f, 0x00, 0x97, 0x02 };\r\nswitch (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv) {\r\ncase 0:\r\ncxinit = cx_inits_640;\r\nbreak;\r\ncase 1:\r\ncxinit = cx_inits_352;\r\nbreak;\r\ndefault:\r\ncxinit = cx_inits_320;\r\nbreak;\r\ncase 3:\r\ncxinit = cx_inits_176;\r\nbreak;\r\n}\r\nreg_w_val(gspca_dev, 0x009a, 0x01);\r\nreg_w_val(gspca_dev, 0x0010, 0x10);\r\nreg_w(gspca_dev, 0x0012, reg12, 5);\r\nreg_w(gspca_dev, 0x0017, reg17, 8);\r\nreg_w_val(gspca_dev, 0x00c0, 0x00);\r\nreg_w_val(gspca_dev, 0x00c1, 0x04);\r\nreg_w_val(gspca_dev, 0x00c2, 0x04);\r\nreg_w(gspca_dev, 0x0061, cxinit, 8);\r\ncxinit += 8;\r\nreg_w(gspca_dev, 0x00ca, cxinit, 8);\r\ncxinit += 8;\r\nreg_w(gspca_dev, 0x00d2, cxinit, 8);\r\ncxinit += 8;\r\nreg_w(gspca_dev, 0x00da, cxinit, 6);\r\ncxinit += 8;\r\nreg_w(gspca_dev, 0x0041, cxinit, 8);\r\ncxinit += 8;\r\nreg_w(gspca_dev, 0x0049, cxinit, 8);\r\ncxinit += 8;\r\nreg_w(gspca_dev, 0x0051, cxinit, 2);\r\nreg_r(gspca_dev, 0x0010, 1);\r\n}\r\nstatic void cx11646_jpegInit(struct gspca_dev*gspca_dev)\r\n{\r\nint i;\r\nint length;\r\nreg_w_val(gspca_dev, 0x00c0, 0x01);\r\nreg_w_val(gspca_dev, 0x00c3, 0x00);\r\nreg_w_val(gspca_dev, 0x00c0, 0x00);\r\nreg_r(gspca_dev, 0x0001, 1);\r\nlength = 8;\r\nfor (i = 0; i < 79; i++) {\r\nif (i == 78)\r\nlength = 6;\r\nreg_w(gspca_dev, 0x0008, cx_jpeg_init[i], length);\r\n}\r\nreg_r(gspca_dev, 0x0002, 1);\r\nreg_w_val(gspca_dev, 0x0055, 0x14);\r\n}\r\nstatic void cx11646_jpeg(struct gspca_dev*gspca_dev)\r\n{\r\nint i;\r\nint length;\r\n__u8 Reg55;\r\nint retry;\r\nreg_w_val(gspca_dev, 0x00c0, 0x01);\r\nreg_w_val(gspca_dev, 0x00c3, 0x00);\r\nreg_w_val(gspca_dev, 0x00c0, 0x00);\r\nreg_r(gspca_dev, 0x0001, 1);\r\nlength = 8;\r\nswitch (gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv) {\r\ncase 0:\r\nfor (i = 0; i < 27; i++) {\r\nif (i == 26)\r\nlength = 2;\r\nreg_w(gspca_dev, 0x0008, cxjpeg_640[i], length);\r\n}\r\nReg55 = 0x28;\r\nbreak;\r\ncase 1:\r\nfor (i = 0; i < 27; i++) {\r\nif (i == 26)\r\nlength = 2;\r\nreg_w(gspca_dev, 0x0008, cxjpeg_352[i], length);\r\n}\r\nReg55 = 0x16;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i < 27; i++) {\r\nif (i == 26)\r\nlength = 2;\r\nreg_w(gspca_dev, 0x0008, cxjpeg_320[i], length);\r\n}\r\nReg55 = 0x14;\r\nbreak;\r\ncase 3:\r\nfor (i = 0; i < 27; i++) {\r\nif (i == 26)\r\nlength = 2;\r\nreg_w(gspca_dev, 0x0008, cxjpeg_176[i], length);\r\n}\r\nReg55 = 0x0B;\r\nbreak;\r\n}\r\nreg_r(gspca_dev, 0x0002, 1);\r\nreg_w_val(gspca_dev, 0x0055, Reg55);\r\nreg_r(gspca_dev, 0x0002, 1);\r\nreg_w(gspca_dev, 0x0010, reg10, 2);\r\nreg_w_val(gspca_dev, 0x0054, 0x02);\r\nreg_w_val(gspca_dev, 0x0054, 0x01);\r\nreg_w_val(gspca_dev, 0x0000, 0x94);\r\nreg_w_val(gspca_dev, 0x0053, 0xc0);\r\nreg_w_val(gspca_dev, 0x00fc, 0xe1);\r\nreg_w_val(gspca_dev, 0x0000, 0x00);\r\nretry = 50;\r\ndo {\r\nreg_r(gspca_dev, 0x0002, 1);\r\nif (gspca_dev->usb_buf[0] == 0x00)\r\nbreak;\r\nreg_w_val(gspca_dev, 0x0053, 0x00);\r\n} while (--retry);\r\nif (retry == 0)\r\nPDEBUG(D_ERR, "Damned Errors sending jpeg Table");\r\nreg_r(gspca_dev, 0x0001, 1);\r\nlength = 8;\r\nfor (i = 0; i < 18; i++) {\r\nif (i == 17)\r\nlength = 2;\r\nreg_w(gspca_dev, 0x0008, cxjpeg_qtable[i], length);\r\n}\r\nreg_r(gspca_dev, 0x0002, 1);\r\nreg_r(gspca_dev, 0x0053, 1);\r\nreg_w_val(gspca_dev, 0x0054, 0x02);\r\nreg_w_val(gspca_dev, 0x0054, 0x01);\r\nreg_w_val(gspca_dev, 0x0000, 0x94);\r\nreg_w_val(gspca_dev, 0x0053, 0xc0);\r\nreg_r(gspca_dev, 0x0038, 1);\r\nreg_r(gspca_dev, 0x0038, 1);\r\nreg_r(gspca_dev, 0x001f, 1);\r\nreg_w(gspca_dev, 0x0012, reg12, 5);\r\nreg_w(gspca_dev, 0x00e5, regE5_8, 8);\r\nreg_r(gspca_dev, 0x00e8, 8);\r\nreg_w(gspca_dev, 0x00e5, regE5a, 4);\r\nreg_r(gspca_dev, 0x00e8, 1);\r\nreg_w_val(gspca_dev, 0x009a, 0x01);\r\nreg_w(gspca_dev, 0x00e5, regE5b, 4);\r\nreg_r(gspca_dev, 0x00e8, 1);\r\nreg_w(gspca_dev, 0x00e5, regE5c, 4);\r\nreg_r(gspca_dev, 0x00e8, 1);\r\nreg_w(gspca_dev, 0x0051, reg51, 2);\r\nreg_w(gspca_dev, 0x0010, reg10, 2);\r\nreg_w_val(gspca_dev, 0x0070, reg70);\r\n}\r\nstatic void cx11646_init1(struct gspca_dev *gspca_dev)\r\n{\r\nint i = 0;\r\nreg_w_val(gspca_dev, 0x0010, 0x00);\r\nreg_w_val(gspca_dev, 0x0053, 0x00);\r\nreg_w_val(gspca_dev, 0x0052, 0x00);\r\nreg_w_val(gspca_dev, 0x009b, 0x2f);\r\nreg_w_val(gspca_dev, 0x009c, 0x10);\r\nreg_r(gspca_dev, 0x0098, 1);\r\nreg_w_val(gspca_dev, 0x0098, 0x40);\r\nreg_r(gspca_dev, 0x0099, 1);\r\nreg_w_val(gspca_dev, 0x0099, 0x07);\r\nreg_w_val(gspca_dev, 0x0039, 0x40);\r\nreg_w_val(gspca_dev, 0x003c, 0xff);\r\nreg_w_val(gspca_dev, 0x003f, 0x1f);\r\nreg_w_val(gspca_dev, 0x003d, 0x40);\r\nreg_r(gspca_dev, 0x0099, 1);\r\nwhile (cx_sensor_init[i][0]) {\r\nreg_w_val(gspca_dev, 0x00e5, cx_sensor_init[i][0]);\r\nreg_r(gspca_dev, 0x00e8, 1);\r\nif (i == 1) {\r\nreg_w_val(gspca_dev, 0x00ed, 0x01);\r\nreg_r(gspca_dev, 0x00ed, 1);\r\n}\r\ni++;\r\n}\r\nreg_w_val(gspca_dev, 0x00c3, 0x00);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nsd->brightness = BRIGHTNESS_DEF;\r\nsd->contrast = CONTRAST_DEF;\r\nsd->colors = COLOR_DEF;\r\nsd->quality = QUALITY_DEF;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\ncx11646_init1(gspca_dev);\r\ncx11646_initsize(gspca_dev);\r\ncx11646_fw(gspca_dev);\r\ncx_sensor(gspca_dev);\r\ncx11646_jpegInit(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\njpeg_define(sd->jpeg_hdr, gspca_dev->height, gspca_dev->width,\r\n0x22);\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\ncx11646_initsize(gspca_dev);\r\ncx11646_fw(gspca_dev);\r\ncx_sensor(gspca_dev);\r\ncx11646_jpeg(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nint retry = 50;\r\nif (!gspca_dev->present)\r\nreturn;\r\nreg_w_val(gspca_dev, 0x0000, 0x00);\r\nreg_r(gspca_dev, 0x0002, 1);\r\nreg_w_val(gspca_dev, 0x0053, 0x00);\r\nwhile (retry--) {\r\nreg_r(gspca_dev, 0x0053, 1);\r\nif (gspca_dev->usb_buf[0] == 0)\r\nbreak;\r\n}\r\nreg_w_val(gspca_dev, 0x0000, 0x00);\r\nreg_r(gspca_dev, 0x0002, 1);\r\nreg_w_val(gspca_dev, 0x0010, 0x00);\r\nreg_r(gspca_dev, 0x0033, 1);\r\nreg_w_val(gspca_dev, 0x00fc, 0xe0);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (data[0] == 0xff && data[1] == 0xd8) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ndata += 2;\r\nlen -= 2;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 regE5cbx[] = { 0x88, 0x00, 0xd4, 0x01, 0x88, 0x01, 0x01, 0x01 };\r\n__u8 reg51c[2];\r\n__u8 bright;\r\n__u8 colors;\r\nbright = sd->brightness;\r\nregE5cbx[2] = bright;\r\nreg_w(gspca_dev, 0x00e5, regE5cbx, 8);\r\nreg_r(gspca_dev, 0x00e8, 8);\r\nreg_w(gspca_dev, 0x00e5, regE5c, 4);\r\nreg_r(gspca_dev, 0x00e8, 1);\r\ncolors = sd->colors;\r\nreg51c[0] = 0x77;\r\nreg51c[1] = colors;\r\nreg_w(gspca_dev, 0x0051, reg51c, 2);\r\nreg_w(gspca_dev, 0x0010, reg10, 2);\r\nreg_w_val(gspca_dev, 0x0070, reg70);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 regE5acx[] = { 0x88, 0x0a, 0x0c, 0x01 };\r\n__u8 reg51c[2];\r\nregE5acx[2] = sd->contrast;\r\nreg_w(gspca_dev, 0x00e5, regE5acx, 4);\r\nreg_r(gspca_dev, 0x00e8, 1);\r\nreg51c[0] = 0x77;\r\nreg51c[1] = sd->colors;\r\nreg_w(gspca_dev, 0x0051, reg51c, 2);\r\nreg_w(gspca_dev, 0x0010, reg10, 2);\r\nreg_w_val(gspca_dev, 0x0070, reg70);\r\n}\r\nstatic int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->brightness = val;\r\nif (gspca_dev->streaming)\r\nsetbrightness(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getbrightness(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->brightness;\r\nreturn 0;\r\n}\r\nstatic int sd_setcontrast(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->contrast = val;\r\nif (gspca_dev->streaming)\r\nsetcontrast(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getcontrast(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->contrast;\r\nreturn 0;\r\n}\r\nstatic int sd_setcolors(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->colors = val;\r\nif (gspca_dev->streaming) {\r\nsetbrightness(gspca_dev);\r\nsetcontrast(gspca_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_getcolors(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->colors;\r\nreturn 0;\r\n}\r\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (jcomp->quality < QUALITY_MIN)\r\nsd->quality = QUALITY_MIN;\r\nelse if (jcomp->quality > QUALITY_MAX)\r\nsd->quality = QUALITY_MAX;\r\nelse\r\nsd->quality = jcomp->quality;\r\nif (gspca_dev->streaming)\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\nreturn 0;\r\n}\r\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nmemset(jcomp, 0, sizeof *jcomp);\r\njcomp->quality = sd->quality;\r\njcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT\r\n| V4L2_JPEG_MARKER_DQT;\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int __init sd_mod_init(void)\r\n{\r\nreturn usb_register(&sd_driver);\r\n}\r\nstatic void __exit sd_mod_exit(void)\r\n{\r\nusb_deregister(&sd_driver);\r\n}
