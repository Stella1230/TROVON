static ssize_t hidraw_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct hidraw_list *list = file->private_data;\r\nint ret = 0, len;\r\nDECLARE_WAITQUEUE(wait, current);\r\nmutex_lock(&list->read_mutex);\r\nwhile (ret == 0) {\r\nif (list->head == list->tail) {\r\nadd_wait_queue(&list->hidraw->wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (list->head == list->tail) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!list->hidraw->exist) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nmutex_unlock(&list->read_mutex);\r\nschedule();\r\nmutex_lock(&list->read_mutex);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&list->hidraw->wait, &wait);\r\n}\r\nif (ret)\r\ngoto out;\r\nlen = list->buffer[list->tail].len > count ?\r\ncount : list->buffer[list->tail].len;\r\nif (copy_to_user(buffer, list->buffer[list->tail].value, len)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = len;\r\nkfree(list->buffer[list->tail].value);\r\nlist->tail = (list->tail + 1) & (HIDRAW_BUFFER_SIZE - 1);\r\n}\r\nout:\r\nmutex_unlock(&list->read_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t hidraw_send_report(struct file *file, const char __user *buffer, size_t count, unsigned char report_type)\r\n{\r\nunsigned int minor = iminor(file->f_path.dentry->d_inode);\r\nstruct hid_device *dev;\r\n__u8 *buf;\r\nint ret = 0;\r\nif (!hidraw_table[minor]) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ndev = hidraw_table[minor]->hid;\r\nif (!dev->hid_output_raw_report) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (count > HID_MAX_BUFFER_SIZE) {\r\nhid_warn(dev, "pid %d passed too large report\n",\r\ntask_pid_nr(current));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (count < 2) {\r\nhid_warn(dev, "pid %d passed too short report\n",\r\ntask_pid_nr(current));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbuf = kmalloc(count * sizeof(__u8), GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(buf, buffer, count)) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nret = dev->hid_output_raw_report(dev, buf, count, report_type);\r\nout_free:\r\nkfree(buf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t hidraw_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nmutex_lock(&minors_lock);\r\nret = hidraw_send_report(file, buffer, count, HID_OUTPUT_REPORT);\r\nmutex_unlock(&minors_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t hidraw_get_report(struct file *file, char __user *buffer, size_t count, unsigned char report_type)\r\n{\r\nunsigned int minor = iminor(file->f_path.dentry->d_inode);\r\nstruct hid_device *dev;\r\n__u8 *buf;\r\nint ret = 0, len;\r\nunsigned char report_number;\r\ndev = hidraw_table[minor]->hid;\r\nif (!dev->hid_get_raw_report) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (count > HID_MAX_BUFFER_SIZE) {\r\nprintk(KERN_WARNING "hidraw: pid %d passed too large report\n",\r\ntask_pid_nr(current));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (count < 2) {\r\nprintk(KERN_WARNING "hidraw: pid %d passed too short report\n",\r\ntask_pid_nr(current));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbuf = kmalloc(count * sizeof(__u8), GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(&report_number, buffer, 1)) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nret = dev->hid_get_raw_report(dev, report_number, buf, count, report_type);\r\nif (ret < 0)\r\ngoto out_free;\r\nlen = (ret < count) ? ret : count;\r\nif (copy_to_user(buffer, buf, len)) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nret = len;\r\nout_free:\r\nkfree(buf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic unsigned int hidraw_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct hidraw_list *list = file->private_data;\r\npoll_wait(file, &list->hidraw->wait, wait);\r\nif (list->head != list->tail)\r\nreturn POLLIN | POLLRDNORM;\r\nif (!list->hidraw->exist)\r\nreturn POLLERR | POLLHUP;\r\nreturn 0;\r\n}\r\nstatic int hidraw_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct hidraw *dev;\r\nstruct hidraw_list *list;\r\nint err = 0;\r\nif (!(list = kzalloc(sizeof(struct hidraw_list), GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmutex_lock(&minors_lock);\r\nif (!hidraw_table[minor]) {\r\nkfree(list);\r\nerr = -ENODEV;\r\ngoto out_unlock;\r\n}\r\nlist->hidraw = hidraw_table[minor];\r\nmutex_init(&list->read_mutex);\r\nlist_add_tail(&list->node, &hidraw_table[minor]->list);\r\nfile->private_data = list;\r\ndev = hidraw_table[minor];\r\nif (!dev->open++) {\r\nerr = hid_hw_power(dev->hid, PM_HINT_FULLON);\r\nif (err < 0)\r\ngoto out_unlock;\r\nerr = hid_hw_open(dev->hid);\r\nif (err < 0) {\r\nhid_hw_power(dev->hid, PM_HINT_NORMAL);\r\ndev->open--;\r\n}\r\n}\r\nout_unlock:\r\nmutex_unlock(&minors_lock);\r\nout:\r\nreturn err;\r\n}\r\nstatic int hidraw_release(struct inode * inode, struct file * file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct hidraw *dev;\r\nstruct hidraw_list *list = file->private_data;\r\nint ret;\r\nmutex_lock(&minors_lock);\r\nif (!hidraw_table[minor]) {\r\nret = -ENODEV;\r\ngoto unlock;\r\n}\r\nlist_del(&list->node);\r\ndev = hidraw_table[minor];\r\nif (!--dev->open) {\r\nif (list->hidraw->exist) {\r\nhid_hw_power(dev->hid, PM_HINT_NORMAL);\r\nhid_hw_close(dev->hid);\r\n} else {\r\nkfree(list->hidraw);\r\n}\r\n}\r\nkfree(list);\r\nret = 0;\r\nunlock:\r\nmutex_unlock(&minors_lock);\r\nreturn ret;\r\n}\r\nstatic long hidraw_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nunsigned int minor = iminor(inode);\r\nlong ret = 0;\r\nstruct hidraw *dev;\r\nvoid __user *user_arg = (void __user*) arg;\r\nmutex_lock(&minors_lock);\r\ndev = hidraw_table[minor];\r\nif (!dev) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase HIDIOCGRDESCSIZE:\r\nif (put_user(dev->hid->rsize, (int __user *)arg))\r\nret = -EFAULT;\r\nbreak;\r\ncase HIDIOCGRDESC:\r\n{\r\n__u32 len;\r\nif (get_user(len, (int __user *)arg))\r\nret = -EFAULT;\r\nelse if (len > HID_MAX_DESCRIPTOR_SIZE - 1)\r\nret = -EINVAL;\r\nelse if (copy_to_user(user_arg + offsetof(\r\nstruct hidraw_report_descriptor,\r\nvalue[0]),\r\ndev->hid->rdesc,\r\nmin(dev->hid->rsize, len)))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ncase HIDIOCGRAWINFO:\r\n{\r\nstruct hidraw_devinfo dinfo;\r\ndinfo.bustype = dev->hid->bus;\r\ndinfo.vendor = dev->hid->vendor;\r\ndinfo.product = dev->hid->product;\r\nif (copy_to_user(user_arg, &dinfo, sizeof(dinfo)))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nstruct hid_device *hid = dev->hid;\r\nif (_IOC_TYPE(cmd) != 'H') {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (_IOC_NR(cmd) == _IOC_NR(HIDIOCSFEATURE(0))) {\r\nint len = _IOC_SIZE(cmd);\r\nret = hidraw_send_report(file, user_arg, len, HID_FEATURE_REPORT);\r\nbreak;\r\n}\r\nif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGFEATURE(0))) {\r\nint len = _IOC_SIZE(cmd);\r\nret = hidraw_get_report(file, user_arg, len, HID_FEATURE_REPORT);\r\nbreak;\r\n}\r\nif (_IOC_DIR(cmd) != _IOC_READ) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWNAME(0))) {\r\nint len = strlen(hid->name) + 1;\r\nif (len > _IOC_SIZE(cmd))\r\nlen = _IOC_SIZE(cmd);\r\nret = copy_to_user(user_arg, hid->name, len) ?\r\n-EFAULT : len;\r\nbreak;\r\n}\r\nif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWPHYS(0))) {\r\nint len = strlen(hid->phys) + 1;\r\nif (len > _IOC_SIZE(cmd))\r\nlen = _IOC_SIZE(cmd);\r\nret = copy_to_user(user_arg, hid->phys, len) ?\r\n-EFAULT : len;\r\nbreak;\r\n}\r\n}\r\nret = -ENOTTY;\r\n}\r\nout:\r\nmutex_unlock(&minors_lock);\r\nreturn ret;\r\n}\r\nvoid hidraw_report_event(struct hid_device *hid, u8 *data, int len)\r\n{\r\nstruct hidraw *dev = hid->hidraw;\r\nstruct hidraw_list *list;\r\nlist_for_each_entry(list, &dev->list, node) {\r\nlist->buffer[list->head].value = kmemdup(data, len, GFP_ATOMIC);\r\nlist->buffer[list->head].len = len;\r\nlist->head = (list->head + 1) & (HIDRAW_BUFFER_SIZE - 1);\r\nkill_fasync(&list->fasync, SIGIO, POLL_IN);\r\n}\r\nwake_up_interruptible(&dev->wait);\r\n}\r\nint hidraw_connect(struct hid_device *hid)\r\n{\r\nint minor, result;\r\nstruct hidraw *dev;\r\ndev = kzalloc(sizeof(struct hidraw), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nresult = -EINVAL;\r\nmutex_lock(&minors_lock);\r\nfor (minor = 0; minor < HIDRAW_MAX_DEVICES; minor++) {\r\nif (hidraw_table[minor])\r\ncontinue;\r\nhidraw_table[minor] = dev;\r\nresult = 0;\r\nbreak;\r\n}\r\nif (result) {\r\nmutex_unlock(&minors_lock);\r\nkfree(dev);\r\ngoto out;\r\n}\r\ndev->dev = device_create(hidraw_class, &hid->dev, MKDEV(hidraw_major, minor),\r\nNULL, "%s%d", "hidraw", minor);\r\nif (IS_ERR(dev->dev)) {\r\nhidraw_table[minor] = NULL;\r\nmutex_unlock(&minors_lock);\r\nresult = PTR_ERR(dev->dev);\r\nkfree(dev);\r\ngoto out;\r\n}\r\nmutex_unlock(&minors_lock);\r\ninit_waitqueue_head(&dev->wait);\r\nINIT_LIST_HEAD(&dev->list);\r\ndev->hid = hid;\r\ndev->minor = minor;\r\ndev->exist = 1;\r\nhid->hidraw = dev;\r\nout:\r\nreturn result;\r\n}\r\nvoid hidraw_disconnect(struct hid_device *hid)\r\n{\r\nstruct hidraw *hidraw = hid->hidraw;\r\nhidraw->exist = 0;\r\ndevice_destroy(hidraw_class, MKDEV(hidraw_major, hidraw->minor));\r\nmutex_lock(&minors_lock);\r\nhidraw_table[hidraw->minor] = NULL;\r\nmutex_unlock(&minors_lock);\r\nif (hidraw->open) {\r\nhid_hw_close(hid);\r\nwake_up_interruptible(&hidraw->wait);\r\n} else {\r\nkfree(hidraw);\r\n}\r\n}\r\nint __init hidraw_init(void)\r\n{\r\nint result;\r\ndev_t dev_id;\r\nresult = alloc_chrdev_region(&dev_id, HIDRAW_FIRST_MINOR,\r\nHIDRAW_MAX_DEVICES, "hidraw");\r\nhidraw_major = MAJOR(dev_id);\r\nif (result < 0) {\r\npr_warn("can't get major number\n");\r\nresult = 0;\r\ngoto out;\r\n}\r\nhidraw_class = class_create(THIS_MODULE, "hidraw");\r\nif (IS_ERR(hidraw_class)) {\r\nresult = PTR_ERR(hidraw_class);\r\nunregister_chrdev(hidraw_major, "hidraw");\r\ngoto out;\r\n}\r\ncdev_init(&hidraw_cdev, &hidraw_ops);\r\ncdev_add(&hidraw_cdev, dev_id, HIDRAW_MAX_DEVICES);\r\nout:\r\nreturn result;\r\n}\r\nvoid hidraw_exit(void)\r\n{\r\ndev_t dev_id = MKDEV(hidraw_major, 0);\r\ncdev_del(&hidraw_cdev);\r\nclass_destroy(hidraw_class);\r\nunregister_chrdev_region(dev_id, HIDRAW_MAX_DEVICES);\r\n}
