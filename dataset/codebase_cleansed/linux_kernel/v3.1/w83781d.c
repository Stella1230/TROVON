static inline u8\r\nFAN_TO_REG(long rpm, int div)\r\n{\r\nif (rpm == 0)\r\nreturn 255;\r\nrpm = SENSORS_LIMIT(rpm, 1, 1000000);\r\nreturn SENSORS_LIMIT((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\r\n}\r\nstatic inline long\r\nFAN_FROM_REG(u8 val, int div)\r\n{\r\nif (val == 0)\r\nreturn -1;\r\nif (val == 255)\r\nreturn 0;\r\nreturn 1350000 / (val * div);\r\n}\r\nstatic inline u8\r\nDIV_TO_REG(long val, enum chips type)\r\n{\r\nint i;\r\nval = SENSORS_LIMIT(val, 1,\r\n((type == w83781d\r\n|| type == as99127f) ? 8 : 128)) >> 1;\r\nfor (i = 0; i < 7; i++) {\r\nif (val == 0)\r\nbreak;\r\nval >>= 1;\r\n}\r\nreturn i;\r\n}\r\nstatic ssize_t\r\nstore_fan_min(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nu32 val;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] =\r\nFAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\r\nw83781d_write_value(data, W83781D_REG_FAN_MIN(nr),\r\ndata->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_vid_reg(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", (long) vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic ssize_t\r\nshow_vrm_reg(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%ld\n", (long) data->vrm);\r\n}\r\nstatic ssize_t\r\nstore_vrm_reg(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nu32 val;\r\nval = simple_strtoul(buf, NULL, 10);\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_alarms_reg(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nreturn sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t show_temp3_alarm(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nint bitnr = (data->type == w83781d) ? 5 : 13;\r\nreturn sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t show_beep_mask (struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nreturn sprintf(buf, "%ld\n",\r\n(long)BEEP_MASK_FROM_REG(data->beep_mask, data->type));\r\n}\r\nstatic ssize_t\r\nstore_beep_mask(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nu32 val;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->beep_mask &= 0x8000;\r\ndata->beep_mask |= BEEP_MASK_TO_REG(val, data->type);\r\nw83781d_write_value(data, W83781D_REG_BEEP_INTS1,\r\ndata->beep_mask & 0xff);\r\nw83781d_write_value(data, W83781D_REG_BEEP_INTS2,\r\n(data->beep_mask >> 8) & 0xff);\r\nif (data->type != w83781d && data->type != as99127f) {\r\nw83781d_write_value(data, W83781D_REG_BEEP_INTS3,\r\n((data->beep_mask) >> 16) & 0xff);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_beep(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nreturn sprintf(buf, "%u\n", (data->beep_mask >> bitnr) & 1);\r\n}\r\nstatic ssize_t\r\nstore_beep(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nunsigned long bit;\r\nu8 reg;\r\nbit = simple_strtoul(buf, NULL, 10);\r\nif (bit & ~1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (bit)\r\ndata->beep_mask |= (1 << bitnr);\r\nelse\r\ndata->beep_mask &= ~(1 << bitnr);\r\nif (bitnr < 8) {\r\nreg = w83781d_read_value(data, W83781D_REG_BEEP_INTS1);\r\nif (bit)\r\nreg |= (1 << bitnr);\r\nelse\r\nreg &= ~(1 << bitnr);\r\nw83781d_write_value(data, W83781D_REG_BEEP_INTS1, reg);\r\n} else if (bitnr < 16) {\r\nreg = w83781d_read_value(data, W83781D_REG_BEEP_INTS2);\r\nif (bit)\r\nreg |= (1 << (bitnr - 8));\r\nelse\r\nreg &= ~(1 << (bitnr - 8));\r\nw83781d_write_value(data, W83781D_REG_BEEP_INTS2, reg);\r\n} else {\r\nreg = w83781d_read_value(data, W83781D_REG_BEEP_INTS3);\r\nif (bit)\r\nreg |= (1 << (bitnr - 16));\r\nelse\r\nreg &= ~(1 << (bitnr - 16));\r\nw83781d_write_value(data, W83781D_REG_BEEP_INTS3, reg);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp3_beep(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nint bitnr = (data->type == w83781d) ? 5 : 13;\r\nreturn sprintf(buf, "%u\n", (data->beep_mask >> bitnr) & 1);\r\n}\r\nstatic ssize_t\r\nshow_fan_div(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nreturn sprintf(buf, "%ld\n",\r\n(long) DIV_FROM_REG(data->fan_div[attr->index]));\r\n}\r\nstatic ssize_t\r\nstore_fan_div(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nunsigned long min;\r\nint nr = attr->index;\r\nu8 reg;\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\nmin = FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr]));\r\ndata->fan_div[nr] = DIV_TO_REG(val, data->type);\r\nreg = (w83781d_read_value(data, nr==2 ? W83781D_REG_PIN : W83781D_REG_VID_FANDIV)\r\n& (nr==0 ? 0xcf : 0x3f))\r\n| ((data->fan_div[nr] & 0x03) << (nr==0 ? 4 : 6));\r\nw83781d_write_value(data, nr==2 ? W83781D_REG_PIN : W83781D_REG_VID_FANDIV, reg);\r\nif (data->type != w83781d && data->type != as99127f) {\r\nreg = (w83781d_read_value(data, W83781D_REG_VBAT)\r\n& ~(1 << (5 + nr)))\r\n| ((data->fan_div[nr] & 0x04) << (3 + nr));\r\nw83781d_write_value(data, W83781D_REG_VBAT, reg);\r\n}\r\ndata->fan_min[nr] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\r\nw83781d_write_value(data, W83781D_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (int)data->pwm[attr->index]);\r\n}\r\nstatic ssize_t\r\nshow_pwm2_enable(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (int)data->pwm2_enable);\r\n}\r\nstatic ssize_t\r\nstore_pwm(struct device *dev, struct device_attribute *da, const char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nu32 val;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = SENSORS_LIMIT(val, 0, 255);\r\nw83781d_write_value(data, W83781D_REG_PWM[nr], data->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_pwm2_enable(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nu32 val, reg;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 0:\r\ncase 1:\r\nreg = w83781d_read_value(data, W83781D_REG_PWMCLK12);\r\nw83781d_write_value(data, W83781D_REG_PWMCLK12,\r\n(reg & 0xf7) | (val << 3));\r\nreg = w83781d_read_value(data, W83781D_REG_BEEP_CONFIG);\r\nw83781d_write_value(data, W83781D_REG_BEEP_CONFIG,\r\n(reg & 0xef) | (!val << 4));\r\ndata->pwm2_enable = val;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sensor(struct device *dev, struct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct w83781d_data *data = w83781d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (int)data->sens[attr->index]);\r\n}\r\nstatic ssize_t\r\nstore_sensor(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nu32 val, tmp;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 1:\r\ntmp = w83781d_read_value(data, W83781D_REG_SCFG1);\r\nw83781d_write_value(data, W83781D_REG_SCFG1,\r\ntmp | BIT_SCFG1[nr]);\r\ntmp = w83781d_read_value(data, W83781D_REG_SCFG2);\r\nw83781d_write_value(data, W83781D_REG_SCFG2,\r\ntmp | BIT_SCFG2[nr]);\r\ndata->sens[nr] = val;\r\nbreak;\r\ncase 2:\r\ntmp = w83781d_read_value(data, W83781D_REG_SCFG1);\r\nw83781d_write_value(data, W83781D_REG_SCFG1,\r\ntmp | BIT_SCFG1[nr]);\r\ntmp = w83781d_read_value(data, W83781D_REG_SCFG2);\r\nw83781d_write_value(data, W83781D_REG_SCFG2,\r\ntmp & ~BIT_SCFG2[nr]);\r\ndata->sens[nr] = val;\r\nbreak;\r\ncase W83781D_DEFAULT_BETA:\r\ndev_warn(dev, "Sensor type %d is deprecated, please use 4 "\r\n"instead\n", W83781D_DEFAULT_BETA);\r\ncase 4:\r\ntmp = w83781d_read_value(data, W83781D_REG_SCFG1);\r\nw83781d_write_value(data, W83781D_REG_SCFG1,\r\ntmp & ~BIT_SCFG1[nr]);\r\ndata->sens[nr] = val;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid sensor type %ld; must be 1, 2, or 4\n",\r\n(long) val);\r\nbreak;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int\r\nw83781d_detect_subclients(struct i2c_client *new_client)\r\n{\r\nint i, val1 = 0, id;\r\nint err;\r\nint address = new_client->addr;\r\nunsigned short sc_addr[2];\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nstruct w83781d_data *data = i2c_get_clientdata(new_client);\r\nenum chips kind = data->type;\r\nid = i2c_adapter_id(adapter);\r\nif (force_subclients[0] == id && force_subclients[1] == address) {\r\nfor (i = 2; i <= 3; i++) {\r\nif (force_subclients[i] < 0x48 ||\r\nforce_subclients[i] > 0x4f) {\r\ndev_err(&new_client->dev, "Invalid subclient "\r\n"address %d; must be 0x48-0x4f\n",\r\nforce_subclients[i]);\r\nerr = -EINVAL;\r\ngoto ERROR_SC_1;\r\n}\r\n}\r\nw83781d_write_value(data, W83781D_REG_I2C_SUBADDR,\r\n(force_subclients[2] & 0x07) |\r\n((force_subclients[3] & 0x07) << 4));\r\nsc_addr[0] = force_subclients[2];\r\n} else {\r\nval1 = w83781d_read_value(data, W83781D_REG_I2C_SUBADDR);\r\nsc_addr[0] = 0x48 + (val1 & 0x07);\r\n}\r\nif (kind != w83783s) {\r\nif (force_subclients[0] == id &&\r\nforce_subclients[1] == address) {\r\nsc_addr[1] = force_subclients[3];\r\n} else {\r\nsc_addr[1] = 0x48 + ((val1 >> 4) & 0x07);\r\n}\r\nif (sc_addr[0] == sc_addr[1]) {\r\ndev_err(&new_client->dev,\r\n"Duplicate addresses 0x%x for subclients.\n",\r\nsc_addr[0]);\r\nerr = -EBUSY;\r\ngoto ERROR_SC_2;\r\n}\r\n}\r\nfor (i = 0; i <= 1; i++) {\r\ndata->lm75[i] = i2c_new_dummy(adapter, sc_addr[i]);\r\nif (!data->lm75[i]) {\r\ndev_err(&new_client->dev, "Subclient %d "\r\n"registration at address 0x%x "\r\n"failed.\n", i, sc_addr[i]);\r\nerr = -ENOMEM;\r\nif (i == 1)\r\ngoto ERROR_SC_3;\r\ngoto ERROR_SC_2;\r\n}\r\nif (kind == w83783s)\r\nbreak;\r\n}\r\nreturn 0;\r\nERROR_SC_3:\r\ni2c_unregister_device(data->lm75[0]);\r\nERROR_SC_2:\r\nERROR_SC_1:\r\nreturn err;\r\n}\r\nstatic int\r\nw83781d_create_files(struct device *dev, int kind, int is_isa)\r\n{\r\nint err;\r\nif ((err = sysfs_create_group(&dev->kobj, &w83781d_group)))\r\nreturn err;\r\nif (kind != w83783s) {\r\nif ((err = device_create_file(dev,\r\n&sensor_dev_attr_in1_input.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in1_min.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in1_max.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in1_alarm.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in1_beep.dev_attr)))\r\nreturn err;\r\n}\r\nif (kind != as99127f && kind != w83781d && kind != w83783s) {\r\nif ((err = device_create_file(dev,\r\n&sensor_dev_attr_in7_input.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in7_min.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in7_max.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in7_alarm.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in7_beep.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in8_input.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in8_min.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in8_max.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in8_alarm.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_in8_beep.dev_attr)))\r\nreturn err;\r\n}\r\nif (kind != w83783s) {\r\nif ((err = device_create_file(dev,\r\n&sensor_dev_attr_temp3_input.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_temp3_max.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_temp3_max_hyst.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_temp3_alarm.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_temp3_beep.dev_attr)))\r\nreturn err;\r\nif (kind != w83781d) {\r\nerr = sysfs_chmod_file(&dev->kobj,\r\n&sensor_dev_attr_temp3_alarm.dev_attr.attr,\r\nS_IRUGO | S_IWUSR);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nif (kind != w83781d && kind != as99127f) {\r\nif ((err = device_create_file(dev,\r\n&sensor_dev_attr_pwm1.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_pwm2.dev_attr))\r\n|| (err = device_create_file(dev, &dev_attr_pwm2_enable)))\r\nreturn err;\r\n}\r\nif (kind == w83782d && !is_isa) {\r\nif ((err = device_create_file(dev,\r\n&sensor_dev_attr_pwm3.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_pwm4.dev_attr)))\r\nreturn err;\r\n}\r\nif (kind != as99127f && kind != w83781d) {\r\nif ((err = device_create_file(dev,\r\n&sensor_dev_attr_temp1_type.dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sensor_dev_attr_temp2_type.dev_attr)))\r\nreturn err;\r\nif (kind != w83783s) {\r\nif ((err = device_create_file(dev,\r\n&sensor_dev_attr_temp3_type.dev_attr)))\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nw83781d_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nint val1, val2;\r\nstruct w83781d_data *isa = w83781d_data_if_isa();\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint address = client->addr;\r\nconst char *client_name;\r\nenum vendor { winbond, asus } vendid;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nif (isa)\r\nmutex_lock(&isa->update_lock);\r\nif (i2c_smbus_read_byte_data(client, W83781D_REG_CONFIG) & 0x80) {\r\ndev_dbg(&adapter->dev,\r\n"Detection of w83781d chip failed at step 3\n");\r\ngoto err_nodev;\r\n}\r\nval1 = i2c_smbus_read_byte_data(client, W83781D_REG_BANK);\r\nval2 = i2c_smbus_read_byte_data(client, W83781D_REG_CHIPMAN);\r\nif (!(val1 & 0x07) &&\r\n((!(val1 & 0x80) && val2 != 0xa3 && val2 != 0xc3) ||\r\n( (val1 & 0x80) && val2 != 0x5c && val2 != 0x12))) {\r\ndev_dbg(&adapter->dev,\r\n"Detection of w83781d chip failed at step 4\n");\r\ngoto err_nodev;\r\n}\r\nif ((!(val1 & 0x80) && val2 == 0xa3) ||\r\n( (val1 & 0x80) && val2 == 0x5c)) {\r\nif (i2c_smbus_read_byte_data(client, W83781D_REG_I2C_ADDR)\r\n!= address) {\r\ndev_dbg(&adapter->dev,\r\n"Detection of w83781d chip failed at step 5\n");\r\ngoto err_nodev;\r\n}\r\n}\r\ni2c_smbus_write_byte_data(client, W83781D_REG_BANK,\r\n(i2c_smbus_read_byte_data(client, W83781D_REG_BANK)\r\n& 0x78) | 0x80);\r\nval2 = i2c_smbus_read_byte_data(client, W83781D_REG_CHIPMAN);\r\nif (val2 == 0x5c)\r\nvendid = winbond;\r\nelse if (val2 == 0x12)\r\nvendid = asus;\r\nelse {\r\ndev_dbg(&adapter->dev,\r\n"w83781d chip vendor is neither Winbond nor Asus\n");\r\ngoto err_nodev;\r\n}\r\nval1 = i2c_smbus_read_byte_data(client, W83781D_REG_WCHIPID);\r\nif ((val1 == 0x10 || val1 == 0x11) && vendid == winbond)\r\nclient_name = "w83781d";\r\nelse if (val1 == 0x30 && vendid == winbond)\r\nclient_name = "w83782d";\r\nelse if (val1 == 0x40 && vendid == winbond && address == 0x2d)\r\nclient_name = "w83783s";\r\nelse if (val1 == 0x31)\r\nclient_name = "as99127f";\r\nelse\r\ngoto err_nodev;\r\nif (val1 <= 0x30 && w83781d_alias_detect(client, val1)) {\r\ndev_dbg(&adapter->dev, "Device at 0x%02x appears to "\r\n"be the same as ISA device\n", address);\r\ngoto err_nodev;\r\n}\r\nif (isa)\r\nmutex_unlock(&isa->update_lock);\r\nstrlcpy(info->type, client_name, I2C_NAME_SIZE);\r\nreturn 0;\r\nerr_nodev:\r\nif (isa)\r\nmutex_unlock(&isa->update_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nw83781d_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct w83781d_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(struct w83781d_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto ERROR1;\r\n}\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->lock);\r\nmutex_init(&data->update_lock);\r\ndata->type = id->driver_data;\r\ndata->client = client;\r\nerr = w83781d_detect_subclients(client);\r\nif (err)\r\ngoto ERROR3;\r\nw83781d_init_device(dev);\r\nerr = w83781d_create_files(dev, data->type, 0);\r\nif (err)\r\ngoto ERROR4;\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto ERROR4;\r\n}\r\nreturn 0;\r\nERROR4:\r\nsysfs_remove_group(&dev->kobj, &w83781d_group);\r\nsysfs_remove_group(&dev->kobj, &w83781d_group_opt);\r\nif (data->lm75[0])\r\ni2c_unregister_device(data->lm75[0]);\r\nif (data->lm75[1])\r\ni2c_unregister_device(data->lm75[1]);\r\nERROR3:\r\nkfree(data);\r\nERROR1:\r\nreturn err;\r\n}\r\nstatic int\r\nw83781d_remove(struct i2c_client *client)\r\n{\r\nstruct w83781d_data *data = i2c_get_clientdata(client);\r\nstruct device *dev = &client->dev;\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&dev->kobj, &w83781d_group);\r\nsysfs_remove_group(&dev->kobj, &w83781d_group_opt);\r\nif (data->lm75[0])\r\ni2c_unregister_device(data->lm75[0]);\r\nif (data->lm75[1])\r\ni2c_unregister_device(data->lm75[1]);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int\r\nw83781d_read_value_i2c(struct w83781d_data *data, u16 reg)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint res, bank;\r\nstruct i2c_client *cl;\r\nbank = (reg >> 8) & 0x0f;\r\nif (bank > 2)\r\ni2c_smbus_write_byte_data(client, W83781D_REG_BANK,\r\nbank);\r\nif (bank == 0 || bank > 2) {\r\nres = i2c_smbus_read_byte_data(client, reg & 0xff);\r\n} else {\r\ncl = data->lm75[bank - 1];\r\nswitch (reg & 0xff) {\r\ncase 0x50:\r\nres = swab16(i2c_smbus_read_word_data(cl, 0));\r\nbreak;\r\ncase 0x52:\r\nres = i2c_smbus_read_byte_data(cl, 1);\r\nbreak;\r\ncase 0x53:\r\nres = swab16(i2c_smbus_read_word_data(cl, 2));\r\nbreak;\r\ncase 0x55:\r\ndefault:\r\nres = swab16(i2c_smbus_read_word_data(cl, 3));\r\nbreak;\r\n}\r\n}\r\nif (bank > 2)\r\ni2c_smbus_write_byte_data(client, W83781D_REG_BANK, 0);\r\nreturn res;\r\n}\r\nstatic int\r\nw83781d_write_value_i2c(struct w83781d_data *data, u16 reg, u16 value)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint bank;\r\nstruct i2c_client *cl;\r\nbank = (reg >> 8) & 0x0f;\r\nif (bank > 2)\r\ni2c_smbus_write_byte_data(client, W83781D_REG_BANK,\r\nbank);\r\nif (bank == 0 || bank > 2) {\r\ni2c_smbus_write_byte_data(client, reg & 0xff,\r\nvalue & 0xff);\r\n} else {\r\ncl = data->lm75[bank - 1];\r\nswitch (reg & 0xff) {\r\ncase 0x52:\r\ni2c_smbus_write_byte_data(cl, 1, value & 0xff);\r\nbreak;\r\ncase 0x53:\r\ni2c_smbus_write_word_data(cl, 2, swab16(value));\r\nbreak;\r\ncase 0x55:\r\ni2c_smbus_write_word_data(cl, 3, swab16(value));\r\nbreak;\r\n}\r\n}\r\nif (bank > 2)\r\ni2c_smbus_write_byte_data(client, W83781D_REG_BANK, 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nw83781d_init_device(struct device *dev)\r\n{\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nint i, p;\r\nint type = data->type;\r\nu8 tmp;\r\nif (reset && type != as99127f) {\r\ndev_info(dev, "If reset=1 solved a problem you were "\r\n"having, please report!\n");\r\ni = w83781d_read_value(data, W83781D_REG_BEEP_CONFIG);\r\np = w83781d_read_value(data, W83781D_REG_PWMCLK12);\r\nw83781d_write_value(data, W83781D_REG_CONFIG, 0x80);\r\nw83781d_write_value(data, W83781D_REG_BEEP_CONFIG, i | 0x80);\r\nw83781d_write_value(data, W83781D_REG_PWMCLK12, p);\r\nw83781d_write_value(data, W83781D_REG_BEEP_INTS2, 0);\r\n}\r\nif (init && !reset && type != as99127f) {\r\ni = w83781d_read_value(data, W83781D_REG_BEEP_CONFIG);\r\nw83781d_write_value(data, W83781D_REG_BEEP_CONFIG, i | 0x80);\r\n}\r\ndata->vrm = vid_which_vrm();\r\nif ((type != w83781d) && (type != as99127f)) {\r\ntmp = w83781d_read_value(data, W83781D_REG_SCFG1);\r\nfor (i = 1; i <= 3; i++) {\r\nif (!(tmp & BIT_SCFG1[i - 1])) {\r\ndata->sens[i - 1] = 4;\r\n} else {\r\nif (w83781d_read_value\r\n(data,\r\nW83781D_REG_SCFG2) & BIT_SCFG2[i - 1])\r\ndata->sens[i - 1] = 1;\r\nelse\r\ndata->sens[i - 1] = 2;\r\n}\r\nif (type == w83783s && i == 2)\r\nbreak;\r\n}\r\n}\r\nif (init && type != as99127f) {\r\ntmp = w83781d_read_value(data, W83781D_REG_TEMP2_CONFIG);\r\nif (tmp & 0x01) {\r\ndev_warn(dev, "Enabling temp2, readings "\r\n"might not make sense\n");\r\nw83781d_write_value(data, W83781D_REG_TEMP2_CONFIG,\r\ntmp & 0xfe);\r\n}\r\nif (type != w83783s) {\r\ntmp = w83781d_read_value(data,\r\nW83781D_REG_TEMP3_CONFIG);\r\nif (tmp & 0x01) {\r\ndev_warn(dev, "Enabling temp3, "\r\n"readings might not make sense\n");\r\nw83781d_write_value(data,\r\nW83781D_REG_TEMP3_CONFIG, tmp & 0xfe);\r\n}\r\n}\r\n}\r\nw83781d_write_value(data, W83781D_REG_CONFIG,\r\n(w83781d_read_value(data,\r\nW83781D_REG_CONFIG) & 0xf7)\r\n| 0x01);\r\nfor (i = 0; i < 3; i++) {\r\ndata->fan_min[i] = w83781d_read_value(data,\r\nW83781D_REG_FAN_MIN(i));\r\n}\r\nmutex_init(&data->update_lock);\r\n}\r\nstatic struct w83781d_data *w83781d_update_device(struct device *dev)\r\n{\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\ndev_dbg(dev, "Starting device update\n");\r\nfor (i = 0; i <= 8; i++) {\r\nif (data->type == w83783s && i == 1)\r\ncontinue;\r\ndata->in[i] =\r\nw83781d_read_value(data, W83781D_REG_IN(i));\r\ndata->in_min[i] =\r\nw83781d_read_value(data, W83781D_REG_IN_MIN(i));\r\ndata->in_max[i] =\r\nw83781d_read_value(data, W83781D_REG_IN_MAX(i));\r\nif ((data->type != w83782d) && (i == 6))\r\nbreak;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\ndata->fan[i] =\r\nw83781d_read_value(data, W83781D_REG_FAN(i));\r\ndata->fan_min[i] =\r\nw83781d_read_value(data, W83781D_REG_FAN_MIN(i));\r\n}\r\nif (data->type != w83781d && data->type != as99127f) {\r\nfor (i = 0; i < 4; i++) {\r\ndata->pwm[i] =\r\nw83781d_read_value(data,\r\nW83781D_REG_PWM[i]);\r\nif ((data->type != w83782d || !client)\r\n&& i == 1)\r\nbreak;\r\n}\r\ndata->pwm2_enable = (w83781d_read_value(data,\r\nW83781D_REG_PWMCLK12) & 0x08) >> 3;\r\n}\r\ndata->temp = w83781d_read_value(data, W83781D_REG_TEMP(1));\r\ndata->temp_max =\r\nw83781d_read_value(data, W83781D_REG_TEMP_OVER(1));\r\ndata->temp_max_hyst =\r\nw83781d_read_value(data, W83781D_REG_TEMP_HYST(1));\r\ndata->temp_add[0] =\r\nw83781d_read_value(data, W83781D_REG_TEMP(2));\r\ndata->temp_max_add[0] =\r\nw83781d_read_value(data, W83781D_REG_TEMP_OVER(2));\r\ndata->temp_max_hyst_add[0] =\r\nw83781d_read_value(data, W83781D_REG_TEMP_HYST(2));\r\nif (data->type != w83783s) {\r\ndata->temp_add[1] =\r\nw83781d_read_value(data, W83781D_REG_TEMP(3));\r\ndata->temp_max_add[1] =\r\nw83781d_read_value(data,\r\nW83781D_REG_TEMP_OVER(3));\r\ndata->temp_max_hyst_add[1] =\r\nw83781d_read_value(data,\r\nW83781D_REG_TEMP_HYST(3));\r\n}\r\ni = w83781d_read_value(data, W83781D_REG_VID_FANDIV);\r\ndata->vid = i & 0x0f;\r\ndata->vid |= (w83781d_read_value(data,\r\nW83781D_REG_CHIPID) & 0x01) << 4;\r\ndata->fan_div[0] = (i >> 4) & 0x03;\r\ndata->fan_div[1] = (i >> 6) & 0x03;\r\ndata->fan_div[2] = (w83781d_read_value(data,\r\nW83781D_REG_PIN) >> 6) & 0x03;\r\nif ((data->type != w83781d) && (data->type != as99127f)) {\r\ni = w83781d_read_value(data, W83781D_REG_VBAT);\r\ndata->fan_div[0] |= (i >> 3) & 0x04;\r\ndata->fan_div[1] |= (i >> 4) & 0x04;\r\ndata->fan_div[2] |= (i >> 5) & 0x04;\r\n}\r\nif (data->type == w83782d) {\r\ndata->alarms = w83781d_read_value(data,\r\nW83782D_REG_ALARM1)\r\n| (w83781d_read_value(data,\r\nW83782D_REG_ALARM2) << 8)\r\n| (w83781d_read_value(data,\r\nW83782D_REG_ALARM3) << 16);\r\n} else if (data->type == w83783s) {\r\ndata->alarms = w83781d_read_value(data,\r\nW83782D_REG_ALARM1)\r\n| (w83781d_read_value(data,\r\nW83782D_REG_ALARM2) << 8);\r\n} else {\r\ndata->alarms = w83781d_read_value(data,\r\nW83781D_REG_ALARM1)\r\n| (w83781d_read_value(data,\r\nW83781D_REG_ALARM2) << 8);\r\n}\r\ni = w83781d_read_value(data, W83781D_REG_BEEP_INTS2);\r\ndata->beep_mask = (i << 8) +\r\nw83781d_read_value(data, W83781D_REG_BEEP_INTS1);\r\nif ((data->type != w83781d) && (data->type != as99127f)) {\r\ndata->beep_mask |=\r\nw83781d_read_value(data,\r\nW83781D_REG_BEEP_INTS3) << 16;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t\r\nshow_name(struct device *dev, struct device_attribute *devattr, char *buf)\r\n{\r\nstruct w83781d_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic struct w83781d_data *w83781d_data_if_isa(void)\r\n{\r\nreturn pdev ? platform_get_drvdata(pdev) : NULL;\r\n}\r\nstatic int w83781d_alias_detect(struct i2c_client *client, u8 chipid)\r\n{\r\nstruct w83781d_data *isa;\r\nint i;\r\nif (!pdev)\r\nreturn 0;\r\nisa = platform_get_drvdata(pdev);\r\nif (w83781d_read_value(isa, W83781D_REG_I2C_ADDR) != client->addr)\r\nreturn 0;\r\nif (w83781d_read_value(isa, W83781D_REG_WCHIPID) != chipid)\r\nreturn 0;\r\nfor (i = 0x2b; i <= 0x3d; i++) {\r\nif (w83781d_read_value(isa, i) !=\r\ni2c_smbus_read_byte_data(client, i))\r\nreturn 0;\r\n}\r\nif (w83781d_read_value(isa, W83781D_REG_CONFIG) !=\r\ni2c_smbus_read_byte_data(client, W83781D_REG_CONFIG))\r\nreturn 0;\r\nfor (i = 0x43; i <= 0x46; i++) {\r\nif (w83781d_read_value(isa, i) !=\r\ni2c_smbus_read_byte_data(client, i))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nw83781d_read_value_isa(struct w83781d_data *data, u16 reg)\r\n{\r\nint word_sized, res;\r\nword_sized = (((reg & 0xff00) == 0x100)\r\n|| ((reg & 0xff00) == 0x200))\r\n&& (((reg & 0x00ff) == 0x50)\r\n|| ((reg & 0x00ff) == 0x53)\r\n|| ((reg & 0x00ff) == 0x55));\r\nif (reg & 0xff00) {\r\noutb_p(W83781D_REG_BANK,\r\ndata->isa_addr + W83781D_ADDR_REG_OFFSET);\r\noutb_p(reg >> 8,\r\ndata->isa_addr + W83781D_DATA_REG_OFFSET);\r\n}\r\noutb_p(reg & 0xff, data->isa_addr + W83781D_ADDR_REG_OFFSET);\r\nres = inb_p(data->isa_addr + W83781D_DATA_REG_OFFSET);\r\nif (word_sized) {\r\noutb_p((reg & 0xff) + 1,\r\ndata->isa_addr + W83781D_ADDR_REG_OFFSET);\r\nres =\r\n(res << 8) + inb_p(data->isa_addr +\r\nW83781D_DATA_REG_OFFSET);\r\n}\r\nif (reg & 0xff00) {\r\noutb_p(W83781D_REG_BANK,\r\ndata->isa_addr + W83781D_ADDR_REG_OFFSET);\r\noutb_p(0, data->isa_addr + W83781D_DATA_REG_OFFSET);\r\n}\r\nreturn res;\r\n}\r\nstatic void\r\nw83781d_write_value_isa(struct w83781d_data *data, u16 reg, u16 value)\r\n{\r\nint word_sized;\r\nword_sized = (((reg & 0xff00) == 0x100)\r\n|| ((reg & 0xff00) == 0x200))\r\n&& (((reg & 0x00ff) == 0x53)\r\n|| ((reg & 0x00ff) == 0x55));\r\nif (reg & 0xff00) {\r\noutb_p(W83781D_REG_BANK,\r\ndata->isa_addr + W83781D_ADDR_REG_OFFSET);\r\noutb_p(reg >> 8,\r\ndata->isa_addr + W83781D_DATA_REG_OFFSET);\r\n}\r\noutb_p(reg & 0xff, data->isa_addr + W83781D_ADDR_REG_OFFSET);\r\nif (word_sized) {\r\noutb_p(value >> 8,\r\ndata->isa_addr + W83781D_DATA_REG_OFFSET);\r\noutb_p((reg & 0xff) + 1,\r\ndata->isa_addr + W83781D_ADDR_REG_OFFSET);\r\n}\r\noutb_p(value & 0xff, data->isa_addr + W83781D_DATA_REG_OFFSET);\r\nif (reg & 0xff00) {\r\noutb_p(W83781D_REG_BANK,\r\ndata->isa_addr + W83781D_ADDR_REG_OFFSET);\r\noutb_p(0, data->isa_addr + W83781D_DATA_REG_OFFSET);\r\n}\r\n}\r\nstatic int\r\nw83781d_read_value(struct w83781d_data *data, u16 reg)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint res;\r\nmutex_lock(&data->lock);\r\nif (client)\r\nres = w83781d_read_value_i2c(data, reg);\r\nelse\r\nres = w83781d_read_value_isa(data, reg);\r\nmutex_unlock(&data->lock);\r\nreturn res;\r\n}\r\nstatic int\r\nw83781d_write_value(struct w83781d_data *data, u16 reg, u16 value)\r\n{\r\nstruct i2c_client *client = data->client;\r\nmutex_lock(&data->lock);\r\nif (client)\r\nw83781d_write_value_i2c(data, reg, value);\r\nelse\r\nw83781d_write_value_isa(data, reg, value);\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nw83781d_isa_probe(struct platform_device *pdev)\r\n{\r\nint err, reg;\r\nstruct w83781d_data *data;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!request_region(res->start + W83781D_ADDR_REG_OFFSET, 2,\r\n"w83781d")) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\ndata = kzalloc(sizeof(struct w83781d_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit_release_region;\r\n}\r\nmutex_init(&data->lock);\r\ndata->isa_addr = res->start;\r\nplatform_set_drvdata(pdev, data);\r\nreg = w83781d_read_value(data, W83781D_REG_WCHIPID);\r\nswitch (reg) {\r\ncase 0x30:\r\ndata->type = w83782d;\r\ndata->name = "w83782d";\r\nbreak;\r\ndefault:\r\ndata->type = w83781d;\r\ndata->name = "w83781d";\r\n}\r\nw83781d_init_device(&pdev->dev);\r\nerr = w83781d_create_files(&pdev->dev, data->type, 1);\r\nif (err)\r\ngoto exit_remove_files;\r\nerr = device_create_file(&pdev->dev, &dev_attr_name);\r\nif (err)\r\ngoto exit_remove_files;\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&pdev->dev.kobj, &w83781d_group);\r\nsysfs_remove_group(&pdev->dev.kobj, &w83781d_group_opt);\r\ndevice_remove_file(&pdev->dev, &dev_attr_name);\r\nkfree(data);\r\nexit_release_region:\r\nrelease_region(res->start + W83781D_ADDR_REG_OFFSET, 2);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit\r\nw83781d_isa_remove(struct platform_device *pdev)\r\n{\r\nstruct w83781d_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &w83781d_group);\r\nsysfs_remove_group(&pdev->dev.kobj, &w83781d_group_opt);\r\ndevice_remove_file(&pdev->dev, &dev_attr_name);\r\nrelease_region(data->isa_addr + W83781D_ADDR_REG_OFFSET, 2);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nw83781d_isa_found(unsigned short address)\r\n{\r\nint val, save, found = 0;\r\nint port;\r\nfor (port = address; port < address + W83781D_EXTENT; port++) {\r\nif (!request_region(port, 1, "w83781d")) {\r\npr_debug("Failed to request port 0x%x\n", port);\r\ngoto release;\r\n}\r\n}\r\n#define REALLY_SLOW_IO\r\nval = inb_p(address + 1);\r\nif (inb_p(address + 2) != val\r\n|| inb_p(address + 3) != val\r\n|| inb_p(address + 7) != val) {\r\npr_debug("Detection failed at step %d\n", 1);\r\ngoto release;\r\n}\r\n#undef REALLY_SLOW_IO\r\nsave = inb_p(address + W83781D_ADDR_REG_OFFSET);\r\nif (save & 0x80) {\r\npr_debug("Detection failed at step %d\n", 2);\r\ngoto release;\r\n}\r\nval = ~save & 0x7f;\r\noutb_p(val, address + W83781D_ADDR_REG_OFFSET);\r\nif (inb_p(address + W83781D_ADDR_REG_OFFSET) != (val | 0x80)) {\r\noutb_p(save, address + W83781D_ADDR_REG_OFFSET);\r\npr_debug("Detection failed at step %d\n", 3);\r\ngoto release;\r\n}\r\noutb_p(W83781D_REG_CONFIG, address + W83781D_ADDR_REG_OFFSET);\r\nval = inb_p(address + W83781D_DATA_REG_OFFSET);\r\nif (val & 0x80) {\r\npr_debug("Detection failed at step %d\n", 4);\r\ngoto release;\r\n}\r\noutb_p(W83781D_REG_BANK, address + W83781D_ADDR_REG_OFFSET);\r\nsave = inb_p(address + W83781D_DATA_REG_OFFSET);\r\noutb_p(W83781D_REG_CHIPMAN, address + W83781D_ADDR_REG_OFFSET);\r\nval = inb_p(address + W83781D_DATA_REG_OFFSET);\r\nif ((!(save & 0x80) && (val != 0xa3))\r\n|| ((save & 0x80) && (val != 0x5c))) {\r\npr_debug("Detection failed at step %d\n", 5);\r\ngoto release;\r\n}\r\noutb_p(W83781D_REG_I2C_ADDR, address + W83781D_ADDR_REG_OFFSET);\r\nval = inb_p(address + W83781D_DATA_REG_OFFSET);\r\nif (val < 0x03 || val > 0x77) {\r\npr_debug("Detection failed at step %d\n", 6);\r\ngoto release;\r\n}\r\nif (inb_p(address + W83781D_ADDR_REG_OFFSET) & 0x80) {\r\npr_debug("Detection failed at step %d\n", 7);\r\ngoto release;\r\n}\r\noutb_p(W83781D_REG_BANK, address + W83781D_ADDR_REG_OFFSET);\r\nsave = inb_p(address + W83781D_DATA_REG_OFFSET);\r\noutb_p(save & 0xf8, address + W83781D_DATA_REG_OFFSET);\r\noutb_p(W83781D_REG_WCHIPID, address + W83781D_ADDR_REG_OFFSET);\r\nval = inb_p(address + W83781D_DATA_REG_OFFSET);\r\nif ((val & 0xfe) == 0x10\r\n|| val == 0x30)\r\nfound = 1;\r\nif (found)\r\npr_info("Found a %s chip at %#x\n",\r\nval == 0x30 ? "W83782D" : "W83781D", (int)address);\r\nrelease:\r\nfor (port--; port >= address; port--)\r\nrelease_region(port, 1);\r\nreturn found;\r\n}\r\nstatic int __init\r\nw83781d_isa_device_add(unsigned short address)\r\n{\r\nstruct resource res = {\r\n.start = address,\r\n.end = address + W83781D_EXTENT - 1,\r\n.name = "w83781d",\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\npdev = platform_device_alloc("w83781d", address);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit;\r\n}\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\npdev = NULL;\r\nreturn err;\r\n}\r\nstatic int __init\r\nw83781d_isa_register(void)\r\n{\r\nint res;\r\nif (w83781d_isa_found(isa_address)) {\r\nres = platform_driver_register(&w83781d_isa_driver);\r\nif (res)\r\ngoto exit;\r\nres = w83781d_isa_device_add(isa_address);\r\nif (res)\r\ngoto exit_unreg_isa_driver;\r\n}\r\nreturn 0;\r\nexit_unreg_isa_driver:\r\nplatform_driver_unregister(&w83781d_isa_driver);\r\nexit:\r\nreturn res;\r\n}\r\nstatic void\r\nw83781d_isa_unregister(void)\r\n{\r\nif (pdev) {\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&w83781d_isa_driver);\r\n}\r\n}\r\nstatic struct w83781d_data *w83781d_data_if_isa(void)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int\r\nw83781d_alias_detect(struct i2c_client *client, u8 chipid)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nw83781d_read_value(struct w83781d_data *data, u16 reg)\r\n{\r\nint res;\r\nmutex_lock(&data->lock);\r\nres = w83781d_read_value_i2c(data, reg);\r\nmutex_unlock(&data->lock);\r\nreturn res;\r\n}\r\nstatic int\r\nw83781d_write_value(struct w83781d_data *data, u16 reg, u16 value)\r\n{\r\nmutex_lock(&data->lock);\r\nw83781d_write_value_i2c(data, reg, value);\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nw83781d_isa_register(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nw83781d_isa_unregister(void)\r\n{\r\n}\r\nstatic int __init\r\nsensors_w83781d_init(void)\r\n{\r\nint res;\r\nres = w83781d_isa_register();\r\nif (res)\r\ngoto exit;\r\nres = i2c_add_driver(&w83781d_driver);\r\nif (res)\r\ngoto exit_unreg_isa;\r\nreturn 0;\r\nexit_unreg_isa:\r\nw83781d_isa_unregister();\r\nexit:\r\nreturn res;\r\n}\r\nstatic void __exit\r\nsensors_w83781d_exit(void)\r\n{\r\nw83781d_isa_unregister();\r\ni2c_del_driver(&w83781d_driver);\r\n}
