static u32 rtl8192_CalculateBitShift(u32 dwBitMask)\r\n{\r\nu32 i;\r\nfor (i=0; i<=31; i++)\r\n{\r\nif (((dwBitMask>>i)&0x1) == 1)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nu8 rtl8192_phy_CheckIsLegalRFPath(struct r8192_priv *priv, u32 eRFPath)\r\n{\r\nu8 ret = 1;\r\nif (priv->rf_type == RF_2T4R)\r\nret = 0;\r\nelse if (priv->rf_type == RF_1T2R)\r\n{\r\nif (eRFPath == RF90_PATH_A || eRFPath == RF90_PATH_B)\r\nret = 1;\r\nelse if (eRFPath == RF90_PATH_C || eRFPath == RF90_PATH_D)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl8192_setBBreg(struct r8192_priv *priv, u32 dwRegAddr, u32 dwBitMask, u32 dwData)\r\n{\r\nu32 OriginalValue, BitShift, NewValue;\r\nif(dwBitMask!= bMaskDWord)\r\n{\r\nOriginalValue = read_nic_dword(priv, dwRegAddr);\r\nBitShift = rtl8192_CalculateBitShift(dwBitMask);\r\nNewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));\r\nwrite_nic_dword(priv, dwRegAddr, NewValue);\r\n}else\r\nwrite_nic_dword(priv, dwRegAddr, dwData);\r\n}\r\nu32 rtl8192_QueryBBReg(struct r8192_priv *priv, u32 dwRegAddr, u32 dwBitMask)\r\n{\r\nu32 OriginalValue, BitShift;\r\nOriginalValue = read_nic_dword(priv, dwRegAddr);\r\nBitShift = rtl8192_CalculateBitShift(dwBitMask);\r\nreturn (OriginalValue & dwBitMask) >> BitShift;\r\n}\r\nstatic u32 rtl8192_phy_RFSerialRead(struct r8192_priv *priv,\r\nRF90_RADIO_PATH_E eRFPath, u32 Offset)\r\n{\r\nu32 ret = 0;\r\nu32 NewOffset = 0;\r\nBB_REGISTER_DEFINITION_T* pPhyReg = &priv->PHYRegDef[eRFPath];\r\nOffset &= 0x3f;\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter4, 0xf00, 0x0);\r\nif (Offset >= 31)\r\n{\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl8192_setBBreg(priv, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );\r\nNewOffset = Offset -30;\r\n}\r\nelse if (Offset >= 16)\r\n{\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl8192_setBBreg(priv, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );\r\nNewOffset = Offset - 15;\r\n}\r\nelse\r\nNewOffset = Offset;\r\nrtl8192_setBBreg(priv, pPhyReg->rfHSSIPara2, bLSSIReadAddress, NewOffset);\r\nrtl8192_setBBreg(priv, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x0);\r\nrtl8192_setBBreg(priv, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x1);\r\nmsleep(1);\r\nret = rtl8192_QueryBBReg(priv, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl8192_setBBreg(\r\npriv,\r\npPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter4, 0x300, 0x3);\r\nreturn ret;\r\n}\r\nstatic void rtl8192_phy_RFSerialWrite(struct r8192_priv *priv,\r\nRF90_RADIO_PATH_E eRFPath, u32 Offset,\r\nu32 Data)\r\n{\r\nu32 DataAndAddr = 0, NewOffset = 0;\r\nBB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];\r\nOffset &= 0x3f;\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter4, 0xf00, 0x0);\r\nif (Offset >= 31)\r\n{\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl8192_setBBreg(priv, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath] << 16));\r\nNewOffset = Offset - 30;\r\n}\r\nelse if (Offset >= 16)\r\n{\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl8192_setBBreg(priv, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));\r\nNewOffset = Offset - 15;\r\n}\r\nelse\r\nNewOffset = Offset;\r\nDataAndAddr = (Data<<16) | (NewOffset&0x3f);\r\nrtl8192_setBBreg(priv, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);\r\nif(Offset==0x0)\r\npriv->RfReg0Value[eRFPath] = Data;\r\nif(Offset != 0)\r\n{\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl8192_setBBreg(\r\npriv,\r\npPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\n}\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter4, 0x300, 0x3);\r\n}\r\nvoid rtl8192_phy_SetRFReg(struct r8192_priv *priv, RF90_RADIO_PATH_E eRFPath,\r\nu32 RegAddr, u32 BitMask, u32 Data)\r\n{\r\nu32 Original_Value, BitShift, New_Value;\r\nif (!rtl8192_phy_CheckIsLegalRFPath(priv, eRFPath))\r\nreturn;\r\nif (priv->eRFPowerState != eRfOn && !priv->being_init_adapter)\r\nreturn;\r\nRT_TRACE(COMP_PHY, "FW RF CTRL is not ready now\n");\r\nif (priv->Rf_Mode == RF_OP_By_FW)\r\n{\r\nif (BitMask != bMask12Bits)\r\n{\r\nOriginal_Value = phy_FwRFSerialRead(priv, eRFPath, RegAddr);\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nNew_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));\r\nphy_FwRFSerialWrite(priv, eRFPath, RegAddr, New_Value);\r\n}else\r\nphy_FwRFSerialWrite(priv, eRFPath, RegAddr, Data);\r\nudelay(200);\r\n}\r\nelse\r\n{\r\nif (BitMask != bMask12Bits)\r\n{\r\nOriginal_Value = rtl8192_phy_RFSerialRead(priv, eRFPath, RegAddr);\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nNew_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));\r\nrtl8192_phy_RFSerialWrite(priv, eRFPath, RegAddr, New_Value);\r\n}else\r\nrtl8192_phy_RFSerialWrite(priv, eRFPath, RegAddr, Data);\r\n}\r\n}\r\nu32 rtl8192_phy_QueryRFReg(struct r8192_priv *priv, RF90_RADIO_PATH_E eRFPath,\r\nu32 RegAddr, u32 BitMask)\r\n{\r\nu32 Original_Value, Readback_Value, BitShift;\r\nif (!rtl8192_phy_CheckIsLegalRFPath(priv, eRFPath))\r\nreturn 0;\r\nif (priv->eRFPowerState != eRfOn && !priv->being_init_adapter)\r\nreturn 0;\r\ndown(&priv->rf_sem);\r\nif (priv->Rf_Mode == RF_OP_By_FW)\r\n{\r\nOriginal_Value = phy_FwRFSerialRead(priv, eRFPath, RegAddr);\r\nudelay(200);\r\n}\r\nelse\r\n{\r\nOriginal_Value = rtl8192_phy_RFSerialRead(priv, eRFPath, RegAddr);\r\n}\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nReadback_Value = (Original_Value & BitMask) >> BitShift;\r\nup(&priv->rf_sem);\r\nreturn Readback_Value;\r\n}\r\nstatic u32 phy_FwRFSerialRead(struct r8192_priv *priv,\r\nRF90_RADIO_PATH_E eRFPath, u32 Offset)\r\n{\r\nu32 Data = 0;\r\nu8 time = 0;\r\nData |= ((Offset&0xFF)<<12);\r\nData |= ((eRFPath&0x3)<<20);\r\nData |= 0x80000000;\r\nwhile (read_nic_dword(priv, QPNR)&0x80000000)\r\n{\r\nif (time++ < 100)\r\n{\r\nudelay(10);\r\n}\r\nelse\r\nbreak;\r\n}\r\nwrite_nic_dword(priv, QPNR, Data);\r\nwhile (read_nic_dword(priv, QPNR)&0x80000000)\r\n{\r\nif (time++ < 100)\r\n{\r\nudelay(10);\r\n}\r\nelse\r\nreturn 0;\r\n}\r\nreturn read_nic_dword(priv, RF_DATA);\r\n}\r\nstatic void phy_FwRFSerialWrite(struct r8192_priv *priv,\r\nRF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)\r\n{\r\nu8 time = 0;\r\nData |= ((Offset&0xFF)<<12);\r\nData |= ((eRFPath&0x3)<<20);\r\nData |= 0x400000;\r\nData |= 0x80000000;\r\nwhile (read_nic_dword(priv, QPNR)&0x80000000)\r\n{\r\nif (time++ < 100)\r\n{\r\nudelay(10);\r\n}\r\nelse\r\nbreak;\r\n}\r\nwrite_nic_dword(priv, QPNR, Data);\r\n}\r\nvoid rtl8192_phy_configmac(struct r8192_priv *priv)\r\n{\r\nu32 dwArrayLen = 0, i = 0;\r\nu32* pdwArray = NULL;\r\n#ifdef TO_DO_LIST\r\nif(Adapter->bInHctTest)\r\n{\r\nRT_TRACE(COMP_PHY, "Rtl819XMACPHY_ArrayDTM\n");\r\ndwArrayLen = MACPHY_ArrayLengthDTM;\r\npdwArray = Rtl819XMACPHY_ArrayDTM;\r\n}\r\nelse if(priv->bTXPowerDataReadFromEEPORM)\r\n#endif\r\nif(priv->bTXPowerDataReadFromEEPORM)\r\n{\r\nRT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");\r\ndwArrayLen = MACPHY_Array_PGLength;\r\npdwArray = Rtl819XMACPHY_Array_PG;\r\n}\r\nelse\r\n{\r\nRT_TRACE(COMP_PHY,"Read rtl819XMACPHY_Array\n");\r\ndwArrayLen = MACPHY_ArrayLength;\r\npdwArray = Rtl819XMACPHY_Array;\r\n}\r\nfor(i = 0; i<dwArrayLen; i=i+3){\r\nRT_TRACE(COMP_DBG, "The Rtl8190MACPHY_Array[0] is %x Rtl8190MACPHY_Array[1] is %x Rtl8190MACPHY_Array[2] is %x\n",\r\npdwArray[i], pdwArray[i+1], pdwArray[i+2]);\r\nif(pdwArray[i] == 0x318)\r\n{\r\npdwArray[i+2] = 0x00000800;\r\n}\r\nrtl8192_setBBreg(priv, pdwArray[i], pdwArray[i+1], pdwArray[i+2]);\r\n}\r\n}\r\nvoid rtl8192_phyConfigBB(struct r8192_priv *priv, u8 ConfigType)\r\n{\r\nint i;\r\nu32* Rtl819XPHY_REGArray_Table = NULL;\r\nu32* Rtl819XAGCTAB_Array_Table = NULL;\r\nu16 AGCTAB_ArrayLen, PHY_REGArrayLen = 0;\r\n#ifdef TO_DO_LIST\r\nu32 *rtl8192PhyRegArrayTable = NULL, *rtl8192AgcTabArrayTable = NULL;\r\nif(Adapter->bInHctTest)\r\n{\r\nAGCTAB_ArrayLen = AGCTAB_ArrayLengthDTM;\r\nRtl819XAGCTAB_Array_Table = Rtl819XAGCTAB_ArrayDTM;\r\nif(priv->RF_Type == RF_2T4R)\r\n{\r\nPHY_REGArrayLen = PHY_REGArrayLengthDTM;\r\nRtl819XPHY_REGArray_Table = Rtl819XPHY_REGArrayDTM;\r\n}\r\nelse if (priv->RF_Type == RF_1T2R)\r\n{\r\nPHY_REGArrayLen = PHY_REG_1T2RArrayLengthDTM;\r\nRtl819XPHY_REGArray_Table = Rtl819XPHY_REG_1T2RArrayDTM;\r\n}\r\n}\r\nelse\r\n#endif\r\n{\r\nAGCTAB_ArrayLen = AGCTAB_ArrayLength;\r\nRtl819XAGCTAB_Array_Table = Rtl819XAGCTAB_Array;\r\nif(priv->rf_type == RF_2T4R)\r\n{\r\nPHY_REGArrayLen = PHY_REGArrayLength;\r\nRtl819XPHY_REGArray_Table = Rtl819XPHY_REGArray;\r\n}\r\nelse if (priv->rf_type == RF_1T2R)\r\n{\r\nPHY_REGArrayLen = PHY_REG_1T2RArrayLength;\r\nRtl819XPHY_REGArray_Table = Rtl819XPHY_REG_1T2RArray;\r\n}\r\n}\r\nif (ConfigType == BaseBand_Config_PHY_REG)\r\n{\r\nfor (i=0; i<PHY_REGArrayLen; i+=2)\r\n{\r\nrtl8192_setBBreg(priv, Rtl819XPHY_REGArray_Table[i], bMaskDWord, Rtl819XPHY_REGArray_Table[i+1]);\r\nRT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x\n",i, Rtl819XPHY_REGArray_Table[i], Rtl819XPHY_REGArray_Table[i+1]);\r\n}\r\n}\r\nelse if (ConfigType == BaseBand_Config_AGC_TAB)\r\n{\r\nfor (i=0; i<AGCTAB_ArrayLen; i+=2)\r\n{\r\nrtl8192_setBBreg(priv, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);\r\nRT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x\n",i, Rtl819XAGCTAB_Array_Table[i], Rtl819XAGCTAB_Array_Table[i+1]);\r\n}\r\n}\r\n}\r\nstatic void rtl8192_InitBBRFRegDef(struct r8192_priv *priv)\r\n{\r\npriv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rf3wireOffset = rFPGA0_XD_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;\r\n}\r\nRT_STATUS rtl8192_phy_checkBBAndRF(struct r8192_priv *priv,\r\nHW90_BLOCK_E CheckBlock,\r\nRF90_RADIO_PATH_E eRFPath)\r\n{\r\nRT_STATUS ret = RT_STATUS_SUCCESS;\r\nu32 i, CheckTimes = 4, dwRegRead = 0;\r\nu32 WriteAddr[4];\r\nu32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};\r\nWriteAddr[HW90_BLOCK_MAC] = 0x100;\r\nWriteAddr[HW90_BLOCK_PHY0] = 0x900;\r\nWriteAddr[HW90_BLOCK_PHY1] = 0x800;\r\nWriteAddr[HW90_BLOCK_RF] = 0x3;\r\nRT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);\r\nfor(i=0 ; i < CheckTimes ; i++)\r\n{\r\nswitch(CheckBlock)\r\n{\r\ncase HW90_BLOCK_MAC:\r\nRT_TRACE(COMP_ERR, "PHY_CheckBBRFOK(): Never Write 0x100 here!\n");\r\nbreak;\r\ncase HW90_BLOCK_PHY0:\r\ncase HW90_BLOCK_PHY1:\r\nwrite_nic_dword(priv, WriteAddr[CheckBlock], WriteData[i]);\r\ndwRegRead = read_nic_dword(priv, WriteAddr[CheckBlock]);\r\nbreak;\r\ncase HW90_BLOCK_RF:\r\nWriteData[i] &= 0xfff;\r\nrtl8192_phy_SetRFReg(priv, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits, WriteData[i]);\r\nmdelay(10);\r\ndwRegRead = rtl8192_phy_QueryRFReg(priv, eRFPath, WriteAddr[HW90_BLOCK_RF], bMaskDWord);\r\nmdelay(10);\r\nbreak;\r\ndefault:\r\nret = RT_STATUS_FAILURE;\r\nbreak;\r\n}\r\nif(dwRegRead != WriteData[i])\r\n{\r\nRT_TRACE(COMP_ERR, "====>error=====dwRegRead: %x, WriteData: %x\n", dwRegRead, WriteData[i]);\r\nret = RT_STATUS_FAILURE;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic RT_STATUS rtl8192_BB_Config_ParaFile(struct r8192_priv *priv)\r\n{\r\nRT_STATUS rtStatus = RT_STATUS_SUCCESS;\r\nu8 bRegValue = 0, eCheckItem = 0;\r\nu32 dwRegValue = 0;\r\nbRegValue = read_nic_byte(priv, BB_GLOBAL_RESET);\r\nwrite_nic_byte(priv, BB_GLOBAL_RESET,(bRegValue|BB_GLOBAL_RESET_BIT));\r\ndwRegValue = read_nic_dword(priv, CPU_GEN);\r\nwrite_nic_dword(priv, CPU_GEN, (dwRegValue&(~CPU_GEN_BB_RST)));\r\nfor(eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++)\r\n{\r\nrtStatus = rtl8192_phy_checkBBAndRF(priv, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0);\r\nif(rtStatus != RT_STATUS_SUCCESS)\r\n{\r\nRT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);\r\nreturn rtStatus;\r\n}\r\n}\r\nrtl8192_setBBreg(priv, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);\r\nrtl8192_phyConfigBB(priv, BaseBand_Config_PHY_REG);\r\ndwRegValue = read_nic_dword(priv, CPU_GEN);\r\nwrite_nic_dword(priv, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));\r\nrtl8192_phyConfigBB(priv, BaseBand_Config_AGC_TAB);\r\nif (priv->card_8192_version > VERSION_8190_BD)\r\n{\r\nif(priv->rf_type == RF_2T4R)\r\n{\r\ndwRegValue = ( priv->AntennaTxPwDiff[2]<<8 |\r\npriv->AntennaTxPwDiff[1]<<4 |\r\npriv->AntennaTxPwDiff[0]);\r\n}\r\nelse\r\ndwRegValue = 0x0;\r\nrtl8192_setBBreg(priv, rFPGA0_TxGainStage,\r\n(bXBTxAGC|bXCTxAGC|bXDTxAGC), dwRegValue);\r\ndwRegValue = priv->CrystalCap;\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter1, bXtalCap92x, dwRegValue);\r\n}\r\nreturn rtStatus;\r\n}\r\nRT_STATUS rtl8192_BBConfig(struct r8192_priv *priv)\r\n{\r\nrtl8192_InitBBRFRegDef(priv);\r\nreturn rtl8192_BB_Config_ParaFile(priv);\r\n}\r\nvoid rtl8192_phy_getTxPower(struct r8192_priv *priv)\r\n{\r\npriv->MCSTxPowerLevelOriginalOffset[0] =\r\nread_nic_dword(priv, rTxAGC_Rate18_06);\r\npriv->MCSTxPowerLevelOriginalOffset[1] =\r\nread_nic_dword(priv, rTxAGC_Rate54_24);\r\npriv->MCSTxPowerLevelOriginalOffset[2] =\r\nread_nic_dword(priv, rTxAGC_Mcs03_Mcs00);\r\npriv->MCSTxPowerLevelOriginalOffset[3] =\r\nread_nic_dword(priv, rTxAGC_Mcs07_Mcs04);\r\npriv->MCSTxPowerLevelOriginalOffset[4] =\r\nread_nic_dword(priv, rTxAGC_Mcs11_Mcs08);\r\npriv->MCSTxPowerLevelOriginalOffset[5] =\r\nread_nic_dword(priv, rTxAGC_Mcs15_Mcs12);\r\npriv->DefaultInitialGain[0] = read_nic_byte(priv, rOFDM0_XAAGCCore1);\r\npriv->DefaultInitialGain[1] = read_nic_byte(priv, rOFDM0_XBAGCCore1);\r\npriv->DefaultInitialGain[2] = read_nic_byte(priv, rOFDM0_XCAGCCore1);\r\npriv->DefaultInitialGain[3] = read_nic_byte(priv, rOFDM0_XDAGCCore1);\r\nRT_TRACE(COMP_INIT, "Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x)\n",\r\npriv->DefaultInitialGain[0], priv->DefaultInitialGain[1],\r\npriv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);\r\npriv->framesync = read_nic_byte(priv, rOFDM0_RxDetector3);\r\npriv->framesyncC34 = read_nic_dword(priv, rOFDM0_RxDetector2);\r\nRT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x\n",\r\nrOFDM0_RxDetector3, priv->framesync);\r\npriv->SifsTime = read_nic_word(priv, SIFS);\r\n}\r\nvoid rtl8192_phy_setTxPower(struct r8192_priv *priv, u8 channel)\r\n{\r\nu8 powerlevel = 0,powerlevelOFDM24G = 0;\r\nchar ant_pwr_diff;\r\nu32 u4RegValue;\r\nif(priv->epromtype == EPROM_93c46)\r\n{\r\npowerlevel = priv->TxPowerLevelCCK[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\n}\r\nelse if(priv->epromtype == EPROM_93c56)\r\n{\r\nif(priv->rf_type == RF_1T2R)\r\n{\r\npowerlevel = priv->TxPowerLevelCCK_C[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G_C[channel-1];\r\n}\r\nelse if(priv->rf_type == RF_2T4R)\r\n{\r\npowerlevel = priv->TxPowerLevelCCK_A[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G_A[channel-1];\r\nant_pwr_diff = priv->TxPowerLevelOFDM24G_C[channel-1]\r\n-priv->TxPowerLevelOFDM24G_A[channel-1];\r\nant_pwr_diff &= 0xf;\r\npriv->AntennaTxPwDiff[2] = 0;\r\npriv->AntennaTxPwDiff[1] = (u8)(ant_pwr_diff);\r\npriv->AntennaTxPwDiff[0] = 0;\r\nu4RegValue = ( priv->AntennaTxPwDiff[2]<<8 |\r\npriv->AntennaTxPwDiff[1]<<4 |\r\npriv->AntennaTxPwDiff[0]);\r\nrtl8192_setBBreg(priv, rFPGA0_TxGainStage,\r\n(bXBTxAGC|bXCTxAGC|bXDTxAGC), u4RegValue);\r\n}\r\n}\r\n#ifdef TODO\r\nif( pMgntInfo->OpMode == RT_OP_MODE_INFRASTRUCTURE &&\r\npMgntInfo->bWithCcxCellPwr &&\r\nchannel == pMgntInfo->dot11CurrentChannelNumber)\r\n{\r\nu8 CckCellPwrIdx = DbmToTxPwrIdx(Adapter, WIRELESS_MODE_B, pMgntInfo->CcxCellPwr);\r\nu8 LegacyOfdmCellPwrIdx = DbmToTxPwrIdx(Adapter, WIRELESS_MODE_G, pMgntInfo->CcxCellPwr);\r\nu8 OfdmCellPwrIdx = DbmToTxPwrIdx(Adapter, WIRELESS_MODE_N_24G, pMgntInfo->CcxCellPwr);\r\nRT_TRACE(COMP_TXAGC, DBG_LOUD,\r\n("CCX Cell Limit: %d dbm => CCK Tx power index : %d, Legacy OFDM Tx power index : %d, OFDM Tx power index: %d\n",\r\npMgntInfo->CcxCellPwr, CckCellPwrIdx, LegacyOfdmCellPwrIdx, OfdmCellPwrIdx));\r\nRT_TRACE(COMP_TXAGC, DBG_LOUD,\r\n("EEPROM channel(%d) => CCK Tx power index: %d, Legacy OFDM Tx power index : %d, OFDM Tx power index: %d\n",\r\nchannel, powerlevel, powerlevelOFDM24G + pHalData->LegacyHTTxPowerDiff, powerlevelOFDM24G));\r\nif(powerlevel > CckCellPwrIdx)\r\npowerlevel = CckCellPwrIdx;\r\nif(powerlevelOFDM24G + pHalData->LegacyHTTxPowerDiff > OfdmCellPwrIdx)\r\n{\r\nif((OfdmCellPwrIdx - pHalData->LegacyHTTxPowerDiff) > 0)\r\n{\r\npowerlevelOFDM24G = OfdmCellPwrIdx - pHalData->LegacyHTTxPowerDiff;\r\n}\r\nelse\r\n{\r\nLegacyOfdmCellPwrIdx = 0;\r\n}\r\n}\r\nRT_TRACE(COMP_TXAGC, DBG_LOUD,\r\n("Altered CCK Tx power index : %d, Legacy OFDM Tx power index: %d, OFDM Tx power index: %d\n",\r\npowerlevel, powerlevelOFDM24G + pHalData->LegacyHTTxPowerDiff, powerlevelOFDM24G));\r\n}\r\npHalData->CurrentCckTxPwrIdx = powerlevel;\r\npHalData->CurrentOfdm24GTxPwrIdx = powerlevelOFDM24G;\r\n#endif\r\nPHY_SetRF8256CCKTxPower(priv, powerlevel);\r\nPHY_SetRF8256OFDMTxPower(priv, powerlevelOFDM24G);\r\n}\r\nRT_STATUS rtl8192_phy_RFConfig(struct r8192_priv *priv)\r\n{\r\nreturn PHY_RF8256_Config(priv);\r\n}\r\nvoid rtl8192_phy_updateInitGain(struct r8192_priv *priv)\r\n{\r\n}\r\nu8 rtl8192_phy_ConfigRFWithHeaderFile(struct r8192_priv *priv,\r\nRF90_RADIO_PATH_E eRFPath)\r\n{\r\nint i;\r\nu8 ret = 0;\r\nswitch(eRFPath){\r\ncase RF90_PATH_A:\r\nfor(i = 0;i<RadioA_ArrayLength; i=i+2){\r\nif(Rtl819XRadioA_Array[i] == 0xfe){\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(priv, eRFPath, Rtl819XRadioA_Array[i], bMask12Bits, Rtl819XRadioA_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nfor(i = 0;i<RadioB_ArrayLength; i=i+2){\r\nif(Rtl819XRadioB_Array[i] == 0xfe){\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(priv, eRFPath, Rtl819XRadioB_Array[i], bMask12Bits, Rtl819XRadioB_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\nfor(i = 0;i<RadioC_ArrayLength; i=i+2){\r\nif(Rtl819XRadioC_Array[i] == 0xfe){\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(priv, eRFPath, Rtl819XRadioC_Array[i], bMask12Bits, Rtl819XRadioC_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_D:\r\nfor(i = 0;i<RadioD_ArrayLength; i=i+2){\r\nif(Rtl819XRadioD_Array[i] == 0xfe){\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(priv, eRFPath, Rtl819XRadioD_Array[i], bMask12Bits, Rtl819XRadioD_Array[i+1]);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl8192_SetTxPowerLevel(struct r8192_priv *priv, u8 channel)\r\n{\r\nu8 powerlevel = priv->TxPowerLevelCCK[channel-1];\r\nu8 powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\nPHY_SetRF8256CCKTxPower(priv, powerlevel);\r\nPHY_SetRF8256OFDMTxPower(priv, powerlevelOFDM24G);\r\n}\r\nstatic u8 rtl8192_phy_SetSwChnlCmdArray(\r\nSwChnlCmd* CmdTable,\r\nu32 CmdTableIdx,\r\nu32 CmdTableSz,\r\nSwChnlCmdID CmdID,\r\nu32 Para1,\r\nu32 Para2,\r\nu32 msDelay\r\n)\r\n{\r\nSwChnlCmd* pCmd;\r\nif(CmdTable == NULL)\r\n{\r\nRT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): CmdTable cannot be NULL.\n");\r\nreturn false;\r\n}\r\nif(CmdTableIdx >= CmdTableSz)\r\n{\r\nRT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\n",\r\nCmdTableIdx, CmdTableSz);\r\nreturn false;\r\n}\r\npCmd = CmdTable + CmdTableIdx;\r\npCmd->CmdID = CmdID;\r\npCmd->Para1 = Para1;\r\npCmd->Para2 = Para2;\r\npCmd->msDelay = msDelay;\r\nreturn true;\r\n}\r\nstatic u8 rtl8192_phy_SwChnlStepByStep(struct r8192_priv *priv, u8 channel,\r\nu8* stage, u8* step, u32* delay)\r\n{\r\nSwChnlCmd PreCommonCmd[MAX_PRECMD_CNT];\r\nu32 PreCommonCmdCnt;\r\nSwChnlCmd PostCommonCmd[MAX_POSTCMD_CNT];\r\nu32 PostCommonCmdCnt;\r\nSwChnlCmd RfDependCmd[MAX_RFDEPENDCMD_CNT];\r\nu32 RfDependCmdCnt;\r\nSwChnlCmd *CurrentCmd = NULL;\r\nu8 eRFPath;\r\nRT_TRACE(COMP_TRACE, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);\r\n#ifdef ENABLE_DOT11D\r\nif (!IsLegalChannel(priv->ieee80211, channel))\r\n{\r\nRT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n", channel);\r\nreturn true;\r\n}\r\n#endif\r\n{\r\nPreCommonCmdCnt = 0;\r\nrtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,\r\nCmdID_SetTxPowerLevel, 0, 0, 0);\r\nrtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nPostCommonCmdCnt = 0;\r\nrtl8192_phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++, MAX_POSTCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nRfDependCmdCnt = 0;\r\nif (!(channel >= 1 && channel <= 14))\r\n{\r\nRT_TRACE(COMP_ERR, "illegal channel for Zebra 8256: %d\n", channel);\r\nreturn false;\r\n}\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg, rZebra1_Channel, channel, 10);\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\ndo{\r\nswitch(*stage)\r\n{\r\ncase 0:\r\nCurrentCmd=&PreCommonCmd[*step];\r\nbreak;\r\ncase 1:\r\nCurrentCmd=&RfDependCmd[*step];\r\nbreak;\r\ncase 2:\r\nCurrentCmd=&PostCommonCmd[*step];\r\nbreak;\r\n}\r\nif(CurrentCmd->CmdID==CmdID_End)\r\n{\r\nif((*stage)==2)\r\n{\r\nreturn true;\r\n}\r\nelse\r\n{\r\n(*stage)++;\r\n(*step)=0;\r\ncontinue;\r\n}\r\n}\r\nswitch(CurrentCmd->CmdID)\r\n{\r\ncase CmdID_SetTxPowerLevel:\r\nif(priv->card_8192_version > (u8)VERSION_8190_BD)\r\nrtl8192_SetTxPowerLevel(priv, channel);\r\nbreak;\r\ncase CmdID_WritePortUlong:\r\nwrite_nic_dword(priv, CurrentCmd->Para1, CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUshort:\r\nwrite_nic_word(priv, CurrentCmd->Para1, (u16)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUchar:\r\nwrite_nic_byte(priv, CurrentCmd->Para1, (u8)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_RF_WriteReg:\r\nfor(eRFPath = 0; eRFPath <priv->NumTotalRFPath; eRFPath++)\r\nrtl8192_phy_SetRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bMask12Bits, CurrentCmd->Para2<<7);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}while(true);\r\n}\r\n(*delay)=CurrentCmd->msDelay;\r\n(*step)++;\r\nreturn false;\r\n}\r\nstatic void rtl8192_phy_FinishSwChnlNow(struct r8192_priv *priv, u8 channel)\r\n{\r\nu32 delay = 0;\r\nwhile (!rtl8192_phy_SwChnlStepByStep(priv, channel, &priv->SwChnlStage, &priv->SwChnlStep, &delay))\r\n{\r\nif(delay>0)\r\nmsleep(delay);\r\nif(!priv->up)\r\nbreak;\r\n}\r\n}\r\nvoid rtl8192_SwChnl_WorkItem(struct r8192_priv *priv)\r\n{\r\nRT_TRACE(COMP_TRACE, "==> SwChnlCallback819xUsbWorkItem()\n");\r\nRT_TRACE(COMP_TRACE, "=====>--%s(), set chan:%d, priv:%p\n", __FUNCTION__, priv->chan, priv);\r\nrtl8192_phy_FinishSwChnlNow(priv, priv->chan);\r\nRT_TRACE(COMP_TRACE, "<== SwChnlCallback819xUsbWorkItem()\n");\r\n}\r\nu8 rtl8192_phy_SwChnl(struct ieee80211_device *ieee80211, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(ieee80211->dev);\r\nRT_TRACE(COMP_PHY, "=====>%s()\n", __FUNCTION__);\r\nif(!priv->up)\r\nreturn false;\r\nif(priv->SwChnlInProgress)\r\nreturn false;\r\nswitch(priv->ieee80211->mode)\r\n{\r\ncase WIRELESS_MODE_A:\r\ncase WIRELESS_MODE_N_5G:\r\nif (channel<=14){\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14\n");\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_B:\r\nif (channel>14){\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14\n");\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\ncase WIRELESS_MODE_N_24G:\r\nif (channel>14){\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14\n");\r\nreturn false;\r\n}\r\nbreak;\r\n}\r\npriv->SwChnlInProgress = true;\r\nif(channel == 0)\r\nchannel = 1;\r\npriv->chan=channel;\r\npriv->SwChnlStage=0;\r\npriv->SwChnlStep=0;\r\nif (priv->up)\r\nrtl8192_SwChnl_WorkItem(priv);\r\npriv->SwChnlInProgress = false;\r\nreturn true;\r\n}\r\nstatic void CCK_Tx_Power_Track_BW_Switch_TSSI(struct r8192_priv *priv)\r\n{\r\nswitch(priv->CurrentChannelBW)\r\n{\r\ncase HT_CHANNEL_WIDTH_20:\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_20Mdefault + priv->CCKPresentAttentuation_difference;\r\nif(priv->CCKPresentAttentuation > (CCKTxBBGainTableLength-1))\r\npriv->CCKPresentAttentuation = CCKTxBBGainTableLength-1;\r\nif(priv->CCKPresentAttentuation < 0)\r\npriv->CCKPresentAttentuation = 0;\r\nRT_TRACE(COMP_POWER_TRACKING, "20M, priv->CCKPresentAttentuation = %d\n", priv->CCKPresentAttentuation);\r\nif(priv->ieee80211->current_network.channel== 14 && !priv->bcck_in_ch14)\r\n{\r\npriv->bcck_in_ch14 = TRUE;\r\ndm_cck_txpower_adjust(priv, priv->bcck_in_ch14);\r\n}\r\nelse if(priv->ieee80211->current_network.channel != 14 && priv->bcck_in_ch14)\r\n{\r\npriv->bcck_in_ch14 = FALSE;\r\ndm_cck_txpower_adjust(priv, priv->bcck_in_ch14);\r\n}\r\nelse\r\ndm_cck_txpower_adjust(priv, priv->bcck_in_ch14);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_40Mdefault + priv->CCKPresentAttentuation_difference;\r\nRT_TRACE(COMP_POWER_TRACKING, "40M, priv->CCKPresentAttentuation = %d\n", priv->CCKPresentAttentuation);\r\nif(priv->CCKPresentAttentuation > (CCKTxBBGainTableLength-1))\r\npriv->CCKPresentAttentuation = CCKTxBBGainTableLength-1;\r\nif(priv->CCKPresentAttentuation < 0)\r\npriv->CCKPresentAttentuation = 0;\r\nif(priv->ieee80211->current_network.channel == 14 && !priv->bcck_in_ch14)\r\n{\r\npriv->bcck_in_ch14 = TRUE;\r\ndm_cck_txpower_adjust(priv, priv->bcck_in_ch14);\r\n}\r\nelse if(priv->ieee80211->current_network.channel != 14 && priv->bcck_in_ch14)\r\n{\r\npriv->bcck_in_ch14 = FALSE;\r\ndm_cck_txpower_adjust(priv, priv->bcck_in_ch14);\r\n}\r\nelse\r\ndm_cck_txpower_adjust(priv, priv->bcck_in_ch14);\r\nbreak;\r\n}\r\n}\r\nstatic void CCK_Tx_Power_Track_BW_Switch_ThermalMeter(struct r8192_priv *priv)\r\n{\r\nif(priv->ieee80211->current_network.channel == 14 && !priv->bcck_in_ch14)\r\npriv->bcck_in_ch14 = TRUE;\r\nelse if(priv->ieee80211->current_network.channel != 14 && priv->bcck_in_ch14)\r\npriv->bcck_in_ch14 = FALSE;\r\nswitch(priv->CurrentChannelBW)\r\n{\r\ncase HT_CHANNEL_WIDTH_20:\r\nif(priv->Record_CCK_20Mindex == 0)\r\npriv->Record_CCK_20Mindex = 6;\r\npriv->CCK_index = priv->Record_CCK_20Mindex;\r\nRT_TRACE(COMP_POWER_TRACKING, "20MHz, CCK_Tx_Power_Track_BW_Switch_ThermalMeter(),CCK_index = %d\n", priv->CCK_index);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\npriv->CCK_index = priv->Record_CCK_40Mindex;\r\nRT_TRACE(COMP_POWER_TRACKING, "40MHz, CCK_Tx_Power_Track_BW_Switch_ThermalMeter(), CCK_index = %d\n", priv->CCK_index);\r\nbreak;\r\n}\r\ndm_cck_txpower_adjust(priv, priv->bcck_in_ch14);\r\n}\r\nstatic void CCK_Tx_Power_Track_BW_Switch(struct r8192_priv *priv)\r\n{\r\nif(priv->IC_Cut >= IC_VersionCut_D)\r\nCCK_Tx_Power_Track_BW_Switch_TSSI(priv);\r\nelse\r\nCCK_Tx_Power_Track_BW_Switch_ThermalMeter(priv);\r\n}\r\nvoid rtl8192_SetBWModeWorkItem(struct r8192_priv *priv)\r\n{\r\nu8 regBwOpMode;\r\nRT_TRACE(COMP_SWBW, "==>rtl8192_SetBWModeWorkItem() Switch to %s bandwidth\n",\r\npriv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz")\r\nif(!priv->up)\r\n{\r\npriv->SetBWModeInProgress= false;\r\nreturn;\r\n}\r\nregBwOpMode = read_nic_byte(priv, BW_OPMODE);\r\nswitch(priv->CurrentChannelBW)\r\n{\r\ncase HT_CHANNEL_WIDTH_20:\r\nregBwOpMode |= BW_OPMODE_20MHZ;\r\nwrite_nic_byte(priv, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nregBwOpMode &= ~BW_OPMODE_20MHZ;\r\nwrite_nic_byte(priv, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n",priv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch(priv->CurrentChannelBW)\r\n{\r\ncase HT_CHANNEL_WIDTH_20:\r\nrtl8192_setBBreg(priv, rFPGA0_RFMOD, bRFMOD, 0x0);\r\nrtl8192_setBBreg(priv, rFPGA1_RFMOD, bRFMOD, 0x0);\r\nif(!priv->btxpower_tracking)\r\n{\r\nwrite_nic_dword(priv, rCCK0_TxFilter1, 0x1a1b0000);\r\nwrite_nic_dword(priv, rCCK0_TxFilter2, 0x090e1317);\r\nwrite_nic_dword(priv, rCCK0_DebugPort, 0x00000204);\r\n}\r\nelse\r\nCCK_Tx_Power_Track_BW_Switch(priv);\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter1, 0x00100000, 1);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nrtl8192_setBBreg(priv, rFPGA0_RFMOD, bRFMOD, 0x1);\r\nrtl8192_setBBreg(priv, rFPGA1_RFMOD, bRFMOD, 0x1);\r\nif(!priv->btxpower_tracking)\r\n{\r\nwrite_nic_dword(priv, rCCK0_TxFilter1, 0x35360000);\r\nwrite_nic_dword(priv, rCCK0_TxFilter2, 0x121c252e);\r\nwrite_nic_dword(priv, rCCK0_DebugPort, 0x00000409);\r\n}\r\nelse\r\nCCK_Tx_Power_Track_BW_Switch(priv);\r\nrtl8192_setBBreg(priv, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));\r\nrtl8192_setBBreg(priv, rOFDM1_LSTF, 0xC00, priv->nCur40MhzPrimeSC);\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter1, 0x00100000, 0);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n" ,priv->CurrentChannelBW);\r\nbreak;\r\n}\r\nPHY_SetRF8256Bandwidth(priv, priv->CurrentChannelBW);\r\natomic_dec(&(priv->ieee80211->atm_swbw));\r\npriv->SetBWModeInProgress= false;\r\nRT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb()\n");\r\n}\r\nvoid rtl8192_SetBWMode(struct ieee80211_device *ieee, HT_CHANNEL_WIDTH Bandwidth, HT_EXTCHNL_OFFSET Offset)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(ieee->dev);\r\nif(priv->SetBWModeInProgress)\r\nreturn;\r\natomic_inc(&(priv->ieee80211->atm_swbw));\r\npriv->SetBWModeInProgress= true;\r\npriv->CurrentChannelBW = Bandwidth;\r\nif(Offset==HT_EXTCHNL_OFFSET_LOWER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nelse if(Offset==HT_EXTCHNL_OFFSET_UPPER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nelse\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nrtl8192_SetBWModeWorkItem(priv);\r\n}\r\nvoid InitialGain819xPci(struct ieee80211_device *ieee, u8 Operation)\r\n{\r\n#define SCAN_RX_INITIAL_GAIN 0x17\r\n#define POWER_DETECTION_TH 0x08\r\nstruct r8192_priv *priv = ieee80211_priv(ieee->dev);\r\nu32 BitMask;\r\nu8 initial_gain;\r\nif(priv->up)\r\n{\r\nswitch(Operation)\r\n{\r\ncase IG_Backup:\r\nRT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");\r\ninitial_gain = SCAN_RX_INITIAL_GAIN;\r\nBitMask = bMaskByte0;\r\nif(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(priv, UFWP, bMaskByte1, 0x8);\r\npriv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(priv, rOFDM0_XAAGCCore1, BitMask);\r\npriv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(priv, rOFDM0_XBAGCCore1, BitMask);\r\npriv->initgain_backup.xcagccore1 = (u8)rtl8192_QueryBBReg(priv, rOFDM0_XCAGCCore1, BitMask);\r\npriv->initgain_backup.xdagccore1 = (u8)rtl8192_QueryBBReg(priv, rOFDM0_XDAGCCore1, BitMask);\r\nBitMask = bMaskByte2;\r\npriv->initgain_backup.cca = (u8)rtl8192_QueryBBReg(priv, rCCK0_CCA, BitMask);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n",priv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n",priv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is %x\n",priv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is %x\n",priv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n",priv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x \n", initial_gain);\r\nwrite_nic_byte(priv, rOFDM0_XAAGCCore1, initial_gain);\r\nwrite_nic_byte(priv, rOFDM0_XBAGCCore1, initial_gain);\r\nwrite_nic_byte(priv, rOFDM0_XCAGCCore1, initial_gain);\r\nwrite_nic_byte(priv, rOFDM0_XDAGCCore1, initial_gain);\r\nRT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x \n", POWER_DETECTION_TH);\r\nwrite_nic_byte(priv, 0xa0a, POWER_DETECTION_TH);\r\nbreak;\r\ncase IG_Restore:\r\nRT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");\r\nBitMask = 0x7f;\r\nif(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(priv, UFWP, bMaskByte1, 0x8);\r\nrtl8192_setBBreg(priv, rOFDM0_XAAGCCore1, BitMask, (u32)priv->initgain_backup.xaagccore1);\r\nrtl8192_setBBreg(priv, rOFDM0_XBAGCCore1, BitMask, (u32)priv->initgain_backup.xbagccore1);\r\nrtl8192_setBBreg(priv, rOFDM0_XCAGCCore1, BitMask, (u32)priv->initgain_backup.xcagccore1);\r\nrtl8192_setBBreg(priv, rOFDM0_XDAGCCore1, BitMask, (u32)priv->initgain_backup.xdagccore1);\r\nBitMask = bMaskByte2;\r\nrtl8192_setBBreg(priv, rCCK0_CCA, BitMask, (u32)priv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n",priv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n",priv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60 is %x\n",priv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68 is %x\n",priv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n",priv->initgain_backup.cca);\r\nrtl8192_phy_setTxPower(priv, priv->ieee80211->current_network.channel);\r\nif(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(priv, UFWP, bMaskByte1, 0x1);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_SCAN, "Unknown IG Operation.\n");\r\nbreak;\r\n}\r\n}\r\n}
