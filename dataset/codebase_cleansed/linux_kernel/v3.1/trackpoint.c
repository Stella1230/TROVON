static int trackpoint_read(struct ps2dev *ps2dev, unsigned char loc, unsigned char *results)\r\n{\r\nif (ps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_COMMAND)) ||\r\nps2_command(ps2dev, results, MAKE_PS2_CMD(0, 1, loc))) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trackpoint_write(struct ps2dev *ps2dev, unsigned char loc, unsigned char val)\r\n{\r\nif (ps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_COMMAND)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_WRITE_MEM)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, loc)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, val))) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trackpoint_toggle_bit(struct ps2dev *ps2dev, unsigned char loc, unsigned char mask)\r\n{\r\nif (loc < 0x20 || loc >= 0x2F)\r\nreturn -1;\r\nif (ps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_COMMAND)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_TOGGLE)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, loc)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, mask))) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t trackpoint_show_int_attr(struct psmouse *psmouse, void *data, char *buf)\r\n{\r\nstruct trackpoint_data *tp = psmouse->private;\r\nstruct trackpoint_attr_data *attr = data;\r\nunsigned char value = *(unsigned char *)((char *)tp + attr->field_offset);\r\nif (attr->inverted)\r\nvalue = !value;\r\nreturn sprintf(buf, "%u\n", value);\r\n}\r\nstatic ssize_t trackpoint_set_int_attr(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct trackpoint_data *tp = psmouse->private;\r\nstruct trackpoint_attr_data *attr = data;\r\nunsigned char *field = (unsigned char *)((char *)tp + attr->field_offset);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 10, &value) || value > 255)\r\nreturn -EINVAL;\r\n*field = value;\r\ntrackpoint_write(&psmouse->ps2dev, attr->command, value);\r\nreturn count;\r\n}\r\nstatic ssize_t trackpoint_set_bit_attr(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct trackpoint_data *tp = psmouse->private;\r\nstruct trackpoint_attr_data *attr = data;\r\nunsigned char *field = (unsigned char *)((char *)tp + attr->field_offset);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 10, &value) || value > 1)\r\nreturn -EINVAL;\r\nif (attr->inverted)\r\nvalue = !value;\r\nif (*field != value) {\r\n*field = value;\r\ntrackpoint_toggle_bit(&psmouse->ps2dev, attr->command, attr->mask);\r\n}\r\nreturn count;\r\n}\r\nstatic int trackpoint_start_protocol(struct psmouse *psmouse, unsigned char *firmware_id)\r\n{\r\nunsigned char param[2] = { 0 };\r\nif (ps2_command(&psmouse->ps2dev, param, MAKE_PS2_CMD(0, 2, TP_READ_ID)))\r\nreturn -1;\r\nif (param[0] != TP_MAGIC_IDENT)\r\nreturn -1;\r\nif (firmware_id)\r\n*firmware_id = param[1];\r\nreturn 0;\r\n}\r\nstatic int trackpoint_sync(struct psmouse *psmouse)\r\n{\r\nstruct trackpoint_data *tp = psmouse->private;\r\nunsigned char toggle;\r\ntrackpoint_read(&psmouse->ps2dev, TP_TOGGLE_TWOHAND, &toggle);\r\nif (toggle & TP_MASK_TWOHAND)\r\ntrackpoint_toggle_bit(&psmouse->ps2dev, TP_TOGGLE_TWOHAND, TP_MASK_TWOHAND);\r\ntrackpoint_read(&psmouse->ps2dev, TP_TOGGLE_SOURCE_TAG, &toggle);\r\nif (toggle & TP_MASK_SOURCE_TAG)\r\ntrackpoint_toggle_bit(&psmouse->ps2dev, TP_TOGGLE_SOURCE_TAG, TP_MASK_SOURCE_TAG);\r\ntrackpoint_read(&psmouse->ps2dev, TP_TOGGLE_MB, &toggle);\r\nif (toggle & TP_MASK_MB)\r\ntrackpoint_toggle_bit(&psmouse->ps2dev, TP_TOGGLE_MB, TP_MASK_MB);\r\ntrackpoint_write(&psmouse->ps2dev, TP_SENS, tp->sensitivity);\r\ntrackpoint_write(&psmouse->ps2dev, TP_INERTIA, tp->inertia);\r\ntrackpoint_write(&psmouse->ps2dev, TP_SPEED, tp->speed);\r\ntrackpoint_write(&psmouse->ps2dev, TP_REACH, tp->reach);\r\ntrackpoint_write(&psmouse->ps2dev, TP_DRAGHYS, tp->draghys);\r\ntrackpoint_write(&psmouse->ps2dev, TP_MINDRAG, tp->mindrag);\r\ntrackpoint_write(&psmouse->ps2dev, TP_THRESH, tp->thresh);\r\ntrackpoint_write(&psmouse->ps2dev, TP_UP_THRESH, tp->upthresh);\r\ntrackpoint_write(&psmouse->ps2dev, TP_Z_TIME, tp->ztime);\r\ntrackpoint_write(&psmouse->ps2dev, TP_JENKS_CURV, tp->jenks);\r\ntrackpoint_read(&psmouse->ps2dev, TP_TOGGLE_PTSON, &toggle);\r\nif (((toggle & TP_MASK_PTSON) == TP_MASK_PTSON) != tp->press_to_select)\r\ntrackpoint_toggle_bit(&psmouse->ps2dev, TP_TOGGLE_PTSON, TP_MASK_PTSON);\r\ntrackpoint_read(&psmouse->ps2dev, TP_TOGGLE_SKIPBACK, &toggle);\r\nif (((toggle & TP_MASK_SKIPBACK) == TP_MASK_SKIPBACK) != tp->skipback)\r\ntrackpoint_toggle_bit(&psmouse->ps2dev, TP_TOGGLE_SKIPBACK, TP_MASK_SKIPBACK);\r\ntrackpoint_read(&psmouse->ps2dev, TP_TOGGLE_EXT_DEV, &toggle);\r\nif (((toggle & TP_MASK_EXT_DEV) == TP_MASK_EXT_DEV) != tp->ext_dev)\r\ntrackpoint_toggle_bit(&psmouse->ps2dev, TP_TOGGLE_EXT_DEV, TP_MASK_EXT_DEV);\r\nreturn 0;\r\n}\r\nstatic void trackpoint_defaults(struct trackpoint_data *tp)\r\n{\r\ntp->press_to_select = TP_DEF_PTSON;\r\ntp->sensitivity = TP_DEF_SENS;\r\ntp->speed = TP_DEF_SPEED;\r\ntp->reach = TP_DEF_REACH;\r\ntp->draghys = TP_DEF_DRAGHYS;\r\ntp->mindrag = TP_DEF_MINDRAG;\r\ntp->thresh = TP_DEF_THRESH;\r\ntp->upthresh = TP_DEF_UP_THRESH;\r\ntp->ztime = TP_DEF_Z_TIME;\r\ntp->jenks = TP_DEF_JENKS_CURV;\r\ntp->inertia = TP_DEF_INERTIA;\r\ntp->skipback = TP_DEF_SKIPBACK;\r\ntp->ext_dev = TP_DEF_EXT_DEV;\r\n}\r\nstatic void trackpoint_disconnect(struct psmouse *psmouse)\r\n{\r\nsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj, &trackpoint_attr_group);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\n}\r\nstatic int trackpoint_reconnect(struct psmouse *psmouse)\r\n{\r\nif (trackpoint_start_protocol(psmouse, NULL))\r\nreturn -1;\r\nif (trackpoint_sync(psmouse))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint trackpoint_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char firmware_id;\r\nunsigned char button_info;\r\nint error;\r\nif (trackpoint_start_protocol(psmouse, &firmware_id))\r\nreturn -1;\r\nif (!set_properties)\r\nreturn 0;\r\nif (trackpoint_read(&psmouse->ps2dev, TP_EXT_BTN, &button_info)) {\r\nprintk(KERN_WARNING "trackpoint.c: failed to get extended button data\n");\r\nbutton_info = 0;\r\n}\r\npsmouse->private = kzalloc(sizeof(struct trackpoint_data), GFP_KERNEL);\r\nif (!psmouse->private)\r\nreturn -ENOMEM;\r\npsmouse->vendor = "IBM";\r\npsmouse->name = "TrackPoint";\r\npsmouse->reconnect = trackpoint_reconnect;\r\npsmouse->disconnect = trackpoint_disconnect;\r\nif ((button_info & 0x0f) >= 3)\r\n__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\r\ntrackpoint_defaults(psmouse->private);\r\ntrackpoint_sync(psmouse);\r\nerror = sysfs_create_group(&ps2dev->serio->dev.kobj, &trackpoint_attr_group);\r\nif (error) {\r\nprintk(KERN_ERR\r\n"trackpoint.c: failed to create sysfs attributes, error: %d\n",\r\nerror);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "IBM TrackPoint firmware: 0x%02x, buttons: %d/%d\n",\r\nfirmware_id, (button_info & 0xf0) >> 4, button_info & 0x0f);\r\nreturn 0;\r\n}
