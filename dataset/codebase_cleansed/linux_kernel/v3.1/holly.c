int holly_exclude_device(struct pci_controller *hose, u_char bus, u_char devfn)\r\n{\r\nif (bus == 0 && PCI_SLOT(devfn) == 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nelse\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void holly_remap_bridge(void)\r\n{\r\nu32 lut_val, lut_addr;\r\nint i;\r\nprintk(KERN_INFO "Remapping PCI bridge\n");\r\nlut_addr = 0x900;\r\nfor (i = 0; i < 31; i++) {\r\ntsi108_write_reg(TSI108_PB_OFFSET + lut_addr, 0x00000201);\r\nlut_addr += 4;\r\ntsi108_write_reg(TSI108_PB_OFFSET + lut_addr, 0x0);\r\nlut_addr += 4;\r\n}\r\ntsi108_write_reg(TSI108_PB_OFFSET + lut_addr, 0x00000241);\r\nlut_addr += 4;\r\ntsi108_write_reg(TSI108_PB_OFFSET + lut_addr, 0x0);\r\ntsi108_write_reg(TSI108_PCI_PFAB_IO_UPPER, 0x0);\r\ntsi108_write_reg(TSI108_PCI_PFAB_IO, 0x1);\r\ntsi108_write_reg(TSI108_PCI_PFAB_BAR0_UPPER, 0x0);\r\ntsi108_write_reg(TSI108_PCI_PFAB_BAR0, 0x7c000000 | 0x01);\r\ntsi108_write_reg(TSI108_PCI_PFAB_MEM32, 0x0);\r\ntsi108_write_reg(TSI108_PCI_PFAB_PFM3, 0x0);\r\ntsi108_write_reg(TSI108_PCI_PFAB_PFM4, 0x0);\r\ntsi108_write_reg(TSI108_PCI_P2O_BAR0_UPPER, 0x0);\r\ntsi108_write_reg(TSI108_PCI_P2O_BAR0, 0xc0000000);\r\nlut_addr = 0x500;\r\nlut_val = 0x00000002;\r\nfor (i = 0; i < 32; i++) {\r\ntsi108_write_reg(TSI108_PCI_OFFSET + lut_addr, lut_val);\r\nlut_addr += 4;\r\ntsi108_write_reg(TSI108_PCI_OFFSET + lut_addr, 0x40000000);\r\nlut_addr += 4;\r\nlut_val += 0x02000000;\r\n}\r\ntsi108_write_reg(TSI108_PCI_P2O_PAGE_SIZES, 0x00007900);\r\ntsi108_write_reg(TSI108_PCI_P2O_BAR2_UPPER, 0x0);\r\ntsi108_write_reg(TSI108_PCI_P2O_BAR2, 0x0);\r\n}\r\nstatic void __init holly_setup_arch(void)\r\n{\r\nstruct device_node *np;\r\nif (ppc_md.progress)\r\nppc_md.progress("holly_setup_arch():set_bridge", 0);\r\ntsi108_csr_vir_base = get_vir_csrbase();\r\nholly_remap_bridge();\r\nnp = of_find_node_by_type(NULL, "pci");\r\nif (np)\r\ntsi108_setup_pci(np, HOLLY_PCI_CFG_PHYS, 1);\r\nppc_md.pci_exclude_device = holly_exclude_device;\r\nif (ppc_md.progress)\r\nppc_md.progress("tsi108: resources set", 0x100);\r\nprintk(KERN_INFO "PPC750GX/CL Platform\n");\r\n}\r\nstatic void __init holly_init_IRQ(void)\r\n{\r\nstruct mpic *mpic;\r\nphys_addr_t mpic_paddr = 0;\r\nstruct device_node *tsi_pic;\r\n#ifdef CONFIG_PCI\r\nunsigned int cascade_pci_irq;\r\nstruct device_node *tsi_pci;\r\nstruct device_node *cascade_node = NULL;\r\n#endif\r\ntsi_pic = of_find_node_by_type(NULL, "open-pic");\r\nif (tsi_pic) {\r\nunsigned int size;\r\nconst void *prop = of_get_property(tsi_pic, "reg", &size);\r\nmpic_paddr = of_translate_address(tsi_pic, prop);\r\n}\r\nif (mpic_paddr == 0) {\r\nprintk(KERN_ERR "%s: No tsi108 PIC found !\n", __func__);\r\nreturn;\r\n}\r\npr_debug("%s: tsi108 pic phys_addr = 0x%x\n", __func__, (u32) mpic_paddr);\r\nmpic = mpic_alloc(tsi_pic, mpic_paddr,\r\nMPIC_PRIMARY | MPIC_BIG_ENDIAN | MPIC_WANTS_RESET |\r\nMPIC_SPV_EOI | MPIC_NO_PTHROU_DIS | MPIC_REGSET_TSI108,\r\n24,\r\nNR_IRQS-4,\r\n"Tsi108_PIC");\r\nBUG_ON(mpic == NULL);\r\nmpic_assign_isu(mpic, 0, mpic_paddr + 0x100);\r\nmpic_init(mpic);\r\n#ifdef CONFIG_PCI\r\ntsi_pci = of_find_node_by_type(NULL, "pci");\r\nif (tsi_pci == NULL) {\r\nprintk(KERN_ERR "%s: No tsi108 pci node found !\n", __func__);\r\nreturn;\r\n}\r\ncascade_node = of_find_node_by_type(NULL, "pic-router");\r\nif (cascade_node == NULL) {\r\nprintk(KERN_ERR "%s: No tsi108 pci cascade node found !\n", __func__);\r\nreturn;\r\n}\r\ncascade_pci_irq = irq_of_parse_and_map(tsi_pci, 0);\r\npr_debug("%s: tsi108 cascade_pci_irq = 0x%x\n", __func__, (u32) cascade_pci_irq);\r\ntsi108_pci_int_init(cascade_node);\r\nirq_set_handler_data(cascade_pci_irq, mpic);\r\nirq_set_chained_handler(cascade_pci_irq, tsi108_irq_cascade);\r\n#endif\r\ntsi108_write_reg(TSI108_MPIC_OFFSET + 0x30c, 0);\r\nof_node_put(tsi_pic);\r\n}\r\nvoid holly_show_cpuinfo(struct seq_file *m)\r\n{\r\nseq_printf(m, "vendor\t\t: IBM\n");\r\nseq_printf(m, "machine\t\t: PPC750 GX/CL\n");\r\n}\r\nvoid holly_restart(char *cmd)\r\n{\r\n__be32 __iomem *ocn_bar1 = NULL;\r\nunsigned long bar;\r\nstruct device_node *bridge = NULL;\r\nconst void *prop;\r\nint size;\r\nphys_addr_t addr = 0xc0000000;\r\nlocal_irq_disable();\r\nbridge = of_find_node_by_type(NULL, "tsi-bridge");\r\nif (bridge) {\r\nprop = of_get_property(bridge, "reg", &size);\r\naddr = of_translate_address(bridge, prop);\r\n}\r\naddr += (TSI108_PB_OFFSET + 0x414);\r\nocn_bar1 = ioremap(addr, 0x4);\r\nbar = ioread32be(ocn_bar1);\r\nbar |= 2;\r\niowrite32be(bar, ocn_bar1);\r\niosync();\r\nmtspr(SPRN_SRR0, 0xfff00100);\r\nmtspr(SPRN_SRR1, MSR_IP);\r\n__asm__ __volatile__("rfi" : : : "memory");\r\nfor (;;) ;\r\n}\r\nvoid holly_power_off(void)\r\n{\r\nlocal_irq_disable();\r\nfor (;;) ;\r\n}\r\nvoid holly_halt(void)\r\n{\r\nholly_power_off();\r\n}\r\nstatic int __init holly_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (!of_flat_dt_is_compatible(root, "ibm,holly"))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ppc750_machine_check_exception(struct pt_regs *regs)\r\n{\r\nconst struct exception_table_entry *entry;\r\nif ((entry = search_exception_tables(regs->nip)) != NULL) {\r\ntsi108_clear_pci_cfg_error();\r\nregs->msr |= MSR_RI;\r\nregs->nip = entry->fixup;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
