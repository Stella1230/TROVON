static int sn_hwperf_enum_objects(int *nobj, struct sn_hwperf_object_info **ret)\r\n{\r\nint e;\r\nu64 sz;\r\nstruct sn_hwperf_object_info *objbuf = NULL;\r\nif ((e = sn_hwperf_init()) < 0) {\r\nprintk(KERN_ERR "sn_hwperf_init failed: err %d\n", e);\r\ngoto out;\r\n}\r\nsz = sn_hwperf_obj_cnt * sizeof(struct sn_hwperf_object_info);\r\nobjbuf = vmalloc(sz);\r\nif (objbuf == NULL) {\r\nprintk("sn_hwperf_enum_objects: vmalloc(%d) failed\n", (int)sz);\r\ne = -ENOMEM;\r\ngoto out;\r\n}\r\ne = ia64_sn_hwperf_op(sn_hwperf_master_nasid, SN_HWPERF_ENUM_OBJECTS,\r\n0, sz, (u64) objbuf, 0, 0, NULL);\r\nif (e != SN_HWPERF_OP_OK) {\r\ne = -EINVAL;\r\nvfree(objbuf);\r\n}\r\nout:\r\n*nobj = sn_hwperf_obj_cnt;\r\n*ret = objbuf;\r\nreturn e;\r\n}\r\nstatic int sn_hwperf_location_to_bpos(char *location,\r\nint *rack, int *bay, int *slot, int *slab)\r\n{\r\nchar type;\r\nif (sscanf(location, "%03d%c%02d#%d",\r\nrack, &type, bay, slab) == 4)\r\n*slot = 0;\r\nelse\r\nif (sscanf(location, "%03d%c%02d^%02d#%d",\r\nrack, &type, bay, slot, slab) != 5)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int sn_hwperf_geoid_to_cnode(char *location)\r\n{\r\nint cnode;\r\ngeoid_t geoid;\r\nmoduleid_t module_id;\r\nint rack, bay, slot, slab;\r\nint this_rack, this_bay, this_slot, this_slab;\r\nif (sn_hwperf_location_to_bpos(location, &rack, &bay, &slot, &slab))\r\nreturn -1;\r\nfor (cnode = 0; cnode < num_cnodes; cnode++) {\r\ngeoid = cnodeid_get_geoid(cnode);\r\nmodule_id = geo_module(geoid);\r\nthis_rack = MODULE_GET_RACK(module_id);\r\nthis_bay = MODULE_GET_BPOS(module_id);\r\nthis_slot = geo_slot(geoid);\r\nthis_slab = geo_slab(geoid);\r\nif (rack == this_rack && bay == this_bay &&\r\nslot == this_slot && slab == this_slab) {\r\nbreak;\r\n}\r\n}\r\nreturn cnode_possible(cnode) ? cnode : -1;\r\n}\r\nstatic int sn_hwperf_obj_to_cnode(struct sn_hwperf_object_info * obj)\r\n{\r\nif (!SN_HWPERF_IS_NODE(obj) && !SN_HWPERF_IS_IONODE(obj))\r\nBUG();\r\nif (SN_HWPERF_FOREIGN(obj))\r\nreturn -1;\r\nreturn sn_hwperf_geoid_to_cnode(obj->location);\r\n}\r\nstatic int sn_hwperf_generic_ordinal(struct sn_hwperf_object_info *obj,\r\nstruct sn_hwperf_object_info *objs)\r\n{\r\nint ordinal;\r\nstruct sn_hwperf_object_info *p;\r\nfor (ordinal=0, p=objs; p != obj; p++) {\r\nif (SN_HWPERF_FOREIGN(p))\r\ncontinue;\r\nif (SN_HWPERF_SAME_OBJTYPE(p, obj))\r\nordinal++;\r\n}\r\nreturn ordinal;\r\n}\r\nstatic const char *sn_hwperf_get_slabname(struct sn_hwperf_object_info *obj,\r\nstruct sn_hwperf_object_info *objs, int *ordinal)\r\n{\r\nint isnode;\r\nconst char *slabname = slabname_other;\r\nif ((isnode = SN_HWPERF_IS_NODE(obj)) || SN_HWPERF_IS_IONODE(obj)) {\r\nslabname = isnode ? slabname_node : slabname_ionode;\r\n*ordinal = sn_hwperf_obj_to_cnode(obj);\r\n}\r\nelse {\r\n*ordinal = sn_hwperf_generic_ordinal(obj, objs);\r\nif (SN_HWPERF_IS_ROUTER(obj))\r\nslabname = slabname_router;\r\n}\r\nreturn slabname;\r\n}\r\nstatic void print_pci_topology(struct seq_file *s)\r\n{\r\nchar *p;\r\nsize_t sz;\r\nint e;\r\nfor (sz = PAGE_SIZE; sz < 16 * PAGE_SIZE; sz += PAGE_SIZE) {\r\nif (!(p = kmalloc(sz, GFP_KERNEL)))\r\nbreak;\r\ne = ia64_sn_ioif_get_pci_topology(__pa(p), sz);\r\nif (e == SALRET_OK)\r\nseq_puts(s, p);\r\nkfree(p);\r\nif (e == SALRET_OK || e == SALRET_NOT_IMPLEMENTED)\r\nbreak;\r\n}\r\n}\r\nstatic inline int sn_hwperf_has_cpus(cnodeid_t node)\r\n{\r\nreturn node < MAX_NUMNODES && node_online(node) && nr_cpus_node(node);\r\n}\r\nstatic inline int sn_hwperf_has_mem(cnodeid_t node)\r\n{\r\nreturn node < MAX_NUMNODES && node_online(node) && NODE_DATA(node)->node_present_pages;\r\n}\r\nstatic struct sn_hwperf_object_info *\r\nsn_hwperf_findobj_id(struct sn_hwperf_object_info *objbuf,\r\nint nobj, int id)\r\n{\r\nint i;\r\nstruct sn_hwperf_object_info *p = objbuf;\r\nfor (i=0; i < nobj; i++, p++) {\r\nif (p->id == id)\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sn_hwperf_get_nearest_node_objdata(struct sn_hwperf_object_info *objbuf,\r\nint nobj, cnodeid_t node, cnodeid_t *near_mem_node, cnodeid_t *near_cpu_node)\r\n{\r\nint e;\r\nstruct sn_hwperf_object_info *nodeobj = NULL;\r\nstruct sn_hwperf_object_info *op;\r\nstruct sn_hwperf_object_info *dest;\r\nstruct sn_hwperf_object_info *router;\r\nstruct sn_hwperf_port_info ptdata[16];\r\nint sz, i, j;\r\ncnodeid_t c;\r\nint found_mem = 0;\r\nint found_cpu = 0;\r\nif (!cnode_possible(node))\r\nreturn -EINVAL;\r\nif (sn_hwperf_has_cpus(node)) {\r\nif (near_cpu_node)\r\n*near_cpu_node = node;\r\nfound_cpu++;\r\n}\r\nif (sn_hwperf_has_mem(node)) {\r\nif (near_mem_node)\r\n*near_mem_node = node;\r\nfound_mem++;\r\n}\r\nif (found_cpu && found_mem)\r\nreturn 0;\r\nfor (i=0, op=objbuf; i < nobj; i++, op++) {\r\nif (!SN_HWPERF_IS_NODE(op) && !SN_HWPERF_IS_IONODE(op))\r\ncontinue;\r\nif (node == sn_hwperf_obj_to_cnode(op)) {\r\nnodeobj = op;\r\nbreak;\r\n}\r\n}\r\nif (!nodeobj) {\r\ne = -ENOENT;\r\ngoto err;\r\n}\r\nsz = op->ports * sizeof(struct sn_hwperf_port_info);\r\nBUG_ON(sz > sizeof(ptdata));\r\ne = ia64_sn_hwperf_op(sn_hwperf_master_nasid,\r\nSN_HWPERF_ENUM_PORTS, nodeobj->id, sz,\r\n(u64)&ptdata, 0, 0, NULL);\r\nif (e != SN_HWPERF_OP_OK) {\r\ne = -EINVAL;\r\ngoto err;\r\n}\r\nfor (router=NULL, j=0; j < op->ports; j++) {\r\ndest = sn_hwperf_findobj_id(objbuf, nobj, ptdata[j].conn_id);\r\nif (dest && SN_HWPERF_IS_ROUTER(dest))\r\nrouter = dest;\r\nif (!dest || SN_HWPERF_FOREIGN(dest) ||\r\n!SN_HWPERF_IS_NODE(dest) || SN_HWPERF_IS_IONODE(dest)) {\r\ncontinue;\r\n}\r\nc = sn_hwperf_obj_to_cnode(dest);\r\nif (!found_cpu && sn_hwperf_has_cpus(c)) {\r\nif (near_cpu_node)\r\n*near_cpu_node = c;\r\nfound_cpu++;\r\n}\r\nif (!found_mem && sn_hwperf_has_mem(c)) {\r\nif (near_mem_node)\r\n*near_mem_node = c;\r\nfound_mem++;\r\n}\r\n}\r\nif (router && (!found_cpu || !found_mem)) {\r\nsz = router->ports * sizeof(struct sn_hwperf_port_info);\r\nBUG_ON(sz > sizeof(ptdata));\r\ne = ia64_sn_hwperf_op(sn_hwperf_master_nasid,\r\nSN_HWPERF_ENUM_PORTS, router->id, sz,\r\n(u64)&ptdata, 0, 0, NULL);\r\nif (e != SN_HWPERF_OP_OK) {\r\ne = -EINVAL;\r\ngoto err;\r\n}\r\nfor (j=0; j < router->ports; j++) {\r\ndest = sn_hwperf_findobj_id(objbuf, nobj,\r\nptdata[j].conn_id);\r\nif (!dest || dest->id == node ||\r\nSN_HWPERF_FOREIGN(dest) ||\r\n!SN_HWPERF_IS_NODE(dest) ||\r\nSN_HWPERF_IS_IONODE(dest)) {\r\ncontinue;\r\n}\r\nc = sn_hwperf_obj_to_cnode(dest);\r\nif (!found_cpu && sn_hwperf_has_cpus(c)) {\r\nif (near_cpu_node)\r\n*near_cpu_node = c;\r\nfound_cpu++;\r\n}\r\nif (!found_mem && sn_hwperf_has_mem(c)) {\r\nif (near_mem_node)\r\n*near_mem_node = c;\r\nfound_mem++;\r\n}\r\nif (found_cpu && found_mem)\r\nbreak;\r\n}\r\n}\r\nif (!found_cpu || !found_mem) {\r\nfor (i=0, op=objbuf; i < nobj; i++, op++) {\r\nif (SN_HWPERF_FOREIGN(op) ||\r\nSN_HWPERF_IS_IONODE(op) ||\r\n!SN_HWPERF_IS_NODE(op)) {\r\ncontinue;\r\n}\r\nc = sn_hwperf_obj_to_cnode(op);\r\nif (!found_cpu && sn_hwperf_has_cpus(c)) {\r\nif (near_cpu_node)\r\n*near_cpu_node = c;\r\nfound_cpu++;\r\n}\r\nif (!found_mem && sn_hwperf_has_mem(c)) {\r\nif (near_mem_node)\r\n*near_mem_node = c;\r\nfound_mem++;\r\n}\r\nif (found_cpu && found_mem)\r\nbreak;\r\n}\r\n}\r\nif (!found_cpu || !found_mem)\r\ne = -ENODATA;\r\nerr:\r\nreturn e;\r\n}\r\nstatic int sn_topology_show(struct seq_file *s, void *d)\r\n{\r\nint sz;\r\nint pt;\r\nint e = 0;\r\nint i;\r\nint j;\r\nconst char *slabname;\r\nint ordinal;\r\nchar slice;\r\nstruct cpuinfo_ia64 *c;\r\nstruct sn_hwperf_port_info *ptdata;\r\nstruct sn_hwperf_object_info *p;\r\nstruct sn_hwperf_object_info *obj = d;\r\nstruct sn_hwperf_object_info *objs = s->private;\r\nu8 shubtype;\r\nu8 system_size;\r\nu8 sharing_size;\r\nu8 partid;\r\nu8 coher;\r\nu8 nasid_shift;\r\nu8 region_size;\r\nu16 nasid_mask;\r\nint nasid_msb;\r\nif (obj == objs) {\r\nseq_printf(s, "# sn_topology version 2\n");\r\nseq_printf(s, "# objtype ordinal location partition"\r\n" [attribute value [, ...]]\n");\r\nif (ia64_sn_get_sn_info(0,\r\n&shubtype, &nasid_mask, &nasid_shift, &system_size,\r\n&sharing_size, &partid, &coher, &region_size))\r\nBUG();\r\nfor (nasid_msb=63; nasid_msb > 0; nasid_msb--) {\r\nif (((u64)nasid_mask << nasid_shift) & (1ULL << nasid_msb))\r\nbreak;\r\n}\r\nseq_printf(s, "partition %u %s local "\r\n"shubtype %s, "\r\n"nasid_mask 0x%016llx, "\r\n"nasid_bits %d:%d, "\r\n"system_size %d, "\r\n"sharing_size %d, "\r\n"coherency_domain %d, "\r\n"region_size %d\n",\r\npartid, utsname()->nodename,\r\nshubtype ? "shub2" : "shub1",\r\n(u64)nasid_mask << nasid_shift, nasid_msb, nasid_shift,\r\nsystem_size, sharing_size, coher, region_size);\r\nprint_pci_topology(s);\r\n}\r\nif (SN_HWPERF_FOREIGN(obj)) {\r\nreturn 0;\r\n}\r\nfor (i = 0; i < SN_HWPERF_MAXSTRING && obj->name[i]; i++) {\r\nif (obj->name[i] == ' ')\r\nobj->name[i] = '_';\r\n}\r\nslabname = sn_hwperf_get_slabname(obj, objs, &ordinal);\r\nseq_printf(s, "%s %d %s %s asic %s", slabname, ordinal, obj->location,\r\nobj->sn_hwp_this_part ? "local" : "shared", obj->name);\r\nif (ordinal < 0 || (!SN_HWPERF_IS_NODE(obj) && !SN_HWPERF_IS_IONODE(obj)))\r\nseq_putc(s, '\n');\r\nelse {\r\ncnodeid_t near_mem = -1;\r\ncnodeid_t near_cpu = -1;\r\nseq_printf(s, ", nasid 0x%x", cnodeid_to_nasid(ordinal));\r\nif (sn_hwperf_get_nearest_node_objdata(objs, sn_hwperf_obj_cnt,\r\nordinal, &near_mem, &near_cpu) == 0) {\r\nseq_printf(s, ", near_mem_nodeid %d, near_cpu_nodeid %d",\r\nnear_mem, near_cpu);\r\n}\r\nif (!SN_HWPERF_IS_IONODE(obj)) {\r\nfor_each_online_node(i) {\r\nseq_printf(s, i ? ":%d" : ", dist %d",\r\nnode_distance(ordinal, i));\r\n}\r\n}\r\nseq_putc(s, '\n');\r\nif (!SN_HWPERF_IS_IONODE(obj)) {\r\nfor_each_cpu_and(i, cpu_online_mask,\r\ncpumask_of_node(ordinal)) {\r\nslice = 'a' + cpuid_to_slice(i);\r\nc = cpu_data(i);\r\nseq_printf(s, "cpu %d %s%c local"\r\n" freq %luMHz, arch ia64",\r\ni, obj->location, slice,\r\nc->proc_freq / 1000000);\r\nfor_each_online_cpu(j) {\r\nseq_printf(s, j ? ":%d" : ", dist %d",\r\nnode_distance(\r\ncpu_to_node(i),\r\ncpu_to_node(j)));\r\n}\r\nseq_putc(s, '\n');\r\n}\r\n}\r\n}\r\nif (obj->ports) {\r\nsz = obj->ports * sizeof(struct sn_hwperf_port_info);\r\nif ((ptdata = kmalloc(sz, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ne = ia64_sn_hwperf_op(sn_hwperf_master_nasid,\r\nSN_HWPERF_ENUM_PORTS, obj->id, sz,\r\n(u64) ptdata, 0, 0, NULL);\r\nif (e != SN_HWPERF_OP_OK)\r\nreturn -EINVAL;\r\nfor (ordinal=0, p=objs; p != obj; p++) {\r\nif (!SN_HWPERF_FOREIGN(p))\r\nordinal += p->ports;\r\n}\r\nfor (pt = 0; pt < obj->ports; pt++) {\r\nfor (p = objs, i = 0; i < sn_hwperf_obj_cnt; i++, p++) {\r\nif (ptdata[pt].conn_id == p->id) {\r\nbreak;\r\n}\r\n}\r\nseq_printf(s, "numalink %d %s-%d",\r\nordinal+pt, obj->location, ptdata[pt].port);\r\nif (i >= sn_hwperf_obj_cnt) {\r\nseq_puts(s, " local endpoint disconnected"\r\n", protocol unknown\n");\r\ncontinue;\r\n}\r\nif (obj->sn_hwp_this_part && p->sn_hwp_this_part)\r\nseq_puts(s, " local");\r\nelse if (SN_HWPERF_FOREIGN(p))\r\nseq_puts(s, " foreign");\r\nelse\r\nseq_puts(s, " shared");\r\nseq_printf(s, " endpoint %s-%d, protocol %s\n",\r\np->location, ptdata[pt].conn_port,\r\n(SN_HWPERF_IS_NL3ROUTER(obj) ||\r\nSN_HWPERF_IS_NL3ROUTER(p)) ? "LLP3" : "LLP4");\r\n}\r\nkfree(ptdata);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *sn_topology_start(struct seq_file *s, loff_t * pos)\r\n{\r\nstruct sn_hwperf_object_info *objs = s->private;\r\nif (*pos < sn_hwperf_obj_cnt)\r\nreturn (void *)(objs + *pos);\r\nreturn NULL;\r\n}\r\nstatic void *sn_topology_next(struct seq_file *s, void *v, loff_t * pos)\r\n{\r\n++*pos;\r\nreturn sn_topology_start(s, pos);\r\n}\r\nstatic void sn_topology_stop(struct seq_file *m, void *v)\r\n{\r\nreturn;\r\n}\r\nstatic void sn_hwperf_call_sal(void *info)\r\n{\r\nstruct sn_hwperf_op_info *op_info = info;\r\nint r;\r\nr = ia64_sn_hwperf_op(sn_hwperf_master_nasid, op_info->op,\r\nop_info->a->arg, op_info->a->sz,\r\n(u64) op_info->p, 0, 0, op_info->v0);\r\nop_info->ret = r;\r\n}\r\nstatic int sn_hwperf_op_cpu(struct sn_hwperf_op_info *op_info)\r\n{\r\nu32 cpu;\r\nu32 use_ipi;\r\nint r = 0;\r\ncpumask_t save_allowed;\r\ncpu = (op_info->a->arg & SN_HWPERF_ARG_CPU_MASK) >> 32;\r\nuse_ipi = op_info->a->arg & SN_HWPERF_ARG_USE_IPI_MASK;\r\nop_info->a->arg &= SN_HWPERF_ARG_OBJID_MASK;\r\nif (cpu != SN_HWPERF_ARG_ANY_CPU) {\r\nif (cpu >= nr_cpu_ids || !cpu_online(cpu)) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nif (cpu == SN_HWPERF_ARG_ANY_CPU || cpu == get_cpu()) {\r\nsn_hwperf_call_sal(op_info);\r\n}\r\nelse {\r\nif (use_ipi) {\r\nsmp_call_function_single(cpu, sn_hwperf_call_sal,\r\nop_info, 1);\r\n}\r\nelse {\r\nsave_allowed = current->cpus_allowed;\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nsn_hwperf_call_sal(op_info);\r\nset_cpus_allowed_ptr(current, &save_allowed);\r\n}\r\n}\r\nr = op_info->ret;\r\nout:\r\nreturn r;\r\n}\r\nstatic int sn_hwperf_map_err(int hwperf_err)\r\n{\r\nint e;\r\nswitch(hwperf_err) {\r\ncase SN_HWPERF_OP_OK:\r\ne = 0;\r\nbreak;\r\ncase SN_HWPERF_OP_NOMEM:\r\ne = -ENOMEM;\r\nbreak;\r\ncase SN_HWPERF_OP_NO_PERM:\r\ne = -EPERM;\r\nbreak;\r\ncase SN_HWPERF_OP_IO_ERROR:\r\ne = -EIO;\r\nbreak;\r\ncase SN_HWPERF_OP_BUSY:\r\ne = -EBUSY;\r\nbreak;\r\ncase SN_HWPERF_OP_RECONFIGURE:\r\ne = -EAGAIN;\r\nbreak;\r\ncase SN_HWPERF_OP_INVAL:\r\ndefault:\r\ne = -EINVAL;\r\nbreak;\r\n}\r\nreturn e;\r\n}\r\nstatic long sn_hwperf_ioctl(struct file *fp, u32 op, unsigned long arg)\r\n{\r\nstruct sn_hwperf_ioctl_args a;\r\nstruct cpuinfo_ia64 *cdata;\r\nstruct sn_hwperf_object_info *objs;\r\nstruct sn_hwperf_object_info *cpuobj;\r\nstruct sn_hwperf_op_info op_info;\r\nvoid *p = NULL;\r\nint nobj;\r\nchar slice;\r\nint node;\r\nint r;\r\nint v0;\r\nint i;\r\nint j;\r\nif ((op & SN_HWPERF_OP_MASK) < 10) {\r\nr = -EINVAL;\r\ngoto error;\r\n}\r\nr = copy_from_user(&a, (const void __user *)arg,\r\nsizeof(struct sn_hwperf_ioctl_args));\r\nif (r != 0) {\r\nr = -EFAULT;\r\ngoto error;\r\n}\r\nif (a.ptr) {\r\np = vmalloc(a.sz);\r\nif (!p) {\r\nr = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nif (op & SN_HWPERF_OP_MEM_COPYIN) {\r\nr = copy_from_user(p, (const void __user *)a.ptr, a.sz);\r\nif (r != 0) {\r\nr = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nswitch (op) {\r\ncase SN_HWPERF_GET_CPU_INFO:\r\nif (a.sz == sizeof(u64)) {\r\n*(u64 *) p = (u64) num_online_cpus() *\r\nsizeof(struct sn_hwperf_object_info);\r\n} else\r\nif (a.sz < num_online_cpus() * sizeof(struct sn_hwperf_object_info)) {\r\nr = -ENOMEM;\r\ngoto error;\r\n} else\r\nif ((r = sn_hwperf_enum_objects(&nobj, &objs)) == 0) {\r\nint cpuobj_index = 0;\r\nmemset(p, 0, a.sz);\r\nfor (i = 0; i < nobj; i++) {\r\nif (!SN_HWPERF_IS_NODE(objs + i))\r\ncontinue;\r\nnode = sn_hwperf_obj_to_cnode(objs + i);\r\nfor_each_online_cpu(j) {\r\nif (node != cpu_to_node(j))\r\ncontinue;\r\ncpuobj = (struct sn_hwperf_object_info *) p + cpuobj_index++;\r\nslice = 'a' + cpuid_to_slice(j);\r\ncdata = cpu_data(j);\r\ncpuobj->id = j;\r\nsnprintf(cpuobj->name,\r\nsizeof(cpuobj->name),\r\n"CPU %luMHz %s",\r\ncdata->proc_freq / 1000000,\r\ncdata->vendor);\r\nsnprintf(cpuobj->location,\r\nsizeof(cpuobj->location),\r\n"%s%c", objs[i].location,\r\nslice);\r\n}\r\n}\r\nvfree(objs);\r\n}\r\nbreak;\r\ncase SN_HWPERF_GET_NODE_NASID:\r\nif (a.sz != sizeof(u64) ||\r\n(node = a.arg) < 0 || !cnode_possible(node)) {\r\nr = -EINVAL;\r\ngoto error;\r\n}\r\n*(u64 *)p = (u64)cnodeid_to_nasid(node);\r\nbreak;\r\ncase SN_HWPERF_GET_OBJ_NODE:\r\ni = a.arg;\r\nif (a.sz != sizeof(u64) || i < 0) {\r\nr = -EINVAL;\r\ngoto error;\r\n}\r\nif ((r = sn_hwperf_enum_objects(&nobj, &objs)) == 0) {\r\nif (i >= nobj) {\r\nr = -EINVAL;\r\nvfree(objs);\r\ngoto error;\r\n}\r\nif (objs[i].id != a.arg) {\r\nfor (i = 0; i < nobj; i++) {\r\nif (objs[i].id == a.arg)\r\nbreak;\r\n}\r\n}\r\nif (i == nobj) {\r\nr = -EINVAL;\r\nvfree(objs);\r\ngoto error;\r\n}\r\nif (!SN_HWPERF_IS_NODE(objs + i) &&\r\n!SN_HWPERF_IS_IONODE(objs + i)) {\r\nr = -ENOENT;\r\nvfree(objs);\r\ngoto error;\r\n}\r\n*(u64 *)p = (u64)sn_hwperf_obj_to_cnode(objs + i);\r\nvfree(objs);\r\n}\r\nbreak;\r\ncase SN_HWPERF_GET_MMRS:\r\ncase SN_HWPERF_SET_MMRS:\r\ncase SN_HWPERF_OBJECT_DISTANCE:\r\nop_info.p = p;\r\nop_info.a = &a;\r\nop_info.v0 = &v0;\r\nop_info.op = op;\r\nr = sn_hwperf_op_cpu(&op_info);\r\nif (r) {\r\nr = sn_hwperf_map_err(r);\r\na.v0 = v0;\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\nr = ia64_sn_hwperf_op(sn_hwperf_master_nasid, op,\r\na.arg, a.sz, (u64) p, 0, 0, &v0);\r\nif (r) {\r\nr = sn_hwperf_map_err(r);\r\ngoto error;\r\n}\r\na.v0 = v0;\r\nbreak;\r\n}\r\nif (op & SN_HWPERF_OP_MEM_COPYOUT) {\r\nr = copy_to_user((void __user *)a.ptr, p, a.sz);\r\nif (r != 0) {\r\nr = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nerror:\r\nvfree(p);\r\nreturn r;\r\n}\r\nstatic int sn_hwperf_init(void)\r\n{\r\nu64 v;\r\nint salr;\r\nint e = 0;\r\nmutex_lock(&sn_hwperf_init_mutex);\r\nif (sn_hwperf_salheap) {\r\nmutex_unlock(&sn_hwperf_init_mutex);\r\nreturn e;\r\n}\r\nsn_hwperf_master_nasid = (nasid_t) ia64_sn_get_console_nasid();\r\nsalr = ia64_sn_hwperf_op(sn_hwperf_master_nasid,\r\n(u64) SN_HWPERF_GET_HEAPSIZE, 0,\r\n(u64) sizeof(u64), (u64) &v, 0, 0, NULL);\r\nif (salr != SN_HWPERF_OP_OK) {\r\ne = -EINVAL;\r\ngoto out;\r\n}\r\nif ((sn_hwperf_salheap = vmalloc(v)) == NULL) {\r\ne = -ENOMEM;\r\ngoto out;\r\n}\r\nsalr = ia64_sn_hwperf_op(sn_hwperf_master_nasid,\r\nSN_HWPERF_INSTALL_HEAP, 0, v,\r\n(u64) sn_hwperf_salheap, 0, 0, NULL);\r\nif (salr != SN_HWPERF_OP_OK) {\r\ne = -EINVAL;\r\ngoto out;\r\n}\r\nsalr = ia64_sn_hwperf_op(sn_hwperf_master_nasid,\r\nSN_HWPERF_OBJECT_COUNT, 0,\r\nsizeof(u64), (u64) &v, 0, 0, NULL);\r\nif (salr != SN_HWPERF_OP_OK) {\r\ne = -EINVAL;\r\ngoto out;\r\n}\r\nsn_hwperf_obj_cnt = (int)v;\r\nout:\r\nif (e < 0 && sn_hwperf_salheap) {\r\nvfree(sn_hwperf_salheap);\r\nsn_hwperf_salheap = NULL;\r\nsn_hwperf_obj_cnt = 0;\r\n}\r\nmutex_unlock(&sn_hwperf_init_mutex);\r\nreturn e;\r\n}\r\nint sn_topology_open(struct inode *inode, struct file *file)\r\n{\r\nint e;\r\nstruct seq_file *seq;\r\nstruct sn_hwperf_object_info *objbuf;\r\nint nobj;\r\nif ((e = sn_hwperf_enum_objects(&nobj, &objbuf)) == 0) {\r\ne = seq_open(file, &sn_topology_seq_ops);\r\nseq = file->private_data;\r\nseq->private = objbuf;\r\n}\r\nreturn e;\r\n}\r\nint sn_topology_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nvfree(seq->private);\r\nreturn seq_release(inode, file);\r\n}\r\nint sn_hwperf_get_nearest_node(cnodeid_t node,\r\ncnodeid_t *near_mem_node, cnodeid_t *near_cpu_node)\r\n{\r\nint e;\r\nint nobj;\r\nstruct sn_hwperf_object_info *objbuf;\r\nif ((e = sn_hwperf_enum_objects(&nobj, &objbuf)) == 0) {\r\ne = sn_hwperf_get_nearest_node_objdata(objbuf, nobj,\r\nnode, near_mem_node, near_cpu_node);\r\nvfree(objbuf);\r\n}\r\nreturn e;\r\n}\r\nstatic int __devinit sn_hwperf_misc_register_init(void)\r\n{\r\nint e;\r\nif (!ia64_platform_is("sn2"))\r\nreturn 0;\r\nsn_hwperf_init();\r\nif ((e = misc_register(&sn_hwperf_dev)) != 0) {\r\nprintk(KERN_ERR "sn_hwperf_misc_register_init: failed to "\r\n"register misc device for \"%s\"\n", sn_hwperf_dev.name);\r\n}\r\nreturn e;\r\n}
