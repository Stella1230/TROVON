static inline unsigned int tlv320aic23_read_reg_cache(struct snd_soc_codec\r\n*codec, unsigned int reg)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg >= ARRAY_SIZE(tlv320aic23_reg))\r\nreturn -1;\r\nreturn cache[reg];\r\n}\r\nstatic inline void tlv320aic23_write_reg_cache(struct snd_soc_codec *codec,\r\nu8 reg, u16 value)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg >= ARRAY_SIZE(tlv320aic23_reg))\r\nreturn;\r\ncache[reg] = value;\r\n}\r\nstatic int tlv320aic23_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nu8 data[2];\r\nif (reg > 9 && reg != 15) {\r\nprintk(KERN_WARNING "%s Invalid register R%u\n", __func__, reg);\r\nreturn -1;\r\n}\r\ndata[0] = (reg << 1) | (value >> 8 & 0x01);\r\ndata[1] = value & 0xff;\r\ntlv320aic23_write_reg_cache(codec, reg, value);\r\nif (codec->hw_write(codec->control_data, data, 2) == 2)\r\nreturn 0;\r\nprintk(KERN_ERR "%s cannot write %03x to register R%u\n", __func__,\r\nvalue, reg);\r\nreturn -EIO;\r\n}\r\nstatic int snd_soc_tlv320aic23_put_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nu16 val, reg;\r\nval = (ucontrol->value.integer.value[0] & 0x07);\r\nval = (val >= 4) ? 4 : (3 - val);\r\nreg = tlv320aic23_read_reg_cache(codec, TLV320AIC23_ANLG) & (~0x1C0);\r\ntlv320aic23_write(codec, TLV320AIC23_ANLG, reg | (val << 6));\r\nreturn 0;\r\n}\r\nstatic int snd_soc_tlv320aic23_get_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nu16 val;\r\nval = tlv320aic23_read_reg_cache(codec, TLV320AIC23_ANLG) & (0x1C0);\r\nval = val >> 6;\r\nval = (val >= 4) ? 4 : (3 - val);\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic unsigned get_score(int adc, int adc_l, int adc_h, int need_adc,\r\nint dac, int dac_l, int dac_h, int need_dac)\r\n{\r\nif ((adc >= adc_l) && (adc <= adc_h) &&\r\n(dac >= dac_l) && (dac <= dac_h)) {\r\nint diff_adc = need_adc - adc;\r\nint diff_dac = need_dac - dac;\r\nreturn abs(diff_adc) + abs(diff_dac);\r\n}\r\nreturn UINT_MAX;\r\n}\r\nstatic int find_rate(int mclk, u32 need_adc, u32 need_dac)\r\n{\r\nint i, j;\r\nint best_i = -1;\r\nint best_j = -1;\r\nint best_div = 0;\r\nunsigned best_score = UINT_MAX;\r\nint adc_l, adc_h, dac_l, dac_h;\r\nneed_adc *= SR_MULT;\r\nneed_dac *= SR_MULT;\r\nadc_l = need_adc - (need_adc >> 5);\r\nadc_h = need_adc + (need_adc >> 5);\r\ndac_l = need_dac - (need_dac >> 5);\r\ndac_h = need_dac + (need_dac >> 5);\r\nfor (i = 0; i < ARRAY_SIZE(bosr_usb_divisor_table); i++) {\r\nint base = mclk / bosr_usb_divisor_table[i];\r\nint mask = sr_valid_mask[i];\r\nfor (j = 0; j < ARRAY_SIZE(sr_adc_mult_table);\r\nj++, mask >>= 1) {\r\nint adc;\r\nint dac;\r\nint score;\r\nif ((mask & 1) == 0)\r\ncontinue;\r\nadc = base * sr_adc_mult_table[j];\r\ndac = base * sr_dac_mult_table[j];\r\nscore = get_score(adc, adc_l, adc_h, need_adc,\r\ndac, dac_l, dac_h, need_dac);\r\nif (best_score > score) {\r\nbest_score = score;\r\nbest_i = i;\r\nbest_j = j;\r\nbest_div = 0;\r\n}\r\nscore = get_score((adc >> 1), adc_l, adc_h, need_adc,\r\n(dac >> 1), dac_l, dac_h, need_dac);\r\nif ((score != UINT_MAX) && (best_score >= score)) {\r\nbest_score = score;\r\nbest_i = i;\r\nbest_j = j;\r\nbest_div = 1;\r\n}\r\n}\r\n}\r\nreturn (best_j << 2) | best_i | (best_div << TLV320AIC23_CLKIN_SHIFT);\r\n}\r\nstatic void get_current_sample_rates(struct snd_soc_codec *codec, int mclk,\r\nu32 *sample_rate_adc, u32 *sample_rate_dac)\r\n{\r\nint src = tlv320aic23_read_reg_cache(codec, TLV320AIC23_SRATE);\r\nint sr = (src >> 2) & 0x0f;\r\nint val = (mclk / bosr_usb_divisor_table[src & 3]);\r\nint adc = (val * sr_adc_mult_table[sr]) / SR_MULT;\r\nint dac = (val * sr_dac_mult_table[sr]) / SR_MULT;\r\nif (src & TLV320AIC23_CLKIN_HALF) {\r\nadc >>= 1;\r\ndac >>= 1;\r\n}\r\n*sample_rate_adc = adc;\r\n*sample_rate_dac = dac;\r\n}\r\nstatic int set_sample_rate_control(struct snd_soc_codec *codec, int mclk,\r\nu32 sample_rate_adc, u32 sample_rate_dac)\r\n{\r\nint data = find_rate(mclk, sample_rate_adc, sample_rate_dac);\r\nif (data < 0) {\r\nprintk(KERN_ERR "%s:Invalid rate %u,%u requested\n",\r\n__func__, sample_rate_adc, sample_rate_dac);\r\nreturn -EINVAL;\r\n}\r\ntlv320aic23_write(codec, TLV320AIC23_SRATE, data);\r\n#ifdef DEBUG\r\n{\r\nu32 adc, dac;\r\nget_current_sample_rates(codec, mclk, &adc, &dac);\r\nprintk(KERN_DEBUG "actual samplerate = %u,%u reg=%x\n",\r\nadc, dac, data);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nu16 iface_reg;\r\nint ret;\r\nstruct aic23 *aic23 = snd_soc_codec_get_drvdata(codec);\r\nu32 sample_rate_adc = aic23->requested_adc;\r\nu32 sample_rate_dac = aic23->requested_dac;\r\nu32 sample_rate = params_rate(params);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\naic23->requested_dac = sample_rate_dac = sample_rate;\r\nif (!sample_rate_adc)\r\nsample_rate_adc = sample_rate;\r\n} else {\r\naic23->requested_adc = sample_rate_adc = sample_rate;\r\nif (!sample_rate_dac)\r\nsample_rate_dac = sample_rate;\r\n}\r\nret = set_sample_rate_control(codec, aic23->mclk, sample_rate_adc,\r\nsample_rate_dac);\r\nif (ret < 0)\r\nreturn ret;\r\niface_reg =\r\ntlv320aic23_read_reg_cache(codec,\r\nTLV320AIC23_DIGT_FMT) & ~(0x03 << 2);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\niface_reg |= (0x01 << 2);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niface_reg |= (0x02 << 2);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\niface_reg |= (0x03 << 2);\r\nbreak;\r\n}\r\ntlv320aic23_write(codec, TLV320AIC23_DIGT_FMT, iface_reg);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_pcm_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\ntlv320aic23_write(codec, TLV320AIC23_ACTIVE, 0x0001);\r\nreturn 0;\r\n}\r\nstatic void tlv320aic23_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nstruct aic23 *aic23 = snd_soc_codec_get_drvdata(codec);\r\nif (!codec->active) {\r\nudelay(50);\r\ntlv320aic23_write(codec, TLV320AIC23_ACTIVE, 0x0);\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naic23->requested_dac = 0;\r\nelse\r\naic23->requested_adc = 0;\r\n}\r\nstatic int tlv320aic23_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 reg;\r\nreg = tlv320aic23_read_reg_cache(codec, TLV320AIC23_DIGT);\r\nif (mute)\r\nreg |= TLV320AIC23_DACM_MUTE;\r\nelse\r\nreg &= ~TLV320AIC23_DACM_MUTE;\r\ntlv320aic23_write(codec, TLV320AIC23_DIGT, reg);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface_reg;\r\niface_reg =\r\ntlv320aic23_read_reg_cache(codec, TLV320AIC23_DIGT_FMT) & (~0x03);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface_reg |= TLV320AIC23_MS_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface_reg |= TLV320AIC23_FOR_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface_reg |= TLV320AIC23_LRP_ON;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface_reg |= TLV320AIC23_FOR_DSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface_reg |= TLV320AIC23_FOR_LJUST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntlv320aic23_write(codec, TLV320AIC23_DIGT_FMT, iface_reg);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct aic23 *aic23 = snd_soc_dai_get_drvdata(codec_dai);\r\naic23->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 reg = tlv320aic23_read_reg_cache(codec, TLV320AIC23_PWR) & 0xff7f;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nreg &= ~(TLV320AIC23_DEVICE_PWR_OFF | TLV320AIC23_OSC_OFF | \\r\nTLV320AIC23_DAC_OFF);\r\ntlv320aic23_write(codec, TLV320AIC23_PWR, reg);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\ntlv320aic23_write(codec, TLV320AIC23_PWR, reg | \\r\nTLV320AIC23_CLK_OFF);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\ntlv320aic23_write(codec, TLV320AIC23_ACTIVE, 0x0);\r\ntlv320aic23_write(codec, TLV320AIC23_PWR, 0xffff);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_suspend(struct snd_soc_codec *codec,\r\npm_message_t state)\r\n{\r\ntlv320aic23_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_resume(struct snd_soc_codec *codec)\r\n{\r\nu16 reg;\r\nfor (reg = 0; reg <= TLV320AIC23_ACTIVE; reg++) {\r\nu16 val = tlv320aic23_read_reg_cache(codec, reg);\r\ntlv320aic23_write(codec, reg, val);\r\n}\r\ntlv320aic23_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct aic23 *aic23 = snd_soc_codec_get_drvdata(codec);\r\nint reg;\r\nprintk(KERN_INFO "AIC23 Audio Codec %s\n", AIC23_VERSION);\r\ncodec->control_data = aic23->control_data;\r\ncodec->hw_write = (hw_write_t)i2c_master_send;\r\ncodec->hw_read = NULL;\r\ntlv320aic23_write(codec, TLV320AIC23_RESET, 0);\r\ntlv320aic23_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\ntlv320aic23_write(codec, TLV320AIC23_DIGT, TLV320AIC23_DEEMP_44K);\r\nreg = tlv320aic23_read_reg_cache(codec, TLV320AIC23_LINVOL);\r\ntlv320aic23_write(codec, TLV320AIC23_LINVOL,\r\n(reg & (~TLV320AIC23_LIM_MUTED)) |\r\n(TLV320AIC23_LRS_ENABLED));\r\nreg = tlv320aic23_read_reg_cache(codec, TLV320AIC23_RINVOL);\r\ntlv320aic23_write(codec, TLV320AIC23_RINVOL,\r\n(reg & (~TLV320AIC23_LIM_MUTED)) |\r\nTLV320AIC23_LRS_ENABLED);\r\nreg = tlv320aic23_read_reg_cache(codec, TLV320AIC23_ANLG);\r\ntlv320aic23_write(codec, TLV320AIC23_ANLG,\r\n(reg) & (~TLV320AIC23_BYPASS_ON) &\r\n(~TLV320AIC23_MICM_MUTED));\r\ntlv320aic23_write(codec, TLV320AIC23_LCHNVOL,\r\nTLV320AIC23_DEFAULT_OUT_VOL &\r\nTLV320AIC23_OUT_VOL_MASK);\r\ntlv320aic23_write(codec, TLV320AIC23_RCHNVOL,\r\nTLV320AIC23_DEFAULT_OUT_VOL &\r\nTLV320AIC23_OUT_VOL_MASK);\r\ntlv320aic23_write(codec, TLV320AIC23_ACTIVE, 0x1);\r\nsnd_soc_add_controls(codec, tlv320aic23_snd_controls,\r\nARRAY_SIZE(tlv320aic23_snd_controls));\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_remove(struct snd_soc_codec *codec)\r\n{\r\ntlv320aic23_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int tlv320aic23_codec_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct aic23 *aic23;\r\nint ret;\r\nif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EINVAL;\r\naic23 = kzalloc(sizeof(struct aic23), GFP_KERNEL);\r\nif (aic23 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, aic23);\r\naic23->control_data = i2c;\r\naic23->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_tlv320aic23, &tlv320aic23_dai, 1);\r\nif (ret < 0)\r\nkfree(aic23);\r\nreturn ret;\r\n}\r\nstatic int __exit tlv320aic23_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nkfree(i2c_get_clientdata(i2c));\r\nreturn 0;\r\n}\r\nstatic int __init tlv320aic23_modinit(void)\r\n{\r\nint ret;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&tlv320aic23_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register TLV320AIC23 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit tlv320aic23_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&tlv320aic23_i2c_driver);\r\n#endif\r\n}
