static int ec168_rw_udev(struct usb_device *udev, struct ec168_req *req)\r\n{\r\nint ret;\r\nunsigned int pipe;\r\nu8 request, requesttype;\r\nu8 *buf;\r\nswitch (req->cmd) {\r\ncase DOWNLOAD_FIRMWARE:\r\ncase GPIO:\r\ncase WRITE_I2C:\r\ncase STREAMING_CTRL:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nrequest = req->cmd;\r\nbreak;\r\ncase READ_I2C:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nrequest = req->cmd;\r\nbreak;\r\ncase GET_CONFIG:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nrequest = CONFIG;\r\nbreak;\r\ncase SET_CONFIG:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nrequest = CONFIG;\r\nbreak;\r\ncase WRITE_DEMOD:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nrequest = DEMOD_RW;\r\nbreak;\r\ncase READ_DEMOD:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nrequest = DEMOD_RW;\r\nbreak;\r\ndefault:\r\nerr("unknown command:%02x", req->cmd);\r\nret = -EPERM;\r\ngoto error;\r\n}\r\nbuf = kmalloc(req->size, GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (requesttype == (USB_TYPE_VENDOR | USB_DIR_OUT)) {\r\nmemcpy(buf, req->data, req->size);\r\npipe = usb_sndctrlpipe(udev, 0);\r\n} else {\r\npipe = usb_rcvctrlpipe(udev, 0);\r\n}\r\nmsleep(1);\r\nret = usb_control_msg(udev, pipe, request, requesttype, req->value,\r\nreq->index, buf, req->size, EC168_USB_TIMEOUT);\r\nec168_debug_dump(request, requesttype, req->value, req->index, buf,\r\nreq->size, deb_xfer);\r\nif (ret < 0)\r\ngoto err_dealloc;\r\nelse\r\nret = 0;\r\nif (!ret && requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))\r\nmemcpy(req->data, buf, req->size);\r\nkfree(buf);\r\nreturn ret;\r\nerr_dealloc:\r\nkfree(buf);\r\nerror:\r\ndeb_info("%s: failed:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec168_ctrl_msg(struct dvb_usb_device *d, struct ec168_req *req)\r\n{\r\nreturn ec168_rw_udev(d->udev, req);\r\n}\r\nstatic int ec168_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct ec168_req req;\r\nint i = 0;\r\nint ret;\r\nif (num > 2)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nwhile (i < num) {\r\nif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\r\nif (msg[i].addr == ec168_ec100_config.demod_address) {\r\nreq.cmd = READ_DEMOD;\r\nreq.value = 0;\r\nreq.index = 0xff00 + msg[i].buf[0];\r\nreq.size = msg[i+1].len;\r\nreq.data = &msg[i+1].buf[0];\r\nret = ec168_ctrl_msg(d, &req);\r\ni += 2;\r\n} else {\r\nerr("I2C read not implemented");\r\nret = -ENOSYS;\r\ni += 2;\r\n}\r\n} else {\r\nif (msg[i].addr == ec168_ec100_config.demod_address) {\r\nreq.cmd = WRITE_DEMOD;\r\nreq.value = msg[i].buf[1];\r\nreq.index = 0xff00 + msg[i].buf[0];\r\nreq.size = 0;\r\nreq.data = NULL;\r\nret = ec168_ctrl_msg(d, &req);\r\ni += 1;\r\n} else {\r\nreq.cmd = WRITE_I2C;\r\nreq.value = msg[i].buf[0];\r\nreq.index = 0x0100 + msg[i].addr;\r\nreq.size = msg[i].len-1;\r\nreq.data = &msg[i].buf[1];\r\nret = ec168_ctrl_msg(d, &req);\r\ni += 1;\r\n}\r\n}\r\nif (ret)\r\ngoto error;\r\n}\r\nret = i;\r\nerror:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic u32 ec168_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int ec168_ec100_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndeb_info("%s:\n", __func__);\r\nadap->fe = dvb_attach(ec100_attach, &ec168_ec100_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ec168_mxl5003s_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndeb_info("%s:\n", __func__);\r\nreturn dvb_attach(mxl5005s_attach, adap->fe, &adap->dev->i2c_adap,\r\n&ec168_mxl5003s_config) == NULL ? -ENODEV : 0;\r\n}\r\nstatic int ec168_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct ec168_req req = {STREAMING_CTRL, 0x7f01, 0x0202, 0, NULL};\r\ndeb_info("%s: onoff:%d\n", __func__, onoff);\r\nif (onoff)\r\nreq.index = 0x0102;\r\nreturn ec168_ctrl_msg(adap->dev, &req);\r\n}\r\nstatic int ec168_download_firmware(struct usb_device *udev,\r\nconst struct firmware *fw)\r\n{\r\nint i, len, packets, remainder, ret;\r\nu16 addr = 0x0000;\r\nstruct ec168_req req = {DOWNLOAD_FIRMWARE, 0, 0, 0, NULL};\r\ndeb_info("%s:\n", __func__);\r\n#define FW_PACKET_MAX_DATA 2048\r\npackets = fw->size / FW_PACKET_MAX_DATA;\r\nremainder = fw->size % FW_PACKET_MAX_DATA;\r\nlen = FW_PACKET_MAX_DATA;\r\nfor (i = 0; i <= packets; i++) {\r\nif (i == packets)\r\nlen = remainder;\r\nreq.size = len;\r\nreq.data = (u8 *)(fw->data + i * FW_PACKET_MAX_DATA);\r\nreq.index = addr;\r\naddr += FW_PACKET_MAX_DATA;\r\nret = ec168_rw_udev(udev, &req);\r\nif (ret) {\r\nerr("firmware download failed:%d packet:%d", ret, i);\r\ngoto error;\r\n}\r\n}\r\nreq.size = 0;\r\nreq.cmd = SET_CONFIG;\r\nreq.value = 0;\r\nreq.index = 0x0001;\r\nret = ec168_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\nreq.cmd = GPIO;\r\nreq.value = 0;\r\nreq.index = 0x0206;\r\nret = ec168_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\nreq.cmd = WRITE_I2C;\r\nreq.value = 0;\r\nreq.index = 0x00c6;\r\nret = ec168_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndeb_info("%s: failed:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec168_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc, int *cold)\r\n{\r\nint ret;\r\nu8 reply;\r\nstruct ec168_req req = {GET_CONFIG, 0, 1, sizeof(reply), &reply};\r\ndeb_info("%s:\n", __func__);\r\nret = ec168_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\ndeb_info("%s: reply:%02x\n", __func__, reply);\r\nif (reply == 0x01)\r\n*cold = 0;\r\nelse\r\n*cold = 1;\r\nreturn ret;\r\nerror:\r\ndeb_info("%s: failed:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec168_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret;\r\ndeb_info("%s: interface:%d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nret = dvb_usb_device_init(intf, &ec168_properties, THIS_MODULE, NULL,\r\nadapter_nr);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndeb_info("%s: failed:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int __init ec168_module_init(void)\r\n{\r\nint ret;\r\ndeb_info("%s:\n", __func__);\r\nret = usb_register(&ec168_driver);\r\nif (ret)\r\nerr("module init failed:%d", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit ec168_module_exit(void)\r\n{\r\ndeb_info("%s:\n", __func__);\r\nusb_deregister(&ec168_driver);\r\n}
