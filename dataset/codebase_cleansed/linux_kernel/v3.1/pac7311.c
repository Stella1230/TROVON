static void reg_w_buf(struct gspca_dev *gspca_dev,\r\n__u8 index,\r\nconst u8 *buffer, int len)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex, gspca_dev->usb_buf, len,\r\n500);\r\nif (ret < 0) {\r\nerr("reg_w_buf() failed index 0x%02x, error %d",\r\nindex, ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\n__u8 index,\r\n__u8 value)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\ngspca_dev->usb_buf[0] = value;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, gspca_dev->usb_buf, 1,\r\n500);\r\nif (ret < 0) {\r\nerr("reg_w() failed index 0x%02x, value 0x%02x, error %d",\r\nindex, value, ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w_seq(struct gspca_dev *gspca_dev,\r\nconst __u8 *seq, int len)\r\n{\r\nwhile (--len >= 0) {\r\nreg_w(gspca_dev, seq[0], seq[1]);\r\nseq += 2;\r\n}\r\n}\r\nstatic void reg_w_page(struct gspca_dev *gspca_dev,\r\nconst __u8 *page, int len)\r\n{\r\nint index;\r\nint ret = 0;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nfor (index = 0; index < len; index++) {\r\nif (page[index] == SKIP)\r\ncontinue;\r\ngspca_dev->usb_buf[0] = page[index];\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, gspca_dev->usb_buf, 1,\r\n500);\r\nif (ret < 0) {\r\nerr("reg_w_page() failed index 0x%02x, "\r\n"value 0x%02x, error %d",\r\nindex, page[index], ret);\r\ngspca_dev->usb_err = ret;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void reg_w_var(struct gspca_dev *gspca_dev,\r\nconst __u8 *seq,\r\nconst __u8 *page4, unsigned int page4_len)\r\n{\r\nint index, len;\r\nfor (;;) {\r\nindex = *seq++;\r\nlen = *seq++;\r\nswitch (len) {\r\ncase END_OF_SEQUENCE:\r\nreturn;\r\ncase LOAD_PAGE4:\r\nreg_w_page(gspca_dev, page4, page4_len);\r\nbreak;\r\ndefault:\r\nif (len > USB_BUF_SZ) {\r\nPDEBUG(D_ERR|D_STREAM,\r\n"Incorrect variable sequence");\r\nreturn;\r\n}\r\nwhile (len > 0) {\r\nif (len < 8) {\r\nreg_w_buf(gspca_dev,\r\nindex, seq, len);\r\nseq += len;\r\nbreak;\r\n}\r\nreg_w_buf(gspca_dev, index, seq, 8);\r\nseq += 8;\r\nindex += 8;\r\nlen -= 8;\r\n}\r\n}\r\n}\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\nPDEBUG(D_CONF, "Find Sensor PAC7311");\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nsd->contrast = CONTRAST_DEF;\r\nsd->gain = GAIN_DEF;\r\nsd->exposure = EXPOSURE_DEF;\r\nsd->autogain = AUTOGAIN_DEF;\r\nsd->hflip = HFLIP_DEF;\r\nsd->vflip = VFLIP_DEF;\r\nreturn 0;\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w(gspca_dev, 0xff, 0x04);\r\nreg_w(gspca_dev, 0x10, sd->contrast >> 4);\r\nreg_w(gspca_dev, 0x11, 0x01);\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint gain = GAIN_MAX - sd->gain;\r\nif (gain < 1)\r\ngain = 1;\r\nelse if (gain > 245)\r\ngain = 245;\r\nreg_w(gspca_dev, 0xff, 0x04);\r\nreg_w(gspca_dev, 0x0e, 0x00);\r\nreg_w(gspca_dev, 0x0f, gain);\r\nreg_w(gspca_dev, 0x11, 0x01);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 reg;\r\nreg = 120 * sd->exposure / 1000;\r\nif (reg < 2)\r\nreg = 2;\r\nelse if (reg > 63)\r\nreg = 63;\r\nreg_w(gspca_dev, 0xff, 0x04);\r\nreg_w(gspca_dev, 0x02, reg);\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nif (gspca_dev->cam.cam_mode[(int)gspca_dev->curr_mode].priv &&\r\nreg <= 3) {\r\nreg_w(gspca_dev, 0x08, 0x09);\r\n} else {\r\nreg_w(gspca_dev, 0x08, 0x08);\r\n}\r\nreg_w(gspca_dev, 0x11, 0x01);\r\n}\r\nstatic void sethvflip(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 data;\r\nreg_w(gspca_dev, 0xff, 0x04);\r\ndata = (sd->hflip ? 0x04 : 0x00) | (sd->vflip ? 0x08 : 0x00);\r\nreg_w(gspca_dev, 0x21, data);\r\nreg_w(gspca_dev, 0x11, 0x01);\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w_seq(gspca_dev, init_7311, sizeof(init_7311)/2);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->sof_read = 0;\r\nreg_w_var(gspca_dev, start_7311,\r\npage4_7311, sizeof(page4_7311));\r\nsetcontrast(gspca_dev);\r\nsetgain(gspca_dev);\r\nsetexposure(gspca_dev);\r\nsethvflip(gspca_dev);\r\nswitch (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv) {\r\ncase 2:\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nreg_w(gspca_dev, 0x17, 0x20);\r\nreg_w(gspca_dev, 0x87, 0x10);\r\nbreak;\r\ncase 1:\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nreg_w(gspca_dev, 0x17, 0x30);\r\nreg_w(gspca_dev, 0x87, 0x11);\r\nbreak;\r\ncase 0:\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nreg_w(gspca_dev, 0x17, 0x00);\r\nreg_w(gspca_dev, 0x87, 0x12);\r\nbreak;\r\n}\r\nsd->sof_read = 0;\r\nsd->autogain_ignore_frames = 0;\r\natomic_set(&sd->avg_lum, -1);\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nreg_w(gspca_dev, 0x78, 0x05);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, 0xff, 0x04);\r\nreg_w(gspca_dev, 0x27, 0x80);\r\nreg_w(gspca_dev, 0x28, 0xca);\r\nreg_w(gspca_dev, 0x29, 0x53);\r\nreg_w(gspca_dev, 0x2a, 0x0e);\r\nreg_w(gspca_dev, 0xff, 0x01);\r\nreg_w(gspca_dev, 0x3e, 0x20);\r\nreg_w(gspca_dev, 0x78, 0x44);\r\nreg_w(gspca_dev, 0x78, 0x44);\r\nreg_w(gspca_dev, 0x78, 0x44);\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint avg_lum = atomic_read(&sd->avg_lum);\r\nint desired_lum, deadzone;\r\nif (avg_lum == -1)\r\nreturn;\r\ndesired_lum = 200;\r\ndeadzone = 20;\r\nif (sd->autogain_ignore_frames > 0)\r\nsd->autogain_ignore_frames--;\r\nelse if (gspca_auto_gain_n_exposure(gspca_dev, avg_lum, desired_lum,\r\ndeadzone, GAIN_KNEE, EXPOSURE_KNEE))\r\nsd->autogain_ignore_frames = PAC_AUTOGAIN_IGNORE_FRAMES;\r\n}\r\nstatic void pac_start_frame(struct gspca_dev *gspca_dev,\r\n__u16 lines, __u16 samples_per_line)\r\n{\r\nunsigned char tmpbuf[4];\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\npac_jpeg_header1, sizeof(pac_jpeg_header1));\r\ntmpbuf[0] = lines >> 8;\r\ntmpbuf[1] = lines & 0xff;\r\ntmpbuf[2] = samples_per_line >> 8;\r\ntmpbuf[3] = samples_per_line & 0xff;\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ntmpbuf, sizeof(tmpbuf));\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\npac_jpeg_header2, sizeof(pac_jpeg_header2));\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 *image;\r\nunsigned char *sof;\r\nsof = pac_find_sof(&sd->sof_read, data, len);\r\nif (sof) {\r\nint n, lum_offset, footer_length;\r\nlum_offset = 24 + sizeof pac_sof_marker;\r\nfooter_length = 26;\r\nn = (sof - data) - (footer_length + sizeof pac_sof_marker);\r\nif (n < 0) {\r\ngspca_dev->image_len += n;\r\nn = 0;\r\n} else {\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, n);\r\n}\r\nimage = gspca_dev->image;\r\nif (image != NULL\r\n&& image[gspca_dev->image_len - 2] == 0xff\r\n&& image[gspca_dev->image_len - 1] == 0xd9)\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\nn = sof - data;\r\nlen -= n;\r\ndata = sof;\r\nif (gspca_dev->last_packet_type == LAST_PACKET &&\r\nn >= lum_offset)\r\natomic_set(&sd->avg_lum, data[-lum_offset] +\r\ndata[-lum_offset + 1]);\r\nelse\r\natomic_set(&sd->avg_lum, -1);\r\npac_start_frame(gspca_dev,\r\ngspca_dev->height, gspca_dev->width);\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_setcontrast(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->contrast = val;\r\nif (gspca_dev->streaming)\r\nsetcontrast(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_getcontrast(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->contrast;\r\nreturn 0;\r\n}\r\nstatic int sd_setgain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->gain = val;\r\nif (gspca_dev->streaming)\r\nsetgain(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_getgain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->gain;\r\nreturn 0;\r\n}\r\nstatic int sd_setexposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->exposure = val;\r\nif (gspca_dev->streaming)\r\nsetexposure(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_getexposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->exposure;\r\nreturn 0;\r\n}\r\nstatic int sd_setautogain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->autogain = val;\r\nif (sd->autogain) {\r\nsd->exposure = EXPOSURE_DEF;\r\nsd->gain = GAIN_DEF;\r\nif (gspca_dev->streaming) {\r\nsd->autogain_ignore_frames =\r\nPAC_AUTOGAIN_IGNORE_FRAMES;\r\nsetexposure(gspca_dev);\r\nsetgain(gspca_dev);\r\n}\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_getautogain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->autogain;\r\nreturn 0;\r\n}\r\nstatic int sd_sethflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->hflip = val;\r\nif (gspca_dev->streaming)\r\nsethvflip(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_gethflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->hflip;\r\nreturn 0;\r\n}\r\nstatic int sd_setvflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->vflip = val;\r\nif (gspca_dev->streaming)\r\nsethvflip(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_getvflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->vflip;\r\nreturn 0;\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint ret = -EINVAL;\r\nu8 data0, data1;\r\nif (len == 2) {\r\ndata0 = data[0];\r\ndata1 = data[1];\r\nif ((data0 == 0x00 && data1 == 0x11) ||\r\n(data0 == 0x22 && data1 == 0x33) ||\r\n(data0 == 0x44 && data1 == 0x55) ||\r\n(data0 == 0x66 && data1 == 0x77) ||\r\n(data0 == 0x88 && data1 == 0x99) ||\r\n(data0 == 0xaa && data1 == 0xbb) ||\r\n(data0 == 0xcc && data1 == 0xdd) ||\r\n(data0 == 0xee && data1 == 0xff)) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int __init sd_mod_init(void)\r\n{\r\nreturn usb_register(&sd_driver);\r\n}\r\nstatic void __exit sd_mod_exit(void)\r\n{\r\nusb_deregister(&sd_driver);\r\n}
