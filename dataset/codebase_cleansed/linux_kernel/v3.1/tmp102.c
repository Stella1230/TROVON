static inline int tmp102_read_reg(struct i2c_client *client, u8 reg)\r\n{\r\nint result = i2c_smbus_read_word_data(client, reg);\r\nreturn result < 0 ? result : swab16(result);\r\n}\r\nstatic inline int tmp102_write_reg(struct i2c_client *client, u8 reg, u16 val)\r\n{\r\nreturn i2c_smbus_write_word_data(client, reg, swab16(val));\r\n}\r\nstatic inline int tmp102_reg_to_mC(s16 val)\r\n{\r\nreturn ((val & ~0x01) * 1000) / 128;\r\n}\r\nstatic inline u16 tmp102_mC_to_reg(int val)\r\n{\r\nreturn (val * 128) / 1000;\r\n}\r\nstatic struct tmp102 *tmp102_update_device(struct i2c_client *client)\r\n{\r\nstruct tmp102 *tmp102 = i2c_get_clientdata(client);\r\nmutex_lock(&tmp102->lock);\r\nif (time_after(jiffies, tmp102->last_update + HZ / 3)) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tmp102->temp); ++i) {\r\nint status = tmp102_read_reg(client, tmp102_reg[i]);\r\nif (status > -1)\r\ntmp102->temp[i] = tmp102_reg_to_mC(status);\r\n}\r\ntmp102->last_update = jiffies;\r\n}\r\nmutex_unlock(&tmp102->lock);\r\nreturn tmp102;\r\n}\r\nstatic ssize_t tmp102_show_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\r\nstruct tmp102 *tmp102 = tmp102_update_device(to_i2c_client(dev));\r\nreturn sprintf(buf, "%d\n", tmp102->temp[sda->index]);\r\n}\r\nstatic ssize_t tmp102_set_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tmp102 *tmp102 = i2c_get_clientdata(client);\r\nlong val;\r\nint status;\r\nif (strict_strtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nval = SENSORS_LIMIT(val, -256000, 255000);\r\nmutex_lock(&tmp102->lock);\r\ntmp102->temp[sda->index] = val;\r\nstatus = tmp102_write_reg(client, tmp102_reg[sda->index],\r\ntmp102_mC_to_reg(val));\r\nmutex_unlock(&tmp102->lock);\r\nreturn status ? : count;\r\n}\r\nstatic int __devinit tmp102_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tmp102 *tmp102;\r\nint status;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_err(&client->dev, "adapter doesn't support SMBus word "\r\n"transactions\n");\r\nreturn -ENODEV;\r\n}\r\ntmp102 = kzalloc(sizeof(*tmp102), GFP_KERNEL);\r\nif (!tmp102) {\r\ndev_dbg(&client->dev, "kzalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(client, tmp102);\r\nstatus = tmp102_read_reg(client, TMP102_CONF_REG);\r\nif (status < 0) {\r\ndev_err(&client->dev, "error reading config register\n");\r\ngoto fail_free;\r\n}\r\ntmp102->config_orig = status;\r\nstatus = tmp102_write_reg(client, TMP102_CONF_REG, TMP102_CONFIG);\r\nif (status < 0) {\r\ndev_err(&client->dev, "error writing config register\n");\r\ngoto fail_restore_config;\r\n}\r\nstatus = tmp102_read_reg(client, TMP102_CONF_REG);\r\nif (status < 0) {\r\ndev_err(&client->dev, "error reading config register\n");\r\ngoto fail_restore_config;\r\n}\r\nstatus &= ~TMP102_CONFIG_RD_ONLY;\r\nif (status != TMP102_CONFIG) {\r\ndev_err(&client->dev, "config settings did not stick\n");\r\nstatus = -ENODEV;\r\ngoto fail_restore_config;\r\n}\r\ntmp102->last_update = jiffies - HZ;\r\nmutex_init(&tmp102->lock);\r\nstatus = sysfs_create_group(&client->dev.kobj, &tmp102_attr_group);\r\nif (status) {\r\ndev_dbg(&client->dev, "could not create sysfs files\n");\r\ngoto fail_restore_config;\r\n}\r\ntmp102->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(tmp102->hwmon_dev)) {\r\ndev_dbg(&client->dev, "unable to register hwmon device\n");\r\nstatus = PTR_ERR(tmp102->hwmon_dev);\r\ngoto fail_remove_sysfs;\r\n}\r\ndev_info(&client->dev, "initialized\n");\r\nreturn 0;\r\nfail_remove_sysfs:\r\nsysfs_remove_group(&client->dev.kobj, &tmp102_attr_group);\r\nfail_restore_config:\r\ntmp102_write_reg(client, TMP102_CONF_REG, tmp102->config_orig);\r\nfail_free:\r\nkfree(tmp102);\r\nreturn status;\r\n}\r\nstatic int __devexit tmp102_remove(struct i2c_client *client)\r\n{\r\nstruct tmp102 *tmp102 = i2c_get_clientdata(client);\r\nhwmon_device_unregister(tmp102->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &tmp102_attr_group);\r\nif (tmp102->config_orig & TMP102_CONF_SD) {\r\nint config;\r\nconfig = tmp102_read_reg(client, TMP102_CONF_REG);\r\nif (config >= 0)\r\ntmp102_write_reg(client, TMP102_CONF_REG,\r\nconfig | TMP102_CONF_SD);\r\n}\r\nkfree(tmp102);\r\nreturn 0;\r\n}\r\nstatic int tmp102_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint config;\r\nconfig = tmp102_read_reg(client, TMP102_CONF_REG);\r\nif (config < 0)\r\nreturn config;\r\nconfig |= TMP102_CONF_SD;\r\nreturn tmp102_write_reg(client, TMP102_CONF_REG, config);\r\n}\r\nstatic int tmp102_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint config;\r\nconfig = tmp102_read_reg(client, TMP102_CONF_REG);\r\nif (config < 0)\r\nreturn config;\r\nconfig &= ~TMP102_CONF_SD;\r\nreturn tmp102_write_reg(client, TMP102_CONF_REG, config);\r\n}\r\nstatic int __init tmp102_init(void)\r\n{\r\nreturn i2c_add_driver(&tmp102_driver);\r\n}\r\nstatic void __exit tmp102_exit(void)\r\n{\r\ni2c_del_driver(&tmp102_driver);\r\n}
