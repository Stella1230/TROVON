static inline u8 __kw_read_reg(struct pmac_i2c_host_kw *host, reg_t reg)\r\n{\r\nreturn readb(host->base + (((unsigned int)reg) << host->bsteps));\r\n}\r\nstatic inline void __kw_write_reg(struct pmac_i2c_host_kw *host,\r\nreg_t reg, u8 val)\r\n{\r\nwriteb(val, host->base + (((unsigned)reg) << host->bsteps));\r\n(void)__kw_read_reg(host, reg_subaddr);\r\n}\r\nstatic u8 kw_i2c_wait_interrupt(struct pmac_i2c_host_kw *host)\r\n{\r\nint i, j;\r\nu8 isr;\r\nfor (i = 0; i < 1000; i++) {\r\nisr = kw_read_reg(reg_isr) & KW_I2C_IRQ_MASK;\r\nif (isr != 0)\r\nreturn isr;\r\nif (host->polled) {\r\nfor (j = 1; j < 100000; j++)\r\nmb();\r\n} else\r\nmsleep(1);\r\n}\r\nreturn isr;\r\n}\r\nstatic void kw_i2c_do_stop(struct pmac_i2c_host_kw *host, int result)\r\n{\r\nkw_write_reg(reg_control, KW_I2C_CTL_STOP);\r\nhost->state = state_stop;\r\nhost->result = result;\r\n}\r\nstatic void kw_i2c_handle_interrupt(struct pmac_i2c_host_kw *host, u8 isr)\r\n{\r\nu8 ack;\r\nDBG_LOW("kw_handle_interrupt(%s, isr: %x)\n",\r\n__kw_state_names[host->state], isr);\r\nif (host->state == state_idle) {\r\nprintk(KERN_WARNING "low_i2c: Keywest got an out of state"\r\n" interrupt, ignoring\n");\r\nkw_write_reg(reg_isr, isr);\r\nreturn;\r\n}\r\nif (isr == 0) {\r\nprintk(KERN_WARNING "low_i2c: Timeout in i2c transfer"\r\n" on keywest !\n");\r\nif (host->state != state_stop) {\r\nkw_i2c_do_stop(host, -EIO);\r\nreturn;\r\n}\r\nack = kw_read_reg(reg_status);\r\nif (ack & KW_I2C_STAT_BUSY)\r\nkw_write_reg(reg_status, 0);\r\nhost->state = state_idle;\r\nkw_write_reg(reg_ier, 0x00);\r\nif (!host->polled)\r\ncomplete(&host->complete);\r\nreturn;\r\n}\r\nif (isr & KW_I2C_IRQ_ADDR) {\r\nack = kw_read_reg(reg_status);\r\nif (host->state != state_addr) {\r\nWRONG_STATE("KW_I2C_IRQ_ADDR");\r\nkw_i2c_do_stop(host, -EIO);\r\n}\r\nif ((ack & KW_I2C_STAT_LAST_AAK) == 0) {\r\nhost->result = -ENXIO;\r\nhost->state = state_stop;\r\nDBG_LOW("KW: NAK on address\n");\r\n} else {\r\nif (host->len == 0)\r\nkw_i2c_do_stop(host, 0);\r\nelse if (host->rw) {\r\nhost->state = state_read;\r\nif (host->len > 1)\r\nkw_write_reg(reg_control,\r\nKW_I2C_CTL_AAK);\r\n} else {\r\nhost->state = state_write;\r\nkw_write_reg(reg_data, *(host->data++));\r\nhost->len--;\r\n}\r\n}\r\nkw_write_reg(reg_isr, KW_I2C_IRQ_ADDR);\r\n}\r\nif (isr & KW_I2C_IRQ_DATA) {\r\nif (host->state == state_read) {\r\n*(host->data++) = kw_read_reg(reg_data);\r\nhost->len--;\r\nkw_write_reg(reg_isr, KW_I2C_IRQ_DATA);\r\nif (host->len == 0)\r\nhost->state = state_stop;\r\nelse if (host->len == 1)\r\nkw_write_reg(reg_control, 0);\r\n} else if (host->state == state_write) {\r\nack = kw_read_reg(reg_status);\r\nif ((ack & KW_I2C_STAT_LAST_AAK) == 0) {\r\nDBG_LOW("KW: nack on data write\n");\r\nhost->result = -EFBIG;\r\nhost->state = state_stop;\r\n} else if (host->len) {\r\nkw_write_reg(reg_data, *(host->data++));\r\nhost->len--;\r\n} else\r\nkw_i2c_do_stop(host, 0);\r\n} else {\r\nWRONG_STATE("KW_I2C_IRQ_DATA");\r\nif (host->state != state_stop)\r\nkw_i2c_do_stop(host, -EIO);\r\n}\r\nkw_write_reg(reg_isr, KW_I2C_IRQ_DATA);\r\n}\r\nif (isr & KW_I2C_IRQ_STOP) {\r\nkw_write_reg(reg_isr, KW_I2C_IRQ_STOP);\r\nif (host->state != state_stop) {\r\nWRONG_STATE("KW_I2C_IRQ_STOP");\r\nhost->result = -EIO;\r\n}\r\nhost->state = state_idle;\r\nif (!host->polled)\r\ncomplete(&host->complete);\r\n}\r\nif (isr & KW_I2C_IRQ_START)\r\nkw_write_reg(reg_isr, KW_I2C_IRQ_START);\r\n}\r\nstatic irqreturn_t kw_i2c_irq(int irq, void *dev_id)\r\n{\r\nstruct pmac_i2c_host_kw *host = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\ndel_timer(&host->timeout_timer);\r\nkw_i2c_handle_interrupt(host, kw_read_reg(reg_isr));\r\nif (host->state != state_idle) {\r\nhost->timeout_timer.expires = jiffies + KW_POLL_TIMEOUT;\r\nadd_timer(&host->timeout_timer);\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void kw_i2c_timeout(unsigned long data)\r\n{\r\nstruct pmac_i2c_host_kw *host = (struct pmac_i2c_host_kw *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nkw_i2c_handle_interrupt(host, kw_read_reg(reg_isr));\r\nif (host->state != state_idle) {\r\nhost->timeout_timer.expires = jiffies + KW_POLL_TIMEOUT;\r\nadd_timer(&host->timeout_timer);\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic int kw_i2c_open(struct pmac_i2c_bus *bus)\r\n{\r\nstruct pmac_i2c_host_kw *host = bus->hostdata;\r\nmutex_lock(&host->mutex);\r\nreturn 0;\r\n}\r\nstatic void kw_i2c_close(struct pmac_i2c_bus *bus)\r\n{\r\nstruct pmac_i2c_host_kw *host = bus->hostdata;\r\nmutex_unlock(&host->mutex);\r\n}\r\nstatic int kw_i2c_xfer(struct pmac_i2c_bus *bus, u8 addrdir, int subsize,\r\nu32 subaddr, u8 *data, int len)\r\n{\r\nstruct pmac_i2c_host_kw *host = bus->hostdata;\r\nu8 mode_reg = host->speed;\r\nint use_irq = host->irq != NO_IRQ && !bus->polled;\r\nswitch(bus->mode) {\r\ncase pmac_i2c_mode_dumb:\r\nreturn -EINVAL;\r\ncase pmac_i2c_mode_std:\r\nmode_reg |= KW_I2C_MODE_STANDARD;\r\nif (subsize != 0)\r\nreturn -EINVAL;\r\nbreak;\r\ncase pmac_i2c_mode_stdsub:\r\nmode_reg |= KW_I2C_MODE_STANDARDSUB;\r\nif (subsize != 1)\r\nreturn -EINVAL;\r\nbreak;\r\ncase pmac_i2c_mode_combined:\r\nmode_reg |= KW_I2C_MODE_COMBINED;\r\nif (subsize != 1)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nkw_write_reg(reg_isr, kw_read_reg(reg_isr));\r\nkw_write_reg(reg_mode, mode_reg | (bus->channel << 4));\r\nkw_write_reg(reg_status, 0);\r\nkw_write_reg(reg_addr, addrdir & 0xff);\r\nif ((mode_reg & KW_I2C_MODE_MODE_MASK) == KW_I2C_MODE_STANDARDSUB\r\n|| (mode_reg & KW_I2C_MODE_MODE_MASK) == KW_I2C_MODE_COMBINED)\r\nkw_write_reg(reg_subaddr, subaddr);\r\nhost->data = data;\r\nhost->len = len;\r\nhost->state = state_addr;\r\nhost->result = 0;\r\nhost->rw = (addrdir & 1);\r\nhost->polled = bus->polled;\r\nif (use_irq) {\r\nINIT_COMPLETION(host->complete);\r\nkw_write_reg(reg_isr, kw_read_reg(reg_isr));\r\nhost->timeout_timer.expires = jiffies + KW_POLL_TIMEOUT;\r\nadd_timer(&host->timeout_timer);\r\nkw_write_reg(reg_ier, KW_I2C_IRQ_MASK);\r\n}\r\nkw_write_reg(reg_control, KW_I2C_CTL_XADDR);\r\nif (use_irq)\r\nwait_for_completion(&host->complete);\r\nelse {\r\nwhile(host->state != state_idle) {\r\nunsigned long flags;\r\nu8 isr = kw_i2c_wait_interrupt(host);\r\nspin_lock_irqsave(&host->lock, flags);\r\nkw_i2c_handle_interrupt(host, isr);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\n}\r\nkw_write_reg(reg_ier, 0);\r\nreturn host->result;\r\n}\r\nstatic struct pmac_i2c_host_kw *__init kw_i2c_host_init(struct device_node *np)\r\n{\r\nstruct pmac_i2c_host_kw *host;\r\nconst u32 *psteps, *prate, *addrp;\r\nu32 steps;\r\nhost = kzalloc(sizeof(struct pmac_i2c_host_kw), GFP_KERNEL);\r\nif (host == NULL) {\r\nprintk(KERN_ERR "low_i2c: Can't allocate host for %s\n",\r\nnp->full_name);\r\nreturn NULL;\r\n}\r\naddrp = of_get_property(np, "AAPL,address", NULL);\r\nif (addrp == NULL) {\r\nprintk(KERN_ERR "low_i2c: Can't find address for %s\n",\r\nnp->full_name);\r\nkfree(host);\r\nreturn NULL;\r\n}\r\nmutex_init(&host->mutex);\r\ninit_completion(&host->complete);\r\nspin_lock_init(&host->lock);\r\ninit_timer(&host->timeout_timer);\r\nhost->timeout_timer.function = kw_i2c_timeout;\r\nhost->timeout_timer.data = (unsigned long)host;\r\npsteps = of_get_property(np, "AAPL,address-step", NULL);\r\nsteps = psteps ? (*psteps) : 0x10;\r\nfor (host->bsteps = 0; (steps & 0x01) == 0; host->bsteps++)\r\nsteps >>= 1;\r\nhost->speed = KW_I2C_MODE_25KHZ;\r\nprate = of_get_property(np, "AAPL,i2c-rate", NULL);\r\nif (prate) switch(*prate) {\r\ncase 100:\r\nhost->speed = KW_I2C_MODE_100KHZ;\r\nbreak;\r\ncase 50:\r\nhost->speed = KW_I2C_MODE_50KHZ;\r\nbreak;\r\ncase 25:\r\nhost->speed = KW_I2C_MODE_25KHZ;\r\nbreak;\r\n}\r\nhost->irq = irq_of_parse_and_map(np, 0);\r\nif (host->irq == NO_IRQ)\r\nprintk(KERN_WARNING\r\n"low_i2c: Failed to map interrupt for %s\n",\r\nnp->full_name);\r\nhost->base = ioremap((*addrp), 0x1000);\r\nif (host->base == NULL) {\r\nprintk(KERN_ERR "low_i2c: Can't map registers for %s\n",\r\nnp->full_name);\r\nkfree(host);\r\nreturn NULL;\r\n}\r\nkw_write_reg(reg_ier, 0);\r\nif (request_irq(host->irq, kw_i2c_irq, IRQF_NO_SUSPEND,\r\n"keywest i2c", host))\r\nhost->irq = NO_IRQ;\r\nprintk(KERN_INFO "KeyWest i2c @0x%08x irq %d %s\n",\r\n*addrp, host->irq, np->full_name);\r\nreturn host;\r\n}\r\nstatic void __init kw_i2c_add(struct pmac_i2c_host_kw *host,\r\nstruct device_node *controller,\r\nstruct device_node *busnode,\r\nint channel)\r\n{\r\nstruct pmac_i2c_bus *bus;\r\nbus = kzalloc(sizeof(struct pmac_i2c_bus), GFP_KERNEL);\r\nif (bus == NULL)\r\nreturn;\r\nbus->controller = of_node_get(controller);\r\nbus->busnode = of_node_get(busnode);\r\nbus->type = pmac_i2c_bus_keywest;\r\nbus->hostdata = host;\r\nbus->channel = channel;\r\nbus->mode = pmac_i2c_mode_std;\r\nbus->open = kw_i2c_open;\r\nbus->close = kw_i2c_close;\r\nbus->xfer = kw_i2c_xfer;\r\nmutex_init(&bus->mutex);\r\nif (controller == busnode)\r\nbus->flags = pmac_i2c_multibus;\r\nlist_add(&bus->link, &pmac_i2c_busses);\r\nprintk(KERN_INFO " channel %d bus %s\n", channel,\r\n(controller == busnode) ? "<multibus>" : busnode->full_name);\r\n}\r\nstatic void __init kw_i2c_probe(void)\r\n{\r\nstruct device_node *np, *child, *parent;\r\nfor_each_compatible_node(np, "i2c","keywest-i2c") {\r\nstruct pmac_i2c_host_kw *host;\r\nint multibus;\r\nhost = kw_i2c_host_init(np);\r\nif (host == NULL)\r\ncontinue;\r\nchild = of_get_next_child(np, NULL);\r\nmultibus = !child || strcmp(child->name, "i2c-bus");\r\nof_node_put(child);\r\nif (multibus) {\r\nint chans, i;\r\nparent = of_get_parent(np);\r\nif (parent == NULL)\r\ncontinue;\r\nchans = parent->name[0] == 'u' ? 2 : 1;\r\nfor (i = 0; i < chans; i++)\r\nkw_i2c_add(host, np, np, i);\r\n} else {\r\nfor (child = NULL;\r\n(child = of_get_next_child(np, child)) != NULL;) {\r\nconst u32 *reg = of_get_property(child,\r\n"reg", NULL);\r\nif (reg == NULL)\r\ncontinue;\r\nkw_i2c_add(host, np, child, *reg);\r\n}\r\n}\r\n}\r\n}\r\nstatic void pmu_i2c_complete(struct adb_request *req)\r\n{\r\ncomplete(req->arg);\r\n}\r\nstatic int pmu_i2c_xfer(struct pmac_i2c_bus *bus, u8 addrdir, int subsize,\r\nu32 subaddr, u8 *data, int len)\r\n{\r\nstruct adb_request *req = bus->hostdata;\r\nstruct pmu_i2c_hdr *hdr = (struct pmu_i2c_hdr *)&req->data[1];\r\nstruct completion comp;\r\nint read = addrdir & 1;\r\nint retry;\r\nint rc = 0;\r\nif (len > 16)\r\nreturn -EINVAL;\r\ninit_completion(&comp);\r\nfor (retry = 0; retry < 16; retry++) {\r\nmemset(req, 0, sizeof(struct adb_request));\r\nhdr->bus = bus->channel;\r\nhdr->count = len;\r\nswitch(bus->mode) {\r\ncase pmac_i2c_mode_std:\r\nif (subsize != 0)\r\nreturn -EINVAL;\r\nhdr->address = addrdir;\r\nhdr->mode = PMU_I2C_MODE_SIMPLE;\r\nbreak;\r\ncase pmac_i2c_mode_stdsub:\r\ncase pmac_i2c_mode_combined:\r\nif (subsize != 1)\r\nreturn -EINVAL;\r\nhdr->address = addrdir & 0xfe;\r\nhdr->comb_addr = addrdir;\r\nhdr->sub_addr = subaddr;\r\nif (bus->mode == pmac_i2c_mode_stdsub)\r\nhdr->mode = PMU_I2C_MODE_STDSUB;\r\nelse\r\nhdr->mode = PMU_I2C_MODE_COMBINED;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nINIT_COMPLETION(comp);\r\nreq->data[0] = PMU_I2C_CMD;\r\nreq->reply[0] = 0xff;\r\nreq->nbytes = sizeof(struct pmu_i2c_hdr) + 1;\r\nreq->done = pmu_i2c_complete;\r\nreq->arg = &comp;\r\nif (!read && len) {\r\nmemcpy(hdr->data, data, len);\r\nreq->nbytes += len;\r\n}\r\nrc = pmu_queue_request(req);\r\nif (rc)\r\nreturn rc;\r\nwait_for_completion(&comp);\r\nif (req->reply[0] == PMU_I2C_STATUS_OK)\r\nbreak;\r\nmsleep(15);\r\n}\r\nif (req->reply[0] != PMU_I2C_STATUS_OK)\r\nreturn -EIO;\r\nfor (retry = 0; retry < 16; retry++) {\r\nmemset(req, 0, sizeof(struct adb_request));\r\nmsleep(15);\r\nhdr->bus = PMU_I2C_BUS_STATUS;\r\nINIT_COMPLETION(comp);\r\nreq->data[0] = PMU_I2C_CMD;\r\nreq->reply[0] = 0xff;\r\nreq->nbytes = 2;\r\nreq->done = pmu_i2c_complete;\r\nreq->arg = &comp;\r\nrc = pmu_queue_request(req);\r\nif (rc)\r\nreturn rc;\r\nwait_for_completion(&comp);\r\nif (req->reply[0] == PMU_I2C_STATUS_OK && !read)\r\nreturn 0;\r\nif (req->reply[0] == PMU_I2C_STATUS_DATAREAD && read) {\r\nint rlen = req->reply_len - 1;\r\nif (rlen != len) {\r\nprintk(KERN_WARNING "low_i2c: PMU returned %d"\r\n" bytes, expected %d !\n", rlen, len);\r\nreturn -EIO;\r\n}\r\nif (len)\r\nmemcpy(data, &req->reply[1], len);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void __init pmu_i2c_probe(void)\r\n{\r\nstruct pmac_i2c_bus *bus;\r\nstruct device_node *busnode;\r\nint channel, sz;\r\nif (!pmu_present())\r\nreturn;\r\nbusnode = of_find_node_by_name(NULL, "pmu-i2c");\r\nif (busnode == NULL)\r\nbusnode = of_find_node_by_name(NULL, "via-pmu");\r\nif (busnode == NULL)\r\nreturn;\r\nprintk(KERN_INFO "PMU i2c %s\n", busnode->full_name);\r\nfor (channel = 1; channel <= 2; channel++) {\r\nsz = sizeof(struct pmac_i2c_bus) + sizeof(struct adb_request);\r\nbus = kzalloc(sz, GFP_KERNEL);\r\nif (bus == NULL)\r\nreturn;\r\nbus->controller = busnode;\r\nbus->busnode = busnode;\r\nbus->type = pmac_i2c_bus_pmu;\r\nbus->channel = channel;\r\nbus->mode = pmac_i2c_mode_std;\r\nbus->hostdata = bus + 1;\r\nbus->xfer = pmu_i2c_xfer;\r\nmutex_init(&bus->mutex);\r\nbus->flags = pmac_i2c_multibus;\r\nlist_add(&bus->link, &pmac_i2c_busses);\r\nprintk(KERN_INFO " channel %d bus <multibus>\n", channel);\r\n}\r\n}\r\nstatic void smu_i2c_complete(struct smu_i2c_cmd *cmd, void *misc)\r\n{\r\ncomplete(misc);\r\n}\r\nstatic int smu_i2c_xfer(struct pmac_i2c_bus *bus, u8 addrdir, int subsize,\r\nu32 subaddr, u8 *data, int len)\r\n{\r\nstruct smu_i2c_cmd *cmd = bus->hostdata;\r\nstruct completion comp;\r\nint read = addrdir & 1;\r\nint rc = 0;\r\nif ((read && len > SMU_I2C_READ_MAX) ||\r\n((!read) && len > SMU_I2C_WRITE_MAX))\r\nreturn -EINVAL;\r\nmemset(cmd, 0, sizeof(struct smu_i2c_cmd));\r\ncmd->info.bus = bus->channel;\r\ncmd->info.devaddr = addrdir;\r\ncmd->info.datalen = len;\r\nswitch(bus->mode) {\r\ncase pmac_i2c_mode_std:\r\nif (subsize != 0)\r\nreturn -EINVAL;\r\ncmd->info.type = SMU_I2C_TRANSFER_SIMPLE;\r\nbreak;\r\ncase pmac_i2c_mode_stdsub:\r\ncase pmac_i2c_mode_combined:\r\nif (subsize > 3 || subsize < 1)\r\nreturn -EINVAL;\r\ncmd->info.sublen = subsize;\r\nmemcpy(&cmd->info.subaddr, ((char *)&subaddr) + (4 - subsize),\r\nsubsize);\r\nif (bus->mode == pmac_i2c_mode_stdsub)\r\ncmd->info.type = SMU_I2C_TRANSFER_STDSUB;\r\nelse\r\ncmd->info.type = SMU_I2C_TRANSFER_COMBINED;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!read && len)\r\nmemcpy(cmd->info.data, data, len);\r\ninit_completion(&comp);\r\ncmd->done = smu_i2c_complete;\r\ncmd->misc = &comp;\r\nrc = smu_queue_i2c(cmd);\r\nif (rc < 0)\r\nreturn rc;\r\nwait_for_completion(&comp);\r\nrc = cmd->status;\r\nif (read && len)\r\nmemcpy(data, cmd->info.data, len);\r\nreturn rc < 0 ? rc : 0;\r\n}\r\nstatic void __init smu_i2c_probe(void)\r\n{\r\nstruct device_node *controller, *busnode;\r\nstruct pmac_i2c_bus *bus;\r\nconst u32 *reg;\r\nint sz;\r\nif (!smu_present())\r\nreturn;\r\ncontroller = of_find_node_by_name(NULL, "smu-i2c-control");\r\nif (controller == NULL)\r\ncontroller = of_find_node_by_name(NULL, "smu");\r\nif (controller == NULL)\r\nreturn;\r\nprintk(KERN_INFO "SMU i2c %s\n", controller->full_name);\r\nfor (busnode = NULL;\r\n(busnode = of_get_next_child(controller, busnode)) != NULL;) {\r\nif (strcmp(busnode->type, "i2c") &&\r\nstrcmp(busnode->type, "i2c-bus"))\r\ncontinue;\r\nreg = of_get_property(busnode, "reg", NULL);\r\nif (reg == NULL)\r\ncontinue;\r\nsz = sizeof(struct pmac_i2c_bus) + sizeof(struct smu_i2c_cmd);\r\nbus = kzalloc(sz, GFP_KERNEL);\r\nif (bus == NULL)\r\nreturn;\r\nbus->controller = controller;\r\nbus->busnode = of_node_get(busnode);\r\nbus->type = pmac_i2c_bus_smu;\r\nbus->channel = *reg;\r\nbus->mode = pmac_i2c_mode_std;\r\nbus->hostdata = bus + 1;\r\nbus->xfer = smu_i2c_xfer;\r\nmutex_init(&bus->mutex);\r\nbus->flags = 0;\r\nlist_add(&bus->link, &pmac_i2c_busses);\r\nprintk(KERN_INFO " channel %x bus %s\n",\r\nbus->channel, busnode->full_name);\r\n}\r\n}\r\nstruct pmac_i2c_bus *pmac_i2c_find_bus(struct device_node *node)\r\n{\r\nstruct device_node *p = of_node_get(node);\r\nstruct device_node *prev = NULL;\r\nstruct pmac_i2c_bus *bus;\r\nwhile(p) {\r\nlist_for_each_entry(bus, &pmac_i2c_busses, link) {\r\nif (p == bus->busnode) {\r\nif (prev && bus->flags & pmac_i2c_multibus) {\r\nconst u32 *reg;\r\nreg = of_get_property(prev, "reg",\r\nNULL);\r\nif (!reg)\r\ncontinue;\r\nif (((*reg) >> 8) != bus->channel)\r\ncontinue;\r\n}\r\nof_node_put(p);\r\nof_node_put(prev);\r\nreturn bus;\r\n}\r\n}\r\nof_node_put(prev);\r\nprev = p;\r\np = of_get_parent(p);\r\n}\r\nreturn NULL;\r\n}\r\nu8 pmac_i2c_get_dev_addr(struct device_node *device)\r\n{\r\nconst u32 *reg = of_get_property(device, "reg", NULL);\r\nif (reg == NULL)\r\nreturn 0;\r\nreturn (*reg) & 0xff;\r\n}\r\nstruct device_node *pmac_i2c_get_controller(struct pmac_i2c_bus *bus)\r\n{\r\nreturn bus->controller;\r\n}\r\nstruct device_node *pmac_i2c_get_bus_node(struct pmac_i2c_bus *bus)\r\n{\r\nreturn bus->busnode;\r\n}\r\nint pmac_i2c_get_type(struct pmac_i2c_bus *bus)\r\n{\r\nreturn bus->type;\r\n}\r\nint pmac_i2c_get_flags(struct pmac_i2c_bus *bus)\r\n{\r\nreturn bus->flags;\r\n}\r\nint pmac_i2c_get_channel(struct pmac_i2c_bus *bus)\r\n{\r\nreturn bus->channel;\r\n}\r\nstruct i2c_adapter *pmac_i2c_get_adapter(struct pmac_i2c_bus *bus)\r\n{\r\nreturn &bus->adapter;\r\n}\r\nstruct pmac_i2c_bus *pmac_i2c_adapter_to_bus(struct i2c_adapter *adapter)\r\n{\r\nstruct pmac_i2c_bus *bus;\r\nlist_for_each_entry(bus, &pmac_i2c_busses, link)\r\nif (&bus->adapter == adapter)\r\nreturn bus;\r\nreturn NULL;\r\n}\r\nint pmac_i2c_match_adapter(struct device_node *dev, struct i2c_adapter *adapter)\r\n{\r\nstruct pmac_i2c_bus *bus = pmac_i2c_find_bus(dev);\r\nif (bus == NULL)\r\nreturn 0;\r\nreturn (&bus->adapter == adapter);\r\n}\r\nint pmac_low_i2c_lock(struct device_node *np)\r\n{\r\nstruct pmac_i2c_bus *bus, *found = NULL;\r\nlist_for_each_entry(bus, &pmac_i2c_busses, link) {\r\nif (np == bus->controller) {\r\nfound = bus;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn -ENODEV;\r\nreturn pmac_i2c_open(bus, 0);\r\n}\r\nint pmac_low_i2c_unlock(struct device_node *np)\r\n{\r\nstruct pmac_i2c_bus *bus, *found = NULL;\r\nlist_for_each_entry(bus, &pmac_i2c_busses, link) {\r\nif (np == bus->controller) {\r\nfound = bus;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn -ENODEV;\r\npmac_i2c_close(bus);\r\nreturn 0;\r\n}\r\nint pmac_i2c_open(struct pmac_i2c_bus *bus, int polled)\r\n{\r\nint rc;\r\nmutex_lock(&bus->mutex);\r\nbus->polled = polled || pmac_i2c_force_poll;\r\nbus->opened = 1;\r\nbus->mode = pmac_i2c_mode_std;\r\nif (bus->open && (rc = bus->open(bus)) != 0) {\r\nbus->opened = 0;\r\nmutex_unlock(&bus->mutex);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid pmac_i2c_close(struct pmac_i2c_bus *bus)\r\n{\r\nWARN_ON(!bus->opened);\r\nif (bus->close)\r\nbus->close(bus);\r\nbus->opened = 0;\r\nmutex_unlock(&bus->mutex);\r\n}\r\nint pmac_i2c_setmode(struct pmac_i2c_bus *bus, int mode)\r\n{\r\nWARN_ON(!bus->opened);\r\nif (mode < pmac_i2c_mode_dumb || mode > pmac_i2c_mode_combined) {\r\nprintk(KERN_ERR "low_i2c: Invalid mode %d requested on"\r\n" bus %s !\n", mode, bus->busnode->full_name);\r\nreturn -EINVAL;\r\n}\r\nbus->mode = mode;\r\nreturn 0;\r\n}\r\nint pmac_i2c_xfer(struct pmac_i2c_bus *bus, u8 addrdir, int subsize,\r\nu32 subaddr, u8 *data, int len)\r\n{\r\nint rc;\r\nWARN_ON(!bus->opened);\r\nDBG("xfer() chan=%d, addrdir=0x%x, mode=%d, subsize=%d, subaddr=0x%x,"\r\n" %d bytes, bus %s\n", bus->channel, addrdir, bus->mode, subsize,\r\nsubaddr, len, bus->busnode->full_name);\r\nrc = bus->xfer(bus, addrdir, subsize, subaddr, data, len);\r\n#ifdef DEBUG\r\nif (rc)\r\nDBG("xfer error %d\n", rc);\r\n#endif\r\nreturn rc;\r\n}\r\nstatic void pmac_i2c_devscan(void (*callback)(struct device_node *dev,\r\nint quirks))\r\n{\r\nstruct pmac_i2c_bus *bus;\r\nstruct device_node *np;\r\nstatic struct whitelist_ent {\r\nchar *name;\r\nchar *compatible;\r\nint quirks;\r\n} whitelist[] = {\r\n{ "i2c-hwclock", "imic5002", pmac_i2c_quirk_skip },\r\n{ "i2c-hwclock", "imic5003", pmac_i2c_quirk_skip },\r\n{ "i2c-hwclock", NULL, pmac_i2c_quirk_invmask },\r\n{ "i2c-cpu-voltage", NULL, 0},\r\n{ "temp-monitor", NULL, 0 },\r\n{ "supply-monitor", NULL, 0 },\r\n{ NULL, NULL, 0 },\r\n};\r\nlist_for_each_entry(bus, &pmac_i2c_busses, link) {\r\nfor (np = NULL;\r\n(np = of_get_next_child(bus->busnode, np)) != NULL;) {\r\nstruct whitelist_ent *p;\r\nif (bus->flags & pmac_i2c_multibus)\r\nif (bus != pmac_i2c_find_bus(np))\r\ncontinue;\r\nfor (p = whitelist; p->name != NULL; p++) {\r\nif (strcmp(np->name, p->name))\r\ncontinue;\r\nif (p->compatible &&\r\n!of_device_is_compatible(np, p->compatible))\r\ncontinue;\r\nif (p->quirks & pmac_i2c_quirk_skip)\r\nbreak;\r\ncallback(np, p->quirks);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void* pmac_i2c_do_begin(struct pmf_function *func, struct pmf_args *args)\r\n{\r\nstruct pmac_i2c_pf_inst *inst;\r\nstruct pmac_i2c_bus *bus;\r\nbus = pmac_i2c_find_bus(func->node);\r\nif (bus == NULL) {\r\nprintk(KERN_ERR "low_i2c: Can't find bus for %s (pfunc)\n",\r\nfunc->node->full_name);\r\nreturn NULL;\r\n}\r\nif (pmac_i2c_open(bus, 0)) {\r\nprintk(KERN_ERR "low_i2c: Can't open i2c bus for %s (pfunc)\n",\r\nfunc->node->full_name);\r\nreturn NULL;\r\n}\r\ninst = kzalloc(sizeof(struct pmac_i2c_pf_inst), GFP_KERNEL);\r\nif (inst == NULL) {\r\npmac_i2c_close(bus);\r\nreturn NULL;\r\n}\r\ninst->bus = bus;\r\ninst->addr = pmac_i2c_get_dev_addr(func->node);\r\ninst->quirks = (int)(long)func->driver_data;\r\nreturn inst;\r\n}\r\nstatic void pmac_i2c_do_end(struct pmf_function *func, void *instdata)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\nif (inst == NULL)\r\nreturn;\r\npmac_i2c_close(inst->bus);\r\nkfree(inst);\r\n}\r\nstatic int pmac_i2c_do_read(PMF_STD_ARGS, u32 len)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\ninst->bytes = len;\r\nreturn pmac_i2c_xfer(inst->bus, inst->addr | pmac_i2c_read, 0, 0,\r\ninst->buffer, len);\r\n}\r\nstatic int pmac_i2c_do_write(PMF_STD_ARGS, u32 len, const u8 *data)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\nreturn pmac_i2c_xfer(inst->bus, inst->addr | pmac_i2c_write, 0, 0,\r\n(u8 *)data, len);\r\n}\r\nstatic void pmac_i2c_do_apply_rmw(struct pmac_i2c_pf_inst *inst,\r\nu32 len, const u8 *mask, const u8 *val)\r\n{\r\nint i;\r\nif (inst->quirks & pmac_i2c_quirk_invmask) {\r\nfor (i = 0; i < len; i ++)\r\ninst->scratch[i] = (inst->buffer[i] & mask[i]) | val[i];\r\n} else {\r\nfor (i = 0; i < len; i ++)\r\ninst->scratch[i] = (inst->buffer[i] & ~mask[i])\r\n| (val[i] & mask[i]);\r\n}\r\n}\r\nstatic int pmac_i2c_do_rmw(PMF_STD_ARGS, u32 masklen, u32 valuelen,\r\nu32 totallen, const u8 *maskdata,\r\nconst u8 *valuedata)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\nif (masklen > inst->bytes || valuelen > inst->bytes ||\r\ntotallen > inst->bytes || valuelen > masklen)\r\nreturn -EINVAL;\r\npmac_i2c_do_apply_rmw(inst, masklen, maskdata, valuedata);\r\nreturn pmac_i2c_xfer(inst->bus, inst->addr | pmac_i2c_write, 0, 0,\r\ninst->scratch, totallen);\r\n}\r\nstatic int pmac_i2c_do_read_sub(PMF_STD_ARGS, u8 subaddr, u32 len)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\ninst->bytes = len;\r\nreturn pmac_i2c_xfer(inst->bus, inst->addr | pmac_i2c_read, 1, subaddr,\r\ninst->buffer, len);\r\n}\r\nstatic int pmac_i2c_do_write_sub(PMF_STD_ARGS, u8 subaddr, u32 len,\r\nconst u8 *data)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\nreturn pmac_i2c_xfer(inst->bus, inst->addr | pmac_i2c_write, 1,\r\nsubaddr, (u8 *)data, len);\r\n}\r\nstatic int pmac_i2c_do_set_mode(PMF_STD_ARGS, int mode)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\nreturn pmac_i2c_setmode(inst->bus, mode);\r\n}\r\nstatic int pmac_i2c_do_rmw_sub(PMF_STD_ARGS, u8 subaddr, u32 masklen,\r\nu32 valuelen, u32 totallen, const u8 *maskdata,\r\nconst u8 *valuedata)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\nif (masklen > inst->bytes || valuelen > inst->bytes ||\r\ntotallen > inst->bytes || valuelen > masklen)\r\nreturn -EINVAL;\r\npmac_i2c_do_apply_rmw(inst, masklen, maskdata, valuedata);\r\nreturn pmac_i2c_xfer(inst->bus, inst->addr | pmac_i2c_write, 1,\r\nsubaddr, inst->scratch, totallen);\r\n}\r\nstatic int pmac_i2c_do_mask_and_comp(PMF_STD_ARGS, u32 len,\r\nconst u8 *maskdata,\r\nconst u8 *valuedata)\r\n{\r\nstruct pmac_i2c_pf_inst *inst = instdata;\r\nint i, match;\r\nif (!args || !args->count || !args->u[0].p)\r\nreturn -EINVAL;\r\nif (len > inst->bytes)\r\nreturn -EINVAL;\r\nfor (i = 0, match = 1; match && i < len; i ++)\r\nif ((inst->buffer[i] & maskdata[i]) != valuedata[i])\r\nmatch = 0;\r\n*args->u[0].p = match;\r\nreturn 0;\r\n}\r\nstatic int pmac_i2c_do_delay(PMF_STD_ARGS, u32 duration)\r\n{\r\nmsleep((duration + 999) / 1000);\r\nreturn 0;\r\n}\r\nstatic void __init pmac_i2c_dev_create(struct device_node *np, int quirks)\r\n{\r\nDBG("dev_create(%s)\n", np->full_name);\r\npmf_register_driver(np, &pmac_i2c_pfunc_handlers,\r\n(void *)(long)quirks);\r\n}\r\nstatic void __init pmac_i2c_dev_init(struct device_node *np, int quirks)\r\n{\r\nDBG("dev_create(%s)\n", np->full_name);\r\npmf_do_functions(np, NULL, 0, PMF_FLAGS_ON_INIT, NULL);\r\n}\r\nstatic void pmac_i2c_dev_suspend(struct device_node *np, int quirks)\r\n{\r\nDBG("dev_suspend(%s)\n", np->full_name);\r\npmf_do_functions(np, NULL, 0, PMF_FLAGS_ON_SLEEP, NULL);\r\n}\r\nstatic void pmac_i2c_dev_resume(struct device_node *np, int quirks)\r\n{\r\nDBG("dev_resume(%s)\n", np->full_name);\r\npmf_do_functions(np, NULL, 0, PMF_FLAGS_ON_WAKE, NULL);\r\n}\r\nvoid pmac_pfunc_i2c_suspend(void)\r\n{\r\npmac_i2c_devscan(pmac_i2c_dev_suspend);\r\n}\r\nvoid pmac_pfunc_i2c_resume(void)\r\n{\r\npmac_i2c_devscan(pmac_i2c_dev_resume);\r\n}\r\nint __init pmac_i2c_init(void)\r\n{\r\nstatic int i2c_inited;\r\nif (i2c_inited)\r\nreturn 0;\r\ni2c_inited = 1;\r\nkw_i2c_probe();\r\n#ifdef CONFIG_ADB_PMU\r\npmu_i2c_probe();\r\n#endif\r\n#ifdef CONFIG_PMAC_SMU\r\nsmu_i2c_probe();\r\n#endif\r\npmac_i2c_devscan(pmac_i2c_dev_create);\r\nreturn 0;\r\n}\r\nstatic int __init pmac_i2c_create_platform_devices(void)\r\n{\r\nstruct pmac_i2c_bus *bus;\r\nint i = 0;\r\npmac_i2c_force_poll = 0;\r\nlist_for_each_entry(bus, &pmac_i2c_busses, link) {\r\nbus->platform_dev =\r\nplatform_device_alloc("i2c-powermac", i++);\r\nif (bus->platform_dev == NULL)\r\nreturn -ENOMEM;\r\nbus->platform_dev->dev.platform_data = bus;\r\nplatform_device_add(bus->platform_dev);\r\n}\r\npmac_i2c_devscan(pmac_i2c_dev_init);\r\nreturn 0;\r\n}
