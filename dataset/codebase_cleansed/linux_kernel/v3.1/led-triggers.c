ssize_t led_trigger_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nchar trigger_name[TRIG_NAME_MAX];\r\nstruct led_trigger *trig;\r\nsize_t len;\r\ntrigger_name[sizeof(trigger_name) - 1] = '\0';\r\nstrncpy(trigger_name, buf, sizeof(trigger_name) - 1);\r\nlen = strlen(trigger_name);\r\nif (len && trigger_name[len - 1] == '\n')\r\ntrigger_name[len - 1] = '\0';\r\nif (!strcmp(trigger_name, "none")) {\r\nled_trigger_remove(led_cdev);\r\nreturn count;\r\n}\r\ndown_read(&triggers_list_lock);\r\nlist_for_each_entry(trig, &trigger_list, next_trig) {\r\nif (!strcmp(trigger_name, trig->name)) {\r\ndown_write(&led_cdev->trigger_lock);\r\nled_trigger_set(led_cdev, trig);\r\nup_write(&led_cdev->trigger_lock);\r\nup_read(&triggers_list_lock);\r\nreturn count;\r\n}\r\n}\r\nup_read(&triggers_list_lock);\r\nreturn -EINVAL;\r\n}\r\nssize_t led_trigger_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct led_trigger *trig;\r\nint len = 0;\r\ndown_read(&triggers_list_lock);\r\ndown_read(&led_cdev->trigger_lock);\r\nif (!led_cdev->trigger)\r\nlen += sprintf(buf+len, "[none] ");\r\nelse\r\nlen += sprintf(buf+len, "none ");\r\nlist_for_each_entry(trig, &trigger_list, next_trig) {\r\nif (led_cdev->trigger && !strcmp(led_cdev->trigger->name,\r\ntrig->name))\r\nlen += sprintf(buf+len, "[%s] ", trig->name);\r\nelse\r\nlen += sprintf(buf+len, "%s ", trig->name);\r\n}\r\nup_read(&led_cdev->trigger_lock);\r\nup_read(&triggers_list_lock);\r\nlen += sprintf(len+buf, "\n");\r\nreturn len;\r\n}\r\nvoid led_trigger_set(struct led_classdev *led_cdev, struct led_trigger *trigger)\r\n{\r\nunsigned long flags;\r\nif (led_cdev->trigger) {\r\nwrite_lock_irqsave(&led_cdev->trigger->leddev_list_lock, flags);\r\nlist_del(&led_cdev->trig_list);\r\nwrite_unlock_irqrestore(&led_cdev->trigger->leddev_list_lock,\r\nflags);\r\nif (led_cdev->trigger->deactivate)\r\nled_cdev->trigger->deactivate(led_cdev);\r\nled_cdev->trigger = NULL;\r\nled_brightness_set(led_cdev, LED_OFF);\r\n}\r\nif (trigger) {\r\nwrite_lock_irqsave(&trigger->leddev_list_lock, flags);\r\nlist_add_tail(&led_cdev->trig_list, &trigger->led_cdevs);\r\nwrite_unlock_irqrestore(&trigger->leddev_list_lock, flags);\r\nled_cdev->trigger = trigger;\r\nif (trigger->activate)\r\ntrigger->activate(led_cdev);\r\n}\r\n}\r\nvoid led_trigger_remove(struct led_classdev *led_cdev)\r\n{\r\ndown_write(&led_cdev->trigger_lock);\r\nled_trigger_set(led_cdev, NULL);\r\nup_write(&led_cdev->trigger_lock);\r\n}\r\nvoid led_trigger_set_default(struct led_classdev *led_cdev)\r\n{\r\nstruct led_trigger *trig;\r\nif (!led_cdev->default_trigger)\r\nreturn;\r\ndown_read(&triggers_list_lock);\r\ndown_write(&led_cdev->trigger_lock);\r\nlist_for_each_entry(trig, &trigger_list, next_trig) {\r\nif (!strcmp(led_cdev->default_trigger, trig->name))\r\nled_trigger_set(led_cdev, trig);\r\n}\r\nup_write(&led_cdev->trigger_lock);\r\nup_read(&triggers_list_lock);\r\n}\r\nint led_trigger_register(struct led_trigger *trigger)\r\n{\r\nstruct led_classdev *led_cdev;\r\nstruct led_trigger *trig;\r\nrwlock_init(&trigger->leddev_list_lock);\r\nINIT_LIST_HEAD(&trigger->led_cdevs);\r\ndown_write(&triggers_list_lock);\r\nlist_for_each_entry(trig, &trigger_list, next_trig) {\r\nif (!strcmp(trig->name, trigger->name)) {\r\nup_write(&triggers_list_lock);\r\nreturn -EEXIST;\r\n}\r\n}\r\nlist_add_tail(&trigger->next_trig, &trigger_list);\r\nup_write(&triggers_list_lock);\r\ndown_read(&leds_list_lock);\r\nlist_for_each_entry(led_cdev, &leds_list, node) {\r\ndown_write(&led_cdev->trigger_lock);\r\nif (!led_cdev->trigger && led_cdev->default_trigger &&\r\n!strcmp(led_cdev->default_trigger, trigger->name))\r\nled_trigger_set(led_cdev, trigger);\r\nup_write(&led_cdev->trigger_lock);\r\n}\r\nup_read(&leds_list_lock);\r\nreturn 0;\r\n}\r\nvoid led_trigger_unregister(struct led_trigger *trigger)\r\n{\r\nstruct led_classdev *led_cdev;\r\ndown_write(&triggers_list_lock);\r\nlist_del(&trigger->next_trig);\r\nup_write(&triggers_list_lock);\r\ndown_read(&leds_list_lock);\r\nlist_for_each_entry(led_cdev, &leds_list, node) {\r\ndown_write(&led_cdev->trigger_lock);\r\nif (led_cdev->trigger == trigger)\r\nled_trigger_set(led_cdev, NULL);\r\nup_write(&led_cdev->trigger_lock);\r\n}\r\nup_read(&leds_list_lock);\r\n}\r\nvoid led_trigger_event(struct led_trigger *trigger,\r\nenum led_brightness brightness)\r\n{\r\nstruct list_head *entry;\r\nif (!trigger)\r\nreturn;\r\nread_lock(&trigger->leddev_list_lock);\r\nlist_for_each(entry, &trigger->led_cdevs) {\r\nstruct led_classdev *led_cdev;\r\nled_cdev = list_entry(entry, struct led_classdev, trig_list);\r\nled_set_brightness(led_cdev, brightness);\r\n}\r\nread_unlock(&trigger->leddev_list_lock);\r\n}\r\nvoid led_trigger_blink(struct led_trigger *trigger,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct list_head *entry;\r\nif (!trigger)\r\nreturn;\r\nread_lock(&trigger->leddev_list_lock);\r\nlist_for_each(entry, &trigger->led_cdevs) {\r\nstruct led_classdev *led_cdev;\r\nled_cdev = list_entry(entry, struct led_classdev, trig_list);\r\nled_blink_set(led_cdev, delay_on, delay_off);\r\n}\r\nread_unlock(&trigger->leddev_list_lock);\r\n}\r\nvoid led_trigger_register_simple(const char *name, struct led_trigger **tp)\r\n{\r\nstruct led_trigger *trigger;\r\nint err;\r\ntrigger = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);\r\nif (trigger) {\r\ntrigger->name = name;\r\nerr = led_trigger_register(trigger);\r\nif (err < 0)\r\nprintk(KERN_WARNING "LED trigger %s failed to register"\r\n" (%d)\n", name, err);\r\n} else\r\nprintk(KERN_WARNING "LED trigger %s failed to register"\r\n" (no memory)\n", name);\r\n*tp = trigger;\r\n}\r\nvoid led_trigger_unregister_simple(struct led_trigger *trigger)\r\n{\r\nif (trigger)\r\nled_trigger_unregister(trigger);\r\nkfree(trigger);\r\n}
