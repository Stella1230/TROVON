static int mos7840_set_reg_sync(struct usb_serial_port *port, __u16 reg,\r\n__u16 val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nval = val & 0x00ff;\r\ndbg("mos7840_set_reg_sync offset is %x, value %x", reg, val);\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ,\r\nMCS_WR_RTYPE, val, reg, NULL, 0,\r\nMOS_WDR_TIMEOUT);\r\n}\r\nstatic int mos7840_get_reg_sync(struct usb_serial_port *port, __u16 reg,\r\n__u16 *val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nint ret = 0;\r\nu8 *buf;\r\nbuf = kmalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,\r\nMCS_RD_RTYPE, 0, reg, buf, VENDOR_READ_LENGTH,\r\nMOS_WDR_TIMEOUT);\r\n*val = buf[0];\r\ndbg("mos7840_get_reg_sync offset is %x, return val %x", reg, *val);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int mos7840_set_uart_reg(struct usb_serial_port *port, __u16 reg,\r\n__u16 val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nval = val & 0x00ff;\r\nif (port->serial->num_ports == 4) {\r\nval |= (((__u16) port->number -\r\n(__u16) (port->serial->minor)) + 1) << 8;\r\ndbg("mos7840_set_uart_reg application number is %x", val);\r\n} else {\r\nif (((__u16) port->number - (__u16) (port->serial->minor)) == 0) {\r\nval |= (((__u16) port->number -\r\n(__u16) (port->serial->minor)) + 1) << 8;\r\ndbg("mos7840_set_uart_reg application number is %x",\r\nval);\r\n} else {\r\nval |=\r\n(((__u16) port->number -\r\n(__u16) (port->serial->minor)) + 2) << 8;\r\ndbg("mos7840_set_uart_reg application number is %x",\r\nval);\r\n}\r\n}\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ,\r\nMCS_WR_RTYPE, val, reg, NULL, 0,\r\nMOS_WDR_TIMEOUT);\r\n}\r\nstatic int mos7840_get_uart_reg(struct usb_serial_port *port, __u16 reg,\r\n__u16 *val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nint ret = 0;\r\n__u16 Wval;\r\nu8 *buf;\r\nbuf = kmalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (port->serial->num_ports == 4) {\r\nWval =\r\n(((__u16) port->number - (__u16) (port->serial->minor)) +\r\n1) << 8;\r\ndbg("mos7840_get_uart_reg application number is %x", Wval);\r\n} else {\r\nif (((__u16) port->number - (__u16) (port->serial->minor)) == 0) {\r\nWval = (((__u16) port->number -\r\n(__u16) (port->serial->minor)) + 1) << 8;\r\ndbg("mos7840_get_uart_reg application number is %x",\r\nWval);\r\n} else {\r\nWval = (((__u16) port->number -\r\n(__u16) (port->serial->minor)) + 2) << 8;\r\ndbg("mos7840_get_uart_reg application number is %x",\r\nWval);\r\n}\r\n}\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,\r\nMCS_RD_RTYPE, Wval, reg, buf, VENDOR_READ_LENGTH,\r\nMOS_WDR_TIMEOUT);\r\n*val = buf[0];\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void mos7840_dump_serial_port(struct moschip_port *mos7840_port)\r\n{\r\ndbg("***************************************");\r\ndbg("SpRegOffset is %2x", mos7840_port->SpRegOffset);\r\ndbg("ControlRegOffset is %2x", mos7840_port->ControlRegOffset);\r\ndbg("DCRRegOffset is %2x", mos7840_port->DcrRegOffset);\r\ndbg("***************************************");\r\n}\r\nstatic inline void mos7840_set_port_private(struct usb_serial_port *port,\r\nstruct moschip_port *data)\r\n{\r\nusb_set_serial_port_data(port, (void *)data);\r\n}\r\nstatic inline struct moschip_port *mos7840_get_port_private(struct\r\nusb_serial_port\r\n*port)\r\n{\r\nreturn (struct moschip_port *)usb_get_serial_port_data(port);\r\n}\r\nstatic void mos7840_handle_new_msr(struct moschip_port *port, __u8 new_msr)\r\n{\r\nstruct moschip_port *mos7840_port;\r\nstruct async_icount *icount;\r\nmos7840_port = port;\r\nicount = &mos7840_port->icount;\r\nif (new_msr &\r\n(MOS_MSR_DELTA_CTS | MOS_MSR_DELTA_DSR | MOS_MSR_DELTA_RI |\r\nMOS_MSR_DELTA_CD)) {\r\nicount = &mos7840_port->icount;\r\nif (new_msr & MOS_MSR_DELTA_CTS) {\r\nicount->cts++;\r\nsmp_wmb();\r\n}\r\nif (new_msr & MOS_MSR_DELTA_DSR) {\r\nicount->dsr++;\r\nsmp_wmb();\r\n}\r\nif (new_msr & MOS_MSR_DELTA_CD) {\r\nicount->dcd++;\r\nsmp_wmb();\r\n}\r\nif (new_msr & MOS_MSR_DELTA_RI) {\r\nicount->rng++;\r\nsmp_wmb();\r\n}\r\n}\r\n}\r\nstatic void mos7840_handle_new_lsr(struct moschip_port *port, __u8 new_lsr)\r\n{\r\nstruct async_icount *icount;\r\ndbg("%s - %02x", __func__, new_lsr);\r\nif (new_lsr & SERIAL_LSR_BI) {\r\nnew_lsr &= (__u8) (SERIAL_LSR_OE | SERIAL_LSR_BI);\r\n}\r\nicount = &port->icount;\r\nif (new_lsr & SERIAL_LSR_BI) {\r\nicount->brk++;\r\nsmp_wmb();\r\n}\r\nif (new_lsr & SERIAL_LSR_OE) {\r\nicount->overrun++;\r\nsmp_wmb();\r\n}\r\nif (new_lsr & SERIAL_LSR_PE) {\r\nicount->parity++;\r\nsmp_wmb();\r\n}\r\nif (new_lsr & SERIAL_LSR_FE) {\r\nicount->frame++;\r\nsmp_wmb();\r\n}\r\n}\r\nstatic void mos7840_control_callback(struct urb *urb)\r\n{\r\nunsigned char *data;\r\nstruct moschip_port *mos7840_port;\r\n__u8 regval = 0x0;\r\nint result = 0;\r\nint status = urb->status;\r\nmos7840_port = urb->context;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d", __func__,\r\nstatus);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d", __func__,\r\nstatus);\r\ngoto exit;\r\n}\r\ndbg("%s urb buffer size is %d", __func__, urb->actual_length);\r\ndbg("%s mos7840_port->MsrLsr is %d port %d", __func__,\r\nmos7840_port->MsrLsr, mos7840_port->port_num);\r\ndata = urb->transfer_buffer;\r\nregval = (__u8) data[0];\r\ndbg("%s data is %x", __func__, regval);\r\nif (mos7840_port->MsrLsr == 0)\r\nmos7840_handle_new_msr(mos7840_port, regval);\r\nelse if (mos7840_port->MsrLsr == 1)\r\nmos7840_handle_new_lsr(mos7840_port, regval);\r\nexit:\r\nspin_lock(&mos7840_port->pool_lock);\r\nif (!mos7840_port->zombie)\r\nresult = usb_submit_urb(mos7840_port->int_urb, GFP_ATOMIC);\r\nspin_unlock(&mos7840_port->pool_lock);\r\nif (result) {\r\ndev_err(&urb->dev->dev,\r\n"%s - Error %d submitting interrupt urb\n",\r\n__func__, result);\r\n}\r\n}\r\nstatic int mos7840_get_reg(struct moschip_port *mcs, __u16 Wval, __u16 reg,\r\n__u16 *val)\r\n{\r\nstruct usb_device *dev = mcs->port->serial->dev;\r\nstruct usb_ctrlrequest *dr = mcs->dr;\r\nunsigned char *buffer = mcs->ctrl_buf;\r\nint ret;\r\ndr->bRequestType = MCS_RD_RTYPE;\r\ndr->bRequest = MCS_RDREQ;\r\ndr->wValue = cpu_to_le16(Wval);\r\ndr->wIndex = cpu_to_le16(reg);\r\ndr->wLength = cpu_to_le16(2);\r\nusb_fill_control_urb(mcs->control_urb, dev, usb_rcvctrlpipe(dev, 0),\r\n(unsigned char *)dr, buffer, 2,\r\nmos7840_control_callback, mcs);\r\nmcs->control_urb->transfer_buffer_length = 2;\r\nret = usb_submit_urb(mcs->control_urb, GFP_ATOMIC);\r\nreturn ret;\r\n}\r\nstatic void mos7840_interrupt_callback(struct urb *urb)\r\n{\r\nint result;\r\nint length;\r\nstruct moschip_port *mos7840_port;\r\nstruct usb_serial *serial;\r\n__u16 Data;\r\nunsigned char *data;\r\n__u8 sp[5], st;\r\nint i, rv = 0;\r\n__u16 wval, wreg = 0;\r\nint status = urb->status;\r\ndbg("%s", " : Entering");\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d", __func__,\r\nstatus);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d", __func__,\r\nstatus);\r\ngoto exit;\r\n}\r\nlength = urb->actual_length;\r\ndata = urb->transfer_buffer;\r\nserial = urb->context;\r\nif (length && length > 5) {\r\ndbg("%s", "Wrong data !!!");\r\nreturn;\r\n}\r\nsp[0] = (__u8) data[0];\r\nsp[1] = (__u8) data[1];\r\nsp[2] = (__u8) data[2];\r\nsp[3] = (__u8) data[3];\r\nst = (__u8) data[4];\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nmos7840_port = mos7840_get_port_private(serial->port[i]);\r\nwval =\r\n(((__u16) serial->port[i]->number -\r\n(__u16) (serial->minor)) + 1) << 8;\r\nif (mos7840_port->open) {\r\nif (sp[i] & 0x01) {\r\ndbg("SP%d No Interrupt !!!", i);\r\n} else {\r\nswitch (sp[i] & 0x0f) {\r\ncase SERIAL_IIR_RLS:\r\ndbg("Serial Port %d: Receiver status error or ", i);\r\ndbg("address bit detected in 9-bit mode");\r\nmos7840_port->MsrLsr = 1;\r\nwreg = LINE_STATUS_REGISTER;\r\nbreak;\r\ncase SERIAL_IIR_MS:\r\ndbg("Serial Port %d: Modem status change", i);\r\nmos7840_port->MsrLsr = 0;\r\nwreg = MODEM_STATUS_REGISTER;\r\nbreak;\r\n}\r\nspin_lock(&mos7840_port->pool_lock);\r\nif (!mos7840_port->zombie) {\r\nrv = mos7840_get_reg(mos7840_port, wval, wreg, &Data);\r\n} else {\r\nspin_unlock(&mos7840_port->pool_lock);\r\nreturn;\r\n}\r\nspin_unlock(&mos7840_port->pool_lock);\r\n}\r\n}\r\n}\r\nif (!(rv < 0))\r\nreturn;\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err(&urb->dev->dev,\r\n"%s - Error %d submitting interrupt urb\n",\r\n__func__, result);\r\n}\r\n}\r\nstatic int mos7840_port_paranoia_check(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port) {\r\ndbg("%s - port == NULL", function);\r\nreturn -1;\r\n}\r\nif (!port->serial) {\r\ndbg("%s - port->serial == NULL", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mos7840_serial_paranoia_check(struct usb_serial *serial,\r\nconst char *function)\r\n{\r\nif (!serial) {\r\ndbg("%s - serial == NULL", function);\r\nreturn -1;\r\n}\r\nif (!serial->type) {\r\ndbg("%s - serial->type == NULL!", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct usb_serial *mos7840_get_usb_serial(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port ||\r\nmos7840_port_paranoia_check(port, function) ||\r\nmos7840_serial_paranoia_check(port->serial, function)) {\r\nreturn NULL;\r\n}\r\nreturn port->serial;\r\n}\r\nstatic void mos7840_bulk_in_callback(struct urb *urb)\r\n{\r\nint retval;\r\nunsigned char *data;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct moschip_port *mos7840_port;\r\nstruct tty_struct *tty;\r\nint status = urb->status;\r\nmos7840_port = urb->context;\r\nif (!mos7840_port) {\r\ndbg("%s", "NULL mos7840_port pointer");\r\nreturn;\r\n}\r\nif (status) {\r\ndbg("nonzero read bulk status received: %d", status);\r\nmos7840_port->read_urb_busy = false;\r\nreturn;\r\n}\r\nport = (struct usb_serial_port *)mos7840_port->port;\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Port Paranoia failed");\r\nmos7840_port->read_urb_busy = false;\r\nreturn;\r\n}\r\nserial = mos7840_get_usb_serial(port, __func__);\r\nif (!serial) {\r\ndbg("%s", "Bad serial pointer");\r\nmos7840_port->read_urb_busy = false;\r\nreturn;\r\n}\r\ndbg("%s", "Entering... ");\r\ndata = urb->transfer_buffer;\r\ndbg("%s", "Entering ...........");\r\nif (urb->actual_length) {\r\ntty = tty_port_tty_get(&mos7840_port->port->port);\r\nif (tty) {\r\ntty_insert_flip_string(tty, data, urb->actual_length);\r\ndbg(" %s ", data);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\nmos7840_port->icount.rx += urb->actual_length;\r\nsmp_wmb();\r\ndbg("mos7840_port->icount.rx is %d:",\r\nmos7840_port->icount.rx);\r\n}\r\nif (!mos7840_port->read_urb) {\r\ndbg("%s", "URB KILLED !!!");\r\nmos7840_port->read_urb_busy = false;\r\nreturn;\r\n}\r\nmos7840_port->read_urb->dev = serial->dev;\r\nmos7840_port->read_urb_busy = true;\r\nretval = usb_submit_urb(mos7840_port->read_urb, GFP_ATOMIC);\r\nif (retval) {\r\ndbg("usb_submit_urb(read bulk) failed, retval = %d", retval);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\n}\r\nstatic void mos7840_bulk_out_data_callback(struct urb *urb)\r\n{\r\nstruct moschip_port *mos7840_port;\r\nstruct tty_struct *tty;\r\nint status = urb->status;\r\nint i;\r\nmos7840_port = urb->context;\r\nspin_lock(&mos7840_port->pool_lock);\r\nfor (i = 0; i < NUM_URBS; i++) {\r\nif (urb == mos7840_port->write_urb_pool[i]) {\r\nmos7840_port->busy[i] = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&mos7840_port->pool_lock);\r\nif (status) {\r\ndbg("nonzero write bulk status received:%d", status);\r\nreturn;\r\n}\r\nif (mos7840_port_paranoia_check(mos7840_port->port, __func__)) {\r\ndbg("%s", "Port Paranoia failed");\r\nreturn;\r\n}\r\ndbg("%s", "Entering .........");\r\ntty = tty_port_tty_get(&mos7840_port->port->port);\r\nif (tty && mos7840_port->open)\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int mos7840_serial_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn 1;\r\n}\r\nstatic int mos7840_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint response;\r\nint j;\r\nstruct usb_serial *serial;\r\nstruct urb *urb;\r\n__u16 Data;\r\nint status;\r\nstruct moschip_port *mos7840_port;\r\nstruct moschip_port *port0;\r\ndbg ("%s enter", __func__);\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Port Paranoia failed");\r\nreturn -ENODEV;\r\n}\r\nserial = port->serial;\r\nif (mos7840_serial_paranoia_check(serial, __func__)) {\r\ndbg("%s", "Serial Paranoia failed");\r\nreturn -ENODEV;\r\n}\r\nmos7840_port = mos7840_get_port_private(port);\r\nport0 = mos7840_get_port_private(serial->port[0]);\r\nif (mos7840_port == NULL || port0 == NULL)\r\nreturn -ENODEV;\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nport0->open_ports++;\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nmos7840_port->write_urb_pool[j] = urb;\r\nif (urb == NULL) {\r\ndev_err(&port->dev, "No more urbs???\n");\r\ncontinue;\r\n}\r\nurb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (!urb->transfer_buffer) {\r\nusb_free_urb(urb);\r\nmos7840_port->write_urb_pool[j] = NULL;\r\ndev_err(&port->dev,\r\n"%s-out of memory for urb buffers.\n",\r\n__func__);\r\ncontinue;\r\n}\r\n}\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset, &Data);\r\nif (status < 0) {\r\ndbg("Reading Spreg failed");\r\nreturn -1;\r\n}\r\nData |= 0x80;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\r\nif (status < 0) {\r\ndbg("writing Spreg failed");\r\nreturn -1;\r\n}\r\nData &= ~0x80;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\r\nif (status < 0) {\r\ndbg("writing Spreg failed");\r\nreturn -1;\r\n}\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\r\n&Data);\r\nif (status < 0) {\r\ndbg("Reading Controlreg failed");\r\nreturn -1;\r\n}\r\nData |= 0x08;\r\nData |= 0x20;\r\nstatus = mos7840_set_reg_sync(port,\r\nmos7840_port->ControlRegOffset, Data);\r\nif (status < 0) {\r\ndbg("writing Controlreg failed");\r\nreturn -1;\r\n}\r\nData = 0x00;\r\nstatus = mos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nif (status < 0) {\r\ndbg("disabling interrupts failed");\r\nreturn -1;\r\n}\r\nData = 0x00;\r\nstatus = mos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\r\nif (status < 0) {\r\ndbg("Writing FIFO_CONTROL_REGISTER failed");\r\nreturn -1;\r\n}\r\nData = 0xcf;\r\nstatus = mos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\r\nif (status < 0) {\r\ndbg("Writing FIFO_CONTROL_REGISTER failed");\r\nreturn -1;\r\n}\r\nData = 0x03;\r\nstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nmos7840_port->shadowLCR = Data;\r\nData = 0x0b;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nmos7840_port->shadowMCR = Data;\r\nData = 0x00;\r\nstatus = mos7840_get_uart_reg(port, LINE_CONTROL_REGISTER, &Data);\r\nmos7840_port->shadowLCR = Data;\r\nData |= SERIAL_LCR_DLAB;\r\nstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nData = 0x0c;\r\nstatus = mos7840_set_uart_reg(port, DIVISOR_LATCH_LSB, Data);\r\nData = 0x0;\r\nstatus = mos7840_set_uart_reg(port, DIVISOR_LATCH_MSB, Data);\r\nData = 0x00;\r\nstatus = mos7840_get_uart_reg(port, LINE_CONTROL_REGISTER, &Data);\r\nData = Data & ~SERIAL_LCR_DLAB;\r\nstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nmos7840_port->shadowLCR = Data;\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset, &Data);\r\nData = Data | 0x0c;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\r\nData = Data & ~0x0c;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\r\nData = 0x0c;\r\nstatus = mos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\r\n&Data);\r\nData = Data & ~0x20;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->ControlRegOffset,\r\nData);\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\r\n&Data);\r\nData = Data | 0x10;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->ControlRegOffset,\r\nData);\r\nif (port0->open_ports == 1) {\r\nif (serial->port[0]->interrupt_in_buffer == NULL) {\r\nusb_fill_int_urb(serial->port[0]->interrupt_in_urb,\r\nserial->dev,\r\nusb_rcvintpipe(serial->dev,\r\nserial->port[0]->interrupt_in_endpointAddress),\r\nserial->port[0]->interrupt_in_buffer,\r\nserial->port[0]->interrupt_in_urb->\r\ntransfer_buffer_length,\r\nmos7840_interrupt_callback,\r\nserial,\r\nserial->port[0]->interrupt_in_urb->interval);\r\nresponse =\r\nusb_submit_urb(serial->port[0]->interrupt_in_urb,\r\nGFP_KERNEL);\r\nif (response) {\r\ndev_err(&port->dev, "%s - Error %d submitting "\r\n"interrupt urb\n", __func__, response);\r\n}\r\n}\r\n}\r\ndbg("port number is %d", port->number);\r\ndbg("serial number is %d", port->serial->minor);\r\ndbg("Bulkin endpoint is %d", port->bulk_in_endpointAddress);\r\ndbg("BulkOut endpoint is %d", port->bulk_out_endpointAddress);\r\ndbg("Interrupt endpoint is %d", port->interrupt_in_endpointAddress);\r\ndbg("port's number in the device is %d", mos7840_port->port_num);\r\nmos7840_port->read_urb = port->read_urb;\r\nusb_fill_bulk_urb(mos7840_port->read_urb,\r\nserial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->bulk_in_buffer,\r\nmos7840_port->read_urb->transfer_buffer_length,\r\nmos7840_bulk_in_callback, mos7840_port);\r\ndbg("mos7840_open: bulkin endpoint is %d",\r\nport->bulk_in_endpointAddress);\r\nmos7840_port->read_urb_busy = true;\r\nresponse = usb_submit_urb(mos7840_port->read_urb, GFP_KERNEL);\r\nif (response) {\r\ndev_err(&port->dev, "%s - Error %d submitting control urb\n",\r\n__func__, response);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\ninit_waitqueue_head(&mos7840_port->wait_chase);\r\ninit_waitqueue_head(&mos7840_port->delta_msr_wait);\r\nmemset(&(mos7840_port->icount), 0x00, sizeof(mos7840_port->icount));\r\nmos7840_port->shadowMCR = MCR_MASTER_IE;\r\nmos7840_port->open = 1;\r\nmos7840_port->icount.tx = 0;\r\nmos7840_port->icount.rx = 0;\r\ndbg("usb_serial serial:%p mos7840_port:%p\n usb_serial_port port:%p",\r\nserial, mos7840_port, port);\r\ndbg ("%s leave", __func__);\r\nreturn 0;\r\n}\r\nstatic int mos7840_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint i;\r\nint chars = 0;\r\nunsigned long flags;\r\nstruct moschip_port *mos7840_port;\r\ndbg("%s", " mos7840_chars_in_buffer:entering ...........");\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port");\r\nreturn 0;\r\n}\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL) {\r\ndbg("%s", "mos7840_break:leaving ...........");\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&mos7840_port->pool_lock, flags);\r\nfor (i = 0; i < NUM_URBS; ++i)\r\nif (mos7840_port->busy[i])\r\nchars += URB_TRANSFER_BUFFER_SIZE;\r\nspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\r\ndbg("%s - returns %d", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic void mos7840_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7840_port;\r\nstruct moschip_port *port0;\r\nint j;\r\n__u16 Data;\r\ndbg("%s", "mos7840_close:entering...");\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Port Paranoia failed");\r\nreturn;\r\n}\r\nserial = mos7840_get_usb_serial(port, __func__);\r\nif (!serial) {\r\ndbg("%s", "Serial Paranoia failed");\r\nreturn;\r\n}\r\nmos7840_port = mos7840_get_port_private(port);\r\nport0 = mos7840_get_port_private(serial->port[0]);\r\nif (mos7840_port == NULL || port0 == NULL)\r\nreturn;\r\nfor (j = 0; j < NUM_URBS; ++j)\r\nusb_kill_urb(mos7840_port->write_urb_pool[j]);\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nif (mos7840_port->write_urb_pool[j]) {\r\nif (mos7840_port->write_urb_pool[j]->transfer_buffer)\r\nkfree(mos7840_port->write_urb_pool[j]->\r\ntransfer_buffer);\r\nusb_free_urb(mos7840_port->write_urb_pool[j]);\r\n}\r\n}\r\nif (serial->dev) {\r\nif (mos7840_port->write_urb) {\r\ndbg("%s", "Shutdown bulk write");\r\nusb_kill_urb(mos7840_port->write_urb);\r\n}\r\nif (mos7840_port->read_urb) {\r\ndbg("%s", "Shutdown bulk read");\r\nusb_kill_urb(mos7840_port->read_urb);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\nif ((&mos7840_port->control_urb)) {\r\ndbg("%s", "Shutdown control read");\r\n}\r\n}\r\nport0->open_ports--;\r\ndbg("mos7840_num_open_ports in close%d:in port%d",\r\nport0->open_ports, port->number);\r\nif (port0->open_ports == 0) {\r\nif (serial->port[0]->interrupt_in_urb) {\r\ndbg("%s", "Shutdown interrupt_in_urb");\r\nusb_kill_urb(serial->port[0]->interrupt_in_urb);\r\n}\r\n}\r\nif (mos7840_port->write_urb) {\r\nif (mos7840_port->write_urb->transfer_buffer != NULL)\r\nkfree(mos7840_port->write_urb->transfer_buffer);\r\nusb_free_urb(mos7840_port->write_urb);\r\n}\r\nData = 0x0;\r\nmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nData = 0x00;\r\nmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nmos7840_port->open = 0;\r\ndbg("%s", "Leaving ............");\r\n}\r\nstatic void mos7840_block_until_chase_response(struct tty_struct *tty,\r\nstruct moschip_port *mos7840_port)\r\n{\r\nint timeout = 1 * HZ;\r\nint wait = 10;\r\nint count;\r\nwhile (1) {\r\ncount = mos7840_chars_in_buffer(tty);\r\nif (count <= 0)\r\nreturn;\r\ninterruptible_sleep_on_timeout(&mos7840_port->wait_chase,\r\ntimeout);\r\nwait--;\r\nif (wait == 0) {\r\ndbg("%s - TIMEOUT", __func__);\r\nreturn;\r\n} else {\r\nwait = 10;\r\n}\r\n}\r\n}\r\nstatic void mos7840_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned char data;\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7840_port;\r\ndbg("%s", "Entering ...........");\r\ndbg("mos7840_break: Start");\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Port Paranoia failed");\r\nreturn;\r\n}\r\nserial = mos7840_get_usb_serial(port, __func__);\r\nif (!serial) {\r\ndbg("%s", "Serial Paranoia failed");\r\nreturn;\r\n}\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn;\r\nif (serial->dev)\r\nmos7840_block_until_chase_response(tty, mos7840_port);\r\nif (break_state == -1)\r\ndata = mos7840_port->shadowLCR | LCR_SET_BREAK;\r\nelse\r\ndata = mos7840_port->shadowLCR & ~LCR_SET_BREAK;\r\nmos7840_port->shadowLCR = data;\r\ndbg("mcs7840_break mos7840_port->shadowLCR is %x",\r\nmos7840_port->shadowLCR);\r\nmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER,\r\nmos7840_port->shadowLCR);\r\n}\r\nstatic int mos7840_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint i;\r\nint room = 0;\r\nunsigned long flags;\r\nstruct moschip_port *mos7840_port;\r\ndbg("%s", " mos7840_write_room:entering ...........");\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port");\r\ndbg("%s", " mos7840_write_room:leaving ...........");\r\nreturn -1;\r\n}\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL) {\r\ndbg("%s", "mos7840_break:leaving ...........");\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&mos7840_port->pool_lock, flags);\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (!mos7840_port->busy[i])\r\nroom += URB_TRANSFER_BUFFER_SIZE;\r\n}\r\nspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\r\nroom = (room == 0) ? 0 : room - URB_TRANSFER_BUFFER_SIZE + 1;\r\ndbg("%s - returns %d", __func__, room);\r\nreturn room;\r\n}\r\nstatic int mos7840_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *data, int count)\r\n{\r\nint status;\r\nint i;\r\nint bytes_sent = 0;\r\nint transfer_size;\r\nunsigned long flags;\r\nstruct moschip_port *mos7840_port;\r\nstruct usb_serial *serial;\r\nstruct urb *urb;\r\nconst unsigned char *current_position = data;\r\nunsigned char *data1;\r\ndbg("%s", "entering ...........");\r\n#ifdef NOTMOS7840\r\nData = 0x00;\r\nstatus = mos7840_get_uart_reg(port, LINE_CONTROL_REGISTER, &Data);\r\nmos7840_port->shadowLCR = Data;\r\ndbg("mos7840_write: LINE_CONTROL_REGISTER is %x", Data);\r\ndbg("mos7840_write: mos7840_port->shadowLCR is %x",\r\nmos7840_port->shadowLCR);\r\nData |= SERIAL_LCR_DLAB;\r\nstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nData = 0x00;\r\nstatus = mos7840_get_uart_reg(port, DIVISOR_LATCH_LSB, &Data);\r\ndbg("mos7840_write:DLL value is %x", Data);\r\nData = 0x0;\r\nstatus = mos7840_get_uart_reg(port, DIVISOR_LATCH_MSB, &Data);\r\ndbg("mos7840_write:DLM value is %x", Data);\r\nData = Data & ~SERIAL_LCR_DLAB;\r\ndbg("mos7840_write: mos7840_port->shadowLCR is %x",\r\nmos7840_port->shadowLCR);\r\nstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\n#endif\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Port Paranoia failed");\r\nreturn -1;\r\n}\r\nserial = port->serial;\r\nif (mos7840_serial_paranoia_check(serial, __func__)) {\r\ndbg("%s", "Serial Paranoia failed");\r\nreturn -1;\r\n}\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL) {\r\ndbg("%s", "mos7840_port is NULL");\r\nreturn -1;\r\n}\r\nurb = NULL;\r\nspin_lock_irqsave(&mos7840_port->pool_lock, flags);\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (!mos7840_port->busy[i]) {\r\nmos7840_port->busy[i] = 1;\r\nurb = mos7840_port->write_urb_pool[i];\r\ndbg("URB:%d", i);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\r\nif (urb == NULL) {\r\ndbg("%s - no more free urbs", __func__);\r\ngoto exit;\r\n}\r\nif (urb->transfer_buffer == NULL) {\r\nurb->transfer_buffer =\r\nkmalloc(URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);\r\nif (urb->transfer_buffer == NULL) {\r\ndev_err(&port->dev, "%s no more kernel memory...\n",\r\n__func__);\r\ngoto exit;\r\n}\r\n}\r\ntransfer_size = min(count, URB_TRANSFER_BUFFER_SIZE);\r\nmemcpy(urb->transfer_buffer, current_position, transfer_size);\r\nusb_fill_bulk_urb(urb,\r\nserial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->bulk_out_endpointAddress),\r\nurb->transfer_buffer,\r\ntransfer_size,\r\nmos7840_bulk_out_data_callback, mos7840_port);\r\ndata1 = urb->transfer_buffer;\r\ndbg("bulkout endpoint is %d", port->bulk_out_endpointAddress);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\nmos7840_port->busy[i] = 0;\r\ndev_err(&port->dev, "%s - usb_submit_urb(write bulk) failed "\r\n"with status = %d\n", __func__, status);\r\nbytes_sent = status;\r\ngoto exit;\r\n}\r\nbytes_sent = transfer_size;\r\nmos7840_port->icount.tx += transfer_size;\r\nsmp_wmb();\r\ndbg("mos7840_port->icount.tx is %d:", mos7840_port->icount.tx);\r\nexit:\r\nreturn bytes_sent;\r\n}\r\nstatic void mos7840_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7840_port;\r\nint status;\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port");\r\nreturn;\r\n}\r\ndbg("- port %d", port->number);\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn;\r\nif (!mos7840_port->open) {\r\ndbg("%s", "port not opened");\r\nreturn;\r\n}\r\ndbg("%s", "Entering ..........");\r\nif (I_IXOFF(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nstatus = mos7840_write(tty, port, &stop_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\nmos7840_port->shadowMCR &= ~MCR_RTS;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\r\nmos7840_port->shadowMCR);\r\nif (status < 0)\r\nreturn;\r\n}\r\n}\r\nstatic void mos7840_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint status;\r\nstruct moschip_port *mos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port");\r\nreturn;\r\n}\r\nif (mos7840_port == NULL)\r\nreturn;\r\nif (!mos7840_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\ndbg("%s", "Entering ..........");\r\nif (I_IXOFF(tty)) {\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus = mos7840_write(tty, port, &start_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\nmos7840_port->shadowMCR |= MCR_RTS;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\r\nmos7840_port->shadowMCR);\r\nif (status < 0)\r\nreturn;\r\n}\r\n}\r\nstatic int mos7840_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7840_port;\r\nunsigned int result;\r\n__u16 msr;\r\n__u16 mcr;\r\nint status;\r\nmos7840_port = mos7840_get_port_private(port);\r\ndbg("%s - port %d", __func__, port->number);\r\nif (mos7840_port == NULL)\r\nreturn -ENODEV;\r\nstatus = mos7840_get_uart_reg(port, MODEM_STATUS_REGISTER, &msr);\r\nstatus = mos7840_get_uart_reg(port, MODEM_CONTROL_REGISTER, &mcr);\r\nresult = ((mcr & MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((mcr & MCR_LOOPBACK) ? TIOCM_LOOP : 0)\r\n| ((msr & MOS7840_MSR_CTS) ? TIOCM_CTS : 0)\r\n| ((msr & MOS7840_MSR_CD) ? TIOCM_CAR : 0)\r\n| ((msr & MOS7840_MSR_RI) ? TIOCM_RI : 0)\r\n| ((msr & MOS7840_MSR_DSR) ? TIOCM_DSR : 0);\r\ndbg("%s - 0x%04X", __func__, result);\r\nreturn result;\r\n}\r\nstatic int mos7840_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7840_port;\r\nunsigned int mcr;\r\nint status;\r\ndbg("%s - port %d", __func__, port->number);\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn -ENODEV;\r\nmcr = mos7840_port->shadowMCR;\r\nif (clear & TIOCM_RTS)\r\nmcr &= ~MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\nmcr &= ~MCR_DTR;\r\nif (clear & TIOCM_LOOP)\r\nmcr &= ~MCR_LOOPBACK;\r\nif (set & TIOCM_RTS)\r\nmcr |= MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr |= MCR_DTR;\r\nif (set & TIOCM_LOOP)\r\nmcr |= MCR_LOOPBACK;\r\nmos7840_port->shadowMCR = mcr;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, mcr);\r\nif (status < 0) {\r\ndbg("setting MODEM_CONTROL_REGISTER Failed");\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mos7840_calc_baud_rate_divisor(int baudRate, int *divisor,\r\n__u16 *clk_sel_val)\r\n{\r\ndbg("%s - %d", __func__, baudRate);\r\nif (baudRate <= 115200) {\r\n*divisor = 115200 / baudRate;\r\n*clk_sel_val = 0x0;\r\n}\r\nif ((baudRate > 115200) && (baudRate <= 230400)) {\r\n*divisor = 230400 / baudRate;\r\n*clk_sel_val = 0x10;\r\n} else if ((baudRate > 230400) && (baudRate <= 403200)) {\r\n*divisor = 403200 / baudRate;\r\n*clk_sel_val = 0x20;\r\n} else if ((baudRate > 403200) && (baudRate <= 460800)) {\r\n*divisor = 460800 / baudRate;\r\n*clk_sel_val = 0x30;\r\n} else if ((baudRate > 460800) && (baudRate <= 806400)) {\r\n*divisor = 806400 / baudRate;\r\n*clk_sel_val = 0x40;\r\n} else if ((baudRate > 806400) && (baudRate <= 921600)) {\r\n*divisor = 921600 / baudRate;\r\n*clk_sel_val = 0x50;\r\n} else if ((baudRate > 921600) && (baudRate <= 1572864)) {\r\n*divisor = 1572864 / baudRate;\r\n*clk_sel_val = 0x60;\r\n} else if ((baudRate > 1572864) && (baudRate <= 3145728)) {\r\n*divisor = 3145728 / baudRate;\r\n*clk_sel_val = 0x70;\r\n}\r\nreturn 0;\r\n#ifdef NOTMCS7840\r\nfor (i = 0; i < ARRAY_SIZE(mos7840_divisor_table); i++) {\r\nif (mos7840_divisor_table[i].BaudRate == baudrate) {\r\n*divisor = mos7840_divisor_table[i].Divisor;\r\nreturn 0;\r\n}\r\n}\r\nif (baudrate > 75 && baudrate < 230400) {\r\ncustom = (__u16) (230400L / baudrate);\r\nround1 = (__u16) (2304000L / baudrate);\r\nround = (__u16) (round1 - (custom * 10));\r\nif (round > 4)\r\ncustom++;\r\n*divisor = custom;\r\ndbg(" Baud %d = %d", baudrate, custom);\r\nreturn 0;\r\n}\r\ndbg("%s", " Baud calculation Failed...");\r\nreturn -1;\r\n#endif\r\n}\r\nstatic int mos7840_send_cmd_write_baud_rate(struct moschip_port *mos7840_port,\r\nint baudRate)\r\n{\r\nint divisor = 0;\r\nint status;\r\n__u16 Data;\r\nunsigned char number;\r\n__u16 clk_sel_val;\r\nstruct usb_serial_port *port;\r\nif (mos7840_port == NULL)\r\nreturn -1;\r\nport = (struct usb_serial_port *)mos7840_port->port;\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port");\r\nreturn -1;\r\n}\r\nif (mos7840_serial_paranoia_check(port->serial, __func__)) {\r\ndbg("%s", "Invalid Serial");\r\nreturn -1;\r\n}\r\ndbg("%s", "Entering ..........");\r\nnumber = mos7840_port->port->number - mos7840_port->port->serial->minor;\r\ndbg("%s - port = %d, baud = %d", __func__,\r\nmos7840_port->port->number, baudRate);\r\nif (baudRate > 115200) {\r\n#ifdef HW_flow_control\r\nData = 0x2b;\r\nmos7840_port->shadowMCR = Data;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\r\nData);\r\nif (status < 0) {\r\ndbg("Writing spreg failed in set_serial_baud");\r\nreturn -1;\r\n}\r\n#endif\r\n} else {\r\n#ifdef HW_flow_control\r\n/ *setting h/w flow control bit to 0 */\r\nData = 0xb;\r\nmos7840_port->shadowMCR = Data;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\r\nData);\r\nif (status < 0) {\r\ndbg("Writing spreg failed in set_serial_baud");\r\nreturn -1;\r\n}\r\n#endif\r\n}\r\nif (1) {\r\nclk_sel_val = 0x0;\r\nData = 0x0;\r\nstatus = mos7840_calc_baud_rate_divisor(baudRate, &divisor,\r\n&clk_sel_val);\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset,\r\n&Data);\r\nif (status < 0) {\r\ndbg("reading spreg failed in set_serial_baud");\r\nreturn -1;\r\n}\r\nData = (Data & 0x8f) | clk_sel_val;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset,\r\nData);\r\nif (status < 0) {\r\ndbg("Writing spreg failed in set_serial_baud");\r\nreturn -1;\r\n}\r\nif (status) {\r\ndev_err(&port->dev, "%s - bad baud rate\n", __func__);\r\nreturn status;\r\n}\r\nData = mos7840_port->shadowLCR | SERIAL_LCR_DLAB;\r\nmos7840_port->shadowLCR = Data;\r\nmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nData = (unsigned char)(divisor & 0xff);\r\ndbg("set_serial_baud Value to write DLL is %x", Data);\r\nmos7840_set_uart_reg(port, DIVISOR_LATCH_LSB, Data);\r\nData = (unsigned char)((divisor & 0xff00) >> 8);\r\ndbg("set_serial_baud Value to write DLM is %x", Data);\r\nmos7840_set_uart_reg(port, DIVISOR_LATCH_MSB, Data);\r\nData = mos7840_port->shadowLCR & ~SERIAL_LCR_DLAB;\r\nmos7840_port->shadowLCR = Data;\r\nmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\n}\r\nreturn status;\r\n}\r\nstatic void mos7840_change_port_settings(struct tty_struct *tty,\r\nstruct moschip_port *mos7840_port, struct ktermios *old_termios)\r\n{\r\nint baud;\r\nunsigned cflag;\r\nunsigned iflag;\r\n__u8 lData;\r\n__u8 lParity;\r\n__u8 lStop;\r\nint status;\r\n__u16 Data;\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nif (mos7840_port == NULL)\r\nreturn;\r\nport = (struct usb_serial_port *)mos7840_port->port;\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port");\r\nreturn;\r\n}\r\nif (mos7840_serial_paranoia_check(port->serial, __func__)) {\r\ndbg("%s", "Invalid Serial");\r\nreturn;\r\n}\r\nserial = port->serial;\r\ndbg("%s - port %d", __func__, mos7840_port->port->number);\r\nif (!mos7840_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\ndbg("%s", "Entering ..........");\r\nlData = LCR_BITS_8;\r\nlStop = LCR_STOP_1;\r\nlParity = LCR_PAR_NONE;\r\ncflag = tty->termios->c_cflag;\r\niflag = tty->termios->c_iflag;\r\nif (cflag & CSIZE) {\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nlData = LCR_BITS_5;\r\nbreak;\r\ncase CS6:\r\nlData = LCR_BITS_6;\r\nbreak;\r\ncase CS7:\r\nlData = LCR_BITS_7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nlData = LCR_BITS_8;\r\nbreak;\r\n}\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD) {\r\nlParity = LCR_PAR_ODD;\r\ndbg("%s - parity = odd", __func__);\r\n} else {\r\nlParity = LCR_PAR_EVEN;\r\ndbg("%s - parity = even", __func__);\r\n}\r\n} else {\r\ndbg("%s - parity = none", __func__);\r\n}\r\nif (cflag & CMSPAR)\r\nlParity = lParity | 0x20;\r\nif (cflag & CSTOPB) {\r\nlStop = LCR_STOP_2;\r\ndbg("%s - stop bits = 2", __func__);\r\n} else {\r\nlStop = LCR_STOP_1;\r\ndbg("%s - stop bits = 1", __func__);\r\n}\r\nmos7840_port->shadowLCR &=\r\n~(LCR_BITS_MASK | LCR_STOP_MASK | LCR_PAR_MASK);\r\nmos7840_port->shadowLCR |= (lData | lParity | lStop);\r\ndbg("mos7840_change_port_settings mos7840_port->shadowLCR is %x",\r\nmos7840_port->shadowLCR);\r\nData = 0x00;\r\nmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nData = 0x00;\r\nmos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\r\nData = 0xcf;\r\nmos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\r\nData = mos7840_port->shadowLCR;\r\nmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nData = 0x00b;\r\nmos7840_port->shadowMCR = Data;\r\nmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nData = 0x00b;\r\nmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nmos7840_port->shadowMCR = MCR_MASTER_IE;\r\nif (cflag & CBAUD)\r\nmos7840_port->shadowMCR |= (MCR_DTR | MCR_RTS);\r\nif (cflag & CRTSCTS)\r\nmos7840_port->shadowMCR |= (MCR_XON_ANY);\r\nelse\r\nmos7840_port->shadowMCR &= ~(MCR_XON_ANY);\r\nData = mos7840_port->shadowMCR;\r\nmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud) {\r\ndbg("%s", "Picked default baud...");\r\nbaud = 9600;\r\n}\r\ndbg("%s - baud rate = %d", __func__, baud);\r\nstatus = mos7840_send_cmd_write_baud_rate(mos7840_port, baud);\r\nData = 0x0c;\r\nmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nif (mos7840_port->read_urb_busy == false) {\r\nmos7840_port->read_urb->dev = serial->dev;\r\nmos7840_port->read_urb_busy = true;\r\nstatus = usb_submit_urb(mos7840_port->read_urb, GFP_ATOMIC);\r\nif (status) {\r\ndbg("usb_submit_urb(read bulk) failed, status = %d",\r\nstatus);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\n}\r\nwake_up(&mos7840_port->delta_msr_wait);\r\nmos7840_port->delta_msr_cond = 1;\r\ndbg("mos7840_change_port_settings mos7840_port->shadowLCR is End %x",\r\nmos7840_port->shadowLCR);\r\n}\r\nstatic void mos7840_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nint status;\r\nunsigned int cflag;\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7840_port;\r\ndbg("mos7840_set_termios: START");\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port");\r\nreturn;\r\n}\r\nserial = port->serial;\r\nif (mos7840_serial_paranoia_check(serial, __func__)) {\r\ndbg("%s", "Invalid Serial");\r\nreturn;\r\n}\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn;\r\nif (!mos7840_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\ndbg("%s", "setting termios - ");\r\ncflag = tty->termios->c_cflag;\r\ndbg("%s - clfag %08x iflag %08x", __func__,\r\ntty->termios->c_cflag, RELEVANT_IFLAG(tty->termios->c_iflag));\r\ndbg("%s - old clfag %08x old iflag %08x", __func__,\r\nold_termios->c_cflag, RELEVANT_IFLAG(old_termios->c_iflag));\r\ndbg("%s - port %d", __func__, port->number);\r\nmos7840_change_port_settings(tty, mos7840_port, old_termios);\r\nif (!mos7840_port->read_urb) {\r\ndbg("%s", "URB KILLED !!!!!");\r\nreturn;\r\n}\r\nif (mos7840_port->read_urb_busy == false) {\r\nmos7840_port->read_urb->dev = serial->dev;\r\nmos7840_port->read_urb_busy = true;\r\nstatus = usb_submit_urb(mos7840_port->read_urb, GFP_ATOMIC);\r\nif (status) {\r\ndbg("usb_submit_urb(read bulk) failed, status = %d",\r\nstatus);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\n}\r\n}\r\nstatic int mos7840_get_lsr_info(struct tty_struct *tty,\r\nunsigned int __user *value)\r\n{\r\nint count;\r\nunsigned int result = 0;\r\ncount = mos7840_chars_in_buffer(tty);\r\nif (count == 0) {\r\ndbg("%s -- Empty", __func__);\r\nresult = TIOCSER_TEMT;\r\n}\r\nif (copy_to_user(value, &result, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mos7840_get_serial_info(struct moschip_port *mos7840_port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (mos7840_port == NULL)\r\nreturn -1;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.line = mos7840_port->port->serial->minor;\r\ntmp.port = mos7840_port->port->number;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = NUM_URBS * URB_TRANSFER_BUFFER_SIZE;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5 * HZ;\r\ntmp.closing_wait = 30 * HZ;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mos7840_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7840_port;\r\nstruct async_icount cnow;\r\nmos7840_port = mos7840_get_port_private(port);\r\ncnow = mos7840_port->icount;\r\nsmp_rmb();\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\ndbg("%s (%d) TIOCGICOUNT RX=%d, TX=%d", __func__,\r\nport->number, icount->rx, icount->tx);\r\nreturn 0;\r\n}\r\nstatic int mos7840_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nstruct moschip_port *mos7840_port;\r\nstruct async_icount cnow;\r\nstruct async_icount cprev;\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port");\r\nreturn -1;\r\n}\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn -1;\r\ndbg("%s - port %d, cmd = 0x%x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCSERGETLSR:\r\ndbg("%s (%d) TIOCSERGETLSR", __func__, port->number);\r\nreturn mos7840_get_lsr_info(tty, argp);\r\nreturn 0;\r\ncase TIOCGSERIAL:\r\ndbg("%s (%d) TIOCGSERIAL", __func__, port->number);\r\nreturn mos7840_get_serial_info(mos7840_port, argp);\r\ncase TIOCSSERIAL:\r\ndbg("%s (%d) TIOCSSERIAL", __func__, port->number);\r\nbreak;\r\ncase TIOCMIWAIT:\r\ndbg("%s (%d) TIOCMIWAIT", __func__, port->number);\r\ncprev = mos7840_port->icount;\r\nwhile (1) {\r\nmos7840_port->delta_msr_cond = 0;\r\nwait_event_interruptible(mos7840_port->delta_msr_wait,\r\n(mos7840_port->\r\ndelta_msr_cond == 1));\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\ncnow = mos7840_port->icount;\r\nsmp_rmb();\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts)\r\nreturn -EIO;\r\nif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {\r\nreturn 0;\r\n}\r\ncprev = cnow;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int mos7840_calc_num_ports(struct usb_serial *serial)\r\n{\r\nint mos7840_num_ports = 0;\r\ndbg("numberofendpoints: cur %d, alt %d",\r\n(int)serial->interface->cur_altsetting->desc.bNumEndpoints,\r\n(int)serial->interface->altsetting->desc.bNumEndpoints);\r\nif (serial->interface->cur_altsetting->desc.bNumEndpoints == 5) {\r\nmos7840_num_ports = serial->num_ports = 2;\r\n} else if (serial->interface->cur_altsetting->desc.bNumEndpoints == 9) {\r\nserial->num_bulk_in = 4;\r\nserial->num_bulk_out = 4;\r\nmos7840_num_ports = serial->num_ports = 4;\r\n}\r\ndbg ("mos7840_num_ports = %d", mos7840_num_ports);\r\nreturn mos7840_num_ports;\r\n}\r\nstatic int mos7840_startup(struct usb_serial *serial)\r\n{\r\nstruct moschip_port *mos7840_port;\r\nstruct usb_device *dev;\r\nint i, status;\r\n__u16 Data;\r\ndbg("%s", "mos7840_startup :Entering..........");\r\nif (!serial) {\r\ndbg("%s", "Invalid Handler");\r\nreturn -1;\r\n}\r\ndev = serial->dev;\r\ndbg("%s", "Entering...");\r\ndbg ("mos7840_startup: serial = %p", serial);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\ndbg ("mos7840_startup: configuring port %d............", i);\r\nmos7840_port = kzalloc(sizeof(struct moschip_port), GFP_KERNEL);\r\nif (mos7840_port == NULL) {\r\ndev_err(&dev->dev, "%s - Out of memory\n", __func__);\r\nstatus = -ENOMEM;\r\ni--;\r\ngoto error;\r\n}\r\nmos7840_port->port = serial->port[i];\r\nmos7840_set_port_private(serial->port[i], mos7840_port);\r\nspin_lock_init(&mos7840_port->pool_lock);\r\nmos7840_port->port_num = i + 1;\r\ndbg ("serial->port[i]->number = %d", serial->port[i]->number);\r\ndbg ("serial->port[i]->serial->minor = %d", serial->port[i]->serial->minor);\r\ndbg ("mos7840_port->port_num = %d", mos7840_port->port_num);\r\ndbg ("serial->minor = %d", serial->minor);\r\nif (mos7840_port->port_num == 1) {\r\nmos7840_port->SpRegOffset = 0x0;\r\nmos7840_port->ControlRegOffset = 0x1;\r\nmos7840_port->DcrRegOffset = 0x4;\r\n} else if ((mos7840_port->port_num == 2)\r\n&& (serial->num_ports == 4)) {\r\nmos7840_port->SpRegOffset = 0x8;\r\nmos7840_port->ControlRegOffset = 0x9;\r\nmos7840_port->DcrRegOffset = 0x16;\r\n} else if ((mos7840_port->port_num == 2)\r\n&& (serial->num_ports == 2)) {\r\nmos7840_port->SpRegOffset = 0xa;\r\nmos7840_port->ControlRegOffset = 0xb;\r\nmos7840_port->DcrRegOffset = 0x19;\r\n} else if ((mos7840_port->port_num == 3)\r\n&& (serial->num_ports == 4)) {\r\nmos7840_port->SpRegOffset = 0xa;\r\nmos7840_port->ControlRegOffset = 0xb;\r\nmos7840_port->DcrRegOffset = 0x19;\r\n} else if ((mos7840_port->port_num == 4)\r\n&& (serial->num_ports == 4)) {\r\nmos7840_port->SpRegOffset = 0xc;\r\nmos7840_port->ControlRegOffset = 0xd;\r\nmos7840_port->DcrRegOffset = 0x1c;\r\n}\r\nmos7840_dump_serial_port(mos7840_port);\r\nmos7840_set_port_private(serial->port[i], mos7840_port);\r\nstatus = mos7840_get_reg_sync(serial->port[i],\r\nmos7840_port->ControlRegOffset, &Data);\r\nif (status < 0) {\r\ndbg("Reading ControlReg failed status-0x%x", status);\r\nbreak;\r\n} else\r\ndbg("ControlReg Reading success val is %x, status%d",\r\nData, status);\r\nData |= 0x08;\r\nData |= 0x04;\r\nstatus = mos7840_set_reg_sync(serial->port[i],\r\nmos7840_port->ControlRegOffset, Data);\r\nif (status < 0) {\r\ndbg("Writing ControlReg failed(rx_disable) status-0x%x", status);\r\nbreak;\r\n} else\r\ndbg("ControlReg Writing success(rx_disable) status%d",\r\nstatus);\r\nData = 0x01;\r\nstatus = mos7840_set_reg_sync(serial->port[i],\r\n(__u16) (mos7840_port->DcrRegOffset + 0), Data);\r\nif (status < 0) {\r\ndbg("Writing DCR0 failed status-0x%x", status);\r\nbreak;\r\n} else\r\ndbg("DCR0 Writing success status%d", status);\r\nData = 0x05;\r\nstatus = mos7840_set_reg_sync(serial->port[i],\r\n(__u16) (mos7840_port->DcrRegOffset + 1), Data);\r\nif (status < 0) {\r\ndbg("Writing DCR1 failed status-0x%x", status);\r\nbreak;\r\n} else\r\ndbg("DCR1 Writing success status%d", status);\r\nData = 0x24;\r\nstatus = mos7840_set_reg_sync(serial->port[i],\r\n(__u16) (mos7840_port->DcrRegOffset + 2), Data);\r\nif (status < 0) {\r\ndbg("Writing DCR2 failed status-0x%x", status);\r\nbreak;\r\n} else\r\ndbg("DCR2 Writing success status%d", status);\r\nData = 0x0;\r\nstatus = mos7840_set_reg_sync(serial->port[i],\r\nCLK_START_VALUE_REGISTER, Data);\r\nif (status < 0) {\r\ndbg("Writing CLK_START_VALUE_REGISTER failed status-0x%x", status);\r\nbreak;\r\n} else\r\ndbg("CLK_START_VALUE_REGISTER Writing success status%d", status);\r\nData = 0x20;\r\nstatus = mos7840_set_reg_sync(serial->port[i],\r\nCLK_MULTI_REGISTER, Data);\r\nif (status < 0) {\r\ndbg("Writing CLK_MULTI_REGISTER failed status-0x%x",\r\nstatus);\r\ngoto error;\r\n} else\r\ndbg("CLK_MULTI_REGISTER Writing success status%d",\r\nstatus);\r\nData = 0x00;\r\nstatus = mos7840_set_uart_reg(serial->port[i],\r\nSCRATCH_PAD_REGISTER, Data);\r\nif (status < 0) {\r\ndbg("Writing SCRATCH_PAD_REGISTER failed status-0x%x",\r\nstatus);\r\nbreak;\r\n} else\r\ndbg("SCRATCH_PAD_REGISTER Writing success status%d",\r\nstatus);\r\nif ((mos7840_port->port_num != 1)\r\n&& (serial->num_ports == 2)) {\r\nData = 0xff;\r\nstatus = mos7840_set_reg_sync(serial->port[i],\r\n(__u16) (ZLP_REG1 +\r\n((__u16)mos7840_port->port_num)), Data);\r\ndbg("ZLIP offset %x",\r\n(__u16) (ZLP_REG1 +\r\n((__u16) mos7840_port->port_num)));\r\nif (status < 0) {\r\ndbg("Writing ZLP_REG%d failed status-0x%x",\r\ni + 2, status);\r\nbreak;\r\n} else\r\ndbg("ZLP_REG%d Writing success status%d",\r\ni + 2, status);\r\n} else {\r\nData = 0xff;\r\nstatus = mos7840_set_reg_sync(serial->port[i],\r\n(__u16) (ZLP_REG1 +\r\n((__u16)mos7840_port->port_num) - 0x1), Data);\r\ndbg("ZLIP offset %x",\r\n(__u16) (ZLP_REG1 +\r\n((__u16) mos7840_port->port_num) - 0x1));\r\nif (status < 0) {\r\ndbg("Writing ZLP_REG%d failed status-0x%x",\r\ni + 1, status);\r\nbreak;\r\n} else\r\ndbg("ZLP_REG%d Writing success status%d",\r\ni + 1, status);\r\n}\r\nmos7840_port->control_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nmos7840_port->ctrl_buf = kmalloc(16, GFP_KERNEL);\r\nmos7840_port->dr = kmalloc(sizeof(struct usb_ctrlrequest),\r\nGFP_KERNEL);\r\nif (!mos7840_port->control_urb || !mos7840_port->ctrl_buf ||\r\n!mos7840_port->dr) {\r\nstatus = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\ndbg ("mos7840_startup: all ports configured...........");\r\nData = 0x0f;\r\nstatus = mos7840_set_reg_sync(serial->port[0], ZLP_REG5, Data);\r\nif (status < 0) {\r\ndbg("Writing ZLP_REG5 failed status-0x%x", status);\r\ngoto error;\r\n} else\r\ndbg("ZLP_REG5 Writing success status%d", status);\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\n(__u8) 0x03, 0x00, 0x01, 0x00, NULL, 0x00, 5 * HZ);\r\nreturn 0;\r\nerror:\r\nfor (; i >= 0; i--) {\r\nmos7840_port = mos7840_get_port_private(serial->port[i]);\r\nkfree(mos7840_port->dr);\r\nkfree(mos7840_port->ctrl_buf);\r\nusb_free_urb(mos7840_port->control_urb);\r\nkfree(mos7840_port);\r\nserial->port[i] = NULL;\r\n}\r\nreturn status;\r\n}\r\nstatic void mos7840_disconnect(struct usb_serial *serial)\r\n{\r\nint i;\r\nunsigned long flags;\r\nstruct moschip_port *mos7840_port;\r\ndbg("%s", " disconnect :entering..........");\r\nif (!serial) {\r\ndbg("%s", "Invalid Handler");\r\nreturn;\r\n}\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nmos7840_port = mos7840_get_port_private(serial->port[i]);\r\ndbg ("mos7840_port %d = %p", i, mos7840_port);\r\nif (mos7840_port) {\r\nspin_lock_irqsave(&mos7840_port->pool_lock, flags);\r\nmos7840_port->zombie = 1;\r\nspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\r\nusb_kill_urb(mos7840_port->control_urb);\r\n}\r\n}\r\ndbg("%s", "Thank u :: ");\r\n}\r\nstatic void mos7840_release(struct usb_serial *serial)\r\n{\r\nint i;\r\nstruct moschip_port *mos7840_port;\r\ndbg("%s", " release :entering..........");\r\nif (!serial) {\r\ndbg("%s", "Invalid Handler");\r\nreturn;\r\n}\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nmos7840_port = mos7840_get_port_private(serial->port[i]);\r\ndbg("mos7840_port %d = %p", i, mos7840_port);\r\nif (mos7840_port) {\r\nkfree(mos7840_port->ctrl_buf);\r\nkfree(mos7840_port->dr);\r\nkfree(mos7840_port);\r\n}\r\n}\r\ndbg("%s", "Thank u :: ");\r\n}\r\nstatic int __init moschip7840_init(void)\r\n{\r\nint retval;\r\ndbg("%s", " mos7840_init :entering..........");\r\nretval = usb_serial_register(&moschip7840_4port_device);\r\nif (retval)\r\ngoto failed_port_device_register;\r\ndbg("%s", "Entering...");\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nretval = usb_register(&io_driver);\r\nif (retval == 0) {\r\ndbg("%s", "Leaving...");\r\nreturn 0;\r\n}\r\nusb_serial_deregister(&moschip7840_4port_device);\r\nfailed_port_device_register:\r\nreturn retval;\r\n}\r\nstatic void __exit moschip7840_exit(void)\r\n{\r\ndbg("%s", " mos7840_exit :entering..........");\r\nusb_deregister(&io_driver);\r\nusb_serial_deregister(&moschip7840_4port_device);\r\ndbg("%s", "Entering...");\r\n}
