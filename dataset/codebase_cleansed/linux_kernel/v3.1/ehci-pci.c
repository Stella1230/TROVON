static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)\r\n{\r\nint retval;\r\nretval = pci_set_mwi(pdev);\r\nif (!retval)\r\nehci_dbg(ehci, "MWI active\n");\r\nreturn 0;\r\n}\r\nstatic int ehci_pci_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nstruct pci_dev *p_smbus;\r\nu8 rev;\r\nu32 temp;\r\nint retval;\r\nswitch (pdev->vendor) {\r\ncase PCI_VENDOR_ID_TOSHIBA_2:\r\nif (pdev->device == 0x01b5) {\r\n#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO\r\nehci->big_endian_mmio = 1;\r\n#else\r\nehci_warn(ehci,\r\n"unsupported big endian Toshiba quirk\n");\r\n#endif\r\n}\r\nbreak;\r\n}\r\nehci->caps = hcd->regs;\r\nehci->regs = hcd->regs +\r\nHC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\r\ndbg_hcs_params(ehci, "reset");\r\ndbg_hcc_params(ehci, "reset");\r\nswitch (pdev->vendor) {\r\ncase PCI_VENDOR_ID_NVIDIA:\r\nswitch (pdev->device) {\r\ncase 0x003c:\r\ncase 0x005b:\r\ncase 0x00d8:\r\ncase 0x00e8:\r\nif (pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(31)) < 0)\r\nehci_warn(ehci, "can't enable NVidia "\r\n"workaround for >2GB RAM\n");\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);\r\nretval = ehci_halt(ehci);\r\nif (retval)\r\nreturn retval;\r\nif ((pdev->vendor == PCI_VENDOR_ID_AMD && pdev->device == 0x7808) ||\r\n(pdev->vendor == PCI_VENDOR_ID_ATI && pdev->device == 0x4396)) {\r\nehci->use_dummy_qh = 1;\r\nehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI "\r\n"dummy qh workaround\n");\r\n}\r\nretval = ehci_init(hcd);\r\nif (retval)\r\nreturn retval;\r\nswitch (pdev->vendor) {\r\ncase PCI_VENDOR_ID_NEC:\r\nehci->need_io_watchdog = 0;\r\nbreak;\r\ncase PCI_VENDOR_ID_INTEL:\r\nehci->need_io_watchdog = 0;\r\nehci->fs_i_thresh = 1;\r\nif (pdev->device == 0x27cc) {\r\nehci->broken_periodic = 1;\r\nehci_info(ehci, "using broken periodic workaround\n");\r\n}\r\nif (pdev->device == 0x0806 || pdev->device == 0x0811\r\n|| pdev->device == 0x0829) {\r\nehci_info(ehci, "disable lpm for langwell/penwell\n");\r\nehci->has_lpm = 0;\r\n}\r\nif (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB) {\r\nhcd->has_tt = 1;\r\ntdi_reset(ehci);\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_TDI:\r\nif (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {\r\nhcd->has_tt = 1;\r\ntdi_reset(ehci);\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_AMD:\r\nif (usb_amd_find_chipset_info())\r\nehci->amd_pll_fix = 1;\r\nif (pdev->device == 0x7463) {\r\nehci_info(ehci, "ignoring AMD8111 (errata)\n");\r\nretval = -EIO;\r\ngoto done;\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_NVIDIA:\r\nswitch (pdev->device) {\r\ncase 0x0068:\r\nif (pdev->revision < 0xa4)\r\nehci->no_selective_suspend = 1;\r\nbreak;\r\ncase 0x0d9d:\r\nehci_info(ehci, "disable lpm/ppcd for nvidia mcp89");\r\nehci->has_lpm = 0;\r\nehci->has_ppcd = 0;\r\nehci->command &= ~CMD_PPCEE;\r\nbreak;\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_VIA:\r\nif (pdev->device == 0x3104 && (pdev->revision & 0xf0) == 0x60) {\r\nu8 tmp;\r\npci_read_config_byte(pdev, 0x4b, &tmp);\r\nif (tmp & 0x20)\r\nbreak;\r\npci_write_config_byte(pdev, 0x4b, tmp | 0x20);\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_ATI:\r\nif (usb_amd_find_chipset_info())\r\nehci->amd_pll_fix = 1;\r\nif ((pdev->device == 0x4386) || (pdev->device == 0x4396)) {\r\np_smbus = pci_get_device(PCI_VENDOR_ID_ATI,\r\nPCI_DEVICE_ID_ATI_SBX00_SMBUS,\r\nNULL);\r\nif (!p_smbus)\r\nbreak;\r\nrev = p_smbus->revision;\r\nif ((pdev->device == 0x4386) || (rev == 0x3a)\r\n|| (rev == 0x3b)) {\r\nu8 tmp;\r\nehci_info(ehci, "applying AMD SB600/SB700 USB "\r\n"freeze workaround\n");\r\npci_read_config_byte(pdev, 0x53, &tmp);\r\npci_write_config_byte(pdev, 0x53, tmp | (1<<3));\r\n}\r\npci_dev_put(p_smbus);\r\n}\r\nbreak;\r\n}\r\ntemp = pci_find_capability(pdev, 0x0a);\r\nif (temp) {\r\npci_read_config_dword(pdev, temp, &temp);\r\ntemp >>= 16;\r\nif ((temp & (3 << 13)) == (1 << 13)) {\r\ntemp &= 0x1fff;\r\nehci->debug = ehci_to_hcd(ehci)->regs + temp;\r\ntemp = ehci_readl(ehci, &ehci->debug->control);\r\nehci_info(ehci, "debug port %d%s\n",\r\nHCS_DEBUG_PORT(ehci->hcs_params),\r\n(temp & DBGP_ENABLED)\r\n? " IN USE"\r\n: "");\r\nif (!(temp & DBGP_ENABLED))\r\nehci->debug = NULL;\r\n}\r\n}\r\nehci_reset(ehci);\r\ntemp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);\r\ntemp &= 0x0f;\r\nif (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {\r\nehci_dbg(ehci, "bogus port configuration: "\r\n"cc=%d x pcc=%d < ports=%d\n",\r\nHCS_N_CC(ehci->hcs_params),\r\nHCS_N_PCC(ehci->hcs_params),\r\nHCS_N_PORTS(ehci->hcs_params));\r\nswitch (pdev->vendor) {\r\ncase 0x17a0:\r\ntemp |= (ehci->hcs_params & ~0xf);\r\nehci->hcs_params = temp;\r\nbreak;\r\ncase PCI_VENDOR_ID_NVIDIA:\r\nbreak;\r\n}\r\n}\r\npci_read_config_byte(pdev, 0x60, &ehci->sbrn);\r\nif (!device_can_wakeup(&pdev->dev)) {\r\nu16 port_wake;\r\npci_read_config_word(pdev, 0x62, &port_wake);\r\nif (port_wake & 0x0001) {\r\ndev_warn(&pdev->dev, "Enabling legacy PCI PM\n");\r\ndevice_set_wakeup_capable(&pdev->dev, 1);\r\n}\r\n}\r\n#ifdef CONFIG_USB_SUSPEND\r\nif (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))\r\nehci_warn(ehci, "selective suspend/wakeup unavailable\n");\r\n#endif\r\nehci_port_power(ehci, 1);\r\nretval = ehci_pci_reinit(ehci, pdev);\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int ehci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nunsigned long flags;\r\nint rc = 0;\r\nif (time_before(jiffies, ehci->next_statechange))\r\nmsleep(10);\r\nehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\n(void)ehci_readl(ehci, &ehci->regs->intr_enable);\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn rc;\r\n}\r\nstatic bool usb_is_intel_switchable_ehci(struct pci_dev *pdev)\r\n{\r\nreturn pdev->class == PCI_CLASS_SERIAL_USB_EHCI &&\r\npdev->vendor == PCI_VENDOR_ID_INTEL &&\r\npdev->device == 0x1E26;\r\n}\r\nstatic void ehci_enable_xhci_companion(void)\r\n{\r\nstruct pci_dev *companion = NULL;\r\nfor_each_pci_dev(companion) {\r\nif (!usb_is_intel_switchable_xhci(companion))\r\ncontinue;\r\nusb_enable_xhci_ports(companion);\r\nreturn;\r\n}\r\n}\r\nstatic int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nif (usb_is_intel_switchable_ehci(pdev))\r\nehci_enable_xhci_companion();\r\nif (time_before(jiffies, ehci->next_statechange))\r\nmsleep(100);\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nif (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&\r\n!hibernated) {\r\nint mask = INTR_MASK;\r\nehci_prepare_ports_for_controller_resume(ehci);\r\nif (!hcd->self.root_hub->do_remote_wakeup)\r\nmask &= ~STS_PCD;\r\nehci_writel(ehci, mask, &ehci->regs->intr_enable);\r\nehci_readl(ehci, &ehci->regs->intr_enable);\r\nreturn 0;\r\n}\r\nusb_root_hub_lost_power(hcd->self.root_hub);\r\n(void) ehci_halt(ehci);\r\n(void) ehci_reset(ehci);\r\n(void) ehci_pci_reinit(ehci, pdev);\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->reclaim)\r\nend_unlink_async(ehci);\r\nehci_work(ehci);\r\nspin_unlock_irq(&ehci->lock);\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\nehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);\r\nehci_readl(ehci, &ehci->regs->command);\r\nehci_port_power(ehci, 1);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nreturn 0;\r\n}\r\nstatic int ehci_update_device(struct usb_hcd *hcd, struct usb_device *udev)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint rc = 0;\r\nif (!udev->parent)\r\nrc = -1;\r\nif (ehci->has_lpm && !udev->parent->parent) {\r\nrc = ehci_lpm_set_da(ehci, udev->devnum, udev->portnum);\r\nif (!rc)\r\nrc = ehci_lpm_check(ehci, udev->portnum);\r\n}\r\nreturn rc;\r\n}
