static u_char au_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nu_char ret = readb(this->IO_ADDR_R);\r\nau_sync();\r\nreturn ret;\r\n}\r\nstatic void au_write_byte(struct mtd_info *mtd, u_char byte)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nwriteb(byte, this->IO_ADDR_W);\r\nau_sync();\r\n}\r\nstatic u_char au_read_byte16(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nu_char ret = (u_char) cpu_to_le16(readw(this->IO_ADDR_R));\r\nau_sync();\r\nreturn ret;\r\n}\r\nstatic void au_write_byte16(struct mtd_info *mtd, u_char byte)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nwritew(le16_to_cpu((u16) byte), this->IO_ADDR_W);\r\nau_sync();\r\n}\r\nstatic u16 au_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nu16 ret = readw(this->IO_ADDR_R);\r\nau_sync();\r\nreturn ret;\r\n}\r\nstatic void au_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i = 0; i < len; i++) {\r\nwriteb(buf[i], this->IO_ADDR_W);\r\nau_sync();\r\n}\r\n}\r\nstatic void au_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i = 0; i < len; i++) {\r\nbuf[i] = readb(this->IO_ADDR_R);\r\nau_sync();\r\n}\r\n}\r\nstatic int au_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i = 0; i < len; i++) {\r\nif (buf[i] != readb(this->IO_ADDR_R))\r\nreturn -EFAULT;\r\nau_sync();\r\n}\r\nreturn 0;\r\n}\r\nstatic void au_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++) {\r\nwritew(p[i], this->IO_ADDR_W);\r\nau_sync();\r\n}\r\n}\r\nstatic void au_read_buf16(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++) {\r\np[i] = readw(this->IO_ADDR_R);\r\nau_sync();\r\n}\r\n}\r\nstatic int au_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++) {\r\nif (p[i] != readw(this->IO_ADDR_R))\r\nreturn -EFAULT;\r\nau_sync();\r\n}\r\nreturn 0;\r\n}\r\nstatic void au1550_hwcontrol(struct mtd_info *mtd, int cmd)\r\n{\r\nregister struct nand_chip *this = mtd->priv;\r\nswitch (cmd) {\r\ncase NAND_CTL_SETCLE:\r\nthis->IO_ADDR_W = p_nand + MEM_STNAND_CMD;\r\nbreak;\r\ncase NAND_CTL_CLRCLE:\r\nthis->IO_ADDR_W = p_nand + MEM_STNAND_DATA;\r\nbreak;\r\ncase NAND_CTL_SETALE:\r\nthis->IO_ADDR_W = p_nand + MEM_STNAND_ADDR;\r\nbreak;\r\ncase NAND_CTL_CLRALE:\r\nthis->IO_ADDR_W = p_nand + MEM_STNAND_DATA;\r\nudelay(1);\r\nbreak;\r\ncase NAND_CTL_SETNCE:\r\nau_writel((1 << (4 + NAND_CS)), MEM_STNDCTL);\r\nbreak;\r\ncase NAND_CTL_CLRNCE:\r\nau_writel(0, MEM_STNDCTL);\r\nbreak;\r\n}\r\nthis->IO_ADDR_R = this->IO_ADDR_W;\r\nau_sync();\r\n}\r\nint au1550_device_ready(struct mtd_info *mtd)\r\n{\r\nint ret = (au_readl(MEM_STSTAT) & 0x1) ? 1 : 0;\r\nau_sync();\r\nreturn ret;\r\n}\r\nstatic void au1550_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\n}\r\nstatic void au1550_command(struct mtd_info *mtd, unsigned command, int column, int page_addr)\r\n{\r\nregister struct nand_chip *this = mtd->priv;\r\nint ce_override = 0, i;\r\nulong flags;\r\nau1550_hwcontrol(mtd, NAND_CTL_SETCLE);\r\nif (command == NAND_CMD_SEQIN) {\r\nint readcmd;\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nreadcmd = NAND_CMD_READOOB;\r\n} else if (column < 256) {\r\nreadcmd = NAND_CMD_READ0;\r\n} else {\r\ncolumn -= 256;\r\nreadcmd = NAND_CMD_READ1;\r\n}\r\nau1550_write_byte(mtd, readcmd);\r\n}\r\nau1550_write_byte(mtd, command);\r\nau1550_hwcontrol(mtd, NAND_CTL_CLRCLE);\r\nif (column != -1 || page_addr != -1) {\r\nau1550_hwcontrol(mtd, NAND_CTL_SETALE);\r\nif (column != -1) {\r\nif (this->options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nau1550_write_byte(mtd, column);\r\n}\r\nif (page_addr != -1) {\r\nau1550_write_byte(mtd, (u8)(page_addr & 0xff));\r\nif (command == NAND_CMD_READ0 ||\r\ncommand == NAND_CMD_READ1 ||\r\ncommand == NAND_CMD_READOOB) {\r\nce_override = 1;\r\nlocal_irq_save(flags);\r\nau1550_hwcontrol(mtd, NAND_CTL_SETNCE);\r\n}\r\nau1550_write_byte(mtd, (u8)(page_addr >> 8));\r\nif (this->chipsize > (32 << 20))\r\nau1550_write_byte(mtd, (u8)((page_addr >> 16) & 0x0f));\r\n}\r\nau1550_hwcontrol(mtd, NAND_CTL_CLRALE);\r\n}\r\nswitch (command) {\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_STATUS:\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READ1:\r\ncase NAND_CMD_READOOB:\r\nif (unlikely(!ce_override))\r\nbreak;\r\nndelay(100);\r\nfor (i = this->chip_delay; !this->dev_ready(mtd) && i > 0; --i)\r\nudelay(1);\r\nau1550_hwcontrol(mtd, NAND_CTL_CLRNCE);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nndelay(100);\r\nwhile(!this->dev_ready(mtd));\r\n}\r\nstatic int __init au1xxx_nand_init(void)\r\n{\r\nstruct nand_chip *this;\r\nu16 boot_swapboot = 0;\r\nint retval;\r\nu32 mem_staddr;\r\nu32 nand_phys;\r\nau1550_mtd = kzalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);\r\nif (!au1550_mtd) {\r\nprintk("Unable to allocate NAND MTD dev structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nthis = (struct nand_chip *)(&au1550_mtd[1]);\r\nau1550_mtd->priv = this;\r\nau1550_mtd->owner = THIS_MODULE;\r\nau_writel(0, MEM_STNDCTL);\r\n#ifdef CONFIG_MIPS_PB1550\r\ngpio_direction_input(206);\r\nboot_swapboot = (au_readl(MEM_STSTAT) & (0x7 << 1)) | ((bcsr_read(BCSR_STATUS) >> 6) & 0x1);\r\nswitch (boot_swapboot) {\r\ncase 0:\r\ncase 2:\r\ncase 8:\r\ncase 0xC:\r\ncase 0xD:\r\nnand_width = 0;\r\nbreak;\r\ncase 1:\r\ncase 9:\r\ncase 3:\r\ncase 0xE:\r\ncase 0xF:\r\nnand_width = 1;\r\nbreak;\r\ndefault:\r\nprintk("Pb1550 NAND: bad boot:swap\n");\r\nretval = -EINVAL;\r\ngoto outmem;\r\n}\r\n#endif\r\n#ifdef NAND_STCFG\r\nif (NAND_CS == 0) {\r\nau_writel(NAND_STCFG, MEM_STCFG0);\r\nau_writel(NAND_STTIME, MEM_STTIME0);\r\nau_writel(NAND_STADDR, MEM_STADDR0);\r\n}\r\nif (NAND_CS == 1) {\r\nau_writel(NAND_STCFG, MEM_STCFG1);\r\nau_writel(NAND_STTIME, MEM_STTIME1);\r\nau_writel(NAND_STADDR, MEM_STADDR1);\r\n}\r\nif (NAND_CS == 2) {\r\nau_writel(NAND_STCFG, MEM_STCFG2);\r\nau_writel(NAND_STTIME, MEM_STTIME2);\r\nau_writel(NAND_STADDR, MEM_STADDR2);\r\n}\r\nif (NAND_CS == 3) {\r\nau_writel(NAND_STCFG, MEM_STCFG3);\r\nau_writel(NAND_STTIME, MEM_STTIME3);\r\nau_writel(NAND_STADDR, MEM_STADDR3);\r\n}\r\n#endif\r\nmem_staddr = 0x00000000;\r\nif (((au_readl(MEM_STCFG0) & 0x7) == 0x5) && (NAND_CS == 0))\r\nmem_staddr = au_readl(MEM_STADDR0);\r\nelse if (((au_readl(MEM_STCFG1) & 0x7) == 0x5) && (NAND_CS == 1))\r\nmem_staddr = au_readl(MEM_STADDR1);\r\nelse if (((au_readl(MEM_STCFG2) & 0x7) == 0x5) && (NAND_CS == 2))\r\nmem_staddr = au_readl(MEM_STADDR2);\r\nelse if (((au_readl(MEM_STCFG3) & 0x7) == 0x5) && (NAND_CS == 3))\r\nmem_staddr = au_readl(MEM_STADDR3);\r\nif (mem_staddr == 0x00000000) {\r\nprintk("Au1xxx NAND: ERROR WITH NAND CHIP-SELECT\n");\r\nkfree(au1550_mtd);\r\nreturn 1;\r\n}\r\nnand_phys = (mem_staddr << 4) & 0xFFFC0000;\r\np_nand = ioremap(nand_phys, 0x1000);\r\nif (NAND_CS == 0)\r\nnand_width = au_readl(MEM_STCFG0) & (1 << 22);\r\nif (NAND_CS == 1)\r\nnand_width = au_readl(MEM_STCFG1) & (1 << 22);\r\nif (NAND_CS == 2)\r\nnand_width = au_readl(MEM_STCFG2) & (1 << 22);\r\nif (NAND_CS == 3)\r\nnand_width = au_readl(MEM_STCFG3) & (1 << 22);\r\nthis->dev_ready = au1550_device_ready;\r\nthis->select_chip = au1550_select_chip;\r\nthis->cmdfunc = au1550_command;\r\nthis->chip_delay = 30;\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\nthis->options = NAND_NO_AUTOINCR;\r\nif (!nand_width)\r\nthis->options |= NAND_BUSWIDTH_16;\r\nthis->read_byte = (!nand_width) ? au_read_byte16 : au_read_byte;\r\nau1550_write_byte = (!nand_width) ? au_write_byte16 : au_write_byte;\r\nthis->read_word = au_read_word;\r\nthis->write_buf = (!nand_width) ? au_write_buf16 : au_write_buf;\r\nthis->read_buf = (!nand_width) ? au_read_buf16 : au_read_buf;\r\nthis->verify_buf = (!nand_width) ? au_verify_buf16 : au_verify_buf;\r\nif (nand_scan(au1550_mtd, 1)) {\r\nretval = -ENXIO;\r\ngoto outio;\r\n}\r\nmtd_device_register(au1550_mtd, partition_info,\r\nARRAY_SIZE(partition_info));\r\nreturn 0;\r\noutio:\r\niounmap(p_nand);\r\noutmem:\r\nkfree(au1550_mtd);\r\nreturn retval;\r\n}\r\nstatic void __exit au1550_cleanup(void)\r\n{\r\nnand_release(au1550_mtd);\r\nkfree(au1550_mtd);\r\niounmap(p_nand);\r\n}
