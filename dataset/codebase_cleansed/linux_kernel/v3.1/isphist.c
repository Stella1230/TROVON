static void hist_reset_mem(struct ispstat *hist)\r\n{\r\nstruct isp_device *isp = hist->isp;\r\nstruct omap3isp_hist_config *conf = hist->priv;\r\nunsigned int i;\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\r\nfor (i = OMAP3ISP_HIST_MEM_SIZE / 4; i > 0; i--) {\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n}\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\r\nhist->wait_acc_frames = conf->num_acc_frames;\r\n}\r\nstatic void hist_dma_config(struct ispstat *hist)\r\n{\r\nhist->dma_config.data_type = OMAP_DMA_DATA_TYPE_S32;\r\nhist->dma_config.sync_mode = OMAP_DMA_SYNC_ELEMENT;\r\nhist->dma_config.frame_count = 1;\r\nhist->dma_config.src_amode = OMAP_DMA_AMODE_CONSTANT;\r\nhist->dma_config.src_start = OMAP3ISP_HIST_REG_BASE + ISPHIST_DATA;\r\nhist->dma_config.dst_amode = OMAP_DMA_AMODE_POST_INC;\r\nhist->dma_config.src_or_dst_synch = OMAP_DMA_SRC_SYNC;\r\n}\r\nstatic void hist_setup_regs(struct ispstat *hist, void *priv)\r\n{\r\nstruct isp_device *isp = hist->isp;\r\nstruct omap3isp_hist_config *conf = priv;\r\nint c;\r\nu32 cnt;\r\nu32 wb_gain;\r\nu32 reg_hor[OMAP3ISP_HIST_MAX_REGIONS];\r\nu32 reg_ver[OMAP3ISP_HIST_MAX_REGIONS];\r\nif (!hist->update || hist->state == ISPSTAT_DISABLED ||\r\nhist->state == ISPSTAT_DISABLING)\r\nreturn;\r\ncnt = conf->cfa << ISPHIST_CNT_CFA_SHIFT;\r\nwb_gain = conf->wg[0] << ISPHIST_WB_GAIN_WG00_SHIFT;\r\nwb_gain |= conf->wg[1] << ISPHIST_WB_GAIN_WG01_SHIFT;\r\nwb_gain |= conf->wg[2] << ISPHIST_WB_GAIN_WG02_SHIFT;\r\nif (conf->cfa == OMAP3ISP_HIST_CFA_BAYER)\r\nwb_gain |= conf->wg[3] << ISPHIST_WB_GAIN_WG03_SHIFT;\r\nfor (c = 0; c < OMAP3ISP_HIST_MAX_REGIONS; c++) {\r\nif (c < conf->num_regions) {\r\nreg_hor[c] = conf->region[c].h_start <<\r\nISPHIST_REG_START_SHIFT;\r\nreg_hor[c] = conf->region[c].h_end <<\r\nISPHIST_REG_END_SHIFT;\r\nreg_ver[c] = conf->region[c].v_start <<\r\nISPHIST_REG_START_SHIFT;\r\nreg_ver[c] = conf->region[c].v_end <<\r\nISPHIST_REG_END_SHIFT;\r\n} else {\r\nreg_hor[c] = 0;\r\nreg_ver[c] = 0;\r\n}\r\n}\r\ncnt |= conf->hist_bins << ISPHIST_CNT_BINS_SHIFT;\r\nswitch (conf->hist_bins) {\r\ncase OMAP3ISP_HIST_BINS_256:\r\ncnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 8) <<\r\nISPHIST_CNT_SHIFT_SHIFT;\r\nbreak;\r\ncase OMAP3ISP_HIST_BINS_128:\r\ncnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 7) <<\r\nISPHIST_CNT_SHIFT_SHIFT;\r\nbreak;\r\ncase OMAP3ISP_HIST_BINS_64:\r\ncnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 6) <<\r\nISPHIST_CNT_SHIFT_SHIFT;\r\nbreak;\r\ndefault:\r\ncnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 5) <<\r\nISPHIST_CNT_SHIFT_SHIFT;\r\nbreak;\r\n}\r\nhist_reset_mem(hist);\r\nisp_reg_writel(isp, cnt, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT);\r\nisp_reg_writel(isp, wb_gain, OMAP3_ISP_IOMEM_HIST, ISPHIST_WB_GAIN);\r\nisp_reg_writel(isp, reg_hor[0], OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_HORZ);\r\nisp_reg_writel(isp, reg_ver[0], OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_VERT);\r\nisp_reg_writel(isp, reg_hor[1], OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_HORZ);\r\nisp_reg_writel(isp, reg_ver[1], OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_VERT);\r\nisp_reg_writel(isp, reg_hor[2], OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_HORZ);\r\nisp_reg_writel(isp, reg_ver[2], OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_VERT);\r\nisp_reg_writel(isp, reg_hor[3], OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_HORZ);\r\nisp_reg_writel(isp, reg_ver[3], OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_VERT);\r\nhist->update = 0;\r\nhist->config_counter += hist->inc_config;\r\nhist->inc_config = 0;\r\nhist->buf_size = conf->buf_size;\r\n}\r\nstatic void hist_enable(struct ispstat *hist, int enable)\r\n{\r\nif (enable) {\r\nisp_reg_set(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR,\r\nISPHIST_PCR_ENABLE);\r\nisp_reg_set(hist->isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,\r\nISPCTRL_HIST_CLK_EN);\r\n} else {\r\nisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR,\r\nISPHIST_PCR_ENABLE);\r\nisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,\r\nISPCTRL_HIST_CLK_EN);\r\n}\r\n}\r\nstatic int hist_busy(struct ispstat *hist)\r\n{\r\nreturn isp_reg_readl(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR)\r\n& ISPHIST_PCR_BUSY;\r\n}\r\nstatic void hist_dma_cb(int lch, u16 ch_status, void *data)\r\n{\r\nstruct ispstat *hist = data;\r\nif (ch_status & ~OMAP_DMA_BLOCK_IRQ) {\r\ndev_dbg(hist->isp->dev, "hist: DMA error. status = 0x%04x\n",\r\nch_status);\r\nomap_stop_dma(lch);\r\nhist_reset_mem(hist);\r\natomic_set(&hist->buf_err, 1);\r\n}\r\nisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\r\nISPHIST_CNT_CLEAR);\r\nomap3isp_stat_dma_isr(hist);\r\nif (hist->state != ISPSTAT_DISABLED)\r\nomap3isp_hist_dma_done(hist->isp);\r\n}\r\nstatic int hist_buf_dma(struct ispstat *hist)\r\n{\r\ndma_addr_t dma_addr = hist->active_buf->dma_addr;\r\nif (unlikely(!dma_addr)) {\r\ndev_dbg(hist->isp->dev, "hist: invalid DMA buffer address\n");\r\nhist_reset_mem(hist);\r\nreturn STAT_NO_BUF;\r\n}\r\nisp_reg_writel(hist->isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\r\nisp_reg_set(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\r\nISPHIST_CNT_CLEAR);\r\nomap3isp_flush(hist->isp);\r\nhist->dma_config.dst_start = dma_addr;\r\nhist->dma_config.elem_count = hist->buf_size / sizeof(u32);\r\nomap_set_dma_params(hist->dma_ch, &hist->dma_config);\r\nomap_start_dma(hist->dma_ch);\r\nreturn STAT_BUF_WAITING_DMA;\r\n}\r\nstatic int hist_buf_pio(struct ispstat *hist)\r\n{\r\nstruct isp_device *isp = hist->isp;\r\nu32 *buf = hist->active_buf->virt_addr;\r\nunsigned int i;\r\nif (!buf) {\r\ndev_dbg(isp->dev, "hist: invalid PIO buffer address\n");\r\nhist_reset_mem(hist);\r\nreturn STAT_NO_BUF;\r\n}\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\r\nfor (i = hist->buf_size / 16; i > 0; i--) {\r\n*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n}\r\nisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\r\nISPHIST_CNT_CLEAR);\r\nreturn STAT_BUF_DONE;\r\n}\r\nstatic int hist_buf_process(struct ispstat *hist)\r\n{\r\nstruct omap3isp_hist_config *user_cfg = hist->priv;\r\nint ret;\r\nif (atomic_read(&hist->buf_err) || hist->state != ISPSTAT_ENABLED) {\r\nhist_reset_mem(hist);\r\nreturn STAT_NO_BUF;\r\n}\r\nif (--(hist->wait_acc_frames))\r\nreturn STAT_NO_BUF;\r\nif (HIST_USING_DMA(hist))\r\nret = hist_buf_dma(hist);\r\nelse\r\nret = hist_buf_pio(hist);\r\nhist->wait_acc_frames = user_cfg->num_acc_frames;\r\nreturn ret;\r\n}\r\nstatic u32 hist_get_buf_size(struct omap3isp_hist_config *conf)\r\n{\r\nreturn OMAP3ISP_HIST_MEM_SIZE_BINS(conf->hist_bins) * conf->num_regions;\r\n}\r\nstatic int hist_validate_params(struct ispstat *hist, void *new_conf)\r\n{\r\nstruct omap3isp_hist_config *user_cfg = new_conf;\r\nint c;\r\nu32 buf_size;\r\nif (user_cfg->cfa > OMAP3ISP_HIST_CFA_FOVEONX3)\r\nreturn -EINVAL;\r\nif ((user_cfg->num_regions < OMAP3ISP_HIST_MIN_REGIONS) ||\r\n(user_cfg->num_regions > OMAP3ISP_HIST_MAX_REGIONS))\r\nreturn -EINVAL;\r\nfor (c = 0; c < user_cfg->num_regions; c++) {\r\nif (user_cfg->region[c].h_start & ~ISPHIST_REG_START_END_MASK)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].h_end & ~ISPHIST_REG_START_END_MASK)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].v_start & ~ISPHIST_REG_START_END_MASK)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].v_end & ~ISPHIST_REG_START_END_MASK)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].h_start > user_cfg->region[c].h_end)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].v_start > user_cfg->region[c].v_end)\r\nreturn -EINVAL;\r\n}\r\nswitch (user_cfg->num_regions) {\r\ncase 1:\r\nif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_256)\r\nreturn -EINVAL;\r\nbreak;\r\ncase 2:\r\nif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_128)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_64)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nbuf_size = hist_get_buf_size(user_cfg);\r\nif (buf_size > user_cfg->buf_size)\r\nuser_cfg->buf_size = buf_size;\r\nelse if (user_cfg->buf_size > OMAP3ISP_HIST_MAX_BUF_SIZE)\r\nuser_cfg->buf_size = OMAP3ISP_HIST_MAX_BUF_SIZE;\r\nreturn 0;\r\n}\r\nstatic int hist_comp_params(struct ispstat *hist,\r\nstruct omap3isp_hist_config *user_cfg)\r\n{\r\nstruct omap3isp_hist_config *cur_cfg = hist->priv;\r\nint c;\r\nif (cur_cfg->cfa != user_cfg->cfa)\r\nreturn 1;\r\nif (cur_cfg->num_acc_frames != user_cfg->num_acc_frames)\r\nreturn 1;\r\nif (cur_cfg->hist_bins != user_cfg->hist_bins)\r\nreturn 1;\r\nfor (c = 0; c < OMAP3ISP_HIST_MAX_WG; c++) {\r\nif (c == 3 && user_cfg->cfa == OMAP3ISP_HIST_CFA_FOVEONX3)\r\nbreak;\r\nelse if (cur_cfg->wg[c] != user_cfg->wg[c])\r\nreturn 1;\r\n}\r\nif (cur_cfg->num_regions != user_cfg->num_regions)\r\nreturn 1;\r\nfor (c = 0; c < user_cfg->num_regions; c++) {\r\nif (cur_cfg->region[c].h_start != user_cfg->region[c].h_start)\r\nreturn 1;\r\nif (cur_cfg->region[c].h_end != user_cfg->region[c].h_end)\r\nreturn 1;\r\nif (cur_cfg->region[c].v_start != user_cfg->region[c].v_start)\r\nreturn 1;\r\nif (cur_cfg->region[c].v_end != user_cfg->region[c].v_end)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hist_set_params(struct ispstat *hist, void *new_conf)\r\n{\r\nstruct omap3isp_hist_config *user_cfg = new_conf;\r\nstruct omap3isp_hist_config *cur_cfg = hist->priv;\r\nif (!hist->configured || hist_comp_params(hist, user_cfg)) {\r\nmemcpy(cur_cfg, user_cfg, sizeof(*user_cfg));\r\nif (user_cfg->num_acc_frames == 0)\r\nuser_cfg->num_acc_frames = 1;\r\nhist->inc_config++;\r\nhist->update = 1;\r\ncur_cfg->buf_size = hist_get_buf_size(cur_cfg);\r\n}\r\n}\r\nstatic long hist_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct ispstat *stat = v4l2_get_subdevdata(sd);\r\nswitch (cmd) {\r\ncase VIDIOC_OMAP3ISP_HIST_CFG:\r\nreturn omap3isp_stat_config(stat, arg);\r\ncase VIDIOC_OMAP3ISP_STAT_REQ:\r\nreturn omap3isp_stat_request_statistics(stat, arg);\r\ncase VIDIOC_OMAP3ISP_STAT_EN: {\r\nint *en = arg;\r\nreturn omap3isp_stat_enable(stat, !!*en);\r\n}\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nint omap3isp_hist_init(struct isp_device *isp)\r\n{\r\nstruct ispstat *hist = &isp->isp_hist;\r\nstruct omap3isp_hist_config *hist_cfg;\r\nint ret = -1;\r\nhist_cfg = kzalloc(sizeof(*hist_cfg), GFP_KERNEL);\r\nif (hist_cfg == NULL)\r\nreturn -ENOMEM;\r\nmemset(hist, 0, sizeof(*hist));\r\nif (HIST_CONFIG_DMA)\r\nret = omap_request_dma(OMAP24XX_DMA_NO_DEVICE, "DMA_ISP_HIST",\r\nhist_dma_cb, hist, &hist->dma_ch);\r\nif (ret) {\r\nif (HIST_CONFIG_DMA)\r\ndev_warn(isp->dev, "hist: DMA request channel failed. "\r\n"Using PIO only.\n");\r\nhist->dma_ch = -1;\r\n} else {\r\ndev_dbg(isp->dev, "hist: DMA channel = %d\n", hist->dma_ch);\r\nhist_dma_config(hist);\r\nomap_enable_dma_irq(hist->dma_ch, OMAP_DMA_BLOCK_IRQ);\r\n}\r\nhist->ops = &hist_ops;\r\nhist->priv = hist_cfg;\r\nhist->event_type = V4L2_EVENT_OMAP3ISP_HIST;\r\nhist->isp = isp;\r\nret = omap3isp_stat_init(hist, "histogram", &hist_subdev_ops);\r\nif (ret) {\r\nkfree(hist_cfg);\r\nif (HIST_USING_DMA(hist))\r\nomap_free_dma(hist->dma_ch);\r\n}\r\nreturn ret;\r\n}\r\nvoid omap3isp_hist_cleanup(struct isp_device *isp)\r\n{\r\nif (HIST_USING_DMA(&isp->isp_hist))\r\nomap_free_dma(isp->isp_hist.dma_ch);\r\nkfree(isp->isp_hist.priv);\r\nomap3isp_stat_free(&isp->isp_hist);\r\n}
