static unsigned int get_pio_timings(ide_drive_t *drive, u8 pio)\r\n{\r\nstruct ide_timing *t = ide_timing_find_mode(XFER_PIO_0 + pio);\r\nunsigned int cmd_on, cmd_off;\r\nu8 iordy = 0;\r\ncmd_on = (t->active + 29) / 30;\r\ncmd_off = (ide_pio_cycle_time(drive, pio) - 30 * cmd_on + 29) / 30;\r\nif (cmd_on == 0)\r\ncmd_on = 1;\r\nif (cmd_off == 0)\r\ncmd_off = 1;\r\nif (ide_pio_need_iordy(drive, pio))\r\niordy = 0x40;\r\nreturn (cmd_on - 1) << 8 | (cmd_off - 1) | iordy;\r\n}\r\nstatic void sl82c105_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long timings = (unsigned long)ide_get_drivedata(drive);\r\nint reg = 0x44 + drive->dn * 4;\r\nu16 drv_ctrl;\r\nconst u8 pio = drive->pio_mode - XFER_PIO_0;\r\ndrv_ctrl = get_pio_timings(drive, pio);\r\ntimings &= 0xffff0000;\r\ntimings |= drv_ctrl;\r\nide_set_drivedata(drive, (void *)timings);\r\npci_write_config_word(dev, reg, drv_ctrl);\r\npci_read_config_word (dev, reg, &drv_ctrl);\r\nprintk(KERN_DEBUG "%s: selected %s (%dns) (%04X)\n", drive->name,\r\nide_xfer_verbose(pio + XFER_PIO_0),\r\nide_pio_cycle_time(drive, pio), drv_ctrl);\r\n}\r\nstatic void sl82c105_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstatic u16 mwdma_timings[] = {0x0707, 0x0201, 0x0200};\r\nunsigned long timings = (unsigned long)ide_get_drivedata(drive);\r\nu16 drv_ctrl;\r\nconst u8 speed = drive->dma_mode;\r\ndrv_ctrl = mwdma_timings[speed - XFER_MW_DMA_0];\r\ntimings &= 0x0000ffff;\r\ntimings |= (unsigned long)drv_ctrl << 16;\r\nide_set_drivedata(drive, (void *)timings);\r\n}\r\nstatic int sl82c105_test_irq(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu32 val, mask = hwif->channel ? CTRL_IDE_IRQB : CTRL_IDE_IRQA;\r\npci_read_config_dword(dev, 0x40, &val);\r\nreturn (val & mask) ? 1 : 0;\r\n}\r\nstatic inline void sl82c105_reset_host(struct pci_dev *dev)\r\n{\r\nu16 val;\r\npci_read_config_word(dev, 0x7e, &val);\r\npci_write_config_word(dev, 0x7e, val | (1 << 2));\r\npci_write_config_word(dev, 0x7e, val & ~(1 << 2));\r\n}\r\nstatic void sl82c105_dma_lost_irq(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu32 val, mask = hwif->channel ? CTRL_IDE_IRQB : CTRL_IDE_IRQA;\r\nu8 dma_cmd;\r\nprintk(KERN_WARNING "sl82c105: lost IRQ, resetting host\n");\r\npci_read_config_dword(dev, 0x40, &val);\r\nif (val & mask)\r\nprintk(KERN_INFO "sl82c105: drive was requesting IRQ, "\r\n"but host lost it\n");\r\ndma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);\r\nif (dma_cmd & 1) {\r\noutb(dma_cmd & ~1, hwif->dma_base + ATA_DMA_CMD);\r\nprintk(KERN_INFO "sl82c105: DMA was enabled\n");\r\n}\r\nsl82c105_reset_host(dev);\r\n}\r\nstatic void sl82c105_dma_start(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nint reg = 0x44 + drive->dn * 4;\r\npci_write_config_word(dev, reg,\r\n(unsigned long)ide_get_drivedata(drive) >> 16);\r\nsl82c105_reset_host(dev);\r\nide_dma_start(drive);\r\n}\r\nstatic void sl82c105_dma_clear(ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(drive->hwif->dev);\r\nsl82c105_reset_host(dev);\r\n}\r\nstatic int sl82c105_dma_end(ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(drive->hwif->dev);\r\nint reg = 0x44 + drive->dn * 4;\r\nint ret = ide_dma_end(drive);\r\npci_write_config_word(dev, reg,\r\n(unsigned long)ide_get_drivedata(drive));\r\nreturn ret;\r\n}\r\nstatic void sl82c105_resetproc(ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(drive->hwif->dev);\r\nu32 val;\r\npci_read_config_dword(dev, 0x40, &val);\r\nval |= (CTRL_P1F16 | CTRL_P0F16);\r\npci_write_config_dword(dev, 0x40, val);\r\n}\r\nstatic u8 sl82c105_bridge_revision(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *bridge;\r\nbridge = pci_get_bus_and_slot(dev->bus->number,\r\nPCI_DEVFN(PCI_SLOT(dev->devfn), 0));\r\nif (!bridge)\r\nreturn -1;\r\nif (bridge->vendor != PCI_VENDOR_ID_WINBOND ||\r\nbridge->device != PCI_DEVICE_ID_WINBOND_83C553 ||\r\nbridge->class >> 8 != PCI_CLASS_BRIDGE_ISA) {\r\npci_dev_put(bridge);\r\nreturn -1;\r\n}\r\npci_dev_put(bridge);\r\nreturn bridge->revision;\r\n}\r\nstatic int init_chipset_sl82c105(struct pci_dev *dev)\r\n{\r\nu32 val;\r\npci_read_config_dword(dev, 0x40, &val);\r\nval |= CTRL_P0EN | CTRL_P0F16 | CTRL_P1F16;\r\npci_write_config_dword(dev, 0x40, val);\r\nreturn 0;\r\n}\r\nstatic int __devinit sl82c105_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct ide_port_info d = sl82c105_chipset;\r\nu8 rev = sl82c105_bridge_revision(dev);\r\nif (rev <= 5) {\r\nprintk(KERN_INFO DRV_NAME ": Winbond W83C553 bridge "\r\n"revision %d, BM-DMA disabled\n", rev);\r\nd.dma_ops = NULL;\r\nd.mwdma_mask = 0;\r\nd.host_flags &= ~IDE_HFLAG_SERIALIZE_DMA;\r\n}\r\nreturn ide_pci_init_one(dev, &d, NULL);\r\n}\r\nstatic int __init sl82c105_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&sl82c105_pci_driver);\r\n}\r\nstatic void __exit sl82c105_ide_exit(void)\r\n{\r\npci_unregister_driver(&sl82c105_pci_driver);\r\n}
