static inline int\r\nwaitforHIA(struct isar_hw *isar, int timeout)\r\n{\r\nint t = timeout;\r\nu8 val = isar->read_reg(isar->hw, ISAR_HIA);\r\nwhile ((val & 1) && t) {\r\nudelay(1);\r\nt--;\r\nval = isar->read_reg(isar->hw, ISAR_HIA);\r\n}\r\npr_debug("%s: HIA after %dus\n", isar->name, timeout - t);\r\nreturn timeout;\r\n}\r\nstatic int\r\nsend_mbox(struct isar_hw *isar, u8 his, u8 creg, u8 len, u8 *msg)\r\n{\r\nif (!waitforHIA(isar, 1000))\r\nreturn 0;\r\npr_debug("send_mbox(%02x,%02x,%d)\n", his, creg, len);\r\nisar->write_reg(isar->hw, ISAR_CTRL_H, creg);\r\nisar->write_reg(isar->hw, ISAR_CTRL_L, len);\r\nisar->write_reg(isar->hw, ISAR_WADR, 0);\r\nif (!msg)\r\nmsg = isar->buf;\r\nif (msg && len) {\r\nisar->write_fifo(isar->hw, ISAR_MBOX, msg, len);\r\nif (isar->ch[0].bch.debug & DEBUG_HW_BFIFO) {\r\nint l = 0;\r\nwhile (l < (int)len) {\r\nhex_dump_to_buffer(msg + l, len - l, 32, 1,\r\nisar->log, 256, 1);\r\npr_debug("%s: %s %02x: %s\n", isar->name,\r\n__func__, l, isar->log);\r\nl += 32;\r\n}\r\n}\r\n}\r\nisar->write_reg(isar->hw, ISAR_HIS, his);\r\nwaitforHIA(isar, 1000);\r\nreturn 1;\r\n}\r\nstatic void\r\nrcv_mbox(struct isar_hw *isar, u8 *msg)\r\n{\r\nif (!msg)\r\nmsg = isar->buf;\r\nisar->write_reg(isar->hw, ISAR_RADR, 0);\r\nif (msg && isar->clsb) {\r\nisar->read_fifo(isar->hw, ISAR_MBOX, msg, isar->clsb);\r\nif (isar->ch[0].bch.debug & DEBUG_HW_BFIFO) {\r\nint l = 0;\r\nwhile (l < (int)isar->clsb) {\r\nhex_dump_to_buffer(msg + l, isar->clsb - l, 32,\r\n1, isar->log, 256, 1);\r\npr_debug("%s: %s %02x: %s\n", isar->name,\r\n__func__, l, isar->log);\r\nl += 32;\r\n}\r\n}\r\n}\r\nisar->write_reg(isar->hw, ISAR_IIA, 0);\r\n}\r\nstatic inline void\r\nget_irq_infos(struct isar_hw *isar)\r\n{\r\nisar->iis = isar->read_reg(isar->hw, ISAR_IIS);\r\nisar->cmsb = isar->read_reg(isar->hw, ISAR_CTRL_H);\r\nisar->clsb = isar->read_reg(isar->hw, ISAR_CTRL_L);\r\npr_debug("%s: rcv_mbox(%02x,%02x,%d)\n", isar->name,\r\nisar->iis, isar->cmsb, isar->clsb);\r\n}\r\nstatic int\r\npoll_mbox(struct isar_hw *isar, int maxdelay)\r\n{\r\nint t = maxdelay;\r\nu8 irq;\r\nirq = isar->read_reg(isar->hw, ISAR_IRQBIT);\r\nwhile (t && !(irq & ISAR_IRQSTA)) {\r\nudelay(1);\r\nt--;\r\n}\r\nif (t) {\r\nget_irq_infos(isar);\r\nrcv_mbox(isar, NULL);\r\n}\r\npr_debug("%s: pulled %d bytes after %d us\n",\r\nisar->name, isar->clsb, maxdelay - t);\r\nreturn t;\r\n}\r\nstatic int\r\nISARVersion(struct isar_hw *isar)\r\n{\r\nint ver;\r\nisar->write_reg(isar->hw, ISAR_IRQBIT, 0);\r\nisar->buf[0] = ISAR_MSG_HWVER;\r\nisar->buf[1] = 0;\r\nisar->buf[2] = 1;\r\nif (!send_mbox(isar, ISAR_HIS_VNR, 0, 3, NULL))\r\nreturn -1;\r\nif (!poll_mbox(isar, 1000))\r\nreturn -2;\r\nif (isar->iis == ISAR_IIS_VNR) {\r\nif (isar->clsb == 1) {\r\nver = isar->buf[0] & 0xf;\r\nreturn ver;\r\n}\r\nreturn -3;\r\n}\r\nreturn -4;\r\n}\r\nstatic int\r\nload_firmware(struct isar_hw *isar, const u8 *buf, int size)\r\n{\r\nu32 saved_debug = isar->ch[0].bch.debug;\r\nint ret, cnt;\r\nu8 nom, noc;\r\nu16 left, val, *sp = (u16 *)buf;\r\nu8 *mp;\r\nu_long flags;\r\nstruct {\r\nu16 sadr;\r\nu16 len;\r\nu16 d_key;\r\n} blk_head;\r\nif (1 != isar->version) {\r\npr_err("%s: ISAR wrong version %d firmware download aborted\n",\r\nisar->name, isar->version);\r\nreturn -EINVAL;\r\n}\r\nif (!(saved_debug & DEBUG_HW_FIRMWARE_FIFO))\r\nisar->ch[0].bch.debug &= ~DEBUG_HW_BFIFO;\r\npr_debug("%s: load firmware %d words (%d bytes)\n",\r\nisar->name, size/2, size);\r\ncnt = 0;\r\nsize /= 2;\r\nspin_lock_irqsave(isar->hwlock, flags);\r\nisar->write_reg(isar->hw, ISAR_IRQBIT, 0);\r\nspin_unlock_irqrestore(isar->hwlock, flags);\r\nwhile (cnt < size) {\r\nblk_head.sadr = le16_to_cpu(*sp++);\r\nblk_head.len = le16_to_cpu(*sp++);\r\nblk_head.d_key = le16_to_cpu(*sp++);\r\ncnt += 3;\r\npr_debug("ISAR firmware block (%#x,%d,%#x)\n",\r\nblk_head.sadr, blk_head.len, blk_head.d_key & 0xff);\r\nleft = blk_head.len;\r\nif (cnt + left > size) {\r\npr_info("%s: firmware error have %d need %d words\n",\r\nisar->name, size, cnt + left);\r\nret = -EINVAL;\r\ngoto reterrflg;\r\n}\r\nspin_lock_irqsave(isar->hwlock, flags);\r\nif (!send_mbox(isar, ISAR_HIS_DKEY, blk_head.d_key & 0xff,\r\n0, NULL)) {\r\npr_info("ISAR send_mbox dkey failed\n");\r\nret = -ETIME;\r\ngoto reterror;\r\n}\r\nif (!poll_mbox(isar, 1000)) {\r\npr_warning("ISAR poll_mbox dkey failed\n");\r\nret = -ETIME;\r\ngoto reterror;\r\n}\r\nspin_unlock_irqrestore(isar->hwlock, flags);\r\nif ((isar->iis != ISAR_IIS_DKEY) || isar->cmsb || isar->clsb) {\r\npr_info("ISAR wrong dkey response (%x,%x,%x)\n",\r\nisar->iis, isar->cmsb, isar->clsb);\r\nret = 1;\r\ngoto reterrflg;\r\n}\r\nwhile (left > 0) {\r\nif (left > 126)\r\nnoc = 126;\r\nelse\r\nnoc = left;\r\nnom = (2 * noc) + 3;\r\nmp = isar->buf;\r\n*mp++ = blk_head.sadr >> 8;\r\n*mp++ = blk_head.sadr & 0xFF;\r\nleft -= noc;\r\ncnt += noc;\r\n*mp++ = noc;\r\npr_debug("%s: load %3d words at %04x\n", isar->name,\r\nnoc, blk_head.sadr);\r\nblk_head.sadr += noc;\r\nwhile (noc) {\r\nval = le16_to_cpu(*sp++);\r\n*mp++ = val >> 8;\r\n*mp++ = val & 0xFF;\r\nnoc--;\r\n}\r\nspin_lock_irqsave(isar->hwlock, flags);\r\nif (!send_mbox(isar, ISAR_HIS_FIRM, 0, nom, NULL)) {\r\npr_info("ISAR send_mbox prog failed\n");\r\nret = -ETIME;\r\ngoto reterror;\r\n}\r\nif (!poll_mbox(isar, 1000)) {\r\npr_info("ISAR poll_mbox prog failed\n");\r\nret = -ETIME;\r\ngoto reterror;\r\n}\r\nspin_unlock_irqrestore(isar->hwlock, flags);\r\nif ((isar->iis != ISAR_IIS_FIRM) ||\r\nisar->cmsb || isar->clsb) {\r\npr_info("ISAR wrong prog response (%x,%x,%x)\n",\r\nisar->iis, isar->cmsb, isar->clsb);\r\nret = -EIO;\r\ngoto reterrflg;\r\n}\r\n}\r\npr_debug("%s: ISAR firmware block %d words loaded\n",\r\nisar->name, blk_head.len);\r\n}\r\nisar->ch[0].bch.debug = saved_debug;\r\ncnt = 10;\r\nwhile (cnt--)\r\nmdelay(1);\r\nisar->buf[0] = 0xff;\r\nisar->buf[1] = 0xfe;\r\nisar->bstat = 0;\r\nspin_lock_irqsave(isar->hwlock, flags);\r\nif (!send_mbox(isar, ISAR_HIS_STDSP, 0, 2, NULL)) {\r\npr_info("ISAR send_mbox start dsp failed\n");\r\nret = -ETIME;\r\ngoto reterror;\r\n}\r\nif (!poll_mbox(isar, 1000)) {\r\npr_info("ISAR poll_mbox start dsp failed\n");\r\nret = -ETIME;\r\ngoto reterror;\r\n}\r\nif ((isar->iis != ISAR_IIS_STDSP) || isar->cmsb || isar->clsb) {\r\npr_info("ISAR wrong start dsp response (%x,%x,%x)\n",\r\nisar->iis, isar->cmsb, isar->clsb);\r\nret = -EIO;\r\ngoto reterror;\r\n} else\r\npr_debug("%s: ISAR start dsp success\n", isar->name);\r\nisar->write_reg(isar->hw, ISAR_IRQBIT, ISAR_IRQSTA);\r\nspin_unlock_irqrestore(isar->hwlock, flags);\r\ncnt = 1000;\r\nwhile ((!isar->bstat) && cnt) {\r\nmdelay(1);\r\ncnt--;\r\n}\r\nif (!cnt) {\r\npr_info("ISAR no general status event received\n");\r\nret = -ETIME;\r\ngoto reterrflg;\r\n} else\r\npr_debug("%s: ISAR general status event %x\n",\r\nisar->name, isar->bstat);\r\ncnt = 10;\r\nwhile (cnt--)\r\nmdelay(1);\r\nisar->iis = 0;\r\nspin_lock_irqsave(isar->hwlock, flags);\r\nif (!send_mbox(isar, ISAR_HIS_DIAG, ISAR_CTRL_STST, 0, NULL)) {\r\npr_info("ISAR send_mbox self tst failed\n");\r\nret = -ETIME;\r\ngoto reterror;\r\n}\r\nspin_unlock_irqrestore(isar->hwlock, flags);\r\ncnt = 10000;\r\nwhile ((isar->iis != ISAR_IIS_DIAG) && cnt) {\r\nudelay(10);\r\ncnt--;\r\n}\r\nmdelay(1);\r\nif (!cnt) {\r\npr_info("ISAR no self tst response\n");\r\nret = -ETIME;\r\ngoto reterrflg;\r\n}\r\nif ((isar->cmsb == ISAR_CTRL_STST) && (isar->clsb == 1)\r\n&& (isar->buf[0] == 0))\r\npr_debug("%s: ISAR selftest OK\n", isar->name);\r\nelse {\r\npr_info("ISAR selftest not OK %x/%x/%x\n",\r\nisar->cmsb, isar->clsb, isar->buf[0]);\r\nret = -EIO;\r\ngoto reterrflg;\r\n}\r\nspin_lock_irqsave(isar->hwlock, flags);\r\nisar->iis = 0;\r\nif (!send_mbox(isar, ISAR_HIS_DIAG, ISAR_CTRL_SWVER, 0, NULL)) {\r\npr_info("ISAR RQST SVN failed\n");\r\nret = -ETIME;\r\ngoto reterror;\r\n}\r\nspin_unlock_irqrestore(isar->hwlock, flags);\r\ncnt = 30000;\r\nwhile ((isar->iis != ISAR_IIS_DIAG) && cnt) {\r\nudelay(10);\r\ncnt--;\r\n}\r\nmdelay(1);\r\nif (!cnt) {\r\npr_info("ISAR no SVN response\n");\r\nret = -ETIME;\r\ngoto reterrflg;\r\n} else {\r\nif ((isar->cmsb == ISAR_CTRL_SWVER) && (isar->clsb == 1)) {\r\npr_notice("%s: ISAR software version %#x\n",\r\nisar->name, isar->buf[0]);\r\n} else {\r\npr_info("%s: ISAR wrong swver response (%x,%x)"\r\n" cnt(%d)\n", isar->name, isar->cmsb,\r\nisar->clsb, cnt);\r\nret = -EIO;\r\ngoto reterrflg;\r\n}\r\n}\r\nspin_lock_irqsave(isar->hwlock, flags);\r\nisar_setup(isar);\r\nspin_unlock_irqrestore(isar->hwlock, flags);\r\nret = 0;\r\nreterrflg:\r\nspin_lock_irqsave(isar->hwlock, flags);\r\nreterror:\r\nisar->ch[0].bch.debug = saved_debug;\r\nif (ret)\r\nisar->write_reg(isar->hw, ISAR_IRQBIT, 0);\r\nspin_unlock_irqrestore(isar->hwlock, flags);\r\nreturn ret;\r\n}\r\nstatic inline void\r\ndeliver_status(struct isar_ch *ch, int status)\r\n{\r\npr_debug("%s: HL->LL FAXIND %x\n", ch->is->name, status);\r\n_queue_data(&ch->bch.ch, PH_CONTROL_IND, status, 0, NULL, GFP_ATOMIC);\r\n}\r\nstatic inline void\r\nisar_rcv_frame(struct isar_ch *ch)\r\n{\r\nu8 *ptr;\r\nif (!ch->is->clsb) {\r\npr_debug("%s; ISAR zero len frame\n", ch->is->name);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nreturn;\r\n}\r\nswitch (ch->bch.state) {\r\ncase ISDN_P_NONE:\r\npr_debug("%s: ISAR protocol 0 spurious IIS_RDATA %x/%x/%x\n",\r\nch->is->name, ch->is->iis, ch->is->cmsb, ch->is->clsb);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\ncase ISDN_P_B_L2DTMF:\r\ncase ISDN_P_B_MODEM_ASYNC:\r\nif (!ch->bch.rx_skb) {\r\nch->bch.rx_skb = mI_alloc_skb(ch->bch.maxlen,\r\nGFP_ATOMIC);\r\nif (unlikely(!ch->bch.rx_skb)) {\r\npr_info("%s: B receive out of memory\n",\r\nch->is->name);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nbreak;\r\n}\r\n}\r\nrcv_mbox(ch->is, skb_put(ch->bch.rx_skb, ch->is->clsb));\r\nrecv_Bchannel(&ch->bch, 0);\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\nif (!ch->bch.rx_skb) {\r\nch->bch.rx_skb = mI_alloc_skb(ch->bch.maxlen,\r\nGFP_ATOMIC);\r\nif (unlikely(!ch->bch.rx_skb)) {\r\npr_info("%s: B receive out of memory\n",\r\nch->is->name);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nbreak;\r\n}\r\n}\r\nif ((ch->bch.rx_skb->len + ch->is->clsb) >\r\n(ch->bch.maxlen + 2)) {\r\npr_debug("%s: incoming packet too large\n",\r\nch->is->name);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nskb_trim(ch->bch.rx_skb, 0);\r\nbreak;\r\n}\r\nif (ch->is->cmsb & HDLC_ERROR) {\r\npr_debug("%s: ISAR frame error %x len %d\n",\r\nch->is->name, ch->is->cmsb, ch->is->clsb);\r\n#ifdef ERROR_STATISTIC\r\nif (ch->is->cmsb & HDLC_ERR_RER)\r\nch->bch.err_inv++;\r\nif (ch->is->cmsb & HDLC_ERR_CER)\r\nch->bch.err_crc++;\r\n#endif\r\nskb_trim(ch->bch.rx_skb, 0);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nbreak;\r\n}\r\nif (ch->is->cmsb & HDLC_FSD)\r\nskb_trim(ch->bch.rx_skb, 0);\r\nptr = skb_put(ch->bch.rx_skb, ch->is->clsb);\r\nrcv_mbox(ch->is, ptr);\r\nif (ch->is->cmsb & HDLC_FED) {\r\nif (ch->bch.rx_skb->len < 3) {\r\npr_debug("%s: ISAR frame to short %d\n",\r\nch->is->name, ch->bch.rx_skb->len);\r\nskb_trim(ch->bch.rx_skb, 0);\r\nbreak;\r\n}\r\nskb_trim(ch->bch.rx_skb, ch->bch.rx_skb->len - 2);\r\nrecv_Bchannel(&ch->bch, 0);\r\n}\r\nbreak;\r\ncase ISDN_P_B_T30_FAX:\r\nif (ch->state != STFAX_ACTIV) {\r\npr_debug("%s: isar_rcv_frame: not ACTIV\n",\r\nch->is->name);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nif (ch->bch.rx_skb)\r\nskb_trim(ch->bch.rx_skb, 0);\r\nbreak;\r\n}\r\nif (!ch->bch.rx_skb) {\r\nch->bch.rx_skb = mI_alloc_skb(ch->bch.maxlen,\r\nGFP_ATOMIC);\r\nif (unlikely(!ch->bch.rx_skb)) {\r\npr_info("%s: B receive out of memory\n",\r\n__func__);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nbreak;\r\n}\r\n}\r\nif (ch->cmd == PCTRL_CMD_FRM) {\r\nrcv_mbox(ch->is, skb_put(ch->bch.rx_skb, ch->is->clsb));\r\npr_debug("%s: isar_rcv_frame: %d\n",\r\nch->is->name, ch->bch.rx_skb->len);\r\nif (ch->is->cmsb & SART_NMD) {\r\npr_debug("%s: isar_rcv_frame: no more data\n",\r\nch->is->name);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nsend_mbox(ch->is, SET_DPS(ch->dpath) |\r\nISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC,\r\n0, NULL);\r\nch->state = STFAX_ESCAPE;\r\n}\r\nrecv_Bchannel(&ch->bch, 0);\r\nif (ch->is->cmsb & SART_NMD)\r\ndeliver_status(ch, HW_MOD_NOCARR);\r\nbreak;\r\n}\r\nif (ch->cmd != PCTRL_CMD_FRH) {\r\npr_debug("%s: isar_rcv_frame: unknown fax mode %x\n",\r\nch->is->name, ch->cmd);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nif (ch->bch.rx_skb)\r\nskb_trim(ch->bch.rx_skb, 0);\r\nbreak;\r\n}\r\nif ((ch->bch.rx_skb->len + ch->is->clsb) >\r\n(ch->bch.maxlen + 2)) {\r\npr_info("%s: %s incoming packet too large\n",\r\nch->is->name, __func__);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nskb_trim(ch->bch.rx_skb, 0);\r\nbreak;\r\n} else if (ch->is->cmsb & HDLC_ERROR) {\r\npr_info("%s: ISAR frame error %x len %d\n",\r\nch->is->name, ch->is->cmsb, ch->is->clsb);\r\nskb_trim(ch->bch.rx_skb, 0);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nbreak;\r\n}\r\nif (ch->is->cmsb & HDLC_FSD)\r\nskb_trim(ch->bch.rx_skb, 0);\r\nptr = skb_put(ch->bch.rx_skb, ch->is->clsb);\r\nrcv_mbox(ch->is, ptr);\r\nif (ch->is->cmsb & HDLC_FED) {\r\nif (ch->bch.rx_skb->len < 3) {\r\npr_info("%s: ISAR frame to short %d\n",\r\nch->is->name, ch->bch.rx_skb->len);\r\nskb_trim(ch->bch.rx_skb, 0);\r\nbreak;\r\n}\r\nskb_trim(ch->bch.rx_skb, ch->bch.rx_skb->len - 2);\r\nrecv_Bchannel(&ch->bch, 0);\r\n}\r\nif (ch->is->cmsb & SART_NMD) {\r\npr_debug("%s: isar_rcv_frame: no more data\n",\r\nch->is->name);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nif (ch->bch.rx_skb)\r\nskb_trim(ch->bch.rx_skb, 0);\r\nsend_mbox(ch->is, SET_DPS(ch->dpath) |\r\nISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC, 0, NULL);\r\nch->state = STFAX_ESCAPE;\r\ndeliver_status(ch, HW_MOD_NOCARR);\r\n}\r\nbreak;\r\ndefault:\r\npr_info("isar_rcv_frame protocol (%x)error\n", ch->bch.state);\r\nch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nisar_fill_fifo(struct isar_ch *ch)\r\n{\r\nint count;\r\nu8 msb;\r\nu8 *ptr;\r\npr_debug("%s: ch%d tx_skb %p tx_idx %d\n",\r\nch->is->name, ch->bch.nr, ch->bch.tx_skb, ch->bch.tx_idx);\r\nif (!ch->bch.tx_skb)\r\nreturn;\r\ncount = ch->bch.tx_skb->len - ch->bch.tx_idx;\r\nif (count <= 0)\r\nreturn;\r\nif (!(ch->is->bstat &\r\n(ch->dpath == 1 ? BSTAT_RDM1 : BSTAT_RDM2)))\r\nreturn;\r\nif (count > ch->mml) {\r\nmsb = 0;\r\ncount = ch->mml;\r\n} else {\r\nmsb = HDLC_FED;\r\n}\r\nptr = ch->bch.tx_skb->data + ch->bch.tx_idx;\r\nif (!ch->bch.tx_idx) {\r\npr_debug("%s: frame start\n", ch->is->name);\r\nif ((ch->bch.state == ISDN_P_B_T30_FAX) &&\r\n(ch->cmd == PCTRL_CMD_FTH)) {\r\nif (count > 1) {\r\nif ((ptr[0] == 0xff) && (ptr[1] == 0x13)) {\r\ntest_and_set_bit(FLG_LASTDATA,\r\n&ch->bch.Flags);\r\npr_debug("%s: set LASTDATA\n",\r\nch->is->name);\r\nif (msb == HDLC_FED)\r\ntest_and_set_bit(FLG_DLEETX,\r\n&ch->bch.Flags);\r\n}\r\n}\r\n}\r\nmsb |= HDLC_FST;\r\n}\r\nch->bch.tx_idx += count;\r\nswitch (ch->bch.state) {\r\ncase ISDN_P_NONE:\r\npr_info("%s: wrong protocol 0\n", __func__);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\ncase ISDN_P_B_L2DTMF:\r\ncase ISDN_P_B_MODEM_ASYNC:\r\nsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\r\n0, count, ptr);\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\nsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\r\nmsb, count, ptr);\r\nbreak;\r\ncase ISDN_P_B_T30_FAX:\r\nif (ch->state != STFAX_ACTIV)\r\npr_debug("%s: not ACTIV\n", ch->is->name);\r\nelse if (ch->cmd == PCTRL_CMD_FTH)\r\nsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\r\nmsb, count, ptr);\r\nelse if (ch->cmd == PCTRL_CMD_FTM)\r\nsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\r\n0, count, ptr);\r\nelse\r\npr_debug("%s: not FTH/FTM\n", ch->is->name);\r\nbreak;\r\ndefault:\r\npr_info("%s: protocol(%x) error\n",\r\n__func__, ch->bch.state);\r\nbreak;\r\n}\r\n}\r\nstatic inline struct isar_ch *\r\nsel_bch_isar(struct isar_hw *isar, u8 dpath)\r\n{\r\nstruct isar_ch *base = &isar->ch[0];\r\nif ((!dpath) || (dpath > 2))\r\nreturn NULL;\r\nif (base->dpath == dpath)\r\nreturn base;\r\nbase++;\r\nif (base->dpath == dpath)\r\nreturn base;\r\nreturn NULL;\r\n}\r\nstatic void\r\nsend_next(struct isar_ch *ch)\r\n{\r\npr_debug("%s: %s ch%d tx_skb %p tx_idx %d\n",\r\nch->is->name, __func__, ch->bch.nr,\r\nch->bch.tx_skb, ch->bch.tx_idx);\r\nif (ch->bch.state == ISDN_P_B_T30_FAX) {\r\nif (ch->cmd == PCTRL_CMD_FTH) {\r\nif (test_bit(FLG_LASTDATA, &ch->bch.Flags)) {\r\npr_debug("set NMD_DATA\n");\r\ntest_and_set_bit(FLG_NMD_DATA, &ch->bch.Flags);\r\n}\r\n} else if (ch->cmd == PCTRL_CMD_FTM) {\r\nif (test_bit(FLG_DLEETX, &ch->bch.Flags)) {\r\ntest_and_set_bit(FLG_LASTDATA, &ch->bch.Flags);\r\ntest_and_set_bit(FLG_NMD_DATA, &ch->bch.Flags);\r\n}\r\n}\r\n}\r\nif (ch->bch.tx_skb) {\r\nif (test_bit(FLG_TRANSPARENT, &ch->bch.Flags))\r\nconfirm_Bsend(&ch->bch);\r\ndev_kfree_skb(ch->bch.tx_skb);\r\n}\r\nif (get_next_bframe(&ch->bch))\r\nisar_fill_fifo(ch);\r\nelse {\r\nif (test_and_clear_bit(FLG_DLEETX, &ch->bch.Flags)) {\r\nif (test_and_clear_bit(FLG_LASTDATA,\r\n&ch->bch.Flags)) {\r\nif (test_and_clear_bit(FLG_NMD_DATA,\r\n&ch->bch.Flags)) {\r\nu8 zd = 0;\r\nsend_mbox(ch->is, SET_DPS(ch->dpath) |\r\nISAR_HIS_SDATA, 0x01, 1, &zd);\r\n}\r\ntest_and_set_bit(FLG_LL_OK, &ch->bch.Flags);\r\n} else {\r\ndeliver_status(ch, HW_MOD_CONNECT);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\ncheck_send(struct isar_hw *isar, u8 rdm)\r\n{\r\nstruct isar_ch *ch;\r\npr_debug("%s: rdm %x\n", isar->name, rdm);\r\nif (rdm & BSTAT_RDM1) {\r\nch = sel_bch_isar(isar, 1);\r\nif (ch && test_bit(FLG_ACTIVE, &ch->bch.Flags)) {\r\nif (ch->bch.tx_skb && (ch->bch.tx_skb->len >\r\nch->bch.tx_idx))\r\nisar_fill_fifo(ch);\r\nelse\r\nsend_next(ch);\r\n}\r\n}\r\nif (rdm & BSTAT_RDM2) {\r\nch = sel_bch_isar(isar, 2);\r\nif (ch && test_bit(FLG_ACTIVE, &ch->bch.Flags)) {\r\nif (ch->bch.tx_skb && (ch->bch.tx_skb->len >\r\nch->bch.tx_idx))\r\nisar_fill_fifo(ch);\r\nelse\r\nsend_next(ch);\r\n}\r\n}\r\n}\r\nstatic void\r\nisar_pump_status_rsp(struct isar_ch *ch) {\r\nu8 ril = ch->is->buf[0];\r\nu8 rim;\r\nif (!test_and_clear_bit(ISAR_RATE_REQ, &ch->is->Flags))\r\nreturn;\r\nif (ril > 14) {\r\npr_info("%s: wrong pstrsp ril=%d\n", ch->is->name, ril);\r\nril = 15;\r\n}\r\nswitch (ch->is->buf[1]) {\r\ncase 0:\r\nrim = 0;\r\nbreak;\r\ncase 0x20:\r\nrim = 2;\r\nbreak;\r\ncase 0x40:\r\nrim = 3;\r\nbreak;\r\ncase 0x41:\r\nrim = 4;\r\nbreak;\r\ncase 0x51:\r\nrim = 5;\r\nbreak;\r\ncase 0x61:\r\nrim = 6;\r\nbreak;\r\ncase 0x71:\r\nrim = 7;\r\nbreak;\r\ncase 0x82:\r\nrim = 8;\r\nbreak;\r\ncase 0x92:\r\nrim = 9;\r\nbreak;\r\ncase 0xa2:\r\nrim = 10;\r\nbreak;\r\ndefault:\r\nrim = 1;\r\nbreak;\r\n}\r\nsprintf(ch->conmsg, "%s %s", dmril[ril], dmrim[rim]);\r\npr_debug("%s: pump strsp %s\n", ch->is->name, ch->conmsg);\r\n}\r\nstatic void\r\nisar_pump_statev_modem(struct isar_ch *ch, u8 devt) {\r\nu8 dps = SET_DPS(ch->dpath);\r\nswitch (devt) {\r\ncase PSEV_10MS_TIMER:\r\npr_debug("%s: pump stev TIMER\n", ch->is->name);\r\nbreak;\r\ncase PSEV_CON_ON:\r\npr_debug("%s: pump stev CONNECT\n", ch->is->name);\r\ndeliver_status(ch, HW_MOD_CONNECT);\r\nbreak;\r\ncase PSEV_CON_OFF:\r\npr_debug("%s: pump stev NO CONNECT\n", ch->is->name);\r\nsend_mbox(ch->is, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\r\ndeliver_status(ch, HW_MOD_NOCARR);\r\nbreak;\r\ncase PSEV_V24_OFF:\r\npr_debug("%s: pump stev V24 OFF\n", ch->is->name);\r\nbreak;\r\ncase PSEV_CTS_ON:\r\npr_debug("%s: pump stev CTS ON\n", ch->is->name);\r\nbreak;\r\ncase PSEV_CTS_OFF:\r\npr_debug("%s pump stev CTS OFF\n", ch->is->name);\r\nbreak;\r\ncase PSEV_DCD_ON:\r\npr_debug("%s: pump stev CARRIER ON\n", ch->is->name);\r\ntest_and_set_bit(ISAR_RATE_REQ, &ch->is->Flags);\r\nsend_mbox(ch->is, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\r\nbreak;\r\ncase PSEV_DCD_OFF:\r\npr_debug("%s: pump stev CARRIER OFF\n", ch->is->name);\r\nbreak;\r\ncase PSEV_DSR_ON:\r\npr_debug("%s: pump stev DSR ON\n", ch->is->name);\r\nbreak;\r\ncase PSEV_DSR_OFF:\r\npr_debug("%s: pump stev DSR_OFF\n", ch->is->name);\r\nbreak;\r\ncase PSEV_REM_RET:\r\npr_debug("%s: pump stev REMOTE RETRAIN\n", ch->is->name);\r\nbreak;\r\ncase PSEV_REM_REN:\r\npr_debug("%s: pump stev REMOTE RENEGOTIATE\n", ch->is->name);\r\nbreak;\r\ncase PSEV_GSTN_CLR:\r\npr_debug("%s: pump stev GSTN CLEAR\n", ch->is->name);\r\nbreak;\r\ndefault:\r\npr_info("u%s: unknown pump stev %x\n", ch->is->name, devt);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nisar_pump_statev_fax(struct isar_ch *ch, u8 devt) {\r\nu8 dps = SET_DPS(ch->dpath);\r\nu8 p1;\r\nswitch (devt) {\r\ncase PSEV_10MS_TIMER:\r\npr_debug("%s: pump stev TIMER\n", ch->is->name);\r\nbreak;\r\ncase PSEV_RSP_READY:\r\npr_debug("%s: pump stev RSP_READY\n", ch->is->name);\r\nch->state = STFAX_READY;\r\ndeliver_status(ch, HW_MOD_READY);\r\n#ifdef AUTOCON\r\nif (test_bit(BC_FLG_ORIG, &ch->bch.Flags))\r\nisar_pump_cmd(bch, HW_MOD_FRH, 3);\r\nelse\r\nisar_pump_cmd(bch, HW_MOD_FTH, 3);\r\n#endif\r\nbreak;\r\ncase PSEV_LINE_TX_H:\r\nif (ch->state == STFAX_LINE) {\r\npr_debug("%s: pump stev LINE_TX_H\n", ch->is->name);\r\nch->state = STFAX_CONT;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\r\nPCTRL_CMD_CONT, 0, NULL);\r\n} else {\r\npr_debug("%s: pump stev LINE_TX_H wrong st %x\n",\r\nch->is->name, ch->state);\r\n}\r\nbreak;\r\ncase PSEV_LINE_RX_H:\r\nif (ch->state == STFAX_LINE) {\r\npr_debug("%s: pump stev LINE_RX_H\n", ch->is->name);\r\nch->state = STFAX_CONT;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\r\nPCTRL_CMD_CONT, 0, NULL);\r\n} else {\r\npr_debug("%s: pump stev LINE_RX_H wrong st %x\n",\r\nch->is->name, ch->state);\r\n}\r\nbreak;\r\ncase PSEV_LINE_TX_B:\r\nif (ch->state == STFAX_LINE) {\r\npr_debug("%s: pump stev LINE_TX_B\n", ch->is->name);\r\nch->state = STFAX_CONT;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\r\nPCTRL_CMD_CONT, 0, NULL);\r\n} else {\r\npr_debug("%s: pump stev LINE_TX_B wrong st %x\n",\r\nch->is->name, ch->state);\r\n}\r\nbreak;\r\ncase PSEV_LINE_RX_B:\r\nif (ch->state == STFAX_LINE) {\r\npr_debug("%s: pump stev LINE_RX_B\n", ch->is->name);\r\nch->state = STFAX_CONT;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\r\nPCTRL_CMD_CONT, 0, NULL);\r\n} else {\r\npr_debug("%s: pump stev LINE_RX_B wrong st %x\n",\r\nch->is->name, ch->state);\r\n}\r\nbreak;\r\ncase PSEV_RSP_CONN:\r\nif (ch->state == STFAX_CONT) {\r\npr_debug("%s: pump stev RSP_CONN\n", ch->is->name);\r\nch->state = STFAX_ACTIV;\r\ntest_and_set_bit(ISAR_RATE_REQ, &ch->is->Flags);\r\nsend_mbox(ch->is, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\r\nif (ch->cmd == PCTRL_CMD_FTH) {\r\nint delay = (ch->mod == 3) ? 1000 : 200;\r\nif (test_and_set_bit(FLG_FTI_RUN,\r\n&ch->bch.Flags))\r\ndel_timer(&ch->ftimer);\r\nch->ftimer.expires =\r\njiffies + ((delay * HZ)/1000);\r\ntest_and_set_bit(FLG_LL_CONN,\r\n&ch->bch.Flags);\r\nadd_timer(&ch->ftimer);\r\n} else {\r\ndeliver_status(ch, HW_MOD_CONNECT);\r\n}\r\n} else {\r\npr_debug("%s: pump stev RSP_CONN wrong st %x\n",\r\nch->is->name, ch->state);\r\n}\r\nbreak;\r\ncase PSEV_FLAGS_DET:\r\npr_debug("%s: pump stev FLAGS_DET\n", ch->is->name);\r\nbreak;\r\ncase PSEV_RSP_DISC:\r\npr_debug("%s: pump stev RSP_DISC state(%d)\n",\r\nch->is->name, ch->state);\r\nif (ch->state == STFAX_ESCAPE) {\r\np1 = 5;\r\nswitch (ch->newcmd) {\r\ncase 0:\r\nch->state = STFAX_READY;\r\nbreak;\r\ncase PCTRL_CMD_FTM:\r\np1 = 2;\r\ncase PCTRL_CMD_FTH:\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\r\nPCTRL_CMD_SILON, 1, &p1);\r\nch->state = STFAX_SILDET;\r\nbreak;\r\ncase PCTRL_CMD_FRH:\r\ncase PCTRL_CMD_FRM:\r\nch->mod = ch->newmod;\r\np1 = ch->newmod;\r\nch->newmod = 0;\r\nch->cmd = ch->newcmd;\r\nch->newcmd = 0;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\r\nch->cmd, 1, &p1);\r\nch->state = STFAX_LINE;\r\nch->try_mod = 3;\r\nbreak;\r\ndefault:\r\npr_debug("%s: RSP_DISC unknown newcmd %x\n",\r\nch->is->name, ch->newcmd);\r\nbreak;\r\n}\r\n} else if (ch->state == STFAX_ACTIV) {\r\nif (test_and_clear_bit(FLG_LL_OK, &ch->bch.Flags))\r\ndeliver_status(ch, HW_MOD_OK);\r\nelse if (ch->cmd == PCTRL_CMD_FRM)\r\ndeliver_status(ch, HW_MOD_NOCARR);\r\nelse\r\ndeliver_status(ch, HW_MOD_FCERROR);\r\nch->state = STFAX_READY;\r\n} else if (ch->state != STFAX_SILDET) {\r\nch->state = STFAX_READY;\r\ndeliver_status(ch, HW_MOD_FCERROR);\r\n}\r\nbreak;\r\ncase PSEV_RSP_SILDET:\r\npr_debug("%s: pump stev RSP_SILDET\n", ch->is->name);\r\nif (ch->state == STFAX_SILDET) {\r\nch->mod = ch->newmod;\r\np1 = ch->newmod;\r\nch->newmod = 0;\r\nch->cmd = ch->newcmd;\r\nch->newcmd = 0;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\r\nch->cmd, 1, &p1);\r\nch->state = STFAX_LINE;\r\nch->try_mod = 3;\r\n}\r\nbreak;\r\ncase PSEV_RSP_SILOFF:\r\npr_debug("%s: pump stev RSP_SILOFF\n", ch->is->name);\r\nbreak;\r\ncase PSEV_RSP_FCERR:\r\nif (ch->state == STFAX_LINE) {\r\npr_debug("%s: pump stev RSP_FCERR try %d\n",\r\nch->is->name, ch->try_mod);\r\nif (ch->try_mod--) {\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\r\nch->cmd, 1, &ch->mod);\r\nbreak;\r\n}\r\n}\r\npr_debug("%s: pump stev RSP_FCERR\n", ch->is->name);\r\nch->state = STFAX_ESCAPE;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC,\r\n0, NULL);\r\ndeliver_status(ch, HW_MOD_FCERROR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid\r\nmISDNisar_irq(struct isar_hw *isar)\r\n{\r\nstruct isar_ch *ch;\r\nget_irq_infos(isar);\r\nswitch (isar->iis & ISAR_IIS_MSCMSD) {\r\ncase ISAR_IIS_RDATA:\r\nch = sel_bch_isar(isar, isar->iis >> 6);\r\nif (ch)\r\nisar_rcv_frame(ch);\r\nelse {\r\npr_debug("%s: ISAR spurious IIS_RDATA %x/%x/%x\n",\r\nisar->name, isar->iis, isar->cmsb,\r\nisar->clsb);\r\nisar->write_reg(isar->hw, ISAR_IIA, 0);\r\n}\r\nbreak;\r\ncase ISAR_IIS_GSTEV:\r\nisar->write_reg(isar->hw, ISAR_IIA, 0);\r\nisar->bstat |= isar->cmsb;\r\ncheck_send(isar, isar->cmsb);\r\nbreak;\r\ncase ISAR_IIS_BSTEV:\r\n#ifdef ERROR_STATISTIC\r\nch = sel_bch_isar(isar, isar->iis >> 6);\r\nif (ch) {\r\nif (isar->cmsb == BSTEV_TBO)\r\nch->bch.err_tx++;\r\nif (isar->cmsb == BSTEV_RBO)\r\nch->bch.err_rdo++;\r\n}\r\n#endif\r\npr_debug("%s: Buffer STEV dpath%d msb(%x)\n",\r\nisar->name, isar->iis>>6, isar->cmsb);\r\nisar->write_reg(isar->hw, ISAR_IIA, 0);\r\nbreak;\r\ncase ISAR_IIS_PSTEV:\r\nch = sel_bch_isar(isar, isar->iis >> 6);\r\nif (ch) {\r\nrcv_mbox(isar, NULL);\r\nif (ch->bch.state == ISDN_P_B_MODEM_ASYNC)\r\nisar_pump_statev_modem(ch, isar->cmsb);\r\nelse if (ch->bch.state == ISDN_P_B_T30_FAX)\r\nisar_pump_statev_fax(ch, isar->cmsb);\r\nelse if (ch->bch.state == ISDN_P_B_RAW) {\r\nint tt;\r\ntt = isar->cmsb | 0x30;\r\nif (tt == 0x3e)\r\ntt = '*';\r\nelse if (tt == 0x3f)\r\ntt = '#';\r\nelse if (tt > '9')\r\ntt += 7;\r\ntt |= DTMF_TONE_VAL;\r\n_queue_data(&ch->bch.ch, PH_CONTROL_IND,\r\nMISDN_ID_ANY, sizeof(tt), &tt,\r\nGFP_ATOMIC);\r\n} else\r\npr_debug("%s: ISAR IIS_PSTEV pm %d sta %x\n",\r\nisar->name, ch->bch.state,\r\nisar->cmsb);\r\n} else {\r\npr_debug("%s: ISAR spurious IIS_PSTEV %x/%x/%x\n",\r\nisar->name, isar->iis, isar->cmsb,\r\nisar->clsb);\r\nisar->write_reg(isar->hw, ISAR_IIA, 0);\r\n}\r\nbreak;\r\ncase ISAR_IIS_PSTRSP:\r\nch = sel_bch_isar(isar, isar->iis >> 6);\r\nif (ch) {\r\nrcv_mbox(isar, NULL);\r\nisar_pump_status_rsp(ch);\r\n} else {\r\npr_debug("%s: ISAR spurious IIS_PSTRSP %x/%x/%x\n",\r\nisar->name, isar->iis, isar->cmsb,\r\nisar->clsb);\r\nisar->write_reg(isar->hw, ISAR_IIA, 0);\r\n}\r\nbreak;\r\ncase ISAR_IIS_DIAG:\r\ncase ISAR_IIS_BSTRSP:\r\ncase ISAR_IIS_IOM2RSP:\r\nrcv_mbox(isar, NULL);\r\nbreak;\r\ncase ISAR_IIS_INVMSG:\r\nrcv_mbox(isar, NULL);\r\npr_debug("%s: invalid msg his:%x\n", isar->name, isar->cmsb);\r\nbreak;\r\ndefault:\r\nrcv_mbox(isar, NULL);\r\npr_debug("%s: unhandled msg iis(%x) ctrl(%x/%x)\n",\r\nisar->name, isar->iis, isar->cmsb, isar->clsb);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nftimer_handler(unsigned long data)\r\n{\r\nstruct isar_ch *ch = (struct isar_ch *)data;\r\npr_debug("%s: ftimer flags %lx\n", ch->is->name, ch->bch.Flags);\r\ntest_and_clear_bit(FLG_FTI_RUN, &ch->bch.Flags);\r\nif (test_and_clear_bit(FLG_LL_CONN, &ch->bch.Flags))\r\ndeliver_status(ch, HW_MOD_CONNECT);\r\n}\r\nstatic void\r\nsetup_pump(struct isar_ch *ch) {\r\nu8 dps = SET_DPS(ch->dpath);\r\nu8 ctrl, param[6];\r\nswitch (ch->bch.state) {\r\ncase ISDN_P_NONE:\r\ncase ISDN_P_B_RAW:\r\ncase ISDN_P_B_HDLC:\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG, PMOD_BYPASS, 0, NULL);\r\nbreak;\r\ncase ISDN_P_B_L2DTMF:\r\nif (test_bit(FLG_DTMFSEND, &ch->bch.Flags)) {\r\nparam[0] = 5;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG,\r\nPMOD_DTMF_TRANS, 1, param);\r\n} else {\r\nparam[0] = 40;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG,\r\nPMOD_DTMF, 1, param);\r\n}\r\ncase ISDN_P_B_MODEM_ASYNC:\r\nctrl = PMOD_DATAMODEM;\r\nif (test_bit(FLG_ORIGIN, &ch->bch.Flags)) {\r\nctrl |= PCTRL_ORIG;\r\nparam[5] = PV32P6_CTN;\r\n} else {\r\nparam[5] = PV32P6_ATN;\r\n}\r\nparam[0] = 6;\r\nparam[1] = PV32P2_V23R | PV32P2_V22A | PV32P2_V22B |\r\nPV32P2_V22C | PV32P2_V21 | PV32P2_BEL;\r\nparam[2] = PV32P3_AMOD | PV32P3_V32B | PV32P3_V23B;\r\nparam[3] = PV32P4_UT144;\r\nparam[4] = PV32P5_UT144;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG, ctrl, 6, param);\r\nbreak;\r\ncase ISDN_P_B_T30_FAX:\r\nctrl = PMOD_FAX;\r\nif (test_bit(FLG_ORIGIN, &ch->bch.Flags)) {\r\nctrl |= PCTRL_ORIG;\r\nparam[1] = PFAXP2_CTN;\r\n} else {\r\nparam[1] = PFAXP2_ATN;\r\n}\r\nparam[0] = 6;\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG, ctrl, 2, param);\r\nch->state = STFAX_NULL;\r\nch->newcmd = 0;\r\nch->newmod = 0;\r\ntest_and_set_bit(FLG_FTI_RUN, &ch->bch.Flags);\r\nbreak;\r\n}\r\nudelay(1000);\r\nsend_mbox(ch->is, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\r\nudelay(1000);\r\n}\r\nstatic void\r\nsetup_sart(struct isar_ch *ch) {\r\nu8 dps = SET_DPS(ch->dpath);\r\nu8 ctrl, param[2] = {0, 0};\r\nswitch (ch->bch.state) {\r\ncase ISDN_P_NONE:\r\nsend_mbox(ch->is, dps | ISAR_HIS_SARTCFG, SMODE_DISABLE,\r\n0, NULL);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\ncase ISDN_P_B_L2DTMF:\r\nsend_mbox(ch->is, dps | ISAR_HIS_SARTCFG, SMODE_BINARY,\r\n2, param);\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\ncase ISDN_P_B_T30_FAX:\r\nsend_mbox(ch->is, dps | ISAR_HIS_SARTCFG, SMODE_HDLC,\r\n1, param);\r\nbreak;\r\ncase ISDN_P_B_MODEM_ASYNC:\r\nctrl = SMODE_V14 | SCTRL_HDMC_BOTH;\r\nparam[0] = S_P1_CHS_8;\r\nparam[1] = S_P2_BFT_DEF;\r\nsend_mbox(ch->is, dps | ISAR_HIS_SARTCFG, ctrl, 2, param);\r\nbreak;\r\n}\r\nudelay(1000);\r\nsend_mbox(ch->is, dps | ISAR_HIS_BSTREQ, 0, 0, NULL);\r\nudelay(1000);\r\n}\r\nstatic void\r\nsetup_iom2(struct isar_ch *ch) {\r\nu8 dps = SET_DPS(ch->dpath);\r\nu8 cmsb = IOM_CTRL_ENA, msg[5] = {IOM_P1_TXD, 0, 0, 0, 0};\r\nif (ch->bch.nr == 2) {\r\nmsg[1] = 1;\r\nmsg[3] = 1;\r\n}\r\nswitch (ch->bch.state) {\r\ncase ISDN_P_NONE:\r\ncmsb = 0;\r\nmsg[1] = ch->dpath + 2;\r\nmsg[3] = ch->dpath + 2;\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\ncase ISDN_P_B_HDLC:\r\nbreak;\r\ncase ISDN_P_B_MODEM_ASYNC:\r\ncase ISDN_P_B_T30_FAX:\r\ncmsb |= IOM_CTRL_RCV;\r\ncase ISDN_P_B_L2DTMF:\r\nif (test_bit(FLG_DTMFSEND, &ch->bch.Flags))\r\ncmsb |= IOM_CTRL_RCV;\r\ncmsb |= IOM_CTRL_ALAW;\r\nbreak;\r\n}\r\nsend_mbox(ch->is, dps | ISAR_HIS_IOM2CFG, cmsb, 5, msg);\r\nudelay(1000);\r\nsend_mbox(ch->is, dps | ISAR_HIS_IOM2REQ, 0, 0, NULL);\r\nudelay(1000);\r\n}\r\nstatic int\r\nmodeisar(struct isar_ch *ch, u32 bprotocol)\r\n{\r\nif (ch->bch.state == ISDN_P_NONE) {\r\nswitch (bprotocol) {\r\ncase ISDN_P_NONE:\r\nif (!ch->dpath)\r\nreturn 0;\r\ntest_and_clear_bit(FLG_HDLC, &ch->bch.Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT, &ch->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\ncase ISDN_P_B_HDLC:\r\nif (!test_and_set_bit(ISAR_DP2_USE, &ch->is->Flags))\r\nch->dpath = 2;\r\nelse if (!test_and_set_bit(ISAR_DP1_USE,\r\n&ch->is->Flags))\r\nch->dpath = 1;\r\nelse {\r\npr_info("modeisar both pathes in use\n");\r\nreturn -EBUSY;\r\n}\r\nif (bprotocol == ISDN_P_B_HDLC)\r\ntest_and_set_bit(FLG_HDLC, &ch->bch.Flags);\r\nelse\r\ntest_and_set_bit(FLG_TRANSPARENT,\r\n&ch->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_MODEM_ASYNC:\r\ncase ISDN_P_B_T30_FAX:\r\ncase ISDN_P_B_L2DTMF:\r\nif (!test_and_set_bit(ISAR_DP1_USE, &ch->is->Flags))\r\nch->dpath = 1;\r\nelse {\r\npr_info("%s: ISAR modeisar analog functions"\r\n"only with DP1\n", ch->is->name);\r\nreturn -EBUSY;\r\n}\r\nbreak;\r\ndefault:\r\npr_info("%s: protocol not known %x\n", ch->is->name,\r\nbprotocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\n}\r\npr_debug("%s: ISAR ch%d dp%d protocol %x->%x\n", ch->is->name,\r\nch->bch.nr, ch->dpath, ch->bch.state, bprotocol);\r\nch->bch.state = bprotocol;\r\nsetup_pump(ch);\r\nsetup_iom2(ch);\r\nsetup_sart(ch);\r\nif (ch->bch.state == ISDN_P_NONE) {\r\nif (ch->dpath == 1)\r\ntest_and_clear_bit(ISAR_DP1_USE, &ch->is->Flags);\r\nelse if (ch->dpath == 2)\r\ntest_and_clear_bit(ISAR_DP2_USE, &ch->is->Flags);\r\nch->dpath = 0;\r\nch->is->ctrl(ch->is->hw, HW_DEACT_IND, ch->bch.nr);\r\n} else\r\nch->is->ctrl(ch->is->hw, HW_ACTIVATE_IND, ch->bch.nr);\r\nreturn 0;\r\n}\r\nstatic void\r\nisar_pump_cmd(struct isar_ch *ch, u32 cmd, u8 para)\r\n{\r\nu8 dps = SET_DPS(ch->dpath);\r\nu8 ctrl = 0, nom = 0, p1 = 0;\r\npr_debug("%s: isar_pump_cmd %x/%x state(%x)\n",\r\nch->is->name, cmd, para, ch->bch.state);\r\nswitch (cmd) {\r\ncase HW_MOD_FTM:\r\nif (ch->state == STFAX_READY) {\r\np1 = para;\r\nctrl = PCTRL_CMD_FTM;\r\nnom = 1;\r\nch->state = STFAX_LINE;\r\nch->cmd = ctrl;\r\nch->mod = para;\r\nch->newmod = 0;\r\nch->newcmd = 0;\r\nch->try_mod = 3;\r\n} else if ((ch->state == STFAX_ACTIV) &&\r\n(ch->cmd == PCTRL_CMD_FTM) && (ch->mod == para))\r\ndeliver_status(ch, HW_MOD_CONNECT);\r\nelse {\r\nch->newmod = para;\r\nch->newcmd = PCTRL_CMD_FTM;\r\nnom = 0;\r\nctrl = PCTRL_CMD_ESC;\r\nch->state = STFAX_ESCAPE;\r\n}\r\nbreak;\r\ncase HW_MOD_FTH:\r\nif (ch->state == STFAX_READY) {\r\np1 = para;\r\nctrl = PCTRL_CMD_FTH;\r\nnom = 1;\r\nch->state = STFAX_LINE;\r\nch->cmd = ctrl;\r\nch->mod = para;\r\nch->newmod = 0;\r\nch->newcmd = 0;\r\nch->try_mod = 3;\r\n} else if ((ch->state == STFAX_ACTIV) &&\r\n(ch->cmd == PCTRL_CMD_FTH) && (ch->mod == para))\r\ndeliver_status(ch, HW_MOD_CONNECT);\r\nelse {\r\nch->newmod = para;\r\nch->newcmd = PCTRL_CMD_FTH;\r\nnom = 0;\r\nctrl = PCTRL_CMD_ESC;\r\nch->state = STFAX_ESCAPE;\r\n}\r\nbreak;\r\ncase HW_MOD_FRM:\r\nif (ch->state == STFAX_READY) {\r\np1 = para;\r\nctrl = PCTRL_CMD_FRM;\r\nnom = 1;\r\nch->state = STFAX_LINE;\r\nch->cmd = ctrl;\r\nch->mod = para;\r\nch->newmod = 0;\r\nch->newcmd = 0;\r\nch->try_mod = 3;\r\n} else if ((ch->state == STFAX_ACTIV) &&\r\n(ch->cmd == PCTRL_CMD_FRM) && (ch->mod == para))\r\ndeliver_status(ch, HW_MOD_CONNECT);\r\nelse {\r\nch->newmod = para;\r\nch->newcmd = PCTRL_CMD_FRM;\r\nnom = 0;\r\nctrl = PCTRL_CMD_ESC;\r\nch->state = STFAX_ESCAPE;\r\n}\r\nbreak;\r\ncase HW_MOD_FRH:\r\nif (ch->state == STFAX_READY) {\r\np1 = para;\r\nctrl = PCTRL_CMD_FRH;\r\nnom = 1;\r\nch->state = STFAX_LINE;\r\nch->cmd = ctrl;\r\nch->mod = para;\r\nch->newmod = 0;\r\nch->newcmd = 0;\r\nch->try_mod = 3;\r\n} else if ((ch->state == STFAX_ACTIV) &&\r\n(ch->cmd == PCTRL_CMD_FRH) && (ch->mod == para))\r\ndeliver_status(ch, HW_MOD_CONNECT);\r\nelse {\r\nch->newmod = para;\r\nch->newcmd = PCTRL_CMD_FRH;\r\nnom = 0;\r\nctrl = PCTRL_CMD_ESC;\r\nch->state = STFAX_ESCAPE;\r\n}\r\nbreak;\r\ncase PCTRL_CMD_TDTMF:\r\np1 = para;\r\nnom = 1;\r\nctrl = PCTRL_CMD_TDTMF;\r\nbreak;\r\n}\r\nif (ctrl)\r\nsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL, ctrl, nom, &p1);\r\n}\r\nstatic void\r\nisar_setup(struct isar_hw *isar)\r\n{\r\nu8 msg;\r\nint i;\r\nmsg = 61;\r\nfor (i = 0; i < 2; i++) {\r\nsend_mbox(isar, (i ? ISAR_HIS_DPS2 : ISAR_HIS_DPS1) |\r\nISAR_HIS_P12CFG, 4, 1, &msg);\r\nisar->ch[i].mml = msg;\r\nisar->ch[i].bch.state = 0;\r\nisar->ch[i].dpath = i + 1;\r\nmodeisar(&isar->ch[i], ISDN_P_NONE);\r\n}\r\n}\r\nstatic int\r\nisar_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct isar_ch *ich = container_of(bch, struct isar_ch, bch);\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nu32 id, *val;\r\nu_long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(ich->is->hwlock, flags);\r\nret = bchannel_senddata(bch, skb);\r\nif (ret > 0) {\r\nid = hh->id;\r\nret = 0;\r\nisar_fill_fifo(ich);\r\nspin_unlock_irqrestore(ich->is->hwlock, flags);\r\nif (!test_bit(FLG_TRANSPARENT, &bch->Flags))\r\nqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\r\n} else\r\nspin_unlock_irqrestore(ich->is->hwlock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nspin_lock_irqsave(ich->is->hwlock, flags);\r\nif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\r\nret = modeisar(ich, ch->protocol);\r\nelse\r\nret = 0;\r\nspin_unlock_irqrestore(ich->is->hwlock, flags);\r\nif (!ret)\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\nspin_lock_irqsave(ich->is->hwlock, flags);\r\nmISDN_clear_bchannel(bch);\r\nmodeisar(ich, ISDN_P_NONE);\r\nspin_unlock_irqrestore(ich->is->hwlock, flags);\r\n_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nret = 0;\r\nbreak;\r\ncase PH_CONTROL_REQ:\r\nval = (u32 *)skb->data;\r\npr_debug("%s: PH_CONTROL | REQUEST %x/%x\n", ich->is->name,\r\nhh->id, *val);\r\nif ((hh->id == 0) && ((*val & ~DTMF_TONE_MASK) ==\r\nDTMF_TONE_VAL)) {\r\nif (bch->state == ISDN_P_B_L2DTMF) {\r\nchar tt = *val & DTMF_TONE_MASK;\r\nif (tt == '*')\r\ntt = 0x1e;\r\nelse if (tt == '#')\r\ntt = 0x1f;\r\nelse if (tt > '9')\r\ntt -= 7;\r\ntt &= 0x1f;\r\nspin_lock_irqsave(ich->is->hwlock, flags);\r\nisar_pump_cmd(ich, PCTRL_CMD_TDTMF, tt);\r\nspin_unlock_irqrestore(ich->is->hwlock, flags);\r\n} else {\r\npr_info("%s: DTMF send wrong protocol %x\n",\r\n__func__, bch->state);\r\nreturn -EINVAL;\r\n}\r\n} else if ((hh->id == HW_MOD_FRM) || (hh->id == HW_MOD_FRH) ||\r\n(hh->id == HW_MOD_FTM) || (hh->id == HW_MOD_FTH)) {\r\nfor (id = 0; id < FAXMODCNT; id++)\r\nif (faxmodulation[id] == *val)\r\nbreak;\r\nif ((FAXMODCNT > id) &&\r\ntest_bit(FLG_INITIALIZED, &bch->Flags)) {\r\npr_debug("%s: isar: new mod\n", ich->is->name);\r\nisar_pump_cmd(ich, hh->id, *val);\r\nret = 0;\r\n} else {\r\npr_info("%s: wrong modulation\n",\r\nich->is->name);\r\nret = -EINVAL;\r\n}\r\n} else if (hh->id == HW_MOD_LASTDATA)\r\ntest_and_set_bit(FLG_DLEETX, &bch->Flags);\r\nelse {\r\npr_info("%s: unknown PH_CONTROL_REQ %x\n",\r\nich->is->name, hh->id);\r\nret = -EINVAL;\r\n}\r\ndefault:\r\npr_info("%s: %s unknown prim(%x,%x)\n",\r\nich->is->name, __func__, hh->prim, hh->id);\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = 0;\r\nbreak;\r\ncase MISDN_CTRL_FILL_EMPTY:\r\ndefault:\r\npr_info("%s: unknown Op %x\n", __func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nisar_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct isar_ch *ich = container_of(bch, struct isar_ch, bch);\r\nint ret = -EINVAL;\r\nu_long flags;\r\npr_debug("%s: %s cmd:%x %p\n", ich->is->name, __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\nif (test_bit(FLG_ACTIVE, &bch->Flags)) {\r\nspin_lock_irqsave(ich->is->hwlock, flags);\r\nmISDN_freebchannel(bch);\r\nmodeisar(ich, ISDN_P_NONE);\r\nspin_unlock_irqrestore(ich->is->hwlock, flags);\r\n} else {\r\nskb_queue_purge(&bch->rqueue);\r\nbch->rcount = 0;\r\n}\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(ich->is->owner);\r\nret = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nret = channel_bctrl(bch, arg);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown prim(%x)\n",\r\nich->is->name, __func__, cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nfree_isar(struct isar_hw *isar)\r\n{\r\nmodeisar(&isar->ch[0], ISDN_P_NONE);\r\nmodeisar(&isar->ch[1], ISDN_P_NONE);\r\ndel_timer(&isar->ch[0].ftimer);\r\ndel_timer(&isar->ch[1].ftimer);\r\ntest_and_clear_bit(FLG_INITIALIZED, &isar->ch[0].bch.Flags);\r\ntest_and_clear_bit(FLG_INITIALIZED, &isar->ch[1].bch.Flags);\r\n}\r\nstatic int\r\ninit_isar(struct isar_hw *isar)\r\n{\r\nint cnt = 3;\r\nwhile (cnt--) {\r\nisar->version = ISARVersion(isar);\r\nif (isar->ch[0].bch.debug & DEBUG_HW)\r\npr_notice("%s: Testing version %d (%d time)\n",\r\nisar->name, isar->version, 3 - cnt);\r\nif (isar->version == 1)\r\nbreak;\r\nisar->ctrl(isar->hw, HW_RESET_REQ, 0);\r\n}\r\nif (isar->version != 1)\r\nreturn -EINVAL;\r\nisar->ch[0].ftimer.function = &ftimer_handler;\r\nisar->ch[0].ftimer.data = (long)&isar->ch[0];\r\ninit_timer(&isar->ch[0].ftimer);\r\ntest_and_set_bit(FLG_INITIALIZED, &isar->ch[0].bch.Flags);\r\nisar->ch[1].ftimer.function = &ftimer_handler;\r\nisar->ch[1].ftimer.data = (long)&isar->ch[1];\r\ninit_timer(&isar->ch[1].ftimer);\r\ntest_and_set_bit(FLG_INITIALIZED, &isar->ch[1].bch.Flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nisar_open(struct isar_hw *isar, struct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nif (rq->adr.channel > 2)\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nbch = &isar->ch[rq->adr.channel - 1].bch;\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\ntest_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);\r\nbch->ch.protocol = rq->protocol;\r\nrq->ch = &bch->ch;\r\nreturn 0;\r\n}\r\nu32\r\nmISDNisar_init(struct isar_hw *isar, void *hw)\r\n{\r\nu32 ret, i;\r\nisar->hw = hw;\r\nfor (i = 0; i < 2; i++) {\r\nisar->ch[i].bch.nr = i + 1;\r\nmISDN_initbchannel(&isar->ch[i].bch, MAX_DATA_MEM);\r\nisar->ch[i].bch.ch.nr = i + 1;\r\nisar->ch[i].bch.ch.send = &isar_l2l1;\r\nisar->ch[i].bch.ch.ctrl = isar_bctrl;\r\nisar->ch[i].bch.hw = hw;\r\nisar->ch[i].is = isar;\r\n}\r\nisar->init = &init_isar;\r\nisar->release = &free_isar;\r\nisar->firmware = &load_firmware;\r\nisar->open = &isar_open;\r\nret = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_L2DTMF & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_MODEM_ASYNC & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_T30_FAX & ISDN_P_B_MASK));\r\nreturn ret;\r\n}\r\nstatic int __init isar_mod_init(void)\r\n{\r\npr_notice("mISDN: ISAR driver Rev. %s\n", ISAR_REV);\r\nreturn 0;\r\n}\r\nstatic void __exit isar_mod_cleanup(void)\r\n{\r\npr_notice("mISDN: ISAR module unloaded\n");\r\n}
