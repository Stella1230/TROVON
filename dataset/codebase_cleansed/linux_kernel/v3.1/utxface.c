acpi_status __init acpi_initialize_subsystem(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_initialize_subsystem);\r\nacpi_gbl_startup_flags = ACPI_SUBSYSTEM_INITIALIZE;\r\nACPI_DEBUG_EXEC(acpi_ut_init_stack_ptr_trace());\r\nstatus = acpi_os_initialize();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "During OSL initialization"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ut_init_globals();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"During initialization of globals"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ut_mutex_initialize();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"During Global Mutex creation"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ns_root_initialize();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"During Namespace initialization"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ut_initialize_interfaces();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"During OSI interfaces initialization"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nACPI_DEBUGGER_EXEC(status = acpi_db_initialize());\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_enable_subsystem(u32 flags)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(acpi_enable_subsystem);\r\nif (!(flags & ACPI_NO_ACPI_ENABLE)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"[Init] Going into ACPI mode\n"));\r\nacpi_gbl_original_mode = acpi_hw_get_mode();\r\nstatus = acpi_enable();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO, "AcpiEnable failed"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nstatus = acpi_tb_initialize_facs();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO, "Could not map the FACS table"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"[Init] Installing default address space handlers\n"));\r\nstatus = acpi_ev_install_region_handlers();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (!(flags & ACPI_NO_EVENT_INIT)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"[Init] Initializing ACPI events\n"));\r\nstatus = acpi_ev_initialize_events();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (!(flags & ACPI_NO_HANDLER_INIT)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"[Init] Installing SCI/GL handlers\n"));\r\nstatus = acpi_ev_install_xrupt_handlers();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_initialize_objects(u32 flags)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(acpi_initialize_objects);\r\nif (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"[Init] Executing _REG OpRegion methods\n"));\r\nstatus = acpi_ev_initialize_op_regions();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nacpi_ns_exec_module_code_list();\r\nif (!(flags & ACPI_NO_OBJECT_INIT)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"[Init] Completing Initialization of ACPI Objects\n"));\r\nstatus = acpi_ns_initialize_objects();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (!(flags & ACPI_NO_DEVICE_INIT)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"[Init] Initializing ACPI Devices\n"));\r\nstatus = acpi_ns_initialize_devices();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nstatus = acpi_purge_cached_objects();\r\nacpi_gbl_startup_flags |= ACPI_INITIALIZED_OK;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_terminate(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_terminate);\r\nif (acpi_gbl_shutdown) {\r\nACPI_ERROR((AE_INFO, "ACPI Subsystem is already terminated"));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_gbl_shutdown = TRUE;\r\nacpi_gbl_startup_flags = 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Shutting down ACPI Subsystem\n"));\r\nACPI_DEBUGGER_EXEC(acpi_gbl_db_terminate_threads = TRUE);\r\nacpi_ut_subsystem_shutdown();\r\nacpi_ut_mutex_terminate();\r\n#ifdef ACPI_DEBUGGER\r\nacpi_db_terminate();\r\n#endif\r\nstatus = acpi_os_terminate();\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_subsystem_status(void)\r\n{\r\nif (acpi_gbl_startup_flags & ACPI_INITIALIZED_OK) {\r\nreturn (AE_OK);\r\n} else {\r\nreturn (AE_ERROR);\r\n}\r\n}\r\nacpi_status acpi_get_system_info(struct acpi_buffer * out_buffer)\r\n{\r\nstruct acpi_system_info *info_ptr;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_get_system_info);\r\nstatus = acpi_ut_validate_buffer(out_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus =\r\nacpi_ut_initialize_buffer(out_buffer,\r\nsizeof(struct acpi_system_info));\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\ninfo_ptr = (struct acpi_system_info *)out_buffer->pointer;\r\ninfo_ptr->acpi_ca_version = ACPI_CA_VERSION;\r\ninfo_ptr->flags = ACPI_SYS_MODE_ACPI;\r\nif (acpi_gbl_FADT.flags & ACPI_FADT_32BIT_TIMER) {\r\ninfo_ptr->timer_resolution = 24;\r\n} else {\r\ninfo_ptr->timer_resolution = 32;\r\n}\r\ninfo_ptr->reserved1 = 0;\r\ninfo_ptr->reserved2 = 0;\r\ninfo_ptr->debug_layer = acpi_dbg_layer;\r\ninfo_ptr->debug_level = acpi_dbg_level;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_install_initialization_handler(acpi_init_handler handler, u32 function)\r\n{\r\nif (!handler) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif (acpi_gbl_init_handler) {\r\nreturn (AE_ALREADY_EXISTS);\r\n}\r\nacpi_gbl_init_handler = handler;\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_purge_cached_objects(void)\r\n{\r\nACPI_FUNCTION_TRACE(acpi_purge_cached_objects);\r\n(void)acpi_os_purge_cache(acpi_gbl_state_cache);\r\n(void)acpi_os_purge_cache(acpi_gbl_operand_cache);\r\n(void)acpi_os_purge_cache(acpi_gbl_ps_node_cache);\r\n(void)acpi_os_purge_cache(acpi_gbl_ps_node_ext_cache);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_install_interface(acpi_string interface_name)\r\n{\r\nacpi_status status;\r\nstruct acpi_interface_info *interface_info;\r\nif (!interface_name || (ACPI_STRLEN(interface_name) == 0)) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\r\ninterface_info = acpi_ut_get_interface(interface_name);\r\nif (interface_info) {\r\nif (interface_info->flags & ACPI_OSI_INVALID) {\r\ninterface_info->flags &= ~ACPI_OSI_INVALID;\r\nstatus = AE_OK;\r\n} else {\r\nstatus = AE_ALREADY_EXISTS;\r\n}\r\n} else {\r\nstatus = acpi_ut_install_interface(interface_name);\r\n}\r\nacpi_os_release_mutex(acpi_gbl_osi_mutex);\r\nreturn (status);\r\n}\r\nacpi_status acpi_remove_interface(acpi_string interface_name)\r\n{\r\nacpi_status status;\r\nif (!interface_name || (ACPI_STRLEN(interface_name) == 0)) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\r\nstatus = acpi_ut_remove_interface(interface_name);\r\nacpi_os_release_mutex(acpi_gbl_osi_mutex);\r\nreturn (status);\r\n}\r\nacpi_status acpi_install_interface_handler(acpi_interface_handler handler)\r\n{\r\nacpi_status status = AE_OK;\r\n(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\r\nif (handler && acpi_gbl_interface_handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\n} else {\r\nacpi_gbl_interface_handler = handler;\r\n}\r\nacpi_os_release_mutex(acpi_gbl_osi_mutex);\r\nreturn (status);\r\n}
