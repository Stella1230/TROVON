void hpfs_ea_ext_remove(struct super_block *s, secno a, int ano, unsigned len)\r\n{\r\nunsigned pos = 0;\r\nwhile (pos < len) {\r\nchar ex[4 + 255 + 1 + 8];\r\nstruct extended_attribute *ea = (struct extended_attribute *)ex;\r\nif (pos + 4 > len) {\r\nhpfs_error(s, "EAs don't end correctly, %s %08x, len %08x",\r\nano ? "anode" : "sectors", a, len);\r\nreturn;\r\n}\r\nif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\r\nif (ea->indirect) {\r\nif (ea_valuelen(ea) != 8) {\r\nhpfs_error(s, "ea->indirect set while ea->valuelen!=8, %s %08x, pos %08x",\r\nano ? "anode" : "sectors", a, pos);\r\nreturn;\r\n}\r\nif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 9, ex+4))\r\nreturn;\r\nhpfs_ea_remove(s, ea_sec(ea), ea->anode, ea_len(ea));\r\n}\r\npos += ea->namelen + ea_valuelen(ea) + 5;\r\n}\r\nif (!ano) hpfs_free_sectors(s, a, (len+511) >> 9);\r\nelse {\r\nstruct buffer_head *bh;\r\nstruct anode *anode;\r\nif ((anode = hpfs_map_anode(s, a, &bh))) {\r\nhpfs_remove_btree(s, &anode->btree);\r\nbrelse(bh);\r\nhpfs_free_sectors(s, a, 1);\r\n}\r\n}\r\n}\r\nstatic char *get_indirect_ea(struct super_block *s, int ano, secno a, int size)\r\n{\r\nchar *ret;\r\nif (!(ret = kmalloc(size + 1, GFP_NOFS))) {\r\nprintk("HPFS: out of memory for EA\n");\r\nreturn NULL;\r\n}\r\nif (hpfs_ea_read(s, a, ano, 0, size, ret)) {\r\nkfree(ret);\r\nreturn NULL;\r\n}\r\nret[size] = 0;\r\nreturn ret;\r\n}\r\nstatic void set_indirect_ea(struct super_block *s, int ano, secno a,\r\nconst char *data, int size)\r\n{\r\nhpfs_ea_write(s, a, ano, 0, size, data);\r\n}\r\nint hpfs_read_ea(struct super_block *s, struct fnode *fnode, char *key,\r\nchar *buf, int size)\r\n{\r\nunsigned pos;\r\nint ano, len;\r\nsecno a;\r\nchar ex[4 + 255 + 1 + 8];\r\nstruct extended_attribute *ea;\r\nstruct extended_attribute *ea_end = fnode_end_ea(fnode);\r\nfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\r\nif (!strcmp(ea->name, key)) {\r\nif (ea->indirect)\r\ngoto indirect;\r\nif (ea_valuelen(ea) >= size)\r\nreturn -EINVAL;\r\nmemcpy(buf, ea_data(ea), ea_valuelen(ea));\r\nbuf[ea_valuelen(ea)] = 0;\r\nreturn 0;\r\n}\r\na = le32_to_cpu(fnode->ea_secno);\r\nlen = le32_to_cpu(fnode->ea_size_l);\r\nano = fnode->ea_anode;\r\npos = 0;\r\nwhile (pos < len) {\r\nea = (struct extended_attribute *)ex;\r\nif (pos + 4 > len) {\r\nhpfs_error(s, "EAs don't end correctly, %s %08x, len %08x",\r\nano ? "anode" : "sectors", a, len);\r\nreturn -EIO;\r\n}\r\nif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return -EIO;\r\nif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea->indirect ? 8 : 0), ex + 4))\r\nreturn -EIO;\r\nif (!strcmp(ea->name, key)) {\r\nif (ea->indirect)\r\ngoto indirect;\r\nif (ea_valuelen(ea) >= size)\r\nreturn -EINVAL;\r\nif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), buf))\r\nreturn -EIO;\r\nbuf[ea_valuelen(ea)] = 0;\r\nreturn 0;\r\n}\r\npos += ea->namelen + ea_valuelen(ea) + 5;\r\n}\r\nreturn -ENOENT;\r\nindirect:\r\nif (ea_len(ea) >= size)\r\nreturn -EINVAL;\r\nif (hpfs_ea_read(s, ea_sec(ea), ea->anode, 0, ea_len(ea), buf))\r\nreturn -EIO;\r\nbuf[ea_len(ea)] = 0;\r\nreturn 0;\r\n}\r\nchar *hpfs_get_ea(struct super_block *s, struct fnode *fnode, char *key, int *size)\r\n{\r\nchar *ret;\r\nunsigned pos;\r\nint ano, len;\r\nsecno a;\r\nstruct extended_attribute *ea;\r\nstruct extended_attribute *ea_end = fnode_end_ea(fnode);\r\nfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\r\nif (!strcmp(ea->name, key)) {\r\nif (ea->indirect)\r\nreturn get_indirect_ea(s, ea->anode, ea_sec(ea), *size = ea_len(ea));\r\nif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\r\nprintk("HPFS: out of memory for EA\n");\r\nreturn NULL;\r\n}\r\nmemcpy(ret, ea_data(ea), ea_valuelen(ea));\r\nret[ea_valuelen(ea)] = 0;\r\nreturn ret;\r\n}\r\na = le32_to_cpu(fnode->ea_secno);\r\nlen = le32_to_cpu(fnode->ea_size_l);\r\nano = fnode->ea_anode;\r\npos = 0;\r\nwhile (pos < len) {\r\nchar ex[4 + 255 + 1 + 8];\r\nea = (struct extended_attribute *)ex;\r\nif (pos + 4 > len) {\r\nhpfs_error(s, "EAs don't end correctly, %s %08x, len %08x",\r\nano ? "anode" : "sectors", a, len);\r\nreturn NULL;\r\n}\r\nif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return NULL;\r\nif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea->indirect ? 8 : 0), ex + 4))\r\nreturn NULL;\r\nif (!strcmp(ea->name, key)) {\r\nif (ea->indirect)\r\nreturn get_indirect_ea(s, ea->anode, ea_sec(ea), *size = ea_len(ea));\r\nif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\r\nprintk("HPFS: out of memory for EA\n");\r\nreturn NULL;\r\n}\r\nif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), ret)) {\r\nkfree(ret);\r\nreturn NULL;\r\n}\r\nret[ea_valuelen(ea)] = 0;\r\nreturn ret;\r\n}\r\npos += ea->namelen + ea_valuelen(ea) + 5;\r\n}\r\nreturn NULL;\r\n}\r\nvoid hpfs_set_ea(struct inode *inode, struct fnode *fnode, const char *key,\r\nconst char *data, int size)\r\n{\r\nfnode_secno fno = inode->i_ino;\r\nstruct super_block *s = inode->i_sb;\r\nunsigned pos;\r\nint ano, len;\r\nsecno a;\r\nunsigned char h[4];\r\nstruct extended_attribute *ea;\r\nstruct extended_attribute *ea_end = fnode_end_ea(fnode);\r\nfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\r\nif (!strcmp(ea->name, key)) {\r\nif (ea->indirect) {\r\nif (ea_len(ea) == size)\r\nset_indirect_ea(s, ea->anode, ea_sec(ea), data, size);\r\n} else if (ea_valuelen(ea) == size) {\r\nmemcpy(ea_data(ea), data, size);\r\n}\r\nreturn;\r\n}\r\na = le32_to_cpu(fnode->ea_secno);\r\nlen = le32_to_cpu(fnode->ea_size_l);\r\nano = fnode->ea_anode;\r\npos = 0;\r\nwhile (pos < len) {\r\nchar ex[4 + 255 + 1 + 8];\r\nea = (struct extended_attribute *)ex;\r\nif (pos + 4 > len) {\r\nhpfs_error(s, "EAs don't end correctly, %s %08x, len %08x",\r\nano ? "anode" : "sectors", a, len);\r\nreturn;\r\n}\r\nif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\r\nif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea->indirect ? 8 : 0), ex + 4))\r\nreturn;\r\nif (!strcmp(ea->name, key)) {\r\nif (ea->indirect) {\r\nif (ea_len(ea) == size)\r\nset_indirect_ea(s, ea->anode, ea_sec(ea), data, size);\r\n}\r\nelse {\r\nif (ea_valuelen(ea) == size)\r\nhpfs_ea_write(s, a, ano, pos + 4 + ea->namelen + 1, size, data);\r\n}\r\nreturn;\r\n}\r\npos += ea->namelen + ea_valuelen(ea) + 5;\r\n}\r\nif (!le16_to_cpu(fnode->ea_offs)) {\r\nfnode->ea_offs = cpu_to_le16(0xc4);\r\n}\r\nif (le16_to_cpu(fnode->ea_offs) < 0xc4 || le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200) {\r\nhpfs_error(s, "fnode %08lx: ea_offs == %03x, ea_size_s == %03x",\r\n(unsigned long)inode->i_ino,\r\nle32_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\r\nreturn;\r\n}\r\nif ((le16_to_cpu(fnode->ea_size_s) || !le32_to_cpu(fnode->ea_size_l)) &&\r\nle16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5 <= 0x200) {\r\nea = fnode_end_ea(fnode);\r\n*(char *)ea = 0;\r\nea->namelen = strlen(key);\r\nea->valuelen_lo = size;\r\nea->valuelen_hi = size >> 8;\r\nstrcpy(ea->name, key);\r\nmemcpy(ea_data(ea), data, size);\r\nfnode->ea_size_s = cpu_to_le16(le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5);\r\ngoto ret;\r\n}\r\nif (le16_to_cpu(fnode->ea_size_s) && !le32_to_cpu(fnode->ea_size_l)) {\r\nsecno n;\r\nstruct buffer_head *bh;\r\nchar *data;\r\nif (!(n = hpfs_alloc_sector(s, fno, 1, 0))) return;\r\nif (!(data = hpfs_get_sector(s, n, &bh))) {\r\nhpfs_free_sectors(s, n, 1);\r\nreturn;\r\n}\r\nmemcpy(data, fnode_ea(fnode), le16_to_cpu(fnode->ea_size_s));\r\nfnode->ea_size_l = cpu_to_le32(le16_to_cpu(fnode->ea_size_s));\r\nfnode->ea_size_s = cpu_to_le16(0);\r\nfnode->ea_secno = cpu_to_le32(n);\r\nfnode->ea_anode = cpu_to_le32(0);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\n}\r\npos = le32_to_cpu(fnode->ea_size_l) + 5 + strlen(key) + size;\r\nlen = (le32_to_cpu(fnode->ea_size_l) + 511) >> 9;\r\nif (pos >= 30000) goto bail;\r\nwhile (((pos + 511) >> 9) > len) {\r\nif (!len) {\r\nsecno q = hpfs_alloc_sector(s, fno, 1, 0);\r\nif (!q) goto bail;\r\nfnode->ea_secno = cpu_to_le32(q);\r\nfnode->ea_anode = 0;\r\nlen++;\r\n} else if (!fnode->ea_anode) {\r\nif (hpfs_alloc_if_possible(s, le32_to_cpu(fnode->ea_secno) + len)) {\r\nlen++;\r\n} else {\r\nsecno new_sec;\r\nint i;\r\nif (!(new_sec = hpfs_alloc_sector(s, fno, 1, 1 - ((pos + 511) >> 9))))\r\ngoto bail;\r\nfor (i = 0; i < len; i++) {\r\nstruct buffer_head *bh1, *bh2;\r\nvoid *b1, *b2;\r\nif (!(b1 = hpfs_map_sector(s, le32_to_cpu(fnode->ea_secno) + i, &bh1, len - i - 1))) {\r\nhpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\r\ngoto bail;\r\n}\r\nif (!(b2 = hpfs_get_sector(s, new_sec + i, &bh2))) {\r\nbrelse(bh1);\r\nhpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\r\ngoto bail;\r\n}\r\nmemcpy(b2, b1, 512);\r\nbrelse(bh1);\r\nmark_buffer_dirty(bh2);\r\nbrelse(bh2);\r\n}\r\nhpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno), len);\r\nfnode->ea_secno = cpu_to_le32(new_sec);\r\nlen = (pos + 511) >> 9;\r\n}\r\n}\r\nif (fnode->ea_anode) {\r\nif (hpfs_add_sector_to_btree(s, le32_to_cpu(fnode->ea_secno),\r\n0, len) != -1) {\r\nlen++;\r\n} else {\r\ngoto bail;\r\n}\r\n}\r\n}\r\nh[0] = 0;\r\nh[1] = strlen(key);\r\nh[2] = size & 0xff;\r\nh[3] = size >> 8;\r\nif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode->ea_anode, le32_to_cpu(fnode->ea_size_l), 4, h)) goto bail;\r\nif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode->ea_anode, le32_to_cpu(fnode->ea_size_l) + 4, h[1] + 1, key)) goto bail;\r\nif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode->ea_anode, le32_to_cpu(fnode->ea_size_l) + 5 + h[1], size, data)) goto bail;\r\nfnode->ea_size_l = cpu_to_le32(pos);\r\nret:\r\nhpfs_i(inode)->i_ea_size += 5 + strlen(key) + size;\r\nreturn;\r\nbail:\r\nif (le32_to_cpu(fnode->ea_secno))\r\nif (fnode->ea_anode) hpfs_truncate_btree(s, le32_to_cpu(fnode->ea_secno), 1, (le32_to_cpu(fnode->ea_size_l) + 511) >> 9);\r\nelse hpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9), len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9));\r\nelse fnode->ea_secno = fnode->ea_size_l = cpu_to_le32(0);\r\n}
