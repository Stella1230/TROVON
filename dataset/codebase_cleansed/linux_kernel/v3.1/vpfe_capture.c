static const struct vpfe_pixel_format *vpfe_lookup_pix_format(u32 pix_format)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vpfe_pix_fmts); i++) {\r\nif (pix_format == vpfe_pix_fmts[i].fmtdesc.pixelformat)\r\nreturn &vpfe_pix_fmts[i];\r\n}\r\nreturn NULL;\r\n}\r\nint vpfe_register_ccdc_device(struct ccdc_hw_device *dev)\r\n{\r\nint ret = 0;\r\nprintk(KERN_NOTICE "vpfe_register_ccdc_device: %s\n", dev->name);\r\nBUG_ON(!dev->hw_ops.open);\r\nBUG_ON(!dev->hw_ops.enable);\r\nBUG_ON(!dev->hw_ops.set_hw_if_params);\r\nBUG_ON(!dev->hw_ops.configure);\r\nBUG_ON(!dev->hw_ops.set_buftype);\r\nBUG_ON(!dev->hw_ops.get_buftype);\r\nBUG_ON(!dev->hw_ops.enum_pix);\r\nBUG_ON(!dev->hw_ops.set_frame_format);\r\nBUG_ON(!dev->hw_ops.get_frame_format);\r\nBUG_ON(!dev->hw_ops.get_pixel_format);\r\nBUG_ON(!dev->hw_ops.set_pixel_format);\r\nBUG_ON(!dev->hw_ops.set_image_window);\r\nBUG_ON(!dev->hw_ops.get_image_window);\r\nBUG_ON(!dev->hw_ops.get_line_length);\r\nBUG_ON(!dev->hw_ops.getfid);\r\nmutex_lock(&ccdc_lock);\r\nif (NULL == ccdc_cfg) {\r\nprintk(KERN_ERR "vpfe capture not initialized\n");\r\nret = -EFAULT;\r\ngoto unlock;\r\n}\r\nif (strcmp(dev->name, ccdc_cfg->name)) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (ccdc_dev) {\r\nprintk(KERN_ERR "ccdc already registered\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nccdc_dev = dev;\r\nunlock:\r\nmutex_unlock(&ccdc_lock);\r\nreturn ret;\r\n}\r\nvoid vpfe_unregister_ccdc_device(struct ccdc_hw_device *dev)\r\n{\r\nif (NULL == dev) {\r\nprintk(KERN_ERR "invalid ccdc device ptr\n");\r\nreturn;\r\n}\r\nprintk(KERN_NOTICE "vpfe_unregister_ccdc_device, dev->name = %s\n",\r\ndev->name);\r\nif (strcmp(dev->name, ccdc_cfg->name)) {\r\nreturn;\r\n}\r\nmutex_lock(&ccdc_lock);\r\nccdc_dev = NULL;\r\nmutex_unlock(&ccdc_lock);\r\nreturn;\r\n}\r\nstatic int vpfe_get_ccdc_image_format(struct vpfe_device *vpfe_dev,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_rect image_win;\r\nenum ccdc_buftype buf_type;\r\nenum ccdc_frmfmt frm_fmt;\r\nmemset(f, 0, sizeof(*f));\r\nf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nccdc_dev->hw_ops.get_image_window(&image_win);\r\nf->fmt.pix.width = image_win.width;\r\nf->fmt.pix.height = image_win.height;\r\nf->fmt.pix.bytesperline = ccdc_dev->hw_ops.get_line_length();\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\r\nf->fmt.pix.height;\r\nbuf_type = ccdc_dev->hw_ops.get_buftype();\r\nf->fmt.pix.pixelformat = ccdc_dev->hw_ops.get_pixel_format();\r\nfrm_fmt = ccdc_dev->hw_ops.get_frame_format();\r\nif (frm_fmt == CCDC_FRMFMT_PROGRESSIVE)\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nelse if (frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nif (buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED)\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nelse if (buf_type == CCDC_BUFTYPE_FLD_SEPARATED)\r\nf->fmt.pix.field = V4L2_FIELD_SEQ_TB;\r\nelse {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf_type\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid frm_fmt\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpfe_config_ccdc_image_format(struct vpfe_device *vpfe_dev)\r\n{\r\nenum ccdc_frmfmt frm_fmt = CCDC_FRMFMT_INTERLACED;\r\nint ret = 0;\r\nif (ccdc_dev->hw_ops.set_pixel_format(\r\nvpfe_dev->fmt.fmt.pix.pixelformat) < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"couldn't set pix format in ccdc\n");\r\nreturn -EINVAL;\r\n}\r\nccdc_dev->hw_ops.set_image_window(&vpfe_dev->crop);\r\nswitch (vpfe_dev->fmt.fmt.pix.field) {\r\ncase V4L2_FIELD_INTERLACED:\r\nret = ccdc_dev->hw_ops.set_buftype(\r\nCCDC_BUFTYPE_FLD_INTERLEAVED);\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\nfrm_fmt = CCDC_FRMFMT_PROGRESSIVE;\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\nret = ccdc_dev->hw_ops.set_buftype(\r\nCCDC_BUFTYPE_FLD_SEPARATED);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!ret)\r\nret = ccdc_dev->hw_ops.set_frame_format(frm_fmt);\r\nreturn ret;\r\n}\r\nstatic int vpfe_config_image_format(struct vpfe_device *vpfe_dev,\r\nconst v4l2_std_id *std_id)\r\n{\r\nstruct vpfe_subdev_info *sdinfo = vpfe_dev->current_subdev;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nstruct v4l2_pix_format *pix = &vpfe_dev->fmt.fmt.pix;\r\nint i, ret = 0;\r\nfor (i = 0; i < ARRAY_SIZE(vpfe_standards); i++) {\r\nif (vpfe_standards[i].std_id & *std_id) {\r\nvpfe_dev->std_info.active_pixels =\r\nvpfe_standards[i].width;\r\nvpfe_dev->std_info.active_lines =\r\nvpfe_standards[i].height;\r\nvpfe_dev->std_info.frame_format =\r\nvpfe_standards[i].frame_format;\r\nvpfe_dev->std_index = i;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(vpfe_standards)) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "standard not supported\n");\r\nreturn -EINVAL;\r\n}\r\nvpfe_dev->crop.top = 0;\r\nvpfe_dev->crop.left = 0;\r\nvpfe_dev->crop.width = vpfe_dev->std_info.active_pixels;\r\nvpfe_dev->crop.height = vpfe_dev->std_info.active_lines;\r\npix->width = vpfe_dev->crop.width;\r\npix->height = vpfe_dev->crop.height;\r\nif (vpfe_dev->std_info.frame_format) {\r\npix->field = V4L2_FIELD_INTERLACED;\r\npix->pixelformat = V4L2_PIX_FMT_UYVY;\r\nv4l2_fill_mbus_format(&mbus_fmt, pix,\r\nV4L2_MBUS_FMT_YUYV10_2X10);\r\n} else {\r\npix->field = V4L2_FIELD_NONE;\r\npix->pixelformat = V4L2_PIX_FMT_SBGGR8;\r\nv4l2_fill_mbus_format(&mbus_fmt, pix,\r\nV4L2_MBUS_FMT_SBGGR8_1X8);\r\n}\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,\r\nsdinfo->grp_id, video, g_mbus_fmt, &mbus_fmt);\r\nif (ret && ret != -ENOIOCTLCMD) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"error in getting g_mbus_fmt from sub device\n");\r\nreturn ret;\r\n}\r\nv4l2_fill_pix_format(pix, &mbus_fmt);\r\npix->bytesperline = pix->width * 2;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\nret = vpfe_config_ccdc_image_format(vpfe_dev);\r\nif (ret)\r\nreturn ret;\r\nif (!ret) {\r\npix->bytesperline = ccdc_dev->hw_ops.get_line_length();\r\npix->sizeimage = pix->bytesperline * pix->height;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vpfe_initialize_device(struct vpfe_device *vpfe_dev)\r\n{\r\nint ret = 0;\r\nvpfe_dev->current_input = 0;\r\nvpfe_dev->std_index = 0;\r\nret = vpfe_config_image_format(vpfe_dev,\r\n&vpfe_standards[vpfe_dev->std_index].std_id);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&ccdc_lock);\r\nif (NULL == ccdc_dev) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "ccdc device not registered\n");\r\nret = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (!try_module_get(ccdc_dev->owner)) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Couldn't lock ccdc module\n");\r\nret = -ENODEV;\r\ngoto unlock;\r\n}\r\nret = ccdc_dev->hw_ops.open(vpfe_dev->pdev);\r\nif (!ret)\r\nvpfe_dev->initialized = 1;\r\nif (vpfe_dev->cfg->clr_intr)\r\nvpfe_dev->cfg->clr_intr(-1);\r\nunlock:\r\nmutex_unlock(&ccdc_lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_open(struct file *file)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_fh *fh;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_open\n");\r\nif (!vpfe_dev->cfg->num_subdevs) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "No decoder registered\n");\r\nreturn -ENODEV;\r\n}\r\nfh = kmalloc(sizeof(struct vpfe_fh), GFP_KERNEL);\r\nif (NULL == fh) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"unable to allocate memory for file handle object\n");\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = fh;\r\nfh->vpfe_dev = vpfe_dev;\r\nmutex_lock(&vpfe_dev->lock);\r\nif (!vpfe_dev->initialized) {\r\nif (vpfe_initialize_device(vpfe_dev)) {\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn -ENODEV;\r\n}\r\n}\r\nvpfe_dev->usrs++;\r\nfh->io_allowed = 0;\r\nfh->prio = V4L2_PRIORITY_UNSET;\r\nv4l2_prio_open(&vpfe_dev->prio, &fh->prio);\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn 0;\r\n}\r\nstatic void vpfe_schedule_next_buffer(struct vpfe_device *vpfe_dev)\r\n{\r\nunsigned long addr;\r\nvpfe_dev->next_frm = list_entry(vpfe_dev->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\nlist_del(&vpfe_dev->next_frm->queue);\r\nvpfe_dev->next_frm->state = VIDEOBUF_ACTIVE;\r\naddr = videobuf_to_dma_contig(vpfe_dev->next_frm);\r\nccdc_dev->hw_ops.setfbaddr(addr);\r\n}\r\nstatic void vpfe_schedule_bottom_field(struct vpfe_device *vpfe_dev)\r\n{\r\nunsigned long addr;\r\naddr = videobuf_to_dma_contig(vpfe_dev->cur_frm);\r\naddr += vpfe_dev->field_off;\r\nccdc_dev->hw_ops.setfbaddr(addr);\r\n}\r\nstatic void vpfe_process_buffer_complete(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct timeval timevalue;\r\ndo_gettimeofday(&timevalue);\r\nvpfe_dev->cur_frm->ts = timevalue;\r\nvpfe_dev->cur_frm->state = VIDEOBUF_DONE;\r\nvpfe_dev->cur_frm->size = vpfe_dev->fmt.fmt.pix.sizeimage;\r\nwake_up_interruptible(&vpfe_dev->cur_frm->done);\r\nvpfe_dev->cur_frm = vpfe_dev->next_frm;\r\n}\r\nstatic irqreturn_t vpfe_isr(int irq, void *dev_id)\r\n{\r\nstruct vpfe_device *vpfe_dev = dev_id;\r\nenum v4l2_field field;\r\nint fid;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "\nStarting vpfe_isr...\n");\r\nfield = vpfe_dev->fmt.fmt.pix.field;\r\nif (!vpfe_dev->started)\r\ngoto clear_intr;\r\nif (NULL != ccdc_dev->hw_ops.reset)\r\nccdc_dev->hw_ops.reset();\r\nif (field == V4L2_FIELD_NONE) {\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"frame format is progressive...\n");\r\nif (vpfe_dev->cur_frm != vpfe_dev->next_frm)\r\nvpfe_process_buffer_complete(vpfe_dev);\r\ngoto clear_intr;\r\n}\r\nfid = ccdc_dev->hw_ops.getfid();\r\nvpfe_dev->field_id ^= 1;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "field id = %x:%x.\n",\r\nfid, vpfe_dev->field_id);\r\nif (fid == vpfe_dev->field_id) {\r\nif (fid == 0) {\r\nif (vpfe_dev->cur_frm != vpfe_dev->next_frm)\r\nvpfe_process_buffer_complete(vpfe_dev);\r\nif (field == V4L2_FIELD_SEQ_TB) {\r\nvpfe_schedule_bottom_field(vpfe_dev);\r\n}\r\ngoto clear_intr;\r\n}\r\nspin_lock(&vpfe_dev->dma_queue_lock);\r\nif (!list_empty(&vpfe_dev->dma_queue) &&\r\nvpfe_dev->cur_frm == vpfe_dev->next_frm)\r\nvpfe_schedule_next_buffer(vpfe_dev);\r\nspin_unlock(&vpfe_dev->dma_queue_lock);\r\n} else if (fid == 0) {\r\nvpfe_dev->field_id = fid;\r\n}\r\nclear_intr:\r\nif (vpfe_dev->cfg->clr_intr)\r\nvpfe_dev->cfg->clr_intr(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t vdint1_isr(int irq, void *dev_id)\r\n{\r\nstruct vpfe_device *vpfe_dev = dev_id;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "\nInside vdint1_isr...\n");\r\nif (!vpfe_dev->started) {\r\nif (vpfe_dev->cfg->clr_intr)\r\nvpfe_dev->cfg->clr_intr(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock(&vpfe_dev->dma_queue_lock);\r\nif ((vpfe_dev->fmt.fmt.pix.field == V4L2_FIELD_NONE) &&\r\n!list_empty(&vpfe_dev->dma_queue) &&\r\nvpfe_dev->cur_frm == vpfe_dev->next_frm)\r\nvpfe_schedule_next_buffer(vpfe_dev);\r\nspin_unlock(&vpfe_dev->dma_queue_lock);\r\nif (vpfe_dev->cfg->clr_intr)\r\nvpfe_dev->cfg->clr_intr(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void vpfe_detach_irq(struct vpfe_device *vpfe_dev)\r\n{\r\nenum ccdc_frmfmt frame_format;\r\nframe_format = ccdc_dev->hw_ops.get_frame_format();\r\nif (frame_format == CCDC_FRMFMT_PROGRESSIVE)\r\nfree_irq(vpfe_dev->ccdc_irq1, vpfe_dev);\r\n}\r\nstatic int vpfe_attach_irq(struct vpfe_device *vpfe_dev)\r\n{\r\nenum ccdc_frmfmt frame_format;\r\nframe_format = ccdc_dev->hw_ops.get_frame_format();\r\nif (frame_format == CCDC_FRMFMT_PROGRESSIVE) {\r\nreturn request_irq(vpfe_dev->ccdc_irq1, vdint1_isr,\r\nIRQF_DISABLED, "vpfe_capture1",\r\nvpfe_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vpfe_stop_ccdc_capture(struct vpfe_device *vpfe_dev)\r\n{\r\nvpfe_dev->started = 0;\r\nccdc_dev->hw_ops.enable(0);\r\nif (ccdc_dev->hw_ops.enable_out_to_sdram)\r\nccdc_dev->hw_ops.enable_out_to_sdram(0);\r\n}\r\nstatic int vpfe_release(struct file *file)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_fh *fh = file->private_data;\r\nstruct vpfe_subdev_info *sdinfo;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_release\n");\r\nmutex_lock(&vpfe_dev->lock);\r\nif (fh->io_allowed) {\r\nif (vpfe_dev->started) {\r\nsdinfo = vpfe_dev->current_subdev;\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,\r\nsdinfo->grp_id,\r\nvideo, s_stream, 0);\r\nif (ret && (ret != -ENOIOCTLCMD))\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"stream off failed in subdev\n");\r\nvpfe_stop_ccdc_capture(vpfe_dev);\r\nvpfe_detach_irq(vpfe_dev);\r\nvideobuf_streamoff(&vpfe_dev->buffer_queue);\r\n}\r\nvpfe_dev->io_usrs = 0;\r\nvpfe_dev->numbuffers = config_params.numbuffers;\r\n}\r\nvpfe_dev->usrs--;\r\nv4l2_prio_close(&vpfe_dev->prio, fh->prio);\r\nif (!vpfe_dev->usrs) {\r\nvpfe_dev->initialized = 0;\r\nif (ccdc_dev->hw_ops.close)\r\nccdc_dev->hw_ops.close(vpfe_dev->pdev);\r\nmodule_put(ccdc_dev->owner);\r\n}\r\nmutex_unlock(&vpfe_dev->lock);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int vpfe_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_mmap\n");\r\nreturn videobuf_mmap_mapper(&vpfe_dev->buffer_queue, vma);\r\n}\r\nstatic unsigned int vpfe_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_poll\n");\r\nif (vpfe_dev->started)\r\nreturn videobuf_poll_stream(file,\r\n&vpfe_dev->buffer_queue, wait);\r\nreturn 0;\r\n}\r\nstatic const struct vpfe_pixel_format *\r\nvpfe_check_format(struct vpfe_device *vpfe_dev,\r\nstruct v4l2_pix_format *pixfmt)\r\n{\r\nu32 min_height = 1, min_width = 32, max_width, max_height;\r\nconst struct vpfe_pixel_format *vpfe_pix_fmt;\r\nu32 pix;\r\nint temp, found;\r\nvpfe_pix_fmt = vpfe_lookup_pix_format(pixfmt->pixelformat);\r\nif (NULL == vpfe_pix_fmt) {\r\npixfmt->pixelformat = vpfe_dev->fmt.fmt.pix.pixelformat;\r\nvpfe_pix_fmt = vpfe_lookup_pix_format(pixfmt->pixelformat);\r\n}\r\ntemp = 0;\r\nfound = 0;\r\nwhile (ccdc_dev->hw_ops.enum_pix(&pix, temp) >= 0) {\r\nif (vpfe_pix_fmt->fmtdesc.pixelformat == pix) {\r\nfound = 1;\r\nbreak;\r\n}\r\ntemp++;\r\n}\r\nif (!found) {\r\npixfmt->pixelformat = vpfe_dev->fmt.fmt.pix.pixelformat;\r\nvpfe_pix_fmt = vpfe_lookup_pix_format(pixfmt->pixelformat);\r\n}\r\nif (pixfmt->field == V4L2_FIELD_ANY) {\r\npixfmt->field = vpfe_dev->fmt.fmt.pix.field;\r\n}\r\nif (vpfe_dev->fmt.fmt.pix.field != pixfmt->field) {\r\nswitch (pixfmt->field) {\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_SEQ_TB:\r\nif (!vpfe_dev->std_info.frame_format)\r\npixfmt->field = V4L2_FIELD_NONE;\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\nif (vpfe_dev->std_info.frame_format)\r\npixfmt->field = V4L2_FIELD_INTERLACED;\r\nbreak;\r\ndefault:\r\npixfmt->field = vpfe_dev->fmt.fmt.pix.field;\r\nbreak;\r\n}\r\n}\r\nif (pixfmt->field == V4L2_FIELD_INTERLACED ||\r\npixfmt->field == V4L2_FIELD_SEQ_TB)\r\nmin_height = 2;\r\nmax_width = vpfe_dev->std_info.active_pixels;\r\nmax_height = vpfe_dev->std_info.active_lines;\r\nmin_width /= vpfe_pix_fmt->bpp;\r\nv4l2_info(&vpfe_dev->v4l2_dev, "width = %d, height = %d, bpp = %d\n",\r\npixfmt->width, pixfmt->height, vpfe_pix_fmt->bpp);\r\npixfmt->width = clamp((pixfmt->width), min_width, max_width);\r\npixfmt->height = clamp((pixfmt->height), min_height, max_height);\r\nif (pixfmt->field == V4L2_FIELD_INTERLACED)\r\npixfmt->height &= (~1);\r\npixfmt->bytesperline = (((pixfmt->width * vpfe_pix_fmt->bpp) + 31)\r\n& ~31);\r\nif (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)\r\npixfmt->sizeimage =\r\npixfmt->bytesperline * pixfmt->height +\r\n((pixfmt->bytesperline * pixfmt->height) >> 1);\r\nelse\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\r\nv4l2_info(&vpfe_dev->v4l2_dev, "adjusted width = %d, height ="\r\n" %d, bpp = %d, bytesperline = %d, sizeimage = %d\n",\r\npixfmt->width, pixfmt->height, vpfe_pix_fmt->bpp,\r\npixfmt->bytesperline, pixfmt->sizeimage);\r\nreturn vpfe_pix_fmt;\r\n}\r\nstatic int vpfe_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_querycap\n");\r\ncap->version = VPFE_CAPTURE_VERSION_CODE;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nstrlcpy(cap->driver, CAPTURE_DRV_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, "VPFE", sizeof(cap->bus_info));\r\nstrlcpy(cap->card, vpfe_dev->cfg->card_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vpfe_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_fmt_vid_cap\n");\r\n*fmt = vpfe_dev->fmt;\r\nreturn ret;\r\n}\r\nstatic int vpfe_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nconst struct vpfe_pixel_format *pix_fmt;\r\nint temp_index;\r\nu32 pix;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_enum_fmt_vid_cap\n");\r\nif (ccdc_dev->hw_ops.enum_pix(&pix, fmt->index) < 0)\r\nreturn -EINVAL;\r\npix_fmt = vpfe_lookup_pix_format(pix);\r\nif (NULL != pix_fmt) {\r\ntemp_index = fmt->index;\r\n*fmt = pix_fmt->fmtdesc;\r\nfmt->index = temp_index;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpfe_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nconst struct vpfe_pixel_format *pix_fmts;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_fmt_vid_cap\n");\r\nif (vpfe_dev->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Streaming is started\n");\r\nreturn -EBUSY;\r\n}\r\npix_fmts = vpfe_check_format(vpfe_dev, &fmt->fmt.pix);\r\nif (NULL == pix_fmts)\r\nreturn -EINVAL;\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nif (ret)\r\nreturn ret;\r\nvpfe_detach_irq(vpfe_dev);\r\nvpfe_dev->fmt = *fmt;\r\nret = vpfe_config_ccdc_image_format(vpfe_dev);\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nconst struct vpfe_pixel_format *pix_fmts;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_try_fmt_vid_cap\n");\r\npix_fmts = vpfe_check_format(vpfe_dev, &f->fmt.pix);\r\nif (NULL == pix_fmts)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vpfe_get_subdev_input_index(struct vpfe_device *vpfe_dev,\r\nint *subdev_index,\r\nint *subdev_input_index,\r\nint app_input_index)\r\n{\r\nstruct vpfe_config *cfg = vpfe_dev->cfg;\r\nstruct vpfe_subdev_info *sdinfo;\r\nint i, j = 0;\r\nfor (i = 0; i < cfg->num_subdevs; i++) {\r\nsdinfo = &cfg->sub_devs[i];\r\nif (app_input_index < (j + sdinfo->num_inputs)) {\r\n*subdev_index = i;\r\n*subdev_input_index = app_input_index - j;\r\nreturn 0;\r\n}\r\nj += sdinfo->num_inputs;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpfe_get_app_input_index(struct vpfe_device *vpfe_dev,\r\nint *app_input_index)\r\n{\r\nstruct vpfe_config *cfg = vpfe_dev->cfg;\r\nstruct vpfe_subdev_info *sdinfo;\r\nint i, j = 0;\r\nfor (i = 0; i < cfg->num_subdevs; i++) {\r\nsdinfo = &cfg->sub_devs[i];\r\nif (!strcmp(sdinfo->name, vpfe_dev->current_subdev->name)) {\r\nif (vpfe_dev->current_input >= sdinfo->num_inputs)\r\nreturn -1;\r\n*app_input_index = j + vpfe_dev->current_input;\r\nreturn 0;\r\n}\r\nj += sdinfo->num_inputs;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpfe_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nint subdev, index ;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_enum_input\n");\r\nif (vpfe_get_subdev_input_index(vpfe_dev,\r\n&subdev,\r\n&index,\r\ninp->index) < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "input information not found"\r\n" for the subdev\n");\r\nreturn -EINVAL;\r\n}\r\nsdinfo = &vpfe_dev->cfg->sub_devs[subdev];\r\nmemcpy(inp, &sdinfo->inputs[index], sizeof(struct v4l2_input));\r\nreturn 0;\r\n}\r\nstatic int vpfe_g_input(struct file *file, void *priv, unsigned int *index)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_input\n");\r\nreturn vpfe_get_app_input_index(vpfe_dev, index);\r\n}\r\nstatic int vpfe_s_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nint subdev_index, inp_index;\r\nstruct vpfe_route *route;\r\nu32 input = 0, output = 0;\r\nint ret = -EINVAL;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_input\n");\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nif (ret)\r\nreturn ret;\r\nif (vpfe_dev->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Streaming is on\n");\r\nret = -EBUSY;\r\ngoto unlock_out;\r\n}\r\nif (vpfe_get_subdev_input_index(vpfe_dev,\r\n&subdev_index,\r\n&inp_index,\r\nindex) < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "invalid input index\n");\r\ngoto unlock_out;\r\n}\r\nsdinfo = &vpfe_dev->cfg->sub_devs[subdev_index];\r\nroute = &sdinfo->routes[inp_index];\r\nif (route && sdinfo->can_route) {\r\ninput = route->input;\r\noutput = route->output;\r\n}\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\nvideo, s_routing, input, output, 0);\r\nif (ret) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"vpfe_doioctl:error in setting input in decoder\n");\r\nret = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nvpfe_dev->current_subdev = sdinfo;\r\nvpfe_dev->current_input = index;\r\nvpfe_dev->std_index = 0;\r\nret = ccdc_dev->hw_ops.set_hw_if_params(&sdinfo->ccdc_if_params);\r\nif (ret)\r\ngoto unlock_out;\r\nret = vpfe_config_image_format(vpfe_dev,\r\n&vpfe_standards[vpfe_dev->std_index].std_id);\r\nunlock_out:\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_querystd(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_querystd\n");\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nsdinfo = vpfe_dev->current_subdev;\r\nif (ret)\r\nreturn ret;\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\nvideo, querystd, std_id);\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_s_std(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_std\n");\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nif (ret)\r\nreturn ret;\r\nsdinfo = vpfe_dev->current_subdev;\r\nif (vpfe_dev->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "streaming is started\n");\r\nret = -EBUSY;\r\ngoto unlock_out;\r\n}\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\ncore, s_std, *std_id);\r\nif (ret < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Failed to set standard\n");\r\ngoto unlock_out;\r\n}\r\nret = vpfe_config_image_format(vpfe_dev, std_id);\r\nunlock_out:\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_g_std(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_std\n");\r\n*std_id = vpfe_standards[vpfe_dev->std_index].std_id;\r\nreturn 0;\r\n}\r\nstatic int vpfe_videobuf_setup(struct videobuf_queue *vq,\r\nunsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct vpfe_fh *fh = vq->priv_data;\r\nstruct vpfe_device *vpfe_dev = fh->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buffer_setup\n");\r\n*size = vpfe_dev->fmt.fmt.pix.sizeimage;\r\nif (vpfe_dev->memory == V4L2_MEMORY_MMAP &&\r\nvpfe_dev->fmt.fmt.pix.sizeimage > config_params.device_bufsize)\r\n*size = config_params.device_bufsize;\r\nif (*count < config_params.min_numbuffers)\r\n*count = config_params.min_numbuffers;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"count=%d, size=%d\n", *count, *size);\r\nreturn 0;\r\n}\r\nstatic int vpfe_videobuf_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct vpfe_fh *fh = vq->priv_data;\r\nstruct vpfe_device *vpfe_dev = fh->vpfe_dev;\r\nunsigned long addr;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buffer_prepare\n");\r\nif (VIDEOBUF_NEEDS_INIT == vb->state) {\r\nvb->width = vpfe_dev->fmt.fmt.pix.width;\r\nvb->height = vpfe_dev->fmt.fmt.pix.height;\r\nvb->size = vpfe_dev->fmt.fmt.pix.sizeimage;\r\nvb->field = field;\r\nret = videobuf_iolock(vq, vb, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\naddr = videobuf_to_dma_contig(vb);\r\nif (!ALIGN(addr, 32))\r\nreturn -EINVAL;\r\nvb->state = VIDEOBUF_PREPARED;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vpfe_videobuf_queue(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct vpfe_fh *fh = vq->priv_data;\r\nstruct vpfe_device *vpfe_dev = fh->vpfe_dev;\r\nunsigned long flags;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buffer_queue\n");\r\nspin_lock_irqsave(&vpfe_dev->dma_queue_lock, flags);\r\nlist_add_tail(&vb->queue, &vpfe_dev->dma_queue);\r\nspin_unlock_irqrestore(&vpfe_dev->dma_queue_lock, flags);\r\nvb->state = VIDEOBUF_QUEUED;\r\n}\r\nstatic void vpfe_videobuf_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct vpfe_fh *fh = vq->priv_data;\r\nstruct vpfe_device *vpfe_dev = fh->vpfe_dev;\r\nunsigned long flags;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_videobuf_release\n");\r\nspin_lock_irqsave(&vpfe_dev->dma_queue_lock, flags);\r\nINIT_LIST_HEAD(&vpfe_dev->dma_queue);\r\nspin_unlock_irqrestore(&vpfe_dev->dma_queue_lock, flags);\r\nvideobuf_dma_contig_free(vq, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int vpfe_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *req_buf)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_fh *fh = file->private_data;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_reqbufs\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != req_buf->type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nif (ret)\r\nreturn ret;\r\nif (vpfe_dev->io_usrs != 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Only one IO user allowed\n");\r\nret = -EBUSY;\r\ngoto unlock_out;\r\n}\r\nvpfe_dev->memory = req_buf->memory;\r\nvideobuf_queue_dma_contig_init(&vpfe_dev->buffer_queue,\r\n&vpfe_videobuf_qops,\r\nvpfe_dev->pdev,\r\n&vpfe_dev->irqlock,\r\nreq_buf->type,\r\nvpfe_dev->fmt.fmt.pix.field,\r\nsizeof(struct videobuf_buffer),\r\nfh, NULL);\r\nfh->io_allowed = 1;\r\nvpfe_dev->io_usrs = 1;\r\nINIT_LIST_HEAD(&vpfe_dev->dma_queue);\r\nret = videobuf_reqbufs(&vpfe_dev->buffer_queue, req_buf);\r\nunlock_out:\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_querybuf\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf->type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (vpfe_dev->memory != V4L2_MEMORY_MMAP) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid memory\n");\r\nreturn -EINVAL;\r\n}\r\nreturn videobuf_querybuf(&vpfe_dev->buffer_queue, buf);\r\n}\r\nstatic int vpfe_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_fh *fh = file->private_data;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_qbuf\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != p->type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nreturn videobuf_qbuf(&vpfe_dev->buffer_queue, p);\r\n}\r\nstatic int vpfe_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_dqbuf\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf->type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn videobuf_dqbuf(&vpfe_dev->buffer_queue,\r\nbuf, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vpfe_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qctrl)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nsdinfo = vpfe_dev->current_subdev;\r\nreturn v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\ncore, queryctrl, qctrl);\r\n}\r\nstatic int vpfe_g_ctrl(struct file *file, void *priv, struct v4l2_control *ctrl)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nsdinfo = vpfe_dev->current_subdev;\r\nreturn v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\ncore, g_ctrl, ctrl);\r\n}\r\nstatic int vpfe_s_ctrl(struct file *file, void *priv, struct v4l2_control *ctrl)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nsdinfo = vpfe_dev->current_subdev;\r\nreturn v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\ncore, s_ctrl, ctrl);\r\n}\r\nstatic void vpfe_calculate_offsets(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct v4l2_rect image_win;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_calculate_offsets\n");\r\nccdc_dev->hw_ops.get_image_window(&image_win);\r\nvpfe_dev->field_off = image_win.height * image_win.width;\r\n}\r\nstatic void vpfe_start_ccdc_capture(struct vpfe_device *vpfe_dev)\r\n{\r\nccdc_dev->hw_ops.enable(1);\r\nif (ccdc_dev->hw_ops.enable_out_to_sdram)\r\nccdc_dev->hw_ops.enable_out_to_sdram(1);\r\nvpfe_dev->started = 1;\r\n}\r\nstatic int vpfe_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type buf_type)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_fh *fh = file->private_data;\r\nstruct vpfe_subdev_info *sdinfo;\r\nunsigned long addr;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_streamon\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf_type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nsdinfo = vpfe_dev->current_subdev;\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\nvideo, s_stream, 1);\r\nif (ret && (ret != -ENOIOCTLCMD)) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "stream on failed in subdev\n");\r\nreturn -EINVAL;\r\n}\r\nif (list_empty(&vpfe_dev->buffer_queue.stream)) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "buffer queue is empty\n");\r\nreturn -EIO;\r\n}\r\nret = videobuf_streamon(&vpfe_dev->buffer_queue);\r\nif (ret)\r\nreturn ret;\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nif (ret)\r\ngoto streamoff;\r\nvpfe_dev->next_frm = list_entry(vpfe_dev->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\nvpfe_dev->cur_frm = vpfe_dev->next_frm;\r\nlist_del(&vpfe_dev->cur_frm->queue);\r\nvpfe_dev->cur_frm->state = VIDEOBUF_ACTIVE;\r\nvpfe_dev->field_id = 0;\r\naddr = videobuf_to_dma_contig(vpfe_dev->cur_frm);\r\nvpfe_calculate_offsets(vpfe_dev);\r\nif (vpfe_attach_irq(vpfe_dev) < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"Error in attaching interrupt handle\n");\r\nret = -EFAULT;\r\ngoto unlock_out;\r\n}\r\nif (ccdc_dev->hw_ops.configure() < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"Error in configuring ccdc\n");\r\nret = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nccdc_dev->hw_ops.setfbaddr((unsigned long)(addr));\r\nvpfe_start_ccdc_capture(vpfe_dev);\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\nunlock_out:\r\nmutex_unlock(&vpfe_dev->lock);\r\nstreamoff:\r\nret = videobuf_streamoff(&vpfe_dev->buffer_queue);\r\nreturn ret;\r\n}\r\nstatic int vpfe_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type buf_type)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nstruct vpfe_fh *fh = file->private_data;\r\nstruct vpfe_subdev_info *sdinfo;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_streamoff\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf_type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (!vpfe_dev->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "device started\n");\r\nreturn -EINVAL;\r\n}\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nif (ret)\r\nreturn ret;\r\nvpfe_stop_ccdc_capture(vpfe_dev);\r\nvpfe_detach_irq(vpfe_dev);\r\nsdinfo = vpfe_dev->current_subdev;\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\nvideo, s_stream, 0);\r\nif (ret && (ret != -ENOIOCTLCMD))\r\nv4l2_err(&vpfe_dev->v4l2_dev, "stream off failed in subdev\n");\r\nret = videobuf_streamoff(&vpfe_dev->buffer_queue);\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *crop)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_cropcap\n");\r\nif (vpfe_dev->std_index >= ARRAY_SIZE(vpfe_standards))\r\nreturn -EINVAL;\r\nmemset(crop, 0, sizeof(struct v4l2_cropcap));\r\ncrop->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncrop->bounds.width = crop->defrect.width =\r\nvpfe_standards[vpfe_dev->std_index].width;\r\ncrop->bounds.height = crop->defrect.height =\r\nvpfe_standards[vpfe_dev->std_index].height;\r\ncrop->pixelaspect = vpfe_standards[vpfe_dev->std_index].pixelaspect;\r\nreturn 0;\r\n}\r\nstatic int vpfe_g_crop(struct file *file, void *priv,\r\nstruct v4l2_crop *crop)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_crop\n");\r\ncrop->c = vpfe_dev->crop;\r\nreturn 0;\r\n}\r\nstatic int vpfe_s_crop(struct file *file, void *priv,\r\nstruct v4l2_crop *crop)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_crop\n");\r\nif (vpfe_dev->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"Cannot change crop when streaming is ON\n");\r\nreturn -EBUSY;\r\n}\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nif (ret)\r\nreturn ret;\r\nif (crop->c.top < 0 || crop->c.left < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"doesn't support negative values for top & left\n");\r\nret = -EINVAL;\r\ngoto unlock_out;\r\n}\r\ncrop->c.width = ((crop->c.width + 15) & ~0xf);\r\nif ((crop->c.left + crop->c.width >\r\nvpfe_dev->std_info.active_pixels) ||\r\n(crop->c.top + crop->c.height >\r\nvpfe_dev->std_info.active_lines)) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Error in S_CROP params\n");\r\nret = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nccdc_dev->hw_ops.set_image_window(&crop->c);\r\nvpfe_dev->fmt.fmt.pix.width = crop->c.width;\r\nvpfe_dev->fmt.fmt.pix.height = crop->c.height;\r\nvpfe_dev->fmt.fmt.pix.bytesperline =\r\nccdc_dev->hw_ops.get_line_length();\r\nvpfe_dev->fmt.fmt.pix.sizeimage =\r\nvpfe_dev->fmt.fmt.pix.bytesperline *\r\nvpfe_dev->fmt.fmt.pix.height;\r\nvpfe_dev->crop = crop->c;\r\nunlock_out:\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic long vpfe_param_handler(struct file *file, void *priv,\r\nbool valid_prio, int cmd, void *param)\r\n{\r\nstruct vpfe_device *vpfe_dev = video_drvdata(file);\r\nint ret = 0;\r\nv4l2_dbg(2, debug, &vpfe_dev->v4l2_dev, "vpfe_param_handler\n");\r\nif (vpfe_dev->started) {\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"device already started\n");\r\nreturn -EBUSY;\r\n}\r\nret = mutex_lock_interruptible(&vpfe_dev->lock);\r\nif (ret)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase VPFE_CMD_S_CCDC_RAW_PARAMS:\r\nv4l2_warn(&vpfe_dev->v4l2_dev,\r\n"VPFE_CMD_S_CCDC_RAW_PARAMS: experimental ioctl\n");\r\nif (ccdc_dev->hw_ops.set_params) {\r\nret = ccdc_dev->hw_ops.set_params(param);\r\nif (ret) {\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"Error setting parameters in CCDC\n");\r\ngoto unlock_out;\r\n}\r\nif (vpfe_get_ccdc_image_format(vpfe_dev,\r\n&vpfe_dev->fmt) < 0) {\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"Invalid image format at CCDC\n");\r\ngoto unlock_out;\r\n}\r\n} else {\r\nret = -EINVAL;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"VPFE_CMD_S_CCDC_RAW_PARAMS not supported\n");\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nunlock_out:\r\nmutex_unlock(&vpfe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic struct vpfe_device *vpfe_initialize(void)\r\n{\r\nstruct vpfe_device *vpfe_dev;\r\nif ((numbuffers > 0) &&\r\n(numbuffers < config_params.min_numbuffers))\r\nnumbuffers = config_params.min_numbuffers;\r\nif (bufsize < config_params.min_bufsize)\r\nbufsize = config_params.min_bufsize;\r\nconfig_params.numbuffers = numbuffers;\r\nif (numbuffers)\r\nconfig_params.device_bufsize = bufsize;\r\nvpfe_dev = kzalloc(sizeof(*vpfe_dev), GFP_KERNEL);\r\nreturn vpfe_dev;\r\n}\r\nstatic __init int vpfe_probe(struct platform_device *pdev)\r\n{\r\nstruct vpfe_subdev_info *sdinfo;\r\nstruct vpfe_config *vpfe_cfg;\r\nstruct resource *res1;\r\nstruct vpfe_device *vpfe_dev;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct video_device *vfd;\r\nint ret = -ENOMEM, i, j;\r\nint num_subdevs = 0;\r\nvpfe_dev = vpfe_initialize();\r\nif (!vpfe_dev) {\r\nv4l2_err(pdev->dev.driver,\r\n"Failed to allocate memory for vpfe_dev\n");\r\nreturn ret;\r\n}\r\nvpfe_dev->pdev = &pdev->dev;\r\nif (NULL == pdev->dev.platform_data) {\r\nv4l2_err(pdev->dev.driver, "Unable to get vpfe config\n");\r\nret = -ENODEV;\r\ngoto probe_free_dev_mem;\r\n}\r\nvpfe_cfg = pdev->dev.platform_data;\r\nvpfe_dev->cfg = vpfe_cfg;\r\nif (NULL == vpfe_cfg->ccdc ||\r\nNULL == vpfe_cfg->card_name ||\r\nNULL == vpfe_cfg->sub_devs) {\r\nv4l2_err(pdev->dev.driver, "null ptr in vpfe_cfg\n");\r\nret = -ENOENT;\r\ngoto probe_free_dev_mem;\r\n}\r\nccdc_cfg = kmalloc(sizeof(struct ccdc_config), GFP_KERNEL);\r\nif (NULL == ccdc_cfg) {\r\nv4l2_err(pdev->dev.driver,\r\n"Memory allocation failed for ccdc_cfg\n");\r\ngoto probe_free_lock;\r\n}\r\nmutex_lock(&ccdc_lock);\r\nstrncpy(ccdc_cfg->name, vpfe_cfg->ccdc, 32);\r\nres1 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res1) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to get interrupt for VINT0\n");\r\nret = -ENODEV;\r\ngoto probe_free_ccdc_cfg_mem;\r\n}\r\nvpfe_dev->ccdc_irq0 = res1->start;\r\nres1 = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\r\nif (!res1) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to get interrupt for VINT1\n");\r\nret = -ENODEV;\r\ngoto probe_free_ccdc_cfg_mem;\r\n}\r\nvpfe_dev->ccdc_irq1 = res1->start;\r\nret = request_irq(vpfe_dev->ccdc_irq0, vpfe_isr, IRQF_DISABLED,\r\n"vpfe_capture0", vpfe_dev);\r\nif (0 != ret) {\r\nv4l2_err(pdev->dev.driver, "Unable to request interrupt\n");\r\ngoto probe_free_ccdc_cfg_mem;\r\n}\r\nvfd = video_device_alloc();\r\nif (NULL == vfd) {\r\nret = -ENOMEM;\r\nv4l2_err(pdev->dev.driver, "Unable to alloc video device\n");\r\ngoto probe_out_release_irq;\r\n}\r\nvfd->release = video_device_release;\r\nvfd->fops = &vpfe_fops;\r\nvfd->ioctl_ops = &vpfe_ioctl_ops;\r\nvfd->tvnorms = 0;\r\nvfd->current_norm = V4L2_STD_PAL;\r\nvfd->v4l2_dev = &vpfe_dev->v4l2_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"%s_V%d.%d.%d",\r\nCAPTURE_DRV_NAME,\r\n(VPFE_CAPTURE_VERSION_CODE >> 16) & 0xff,\r\n(VPFE_CAPTURE_VERSION_CODE >> 8) & 0xff,\r\n(VPFE_CAPTURE_VERSION_CODE) & 0xff);\r\nvpfe_dev->video_dev = vfd;\r\nret = v4l2_device_register(&pdev->dev, &vpfe_dev->v4l2_dev);\r\nif (ret) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to register v4l2 device.\n");\r\ngoto probe_out_video_release;\r\n}\r\nv4l2_info(&vpfe_dev->v4l2_dev, "v4l2 device registered\n");\r\nspin_lock_init(&vpfe_dev->irqlock);\r\nspin_lock_init(&vpfe_dev->dma_queue_lock);\r\nmutex_init(&vpfe_dev->lock);\r\nvpfe_dev->numbuffers = config_params.numbuffers;\r\nv4l2_prio_init(&vpfe_dev->prio);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"trying to register vpfe device.\n");\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"video_dev=%x\n", (int)&vpfe_dev->video_dev);\r\nvpfe_dev->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = video_register_device(vpfe_dev->video_dev,\r\nVFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to register video device.\n");\r\ngoto probe_out_v4l2_unregister;\r\n}\r\nv4l2_info(&vpfe_dev->v4l2_dev, "video device registered\n");\r\nplatform_set_drvdata(pdev, vpfe_dev);\r\nvideo_set_drvdata(vpfe_dev->video_dev, vpfe_dev);\r\ni2c_adap = i2c_get_adapter(vpfe_cfg->i2c_adapter_id);\r\nnum_subdevs = vpfe_cfg->num_subdevs;\r\nvpfe_dev->sd = kmalloc(sizeof(struct v4l2_subdev *) * num_subdevs,\r\nGFP_KERNEL);\r\nif (NULL == vpfe_dev->sd) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"unable to allocate memory for subdevice pointers\n");\r\nret = -ENOMEM;\r\ngoto probe_out_video_unregister;\r\n}\r\nfor (i = 0; i < num_subdevs; i++) {\r\nstruct v4l2_input *inps;\r\nsdinfo = &vpfe_cfg->sub_devs[i];\r\nvpfe_dev->sd[i] =\r\nv4l2_i2c_new_subdev_board(&vpfe_dev->v4l2_dev,\r\ni2c_adap,\r\n&sdinfo->board_info,\r\nNULL);\r\nif (vpfe_dev->sd[i]) {\r\nv4l2_info(&vpfe_dev->v4l2_dev,\r\n"v4l2 sub device %s registered\n",\r\nsdinfo->name);\r\nvpfe_dev->sd[i]->grp_id = sdinfo->grp_id;\r\nfor (j = 0; j < sdinfo->num_inputs; j++) {\r\ninps = &sdinfo->inputs[j];\r\nvfd->tvnorms |= inps->std;\r\n}\r\n} else {\r\nv4l2_info(&vpfe_dev->v4l2_dev,\r\n"v4l2 sub device %s register fails\n",\r\nsdinfo->name);\r\ngoto probe_sd_out;\r\n}\r\n}\r\nvpfe_dev->current_subdev = &vpfe_cfg->sub_devs[0];\r\nmutex_unlock(&ccdc_lock);\r\nreturn 0;\r\nprobe_sd_out:\r\nkfree(vpfe_dev->sd);\r\nprobe_out_video_unregister:\r\nvideo_unregister_device(vpfe_dev->video_dev);\r\nprobe_out_v4l2_unregister:\r\nv4l2_device_unregister(&vpfe_dev->v4l2_dev);\r\nprobe_out_video_release:\r\nif (!video_is_registered(vpfe_dev->video_dev))\r\nvideo_device_release(vpfe_dev->video_dev);\r\nprobe_out_release_irq:\r\nfree_irq(vpfe_dev->ccdc_irq0, vpfe_dev);\r\nprobe_free_ccdc_cfg_mem:\r\nkfree(ccdc_cfg);\r\nprobe_free_lock:\r\nmutex_unlock(&ccdc_lock);\r\nprobe_free_dev_mem:\r\nkfree(vpfe_dev);\r\nreturn ret;\r\n}\r\nstatic int __devexit vpfe_remove(struct platform_device *pdev)\r\n{\r\nstruct vpfe_device *vpfe_dev = platform_get_drvdata(pdev);\r\nv4l2_info(pdev->dev.driver, "vpfe_remove\n");\r\nfree_irq(vpfe_dev->ccdc_irq0, vpfe_dev);\r\nkfree(vpfe_dev->sd);\r\nv4l2_device_unregister(&vpfe_dev->v4l2_dev);\r\nvideo_unregister_device(vpfe_dev->video_dev);\r\nkfree(vpfe_dev);\r\nkfree(ccdc_cfg);\r\nreturn 0;\r\n}\r\nstatic int vpfe_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vpfe_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic __init int vpfe_init(void)\r\n{\r\nprintk(KERN_NOTICE "vpfe_init\n");\r\nreturn platform_driver_register(&vpfe_driver);\r\n}\r\nstatic void vpfe_cleanup(void)\r\n{\r\nplatform_driver_unregister(&vpfe_driver);\r\n}
