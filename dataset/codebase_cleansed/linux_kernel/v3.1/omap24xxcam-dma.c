static void omap24xxcam_dmahw_ack_all(unsigned long base)\r\n{\r\nu32 csr;\r\nint i;\r\nfor (i = 0; i < NUM_CAMDMA_CHANNELS; ++i) {\r\ncsr = omap24xxcam_reg_in(base, CAMDMA_CSR(i));\r\nomap24xxcam_reg_out(base, CAMDMA_CSR(i), csr);\r\n}\r\nomap24xxcam_reg_out(base, CAMDMA_IRQSTATUS_L0, 0xf);\r\n}\r\nstatic u32 omap24xxcam_dmahw_ack_ch(unsigned long base, int dmach)\r\n{\r\nu32 csr;\r\ncsr = omap24xxcam_reg_in(base, CAMDMA_CSR(dmach));\r\nomap24xxcam_reg_out(base, CAMDMA_CSR(dmach), csr);\r\nomap24xxcam_reg_out(base, CAMDMA_IRQSTATUS_L0, (1 << dmach));\r\nreturn csr;\r\n}\r\nstatic int omap24xxcam_dmahw_running(unsigned long base, int dmach)\r\n{\r\nreturn omap24xxcam_reg_in(base, CAMDMA_CCR(dmach)) & CAMDMA_CCR_ENABLE;\r\n}\r\nstatic void omap24xxcam_dmahw_transfer_setup(unsigned long base, int dmach,\r\ndma_addr_t start, u32 len)\r\n{\r\nomap24xxcam_reg_out(base, CAMDMA_CCR(dmach),\r\nCAMDMA_CCR_SEL_SRC_DST_SYNC\r\n| CAMDMA_CCR_BS\r\n| CAMDMA_CCR_DST_AMODE_POST_INC\r\n| CAMDMA_CCR_SRC_AMODE_POST_INC\r\n| CAMDMA_CCR_FS\r\n| CAMDMA_CCR_WR_ACTIVE\r\n| CAMDMA_CCR_RD_ACTIVE\r\n| CAMDMA_CCR_SYNCHRO_CAMERA);\r\nomap24xxcam_reg_out(base, CAMDMA_CLNK_CTRL(dmach), 0);\r\nomap24xxcam_reg_out(base, CAMDMA_CEN(dmach), len);\r\nomap24xxcam_reg_out(base, CAMDMA_CFN(dmach), 1);\r\nomap24xxcam_reg_out(base, CAMDMA_CSDP(dmach),\r\nCAMDMA_CSDP_WRITE_MODE_POSTED\r\n| CAMDMA_CSDP_DST_BURST_EN_32\r\n| CAMDMA_CSDP_DST_PACKED\r\n| CAMDMA_CSDP_SRC_BURST_EN_32\r\n| CAMDMA_CSDP_SRC_PACKED\r\n| CAMDMA_CSDP_DATA_TYPE_8BITS);\r\nomap24xxcam_reg_out(base, CAMDMA_CSSA(dmach), 0);\r\nomap24xxcam_reg_out(base, CAMDMA_CDSA(dmach), start);\r\nomap24xxcam_reg_out(base, CAMDMA_CSEI(dmach), 0);\r\nomap24xxcam_reg_out(base, CAMDMA_CSFI(dmach), DMA_THRESHOLD);\r\nomap24xxcam_reg_out(base, CAMDMA_CDEI(dmach), 0);\r\nomap24xxcam_reg_out(base, CAMDMA_CDFI(dmach), 0);\r\nomap24xxcam_reg_out(base, CAMDMA_CSR(dmach),\r\nCAMDMA_CSR_MISALIGNED_ERR\r\n| CAMDMA_CSR_SECURE_ERR\r\n| CAMDMA_CSR_TRANS_ERR\r\n| CAMDMA_CSR_BLOCK\r\n| CAMDMA_CSR_DROP);\r\nomap24xxcam_reg_out(base, CAMDMA_CICR(dmach),\r\nCAMDMA_CICR_MISALIGNED_ERR_IE\r\n| CAMDMA_CICR_SECURE_ERR_IE\r\n| CAMDMA_CICR_TRANS_ERR_IE\r\n| CAMDMA_CICR_BLOCK_IE\r\n| CAMDMA_CICR_DROP_IE);\r\n}\r\nstatic void omap24xxcam_dmahw_transfer_start(unsigned long base, int dmach)\r\n{\r\nomap24xxcam_reg_out(base, CAMDMA_CCR(dmach),\r\nCAMDMA_CCR_SEL_SRC_DST_SYNC\r\n| CAMDMA_CCR_BS\r\n| CAMDMA_CCR_DST_AMODE_POST_INC\r\n| CAMDMA_CCR_SRC_AMODE_POST_INC\r\n| CAMDMA_CCR_ENABLE\r\n| CAMDMA_CCR_FS\r\n| CAMDMA_CCR_SYNCHRO_CAMERA);\r\n}\r\nstatic void omap24xxcam_dmahw_transfer_chain(unsigned long base, int dmach,\r\nint free_dmach)\r\n{\r\nint prev_dmach, ch;\r\nif (dmach == 0)\r\nprev_dmach = NUM_CAMDMA_CHANNELS - 1;\r\nelse\r\nprev_dmach = dmach - 1;\r\nomap24xxcam_reg_out(base, CAMDMA_CLNK_CTRL(prev_dmach),\r\nCAMDMA_CLNK_CTRL_ENABLE_LNK | dmach);\r\nch = (dmach + free_dmach) % NUM_CAMDMA_CHANNELS;\r\nwhile (!(omap24xxcam_reg_in(base, CAMDMA_CCR(ch))\r\n& CAMDMA_CCR_ENABLE)) {\r\nif (ch == dmach) {\r\nomap24xxcam_dmahw_transfer_start(base, dmach);\r\nbreak;\r\n} else\r\nch = (ch + 1) % NUM_CAMDMA_CHANNELS;\r\n}\r\n}\r\nstatic void omap24xxcam_dmahw_abort_ch(unsigned long base, int dmach)\r\n{\r\nomap24xxcam_reg_out(base, CAMDMA_CICR(dmach), 0);\r\nomap24xxcam_reg_merge(base, CAMDMA_CLNK_CTRL(dmach), 0,\r\nCAMDMA_CLNK_CTRL_ENABLE_LNK);\r\nomap24xxcam_reg_merge(base, CAMDMA_CCR(dmach), 0, CAMDMA_CCR_ENABLE);\r\n}\r\nstatic void omap24xxcam_dmahw_init(unsigned long base)\r\n{\r\nomap24xxcam_reg_out(base, CAMDMA_OCP_SYSCONFIG,\r\nCAMDMA_OCP_SYSCONFIG_MIDLEMODE_FSTANDBY\r\n| CAMDMA_OCP_SYSCONFIG_SIDLEMODE_FIDLE\r\n| CAMDMA_OCP_SYSCONFIG_AUTOIDLE);\r\nomap24xxcam_reg_merge(base, CAMDMA_GCR, 0x10,\r\nCAMDMA_GCR_MAX_CHANNEL_FIFO_DEPTH);\r\nomap24xxcam_reg_out(base, CAMDMA_IRQENABLE_L0, 0xf);\r\n}\r\nstatic int omap24xxcam_dma_start(struct omap24xxcam_dma *dma, dma_addr_t start,\r\nu32 len, dma_callback_t callback, void *arg)\r\n{\r\nunsigned long flags;\r\nint dmach;\r\nspin_lock_irqsave(&dma->lock, flags);\r\nif (!dma->free_dmach || atomic_read(&dma->dma_stop)) {\r\nspin_unlock_irqrestore(&dma->lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndmach = dma->next_dmach;\r\ndma->ch_state[dmach].callback = callback;\r\ndma->ch_state[dmach].arg = arg;\r\nomap24xxcam_dmahw_transfer_setup(dma->base, dmach, start, len);\r\nif (dma->free_dmach < NUM_CAMDMA_CHANNELS) {\r\nomap24xxcam_dmahw_transfer_chain(dma->base, dmach,\r\ndma->free_dmach);\r\n} else {\r\nomap24xxcam_dmahw_transfer_start(dma->base, dmach);\r\n}\r\ndma->next_dmach = (dma->next_dmach + 1) % NUM_CAMDMA_CHANNELS;\r\ndma->free_dmach--;\r\nspin_unlock_irqrestore(&dma->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void omap24xxcam_dma_abort(struct omap24xxcam_dma *dma, u32 csr)\r\n{\r\nunsigned long flags;\r\nint dmach, i, free_dmach;\r\ndma_callback_t callback;\r\nvoid *arg;\r\nspin_lock_irqsave(&dma->lock, flags);\r\ndmach = (dma->next_dmach + dma->free_dmach) % NUM_CAMDMA_CHANNELS;\r\nfor (i = 0; i < NUM_CAMDMA_CHANNELS; i++) {\r\nomap24xxcam_dmahw_abort_ch(dma->base, dmach);\r\ndmach = (dmach + 1) % NUM_CAMDMA_CHANNELS;\r\n}\r\nfree_dmach = dma->free_dmach;\r\nwhile ((dma->free_dmach < NUM_CAMDMA_CHANNELS) &&\r\n(free_dmach < NUM_CAMDMA_CHANNELS)) {\r\ndmach = (dma->next_dmach + dma->free_dmach)\r\n% NUM_CAMDMA_CHANNELS;\r\ncallback = dma->ch_state[dmach].callback;\r\narg = dma->ch_state[dmach].arg;\r\ndma->free_dmach++;\r\nfree_dmach++;\r\nif (callback) {\r\nspin_unlock(&dma->lock);\r\n(*callback) (dma, csr, arg);\r\nspin_lock(&dma->lock);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dma->lock, flags);\r\n}\r\nstatic void omap24xxcam_dma_stop(struct omap24xxcam_dma *dma, u32 csr)\r\n{\r\natomic_inc(&dma->dma_stop);\r\nomap24xxcam_dma_abort(dma, csr);\r\natomic_dec(&dma->dma_stop);\r\n}\r\nvoid omap24xxcam_dma_isr(struct omap24xxcam_dma *dma)\r\n{\r\nint dmach;\r\ndma_callback_t callback;\r\nvoid *arg;\r\nu32 csr;\r\nconst u32 csr_error = CAMDMA_CSR_MISALIGNED_ERR\r\n| CAMDMA_CSR_SUPERVISOR_ERR | CAMDMA_CSR_SECURE_ERR\r\n| CAMDMA_CSR_TRANS_ERR | CAMDMA_CSR_DROP;\r\nspin_lock(&dma->lock);\r\nif (dma->free_dmach == NUM_CAMDMA_CHANNELS) {\r\nomap24xxcam_dmahw_ack_all(dma->base);\r\nspin_unlock(&dma->lock);\r\nreturn;\r\n}\r\nwhile (dma->free_dmach < NUM_CAMDMA_CHANNELS) {\r\ndmach = (dma->next_dmach + dma->free_dmach)\r\n% NUM_CAMDMA_CHANNELS;\r\nif (omap24xxcam_dmahw_running(dma->base, dmach)) {\r\nbreak;\r\n}\r\ncsr = omap24xxcam_dmahw_ack_ch(dma->base, dmach);\r\nif (csr & csr_error) {\r\nspin_unlock(&dma->lock);\r\nomap24xxcam_dma_stop(dma, csr);\r\nreturn;\r\n} else {\r\ncallback = dma->ch_state[dmach].callback;\r\narg = dma->ch_state[dmach].arg;\r\ndma->free_dmach++;\r\nif (callback) {\r\nspin_unlock(&dma->lock);\r\n(*callback) (dma, csr, arg);\r\nspin_lock(&dma->lock);\r\n}\r\n}\r\n}\r\nspin_unlock(&dma->lock);\r\nomap24xxcam_sgdma_process(\r\ncontainer_of(dma, struct omap24xxcam_sgdma, dma));\r\n}\r\nvoid omap24xxcam_dma_hwinit(struct omap24xxcam_dma *dma)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dma->lock, flags);\r\nomap24xxcam_dmahw_init(dma->base);\r\nspin_unlock_irqrestore(&dma->lock, flags);\r\n}\r\nstatic void omap24xxcam_dma_init(struct omap24xxcam_dma *dma,\r\nunsigned long base)\r\n{\r\nint ch;\r\nspin_lock_init(&dma->lock);\r\ndma->base = base;\r\ndma->free_dmach = NUM_CAMDMA_CHANNELS;\r\ndma->next_dmach = 0;\r\nfor (ch = 0; ch < NUM_CAMDMA_CHANNELS; ch++) {\r\ndma->ch_state[ch].callback = NULL;\r\ndma->ch_state[ch].arg = NULL;\r\n}\r\n}\r\nstatic void omap24xxcam_sgdma_callback(struct omap24xxcam_dma *dma, u32 csr,\r\nvoid *arg)\r\n{\r\nstruct omap24xxcam_sgdma *sgdma =\r\ncontainer_of(dma, struct omap24xxcam_sgdma, dma);\r\nint sgslot = (int)arg;\r\nstruct sgdma_state *sg_state;\r\nconst u32 csr_error = CAMDMA_CSR_MISALIGNED_ERR\r\n| CAMDMA_CSR_SUPERVISOR_ERR | CAMDMA_CSR_SECURE_ERR\r\n| CAMDMA_CSR_TRANS_ERR | CAMDMA_CSR_DROP;\r\nspin_lock(&sgdma->lock);\r\ndel_timer(&sgdma->reset_timer);\r\nsg_state = sgdma->sg_state + sgslot;\r\nif (!sg_state->queued_sglist) {\r\nspin_unlock(&sgdma->lock);\r\nprintk(KERN_ERR "%s: sgdma completed when none queued!\n",\r\n__func__);\r\nreturn;\r\n}\r\nsg_state->csr |= csr;\r\nif (!--sg_state->queued_sglist) {\r\nif ((sg_state->next_sglist == sg_state->sglen)\r\n|| (sg_state->csr & csr_error)) {\r\nsgdma_callback_t callback = sg_state->callback;\r\nvoid *arg = sg_state->arg;\r\nu32 sg_csr = sg_state->csr;\r\nsgdma->free_sgdma++;\r\nif (callback) {\r\nspin_unlock(&sgdma->lock);\r\n(*callback) (sgdma, sg_csr, arg);\r\nreturn;\r\n}\r\n}\r\n}\r\nspin_unlock(&sgdma->lock);\r\n}\r\nvoid omap24xxcam_sgdma_process(struct omap24xxcam_sgdma *sgdma)\r\n{\r\nunsigned long flags;\r\nint queued_sgdma, sgslot;\r\nstruct sgdma_state *sg_state;\r\nconst u32 csr_error = CAMDMA_CSR_MISALIGNED_ERR\r\n| CAMDMA_CSR_SUPERVISOR_ERR | CAMDMA_CSR_SECURE_ERR\r\n| CAMDMA_CSR_TRANS_ERR | CAMDMA_CSR_DROP;\r\nspin_lock_irqsave(&sgdma->lock, flags);\r\nqueued_sgdma = NUM_SG_DMA - sgdma->free_sgdma;\r\nsgslot = (sgdma->next_sgdma + sgdma->free_sgdma) % NUM_SG_DMA;\r\nwhile (queued_sgdma > 0) {\r\nsg_state = sgdma->sg_state + sgslot;\r\nwhile ((sg_state->next_sglist < sg_state->sglen) &&\r\n!(sg_state->csr & csr_error)) {\r\nconst struct scatterlist *sglist;\r\nunsigned int len;\r\nsglist = sg_state->sglist + sg_state->next_sglist;\r\nif (sg_state->next_sglist + 1 == sg_state->sglen) {\r\nlen = sg_state->len - sg_state->bytes_read;\r\n} else {\r\nlen = sg_dma_len(sglist);\r\n}\r\nif (omap24xxcam_dma_start(&sgdma->dma,\r\nsg_dma_address(sglist),\r\nlen,\r\nomap24xxcam_sgdma_callback,\r\n(void *)sgslot)) {\r\nspin_unlock_irqrestore(&sgdma->lock, flags);\r\nreturn;\r\n} else {\r\nunsigned long expires;\r\nsg_state->next_sglist++;\r\nsg_state->bytes_read += len;\r\nsg_state->queued_sglist++;\r\nexpires = jiffies + HZ;\r\nmod_timer(&sgdma->reset_timer, expires);\r\n}\r\n}\r\nqueued_sgdma--;\r\nsgslot = (sgslot + 1) % NUM_SG_DMA;\r\n}\r\nspin_unlock_irqrestore(&sgdma->lock, flags);\r\n}\r\nint omap24xxcam_sgdma_queue(struct omap24xxcam_sgdma *sgdma,\r\nconst struct scatterlist *sglist, int sglen,\r\nint len, sgdma_callback_t callback, void *arg)\r\n{\r\nunsigned long flags;\r\nstruct sgdma_state *sg_state;\r\nif ((sglen < 0) || ((sglen > 0) & !sglist))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&sgdma->lock, flags);\r\nif (!sgdma->free_sgdma) {\r\nspin_unlock_irqrestore(&sgdma->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nsg_state = sgdma->sg_state + sgdma->next_sgdma;\r\nsg_state->sglist = sglist;\r\nsg_state->sglen = sglen;\r\nsg_state->next_sglist = 0;\r\nsg_state->bytes_read = 0;\r\nsg_state->len = len;\r\nsg_state->queued_sglist = 0;\r\nsg_state->csr = 0;\r\nsg_state->callback = callback;\r\nsg_state->arg = arg;\r\nsgdma->next_sgdma = (sgdma->next_sgdma + 1) % NUM_SG_DMA;\r\nsgdma->free_sgdma--;\r\nspin_unlock_irqrestore(&sgdma->lock, flags);\r\nomap24xxcam_sgdma_process(sgdma);\r\nreturn 0;\r\n}\r\nvoid omap24xxcam_sgdma_sync(struct omap24xxcam_sgdma *sgdma)\r\n{\r\nunsigned long flags;\r\nint sgslot;\r\nstruct sgdma_state *sg_state;\r\nu32 csr = CAMDMA_CSR_TRANS_ERR;\r\nomap24xxcam_dma_stop(&sgdma->dma, csr);\r\nspin_lock_irqsave(&sgdma->lock, flags);\r\nif (sgdma->free_sgdma < NUM_SG_DMA) {\r\nsgslot = (sgdma->next_sgdma + sgdma->free_sgdma) % NUM_SG_DMA;\r\nsg_state = sgdma->sg_state + sgslot;\r\nif (sg_state->next_sglist != 0) {\r\nsgdma_callback_t callback = sg_state->callback;\r\nvoid *arg = sg_state->arg;\r\nsgdma->free_sgdma++;\r\nif (callback) {\r\nspin_unlock(&sgdma->lock);\r\n(*callback) (sgdma, csr, arg);\r\nspin_lock(&sgdma->lock);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&sgdma->lock, flags);\r\n}\r\nvoid omap24xxcam_sgdma_init(struct omap24xxcam_sgdma *sgdma,\r\nunsigned long base,\r\nvoid (*reset_callback)(unsigned long data),\r\nunsigned long reset_callback_data)\r\n{\r\nint sg;\r\nspin_lock_init(&sgdma->lock);\r\nsgdma->free_sgdma = NUM_SG_DMA;\r\nsgdma->next_sgdma = 0;\r\nfor (sg = 0; sg < NUM_SG_DMA; sg++) {\r\nsgdma->sg_state[sg].sglen = 0;\r\nsgdma->sg_state[sg].next_sglist = 0;\r\nsgdma->sg_state[sg].bytes_read = 0;\r\nsgdma->sg_state[sg].queued_sglist = 0;\r\nsgdma->sg_state[sg].csr = 0;\r\nsgdma->sg_state[sg].callback = NULL;\r\nsgdma->sg_state[sg].arg = NULL;\r\n}\r\nomap24xxcam_dma_init(&sgdma->dma, base);\r\nsetup_timer(&sgdma->reset_timer, reset_callback, reset_callback_data);\r\n}
