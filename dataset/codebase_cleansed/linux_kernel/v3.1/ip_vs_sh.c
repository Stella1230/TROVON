static inline unsigned ip_vs_sh_hashkey(int af, const union nf_inet_addr *addr)\r\n{\r\n__be32 addr_fold = addr->ip;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\naddr_fold = addr->ip6[0]^addr->ip6[1]^\r\naddr->ip6[2]^addr->ip6[3];\r\n#endif\r\nreturn (ntohl(addr_fold)*2654435761UL) & IP_VS_SH_TAB_MASK;\r\n}\r\nstatic inline struct ip_vs_dest *\r\nip_vs_sh_get(int af, struct ip_vs_sh_bucket *tbl,\r\nconst union nf_inet_addr *addr)\r\n{\r\nreturn (tbl[ip_vs_sh_hashkey(af, addr)]).dest;\r\n}\r\nstatic int\r\nip_vs_sh_assign(struct ip_vs_sh_bucket *tbl, struct ip_vs_service *svc)\r\n{\r\nint i;\r\nstruct ip_vs_sh_bucket *b;\r\nstruct list_head *p;\r\nstruct ip_vs_dest *dest;\r\nb = tbl;\r\np = &svc->destinations;\r\nfor (i=0; i<IP_VS_SH_TAB_SIZE; i++) {\r\nif (list_empty(p)) {\r\nb->dest = NULL;\r\n} else {\r\nif (p == &svc->destinations)\r\np = p->next;\r\ndest = list_entry(p, struct ip_vs_dest, n_list);\r\natomic_inc(&dest->refcnt);\r\nb->dest = dest;\r\np = p->next;\r\n}\r\nb++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ip_vs_sh_flush(struct ip_vs_sh_bucket *tbl)\r\n{\r\nint i;\r\nstruct ip_vs_sh_bucket *b;\r\nb = tbl;\r\nfor (i=0; i<IP_VS_SH_TAB_SIZE; i++) {\r\nif (b->dest) {\r\natomic_dec(&b->dest->refcnt);\r\nb->dest = NULL;\r\n}\r\nb++;\r\n}\r\n}\r\nstatic int ip_vs_sh_init_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_sh_bucket *tbl;\r\ntbl = kmalloc(sizeof(struct ip_vs_sh_bucket)*IP_VS_SH_TAB_SIZE,\r\nGFP_ATOMIC);\r\nif (tbl == NULL) {\r\npr_err("%s(): no memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nsvc->sched_data = tbl;\r\nIP_VS_DBG(6, "SH hash table (memory=%Zdbytes) allocated for "\r\n"current service\n",\r\nsizeof(struct ip_vs_sh_bucket)*IP_VS_SH_TAB_SIZE);\r\nip_vs_sh_assign(tbl, svc);\r\nreturn 0;\r\n}\r\nstatic int ip_vs_sh_done_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_sh_bucket *tbl = svc->sched_data;\r\nip_vs_sh_flush(tbl);\r\nkfree(svc->sched_data);\r\nIP_VS_DBG(6, "SH hash table (memory=%Zdbytes) released\n",\r\nsizeof(struct ip_vs_sh_bucket)*IP_VS_SH_TAB_SIZE);\r\nreturn 0;\r\n}\r\nstatic int ip_vs_sh_update_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_sh_bucket *tbl = svc->sched_data;\r\nip_vs_sh_flush(tbl);\r\nip_vs_sh_assign(tbl, svc);\r\nreturn 0;\r\n}\r\nstatic inline int is_overloaded(struct ip_vs_dest *dest)\r\n{\r\nreturn dest->flags & IP_VS_DEST_F_OVERLOAD;\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_sh_schedule(struct ip_vs_service *svc, const struct sk_buff *skb)\r\n{\r\nstruct ip_vs_dest *dest;\r\nstruct ip_vs_sh_bucket *tbl;\r\nstruct ip_vs_iphdr iph;\r\nip_vs_fill_iphdr(svc->af, skb_network_header(skb), &iph);\r\nIP_VS_DBG(6, "ip_vs_sh_schedule(): Scheduling...\n");\r\ntbl = (struct ip_vs_sh_bucket *)svc->sched_data;\r\ndest = ip_vs_sh_get(svc->af, tbl, &iph.saddr);\r\nif (!dest\r\n|| !(dest->flags & IP_VS_DEST_F_AVAILABLE)\r\n|| atomic_read(&dest->weight) <= 0\r\n|| is_overloaded(dest)) {\r\nip_vs_scheduler_err(svc, "no destination available");\r\nreturn NULL;\r\n}\r\nIP_VS_DBG_BUF(6, "SH: source IP address %s --> server %s:%d\n",\r\nIP_VS_DBG_ADDR(svc->af, &iph.saddr),\r\nIP_VS_DBG_ADDR(svc->af, &dest->addr),\r\nntohs(dest->port));\r\nreturn dest;\r\n}\r\nstatic int __init ip_vs_sh_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_sh_scheduler);\r\n}\r\nstatic void __exit ip_vs_sh_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_sh_scheduler);\r\n}
