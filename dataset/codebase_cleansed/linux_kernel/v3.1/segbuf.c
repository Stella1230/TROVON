struct nilfs_segment_buffer *nilfs_segbuf_new(struct super_block *sb)\r\n{\r\nstruct nilfs_segment_buffer *segbuf;\r\nsegbuf = kmem_cache_alloc(nilfs_segbuf_cachep, GFP_NOFS);\r\nif (unlikely(!segbuf))\r\nreturn NULL;\r\nsegbuf->sb_super = sb;\r\nINIT_LIST_HEAD(&segbuf->sb_list);\r\nINIT_LIST_HEAD(&segbuf->sb_segsum_buffers);\r\nINIT_LIST_HEAD(&segbuf->sb_payload_buffers);\r\nsegbuf->sb_super_root = NULL;\r\ninit_completion(&segbuf->sb_bio_event);\r\natomic_set(&segbuf->sb_err, 0);\r\nsegbuf->sb_nbio = 0;\r\nreturn segbuf;\r\n}\r\nvoid nilfs_segbuf_free(struct nilfs_segment_buffer *segbuf)\r\n{\r\nkmem_cache_free(nilfs_segbuf_cachep, segbuf);\r\n}\r\nvoid nilfs_segbuf_map(struct nilfs_segment_buffer *segbuf, __u64 segnum,\r\nunsigned long offset, struct the_nilfs *nilfs)\r\n{\r\nsegbuf->sb_segnum = segnum;\r\nnilfs_get_segment_range(nilfs, segnum, &segbuf->sb_fseg_start,\r\n&segbuf->sb_fseg_end);\r\nsegbuf->sb_pseg_start = segbuf->sb_fseg_start + offset;\r\nsegbuf->sb_rest_blocks =\r\nsegbuf->sb_fseg_end - segbuf->sb_pseg_start + 1;\r\n}\r\nvoid nilfs_segbuf_map_cont(struct nilfs_segment_buffer *segbuf,\r\nstruct nilfs_segment_buffer *prev)\r\n{\r\nsegbuf->sb_segnum = prev->sb_segnum;\r\nsegbuf->sb_fseg_start = prev->sb_fseg_start;\r\nsegbuf->sb_fseg_end = prev->sb_fseg_end;\r\nsegbuf->sb_pseg_start = prev->sb_pseg_start + prev->sb_sum.nblocks;\r\nsegbuf->sb_rest_blocks =\r\nsegbuf->sb_fseg_end - segbuf->sb_pseg_start + 1;\r\n}\r\nvoid nilfs_segbuf_set_next_segnum(struct nilfs_segment_buffer *segbuf,\r\n__u64 nextnum, struct the_nilfs *nilfs)\r\n{\r\nsegbuf->sb_nextnum = nextnum;\r\nsegbuf->sb_sum.next = nilfs_get_segment_start_blocknr(nilfs, nextnum);\r\n}\r\nint nilfs_segbuf_extend_segsum(struct nilfs_segment_buffer *segbuf)\r\n{\r\nstruct buffer_head *bh;\r\nbh = sb_getblk(segbuf->sb_super,\r\nsegbuf->sb_pseg_start + segbuf->sb_sum.nsumblk);\r\nif (unlikely(!bh))\r\nreturn -ENOMEM;\r\nnilfs_segbuf_add_segsum_buffer(segbuf, bh);\r\nreturn 0;\r\n}\r\nint nilfs_segbuf_extend_payload(struct nilfs_segment_buffer *segbuf,\r\nstruct buffer_head **bhp)\r\n{\r\nstruct buffer_head *bh;\r\nbh = sb_getblk(segbuf->sb_super,\r\nsegbuf->sb_pseg_start + segbuf->sb_sum.nblocks);\r\nif (unlikely(!bh))\r\nreturn -ENOMEM;\r\nnilfs_segbuf_add_payload_buffer(segbuf, bh);\r\n*bhp = bh;\r\nreturn 0;\r\n}\r\nint nilfs_segbuf_reset(struct nilfs_segment_buffer *segbuf, unsigned flags,\r\ntime_t ctime, __u64 cno)\r\n{\r\nint err;\r\nsegbuf->sb_sum.nblocks = segbuf->sb_sum.nsumblk = 0;\r\nerr = nilfs_segbuf_extend_segsum(segbuf);\r\nif (unlikely(err))\r\nreturn err;\r\nsegbuf->sb_sum.flags = flags;\r\nsegbuf->sb_sum.sumbytes = sizeof(struct nilfs_segment_summary);\r\nsegbuf->sb_sum.nfinfo = segbuf->sb_sum.nfileblk = 0;\r\nsegbuf->sb_sum.ctime = ctime;\r\nsegbuf->sb_sum.cno = cno;\r\nreturn 0;\r\n}\r\nvoid nilfs_segbuf_fill_in_segsum(struct nilfs_segment_buffer *segbuf)\r\n{\r\nstruct nilfs_segment_summary *raw_sum;\r\nstruct buffer_head *bh_sum;\r\nbh_sum = list_entry(segbuf->sb_segsum_buffers.next,\r\nstruct buffer_head, b_assoc_buffers);\r\nraw_sum = (struct nilfs_segment_summary *)bh_sum->b_data;\r\nraw_sum->ss_magic = cpu_to_le32(NILFS_SEGSUM_MAGIC);\r\nraw_sum->ss_bytes = cpu_to_le16(sizeof(*raw_sum));\r\nraw_sum->ss_flags = cpu_to_le16(segbuf->sb_sum.flags);\r\nraw_sum->ss_seq = cpu_to_le64(segbuf->sb_sum.seg_seq);\r\nraw_sum->ss_create = cpu_to_le64(segbuf->sb_sum.ctime);\r\nraw_sum->ss_next = cpu_to_le64(segbuf->sb_sum.next);\r\nraw_sum->ss_nblocks = cpu_to_le32(segbuf->sb_sum.nblocks);\r\nraw_sum->ss_nfinfo = cpu_to_le32(segbuf->sb_sum.nfinfo);\r\nraw_sum->ss_sumbytes = cpu_to_le32(segbuf->sb_sum.sumbytes);\r\nraw_sum->ss_pad = 0;\r\nraw_sum->ss_cno = cpu_to_le64(segbuf->sb_sum.cno);\r\n}\r\nstatic void\r\nnilfs_segbuf_fill_in_segsum_crc(struct nilfs_segment_buffer *segbuf, u32 seed)\r\n{\r\nstruct buffer_head *bh;\r\nstruct nilfs_segment_summary *raw_sum;\r\nunsigned long size, bytes = segbuf->sb_sum.sumbytes;\r\nu32 crc;\r\nbh = list_entry(segbuf->sb_segsum_buffers.next, struct buffer_head,\r\nb_assoc_buffers);\r\nraw_sum = (struct nilfs_segment_summary *)bh->b_data;\r\nsize = min_t(unsigned long, bytes, bh->b_size);\r\ncrc = crc32_le(seed,\r\n(unsigned char *)raw_sum +\r\nsizeof(raw_sum->ss_datasum) + sizeof(raw_sum->ss_sumsum),\r\nsize - (sizeof(raw_sum->ss_datasum) +\r\nsizeof(raw_sum->ss_sumsum)));\r\nlist_for_each_entry_continue(bh, &segbuf->sb_segsum_buffers,\r\nb_assoc_buffers) {\r\nbytes -= size;\r\nsize = min_t(unsigned long, bytes, bh->b_size);\r\ncrc = crc32_le(crc, bh->b_data, size);\r\n}\r\nraw_sum->ss_sumsum = cpu_to_le32(crc);\r\n}\r\nstatic void nilfs_segbuf_fill_in_data_crc(struct nilfs_segment_buffer *segbuf,\r\nu32 seed)\r\n{\r\nstruct buffer_head *bh;\r\nstruct nilfs_segment_summary *raw_sum;\r\nvoid *kaddr;\r\nu32 crc;\r\nbh = list_entry(segbuf->sb_segsum_buffers.next, struct buffer_head,\r\nb_assoc_buffers);\r\nraw_sum = (struct nilfs_segment_summary *)bh->b_data;\r\ncrc = crc32_le(seed,\r\n(unsigned char *)raw_sum + sizeof(raw_sum->ss_datasum),\r\nbh->b_size - sizeof(raw_sum->ss_datasum));\r\nlist_for_each_entry_continue(bh, &segbuf->sb_segsum_buffers,\r\nb_assoc_buffers) {\r\ncrc = crc32_le(crc, bh->b_data, bh->b_size);\r\n}\r\nlist_for_each_entry(bh, &segbuf->sb_payload_buffers, b_assoc_buffers) {\r\nkaddr = kmap_atomic(bh->b_page, KM_USER0);\r\ncrc = crc32_le(crc, kaddr + bh_offset(bh), bh->b_size);\r\nkunmap_atomic(kaddr, KM_USER0);\r\n}\r\nraw_sum->ss_datasum = cpu_to_le32(crc);\r\n}\r\nstatic void\r\nnilfs_segbuf_fill_in_super_root_crc(struct nilfs_segment_buffer *segbuf,\r\nu32 seed)\r\n{\r\nstruct nilfs_super_root *raw_sr;\r\nstruct the_nilfs *nilfs = segbuf->sb_super->s_fs_info;\r\nunsigned srsize;\r\nu32 crc;\r\nraw_sr = (struct nilfs_super_root *)segbuf->sb_super_root->b_data;\r\nsrsize = NILFS_SR_BYTES(nilfs->ns_inode_size);\r\ncrc = crc32_le(seed,\r\n(unsigned char *)raw_sr + sizeof(raw_sr->sr_sum),\r\nsrsize - sizeof(raw_sr->sr_sum));\r\nraw_sr->sr_sum = cpu_to_le32(crc);\r\n}\r\nstatic void nilfs_release_buffers(struct list_head *list)\r\n{\r\nstruct buffer_head *bh, *n;\r\nlist_for_each_entry_safe(bh, n, list, b_assoc_buffers) {\r\nlist_del_init(&bh->b_assoc_buffers);\r\nbrelse(bh);\r\n}\r\n}\r\nstatic void nilfs_segbuf_clear(struct nilfs_segment_buffer *segbuf)\r\n{\r\nnilfs_release_buffers(&segbuf->sb_segsum_buffers);\r\nnilfs_release_buffers(&segbuf->sb_payload_buffers);\r\nsegbuf->sb_super_root = NULL;\r\n}\r\nvoid nilfs_clear_logs(struct list_head *logs)\r\n{\r\nstruct nilfs_segment_buffer *segbuf;\r\nlist_for_each_entry(segbuf, logs, sb_list)\r\nnilfs_segbuf_clear(segbuf);\r\n}\r\nvoid nilfs_truncate_logs(struct list_head *logs,\r\nstruct nilfs_segment_buffer *last)\r\n{\r\nstruct nilfs_segment_buffer *n, *segbuf;\r\nsegbuf = list_prepare_entry(last, logs, sb_list);\r\nlist_for_each_entry_safe_continue(segbuf, n, logs, sb_list) {\r\nlist_del_init(&segbuf->sb_list);\r\nnilfs_segbuf_clear(segbuf);\r\nnilfs_segbuf_free(segbuf);\r\n}\r\n}\r\nint nilfs_write_logs(struct list_head *logs, struct the_nilfs *nilfs)\r\n{\r\nstruct nilfs_segment_buffer *segbuf;\r\nint ret = 0;\r\nlist_for_each_entry(segbuf, logs, sb_list) {\r\nret = nilfs_segbuf_write(segbuf, nilfs);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint nilfs_wait_on_logs(struct list_head *logs)\r\n{\r\nstruct nilfs_segment_buffer *segbuf;\r\nint err, ret = 0;\r\nlist_for_each_entry(segbuf, logs, sb_list) {\r\nerr = nilfs_segbuf_wait(segbuf);\r\nif (err && !ret)\r\nret = err;\r\n}\r\nreturn ret;\r\n}\r\nvoid nilfs_add_checksums_on_logs(struct list_head *logs, u32 seed)\r\n{\r\nstruct nilfs_segment_buffer *segbuf;\r\nlist_for_each_entry(segbuf, logs, sb_list) {\r\nif (segbuf->sb_super_root)\r\nnilfs_segbuf_fill_in_super_root_crc(segbuf, seed);\r\nnilfs_segbuf_fill_in_segsum_crc(segbuf, seed);\r\nnilfs_segbuf_fill_in_data_crc(segbuf, seed);\r\n}\r\n}\r\nstatic void nilfs_end_bio_write(struct bio *bio, int err)\r\n{\r\nconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\r\nstruct nilfs_segment_buffer *segbuf = bio->bi_private;\r\nif (err == -EOPNOTSUPP) {\r\nset_bit(BIO_EOPNOTSUPP, &bio->bi_flags);\r\nbio_put(bio);\r\n}\r\nif (!uptodate)\r\natomic_inc(&segbuf->sb_err);\r\nbio_put(bio);\r\ncomplete(&segbuf->sb_bio_event);\r\n}\r\nstatic int nilfs_segbuf_submit_bio(struct nilfs_segment_buffer *segbuf,\r\nstruct nilfs_write_info *wi, int mode)\r\n{\r\nstruct bio *bio = wi->bio;\r\nint err;\r\nif (segbuf->sb_nbio > 0 &&\r\nbdi_write_congested(segbuf->sb_super->s_bdi)) {\r\nwait_for_completion(&segbuf->sb_bio_event);\r\nsegbuf->sb_nbio--;\r\nif (unlikely(atomic_read(&segbuf->sb_err))) {\r\nbio_put(bio);\r\nerr = -EIO;\r\ngoto failed;\r\n}\r\n}\r\nbio->bi_end_io = nilfs_end_bio_write;\r\nbio->bi_private = segbuf;\r\nbio_get(bio);\r\nsubmit_bio(mode, bio);\r\nif (bio_flagged(bio, BIO_EOPNOTSUPP)) {\r\nbio_put(bio);\r\nerr = -EOPNOTSUPP;\r\ngoto failed;\r\n}\r\nsegbuf->sb_nbio++;\r\nbio_put(bio);\r\nwi->bio = NULL;\r\nwi->rest_blocks -= wi->end - wi->start;\r\nwi->nr_vecs = min(wi->max_pages, wi->rest_blocks);\r\nwi->start = wi->end;\r\nreturn 0;\r\nfailed:\r\nwi->bio = NULL;\r\nreturn err;\r\n}\r\nstatic struct bio *nilfs_alloc_seg_bio(struct the_nilfs *nilfs, sector_t start,\r\nint nr_vecs)\r\n{\r\nstruct bio *bio;\r\nbio = bio_alloc(GFP_NOIO, nr_vecs);\r\nif (bio == NULL) {\r\nwhile (!bio && (nr_vecs >>= 1))\r\nbio = bio_alloc(GFP_NOIO, nr_vecs);\r\n}\r\nif (likely(bio)) {\r\nbio->bi_bdev = nilfs->ns_bdev;\r\nbio->bi_sector = start << (nilfs->ns_blocksize_bits - 9);\r\n}\r\nreturn bio;\r\n}\r\nstatic void nilfs_segbuf_prepare_write(struct nilfs_segment_buffer *segbuf,\r\nstruct nilfs_write_info *wi)\r\n{\r\nwi->bio = NULL;\r\nwi->rest_blocks = segbuf->sb_sum.nblocks;\r\nwi->max_pages = bio_get_nr_vecs(wi->nilfs->ns_bdev);\r\nwi->nr_vecs = min(wi->max_pages, wi->rest_blocks);\r\nwi->start = wi->end = 0;\r\nwi->blocknr = segbuf->sb_pseg_start;\r\n}\r\nstatic int nilfs_segbuf_submit_bh(struct nilfs_segment_buffer *segbuf,\r\nstruct nilfs_write_info *wi,\r\nstruct buffer_head *bh, int mode)\r\n{\r\nint len, err;\r\nBUG_ON(wi->nr_vecs <= 0);\r\nrepeat:\r\nif (!wi->bio) {\r\nwi->bio = nilfs_alloc_seg_bio(wi->nilfs, wi->blocknr + wi->end,\r\nwi->nr_vecs);\r\nif (unlikely(!wi->bio))\r\nreturn -ENOMEM;\r\n}\r\nlen = bio_add_page(wi->bio, bh->b_page, bh->b_size, bh_offset(bh));\r\nif (len == bh->b_size) {\r\nwi->end++;\r\nreturn 0;\r\n}\r\nerr = nilfs_segbuf_submit_bio(segbuf, wi, mode);\r\nif (likely(!err))\r\ngoto repeat;\r\nreturn err;\r\n}\r\nstatic int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\r\nstruct the_nilfs *nilfs)\r\n{\r\nstruct nilfs_write_info wi;\r\nstruct buffer_head *bh;\r\nint res = 0, rw = WRITE;\r\nwi.nilfs = nilfs;\r\nnilfs_segbuf_prepare_write(segbuf, &wi);\r\nlist_for_each_entry(bh, &segbuf->sb_segsum_buffers, b_assoc_buffers) {\r\nres = nilfs_segbuf_submit_bh(segbuf, &wi, bh, rw);\r\nif (unlikely(res))\r\ngoto failed_bio;\r\n}\r\nlist_for_each_entry(bh, &segbuf->sb_payload_buffers, b_assoc_buffers) {\r\nres = nilfs_segbuf_submit_bh(segbuf, &wi, bh, rw);\r\nif (unlikely(res))\r\ngoto failed_bio;\r\n}\r\nif (wi.bio) {\r\nrw |= REQ_SYNC;\r\nres = nilfs_segbuf_submit_bio(segbuf, &wi, rw);\r\n}\r\nfailed_bio:\r\nreturn res;\r\n}\r\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf)\r\n{\r\nint err = 0;\r\nif (!segbuf->sb_nbio)\r\nreturn 0;\r\ndo {\r\nwait_for_completion(&segbuf->sb_bio_event);\r\n} while (--segbuf->sb_nbio > 0);\r\nif (unlikely(atomic_read(&segbuf->sb_err) > 0)) {\r\nprintk(KERN_ERR "NILFS: IO error writing segment\n");\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}
