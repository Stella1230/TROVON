static inline int is_laguna(const struct cirrusfb_info *cinfo)\r\n{\r\nreturn cinfo->btype == BT_LAGUNA || cinfo->btype == BT_LAGUNAB;\r\n}\r\nstatic int cirrusfb_open(struct fb_info *info, int user)\r\n{\r\nif (opencount++ == 0)\r\nswitch_monitor(info->par, 1);\r\nreturn 0;\r\n}\r\nstatic int cirrusfb_release(struct fb_info *info, int user)\r\n{\r\nif (--opencount == 0)\r\nswitch_monitor(info->par, 0);\r\nreturn 0;\r\n}\r\nstatic int cirrusfb_check_mclk(struct fb_info *info, long freq)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nlong mclk = vga_rseq(cinfo->regbase, CL_SEQR1F) & 0x3f;\r\nmclk = (14318 * mclk) >> 3;\r\ndev_dbg(info->device, "Read MCLK of %ld kHz\n", mclk);\r\nif (abs(freq - mclk) < 250) {\r\ndev_dbg(info->device, "Using VCLK = MCLK\n");\r\nreturn 1;\r\n} else if (abs(freq - (mclk / 2)) < 250) {\r\ndev_dbg(info->device, "Using VCLK = MCLK/2\n");\r\nreturn 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cirrusfb_check_pixclock(const struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nlong freq;\r\nlong maxclock;\r\nstruct cirrusfb_info *cinfo = info->par;\r\nunsigned maxclockidx = var->bits_per_pixel >> 3;\r\nfreq = PICOS2KHZ(var->pixclock);\r\ndev_dbg(info->device, "desired pixclock: %ld kHz\n", freq);\r\nmaxclock = cirrusfb_board_info[cinfo->btype].maxclock[maxclockidx];\r\ncinfo->multiplexing = 0;\r\nif (freq > maxclock) {\r\ndev_err(info->device,\r\n"Frequency greater than maxclock (%ld kHz)\n",\r\nmaxclock);\r\nreturn -EINVAL;\r\n}\r\nif (var->bits_per_pixel == 8) {\r\nswitch (cinfo->btype) {\r\ncase BT_ALPINE:\r\ncase BT_SD64:\r\ncase BT_PICASSO4:\r\nif (freq > 85500)\r\ncinfo->multiplexing = 1;\r\nbreak;\r\ncase BT_GD5480:\r\nif (freq > 135100)\r\ncinfo->multiplexing = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ncinfo->doubleVCLK = 0;\r\nif (cinfo->btype == BT_SD64 && info->fix.smem_len <= MB_ &&\r\nvar->bits_per_pixel == 16) {\r\ncinfo->doubleVCLK = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cirrusfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint yres;\r\nunsigned pixels = info->screen_size * 8 / var->bits_per_pixel;\r\nstruct cirrusfb_info *cinfo = info->par;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\nvar->red.offset = 0;\r\nvar->red.length = 1;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\nbreak;\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\nbreak;\r\ncase 16:\r\nif (isPReP) {\r\nvar->red.offset = 2;\r\nvar->green.offset = -3;\r\nvar->blue.offset = 8;\r\n} else {\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\n}\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 24:\r\nif (isPReP) {\r\nvar->red.offset = 0;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 16;\r\n} else {\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\n}\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ndefault:\r\ndev_dbg(info->device,\r\n"Unsupported bpp size: %d\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual == -1) {\r\nvar->yres_virtual = pixels / var->xres_virtual;\r\ndev_info(info->device,\r\n"virtual resolution set to maximum of %dx%d\n",\r\nvar->xres_virtual, var->yres_virtual);\r\n}\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->xres_virtual * var->yres_virtual > pixels) {\r\ndev_err(info->device, "mode %dx%dx%d rejected... "\r\n"virtual resolution too high to fit into video memory!\n",\r\nvar->xres_virtual, var->yres_virtual,\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (var->xoffset < 0)\r\nvar->xoffset = 0;\r\nif (var->yoffset < 0)\r\nvar->yoffset = 0;\r\nif (var->xoffset > var->xres_virtual - var->xres)\r\nvar->xoffset = var->xres_virtual - var->xres - 1;\r\nif (var->yoffset > var->yres_virtual - var->yres)\r\nvar->yoffset = var->yres_virtual - var->yres - 1;\r\nvar->red.msb_right =\r\nvar->green.msb_right =\r\nvar->blue.msb_right =\r\nvar->transp.offset =\r\nvar->transp.length =\r\nvar->transp.msb_right = 0;\r\nyres = var->yres;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\nyres *= 2;\r\nelse if (var->vmode & FB_VMODE_INTERLACED)\r\nyres = (yres + 1) / 2;\r\nif (yres >= 1280) {\r\ndev_err(info->device, "ERROR: VerticalTotal >= 1280; "\r\n"special treatment required! (TODO)\n");\r\nreturn -EINVAL;\r\n}\r\nif (cirrusfb_check_pixclock(var, info))\r\nreturn -EINVAL;\r\nif (!is_laguna(cinfo))\r\nvar->accel_flags = FB_ACCELF_TEXT;\r\nreturn 0;\r\n}\r\nstatic void cirrusfb_set_mclk_as_source(const struct fb_info *info, int div)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nunsigned char old1f, old1e;\r\nassert(cinfo != NULL);\r\nold1f = vga_rseq(cinfo->regbase, CL_SEQR1F) & ~0x40;\r\nif (div) {\r\ndev_dbg(info->device, "Set %s as pixclock source.\n",\r\n(div == 2) ? "MCLK/2" : "MCLK");\r\nold1f |= 0x40;\r\nold1e = vga_rseq(cinfo->regbase, CL_SEQR1E) & ~0x1;\r\nif (div == 2)\r\nold1e |= 1;\r\nvga_wseq(cinfo->regbase, CL_SEQR1E, old1e);\r\n}\r\nvga_wseq(cinfo->regbase, CL_SEQR1F, old1f);\r\n}\r\nstatic int cirrusfb_set_par_foo(struct fb_info *info)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nu8 __iomem *regbase = cinfo->regbase;\r\nunsigned char tmp;\r\nint pitch;\r\nconst struct cirrusfb_board_info_rec *bi;\r\nint hdispend, hsyncstart, hsyncend, htotal;\r\nint yres, vdispend, vsyncstart, vsyncend, vtotal;\r\nlong freq;\r\nint nom, den, div;\r\nunsigned int control = 0, format = 0, threshold = 0;\r\ndev_dbg(info->device, "Requested mode: %dx%dx%d\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ninfo->fix.line_length = var->xres_virtual / 8;\r\ninfo->fix.visual = FB_VISUAL_MONO10;\r\nbreak;\r\ncase 8:\r\ninfo->fix.line_length = var->xres_virtual;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ncase 16:\r\ncase 24:\r\ninfo->fix.line_length = var->xres_virtual *\r\nvar->bits_per_pixel >> 3;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\n}\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninit_vgachip(info);\r\nbi = &cirrusfb_board_info[cinfo->btype];\r\nhsyncstart = var->xres + var->right_margin;\r\nhsyncend = hsyncstart + var->hsync_len;\r\nhtotal = (hsyncend + var->left_margin) / 8;\r\nhdispend = var->xres / 8;\r\nhsyncstart = hsyncstart / 8;\r\nhsyncend = hsyncend / 8;\r\nvdispend = var->yres;\r\nvsyncstart = vdispend + var->lower_margin;\r\nvsyncend = vsyncstart + var->vsync_len;\r\nvtotal = vsyncend + var->upper_margin;\r\nif (var->vmode & FB_VMODE_DOUBLE) {\r\nvdispend *= 2;\r\nvsyncstart *= 2;\r\nvsyncend *= 2;\r\nvtotal *= 2;\r\n} else if (var->vmode & FB_VMODE_INTERLACED) {\r\nvdispend = (vdispend + 1) / 2;\r\nvsyncstart = (vsyncstart + 1) / 2;\r\nvsyncend = (vsyncend + 1) / 2;\r\nvtotal = (vtotal + 1) / 2;\r\n}\r\nyres = vdispend;\r\nif (yres >= 1024) {\r\nvtotal /= 2;\r\nvsyncstart /= 2;\r\nvsyncend /= 2;\r\nvdispend /= 2;\r\n}\r\nvdispend -= 1;\r\nvsyncstart -= 1;\r\nvsyncend -= 1;\r\nvtotal -= 2;\r\nif (cinfo->multiplexing) {\r\nhtotal /= 2;\r\nhsyncstart /= 2;\r\nhsyncend /= 2;\r\nhdispend /= 2;\r\n}\r\nhtotal -= 5;\r\nhdispend -= 1;\r\nhsyncstart += 1;\r\nhsyncend += 1;\r\nvga_wcrt(regbase, VGA_CRTC_V_SYNC_END, 0x20);\r\ndev_dbg(info->device, "CRT0: %d\n", htotal);\r\nvga_wcrt(regbase, VGA_CRTC_H_TOTAL, htotal);\r\ndev_dbg(info->device, "CRT1: %d\n", hdispend);\r\nvga_wcrt(regbase, VGA_CRTC_H_DISP, hdispend);\r\ndev_dbg(info->device, "CRT2: %d\n", var->xres / 8);\r\nvga_wcrt(regbase, VGA_CRTC_H_BLANK_START, var->xres / 8);\r\ndev_dbg(info->device, "CRT3: 128+%d\n", (htotal + 5) % 32);\r\nvga_wcrt(regbase, VGA_CRTC_H_BLANK_END,\r\n128 + ((htotal + 5) % 32));\r\ndev_dbg(info->device, "CRT4: %d\n", hsyncstart);\r\nvga_wcrt(regbase, VGA_CRTC_H_SYNC_START, hsyncstart);\r\ntmp = hsyncend % 32;\r\nif ((htotal + 5) & 32)\r\ntmp += 128;\r\ndev_dbg(info->device, "CRT5: %d\n", tmp);\r\nvga_wcrt(regbase, VGA_CRTC_H_SYNC_END, tmp);\r\ndev_dbg(info->device, "CRT6: %d\n", vtotal & 0xff);\r\nvga_wcrt(regbase, VGA_CRTC_V_TOTAL, vtotal & 0xff);\r\ntmp = 16;\r\nif (vtotal & 256)\r\ntmp |= 1;\r\nif (vdispend & 256)\r\ntmp |= 2;\r\nif (vsyncstart & 256)\r\ntmp |= 4;\r\nif ((vdispend + 1) & 256)\r\ntmp |= 8;\r\nif (vtotal & 512)\r\ntmp |= 32;\r\nif (vdispend & 512)\r\ntmp |= 64;\r\nif (vsyncstart & 512)\r\ntmp |= 128;\r\ndev_dbg(info->device, "CRT7: %d\n", tmp);\r\nvga_wcrt(regbase, VGA_CRTC_OVERFLOW, tmp);\r\ntmp = 0x40;\r\nif ((vdispend + 1) & 512)\r\ntmp |= 0x20;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\ntmp |= 0x80;\r\ndev_dbg(info->device, "CRT9: %d\n", tmp);\r\nvga_wcrt(regbase, VGA_CRTC_MAX_SCAN, tmp);\r\ndev_dbg(info->device, "CRT10: %d\n", vsyncstart & 0xff);\r\nvga_wcrt(regbase, VGA_CRTC_V_SYNC_START, vsyncstart & 0xff);\r\ndev_dbg(info->device, "CRT11: 64+32+%d\n", vsyncend % 16);\r\nvga_wcrt(regbase, VGA_CRTC_V_SYNC_END, vsyncend % 16 + 64 + 32);\r\ndev_dbg(info->device, "CRT12: %d\n", vdispend & 0xff);\r\nvga_wcrt(regbase, VGA_CRTC_V_DISP_END, vdispend & 0xff);\r\ndev_dbg(info->device, "CRT15: %d\n", (vdispend + 1) & 0xff);\r\nvga_wcrt(regbase, VGA_CRTC_V_BLANK_START, (vdispend + 1) & 0xff);\r\ndev_dbg(info->device, "CRT16: %d\n", vtotal & 0xff);\r\nvga_wcrt(regbase, VGA_CRTC_V_BLANK_END, vtotal & 0xff);\r\ndev_dbg(info->device, "CRT18: 0xff\n");\r\nvga_wcrt(regbase, VGA_CRTC_LINE_COMPARE, 0xff);\r\ntmp = 0;\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\ntmp |= 1;\r\nif ((htotal + 5) & 64)\r\ntmp |= 16;\r\nif ((htotal + 5) & 128)\r\ntmp |= 32;\r\nif (vtotal & 256)\r\ntmp |= 64;\r\nif (vtotal & 512)\r\ntmp |= 128;\r\ndev_dbg(info->device, "CRT1a: %d\n", tmp);\r\nvga_wcrt(regbase, CL_CRT1A, tmp);\r\nfreq = PICOS2KHZ(var->pixclock);\r\nif (var->bits_per_pixel == 24)\r\nif (cinfo->btype == BT_ALPINE || cinfo->btype == BT_SD64)\r\nfreq *= 3;\r\nif (cinfo->multiplexing)\r\nfreq /= 2;\r\nif (cinfo->doubleVCLK)\r\nfreq *= 2;\r\nbestclock(freq, &nom, &den, &div);\r\ndev_dbg(info->device, "VCLK freq: %ld kHz nom: %d den: %d div: %d\n",\r\nfreq, nom, den, div);\r\nif (cinfo->btype == BT_ALPINE || cinfo->btype == BT_PICASSO4 ||\r\ncinfo->btype == BT_SD64) {\r\nint divMCLK = cirrusfb_check_mclk(info, freq);\r\nif (divMCLK)\r\nnom = 0;\r\ncirrusfb_set_mclk_as_source(info, divMCLK);\r\n}\r\nif (is_laguna(cinfo)) {\r\nlong pcifc = fb_readl(cinfo->laguna_mmio + 0x3fc);\r\nunsigned char tile = fb_readb(cinfo->laguna_mmio + 0x407);\r\nunsigned short tile_control;\r\nif (cinfo->btype == BT_LAGUNAB) {\r\ntile_control = fb_readw(cinfo->laguna_mmio + 0x2c4);\r\ntile_control &= ~0x80;\r\nfb_writew(tile_control, cinfo->laguna_mmio + 0x2c4);\r\n}\r\nfb_writel(pcifc | 0x10000000l, cinfo->laguna_mmio + 0x3fc);\r\nfb_writeb(tile & 0x3f, cinfo->laguna_mmio + 0x407);\r\ncontrol = fb_readw(cinfo->laguna_mmio + 0x402);\r\nthreshold = fb_readw(cinfo->laguna_mmio + 0xea);\r\ncontrol &= ~0x6800;\r\nformat = 0;\r\nthreshold &= 0xffc0 & 0x3fbf;\r\n}\r\nif (nom) {\r\ntmp = den << 1;\r\nif (div != 0)\r\ntmp |= 1;\r\nif ((cinfo->btype == BT_SD64) ||\r\n(cinfo->btype == BT_ALPINE) ||\r\n(cinfo->btype == BT_GD5480))\r\ntmp |= 0x80;\r\nif (is_laguna(cinfo)) {\r\nvga_wseq(regbase, CL_SEQRE, tmp);\r\nvga_wseq(regbase, CL_SEQR1E, nom);\r\n} else {\r\nvga_wseq(regbase, CL_SEQRE, nom);\r\nvga_wseq(regbase, CL_SEQR1E, tmp);\r\n}\r\n}\r\nif (yres >= 1024)\r\nvga_wcrt(regbase, VGA_CRTC_MODE, 0xc7);\r\nelse\r\nvga_wcrt(regbase, VGA_CRTC_MODE, 0xc3);\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\nvga_wcrt(regbase, VGA_CRTC_REGS, htotal / 2);\r\nelse\r\nvga_wcrt(regbase, VGA_CRTC_REGS, 0x00);\r\ntmp = 0x03 | 0xc;\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT)\r\ntmp |= 0x40;\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT)\r\ntmp |= 0x80;\r\nWGen(cinfo, VGA_MIS_W, tmp);\r\nvga_wcrt(regbase, VGA_CRTC_CURSOR_START, 0);\r\nvga_wcrt(regbase, VGA_CRTC_CURSOR_END, 31);\r\nif (var->bits_per_pixel == 1) {\r\ndev_dbg(info->device, "preparing for 1 bit deep display\n");\r\nvga_wgfx(regbase, VGA_GFX_MODE, 0);\r\nswitch (cinfo->btype) {\r\ncase BT_SD64:\r\ncase BT_PICCOLO:\r\ncase BT_PICASSO:\r\ncase BT_SPECTRUM:\r\ncase BT_PICASSO4:\r\ncase BT_ALPINE:\r\ncase BT_GD5480:\r\nvga_wseq(regbase, CL_SEQR7,\r\ncinfo->multiplexing ?\r\nbi->sr07_1bpp_mux : bi->sr07_1bpp);\r\nbreak;\r\ncase BT_LAGUNA:\r\ncase BT_LAGUNAB:\r\nvga_wseq(regbase, CL_SEQR7,\r\nvga_rseq(regbase, CL_SEQR7) & ~0x01);\r\nbreak;\r\ndefault:\r\ndev_warn(info->device, "unknown Board\n");\r\nbreak;\r\n}\r\nswitch (cinfo->btype) {\r\ncase BT_PICCOLO:\r\ncase BT_SPECTRUM:\r\nvga_wseq(regbase, CL_SEQRF, 0xb0);\r\nbreak;\r\ncase BT_PICASSO:\r\nvga_wseq(regbase, CL_SEQRF, 0xd0);\r\nbreak;\r\ncase BT_SD64:\r\ncase BT_PICASSO4:\r\ncase BT_ALPINE:\r\ncase BT_GD5480:\r\ncase BT_LAGUNA:\r\ncase BT_LAGUNAB:\r\nbreak;\r\ndefault:\r\ndev_warn(info->device, "unknown Board\n");\r\nbreak;\r\n}\r\nWGen(cinfo, VGA_PEL_MSK, 0x01);\r\nif (cinfo->multiplexing)\r\nWHDR(cinfo, 0x4a);\r\nelse\r\nWHDR(cinfo, 0);\r\nvga_wseq(regbase, VGA_SEQ_MEMORY_MODE, 0x06);\r\nvga_wseq(regbase, VGA_SEQ_PLANE_WRITE, 0x01);\r\n}\r\nelse if (var->bits_per_pixel == 8) {\r\ndev_dbg(info->device, "preparing for 8 bit deep display\n");\r\nswitch (cinfo->btype) {\r\ncase BT_SD64:\r\ncase BT_PICCOLO:\r\ncase BT_PICASSO:\r\ncase BT_SPECTRUM:\r\ncase BT_PICASSO4:\r\ncase BT_ALPINE:\r\ncase BT_GD5480:\r\nvga_wseq(regbase, CL_SEQR7,\r\ncinfo->multiplexing ?\r\nbi->sr07_8bpp_mux : bi->sr07_8bpp);\r\nbreak;\r\ncase BT_LAGUNA:\r\ncase BT_LAGUNAB:\r\nvga_wseq(regbase, CL_SEQR7,\r\nvga_rseq(regbase, CL_SEQR7) | 0x01);\r\nthreshold |= 0x10;\r\nbreak;\r\ndefault:\r\ndev_warn(info->device, "unknown Board\n");\r\nbreak;\r\n}\r\nswitch (cinfo->btype) {\r\ncase BT_PICCOLO:\r\ncase BT_PICASSO:\r\ncase BT_SPECTRUM:\r\nvga_wseq(regbase, CL_SEQRF, 0xb0);\r\nbreak;\r\ncase BT_PICASSO4:\r\n#ifdef CONFIG_ZORRO\r\nvga_wseq(regbase, CL_SEQRF, 0xb8);\r\n#endif\r\ncase BT_ALPINE:\r\ncase BT_SD64:\r\ncase BT_GD5480:\r\ncase BT_LAGUNA:\r\ncase BT_LAGUNAB:\r\nbreak;\r\ndefault:\r\ndev_warn(info->device, "unknown board\n");\r\nbreak;\r\n}\r\nvga_wgfx(regbase, VGA_GFX_MODE, 64);\r\nif (cinfo->multiplexing)\r\nWHDR(cinfo, 0x4a);\r\nelse\r\nWHDR(cinfo, 0);\r\n}\r\nelse if (var->bits_per_pixel == 16) {\r\ndev_dbg(info->device, "preparing for 16 bit deep display\n");\r\nswitch (cinfo->btype) {\r\ncase BT_PICCOLO:\r\ncase BT_SPECTRUM:\r\nvga_wseq(regbase, CL_SEQR7, 0x87);\r\nvga_wseq(regbase, CL_SEQRF, 0xb0);\r\nbreak;\r\ncase BT_PICASSO:\r\nvga_wseq(regbase, CL_SEQR7, 0x27);\r\nvga_wseq(regbase, CL_SEQRF, 0xb0);\r\nbreak;\r\ncase BT_SD64:\r\ncase BT_PICASSO4:\r\ncase BT_ALPINE:\r\nvga_wseq(regbase, CL_SEQR7,\r\ncinfo->doubleVCLK ? 0xa3 : 0xa7);\r\nbreak;\r\ncase BT_GD5480:\r\nvga_wseq(regbase, CL_SEQR7, 0x17);\r\nbreak;\r\ncase BT_LAGUNA:\r\ncase BT_LAGUNAB:\r\nvga_wseq(regbase, CL_SEQR7,\r\nvga_rseq(regbase, CL_SEQR7) & ~0x01);\r\ncontrol |= 0x2000;\r\nformat |= 0x1400;\r\nthreshold |= 0x10;\r\nbreak;\r\ndefault:\r\ndev_warn(info->device, "unknown Board\n");\r\nbreak;\r\n}\r\nvga_wgfx(regbase, VGA_GFX_MODE, 64);\r\n#ifdef CONFIG_PCI\r\nWHDR(cinfo, cinfo->doubleVCLK ? 0xe1 : 0xc1);\r\n#elif defined(CONFIG_ZORRO)\r\nWHDR(cinfo, 0xa0);\r\n#endif\r\n}\r\nelse if (var->bits_per_pixel == 24) {\r\ndev_dbg(info->device, "preparing for 24 bit deep display\n");\r\nswitch (cinfo->btype) {\r\ncase BT_PICCOLO:\r\ncase BT_SPECTRUM:\r\nvga_wseq(regbase, CL_SEQR7, 0x85);\r\nvga_wseq(regbase, CL_SEQRF, 0xb0);\r\nbreak;\r\ncase BT_PICASSO:\r\nvga_wseq(regbase, CL_SEQR7, 0x25);\r\nvga_wseq(regbase, CL_SEQRF, 0xb0);\r\nbreak;\r\ncase BT_SD64:\r\ncase BT_PICASSO4:\r\ncase BT_ALPINE:\r\nvga_wseq(regbase, CL_SEQR7, 0xa5);\r\nbreak;\r\ncase BT_GD5480:\r\nvga_wseq(regbase, CL_SEQR7, 0x15);\r\nbreak;\r\ncase BT_LAGUNA:\r\ncase BT_LAGUNAB:\r\nvga_wseq(regbase, CL_SEQR7,\r\nvga_rseq(regbase, CL_SEQR7) & ~0x01);\r\ncontrol |= 0x4000;\r\nformat |= 0x2400;\r\nthreshold |= 0x20;\r\nbreak;\r\ndefault:\r\ndev_warn(info->device, "unknown Board\n");\r\nbreak;\r\n}\r\nvga_wgfx(regbase, VGA_GFX_MODE, 64);\r\nWHDR(cinfo, 0xc5);\r\n}\r\nelse\r\ndev_err(info->device,\r\n"What's this? requested color depth == %d.\n",\r\nvar->bits_per_pixel);\r\npitch = info->fix.line_length >> 3;\r\nvga_wcrt(regbase, VGA_CRTC_OFFSET, pitch & 0xff);\r\ntmp = 0x22;\r\nif (pitch & 0x100)\r\ntmp |= 0x10;\r\nvga_wcrt(regbase, CL_CRT1B, tmp);\r\nif (cirrusfb_board_info[cinfo->btype].scrn_start_bit19)\r\nvga_wcrt(regbase, CL_CRT1D, (pitch >> 9) & 1);\r\nif (is_laguna(cinfo)) {\r\ntmp = 0;\r\nif ((htotal + 5) & 256)\r\ntmp |= 128;\r\nif (hdispend & 256)\r\ntmp |= 64;\r\nif (hsyncstart & 256)\r\ntmp |= 48;\r\nif (vtotal & 1024)\r\ntmp |= 8;\r\nif (vdispend & 1024)\r\ntmp |= 4;\r\nif (vsyncstart & 1024)\r\ntmp |= 3;\r\nvga_wcrt(regbase, CL_CRT1E, tmp);\r\ndev_dbg(info->device, "CRT1e: %d\n", tmp);\r\n}\r\nvga_wattr(regbase, CL_AR33, 0);\r\nAttrOn(cinfo);\r\nif (is_laguna(cinfo)) {\r\nfb_writew(control | 0x1000, cinfo->laguna_mmio + 0x402);\r\nfb_writew(format, cinfo->laguna_mmio + 0xc0);\r\nfb_writew(threshold, cinfo->laguna_mmio + 0xea);\r\n}\r\ntmp = 0x01;\r\nvga_wseq(regbase, VGA_SEQ_CLOCK_MODE, tmp);\r\ndev_dbg(info->device, "CL_SEQR1: %d\n", tmp);\r\n#ifdef CIRRUSFB_DEBUG\r\ncirrusfb_dbg_reg_dump(info, NULL);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int cirrusfb_set_par(struct fb_info *info)\r\n{\r\ncirrusfb_set_par_foo(info);\r\nreturn cirrusfb_set_par_foo(info);\r\n}\r\nstatic int cirrusfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nif (regno > 255)\r\nreturn -EINVAL;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 v;\r\nred >>= (16 - info->var.red.length);\r\ngreen >>= (16 - info->var.green.length);\r\nblue >>= (16 - info->var.blue.length);\r\nif (regno >= 16)\r\nreturn 1;\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\ncinfo->pseudo_palette[regno] = v;\r\nreturn 0;\r\n}\r\nif (info->var.bits_per_pixel == 8)\r\nWClut(cinfo, regno, red >> 10, green >> 10, blue >> 10);\r\nreturn 0;\r\n}\r\nstatic int cirrusfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint xoffset;\r\nunsigned long base;\r\nunsigned char tmp, xpix;\r\nstruct cirrusfb_info *cinfo = info->par;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\nreturn -EINVAL;\r\nxoffset = var->xoffset * info->var.bits_per_pixel / 8;\r\nbase = var->yoffset * info->fix.line_length + xoffset;\r\nif (info->var.bits_per_pixel == 1) {\r\nxpix = (unsigned char) (var->xoffset % 8);\r\n} else {\r\nbase /= 4;\r\nxpix = (unsigned char) ((xoffset % 4) * 2);\r\n}\r\nif (!is_laguna(cinfo))\r\ncirrusfb_WaitBLT(cinfo->regbase);\r\nvga_wcrt(cinfo->regbase, VGA_CRTC_START_LO, base & 0xff);\r\nvga_wcrt(cinfo->regbase, VGA_CRTC_START_HI, (base >> 8) & 0xff);\r\ntmp = vga_rcrt(cinfo->regbase, CL_CRT1B) & 0xf2;\r\nif (base & 0x10000)\r\ntmp |= 0x01;\r\nif (base & 0x20000)\r\ntmp |= 0x04;\r\nif (base & 0x40000)\r\ntmp |= 0x08;\r\nvga_wcrt(cinfo->regbase, CL_CRT1B, tmp);\r\nif (cirrusfb_board_info[cinfo->btype].scrn_start_bit19) {\r\ntmp = vga_rcrt(cinfo->regbase, CL_CRT1D);\r\nif (is_laguna(cinfo))\r\ntmp = (tmp & ~0x18) | ((base >> 16) & 0x18);\r\nelse\r\ntmp = (tmp & ~0x80) | ((base >> 12) & 0x80);\r\nvga_wcrt(cinfo->regbase, CL_CRT1D, tmp);\r\n}\r\nif (info->var.bits_per_pixel == 1)\r\nvga_wattr(cinfo->regbase, CL_AR33, xpix);\r\nreturn 0;\r\n}\r\nstatic int cirrusfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nunsigned char val;\r\nstruct cirrusfb_info *cinfo = info->par;\r\nint current_mode = cinfo->blank_mode;\r\ndev_dbg(info->device, "ENTER, blank mode = %d\n", blank_mode);\r\nif (info->state != FBINFO_STATE_RUNNING ||\r\ncurrent_mode == blank_mode) {\r\ndev_dbg(info->device, "EXIT, returning 0\n");\r\nreturn 0;\r\n}\r\nif (current_mode == FB_BLANK_NORMAL ||\r\ncurrent_mode == FB_BLANK_UNBLANK)\r\nval = 0;\r\nelse\r\nval = 0x20;\r\nval |= vga_rseq(cinfo->regbase, VGA_SEQ_CLOCK_MODE) & 0xdf;\r\nvga_wseq(cinfo->regbase, VGA_SEQ_CLOCK_MODE, val);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nval = 0x00;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nval = 0x04;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nval = 0x02;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nval = 0x06;\r\nbreak;\r\ndefault:\r\ndev_dbg(info->device, "EXIT, returning 1\n");\r\nreturn 1;\r\n}\r\nvga_wgfx(cinfo->regbase, CL_GRE, val);\r\ncinfo->blank_mode = blank_mode;\r\ndev_dbg(info->device, "EXIT, returning 0\n");\r\nreturn (blank_mode == FB_BLANK_NORMAL) ? 1 : 0;\r\n}\r\nstatic void init_vgachip(struct fb_info *info)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nconst struct cirrusfb_board_info_rec *bi;\r\nassert(cinfo != NULL);\r\nbi = &cirrusfb_board_info[cinfo->btype];\r\nswitch (cinfo->btype) {\r\ncase BT_PICCOLO:\r\nWSFR(cinfo, 0x01);\r\nudelay(500);\r\nWSFR(cinfo, 0x51);\r\nudelay(500);\r\nbreak;\r\ncase BT_PICASSO:\r\nWSFR2(cinfo, 0xff);\r\nudelay(500);\r\nbreak;\r\ncase BT_SD64:\r\ncase BT_SPECTRUM:\r\nWSFR(cinfo, 0x1f);\r\nudelay(500);\r\nWSFR(cinfo, 0x4f);\r\nudelay(500);\r\nbreak;\r\ncase BT_PICASSO4:\r\nvga_wcrt(cinfo->regbase, CL_CRT51, 0x00);\r\nmdelay(100);\r\nvga_wgfx(cinfo->regbase, CL_GR31, 0x00);\r\ncase BT_GD5480:\r\nvga_wgfx(cinfo->regbase, CL_GR2F, 0x00);\r\ncase BT_ALPINE:\r\nvga_wgfx(cinfo->regbase, CL_GR33, 0x00);\r\nbreak;\r\ncase BT_LAGUNA:\r\ncase BT_LAGUNAB:\r\nbreak;\r\ndefault:\r\ndev_err(info->device, "Warning: Unknown board type\n");\r\nbreak;\r\n}\r\nassert(info->screen_size > 0);\r\nif (cinfo->btype != BT_PICASSO4) {\r\nWGen(cinfo, CL_VSSM, 0x10);\r\nWGen(cinfo, CL_POS102, 0x01);\r\nWGen(cinfo, CL_VSSM, 0x08);\r\nif (cinfo->btype != BT_SD64)\r\nWGen(cinfo, CL_VSSM2, 0x01);\r\nvga_wseq(cinfo->regbase, VGA_SEQ_RESET, 0x03);\r\nvga_wseq(cinfo->regbase, VGA_SEQ_CLOCK_MODE, 0x21);\r\nvga_wseq(cinfo->regbase, CL_SEQR6, 0x12);\r\nswitch (cinfo->btype) {\r\ncase BT_GD5480:\r\nvga_wseq(cinfo->regbase, CL_SEQRF, 0x98);\r\nbreak;\r\ncase BT_ALPINE:\r\ncase BT_LAGUNA:\r\ncase BT_LAGUNAB:\r\nbreak;\r\ncase BT_SD64:\r\n#ifdef CONFIG_ZORRO\r\nvga_wseq(cinfo->regbase, CL_SEQRF, 0xb8);\r\n#endif\r\nbreak;\r\ndefault:\r\nvga_wseq(cinfo->regbase, CL_SEQR16, 0x0f);\r\nvga_wseq(cinfo->regbase, CL_SEQRF, 0xb0);\r\nbreak;\r\n}\r\n}\r\nvga_wseq(cinfo->regbase, VGA_SEQ_PLANE_WRITE, 0xff);\r\nvga_wseq(cinfo->regbase, VGA_SEQ_CHARACTER_MAP, 0x00);\r\nvga_wseq(cinfo->regbase, VGA_SEQ_MEMORY_MODE, 0x0a);\r\nif (bi->init_sr07)\r\nvga_wseq(cinfo->regbase, CL_SEQR7, bi->sr07);\r\nvga_wseq(cinfo->regbase, CL_SEQR10, 0x00);\r\nvga_wseq(cinfo->regbase, CL_SEQR11, 0x00);\r\nvga_wseq(cinfo->regbase, CL_SEQR12, 0x00);\r\nvga_wseq(cinfo->regbase, CL_SEQR13, 0x00);\r\nif (cinfo->btype != BT_PICASSO4) {\r\nvga_wseq(cinfo->regbase, CL_SEQR17, 0x00);\r\nvga_wseq(cinfo->regbase, CL_SEQR18, 0x02);\r\n}\r\nvga_wcrt(cinfo->regbase, VGA_CRTC_PRESET_ROW, 0x00);\r\nvga_wcrt(cinfo->regbase, VGA_CRTC_CURSOR_START, 0x20);\r\nvga_wcrt(cinfo->regbase, VGA_CRTC_CURSOR_END, 0x00);\r\nvga_wcrt(cinfo->regbase, VGA_CRTC_CURSOR_HI, 0x00);\r\nvga_wcrt(cinfo->regbase, VGA_CRTC_CURSOR_LO, 0x00);\r\nvga_wcrt(cinfo->regbase, VGA_CRTC_UNDERLINE, 0x00);\r\nvga_wcrt(cinfo->regbase, CL_CRT1B, 0x02);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_SR_VALUE, 0x00);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_SR_ENABLE, 0x00);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_COMPARE_VALUE, 0x00);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_DATA_ROTATE, 0x00);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_PLANE_READ, 0x00);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_MODE, 0x00);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_MISC, 0x01);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_COMPARE_MASK, 0x0f);\r\nvga_wgfx(cinfo->regbase, VGA_GFX_BIT_MASK, 0xff);\r\nif (cinfo->btype == BT_ALPINE || cinfo->btype == BT_SD64 ||\r\nis_laguna(cinfo))\r\nvga_wgfx(cinfo->regbase, CL_GRB, 0x20);\r\nelse\r\nvga_wgfx(cinfo->regbase, CL_GRB, 0x28);\r\nvga_wgfx(cinfo->regbase, CL_GRC, 0xff);\r\nvga_wgfx(cinfo->regbase, CL_GRD, 0x00);\r\nvga_wgfx(cinfo->regbase, CL_GRE, 0x00);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE0, 0x00);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE1, 0x01);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE2, 0x02);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE3, 0x03);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE4, 0x04);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE5, 0x05);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE6, 0x06);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE7, 0x07);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE8, 0x08);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTE9, 0x09);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTEA, 0x0a);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTEB, 0x0b);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTEC, 0x0c);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTED, 0x0d);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTEE, 0x0e);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PALETTEF, 0x0f);\r\nvga_wattr(cinfo->regbase, VGA_ATC_MODE, 0x01);\r\nvga_wattr(cinfo->regbase, VGA_ATC_OVERSCAN, 0x00);\r\nvga_wattr(cinfo->regbase, VGA_ATC_PLANE_ENABLE, 0x0f);\r\nvga_wattr(cinfo->regbase, VGA_ATC_COLOR_PAGE, 0x00);\r\nWGen(cinfo, VGA_PEL_MSK, 0xff);\r\nvga_wgfx(cinfo->regbase, CL_GR31, 0x04);\r\nvga_wgfx(cinfo->regbase, CL_GR31, 0x00);\r\nWHDR(cinfo, 0);\r\nreturn;\r\n}\r\nstatic void switch_monitor(struct cirrusfb_info *cinfo, int on)\r\n{\r\n#ifdef CONFIG_ZORRO\r\nstatic int IsOn = 0;\r\nif (cinfo->btype == BT_PICASSO4)\r\nreturn;\r\nif (cinfo->btype == BT_ALPINE)\r\nreturn;\r\nif (cinfo->btype == BT_GD5480)\r\nreturn;\r\nif (cinfo->btype == BT_PICASSO) {\r\nif ((on && !IsOn) || (!on && IsOn))\r\nWSFR(cinfo, 0xff);\r\nreturn;\r\n}\r\nif (on) {\r\nswitch (cinfo->btype) {\r\ncase BT_SD64:\r\nWSFR(cinfo, cinfo->SFR | 0x21);\r\nbreak;\r\ncase BT_PICCOLO:\r\nWSFR(cinfo, cinfo->SFR | 0x28);\r\nbreak;\r\ncase BT_SPECTRUM:\r\nWSFR(cinfo, 0x6f);\r\nbreak;\r\ndefault: break;\r\n}\r\n} else {\r\nswitch (cinfo->btype) {\r\ncase BT_SD64:\r\nWSFR(cinfo, cinfo->SFR & 0xde);\r\nbreak;\r\ncase BT_PICCOLO:\r\nWSFR(cinfo, cinfo->SFR & 0xd7);\r\nbreak;\r\ncase BT_SPECTRUM:\r\nWSFR(cinfo, 0x4f);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n#endif\r\n}\r\nstatic int cirrusfb_sync(struct fb_info *info)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nif (!is_laguna(cinfo)) {\r\nwhile (vga_rgfx(cinfo->regbase, CL_GR31) & 0x03)\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic void cirrusfb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *region)\r\n{\r\nstruct fb_fillrect modded;\r\nint vxres, vyres;\r\nstruct cirrusfb_info *cinfo = info->par;\r\nint m = info->var.bits_per_pixel;\r\nu32 color = (info->fix.visual == FB_VISUAL_TRUECOLOR) ?\r\ncinfo->pseudo_palette[region->color] : region->color;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_fillrect(info, region);\r\nreturn;\r\n}\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nmemcpy(&modded, region, sizeof(struct fb_fillrect));\r\nif (!modded.width || !modded.height ||\r\nmodded.dx >= vxres || modded.dy >= vyres)\r\nreturn;\r\nif (modded.dx + modded.width > vxres)\r\nmodded.width = vxres - modded.dx;\r\nif (modded.dy + modded.height > vyres)\r\nmodded.height = vyres - modded.dy;\r\ncirrusfb_RectFill(cinfo->regbase,\r\ninfo->var.bits_per_pixel,\r\n(region->dx * m) / 8, region->dy,\r\n(region->width * m) / 8, region->height,\r\ncolor, color,\r\ninfo->fix.line_length, 0x40);\r\n}\r\nstatic void cirrusfb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct fb_copyarea modded;\r\nu32 vxres, vyres;\r\nstruct cirrusfb_info *cinfo = info->par;\r\nint m = info->var.bits_per_pixel;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nmemcpy(&modded, area, sizeof(struct fb_copyarea));\r\nif (!modded.width || !modded.height ||\r\nmodded.sx >= vxres || modded.sy >= vyres ||\r\nmodded.dx >= vxres || modded.dy >= vyres)\r\nreturn;\r\nif (modded.sx + modded.width > vxres)\r\nmodded.width = vxres - modded.sx;\r\nif (modded.dx + modded.width > vxres)\r\nmodded.width = vxres - modded.dx;\r\nif (modded.sy + modded.height > vyres)\r\nmodded.height = vyres - modded.sy;\r\nif (modded.dy + modded.height > vyres)\r\nmodded.height = vyres - modded.dy;\r\ncirrusfb_BitBLT(cinfo->regbase, info->var.bits_per_pixel,\r\n(area->sx * m) / 8, area->sy,\r\n(area->dx * m) / 8, area->dy,\r\n(area->width * m) / 8, area->height,\r\ninfo->fix.line_length);\r\n}\r\nstatic void cirrusfb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nunsigned char op = (info->var.bits_per_pixel == 24) ? 0xc : 0x4;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED || image->depth != 1)\r\ncfb_imageblit(info, image);\r\nelse if ((cinfo->btype == BT_ALPINE || cinfo->btype == BT_SD64) &&\r\nop == 0xc)\r\ncfb_imageblit(info, image);\r\nelse {\r\nunsigned size = ((image->width + 7) >> 3) * image->height;\r\nint m = info->var.bits_per_pixel;\r\nu32 fg, bg;\r\nif (info->var.bits_per_pixel == 8) {\r\nfg = image->fg_color;\r\nbg = image->bg_color;\r\n} else {\r\nfg = ((u32 *)(info->pseudo_palette))[image->fg_color];\r\nbg = ((u32 *)(info->pseudo_palette))[image->bg_color];\r\n}\r\nif (info->var.bits_per_pixel == 24) {\r\ncirrusfb_RectFill(cinfo->regbase,\r\ninfo->var.bits_per_pixel,\r\n(image->dx * m) / 8, image->dy,\r\n(image->width * m) / 8,\r\nimage->height,\r\nbg, bg,\r\ninfo->fix.line_length, 0x40);\r\n}\r\ncirrusfb_RectFill(cinfo->regbase,\r\ninfo->var.bits_per_pixel,\r\n(image->dx * m) / 8, image->dy,\r\n(image->width * m) / 8, image->height,\r\nfg, bg,\r\ninfo->fix.line_length, op);\r\nmemcpy(info->screen_base, image->data, size);\r\n}\r\n}\r\nstatic void get_prep_addrs(unsigned long *display, unsigned long *registers)\r\n{\r\n*display = PREP_VIDEO_BASE;\r\n*registers = (unsigned long) PREP_IO_BASE;\r\n}\r\nstatic unsigned int __devinit cirrusfb_get_memsize(struct fb_info *info,\r\nu8 __iomem *regbase)\r\n{\r\nunsigned long mem;\r\nstruct cirrusfb_info *cinfo = info->par;\r\nif (is_laguna(cinfo)) {\r\nunsigned char SR14 = vga_rseq(regbase, CL_SEQR14);\r\nmem = ((SR14 & 7) + 1) << 20;\r\n} else {\r\nunsigned char SRF = vga_rseq(regbase, CL_SEQRF);\r\nswitch ((SRF & 0x18)) {\r\ncase 0x08:\r\nmem = 512 * 1024;\r\nbreak;\r\ncase 0x10:\r\nmem = 1024 * 1024;\r\nbreak;\r\ncase 0x18:\r\nmem = 2048 * 1024;\r\nbreak;\r\ndefault:\r\ndev_warn(info->device, "Unknown memory size!\n");\r\nmem = 1024 * 1024;\r\n}\r\nif (cinfo->btype != BT_ALPINE && (SRF & 0x80) != 0)\r\nmem *= 2;\r\n}\r\nreturn mem;\r\n}\r\nstatic void get_pci_addrs(const struct pci_dev *pdev,\r\nunsigned long *display, unsigned long *registers)\r\n{\r\nassert(pdev != NULL);\r\nassert(display != NULL);\r\nassert(registers != NULL);\r\n*display = 0;\r\n*registers = 0;\r\nif (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {\r\n*display = pci_resource_start(pdev, 1);\r\n*registers = pci_resource_start(pdev, 0);\r\n} else {\r\n*display = pci_resource_start(pdev, 0);\r\n*registers = pci_resource_start(pdev, 1);\r\n}\r\nassert(*display != 0);\r\n}\r\nstatic void cirrusfb_pci_unmap(struct fb_info *info)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(info->device);\r\nstruct cirrusfb_info *cinfo = info->par;\r\nif (cinfo->laguna_mmio == NULL)\r\niounmap(cinfo->laguna_mmio);\r\niounmap(info->screen_base);\r\n#if 0\r\nrelease_mem_region(0xA0000, 65535);\r\n#endif\r\nif (release_io_ports)\r\nrelease_region(0x3C0, 32);\r\npci_release_regions(pdev);\r\n}\r\nstatic void cirrusfb_zorro_unmap(struct fb_info *info)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nstruct zorro_dev *zdev = to_zorro_dev(info->device);\r\nzorro_release_device(zdev);\r\nif (cinfo->btype == BT_PICASSO4) {\r\ncinfo->regbase -= 0x600000;\r\niounmap((void *)cinfo->regbase);\r\niounmap(info->screen_base);\r\n} else {\r\nif (zorro_resource_start(zdev) > 0x01000000)\r\niounmap(info->screen_base);\r\n}\r\n}\r\nstatic int __devinit cirrusfb_set_fbinfo(struct fb_info *info)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\ninfo->pseudo_palette = cinfo->pseudo_palette;\r\ninfo->flags = FBINFO_DEFAULT\r\n| FBINFO_HWACCEL_XPAN\r\n| FBINFO_HWACCEL_YPAN\r\n| FBINFO_HWACCEL_FILLRECT\r\n| FBINFO_HWACCEL_IMAGEBLIT\r\n| FBINFO_HWACCEL_COPYAREA;\r\nif (noaccel || is_laguna(cinfo)) {\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\n} else\r\ninfo->fix.accel = FB_ACCEL_CIRRUS_ALPINE;\r\ninfo->fbops = &cirrusfb_ops;\r\nif (cinfo->btype == BT_GD5480) {\r\nif (var->bits_per_pixel == 16)\r\ninfo->screen_base += 1 * MB_;\r\nif (var->bits_per_pixel == 32)\r\ninfo->screen_base += 2 * MB_;\r\n}\r\nstrlcpy(info->fix.id, cirrusfb_board_info[cinfo->btype].name,\r\nsizeof(info->fix.id));\r\ninfo->fix.smem_len = info->screen_size;\r\nif (var->bits_per_pixel == 1)\r\ninfo->fix.smem_len /= 4;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 1;\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.mmio_len = 0;\r\nfb_alloc_cmap(&info->cmap, 256, 0);\r\nreturn 0;\r\n}\r\nstatic int __devinit cirrusfb_register(struct fb_info *info)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nint err;\r\nassert(cinfo->btype != BT_NONE);\r\ncirrusfb_set_fbinfo(info);\r\ndev_dbg(info->device, "(RAM start set to: 0x%p)\n", info->screen_base);\r\nerr = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 8);\r\nif (!err) {\r\ndev_dbg(info->device, "wrong initial video mode\n");\r\nerr = -EINVAL;\r\ngoto err_dealloc_cmap;\r\n}\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\nerr = cirrusfb_check_var(&info->var, info);\r\nif (err < 0) {\r\ndev_dbg(info->device,\r\n"choking on default var... umm, no good.\n");\r\ngoto err_dealloc_cmap;\r\n}\r\nerr = register_framebuffer(info);\r\nif (err < 0) {\r\ndev_err(info->device,\r\n"could not register fb device; err = %d!\n", err);\r\ngoto err_dealloc_cmap;\r\n}\r\nreturn 0;\r\nerr_dealloc_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nreturn err;\r\n}\r\nstatic void __devexit cirrusfb_cleanup(struct fb_info *info)\r\n{\r\nstruct cirrusfb_info *cinfo = info->par;\r\nswitch_monitor(cinfo, 0);\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\ndev_dbg(info->device, "Framebuffer unregistered\n");\r\ncinfo->unmap(info);\r\nframebuffer_release(info);\r\n}\r\nstatic int __devinit cirrusfb_pci_register(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct cirrusfb_info *cinfo;\r\nstruct fb_info *info;\r\nunsigned long board_addr, board_size;\r\nint ret;\r\nret = pci_enable_device(pdev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "cirrusfb: Cannot enable PCI device\n");\r\ngoto err_out;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct cirrusfb_info), &pdev->dev);\r\nif (!info) {\r\nprintk(KERN_ERR "cirrusfb: could not allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_out;\r\n}\r\ncinfo = info->par;\r\ncinfo->btype = (enum cirrus_board) ent->driver_data;\r\ndev_dbg(info->device,\r\n" Found PCI device, base address 0 is 0x%Lx, btype set to %d\n",\r\n(unsigned long long)pdev->resource[0].start, cinfo->btype);\r\ndev_dbg(info->device, " base address 1 is 0x%Lx\n",\r\n(unsigned long long)pdev->resource[1].start);\r\nif (isPReP) {\r\npci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, 0x00000000);\r\n#ifdef CONFIG_PPC_PREP\r\nget_prep_addrs(&board_addr, &info->fix.mmio_start);\r\n#endif\r\ncinfo->regbase = (char __iomem *) info->fix.mmio_start;\r\n} else {\r\ndev_dbg(info->device,\r\n"Attempt to get PCI info for Cirrus Graphics Card\n");\r\nget_pci_addrs(pdev, &board_addr, &info->fix.mmio_start);\r\ncinfo->regbase = NULL;\r\ncinfo->laguna_mmio = ioremap(info->fix.mmio_start, 0x1000);\r\n}\r\ndev_dbg(info->device, "Board address: 0x%lx, register address: 0x%lx\n",\r\nboard_addr, info->fix.mmio_start);\r\nboard_size = (cinfo->btype == BT_GD5480) ?\r\n32 * MB_ : cirrusfb_get_memsize(info, cinfo->regbase);\r\nret = pci_request_regions(pdev, "cirrusfb");\r\nif (ret < 0) {\r\ndev_err(info->device, "cannot reserve region 0x%lx, abort\n",\r\nboard_addr);\r\ngoto err_release_fb;\r\n}\r\n#if 0\r\nif (!request_mem_region(0xA0000, 65535, "cirrusfb")) {\r\ndev_err(info->device, "cannot reserve region 0x%lx, abort\n",\r\n0xA0000L);\r\nret = -EBUSY;\r\ngoto err_release_regions;\r\n}\r\n#endif\r\nif (request_region(0x3C0, 32, "cirrusfb"))\r\nrelease_io_ports = 1;\r\ninfo->screen_base = ioremap(board_addr, board_size);\r\nif (!info->screen_base) {\r\nret = -EIO;\r\ngoto err_release_legacy;\r\n}\r\ninfo->fix.smem_start = board_addr;\r\ninfo->screen_size = board_size;\r\ncinfo->unmap = cirrusfb_pci_unmap;\r\ndev_info(info->device,\r\n"Cirrus Logic chipset on PCI bus, RAM (%lu kB) at 0x%lx\n",\r\ninfo->screen_size >> 10, board_addr);\r\npci_set_drvdata(pdev, info);\r\nret = cirrusfb_register(info);\r\nif (!ret)\r\nreturn 0;\r\npci_set_drvdata(pdev, NULL);\r\niounmap(info->screen_base);\r\nerr_release_legacy:\r\nif (release_io_ports)\r\nrelease_region(0x3C0, 32);\r\n#if 0\r\nrelease_mem_region(0xA0000, 65535);\r\nerr_release_regions:\r\n#endif\r\npci_release_regions(pdev);\r\nerr_release_fb:\r\nif (cinfo->laguna_mmio != NULL)\r\niounmap(cinfo->laguna_mmio);\r\nframebuffer_release(info);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void __devexit cirrusfb_pci_unregister(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\ncirrusfb_cleanup(info);\r\n}\r\nstatic int __devinit cirrusfb_zorro_register(struct zorro_dev *z,\r\nconst struct zorro_device_id *ent)\r\n{\r\nstruct cirrusfb_info *cinfo;\r\nstruct fb_info *info;\r\nenum cirrus_board btype;\r\nstruct zorro_dev *z2 = NULL;\r\nunsigned long board_addr, board_size, size;\r\nint ret;\r\nbtype = ent->driver_data;\r\nif (cirrusfb_zorro_table2[btype].id2)\r\nz2 = zorro_find_device(cirrusfb_zorro_table2[btype].id2, NULL);\r\nsize = cirrusfb_zorro_table2[btype].size;\r\ninfo = framebuffer_alloc(sizeof(struct cirrusfb_info), &z->dev);\r\nif (!info) {\r\nprintk(KERN_ERR "cirrusfb: could not allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_out;\r\n}\r\ndev_info(info->device, "%s board detected\n",\r\ncirrusfb_board_info[btype].name);\r\ncinfo = info->par;\r\ncinfo->btype = btype;\r\nassert(z);\r\nassert(btype != BT_NONE);\r\nboard_addr = zorro_resource_start(z);\r\nboard_size = zorro_resource_len(z);\r\ninfo->screen_size = size;\r\nif (!zorro_request_device(z, "cirrusfb")) {\r\ndev_err(info->device, "cannot reserve region 0x%lx, abort\n",\r\nboard_addr);\r\nret = -EBUSY;\r\ngoto err_release_fb;\r\n}\r\nret = -EIO;\r\nif (btype == BT_PICASSO4) {\r\ndev_info(info->device, " REG at $%lx\n", board_addr + 0x600000);\r\ncinfo->regbase = ioremap(board_addr, 16777216);\r\nif (!cinfo->regbase)\r\ngoto err_release_region;\r\ndev_dbg(info->device, "Virtual address for board set to: $%p\n",\r\ncinfo->regbase);\r\ncinfo->regbase += 0x600000;\r\ninfo->fix.mmio_start = board_addr + 0x600000;\r\ninfo->fix.smem_start = board_addr + 16777216;\r\ninfo->screen_base = ioremap(info->fix.smem_start, 16777216);\r\nif (!info->screen_base)\r\ngoto err_unmap_regbase;\r\n} else {\r\ndev_info(info->device, " REG at $%lx\n",\r\n(unsigned long) z2->resource.start);\r\ninfo->fix.smem_start = board_addr;\r\nif (board_addr > 0x01000000)\r\ninfo->screen_base = ioremap(board_addr, board_size);\r\nelse\r\ninfo->screen_base = (caddr_t) ZTWO_VADDR(board_addr);\r\nif (!info->screen_base)\r\ngoto err_release_region;\r\ncinfo->regbase = (caddr_t) ZTWO_VADDR(z2->resource.start);\r\ninfo->fix.mmio_start = z2->resource.start;\r\ndev_dbg(info->device, "Virtual address for board set to: $%p\n",\r\ncinfo->regbase);\r\n}\r\ncinfo->unmap = cirrusfb_zorro_unmap;\r\ndev_info(info->device,\r\n"Cirrus Logic chipset on Zorro bus, RAM (%lu MB) at $%lx\n",\r\nboard_size / MB_, board_addr);\r\nzorro_set_drvdata(z, info);\r\nif (cirrusfb_board_info[btype].init_sr1f)\r\nvga_wseq(cinfo->regbase, CL_SEQR1F,\r\ncirrusfb_board_info[btype].sr1f);\r\nret = cirrusfb_register(info);\r\nif (!ret)\r\nreturn 0;\r\nif (btype == BT_PICASSO4 || board_addr > 0x01000000)\r\niounmap(info->screen_base);\r\nerr_unmap_regbase:\r\nif (btype == BT_PICASSO4)\r\niounmap(cinfo->regbase - 0x600000);\r\nerr_release_region:\r\nrelease_region(board_addr, board_size);\r\nerr_release_fb:\r\nframebuffer_release(info);\r\nerr_out:\r\nreturn ret;\r\n}\r\nvoid __devexit cirrusfb_zorro_unregister(struct zorro_dev *z)\r\n{\r\nstruct fb_info *info = zorro_get_drvdata(z);\r\ncirrusfb_cleanup(info);\r\n}\r\nstatic int __init cirrusfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strcmp(this_opt, "noaccel"))\r\nnoaccel = 1;\r\nelse if (!strncmp(this_opt, "mode:", 5))\r\nmode_option = this_opt + 5;\r\nelse\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init cirrusfb_init(void)\r\n{\r\nint error = 0;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("cirrusfb", &option))\r\nreturn -ENODEV;\r\ncirrusfb_setup(option);\r\n#endif\r\n#ifdef CONFIG_ZORRO\r\nerror |= zorro_register_driver(&cirrusfb_zorro_driver);\r\n#endif\r\n#ifdef CONFIG_PCI\r\nerror |= pci_register_driver(&cirrusfb_pci_driver);\r\n#endif\r\nreturn error;\r\n}\r\nstatic void __exit cirrusfb_exit(void)\r\n{\r\n#ifdef CONFIG_PCI\r\npci_unregister_driver(&cirrusfb_pci_driver);\r\n#endif\r\n#ifdef CONFIG_ZORRO\r\nzorro_unregister_driver(&cirrusfb_zorro_driver);\r\n#endif\r\n}\r\nstatic void WGen(const struct cirrusfb_info *cinfo,\r\nint regnum, unsigned char val)\r\n{\r\nunsigned long regofs = 0;\r\nif (cinfo->btype == BT_PICASSO) {\r\nif (regnum == VGA_PEL_IR || regnum == VGA_PEL_D)\r\nregofs = 0xfff;\r\n}\r\nvga_w(cinfo->regbase, regofs + regnum, val);\r\n}\r\nstatic unsigned char RGen(const struct cirrusfb_info *cinfo, int regnum)\r\n{\r\nunsigned long regofs = 0;\r\nif (cinfo->btype == BT_PICASSO) {\r\nif (regnum == VGA_PEL_IR || regnum == VGA_PEL_D)\r\nregofs = 0xfff;\r\n}\r\nreturn vga_r(cinfo->regbase, regofs + regnum);\r\n}\r\nstatic void AttrOn(const struct cirrusfb_info *cinfo)\r\n{\r\nassert(cinfo != NULL);\r\nif (vga_rcrt(cinfo->regbase, CL_CRT24) & 0x80) {\r\nvga_w(cinfo->regbase, VGA_ATT_IW,\r\nvga_r(cinfo->regbase, VGA_ATT_R));\r\n}\r\nvga_w(cinfo->regbase, VGA_ATT_IW, 0x33);\r\nvga_w(cinfo->regbase, VGA_ATT_IW, 0x00);\r\n}\r\nstatic void WHDR(const struct cirrusfb_info *cinfo, unsigned char val)\r\n{\r\nunsigned char dummy;\r\nif (is_laguna(cinfo))\r\nreturn;\r\nif (cinfo->btype == BT_PICASSO) {\r\nWGen(cinfo, VGA_PEL_MSK, 0x00);\r\nudelay(200);\r\ndummy = RGen(cinfo, VGA_PEL_IW);\r\nudelay(200);\r\n}\r\ndummy = RGen(cinfo, VGA_PEL_MSK);\r\nudelay(200);\r\ndummy = RGen(cinfo, VGA_PEL_MSK);\r\nudelay(200);\r\ndummy = RGen(cinfo, VGA_PEL_MSK);\r\nudelay(200);\r\ndummy = RGen(cinfo, VGA_PEL_MSK);\r\nudelay(200);\r\nWGen(cinfo, VGA_PEL_MSK, val);\r\nudelay(200);\r\nif (cinfo->btype == BT_PICASSO) {\r\ndummy = RGen(cinfo, VGA_PEL_IW);\r\nudelay(200);\r\nWGen(cinfo, VGA_PEL_MSK, 0xff);\r\nudelay(200);\r\n}\r\n}\r\nstatic void WSFR(struct cirrusfb_info *cinfo, unsigned char val)\r\n{\r\n#ifdef CONFIG_ZORRO\r\nassert(cinfo->regbase != NULL);\r\ncinfo->SFR = val;\r\nz_writeb(val, cinfo->regbase + 0x8000);\r\n#endif\r\n}\r\nstatic void WSFR2(struct cirrusfb_info *cinfo, unsigned char val)\r\n{\r\n#ifdef CONFIG_ZORRO\r\nassert(cinfo->regbase != NULL);\r\ncinfo->SFR = val;\r\nz_writeb(val, cinfo->regbase + 0x9000);\r\n#endif\r\n}\r\nstatic void WClut(struct cirrusfb_info *cinfo, unsigned char regnum, unsigned char red,\r\nunsigned char green, unsigned char blue)\r\n{\r\nunsigned int data = VGA_PEL_D;\r\nvga_w(cinfo->regbase, VGA_PEL_IW, regnum);\r\nif (cinfo->btype == BT_PICASSO || cinfo->btype == BT_PICASSO4 ||\r\ncinfo->btype == BT_ALPINE || cinfo->btype == BT_GD5480 ||\r\ncinfo->btype == BT_SD64 || is_laguna(cinfo)) {\r\nif (cinfo->btype == BT_PICASSO)\r\ndata += 0xfff;\r\nvga_w(cinfo->regbase, data, red);\r\nvga_w(cinfo->regbase, data, green);\r\nvga_w(cinfo->regbase, data, blue);\r\n} else {\r\nvga_w(cinfo->regbase, data, blue);\r\nvga_w(cinfo->regbase, data, green);\r\nvga_w(cinfo->regbase, data, red);\r\n}\r\n}\r\nstatic void cirrusfb_WaitBLT(u8 __iomem *regbase)\r\n{\r\nwhile (vga_rgfx(regbase, CL_GR31) & 0x08)\r\ncpu_relax();\r\n}\r\nstatic void cirrusfb_set_blitter(u8 __iomem *regbase,\r\nu_short nwidth, u_short nheight,\r\nu_long nsrc, u_long ndest,\r\nu_short bltmode, u_short line_length)\r\n{\r\nvga_wgfx(regbase, CL_GR24, line_length & 0xff);\r\nvga_wgfx(regbase, CL_GR25, line_length >> 8);\r\nvga_wgfx(regbase, CL_GR26, line_length & 0xff);\r\nvga_wgfx(regbase, CL_GR27, line_length >> 8);\r\nvga_wgfx(regbase, CL_GR20, nwidth & 0xff);\r\nvga_wgfx(regbase, CL_GR21, nwidth >> 8);\r\nvga_wgfx(regbase, CL_GR22, nheight & 0xff);\r\nvga_wgfx(regbase, CL_GR23, nheight >> 8);\r\nvga_wgfx(regbase, CL_GR28, (u_char) (ndest & 0xff));\r\nvga_wgfx(regbase, CL_GR29, (u_char) (ndest >> 8));\r\nvga_wgfx(regbase, CL_GR2A, (u_char) (ndest >> 16));\r\nvga_wgfx(regbase, CL_GR2C, (u_char) (nsrc & 0xff));\r\nvga_wgfx(regbase, CL_GR2D, (u_char) (nsrc >> 8));\r\nvga_wgfx(regbase, CL_GR2E, (u_char) (nsrc >> 16));\r\nvga_wgfx(regbase, CL_GR30, bltmode);\r\nvga_wgfx(regbase, CL_GR32, 0x0d);\r\nvga_wgfx(regbase, CL_GR31, 0x02);\r\n}\r\nstatic void cirrusfb_BitBLT(u8 __iomem *regbase, int bits_per_pixel,\r\nu_short curx, u_short cury,\r\nu_short destx, u_short desty,\r\nu_short width, u_short height,\r\nu_short line_length)\r\n{\r\nu_short nwidth = width - 1;\r\nu_short nheight = height - 1;\r\nu_long nsrc, ndest;\r\nu_char bltmode;\r\nbltmode = 0x00;\r\nif (cury <= desty) {\r\nif (cury == desty) {\r\nif (curx < destx)\r\nbltmode |= 0x01;\r\n} else\r\nbltmode |= 0x01;\r\n}\r\nnsrc = (cury * line_length) + curx;\r\nndest = (desty * line_length) + destx;\r\nif (bltmode) {\r\nnsrc += nheight * line_length + nwidth;\r\nndest += nheight * line_length + nwidth;\r\n}\r\ncirrusfb_WaitBLT(regbase);\r\ncirrusfb_set_blitter(regbase, nwidth, nheight,\r\nnsrc, ndest, bltmode, line_length);\r\n}\r\nstatic void cirrusfb_RectFill(u8 __iomem *regbase, int bits_per_pixel,\r\nu_short x, u_short y, u_short width, u_short height,\r\nu32 fg_color, u32 bg_color, u_short line_length,\r\nu_char blitmode)\r\n{\r\nu_long ndest = (y * line_length) + x;\r\nu_char op;\r\ncirrusfb_WaitBLT(regbase);\r\nvga_wgfx(regbase, VGA_GFX_SR_VALUE, bg_color);\r\nvga_wgfx(regbase, VGA_GFX_SR_ENABLE, fg_color);\r\nop = 0x80;\r\nif (bits_per_pixel >= 16) {\r\nvga_wgfx(regbase, CL_GR10, bg_color >> 8);\r\nvga_wgfx(regbase, CL_GR11, fg_color >> 8);\r\nop = 0x90;\r\n}\r\nif (bits_per_pixel >= 24) {\r\nvga_wgfx(regbase, CL_GR12, bg_color >> 16);\r\nvga_wgfx(regbase, CL_GR13, fg_color >> 16);\r\nop = 0xa0;\r\n}\r\nif (bits_per_pixel == 32) {\r\nvga_wgfx(regbase, CL_GR14, bg_color >> 24);\r\nvga_wgfx(regbase, CL_GR15, fg_color >> 24);\r\nop = 0xb0;\r\n}\r\ncirrusfb_set_blitter(regbase, width - 1, height - 1,\r\n0, ndest, op | blitmode, line_length);\r\n}\r\nstatic void bestclock(long freq, int *nom, int *den, int *div)\r\n{\r\nint n, d;\r\nlong h, diff;\r\nassert(nom != NULL);\r\nassert(den != NULL);\r\nassert(div != NULL);\r\n*nom = 0;\r\n*den = 0;\r\n*div = 0;\r\nif (freq < 8000)\r\nfreq = 8000;\r\ndiff = freq;\r\nfor (n = 32; n < 128; n++) {\r\nint s = 0;\r\nd = (14318 * n) / freq;\r\nif ((d >= 7) && (d <= 63)) {\r\nint temp = d;\r\nif (temp > 31) {\r\ns = 1;\r\ntemp >>= 1;\r\n}\r\nh = ((14318 * n) / temp) >> s;\r\nh = h > freq ? h - freq : freq - h;\r\nif (h < diff) {\r\ndiff = h;\r\n*nom = n;\r\n*den = temp;\r\n*div = s;\r\n}\r\n}\r\nd++;\r\nif ((d >= 7) && (d <= 63)) {\r\nif (d > 31) {\r\ns = 1;\r\nd >>= 1;\r\n}\r\nh = ((14318 * n) / d) >> s;\r\nh = h > freq ? h - freq : freq - h;\r\nif (h < diff) {\r\ndiff = h;\r\n*nom = n;\r\n*den = d;\r\n*div = s;\r\n}\r\n}\r\n}\r\n}\r\nstatic void cirrusfb_dbg_print_regs(struct fb_info *info,\r\ncaddr_t regbase,\r\nenum cirrusfb_dbg_reg_class reg_class, ...)\r\n{\r\nva_list list;\r\nunsigned char val = 0;\r\nunsigned reg;\r\nchar *name;\r\nva_start(list, reg_class);\r\nname = va_arg(list, char *);\r\nwhile (name != NULL) {\r\nreg = va_arg(list, int);\r\nswitch (reg_class) {\r\ncase CRT:\r\nval = vga_rcrt(regbase, (unsigned char) reg);\r\nbreak;\r\ncase SEQ:\r\nval = vga_rseq(regbase, (unsigned char) reg);\r\nbreak;\r\ndefault:\r\nassert(false);\r\nbreak;\r\n}\r\ndev_dbg(info->device, "%8s = 0x%02X\n", name, val);\r\nname = va_arg(list, char *);\r\n}\r\nva_end(list);\r\n}\r\nstatic void cirrusfb_dbg_reg_dump(struct fb_info *info, caddr_t regbase)\r\n{\r\ndev_dbg(info->device, "VGA CRTC register dump:\n");\r\ncirrusfb_dbg_print_regs(info, regbase, CRT,\r\n"CR00", 0x00,\r\n"CR01", 0x01,\r\n"CR02", 0x02,\r\n"CR03", 0x03,\r\n"CR04", 0x04,\r\n"CR05", 0x05,\r\n"CR06", 0x06,\r\n"CR07", 0x07,\r\n"CR08", 0x08,\r\n"CR09", 0x09,\r\n"CR0A", 0x0A,\r\n"CR0B", 0x0B,\r\n"CR0C", 0x0C,\r\n"CR0D", 0x0D,\r\n"CR0E", 0x0E,\r\n"CR0F", 0x0F,\r\n"CR10", 0x10,\r\n"CR11", 0x11,\r\n"CR12", 0x12,\r\n"CR13", 0x13,\r\n"CR14", 0x14,\r\n"CR15", 0x15,\r\n"CR16", 0x16,\r\n"CR17", 0x17,\r\n"CR18", 0x18,\r\n"CR22", 0x22,\r\n"CR24", 0x24,\r\n"CR26", 0x26,\r\n"CR2D", 0x2D,\r\n"CR2E", 0x2E,\r\n"CR2F", 0x2F,\r\n"CR30", 0x30,\r\n"CR31", 0x31,\r\n"CR32", 0x32,\r\n"CR33", 0x33,\r\n"CR34", 0x34,\r\n"CR35", 0x35,\r\n"CR36", 0x36,\r\n"CR37", 0x37,\r\n"CR38", 0x38,\r\n"CR39", 0x39,\r\n"CR3A", 0x3A,\r\n"CR3B", 0x3B,\r\n"CR3C", 0x3C,\r\n"CR3D", 0x3D,\r\n"CR3E", 0x3E,\r\n"CR3F", 0x3F,\r\nNULL);\r\ndev_dbg(info->device, "\n");\r\ndev_dbg(info->device, "VGA SEQ register dump:\n");\r\ncirrusfb_dbg_print_regs(info, regbase, SEQ,\r\n"SR00", 0x00,\r\n"SR01", 0x01,\r\n"SR02", 0x02,\r\n"SR03", 0x03,\r\n"SR04", 0x04,\r\n"SR08", 0x08,\r\n"SR09", 0x09,\r\n"SR0A", 0x0A,\r\n"SR0B", 0x0B,\r\n"SR0D", 0x0D,\r\n"SR10", 0x10,\r\n"SR11", 0x11,\r\n"SR12", 0x12,\r\n"SR13", 0x13,\r\n"SR14", 0x14,\r\n"SR15", 0x15,\r\n"SR16", 0x16,\r\n"SR17", 0x17,\r\n"SR18", 0x18,\r\n"SR19", 0x19,\r\n"SR1A", 0x1A,\r\n"SR1B", 0x1B,\r\n"SR1C", 0x1C,\r\n"SR1D", 0x1D,\r\n"SR1E", 0x1E,\r\n"SR1F", 0x1F,\r\nNULL);\r\ndev_dbg(info->device, "\n");\r\n}
