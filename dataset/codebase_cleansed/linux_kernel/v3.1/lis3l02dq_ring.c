static inline u16 combine_8_to_16(u8 lower, u8 upper)\r\n{\r\nu16 _lower = lower;\r\nu16 _upper = upper;\r\nreturn _lower | (_upper << 8);\r\n}\r\nirqreturn_t lis3l02dq_data_rdy_trig_poll(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nif (st->trigger_on) {\r\niio_trigger_poll(st->trig, iio_get_time_ns());\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nssize_t lis3l02dq_read_accel_from_ring(struct iio_ring_buffer *ring,\r\nint index,\r\nint *val)\r\n{\r\nint ret;\r\ns16 *data;\r\nif (!iio_scan_mask_query(ring, index))\r\nreturn -EINVAL;\r\nif (!ring->access->read_last)\r\nreturn -EBUSY;\r\ndata = kmalloc(ring->access->get_bytes_per_datum(ring),\r\nGFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nret = ring->access->read_last(ring, (u8 *)data);\r\nif (ret)\r\ngoto error_free_data;\r\n*val = data[bitmap_weight(&ring->scan_mask, index)];\r\nerror_free_data:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_read_all(struct iio_dev *indio_dev, u8 *rx_array)\r\n{\r\nstruct iio_ring_buffer *ring = indio_dev->ring;\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nstruct spi_transfer *xfers;\r\nstruct spi_message msg;\r\nint ret, i, j = 0;\r\nxfers = kzalloc((ring->scan_count) * 2\r\n* sizeof(*xfers), GFP_KERNEL);\r\nif (!xfers)\r\nreturn -ENOMEM;\r\nmutex_lock(&st->buf_lock);\r\nfor (i = 0; i < ARRAY_SIZE(read_all_tx_array)/4; i++)\r\nif (ring->scan_mask & (1 << i)) {\r\nxfers[j].tx_buf = st->tx + 2*j;\r\nst->tx[2*j] = read_all_tx_array[i*4];\r\nst->tx[2*j + 1] = 0;\r\nif (rx_array)\r\nxfers[j].rx_buf = rx_array + j*2;\r\nxfers[j].bits_per_word = 8;\r\nxfers[j].len = 2;\r\nxfers[j].cs_change = 1;\r\nj++;\r\nxfers[j].tx_buf = st->tx + 2*j;\r\nst->tx[2*j] = read_all_tx_array[i*4 + 2];\r\nst->tx[2*j + 1] = 0;\r\nif (rx_array)\r\nxfers[j].rx_buf = rx_array + j*2;\r\nxfers[j].bits_per_word = 8;\r\nxfers[j].len = 2;\r\nxfers[j].cs_change = 1;\r\nj++;\r\n}\r\nspi_message_init(&msg);\r\nfor (j = 0; j < ring->scan_count * 2; j++)\r\nspi_message_add_tail(&xfers[j], &msg);\r\nret = spi_sync(st->us, &msg);\r\nmutex_unlock(&st->buf_lock);\r\nkfree(xfers);\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_get_ring_element(struct iio_dev *indio_dev,\r\nu8 *buf)\r\n{\r\nint ret, i;\r\nu8 *rx_array ;\r\ns16 *data = (s16 *)buf;\r\nrx_array = kzalloc(4 * (indio_dev->ring->scan_count), GFP_KERNEL);\r\nif (rx_array == NULL)\r\nreturn -ENOMEM;\r\nret = lis3l02dq_read_all(indio_dev, rx_array);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < indio_dev->ring->scan_count; i++)\r\ndata[i] = combine_8_to_16(rx_array[i*4+1],\r\nrx_array[i*4+3]);\r\nkfree(rx_array);\r\nreturn i*sizeof(data[0]);\r\n}\r\nstatic irqreturn_t lis3l02dq_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->private_data;\r\nstruct iio_ring_buffer *ring = indio_dev->ring;\r\nint len = 0;\r\nsize_t datasize = ring->access->get_bytes_per_datum(ring);\r\nchar *data = kmalloc(datasize, GFP_KERNEL);\r\nif (data == NULL) {\r\ndev_err(indio_dev->dev.parent,\r\n"memory alloc failed in ring bh");\r\nreturn -ENOMEM;\r\n}\r\nif (ring->scan_count)\r\nlen = lis3l02dq_get_ring_element(indio_dev, data);\r\nif (ring->scan_timestamp)\r\n*(s64 *)(((phys_addr_t)data + len\r\n+ sizeof(s64) - 1) & ~(sizeof(s64) - 1))\r\n= pf->timestamp;\r\nring->access->store_to(ring, (u8 *)data, pf->timestamp);\r\niio_trigger_notify_done(indio_dev->trig);\r\nkfree(data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\n__lis3l02dq_write_data_ready_config(struct device *dev, bool state)\r\n{\r\nint ret;\r\nu8 valold;\r\nbool currentlyset;\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nret = lis3l02dq_spi_read_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_2_ADDR,\r\n&valold);\r\nif (ret)\r\ngoto error_ret;\r\ncurrentlyset\r\n= valold & LIS3L02DQ_REG_CTRL_2_ENABLE_DATA_READY_GENERATION;\r\nif (!state && currentlyset) {\r\nvalold &= ~LIS3L02DQ_REG_CTRL_2_ENABLE_DATA_READY_GENERATION;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_2_ADDR,\r\nvalold);\r\nif (ret)\r\ngoto error_ret;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_2_ADDR,\r\nvalold);\r\nif (ret)\r\ngoto error_ret;\r\nst->trigger_on = false;\r\n} else if (state && !currentlyset) {\r\nret = lis3l02dq_disable_all_events(indio_dev);\r\nif (ret < 0)\r\ngoto error_ret;\r\nvalold = ret |\r\nLIS3L02DQ_REG_CTRL_2_ENABLE_DATA_READY_GENERATION;\r\nst->trigger_on = true;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_2_ADDR,\r\nvalold);\r\nif (ret)\r\ngoto error_ret;\r\n}\r\nreturn 0;\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_data_rdy_trigger_set_state(struct iio_trigger *trig,\r\nbool state)\r\n{\r\nstruct iio_dev *indio_dev = trig->private_data;\r\nint ret = 0;\r\nu8 t;\r\n__lis3l02dq_write_data_ready_config(&indio_dev->dev, state);\r\nif (state == false) {\r\nret = lis3l02dq_read_all(indio_dev, NULL);\r\n}\r\nlis3l02dq_spi_read_reg_8(indio_dev,\r\nLIS3L02DQ_REG_WAKE_UP_SRC_ADDR,\r\n&t);\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_trig_try_reen(struct iio_trigger *trig)\r\n{\r\nstruct iio_dev *indio_dev = trig->private_data;\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\nif (gpio_get_value(irq_to_gpio(st->us->irq)))\r\nlis3l02dq_read_all(indio_dev, NULL);\r\nelse\r\nbreak;\r\nif (i == 5)\r\nprintk(KERN_INFO\r\n"Failed to clear the interrupt for lis3l02dq\n");\r\nreturn 0;\r\n}\r\nint lis3l02dq_probe_trigger(struct iio_dev *indio_dev)\r\n{\r\nint ret;\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\nst->trig = iio_allocate_trigger("lis3l02dq-dev%d", indio_dev->id);\r\nif (!st->trig) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nst->trig->dev.parent = &st->us->dev;\r\nst->trig->owner = THIS_MODULE;\r\nst->trig->private_data = indio_dev;\r\nst->trig->set_trigger_state = &lis3l02dq_data_rdy_trigger_set_state;\r\nst->trig->try_reenable = &lis3l02dq_trig_try_reen;\r\nret = iio_trigger_register(st->trig);\r\nif (ret)\r\ngoto error_free_trig;\r\nreturn 0;\r\nerror_free_trig:\r\niio_free_trigger(st->trig);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nvoid lis3l02dq_remove_trigger(struct iio_dev *indio_dev)\r\n{\r\nstruct lis3l02dq_state *st = iio_priv(indio_dev);\r\niio_trigger_unregister(st->trig);\r\niio_free_trigger(st->trig);\r\n}\r\nvoid lis3l02dq_unconfigure_ring(struct iio_dev *indio_dev)\r\n{\r\niio_dealloc_pollfunc(indio_dev->pollfunc);\r\nlis3l02dq_free_buf(indio_dev->ring);\r\n}\r\nstatic int lis3l02dq_ring_postenable(struct iio_dev *indio_dev)\r\n{\r\nu8 t;\r\nint ret;\r\nbool oneenabled = false;\r\nret = lis3l02dq_spi_read_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_1_ADDR,\r\n&t);\r\nif (ret)\r\ngoto error_ret;\r\nif (iio_scan_mask_query(indio_dev->ring, 0)) {\r\nt |= LIS3L02DQ_REG_CTRL_1_AXES_X_ENABLE;\r\noneenabled = true;\r\n} else\r\nt &= ~LIS3L02DQ_REG_CTRL_1_AXES_X_ENABLE;\r\nif (iio_scan_mask_query(indio_dev->ring, 1)) {\r\nt |= LIS3L02DQ_REG_CTRL_1_AXES_Y_ENABLE;\r\noneenabled = true;\r\n} else\r\nt &= ~LIS3L02DQ_REG_CTRL_1_AXES_Y_ENABLE;\r\nif (iio_scan_mask_query(indio_dev->ring, 2)) {\r\nt |= LIS3L02DQ_REG_CTRL_1_AXES_Z_ENABLE;\r\noneenabled = true;\r\n} else\r\nt &= ~LIS3L02DQ_REG_CTRL_1_AXES_Z_ENABLE;\r\nif (!oneenabled)\r\nreturn -EINVAL;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_1_ADDR,\r\nt);\r\nif (ret)\r\ngoto error_ret;\r\nreturn iio_triggered_ring_postenable(indio_dev);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int lis3l02dq_ring_predisable(struct iio_dev *indio_dev)\r\n{\r\nu8 t;\r\nint ret;\r\nret = iio_triggered_ring_predisable(indio_dev);\r\nif (ret)\r\ngoto error_ret;\r\nret = lis3l02dq_spi_read_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_1_ADDR,\r\n&t);\r\nif (ret)\r\ngoto error_ret;\r\nt |= LIS3L02DQ_REG_CTRL_1_AXES_X_ENABLE |\r\nLIS3L02DQ_REG_CTRL_1_AXES_Y_ENABLE |\r\nLIS3L02DQ_REG_CTRL_1_AXES_Z_ENABLE;\r\nret = lis3l02dq_spi_write_reg_8(indio_dev,\r\nLIS3L02DQ_REG_CTRL_1_ADDR,\r\nt);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nint lis3l02dq_configure_ring(struct iio_dev *indio_dev)\r\n{\r\nint ret;\r\nstruct iio_ring_buffer *ring;\r\nring = lis3l02dq_alloc_buf(indio_dev);\r\nif (!ring)\r\nreturn -ENOMEM;\r\nindio_dev->ring = ring;\r\nindio_dev->ring->access = &lis3l02dq_access_funcs;\r\nring->bpe = 2;\r\nring->scan_timestamp = true;\r\nring->setup_ops = &lis3l02dq_ring_setup_ops;\r\nring->owner = THIS_MODULE;\r\niio_scan_mask_set(ring, 0);\r\niio_scan_mask_set(ring, 1);\r\niio_scan_mask_set(ring, 2);\r\nindio_dev->pollfunc = iio_alloc_pollfunc(&iio_pollfunc_store_time,\r\n&lis3l02dq_trigger_handler,\r\n0,\r\nindio_dev,\r\n"lis3l02dq_consumer%d",\r\nindio_dev->id);\r\nif (indio_dev->pollfunc == NULL) {\r\nret = -ENOMEM;\r\ngoto error_iio_sw_rb_free;\r\n}\r\nindio_dev->modes |= INDIO_RING_TRIGGERED;\r\nreturn 0;\r\nerror_iio_sw_rb_free:\r\nlis3l02dq_free_buf(indio_dev->ring);\r\nreturn ret;\r\n}
