static void siu_dai_start(struct siu_port *port_info)\r\n{\r\nstruct siu_info *info = siu_i2s_data;\r\nu32 __iomem *base = info->reg;\r\ndev_dbg(port_info->pcm->card->dev, "%s\n", __func__);\r\npm_runtime_get_sync(info->dev);\r\nsiu_write32(base + SIU_SRCTL, 0);\r\nudelay(1);\r\nport_info->stfifo = 0;\r\nport_info->trdat = 0;\r\nsiu_write32(base + SIU_SRCTL, 0x301);\r\nsiu_write32(base + SIU_CKCTL, 0x40400000);\r\nsiu_write32(base + SIU_BRGASEL, 0);\r\nsiu_write32(base + SIU_BRRA, 0);\r\nsiu_write32(base + SIU_BRGBSEL, 1);\r\nsiu_write32(base + SIU_BRRB, 0);\r\nsiu_write32(base + SIU_IFCTL, 0x44440000);\r\nsiu_write32(base + SIU_SFORM, 0x0c0c0000);\r\nsiu_write32(base + SIU_SBDVCA, port_info->playback.volume);\r\nsiu_write32(base + SIU_SBDVCB, port_info->capture.volume);\r\n}\r\nstatic void siu_dai_stop(struct siu_port *port_info)\r\n{\r\nstruct siu_info *info = siu_i2s_data;\r\nu32 __iomem *base = info->reg;\r\nsiu_write32(base + SIU_SRCTL, 0);\r\npm_runtime_put_sync(info->dev);\r\n}\r\nstatic void siu_dai_spbAselect(struct siu_port *port_info)\r\n{\r\nstruct siu_info *info = siu_i2s_data;\r\nstruct siu_firmware *fw = &info->fw;\r\nu32 *ydef = fw->yram0;\r\nu32 idx;\r\nif (!info->port_id)\r\nidx = 1;\r\nelse\r\nidx = 2;\r\nydef[0] = (fw->spbpar[idx].ab1a << 16) |\r\n(fw->spbpar[idx].ab0a << 8) |\r\n(fw->spbpar[idx].dir << 7) | 3;\r\nydef[1] = fw->yram0[1];\r\nydef[2] = (16 / 2) << 24;\r\nydef[3] = fw->yram0[3];\r\nydef[4] = fw->yram0[4];\r\nydef[7] = fw->spbpar[idx].event;\r\nport_info->stfifo |= fw->spbpar[idx].stfifo;\r\nport_info->trdat |= fw->spbpar[idx].trdat;\r\n}\r\nstatic void siu_dai_spbBselect(struct siu_port *port_info)\r\n{\r\nstruct siu_info *info = siu_i2s_data;\r\nstruct siu_firmware *fw = &info->fw;\r\nu32 *ydef = fw->yram0;\r\nu32 idx;\r\nif (!info->port_id)\r\nidx = 7;\r\nelse\r\nidx = 8;\r\nydef[5] = (fw->spbpar[idx].ab1a << 16) |\r\n(fw->spbpar[idx].ab0a << 8) | 1;\r\nydef[6] = fw->spbpar[idx].event;\r\nport_info->stfifo |= fw->spbpar[idx].stfifo;\r\nport_info->trdat |= fw->spbpar[idx].trdat;\r\n}\r\nstatic void siu_dai_open(struct siu_stream *siu_stream)\r\n{\r\nstruct siu_info *info = siu_i2s_data;\r\nu32 __iomem *base = info->reg;\r\nu32 srctl, ifctl;\r\nsrctl = siu_read32(base + SIU_SRCTL);\r\nifctl = siu_read32(base + SIU_IFCTL);\r\nswitch (info->port_id) {\r\ncase SIU_PORT_A:\r\nsrctl |= 0x200;\r\nifctl &= ~0xc2;\r\nbreak;\r\ncase SIU_PORT_B:\r\nsrctl |= 0x100;\r\nifctl &= ~0x31;\r\nbreak;\r\n}\r\nsiu_write32(base + SIU_SRCTL, srctl);\r\nsiu_write32(base + SIU_IFCTL, ifctl);\r\n}\r\nstatic void siu_dai_pcmdatapack(struct siu_stream *siu_stream)\r\n{\r\nstruct siu_info *info = siu_i2s_data;\r\nu32 __iomem *base = info->reg;\r\nu32 dpak;\r\ndpak = siu_read32(base + SIU_DPAK);\r\nswitch (info->port_id) {\r\ncase SIU_PORT_A:\r\ndpak &= ~0xc0000000;\r\nbreak;\r\ncase SIU_PORT_B:\r\ndpak &= ~0x00c00000;\r\nbreak;\r\n}\r\nsiu_write32(base + SIU_DPAK, dpak);\r\n}\r\nstatic int siu_dai_spbstart(struct siu_port *port_info)\r\n{\r\nstruct siu_info *info = siu_i2s_data;\r\nu32 __iomem *base = info->reg;\r\nstruct siu_firmware *fw = &info->fw;\r\nu32 *ydef = fw->yram0;\r\nint cnt;\r\nu32 __iomem *add;\r\nu32 *ptr;\r\nptr = fw->pram0;\r\nadd = info->pram;\r\nfor (cnt = 0; cnt < PRAM0_SIZE; cnt++, add++, ptr++)\r\nsiu_write32(add, *ptr);\r\nptr = fw->pram1;\r\nadd = info->pram + (0x0100 / sizeof(u32));\r\nfor (cnt = 0; cnt < PRAM1_SIZE; cnt++, add++, ptr++)\r\nsiu_write32(add, *ptr);\r\nadd = info->xram;\r\nfor (cnt = 0; cnt < XRAM0_SIZE + XRAM1_SIZE + XRAM2_SIZE; cnt++, add++)\r\nsiu_write32(add, 0);\r\nadd = info->yram;\r\nfor (cnt = 0; cnt < YRAM_DEF_SIZE; cnt++, add++)\r\nsiu_write32(add, ydef[cnt]);\r\nadd = info->yram + (0x0200 / sizeof(u32));\r\nfor (cnt = 0; cnt < YRAM_FIR_SIZE; cnt++, add++)\r\nsiu_write32(add, fw->yram_fir_coeff[cnt]);\r\nadd = info->yram + (0x0600 / sizeof(u32));\r\nfor (cnt = 0; cnt < YRAM_IIR_SIZE; cnt++, add++)\r\nsiu_write32(add, 0);\r\nsiu_write32(base + SIU_TRDAT, port_info->trdat);\r\nport_info->trdat = 0x0;\r\nsiu_write32(base + SIU_SBACTIV, 0);\r\nsiu_write32(base + SIU_SBCTL, 0xc0000000);\r\ncnt = 0x10000;\r\nwhile (--cnt && siu_read32(base + SIU_SBCTL) != 0x80000000)\r\ncpu_relax();\r\nif (!cnt)\r\nreturn -EBUSY;\r\nsiu_write32(base + SIU_SBPSET, 0x00400000);\r\nsiu_write32(base + SIU_SBACTIV, 0xc0000000);\r\nreturn 0;\r\n}\r\nstatic void siu_dai_spbstop(struct siu_port *port_info)\r\n{\r\nstruct siu_info *info = siu_i2s_data;\r\nu32 __iomem *base = info->reg;\r\nsiu_write32(base + SIU_SBACTIV, 0);\r\nsiu_write32(base + SIU_SBCTL, 0);\r\nport_info->stfifo = 0;\r\n}\r\nstatic int siu_dai_info_volume(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct siu_port *port_info = snd_kcontrol_chip(kctrl);\r\ndev_dbg(port_info->pcm->card->dev, "%s\n", __func__);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = SIU_MAX_VOLUME;\r\nreturn 0;\r\n}\r\nstatic int siu_dai_get_volume(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct siu_port *port_info = snd_kcontrol_chip(kctrl);\r\nstruct device *dev = port_info->pcm->card->dev;\r\nu32 vol;\r\ndev_dbg(dev, "%s\n", __func__);\r\nswitch (kctrl->private_value) {\r\ncase VOLUME_PLAYBACK:\r\nvol = port_info->playback.volume;\r\nucontrol->value.integer.value[0] = vol & 0xffff;\r\nucontrol->value.integer.value[1] = vol >> 16 & 0xffff;\r\nbreak;\r\ncase VOLUME_CAPTURE:\r\nvol = port_info->capture.volume;\r\nucontrol->value.integer.value[0] = vol & 0xffff;\r\nucontrol->value.integer.value[1] = vol >> 16 & 0xffff;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s() invalid private_value=%ld\n",\r\n__func__, kctrl->private_value);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int siu_dai_put_volume(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct siu_port *port_info = snd_kcontrol_chip(kctrl);\r\nstruct device *dev = port_info->pcm->card->dev;\r\nstruct siu_info *info = siu_i2s_data;\r\nu32 __iomem *base = info->reg;\r\nu32 new_vol;\r\nu32 cur_vol;\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (ucontrol->value.integer.value[0] < 0 ||\r\nucontrol->value.integer.value[0] > SIU_MAX_VOLUME ||\r\nucontrol->value.integer.value[1] < 0 ||\r\nucontrol->value.integer.value[1] > SIU_MAX_VOLUME)\r\nreturn -EINVAL;\r\nnew_vol = ucontrol->value.integer.value[0] |\r\nucontrol->value.integer.value[1] << 16;\r\nswitch (kctrl->private_value) {\r\ncase VOLUME_PLAYBACK:\r\ncur_vol = port_info->playback.volume;\r\nsiu_write32(base + SIU_SBDVCA, new_vol);\r\nport_info->playback.volume = new_vol;\r\nbreak;\r\ncase VOLUME_CAPTURE:\r\ncur_vol = port_info->capture.volume;\r\nsiu_write32(base + SIU_SBDVCB, new_vol);\r\nport_info->capture.volume = new_vol;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s() invalid private_value=%ld\n",\r\n__func__, kctrl->private_value);\r\nreturn -EINVAL;\r\n}\r\nif (cur_vol != new_vol)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint siu_init_port(int port, struct siu_port **port_info, struct snd_card *card)\r\n{\r\nstruct device *dev = card->dev;\r\nstruct snd_kcontrol *kctrl;\r\nint ret;\r\n*port_info = kzalloc(sizeof(**port_info), GFP_KERNEL);\r\nif (!*port_info)\r\nreturn -ENOMEM;\r\ndev_dbg(dev, "%s: port #%d@%p\n", __func__, port, *port_info);\r\n(*port_info)->playback.volume = DFLT_VOLUME_LEVEL;\r\n(*port_info)->capture.volume = DFLT_VOLUME_LEVEL;\r\nkctrl = snd_ctl_new1(&playback_controls, *port_info);\r\nret = snd_ctl_add(card, kctrl);\r\nif (ret < 0)\r\ndev_err(dev,\r\n"failed to add playback controls %p port=%d err=%d\n",\r\nkctrl, port, ret);\r\nkctrl = snd_ctl_new1(&capture_controls, *port_info);\r\nret = snd_ctl_add(card, kctrl);\r\nif (ret < 0)\r\ndev_err(dev,\r\n"failed to add capture controls %p port=%d err=%d\n",\r\nkctrl, port, ret);\r\nreturn 0;\r\n}\r\nvoid siu_free_port(struct siu_port *port_info)\r\n{\r\nkfree(port_info);\r\n}\r\nstatic int siu_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct siu_info *info = snd_soc_dai_get_drvdata(dai);\r\nstruct snd_pcm_runtime *rt = substream->runtime;\r\nstruct siu_port *port_info = siu_port_info(substream);\r\nint ret;\r\ndev_dbg(substream->pcm->card->dev, "%s: port=%d@%p\n", __func__,\r\ninfo->port_id, port_info);\r\nsnd_soc_set_runtime_hwparams(substream, &siu_dai_pcm_hw);\r\nret = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nsiu_dai_start(port_info);\r\nreturn 0;\r\n}\r\nstatic void siu_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct siu_info *info = snd_soc_dai_get_drvdata(dai);\r\nstruct siu_port *port_info = siu_port_info(substream);\r\ndev_dbg(substream->pcm->card->dev, "%s: port=%d@%p\n", __func__,\r\ninfo->port_id, port_info);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nport_info->play_cap &= ~PLAYBACK_ENABLED;\r\nelse\r\nport_info->play_cap &= ~CAPTURE_ENABLED;\r\nif (!port_info->play_cap) {\r\nBUG_ON(port_info->playback.rw_flg || port_info->capture.rw_flg);\r\nsiu_dai_spbstop(port_info);\r\nsiu_dai_stop(port_info);\r\n}\r\n}\r\nstatic int siu_dai_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct siu_info *info = snd_soc_dai_get_drvdata(dai);\r\nstruct snd_pcm_runtime *rt = substream->runtime;\r\nstruct siu_port *port_info = siu_port_info(substream);\r\nstruct siu_stream *siu_stream;\r\nint self, ret;\r\ndev_dbg(substream->pcm->card->dev,\r\n"%s: port %d, active streams %lx, %d channels\n",\r\n__func__, info->port_id, port_info->play_cap, rt->channels);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nself = PLAYBACK_ENABLED;\r\nsiu_stream = &port_info->playback;\r\n} else {\r\nself = CAPTURE_ENABLED;\r\nsiu_stream = &port_info->capture;\r\n}\r\nif (!port_info->play_cap) {\r\nsiu_stream->rw_flg = 0;\r\nsiu_dai_spbAselect(port_info);\r\nsiu_dai_spbBselect(port_info);\r\nsiu_dai_open(siu_stream);\r\nsiu_dai_pcmdatapack(siu_stream);\r\nret = siu_dai_spbstart(port_info);\r\nif (ret < 0)\r\ngoto fail;\r\n} else {\r\nret = 0;\r\n}\r\nport_info->play_cap |= self;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int siu_dai_set_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct siu_info *info = snd_soc_dai_get_drvdata(dai);\r\nu32 __iomem *base = info->reg;\r\nu32 ifctl;\r\ndev_dbg(dai->dev, "%s: fmt 0x%x on port %d\n",\r\n__func__, fmt, info->port_id);\r\nif (info->port_id < 0)\r\nreturn -ENODEV;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nifctl = siu_flags[info->port_id].playback.i2s |\r\nsiu_flags[info->port_id].capture.i2s;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nifctl = siu_flags[info->port_id].playback.pcm |\r\nsiu_flags[info->port_id].capture.pcm;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nifctl |= ~(siu_flags[info->port_id].playback.mask |\r\nsiu_flags[info->port_id].capture.mask) &\r\nsiu_read32(base + SIU_IFCTL);\r\nsiu_write32(base + SIU_IFCTL, ifctl);\r\nreturn 0;\r\n}\r\nstatic int siu_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct clk *siu_clk, *parent_clk;\r\nchar *siu_name, *parent_name;\r\nint ret;\r\nif (dir != SND_SOC_CLOCK_IN)\r\nreturn -EINVAL;\r\ndev_dbg(dai->dev, "%s: using clock %d\n", __func__, clk_id);\r\nswitch (clk_id) {\r\ncase SIU_CLKA_PLL:\r\nsiu_name = "siua_clk";\r\nparent_name = "pll_clk";\r\nbreak;\r\ncase SIU_CLKA_EXT:\r\nsiu_name = "siua_clk";\r\nparent_name = "siumcka_clk";\r\nbreak;\r\ncase SIU_CLKB_PLL:\r\nsiu_name = "siub_clk";\r\nparent_name = "pll_clk";\r\nbreak;\r\ncase SIU_CLKB_EXT:\r\nsiu_name = "siub_clk";\r\nparent_name = "siumckb_clk";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsiu_clk = clk_get(dai->dev, siu_name);\r\nif (IS_ERR(siu_clk)) {\r\ndev_err(dai->dev, "%s: cannot get a SIU clock: %ld\n", __func__,\r\nPTR_ERR(siu_clk));\r\nreturn PTR_ERR(siu_clk);\r\n}\r\nparent_clk = clk_get(dai->dev, parent_name);\r\nif (IS_ERR(parent_clk)) {\r\nret = PTR_ERR(parent_clk);\r\ndev_err(dai->dev, "cannot get a SIU clock parent: %d\n", ret);\r\ngoto epclkget;\r\n}\r\nret = clk_set_parent(siu_clk, parent_clk);\r\nif (ret < 0) {\r\ndev_err(dai->dev, "cannot reparent the SIU clock: %d\n", ret);\r\ngoto eclksetp;\r\n}\r\nret = clk_set_rate(siu_clk, freq);\r\nif (ret < 0)\r\ndev_err(dai->dev, "cannot set SIU clock rate: %d\n", ret);\r\neclksetp:\r\nclk_put(parent_clk);\r\nepclkget:\r\nclk_put(siu_clk);\r\nreturn ret;\r\n}\r\nstatic int __devinit siu_probe(struct platform_device *pdev)\r\n{\r\nconst struct firmware *fw_entry;\r\nstruct resource *res, *region;\r\nstruct siu_info *info;\r\nint ret;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nsiu_i2s_data = info;\r\ninfo->dev = &pdev->dev;\r\nret = request_firmware(&fw_entry, "siu_spb.bin", &pdev->dev);\r\nif (ret)\r\ngoto ereqfw;\r\nmemcpy(&info->fw, fw_entry->data, fw_entry->size);\r\nrelease_firmware(fw_entry);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto egetres;\r\n}\r\nregion = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (!region) {\r\ndev_err(&pdev->dev, "SIU region already claimed\n");\r\nret = -EBUSY;\r\ngoto ereqmemreg;\r\n}\r\nret = -ENOMEM;\r\ninfo->pram = ioremap(res->start, PRAM_SIZE);\r\nif (!info->pram)\r\ngoto emappram;\r\ninfo->xram = ioremap(res->start + XRAM_OFFSET, XRAM_SIZE);\r\nif (!info->xram)\r\ngoto emapxram;\r\ninfo->yram = ioremap(res->start + YRAM_OFFSET, YRAM_SIZE);\r\nif (!info->yram)\r\ngoto emapyram;\r\ninfo->reg = ioremap(res->start + REG_OFFSET, resource_size(res) -\r\nREG_OFFSET);\r\nif (!info->reg)\r\ngoto emapreg;\r\ndev_set_drvdata(&pdev->dev, info);\r\nret = snd_soc_register_dais(&pdev->dev, &siu_i2s_dai, 1);\r\nif (ret < 0)\r\ngoto edaiinit;\r\nret = snd_soc_register_platform(&pdev->dev, &siu_platform);\r\nif (ret < 0)\r\ngoto esocregp;\r\npm_runtime_enable(&pdev->dev);\r\nreturn ret;\r\nesocregp:\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nedaiinit:\r\niounmap(info->reg);\r\nemapreg:\r\niounmap(info->yram);\r\nemapyram:\r\niounmap(info->xram);\r\nemapxram:\r\niounmap(info->pram);\r\nemappram:\r\nrelease_mem_region(res->start, resource_size(res));\r\nereqmemreg:\r\negetres:\r\nereqfw:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int __devexit siu_remove(struct platform_device *pdev)\r\n{\r\nstruct siu_info *info = dev_get_drvdata(&pdev->dev);\r\nstruct resource *res;\r\npm_runtime_disable(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nsnd_soc_unregister_dai(&pdev->dev);\r\niounmap(info->reg);\r\niounmap(info->yram);\r\niounmap(info->xram);\r\niounmap(info->pram);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int __init siu_init(void)\r\n{\r\nreturn platform_driver_register(&siu_driver);\r\n}\r\nstatic void __exit siu_exit(void)\r\n{\r\nplatform_driver_unregister(&siu_driver);\r\n}
