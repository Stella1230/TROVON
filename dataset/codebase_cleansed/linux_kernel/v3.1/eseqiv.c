static void eseqiv_complete2(struct skcipher_givcrypt_request *req)\r\n{\r\nstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\r\nstruct eseqiv_request_ctx *reqctx = skcipher_givcrypt_reqctx(req);\r\nmemcpy(req->giv, PTR_ALIGN((u8 *)reqctx->tail,\r\ncrypto_ablkcipher_alignmask(geniv) + 1),\r\ncrypto_ablkcipher_ivsize(geniv));\r\n}\r\nstatic void eseqiv_complete(struct crypto_async_request *base, int err)\r\n{\r\nstruct skcipher_givcrypt_request *req = base->data;\r\nif (err)\r\ngoto out;\r\neseqiv_complete2(req);\r\nout:\r\nskcipher_givcrypt_complete(req, err);\r\n}\r\nstatic int eseqiv_givencrypt(struct skcipher_givcrypt_request *req)\r\n{\r\nstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\r\nstruct eseqiv_ctx *ctx = crypto_ablkcipher_ctx(geniv);\r\nstruct eseqiv_request_ctx *reqctx = skcipher_givcrypt_reqctx(req);\r\nstruct ablkcipher_request *subreq;\r\ncrypto_completion_t complete;\r\nvoid *data;\r\nstruct scatterlist *osrc, *odst;\r\nstruct scatterlist *dst;\r\nstruct page *srcp;\r\nstruct page *dstp;\r\nu8 *giv;\r\nu8 *vsrc;\r\nu8 *vdst;\r\n__be64 seq;\r\nunsigned int ivsize;\r\nunsigned int len;\r\nint err;\r\nsubreq = (void *)(reqctx->tail + ctx->reqoff);\r\nablkcipher_request_set_tfm(subreq, skcipher_geniv_cipher(geniv));\r\ngiv = req->giv;\r\ncomplete = req->creq.base.complete;\r\ndata = req->creq.base.data;\r\nosrc = req->creq.src;\r\nodst = req->creq.dst;\r\nsrcp = sg_page(osrc);\r\ndstp = sg_page(odst);\r\nvsrc = PageHighMem(srcp) ? NULL : page_address(srcp) + osrc->offset;\r\nvdst = PageHighMem(dstp) ? NULL : page_address(dstp) + odst->offset;\r\nivsize = crypto_ablkcipher_ivsize(geniv);\r\nif (vsrc != giv + ivsize && vdst != giv + ivsize) {\r\ngiv = PTR_ALIGN((u8 *)reqctx->tail,\r\ncrypto_ablkcipher_alignmask(geniv) + 1);\r\ncomplete = eseqiv_complete;\r\ndata = req;\r\n}\r\nablkcipher_request_set_callback(subreq, req->creq.base.flags, complete,\r\ndata);\r\nsg_init_table(reqctx->src, 2);\r\nsg_set_buf(reqctx->src, giv, ivsize);\r\nscatterwalk_crypto_chain(reqctx->src, osrc, vsrc == giv + ivsize, 2);\r\ndst = reqctx->src;\r\nif (osrc != odst) {\r\nsg_init_table(reqctx->dst, 2);\r\nsg_set_buf(reqctx->dst, giv, ivsize);\r\nscatterwalk_crypto_chain(reqctx->dst, odst, vdst == giv + ivsize, 2);\r\ndst = reqctx->dst;\r\n}\r\nablkcipher_request_set_crypt(subreq, reqctx->src, dst,\r\nreq->creq.nbytes + ivsize,\r\nreq->creq.info);\r\nmemcpy(req->creq.info, ctx->salt, ivsize);\r\nlen = ivsize;\r\nif (ivsize > sizeof(u64)) {\r\nmemset(req->giv, 0, ivsize - sizeof(u64));\r\nlen = sizeof(u64);\r\n}\r\nseq = cpu_to_be64(req->seq);\r\nmemcpy(req->giv + ivsize - len, &seq, len);\r\nerr = crypto_ablkcipher_encrypt(subreq);\r\nif (err)\r\ngoto out;\r\nif (giv != req->giv)\r\neseqiv_complete2(req);\r\nout:\r\nreturn err;\r\n}\r\nstatic int eseqiv_givencrypt_first(struct skcipher_givcrypt_request *req)\r\n{\r\nstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\r\nstruct eseqiv_ctx *ctx = crypto_ablkcipher_ctx(geniv);\r\nint err = 0;\r\nspin_lock_bh(&ctx->lock);\r\nif (crypto_ablkcipher_crt(geniv)->givencrypt != eseqiv_givencrypt_first)\r\ngoto unlock;\r\ncrypto_ablkcipher_crt(geniv)->givencrypt = eseqiv_givencrypt;\r\nerr = crypto_rng_get_bytes(crypto_default_rng, ctx->salt,\r\ncrypto_ablkcipher_ivsize(geniv));\r\nunlock:\r\nspin_unlock_bh(&ctx->lock);\r\nif (err)\r\nreturn err;\r\nreturn eseqiv_givencrypt(req);\r\n}\r\nstatic int eseqiv_init(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_ablkcipher *geniv = __crypto_ablkcipher_cast(tfm);\r\nstruct eseqiv_ctx *ctx = crypto_ablkcipher_ctx(geniv);\r\nunsigned long alignmask;\r\nunsigned int reqsize;\r\nspin_lock_init(&ctx->lock);\r\nalignmask = crypto_tfm_ctx_alignment() - 1;\r\nreqsize = sizeof(struct eseqiv_request_ctx);\r\nif (alignmask & reqsize) {\r\nalignmask &= reqsize;\r\nalignmask--;\r\n}\r\nalignmask = ~alignmask;\r\nalignmask &= crypto_ablkcipher_alignmask(geniv);\r\nreqsize += alignmask;\r\nreqsize += crypto_ablkcipher_ivsize(geniv);\r\nreqsize = ALIGN(reqsize, crypto_tfm_ctx_alignment());\r\nctx->reqoff = reqsize - sizeof(struct eseqiv_request_ctx);\r\ntfm->crt_ablkcipher.reqsize = reqsize +\r\nsizeof(struct ablkcipher_request);\r\nreturn skcipher_geniv_init(tfm);\r\n}\r\nstatic struct crypto_instance *eseqiv_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_instance *inst;\r\nint err;\r\nerr = crypto_get_default_rng();\r\nif (err)\r\nreturn ERR_PTR(err);\r\ninst = skcipher_geniv_alloc(&eseqiv_tmpl, tb, 0, 0);\r\nif (IS_ERR(inst))\r\ngoto put_rng;\r\nerr = -EINVAL;\r\nif (inst->alg.cra_ablkcipher.ivsize != inst->alg.cra_blocksize)\r\ngoto free_inst;\r\ninst->alg.cra_ablkcipher.givencrypt = eseqiv_givencrypt_first;\r\ninst->alg.cra_init = eseqiv_init;\r\ninst->alg.cra_exit = skcipher_geniv_exit;\r\ninst->alg.cra_ctxsize = sizeof(struct eseqiv_ctx);\r\ninst->alg.cra_ctxsize += inst->alg.cra_ablkcipher.ivsize;\r\nout:\r\nreturn inst;\r\nfree_inst:\r\nskcipher_geniv_free(inst);\r\ninst = ERR_PTR(err);\r\nput_rng:\r\ncrypto_put_default_rng();\r\ngoto out;\r\n}\r\nstatic void eseqiv_free(struct crypto_instance *inst)\r\n{\r\nskcipher_geniv_free(inst);\r\ncrypto_put_default_rng();\r\n}\r\nstatic int __init eseqiv_module_init(void)\r\n{\r\nreturn crypto_register_template(&eseqiv_tmpl);\r\n}\r\nstatic void __exit eseqiv_module_exit(void)\r\n{\r\ncrypto_unregister_template(&eseqiv_tmpl);\r\n}
