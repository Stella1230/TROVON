static bool icmpv6_pkt_to_tuple(const struct sk_buff *skb,\r\nunsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct icmp6hdr *hp;\r\nstruct icmp6hdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->dst.u.icmp.type = hp->icmp6_type;\r\ntuple->src.u.icmp.id = hp->icmp6_identifier;\r\ntuple->dst.u.icmp.code = hp->icmp6_code;\r\nreturn true;\r\n}\r\nstatic bool icmpv6_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\nint type = orig->dst.u.icmp.type - 128;\r\nif (type < 0 || type >= sizeof(invmap) || !invmap[type])\r\nreturn false;\r\ntuple->src.u.icmp.id = orig->src.u.icmp.id;\r\ntuple->dst.u.icmp.type = invmap[type] - 1;\r\ntuple->dst.u.icmp.code = orig->dst.u.icmp.code;\r\nreturn true;\r\n}\r\nstatic int icmpv6_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "type=%u code=%u id=%u ",\r\ntuple->dst.u.icmp.type,\r\ntuple->dst.u.icmp.code,\r\nntohs(tuple->src.u.icmp.id));\r\n}\r\nstatic int icmpv6_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nnf_ct_refresh_acct(ct, ctinfo, skb, nf_ct_icmpv6_timeout);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool icmpv6_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff)\r\n{\r\nstatic const u_int8_t valid_new[] = {\r\n[ICMPV6_ECHO_REQUEST - 128] = 1,\r\n[ICMPV6_NI_QUERY - 128] = 1\r\n};\r\nint type = ct->tuplehash[0].tuple.dst.u.icmp.type - 128;\r\nif (type < 0 || type >= sizeof(valid_new) || !valid_new[type]) {\r\npr_debug("icmpv6: can't create new conn with type %u\n",\r\ntype + 128);\r\nnf_ct_dump_tuple_ipv6(&ct->tuplehash[0].tuple);\r\nif (LOG_INVALID(nf_ct_net(ct), IPPROTO_ICMPV6))\r\nnf_log_packet(PF_INET6, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_icmpv6: invalid new with type %d ",\r\ntype + 128);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\nicmpv6_error_message(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb,\r\nunsigned int icmp6off,\r\nenum ip_conntrack_info *ctinfo,\r\nunsigned int hooknum)\r\n{\r\nstruct nf_conntrack_tuple intuple, origtuple;\r\nconst struct nf_conntrack_tuple_hash *h;\r\nconst struct nf_conntrack_l4proto *inproto;\r\nu16 zone = tmpl ? nf_ct_zone(tmpl) : NF_CT_DEFAULT_ZONE;\r\nNF_CT_ASSERT(skb->nfct == NULL);\r\nif (!nf_ct_get_tuplepr(skb,\r\nskb_network_offset(skb)\r\n+ sizeof(struct ipv6hdr)\r\n+ sizeof(struct icmp6hdr),\r\nPF_INET6, &origtuple)) {\r\npr_debug("icmpv6_error: Can't get tuple\n");\r\nreturn -NF_ACCEPT;\r\n}\r\ninproto = __nf_ct_l4proto_find(PF_INET6, origtuple.dst.protonum);\r\nif (!nf_ct_invert_tuple(&intuple, &origtuple,\r\n&nf_conntrack_l3proto_ipv6, inproto)) {\r\npr_debug("icmpv6_error: Can't invert tuple\n");\r\nreturn -NF_ACCEPT;\r\n}\r\n*ctinfo = IP_CT_RELATED;\r\nh = nf_conntrack_find_get(net, zone, &intuple);\r\nif (!h) {\r\npr_debug("icmpv6_error: no match\n");\r\nreturn -NF_ACCEPT;\r\n} else {\r\nif (NF_CT_DIRECTION(h) == IP_CT_DIR_REPLY)\r\n*ctinfo += IP_CT_IS_REPLY;\r\n}\r\nskb->nfct = &nf_ct_tuplehash_to_ctrack(h)->ct_general;\r\nskb->nfctinfo = *ctinfo;\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int\r\nicmpv6_error(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb, unsigned int dataoff,\r\nenum ip_conntrack_info *ctinfo, u_int8_t pf, unsigned int hooknum)\r\n{\r\nconst struct icmp6hdr *icmp6h;\r\nstruct icmp6hdr _ih;\r\nint type;\r\nicmp6h = skb_header_pointer(skb, dataoff, sizeof(_ih), &_ih);\r\nif (icmp6h == NULL) {\r\nif (LOG_INVALID(net, IPPROTO_ICMPV6))\r\nnf_log_packet(PF_INET6, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_icmpv6: short packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\r\nnf_ip6_checksum(skb, hooknum, dataoff, IPPROTO_ICMPV6)) {\r\nif (LOG_INVALID(net, IPPROTO_ICMPV6))\r\nnf_log_packet(PF_INET6, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_icmpv6: ICMPv6 checksum failed ");\r\nreturn -NF_ACCEPT;\r\n}\r\ntype = icmp6h->icmp6_type - 130;\r\nif (type >= 0 && type < sizeof(noct_valid_new) &&\r\nnoct_valid_new[type]) {\r\nskb->nfct = &nf_ct_untracked_get()->ct_general;\r\nskb->nfctinfo = IP_CT_NEW;\r\nnf_conntrack_get(skb->nfct);\r\nreturn NF_ACCEPT;\r\n}\r\nif (icmp6h->icmp6_type >= 128)\r\nreturn NF_ACCEPT;\r\nreturn icmpv6_error_message(net, tmpl, skb, dataoff, ctinfo, hooknum);\r\n}\r\nstatic int icmpv6_tuple_to_nlattr(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *t)\r\n{\r\nNLA_PUT_BE16(skb, CTA_PROTO_ICMPV6_ID, t->src.u.icmp.id);\r\nNLA_PUT_U8(skb, CTA_PROTO_ICMPV6_TYPE, t->dst.u.icmp.type);\r\nNLA_PUT_U8(skb, CTA_PROTO_ICMPV6_CODE, t->dst.u.icmp.code);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int icmpv6_nlattr_to_tuple(struct nlattr *tb[],\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nif (!tb[CTA_PROTO_ICMPV6_TYPE] ||\r\n!tb[CTA_PROTO_ICMPV6_CODE] ||\r\n!tb[CTA_PROTO_ICMPV6_ID])\r\nreturn -EINVAL;\r\ntuple->dst.u.icmp.type = nla_get_u8(tb[CTA_PROTO_ICMPV6_TYPE]);\r\ntuple->dst.u.icmp.code = nla_get_u8(tb[CTA_PROTO_ICMPV6_CODE]);\r\ntuple->src.u.icmp.id = nla_get_be16(tb[CTA_PROTO_ICMPV6_ID]);\r\nif (tuple->dst.u.icmp.type < 128 ||\r\ntuple->dst.u.icmp.type - 128 >= sizeof(invmap) ||\r\n!invmap[tuple->dst.u.icmp.type - 128])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int icmpv6_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(icmpv6_nla_policy, CTA_PROTO_MAX + 1);\r\n}
