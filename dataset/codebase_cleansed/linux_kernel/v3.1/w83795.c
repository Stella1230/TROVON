static inline u16 in_from_reg(u8 index, u16 val)\r\n{\r\nif (index >= 12 && index <= 14)\r\nreturn val * 6;\r\nelse\r\nreturn val * 2;\r\n}\r\nstatic inline u16 in_to_reg(u8 index, u16 val)\r\n{\r\nif (index >= 12 && index <= 14)\r\nreturn val / 6;\r\nelse\r\nreturn val / 2;\r\n}\r\nstatic inline unsigned long fan_from_reg(u16 val)\r\n{\r\nif ((val == 0xfff) || (val == 0))\r\nreturn 0;\r\nreturn 1350000UL / val;\r\n}\r\nstatic inline u16 fan_to_reg(long rpm)\r\n{\r\nif (rpm <= 0)\r\nreturn 0x0fff;\r\nreturn SENSORS_LIMIT((1350000 + (rpm >> 1)) / rpm, 1, 0xffe);\r\n}\r\nstatic inline unsigned long time_from_reg(u8 reg)\r\n{\r\nreturn reg * 100;\r\n}\r\nstatic inline u8 time_to_reg(unsigned long val)\r\n{\r\nreturn SENSORS_LIMIT((val + 50) / 100, 0, 0xff);\r\n}\r\nstatic inline long temp_from_reg(s8 reg)\r\n{\r\nreturn reg * 1000;\r\n}\r\nstatic inline s8 temp_to_reg(long val, s8 min, s8 max)\r\n{\r\nreturn SENSORS_LIMIT(val / 1000, min, max);\r\n}\r\nstatic unsigned int pwm_freq_from_reg(u8 reg, u16 clkin)\r\n{\r\nunsigned long base_clock;\r\nif (reg & 0x80) {\r\nbase_clock = clkin * 1000 / ((clkin == 48000) ? 384 : 256);\r\nreturn base_clock / ((reg & 0x7f) + 1);\r\n} else\r\nreturn pwm_freq_cksel0[reg & 0x0f];\r\n}\r\nstatic u8 pwm_freq_to_reg(unsigned long val, u16 clkin)\r\n{\r\nunsigned long base_clock;\r\nu8 reg0, reg1;\r\nunsigned long best0, best1;\r\nfor (reg0 = 0; reg0 < ARRAY_SIZE(pwm_freq_cksel0) - 1; reg0++) {\r\nif (val > (pwm_freq_cksel0[reg0] +\r\npwm_freq_cksel0[reg0 + 1]) / 2)\r\nbreak;\r\n}\r\nif (val < 375)\r\nreturn reg0;\r\nbest0 = pwm_freq_cksel0[reg0];\r\nbase_clock = clkin * 1000 / ((clkin == 48000) ? 384 : 256);\r\nreg1 = SENSORS_LIMIT(DIV_ROUND_CLOSEST(base_clock, val), 1, 128);\r\nbest1 = base_clock / reg1;\r\nreg1 = 0x80 | (reg1 - 1);\r\nif (abs(val - best0) > abs(val - best1))\r\nreturn reg1;\r\nelse\r\nreturn reg0;\r\n}\r\nstatic int w83795_set_bank(struct i2c_client *client, u8 bank)\r\n{\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nint err;\r\nif ((data->bank & 0x07) == bank)\r\nreturn 0;\r\nbank |= data->bank & ~0x07;\r\nerr = i2c_smbus_write_byte_data(client, W83795_REG_BANKSEL, bank);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"Failed to set bank to %d, err %d\n",\r\n(int)bank, err);\r\nreturn err;\r\n}\r\ndata->bank = bank;\r\nreturn 0;\r\n}\r\nstatic u8 w83795_read(struct i2c_client *client, u16 reg)\r\n{\r\nint err;\r\nerr = w83795_set_bank(client, reg >> 8);\r\nif (err < 0)\r\nreturn 0x00;\r\nerr = i2c_smbus_read_byte_data(client, reg & 0xff);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"Failed to read from register 0x%03x, err %d\n",\r\n(int)reg, err);\r\nreturn 0x00;\r\n}\r\nreturn err;\r\n}\r\nstatic int w83795_write(struct i2c_client *client, u16 reg, u8 value)\r\n{\r\nint err;\r\nerr = w83795_set_bank(client, reg >> 8);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(client, reg & 0xff, value);\r\nif (err < 0)\r\ndev_err(&client->dev,\r\n"Failed to write to register 0x%03x, err %d\n",\r\n(int)reg, err);\r\nreturn err;\r\n}\r\nstatic void w83795_update_limits(struct i2c_client *client)\r\n{\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nint i, limit;\r\nu8 lsb;\r\nfor (i = 0; i < ARRAY_SIZE(data->in); i++) {\r\nif (!(data->has_in & (1 << i)))\r\ncontinue;\r\ndata->in[i][IN_MAX] =\r\nw83795_read(client, W83795_REG_IN[i][IN_MAX]);\r\ndata->in[i][IN_LOW] =\r\nw83795_read(client, W83795_REG_IN[i][IN_LOW]);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->in_lsb); i++) {\r\nif ((i == 2 && data->chip_type == w83795adg) ||\r\n(i >= 4 && !(data->has_in & (1 << (i + 11)))))\r\ncontinue;\r\ndata->in_lsb[i][IN_MAX] =\r\nw83795_read(client, IN_LSB_REG(i, IN_MAX));\r\ndata->in_lsb[i][IN_LOW] =\r\nw83795_read(client, IN_LSB_REG(i, IN_LOW));\r\n}\r\nlsb = 0;\r\nfor (i = 0; i < ARRAY_SIZE(data->fan); i++) {\r\nif ((i & 1) == 0 && (data->has_fan & (3 << i)))\r\nlsb = w83795_read(client, W83795_REG_FAN_MIN_LSB(i));\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\ndata->fan_min[i] =\r\nw83795_read(client, W83795_REG_FAN_MIN_HL(i)) << 4;\r\ndata->fan_min[i] |=\r\n(lsb >> W83795_REG_FAN_MIN_LSB_SHIFT(i)) & 0x0F;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->temp); i++) {\r\nif (!(data->has_temp & (1 << i)))\r\ncontinue;\r\nfor (limit = TEMP_CRIT; limit <= TEMP_WARN_HYST; limit++)\r\ndata->temp[i][limit] =\r\nw83795_read(client, W83795_REG_TEMP[i][limit]);\r\n}\r\nif (data->enable_dts) {\r\nfor (limit = DTS_CRIT; limit <= DTS_WARN_HYST; limit++)\r\ndata->dts_ext[limit] =\r\nw83795_read(client, W83795_REG_DTS_EXT(limit));\r\n}\r\nif (data->enable_beep) {\r\nfor (i = 0; i < ARRAY_SIZE(data->beeps); i++)\r\ndata->beeps[i] =\r\nw83795_read(client, W83795_REG_BEEP(i));\r\n}\r\ndata->valid_limits = 1;\r\n}\r\nstatic struct w83795_data *w83795_update_pwm_config(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nint i, tmp;\r\nmutex_lock(&data->update_lock);\r\nif (data->valid_pwm_config)\r\ngoto END;\r\nfor (i = 0; i < ARRAY_SIZE(data->temp_src); i++)\r\ndata->temp_src[i] = w83795_read(client, W83795_REG_TSS(i));\r\ndata->pwm_fcms[0] = w83795_read(client, W83795_REG_FCMS1);\r\ndata->pwm_fcms[1] = w83795_read(client, W83795_REG_FCMS2);\r\nfor (i = 0; i < ARRAY_SIZE(data->pwm_tfmr); i++)\r\ndata->pwm_tfmr[i] = w83795_read(client, W83795_REG_TFMR(i));\r\ndata->pwm_fomc = w83795_read(client, W83795_REG_FOMC);\r\nfor (i = 0; i < data->has_pwm; i++) {\r\nfor (tmp = PWM_FREQ; tmp <= PWM_STOP_TIME; tmp++)\r\ndata->pwm[i][tmp] =\r\nw83795_read(client, W83795_REG_PWM(i, tmp));\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->target_speed); i++) {\r\ndata->target_speed[i] =\r\nw83795_read(client, W83795_REG_FTSH(i)) << 4;\r\ndata->target_speed[i] |=\r\nw83795_read(client, W83795_REG_FTSL(i)) >> 4;\r\n}\r\ndata->tol_speed = w83795_read(client, W83795_REG_TFTS) & 0x3f;\r\nfor (i = 0; i < ARRAY_SIZE(data->pwm_temp); i++) {\r\ndata->pwm_temp[i][TEMP_PWM_TTTI] =\r\nw83795_read(client, W83795_REG_TTTI(i)) & 0x7f;\r\ndata->pwm_temp[i][TEMP_PWM_CTFS] =\r\nw83795_read(client, W83795_REG_CTFS(i));\r\ntmp = w83795_read(client, W83795_REG_HT(i));\r\ndata->pwm_temp[i][TEMP_PWM_HCT] = tmp >> 4;\r\ndata->pwm_temp[i][TEMP_PWM_HOT] = tmp & 0x0f;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->sf4_reg); i++) {\r\nfor (tmp = 0; tmp < 7; tmp++) {\r\ndata->sf4_reg[i][SF4_TEMP][tmp] =\r\nw83795_read(client,\r\nW83795_REG_SF4_TEMP(i, tmp));\r\ndata->sf4_reg[i][SF4_PWM][tmp] =\r\nw83795_read(client, W83795_REG_SF4_PWM(i, tmp));\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->setup_pwm); i++)\r\ndata->setup_pwm[i] =\r\nw83795_read(client, W83795_REG_SETUP_PWM(i));\r\ndata->valid_pwm_config = 1;\r\nEND:\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic struct w83795_data *w83795_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nu16 tmp;\r\nu8 intrusion;\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (!data->valid_limits)\r\nw83795_update_limits(client);\r\nif (!(time_after(jiffies, data->last_updated + HZ * 2)\r\n|| !data->valid))\r\ngoto END;\r\nfor (i = 0; i < ARRAY_SIZE(data->in); i++) {\r\nif (!(data->has_in & (1 << i)))\r\ncontinue;\r\ntmp = w83795_read(client, W83795_REG_IN[i][IN_READ]) << 2;\r\ntmp |= w83795_read(client, W83795_REG_VRLSB) >> 6;\r\ndata->in[i][IN_READ] = tmp;\r\n}\r\nif (data->has_dyn_in) {\r\nu8 lsb_max = w83795_read(client, IN_LSB_REG(0, IN_MAX));\r\nu8 lsb_low = w83795_read(client, IN_LSB_REG(0, IN_LOW));\r\nfor (i = 0; i < 3; i++) {\r\nif (!(data->has_dyn_in & (1 << i)))\r\ncontinue;\r\ndata->in[i][IN_MAX] =\r\nw83795_read(client, W83795_REG_IN[i][IN_MAX]);\r\ndata->in[i][IN_LOW] =\r\nw83795_read(client, W83795_REG_IN[i][IN_LOW]);\r\ndata->in_lsb[i][IN_MAX] = (lsb_max >> (2 * i)) & 0x03;\r\ndata->in_lsb[i][IN_LOW] = (lsb_low >> (2 * i)) & 0x03;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->fan); i++) {\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\ndata->fan[i] = w83795_read(client, W83795_REG_FAN(i)) << 4;\r\ndata->fan[i] |= w83795_read(client, W83795_REG_VRLSB) >> 4;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->temp); i++) {\r\ndata->temp[i][TEMP_READ] =\r\nw83795_read(client, W83795_REG_TEMP[i][TEMP_READ]);\r\ndata->temp_read_vrlsb[i] =\r\nw83795_read(client, W83795_REG_VRLSB);\r\n}\r\nif (data->enable_dts) {\r\nfor (i = 0; i < ARRAY_SIZE(data->dts); i++) {\r\nif (!(data->has_dts & (1 << i)))\r\ncontinue;\r\ndata->dts[i] =\r\nw83795_read(client, W83795_REG_DTS(i));\r\ndata->dts_read_vrlsb[i] =\r\nw83795_read(client, W83795_REG_VRLSB);\r\n}\r\n}\r\nfor (i = 0; i < data->has_pwm; i++) {\r\ndata->pwm[i][PWM_OUTPUT] =\r\nw83795_read(client, W83795_REG_PWM(i, PWM_OUTPUT));\r\n}\r\ntmp = w83795_read(client, W83795_REG_ALARM_CTRL);\r\nif (tmp & ALARM_CTRL_RTSACS)\r\nw83795_write(client, W83795_REG_ALARM_CTRL,\r\ntmp & ~ALARM_CTRL_RTSACS);\r\nintrusion = w83795_read(client, W83795_REG_ALARM(5)) & (1 << 6);\r\nw83795_write(client, W83795_REG_ALARM_CTRL, tmp | ALARM_CTRL_RTSACS);\r\nfor (i = 0; i < ARRAY_SIZE(data->alarms); i++)\r\ndata->alarms[i] = w83795_read(client, W83795_REG_ALARM(i));\r\ndata->alarms[5] |= intrusion;\r\nif (!(tmp & ALARM_CTRL_RTSACS))\r\nw83795_write(client, W83795_REG_ALARM_CTRL,\r\ntmp & ~ALARM_CTRL_RTSACS);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\nEND:\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t\r\nshow_alarm_beep(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data = w83795_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index >> 3;\r\nint bit = sensor_attr->index & 0x07;\r\nu8 val;\r\nif (nr == ALARM_STATUS)\r\nval = (data->alarms[index] >> bit) & 1;\r\nelse\r\nval = (data->beeps[index] >> bit) & 1;\r\nreturn sprintf(buf, "%u\n", val);\r\n}\r\nstatic ssize_t\r\nstore_beep(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index >> 3;\r\nint shift = sensor_attr->index & 0x07;\r\nu8 beep_bit = 1 << shift;\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->beeps[index] = w83795_read(client, W83795_REG_BEEP(index));\r\ndata->beeps[index] &= ~beep_bit;\r\ndata->beeps[index] |= val << shift;\r\nw83795_write(client, W83795_REG_BEEP(index), data->beeps[index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_chassis_clear(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val) < 0 || val != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nval = w83795_read(client, W83795_REG_CLR_CHASSIS);\r\nval |= 0x80;\r\nw83795_write(client, W83795_REG_CLR_CHASSIS, val);\r\nw83795_read(client, W83795_REG_ALARM(5));\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83795_data *data = w83795_update_device(dev);\r\nu16 val;\r\nif (nr == FAN_INPUT)\r\nval = data->fan[index] & 0x0fff;\r\nelse\r\nval = data->fan_min[index] & 0x0fff;\r\nreturn sprintf(buf, "%lu\n", fan_from_reg(val));\r\n}\r\nstatic ssize_t\r\nstore_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nval = fan_to_reg(val);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[index] = val;\r\nw83795_write(client, W83795_REG_FAN_MIN_HL(index), (val >> 4) & 0xff);\r\nval &= 0x0f;\r\nif (index & 1) {\r\nval <<= 4;\r\nval |= w83795_read(client, W83795_REG_FAN_MIN_LSB(index))\r\n& 0x0f;\r\n} else {\r\nval |= w83795_read(client, W83795_REG_FAN_MIN_LSB(index))\r\n& 0xf0;\r\n}\r\nw83795_write(client, W83795_REG_FAN_MIN_LSB(index), val & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data;\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned int val;\r\ndata = nr == PWM_OUTPUT ? w83795_update_device(dev)\r\n: w83795_update_pwm_config(dev);\r\nswitch (nr) {\r\ncase PWM_STOP_TIME:\r\nval = time_from_reg(data->pwm[index][nr]);\r\nbreak;\r\ncase PWM_FREQ:\r\nval = pwm_freq_from_reg(data->pwm[index][nr], data->clkin);\r\nbreak;\r\ndefault:\r\nval = data->pwm[index][nr];\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%u\n", val);\r\n}\r\nstatic ssize_t\r\nstore_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nswitch (nr) {\r\ncase PWM_STOP_TIME:\r\nval = time_to_reg(val);\r\nbreak;\r\ncase PWM_FREQ:\r\nval = pwm_freq_to_reg(val, data->clkin);\r\nbreak;\r\ndefault:\r\nval = SENSORS_LIMIT(val, 0, 0xff);\r\nbreak;\r\n}\r\nw83795_write(client, W83795_REG_PWM(index, nr), val);\r\ndata->pwm[index][nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm_enable(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nint index = sensor_attr->index;\r\nu8 tmp;\r\nif (data->pwm_fcms[0] & (1 << index)) {\r\ntmp = 2;\r\ngoto out;\r\n}\r\nfor (tmp = 0; tmp < 6; tmp++) {\r\nif (data->pwm_tfmr[tmp] & (1 << index)) {\r\ntmp = 3;\r\ngoto out;\r\n}\r\n}\r\ntmp = 1;\r\nout:\r\nreturn sprintf(buf, "%u\n", tmp);\r\n}\r\nstatic ssize_t\r\nstore_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nunsigned long val;\r\nint i;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (val < 1 || val > 2)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 1:\r\ndata->pwm_fcms[0] &= ~(1 << index);\r\nw83795_write(client, W83795_REG_FCMS1, data->pwm_fcms[0]);\r\nfor (i = 0; i < 6; i++) {\r\ndata->pwm_tfmr[i] &= ~(1 << index);\r\nw83795_write(client, W83795_REG_TFMR(i),\r\ndata->pwm_tfmr[i]);\r\n}\r\nbreak;\r\ncase 2:\r\ndata->pwm_fcms[0] |= (1 << index);\r\nw83795_write(client, W83795_REG_FCMS1, data->pwm_fcms[0]);\r\nbreak;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm_mode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nint index = to_sensor_dev_attr_2(attr)->index;\r\nunsigned int mode;\r\nif (data->pwm_fomc & (1 << index))\r\nmode = 0;\r\nelse\r\nmode = 1;\r\nreturn sprintf(buf, "%u\n", mode);\r\n}\r\nstatic int w83795_tss_useful(const struct w83795_data *data, int tsrc)\r\n{\r\nint useful = 0, i;\r\nfor (i = 0; i < 4; i++) {\r\nif (tss_map[i][tsrc] == TSS_MAP_RESERVED)\r\ncontinue;\r\nif (tss_map[i][tsrc] < 6)\r\nuseful += (data->has_temp >> tss_map[i][tsrc]) & 1;\r\nelse\r\nuseful += (data->has_dts >> (tss_map[i][tsrc] - 6)) & 1;\r\n}\r\nreturn useful;\r\n}\r\nstatic ssize_t\r\nshow_temp_src(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nint index = sensor_attr->index;\r\nu8 tmp = data->temp_src[index / 2];\r\nif (index & 1)\r\ntmp >>= 4;\r\nelse\r\ntmp &= 0x0f;\r\nif (tmp >= 4 || tss_map[tmp][index] == TSS_MAP_RESERVED)\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%u\n", (unsigned int)tss_map[tmp][index] + 1);\r\n}\r\nstatic ssize_t\r\nstore_temp_src(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nint tmp;\r\nunsigned long channel;\r\nu8 val = index / 2;\r\nif (strict_strtoul(buf, 10, &channel) < 0 ||\r\nchannel < 1 || channel > 14)\r\nreturn -EINVAL;\r\nfor (tmp = 0; tmp < 4; tmp++) {\r\nif (tss_map[tmp][index] == channel - 1)\r\nbreak;\r\n}\r\nif (tmp == 4)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (index & 1) {\r\ntmp <<= 4;\r\ndata->temp_src[val] &= 0x0f;\r\n} else {\r\ndata->temp_src[val] &= 0xf0;\r\n}\r\ndata->temp_src[val] |= tmp;\r\nw83795_write(client, W83795_REG_TSS(val), data->temp_src[val]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nu8 tmp = 0xff;\r\nswitch (nr) {\r\ncase TEMP_PWM_ENABLE:\r\ntmp = (data->pwm_fcms[1] >> index) & 1;\r\nif (tmp)\r\ntmp = 4;\r\nelse\r\ntmp = 3;\r\nbreak;\r\ncase TEMP_PWM_FAN_MAP:\r\ntmp = data->pwm_tfmr[index];\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%u\n", tmp);\r\n}\r\nstatic ssize_t\r\nstore_temp_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned long tmp;\r\nif (strict_strtoul(buf, 10, &tmp) < 0)\r\nreturn -EINVAL;\r\nswitch (nr) {\r\ncase TEMP_PWM_ENABLE:\r\nif (tmp != 3 && tmp != 4)\r\nreturn -EINVAL;\r\ntmp -= 3;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_fcms[1] &= ~(1 << index);\r\ndata->pwm_fcms[1] |= tmp << index;\r\nw83795_write(client, W83795_REG_FCMS2, data->pwm_fcms[1]);\r\nmutex_unlock(&data->update_lock);\r\nbreak;\r\ncase TEMP_PWM_FAN_MAP:\r\nmutex_lock(&data->update_lock);\r\ntmp = SENSORS_LIMIT(tmp, 0, 0xff);\r\nw83795_write(client, W83795_REG_TFMR(index), tmp);\r\ndata->pwm_tfmr[index] = tmp;\r\nmutex_unlock(&data->update_lock);\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fanin(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nu16 tmp = 0;\r\nswitch (nr) {\r\ncase FANIN_TARGET:\r\ntmp = fan_from_reg(data->target_speed[index]);\r\nbreak;\r\ncase FANIN_TOL:\r\ntmp = data->tol_speed;\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%u\n", tmp);\r\n}\r\nstatic ssize_t\r\nstore_fanin(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nswitch (nr) {\r\ncase FANIN_TARGET:\r\nval = fan_to_reg(SENSORS_LIMIT(val, 0, 0xfff));\r\nw83795_write(client, W83795_REG_FTSH(index), val >> 4);\r\nw83795_write(client, W83795_REG_FTSL(index), (val << 4) & 0xf0);\r\ndata->target_speed[index] = val;\r\nbreak;\r\ncase FANIN_TOL:\r\nval = SENSORS_LIMIT(val, 0, 0x3f);\r\nw83795_write(client, W83795_REG_TFTS, val);\r\ndata->tol_speed = val;\r\nbreak;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_pwm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nlong tmp = temp_from_reg(data->pwm_temp[index][nr]);\r\nreturn sprintf(buf, "%ld\n", tmp);\r\n}\r\nstatic ssize_t\r\nstore_temp_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned long val;\r\nu8 tmp;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nval /= 1000;\r\nmutex_lock(&data->update_lock);\r\nswitch (nr) {\r\ncase TEMP_PWM_TTTI:\r\nval = SENSORS_LIMIT(val, 0, 0x7f);\r\nw83795_write(client, W83795_REG_TTTI(index), val);\r\nbreak;\r\ncase TEMP_PWM_CTFS:\r\nval = SENSORS_LIMIT(val, 0, 0x7f);\r\nw83795_write(client, W83795_REG_CTFS(index), val);\r\nbreak;\r\ncase TEMP_PWM_HCT:\r\nval = SENSORS_LIMIT(val, 0, 0x0f);\r\ntmp = w83795_read(client, W83795_REG_HT(index));\r\ntmp &= 0x0f;\r\ntmp |= (val << 4) & 0xf0;\r\nw83795_write(client, W83795_REG_HT(index), tmp);\r\nbreak;\r\ncase TEMP_PWM_HOT:\r\nval = SENSORS_LIMIT(val, 0, 0x0f);\r\ntmp = w83795_read(client, W83795_REG_HT(index));\r\ntmp &= 0xf0;\r\ntmp |= val & 0x0f;\r\nw83795_write(client, W83795_REG_HT(index), tmp);\r\nbreak;\r\n}\r\ndata->pwm_temp[index][nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf4_pwm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nreturn sprintf(buf, "%u\n", data->sf4_reg[index][SF4_PWM][nr]);\r\n}\r\nstatic ssize_t\r\nstore_sf4_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nw83795_write(client, W83795_REG_SF4_PWM(index, nr), val);\r\ndata->sf4_reg[index][SF4_PWM][nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf4_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nreturn sprintf(buf, "%u\n",\r\n(data->sf4_reg[index][SF4_TEMP][nr]) * 1000);\r\n}\r\nstatic ssize_t\r\nstore_sf4_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nval /= 1000;\r\nmutex_lock(&data->update_lock);\r\nw83795_write(client, W83795_REG_SF4_TEMP(index, nr), val);\r\ndata->sf4_reg[index][SF4_TEMP][nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83795_data *data = w83795_update_device(dev);\r\nlong temp = temp_from_reg(data->temp[index][nr]);\r\nif (nr == TEMP_READ)\r\ntemp += (data->temp_read_vrlsb[index] >> 6) * 250;\r\nreturn sprintf(buf, "%ld\n", temp);\r\n}\r\nstatic ssize_t\r\nstore_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nlong tmp;\r\nif (strict_strtol(buf, 10, &tmp) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->temp[index][nr] = temp_to_reg(tmp, -128, 127);\r\nw83795_write(client, W83795_REG_TEMP[index][nr], data->temp[index][nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_dts_mode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data = dev_get_drvdata(dev);\r\nint tmp;\r\nif (data->enable_dts & 2)\r\ntmp = 5;\r\nelse\r\ntmp = 6;\r\nreturn sprintf(buf, "%d\n", tmp);\r\n}\r\nstatic ssize_t\r\nshow_dts(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nstruct w83795_data *data = w83795_update_device(dev);\r\nlong temp = temp_from_reg(data->dts[index]);\r\ntemp += (data->dts_read_vrlsb[index] >> 6) * 250;\r\nreturn sprintf(buf, "%ld\n", temp);\r\n}\r\nstatic ssize_t\r\nshow_dts_ext(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nstruct w83795_data *data = dev_get_drvdata(dev);\r\nlong temp = temp_from_reg(data->dts_ext[nr]);\r\nreturn sprintf(buf, "%ld\n", temp);\r\n}\r\nstatic ssize_t\r\nstore_dts_ext(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nlong tmp;\r\nif (strict_strtol(buf, 10, &tmp) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->dts_ext[nr] = temp_to_reg(tmp, -128, 127);\r\nw83795_write(client, W83795_REG_DTS_EXT(nr), data->dts_ext[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_mode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83795_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nint tmp;\r\nif (data->temp_mode & (1 << index))\r\ntmp = 3;\r\nelse\r\ntmp = 4;\r\nreturn sprintf(buf, "%d\n", tmp);\r\n}\r\nstatic ssize_t\r\nstore_temp_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nint reg_shift;\r\nunsigned long val;\r\nu8 tmp;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif ((val != 4) && (val != 3))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (val == 3) {\r\nval = 0x01;\r\ndata->temp_mode |= 1 << index;\r\n} else if (val == 4) {\r\nval = 0x03;\r\ndata->temp_mode &= ~(1 << index);\r\n}\r\nreg_shift = 2 * index;\r\ntmp = w83795_read(client, W83795_REG_TEMP_CTRL2);\r\ntmp &= ~(0x03 << reg_shift);\r\ntmp |= val << reg_shift;\r\nw83795_write(client, W83795_REG_TEMP_CTRL2, tmp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_in(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83795_data *data = w83795_update_device(dev);\r\nu16 val = data->in[index][nr];\r\nu8 lsb_idx;\r\nswitch (nr) {\r\ncase IN_READ:\r\nif ((index >= 17) &&\r\n!((data->has_gain >> (index - 17)) & 1))\r\nval *= 8;\r\nbreak;\r\ncase IN_MAX:\r\ncase IN_LOW:\r\nlsb_idx = IN_LSB_SHIFT_IDX[index][IN_LSB_IDX];\r\nval <<= 2;\r\nval |= (data->in_lsb[lsb_idx][nr] >>\r\nIN_LSB_SHIFT_IDX[index][IN_LSB_SHIFT]) & 0x03;\r\nif ((index >= 17) &&\r\n!((data->has_gain >> (index - 17)) & 1))\r\nval *= 8;\r\nbreak;\r\n}\r\nval = in_from_reg(index, val);\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t\r\nstore_in(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nu8 tmp;\r\nu8 lsb_idx;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nval = in_to_reg(index, val);\r\nif ((index >= 17) &&\r\n!((data->has_gain >> (index - 17)) & 1))\r\nval /= 8;\r\nval = SENSORS_LIMIT(val, 0, 0x3FF);\r\nmutex_lock(&data->update_lock);\r\nlsb_idx = IN_LSB_SHIFT_IDX[index][IN_LSB_IDX];\r\ntmp = w83795_read(client, IN_LSB_REG(lsb_idx, nr));\r\ntmp &= ~(0x03 << IN_LSB_SHIFT_IDX[index][IN_LSB_SHIFT]);\r\ntmp |= (val & 0x03) << IN_LSB_SHIFT_IDX[index][IN_LSB_SHIFT];\r\nw83795_write(client, IN_LSB_REG(lsb_idx, nr), tmp);\r\ndata->in_lsb[lsb_idx][nr] = tmp;\r\ntmp = (val >> 2) & 0xff;\r\nw83795_write(client, W83795_REG_IN[index][nr], tmp);\r\ndata->in[index][nr] = tmp;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf_setup(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nstruct w83795_data *data = w83795_update_pwm_config(dev);\r\nu16 val = data->setup_pwm[nr];\r\nswitch (nr) {\r\ncase SETUP_PWM_UPTIME:\r\ncase SETUP_PWM_DOWNTIME:\r\nval = time_from_reg(val);\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t\r\nstore_sf_setup(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nswitch (nr) {\r\ncase SETUP_PWM_DEFAULT:\r\nval = SENSORS_LIMIT(val, 0, 0xff);\r\nbreak;\r\ncase SETUP_PWM_UPTIME:\r\ncase SETUP_PWM_DOWNTIME:\r\nval = time_to_reg(val);\r\nif (val == 0)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nmutex_lock(&data->update_lock);\r\ndata->setup_pwm[nr] = val;\r\nw83795_write(client, W83795_REG_SETUP_PWM(nr), val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic void w83795_init_client(struct i2c_client *client)\r\n{\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nstatic const u16 clkin[4] = {\r\n14318, 24000, 33333, 48000\r\n};\r\nu8 config;\r\nif (reset)\r\nw83795_write(client, W83795_REG_CONFIG, 0x80);\r\nconfig = w83795_read(client, W83795_REG_CONFIG);\r\nif (!(config & W83795_REG_CONFIG_START)) {\r\ndev_info(&client->dev, "Enabling monitoring operations\n");\r\nw83795_write(client, W83795_REG_CONFIG,\r\nconfig | W83795_REG_CONFIG_START);\r\n}\r\ndata->clkin = clkin[(config >> 3) & 0x3];\r\ndev_dbg(&client->dev, "clkin = %u kHz\n", data->clkin);\r\n}\r\nstatic int w83795_get_device_id(struct i2c_client *client)\r\n{\r\nint device_id;\r\ndevice_id = i2c_smbus_read_byte_data(client, W83795_REG_DEVICEID);\r\nif (device_id < 0 || (device_id & 0xf0) != 0x50) {\r\nint alt_id;\r\nalt_id = i2c_smbus_read_byte_data(client,\r\nW83795_REG_DEVICEID_A);\r\nif (alt_id == 0x50)\r\ndevice_id = alt_id;\r\n}\r\nreturn device_id;\r\n}\r\nstatic int w83795_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nint bank, vendor_id, device_id, expected, i2c_addr, config;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nunsigned short address = client->addr;\r\nconst char *chip_name;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nbank = i2c_smbus_read_byte_data(client, W83795_REG_BANKSEL);\r\nif (bank < 0 || (bank & 0x7c)) {\r\ndev_dbg(&adapter->dev,\r\n"w83795: Detection failed at addr 0x%02hx, check %s\n",\r\naddress, "bank");\r\nreturn -ENODEV;\r\n}\r\nvendor_id = i2c_smbus_read_byte_data(client, W83795_REG_VENDORID);\r\nexpected = bank & 0x80 ? 0x5c : 0xa3;\r\nif (vendor_id != expected) {\r\ndev_dbg(&adapter->dev,\r\n"w83795: Detection failed at addr 0x%02hx, check %s\n",\r\naddress, "vendor id");\r\nreturn -ENODEV;\r\n}\r\ndevice_id = w83795_get_device_id(client) |\r\n(i2c_smbus_read_byte_data(client, W83795_REG_CHIPID) << 8);\r\nif ((device_id >> 4) != 0x795) {\r\ndev_dbg(&adapter->dev,\r\n"w83795: Detection failed at addr 0x%02hx, check %s\n",\r\naddress, "device id\n");\r\nreturn -ENODEV;\r\n}\r\nif ((bank & 0x07) == 0) {\r\ni2c_addr = i2c_smbus_read_byte_data(client,\r\nW83795_REG_I2C_ADDR);\r\nif ((i2c_addr & 0x7f) != address) {\r\ndev_dbg(&adapter->dev,\r\n"w83795: Detection failed at addr 0x%02hx, "\r\n"check %s\n", address, "i2c addr");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ((bank & 0x07) != 0)\r\ni2c_smbus_write_byte_data(client, W83795_REG_BANKSEL,\r\nbank & ~0x07);\r\nconfig = i2c_smbus_read_byte_data(client, W83795_REG_CONFIG);\r\nif (config & W83795_REG_CONFIG_CONFIG48)\r\nchip_name = "w83795adg";\r\nelse\r\nchip_name = "w83795g";\r\nstrlcpy(info->type, chip_name, I2C_NAME_SIZE);\r\ndev_info(&adapter->dev, "Found %s rev. %c at 0x%02hx\n", chip_name,\r\n'A' + (device_id & 0xf), address);\r\nreturn 0;\r\n}\r\nstatic int device_remove_file_wrapper(struct device *dev,\r\nconst struct device_attribute *attr)\r\n{\r\ndevice_remove_file(dev, attr);\r\nreturn 0;\r\n}\r\nstatic void w83795_check_dynamic_in_limits(struct i2c_client *client)\r\n{\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nu8 vid_ctl;\r\nint i, err_max, err_min;\r\nvid_ctl = w83795_read(client, W83795_REG_VID_CTRL);\r\nif ((vid_ctl & 0x07) == 0x00 || (vid_ctl & 0x07) == 0x07)\r\nreturn;\r\ndata->has_dyn_in = (vid_ctl >> 3) & 0x07;\r\nfor (i = 0; i < 2; i++) {\r\nif (!(data->has_dyn_in & (1 << i)))\r\ncontinue;\r\nerr_max = sysfs_chmod_file(&client->dev.kobj,\r\n&w83795_in[i][2].dev_attr.attr,\r\nS_IRUGO);\r\nerr_min = sysfs_chmod_file(&client->dev.kobj,\r\n&w83795_in[i][3].dev_attr.attr,\r\nS_IRUGO);\r\nif (err_max || err_min)\r\ndev_warn(&client->dev, "Failed to set in%d limits "\r\n"read-only (%d, %d)\n", i, err_max, err_min);\r\nelse\r\ndev_info(&client->dev, "in%d limits set dynamically "\r\n"from VID\n", i);\r\n}\r\n}\r\nstatic void w83795_apply_temp_config(struct w83795_data *data, u8 config,\r\nint temp_chan, int in_chan)\r\n{\r\nswitch (config) {\r\ncase 0x2:\r\ndata->has_in |= 1 << in_chan;\r\nbreak;\r\ncase 0x1:\r\nif (temp_chan >= 4)\r\nbreak;\r\ndata->temp_mode |= 1 << temp_chan;\r\ncase 0x3:\r\ndata->has_temp |= 1 << temp_chan;\r\nbreak;\r\n}\r\n}\r\nstatic int w83795_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint i;\r\nu8 tmp;\r\nstruct device *dev = &client->dev;\r\nstruct w83795_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(struct w83795_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ni2c_set_clientdata(client, data);\r\ndata->chip_type = id->driver_data;\r\ndata->bank = i2c_smbus_read_byte_data(client, W83795_REG_BANKSEL);\r\nmutex_init(&data->update_lock);\r\nw83795_init_client(client);\r\ndata->has_in = w83795_read(client, W83795_REG_VOLT_CTRL1)\r\n| (w83795_read(client, W83795_REG_VOLT_CTRL2) << 8);\r\ndata->has_fan = w83795_read(client, W83795_REG_FANIN_CTRL1)\r\n| (w83795_read(client, W83795_REG_FANIN_CTRL2) << 8);\r\ntmp = w83795_read(client, W83795_REG_TEMP_CTRL1);\r\nif (tmp & 0x20)\r\ndata->enable_dts = 1;\r\nw83795_apply_temp_config(data, (tmp >> 2) & 0x3, 5, 16);\r\nw83795_apply_temp_config(data, tmp & 0x3, 4, 15);\r\ntmp = w83795_read(client, W83795_REG_TEMP_CTRL2);\r\nw83795_apply_temp_config(data, tmp >> 6, 3, 20);\r\nw83795_apply_temp_config(data, (tmp >> 4) & 0x3, 2, 19);\r\nw83795_apply_temp_config(data, (tmp >> 2) & 0x3, 1, 18);\r\nw83795_apply_temp_config(data, tmp & 0x3, 0, 17);\r\nif (data->enable_dts) {\r\nif (1 & w83795_read(client, W83795_REG_DTSC))\r\ndata->enable_dts |= 2;\r\ndata->has_dts = w83795_read(client, W83795_REG_DTSE);\r\n}\r\nif (data->enable_dts == 1) {\r\nfor (i = 0; i < 8; i++) {\r\nif (!(data->has_dts & (1 << i)))\r\ncontinue;\r\ntmp = w83795_read(client, W83795_REG_PECI_TBASE(i));\r\ndev_info(&client->dev,\r\n"PECI agent %d Tbase temperature: %u\n",\r\ni + 1, (unsigned int)tmp & 0x7f);\r\n}\r\n}\r\ndata->has_gain = w83795_read(client, W83795_REG_VMIGB_CTRL) & 0x0f;\r\nif (data->chip_type == w83795g)\r\ndata->has_pwm = 8;\r\nelse\r\ndata->has_pwm = 2;\r\nif (data->chip_type == w83795g) {\r\ndata->enable_beep = 1;\r\n} else {\r\ntmp = w83795_read(client, W83795_REG_OVT_CFG);\r\nif ((tmp & OVT_CFG_SEL) == 0)\r\ndata->enable_beep = 1;\r\n}\r\nerr = w83795_handle_files(dev, device_create_file);\r\nif (err)\r\ngoto exit_remove;\r\nif (data->chip_type == w83795g)\r\nw83795_check_dynamic_in_limits(client);\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nw83795_handle_files(dev, device_remove_file_wrapper);\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int w83795_remove(struct i2c_client *client)\r\n{\r\nstruct w83795_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nw83795_handle_files(&client->dev, device_remove_file_wrapper);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init sensors_w83795_init(void)\r\n{\r\nreturn i2c_add_driver(&w83795_driver);\r\n}\r\nstatic void __exit sensors_w83795_exit(void)\r\n{\r\ni2c_del_driver(&w83795_driver);\r\n}
