static struct rpc_auth *\r\nunx_create(struct rpc_clnt *clnt, rpc_authflavor_t flavor)\r\n{\r\ndprintk("RPC: creating UNIX authenticator for client %p\n",\r\nclnt);\r\natomic_inc(&unix_auth.au_count);\r\nreturn &unix_auth;\r\n}\r\nstatic void\r\nunx_destroy(struct rpc_auth *auth)\r\n{\r\ndprintk("RPC: destroying UNIX authenticator %p\n", auth);\r\nrpcauth_clear_credcache(auth->au_credcache);\r\n}\r\nstatic struct rpc_cred *\r\nunx_lookup_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\r\n{\r\nreturn rpcauth_lookup_credcache(auth, acred, flags);\r\n}\r\nstatic struct rpc_cred *\r\nunx_create_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\r\n{\r\nstruct unx_cred *cred;\r\nunsigned int groups = 0;\r\nunsigned int i;\r\ndprintk("RPC: allocating UNIX cred for uid %d gid %d\n",\r\nacred->uid, acred->gid);\r\nif (!(cred = kmalloc(sizeof(*cred), GFP_NOFS)))\r\nreturn ERR_PTR(-ENOMEM);\r\nrpcauth_init_cred(&cred->uc_base, acred, auth, &unix_credops);\r\ncred->uc_base.cr_flags = 1UL << RPCAUTH_CRED_UPTODATE;\r\nif (acred->group_info != NULL)\r\ngroups = acred->group_info->ngroups;\r\nif (groups > NFS_NGROUPS)\r\ngroups = NFS_NGROUPS;\r\ncred->uc_gid = acred->gid;\r\nfor (i = 0; i < groups; i++)\r\ncred->uc_gids[i] = GROUP_AT(acred->group_info, i);\r\nif (i < NFS_NGROUPS)\r\ncred->uc_gids[i] = NOGROUP;\r\nreturn &cred->uc_base;\r\n}\r\nstatic void\r\nunx_free_cred(struct unx_cred *unx_cred)\r\n{\r\ndprintk("RPC: unx_free_cred %p\n", unx_cred);\r\nkfree(unx_cred);\r\n}\r\nstatic void\r\nunx_free_cred_callback(struct rcu_head *head)\r\n{\r\nstruct unx_cred *unx_cred = container_of(head, struct unx_cred, uc_base.cr_rcu);\r\nunx_free_cred(unx_cred);\r\n}\r\nstatic void\r\nunx_destroy_cred(struct rpc_cred *cred)\r\n{\r\ncall_rcu(&cred->cr_rcu, unx_free_cred_callback);\r\n}\r\nstatic int\r\nunx_match(struct auth_cred *acred, struct rpc_cred *rcred, int flags)\r\n{\r\nstruct unx_cred *cred = container_of(rcred, struct unx_cred, uc_base);\r\nunsigned int groups = 0;\r\nunsigned int i;\r\nif (cred->uc_uid != acred->uid || cred->uc_gid != acred->gid)\r\nreturn 0;\r\nif (acred->group_info != NULL)\r\ngroups = acred->group_info->ngroups;\r\nif (groups > NFS_NGROUPS)\r\ngroups = NFS_NGROUPS;\r\nfor (i = 0; i < groups ; i++)\r\nif (cred->uc_gids[i] != GROUP_AT(acred->group_info, i))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic __be32 *\r\nunx_marshal(struct rpc_task *task, __be32 *p)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nstruct unx_cred *cred = container_of(task->tk_rqstp->rq_cred, struct unx_cred, uc_base);\r\n__be32 *base, *hold;\r\nint i;\r\n*p++ = htonl(RPC_AUTH_UNIX);\r\nbase = p++;\r\n*p++ = htonl(jiffies/HZ);\r\np = xdr_encode_array(p, clnt->cl_nodename, clnt->cl_nodelen);\r\n*p++ = htonl((u32) cred->uc_uid);\r\n*p++ = htonl((u32) cred->uc_gid);\r\nhold = p++;\r\nfor (i = 0; i < 16 && cred->uc_gids[i] != (gid_t) NOGROUP; i++)\r\n*p++ = htonl((u32) cred->uc_gids[i]);\r\n*hold = htonl(p - hold - 1);\r\n*base = htonl((p - base - 1) << 2);\r\n*p++ = htonl(RPC_AUTH_NULL);\r\n*p++ = htonl(0);\r\nreturn p;\r\n}\r\nstatic int\r\nunx_refresh(struct rpc_task *task)\r\n{\r\nset_bit(RPCAUTH_CRED_UPTODATE, &task->tk_rqstp->rq_cred->cr_flags);\r\nreturn 0;\r\n}\r\nstatic __be32 *\r\nunx_validate(struct rpc_task *task, __be32 *p)\r\n{\r\nrpc_authflavor_t flavor;\r\nu32 size;\r\nflavor = ntohl(*p++);\r\nif (flavor != RPC_AUTH_NULL &&\r\nflavor != RPC_AUTH_UNIX &&\r\nflavor != RPC_AUTH_SHORT) {\r\nprintk("RPC: bad verf flavor: %u\n", flavor);\r\nreturn NULL;\r\n}\r\nsize = ntohl(*p++);\r\nif (size > RPC_MAX_AUTH_SIZE) {\r\nprintk("RPC: giant verf size: %u\n", size);\r\nreturn NULL;\r\n}\r\ntask->tk_rqstp->rq_cred->cr_auth->au_rslack = (size >> 2) + 2;\r\np += (size >> 2);\r\nreturn p;\r\n}\r\nint __init rpc_init_authunix(void)\r\n{\r\nreturn rpcauth_init_credcache(&unix_auth);\r\n}\r\nvoid rpc_destroy_authunix(void)\r\n{\r\nrpcauth_destroy_credcache(&unix_auth);\r\n}
