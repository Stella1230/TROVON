void ucb1x00_io_set_dir(struct ucb1x00 *ucb, unsigned int in, unsigned int out)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nucb->io_dir |= out;\r\nucb->io_dir &= ~in;\r\nucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\n}\r\nvoid ucb1x00_io_write(struct ucb1x00 *ucb, unsigned int set, unsigned int clear)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nucb->io_out |= set;\r\nucb->io_out &= ~clear;\r\nucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\n}\r\nunsigned int ucb1x00_io_read(struct ucb1x00 *ucb)\r\n{\r\nreturn ucb1x00_reg_read(ucb, UCB_IO_DATA);\r\n}\r\nstatic void ucb1x00_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nif (value)\r\nucb->io_out |= 1 << offset;\r\nelse\r\nucb->io_out &= ~(1 << offset);\r\nucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\n}\r\nstatic int ucb1x00_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nreturn ucb1x00_reg_read(ucb, UCB_IO_DATA) & (1 << offset);\r\n}\r\nstatic int ucb1x00_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nucb->io_dir &= ~(1 << offset);\r\nucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ucb1x00_gpio_direction_output(struct gpio_chip *chip, unsigned offset\r\n, int value)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nucb->io_dir |= (1 << offset);\r\nucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\r\nif (value)\r\nucb->io_out |= 1 << offset;\r\nelse\r\nucb->io_out &= ~(1 << offset);\r\nucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\nreturn 0;\r\n}\r\nvoid ucb1x00_adc_enable(struct ucb1x00 *ucb)\r\n{\r\ndown(&ucb->adc_sem);\r\nucb->adc_cr |= UCB_ADC_ENA;\r\nucb1x00_enable(ucb);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr);\r\n}\r\nunsigned int ucb1x00_adc_read(struct ucb1x00 *ucb, int adc_channel, int sync)\r\n{\r\nunsigned int val;\r\nif (sync)\r\nadc_channel |= UCB_ADC_SYNC_ENA;\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr | adc_channel);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr | adc_channel | UCB_ADC_START);\r\nfor (;;) {\r\nval = ucb1x00_reg_read(ucb, UCB_ADC_DATA);\r\nif (val & UCB_ADC_DAT_VAL)\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(1);\r\n}\r\nreturn UCB_ADC_DAT(val);\r\n}\r\nvoid ucb1x00_adc_disable(struct ucb1x00 *ucb)\r\n{\r\nucb->adc_cr &= ~UCB_ADC_ENA;\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr);\r\nucb1x00_disable(ucb);\r\nup(&ucb->adc_sem);\r\n}\r\nstatic irqreturn_t ucb1x00_irq(int irqnr, void *devid)\r\n{\r\nstruct ucb1x00 *ucb = devid;\r\nstruct ucb1x00_irq *irq;\r\nunsigned int isr, i;\r\nucb1x00_enable(ucb);\r\nisr = ucb1x00_reg_read(ucb, UCB_IE_STATUS);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, isr);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\r\nfor (i = 0, irq = ucb->irq_handler; i < 16 && isr; i++, isr >>= 1, irq++)\r\nif (isr & 1 && irq->fn)\r\nirq->fn(i, irq->devid);\r\nucb1x00_disable(ucb);\r\nreturn IRQ_HANDLED;\r\n}\r\nint ucb1x00_hook_irq(struct ucb1x00 *ucb, unsigned int idx, void (*fn)(int, void *), void *devid)\r\n{\r\nstruct ucb1x00_irq *irq;\r\nint ret = -EINVAL;\r\nif (idx < 16) {\r\nirq = ucb->irq_handler + idx;\r\nret = -EBUSY;\r\nspin_lock_irq(&ucb->lock);\r\nif (irq->fn == NULL) {\r\nirq->devid = devid;\r\nirq->fn = fn;\r\nret = 0;\r\n}\r\nspin_unlock_irq(&ucb->lock);\r\n}\r\nreturn ret;\r\n}\r\nvoid ucb1x00_enable_irq(struct ucb1x00 *ucb, unsigned int idx, int edges)\r\n{\r\nunsigned long flags;\r\nif (idx < 16) {\r\nspin_lock_irqsave(&ucb->lock, flags);\r\nucb1x00_enable(ucb);\r\nif (edges & UCB_RISING) {\r\nucb->irq_ris_enbl |= 1 << idx;\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl);\r\n}\r\nif (edges & UCB_FALLING) {\r\nucb->irq_fal_enbl |= 1 << idx;\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl);\r\n}\r\nucb1x00_disable(ucb);\r\nspin_unlock_irqrestore(&ucb->lock, flags);\r\n}\r\n}\r\nvoid ucb1x00_disable_irq(struct ucb1x00 *ucb, unsigned int idx, int edges)\r\n{\r\nunsigned long flags;\r\nif (idx < 16) {\r\nspin_lock_irqsave(&ucb->lock, flags);\r\nucb1x00_enable(ucb);\r\nif (edges & UCB_RISING) {\r\nucb->irq_ris_enbl &= ~(1 << idx);\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl);\r\n}\r\nif (edges & UCB_FALLING) {\r\nucb->irq_fal_enbl &= ~(1 << idx);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl);\r\n}\r\nucb1x00_disable(ucb);\r\nspin_unlock_irqrestore(&ucb->lock, flags);\r\n}\r\n}\r\nint ucb1x00_free_irq(struct ucb1x00 *ucb, unsigned int idx, void *devid)\r\n{\r\nstruct ucb1x00_irq *irq;\r\nint ret;\r\nif (idx >= 16)\r\ngoto bad;\r\nirq = ucb->irq_handler + idx;\r\nret = -ENOENT;\r\nspin_lock_irq(&ucb->lock);\r\nif (irq->devid == devid) {\r\nucb->irq_ris_enbl &= ~(1 << idx);\r\nucb->irq_fal_enbl &= ~(1 << idx);\r\nucb1x00_enable(ucb);\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl);\r\nucb1x00_disable(ucb);\r\nirq->fn = NULL;\r\nirq->devid = NULL;\r\nret = 0;\r\n}\r\nspin_unlock_irq(&ucb->lock);\r\nreturn ret;\r\nbad:\r\nprintk(KERN_ERR "Freeing bad UCB1x00 irq %d\n", idx);\r\nreturn -EINVAL;\r\n}\r\nstatic int ucb1x00_add_dev(struct ucb1x00 *ucb, struct ucb1x00_driver *drv)\r\n{\r\nstruct ucb1x00_dev *dev;\r\nint ret = -ENOMEM;\r\ndev = kmalloc(sizeof(struct ucb1x00_dev), GFP_KERNEL);\r\nif (dev) {\r\ndev->ucb = ucb;\r\ndev->drv = drv;\r\nret = drv->add(dev);\r\nif (ret == 0) {\r\nlist_add(&dev->dev_node, &ucb->devs);\r\nlist_add(&dev->drv_node, &drv->devs);\r\n} else {\r\nkfree(dev);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ucb1x00_remove_dev(struct ucb1x00_dev *dev)\r\n{\r\ndev->drv->remove(dev);\r\nlist_del(&dev->dev_node);\r\nlist_del(&dev->drv_node);\r\nkfree(dev);\r\n}\r\nstatic int ucb1x00_detect_irq(struct ucb1x00 *ucb)\r\n{\r\nunsigned long mask;\r\nmask = probe_irq_on();\r\nif (!mask) {\r\nprobe_irq_off(mask);\r\nreturn NO_IRQ;\r\n}\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, UCB_IE_ADC);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, UCB_IE_ADC);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0xffff);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, UCB_ADC_ENA);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, UCB_ADC_ENA | UCB_ADC_START);\r\nwhile ((ucb1x00_reg_read(ucb, UCB_ADC_DATA) & UCB_ADC_DAT_VAL) == 0);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, 0);\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, 0);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, 0);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0xffff);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\r\nreturn probe_irq_off(mask);\r\n}\r\nstatic void ucb1x00_release(struct device *dev)\r\n{\r\nstruct ucb1x00 *ucb = classdev_to_ucb1x00(dev);\r\nkfree(ucb);\r\n}\r\nstatic int ucb1x00_probe(struct mcp *mcp)\r\n{\r\nstruct ucb1x00 *ucb;\r\nstruct ucb1x00_driver *drv;\r\nunsigned int id;\r\nint ret = -ENODEV;\r\nint temp;\r\nmcp_enable(mcp);\r\nid = mcp_reg_read(mcp, UCB_ID);\r\nif (id != UCB_ID_1200 && id != UCB_ID_1300 && id != UCB_ID_TC35143) {\r\nprintk(KERN_WARNING "UCB1x00 ID not found: %04x\n", id);\r\ngoto err_disable;\r\n}\r\nucb = kzalloc(sizeof(struct ucb1x00), GFP_KERNEL);\r\nret = -ENOMEM;\r\nif (!ucb)\r\ngoto err_disable;\r\nucb->dev.class = &ucb1x00_class;\r\nucb->dev.parent = &mcp->attached_device;\r\ndev_set_name(&ucb->dev, "ucb1x00");\r\nspin_lock_init(&ucb->lock);\r\nspin_lock_init(&ucb->io_lock);\r\nsema_init(&ucb->adc_sem, 1);\r\nucb->id = id;\r\nucb->mcp = mcp;\r\nucb->irq = ucb1x00_detect_irq(ucb);\r\nif (ucb->irq == NO_IRQ) {\r\nprintk(KERN_ERR "UCB1x00: IRQ probe failed\n");\r\nret = -ENODEV;\r\ngoto err_free;\r\n}\r\nucb->gpio.base = -1;\r\nif (mcp->gpio_base != 0) {\r\nucb->gpio.label = dev_name(&ucb->dev);\r\nucb->gpio.base = mcp->gpio_base;\r\nucb->gpio.ngpio = 10;\r\nucb->gpio.set = ucb1x00_gpio_set;\r\nucb->gpio.get = ucb1x00_gpio_get;\r\nucb->gpio.direction_input = ucb1x00_gpio_direction_input;\r\nucb->gpio.direction_output = ucb1x00_gpio_direction_output;\r\nret = gpiochip_add(&ucb->gpio);\r\nif (ret)\r\ngoto err_free;\r\n} else\r\ndev_info(&ucb->dev, "gpio_base not set so no gpiolib support");\r\nret = request_irq(ucb->irq, ucb1x00_irq, IRQF_TRIGGER_RISING,\r\n"UCB1x00", ucb);\r\nif (ret) {\r\nprintk(KERN_ERR "ucb1x00: unable to grab irq%d: %d\n",\r\nucb->irq, ret);\r\ngoto err_gpio;\r\n}\r\nmcp_set_drvdata(mcp, ucb);\r\nret = device_register(&ucb->dev);\r\nif (ret)\r\ngoto err_irq;\r\nINIT_LIST_HEAD(&ucb->devs);\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_add(&ucb->node, &ucb1x00_devices);\r\nlist_for_each_entry(drv, &ucb1x00_drivers, node) {\r\nucb1x00_add_dev(ucb, drv);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\ngoto out;\r\nerr_irq:\r\nfree_irq(ucb->irq, ucb);\r\nerr_gpio:\r\nif (ucb->gpio.base != -1)\r\ntemp = gpiochip_remove(&ucb->gpio);\r\nerr_free:\r\nkfree(ucb);\r\nerr_disable:\r\nmcp_disable(mcp);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ucb1x00_remove(struct mcp *mcp)\r\n{\r\nstruct ucb1x00 *ucb = mcp_get_drvdata(mcp);\r\nstruct list_head *l, *n;\r\nint ret;\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_del(&ucb->node);\r\nlist_for_each_safe(l, n, &ucb->devs) {\r\nstruct ucb1x00_dev *dev = list_entry(l, struct ucb1x00_dev, dev_node);\r\nucb1x00_remove_dev(dev);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nif (ucb->gpio.base != -1) {\r\nret = gpiochip_remove(&ucb->gpio);\r\nif (ret)\r\ndev_err(&ucb->dev, "Can't remove gpio chip: %d\n", ret);\r\n}\r\nfree_irq(ucb->irq, ucb);\r\ndevice_unregister(&ucb->dev);\r\n}\r\nint ucb1x00_register_driver(struct ucb1x00_driver *drv)\r\n{\r\nstruct ucb1x00 *ucb;\r\nINIT_LIST_HEAD(&drv->devs);\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_add(&drv->node, &ucb1x00_drivers);\r\nlist_for_each_entry(ucb, &ucb1x00_devices, node) {\r\nucb1x00_add_dev(ucb, drv);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nreturn 0;\r\n}\r\nvoid ucb1x00_unregister_driver(struct ucb1x00_driver *drv)\r\n{\r\nstruct list_head *n, *l;\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_del(&drv->node);\r\nlist_for_each_safe(l, n, &drv->devs) {\r\nstruct ucb1x00_dev *dev = list_entry(l, struct ucb1x00_dev, drv_node);\r\nucb1x00_remove_dev(dev);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\n}\r\nstatic int ucb1x00_suspend(struct mcp *mcp, pm_message_t state)\r\n{\r\nstruct ucb1x00 *ucb = mcp_get_drvdata(mcp);\r\nstruct ucb1x00_dev *dev;\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_for_each_entry(dev, &ucb->devs, dev_node) {\r\nif (dev->drv->suspend)\r\ndev->drv->suspend(dev, state);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nreturn 0;\r\n}\r\nstatic int ucb1x00_resume(struct mcp *mcp)\r\n{\r\nstruct ucb1x00 *ucb = mcp_get_drvdata(mcp);\r\nstruct ucb1x00_dev *dev;\r\nucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_for_each_entry(dev, &ucb->devs, dev_node) {\r\nif (dev->drv->resume)\r\ndev->drv->resume(dev);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init ucb1x00_init(void)\r\n{\r\nint ret = class_register(&ucb1x00_class);\r\nif (ret == 0) {\r\nret = mcp_driver_register(&ucb1x00_driver);\r\nif (ret)\r\nclass_unregister(&ucb1x00_class);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit ucb1x00_exit(void)\r\n{\r\nmcp_driver_unregister(&ucb1x00_driver);\r\nclass_unregister(&ucb1x00_class);\r\n}
