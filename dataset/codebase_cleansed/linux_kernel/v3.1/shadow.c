void *kmemcheck_shadow_lookup(unsigned long address)\r\n{\r\npte_t *pte;\r\nstruct page *page;\r\nif (!virt_addr_valid(address))\r\nreturn NULL;\r\npte = kmemcheck_pte_lookup(address);\r\nif (!pte)\r\nreturn NULL;\r\npage = virt_to_page(address);\r\nif (!page->shadow)\r\nreturn NULL;\r\nreturn page->shadow + (address & (PAGE_SIZE - 1));\r\n}\r\nstatic void mark_shadow(void *address, unsigned int n,\r\nenum kmemcheck_shadow status)\r\n{\r\nunsigned long addr = (unsigned long) address;\r\nunsigned long last_addr = addr + n - 1;\r\nunsigned long page = addr & PAGE_MASK;\r\nunsigned long last_page = last_addr & PAGE_MASK;\r\nunsigned int first_n;\r\nvoid *shadow;\r\nif (page == last_page)\r\nfirst_n = n;\r\nelse\r\nfirst_n = page + PAGE_SIZE - addr;\r\nshadow = kmemcheck_shadow_lookup(addr);\r\nif (shadow)\r\nmemset(shadow, status, first_n);\r\naddr += first_n;\r\nn -= first_n;\r\nwhile (n >= PAGE_SIZE) {\r\nshadow = kmemcheck_shadow_lookup(addr);\r\nif (shadow)\r\nmemset(shadow, status, PAGE_SIZE);\r\naddr += PAGE_SIZE;\r\nn -= PAGE_SIZE;\r\n}\r\nif (n > 0) {\r\nshadow = kmemcheck_shadow_lookup(addr);\r\nif (shadow)\r\nmemset(shadow, status, n);\r\n}\r\n}\r\nvoid kmemcheck_mark_unallocated(void *address, unsigned int n)\r\n{\r\nmark_shadow(address, n, KMEMCHECK_SHADOW_UNALLOCATED);\r\n}\r\nvoid kmemcheck_mark_uninitialized(void *address, unsigned int n)\r\n{\r\nmark_shadow(address, n, KMEMCHECK_SHADOW_UNINITIALIZED);\r\n}\r\nvoid kmemcheck_mark_initialized(void *address, unsigned int n)\r\n{\r\nmark_shadow(address, n, KMEMCHECK_SHADOW_INITIALIZED);\r\n}\r\nvoid kmemcheck_mark_freed(void *address, unsigned int n)\r\n{\r\nmark_shadow(address, n, KMEMCHECK_SHADOW_FREED);\r\n}\r\nvoid kmemcheck_mark_unallocated_pages(struct page *p, unsigned int n)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < n; ++i)\r\nkmemcheck_mark_unallocated(page_address(&p[i]), PAGE_SIZE);\r\n}\r\nvoid kmemcheck_mark_uninitialized_pages(struct page *p, unsigned int n)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < n; ++i)\r\nkmemcheck_mark_uninitialized(page_address(&p[i]), PAGE_SIZE);\r\n}\r\nvoid kmemcheck_mark_initialized_pages(struct page *p, unsigned int n)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < n; ++i)\r\nkmemcheck_mark_initialized(page_address(&p[i]), PAGE_SIZE);\r\n}\r\nenum kmemcheck_shadow kmemcheck_shadow_test(void *shadow, unsigned int size)\r\n{\r\n#ifdef CONFIG_KMEMCHECK_PARTIAL_OK\r\nuint8_t *x;\r\nunsigned int i;\r\nx = shadow;\r\nfor (i = 0; i < size; ++i) {\r\nif (x[i] == KMEMCHECK_SHADOW_INITIALIZED)\r\nreturn x[i];\r\n}\r\nreturn x[0];\r\n#else\r\nreturn kmemcheck_shadow_test_all(shadow, size);\r\n#endif\r\n}\r\nenum kmemcheck_shadow kmemcheck_shadow_test_all(void *shadow, unsigned int size)\r\n{\r\nuint8_t *x;\r\nunsigned int i;\r\nx = shadow;\r\nfor (i = 0; i < size; ++i) {\r\nif (x[i] != KMEMCHECK_SHADOW_INITIALIZED)\r\nreturn x[i];\r\n}\r\nreturn x[0];\r\n}\r\nvoid kmemcheck_shadow_set(void *shadow, unsigned int size)\r\n{\r\nuint8_t *x;\r\nunsigned int i;\r\nx = shadow;\r\nfor (i = 0; i < size; ++i)\r\nx[i] = KMEMCHECK_SHADOW_INITIALIZED;\r\n}
