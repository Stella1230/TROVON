static void\r\nmii_idle(unsigned int ioaddr)\r\n{\r\nPutByte(XIRCREG2_GPR2, 0x04|0);\r\nudelay(1);\r\nPutByte(XIRCREG2_GPR2, 0x04|1);\r\nudelay(1);\r\n}\r\nstatic void\r\nmii_putbit(unsigned int ioaddr, unsigned data)\r\n{\r\n#if 1\r\nif (data) {\r\nPutByte(XIRCREG2_GPR2, 0x0c|2|0);\r\nudelay(1);\r\nPutByte(XIRCREG2_GPR2, 0x0c|2|1);\r\nudelay(1);\r\n} else {\r\nPutByte(XIRCREG2_GPR2, 0x0c|0|0);\r\nudelay(1);\r\nPutByte(XIRCREG2_GPR2, 0x0c|0|1);\r\nudelay(1);\r\n}\r\n#else\r\nif (data) {\r\nPutWord(XIRCREG2_GPR2-1, 0x0e0e);\r\nudelay(1);\r\nPutWord(XIRCREG2_GPR2-1, 0x0f0f);\r\nudelay(1);\r\n} else {\r\nPutWord(XIRCREG2_GPR2-1, 0x0c0c);\r\nudelay(1);\r\nPutWord(XIRCREG2_GPR2-1, 0x0d0d);\r\nudelay(1);\r\n}\r\n#endif\r\n}\r\nstatic int\r\nmii_getbit(unsigned int ioaddr)\r\n{\r\nunsigned d;\r\nPutByte(XIRCREG2_GPR2, 4|0);\r\nudelay(1);\r\nd = GetByte(XIRCREG2_GPR2);\r\nPutByte(XIRCREG2_GPR2, 4|1);\r\nudelay(1);\r\nreturn d & 0x20;\r\n}\r\nstatic void\r\nmii_wbits(unsigned int ioaddr, unsigned data, int len)\r\n{\r\nunsigned m = 1 << (len-1);\r\nfor (; m; m >>= 1)\r\nmii_putbit(ioaddr, data & m);\r\n}\r\nstatic unsigned\r\nmii_rd(unsigned int ioaddr, u_char phyaddr, u_char phyreg)\r\n{\r\nint i;\r\nunsigned data=0, m;\r\nSelectPage(2);\r\nfor (i=0; i < 32; i++)\r\nmii_putbit(ioaddr, 1);\r\nmii_wbits(ioaddr, 0x06, 4);\r\nmii_wbits(ioaddr, phyaddr, 5);\r\nmii_wbits(ioaddr, phyreg, 5);\r\nmii_idle(ioaddr);\r\nmii_getbit(ioaddr);\r\nfor (m = 1<<15; m; m >>= 1)\r\nif (mii_getbit(ioaddr))\r\ndata |= m;\r\nmii_idle(ioaddr);\r\nreturn data;\r\n}\r\nstatic void\r\nmii_wr(unsigned int ioaddr, u_char phyaddr, u_char phyreg, unsigned data,\r\nint len)\r\n{\r\nint i;\r\nSelectPage(2);\r\nfor (i=0; i < 32; i++)\r\nmii_putbit(ioaddr, 1);\r\nmii_wbits(ioaddr, 0x05, 4);\r\nmii_wbits(ioaddr, phyaddr, 5);\r\nmii_wbits(ioaddr, phyreg, 5);\r\nmii_putbit(ioaddr, 1);\r\nmii_putbit(ioaddr, 0);\r\nmii_wbits(ioaddr, data, len);\r\nmii_idle(ioaddr);\r\n}\r\nstatic int\r\nxirc2ps_probe(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev;\r\nlocal_info_t *local;\r\ndev_dbg(&link->dev, "attach()\n");\r\ndev = alloc_etherdev(sizeof(local_info_t));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlocal = netdev_priv(dev);\r\nlocal->dev = dev;\r\nlocal->p_dev = link;\r\nlink->priv = dev;\r\nlink->config_index = 1;\r\ndev->netdev_ops = &netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nINIT_WORK(&local->tx_timeout_task, xirc2ps_tx_timeout_task);\r\nreturn xirc2ps_config(link);\r\n}\r\nstatic void\r\nxirc2ps_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\ndev_dbg(&link->dev, "detach\n");\r\nunregister_netdev(dev);\r\nxirc2ps_release(link);\r\nfree_netdev(dev);\r\n}\r\nstatic int\r\nset_card_type(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nlocal_info_t *local = netdev_priv(dev);\r\nu8 *buf;\r\nunsigned int cisrev, mediaid, prodid;\r\nsize_t len;\r\nlen = pcmcia_get_tuple(link, CISTPL_MANFID, &buf);\r\nif (len < 5) {\r\ndev_err(&link->dev, "invalid CIS -- sorry\n");\r\nreturn 0;\r\n}\r\ncisrev = buf[2];\r\nmediaid = buf[3];\r\nprodid = buf[4];\r\ndev_dbg(&link->dev, "cisrev=%02x mediaid=%02x prodid=%02x\n",\r\ncisrev, mediaid, prodid);\r\nlocal->mohawk = 0;\r\nlocal->dingo = 0;\r\nlocal->modem = 0;\r\nlocal->card_type = XIR_UNKNOWN;\r\nif (!(prodid & 0x40)) {\r\npr_notice("Oops: Not a creditcard\n");\r\nreturn 0;\r\n}\r\nif (!(mediaid & 0x01)) {\r\npr_notice("Not an Ethernet card\n");\r\nreturn 0;\r\n}\r\nif (mediaid & 0x10) {\r\nlocal->modem = 1;\r\nswitch(prodid & 15) {\r\ncase 1: local->card_type = XIR_CEM ; break;\r\ncase 2: local->card_type = XIR_CEM2 ; break;\r\ncase 3: local->card_type = XIR_CEM3 ; break;\r\ncase 4: local->card_type = XIR_CEM33 ; break;\r\ncase 5: local->card_type = XIR_CEM56M;\r\nlocal->mohawk = 1;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nlocal->card_type = XIR_CEM56 ;\r\nlocal->mohawk = 1;\r\nlocal->dingo = 1;\r\nbreak;\r\n}\r\n} else {\r\nswitch(prodid & 15) {\r\ncase 1: local->card_type = has_ce2_string(link)? XIR_CE2 : XIR_CE ;\r\nbreak;\r\ncase 2: local->card_type = XIR_CE2; break;\r\ncase 3: local->card_type = XIR_CE3;\r\nlocal->mohawk = 1;\r\nbreak;\r\n}\r\n}\r\nif (local->card_type == XIR_CE || local->card_type == XIR_CEM) {\r\npr_notice("Sorry, this is an old CE card\n");\r\nreturn 0;\r\n}\r\nif (local->card_type == XIR_UNKNOWN)\r\npr_notice("unknown card (mediaid=%02x prodid=%02x)\n", mediaid, prodid);\r\nreturn 1;\r\n}\r\nstatic int\r\nhas_ce2_string(struct pcmcia_device * p_dev)\r\n{\r\nif (p_dev->prod_id[2] && strstr(p_dev->prod_id[2], "CE2"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nxirc2ps_config_modem(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nunsigned int ioaddr;\r\nif ((p_dev->resource[0]->start & 0xf) == 8)\r\nreturn -ENODEV;\r\np_dev->resource[0]->end = 16;\r\np_dev->resource[1]->end = 8;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\r\np_dev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\np_dev->io_lines = 10;\r\np_dev->resource[1]->start = p_dev->resource[0]->start;\r\nfor (ioaddr = 0x300; ioaddr < 0x400; ioaddr += 0x10) {\r\np_dev->resource[0]->start = ioaddr;\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nxirc2ps_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint *pass = priv_data;\r\nresource_size_t tmp = p_dev->resource[1]->start;\r\ntmp += (*pass ? (p_dev->config_index & 0x20 ? -24 : 8)\r\n: (p_dev->config_index & 0x20 ? 8 : -24));\r\nif ((p_dev->resource[0]->start & 0xf) == 8)\r\nreturn -ENODEV;\r\np_dev->resource[0]->end = 18;\r\np_dev->resource[1]->end = 8;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\r\np_dev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\np_dev->io_lines = 10;\r\np_dev->resource[1]->start = p_dev->resource[0]->start;\r\np_dev->resource[0]->start = tmp;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int pcmcia_get_mac_ce(struct pcmcia_device *p_dev,\r\ntuple_t *tuple,\r\nvoid *priv)\r\n{\r\nstruct net_device *dev = priv;\r\nint i;\r\nif (tuple->TupleDataLen != 13)\r\nreturn -EINVAL;\r\nif ((tuple->TupleData[0] != 2) || (tuple->TupleData[1] != 1) ||\r\n(tuple->TupleData[2] != 6))\r\nreturn -EINVAL;\r\nfor (i = 2; i < 6; i++)\r\ndev->dev_addr[i] = tuple->TupleData[i+2];\r\nreturn 0;\r\n}\r\nstatic int\r\nxirc2ps_config(struct pcmcia_device * link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nlocal_info_t *local = netdev_priv(dev);\r\nunsigned int ioaddr;\r\nint err;\r\nu8 *buf;\r\nsize_t len;\r\nlocal->dingo_ccr = NULL;\r\ndev_dbg(&link->dev, "config\n");\r\nif (link->has_manf_id == 0) {\r\npr_notice("manfid not found in CIS\n");\r\ngoto failure;\r\n}\r\nswitch (link->manf_id) {\r\ncase MANFID_XIRCOM:\r\nlocal->manf_str = "Xircom";\r\nbreak;\r\ncase MANFID_ACCTON:\r\nlocal->manf_str = "Accton";\r\nbreak;\r\ncase MANFID_COMPAQ:\r\ncase MANFID_COMPAQ2:\r\nlocal->manf_str = "Compaq";\r\nbreak;\r\ncase MANFID_INTEL:\r\nlocal->manf_str = "Intel";\r\nbreak;\r\ncase MANFID_TOSHIBA:\r\nlocal->manf_str = "Toshiba";\r\nbreak;\r\ndefault:\r\npr_notice("Unknown Card Manufacturer ID: 0x%04x\n",\r\n(unsigned)link->manf_id);\r\ngoto failure;\r\n}\r\ndev_dbg(&link->dev, "found %s card\n", local->manf_str);\r\nif (!set_card_type(link)) {\r\npr_notice("this card is not supported\n");\r\ngoto failure;\r\n}\r\nerr = pcmcia_get_mac_from_cis(link, dev);\r\nif (err) {\r\nlen = pcmcia_get_tuple(link, 0x89, &buf);\r\nif (buf && len == 8) {\r\nif (*buf == CISTPL_FUNCE_LAN_NODE_ID) {\r\nint i;\r\nfor (i = 2; i < 6; i++)\r\ndev->dev_addr[i] = buf[i+2];\r\n} else\r\nerr = -1;\r\n}\r\nkfree(buf);\r\n}\r\nif (err)\r\nerr = pcmcia_loop_tuple(link, CISTPL_FUNCE, pcmcia_get_mac_ce, dev);\r\nif (err) {\r\npr_notice("node-id not found in CIS\n");\r\ngoto failure;\r\n}\r\nif (local->modem) {\r\nint pass;\r\nlink->config_flags |= CONF_AUTO_SET_IO;\r\nif (local->dingo) {\r\nif (!pcmcia_loop_config(link, xirc2ps_config_modem, NULL))\r\ngoto port_found;\r\n} else {\r\nfor (pass=0; pass < 2; pass++)\r\nif (!pcmcia_loop_config(link, xirc2ps_config_check,\r\n&pass))\r\ngoto port_found;\r\n}\r\npr_notice("no ports available\n");\r\n} else {\r\nlink->io_lines = 10;\r\nlink->resource[0]->end = 16;\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\r\nfor (ioaddr = 0x300; ioaddr < 0x400; ioaddr += 0x10) {\r\nlink->resource[0]->start = ioaddr;\r\nif (!(err = pcmcia_request_io(link)))\r\ngoto port_found;\r\n}\r\nlink->resource[0]->start = 0;\r\nif ((err = pcmcia_request_io(link)))\r\ngoto config_error;\r\n}\r\nport_found:\r\nif (err)\r\ngoto config_error;\r\nif ((err=pcmcia_request_irq(link, xirc2ps_interrupt)))\r\ngoto config_error;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\nif (do_sound)\r\nlink->config_flags |= CONF_ENABLE_SPKR;\r\nif ((err = pcmcia_enable_device(link)))\r\ngoto config_error;\r\nif (local->dingo) {\r\nerr = pcmcia_write_config_byte(link, CISREG_IOBASE_0, (u8)\r\nlink->resource[1]->start & 0xff);\r\nif (err)\r\ngoto config_error;\r\nerr = pcmcia_write_config_byte(link, CISREG_IOBASE_1,\r\n(link->resource[1]->start >> 8) & 0xff);\r\nif (err)\r\ngoto config_error;\r\nlink->resource[2]->flags = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_AM |\r\nWIN_ENABLE;\r\nlink->resource[2]->start = link->resource[2]->end = 0;\r\nif ((err = pcmcia_request_window(link, link->resource[2], 0)))\r\ngoto config_error;\r\nlocal->dingo_ccr = ioremap(link->resource[2]->start, 0x1000) + 0x0800;\r\nif ((err = pcmcia_map_mem_page(link, link->resource[2], 0)))\r\ngoto config_error;\r\nwriteb(0x47, local->dingo_ccr + CISREG_COR);\r\nioaddr = link->resource[0]->start;\r\nwriteb(ioaddr & 0xff , local->dingo_ccr + CISREG_IOBASE_0);\r\nwriteb((ioaddr >> 8)&0xff , local->dingo_ccr + CISREG_IOBASE_1);\r\n#if 0\r\n{\r\nu_char tmp;\r\npr_info("ECOR:");\r\nfor (i=0; i < 7; i++) {\r\ntmp = readb(local->dingo_ccr + i*2);\r\npr_cont(" %02x", tmp);\r\n}\r\npr_cont("\n");\r\npr_info("DCOR:");\r\nfor (i=0; i < 4; i++) {\r\ntmp = readb(local->dingo_ccr + 0x20 + i*2);\r\npr_cont(" %02x", tmp);\r\n}\r\npr_cont("\n");\r\npr_info("SCOR:");\r\nfor (i=0; i < 10; i++) {\r\ntmp = readb(local->dingo_ccr + 0x40 + i*2);\r\npr_cont(" %02x", tmp);\r\n}\r\npr_cont("\n");\r\n}\r\n#endif\r\nwriteb(0x01, local->dingo_ccr + 0x20);\r\nwriteb(0x0c, local->dingo_ccr + 0x22);\r\nwriteb(0x00, local->dingo_ccr + 0x24);\r\nwriteb(0x00, local->dingo_ccr + 0x26);\r\nwriteb(0x00, local->dingo_ccr + 0x28);\r\n}\r\nlocal->probe_port=0;\r\nif (!if_port) {\r\nlocal->probe_port = dev->if_port = 1;\r\n} else if ((if_port >= 1 && if_port <= 2) ||\r\n(local->mohawk && if_port==4))\r\ndev->if_port = if_port;\r\nelse\r\npr_notice("invalid if_port requested\n");\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nif (local->dingo)\r\ndo_reset(dev, 1);\r\nSET_NETDEV_DEV(dev, &link->dev);\r\nif ((err=register_netdev(dev))) {\r\npr_notice("register_netdev() failed\n");\r\ngoto config_error;\r\n}\r\nnetdev_info(dev, "%s: port %#3lx, irq %d, hwaddr %pM\n",\r\nlocal->manf_str, (u_long)dev->base_addr, (int)dev->irq,\r\ndev->dev_addr);\r\nreturn 0;\r\nconfig_error:\r\nxirc2ps_release(link);\r\nreturn -ENODEV;\r\nfailure:\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\nxirc2ps_release(struct pcmcia_device *link)\r\n{\r\ndev_dbg(&link->dev, "release\n");\r\nif (link->resource[2]->end) {\r\nstruct net_device *dev = link->priv;\r\nlocal_info_t *local = netdev_priv(dev);\r\nif (local->dingo)\r\niounmap(local->dingo_ccr - 0x0800);\r\n}\r\npcmcia_disable_device(link);\r\n}\r\nstatic int xirc2ps_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open) {\r\nnetif_device_detach(dev);\r\ndo_powerdown(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xirc2ps_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open) {\r\ndo_reset(dev,1);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nxirc2ps_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nlocal_info_t *lp = netdev_priv(dev);\r\nunsigned int ioaddr;\r\nu_char saved_page;\r\nunsigned bytes_rcvd;\r\nunsigned int_status, eth_status, rx_status, tx_status;\r\nunsigned rsr, pktlen;\r\nulong start_ticks = jiffies;\r\nif (!netif_device_present(dev))\r\nreturn IRQ_HANDLED;\r\nioaddr = dev->base_addr;\r\nif (lp->mohawk) {\r\nPutByte(XIRCREG_CR, 0);\r\n}\r\npr_debug("%s: interrupt %d at %#x.\n", dev->name, irq, ioaddr);\r\nsaved_page = GetByte(XIRCREG_PR);\r\nint_status = GetByte(XIRCREG_ISR);\r\nbytes_rcvd = 0;\r\nloop_entry:\r\nif (int_status == 0xff) {\r\npr_debug("%s: interrupt %d for dead card\n", dev->name, irq);\r\ngoto leave;\r\n}\r\neth_status = GetByte(XIRCREG_ESR);\r\nSelectPage(0x40);\r\nrx_status = GetByte(XIRCREG40_RXST0);\r\nPutByte(XIRCREG40_RXST0, (~rx_status & 0xff));\r\ntx_status = GetByte(XIRCREG40_TXST0);\r\ntx_status |= GetByte(XIRCREG40_TXST1) << 8;\r\nPutByte(XIRCREG40_TXST0, 0);\r\nPutByte(XIRCREG40_TXST1, 0);\r\npr_debug("%s: ISR=%#2.2x ESR=%#2.2x RSR=%#2.2x TSR=%#4.4x\n",\r\ndev->name, int_status, eth_status, rx_status, tx_status);\r\nSelectPage(0);\r\nwhile (eth_status & FullPktRcvd) {\r\nrsr = GetByte(XIRCREG0_RSR);\r\nif (bytes_rcvd > maxrx_bytes && (rsr & PktRxOk)) {\r\ndev->stats.rx_dropped++;\r\npr_debug("%s: RX drop, too much done\n", dev->name);\r\n} else if (rsr & PktRxOk) {\r\nstruct sk_buff *skb;\r\npktlen = GetWord(XIRCREG0_RBC);\r\nbytes_rcvd += pktlen;\r\npr_debug("rsr=%#02x packet_length=%u\n", rsr, pktlen);\r\nskb = dev_alloc_skb(pktlen+3);\r\nif (!skb) {\r\npr_notice("low memory, packet dropped (size=%u)\n", pktlen);\r\ndev->stats.rx_dropped++;\r\n} else {\r\nskb_reserve(skb, 2);\r\nif (lp->silicon == 0 ) {\r\nunsigned rhsa;\r\nSelectPage(5);\r\nrhsa = GetWord(XIRCREG5_RHSA0);\r\nSelectPage(0);\r\nrhsa += 3;\r\nif (rhsa >= 0x8000)\r\nrhsa = 0;\r\nif (rhsa + pktlen > 0x8000) {\r\nunsigned i;\r\nu_char *buf = skb_put(skb, pktlen);\r\nfor (i=0; i < pktlen ; i++, rhsa++) {\r\nbuf[i] = GetByte(XIRCREG_EDP);\r\nif (rhsa == 0x8000) {\r\nrhsa = 0;\r\ni--;\r\n}\r\n}\r\n} else {\r\ninsw(ioaddr+XIRCREG_EDP,\r\nskb_put(skb, pktlen), (pktlen+1)>>1);\r\n}\r\n}\r\n#if 0\r\nelse if (lp->mohawk) {\r\nunsigned i;\r\nu_long *p = skb_put(skb, pktlen);\r\nregister u_long a;\r\nunsigned int edpreg = ioaddr+XIRCREG_EDP-2;\r\nfor (i=0; i < len ; i += 4, p++) {\r\na = inl(edpreg);\r\n__asm__("rorl $16,%0\n\t"\r\n:"=q" (a)\r\n: "0" (a));\r\n*p = a;\r\n}\r\n}\r\n#endif\r\nelse {\r\ninsw(ioaddr+XIRCREG_EDP, skb_put(skb, pktlen),\r\n(pktlen+1)>>1);\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pktlen;\r\nif (!(rsr & PhyPkt))\r\ndev->stats.multicast++;\r\n}\r\n} else {\r\npr_debug("rsr=%#02x\n", rsr);\r\n}\r\nif (rsr & PktTooLong) {\r\ndev->stats.rx_frame_errors++;\r\npr_debug("%s: Packet too long\n", dev->name);\r\n}\r\nif (rsr & CRCErr) {\r\ndev->stats.rx_crc_errors++;\r\npr_debug("%s: CRC error\n", dev->name);\r\n}\r\nif (rsr & AlignErr) {\r\ndev->stats.rx_fifo_errors++;\r\npr_debug("%s: Alignment error\n", dev->name);\r\n}\r\nPutWord(XIRCREG0_DO, 0x8000);\r\neth_status = GetByte(XIRCREG_ESR);\r\n}\r\nif (rx_status & 0x10) {\r\ndev->stats.rx_over_errors++;\r\nPutByte(XIRCREG_CR, ClearRxOvrun);\r\npr_debug("receive overrun cleared\n");\r\n}\r\nif (int_status & PktTxed) {\r\nunsigned n, nn;\r\nn = lp->last_ptr_value;\r\nnn = GetByte(XIRCREG0_PTR);\r\nlp->last_ptr_value = nn;\r\nif (nn < n)\r\ndev->stats.tx_packets += 256 - n;\r\nelse if (n == nn) {\r\npr_debug("PTR not changed?\n");\r\n} else\r\ndev->stats.tx_packets += lp->last_ptr_value - n;\r\nnetif_wake_queue(dev);\r\n}\r\nif (tx_status & 0x0002) {\r\npr_debug("tx restarted due to execssive collissions\n");\r\nPutByte(XIRCREG_CR, RestartTx);\r\n}\r\nif (tx_status & 0x0040)\r\ndev->stats.tx_aborted_errors++;\r\nif (bytes_rcvd > 1000) {\r\nu_long duration = jiffies - start_ticks;\r\nif (duration >= HZ/10) {\r\nmaxrx_bytes = (bytes_rcvd * (HZ/10)) / duration;\r\nif (maxrx_bytes < 2000)\r\nmaxrx_bytes = 2000;\r\nelse if (maxrx_bytes > 22000)\r\nmaxrx_bytes = 22000;\r\npr_debug("set maxrx=%u (rcvd=%u ticks=%lu)\n",\r\nmaxrx_bytes, bytes_rcvd, duration);\r\n} else if (!duration && maxrx_bytes < 22000) {\r\nmaxrx_bytes += 2000;\r\nif (maxrx_bytes > 22000)\r\nmaxrx_bytes = 22000;\r\npr_debug("set maxrx=%u\n", maxrx_bytes);\r\n}\r\n}\r\nleave:\r\nif (lockup_hack) {\r\nif (int_status != 0xff && (int_status = GetByte(XIRCREG_ISR)) != 0)\r\ngoto loop_entry;\r\n}\r\nSelectPage(saved_page);\r\nPutByte(XIRCREG_CR, EnableIntr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nxirc2ps_tx_timeout_task(struct work_struct *work)\r\n{\r\nlocal_info_t *local =\r\ncontainer_of(work, local_info_t, tx_timeout_task);\r\nstruct net_device *dev = local->dev;\r\ndo_reset(dev,1);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void\r\nxirc_tx_timeout(struct net_device *dev)\r\n{\r\nlocal_info_t *lp = netdev_priv(dev);\r\ndev->stats.tx_errors++;\r\nnetdev_notice(dev, "transmit timed out\n");\r\nschedule_work(&lp->tx_timeout_task);\r\n}\r\nstatic netdev_tx_t\r\ndo_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nlocal_info_t *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nint okay;\r\nunsigned freespace;\r\nunsigned pktlen = skb->len;\r\npr_debug("do_start_xmit(skb=%p, dev=%p) len=%u\n",\r\nskb, dev, pktlen);\r\nif (pktlen < ETH_ZLEN)\r\n{\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\npktlen = ETH_ZLEN;\r\n}\r\nnetif_stop_queue(dev);\r\nSelectPage(0);\r\nPutWord(XIRCREG0_TRS, (u_short)pktlen+2);\r\nfreespace = GetWord(XIRCREG0_TSO);\r\nokay = freespace & 0x8000;\r\nfreespace &= 0x7fff;\r\nokay = pktlen +2 < freespace;\r\npr_debug("%s: avail. tx space=%u%s\n",\r\ndev->name, freespace, okay ? " (okay)":" (not enough)");\r\nif (!okay) {\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nPutWord(XIRCREG_EDP, (u_short)pktlen);\r\noutsw(ioaddr+XIRCREG_EDP, skb->data, pktlen>>1);\r\nif (pktlen & 1)\r\nPutByte(XIRCREG_EDP, skb->data[pktlen-1]);\r\nif (lp->mohawk)\r\nPutByte(XIRCREG_CR, TransmitPacket|EnableIntr);\r\ndev_kfree_skb (skb);\r\ndev->stats.tx_bytes += pktlen;\r\nnetif_start_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void set_address(struct set_address_info *sa_info, char *addr)\r\n{\r\nunsigned int ioaddr = sa_info->ioaddr;\r\nint i;\r\nfor (i = 0; i < 6; i++) {\r\nif (sa_info->reg_nr > 15) {\r\nsa_info->reg_nr = 8;\r\nsa_info->page_nr++;\r\nSelectPage(sa_info->page_nr);\r\n}\r\nif (sa_info->mohawk)\r\nPutByte(sa_info->reg_nr++, addr[5 - i]);\r\nelse\r\nPutByte(sa_info->reg_nr++, addr[i]);\r\n}\r\n}\r\nstatic void set_addresses(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nlocal_info_t *lp = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nstruct set_address_info sa_info;\r\nint i;\r\nsa_info.reg_nr = 15 + 1;\r\nsa_info.page_nr = 0x50 - 1;\r\nsa_info.mohawk = lp->mohawk;\r\nsa_info.ioaddr = ioaddr;\r\nset_address(&sa_info, dev->dev_addr);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (i++ == 9)\r\nbreak;\r\nset_address(&sa_info, ha->addr);\r\n}\r\nwhile (i++ < 9)\r\nset_address(&sa_info, dev->dev_addr);\r\nSelectPage(0);\r\n}\r\nstatic void\r\nset_multicast_list(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nunsigned value;\r\nSelectPage(0x42);\r\nvalue = GetByte(XIRCREG42_SWC1) & 0xC0;\r\nif (dev->flags & IFF_PROMISC) {\r\nPutByte(XIRCREG42_SWC1, value | 0x06);\r\n} else if (netdev_mc_count(dev) > 9 || (dev->flags & IFF_ALLMULTI)) {\r\nPutByte(XIRCREG42_SWC1, value | 0x02);\r\n} else if (!netdev_mc_empty(dev)) {\r\nPutByte(XIRCREG42_SWC1, value | 0x01);\r\nSelectPage(0x40);\r\nPutByte(XIRCREG40_CMD0, Offline);\r\nset_addresses(dev);\r\nSelectPage(0x40);\r\nPutByte(XIRCREG40_CMD0, EnableRecv | Online);\r\n} else {\r\nPutByte(XIRCREG42_SWC1, value | 0x00);\r\n}\r\nSelectPage(0);\r\n}\r\nstatic int\r\ndo_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nlocal_info_t *local = netdev_priv(dev);\r\npr_debug("do_config(%p)\n", dev);\r\nif (map->port != 255 && map->port != dev->if_port) {\r\nif (map->port > 4)\r\nreturn -EINVAL;\r\nif (!map->port) {\r\nlocal->probe_port = 1;\r\ndev->if_port = 1;\r\n} else {\r\nlocal->probe_port = 0;\r\ndev->if_port = map->port;\r\n}\r\nnetdev_info(dev, "switching to %s port\n", if_names[dev->if_port]);\r\ndo_reset(dev,1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_open(struct net_device *dev)\r\n{\r\nlocal_info_t *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\ndev_dbg(&link->dev, "do_open(%p)\n", dev);\r\nif (!pcmcia_dev_present(link))\r\nreturn -ENODEV;\r\nlink->open++;\r\nnetif_start_queue(dev);\r\ndo_reset(dev,1);\r\nreturn 0;\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, "xirc2ps_cs");\r\nsprintf(info->bus_info, "PCMCIA 0x%lx", dev->base_addr);\r\n}\r\nstatic int\r\ndo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nlocal_info_t *local = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\npr_debug("%s: ioctl(%-.6s, %#04x) %04x %04x %04x %04x\n",\r\ndev->name, rq->ifr_ifrn.ifrn_name, cmd,\r\ndata->phy_id, data->reg_num, data->val_in, data->val_out);\r\nif (!local->mohawk)\r\nreturn -EOPNOTSUPP;\r\nswitch(cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = 0;\r\ncase SIOCGMIIREG:\r\ndata->val_out = mii_rd(ioaddr, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f);\r\nbreak;\r\ncase SIOCSMIIREG:\r\nmii_wr(ioaddr, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in,\r\n16);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nhardreset(struct net_device *dev)\r\n{\r\nlocal_info_t *local = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nSelectPage(4);\r\nudelay(1);\r\nPutByte(XIRCREG4_GPR1, 0);\r\nmsleep(40);\r\nif (local->mohawk)\r\nPutByte(XIRCREG4_GPR1, 1);\r\nelse\r\nPutByte(XIRCREG4_GPR1, 1 | 4);\r\nmsleep(20);\r\n}\r\nstatic void\r\ndo_reset(struct net_device *dev, int full)\r\n{\r\nlocal_info_t *local = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nunsigned value;\r\npr_debug("%s: do_reset(%p,%d)\n", dev? dev->name:"eth?", dev, full);\r\nhardreset(dev);\r\nPutByte(XIRCREG_CR, SoftReset);\r\nmsleep(20);\r\nPutByte(XIRCREG_CR, 0);\r\nmsleep(40);\r\nif (local->mohawk) {\r\nSelectPage(4);\r\nPutByte(XIRCREG4_GPR0, 0x0e);\r\n}\r\nmsleep(500);\r\nlocal->last_ptr_value = 0;\r\nlocal->silicon = local->mohawk ? (GetByte(XIRCREG4_BOV) & 0x70) >> 4\r\n: (GetByte(XIRCREG4_BOV) & 0x30) >> 4;\r\nif (local->probe_port) {\r\nif (!local->mohawk) {\r\nSelectPage(4);\r\nPutByte(XIRCREG4_GPR0, 4);\r\nlocal->probe_port = 0;\r\n}\r\n} else if (dev->if_port == 2) {\r\nSelectPage(0x42);\r\nPutByte(XIRCREG42_SWC1, 0xC0);\r\n} else {\r\nSelectPage(0x42);\r\nPutByte(XIRCREG42_SWC1, 0x80);\r\n}\r\nmsleep(40);\r\n#if 0\r\n{\r\nSelectPage(0);\r\nvalue = GetByte(XIRCREG_ESR);\r\npr_debug("%s: ESR is: %#02x\n", dev->name, value);\r\n}\r\n#endif\r\nSelectPage(1);\r\nPutByte(XIRCREG1_IMR0, 0xff);\r\nPutByte(XIRCREG1_IMR1, 1 );\r\nvalue = GetByte(XIRCREG1_ECR);\r\n#if 0\r\nif (local->mohawk)\r\nvalue |= DisableLinkPulse;\r\nPutByte(XIRCREG1_ECR, value);\r\n#endif\r\npr_debug("%s: ECR is: %#02x\n", dev->name, value);\r\nSelectPage(0x42);\r\nPutByte(XIRCREG42_SWC0, 0x20);\r\nif (local->silicon != 1) {\r\nSelectPage(2);\r\nPutWord(XIRCREG2_RBS, 0x2000);\r\n}\r\nif (full)\r\nset_addresses(dev);\r\nSelectPage(0);\r\nPutWord(XIRCREG0_DO, 0x2000);\r\nSelectPage(0x40);\r\nPutByte(XIRCREG40_RMASK0, 0xff);\r\nPutByte(XIRCREG40_TMASK0, 0xff);\r\nPutByte(XIRCREG40_TMASK1, 0xb0);\r\nPutByte(XIRCREG40_RXST0, 0x00);\r\nPutByte(XIRCREG40_TXST0, 0x00);\r\nPutByte(XIRCREG40_TXST1, 0x00);\r\nif (full && local->mohawk && init_mii(dev)) {\r\nif (dev->if_port == 4 || local->dingo || local->new_mii) {\r\nnetdev_info(dev, "MII selected\n");\r\nSelectPage(2);\r\nPutByte(XIRCREG2_MSR, GetByte(XIRCREG2_MSR) | 0x08);\r\nmsleep(20);\r\n} else {\r\nnetdev_info(dev, "MII detected; using 10mbs\n");\r\nSelectPage(0x42);\r\nif (dev->if_port == 2)\r\nPutByte(XIRCREG42_SWC1, 0xC0);\r\nelse\r\nPutByte(XIRCREG42_SWC1, 0x80);\r\nmsleep(40);\r\n}\r\nif (full_duplex)\r\nPutByte(XIRCREG1_ECR, GetByte(XIRCREG1_ECR | FullDuplex));\r\n} else {\r\nSelectPage(0);\r\nvalue = GetByte(XIRCREG_ESR);\r\ndev->if_port = (value & MediaSelect) ? 1 : 2;\r\n}\r\nSelectPage(2);\r\nif (dev->if_port == 1 || dev->if_port == 4)\r\nPutByte(XIRCREG2_LED, 0x3b);\r\nelse\r\nPutByte(XIRCREG2_LED, 0x3a);\r\nif (local->dingo)\r\nPutByte(0x0b, 0x04);\r\nif (full) {\r\nset_multicast_list(dev);\r\nSelectPage(0x40);\r\nPutByte(XIRCREG40_CMD0, EnableRecv | Online);\r\n}\r\nSelectPage(1);\r\nPutByte(XIRCREG1_IMR0, 0xff);\r\nudelay(1);\r\nSelectPage(0);\r\nPutByte(XIRCREG_CR, EnableIntr);\r\nif (local->modem && !local->dingo) {\r\nif (!(GetByte(0x10) & 0x01))\r\nPutByte(0x10, 0x11);\r\n}\r\nif (full)\r\nnetdev_info(dev, "media %s, silicon revision %d\n",\r\nif_names[dev->if_port], local->silicon);\r\nSelectPage(0);\r\n}\r\nstatic int\r\ninit_mii(struct net_device *dev)\r\n{\r\nlocal_info_t *local = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nunsigned control, status, linkpartner;\r\nint i;\r\nif (if_port == 4 || if_port == 1) {\r\ndev->if_port = if_port;\r\nlocal->probe_port = 0;\r\nreturn 1;\r\n}\r\nstatus = mii_rd(ioaddr, 0, 1);\r\nif ((status & 0xff00) != 0x7800)\r\nreturn 0;\r\nlocal->new_mii = (mii_rd(ioaddr, 0, 2) != 0xffff);\r\nif (local->probe_port)\r\ncontrol = 0x1000;\r\nelse if (dev->if_port == 4)\r\ncontrol = 0x2000;\r\nelse\r\ncontrol = 0x0000;\r\nmii_wr(ioaddr, 0, 0, control, 16);\r\nudelay(100);\r\ncontrol = mii_rd(ioaddr, 0, 0);\r\nif (control & 0x0400) {\r\nnetdev_notice(dev, "can't take PHY out of isolation mode\n");\r\nlocal->probe_port = 0;\r\nreturn 0;\r\n}\r\nif (local->probe_port) {\r\nfor (i=0; i < 35; i++) {\r\nmsleep(100);\r\nstatus = mii_rd(ioaddr, 0, 1);\r\nif ((status & 0x0020) && (status & 0x0004))\r\nbreak;\r\n}\r\nif (!(status & 0x0020)) {\r\nnetdev_info(dev, "autonegotiation failed; using 10mbs\n");\r\nif (!local->new_mii) {\r\ncontrol = 0x0000;\r\nmii_wr(ioaddr, 0, 0, control, 16);\r\nudelay(100);\r\nSelectPage(0);\r\ndev->if_port = (GetByte(XIRCREG_ESR) & MediaSelect) ? 1 : 2;\r\n}\r\n} else {\r\nlinkpartner = mii_rd(ioaddr, 0, 5);\r\nnetdev_info(dev, "MII link partner: %04x\n", linkpartner);\r\nif (linkpartner & 0x0080) {\r\ndev->if_port = 4;\r\n} else\r\ndev->if_port = 1;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\ndo_powerdown(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\npr_debug("do_powerdown(%p)\n", dev);\r\nSelectPage(4);\r\nPutByte(XIRCREG4_GPR1, 0);\r\nSelectPage(0);\r\n}\r\nstatic int\r\ndo_stop(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nlocal_info_t *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\ndev_dbg(&link->dev, "do_stop(%p)\n", dev);\r\nif (!link)\r\nreturn -ENODEV;\r\nnetif_stop_queue(dev);\r\nSelectPage(0);\r\nPutByte(XIRCREG_CR, 0);\r\nSelectPage(0x01);\r\nPutByte(XIRCREG1_IMR0, 0x00);\r\nSelectPage(4);\r\nPutByte(XIRCREG4_GPR1, 0);\r\nSelectPage(0);\r\nlink->open--;\r\nreturn 0;\r\n}\r\nstatic int __init\r\ninit_xirc2ps_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&xirc2ps_cs_driver);\r\n}\r\nstatic void __exit\r\nexit_xirc2ps_cs(void)\r\n{\r\npcmcia_unregister_driver(&xirc2ps_cs_driver);\r\n}\r\nstatic int __init setup_xirc2ps_cs(char *str)\r\n{\r\nint ints[10] = { -1 };\r\nstr = get_options(str, 9, ints);\r\n#define MAYBE_SET(X,Y) if (ints[0] >= Y && ints[Y] != -1) { X = ints[Y]; }\r\nMAYBE_SET(if_port, 3);\r\nMAYBE_SET(full_duplex, 4);\r\nMAYBE_SET(do_sound, 5);\r\nMAYBE_SET(lockup_hack, 6);\r\n#undef MAYBE_SET\r\nreturn 1;\r\n}
