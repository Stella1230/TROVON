static void\r\nnv04_i2c_setscl(void *data, int state)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nuint8_t val;\r\nval = (NVReadVgaCrtc(dev, 0, i2c->wr) & 0xd0) | (state ? 0x20 : 0);\r\nNVWriteVgaCrtc(dev, 0, i2c->wr, val | 0x01);\r\n}\r\nstatic void\r\nnv04_i2c_setsda(void *data, int state)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nuint8_t val;\r\nval = (NVReadVgaCrtc(dev, 0, i2c->wr) & 0xe0) | (state ? 0x10 : 0);\r\nNVWriteVgaCrtc(dev, 0, i2c->wr, val | 0x01);\r\n}\r\nstatic int\r\nnv04_i2c_getscl(void *data)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nreturn !!(NVReadVgaCrtc(dev, 0, i2c->rd) & 4);\r\n}\r\nstatic int\r\nnv04_i2c_getsda(void *data)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nreturn !!(NVReadVgaCrtc(dev, 0, i2c->rd) & 8);\r\n}\r\nstatic void\r\nnv4e_i2c_setscl(void *data, int state)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nuint8_t val;\r\nval = (nv_rd32(dev, i2c->wr) & 0xd0) | (state ? 0x20 : 0);\r\nnv_wr32(dev, i2c->wr, val | 0x01);\r\n}\r\nstatic void\r\nnv4e_i2c_setsda(void *data, int state)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nuint8_t val;\r\nval = (nv_rd32(dev, i2c->wr) & 0xe0) | (state ? 0x10 : 0);\r\nnv_wr32(dev, i2c->wr, val | 0x01);\r\n}\r\nstatic int\r\nnv4e_i2c_getscl(void *data)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nreturn !!((nv_rd32(dev, i2c->rd) >> 16) & 4);\r\n}\r\nstatic int\r\nnv4e_i2c_getsda(void *data)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nreturn !!((nv_rd32(dev, i2c->rd) >> 16) & 8);\r\n}\r\nstatic int\r\nnv50_i2c_getscl(void *data)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nreturn !!(nv_rd32(dev, i2c->rd) & 1);\r\n}\r\nstatic int\r\nnv50_i2c_getsda(void *data)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nreturn !!(nv_rd32(dev, i2c->rd) & 2);\r\n}\r\nstatic void\r\nnv50_i2c_setscl(void *data, int state)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nnv_wr32(dev, i2c->wr, 4 | (i2c->data ? 2 : 0) | (state ? 1 : 0));\r\n}\r\nstatic void\r\nnv50_i2c_setsda(void *data, int state)\r\n{\r\nstruct nouveau_i2c_chan *i2c = data;\r\nstruct drm_device *dev = i2c->dev;\r\nnv_wr32(dev, i2c->wr,\r\n(nv_rd32(dev, i2c->rd) & 1) | 4 | (state ? 2 : 0));\r\ni2c->data = state;\r\n}\r\nint\r\nnouveau_i2c_init(struct drm_device *dev, struct dcb_i2c_entry *entry, int index)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_i2c_chan *i2c;\r\nint ret;\r\nif (entry->chan)\r\nreturn -EEXIST;\r\nif (dev_priv->card_type >= NV_50 && entry->read >= NV50_I2C_PORTS) {\r\nNV_ERROR(dev, "unknown i2c port %d\n", entry->read);\r\nreturn -EINVAL;\r\n}\r\ni2c = kzalloc(sizeof(*i2c), GFP_KERNEL);\r\nif (i2c == NULL)\r\nreturn -ENOMEM;\r\nswitch (entry->port_type) {\r\ncase 0:\r\ni2c->bit.setsda = nv04_i2c_setsda;\r\ni2c->bit.setscl = nv04_i2c_setscl;\r\ni2c->bit.getsda = nv04_i2c_getsda;\r\ni2c->bit.getscl = nv04_i2c_getscl;\r\ni2c->rd = entry->read;\r\ni2c->wr = entry->write;\r\nbreak;\r\ncase 4:\r\ni2c->bit.setsda = nv4e_i2c_setsda;\r\ni2c->bit.setscl = nv4e_i2c_setscl;\r\ni2c->bit.getsda = nv4e_i2c_getsda;\r\ni2c->bit.getscl = nv4e_i2c_getscl;\r\ni2c->rd = 0x600800 + entry->read;\r\ni2c->wr = 0x600800 + entry->write;\r\nbreak;\r\ncase 5:\r\ni2c->bit.setsda = nv50_i2c_setsda;\r\ni2c->bit.setscl = nv50_i2c_setscl;\r\ni2c->bit.getsda = nv50_i2c_getsda;\r\ni2c->bit.getscl = nv50_i2c_getscl;\r\ni2c->rd = nv50_i2c_port[entry->read];\r\ni2c->wr = i2c->rd;\r\nbreak;\r\ncase 6:\r\ni2c->rd = entry->read;\r\ni2c->wr = entry->write;\r\nbreak;\r\ndefault:\r\nNV_ERROR(dev, "DCB I2C port type %d unknown\n",\r\nentry->port_type);\r\nkfree(i2c);\r\nreturn -EINVAL;\r\n}\r\nsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\r\n"nouveau-%s-%d", pci_name(dev->pdev), index);\r\ni2c->adapter.owner = THIS_MODULE;\r\ni2c->adapter.dev.parent = &dev->pdev->dev;\r\ni2c->dev = dev;\r\ni2c_set_adapdata(&i2c->adapter, i2c);\r\nif (entry->port_type < 6) {\r\ni2c->adapter.algo_data = &i2c->bit;\r\ni2c->bit.udelay = 40;\r\ni2c->bit.timeout = usecs_to_jiffies(5000);\r\ni2c->bit.data = i2c;\r\nret = i2c_bit_add_bus(&i2c->adapter);\r\n} else {\r\ni2c->adapter.algo = &nouveau_dp_i2c_algo;\r\nret = i2c_add_adapter(&i2c->adapter);\r\n}\r\nif (ret) {\r\nNV_ERROR(dev, "Failed to register i2c %d\n", index);\r\nkfree(i2c);\r\nreturn ret;\r\n}\r\nentry->chan = i2c;\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_i2c_fini(struct drm_device *dev, struct dcb_i2c_entry *entry)\r\n{\r\nif (!entry->chan)\r\nreturn;\r\ni2c_del_adapter(&entry->chan->adapter);\r\nkfree(entry->chan);\r\nentry->chan = NULL;\r\n}\r\nstruct nouveau_i2c_chan *\r\nnouveau_i2c_find(struct drm_device *dev, int index)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct dcb_i2c_entry *i2c = &dev_priv->vbios.dcb.i2c[index];\r\nif (index >= DCB_MAX_NUM_I2C_ENTRIES)\r\nreturn NULL;\r\nif (dev_priv->card_type >= NV_50 && (i2c->entry & 0x00000100)) {\r\nuint32_t reg = 0xe500, val;\r\nif (i2c->port_type == 6) {\r\nreg += i2c->read * 0x50;\r\nval = 0x2002;\r\n} else {\r\nreg += ((i2c->entry & 0x1e00) >> 9) * 0x50;\r\nval = 0xe001;\r\n}\r\nnv_wr32(dev, reg, (nv_rd32(dev, reg) & ~0xf003) | val);\r\n}\r\nif (!i2c->chan && nouveau_i2c_init(dev, i2c, index))\r\nreturn NULL;\r\nreturn i2c->chan;\r\n}\r\nbool\r\nnouveau_probe_i2c_addr(struct nouveau_i2c_chan *i2c, int addr)\r\n{\r\nuint8_t buf[] = { 0 };\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = buf,\r\n},\r\n{\r\n.addr = addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = buf,\r\n}\r\n};\r\nreturn i2c_transfer(&i2c->adapter, msgs, 2) == 2;\r\n}\r\nint\r\nnouveau_i2c_identify(struct drm_device *dev, const char *what,\r\nstruct i2c_board_info *info,\r\nbool (*match)(struct nouveau_i2c_chan *,\r\nstruct i2c_board_info *),\r\nint index)\r\n{\r\nstruct nouveau_i2c_chan *i2c = nouveau_i2c_find(dev, index);\r\nint i;\r\nNV_DEBUG(dev, "Probing %ss on I2C bus: %d\n", what, index);\r\nfor (i = 0; info[i].addr; i++) {\r\nif (nouveau_probe_i2c_addr(i2c, info[i].addr) &&\r\n(!match || match(i2c, &info[i]))) {\r\nNV_INFO(dev, "Detected %s: %s\n", what, info[i].type);\r\nreturn i;\r\n}\r\n}\r\nNV_DEBUG(dev, "No devices found.\n");\r\nreturn -ENODEV;\r\n}
