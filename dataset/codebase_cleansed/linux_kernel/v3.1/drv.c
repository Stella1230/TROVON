int pcbit_init_dev(int board, int mem_base, int irq)\r\n{\r\nstruct pcbit_dev *dev;\r\nisdn_if *dev_if;\r\nif ((dev=kzalloc(sizeof(struct pcbit_dev), GFP_KERNEL)) == NULL)\r\n{\r\nprintk("pcbit_init: couldn't malloc pcbit_dev struct\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_pcbit[board] = dev;\r\ninit_waitqueue_head(&dev->set_running_wq);\r\nspin_lock_init(&dev->lock);\r\nif (mem_base >= 0xA0000 && mem_base <= 0xFFFFF ) {\r\ndev->ph_mem = mem_base;\r\nif (!request_mem_region(dev->ph_mem, 4096, "PCBIT mem")) {\r\nprintk(KERN_WARNING\r\n"PCBIT: memory region %lx-%lx already in use\n",\r\ndev->ph_mem, dev->ph_mem + 4096);\r\nkfree(dev);\r\ndev_pcbit[board] = NULL;\r\nreturn -EACCES;\r\n}\r\ndev->sh_mem = ioremap(dev->ph_mem, 4096);\r\n}\r\nelse\r\n{\r\nprintk("memory address invalid");\r\nkfree(dev);\r\ndev_pcbit[board] = NULL;\r\nreturn -EACCES;\r\n}\r\ndev->b1 = kzalloc(sizeof(struct pcbit_chan), GFP_KERNEL);\r\nif (!dev->b1) {\r\nprintk("pcbit_init: couldn't malloc pcbit_chan struct\n");\r\niounmap(dev->sh_mem);\r\nrelease_mem_region(dev->ph_mem, 4096);\r\nkfree(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev->b2 = kzalloc(sizeof(struct pcbit_chan), GFP_KERNEL);\r\nif (!dev->b2) {\r\nprintk("pcbit_init: couldn't malloc pcbit_chan struct\n");\r\nkfree(dev->b1);\r\niounmap(dev->sh_mem);\r\nrelease_mem_region(dev->ph_mem, 4096);\r\nkfree(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev->b2->id = 1;\r\nINIT_WORK(&dev->qdelivery, pcbit_deliver);\r\nif (request_irq(irq, &pcbit_irq_handler, 0, pcbit_devname[board], dev) != 0)\r\n{\r\nkfree(dev->b1);\r\nkfree(dev->b2);\r\niounmap(dev->sh_mem);\r\nrelease_mem_region(dev->ph_mem, 4096);\r\nkfree(dev);\r\ndev_pcbit[board] = NULL;\r\nreturn -EIO;\r\n}\r\ndev->irq = irq;\r\ndev->rcv_seq = 0;\r\ndev->send_seq = 0;\r\ndev->unack_seq = 0;\r\ndev->hl_hdrlen = 16;\r\ndev_if = kmalloc(sizeof(isdn_if), GFP_KERNEL);\r\nif (!dev_if) {\r\nfree_irq(irq, dev);\r\nkfree(dev->b1);\r\nkfree(dev->b2);\r\niounmap(dev->sh_mem);\r\nrelease_mem_region(dev->ph_mem, 4096);\r\nkfree(dev);\r\ndev_pcbit[board] = NULL;\r\nreturn -EIO;\r\n}\r\ndev->dev_if = dev_if;\r\ndev_if->owner = THIS_MODULE;\r\ndev_if->channels = 2;\r\ndev_if->features = (ISDN_FEATURE_P_EURO | ISDN_FEATURE_L3_TRANS |\r\nISDN_FEATURE_L2_HDLC | ISDN_FEATURE_L2_TRANS );\r\ndev_if->writebuf_skb = pcbit_xmit;\r\ndev_if->hl_hdrlen = 16;\r\ndev_if->maxbufsize = MAXBUFSIZE;\r\ndev_if->command = pcbit_command;\r\ndev_if->writecmd = pcbit_writecmd;\r\ndev_if->readstat = pcbit_stat;\r\nstrcpy(dev_if->id, pcbit_devname[board]);\r\nif (!register_isdn(dev_if)) {\r\nfree_irq(irq, dev);\r\nkfree(dev->b1);\r\nkfree(dev->b2);\r\niounmap(dev->sh_mem);\r\nrelease_mem_region(dev->ph_mem, 4096);\r\nkfree(dev);\r\ndev_pcbit[board] = NULL;\r\nreturn -EIO;\r\n}\r\ndev->id = dev_if->channels;\r\ndev->l2_state = L2_DOWN;\r\ndev->free = 511;\r\nreturn 0;\r\n}\r\nvoid pcbit_terminate(int board)\r\n{\r\nstruct pcbit_dev * dev;\r\ndev = dev_pcbit[board];\r\nif (dev) {\r\nfree_irq(dev->irq, dev);\r\npcbit_clear_msn(dev);\r\nkfree(dev->dev_if);\r\nif (dev->b1->fsm_timer.function)\r\ndel_timer(&dev->b1->fsm_timer);\r\nif (dev->b2->fsm_timer.function)\r\ndel_timer(&dev->b2->fsm_timer);\r\nkfree(dev->b1);\r\nkfree(dev->b2);\r\niounmap(dev->sh_mem);\r\nrelease_mem_region(dev->ph_mem, 4096);\r\nkfree(dev);\r\n}\r\n}\r\nstatic int pcbit_command(isdn_ctrl* ctl)\r\n{\r\nstruct pcbit_dev *dev;\r\nstruct pcbit_chan *chan;\r\nstruct callb_data info;\r\ndev = finddev(ctl->driver);\r\nif (!dev)\r\n{\r\nprintk("pcbit_command: unknown device\n");\r\nreturn -1;\r\n}\r\nchan = (ctl->arg & 0x0F) ? dev->b2 : dev->b1;\r\nswitch(ctl->command) {\r\ncase ISDN_CMD_IOCTL:\r\nreturn pcbit_ioctl(ctl);\r\nbreak;\r\ncase ISDN_CMD_DIAL:\r\ninfo.type = EV_USR_SETUP_REQ;\r\ninfo.data.setup.CalledPN = (char *) &ctl->parm.setup.phone;\r\npcbit_fsm_event(dev, chan, EV_USR_SETUP_REQ, &info);\r\nbreak;\r\ncase ISDN_CMD_ACCEPTD:\r\npcbit_fsm_event(dev, chan, EV_USR_SETUP_RESP, NULL);\r\nbreak;\r\ncase ISDN_CMD_ACCEPTB:\r\nprintk("ISDN_CMD_ACCEPTB - not really needed\n");\r\nbreak;\r\ncase ISDN_CMD_HANGUP:\r\npcbit_fsm_event(dev, chan, EV_USR_RELEASE_REQ, NULL);\r\nbreak;\r\ncase ISDN_CMD_SETL2:\r\nchan->proto = (ctl->arg >> 8);\r\nbreak;\r\ncase ISDN_CMD_CLREAZ:\r\npcbit_clear_msn(dev);\r\nbreak;\r\ncase ISDN_CMD_SETEAZ:\r\npcbit_set_msn(dev, ctl->parm.num);\r\nbreak;\r\ncase ISDN_CMD_SETL3:\r\nif ((ctl->arg >> 8) != ISDN_PROTO_L3_TRANS)\r\nprintk(KERN_DEBUG "L3 protocol unknown\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "pcbit_command: unknown command\n");\r\nbreak;\r\n};\r\nreturn 0;\r\n}\r\nstatic void pcbit_block_timer(unsigned long data)\r\n{\r\nstruct pcbit_chan *chan;\r\nstruct pcbit_dev * dev;\r\nisdn_ctrl ictl;\r\nchan = (struct pcbit_chan *) data;\r\ndev = chan2dev(chan);\r\nif (dev == NULL) {\r\nprintk(KERN_DEBUG "pcbit: chan2dev failed\n");\r\nreturn;\r\n}\r\ndel_timer(&chan->block_timer);\r\nchan->block_timer.function = NULL;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "pcbit_block_timer\n");\r\n#endif\r\nchan->queued = 0;\r\nictl.driver = dev->id;\r\nictl.command = ISDN_STAT_BSENT;\r\nictl.arg = chan->id;\r\ndev->dev_if->statcallb(&ictl);\r\n}\r\nstatic int pcbit_xmit(int driver, int chnum, int ack, struct sk_buff *skb)\r\n{\r\nushort hdrlen;\r\nint refnum, len;\r\nstruct pcbit_chan * chan;\r\nstruct pcbit_dev *dev;\r\ndev = finddev(driver);\r\nif (dev == NULL)\r\n{\r\nprintk("finddev returned NULL");\r\nreturn -1;\r\n}\r\nchan = chnum ? dev->b2 : dev->b1;\r\nif (chan->fsm_state != ST_ACTIVE)\r\nreturn -1;\r\nif (chan->queued >= MAX_QUEUED )\r\n{\r\n#ifdef DEBUG_QUEUE\r\nprintk(KERN_DEBUG\r\n"pcbit: %d packets already in queue - write fails\n",\r\nchan->queued);\r\n#endif\r\n#ifdef BLOCK_TIMER\r\nif (chan->block_timer.function == NULL) {\r\ninit_timer(&chan->block_timer);\r\nchan->block_timer.function = &pcbit_block_timer;\r\nchan->block_timer.data = (long) chan;\r\nchan->block_timer.expires = jiffies + 1 * HZ;\r\nadd_timer(&chan->block_timer);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nchan->queued++;\r\nlen = skb->len;\r\nhdrlen = capi_tdata_req(chan, skb);\r\nrefnum = last_ref_num++ & 0x7fffU;\r\nchan->s_refnum = refnum;\r\npcbit_l2_write(dev, MSG_TDATA_REQ, refnum, skb, hdrlen);\r\nreturn len;\r\n}\r\nstatic int pcbit_writecmd(const u_char __user *buf, int len, int driver, int channel)\r\n{\r\nstruct pcbit_dev * dev;\r\nint i, j;\r\nconst u_char * loadbuf;\r\nu_char * ptr = NULL;\r\nu_char *cbuf;\r\nint errstat;\r\ndev = finddev(driver);\r\nif (!dev)\r\n{\r\nprintk("pcbit_writecmd: couldn't find device");\r\nreturn -ENODEV;\r\n}\r\nswitch(dev->l2_state) {\r\ncase L2_LWMODE:\r\nif (len < 0 || len > BANK4 + 1 || len > 1024)\r\n{\r\nprintk("pcbit_writecmd: invalid length %d\n", len);\r\nreturn -EINVAL;\r\n}\r\ncbuf = memdup_user(buf, len);\r\nif (IS_ERR(cbuf))\r\nreturn PTR_ERR(cbuf);\r\nmemcpy_toio(dev->sh_mem, cbuf, len);\r\nkfree(cbuf);\r\nreturn len;\r\ncase L2_FWMODE:\r\nif ((ptr = kmalloc(len, GFP_KERNEL))==NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(ptr, buf, len)) {\r\nkfree(ptr);\r\nreturn -EFAULT;\r\n}\r\nloadbuf = ptr;\r\nerrstat = 0;\r\nfor (i=0; i < len; i++)\r\n{\r\nfor(j=0; j < LOAD_RETRY; j++)\r\nif (!(readb(dev->sh_mem + dev->loadptr)))\r\nbreak;\r\nif (j == LOAD_RETRY)\r\n{\r\nerrstat = -ETIME;\r\nprintk("TIMEOUT i=%d\n", i);\r\nbreak;\r\n}\r\nwriteb(loadbuf[i], dev->sh_mem + dev->loadptr + 1);\r\nwriteb(0x01, dev->sh_mem + dev->loadptr);\r\ndev->loadptr += 2;\r\nif (dev->loadptr > LOAD_ZONE_END)\r\ndev->loadptr = LOAD_ZONE_START;\r\n}\r\nkfree(ptr);\r\nreturn errstat ? errstat : len;\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\n}\r\nvoid pcbit_l3_receive(struct pcbit_dev * dev, ulong msg,\r\nstruct sk_buff * skb,\r\nushort hdr_len, ushort refnum)\r\n{\r\nstruct pcbit_chan *chan;\r\nstruct sk_buff *skb2;\r\nunsigned short len;\r\nstruct callb_data cbdata;\r\nint complete, err;\r\nisdn_ctrl ictl;\r\nswitch(msg) {\r\ncase MSG_TDATA_IND:\r\nif (!(chan = capi_channel(dev, skb))) {\r\nprintk(KERN_WARNING\r\n"CAPI header: unknown channel id\n");\r\nbreak;\r\n}\r\nchan->r_refnum = skb->data[7];\r\nskb_pull(skb, 8);\r\ndev->dev_if->rcvcallb_skb(dev->id, chan->id, skb);\r\nif (capi_tdata_resp(chan, &skb2) > 0)\r\npcbit_l2_write(dev, MSG_TDATA_RESP, refnum,\r\nskb2, skb2->len);\r\nreturn;\r\nbreak;\r\ncase MSG_TDATA_CONF:\r\nif (!(chan = capi_channel(dev, skb))) {\r\nprintk(KERN_WARNING\r\n"CAPI header: unknown channel id\n");\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nif ( (*((ushort *) (skb->data + 2) )) != 0) {\r\nprintk(KERN_DEBUG "TDATA_CONF error\n");\r\n}\r\n#endif\r\n#ifdef BLOCK_TIMER\r\nif (chan->queued == MAX_QUEUED) {\r\ndel_timer(&chan->block_timer);\r\nchan->block_timer.function = NULL;\r\n}\r\n#endif\r\nchan->queued--;\r\nictl.driver = dev->id;\r\nictl.command = ISDN_STAT_BSENT;\r\nictl.arg = chan->id;\r\ndev->dev_if->statcallb(&ictl);\r\nbreak;\r\ncase MSG_CONN_IND:\r\nif (!dev->b1->fsm_state)\r\nchan = dev->b1;\r\nelse if (!dev->b2->fsm_state)\r\nchan = dev->b2;\r\nelse {\r\nprintk(KERN_INFO\r\n"Incoming connection: no channels available");\r\nif ((len = capi_disc_req(*(ushort*)(skb->data), &skb2, CAUSE_NOCHAN)) > 0)\r\npcbit_l2_write(dev, MSG_DISC_REQ, refnum, skb2, len);\r\nbreak;\r\n}\r\ncbdata.data.setup.CalledPN = NULL;\r\ncbdata.data.setup.CallingPN = NULL;\r\ncapi_decode_conn_ind(chan, skb, &cbdata);\r\ncbdata.type = EV_NET_SETUP;\r\npcbit_fsm_event(dev, chan, EV_NET_SETUP, NULL);\r\nif (pcbit_check_msn(dev, cbdata.data.setup.CallingPN))\r\npcbit_fsm_event(dev, chan, EV_USR_PROCED_REQ, &cbdata);\r\nelse\r\npcbit_fsm_event(dev, chan, EV_USR_RELEASE_REQ, NULL);\r\nkfree(cbdata.data.setup.CalledPN);\r\nkfree(cbdata.data.setup.CallingPN);\r\nbreak;\r\ncase MSG_CONN_CONF:\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "refnum=%04x b1=%04x b2=%04x\n", refnum,\r\ndev->b1->s_refnum,\r\ndev->b2->s_refnum);\r\n#endif\r\nif (dev->b1->fsm_state == ST_CALL_INIT)\r\nchan = dev->b1;\r\nelse {\r\nif (dev->b2->s_refnum == ST_CALL_INIT)\r\nchan = dev->b2;\r\nelse {\r\nchan = NULL;\r\nprintk(KERN_WARNING "Connection Confirm - no channel in Call Init state\n");\r\nbreak;\r\n}\r\n}\r\nif (capi_decode_conn_conf(chan, skb, &complete)) {\r\nprintk(KERN_DEBUG "conn_conf indicates error\n");\r\npcbit_fsm_event(dev, chan, EV_ERROR, NULL);\r\n}\r\nelse\r\nif (complete)\r\npcbit_fsm_event(dev, chan, EV_NET_CALL_PROC, NULL);\r\nelse\r\npcbit_fsm_event(dev, chan, EV_NET_SETUP_ACK, NULL);\r\nbreak;\r\ncase MSG_CONN_ACTV_IND:\r\nif (!(chan = capi_channel(dev, skb))) {\r\nprintk(KERN_WARNING\r\n"CAPI header: unknown channel id\n");\r\nbreak;\r\n}\r\nif (capi_decode_conn_actv_ind(chan, skb)) {\r\nprintk("error in capi_decode_conn_actv_ind\n");\r\nbreak;\r\n}\r\nchan->r_refnum = refnum;\r\npcbit_fsm_event(dev, chan, EV_NET_CONN, NULL);\r\nbreak;\r\ncase MSG_CONN_ACTV_CONF:\r\nif (!(chan = capi_channel(dev, skb))) {\r\nprintk(KERN_WARNING\r\n"CAPI header: unknown channel id\n");\r\nbreak;\r\n}\r\nif (capi_decode_conn_actv_conf(chan, skb) == 0)\r\npcbit_fsm_event(dev, chan, EV_NET_CONN_ACK, NULL);\r\nelse\r\nprintk(KERN_DEBUG "decode_conn_actv_conf failed\n");\r\nbreak;\r\ncase MSG_SELP_CONF:\r\nif (!(chan = capi_channel(dev, skb))) {\r\nprintk(KERN_WARNING\r\n"CAPI header: unknown channel id\n");\r\nbreak;\r\n}\r\nif (!(err = capi_decode_sel_proto_conf(chan, skb)))\r\npcbit_fsm_event(dev, chan, EV_NET_SELP_RESP, NULL);\r\nelse {\r\nprintk("error %d - capi_decode_sel_proto_conf\n", err);\r\n}\r\nbreak;\r\ncase MSG_ACT_TRANSP_CONF:\r\nif (!(chan = capi_channel(dev, skb))) {\r\nprintk(KERN_WARNING\r\n"CAPI header: unknown channel id\n");\r\nbreak;\r\n}\r\nif (!capi_decode_actv_trans_conf(chan, skb))\r\npcbit_fsm_event(dev, chan, EV_NET_ACTV_RESP, NULL);\r\nbreak;\r\ncase MSG_DISC_IND:\r\nif (!(chan = capi_channel(dev, skb))) {\r\nprintk(KERN_WARNING\r\n"CAPI header: unknown channel id\n");\r\nbreak;\r\n}\r\nif (!capi_decode_disc_ind(chan, skb))\r\npcbit_fsm_event(dev, chan, EV_NET_DISC, NULL);\r\nelse\r\nprintk(KERN_WARNING "capi_decode_disc_ind - error\n");\r\nbreak;\r\ncase MSG_DISC_CONF:\r\nif (!(chan = capi_channel(dev, skb))) {\r\nprintk(KERN_WARNING\r\n"CAPI header: unknown channel id\n");\r\nbreak;\r\n}\r\nif (!capi_decode_disc_ind(chan, skb))\r\npcbit_fsm_event(dev, chan, EV_NET_RELEASE, NULL);\r\nelse\r\nprintk(KERN_WARNING "capi_decode_disc_conf - error\n");\r\nbreak;\r\ncase MSG_INFO_IND:\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "received Info Indication - discarded\n");\r\n#endif\r\nbreak;\r\n#ifdef DEBUG\r\ncase MSG_DEBUG_188:\r\ncapi_decode_debug_188(skb->data, skb->len);\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "pcbit_l3_receive: unknown message %08lx\n",\r\nmsg);\r\nbreak;\r\n#endif\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic int pcbit_stat(u_char __user *buf, int len, int driver, int channel)\r\n{\r\nint stat_count;\r\nstat_count = stat_end - stat_st;\r\nif (stat_count < 0)\r\nstat_count = STATBUF_LEN - stat_st + stat_end;\r\nif (len > stat_count)\r\nlen = stat_count;\r\nif (stat_st < stat_end)\r\n{\r\nif (copy_to_user(buf, statbuf + stat_st, len))\r\nreturn -EFAULT;\r\nstat_st += len;\r\n}\r\nelse\r\n{\r\nif (len > STATBUF_LEN - stat_st)\r\n{\r\nif (copy_to_user(buf, statbuf + stat_st,\r\nSTATBUF_LEN - stat_st))\r\nreturn -EFAULT;\r\nif (copy_to_user(buf, statbuf,\r\nlen - (STATBUF_LEN - stat_st)))\r\nreturn -EFAULT;\r\nstat_st = len - (STATBUF_LEN - stat_st);\r\n}\r\nelse\r\n{\r\nif (copy_to_user(buf, statbuf + stat_st, len))\r\nreturn -EFAULT;\r\nstat_st += len;\r\nif (stat_st == STATBUF_LEN)\r\nstat_st = 0;\r\n}\r\n}\r\nif (stat_st == stat_end)\r\nstat_st = stat_end = 0;\r\nreturn len;\r\n}\r\nstatic void pcbit_logstat(struct pcbit_dev *dev, char *str)\r\n{\r\nint i;\r\nisdn_ctrl ictl;\r\nfor (i=stat_end; i<strlen(str); i++)\r\n{\r\nstatbuf[i]=str[i];\r\nstat_end = (stat_end + 1) % STATBUF_LEN;\r\nif (stat_end == stat_st)\r\nstat_st = (stat_st + 1) % STATBUF_LEN;\r\n}\r\nictl.command=ISDN_STAT_STAVAIL;\r\nictl.driver=dev->id;\r\nictl.arg=strlen(str);\r\ndev->dev_if->statcallb(&ictl);\r\n}\r\nvoid pcbit_state_change(struct pcbit_dev * dev, struct pcbit_chan * chan,\r\nunsigned short i, unsigned short ev, unsigned short f)\r\n{\r\nchar buf[256];\r\nsprintf(buf, "change on device: %d channel:%d\n%s -> %s -> %s\n",\r\ndev->id, chan->id,\r\nisdn_state_table[i], strisdnevent(ev), isdn_state_table[f]\r\n);\r\n#ifdef DEBUG\r\nprintk("%s", buf);\r\n#endif\r\npcbit_logstat(dev, buf);\r\n}\r\nstatic void set_running_timeout(unsigned long ptr)\r\n{\r\nstruct pcbit_dev * dev;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "set_running_timeout\n");\r\n#endif\r\ndev = (struct pcbit_dev *) ptr;\r\nwake_up_interruptible(&dev->set_running_wq);\r\n}\r\nstatic int set_protocol_running(struct pcbit_dev * dev)\r\n{\r\nisdn_ctrl ctl;\r\ninit_timer(&dev->set_running_timer);\r\ndev->set_running_timer.function = &set_running_timeout;\r\ndev->set_running_timer.data = (ulong) dev;\r\ndev->set_running_timer.expires = jiffies + SET_RUN_TIMEOUT;\r\ndev->l2_state = L2_STARTING;\r\nwriteb((0x80U | ((dev->rcv_seq & 0x07) << 3) | (dev->send_seq & 0x07)),\r\ndev->sh_mem + BANK4);\r\nadd_timer(&dev->set_running_timer);\r\ninterruptible_sleep_on(&dev->set_running_wq);\r\ndel_timer(&dev->set_running_timer);\r\nif (dev->l2_state == L2_RUNNING)\r\n{\r\nprintk(KERN_DEBUG "pcbit: running\n");\r\ndev->unack_seq = dev->send_seq;\r\ndev->writeptr = dev->sh_mem;\r\ndev->readptr = dev->sh_mem + BANK2;\r\nctl.driver = dev->id;\r\nctl.command = ISDN_STAT_RUN;\r\ndev->dev_if->statcallb(&ctl);\r\n}\r\nelse\r\n{\r\nprintk(KERN_DEBUG "pcbit: initialization failed\n");\r\nprintk(KERN_DEBUG "pcbit: firmware not loaded\n");\r\ndev->l2_state = L2_DOWN;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "Bank3 = %02x\n",\r\nreadb(dev->sh_mem + BANK3));\r\n#endif\r\nwriteb(0x40, dev->sh_mem + BANK4);\r\nctl.driver = dev->id;\r\nctl.command = ISDN_STAT_STOP;\r\ndev->dev_if->statcallb(&ctl);\r\nreturn -EL2HLT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcbit_ioctl(isdn_ctrl* ctl)\r\n{\r\nstruct pcbit_dev * dev;\r\nstruct pcbit_ioctl *cmd;\r\ndev = finddev(ctl->driver);\r\nif (!dev)\r\n{\r\nprintk(KERN_DEBUG "pcbit_ioctl: unknown device\n");\r\nreturn -ENODEV;\r\n}\r\ncmd = (struct pcbit_ioctl *) ctl->parm.num;\r\nswitch(ctl->arg) {\r\ncase PCBIT_IOCTL_GETSTAT:\r\ncmd->info.l2_status = dev->l2_state;\r\nbreak;\r\ncase PCBIT_IOCTL_STRLOAD:\r\nif (dev->l2_state == L2_RUNNING)\r\nreturn -EBUSY;\r\ndev->unack_seq = dev->send_seq = dev->rcv_seq = 0;\r\ndev->writeptr = dev->sh_mem;\r\ndev->readptr = dev->sh_mem + BANK2;\r\ndev->l2_state = L2_LOADING;\r\nbreak;\r\ncase PCBIT_IOCTL_LWMODE:\r\nif (dev->l2_state != L2_LOADING)\r\nreturn -EINVAL;\r\ndev->l2_state = L2_LWMODE;\r\nbreak;\r\ncase PCBIT_IOCTL_FWMODE:\r\nif (dev->l2_state == L2_RUNNING)\r\nreturn -EBUSY;\r\ndev->loadptr = LOAD_ZONE_START;\r\ndev->l2_state = L2_FWMODE;\r\nbreak;\r\ncase PCBIT_IOCTL_ENDLOAD:\r\nif (dev->l2_state == L2_RUNNING)\r\nreturn -EBUSY;\r\ndev->l2_state = L2_DOWN;\r\nbreak;\r\ncase PCBIT_IOCTL_SETBYTE:\r\nif (dev->l2_state == L2_RUNNING)\r\nreturn -EBUSY;\r\nif (cmd->info.rdp_byte.addr > BANK4)\r\nreturn -EFAULT;\r\nwriteb(cmd->info.rdp_byte.value, dev->sh_mem + cmd->info.rdp_byte.addr);\r\nbreak;\r\ncase PCBIT_IOCTL_GETBYTE:\r\nif (dev->l2_state == L2_RUNNING)\r\nreturn -EBUSY;\r\nif (cmd->info.rdp_byte.addr > BANK4)\r\n{\r\nprintk("getbyte: invalid addr %04x\n", cmd->info.rdp_byte.addr);\r\nreturn -EFAULT;\r\n}\r\ncmd->info.rdp_byte.value = readb(dev->sh_mem + cmd->info.rdp_byte.addr);\r\nbreak;\r\ncase PCBIT_IOCTL_RUNNING:\r\nif (dev->l2_state == L2_RUNNING)\r\nreturn -EBUSY;\r\nreturn set_protocol_running(dev);\r\nbreak;\r\ncase PCBIT_IOCTL_WATCH188:\r\nif (dev->l2_state != L2_LOADING)\r\nreturn -EINVAL;\r\npcbit_l2_write(dev, MSG_WATCH188, 0x0001, NULL, 0);\r\nbreak;\r\ncase PCBIT_IOCTL_PING188:\r\nif (dev->l2_state != L2_LOADING)\r\nreturn -EINVAL;\r\npcbit_l2_write(dev, MSG_PING188_REQ, 0x0001, NULL, 0);\r\nbreak;\r\ncase PCBIT_IOCTL_APION:\r\nif (dev->l2_state != L2_LOADING)\r\nreturn -EINVAL;\r\npcbit_l2_write(dev, MSG_API_ON, 0x0001, NULL, 0);\r\nbreak;\r\ncase PCBIT_IOCTL_STOP:\r\ndev->l2_state = L2_DOWN;\r\nwriteb(0x40, dev->sh_mem + BANK4);\r\ndev->rcv_seq = 0;\r\ndev->send_seq = 0;\r\ndev->unack_seq = 0;\r\nbreak;\r\ndefault:\r\nprintk("error: unknown ioctl\n");\r\nbreak;\r\n};\r\nreturn 0;\r\n}\r\nstatic void pcbit_clear_msn(struct pcbit_dev *dev)\r\n{\r\nstruct msn_entry *ptr, *back;\r\nfor (ptr=dev->msn_list; ptr; )\r\n{\r\nback = ptr->next;\r\nkfree(ptr);\r\nptr = back;\r\n}\r\ndev->msn_list = NULL;\r\n}\r\nstatic void pcbit_set_msn(struct pcbit_dev *dev, char *list)\r\n{\r\nstruct msn_entry *ptr;\r\nstruct msn_entry *back = NULL;\r\nchar *cp, *sp;\r\nint len;\r\nif (strlen(list) == 0) {\r\nptr = kmalloc(sizeof(struct msn_entry), GFP_ATOMIC);\r\nif (!ptr) {\r\nprintk(KERN_WARNING "kmalloc failed\n");\r\nreturn;\r\n}\r\nptr->msn = NULL;\r\nptr->next = dev->msn_list;\r\ndev->msn_list = ptr;\r\nreturn;\r\n}\r\nif (dev->msn_list)\r\nfor (back=dev->msn_list; back->next; back=back->next);\r\nsp = list;\r\ndo {\r\ncp=strchr(sp, ',');\r\nif (cp)\r\nlen = cp - sp;\r\nelse\r\nlen = strlen(sp);\r\nptr = kmalloc(sizeof(struct msn_entry), GFP_ATOMIC);\r\nif (!ptr) {\r\nprintk(KERN_WARNING "kmalloc failed\n");\r\nreturn;\r\n}\r\nptr->next = NULL;\r\nptr->msn = kmalloc(len, GFP_ATOMIC);\r\nif (!ptr->msn) {\r\nprintk(KERN_WARNING "kmalloc failed\n");\r\nkfree(ptr);\r\nreturn;\r\n}\r\nmemcpy(ptr->msn, sp, len - 1);\r\nptr->msn[len] = 0;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "msn: %s\n", ptr->msn);\r\n#endif\r\nif (dev->msn_list == NULL)\r\ndev->msn_list = ptr;\r\nelse\r\nback->next = ptr;\r\nback = ptr;\r\nsp += len;\r\n} while(cp);\r\n}\r\nstatic int pcbit_check_msn(struct pcbit_dev *dev, char *msn)\r\n{\r\nstruct msn_entry *ptr;\r\nfor (ptr=dev->msn_list; ptr; ptr=ptr->next) {\r\nif (ptr->msn == NULL)\r\nreturn 1;\r\nif (strcmp(ptr->msn, msn) == 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
