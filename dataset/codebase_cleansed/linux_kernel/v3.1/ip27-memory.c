static int is_fine_dirmode(void)\r\n{\r\nreturn (((LOCAL_HUB_L(NI_STATUS_REV_ID) & NSRI_REGIONSIZE_MASK)\r\n>> NSRI_REGIONSIZE_SHFT) & REGIONSIZE_FINE);\r\n}\r\nstatic hubreg_t get_region(cnodeid_t cnode)\r\n{\r\nif (fine_mode)\r\nreturn COMPACT_TO_NASID_NODEID(cnode) >> NASID_TO_FINEREG_SHFT;\r\nelse\r\nreturn COMPACT_TO_NASID_NODEID(cnode) >> NASID_TO_COARSEREG_SHFT;\r\n}\r\nstatic void gen_region_mask(hubreg_t *region_mask)\r\n{\r\ncnodeid_t cnode;\r\n(*region_mask) = 0;\r\nfor_each_online_node(cnode) {\r\n(*region_mask) |= 1ULL << get_region(cnode);\r\n}\r\n}\r\nstatic void router_recurse(klrou_t *router_a, klrou_t *router_b, int depth)\r\n{\r\nklrou_t *router;\r\nlboard_t *brd;\r\nint port;\r\nif (router_a->rou_rflag == 1)\r\nreturn;\r\nif (depth >= router_distance)\r\nreturn;\r\nrouter_a->rou_rflag = 1;\r\nfor (port = 1; port <= MAX_ROUTER_PORTS; port++) {\r\nif (router_a->rou_port[port].port_nasid == INVALID_NASID)\r\ncontinue;\r\nbrd = (lboard_t *)NODE_OFFSET_TO_K0(\r\nrouter_a->rou_port[port].port_nasid,\r\nrouter_a->rou_port[port].port_offset);\r\nif (brd->brd_type == KLTYPE_ROUTER) {\r\nrouter = (klrou_t *)NODE_OFFSET_TO_K0(NASID_GET(brd), brd->brd_compts[0]);\r\nif (router == router_b) {\r\nif (depth < router_distance)\r\nrouter_distance = depth;\r\n}\r\nelse\r\nrouter_recurse(router, router_b, depth + 1);\r\n}\r\n}\r\nrouter_a->rou_rflag = 0;\r\n}\r\nstatic int __init compute_node_distance(nasid_t nasid_a, nasid_t nasid_b)\r\n{\r\nklrou_t *router, *router_a = NULL, *router_b = NULL;\r\nlboard_t *brd, *dest_brd;\r\ncnodeid_t cnode;\r\nnasid_t nasid;\r\nint port;\r\nfor_each_online_node(cnode) {\r\nnasid = COMPACT_TO_NASID_NODEID(cnode);\r\nif (nasid == -1) continue;\r\nbrd = find_lboard_class((lboard_t *)KL_CONFIG_INFO(nasid),\r\nKLTYPE_ROUTER);\r\nif (!brd)\r\ncontinue;\r\ndo {\r\nif (brd->brd_flags & DUPLICATE_BOARD)\r\ncontinue;\r\nrouter = (klrou_t *)NODE_OFFSET_TO_K0(NASID_GET(brd), brd->brd_compts[0]);\r\nrouter->rou_rflag = 0;\r\nfor (port = 1; port <= MAX_ROUTER_PORTS; port++) {\r\nif (router->rou_port[port].port_nasid == INVALID_NASID)\r\ncontinue;\r\ndest_brd = (lboard_t *)NODE_OFFSET_TO_K0(\r\nrouter->rou_port[port].port_nasid,\r\nrouter->rou_port[port].port_offset);\r\nif (dest_brd->brd_type == KLTYPE_IP27) {\r\nif (dest_brd->brd_nasid == nasid_a)\r\nrouter_a = router;\r\nif (dest_brd->brd_nasid == nasid_b)\r\nrouter_b = router;\r\n}\r\n}\r\n} while ((brd = find_lboard_class(KLCF_NEXT(brd), KLTYPE_ROUTER)));\r\n}\r\nif (router_a == NULL) {\r\nprintk("node_distance: router_a NULL\n");\r\nreturn -1;\r\n}\r\nif (router_b == NULL) {\r\nprintk("node_distance: router_b NULL\n");\r\nreturn -1;\r\n}\r\nif (nasid_a == nasid_b)\r\nreturn 0;\r\nif (router_a == router_b)\r\nreturn 1;\r\nrouter_distance = 100;\r\nrouter_recurse(router_a, router_b, 2);\r\nreturn router_distance;\r\n}\r\nstatic void __init init_topology_matrix(void)\r\n{\r\nnasid_t nasid, nasid2;\r\ncnodeid_t row, col;\r\nfor (row = 0; row < MAX_COMPACT_NODES; row++)\r\nfor (col = 0; col < MAX_COMPACT_NODES; col++)\r\n__node_distances[row][col] = -1;\r\nfor_each_online_node(row) {\r\nnasid = COMPACT_TO_NASID_NODEID(row);\r\nfor_each_online_node(col) {\r\nnasid2 = COMPACT_TO_NASID_NODEID(col);\r\n__node_distances[row][col] =\r\ncompute_node_distance(nasid, nasid2);\r\n}\r\n}\r\n}\r\nstatic void __init dump_topology(void)\r\n{\r\nnasid_t nasid;\r\ncnodeid_t cnode;\r\nlboard_t *brd, *dest_brd;\r\nint port;\r\nint router_num = 0;\r\nklrou_t *router;\r\ncnodeid_t row, col;\r\nprintk("************** Topology ********************\n");\r\nprintk(" ");\r\nfor_each_online_node(col)\r\nprintk("%02d ", col);\r\nprintk("\n");\r\nfor_each_online_node(row) {\r\nprintk("%02d ", row);\r\nfor_each_online_node(col)\r\nprintk("%2d ", node_distance(row, col));\r\nprintk("\n");\r\n}\r\nfor_each_online_node(cnode) {\r\nnasid = COMPACT_TO_NASID_NODEID(cnode);\r\nif (nasid == -1) continue;\r\nbrd = find_lboard_class((lboard_t *)KL_CONFIG_INFO(nasid),\r\nKLTYPE_ROUTER);\r\nif (!brd)\r\ncontinue;\r\ndo {\r\nif (brd->brd_flags & DUPLICATE_BOARD)\r\ncontinue;\r\nprintk("Router %d:", router_num);\r\nrouter_num++;\r\nrouter = (klrou_t *)NODE_OFFSET_TO_K0(NASID_GET(brd), brd->brd_compts[0]);\r\nfor (port = 1; port <= MAX_ROUTER_PORTS; port++) {\r\nif (router->rou_port[port].port_nasid == INVALID_NASID)\r\ncontinue;\r\ndest_brd = (lboard_t *)NODE_OFFSET_TO_K0(\r\nrouter->rou_port[port].port_nasid,\r\nrouter->rou_port[port].port_offset);\r\nif (dest_brd->brd_type == KLTYPE_IP27)\r\nprintk(" %d", dest_brd->brd_nasid);\r\nif (dest_brd->brd_type == KLTYPE_ROUTER)\r\nprintk(" r");\r\n}\r\nprintk("\n");\r\n} while ( (brd = find_lboard_class(KLCF_NEXT(brd), KLTYPE_ROUTER)) );\r\n}\r\n}\r\nstatic pfn_t __init slot_getbasepfn(cnodeid_t cnode, int slot)\r\n{\r\nnasid_t nasid = COMPACT_TO_NASID_NODEID(cnode);\r\nreturn ((pfn_t)nasid << PFN_NASIDSHFT) | (slot << SLOT_PFNSHIFT);\r\n}\r\nstatic pfn_t __init slot_psize_compute(cnodeid_t node, int slot)\r\n{\r\nnasid_t nasid;\r\nlboard_t *brd;\r\nklmembnk_t *banks;\r\nunsigned long size;\r\nnasid = COMPACT_TO_NASID_NODEID(node);\r\nbrd = find_lboard((lboard_t *)KL_CONFIG_INFO(nasid), KLTYPE_IP27);\r\nif (!brd)\r\nreturn 0;\r\nbanks = (klmembnk_t *) find_first_component(brd, KLSTRUCT_MEMBNK);\r\nif (!banks)\r\nreturn 0;\r\nsize = (unsigned long)banks->membnk_bnksz[slot/4];\r\nif (size <= 128) {\r\nif (slot % 4 == 0) {\r\nsize <<= 20;\r\nreturn(size >> PAGE_SHIFT);\r\n} else\r\nreturn 0;\r\n} else {\r\nsize /= 4;\r\nsize <<= 20;\r\nreturn size >> PAGE_SHIFT;\r\n}\r\n}\r\nstatic void __init mlreset(void)\r\n{\r\nint i;\r\nmaster_nasid = get_nasid();\r\nfine_mode = is_fine_dirmode();\r\n#ifdef CONFIG_SMP\r\ncpu_node_probe();\r\n#endif\r\ninit_topology_matrix();\r\ndump_topology();\r\ngen_region_mask(&region_mask);\r\nsetup_replication_mask();\r\nfor_each_online_node(i) {\r\nnasid_t nasid;\r\nnasid = COMPACT_TO_NASID_NODEID(i);\r\nREMOTE_HUB_S(nasid, PI_REGION_PRESENT, (region_mask | 1));\r\n#ifdef CONFIG_REPLICATE_EXHANDLERS\r\nREMOTE_HUB_S(nasid, PI_CALIAS_SIZE, PI_CALIAS_SIZE_8K);\r\n#else\r\nREMOTE_HUB_S(nasid, PI_CALIAS_SIZE, PI_CALIAS_SIZE_0);\r\n#endif\r\n#ifdef LATER\r\nREMOTE_HUB_S(nasid, IIO_ITTE(SWIN0_BIGWIN),\r\n((HUB_PIO_MAP_TO_MEM << IIO_ITTE_IOSP_SHIFT) |\r\n(0 << IIO_ITTE_WIDGET_SHIFT)));\r\n#endif\r\n}\r\n}\r\nstatic void __init szmem(void)\r\n{\r\npfn_t slot_psize, slot0sz = 0, nodebytes;\r\nint slot;\r\ncnodeid_t node;\r\nnum_physpages = 0;\r\nfor_each_online_node(node) {\r\nnodebytes = 0;\r\nfor (slot = 0; slot < MAX_MEM_SLOTS; slot++) {\r\nslot_psize = slot_psize_compute(node, slot);\r\nif (slot == 0)\r\nslot0sz = slot_psize;\r\nnodebytes += (1LL << SLOT_SHIFT);\r\nif (!slot_psize)\r\ncontinue;\r\nif ((nodebytes >> PAGE_SHIFT) * (sizeof(struct page)) >\r\n(slot0sz << PAGE_SHIFT)) {\r\nprintk("Ignoring slot %d onwards on node %d\n",\r\nslot, node);\r\nslot = MAX_MEM_SLOTS;\r\ncontinue;\r\n}\r\nnum_physpages += slot_psize;\r\nadd_active_range(node, slot_getbasepfn(node, slot),\r\nslot_getbasepfn(node, slot) + slot_psize);\r\n}\r\n}\r\n}\r\nstatic void __init node_mem_init(cnodeid_t node)\r\n{\r\npfn_t slot_firstpfn = slot_getbasepfn(node, 0);\r\npfn_t slot_freepfn = node_getfirstfree(node);\r\nunsigned long bootmap_size;\r\npfn_t start_pfn, end_pfn;\r\nget_pfn_range_for_nid(node, &start_pfn, &end_pfn);\r\n__node_data[node] = __va(slot_freepfn << PAGE_SHIFT);\r\nNODE_DATA(node)->bdata = &bootmem_node_data[node];\r\nNODE_DATA(node)->node_start_pfn = start_pfn;\r\nNODE_DATA(node)->node_spanned_pages = end_pfn - start_pfn;\r\ncpus_clear(hub_data(node)->h_cpus);\r\nslot_freepfn += PFN_UP(sizeof(struct pglist_data) +\r\nsizeof(struct hub_data));\r\nbootmap_size = init_bootmem_node(NODE_DATA(node), slot_freepfn,\r\nstart_pfn, end_pfn);\r\nfree_bootmem_with_active_regions(node, end_pfn);\r\nreserve_bootmem_node(NODE_DATA(node), slot_firstpfn << PAGE_SHIFT,\r\n((slot_freepfn - slot_firstpfn) << PAGE_SHIFT) + bootmap_size,\r\nBOOTMEM_DEFAULT);\r\nsparse_memory_present_with_active_regions(node);\r\n}\r\nvoid __init prom_meminit(void)\r\n{\r\ncnodeid_t node;\r\nmlreset();\r\nszmem();\r\nfor (node = 0; node < MAX_COMPACT_NODES; node++) {\r\nif (node_online(node)) {\r\nnode_mem_init(node);\r\ncontinue;\r\n}\r\n__node_data[node] = &null_node;\r\n}\r\n}\r\nvoid __init prom_free_prom_memory(void)\r\n{\r\n}\r\nvoid __init paging_init(void)\r\n{\r\nunsigned long zones_size[MAX_NR_ZONES] = {0, };\r\nunsigned node;\r\npagetable_init();\r\nfor_each_online_node(node) {\r\npfn_t start_pfn, end_pfn;\r\nget_pfn_range_for_nid(node, &start_pfn, &end_pfn);\r\nif (end_pfn > max_low_pfn)\r\nmax_low_pfn = end_pfn;\r\n}\r\nzones_size[ZONE_NORMAL] = max_low_pfn;\r\nfree_area_init_nodes(zones_size);\r\n}\r\nvoid __init mem_init(void)\r\n{\r\nunsigned long codesize, datasize, initsize, tmp;\r\nunsigned node;\r\nhigh_memory = (void *) __va(num_physpages << PAGE_SHIFT);\r\nfor_each_online_node(node) {\r\ntotalram_pages += free_all_bootmem_node(NODE_DATA(node));\r\n}\r\ntotalram_pages -= setup_zero_pages();\r\ncodesize = (unsigned long) &_etext - (unsigned long) &_text;\r\ndatasize = (unsigned long) &_edata - (unsigned long) &_etext;\r\ninitsize = (unsigned long) &__init_end - (unsigned long) &__init_begin;\r\ntmp = nr_free_pages();\r\nprintk(KERN_INFO "Memory: %luk/%luk available (%ldk kernel code, "\r\n"%ldk reserved, %ldk data, %ldk init, %ldk highmem)\n",\r\ntmp << (PAGE_SHIFT-10),\r\nnum_physpages << (PAGE_SHIFT-10),\r\ncodesize >> 10,\r\n(num_physpages - tmp) << (PAGE_SHIFT-10),\r\ndatasize >> 10,\r\ninitsize >> 10,\r\ntotalhigh_pages << (PAGE_SHIFT-10));\r\n}
