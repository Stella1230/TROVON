static void flush_ldt(void *current_mm)\r\n{\r\nif (current->active_mm == current_mm)\r\nload_LDT(&current->active_mm->context);\r\n}\r\nstatic int alloc_ldt(mm_context_t *pc, int mincount, int reload)\r\n{\r\nvoid *oldldt, *newldt;\r\nint oldsize;\r\nif (mincount <= pc->size)\r\nreturn 0;\r\noldsize = pc->size;\r\nmincount = (mincount + (PAGE_SIZE / LDT_ENTRY_SIZE - 1)) &\r\n(~(PAGE_SIZE / LDT_ENTRY_SIZE - 1));\r\nif (mincount * LDT_ENTRY_SIZE > PAGE_SIZE)\r\nnewldt = vmalloc(mincount * LDT_ENTRY_SIZE);\r\nelse\r\nnewldt = (void *)__get_free_page(GFP_KERNEL);\r\nif (!newldt)\r\nreturn -ENOMEM;\r\nif (oldsize)\r\nmemcpy(newldt, pc->ldt, oldsize * LDT_ENTRY_SIZE);\r\noldldt = pc->ldt;\r\nmemset(newldt + oldsize * LDT_ENTRY_SIZE, 0,\r\n(mincount - oldsize) * LDT_ENTRY_SIZE);\r\nparavirt_alloc_ldt(newldt, mincount);\r\n#ifdef CONFIG_X86_64\r\nwmb();\r\n#endif\r\npc->ldt = newldt;\r\nwmb();\r\npc->size = mincount;\r\nwmb();\r\nif (reload) {\r\n#ifdef CONFIG_SMP\r\npreempt_disable();\r\nload_LDT(pc);\r\nif (!cpumask_equal(mm_cpumask(current->mm),\r\ncpumask_of(smp_processor_id())))\r\nsmp_call_function(flush_ldt, current->mm, 1);\r\npreempt_enable();\r\n#else\r\nload_LDT(pc);\r\n#endif\r\n}\r\nif (oldsize) {\r\nparavirt_free_ldt(oldldt, oldsize);\r\nif (oldsize * LDT_ENTRY_SIZE > PAGE_SIZE)\r\nvfree(oldldt);\r\nelse\r\nput_page(virt_to_page(oldldt));\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int copy_ldt(mm_context_t *new, mm_context_t *old)\r\n{\r\nint err = alloc_ldt(new, old->size, 0);\r\nint i;\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < old->size; i++)\r\nwrite_ldt_entry(new->ldt, i, old->ldt + i * LDT_ENTRY_SIZE);\r\nreturn 0;\r\n}\r\nint init_new_context(struct task_struct *tsk, struct mm_struct *mm)\r\n{\r\nstruct mm_struct *old_mm;\r\nint retval = 0;\r\nmutex_init(&mm->context.lock);\r\nmm->context.size = 0;\r\nold_mm = current->mm;\r\nif (old_mm && old_mm->context.size > 0) {\r\nmutex_lock(&old_mm->context.lock);\r\nretval = copy_ldt(&mm->context, &old_mm->context);\r\nmutex_unlock(&old_mm->context.lock);\r\n}\r\nreturn retval;\r\n}\r\nvoid destroy_context(struct mm_struct *mm)\r\n{\r\nif (mm->context.size) {\r\n#ifdef CONFIG_X86_32\r\nif (mm == current->active_mm)\r\nclear_LDT();\r\n#endif\r\nparavirt_free_ldt(mm->context.ldt, mm->context.size);\r\nif (mm->context.size * LDT_ENTRY_SIZE > PAGE_SIZE)\r\nvfree(mm->context.ldt);\r\nelse\r\nput_page(virt_to_page(mm->context.ldt));\r\nmm->context.size = 0;\r\n}\r\n}\r\nstatic int read_ldt(void __user *ptr, unsigned long bytecount)\r\n{\r\nint err;\r\nunsigned long size;\r\nstruct mm_struct *mm = current->mm;\r\nif (!mm->context.size)\r\nreturn 0;\r\nif (bytecount > LDT_ENTRY_SIZE * LDT_ENTRIES)\r\nbytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;\r\nmutex_lock(&mm->context.lock);\r\nsize = mm->context.size * LDT_ENTRY_SIZE;\r\nif (size > bytecount)\r\nsize = bytecount;\r\nerr = 0;\r\nif (copy_to_user(ptr, mm->context.ldt, size))\r\nerr = -EFAULT;\r\nmutex_unlock(&mm->context.lock);\r\nif (err < 0)\r\ngoto error_return;\r\nif (size != bytecount) {\r\nif (clear_user(ptr + size, bytecount - size) != 0) {\r\nerr = -EFAULT;\r\ngoto error_return;\r\n}\r\n}\r\nreturn bytecount;\r\nerror_return:\r\nreturn err;\r\n}\r\nstatic int read_default_ldt(void __user *ptr, unsigned long bytecount)\r\n{\r\n#ifdef CONFIG_X86_32\r\nunsigned long size = 5 * sizeof(struct desc_struct);\r\n#else\r\nunsigned long size = 128;\r\n#endif\r\nif (bytecount > size)\r\nbytecount = size;\r\nif (clear_user(ptr, bytecount))\r\nreturn -EFAULT;\r\nreturn bytecount;\r\n}\r\nstatic int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct desc_struct ldt;\r\nint error;\r\nstruct user_desc ldt_info;\r\nerror = -EINVAL;\r\nif (bytecount != sizeof(ldt_info))\r\ngoto out;\r\nerror = -EFAULT;\r\nif (copy_from_user(&ldt_info, ptr, sizeof(ldt_info)))\r\ngoto out;\r\nerror = -EINVAL;\r\nif (ldt_info.entry_number >= LDT_ENTRIES)\r\ngoto out;\r\nif (ldt_info.contents == 3) {\r\nif (oldmode)\r\ngoto out;\r\nif (ldt_info.seg_not_present == 0)\r\ngoto out;\r\n}\r\nmutex_lock(&mm->context.lock);\r\nif (ldt_info.entry_number >= mm->context.size) {\r\nerror = alloc_ldt(&current->mm->context,\r\nldt_info.entry_number + 1, 1);\r\nif (error < 0)\r\ngoto out_unlock;\r\n}\r\nif (ldt_info.base_addr == 0 && ldt_info.limit == 0) {\r\nif (oldmode || LDT_empty(&ldt_info)) {\r\nmemset(&ldt, 0, sizeof(ldt));\r\ngoto install;\r\n}\r\n}\r\nfill_ldt(&ldt, &ldt_info);\r\nif (oldmode)\r\nldt.avl = 0;\r\ninstall:\r\nwrite_ldt_entry(mm->context.ldt, ldt_info.entry_number, &ldt);\r\nerror = 0;\r\nout_unlock:\r\nmutex_unlock(&mm->context.lock);\r\nout:\r\nreturn error;\r\n}\r\nasmlinkage int sys_modify_ldt(int func, void __user *ptr,\r\nunsigned long bytecount)\r\n{\r\nint ret = -ENOSYS;\r\nswitch (func) {\r\ncase 0:\r\nret = read_ldt(ptr, bytecount);\r\nbreak;\r\ncase 1:\r\nret = write_ldt(ptr, bytecount, 1);\r\nbreak;\r\ncase 2:\r\nret = read_default_ldt(ptr, bytecount);\r\nbreak;\r\ncase 0x11:\r\nret = write_ldt(ptr, bytecount, 0);\r\nbreak;\r\n}\r\nreturn ret;\r\n}
