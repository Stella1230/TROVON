static inline u64 sal_get_hubdev_info(u64 handle, u64 address)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_GET_HUBDEV_INFO,\r\n(u64) handle, (u64) address, 0, 0, 0, 0, 0);\r\nreturn ret_stuff.v0;\r\n}\r\nstatic inline u64 sal_get_pcibus_info(u64 segment, u64 busnum, u64 address)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_GET_PCIBUS_INFO,\r\n(u64) segment, (u64) busnum, (u64) address, 0, 0, 0, 0);\r\nreturn ret_stuff.v0;\r\n}\r\nstatic inline u64\r\nsal_get_pcidev_info(u64 segment, u64 bus_number, u64 devfn, u64 pci_dev,\r\nu64 sn_irq_info)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_GET_PCIDEV_INFO,\r\n(u64) segment, (u64) bus_number, (u64) devfn,\r\n(u64) pci_dev,\r\nsn_irq_info, 0, 0);\r\nreturn ret_stuff.v0;\r\n}\r\nstatic void __init sn_fixup_ionodes(void)\r\n{\r\nstruct hubdev_info *hubdev;\r\nu64 status;\r\nu64 nasid;\r\nint i;\r\nextern void sn_common_hubdev_init(struct hubdev_info *);\r\nfor (i = 0; i < num_cnodes; i++) {\r\nhubdev = (struct hubdev_info *)(NODEPDA(i)->pdinfo);\r\nnasid = cnodeid_to_nasid(i);\r\nhubdev->max_segment_number = 0xffffffff;\r\nhubdev->max_pcibus_number = 0xff;\r\nstatus = sal_get_hubdev_info(nasid, (u64) __pa(hubdev));\r\nif (status)\r\ncontinue;\r\nif (hubdev->max_segment_number) {\r\nmax_segment_number = hubdev->max_segment_number;\r\nmax_pcibus_number = hubdev->max_pcibus_number;\r\n}\r\nsn_common_hubdev_init(hubdev);\r\n}\r\n}\r\nstatic void\r\nsn_legacy_pci_window_fixup(struct pci_controller *controller,\r\nu64 legacy_io, u64 legacy_mem)\r\n{\r\ncontroller->window = kcalloc(2, sizeof(struct pci_window),\r\nGFP_KERNEL);\r\nBUG_ON(controller->window == NULL);\r\ncontroller->window[0].offset = legacy_io;\r\ncontroller->window[0].resource.name = "legacy_io";\r\ncontroller->window[0].resource.flags = IORESOURCE_IO;\r\ncontroller->window[0].resource.start = legacy_io;\r\ncontroller->window[0].resource.end =\r\ncontroller->window[0].resource.start + 0xffff;\r\ncontroller->window[0].resource.parent = &ioport_resource;\r\ncontroller->window[1].offset = legacy_mem;\r\ncontroller->window[1].resource.name = "legacy_mem";\r\ncontroller->window[1].resource.flags = IORESOURCE_MEM;\r\ncontroller->window[1].resource.start = legacy_mem;\r\ncontroller->window[1].resource.end =\r\ncontroller->window[1].resource.start + (1024 * 1024) - 1;\r\ncontroller->window[1].resource.parent = &iomem_resource;\r\ncontroller->windows = 2;\r\n}\r\nstatic void\r\nsn_pci_window_fixup(struct pci_dev *dev, unsigned int count,\r\ns64 * pci_addrs)\r\n{\r\nstruct pci_controller *controller = PCI_CONTROLLER(dev->bus);\r\nunsigned int i;\r\nunsigned int idx;\r\nunsigned int new_count;\r\nstruct pci_window *new_window;\r\nif (count == 0)\r\nreturn;\r\nidx = controller->windows;\r\nnew_count = controller->windows + count;\r\nnew_window = kcalloc(new_count, sizeof(struct pci_window), GFP_KERNEL);\r\nBUG_ON(new_window == NULL);\r\nif (controller->window) {\r\nmemcpy(new_window, controller->window,\r\nsizeof(struct pci_window) * controller->windows);\r\nkfree(controller->window);\r\n}\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nif (pci_addrs[i] == -1)\r\ncontinue;\r\nnew_window[idx].offset = dev->resource[i].start - pci_addrs[i];\r\nnew_window[idx].resource = dev->resource[i];\r\nidx++;\r\n}\r\ncontroller->windows = new_count;\r\ncontroller->window = new_window;\r\n}\r\nvoid\r\nsn_io_slot_fixup(struct pci_dev *dev)\r\n{\r\nunsigned int count = 0;\r\nint idx;\r\ns64 pci_addrs[PCI_ROM_RESOURCE + 1];\r\nunsigned long addr, end, size, start;\r\nstruct pcidev_info *pcidev_info;\r\nstruct sn_irq_info *sn_irq_info;\r\nint status;\r\npcidev_info = kzalloc(sizeof(struct pcidev_info), GFP_KERNEL);\r\nif (!pcidev_info)\r\npanic("%s: Unable to alloc memory for pcidev_info", __func__);\r\nsn_irq_info = kzalloc(sizeof(struct sn_irq_info), GFP_KERNEL);\r\nif (!sn_irq_info)\r\npanic("%s: Unable to alloc memory for sn_irq_info", __func__);\r\nstatus = sal_get_pcidev_info((u64) pci_domain_nr(dev),\r\n(u64) dev->bus->number,\r\ndev->devfn,\r\n(u64) __pa(pcidev_info),\r\n(u64) __pa(sn_irq_info));\r\nBUG_ON(status);\r\nfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\r\nif (!pcidev_info->pdi_pio_mapped_addr[idx]) {\r\npci_addrs[idx] = -1;\r\ncontinue;\r\n}\r\nstart = dev->resource[idx].start;\r\nend = dev->resource[idx].end;\r\nsize = end - start;\r\nif (size == 0) {\r\npci_addrs[idx] = -1;\r\ncontinue;\r\n}\r\npci_addrs[idx] = start;\r\ncount++;\r\naddr = pcidev_info->pdi_pio_mapped_addr[idx];\r\naddr = ((addr << 4) >> 4) | __IA64_UNCACHED_OFFSET;\r\ndev->resource[idx].start = addr;\r\ndev->resource[idx].end = addr + size;\r\nif (dev->resource[idx].parent && dev->resource[idx].parent->child)\r\nrelease_resource(&dev->resource[idx]);\r\nif (dev->resource[idx].flags & IORESOURCE_IO)\r\ninsert_resource(&ioport_resource, &dev->resource[idx]);\r\nelse\r\ninsert_resource(&iomem_resource, &dev->resource[idx]);\r\nif (idx == PCI_ROM_RESOURCE) {\r\nsize_t image_size;\r\nvoid __iomem *rom;\r\nrom = ioremap(pci_resource_start(dev, PCI_ROM_RESOURCE),\r\nsize + 1);\r\nimage_size = pci_get_rom_size(dev, rom, size + 1);\r\ndev->resource[PCI_ROM_RESOURCE].end =\r\ndev->resource[PCI_ROM_RESOURCE].start +\r\nimage_size - 1;\r\ndev->resource[PCI_ROM_RESOURCE].flags |=\r\nIORESOURCE_ROM_BIOS_COPY;\r\n}\r\n}\r\nif (count > 0)\r\nsn_pci_window_fixup(dev, count, pci_addrs);\r\nsn_pci_fixup_slot(dev, pcidev_info, sn_irq_info);\r\n}\r\nstatic void __init\r\nsn_pci_controller_fixup(int segment, int busnum, struct pci_bus *bus)\r\n{\r\ns64 status = 0;\r\nstruct pci_controller *controller;\r\nstruct pcibus_bussoft *prom_bussoft_ptr;\r\nstatus = sal_get_pcibus_info((u64) segment, (u64) busnum,\r\n(u64) ia64_tpa(&prom_bussoft_ptr));\r\nif (status > 0)\r\nreturn;\r\nprom_bussoft_ptr = __va(prom_bussoft_ptr);\r\ncontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\r\nBUG_ON(!controller);\r\ncontroller->segment = segment;\r\ncontroller->platform_data = prom_bussoft_ptr;\r\nbus = pci_scan_bus(busnum, &pci_root_ops, controller);\r\nif (bus == NULL)\r\ngoto error_return;\r\nbus->sysdata = controller;\r\nreturn;\r\nerror_return:\r\nkfree(controller);\r\nreturn;\r\n}\r\nvoid\r\nsn_bus_fixup(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *pci_dev = NULL;\r\nstruct pcibus_bussoft *prom_bussoft_ptr;\r\nif (!bus->parent) {\r\nprom_bussoft_ptr = PCI_CONTROLLER(bus)->platform_data;\r\nif (prom_bussoft_ptr == NULL) {\r\nprintk(KERN_ERR\r\n"sn_bus_fixup: 0x%04x:0x%02x Unable to "\r\n"obtain prom_bussoft_ptr\n",\r\npci_domain_nr(bus), bus->number);\r\nreturn;\r\n}\r\nsn_common_bus_fixup(bus, prom_bussoft_ptr);\r\nsn_legacy_pci_window_fixup(PCI_CONTROLLER(bus),\r\nprom_bussoft_ptr->bs_legacy_io,\r\nprom_bussoft_ptr->bs_legacy_mem);\r\n}\r\nlist_for_each_entry(pci_dev, &bus->devices, bus_list) {\r\nsn_io_slot_fixup(pci_dev);\r\n}\r\n}\r\nvoid __init sn_io_init(void)\r\n{\r\nint i, j;\r\nsn_fixup_ionodes();\r\nfor (i = 0; i <= max_segment_number; i++)\r\nfor (j = 0; j <= max_pcibus_number; j++)\r\nsn_pci_controller_fixup(i, j, NULL);\r\n}
