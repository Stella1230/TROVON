static void init_input_buf(char *buf, unsigned long long size)\r\n{\r\ninput_buf = buf;\r\ninput_buf_siz = size;\r\ninput_buf_ptr = 0;\r\n}\r\nstatic int cmdline_cmp(const void *a, const void *b)\r\n{\r\nconst struct cmdline *ca = a;\r\nconst struct cmdline *cb = b;\r\nif (ca->pid < cb->pid)\r\nreturn -1;\r\nif (ca->pid > cb->pid)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid parse_cmdlines(char *file, int size __unused)\r\n{\r\nstruct cmdline_list {\r\nstruct cmdline_list *next;\r\nchar *comm;\r\nint pid;\r\n} *list = NULL, *item;\r\nchar *line;\r\nchar *next = NULL;\r\nint i;\r\nline = strtok_r(file, "\n", &next);\r\nwhile (line) {\r\nitem = malloc_or_die(sizeof(*item));\r\nsscanf(line, "%d %as", &item->pid,\r\n(float *)(void *)&item->comm);\r\nitem->next = list;\r\nlist = item;\r\nline = strtok_r(NULL, "\n", &next);\r\ncmdline_count++;\r\n}\r\ncmdlines = malloc_or_die(sizeof(*cmdlines) * cmdline_count);\r\ni = 0;\r\nwhile (list) {\r\ncmdlines[i].pid = list->pid;\r\ncmdlines[i].comm = list->comm;\r\ni++;\r\nitem = list;\r\nlist = list->next;\r\nfree(item);\r\n}\r\nqsort(cmdlines, cmdline_count, sizeof(*cmdlines), cmdline_cmp);\r\n}\r\nstatic int func_cmp(const void *a, const void *b)\r\n{\r\nconst struct func_map *fa = a;\r\nconst struct func_map *fb = b;\r\nif (fa->addr < fb->addr)\r\nreturn -1;\r\nif (fa->addr > fb->addr)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid parse_proc_kallsyms(char *file, unsigned int size __unused)\r\n{\r\nstruct func_list {\r\nstruct func_list *next;\r\nunsigned long long addr;\r\nchar *func;\r\nchar *mod;\r\n} *list = NULL, *item;\r\nchar *line;\r\nchar *next = NULL;\r\nchar *addr_str;\r\nchar ch;\r\nint ret __used;\r\nint i;\r\nline = strtok_r(file, "\n", &next);\r\nwhile (line) {\r\nitem = malloc_or_die(sizeof(*item));\r\nitem->mod = NULL;\r\nret = sscanf(line, "%as %c %as\t[%as",\r\n(float *)(void *)&addr_str,\r\n&ch,\r\n(float *)(void *)&item->func,\r\n(float *)(void *)&item->mod);\r\nitem->addr = strtoull(addr_str, NULL, 16);\r\nfree(addr_str);\r\nif (item->mod)\r\nitem->mod[strlen(item->mod) - 1] = 0;\r\nitem->next = list;\r\nlist = item;\r\nline = strtok_r(NULL, "\n", &next);\r\nfunc_count++;\r\n}\r\nfunc_list = malloc_or_die(sizeof(*func_list) * (func_count + 1));\r\ni = 0;\r\nwhile (list) {\r\nfunc_list[i].func = list->func;\r\nfunc_list[i].addr = list->addr;\r\nfunc_list[i].mod = list->mod;\r\ni++;\r\nitem = list;\r\nlist = list->next;\r\nfree(item);\r\n}\r\nqsort(func_list, func_count, sizeof(*func_list), func_cmp);\r\nfunc_list[func_count].func = NULL;\r\nfunc_list[func_count].addr = 0;\r\nfunc_list[func_count].mod = NULL;\r\n}\r\nstatic int func_bcmp(const void *a, const void *b)\r\n{\r\nconst struct func_map *fa = a;\r\nconst struct func_map *fb = b;\r\nif ((fa->addr == fb->addr) ||\r\n(fa->addr > fb->addr &&\r\nfa->addr < (fb+1)->addr))\r\nreturn 0;\r\nif (fa->addr < fb->addr)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic struct func_map *find_func(unsigned long long addr)\r\n{\r\nstruct func_map *func;\r\nstruct func_map key;\r\nkey.addr = addr;\r\nfunc = bsearch(&key, func_list, func_count, sizeof(*func_list),\r\nfunc_bcmp);\r\nreturn func;\r\n}\r\nvoid print_funcs(void)\r\n{\r\nint i;\r\nfor (i = 0; i < (int)func_count; i++) {\r\nprintf("%016llx %s",\r\nfunc_list[i].addr,\r\nfunc_list[i].func);\r\nif (func_list[i].mod)\r\nprintf(" [%s]\n", func_list[i].mod);\r\nelse\r\nprintf("\n");\r\n}\r\n}\r\nstatic int printk_cmp(const void *a, const void *b)\r\n{\r\nconst struct func_map *fa = a;\r\nconst struct func_map *fb = b;\r\nif (fa->addr < fb->addr)\r\nreturn -1;\r\nif (fa->addr > fb->addr)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct printk_map *find_printk(unsigned long long addr)\r\n{\r\nstruct printk_map *printk;\r\nstruct printk_map key;\r\nkey.addr = addr;\r\nprintk = bsearch(&key, printk_list, printk_count, sizeof(*printk_list),\r\nprintk_cmp);\r\nreturn printk;\r\n}\r\nvoid parse_ftrace_printk(char *file, unsigned int size __unused)\r\n{\r\nstruct printk_list {\r\nstruct printk_list *next;\r\nunsigned long long addr;\r\nchar *printk;\r\n} *list = NULL, *item;\r\nchar *line;\r\nchar *next = NULL;\r\nchar *addr_str;\r\nint i;\r\nline = strtok_r(file, "\n", &next);\r\nwhile (line) {\r\naddr_str = strsep(&line, ":");\r\nif (!line) {\r\nwarning("error parsing print strings");\r\nbreak;\r\n}\r\nitem = malloc_or_die(sizeof(*item));\r\nitem->addr = strtoull(addr_str, NULL, 16);\r\nitem->printk = strdup(line+1);\r\nitem->next = list;\r\nlist = item;\r\nline = strtok_r(NULL, "\n", &next);\r\nprintk_count++;\r\n}\r\nprintk_list = malloc_or_die(sizeof(*printk_list) * printk_count + 1);\r\ni = 0;\r\nwhile (list) {\r\nprintk_list[i].printk = list->printk;\r\nprintk_list[i].addr = list->addr;\r\ni++;\r\nitem = list;\r\nlist = list->next;\r\nfree(item);\r\n}\r\nqsort(printk_list, printk_count, sizeof(*printk_list), printk_cmp);\r\n}\r\nvoid print_printk(void)\r\n{\r\nint i;\r\nfor (i = 0; i < (int)printk_count; i++) {\r\nprintf("%016llx %s\n",\r\nprintk_list[i].addr,\r\nprintk_list[i].printk);\r\n}\r\n}\r\nstatic struct event *alloc_event(void)\r\n{\r\nstruct event *event;\r\nevent = malloc_or_die(sizeof(*event));\r\nmemset(event, 0, sizeof(*event));\r\nreturn event;\r\n}\r\nstatic void add_event(struct event *event)\r\n{\r\nevent->next = event_list;\r\nevent_list = event;\r\n}\r\nstatic int event_item_type(enum event_type type)\r\n{\r\nswitch (type) {\r\ncase EVENT_ITEM ... EVENT_SQUOTE:\r\nreturn 1;\r\ncase EVENT_ERROR ... EVENT_DELIM:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void free_arg(struct print_arg *arg)\r\n{\r\nif (!arg)\r\nreturn;\r\nswitch (arg->type) {\r\ncase PRINT_ATOM:\r\nif (arg->atom.atom)\r\nfree(arg->atom.atom);\r\nbreak;\r\ncase PRINT_NULL:\r\ncase PRINT_FIELD ... PRINT_OP:\r\ndefault:\r\nbreak;\r\n}\r\nfree(arg);\r\n}\r\nstatic enum event_type get_type(int ch)\r\n{\r\nif (ch == '\n')\r\nreturn EVENT_NEWLINE;\r\nif (isspace(ch))\r\nreturn EVENT_SPACE;\r\nif (isalnum(ch) || ch == '_')\r\nreturn EVENT_ITEM;\r\nif (ch == '\'')\r\nreturn EVENT_SQUOTE;\r\nif (ch == '"')\r\nreturn EVENT_DQUOTE;\r\nif (!isprint(ch))\r\nreturn EVENT_NONE;\r\nif (ch == '(' || ch == ')' || ch == ',')\r\nreturn EVENT_DELIM;\r\nreturn EVENT_OP;\r\n}\r\nstatic int __read_char(void)\r\n{\r\nif (input_buf_ptr >= input_buf_siz)\r\nreturn -1;\r\nreturn input_buf[input_buf_ptr++];\r\n}\r\nstatic int __peek_char(void)\r\n{\r\nif (input_buf_ptr >= input_buf_siz)\r\nreturn -1;\r\nreturn input_buf[input_buf_ptr];\r\n}\r\nstatic enum event_type __read_token(char **tok)\r\n{\r\nchar buf[BUFSIZ];\r\nint ch, last_ch, quote_ch, next_ch;\r\nint i = 0;\r\nint tok_size = 0;\r\nenum event_type type;\r\n*tok = NULL;\r\nch = __read_char();\r\nif (ch < 0)\r\nreturn EVENT_NONE;\r\ntype = get_type(ch);\r\nif (type == EVENT_NONE)\r\nreturn type;\r\nbuf[i++] = ch;\r\nswitch (type) {\r\ncase EVENT_NEWLINE:\r\ncase EVENT_DELIM:\r\n*tok = malloc_or_die(2);\r\n(*tok)[0] = ch;\r\n(*tok)[1] = 0;\r\nreturn type;\r\ncase EVENT_OP:\r\nswitch (ch) {\r\ncase '-':\r\nnext_ch = __peek_char();\r\nif (next_ch == '>') {\r\nbuf[i++] = __read_char();\r\nbreak;\r\n}\r\ncase '+':\r\ncase '|':\r\ncase '&':\r\ncase '>':\r\ncase '<':\r\nlast_ch = ch;\r\nch = __peek_char();\r\nif (ch != last_ch)\r\ngoto test_equal;\r\nbuf[i++] = __read_char();\r\nswitch (last_ch) {\r\ncase '>':\r\ncase '<':\r\ngoto test_equal;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase '!':\r\ncase '=':\r\ngoto test_equal;\r\ndefault:\r\nbreak;\r\n}\r\nbuf[i] = 0;\r\n*tok = strdup(buf);\r\nreturn type;\r\ntest_equal:\r\nch = __peek_char();\r\nif (ch == '=')\r\nbuf[i++] = __read_char();\r\nbreak;\r\ncase EVENT_DQUOTE:\r\ncase EVENT_SQUOTE:\r\ni--;\r\nquote_ch = ch;\r\nlast_ch = 0;\r\ndo {\r\nif (i == (BUFSIZ - 1)) {\r\nbuf[i] = 0;\r\nif (*tok) {\r\n*tok = realloc(*tok, tok_size + BUFSIZ);\r\nif (!*tok)\r\nreturn EVENT_NONE;\r\nstrcat(*tok, buf);\r\n} else\r\n*tok = strdup(buf);\r\nif (!*tok)\r\nreturn EVENT_NONE;\r\ntok_size += BUFSIZ;\r\ni = 0;\r\n}\r\nlast_ch = ch;\r\nch = __read_char();\r\nbuf[i++] = ch;\r\nif (ch == '\\' && last_ch == '\\')\r\nlast_ch = 0;\r\n} while (ch != quote_ch || last_ch == '\\');\r\ni--;\r\ngoto out;\r\ncase EVENT_ERROR ... EVENT_SPACE:\r\ncase EVENT_ITEM:\r\ndefault:\r\nbreak;\r\n}\r\nwhile (get_type(__peek_char()) == type) {\r\nif (i == (BUFSIZ - 1)) {\r\nbuf[i] = 0;\r\nif (*tok) {\r\n*tok = realloc(*tok, tok_size + BUFSIZ);\r\nif (!*tok)\r\nreturn EVENT_NONE;\r\nstrcat(*tok, buf);\r\n} else\r\n*tok = strdup(buf);\r\nif (!*tok)\r\nreturn EVENT_NONE;\r\ntok_size += BUFSIZ;\r\ni = 0;\r\n}\r\nch = __read_char();\r\nbuf[i++] = ch;\r\n}\r\nout:\r\nbuf[i] = 0;\r\nif (*tok) {\r\n*tok = realloc(*tok, tok_size + i);\r\nif (!*tok)\r\nreturn EVENT_NONE;\r\nstrcat(*tok, buf);\r\n} else\r\n*tok = strdup(buf);\r\nif (!*tok)\r\nreturn EVENT_NONE;\r\nreturn type;\r\n}\r\nstatic void free_token(char *tok)\r\n{\r\nif (tok)\r\nfree(tok);\r\n}\r\nstatic enum event_type read_token(char **tok)\r\n{\r\nenum event_type type;\r\nfor (;;) {\r\ntype = __read_token(tok);\r\nif (type != EVENT_SPACE)\r\nreturn type;\r\nfree_token(*tok);\r\n}\r\nreturn EVENT_NONE;\r\n}\r\nstatic enum event_type read_token_item(char **tok)\r\n{\r\nenum event_type type;\r\nfor (;;) {\r\ntype = __read_token(tok);\r\nif (type != EVENT_SPACE && type != EVENT_NEWLINE)\r\nreturn type;\r\nfree_token(*tok);\r\n}\r\nreturn EVENT_NONE;\r\n}\r\nstatic int test_type(enum event_type type, enum event_type expect)\r\n{\r\nif (type != expect) {\r\nwarning("Error: expected type %d but read %d",\r\nexpect, type);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __test_type_token(enum event_type type, char *token,\r\nenum event_type expect, const char *expect_tok,\r\nbool warn)\r\n{\r\nif (type != expect) {\r\nif (warn)\r\nwarning("Error: expected type %d but read %d",\r\nexpect, type);\r\nreturn -1;\r\n}\r\nif (strcmp(token, expect_tok) != 0) {\r\nif (warn)\r\nwarning("Error: expected '%s' but read '%s'",\r\nexpect_tok, token);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int test_type_token(enum event_type type, char *token,\r\nenum event_type expect, const char *expect_tok)\r\n{\r\nreturn __test_type_token(type, token, expect, expect_tok, true);\r\n}\r\nstatic int __read_expect_type(enum event_type expect, char **tok, int newline_ok)\r\n{\r\nenum event_type type;\r\nif (newline_ok)\r\ntype = read_token(tok);\r\nelse\r\ntype = read_token_item(tok);\r\nreturn test_type(type, expect);\r\n}\r\nstatic int read_expect_type(enum event_type expect, char **tok)\r\n{\r\nreturn __read_expect_type(expect, tok, 1);\r\n}\r\nstatic int __read_expected(enum event_type expect, const char *str,\r\nint newline_ok, bool warn)\r\n{\r\nenum event_type type;\r\nchar *token;\r\nint ret;\r\nif (newline_ok)\r\ntype = read_token(&token);\r\nelse\r\ntype = read_token_item(&token);\r\nret = __test_type_token(type, token, expect, str, warn);\r\nfree_token(token);\r\nreturn ret;\r\n}\r\nstatic int read_expected(enum event_type expect, const char *str)\r\n{\r\nreturn __read_expected(expect, str, 1, true);\r\n}\r\nstatic int read_expected_item(enum event_type expect, const char *str)\r\n{\r\nreturn __read_expected(expect, str, 0, true);\r\n}\r\nstatic char *event_read_name(void)\r\n{\r\nchar *token;\r\nif (read_expected(EVENT_ITEM, "name") < 0)\r\nreturn NULL;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn NULL;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nreturn token;\r\nfail:\r\nfree_token(token);\r\nreturn NULL;\r\n}\r\nstatic int event_read_id(void)\r\n{\r\nchar *token;\r\nint id;\r\nif (read_expected_item(EVENT_ITEM, "ID") < 0)\r\nreturn -1;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn -1;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nid = strtoul(token, NULL, 0);\r\nfree_token(token);\r\nreturn id;\r\nfail:\r\nfree_token(token);\r\nreturn -1;\r\n}\r\nstatic int field_is_string(struct format_field *field)\r\n{\r\nif ((field->flags & FIELD_IS_ARRAY) &&\r\n(!strstr(field->type, "char") || !strstr(field->type, "u8") ||\r\n!strstr(field->type, "s8")))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int field_is_dynamic(struct format_field *field)\r\n{\r\nif (!strncmp(field->type, "__data_loc", 10))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int event_read_fields(struct event *event, struct format_field **fields)\r\n{\r\nstruct format_field *field = NULL;\r\nenum event_type type;\r\nchar *token;\r\nchar *last_token;\r\nint count = 0;\r\ndo {\r\ntype = read_token(&token);\r\nif (type == EVENT_NEWLINE) {\r\nfree_token(token);\r\nreturn count;\r\n}\r\ncount++;\r\nif (test_type_token(type, token, EVENT_ITEM, "field"))\r\ngoto fail;\r\nfree_token(token);\r\ntype = read_token(&token);\r\nif (event->flags & EVENT_FL_ISFTRACE &&\r\ntype == EVENT_ITEM && strcmp(token, "special") == 0) {\r\nfree_token(token);\r\ntype = read_token(&token);\r\n}\r\nif (test_type_token(type, token, EVENT_OP, ":") < 0)\r\nreturn -1;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nlast_token = token;\r\nfield = malloc_or_die(sizeof(*field));\r\nmemset(field, 0, sizeof(*field));\r\nfor (;;) {\r\ntype = read_token(&token);\r\nif (type == EVENT_ITEM ||\r\n(type == EVENT_OP && strcmp(token, "*") == 0) ||\r\n(event->flags & EVENT_FL_ISFTRACE &&\r\ntype == EVENT_OP && strcmp(token, ".") == 0)) {\r\nif (strcmp(token, "*") == 0)\r\nfield->flags |= FIELD_IS_POINTER;\r\nif (field->type) {\r\nfield->type = realloc(field->type,\r\nstrlen(field->type) +\r\nstrlen(last_token) + 2);\r\nstrcat(field->type, " ");\r\nstrcat(field->type, last_token);\r\n} else\r\nfield->type = last_token;\r\nlast_token = token;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (!field->type) {\r\ndie("no type found");\r\ngoto fail;\r\n}\r\nfield->name = last_token;\r\nif (test_type(type, EVENT_OP))\r\ngoto fail;\r\nif (strcmp(token, "[") == 0) {\r\nenum event_type last_type = type;\r\nchar *brackets = token;\r\nint len;\r\nfield->flags |= FIELD_IS_ARRAY;\r\ntype = read_token(&token);\r\nwhile (strcmp(token, "]") != 0) {\r\nif (last_type == EVENT_ITEM &&\r\ntype == EVENT_ITEM)\r\nlen = 2;\r\nelse\r\nlen = 1;\r\nlast_type = type;\r\nbrackets = realloc(brackets,\r\nstrlen(brackets) +\r\nstrlen(token) + len);\r\nif (len == 2)\r\nstrcat(brackets, " ");\r\nstrcat(brackets, token);\r\nfree_token(token);\r\ntype = read_token(&token);\r\nif (type == EVENT_NONE) {\r\ndie("failed to find token");\r\ngoto fail;\r\n}\r\n}\r\nfree_token(token);\r\nbrackets = realloc(brackets, strlen(brackets) + 2);\r\nstrcat(brackets, "]");\r\ntype = read_token(&token);\r\nif (type == EVENT_ITEM) {\r\nfield->type = realloc(field->type,\r\nstrlen(field->type) +\r\nstrlen(field->name) +\r\nstrlen(brackets) + 2);\r\nstrcat(field->type, " ");\r\nstrcat(field->type, field->name);\r\nfree_token(field->name);\r\nstrcat(field->type, brackets);\r\nfield->name = token;\r\ntype = read_token(&token);\r\n} else {\r\nfield->type = realloc(field->type,\r\nstrlen(field->type) +\r\nstrlen(brackets) + 1);\r\nstrcat(field->type, brackets);\r\n}\r\nfree(brackets);\r\n}\r\nif (field_is_string(field)) {\r\nfield->flags |= FIELD_IS_STRING;\r\nif (field_is_dynamic(field))\r\nfield->flags |= FIELD_IS_DYNAMIC;\r\n}\r\nif (test_type_token(type, token, EVENT_OP, ";"))\r\ngoto fail;\r\nfree_token(token);\r\nif (read_expected(EVENT_ITEM, "offset") < 0)\r\ngoto fail_expect;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\ngoto fail_expect;\r\nif (read_expect_type(EVENT_ITEM, &token))\r\ngoto fail;\r\nfield->offset = strtoul(token, NULL, 0);\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\ngoto fail_expect;\r\nif (read_expected(EVENT_ITEM, "size") < 0)\r\ngoto fail_expect;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\ngoto fail_expect;\r\nif (read_expect_type(EVENT_ITEM, &token))\r\ngoto fail;\r\nfield->size = strtoul(token, NULL, 0);\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\ngoto fail_expect;\r\ntype = read_token(&token);\r\nif (type != EVENT_NEWLINE) {\r\nif (test_type_token(type, token, EVENT_ITEM, "signed"))\r\ngoto fail;\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ":") < 0)\r\ngoto fail_expect;\r\nif (read_expect_type(EVENT_ITEM, &token))\r\ngoto fail;\r\nif (strtoul(token, NULL, 0))\r\nfield->flags |= FIELD_IS_SIGNED;\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\ngoto fail_expect;\r\nif (read_expect_type(EVENT_NEWLINE, &token))\r\ngoto fail;\r\n}\r\nfree_token(token);\r\n*fields = field;\r\nfields = &field->next;\r\n} while (1);\r\nreturn 0;\r\nfail:\r\nfree_token(token);\r\nfail_expect:\r\nif (field)\r\nfree(field);\r\nreturn -1;\r\n}\r\nstatic int event_read_format(struct event *event)\r\n{\r\nchar *token;\r\nint ret;\r\nif (read_expected_item(EVENT_ITEM, "format") < 0)\r\nreturn -1;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn -1;\r\nif (read_expect_type(EVENT_NEWLINE, &token))\r\ngoto fail;\r\nfree_token(token);\r\nret = event_read_fields(event, &event->format.common_fields);\r\nif (ret < 0)\r\nreturn ret;\r\nevent->format.nr_common = ret;\r\nret = event_read_fields(event, &event->format.fields);\r\nif (ret < 0)\r\nreturn ret;\r\nevent->format.nr_fields = ret;\r\nreturn 0;\r\nfail:\r\nfree_token(token);\r\nreturn -1;\r\n}\r\nstatic enum event_type\r\nprocess_arg(struct event *event, struct print_arg *arg, char **tok)\r\n{\r\nenum event_type type;\r\nchar *token;\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn process_arg_token(event, arg, tok, type);\r\n}\r\nstatic enum event_type\r\nprocess_cond(struct event *event, struct print_arg *top, char **tok)\r\n{\r\nstruct print_arg *arg, *left, *right;\r\nenum event_type type;\r\nchar *token = NULL;\r\narg = malloc_or_die(sizeof(*arg));\r\nmemset(arg, 0, sizeof(*arg));\r\nleft = malloc_or_die(sizeof(*left));\r\nright = malloc_or_die(sizeof(*right));\r\narg->type = PRINT_OP;\r\narg->op.left = left;\r\narg->op.right = right;\r\n*tok = NULL;\r\ntype = process_arg(event, left, &token);\r\nif (test_type_token(type, token, EVENT_OP, ":"))\r\ngoto out_free;\r\narg->op.op = token;\r\ntype = process_arg(event, right, &token);\r\ntop->op.right = arg;\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_token(*tok);\r\nfree(right);\r\nfree(left);\r\nfree_arg(arg);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_array(struct event *event, struct print_arg *top, char **tok)\r\n{\r\nstruct print_arg *arg;\r\nenum event_type type;\r\nchar *token = NULL;\r\narg = malloc_or_die(sizeof(*arg));\r\nmemset(arg, 0, sizeof(*arg));\r\n*tok = NULL;\r\ntype = process_arg(event, arg, &token);\r\nif (test_type_token(type, token, EVENT_OP, "]"))\r\ngoto out_free;\r\ntop->op.right = arg;\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_token(*tok);\r\nfree_arg(arg);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic int get_op_prio(char *op)\r\n{\r\nif (!op[1]) {\r\nswitch (op[0]) {\r\ncase '*':\r\ncase '/':\r\ncase '%':\r\nreturn 6;\r\ncase '+':\r\ncase '-':\r\nreturn 7;\r\ncase '<':\r\ncase '>':\r\nreturn 9;\r\ncase '&':\r\nreturn 11;\r\ncase '^':\r\nreturn 12;\r\ncase '|':\r\nreturn 13;\r\ncase '?':\r\nreturn 16;\r\ndefault:\r\ndie("unknown op '%c'", op[0]);\r\nreturn -1;\r\n}\r\n} else {\r\nif (strcmp(op, "++") == 0 ||\r\nstrcmp(op, "--") == 0) {\r\nreturn 3;\r\n} else if (strcmp(op, ">>") == 0 ||\r\nstrcmp(op, "<<") == 0) {\r\nreturn 8;\r\n} else if (strcmp(op, ">=") == 0 ||\r\nstrcmp(op, "<=") == 0) {\r\nreturn 9;\r\n} else if (strcmp(op, "==") == 0 ||\r\nstrcmp(op, "!=") == 0) {\r\nreturn 10;\r\n} else if (strcmp(op, "&&") == 0) {\r\nreturn 14;\r\n} else if (strcmp(op, "||") == 0) {\r\nreturn 15;\r\n} else {\r\ndie("unknown op '%s'", op);\r\nreturn -1;\r\n}\r\n}\r\n}\r\nstatic void set_op_prio(struct print_arg *arg)\r\n{\r\nif (!arg->op.left || arg->op.left->type == PRINT_NULL) {\r\narg->op.prio = 0;\r\nreturn;\r\n}\r\narg->op.prio = get_op_prio(arg->op.op);\r\n}\r\nstatic enum event_type\r\nprocess_op(struct event *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg *left, *right = NULL;\r\nenum event_type type;\r\nchar *token;\r\ntoken = *tok;\r\nif (arg->type == PRINT_OP && !arg->op.left) {\r\nif (token[1]) {\r\ndie("bad op token %s", token);\r\nreturn EVENT_ERROR;\r\n}\r\nswitch (token[0]) {\r\ncase '!':\r\ncase '+':\r\ncase '-':\r\nbreak;\r\ndefault:\r\ndie("bad op token %s", token);\r\nreturn EVENT_ERROR;\r\n}\r\nleft = malloc_or_die(sizeof(*left));\r\nleft->type = PRINT_NULL;\r\narg->op.left = left;\r\nright = malloc_or_die(sizeof(*right));\r\narg->op.right = right;\r\ntype = process_arg(event, right, tok);\r\n} else if (strcmp(token, "?") == 0) {\r\nleft = malloc_or_die(sizeof(*left));\r\n*left = *arg;\r\narg->type = PRINT_OP;\r\narg->op.op = token;\r\narg->op.left = left;\r\narg->op.prio = 0;\r\ntype = process_cond(event, arg, tok);\r\n} else if (strcmp(token, ">>") == 0 ||\r\nstrcmp(token, "<<") == 0 ||\r\nstrcmp(token, "&") == 0 ||\r\nstrcmp(token, "|") == 0 ||\r\nstrcmp(token, "&&") == 0 ||\r\nstrcmp(token, "||") == 0 ||\r\nstrcmp(token, "-") == 0 ||\r\nstrcmp(token, "+") == 0 ||\r\nstrcmp(token, "*") == 0 ||\r\nstrcmp(token, "^") == 0 ||\r\nstrcmp(token, "/") == 0 ||\r\nstrcmp(token, "<") == 0 ||\r\nstrcmp(token, ">") == 0 ||\r\nstrcmp(token, "==") == 0 ||\r\nstrcmp(token, "!=") == 0) {\r\nleft = malloc_or_die(sizeof(*left));\r\n*left = *arg;\r\narg->type = PRINT_OP;\r\narg->op.op = token;\r\narg->op.left = left;\r\nset_op_prio(arg);\r\nright = malloc_or_die(sizeof(*right));\r\ntype = read_token_item(&token);\r\n*tok = token;\r\nif ((strcmp(arg->op.op, "*") == 0) &&\r\ntype == EVENT_DELIM && (strcmp(token, ")") == 0)) {\r\nif (left->type != PRINT_ATOM)\r\ndie("bad pointer type");\r\nleft->atom.atom = realloc(left->atom.atom,\r\nsizeof(left->atom.atom) + 3);\r\nstrcat(left->atom.atom, " *");\r\n*arg = *left;\r\nfree(arg);\r\nreturn type;\r\n}\r\ntype = process_arg_token(event, right, tok, type);\r\narg->op.right = right;\r\n} else if (strcmp(token, "[") == 0) {\r\nleft = malloc_or_die(sizeof(*left));\r\n*left = *arg;\r\narg->type = PRINT_OP;\r\narg->op.op = token;\r\narg->op.left = left;\r\narg->op.prio = 0;\r\ntype = process_array(event, arg, tok);\r\n} else {\r\nwarning("unknown op '%s'", token);\r\nevent->flags |= EVENT_FL_FAILED;\r\nreturn EVENT_NONE;\r\n}\r\nif (type == EVENT_OP) {\r\nint prio;\r\nprio = get_op_prio(*tok);\r\nif (prio > arg->op.prio)\r\nreturn process_op(event, arg, tok);\r\nreturn process_op(event, right, tok);\r\n}\r\nreturn type;\r\n}\r\nstatic enum event_type\r\nprocess_entry(struct event *event __unused, struct print_arg *arg,\r\nchar **tok)\r\n{\r\nenum event_type type;\r\nchar *field;\r\nchar *token;\r\nif (read_expected(EVENT_OP, "->") < 0)\r\nreturn EVENT_ERROR;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nfield = token;\r\narg->type = PRINT_FIELD;\r\narg->field.name = field;\r\nif (is_flag_field) {\r\narg->field.field = find_any_field(event, arg->field.name);\r\narg->field.field->flags |= FIELD_IS_FLAG;\r\nis_flag_field = 0;\r\n} else if (is_symbolic_field) {\r\narg->field.field = find_any_field(event, arg->field.name);\r\narg->field.field->flags |= FIELD_IS_SYMBOLIC;\r\nis_symbolic_field = 0;\r\n}\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn type;\r\nfail:\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic long long arg_num_eval(struct print_arg *arg)\r\n{\r\nlong long left, right;\r\nlong long val = 0;\r\nswitch (arg->type) {\r\ncase PRINT_ATOM:\r\nval = strtoll(arg->atom.atom, NULL, 0);\r\nbreak;\r\ncase PRINT_TYPE:\r\nval = arg_num_eval(arg->typecast.item);\r\nbreak;\r\ncase PRINT_OP:\r\nswitch (arg->op.op[0]) {\r\ncase '|':\r\nleft = arg_num_eval(arg->op.left);\r\nright = arg_num_eval(arg->op.right);\r\nif (arg->op.op[1])\r\nval = left || right;\r\nelse\r\nval = left | right;\r\nbreak;\r\ncase '&':\r\nleft = arg_num_eval(arg->op.left);\r\nright = arg_num_eval(arg->op.right);\r\nif (arg->op.op[1])\r\nval = left && right;\r\nelse\r\nval = left & right;\r\nbreak;\r\ncase '<':\r\nleft = arg_num_eval(arg->op.left);\r\nright = arg_num_eval(arg->op.right);\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\nval = left < right;\r\nbreak;\r\ncase '<':\r\nval = left << right;\r\nbreak;\r\ncase '=':\r\nval = left <= right;\r\nbreak;\r\ndefault:\r\ndie("unknown op '%s'", arg->op.op);\r\n}\r\nbreak;\r\ncase '>':\r\nleft = arg_num_eval(arg->op.left);\r\nright = arg_num_eval(arg->op.right);\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\nval = left > right;\r\nbreak;\r\ncase '>':\r\nval = left >> right;\r\nbreak;\r\ncase '=':\r\nval = left >= right;\r\nbreak;\r\ndefault:\r\ndie("unknown op '%s'", arg->op.op);\r\n}\r\nbreak;\r\ncase '=':\r\nleft = arg_num_eval(arg->op.left);\r\nright = arg_num_eval(arg->op.right);\r\nif (arg->op.op[1] != '=')\r\ndie("unknown op '%s'", arg->op.op);\r\nval = left == right;\r\nbreak;\r\ncase '!':\r\nleft = arg_num_eval(arg->op.left);\r\nright = arg_num_eval(arg->op.right);\r\nswitch (arg->op.op[1]) {\r\ncase '=':\r\nval = left != right;\r\nbreak;\r\ndefault:\r\ndie("unknown op '%s'", arg->op.op);\r\n}\r\nbreak;\r\ndefault:\r\ndie("unknown op '%s'", arg->op.op);\r\n}\r\nbreak;\r\ncase PRINT_NULL:\r\ncase PRINT_FIELD ... PRINT_SYMBOL:\r\ncase PRINT_STRING:\r\ndefault:\r\ndie("invalid eval type %d", arg->type);\r\n}\r\nreturn val;\r\n}\r\nstatic char *arg_eval (struct print_arg *arg)\r\n{\r\nlong long val;\r\nstatic char buf[20];\r\nswitch (arg->type) {\r\ncase PRINT_ATOM:\r\nreturn arg->atom.atom;\r\ncase PRINT_TYPE:\r\nreturn arg_eval(arg->typecast.item);\r\ncase PRINT_OP:\r\nval = arg_num_eval(arg);\r\nsprintf(buf, "%lld", val);\r\nreturn buf;\r\ncase PRINT_NULL:\r\ncase PRINT_FIELD ... PRINT_SYMBOL:\r\ncase PRINT_STRING:\r\ndefault:\r\ndie("invalid eval type %d", arg->type);\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic enum event_type\r\nprocess_fields(struct event *event, struct print_flag_sym **list, char **tok)\r\n{\r\nenum event_type type;\r\nstruct print_arg *arg = NULL;\r\nstruct print_flag_sym *field;\r\nchar *token = NULL;\r\nchar *value;\r\ndo {\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\nif (test_type_token(type, token, EVENT_OP, "{"))\r\nbreak;\r\narg = malloc_or_die(sizeof(*arg));\r\nfree_token(token);\r\ntype = process_arg(event, arg, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto out_free;\r\nfield = malloc_or_die(sizeof(*field));\r\nmemset(field, 0, sizeof(*field));\r\nvalue = arg_eval(arg);\r\nfield->value = strdup(value);\r\nfree_token(token);\r\ntype = process_arg(event, arg, &token);\r\nif (test_type_token(type, token, EVENT_OP, "}"))\r\ngoto out_free;\r\nvalue = arg_eval(arg);\r\nfield->str = strdup(value);\r\nfree_arg(arg);\r\narg = NULL;\r\n*list = field;\r\nlist = &field->next;\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\n} while (type == EVENT_DELIM && strcmp(token, ",") == 0);\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_arg(arg);\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_flags(struct event *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg *field;\r\nenum event_type type;\r\nchar *token;\r\nmemset(arg, 0, sizeof(*arg));\r\narg->type = PRINT_FLAGS;\r\nif (read_expected_item(EVENT_DELIM, "(") < 0)\r\nreturn EVENT_ERROR;\r\nfield = malloc_or_die(sizeof(*field));\r\ntype = process_arg(event, field, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto out_free;\r\narg->flags.field = field;\r\ntype = read_token_item(&token);\r\nif (event_item_type(type)) {\r\narg->flags.delim = token;\r\ntype = read_token_item(&token);\r\n}\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto out_free;\r\ntype = process_fields(event, &arg->flags.flags, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ")"))\r\ngoto out_free;\r\nfree_token(token);\r\ntype = read_token_item(tok);\r\nreturn type;\r\nout_free:\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_symbols(struct event *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg *field;\r\nenum event_type type;\r\nchar *token;\r\nmemset(arg, 0, sizeof(*arg));\r\narg->type = PRINT_SYMBOL;\r\nif (read_expected_item(EVENT_DELIM, "(") < 0)\r\nreturn EVENT_ERROR;\r\nfield = malloc_or_die(sizeof(*field));\r\ntype = process_arg(event, field, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto out_free;\r\narg->symbol.field = field;\r\ntype = process_fields(event, &arg->symbol.symbols, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ")"))\r\ngoto out_free;\r\nfree_token(token);\r\ntype = read_token_item(tok);\r\nreturn type;\r\nout_free:\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_paren(struct event *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg *item_arg;\r\nenum event_type type;\r\nchar *token;\r\ntype = process_arg(event, arg, &token);\r\nif (type == EVENT_ERROR)\r\nreturn EVENT_ERROR;\r\nif (type == EVENT_OP)\r\ntype = process_op(event, arg, &token);\r\nif (type == EVENT_ERROR)\r\nreturn EVENT_ERROR;\r\nif (test_type_token(type, token, EVENT_DELIM, ")")) {\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\nif (event_item_type(type) ||\r\n(type == EVENT_DELIM && strcmp(token, "(") == 0)) {\r\nif (arg->type != PRINT_ATOM)\r\ndie("previous needed to be PRINT_ATOM");\r\nitem_arg = malloc_or_die(sizeof(*item_arg));\r\narg->type = PRINT_TYPE;\r\narg->typecast.type = arg->atom.atom;\r\narg->typecast.item = item_arg;\r\ntype = process_arg_token(event, item_arg, &token, type);\r\n}\r\n*tok = token;\r\nreturn type;\r\n}\r\nstatic enum event_type\r\nprocess_str(struct event *event __unused, struct print_arg *arg, char **tok)\r\n{\r\nenum event_type type;\r\nchar *token;\r\nif (read_expected(EVENT_DELIM, "(") < 0)\r\nreturn EVENT_ERROR;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\narg->type = PRINT_STRING;\r\narg->string.string = token;\r\narg->string.offset = -1;\r\nif (read_expected(EVENT_DELIM, ")") < 0)\r\nreturn EVENT_ERROR;\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn type;\r\nfail:\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nenum event_type\r\nprocess_arg_token(struct event *event, struct print_arg *arg,\r\nchar **tok, enum event_type type)\r\n{\r\nchar *token;\r\nchar *atom;\r\ntoken = *tok;\r\nswitch (type) {\r\ncase EVENT_ITEM:\r\nif (strcmp(token, "REC") == 0) {\r\nfree_token(token);\r\ntype = process_entry(event, arg, &token);\r\n} else if (strcmp(token, "__print_flags") == 0) {\r\nfree_token(token);\r\nis_flag_field = 1;\r\ntype = process_flags(event, arg, &token);\r\n} else if (strcmp(token, "__print_symbolic") == 0) {\r\nfree_token(token);\r\nis_symbolic_field = 1;\r\ntype = process_symbols(event, arg, &token);\r\n} else if (strcmp(token, "__get_str") == 0) {\r\nfree_token(token);\r\ntype = process_str(event, arg, &token);\r\n} else {\r\natom = token;\r\ntype = read_token_item(&token);\r\nwhile (type == EVENT_ITEM) {\r\natom = realloc(atom, strlen(atom) + strlen(token) + 2);\r\nstrcat(atom, " ");\r\nstrcat(atom, token);\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\n}\r\narg->type = PRINT_ATOM;\r\narg->atom.atom = atom;\r\n}\r\nbreak;\r\ncase EVENT_DQUOTE:\r\ncase EVENT_SQUOTE:\r\narg->type = PRINT_ATOM;\r\narg->atom.atom = token;\r\ntype = read_token_item(&token);\r\nbreak;\r\ncase EVENT_DELIM:\r\nif (strcmp(token, "(") == 0) {\r\nfree_token(token);\r\ntype = process_paren(event, arg, &token);\r\nbreak;\r\n}\r\ncase EVENT_OP:\r\narg->type = PRINT_OP;\r\narg->op.op = token;\r\narg->op.left = NULL;\r\ntype = process_op(event, arg, &token);\r\nbreak;\r\ncase EVENT_ERROR ... EVENT_NEWLINE:\r\ndefault:\r\ndie("unexpected type %d", type);\r\n}\r\n*tok = token;\r\nreturn type;\r\n}\r\nstatic int event_read_print_args(struct event *event, struct print_arg **list)\r\n{\r\nenum event_type type = EVENT_ERROR;\r\nstruct print_arg *arg;\r\nchar *token;\r\nint args = 0;\r\ndo {\r\nif (type == EVENT_NEWLINE) {\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\ncontinue;\r\n}\r\narg = malloc_or_die(sizeof(*arg));\r\nmemset(arg, 0, sizeof(*arg));\r\ntype = process_arg(event, arg, &token);\r\nif (type == EVENT_ERROR) {\r\nfree_arg(arg);\r\nreturn -1;\r\n}\r\n*list = arg;\r\nargs++;\r\nif (type == EVENT_OP) {\r\ntype = process_op(event, arg, &token);\r\nlist = &arg->next;\r\ncontinue;\r\n}\r\nif (type == EVENT_DELIM && strcmp(token, ",") == 0) {\r\nfree_token(token);\r\n*list = arg;\r\nlist = &arg->next;\r\ncontinue;\r\n}\r\nbreak;\r\n} while (type != EVENT_NONE);\r\nif (type != EVENT_NONE)\r\nfree_token(token);\r\nreturn args;\r\n}\r\nstatic int event_read_print(struct event *event)\r\n{\r\nenum event_type type;\r\nchar *token;\r\nint ret;\r\nif (read_expected_item(EVENT_ITEM, "print") < 0)\r\nreturn -1;\r\nif (read_expected(EVENT_ITEM, "fmt") < 0)\r\nreturn -1;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn -1;\r\nif (read_expect_type(EVENT_DQUOTE, &token) < 0)\r\ngoto fail;\r\nconcat:\r\nevent->print_fmt.format = token;\r\nevent->print_fmt.args = NULL;\r\ntype = read_token_item(&token);\r\nif (type == EVENT_NONE)\r\nreturn 0;\r\nif (type == EVENT_DQUOTE) {\r\nchar *cat;\r\ncat = malloc_or_die(strlen(event->print_fmt.format) +\r\nstrlen(token) + 1);\r\nstrcpy(cat, event->print_fmt.format);\r\nstrcat(cat, token);\r\nfree_token(token);\r\nfree_token(event->print_fmt.format);\r\nevent->print_fmt.format = NULL;\r\ntoken = cat;\r\ngoto concat;\r\n}\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto fail;\r\nfree_token(token);\r\nret = event_read_print_args(event, &event->print_fmt.args);\r\nif (ret < 0)\r\nreturn -1;\r\nreturn ret;\r\nfail:\r\nfree_token(token);\r\nreturn -1;\r\n}\r\nstatic struct format_field *\r\nfind_common_field(struct event *event, const char *name)\r\n{\r\nstruct format_field *format;\r\nfor (format = event->format.common_fields;\r\nformat; format = format->next) {\r\nif (strcmp(format->name, name) == 0)\r\nbreak;\r\n}\r\nreturn format;\r\n}\r\nstatic struct format_field *\r\nfind_field(struct event *event, const char *name)\r\n{\r\nstruct format_field *format;\r\nfor (format = event->format.fields;\r\nformat; format = format->next) {\r\nif (strcmp(format->name, name) == 0)\r\nbreak;\r\n}\r\nreturn format;\r\n}\r\nstatic struct format_field *\r\nfind_any_field(struct event *event, const char *name)\r\n{\r\nstruct format_field *format;\r\nformat = find_common_field(event, name);\r\nif (format)\r\nreturn format;\r\nreturn find_field(event, name);\r\n}\r\nunsigned long long read_size(void *ptr, int size)\r\n{\r\nswitch (size) {\r\ncase 1:\r\nreturn *(unsigned char *)ptr;\r\ncase 2:\r\nreturn data2host2(ptr);\r\ncase 4:\r\nreturn data2host4(ptr);\r\ncase 8:\r\nreturn data2host8(ptr);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nunsigned long long\r\nraw_field_value(struct event *event, const char *name, void *data)\r\n{\r\nstruct format_field *field;\r\nfield = find_any_field(event, name);\r\nif (!field)\r\nreturn 0ULL;\r\nreturn read_size(data + field->offset, field->size);\r\n}\r\nvoid *raw_field_ptr(struct event *event, const char *name, void *data)\r\n{\r\nstruct format_field *field;\r\nfield = find_any_field(event, name);\r\nif (!field)\r\nreturn NULL;\r\nif (field->flags & FIELD_IS_DYNAMIC) {\r\nint offset;\r\noffset = *(int *)(data + field->offset);\r\noffset &= 0xffff;\r\nreturn data + offset;\r\n}\r\nreturn data + field->offset;\r\n}\r\nstatic int get_common_info(const char *type, int *offset, int *size)\r\n{\r\nstruct event *event;\r\nstruct format_field *field;\r\nif (!event_list)\r\ndie("no event_list!");\r\nevent = event_list;\r\nfield = find_common_field(event, type);\r\nif (!field)\r\ndie("field '%s' not found", type);\r\n*offset = field->offset;\r\n*size = field->size;\r\nreturn 0;\r\n}\r\nstatic int __parse_common(void *data, int *size, int *offset,\r\nconst char *name)\r\n{\r\nint ret;\r\nif (!*size) {\r\nret = get_common_info(name, offset, size);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn read_size(data + *offset, *size);\r\n}\r\nint trace_parse_common_type(void *data)\r\n{\r\nstatic int type_offset;\r\nstatic int type_size;\r\nreturn __parse_common(data, &type_size, &type_offset,\r\n"common_type");\r\n}\r\nint trace_parse_common_pid(void *data)\r\n{\r\nstatic int pid_offset;\r\nstatic int pid_size;\r\nreturn __parse_common(data, &pid_size, &pid_offset,\r\n"common_pid");\r\n}\r\nint parse_common_pc(void *data)\r\n{\r\nstatic int pc_offset;\r\nstatic int pc_size;\r\nreturn __parse_common(data, &pc_size, &pc_offset,\r\n"common_preempt_count");\r\n}\r\nint parse_common_flags(void *data)\r\n{\r\nstatic int flags_offset;\r\nstatic int flags_size;\r\nreturn __parse_common(data, &flags_size, &flags_offset,\r\n"common_flags");\r\n}\r\nint parse_common_lock_depth(void *data)\r\n{\r\nstatic int ld_offset;\r\nstatic int ld_size;\r\nint ret;\r\nret = __parse_common(data, &ld_size, &ld_offset,\r\n"common_lock_depth");\r\nif (ret < 0)\r\nreturn -1;\r\nreturn ret;\r\n}\r\nstruct event *trace_find_event(int id)\r\n{\r\nstruct event *event;\r\nfor (event = event_list; event; event = event->next) {\r\nif (event->id == id)\r\nbreak;\r\n}\r\nreturn event;\r\n}\r\nstruct event *trace_find_next_event(struct event *event)\r\n{\r\nif (!event)\r\nreturn event_list;\r\nreturn event->next;\r\n}\r\nstatic unsigned long long eval_num_arg(void *data, int size,\r\nstruct event *event, struct print_arg *arg)\r\n{\r\nunsigned long long val = 0;\r\nunsigned long long left, right;\r\nstruct print_arg *larg;\r\nswitch (arg->type) {\r\ncase PRINT_NULL:\r\nreturn 0;\r\ncase PRINT_ATOM:\r\nreturn strtoull(arg->atom.atom, NULL, 0);\r\ncase PRINT_FIELD:\r\nif (!arg->field.field) {\r\narg->field.field = find_any_field(event, arg->field.name);\r\nif (!arg->field.field)\r\ndie("field %s not found", arg->field.name);\r\n}\r\nval = read_size(data + arg->field.field->offset,\r\narg->field.field->size);\r\nbreak;\r\ncase PRINT_FLAGS:\r\ncase PRINT_SYMBOL:\r\nbreak;\r\ncase PRINT_TYPE:\r\nreturn eval_num_arg(data, size, event, arg->typecast.item);\r\ncase PRINT_STRING:\r\nreturn 0;\r\nbreak;\r\ncase PRINT_OP:\r\nif (strcmp(arg->op.op, "[") == 0) {\r\nif (arg->op.left->type != PRINT_FIELD)\r\ngoto default_op;\r\nlarg = arg->op.left;\r\nif (!larg->field.field) {\r\nlarg->field.field =\r\nfind_any_field(event, larg->field.name);\r\nif (!larg->field.field)\r\ndie("field %s not found", larg->field.name);\r\n}\r\nright = eval_num_arg(data, size, event, arg->op.right);\r\nval = read_size(data + larg->field.field->offset +\r\nright * long_size, long_size);\r\nbreak;\r\n}\r\ndefault_op:\r\nleft = eval_num_arg(data, size, event, arg->op.left);\r\nright = eval_num_arg(data, size, event, arg->op.right);\r\nswitch (arg->op.op[0]) {\r\ncase '|':\r\nif (arg->op.op[1])\r\nval = left || right;\r\nelse\r\nval = left | right;\r\nbreak;\r\ncase '&':\r\nif (arg->op.op[1])\r\nval = left && right;\r\nelse\r\nval = left & right;\r\nbreak;\r\ncase '<':\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\nval = left < right;\r\nbreak;\r\ncase '<':\r\nval = left << right;\r\nbreak;\r\ncase '=':\r\nval = left <= right;\r\nbreak;\r\ndefault:\r\ndie("unknown op '%s'", arg->op.op);\r\n}\r\nbreak;\r\ncase '>':\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\nval = left > right;\r\nbreak;\r\ncase '>':\r\nval = left >> right;\r\nbreak;\r\ncase '=':\r\nval = left >= right;\r\nbreak;\r\ndefault:\r\ndie("unknown op '%s'", arg->op.op);\r\n}\r\nbreak;\r\ncase '=':\r\nif (arg->op.op[1] != '=')\r\ndie("unknown op '%s'", arg->op.op);\r\nval = left == right;\r\nbreak;\r\ncase '-':\r\nval = left - right;\r\nbreak;\r\ncase '+':\r\nval = left + right;\r\nbreak;\r\ndefault:\r\ndie("unknown op '%s'", arg->op.op);\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn val;\r\n}\r\nunsigned long long eval_flag(const char *flag)\r\n{\r\nint i;\r\nif (isdigit(flag[0]))\r\nreturn strtoull(flag, NULL, 0);\r\nfor (i = 0; i < (int)(sizeof(flags)/sizeof(flags[0])); i++)\r\nif (strcmp(flags[i].name, flag) == 0)\r\nreturn flags[i].value;\r\nreturn 0;\r\n}\r\nstatic void print_str_arg(void *data, int size,\r\nstruct event *event, struct print_arg *arg)\r\n{\r\nstruct print_flag_sym *flag;\r\nunsigned long long val, fval;\r\nchar *str;\r\nint print;\r\nswitch (arg->type) {\r\ncase PRINT_NULL:\r\nreturn;\r\ncase PRINT_ATOM:\r\nprintf("%s", arg->atom.atom);\r\nreturn;\r\ncase PRINT_FIELD:\r\nif (!arg->field.field) {\r\narg->field.field = find_any_field(event, arg->field.name);\r\nif (!arg->field.field)\r\ndie("field %s not found", arg->field.name);\r\n}\r\nstr = malloc_or_die(arg->field.field->size + 1);\r\nmemcpy(str, data + arg->field.field->offset,\r\narg->field.field->size);\r\nstr[arg->field.field->size] = 0;\r\nprintf("%s", str);\r\nfree(str);\r\nbreak;\r\ncase PRINT_FLAGS:\r\nval = eval_num_arg(data, size, event, arg->flags.field);\r\nprint = 0;\r\nfor (flag = arg->flags.flags; flag; flag = flag->next) {\r\nfval = eval_flag(flag->value);\r\nif (!val && !fval) {\r\nprintf("%s", flag->str);\r\nbreak;\r\n}\r\nif (fval && (val & fval) == fval) {\r\nif (print && arg->flags.delim)\r\nprintf("%s", arg->flags.delim);\r\nprintf("%s", flag->str);\r\nprint = 1;\r\nval &= ~fval;\r\n}\r\n}\r\nbreak;\r\ncase PRINT_SYMBOL:\r\nval = eval_num_arg(data, size, event, arg->symbol.field);\r\nfor (flag = arg->symbol.symbols; flag; flag = flag->next) {\r\nfval = eval_flag(flag->value);\r\nif (val == fval) {\r\nprintf("%s", flag->str);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase PRINT_TYPE:\r\nbreak;\r\ncase PRINT_STRING: {\r\nint str_offset;\r\nif (arg->string.offset == -1) {\r\nstruct format_field *f;\r\nf = find_any_field(event, arg->string.string);\r\narg->string.offset = f->offset;\r\n}\r\nstr_offset = *(int *)(data + arg->string.offset);\r\nstr_offset &= 0xffff;\r\nprintf("%s", ((char *)data) + str_offset);\r\nbreak;\r\n}\r\ncase PRINT_OP:\r\nif (arg->op.op[0] != '?')\r\nreturn;\r\nval = eval_num_arg(data, size, event, arg->op.left);\r\nif (val)\r\nprint_str_arg(data, size, event, arg->op.right->op.left);\r\nelse\r\nprint_str_arg(data, size, event, arg->op.right->op.right);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic struct print_arg *make_bprint_args(char *fmt, void *data, int size, struct event *event)\r\n{\r\nstatic struct format_field *field, *ip_field;\r\nstruct print_arg *args, *arg, **next;\r\nunsigned long long ip, val;\r\nchar *ptr;\r\nvoid *bptr;\r\nif (!field) {\r\nfield = find_field(event, "buf");\r\nif (!field)\r\ndie("can't find buffer field for binary printk");\r\nip_field = find_field(event, "ip");\r\nif (!ip_field)\r\ndie("can't find ip field for binary printk");\r\n}\r\nip = read_size(data + ip_field->offset, ip_field->size);\r\nargs = malloc_or_die(sizeof(*args));\r\narg = args;\r\narg->next = NULL;\r\nnext = &arg->next;\r\narg->type = PRINT_ATOM;\r\narg->atom.atom = malloc_or_die(32);\r\nsprintf(arg->atom.atom, "%lld", ip);\r\nfor (ptr = fmt + 6, bptr = data + field->offset;\r\nbptr < data + size && *ptr; ptr++) {\r\nint ls = 0;\r\nif (*ptr == '%') {\r\nprocess_again:\r\nptr++;\r\nswitch (*ptr) {\r\ncase '%':\r\nbreak;\r\ncase 'l':\r\nls++;\r\ngoto process_again;\r\ncase 'L':\r\nls = 2;\r\ngoto process_again;\r\ncase '0' ... '9':\r\ngoto process_again;\r\ncase 'p':\r\nls = 1;\r\ncase 'd':\r\ncase 'u':\r\ncase 'x':\r\ncase 'i':\r\nbptr = (void *)(((unsigned long)bptr + 3) &\r\n~3);\r\nswitch (ls) {\r\ncase 0:\r\ncase 1:\r\nls = long_size;\r\nbreak;\r\ncase 2:\r\nls = 8;\r\ndefault:\r\nbreak;\r\n}\r\nval = read_size(bptr, ls);\r\nbptr += ls;\r\narg = malloc_or_die(sizeof(*arg));\r\narg->next = NULL;\r\narg->type = PRINT_ATOM;\r\narg->atom.atom = malloc_or_die(32);\r\nsprintf(arg->atom.atom, "%lld", val);\r\n*next = arg;\r\nnext = &arg->next;\r\nbreak;\r\ncase 's':\r\narg = malloc_or_die(sizeof(*arg));\r\narg->next = NULL;\r\narg->type = PRINT_STRING;\r\narg->string.string = strdup(bptr);\r\nbptr += strlen(bptr) + 1;\r\n*next = arg;\r\nnext = &arg->next;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn args;\r\n}\r\nstatic void free_args(struct print_arg *args)\r\n{\r\nstruct print_arg *next;\r\nwhile (args) {\r\nnext = args->next;\r\nif (args->type == PRINT_ATOM)\r\nfree(args->atom.atom);\r\nelse\r\nfree(args->string.string);\r\nfree(args);\r\nargs = next;\r\n}\r\n}\r\nstatic char *get_bprint_format(void *data, int size __unused, struct event *event)\r\n{\r\nunsigned long long addr;\r\nstatic struct format_field *field;\r\nstruct printk_map *printk;\r\nchar *format;\r\nchar *p;\r\nif (!field) {\r\nfield = find_field(event, "fmt");\r\nif (!field)\r\ndie("can't find format field for binary printk");\r\nprintf("field->offset = %d size=%d\n", field->offset, field->size);\r\n}\r\naddr = read_size(data + field->offset, field->size);\r\nprintk = find_printk(addr);\r\nif (!printk) {\r\nformat = malloc_or_die(45);\r\nsprintf(format, "%%pf : (NO FORMAT FOUND at %llx)\n",\r\naddr);\r\nreturn format;\r\n}\r\np = printk->printk;\r\nif (*p == '"')\r\np++;\r\nformat = malloc_or_die(strlen(p) + 10);\r\nsprintf(format, "%s : %s", "%pf", p);\r\np = format + strlen(format) - 1;\r\nif (*p == '"')\r\n*p = 0;\r\np -= 2;\r\nif (strcmp(p, "\\n") == 0)\r\n*p = 0;\r\nreturn format;\r\n}\r\nstatic void pretty_print(void *data, int size, struct event *event)\r\n{\r\nstruct print_fmt *print_fmt = &event->print_fmt;\r\nstruct print_arg *arg = print_fmt->args;\r\nstruct print_arg *args = NULL;\r\nconst char *ptr = print_fmt->format;\r\nunsigned long long val;\r\nstruct func_map *func;\r\nconst char *saveptr;\r\nchar *bprint_fmt = NULL;\r\nchar format[32];\r\nint show_func;\r\nint len;\r\nint ls;\r\nif (event->flags & EVENT_FL_ISFUNC)\r\nptr = " %pF <-- %pF";\r\nif (event->flags & EVENT_FL_ISBPRINT) {\r\nbprint_fmt = get_bprint_format(data, size, event);\r\nargs = make_bprint_args(bprint_fmt, data, size, event);\r\narg = args;\r\nptr = bprint_fmt;\r\n}\r\nfor (; *ptr; ptr++) {\r\nls = 0;\r\nif (*ptr == '\\') {\r\nptr++;\r\nswitch (*ptr) {\r\ncase 'n':\r\nprintf("\n");\r\nbreak;\r\ncase 't':\r\nprintf("\t");\r\nbreak;\r\ncase 'r':\r\nprintf("\r");\r\nbreak;\r\ncase '\\':\r\nprintf("\\");\r\nbreak;\r\ndefault:\r\nprintf("%c", *ptr);\r\nbreak;\r\n}\r\n} else if (*ptr == '%') {\r\nsaveptr = ptr;\r\nshow_func = 0;\r\ncont_process:\r\nptr++;\r\nswitch (*ptr) {\r\ncase '%':\r\nprintf("%%");\r\nbreak;\r\ncase 'l':\r\nls++;\r\ngoto cont_process;\r\ncase 'L':\r\nls = 2;\r\ngoto cont_process;\r\ncase 'z':\r\ncase 'Z':\r\ncase '0' ... '9':\r\ngoto cont_process;\r\ncase 'p':\r\nif (long_size == 4)\r\nls = 1;\r\nelse\r\nls = 2;\r\nif (*(ptr+1) == 'F' ||\r\n*(ptr+1) == 'f') {\r\nptr++;\r\nshow_func = *ptr;\r\n}\r\ncase 'd':\r\ncase 'i':\r\ncase 'x':\r\ncase 'X':\r\ncase 'u':\r\nif (!arg)\r\ndie("no argument match");\r\nlen = ((unsigned long)ptr + 1) -\r\n(unsigned long)saveptr;\r\nif (len > 32)\r\ndie("bad format!");\r\nmemcpy(format, saveptr, len);\r\nformat[len] = 0;\r\nval = eval_num_arg(data, size, event, arg);\r\narg = arg->next;\r\nif (show_func) {\r\nfunc = find_func(val);\r\nif (func) {\r\nprintf("%s", func->func);\r\nif (show_func == 'F')\r\nprintf("+0x%llx",\r\nval - func->addr);\r\nbreak;\r\n}\r\n}\r\nswitch (ls) {\r\ncase 0:\r\nprintf(format, (int)val);\r\nbreak;\r\ncase 1:\r\nprintf(format, (long)val);\r\nbreak;\r\ncase 2:\r\nprintf(format, (long long)val);\r\nbreak;\r\ndefault:\r\ndie("bad count (%d)", ls);\r\n}\r\nbreak;\r\ncase 's':\r\nif (!arg)\r\ndie("no matching argument");\r\nprint_str_arg(data, size, event, arg);\r\narg = arg->next;\r\nbreak;\r\ndefault:\r\nprintf(">%c<", *ptr);\r\n}\r\n} else\r\nprintf("%c", *ptr);\r\n}\r\nif (args) {\r\nfree_args(args);\r\nfree(bprint_fmt);\r\n}\r\n}\r\nstatic inline int log10_cpu(int nb)\r\n{\r\nif (nb / 100)\r\nreturn 3;\r\nif (nb / 10)\r\nreturn 2;\r\nreturn 1;\r\n}\r\nstatic void print_lat_fmt(void *data, int size __unused)\r\n{\r\nunsigned int lat_flags;\r\nunsigned int pc;\r\nint lock_depth;\r\nint hardirq;\r\nint softirq;\r\nlat_flags = parse_common_flags(data);\r\npc = parse_common_pc(data);\r\nlock_depth = parse_common_lock_depth(data);\r\nhardirq = lat_flags & TRACE_FLAG_HARDIRQ;\r\nsoftirq = lat_flags & TRACE_FLAG_SOFTIRQ;\r\nprintf("%c%c%c",\r\n(lat_flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\r\n(lat_flags & TRACE_FLAG_IRQS_NOSUPPORT) ?\r\n'X' : '.',\r\n(lat_flags & TRACE_FLAG_NEED_RESCHED) ?\r\n'N' : '.',\r\n(hardirq && softirq) ? 'H' :\r\nhardirq ? 'h' : softirq ? 's' : '.');\r\nif (pc)\r\nprintf("%x", pc);\r\nelse\r\nprintf(".");\r\nif (lock_depth < 0)\r\nprintf(". ");\r\nelse\r\nprintf("%d ", lock_depth);\r\n}\r\nstatic struct record *\r\nget_return_for_leaf(int cpu, int cur_pid, unsigned long long cur_func,\r\nstruct record *next)\r\n{\r\nstruct format_field *field;\r\nstruct event *event;\r\nunsigned long val;\r\nint type;\r\nint pid;\r\ntype = trace_parse_common_type(next->data);\r\nevent = trace_find_event(type);\r\nif (!event)\r\nreturn NULL;\r\nif (!(event->flags & EVENT_FL_ISFUNCRET))\r\nreturn NULL;\r\npid = trace_parse_common_pid(next->data);\r\nfield = find_field(event, "func");\r\nif (!field)\r\ndie("function return does not have field func");\r\nval = read_size(next->data + field->offset, field->size);\r\nif (cur_pid != pid || cur_func != val)\r\nreturn NULL;\r\nreturn trace_read_data(cpu);\r\n}\r\nstatic void print_graph_overhead(unsigned long long duration)\r\n{\r\nif (duration == ~0ULL)\r\nreturn (void)printf(" ");\r\nif (duration > 100000ULL)\r\nreturn (void)printf("! ");\r\nif (duration > 10000ULL)\r\nreturn (void)printf("+ ");\r\nprintf(" ");\r\n}\r\nstatic void print_graph_duration(unsigned long long duration)\r\n{\r\nunsigned long usecs = duration / 1000;\r\nunsigned long nsecs_rem = duration % 1000;\r\nchar msecs_str[21];\r\nchar nsecs_str[5];\r\nint len;\r\nint i;\r\nsprintf(msecs_str, "%lu", usecs);\r\nlen = printf("%lu", usecs);\r\nif (len < 7) {\r\nsnprintf(nsecs_str, 8 - len, "%03lu", nsecs_rem);\r\nlen += printf(".%s", nsecs_str);\r\n}\r\nprintf(" us ");\r\nfor (i = len; i < 7; i++)\r\nprintf(" ");\r\nprintf("| ");\r\n}\r\nstatic void\r\nprint_graph_entry_leaf(struct event *event, void *data, struct record *ret_rec)\r\n{\r\nunsigned long long rettime, calltime;\r\nunsigned long long duration, depth;\r\nunsigned long long val;\r\nstruct format_field *field;\r\nstruct func_map *func;\r\nstruct event *ret_event;\r\nint type;\r\nint i;\r\ntype = trace_parse_common_type(ret_rec->data);\r\nret_event = trace_find_event(type);\r\nfield = find_field(ret_event, "rettime");\r\nif (!field)\r\ndie("can't find rettime in return graph");\r\nrettime = read_size(ret_rec->data + field->offset, field->size);\r\nfield = find_field(ret_event, "calltime");\r\nif (!field)\r\ndie("can't find rettime in return graph");\r\ncalltime = read_size(ret_rec->data + field->offset, field->size);\r\nduration = rettime - calltime;\r\nprint_graph_overhead(duration);\r\nprint_graph_duration(duration);\r\nfield = find_field(event, "depth");\r\nif (!field)\r\ndie("can't find depth in entry graph");\r\ndepth = read_size(data + field->offset, field->size);\r\nfor (i = 0; i < (int)(depth * TRACE_GRAPH_INDENT); i++)\r\nprintf(" ");\r\nfield = find_field(event, "func");\r\nif (!field)\r\ndie("can't find func in entry graph");\r\nval = read_size(data + field->offset, field->size);\r\nfunc = find_func(val);\r\nif (func)\r\nprintf("%s();", func->func);\r\nelse\r\nprintf("%llx();", val);\r\n}\r\nstatic void print_graph_nested(struct event *event, void *data)\r\n{\r\nstruct format_field *field;\r\nunsigned long long depth;\r\nunsigned long long val;\r\nstruct func_map *func;\r\nint i;\r\nprint_graph_overhead(-1);\r\nprintf(" | ");\r\nfield = find_field(event, "depth");\r\nif (!field)\r\ndie("can't find depth in entry graph");\r\ndepth = read_size(data + field->offset, field->size);\r\nfor (i = 0; i < (int)(depth * TRACE_GRAPH_INDENT); i++)\r\nprintf(" ");\r\nfield = find_field(event, "func");\r\nif (!field)\r\ndie("can't find func in entry graph");\r\nval = read_size(data + field->offset, field->size);\r\nfunc = find_func(val);\r\nif (func)\r\nprintf("%s() {", func->func);\r\nelse\r\nprintf("%llx() {", val);\r\n}\r\nstatic void\r\npretty_print_func_ent(void *data, int size, struct event *event,\r\nint cpu, int pid)\r\n{\r\nstruct format_field *field;\r\nstruct record *rec;\r\nvoid *copy_data;\r\nunsigned long val;\r\nif (latency_format) {\r\nprint_lat_fmt(data, size);\r\nprintf(" | ");\r\n}\r\nfield = find_field(event, "func");\r\nif (!field)\r\ndie("function entry does not have func field");\r\nval = read_size(data + field->offset, field->size);\r\ncopy_data = malloc_or_die(size);\r\nmemcpy(copy_data, data, size);\r\ndata = copy_data;\r\nrec = trace_peek_data(cpu);\r\nif (rec) {\r\nrec = get_return_for_leaf(cpu, pid, val, rec);\r\nif (rec) {\r\nprint_graph_entry_leaf(event, data, rec);\r\ngoto out_free;\r\n}\r\n}\r\nprint_graph_nested(event, data);\r\nout_free:\r\nfree(data);\r\n}\r\nstatic void\r\npretty_print_func_ret(void *data, int size __unused, struct event *event)\r\n{\r\nunsigned long long rettime, calltime;\r\nunsigned long long duration, depth;\r\nstruct format_field *field;\r\nint i;\r\nif (latency_format) {\r\nprint_lat_fmt(data, size);\r\nprintf(" | ");\r\n}\r\nfield = find_field(event, "rettime");\r\nif (!field)\r\ndie("can't find rettime in return graph");\r\nrettime = read_size(data + field->offset, field->size);\r\nfield = find_field(event, "calltime");\r\nif (!field)\r\ndie("can't find calltime in return graph");\r\ncalltime = read_size(data + field->offset, field->size);\r\nduration = rettime - calltime;\r\nprint_graph_overhead(duration);\r\nprint_graph_duration(duration);\r\nfield = find_field(event, "depth");\r\nif (!field)\r\ndie("can't find depth in entry graph");\r\ndepth = read_size(data + field->offset, field->size);\r\nfor (i = 0; i < (int)(depth * TRACE_GRAPH_INDENT); i++)\r\nprintf(" ");\r\nprintf("}");\r\n}\r\nstatic void\r\npretty_print_func_graph(void *data, int size, struct event *event,\r\nint cpu, int pid)\r\n{\r\nif (event->flags & EVENT_FL_ISFUNCENT)\r\npretty_print_func_ent(data, size, event, cpu, pid);\r\nelse if (event->flags & EVENT_FL_ISFUNCRET)\r\npretty_print_func_ret(data, size, event);\r\nprintf("\n");\r\n}\r\nvoid print_trace_event(int cpu, void *data, int size)\r\n{\r\nstruct event *event;\r\nint type;\r\nint pid;\r\ntype = trace_parse_common_type(data);\r\nevent = trace_find_event(type);\r\nif (!event) {\r\nwarning("ug! no event found for type %d", type);\r\nreturn;\r\n}\r\npid = trace_parse_common_pid(data);\r\nif (event->flags & (EVENT_FL_ISFUNCENT | EVENT_FL_ISFUNCRET))\r\nreturn pretty_print_func_graph(data, size, event, cpu, pid);\r\nif (latency_format)\r\nprint_lat_fmt(data, size);\r\nif (event->flags & EVENT_FL_FAILED) {\r\nprintf("EVENT '%s' FAILED TO PARSE\n",\r\nevent->name);\r\nreturn;\r\n}\r\npretty_print(data, size, event);\r\n}\r\nstatic void print_fields(struct print_flag_sym *field)\r\n{\r\nprintf("{ %s, %s }", field->value, field->str);\r\nif (field->next) {\r\nprintf(", ");\r\nprint_fields(field->next);\r\n}\r\n}\r\nstatic void print_args(struct print_arg *args)\r\n{\r\nint print_paren = 1;\r\nswitch (args->type) {\r\ncase PRINT_NULL:\r\nprintf("null");\r\nbreak;\r\ncase PRINT_ATOM:\r\nprintf("%s", args->atom.atom);\r\nbreak;\r\ncase PRINT_FIELD:\r\nprintf("REC->%s", args->field.name);\r\nbreak;\r\ncase PRINT_FLAGS:\r\nprintf("__print_flags(");\r\nprint_args(args->flags.field);\r\nprintf(", %s, ", args->flags.delim);\r\nprint_fields(args->flags.flags);\r\nprintf(")");\r\nbreak;\r\ncase PRINT_SYMBOL:\r\nprintf("__print_symbolic(");\r\nprint_args(args->symbol.field);\r\nprintf(", ");\r\nprint_fields(args->symbol.symbols);\r\nprintf(")");\r\nbreak;\r\ncase PRINT_STRING:\r\nprintf("__get_str(%s)", args->string.string);\r\nbreak;\r\ncase PRINT_TYPE:\r\nprintf("(%s)", args->typecast.type);\r\nprint_args(args->typecast.item);\r\nbreak;\r\ncase PRINT_OP:\r\nif (strcmp(args->op.op, ":") == 0)\r\nprint_paren = 0;\r\nif (print_paren)\r\nprintf("(");\r\nprint_args(args->op.left);\r\nprintf(" %s ", args->op.op);\r\nprint_args(args->op.right);\r\nif (print_paren)\r\nprintf(")");\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (args->next) {\r\nprintf("\n");\r\nprint_args(args->next);\r\n}\r\n}\r\nint parse_ftrace_file(char *buf, unsigned long size)\r\n{\r\nstruct format_field *field;\r\nstruct print_arg *arg, **list;\r\nstruct event *event;\r\nint ret;\r\ninit_input_buf(buf, size);\r\nevent = alloc_event();\r\nif (!event)\r\nreturn -ENOMEM;\r\nevent->flags |= EVENT_FL_ISFTRACE;\r\nevent->name = event_read_name();\r\nif (!event->name)\r\ndie("failed to read ftrace event name");\r\nif (strcmp(event->name, "function") == 0)\r\nevent->flags |= EVENT_FL_ISFUNC;\r\nelse if (strcmp(event->name, "funcgraph_entry") == 0)\r\nevent->flags |= EVENT_FL_ISFUNCENT;\r\nelse if (strcmp(event->name, "funcgraph_exit") == 0)\r\nevent->flags |= EVENT_FL_ISFUNCRET;\r\nelse if (strcmp(event->name, "bprint") == 0)\r\nevent->flags |= EVENT_FL_ISBPRINT;\r\nevent->id = event_read_id();\r\nif (event->id < 0)\r\ndie("failed to read ftrace event id");\r\nadd_event(event);\r\nret = event_read_format(event);\r\nif (ret < 0)\r\ndie("failed to read ftrace event format");\r\nret = event_read_print(event);\r\nif (ret < 0)\r\ndie("failed to read ftrace event print fmt");\r\nif (ret > 0)\r\nreturn 0;\r\nlist = &event->print_fmt.args;\r\nfor (field = event->format.fields; field; field = field->next) {\r\narg = malloc_or_die(sizeof(*arg));\r\nmemset(arg, 0, sizeof(*arg));\r\n*list = arg;\r\nlist = &arg->next;\r\narg->type = PRINT_FIELD;\r\narg->field.name = field->name;\r\narg->field.field = field;\r\n}\r\nreturn 0;\r\n}\r\nint parse_event_file(char *buf, unsigned long size, char *sys)\r\n{\r\nstruct event *event;\r\nint ret;\r\ninit_input_buf(buf, size);\r\nevent = alloc_event();\r\nif (!event)\r\nreturn -ENOMEM;\r\nevent->name = event_read_name();\r\nif (!event->name)\r\ndie("failed to read event name");\r\nevent->id = event_read_id();\r\nif (event->id < 0)\r\ndie("failed to read event id");\r\nret = event_read_format(event);\r\nif (ret < 0) {\r\nwarning("failed to read event format for %s", event->name);\r\ngoto event_failed;\r\n}\r\nret = event_read_print(event);\r\nif (ret < 0) {\r\nwarning("failed to read event print fmt for %s", event->name);\r\ngoto event_failed;\r\n}\r\nevent->system = strdup(sys);\r\n#define PRINT_ARGS 0\r\nif (PRINT_ARGS && event->print_fmt.args)\r\nprint_args(event->print_fmt.args);\r\nadd_event(event);\r\nreturn 0;\r\nevent_failed:\r\nevent->flags |= EVENT_FL_FAILED;\r\nadd_event(event);\r\nreturn -1;\r\n}\r\nvoid parse_set_info(int nr_cpus, int long_sz)\r\n{\r\ncpus = nr_cpus;\r\nlong_size = long_sz;\r\n}\r\nint common_pc(struct scripting_context *context)\r\n{\r\nreturn parse_common_pc(context->event_data);\r\n}\r\nint common_flags(struct scripting_context *context)\r\n{\r\nreturn parse_common_flags(context->event_data);\r\n}\r\nint common_lock_depth(struct scripting_context *context)\r\n{\r\nreturn parse_common_lock_depth(context->event_data);\r\n}
