static int __init mpf_checksum(unsigned char *mp, int len)\r\n{\r\nint sum = 0;\r\nwhile (len--)\r\nsum += *mp++;\r\nreturn sum & 0xFF;\r\n}\r\nint __init default_mpc_apic_id(struct mpc_cpu *m)\r\n{\r\nreturn m->apicid;\r\n}\r\nstatic void __init MP_processor_info(struct mpc_cpu *m)\r\n{\r\nint apicid;\r\nchar *bootup_cpu = "";\r\nif (!(m->cpuflag & CPU_ENABLED)) {\r\ndisabled_cpus++;\r\nreturn;\r\n}\r\napicid = x86_init.mpparse.mpc_apic_id(m);\r\nif (m->cpuflag & CPU_BOOTPROCESSOR) {\r\nbootup_cpu = " (Bootup-CPU)";\r\nboot_cpu_physical_apicid = m->apicid;\r\n}\r\nprintk(KERN_INFO "Processor #%d%s\n", m->apicid, bootup_cpu);\r\ngeneric_processor_info(apicid, m->apicver);\r\n}\r\nvoid __init default_mpc_oem_bus_info(struct mpc_bus *m, char *str)\r\n{\r\nmemcpy(str, m->bustype, 6);\r\nstr[6] = 0;\r\napic_printk(APIC_VERBOSE, "Bus #%d is %s\n", m->busid, str);\r\n}\r\nstatic void __init MP_bus_info(struct mpc_bus *m)\r\n{\r\nchar str[7];\r\nx86_init.mpparse.mpc_oem_bus_info(m, str);\r\n#if MAX_MP_BUSSES < 256\r\nif (m->busid >= MAX_MP_BUSSES) {\r\nprintk(KERN_WARNING "MP table busid value (%d) for bustype %s "\r\n" is too large, max. supported is %d\n",\r\nm->busid, str, MAX_MP_BUSSES - 1);\r\nreturn;\r\n}\r\n#endif\r\nif (strncmp(str, BUSTYPE_ISA, sizeof(BUSTYPE_ISA) - 1) == 0) {\r\nset_bit(m->busid, mp_bus_not_pci);\r\n#if defined(CONFIG_EISA) || defined(CONFIG_MCA)\r\nmp_bus_id_to_type[m->busid] = MP_BUS_ISA;\r\n#endif\r\n} else if (strncmp(str, BUSTYPE_PCI, sizeof(BUSTYPE_PCI) - 1) == 0) {\r\nif (x86_init.mpparse.mpc_oem_pci_bus)\r\nx86_init.mpparse.mpc_oem_pci_bus(m);\r\nclear_bit(m->busid, mp_bus_not_pci);\r\n#if defined(CONFIG_EISA) || defined(CONFIG_MCA)\r\nmp_bus_id_to_type[m->busid] = MP_BUS_PCI;\r\n} else if (strncmp(str, BUSTYPE_EISA, sizeof(BUSTYPE_EISA) - 1) == 0) {\r\nmp_bus_id_to_type[m->busid] = MP_BUS_EISA;\r\n} else if (strncmp(str, BUSTYPE_MCA, sizeof(BUSTYPE_MCA) - 1) == 0) {\r\nmp_bus_id_to_type[m->busid] = MP_BUS_MCA;\r\n#endif\r\n} else\r\nprintk(KERN_WARNING "Unknown bustype %s - ignoring\n", str);\r\n}\r\nstatic void __init MP_ioapic_info(struct mpc_ioapic *m)\r\n{\r\nif (m->flags & MPC_APIC_USABLE)\r\nmp_register_ioapic(m->apicid, m->apicaddr, gsi_top);\r\n}\r\nstatic void __init print_mp_irq_info(struct mpc_intsrc *mp_irq)\r\n{\r\napic_printk(APIC_VERBOSE, "Int: type %d, pol %d, trig %d, bus %02x,"\r\n" IRQ %02x, APIC ID %x, APIC INT %02x\n",\r\nmp_irq->irqtype, mp_irq->irqflag & 3,\r\n(mp_irq->irqflag >> 2) & 3, mp_irq->srcbus,\r\nmp_irq->srcbusirq, mp_irq->dstapic, mp_irq->dstirq);\r\n}\r\nstatic inline void __init MP_bus_info(struct mpc_bus *m) {}\r\nstatic inline void __init MP_ioapic_info(struct mpc_ioapic *m) {}\r\nstatic void __init MP_lintsrc_info(struct mpc_lintsrc *m)\r\n{\r\napic_printk(APIC_VERBOSE, "Lint: type %d, pol %d, trig %d, bus %02x,"\r\n" IRQ %02x, APIC ID %x, APIC LINT %02x\n",\r\nm->irqtype, m->irqflag & 3, (m->irqflag >> 2) & 3, m->srcbusid,\r\nm->srcbusirq, m->destapic, m->destapiclint);\r\n}\r\nstatic int __init smp_check_mpc(struct mpc_table *mpc, char *oem, char *str)\r\n{\r\nif (memcmp(mpc->signature, MPC_SIGNATURE, 4)) {\r\nprintk(KERN_ERR "MPTABLE: bad signature [%c%c%c%c]!\n",\r\nmpc->signature[0], mpc->signature[1],\r\nmpc->signature[2], mpc->signature[3]);\r\nreturn 0;\r\n}\r\nif (mpf_checksum((unsigned char *)mpc, mpc->length)) {\r\nprintk(KERN_ERR "MPTABLE: checksum error!\n");\r\nreturn 0;\r\n}\r\nif (mpc->spec != 0x01 && mpc->spec != 0x04) {\r\nprintk(KERN_ERR "MPTABLE: bad table version (%d)!!\n",\r\nmpc->spec);\r\nreturn 0;\r\n}\r\nif (!mpc->lapic) {\r\nprintk(KERN_ERR "MPTABLE: null local APIC address!\n");\r\nreturn 0;\r\n}\r\nmemcpy(oem, mpc->oem, 8);\r\noem[8] = 0;\r\nprintk(KERN_INFO "MPTABLE: OEM ID: %s\n", oem);\r\nmemcpy(str, mpc->productid, 12);\r\nstr[12] = 0;\r\nprintk(KERN_INFO "MPTABLE: Product ID: %s\n", str);\r\nprintk(KERN_INFO "MPTABLE: APIC at: 0x%X\n", mpc->lapic);\r\nreturn 1;\r\n}\r\nstatic void skip_entry(unsigned char **ptr, int *count, int size)\r\n{\r\n*ptr += size;\r\n*count += size;\r\n}\r\nstatic void __init smp_dump_mptable(struct mpc_table *mpc, unsigned char *mpt)\r\n{\r\nprintk(KERN_ERR "Your mptable is wrong, contact your HW vendor!\n"\r\n"type %x\n", *mpt);\r\nprint_hex_dump(KERN_ERR, " ", DUMP_PREFIX_ADDRESS, 16,\r\n1, mpc, mpc->length, 1);\r\n}\r\nvoid __init default_smp_read_mpc_oem(struct mpc_table *mpc) { }\r\nstatic int __init smp_read_mpc(struct mpc_table *mpc, unsigned early)\r\n{\r\nchar str[16];\r\nchar oem[10];\r\nint count = sizeof(*mpc);\r\nunsigned char *mpt = ((unsigned char *)mpc) + count;\r\nif (!smp_check_mpc(mpc, oem, str))\r\nreturn 0;\r\n#ifdef CONFIG_X86_32\r\ngeneric_mps_oem_check(mpc, oem, str);\r\n#endif\r\nif (!acpi_lapic)\r\nregister_lapic_address(mpc->lapic);\r\nif (early)\r\nreturn 1;\r\nif (mpc->oemptr)\r\nx86_init.mpparse.smp_read_mpc_oem(mpc);\r\nx86_init.mpparse.mpc_record(0);\r\nwhile (count < mpc->length) {\r\nswitch (*mpt) {\r\ncase MP_PROCESSOR:\r\nif (!acpi_lapic)\r\nMP_processor_info((struct mpc_cpu *)mpt);\r\nskip_entry(&mpt, &count, sizeof(struct mpc_cpu));\r\nbreak;\r\ncase MP_BUS:\r\nMP_bus_info((struct mpc_bus *)mpt);\r\nskip_entry(&mpt, &count, sizeof(struct mpc_bus));\r\nbreak;\r\ncase MP_IOAPIC:\r\nMP_ioapic_info((struct mpc_ioapic *)mpt);\r\nskip_entry(&mpt, &count, sizeof(struct mpc_ioapic));\r\nbreak;\r\ncase MP_INTSRC:\r\nmp_save_irq((struct mpc_intsrc *)mpt);\r\nskip_entry(&mpt, &count, sizeof(struct mpc_intsrc));\r\nbreak;\r\ncase MP_LINTSRC:\r\nMP_lintsrc_info((struct mpc_lintsrc *)mpt);\r\nskip_entry(&mpt, &count, sizeof(struct mpc_lintsrc));\r\nbreak;\r\ndefault:\r\nsmp_dump_mptable(mpc, mpt);\r\ncount = mpc->length;\r\nbreak;\r\n}\r\nx86_init.mpparse.mpc_record(1);\r\n}\r\nif (!num_processors)\r\nprintk(KERN_ERR "MPTABLE: no processors registered!\n");\r\nreturn num_processors;\r\n}\r\nstatic int __init ELCR_trigger(unsigned int irq)\r\n{\r\nunsigned int port;\r\nport = 0x4d0 + (irq >> 3);\r\nreturn (inb(port) >> (irq & 7)) & 1;\r\n}\r\nstatic void __init construct_default_ioirq_mptable(int mpc_default_type)\r\n{\r\nstruct mpc_intsrc intsrc;\r\nint i;\r\nint ELCR_fallback = 0;\r\nintsrc.type = MP_INTSRC;\r\nintsrc.irqflag = 0;\r\nintsrc.srcbus = 0;\r\nintsrc.dstapic = mpc_ioapic_id(0);\r\nintsrc.irqtype = mp_INT;\r\nif (mpc_default_type == 5) {\r\nprintk(KERN_INFO "ISA/PCI bus type with no IRQ information... "\r\n"falling back to ELCR\n");\r\nif (ELCR_trigger(0) || ELCR_trigger(1) || ELCR_trigger(2) ||\r\nELCR_trigger(13))\r\nprintk(KERN_ERR "ELCR contains invalid data... "\r\n"not using ELCR\n");\r\nelse {\r\nprintk(KERN_INFO\r\n"Using ELCR to identify PCI interrupts\n");\r\nELCR_fallback = 1;\r\n}\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nswitch (mpc_default_type) {\r\ncase 2:\r\nif (i == 0 || i == 13)\r\ncontinue;\r\ndefault:\r\nif (i == 2)\r\ncontinue;\r\n}\r\nif (ELCR_fallback) {\r\nif (ELCR_trigger(i))\r\nintsrc.irqflag = 13;\r\nelse\r\nintsrc.irqflag = 0;\r\n}\r\nintsrc.srcbusirq = i;\r\nintsrc.dstirq = i ? i : 2;\r\nmp_save_irq(&intsrc);\r\n}\r\nintsrc.irqtype = mp_ExtINT;\r\nintsrc.srcbusirq = 0;\r\nintsrc.dstirq = 0;\r\nmp_save_irq(&intsrc);\r\n}\r\nstatic void __init construct_ioapic_table(int mpc_default_type)\r\n{\r\nstruct mpc_ioapic ioapic;\r\nstruct mpc_bus bus;\r\nbus.type = MP_BUS;\r\nbus.busid = 0;\r\nswitch (mpc_default_type) {\r\ndefault:\r\nprintk(KERN_ERR "???\nUnknown standard configuration %d\n",\r\nmpc_default_type);\r\ncase 1:\r\ncase 5:\r\nmemcpy(bus.bustype, "ISA ", 6);\r\nbreak;\r\ncase 2:\r\ncase 6:\r\ncase 3:\r\nmemcpy(bus.bustype, "EISA ", 6);\r\nbreak;\r\ncase 4:\r\ncase 7:\r\nmemcpy(bus.bustype, "MCA ", 6);\r\n}\r\nMP_bus_info(&bus);\r\nif (mpc_default_type > 4) {\r\nbus.busid = 1;\r\nmemcpy(bus.bustype, "PCI ", 6);\r\nMP_bus_info(&bus);\r\n}\r\nioapic.type = MP_IOAPIC;\r\nioapic.apicid = 2;\r\nioapic.apicver = mpc_default_type > 4 ? 0x10 : 0x01;\r\nioapic.flags = MPC_APIC_USABLE;\r\nioapic.apicaddr = IO_APIC_DEFAULT_PHYS_BASE;\r\nMP_ioapic_info(&ioapic);\r\nconstruct_default_ioirq_mptable(mpc_default_type);\r\n}\r\nstatic inline void __init construct_ioapic_table(int mpc_default_type) { }\r\nstatic inline void __init construct_default_ISA_mptable(int mpc_default_type)\r\n{\r\nstruct mpc_cpu processor;\r\nstruct mpc_lintsrc lintsrc;\r\nint linttypes[2] = { mp_ExtINT, mp_NMI };\r\nint i;\r\nmp_lapic_addr = APIC_DEFAULT_PHYS_BASE;\r\nprocessor.type = MP_PROCESSOR;\r\nprocessor.apicver = mpc_default_type > 4 ? 0x10 : 0x01;\r\nprocessor.cpuflag = CPU_ENABLED;\r\nprocessor.cpufeature = (boot_cpu_data.x86 << 8) |\r\n(boot_cpu_data.x86_model << 4) | boot_cpu_data.x86_mask;\r\nprocessor.featureflag = boot_cpu_data.x86_capability[0];\r\nprocessor.reserved[0] = 0;\r\nprocessor.reserved[1] = 0;\r\nfor (i = 0; i < 2; i++) {\r\nprocessor.apicid = i;\r\nMP_processor_info(&processor);\r\n}\r\nconstruct_ioapic_table(mpc_default_type);\r\nlintsrc.type = MP_LINTSRC;\r\nlintsrc.irqflag = 0;\r\nlintsrc.srcbusid = 0;\r\nlintsrc.srcbusirq = 0;\r\nlintsrc.destapic = MP_APIC_ALL;\r\nfor (i = 0; i < 2; i++) {\r\nlintsrc.irqtype = linttypes[i];\r\nlintsrc.destapiclint = i;\r\nMP_lintsrc_info(&lintsrc);\r\n}\r\n}\r\nstatic unsigned long __init get_mpc_size(unsigned long physptr)\r\n{\r\nstruct mpc_table *mpc;\r\nunsigned long size;\r\nmpc = early_ioremap(physptr, PAGE_SIZE);\r\nsize = mpc->length;\r\nearly_iounmap(mpc, PAGE_SIZE);\r\napic_printk(APIC_VERBOSE, " mpc: %lx-%lx\n", physptr, physptr + size);\r\nreturn size;\r\n}\r\nstatic int __init check_physptr(struct mpf_intel *mpf, unsigned int early)\r\n{\r\nstruct mpc_table *mpc;\r\nunsigned long size;\r\nsize = get_mpc_size(mpf->physptr);\r\nmpc = early_ioremap(mpf->physptr, size);\r\nif (!smp_read_mpc(mpc, early)) {\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nsmp_found_config = 0;\r\n#endif\r\nprintk(KERN_ERR "BIOS bug, MP table errors detected!...\n"\r\n"... disabling SMP support. (tell your hw vendor)\n");\r\nearly_iounmap(mpc, size);\r\nreturn -1;\r\n}\r\nearly_iounmap(mpc, size);\r\nif (early)\r\nreturn -1;\r\n#ifdef CONFIG_X86_IO_APIC\r\nif (!mp_irq_entries) {\r\nstruct mpc_bus bus;\r\nprintk(KERN_ERR "BIOS bug, no explicit IRQ entries, "\r\n"using default mptable. (tell your hw vendor)\n");\r\nbus.type = MP_BUS;\r\nbus.busid = 0;\r\nmemcpy(bus.bustype, "ISA ", 6);\r\nMP_bus_info(&bus);\r\nconstruct_default_ioirq_mptable(0);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid __init default_get_smp_config(unsigned int early)\r\n{\r\nstruct mpf_intel *mpf = mpf_found;\r\nif (!mpf)\r\nreturn;\r\nif (acpi_lapic && early)\r\nreturn;\r\nif (acpi_lapic && acpi_ioapic)\r\nreturn;\r\nprintk(KERN_INFO "Intel MultiProcessor Specification v1.%d\n",\r\nmpf->specification);\r\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86_32)\r\nif (mpf->feature2 & (1 << 7)) {\r\nprintk(KERN_INFO " IMCR and PIC compatibility mode.\n");\r\npic_mode = 1;\r\n} else {\r\nprintk(KERN_INFO " Virtual Wire compatibility mode.\n");\r\npic_mode = 0;\r\n}\r\n#endif\r\nif (mpf->feature1 != 0) {\r\nif (early) {\r\nmp_lapic_addr = APIC_DEFAULT_PHYS_BASE;\r\nreturn;\r\n}\r\nprintk(KERN_INFO "Default MP configuration #%d\n",\r\nmpf->feature1);\r\nconstruct_default_ISA_mptable(mpf->feature1);\r\n} else if (mpf->physptr) {\r\nif (check_physptr(mpf, early))\r\nreturn;\r\n} else\r\nBUG();\r\nif (!early)\r\nprintk(KERN_INFO "Processors: %d\n", num_processors);\r\n}\r\nstatic void __init smp_reserve_memory(struct mpf_intel *mpf)\r\n{\r\nunsigned long size = get_mpc_size(mpf->physptr);\r\nmemblock_x86_reserve_range(mpf->physptr, mpf->physptr+size, "* MP-table mpc");\r\n}\r\nstatic int __init smp_scan_config(unsigned long base, unsigned long length)\r\n{\r\nunsigned int *bp = phys_to_virt(base);\r\nstruct mpf_intel *mpf;\r\nunsigned long mem;\r\napic_printk(APIC_VERBOSE, "Scan SMP from %p for %ld bytes.\n",\r\nbp, length);\r\nBUILD_BUG_ON(sizeof(*mpf) != 16);\r\nwhile (length > 0) {\r\nmpf = (struct mpf_intel *)bp;\r\nif ((*bp == SMP_MAGIC_IDENT) &&\r\n(mpf->length == 1) &&\r\n!mpf_checksum((unsigned char *)bp, 16) &&\r\n((mpf->specification == 1)\r\n|| (mpf->specification == 4))) {\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nsmp_found_config = 1;\r\n#endif\r\nmpf_found = mpf;\r\nprintk(KERN_INFO "found SMP MP-table at [%p] %llx\n",\r\nmpf, (u64)virt_to_phys(mpf));\r\nmem = virt_to_phys(mpf);\r\nmemblock_x86_reserve_range(mem, mem + sizeof(*mpf), "* MP-table mpf");\r\nif (mpf->physptr)\r\nsmp_reserve_memory(mpf);\r\nreturn 1;\r\n}\r\nbp += 4;\r\nlength -= 16;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init default_find_smp_config(void)\r\n{\r\nunsigned int address;\r\nif (smp_scan_config(0x0, 0x400) ||\r\nsmp_scan_config(639 * 0x400, 0x400) ||\r\nsmp_scan_config(0xF0000, 0x10000))\r\nreturn;\r\naddress = get_bios_ebda();\r\nif (address)\r\nsmp_scan_config(address, 0x400);\r\n}\r\nstatic int __init get_MP_intsrc_index(struct mpc_intsrc *m)\r\n{\r\nint i;\r\nif (m->irqtype != mp_INT)\r\nreturn 0;\r\nif (m->irqflag != 0x0f)\r\nreturn 0;\r\nfor (i = 0; i < mp_irq_entries; i++) {\r\nif (mp_irqs[i].irqtype != mp_INT)\r\ncontinue;\r\nif (mp_irqs[i].irqflag != 0x0f)\r\ncontinue;\r\nif (mp_irqs[i].srcbus != m->srcbus)\r\ncontinue;\r\nif (mp_irqs[i].srcbusirq != m->srcbusirq)\r\ncontinue;\r\nif (irq_used[i]) {\r\nreturn -2;\r\n}\r\nirq_used[i] = 1;\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic void __init check_irq_src(struct mpc_intsrc *m, int *nr_m_spare)\r\n{\r\nint i;\r\napic_printk(APIC_VERBOSE, "OLD ");\r\nprint_mp_irq_info(m);\r\ni = get_MP_intsrc_index(m);\r\nif (i > 0) {\r\nmemcpy(m, &mp_irqs[i], sizeof(*m));\r\napic_printk(APIC_VERBOSE, "NEW ");\r\nprint_mp_irq_info(&mp_irqs[i]);\r\nreturn;\r\n}\r\nif (!i) {\r\nreturn;\r\n}\r\nif (*nr_m_spare < SPARE_SLOT_NUM) {\r\nm_spare[*nr_m_spare] = m;\r\n*nr_m_spare += 1;\r\n}\r\n}\r\nstatic int __init\r\ncheck_slot(unsigned long mpc_new_phys, unsigned long mpc_new_length, int count)\r\n{\r\nif (!mpc_new_phys || count <= mpc_new_length) {\r\nWARN(1, "update_mptable: No spare slots (length: %x)\n", count);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\ninline void __init check_irq_src(struct mpc_intsrc *m, int *nr_m_spare) {}\r\nstatic int __init replace_intsrc_all(struct mpc_table *mpc,\r\nunsigned long mpc_new_phys,\r\nunsigned long mpc_new_length)\r\n{\r\n#ifdef CONFIG_X86_IO_APIC\r\nint i;\r\n#endif\r\nint count = sizeof(*mpc);\r\nint nr_m_spare = 0;\r\nunsigned char *mpt = ((unsigned char *)mpc) + count;\r\nprintk(KERN_INFO "mpc_length %x\n", mpc->length);\r\nwhile (count < mpc->length) {\r\nswitch (*mpt) {\r\ncase MP_PROCESSOR:\r\nskip_entry(&mpt, &count, sizeof(struct mpc_cpu));\r\nbreak;\r\ncase MP_BUS:\r\nskip_entry(&mpt, &count, sizeof(struct mpc_bus));\r\nbreak;\r\ncase MP_IOAPIC:\r\nskip_entry(&mpt, &count, sizeof(struct mpc_ioapic));\r\nbreak;\r\ncase MP_INTSRC:\r\ncheck_irq_src((struct mpc_intsrc *)mpt, &nr_m_spare);\r\nskip_entry(&mpt, &count, sizeof(struct mpc_intsrc));\r\nbreak;\r\ncase MP_LINTSRC:\r\nskip_entry(&mpt, &count, sizeof(struct mpc_lintsrc));\r\nbreak;\r\ndefault:\r\nsmp_dump_mptable(mpc, mpt);\r\ngoto out;\r\n}\r\n}\r\n#ifdef CONFIG_X86_IO_APIC\r\nfor (i = 0; i < mp_irq_entries; i++) {\r\nif (irq_used[i])\r\ncontinue;\r\nif (mp_irqs[i].irqtype != mp_INT)\r\ncontinue;\r\nif (mp_irqs[i].irqflag != 0x0f)\r\ncontinue;\r\nif (nr_m_spare > 0) {\r\napic_printk(APIC_VERBOSE, "*NEW* found\n");\r\nnr_m_spare--;\r\nmemcpy(m_spare[nr_m_spare], &mp_irqs[i], sizeof(mp_irqs[i]));\r\nm_spare[nr_m_spare] = NULL;\r\n} else {\r\nstruct mpc_intsrc *m = (struct mpc_intsrc *)mpt;\r\ncount += sizeof(struct mpc_intsrc);\r\nif (check_slot(mpc_new_phys, mpc_new_length, count) < 0)\r\ngoto out;\r\nmemcpy(m, &mp_irqs[i], sizeof(*m));\r\nmpc->length = count;\r\nmpt += sizeof(struct mpc_intsrc);\r\n}\r\nprint_mp_irq_info(&mp_irqs[i]);\r\n}\r\n#endif\r\nout:\r\nmpc->checksum = 0;\r\nmpc->checksum -= mpf_checksum((unsigned char *)mpc, mpc->length);\r\nreturn 0;\r\n}\r\nstatic int __init update_mptable_setup(char *str)\r\n{\r\nenable_update_mptable = 1;\r\n#ifdef CONFIG_PCI\r\npci_routeirq = 1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init parse_alloc_mptable_opt(char *p)\r\n{\r\nenable_update_mptable = 1;\r\n#ifdef CONFIG_PCI\r\npci_routeirq = 1;\r\n#endif\r\nalloc_mptable = 1;\r\nif (!p)\r\nreturn 0;\r\nmpc_new_length = memparse(p, &p);\r\nreturn 0;\r\n}\r\nvoid __init early_reserve_e820_mpc_new(void)\r\n{\r\nif (enable_update_mptable && alloc_mptable) {\r\nu64 startt = 0;\r\nmpc_new_phys = early_reserve_e820(startt, mpc_new_length, 4);\r\n}\r\n}\r\nstatic int __init update_mp_table(void)\r\n{\r\nchar str[16];\r\nchar oem[10];\r\nstruct mpf_intel *mpf;\r\nstruct mpc_table *mpc, *mpc_new;\r\nif (!enable_update_mptable)\r\nreturn 0;\r\nmpf = mpf_found;\r\nif (!mpf)\r\nreturn 0;\r\nif (mpf->feature1 != 0)\r\nreturn 0;\r\nif (!mpf->physptr)\r\nreturn 0;\r\nmpc = phys_to_virt(mpf->physptr);\r\nif (!smp_check_mpc(mpc, oem, str))\r\nreturn 0;\r\nprintk(KERN_INFO "mpf: %llx\n", (u64)virt_to_phys(mpf));\r\nprintk(KERN_INFO "physptr: %x\n", mpf->physptr);\r\nif (mpc_new_phys && mpc->length > mpc_new_length) {\r\nmpc_new_phys = 0;\r\nprintk(KERN_INFO "mpc_new_length is %ld, please use alloc_mptable=8k\n",\r\nmpc_new_length);\r\n}\r\nif (!mpc_new_phys) {\r\nunsigned char old, new;\r\nmpc->checksum = 0;\r\nold = mpf_checksum((unsigned char *)mpc, mpc->length);\r\nmpc->checksum = 0xff;\r\nnew = mpf_checksum((unsigned char *)mpc, mpc->length);\r\nif (old == new) {\r\nprintk(KERN_INFO "mpc is readonly, please try alloc_mptable instead\n");\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "use in-position replacing\n");\r\n} else {\r\nmpf->physptr = mpc_new_phys;\r\nmpc_new = phys_to_virt(mpc_new_phys);\r\nmemcpy(mpc_new, mpc, mpc->length);\r\nmpc = mpc_new;\r\nif (mpc_new_phys - mpf->physptr) {\r\nstruct mpf_intel *mpf_new;\r\nprintk(KERN_INFO "mpf new: %x\n", 0x400 - 16);\r\nmpf_new = phys_to_virt(0x400 - 16);\r\nmemcpy(mpf_new, mpf, 16);\r\nmpf = mpf_new;\r\nmpf->physptr = mpc_new_phys;\r\n}\r\nmpf->checksum = 0;\r\nmpf->checksum -= mpf_checksum((unsigned char *)mpf, 16);\r\nprintk(KERN_INFO "physptr new: %x\n", mpf->physptr);\r\n}\r\nreplace_intsrc_all(mpc, mpc_new_phys, mpc_new_length);\r\nreturn 0;\r\n}
