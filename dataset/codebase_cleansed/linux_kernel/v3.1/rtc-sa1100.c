static inline int rtc_periodic_alarm(struct rtc_time *tm)\r\n{\r\nreturn (tm->tm_year == -1) ||\r\n((unsigned)tm->tm_mon >= 12) ||\r\n((unsigned)(tm->tm_mday - 1) >= 31) ||\r\n((unsigned)tm->tm_hour > 23) ||\r\n((unsigned)tm->tm_min > 59) ||\r\n((unsigned)tm->tm_sec > 59);\r\n}\r\nstatic void rtc_next_alarm_time(struct rtc_time *next, struct rtc_time *now,\r\nstruct rtc_time *alrm)\r\n{\r\nunsigned long next_time;\r\nunsigned long now_time;\r\nnext->tm_year = now->tm_year;\r\nnext->tm_mon = now->tm_mon;\r\nnext->tm_mday = now->tm_mday;\r\nnext->tm_hour = alrm->tm_hour;\r\nnext->tm_min = alrm->tm_min;\r\nnext->tm_sec = alrm->tm_sec;\r\nrtc_tm_to_time(now, &now_time);\r\nrtc_tm_to_time(next, &next_time);\r\nif (next_time < now_time) {\r\nnext_time += 60 * 60 * 24;\r\nrtc_time_to_tm(next_time, next);\r\n}\r\n}\r\nstatic int rtc_update_alarm(struct rtc_time *alrm)\r\n{\r\nstruct rtc_time alarm_tm, now_tm;\r\nunsigned long now, time;\r\nint ret;\r\ndo {\r\nnow = RCNR;\r\nrtc_time_to_tm(now, &now_tm);\r\nrtc_next_alarm_time(&alarm_tm, &now_tm, alrm);\r\nret = rtc_tm_to_time(&alarm_tm, &time);\r\nif (ret != 0)\r\nbreak;\r\nRTSR = RTSR & (RTSR_HZE|RTSR_ALE|RTSR_AL);\r\nRTAR = time;\r\n} while (now != RCNR);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t sa1100_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev_id);\r\nstruct rtc_device *rtc = platform_get_drvdata(pdev);\r\nunsigned int rtsr;\r\nunsigned long events = 0;\r\nspin_lock(&sa1100_rtc_lock);\r\nrtsr = RTSR;\r\nRTSR = 0;\r\nif (rtsr & (RTSR_ALE | RTSR_HZE)) {\r\nRTSR = (RTSR_AL | RTSR_HZ) & (rtsr >> 2);\r\n} else {\r\nRTSR = RTSR_AL | RTSR_HZ;\r\n}\r\nif (rtsr & RTSR_AL)\r\nrtsr &= ~RTSR_ALE;\r\nRTSR = rtsr & (RTSR_ALE | RTSR_HZE);\r\nif (rtsr & RTSR_AL)\r\nevents |= RTC_AF | RTC_IRQF;\r\nif (rtsr & RTSR_HZ)\r\nevents |= RTC_UF | RTC_IRQF;\r\nrtc_update_irq(rtc, 1, events);\r\nif (rtsr & RTSR_AL && rtc_periodic_alarm(&rtc_alarm))\r\nrtc_update_alarm(&rtc_alarm);\r\nspin_unlock(&sa1100_rtc_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sa1100_rtc_open(struct device *dev)\r\n{\r\nint ret;\r\nstruct platform_device *plat_dev = to_platform_device(dev);\r\nstruct rtc_device *rtc = platform_get_drvdata(plat_dev);\r\nret = request_irq(IRQ_RTC1Hz, sa1100_rtc_interrupt, IRQF_DISABLED,\r\n"rtc 1Hz", dev);\r\nif (ret) {\r\ndev_err(dev, "IRQ %d already in use.\n", IRQ_RTC1Hz);\r\ngoto fail_ui;\r\n}\r\nret = request_irq(IRQ_RTCAlrm, sa1100_rtc_interrupt, IRQF_DISABLED,\r\n"rtc Alrm", dev);\r\nif (ret) {\r\ndev_err(dev, "IRQ %d already in use.\n", IRQ_RTCAlrm);\r\ngoto fail_ai;\r\n}\r\nrtc->max_user_freq = RTC_FREQ;\r\nrtc_irq_set_freq(rtc, NULL, RTC_FREQ);\r\nreturn 0;\r\nfail_ai:\r\nfree_irq(IRQ_RTC1Hz, dev);\r\nfail_ui:\r\nreturn ret;\r\n}\r\nstatic void sa1100_rtc_release(struct device *dev)\r\n{\r\nspin_lock_irq(&sa1100_rtc_lock);\r\nRTSR = 0;\r\nOIER &= ~OIER_E1;\r\nOSSR = OSSR_M1;\r\nspin_unlock_irq(&sa1100_rtc_lock);\r\nfree_irq(IRQ_RTCAlrm, dev);\r\nfree_irq(IRQ_RTC1Hz, dev);\r\n}\r\nstatic int sa1100_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nspin_lock_irq(&sa1100_rtc_lock);\r\nif (enabled)\r\nRTSR |= RTSR_ALE;\r\nelse\r\nRTSR &= ~RTSR_ALE;\r\nspin_unlock_irq(&sa1100_rtc_lock);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nrtc_time_to_tm(RCNR, tm);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nunsigned long time;\r\nint ret;\r\nret = rtc_tm_to_time(tm, &time);\r\nif (ret == 0)\r\nRCNR = time;\r\nreturn ret;\r\n}\r\nstatic int sa1100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nu32 rtsr;\r\nmemcpy(&alrm->time, &rtc_alarm, sizeof(struct rtc_time));\r\nrtsr = RTSR;\r\nalrm->enabled = (rtsr & RTSR_ALE) ? 1 : 0;\r\nalrm->pending = (rtsr & RTSR_AL) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nint ret;\r\nspin_lock_irq(&sa1100_rtc_lock);\r\nret = rtc_update_alarm(&alrm->time);\r\nif (ret == 0) {\r\nif (alrm->enabled)\r\nRTSR |= RTSR_ALE;\r\nelse\r\nRTSR &= ~RTSR_ALE;\r\n}\r\nspin_unlock_irq(&sa1100_rtc_lock);\r\nreturn ret;\r\n}\r\nstatic int sa1100_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nseq_printf(seq, "trim/divider\t\t: 0x%08x\n", (u32) RTTR);\r\nseq_printf(seq, "RTSR\t\t\t: 0x%08x\n", (u32)RTSR);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtc;\r\nif (RTTR == 0) {\r\nRTTR = RTC_DEF_DIVIDER + (RTC_DEF_TRIM << 16);\r\ndev_warn(&pdev->dev, "warning: "\r\n"initializing default clock divider/trim value\n");\r\nRCNR = 0;\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nrtc = rtc_device_register(pdev->name, &pdev->dev, &sa1100_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\nplatform_set_drvdata(pdev, rtc);\r\nRTSR = RTSR_AL | RTSR_HZ;\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtc = platform_get_drvdata(pdev);\r\nif (rtc)\r\nrtc_device_unregister(rtc);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_suspend(struct device *dev)\r\n{\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(IRQ_RTCAlrm);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_resume(struct device *dev)\r\n{\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(IRQ_RTCAlrm);\r\nreturn 0;\r\n}\r\nstatic int __init sa1100_rtc_init(void)\r\n{\r\nreturn platform_driver_register(&sa1100_rtc_driver);\r\n}\r\nstatic void __exit sa1100_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&sa1100_rtc_driver);\r\n}
