static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\r\nunsigned long addr,\r\nunsigned long length)\r\n{\r\nunsigned long result = 0;\r\nswitch (ioapic->ioregsel) {\r\ncase IOAPIC_REG_VERSION:\r\nresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\r\n| (IOAPIC_VERSION_ID & 0xff));\r\nbreak;\r\ncase IOAPIC_REG_APIC_ID:\r\ncase IOAPIC_REG_ARB_ID:\r\nresult = ((ioapic->id & 0xf) << 24);\r\nbreak;\r\ndefault:\r\n{\r\nu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\r\nu64 redir_content;\r\nASSERT(redir_index < IOAPIC_NUM_PINS);\r\nredir_content = ioapic->redirtbl[redir_index].bits;\r\nresult = (ioapic->ioregsel & 0x1) ?\r\n(redir_content >> 32) & 0xffffffff :\r\nredir_content & 0xffffffff;\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int ioapic_service(struct kvm_ioapic *ioapic, unsigned int idx)\r\n{\r\nunion kvm_ioapic_redirect_entry *pent;\r\nint injected = -1;\r\npent = &ioapic->redirtbl[idx];\r\nif (!pent->fields.mask) {\r\ninjected = ioapic_deliver(ioapic, idx);\r\nif (injected && pent->fields.trig_mode == IOAPIC_LEVEL_TRIG)\r\npent->fields.remote_irr = 1;\r\n}\r\nreturn injected;\r\n}\r\nstatic void update_handled_vectors(struct kvm_ioapic *ioapic)\r\n{\r\nDECLARE_BITMAP(handled_vectors, 256);\r\nint i;\r\nmemset(handled_vectors, 0, sizeof(handled_vectors));\r\nfor (i = 0; i < IOAPIC_NUM_PINS; ++i)\r\n__set_bit(ioapic->redirtbl[i].fields.vector, handled_vectors);\r\nmemcpy(ioapic->handled_vectors, handled_vectors,\r\nsizeof(handled_vectors));\r\nsmp_wmb();\r\n}\r\nstatic void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\r\n{\r\nunsigned index;\r\nbool mask_before, mask_after;\r\nunion kvm_ioapic_redirect_entry *e;\r\nswitch (ioapic->ioregsel) {\r\ncase IOAPIC_REG_VERSION:\r\nbreak;\r\ncase IOAPIC_REG_APIC_ID:\r\nioapic->id = (val >> 24) & 0xf;\r\nbreak;\r\ncase IOAPIC_REG_ARB_ID:\r\nbreak;\r\ndefault:\r\nindex = (ioapic->ioregsel - 0x10) >> 1;\r\nioapic_debug("change redir index %x val %x\n", index, val);\r\nif (index >= IOAPIC_NUM_PINS)\r\nreturn;\r\ne = &ioapic->redirtbl[index];\r\nmask_before = e->fields.mask;\r\nif (ioapic->ioregsel & 1) {\r\ne->bits &= 0xffffffff;\r\ne->bits |= (u64) val << 32;\r\n} else {\r\ne->bits &= ~0xffffffffULL;\r\ne->bits |= (u32) val;\r\ne->fields.remote_irr = 0;\r\n}\r\nupdate_handled_vectors(ioapic);\r\nmask_after = e->fields.mask;\r\nif (mask_before != mask_after)\r\nkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\r\nif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\r\n&& ioapic->irr & (1 << index))\r\nioapic_service(ioapic, index);\r\nbreak;\r\n}\r\n}\r\nstatic int ioapic_deliver(struct kvm_ioapic *ioapic, int irq)\r\n{\r\nunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\r\nstruct kvm_lapic_irq irqe;\r\nioapic_debug("dest=%x dest_mode=%x delivery_mode=%x "\r\n"vector=%x trig_mode=%x\n",\r\nentry->fields.dest_id, entry->fields.dest_mode,\r\nentry->fields.delivery_mode, entry->fields.vector,\r\nentry->fields.trig_mode);\r\nirqe.dest_id = entry->fields.dest_id;\r\nirqe.vector = entry->fields.vector;\r\nirqe.dest_mode = entry->fields.dest_mode;\r\nirqe.trig_mode = entry->fields.trig_mode;\r\nirqe.delivery_mode = entry->fields.delivery_mode << 8;\r\nirqe.level = 1;\r\nirqe.shorthand = 0;\r\n#ifdef CONFIG_X86\r\nif (irq == 0) {\r\nirqe.dest_mode = 0;\r\nirqe.dest_id = ioapic->kvm->bsp_vcpu->vcpu_id;\r\n}\r\n#endif\r\nreturn kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe);\r\n}\r\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int level)\r\n{\r\nu32 old_irr;\r\nu32 mask = 1 << irq;\r\nunion kvm_ioapic_redirect_entry entry;\r\nint ret = 1;\r\nspin_lock(&ioapic->lock);\r\nold_irr = ioapic->irr;\r\nif (irq >= 0 && irq < IOAPIC_NUM_PINS) {\r\nentry = ioapic->redirtbl[irq];\r\nlevel ^= entry.fields.polarity;\r\nif (!level)\r\nioapic->irr &= ~mask;\r\nelse {\r\nint edge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\r\nioapic->irr |= mask;\r\nif ((edge && old_irr != ioapic->irr) ||\r\n(!edge && !entry.fields.remote_irr))\r\nret = ioapic_service(ioapic, irq);\r\nelse\r\nret = 0;\r\n}\r\ntrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\r\n}\r\nspin_unlock(&ioapic->lock);\r\nreturn ret;\r\n}\r\nstatic void __kvm_ioapic_update_eoi(struct kvm_ioapic *ioapic, int vector,\r\nint trigger_mode)\r\n{\r\nint i;\r\nfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\r\nunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\r\nif (ent->fields.vector != vector)\r\ncontinue;\r\nspin_unlock(&ioapic->lock);\r\nkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, i);\r\nspin_lock(&ioapic->lock);\r\nif (trigger_mode != IOAPIC_LEVEL_TRIG)\r\ncontinue;\r\nASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\r\nent->fields.remote_irr = 0;\r\nif (!ent->fields.mask && (ioapic->irr & (1 << i)))\r\nioapic_service(ioapic, i);\r\n}\r\n}\r\nvoid kvm_ioapic_update_eoi(struct kvm *kvm, int vector, int trigger_mode)\r\n{\r\nstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\r\nsmp_rmb();\r\nif (!test_bit(vector, ioapic->handled_vectors))\r\nreturn;\r\nspin_lock(&ioapic->lock);\r\n__kvm_ioapic_update_eoi(ioapic, vector, trigger_mode);\r\nspin_unlock(&ioapic->lock);\r\n}\r\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\r\n{\r\nreturn container_of(dev, struct kvm_ioapic, dev);\r\n}\r\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\r\n{\r\nreturn ((addr >= ioapic->base_address &&\r\n(addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\r\n}\r\nstatic int ioapic_mmio_read(struct kvm_io_device *this, gpa_t addr, int len,\r\nvoid *val)\r\n{\r\nstruct kvm_ioapic *ioapic = to_ioapic(this);\r\nu32 result;\r\nif (!ioapic_in_range(ioapic, addr))\r\nreturn -EOPNOTSUPP;\r\nioapic_debug("addr %lx\n", (unsigned long)addr);\r\nASSERT(!(addr & 0xf));\r\naddr &= 0xff;\r\nspin_lock(&ioapic->lock);\r\nswitch (addr) {\r\ncase IOAPIC_REG_SELECT:\r\nresult = ioapic->ioregsel;\r\nbreak;\r\ncase IOAPIC_REG_WINDOW:\r\nresult = ioapic_read_indirect(ioapic, addr, len);\r\nbreak;\r\ndefault:\r\nresult = 0;\r\nbreak;\r\n}\r\nspin_unlock(&ioapic->lock);\r\nswitch (len) {\r\ncase 8:\r\n*(u64 *) val = result;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\nmemcpy(val, (char *)&result, len);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "ioapic: wrong length %d\n", len);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioapic_mmio_write(struct kvm_io_device *this, gpa_t addr, int len,\r\nconst void *val)\r\n{\r\nstruct kvm_ioapic *ioapic = to_ioapic(this);\r\nu32 data;\r\nif (!ioapic_in_range(ioapic, addr))\r\nreturn -EOPNOTSUPP;\r\nioapic_debug("ioapic_mmio_write addr=%p len=%d val=%p\n",\r\n(void*)addr, len, val);\r\nASSERT(!(addr & 0xf));\r\nif (len == 4 || len == 8)\r\ndata = *(u32 *) val;\r\nelse {\r\nprintk(KERN_WARNING "ioapic: Unsupported size %d\n", len);\r\nreturn 0;\r\n}\r\naddr &= 0xff;\r\nspin_lock(&ioapic->lock);\r\nswitch (addr) {\r\ncase IOAPIC_REG_SELECT:\r\nioapic->ioregsel = data;\r\nbreak;\r\ncase IOAPIC_REG_WINDOW:\r\nioapic_write_indirect(ioapic, data);\r\nbreak;\r\n#ifdef CONFIG_IA64\r\ncase IOAPIC_REG_EOI:\r\n__kvm_ioapic_update_eoi(ioapic, data, IOAPIC_LEVEL_TRIG);\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock(&ioapic->lock);\r\nreturn 0;\r\n}\r\nvoid kvm_ioapic_reset(struct kvm_ioapic *ioapic)\r\n{\r\nint i;\r\nfor (i = 0; i < IOAPIC_NUM_PINS; i++)\r\nioapic->redirtbl[i].fields.mask = 1;\r\nioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\r\nioapic->ioregsel = 0;\r\nioapic->irr = 0;\r\nioapic->id = 0;\r\nupdate_handled_vectors(ioapic);\r\n}\r\nint kvm_ioapic_init(struct kvm *kvm)\r\n{\r\nstruct kvm_ioapic *ioapic;\r\nint ret;\r\nioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL);\r\nif (!ioapic)\r\nreturn -ENOMEM;\r\nspin_lock_init(&ioapic->lock);\r\nkvm->arch.vioapic = ioapic;\r\nkvm_ioapic_reset(ioapic);\r\nkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\r\nioapic->kvm = kvm;\r\nmutex_lock(&kvm->slots_lock);\r\nret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\r\nmutex_unlock(&kvm->slots_lock);\r\nif (ret < 0) {\r\nkvm->arch.vioapic = NULL;\r\nkfree(ioapic);\r\n}\r\nreturn ret;\r\n}\r\nvoid kvm_ioapic_destroy(struct kvm *kvm)\r\n{\r\nstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\r\nif (ioapic) {\r\nkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\r\nkvm->arch.vioapic = NULL;\r\nkfree(ioapic);\r\n}\r\n}\r\nint kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\r\n{\r\nstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\r\nif (!ioapic)\r\nreturn -EINVAL;\r\nspin_lock(&ioapic->lock);\r\nmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\r\nspin_unlock(&ioapic->lock);\r\nreturn 0;\r\n}\r\nint kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\r\n{\r\nstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\r\nif (!ioapic)\r\nreturn -EINVAL;\r\nspin_lock(&ioapic->lock);\r\nmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\r\nupdate_handled_vectors(ioapic);\r\nspin_unlock(&ioapic->lock);\r\nreturn 0;\r\n}
