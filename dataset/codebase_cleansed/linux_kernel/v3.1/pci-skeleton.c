static int __devinit netdrv_init_board(struct pci_dev *pdev,\r\nstruct net_device **dev_out,\r\nvoid **ioaddr_out)\r\n{\r\nvoid *ioaddr = NULL;\r\nstruct net_device *dev;\r\nstruct netdrv_private *tp;\r\nint rc, i;\r\nu32 pio_start, pio_end, pio_flags, pio_len;\r\nunsigned long mmio_start, mmio_end, mmio_flags, mmio_len;\r\nu32 tmp;\r\nDPRINTK("ENTER\n");\r\nassert(pdev != NULL);\r\nassert(ioaddr_out != NULL);\r\n*ioaddr_out = NULL;\r\n*dev_out = NULL;\r\ndev = alloc_etherdev(sizeof(*tp));\r\nif (dev == NULL) {\r\ndev_err(&pdev->dev, "unable to alloc new ethernet\n");\r\nDPRINTK("EXIT, returning -ENOMEM\n");\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ntp = netdev_priv(dev);\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err_out;\r\npio_start = pci_resource_start(pdev, 0);\r\npio_end = pci_resource_end(pdev, 0);\r\npio_flags = pci_resource_flags(pdev, 0);\r\npio_len = pci_resource_len(pdev, 0);\r\nmmio_start = pci_resource_start(pdev, 1);\r\nmmio_end = pci_resource_end(pdev, 1);\r\nmmio_flags = pci_resource_flags(pdev, 1);\r\nmmio_len = pci_resource_len(pdev, 1);\r\nDPRINTK("PIO region size == %#02X\n", pio_len);\r\nDPRINTK("MMIO region size == %#02lX\n", mmio_len);\r\nif (!(pio_flags & IORESOURCE_IO)) {\r\ndev_err(&pdev->dev, "region #0 not a PIO resource, aborting\n");\r\nrc = -ENODEV;\r\ngoto err_out;\r\n}\r\nif (!(mmio_flags & IORESOURCE_MEM)) {\r\ndev_err(&pdev->dev, "region #1 not an MMIO resource, aborting\n");\r\nrc = -ENODEV;\r\ngoto err_out;\r\n}\r\nif ((pio_len < NETDRV_MIN_IO_SIZE) ||\r\n(mmio_len < NETDRV_MIN_IO_SIZE)) {\r\ndev_err(&pdev->dev, "Invalid PCI region size(s), aborting\n");\r\nrc = -ENODEV;\r\ngoto err_out;\r\n}\r\nrc = pci_request_regions(pdev, MODNAME);\r\nif (rc)\r\ngoto err_out;\r\npci_set_master(pdev);\r\n#ifdef USE_IO_OPS\r\nioaddr = (void *)pio_start;\r\n#else\r\nioaddr = ioremap(mmio_start, mmio_len);\r\nif (ioaddr == NULL) {\r\ndev_err(&pdev->dev, "cannot remap MMIO, aborting\n");\r\nrc = -EIO;\r\ngoto err_out_free_res;\r\n}\r\n#endif\r\nNETDRV_W8(ChipCmd, (NETDRV_R8(ChipCmd) & ChipCmdClear) | CmdReset);\r\nfor (i = 1000; i > 0; i--)\r\nif ((NETDRV_R8(ChipCmd) & CmdReset) == 0)\r\nbreak;\r\nelse\r\nudelay(10);\r\n#ifndef USE_IO_OPS\r\nassert(inb(pio_start+Config0) == readb(ioaddr+Config0));\r\nassert(inb(pio_start+Config1) == readb(ioaddr+Config1));\r\nassert(inb(pio_start+TxConfig) == readb(ioaddr+TxConfig));\r\nassert(inb(pio_start+RxConfig) == readb(ioaddr+RxConfig));\r\n#endif\r\ntmp = NETDRV_R8(ChipVersion);\r\nfor (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--)\r\nif (tmp == rtl_chip_info[i].version) {\r\ntp->chipset = i;\r\ngoto match;\r\n}\r\ndev_printk(KERN_DEBUG, &pdev->dev,\r\n"unknown chip version, assuming RTL-8139\n");\r\ndev_printk(KERN_DEBUG, &pdev->dev, "TxConfig = %#lx\n",\r\nNETDRV_R32(TxConfig));\r\ntp->chipset = 0;\r\nmatch:\r\nDPRINTK("chipset id(%d) == index %d, '%s'\n",\r\ntmp, tp->chipset, rtl_chip_info[tp->chipset].name);\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_out_unmap;\r\nDPRINTK("EXIT, returning 0\n");\r\n*ioaddr_out = ioaddr;\r\n*dev_out = dev;\r\nreturn 0;\r\nerr_out_unmap:\r\n#ifndef USE_IO_OPS\r\niounmap(ioaddr);\r\nerr_out_free_res:\r\n#endif\r\npci_release_regions(pdev);\r\nerr_out:\r\nfree_netdev(dev);\r\nDPRINTK("EXIT, returning %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int __devinit netdrv_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct netdrv_private *tp;\r\nint i, addr_len, option;\r\nvoid *ioaddr = NULL;\r\nstatic int board_idx = -1;\r\n#ifndef MODULE\r\nstatic int printed_version;\r\nif (!printed_version++)\r\nprintk(version);\r\n#endif\r\nDPRINTK("ENTER\n");\r\nassert(pdev != NULL);\r\nassert(ent != NULL);\r\nboard_idx++;\r\ni = netdrv_init_board(pdev, &dev, &ioaddr);\r\nif (i < 0) {\r\nDPRINTK("EXIT, returning %d\n", i);\r\nreturn i;\r\n}\r\ntp = netdev_priv(dev);\r\nassert(ioaddr != NULL);\r\nassert(dev != NULL);\r\nassert(tp != NULL);\r\naddr_len = read_eeprom(ioaddr, 0, 8) == 0x8129 ? 8 : 6;\r\nfor (i = 0; i < 3; i++)\r\n((u16 *)(dev->dev_addr))[i] =\r\nle16_to_cpu(read_eeprom(ioaddr, i + 7, addr_len));\r\ndev->netdev_ops = &netdrv_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->irq = pdev->irq;\r\ndev->base_addr = (unsigned long) ioaddr;\r\ntp = netdev_priv(dev);\r\ntp->drv_flags = PCI_COMMAND_IO | PCI_COMMAND_MEMORY |\r\nPCI_COMMAND_MASTER | NETDRV_CAPS;\r\ntp->pci_dev = pdev;\r\ntp->board = ent->driver_data;\r\ntp->mmio_addr = ioaddr;\r\nspin_lock_init(&tp->lock);\r\npci_set_drvdata(pdev, dev);\r\ntp->phys[0] = 32;\r\nnetdev_info(dev, "%s at %#lx, %pM IRQ %d\n",\r\nboard_info[ent->driver_data].name,\r\ndev->base_addr, dev->dev_addr, dev->irq);\r\nnetdev_printk(KERN_DEBUG, dev, "Identified 8139 chip type '%s'\n",\r\nrtl_chip_info[tp->chipset].name);\r\nNETDRV_W8_F(Cfg9346, Cfg9346_Unlock);\r\noption = (board_idx > 7) ? 0 : media[board_idx];\r\nif (option > 0) {\r\ntp->full_duplex = (option & 0x200) ? 1 : 0;\r\ntp->default_port = option & 15;\r\nif (tp->default_port)\r\ntp->medialock = 1;\r\n}\r\nif (tp->full_duplex) {\r\nnetdev_info(dev, "Media type forced to Full Duplex\n");\r\nmdio_write(dev, tp->phys[0], MII_ADVERTISE, ADVERTISE_FULL);\r\ntp->duplex_lock = 1;\r\n}\r\nDPRINTK("EXIT - returning 0\n");\r\nreturn 0;\r\n}\r\nstatic void __devexit netdrv_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct netdrv_private *np;\r\nDPRINTK("ENTER\n");\r\nassert(dev != NULL);\r\nnp = netdev_priv(dev);\r\nassert(np != NULL);\r\nunregister_netdev(dev);\r\n#ifndef USE_IO_OPS\r\niounmap(np->mmio_addr);\r\n#endif\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic int __devinit read_eeprom(void *ioaddr, int location, int addr_len)\r\n{\r\nint i;\r\nunsigned retval = 0;\r\nvoid *ee_addr = ioaddr + Cfg9346;\r\nint read_cmd = location | (EE_READ_CMD << addr_len);\r\nDPRINTK("ENTER\n");\r\nwriteb(EE_ENB & ~EE_CS, ee_addr);\r\nwriteb(EE_ENB, ee_addr);\r\neeprom_delay();\r\nfor (i = 4 + addr_len; i >= 0; i--) {\r\nint dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;\r\nwriteb(EE_ENB | dataval, ee_addr);\r\neeprom_delay();\r\nwriteb(EE_ENB | dataval | EE_SHIFT_CLK, ee_addr);\r\neeprom_delay();\r\n}\r\nwriteb(EE_ENB, ee_addr);\r\neeprom_delay();\r\nfor (i = 16; i > 0; i--) {\r\nwriteb(EE_ENB | EE_SHIFT_CLK, ee_addr);\r\neeprom_delay();\r\nretval =\r\n(retval << 1) | ((readb(ee_addr) & EE_DATA_READ) ? 1 :\r\n0);\r\nwriteb(EE_ENB, ee_addr);\r\neeprom_delay();\r\n}\r\nwriteb(~EE_CS, ee_addr);\r\neeprom_delay();\r\nDPRINTK("EXIT - returning %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic void mdio_sync(void *mdio_addr)\r\n{\r\nint i;\r\nDPRINTK("ENTER\n");\r\nfor (i = 32; i >= 0; i--) {\r\nwriteb(MDIO_WRITE1, mdio_addr);\r\nmdio_delay();\r\nwriteb(MDIO_WRITE1 | MDIO_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int location)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *mdio_addr = tp->mmio_addr + Config4;\r\nint mii_cmd = (0xf6 << 10) | (phy_id << 5) | location;\r\nint retval = 0;\r\nint i;\r\nDPRINTK("ENTER\n");\r\nif (phy_id > 31) {\r\nDPRINTK("EXIT after directly using 8139 internal regs\n");\r\nreturn location < 8 && mii_2_8139_map[location] ?\r\nreadw(tp->mmio_addr + mii_2_8139_map[location]) : 0;\r\n}\r\nmdio_sync(mdio_addr);\r\nfor (i = 15; i >= 0; i--) {\r\nint dataval = (mii_cmd & (1 << i)) ? MDIO_DATA_OUT : 0;\r\nwriteb(MDIO_DIR | dataval, mdio_addr);\r\nmdio_delay();\r\nwriteb(MDIO_DIR | dataval | MDIO_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nfor (i = 19; i > 0; i--) {\r\nwriteb(0, mdio_addr);\r\nmdio_delay();\r\nretval = ((retval << 1) | ((readb(mdio_addr) & MDIO_DATA_IN))\r\n? 1 : 0);\r\nwriteb(MDIO_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nDPRINTK("EXIT, returning %d\n", (retval >> 1) & 0xffff);\r\nreturn (retval >> 1) & 0xffff;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int location,\r\nint value)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *mdio_addr = tp->mmio_addr + Config4;\r\nint mii_cmd =\r\n(0x5002 << 16) | (phy_id << 23) | (location << 18) | value;\r\nint i;\r\nDPRINTK("ENTER\n");\r\nif (phy_id > 31) {\r\nif (location < 8 && mii_2_8139_map[location]) {\r\nwritew(value,\r\ntp->mmio_addr + mii_2_8139_map[location]);\r\nreadw(tp->mmio_addr + mii_2_8139_map[location]);\r\n}\r\nDPRINTK("EXIT after directly using 8139 internal regs\n");\r\nreturn;\r\n}\r\nmdio_sync(mdio_addr);\r\nfor (i = 31; i >= 0; i--) {\r\nint dataval =\r\n(mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;\r\nwriteb(dataval, mdio_addr);\r\nmdio_delay();\r\nwriteb(dataval | MDIO_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nfor (i = 2; i > 0; i--) {\r\nwriteb(0, mdio_addr);\r\nmdio_delay();\r\nwriteb(MDIO_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic int netdrv_open(struct net_device *dev)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nint retval;\r\nvoid *ioaddr = tp->mmio_addr;\r\nDPRINTK("ENTER\n");\r\nretval = request_irq(dev->irq, netdrv_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (retval) {\r\nDPRINTK("EXIT, returning %d\n", retval);\r\nreturn retval;\r\n}\r\ntp->tx_bufs = pci_alloc_consistent(tp->pci_dev, TX_BUF_TOT_LEN,\r\n&tp->tx_bufs_dma);\r\ntp->rx_ring = pci_alloc_consistent(tp->pci_dev, RX_BUF_TOT_LEN,\r\n&tp->rx_ring_dma);\r\nif (tp->tx_bufs == NULL || tp->rx_ring == NULL) {\r\nfree_irq(dev->irq, dev);\r\nif (tp->tx_bufs)\r\npci_free_consistent(tp->pci_dev, TX_BUF_TOT_LEN,\r\ntp->tx_bufs, tp->tx_bufs_dma);\r\nif (tp->rx_ring)\r\npci_free_consistent(tp->pci_dev, RX_BUF_TOT_LEN,\r\ntp->rx_ring, tp->rx_ring_dma);\r\nDPRINTK("EXIT, returning -ENOMEM\n");\r\nreturn -ENOMEM;\r\n}\r\ntp->full_duplex = tp->duplex_lock;\r\ntp->tx_flag = (TX_FIFO_THRESH << 11) & 0x003f0000;\r\nnetdrv_init_ring(dev);\r\nnetdrv_hw_start(dev);\r\nnetdev_dbg(dev, "ioaddr %#llx IRQ %d GP Pins %02x %s-duplex\n",\r\n(unsigned long long)pci_resource_start(tp->pci_dev, 1),\r\ndev->irq, NETDRV_R8(MediaStatus),\r\ntp->full_duplex ? "full" : "half");\r\ninit_timer(&tp->timer);\r\ntp->timer.expires = jiffies + 3 * HZ;\r\ntp->timer.data = (unsigned long) dev;\r\ntp->timer.function = netdrv_timer;\r\nadd_timer(&tp->timer);\r\nDPRINTK("EXIT, returning 0\n");\r\nreturn 0;\r\n}\r\nstatic void netdrv_hw_start(struct net_device *dev)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *ioaddr = tp->mmio_addr;\r\nu32 i;\r\nDPRINTK("ENTER\n");\r\nNETDRV_W8(ChipCmd, (NETDRV_R8(ChipCmd) & ChipCmdClear) | CmdReset);\r\nudelay(100);\r\nfor (i = 1000; i > 0; i--)\r\nif ((NETDRV_R8(ChipCmd) & CmdReset) == 0)\r\nbreak;\r\nNETDRV_W32_F(MAC0 + 0, cpu_to_le32(*(u32 *)(dev->dev_addr + 0)));\r\nNETDRV_W32_F(MAC0 + 4, cpu_to_le32(*(u32 *)(dev->dev_addr + 4)));\r\nNETDRV_W8_F(ChipCmd, (NETDRV_R8(ChipCmd) & ChipCmdClear) |\r\nCmdRxEnb | CmdTxEnb);\r\ni = netdrv_rx_config |\r\n(NETDRV_R32(RxConfig) & rtl_chip_info[tp->chipset].RxConfigMask);\r\nNETDRV_W32_F(RxConfig, i);\r\nNETDRV_W32(TxConfig, (TX_DMA_BURST << TxDMAShift));\r\nNETDRV_W8_F(Cfg9346, Cfg9346_Unlock);\r\nudelay(10);\r\ntp->cur_rx = 0;\r\nNETDRV_W8_F(Cfg9346, Cfg9346_Lock);\r\nudelay(10);\r\nNETDRV_W32_F(RxBuf, tp->rx_ring_dma);\r\nfor (i = 0; i < NUM_TX_DESC; i++)\r\nNETDRV_W32_F(TxAddr0 + (i * 4), tp->tx_bufs_dma + (tp->tx_buf[i] - tp->tx_bufs));\r\nNETDRV_W32_F(RxMissed, 0);\r\nnetdrv_set_rx_mode(dev);\r\nNETDRV_W16(MultiIntr, NETDRV_R16(MultiIntr) & MultiIntrClear);\r\nNETDRV_W8_F(ChipCmd, (NETDRV_R8(ChipCmd) & ChipCmdClear) |\r\nCmdRxEnb | CmdTxEnb);\r\nNETDRV_W16_F(IntrMask, netdrv_intr_mask);\r\nnetif_start_queue(dev);\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic void netdrv_init_ring(struct net_device *dev)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nint i;\r\nDPRINTK("ENTER\n");\r\ntp->cur_rx = 0;\r\natomic_set(&tp->cur_tx, 0);\r\natomic_set(&tp->dirty_tx, 0);\r\nfor (i = 0; i < NUM_TX_DESC; i++) {\r\ntp->tx_info[i].skb = NULL;\r\ntp->tx_info[i].mapping = 0;\r\ntp->tx_buf[i] = &tp->tx_bufs[i * TX_BUF_SIZE];\r\n}\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic void netdrv_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *) data;\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *ioaddr = tp->mmio_addr;\r\nint next_tick = 60 * HZ;\r\nint mii_lpa;\r\nmii_lpa = mdio_read(dev, tp->phys[0], MII_LPA);\r\nif (!tp->duplex_lock && mii_lpa != 0xffff) {\r\nint duplex = ((mii_lpa & LPA_100FULL) ||\r\n(mii_lpa & 0x01C0) == 0x0040);\r\nif (tp->full_duplex != duplex) {\r\ntp->full_duplex = duplex;\r\nnetdev_info(dev, "Setting %s-duplex based on MII #%d link partner ability of %04x\n",\r\ntp->full_duplex ? "full" : "half",\r\ntp->phys[0], mii_lpa);\r\nNETDRV_W8(Cfg9346, Cfg9346_Unlock);\r\nNETDRV_W8(Config1, tp->full_duplex ? 0x60 : 0x20);\r\nNETDRV_W8(Cfg9346, Cfg9346_Lock);\r\n}\r\n}\r\nnetdev_dbg(dev, "Media selection tick, Link partner %04x\n",\r\nNETDRV_R16(NWayLPAR));\r\nnetdev_dbg(dev, "Other registers are IntMask %04x IntStatus %04x RxStatus %04lx\n",\r\nNETDRV_R16(IntrMask),\r\nNETDRV_R16(IntrStatus),\r\nNETDRV_R32(RxEarlyStatus));\r\nnetdev_dbg(dev, "Chip config %02x %02x\n",\r\nNETDRV_R8(Config0), NETDRV_R8(Config1));\r\ntp->timer.expires = jiffies + next_tick;\r\nadd_timer(&tp->timer);\r\n}\r\nstatic void netdrv_tx_clear(struct net_device *dev)\r\n{\r\nint i;\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\natomic_set(&tp->cur_tx, 0);\r\natomic_set(&tp->dirty_tx, 0);\r\nfor (i = 0; i < NUM_TX_DESC; i++) {\r\nstruct ring_info *rp = &tp->tx_info[i];\r\nif (rp->mapping != 0) {\r\npci_unmap_single(tp->pci_dev, rp->mapping,\r\nrp->skb->len, PCI_DMA_TODEVICE);\r\nrp->mapping = 0;\r\n}\r\nif (rp->skb) {\r\ndev_kfree_skb(rp->skb);\r\nrp->skb = NULL;\r\ndev->stats.tx_dropped++;\r\n}\r\n}\r\n}\r\nstatic void netdrv_tx_timeout(struct net_device *dev)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *ioaddr = tp->mmio_addr;\r\nint i;\r\nu8 tmp8;\r\nunsigned long flags;\r\nnetdev_dbg(dev, "Transmit timeout, status %02x %04x media %02x\n",\r\nNETDRV_R8(ChipCmd),\r\nNETDRV_R16(IntrStatus),\r\nNETDRV_R8(MediaStatus));\r\ntmp8 = NETDRV_R8(ChipCmd);\r\nif (tmp8 & CmdTxEnb)\r\nNETDRV_W8(ChipCmd, tmp8 & ~CmdTxEnb);\r\nNETDRV_W16(IntrMask, 0x0000);\r\nnetdev_dbg(dev, "Tx queue start entry %d dirty entry %d\n",\r\natomic_read(&tp->cur_tx),\r\natomic_read(&tp->dirty_tx));\r\nfor (i = 0; i < NUM_TX_DESC; i++)\r\nnetdev_dbg(dev, "Tx descriptor %d is %08lx%s\n",\r\ni, NETDRV_R32(TxStatus0 + (i * 4)),\r\ni == atomic_read(&tp->dirty_tx) % NUM_TX_DESC ?\r\n"(queue head)" : "");\r\nspin_lock_irqsave(&tp->lock, flags);\r\nnetdrv_tx_clear(dev);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nnetdrv_hw_start(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int netdrv_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *ioaddr = tp->mmio_addr;\r\nint entry;\r\nentry = atomic_read(&tp->cur_tx) % NUM_TX_DESC;\r\nassert(tp->tx_info[entry].skb == NULL);\r\nassert(tp->tx_info[entry].mapping == 0);\r\ntp->tx_info[entry].skb = skb;\r\nskb_copy_from_linear_data(skb, tp->tx_buf[entry], skb->len);\r\nNETDRV_W32(TxStatus0 + (entry * sizeof(u32)),\r\ntp->tx_flag | (skb->len >= ETH_ZLEN ? skb->len : ETH_ZLEN));\r\natomic_inc(&tp->cur_tx);\r\nif ((atomic_read(&tp->cur_tx) - atomic_read(&tp->dirty_tx)) >= NUM_TX_DESC)\r\nnetif_stop_queue(dev);\r\nnetdev_dbg(dev, "Queued Tx packet at %p size %u to slot %d\n",\r\nskb->data, skb->len, entry);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void netdrv_tx_interrupt(struct net_device *dev,\r\nstruct netdrv_private *tp,\r\nvoid *ioaddr)\r\n{\r\nint cur_tx, dirty_tx, tx_left;\r\nassert(dev != NULL);\r\nassert(tp != NULL);\r\nassert(ioaddr != NULL);\r\ndirty_tx = atomic_read(&tp->dirty_tx);\r\ncur_tx = atomic_read(&tp->cur_tx);\r\ntx_left = cur_tx - dirty_tx;\r\nwhile (tx_left > 0) {\r\nint entry = dirty_tx % NUM_TX_DESC;\r\nint txstatus;\r\ntxstatus = NETDRV_R32(TxStatus0 + (entry * sizeof(u32)));\r\nif (!(txstatus & (TxStatOK | TxUnderrun | TxAborted)))\r\nbreak;\r\nif (txstatus & (TxOutOfWindow | TxAborted)) {\r\nnetdev_dbg(dev, "Transmit error, Tx status %#08x\n",\r\ntxstatus);\r\ndev->stats.tx_errors++;\r\nif (txstatus & TxAborted) {\r\ndev->stats.tx_aborted_errors++;\r\nNETDRV_W32(TxConfig, TxClearAbt | (TX_DMA_BURST << TxDMAShift));\r\n}\r\nif (txstatus & TxCarrierLost)\r\ndev->stats.tx_carrier_errors++;\r\nif (txstatus & TxOutOfWindow)\r\ndev->stats.tx_window_errors++;\r\n} else {\r\nif (txstatus & TxUnderrun) {\r\nif (tp->tx_flag < 0x00300000)\r\ntp->tx_flag += 0x00020000;\r\ndev->stats.tx_fifo_errors++;\r\n}\r\ndev->stats.collisions += (txstatus >> 24) & 15;\r\ndev->stats.tx_bytes += txstatus & 0x7ff;\r\ndev->stats.tx_packets++;\r\n}\r\nif (tp->tx_info[entry].mapping != 0) {\r\npci_unmap_single(tp->pci_dev,\r\ntp->tx_info[entry].mapping,\r\ntp->tx_info[entry].skb->len,\r\nPCI_DMA_TODEVICE);\r\ntp->tx_info[entry].mapping = 0;\r\n}\r\ndev_kfree_skb_irq(tp->tx_info[entry].skb);\r\ntp->tx_info[entry].skb = NULL;\r\ndirty_tx++;\r\nif (dirty_tx < 0) {\r\natomic_sub(cur_tx, &tp->cur_tx);\r\ndirty_tx = cur_tx - tx_left + 1;\r\n}\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\ncur_tx = atomic_read(&tp->cur_tx);\r\ntx_left = cur_tx - dirty_tx;\r\n}\r\n#ifndef NETDRV_NDEBUG\r\nif (atomic_read(&tp->cur_tx) - dirty_tx > NUM_TX_DESC) {\r\nnetdev_err(dev, "Out-of-sync dirty pointer, %d vs. %d\n",\r\ndirty_tx, atomic_read(&tp->cur_tx));\r\ndirty_tx += NUM_TX_DESC;\r\n}\r\n#endif\r\natomic_set(&tp->dirty_tx, dirty_tx);\r\n}\r\nstatic void netdrv_rx_err(u32 rx_status, struct net_device *dev,\r\nstruct netdrv_private *tp, void *ioaddr)\r\n{\r\nu8 tmp8;\r\nint tmp_work = 1000;\r\nnetdev_dbg(dev, "Ethernet frame had errors, status %08x\n", rx_status);\r\nif (rx_status & RxTooLong)\r\nnetdev_dbg(dev, "Oversized Ethernet frame, status %04x!\n",\r\nrx_status);\r\ndev->stats.rx_errors++;\r\nif (rx_status & (RxBadSymbol | RxBadAlign))\r\ndev->stats.rx_frame_errors++;\r\nif (rx_status & (RxRunt | RxTooLong))\r\ndev->stats.rx_length_errors++;\r\nif (rx_status & RxCRCErr)\r\ndev->stats.rx_crc_errors++;\r\ntp->cur_rx = 0;\r\ntmp8 = NETDRV_R8(ChipCmd) & ChipCmdClear;\r\nNETDRV_W8_F(ChipCmd, tmp8 | CmdTxEnb);\r\nnetdrv_set_rx_mode(dev);\r\nwhile (--tmp_work > 0) {\r\ntmp8 = NETDRV_R8(ChipCmd);\r\nif ((tmp8 & CmdRxEnb) && (tmp8 & CmdTxEnb))\r\nbreak;\r\nNETDRV_W8_F(ChipCmd,\r\n(tmp8 & ChipCmdClear) | CmdRxEnb | CmdTxEnb);\r\n}\r\nnetdrv_set_rx_mode(dev);\r\nif (tmp_work <= 0)\r\nnetdev_warn(dev, "tx/rx enable wait too long\n");\r\n}\r\nstatic void netdrv_rx_interrupt(struct net_device *dev,\r\nstruct netdrv_private *tp, void *ioaddr)\r\n{\r\nunsigned char *rx_ring;\r\nu16 cur_rx;\r\nassert(dev != NULL);\r\nassert(tp != NULL);\r\nassert(ioaddr != NULL);\r\nrx_ring = tp->rx_ring;\r\ncur_rx = tp->cur_rx;\r\nnetdev_dbg(dev, "In netdrv_rx(), current %04x BufAddr %04x, free to %04x, Cmd %02x\n",\r\ncur_rx, NETDRV_R16(RxBufAddr),\r\nNETDRV_R16(RxBufPtr), NETDRV_R8(ChipCmd));\r\nwhile ((NETDRV_R8(ChipCmd) & RxBufEmpty) == 0) {\r\nint ring_offset = cur_rx % RX_BUF_LEN;\r\nu32 rx_status;\r\nunsigned int rx_size;\r\nunsigned int pkt_size;\r\nstruct sk_buff *skb;\r\nrx_status = le32_to_cpu(*(u32 *)(rx_ring + ring_offset));\r\nrx_size = rx_status >> 16;\r\npkt_size = rx_size - 4;\r\nnetdev_dbg(dev, "netdrv_rx() status %04x, size %04x, cur %04x\n",\r\nrx_status, rx_size, cur_rx);\r\n#if defined(NETDRV_DEBUG) && (NETDRV_DEBUG > 2)\r\nprint_hex_dump_bytes("Frame contents: ", HEX_DUMP_OFFSET,\r\n&rx_ring[ring_offset], 70);\r\n#endif\r\nif ((rx_size > (MAX_ETH_FRAME_SIZE+4)) ||\r\n(!(rx_status & RxStatusOK))) {\r\nnetdrv_rx_err(rx_status, dev, tp, ioaddr);\r\nreturn;\r\n}\r\nskb = dev_alloc_skb(pkt_size + 2);\r\nif (skb) {\r\nskb_reserve(skb, 2);\r\nskb_copy_to_linear_data(skb, &rx_ring[ring_offset + 4], pkt_size);\r\nskb_put(skb, pkt_size);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_bytes += pkt_size;\r\ndev->stats.rx_packets++;\r\n} else {\r\nnetdev_warn(dev, "Memory squeeze, dropping packet\n");\r\ndev->stats.rx_dropped++;\r\n}\r\ncur_rx = (cur_rx + rx_size + 4 + 3) & ~3;\r\nNETDRV_W16_F(RxBufPtr, cur_rx - 16);\r\n}\r\nnetdev_dbg(dev, "Done netdrv_rx(), current %04x BufAddr %04x, free to %04x, Cmd %02x\n",\r\ncur_rx, NETDRV_R16(RxBufAddr),\r\nNETDRV_R16(RxBufPtr), NETDRV_R8(ChipCmd));\r\ntp->cur_rx = cur_rx;\r\n}\r\nstatic void netdrv_weird_interrupt(struct net_device *dev,\r\nstruct netdrv_private *tp,\r\nvoid *ioaddr,\r\nint status, int link_changed)\r\n{\r\nnetdev_printk(KERN_DEBUG, dev, "Abnormal interrupt, status %08x\n",\r\nstatus);\r\nassert(dev != NULL);\r\nassert(tp != NULL);\r\nassert(ioaddr != NULL);\r\ndev->stats.rx_missed_errors += NETDRV_R32(RxMissed);\r\nNETDRV_W32(RxMissed, 0);\r\nif ((status & RxUnderrun) && link_changed &&\r\n(tp->drv_flags & HAS_LNK_CHNG)) {\r\nint lpar = NETDRV_R16(NWayLPAR);\r\nint duplex = ((lpar & 0x0100) || (lpar & 0x01C0) == 0x0040 ||\r\ntp->duplex_lock);\r\nif (tp->full_duplex != duplex) {\r\ntp->full_duplex = duplex;\r\nNETDRV_W8(Cfg9346, Cfg9346_Unlock);\r\nNETDRV_W8(Config1, tp->full_duplex ? 0x60 : 0x20);\r\nNETDRV_W8(Cfg9346, Cfg9346_Lock);\r\n}\r\nstatus &= ~RxUnderrun;\r\n}\r\nif (status & (RxUnderrun | RxOverflow | RxErr | RxFIFOOver))\r\ndev->stats.rx_errors++;\r\nif (status & (PCSTimeout))\r\ndev->stats.rx_length_errors++;\r\nif (status & (RxUnderrun | RxFIFOOver))\r\ndev->stats.rx_fifo_errors++;\r\nif (status & RxOverflow) {\r\ndev->stats.rx_over_errors++;\r\ntp->cur_rx = NETDRV_R16(RxBufAddr) % RX_BUF_LEN;\r\nNETDRV_W16_F(RxBufPtr, tp->cur_rx - 16);\r\n}\r\nif (status & PCIErr) {\r\nu16 pci_cmd_status;\r\npci_read_config_word(tp->pci_dev, PCI_STATUS, &pci_cmd_status);\r\nnetdev_err(dev, "PCI Bus error %04x\n", pci_cmd_status);\r\n}\r\n}\r\nstatic irqreturn_t netdrv_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_instance;\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nint boguscnt = max_interrupt_work;\r\nvoid *ioaddr = tp->mmio_addr;\r\nint status = 0, link_changed = 0;\r\nint handled = 0;\r\nspin_lock(&tp->lock);\r\ndo {\r\nstatus = NETDRV_R16(IntrStatus);\r\nif (status == 0xFFFF)\r\nbreak;\r\nhandled = 1;\r\nNETDRV_W16_F(IntrStatus, status);\r\nnetdev_dbg(dev, "interrupt status=%#04x new intstat=%#04x\n",\r\nstatus, NETDRV_R16(IntrStatus));\r\nif ((status &\r\n(PCIErr | PCSTimeout | RxUnderrun | RxOverflow |\r\nRxFIFOOver | TxErr | TxOK | RxErr | RxOK)) == 0)\r\nbreak;\r\nif (status & (PCIErr | PCSTimeout | RxUnderrun | RxOverflow |\r\nRxFIFOOver | TxErr | RxErr))\r\nnetdrv_weird_interrupt(dev, tp, ioaddr,\r\nstatus, link_changed);\r\nif (status & (RxOK | RxUnderrun | RxOverflow | RxFIFOOver))\r\nnetdrv_rx_interrupt(dev, tp, ioaddr);\r\nif (status & (TxOK | TxErr))\r\nnetdrv_tx_interrupt(dev, tp, ioaddr);\r\nboguscnt--;\r\n} while (boguscnt > 0);\r\nif (boguscnt <= 0) {\r\nnetdev_warn(dev, "Too much work at interrupt, IntrStatus=%#04x\n",\r\nstatus);\r\nNETDRV_W16(IntrStatus, 0xffff);\r\n}\r\nspin_unlock(&tp->lock);\r\nnetdev_dbg(dev, "exiting interrupt, intr_status=%#04x\n",\r\nNETDRV_R16(IntrStatus));\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int netdrv_close(struct net_device *dev)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *ioaddr = tp->mmio_addr;\r\nunsigned long flags;\r\nDPRINTK("ENTER\n");\r\nnetif_stop_queue(dev);\r\nnetdev_dbg(dev, "Shutting down ethercard, status was %#04x\n",\r\nNETDRV_R16(IntrStatus));\r\ndel_timer_sync(&tp->timer);\r\nspin_lock_irqsave(&tp->lock, flags);\r\nNETDRV_W8(ChipCmd, (NETDRV_R8(ChipCmd) & ChipCmdClear));\r\nNETDRV_W16(IntrMask, 0x0000);\r\ndev->stats.rx_missed_errors += NETDRV_R32(RxMissed);\r\nNETDRV_W32(RxMissed, 0);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nfree_irq(dev->irq, dev);\r\nnetdrv_tx_clear(dev);\r\npci_free_consistent(tp->pci_dev, RX_BUF_TOT_LEN,\r\ntp->rx_ring, tp->rx_ring_dma);\r\npci_free_consistent(tp->pci_dev, TX_BUF_TOT_LEN,\r\ntp->tx_bufs, tp->tx_bufs_dma);\r\ntp->rx_ring = NULL;\r\ntp->tx_bufs = NULL;\r\nNETDRV_W8(Cfg9346, Cfg9346_Unlock);\r\nNETDRV_W8(Config1, 0x03);\r\nNETDRV_W8(Cfg9346, Cfg9346_Lock);\r\nDPRINTK("EXIT\n");\r\nreturn 0;\r\n}\r\nstatic int netdrv_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nunsigned long flags;\r\nint rc = 0;\r\nDPRINTK("ENTER\n");\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = tp->phys[0] & 0x3f;\r\ncase SIOCGMIIREG:\r\nspin_lock_irqsave(&tp->lock, flags);\r\ndata->val_out = mdio_read(dev, data->phy_id & 0x1f, data->reg_num & 0x1f);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nbreak;\r\ncase SIOCSMIIREG:\r\nspin_lock_irqsave(&tp->lock, flags);\r\nmdio_write(dev, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nbreak;\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nDPRINTK("EXIT, returning %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic void netdrv_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *ioaddr = tp->mmio_addr;\r\nu32 mc_filter[2];\r\nint rx_mode;\r\nu32 tmp;\r\nDPRINTK("ENTER\n");\r\nnetdev_dbg(dev, "%s(%04x) done -- Rx config %08lx\n",\r\n__func__, dev->flags, NETDRV_R32(RxConfig));\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode =\r\nAcceptBroadcast | AcceptMulticast | AcceptMyPhys |\r\nAcceptAllPhys;\r\nmc_filter[1] = mc_filter[0] = 0xffffffff;\r\n} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nrx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;\r\nmc_filter[1] = mc_filter[0] = 0xffffffff;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nrx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;\r\nmc_filter[1] = mc_filter[0] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\n}\r\n}\r\nif (!in_irq())\r\nspin_lock_irq(&tp->lock);\r\ntmp = netdrv_rx_config | rx_mode |\r\n(NETDRV_R32(RxConfig) & rtl_chip_info[tp->chipset].RxConfigMask);\r\nNETDRV_W32_F(RxConfig, tmp);\r\nNETDRV_W32_F(MAR0 + 0, mc_filter[0]);\r\nNETDRV_W32_F(MAR0 + 4, mc_filter[1]);\r\nif (!in_irq())\r\nspin_unlock_irq(&tp->lock);\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic int netdrv_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct netdrv_private *tp = netdev_priv(dev);\r\nvoid *ioaddr = tp->mmio_addr;\r\nunsigned long flags;\r\nif (!netif_running(dev))\r\nreturn 0;\r\nnetif_device_detach(dev);\r\nspin_lock_irqsave(&tp->lock, flags);\r\nNETDRV_W16(IntrMask, 0x0000);\r\nNETDRV_W8(ChipCmd, (NETDRV_R8(ChipCmd) & ChipCmdClear));\r\ndev->stats.rx_missed_errors += NETDRV_R32(RxMissed);\r\nNETDRV_W32(RxMissed, 0);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int netdrv_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nnetif_device_attach(dev);\r\nnetdrv_hw_start(dev);\r\nreturn 0;\r\n}\r\nstatic int __init netdrv_init_module(void)\r\n{\r\n#ifdef MODULE\r\nprintk(version);\r\n#endif\r\nreturn pci_register_driver(&netdrv_pci_driver);\r\n}\r\nstatic void __exit netdrv_cleanup_module(void)\r\n{\r\npci_unregister_driver(&netdrv_pci_driver);\r\n}
