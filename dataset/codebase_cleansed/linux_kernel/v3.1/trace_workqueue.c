static void cpu_workqueue_stat_free(struct kref *kref)\r\n{\r\nkfree(container_of(kref, struct cpu_workqueue_stats, kref));\r\n}\r\nstatic void\r\nprobe_workqueue_insertion(void *ignore,\r\nstruct task_struct *wq_thread,\r\nstruct work_struct *work)\r\n{\r\nint cpu = cpumask_first(&wq_thread->cpus_allowed);\r\nstruct cpu_workqueue_stats *node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&workqueue_cpu_stat(cpu)->lock, flags);\r\nlist_for_each_entry(node, &workqueue_cpu_stat(cpu)->list, list) {\r\nif (node->pid == wq_thread->pid) {\r\natomic_inc(&node->inserted);\r\ngoto found;\r\n}\r\n}\r\npr_debug("trace_workqueue: entry not found\n");\r\nfound:\r\nspin_unlock_irqrestore(&workqueue_cpu_stat(cpu)->lock, flags);\r\n}\r\nstatic void\r\nprobe_workqueue_execution(void *ignore,\r\nstruct task_struct *wq_thread,\r\nstruct work_struct *work)\r\n{\r\nint cpu = cpumask_first(&wq_thread->cpus_allowed);\r\nstruct cpu_workqueue_stats *node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&workqueue_cpu_stat(cpu)->lock, flags);\r\nlist_for_each_entry(node, &workqueue_cpu_stat(cpu)->list, list) {\r\nif (node->pid == wq_thread->pid) {\r\nnode->executed++;\r\ngoto found;\r\n}\r\n}\r\npr_debug("trace_workqueue: entry not found\n");\r\nfound:\r\nspin_unlock_irqrestore(&workqueue_cpu_stat(cpu)->lock, flags);\r\n}\r\nstatic void probe_workqueue_creation(void *ignore,\r\nstruct task_struct *wq_thread, int cpu)\r\n{\r\nstruct cpu_workqueue_stats *cws;\r\nunsigned long flags;\r\nWARN_ON(cpu < 0);\r\ncws = kzalloc(sizeof(struct cpu_workqueue_stats), GFP_ATOMIC);\r\nif (!cws) {\r\npr_warning("trace_workqueue: not enough memory\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&cws->list);\r\nkref_init(&cws->kref);\r\ncws->cpu = cpu;\r\ncws->pid = wq_thread->pid;\r\nspin_lock_irqsave(&workqueue_cpu_stat(cpu)->lock, flags);\r\nlist_add_tail(&cws->list, &workqueue_cpu_stat(cpu)->list);\r\nspin_unlock_irqrestore(&workqueue_cpu_stat(cpu)->lock, flags);\r\n}\r\nstatic void\r\nprobe_workqueue_destruction(void *ignore, struct task_struct *wq_thread)\r\n{\r\nint cpu = cpumask_first(&wq_thread->cpus_allowed);\r\nstruct cpu_workqueue_stats *node, *next;\r\nunsigned long flags;\r\nspin_lock_irqsave(&workqueue_cpu_stat(cpu)->lock, flags);\r\nlist_for_each_entry_safe(node, next, &workqueue_cpu_stat(cpu)->list,\r\nlist) {\r\nif (node->pid == wq_thread->pid) {\r\nlist_del(&node->list);\r\nkref_put(&node->kref, cpu_workqueue_stat_free);\r\ngoto found;\r\n}\r\n}\r\npr_debug("trace_workqueue: don't find workqueue to destroy\n");\r\nfound:\r\nspin_unlock_irqrestore(&workqueue_cpu_stat(cpu)->lock, flags);\r\n}\r\nstatic struct cpu_workqueue_stats *workqueue_stat_start_cpu(int cpu)\r\n{\r\nunsigned long flags;\r\nstruct cpu_workqueue_stats *ret = NULL;\r\nspin_lock_irqsave(&workqueue_cpu_stat(cpu)->lock, flags);\r\nif (!list_empty(&workqueue_cpu_stat(cpu)->list)) {\r\nret = list_entry(workqueue_cpu_stat(cpu)->list.next,\r\nstruct cpu_workqueue_stats, list);\r\nkref_get(&ret->kref);\r\n}\r\nspin_unlock_irqrestore(&workqueue_cpu_stat(cpu)->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void *workqueue_stat_start(struct tracer_stat *trace)\r\n{\r\nint cpu;\r\nvoid *ret = NULL;\r\nfor_each_possible_cpu(cpu) {\r\nret = workqueue_stat_start_cpu(cpu);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *workqueue_stat_next(void *prev, int idx)\r\n{\r\nstruct cpu_workqueue_stats *prev_cws = prev;\r\nstruct cpu_workqueue_stats *ret;\r\nint cpu = prev_cws->cpu;\r\nunsigned long flags;\r\nspin_lock_irqsave(&workqueue_cpu_stat(cpu)->lock, flags);\r\nif (list_is_last(&prev_cws->list, &workqueue_cpu_stat(cpu)->list)) {\r\nspin_unlock_irqrestore(&workqueue_cpu_stat(cpu)->lock, flags);\r\ndo {\r\ncpu = cpumask_next(cpu, cpu_possible_mask);\r\nif (cpu >= nr_cpu_ids)\r\nreturn NULL;\r\n} while (!(ret = workqueue_stat_start_cpu(cpu)));\r\nreturn ret;\r\n} else {\r\nret = list_entry(prev_cws->list.next,\r\nstruct cpu_workqueue_stats, list);\r\nkref_get(&ret->kref);\r\n}\r\nspin_unlock_irqrestore(&workqueue_cpu_stat(cpu)->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int workqueue_stat_show(struct seq_file *s, void *p)\r\n{\r\nstruct cpu_workqueue_stats *cws = p;\r\nstruct pid *pid;\r\nstruct task_struct *tsk;\r\npid = find_get_pid(cws->pid);\r\nif (pid) {\r\ntsk = get_pid_task(pid, PIDTYPE_PID);\r\nif (tsk) {\r\nseq_printf(s, "%3d %6d %6u %s\n", cws->cpu,\r\natomic_read(&cws->inserted), cws->executed,\r\ntsk->comm);\r\nput_task_struct(tsk);\r\n}\r\nput_pid(pid);\r\n}\r\nreturn 0;\r\n}\r\nstatic void workqueue_stat_release(void *stat)\r\n{\r\nstruct cpu_workqueue_stats *node = stat;\r\nkref_put(&node->kref, cpu_workqueue_stat_free);\r\n}\r\nstatic int workqueue_stat_headers(struct seq_file *s)\r\n{\r\nseq_printf(s, "# CPU INSERTED EXECUTED NAME\n");\r\nseq_printf(s, "# | | | |\n");\r\nreturn 0;\r\n}\r\nint __init stat_workqueue_init(void)\r\n{\r\nif (register_stat_tracer(&workqueue_stats)) {\r\npr_warning("Unable to register workqueue stat tracer\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint __init trace_workqueue_early_init(void)\r\n{\r\nint ret, cpu;\r\nfor_each_possible_cpu(cpu) {\r\nspin_lock_init(&workqueue_cpu_stat(cpu)->lock);\r\nINIT_LIST_HEAD(&workqueue_cpu_stat(cpu)->list);\r\n}\r\nret = register_trace_workqueue_insertion(probe_workqueue_insertion, NULL);\r\nif (ret)\r\ngoto out;\r\nret = register_trace_workqueue_execution(probe_workqueue_execution, NULL);\r\nif (ret)\r\ngoto no_insertion;\r\nret = register_trace_workqueue_creation(probe_workqueue_creation, NULL);\r\nif (ret)\r\ngoto no_execution;\r\nret = register_trace_workqueue_destruction(probe_workqueue_destruction, NULL);\r\nif (ret)\r\ngoto no_creation;\r\nreturn 0;\r\nno_creation:\r\nunregister_trace_workqueue_creation(probe_workqueue_creation, NULL);\r\nno_execution:\r\nunregister_trace_workqueue_execution(probe_workqueue_execution, NULL);\r\nno_insertion:\r\nunregister_trace_workqueue_insertion(probe_workqueue_insertion, NULL);\r\nout:\r\npr_warning("trace_workqueue: unable to trace workqueues\n");\r\nreturn 1;\r\n}
