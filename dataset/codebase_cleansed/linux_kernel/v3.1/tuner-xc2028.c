static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)\r\n{\r\nunsigned char buf[2];\r\nunsigned char ibuf[2];\r\ntuner_dbg("%s %04x called\n", __func__, reg);\r\nbuf[0] = reg >> 8;\r\nbuf[1] = (unsigned char) reg;\r\nif (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)\r\nreturn -EIO;\r\n*val = (ibuf[1]) | (ibuf[0] << 8);\r\nreturn 0;\r\n}\r\nstatic void dump_firm_type_and_int_freq(unsigned int type, u16 int_freq)\r\n{\r\nif (type & BASE)\r\nprintk("BASE ");\r\nif (type & INIT1)\r\nprintk("INIT1 ");\r\nif (type & F8MHZ)\r\nprintk("F8MHZ ");\r\nif (type & MTS)\r\nprintk("MTS ");\r\nif (type & D2620)\r\nprintk("D2620 ");\r\nif (type & D2633)\r\nprintk("D2633 ");\r\nif (type & DTV6)\r\nprintk("DTV6 ");\r\nif (type & QAM)\r\nprintk("QAM ");\r\nif (type & DTV7)\r\nprintk("DTV7 ");\r\nif (type & DTV78)\r\nprintk("DTV78 ");\r\nif (type & DTV8)\r\nprintk("DTV8 ");\r\nif (type & FM)\r\nprintk("FM ");\r\nif (type & INPUT1)\r\nprintk("INPUT1 ");\r\nif (type & LCD)\r\nprintk("LCD ");\r\nif (type & NOGD)\r\nprintk("NOGD ");\r\nif (type & MONO)\r\nprintk("MONO ");\r\nif (type & ATSC)\r\nprintk("ATSC ");\r\nif (type & IF)\r\nprintk("IF ");\r\nif (type & LG60)\r\nprintk("LG60 ");\r\nif (type & ATI638)\r\nprintk("ATI638 ");\r\nif (type & OREN538)\r\nprintk("OREN538 ");\r\nif (type & OREN36)\r\nprintk("OREN36 ");\r\nif (type & TOYOTA388)\r\nprintk("TOYOTA388 ");\r\nif (type & TOYOTA794)\r\nprintk("TOYOTA794 ");\r\nif (type & DIBCOM52)\r\nprintk("DIBCOM52 ");\r\nif (type & ZARLINK456)\r\nprintk("ZARLINK456 ");\r\nif (type & CHINA)\r\nprintk("CHINA ");\r\nif (type & F6MHZ)\r\nprintk("F6MHZ ");\r\nif (type & INPUT2)\r\nprintk("INPUT2 ");\r\nif (type & SCODE)\r\nprintk("SCODE ");\r\nif (type & HAS_IF)\r\nprintk("HAS_IF_%d ", int_freq);\r\n}\r\nstatic v4l2_std_id parse_audio_std_option(void)\r\n{\r\nif (strcasecmp(audio_std, "A2") == 0)\r\nreturn V4L2_STD_A2;\r\nif (strcasecmp(audio_std, "A2/A") == 0)\r\nreturn V4L2_STD_A2_A;\r\nif (strcasecmp(audio_std, "A2/B") == 0)\r\nreturn V4L2_STD_A2_B;\r\nif (strcasecmp(audio_std, "NICAM") == 0)\r\nreturn V4L2_STD_NICAM;\r\nif (strcasecmp(audio_std, "NICAM/A") == 0)\r\nreturn V4L2_STD_NICAM_A;\r\nif (strcasecmp(audio_std, "NICAM/B") == 0)\r\nreturn V4L2_STD_NICAM_B;\r\nreturn 0;\r\n}\r\nstatic void free_firmware(struct xc2028_data *priv)\r\n{\r\nint i;\r\ntuner_dbg("%s called\n", __func__);\r\nif (!priv->firm)\r\nreturn;\r\nfor (i = 0; i < priv->firm_size; i++)\r\nkfree(priv->firm[i].ptr);\r\nkfree(priv->firm);\r\npriv->firm = NULL;\r\npriv->firm_size = 0;\r\nmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\r\n}\r\nstatic int load_all_firmwares(struct dvb_frontend *fe)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nconst struct firmware *fw = NULL;\r\nconst unsigned char *p, *endp;\r\nint rc = 0;\r\nint n, n_array;\r\nchar name[33];\r\nchar *fname;\r\ntuner_dbg("%s called\n", __func__);\r\nif (!firmware_name[0])\r\nfname = priv->ctrl.fname;\r\nelse\r\nfname = firmware_name;\r\ntuner_dbg("Reading firmware %s\n", fname);\r\nrc = request_firmware(&fw, fname, priv->i2c_props.adap->dev.parent);\r\nif (rc < 0) {\r\nif (rc == -ENOENT)\r\ntuner_err("Error: firmware %s not found.\n",\r\nfname);\r\nelse\r\ntuner_err("Error %d while requesting firmware %s \n",\r\nrc, fname);\r\nreturn rc;\r\n}\r\np = fw->data;\r\nendp = p + fw->size;\r\nif (fw->size < sizeof(name) - 1 + 2 + 2) {\r\ntuner_err("Error: firmware file %s has invalid size!\n",\r\nfname);\r\ngoto corrupt;\r\n}\r\nmemcpy(name, p, sizeof(name) - 1);\r\nname[sizeof(name) - 1] = 0;\r\np += sizeof(name) - 1;\r\npriv->firm_version = get_unaligned_le16(p);\r\np += 2;\r\nn_array = get_unaligned_le16(p);\r\np += 2;\r\ntuner_info("Loading %d firmware images from %s, type: %s, ver %d.%d\n",\r\nn_array, fname, name,\r\npriv->firm_version >> 8, priv->firm_version & 0xff);\r\npriv->firm = kzalloc(sizeof(*priv->firm) * n_array, GFP_KERNEL);\r\nif (priv->firm == NULL) {\r\ntuner_err("Not enough memory to load firmware file.\n");\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\npriv->firm_size = n_array;\r\nn = -1;\r\nwhile (p < endp) {\r\n__u32 type, size;\r\nv4l2_std_id id;\r\n__u16 int_freq = 0;\r\nn++;\r\nif (n >= n_array) {\r\ntuner_err("More firmware images in file than "\r\n"were expected!\n");\r\ngoto corrupt;\r\n}\r\nif (endp - p < sizeof(type) + sizeof(id) + sizeof(size))\r\ngoto header;\r\ntype = get_unaligned_le32(p);\r\np += sizeof(type);\r\nid = get_unaligned_le64(p);\r\np += sizeof(id);\r\nif (type & HAS_IF) {\r\nint_freq = get_unaligned_le16(p);\r\np += sizeof(int_freq);\r\nif (endp - p < sizeof(size))\r\ngoto header;\r\n}\r\nsize = get_unaligned_le32(p);\r\np += sizeof(size);\r\nif (!size || size > endp - p) {\r\ntuner_err("Firmware type ");\r\ndump_firm_type(type);\r\nprintk("(%x), id %llx is corrupted "\r\n"(size=%d, expected %d)\n",\r\ntype, (unsigned long long)id,\r\n(unsigned)(endp - p), size);\r\ngoto corrupt;\r\n}\r\npriv->firm[n].ptr = kzalloc(size, GFP_KERNEL);\r\nif (priv->firm[n].ptr == NULL) {\r\ntuner_err("Not enough memory to load firmware file.\n");\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\ntuner_dbg("Reading firmware type ");\r\nif (debug) {\r\ndump_firm_type_and_int_freq(type, int_freq);\r\nprintk("(%x), id %llx, size=%d.\n",\r\ntype, (unsigned long long)id, size);\r\n}\r\nmemcpy(priv->firm[n].ptr, p, size);\r\npriv->firm[n].type = type;\r\npriv->firm[n].id = id;\r\npriv->firm[n].size = size;\r\npriv->firm[n].int_freq = int_freq;\r\np += size;\r\n}\r\nif (n + 1 != priv->firm_size) {\r\ntuner_err("Firmware file is incomplete!\n");\r\ngoto corrupt;\r\n}\r\ngoto done;\r\nheader:\r\ntuner_err("Firmware header is incomplete!\n");\r\ncorrupt:\r\nrc = -EINVAL;\r\ntuner_err("Error: firmware file is corrupted!\n");\r\nerr:\r\ntuner_info("Releasing partially loaded firmware file.\n");\r\nfree_firmware(priv);\r\ndone:\r\nrelease_firmware(fw);\r\nif (rc == 0)\r\ntuner_dbg("Firmware files loaded.\n");\r\nreturn rc;\r\n}\r\nstatic int seek_firmware(struct dvb_frontend *fe, unsigned int type,\r\nv4l2_std_id *id)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nint i, best_i = -1, best_nr_matches = 0;\r\nunsigned int type_mask = 0;\r\ntuner_dbg("%s called, want type=", __func__);\r\nif (debug) {\r\ndump_firm_type(type);\r\nprintk("(%x), id %016llx.\n", type, (unsigned long long)*id);\r\n}\r\nif (!priv->firm) {\r\ntuner_err("Error! firmware not loaded\n");\r\nreturn -EINVAL;\r\n}\r\nif (((type & ~SCODE) == 0) && (*id == 0))\r\n*id = V4L2_STD_PAL;\r\nif (type & BASE)\r\ntype_mask = BASE_TYPES;\r\nelse if (type & SCODE) {\r\ntype &= SCODE_TYPES;\r\ntype_mask = SCODE_TYPES & ~HAS_IF;\r\n} else if (type & DTV_TYPES)\r\ntype_mask = DTV_TYPES;\r\nelse if (type & STD_SPECIFIC_TYPES)\r\ntype_mask = STD_SPECIFIC_TYPES;\r\ntype &= type_mask;\r\nif (!(type & SCODE))\r\ntype_mask = ~0;\r\nfor (i = 0; i < priv->firm_size; i++) {\r\nif ((type == (priv->firm[i].type & type_mask)) &&\r\n(*id == priv->firm[i].id))\r\ngoto found;\r\n}\r\nfor (i = 0; i < priv->firm_size; i++) {\r\nv4l2_std_id match_mask;\r\nint nr_matches;\r\nif (type != (priv->firm[i].type & type_mask))\r\ncontinue;\r\nmatch_mask = *id & priv->firm[i].id;\r\nif (!match_mask)\r\ncontinue;\r\nif ((*id & match_mask) == *id)\r\ngoto found;\r\nnr_matches = hweight64(match_mask);\r\nif (nr_matches > best_nr_matches) {\r\nbest_nr_matches = nr_matches;\r\nbest_i = i;\r\n}\r\n}\r\nif (best_nr_matches > 0) {\r\ntuner_dbg("Selecting best matching firmware (%d bits) for "\r\n"type=", best_nr_matches);\r\ndump_firm_type(type);\r\nprintk("(%x), id %016llx:\n", type, (unsigned long long)*id);\r\ni = best_i;\r\ngoto found;\r\n}\r\ni = -ENOENT;\r\ngoto ret;\r\nfound:\r\n*id = priv->firm[i].id;\r\nret:\r\ntuner_dbg("%s firmware for type=", (i < 0) ? "Can't find" : "Found");\r\nif (debug) {\r\ndump_firm_type(type);\r\nprintk("(%x), id %016llx.\n", type, (unsigned long long)*id);\r\n}\r\nreturn i;\r\n}\r\nstatic inline int do_tuner_callback(struct dvb_frontend *fe, int cmd, int arg)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nreturn (!fe->callback) ? -EINVAL :\r\nfe->callback(((fe->dvb) && (fe->dvb->priv)) ?\r\nfe->dvb->priv : priv->i2c_props.adap->algo_data,\r\nDVB_FRONTEND_COMPONENT_TUNER, cmd, arg);\r\n}\r\nstatic int load_firmware(struct dvb_frontend *fe, unsigned int type,\r\nv4l2_std_id *id)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nint pos, rc;\r\nunsigned char *p, *endp, buf[priv->ctrl.max_len];\r\ntuner_dbg("%s called\n", __func__);\r\npos = seek_firmware(fe, type, id);\r\nif (pos < 0)\r\nreturn pos;\r\ntuner_info("Loading firmware for type=");\r\ndump_firm_type(priv->firm[pos].type);\r\nprintk("(%x), id %016llx.\n", priv->firm[pos].type,\r\n(unsigned long long)*id);\r\np = priv->firm[pos].ptr;\r\nendp = p + priv->firm[pos].size;\r\nwhile (p < endp) {\r\n__u16 size;\r\nif (p + sizeof(size) > endp) {\r\ntuner_err("Firmware chunk size is wrong\n");\r\nreturn -EINVAL;\r\n}\r\nsize = le16_to_cpu(*(__u16 *) p);\r\np += sizeof(size);\r\nif (size == 0xffff)\r\nreturn 0;\r\nif (!size) {\r\nrc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\r\nif (rc < 0) {\r\ntuner_err("Error at RESET code %d\n",\r\n(*p) & 0x7f);\r\nreturn -EINVAL;\r\n}\r\ncontinue;\r\n}\r\nif (size >= 0xff00) {\r\nswitch (size) {\r\ncase 0xff00:\r\nrc = do_tuner_callback(fe, XC2028_RESET_CLK, 0);\r\nif (rc < 0) {\r\ntuner_err("Error at RESET code %d\n",\r\n(*p) & 0x7f);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ntuner_info("Invalid RESET code %d\n",\r\nsize & 0x7f);\r\nreturn -EINVAL;\r\n}\r\ncontinue;\r\n}\r\nif (size & 0x8000) {\r\nmsleep(size & 0x7fff);\r\ncontinue;\r\n}\r\nif ((size + p > endp)) {\r\ntuner_err("missing bytes: need %d, have %d\n",\r\nsize, (int)(endp - p));\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = *p;\r\np++;\r\nsize--;\r\nwhile (size > 0) {\r\nint len = (size < priv->ctrl.max_len - 1) ?\r\nsize : priv->ctrl.max_len - 1;\r\nmemcpy(buf + 1, p, len);\r\nrc = i2c_send(priv, buf, len + 1);\r\nif (rc < 0) {\r\ntuner_err("%d returned from send\n", rc);\r\nreturn -EINVAL;\r\n}\r\np += len;\r\nsize -= len;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int load_scode(struct dvb_frontend *fe, unsigned int type,\r\nv4l2_std_id *id, __u16 int_freq, int scode)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nint pos, rc;\r\nunsigned char *p;\r\ntuner_dbg("%s called\n", __func__);\r\nif (!int_freq) {\r\npos = seek_firmware(fe, type, id);\r\nif (pos < 0)\r\nreturn pos;\r\n} else {\r\nfor (pos = 0; pos < priv->firm_size; pos++) {\r\nif ((priv->firm[pos].int_freq == int_freq) &&\r\n(priv->firm[pos].type & HAS_IF))\r\nbreak;\r\n}\r\nif (pos == priv->firm_size)\r\nreturn -ENOENT;\r\n}\r\np = priv->firm[pos].ptr;\r\nif (priv->firm[pos].type & HAS_IF) {\r\nif (priv->firm[pos].size != 12 * 16 || scode >= 16)\r\nreturn -EINVAL;\r\np += 12 * scode;\r\n} else {\r\nif (priv->firm[pos].size != 14 * 16 || scode >= 16 ||\r\nle16_to_cpu(*(__u16 *)(p + 14 * scode)) != 12)\r\nreturn -EINVAL;\r\np += 14 * scode + 2;\r\n}\r\ntuner_info("Loading SCODE for type=");\r\ndump_firm_type_and_int_freq(priv->firm[pos].type,\r\npriv->firm[pos].int_freq);\r\nprintk("(%x), id %016llx.\n", priv->firm[pos].type,\r\n(unsigned long long)*id);\r\nif (priv->firm_version < 0x0202)\r\nrc = send_seq(priv, {0x20, 0x00, 0x00, 0x00});\r\nelse\r\nrc = send_seq(priv, {0xa0, 0x00, 0x00, 0x00});\r\nif (rc < 0)\r\nreturn -EIO;\r\nrc = i2c_send(priv, p, 12);\r\nif (rc < 0)\r\nreturn -EIO;\r\nrc = send_seq(priv, {0x00, 0x8c});\r\nif (rc < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int check_firmware(struct dvb_frontend *fe, unsigned int type,\r\nv4l2_std_id std, __u16 int_freq)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nstruct firmware_properties new_fw;\r\nint rc = 0, retry_count = 0;\r\nu16 version, hwmodel;\r\nv4l2_std_id std0;\r\ntuner_dbg("%s called\n", __func__);\r\nif (!priv->firm) {\r\nif (!priv->ctrl.fname) {\r\ntuner_info("xc2028/3028 firmware name not set!\n");\r\nreturn -EINVAL;\r\n}\r\nrc = load_all_firmwares(fe);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nif (priv->ctrl.mts && !(type & FM))\r\ntype |= MTS;\r\nretry:\r\nnew_fw.type = type;\r\nnew_fw.id = std;\r\nnew_fw.std_req = std;\r\nnew_fw.scode_table = SCODE | priv->ctrl.scode_table;\r\nnew_fw.scode_nr = 0;\r\nnew_fw.int_freq = int_freq;\r\ntuner_dbg("checking firmware, user requested type=");\r\nif (debug) {\r\ndump_firm_type(new_fw.type);\r\nprintk("(%x), id %016llx, ", new_fw.type,\r\n(unsigned long long)new_fw.std_req);\r\nif (!int_freq) {\r\nprintk("scode_tbl ");\r\ndump_firm_type(priv->ctrl.scode_table);\r\nprintk("(%x), ", priv->ctrl.scode_table);\r\n} else\r\nprintk("int_freq %d, ", new_fw.int_freq);\r\nprintk("scode_nr %d\n", new_fw.scode_nr);\r\n}\r\nif (((BASE | new_fw.type) & BASE_TYPES) ==\r\n(priv->cur_fw.type & BASE_TYPES)) {\r\ntuner_dbg("BASE firmware not changed.\n");\r\ngoto skip_base;\r\n}\r\nmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\r\nrc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\r\nif (rc < 0)\r\ngoto fail;\r\nstd0 = 0;\r\nrc = load_firmware(fe, BASE | new_fw.type, &std0);\r\nif (rc < 0) {\r\ntuner_err("Error %d while loading base firmware\n",\r\nrc);\r\ngoto fail;\r\n}\r\ntuner_dbg("Load init1 firmware, if exists\n");\r\nrc = load_firmware(fe, BASE | INIT1 | new_fw.type, &std0);\r\nif (rc == -ENOENT)\r\nrc = load_firmware(fe, (BASE | INIT1 | new_fw.type) & ~F8MHZ,\r\n&std0);\r\nif (rc < 0 && rc != -ENOENT) {\r\ntuner_err("Error %d while loading init1 firmware\n",\r\nrc);\r\ngoto fail;\r\n}\r\nskip_base:\r\nif (priv->cur_fw.type == (BASE | new_fw.type) &&\r\npriv->cur_fw.std_req == std) {\r\ntuner_dbg("Std-specific firmware already loaded.\n");\r\ngoto skip_std_specific;\r\n}\r\npriv->cur_fw.scode_table = 0;\r\nrc = load_firmware(fe, new_fw.type, &new_fw.id);\r\nif (rc == -ENOENT)\r\nrc = load_firmware(fe, new_fw.type & ~F8MHZ, &new_fw.id);\r\nif (rc < 0)\r\ngoto fail;\r\nskip_std_specific:\r\nif (priv->cur_fw.scode_table == new_fw.scode_table &&\r\npriv->cur_fw.scode_nr == new_fw.scode_nr) {\r\ntuner_dbg("SCODE firmware already loaded.\n");\r\ngoto check_device;\r\n}\r\nif (new_fw.type & FM)\r\ngoto check_device;\r\ntuner_dbg("Trying to load scode %d\n", new_fw.scode_nr);\r\nrc = load_scode(fe, new_fw.type | new_fw.scode_table, &new_fw.id,\r\nnew_fw.int_freq, new_fw.scode_nr);\r\ncheck_device:\r\nif (xc2028_get_reg(priv, 0x0004, &version) < 0 ||\r\nxc2028_get_reg(priv, 0x0008, &hwmodel) < 0) {\r\ntuner_err("Unable to read tuner registers.\n");\r\ngoto fail;\r\n}\r\ntuner_dbg("Device is Xceive %d version %d.%d, "\r\n"firmware version %d.%d\n",\r\nhwmodel, (version & 0xf000) >> 12, (version & 0xf00) >> 8,\r\n(version & 0xf0) >> 4, version & 0xf);\r\nif (priv->ctrl.read_not_reliable)\r\ngoto read_not_reliable;\r\nif (priv->firm_version != ((version & 0xf0) << 4 | (version & 0x0f))) {\r\nif (!priv->ctrl.read_not_reliable) {\r\ntuner_err("Incorrect readback of firmware version.\n");\r\ngoto fail;\r\n} else {\r\ntuner_err("Returned an incorrect version. However, "\r\n"read is not reliable enough. Ignoring it.\n");\r\nhwmodel = 3028;\r\n}\r\n}\r\nif (priv->hwmodel == 0 && (hwmodel == 2028 || hwmodel == 3028)) {\r\npriv->hwmodel = hwmodel;\r\npriv->hwvers = version & 0xff00;\r\n} else if (priv->hwmodel == 0 || priv->hwmodel != hwmodel ||\r\npriv->hwvers != (version & 0xff00)) {\r\ntuner_err("Read invalid device hardware information - tuner "\r\n"hung?\n");\r\ngoto fail;\r\n}\r\nread_not_reliable:\r\nmemcpy(&priv->cur_fw, &new_fw, sizeof(priv->cur_fw));\r\npriv->cur_fw.type |= BASE;\r\nreturn 0;\r\nfail:\r\nmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\r\nif (retry_count < 8) {\r\nmsleep(50);\r\nretry_count++;\r\ntuner_dbg("Retrying firmware load\n");\r\ngoto retry;\r\n}\r\nif (rc == -ENOENT)\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nstatic int xc2028_signal(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nu16 frq_lock, signal = 0;\r\nint rc;\r\ntuner_dbg("%s called\n", __func__);\r\nmutex_lock(&priv->lock);\r\nrc = xc2028_get_reg(priv, 0x0002, &frq_lock);\r\nif (rc < 0)\r\ngoto ret;\r\nif (frq_lock == 1)\r\nsignal = 32768;\r\nrc = xc2028_get_reg(priv, 0x0040, &signal);\r\nif (rc < 0)\r\ngoto ret;\r\nsignal = signal || ((signal & 0x07) << 12);\r\nret:\r\nmutex_unlock(&priv->lock);\r\n*strength = signal;\r\ntuner_dbg("signal strength is %d\n", signal);\r\nreturn rc;\r\n}\r\nstatic int generic_set_freq(struct dvb_frontend *fe, u32 freq ,\r\nenum v4l2_tuner_type new_type,\r\nunsigned int type,\r\nv4l2_std_id std,\r\nu16 int_freq)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nint rc = -EINVAL;\r\nunsigned char buf[4];\r\nu32 div, offset = 0;\r\ntuner_dbg("%s called\n", __func__);\r\nmutex_lock(&priv->lock);\r\ntuner_dbg("should set frequency %d kHz\n", freq / 1000);\r\nif (check_firmware(fe, type, std, int_freq) < 0)\r\ngoto ret;\r\nif (new_type == V4L2_TUNER_ANALOG_TV) {\r\nrc = send_seq(priv, {0x00, 0x00});\r\n} else {\r\nif (priv->cur_fw.type & DTV6)\r\noffset = 1750000;\r\nelse if (priv->cur_fw.type & DTV7)\r\noffset = 2250000;\r\nelse\r\noffset = 2750000;\r\nif ((priv->cur_fw.type & DTV78) && freq < 470000000)\r\noffset -= 500000;\r\n#if 1\r\nif (priv->cur_fw.type & DTV7)\r\noffset += 500000;\r\n#else\r\nif (priv->firm_version < 0x0302) {\r\nif (priv->cur_fw.type & DTV7)\r\noffset += 500000;\r\n} else {\r\nif (priv->cur_fw.type & DTV7)\r\noffset -= 300000;\r\nelse if (type != ATSC)\r\noffset += 200000;\r\n}\r\n#endif\r\n}\r\ndiv = (freq - offset + DIV / 2) / DIV;\r\nif (priv->firm_version < 0x0202)\r\nrc = send_seq(priv, {0x00, 0x02, 0x00, 0x00});\r\nelse\r\nrc = send_seq(priv, {0x80, 0x02, 0x00, 0x00});\r\nif (rc < 0)\r\ngoto ret;\r\nif (priv->ctrl.msleep)\r\nmsleep(priv->ctrl.msleep);\r\ndo_tuner_callback(fe, XC2028_RESET_CLK, 1);\r\nmsleep(10);\r\nbuf[0] = 0xff & (div >> 24);\r\nbuf[1] = 0xff & (div >> 16);\r\nbuf[2] = 0xff & (div >> 8);\r\nbuf[3] = 0xff & (div);\r\nrc = i2c_send(priv, buf, sizeof(buf));\r\nif (rc < 0)\r\ngoto ret;\r\nmsleep(100);\r\npriv->frequency = freq;\r\ntuner_dbg("divisor= %02x %02x %02x %02x (freq=%d.%03d)\n",\r\nbuf[0], buf[1], buf[2], buf[3],\r\nfreq / 1000000, (freq % 1000000) / 1000);\r\nrc = 0;\r\nret:\r\nmutex_unlock(&priv->lock);\r\nreturn rc;\r\n}\r\nstatic int xc2028_set_analog_freq(struct dvb_frontend *fe,\r\nstruct analog_parameters *p)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nunsigned int type=0;\r\ntuner_dbg("%s called\n", __func__);\r\nif (p->mode == V4L2_TUNER_RADIO) {\r\ntype |= FM;\r\nif (priv->ctrl.input1)\r\ntype |= INPUT1;\r\nreturn generic_set_freq(fe, (625l * p->frequency) / 10,\r\nV4L2_TUNER_RADIO, type, 0, 0);\r\n}\r\nif (!p->std)\r\np->std = V4L2_STD_MN;\r\nif (!(p->std & V4L2_STD_MN))\r\ntype |= F8MHZ;\r\np->std |= parse_audio_std_option();\r\nreturn generic_set_freq(fe, 62500l * p->frequency,\r\nV4L2_TUNER_ANALOG_TV, type, p->std, 0);\r\n}\r\nstatic int xc2028_set_params(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nunsigned int type=0;\r\nfe_bandwidth_t bw = BANDWIDTH_8_MHZ;\r\nu16 demod = 0;\r\ntuner_dbg("%s called\n", __func__);\r\nswitch(fe->ops.info.type) {\r\ncase FE_OFDM:\r\nbw = p->u.ofdm.bandwidth;\r\nif (bw == BANDWIDTH_6_MHZ)\r\ntype |= QAM;\r\nbreak;\r\ncase FE_ATSC:\r\nbw = BANDWIDTH_6_MHZ;\r\ntype |= ATSC | D2633;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (bw) {\r\ncase BANDWIDTH_8_MHZ:\r\nif (p->frequency < 470000000)\r\npriv->ctrl.vhfbw7 = 0;\r\nelse\r\npriv->ctrl.uhfbw8 = 1;\r\ntype |= (priv->ctrl.vhfbw7 && priv->ctrl.uhfbw8) ? DTV78 : DTV8;\r\ntype |= F8MHZ;\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\nif (p->frequency < 470000000)\r\npriv->ctrl.vhfbw7 = 1;\r\nelse\r\npriv->ctrl.uhfbw8 = 0;\r\ntype |= (priv->ctrl.vhfbw7 && priv->ctrl.uhfbw8) ? DTV78 : DTV7;\r\ntype |= F8MHZ;\r\nbreak;\r\ncase BANDWIDTH_6_MHZ:\r\ntype |= DTV6;\r\npriv->ctrl.vhfbw7 = 0;\r\npriv->ctrl.uhfbw8 = 0;\r\nbreak;\r\ndefault:\r\ntuner_err("error: bandwidth not supported.\n");\r\n};\r\nif (fe->ops.info.type != FE_ATSC) {\r\nswitch (priv->ctrl.type) {\r\ncase XC2028_D2633:\r\ntype |= D2633;\r\nbreak;\r\ncase XC2028_D2620:\r\ntype |= D2620;\r\nbreak;\r\ncase XC2028_AUTO:\r\ndefault:\r\nif (priv->ctrl.demod == XC3028_FE_ZARLINK456)\r\ntype |= D2633;\r\nelse\r\ntype |= D2620;\r\n}\r\n}\r\nif (priv->ctrl.demod) {\r\ndemod = priv->ctrl.demod;\r\nif (type == ATSC || priv->firm_version < 0x0302)\r\ndemod += 200;\r\n}\r\nreturn generic_set_freq(fe, p->frequency,\r\nV4L2_TUNER_DIGITAL_TV, type, 0, demod);\r\n}\r\nstatic int xc2028_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nint rc = 0;\r\nif (no_poweroff || priv->ctrl.disable_power_mgmt)\r\nreturn 0;\r\ntuner_dbg("Putting xc2028/3028 into poweroff mode.\n");\r\nif (debug > 1) {\r\ntuner_dbg("Printing sleep stack trace:\n");\r\ndump_stack();\r\n}\r\nmutex_lock(&priv->lock);\r\nif (priv->firm_version < 0x0202)\r\nrc = send_seq(priv, {0x00, 0x08, 0x00, 0x00});\r\nelse\r\nrc = send_seq(priv, {0x80, 0x08, 0x00, 0x00});\r\npriv->cur_fw.type = 0;\r\nmutex_unlock(&priv->lock);\r\nreturn rc;\r\n}\r\nstatic int xc2028_dvb_release(struct dvb_frontend *fe)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\ntuner_dbg("%s called\n", __func__);\r\nmutex_lock(&xc2028_list_mutex);\r\nif (hybrid_tuner_report_instance_count(priv) == 1) {\r\nkfree(priv->ctrl.fname);\r\nfree_firmware(priv);\r\n}\r\nif (priv)\r\nhybrid_tuner_release_state(priv);\r\nmutex_unlock(&xc2028_list_mutex);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int xc2028_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\ntuner_dbg("%s called\n", __func__);\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\r\n{\r\nstruct xc2028_data *priv = fe->tuner_priv;\r\nstruct xc2028_ctrl *p = priv_cfg;\r\nint rc = 0;\r\ntuner_dbg("%s called\n", __func__);\r\nmutex_lock(&priv->lock);\r\nmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\r\nif (priv->ctrl.max_len < 9)\r\npriv->ctrl.max_len = 13;\r\nif (p->fname) {\r\nif (priv->ctrl.fname && strcmp(p->fname, priv->ctrl.fname)) {\r\nkfree(priv->ctrl.fname);\r\nfree_firmware(priv);\r\n}\r\npriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\r\nif (priv->ctrl.fname == NULL)\r\nrc = -ENOMEM;\r\n}\r\nmutex_unlock(&priv->lock);\r\nreturn rc;\r\n}\r\nstruct dvb_frontend *xc2028_attach(struct dvb_frontend *fe,\r\nstruct xc2028_config *cfg)\r\n{\r\nstruct xc2028_data *priv;\r\nint instance;\r\nif (debug)\r\nprintk(KERN_DEBUG "xc2028: Xcv2028/3028 init called!\n");\r\nif (NULL == cfg)\r\nreturn NULL;\r\nif (!fe) {\r\nprintk(KERN_ERR "xc2028: No frontend!\n");\r\nreturn NULL;\r\n}\r\nmutex_lock(&xc2028_list_mutex);\r\ninstance = hybrid_tuner_request_state(struct xc2028_data, priv,\r\nhybrid_tuner_instance_list,\r\ncfg->i2c_adap, cfg->i2c_addr,\r\n"xc2028");\r\nswitch (instance) {\r\ncase 0:\r\ngoto fail;\r\nbreak;\r\ncase 1:\r\npriv->ctrl.max_len = 13;\r\nmutex_init(&priv->lock);\r\nfe->tuner_priv = priv;\r\nbreak;\r\ncase 2:\r\nfe->tuner_priv = priv;\r\nbreak;\r\n}\r\nmemcpy(&fe->ops.tuner_ops, &xc2028_dvb_tuner_ops,\r\nsizeof(xc2028_dvb_tuner_ops));\r\ntuner_info("type set to %s\n", "XCeive xc2028/xc3028 tuner");\r\nif (cfg->ctrl)\r\nxc2028_set_config(fe, cfg->ctrl);\r\nmutex_unlock(&xc2028_list_mutex);\r\nreturn fe;\r\nfail:\r\nmutex_unlock(&xc2028_list_mutex);\r\nxc2028_dvb_release(fe);\r\nreturn NULL;\r\n}
