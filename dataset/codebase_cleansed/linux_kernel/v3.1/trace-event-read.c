static int do_read(int fd, void *buf, int size)\r\n{\r\nint rsize = size;\r\nwhile (size) {\r\nint ret = read(fd, buf, size);\r\nif (ret <= 0)\r\nreturn -1;\r\nif (repipe) {\r\nint retw = write(STDOUT_FILENO, buf, ret);\r\nif (retw <= 0 || retw != ret)\r\ndie("repiping input file");\r\n}\r\nsize -= ret;\r\nbuf += ret;\r\n}\r\nreturn rsize;\r\n}\r\nstatic int read_or_die(void *data, int size)\r\n{\r\nint r;\r\nr = do_read(input_fd, data, size);\r\nif (r <= 0)\r\ndie("reading input file (size expected=%d received=%d)",\r\nsize, r);\r\nif (calc_data_size)\r\ncalc_data_size += r;\r\nreturn r;\r\n}\r\nstatic void skip(int size)\r\n{\r\nchar buf[BUFSIZ];\r\nint r;\r\nwhile (size) {\r\nr = size > BUFSIZ ? BUFSIZ : size;\r\nread_or_die(buf, r);\r\nsize -= r;\r\n};\r\n}\r\nstatic unsigned int read4(void)\r\n{\r\nunsigned int data;\r\nread_or_die(&data, 4);\r\nreturn __data2host4(data);\r\n}\r\nstatic unsigned long long read8(void)\r\n{\r\nunsigned long long data;\r\nread_or_die(&data, 8);\r\nreturn __data2host8(data);\r\n}\r\nstatic char *read_string(void)\r\n{\r\nchar buf[BUFSIZ];\r\nchar *str = NULL;\r\nint size = 0;\r\noff_t r;\r\nchar c;\r\nfor (;;) {\r\nr = read(input_fd, &c, 1);\r\nif (r < 0)\r\ndie("reading input file");\r\nif (!r)\r\ndie("no data");\r\nif (repipe) {\r\nint retw = write(STDOUT_FILENO, &c, 1);\r\nif (retw <= 0 || retw != r)\r\ndie("repiping input file string");\r\n}\r\nbuf[size++] = c;\r\nif (!c)\r\nbreak;\r\n}\r\nif (calc_data_size)\r\ncalc_data_size += size;\r\nstr = malloc_or_die(size);\r\nmemcpy(str, buf, size);\r\nreturn str;\r\n}\r\nstatic void read_proc_kallsyms(void)\r\n{\r\nunsigned int size;\r\nchar *buf;\r\nsize = read4();\r\nif (!size)\r\nreturn;\r\nbuf = malloc_or_die(size + 1);\r\nread_or_die(buf, size);\r\nbuf[size] = '\0';\r\nparse_proc_kallsyms(buf, size);\r\nfree(buf);\r\n}\r\nstatic void read_ftrace_printk(void)\r\n{\r\nunsigned int size;\r\nchar *buf;\r\nsize = read4();\r\nif (!size)\r\nreturn;\r\nbuf = malloc_or_die(size);\r\nread_or_die(buf, size);\r\nparse_ftrace_printk(buf, size);\r\nfree(buf);\r\n}\r\nstatic void read_header_files(void)\r\n{\r\nunsigned long long size;\r\nchar *header_event;\r\nchar buf[BUFSIZ];\r\nread_or_die(buf, 12);\r\nif (memcmp(buf, "header_page", 12) != 0)\r\ndie("did not read header page");\r\nsize = read8();\r\nskip(size);\r\nlong_size = header_page_size_size;\r\nread_or_die(buf, 13);\r\nif (memcmp(buf, "header_event", 13) != 0)\r\ndie("did not read header event");\r\nsize = read8();\r\nheader_event = malloc_or_die(size);\r\nread_or_die(header_event, size);\r\nfree(header_event);\r\n}\r\nstatic void read_ftrace_file(unsigned long long size)\r\n{\r\nchar *buf;\r\nbuf = malloc_or_die(size);\r\nread_or_die(buf, size);\r\nparse_ftrace_file(buf, size);\r\nfree(buf);\r\n}\r\nstatic void read_event_file(char *sys, unsigned long long size)\r\n{\r\nchar *buf;\r\nbuf = malloc_or_die(size);\r\nread_or_die(buf, size);\r\nparse_event_file(buf, size, sys);\r\nfree(buf);\r\n}\r\nstatic void read_ftrace_files(void)\r\n{\r\nunsigned long long size;\r\nint count;\r\nint i;\r\ncount = read4();\r\nfor (i = 0; i < count; i++) {\r\nsize = read8();\r\nread_ftrace_file(size);\r\n}\r\n}\r\nstatic void read_event_files(void)\r\n{\r\nunsigned long long size;\r\nchar *sys;\r\nint systems;\r\nint count;\r\nint i,x;\r\nsystems = read4();\r\nfor (i = 0; i < systems; i++) {\r\nsys = read_string();\r\ncount = read4();\r\nfor (x=0; x < count; x++) {\r\nsize = read8();\r\nread_event_file(sys, size);\r\n}\r\n}\r\n}\r\nstatic void update_cpu_data_index(int cpu)\r\n{\r\ncpu_data[cpu].offset += page_size;\r\ncpu_data[cpu].size -= page_size;\r\ncpu_data[cpu].index = 0;\r\n}\r\nstatic void get_next_page(int cpu)\r\n{\r\noff_t save_seek;\r\noff_t ret;\r\nif (!cpu_data[cpu].page)\r\nreturn;\r\nif (read_page) {\r\nif (cpu_data[cpu].size <= page_size) {\r\nfree(cpu_data[cpu].page);\r\ncpu_data[cpu].page = NULL;\r\nreturn;\r\n}\r\nupdate_cpu_data_index(cpu);\r\nsave_seek = lseek(input_fd, 0, SEEK_CUR);\r\nret = lseek(input_fd, cpu_data[cpu].offset, SEEK_SET);\r\nif (ret == (off_t)-1)\r\ndie("failed to lseek");\r\nret = read(input_fd, cpu_data[cpu].page, page_size);\r\nif (ret < 0)\r\ndie("failed to read page");\r\nlseek(input_fd, save_seek, SEEK_SET);\r\nreturn;\r\n}\r\nmunmap(cpu_data[cpu].page, page_size);\r\ncpu_data[cpu].page = NULL;\r\nif (cpu_data[cpu].size <= page_size)\r\nreturn;\r\nupdate_cpu_data_index(cpu);\r\ncpu_data[cpu].page = mmap(NULL, page_size, PROT_READ, MAP_PRIVATE,\r\ninput_fd, cpu_data[cpu].offset);\r\nif (cpu_data[cpu].page == MAP_FAILED)\r\ndie("failed to mmap cpu %d at offset 0x%llx",\r\ncpu, cpu_data[cpu].offset);\r\n}\r\nstatic unsigned int type_len4host(unsigned int type_len_ts)\r\n{\r\nif (file_bigendian)\r\nreturn (type_len_ts >> 27) & ((1 << 5) - 1);\r\nelse\r\nreturn type_len_ts & ((1 << 5) - 1);\r\n}\r\nstatic unsigned int ts4host(unsigned int type_len_ts)\r\n{\r\nif (file_bigendian)\r\nreturn type_len_ts & ((1 << 27) - 1);\r\nelse\r\nreturn type_len_ts >> 5;\r\n}\r\nstatic int calc_index(void *ptr, int cpu)\r\n{\r\nreturn (unsigned long)ptr - (unsigned long)cpu_data[cpu].page;\r\n}\r\nstruct record *trace_peek_data(int cpu)\r\n{\r\nstruct record *data;\r\nvoid *page = cpu_data[cpu].page;\r\nint idx = cpu_data[cpu].index;\r\nvoid *ptr = page + idx;\r\nunsigned long long extend;\r\nunsigned int type_len_ts;\r\nunsigned int type_len;\r\nunsigned int delta;\r\nunsigned int length = 0;\r\nif (cpu_data[cpu].next)\r\nreturn cpu_data[cpu].next;\r\nif (!page)\r\nreturn NULL;\r\nif (!idx) {\r\nif (header_page_ts_size != 8)\r\ndie("expected a long long type for timestamp");\r\ncpu_data[cpu].timestamp = data2host8(ptr);\r\nptr += 8;\r\nswitch (header_page_size_size) {\r\ncase 4:\r\ncpu_data[cpu].page_size = data2host4(ptr);\r\nptr += 4;\r\nbreak;\r\ncase 8:\r\ncpu_data[cpu].page_size = data2host8(ptr);\r\nptr += 8;\r\nbreak;\r\ndefault:\r\ndie("bad long size");\r\n}\r\nptr = cpu_data[cpu].page + header_page_data_offset;\r\n}\r\nread_again:\r\nidx = calc_index(ptr, cpu);\r\nif (idx >= cpu_data[cpu].page_size) {\r\nget_next_page(cpu);\r\nreturn trace_peek_data(cpu);\r\n}\r\ntype_len_ts = data2host4(ptr);\r\nptr += 4;\r\ntype_len = type_len4host(type_len_ts);\r\ndelta = ts4host(type_len_ts);\r\nswitch (type_len) {\r\ncase RINGBUF_TYPE_PADDING:\r\nif (!delta)\r\ndie("error, hit unexpected end of page");\r\nlength = data2host4(ptr);\r\nptr += 4;\r\nlength *= 4;\r\nptr += length;\r\ngoto read_again;\r\ncase RINGBUF_TYPE_TIME_EXTEND:\r\nextend = data2host4(ptr);\r\nptr += 4;\r\nextend <<= TS_SHIFT;\r\nextend += delta;\r\ncpu_data[cpu].timestamp += extend;\r\ngoto read_again;\r\ncase RINGBUF_TYPE_TIME_STAMP:\r\nptr += 12;\r\nbreak;\r\ncase 0:\r\nlength = data2host4(ptr);\r\nptr += 4;\r\ndie("here! length=%d", length);\r\nbreak;\r\ndefault:\r\nlength = type_len * 4;\r\nbreak;\r\n}\r\ncpu_data[cpu].timestamp += delta;\r\ndata = malloc_or_die(sizeof(*data));\r\nmemset(data, 0, sizeof(*data));\r\ndata->ts = cpu_data[cpu].timestamp;\r\ndata->size = length;\r\ndata->data = ptr;\r\nptr += length;\r\ncpu_data[cpu].index = calc_index(ptr, cpu);\r\ncpu_data[cpu].next = data;\r\nreturn data;\r\n}\r\nstruct record *trace_read_data(int cpu)\r\n{\r\nstruct record *data;\r\ndata = trace_peek_data(cpu);\r\ncpu_data[cpu].next = NULL;\r\nreturn data;\r\n}\r\nssize_t trace_report(int fd, bool __repipe)\r\n{\r\nchar buf[BUFSIZ];\r\nchar test[] = { 23, 8, 68 };\r\nchar *version;\r\nint show_version = 0;\r\nint show_funcs = 0;\r\nint show_printk = 0;\r\nssize_t size;\r\ncalc_data_size = 1;\r\nrepipe = __repipe;\r\ninput_fd = fd;\r\nread_or_die(buf, 3);\r\nif (memcmp(buf, test, 3) != 0)\r\ndie("no trace data in the file");\r\nread_or_die(buf, 7);\r\nif (memcmp(buf, "tracing", 7) != 0)\r\ndie("not a trace file (missing 'tracing' tag)");\r\nversion = read_string();\r\nif (show_version)\r\nprintf("version = %s\n", version);\r\nfree(version);\r\nread_or_die(buf, 1);\r\nfile_bigendian = buf[0];\r\nhost_bigendian = bigendian();\r\nread_or_die(buf, 1);\r\nlong_size = buf[0];\r\npage_size = read4();\r\nread_header_files();\r\nread_ftrace_files();\r\nread_event_files();\r\nread_proc_kallsyms();\r\nread_ftrace_printk();\r\nsize = calc_data_size - 1;\r\ncalc_data_size = 0;\r\nrepipe = false;\r\nif (show_funcs) {\r\nprint_funcs();\r\nreturn size;\r\n}\r\nif (show_printk) {\r\nprint_printk();\r\nreturn size;\r\n}\r\nreturn size;\r\n}
