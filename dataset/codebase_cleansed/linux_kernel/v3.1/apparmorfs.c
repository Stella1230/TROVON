static char *aa_simple_write_to_buffer(int op, const char __user *userbuf,\r\nsize_t alloc_size, size_t copy_size,\r\nloff_t *pos)\r\n{\r\nchar *data;\r\nBUG_ON(copy_size > alloc_size);\r\nif (*pos != 0)\r\nreturn ERR_PTR(-ESPIPE);\r\nif (!aa_may_manage_policy(op))\r\nreturn ERR_PTR(-EACCES);\r\ndata = kvmalloc(alloc_size);\r\nif (data == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (copy_from_user(data, userbuf, copy_size)) {\r\nkvfree(data);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nreturn data;\r\n}\r\nstatic ssize_t profile_load(struct file *f, const char __user *buf, size_t size,\r\nloff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_LOAD, buf, size, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\nerror = aa_replace_profiles(data, size, PROF_ADD);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic ssize_t profile_replace(struct file *f, const char __user *buf,\r\nsize_t size, loff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_REPL, buf, size, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\nerror = aa_replace_profiles(data, size, PROF_REPLACE);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic ssize_t profile_remove(struct file *f, const char __user *buf,\r\nsize_t size, loff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_RM, buf, size + 1, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\ndata[size] = 0;\r\nerror = aa_remove_profiles(data, size);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic void __init aafs_remove(const char *name)\r\n{\r\nstruct dentry *dentry;\r\ndentry = lookup_one_len(name, aa_fs_dentry, strlen(name));\r\nif (!IS_ERR(dentry)) {\r\nsecurityfs_remove(dentry);\r\ndput(dentry);\r\n}\r\n}\r\nstatic int __init aafs_create(const char *name, int mask,\r\nconst struct file_operations *fops)\r\n{\r\nstruct dentry *dentry;\r\ndentry = securityfs_create_file(name, S_IFREG | mask, aa_fs_dentry,\r\nNULL, fops);\r\nreturn IS_ERR(dentry) ? PTR_ERR(dentry) : 0;\r\n}\r\nvoid __init aa_destroy_aafs(void)\r\n{\r\nif (aa_fs_dentry) {\r\naafs_remove(".remove");\r\naafs_remove(".replace");\r\naafs_remove(".load");\r\nsecurityfs_remove(aa_fs_dentry);\r\naa_fs_dentry = NULL;\r\n}\r\n}\r\nint __init aa_create_aafs(void)\r\n{\r\nint error;\r\nif (!apparmor_initialized)\r\nreturn 0;\r\nif (aa_fs_dentry) {\r\nAA_ERROR("%s: AppArmor securityfs already exists\n", __func__);\r\nreturn -EEXIST;\r\n}\r\naa_fs_dentry = securityfs_create_dir("apparmor", NULL);\r\nif (IS_ERR(aa_fs_dentry)) {\r\nerror = PTR_ERR(aa_fs_dentry);\r\naa_fs_dentry = NULL;\r\ngoto error;\r\n}\r\nerror = aafs_create(".load", 0640, &aa_fs_profile_load);\r\nif (error)\r\ngoto error;\r\nerror = aafs_create(".replace", 0640, &aa_fs_profile_replace);\r\nif (error)\r\ngoto error;\r\nerror = aafs_create(".remove", 0640, &aa_fs_profile_remove);\r\nif (error)\r\ngoto error;\r\naa_info_message("AppArmor Filesystem Enabled");\r\nreturn 0;\r\nerror:\r\naa_destroy_aafs();\r\nAA_ERROR("Error creating AppArmor securityfs\n");\r\nreturn error;\r\n}
