static struct pci_dn *get_pdn(struct pci_dev *pdev)\r\n{\r\nstruct device_node *dn;\r\nstruct pci_dn *pdn;\r\ndn = pci_device_to_OF_node(pdev);\r\nif (!dn) {\r\ndev_dbg(&pdev->dev, "rtas_msi: No OF device node\n");\r\nreturn NULL;\r\n}\r\npdn = PCI_DN(dn);\r\nif (!pdn) {\r\ndev_dbg(&pdev->dev, "rtas_msi: No PCI DN\n");\r\nreturn NULL;\r\n}\r\nreturn pdn;\r\n}\r\nstatic int rtas_change_msi(struct pci_dn *pdn, u32 func, u32 num_irqs)\r\n{\r\nu32 addr, seq_num, rtas_ret[3];\r\nunsigned long buid;\r\nint rc;\r\naddr = rtas_config_addr(pdn->busno, pdn->devfn, 0);\r\nbuid = pdn->phb->buid;\r\nseq_num = 1;\r\ndo {\r\nif (func == RTAS_CHANGE_MSI_FN || func == RTAS_CHANGE_MSIX_FN)\r\nrc = rtas_call(change_token, 6, 4, rtas_ret, addr,\r\nBUID_HI(buid), BUID_LO(buid),\r\nfunc, num_irqs, seq_num);\r\nelse\r\nrc = rtas_call(change_token, 6, 3, rtas_ret, addr,\r\nBUID_HI(buid), BUID_LO(buid),\r\nfunc, num_irqs, seq_num);\r\nseq_num = rtas_ret[1];\r\n} while (rtas_busy_delay(rc));\r\nif (rc == 0)\r\nrc = rtas_ret[0];\r\nelse if (rc > 0)\r\nrc = -rc;\r\npr_debug("rtas_msi: ibm,change_msi(func=%d,num=%d), got %d rc = %d\n",\r\nfunc, num_irqs, rtas_ret[0], rc);\r\nreturn rc;\r\n}\r\nstatic void rtas_disable_msi(struct pci_dev *pdev)\r\n{\r\nstruct pci_dn *pdn;\r\npdn = get_pdn(pdev);\r\nif (!pdn)\r\nreturn;\r\nif (rtas_change_msi(pdn, RTAS_CHANGE_MSI_FN, 0) != 0) {\r\nif (rtas_change_msi(pdn, RTAS_CHANGE_FN, 0) != 0) {\r\npr_debug("rtas_msi: Setting MSIs to 0 failed!\n");\r\n}\r\n}\r\n}\r\nstatic int rtas_query_irq_number(struct pci_dn *pdn, int offset)\r\n{\r\nu32 addr, rtas_ret[2];\r\nunsigned long buid;\r\nint rc;\r\naddr = rtas_config_addr(pdn->busno, pdn->devfn, 0);\r\nbuid = pdn->phb->buid;\r\ndo {\r\nrc = rtas_call(query_token, 4, 3, rtas_ret, addr,\r\nBUID_HI(buid), BUID_LO(buid), offset);\r\n} while (rtas_busy_delay(rc));\r\nif (rc) {\r\npr_debug("rtas_msi: error (%d) querying source number\n", rc);\r\nreturn rc;\r\n}\r\nreturn rtas_ret[0];\r\n}\r\nstatic void rtas_teardown_msi_irqs(struct pci_dev *pdev)\r\n{\r\nstruct msi_desc *entry;\r\nlist_for_each_entry(entry, &pdev->msi_list, list) {\r\nif (entry->irq == NO_IRQ)\r\ncontinue;\r\nirq_set_msi_desc(entry->irq, NULL);\r\nirq_dispose_mapping(entry->irq);\r\n}\r\nrtas_disable_msi(pdev);\r\n}\r\nstatic int check_req(struct pci_dev *pdev, int nvec, char *prop_name)\r\n{\r\nstruct device_node *dn;\r\nstruct pci_dn *pdn;\r\nconst u32 *req_msi;\r\npdn = get_pdn(pdev);\r\nif (!pdn)\r\nreturn -ENODEV;\r\ndn = pdn->node;\r\nreq_msi = of_get_property(dn, prop_name, NULL);\r\nif (!req_msi) {\r\npr_debug("rtas_msi: No %s on %s\n", prop_name, dn->full_name);\r\nreturn -ENOENT;\r\n}\r\nif (*req_msi < nvec) {\r\npr_debug("rtas_msi: %s requests < %d MSIs\n", prop_name, nvec);\r\nif (*req_msi == 0)\r\nreturn -ENOSPC;\r\nreturn *req_msi;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_req_msi(struct pci_dev *pdev, int nvec)\r\n{\r\nreturn check_req(pdev, nvec, "ibm,req#msi");\r\n}\r\nstatic int check_req_msix(struct pci_dev *pdev, int nvec)\r\n{\r\nreturn check_req(pdev, nvec, "ibm,req#msi-x");\r\n}\r\nstatic struct device_node *find_pe_total_msi(struct pci_dev *dev, int *total)\r\n{\r\nstruct device_node *dn;\r\nconst u32 *p;\r\ndn = of_node_get(pci_device_to_OF_node(dev));\r\nwhile (dn) {\r\np = of_get_property(dn, "ibm,pe-total-#msi", NULL);\r\nif (p) {\r\npr_debug("rtas_msi: found prop on dn %s\n",\r\ndn->full_name);\r\n*total = *p;\r\nreturn dn;\r\n}\r\ndn = of_get_next_parent(dn);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct device_node *find_pe_dn(struct pci_dev *dev, int *total)\r\n{\r\nstruct device_node *dn;\r\ndn = pci_device_to_OF_node(dev);\r\nif (!dn)\r\nreturn NULL;\r\ndn = find_device_pe(dn);\r\nif (!dn)\r\nreturn NULL;\r\ndn = of_get_parent(dn);\r\nif (!dn)\r\nreturn NULL;\r\n*total = 8;\r\npr_debug("rtas_msi: using PE dn %s\n", dn->full_name);\r\nreturn dn;\r\n}\r\nstatic void *count_non_bridge_devices(struct device_node *dn, void *data)\r\n{\r\nstruct msi_counts *counts = data;\r\nconst u32 *p;\r\nu32 class;\r\npr_debug("rtas_msi: counting %s\n", dn->full_name);\r\np = of_get_property(dn, "class-code", NULL);\r\nclass = p ? *p : 0;\r\nif ((class >> 8) != PCI_CLASS_BRIDGE_PCI)\r\ncounts->num_devices++;\r\nreturn NULL;\r\n}\r\nstatic void *count_spare_msis(struct device_node *dn, void *data)\r\n{\r\nstruct msi_counts *counts = data;\r\nconst u32 *p;\r\nint req;\r\nif (dn == counts->requestor)\r\nreq = counts->request;\r\nelse {\r\nreq = 0;\r\np = of_get_property(dn, "ibm,req#msi", NULL);\r\nif (p)\r\nreq = *p;\r\np = of_get_property(dn, "ibm,req#msi-x", NULL);\r\nif (p)\r\nreq = max(req, (int)*p);\r\n}\r\nif (req < counts->quota)\r\ncounts->spare += counts->quota - req;\r\nelse if (req > counts->quota)\r\ncounts->over_quota++;\r\nreturn NULL;\r\n}\r\nstatic int msi_quota_for_device(struct pci_dev *dev, int request)\r\n{\r\nstruct device_node *pe_dn;\r\nstruct msi_counts counts;\r\nint total;\r\npr_debug("rtas_msi: calc quota for %s, request %d\n", pci_name(dev),\r\nrequest);\r\npe_dn = find_pe_total_msi(dev, &total);\r\nif (!pe_dn)\r\npe_dn = find_pe_dn(dev, &total);\r\nif (!pe_dn) {\r\npr_err("rtas_msi: couldn't find PE for %s\n", pci_name(dev));\r\ngoto out;\r\n}\r\npr_debug("rtas_msi: found PE %s\n", pe_dn->full_name);\r\nmemset(&counts, 0, sizeof(struct msi_counts));\r\ntraverse_pci_devices(pe_dn, count_non_bridge_devices, &counts);\r\nif (counts.num_devices == 0) {\r\npr_err("rtas_msi: found 0 devices under PE for %s\n",\r\npci_name(dev));\r\ngoto out;\r\n}\r\ncounts.quota = total / counts.num_devices;\r\nif (request <= counts.quota)\r\ngoto out;\r\ncounts.requestor = pci_device_to_OF_node(dev);\r\ncounts.request = request;\r\ntraverse_pci_devices(pe_dn, count_spare_msis, &counts);\r\ncounts.spare += total % counts.num_devices;\r\nif (counts.over_quota)\r\ncounts.quota += counts.spare / counts.over_quota;\r\nrequest = min(counts.quota, request);\r\npr_debug("rtas_msi: request clamped to quota %d\n", request);\r\nout:\r\nof_node_put(pe_dn);\r\nreturn request;\r\n}\r\nstatic int rtas_msi_check_device(struct pci_dev *pdev, int nvec, int type)\r\n{\r\nint quota, rc;\r\nif (type == PCI_CAP_ID_MSIX)\r\nrc = check_req_msix(pdev, nvec);\r\nelse\r\nrc = check_req_msi(pdev, nvec);\r\nif (rc)\r\nreturn rc;\r\nquota = msi_quota_for_device(pdev, nvec);\r\nif (quota && quota < nvec)\r\nreturn quota;\r\nreturn 0;\r\n}\r\nstatic int check_msix_entries(struct pci_dev *pdev)\r\n{\r\nstruct msi_desc *entry;\r\nint expected;\r\nexpected = 0;\r\nlist_for_each_entry(entry, &pdev->msi_list, list) {\r\nif (entry->msi_attrib.entry_nr != expected) {\r\npr_debug("rtas_msi: bad MSI-X entries.\n");\r\nreturn -EINVAL;\r\n}\r\nexpected++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtas_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)\r\n{\r\nstruct pci_dn *pdn;\r\nint hwirq, virq, i, rc;\r\nstruct msi_desc *entry;\r\nstruct msi_msg msg;\r\npdn = get_pdn(pdev);\r\nif (!pdn)\r\nreturn -ENODEV;\r\nif (type == PCI_CAP_ID_MSIX && check_msix_entries(pdev))\r\nreturn -EINVAL;\r\nif (type == PCI_CAP_ID_MSI) {\r\nrc = rtas_change_msi(pdn, RTAS_CHANGE_MSI_FN, nvec);\r\nif (rc < 0) {\r\npr_debug("rtas_msi: trying the old firmware call.\n");\r\nrc = rtas_change_msi(pdn, RTAS_CHANGE_FN, nvec);\r\n}\r\n} else\r\nrc = rtas_change_msi(pdn, RTAS_CHANGE_MSIX_FN, nvec);\r\nif (rc != nvec) {\r\npr_debug("rtas_msi: rtas_change_msi() failed\n");\r\nreturn rc;\r\n}\r\ni = 0;\r\nlist_for_each_entry(entry, &pdev->msi_list, list) {\r\nhwirq = rtas_query_irq_number(pdn, i++);\r\nif (hwirq < 0) {\r\npr_debug("rtas_msi: error (%d) getting hwirq\n", rc);\r\nreturn hwirq;\r\n}\r\nvirq = irq_create_mapping(NULL, hwirq);\r\nif (virq == NO_IRQ) {\r\npr_debug("rtas_msi: Failed mapping hwirq %d\n", hwirq);\r\nreturn -ENOSPC;\r\n}\r\ndev_dbg(&pdev->dev, "rtas_msi: allocated virq %d\n", virq);\r\nirq_set_msi_desc(virq, entry);\r\nread_msi_msg(virq, &msg);\r\nentry->msg = msg;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtas_msi_pci_irq_fixup(struct pci_dev *pdev)\r\n{\r\nif (pdev->irq == NO_IRQ) {\r\ndev_dbg(&pdev->dev, "rtas_msi: no LSI, nothing to do.\n");\r\nreturn;\r\n}\r\nif (check_req_msi(pdev, 1) && check_req_msix(pdev, 1)) {\r\ndev_dbg(&pdev->dev, "rtas_msi: no req#msi/x, nothing to do.\n");\r\nreturn;\r\n}\r\ndev_dbg(&pdev->dev, "rtas_msi: disabling existing MSI.\n");\r\nrtas_disable_msi(pdev);\r\n}\r\nstatic int rtas_msi_init(void)\r\n{\r\nquery_token = rtas_token("ibm,query-interrupt-source-number");\r\nchange_token = rtas_token("ibm,change-msi");\r\nif ((query_token == RTAS_UNKNOWN_SERVICE) ||\r\n(change_token == RTAS_UNKNOWN_SERVICE)) {\r\npr_debug("rtas_msi: no RTAS tokens, no MSI support.\n");\r\nreturn -1;\r\n}\r\npr_debug("rtas_msi: Registering RTAS MSI callbacks.\n");\r\nWARN_ON(ppc_md.setup_msi_irqs);\r\nppc_md.setup_msi_irqs = rtas_setup_msi_irqs;\r\nppc_md.teardown_msi_irqs = rtas_teardown_msi_irqs;\r\nppc_md.msi_check_device = rtas_msi_check_device;\r\nWARN_ON(ppc_md.pci_irq_fixup);\r\nppc_md.pci_irq_fixup = rtas_msi_pci_irq_fixup;\r\nreturn 0;\r\n}
