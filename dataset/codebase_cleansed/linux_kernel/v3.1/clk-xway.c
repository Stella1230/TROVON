static inline unsigned int get_input_clock(int pll)\r\n{\r\nswitch (pll) {\r\ncase 0:\r\nif (ltq_cgu_r32(LTQ_CGU_PLL0_CFG) & CGU_PLL0_SRC)\r\nreturn BASIS_REQUENCY_USB;\r\nelse if (CGU_PLL0_PHASE_DIVIDER_ENABLE)\r\nreturn BASIC_FREQUENCY_1;\r\nelse\r\nreturn BASIC_FREQUENCY_2;\r\ncase 1:\r\nif (CGU_PLL1_SRC)\r\nreturn BASIS_REQUENCY_USB;\r\nelse if (CGU_PLL0_PHASE_DIVIDER_ENABLE)\r\nreturn BASIC_FREQUENCY_1;\r\nelse\r\nreturn BASIC_FREQUENCY_2;\r\ncase 2:\r\nswitch (CGU_PLL2_SRC) {\r\ncase 0:\r\nreturn ltq_get_pll0_fdiv();\r\ncase 1:\r\nreturn CGU_PLL2_PHASE_DIVIDER_ENABLE ?\r\nBASIC_FREQUENCY_1 :\r\nBASIC_FREQUENCY_2;\r\ncase 2:\r\nreturn BASIS_REQUENCY_USB;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline unsigned int cal_dsm(int pll, unsigned int num, unsigned int den)\r\n{\r\nu64 res, clock = get_input_clock(pll);\r\nres = num * clock;\r\ndo_div(res, den);\r\nreturn res;\r\n}\r\nstatic inline unsigned int mash_dsm(int pll, unsigned int M, unsigned int N,\r\nunsigned int K)\r\n{\r\nunsigned int num = ((N + 1) << 10) + K;\r\nunsigned int den = (M + 1) << 10;\r\nreturn cal_dsm(pll, num, den);\r\n}\r\nstatic inline unsigned int ssff_dsm_1(int pll, unsigned int M, unsigned int N,\r\nunsigned int K)\r\n{\r\nunsigned int num = ((N + 1) << 11) + K + 512;\r\nunsigned int den = (M + 1) << 11;\r\nreturn cal_dsm(pll, num, den);\r\n}\r\nstatic inline unsigned int ssff_dsm_2(int pll, unsigned int M, unsigned int N,\r\nunsigned int K)\r\n{\r\nunsigned int num = K >= 512 ?\r\n((N + 1) << 12) + K - 512 : ((N + 1) << 12) + K + 3584;\r\nunsigned int den = (M + 1) << 12;\r\nreturn cal_dsm(pll, num, den);\r\n}\r\nstatic inline unsigned int dsm(int pll, unsigned int M, unsigned int N,\r\nunsigned int K, unsigned int dsmsel, unsigned int phase_div_en)\r\n{\r\nif (!dsmsel)\r\nreturn mash_dsm(pll, M, N, K);\r\nelse if (!phase_div_en)\r\nreturn mash_dsm(pll, M, N, K);\r\nelse\r\nreturn ssff_dsm_2(pll, M, N, K);\r\n}\r\nstatic inline unsigned int ltq_get_pll0_fosc(void)\r\n{\r\nif (CGU_PLL0_BYPASS)\r\nreturn get_input_clock(0);\r\nelse\r\nreturn !CGU_PLL0_CFG_FRAC_EN\r\n? dsm(0, CGU_PLL0_CFG_PLLM, CGU_PLL0_CFG_PLLN, 0,\r\nCGU_PLL0_CFG_DSMSEL,\r\nCGU_PLL0_PHASE_DIVIDER_ENABLE)\r\n: dsm(0, CGU_PLL0_CFG_PLLM, CGU_PLL0_CFG_PLLN,\r\nCGU_PLL0_CFG_PLLK, CGU_PLL0_CFG_DSMSEL,\r\nCGU_PLL0_PHASE_DIVIDER_ENABLE);\r\n}\r\nstatic unsigned int ltq_get_pll0_fdiv(void)\r\n{\r\nunsigned int div = CGU_PLL2_CFG_INPUT_DIV + 1;\r\nreturn (ltq_get_pll0_fosc() + (div >> 1)) / div;\r\n}\r\nunsigned int ltq_get_io_region_clock(void)\r\n{\r\nunsigned int ret = ltq_get_pll0_fosc();\r\nswitch (ltq_cgu_r32(LTQ_CGU_PLL2_CFG) & CGU_SYS_DDR_SEL) {\r\ndefault:\r\ncase 0:\r\nreturn (ret + 1) / 2;\r\ncase 1:\r\nreturn (ret * 2 + 2) / 5;\r\ncase 2:\r\nreturn (ret + 1) / 3;\r\ncase 3:\r\nreturn (ret + 2) / 4;\r\n}\r\n}\r\nunsigned int ltq_get_fpi_bus_clock(int fpi)\r\n{\r\nunsigned int ret = ltq_get_io_region_clock();\r\nif ((fpi == 2) && (ltq_cgu_r32(LTQ_CGU_SYS) & CGU_SYS_FPI_SEL))\r\nret >>= 1;\r\nreturn ret;\r\n}\r\nunsigned int ltq_get_cpu_hz(void)\r\n{\r\nswitch (ltq_cgu_r32(LTQ_CGU_SYS) & 0xc) {\r\ncase 0:\r\nreturn CLOCK_333M;\r\ncase 4:\r\nreturn DDR_HZ;\r\ncase 8:\r\nreturn DDR_HZ << 1;\r\ndefault:\r\nreturn DDR_HZ >> 1;\r\n}\r\n}\r\nunsigned int ltq_get_fpi_hz(void)\r\n{\r\nunsigned int ddr_clock = DDR_HZ;\r\nif (ltq_cgu_r32(LTQ_CGU_SYS) & 0x40)\r\nreturn ddr_clock >> 1;\r\nreturn ddr_clock;\r\n}
