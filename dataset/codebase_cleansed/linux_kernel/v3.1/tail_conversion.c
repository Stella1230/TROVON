int direct2indirect(struct reiserfs_transaction_handle *th, struct inode *inode,\r\nstruct treepath *path, struct buffer_head *unbh,\r\nloff_t tail_offset)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct buffer_head *up_to_date_bh;\r\nstruct item_head *p_le_ih = PATH_PITEM_HEAD(path);\r\nunsigned long total_tail = 0;\r\nstruct cpu_key end_key;\r\nstruct item_head ind_ih;\r\nint blk_size, retval;\r\nunp_t unfm_ptr;\r\nBUG_ON(!th->t_trans_id);\r\nREISERFS_SB(sb)->s_direct2indirect++;\r\nblk_size = sb->s_blocksize;\r\ncopy_item_head(&ind_ih, p_le_ih);\r\nset_le_ih_k_offset(&ind_ih, tail_offset);\r\nset_le_ih_k_type(&ind_ih, TYPE_INDIRECT);\r\nmake_cpu_key(&end_key, inode, tail_offset, TYPE_INDIRECT, 4);\r\nif (search_for_position_by_key(sb, &end_key, path) == POSITION_FOUND) {\r\nreiserfs_error(sb, "PAP-14030",\r\n"pasted or inserted byte exists in "\r\n"the tree %K. Use fsck to repair.", &end_key);\r\npathrelse(path);\r\nreturn -EIO;\r\n}\r\np_le_ih = PATH_PITEM_HEAD(path);\r\nunfm_ptr = cpu_to_le32(unbh->b_blocknr);\r\nif (is_statdata_le_ih(p_le_ih)) {\r\nset_ih_free_space(&ind_ih, 0);\r\nput_ih_item_len(&ind_ih, UNFM_P_SIZE);\r\nPATH_LAST_POSITION(path)++;\r\nretval =\r\nreiserfs_insert_item(th, path, &end_key, &ind_ih, inode,\r\n(char *)&unfm_ptr);\r\n} else {\r\nretval = reiserfs_paste_into_item(th, path, &end_key, inode,\r\n(char *)&unfm_ptr,\r\nUNFM_P_SIZE);\r\n}\r\nif (retval) {\r\nreturn retval;\r\n}\r\nmake_cpu_key(&end_key, inode, max_reiserfs_offset(inode), TYPE_DIRECT,\r\n4);\r\nwhile (1) {\r\nint tail_size;\r\nif (search_for_position_by_key(sb, &end_key, path) ==\r\nPOSITION_FOUND)\r\nreiserfs_panic(sb, "PAP-14050",\r\n"direct item (%K) not found", &end_key);\r\np_le_ih = PATH_PITEM_HEAD(path);\r\nRFALSE(!is_direct_le_ih(p_le_ih),\r\n"vs-14055: direct item expected(%K), found %h",\r\n&end_key, p_le_ih);\r\ntail_size = (le_ih_k_offset(p_le_ih) & (blk_size - 1))\r\n+ ih_item_len(p_le_ih) - 1;\r\nif (!unbh->b_page || buffer_uptodate(unbh)\r\n|| PageUptodate(unbh->b_page)) {\r\nup_to_date_bh = NULL;\r\n} else {\r\nup_to_date_bh = unbh;\r\n}\r\nretval = reiserfs_delete_item(th, path, &end_key, inode,\r\nup_to_date_bh);\r\ntotal_tail += retval;\r\nif (tail_size == retval)\r\nbreak;\r\n}\r\nif (up_to_date_bh) {\r\nunsigned pgoff =\r\n(tail_offset + total_tail - 1) & (PAGE_CACHE_SIZE - 1);\r\nchar *kaddr = kmap_atomic(up_to_date_bh->b_page, KM_USER0);\r\nmemset(kaddr + pgoff, 0, blk_size - total_tail);\r\nkunmap_atomic(kaddr, KM_USER0);\r\n}\r\nREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\r\nreturn 0;\r\n}\r\nvoid reiserfs_unmap_buffer(struct buffer_head *bh)\r\n{\r\nlock_buffer(bh);\r\nif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\r\nBUG();\r\n}\r\nclear_buffer_dirty(bh);\r\nif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\r\nstruct inode *inode = bh->b_page->mapping->host;\r\nstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\r\nspin_lock(&j->j_dirty_buffers_lock);\r\nlist_del_init(&bh->b_assoc_buffers);\r\nreiserfs_free_jh(bh);\r\nspin_unlock(&j->j_dirty_buffers_lock);\r\n}\r\nclear_buffer_mapped(bh);\r\nclear_buffer_req(bh);\r\nclear_buffer_new(bh);\r\nbh->b_bdev = NULL;\r\nunlock_buffer(bh);\r\n}\r\nint indirect2direct(struct reiserfs_transaction_handle *th,\r\nstruct inode *inode, struct page *page,\r\nstruct treepath *path,\r\nconst struct cpu_key *item_key,\r\nloff_t n_new_file_size,\r\nchar *mode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct item_head s_ih;\r\nunsigned long block_size = sb->s_blocksize;\r\nchar *tail;\r\nint tail_len, round_tail_len;\r\nloff_t pos, pos1;\r\nstruct cpu_key key;\r\nBUG_ON(!th->t_trans_id);\r\nREISERFS_SB(sb)->s_indirect2direct++;\r\n*mode = M_SKIP_BALANCING;\r\ncopy_item_head(&s_ih, PATH_PITEM_HEAD(path));\r\ntail_len = (n_new_file_size & (block_size - 1));\r\nif (get_inode_sd_version(inode) == STAT_DATA_V2)\r\nround_tail_len = ROUND_UP(tail_len);\r\nelse\r\nround_tail_len = tail_len;\r\npos =\r\nle_ih_k_offset(&s_ih) - 1 + (ih_item_len(&s_ih) / UNFM_P_SIZE -\r\n1) * sb->s_blocksize;\r\npos1 = pos;\r\ntail = (char *)kmap(page);\r\nif (path_changed(&s_ih, path)) {\r\nif (search_for_position_by_key(sb, item_key, path)\r\n== POSITION_NOT_FOUND)\r\nreiserfs_panic(sb, "PAP-5520",\r\n"item to be converted %K does not exist",\r\nitem_key);\r\ncopy_item_head(&s_ih, PATH_PITEM_HEAD(path));\r\n#ifdef CONFIG_REISERFS_CHECK\r\npos = le_ih_k_offset(&s_ih) - 1 +\r\n(ih_item_len(&s_ih) / UNFM_P_SIZE -\r\n1) * sb->s_blocksize;\r\nif (pos != pos1)\r\nreiserfs_panic(sb, "vs-5530", "tail position "\r\n"changed while we were reading it");\r\n#endif\r\n}\r\nmake_le_item_head(&s_ih, NULL, get_inode_item_key_version(inode),\r\npos1 + 1, TYPE_DIRECT, round_tail_len,\r\n0xffff );\r\ntail = tail + (pos & (PAGE_CACHE_SIZE - 1));\r\nPATH_LAST_POSITION(path)++;\r\nkey = *item_key;\r\nset_cpu_key_k_type(&key, TYPE_DIRECT);\r\nkey.key_length = 4;\r\nif (reiserfs_insert_item(th, path, &key, &s_ih, inode,\r\ntail ? tail : NULL) < 0) {\r\nkunmap(page);\r\nreturn block_size - round_tail_len;\r\n}\r\nkunmap(page);\r\nreiserfs_update_sd(th, inode);\r\n*mode = M_CUT;\r\nREISERFS_I(inode)->i_first_direct_byte = pos1 + 1;\r\nreturn block_size - round_tail_len;\r\n}
