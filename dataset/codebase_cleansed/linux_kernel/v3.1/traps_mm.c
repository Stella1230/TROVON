void __init base_trap_init(void)\r\n{\r\nif (MACH_IS_SUN3X) {\r\nextern e_vector *sun3x_prom_vbr;\r\n__asm__ volatile ("movec %%vbr, %0" : "=r" (sun3x_prom_vbr));\r\n}\r\n__asm__ volatile ("movec %0,%%vbr" : : "r" ((void*)vectors));\r\nif (CPU_IS_060) {\r\nasmlinkage void unimp_vec(void) asm ("_060_isp_unimp");\r\nvectors[VEC_UNIMPII] = unimp_vec;\r\n}\r\nvectors[VEC_BUSERR] = buserr;\r\nvectors[VEC_ILLEGAL] = trap;\r\nvectors[VEC_SYS] = system_call;\r\n}\r\nvoid __init trap_init (void)\r\n{\r\nint i;\r\nfor (i = VEC_SPUR; i <= VEC_INT7; i++)\r\nvectors[i] = bad_inthandler;\r\nfor (i = 0; i < VEC_USER; i++)\r\nif (!vectors[i])\r\nvectors[i] = trap;\r\nfor (i = VEC_USER; i < 256; i++)\r\nvectors[i] = bad_inthandler;\r\n#ifdef CONFIG_M68KFPU_EMU\r\nif (FPU_IS_EMU)\r\nvectors[VEC_LINE11] = fpu_emu;\r\n#endif\r\nif (CPU_IS_040 && !FPU_IS_EMU) {\r\nasmlinkage void dz_vec(void) asm ("dz");\r\nasmlinkage void inex_vec(void) asm ("inex");\r\nasmlinkage void ovfl_vec(void) asm ("ovfl");\r\nasmlinkage void unfl_vec(void) asm ("unfl");\r\nasmlinkage void snan_vec(void) asm ("snan");\r\nasmlinkage void operr_vec(void) asm ("operr");\r\nasmlinkage void bsun_vec(void) asm ("bsun");\r\nasmlinkage void fline_vec(void) asm ("fline");\r\nasmlinkage void unsupp_vec(void) asm ("unsupp");\r\nvectors[VEC_FPDIVZ] = dz_vec;\r\nvectors[VEC_FPIR] = inex_vec;\r\nvectors[VEC_FPOVER] = ovfl_vec;\r\nvectors[VEC_FPUNDER] = unfl_vec;\r\nvectors[VEC_FPNAN] = snan_vec;\r\nvectors[VEC_FPOE] = operr_vec;\r\nvectors[VEC_FPBRUC] = bsun_vec;\r\nvectors[VEC_LINE11] = fline_vec;\r\nvectors[VEC_FPUNSUP] = unsupp_vec;\r\n}\r\nif (CPU_IS_060 && !FPU_IS_EMU) {\r\nasmlinkage void snan_vec6(void) asm ("_060_fpsp_snan");\r\nasmlinkage void operr_vec6(void) asm ("_060_fpsp_operr");\r\nasmlinkage void ovfl_vec6(void) asm ("_060_fpsp_ovfl");\r\nasmlinkage void unfl_vec6(void) asm ("_060_fpsp_unfl");\r\nasmlinkage void dz_vec6(void) asm ("_060_fpsp_dz");\r\nasmlinkage void inex_vec6(void) asm ("_060_fpsp_inex");\r\nasmlinkage void fline_vec6(void) asm ("_060_fpsp_fline");\r\nasmlinkage void unsupp_vec6(void) asm ("_060_fpsp_unsupp");\r\nasmlinkage void effadd_vec6(void) asm ("_060_fpsp_effadd");\r\nvectors[VEC_FPNAN] = snan_vec6;\r\nvectors[VEC_FPOE] = operr_vec6;\r\nvectors[VEC_FPOVER] = ovfl_vec6;\r\nvectors[VEC_FPUNDER] = unfl_vec6;\r\nvectors[VEC_FPDIVZ] = dz_vec6;\r\nvectors[VEC_FPIR] = inex_vec6;\r\nvectors[VEC_LINE11] = fline_vec6;\r\nvectors[VEC_FPUNSUP] = unsupp_vec6;\r\nvectors[VEC_UNIMPEA] = effadd_vec6;\r\n}\r\nif (MACH_IS_AMIGA) {\r\nvectors[VEC_INT7] = nmihandler;\r\n}\r\n}\r\nstatic inline void access_error060 (struct frame *fp)\r\n{\r\nunsigned long fslw = fp->un.fmt4.pc;\r\n#ifdef DEBUG\r\nprintk("fslw=%#lx, fa=%#lx\n", fslw, fp->un.fmt4.effaddr);\r\n#endif\r\nif (fslw & MMU060_BPE) {\r\n__asm__ __volatile__ ("movec %/cacr,%/d0\n\t"\r\n"orl #0x00400000,%/d0\n\t"\r\n"movec %/d0,%/cacr"\r\n: : : "d0" );\r\nif (!(fslw & MMU060_ERR_BITS) && !(fslw & MMU060_SEE))\r\nreturn;\r\n}\r\nif (fslw & (MMU060_DESC_ERR | MMU060_WP | MMU060_SP)) {\r\nunsigned long errorcode;\r\nunsigned long addr = fp->un.fmt4.effaddr;\r\nif (fslw & MMU060_MA)\r\naddr = (addr + PAGE_SIZE - 1) & PAGE_MASK;\r\nerrorcode = 1;\r\nif (fslw & MMU060_DESC_ERR) {\r\n__flush_tlb040_one(addr);\r\nerrorcode = 0;\r\n}\r\nif (fslw & MMU060_W)\r\nerrorcode |= 2;\r\n#ifdef DEBUG\r\nprintk("errorcode = %d\n", errorcode );\r\n#endif\r\ndo_page_fault(&fp->ptregs, addr, errorcode);\r\n} else if (fslw & (MMU060_SEE)){\r\nsend_fault_sig(&fp->ptregs);\r\n} else if (!(fslw & (MMU060_RE|MMU060_WE)) ||\r\nsend_fault_sig(&fp->ptregs) > 0) {\r\nprintk("pc=%#lx, fa=%#lx\n", fp->ptregs.pc, fp->un.fmt4.effaddr);\r\nprintk( "68060 access error, fslw=%lx\n", fslw );\r\ntrap_c( fp );\r\n}\r\n}\r\nstatic inline unsigned long probe040(int iswrite, unsigned long addr, int wbs)\r\n{\r\nunsigned long mmusr;\r\nmm_segment_t old_fs = get_fs();\r\nset_fs(MAKE_MM_SEG(wbs));\r\nif (iswrite)\r\nasm volatile (".chip 68040; ptestw (%0); .chip 68k" : : "a" (addr));\r\nelse\r\nasm volatile (".chip 68040; ptestr (%0); .chip 68k" : : "a" (addr));\r\nasm volatile (".chip 68040; movec %%mmusr,%0; .chip 68k" : "=r" (mmusr));\r\nset_fs(old_fs);\r\nreturn mmusr;\r\n}\r\nstatic inline int do_040writeback1(unsigned short wbs, unsigned long wba,\r\nunsigned long wbd)\r\n{\r\nint res = 0;\r\nmm_segment_t old_fs = get_fs();\r\nset_fs(MAKE_MM_SEG(wbs));\r\nswitch (wbs & WBSIZ_040) {\r\ncase BA_SIZE_BYTE:\r\nres = put_user(wbd & 0xff, (char __user *)wba);\r\nbreak;\r\ncase BA_SIZE_WORD:\r\nres = put_user(wbd & 0xffff, (short __user *)wba);\r\nbreak;\r\ncase BA_SIZE_LONG:\r\nres = put_user(wbd, (int __user *)wba);\r\nbreak;\r\n}\r\nset_fs(old_fs);\r\n#ifdef DEBUG\r\nprintk("do_040writeback1, res=%d\n",res);\r\n#endif\r\nreturn res;\r\n}\r\nstatic inline void fix_xframe040(struct frame *fp, unsigned long wba, unsigned short wbs)\r\n{\r\nfp->un.fmt7.faddr = wba;\r\nfp->un.fmt7.ssw = wbs & 0xff;\r\nif (wba != current->thread.faddr)\r\nfp->un.fmt7.ssw |= MA_040;\r\n}\r\nstatic inline void do_040writebacks(struct frame *fp)\r\n{\r\nint res = 0;\r\n#if 0\r\nif (fp->un.fmt7.wb1s & WBV_040)\r\nprintk("access_error040: cannot handle 1st writeback. oops.\n");\r\n#endif\r\nif ((fp->un.fmt7.wb2s & WBV_040) &&\r\n!(fp->un.fmt7.wb2s & WBTT_040)) {\r\nres = do_040writeback1(fp->un.fmt7.wb2s, fp->un.fmt7.wb2a,\r\nfp->un.fmt7.wb2d);\r\nif (res)\r\nfix_xframe040(fp, fp->un.fmt7.wb2a, fp->un.fmt7.wb2s);\r\nelse\r\nfp->un.fmt7.wb2s = 0;\r\n}\r\nif (fp->un.fmt7.wb3s & WBV_040 && (!res || fp->un.fmt7.wb3s & 4)) {\r\nres = do_040writeback1(fp->un.fmt7.wb3s, fp->un.fmt7.wb3a,\r\nfp->un.fmt7.wb3d);\r\nif (res)\r\n{\r\nfix_xframe040(fp, fp->un.fmt7.wb3a, fp->un.fmt7.wb3s);\r\nfp->un.fmt7.wb2s = fp->un.fmt7.wb3s;\r\nfp->un.fmt7.wb3s &= (~WBV_040);\r\nfp->un.fmt7.wb2a = fp->un.fmt7.wb3a;\r\nfp->un.fmt7.wb2d = fp->un.fmt7.wb3d;\r\n}\r\nelse\r\nfp->un.fmt7.wb3s = 0;\r\n}\r\nif (res)\r\nsend_fault_sig(&fp->ptregs);\r\n}\r\nasmlinkage void berr_040cleanup(struct frame *fp)\r\n{\r\nfp->un.fmt7.wb2s &= ~4;\r\nfp->un.fmt7.wb3s &= ~4;\r\ndo_040writebacks(fp);\r\n}\r\nstatic inline void access_error040(struct frame *fp)\r\n{\r\nunsigned short ssw = fp->un.fmt7.ssw;\r\nunsigned long mmusr;\r\n#ifdef DEBUG\r\nprintk("ssw=%#x, fa=%#lx\n", ssw, fp->un.fmt7.faddr);\r\nprintk("wb1s=%#x, wb2s=%#x, wb3s=%#x\n", fp->un.fmt7.wb1s,\r\nfp->un.fmt7.wb2s, fp->un.fmt7.wb3s);\r\nprintk ("wb2a=%lx, wb3a=%lx, wb2d=%lx, wb3d=%lx\n",\r\nfp->un.fmt7.wb2a, fp->un.fmt7.wb3a,\r\nfp->un.fmt7.wb2d, fp->un.fmt7.wb3d);\r\n#endif\r\nif (ssw & ATC_040) {\r\nunsigned long addr = fp->un.fmt7.faddr;\r\nunsigned long errorcode;\r\nif (ssw & MA_040)\r\naddr = (addr + 7) & -8;\r\nmmusr = probe040(!(ssw & RW_040), addr, ssw);\r\n#ifdef DEBUG\r\nprintk("mmusr = %lx\n", mmusr);\r\n#endif\r\nerrorcode = 1;\r\nif (!(mmusr & MMU_R_040)) {\r\n__flush_tlb040_one(addr);\r\nerrorcode = 0;\r\n}\r\nif (!(ssw & RW_040) || (ssw & LK_040))\r\nerrorcode |= 2;\r\nif (do_page_fault(&fp->ptregs, addr, errorcode)) {\r\n#ifdef DEBUG\r\nprintk("do_page_fault() !=0\n");\r\n#endif\r\nif (user_mode(&fp->ptregs)){\r\n#ifdef DEBUG\r\nprintk(".. was usermode - return\n");\r\n#endif\r\nreturn;\r\n}\r\ndisable_wb:\r\n#ifdef DEBUG\r\nprintk(".. disabling wb2\n");\r\n#endif\r\nif (fp->un.fmt7.wb2a == fp->un.fmt7.faddr)\r\nfp->un.fmt7.wb2s &= ~WBV_040;\r\nif (fp->un.fmt7.wb3a == fp->un.fmt7.faddr)\r\nfp->un.fmt7.wb3s &= ~WBV_040;\r\n}\r\n} else {\r\ncurrent->thread.signo = SIGBUS;\r\ncurrent->thread.faddr = fp->un.fmt7.faddr;\r\nif (send_fault_sig(&fp->ptregs) >= 0)\r\nprintk("68040 bus error (ssw=%x, faddr=%lx)\n", ssw,\r\nfp->un.fmt7.faddr);\r\ngoto disable_wb;\r\n}\r\ndo_040writebacks(fp);\r\n}\r\nstatic inline void bus_error030 (struct frame *fp)\r\n{\r\nunsigned char buserr_type = sun3_get_buserr ();\r\nunsigned long addr, errorcode;\r\nunsigned short ssw = fp->un.fmtb.ssw;\r\nextern unsigned long _sun3_map_test_start, _sun3_map_test_end;\r\n#ifdef DEBUG\r\nif (ssw & (FC | FB))\r\nprintk ("Instruction fault at %#010lx\n",\r\nssw & FC ?\r\nfp->ptregs.format == 0xa ? fp->ptregs.pc + 2 : fp->un.fmtb.baddr - 2\r\n:\r\nfp->ptregs.format == 0xa ? fp->ptregs.pc + 4 : fp->un.fmtb.baddr);\r\nif (ssw & DF)\r\nprintk ("Data %s fault at %#010lx in %s (pc=%#lx)\n",\r\nssw & RW ? "read" : "write",\r\nfp->un.fmtb.daddr,\r\nspace_names[ssw & DFC], fp->ptregs.pc);\r\n#endif\r\nif ((ssw & DF)\r\n&& (buserr_type & (SUN3_BUSERR_PROTERR | SUN3_BUSERR_INVALID))) {\r\nif (mmu_emu_handle_fault (fp->un.fmtb.daddr, ssw & RW, 0))\r\nreturn;\r\n}\r\nif (fp->ptregs.sr & PS_S) {\r\nif (! ((ssw & DF) && ((ssw & DFC) == USER_DATA))) {\r\nif (mmu_emu_handle_fault (fp->un.fmtb.daddr, ssw & RW, 1))\r\nreturn;\r\nif (ssw & (FC | FB))\r\nprintk ("Instruction fault at %#010lx\n",\r\nfp->ptregs.pc);\r\nif (ssw & DF) {\r\nif((fp->ptregs.pc >= (unsigned long)&_sun3_map_test_start) &&\r\n(fp->ptregs.pc <= (unsigned long)&_sun3_map_test_end)) {\r\nsend_fault_sig(&fp->ptregs);\r\nreturn;\r\n}\r\nprintk ("Data %s fault at %#010lx in %s (pc=%#lx)\n",\r\nssw & RW ? "read" : "write",\r\nfp->un.fmtb.daddr,\r\nspace_names[ssw & DFC], fp->ptregs.pc);\r\n}\r\nprintk ("BAD KERNEL BUSERR\n");\r\ndie_if_kernel("Oops", &fp->ptregs,0);\r\nforce_sig(SIGKILL, current);\r\nreturn;\r\n}\r\n} else {\r\nif (!(ssw & (FC | FB)) && !(ssw & DF))\r\npanic ("USER BUSERR w/o instruction or data fault");\r\n}\r\nif (ssw & DF) {\r\naddr = fp->un.fmtb.daddr;\r\nif (buserr_type & SUN3_BUSERR_PROTERR)\r\nerrorcode = 0x01;\r\nelse if (buserr_type & SUN3_BUSERR_INVALID)\r\nerrorcode = 0x00;\r\nelse {\r\n#ifdef DEBUG\r\nprintk ("*** unexpected busfault type=%#04x\n", buserr_type);\r\nprintk ("invalid %s access at %#lx from pc %#lx\n",\r\n!(ssw & RW) ? "write" : "read", addr,\r\nfp->ptregs.pc);\r\n#endif\r\ndie_if_kernel ("Oops", &fp->ptregs, buserr_type);\r\nforce_sig (SIGBUS, current);\r\nreturn;\r\n}\r\nif (!(ssw & RW) || ssw & RM)\r\nerrorcode |= 0x02;\r\ndo_page_fault (&fp->ptregs, addr, errorcode);\r\nreturn;\r\n}\r\nif (fp->ptregs.format == 0xA)\r\naddr = fp->ptregs.pc + 4;\r\nelse\r\naddr = fp->un.fmtb.baddr;\r\nif (ssw & FC)\r\naddr -= 2;\r\nif (buserr_type & SUN3_BUSERR_INVALID) {\r\nif (!mmu_emu_handle_fault (fp->un.fmtb.daddr, 1, 0))\r\ndo_page_fault (&fp->ptregs, addr, 0);\r\n} else {\r\n#ifdef DEBUG\r\nprintk ("protection fault on insn access (segv).\n");\r\n#endif\r\nforce_sig (SIGSEGV, current);\r\n}\r\n}\r\nstatic inline void bus_error030 (struct frame *fp)\r\n{\r\nvolatile unsigned short temp;\r\nunsigned short mmusr;\r\nunsigned long addr, errorcode;\r\nunsigned short ssw = fp->un.fmtb.ssw;\r\n#ifdef DEBUG\r\nunsigned long desc;\r\nprintk ("pid = %x ", current->pid);\r\nprintk ("SSW=%#06x ", ssw);\r\nif (ssw & (FC | FB))\r\nprintk ("Instruction fault at %#010lx\n",\r\nssw & FC ?\r\nfp->ptregs.format == 0xa ? fp->ptregs.pc + 2 : fp->un.fmtb.baddr - 2\r\n:\r\nfp->ptregs.format == 0xa ? fp->ptregs.pc + 4 : fp->un.fmtb.baddr);\r\nif (ssw & DF)\r\nprintk ("Data %s fault at %#010lx in %s (pc=%#lx)\n",\r\nssw & RW ? "read" : "write",\r\nfp->un.fmtb.daddr,\r\nspace_names[ssw & DFC], fp->ptregs.pc);\r\n#endif\r\nif (ssw & DF) {\r\naddr = fp->un.fmtb.daddr;\r\n#ifdef DEBUG\r\nasm volatile ("ptestr %3,%2@,#7,%0\n\t"\r\n"pmove %%psr,%1@"\r\n: "=a&" (desc)\r\n: "a" (&temp), "a" (addr), "d" (ssw));\r\n#else\r\nasm volatile ("ptestr %2,%1@,#7\n\t"\r\n"pmove %%psr,%0@"\r\n: : "a" (&temp), "a" (addr), "d" (ssw));\r\n#endif\r\nmmusr = temp;\r\n#ifdef DEBUG\r\nprintk("mmusr is %#x for addr %#lx in task %p\n",\r\nmmusr, addr, current);\r\nprintk("descriptor address is %#lx, contents %#lx\n",\r\n__va(desc), *(unsigned long *)__va(desc));\r\n#endif\r\nerrorcode = (mmusr & MMU_I) ? 0 : 1;\r\nif (!(ssw & RW) || (ssw & RM))\r\nerrorcode |= 2;\r\nif (mmusr & (MMU_I | MMU_WP)) {\r\nif (ssw & 4) {\r\nprintk("Data %s fault at %#010lx in %s (pc=%#lx)\n",\r\nssw & RW ? "read" : "write",\r\nfp->un.fmtb.daddr,\r\nspace_names[ssw & DFC], fp->ptregs.pc);\r\ngoto buserr;\r\n}\r\nif (do_page_fault (&fp->ptregs, addr, errorcode) < 0)\r\nreturn;\r\n} else if (!(mmusr & MMU_I)) {\r\nif (!(ssw & RM) && send_fault_sig(&fp->ptregs) > 0)\r\nprintk("unexpected bus error (%#x,%#x)\n", ssw, mmusr);\r\n} else if (mmusr & (MMU_B|MMU_L|MMU_S)) {\r\nprintk("invalid %s access at %#lx from pc %#lx\n",\r\n!(ssw & RW) ? "write" : "read", addr,\r\nfp->ptregs.pc);\r\ndie_if_kernel("Oops",&fp->ptregs,mmusr);\r\nforce_sig(SIGSEGV, current);\r\nreturn;\r\n} else {\r\n#if 0\r\nstatic volatile long tlong;\r\n#endif\r\nprintk("weird %s access at %#lx from pc %#lx (ssw is %#x)\n",\r\n!(ssw & RW) ? "write" : "read", addr,\r\nfp->ptregs.pc, ssw);\r\nasm volatile ("ptestr #1,%1@,#0\n\t"\r\n"pmove %%psr,%0@"\r\n:\r\n: "a" (&temp), "a" (addr));\r\nmmusr = temp;\r\nprintk ("level 0 mmusr is %#x\n", mmusr);\r\n#if 0\r\nasm volatile ("pmove %%tt0,%0@"\r\n:\r\n: "a" (&tlong));\r\nprintk("tt0 is %#lx, ", tlong);\r\nasm volatile ("pmove %%tt1,%0@"\r\n:\r\n: "a" (&tlong));\r\nprintk("tt1 is %#lx\n", tlong);\r\n#endif\r\n#ifdef DEBUG\r\nprintk("Unknown SIGSEGV - 1\n");\r\n#endif\r\ndie_if_kernel("Oops",&fp->ptregs,mmusr);\r\nforce_sig(SIGSEGV, current);\r\nreturn;\r\n}\r\nif (!(ssw & RW) || (ssw & RM))\r\nasm volatile ("ploadw %1,%0@" :\r\n: "a" (addr), "d" (ssw));\r\nelse\r\nasm volatile ("ploadr %1,%0@" :\r\n: "a" (addr), "d" (ssw));\r\n}\r\nif (!(ssw & (FC|FB)))\r\nreturn;\r\nif (fp->ptregs.sr & PS_S) {\r\nprintk("Instruction fault at %#010lx\n",\r\nfp->ptregs.pc);\r\nbuserr:\r\nprintk ("BAD KERNEL BUSERR\n");\r\ndie_if_kernel("Oops",&fp->ptregs,0);\r\nforce_sig(SIGKILL, current);\r\nreturn;\r\n}\r\nif (fp->ptregs.format == 10)\r\naddr = fp->ptregs.pc + 4;\r\nelse\r\naddr = fp->un.fmtb.baddr;\r\nif (ssw & FC)\r\naddr -= 2;\r\nif ((ssw & DF) && ((addr ^ fp->un.fmtb.daddr) & PAGE_MASK) == 0)\r\ngoto create_atc_entry;\r\n#ifdef DEBUG\r\nasm volatile ("ptestr #1,%2@,#7,%0\n\t"\r\n"pmove %%psr,%1@"\r\n: "=a&" (desc)\r\n: "a" (&temp), "a" (addr));\r\n#else\r\nasm volatile ("ptestr #1,%1@,#7\n\t"\r\n"pmove %%psr,%0@"\r\n: : "a" (&temp), "a" (addr));\r\n#endif\r\nmmusr = temp;\r\n#ifdef DEBUG\r\nprintk ("mmusr is %#x for addr %#lx in task %p\n",\r\nmmusr, addr, current);\r\nprintk ("descriptor address is %#lx, contents %#lx\n",\r\n__va(desc), *(unsigned long *)__va(desc));\r\n#endif\r\nif (mmusr & MMU_I)\r\ndo_page_fault (&fp->ptregs, addr, 0);\r\nelse if (mmusr & (MMU_B|MMU_L|MMU_S)) {\r\nprintk ("invalid insn access at %#lx from pc %#lx\n",\r\naddr, fp->ptregs.pc);\r\n#ifdef DEBUG\r\nprintk("Unknown SIGSEGV - 2\n");\r\n#endif\r\ndie_if_kernel("Oops",&fp->ptregs,mmusr);\r\nforce_sig(SIGSEGV, current);\r\nreturn;\r\n}\r\ncreate_atc_entry:\r\nasm volatile ("ploadr #2,%0@" :\r\n: "a" (addr));\r\n}\r\nasmlinkage void buserr_c(struct frame *fp)\r\n{\r\nif (user_mode(&fp->ptregs))\r\ncurrent->thread.esp0 = (unsigned long) fp;\r\n#ifdef DEBUG\r\nprintk ("*** Bus Error *** Format is %x\n", fp->ptregs.format);\r\n#endif\r\nswitch (fp->ptregs.format) {\r\n#if defined (CONFIG_M68060)\r\ncase 4:\r\naccess_error060 (fp);\r\nbreak;\r\n#endif\r\n#if defined (CONFIG_M68040)\r\ncase 0x7:\r\naccess_error040 (fp);\r\nbreak;\r\n#endif\r\n#if defined (CPU_M68020_OR_M68030)\r\ncase 0xa:\r\ncase 0xb:\r\nbus_error030 (fp);\r\nbreak;\r\n#endif\r\ndefault:\r\ndie_if_kernel("bad frame format",&fp->ptregs,0);\r\n#ifdef DEBUG\r\nprintk("Unknown SIGSEGV - 4\n");\r\n#endif\r\nforce_sig(SIGSEGV, current);\r\n}\r\n}\r\nvoid show_trace(unsigned long *stack)\r\n{\r\nunsigned long *endstack;\r\nunsigned long addr;\r\nint i;\r\nprintk("Call Trace:");\r\naddr = (unsigned long)stack + THREAD_SIZE - 1;\r\nendstack = (unsigned long *)(addr & -THREAD_SIZE);\r\ni = 0;\r\nwhile (stack + 1 <= endstack) {\r\naddr = *stack++;\r\nif (__kernel_text_address(addr)) {\r\n#ifndef CONFIG_KALLSYMS\r\nif (i % 5 == 0)\r\nprintk("\n ");\r\n#endif\r\nprintk(" [<%08lx>] %pS\n", addr, (void *)addr);\r\ni++;\r\n}\r\n}\r\nprintk("\n");\r\n}\r\nvoid show_registers(struct pt_regs *regs)\r\n{\r\nstruct frame *fp = (struct frame *)regs;\r\nmm_segment_t old_fs = get_fs();\r\nu16 c, *cp;\r\nunsigned long addr;\r\nint i;\r\nprint_modules();\r\nprintk("PC: [<%08lx>] %pS\n", regs->pc, (void *)regs->pc);\r\nprintk("SR: %04x SP: %p a2: %08lx\n", regs->sr, regs, regs->a2);\r\nprintk("d0: %08lx d1: %08lx d2: %08lx d3: %08lx\n",\r\nregs->d0, regs->d1, regs->d2, regs->d3);\r\nprintk("d4: %08lx d5: %08lx a0: %08lx a1: %08lx\n",\r\nregs->d4, regs->d5, regs->a0, regs->a1);\r\nprintk("Process %s (pid: %d, task=%p)\n",\r\ncurrent->comm, task_pid_nr(current), current);\r\naddr = (unsigned long)&fp->un;\r\nprintk("Frame format=%X ", regs->format);\r\nswitch (regs->format) {\r\ncase 0x2:\r\nprintk("instr addr=%08lx\n", fp->un.fmt2.iaddr);\r\naddr += sizeof(fp->un.fmt2);\r\nbreak;\r\ncase 0x3:\r\nprintk("eff addr=%08lx\n", fp->un.fmt3.effaddr);\r\naddr += sizeof(fp->un.fmt3);\r\nbreak;\r\ncase 0x4:\r\nprintk((CPU_IS_060 ? "fault addr=%08lx fslw=%08lx\n"\r\n: "eff addr=%08lx pc=%08lx\n"),\r\nfp->un.fmt4.effaddr, fp->un.fmt4.pc);\r\naddr += sizeof(fp->un.fmt4);\r\nbreak;\r\ncase 0x7:\r\nprintk("eff addr=%08lx ssw=%04x faddr=%08lx\n",\r\nfp->un.fmt7.effaddr, fp->un.fmt7.ssw, fp->un.fmt7.faddr);\r\nprintk("wb 1 stat/addr/data: %04x %08lx %08lx\n",\r\nfp->un.fmt7.wb1s, fp->un.fmt7.wb1a, fp->un.fmt7.wb1dpd0);\r\nprintk("wb 2 stat/addr/data: %04x %08lx %08lx\n",\r\nfp->un.fmt7.wb2s, fp->un.fmt7.wb2a, fp->un.fmt7.wb2d);\r\nprintk("wb 3 stat/addr/data: %04x %08lx %08lx\n",\r\nfp->un.fmt7.wb3s, fp->un.fmt7.wb3a, fp->un.fmt7.wb3d);\r\nprintk("push data: %08lx %08lx %08lx %08lx\n",\r\nfp->un.fmt7.wb1dpd0, fp->un.fmt7.pd1, fp->un.fmt7.pd2,\r\nfp->un.fmt7.pd3);\r\naddr += sizeof(fp->un.fmt7);\r\nbreak;\r\ncase 0x9:\r\nprintk("instr addr=%08lx\n", fp->un.fmt9.iaddr);\r\naddr += sizeof(fp->un.fmt9);\r\nbreak;\r\ncase 0xa:\r\nprintk("ssw=%04x isc=%04x isb=%04x daddr=%08lx dobuf=%08lx\n",\r\nfp->un.fmta.ssw, fp->un.fmta.isc, fp->un.fmta.isb,\r\nfp->un.fmta.daddr, fp->un.fmta.dobuf);\r\naddr += sizeof(fp->un.fmta);\r\nbreak;\r\ncase 0xb:\r\nprintk("ssw=%04x isc=%04x isb=%04x daddr=%08lx dobuf=%08lx\n",\r\nfp->un.fmtb.ssw, fp->un.fmtb.isc, fp->un.fmtb.isb,\r\nfp->un.fmtb.daddr, fp->un.fmtb.dobuf);\r\nprintk("baddr=%08lx dibuf=%08lx ver=%x\n",\r\nfp->un.fmtb.baddr, fp->un.fmtb.dibuf, fp->un.fmtb.ver);\r\naddr += sizeof(fp->un.fmtb);\r\nbreak;\r\ndefault:\r\nprintk("\n");\r\n}\r\nshow_stack(NULL, (unsigned long *)addr);\r\nprintk("Code:");\r\nset_fs(KERNEL_DS);\r\ncp = (u16 *)regs->pc;\r\nfor (i = -8; i < 16; i++) {\r\nif (get_user(c, cp + i) && i >= 0) {\r\nprintk(" Bad PC value.");\r\nbreak;\r\n}\r\nprintk(i ? " %04x" : " <%04x>", c);\r\n}\r\nset_fs(old_fs);\r\nprintk ("\n");\r\n}\r\nvoid show_stack(struct task_struct *task, unsigned long *stack)\r\n{\r\nunsigned long *p;\r\nunsigned long *endstack;\r\nint i;\r\nif (!stack) {\r\nif (task)\r\nstack = (unsigned long *)task->thread.esp0;\r\nelse\r\nstack = (unsigned long *)&stack;\r\n}\r\nendstack = (unsigned long *)(((unsigned long)stack + THREAD_SIZE - 1) & -THREAD_SIZE);\r\nprintk("Stack from %08lx:", (unsigned long)stack);\r\np = stack;\r\nfor (i = 0; i < kstack_depth_to_print; i++) {\r\nif (p + 1 > endstack)\r\nbreak;\r\nif (i % 8 == 0)\r\nprintk("\n ");\r\nprintk(" %08lx", *p++);\r\n}\r\nprintk("\n");\r\nshow_trace(stack);\r\n}\r\nvoid dump_stack(void)\r\n{\r\nunsigned long stack;\r\nshow_trace(&stack);\r\n}\r\nvoid bad_super_trap (struct frame *fp)\r\n{\r\nconsole_verbose();\r\nif (fp->ptregs.vector < 4 * ARRAY_SIZE(vec_names))\r\nprintk ("*** %s *** FORMAT=%X\n",\r\nvec_names[(fp->ptregs.vector) >> 2],\r\nfp->ptregs.format);\r\nelse\r\nprintk ("*** Exception %d *** FORMAT=%X\n",\r\n(fp->ptregs.vector) >> 2,\r\nfp->ptregs.format);\r\nif (fp->ptregs.vector >> 2 == VEC_ADDRERR && CPU_IS_020_OR_030) {\r\nunsigned short ssw = fp->un.fmtb.ssw;\r\nprintk ("SSW=%#06x ", ssw);\r\nif (ssw & RC)\r\nprintk ("Pipe stage C instruction fault at %#010lx\n",\r\n(fp->ptregs.format) == 0xA ?\r\nfp->ptregs.pc + 2 : fp->un.fmtb.baddr - 2);\r\nif (ssw & RB)\r\nprintk ("Pipe stage B instruction fault at %#010lx\n",\r\n(fp->ptregs.format) == 0xA ?\r\nfp->ptregs.pc + 4 : fp->un.fmtb.baddr);\r\nif (ssw & DF)\r\nprintk ("Data %s fault at %#010lx in %s (pc=%#lx)\n",\r\nssw & RW ? "read" : "write",\r\nfp->un.fmtb.daddr, space_names[ssw & DFC],\r\nfp->ptregs.pc);\r\n}\r\nprintk ("Current process id is %d\n", task_pid_nr(current));\r\ndie_if_kernel("BAD KERNEL TRAP", &fp->ptregs, 0);\r\n}\r\nasmlinkage void trap_c(struct frame *fp)\r\n{\r\nint sig;\r\nsiginfo_t info;\r\nif (fp->ptregs.sr & PS_S) {\r\nif (fp->ptregs.vector == VEC_TRACE << 2) {\r\n} else if (!handle_kernel_fault(&fp->ptregs))\r\nbad_super_trap(fp);\r\nreturn;\r\n}\r\nswitch ((fp->ptregs.vector) >> 2) {\r\ncase VEC_ADDRERR:\r\ninfo.si_code = BUS_ADRALN;\r\nsig = SIGBUS;\r\nbreak;\r\ncase VEC_ILLEGAL:\r\ncase VEC_LINE10:\r\ncase VEC_LINE11:\r\ninfo.si_code = ILL_ILLOPC;\r\nsig = SIGILL;\r\nbreak;\r\ncase VEC_PRIV:\r\ninfo.si_code = ILL_PRVOPC;\r\nsig = SIGILL;\r\nbreak;\r\ncase VEC_COPROC:\r\ninfo.si_code = ILL_COPROC;\r\nsig = SIGILL;\r\nbreak;\r\ncase VEC_TRAP1:\r\ncase VEC_TRAP2:\r\ncase VEC_TRAP3:\r\ncase VEC_TRAP4:\r\ncase VEC_TRAP5:\r\ncase VEC_TRAP6:\r\ncase VEC_TRAP7:\r\ncase VEC_TRAP8:\r\ncase VEC_TRAP9:\r\ncase VEC_TRAP10:\r\ncase VEC_TRAP11:\r\ncase VEC_TRAP12:\r\ncase VEC_TRAP13:\r\ncase VEC_TRAP14:\r\ninfo.si_code = ILL_ILLTRP;\r\nsig = SIGILL;\r\nbreak;\r\ncase VEC_FPBRUC:\r\ncase VEC_FPOE:\r\ncase VEC_FPNAN:\r\ninfo.si_code = FPE_FLTINV;\r\nsig = SIGFPE;\r\nbreak;\r\ncase VEC_FPIR:\r\ninfo.si_code = FPE_FLTRES;\r\nsig = SIGFPE;\r\nbreak;\r\ncase VEC_FPDIVZ:\r\ninfo.si_code = FPE_FLTDIV;\r\nsig = SIGFPE;\r\nbreak;\r\ncase VEC_FPUNDER:\r\ninfo.si_code = FPE_FLTUND;\r\nsig = SIGFPE;\r\nbreak;\r\ncase VEC_FPOVER:\r\ninfo.si_code = FPE_FLTOVF;\r\nsig = SIGFPE;\r\nbreak;\r\ncase VEC_ZERODIV:\r\ninfo.si_code = FPE_INTDIV;\r\nsig = SIGFPE;\r\nbreak;\r\ncase VEC_CHK:\r\ncase VEC_TRAP:\r\ninfo.si_code = FPE_INTOVF;\r\nsig = SIGFPE;\r\nbreak;\r\ncase VEC_TRACE:\r\ninfo.si_code = TRAP_TRACE;\r\nsig = SIGTRAP;\r\nbreak;\r\ncase VEC_TRAP15:\r\ninfo.si_code = TRAP_BRKPT;\r\nsig = SIGTRAP;\r\nbreak;\r\ndefault:\r\ninfo.si_code = ILL_ILLOPC;\r\nsig = SIGILL;\r\nbreak;\r\n}\r\ninfo.si_signo = sig;\r\ninfo.si_errno = 0;\r\nswitch (fp->ptregs.format) {\r\ndefault:\r\ninfo.si_addr = (void *) fp->ptregs.pc;\r\nbreak;\r\ncase 2:\r\ninfo.si_addr = (void *) fp->un.fmt2.iaddr;\r\nbreak;\r\ncase 7:\r\ninfo.si_addr = (void *) fp->un.fmt7.effaddr;\r\nbreak;\r\ncase 9:\r\ninfo.si_addr = (void *) fp->un.fmt9.iaddr;\r\nbreak;\r\ncase 10:\r\ninfo.si_addr = (void *) fp->un.fmta.daddr;\r\nbreak;\r\ncase 11:\r\ninfo.si_addr = (void *) fp->un.fmtb.daddr;\r\nbreak;\r\n}\r\nforce_sig_info (sig, &info, current);\r\n}\r\nvoid die_if_kernel (char *str, struct pt_regs *fp, int nr)\r\n{\r\nif (!(fp->sr & PS_S))\r\nreturn;\r\nconsole_verbose();\r\nprintk("%s: %08x\n",str,nr);\r\nshow_registers(fp);\r\nadd_taint(TAINT_DIE);\r\ndo_exit(SIGSEGV);\r\n}\r\nasmlinkage void fpsp040_die(void)\r\n{\r\ndo_exit(SIGSEGV);\r\n}\r\nasmlinkage void fpemu_signal(int signal, int code, void *addr)\r\n{\r\nsiginfo_t info;\r\ninfo.si_signo = signal;\r\ninfo.si_errno = 0;\r\ninfo.si_code = code;\r\ninfo.si_addr = addr;\r\nforce_sig_info(signal, &info, current);\r\n}
