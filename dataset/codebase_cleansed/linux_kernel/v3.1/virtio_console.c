static struct port *find_port_by_vtermno(u32 vtermno)\r\n{\r\nstruct port *port;\r\nstruct console *cons;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdrvdata_lock, flags);\r\nlist_for_each_entry(cons, &pdrvdata.consoles, list) {\r\nif (cons->vtermno == vtermno) {\r\nport = container_of(cons, struct port, cons);\r\ngoto out;\r\n}\r\n}\r\nport = NULL;\r\nout:\r\nspin_unlock_irqrestore(&pdrvdata_lock, flags);\r\nreturn port;\r\n}\r\nstatic struct port *find_port_by_devt_in_portdev(struct ports_device *portdev,\r\ndev_t dev)\r\n{\r\nstruct port *port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&portdev->ports_lock, flags);\r\nlist_for_each_entry(port, &portdev->ports, list)\r\nif (port->cdev->dev == dev)\r\ngoto out;\r\nport = NULL;\r\nout:\r\nspin_unlock_irqrestore(&portdev->ports_lock, flags);\r\nreturn port;\r\n}\r\nstatic struct port *find_port_by_devt(dev_t dev)\r\n{\r\nstruct ports_device *portdev;\r\nstruct port *port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdrvdata_lock, flags);\r\nlist_for_each_entry(portdev, &pdrvdata.portdevs, list) {\r\nport = find_port_by_devt_in_portdev(portdev, dev);\r\nif (port)\r\ngoto out;\r\n}\r\nport = NULL;\r\nout:\r\nspin_unlock_irqrestore(&pdrvdata_lock, flags);\r\nreturn port;\r\n}\r\nstatic struct port *find_port_by_id(struct ports_device *portdev, u32 id)\r\n{\r\nstruct port *port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&portdev->ports_lock, flags);\r\nlist_for_each_entry(port, &portdev->ports, list)\r\nif (port->id == id)\r\ngoto out;\r\nport = NULL;\r\nout:\r\nspin_unlock_irqrestore(&portdev->ports_lock, flags);\r\nreturn port;\r\n}\r\nstatic struct port *find_port_by_vq(struct ports_device *portdev,\r\nstruct virtqueue *vq)\r\n{\r\nstruct port *port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&portdev->ports_lock, flags);\r\nlist_for_each_entry(port, &portdev->ports, list)\r\nif (port->in_vq == vq || port->out_vq == vq)\r\ngoto out;\r\nport = NULL;\r\nout:\r\nspin_unlock_irqrestore(&portdev->ports_lock, flags);\r\nreturn port;\r\n}\r\nstatic bool is_console_port(struct port *port)\r\n{\r\nif (port->cons.hvc)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool use_multiport(struct ports_device *portdev)\r\n{\r\nif (!portdev->vdev)\r\nreturn 0;\r\nreturn portdev->vdev->features[0] & (1 << VIRTIO_CONSOLE_F_MULTIPORT);\r\n}\r\nstatic void free_buf(struct port_buffer *buf)\r\n{\r\nkfree(buf->buf);\r\nkfree(buf);\r\n}\r\nstatic struct port_buffer *alloc_buf(size_t buf_size)\r\n{\r\nstruct port_buffer *buf;\r\nbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf)\r\ngoto fail;\r\nbuf->buf = kzalloc(buf_size, GFP_KERNEL);\r\nif (!buf->buf)\r\ngoto free_buf;\r\nbuf->len = 0;\r\nbuf->offset = 0;\r\nbuf->size = buf_size;\r\nreturn buf;\r\nfree_buf:\r\nkfree(buf);\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic void *get_inbuf(struct port *port)\r\n{\r\nstruct port_buffer *buf;\r\nstruct virtqueue *vq;\r\nunsigned int len;\r\nvq = port->in_vq;\r\nbuf = virtqueue_get_buf(vq, &len);\r\nif (buf) {\r\nbuf->len = len;\r\nbuf->offset = 0;\r\n}\r\nreturn buf;\r\n}\r\nstatic int add_inbuf(struct virtqueue *vq, struct port_buffer *buf)\r\n{\r\nstruct scatterlist sg[1];\r\nint ret;\r\nsg_init_one(sg, buf->buf, buf->size);\r\nret = virtqueue_add_buf(vq, sg, 0, 1, buf);\r\nvirtqueue_kick(vq);\r\nreturn ret;\r\n}\r\nstatic void discard_port_data(struct port *port)\r\n{\r\nstruct port_buffer *buf;\r\nstruct virtqueue *vq;\r\nunsigned int len;\r\nint ret;\r\nif (!port->portdev) {\r\nreturn;\r\n}\r\nvq = port->in_vq;\r\nif (port->inbuf)\r\nbuf = port->inbuf;\r\nelse\r\nbuf = virtqueue_get_buf(vq, &len);\r\nret = 0;\r\nwhile (buf) {\r\nif (add_inbuf(vq, buf) < 0) {\r\nret++;\r\nfree_buf(buf);\r\n}\r\nbuf = virtqueue_get_buf(vq, &len);\r\n}\r\nport->inbuf = NULL;\r\nif (ret)\r\ndev_warn(port->dev, "Errors adding %d buffers back to vq\n",\r\nret);\r\n}\r\nstatic bool port_has_data(struct port *port)\r\n{\r\nunsigned long flags;\r\nbool ret;\r\nspin_lock_irqsave(&port->inbuf_lock, flags);\r\nif (port->inbuf) {\r\nret = true;\r\ngoto out;\r\n}\r\nport->inbuf = get_inbuf(port);\r\nif (port->inbuf) {\r\nret = true;\r\ngoto out;\r\n}\r\nret = false;\r\nout:\r\nspin_unlock_irqrestore(&port->inbuf_lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t __send_control_msg(struct ports_device *portdev, u32 port_id,\r\nunsigned int event, unsigned int value)\r\n{\r\nstruct scatterlist sg[1];\r\nstruct virtio_console_control cpkt;\r\nstruct virtqueue *vq;\r\nunsigned int len;\r\nif (!use_multiport(portdev))\r\nreturn 0;\r\ncpkt.id = port_id;\r\ncpkt.event = event;\r\ncpkt.value = value;\r\nvq = portdev->c_ovq;\r\nsg_init_one(sg, &cpkt, sizeof(cpkt));\r\nif (virtqueue_add_buf(vq, sg, 1, 0, &cpkt) >= 0) {\r\nvirtqueue_kick(vq);\r\nwhile (!virtqueue_get_buf(vq, &len))\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t send_control_msg(struct port *port, unsigned int event,\r\nunsigned int value)\r\n{\r\nif (port->portdev)\r\nreturn __send_control_msg(port->portdev, port->id, event, value);\r\nreturn 0;\r\n}\r\nstatic void reclaim_consumed_buffers(struct port *port)\r\n{\r\nvoid *buf;\r\nunsigned int len;\r\nif (!port->portdev) {\r\nreturn;\r\n}\r\nwhile ((buf = virtqueue_get_buf(port->out_vq, &len))) {\r\nkfree(buf);\r\nport->outvq_full = false;\r\n}\r\n}\r\nstatic ssize_t send_buf(struct port *port, void *in_buf, size_t in_count,\r\nbool nonblock)\r\n{\r\nstruct scatterlist sg[1];\r\nstruct virtqueue *out_vq;\r\nssize_t ret;\r\nunsigned long flags;\r\nunsigned int len;\r\nout_vq = port->out_vq;\r\nspin_lock_irqsave(&port->outvq_lock, flags);\r\nreclaim_consumed_buffers(port);\r\nsg_init_one(sg, in_buf, in_count);\r\nret = virtqueue_add_buf(out_vq, sg, 1, 0, in_buf);\r\nvirtqueue_kick(out_vq);\r\nif (ret < 0) {\r\nin_count = 0;\r\ngoto done;\r\n}\r\nif (ret == 0)\r\nport->outvq_full = true;\r\nif (nonblock)\r\ngoto done;\r\nwhile (!virtqueue_get_buf(out_vq, &len))\r\ncpu_relax();\r\ndone:\r\nspin_unlock_irqrestore(&port->outvq_lock, flags);\r\nreturn in_count;\r\n}\r\nstatic ssize_t fill_readbuf(struct port *port, char *out_buf, size_t out_count,\r\nbool to_user)\r\n{\r\nstruct port_buffer *buf;\r\nunsigned long flags;\r\nif (!out_count || !port_has_data(port))\r\nreturn 0;\r\nbuf = port->inbuf;\r\nout_count = min(out_count, buf->len - buf->offset);\r\nif (to_user) {\r\nssize_t ret;\r\nret = copy_to_user(out_buf, buf->buf + buf->offset, out_count);\r\nif (ret)\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(out_buf, buf->buf + buf->offset, out_count);\r\n}\r\nbuf->offset += out_count;\r\nif (buf->offset == buf->len) {\r\nspin_lock_irqsave(&port->inbuf_lock, flags);\r\nport->inbuf = NULL;\r\nif (add_inbuf(port->in_vq, buf) < 0)\r\ndev_warn(port->dev, "failed add_buf\n");\r\nspin_unlock_irqrestore(&port->inbuf_lock, flags);\r\n}\r\nreturn out_count;\r\n}\r\nstatic bool will_read_block(struct port *port)\r\n{\r\nif (!port->guest_connected) {\r\nreturn false;\r\n}\r\nreturn !port_has_data(port) && port->host_connected;\r\n}\r\nstatic bool will_write_block(struct port *port)\r\n{\r\nbool ret;\r\nif (!port->guest_connected) {\r\nreturn false;\r\n}\r\nif (!port->host_connected)\r\nreturn true;\r\nspin_lock_irq(&port->outvq_lock);\r\nreclaim_consumed_buffers(port);\r\nret = port->outvq_full;\r\nspin_unlock_irq(&port->outvq_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t port_fops_read(struct file *filp, char __user *ubuf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct port *port;\r\nssize_t ret;\r\nport = filp->private_data;\r\nif (!port_has_data(port)) {\r\nif (!port->host_connected)\r\nreturn 0;\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(port->waitqueue,\r\n!will_read_block(port));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!port->guest_connected)\r\nreturn -ENODEV;\r\nif (!port_has_data(port) && !port->host_connected)\r\nreturn 0;\r\nreturn fill_readbuf(port, ubuf, count, true);\r\n}\r\nstatic ssize_t port_fops_write(struct file *filp, const char __user *ubuf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct port *port;\r\nchar *buf;\r\nssize_t ret;\r\nbool nonblock;\r\nif (!count)\r\nreturn 0;\r\nport = filp->private_data;\r\nnonblock = filp->f_flags & O_NONBLOCK;\r\nif (will_write_block(port)) {\r\nif (nonblock)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(port->waitqueue,\r\n!will_write_block(port));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!port->guest_connected)\r\nreturn -ENODEV;\r\ncount = min((size_t)(32 * 1024), count);\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = copy_from_user(buf, ubuf, count);\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto free_buf;\r\n}\r\nnonblock = true;\r\nret = send_buf(port, buf, count, nonblock);\r\nif (nonblock && ret > 0)\r\ngoto out;\r\nfree_buf:\r\nkfree(buf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic unsigned int port_fops_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct port *port;\r\nunsigned int ret;\r\nport = filp->private_data;\r\npoll_wait(filp, &port->waitqueue, wait);\r\nif (!port->guest_connected) {\r\nreturn POLLHUP;\r\n}\r\nret = 0;\r\nif (!will_read_block(port))\r\nret |= POLLIN | POLLRDNORM;\r\nif (!will_write_block(port))\r\nret |= POLLOUT;\r\nif (!port->host_connected)\r\nret |= POLLHUP;\r\nreturn ret;\r\n}\r\nstatic int port_fops_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct port *port;\r\nport = filp->private_data;\r\nsend_control_msg(port, VIRTIO_CONSOLE_PORT_OPEN, 0);\r\nspin_lock_irq(&port->inbuf_lock);\r\nport->guest_connected = false;\r\ndiscard_port_data(port);\r\nspin_unlock_irq(&port->inbuf_lock);\r\nspin_lock_irq(&port->outvq_lock);\r\nreclaim_consumed_buffers(port);\r\nspin_unlock_irq(&port->outvq_lock);\r\nkref_put(&port->kref, remove_port);\r\nreturn 0;\r\n}\r\nstatic int port_fops_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct cdev *cdev = inode->i_cdev;\r\nstruct port *port;\r\nint ret;\r\nport = find_port_by_devt(cdev->dev);\r\nfilp->private_data = port;\r\nspin_lock_irq(&port->portdev->ports_lock);\r\nkref_get(&port->kref);\r\nspin_unlock_irq(&port->portdev->ports_lock);\r\nif (is_console_port(port)) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nspin_lock_irq(&port->inbuf_lock);\r\nif (port->guest_connected) {\r\nspin_unlock_irq(&port->inbuf_lock);\r\nret = -EMFILE;\r\ngoto out;\r\n}\r\nport->guest_connected = true;\r\nspin_unlock_irq(&port->inbuf_lock);\r\nspin_lock_irq(&port->outvq_lock);\r\nreclaim_consumed_buffers(port);\r\nspin_unlock_irq(&port->outvq_lock);\r\nnonseekable_open(inode, filp);\r\nsend_control_msg(filp->private_data, VIRTIO_CONSOLE_PORT_OPEN, 1);\r\nreturn 0;\r\nout:\r\nkref_put(&port->kref, remove_port);\r\nreturn ret;\r\n}\r\nstatic int port_fops_fasync(int fd, struct file *filp, int mode)\r\n{\r\nstruct port *port;\r\nport = filp->private_data;\r\nreturn fasync_helper(fd, filp, mode, &port->async_queue);\r\n}\r\nstatic int put_chars(u32 vtermno, const char *buf, int count)\r\n{\r\nstruct port *port;\r\nif (unlikely(early_put_chars))\r\nreturn early_put_chars(vtermno, buf, count);\r\nport = find_port_by_vtermno(vtermno);\r\nif (!port)\r\nreturn -EPIPE;\r\nreturn send_buf(port, (void *)buf, count, false);\r\n}\r\nstatic int get_chars(u32 vtermno, char *buf, int count)\r\n{\r\nstruct port *port;\r\nif (unlikely(early_put_chars))\r\nreturn 0;\r\nport = find_port_by_vtermno(vtermno);\r\nif (!port)\r\nreturn -EPIPE;\r\nBUG_ON(!port->in_vq);\r\nreturn fill_readbuf(port, buf, count, false);\r\n}\r\nstatic void resize_console(struct port *port)\r\n{\r\nstruct virtio_device *vdev;\r\nif (!port || !is_console_port(port))\r\nreturn;\r\nvdev = port->portdev->vdev;\r\nif (virtio_has_feature(vdev, VIRTIO_CONSOLE_F_SIZE))\r\nhvc_resize(port->cons.hvc, port->cons.ws);\r\n}\r\nstatic int notifier_add_vio(struct hvc_struct *hp, int data)\r\n{\r\nstruct port *port;\r\nport = find_port_by_vtermno(hp->vtermno);\r\nif (!port)\r\nreturn -EINVAL;\r\nhp->irq_requested = 1;\r\nresize_console(port);\r\nreturn 0;\r\n}\r\nstatic void notifier_del_vio(struct hvc_struct *hp, int data)\r\n{\r\nhp->irq_requested = 0;\r\n}\r\nint __init virtio_cons_early_init(int (*put_chars)(u32, const char *, int))\r\n{\r\nearly_put_chars = put_chars;\r\nreturn hvc_instantiate(0, 0, &hv_ops);\r\n}\r\nint init_port_console(struct port *port)\r\n{\r\nint ret;\r\nport->cons.vtermno = pdrvdata.next_vtermno;\r\nport->cons.hvc = hvc_alloc(port->cons.vtermno, 0, &hv_ops, PAGE_SIZE);\r\nif (IS_ERR(port->cons.hvc)) {\r\nret = PTR_ERR(port->cons.hvc);\r\ndev_err(port->dev,\r\n"error %d allocating hvc for port\n", ret);\r\nport->cons.hvc = NULL;\r\nreturn ret;\r\n}\r\nspin_lock_irq(&pdrvdata_lock);\r\npdrvdata.next_vtermno++;\r\nlist_add_tail(&port->cons.list, &pdrvdata.consoles);\r\nspin_unlock_irq(&pdrvdata_lock);\r\nport->guest_connected = true;\r\nif (early_put_chars)\r\nearly_put_chars = NULL;\r\nsend_control_msg(port, VIRTIO_CONSOLE_PORT_OPEN, 1);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_port_name(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nstruct port *port;\r\nport = dev_get_drvdata(dev);\r\nreturn sprintf(buffer, "%s\n", port->name);\r\n}\r\nstatic int debugfs_open(struct inode *inode, struct file *filp)\r\n{\r\nfilp->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t debugfs_read(struct file *filp, char __user *ubuf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct port *port;\r\nchar *buf;\r\nssize_t ret, out_offset, out_count;\r\nout_count = 1024;\r\nbuf = kmalloc(out_count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nport = filp->private_data;\r\nout_offset = 0;\r\nout_offset += snprintf(buf + out_offset, out_count,\r\n"name: %s\n", port->name ? port->name : "");\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"guest_connected: %d\n", port->guest_connected);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"host_connected: %d\n", port->host_connected);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"outvq_full: %d\n", port->outvq_full);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"is_console: %s\n",\r\nis_console_port(port) ? "yes" : "no");\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"console_vtermno: %u\n", port->cons.vtermno);\r\nret = simple_read_from_buffer(ubuf, count, offp, buf, out_offset);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void set_console_size(struct port *port, u16 rows, u16 cols)\r\n{\r\nif (!port || !is_console_port(port))\r\nreturn;\r\nport->cons.ws.ws_row = rows;\r\nport->cons.ws.ws_col = cols;\r\n}\r\nstatic unsigned int fill_queue(struct virtqueue *vq, spinlock_t *lock)\r\n{\r\nstruct port_buffer *buf;\r\nunsigned int nr_added_bufs;\r\nint ret;\r\nnr_added_bufs = 0;\r\ndo {\r\nbuf = alloc_buf(PAGE_SIZE);\r\nif (!buf)\r\nbreak;\r\nspin_lock_irq(lock);\r\nret = add_inbuf(vq, buf);\r\nif (ret < 0) {\r\nspin_unlock_irq(lock);\r\nfree_buf(buf);\r\nbreak;\r\n}\r\nnr_added_bufs++;\r\nspin_unlock_irq(lock);\r\n} while (ret > 0);\r\nreturn nr_added_bufs;\r\n}\r\nstatic void send_sigio_to_port(struct port *port)\r\n{\r\nif (port->async_queue && port->guest_connected)\r\nkill_fasync(&port->async_queue, SIGIO, POLL_OUT);\r\n}\r\nstatic int add_port(struct ports_device *portdev, u32 id)\r\n{\r\nchar debugfs_name[16];\r\nstruct port *port;\r\nstruct port_buffer *buf;\r\ndev_t devt;\r\nunsigned int nr_added_bufs;\r\nint err;\r\nport = kmalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nkref_init(&port->kref);\r\nport->portdev = portdev;\r\nport->id = id;\r\nport->name = NULL;\r\nport->inbuf = NULL;\r\nport->cons.hvc = NULL;\r\nport->async_queue = NULL;\r\nport->cons.ws.ws_row = port->cons.ws.ws_col = 0;\r\nport->host_connected = port->guest_connected = false;\r\nport->outvq_full = false;\r\nport->in_vq = portdev->in_vqs[port->id];\r\nport->out_vq = portdev->out_vqs[port->id];\r\nport->cdev = cdev_alloc();\r\nif (!port->cdev) {\r\ndev_err(&port->portdev->vdev->dev, "Error allocating cdev\n");\r\nerr = -ENOMEM;\r\ngoto free_port;\r\n}\r\nport->cdev->ops = &port_fops;\r\ndevt = MKDEV(portdev->chr_major, id);\r\nerr = cdev_add(port->cdev, devt, 1);\r\nif (err < 0) {\r\ndev_err(&port->portdev->vdev->dev,\r\n"Error %d adding cdev for port %u\n", err, id);\r\ngoto free_cdev;\r\n}\r\nport->dev = device_create(pdrvdata.class, &port->portdev->vdev->dev,\r\ndevt, port, "vport%up%u",\r\nport->portdev->drv_index, id);\r\nif (IS_ERR(port->dev)) {\r\nerr = PTR_ERR(port->dev);\r\ndev_err(&port->portdev->vdev->dev,\r\n"Error %d creating device for port %u\n",\r\nerr, id);\r\ngoto free_cdev;\r\n}\r\nspin_lock_init(&port->inbuf_lock);\r\nspin_lock_init(&port->outvq_lock);\r\ninit_waitqueue_head(&port->waitqueue);\r\nnr_added_bufs = fill_queue(port->in_vq, &port->inbuf_lock);\r\nif (!nr_added_bufs) {\r\ndev_err(port->dev, "Error allocating inbufs\n");\r\nerr = -ENOMEM;\r\ngoto free_device;\r\n}\r\nif (!use_multiport(port->portdev)) {\r\nerr = init_port_console(port);\r\nif (err)\r\ngoto free_inbufs;\r\n}\r\nspin_lock_irq(&portdev->ports_lock);\r\nlist_add_tail(&port->list, &port->portdev->ports);\r\nspin_unlock_irq(&portdev->ports_lock);\r\nsend_control_msg(port, VIRTIO_CONSOLE_PORT_READY, 1);\r\nif (pdrvdata.debugfs_dir) {\r\nsprintf(debugfs_name, "vport%up%u",\r\nport->portdev->drv_index, id);\r\nport->debugfs_file = debugfs_create_file(debugfs_name, 0444,\r\npdrvdata.debugfs_dir,\r\nport,\r\n&port_debugfs_ops);\r\n}\r\nreturn 0;\r\nfree_inbufs:\r\nwhile ((buf = virtqueue_detach_unused_buf(port->in_vq)))\r\nfree_buf(buf);\r\nfree_device:\r\ndevice_destroy(pdrvdata.class, port->dev->devt);\r\nfree_cdev:\r\ncdev_del(port->cdev);\r\nfree_port:\r\nkfree(port);\r\nfail:\r\n__send_control_msg(portdev, id, VIRTIO_CONSOLE_PORT_READY, 0);\r\nreturn err;\r\n}\r\nstatic void remove_port(struct kref *kref)\r\n{\r\nstruct port *port;\r\nport = container_of(kref, struct port, kref);\r\nsysfs_remove_group(&port->dev->kobj, &port_attribute_group);\r\ndevice_destroy(pdrvdata.class, port->dev->devt);\r\ncdev_del(port->cdev);\r\nkfree(port->name);\r\ndebugfs_remove(port->debugfs_file);\r\nkfree(port);\r\n}\r\nstatic void unplug_port(struct port *port)\r\n{\r\nstruct port_buffer *buf;\r\nspin_lock_irq(&port->portdev->ports_lock);\r\nlist_del(&port->list);\r\nspin_unlock_irq(&port->portdev->ports_lock);\r\nif (port->guest_connected) {\r\nport->guest_connected = false;\r\nport->host_connected = false;\r\nwake_up_interruptible(&port->waitqueue);\r\nsend_sigio_to_port(port);\r\n}\r\nif (is_console_port(port)) {\r\nspin_lock_irq(&pdrvdata_lock);\r\nlist_del(&port->cons.list);\r\nspin_unlock_irq(&pdrvdata_lock);\r\nhvc_remove(port->cons.hvc);\r\n}\r\ndiscard_port_data(port);\r\nreclaim_consumed_buffers(port);\r\nwhile ((buf = virtqueue_detach_unused_buf(port->in_vq)))\r\nfree_buf(buf);\r\nport->portdev = NULL;\r\nkref_put(&port->kref, remove_port);\r\n}\r\nstatic void handle_control_message(struct ports_device *portdev,\r\nstruct port_buffer *buf)\r\n{\r\nstruct virtio_console_control *cpkt;\r\nstruct port *port;\r\nsize_t name_size;\r\nint err;\r\ncpkt = (struct virtio_console_control *)(buf->buf + buf->offset);\r\nport = find_port_by_id(portdev, cpkt->id);\r\nif (!port && cpkt->event != VIRTIO_CONSOLE_PORT_ADD) {\r\ndev_dbg(&portdev->vdev->dev,\r\n"Invalid index %u in control packet\n", cpkt->id);\r\nreturn;\r\n}\r\nswitch (cpkt->event) {\r\ncase VIRTIO_CONSOLE_PORT_ADD:\r\nif (port) {\r\ndev_dbg(&portdev->vdev->dev,\r\n"Port %u already added\n", port->id);\r\nsend_control_msg(port, VIRTIO_CONSOLE_PORT_READY, 1);\r\nbreak;\r\n}\r\nif (cpkt->id >= portdev->config.max_nr_ports) {\r\ndev_warn(&portdev->vdev->dev,\r\n"Request for adding port with out-of-bound id %u, max. supported id: %u\n",\r\ncpkt->id, portdev->config.max_nr_ports - 1);\r\nbreak;\r\n}\r\nadd_port(portdev, cpkt->id);\r\nbreak;\r\ncase VIRTIO_CONSOLE_PORT_REMOVE:\r\nunplug_port(port);\r\nbreak;\r\ncase VIRTIO_CONSOLE_CONSOLE_PORT:\r\nif (!cpkt->value)\r\nbreak;\r\nif (is_console_port(port))\r\nbreak;\r\ninit_port_console(port);\r\nbreak;\r\ncase VIRTIO_CONSOLE_RESIZE: {\r\nstruct {\r\n__u16 rows;\r\n__u16 cols;\r\n} size;\r\nif (!is_console_port(port))\r\nbreak;\r\nmemcpy(&size, buf->buf + buf->offset + sizeof(*cpkt),\r\nsizeof(size));\r\nset_console_size(port, size.rows, size.cols);\r\nport->cons.hvc->irq_requested = 1;\r\nresize_console(port);\r\nbreak;\r\n}\r\ncase VIRTIO_CONSOLE_PORT_OPEN:\r\nport->host_connected = cpkt->value;\r\nwake_up_interruptible(&port->waitqueue);\r\nspin_lock_irq(&port->outvq_lock);\r\nreclaim_consumed_buffers(port);\r\nspin_unlock_irq(&port->outvq_lock);\r\nsend_sigio_to_port(port);\r\nbreak;\r\ncase VIRTIO_CONSOLE_PORT_NAME:\r\nname_size = buf->len - buf->offset - sizeof(*cpkt) + 1;\r\nport->name = kmalloc(name_size, GFP_KERNEL);\r\nif (!port->name) {\r\ndev_err(port->dev,\r\n"Not enough space to store port name\n");\r\nbreak;\r\n}\r\nstrncpy(port->name, buf->buf + buf->offset + sizeof(*cpkt),\r\nname_size - 1);\r\nport->name[name_size - 1] = 0;\r\nerr = sysfs_create_group(&port->dev->kobj,\r\n&port_attribute_group);\r\nif (err) {\r\ndev_err(port->dev,\r\n"Error %d creating sysfs device attributes\n",\r\nerr);\r\n} else {\r\nkobject_uevent(&port->dev->kobj, KOBJ_CHANGE);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void control_work_handler(struct work_struct *work)\r\n{\r\nstruct ports_device *portdev;\r\nstruct virtqueue *vq;\r\nstruct port_buffer *buf;\r\nunsigned int len;\r\nportdev = container_of(work, struct ports_device, control_work);\r\nvq = portdev->c_ivq;\r\nspin_lock(&portdev->cvq_lock);\r\nwhile ((buf = virtqueue_get_buf(vq, &len))) {\r\nspin_unlock(&portdev->cvq_lock);\r\nbuf->len = len;\r\nbuf->offset = 0;\r\nhandle_control_message(portdev, buf);\r\nspin_lock(&portdev->cvq_lock);\r\nif (add_inbuf(portdev->c_ivq, buf) < 0) {\r\ndev_warn(&portdev->vdev->dev,\r\n"Error adding buffer to queue\n");\r\nfree_buf(buf);\r\n}\r\n}\r\nspin_unlock(&portdev->cvq_lock);\r\n}\r\nstatic void out_intr(struct virtqueue *vq)\r\n{\r\nstruct port *port;\r\nport = find_port_by_vq(vq->vdev->priv, vq);\r\nif (!port)\r\nreturn;\r\nwake_up_interruptible(&port->waitqueue);\r\n}\r\nstatic void in_intr(struct virtqueue *vq)\r\n{\r\nstruct port *port;\r\nunsigned long flags;\r\nport = find_port_by_vq(vq->vdev->priv, vq);\r\nif (!port)\r\nreturn;\r\nspin_lock_irqsave(&port->inbuf_lock, flags);\r\nif (!port->inbuf)\r\nport->inbuf = get_inbuf(port);\r\nif (!port->guest_connected)\r\ndiscard_port_data(port);\r\nspin_unlock_irqrestore(&port->inbuf_lock, flags);\r\nwake_up_interruptible(&port->waitqueue);\r\nsend_sigio_to_port(port);\r\nif (is_console_port(port) && hvc_poll(port->cons.hvc))\r\nhvc_kick();\r\n}\r\nstatic void control_intr(struct virtqueue *vq)\r\n{\r\nstruct ports_device *portdev;\r\nportdev = vq->vdev->priv;\r\nschedule_work(&portdev->control_work);\r\n}\r\nstatic void config_intr(struct virtio_device *vdev)\r\n{\r\nstruct ports_device *portdev;\r\nportdev = vdev->priv;\r\nif (!use_multiport(portdev)) {\r\nstruct port *port;\r\nu16 rows, cols;\r\nvdev->config->get(vdev,\r\noffsetof(struct virtio_console_config, cols),\r\n&cols, sizeof(u16));\r\nvdev->config->get(vdev,\r\noffsetof(struct virtio_console_config, rows),\r\n&rows, sizeof(u16));\r\nport = find_port_by_id(portdev, 0);\r\nset_console_size(port, rows, cols);\r\nresize_console(port);\r\n}\r\n}\r\nstatic int init_vqs(struct ports_device *portdev)\r\n{\r\nvq_callback_t **io_callbacks;\r\nchar **io_names;\r\nstruct virtqueue **vqs;\r\nu32 i, j, nr_ports, nr_queues;\r\nint err;\r\nnr_ports = portdev->config.max_nr_ports;\r\nnr_queues = use_multiport(portdev) ? (nr_ports + 1) * 2 : 2;\r\nvqs = kmalloc(nr_queues * sizeof(struct virtqueue *), GFP_KERNEL);\r\nio_callbacks = kmalloc(nr_queues * sizeof(vq_callback_t *), GFP_KERNEL);\r\nio_names = kmalloc(nr_queues * sizeof(char *), GFP_KERNEL);\r\nportdev->in_vqs = kmalloc(nr_ports * sizeof(struct virtqueue *),\r\nGFP_KERNEL);\r\nportdev->out_vqs = kmalloc(nr_ports * sizeof(struct virtqueue *),\r\nGFP_KERNEL);\r\nif (!vqs || !io_callbacks || !io_names || !portdev->in_vqs ||\r\n!portdev->out_vqs) {\r\nerr = -ENOMEM;\r\ngoto free;\r\n}\r\nj = 0;\r\nio_callbacks[j] = in_intr;\r\nio_callbacks[j + 1] = out_intr;\r\nio_names[j] = "input";\r\nio_names[j + 1] = "output";\r\nj += 2;\r\nif (use_multiport(portdev)) {\r\nio_callbacks[j] = control_intr;\r\nio_callbacks[j + 1] = NULL;\r\nio_names[j] = "control-i";\r\nio_names[j + 1] = "control-o";\r\nfor (i = 1; i < nr_ports; i++) {\r\nj += 2;\r\nio_callbacks[j] = in_intr;\r\nio_callbacks[j + 1] = out_intr;\r\nio_names[j] = "input";\r\nio_names[j + 1] = "output";\r\n}\r\n}\r\nerr = portdev->vdev->config->find_vqs(portdev->vdev, nr_queues, vqs,\r\nio_callbacks,\r\n(const char **)io_names);\r\nif (err)\r\ngoto free;\r\nj = 0;\r\nportdev->in_vqs[0] = vqs[0];\r\nportdev->out_vqs[0] = vqs[1];\r\nj += 2;\r\nif (use_multiport(portdev)) {\r\nportdev->c_ivq = vqs[j];\r\nportdev->c_ovq = vqs[j + 1];\r\nfor (i = 1; i < nr_ports; i++) {\r\nj += 2;\r\nportdev->in_vqs[i] = vqs[j];\r\nportdev->out_vqs[i] = vqs[j + 1];\r\n}\r\n}\r\nkfree(io_names);\r\nkfree(io_callbacks);\r\nkfree(vqs);\r\nreturn 0;\r\nfree:\r\nkfree(portdev->out_vqs);\r\nkfree(portdev->in_vqs);\r\nkfree(io_names);\r\nkfree(io_callbacks);\r\nkfree(vqs);\r\nreturn err;\r\n}\r\nstatic int __devinit virtcons_probe(struct virtio_device *vdev)\r\n{\r\nstruct ports_device *portdev;\r\nint err;\r\nbool multiport;\r\nportdev = kmalloc(sizeof(*portdev), GFP_KERNEL);\r\nif (!portdev) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nportdev->vdev = vdev;\r\nvdev->priv = portdev;\r\nspin_lock_irq(&pdrvdata_lock);\r\nportdev->drv_index = pdrvdata.index++;\r\nspin_unlock_irq(&pdrvdata_lock);\r\nportdev->chr_major = register_chrdev(0, "virtio-portsdev",\r\n&portdev_fops);\r\nif (portdev->chr_major < 0) {\r\ndev_err(&vdev->dev,\r\n"Error %d registering chrdev for device %u\n",\r\nportdev->chr_major, portdev->drv_index);\r\nerr = portdev->chr_major;\r\ngoto free;\r\n}\r\nmultiport = false;\r\nportdev->config.max_nr_ports = 1;\r\nif (virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT)) {\r\nmultiport = true;\r\nvdev->config->get(vdev, offsetof(struct virtio_console_config,\r\nmax_nr_ports),\r\n&portdev->config.max_nr_ports,\r\nsizeof(portdev->config.max_nr_ports));\r\n}\r\nerr = init_vqs(portdev);\r\nif (err < 0) {\r\ndev_err(&vdev->dev, "Error %d initializing vqs\n", err);\r\ngoto free_chrdev;\r\n}\r\nspin_lock_init(&portdev->ports_lock);\r\nINIT_LIST_HEAD(&portdev->ports);\r\nif (multiport) {\r\nunsigned int nr_added_bufs;\r\nspin_lock_init(&portdev->cvq_lock);\r\nINIT_WORK(&portdev->control_work, &control_work_handler);\r\nnr_added_bufs = fill_queue(portdev->c_ivq, &portdev->cvq_lock);\r\nif (!nr_added_bufs) {\r\ndev_err(&vdev->dev,\r\n"Error allocating buffers for control queue\n");\r\nerr = -ENOMEM;\r\ngoto free_vqs;\r\n}\r\n} else {\r\nadd_port(portdev, 0);\r\n}\r\nspin_lock_irq(&pdrvdata_lock);\r\nlist_add_tail(&portdev->list, &pdrvdata.portdevs);\r\nspin_unlock_irq(&pdrvdata_lock);\r\n__send_control_msg(portdev, VIRTIO_CONSOLE_BAD_ID,\r\nVIRTIO_CONSOLE_DEVICE_READY, 1);\r\nreturn 0;\r\nfree_vqs:\r\n__send_control_msg(portdev, VIRTIO_CONSOLE_BAD_ID,\r\nVIRTIO_CONSOLE_DEVICE_READY, 0);\r\nvdev->config->del_vqs(vdev);\r\nkfree(portdev->in_vqs);\r\nkfree(portdev->out_vqs);\r\nfree_chrdev:\r\nunregister_chrdev(portdev->chr_major, "virtio-portsdev");\r\nfree:\r\nkfree(portdev);\r\nfail:\r\nreturn err;\r\n}\r\nstatic void virtcons_remove(struct virtio_device *vdev)\r\n{\r\nstruct ports_device *portdev;\r\nstruct port *port, *port2;\r\nportdev = vdev->priv;\r\nspin_lock_irq(&pdrvdata_lock);\r\nlist_del(&portdev->list);\r\nspin_unlock_irq(&pdrvdata_lock);\r\nvdev->config->reset(vdev);\r\ncancel_work_sync(&portdev->control_work);\r\nlist_for_each_entry_safe(port, port2, &portdev->ports, list)\r\nunplug_port(port);\r\nunregister_chrdev(portdev->chr_major, "virtio-portsdev");\r\nif (use_multiport(portdev)) {\r\nstruct port_buffer *buf;\r\nunsigned int len;\r\nwhile ((buf = virtqueue_get_buf(portdev->c_ivq, &len)))\r\nfree_buf(buf);\r\nwhile ((buf = virtqueue_detach_unused_buf(portdev->c_ivq)))\r\nfree_buf(buf);\r\n}\r\nvdev->config->del_vqs(vdev);\r\nkfree(portdev->in_vqs);\r\nkfree(portdev->out_vqs);\r\nkfree(portdev);\r\n}\r\nstatic int __init init(void)\r\n{\r\nint err;\r\npdrvdata.class = class_create(THIS_MODULE, "virtio-ports");\r\nif (IS_ERR(pdrvdata.class)) {\r\nerr = PTR_ERR(pdrvdata.class);\r\npr_err("Error %d creating virtio-ports class\n", err);\r\nreturn err;\r\n}\r\npdrvdata.debugfs_dir = debugfs_create_dir("virtio-ports", NULL);\r\nif (!pdrvdata.debugfs_dir) {\r\npr_warning("Error %ld creating debugfs dir for virtio-ports\n",\r\nPTR_ERR(pdrvdata.debugfs_dir));\r\n}\r\nINIT_LIST_HEAD(&pdrvdata.consoles);\r\nINIT_LIST_HEAD(&pdrvdata.portdevs);\r\nreturn register_virtio_driver(&virtio_console);\r\n}\r\nstatic void __exit fini(void)\r\n{\r\nunregister_virtio_driver(&virtio_console);\r\nclass_destroy(pdrvdata.class);\r\nif (pdrvdata.debugfs_dir)\r\ndebugfs_remove_recursive(pdrvdata.debugfs_dir);\r\n}
