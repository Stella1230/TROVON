static void hwblk_area_mod_cnt(struct hwblk_info *info,\r\nint area, int counter, int value, int goal)\r\n{\r\nstruct hwblk_area *hap = info->areas + area;\r\nhap->cnt[counter] += value;\r\nif (hap->cnt[counter] != goal)\r\nreturn;\r\nif (hap->flags & HWBLK_AREA_FLAG_PARENT)\r\nhwblk_area_mod_cnt(info, hap->parent, counter, value, goal);\r\n}\r\nstatic int __hwblk_mod_cnt(struct hwblk_info *info, int hwblk,\r\nint counter, int value, int goal)\r\n{\r\nstruct hwblk *hp = info->hwblks + hwblk;\r\nhp->cnt[counter] += value;\r\nif (hp->cnt[counter] == goal)\r\nhwblk_area_mod_cnt(info, hp->area, counter, value, goal);\r\nreturn hp->cnt[counter];\r\n}\r\nstatic void hwblk_mod_cnt(struct hwblk_info *info, int hwblk,\r\nint counter, int value, int goal)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hwblk_lock, flags);\r\n__hwblk_mod_cnt(info, hwblk, counter, value, goal);\r\nspin_unlock_irqrestore(&hwblk_lock, flags);\r\n}\r\nvoid hwblk_cnt_inc(struct hwblk_info *info, int hwblk, int counter)\r\n{\r\nhwblk_mod_cnt(info, hwblk, counter, 1, 1);\r\n}\r\nvoid hwblk_cnt_dec(struct hwblk_info *info, int hwblk, int counter)\r\n{\r\nhwblk_mod_cnt(info, hwblk, counter, -1, 0);\r\n}\r\nvoid hwblk_enable(struct hwblk_info *info, int hwblk)\r\n{\r\nstruct hwblk *hp = info->hwblks + hwblk;\r\nunsigned long tmp;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&hwblk_lock, flags);\r\nret = __hwblk_mod_cnt(info, hwblk, HWBLK_CNT_USAGE, 1, 1);\r\nif (ret == 1) {\r\ntmp = __raw_readl(hp->mstp);\r\ntmp &= ~(1 << hp->bit);\r\n__raw_writel(tmp, hp->mstp);\r\n}\r\nspin_unlock_irqrestore(&hwblk_lock, flags);\r\n}\r\nvoid hwblk_disable(struct hwblk_info *info, int hwblk)\r\n{\r\nstruct hwblk *hp = info->hwblks + hwblk;\r\nunsigned long tmp;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&hwblk_lock, flags);\r\nret = __hwblk_mod_cnt(info, hwblk, HWBLK_CNT_USAGE, -1, 0);\r\nif (ret == 0) {\r\ntmp = __raw_readl(hp->mstp);\r\ntmp |= 1 << hp->bit;\r\n__raw_writel(tmp, hp->mstp);\r\n}\r\nspin_unlock_irqrestore(&hwblk_lock, flags);\r\n}\r\nint __init hwblk_register(struct hwblk_info *info)\r\n{\r\nhwblk_info = info;\r\nreturn 0;\r\n}\r\nint __init __weak arch_hwblk_init(void)\r\n{\r\nreturn 0;\r\n}\r\nint __weak arch_hwblk_sleep_mode(void)\r\n{\r\nreturn SUSP_SH_SLEEP;\r\n}\r\nint __init hwblk_init(void)\r\n{\r\nreturn arch_hwblk_init();\r\n}\r\nstatic int sh_hwblk_clk_enable(struct clk *clk)\r\n{\r\nif (!hwblk_info)\r\nreturn -ENOENT;\r\nhwblk_enable(hwblk_info, clk->arch_flags);\r\nreturn 0;\r\n}\r\nstatic void sh_hwblk_clk_disable(struct clk *clk)\r\n{\r\nif (hwblk_info)\r\nhwblk_disable(hwblk_info, clk->arch_flags);\r\n}\r\nint __init sh_hwblk_clk_register(struct clk *clks, int nr)\r\n{\r\nstruct clk *clkp;\r\nint ret = 0;\r\nint k;\r\nfor (k = 0; !ret && (k < nr); k++) {\r\nclkp = clks + k;\r\nif (!clkp->arch_flags)\r\ncontinue;\r\nclkp->ops = &sh_hwblk_clk_ops;\r\nret |= clk_register(clkp);\r\n}\r\nreturn ret;\r\n}
