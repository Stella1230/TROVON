static int bcm_char_open(struct inode *inode, struct file * filp)\r\n{\r\nPMINI_ADAPTER Adapter = NULL;\r\nPPER_TARANG_DATA pTarang = NULL;\r\nAdapter = GET_BCM_ADAPTER(gblpnetdev);\r\npTarang = kzalloc(sizeof(PER_TARANG_DATA), GFP_KERNEL);\r\nif (!pTarang)\r\nreturn -ENOMEM;\r\npTarang->Adapter = Adapter;\r\npTarang->RxCntrlMsgBitMask = 0xFFFFFFFF & ~(1 << 0xB);\r\ndown(&Adapter->RxAppControlQueuelock);\r\npTarang->next = Adapter->pTarangs;\r\nAdapter->pTarangs = pTarang;\r\nup(&Adapter->RxAppControlQueuelock);\r\nfilp->private_data = pTarang;\r\natomic_inc(&Adapter->ApplicationRunning);\r\nnonseekable_open(inode, filp);\r\nreturn 0;\r\n}\r\nstatic int bcm_char_release(struct inode *inode, struct file *filp)\r\n{\r\nPPER_TARANG_DATA pTarang, tmp, ptmp;\r\nPMINI_ADAPTER Adapter = NULL;\r\nstruct sk_buff *pkt, *npkt;\r\npTarang = (PPER_TARANG_DATA)filp->private_data;\r\nif (pTarang == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\r\n"ptarang is null\n");\r\nreturn 0;\r\n}\r\nAdapter = pTarang->Adapter;\r\ndown(&Adapter->RxAppControlQueuelock);\r\ntmp = Adapter->pTarangs;\r\nfor (ptmp = NULL; tmp; ptmp = tmp, tmp = tmp->next) {\r\nif (tmp == pTarang)\r\nbreak;\r\n}\r\nif (tmp) {\r\nif (!ptmp)\r\nAdapter->pTarangs = tmp->next;\r\nelse\r\nptmp->next = tmp->next;\r\n} else {\r\nup(&Adapter->RxAppControlQueuelock);\r\nreturn 0;\r\n}\r\npkt = pTarang->RxAppControlHead;\r\nwhile (pkt) {\r\nnpkt = pkt->next;\r\nkfree_skb(pkt);\r\npkt = npkt;\r\n}\r\nup(&Adapter->RxAppControlQueuelock);\r\natomic_dec(&Adapter->ApplicationRunning);\r\nkfree(pTarang);\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t bcm_char_read(struct file *filp, char __user *buf, size_t size,\r\nloff_t *f_pos)\r\n{\r\nPPER_TARANG_DATA pTarang = filp->private_data;\r\nPMINI_ADAPTER Adapter = pTarang->Adapter;\r\nstruct sk_buff *Packet = NULL;\r\nssize_t PktLen = 0;\r\nint wait_ret_val = 0;\r\nunsigned long ret = 0;\r\nwait_ret_val = wait_event_interruptible(Adapter->process_read_wait_queue,\r\n(pTarang->RxAppControlHead ||\r\nAdapter->device_removed));\r\nif ((wait_ret_val == -ERESTARTSYS)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\r\n"Exiting as i've been asked to exit!!!\n");\r\nreturn wait_ret_val;\r\n}\r\nif (Adapter->device_removed) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\r\n"Device Removed... Killing the Apps...\n");\r\nreturn -ENODEV;\r\n}\r\nif (FALSE == Adapter->fw_download_done)\r\nreturn -EACCES;\r\ndown(&Adapter->RxAppControlQueuelock);\r\nif (pTarang->RxAppControlHead) {\r\nPacket = pTarang->RxAppControlHead;\r\nDEQUEUEPACKET(pTarang->RxAppControlHead,\r\npTarang->RxAppControlTail);\r\npTarang->AppCtrlQueueLen--;\r\n}\r\nup(&Adapter->RxAppControlQueuelock);\r\nif (Packet) {\r\nPktLen = Packet->len;\r\nret = copy_to_user(buf, Packet->data,\r\nmin_t(size_t, PktLen, size));\r\nif (ret) {\r\ndev_kfree_skb(Packet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\r\n"Returning from copy to user failure\n");\r\nreturn -EFAULT;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\r\n"Read %zd Bytes From Adapter packet = %p by process %d!\n",\r\nPktLen, Packet, current->pid);\r\ndev_kfree_skb(Packet);\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "<\n");\r\nreturn PktLen;\r\n}\r\nstatic long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)\r\n{\r\nPPER_TARANG_DATA pTarang = filp->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nPMINI_ADAPTER Adapter = pTarang->Adapter;\r\nINT Status = STATUS_FAILURE;\r\nint timeout = 0;\r\nIOCTL_BUFFER IoBuffer;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX", cmd, arg);\r\nif(_IOC_TYPE(cmd) != BCM_IOCTL)\r\nreturn -EFAULT;\r\nif(_IOC_DIR(cmd) & _IOC_READ)\r\nStatus = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));\r\nelse if (_IOC_DIR(cmd) & _IOC_WRITE)\r\nStatus = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));\r\nelse if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))\r\nStatus = STATUS_SUCCESS;\r\nif(Status)\r\nreturn -EFAULT;\r\nif(Adapter->device_removed)\r\n{\r\nreturn -EFAULT;\r\n}\r\nif(FALSE == Adapter->fw_download_done)\r\n{\r\nswitch (cmd)\r\n{\r\ncase IOCTL_MAC_ADDR_REQ:\r\ncase IOCTL_LINK_REQ:\r\ncase IOCTL_CM_REQUEST:\r\ncase IOCTL_SS_INFO_REQ:\r\ncase IOCTL_SEND_CONTROL_MESSAGE:\r\ncase IOCTL_IDLE_REQ:\r\ncase IOCTL_BCM_GPIO_SET_REQUEST:\r\ncase IOCTL_BCM_GPIO_STATUS_REQUEST:\r\nreturn -EACCES;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nStatus = vendorextnIoctl(Adapter, cmd, arg);\r\nif(Status != CONTINUE_COMMON_PATH )\r\nreturn Status;\r\nswitch(cmd){\r\ncase IOCTL_BCM_REGISTER_READ_PRIVATE:\r\n{\r\nRDM_BUFFER sRdmBuffer = {0};\r\nPCHAR temp_buff;\r\nUINT Bufflen;\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(sRdmBuffer))\r\nreturn -EINVAL;\r\nif(copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nBufflen = IoBuffer.OutputLength + (4 - IoBuffer.OutputLength%4)%4;\r\ntemp_buff = kmalloc(Bufflen, GFP_KERNEL);\r\nif(!temp_buff)\r\nreturn -ENOMEM;\r\nStatus = rdmalt(Adapter, (UINT)sRdmBuffer.Register,\r\n(PUINT)temp_buff, Bufflen);\r\nif(Status == STATUS_SUCCESS)\r\n{\r\nif(copy_to_user(IoBuffer.OutputBuffer, temp_buff, IoBuffer.OutputLength))\r\nStatus = -EFAULT;\r\n}\r\nkfree(temp_buff);\r\nbreak;\r\n}\r\ncase IOCTL_BCM_REGISTER_WRITE_PRIVATE:\r\n{\r\nWRM_BUFFER sWrmBuffer = {0};\r\nUINT uiTempVar=0;\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(sWrmBuffer))\r\nreturn -EINVAL;\r\nif(copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nuiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;\r\nif(!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&\r\n((uiTempVar == EEPROM_REJECT_REG_1)||\r\n(uiTempVar == EEPROM_REJECT_REG_2) ||\r\n(uiTempVar == EEPROM_REJECT_REG_3) ||\r\n(uiTempVar == EEPROM_REJECT_REG_4)))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "EEPROM Access Denied, not in VSG Mode\n");\r\nreturn -EFAULT;\r\n}\r\nStatus = wrmalt(Adapter, (UINT)sWrmBuffer.Register,\r\n(PUINT)sWrmBuffer.Data, sizeof(ULONG));\r\nif(Status == STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"WRM Done\n");\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "WRM Failed\n");\r\nStatus = -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase IOCTL_BCM_REGISTER_READ:\r\ncase IOCTL_BCM_EEPROM_REGISTER_READ:\r\n{\r\nRDM_BUFFER sRdmBuffer = {0};\r\nPCHAR temp_buff = NULL;\r\nUINT uiTempVar = 0;\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Device in Idle Mode, Blocking Rdms\n");\r\nreturn -EACCES;\r\n}\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(sRdmBuffer))\r\nreturn -EINVAL;\r\nif(copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\ntemp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);\r\nif(!temp_buff)\r\nreturn STATUS_FAILURE;\r\nif((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||\r\n((ULONG)sRdmBuffer.Register & 0x3))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "RDM Done On invalid Address : %x Access Denied.\n",\r\n(int)sRdmBuffer.Register);\r\nreturn -EINVAL;\r\n}\r\nuiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;\r\nStatus = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register,\r\n(PUINT)temp_buff, IoBuffer.OutputLength);\r\nif(Status == STATUS_SUCCESS)\r\nif(copy_to_user(IoBuffer.OutputBuffer, temp_buff, IoBuffer.OutputLength))\r\nStatus = -EFAULT;\r\nkfree(temp_buff);\r\nbreak;\r\n}\r\ncase IOCTL_BCM_REGISTER_WRITE:\r\ncase IOCTL_BCM_EEPROM_REGISTER_WRITE:\r\n{\r\nWRM_BUFFER sWrmBuffer = {0};\r\nUINT uiTempVar=0;\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Device in Idle Mode, Blocking Wrms\n");\r\nreturn -EACCES;\r\n}\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(sWrmBuffer))\r\nreturn -EINVAL;\r\nif(copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nif( (((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||\r\n((ULONG)sWrmBuffer.Register & 0x3) )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "WRM Done On invalid Address : %x Access Denied.\n",\r\n(int)sWrmBuffer.Register);\r\nreturn -EINVAL;\r\n}\r\nuiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;\r\nif(!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&\r\n((uiTempVar == EEPROM_REJECT_REG_1)||\r\n(uiTempVar == EEPROM_REJECT_REG_2) ||\r\n(uiTempVar == EEPROM_REJECT_REG_3) ||\r\n(uiTempVar == EEPROM_REJECT_REG_4)) &&\r\n(cmd == IOCTL_BCM_REGISTER_WRITE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "EEPROM Access Denied, not in VSG Mode\n");\r\nreturn -EFAULT;\r\n}\r\nStatus = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,\r\n(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);\r\nif(Status == STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, "WRM Done\n");\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "WRM Failed\n");\r\nStatus = -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase IOCTL_BCM_GPIO_SET_REQUEST:\r\n{\r\nUCHAR ucResetValue[4];\r\nUINT value =0;\r\nUINT uiBit = 0;\r\nUINT uiOperation = 0;\r\nGPIO_INFO gpio_info = {0};\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"GPIO Can't be set/clear in Low power Mode");\r\nreturn -EACCES;\r\n}\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(gpio_info))\r\nreturn -EINVAL;\r\nif(copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nuiBit = gpio_info.uiGpioNumber;\r\nuiOperation = gpio_info.uiGpioValue;\r\nvalue= (1<<uiBit);\r\nif(IsReqGpioIsLedInNVM(Adapter,value) ==FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Sorry, Requested GPIO<0x%X> is not correspond to LED !!!",value);\r\nStatus = -EINVAL;\r\nbreak;\r\n}\r\nif(uiOperation)\r\n{\r\nStatus = wrmaltWithLock(Adapter,BCM_GPIO_OUTPUT_SET_REG ,\r\n(PUINT)(&value), sizeof(UINT));\r\nif(Status == STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Set the GPIO bit\n");\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Failed to set the %dth GPIO \n",uiBit);\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nStatus = wrmaltWithLock(Adapter,BCM_GPIO_OUTPUT_CLR_REG ,\r\n(PUINT)(&value), sizeof(UINT));\r\nif(Status == STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Set the GPIO bit\n");\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Failed to clear the %dth GPIO \n",uiBit);\r\nbreak;\r\n}\r\n}\r\nStatus = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER,\r\n(PUINT)ucResetValue, sizeof(UINT));\r\nif (STATUS_SUCCESS != Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"GPIO_MODE_REGISTER read failed");\r\nbreak;\r\n}\r\n*(UINT*)ucResetValue |= (1<<uiBit);\r\nStatus = wrmaltWithLock(Adapter,GPIO_MODE_REGISTER ,\r\n(PUINT)ucResetValue, sizeof(UINT));\r\nif(Status == STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Set the GPIO to output Mode\n");\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Failed to put GPIO in Output Mode\n");\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase BCM_LED_THREAD_STATE_CHANGE_REQ:\r\n{\r\nUSER_THREAD_REQ threadReq = { 0 };\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"User made LED thread InActive");\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"GPIO Can't be set/clear in Low power Mode");\r\nStatus = -EACCES;\r\nbreak;\r\n}\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(threadReq))\r\nreturn -EINVAL;\r\nif (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nif(Adapter->LEDInfo.led_thread_running)\r\n{\r\nif(threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Activating thread req");\r\nAdapter->DriverState = LED_THREAD_ACTIVE;\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"DeActivating Thread req.....");\r\nAdapter->DriverState = LED_THREAD_INACTIVE;\r\n}\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\n}\r\nbreak;\r\ncase IOCTL_BCM_GPIO_STATUS_REQUEST:\r\n{\r\nULONG uiBit = 0;\r\nUCHAR ucRead[4];\r\nGPIO_INFO gpio_info = {0};\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\nreturn -EACCES;\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(gpio_info))\r\nreturn -EINVAL;\r\nif(copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nuiBit = gpio_info.uiGpioNumber;\r\nStatus = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,\r\n(PUINT)ucRead, sizeof(UINT));\r\nif(Status != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "RDM Failed\n");\r\nreturn Status;\r\n}\r\n}\r\nbreak;\r\ncase IOCTL_BCM_GPIO_MULTI_REQUEST:\r\n{\r\nUCHAR ucResetValue[4];\r\nGPIO_MULTI_INFO gpio_multi_info[MAX_IDX];\r\nPGPIO_MULTI_INFO pgpio_multi_info = (PGPIO_MULTI_INFO)gpio_multi_info;\r\nmemset( pgpio_multi_info, 0, MAX_IDX * sizeof( GPIO_MULTI_INFO));\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\nreturn -EINVAL;\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(gpio_multi_info))\r\nreturn -EINVAL;\r\nif (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nif(IsReqGpioIsLedInNVM(Adapter,pgpio_multi_info[WIMAX_IDX].uiGPIOMask)== FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!",pgpio_multi_info[WIMAX_IDX].uiGPIOMask,Adapter->gpioBitMap);\r\nStatus = -EINVAL;\r\nbreak;\r\n}\r\nif( ( pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &\r\n( pgpio_multi_info[WIMAX_IDX].uiGPIOCommand))\r\n{\r\n*(UINT*) ucResetValue = pgpio_multi_info[WIMAX_IDX].uiGPIOMask &\r\npgpio_multi_info[WIMAX_IDX].uiGPIOCommand &\r\npgpio_multi_info[WIMAX_IDX].uiGPIOValue;\r\nif( *(UINT*) ucResetValue)\r\nStatus = wrmaltWithLock( Adapter, BCM_GPIO_OUTPUT_SET_REG , (PUINT) ucResetValue, sizeof(ULONG));\r\nif( Status != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_PRINTK, 0, 0,"WRM to BCM_GPIO_OUTPUT_SET_REG Failed.");\r\nreturn Status;\r\n}\r\n*(UINT*) ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &\r\npgpio_multi_info[WIMAX_IDX].uiGPIOCommand &\r\n( ~( pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));\r\nif( *(UINT*) ucResetValue)\r\nStatus = wrmaltWithLock( Adapter, BCM_GPIO_OUTPUT_CLR_REG , (PUINT) ucResetValue, sizeof(ULONG));\r\nif( Status != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_PRINTK, 0, 0,"WRM to BCM_GPIO_OUTPUT_CLR_REG Failed." );\r\nreturn Status;\r\n}\r\n}\r\nif( pgpio_multi_info[WIMAX_IDX].uiGPIOMask)\r\n{\r\nStatus = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\r\nif(Status != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_PRINTK, 0, 0,"RDM to GPIO_PIN_STATE_REGISTER Failed.");\r\nreturn Status;\r\n}\r\npgpio_multi_info[WIMAX_IDX].uiGPIOValue = ( *(UINT*)ucResetValue &\r\npgpio_multi_info[WIMAX_IDX].uiGPIOMask);\r\n}\r\nStatus = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Failed while copying Content to IOBufer for user space err:%d",Status);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase IOCTL_BCM_GPIO_MODE_REQUEST:\r\n{\r\nUCHAR ucResetValue[4];\r\nGPIO_MULTI_MODE gpio_multi_mode[MAX_IDX];\r\nPGPIO_MULTI_MODE pgpio_multi_mode = ( PGPIO_MULTI_MODE) gpio_multi_mode;\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\nreturn -EINVAL;\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (IoBuffer.InputLength > sizeof(gpio_multi_mode))\r\nreturn -EINVAL;\r\nif (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nStatus = rdmaltWithLock( Adapter, ( UINT) GPIO_MODE_REGISTER, ( PUINT) ucResetValue, sizeof( UINT));\r\nif( STATUS_SUCCESS != Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Read of GPIO_MODE_REGISTER failed");\r\nreturn Status;\r\n}\r\nif(IsReqGpioIsLedInNVM(Adapter,pgpio_multi_mode[WIMAX_IDX].uiGPIOMask)== FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!",pgpio_multi_mode[WIMAX_IDX].uiGPIOMask,Adapter->gpioBitMap);\r\nStatus = -EINVAL;\r\nbreak;\r\n}\r\nif( pgpio_multi_mode[WIMAX_IDX].uiGPIOMask)\r\n{\r\n*( UINT*) ucResetValue |= ( pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &\r\npgpio_multi_mode[WIMAX_IDX].uiGPIOMask);\r\n*( UINT*) ucResetValue &= ~( ( ~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &\r\npgpio_multi_mode[WIMAX_IDX].uiGPIOMask);\r\npgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT*)ucResetValue;\r\nStatus = wrmaltWithLock( Adapter, GPIO_MODE_REGISTER , ( PUINT) ucResetValue, sizeof( ULONG));\r\nif( Status == STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "WRM to GPIO_MODE_REGISTER Done");\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_PRINTK, 0, 0,"WRM to GPIO_MODE_REGISTER Failed");\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\npgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *( UINT*) ucResetValue;\r\n}\r\nStatus = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Failed while copying Content to IOBufer for user space err:%d",Status);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase IOCTL_MAC_ADDR_REQ:\r\ncase IOCTL_LINK_REQ:\r\ncase IOCTL_CM_REQUEST:\r\ncase IOCTL_SS_INFO_REQ:\r\ncase IOCTL_SEND_CONTROL_MESSAGE:\r\ncase IOCTL_IDLE_REQ:\r\n{\r\nPVOID pvBuffer=NULL;\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\npvBuffer = kmalloc(IoBuffer.InputLength, GFP_KERNEL);\r\nif(!pvBuffer)\r\nreturn -ENOMEM;\r\nif(copy_from_user(pvBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\n{\r\nStatus = -EFAULT;\r\nkfree(pvBuffer);\r\nbreak;\r\n}\r\ndown(&Adapter->LowPowerModeSync);\r\nStatus = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,\r\n!Adapter->bPreparingForLowPowerMode,\r\n(1 * HZ));\r\nif(Status == -ERESTARTSYS)\r\ngoto cntrlEnd;\r\nif(Adapter->bPreparingForLowPowerMode)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Preparing Idle Mode is still True - Hence Rejecting control message\n");\r\nStatus = STATUS_FAILURE ;\r\ngoto cntrlEnd ;\r\n}\r\nStatus = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);\r\ncntrlEnd:\r\nup(&Adapter->LowPowerModeSync);\r\nkfree(pvBuffer);\r\nbreak;\r\n}\r\ncase IOCTL_BCM_BUFFER_DOWNLOAD_START:\r\n{\r\nINT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock) ;\r\nif(NVMAccess)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, " IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n");\r\nreturn -EACCES;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Starting the firmware download PID =0x%x!!!!\n", current->pid);\r\nif(!down_trylock(&Adapter->fw_download_sema))\r\n{\r\nAdapter->bBinDownloaded=FALSE;\r\nAdapter->fw_download_process_pid=current->pid;\r\nAdapter->bCfgDownloaded=FALSE;\r\nAdapter->fw_download_done=FALSE;\r\nnetif_carrier_off(Adapter->dev);\r\nnetif_stop_queue(Adapter->dev);\r\nStatus = reset_card_proc(Adapter);\r\nif(Status)\r\n{\r\npr_err(PFX "%s: reset_card_proc Failed!\n", Adapter->dev->name);\r\nup(&Adapter->fw_download_sema);\r\nup(&Adapter->NVMRdmWrmLock);\r\nbreak;\r\n}\r\nmdelay(10);\r\n}\r\nelse\r\n{\r\nStatus = -EBUSY;\r\n}\r\nup(&Adapter->NVMRdmWrmLock);\r\nbreak;\r\n}\r\ncase IOCTL_BCM_BUFFER_DOWNLOAD:\r\n{\r\nFIRMWARE_INFO *psFwInfo = NULL;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Starting the firmware download PID =0x%x!!!!\n", current->pid);\r\ndo{\r\nif(!down_trylock(&Adapter->fw_download_sema))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Invalid way to download buffer. Use Start and then call this!!!\n");\r\nStatus=-EINVAL;\r\nbreak;\r\n}\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Length for FW DLD is : %lx\n",\r\nIoBuffer.InputLength);\r\nif (IoBuffer.InputLength > sizeof(FIRMWARE_INFO))\r\nreturn -EINVAL;\r\npsFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);\r\nif(!psFwInfo)\r\nreturn -ENOMEM;\r\nif(copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\nreturn -EFAULT;\r\nif(!psFwInfo->pvMappedFirmwareAddress ||\r\n(psFwInfo->u32FirmwareLength == 0))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Something else is wrong %lu\n",\r\npsFwInfo->u32FirmwareLength);\r\nStatus = -EINVAL;\r\nbreak;\r\n}\r\nStatus = bcm_ioctl_fw_download(Adapter, psFwInfo);\r\nif(Status != STATUS_SUCCESS)\r\n{\r\nif(psFwInfo->u32StartingAddress==CONFIG_BEGIN_ADDR)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "IOCTL: Configuration File Upload Failed\n");\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "IOCTL: Firmware File Upload Failed\n");\r\n}\r\nif(Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY)\r\n{\r\nAdapter->DriverState = DRIVER_INIT;\r\nAdapter->LEDInfo.bLedInitDone = FALSE;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\n}\r\nbreak ;\r\n}while(0);\r\nif(Status != STATUS_SUCCESS)\r\nup(&Adapter->fw_download_sema);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, "IOCTL: Firmware File Uploaded\n");\r\nkfree(psFwInfo);\r\nbreak;\r\n}\r\ncase IOCTL_BCM_BUFFER_DOWNLOAD_STOP:\r\n{\r\nINT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);\r\nif(NVMAccess)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, " FW download blocked as EEPROM Read/Write is in progress\n");\r\nup(&Adapter->fw_download_sema);\r\nreturn -EACCES;\r\n}\r\nif(down_trylock(&Adapter->fw_download_sema))\r\n{\r\nAdapter->bBinDownloaded=TRUE;\r\nAdapter->bCfgDownloaded=TRUE;\r\natomic_set(&Adapter->CurrNumFreeTxDesc, 0);\r\nAdapter->CurrNumRecvDescs=0;\r\nAdapter->downloadDDR = 0;\r\nStatus = run_card_proc(Adapter);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Firm Download Failed\n");\r\nup(&Adapter->fw_download_sema);\r\nup(&Adapter->NVMRdmWrmLock);\r\nbreak;\r\n}\r\nelse\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Firm Download Over...\n");\r\nmdelay(10);\r\nif(StartInterruptUrb((PS_INTERFACE_ADAPTER)Adapter->pvInterfaceAdapter))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Unable to send interrupt...\n");\r\n}\r\ntimeout = 5*HZ;\r\nAdapter->waiting_to_fw_download_done = FALSE;\r\nwait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,\r\nAdapter->waiting_to_fw_download_done, timeout);\r\nAdapter->fw_download_process_pid=INVALID_PID;\r\nAdapter->fw_download_done=TRUE;\r\natomic_set(&Adapter->CurrNumFreeTxDesc, 0);\r\nAdapter->CurrNumRecvDescs = 0;\r\nAdapter->PrevNumRecvDescs = 0;\r\natomic_set(&Adapter->cntrlpktCnt,0);\r\nAdapter->LinkUpStatus = 0;\r\nAdapter->LinkStatus = 0;\r\nif(Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY)\r\n{\r\nAdapter->DriverState = FW_DOWNLOAD_DONE;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\nif(!timeout)\r\n{\r\nStatus = -ENODEV;\r\n}\r\n}\r\nelse\r\n{\r\nStatus = -EINVAL;\r\n}\r\nup(&Adapter->fw_download_sema);\r\nup(&Adapter->NVMRdmWrmLock);\r\nbreak;\r\n}\r\ncase IOCTL_BE_BUCKET_SIZE:\r\nStatus = 0;\r\nif (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))\r\nStatus = -EFAULT;\r\nbreak;\r\ncase IOCTL_RTPS_BUCKET_SIZE:\r\nStatus = 0;\r\nif (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))\r\nStatus = -EFAULT;\r\nbreak;\r\ncase IOCTL_CHIP_RESET:\r\n{\r\nINT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);\r\nif(NVMAccess)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, " IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n");\r\nreturn -EACCES;\r\n}\r\ndown(&Adapter->RxAppControlQueuelock);\r\nStatus = reset_card_proc(Adapter);\r\nflushAllAppQ();\r\nup(&Adapter->RxAppControlQueuelock);\r\nup(&Adapter->NVMRdmWrmLock);\r\nResetCounters(Adapter);\r\nbreak;\r\n}\r\ncase IOCTL_QOS_THRESHOLD:\r\n{\r\nUSHORT uiLoopIndex;\r\nStatus = 0;\r\nfor (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {\r\nif (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,\r\n(unsigned long __user *)arg)) {\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase IOCTL_DUMP_PACKET_INFO:\r\nDumpPackInfo(Adapter);\r\nDumpPhsRules(&Adapter->stBCMPhsContext);\r\nStatus = STATUS_SUCCESS;\r\nbreak;\r\ncase IOCTL_GET_PACK_INFO:\r\nif(copy_to_user(argp, &Adapter->PackInfo, sizeof(PacketInfo)*NO_OF_QUEUES))\r\nreturn -EFAULT;\r\nStatus = STATUS_SUCCESS;\r\nbreak;\r\ncase IOCTL_BCM_SWITCH_TRANSFER_MODE:\r\n{\r\nUINT uiData = 0;\r\nif(copy_from_user(&uiData, argp, sizeof(UINT)))\r\nreturn -EFAULT;\r\nif(uiData)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\n");\r\nAdapter->TransferMode = ETH_PACKET_TUNNELING_MODE;\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\n");\r\nAdapter->TransferMode = IP_PACKET_ONLY_MODE;\r\n}\r\nStatus = STATUS_SUCCESS;\r\nbreak;\r\n}\r\ncase IOCTL_BCM_GET_DRIVER_VERSION:\r\n{\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(copy_to_user(IoBuffer.OutputBuffer, VER_FILEVERSION_STR, IoBuffer.OutputLength))\r\nreturn -EFAULT;\r\nStatus = STATUS_SUCCESS;\r\nbreak;\r\n}\r\ncase IOCTL_BCM_GET_CURRENT_STATUS:\r\n{\r\nLINK_STATE link_state;\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "copy_from_user failed..\n");\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\nif (IoBuffer.OutputLength != sizeof(link_state)) {\r\nStatus = -EINVAL;\r\nbreak;\r\n}\r\nmemset(&link_state, 0, sizeof(link_state));\r\nlink_state.bIdleMode = Adapter->IdleMode;\r\nlink_state.bShutdownMode = Adapter->bShutStatus;\r\nlink_state.ucLinkStatus = Adapter->LinkStatus;\r\nif (copy_to_user(IoBuffer.OutputBuffer, &link_state,\r\nmin_t(size_t, sizeof(link_state), IoBuffer.OutputLength)))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Copy_to_user Failed..\n");\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\nStatus = STATUS_SUCCESS;\r\nbreak;\r\n}\r\ncase IOCTL_BCM_SET_MAC_TRACING:\r\n{\r\nUINT tracing_flag;\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(copy_from_user(&tracing_flag,IoBuffer.InputBuffer,sizeof(UINT)))\r\nreturn -EFAULT;\r\nif (tracing_flag)\r\nAdapter->pTarangs->MacTracingEnabled = TRUE;\r\nelse\r\nAdapter->pTarangs->MacTracingEnabled = FALSE;\r\nbreak;\r\n}\r\ncase IOCTL_BCM_GET_DSX_INDICATION:\r\n{\r\nULONG ulSFId=0;\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(IoBuffer.OutputLength < sizeof(stLocalSFAddIndicationAlt))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,\r\n"Mismatch req: %lx needed is =0x%zx!!!",\r\nIoBuffer.OutputLength, sizeof(stLocalSFAddIndicationAlt));\r\nreturn -EINVAL;\r\n}\r\nif(copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))\r\nreturn -EFAULT;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Get DSX Data SF ID is =%lx\n", ulSFId );\r\nget_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);\r\nStatus=STATUS_SUCCESS;\r\n}\r\nbreak;\r\ncase IOCTL_BCM_GET_HOST_MIBS:\r\n{\r\nPVOID temp_buff;\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(IoBuffer.OutputLength != sizeof(S_MIBS_HOST_STATS_MIBS))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,\r\n"Length Check failed %lu %zd\n",\r\nIoBuffer.OutputLength, sizeof(S_MIBS_HOST_STATS_MIBS));\r\nreturn -EINVAL;\r\n}\r\ntemp_buff = kzalloc(sizeof(S_MIBS_HOST_STATS_MIBS), GFP_KERNEL);\r\nif(!temp_buff)\r\nreturn STATUS_FAILURE;\r\nStatus = ProcessGetHostMibs(Adapter, temp_buff);\r\nGetDroppedAppCntrlPktMibs(temp_buff, pTarang);\r\nif (Status != STATUS_FAILURE)\r\nif(copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(S_MIBS_HOST_STATS_MIBS)))\r\nStatus = -EFAULT;\r\nkfree(temp_buff);\r\nbreak;\r\n}\r\ncase IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:\r\nif((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE==Adapter->IdleMode))\r\n{\r\nAdapter->usIdleModePattern = ABORT_IDLE_MODE;\r\nAdapter->bWakeUpDevice = TRUE;\r\nwake_up(&Adapter->process_rx_cntrlpkt);\r\n}\r\nStatus = STATUS_SUCCESS;\r\nbreak;\r\ncase IOCTL_BCM_BULK_WRM:\r\n{\r\nPBULKWRM_BUFFER pBulkBuffer;\r\nUINT uiTempVar=0;\r\nPCHAR pvBuffer = NULL;\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, "Device in Idle/Shutdown Mode, Blocking Wrms\n");\r\nStatus = -EACCES;\r\nbreak;\r\n}\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\npvBuffer = kmalloc(IoBuffer.InputLength, GFP_KERNEL);\r\nif(!pvBuffer)\r\nreturn -ENOMEM;\r\nif(copy_from_user(pvBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\r\n{\r\nkfree(pvBuffer);\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\npBulkBuffer = (PBULKWRM_BUFFER)pvBuffer;\r\nif(((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||\r\n((ULONG)pBulkBuffer->Register & 0x3))\r\n{\r\nkfree(pvBuffer);\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0,"WRM Done On invalid Address : %x Access Denied.\n",(int)pBulkBuffer->Register);\r\nStatus = -EINVAL;\r\nbreak;\r\n}\r\nuiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;\r\nif(!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE)\r\n&& ((uiTempVar == EEPROM_REJECT_REG_1)||\r\n(uiTempVar == EEPROM_REJECT_REG_2) ||\r\n(uiTempVar == EEPROM_REJECT_REG_3) ||\r\n(uiTempVar == EEPROM_REJECT_REG_4)) &&\r\n(cmd == IOCTL_BCM_REGISTER_WRITE))\r\n{\r\nkfree(pvBuffer);\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0,"EEPROM Access Denied, not in VSG Mode\n");\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\nif(pBulkBuffer->SwapEndian == FALSE)\r\nStatus = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));\r\nelse\r\nStatus = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));\r\nif(Status != STATUS_SUCCESS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "WRM Failed\n");\r\n}\r\nkfree(pvBuffer);\r\nbreak;\r\n}\r\ncase IOCTL_BCM_GET_NVM_SIZE:\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH ) {\r\nif(copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))\r\nreturn -EFAULT;\r\n}\r\nStatus = STATUS_SUCCESS ;\r\nbreak;\r\ncase IOCTL_BCM_CAL_INIT :\r\n{\r\nUINT uiSectorSize = 0 ;\r\nif(Adapter->eNVMType == NVM_FLASH)\r\n{\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))\r\nreturn -EFAULT;\r\nif((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE))\r\n{\r\nif (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,\r\nsizeof(UINT)))\r\nreturn -EFAULT;\r\n}\r\nelse\r\n{\r\nif(IsFlash2x(Adapter))\r\n{\r\nif (copy_to_user(IoBuffer.OutputBuffer,\r\n&Adapter->uiSectorSize ,\r\nsizeof(UINT)))\r\nreturn -EFAULT;\r\n}\r\nelse\r\n{\r\nif((TRUE == Adapter->bShutStatus) ||\r\n(TRUE == Adapter->IdleMode))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Device is in Idle/Shutdown Mode\n");\r\nreturn -EACCES;\r\n}\r\nAdapter->uiSectorSize = uiSectorSize ;\r\nBcmUpdateSectorSize(Adapter,Adapter->uiSectorSize);\r\n}\r\n}\r\nStatus = STATUS_SUCCESS ;\r\n}\r\nelse\r\n{\r\nStatus = STATUS_FAILURE;\r\n}\r\n}\r\nbreak;\r\ncase IOCTL_BCM_SET_DEBUG :\r\n#ifdef DEBUG\r\n{\r\nUSER_BCM_DBG_STATE sUserDebugState;\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "In SET_DEBUG ioctl\n");\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(USER_BCM_DBG_STATE)))\r\nreturn -EFAULT;\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, "IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x ",\r\nsUserDebugState.OnOff, sUserDebugState.Type);\r\nsUserDebugState.Subtype = 1 << sUserDebugState.Subtype;\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, "actual Subtype=0x%x\n", sUserDebugState.Subtype);\r\nAdapter->stDebugState.type |= sUserDebugState.Type;\r\nif (sUserDebugState.OnOff)\r\nAdapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;\r\nelse\r\nAdapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;\r\nBCM_SHOW_DEBUG_BITMAP(Adapter);\r\n}\r\n#endif\r\nbreak;\r\ncase IOCTL_BCM_NVM_READ:\r\ncase IOCTL_BCM_NVM_WRITE:\r\n{\r\nNVM_READWRITE stNVMReadWrite;\r\nPUCHAR pReadData = NULL;\r\nULONG ulDSDMagicNumInUsrBuff = 0;\r\nstruct timeval tv0, tv1;\r\nmemset(&tv0,0,sizeof(struct timeval));\r\nmemset(&tv1,0,sizeof(struct timeval));\r\nif((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0))\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,"The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\n");\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\nif(IsFlash2x(Adapter))\r\n{\r\nif((Adapter->eActiveDSD != DSD0) &&\r\n(Adapter->eActiveDSD != DSD1) &&\r\n(Adapter->eActiveDSD != DSD2))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"No DSD is active..hence NVM Command is blocked");\r\nreturn STATUS_FAILURE ;\r\n}\r\n}\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(copy_from_user(&stNVMReadWrite,\r\n(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,\r\nsizeof(NVM_READWRITE)))\r\nreturn -EFAULT;\r\nif((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) > Adapter->uiNVMDSDSize)\r\n{\r\nStatus = STATUS_FAILURE;\r\nbreak;\r\n}\r\npReadData = kzalloc(stNVMReadWrite.uiNumBytes, GFP_KERNEL);\r\nif(!pReadData)\r\nreturn -ENOMEM;\r\nif(copy_from_user(pReadData, stNVMReadWrite.pBuffer,\r\nstNVMReadWrite.uiNumBytes))\r\n{\r\nStatus = -EFAULT;\r\nkfree(pReadData);\r\nbreak;\r\n}\r\ndo_gettimeofday(&tv0);\r\nif(IOCTL_BCM_NVM_READ == cmd)\r\n{\r\ndown(&Adapter->NVMRdmWrmLock);\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Device is in Idle/Shutdown Mode\n");\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pReadData);\r\nreturn -EACCES;\r\n}\r\nStatus = BeceemNVMRead(Adapter, (PUINT)pReadData,\r\nstNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);\r\nup(&Adapter->NVMRdmWrmLock);\r\nif(Status != STATUS_SUCCESS)\r\n{\r\nkfree(pReadData);\r\nreturn Status;\r\n}\r\nif(copy_to_user(stNVMReadWrite.pBuffer,pReadData, stNVMReadWrite.uiNumBytes))\r\n{\r\nkfree(pReadData);\r\nStatus = -EFAULT;\r\n}\r\n}\r\nelse\r\n{\r\ndown(&Adapter->NVMRdmWrmLock);\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Device is in Idle/Shutdown Mode\n");\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pReadData);\r\nreturn -EACCES;\r\n}\r\nAdapter->bHeaderChangeAllowed = TRUE ;\r\nif(IsFlash2x(Adapter))\r\n{\r\nStatus = BcmFlash2xCorruptSig(Adapter,Adapter->eActiveDSD);\r\nif(Status != STATUS_SUCCESS)\r\n{\r\nif(( (stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize ) ||\r\n(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"DSD Sig is present neither in Flash nor User provided Input..");\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pReadData);\r\nreturn Status;\r\n}\r\nulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));\r\nif(ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"DSD Sig is present neither in Flash nor User provided Input..");\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pReadData);\r\nreturn Status;\r\n}\r\n}\r\n}\r\nStatus = BeceemNVMWrite(Adapter, (PUINT )pReadData,\r\nstNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);\r\nif(IsFlash2x(Adapter))\r\nBcmFlash2xWriteSig(Adapter,Adapter->eActiveDSD);\r\nAdapter->bHeaderChangeAllowed = FALSE ;\r\nup(&Adapter->NVMRdmWrmLock);\r\nif(Status != STATUS_SUCCESS)\r\n{\r\nkfree(pReadData);\r\nreturn Status;\r\n}\r\n}\r\ndo_gettimeofday(&tv1);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, " timetaken by Write/read :%ld msec\n",(tv1.tv_sec - tv0.tv_sec)*1000 +(tv1.tv_usec - tv0.tv_usec)/1000);\r\nkfree(pReadData);\r\nStatus = STATUS_SUCCESS;\r\n}\r\nbreak;\r\ncase IOCTL_BCM_FLASH2X_SECTION_READ :\r\n{\r\nFLASH2X_READWRITE sFlash2xRead = {0};\r\nPUCHAR pReadBuff = NULL ;\r\nUINT NOB = 0;\r\nUINT BuffSize = 0;\r\nUINT ReadBytes = 0;\r\nUINT ReadOffset = 0;\r\nvoid __user *OutPutBuff;\r\nif(IsFlash2x(Adapter) != TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Does not have 2.x map");\r\nreturn -EINVAL;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "IOCTL_BCM_FLASH2X_SECTION_READ Called");\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer,sizeof(FLASH2X_READWRITE)))\r\nreturn -EFAULT;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\nsFlash2xRead.Section :%x" ,sFlash2xRead.Section);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\nsFlash2xRead.offset :%x" ,sFlash2xRead.offset);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\nsFlash2xRead.numOfBytes :%x" ,sFlash2xRead.numOfBytes);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\nsFlash2xRead.bVerify :%x\n" ,sFlash2xRead.bVerify);\r\nif(validateFlash2xReadWrite(Adapter,&sFlash2xRead) == FALSE)\r\nreturn STATUS_FAILURE ;\r\nNOB = sFlash2xRead.numOfBytes;\r\nif(NOB > Adapter->uiSectorSize )\r\nBuffSize = Adapter->uiSectorSize;\r\nelse\r\nBuffSize = NOB ;\r\nReadOffset = sFlash2xRead.offset ;\r\nOutPutBuff = IoBuffer.OutputBuffer;\r\npReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);\r\nif(pReadBuff == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Memory allocation failed for Flash 2.x Read Structure");\r\nreturn -ENOMEM;\r\n}\r\ndown(&Adapter->NVMRdmWrmLock);\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Device is in Idle/Shutdown Mode\n");\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pReadBuff);\r\nreturn -EACCES;\r\n}\r\nwhile(NOB)\r\n{\r\nif(NOB > Adapter->uiSectorSize )\r\nReadBytes = Adapter->uiSectorSize;\r\nelse\r\nReadBytes = NOB;\r\nStatus = BcmFlash2xBulkRead(Adapter,(PUINT)pReadBuff,sFlash2xRead.Section,ReadOffset,ReadBytes);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Flash 2x read err with Status :%d", Status);\r\nbreak ;\r\n}\r\nBCM_DEBUG_PRINT_BUFFER(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,pReadBuff, ReadBytes);\r\nStatus = copy_to_user(OutPutBuff, pReadBuff,ReadBytes);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Copy to use failed with status :%d", Status);\r\nbreak;\r\n}\r\nNOB = NOB - ReadBytes;\r\nif(NOB)\r\n{\r\nReadOffset = ReadOffset + ReadBytes ;\r\nOutPutBuff = OutPutBuff + ReadBytes ;\r\n}\r\n}\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pReadBuff);\r\n}\r\nbreak ;\r\ncase IOCTL_BCM_FLASH2X_SECTION_WRITE :\r\n{\r\nFLASH2X_READWRITE sFlash2xWrite = {0};\r\nPUCHAR pWriteBuff;\r\nvoid __user *InputAddr;\r\nUINT NOB = 0;\r\nUINT BuffSize = 0;\r\nUINT WriteOffset = 0;\r\nUINT WriteBytes = 0;\r\nif(IsFlash2x(Adapter) != TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Does not have 2.x map");\r\nreturn -EINVAL;\r\n}\r\nAdapter->bAllDSDWriteAllow = FALSE;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, " IOCTL_BCM_FLASH2X_SECTION_WRITE Called");\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(FLASH2X_READWRITE)))\r\nreturn -EFAULT;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\nsFlash2xRead.Section :%x" ,sFlash2xWrite.Section);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\nsFlash2xRead.offset :%d" ,sFlash2xWrite.offset);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\nsFlash2xRead.numOfBytes :%x" ,sFlash2xWrite.numOfBytes);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\nsFlash2xRead.bVerify :%x\n" ,sFlash2xWrite.bVerify);\r\nif((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) &&\r\n(sFlash2xWrite.Section != VSA2) )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Only VSA write is allowed");\r\nreturn -EINVAL;\r\n}\r\nif(validateFlash2xReadWrite(Adapter,&sFlash2xWrite) == FALSE)\r\nreturn STATUS_FAILURE ;\r\nInputAddr = sFlash2xWrite.pDataBuff;\r\nWriteOffset = sFlash2xWrite.offset ;\r\nNOB = sFlash2xWrite.numOfBytes;\r\nif(NOB > Adapter->uiSectorSize )\r\nBuffSize = Adapter->uiSectorSize;\r\nelse\r\nBuffSize = NOB ;\r\npWriteBuff = kmalloc(BuffSize, GFP_KERNEL);\r\nif(pWriteBuff == NULL)\r\nreturn -ENOMEM;\r\nWriteBytes = Adapter->uiSectorSize ;\r\nif(WriteOffset % Adapter->uiSectorSize)\r\nWriteBytes =Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);\r\nif(NOB < WriteBytes)\r\nWriteBytes = NOB;\r\ndown(&Adapter->NVMRdmWrmLock);\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Device is in Idle/Shutdown Mode\n");\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pWriteBuff);\r\nreturn -EACCES;\r\n}\r\nBcmFlash2xCorruptSig(Adapter,sFlash2xWrite.Section);\r\ndo\r\n{\r\nStatus = copy_from_user(pWriteBuff,InputAddr,WriteBytes);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Copy to user failed with status :%d", Status);\r\nbreak ;\r\n}\r\nBCM_DEBUG_PRINT_BUFFER(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,pWriteBuff,WriteBytes);\r\nStatus = BcmFlash2xBulkWrite(Adapter,(PUINT)pWriteBuff,sFlash2xWrite.Section,WriteOffset,WriteBytes,sFlash2xWrite.bVerify);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash 2x read err with Status :%d", Status);\r\nbreak ;\r\n}\r\nNOB = NOB - WriteBytes;\r\nif(NOB)\r\n{\r\nWriteOffset = WriteOffset + WriteBytes ;\r\nInputAddr = InputAddr + WriteBytes ;\r\nif(NOB > Adapter->uiSectorSize )\r\nWriteBytes = Adapter->uiSectorSize;\r\nelse\r\nWriteBytes = NOB;\r\n}\r\n} while(NOB > 0);\r\nBcmFlash2xWriteSig(Adapter,sFlash2xWrite.Section);\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pWriteBuff);\r\n}\r\nbreak ;\r\ncase IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP :\r\n{\r\nPFLASH2X_BITMAP psFlash2xBitMap;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called");\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(IoBuffer.OutputLength != sizeof(FLASH2X_BITMAP))\r\nreturn -EINVAL;\r\npsFlash2xBitMap = kzalloc(sizeof(FLASH2X_BITMAP), GFP_KERNEL);\r\nif(psFlash2xBitMap == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Memory is not available");\r\nreturn -ENOMEM ;\r\n}\r\ndown(&Adapter->NVMRdmWrmLock);\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Device is in Idle/Shutdown Mode\n");\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(psFlash2xBitMap);\r\nreturn -EACCES;\r\n}\r\nBcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);\r\nup(&Adapter->NVMRdmWrmLock);\r\nif (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(FLASH2X_BITMAP)))\r\nStatus = -EFAULT;\r\nkfree(psFlash2xBitMap);\r\n}\r\nbreak ;\r\ncase IOCTL_BCM_SET_ACTIVE_SECTION :\r\n{\r\nFLASH2X_SECTION_VAL eFlash2xSectionVal = 0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "IOCTL_BCM_SET_ACTIVE_SECTION Called");\r\nif(IsFlash2x(Adapter) != TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Does not have 2.x map");\r\nreturn -EINVAL;\r\n}\r\nStatus = copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Copy of IOCTL BUFFER failed");\r\nreturn Status;\r\n}\r\nStatus = copy_from_user(&eFlash2xSectionVal,IoBuffer.InputBuffer, sizeof(INT));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Copy of flash section val failed");\r\nreturn Status;\r\n}\r\ndown(&Adapter->NVMRdmWrmLock);\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Device is in Idle/Shutdown Mode\n");\r\nup(&Adapter->NVMRdmWrmLock);\r\nreturn -EACCES;\r\n}\r\nStatus = BcmSetActiveSection(Adapter,eFlash2xSectionVal);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Failed to make it's priority Highest. Status %d", Status);\r\n}\r\nup(&Adapter->NVMRdmWrmLock);\r\n}\r\nbreak ;\r\ncase IOCTL_BCM_IDENTIFY_ACTIVE_SECTION :\r\n{\r\nAdapter->bAllDSDWriteAllow = FALSE ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called");\r\nStatus = STATUS_SUCCESS ;\r\n}\r\nbreak ;\r\ncase IOCTL_BCM_COPY_SECTION :\r\n{\r\nFLASH2X_COPY_SECTION sCopySectStrut = {0};\r\nStatus = STATUS_SUCCESS;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "IOCTL_BCM_COPY_SECTION Called");\r\nAdapter->bAllDSDWriteAllow = FALSE ;\r\nif(IsFlash2x(Adapter) != TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Does not have 2.x map");\r\nreturn -EINVAL;\r\n}\r\nStatus = copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Copy of IOCTL BUFFER failed Status :%d", Status);\r\nreturn Status;\r\n}\r\nStatus = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(FLASH2X_COPY_SECTION));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Copy of Copy_Section_Struct failed with Status :%d", Status);\r\nreturn Status;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Source SEction :%x", sCopySectStrut.SrcSection);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Destination SEction :%x", sCopySectStrut.DstSection);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "offset :%x", sCopySectStrut.offset);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "NOB :%x", sCopySectStrut.numOfBytes);\r\nif(IsSectionExistInFlash(Adapter,sCopySectStrut.SrcSection) == FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Source Section<%x> does not exixt in Flash ", sCopySectStrut.SrcSection);\r\nreturn -EINVAL;\r\n}\r\nif(IsSectionExistInFlash(Adapter,sCopySectStrut.DstSection) == FALSE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Destinatio Section<%x> does not exixt in Flash ", sCopySectStrut.DstSection);\r\nreturn -EINVAL;\r\n}\r\nif(sCopySectStrut.SrcSection == sCopySectStrut.DstSection)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Source and Destination section should be different");\r\nreturn -EINVAL;\r\n}\r\ndown(&Adapter->NVMRdmWrmLock);\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Device is in Idle/Shutdown Mode\n");\r\nup(&Adapter->NVMRdmWrmLock);\r\nreturn -EACCES;\r\n}\r\nif(sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2)\r\n{\r\nif(IsNonCDLessDevice(Adapter))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Device is Non-CDLess hence won't have ISO !!");\r\nStatus = -EINVAL ;\r\n}\r\nelse if(sCopySectStrut.numOfBytes == 0)\r\n{\r\nStatus = BcmCopyISO(Adapter,sCopySectStrut);\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Partial Copy of ISO section is not Allowed..");\r\nStatus = STATUS_FAILURE ;\r\n}\r\nup(&Adapter->NVMRdmWrmLock);\r\nreturn Status;\r\n}\r\nStatus = BcmCopySection(Adapter, sCopySectStrut.SrcSection,\r\nsCopySectStrut.DstSection,sCopySectStrut.offset,sCopySectStrut.numOfBytes);\r\nup(&Adapter->NVMRdmWrmLock);\r\n}\r\nbreak ;\r\ncase IOCTL_BCM_GET_FLASH_CS_INFO :\r\n{\r\nStatus = STATUS_SUCCESS;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, " IOCTL_BCM_GET_FLASH_CS_INFO Called");\r\nStatus = copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Copy of IOCTL BUFFER failed");\r\nbreak;\r\n}\r\nif(Adapter->eNVMType != NVM_FLASH)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Connected device does not have flash");\r\nStatus = -EINVAL;\r\nbreak;\r\n}\r\nif(IsFlash2x(Adapter) == TRUE)\r\n{\r\nif(IoBuffer.OutputLength < sizeof(FLASH2X_CS_INFO))\r\nreturn -EINVAL;\r\nif (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(FLASH2X_CS_INFO)))\r\nreturn -EFAULT;\r\n}\r\nelse\r\n{\r\nif(IoBuffer.OutputLength < sizeof(FLASH_CS_INFO))\r\nreturn -EINVAL;\r\nif (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(FLASH_CS_INFO)))\r\nreturn -EFAULT;\r\n}\r\n}\r\nbreak ;\r\ncase IOCTL_BCM_SELECT_DSD :\r\n{\r\nUINT SectOfset = 0;\r\nFLASH2X_SECTION_VAL eFlash2xSectionVal;\r\neFlash2xSectionVal = NO_SECTION_VAL ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, " IOCTL_BCM_SELECT_DSD Called");\r\nif(IsFlash2x(Adapter) != TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash Does not have 2.x map");\r\nreturn -EINVAL;\r\n}\r\nStatus = copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Copy of IOCTL BUFFER failed");\r\nreturn Status;\r\n}\r\nStatus = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Copy of flash section val failed");\r\nreturn Status;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Read Section :%d", eFlash2xSectionVal);\r\nif((eFlash2xSectionVal != DSD0) &&\r\n(eFlash2xSectionVal != DSD1) &&\r\n(eFlash2xSectionVal != DSD2) )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Passed section<%x> is not DSD section", eFlash2xSectionVal);\r\nreturn STATUS_FAILURE ;\r\n}\r\nSectOfset= BcmGetSectionValStartOffset(Adapter,eFlash2xSectionVal);\r\nif(SectOfset == INVALID_OFFSET)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Provided Section val <%d> does not exixt in Flash 2.x", eFlash2xSectionVal);\r\nreturn -EINVAL;\r\n}\r\nAdapter->bAllDSDWriteAllow = TRUE ;\r\nAdapter->ulFlashCalStart = SectOfset ;\r\nAdapter->eActiveDSD = eFlash2xSectionVal;\r\n}\r\nStatus = STATUS_SUCCESS ;\r\nbreak;\r\ncase IOCTL_BCM_NVM_RAW_READ :\r\n{\r\nNVM_READWRITE stNVMRead;\r\nINT NOB ;\r\nINT BuffSize ;\r\nINT ReadOffset = 0;\r\nUINT ReadBytes = 0 ;\r\nPUCHAR pReadBuff;\r\nvoid __user *OutPutBuff;\r\nif(Adapter->eNVMType != NVM_FLASH)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"NVM TYPE is not Flash ");\r\nreturn -EINVAL ;\r\n}\r\nif(copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "copy_from_user 1 failed\n");\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\nif(copy_from_user(&stNVMRead, IoBuffer.OutputBuffer,sizeof(NVM_READWRITE)))\r\nreturn -EFAULT;\r\nNOB = stNVMRead.uiNumBytes;\r\nif(NOB > DEFAULT_BUFF_SIZE)\r\nBuffSize = DEFAULT_BUFF_SIZE;\r\nelse\r\nBuffSize = NOB ;\r\nReadOffset = stNVMRead.uiOffset;\r\nOutPutBuff = stNVMRead.pBuffer;\r\npReadBuff = kzalloc(BuffSize , GFP_KERNEL);\r\nif(pReadBuff == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Memory allocation failed for Flash 2.x Read Structure");\r\nStatus = -ENOMEM;\r\nbreak;\r\n}\r\ndown(&Adapter->NVMRdmWrmLock);\r\nif((Adapter->IdleMode == TRUE) ||\r\n(Adapter->bShutStatus ==TRUE) ||\r\n(Adapter->bPreparingForLowPowerMode ==TRUE))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Device is in Idle/Shutdown Mode\n");\r\nkfree(pReadBuff);\r\nup(&Adapter->NVMRdmWrmLock);\r\nreturn -EACCES;\r\n}\r\nAdapter->bFlashRawRead = TRUE ;\r\nwhile(NOB)\r\n{\r\nif(NOB > DEFAULT_BUFF_SIZE )\r\nReadBytes = DEFAULT_BUFF_SIZE;\r\nelse\r\nReadBytes = NOB;\r\nStatus = BeceemNVMRead(Adapter,(PUINT)pReadBuff,ReadOffset,ReadBytes);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Flash 2x read err with Status :%d", Status);\r\nbreak;\r\n}\r\nBCM_DEBUG_PRINT_BUFFER(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,pReadBuff,ReadBytes);\r\nStatus = copy_to_user(OutPutBuff, pReadBuff,ReadBytes);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Copy to use failed with status :%d", Status);\r\nbreak;\r\n}\r\nNOB = NOB - ReadBytes;\r\nif(NOB)\r\n{\r\nReadOffset = ReadOffset + ReadBytes ;\r\nOutPutBuff = OutPutBuff + ReadBytes ;\r\n}\r\n}\r\nAdapter->bFlashRawRead = FALSE ;\r\nup(&Adapter->NVMRdmWrmLock);\r\nkfree(pReadBuff);\r\nbreak ;\r\n}\r\ncase IOCTL_BCM_CNTRLMSG_MASK:\r\n{\r\nULONG RxCntrlMsgBitMask = 0 ;\r\nStatus = copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER));\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"copy of Ioctl buffer is failed from user space");\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\nif (IoBuffer.InputLength != sizeof(unsigned long)) {\r\nStatus = -EINVAL;\r\nbreak;\r\n}\r\nStatus = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);\r\nif(Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"copy of control bit mask failed from user space");\r\nStatus = -EFAULT;\r\nbreak;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"\n Got user defined cntrl msg bit mask :%lx", RxCntrlMsgBitMask);\r\npTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask ;\r\n}\r\nbreak;\r\ncase IOCTL_BCM_GET_DEVICE_DRIVER_INFO:\r\n{\r\nDEVICE_DRIVER_INFO DevInfo;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n");\r\nDevInfo.MaxRDMBufferSize = BUFFER_4K;\r\nDevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;\r\nDevInfo.u32RxAlignmentCorrection = 0;\r\nDevInfo.u32NVMType = Adapter->eNVMType;\r\nDevInfo.u32InterfaceType = BCM_USB;\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(IoBuffer.OutputLength < sizeof(DevInfo))\r\nreturn -EINVAL;\r\nif (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))\r\nreturn -EFAULT;\r\n}\r\nbreak ;\r\ncase IOCTL_BCM_TIME_SINCE_NET_ENTRY:\r\n{\r\nST_TIME_ELAPSED stTimeElapsedSinceNetEntry = {0};\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"IOCTL_BCM_TIME_SINCE_NET_ENTRY called");\r\nif (copy_from_user(&IoBuffer, argp, sizeof(IOCTL_BUFFER)))\r\nreturn -EFAULT;\r\nif(IoBuffer.OutputLength < sizeof(ST_TIME_ELAPSED))\r\nreturn -EINVAL;\r\nstTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;\r\nif (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(ST_TIME_ELAPSED)))\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ncase IOCTL_CLOSE_NOTIFICATION:\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,"IOCTL_CLOSE_NOTIFICATION");\r\nbreak;\r\ndefault:\r\npr_info(DRV_NAME ": unknown ioctl cmd=%#x\n", cmd);\r\nStatus = STATUS_FAILURE;\r\nbreak;\r\n}\r\nreturn Status;\r\n}\r\nint register_control_device_interface(PMINI_ADAPTER Adapter)\r\n{\r\nif (Adapter->major > 0)\r\nreturn Adapter->major;\r\nAdapter->major = register_chrdev(0, DEV_NAME, &bcm_fops);\r\nif (Adapter->major < 0) {\r\npr_err(DRV_NAME ": could not created character device\n");\r\nreturn Adapter->major;\r\n}\r\nAdapter->pstCreatedClassDevice = device_create(bcm_class, NULL,\r\nMKDEV(Adapter->major, 0),\r\nAdapter, DEV_NAME);\r\nif (IS_ERR(Adapter->pstCreatedClassDevice)) {\r\npr_err(DRV_NAME ": class device create failed\n");\r\nunregister_chrdev(Adapter->major, DEV_NAME);\r\nreturn PTR_ERR(Adapter->pstCreatedClassDevice);\r\n}\r\nreturn 0;\r\n}\r\nvoid unregister_control_device_interface(PMINI_ADAPTER Adapter)\r\n{\r\nif (Adapter->major > 0) {\r\ndevice_destroy(bcm_class, MKDEV(Adapter->major, 0));\r\nunregister_chrdev(Adapter->major, DEV_NAME);\r\n}\r\n}
