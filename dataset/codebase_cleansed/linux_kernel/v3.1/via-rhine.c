static inline u32 get_intr_status(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu32 intr_status;\r\nintr_status = ioread16(ioaddr + IntrStatus);\r\nif (rp->quirks & rqStatusWBRace)\r\nintr_status |= ioread8(ioaddr + IntrStatus2) << 16;\r\nreturn intr_status;\r\n}\r\nstatic void rhine_power_init(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu16 wolstat;\r\nif (rp->quirks & rqWOL) {\r\niowrite8(ioread8(ioaddr + StickyHW) & 0xFC, ioaddr + StickyHW);\r\niowrite8(0x80, ioaddr + WOLcgClr);\r\niowrite8(0xFF, ioaddr + WOLcrClr);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x03, ioaddr + WOLcrClr1);\r\nwolstat = ioread8(ioaddr + PwrcsrSet);\r\nif (rp->quirks & rq6patterns)\r\nwolstat |= (ioread8(ioaddr + PwrcsrSet1) & 0x03) << 8;\r\niowrite8(0xFF, ioaddr + PwrcsrClr);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x03, ioaddr + PwrcsrClr1);\r\nif (wolstat) {\r\nchar *reason;\r\nswitch (wolstat) {\r\ncase WOLmagic:\r\nreason = "Magic packet";\r\nbreak;\r\ncase WOLlnkon:\r\nreason = "Link went up";\r\nbreak;\r\ncase WOLlnkoff:\r\nreason = "Link went down";\r\nbreak;\r\ncase WOLucast:\r\nreason = "Unicast packet";\r\nbreak;\r\ncase WOLbmcast:\r\nreason = "Multicast/broadcast packet";\r\nbreak;\r\ndefault:\r\nreason = "Unknown";\r\n}\r\nnetdev_info(dev, "Woke system up. Reason: %s\n",\r\nreason);\r\n}\r\n}\r\n}\r\nstatic void rhine_chip_reset(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\niowrite8(Cmd1Reset, ioaddr + ChipCmd1);\r\nIOSYNC;\r\nif (ioread8(ioaddr + ChipCmd1) & Cmd1Reset) {\r\nnetdev_info(dev, "Reset not complete yet. Trying harder.\n");\r\nif (rp->quirks & rqForceReset)\r\niowrite8(0x40, ioaddr + MiscCmd);\r\nRHINE_WAIT_FOR(!(ioread8(ioaddr + ChipCmd1) & Cmd1Reset));\r\n}\r\nif (debug > 1)\r\nnetdev_info(dev, "Reset %s\n",\r\n(ioread8(ioaddr + ChipCmd1) & Cmd1Reset) ?\r\n"failed" : "succeeded");\r\n}\r\nstatic void enable_mmio(long pioaddr, u32 quirks)\r\n{\r\nint n;\r\nif (quirks & rqRhineI) {\r\nn = inb(pioaddr + ConfigA) | 0x20;\r\noutb(n, pioaddr + ConfigA);\r\n} else {\r\nn = inb(pioaddr + ConfigD) | 0x80;\r\noutb(n, pioaddr + ConfigD);\r\n}\r\n}\r\nstatic void __devinit rhine_reload_eeprom(long pioaddr, struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\noutb(0x20, pioaddr + MACRegEEcsr);\r\nRHINE_WAIT_FOR(!(inb(pioaddr + MACRegEEcsr) & 0x20));\r\n#ifdef USE_MMIO\r\nenable_mmio(pioaddr, rp->quirks);\r\n#endif\r\nif (rp->quirks & rqWOL)\r\niowrite8(ioread8(ioaddr + ConfigA) & 0xFC, ioaddr + ConfigA);\r\n}\r\nstatic void rhine_poll(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nrhine_interrupt(dev->irq, (void *)dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int rhine_napipoll(struct napi_struct *napi, int budget)\r\n{\r\nstruct rhine_private *rp = container_of(napi, struct rhine_private, napi);\r\nstruct net_device *dev = rp->dev;\r\nvoid __iomem *ioaddr = rp->base;\r\nint work_done;\r\nwork_done = rhine_rx(dev, budget);\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\niowrite16(IntrRxDone | IntrRxErr | IntrRxEmpty| IntrRxOverflow |\r\nIntrRxDropped | IntrRxNoBuf | IntrTxAborted |\r\nIntrTxDone | IntrTxError | IntrTxUnderrun |\r\nIntrPCIErr | IntrStatsMax | IntrLinkChange,\r\nioaddr + IntrEnable);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void __devinit rhine_hw_init(struct net_device *dev, long pioaddr)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nrhine_chip_reset(dev);\r\nif (rp->quirks & rqRhineI)\r\nmsleep(5);\r\nrhine_reload_eeprom(pioaddr, dev);\r\n}\r\nstatic int __devinit rhine_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct rhine_private *rp;\r\nint i, rc;\r\nu32 quirks;\r\nlong pioaddr;\r\nlong memaddr;\r\nvoid __iomem *ioaddr;\r\nint io_size, phy_id;\r\nconst char *name;\r\n#ifdef USE_MMIO\r\nint bar = 1;\r\n#else\r\nint bar = 0;\r\n#endif\r\n#ifndef MODULE\r\npr_info_once("%s\n", version);\r\n#endif\r\nio_size = 256;\r\nphy_id = 0;\r\nquirks = 0;\r\nname = "Rhine";\r\nif (pdev->revision < VTunknown0) {\r\nquirks = rqRhineI;\r\nio_size = 128;\r\n}\r\nelse if (pdev->revision >= VT6102) {\r\nquirks = rqWOL | rqForceReset;\r\nif (pdev->revision < VT6105) {\r\nname = "Rhine II";\r\nquirks |= rqStatusWBRace;\r\n}\r\nelse {\r\nphy_id = 1;\r\nif (pdev->revision >= VT6105_B0)\r\nquirks |= rq6patterns;\r\nif (pdev->revision < VT6105M)\r\nname = "Rhine III";\r\nelse\r\nname = "Rhine III (Management Adapter)";\r\n}\r\n}\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err_out;\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"32-bit PCI DMA addresses not supported by the card!?\n");\r\ngoto err_out;\r\n}\r\nif ((pci_resource_len(pdev, 0) < io_size) ||\r\n(pci_resource_len(pdev, 1) < io_size)) {\r\nrc = -EIO;\r\ndev_err(&pdev->dev, "Insufficient PCI resources, aborting\n");\r\ngoto err_out;\r\n}\r\npioaddr = pci_resource_start(pdev, 0);\r\nmemaddr = pci_resource_start(pdev, 1);\r\npci_set_master(pdev);\r\ndev = alloc_etherdev(sizeof(struct rhine_private));\r\nif (!dev) {\r\nrc = -ENOMEM;\r\ndev_err(&pdev->dev, "alloc_etherdev failed\n");\r\ngoto err_out;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nrp = netdev_priv(dev);\r\nrp->dev = dev;\r\nrp->quirks = quirks;\r\nrp->pioaddr = pioaddr;\r\nrp->pdev = pdev;\r\nrc = pci_request_regions(pdev, DRV_NAME);\r\nif (rc)\r\ngoto err_out_free_netdev;\r\nioaddr = pci_iomap(pdev, bar, io_size);\r\nif (!ioaddr) {\r\nrc = -EIO;\r\ndev_err(&pdev->dev,\r\n"ioremap failed for device %s, region 0x%X @ 0x%lX\n",\r\npci_name(pdev), io_size, memaddr);\r\ngoto err_out_free_res;\r\n}\r\n#ifdef USE_MMIO\r\nenable_mmio(pioaddr, quirks);\r\ni = 0;\r\nwhile (mmio_verify_registers[i]) {\r\nint reg = mmio_verify_registers[i++];\r\nunsigned char a = inb(pioaddr+reg);\r\nunsigned char b = readb(ioaddr+reg);\r\nif (a != b) {\r\nrc = -EIO;\r\ndev_err(&pdev->dev,\r\n"MMIO do not match PIO [%02x] (%02x != %02x)\n",\r\nreg, a, b);\r\ngoto err_out_unmap;\r\n}\r\n}\r\n#endif\r\ndev->base_addr = (unsigned long)ioaddr;\r\nrp->base = ioaddr;\r\nrhine_power_init(dev);\r\nrhine_hw_init(dev, pioaddr);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = ioread8(ioaddr + StationAddr + i);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nnetdev_err(dev, "Invalid MAC address: %pM\n", dev->dev_addr);\r\nrandom_ether_addr(dev->dev_addr);\r\nnetdev_info(dev, "Using random MAC address: %pM\n",\r\ndev->dev_addr);\r\n}\r\nmemcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);\r\nif (!phy_id)\r\nphy_id = ioread8(ioaddr + 0x6C);\r\ndev->irq = pdev->irq;\r\nspin_lock_init(&rp->lock);\r\nINIT_WORK(&rp->reset_task, rhine_reset_task);\r\nrp->mii_if.dev = dev;\r\nrp->mii_if.mdio_read = mdio_read;\r\nrp->mii_if.mdio_write = mdio_write;\r\nrp->mii_if.phy_id_mask = 0x1f;\r\nrp->mii_if.reg_num_mask = 0x1f;\r\ndev->netdev_ops = &rhine_netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops,\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nnetif_napi_add(dev, &rp->napi, rhine_napipoll, 64);\r\nif (rp->quirks & rqRhineI)\r\ndev->features |= NETIF_F_SG|NETIF_F_HW_CSUM;\r\nif (pdev->revision >= VT6105M)\r\ndev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |\r\nNETIF_F_HW_VLAN_FILTER;\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_out_unmap;\r\nnetdev_info(dev, "VIA %s at 0x%lx, %pM, IRQ %d\n",\r\nname,\r\n#ifdef USE_MMIO\r\nmemaddr,\r\n#else\r\n(long)ioaddr,\r\n#endif\r\ndev->dev_addr, pdev->irq);\r\npci_set_drvdata(pdev, dev);\r\n{\r\nu16 mii_cmd;\r\nint mii_status = mdio_read(dev, phy_id, 1);\r\nmii_cmd = mdio_read(dev, phy_id, MII_BMCR) & ~BMCR_ISOLATE;\r\nmdio_write(dev, phy_id, MII_BMCR, mii_cmd);\r\nif (mii_status != 0xffff && mii_status != 0x0000) {\r\nrp->mii_if.advertising = mdio_read(dev, phy_id, 4);\r\nnetdev_info(dev,\r\n"MII PHY found at address %d, status 0x%04x advertising %04x Link %04x\n",\r\nphy_id,\r\nmii_status, rp->mii_if.advertising,\r\nmdio_read(dev, phy_id, 5));\r\nif (mii_status & BMSR_LSTATUS)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\n}\r\n}\r\nrp->mii_if.phy_id = phy_id;\r\nif (debug > 1 && avoid_D3)\r\nnetdev_info(dev, "No D3 power state at shutdown\n");\r\nreturn 0;\r\nerr_out_unmap:\r\npci_iounmap(pdev, ioaddr);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_free_netdev:\r\nfree_netdev(dev);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic int alloc_ring(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid *ring;\r\ndma_addr_t ring_dma;\r\nring = pci_alloc_consistent(rp->pdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\n&ring_dma);\r\nif (!ring) {\r\nnetdev_err(dev, "Could not allocate DMA memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (rp->quirks & rqRhineI) {\r\nrp->tx_bufs = pci_alloc_consistent(rp->pdev,\r\nPKT_BUF_SZ * TX_RING_SIZE,\r\n&rp->tx_bufs_dma);\r\nif (rp->tx_bufs == NULL) {\r\npci_free_consistent(rp->pdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\nring, ring_dma);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nrp->rx_ring = ring;\r\nrp->tx_ring = ring + RX_RING_SIZE * sizeof(struct rx_desc);\r\nrp->rx_ring_dma = ring_dma;\r\nrp->tx_ring_dma = ring_dma + RX_RING_SIZE * sizeof(struct rx_desc);\r\nreturn 0;\r\n}\r\nstatic void free_ring(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\npci_free_consistent(rp->pdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\nrp->rx_ring, rp->rx_ring_dma);\r\nrp->tx_ring = NULL;\r\nif (rp->tx_bufs)\r\npci_free_consistent(rp->pdev, PKT_BUF_SZ * TX_RING_SIZE,\r\nrp->tx_bufs, rp->tx_bufs_dma);\r\nrp->tx_bufs = NULL;\r\n}\r\nstatic void alloc_rbufs(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\ndma_addr_t next;\r\nint i;\r\nrp->dirty_rx = rp->cur_rx = 0;\r\nrp->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\r\nrp->rx_head_desc = &rp->rx_ring[0];\r\nnext = rp->rx_ring_dma;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nrp->rx_ring[i].rx_status = 0;\r\nrp->rx_ring[i].desc_length = cpu_to_le32(rp->rx_buf_sz);\r\nnext += sizeof(struct rx_desc);\r\nrp->rx_ring[i].next_desc = cpu_to_le32(next);\r\nrp->rx_skbuff[i] = NULL;\r\n}\r\nrp->rx_ring[i-1].next_desc = cpu_to_le32(rp->rx_ring_dma);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, rp->rx_buf_sz);\r\nrp->rx_skbuff[i] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nskb->dev = dev;\r\nrp->rx_skbuff_dma[i] =\r\npci_map_single(rp->pdev, skb->data, rp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nrp->rx_ring[i].addr = cpu_to_le32(rp->rx_skbuff_dma[i]);\r\nrp->rx_ring[i].rx_status = cpu_to_le32(DescOwn);\r\n}\r\nrp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\r\n}\r\nstatic void free_rbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nrp->rx_ring[i].rx_status = 0;\r\nrp->rx_ring[i].addr = cpu_to_le32(0xBADF00D0);\r\nif (rp->rx_skbuff[i]) {\r\npci_unmap_single(rp->pdev,\r\nrp->rx_skbuff_dma[i],\r\nrp->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(rp->rx_skbuff[i]);\r\n}\r\nrp->rx_skbuff[i] = NULL;\r\n}\r\n}\r\nstatic void alloc_tbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\ndma_addr_t next;\r\nint i;\r\nrp->dirty_tx = rp->cur_tx = 0;\r\nnext = rp->tx_ring_dma;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nrp->tx_skbuff[i] = NULL;\r\nrp->tx_ring[i].tx_status = 0;\r\nrp->tx_ring[i].desc_length = cpu_to_le32(TXDESC);\r\nnext += sizeof(struct tx_desc);\r\nrp->tx_ring[i].next_desc = cpu_to_le32(next);\r\nif (rp->quirks & rqRhineI)\r\nrp->tx_buf[i] = &rp->tx_bufs[i * PKT_BUF_SZ];\r\n}\r\nrp->tx_ring[i-1].next_desc = cpu_to_le32(rp->tx_ring_dma);\r\n}\r\nstatic void free_tbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nrp->tx_ring[i].tx_status = 0;\r\nrp->tx_ring[i].desc_length = cpu_to_le32(TXDESC);\r\nrp->tx_ring[i].addr = cpu_to_le32(0xBADF00D0);\r\nif (rp->tx_skbuff[i]) {\r\nif (rp->tx_skbuff_dma[i]) {\r\npci_unmap_single(rp->pdev,\r\nrp->tx_skbuff_dma[i],\r\nrp->tx_skbuff[i]->len,\r\nPCI_DMA_TODEVICE);\r\n}\r\ndev_kfree_skb(rp->tx_skbuff[i]);\r\n}\r\nrp->tx_skbuff[i] = NULL;\r\nrp->tx_buf[i] = NULL;\r\n}\r\n}\r\nstatic void rhine_check_media(struct net_device *dev, unsigned int init_media)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nmii_check_media(&rp->mii_if, debug, init_media);\r\nif (rp->mii_if.full_duplex)\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1FDuplex,\r\nioaddr + ChipCmd1);\r\nelse\r\niowrite8(ioread8(ioaddr + ChipCmd1) & ~Cmd1FDuplex,\r\nioaddr + ChipCmd1);\r\nif (debug > 1)\r\nnetdev_info(dev, "force_media %d, carrier %d\n",\r\nrp->mii_if.force_media, netif_carrier_ok(dev));\r\n}\r\nstatic void rhine_set_carrier(struct mii_if_info *mii)\r\n{\r\nif (mii->force_media) {\r\nif (!netif_carrier_ok(mii->dev))\r\nnetif_carrier_on(mii->dev);\r\n}\r\nelse\r\nrhine_check_media(mii->dev, 0);\r\nif (debug > 1)\r\nnetdev_info(mii->dev, "force_media %d, carrier %d\n",\r\nmii->force_media, netif_carrier_ok(mii->dev));\r\n}\r\nstatic void rhine_set_cam(void __iomem *ioaddr, int idx, u8 *addr)\r\n{\r\nint i;\r\niowrite8(CAMC_CAMEN, ioaddr + CamCon);\r\nwmb();\r\nidx &= (MCAM_SIZE - 1);\r\niowrite8((u8) idx, ioaddr + CamAddr);\r\nfor (i = 0; i < 6; i++, addr++)\r\niowrite8(*addr, ioaddr + MulticastFilter0 + i);\r\nudelay(10);\r\nwmb();\r\niowrite8(CAMC_CAMWR | CAMC_CAMEN, ioaddr + CamCon);\r\nudelay(10);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_vlan_cam(void __iomem *ioaddr, int idx, u8 *addr)\r\n{\r\niowrite8(CAMC_CAMEN | CAMC_VCAMSL, ioaddr + CamCon);\r\nwmb();\r\nidx &= (VCAM_SIZE - 1);\r\niowrite8((u8) idx, ioaddr + CamAddr);\r\niowrite16(*((u16 *) addr), ioaddr + MulticastFilter0 + 6);\r\nudelay(10);\r\nwmb();\r\niowrite8(CAMC_CAMWR | CAMC_CAMEN, ioaddr + CamCon);\r\nudelay(10);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_cam_mask(void __iomem *ioaddr, u32 mask)\r\n{\r\niowrite8(CAMC_CAMEN, ioaddr + CamCon);\r\nwmb();\r\niowrite32(mask, ioaddr + CamMask);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_vlan_cam_mask(void __iomem *ioaddr, u32 mask)\r\n{\r\niowrite8(CAMC_CAMEN | CAMC_VCAMSL, ioaddr + CamCon);\r\nwmb();\r\niowrite32(mask, ioaddr + CamMask);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_init_cam_filter(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nrhine_set_vlan_cam_mask(ioaddr, 0);\r\nrhine_set_cam_mask(ioaddr, 0);\r\nBYTE_REG_BITS_ON(TCR_PQEN, ioaddr + TxConfig);\r\nBYTE_REG_BITS_OFF(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\n}\r\nstatic void rhine_update_vcam(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu16 vid;\r\nu32 vCAMmask = 0;\r\nunsigned int i = 0;\r\nfor_each_set_bit(vid, rp->active_vlans, VLAN_N_VID) {\r\nrhine_set_vlan_cam(ioaddr, i, (u8 *)&vid);\r\nvCAMmask |= 1 << i;\r\nif (++i >= VCAM_SIZE)\r\nbreak;\r\n}\r\nrhine_set_vlan_cam_mask(ioaddr, vCAMmask);\r\n}\r\nstatic void rhine_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nspin_lock_irq(&rp->lock);\r\nset_bit(vid, rp->active_vlans);\r\nrhine_update_vcam(dev);\r\nspin_unlock_irq(&rp->lock);\r\n}\r\nstatic void rhine_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nspin_lock_irq(&rp->lock);\r\nclear_bit(vid, rp->active_vlans);\r\nrhine_update_vcam(dev);\r\nspin_unlock_irq(&rp->lock);\r\n}\r\nstatic void init_registers(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\niowrite8(dev->dev_addr[i], ioaddr + StationAddr + i);\r\niowrite16(0x0006, ioaddr + PCIBusConfig);\r\niowrite8(0x20, ioaddr + TxConfig);\r\nrp->tx_thresh = 0x20;\r\nrp->rx_thresh = 0x60;\r\niowrite32(rp->rx_ring_dma, ioaddr + RxRingPtr);\r\niowrite32(rp->tx_ring_dma, ioaddr + TxRingPtr);\r\nrhine_set_rx_mode(dev);\r\nif (rp->pdev->revision >= VT6105M)\r\nrhine_init_cam_filter(dev);\r\nnapi_enable(&rp->napi);\r\niowrite16(IntrRxDone | IntrRxErr | IntrRxEmpty| IntrRxOverflow |\r\nIntrRxDropped | IntrRxNoBuf | IntrTxAborted |\r\nIntrTxDone | IntrTxError | IntrTxUnderrun |\r\nIntrPCIErr | IntrStatsMax | IntrLinkChange,\r\nioaddr + IntrEnable);\r\niowrite16(CmdStart | CmdTxOn | CmdRxOn | (Cmd1NoTxPoll << 8),\r\nioaddr + ChipCmd);\r\nrhine_check_media(dev, 1);\r\n}\r\nstatic void rhine_enable_linkmon(void __iomem *ioaddr)\r\n{\r\niowrite8(0, ioaddr + MIICmd);\r\niowrite8(MII_BMSR, ioaddr + MIIRegAddr);\r\niowrite8(0x80, ioaddr + MIICmd);\r\nRHINE_WAIT_FOR((ioread8(ioaddr + MIIRegAddr) & 0x20));\r\niowrite8(MII_BMSR | 0x40, ioaddr + MIIRegAddr);\r\n}\r\nstatic void rhine_disable_linkmon(void __iomem *ioaddr, u32 quirks)\r\n{\r\niowrite8(0, ioaddr + MIICmd);\r\nif (quirks & rqRhineI) {\r\niowrite8(0x01, ioaddr + MIIRegAddr);\r\nmdelay(1);\r\niowrite8(0x80, ioaddr + MIICmd);\r\nRHINE_WAIT_FOR(ioread8(ioaddr + MIIRegAddr) & 0x20);\r\niowrite8(0, ioaddr + MIICmd);\r\n}\r\nelse\r\nRHINE_WAIT_FOR(ioread8(ioaddr + MIIRegAddr) & 0x80);\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int regnum)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint result;\r\nrhine_disable_linkmon(ioaddr, rp->quirks);\r\niowrite8(phy_id, ioaddr + MIIPhyAddr);\r\niowrite8(regnum, ioaddr + MIIRegAddr);\r\niowrite8(0x40, ioaddr + MIICmd);\r\nRHINE_WAIT_FOR(!(ioread8(ioaddr + MIICmd) & 0x40));\r\nresult = ioread16(ioaddr + MIIData);\r\nrhine_enable_linkmon(ioaddr);\r\nreturn result;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int regnum, int value)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nrhine_disable_linkmon(ioaddr, rp->quirks);\r\niowrite8(phy_id, ioaddr + MIIPhyAddr);\r\niowrite8(regnum, ioaddr + MIIRegAddr);\r\niowrite16(value, ioaddr + MIIData);\r\niowrite8(0x20, ioaddr + MIICmd);\r\nRHINE_WAIT_FOR(!(ioread8(ioaddr + MIICmd) & 0x20));\r\nrhine_enable_linkmon(ioaddr);\r\n}\r\nstatic int rhine_open(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint rc;\r\nrc = request_irq(rp->pdev->irq, rhine_interrupt, IRQF_SHARED, dev->name,\r\ndev);\r\nif (rc)\r\nreturn rc;\r\nif (debug > 1)\r\nnetdev_dbg(dev, "%s() irq %d\n", __func__, rp->pdev->irq);\r\nrc = alloc_ring(dev);\r\nif (rc) {\r\nfree_irq(rp->pdev->irq, dev);\r\nreturn rc;\r\n}\r\nalloc_rbufs(dev);\r\nalloc_tbufs(dev);\r\nrhine_chip_reset(dev);\r\ninit_registers(dev);\r\nif (debug > 2)\r\nnetdev_dbg(dev, "%s() Done - status %04x MII status: %04x\n",\r\n__func__, ioread16(ioaddr + ChipCmd),\r\nmdio_read(dev, rp->mii_if.phy_id, MII_BMSR));\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void rhine_reset_task(struct work_struct *work)\r\n{\r\nstruct rhine_private *rp = container_of(work, struct rhine_private,\r\nreset_task);\r\nstruct net_device *dev = rp->dev;\r\ndisable_irq(rp->pdev->irq);\r\nnapi_disable(&rp->napi);\r\nspin_lock_bh(&rp->lock);\r\nfree_tbufs(dev);\r\nfree_rbufs(dev);\r\nalloc_tbufs(dev);\r\nalloc_rbufs(dev);\r\nrhine_chip_reset(dev);\r\ninit_registers(dev);\r\nspin_unlock_bh(&rp->lock);\r\nenable_irq(rp->pdev->irq);\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_errors++;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void rhine_tx_timeout(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nnetdev_warn(dev, "Transmit timed out, status %04x, PHY status %04x, resetting...\n",\r\nioread16(ioaddr + IntrStatus),\r\nmdio_read(dev, rp->mii_if.phy_id, MII_BMSR));\r\nschedule_work(&rp->reset_task);\r\n}\r\nstatic netdev_tx_t rhine_start_tx(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nunsigned entry;\r\nunsigned long flags;\r\nentry = rp->cur_tx % TX_RING_SIZE;\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nrp->tx_skbuff[entry] = skb;\r\nif ((rp->quirks & rqRhineI) &&\r\n(((unsigned long)skb->data & 3) || skb_shinfo(skb)->nr_frags != 0 || skb->ip_summed == CHECKSUM_PARTIAL)) {\r\nif (skb->len > PKT_BUF_SZ) {\r\ndev_kfree_skb(skb);\r\nrp->tx_skbuff[entry] = NULL;\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb_copy_and_csum_dev(skb, rp->tx_buf[entry]);\r\nif (skb->len < ETH_ZLEN)\r\nmemset(rp->tx_buf[entry] + skb->len, 0,\r\nETH_ZLEN - skb->len);\r\nrp->tx_skbuff_dma[entry] = 0;\r\nrp->tx_ring[entry].addr = cpu_to_le32(rp->tx_bufs_dma +\r\n(rp->tx_buf[entry] -\r\nrp->tx_bufs));\r\n} else {\r\nrp->tx_skbuff_dma[entry] =\r\npci_map_single(rp->pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nrp->tx_ring[entry].addr = cpu_to_le32(rp->tx_skbuff_dma[entry]);\r\n}\r\nrp->tx_ring[entry].desc_length =\r\ncpu_to_le32(TXDESC | (skb->len >= ETH_ZLEN ? skb->len : ETH_ZLEN));\r\nif (unlikely(vlan_tx_tag_present(skb))) {\r\nrp->tx_ring[entry].tx_status = cpu_to_le32((vlan_tx_tag_get(skb)) << 16);\r\nrp->tx_ring[entry].desc_length |= cpu_to_le32(0x020000);\r\n}\r\nelse\r\nrp->tx_ring[entry].tx_status = 0;\r\nspin_lock_irqsave(&rp->lock, flags);\r\nwmb();\r\nrp->tx_ring[entry].tx_status |= cpu_to_le32(DescOwn);\r\nwmb();\r\nrp->cur_tx++;\r\nif (vlan_tx_tag_present(skb))\r\nBYTE_REG_BITS_ON(1 << 7, ioaddr + TQWake);\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1TxDemand,\r\nioaddr + ChipCmd1);\r\nIOSYNC;\r\nif (rp->cur_tx == rp->dirty_tx + TX_QUEUE_LEN)\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&rp->lock, flags);\r\nif (debug > 4) {\r\nnetdev_dbg(dev, "Transmit frame #%d queued in slot %d\n",\r\nrp->cur_tx-1, entry);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t rhine_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu32 intr_status;\r\nint boguscnt = max_interrupt_work;\r\nint handled = 0;\r\nwhile ((intr_status = get_intr_status(dev))) {\r\nhandled = 1;\r\nif (intr_status & IntrTxDescRace)\r\niowrite8(0x08, ioaddr + IntrStatus2);\r\niowrite16(intr_status & 0xffff, ioaddr + IntrStatus);\r\nIOSYNC;\r\nif (debug > 4)\r\nnetdev_dbg(dev, "Interrupt, status %08x\n",\r\nintr_status);\r\nif (intr_status & (IntrRxDone | IntrRxErr | IntrRxDropped |\r\nIntrRxWakeUp | IntrRxEmpty | IntrRxNoBuf)) {\r\niowrite16(IntrTxAborted |\r\nIntrTxDone | IntrTxError | IntrTxUnderrun |\r\nIntrPCIErr | IntrStatsMax | IntrLinkChange,\r\nioaddr + IntrEnable);\r\nnapi_schedule(&rp->napi);\r\n}\r\nif (intr_status & (IntrTxErrSummary | IntrTxDone)) {\r\nif (intr_status & IntrTxErrSummary) {\r\nRHINE_WAIT_FOR(!(ioread8(ioaddr+ChipCmd) & CmdTxOn));\r\nif (debug > 2 &&\r\nioread8(ioaddr+ChipCmd) & CmdTxOn)\r\nnetdev_warn(dev,\r\n"%s: Tx engine still on\n",\r\n__func__);\r\n}\r\nrhine_tx(dev);\r\n}\r\nif (intr_status & (IntrPCIErr | IntrLinkChange |\r\nIntrStatsMax | IntrTxError | IntrTxAborted |\r\nIntrTxUnderrun | IntrTxDescRace))\r\nrhine_error(dev, intr_status);\r\nif (--boguscnt < 0) {\r\nnetdev_warn(dev, "Too much work at interrupt, status=%#08x\n",\r\nintr_status);\r\nbreak;\r\n}\r\n}\r\nif (debug > 3)\r\nnetdev_dbg(dev, "exiting interrupt, status=%08x\n",\r\nioread16(ioaddr + IntrStatus));\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void rhine_tx(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint txstatus = 0, entry = rp->dirty_tx % TX_RING_SIZE;\r\nspin_lock(&rp->lock);\r\nwhile (rp->dirty_tx != rp->cur_tx) {\r\ntxstatus = le32_to_cpu(rp->tx_ring[entry].tx_status);\r\nif (debug > 6)\r\nnetdev_dbg(dev, "Tx scavenge %d status %08x\n",\r\nentry, txstatus);\r\nif (txstatus & DescOwn)\r\nbreak;\r\nif (txstatus & 0x8000) {\r\nif (debug > 1)\r\nnetdev_dbg(dev, "Transmit error, Tx status %08x\n",\r\ntxstatus);\r\ndev->stats.tx_errors++;\r\nif (txstatus & 0x0400)\r\ndev->stats.tx_carrier_errors++;\r\nif (txstatus & 0x0200)\r\ndev->stats.tx_window_errors++;\r\nif (txstatus & 0x0100)\r\ndev->stats.tx_aborted_errors++;\r\nif (txstatus & 0x0080)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (((rp->quirks & rqRhineI) && txstatus & 0x0002) ||\r\n(txstatus & 0x0800) || (txstatus & 0x1000)) {\r\ndev->stats.tx_fifo_errors++;\r\nrp->tx_ring[entry].tx_status = cpu_to_le32(DescOwn);\r\nbreak;\r\n}\r\n} else {\r\nif (rp->quirks & rqRhineI)\r\ndev->stats.collisions += (txstatus >> 3) & 0x0F;\r\nelse\r\ndev->stats.collisions += txstatus & 0x0F;\r\nif (debug > 6)\r\nnetdev_dbg(dev, "collisions: %1.1x:%1.1x\n",\r\n(txstatus >> 3) & 0xF,\r\ntxstatus & 0xF);\r\ndev->stats.tx_bytes += rp->tx_skbuff[entry]->len;\r\ndev->stats.tx_packets++;\r\n}\r\nif (rp->tx_skbuff_dma[entry]) {\r\npci_unmap_single(rp->pdev,\r\nrp->tx_skbuff_dma[entry],\r\nrp->tx_skbuff[entry]->len,\r\nPCI_DMA_TODEVICE);\r\n}\r\ndev_kfree_skb_irq(rp->tx_skbuff[entry]);\r\nrp->tx_skbuff[entry] = NULL;\r\nentry = (++rp->dirty_tx) % TX_RING_SIZE;\r\n}\r\nif ((rp->cur_tx - rp->dirty_tx) < TX_QUEUE_LEN - 4)\r\nnetif_wake_queue(dev);\r\nspin_unlock(&rp->lock);\r\n}\r\nstatic inline u16 rhine_get_vlan_tci(struct sk_buff *skb, int data_size)\r\n{\r\nu8 *trailer = (u8 *)skb->data + ((data_size + 3) & ~3) + 2;\r\nreturn be16_to_cpup((__be16 *)trailer);\r\n}\r\nstatic int rhine_rx(struct net_device *dev, int limit)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint count;\r\nint entry = rp->cur_rx % RX_RING_SIZE;\r\nif (debug > 4) {\r\nnetdev_dbg(dev, "%s(), entry %d status %08x\n",\r\n__func__, entry,\r\nle32_to_cpu(rp->rx_head_desc->rx_status));\r\n}\r\nfor (count = 0; count < limit; ++count) {\r\nstruct rx_desc *desc = rp->rx_head_desc;\r\nu32 desc_status = le32_to_cpu(desc->rx_status);\r\nu32 desc_length = le32_to_cpu(desc->desc_length);\r\nint data_size = desc_status >> 16;\r\nif (desc_status & DescOwn)\r\nbreak;\r\nif (debug > 4)\r\nnetdev_dbg(dev, "%s() status is %08x\n",\r\n__func__, desc_status);\r\nif ((desc_status & (RxWholePkt | RxErr)) != RxWholePkt) {\r\nif ((desc_status & RxWholePkt) != RxWholePkt) {\r\nnetdev_warn(dev,\r\n"Oversized Ethernet frame spanned multiple buffers, "\r\n"entry %#x length %d status %08x!\n",\r\nentry, data_size,\r\ndesc_status);\r\nnetdev_warn(dev,\r\n"Oversized Ethernet frame %p vs %p\n",\r\nrp->rx_head_desc,\r\n&rp->rx_ring[entry]);\r\ndev->stats.rx_length_errors++;\r\n} else if (desc_status & RxErr) {\r\nif (debug > 2)\r\nnetdev_dbg(dev, "%s() Rx error was %08x\n",\r\n__func__, desc_status);\r\ndev->stats.rx_errors++;\r\nif (desc_status & 0x0030)\r\ndev->stats.rx_length_errors++;\r\nif (desc_status & 0x0048)\r\ndev->stats.rx_fifo_errors++;\r\nif (desc_status & 0x0004)\r\ndev->stats.rx_frame_errors++;\r\nif (desc_status & 0x0002) {\r\nspin_lock(&rp->lock);\r\ndev->stats.rx_crc_errors++;\r\nspin_unlock(&rp->lock);\r\n}\r\n}\r\n} else {\r\nstruct sk_buff *skb = NULL;\r\nint pkt_len = data_size - 4;\r\nu16 vlan_tci = 0;\r\nif (pkt_len < rx_copybreak)\r\nskb = netdev_alloc_skb_ip_align(dev, pkt_len);\r\nif (skb) {\r\npci_dma_sync_single_for_cpu(rp->pdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nskb_copy_to_linear_data(skb,\r\nrp->rx_skbuff[entry]->data,\r\npkt_len);\r\nskb_put(skb, pkt_len);\r\npci_dma_sync_single_for_device(rp->pdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\n} else {\r\nskb = rp->rx_skbuff[entry];\r\nif (skb == NULL) {\r\nnetdev_err(dev, "Inconsistent Rx descriptor chain\n");\r\nbreak;\r\n}\r\nrp->rx_skbuff[entry] = NULL;\r\nskb_put(skb, pkt_len);\r\npci_unmap_single(rp->pdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\n}\r\nif (unlikely(desc_length & DescTag))\r\nvlan_tci = rhine_get_vlan_tci(skb, data_size);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (unlikely(desc_length & DescTag))\r\n__vlan_hwaccel_put_tag(skb, vlan_tci);\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_bytes += pkt_len;\r\ndev->stats.rx_packets++;\r\n}\r\nentry = (++rp->cur_rx) % RX_RING_SIZE;\r\nrp->rx_head_desc = &rp->rx_ring[entry];\r\n}\r\nfor (; rp->cur_rx - rp->dirty_rx > 0; rp->dirty_rx++) {\r\nstruct sk_buff *skb;\r\nentry = rp->dirty_rx % RX_RING_SIZE;\r\nif (rp->rx_skbuff[entry] == NULL) {\r\nskb = netdev_alloc_skb(dev, rp->rx_buf_sz);\r\nrp->rx_skbuff[entry] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nskb->dev = dev;\r\nrp->rx_skbuff_dma[entry] =\r\npci_map_single(rp->pdev, skb->data,\r\nrp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nrp->rx_ring[entry].addr = cpu_to_le32(rp->rx_skbuff_dma[entry]);\r\n}\r\nrp->rx_ring[entry].rx_status = cpu_to_le32(DescOwn);\r\n}\r\nreturn count;\r\n}\r\nstatic inline void clear_tally_counters(void __iomem *ioaddr)\r\n{\r\niowrite32(0, ioaddr + RxMissed);\r\nioread16(ioaddr + RxCRCErrs);\r\nioread16(ioaddr + RxMissed);\r\n}\r\nstatic void rhine_restart_tx(struct net_device *dev) {\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint entry = rp->dirty_tx % TX_RING_SIZE;\r\nu32 intr_status;\r\nintr_status = get_intr_status(dev);\r\nif ((intr_status & IntrTxErrSummary) == 0) {\r\niowrite32(rp->tx_ring_dma + entry * sizeof(struct tx_desc),\r\nioaddr + TxRingPtr);\r\niowrite8(ioread8(ioaddr + ChipCmd) | CmdTxOn,\r\nioaddr + ChipCmd);\r\nif (rp->tx_ring[entry].desc_length & cpu_to_le32(0x020000))\r\nBYTE_REG_BITS_ON(1 << 7, ioaddr + TQWake);\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1TxDemand,\r\nioaddr + ChipCmd1);\r\nIOSYNC;\r\n}\r\nelse {\r\nif (debug > 1)\r\nnetdev_warn(dev, "%s() Another error occurred %08x\n",\r\n__func__, intr_status);\r\n}\r\n}\r\nstatic void rhine_error(struct net_device *dev, int intr_status)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nspin_lock(&rp->lock);\r\nif (intr_status & IntrLinkChange)\r\nrhine_check_media(dev, 0);\r\nif (intr_status & IntrStatsMax) {\r\ndev->stats.rx_crc_errors += ioread16(ioaddr + RxCRCErrs);\r\ndev->stats.rx_missed_errors += ioread16(ioaddr + RxMissed);\r\nclear_tally_counters(ioaddr);\r\n}\r\nif (intr_status & IntrTxAborted) {\r\nif (debug > 1)\r\nnetdev_info(dev, "Abort %08x, frame dropped\n",\r\nintr_status);\r\n}\r\nif (intr_status & IntrTxUnderrun) {\r\nif (rp->tx_thresh < 0xE0)\r\nBYTE_REG_BITS_SET((rp->tx_thresh += 0x20), 0x80, ioaddr + TxConfig);\r\nif (debug > 1)\r\nnetdev_info(dev, "Transmitter underrun, Tx threshold now %02x\n",\r\nrp->tx_thresh);\r\n}\r\nif (intr_status & IntrTxDescRace) {\r\nif (debug > 2)\r\nnetdev_info(dev, "Tx descriptor write-back race\n");\r\n}\r\nif ((intr_status & IntrTxError) &&\r\n(intr_status & (IntrTxAborted |\r\nIntrTxUnderrun | IntrTxDescRace)) == 0) {\r\nif (rp->tx_thresh < 0xE0) {\r\nBYTE_REG_BITS_SET((rp->tx_thresh += 0x20), 0x80, ioaddr + TxConfig);\r\n}\r\nif (debug > 1)\r\nnetdev_info(dev, "Unspecified error. Tx threshold now %02x\n",\r\nrp->tx_thresh);\r\n}\r\nif (intr_status & (IntrTxAborted | IntrTxUnderrun | IntrTxDescRace |\r\nIntrTxError))\r\nrhine_restart_tx(dev);\r\nif (intr_status & ~(IntrLinkChange | IntrStatsMax | IntrTxUnderrun |\r\nIntrTxError | IntrTxAborted | IntrNormalSummary |\r\nIntrTxDescRace)) {\r\nif (debug > 1)\r\nnetdev_err(dev, "Something Wicked happened! %08x\n",\r\nintr_status);\r\n}\r\nspin_unlock(&rp->lock);\r\n}\r\nstatic struct net_device_stats *rhine_get_stats(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rp->lock, flags);\r\ndev->stats.rx_crc_errors += ioread16(ioaddr + RxCRCErrs);\r\ndev->stats.rx_missed_errors += ioread16(ioaddr + RxMissed);\r\nclear_tally_counters(ioaddr);\r\nspin_unlock_irqrestore(&rp->lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void rhine_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu32 mc_filter[2];\r\nu8 rx_mode = 0x0C;\r\nstruct netdev_hw_addr *ha;\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode = 0x1C;\r\niowrite32(0xffffffff, ioaddr + MulticastFilter0);\r\niowrite32(0xffffffff, ioaddr + MulticastFilter1);\r\n} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\niowrite32(0xffffffff, ioaddr + MulticastFilter0);\r\niowrite32(0xffffffff, ioaddr + MulticastFilter1);\r\n} else if (rp->pdev->revision >= VT6105M) {\r\nint i = 0;\r\nu32 mCAMmask = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (i == MCAM_SIZE)\r\nbreak;\r\nrhine_set_cam(ioaddr, i, ha->addr);\r\nmCAMmask |= 1 << i;\r\ni++;\r\n}\r\nrhine_set_cam_mask(ioaddr, mCAMmask);\r\n} else {\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\n}\r\niowrite32(mc_filter[0], ioaddr + MulticastFilter0);\r\niowrite32(mc_filter[1], ioaddr + MulticastFilter1);\r\n}\r\nif (rp->pdev->revision >= VT6105M) {\r\nif (dev->flags & IFF_PROMISC)\r\nBYTE_REG_BITS_OFF(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\nelse\r\nBYTE_REG_BITS_ON(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\n}\r\nBYTE_REG_BITS_ON(rx_mode, ioaddr + RxConfig);\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nstrcpy(info->bus_info, pci_name(rp->pdev));\r\n}\r\nstatic int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&rp->lock);\r\nrc = mii_ethtool_gset(&rp->mii_if, cmd);\r\nspin_unlock_irq(&rp->lock);\r\nreturn rc;\r\n}\r\nstatic int netdev_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&rp->lock);\r\nrc = mii_ethtool_sset(&rp->mii_if, cmd);\r\nspin_unlock_irq(&rp->lock);\r\nrhine_set_carrier(&rp->mii_if);\r\nreturn rc;\r\n}\r\nstatic int netdev_nway_reset(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nreturn mii_nway_restart(&rp->mii_if);\r\n}\r\nstatic u32 netdev_get_link(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nreturn mii_link_ok(&rp->mii_if);\r\n}\r\nstatic u32 netdev_get_msglevel(struct net_device *dev)\r\n{\r\nreturn debug;\r\n}\r\nstatic void netdev_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\ndebug = value;\r\n}\r\nstatic void rhine_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (!(rp->quirks & rqWOL))\r\nreturn;\r\nspin_lock_irq(&rp->lock);\r\nwol->supported = WAKE_PHY | WAKE_MAGIC |\r\nWAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\nwol->wolopts = rp->wolopts;\r\nspin_unlock_irq(&rp->lock);\r\n}\r\nstatic int rhine_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nu32 support = WAKE_PHY | WAKE_MAGIC |\r\nWAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\nif (!(rp->quirks & rqWOL))\r\nreturn -EINVAL;\r\nif (wol->wolopts & ~support)\r\nreturn -EINVAL;\r\nspin_lock_irq(&rp->lock);\r\nrp->wolopts = wol->wolopts;\r\nspin_unlock_irq(&rp->lock);\r\nreturn 0;\r\n}\r\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nspin_lock_irq(&rp->lock);\r\nrc = generic_mii_ioctl(&rp->mii_if, if_mii(rq), cmd, NULL);\r\nspin_unlock_irq(&rp->lock);\r\nrhine_set_carrier(&rp->mii_if);\r\nreturn rc;\r\n}\r\nstatic int rhine_close(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nnapi_disable(&rp->napi);\r\ncancel_work_sync(&rp->reset_task);\r\nnetif_stop_queue(dev);\r\nspin_lock_irq(&rp->lock);\r\nif (debug > 1)\r\nnetdev_dbg(dev, "Shutting down ethercard, status was %04x\n",\r\nioread16(ioaddr + ChipCmd));\r\niowrite8(rp->tx_thresh | 0x02, ioaddr + TxConfig);\r\niowrite16(0x0000, ioaddr + IntrEnable);\r\niowrite16(CmdStop, ioaddr + ChipCmd);\r\nspin_unlock_irq(&rp->lock);\r\nfree_irq(rp->pdev->irq, dev);\r\nfree_rbufs(dev);\r\nfree_tbufs(dev);\r\nfree_ring(dev);\r\nreturn 0;\r\n}\r\nstatic void __devexit rhine_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\npci_iounmap(pdev, rp->base);\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic void rhine_shutdown (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nif (!(rp->quirks & rqWOL))\r\nreturn;\r\nrhine_power_init(dev);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x04, ioaddr + WOLcgClr);\r\nif (rp->wolopts & WAKE_MAGIC) {\r\niowrite8(WOLmagic, ioaddr + WOLcrSet);\r\niowrite8(ioread8(ioaddr + ConfigA) | 0x03, ioaddr + ConfigA);\r\n}\r\nif (rp->wolopts & (WAKE_BCAST|WAKE_MCAST))\r\niowrite8(WOLbmcast, ioaddr + WOLcgSet);\r\nif (rp->wolopts & WAKE_PHY)\r\niowrite8(WOLlnkon | WOLlnkoff, ioaddr + WOLcrSet);\r\nif (rp->wolopts & WAKE_UCAST)\r\niowrite8(WOLucast, ioaddr + WOLcrSet);\r\nif (rp->wolopts) {\r\niowrite8(0x01, ioaddr + PwcfgSet);\r\niowrite8(ioread8(ioaddr + StickyHW) | 0x04, ioaddr + StickyHW);\r\n}\r\nif (!avoid_D3)\r\niowrite8(ioread8(ioaddr + StickyHW) | 0x03, ioaddr + StickyHW);\r\n}\r\nstatic int rhine_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nunsigned long flags;\r\nif (!netif_running(dev))\r\nreturn 0;\r\nnapi_disable(&rp->napi);\r\nnetif_device_detach(dev);\r\npci_save_state(pdev);\r\nspin_lock_irqsave(&rp->lock, flags);\r\nrhine_shutdown(pdev);\r\nspin_unlock_irqrestore(&rp->lock, flags);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic int rhine_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nunsigned long flags;\r\nint ret;\r\nif (!netif_running(dev))\r\nreturn 0;\r\nif (request_irq(dev->irq, rhine_interrupt, IRQF_SHARED, dev->name, dev))\r\nnetdev_err(dev, "request_irq failed\n");\r\nret = pci_set_power_state(pdev, PCI_D0);\r\nif (debug > 1)\r\nnetdev_info(dev, "Entering power state D0 %s (%d)\n",\r\nret ? "failed" : "succeeded", ret);\r\npci_restore_state(pdev);\r\nspin_lock_irqsave(&rp->lock, flags);\r\n#ifdef USE_MMIO\r\nenable_mmio(rp->pioaddr, rp->quirks);\r\n#endif\r\nrhine_power_init(dev);\r\nfree_tbufs(dev);\r\nfree_rbufs(dev);\r\nalloc_tbufs(dev);\r\nalloc_rbufs(dev);\r\ninit_registers(dev);\r\nspin_unlock_irqrestore(&rp->lock, flags);\r\nnetif_device_attach(dev);\r\nreturn 0;\r\n}\r\nstatic int __init rhine_init(void)\r\n{\r\n#ifdef MODULE\r\npr_info("%s\n", version);\r\n#endif\r\nif (dmi_check_system(rhine_dmi_table)) {\r\navoid_D3 = 1;\r\npr_warn("Broken BIOS detected, avoid_D3 enabled\n");\r\n}\r\nelse if (avoid_D3)\r\npr_info("avoid_D3 set\n");\r\nreturn pci_register_driver(&rhine_driver);\r\n}\r\nstatic void __exit rhine_cleanup(void)\r\n{\r\npci_unregister_driver(&rhine_driver);\r\n}
