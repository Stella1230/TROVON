static int hidp_sock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nBT_DBG("sock %p sk %p", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nsock_orphan(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int hidp_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *) arg;\r\nstruct hidp_connadd_req ca;\r\nstruct hidp_conndel_req cd;\r\nstruct hidp_connlist_req cl;\r\nstruct hidp_conninfo ci;\r\nstruct socket *csock;\r\nstruct socket *isock;\r\nint err;\r\nBT_DBG("cmd %x arg %lx", cmd, arg);\r\nswitch (cmd) {\r\ncase HIDPCONNADD:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nif (copy_from_user(&ca, argp, sizeof(ca)))\r\nreturn -EFAULT;\r\ncsock = sockfd_lookup(ca.ctrl_sock, &err);\r\nif (!csock)\r\nreturn err;\r\nisock = sockfd_lookup(ca.intr_sock, &err);\r\nif (!isock) {\r\nsockfd_put(csock);\r\nreturn err;\r\n}\r\nif (csock->sk->sk_state != BT_CONNECTED ||\r\nisock->sk->sk_state != BT_CONNECTED) {\r\nsockfd_put(csock);\r\nsockfd_put(isock);\r\nreturn -EBADFD;\r\n}\r\nerr = hidp_add_connection(&ca, csock, isock);\r\nif (!err) {\r\nif (copy_to_user(argp, &ca, sizeof(ca)))\r\nerr = -EFAULT;\r\n} else {\r\nsockfd_put(csock);\r\nsockfd_put(isock);\r\n}\r\nreturn err;\r\ncase HIDPCONNDEL:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nif (copy_from_user(&cd, argp, sizeof(cd)))\r\nreturn -EFAULT;\r\nreturn hidp_del_connection(&cd);\r\ncase HIDPGETCONNLIST:\r\nif (copy_from_user(&cl, argp, sizeof(cl)))\r\nreturn -EFAULT;\r\nif (cl.cnum <= 0)\r\nreturn -EINVAL;\r\nerr = hidp_get_connlist(&cl);\r\nif (!err && copy_to_user(argp, &cl, sizeof(cl)))\r\nreturn -EFAULT;\r\nreturn err;\r\ncase HIDPGETCONNINFO:\r\nif (copy_from_user(&ci, argp, sizeof(ci)))\r\nreturn -EFAULT;\r\nerr = hidp_get_conninfo(&ci);\r\nif (!err && copy_to_user(argp, &ci, sizeof(ci)))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hidp_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nif (cmd == HIDPGETCONNLIST) {\r\nstruct hidp_connlist_req cl;\r\nuint32_t uci;\r\nint err;\r\nif (get_user(cl.cnum, (uint32_t __user *) arg) ||\r\nget_user(uci, (u32 __user *) (arg + 4)))\r\nreturn -EFAULT;\r\ncl.ci = compat_ptr(uci);\r\nif (cl.cnum <= 0)\r\nreturn -EINVAL;\r\nerr = hidp_get_connlist(&cl);\r\nif (!err && put_user(cl.cnum, (uint32_t __user *) arg))\r\nerr = -EFAULT;\r\nreturn err;\r\n} else if (cmd == HIDPCONNADD) {\r\nstruct compat_hidp_connadd_req ca;\r\nstruct hidp_connadd_req __user *uca;\r\nuca = compat_alloc_user_space(sizeof(*uca));\r\nif (copy_from_user(&ca, (void __user *) arg, sizeof(ca)))\r\nreturn -EFAULT;\r\nif (put_user(ca.ctrl_sock, &uca->ctrl_sock) ||\r\nput_user(ca.intr_sock, &uca->intr_sock) ||\r\nput_user(ca.parser, &uca->parser) ||\r\nput_user(ca.rd_size, &uca->rd_size) ||\r\nput_user(compat_ptr(ca.rd_data), &uca->rd_data) ||\r\nput_user(ca.country, &uca->country) ||\r\nput_user(ca.subclass, &uca->subclass) ||\r\nput_user(ca.vendor, &uca->vendor) ||\r\nput_user(ca.product, &uca->product) ||\r\nput_user(ca.version, &uca->version) ||\r\nput_user(ca.flags, &uca->flags) ||\r\nput_user(ca.idle_to, &uca->idle_to) ||\r\ncopy_to_user(&uca->name[0], &ca.name[0], 128))\r\nreturn -EFAULT;\r\narg = (unsigned long) uca;\r\n}\r\nreturn hidp_sock_ioctl(sock, cmd, arg);\r\n}\r\nstatic int hidp_sock_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nBT_DBG("sock %p", sock);\r\nif (sock->type != SOCK_RAW)\r\nreturn -ESOCKTNOSUPPORT;\r\nsk = sk_alloc(net, PF_BLUETOOTH, GFP_ATOMIC, &hidp_proto);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsock_init_data(sock, sk);\r\nsock->ops = &hidp_sock_ops;\r\nsock->state = SS_UNCONNECTED;\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nsk->sk_protocol = protocol;\r\nsk->sk_state = BT_OPEN;\r\nreturn 0;\r\n}\r\nint __init hidp_init_sockets(void)\r\n{\r\nint err;\r\nerr = proto_register(&hidp_proto, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = bt_sock_register(BTPROTO_HIDP, &hidp_sock_family_ops);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nBT_ERR("Can't register HIDP socket");\r\nproto_unregister(&hidp_proto);\r\nreturn err;\r\n}\r\nvoid __exit hidp_cleanup_sockets(void)\r\n{\r\nif (bt_sock_unregister(BTPROTO_HIDP) < 0)\r\nBT_ERR("Can't unregister HIDP socket");\r\nproto_unregister(&hidp_proto);\r\n}
