static int pvr2_dvb_feed_func(struct pvr2_dvb_adapter *adap)\r\n{\r\nint ret;\r\nunsigned int count;\r\nstruct pvr2_buffer *bp;\r\nstruct pvr2_stream *stream;\r\npvr2_trace(PVR2_TRACE_DVB_FEED, "dvb feed thread started");\r\nset_freezable();\r\nstream = adap->channel.stream->stream;\r\nfor (;;) {\r\nif (kthread_should_stop()) break;\r\ntry_to_freeze();\r\nbp = pvr2_stream_get_ready_buffer(stream);\r\nif (bp != NULL) {\r\ncount = pvr2_buffer_get_count(bp);\r\nif (count) {\r\ndvb_dmx_swfilter(\r\n&adap->demux,\r\nadap->buffer_storage[\r\npvr2_buffer_get_id(bp)],\r\ncount);\r\n} else {\r\nret = pvr2_buffer_get_status(bp);\r\nif (ret < 0) break;\r\n}\r\nret = pvr2_buffer_queue(bp);\r\nif (ret < 0) break;\r\ncontinue;\r\n}\r\nret = wait_event_interruptible(\r\nadap->buffer_wait_data,\r\n(pvr2_stream_get_ready_count(stream) > 0) ||\r\nkthread_should_stop());\r\nif (ret < 0) break;\r\n}\r\npvr2_trace(PVR2_TRACE_DVB_FEED, "dvb feed thread stopped");\r\nreturn 0;\r\n}\r\nstatic int pvr2_dvb_feed_thread(void *data)\r\n{\r\nint stat = pvr2_dvb_feed_func(data);\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\n}\r\nreturn stat;\r\n}\r\nstatic void pvr2_dvb_notify(struct pvr2_dvb_adapter *adap)\r\n{\r\nwake_up(&adap->buffer_wait_data);\r\n}\r\nstatic void pvr2_dvb_stream_end(struct pvr2_dvb_adapter *adap)\r\n{\r\nunsigned int idx;\r\nstruct pvr2_stream *stream;\r\nif (adap->thread) {\r\nkthread_stop(adap->thread);\r\nadap->thread = NULL;\r\n}\r\nif (adap->channel.stream) {\r\nstream = adap->channel.stream->stream;\r\n} else {\r\nstream = NULL;\r\n}\r\nif (stream) {\r\npvr2_hdw_set_streaming(adap->channel.hdw, 0);\r\npvr2_stream_set_callback(stream, NULL, NULL);\r\npvr2_stream_kill(stream);\r\npvr2_stream_set_buffer_count(stream, 0);\r\npvr2_channel_claim_stream(&adap->channel, NULL);\r\n}\r\nif (adap->stream_run) {\r\nfor (idx = 0; idx < PVR2_DVB_BUFFER_COUNT; idx++) {\r\nif (!(adap->buffer_storage[idx])) continue;\r\nkfree(adap->buffer_storage[idx]);\r\nadap->buffer_storage[idx] = NULL;\r\n}\r\nadap->stream_run = 0;\r\n}\r\n}\r\nstatic int pvr2_dvb_stream_do_start(struct pvr2_dvb_adapter *adap)\r\n{\r\nstruct pvr2_context *pvr = adap->channel.mc_head;\r\nunsigned int idx;\r\nint ret;\r\nstruct pvr2_buffer *bp;\r\nstruct pvr2_stream *stream = NULL;\r\nif (adap->stream_run) return -EIO;\r\nret = pvr2_channel_claim_stream(&adap->channel, &pvr->video_stream);\r\nif (ret < 0) return ret;\r\nstream = adap->channel.stream->stream;\r\nfor (idx = 0; idx < PVR2_DVB_BUFFER_COUNT; idx++) {\r\nadap->buffer_storage[idx] = kmalloc(PVR2_DVB_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (!(adap->buffer_storage[idx])) return -ENOMEM;\r\n}\r\npvr2_stream_set_callback(pvr->video_stream.stream,\r\n(pvr2_stream_callback) pvr2_dvb_notify, adap);\r\nret = pvr2_stream_set_buffer_count(stream, PVR2_DVB_BUFFER_COUNT);\r\nif (ret < 0) return ret;\r\nfor (idx = 0; idx < PVR2_DVB_BUFFER_COUNT; idx++) {\r\nbp = pvr2_stream_get_buffer(stream, idx);\r\npvr2_buffer_set_buffer(bp,\r\nadap->buffer_storage[idx],\r\nPVR2_DVB_BUFFER_SIZE);\r\n}\r\nret = pvr2_hdw_set_streaming(adap->channel.hdw, 1);\r\nif (ret < 0) return ret;\r\nwhile ((bp = pvr2_stream_get_idle_buffer(stream)) != NULL) {\r\nret = pvr2_buffer_queue(bp);\r\nif (ret < 0) return ret;\r\n}\r\nadap->thread = kthread_run(pvr2_dvb_feed_thread, adap, "pvrusb2-dvb");\r\nif (IS_ERR(adap->thread)) {\r\nret = PTR_ERR(adap->thread);\r\nadap->thread = NULL;\r\nreturn ret;\r\n}\r\nadap->stream_run = !0;\r\nreturn 0;\r\n}\r\nstatic int pvr2_dvb_stream_start(struct pvr2_dvb_adapter *adap)\r\n{\r\nint ret = pvr2_dvb_stream_do_start(adap);\r\nif (ret < 0) pvr2_dvb_stream_end(adap);\r\nreturn ret;\r\n}\r\nstatic int pvr2_dvb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed, int onoff)\r\n{\r\nstruct pvr2_dvb_adapter *adap = dvbdmxfeed->demux->priv;\r\nint ret = 0;\r\nif (adap == NULL) return -ENODEV;\r\nmutex_lock(&adap->lock);\r\ndo {\r\nif (onoff) {\r\nif (!adap->feedcount) {\r\npvr2_trace(PVR2_TRACE_DVB_FEED,\r\n"start feeding demux");\r\nret = pvr2_dvb_stream_start(adap);\r\nif (ret < 0) break;\r\n}\r\n(adap->feedcount)++;\r\n} else if (adap->feedcount > 0) {\r\n(adap->feedcount)--;\r\nif (!adap->feedcount) {\r\npvr2_trace(PVR2_TRACE_DVB_FEED,\r\n"stop feeding demux");\r\npvr2_dvb_stream_end(adap);\r\n}\r\n}\r\n} while (0);\r\nmutex_unlock(&adap->lock);\r\nreturn ret;\r\n}\r\nstatic int pvr2_dvb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\npvr2_trace(PVR2_TRACE_DVB_FEED, "start pid: 0x%04x", dvbdmxfeed->pid);\r\nreturn pvr2_dvb_ctrl_feed(dvbdmxfeed, 1);\r\n}\r\nstatic int pvr2_dvb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\npvr2_trace(PVR2_TRACE_DVB_FEED, "stop pid: 0x%04x", dvbdmxfeed->pid);\r\nreturn pvr2_dvb_ctrl_feed(dvbdmxfeed, 0);\r\n}\r\nstatic int pvr2_dvb_bus_ctrl(struct dvb_frontend *fe, int acquire)\r\n{\r\nstruct pvr2_dvb_adapter *adap = fe->dvb->priv;\r\nreturn pvr2_channel_limit_inputs(\r\n&adap->channel,\r\n(acquire ? (1 << PVR2_CVAL_INPUT_DTV) : 0));\r\n}\r\nstatic int pvr2_dvb_adapter_init(struct pvr2_dvb_adapter *adap)\r\n{\r\nint ret;\r\nret = dvb_register_adapter(&adap->dvb_adap, "pvrusb2-dvb",\r\nTHIS_MODULE,\r\n&adap->channel.hdw->usb_dev->dev,\r\nadapter_nr);\r\nif (ret < 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"dvb_register_adapter failed: error %d", ret);\r\ngoto err;\r\n}\r\nadap->dvb_adap.priv = adap;\r\nadap->demux.dmx.capabilities = DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING;\r\nadap->demux.priv = adap;\r\nadap->demux.filternum = 256;\r\nadap->demux.feednum = 256;\r\nadap->demux.start_feed = pvr2_dvb_start_feed;\r\nadap->demux.stop_feed = pvr2_dvb_stop_feed;\r\nadap->demux.write_to_decoder = NULL;\r\nret = dvb_dmx_init(&adap->demux);\r\nif (ret < 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"dvb_dmx_init failed: error %d", ret);\r\ngoto err_dmx;\r\n}\r\nadap->dmxdev.filternum = adap->demux.filternum;\r\nadap->dmxdev.demux = &adap->demux.dmx;\r\nadap->dmxdev.capabilities = 0;\r\nret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap);\r\nif (ret < 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"dvb_dmxdev_init failed: error %d", ret);\r\ngoto err_dmx_dev;\r\n}\r\ndvb_net_init(&adap->dvb_adap, &adap->dvb_net, &adap->demux.dmx);\r\nreturn 0;\r\nerr_dmx_dev:\r\ndvb_dmx_release(&adap->demux);\r\nerr_dmx:\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int pvr2_dvb_adapter_exit(struct pvr2_dvb_adapter *adap)\r\n{\r\npvr2_trace(PVR2_TRACE_INFO, "unregistering DVB devices");\r\ndvb_net_release(&adap->dvb_net);\r\nadap->demux.dmx.close(&adap->demux.dmx);\r\ndvb_dmxdev_release(&adap->dmxdev);\r\ndvb_dmx_release(&adap->demux);\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\nreturn 0;\r\n}\r\nstatic int pvr2_dvb_frontend_init(struct pvr2_dvb_adapter *adap)\r\n{\r\nstruct pvr2_hdw *hdw = adap->channel.hdw;\r\nconst struct pvr2_dvb_props *dvb_props = hdw->hdw_desc->dvb_props;\r\nint ret = 0;\r\nif (dvb_props == NULL) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS, "fe_props not defined!");\r\nreturn -EINVAL;\r\n}\r\nret = pvr2_channel_limit_inputs(\r\n&adap->channel,\r\n(1 << PVR2_CVAL_INPUT_DTV));\r\nif (ret) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"failed to grab control of dtv input (code=%d)",\r\nret);\r\nreturn ret;\r\n}\r\nif (dvb_props->frontend_attach == NULL) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"frontend_attach not defined!");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif ((dvb_props->frontend_attach(adap) == 0) && (adap->fe)) {\r\nif (dvb_register_frontend(&adap->dvb_adap, adap->fe)) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"frontend registration failed!");\r\ndvb_frontend_detach(adap->fe);\r\nadap->fe = NULL;\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif (dvb_props->tuner_attach)\r\ndvb_props->tuner_attach(adap);\r\nif (adap->fe->ops.analog_ops.standby)\r\nadap->fe->ops.analog_ops.standby(adap->fe);\r\nadap->fe->ops.ts_bus_ctrl = pvr2_dvb_bus_ctrl;\r\n} else {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"no frontend was attached!");\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\ndone:\r\npvr2_channel_limit_inputs(&adap->channel, 0);\r\nreturn ret;\r\n}\r\nstatic int pvr2_dvb_frontend_exit(struct pvr2_dvb_adapter *adap)\r\n{\r\nif (adap->fe != NULL) {\r\ndvb_unregister_frontend(adap->fe);\r\ndvb_frontend_detach(adap->fe);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pvr2_dvb_destroy(struct pvr2_dvb_adapter *adap)\r\n{\r\npvr2_dvb_stream_end(adap);\r\npvr2_dvb_frontend_exit(adap);\r\npvr2_dvb_adapter_exit(adap);\r\npvr2_channel_done(&adap->channel);\r\nkfree(adap);\r\n}\r\nstatic void pvr2_dvb_internal_check(struct pvr2_channel *chp)\r\n{\r\nstruct pvr2_dvb_adapter *adap;\r\nadap = container_of(chp, struct pvr2_dvb_adapter, channel);\r\nif (!adap->channel.mc_head->disconnect_flag) return;\r\npvr2_dvb_destroy(adap);\r\n}\r\nstruct pvr2_dvb_adapter *pvr2_dvb_create(struct pvr2_context *pvr)\r\n{\r\nint ret = 0;\r\nstruct pvr2_dvb_adapter *adap;\r\nif (!pvr->hdw->hdw_desc->dvb_props) {\r\nreturn NULL;\r\n}\r\nadap = kzalloc(sizeof(*adap), GFP_KERNEL);\r\nif (!adap) return adap;\r\npvr2_channel_init(&adap->channel, pvr);\r\nadap->channel.check_func = pvr2_dvb_internal_check;\r\ninit_waitqueue_head(&adap->buffer_wait_data);\r\nmutex_init(&adap->lock);\r\nret = pvr2_dvb_adapter_init(adap);\r\nif (ret < 0) goto fail1;\r\nret = pvr2_dvb_frontend_init(adap);\r\nif (ret < 0) goto fail2;\r\nreturn adap;\r\nfail2:\r\npvr2_dvb_adapter_exit(adap);\r\nfail1:\r\npvr2_channel_done(&adap->channel);\r\nreturn NULL;\r\n}
