static int\r\nvcs_notifier(struct notifier_block *nb, unsigned long code, void *_param)\r\n{\r\nstruct vt_notifier_param *param = _param;\r\nstruct vc_data *vc = param->vc;\r\nstruct vcs_poll_data *poll =\r\ncontainer_of(nb, struct vcs_poll_data, notifier);\r\nint currcons = poll->cons_num;\r\nif (code != VT_UPDATE)\r\nreturn NOTIFY_DONE;\r\nif (currcons == 0)\r\ncurrcons = fg_console;\r\nelse\r\ncurrcons--;\r\nif (currcons != vc->vc_num)\r\nreturn NOTIFY_DONE;\r\npoll->seen_last_update = false;\r\nwake_up_interruptible(&poll->waitq);\r\nkill_fasync(&poll->fasync, SIGIO, POLL_IN);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void\r\nvcs_poll_data_free(struct vcs_poll_data *poll)\r\n{\r\nunregister_vt_notifier(&poll->notifier);\r\nkfree(poll);\r\n}\r\nstatic struct vcs_poll_data *\r\nvcs_poll_data_get(struct file *file)\r\n{\r\nstruct vcs_poll_data *poll = file->private_data;\r\nif (poll)\r\nreturn poll;\r\npoll = kzalloc(sizeof(*poll), GFP_KERNEL);\r\nif (!poll)\r\nreturn NULL;\r\npoll->cons_num = iminor(file->f_path.dentry->d_inode) & 127;\r\ninit_waitqueue_head(&poll->waitq);\r\npoll->notifier.notifier_call = vcs_notifier;\r\nif (register_vt_notifier(&poll->notifier) != 0) {\r\nkfree(poll);\r\nreturn NULL;\r\n}\r\nspin_lock(&file->f_lock);\r\nif (!file->private_data) {\r\nfile->private_data = poll;\r\n} else {\r\nvcs_poll_data_free(poll);\r\npoll = file->private_data;\r\n}\r\nspin_unlock(&file->f_lock);\r\nreturn poll;\r\n}\r\nstatic struct vc_data*\r\nvcs_vc(struct inode *inode, int *viewed)\r\n{\r\nunsigned int currcons = iminor(inode) & 127;\r\nWARN_CONSOLE_UNLOCKED();\r\nif (currcons == 0) {\r\ncurrcons = fg_console;\r\nif (viewed)\r\n*viewed = 1;\r\n} else {\r\ncurrcons--;\r\nif (viewed)\r\n*viewed = 0;\r\n}\r\nreturn vc_cons[currcons].d;\r\n}\r\nstatic int\r\nvcs_size(struct inode *inode)\r\n{\r\nint size;\r\nint minor = iminor(inode);\r\nstruct vc_data *vc;\r\nWARN_CONSOLE_UNLOCKED();\r\nvc = vcs_vc(inode, NULL);\r\nif (!vc)\r\nreturn -ENXIO;\r\nsize = vc->vc_rows * vc->vc_cols;\r\nif (minor & 128)\r\nsize = 2*size + HEADER_SIZE;\r\nreturn size;\r\n}\r\nstatic loff_t vcs_lseek(struct file *file, loff_t offset, int orig)\r\n{\r\nint size;\r\nconsole_lock();\r\nsize = vcs_size(file->f_path.dentry->d_inode);\r\nconsole_unlock();\r\nif (size < 0)\r\nreturn size;\r\nswitch (orig) {\r\ndefault:\r\nreturn -EINVAL;\r\ncase 2:\r\noffset += size;\r\nbreak;\r\ncase 1:\r\noffset += file->f_pos;\r\ncase 0:\r\nbreak;\r\n}\r\nif (offset < 0 || offset > size) {\r\nreturn -EINVAL;\r\n}\r\nfile->f_pos = offset;\r\nreturn file->f_pos;\r\n}\r\nstatic ssize_t\r\nvcs_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nunsigned int currcons = iminor(inode);\r\nstruct vc_data *vc;\r\nstruct vcs_poll_data *poll;\r\nlong pos;\r\nlong attr, read;\r\nint col, maxcol, viewed;\r\nunsigned short *org = NULL;\r\nssize_t ret;\r\nchar *con_buf;\r\ncon_buf = (char *) __get_free_page(GFP_KERNEL);\r\nif (!con_buf)\r\nreturn -ENOMEM;\r\npos = *ppos;\r\nconsole_lock();\r\nattr = (currcons & 128);\r\nret = -ENXIO;\r\nvc = vcs_vc(inode, &viewed);\r\nif (!vc)\r\ngoto unlock_out;\r\nret = -EINVAL;\r\nif (pos < 0)\r\ngoto unlock_out;\r\npoll = file->private_data;\r\nif (count && poll)\r\npoll->seen_last_update = true;\r\nread = 0;\r\nret = 0;\r\nwhile (count) {\r\nchar *con_buf0, *con_buf_start;\r\nlong this_round, size;\r\nssize_t orig_count;\r\nlong p = pos;\r\nsize = vcs_size(inode);\r\nif (size < 0) {\r\nif (read)\r\nbreak;\r\nret = size;\r\ngoto unlock_out;\r\n}\r\nif (pos >= size)\r\nbreak;\r\nif (count > size - pos)\r\ncount = size - pos;\r\nthis_round = count;\r\nif (this_round > CON_BUF_SIZE)\r\nthis_round = CON_BUF_SIZE;\r\ncon_buf_start = con_buf0 = con_buf;\r\norig_count = this_round;\r\nmaxcol = vc->vc_cols;\r\nif (!attr) {\r\norg = screen_pos(vc, p, viewed);\r\ncol = p % maxcol;\r\np += maxcol - col;\r\nwhile (this_round-- > 0) {\r\n*con_buf0++ = (vcs_scr_readw(vc, org++) & 0xff);\r\nif (++col == maxcol) {\r\norg = screen_pos(vc, p, viewed);\r\ncol = 0;\r\np += maxcol;\r\n}\r\n}\r\n} else {\r\nif (p < HEADER_SIZE) {\r\nsize_t tmp_count;\r\ncon_buf0[0] = (char)vc->vc_rows;\r\ncon_buf0[1] = (char)vc->vc_cols;\r\ngetconsxy(vc, con_buf0 + 2);\r\ncon_buf_start += p;\r\nthis_round += p;\r\nif (this_round > CON_BUF_SIZE) {\r\nthis_round = CON_BUF_SIZE;\r\norig_count = this_round - p;\r\n}\r\ntmp_count = HEADER_SIZE;\r\nif (tmp_count > this_round)\r\ntmp_count = this_round;\r\nthis_round -= tmp_count;\r\np = HEADER_SIZE;\r\ncon_buf0 = con_buf + HEADER_SIZE;\r\n} else if (p & 1) {\r\ncon_buf_start++;\r\nif (this_round < CON_BUF_SIZE)\r\nthis_round++;\r\nelse\r\norig_count--;\r\n}\r\nif (this_round > 0) {\r\nunsigned short *tmp_buf = (unsigned short *)con_buf0;\r\np -= HEADER_SIZE;\r\np /= 2;\r\ncol = p % maxcol;\r\norg = screen_pos(vc, p, viewed);\r\np += maxcol - col;\r\nthis_round = (this_round + 1) >> 1;\r\nwhile (this_round) {\r\n*tmp_buf++ = vcs_scr_readw(vc, org++);\r\nthis_round --;\r\nif (++col == maxcol) {\r\norg = screen_pos(vc, p, viewed);\r\ncol = 0;\r\np += maxcol;\r\n}\r\n}\r\n}\r\n}\r\nconsole_unlock();\r\nret = copy_to_user(buf, con_buf_start, orig_count);\r\nconsole_lock();\r\nif (ret) {\r\nread += (orig_count - ret);\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nbuf += orig_count;\r\npos += orig_count;\r\nread += orig_count;\r\ncount -= orig_count;\r\n}\r\n*ppos += read;\r\nif (read)\r\nret = read;\r\nunlock_out:\r\nconsole_unlock();\r\nfree_page((unsigned long) con_buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nunsigned int currcons = iminor(inode);\r\nstruct vc_data *vc;\r\nlong pos;\r\nlong attr, size, written;\r\nchar *con_buf0;\r\nint col, maxcol, viewed;\r\nu16 *org0 = NULL, *org = NULL;\r\nsize_t ret;\r\nchar *con_buf;\r\ncon_buf = (char *) __get_free_page(GFP_KERNEL);\r\nif (!con_buf)\r\nreturn -ENOMEM;\r\npos = *ppos;\r\nconsole_lock();\r\nattr = (currcons & 128);\r\nret = -ENXIO;\r\nvc = vcs_vc(inode, &viewed);\r\nif (!vc)\r\ngoto unlock_out;\r\nsize = vcs_size(inode);\r\nret = -EINVAL;\r\nif (pos < 0 || pos > size)\r\ngoto unlock_out;\r\nif (count > size - pos)\r\ncount = size - pos;\r\nwritten = 0;\r\nwhile (count) {\r\nlong this_round = count;\r\nsize_t orig_count;\r\nlong p;\r\nif (this_round > CON_BUF_SIZE)\r\nthis_round = CON_BUF_SIZE;\r\nconsole_unlock();\r\nret = copy_from_user(con_buf, buf, this_round);\r\nconsole_lock();\r\nif (ret) {\r\nthis_round -= ret;\r\nif (!this_round) {\r\nif (written)\r\nbreak;\r\nret = -EFAULT;\r\ngoto unlock_out;\r\n}\r\n}\r\nsize = vcs_size(inode);\r\nif (size < 0) {\r\nif (written)\r\nbreak;\r\nret = size;\r\ngoto unlock_out;\r\n}\r\nif (pos >= size)\r\nbreak;\r\nif (this_round > size - pos)\r\nthis_round = size - pos;\r\ncon_buf0 = con_buf;\r\norig_count = this_round;\r\nmaxcol = vc->vc_cols;\r\np = pos;\r\nif (!attr) {\r\norg0 = org = screen_pos(vc, p, viewed);\r\ncol = p % maxcol;\r\np += maxcol - col;\r\nwhile (this_round > 0) {\r\nunsigned char c = *con_buf0++;\r\nthis_round--;\r\nvcs_scr_writew(vc,\r\n(vcs_scr_readw(vc, org) & 0xff00) | c, org);\r\norg++;\r\nif (++col == maxcol) {\r\norg = screen_pos(vc, p, viewed);\r\ncol = 0;\r\np += maxcol;\r\n}\r\n}\r\n} else {\r\nif (p < HEADER_SIZE) {\r\nchar header[HEADER_SIZE];\r\ngetconsxy(vc, header + 2);\r\nwhile (p < HEADER_SIZE && this_round > 0) {\r\nthis_round--;\r\nheader[p++] = *con_buf0++;\r\n}\r\nif (!viewed)\r\nputconsxy(vc, header + 2);\r\n}\r\np -= HEADER_SIZE;\r\ncol = (p/2) % maxcol;\r\nif (this_round > 0) {\r\norg0 = org = screen_pos(vc, p/2, viewed);\r\nif ((p & 1) && this_round > 0) {\r\nchar c;\r\nthis_round--;\r\nc = *con_buf0++;\r\n#ifdef __BIG_ENDIAN\r\nvcs_scr_writew(vc, c |\r\n(vcs_scr_readw(vc, org) & 0xff00), org);\r\n#else\r\nvcs_scr_writew(vc, (c << 8) |\r\n(vcs_scr_readw(vc, org) & 0xff), org);\r\n#endif\r\norg++;\r\np++;\r\nif (++col == maxcol) {\r\norg = screen_pos(vc, p/2, viewed);\r\ncol = 0;\r\n}\r\n}\r\np /= 2;\r\np += maxcol - col;\r\n}\r\nwhile (this_round > 1) {\r\nunsigned short w;\r\nw = get_unaligned(((unsigned short *)con_buf0));\r\nvcs_scr_writew(vc, w, org++);\r\ncon_buf0 += 2;\r\nthis_round -= 2;\r\nif (++col == maxcol) {\r\norg = screen_pos(vc, p, viewed);\r\ncol = 0;\r\np += maxcol;\r\n}\r\n}\r\nif (this_round > 0) {\r\nunsigned char c;\r\nc = *con_buf0++;\r\n#ifdef __BIG_ENDIAN\r\nvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\r\n#else\r\nvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\r\n#endif\r\n}\r\n}\r\ncount -= orig_count;\r\nwritten += orig_count;\r\nbuf += orig_count;\r\npos += orig_count;\r\nif (org0)\r\nupdate_region(vc, (unsigned long)(org0), org - org0);\r\n}\r\n*ppos += written;\r\nret = written;\r\nif (written)\r\nvcs_scr_updated(vc);\r\nunlock_out:\r\nconsole_unlock();\r\nfree_page((unsigned long) con_buf);\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nvcs_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct vcs_poll_data *poll = vcs_poll_data_get(file);\r\nint ret = DEFAULT_POLLMASK|POLLERR|POLLPRI;\r\nif (poll) {\r\npoll_wait(file, &poll->waitq, wait);\r\nif (poll->seen_last_update)\r\nret = DEFAULT_POLLMASK;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nvcs_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct vcs_poll_data *poll = file->private_data;\r\nif (!poll) {\r\nif (!on)\r\nreturn 0;\r\npoll = vcs_poll_data_get(file);\r\nif (!poll)\r\nreturn -ENOMEM;\r\n}\r\nreturn fasync_helper(fd, file, on, &poll->fasync);\r\n}\r\nstatic int\r\nvcs_open(struct inode *inode, struct file *filp)\r\n{\r\nunsigned int currcons = iminor(inode) & 127;\r\nint ret = 0;\r\ntty_lock();\r\nif(currcons && !vc_cons_allocated(currcons-1))\r\nret = -ENXIO;\r\ntty_unlock();\r\nreturn ret;\r\n}\r\nstatic int vcs_release(struct inode *inode, struct file *file)\r\n{\r\nstruct vcs_poll_data *poll = file->private_data;\r\nif (poll)\r\nvcs_poll_data_free(poll);\r\nreturn 0;\r\n}\r\nvoid vcs_make_sysfs(int index)\r\n{\r\ndevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, index + 1), NULL,\r\n"vcs%u", index + 1);\r\ndevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, index + 129), NULL,\r\n"vcsa%u", index + 1);\r\n}\r\nvoid vcs_remove_sysfs(int index)\r\n{\r\ndevice_destroy(vc_class, MKDEV(VCS_MAJOR, index + 1));\r\ndevice_destroy(vc_class, MKDEV(VCS_MAJOR, index + 129));\r\n}\r\nint __init vcs_init(void)\r\n{\r\nunsigned int i;\r\nif (register_chrdev(VCS_MAJOR, "vcs", &vcs_fops))\r\npanic("unable to get major %d for vcs device", VCS_MAJOR);\r\nvc_class = class_create(THIS_MODULE, "vc");\r\ndevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, 0), NULL, "vcs");\r\ndevice_create(vc_class, NULL, MKDEV(VCS_MAJOR, 128), NULL, "vcsa");\r\nfor (i = 0; i < MIN_NR_CONSOLES; i++)\r\nvcs_make_sysfs(i);\r\nreturn 0;\r\n}
