int\r\nnv50_pm_clock_get(struct drm_device *dev, u32 id)\r\n{\r\nstruct pll_lims pll;\r\nint P, N, M, ret;\r\nu32 reg0, reg1;\r\nret = get_pll_limits(dev, id, &pll);\r\nif (ret)\r\nreturn ret;\r\nreg0 = nv_rd32(dev, pll.reg + 0);\r\nreg1 = nv_rd32(dev, pll.reg + 4);\r\nif ((reg0 & 0x80000000) == 0) {\r\nif (id == PLL_SHADER) {\r\nNV_DEBUG(dev, "Shader PLL is disabled. "\r\n"Shader clock is twice the core\n");\r\nret = nv50_pm_clock_get(dev, PLL_CORE);\r\nif (ret > 0)\r\nreturn ret << 1;\r\n} else if (id == PLL_MEMORY) {\r\nNV_DEBUG(dev, "Memory PLL is disabled. "\r\n"Memory clock is equal to the ref_clk\n");\r\nreturn pll.refclk;\r\n}\r\n}\r\nP = (reg0 & 0x00070000) >> 16;\r\nN = (reg1 & 0x0000ff00) >> 8;\r\nM = (reg1 & 0x000000ff);\r\nreturn ((pll.refclk * N / M) >> P);\r\n}\r\nvoid *\r\nnv50_pm_clock_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl,\r\nu32 id, int khz)\r\n{\r\nstruct nv50_pm_state *state;\r\nint dummy, ret;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn ERR_PTR(-ENOMEM);\r\nstate->type = id;\r\nstate->perflvl = perflvl;\r\nret = get_pll_limits(dev, id, &state->pll);\r\nif (ret < 0) {\r\nkfree(state);\r\nreturn (ret == -ENOENT) ? NULL : ERR_PTR(ret);\r\n}\r\nret = nv50_calc_pll(dev, &state->pll, khz, &state->N, &state->M,\r\n&dummy, &dummy, &state->P);\r\nif (ret < 0) {\r\nkfree(state);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn state;\r\n}\r\nvoid\r\nnv50_pm_clock_set(struct drm_device *dev, void *pre_state)\r\n{\r\nstruct nv50_pm_state *state = pre_state;\r\nstruct nouveau_pm_level *perflvl = state->perflvl;\r\nu32 reg = state->pll.reg, tmp;\r\nstruct bit_entry BIT_M;\r\nu16 script;\r\nint N = state->N;\r\nint M = state->M;\r\nint P = state->P;\r\nif (state->type == PLL_MEMORY && perflvl->memscript &&\r\nbit_table(dev, 'M', &BIT_M) == 0 &&\r\nBIT_M.version == 1 && BIT_M.length >= 0x0b) {\r\nscript = ROM16(BIT_M.data[0x05]);\r\nif (script)\r\nnouveau_bios_run_init_table(dev, script, NULL);\r\nscript = ROM16(BIT_M.data[0x07]);\r\nif (script)\r\nnouveau_bios_run_init_table(dev, script, NULL);\r\nscript = ROM16(BIT_M.data[0x09]);\r\nif (script)\r\nnouveau_bios_run_init_table(dev, script, NULL);\r\nnouveau_bios_run_init_table(dev, perflvl->memscript, NULL);\r\n}\r\nif (state->type == PLL_MEMORY) {\r\nnv_wr32(dev, 0x100210, 0);\r\nnv_wr32(dev, 0x1002dc, 1);\r\n}\r\ntmp = nv_rd32(dev, reg + 0) & 0xfff8ffff;\r\ntmp |= 0x80000000 | (P << 16);\r\nnv_wr32(dev, reg + 0, tmp);\r\nnv_wr32(dev, reg + 4, (N << 8) | M);\r\nif (state->type == PLL_MEMORY) {\r\nnv_wr32(dev, 0x1002dc, 0);\r\nnv_wr32(dev, 0x100210, 0x80000000);\r\n}\r\nkfree(state);\r\n}
