static int convert_prio(int prio)\r\n{\r\nint cpupri;\r\nif (prio == CPUPRI_INVALID)\r\ncpupri = CPUPRI_INVALID;\r\nelse if (prio == MAX_PRIO)\r\ncpupri = CPUPRI_IDLE;\r\nelse if (prio >= MAX_RT_PRIO)\r\ncpupri = CPUPRI_NORMAL;\r\nelse\r\ncpupri = MAX_RT_PRIO - prio + 1;\r\nreturn cpupri;\r\n}\r\nint cpupri_find(struct cpupri *cp, struct task_struct *p,\r\nstruct cpumask *lowest_mask)\r\n{\r\nint idx = 0;\r\nint task_pri = convert_prio(p->prio);\r\nfor_each_cpupri_active(cp->pri_active, idx) {\r\nstruct cpupri_vec *vec = &cp->pri_to_cpu[idx];\r\nif (idx >= task_pri)\r\nbreak;\r\nif (cpumask_any_and(&p->cpus_allowed, vec->mask) >= nr_cpu_ids)\r\ncontinue;\r\nif (lowest_mask) {\r\ncpumask_and(lowest_mask, &p->cpus_allowed, vec->mask);\r\nif (cpumask_any(lowest_mask) >= nr_cpu_ids)\r\ncontinue;\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid cpupri_set(struct cpupri *cp, int cpu, int newpri)\r\n{\r\nint *currpri = &cp->cpu_to_pri[cpu];\r\nint oldpri = *currpri;\r\nunsigned long flags;\r\nnewpri = convert_prio(newpri);\r\nBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\r\nif (newpri == oldpri)\r\nreturn;\r\nif (likely(newpri != CPUPRI_INVALID)) {\r\nstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\r\nraw_spin_lock_irqsave(&vec->lock, flags);\r\ncpumask_set_cpu(cpu, vec->mask);\r\nvec->count++;\r\nif (vec->count == 1)\r\nset_bit(newpri, cp->pri_active);\r\nraw_spin_unlock_irqrestore(&vec->lock, flags);\r\n}\r\nif (likely(oldpri != CPUPRI_INVALID)) {\r\nstruct cpupri_vec *vec = &cp->pri_to_cpu[oldpri];\r\nraw_spin_lock_irqsave(&vec->lock, flags);\r\nvec->count--;\r\nif (!vec->count)\r\nclear_bit(oldpri, cp->pri_active);\r\ncpumask_clear_cpu(cpu, vec->mask);\r\nraw_spin_unlock_irqrestore(&vec->lock, flags);\r\n}\r\n*currpri = newpri;\r\n}\r\nint cpupri_init(struct cpupri *cp)\r\n{\r\nint i;\r\nmemset(cp, 0, sizeof(*cp));\r\nfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\r\nstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\r\nraw_spin_lock_init(&vec->lock);\r\nvec->count = 0;\r\nif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\r\ngoto cleanup;\r\n}\r\nfor_each_possible_cpu(i)\r\ncp->cpu_to_pri[i] = CPUPRI_INVALID;\r\nreturn 0;\r\ncleanup:\r\nfor (i--; i >= 0; i--)\r\nfree_cpumask_var(cp->pri_to_cpu[i].mask);\r\nreturn -ENOMEM;\r\n}\r\nvoid cpupri_cleanup(struct cpupri *cp)\r\n{\r\nint i;\r\nfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\r\nfree_cpumask_var(cp->pri_to_cpu[i].mask);\r\n}
