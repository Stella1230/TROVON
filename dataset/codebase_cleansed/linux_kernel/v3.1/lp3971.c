static int lp3971_ldo_list_voltage(struct regulator_dev *dev, unsigned index)\r\n{\r\nint ldo = rdev_get_id(dev) - LP3971_LDO1;\r\nreturn 1000 * LDO_VOL_VALUE_MAP(ldo)[index];\r\n}\r\nstatic int lp3971_ldo_is_enabled(struct regulator_dev *dev)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint ldo = rdev_get_id(dev) - LP3971_LDO1;\r\nu16 mask = 1 << (1 + ldo);\r\nu16 val;\r\nval = lp3971_reg_read(lp3971, LP3971_LDO_ENABLE_REG);\r\nreturn (val & mask) != 0;\r\n}\r\nstatic int lp3971_ldo_enable(struct regulator_dev *dev)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint ldo = rdev_get_id(dev) - LP3971_LDO1;\r\nu16 mask = 1 << (1 + ldo);\r\nreturn lp3971_set_bits(lp3971, LP3971_LDO_ENABLE_REG, mask, mask);\r\n}\r\nstatic int lp3971_ldo_disable(struct regulator_dev *dev)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint ldo = rdev_get_id(dev) - LP3971_LDO1;\r\nu16 mask = 1 << (1 + ldo);\r\nreturn lp3971_set_bits(lp3971, LP3971_LDO_ENABLE_REG, mask, 0);\r\n}\r\nstatic int lp3971_ldo_get_voltage(struct regulator_dev *dev)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint ldo = rdev_get_id(dev) - LP3971_LDO1;\r\nu16 val, reg;\r\nreg = lp3971_reg_read(lp3971, LP3971_LDO_VOL_CONTR_REG(ldo));\r\nval = (reg >> LDO_VOL_CONTR_SHIFT(ldo)) & LDO_VOL_CONTR_MASK;\r\nreturn 1000 * LDO_VOL_VALUE_MAP(ldo)[val];\r\n}\r\nstatic int lp3971_ldo_set_voltage(struct regulator_dev *dev,\r\nint min_uV, int max_uV,\r\nunsigned int *selector)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint ldo = rdev_get_id(dev) - LP3971_LDO1;\r\nint min_vol = min_uV / 1000, max_vol = max_uV / 1000;\r\nconst int *vol_map = LDO_VOL_VALUE_MAP(ldo);\r\nu16 val;\r\nif (min_vol < vol_map[LDO_VOL_MIN_IDX] ||\r\nmin_vol > vol_map[LDO_VOL_MAX_IDX])\r\nreturn -EINVAL;\r\nfor (val = LDO_VOL_MIN_IDX; val <= LDO_VOL_MAX_IDX; val++)\r\nif (vol_map[val] >= min_vol)\r\nbreak;\r\nif (val > LDO_VOL_MAX_IDX || vol_map[val] > max_vol)\r\nreturn -EINVAL;\r\n*selector = val;\r\nreturn lp3971_set_bits(lp3971, LP3971_LDO_VOL_CONTR_REG(ldo),\r\nLDO_VOL_CONTR_MASK << LDO_VOL_CONTR_SHIFT(ldo),\r\nval << LDO_VOL_CONTR_SHIFT(ldo));\r\n}\r\nstatic int lp3971_dcdc_list_voltage(struct regulator_dev *dev, unsigned index)\r\n{\r\nreturn 1000 * buck_voltage_map[index];\r\n}\r\nstatic int lp3971_dcdc_is_enabled(struct regulator_dev *dev)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint buck = rdev_get_id(dev) - LP3971_DCDC1;\r\nu16 mask = 1 << (buck * 2);\r\nu16 val;\r\nval = lp3971_reg_read(lp3971, LP3971_BUCK_VOL_ENABLE_REG);\r\nreturn (val & mask) != 0;\r\n}\r\nstatic int lp3971_dcdc_enable(struct regulator_dev *dev)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint buck = rdev_get_id(dev) - LP3971_DCDC1;\r\nu16 mask = 1 << (buck * 2);\r\nreturn lp3971_set_bits(lp3971, LP3971_BUCK_VOL_ENABLE_REG, mask, mask);\r\n}\r\nstatic int lp3971_dcdc_disable(struct regulator_dev *dev)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint buck = rdev_get_id(dev) - LP3971_DCDC1;\r\nu16 mask = 1 << (buck * 2);\r\nreturn lp3971_set_bits(lp3971, LP3971_BUCK_VOL_ENABLE_REG, mask, 0);\r\n}\r\nstatic int lp3971_dcdc_get_voltage(struct regulator_dev *dev)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint buck = rdev_get_id(dev) - LP3971_DCDC1;\r\nu16 reg;\r\nint val;\r\nreg = lp3971_reg_read(lp3971, LP3971_BUCK_TARGET_VOL1_REG(buck));\r\nreg &= BUCK_TARGET_VOL_MASK;\r\nif (reg <= BUCK_TARGET_VOL_MAX_IDX)\r\nval = 1000 * buck_voltage_map[reg];\r\nelse {\r\nval = 0;\r\ndev_warn(&dev->dev, "chip reported incorrect voltage value.\n");\r\n}\r\nreturn val;\r\n}\r\nstatic int lp3971_dcdc_set_voltage(struct regulator_dev *dev,\r\nint min_uV, int max_uV,\r\nunsigned int *selector)\r\n{\r\nstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\r\nint buck = rdev_get_id(dev) - LP3971_DCDC1;\r\nint min_vol = min_uV / 1000, max_vol = max_uV / 1000;\r\nconst int *vol_map = buck_voltage_map;\r\nu16 val;\r\nint ret;\r\nif (min_vol < vol_map[BUCK_TARGET_VOL_MIN_IDX] ||\r\nmin_vol > vol_map[BUCK_TARGET_VOL_MAX_IDX])\r\nreturn -EINVAL;\r\nfor (val = BUCK_TARGET_VOL_MIN_IDX; val <= BUCK_TARGET_VOL_MAX_IDX;\r\nval++)\r\nif (vol_map[val] >= min_vol)\r\nbreak;\r\nif (val > BUCK_TARGET_VOL_MAX_IDX || vol_map[val] > max_vol)\r\nreturn -EINVAL;\r\n*selector = val;\r\nret = lp3971_set_bits(lp3971, LP3971_BUCK_TARGET_VOL1_REG(buck),\r\nBUCK_TARGET_VOL_MASK, val);\r\nif (ret)\r\nreturn ret;\r\nret = lp3971_set_bits(lp3971, LP3971_BUCK_VOL_CHANGE_REG,\r\nBUCK_VOL_CHANGE_FLAG_MASK << BUCK_VOL_CHANGE_SHIFT(buck),\r\nBUCK_VOL_CHANGE_FLAG_GO << BUCK_VOL_CHANGE_SHIFT(buck));\r\nif (ret)\r\nreturn ret;\r\nreturn lp3971_set_bits(lp3971, LP3971_BUCK_VOL_CHANGE_REG,\r\nBUCK_VOL_CHANGE_FLAG_MASK << BUCK_VOL_CHANGE_SHIFT(buck),\r\n0 << BUCK_VOL_CHANGE_SHIFT(buck));\r\n}\r\nstatic int lp3971_i2c_read(struct i2c_client *i2c, char reg, int count,\r\nu16 *dest)\r\n{\r\nint ret;\r\nif (count != 1)\r\nreturn -EIO;\r\nret = i2c_smbus_read_byte_data(i2c, reg);\r\nif (ret < 0)\r\nreturn -EIO;\r\n*dest = ret;\r\nreturn 0;\r\n}\r\nstatic int lp3971_i2c_write(struct i2c_client *i2c, char reg, int count,\r\nconst u16 *src)\r\n{\r\nif (count != 1)\r\nreturn -EIO;\r\nreturn i2c_smbus_write_byte_data(i2c, reg, *src);\r\n}\r\nstatic u8 lp3971_reg_read(struct lp3971 *lp3971, u8 reg)\r\n{\r\nu16 val = 0;\r\nmutex_lock(&lp3971->io_lock);\r\nlp3971_i2c_read(lp3971->i2c, reg, 1, &val);\r\ndev_dbg(lp3971->dev, "reg read 0x%02x -> 0x%02x\n", (int)reg,\r\n(unsigned)val&0xff);\r\nmutex_unlock(&lp3971->io_lock);\r\nreturn val & 0xff;\r\n}\r\nstatic int lp3971_set_bits(struct lp3971 *lp3971, u8 reg, u16 mask, u16 val)\r\n{\r\nu16 tmp;\r\nint ret;\r\nmutex_lock(&lp3971->io_lock);\r\nret = lp3971_i2c_read(lp3971->i2c, reg, 1, &tmp);\r\ntmp = (tmp & ~mask) | val;\r\nif (ret == 0) {\r\nret = lp3971_i2c_write(lp3971->i2c, reg, 1, &tmp);\r\ndev_dbg(lp3971->dev, "reg write 0x%02x -> 0x%02x\n", (int)reg,\r\n(unsigned)val&0xff);\r\n}\r\nmutex_unlock(&lp3971->io_lock);\r\nreturn ret;\r\n}\r\nstatic int __devinit setup_regulators(struct lp3971 *lp3971,\r\nstruct lp3971_platform_data *pdata)\r\n{\r\nint i, err;\r\nlp3971->num_regulators = pdata->num_regulators;\r\nlp3971->rdev = kcalloc(pdata->num_regulators,\r\nsizeof(struct regulator_dev *), GFP_KERNEL);\r\nif (!lp3971->rdev) {\r\nerr = -ENOMEM;\r\ngoto err_nomem;\r\n}\r\nfor (i = 0; i < pdata->num_regulators; i++) {\r\nstruct lp3971_regulator_subdev *reg = &pdata->regulators[i];\r\nlp3971->rdev[i] = regulator_register(&regulators[reg->id],\r\nlp3971->dev, reg->initdata, lp3971);\r\nif (IS_ERR(lp3971->rdev[i])) {\r\nerr = PTR_ERR(lp3971->rdev[i]);\r\ndev_err(lp3971->dev, "regulator init failed: %d\n",\r\nerr);\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nwhile (--i >= 0)\r\nregulator_unregister(lp3971->rdev[i]);\r\nkfree(lp3971->rdev);\r\nlp3971->rdev = NULL;\r\nerr_nomem:\r\nreturn err;\r\n}\r\nstatic int __devinit lp3971_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lp3971 *lp3971;\r\nstruct lp3971_platform_data *pdata = i2c->dev.platform_data;\r\nint ret;\r\nu16 val;\r\nif (!pdata) {\r\ndev_dbg(&i2c->dev, "No platform init data supplied\n");\r\nreturn -ENODEV;\r\n}\r\nlp3971 = kzalloc(sizeof(struct lp3971), GFP_KERNEL);\r\nif (lp3971 == NULL)\r\nreturn -ENOMEM;\r\nlp3971->i2c = i2c;\r\nlp3971->dev = &i2c->dev;\r\nmutex_init(&lp3971->io_lock);\r\nret = lp3971_i2c_read(i2c, LP3971_SYS_CONTROL1_REG, 1, &val);\r\nif (ret == 0 && (val & SYS_CONTROL1_INIT_MASK) != SYS_CONTROL1_INIT_VAL)\r\nret = -ENODEV;\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "failed to detect device\n");\r\ngoto err_detect;\r\n}\r\nret = setup_regulators(lp3971, pdata);\r\nif (ret < 0)\r\ngoto err_detect;\r\ni2c_set_clientdata(i2c, lp3971);\r\nreturn 0;\r\nerr_detect:\r\nkfree(lp3971);\r\nreturn ret;\r\n}\r\nstatic int __devexit lp3971_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct lp3971 *lp3971 = i2c_get_clientdata(i2c);\r\nint i;\r\nfor (i = 0; i < lp3971->num_regulators; i++)\r\nregulator_unregister(lp3971->rdev[i]);\r\nkfree(lp3971->rdev);\r\nkfree(lp3971);\r\nreturn 0;\r\n}\r\nstatic int __init lp3971_module_init(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&lp3971_i2c_driver);\r\nif (ret != 0)\r\npr_err("Failed to register I2C driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit lp3971_module_exit(void)\r\n{\r\ni2c_del_driver(&lp3971_i2c_driver);\r\n}
