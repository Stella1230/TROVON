static inline void disable_heartbeat(void)\r\n{\r\nif (mach_heartbeat) {\r\nsaved_heartbeat = mach_heartbeat;\r\nmach_heartbeat = NULL;\r\n}\r\nAmiSetTreble(dmasound.treble);\r\n}\r\nstatic inline void enable_heartbeat(void)\r\n{\r\nif (saved_heartbeat)\r\nmach_heartbeat = saved_heartbeat;\r\n}\r\nstatic ssize_t ami_ct_s8(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed, ssize_t frameLeft)\r\n{\r\nssize_t count, used;\r\nif (!dmasound.soft.stereo) {\r\nvoid *p = &frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft) & ~1;\r\nused = count;\r\nif (copy_from_user(p, userPtr, count))\r\nreturn -EFAULT;\r\n} else {\r\nu_char *left = &frame[*frameUsed>>1];\r\nu_char *right = left+write_sq_block_size_half;\r\ncount = min_t(unsigned long, userCount, frameLeft)>>1 & ~1;\r\nused = count*2;\r\nwhile (count > 0) {\r\nif (get_user(*left++, userPtr++)\r\n|| get_user(*right++, userPtr++))\r\nreturn -EFAULT;\r\ncount--;\r\n}\r\n}\r\n*frameUsed += used;\r\nreturn used;\r\n}\r\nstatic inline void StopDMA(void)\r\n{\r\ncustom.aud[0].audvol = custom.aud[1].audvol = 0;\r\ncustom.aud[2].audvol = custom.aud[3].audvol = 0;\r\ncustom.dmacon = AMI_AUDIO_OFF;\r\nenable_heartbeat();\r\n}\r\nstatic void *AmiAlloc(unsigned int size, gfp_t flags)\r\n{\r\nreturn amiga_chip_alloc((long)size, "dmasound [Paula]");\r\n}\r\nstatic void AmiFree(void *obj, unsigned int size)\r\n{\r\namiga_chip_free (obj);\r\n}\r\nstatic int __init AmiIrqInit(void)\r\n{\r\nStopDMA();\r\nif (request_irq(IRQ_AMIGA_AUD0, AmiInterrupt, 0, "DMA sound",\r\nAmiInterrupt))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void AmiIrqCleanUp(void)\r\n{\r\nStopDMA();\r\nfree_irq(IRQ_AMIGA_AUD0, AmiInterrupt);\r\n}\r\nstatic void AmiSilence(void)\r\n{\r\nStopDMA();\r\n}\r\nstatic void AmiInit(void)\r\n{\r\nint period, i;\r\nAmiSilence();\r\nif (dmasound.soft.speed)\r\nperiod = amiga_colorclock/dmasound.soft.speed-1;\r\nelse\r\nperiod = amiga_audio_min_period;\r\ndmasound.hard = dmasound.soft;\r\ndmasound.trans_write = &transAmiga;\r\nif (period < amiga_audio_min_period) {\r\nperiod = amiga_audio_min_period;\r\n} else if (period > 65535) {\r\nperiod = 65535;\r\n}\r\ndmasound.hard.speed = amiga_colorclock/(period+1);\r\nfor (i = 0; i < 4; i++)\r\ncustom.aud[i].audper = period;\r\namiga_audio_period = period;\r\n}\r\nstatic int AmiSetFormat(int format)\r\n{\r\nint size;\r\nswitch (format) {\r\ncase AFMT_QUERY:\r\nreturn dmasound.soft.format;\r\ncase AFMT_MU_LAW:\r\ncase AFMT_A_LAW:\r\ncase AFMT_U8:\r\ncase AFMT_S8:\r\nsize = 8;\r\nbreak;\r\ncase AFMT_S16_BE:\r\ncase AFMT_U16_BE:\r\ncase AFMT_S16_LE:\r\ncase AFMT_U16_LE:\r\nsize = 16;\r\nbreak;\r\ndefault:\r\nsize = 8;\r\nformat = AFMT_S8;\r\n}\r\ndmasound.soft.format = format;\r\ndmasound.soft.size = size;\r\nif (dmasound.minDev == SND_DEV_DSP) {\r\ndmasound.dsp.format = format;\r\ndmasound.dsp.size = dmasound.soft.size;\r\n}\r\nAmiInit();\r\nreturn format;\r\n}\r\nstatic int AmiSetVolume(int volume)\r\n{\r\ndmasound.volume_left = VOLUME_VOXWARE_TO_AMI(volume & 0xff);\r\ncustom.aud[0].audvol = dmasound.volume_left;\r\ndmasound.volume_right = VOLUME_VOXWARE_TO_AMI((volume & 0xff00) >> 8);\r\ncustom.aud[1].audvol = dmasound.volume_right;\r\nif (dmasound.hard.size == 16) {\r\nif (dmasound.volume_left == 64 && dmasound.volume_right == 64) {\r\ncustom.aud[2].audvol = 1;\r\ncustom.aud[3].audvol = 1;\r\n} else {\r\ncustom.aud[2].audvol = 0;\r\ncustom.aud[3].audvol = 0;\r\n}\r\n}\r\nreturn VOLUME_AMI_TO_VOXWARE(dmasound.volume_left) |\r\n(VOLUME_AMI_TO_VOXWARE(dmasound.volume_right) << 8);\r\n}\r\nstatic int AmiSetTreble(int treble)\r\n{\r\ndmasound.treble = treble;\r\nif (treble < 50)\r\nciaa.pra &= ~0x02;\r\nelse\r\nciaa.pra |= 0x02;\r\nreturn treble;\r\n}\r\nstatic void AmiPlayNextFrame(int index)\r\n{\r\nu_char *start, *ch0, *ch1, *ch2, *ch3;\r\nu_long size;\r\nstart = write_sq.buffers[write_sq.front];\r\nsize = (write_sq.count == index ? write_sq.rear_size\r\n: write_sq.block_size)>>1;\r\nif (dmasound.hard.stereo) {\r\nch0 = start;\r\nch1 = start+write_sq_block_size_half;\r\nsize >>= 1;\r\n} else {\r\nch0 = start;\r\nch1 = start;\r\n}\r\ndisable_heartbeat();\r\ncustom.aud[0].audvol = dmasound.volume_left;\r\ncustom.aud[1].audvol = dmasound.volume_right;\r\nif (dmasound.hard.size == 8) {\r\ncustom.aud[0].audlc = (u_short *)ZTWO_PADDR(ch0);\r\ncustom.aud[0].audlen = size;\r\ncustom.aud[1].audlc = (u_short *)ZTWO_PADDR(ch1);\r\ncustom.aud[1].audlen = size;\r\ncustom.dmacon = AMI_AUDIO_8;\r\n} else {\r\nsize >>= 1;\r\ncustom.aud[0].audlc = (u_short *)ZTWO_PADDR(ch0);\r\ncustom.aud[0].audlen = size;\r\ncustom.aud[1].audlc = (u_short *)ZTWO_PADDR(ch1);\r\ncustom.aud[1].audlen = size;\r\nif (dmasound.volume_left == 64 && dmasound.volume_right == 64) {\r\nch3 = ch0+write_sq_block_size_quarter;\r\nch2 = ch1+write_sq_block_size_quarter;\r\ncustom.aud[2].audvol = 1;\r\ncustom.aud[3].audvol = 1;\r\ncustom.aud[2].audlc = (u_short *)ZTWO_PADDR(ch2);\r\ncustom.aud[2].audlen = size;\r\ncustom.aud[3].audlc = (u_short *)ZTWO_PADDR(ch3);\r\ncustom.aud[3].audlen = size;\r\ncustom.dmacon = AMI_AUDIO_14;\r\n} else {\r\ncustom.aud[2].audvol = 0;\r\ncustom.aud[3].audvol = 0;\r\ncustom.dmacon = AMI_AUDIO_8;\r\n}\r\n}\r\nwrite_sq.front = (write_sq.front+1) % write_sq.max_count;\r\nwrite_sq.active |= AMI_PLAY_LOADED;\r\n}\r\nstatic void AmiPlay(void)\r\n{\r\nint minframes = 1;\r\ncustom.intena = IF_AUD0;\r\nif (write_sq.active & AMI_PLAY_LOADED) {\r\ncustom.intena = IF_SETCLR | IF_AUD0;\r\nreturn;\r\n}\r\nif (write_sq.active & AMI_PLAY_PLAYING)\r\nminframes = 2;\r\nif (write_sq.count < minframes) {\r\ncustom.intena = IF_SETCLR | IF_AUD0;\r\nreturn;\r\n}\r\nif (write_sq.count <= minframes &&\r\nwrite_sq.rear_size < write_sq.block_size && !write_sq.syncing) {\r\ncustom.intena = IF_SETCLR | IF_AUD0;\r\nreturn;\r\n}\r\nAmiPlayNextFrame(minframes);\r\ncustom.intena = IF_SETCLR | IF_AUD0;\r\n}\r\nstatic irqreturn_t AmiInterrupt(int irq, void *dummy)\r\n{\r\nint minframes = 1;\r\ncustom.intena = IF_AUD0;\r\nif (!write_sq.active) {\r\nWAKE_UP(write_sq.sync_queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (write_sq.active & AMI_PLAY_PLAYING) {\r\nwrite_sq.count--;\r\nWAKE_UP(write_sq.action_queue);\r\n}\r\nif (write_sq.active & AMI_PLAY_LOADED)\r\nminframes = 2;\r\nwrite_sq.active = (write_sq.active<<1) & AMI_PLAY_MASK;\r\nif (!write_sq.active)\r\nStopDMA();\r\ncustom.intena = IF_SETCLR | IF_AUD0;\r\nif (write_sq.count >= minframes)\r\nAmiPlay();\r\nif (!write_sq.active)\r\nWAKE_UP(write_sq.sync_queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init AmiMixerInit(void)\r\n{\r\ndmasound.volume_left = 64;\r\ndmasound.volume_right = 64;\r\ncustom.aud[0].audvol = dmasound.volume_left;\r\ncustom.aud[3].audvol = 1;\r\ncustom.aud[1].audvol = dmasound.volume_right;\r\ncustom.aud[2].audvol = 1;\r\ndmasound.treble = 50;\r\n}\r\nstatic int AmiMixerIoctl(u_int cmd, u_long arg)\r\n{\r\nint data;\r\nswitch (cmd) {\r\ncase SOUND_MIXER_READ_DEVMASK:\r\nreturn IOCTL_OUT(arg, SOUND_MASK_VOLUME | SOUND_MASK_TREBLE);\r\ncase SOUND_MIXER_READ_RECMASK:\r\nreturn IOCTL_OUT(arg, 0);\r\ncase SOUND_MIXER_READ_STEREODEVS:\r\nreturn IOCTL_OUT(arg, SOUND_MASK_VOLUME);\r\ncase SOUND_MIXER_READ_VOLUME:\r\nreturn IOCTL_OUT(arg,\r\nVOLUME_AMI_TO_VOXWARE(dmasound.volume_left) |\r\nVOLUME_AMI_TO_VOXWARE(dmasound.volume_right) << 8);\r\ncase SOUND_MIXER_WRITE_VOLUME:\r\nIOCTL_IN(arg, data);\r\nreturn IOCTL_OUT(arg, dmasound_set_volume(data));\r\ncase SOUND_MIXER_READ_TREBLE:\r\nreturn IOCTL_OUT(arg, dmasound.treble);\r\ncase SOUND_MIXER_WRITE_TREBLE:\r\nIOCTL_IN(arg, data);\r\nreturn IOCTL_OUT(arg, dmasound_set_treble(data));\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int AmiWriteSqSetup(void)\r\n{\r\nwrite_sq_block_size_half = write_sq.block_size>>1;\r\nwrite_sq_block_size_quarter = write_sq_block_size_half>>1;\r\nreturn 0;\r\n}\r\nstatic int AmiStateInfo(char *buffer, size_t space)\r\n{\r\nint len = 0;\r\nlen += sprintf(buffer+len, "\tsound.volume_left = %d [0...64]\n",\r\ndmasound.volume_left);\r\nlen += sprintf(buffer+len, "\tsound.volume_right = %d [0...64]\n",\r\ndmasound.volume_right);\r\nif (len >= space) {\r\nprintk(KERN_ERR "dmasound_paula: overflowed state buffer alloc.\n") ;\r\nlen = space ;\r\n}\r\nreturn len;\r\n}\r\nstatic int __init amiga_audio_probe(struct platform_device *pdev)\r\n{\r\ndmasound.mach = machAmiga;\r\ndmasound.mach.default_hard = def_hard ;\r\ndmasound.mach.default_soft = def_soft ;\r\nreturn dmasound_init();\r\n}\r\nstatic int __exit amiga_audio_remove(struct platform_device *pdev)\r\n{\r\ndmasound_deinit();\r\nreturn 0;\r\n}\r\nstatic int __init amiga_audio_init(void)\r\n{\r\nreturn platform_driver_probe(&amiga_audio_driver, amiga_audio_probe);\r\n}\r\nstatic void __exit amiga_audio_exit(void)\r\n{\r\nplatform_driver_unregister(&amiga_audio_driver);\r\n}
