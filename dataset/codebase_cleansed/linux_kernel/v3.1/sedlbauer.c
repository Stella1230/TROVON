static inline u_char\r\nreadreg(unsigned int ale, unsigned int adr, u_char off)\r\n{\r\nregister u_char ret;\r\nbyteout(ale, off);\r\nret = bytein(adr);\r\nreturn (ret);\r\n}\r\nstatic inline void\r\nreadfifo(unsigned int ale, unsigned int adr, u_char off, u_char * data, int size)\r\n{\r\nbyteout(ale, off);\r\ninsb(adr, data, size);\r\n}\r\nstatic inline void\r\nwritereg(unsigned int ale, unsigned int adr, u_char off, u_char data)\r\n{\r\nbyteout(ale, off);\r\nbyteout(adr, data);\r\n}\r\nstatic inline void\r\nwritefifo(unsigned int ale, unsigned int adr, u_char off, u_char * data, int size)\r\n{\r\nbyteout(ale, off);\r\noutsb(adr, data, size);\r\n}\r\nstatic u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, offset));\r\n}\r\nstatic void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, offset, value);\r\n}\r\nstatic void\r\nReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\nreadfifo(cs->hw.sedl.adr, cs->hw.sedl.isac, 0, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\nwritefifo(cs->hw.sedl.adr, cs->hw.sedl.isac, 0, data, size);\r\n}\r\nstatic u_char\r\nReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, offset|0x80));\r\n}\r\nstatic void\r\nWriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, offset|0x80, value);\r\n}\r\nstatic void\r\nReadISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\nreadfifo(cs->hw.sedl.adr, cs->hw.sedl.isac, 0x80, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\nwritefifo(cs->hw.sedl.adr, cs->hw.sedl.isac, 0x80, data, size);\r\n}\r\nstatic u_char\r\nReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.sedl.adr,\r\ncs->hw.sedl.hscx, offset + (hscx ? 0x40 : 0)));\r\n}\r\nstatic void\r\nWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.sedl.adr,\r\ncs->hw.sedl.hscx, offset + (hscx ? 0x40 : 0), value);\r\n}\r\nstatic u_char\r\nReadISAR(struct IsdnCardState *cs, int mode, u_char offset)\r\n{\r\nif (mode == 0)\r\nreturn (readreg(cs->hw.sedl.adr, cs->hw.sedl.hscx, offset));\r\nelse if (mode == 1)\r\nbyteout(cs->hw.sedl.adr, offset);\r\nreturn(bytein(cs->hw.sedl.hscx));\r\n}\r\nstatic void\r\nWriteISAR(struct IsdnCardState *cs, int mode, u_char offset, u_char value)\r\n{\r\nif (mode == 0)\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx, offset, value);\r\nelse {\r\nif (mode == 1)\r\nbyteout(cs->hw.sedl.adr, offset);\r\nbyteout(cs->hw.sedl.hscx, value);\r\n}\r\n}\r\nstatic irqreturn_t\r\nsedlbauer_interrupt(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char val;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif ((cs->hw.sedl.bus == SEDL_BUS_PCMCIA) && (*cs->busy_flag == 1)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nprintk(KERN_WARNING "Sedlbauer: card not available!\n");\r\nreturn IRQ_NONE;\r\n}\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.hscx, HSCX_ISTA + 0x40);\r\nStart_HSCX:\r\nif (val)\r\nhscx_int_main(cs, val);\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_ISTA);\r\nStart_ISAC:\r\nif (val)\r\nisac_interrupt(cs, val);\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.hscx, HSCX_ISTA + 0x40);\r\nif (val) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX IntStat after IntRoutine");\r\ngoto Start_HSCX;\r\n}\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_ISTA);\r\nif (val) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ISAC IntStat after IntRoutine");\r\ngoto Start_ISAC;\r\n}\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx, HSCX_MASK, 0xFF);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx, HSCX_MASK + 0x40, 0xFF);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_MASK, 0xFF);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_MASK, 0x0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx, HSCX_MASK, 0x0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx, HSCX_MASK + 0x40, 0x0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nsedlbauer_interrupt_ipac(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char ista, val, icnt = 5;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nista = readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_ISTA);\r\nStart_IPAC:\r\nif (cs->debug & L1_DEB_IPAC)\r\ndebugl1(cs, "IPAC ISTA %02X", ista);\r\nif (ista & 0x0f) {\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.hscx, HSCX_ISTA + 0x40);\r\nif (ista & 0x01)\r\nval |= 0x01;\r\nif (ista & 0x04)\r\nval |= 0x02;\r\nif (ista & 0x08)\r\nval |= 0x04;\r\nif (val)\r\nhscx_int_main(cs, val);\r\n}\r\nif (ista & 0x20) {\r\nval = 0xfe & readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_ISTA | 0x80);\r\nif (val) {\r\nisac_interrupt(cs, val);\r\n}\r\n}\r\nif (ista & 0x10) {\r\nval = 0x01;\r\nisac_interrupt(cs, val);\r\n}\r\nista = readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_ISTA);\r\nif ((ista & 0x3f) && icnt) {\r\nicnt--;\r\ngoto Start_IPAC;\r\n}\r\nif (!icnt)\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Sedlbauer IRQ LOOP");\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_MASK, 0xFF);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_MASK, 0xC0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nsedlbauer_interrupt_isar(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char val;\r\nint cnt = 5;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.hscx, ISAR_IRQBIT);\r\nStart_ISAR:\r\nif (val & ISAR_IRQSTA)\r\nisar_int_main(cs);\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_ISTA);\r\nStart_ISAC:\r\nif (val)\r\nisac_interrupt(cs, val);\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.hscx, ISAR_IRQBIT);\r\nif ((val & ISAR_IRQSTA) && --cnt) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "ISAR IntStat after IntRoutine");\r\ngoto Start_ISAR;\r\n}\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_ISTA);\r\nif (val && --cnt) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ISAC IntStat after IntRoutine");\r\ngoto Start_ISAC;\r\n}\r\nif (!cnt)\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Sedlbauer IRQ LOOP");\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx, ISAR_IRQBIT, 0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_MASK, 0xFF);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, ISAC_MASK, 0x0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx, ISAR_IRQBIT, ISAR_IRQMSK);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nrelease_io_sedlbauer(struct IsdnCardState *cs)\r\n{\r\nint bytecnt = 8;\r\nif (cs->subtyp == SEDL_SPEED_FAX) {\r\nbytecnt = 16;\r\n} else if (cs->hw.sedl.bus == SEDL_BUS_PCI) {\r\nbytecnt = 256;\r\n}\r\nif (cs->hw.sedl.cfg_reg)\r\nrelease_region(cs->hw.sedl.cfg_reg, bytecnt);\r\n}\r\nstatic void\r\nreset_sedlbauer(struct IsdnCardState *cs)\r\n{\r\nprintk(KERN_INFO "Sedlbauer: resetting card\n");\r\nif (!((cs->hw.sedl.bus == SEDL_BUS_PCMCIA) &&\r\n(cs->hw.sedl.chip == SEDL_CHIP_ISAC_HSCX))) {\r\nif (cs->hw.sedl.chip == SEDL_CHIP_IPAC) {\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_POTA2, 0x20);\r\nmdelay(2);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_POTA2, 0x0);\r\nmdelay(10);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_CONF, 0x0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_ACFG, 0xff);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_AOE, 0x0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_MASK, 0xc0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_PCFG, 0x12);\r\n} else if ((cs->hw.sedl.chip == SEDL_CHIP_ISAC_ISAR) &&\r\n(cs->hw.sedl.bus == SEDL_BUS_PCI)) {\r\nbyteout(cs->hw.sedl.cfg_reg +3, cs->hw.sedl.reset_on);\r\nmdelay(2);\r\nbyteout(cs->hw.sedl.cfg_reg +3, cs->hw.sedl.reset_off);\r\nmdelay(10);\r\n} else {\r\nbyteout(cs->hw.sedl.reset_on, SEDL_RESET);\r\nmdelay(2);\r\nbyteout(cs->hw.sedl.reset_off, 0);\r\nmdelay(10);\r\n}\r\n}\r\n}\r\nstatic int\r\nSedl_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_sedlbauer(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn(0);\r\ncase CARD_RELEASE:\r\nif (cs->hw.sedl.bus == SEDL_BUS_PCI)\r\nbyteout(cs->hw.sedl.cfg_reg+ 5, 0);\r\nif (cs->hw.sedl.chip == SEDL_CHIP_ISAC_ISAR) {\r\nspin_lock_irqsave(&cs->lock, flags);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx,\r\nISAR_IRQBIT, 0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac,\r\nISAC_MASK, 0xFF);\r\nreset_sedlbauer(cs);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx,\r\nISAR_IRQBIT, 0);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.isac,\r\nISAC_MASK, 0xFF);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\n}\r\nrelease_io_sedlbauer(cs);\r\nreturn(0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->hw.sedl.bus == SEDL_BUS_PCI)\r\nbyteout(cs->hw.sedl.cfg_reg+ 5, 0x02);\r\nreset_sedlbauer(cs);\r\nif (cs->hw.sedl.chip == SEDL_CHIP_ISAC_ISAR) {\r\nclear_pending_isac_ints(cs);\r\nwritereg(cs->hw.sedl.adr, cs->hw.sedl.hscx,\r\nISAR_IRQBIT, 0);\r\ninitisac(cs);\r\ninitisar(cs);\r\ncs->writeisac(cs, ISAC_MASK, 0);\r\ncs->writeisac(cs, ISAC_CMDR, 0x41);\r\n} else {\r\ninithscxisac(cs, 3);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn(0);\r\ncase CARD_TEST:\r\nreturn(0);\r\ncase MDL_INFO_CONN:\r\nif (cs->subtyp != SEDL_SPEEDFAX_PYRAMID)\r\nreturn(0);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif ((long) arg)\r\ncs->hw.sedl.reset_off &= ~SEDL_ISAR_PCI_LED2;\r\nelse\r\ncs->hw.sedl.reset_off &= ~SEDL_ISAR_PCI_LED1;\r\nbyteout(cs->hw.sedl.cfg_reg +3, cs->hw.sedl.reset_off);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase MDL_INFO_REL:\r\nif (cs->subtyp != SEDL_SPEEDFAX_PYRAMID)\r\nreturn(0);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif ((long) arg)\r\ncs->hw.sedl.reset_off |= SEDL_ISAR_PCI_LED2;\r\nelse\r\ncs->hw.sedl.reset_off |= SEDL_ISAR_PCI_LED1;\r\nbyteout(cs->hw.sedl.cfg_reg +3, cs->hw.sedl.reset_off);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\n}\r\nreturn(0);\r\n}\r\nstatic int __devinit\r\nsetup_sedlbauer_isapnp(struct IsdnCard *card, int *bytecnt)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nstruct pnp_dev *pnp_d;\r\nif (!isapnp_present())\r\nreturn -1;\r\nwhile(ipid->card_vendor) {\r\nif ((pnp_c = pnp_find_card(ipid->card_vendor,\r\nipid->card_device, pnp_c))) {\r\npnp_d = NULL;\r\nif ((pnp_d = pnp_find_dev(pnp_c,\r\nipid->vendor, ipid->function, pnp_d))) {\r\nint err;\r\nprintk(KERN_INFO "HiSax: %s detected\n",\r\n(char *)ipid->driver_data);\r\npnp_disable_dev(pnp_d);\r\nerr = pnp_activate_dev(pnp_d);\r\nif (err<0) {\r\nprintk(KERN_WARNING "%s: pnp_activate_dev ret(%d)\n",\r\n__func__, err);\r\nreturn(0);\r\n}\r\ncard->para[1] = pnp_port_start(pnp_d, 0);\r\ncard->para[0] = pnp_irq(pnp_d, 0);\r\nif (!card->para[0] || !card->para[1]) {\r\nprintk(KERN_ERR "Sedlbauer PnP:some resources are missing %ld/%lx\n",\r\ncard->para[0], card->para[1]);\r\npnp_disable_dev(pnp_d);\r\nreturn(0);\r\n}\r\ncs->hw.sedl.cfg_reg = card->para[1];\r\ncs->irq = card->para[0];\r\nif (ipid->function == ISAPNP_FUNCTION(0x2)) {\r\ncs->subtyp = SEDL_SPEED_FAX;\r\ncs->hw.sedl.chip = SEDL_CHIP_ISAC_ISAR;\r\n*bytecnt = 16;\r\n} else {\r\ncs->subtyp = SEDL_SPEED_CARD_WIN;\r\ncs->hw.sedl.chip = SEDL_CHIP_TEST;\r\n}\r\nreturn (1);\r\n} else {\r\nprintk(KERN_ERR "Sedlbauer PnP: PnP error card found, no device\n");\r\nreturn(0);\r\n}\r\n}\r\nipid++;\r\npnp_c = NULL;\r\n}\r\nprintk(KERN_INFO "Sedlbauer PnP: no ISAPnP card found\n");\r\nreturn -1;\r\n}\r\nstatic int __devinit\r\nsetup_sedlbauer_isapnp(struct IsdnCard *card, int *bytecnt)\r\n{\r\nreturn -1;\r\n}\r\nstatic int __devinit\r\nsetup_sedlbauer_pci(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nu16 sub_vendor_id, sub_id;\r\nif ((dev_sedl = hisax_find_pci_device(PCI_VENDOR_ID_TIGERJET,\r\nPCI_DEVICE_ID_TIGERJET_100, dev_sedl))) {\r\nif (pci_enable_device(dev_sedl))\r\nreturn(0);\r\ncs->irq = dev_sedl->irq;\r\nif (!cs->irq) {\r\nprintk(KERN_WARNING "Sedlbauer: No IRQ for PCI card found\n");\r\nreturn(0);\r\n}\r\ncs->hw.sedl.cfg_reg = pci_resource_start(dev_sedl, 0);\r\n} else {\r\nprintk(KERN_WARNING "Sedlbauer: No PCI card found\n");\r\nreturn(0);\r\n}\r\ncs->irq_flags |= IRQF_SHARED;\r\ncs->hw.sedl.bus = SEDL_BUS_PCI;\r\nsub_vendor_id = dev_sedl->subsystem_vendor;\r\nsub_id = dev_sedl->subsystem_device;\r\nprintk(KERN_INFO "Sedlbauer: PCI subvendor:%x subid %x\n",\r\nsub_vendor_id, sub_id);\r\nprintk(KERN_INFO "Sedlbauer: PCI base adr %#x\n",\r\ncs->hw.sedl.cfg_reg);\r\nif (sub_id != PCI_SUB_ID_SEDLBAUER) {\r\nprintk(KERN_ERR "Sedlbauer: unknown sub id %#x\n", sub_id);\r\nreturn(0);\r\n}\r\nif (sub_vendor_id == PCI_SUBVENDOR_SPEEDFAX_PYRAMID) {\r\ncs->hw.sedl.chip = SEDL_CHIP_ISAC_ISAR;\r\ncs->subtyp = SEDL_SPEEDFAX_PYRAMID;\r\n} else if (sub_vendor_id == PCI_SUBVENDOR_SPEEDFAX_PCI) {\r\ncs->hw.sedl.chip = SEDL_CHIP_ISAC_ISAR;\r\ncs->subtyp = SEDL_SPEEDFAX_PCI;\r\n} else if (sub_vendor_id == PCI_SUBVENDOR_HST_SAPHIR3) {\r\ncs->hw.sedl.chip = SEDL_CHIP_IPAC;\r\ncs->subtyp = HST_SAPHIR3;\r\n} else if (sub_vendor_id == PCI_SUBVENDOR_SEDLBAUER_PCI) {\r\ncs->hw.sedl.chip = SEDL_CHIP_IPAC;\r\ncs->subtyp = SEDL_SPEED_PCI;\r\n} else {\r\nprintk(KERN_ERR "Sedlbauer: unknown sub vendor id %#x\n",\r\nsub_vendor_id);\r\nreturn(0);\r\n}\r\ncs->hw.sedl.reset_on = SEDL_ISAR_PCI_ISAR_RESET_ON;\r\ncs->hw.sedl.reset_off = SEDL_ISAR_PCI_ISAR_RESET_OFF;\r\nbyteout(cs->hw.sedl.cfg_reg, 0xff);\r\nbyteout(cs->hw.sedl.cfg_reg, 0x00);\r\nbyteout(cs->hw.sedl.cfg_reg+ 2, 0xdd);\r\nbyteout(cs->hw.sedl.cfg_reg+ 5, 0);\r\nbyteout(cs->hw.sedl.cfg_reg +3, cs->hw.sedl.reset_on);\r\nmdelay(2);\r\nbyteout(cs->hw.sedl.cfg_reg +3, cs->hw.sedl.reset_off);\r\nmdelay(10);\r\nreturn (1);\r\n}\r\nstatic int __devinit\r\nsetup_sedlbauer_pci(struct IsdnCard *card)\r\n{\r\nreturn (1);\r\n}\r\nint __devinit\r\nsetup_sedlbauer(struct IsdnCard *card)\r\n{\r\nint bytecnt = 8, ver, val, rc;\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nstrcpy(tmp, Sedlbauer_revision);\r\nprintk(KERN_INFO "HiSax: Sedlbauer driver Rev. %s\n", HiSax_getrev(tmp));\r\nif (cs->typ == ISDN_CTYPE_SEDLBAUER) {\r\ncs->subtyp = SEDL_SPEED_CARD_WIN;\r\ncs->hw.sedl.bus = SEDL_BUS_ISA;\r\ncs->hw.sedl.chip = SEDL_CHIP_TEST;\r\n} else if (cs->typ == ISDN_CTYPE_SEDLBAUER_PCMCIA) {\r\ncs->subtyp = SEDL_SPEED_STAR;\r\ncs->hw.sedl.bus = SEDL_BUS_PCMCIA;\r\ncs->hw.sedl.chip = SEDL_CHIP_TEST;\r\n} else if (cs->typ == ISDN_CTYPE_SEDLBAUER_FAX) {\r\ncs->subtyp = SEDL_SPEED_FAX;\r\ncs->hw.sedl.bus = SEDL_BUS_ISA;\r\ncs->hw.sedl.chip = SEDL_CHIP_ISAC_ISAR;\r\n} else\r\nreturn (0);\r\nbytecnt = 8;\r\nif (card->para[1]) {\r\ncs->hw.sedl.cfg_reg = card->para[1];\r\ncs->irq = card->para[0];\r\nif (cs->hw.sedl.chip == SEDL_CHIP_ISAC_ISAR) {\r\nbytecnt = 16;\r\n}\r\n} else {\r\nrc = setup_sedlbauer_isapnp(card, &bytecnt);\r\nif (!rc)\r\nreturn (0);\r\nif (rc > 0)\r\ngoto ready;\r\nrc = setup_sedlbauer_pci(card);\r\nif (!rc)\r\nreturn (0);\r\nbytecnt = 256;\r\n}\r\nready:\r\nif (cs->hw.sedl.bus != SEDL_BUS_PCMCIA &&\r\n!request_region(cs->hw.sedl.cfg_reg, bytecnt, "sedlbauer isdn")) {\r\nprintk(KERN_WARNING\r\n"HiSax: %s config port %x-%x already in use\n",\r\nCardType[card->typ],\r\ncs->hw.sedl.cfg_reg,\r\ncs->hw.sedl.cfg_reg + bytecnt);\r\nreturn (0);\r\n}\r\nprintk(KERN_INFO\r\n"Sedlbauer: defined at 0x%x-0x%x IRQ %d\n",\r\ncs->hw.sedl.cfg_reg,\r\ncs->hw.sedl.cfg_reg + bytecnt,\r\ncs->irq);\r\ncs->BC_Read_Reg = &ReadHSCX;\r\ncs->BC_Write_Reg = &WriteHSCX;\r\ncs->BC_Send_Data = &hscx_fill_fifo;\r\ncs->cardmsg = &Sedl_card_msg;\r\nif (cs->hw.sedl.bus != SEDL_BUS_PCI) {\r\nval = readreg(cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_ADR,\r\ncs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_IPAC, IPAC_ID);\r\nprintk(KERN_DEBUG "Sedlbauer: testing IPAC version %x\n", val);\r\nif ((val == 1) || (val == 2)) {\r\ncs->subtyp = SEDL_SPEED_WIN2_PC104;\r\nif (cs->hw.sedl.bus == SEDL_BUS_PCMCIA) {\r\ncs->subtyp = SEDL_SPEED_STAR2;\r\n}\r\ncs->hw.sedl.chip = SEDL_CHIP_IPAC;\r\n} else {\r\nif (cs->hw.sedl.chip == SEDL_CHIP_TEST) {\r\ncs->hw.sedl.chip = SEDL_CHIP_ISAC_HSCX;\r\n}\r\n}\r\n}\r\nprintk(KERN_INFO "Sedlbauer: %s detected\n",\r\nSedlbauer_Types[cs->subtyp]);\r\nsetup_isac(cs);\r\nif (cs->hw.sedl.chip == SEDL_CHIP_IPAC) {\r\nif (cs->hw.sedl.bus == SEDL_BUS_PCI) {\r\ncs->hw.sedl.adr = cs->hw.sedl.cfg_reg + SEDL_IPAC_PCI_ADR;\r\ncs->hw.sedl.isac = cs->hw.sedl.cfg_reg + SEDL_IPAC_PCI_IPAC;\r\ncs->hw.sedl.hscx = cs->hw.sedl.cfg_reg + SEDL_IPAC_PCI_IPAC;\r\n} else {\r\ncs->hw.sedl.adr = cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_ADR;\r\ncs->hw.sedl.isac = cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_IPAC;\r\ncs->hw.sedl.hscx = cs->hw.sedl.cfg_reg + SEDL_IPAC_ANY_IPAC;\r\n}\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\ncs->readisac = &ReadISAC_IPAC;\r\ncs->writeisac = &WriteISAC_IPAC;\r\ncs->readisacfifo = &ReadISACfifo_IPAC;\r\ncs->writeisacfifo = &WriteISACfifo_IPAC;\r\ncs->irq_func = &sedlbauer_interrupt_ipac;\r\nval = readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, IPAC_ID);\r\nprintk(KERN_INFO "Sedlbauer: IPAC version %x\n", val);\r\n} else {\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\nif (cs->hw.sedl.chip == SEDL_CHIP_ISAC_ISAR) {\r\nif (cs->hw.sedl.bus == SEDL_BUS_PCI) {\r\ncs->hw.sedl.adr = cs->hw.sedl.cfg_reg +\r\nSEDL_ISAR_PCI_ADR;\r\ncs->hw.sedl.isac = cs->hw.sedl.cfg_reg +\r\nSEDL_ISAR_PCI_ISAC;\r\ncs->hw.sedl.hscx = cs->hw.sedl.cfg_reg +\r\nSEDL_ISAR_PCI_ISAR;\r\n} else {\r\ncs->hw.sedl.adr = cs->hw.sedl.cfg_reg +\r\nSEDL_ISAR_ISA_ADR;\r\ncs->hw.sedl.isac = cs->hw.sedl.cfg_reg +\r\nSEDL_ISAR_ISA_ISAC;\r\ncs->hw.sedl.hscx = cs->hw.sedl.cfg_reg +\r\nSEDL_ISAR_ISA_ISAR;\r\ncs->hw.sedl.reset_on = cs->hw.sedl.cfg_reg +\r\nSEDL_ISAR_ISA_ISAR_RESET_ON;\r\ncs->hw.sedl.reset_off = cs->hw.sedl.cfg_reg +\r\nSEDL_ISAR_ISA_ISAR_RESET_OFF;\r\n}\r\ncs->bcs[0].hw.isar.reg = &cs->hw.sedl.isar;\r\ncs->bcs[1].hw.isar.reg = &cs->hw.sedl.isar;\r\ntest_and_set_bit(HW_ISAR, &cs->HW_Flags);\r\ncs->irq_func = &sedlbauer_interrupt_isar;\r\ncs->auxcmd = &isar_auxcmd;\r\nISACVersion(cs, "Sedlbauer:");\r\ncs->BC_Read_Reg = &ReadISAR;\r\ncs->BC_Write_Reg = &WriteISAR;\r\ncs->BC_Send_Data = &isar_fill_fifo;\r\nbytecnt = 3;\r\nwhile (bytecnt) {\r\nver = ISARVersion(cs, "Sedlbauer:");\r\nif (ver < 0)\r\nprintk(KERN_WARNING\r\n"Sedlbauer: wrong ISAR version (ret = %d)\n", ver);\r\nelse\r\nbreak;\r\nreset_sedlbauer(cs);\r\nbytecnt--;\r\n}\r\nif (!bytecnt) {\r\nrelease_io_sedlbauer(cs);\r\nreturn (0);\r\n}\r\n} else {\r\nif (cs->hw.sedl.bus == SEDL_BUS_PCMCIA) {\r\ncs->hw.sedl.adr = cs->hw.sedl.cfg_reg + SEDL_HSCX_PCMCIA_ADR;\r\ncs->hw.sedl.isac = cs->hw.sedl.cfg_reg + SEDL_HSCX_PCMCIA_ISAC;\r\ncs->hw.sedl.hscx = cs->hw.sedl.cfg_reg + SEDL_HSCX_PCMCIA_HSCX;\r\ncs->hw.sedl.reset_on = cs->hw.sedl.cfg_reg + SEDL_HSCX_PCMCIA_RESET;\r\ncs->hw.sedl.reset_off = cs->hw.sedl.cfg_reg + SEDL_HSCX_PCMCIA_RESET;\r\ncs->irq_flags |= IRQF_SHARED;\r\n} else {\r\ncs->hw.sedl.adr = cs->hw.sedl.cfg_reg + SEDL_HSCX_ISA_ADR;\r\ncs->hw.sedl.isac = cs->hw.sedl.cfg_reg + SEDL_HSCX_ISA_ISAC;\r\ncs->hw.sedl.hscx = cs->hw.sedl.cfg_reg + SEDL_HSCX_ISA_HSCX;\r\ncs->hw.sedl.reset_on = cs->hw.sedl.cfg_reg + SEDL_HSCX_ISA_RESET_ON;\r\ncs->hw.sedl.reset_off = cs->hw.sedl.cfg_reg + SEDL_HSCX_ISA_RESET_OFF;\r\n}\r\ncs->irq_func = &sedlbauer_interrupt;\r\nISACVersion(cs, "Sedlbauer:");\r\nif (HscxVersion(cs, "Sedlbauer:")) {\r\nprintk(KERN_WARNING\r\n"Sedlbauer: wrong HSCX versions check IO address\n");\r\nrelease_io_sedlbauer(cs);\r\nreturn (0);\r\n}\r\n}\r\n}\r\nreturn (1);\r\n}
