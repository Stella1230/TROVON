static unsigned long tmr2ticks(int tmr_value)\r\n{\r\nunsigned long tmp;\r\nunsigned long scale;\r\ntmp = tmr_value * usecs_per_tmr;\r\nscale = (60 * 1000000) / (curr_tempo * curr_timebase);\r\nreturn (tmp + (scale / 2)) / scale;\r\n}\r\nvoid reprogram_timer(void)\r\n{\r\nunsigned long usecs_per_tick;\r\nif(!tmr)\r\nreturn;\r\nusecs_per_tick = (60 * 1000000) / (curr_tempo * curr_timebase);\r\nif (usecs_per_tick < 2000)\r\nusecs_per_tick = 2000;\r\nusecs_per_tmr = tmr->tmr_start(tmr->dev, usecs_per_tick);\r\n}\r\nvoid sound_timer_syncinterval(unsigned int new_usecs)\r\n{\r\ntmr_offs = tmr_ctr;\r\nticks_offs += tmr2ticks(tmr_ctr);\r\ntmr_ctr = 0;\r\nusecs_per_tmr = new_usecs;\r\n}\r\nstatic void tmr_reset(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock,flags);\r\ntmr_offs = 0;\r\nticks_offs = 0;\r\ntmr_ctr = 0;\r\nnext_event_time = (unsigned long) -1;\r\nprev_event_time = 0;\r\ncurr_ticks = 0;\r\nspin_unlock_irqrestore(&lock,flags);\r\n}\r\nstatic int timer_open(int dev, int mode)\r\n{\r\nif (opened)\r\nreturn -EBUSY;\r\ntmr_reset();\r\ncurr_tempo = 60;\r\ncurr_timebase = 100;\r\nopened = 1;\r\nreprogram_timer();\r\nreturn 0;\r\n}\r\nstatic void timer_close(int dev)\r\n{\r\nopened = tmr_running = 0;\r\ntmr->tmr_disable(tmr->dev);\r\n}\r\nstatic int timer_event(int dev, unsigned char *event)\r\n{\r\nunsigned char cmd = event[1];\r\nunsigned long parm = *(int *) &event[4];\r\nswitch (cmd)\r\n{\r\ncase TMR_WAIT_REL:\r\nparm += prev_event_time;\r\ncase TMR_WAIT_ABS:\r\nif (parm > 0)\r\n{\r\nlong time;\r\nif (parm <= curr_ticks)\r\nreturn TIMER_NOT_ARMED;\r\ntime = parm;\r\nnext_event_time = prev_event_time = time;\r\nreturn TIMER_ARMED;\r\n}\r\nbreak;\r\ncase TMR_START:\r\ntmr_reset();\r\ntmr_running = 1;\r\nreprogram_timer();\r\nbreak;\r\ncase TMR_STOP:\r\ntmr_running = 0;\r\nbreak;\r\ncase TMR_CONTINUE:\r\ntmr_running = 1;\r\nreprogram_timer();\r\nbreak;\r\ncase TMR_TEMPO:\r\nif (parm)\r\n{\r\nif (parm < 8)\r\nparm = 8;\r\nif (parm > 250)\r\nparm = 250;\r\ntmr_offs = tmr_ctr;\r\nticks_offs += tmr2ticks(tmr_ctr);\r\ntmr_ctr = 0;\r\ncurr_tempo = parm;\r\nreprogram_timer();\r\n}\r\nbreak;\r\ncase TMR_ECHO:\r\nseq_copy_to_input(event, 8);\r\nbreak;\r\ndefault:;\r\n}\r\nreturn TIMER_NOT_ARMED;\r\n}\r\nstatic unsigned long timer_get_time(int dev)\r\n{\r\nif (!opened)\r\nreturn 0;\r\nreturn curr_ticks;\r\n}\r\nstatic int timer_ioctl(int dev, unsigned int cmd, void __user *arg)\r\n{\r\nint __user *p = arg;\r\nint val;\r\nswitch (cmd)\r\n{\r\ncase SNDCTL_TMR_SOURCE:\r\nval = TMR_INTERNAL;\r\nbreak;\r\ncase SNDCTL_TMR_START:\r\ntmr_reset();\r\ntmr_running = 1;\r\nreturn 0;\r\ncase SNDCTL_TMR_STOP:\r\ntmr_running = 0;\r\nreturn 0;\r\ncase SNDCTL_TMR_CONTINUE:\r\ntmr_running = 1;\r\nreturn 0;\r\ncase SNDCTL_TMR_TIMEBASE:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val)\r\n{\r\nif (val < 1)\r\nval = 1;\r\nif (val > 1000)\r\nval = 1000;\r\ncurr_timebase = val;\r\n}\r\nval = curr_timebase;\r\nbreak;\r\ncase SNDCTL_TMR_TEMPO:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val)\r\n{\r\nif (val < 8)\r\nval = 8;\r\nif (val > 250)\r\nval = 250;\r\ntmr_offs = tmr_ctr;\r\nticks_offs += tmr2ticks(tmr_ctr);\r\ntmr_ctr = 0;\r\ncurr_tempo = val;\r\nreprogram_timer();\r\n}\r\nval = curr_tempo;\r\nbreak;\r\ncase SNDCTL_SEQ_CTRLRATE:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val != 0)\r\nreturn -EINVAL;\r\nval = ((curr_tempo * curr_timebase) + 30) / 60;\r\nbreak;\r\ncase SNDCTL_SEQ_GETTIME:\r\nval = curr_ticks;\r\nbreak;\r\ncase SNDCTL_TMR_METRONOME:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn put_user(val, p);\r\n}\r\nstatic void timer_arm(int dev, long time)\r\n{\r\nif (time < 0)\r\ntime = curr_ticks + 1;\r\nelse if (time <= curr_ticks)\r\nreturn;\r\nnext_event_time = prev_event_time = time;\r\nreturn;\r\n}\r\nvoid sound_timer_interrupt(void)\r\n{\r\nunsigned long flags;\r\nif (!opened)\r\nreturn;\r\ntmr->tmr_restart(tmr->dev);\r\nif (!tmr_running)\r\nreturn;\r\nspin_lock_irqsave(&lock,flags);\r\ntmr_ctr++;\r\ncurr_ticks = ticks_offs + tmr2ticks(tmr_ctr);\r\nif (curr_ticks >= next_event_time)\r\n{\r\nnext_event_time = (unsigned long) -1;\r\nsequencer_timer(0);\r\n}\r\nspin_unlock_irqrestore(&lock,flags);\r\n}\r\nvoid sound_timer_init(struct sound_lowlev_timer *t, char *name)\r\n{\r\nint n;\r\nif (initialized)\r\n{\r\nif (t->priority <= tmr->priority)\r\nreturn;\r\ntmr = t;\r\nreturn;\r\n}\r\ninitialized = 1;\r\ntmr = t;\r\nn = sound_alloc_timerdev();\r\nif (n == -1)\r\nn = 0;\r\nstrcpy(sound_timer.info.name, name);\r\nsound_timer_devs[n] = &sound_timer;\r\n}
