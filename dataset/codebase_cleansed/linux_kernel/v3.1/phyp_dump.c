static unsigned long init_dump_header(struct phyp_dump_header *ph)\r\n{\r\nunsigned long addr_offset = 0;\r\nph->version = DUMP_HEADER_VERSION;\r\nph->num_of_sections = NUM_DUMP_SECTIONS;\r\nph->status = 0;\r\nph->first_offset_section =\r\n(u32)offsetof(struct phyp_dump_header, cpu_data);\r\nph->dump_disk_section = 0;\r\nph->block_num_dd = 0;\r\nph->num_of_blocks_dd = 0;\r\nph->offset_dd = 0;\r\nph->maxtime_to_auto = 0;\r\nph->cpu_data.dump_flags = DUMP_REQUEST_FLAG;\r\nph->cpu_data.source_type = DUMP_SOURCE_CPU;\r\nph->cpu_data.source_address = 0;\r\nph->cpu_data.source_length = phyp_dump_info->cpu_state_size;\r\nph->cpu_data.destination_address = addr_offset;\r\naddr_offset += phyp_dump_info->cpu_state_size;\r\nph->hpte_data.dump_flags = DUMP_REQUEST_FLAG;\r\nph->hpte_data.source_type = DUMP_SOURCE_HPTE;\r\nph->hpte_data.source_address = 0;\r\nph->hpte_data.source_length = phyp_dump_info->hpte_region_size;\r\nph->hpte_data.destination_address = addr_offset;\r\naddr_offset += phyp_dump_info->hpte_region_size;\r\nph->kernel_data.dump_flags = DUMP_REQUEST_FLAG;\r\nph->kernel_data.source_type = DUMP_SOURCE_RMO;\r\nph->kernel_data.source_address = PHYP_DUMP_RMR_START;\r\nph->kernel_data.source_length = PHYP_DUMP_RMR_END;\r\nph->kernel_data.destination_address = addr_offset;\r\naddr_offset += ph->kernel_data.source_length;\r\nreturn addr_offset;\r\n}\r\nstatic void print_dump_header(const struct phyp_dump_header *ph)\r\n{\r\n#ifdef DEBUG\r\nif (ph == NULL)\r\nreturn;\r\nprintk(KERN_INFO "dump header:\n");\r\nprintk(KERN_INFO "version = %d\n", ph->version);\r\nprintk(KERN_INFO "Sections = %d\n", ph->num_of_sections);\r\nprintk(KERN_INFO "Status = 0x%x\n", ph->status);\r\nprintk(KERN_INFO "Offset to first section 0x%x\n",\r\nph->first_offset_section);\r\nprintk(KERN_INFO "dump disk sections should be zero\n");\r\nprintk(KERN_INFO "dump disk section = %d\n", ph->dump_disk_section);\r\nprintk(KERN_INFO "block num = %lld\n", ph->block_num_dd);\r\nprintk(KERN_INFO "number of blocks = %lld\n", ph->num_of_blocks_dd);\r\nprintk(KERN_INFO "dump disk offset = %d\n", ph->offset_dd);\r\nprintk(KERN_INFO "Max auto time= %d\n", ph->maxtime_to_auto);\r\nprintk(KERN_INFO " CPU AREA\n");\r\nprintk(KERN_INFO "cpu dump_flags =%d\n", ph->cpu_data.dump_flags);\r\nprintk(KERN_INFO "cpu source_type =%d\n", ph->cpu_data.source_type);\r\nprintk(KERN_INFO "cpu error_flags =%d\n", ph->cpu_data.error_flags);\r\nprintk(KERN_INFO "cpu source_address =%llx\n",\r\nph->cpu_data.source_address);\r\nprintk(KERN_INFO "cpu source_length =%llx\n",\r\nph->cpu_data.source_length);\r\nprintk(KERN_INFO "cpu length_copied =%llx\n",\r\nph->cpu_data.length_copied);\r\nprintk(KERN_INFO " HPTE AREA\n");\r\nprintk(KERN_INFO "HPTE dump_flags =%d\n", ph->hpte_data.dump_flags);\r\nprintk(KERN_INFO "HPTE source_type =%d\n", ph->hpte_data.source_type);\r\nprintk(KERN_INFO "HPTE error_flags =%d\n", ph->hpte_data.error_flags);\r\nprintk(KERN_INFO "HPTE source_address =%llx\n",\r\nph->hpte_data.source_address);\r\nprintk(KERN_INFO "HPTE source_length =%llx\n",\r\nph->hpte_data.source_length);\r\nprintk(KERN_INFO "HPTE length_copied =%llx\n",\r\nph->hpte_data.length_copied);\r\nprintk(KERN_INFO " SRSD AREA\n");\r\nprintk(KERN_INFO "SRSD dump_flags =%d\n", ph->kernel_data.dump_flags);\r\nprintk(KERN_INFO "SRSD source_type =%d\n", ph->kernel_data.source_type);\r\nprintk(KERN_INFO "SRSD error_flags =%d\n", ph->kernel_data.error_flags);\r\nprintk(KERN_INFO "SRSD source_address =%llx\n",\r\nph->kernel_data.source_address);\r\nprintk(KERN_INFO "SRSD source_length =%llx\n",\r\nph->kernel_data.source_length);\r\nprintk(KERN_INFO "SRSD length_copied =%llx\n",\r\nph->kernel_data.length_copied);\r\n#endif\r\n}\r\nstatic ssize_t show_phyp_dump_active(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%lx\n", phyp_dump_info->phyp_dump_at_boot);\r\n}\r\nstatic void register_dump_area(struct phyp_dump_header *ph, unsigned long addr)\r\n{\r\nint rc;\r\nif (ph->cpu_data.destination_address == 0) {\r\nph->cpu_data.destination_address += addr;\r\nph->hpte_data.destination_address += addr;\r\nph->kernel_data.destination_address += addr;\r\n}\r\ndo {\r\nrc = rtas_call(ibm_configure_kernel_dump, 3, 1, NULL,\r\n1, ph, sizeof(struct phyp_dump_header));\r\n} while (rtas_busy_delay(rc));\r\nif (rc) {\r\nprintk(KERN_ERR "phyp-dump: unexpected error (%d) on "\r\n"register\n", rc);\r\nprint_dump_header(ph);\r\nreturn;\r\n}\r\nrc = sysfs_create_file(kernel_kobj, &pdl.attr);\r\nif (rc)\r\nprintk(KERN_ERR "phyp-dump: unable to create sysfs"\r\n" file (%d)\n", rc);\r\n}\r\nstatic\r\nvoid invalidate_last_dump(struct phyp_dump_header *ph, unsigned long addr)\r\n{\r\nint rc;\r\nif (ph->cpu_data.destination_address == 0) {\r\nph->cpu_data.destination_address += addr;\r\nph->hpte_data.destination_address += addr;\r\nph->kernel_data.destination_address += addr;\r\n}\r\ndo {\r\nrc = rtas_call(ibm_configure_kernel_dump, 3, 1, NULL,\r\n2, ph, sizeof(struct phyp_dump_header));\r\n} while (rtas_busy_delay(rc));\r\nif (rc) {\r\nprintk(KERN_ERR "phyp-dump: unexpected error (%d) "\r\n"on invalidate\n", rc);\r\nprint_dump_header(ph);\r\n}\r\n}\r\nstatic void release_memory_range(unsigned long start_pfn,\r\nunsigned long nr_pages)\r\n{\r\nstruct page *rpage;\r\nunsigned long end_pfn;\r\nlong i;\r\nend_pfn = start_pfn + nr_pages;\r\nfor (i = start_pfn; i <= end_pfn; i++) {\r\nrpage = pfn_to_page(i);\r\nif (PageReserved(rpage)) {\r\nClearPageReserved(rpage);\r\ninit_page_count(rpage);\r\n__free_page(rpage);\r\ntotalram_pages++;\r\n}\r\n}\r\n}\r\nstatic void\r\ntrack_freed_range(unsigned long addr, unsigned long length)\r\n{\r\nstatic unsigned long scratch_area_size, reserved_area_size;\r\nif (addr < phyp_dump_info->init_reserve_start)\r\nreturn;\r\nif ((addr >= phyp_dump_info->init_reserve_start) &&\r\n(addr <= phyp_dump_info->init_reserve_start +\r\nphyp_dump_info->init_reserve_size))\r\nreserved_area_size += length;\r\nif ((addr >= phyp_dump_info->reserved_scratch_addr) &&\r\n(addr <= phyp_dump_info->reserved_scratch_addr +\r\nphyp_dump_info->reserved_scratch_size))\r\nscratch_area_size += length;\r\nif ((reserved_area_size == phyp_dump_info->init_reserve_size) &&\r\n(scratch_area_size == phyp_dump_info->reserved_scratch_size)) {\r\ninvalidate_last_dump(&phdr,\r\nphyp_dump_info->reserved_scratch_addr);\r\nregister_dump_area(&phdr,\r\nphyp_dump_info->reserved_scratch_addr);\r\n}\r\n}\r\nstatic ssize_t store_release_region(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long start_addr, length, end_addr;\r\nunsigned long start_pfn, nr_pages;\r\nssize_t ret;\r\nret = sscanf(buf, "%lx %lx", &start_addr, &length);\r\nif (ret != 2)\r\nreturn -EINVAL;\r\ntrack_freed_range(start_addr, length);\r\nif (start_addr < phyp_dump_info->init_reserve_start)\r\nstart_addr = phyp_dump_info->init_reserve_start;\r\nend_addr = phyp_dump_info->init_reserve_start +\r\nphyp_dump_info->init_reserve_size;\r\nif (start_addr+length > end_addr)\r\nlength = end_addr - start_addr;\r\nstart_pfn = PFN_DOWN(start_addr);\r\nnr_pages = PFN_DOWN(length);\r\nrelease_memory_range(start_pfn, nr_pages);\r\nreturn count;\r\n}\r\nstatic ssize_t show_release_region(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nu64 second_addr_range;\r\nsecond_addr_range = phyp_dump_info->init_reserve_size -\r\nphyp_dump_info->reserved_scratch_size;\r\nreturn sprintf(buf, "CPU:0x%llx-0x%llx: HPTE:0x%llx-0x%llx:"\r\n" DUMP:0x%llx-0x%llx, 0x%lx-0x%llx:\n",\r\nphdr.cpu_data.destination_address,\r\nphdr.cpu_data.length_copied,\r\nphdr.hpte_data.destination_address,\r\nphdr.hpte_data.length_copied,\r\nphdr.kernel_data.destination_address,\r\nphdr.kernel_data.length_copied,\r\nphyp_dump_info->init_reserve_start,\r\nsecond_addr_range);\r\n}\r\nstatic int __init phyp_dump_setup(void)\r\n{\r\nstruct device_node *rtas;\r\nconst struct phyp_dump_header *dump_header = NULL;\r\nunsigned long dump_area_start;\r\nunsigned long dump_area_length;\r\nint header_len = 0;\r\nint rc;\r\nif (phyp_dump_info->init_reserve_size == 0)\r\nreturn 0;\r\nif (!phyp_dump_info->phyp_dump_configured)\r\nreturn -ENOSYS;\r\nrtas = of_find_node_by_path("/rtas");\r\nif (rtas) {\r\ndump_header = of_get_property(rtas, "ibm,kernel-dump",\r\n&header_len);\r\nof_node_put(rtas);\r\n}\r\nibm_configure_kernel_dump = rtas_token("ibm,configure-kernel-dump");\r\nprint_dump_header(dump_header);\r\ndump_area_length = init_dump_header(&phdr);\r\ndump_area_start = phyp_dump_info->init_reserve_start & PAGE_MASK;\r\nif (dump_header == NULL) {\r\nregister_dump_area(&phdr, dump_area_start);\r\nreturn 0;\r\n}\r\nif ((dump_header) && (dump_header->status & DUMP_ERROR_FLAG)) {\r\ninvalidate_last_dump(&phdr, dump_area_start);\r\nregister_dump_area(&phdr, dump_area_start);\r\nreturn 0;\r\n}\r\nif (dump_header) {\r\nphyp_dump_info->reserved_scratch_addr =\r\ndump_header->cpu_data.destination_address;\r\nphyp_dump_info->reserved_scratch_size =\r\ndump_header->cpu_data.source_length +\r\ndump_header->hpte_data.source_length +\r\ndump_header->kernel_data.source_length;\r\n}\r\nrc = sysfs_create_file(kernel_kobj, &rr.attr);\r\nif (rc)\r\nprintk(KERN_ERR "phyp-dump: unable to create sysfs file (%d)\n",\r\nrc);\r\nreturn 0;\r\n}\r\nint __init early_init_dt_scan_phyp_dump(unsigned long node,\r\nconst char *uname, int depth, void *data)\r\n{\r\nconst unsigned int *sizes;\r\nphyp_dump_info->phyp_dump_configured = 0;\r\nphyp_dump_info->phyp_dump_is_active = 0;\r\nif (depth != 1 || strcmp(uname, "rtas") != 0)\r\nreturn 0;\r\nif (of_get_flat_dt_prop(node, "ibm,configure-kernel-dump", NULL))\r\nphyp_dump_info->phyp_dump_configured++;\r\nif (of_get_flat_dt_prop(node, "ibm,dump-kernel", NULL))\r\nphyp_dump_info->phyp_dump_is_active++;\r\nsizes = of_get_flat_dt_prop(node, "ibm,configure-kernel-dump-sizes",\r\nNULL);\r\nif (!sizes)\r\nreturn 0;\r\nif (sizes[0] == 1)\r\nphyp_dump_info->cpu_state_size = *((unsigned long *)&sizes[1]);\r\nif (sizes[3] == 2)\r\nphyp_dump_info->hpte_region_size =\r\n*((unsigned long *)&sizes[4]);\r\nreturn 1;\r\n}\r\nstatic int __init early_phyp_dump_enabled(char *p)\r\n{\r\nphyp_dump_info->phyp_dump_at_boot = 1;\r\nif (!p)\r\nreturn 0;\r\nif (strncmp(p, "1", 1) == 0)\r\nphyp_dump_info->phyp_dump_at_boot = 1;\r\nelse if (strncmp(p, "0", 1) == 0)\r\nphyp_dump_info->phyp_dump_at_boot = 0;\r\nreturn 0;\r\n}\r\nstatic int __init early_phyp_dump_reserve_size(char *p)\r\n{\r\nif (p)\r\nphyp_dump_info->reserve_bootvar = memparse(p, &p);\r\nreturn 0;\r\n}
