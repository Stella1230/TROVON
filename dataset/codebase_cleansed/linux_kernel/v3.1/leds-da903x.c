static void da903x_led_work(struct work_struct *work)\r\n{\r\nstruct da903x_led *led = container_of(work, struct da903x_led, work);\r\nuint8_t val;\r\nint offset;\r\nswitch (led->id) {\r\ncase DA9030_ID_LED_1:\r\ncase DA9030_ID_LED_2:\r\ncase DA9030_ID_LED_3:\r\ncase DA9030_ID_LED_4:\r\ncase DA9030_ID_LED_PC:\r\noffset = DA9030_LED_OFFSET(led->id);\r\nval = led->flags & ~0x87;\r\nval |= (led->new_brightness) ? 0x80 : 0;\r\nval |= (0x7 - (led->new_brightness >> 5)) & 0x7;\r\nda903x_write(led->master, DA9030_LED1_CONTROL + offset, val);\r\nbreak;\r\ncase DA9030_ID_VIBRA:\r\nval = led->flags & ~0x80;\r\nval |= (led->new_brightness) ? 0x80 : 0;\r\nda903x_write(led->master, DA9030_MISC_CONTROL_A, val);\r\nbreak;\r\ncase DA9034_ID_LED_1:\r\ncase DA9034_ID_LED_2:\r\noffset = DA9034_LED_OFFSET(led->id);\r\nval = (led->new_brightness * 0x5f / LED_FULL) & 0x7f;\r\nval |= (led->flags & DA9034_LED_RAMP) ? 0x80 : 0;\r\nda903x_write(led->master, DA9034_LED1_CONTROL + offset, val);\r\nbreak;\r\ncase DA9034_ID_VIBRA:\r\nval = led->new_brightness & 0xfe;\r\nda903x_write(led->master, DA9034_VIBRA, val);\r\nbreak;\r\n}\r\n}\r\nstatic void da903x_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct da903x_led *led;\r\nled = container_of(led_cdev, struct da903x_led, cdev);\r\nled->new_brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic int __devinit da903x_led_probe(struct platform_device *pdev)\r\n{\r\nstruct led_info *pdata = pdev->dev.platform_data;\r\nstruct da903x_led *led;\r\nint id, ret;\r\nif (pdata == NULL)\r\nreturn 0;\r\nid = pdev->id;\r\nif (!((id >= DA9030_ID_LED_1 && id <= DA9030_ID_VIBRA) ||\r\n(id >= DA9034_ID_LED_1 && id <= DA9034_ID_VIBRA))) {\r\ndev_err(&pdev->dev, "invalid LED ID (%d) specified\n", id);\r\nreturn -EINVAL;\r\n}\r\nled = kzalloc(sizeof(struct da903x_led), GFP_KERNEL);\r\nif (led == NULL) {\r\ndev_err(&pdev->dev, "failed to alloc memory for LED%d\n", id);\r\nreturn -ENOMEM;\r\n}\r\nled->cdev.name = pdata->name;\r\nled->cdev.default_trigger = pdata->default_trigger;\r\nled->cdev.brightness_set = da903x_led_set;\r\nled->cdev.brightness = LED_OFF;\r\nled->id = id;\r\nled->flags = pdata->flags;\r\nled->master = pdev->dev.parent;\r\nled->new_brightness = LED_OFF;\r\nINIT_WORK(&led->work, da903x_led_work);\r\nret = led_classdev_register(led->master, &led->cdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register LED %d\n", id);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, led);\r\nreturn 0;\r\nerr:\r\nkfree(led);\r\nreturn ret;\r\n}\r\nstatic int __devexit da903x_led_remove(struct platform_device *pdev)\r\n{\r\nstruct da903x_led *led = platform_get_drvdata(pdev);\r\nled_classdev_unregister(&led->cdev);\r\nkfree(led);\r\nreturn 0;\r\n}\r\nstatic int __init da903x_led_init(void)\r\n{\r\nreturn platform_driver_register(&da903x_led_driver);\r\n}\r\nstatic void __exit da903x_led_exit(void)\r\n{\r\nplatform_driver_unregister(&da903x_led_driver);\r\n}
