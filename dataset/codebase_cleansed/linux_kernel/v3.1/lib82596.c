static inline int wait_istat(struct net_device *dev, struct i596_dma *dma, int delcnt, char *str)\r\n{\r\nDMA_INV(dev, &(dma->iscp), sizeof(struct i596_iscp));\r\nwhile (--delcnt && dma->iscp.stat) {\r\nudelay(10);\r\nDMA_INV(dev, &(dma->iscp), sizeof(struct i596_iscp));\r\n}\r\nif (!delcnt) {\r\nprintk(KERN_ERR "%s: %s, iscp.stat %04x, didn't clear\n",\r\ndev->name, str, SWAP16(dma->iscp.stat));\r\nreturn -1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic inline int wait_cmd(struct net_device *dev, struct i596_dma *dma, int delcnt, char *str)\r\n{\r\nDMA_INV(dev, &(dma->scb), sizeof(struct i596_scb));\r\nwhile (--delcnt && dma->scb.command) {\r\nudelay(10);\r\nDMA_INV(dev, &(dma->scb), sizeof(struct i596_scb));\r\n}\r\nif (!delcnt) {\r\nprintk(KERN_ERR "%s: %s, status %4.4x, cmd %4.4x.\n",\r\ndev->name, str,\r\nSWAP16(dma->scb.status),\r\nSWAP16(dma->scb.command));\r\nreturn -1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic void i596_display_data(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_dma *dma = lp->dma;\r\nstruct i596_cmd *cmd;\r\nstruct i596_rfd *rfd;\r\nstruct i596_rbd *rbd;\r\nprintk(KERN_DEBUG "lp and scp at %p, .sysbus = %08x, .iscp = %08x\n",\r\n&dma->scp, dma->scp.sysbus, SWAP32(dma->scp.iscp));\r\nprintk(KERN_DEBUG "iscp at %p, iscp.stat = %08x, .scb = %08x\n",\r\n&dma->iscp, SWAP32(dma->iscp.stat), SWAP32(dma->iscp.scb));\r\nprintk(KERN_DEBUG "scb at %p, scb.status = %04x, .command = %04x,"\r\n" .cmd = %08x, .rfd = %08x\n",\r\n&dma->scb, SWAP16(dma->scb.status), SWAP16(dma->scb.command),\r\nSWAP16(dma->scb.cmd), SWAP32(dma->scb.rfd));\r\nprintk(KERN_DEBUG " errors: crc %x, align %x, resource %x,"\r\n" over %x, rcvdt %x, short %x\n",\r\nSWAP32(dma->scb.crc_err), SWAP32(dma->scb.align_err),\r\nSWAP32(dma->scb.resource_err), SWAP32(dma->scb.over_err),\r\nSWAP32(dma->scb.rcvdt_err), SWAP32(dma->scb.short_err));\r\ncmd = lp->cmd_head;\r\nwhile (cmd != NULL) {\r\nprintk(KERN_DEBUG\r\n"cmd at %p, .status = %04x, .command = %04x,"\r\n" .b_next = %08x\n",\r\ncmd, SWAP16(cmd->status), SWAP16(cmd->command),\r\nSWAP32(cmd->b_next));\r\ncmd = cmd->v_next;\r\n}\r\nrfd = lp->rfd_head;\r\nprintk(KERN_DEBUG "rfd_head = %p\n", rfd);\r\ndo {\r\nprintk(KERN_DEBUG\r\n" %p .stat %04x, .cmd %04x, b_next %08x, rbd %08x,"\r\n" count %04x\n",\r\nrfd, SWAP16(rfd->stat), SWAP16(rfd->cmd),\r\nSWAP32(rfd->b_next), SWAP32(rfd->rbd),\r\nSWAP16(rfd->count));\r\nrfd = rfd->v_next;\r\n} while (rfd != lp->rfd_head);\r\nrbd = lp->rbd_head;\r\nprintk(KERN_DEBUG "rbd_head = %p\n", rbd);\r\ndo {\r\nprintk(KERN_DEBUG\r\n" %p .count %04x, b_next %08x, b_data %08x,"\r\n" size %04x\n",\r\nrbd, SWAP16(rbd->count), SWAP32(rbd->b_next),\r\nSWAP32(rbd->b_data), SWAP16(rbd->size));\r\nrbd = rbd->v_next;\r\n} while (rbd != lp->rbd_head);\r\nDMA_INV(dev, dma, sizeof(struct i596_dma));\r\n}\r\nstatic inline int init_rx_bufs(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_dma *dma = lp->dma;\r\nint i;\r\nstruct i596_rfd *rfd;\r\nstruct i596_rbd *rbd;\r\nfor (i = 0, rbd = dma->rbds; i < rx_ring_size; i++, rbd++) {\r\ndma_addr_t dma_addr;\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb_ip_align(dev, PKT_BUF_SZ);\r\nif (skb == NULL)\r\nreturn -1;\r\ndma_addr = dma_map_single(dev->dev.parent, skb->data,\r\nPKT_BUF_SZ, DMA_FROM_DEVICE);\r\nrbd->v_next = rbd+1;\r\nrbd->b_next = SWAP32(virt_to_dma(lp, rbd+1));\r\nrbd->b_addr = SWAP32(virt_to_dma(lp, rbd));\r\nrbd->skb = skb;\r\nrbd->v_data = skb->data;\r\nrbd->b_data = SWAP32(dma_addr);\r\nrbd->size = SWAP16(PKT_BUF_SZ);\r\n}\r\nlp->rbd_head = dma->rbds;\r\nrbd = dma->rbds + rx_ring_size - 1;\r\nrbd->v_next = dma->rbds;\r\nrbd->b_next = SWAP32(virt_to_dma(lp, dma->rbds));\r\nfor (i = 0, rfd = dma->rfds; i < rx_ring_size; i++, rfd++) {\r\nrfd->rbd = I596_NULL;\r\nrfd->v_next = rfd+1;\r\nrfd->v_prev = rfd-1;\r\nrfd->b_next = SWAP32(virt_to_dma(lp, rfd+1));\r\nrfd->cmd = SWAP16(CMD_FLEX);\r\n}\r\nlp->rfd_head = dma->rfds;\r\ndma->scb.rfd = SWAP32(virt_to_dma(lp, dma->rfds));\r\nrfd = dma->rfds;\r\nrfd->rbd = SWAP32(virt_to_dma(lp, lp->rbd_head));\r\nrfd->v_prev = dma->rfds + rx_ring_size - 1;\r\nrfd = dma->rfds + rx_ring_size - 1;\r\nrfd->v_next = dma->rfds;\r\nrfd->b_next = SWAP32(virt_to_dma(lp, dma->rfds));\r\nrfd->cmd = SWAP16(CMD_EOL|CMD_FLEX);\r\nDMA_WBACK_INV(dev, dma, sizeof(struct i596_dma));\r\nreturn 0;\r\n}\r\nstatic inline void remove_rx_bufs(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_rbd *rbd;\r\nint i;\r\nfor (i = 0, rbd = lp->dma->rbds; i < rx_ring_size; i++, rbd++) {\r\nif (rbd->skb == NULL)\r\nbreak;\r\ndma_unmap_single(dev->dev.parent,\r\n(dma_addr_t)SWAP32(rbd->b_data),\r\nPKT_BUF_SZ, DMA_FROM_DEVICE);\r\ndev_kfree_skb(rbd->skb);\r\n}\r\n}\r\nstatic void rebuild_rx_bufs(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_dma *dma = lp->dma;\r\nint i;\r\nfor (i = 0; i < rx_ring_size; i++) {\r\ndma->rfds[i].rbd = I596_NULL;\r\ndma->rfds[i].cmd = SWAP16(CMD_FLEX);\r\n}\r\ndma->rfds[rx_ring_size-1].cmd = SWAP16(CMD_EOL|CMD_FLEX);\r\nlp->rfd_head = dma->rfds;\r\ndma->scb.rfd = SWAP32(virt_to_dma(lp, dma->rfds));\r\nlp->rbd_head = dma->rbds;\r\ndma->rfds[0].rbd = SWAP32(virt_to_dma(lp, dma->rbds));\r\nDMA_WBACK_INV(dev, dma, sizeof(struct i596_dma));\r\n}\r\nstatic int init_i596_mem(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_dma *dma = lp->dma;\r\nunsigned long flags;\r\nmpu_port(dev, PORT_RESET, 0);\r\nudelay(100);\r\nlp->last_cmd = jiffies;\r\ndma->scp.sysbus = SYSBUS;\r\ndma->scp.iscp = SWAP32(virt_to_dma(lp, &(dma->iscp)));\r\ndma->iscp.scb = SWAP32(virt_to_dma(lp, &(dma->scb)));\r\ndma->iscp.stat = SWAP32(ISCP_BUSY);\r\nlp->cmd_backlog = 0;\r\nlp->cmd_head = NULL;\r\ndma->scb.cmd = I596_NULL;\r\nDEB(DEB_INIT, printk(KERN_DEBUG "%s: starting i82596.\n", dev->name));\r\nDMA_WBACK(dev, &(dma->scp), sizeof(struct i596_scp));\r\nDMA_WBACK(dev, &(dma->iscp), sizeof(struct i596_iscp));\r\nDMA_WBACK(dev, &(dma->scb), sizeof(struct i596_scb));\r\nmpu_port(dev, PORT_ALTSCP, virt_to_dma(lp, &dma->scp));\r\nca(dev);\r\nif (wait_istat(dev, dma, 1000, "initialization timed out"))\r\ngoto failed;\r\nDEB(DEB_INIT, printk(KERN_DEBUG\r\n"%s: i82596 initialization successful\n",\r\ndev->name));\r\nif (request_irq(dev->irq, i596_interrupt, 0, "i82596", dev)) {\r\nprintk(KERN_ERR "%s: IRQ %d not free\n", dev->name, dev->irq);\r\ngoto failed;\r\n}\r\nrebuild_rx_bufs(dev);\r\ndma->scb.command = 0;\r\nDMA_WBACK(dev, &(dma->scb), sizeof(struct i596_scb));\r\nDEB(DEB_INIT, printk(KERN_DEBUG\r\n"%s: queuing CmdConfigure\n", dev->name));\r\nmemcpy(dma->cf_cmd.i596_config, init_setup, 14);\r\ndma->cf_cmd.cmd.command = SWAP16(CmdConfigure);\r\nDMA_WBACK(dev, &(dma->cf_cmd), sizeof(struct cf_cmd));\r\ni596_add_cmd(dev, &dma->cf_cmd.cmd);\r\nDEB(DEB_INIT, printk(KERN_DEBUG "%s: queuing CmdSASetup\n", dev->name));\r\nmemcpy(dma->sa_cmd.eth_addr, dev->dev_addr, 6);\r\ndma->sa_cmd.cmd.command = SWAP16(CmdSASetup);\r\nDMA_WBACK(dev, &(dma->sa_cmd), sizeof(struct sa_cmd));\r\ni596_add_cmd(dev, &dma->sa_cmd.cmd);\r\nDEB(DEB_INIT, printk(KERN_DEBUG "%s: queuing CmdTDR\n", dev->name));\r\ndma->tdr_cmd.cmd.command = SWAP16(CmdTDR);\r\nDMA_WBACK(dev, &(dma->tdr_cmd), sizeof(struct tdr_cmd));\r\ni596_add_cmd(dev, &dma->tdr_cmd.cmd);\r\nspin_lock_irqsave (&lp->lock, flags);\r\nif (wait_cmd(dev, dma, 1000, "timed out waiting to issue RX_START")) {\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\ngoto failed_free_irq;\r\n}\r\nDEB(DEB_INIT, printk(KERN_DEBUG "%s: Issuing RX_START\n", dev->name));\r\ndma->scb.command = SWAP16(RX_START);\r\ndma->scb.rfd = SWAP32(virt_to_dma(lp, dma->rfds));\r\nDMA_WBACK(dev, &(dma->scb), sizeof(struct i596_scb));\r\nca(dev);\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\nif (wait_cmd(dev, dma, 1000, "RX_START not processed"))\r\ngoto failed_free_irq;\r\nDEB(DEB_INIT, printk(KERN_DEBUG\r\n"%s: Receive unit started OK\n", dev->name));\r\nreturn 0;\r\nfailed_free_irq:\r\nfree_irq(dev->irq, dev);\r\nfailed:\r\nprintk(KERN_ERR "%s: Failed to initialise 82596\n", dev->name);\r\nmpu_port(dev, PORT_RESET, 0);\r\nreturn -1;\r\n}\r\nstatic inline int i596_rx(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_rfd *rfd;\r\nstruct i596_rbd *rbd;\r\nint frames = 0;\r\nDEB(DEB_RXFRAME, printk(KERN_DEBUG\r\n"i596_rx(), rfd_head %p, rbd_head %p\n",\r\nlp->rfd_head, lp->rbd_head));\r\nrfd = lp->rfd_head;\r\nDMA_INV(dev, rfd, sizeof(struct i596_rfd));\r\nwhile (rfd->stat & SWAP16(STAT_C)) {\r\nif (rfd->rbd == I596_NULL)\r\nrbd = NULL;\r\nelse if (rfd->rbd == lp->rbd_head->b_addr) {\r\nrbd = lp->rbd_head;\r\nDMA_INV(dev, rbd, sizeof(struct i596_rbd));\r\n} else {\r\nprintk(KERN_ERR "%s: rbd chain broken!\n", dev->name);\r\nrbd = NULL;\r\n}\r\nDEB(DEB_RXFRAME, printk(KERN_DEBUG\r\n" rfd %p, rfd.rbd %08x, rfd.stat %04x\n",\r\nrfd, rfd->rbd, rfd->stat));\r\nif (rbd != NULL && (rfd->stat & SWAP16(STAT_OK))) {\r\nint pkt_len = SWAP16(rbd->count) & 0x3fff;\r\nstruct sk_buff *skb = rbd->skb;\r\nint rx_in_place = 0;\r\nDEB(DEB_RXADDR, print_eth(rbd->v_data, "received"));\r\nframes++;\r\nif (pkt_len > rx_copybreak) {\r\nstruct sk_buff *newskb;\r\ndma_addr_t dma_addr;\r\ndma_unmap_single(dev->dev.parent,\r\n(dma_addr_t)SWAP32(rbd->b_data),\r\nPKT_BUF_SZ, DMA_FROM_DEVICE);\r\nnewskb = netdev_alloc_skb_ip_align(dev,\r\nPKT_BUF_SZ);\r\nif (newskb == NULL) {\r\nskb = NULL;\r\ngoto memory_squeeze;\r\n}\r\nskb_put(skb, pkt_len);\r\nrx_in_place = 1;\r\nrbd->skb = newskb;\r\ndma_addr = dma_map_single(dev->dev.parent,\r\nnewskb->data,\r\nPKT_BUF_SZ,\r\nDMA_FROM_DEVICE);\r\nrbd->v_data = newskb->data;\r\nrbd->b_data = SWAP32(dma_addr);\r\nDMA_WBACK_INV(dev, rbd, sizeof(struct i596_rbd));\r\n} else\r\nskb = netdev_alloc_skb_ip_align(dev, pkt_len);\r\nmemory_squeeze:\r\nif (skb == NULL) {\r\nprintk(KERN_ERR\r\n"%s: i596_rx Memory squeeze, dropping packet.\n",\r\ndev->name);\r\ndev->stats.rx_dropped++;\r\n} else {\r\nif (!rx_in_place) {\r\ndma_sync_single_for_cpu(dev->dev.parent,\r\n(dma_addr_t)SWAP32(rbd->b_data),\r\nPKT_BUF_SZ, DMA_FROM_DEVICE);\r\nmemcpy(skb_put(skb, pkt_len), rbd->v_data, pkt_len);\r\ndma_sync_single_for_device(dev->dev.parent,\r\n(dma_addr_t)SWAP32(rbd->b_data),\r\nPKT_BUF_SZ, DMA_FROM_DEVICE);\r\n}\r\nskb->len = pkt_len;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\n} else {\r\nDEB(DEB_ERRORS, printk(KERN_DEBUG\r\n"%s: Error, rfd.stat = 0x%04x\n",\r\ndev->name, rfd->stat));\r\ndev->stats.rx_errors++;\r\nif (rfd->stat & SWAP16(0x0100))\r\ndev->stats.collisions++;\r\nif (rfd->stat & SWAP16(0x8000))\r\ndev->stats.rx_length_errors++;\r\nif (rfd->stat & SWAP16(0x0001))\r\ndev->stats.rx_over_errors++;\r\nif (rfd->stat & SWAP16(0x0002))\r\ndev->stats.rx_fifo_errors++;\r\nif (rfd->stat & SWAP16(0x0004))\r\ndev->stats.rx_frame_errors++;\r\nif (rfd->stat & SWAP16(0x0008))\r\ndev->stats.rx_crc_errors++;\r\nif (rfd->stat & SWAP16(0x0010))\r\ndev->stats.rx_length_errors++;\r\n}\r\nif (rbd != NULL && (rbd->count & SWAP16(0x4000))) {\r\nrbd->count = 0;\r\nlp->rbd_head = rbd->v_next;\r\nDMA_WBACK_INV(dev, rbd, sizeof(struct i596_rbd));\r\n}\r\nrfd->rbd = I596_NULL;\r\nrfd->stat = 0;\r\nrfd->cmd = SWAP16(CMD_EOL|CMD_FLEX);\r\nrfd->count = 0;\r\nlp->dma->scb.rfd = rfd->b_next;\r\nlp->rfd_head = rfd->v_next;\r\nDMA_WBACK_INV(dev, rfd, sizeof(struct i596_rfd));\r\nrfd->v_prev->cmd = SWAP16(CMD_FLEX);\r\nDMA_WBACK_INV(dev, rfd->v_prev, sizeof(struct i596_rfd));\r\nrfd = lp->rfd_head;\r\nDMA_INV(dev, rfd, sizeof(struct i596_rfd));\r\n}\r\nDEB(DEB_RXFRAME, printk(KERN_DEBUG "frames %d\n", frames));\r\nreturn 0;\r\n}\r\nstatic inline void i596_cleanup_cmd(struct net_device *dev, struct i596_private *lp)\r\n{\r\nstruct i596_cmd *ptr;\r\nwhile (lp->cmd_head != NULL) {\r\nptr = lp->cmd_head;\r\nlp->cmd_head = ptr->v_next;\r\nlp->cmd_backlog--;\r\nswitch (SWAP16(ptr->command) & 0x7) {\r\ncase CmdTx:\r\n{\r\nstruct tx_cmd *tx_cmd = (struct tx_cmd *) ptr;\r\nstruct sk_buff *skb = tx_cmd->skb;\r\ndma_unmap_single(dev->dev.parent,\r\ntx_cmd->dma_addr,\r\nskb->len, DMA_TO_DEVICE);\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nptr->v_next = NULL;\r\nptr->b_next = I596_NULL;\r\ntx_cmd->cmd.command = 0;\r\nbreak;\r\n}\r\ndefault:\r\nptr->v_next = NULL;\r\nptr->b_next = I596_NULL;\r\n}\r\nDMA_WBACK_INV(dev, ptr, sizeof(struct i596_cmd));\r\n}\r\nwait_cmd(dev, lp->dma, 100, "i596_cleanup_cmd timed out");\r\nlp->dma->scb.cmd = I596_NULL;\r\nDMA_WBACK(dev, &(lp->dma->scb), sizeof(struct i596_scb));\r\n}\r\nstatic inline void i596_reset(struct net_device *dev, struct i596_private *lp)\r\n{\r\nunsigned long flags;\r\nDEB(DEB_RESET, printk(KERN_DEBUG "i596_reset\n"));\r\nspin_lock_irqsave (&lp->lock, flags);\r\nwait_cmd(dev, lp->dma, 100, "i596_reset timed out");\r\nnetif_stop_queue(dev);\r\nlp->dma->scb.command = SWAP16(CUC_ABORT | RX_ABORT);\r\nDMA_WBACK(dev, &(lp->dma->scb), sizeof(struct i596_scb));\r\nca(dev);\r\nwait_cmd(dev, lp->dma, 1000, "i596_reset 2 timed out");\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\ni596_cleanup_cmd(dev, lp);\r\ni596_rx(dev);\r\nnetif_start_queue(dev);\r\ninit_i596_mem(dev);\r\n}\r\nstatic void i596_add_cmd(struct net_device *dev, struct i596_cmd *cmd)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_dma *dma = lp->dma;\r\nunsigned long flags;\r\nDEB(DEB_ADDCMD, printk(KERN_DEBUG "i596_add_cmd cmd_head %p\n",\r\nlp->cmd_head));\r\ncmd->status = 0;\r\ncmd->command |= SWAP16(CMD_EOL | CMD_INTR);\r\ncmd->v_next = NULL;\r\ncmd->b_next = I596_NULL;\r\nDMA_WBACK(dev, cmd, sizeof(struct i596_cmd));\r\nspin_lock_irqsave (&lp->lock, flags);\r\nif (lp->cmd_head != NULL) {\r\nlp->cmd_tail->v_next = cmd;\r\nlp->cmd_tail->b_next = SWAP32(virt_to_dma(lp, &cmd->status));\r\nDMA_WBACK(dev, lp->cmd_tail, sizeof(struct i596_cmd));\r\n} else {\r\nlp->cmd_head = cmd;\r\nwait_cmd(dev, dma, 100, "i596_add_cmd timed out");\r\ndma->scb.cmd = SWAP32(virt_to_dma(lp, &cmd->status));\r\ndma->scb.command = SWAP16(CUC_START);\r\nDMA_WBACK(dev, &(dma->scb), sizeof(struct i596_scb));\r\nca(dev);\r\n}\r\nlp->cmd_tail = cmd;\r\nlp->cmd_backlog++;\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\nif (lp->cmd_backlog > max_cmd_backlog) {\r\nunsigned long tickssofar = jiffies - lp->last_cmd;\r\nif (tickssofar < ticks_limit)\r\nreturn;\r\nprintk(KERN_ERR\r\n"%s: command unit timed out, status resetting.\n",\r\ndev->name);\r\n#if 1\r\ni596_reset(dev, lp);\r\n#endif\r\n}\r\n}\r\nstatic int i596_open(struct net_device *dev)\r\n{\r\nDEB(DEB_OPEN, printk(KERN_DEBUG\r\n"%s: i596_open() irq %d.\n", dev->name, dev->irq));\r\nif (init_rx_bufs(dev)) {\r\nprintk(KERN_ERR "%s: Failed to init rx bufs\n", dev->name);\r\nreturn -EAGAIN;\r\n}\r\nif (init_i596_mem(dev)) {\r\nprintk(KERN_ERR "%s: Failed to init memory\n", dev->name);\r\ngoto out_remove_rx_bufs;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_remove_rx_bufs:\r\nremove_rx_bufs(dev);\r\nreturn -EAGAIN;\r\n}\r\nstatic void i596_tx_timeout (struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nDEB(DEB_ERRORS, printk(KERN_DEBUG\r\n"%s: transmit timed out, status resetting.\n",\r\ndev->name));\r\ndev->stats.tx_errors++;\r\nif (lp->last_restart == dev->stats.tx_packets) {\r\nDEB(DEB_ERRORS, printk(KERN_DEBUG "Resetting board.\n"));\r\ni596_reset (dev, lp);\r\n} else {\r\nDEB(DEB_ERRORS, printk(KERN_DEBUG "Kicking board.\n"));\r\nlp->dma->scb.command = SWAP16(CUC_START | RX_START);\r\nDMA_WBACK_INV(dev, &(lp->dma->scb), sizeof(struct i596_scb));\r\nca (dev);\r\nlp->last_restart = dev->stats.tx_packets;\r\n}\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue (dev);\r\n}\r\nstatic int i596_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct tx_cmd *tx_cmd;\r\nstruct i596_tbd *tbd;\r\nshort length = skb->len;\r\nDEB(DEB_STARTTX, printk(KERN_DEBUG\r\n"%s: i596_start_xmit(%x,%p) called\n",\r\ndev->name, skb->len, skb->data));\r\nif (length < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\nnetif_stop_queue(dev);\r\ntx_cmd = lp->dma->tx_cmds + lp->next_tx_cmd;\r\ntbd = lp->dma->tbds + lp->next_tx_cmd;\r\nif (tx_cmd->cmd.command) {\r\nDEB(DEB_ERRORS, printk(KERN_DEBUG\r\n"%s: xmit ring full, dropping packet.\n",\r\ndev->name));\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\n} else {\r\nif (++lp->next_tx_cmd == TX_RING_SIZE)\r\nlp->next_tx_cmd = 0;\r\ntx_cmd->tbd = SWAP32(virt_to_dma(lp, tbd));\r\ntbd->next = I596_NULL;\r\ntx_cmd->cmd.command = SWAP16(CMD_FLEX | CmdTx);\r\ntx_cmd->skb = skb;\r\ntx_cmd->pad = 0;\r\ntx_cmd->size = 0;\r\ntbd->pad = 0;\r\ntbd->size = SWAP16(EOF | length);\r\ntx_cmd->dma_addr = dma_map_single(dev->dev.parent, skb->data,\r\nskb->len, DMA_TO_DEVICE);\r\ntbd->data = SWAP32(tx_cmd->dma_addr);\r\nDEB(DEB_TXADDR, print_eth(skb->data, "tx-queued"));\r\nDMA_WBACK_INV(dev, tx_cmd, sizeof(struct tx_cmd));\r\nDMA_WBACK_INV(dev, tbd, sizeof(struct i596_tbd));\r\ni596_add_cmd(dev, &tx_cmd->cmd);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += length;\r\n}\r\nnetif_start_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void print_eth(unsigned char *add, char *str)\r\n{\r\nprintk(KERN_DEBUG "i596 0x%p, %pM --> %pM %02X%02X, %s\n",\r\nadd, add + 6, add, add[12], add[13], str);\r\n}\r\nstatic int __devinit i82596_probe(struct net_device *dev)\r\n{\r\nint i;\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_dma *dma;\r\nBUILD_BUG_ON(sizeof(struct i596_rfd) != 32);\r\nBUILD_BUG_ON(sizeof(struct i596_rbd) & 31);\r\nBUILD_BUG_ON(sizeof(struct tx_cmd) & 31);\r\nBUILD_BUG_ON(sizeof(struct i596_tbd) != 32);\r\n#ifndef __LP64__\r\nBUILD_BUG_ON(sizeof(struct i596_dma) > 4096);\r\n#endif\r\nif (!dev->base_addr || !dev->irq)\r\nreturn -ENODEV;\r\ndma = (struct i596_dma *) DMA_ALLOC(dev->dev.parent,\r\nsizeof(struct i596_dma), &lp->dma_addr, GFP_KERNEL);\r\nif (!dma) {\r\nprintk(KERN_ERR "%s: Couldn't get shared memory\n", __FILE__);\r\nreturn -ENOMEM;\r\n}\r\ndev->netdev_ops = &i596_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nmemset(dma, 0, sizeof(struct i596_dma));\r\nlp->dma = dma;\r\ndma->scb.command = 0;\r\ndma->scb.cmd = I596_NULL;\r\ndma->scb.rfd = I596_NULL;\r\nspin_lock_init(&lp->lock);\r\nDMA_WBACK_INV(dev, dma, sizeof(struct i596_dma));\r\ni = register_netdev(dev);\r\nif (i) {\r\nDMA_FREE(dev->dev.parent, sizeof(struct i596_dma),\r\n(void *)dma, lp->dma_addr);\r\nreturn i;\r\n}\r\nDEB(DEB_PROBE, printk(KERN_INFO "%s: 82596 at %#3lx, %pM IRQ %d.\n",\r\ndev->name, dev->base_addr, dev->dev_addr,\r\ndev->irq));\r\nDEB(DEB_INIT, printk(KERN_INFO\r\n"%s: dma at 0x%p (%d bytes), lp->scb at 0x%p\n",\r\ndev->name, dma, (int)sizeof(struct i596_dma),\r\n&dma->scb));\r\nreturn 0;\r\n}\r\nstatic void i596_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\ni596_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic irqreturn_t i596_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct i596_private *lp;\r\nstruct i596_dma *dma;\r\nunsigned short status, ack_cmd = 0;\r\nlp = netdev_priv(dev);\r\ndma = lp->dma;\r\nspin_lock (&lp->lock);\r\nwait_cmd(dev, dma, 100, "i596 interrupt, timeout");\r\nstatus = SWAP16(dma->scb.status);\r\nDEB(DEB_INTS, printk(KERN_DEBUG\r\n"%s: i596 interrupt, IRQ %d, status %4.4x.\n",\r\ndev->name, dev->irq, status));\r\nack_cmd = status & 0xf000;\r\nif (!ack_cmd) {\r\nDEB(DEB_ERRORS, printk(KERN_DEBUG\r\n"%s: interrupt with no events\n",\r\ndev->name));\r\nspin_unlock (&lp->lock);\r\nreturn IRQ_NONE;\r\n}\r\nif ((status & 0x8000) || (status & 0x2000)) {\r\nstruct i596_cmd *ptr;\r\nif ((status & 0x8000))\r\nDEB(DEB_INTS,\r\nprintk(KERN_DEBUG\r\n"%s: i596 interrupt completed command.\n",\r\ndev->name));\r\nif ((status & 0x2000))\r\nDEB(DEB_INTS,\r\nprintk(KERN_DEBUG\r\n"%s: i596 interrupt command unit inactive %x.\n",\r\ndev->name, status & 0x0700));\r\nwhile (lp->cmd_head != NULL) {\r\nDMA_INV(dev, lp->cmd_head, sizeof(struct i596_cmd));\r\nif (!(lp->cmd_head->status & SWAP16(STAT_C)))\r\nbreak;\r\nptr = lp->cmd_head;\r\nDEB(DEB_STATUS,\r\nprintk(KERN_DEBUG\r\n"cmd_head->status = %04x, ->command = %04x\n",\r\nSWAP16(lp->cmd_head->status),\r\nSWAP16(lp->cmd_head->command)));\r\nlp->cmd_head = ptr->v_next;\r\nlp->cmd_backlog--;\r\nswitch (SWAP16(ptr->command) & 0x7) {\r\ncase CmdTx:\r\n{\r\nstruct tx_cmd *tx_cmd = (struct tx_cmd *) ptr;\r\nstruct sk_buff *skb = tx_cmd->skb;\r\nif (ptr->status & SWAP16(STAT_OK)) {\r\nDEB(DEB_TXADDR,\r\nprint_eth(skb->data, "tx-done"));\r\n} else {\r\ndev->stats.tx_errors++;\r\nif (ptr->status & SWAP16(0x0020))\r\ndev->stats.collisions++;\r\nif (!(ptr->status & SWAP16(0x0040)))\r\ndev->stats.tx_heartbeat_errors++;\r\nif (ptr->status & SWAP16(0x0400))\r\ndev->stats.tx_carrier_errors++;\r\nif (ptr->status & SWAP16(0x0800))\r\ndev->stats.collisions++;\r\nif (ptr->status & SWAP16(0x1000))\r\ndev->stats.tx_aborted_errors++;\r\n}\r\ndma_unmap_single(dev->dev.parent,\r\ntx_cmd->dma_addr,\r\nskb->len, DMA_TO_DEVICE);\r\ndev_kfree_skb_irq(skb);\r\ntx_cmd->cmd.command = 0;\r\nbreak;\r\n}\r\ncase CmdTDR:\r\n{\r\nunsigned short status = SWAP16(((struct tdr_cmd *)ptr)->status);\r\nif (status & 0x8000) {\r\nDEB(DEB_ANY,\r\nprintk(KERN_DEBUG "%s: link ok.\n",\r\ndev->name));\r\n} else {\r\nif (status & 0x4000)\r\nprintk(KERN_ERR\r\n"%s: Transceiver problem.\n",\r\ndev->name);\r\nif (status & 0x2000)\r\nprintk(KERN_ERR\r\n"%s: Termination problem.\n",\r\ndev->name);\r\nif (status & 0x1000)\r\nprintk(KERN_ERR\r\n"%s: Short circuit.\n",\r\ndev->name);\r\nDEB(DEB_TDR,\r\nprintk(KERN_DEBUG "%s: Time %d.\n",\r\ndev->name, status & 0x07ff));\r\n}\r\nbreak;\r\n}\r\ncase CmdConfigure:\r\nptr->command = 0;\r\nbreak;\r\n}\r\nptr->v_next = NULL;\r\nptr->b_next = I596_NULL;\r\nDMA_WBACK(dev, ptr, sizeof(struct i596_cmd));\r\nlp->last_cmd = jiffies;\r\n}\r\nptr = lp->cmd_head;\r\nwhile ((ptr != NULL) && (ptr != lp->cmd_tail)) {\r\nstruct i596_cmd *prev = ptr;\r\nptr->command &= SWAP16(0x1fff);\r\nptr = ptr->v_next;\r\nDMA_WBACK_INV(dev, prev, sizeof(struct i596_cmd));\r\n}\r\nif (lp->cmd_head != NULL)\r\nack_cmd |= CUC_START;\r\ndma->scb.cmd = SWAP32(virt_to_dma(lp, &lp->cmd_head->status));\r\nDMA_WBACK_INV(dev, &dma->scb, sizeof(struct i596_scb));\r\n}\r\nif ((status & 0x1000) || (status & 0x4000)) {\r\nif ((status & 0x4000))\r\nDEB(DEB_INTS,\r\nprintk(KERN_DEBUG\r\n"%s: i596 interrupt received a frame.\n",\r\ndev->name));\r\ni596_rx(dev);\r\nif (status & 0x1000) {\r\nif (netif_running(dev)) {\r\nDEB(DEB_ERRORS,\r\nprintk(KERN_DEBUG\r\n"%s: i596 interrupt receive unit inactive, status 0x%x\n",\r\ndev->name, status));\r\nack_cmd |= RX_START;\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\nrebuild_rx_bufs(dev);\r\n}\r\n}\r\n}\r\nwait_cmd(dev, dma, 100, "i596 interrupt, timeout");\r\ndma->scb.command = SWAP16(ack_cmd);\r\nDMA_WBACK(dev, &dma->scb, sizeof(struct i596_scb));\r\nca(dev);\r\nwait_cmd(dev, dma, 100, "i596 interrupt, exit timeout");\r\nDEB(DEB_INTS, printk(KERN_DEBUG "%s: exiting interrupt.\n", dev->name));\r\nspin_unlock (&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int i596_close(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nDEB(DEB_INIT,\r\nprintk(KERN_DEBUG\r\n"%s: Shutting down ethercard, status was %4.4x.\n",\r\ndev->name, SWAP16(lp->dma->scb.status)));\r\nspin_lock_irqsave(&lp->lock, flags);\r\nwait_cmd(dev, lp->dma, 100, "close1 timed out");\r\nlp->dma->scb.command = SWAP16(CUC_ABORT | RX_ABORT);\r\nDMA_WBACK(dev, &lp->dma->scb, sizeof(struct i596_scb));\r\nca(dev);\r\nwait_cmd(dev, lp->dma, 100, "close2 timed out");\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nDEB(DEB_STRUCT, i596_display_data(dev));\r\ni596_cleanup_cmd(dev, lp);\r\nfree_irq(dev->irq, dev);\r\nremove_rx_bufs(dev);\r\nreturn 0;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_dma *dma = lp->dma;\r\nint config = 0, cnt;\r\nDEB(DEB_MULTI,\r\nprintk(KERN_DEBUG\r\n"%s: set multicast list, %d entries, promisc %s, allmulti %s\n",\r\ndev->name, netdev_mc_count(dev),\r\ndev->flags & IFF_PROMISC ? "ON" : "OFF",\r\ndev->flags & IFF_ALLMULTI ? "ON" : "OFF"));\r\nif ((dev->flags & IFF_PROMISC) &&\r\n!(dma->cf_cmd.i596_config[8] & 0x01)) {\r\ndma->cf_cmd.i596_config[8] |= 0x01;\r\nconfig = 1;\r\n}\r\nif (!(dev->flags & IFF_PROMISC) &&\r\n(dma->cf_cmd.i596_config[8] & 0x01)) {\r\ndma->cf_cmd.i596_config[8] &= ~0x01;\r\nconfig = 1;\r\n}\r\nif ((dev->flags & IFF_ALLMULTI) &&\r\n(dma->cf_cmd.i596_config[11] & 0x20)) {\r\ndma->cf_cmd.i596_config[11] &= ~0x20;\r\nconfig = 1;\r\n}\r\nif (!(dev->flags & IFF_ALLMULTI) &&\r\n!(dma->cf_cmd.i596_config[11] & 0x20)) {\r\ndma->cf_cmd.i596_config[11] |= 0x20;\r\nconfig = 1;\r\n}\r\nif (config) {\r\nif (dma->cf_cmd.cmd.command)\r\nprintk(KERN_INFO\r\n"%s: config change request already queued\n",\r\ndev->name);\r\nelse {\r\ndma->cf_cmd.cmd.command = SWAP16(CmdConfigure);\r\nDMA_WBACK_INV(dev, &dma->cf_cmd, sizeof(struct cf_cmd));\r\ni596_add_cmd(dev, &dma->cf_cmd.cmd);\r\n}\r\n}\r\ncnt = netdev_mc_count(dev);\r\nif (cnt > MAX_MC_CNT) {\r\ncnt = MAX_MC_CNT;\r\nprintk(KERN_NOTICE "%s: Only %d multicast addresses supported",\r\ndev->name, cnt);\r\n}\r\nif (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nunsigned char *cp;\r\nstruct mc_cmd *cmd;\r\ncmd = &dma->mc_cmd;\r\ncmd->cmd.command = SWAP16(CmdMulticastList);\r\ncmd->mc_cnt = SWAP16(netdev_mc_count(dev) * 6);\r\ncp = cmd->mc_addrs;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (!cnt--)\r\nbreak;\r\nmemcpy(cp, ha->addr, 6);\r\nif (i596_debug > 1)\r\nDEB(DEB_MULTI,\r\nprintk(KERN_DEBUG\r\n"%s: Adding address %pM\n",\r\ndev->name, cp));\r\ncp += 6;\r\n}\r\nDMA_WBACK_INV(dev, &dma->mc_cmd, sizeof(struct mc_cmd));\r\ni596_add_cmd(dev, &cmd->cmd);\r\n}\r\n}
