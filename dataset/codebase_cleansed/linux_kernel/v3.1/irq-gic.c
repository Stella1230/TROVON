void gic_send_ipi(unsigned int intr)\r\n{\r\npr_debug("CPU%d: %s status %08x\n", smp_processor_id(), __func__,\r\nread_c0_status());\r\nGICWRITE(GIC_REG(SHARED, GIC_SH_WEDGE), 0x80000000 | intr);\r\n}\r\nstatic void __init vpe_local_setup(unsigned int numvpes)\r\n{\r\nint i;\r\nunsigned long timer_interrupt = 5, perf_interrupt = 5;\r\nunsigned int vpe_ctl;\r\nfor (i = 0; i < numvpes; i++) {\r\nGICWRITE(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), i);\r\nGICREAD(GIC_REG(VPE_OTHER, GIC_VPE_CTL), vpe_ctl);\r\nif (vpe_ctl & GIC_VPE_CTL_TIMER_RTBL_MSK)\r\nGICWRITE(GIC_REG(VPE_OTHER, GIC_VPE_TIMER_MAP),\r\nGIC_MAP_TO_PIN_MSK | timer_interrupt);\r\nif (vpe_ctl & GIC_VPE_CTL_PERFCNT_RTBL_MSK)\r\nGICWRITE(GIC_REG(VPE_OTHER, GIC_VPE_PERFCTR_MAP),\r\nGIC_MAP_TO_PIN_MSK | perf_interrupt);\r\n}\r\n}\r\nunsigned int gic_get_int(void)\r\n{\r\nunsigned int i;\r\nunsigned long *pending, *intrmask, *pcpu_mask;\r\nunsigned long *pending_abs, *intrmask_abs;\r\npending = pending_regs[smp_processor_id()].pending;\r\nintrmask = intrmask_regs[smp_processor_id()].intrmask;\r\npcpu_mask = pcpu_masks[smp_processor_id()].pcpu_mask;\r\npending_abs = (unsigned long *) GIC_REG_ABS_ADDR(SHARED,\r\nGIC_SH_PEND_31_0_OFS);\r\nintrmask_abs = (unsigned long *) GIC_REG_ABS_ADDR(SHARED,\r\nGIC_SH_MASK_31_0_OFS);\r\nfor (i = 0; i < BITS_TO_LONGS(GIC_NUM_INTRS); i++) {\r\nGICREAD(*pending_abs, pending[i]);\r\nGICREAD(*intrmask_abs, intrmask[i]);\r\npending_abs++;\r\nintrmask_abs++;\r\n}\r\nbitmap_and(pending, pending, intrmask, GIC_NUM_INTRS);\r\nbitmap_and(pending, pending, pcpu_mask, GIC_NUM_INTRS);\r\ni = find_first_bit(pending, GIC_NUM_INTRS);\r\npr_debug("CPU%d: %s pend=%d\n", smp_processor_id(), __func__, i);\r\nreturn i;\r\n}\r\nstatic void gic_irq_ack(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq - _irqbase;\r\npr_debug("CPU%d: %s: irq%d\n", smp_processor_id(), __func__, irq);\r\nGIC_CLR_INTR_MASK(irq);\r\nif (gic_irq_flags[irq] & GIC_IRQ_FLAG_EDGE)\r\nGICWRITE(GIC_REG(SHARED, GIC_SH_WEDGE), irq);\r\n}\r\nstatic void gic_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq - _irqbase;\r\npr_debug("CPU%d: %s: irq%d\n", smp_processor_id(), __func__, irq);\r\nGIC_CLR_INTR_MASK(irq);\r\n}\r\nstatic void gic_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq - _irqbase;\r\npr_debug("CPU%d: %s: irq%d\n", smp_processor_id(), __func__, irq);\r\nGIC_SET_INTR_MASK(irq);\r\n}\r\nstatic int gic_set_affinity(struct irq_data *d, const struct cpumask *cpumask,\r\nbool force)\r\n{\r\nunsigned int irq = d->irq - _irqbase;\r\ncpumask_t tmp = CPU_MASK_NONE;\r\nunsigned long flags;\r\nint i;\r\npr_debug("%s(%d) called\n", __func__, irq);\r\ncpumask_and(&tmp, cpumask, cpu_online_mask);\r\nif (cpus_empty(tmp))\r\nreturn -1;\r\nspin_lock_irqsave(&gic_lock, flags);\r\nfor (;;) {\r\nGIC_SH_MAP_TO_VPE_SMASK(irq, first_cpu(tmp));\r\nfor (i = 0; i < NR_CPUS; i++)\r\nclear_bit(irq, pcpu_masks[i].pcpu_mask);\r\nset_bit(irq, pcpu_masks[first_cpu(tmp)].pcpu_mask);\r\n}\r\ncpumask_copy(d->affinity, cpumask);\r\nspin_unlock_irqrestore(&gic_lock, flags);\r\nreturn IRQ_SET_MASK_OK_NOCOPY;\r\n}\r\nstatic void __init gic_setup_intr(unsigned int intr, unsigned int cpu,\r\nunsigned int pin, unsigned int polarity, unsigned int trigtype,\r\nunsigned int flags)\r\n{\r\nif (pin & GIC_MAP_TO_NMI_MSK) {\r\nGICWRITE(GIC_REG_ADDR(SHARED, GIC_SH_MAP_TO_PIN(intr)), pin);\r\nfor (cpu = 0; cpu < NR_CPUS; cpu += 32) {\r\nGICWRITE(GIC_REG_ADDR(SHARED,\r\nGIC_SH_MAP_TO_VPE_REG_OFF(intr, cpu)),\r\n0xffffffff);\r\n}\r\n} else {\r\nGICWRITE(GIC_REG_ADDR(SHARED, GIC_SH_MAP_TO_PIN(intr)),\r\nGIC_MAP_TO_PIN_MSK | pin);\r\nGIC_SH_MAP_TO_VPE_SMASK(intr, cpu);\r\n}\r\nGIC_SET_POLARITY(intr, polarity);\r\nGIC_SET_TRIGGER(intr, trigtype);\r\nGIC_CLR_INTR_MASK(intr);\r\nif (flags & GIC_FLAG_IPI)\r\nset_bit(intr, pcpu_masks[cpu].pcpu_mask);\r\nif (flags & GIC_FLAG_TRANSPARENT)\r\nGIC_SET_INTR_MASK(intr);\r\nif (trigtype == GIC_TRIG_EDGE)\r\ngic_irq_flags[intr] |= GIC_IRQ_FLAG_EDGE;\r\n}\r\nstatic void __init gic_basic_init(int numintrs, int numvpes,\r\nstruct gic_intr_map *intrmap, int mapsize)\r\n{\r\nunsigned int i, cpu;\r\nfor (i = 0; i < numintrs; i++) {\r\nGIC_SET_POLARITY(i, GIC_POL_POS);\r\nGIC_SET_TRIGGER(i, GIC_TRIG_LEVEL);\r\nGIC_CLR_INTR_MASK(i);\r\nif (i < GIC_NUM_INTRS)\r\ngic_irq_flags[i] = 0;\r\n}\r\nfor (i = 0; i < mapsize; i++) {\r\ncpu = intrmap[i].cpunum;\r\nif (cpu == GIC_UNUSED)\r\ncontinue;\r\nif (cpu == 0 && i != 0 && intrmap[i].flags == 0)\r\ncontinue;\r\ngic_setup_intr(i,\r\nintrmap[i].cpunum,\r\nintrmap[i].pin,\r\nintrmap[i].polarity,\r\nintrmap[i].trigtype,\r\nintrmap[i].flags);\r\n}\r\nvpe_local_setup(numvpes);\r\nfor (i = _irqbase; i < (_irqbase + numintrs); i++)\r\nirq_set_chip(i, &gic_irq_controller);\r\n}\r\nvoid __init gic_init(unsigned long gic_base_addr,\r\nunsigned long gic_addrspace_size,\r\nstruct gic_intr_map *intr_map, unsigned int intr_map_size,\r\nunsigned int irqbase)\r\n{\r\nunsigned int gicconfig;\r\nint numvpes, numintrs;\r\n_gic_base = (unsigned long) ioremap_nocache(gic_base_addr,\r\ngic_addrspace_size);\r\n_irqbase = irqbase;\r\nGICREAD(GIC_REG(SHARED, GIC_SH_CONFIG), gicconfig);\r\nnumintrs = (gicconfig & GIC_SH_CONFIG_NUMINTRS_MSK) >>\r\nGIC_SH_CONFIG_NUMINTRS_SHF;\r\nnumintrs = ((numintrs + 1) * 8);\r\nnumvpes = (gicconfig & GIC_SH_CONFIG_NUMVPES_MSK) >>\r\nGIC_SH_CONFIG_NUMVPES_SHF;\r\npr_debug("%s called\n", __func__);\r\ngic_basic_init(numintrs, numvpes, intr_map, intr_map_size);\r\n}
