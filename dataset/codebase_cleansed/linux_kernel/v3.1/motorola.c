static pte_t * __init kernel_page_table(void)\r\n{\r\npte_t *ptablep;\r\nptablep = (pte_t *)alloc_bootmem_low_pages(PAGE_SIZE);\r\nclear_page(ptablep);\r\n__flush_page_to_ram(ptablep);\r\nflush_tlb_kernel_page(ptablep);\r\nnocache_page(ptablep);\r\nreturn ptablep;\r\n}\r\nstatic pmd_t * __init kernel_ptr_table(void)\r\n{\r\nif (!last_pgtable) {\r\nunsigned long pmd, last;\r\nint i;\r\nlast = (unsigned long)kernel_pg_dir;\r\nfor (i = 0; i < PTRS_PER_PGD; i++) {\r\nif (!pgd_present(kernel_pg_dir[i]))\r\ncontinue;\r\npmd = __pgd_page(kernel_pg_dir[i]);\r\nif (pmd > last)\r\nlast = pmd;\r\n}\r\nlast_pgtable = (pmd_t *)last;\r\n#ifdef DEBUG\r\nprintk("kernel_ptr_init: %p\n", last_pgtable);\r\n#endif\r\n}\r\nlast_pgtable += PTRS_PER_PMD;\r\nif (((unsigned long)last_pgtable & ~PAGE_MASK) == 0) {\r\nlast_pgtable = (pmd_t *)alloc_bootmem_low_pages(PAGE_SIZE);\r\nclear_page(last_pgtable);\r\n__flush_page_to_ram(last_pgtable);\r\nflush_tlb_kernel_page(last_pgtable);\r\nnocache_page(last_pgtable);\r\n}\r\nreturn last_pgtable;\r\n}\r\nstatic void __init map_node(int node)\r\n{\r\n#define PTRTREESIZE (256*1024)\r\n#define ROOTTREESIZE (32*1024*1024)\r\nunsigned long physaddr, virtaddr, size;\r\npgd_t *pgd_dir;\r\npmd_t *pmd_dir;\r\npte_t *pte_dir;\r\nsize = m68k_memory[node].size;\r\nphysaddr = m68k_memory[node].addr;\r\nvirtaddr = (unsigned long)phys_to_virt(physaddr);\r\nphysaddr |= m68k_supervisor_cachemode |\r\n_PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_DIRTY;\r\nif (CPU_IS_040_OR_060)\r\nphysaddr |= _PAGE_GLOBAL040;\r\nwhile (size > 0) {\r\n#ifdef DEBUG\r\nif (!(virtaddr & (PTRTREESIZE-1)))\r\nprintk ("\npa=%#lx va=%#lx ", physaddr & PAGE_MASK,\r\nvirtaddr);\r\n#endif\r\npgd_dir = pgd_offset_k(virtaddr);\r\nif (virtaddr && CPU_IS_020_OR_030) {\r\nif (!(virtaddr & (ROOTTREESIZE-1)) &&\r\nsize >= ROOTTREESIZE) {\r\n#ifdef DEBUG\r\nprintk ("[very early term]");\r\n#endif\r\npgd_val(*pgd_dir) = physaddr;\r\nsize -= ROOTTREESIZE;\r\nvirtaddr += ROOTTREESIZE;\r\nphysaddr += ROOTTREESIZE;\r\ncontinue;\r\n}\r\n}\r\nif (!pgd_present(*pgd_dir)) {\r\npmd_dir = kernel_ptr_table();\r\n#ifdef DEBUG\r\nprintk ("[new pointer %p]", pmd_dir);\r\n#endif\r\npgd_set(pgd_dir, pmd_dir);\r\n} else\r\npmd_dir = pmd_offset(pgd_dir, virtaddr);\r\nif (CPU_IS_020_OR_030) {\r\nif (virtaddr) {\r\n#ifdef DEBUG\r\nprintk ("[early term]");\r\n#endif\r\npmd_dir->pmd[(virtaddr/PTRTREESIZE) & 15] = physaddr;\r\nphysaddr += PTRTREESIZE;\r\n} else {\r\nint i;\r\n#ifdef DEBUG\r\nprintk ("[zero map]");\r\n#endif\r\nzero_pgtable = kernel_ptr_table();\r\npte_dir = (pte_t *)zero_pgtable;\r\npmd_dir->pmd[0] = virt_to_phys(pte_dir) |\r\n_PAGE_TABLE | _PAGE_ACCESSED;\r\npte_val(*pte_dir++) = 0;\r\nphysaddr += PAGE_SIZE;\r\nfor (i = 1; i < 64; physaddr += PAGE_SIZE, i++)\r\npte_val(*pte_dir++) = physaddr;\r\n}\r\nsize -= PTRTREESIZE;\r\nvirtaddr += PTRTREESIZE;\r\n} else {\r\nif (!pmd_present(*pmd_dir)) {\r\n#ifdef DEBUG\r\nprintk ("[new table]");\r\n#endif\r\npte_dir = kernel_page_table();\r\npmd_set(pmd_dir, pte_dir);\r\n}\r\npte_dir = pte_offset_kernel(pmd_dir, virtaddr);\r\nif (virtaddr) {\r\nif (!pte_present(*pte_dir))\r\npte_val(*pte_dir) = physaddr;\r\n} else\r\npte_val(*pte_dir) = 0;\r\nsize -= PAGE_SIZE;\r\nvirtaddr += PAGE_SIZE;\r\nphysaddr += PAGE_SIZE;\r\n}\r\n}\r\n#ifdef DEBUG\r\nprintk("\n");\r\n#endif\r\n}\r\nvoid __init paging_init(void)\r\n{\r\nunsigned long zones_size[MAX_NR_ZONES] = { 0, };\r\nunsigned long min_addr, max_addr;\r\nunsigned long addr, size, end;\r\nint i;\r\n#ifdef DEBUG\r\nprintk ("start of paging_init (%p, %lx)\n", kernel_pg_dir, availmem);\r\n#endif\r\nif (CPU_IS_040_OR_060) {\r\nint i;\r\n#ifndef mm_cachebits\r\nmm_cachebits = _PAGE_CACHE040;\r\n#endif\r\nfor (i = 0; i < 16; i++)\r\npgprot_val(protection_map[i]) |= _PAGE_CACHE040;\r\n}\r\nmin_addr = m68k_memory[0].addr;\r\nmax_addr = min_addr + m68k_memory[0].size;\r\nfor (i = 1; i < m68k_num_memory;) {\r\nif (m68k_memory[i].addr < min_addr) {\r\nprintk("Ignoring memory chunk at 0x%lx:0x%lx before the first chunk\n",\r\nm68k_memory[i].addr, m68k_memory[i].size);\r\nprintk("Fix your bootloader or use a memfile to make use of this area!\n");\r\nm68k_num_memory--;\r\nmemmove(m68k_memory + i, m68k_memory + i + 1,\r\n(m68k_num_memory - i) * sizeof(struct mem_info));\r\ncontinue;\r\n}\r\naddr = m68k_memory[i].addr + m68k_memory[i].size;\r\nif (addr > max_addr)\r\nmax_addr = addr;\r\ni++;\r\n}\r\nm68k_memoffset = min_addr - PAGE_OFFSET;\r\nm68k_virt_to_node_shift = fls(max_addr - min_addr - 1) - 6;\r\nmodule_fixup(NULL, __start_fixup, __stop_fixup);\r\nflush_icache();\r\nhigh_memory = phys_to_virt(max_addr);\r\nmin_low_pfn = availmem >> PAGE_SHIFT;\r\nmax_low_pfn = max_addr >> PAGE_SHIFT;\r\nfor (i = 0; i < m68k_num_memory; i++) {\r\naddr = m68k_memory[i].addr;\r\nend = addr + m68k_memory[i].size;\r\nm68k_setup_node(i);\r\navailmem = PAGE_ALIGN(availmem);\r\navailmem += init_bootmem_node(NODE_DATA(i),\r\navailmem >> PAGE_SHIFT,\r\naddr >> PAGE_SHIFT,\r\nend >> PAGE_SHIFT);\r\n}\r\naddr = m68k_memory[0].addr;\r\nsize = m68k_memory[0].size;\r\nfree_bootmem_node(NODE_DATA(0), availmem, min(INIT_MAPPED_SIZE, size) - (availmem - addr));\r\nmap_node(0);\r\nif (size > INIT_MAPPED_SIZE)\r\nfree_bootmem_node(NODE_DATA(0), addr + INIT_MAPPED_SIZE, size - INIT_MAPPED_SIZE);\r\nfor (i = 1; i < m68k_num_memory; i++)\r\nmap_node(i);\r\nflush_tlb_all();\r\nempty_zero_page = alloc_bootmem_pages(PAGE_SIZE);\r\nset_fs(KERNEL_DS);\r\n#ifdef DEBUG\r\nprintk ("before free_area_init\n");\r\n#endif\r\nfor (i = 0; i < m68k_num_memory; i++) {\r\nzones_size[ZONE_DMA] = m68k_memory[i].size >> PAGE_SHIFT;\r\nfree_area_init_node(i, zones_size,\r\nm68k_memory[i].addr >> PAGE_SHIFT, NULL);\r\nif (node_present_pages(i))\r\nnode_set_state(i, N_NORMAL_MEMORY);\r\n}\r\n}\r\nvoid free_initmem(void)\r\n{\r\nunsigned long addr;\r\naddr = (unsigned long)__init_begin;\r\nfor (; addr < (unsigned long)__init_end; addr += PAGE_SIZE) {\r\nvirt_to_page(addr)->flags &= ~(1 << PG_reserved);\r\ninit_page_count(virt_to_page(addr));\r\nfree_page(addr);\r\ntotalram_pages++;\r\n}\r\n}
