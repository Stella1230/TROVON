static void i_usX2Y_Out04Int(struct urb *urb)\r\n{\r\n#ifdef CONFIG_SND_DEBUG\r\nif (urb->status) {\r\nint i;\r\nstruct usX2Ydev *usX2Y = urb->context;\r\nfor (i = 0; i < 10 && usX2Y->AS04.urb[i] != urb; i++);\r\nsnd_printdd("i_usX2Y_Out04Int() urb %i status=%i\n", i, urb->status);\r\n}\r\n#endif\r\n}\r\nstatic void i_usX2Y_In04Int(struct urb *urb)\r\n{\r\nint err = 0;\r\nstruct usX2Ydev *usX2Y = urb->context;\r\nstruct us428ctls_sharedmem *us428ctls = usX2Y->us428ctls_sharedmem;\r\nusX2Y->In04IntCalls++;\r\nif (urb->status) {\r\nsnd_printdd("Interrupt Pipe 4 came back with status=%i\n", urb->status);\r\nreturn;\r\n}\r\nif (us428ctls) {\r\nint diff = -1;\r\nif (-2 == us428ctls->CtlSnapShotLast) {\r\ndiff = 0;\r\nmemcpy(usX2Y->In04Last, usX2Y->In04Buf, sizeof(usX2Y->In04Last));\r\nus428ctls->CtlSnapShotLast = -1;\r\n} else {\r\nint i;\r\nfor (i = 0; i < 21; i++) {\r\nif (usX2Y->In04Last[i] != ((char*)usX2Y->In04Buf)[i]) {\r\nif (diff < 0)\r\ndiff = i;\r\nusX2Y->In04Last[i] = ((char*)usX2Y->In04Buf)[i];\r\n}\r\n}\r\n}\r\nif (0 <= diff) {\r\nint n = us428ctls->CtlSnapShotLast + 1;\r\nif (n >= N_us428_ctl_BUFS || n < 0)\r\nn = 0;\r\nmemcpy(us428ctls->CtlSnapShot + n, usX2Y->In04Buf, sizeof(us428ctls->CtlSnapShot[0]));\r\nus428ctls->CtlSnapShotDiffersAt[n] = diff;\r\nus428ctls->CtlSnapShotLast = n;\r\nwake_up(&usX2Y->us428ctls_wait_queue_head);\r\n}\r\n}\r\nif (usX2Y->US04) {\r\nif (0 == usX2Y->US04->submitted)\r\ndo {\r\nerr = usb_submit_urb(usX2Y->US04->urb[usX2Y->US04->submitted++], GFP_ATOMIC);\r\n} while (!err && usX2Y->US04->submitted < usX2Y->US04->len);\r\n} else\r\nif (us428ctls && us428ctls->p4outLast >= 0 && us428ctls->p4outLast < N_us428_p4out_BUFS) {\r\nif (us428ctls->p4outLast != us428ctls->p4outSent) {\r\nint j, send = us428ctls->p4outSent + 1;\r\nif (send >= N_us428_p4out_BUFS)\r\nsend = 0;\r\nfor (j = 0; j < URBS_AsyncSeq && !err; ++j)\r\nif (0 == usX2Y->AS04.urb[j]->status) {\r\nstruct us428_p4out *p4out = us428ctls->p4out + send;\r\nusb_fill_bulk_urb(usX2Y->AS04.urb[j], usX2Y->dev,\r\nusb_sndbulkpipe(usX2Y->dev, 0x04), &p4out->val.vol,\r\np4out->type == eLT_Light ? sizeof(struct us428_lights) : 5,\r\ni_usX2Y_Out04Int, usX2Y);\r\nerr = usb_submit_urb(usX2Y->AS04.urb[j], GFP_ATOMIC);\r\nus428ctls->p4outSent = send;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (err)\r\nsnd_printk(KERN_ERR "In04Int() usb_submit_urb err=%i\n", err);\r\nurb->dev = usX2Y->dev;\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nint usX2Y_AsyncSeq04_init(struct usX2Ydev *usX2Y)\r\n{\r\nint err = 0,\r\ni;\r\nif (NULL == (usX2Y->AS04.buffer = kmalloc(URB_DataLen_AsyncSeq*URBS_AsyncSeq, GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\n} else\r\nfor (i = 0; i < URBS_AsyncSeq; ++i) {\r\nif (NULL == (usX2Y->AS04.urb[i] = usb_alloc_urb(0, GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nusb_fill_bulk_urb( usX2Y->AS04.urb[i], usX2Y->dev,\r\nusb_sndbulkpipe(usX2Y->dev, 0x04),\r\nusX2Y->AS04.buffer + URB_DataLen_AsyncSeq*i, 0,\r\ni_usX2Y_Out04Int, usX2Y\r\n);\r\n}\r\nreturn err;\r\n}\r\nint usX2Y_In04_init(struct usX2Ydev *usX2Y)\r\n{\r\nif (! (usX2Y->In04urb = usb_alloc_urb(0, GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nif (! (usX2Y->In04Buf = kmalloc(21, GFP_KERNEL))) {\r\nusb_free_urb(usX2Y->In04urb);\r\nreturn -ENOMEM;\r\n}\r\ninit_waitqueue_head(&usX2Y->In04WaitQueue);\r\nusb_fill_int_urb(usX2Y->In04urb, usX2Y->dev, usb_rcvintpipe(usX2Y->dev, 0x4),\r\nusX2Y->In04Buf, 21,\r\ni_usX2Y_In04Int, usX2Y,\r\n10);\r\nreturn usb_submit_urb(usX2Y->In04urb, GFP_KERNEL);\r\n}\r\nstatic void usX2Y_unlinkSeq(struct snd_usX2Y_AsyncSeq *S)\r\n{\r\nint i;\r\nfor (i = 0; i < URBS_AsyncSeq; ++i) {\r\nif (S[i].urb) {\r\nusb_kill_urb(S->urb[i]);\r\nusb_free_urb(S->urb[i]);\r\nS->urb[i] = NULL;\r\n}\r\n}\r\nkfree(S->buffer);\r\n}\r\nstatic int usX2Y_create_card(struct usb_device *device, struct snd_card **cardp)\r\n{\r\nint dev;\r\nstruct snd_card * card;\r\nint err;\r\nfor (dev = 0; dev < SNDRV_CARDS; ++dev)\r\nif (enable[dev] && !snd_usX2Y_card_used[dev])\r\nbreak;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct usX2Ydev), &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_usX2Y_card_used[usX2Y(card)->card_index = dev] = 1;\r\ncard->private_free = snd_usX2Y_card_private_free;\r\nusX2Y(card)->dev = device;\r\ninit_waitqueue_head(&usX2Y(card)->prepare_wait_queue);\r\nmutex_init(&usX2Y(card)->prepare_mutex);\r\nINIT_LIST_HEAD(&usX2Y(card)->midi_list);\r\nstrcpy(card->driver, "USB "NAME_ALLCAPS"");\r\nsprintf(card->shortname, "TASCAM "NAME_ALLCAPS"");\r\nsprintf(card->longname, "%s (%x:%x if %d at %03d/%03d)",\r\ncard->shortname,\r\nle16_to_cpu(device->descriptor.idVendor),\r\nle16_to_cpu(device->descriptor.idProduct),\r\n0,\r\nusX2Y(card)->dev->bus->busnum, usX2Y(card)->dev->devnum\r\n);\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int usX2Y_usb_probe(struct usb_device *device,\r\nstruct usb_interface *intf,\r\nconst struct usb_device_id *device_id,\r\nstruct snd_card **cardp)\r\n{\r\nint err;\r\nstruct snd_card * card;\r\n*cardp = NULL;\r\nif (le16_to_cpu(device->descriptor.idVendor) != 0x1604 ||\r\n(le16_to_cpu(device->descriptor.idProduct) != USB_ID_US122 &&\r\nle16_to_cpu(device->descriptor.idProduct) != USB_ID_US224 &&\r\nle16_to_cpu(device->descriptor.idProduct) != USB_ID_US428))\r\nreturn -EINVAL;\r\nerr = usX2Y_create_card(device, &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, &intf->dev);\r\nif ((err = usX2Y_hwdep_new(card, device)) < 0 ||\r\n(err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int snd_usX2Y_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nerr = usX2Y_usb_probe(interface_to_usbdev(intf), intf, id, &card);\r\nif (err < 0)\r\nreturn err;\r\ndev_set_drvdata(&intf->dev, card);\r\nreturn 0;\r\n}\r\nstatic void snd_usX2Y_disconnect(struct usb_interface *intf)\r\n{\r\nusX2Y_usb_disconnect(interface_to_usbdev(intf),\r\nusb_get_intfdata(intf));\r\n}\r\nstatic void snd_usX2Y_card_private_free(struct snd_card *card)\r\n{\r\nkfree(usX2Y(card)->In04Buf);\r\nusb_free_urb(usX2Y(card)->In04urb);\r\nif (usX2Y(card)->us428ctls_sharedmem)\r\nsnd_free_pages(usX2Y(card)->us428ctls_sharedmem, sizeof(*usX2Y(card)->us428ctls_sharedmem));\r\nif (usX2Y(card)->card_index >= 0 && usX2Y(card)->card_index < SNDRV_CARDS)\r\nsnd_usX2Y_card_used[usX2Y(card)->card_index] = 0;\r\n}\r\nstatic void usX2Y_usb_disconnect(struct usb_device *device, void* ptr)\r\n{\r\nif (ptr) {\r\nstruct snd_card *card = ptr;\r\nstruct usX2Ydev *usX2Y = usX2Y(card);\r\nstruct list_head *p;\r\nusX2Y->chip_status = USX2Y_STAT_CHIP_HUP;\r\nusX2Y_unlinkSeq(&usX2Y->AS04);\r\nusb_kill_urb(usX2Y->In04urb);\r\nsnd_card_disconnect(card);\r\nlist_for_each(p, &usX2Y->midi_list) {\r\nsnd_usbmidi_disconnect(p);\r\n}\r\nif (usX2Y->us428ctls_sharedmem)\r\nwake_up(&usX2Y->us428ctls_wait_queue_head);\r\nsnd_card_free(card);\r\n}\r\n}\r\nstatic int __init snd_usX2Y_module_init(void)\r\n{\r\nreturn usb_register(&snd_usX2Y_usb_driver);\r\n}\r\nstatic void __exit snd_usX2Y_module_exit(void)\r\n{\r\nusb_deregister(&snd_usX2Y_usb_driver);\r\n}
