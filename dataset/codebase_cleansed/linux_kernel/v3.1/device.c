static int count_idrs(int id, void *p, void *data)\r\n{\r\nint *countp = data;\r\n*countp = *countp + 1;\r\nreturn 0;\r\n}\r\nstatic ssize_t debugfs_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct c4iw_debugfs_data *d = file->private_data;\r\nreturn simple_read_from_buffer(buf, count, ppos, d->buf, d->pos);\r\n}\r\nstatic int dump_qp(int id, void *p, void *data)\r\n{\r\nstruct c4iw_qp *qp = p;\r\nstruct c4iw_debugfs_data *qpd = data;\r\nint space;\r\nint cc;\r\nif (id != qp->wq.sq.qid)\r\nreturn 0;\r\nspace = qpd->bufsize - qpd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\nif (qp->ep)\r\ncc = snprintf(qpd->buf + qpd->pos, space,\r\n"qp sq id %u rq id %u state %u onchip %u "\r\n"ep tid %u state %u %pI4:%u->%pI4:%u\n",\r\nqp->wq.sq.qid, qp->wq.rq.qid, (int)qp->attr.state,\r\nqp->wq.sq.flags & T4_SQ_ONCHIP,\r\nqp->ep->hwtid, (int)qp->ep->com.state,\r\n&qp->ep->com.local_addr.sin_addr.s_addr,\r\nntohs(qp->ep->com.local_addr.sin_port),\r\n&qp->ep->com.remote_addr.sin_addr.s_addr,\r\nntohs(qp->ep->com.remote_addr.sin_port));\r\nelse\r\ncc = snprintf(qpd->buf + qpd->pos, space,\r\n"qp sq id %u rq id %u state %u onchip %u\n",\r\nqp->wq.sq.qid, qp->wq.rq.qid,\r\n(int)qp->attr.state,\r\nqp->wq.sq.flags & T4_SQ_ONCHIP);\r\nif (cc < space)\r\nqpd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int qp_release(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *qpd = file->private_data;\r\nif (!qpd) {\r\nprintk(KERN_INFO "%s null qpd?\n", __func__);\r\nreturn 0;\r\n}\r\nkfree(qpd->buf);\r\nkfree(qpd);\r\nreturn 0;\r\n}\r\nstatic int qp_open(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *qpd;\r\nint ret = 0;\r\nint count = 1;\r\nqpd = kmalloc(sizeof *qpd, GFP_KERNEL);\r\nif (!qpd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nqpd->devp = inode->i_private;\r\nqpd->pos = 0;\r\nspin_lock_irq(&qpd->devp->lock);\r\nidr_for_each(&qpd->devp->qpidr, count_idrs, &count);\r\nspin_unlock_irq(&qpd->devp->lock);\r\nqpd->bufsize = count * 128;\r\nqpd->buf = kmalloc(qpd->bufsize, GFP_KERNEL);\r\nif (!qpd->buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nspin_lock_irq(&qpd->devp->lock);\r\nidr_for_each(&qpd->devp->qpidr, dump_qp, qpd);\r\nspin_unlock_irq(&qpd->devp->lock);\r\nqpd->buf[qpd->pos++] = 0;\r\nfile->private_data = qpd;\r\ngoto out;\r\nerr1:\r\nkfree(qpd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int dump_stag(int id, void *p, void *data)\r\n{\r\nstruct c4iw_debugfs_data *stagd = data;\r\nint space;\r\nint cc;\r\nspace = stagd->bufsize - stagd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\ncc = snprintf(stagd->buf + stagd->pos, space, "0x%x\n", id<<8);\r\nif (cc < space)\r\nstagd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int stag_release(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *stagd = file->private_data;\r\nif (!stagd) {\r\nprintk(KERN_INFO "%s null stagd?\n", __func__);\r\nreturn 0;\r\n}\r\nkfree(stagd->buf);\r\nkfree(stagd);\r\nreturn 0;\r\n}\r\nstatic int stag_open(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *stagd;\r\nint ret = 0;\r\nint count = 1;\r\nstagd = kmalloc(sizeof *stagd, GFP_KERNEL);\r\nif (!stagd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nstagd->devp = inode->i_private;\r\nstagd->pos = 0;\r\nspin_lock_irq(&stagd->devp->lock);\r\nidr_for_each(&stagd->devp->mmidr, count_idrs, &count);\r\nspin_unlock_irq(&stagd->devp->lock);\r\nstagd->bufsize = count * sizeof("0x12345678\n");\r\nstagd->buf = kmalloc(stagd->bufsize, GFP_KERNEL);\r\nif (!stagd->buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nspin_lock_irq(&stagd->devp->lock);\r\nidr_for_each(&stagd->devp->mmidr, dump_stag, stagd);\r\nspin_unlock_irq(&stagd->devp->lock);\r\nstagd->buf[stagd->pos++] = 0;\r\nfile->private_data = stagd;\r\ngoto out;\r\nerr1:\r\nkfree(stagd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int setup_debugfs(struct c4iw_dev *devp)\r\n{\r\nstruct dentry *de;\r\nif (!devp->debugfs_root)\r\nreturn -1;\r\nde = debugfs_create_file("qps", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &qp_debugfs_fops);\r\nif (de && de->d_inode)\r\nde->d_inode->i_size = 4096;\r\nde = debugfs_create_file("stags", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &stag_debugfs_fops);\r\nif (de && de->d_inode)\r\nde->d_inode->i_size = 4096;\r\nreturn 0;\r\n}\r\nvoid c4iw_release_dev_ucontext(struct c4iw_rdev *rdev,\r\nstruct c4iw_dev_ucontext *uctx)\r\n{\r\nstruct list_head *pos, *nxt;\r\nstruct c4iw_qid_list *entry;\r\nmutex_lock(&uctx->lock);\r\nlist_for_each_safe(pos, nxt, &uctx->qpids) {\r\nentry = list_entry(pos, struct c4iw_qid_list, entry);\r\nlist_del_init(&entry->entry);\r\nif (!(entry->qid & rdev->qpmask))\r\nc4iw_put_resource(&rdev->resource.qid_fifo, entry->qid,\r\n&rdev->resource.qid_fifo_lock);\r\nkfree(entry);\r\n}\r\nlist_for_each_safe(pos, nxt, &uctx->qpids) {\r\nentry = list_entry(pos, struct c4iw_qid_list, entry);\r\nlist_del_init(&entry->entry);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&uctx->lock);\r\n}\r\nvoid c4iw_init_dev_ucontext(struct c4iw_rdev *rdev,\r\nstruct c4iw_dev_ucontext *uctx)\r\n{\r\nINIT_LIST_HEAD(&uctx->qpids);\r\nINIT_LIST_HEAD(&uctx->cqids);\r\nmutex_init(&uctx->lock);\r\n}\r\nstatic int c4iw_rdev_open(struct c4iw_rdev *rdev)\r\n{\r\nint err;\r\nc4iw_init_dev_ucontext(rdev, &rdev->uctx);\r\nrdev->qpshift = PAGE_SHIFT - ilog2(rdev->lldi.udb_density);\r\nrdev->qpmask = rdev->lldi.udb_density - 1;\r\nrdev->cqshift = PAGE_SHIFT - ilog2(rdev->lldi.ucq_density);\r\nrdev->cqmask = rdev->lldi.ucq_density - 1;\r\nPDBG("%s dev %s stag start 0x%0x size 0x%0x num stags %d "\r\n"pbl start 0x%0x size 0x%0x rq start 0x%0x size 0x%0x "\r\n"qp qid start %u size %u cq qid start %u size %u\n",\r\n__func__, pci_name(rdev->lldi.pdev), rdev->lldi.vr->stag.start,\r\nrdev->lldi.vr->stag.size, c4iw_num_stags(rdev),\r\nrdev->lldi.vr->pbl.start,\r\nrdev->lldi.vr->pbl.size, rdev->lldi.vr->rq.start,\r\nrdev->lldi.vr->rq.size,\r\nrdev->lldi.vr->qp.start,\r\nrdev->lldi.vr->qp.size,\r\nrdev->lldi.vr->cq.start,\r\nrdev->lldi.vr->cq.size);\r\nPDBG("udb len 0x%x udb base %p db_reg %p gts_reg %p qpshift %lu "\r\n"qpmask 0x%x cqshift %lu cqmask 0x%x\n",\r\n(unsigned)pci_resource_len(rdev->lldi.pdev, 2),\r\n(void *)pci_resource_start(rdev->lldi.pdev, 2),\r\nrdev->lldi.db_reg,\r\nrdev->lldi.gts_reg,\r\nrdev->qpshift, rdev->qpmask,\r\nrdev->cqshift, rdev->cqmask);\r\nif (c4iw_num_stags(rdev) == 0) {\r\nerr = -EINVAL;\r\ngoto err1;\r\n}\r\nerr = c4iw_init_resource(rdev, c4iw_num_stags(rdev), T4_MAX_NUM_PD);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing resources\n", err);\r\ngoto err1;\r\n}\r\nerr = c4iw_pblpool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing pbl pool\n", err);\r\ngoto err2;\r\n}\r\nerr = c4iw_rqtpool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing rqt pool\n", err);\r\ngoto err3;\r\n}\r\nerr = c4iw_ocqp_pool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing ocqp pool\n", err);\r\ngoto err4;\r\n}\r\nreturn 0;\r\nerr4:\r\nc4iw_rqtpool_destroy(rdev);\r\nerr3:\r\nc4iw_pblpool_destroy(rdev);\r\nerr2:\r\nc4iw_destroy_resource(&rdev->resource);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void c4iw_rdev_close(struct c4iw_rdev *rdev)\r\n{\r\nc4iw_pblpool_destroy(rdev);\r\nc4iw_rqtpool_destroy(rdev);\r\nc4iw_destroy_resource(&rdev->resource);\r\n}\r\nstatic void c4iw_remove(struct uld_ctx *ctx)\r\n{\r\nPDBG("%s c4iw_dev %p\n", __func__, ctx->dev);\r\nc4iw_unregister_device(ctx->dev);\r\nc4iw_rdev_close(&ctx->dev->rdev);\r\nidr_destroy(&ctx->dev->cqidr);\r\nidr_destroy(&ctx->dev->qpidr);\r\nidr_destroy(&ctx->dev->mmidr);\r\niounmap(ctx->dev->rdev.oc_mw_kva);\r\nib_dealloc_device(&ctx->dev->ibdev);\r\nctx->dev = NULL;\r\n}\r\nstatic struct c4iw_dev *c4iw_alloc(const struct cxgb4_lld_info *infop)\r\n{\r\nstruct c4iw_dev *devp;\r\nint ret;\r\ndevp = (struct c4iw_dev *)ib_alloc_device(sizeof(*devp));\r\nif (!devp) {\r\nprintk(KERN_ERR MOD "Cannot allocate ib device\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndevp->rdev.lldi = *infop;\r\ndevp->rdev.oc_mw_pa = pci_resource_start(devp->rdev.lldi.pdev, 2) +\r\n(pci_resource_len(devp->rdev.lldi.pdev, 2) -\r\nroundup_pow_of_two(devp->rdev.lldi.vr->ocq.size));\r\ndevp->rdev.oc_mw_kva = ioremap_wc(devp->rdev.oc_mw_pa,\r\ndevp->rdev.lldi.vr->ocq.size);\r\nPDBG(KERN_INFO MOD "ocq memory: "\r\n"hw_start 0x%x size %u mw_pa 0x%lx mw_kva %p\n",\r\ndevp->rdev.lldi.vr->ocq.start, devp->rdev.lldi.vr->ocq.size,\r\ndevp->rdev.oc_mw_pa, devp->rdev.oc_mw_kva);\r\nret = c4iw_rdev_open(&devp->rdev);\r\nif (ret) {\r\nmutex_unlock(&dev_mutex);\r\nprintk(KERN_ERR MOD "Unable to open CXIO rdev err %d\n", ret);\r\nib_dealloc_device(&devp->ibdev);\r\nreturn ERR_PTR(ret);\r\n}\r\nidr_init(&devp->cqidr);\r\nidr_init(&devp->qpidr);\r\nidr_init(&devp->mmidr);\r\nspin_lock_init(&devp->lock);\r\nif (c4iw_debugfs_root) {\r\ndevp->debugfs_root = debugfs_create_dir(\r\npci_name(devp->rdev.lldi.pdev),\r\nc4iw_debugfs_root);\r\nsetup_debugfs(devp);\r\n}\r\nreturn devp;\r\n}\r\nstatic void *c4iw_uld_add(const struct cxgb4_lld_info *infop)\r\n{\r\nstruct uld_ctx *ctx;\r\nstatic int vers_printed;\r\nint i;\r\nif (!vers_printed++)\r\nprintk(KERN_INFO MOD "Chelsio T4 RDMA Driver - version %s\n",\r\nDRV_VERSION);\r\nctx = kzalloc(sizeof *ctx, GFP_KERNEL);\r\nif (!ctx) {\r\nctx = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nctx->lldi = *infop;\r\nPDBG("%s found device %s nchan %u nrxq %u ntxq %u nports %u\n",\r\n__func__, pci_name(ctx->lldi.pdev),\r\nctx->lldi.nchan, ctx->lldi.nrxq,\r\nctx->lldi.ntxq, ctx->lldi.nports);\r\nmutex_lock(&dev_mutex);\r\nlist_add_tail(&ctx->entry, &uld_ctx_list);\r\nmutex_unlock(&dev_mutex);\r\nfor (i = 0; i < ctx->lldi.nrxq; i++)\r\nPDBG("rxqid[%u] %u\n", i, ctx->lldi.rxq_ids[i]);\r\nout:\r\nreturn ctx;\r\n}\r\nstatic int c4iw_uld_rx_handler(void *handle, const __be64 *rsp,\r\nconst struct pkt_gl *gl)\r\n{\r\nstruct uld_ctx *ctx = handle;\r\nstruct c4iw_dev *dev = ctx->dev;\r\nstruct sk_buff *skb;\r\nconst struct cpl_act_establish *rpl;\r\nunsigned int opcode;\r\nif (gl == NULL) {\r\nunsigned int len = 64 - sizeof(struct rsp_ctrl) - 8;\r\nskb = alloc_skb(256, GFP_ATOMIC);\r\nif (!skb)\r\ngoto nomem;\r\n__skb_put(skb, len);\r\nskb_copy_to_linear_data(skb, &rsp[1], len);\r\n} else if (gl == CXGB4_MSG_AN) {\r\nconst struct rsp_ctrl *rc = (void *)rsp;\r\nu32 qid = be32_to_cpu(rc->pldbuflen_qid);\r\nc4iw_ev_handler(dev, qid);\r\nreturn 0;\r\n} else {\r\nskb = cxgb4_pktgl_to_skb(gl, 128, 128);\r\nif (unlikely(!skb))\r\ngoto nomem;\r\n}\r\nrpl = cplhdr(skb);\r\nopcode = rpl->ot.opcode;\r\nif (c4iw_handlers[opcode])\r\nc4iw_handlers[opcode](dev, skb);\r\nelse\r\nprintk(KERN_INFO "%s no handler opcode 0x%x...\n", __func__,\r\nopcode);\r\nreturn 0;\r\nnomem:\r\nreturn -1;\r\n}\r\nstatic int c4iw_uld_state_change(void *handle, enum cxgb4_state new_state)\r\n{\r\nstruct uld_ctx *ctx = handle;\r\nPDBG("%s new_state %u\n", __func__, new_state);\r\nswitch (new_state) {\r\ncase CXGB4_STATE_UP:\r\nprintk(KERN_INFO MOD "%s: Up\n", pci_name(ctx->lldi.pdev));\r\nif (!ctx->dev) {\r\nint ret = 0;\r\nctx->dev = c4iw_alloc(&ctx->lldi);\r\nif (!IS_ERR(ctx->dev))\r\nret = c4iw_register_device(ctx->dev);\r\nif (IS_ERR(ctx->dev) || ret)\r\nprintk(KERN_ERR MOD\r\n"%s: RDMA registration failed: %d\n",\r\npci_name(ctx->lldi.pdev), ret);\r\n}\r\nbreak;\r\ncase CXGB4_STATE_DOWN:\r\nprintk(KERN_INFO MOD "%s: Down\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nbreak;\r\ncase CXGB4_STATE_START_RECOVERY:\r\nprintk(KERN_INFO MOD "%s: Fatal Error\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev) {\r\nstruct ib_event event;\r\nctx->dev->rdev.flags |= T4_FATAL_ERROR;\r\nmemset(&event, 0, sizeof event);\r\nevent.event = IB_EVENT_DEVICE_FATAL;\r\nevent.device = &ctx->dev->ibdev;\r\nib_dispatch_event(&event);\r\nc4iw_remove(ctx);\r\n}\r\nbreak;\r\ncase CXGB4_STATE_DETACH:\r\nprintk(KERN_INFO MOD "%s: Detach\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init c4iw_init_module(void)\r\n{\r\nint err;\r\nerr = c4iw_cm_init();\r\nif (err)\r\nreturn err;\r\nc4iw_debugfs_root = debugfs_create_dir(DRV_NAME, NULL);\r\nif (!c4iw_debugfs_root)\r\nprintk(KERN_WARNING MOD\r\n"could not create debugfs entry, continuing\n");\r\ncxgb4_register_uld(CXGB4_ULD_RDMA, &c4iw_uld_info);\r\nreturn 0;\r\n}\r\nstatic void __exit c4iw_exit_module(void)\r\n{\r\nstruct uld_ctx *ctx, *tmp;\r\nmutex_lock(&dev_mutex);\r\nlist_for_each_entry_safe(ctx, tmp, &uld_ctx_list, entry) {\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nkfree(ctx);\r\n}\r\nmutex_unlock(&dev_mutex);\r\ncxgb4_unregister_uld(CXGB4_ULD_RDMA);\r\nc4iw_cm_term();\r\ndebugfs_remove_recursive(c4iw_debugfs_root);\r\n}
