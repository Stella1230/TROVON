int nand_bch_calculate_ecc(struct mtd_info *mtd, const unsigned char *buf,\r\nunsigned char *code)\r\n{\r\nconst struct nand_chip *chip = mtd->priv;\r\nstruct nand_bch_control *nbc = chip->ecc.priv;\r\nunsigned int i;\r\nmemset(code, 0, chip->ecc.bytes);\r\nencode_bch(nbc->bch, buf, chip->ecc.size, code);\r\nfor (i = 0; i < chip->ecc.bytes; i++)\r\ncode[i] ^= nbc->eccmask[i];\r\nreturn 0;\r\n}\r\nint nand_bch_correct_data(struct mtd_info *mtd, unsigned char *buf,\r\nunsigned char *read_ecc, unsigned char *calc_ecc)\r\n{\r\nconst struct nand_chip *chip = mtd->priv;\r\nstruct nand_bch_control *nbc = chip->ecc.priv;\r\nunsigned int *errloc = nbc->errloc;\r\nint i, count;\r\ncount = decode_bch(nbc->bch, NULL, chip->ecc.size, read_ecc, calc_ecc,\r\nNULL, errloc);\r\nif (count > 0) {\r\nfor (i = 0; i < count; i++) {\r\nif (errloc[i] < (chip->ecc.size*8))\r\nbuf[errloc[i] >> 3] ^= (1 << (errloc[i] & 7));\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: corrected bitflip %u\n",\r\n__func__, errloc[i]);\r\n}\r\n} else if (count < 0) {\r\nprintk(KERN_ERR "ecc unrecoverable error\n");\r\ncount = -1;\r\n}\r\nreturn count;\r\n}\r\nstruct nand_bch_control *\r\nnand_bch_init(struct mtd_info *mtd, unsigned int eccsize, unsigned int eccbytes,\r\nstruct nand_ecclayout **ecclayout)\r\n{\r\nunsigned int m, t, eccsteps, i;\r\nstruct nand_ecclayout *layout;\r\nstruct nand_bch_control *nbc = NULL;\r\nunsigned char *erased_page;\r\nif (!eccsize || !eccbytes) {\r\nprintk(KERN_WARNING "ecc parameters not supplied\n");\r\ngoto fail;\r\n}\r\nm = fls(1+8*eccsize);\r\nt = (eccbytes*8)/m;\r\nnbc = kzalloc(sizeof(*nbc), GFP_KERNEL);\r\nif (!nbc)\r\ngoto fail;\r\nnbc->bch = init_bch(m, t, 0);\r\nif (!nbc->bch)\r\ngoto fail;\r\nif (nbc->bch->ecc_bytes != eccbytes) {\r\nprintk(KERN_WARNING "invalid eccbytes %u, should be %u\n",\r\neccbytes, nbc->bch->ecc_bytes);\r\ngoto fail;\r\n}\r\neccsteps = mtd->writesize/eccsize;\r\nif (!*ecclayout) {\r\nif (mtd->oobsize < 64) {\r\nprintk(KERN_WARNING "must provide an oob scheme for "\r\n"oobsize %d\n", mtd->oobsize);\r\ngoto fail;\r\n}\r\nlayout = &nbc->ecclayout;\r\nlayout->eccbytes = eccsteps*eccbytes;\r\nif (layout->eccbytes+2 > mtd->oobsize) {\r\nprintk(KERN_WARNING "no suitable oob scheme available "\r\n"for oobsize %d eccbytes %u\n", mtd->oobsize,\r\neccbytes);\r\ngoto fail;\r\n}\r\nfor (i = 0; i < layout->eccbytes; i++)\r\nlayout->eccpos[i] = mtd->oobsize-layout->eccbytes+i;\r\nlayout->oobfree[0].offset = 2;\r\nlayout->oobfree[0].length = mtd->oobsize-2-layout->eccbytes;\r\n*ecclayout = layout;\r\n}\r\nif (8*(eccsize+eccbytes) >= (1 << m)) {\r\nprintk(KERN_WARNING "eccsize %u is too large\n", eccsize);\r\ngoto fail;\r\n}\r\nif ((*ecclayout)->eccbytes != (eccsteps*eccbytes)) {\r\nprintk(KERN_WARNING "invalid ecc layout\n");\r\ngoto fail;\r\n}\r\nnbc->eccmask = kmalloc(eccbytes, GFP_KERNEL);\r\nnbc->errloc = kmalloc(t*sizeof(*nbc->errloc), GFP_KERNEL);\r\nif (!nbc->eccmask || !nbc->errloc)\r\ngoto fail;\r\nerased_page = kmalloc(eccsize, GFP_KERNEL);\r\nif (!erased_page)\r\ngoto fail;\r\nmemset(erased_page, 0xff, eccsize);\r\nmemset(nbc->eccmask, 0, eccbytes);\r\nencode_bch(nbc->bch, erased_page, eccsize, nbc->eccmask);\r\nkfree(erased_page);\r\nfor (i = 0; i < eccbytes; i++)\r\nnbc->eccmask[i] ^= 0xff;\r\nreturn nbc;\r\nfail:\r\nnand_bch_free(nbc);\r\nreturn NULL;\r\n}\r\nvoid nand_bch_free(struct nand_bch_control *nbc)\r\n{\r\nif (nbc) {\r\nfree_bch(nbc->bch);\r\nkfree(nbc->errloc);\r\nkfree(nbc->eccmask);\r\nkfree(nbc);\r\n}\r\n}
