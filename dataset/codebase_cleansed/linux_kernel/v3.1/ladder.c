static inline void ladder_do_selection(struct ladder_device *ldev,\r\nint old_idx, int new_idx)\r\n{\r\nldev->states[old_idx].stats.promotion_count = 0;\r\nldev->states[old_idx].stats.demotion_count = 0;\r\nldev->last_state_idx = new_idx;\r\n}\r\nstatic int ladder_select_state(struct cpuidle_device *dev)\r\n{\r\nstruct ladder_device *ldev = &__get_cpu_var(ladder_devices);\r\nstruct ladder_device_state *last_state;\r\nint last_residency, last_idx = ldev->last_state_idx;\r\nint latency_req = pm_qos_request(PM_QOS_CPU_DMA_LATENCY);\r\nif (unlikely(latency_req == 0)) {\r\nladder_do_selection(ldev, last_idx, 0);\r\nreturn 0;\r\n}\r\nlast_state = &ldev->states[last_idx];\r\nif (dev->states[last_idx].flags & CPUIDLE_FLAG_TIME_VALID)\r\nlast_residency = cpuidle_get_last_residency(dev) - dev->states[last_idx].exit_latency;\r\nelse\r\nlast_residency = last_state->threshold.promotion_time + 1;\r\nif (last_idx < dev->state_count - 1 &&\r\nlast_residency > last_state->threshold.promotion_time &&\r\ndev->states[last_idx + 1].exit_latency <= latency_req) {\r\nlast_state->stats.promotion_count++;\r\nlast_state->stats.demotion_count = 0;\r\nif (last_state->stats.promotion_count >= last_state->threshold.promotion_count) {\r\nladder_do_selection(ldev, last_idx, last_idx + 1);\r\nreturn last_idx + 1;\r\n}\r\n}\r\nif (last_idx > CPUIDLE_DRIVER_STATE_START &&\r\ndev->states[last_idx].exit_latency > latency_req) {\r\nint i;\r\nfor (i = last_idx - 1; i > CPUIDLE_DRIVER_STATE_START; i--) {\r\nif (dev->states[i].exit_latency <= latency_req)\r\nbreak;\r\n}\r\nladder_do_selection(ldev, last_idx, i);\r\nreturn i;\r\n}\r\nif (last_idx > CPUIDLE_DRIVER_STATE_START &&\r\nlast_residency < last_state->threshold.demotion_time) {\r\nlast_state->stats.demotion_count++;\r\nlast_state->stats.promotion_count = 0;\r\nif (last_state->stats.demotion_count >= last_state->threshold.demotion_count) {\r\nladder_do_selection(ldev, last_idx, last_idx - 1);\r\nreturn last_idx - 1;\r\n}\r\n}\r\nreturn last_idx;\r\n}\r\nstatic int ladder_enable_device(struct cpuidle_device *dev)\r\n{\r\nint i;\r\nstruct ladder_device *ldev = &per_cpu(ladder_devices, dev->cpu);\r\nstruct ladder_device_state *lstate;\r\nstruct cpuidle_state *state;\r\nldev->last_state_idx = CPUIDLE_DRIVER_STATE_START;\r\nfor (i = 0; i < dev->state_count; i++) {\r\nstate = &dev->states[i];\r\nlstate = &ldev->states[i];\r\nlstate->stats.promotion_count = 0;\r\nlstate->stats.demotion_count = 0;\r\nlstate->threshold.promotion_count = PROMOTION_COUNT;\r\nlstate->threshold.demotion_count = DEMOTION_COUNT;\r\nif (i < dev->state_count - 1)\r\nlstate->threshold.promotion_time = state->exit_latency;\r\nif (i > 0)\r\nlstate->threshold.demotion_time = state->exit_latency;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init init_ladder(void)\r\n{\r\nreturn cpuidle_register_governor(&ladder_governor);\r\n}\r\nstatic void __exit exit_ladder(void)\r\n{\r\ncpuidle_unregister_governor(&ladder_governor);\r\n}
