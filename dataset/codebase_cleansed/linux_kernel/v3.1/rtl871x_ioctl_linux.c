static int hwaddr_aton_i(const char *txt, u8 *addr)\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++) {\r\nint a, b;\r\na = hex_to_bin(*txt++);\r\nif (a < 0)\r\nreturn -1;\r\nb = hex_to_bin(*txt++);\r\nif (b < 0)\r\nreturn -1;\r\n*addr++ = (a << 4) | b;\r\nif (i < 5 && *txt++ != ':')\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid r8712_indicate_wx_assoc_event(struct _adapter *padapter)\r\n{\r\nunion iwreq_data wrqu;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress,\r\nETH_ALEN);\r\nwireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\nvoid r8712_indicate_wx_disassoc_event(struct _adapter *padapter)\r\n{\r\nunion iwreq_data wrqu;\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\r\nwireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\nstatic inline void handle_pairwise_key(struct sta_info *psta,\r\nstruct ieee_param *param,\r\nstruct _adapter *padapter)\r\n{\r\nmemcpy(psta->x_UncstKey.skey, param->u.crypt.key,\r\n(param->u.crypt. key_len > 16 ? 16 : param->u.crypt.key_len));\r\nif (strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\nmemcpy(psta->tkiptxmickey. skey, &(param->u.crypt.\r\nkey[16]), 8);\r\nmemcpy(psta->tkiprxmickey. skey, &(param->u.crypt.\r\nkey[24]), 8);\r\npadapter->securitypriv. busetkipkey = false;\r\n_set_timer(&padapter->securitypriv.tkip_timer, 50);\r\n}\r\nr8712_setstakey_cmd(padapter, (unsigned char *)psta, true);\r\n}\r\nstatic inline void handle_group_key(struct ieee_param *param,\r\nstruct _adapter *padapter)\r\n{\r\nif (0 < param->u.crypt.idx &&\r\nparam->u.crypt.idx < 3) {\r\nmemcpy(padapter->securitypriv.XGrpKey[param->u.crypt.\r\nidx-1].skey, param->u.crypt.key, (param->u.crypt.key_len\r\n> 16 ? 16 : param->u.crypt.key_len));\r\nmemcpy(padapter->securitypriv.XGrptxmickey[param->\r\nu.crypt.idx-1].skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(padapter->securitypriv. XGrprxmickey[param->\r\nu.crypt.idx-1].skey, &(param->u.crypt.key[24]), 8);\r\npadapter->securitypriv.binstallGrpkey = true;\r\nr8712_set_key(padapter, &padapter->securitypriv,\r\nparam->u.crypt.idx);\r\nif (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE) {\r\nif (padapter->registrypriv.power_mgnt != padapter->\r\npwrctrlpriv.pwr_mode)\r\n_set_timer(&(padapter->mlmepriv.dhcp_timer),\r\n60000);\r\n}\r\n}\r\n}\r\nstatic inline char *translate_scan(struct _adapter *padapter,\r\nstruct iw_request_info *info,\r\nstruct wlan_network *pnetwork,\r\nchar *start, char *stop)\r\n{\r\nstruct iw_event iwe;\r\nstruct ieee80211_ht_cap *pht_capie;\r\nchar *current_val;\r\nu8 *buf = (u8 *)_malloc(pnetwork->network.IELength * 2);\r\nu8 *wpa_ie = (u8 *)_malloc(255);\r\nu8 *rsn_ie = (u8 *)_malloc(255);\r\nu8 *wps_ie = (u8 *)_malloc(MAX_WPS_IE_LEN);\r\ns8 *p;\r\nu32 i = 0, ht_ielen = 0;\r\nu16 cap, ht_cap = false, mcs_rate;\r\nu8 rssi, bw_40MHz = 0, short_GI = 0;\r\nif ((pnetwork->network.Configuration.DSConfig < 1) ||\r\n(pnetwork->network.Configuration.DSConfig > 14)) {\r\nif (pnetwork->network.Configuration.DSConfig < 1)\r\npnetwork->network.Configuration.DSConfig = 1;\r\nelse\r\npnetwork->network.Configuration.DSConfig = 14;\r\n}\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\niwe.u.data.length = (u16)min((u16)pnetwork->network.Ssid.SsidLength,\r\n(u16)32);\r\nstart = iwe_stream_add_point(info, start, stop, &iwe,\r\npnetwork->network.Ssid.Ssid);\r\np = r8712_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_,\r\n&ht_ielen, pnetwork->network.IELength - 12);\r\nif (p && ht_ielen > 0) {\r\nht_cap = true;\r\npht_capie = (struct ieee80211_ht_cap *)(p + 2);\r\nmemcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);\r\nbw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH)\r\n? 1 : 0;\r\nshort_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20 |\r\nIEEE80211_HT_CAP_SGI_40)) ? 1 : 0;\r\n}\r\niwe.cmd = SIOCGIWNAME;\r\nif ((r8712_is_cckratesonly_included((u8 *)&pnetwork->network.\r\nSupportedRates)) == true) {\r\nif (ht_cap == true)\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");\r\nelse\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");\r\n} else if ((r8712_is_cckrates_included((u8 *)&pnetwork->network.\r\nSupportedRates)) == true) {\r\nif (ht_cap == true)\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");\r\nelse\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");\r\n} else {\r\nif (ht_cap == true)\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");\r\nelse\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");\r\n}\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);\r\niwe.cmd = SIOCGIWMODE;\r\nmemcpy((u8 *)&cap, r8712_get_capability_from_ie(pnetwork->network.IEs),\r\n2);\r\ncap = le16_to_cpu(cap);\r\nif (cap & (WLAN_CAPABILITY_IBSS|WLAN_CAPABILITY_BSS)) {\r\nif (cap & WLAN_CAPABILITY_BSS)\r\niwe.u.mode = (u32)IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = (u32)IW_MODE_ADHOC;\r\nstart = iwe_stream_add_event(info, start, stop, &iwe,\r\nIW_EV_UINT_LEN);\r\n}\r\niwe.cmd = SIOCGIWFREQ;\r\n{\r\nu8 dsconfig = pnetwork->network.Configuration.DSConfig;\r\nif (dsconfig >= 1 && dsconfig <= sizeof(\r\nieee80211_wlan_frequencies) / sizeof(long))\r\niwe.u.freq.m = (s32)(ieee80211_wlan_frequencies[\r\npnetwork->network.Configuration.\r\nDSConfig - 1] * 100000);\r\nelse\r\niwe.u.freq.m = 0;\r\n}\r\niwe.u.freq.e = (s16)1;\r\niwe.u.freq.i = (u8)pnetwork->network.Configuration.DSConfig;\r\nstart = iwe_stream_add_event(info, start, stop, &iwe,\r\nIW_EV_FREQ_LEN);\r\niwe.cmd = SIOCGIWENCODE;\r\nif (cap & WLAN_CAPABILITY_PRIVACY)\r\niwe.u.data.flags = (u16)(IW_ENCODE_ENABLED |\r\nIW_ENCODE_NOKEY);\r\nelse\r\niwe.u.data.flags = (u16)(IW_ENCODE_DISABLED);\r\niwe.u.data.length = (u16)0;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe,\r\npnetwork->network.Ssid.Ssid);\r\ncurrent_val = start + iwe_stream_lcp_len(info);\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = 0;\r\niwe.u.bitrate.disabled = 0;\r\niwe.u.bitrate.value = 0;\r\ni = 0;\r\nwhile (pnetwork->network.SupportedRates[i] != 0) {\r\niwe.u.bitrate.value = (pnetwork->network.SupportedRates[i++] &\r\n0x7F) * 500000;\r\ncurrent_val = iwe_stream_add_value(info, start, current_val,\r\nstop, &iwe, IW_EV_PARAM_LEN);\r\n}\r\nif ((current_val - start) > iwe_stream_lcp_len(info))\r\nstart = current_val;\r\n{\r\nu16 wpa_len = 0, rsn_len = 0;\r\nint n;\r\nsint out_len = 0;\r\nout_len = r8712_get_sec_ie(pnetwork->network.IEs,\r\npnetwork->network.\r\nIELength, rsn_ie, &rsn_len,\r\nwpa_ie, &wpa_len);\r\nif (wpa_len > 0) {\r\nmemset(buf, 0, MAX_WPA_IE_LEN);\r\nn = sprintf(buf, "wpa_ie=");\r\nfor (i = 0; i < wpa_len; i++) {\r\nn += snprintf(buf + n, MAX_WPA_IE_LEN - n,\r\n"%02x", wpa_ie[i]);\r\nif (n >= MAX_WPA_IE_LEN)\r\nbreak;\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\niwe.u.data.length = (u16)strlen(buf);\r\nstart = iwe_stream_add_point(info, start, stop,\r\n&iwe, buf);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = (u16)wpa_len;\r\nstart = iwe_stream_add_point(info, start, stop,\r\n&iwe, wpa_ie);\r\n}\r\nif (rsn_len > 0) {\r\nmemset(buf, 0, MAX_WPA_IE_LEN);\r\nn = sprintf(buf, "rsn_ie=");\r\nfor (i = 0; i < rsn_len; i++) {\r\nn += snprintf(buf + n, MAX_WPA_IE_LEN - n,\r\n"%02x", rsn_ie[i]);\r\nif (n >= MAX_WPA_IE_LEN)\r\nbreak;\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\niwe.u.data.length = strlen(buf);\r\nstart = iwe_stream_add_point(info, start, stop,\r\n&iwe, buf);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = rsn_len;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe,\r\nrsn_ie);\r\n}\r\n}\r\n{\r\nuint wps_ielen;\r\nif (r8712_get_wps_ie(pnetwork->network.IEs,\r\npnetwork->network.IELength,\r\nwps_ie, &wps_ielen) == true) {\r\nif (wps_ielen > 2) {\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = (u16)wps_ielen;\r\nstart = iwe_stream_add_point(info, start, stop,\r\n&iwe, wps_ie);\r\n}\r\n}\r\n}\r\niwe.cmd = IWEVQUAL;\r\nrssi = r8712_signal_scale_mapping(pnetwork->network.Rssi);\r\niwe.u.qual.updated = (u8)(IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_UPDATED |\r\nIW_QUAL_NOISE_INVALID);\r\niwe.u.qual.level = rssi;\r\niwe.u.qual.qual = 0;\r\niwe.u.qual.noise = 0;\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);\r\nkfree(buf);\r\nkfree(wpa_ie);\r\nkfree(rsn_ie);\r\nkfree(wps_ie);\r\nreturn start;\r\n}\r\nstatic int wpa_set_auth_algs(struct net_device *dev, u32 value)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nint ret = 0;\r\nif ((value & AUTH_ALG_SHARED_KEY) && (value & AUTH_ALG_OPEN_SYSTEM)) {\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeAutoSwitch;\r\npadapter->securitypriv.AuthAlgrthm = 3;\r\n} else if (value & AUTH_ALG_SHARED_KEY) {\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;\r\npadapter->securitypriv.AuthAlgrthm = 1;\r\n} else if (value & AUTH_ALG_OPEN_SYSTEM) {\r\nif (padapter->securitypriv.ndisauthtype <\r\nNdis802_11AuthModeWPAPSK) {\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeOpen;\r\npadapter->securitypriv.AuthAlgrthm = 0;\r\n}\r\n} else\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,\r\nu32 param_len)\r\n{\r\nint ret = 0;\r\nu32 wep_key_idx, wep_key_len = 0;\r\nstruct NDIS_802_11_WEP *pwep = NULL;\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len != (u32)((u8 *) param->u.crypt.key - (u8 *)param) +\r\nparam->u.crypt.key_len)\r\nreturn -EINVAL;\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\r\nif (param->u.crypt.idx >= WEP_KEYS) {\r\nparam->u.crypt.idx = 0;\r\n}\r\n} else\r\nreturn -EINVAL;\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nprintk(KERN_INFO "r8712u: wpa_set_encryption, crypt.alg ="\r\n" WEP\n");\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\npadapter->securitypriv.PrivacyAlgrthm = _WEP40_;\r\npadapter->securitypriv.XGrpPrivacy = _WEP40_;\r\nwep_key_idx = param->u.crypt.idx;\r\nwep_key_len = param->u.crypt.key_len;\r\nif (wep_key_idx >= WEP_KEYS)\r\nwep_key_idx = 0;\r\nif (wep_key_len > 0) {\r\nwep_key_len = wep_key_len <= 5 ? 5 : 13;\r\npwep = (struct NDIS_802_11_WEP *)_malloc((u32)\r\n(wep_key_len +\r\nFIELD_OFFSET(struct NDIS_802_11_WEP,\r\nKeyMaterial)));\r\nif (pwep == NULL)\r\nreturn -ENOMEM;\r\nmemset(pwep, 0, sizeof(struct NDIS_802_11_WEP));\r\npwep->KeyLength = wep_key_len;\r\npwep->Length = wep_key_len +\r\nFIELD_OFFSET(struct NDIS_802_11_WEP,\r\nKeyMaterial);\r\nif (wep_key_len == 13) {\r\npadapter->securitypriv.PrivacyAlgrthm =\r\n_WEP104_;\r\npadapter->securitypriv.XGrpPrivacy =\r\n_WEP104_;\r\n}\r\n} else\r\nreturn -EINVAL;\r\npwep->KeyIndex = wep_key_idx;\r\npwep->KeyIndex |= 0x80000000;\r\nmemcpy(pwep->KeyMaterial, param->u.crypt.key, pwep->KeyLength);\r\nif (param->u.crypt.set_tx) {\r\nif (r8712_set_802_11_add_wep(padapter, pwep) ==\r\n(u8)_FAIL)\r\nret = -EOPNOTSUPP;\r\n} else {\r\nif (wep_key_idx >= WEP_KEYS) {\r\nret = -EOPNOTSUPP;\r\ngoto exit;\r\n}\r\nmemcpy(&(psecuritypriv->DefKey[wep_key_idx].\r\nskey[0]), pwep->KeyMaterial,\r\npwep->KeyLength);\r\npsecuritypriv->DefKeylen[wep_key_idx] =\r\npwep->KeyLength;\r\nr8712_set_key(padapter, psecuritypriv, wep_key_idx);\r\n}\r\ngoto exit;\r\n}\r\nif (padapter->securitypriv.AuthAlgrthm == 2) {\r\nstruct sta_info *psta, *pbcmc_sta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE |\r\nWIFI_MP_STATE) == true) {\r\npsta = r8712_get_stainfo(pstapriv,\r\nget_bssid(pmlmepriv));\r\nif (psta) {\r\npsta->ieee8021x_blocked = false;\r\nif ((padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption2Enabled) ||\r\n(padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption3Enabled))\r\npsta->XPrivacy = padapter->\r\nsecuritypriv.PrivacyAlgrthm;\r\nif (param->u.crypt.set_tx == 1)\r\nhandle_pairwise_key(psta, param,\r\npadapter);\r\nelse\r\nhandle_group_key(param, padapter);\r\n}\r\npbcmc_sta = r8712_get_bcmc_stainfo(padapter);\r\nif (pbcmc_sta) {\r\npbcmc_sta->ieee8021x_blocked = false;\r\nif ((padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption2Enabled) ||\r\n(padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption3Enabled))\r\npbcmc_sta->XPrivacy =\r\npadapter->securitypriv.\r\nPrivacyAlgrthm;\r\n}\r\n}\r\n}\r\nexit:\r\nkfree((u8 *)pwep);\r\nreturn ret;\r\n}\r\nstatic int r871x_set_wpa_ie(struct _adapter *padapter, char *pie,\r\nunsigned short ielen)\r\n{\r\nu8 *buf = NULL, *pos = NULL;\r\nint group_cipher = 0, pairwise_cipher = 0;\r\nint ret = 0;\r\nif ((ielen > MAX_WPA_IE_LEN) || (pie == NULL))\r\nreturn -EINVAL;\r\nif (ielen) {\r\nbuf = _malloc(ielen);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(buf, pie , ielen);\r\npos = buf;\r\nif (ielen < RSN_HEADER_LEN) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (r8712_parse_wpa_ie(buf, ielen, &group_cipher,\r\n&pairwise_cipher) == _SUCCESS) {\r\npadapter->securitypriv.AuthAlgrthm = 2;\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeWPAPSK;\r\n}\r\nif (r8712_parse_wpa2_ie(buf, ielen, &group_cipher,\r\n&pairwise_cipher) == _SUCCESS) {\r\npadapter->securitypriv.AuthAlgrthm = 2;\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeWPA2PSK;\r\n}\r\nswitch (group_cipher) {\r\ncase WPA_CIPHER_NONE:\r\npadapter->securitypriv.XGrpPrivacy =\r\n_NO_PRIVACY_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11EncryptionDisabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP40:\r\npadapter->securitypriv.XGrpPrivacy = _WEP40_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npadapter->securitypriv.XGrpPrivacy = _TKIP_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption2Enabled;\r\nbreak;\r\ncase WPA_CIPHER_CCMP:\r\npadapter->securitypriv.XGrpPrivacy = _AES_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption3Enabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP104:\r\npadapter->securitypriv.XGrpPrivacy = _WEP104_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\nbreak;\r\n}\r\nswitch (pairwise_cipher) {\r\ncase WPA_CIPHER_NONE:\r\npadapter->securitypriv.PrivacyAlgrthm =\r\n_NO_PRIVACY_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11EncryptionDisabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP40:\r\npadapter->securitypriv.PrivacyAlgrthm = _WEP40_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npadapter->securitypriv.PrivacyAlgrthm = _TKIP_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption2Enabled;\r\nbreak;\r\ncase WPA_CIPHER_CCMP:\r\npadapter->securitypriv.PrivacyAlgrthm = _AES_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption3Enabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP104:\r\npadapter->securitypriv.PrivacyAlgrthm = _WEP104_;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\nbreak;\r\n}\r\npadapter->securitypriv.wps_phase = false;\r\n{\r\nu16 cnt = 0;\r\nu8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\r\nwhile (cnt < ielen) {\r\neid = buf[cnt];\r\nif ((eid == _VENDOR_SPECIFIC_IE_) &&\r\n(!memcmp(&buf[cnt+2], wps_oui, 4))) {\r\nprintk(KERN_INFO "r8712u: "\r\n"SET WPS_IE\n");\r\npadapter->securitypriv.wps_ie_len =\r\n((buf[cnt+1] + 2) <\r\n(MAX_WPA_IE_LEN << 2)) ?\r\n(buf[cnt + 1] + 2) :\r\n(MAX_WPA_IE_LEN << 2);\r\nmemcpy(padapter->securitypriv.wps_ie,\r\n&buf[cnt],\r\npadapter->securitypriv.wps_ie_len);\r\npadapter->securitypriv.wps_phase =\r\ntrue;\r\nprintk(KERN_INFO "r8712u: SET WPS_IE,"\r\n" wps_phase==true\n");\r\ncnt += buf[cnt+1]+2;\r\nbreak;\r\n} else\r\ncnt += buf[cnt + 1] + 2;\r\n}\r\n}\r\n}\r\nexit:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int r8711_wx_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nu32 ht_ielen = 0;\r\nchar *p;\r\nu8 ht_cap = false;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nNDIS_802_11_RATES_EX *prates = NULL;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) ==\r\ntrue) {\r\np = r8712_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_,\r\n&ht_ielen, pcur_bss->IELength - 12);\r\nif (p && ht_ielen > 0)\r\nht_cap = true;\r\nprates = &pcur_bss->SupportedRates;\r\nif (r8712_is_cckratesonly_included((u8 *)prates) == true) {\r\nif (ht_cap == true)\r\nsnprintf(wrqu->name, IFNAMSIZ,\r\n"IEEE 802.11bn");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ,\r\n"IEEE 802.11b");\r\n} else if ((r8712_is_cckrates_included((u8 *)prates)) == true) {\r\nif (ht_cap == true)\r\nsnprintf(wrqu->name, IFNAMSIZ,\r\n"IEEE 802.11bgn");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ,\r\n"IEEE 802.11bg");\r\n} else {\r\nif (ht_cap == true)\r\nsnprintf(wrqu->name, IFNAMSIZ,\r\n"IEEE 802.11gn");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ,\r\n"IEEE 802.11g");\r\n}\r\n} else\r\nsnprintf(wrqu->name, IFNAMSIZ, "unassociated");\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_set_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct iw_freq *fwrq = &wrqu->freq;\r\nint rc = 0;\r\nif ((fwrq->e == 1) &&\r\n(fwrq->m >= (int) 2.412e8) &&\r\n(fwrq->m <= (int) 2.487e8)) {\r\nint f = fwrq->m / 100000;\r\nint c = 0;\r\nwhile ((c < 14) && (f != frequency_list[c]))\r\nc++;\r\nfwrq->e = 0;\r\nfwrq->m = c + 1;\r\n}\r\nif ((fwrq->m > 14) || (fwrq->e > 0))\r\nrc = -EOPNOTSUPP;\r\nelse {\r\nint channel = fwrq->m;\r\nif ((channel < 1) || (channel > 14))\r\nrc = -EINVAL;\r\nelse {\r\npadapter->registrypriv.channel = channel;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int r8711_wx_get_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true) {\r\nwrqu->freq.m = ieee80211_wlan_frequencies[\r\npcur_bss->Configuration.DSConfig-1] * 100000;\r\nwrqu->freq.e = 1;\r\nwrqu->freq.i = pcur_bss->Configuration.DSConfig;\r\n} else\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_set_mode(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nenum NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;\r\nswitch (wrqu->mode) {\r\ncase IW_MODE_AUTO:\r\nnetworkType = Ndis802_11AutoUnknown;\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\nnetworkType = Ndis802_11IBSS;\r\nbreak;\r\ncase IW_MODE_MASTER:\r\nnetworkType = Ndis802_11APMode;\r\nbreak;\r\ncase IW_MODE_INFRA:\r\nnetworkType = Ndis802_11Infrastructure;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (Ndis802_11APMode == networkType)\r\nr8712_setopmode_cmd(padapter, networkType);\r\nelse\r\nr8712_setopmode_cmd(padapter, Ndis802_11AutoUnknown);\r\nif (!r8712_set_802_11_infrastructure_mode(padapter, networkType))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_get_mode(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)\r\nwrqu->mode = IW_MODE_INFRA;\r\nelse if (check_fwstate(pmlmepriv,\r\nWIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE) == true)\r\nwrqu->mode = IW_MODE_ADHOC;\r\nelse if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\r\nwrqu->mode = IW_MODE_MASTER;\r\nelse\r\nwrqu->mode = IW_MODE_AUTO;\r\nreturn 0;\r\n}\r\nstatic int r871x_wx_set_pmkid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct iw_pmksa *pPMK = (struct iw_pmksa *) extra;\r\nu8 strZeroMacAddress[ETH_ALEN] = {0x00};\r\nu8 strIssueBssid[ETH_ALEN] = {0x00};\r\nu8 j, blInserted = false;\r\nint intReturn = false;\r\nif (pPMK == NULL)\r\nreturn -EINVAL;\r\nmemcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);\r\nswitch (pPMK->cmd) {\r\ncase IW_PMKSA_ADD:\r\nif (!memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN))\r\nreturn intReturn;\r\nelse\r\nintReturn = true;\r\nblInserted = false;\r\nfor (j = 0 ; j < NUM_PMKID_CACHE; j++) {\r\nif (!memcmp(psecuritypriv->PMKIDList[j].Bssid,\r\nstrIssueBssid, ETH_ALEN)) {\r\nprintk(KERN_INFO "r8712u: r871x_wx_set_pmkid:"\r\n" BSSID exists in the PMKList.\n");\r\nmemcpy(psecuritypriv->PMKIDList[j].PMKID,\r\npPMK->pmkid, IW_PMKID_LEN);\r\npsecuritypriv->PMKIDList[j].bUsed = true;\r\npsecuritypriv->PMKIDIndex = j + 1;\r\nblInserted = true;\r\nbreak;\r\n}\r\n}\r\nif (!blInserted) {\r\nprintk(KERN_INFO "r8712u: r871x_wx_set_pmkid: Use the"\r\n" new entry index = %d for this PMKID.\n",\r\npsecuritypriv->PMKIDIndex);\r\nmemcpy(psecuritypriv->PMKIDList[psecuritypriv->\r\nPMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);\r\nmemcpy(psecuritypriv->PMKIDList[psecuritypriv->\r\nPMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);\r\npsecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].\r\nbUsed = true;\r\npsecuritypriv->PMKIDIndex++ ;\r\nif (psecuritypriv->PMKIDIndex == NUM_PMKID_CACHE)\r\npsecuritypriv->PMKIDIndex = 0;\r\n}\r\nbreak;\r\ncase IW_PMKSA_REMOVE:\r\nintReturn = true;\r\nfor (j = 0; j < NUM_PMKID_CACHE; j++) {\r\nif (!memcmp(psecuritypriv->PMKIDList[j].Bssid,\r\nstrIssueBssid, ETH_ALEN)) {\r\nmemset(psecuritypriv->PMKIDList[j].Bssid,\r\n0x00, ETH_ALEN);\r\npsecuritypriv->PMKIDList[j].bUsed = false;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase IW_PMKSA_FLUSH:\r\nmemset(psecuritypriv->PMKIDList, 0,\r\nsizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);\r\npsecuritypriv->PMKIDIndex = 0;\r\nintReturn = true;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "r8712u: r871x_wx_set_pmkid: "\r\n"unknown Command\n");\r\nintReturn = false;\r\nbreak;\r\n}\r\nreturn intReturn;\r\n}\r\nstatic int r8711_wx_get_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nwrqu->sens.value = 0;\r\nwrqu->sens.fixed = 0;\r\nwrqu->sens.disabled = 1;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_get_range(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nu16 val;\r\nint i;\r\nwrqu->data.length = sizeof(*range);\r\nmemset(range, 0, sizeof(*range));\r\nrange->throughput = 5 * 1000 * 1000;\r\nrange->max_qual.qual = 100;\r\nrange->max_qual.level = 100;\r\nrange->max_qual.noise = 100;\r\nrange->max_qual.updated = 7;\r\nrange->avg_qual.qual = 92;\r\nrange->avg_qual.level = 20 + -98;\r\nrange->avg_qual.noise = 0;\r\nrange->avg_qual.updated = 7;\r\nrange->num_bitrates = RATE_COUNT;\r\nfor (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++)\r\nrange->bitrate[i] = rtl8180_rates[i];\r\nrange->min_frag = MIN_FRAG_THRESHOLD;\r\nrange->max_frag = MAX_FRAG_THRESHOLD;\r\nrange->pm_capa = 0;\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 16;\r\nrange->num_channels = 14;\r\nfor (i = 0, val = 0; i < 14; i++) {\r\nrange->freq[val].i = i + 1;\r\nrange->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;\r\nrange->freq[val].e = 1;\r\nval++;\r\nif (val == IW_MAX_FREQUENCIES)\r\nbreak;\r\n}\r\nrange->num_frequency = val;\r\nrange->enc_capa = IW_ENC_CAPA_WPA |\r\nIW_ENC_CAPA_WPA2 |\r\nIW_ENC_CAPA_CIPHER_TKIP |\r\nIW_ENC_CAPA_CIPHER_CCMP;\r\nreturn 0;\r\n}\r\nstatic int r871x_wx_set_priv(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *awrq,\r\nchar *extra)\r\n{\r\nint ret = 0, len = 0;\r\nchar *ext;\r\nstruct iw_point *dwrq = (struct iw_point *)awrq;\r\nlen = dwrq->length;\r\next = _malloc(len);\r\nif (!ext)\r\nreturn -ENOMEM;\r\nif (copy_from_user(ext, dwrq->pointer, len)) {\r\nkfree(ext);\r\nreturn -EFAULT;\r\n}\r\nkfree(ext);\r\nreturn ret;\r\n}\r\nstatic int r8711_wx_set_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *awrq,\r\nchar *extra)\r\n{\r\nint ret = -EINPROGRESS;\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct __queue *queue = &pmlmepriv->scanned_queue;\r\nstruct sockaddr *temp = (struct sockaddr *)awrq;\r\nunsigned long irqL;\r\nstruct list_head *phead;\r\nu8 *dst_bssid;\r\nstruct wlan_network *pnetwork = NULL;\r\nenum NDIS_802_11_AUTHENTICATION_MODE authmode;\r\nif (padapter->bup == false)\r\nreturn -1;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\r\nreturn -1;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)\r\nreturn ret;\r\nif (temp->sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nauthmode = padapter->securitypriv.ndisauthtype;\r\nspin_lock_irqsave(&queue->lock, irqL);\r\nphead = get_list_head(queue);\r\npmlmepriv->pscanned = get_next(phead);\r\nwhile (1) {\r\nif (end_of_queue_search(phead, pmlmepriv->pscanned) == true)\r\nbreak;\r\npnetwork = LIST_CONTAINOR(pmlmepriv->pscanned,\r\nstruct wlan_network, list);\r\npmlmepriv->pscanned = get_next(pmlmepriv->pscanned);\r\ndst_bssid = pnetwork->network.MacAddress;\r\nif (!memcmp(dst_bssid, temp->sa_data, ETH_ALEN)) {\r\nif (r8712_set_802_11_infrastructure_mode(padapter,\r\npnetwork->network.InfrastructureMode) == false)\r\nret = -1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&queue->lock, irqL);\r\nif (!ret) {\r\nif (!r8712_set_802_11_authentication_mode(padapter, authmode))\r\nret = -1;\r\nelse {\r\nif (!r8712_set_802_11_bssid(padapter, temp->sa_data))\r\nret = -1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int r8711_wx_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nwrqu->ap_addr.sa_family = ARPHRD_ETHER;\r\nmemset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED |\r\nWIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)) {\r\nmemcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int r871x_wx_set_mlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret = 0;\r\nu16 reason;\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct iw_mlme *mlme = (struct iw_mlme *) extra;\r\nif (mlme == NULL)\r\nreturn -1;\r\nreason = cpu_to_le16(mlme->reason_code);\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\nif (!r8712_set_802_11_disassociate(padapter))\r\nret = -1;\r\nbreak;\r\ncase IW_MLME_DISASSOC:\r\nif (!r8712_set_802_11_disassociate(padapter))\r\nret = -1;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int r8711_wx_set_scan(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nu8 status = true;\r\nif (padapter->bDriverStopped == true) {\r\nprintk(KERN_WARNING "r8712u: in r8711_wx_set_scan: "\r\n"bDriverStopped=%d\n", padapter->bDriverStopped);\r\nreturn -1;\r\n}\r\nif (padapter->bup == false)\r\nreturn -1;\r\nif (padapter->hw_init_completed == false)\r\nreturn -1;\r\nif ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) ||\r\n(pmlmepriv->sitesurveyctrl.traffic_busy == true))\r\nreturn 0;\r\nif (wrqu->data.length == sizeof(struct iw_scan_req)) {\r\nstruct iw_scan_req *req = (struct iw_scan_req *)extra;\r\nif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\r\nstruct ndis_802_11_ssid ssid;\r\nunsigned long irqL;\r\nu32 len = (u32) min((u8)req->essid_len,\r\n(u8)IW_ESSID_MAX_SIZE);\r\nmemset((unsigned char *)&ssid, 0,\r\nsizeof(struct ndis_802_11_ssid));\r\nmemcpy(ssid.Ssid, req->essid, len);\r\nssid.SsidLength = len;\r\nspin_lock_irqsave(&pmlmepriv->lock, irqL);\r\nif ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY |\r\n_FW_UNDER_LINKING)) ||\r\n(pmlmepriv->sitesurveyctrl.traffic_busy == true)) {\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\r\nstatus = false;\r\n} else\r\nstatus = r8712_sitesurvey_cmd(padapter, &ssid);\r\nspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\r\n}\r\n} else\r\nstatus = r8712_set_802_11_bssid_list_scan(padapter);\r\nif (status == false)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_get_scan(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct __queue *queue = &pmlmepriv->scanned_queue;\r\nstruct wlan_network *pnetwork = NULL;\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\nchar *ev = extra;\r\nchar *stop = ev + wrqu->data.length;\r\nu32 ret = 0, cnt = 0;\r\nif (padapter->bDriverStopped)\r\nreturn -EINVAL;\r\nwhile (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {\r\nmsleep(30);\r\ncnt++;\r\nif (cnt > 1000)\r\nbreak;\r\n}\r\nspin_lock_irqsave(&queue->lock, irqL);\r\nphead = get_list_head(queue);\r\nplist = get_next(phead);\r\nwhile (1) {\r\nif (end_of_queue_search(phead, plist) == true)\r\nbreak;\r\nif ((stop - ev) < SCAN_ITEM_SIZE) {\r\nret = -E2BIG;\r\nbreak;\r\n}\r\npnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);\r\nev = translate_scan(padapter, a, pnetwork, ev, stop);\r\nplist = get_next(plist);\r\n}\r\nspin_unlock_irqrestore(&queue->lock, irqL);\r\nwrqu->data.length = ev - extra;\r\nwrqu->data.flags = 0;\r\nreturn ret;\r\n}\r\nstatic int r8711_wx_set_essid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct __queue *queue = &pmlmepriv->scanned_queue;\r\nstruct wlan_network *pnetwork = NULL;\r\nenum NDIS_802_11_AUTHENTICATION_MODE authmode;\r\nstruct ndis_802_11_ssid ndis_ssid;\r\nu8 *dst_ssid, *src_ssid;\r\nstruct list_head *phead;\r\nu32 len;\r\nif (padapter->bup == false)\r\nreturn -1;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))\r\nreturn -1;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\r\nreturn 0;\r\nif (wrqu->essid.length > IW_ESSID_MAX_SIZE)\r\nreturn -E2BIG;\r\nauthmode = padapter->securitypriv.ndisauthtype;\r\nif (wrqu->essid.flags && wrqu->essid.length) {\r\nlen = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ?\r\nwrqu->essid.length : IW_ESSID_MAX_SIZE;\r\nmemset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));\r\nndis_ssid.SsidLength = len;\r\nmemcpy(ndis_ssid.Ssid, extra, len);\r\nsrc_ssid = ndis_ssid.Ssid;\r\nphead = get_list_head(queue);\r\npmlmepriv->pscanned = get_next(phead);\r\nwhile (1) {\r\nif (end_of_queue_search(phead, pmlmepriv->pscanned))\r\nbreak;\r\npnetwork = LIST_CONTAINOR(pmlmepriv->pscanned,\r\nstruct wlan_network, list);\r\npmlmepriv->pscanned = get_next(pmlmepriv->pscanned);\r\ndst_ssid = pnetwork->network.Ssid.Ssid;\r\nif ((!memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength))\r\n&& (pnetwork->network.Ssid.SsidLength ==\r\nndis_ssid.SsidLength)) {\r\nif (!r8712_set_802_11_infrastructure_mode(\r\npadapter,\r\npnetwork->network.InfrastructureMode))\r\nreturn -1;\r\nbreak;\r\n}\r\n}\r\nr8712_set_802_11_authentication_mode(padapter, authmode);\r\nr8712_set_802_11_ssid(padapter, &ndis_ssid);\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int r8711_wx_get_essid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nu32 len, ret = 0;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {\r\nlen = pcur_bss->Ssid.SsidLength;\r\nwrqu->essid.length = len;\r\nmemcpy(extra, pcur_bss->Ssid.Ssid, len);\r\nwrqu->essid.flags = 1;\r\n} else\r\nret = -1;\r\nreturn ret;\r\n}\r\nstatic int r8711_wx_set_rate(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nu32 target_rate = wrqu->bitrate.value;\r\nu32 fixed = wrqu->bitrate.fixed;\r\nu32 ratevalue = 0;\r\nu8 datarates[NumRates];\r\nu8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};\r\nint i, ret = 0;\r\nif (target_rate == -1) {\r\nratevalue = 11;\r\ngoto set_rate;\r\n}\r\ntarget_rate = target_rate / 100000;\r\nswitch (target_rate) {\r\ncase 10:\r\nratevalue = 0;\r\nbreak;\r\ncase 20:\r\nratevalue = 1;\r\nbreak;\r\ncase 55:\r\nratevalue = 2;\r\nbreak;\r\ncase 60:\r\nratevalue = 3;\r\nbreak;\r\ncase 90:\r\nratevalue = 4;\r\nbreak;\r\ncase 110:\r\nratevalue = 5;\r\nbreak;\r\ncase 120:\r\nratevalue = 6;\r\nbreak;\r\ncase 180:\r\nratevalue = 7;\r\nbreak;\r\ncase 240:\r\nratevalue = 8;\r\nbreak;\r\ncase 360:\r\nratevalue = 9;\r\nbreak;\r\ncase 480:\r\nratevalue = 10;\r\nbreak;\r\ncase 540:\r\nratevalue = 11;\r\nbreak;\r\ndefault:\r\nratevalue = 11;\r\nbreak;\r\n}\r\nset_rate:\r\nfor (i = 0; i < NumRates; i++) {\r\nif (ratevalue == mpdatarate[i]) {\r\ndatarates[i] = mpdatarate[i];\r\nif (fixed == 0)\r\nbreak;\r\n} else\r\ndatarates[i] = 0xff;\r\n}\r\nif (r8712_setdatarate_cmd(padapter, datarates) != _SUCCESS)\r\nret = -1;\r\nreturn ret;\r\n}\r\nstatic int r8711_wx_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nstruct ieee80211_ht_cap *pht_capie;\r\nint i;\r\nu8 *p;\r\nu16 rate, max_rate = 0, ht_cap = false;\r\nu32 ht_ielen = 0;\r\nu8 bw_40MHz = 0, short_GI = 0;\r\nu16 mcs_rate = 0;\r\ni = 0;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {\r\np = r8712_get_ie(&pcur_bss->IEs[12],\r\n_HT_CAPABILITY_IE_, &ht_ielen,\r\npcur_bss->IELength - 12);\r\nif (p && ht_ielen > 0) {\r\nht_cap = true;\r\npht_capie = (struct ieee80211_ht_cap *)(p + 2);\r\nmemcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);\r\nbw_40MHz = (pht_capie->cap_info &\r\nIEEE80211_HT_CAP_SUP_WIDTH) ? 1 : 0;\r\nshort_GI = (pht_capie->cap_info &\r\n(IEEE80211_HT_CAP_SGI_20 |\r\nIEEE80211_HT_CAP_SGI_40)) ? 1 : 0;\r\n}\r\nwhile ((pcur_bss->SupportedRates[i] != 0) &&\r\n(pcur_bss->SupportedRates[i] != 0xFF)) {\r\nrate = pcur_bss->SupportedRates[i] & 0x7F;\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\nwrqu->bitrate.fixed = 0;\r\nwrqu->bitrate.value = rate*500000;\r\ni++;\r\n}\r\nif (ht_cap == true) {\r\nif (mcs_rate & 0x8000)\r\nmax_rate = (bw_40MHz) ? ((short_GI) ? 300 :\r\n270) : ((short_GI) ? 144 : 130);\r\nelse if (mcs_rate & 0x0080)\r\nmax_rate = (bw_40MHz) ? ((short_GI) ? 150 :\r\n135) : ((short_GI) ? 72 : 65);\r\nelse\r\nmax_rate = (bw_40MHz) ? ((short_GI) ? 150 :\r\n135) : ((short_GI) ? 72 : 65);\r\nmax_rate *= 2;\r\nwrqu->bitrate.value = max_rate * 500000;\r\n} else {\r\nwrqu->bitrate.value = max_rate * 500000;\r\n}\r\n} else\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_get_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nwrqu->rts.value = padapter->registrypriv.rts_thresh;\r\nwrqu->rts.fixed = 0;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_set_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nif (wrqu->frag.disabled)\r\npadapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;\r\nelse {\r\nif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\r\nwrqu->frag.value > MAX_FRAG_THRESHOLD)\r\nreturn -EINVAL;\r\npadapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_get_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nwrqu->frag.value = padapter->xmitpriv.frag_len;\r\nwrqu->frag.fixed = 0;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nwrqu->retry.value = 7;\r\nwrqu->retry.fixed = 0;\r\nwrqu->retry.disabled = 1;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_set_enc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nu32 key;\r\nu32 keyindex_provided;\r\nstruct NDIS_802_11_WEP wep;\r\nenum NDIS_802_11_AUTHENTICATION_MODE authmode;\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nmemset(&wep, 0, sizeof(struct NDIS_802_11_WEP));\r\nif (erq->flags & IW_ENCODE_DISABLED) {\r\nprintk(KERN_INFO "r8712u: r8711_wx_set_enc: "\r\n"EncryptionDisabled\n");\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11EncryptionDisabled;\r\npadapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;\r\npadapter->securitypriv.AuthAlgrthm = 0;\r\nauthmode = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.ndisauthtype = authmode;\r\nreturn 0;\r\n}\r\nif (key) {\r\nif (key > WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\nkeyindex_provided = 1;\r\n} else {\r\nkeyindex_provided = 0;\r\nkey = padapter->securitypriv.PrivacyKeyIndex;\r\n}\r\nif (erq->flags & IW_ENCODE_OPEN) {\r\nprintk(KERN_INFO "r8712u: r8711_wx_set_enc: "\r\n"IW_ENCODE_OPEN\n");\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\npadapter->securitypriv.AuthAlgrthm = 0;\r\npadapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;\r\nauthmode = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.ndisauthtype = authmode;\r\n} else if (erq->flags & IW_ENCODE_RESTRICTED) {\r\nprintk(KERN_INFO "r8712u: r8711_wx_set_enc: "\r\n"IW_ENCODE_RESTRICTED\n");\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\npadapter->securitypriv.AuthAlgrthm = 1;\r\npadapter->securitypriv.PrivacyAlgrthm = _WEP40_;\r\npadapter->securitypriv.XGrpPrivacy = _WEP40_;\r\nauthmode = Ndis802_11AuthModeShared;\r\npadapter->securitypriv.ndisauthtype = authmode;\r\n} else {\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption1Enabled;\r\npadapter->securitypriv.AuthAlgrthm = 0;\r\npadapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;\r\nauthmode = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.ndisauthtype = authmode;\r\n}\r\nwep.KeyIndex = key;\r\nif (erq->length > 0) {\r\nwep.KeyLength = erq->length <= 5 ? 5 : 13;\r\nwep.Length = wep.KeyLength +\r\nFIELD_OFFSET(struct NDIS_802_11_WEP, KeyMaterial);\r\n} else {\r\nwep.KeyLength = 0 ;\r\nif (keyindex_provided == 1) {\r\npadapter->securitypriv.PrivacyKeyIndex = key;\r\nswitch (padapter->securitypriv.DefKeylen[key]) {\r\ncase 5:\r\npadapter->securitypriv.PrivacyAlgrthm =\r\n_WEP40_;\r\nbreak;\r\ncase 13:\r\npadapter->securitypriv.PrivacyAlgrthm =\r\n_WEP104_;\r\nbreak;\r\ndefault:\r\npadapter->securitypriv.PrivacyAlgrthm =\r\n_NO_PRIVACY_;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nwep.KeyIndex |= 0x80000000;\r\nmemcpy(wep.KeyMaterial, keybuf, wep.KeyLength);\r\nif (r8712_set_802_11_add_wep(padapter, &wep) == _FAIL)\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_get_enc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nuint key, ret = 0;\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == false) {\r\nif (!check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nreturn 0;\r\n}\r\n}\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (key) {\r\nif (key > WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\n} else {\r\nkey = padapter->securitypriv.PrivacyKeyIndex;\r\n}\r\nerq->flags = key + 1;\r\nswitch (padapter->securitypriv.ndisencryptstatus) {\r\ncase Ndis802_11EncryptionNotSupported:\r\ncase Ndis802_11EncryptionDisabled:\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nbreak;\r\ncase Ndis802_11Encryption1Enabled:\r\nerq->length = padapter->securitypriv.DefKeylen[key];\r\nif (erq->length) {\r\nmemcpy(keybuf, padapter->securitypriv.DefKey[\r\nkey].skey, padapter->securitypriv.\r\nDefKeylen[key]);\r\nerq->flags |= IW_ENCODE_ENABLED;\r\nif (padapter->securitypriv.ndisauthtype ==\r\nNdis802_11AuthModeOpen)\r\nerq->flags |= IW_ENCODE_OPEN;\r\nelse if (padapter->securitypriv.ndisauthtype ==\r\nNdis802_11AuthModeShared)\r\nerq->flags |= IW_ENCODE_RESTRICTED;\r\n} else {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\n}\r\nbreak;\r\ncase Ndis802_11Encryption2Enabled:\r\ncase Ndis802_11Encryption3Enabled:\r\nerq->length = 16;\r\nerq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN |\r\nIW_ENCODE_NOKEY);\r\nbreak;\r\ndefault:\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int r8711_wx_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nwrqu->power.value = 0;\r\nwrqu->power.fixed = 0;\r\nwrqu->power.disabled = 1;\r\nreturn 0;\r\n}\r\nstatic int r871x_wx_set_gen_ie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nreturn r871x_set_wpa_ie(padapter, extra, wrqu->data.length);\r\n}\r\nstatic int r871x_wx_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct iw_param *param = (struct iw_param *)&(wrqu->param);\r\nint paramid;\r\nint paramval;\r\nint ret = 0;\r\nparamid = param->flags & IW_AUTH_INDEX;\r\nparamval = param->value;\r\nswitch (paramid) {\r\ncase IW_AUTH_WPA_VERSION:\r\nbreak;\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\nbreak;\r\ncase IW_AUTH_CIPHER_GROUP:\r\nbreak;\r\ncase IW_AUTH_KEY_MGMT:\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nif (paramval) {\r\npadapter->securitypriv.btkip_countermeasure = true;\r\n} else {\r\npadapter->securitypriv.btkip_countermeasure = false;\r\n}\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nif (padapter->securitypriv.ndisencryptstatus ==\r\nNdis802_11Encryption1Enabled) {\r\nbreak;\r\n}\r\nif (paramval) {\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11EncryptionDisabled;\r\npadapter->securitypriv.PrivacyAlgrthm =\r\n_NO_PRIVACY_;\r\npadapter->securitypriv.XGrpPrivacy =\r\n_NO_PRIVACY_;\r\npadapter->securitypriv.AuthAlgrthm = 0;\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeOpen;\r\n}\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nret = wpa_set_auth_algs(dev, (u32)paramval);\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int r871x_wx_set_enc_ext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_point *pencoding = &wrqu->encoding;\r\nstruct iw_encode_ext *pext = (struct iw_encode_ext *)extra;\r\nstruct ieee_param *param = NULL;\r\nchar *alg_name;\r\nu32 param_len;\r\nint ret = 0;\r\nparam_len = sizeof(struct ieee_param) + pext->key_len;\r\nparam = (struct ieee_param *)_malloc(param_len);\r\nif (param == NULL)\r\nreturn -1;\r\nmemset(param, 0, param_len);\r\nparam->cmd = IEEE_CMD_SET_ENCRYPTION;\r\nmemset(param->sta_addr, 0xff, ETH_ALEN);\r\nswitch (pext->alg) {\r\ncase IW_ENCODE_ALG_NONE:\r\nalg_name = "none";\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nalg_name = "WEP";\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\nalg_name = "TKIP";\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\nalg_name = "CCMP";\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nstrncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);\r\nif (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)\r\nparam->u.crypt.set_tx = 0;\r\nif (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)\r\nparam->u.crypt.set_tx = 1;\r\nparam->u.crypt.idx = (pencoding->flags & 0x00FF) - 1;\r\nif (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)\r\nmemcpy(param->u.crypt.seq, pext->rx_seq, 8);\r\nif (pext->key_len) {\r\nparam->u.crypt.key_len = pext->key_len;\r\nmemcpy(param + 1, pext + 1, pext->key_len);\r\n}\r\nret = wpa_set_encryption(dev, param, param_len);\r\nkfree(param);\r\nreturn ret;\r\n}\r\nstatic int r871x_wx_get_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nif (extra) {\r\nwrqu->data.length = 8;\r\nwrqu->data.flags = 1;\r\nmemcpy(extra, "rtl_wifi", 8);\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_read32(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nu32 addr;\r\nu32 data32;\r\nget_user(addr, (u32 __user *)wrqu->data.pointer);\r\ndata32 = r8712_read32(padapter, addr);\r\nput_user(data32, (u32 __user *)wrqu->data.pointer);\r\nwrqu->data.length = (data32 & 0xffff0000) >> 16;\r\nwrqu->data.flags = data32 & 0xffff;\r\nget_user(addr, (u32 __user *)wrqu->data.pointer);\r\nreturn 0;\r\n}\r\nstatic int r8711_wx_write32(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nu32 addr;\r\nu32 data32;\r\nget_user(addr, (u32 __user *)wrqu->data.pointer);\r\ndata32 = ((u32)wrqu->data.length<<16) | (u32)wrqu->data.flags ;\r\nr8712_write32(padapter, addr, data32);\r\nreturn 0;\r\n}\r\nstatic int dummy(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nreturn -1;\r\n}\r\nstatic int r8711_drvext_hdl(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nreturn 0;\r\n}\r\nstatic int r871x_mp_ioctl_hdl(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct iw_point *p = &wrqu->data;\r\nstruct oid_par_priv oid_par;\r\nstruct mp_ioctl_handler *phandler;\r\nstruct mp_ioctl_param *poidparam;\r\nunsigned long BytesRead, BytesWritten, BytesNeeded;\r\nu8 *pparmbuf = NULL, bset;\r\nu16 len;\r\nuint status;\r\nint ret = 0;\r\nif ((!p->length) || (!p->pointer)) {\r\nret = -EINVAL;\r\ngoto _r871x_mp_ioctl_hdl_exit;\r\n}\r\nbset = (u8)(p->flags & 0xFFFF);\r\nlen = p->length;\r\npparmbuf = NULL;\r\npparmbuf = (u8 *)_malloc(len);\r\nif (pparmbuf == NULL) {\r\nret = -ENOMEM;\r\ngoto _r871x_mp_ioctl_hdl_exit;\r\n}\r\nif (copy_from_user(pparmbuf, p->pointer, len)) {\r\nret = -EFAULT;\r\ngoto _r871x_mp_ioctl_hdl_exit;\r\n}\r\npoidparam = (struct mp_ioctl_param *)pparmbuf;\r\nif (poidparam->subcode >= MAX_MP_IOCTL_SUBCODE) {\r\nret = -EINVAL;\r\ngoto _r871x_mp_ioctl_hdl_exit;\r\n}\r\nphandler = mp_ioctl_hdl + poidparam->subcode;\r\nif ((phandler->paramsize != 0) &&\r\n(poidparam->len < phandler->paramsize)) {\r\nret = -EINVAL;\r\ngoto _r871x_mp_ioctl_hdl_exit;\r\n}\r\nif (phandler->oid == 0 && phandler->handler)\r\nstatus = phandler->handler(&oid_par);\r\nelse if (phandler->handler) {\r\noid_par.adapter_context = padapter;\r\noid_par.oid = phandler->oid;\r\noid_par.information_buf = poidparam->data;\r\noid_par.information_buf_len = poidparam->len;\r\noid_par.dbg = 0;\r\nBytesWritten = 0;\r\nBytesNeeded = 0;\r\nif (bset) {\r\noid_par.bytes_rw = &BytesRead;\r\noid_par.bytes_needed = &BytesNeeded;\r\noid_par.type_of_oid = SET_OID;\r\n} else {\r\noid_par.bytes_rw = &BytesWritten;\r\noid_par.bytes_needed = &BytesNeeded;\r\noid_par.type_of_oid = QUERY_OID;\r\n}\r\nstatus = phandler->handler(&oid_par);\r\n} else {\r\nprintk(KERN_INFO "r8712u: r871x_mp_ioctl_hdl(): err!,"\r\n" subcode=%d, oid=%d, handler=%p\n",\r\npoidparam->subcode, phandler->oid, phandler->handler);\r\nret = -EFAULT;\r\ngoto _r871x_mp_ioctl_hdl_exit;\r\n}\r\nif (bset == 0x00) {\r\nif (copy_to_user(p->pointer, pparmbuf, len))\r\nret = -EFAULT;\r\n}\r\nif (status) {\r\nret = -EFAULT;\r\ngoto _r871x_mp_ioctl_hdl_exit;\r\n}\r\n_r871x_mp_ioctl_hdl_exit:\r\nkfree(pparmbuf);\r\nreturn ret;\r\n}\r\nstatic int r871x_get_ap_info(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct __queue *queue = &pmlmepriv->scanned_queue;\r\nstruct iw_point *pdata = &wrqu->data;\r\nstruct wlan_network *pnetwork = NULL;\r\nu32 cnt = 0, wpa_ielen;\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\nunsigned char *pbuf;\r\nu8 bssid[ETH_ALEN];\r\nchar data[32];\r\nif (padapter->bDriverStopped || (pdata == NULL))\r\nreturn -EINVAL;\r\nwhile (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {\r\nmsleep(30);\r\ncnt++;\r\nif (cnt > 100)\r\nbreak;\r\n}\r\npdata->flags = 0;\r\nif (pdata->length >= 32) {\r\nif (copy_from_user(data, pdata->pointer, 32))\r\nreturn -EINVAL;\r\n} else\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&(pmlmepriv->scanned_queue.lock), irqL);\r\nphead = get_list_head(queue);\r\nplist = get_next(phead);\r\nwhile (1) {\r\nif (end_of_queue_search(phead, plist) == true)\r\nbreak;\r\npnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);\r\nif (hwaddr_aton_i(data, bssid)) {\r\nprintk(KERN_INFO "r8712u: Invalid BSSID '%s'.\n",\r\n(u8 *)data);\r\nspin_unlock_irqrestore(&(pmlmepriv->scanned_queue.lock),\r\nirqL);\r\nreturn -EINVAL;\r\n}\r\nprintk(KERN_INFO "r8712u: BSSID:%pM\n", bssid);\r\nif (!memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN)) {\r\npbuf = r8712_get_wpa_ie(&pnetwork->network.IEs[12],\r\n&wpa_ielen, pnetwork->network.IELength-12);\r\nif (pbuf && (wpa_ielen > 0)) {\r\npdata->flags = 1;\r\nbreak;\r\n}\r\npbuf = r8712_get_wpa2_ie(&pnetwork->network.IEs[12],\r\n&wpa_ielen, pnetwork->network.IELength-12);\r\nif (pbuf && (wpa_ielen > 0)) {\r\npdata->flags = 2;\r\nbreak;\r\n}\r\n}\r\nplist = get_next(plist);\r\n}\r\nspin_unlock_irqrestore(&(pmlmepriv->scanned_queue.lock), irqL);\r\nif (pdata->length >= 34) {\r\nif (copy_to_user((u8 __user *)pdata->pointer + 32,\r\n(u8 *)&pdata->flags, 1))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r871x_set_pid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nstruct iw_point *pdata = &wrqu->data;\r\nif ((padapter->bDriverStopped) || (pdata == NULL))\r\nreturn -EINVAL;\r\nif (copy_from_user(&padapter->pid, pdata->pointer, sizeof(int)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int r871x_wps_start(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)_netdev_priv(dev);\r\nstruct iw_point *pdata = &wrqu->data;\r\nu32 u32wps_start = 0;\r\nif (copy_from_user((void *)&u32wps_start, pdata->pointer, 4))\r\nreturn -EFAULT;\r\nif ((padapter->bDriverStopped) || (pdata == NULL))\r\nreturn -EINVAL;\r\nif (u32wps_start == 0)\r\nu32wps_start = *extra;\r\nif (u32wps_start == 1)\r\npadapter->ledpriv.LedControlHandler(padapter,\r\nLED_CTL_START_WPS);\r\nelse if (u32wps_start == 2)\r\npadapter->ledpriv.LedControlHandler(padapter,\r\nLED_CTL_STOP_WPS);\r\nelse if (u32wps_start == 3)\r\npadapter->ledpriv.LedControlHandler(padapter,\r\nLED_CTL_STOP_WPS_FAIL);\r\nreturn 0;\r\n}\r\nstatic int wpa_set_param(struct net_device *dev, u8 name, u32 value)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nswitch (name) {\r\ncase IEEE_PARAM_WPA_ENABLED:\r\npadapter->securitypriv.AuthAlgrthm = 2;\r\nswitch ((value)&0xff) {\r\ncase 1:\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeWPAPSK;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption2Enabled;\r\nbreak;\r\ncase 2:\r\npadapter->securitypriv.ndisauthtype =\r\nNdis802_11AuthModeWPA2PSK;\r\npadapter->securitypriv.ndisencryptstatus =\r\nNdis802_11Encryption3Enabled;\r\nbreak;\r\n}\r\nbreak;\r\ncase IEEE_PARAM_TKIP_COUNTERMEASURES:\r\nbreak;\r\ncase IEEE_PARAM_DROP_UNENCRYPTED:\r\nbreak;\r\ncase IEEE_PARAM_PRIVACY_INVOKED:\r\nbreak;\r\ncase IEEE_PARAM_AUTH_ALGS:\r\nreturn wpa_set_auth_algs(dev, value);\r\nbreak;\r\ncase IEEE_PARAM_IEEE_802_1X:\r\nbreak;\r\ncase IEEE_PARAM_WPAX_SELECT:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wpa_mlme(struct net_device *dev, u32 command, u32 reason)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nswitch (command) {\r\ncase IEEE_MLME_STA_DEAUTH:\r\nif (!r8712_set_802_11_disassociate(padapter))\r\nreturn -1;\r\nbreak;\r\ncase IEEE_MLME_STA_DISASSOC:\r\nif (!r8712_set_802_11_disassociate(padapter))\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)\r\n{\r\nstruct ieee_param *param;\r\nint ret = 0;\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nif (p->length < sizeof(struct ieee_param) || !p->pointer)\r\nreturn -EINVAL;\r\nparam = (struct ieee_param *)_malloc(p->length);\r\nif (param == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(param, p->pointer, p->length))\r\nkfree((u8 *)param);\r\nreturn -EFAULT;\r\nswitch (param->cmd) {\r\ncase IEEE_CMD_SET_WPA_PARAM:\r\nret = wpa_set_param(dev, param->u.wpa_param.name,\r\nparam->u.wpa_param.value);\r\nbreak;\r\ncase IEEE_CMD_SET_WPA_IE:\r\nret = r871x_set_wpa_ie(padapter, (char *)param->u.wpa_ie.data,\r\n(u16)param->u.wpa_ie.len);\r\nbreak;\r\ncase IEEE_CMD_SET_ENCRYPTION:\r\nret = wpa_set_encryption(dev, param, p->length);\r\nbreak;\r\ncase IEEE_CMD_MLME:\r\nret = wpa_mlme(dev, param->u.mlme.command,\r\nparam->u.mlme.reason_code);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (ret == 0 && copy_to_user(p->pointer, param, p->length))\r\nret = -EFAULT;\r\nkfree((u8 *)param);\r\nreturn ret;\r\n}\r\nint r871x_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct iwreq *wrq = (struct iwreq *)rq;\r\nswitch (cmd) {\r\ncase RTL_IOCTL_WPA_SUPPLICANT:\r\nreturn wpa_supplicant_ioctl(dev, &wrq->u.data);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct iw_statistics *r871x_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *) _netdev_priv(dev);\r\nstruct iw_statistics *piwstats = &padapter->iwstats;\r\nint tmp_level = 0;\r\nint tmp_qual = 0;\r\nint tmp_noise = 0;\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != true) {\r\npiwstats->qual.qual = 0;\r\npiwstats->qual.level = 0;\r\npiwstats->qual.noise = 0;\r\n} else {\r\ntmp_level = padapter->recvpriv.fw_rssi;\r\ntmp_qual = padapter->recvpriv.signal;\r\ntmp_noise = padapter->recvpriv.noise;\r\npiwstats->qual.level = tmp_level;\r\npiwstats->qual.qual = tmp_qual;\r\npiwstats->qual.noise = tmp_noise;\r\n}\r\npiwstats->qual.updated = IW_QUAL_ALL_UPDATED;\r\nreturn &padapter->iwstats;\r\n}
