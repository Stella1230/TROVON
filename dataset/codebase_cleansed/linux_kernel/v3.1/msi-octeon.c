int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)\r\n{\r\nstruct msi_msg msg;\r\nu16 control;\r\nint configured_private_bits;\r\nint request_private_bits;\r\nint irq = 0;\r\nint irq_step;\r\nu64 search_mask;\r\nint index;\r\npci_read_config_word(dev, desc->msi_attrib.pos + PCI_MSI_FLAGS,\r\n&control);\r\nconfigured_private_bits = (control & PCI_MSI_FLAGS_QSIZE) >> 4;\r\nif (configured_private_bits == 0) {\r\nrequest_private_bits = (control & PCI_MSI_FLAGS_QMASK) >> 1;\r\n} else {\r\nrequest_private_bits = configured_private_bits;\r\n}\r\nif (request_private_bits > 5)\r\nrequest_private_bits = 0;\r\ntry_only_one:\r\nirq_step = 1 << request_private_bits;\r\nsearch_mask = (1 << irq_step) - 1;\r\nspin_lock(&msi_free_irq_bitmask_lock);\r\nfor (index = 0; index < msi_irq_size/64; index++) {\r\nfor (irq = 0; irq < 64; irq += irq_step) {\r\nif ((msi_free_irq_bitmask[index] & (search_mask << irq)) == 0) {\r\nmsi_free_irq_bitmask[index] |= search_mask << irq;\r\nmsi_multiple_irq_bitmask[index] |= (search_mask >> 1) << irq;\r\ngoto msi_irq_allocated;\r\n}\r\n}\r\n}\r\nmsi_irq_allocated:\r\nspin_unlock(&msi_free_irq_bitmask_lock);\r\nif (irq >= 64) {\r\nif (request_private_bits) {\r\npr_err("arch_setup_msi_irq: Unable to find %d free interrupts, trying just one",\r\n1 << request_private_bits);\r\nrequest_private_bits = 0;\r\ngoto try_only_one;\r\n} else\r\npanic("arch_setup_msi_irq: Unable to find a free MSI interrupt");\r\n}\r\nirq += index*64;\r\nirq += OCTEON_IRQ_MSI_BIT0;\r\nswitch (octeon_dma_bar_type) {\r\ncase OCTEON_DMA_BAR_TYPE_SMALL:\r\nmsg.address_lo =\r\n((128ul << 20) + CVMX_PCI_MSI_RCV) & 0xffffffff;\r\nmsg.address_hi = ((128ul << 20) + CVMX_PCI_MSI_RCV) >> 32;\r\ncase OCTEON_DMA_BAR_TYPE_BIG:\r\nmsg.address_lo = (0 + CVMX_PCI_MSI_RCV) & 0xffffffff;\r\nmsg.address_hi = (0 + CVMX_PCI_MSI_RCV) >> 32;\r\nbreak;\r\ncase OCTEON_DMA_BAR_TYPE_PCIE:\r\nmsg.address_lo = (0 + CVMX_NPEI_PCIE_MSI_RCV) & 0xffffffff;\r\nmsg.address_hi = (0 + CVMX_NPEI_PCIE_MSI_RCV) >> 32;\r\nbreak;\r\ndefault:\r\npanic("arch_setup_msi_irq: Invalid octeon_dma_bar_type\n");\r\n}\r\nmsg.data = irq - OCTEON_IRQ_MSI_BIT0;\r\ncontrol &= ~PCI_MSI_FLAGS_QSIZE;\r\ncontrol |= request_private_bits << 4;\r\npci_write_config_word(dev, desc->msi_attrib.pos + PCI_MSI_FLAGS,\r\ncontrol);\r\nirq_set_msi_desc(irq, desc);\r\nwrite_msi_msg(irq, &msg);\r\nreturn 0;\r\n}\r\nint arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)\r\n{\r\nstruct msi_desc *entry;\r\nint ret;\r\nif (type == PCI_CAP_ID_MSIX)\r\nreturn -EINVAL;\r\nif (type == PCI_CAP_ID_MSI && nvec > 1)\r\nreturn 1;\r\nlist_for_each_entry(entry, &dev->msi_list, list) {\r\nret = arch_setup_msi_irq(dev, entry);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret > 0)\r\nreturn -ENOSPC;\r\n}\r\nreturn 0;\r\n}\r\nvoid arch_teardown_msi_irq(unsigned int irq)\r\n{\r\nint number_irqs;\r\nu64 bitmask;\r\nint index = 0;\r\nint irq0;\r\nif ((irq < OCTEON_IRQ_MSI_BIT0)\r\n|| (irq > msi_irq_size + OCTEON_IRQ_MSI_BIT0))\r\npanic("arch_teardown_msi_irq: Attempted to teardown illegal "\r\n"MSI interrupt (%d)", irq);\r\nirq -= OCTEON_IRQ_MSI_BIT0;\r\nindex = irq / 64;\r\nirq0 = irq % 64;\r\nnumber_irqs = 0;\r\nwhile ((irq0 + number_irqs < 64) &&\r\n(msi_multiple_irq_bitmask[index]\r\n& (1ull << (irq0 + number_irqs))))\r\nnumber_irqs++;\r\nnumber_irqs++;\r\nbitmask = (1 << number_irqs) - 1;\r\nbitmask <<= irq0;\r\nif ((msi_free_irq_bitmask[index] & bitmask) != bitmask)\r\npanic("arch_teardown_msi_irq: Attempted to teardown MSI "\r\n"interrupt (%d) not in use", irq);\r\nspin_lock(&msi_free_irq_bitmask_lock);\r\nmsi_free_irq_bitmask[index] &= ~bitmask;\r\nmsi_multiple_irq_bitmask[index] &= ~bitmask;\r\nspin_unlock(&msi_free_irq_bitmask_lock);\r\n}\r\nstatic void octeon_irq_msi_enable_pcie(struct irq_data *data)\r\n{\r\nu64 en;\r\nunsigned long flags;\r\nint msi_number = data->irq - OCTEON_IRQ_MSI_BIT0;\r\nint irq_index = msi_number >> 6;\r\nint irq_bit = msi_number & 0x3f;\r\nraw_spin_lock_irqsave(&octeon_irq_msi_lock, flags);\r\nen = cvmx_read_csr(mis_ena_reg[irq_index]);\r\nen |= 1ull << irq_bit;\r\ncvmx_write_csr(mis_ena_reg[irq_index], en);\r\ncvmx_read_csr(mis_ena_reg[irq_index]);\r\nraw_spin_unlock_irqrestore(&octeon_irq_msi_lock, flags);\r\n}\r\nstatic void octeon_irq_msi_disable_pcie(struct irq_data *data)\r\n{\r\nu64 en;\r\nunsigned long flags;\r\nint msi_number = data->irq - OCTEON_IRQ_MSI_BIT0;\r\nint irq_index = msi_number >> 6;\r\nint irq_bit = msi_number & 0x3f;\r\nraw_spin_lock_irqsave(&octeon_irq_msi_lock, flags);\r\nen = cvmx_read_csr(mis_ena_reg[irq_index]);\r\nen &= ~(1ull << irq_bit);\r\ncvmx_write_csr(mis_ena_reg[irq_index], en);\r\ncvmx_read_csr(mis_ena_reg[irq_index]);\r\nraw_spin_unlock_irqrestore(&octeon_irq_msi_lock, flags);\r\n}\r\nstatic void octeon_irq_msi_enable_pci(struct irq_data *data)\r\n{\r\n}\r\nstatic void octeon_irq_msi_disable_pci(struct irq_data *data)\r\n{\r\n}\r\nstatic irqreturn_t __octeon_msi_do_interrupt(int index, u64 msi_bits)\r\n{\r\nint irq;\r\nint bit;\r\nbit = fls64(msi_bits);\r\nif (bit) {\r\nbit--;\r\ncvmx_write_csr(msi_rcv_reg[index], 1ull << bit);\r\nirq = bit + OCTEON_IRQ_MSI_BIT0 + 64 * index;\r\ndo_IRQ(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nint __init octeon_msi_initialize(void)\r\n{\r\nint irq;\r\nstruct irq_chip *msi;\r\nif (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE) {\r\nmsi_rcv_reg[0] = CVMX_PEXP_NPEI_MSI_RCV0;\r\nmsi_rcv_reg[1] = CVMX_PEXP_NPEI_MSI_RCV1;\r\nmsi_rcv_reg[2] = CVMX_PEXP_NPEI_MSI_RCV2;\r\nmsi_rcv_reg[3] = CVMX_PEXP_NPEI_MSI_RCV3;\r\nmis_ena_reg[0] = CVMX_PEXP_NPEI_MSI_ENB0;\r\nmis_ena_reg[1] = CVMX_PEXP_NPEI_MSI_ENB1;\r\nmis_ena_reg[2] = CVMX_PEXP_NPEI_MSI_ENB2;\r\nmis_ena_reg[3] = CVMX_PEXP_NPEI_MSI_ENB3;\r\nmsi = &octeon_irq_chip_msi_pcie;\r\n} else {\r\nmsi_rcv_reg[0] = CVMX_NPI_NPI_MSI_RCV;\r\n#define INVALID_GENERATE_ADE 0x8700000000000000ULL;\r\nmsi_rcv_reg[1] = INVALID_GENERATE_ADE;\r\nmsi_rcv_reg[2] = INVALID_GENERATE_ADE;\r\nmsi_rcv_reg[3] = INVALID_GENERATE_ADE;\r\nmis_ena_reg[0] = INVALID_GENERATE_ADE;\r\nmis_ena_reg[1] = INVALID_GENERATE_ADE;\r\nmis_ena_reg[2] = INVALID_GENERATE_ADE;\r\nmis_ena_reg[3] = INVALID_GENERATE_ADE;\r\nmsi = &octeon_irq_chip_msi_pci;\r\n}\r\nfor (irq = OCTEON_IRQ_MSI_BIT0; irq <= OCTEON_IRQ_MSI_LAST; irq++)\r\nirq_set_chip_and_handler(irq, msi, handle_simple_irq);\r\nif (octeon_has_feature(OCTEON_FEATURE_PCIE)) {\r\nif (request_irq(OCTEON_IRQ_PCI_MSI0, octeon_msi_interrupt0,\r\n0, "MSI[0:63]", octeon_msi_interrupt0))\r\npanic("request_irq(OCTEON_IRQ_PCI_MSI0) failed");\r\nif (request_irq(OCTEON_IRQ_PCI_MSI1, octeon_msi_interrupt1,\r\n0, "MSI[64:127]", octeon_msi_interrupt1))\r\npanic("request_irq(OCTEON_IRQ_PCI_MSI1) failed");\r\nif (request_irq(OCTEON_IRQ_PCI_MSI2, octeon_msi_interrupt2,\r\n0, "MSI[127:191]", octeon_msi_interrupt2))\r\npanic("request_irq(OCTEON_IRQ_PCI_MSI2) failed");\r\nif (request_irq(OCTEON_IRQ_PCI_MSI3, octeon_msi_interrupt3,\r\n0, "MSI[192:255]", octeon_msi_interrupt3))\r\npanic("request_irq(OCTEON_IRQ_PCI_MSI3) failed");\r\nmsi_irq_size = 256;\r\n} else if (octeon_is_pci_host()) {\r\nif (request_irq(OCTEON_IRQ_PCI_MSI0, octeon_msi_interrupt0,\r\n0, "MSI[0:15]", octeon_msi_interrupt0))\r\npanic("request_irq(OCTEON_IRQ_PCI_MSI0) failed");\r\nif (request_irq(OCTEON_IRQ_PCI_MSI1, octeon_msi_interrupt0,\r\n0, "MSI[16:31]", octeon_msi_interrupt0))\r\npanic("request_irq(OCTEON_IRQ_PCI_MSI1) failed");\r\nif (request_irq(OCTEON_IRQ_PCI_MSI2, octeon_msi_interrupt0,\r\n0, "MSI[32:47]", octeon_msi_interrupt0))\r\npanic("request_irq(OCTEON_IRQ_PCI_MSI2) failed");\r\nif (request_irq(OCTEON_IRQ_PCI_MSI3, octeon_msi_interrupt0,\r\n0, "MSI[48:63]", octeon_msi_interrupt0))\r\npanic("request_irq(OCTEON_IRQ_PCI_MSI3) failed");\r\nmsi_irq_size = 64;\r\n}\r\nreturn 0;\r\n}
