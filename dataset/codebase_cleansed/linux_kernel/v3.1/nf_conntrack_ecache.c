void nf_ct_deliver_cached_events(struct nf_conn *ct)\r\n{\r\nunsigned long events;\r\nstruct nf_ct_event_notifier *notify;\r\nstruct nf_conntrack_ecache *e;\r\nrcu_read_lock();\r\nnotify = rcu_dereference(nf_conntrack_event_cb);\r\nif (notify == NULL)\r\ngoto out_unlock;\r\ne = nf_ct_ecache_find(ct);\r\nif (e == NULL)\r\ngoto out_unlock;\r\nevents = xchg(&e->cache, 0);\r\nif (nf_ct_is_confirmed(ct) && !nf_ct_is_dying(ct) && events) {\r\nstruct nf_ct_event item = {\r\n.ct = ct,\r\n.pid = 0,\r\n.report = 0\r\n};\r\nint ret;\r\nunsigned long missed = e->missed;\r\nif (!((events | missed) & e->ctmask))\r\ngoto out_unlock;\r\nret = notify->fcn(events | missed, &item);\r\nif (unlikely(ret < 0 || missed)) {\r\nspin_lock_bh(&ct->lock);\r\nif (ret < 0)\r\ne->missed |= events;\r\nelse\r\ne->missed &= ~missed;\r\nspin_unlock_bh(&ct->lock);\r\n}\r\n}\r\nout_unlock:\r\nrcu_read_unlock();\r\n}\r\nint nf_conntrack_register_notifier(struct nf_ct_event_notifier *new)\r\n{\r\nint ret = 0;\r\nstruct nf_ct_event_notifier *notify;\r\nmutex_lock(&nf_ct_ecache_mutex);\r\nnotify = rcu_dereference_protected(nf_conntrack_event_cb,\r\nlockdep_is_held(&nf_ct_ecache_mutex));\r\nif (notify != NULL) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nrcu_assign_pointer(nf_conntrack_event_cb, new);\r\nmutex_unlock(&nf_ct_ecache_mutex);\r\nreturn ret;\r\nout_unlock:\r\nmutex_unlock(&nf_ct_ecache_mutex);\r\nreturn ret;\r\n}\r\nvoid nf_conntrack_unregister_notifier(struct nf_ct_event_notifier *new)\r\n{\r\nstruct nf_ct_event_notifier *notify;\r\nmutex_lock(&nf_ct_ecache_mutex);\r\nnotify = rcu_dereference_protected(nf_conntrack_event_cb,\r\nlockdep_is_held(&nf_ct_ecache_mutex));\r\nBUG_ON(notify != new);\r\nrcu_assign_pointer(nf_conntrack_event_cb, NULL);\r\nmutex_unlock(&nf_ct_ecache_mutex);\r\n}\r\nint nf_ct_expect_register_notifier(struct nf_exp_event_notifier *new)\r\n{\r\nint ret = 0;\r\nstruct nf_exp_event_notifier *notify;\r\nmutex_lock(&nf_ct_ecache_mutex);\r\nnotify = rcu_dereference_protected(nf_expect_event_cb,\r\nlockdep_is_held(&nf_ct_ecache_mutex));\r\nif (notify != NULL) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nrcu_assign_pointer(nf_expect_event_cb, new);\r\nmutex_unlock(&nf_ct_ecache_mutex);\r\nreturn ret;\r\nout_unlock:\r\nmutex_unlock(&nf_ct_ecache_mutex);\r\nreturn ret;\r\n}\r\nvoid nf_ct_expect_unregister_notifier(struct nf_exp_event_notifier *new)\r\n{\r\nstruct nf_exp_event_notifier *notify;\r\nmutex_lock(&nf_ct_ecache_mutex);\r\nnotify = rcu_dereference_protected(nf_expect_event_cb,\r\nlockdep_is_held(&nf_ct_ecache_mutex));\r\nBUG_ON(notify != new);\r\nrcu_assign_pointer(nf_expect_event_cb, NULL);\r\nmutex_unlock(&nf_ct_ecache_mutex);\r\n}\r\nstatic int nf_conntrack_event_init_sysctl(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = kmemdup(event_sysctl_table, sizeof(event_sysctl_table),\r\nGFP_KERNEL);\r\nif (!table)\r\ngoto out;\r\ntable[0].data = &net->ct.sysctl_events;\r\ntable[1].data = &net->ct.sysctl_events_retry_timeout;\r\nnet->ct.event_sysctl_header =\r\nregister_net_sysctl_table(net,\r\nnf_net_netfilter_sysctl_path, table);\r\nif (!net->ct.event_sysctl_header) {\r\nprintk(KERN_ERR "nf_ct_event: can't register to sysctl.\n");\r\ngoto out_register;\r\n}\r\nreturn 0;\r\nout_register:\r\nkfree(table);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nstatic void nf_conntrack_event_fini_sysctl(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = net->ct.event_sysctl_header->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ct.event_sysctl_header);\r\nkfree(table);\r\n}\r\nstatic int nf_conntrack_event_init_sysctl(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nf_conntrack_event_fini_sysctl(struct net *net)\r\n{\r\n}\r\nint nf_conntrack_ecache_init(struct net *net)\r\n{\r\nint ret;\r\nnet->ct.sysctl_events = nf_ct_events;\r\nnet->ct.sysctl_events_retry_timeout = nf_ct_events_retry_timeout;\r\nif (net_eq(net, &init_net)) {\r\nret = nf_ct_extend_register(&event_extend);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "nf_ct_event: Unable to register "\r\n"event extension.\n");\r\ngoto out_extend_register;\r\n}\r\n}\r\nret = nf_conntrack_event_init_sysctl(net);\r\nif (ret < 0)\r\ngoto out_sysctl;\r\nreturn 0;\r\nout_sysctl:\r\nif (net_eq(net, &init_net))\r\nnf_ct_extend_unregister(&event_extend);\r\nout_extend_register:\r\nreturn ret;\r\n}\r\nvoid nf_conntrack_ecache_fini(struct net *net)\r\n{\r\nnf_conntrack_event_fini_sysctl(net);\r\nif (net_eq(net, &init_net))\r\nnf_ct_extend_unregister(&event_extend);\r\n}
