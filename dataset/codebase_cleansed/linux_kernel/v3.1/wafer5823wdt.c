static void wafwdt_ping(void)\r\n{\r\nspin_lock(&wafwdt_lock);\r\ninb_p(wdt_stop);\r\ninb_p(wdt_start);\r\nspin_unlock(&wafwdt_lock);\r\n}\r\nstatic void wafwdt_start(void)\r\n{\r\noutb_p(timeout, wdt_start);\r\ninb_p(wdt_start);\r\n}\r\nstatic void wafwdt_stop(void)\r\n{\r\ninb_p(wdt_stop);\r\n}\r\nstatic ssize_t wafwdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nwafwdt_ping();\r\n}\r\nreturn count;\r\n}\r\nstatic long wafwdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint new_timeout;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = "Wafer 5823 WDT",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint options, retval = -EINVAL;\r\nif (get_user(options, p))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nwafwdt_start();\r\nretval = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nwafwdt_stop();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nwafwdt_ping();\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, p))\r\nreturn -EFAULT;\r\nif ((new_timeout < 1) || (new_timeout > 255))\r\nreturn -EINVAL;\r\ntimeout = new_timeout;\r\nwafwdt_stop();\r\nwafwdt_start();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wafwdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &wafwdt_is_open))\r\nreturn -EBUSY;\r\nwafwdt_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wafwdt_close(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42)\r\nwafwdt_stop();\r\nelse {\r\nprintk(KERN_CRIT PFX\r\n"WDT device closed unexpectedly. WDT will not stop!\n");\r\nwafwdt_ping();\r\n}\r\nclear_bit(0, &wafwdt_is_open);\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int wafwdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwafwdt_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init wafwdt_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO\r\n"WDT driver for Wafer 5823 single board computer initialising.\n");\r\nif (timeout < 1 || timeout > 255) {\r\ntimeout = WD_TIMO;\r\nprintk(KERN_INFO PFX\r\n"timeout value must be 1 <= x <= 255, using %d\n",\r\ntimeout);\r\n}\r\nif (wdt_stop != wdt_start) {\r\nif (!request_region(wdt_stop, 1, "Wafer 5823 WDT")) {\r\nprintk(KERN_ERR PFX\r\n"I/O address 0x%04x already in use\n",\r\nwdt_stop);\r\nret = -EIO;\r\ngoto error;\r\n}\r\n}\r\nif (!request_region(wdt_start, 1, "Wafer 5823 WDT")) {\r\nprintk(KERN_ERR PFX "I/O address 0x%04x already in use\n",\r\nwdt_start);\r\nret = -EIO;\r\ngoto error2;\r\n}\r\nret = register_reboot_notifier(&wafwdt_notifier);\r\nif (ret != 0) {\r\nprintk(KERN_ERR PFX\r\n"cannot register reboot notifier (err=%d)\n", ret);\r\ngoto error3;\r\n}\r\nret = misc_register(&wafwdt_miscdev);\r\nif (ret != 0) {\r\nprintk(KERN_ERR PFX\r\n"cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto error4;\r\n}\r\nprintk(KERN_INFO PFX "initialized. timeout=%d sec (nowayout=%d)\n",\r\ntimeout, nowayout);\r\nreturn ret;\r\nerror4:\r\nunregister_reboot_notifier(&wafwdt_notifier);\r\nerror3:\r\nrelease_region(wdt_start, 1);\r\nerror2:\r\nif (wdt_stop != wdt_start)\r\nrelease_region(wdt_stop, 1);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void __exit wafwdt_exit(void)\r\n{\r\nmisc_deregister(&wafwdt_miscdev);\r\nunregister_reboot_notifier(&wafwdt_notifier);\r\nif (wdt_stop != wdt_start)\r\nrelease_region(wdt_stop, 1);\r\nrelease_region(wdt_start, 1);\r\n}
