static int __devinit cb_pcimdda_driver_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id\r\n*ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, cb_pcimdda_driver.driver_name);\r\n}\r\nstatic void __devexit cb_pcimdda_driver_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init cb_pcimdda_driver_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&cb_pcimdda_driver);\r\nif (retval < 0)\r\nreturn retval;\r\ncb_pcimdda_driver_pci_driver.name =\r\n(char *)cb_pcimdda_driver.driver_name;\r\nreturn pci_register_driver(&cb_pcimdda_driver_pci_driver);\r\n}\r\nstatic void __exit cb_pcimdda_driver_cleanup_module(void)\r\n{\r\npci_unregister_driver(&cb_pcimdda_driver_pci_driver);\r\ncomedi_driver_unregister(&cb_pcimdda_driver);\r\n}\r\nstatic inline unsigned int figure_out_maxdata(int bits)\r\n{\r\nreturn ((unsigned int)1 << bits) - 1;\r\n}\r\nstatic int attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint err;\r\nif (alloc_private(dev, sizeof(struct board_private_struct)) < 0)\r\nreturn -ENOMEM;\r\nerr = probe(dev, it);\r\nif (err)\r\nreturn err;\r\nprintk("comedi%d: %s: ", dev->minor, thisboard->name);\r\ndev->board_name = thisboard->name;\r\nif (alloc_subdevices(dev, 2) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = thisboard->ao_chans;\r\ns->maxdata = figure_out_maxdata(thisboard->ao_bits);\r\nif (it->options[2])\r\ns->range_table = &range_bipolar10;\r\nelse\r\ns->range_table = &range_bipolar5;\r\ns->insn_write = &ao_winsn;\r\ns->insn_read = &ao_rinsn;\r\ns = dev->subdevices + 1;\r\nif (thisboard->dio_chans) {\r\nswitch (thisboard->dio_method) {\r\ncase DIO_8255:\r\nsubdev_8255_init(dev, s, NULL, devpriv->dio_registers);\r\ndevpriv->attached_to_8255 = 1;\r\nbreak;\r\ncase DIO_INTERNAL:\r\ndefault:\r\nprintk("DIO_INTERNAL not implemented yet!\n");\r\nreturn -ENXIO;\r\nbreak;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ndevpriv->attached_successfully = 1;\r\nprintk("attached\n");\r\nreturn 1;\r\n}\r\nstatic int detach(struct comedi_device *dev)\r\n{\r\nif (devpriv) {\r\nif (dev->subdevices && devpriv->attached_to_8255) {\r\nsubdev_8255_cleanup(dev, dev->subdevices + 2);\r\ndevpriv->attached_to_8255 = 0;\r\n}\r\nif (devpriv->pci_dev) {\r\nif (devpriv->registers)\r\ncomedi_pci_disable(devpriv->pci_dev);\r\npci_dev_put(devpriv->pci_dev);\r\n}\r\nif (devpriv->attached_successfully && thisboard)\r\nprintk("comedi%d: %s: detached\n", dev->minor,\r\nthisboard->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nunsigned long offset = devpriv->registers + chan * 2;\r\nfor (i = 0; i < insn->n; i++) {\r\noutb((char)(data[i] & 0x00ff), offset);\r\noutb((char)(data[i] >> 8 & 0x00ff), offset + 1);\r\ndevpriv->ao_readback[chan] = data[i];\r\n}\r\nreturn i;\r\n}\r\nstatic int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++) {\r\ninw(devpriv->registers + chan * 2);\r\ndata[i] = devpriv->ao_readback[chan];\r\n}\r\nreturn i;\r\n}\r\nstatic int probe(struct comedi_device *dev, const struct comedi_devconfig *it)\r\n{\r\nstruct pci_dev *pcidev = NULL;\r\nint index;\r\nunsigned long registers;\r\nfor_each_pci_dev(pcidev) {\r\nif (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)\r\ncontinue;\r\nfor (index = 0; index < ARRAY_SIZE(boards); index++) {\r\nif (boards[index].device_id != pcidev->device)\r\ncontinue;\r\nif (it->options[0] || it->options[1]) {\r\nif (pcidev->bus->number != it->options[0] ||\r\nPCI_SLOT(pcidev->devfn) != it->options[1]) {\r\ncontinue;\r\n}\r\n}\r\ndevpriv->pci_dev = pcidev;\r\ndev->board_ptr = boards + index;\r\nif (comedi_pci_enable(pcidev, thisboard->name)) {\r\nprintk\r\n("cb_pcimdda: Failed to enable PCI device and request regions\n");\r\nreturn -EIO;\r\n}\r\nregisters =\r\npci_resource_start(devpriv->pci_dev,\r\nREGS_BADRINDEX);\r\ndevpriv->registers = registers;\r\ndevpriv->dio_registers\r\n= devpriv->registers + thisboard->dio_offset;\r\nreturn 0;\r\n}\r\n}\r\nprintk("cb_pcimdda: No supported ComputerBoards/MeasurementComputing "\r\n"card found at the requested position\n");\r\nreturn -ENODEV;\r\n}
