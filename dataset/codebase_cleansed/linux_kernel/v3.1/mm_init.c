void mminit_verify_zonelist(void)\r\n{\r\nint nid;\r\nif (mminit_loglevel < MMINIT_VERIFY)\r\nreturn;\r\nfor_each_online_node(nid) {\r\npg_data_t *pgdat = NODE_DATA(nid);\r\nstruct zone *zone;\r\nstruct zoneref *z;\r\nstruct zonelist *zonelist;\r\nint i, listid, zoneid;\r\nBUG_ON(MAX_ZONELISTS > 2);\r\nfor (i = 0; i < MAX_ZONELISTS * MAX_NR_ZONES; i++) {\r\nzoneid = i % MAX_NR_ZONES;\r\nlistid = i / MAX_NR_ZONES;\r\nzonelist = &pgdat->node_zonelists[listid];\r\nzone = &pgdat->node_zones[zoneid];\r\nif (!populated_zone(zone))\r\ncontinue;\r\nprintk(KERN_DEBUG "mminit::zonelist %s %d:%s = ",\r\nlistid > 0 ? "thisnode" : "general", nid,\r\nzone->name);\r\nfor_each_zone_zonelist(zone, z, zonelist, zoneid) {\r\n#ifdef CONFIG_NUMA\r\nprintk(KERN_CONT "%d:%s ",\r\nzone->node, zone->name);\r\n#else\r\nprintk(KERN_CONT "0:%s ", zone->name);\r\n#endif\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\n}\r\n}\r\nvoid __init mminit_verify_pageflags_layout(void)\r\n{\r\nint shift, width;\r\nunsigned long or_mask, add_mask;\r\nshift = 8 * sizeof(unsigned long);\r\nwidth = shift - SECTIONS_WIDTH - NODES_WIDTH - ZONES_WIDTH;\r\nmminit_dprintk(MMINIT_TRACE, "pageflags_layout_widths",\r\n"Section %d Node %d Zone %d Flags %d\n",\r\nSECTIONS_WIDTH,\r\nNODES_WIDTH,\r\nZONES_WIDTH,\r\nNR_PAGEFLAGS);\r\nmminit_dprintk(MMINIT_TRACE, "pageflags_layout_shifts",\r\n"Section %d Node %d Zone %d\n",\r\nSECTIONS_SHIFT,\r\nNODES_SHIFT,\r\nZONES_SHIFT);\r\nmminit_dprintk(MMINIT_TRACE, "pageflags_layout_offsets",\r\n"Section %lu Node %lu Zone %lu\n",\r\n(unsigned long)SECTIONS_PGSHIFT,\r\n(unsigned long)NODES_PGSHIFT,\r\n(unsigned long)ZONES_PGSHIFT);\r\nmminit_dprintk(MMINIT_TRACE, "pageflags_layout_zoneid",\r\n"Zone ID: %lu -> %lu\n",\r\n(unsigned long)ZONEID_PGOFF,\r\n(unsigned long)(ZONEID_PGOFF + ZONEID_SHIFT));\r\nmminit_dprintk(MMINIT_TRACE, "pageflags_layout_usage",\r\n"location: %d -> %d unused %d -> %d flags %d -> %d\n",\r\nshift, width, width, NR_PAGEFLAGS, NR_PAGEFLAGS, 0);\r\n#ifdef NODE_NOT_IN_PAGE_FLAGS\r\nmminit_dprintk(MMINIT_TRACE, "pageflags_layout_nodeflags",\r\n"Node not in page flags");\r\n#endif\r\nif (SECTIONS_WIDTH) {\r\nshift -= SECTIONS_WIDTH;\r\nBUG_ON(shift != SECTIONS_PGSHIFT);\r\n}\r\nif (NODES_WIDTH) {\r\nshift -= NODES_WIDTH;\r\nBUG_ON(shift != NODES_PGSHIFT);\r\n}\r\nif (ZONES_WIDTH) {\r\nshift -= ZONES_WIDTH;\r\nBUG_ON(shift != ZONES_PGSHIFT);\r\n}\r\nor_mask = (ZONES_MASK << ZONES_PGSHIFT) |\r\n(NODES_MASK << NODES_PGSHIFT) |\r\n(SECTIONS_MASK << SECTIONS_PGSHIFT);\r\nadd_mask = (ZONES_MASK << ZONES_PGSHIFT) +\r\n(NODES_MASK << NODES_PGSHIFT) +\r\n(SECTIONS_MASK << SECTIONS_PGSHIFT);\r\nBUG_ON(or_mask != add_mask);\r\n}\r\nvoid __meminit mminit_verify_page_links(struct page *page, enum zone_type zone,\r\nunsigned long nid, unsigned long pfn)\r\n{\r\nBUG_ON(page_to_nid(page) != nid);\r\nBUG_ON(page_zonenum(page) != zone);\r\nBUG_ON(page_to_pfn(page) != pfn);\r\n}\r\nstatic __init int set_mminit_loglevel(char *str)\r\n{\r\nget_option(&str, &mminit_loglevel);\r\nreturn 0;\r\n}\r\nstatic int __init mm_sysfs_init(void)\r\n{\r\nmm_kobj = kobject_create_and_add("mm", kernel_kobj);\r\nif (!mm_kobj)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
