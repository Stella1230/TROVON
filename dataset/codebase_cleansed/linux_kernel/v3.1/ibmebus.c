static void *ibmebus_alloc_coherent(struct device *dev,\r\nsize_t size,\r\ndma_addr_t *dma_handle,\r\ngfp_t flag)\r\n{\r\nvoid *mem;\r\nmem = kmalloc(size, flag);\r\n*dma_handle = (dma_addr_t)mem;\r\nreturn mem;\r\n}\r\nstatic void ibmebus_free_coherent(struct device *dev,\r\nsize_t size, void *vaddr,\r\ndma_addr_t dma_handle)\r\n{\r\nkfree(vaddr);\r\n}\r\nstatic dma_addr_t ibmebus_map_page(struct device *dev,\r\nstruct page *page,\r\nunsigned long offset,\r\nsize_t size,\r\nenum dma_data_direction direction,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn (dma_addr_t)(page_address(page) + offset);\r\n}\r\nstatic void ibmebus_unmap_page(struct device *dev,\r\ndma_addr_t dma_addr,\r\nsize_t size,\r\nenum dma_data_direction direction,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn;\r\n}\r\nstatic int ibmebus_map_sg(struct device *dev,\r\nstruct scatterlist *sgl,\r\nint nents, enum dma_data_direction direction,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nfor_each_sg(sgl, sg, nents, i) {\r\nsg->dma_address = (dma_addr_t) sg_virt(sg);\r\nsg->dma_length = sg->length;\r\n}\r\nreturn nents;\r\n}\r\nstatic void ibmebus_unmap_sg(struct device *dev,\r\nstruct scatterlist *sg,\r\nint nents, enum dma_data_direction direction,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn;\r\n}\r\nstatic int ibmebus_dma_supported(struct device *dev, u64 mask)\r\n{\r\nreturn 1;\r\n}\r\nstatic int ibmebus_match_path(struct device *dev, void *data)\r\n{\r\nstruct device_node *dn = to_platform_device(dev)->dev.of_node;\r\nreturn (dn->full_name &&\r\n(strcasecmp((char *)data, dn->full_name) == 0));\r\n}\r\nstatic int ibmebus_match_node(struct device *dev, void *data)\r\n{\r\nreturn to_platform_device(dev)->dev.of_node == data;\r\n}\r\nstatic int ibmebus_create_device(struct device_node *dn)\r\n{\r\nstruct platform_device *dev;\r\nint ret;\r\ndev = of_device_alloc(dn, NULL, &ibmebus_bus_device);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->dev.bus = &ibmebus_bus_type;\r\ndev->dev.archdata.dma_ops = &ibmebus_dma_ops;\r\nret = of_device_add(dev);\r\nif (ret)\r\nplatform_device_put(dev);\r\nreturn ret;\r\n}\r\nstatic int ibmebus_create_devices(const struct of_device_id *matches)\r\n{\r\nstruct device_node *root, *child;\r\nint ret = 0;\r\nroot = of_find_node_by_path("/");\r\nfor_each_child_of_node(root, child) {\r\nif (!of_match_node(matches, child))\r\ncontinue;\r\nif (bus_find_device(&ibmebus_bus_type, NULL, child,\r\nibmebus_match_node))\r\ncontinue;\r\nret = ibmebus_create_device(child);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: failed to create device (%i)",\r\n__func__, ret);\r\nof_node_put(child);\r\nbreak;\r\n}\r\n}\r\nof_node_put(root);\r\nreturn ret;\r\n}\r\nint ibmebus_register_driver(struct of_platform_driver *drv)\r\n{\r\nibmebus_create_devices(drv->driver.of_match_table);\r\ndrv->driver.bus = &ibmebus_bus_type;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid ibmebus_unregister_driver(struct of_platform_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nint ibmebus_request_irq(u32 ist, irq_handler_t handler,\r\nunsigned long irq_flags, const char *devname,\r\nvoid *dev_id)\r\n{\r\nunsigned int irq = irq_create_mapping(NULL, ist);\r\nif (irq == NO_IRQ)\r\nreturn -EINVAL;\r\nreturn request_irq(irq, handler, irq_flags, devname, dev_id);\r\n}\r\nvoid ibmebus_free_irq(u32 ist, void *dev_id)\r\n{\r\nunsigned int irq = irq_find_mapping(NULL, ist);\r\nfree_irq(irq, dev_id);\r\nirq_dispose_mapping(irq);\r\n}\r\nstatic char *ibmebus_chomp(const char *in, size_t count)\r\n{\r\nchar *out = kmalloc(count + 1, GFP_KERNEL);\r\nif (!out)\r\nreturn NULL;\r\nmemcpy(out, in, count);\r\nout[count] = '\0';\r\nif (out[count - 1] == '\n')\r\nout[count - 1] = '\0';\r\nreturn out;\r\n}\r\nstatic ssize_t ibmebus_store_probe(struct bus_type *bus,\r\nconst char *buf, size_t count)\r\n{\r\nstruct device_node *dn = NULL;\r\nchar *path;\r\nssize_t rc = 0;\r\npath = ibmebus_chomp(buf, count);\r\nif (!path)\r\nreturn -ENOMEM;\r\nif (bus_find_device(&ibmebus_bus_type, NULL, path,\r\nibmebus_match_path)) {\r\nprintk(KERN_WARNING "%s: %s has already been probed\n",\r\n__func__, path);\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\nif ((dn = of_find_node_by_path(path))) {\r\nrc = ibmebus_create_device(dn);\r\nof_node_put(dn);\r\n} else {\r\nprintk(KERN_WARNING "%s: no such device node: %s\n",\r\n__func__, path);\r\nrc = -ENODEV;\r\n}\r\nout:\r\nkfree(path);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic ssize_t ibmebus_store_remove(struct bus_type *bus,\r\nconst char *buf, size_t count)\r\n{\r\nstruct device *dev;\r\nchar *path;\r\npath = ibmebus_chomp(buf, count);\r\nif (!path)\r\nreturn -ENOMEM;\r\nif ((dev = bus_find_device(&ibmebus_bus_type, NULL, path,\r\nibmebus_match_path))) {\r\nof_device_unregister(to_platform_device(dev));\r\nkfree(path);\r\nreturn count;\r\n} else {\r\nprintk(KERN_WARNING "%s: %s not on the bus\n",\r\n__func__, path);\r\nkfree(path);\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int ibmebus_bus_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nconst struct of_device_id *matches = drv->of_match_table;\r\nif (!matches)\r\nreturn 0;\r\nreturn of_match_device(matches, dev) != NULL;\r\n}\r\nstatic int ibmebus_bus_device_probe(struct device *dev)\r\n{\r\nint error = -ENODEV;\r\nstruct of_platform_driver *drv;\r\nstruct platform_device *of_dev;\r\nconst struct of_device_id *match;\r\ndrv = to_of_platform_driver(dev->driver);\r\nof_dev = to_platform_device(dev);\r\nif (!drv->probe)\r\nreturn error;\r\nof_dev_get(of_dev);\r\nmatch = of_match_device(drv->driver.of_match_table, dev);\r\nif (match)\r\nerror = drv->probe(of_dev, match);\r\nif (error)\r\nof_dev_put(of_dev);\r\nreturn error;\r\n}\r\nstatic int ibmebus_bus_device_remove(struct device *dev)\r\n{\r\nstruct platform_device *of_dev = to_platform_device(dev);\r\nstruct of_platform_driver *drv = to_of_platform_driver(dev->driver);\r\nif (dev->driver && drv->remove)\r\ndrv->remove(of_dev);\r\nreturn 0;\r\n}\r\nstatic void ibmebus_bus_device_shutdown(struct device *dev)\r\n{\r\nstruct platform_device *of_dev = to_platform_device(dev);\r\nstruct of_platform_driver *drv = to_of_platform_driver(dev->driver);\r\nif (dev->driver && drv->shutdown)\r\ndrv->shutdown(of_dev);\r\n}\r\nstatic ssize_t devspec_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *ofdev;\r\nofdev = to_platform_device(dev);\r\nreturn sprintf(buf, "%s\n", ofdev->dev.of_node->full_name);\r\n}\r\nstatic ssize_t name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *ofdev;\r\nofdev = to_platform_device(dev);\r\nreturn sprintf(buf, "%s\n", ofdev->dev.of_node->name);\r\n}\r\nstatic ssize_t modalias_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t len = of_device_get_modalias(dev, buf, PAGE_SIZE - 2);\r\nbuf[len] = '\n';\r\nbuf[len+1] = 0;\r\nreturn len+1;\r\n}\r\nstatic int ibmebus_bus_legacy_suspend(struct device *dev, pm_message_t mesg)\r\n{\r\nstruct platform_device *of_dev = to_platform_device(dev);\r\nstruct of_platform_driver *drv = to_of_platform_driver(dev->driver);\r\nint ret = 0;\r\nif (dev->driver && drv->suspend)\r\nret = drv->suspend(of_dev, mesg);\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_legacy_resume(struct device *dev)\r\n{\r\nstruct platform_device *of_dev = to_platform_device(dev);\r\nstruct of_platform_driver *drv = to_of_platform_driver(dev->driver);\r\nint ret = 0;\r\nif (dev->driver && drv->resume)\r\nret = drv->resume(of_dev);\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_prepare(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (drv && drv->pm && drv->pm->prepare)\r\nret = drv->pm->prepare(dev);\r\nreturn ret;\r\n}\r\nstatic void ibmebus_bus_pm_complete(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nif (drv && drv->pm && drv->pm->complete)\r\ndrv->pm->complete(dev);\r\n}\r\nstatic int ibmebus_bus_pm_suspend(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->suspend)\r\nret = drv->pm->suspend(dev);\r\n} else {\r\nret = ibmebus_bus_legacy_suspend(dev, PMSG_SUSPEND);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_suspend_noirq(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->suspend_noirq)\r\nret = drv->pm->suspend_noirq(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_resume(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->resume)\r\nret = drv->pm->resume(dev);\r\n} else {\r\nret = ibmebus_bus_legacy_resume(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_resume_noirq(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->resume_noirq)\r\nret = drv->pm->resume_noirq(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_freeze(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->freeze)\r\nret = drv->pm->freeze(dev);\r\n} else {\r\nret = ibmebus_bus_legacy_suspend(dev, PMSG_FREEZE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_freeze_noirq(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->freeze_noirq)\r\nret = drv->pm->freeze_noirq(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_thaw(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->thaw)\r\nret = drv->pm->thaw(dev);\r\n} else {\r\nret = ibmebus_bus_legacy_resume(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_thaw_noirq(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->thaw_noirq)\r\nret = drv->pm->thaw_noirq(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_poweroff(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->poweroff)\r\nret = drv->pm->poweroff(dev);\r\n} else {\r\nret = ibmebus_bus_legacy_suspend(dev, PMSG_HIBERNATE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_poweroff_noirq(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->poweroff_noirq)\r\nret = drv->pm->poweroff_noirq(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_restore(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->restore)\r\nret = drv->pm->restore(dev);\r\n} else {\r\nret = ibmebus_bus_legacy_resume(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ibmebus_bus_pm_restore_noirq(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint ret = 0;\r\nif (!drv)\r\nreturn 0;\r\nif (drv->pm) {\r\nif (drv->pm->restore_noirq)\r\nret = drv->pm->restore_noirq(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init ibmebus_bus_init(void)\r\n{\r\nint err;\r\nprintk(KERN_INFO "IBM eBus Device Driver\n");\r\nerr = bus_register(&ibmebus_bus_type);\r\nif (err) {\r\nprintk(KERN_ERR "%s: failed to register IBM eBus.\n",\r\n__func__);\r\nreturn err;\r\n}\r\nerr = device_register(&ibmebus_bus_device);\r\nif (err) {\r\nprintk(KERN_WARNING "%s: device_register returned %i\n",\r\n__func__, err);\r\nbus_unregister(&ibmebus_bus_type);\r\nreturn err;\r\n}\r\nerr = ibmebus_create_devices(ibmebus_matches);\r\nif (err) {\r\ndevice_unregister(&ibmebus_bus_device);\r\nbus_unregister(&ibmebus_bus_type);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
