static cycle_t cksrc_dc21285_read(struct clocksource *cs)\r\n{\r\nreturn cs->mask - *CSR_TIMER2_VALUE;\r\n}\r\nstatic int cksrc_dc21285_enable(struct clocksource *cs)\r\n{\r\n*CSR_TIMER2_LOAD = cs->mask;\r\n*CSR_TIMER2_CLR = 0;\r\n*CSR_TIMER2_CNTL = TIMER_CNTL_ENABLE | TIMER_CNTL_DIV16;\r\nreturn 0;\r\n}\r\nstatic void cksrc_dc21285_disable(struct clocksource *cs)\r\n{\r\n*CSR_TIMER2_CNTL = 0;\r\n}\r\nstatic void ckevt_dc21285_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *c)\r\n{\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_RESUME:\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\n*CSR_TIMER1_CLR = 0;\r\n*CSR_TIMER1_LOAD = (mem_fclk_21285 + 8 * HZ) / (16 * HZ);\r\n*CSR_TIMER1_CNTL = TIMER_CNTL_ENABLE | TIMER_CNTL_AUTORELOAD |\r\nTIMER_CNTL_DIV16;\r\nbreak;\r\ndefault:\r\n*CSR_TIMER1_CNTL = 0;\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t timer1_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *ce = dev_id;\r\n*CSR_TIMER1_CLR = 0;\r\nce->event_handler(ce);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init footbridge_timer_init(void)\r\n{\r\nstruct clock_event_device *ce = &ckevt_dc21285;\r\nclocksource_register_hz(&cksrc_dc21285, (mem_fclk_21285 + 8) / 16);\r\nsetup_irq(ce->irq, &footbridge_timer_irq);\r\nclockevents_calc_mult_shift(ce, mem_fclk_21285, 5);\r\nce->max_delta_ns = clockevent_delta2ns(0xffffff, ce);\r\nce->min_delta_ns = clockevent_delta2ns(0x000004, ce);\r\nce->cpumask = cpumask_of(smp_processor_id());\r\nclockevents_register_device(ce);\r\n}
