static int flags_by_mnt(int mnt_flags)\r\n{\r\nint flags = 0;\r\nif (mnt_flags & MNT_READONLY)\r\nflags |= ST_RDONLY;\r\nif (mnt_flags & MNT_NOSUID)\r\nflags |= ST_NOSUID;\r\nif (mnt_flags & MNT_NODEV)\r\nflags |= ST_NODEV;\r\nif (mnt_flags & MNT_NOEXEC)\r\nflags |= ST_NOEXEC;\r\nif (mnt_flags & MNT_NOATIME)\r\nflags |= ST_NOATIME;\r\nif (mnt_flags & MNT_NODIRATIME)\r\nflags |= ST_NODIRATIME;\r\nif (mnt_flags & MNT_RELATIME)\r\nflags |= ST_RELATIME;\r\nreturn flags;\r\n}\r\nstatic int flags_by_sb(int s_flags)\r\n{\r\nint flags = 0;\r\nif (s_flags & MS_SYNCHRONOUS)\r\nflags |= ST_SYNCHRONOUS;\r\nif (s_flags & MS_MANDLOCK)\r\nflags |= ST_MANDLOCK;\r\nreturn flags;\r\n}\r\nstatic int calculate_f_flags(struct vfsmount *mnt)\r\n{\r\nreturn ST_VALID | flags_by_mnt(mnt->mnt_flags) |\r\nflags_by_sb(mnt->mnt_sb->s_flags);\r\n}\r\nint statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)\r\n{\r\nint retval;\r\nif (!dentry->d_sb->s_op->statfs)\r\nreturn -ENOSYS;\r\nmemset(buf, 0, sizeof(*buf));\r\nretval = security_sb_statfs(dentry);\r\nif (retval)\r\nreturn retval;\r\nretval = dentry->d_sb->s_op->statfs(dentry, buf);\r\nif (retval == 0 && buf->f_frsize == 0)\r\nbuf->f_frsize = buf->f_bsize;\r\nreturn retval;\r\n}\r\nint vfs_statfs(struct path *path, struct kstatfs *buf)\r\n{\r\nint error;\r\nerror = statfs_by_dentry(path->dentry, buf);\r\nif (!error)\r\nbuf->f_flags = calculate_f_flags(path->mnt);\r\nreturn error;\r\n}\r\nint user_statfs(const char __user *pathname, struct kstatfs *st)\r\n{\r\nstruct path path;\r\nint error = user_path(pathname, &path);\r\nif (!error) {\r\nerror = vfs_statfs(&path, st);\r\npath_put(&path);\r\n}\r\nreturn error;\r\n}\r\nint fd_statfs(int fd, struct kstatfs *st)\r\n{\r\nstruct file *file = fget(fd);\r\nint error = -EBADF;\r\nif (file) {\r\nerror = vfs_statfs(&file->f_path, st);\r\nfput(file);\r\n}\r\nreturn error;\r\n}\r\nstatic int do_statfs_native(struct kstatfs *st, struct statfs __user *p)\r\n{\r\nstruct statfs buf;\r\nif (sizeof(buf) == sizeof(*st))\r\nmemcpy(&buf, st, sizeof(*st));\r\nelse {\r\nif (sizeof buf.f_blocks == 4) {\r\nif ((st->f_blocks | st->f_bfree | st->f_bavail |\r\nst->f_bsize | st->f_frsize) &\r\n0xffffffff00000000ULL)\r\nreturn -EOVERFLOW;\r\nif (st->f_files != -1 &&\r\n(st->f_files & 0xffffffff00000000ULL))\r\nreturn -EOVERFLOW;\r\nif (st->f_ffree != -1 &&\r\n(st->f_ffree & 0xffffffff00000000ULL))\r\nreturn -EOVERFLOW;\r\n}\r\nbuf.f_type = st->f_type;\r\nbuf.f_bsize = st->f_bsize;\r\nbuf.f_blocks = st->f_blocks;\r\nbuf.f_bfree = st->f_bfree;\r\nbuf.f_bavail = st->f_bavail;\r\nbuf.f_files = st->f_files;\r\nbuf.f_ffree = st->f_ffree;\r\nbuf.f_fsid = st->f_fsid;\r\nbuf.f_namelen = st->f_namelen;\r\nbuf.f_frsize = st->f_frsize;\r\nbuf.f_flags = st->f_flags;\r\nmemset(buf.f_spare, 0, sizeof(buf.f_spare));\r\n}\r\nif (copy_to_user(p, &buf, sizeof(buf)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int do_statfs64(struct kstatfs *st, struct statfs64 __user *p)\r\n{\r\nstruct statfs64 buf;\r\nif (sizeof(buf) == sizeof(*st))\r\nmemcpy(&buf, st, sizeof(*st));\r\nelse {\r\nbuf.f_type = st->f_type;\r\nbuf.f_bsize = st->f_bsize;\r\nbuf.f_blocks = st->f_blocks;\r\nbuf.f_bfree = st->f_bfree;\r\nbuf.f_bavail = st->f_bavail;\r\nbuf.f_files = st->f_files;\r\nbuf.f_ffree = st->f_ffree;\r\nbuf.f_fsid = st->f_fsid;\r\nbuf.f_namelen = st->f_namelen;\r\nbuf.f_frsize = st->f_frsize;\r\nbuf.f_flags = st->f_flags;\r\nmemset(buf.f_spare, 0, sizeof(buf.f_spare));\r\n}\r\nif (copy_to_user(p, &buf, sizeof(buf)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}
