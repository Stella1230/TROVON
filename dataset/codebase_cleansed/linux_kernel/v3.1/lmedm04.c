static int lme2510_bulk_write(struct usb_device *dev,\r\nu8 *snd, int len, u8 pipe)\r\n{\r\nint ret, actual_l;\r\nret = usb_bulk_msg(dev, usb_sndbulkpipe(dev, pipe),\r\nsnd, len , &actual_l, 100);\r\nreturn ret;\r\n}\r\nstatic int lme2510_bulk_read(struct usb_device *dev,\r\nu8 *rev, int len, u8 pipe)\r\n{\r\nint ret, actual_l;\r\nret = usb_bulk_msg(dev, usb_rcvbulkpipe(dev, pipe),\r\nrev, len , &actual_l, 200);\r\nreturn ret;\r\n}\r\nstatic int lme2510_usb_talk(struct dvb_usb_device *d,\r\nu8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nu8 *buff;\r\nint ret = 0;\r\nif (st->usb_buffer == NULL) {\r\nst->usb_buffer = kmalloc(512, GFP_KERNEL);\r\nif (st->usb_buffer == NULL) {\r\ninfo("MEM Error no memory");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nbuff = st->usb_buffer;\r\nret = mutex_lock_interruptible(&d->usb_mutex);\r\nif (ret < 0)\r\nreturn -EAGAIN;\r\nmemcpy(buff, wbuf, (wlen > 512) ? 512 : wlen);\r\nret |= usb_clear_halt(d->udev, usb_sndbulkpipe(d->udev, 0x01));\r\nret |= lme2510_bulk_write(d->udev, buff, wlen , 0x01);\r\nmsleep(10);\r\nret |= usb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, 0x01));\r\nret |= lme2510_bulk_read(d->udev, buff, (rlen > 512) ?\r\n512 : rlen , 0x01);\r\nif (rlen > 0)\r\nmemcpy(rbuf, buff, rlen);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int lme2510_stream_restart(struct dvb_usb_device *d)\r\n{\r\nstatic u8 stream_on[] = LME_ST_ON_W;\r\nint ret;\r\nu8 rbuff[10];\r\nret = lme2510_usb_talk(d, stream_on, sizeof(stream_on),\r\nrbuff, sizeof(rbuff));\r\nreturn ret;\r\n}\r\nstatic int lme2510_enable_pid(struct dvb_usb_device *d, u8 index, u16 pid_out)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nstatic u8 pid_buff[] = LME_ZERO_PID;\r\nstatic u8 rbuf[1];\r\nu8 pid_no = index * 2;\r\nu8 pid_len = pid_no + 2;\r\nint ret = 0;\r\ndeb_info(1, "PID Setting Pid %04x", pid_out);\r\nif (st->pid_size == 0)\r\nret |= lme2510_stream_restart(d);\r\npid_buff[2] = pid_no;\r\npid_buff[3] = (u8)pid_out & 0xff;\r\npid_buff[4] = pid_no + 1;\r\npid_buff[5] = (u8)(pid_out >> 8);\r\nif (pid_len > st->pid_size)\r\nst->pid_size = pid_len;\r\npid_buff[7] = 0x80 + st->pid_size;\r\nret |= lme2510_usb_talk(d, pid_buff ,\r\nsizeof(pid_buff) , rbuf, sizeof(rbuf));\r\nif (st->stream_on)\r\nret |= lme2510_stream_restart(d);\r\nreturn ret;\r\n}\r\nstatic void lme2510_int_response(struct urb *lme_urb)\r\n{\r\nstruct dvb_usb_adapter *adap = lme_urb->context;\r\nstruct lme2510_state *st = adap->dev->priv;\r\nstatic u8 *ibuf, *rbuf;\r\nint i = 0, offset;\r\nu32 key;\r\nswitch (lme_urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ninfo("Error %x", lme_urb->status);\r\nbreak;\r\n}\r\nrbuf = (u8 *) lme_urb->transfer_buffer;\r\noffset = ((lme_urb->actual_length/8) > 4)\r\n? 4 : (lme_urb->actual_length/8) ;\r\nfor (i = 0; i < offset; ++i) {\r\nibuf = (u8 *)&rbuf[i*8];\r\ndeb_info(5, "INT O/S C =%02x C/O=%02x Type =%02x%02x",\r\noffset, i, ibuf[0], ibuf[1]);\r\nswitch (ibuf[0]) {\r\ncase 0xaa:\r\ndebug_data_snipet(1, "INT Remote data snipet", ibuf);\r\nif ((ibuf[4] + ibuf[5]) == 0xff) {\r\nkey = ibuf[5];\r\nkey += (ibuf[3] > 0)\r\n? (ibuf[3] ^ 0xff) << 8 : 0;\r\nkey += (ibuf[2] ^ 0xff) << 16;\r\ndeb_info(1, "INT Key =%08x", key);\r\nif (adap->dev->rc_dev != NULL)\r\nrc_keydown(adap->dev->rc_dev, key, 0);\r\n}\r\nbreak;\r\ncase 0xbb:\r\nswitch (st->tuner_config) {\r\ncase TUNER_LG:\r\nif (ibuf[2] > 0)\r\nst->signal_lock = ibuf[2];\r\nst->signal_level = ibuf[4];\r\nst->signal_sn = ibuf[3];\r\nst->time_key = ibuf[7];\r\nbreak;\r\ncase TUNER_S7395:\r\ncase TUNER_S0194:\r\nif (ibuf[1] == 0x03) {\r\nif (ibuf[2] > 1)\r\nst->signal_lock = ibuf[2];\r\nst->signal_level = ibuf[3];\r\nst->signal_sn = ibuf[4];\r\n} else {\r\nst->signal_level = ibuf[4];\r\nst->signal_sn = ibuf[5];\r\nst->signal_lock =\r\n(st->signal_lock & 0xf7) +\r\n((ibuf[2] & 0x01) << 0x03);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndebug_data_snipet(5, "INT Remote data snipet in", ibuf);\r\nbreak;\r\ncase 0xcc:\r\ndebug_data_snipet(1, "INT Control data snipet", ibuf);\r\nbreak;\r\ndefault:\r\ndebug_data_snipet(1, "INT Unknown data snipet", ibuf);\r\nbreak;\r\n}\r\n}\r\nusb_submit_urb(lme_urb, GFP_ATOMIC);\r\n}\r\nstatic int lme2510_int_read(struct dvb_usb_adapter *adap)\r\n{\r\nstruct lme2510_state *lme_int = adap->dev->priv;\r\nlme_int->lme_urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (lme_int->lme_urb == NULL)\r\nreturn -ENOMEM;\r\nlme_int->buffer = usb_alloc_coherent(adap->dev->udev, 5000, GFP_ATOMIC,\r\n&lme_int->lme_urb->transfer_dma);\r\nif (lme_int->buffer == NULL)\r\nreturn -ENOMEM;\r\nusb_fill_int_urb(lme_int->lme_urb,\r\nadap->dev->udev,\r\nusb_rcvintpipe(adap->dev->udev, 0xa),\r\nlme_int->buffer,\r\n4096,\r\nlme2510_int_response,\r\nadap,\r\n11);\r\nlme_int->lme_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_submit_urb(lme_int->lme_urb, GFP_ATOMIC);\r\ninfo("INT Interrupt Service Started");\r\nreturn 0;\r\n}\r\nstatic int lme2510_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct lme2510_state *st = adap->dev->priv;\r\nstatic u8 clear_pid_reg[] = LME_CLEAR_PID;\r\nstatic u8 rbuf[1];\r\nint ret;\r\ndeb_info(1, "PID Clearing Filter");\r\nret = mutex_lock_interruptible(&adap->dev->i2c_mutex);\r\nif (ret < 0)\r\nreturn -EAGAIN;\r\nif (!onoff)\r\nret |= lme2510_usb_talk(adap->dev, clear_pid_reg,\r\nsizeof(clear_pid_reg), rbuf, sizeof(rbuf));\r\nst->pid_size = 0;\r\nmutex_unlock(&adap->dev->i2c_mutex);\r\nreturn 0;\r\n}\r\nstatic int lme2510_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\r\nint onoff)\r\n{\r\nint ret = 0;\r\ndeb_info(3, "%s PID=%04x Index=%04x onoff=%02x", __func__,\r\npid, index, onoff);\r\nif (onoff)\r\nif (!pid_filter) {\r\nret = mutex_lock_interruptible(&adap->dev->i2c_mutex);\r\nif (ret < 0)\r\nreturn -EAGAIN;\r\nret |= lme2510_enable_pid(adap->dev, index, pid);\r\nmutex_unlock(&adap->dev->i2c_mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic int lme2510_return_status(struct usb_device *dev)\r\n{\r\nint ret = 0;\r\nu8 *data;\r\ndata = kzalloc(10, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nret |= usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n0x06, 0x80, 0x0302, 0x00, data, 0x0006, 200);\r\ninfo("Firmware Status: %x (%x)", ret , data[2]);\r\nret = (ret < 0) ? -ENODEV : data[2];\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int lme2510_msg(struct dvb_usb_device *d,\r\nu8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nint ret = 0;\r\nstruct lme2510_state *st = d->priv;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (st->i2c_talk_onoff == 1) {\r\nret = lme2510_usb_talk(d, wbuf, wlen, rbuf, rlen);\r\nswitch (st->tuner_config) {\r\ncase TUNER_LG:\r\nif (wbuf[2] == 0x1c) {\r\nif (wbuf[3] == 0x0e) {\r\nst->signal_lock = rbuf[1];\r\nif ((st->stream_on & 1) &&\r\n(st->signal_lock & 0x10)) {\r\nlme2510_stream_restart(d);\r\nst->i2c_talk_onoff = 0;\r\n}\r\nmsleep(80);\r\n}\r\n}\r\nbreak;\r\ncase TUNER_S7395:\r\nif (wbuf[2] == 0xd0) {\r\nif (wbuf[3] == 0x24) {\r\nst->signal_lock = rbuf[1];\r\nif ((st->stream_on & 1) &&\r\n(st->signal_lock & 0x8)) {\r\nlme2510_stream_restart(d);\r\nst->i2c_talk_onoff = 0;\r\n}\r\n}\r\nif ((wbuf[3] != 0x6) & (wbuf[3] != 0x5))\r\nmsleep(5);\r\n}\r\nbreak;\r\ncase TUNER_S0194:\r\nif (wbuf[2] == 0xd0) {\r\nif (wbuf[3] == 0x1b) {\r\nst->signal_lock = rbuf[1];\r\nif ((st->stream_on & 1) &&\r\n(st->signal_lock & 0x8)) {\r\nlme2510_stream_restart(d);\r\nst->i2c_talk_onoff = 0;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (st->tuner_config) {\r\ncase TUNER_LG:\r\nswitch (wbuf[3]) {\r\ncase 0x0e:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = st->signal_lock;\r\nbreak;\r\ncase 0x43:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = st->signal_level;\r\nbreak;\r\ncase 0x1c:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = st->signal_sn;\r\nbreak;\r\ncase 0x15:\r\ncase 0x16:\r\ncase 0x17:\r\ncase 0x18:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = 0x00;\r\nbreak;\r\ndefault:\r\nlme2510_usb_talk(d, wbuf, wlen, rbuf, rlen);\r\nst->i2c_talk_onoff = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase TUNER_S7395:\r\nswitch (wbuf[3]) {\r\ncase 0x10:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = (st->signal_level & 0x80)\r\n? 0 : (st->signal_level * 2);\r\nbreak;\r\ncase 0x2d:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = st->signal_sn;\r\nbreak;\r\ncase 0x24:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = st->signal_lock;\r\nbreak;\r\ncase 0x2e:\r\ncase 0x26:\r\ncase 0x27:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = 0x00;\r\nbreak;\r\ndefault:\r\nlme2510_usb_talk(d, wbuf, wlen, rbuf, rlen);\r\nst->i2c_talk_onoff = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase TUNER_S0194:\r\nswitch (wbuf[3]) {\r\ncase 0x18:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = (st->signal_level & 0x80)\r\n? 0 : (st->signal_level * 2);\r\nbreak;\r\ncase 0x24:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = st->signal_sn;\r\nbreak;\r\ncase 0x1b:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = st->signal_lock;\r\nbreak;\r\ncase 0x19:\r\ncase 0x25:\r\ncase 0x1e:\r\ncase 0x1d:\r\nrbuf[0] = 0x55;\r\nrbuf[1] = 0x00;\r\nbreak;\r\ndefault:\r\nlme2510_usb_talk(d, wbuf, wlen, rbuf, rlen);\r\nst->i2c_talk_onoff = 1;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndeb_info(4, "I2C From Interrupt Message out(%02x) in(%02x)",\r\nwbuf[3], rbuf[1]);\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int lme2510_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct lme2510_state *st = d->priv;\r\nstatic u8 obuf[64], ibuf[512];\r\nint i, read, read_o;\r\nu16 len;\r\nu8 gate = st->i2c_gate;\r\nif (gate == 0)\r\ngate = 5;\r\nif (num > 2)\r\nwarn("more than 2 i2c messages"\r\n"at a time is not handled yet. TODO.");\r\nfor (i = 0; i < num; i++) {\r\nread_o = 1 & (msg[i].flags & I2C_M_RD);\r\nread = i+1 < num && (msg[i+1].flags & I2C_M_RD);\r\nread |= read_o;\r\ngate = (msg[i].addr == st->i2c_tuner_addr)\r\n? (read) ? st->i2c_tuner_gate_r\r\n: st->i2c_tuner_gate_w\r\n: st->i2c_gate;\r\nobuf[0] = gate | (read << 7);\r\nif (gate == 5)\r\nobuf[1] = (read) ? 2 : msg[i].len + 1;\r\nelse\r\nobuf[1] = msg[i].len + read + 1;\r\nobuf[2] = msg[i].addr;\r\nif (read) {\r\nif (read_o)\r\nlen = 3;\r\nelse {\r\nmemcpy(&obuf[3], msg[i].buf, msg[i].len);\r\nobuf[msg[i].len+3] = msg[i+1].len;\r\nlen = msg[i].len+4;\r\n}\r\n} else {\r\nmemcpy(&obuf[3], msg[i].buf, msg[i].len);\r\nlen = msg[i].len+3;\r\n}\r\nif (lme2510_msg(d, obuf, len, ibuf, 512) < 0) {\r\ndeb_info(1, "i2c transfer failed.");\r\nreturn -EAGAIN;\r\n}\r\nif (read) {\r\nif (read_o)\r\nmemcpy(msg[i].buf, &ibuf[1], msg[i].len);\r\nelse {\r\nmemcpy(msg[i+1].buf, &ibuf[1], msg[i+1].len);\r\ni++;\r\n}\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic u32 lme2510_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int lme2510_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\n*cold = 0;\r\nreturn 0;\r\n}\r\nstatic int lme2510_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct lme2510_state *st = adap->dev->priv;\r\nstatic u8 clear_reg_3[] = LME_CLEAR_PID;\r\nstatic u8 rbuf[1];\r\nint ret = 0, rlen = sizeof(rbuf);\r\ndeb_info(1, "STM (%02x)", onoff);\r\nif (onoff == 1)\r\nst->stream_on = 1;\r\nelse {\r\ndeb_info(1, "STM Steam Off");\r\nif (mutex_lock_interruptible(&adap->dev->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nret = lme2510_usb_talk(adap->dev, clear_reg_3,\r\nsizeof(clear_reg_3), rbuf, rlen);\r\nst->stream_on = 0;\r\nst->i2c_talk_onoff = 1;\r\nmutex_unlock(&adap->dev->i2c_mutex);\r\n}\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic u8 check_sum(u8 *p, u8 len)\r\n{\r\nu8 sum = 0;\r\nwhile (len--)\r\nsum += *p++;\r\nreturn sum;\r\n}\r\nstatic int lme2510_download_firmware(struct usb_device *dev,\r\nconst struct firmware *fw)\r\n{\r\nint ret = 0;\r\nu8 *data;\r\nu16 j, wlen, len_in, start, end;\r\nu8 packet_size, dlen, i;\r\nu8 *fw_data;\r\npacket_size = 0x31;\r\nlen_in = 1;\r\ndata = kzalloc(512, GFP_KERNEL);\r\nif (!data) {\r\ninfo("FRM Could not start Firmware Download (Buffer allocation failed)");\r\nreturn -ENOMEM;\r\n}\r\ninfo("FRM Starting Firmware Download");\r\nfor (i = 1; i < 3; i++) {\r\nstart = (i == 1) ? 0 : 512;\r\nend = (i == 1) ? 512 : fw->size;\r\nfor (j = start; j < end; j += (packet_size+1)) {\r\nfw_data = (u8 *)(fw->data + j);\r\nif ((end - j) > packet_size) {\r\ndata[0] = i;\r\ndlen = packet_size;\r\n} else {\r\ndata[0] = i | 0x80;\r\ndlen = (u8)(end - j)-1;\r\n}\r\ndata[1] = dlen;\r\nmemcpy(&data[2], fw_data, dlen+1);\r\nwlen = (u8) dlen + 4;\r\ndata[wlen-1] = check_sum(fw_data, dlen+1);\r\ndeb_info(1, "Data S=%02x:E=%02x CS= %02x", data[3],\r\ndata[dlen+2], data[dlen+3]);\r\nret |= lme2510_bulk_write(dev, data, wlen, 1);\r\nret |= lme2510_bulk_read(dev, data, len_in , 1);\r\nret |= (data[0] == 0x88) ? 0 : -1;\r\n}\r\n}\r\nusb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n0x06, 0x80, 0x0200, 0x00, data, 0x0109, 1000);\r\ndata[0] = 0x8a;\r\nlen_in = 1;\r\nmsleep(2000);\r\nret |= lme2510_bulk_write(dev, data , len_in, 1);\r\nret |= lme2510_bulk_read(dev, data, len_in, 1);\r\nmsleep(400);\r\nif (ret < 0)\r\ninfo("FRM Firmware Download Failed (%04x)" , ret);\r\nelse\r\ninfo("FRM Firmware Download Completed - Resetting Device");\r\nkfree(data);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic void lme_coldreset(struct usb_device *dev)\r\n{\r\nint ret = 0, len_in;\r\nu8 data[512] = {0};\r\ndata[0] = 0x0a;\r\nlen_in = 1;\r\ninfo("FRM Firmware Cold Reset");\r\nret |= lme2510_bulk_write(dev, data , len_in, 1);\r\nret |= lme2510_bulk_read(dev, data, len_in, 1);\r\nreturn;\r\n}\r\nstatic int lme_firmware_switch(struct usb_device *udev, int cold)\r\n{\r\nconst struct firmware *fw = NULL;\r\nconst char fw_c_s7395[] = "dvb-usb-lme2510c-s7395.fw";\r\nconst char fw_c_lg[] = "dvb-usb-lme2510c-lg.fw";\r\nconst char fw_c_s0194[] = "dvb-usb-lme2510c-s0194.fw";\r\nconst char fw_lg[] = "dvb-usb-lme2510-lg.fw";\r\nconst char fw_s0194[] = "dvb-usb-lme2510-s0194.fw";\r\nconst char *fw_lme;\r\nint ret, cold_fw;\r\ncold = (cold > 0) ? (cold & 1) : 0;\r\ncold_fw = !cold;\r\nif (le16_to_cpu(udev->descriptor.idProduct) == 0x1122) {\r\nswitch (dvb_usb_lme2510_firmware) {\r\ndefault:\r\ndvb_usb_lme2510_firmware = TUNER_S0194;\r\ncase TUNER_S0194:\r\nfw_lme = fw_s0194;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0) {\r\ncold = 0;\r\nbreak;\r\n}\r\ndvb_usb_lme2510_firmware = TUNER_LG;\r\ncase TUNER_LG:\r\nfw_lme = fw_lg;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0)\r\nbreak;\r\ninfo("FRM No Firmware Found - please install");\r\ndvb_usb_lme2510_firmware = TUNER_DEFAULT;\r\ncold = 0;\r\ncold_fw = 0;\r\nbreak;\r\n}\r\n} else {\r\nswitch (dvb_usb_lme2510_firmware) {\r\ndefault:\r\ndvb_usb_lme2510_firmware = TUNER_S7395;\r\ncase TUNER_S7395:\r\nfw_lme = fw_c_s7395;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0) {\r\ncold = 0;\r\nbreak;\r\n}\r\ndvb_usb_lme2510_firmware = TUNER_LG;\r\ncase TUNER_LG:\r\nfw_lme = fw_c_lg;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0)\r\nbreak;\r\ndvb_usb_lme2510_firmware = TUNER_S0194;\r\ncase TUNER_S0194:\r\nfw_lme = fw_c_s0194;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0)\r\nbreak;\r\ninfo("FRM No Firmware Found - please install");\r\ndvb_usb_lme2510_firmware = TUNER_DEFAULT;\r\ncold = 0;\r\ncold_fw = 0;\r\nbreak;\r\n}\r\n}\r\nif (cold_fw) {\r\ninfo("FRM Loading %s file", fw_lme);\r\nret = lme2510_download_firmware(udev, fw);\r\n}\r\nrelease_firmware(fw);\r\nif (cold) {\r\ninfo("FRM Changing to %s firmware", fw_lme);\r\nlme_coldreset(udev);\r\nreturn -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic int lme2510_kill_urb(struct usb_data_stream *stream)\r\n{\r\nint i;\r\nfor (i = 0; i < stream->urbs_submitted; i++) {\r\ndeb_info(3, "killing URB no. %d.", i);\r\nusb_kill_urb(stream->urb_list[i]);\r\n}\r\nstream->urbs_submitted = 0;\r\nreturn 0;\r\n}\r\nstatic int dm04_lme2510_set_voltage(struct dvb_frontend *fe,\r\nfe_sec_voltage_t voltage)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstatic u8 voltage_low[] = LME_VOLTAGE_L;\r\nstatic u8 voltage_high[] = LME_VOLTAGE_H;\r\nstatic u8 rbuf[1];\r\nint ret = 0, len = 3, rlen = 1;\r\nif (mutex_lock_interruptible(&adap->dev->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_18:\r\nret |= lme2510_usb_talk(adap->dev,\r\nvoltage_high, len, rbuf, rlen);\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\ncase SEC_VOLTAGE_13:\r\ndefault:\r\nret |= lme2510_usb_talk(adap->dev,\r\nvoltage_low, len, rbuf, rlen);\r\nbreak;\r\n}\r\nmutex_unlock(&adap->dev->i2c_mutex);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int lme_name(struct dvb_usb_adapter *adap)\r\n{\r\nstruct lme2510_state *st = adap->dev->priv;\r\nconst char *desc = adap->dev->desc->name;\r\nchar *fe_name[] = {"", " LG TDQY-P001F", " SHARP:BS2F7HZ7395",\r\n" SHARP:BS2F7HZ0194"};\r\nchar *name = adap->fe->ops.info.name;\r\nstrlcpy(name, desc, 128);\r\nstrlcat(name, fe_name[st->tuner_config], 128);\r\nreturn 0;\r\n}\r\nstatic int dm04_lme2510_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct lme2510_state *st = adap->dev->priv;\r\nint ret = 0;\r\nst->i2c_talk_onoff = 1;\r\nst->i2c_gate = 4;\r\nadap->fe = dvb_attach(tda10086_attach, &tda10086_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe) {\r\ninfo("TUN Found Frontend TDA10086");\r\nst->i2c_tuner_gate_w = 4;\r\nst->i2c_tuner_gate_r = 4;\r\nst->i2c_tuner_addr = 0xc0;\r\nst->tuner_config = TUNER_LG;\r\nif (dvb_usb_lme2510_firmware != TUNER_LG) {\r\ndvb_usb_lme2510_firmware = TUNER_LG;\r\nret = lme_firmware_switch(adap->dev->udev, 1);\r\n}\r\ngoto end;\r\n}\r\nst->i2c_gate = 4;\r\nadap->fe = dvb_attach(stv0299_attach, &sharp_z0194_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe) {\r\ninfo("FE Found Stv0299");\r\nst->i2c_tuner_gate_w = 4;\r\nst->i2c_tuner_gate_r = 5;\r\nst->i2c_tuner_addr = 0xc0;\r\nst->tuner_config = TUNER_S0194;\r\nif (dvb_usb_lme2510_firmware != TUNER_S0194) {\r\ndvb_usb_lme2510_firmware = TUNER_S0194;\r\nret = lme_firmware_switch(adap->dev->udev, 1);\r\n}\r\ngoto end;\r\n}\r\nst->i2c_gate = 5;\r\nadap->fe = dvb_attach(stv0288_attach, &lme_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe) {\r\ninfo("FE Found Stv0288");\r\nst->i2c_tuner_gate_w = 4;\r\nst->i2c_tuner_gate_r = 5;\r\nst->i2c_tuner_addr = 0xc0;\r\nst->tuner_config = TUNER_S7395;\r\nif (dvb_usb_lme2510_firmware != TUNER_S7395) {\r\ndvb_usb_lme2510_firmware = TUNER_S7395;\r\nret = lme_firmware_switch(adap->dev->udev, 1);\r\n}\r\n} else {\r\ninfo("DM04 Not Supported");\r\nreturn -ENODEV;\r\n}\r\nend: if (ret) {\r\nif (adap->fe) {\r\ndvb_frontend_detach(adap->fe);\r\nadap->fe = NULL;\r\n}\r\nadap->dev->props.rc.core.rc_codes = NULL;\r\nreturn -ENODEV;\r\n}\r\nadap->fe->ops.set_voltage = dm04_lme2510_set_voltage;\r\nret = lme_name(adap);\r\nreturn ret;\r\n}\r\nstatic int dm04_lme2510_tuner(struct dvb_usb_adapter *adap)\r\n{\r\nstruct lme2510_state *st = adap->dev->priv;\r\nchar *tun_msg[] = {"", "TDA8263", "IX2505V", "DVB_PLL_OPERA"};\r\nint ret = 0;\r\nswitch (st->tuner_config) {\r\ncase TUNER_LG:\r\nif (dvb_attach(tda826x_attach, adap->fe, 0xc0,\r\n&adap->dev->i2c_adap, 1))\r\nret = st->tuner_config;\r\nbreak;\r\ncase TUNER_S7395:\r\nif (dvb_attach(ix2505v_attach , adap->fe, &lme_tuner,\r\n&adap->dev->i2c_adap))\r\nret = st->tuner_config;\r\nbreak;\r\ncase TUNER_S0194:\r\nif (dvb_attach(dvb_pll_attach , adap->fe, 0xc0,\r\n&adap->dev->i2c_adap, DVB_PLL_OPERA1))\r\nret = st->tuner_config;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret)\r\ninfo("TUN Found %s tuner", tun_msg[ret]);\r\nelse {\r\ninfo("TUN No tuner found --- reseting device");\r\nlme_coldreset(adap->dev->udev);\r\nreturn -ENODEV;\r\n}\r\nret = lme2510_int_read(adap);\r\nif (ret < 0) {\r\ninfo("INT Unable to start Interrupt Service");\r\nreturn -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic int lme2510_powerup(struct dvb_usb_device *d, int onoff)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nstatic u8 lnb_on[] = LNB_ON;\r\nstatic u8 lnb_off[] = LNB_OFF;\r\nstatic u8 rbuf[1];\r\nint ret, len = 3, rlen = 1;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (onoff)\r\nret = lme2510_usb_talk(d, lnb_on, len, rbuf, rlen);\r\nelse\r\nret = lme2510_usb_talk(d, lnb_off, len, rbuf, rlen);\r\nst->i2c_talk_onoff = 1;\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int lme2510_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nint ret = 0;\r\nusb_reset_configuration(udev);\r\nusb_set_interface(udev, intf->cur_altsetting->desc.bInterfaceNumber, 1);\r\nif (udev->speed != USB_SPEED_HIGH) {\r\nret = usb_reset_device(udev);\r\ninfo("DEV Failed to connect in HIGH SPEED mode");\r\nreturn -ENODEV;\r\n}\r\nif (lme2510_return_status(udev) == 0x44) {\r\nlme_firmware_switch(udev, 0);\r\nreturn -ENODEV;\r\n}\r\nif (0 == dvb_usb_device_init(intf, &lme2510_properties,\r\nTHIS_MODULE, NULL, adapter_nr)) {\r\ninfo("DEV registering device driver");\r\nreturn 0;\r\n}\r\nif (0 == dvb_usb_device_init(intf, &lme2510c_properties,\r\nTHIS_MODULE, NULL, adapter_nr)) {\r\ninfo("DEV registering device driver");\r\nreturn 0;\r\n}\r\ninfo("DEV lme2510 Error");\r\nreturn -ENODEV;\r\n}\r\nstatic void *lme2510_exit_int(struct dvb_usb_device *d)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nstruct dvb_usb_adapter *adap = &d->adapter[0];\r\nvoid *buffer = NULL;\r\nif (adap != NULL) {\r\nlme2510_kill_urb(&adap->stream);\r\nadap->feedcount = 0;\r\n}\r\nif (st->usb_buffer != NULL) {\r\nst->i2c_talk_onoff = 1;\r\nst->signal_lock = 0;\r\nst->signal_level = 0;\r\nst->signal_sn = 0;\r\nbuffer = st->usb_buffer;\r\n}\r\nif (st->lme_urb != NULL) {\r\nusb_kill_urb(st->lme_urb);\r\nusb_free_coherent(d->udev, 5000, st->buffer,\r\nst->lme_urb->transfer_dma);\r\ninfo("Interrupt Service Stopped");\r\n}\r\nreturn buffer;\r\n}\r\nstatic void lme2510_exit(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\nvoid *usb_buffer;\r\nif (d != NULL) {\r\nusb_buffer = lme2510_exit_int(d);\r\ndvb_usb_device_exit(intf);\r\nif (usb_buffer != NULL)\r\nkfree(usb_buffer);\r\n}\r\n}\r\nstatic int __init lme2510_module_init(void)\r\n{\r\nint result = usb_register(&lme2510_driver);\r\nif (result) {\r\nerr("usb_register failed. Error number %d", result);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit lme2510_module_exit(void)\r\n{\r\nusb_deregister(&lme2510_driver);\r\n}
