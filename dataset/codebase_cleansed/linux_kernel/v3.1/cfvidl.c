struct cflayer *cfvidl_create(u8 channel_id, struct dev_info *dev_info)\r\n{\r\nstruct cfsrvl *vid = kmalloc(sizeof(struct cfsrvl), GFP_ATOMIC);\r\nif (!vid) {\r\npr_warn("Out of memory\n");\r\nreturn NULL;\r\n}\r\ncaif_assert(offsetof(struct cfsrvl, layer) == 0);\r\nmemset(vid, 0, sizeof(struct cfsrvl));\r\ncfsrvl_init(vid, channel_id, dev_info, false);\r\nvid->layer.receive = cfvidl_receive;\r\nvid->layer.transmit = cfvidl_transmit;\r\nsnprintf(vid->layer.name, CAIF_LAYER_NAME_SZ - 1, "vid1");\r\nreturn &vid->layer;\r\n}\r\nstatic int cfvidl_receive(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nu32 videoheader;\r\nif (cfpkt_extr_head(pkt, &videoheader, 4) < 0) {\r\npr_err("Packet is erroneous!\n");\r\ncfpkt_destroy(pkt);\r\nreturn -EPROTO;\r\n}\r\nreturn layr->up->receive(layr->up, pkt);\r\n}\r\nstatic int cfvidl_transmit(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nstruct cfsrvl *service = container_obj(layr);\r\nstruct caif_payload_info *info;\r\nu32 videoheader = 0;\r\nint ret;\r\nif (!cfsrvl_ready(service, &ret))\r\nreturn ret;\r\ncfpkt_add_head(pkt, &videoheader, 4);\r\ninfo = cfpkt_info(pkt);\r\ninfo->channel_id = service->layer.id;\r\ninfo->dev_info = &service->dev_info;\r\nreturn layr->dn->transmit(layr->dn, pkt);\r\n}
