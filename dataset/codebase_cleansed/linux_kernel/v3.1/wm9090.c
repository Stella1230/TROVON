static int wm9090_volatile(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM9090_SOFTWARE_RESET:\r\ncase WM9090_DC_SERVO_0:\r\ncase WM9090_DC_SERVO_READBACK_0:\r\ncase WM9090_DC_SERVO_READBACK_1:\r\ncase WM9090_DC_SERVO_READBACK_2:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void wait_for_dc_servo(struct snd_soc_codec *codec)\r\n{\r\nunsigned int reg;\r\nint count = 0;\r\ndev_dbg(codec->dev, "Waiting for DC servo...\n");\r\ndo {\r\ncount++;\r\nmsleep(1);\r\nreg = snd_soc_read(codec, WM9090_DC_SERVO_READBACK_0);\r\ndev_dbg(codec->dev, "DC servo status: %x\n", reg);\r\n} while ((reg & WM9090_DCS_CAL_COMPLETE_MASK)\r\n!= WM9090_DCS_CAL_COMPLETE_MASK && count < 1000);\r\nif ((reg & WM9090_DCS_CAL_COMPLETE_MASK)\r\n!= WM9090_DCS_CAL_COMPLETE_MASK)\r\ndev_err(codec->dev, "Timed out waiting for DC Servo\n");\r\n}\r\nstatic int hp_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nunsigned int reg = snd_soc_read(codec, WM9090_ANALOGUE_HP_0);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, WM9090_CHARGE_PUMP_1,\r\nWM9090_CP_ENA, WM9090_CP_ENA);\r\nmsleep(5);\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_1,\r\nWM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA,\r\nWM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA);\r\nreg |= WM9090_HPOUT1L_DLY | WM9090_HPOUT1R_DLY;\r\nsnd_soc_write(codec, WM9090_ANALOGUE_HP_0, reg);\r\nsnd_soc_write(codec, WM9090_DC_SERVO_0,\r\nWM9090_DCS_ENA_CHAN_0 |\r\nWM9090_DCS_ENA_CHAN_1 |\r\nWM9090_DCS_TRIG_STARTUP_1 |\r\nWM9090_DCS_TRIG_STARTUP_0);\r\nwait_for_dc_servo(codec);\r\nreg |= WM9090_HPOUT1R_OUTP | WM9090_HPOUT1R_RMV_SHORT |\r\nWM9090_HPOUT1L_OUTP | WM9090_HPOUT1L_RMV_SHORT;\r\nsnd_soc_write(codec, WM9090_ANALOGUE_HP_0, reg);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nreg &= ~(WM9090_HPOUT1L_RMV_SHORT |\r\nWM9090_HPOUT1L_DLY |\r\nWM9090_HPOUT1L_OUTP |\r\nWM9090_HPOUT1R_RMV_SHORT |\r\nWM9090_HPOUT1R_DLY |\r\nWM9090_HPOUT1R_OUTP);\r\nsnd_soc_write(codec, WM9090_ANALOGUE_HP_0, reg);\r\nsnd_soc_write(codec, WM9090_DC_SERVO_0, 0);\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_1,\r\nWM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA,\r\n0);\r\nsnd_soc_update_bits(codec, WM9090_CHARGE_PUMP_1,\r\nWM9090_CP_ENA, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm9090_add_controls(struct snd_soc_codec *codec)\r\n{\r\nstruct wm9090_priv *wm9090 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint i;\r\nsnd_soc_dapm_new_controls(dapm, wm9090_dapm_widgets,\r\nARRAY_SIZE(wm9090_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));\r\nsnd_soc_add_controls(codec, wm9090_controls,\r\nARRAY_SIZE(wm9090_controls));\r\nif (wm9090->pdata.lin1_diff) {\r\nsnd_soc_dapm_add_routes(dapm, audio_map_in1_diff,\r\nARRAY_SIZE(audio_map_in1_diff));\r\n} else {\r\nsnd_soc_dapm_add_routes(dapm, audio_map_in1_se,\r\nARRAY_SIZE(audio_map_in1_se));\r\nsnd_soc_add_controls(codec, wm9090_in1_se_controls,\r\nARRAY_SIZE(wm9090_in1_se_controls));\r\n}\r\nif (wm9090->pdata.lin2_diff) {\r\nsnd_soc_dapm_add_routes(dapm, audio_map_in2_diff,\r\nARRAY_SIZE(audio_map_in2_diff));\r\n} else {\r\nsnd_soc_dapm_add_routes(dapm, audio_map_in2_se,\r\nARRAY_SIZE(audio_map_in2_se));\r\nsnd_soc_add_controls(codec, wm9090_in2_se_controls,\r\nARRAY_SIZE(wm9090_in2_se_controls));\r\n}\r\nif (wm9090->pdata.agc_ena) {\r\nfor (i = 0; i < ARRAY_SIZE(wm9090->pdata.agc); i++)\r\nsnd_soc_write(codec, WM9090_AGC_CONTROL_0 + i,\r\nwm9090->pdata.agc[i]);\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_3,\r\nWM9090_AGC_ENA, WM9090_AGC_ENA);\r\n} else {\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_3,\r\nWM9090_AGC_ENA, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm9090_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 *reg_cache = codec->reg_cache;\r\nint i, ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM9090_ANTIPOP2, WM9090_VMID_ENA,\r\nWM9090_VMID_ENA);\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_1,\r\nWM9090_BIAS_ENA |\r\nWM9090_VMID_RES_MASK,\r\nWM9090_BIAS_ENA |\r\n1 << WM9090_VMID_RES_SHIFT);\r\nmsleep(1);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nfor (i = 1; i < codec->driver->reg_cache_size; i++) {\r\nif (reg_cache[i] == wm9090_reg_defaults[i])\r\ncontinue;\r\nif (wm9090_volatile(codec, i))\r\ncontinue;\r\nret = snd_soc_write(codec, i, reg_cache[i]);\r\nif (ret != 0)\r\ndev_warn(codec->dev,\r\n"Failed to restore register %d: %d\n",\r\ni, ret);\r\n}\r\n}\r\nsnd_soc_update_bits(codec, WM9090_POWER_MANAGEMENT_1,\r\nWM9090_BIAS_ENA | WM9090_VMID_RES_MASK, 0);\r\nsnd_soc_update_bits(codec, WM9090_ANTIPOP2,\r\nWM9090_VMID_ENA, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm9090_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm9090_priv *wm9090 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncodec->control_data = wm9090->control_data;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_I2C);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_read(codec, WM9090_SOFTWARE_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != wm9090_reg_defaults[WM9090_SOFTWARE_RESET]) {\r\ndev_err(codec->dev, "Device is not a WM9090, ID=%x\n", ret);\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_write(codec, WM9090_SOFTWARE_RESET, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, WM9090_IN1_LINE_INPUT_A_VOLUME,\r\nWM9090_IN1_VU | WM9090_IN1A_ZC,\r\nWM9090_IN1_VU | WM9090_IN1A_ZC);\r\nsnd_soc_update_bits(codec, WM9090_IN1_LINE_INPUT_B_VOLUME,\r\nWM9090_IN1_VU | WM9090_IN1B_ZC,\r\nWM9090_IN1_VU | WM9090_IN1B_ZC);\r\nsnd_soc_update_bits(codec, WM9090_IN2_LINE_INPUT_A_VOLUME,\r\nWM9090_IN2_VU | WM9090_IN2A_ZC,\r\nWM9090_IN2_VU | WM9090_IN2A_ZC);\r\nsnd_soc_update_bits(codec, WM9090_IN2_LINE_INPUT_B_VOLUME,\r\nWM9090_IN2_VU | WM9090_IN2B_ZC,\r\nWM9090_IN2_VU | WM9090_IN2B_ZC);\r\nsnd_soc_update_bits(codec, WM9090_SPEAKER_VOLUME_LEFT,\r\nWM9090_SPKOUT_VU | WM9090_SPKOUTL_ZC,\r\nWM9090_SPKOUT_VU | WM9090_SPKOUTL_ZC);\r\nsnd_soc_update_bits(codec, WM9090_LEFT_OUTPUT_VOLUME,\r\nWM9090_HPOUT1_VU | WM9090_HPOUT1L_ZC,\r\nWM9090_HPOUT1_VU | WM9090_HPOUT1L_ZC);\r\nsnd_soc_update_bits(codec, WM9090_RIGHT_OUTPUT_VOLUME,\r\nWM9090_HPOUT1_VU | WM9090_HPOUT1R_ZC,\r\nWM9090_HPOUT1_VU | WM9090_HPOUT1R_ZC);\r\nsnd_soc_update_bits(codec, WM9090_CLOCKING_1,\r\nWM9090_TOCLK_ENA, WM9090_TOCLK_ENA);\r\nwm9090_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nwm9090_add_controls(codec);\r\nreturn 0;\r\n}\r\nstatic int wm9090_suspend(struct snd_soc_codec *codec, pm_message_t state)\r\n{\r\nwm9090_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm9090_resume(struct snd_soc_codec *codec)\r\n{\r\nwm9090_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm9090_remove(struct snd_soc_codec *codec)\r\n{\r\nwm9090_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm9090_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm9090_priv *wm9090;\r\nint ret;\r\nwm9090 = kzalloc(sizeof(*wm9090), GFP_KERNEL);\r\nif (wm9090 == NULL) {\r\ndev_err(&i2c->dev, "Can not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (i2c->dev.platform_data)\r\nmemcpy(&wm9090->pdata, i2c->dev.platform_data,\r\nsizeof(wm9090->pdata));\r\ni2c_set_clientdata(i2c, wm9090);\r\nwm9090->control_data = i2c;\r\nmutex_init(&wm9090->mutex);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm9090, NULL, 0);\r\nif (ret < 0)\r\nkfree(wm9090);\r\nreturn ret;\r\n}\r\nstatic int __devexit wm9090_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct wm9090_priv *wm9090 = i2c_get_clientdata(i2c);\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nkfree(wm9090);\r\nreturn 0;\r\n}\r\nstatic int __init wm9090_init(void)\r\n{\r\nreturn i2c_add_driver(&wm9090_i2c_driver);\r\n}\r\nstatic void __exit wm9090_exit(void)\r\n{\r\ni2c_del_driver(&wm9090_i2c_driver);\r\n}
