u32 read_ir_reg(u32 addr)\r\n{\r\nreadl(addr);\r\nreturn readl(addr);\r\n}\r\nstatic db_dest_t *GetFreeDB(struct au1k_private *aup)\r\n{\r\ndb_dest_t *pDB;\r\npDB = aup->pDBfree;\r\nif (pDB) {\r\naup->pDBfree = pDB->pnext;\r\n}\r\nreturn pDB;\r\n}\r\nstatic void ReleaseDB(struct au1k_private *aup, db_dest_t *pDB)\r\n{\r\ndb_dest_t *pDBfree = aup->pDBfree;\r\nif (pDBfree)\r\npDBfree->pnext = pDB;\r\naup->pDBfree = pDB;\r\n}\r\nstatic void *dma_alloc(size_t size, dma_addr_t * dma_handle)\r\n{\r\nvoid *ret;\r\nint gfp = GFP_ATOMIC | GFP_DMA;\r\nret = (void *) __get_free_pages(gfp, get_order(size));\r\nif (ret != NULL) {\r\nmemset(ret, 0, size);\r\n*dma_handle = virt_to_bus(ret);\r\nret = (void *)KSEG0ADDR(ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dma_free(void *vaddr, size_t size)\r\n{\r\nvaddr = (void *)KSEG0ADDR(vaddr);\r\nfree_pages((unsigned long) vaddr, get_order(size));\r\n}\r\nstatic void\r\nsetup_hw_rings(struct au1k_private *aup, u32 rx_base, u32 tx_base)\r\n{\r\nint i;\r\nfor (i=0; i<NUM_IR_DESC; i++) {\r\naup->rx_ring[i] = (volatile ring_dest_t *)\r\n(rx_base + sizeof(ring_dest_t)*i);\r\n}\r\nfor (i=0; i<NUM_IR_DESC; i++) {\r\naup->tx_ring[i] = (volatile ring_dest_t *)\r\n(tx_base + sizeof(ring_dest_t)*i);\r\n}\r\n}\r\nstatic int au1k_irda_init(void)\r\n{\r\nstatic unsigned version_printed = 0;\r\nstruct au1k_private *aup;\r\nstruct net_device *dev;\r\nint err;\r\nif (version_printed++ == 0) printk(version);\r\ndev = alloc_irdadev(sizeof(struct au1k_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->irq = AU1000_IRDA_RX_INT;\r\nerr = au1k_irda_net_init(dev);\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nir_devs[0] = dev;\r\nprintk(KERN_INFO "IrDA: Registered device %s\n", dev->name);\r\nreturn 0;\r\nout1:\r\naup = netdev_priv(dev);\r\ndma_free((void *)aup->db[0].vaddr,\r\nMAX_BUF_SIZE * 2*NUM_IR_DESC);\r\ndma_free((void *)aup->rx_ring[0],\r\n2 * MAX_NUM_IR_DESC*(sizeof(ring_dest_t)));\r\nkfree(aup->rx_buff.head);\r\nout:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int au1k_irda_init_iobuf(iobuff_t *io, int size)\r\n{\r\nio->head = kmalloc(size, GFP_KERNEL);\r\nif (io->head != NULL) {\r\nio->truesize = size;\r\nio->in_frame = FALSE;\r\nio->state = OUTSIDE_FRAME;\r\nio->data = io->head;\r\n}\r\nreturn io->head ? 0 : -ENOMEM;\r\n}\r\nstatic int au1k_irda_net_init(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nint i, retval = 0, err;\r\ndb_dest_t *pDB, *pDBfree;\r\ndma_addr_t temp;\r\nerr = au1k_irda_init_iobuf(&aup->rx_buff, 14384);\r\nif (err)\r\ngoto out1;\r\ndev->netdev_ops = &au1k_irda_netdev_ops;\r\nirda_init_max_qos_capabilies(&aup->qos);\r\naup->qos.baud_rate.bits = IR_9600|IR_19200|IR_38400|IR_57600|\r\nIR_115200|IR_576000 |(IR_4000000 << 8);\r\naup->qos.min_turn_time.bits = qos_mtt_bits;\r\nirda_qos_bits_to_value(&aup->qos);\r\nretval = -ENOMEM;\r\naup->rx_ring[0] = (ring_dest_t *)\r\ndma_alloc(2*MAX_NUM_IR_DESC*(sizeof(ring_dest_t)), &temp);\r\nif (!aup->rx_ring[0])\r\ngoto out2;\r\naup->db[0].vaddr =\r\n(void *)dma_alloc(MAX_BUF_SIZE * 2*NUM_IR_DESC, &temp);\r\nif (!aup->db[0].vaddr)\r\ngoto out3;\r\nsetup_hw_rings(aup, (u32)aup->rx_ring[0], (u32)aup->rx_ring[0] + 512);\r\npDBfree = NULL;\r\npDB = aup->db;\r\nfor (i=0; i<(2*NUM_IR_DESC); i++) {\r\npDB->pnext = pDBfree;\r\npDBfree = pDB;\r\npDB->vaddr =\r\n(u32 *)((unsigned)aup->db[0].vaddr + MAX_BUF_SIZE*i);\r\npDB->dma_addr = (dma_addr_t)virt_to_bus(pDB->vaddr);\r\npDB++;\r\n}\r\naup->pDBfree = pDBfree;\r\nfor (i=0; i<NUM_IR_DESC; i++) {\r\npDB = GetFreeDB(aup);\r\nif (!pDB) goto out;\r\naup->rx_ring[i]->addr_0 = (u8)(pDB->dma_addr & 0xff);\r\naup->rx_ring[i]->addr_1 = (u8)((pDB->dma_addr>>8) & 0xff);\r\naup->rx_ring[i]->addr_2 = (u8)((pDB->dma_addr>>16) & 0xff);\r\naup->rx_ring[i]->addr_3 = (u8)((pDB->dma_addr>>24) & 0xff);\r\naup->rx_db_inuse[i] = pDB;\r\n}\r\nfor (i=0; i<NUM_IR_DESC; i++) {\r\npDB = GetFreeDB(aup);\r\nif (!pDB) goto out;\r\naup->tx_ring[i]->addr_0 = (u8)(pDB->dma_addr & 0xff);\r\naup->tx_ring[i]->addr_1 = (u8)((pDB->dma_addr>>8) & 0xff);\r\naup->tx_ring[i]->addr_2 = (u8)((pDB->dma_addr>>16) & 0xff);\r\naup->tx_ring[i]->addr_3 = (u8)((pDB->dma_addr>>24) & 0xff);\r\naup->tx_ring[i]->count_0 = 0;\r\naup->tx_ring[i]->count_1 = 0;\r\naup->tx_ring[i]->flags = 0;\r\naup->tx_db_inuse[i] = pDB;\r\n}\r\n#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)\r\nbcsr_mod(BCSR_RESETS, BCSR_RESETS_IRDA_MODE_MASK,\r\nBCSR_RESETS_IRDA_MODE_FULL);\r\n#endif\r\nreturn 0;\r\nout3:\r\ndma_free((void *)aup->rx_ring[0],\r\n2 * MAX_NUM_IR_DESC*(sizeof(ring_dest_t)));\r\nout2:\r\nkfree(aup->rx_buff.head);\r\nout1:\r\nprintk(KERN_ERR "au1k_init_module failed. Returns %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int au1k_init(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nint i;\r\nu32 control;\r\nu32 ring_address;\r\ncontrol = 0xe;\r\n#ifndef CONFIG_CPU_LITTLE_ENDIAN\r\ncontrol |= 1;\r\n#endif\r\naup->tx_head = 0;\r\naup->tx_tail = 0;\r\naup->rx_head = 0;\r\nfor (i=0; i<NUM_IR_DESC; i++) {\r\naup->rx_ring[i]->flags = AU_OWN;\r\n}\r\nwritel(control, IR_INTERFACE_CONFIG);\r\nau_sync_delay(10);\r\nwritel(read_ir_reg(IR_ENABLE) & ~0x8000, IR_ENABLE);\r\nau_sync_delay(1);\r\nwritel(MAX_BUF_SIZE, IR_MAX_PKT_LEN);\r\nring_address = (u32)virt_to_phys((void *)aup->rx_ring[0]);\r\nwritel(ring_address >> 26, IR_RING_BASE_ADDR_H);\r\nwritel((ring_address >> 10) & 0xffff, IR_RING_BASE_ADDR_L);\r\nwritel(RING_SIZE_64<<8 | RING_SIZE_64<<12, IR_RING_SIZE);\r\nwritel(1<<2 | IR_ONE_PIN, IR_CONFIG_2);\r\nwritel(0, IR_RING_ADDR_CMPR);\r\nau1k_irda_set_speed(dev, 9600);\r\nreturn 0;\r\n}\r\nstatic int au1k_irda_start(struct net_device *dev)\r\n{\r\nint retval;\r\nchar hwname[32];\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nif ((retval = au1k_init(dev))) {\r\nprintk(KERN_ERR "%s: error in au1k_init\n", dev->name);\r\nreturn retval;\r\n}\r\nif ((retval = request_irq(AU1000_IRDA_TX_INT, au1k_irda_interrupt,\r\n0, dev->name, dev))) {\r\nprintk(KERN_ERR "%s: unable to get IRQ %d\n",\r\ndev->name, dev->irq);\r\nreturn retval;\r\n}\r\nif ((retval = request_irq(AU1000_IRDA_RX_INT, au1k_irda_interrupt,\r\n0, dev->name, dev))) {\r\nfree_irq(AU1000_IRDA_TX_INT, dev);\r\nprintk(KERN_ERR "%s: unable to get IRQ %d\n",\r\ndev->name, dev->irq);\r\nreturn retval;\r\n}\r\nsprintf(hwname, "Au1000 SIR/FIR");\r\naup->irlap = irlap_open(dev, &aup->qos, hwname);\r\nnetif_start_queue(dev);\r\nwritel(read_ir_reg(IR_CONFIG_2) | 1<<8, IR_CONFIG_2);\r\naup->timer.expires = RUN_AT((3*HZ));\r\naup->timer.data = (unsigned long)dev;\r\nreturn 0;\r\n}\r\nstatic int au1k_irda_stop(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nwritel(read_ir_reg(IR_CONFIG_2) & ~(1<<8), IR_CONFIG_2);\r\nwritel(0, IR_CONFIG_1);\r\nwritel(0, IR_INTERFACE_CONFIG);\r\nau_sync();\r\nif (aup->irlap) {\r\nirlap_close(aup->irlap);\r\naup->irlap = NULL;\r\n}\r\nnetif_stop_queue(dev);\r\ndel_timer(&aup->timer);\r\nfree_irq(AU1000_IRDA_TX_INT, dev);\r\nfree_irq(AU1000_IRDA_RX_INT, dev);\r\nreturn 0;\r\n}\r\nstatic void __exit au1k_irda_exit(void)\r\n{\r\nstruct net_device *dev = ir_devs[0];\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nunregister_netdev(dev);\r\ndma_free((void *)aup->db[0].vaddr,\r\nMAX_BUF_SIZE * 2*NUM_IR_DESC);\r\ndma_free((void *)aup->rx_ring[0],\r\n2 * MAX_NUM_IR_DESC*(sizeof(ring_dest_t)));\r\nkfree(aup->rx_buff.head);\r\nfree_netdev(dev);\r\n}\r\nstatic inline void\r\nupdate_tx_stats(struct net_device *dev, u32 status, u32 pkt_len)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nstruct net_device_stats *ps = &aup->stats;\r\nps->tx_packets++;\r\nps->tx_bytes += pkt_len;\r\nif (status & IR_TX_ERROR) {\r\nps->tx_errors++;\r\nps->tx_aborted_errors++;\r\n}\r\n}\r\nstatic void au1k_tx_ack(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nvolatile ring_dest_t *ptxd;\r\nptxd = aup->tx_ring[aup->tx_tail];\r\nwhile (!(ptxd->flags & AU_OWN) && (aup->tx_tail != aup->tx_head)) {\r\nupdate_tx_stats(dev, ptxd->flags,\r\nptxd->count_1<<8 | ptxd->count_0);\r\nptxd->count_0 = 0;\r\nptxd->count_1 = 0;\r\nau_sync();\r\naup->tx_tail = (aup->tx_tail + 1) & (NUM_IR_DESC - 1);\r\nptxd = aup->tx_ring[aup->tx_tail];\r\nif (aup->tx_full) {\r\naup->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nif (aup->tx_tail == aup->tx_head) {\r\nif (aup->newspeed) {\r\nau1k_irda_set_speed(dev, aup->newspeed);\r\naup->newspeed = 0;\r\n}\r\nelse {\r\nwritel(read_ir_reg(IR_CONFIG_1) & ~IR_TX_ENABLE,\r\nIR_CONFIG_1);\r\nau_sync();\r\nwritel(read_ir_reg(IR_CONFIG_1) | IR_RX_ENABLE,\r\nIR_CONFIG_1);\r\nwritel(0, IR_RING_PROMPT);\r\nau_sync();\r\n}\r\n}\r\n}\r\nstatic int au1k_irda_hard_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nint speed = irda_get_next_speed(skb);\r\nvolatile ring_dest_t *ptxd;\r\nu32 len;\r\nu32 flags;\r\ndb_dest_t *pDB;\r\nif (speed != aup->speed && speed != -1) {\r\naup->newspeed = speed;\r\n}\r\nif ((skb->len == 0) && (aup->newspeed)) {\r\nif (aup->tx_tail == aup->tx_head) {\r\nau1k_irda_set_speed(dev, speed);\r\naup->newspeed = 0;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nptxd = aup->tx_ring[aup->tx_head];\r\nflags = ptxd->flags;\r\nif (flags & AU_OWN) {\r\nprintk(KERN_DEBUG "%s: tx_full\n", dev->name);\r\nnetif_stop_queue(dev);\r\naup->tx_full = 1;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nelse if (((aup->tx_head + 1) & (NUM_IR_DESC - 1)) == aup->tx_tail) {\r\nprintk(KERN_DEBUG "%s: tx_full\n", dev->name);\r\nnetif_stop_queue(dev);\r\naup->tx_full = 1;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\npDB = aup->tx_db_inuse[aup->tx_head];\r\n#if 0\r\nif (read_ir_reg(IR_RX_BYTE_CNT) != 0) {\r\nprintk("tx warning: rx byte cnt %x\n",\r\nread_ir_reg(IR_RX_BYTE_CNT));\r\n}\r\n#endif\r\nif (aup->speed == 4000000) {\r\nskb_copy_from_linear_data(skb, pDB->vaddr, skb->len);\r\nptxd->count_0 = skb->len & 0xff;\r\nptxd->count_1 = (skb->len >> 8) & 0xff;\r\n}\r\nelse {\r\nlen = async_wrap_skb(skb, (u8 *)pDB->vaddr, MAX_BUF_SIZE);\r\nptxd->count_0 = len & 0xff;\r\nptxd->count_1 = (len >> 8) & 0xff;\r\nptxd->flags |= IR_DIS_CRC;\r\nau_writel(au_readl(0xae00000c) & ~(1<<13), 0xae00000c);\r\n}\r\nptxd->flags |= AU_OWN;\r\nau_sync();\r\nwritel(read_ir_reg(IR_CONFIG_1) | IR_TX_ENABLE, IR_CONFIG_1);\r\nwritel(0, IR_RING_PROMPT);\r\nau_sync();\r\ndev_kfree_skb(skb);\r\naup->tx_head = (aup->tx_head + 1) & (NUM_IR_DESC - 1);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic inline void\r\nupdate_rx_stats(struct net_device *dev, u32 status, u32 count)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nstruct net_device_stats *ps = &aup->stats;\r\nps->rx_packets++;\r\nif (status & IR_RX_ERROR) {\r\nps->rx_errors++;\r\nif (status & (IR_PHY_ERROR|IR_FIFO_OVER))\r\nps->rx_missed_errors++;\r\nif (status & IR_MAX_LEN)\r\nps->rx_length_errors++;\r\nif (status & IR_CRC_ERROR)\r\nps->rx_crc_errors++;\r\n}\r\nelse\r\nps->rx_bytes += count;\r\n}\r\nstatic int au1k_irda_rx(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nvolatile ring_dest_t *prxd;\r\nu32 flags, count;\r\ndb_dest_t *pDB;\r\nprxd = aup->rx_ring[aup->rx_head];\r\nflags = prxd->flags;\r\nwhile (!(flags & AU_OWN)) {\r\npDB = aup->rx_db_inuse[aup->rx_head];\r\ncount = prxd->count_1<<8 | prxd->count_0;\r\nif (!(flags & IR_RX_ERROR)) {\r\nupdate_rx_stats(dev, flags, count);\r\nskb=alloc_skb(count+1,GFP_ATOMIC);\r\nif (skb == NULL) {\r\naup->netdev->stats.rx_dropped++;\r\ncontinue;\r\n}\r\nskb_reserve(skb, 1);\r\nif (aup->speed == 4000000)\r\nskb_put(skb, count);\r\nelse\r\nskb_put(skb, count-2);\r\nskb_copy_to_linear_data(skb, pDB->vaddr, count - 2);\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\nprxd->count_0 = 0;\r\nprxd->count_1 = 0;\r\n}\r\nprxd->flags |= AU_OWN;\r\naup->rx_head = (aup->rx_head + 1) & (NUM_IR_DESC - 1);\r\nwritel(0, IR_RING_PROMPT);\r\nau_sync();\r\nprxd = aup->rx_ring[aup->rx_head];\r\nflags = prxd->flags;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t au1k_irda_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nwritel(0, IR_INT_CLEAR);\r\nau1k_irda_rx(dev);\r\nau1k_tx_ack(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void au1k_tx_timeout(struct net_device *dev)\r\n{\r\nu32 speed;\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nprintk(KERN_ERR "%s: tx timeout\n", dev->name);\r\nspeed = aup->speed;\r\naup->speed = 0;\r\nau1k_irda_set_speed(dev, speed);\r\naup->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int\r\nau1k_irda_set_speed(struct net_device *dev, int speed)\r\n{\r\nunsigned long flags;\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nu32 control;\r\nint ret = 0, timeout = 10, i;\r\nvolatile ring_dest_t *ptxd;\r\n#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)\r\nunsigned long irda_resets;\r\n#endif\r\nif (speed == aup->speed)\r\nreturn ret;\r\nspin_lock_irqsave(&ir_lock, flags);\r\nwritel(read_ir_reg(IR_ENABLE) & ~0x8000, IR_ENABLE);\r\nwritel(read_ir_reg(IR_CONFIG_1) & ~(IR_RX_ENABLE|IR_TX_ENABLE),\r\nIR_CONFIG_1);\r\nau_sync_delay(1);\r\nwhile (read_ir_reg(IR_ENABLE) & (IR_RX_STATUS | IR_TX_STATUS)) {\r\nmdelay(1);\r\nif (!timeout--) {\r\nprintk(KERN_ERR "%s: rx/tx disable timeout\n",\r\ndev->name);\r\nbreak;\r\n}\r\n}\r\nwritel(read_ir_reg(IR_CONFIG_1) & ~IR_DMA_ENABLE, IR_CONFIG_1);\r\nau_sync_delay(1);\r\naup->tx_head = aup->tx_tail = aup->rx_head = 0;\r\nfor (i=0; i<NUM_IR_DESC; i++) {\r\nptxd = aup->tx_ring[i];\r\nptxd->flags = 0;\r\nptxd->count_0 = 0;\r\nptxd->count_1 = 0;\r\n}\r\nfor (i=0; i<NUM_IR_DESC; i++) {\r\nptxd = aup->rx_ring[i];\r\nptxd->count_0 = 0;\r\nptxd->count_1 = 0;\r\nptxd->flags = AU_OWN;\r\n}\r\nif (speed == 4000000) {\r\n#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)\r\nbcsr_mod(BCSR_RESETS, 0, BCSR_RESETS_FIR_SEL);\r\n#else\r\nwritel(1<<13, CPLD_AUX1);\r\n#endif\r\n}\r\nelse {\r\n#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100)\r\nbcsr_mod(BCSR_RESETS, BCSR_RESETS_FIR_SEL, 0);\r\n#else\r\nwritel(readl(CPLD_AUX1) & ~(1<<13), CPLD_AUX1);\r\n#endif\r\n}\r\nswitch (speed) {\r\ncase 9600:\r\nwritel(11<<10 | 12<<5, IR_WRITE_PHY_CONFIG);\r\nwritel(IR_SIR_MODE, IR_CONFIG_1);\r\nbreak;\r\ncase 19200:\r\nwritel(5<<10 | 12<<5, IR_WRITE_PHY_CONFIG);\r\nwritel(IR_SIR_MODE, IR_CONFIG_1);\r\nbreak;\r\ncase 38400:\r\nwritel(2<<10 | 12<<5, IR_WRITE_PHY_CONFIG);\r\nwritel(IR_SIR_MODE, IR_CONFIG_1);\r\nbreak;\r\ncase 57600:\r\nwritel(1<<10 | 12<<5, IR_WRITE_PHY_CONFIG);\r\nwritel(IR_SIR_MODE, IR_CONFIG_1);\r\nbreak;\r\ncase 115200:\r\nwritel(12<<5, IR_WRITE_PHY_CONFIG);\r\nwritel(IR_SIR_MODE, IR_CONFIG_1);\r\nbreak;\r\ncase 4000000:\r\nwritel(0xF, IR_WRITE_PHY_CONFIG);\r\nwritel(IR_FIR|IR_DMA_ENABLE|IR_RX_ENABLE, IR_CONFIG_1);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unsupported speed %x\n", dev->name, speed);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\naup->speed = speed;\r\nwritel(read_ir_reg(IR_ENABLE) | 0x8000, IR_ENABLE);\r\nau_sync();\r\ncontrol = read_ir_reg(IR_ENABLE);\r\nwritel(0, IR_RING_PROMPT);\r\nau_sync();\r\nif (control & (1<<14)) {\r\nprintk(KERN_ERR "%s: configuration error\n", dev->name);\r\n}\r\nelse {\r\nif (control & (1<<11))\r\nprintk(KERN_DEBUG "%s Valid SIR config\n", dev->name);\r\nif (control & (1<<12))\r\nprintk(KERN_DEBUG "%s Valid MIR config\n", dev->name);\r\nif (control & (1<<13))\r\nprintk(KERN_DEBUG "%s Valid FIR config\n", dev->name);\r\nif (control & (1<<10))\r\nprintk(KERN_DEBUG "%s TX enabled\n", dev->name);\r\nif (control & (1<<9))\r\nprintk(KERN_DEBUG "%s RX enabled\n", dev->name);\r\n}\r\nspin_unlock_irqrestore(&ir_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nau1k_irda_ioctl(struct net_device *dev, struct ifreq *ifreq, int cmd)\r\n{\r\nstruct if_irda_req *rq = (struct if_irda_req *)ifreq;\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (aup->open)\r\nret = au1k_irda_set_speed(dev,\r\nrq->ifr_baudrate);\r\nelse {\r\nprintk(KERN_ERR "%s ioctl: !netif_running\n",\r\ndev->name);\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nret = -EPERM;\r\nif (capable(CAP_NET_ADMIN)) {\r\nirda_device_set_media_busy(dev, TRUE);\r\nret = 0;\r\n}\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nrq->ifr_receiving = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}
