static int ms02nv_read(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct ms02nv_private *mp = mtd->priv;\r\nif (from + len > mtd->size)\r\nreturn -EINVAL;\r\nmemcpy(buf, mp->uaddr + from, len);\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic int ms02nv_write(struct mtd_info *mtd, loff_t to,\r\nsize_t len, size_t *retlen, const u_char *buf)\r\n{\r\nstruct ms02nv_private *mp = mtd->priv;\r\nif (to + len > mtd->size)\r\nreturn -EINVAL;\r\nmemcpy(mp->uaddr + to, buf, len);\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic inline uint ms02nv_probe_one(ulong addr)\r\n{\r\nms02nv_uint *ms02nv_diagp;\r\nms02nv_uint *ms02nv_magicp;\r\nuint ms02nv_diag;\r\nuint ms02nv_magic;\r\nsize_t size;\r\nint err;\r\nms02nv_diagp = (ms02nv_uint *)(CKSEG1ADDR(addr + MS02NV_DIAG));\r\nms02nv_magicp = (ms02nv_uint *)(CKSEG1ADDR(addr + MS02NV_MAGIC));\r\nerr = get_dbe(ms02nv_magic, ms02nv_magicp);\r\nif (err)\r\nreturn 0;\r\nif (ms02nv_magic != MS02NV_ID)\r\nreturn 0;\r\nms02nv_diag = *ms02nv_diagp;\r\nsize = (ms02nv_diag & MS02NV_DIAG_SIZE_MASK) << MS02NV_DIAG_SIZE_SHIFT;\r\nif (size > MS02NV_CSR)\r\nsize = MS02NV_CSR;\r\nreturn size;\r\n}\r\nstatic int __init ms02nv_init_one(ulong addr)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct ms02nv_private *mp;\r\nstruct resource *mod_res;\r\nstruct resource *diag_res;\r\nstruct resource *user_res;\r\nstruct resource *csr_res;\r\nulong fixaddr;\r\nsize_t size, fixsize;\r\nstatic int version_printed;\r\nint ret = -ENODEV;\r\nmod_res = kzalloc(sizeof(*mod_res), GFP_KERNEL);\r\nif (!mod_res)\r\nreturn -ENOMEM;\r\nmod_res->name = ms02nv_name;\r\nmod_res->start = addr;\r\nmod_res->end = addr + MS02NV_SLOT_SIZE - 1;\r\nmod_res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&iomem_resource, mod_res) < 0)\r\ngoto err_out_mod_res;\r\nsize = ms02nv_probe_one(addr);\r\nif (!size)\r\ngoto err_out_mod_res_rel;\r\nif (!version_printed) {\r\nprintk(KERN_INFO "%s", version);\r\nversion_printed = 1;\r\n}\r\nret = -ENOMEM;\r\nmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\r\nif (!mtd)\r\ngoto err_out_mod_res_rel;\r\nmp = kzalloc(sizeof(*mp), GFP_KERNEL);\r\nif (!mp)\r\ngoto err_out_mtd;\r\nmtd->priv = mp;\r\nmp->resource.module = mod_res;\r\ndiag_res = kzalloc(sizeof(*diag_res), GFP_KERNEL);\r\nif (!diag_res)\r\ngoto err_out_mp;\r\ndiag_res->name = ms02nv_res_diag_ram;\r\ndiag_res->start = addr;\r\ndiag_res->end = addr + MS02NV_RAM - 1;\r\ndiag_res->flags = IORESOURCE_BUSY;\r\nrequest_resource(mod_res, diag_res);\r\nmp->resource.diag_ram = diag_res;\r\nuser_res = kzalloc(sizeof(*user_res), GFP_KERNEL);\r\nif (!user_res)\r\ngoto err_out_diag_res;\r\nuser_res->name = ms02nv_res_user_ram;\r\nuser_res->start = addr + MS02NV_RAM;\r\nuser_res->end = addr + size - 1;\r\nuser_res->flags = IORESOURCE_BUSY;\r\nrequest_resource(mod_res, user_res);\r\nmp->resource.user_ram = user_res;\r\ncsr_res = kzalloc(sizeof(*csr_res), GFP_KERNEL);\r\nif (!csr_res)\r\ngoto err_out_user_res;\r\ncsr_res->name = ms02nv_res_csr;\r\ncsr_res->start = addr + MS02NV_CSR;\r\ncsr_res->end = addr + MS02NV_CSR + 3;\r\ncsr_res->flags = IORESOURCE_BUSY;\r\nrequest_resource(mod_res, csr_res);\r\nmp->resource.csr = csr_res;\r\nmp->addr = phys_to_virt(addr);\r\nmp->size = size;\r\nfixaddr = (addr + MS02NV_RAM + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);\r\nfixsize = (size - (fixaddr - addr)) & ~(PAGE_SIZE - 1);\r\nmp->uaddr = phys_to_virt(fixaddr);\r\nmtd->type = MTD_RAM;\r\nmtd->flags = MTD_CAP_RAM;\r\nmtd->size = fixsize;\r\nmtd->name = (char *)ms02nv_name;\r\nmtd->owner = THIS_MODULE;\r\nmtd->read = ms02nv_read;\r\nmtd->write = ms02nv_write;\r\nmtd->writesize = 1;\r\nret = -EIO;\r\nif (mtd_device_register(mtd, NULL, 0)) {\r\nprintk(KERN_ERR\r\n"ms02-nv: Unable to register MTD device, aborting!\n");\r\ngoto err_out_csr_res;\r\n}\r\nprintk(KERN_INFO "mtd%d: %s at 0x%08lx, size %zuMiB.\n",\r\nmtd->index, ms02nv_name, addr, size >> 20);\r\nmp->next = root_ms02nv_mtd;\r\nroot_ms02nv_mtd = mtd;\r\nreturn 0;\r\nerr_out_csr_res:\r\nrelease_resource(csr_res);\r\nkfree(csr_res);\r\nerr_out_user_res:\r\nrelease_resource(user_res);\r\nkfree(user_res);\r\nerr_out_diag_res:\r\nrelease_resource(diag_res);\r\nkfree(diag_res);\r\nerr_out_mp:\r\nkfree(mp);\r\nerr_out_mtd:\r\nkfree(mtd);\r\nerr_out_mod_res_rel:\r\nrelease_resource(mod_res);\r\nerr_out_mod_res:\r\nkfree(mod_res);\r\nreturn ret;\r\n}\r\nstatic void __exit ms02nv_remove_one(void)\r\n{\r\nstruct mtd_info *mtd = root_ms02nv_mtd;\r\nstruct ms02nv_private *mp = mtd->priv;\r\nroot_ms02nv_mtd = mp->next;\r\nmtd_device_unregister(mtd);\r\nrelease_resource(mp->resource.csr);\r\nkfree(mp->resource.csr);\r\nrelease_resource(mp->resource.user_ram);\r\nkfree(mp->resource.user_ram);\r\nrelease_resource(mp->resource.diag_ram);\r\nkfree(mp->resource.diag_ram);\r\nrelease_resource(mp->resource.module);\r\nkfree(mp->resource.module);\r\nkfree(mp);\r\nkfree(mtd);\r\n}\r\nstatic int __init ms02nv_init(void)\r\n{\r\nvolatile u32 *csr;\r\nuint stride = 0;\r\nint count = 0;\r\nint i;\r\nswitch (mips_machtype) {\r\ncase MACH_DS5000_200:\r\ncsr = (volatile u32 *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CSR);\r\nif (*csr & KN02_CSR_BNK32M)\r\nstride = 2;\r\nbreak;\r\ncase MACH_DS5000_2X0:\r\ncase MACH_DS5900:\r\ncsr = (volatile u32 *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_MCR);\r\nif (*csr & KN03_MCR_BNK32M)\r\nstride = 2;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ms02nv_addrs); i++)\r\nif (!ms02nv_init_one(ms02nv_addrs[i] << stride))\r\ncount++;\r\nreturn (count > 0) ? 0 : -ENODEV;\r\n}\r\nstatic void __exit ms02nv_cleanup(void)\r\n{\r\nwhile (root_ms02nv_mtd)\r\nms02nv_remove_one();\r\n}
