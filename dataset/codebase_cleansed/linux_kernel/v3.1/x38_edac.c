static int how_many_channel(struct pci_dev *pdev)\r\n{\r\nunsigned char capid0_8b;\r\npci_read_config_byte(pdev, X38_CAPID0 + 8, &capid0_8b);\r\nif (capid0_8b & 0x20) {\r\ndebugf0("In single channel mode.\n");\r\nx38_channel_num = 1;\r\n} else {\r\ndebugf0("In dual channel mode.\n");\r\nx38_channel_num = 2;\r\n}\r\nreturn x38_channel_num;\r\n}\r\nstatic unsigned long eccerrlog_syndrome(u64 log)\r\n{\r\nreturn (log & X38_ECCERRLOG_SYNDROME_BITS) >> 16;\r\n}\r\nstatic int eccerrlog_row(int channel, u64 log)\r\n{\r\nreturn ((log & X38_ECCERRLOG_RANK_BITS) >> 27) |\r\n(channel * X38_RANKS_PER_CHANNEL);\r\n}\r\nstatic void x38_clear_error_info(struct mem_ctl_info *mci)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->dev);\r\npci_write_bits16(pdev, X38_ERRSTS, X38_ERRSTS_BITS,\r\nX38_ERRSTS_BITS);\r\n}\r\nstatic u64 x38_readq(const void __iomem *addr)\r\n{\r\nreturn readl(addr) | (((u64)readl(addr + 4)) << 32);\r\n}\r\nstatic void x38_get_and_clear_error_info(struct mem_ctl_info *mci,\r\nstruct x38_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\nvoid __iomem *window = mci->pvt_info;\r\npdev = to_pci_dev(mci->dev);\r\npci_read_config_word(pdev, X38_ERRSTS, &info->errsts);\r\nif (!(info->errsts & X38_ERRSTS_BITS))\r\nreturn;\r\ninfo->eccerrlog[0] = x38_readq(window + X38_C0ECCERRLOG);\r\nif (x38_channel_num == 2)\r\ninfo->eccerrlog[1] = x38_readq(window + X38_C1ECCERRLOG);\r\npci_read_config_word(pdev, X38_ERRSTS, &info->errsts2);\r\nif ((info->errsts ^ info->errsts2) & X38_ERRSTS_BITS) {\r\ninfo->eccerrlog[0] = x38_readq(window + X38_C0ECCERRLOG);\r\nif (x38_channel_num == 2)\r\ninfo->eccerrlog[1] =\r\nx38_readq(window + X38_C1ECCERRLOG);\r\n}\r\nx38_clear_error_info(mci);\r\n}\r\nstatic void x38_process_error_info(struct mem_ctl_info *mci,\r\nstruct x38_error_info *info)\r\n{\r\nint channel;\r\nu64 log;\r\nif (!(info->errsts & X38_ERRSTS_BITS))\r\nreturn;\r\nif ((info->errsts ^ info->errsts2) & X38_ERRSTS_BITS) {\r\nedac_mc_handle_ce_no_info(mci, "UE overwrote CE");\r\ninfo->errsts = info->errsts2;\r\n}\r\nfor (channel = 0; channel < x38_channel_num; channel++) {\r\nlog = info->eccerrlog[channel];\r\nif (log & X38_ECCERRLOG_UE) {\r\nedac_mc_handle_ue(mci, 0, 0,\r\neccerrlog_row(channel, log), "x38 UE");\r\n} else if (log & X38_ECCERRLOG_CE) {\r\nedac_mc_handle_ce(mci, 0, 0,\r\neccerrlog_syndrome(log),\r\neccerrlog_row(channel, log), 0, "x38 CE");\r\n}\r\n}\r\n}\r\nstatic void x38_check(struct mem_ctl_info *mci)\r\n{\r\nstruct x38_error_info info;\r\ndebugf1("MC%d: %s()\n", mci->mc_idx, __func__);\r\nx38_get_and_clear_error_info(mci, &info);\r\nx38_process_error_info(mci, &info);\r\n}\r\nvoid __iomem *x38_map_mchbar(struct pci_dev *pdev)\r\n{\r\nunion {\r\nu64 mchbar;\r\nstruct {\r\nu32 mchbar_low;\r\nu32 mchbar_high;\r\n};\r\n} u;\r\nvoid __iomem *window;\r\npci_read_config_dword(pdev, X38_MCHBAR_LOW, &u.mchbar_low);\r\npci_write_config_dword(pdev, X38_MCHBAR_LOW, u.mchbar_low | 0x1);\r\npci_read_config_dword(pdev, X38_MCHBAR_HIGH, &u.mchbar_high);\r\nu.mchbar &= X38_MCHBAR_MASK;\r\nif (u.mchbar != (resource_size_t)u.mchbar) {\r\nprintk(KERN_ERR\r\n"x38: mmio space beyond accessible range (0x%llx)\n",\r\n(unsigned long long)u.mchbar);\r\nreturn NULL;\r\n}\r\nwindow = ioremap_nocache(u.mchbar, X38_MMR_WINDOW_SIZE);\r\nif (!window)\r\nprintk(KERN_ERR "x38: cannot map mmio space at 0x%llx\n",\r\n(unsigned long long)u.mchbar);\r\nreturn window;\r\n}\r\nstatic void x38_get_drbs(void __iomem *window,\r\nu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL])\r\n{\r\nint i;\r\nfor (i = 0; i < X38_RANKS_PER_CHANNEL; i++) {\r\ndrbs[0][i] = readw(window + X38_C0DRB + 2*i) & X38_DRB_MASK;\r\ndrbs[1][i] = readw(window + X38_C1DRB + 2*i) & X38_DRB_MASK;\r\n}\r\n}\r\nstatic bool x38_is_stacked(struct pci_dev *pdev,\r\nu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL])\r\n{\r\nu16 tom;\r\npci_read_config_word(pdev, X38_TOM, &tom);\r\ntom &= X38_TOM_MASK;\r\nreturn drbs[X38_CHANNELS - 1][X38_RANKS_PER_CHANNEL - 1] == tom;\r\n}\r\nstatic unsigned long drb_to_nr_pages(\r\nu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL],\r\nbool stacked, int channel, int rank)\r\n{\r\nint n;\r\nn = drbs[channel][rank];\r\nif (rank > 0)\r\nn -= drbs[channel][rank - 1];\r\nif (stacked && (channel == 1) && drbs[channel][rank] ==\r\ndrbs[channel][X38_RANKS_PER_CHANNEL - 1]) {\r\nn -= drbs[0][X38_RANKS_PER_CHANNEL - 1];\r\n}\r\nn <<= (X38_DRB_SHIFT - PAGE_SHIFT);\r\nreturn n;\r\n}\r\nstatic int x38_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nint rc;\r\nint i;\r\nstruct mem_ctl_info *mci = NULL;\r\nunsigned long last_page;\r\nu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL];\r\nbool stacked;\r\nvoid __iomem *window;\r\ndebugf0("MC: %s()\n", __func__);\r\nwindow = x38_map_mchbar(pdev);\r\nif (!window)\r\nreturn -ENODEV;\r\nx38_get_drbs(window, drbs);\r\nhow_many_channel(pdev);\r\nmci = edac_mc_alloc(0, X38_RANKS, x38_channel_num, 0);\r\nif (!mci)\r\nreturn -ENOMEM;\r\ndebugf3("MC: %s(): init mci\n", __func__);\r\nmci->dev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = X38_REVISION;\r\nmci->ctl_name = x38_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = x38_check;\r\nmci->ctl_page_to_phys = NULL;\r\nmci->pvt_info = window;\r\nstacked = x38_is_stacked(pdev, drbs);\r\nlast_page = -1UL;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nunsigned long nr_pages;\r\nstruct csrow_info *csrow = &mci->csrows[i];\r\nnr_pages = drb_to_nr_pages(drbs, stacked,\r\ni / X38_RANKS_PER_CHANNEL,\r\ni % X38_RANKS_PER_CHANNEL);\r\nif (nr_pages == 0) {\r\ncsrow->mtype = MEM_EMPTY;\r\ncontinue;\r\n}\r\ncsrow->first_page = last_page + 1;\r\nlast_page += nr_pages;\r\ncsrow->last_page = last_page;\r\ncsrow->nr_pages = nr_pages;\r\ncsrow->grain = nr_pages << PAGE_SHIFT;\r\ncsrow->mtype = MEM_DDR2;\r\ncsrow->dtype = DEV_UNKNOWN;\r\ncsrow->edac_mode = EDAC_UNKNOWN;\r\n}\r\nx38_clear_error_info(mci);\r\nrc = -ENODEV;\r\nif (edac_mc_add_mc(mci)) {\r\ndebugf3("MC: %s(): failed edac_mc_add_mc()\n", __func__);\r\ngoto fail;\r\n}\r\ndebugf3("MC: %s(): success\n", __func__);\r\nreturn 0;\r\nfail:\r\niounmap(window);\r\nif (mci)\r\nedac_mc_free(mci);\r\nreturn rc;\r\n}\r\nstatic int __devinit x38_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint rc;\r\ndebugf0("MC: %s()\n", __func__);\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nrc = x38_probe1(pdev, ent->driver_data);\r\nif (!mci_pdev)\r\nmci_pdev = pci_dev_get(pdev);\r\nreturn rc;\r\n}\r\nstatic void __devexit x38_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\ndebugf0("%s()\n", __func__);\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\niounmap(mci->pvt_info);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init x38_init(void)\r\n{\r\nint pci_rc;\r\ndebugf3("MC: %s()\n", __func__);\r\nopstate_init();\r\npci_rc = pci_register_driver(&x38_driver);\r\nif (pci_rc < 0)\r\ngoto fail0;\r\nif (!mci_pdev) {\r\nx38_registered = 0;\r\nmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_X38_HB, NULL);\r\nif (!mci_pdev) {\r\ndebugf0("x38 pci_get_device fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\npci_rc = x38_init_one(mci_pdev, x38_pci_tbl);\r\nif (pci_rc < 0) {\r\ndebugf0("x38 init fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\npci_unregister_driver(&x38_driver);\r\nfail0:\r\nif (mci_pdev)\r\npci_dev_put(mci_pdev);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit x38_exit(void)\r\n{\r\ndebugf3("MC: %s()\n", __func__);\r\npci_unregister_driver(&x38_driver);\r\nif (!x38_registered) {\r\nx38_remove_one(mci_pdev);\r\npci_dev_put(mci_pdev);\r\n}\r\n}
