static void wdt_timer_ping(unsigned long data)\r\n{\r\nif (time_before(jiffies, next_heartbeat)) {\r\nspin_lock(&wdt_spinlock);\r\ninb_p(WDT_PING);\r\nmod_timer(&timer, jiffies + WDT_INTERVAL);\r\nspin_unlock(&wdt_spinlock);\r\n} else\r\nprintk(KERN_WARNING PFX\r\n"Heartbeat lost! Will not ping the watchdog\n");\r\n}\r\nstatic void wdt_change(int writeval)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt_spinlock, flags);\r\ninb_p(WDT_PING);\r\noutb_p(ENABLE_W83877F, ENABLE_W83877F_PORT);\r\noutb_p(ENABLE_W83877F, ENABLE_W83877F_PORT);\r\noutb_p(WDT_REGISTER, ENABLE_W83877F_PORT);\r\noutb_p(writeval, ENABLE_W83877F_PORT+1);\r\noutb_p(DISABLE_W83877F, ENABLE_W83877F_PORT);\r\nspin_unlock_irqrestore(&wdt_spinlock, flags);\r\n}\r\nstatic void wdt_startup(void)\r\n{\r\nnext_heartbeat = jiffies + (timeout * HZ);\r\nmod_timer(&timer, jiffies + WDT_INTERVAL);\r\nwdt_change(WDT_ENABLE);\r\nprintk(KERN_INFO PFX "Watchdog timer is now enabled.\n");\r\n}\r\nstatic void wdt_turnoff(void)\r\n{\r\ndel_timer(&timer);\r\nwdt_change(WDT_DISABLE);\r\nprintk(KERN_INFO PFX "Watchdog timer is now disabled...\n");\r\n}\r\nstatic void wdt_keepalive(void)\r\n{\r\nnext_heartbeat = jiffies + (timeout * HZ);\r\n}\r\nstatic ssize_t fop_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t ofs;\r\nwdt_expect_close = 0;\r\nfor (ofs = 0; ofs != count; ofs++) {\r\nchar c;\r\nif (get_user(c, buf + ofs))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nwdt_expect_close = 42;\r\n}\r\n}\r\nwdt_keepalive();\r\n}\r\nreturn count;\r\n}\r\nstatic int fop_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &wdt_is_open))\r\nreturn -EBUSY;\r\nwdt_startup();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int fop_close(struct inode *inode, struct file *file)\r\n{\r\nif (wdt_expect_close == 42)\r\nwdt_turnoff();\r\nelse {\r\ndel_timer(&timer);\r\nprintk(KERN_CRIT PFX\r\n"device file closed unexpectedly. Will not stop the WDT!\n");\r\n}\r\nclear_bit(0, &wdt_is_open);\r\nwdt_expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic long fop_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT\r\n| WDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = "W83877F",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint new_options, retval = -EINVAL;\r\nif (get_user(new_options, p))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD) {\r\nwdt_turnoff();\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_ENABLECARD) {\r\nwdt_startup();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nwdt_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\n{\r\nint new_timeout;\r\nif (get_user(new_timeout, p))\r\nreturn -EFAULT;\r\nif (new_timeout < 1 || new_timeout > 3600)\r\nreturn -EINVAL;\r\ntimeout = new_timeout;\r\nwdt_keepalive();\r\n}\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdt_turnoff();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __exit w83877f_wdt_unload(void)\r\n{\r\nwdt_turnoff();\r\nmisc_deregister(&wdt_miscdev);\r\nunregister_reboot_notifier(&wdt_notifier);\r\nrelease_region(WDT_PING, 1);\r\nrelease_region(ENABLE_W83877F_PORT, 2);\r\n}\r\nstatic int __init w83877f_wdt_init(void)\r\n{\r\nint rc = -EBUSY;\r\nif (timeout < 1 || timeout > 3600) {\r\ntimeout = WATCHDOG_TIMEOUT;\r\nprintk(KERN_INFO PFX\r\n"timeout value must be 1 <= x <= 3600, using %d\n",\r\ntimeout);\r\n}\r\nif (!request_region(ENABLE_W83877F_PORT, 2, "W83877F WDT")) {\r\nprintk(KERN_ERR PFX "I/O address 0x%04x already in use\n",\r\nENABLE_W83877F_PORT);\r\nrc = -EIO;\r\ngoto err_out;\r\n}\r\nif (!request_region(WDT_PING, 1, "W8387FF WDT")) {\r\nprintk(KERN_ERR PFX "I/O address 0x%04x already in use\n",\r\nWDT_PING);\r\nrc = -EIO;\r\ngoto err_out_region1;\r\n}\r\nrc = register_reboot_notifier(&wdt_notifier);\r\nif (rc) {\r\nprintk(KERN_ERR PFX\r\n"cannot register reboot notifier (err=%d)\n", rc);\r\ngoto err_out_region2;\r\n}\r\nrc = misc_register(&wdt_miscdev);\r\nif (rc) {\r\nprintk(KERN_ERR PFX\r\n"cannot register miscdev on minor=%d (err=%d)\n",\r\nwdt_miscdev.minor, rc);\r\ngoto err_out_reboot;\r\n}\r\nprintk(KERN_INFO PFX\r\n"WDT driver for W83877F initialised. timeout=%d sec (nowayout=%d)\n",\r\ntimeout, nowayout);\r\nreturn 0;\r\nerr_out_reboot:\r\nunregister_reboot_notifier(&wdt_notifier);\r\nerr_out_region2:\r\nrelease_region(WDT_PING, 1);\r\nerr_out_region1:\r\nrelease_region(ENABLE_W83877F_PORT, 2);\r\nerr_out:\r\nreturn rc;\r\n}
