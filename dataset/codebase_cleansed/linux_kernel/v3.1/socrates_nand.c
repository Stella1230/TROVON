static void socrates_nand_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nstruct socrates_nand_host *host = this->priv;\r\nfor (i = 0; i < len; i++) {\r\nout_be32(host->io_base, FPGA_NAND_ENABLE |\r\nFPGA_NAND_CMD_WRITE |\r\n(buf[i] << FPGA_NAND_DATA_SHIFT));\r\n}\r\n}\r\nstatic void socrates_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nstruct socrates_nand_host *host = this->priv;\r\nuint32_t val;\r\nval = FPGA_NAND_ENABLE | FPGA_NAND_CMD_READ;\r\nout_be32(host->io_base, val);\r\nfor (i = 0; i < len; i++) {\r\nbuf[i] = (in_be32(host->io_base) >>\r\nFPGA_NAND_DATA_SHIFT) & 0xff;\r\n}\r\n}\r\nstatic uint8_t socrates_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nuint8_t byte;\r\nsocrates_nand_read_buf(mtd, &byte, sizeof(byte));\r\nreturn byte;\r\n}\r\nstatic uint16_t socrates_nand_read_word(struct mtd_info *mtd)\r\n{\r\nuint16_t word;\r\nsocrates_nand_read_buf(mtd, (uint8_t *)&word, sizeof(word));\r\nreturn word;\r\n}\r\nstatic int socrates_nand_verify_buf(struct mtd_info *mtd, const u8 *buf,\r\nint len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nif (buf[i] != socrates_nand_read_byte(mtd))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void socrates_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct socrates_nand_host *host = nand_chip->priv;\r\nuint32_t val;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nval = FPGA_NAND_CMD_COMMAND;\r\nelse\r\nval = FPGA_NAND_CMD_ADDR;\r\nif (ctrl & NAND_NCE)\r\nval |= FPGA_NAND_ENABLE;\r\nval |= (cmd & 0xff) << FPGA_NAND_DATA_SHIFT;\r\nout_be32(host->io_base, val);\r\n}\r\nstatic int socrates_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct socrates_nand_host *host = nand_chip->priv;\r\nif (in_be32(host->io_base) & FPGA_NAND_BUSY)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int __devinit socrates_nand_probe(struct platform_device *ofdev)\r\n{\r\nstruct socrates_nand_host *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand_chip;\r\nint res;\r\nstruct mtd_partition *partitions = NULL;\r\nint num_partitions = 0;\r\nhost = kzalloc(sizeof(struct socrates_nand_host), GFP_KERNEL);\r\nif (!host) {\r\nprintk(KERN_ERR\r\n"socrates_nand: failed to allocate device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nhost->io_base = of_iomap(ofdev->dev.of_node, 0);\r\nif (host->io_base == NULL) {\r\nprintk(KERN_ERR "socrates_nand: ioremap failed\n");\r\nkfree(host);\r\nreturn -EIO;\r\n}\r\nmtd = &host->mtd;\r\nnand_chip = &host->nand_chip;\r\nhost->dev = &ofdev->dev;\r\nnand_chip->priv = host;\r\nmtd->priv = nand_chip;\r\nmtd->name = "socrates_nand";\r\nmtd->owner = THIS_MODULE;\r\nmtd->dev.parent = &ofdev->dev;\r\nnand_chip->IO_ADDR_R = (void *)0xdeadbeef;\r\nnand_chip->IO_ADDR_W = (void *)0xdeadbeef;\r\nnand_chip->cmd_ctrl = socrates_nand_cmd_ctrl;\r\nnand_chip->read_byte = socrates_nand_read_byte;\r\nnand_chip->read_word = socrates_nand_read_word;\r\nnand_chip->write_buf = socrates_nand_write_buf;\r\nnand_chip->read_buf = socrates_nand_read_buf;\r\nnand_chip->verify_buf = socrates_nand_verify_buf;\r\nnand_chip->dev_ready = socrates_nand_device_ready;\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nnand_chip->chip_delay = 20;\r\ndev_set_drvdata(&ofdev->dev, host);\r\nif (nand_scan_ident(mtd, 1, NULL)) {\r\nres = -ENXIO;\r\ngoto out;\r\n}\r\nif (nand_scan_tail(mtd)) {\r\nres = -ENXIO;\r\ngoto out;\r\n}\r\n#ifdef CONFIG_MTD_CMDLINE_PARTS\r\nnum_partitions = parse_mtd_partitions(mtd, part_probes,\r\n&partitions, 0);\r\nif (num_partitions < 0) {\r\nres = num_partitions;\r\ngoto release;\r\n}\r\n#endif\r\nif (num_partitions == 0) {\r\nnum_partitions = of_mtd_parse_partitions(&ofdev->dev,\r\nofdev->dev.of_node,\r\n&partitions);\r\nif (num_partitions < 0) {\r\nres = num_partitions;\r\ngoto release;\r\n}\r\n}\r\nres = mtd_device_register(mtd, partitions, num_partitions);\r\nif (!res)\r\nreturn res;\r\nrelease:\r\nnand_release(mtd);\r\nout:\r\ndev_set_drvdata(&ofdev->dev, NULL);\r\niounmap(host->io_base);\r\nkfree(host);\r\nreturn res;\r\n}\r\nstatic int __devexit socrates_nand_remove(struct platform_device *ofdev)\r\n{\r\nstruct socrates_nand_host *host = dev_get_drvdata(&ofdev->dev);\r\nstruct mtd_info *mtd = &host->mtd;\r\nnand_release(mtd);\r\ndev_set_drvdata(&ofdev->dev, NULL);\r\niounmap(host->io_base);\r\nkfree(host);\r\nreturn 0;\r\n}\r\nstatic int __init socrates_nand_init(void)\r\n{\r\nreturn platform_driver_register(&socrates_nand_driver);\r\n}\r\nstatic void __exit socrates_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&socrates_nand_driver);\r\n}
