static int tda18271_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nenum tda18271_i2c_gate gate;\r\nint ret = 0;\r\nswitch (priv->gate) {\r\ncase TDA18271_GATE_DIGITAL:\r\ncase TDA18271_GATE_ANALOG:\r\ngate = priv->gate;\r\nbreak;\r\ncase TDA18271_GATE_AUTO:\r\ndefault:\r\nswitch (priv->mode) {\r\ncase TDA18271_DIGITAL:\r\ngate = TDA18271_GATE_DIGITAL;\r\nbreak;\r\ncase TDA18271_ANALOG:\r\ndefault:\r\ngate = TDA18271_GATE_ANALOG;\r\nbreak;\r\n}\r\n}\r\nswitch (gate) {\r\ncase TDA18271_GATE_ANALOG:\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nret = fe->ops.analog_ops.i2c_gate_ctrl(fe, enable);\r\nbreak;\r\ncase TDA18271_GATE_DIGITAL:\r\nif (fe->ops.i2c_gate_ctrl)\r\nret = fe->ops.i2c_gate_ctrl(fe, enable);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void tda18271_dump_regs(struct dvb_frontend *fe, int extended)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\ntda_reg("=== TDA18271 REG DUMP ===\n");\r\ntda_reg("ID_BYTE = 0x%02x\n", 0xff & regs[R_ID]);\r\ntda_reg("THERMO_BYTE = 0x%02x\n", 0xff & regs[R_TM]);\r\ntda_reg("POWER_LEVEL_BYTE = 0x%02x\n", 0xff & regs[R_PL]);\r\ntda_reg("EASY_PROG_BYTE_1 = 0x%02x\n", 0xff & regs[R_EP1]);\r\ntda_reg("EASY_PROG_BYTE_2 = 0x%02x\n", 0xff & regs[R_EP2]);\r\ntda_reg("EASY_PROG_BYTE_3 = 0x%02x\n", 0xff & regs[R_EP3]);\r\ntda_reg("EASY_PROG_BYTE_4 = 0x%02x\n", 0xff & regs[R_EP4]);\r\ntda_reg("EASY_PROG_BYTE_5 = 0x%02x\n", 0xff & regs[R_EP5]);\r\ntda_reg("CAL_POST_DIV_BYTE = 0x%02x\n", 0xff & regs[R_CPD]);\r\ntda_reg("CAL_DIV_BYTE_1 = 0x%02x\n", 0xff & regs[R_CD1]);\r\ntda_reg("CAL_DIV_BYTE_2 = 0x%02x\n", 0xff & regs[R_CD2]);\r\ntda_reg("CAL_DIV_BYTE_3 = 0x%02x\n", 0xff & regs[R_CD3]);\r\ntda_reg("MAIN_POST_DIV_BYTE = 0x%02x\n", 0xff & regs[R_MPD]);\r\ntda_reg("MAIN_DIV_BYTE_1 = 0x%02x\n", 0xff & regs[R_MD1]);\r\ntda_reg("MAIN_DIV_BYTE_2 = 0x%02x\n", 0xff & regs[R_MD2]);\r\ntda_reg("MAIN_DIV_BYTE_3 = 0x%02x\n", 0xff & regs[R_MD3]);\r\nif (!(tda18271_debug & DBG_ADV))\r\nreturn;\r\ntda_reg("EXTENDED_BYTE_1 = 0x%02x\n", 0xff & regs[R_EB1]);\r\ntda_reg("EXTENDED_BYTE_2 = 0x%02x\n", 0xff & regs[R_EB2]);\r\ntda_reg("EXTENDED_BYTE_3 = 0x%02x\n", 0xff & regs[R_EB3]);\r\ntda_reg("EXTENDED_BYTE_4 = 0x%02x\n", 0xff & regs[R_EB4]);\r\ntda_reg("EXTENDED_BYTE_5 = 0x%02x\n", 0xff & regs[R_EB5]);\r\ntda_reg("EXTENDED_BYTE_6 = 0x%02x\n", 0xff & regs[R_EB6]);\r\ntda_reg("EXTENDED_BYTE_7 = 0x%02x\n", 0xff & regs[R_EB7]);\r\ntda_reg("EXTENDED_BYTE_8 = 0x%02x\n", 0xff & regs[R_EB8]);\r\ntda_reg("EXTENDED_BYTE_9 W = 0x%02x\n", 0xff & regs[R_EB9]);\r\ntda_reg("EXTENDED_BYTE_10 = 0x%02x\n", 0xff & regs[R_EB10]);\r\ntda_reg("EXTENDED_BYTE_11 = 0x%02x\n", 0xff & regs[R_EB11]);\r\ntda_reg("EXTENDED_BYTE_12 = 0x%02x\n", 0xff & regs[R_EB12]);\r\ntda_reg("EXTENDED_BYTE_13 = 0x%02x\n", 0xff & regs[R_EB13]);\r\ntda_reg("EXTENDED_BYTE_14 = 0x%02x\n", 0xff & regs[R_EB14]);\r\ntda_reg("EXTENDED_BYTE_15 = 0x%02x\n", 0xff & regs[R_EB15]);\r\ntda_reg("EXTENDED_BYTE_16 W = 0x%02x\n", 0xff & regs[R_EB16]);\r\ntda_reg("EXTENDED_BYTE_17 W = 0x%02x\n", 0xff & regs[R_EB17]);\r\ntda_reg("EXTENDED_BYTE_18 = 0x%02x\n", 0xff & regs[R_EB18]);\r\ntda_reg("EXTENDED_BYTE_19 W = 0x%02x\n", 0xff & regs[R_EB19]);\r\ntda_reg("EXTENDED_BYTE_20 W = 0x%02x\n", 0xff & regs[R_EB20]);\r\ntda_reg("EXTENDED_BYTE_21 = 0x%02x\n", 0xff & regs[R_EB21]);\r\ntda_reg("EXTENDED_BYTE_22 = 0x%02x\n", 0xff & regs[R_EB22]);\r\ntda_reg("EXTENDED_BYTE_23 = 0x%02x\n", 0xff & regs[R_EB23]);\r\n}\r\nint tda18271_read_regs(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nunsigned char buf = 0x00;\r\nint ret;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = priv->i2c_props.addr, .flags = 0,\r\n.buf = &buf, .len = 1 },\r\n{ .addr = priv->i2c_props.addr, .flags = I2C_M_RD,\r\n.buf = regs, .len = 16 }\r\n};\r\ntda18271_i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(priv->i2c_props.adap, msg, 2);\r\ntda18271_i2c_gate_ctrl(fe, 0);\r\nif (ret != 2)\r\ntda_err("ERROR: i2c_transfer returned: %d\n", ret);\r\nif (tda18271_debug & DBG_REG)\r\ntda18271_dump_regs(fe, 0);\r\nreturn (ret == 2 ? 0 : ret);\r\n}\r\nint tda18271_read_extended(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nunsigned char regdump[TDA18271_NUM_REGS];\r\nunsigned char buf = 0x00;\r\nint ret, i;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = priv->i2c_props.addr, .flags = 0,\r\n.buf = &buf, .len = 1 },\r\n{ .addr = priv->i2c_props.addr, .flags = I2C_M_RD,\r\n.buf = regdump, .len = TDA18271_NUM_REGS }\r\n};\r\ntda18271_i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(priv->i2c_props.adap, msg, 2);\r\ntda18271_i2c_gate_ctrl(fe, 0);\r\nif (ret != 2)\r\ntda_err("ERROR: i2c_transfer returned: %d\n", ret);\r\nfor (i = 0; i < TDA18271_NUM_REGS; i++) {\r\nif ((i != R_EB9) &&\r\n(i != R_EB16) &&\r\n(i != R_EB17) &&\r\n(i != R_EB19) &&\r\n(i != R_EB20))\r\nregs[i] = regdump[i];\r\n}\r\nif (tda18271_debug & DBG_REG)\r\ntda18271_dump_regs(fe, 1);\r\nreturn (ret == 2 ? 0 : ret);\r\n}\r\nint tda18271_write_regs(struct dvb_frontend *fe, int idx, int len)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nunsigned char buf[TDA18271_NUM_REGS + 1];\r\nstruct i2c_msg msg = { .addr = priv->i2c_props.addr, .flags = 0,\r\n.buf = buf };\r\nint i, ret = 1, max;\r\nBUG_ON((len == 0) || (idx + len > sizeof(buf)));\r\nswitch (priv->small_i2c) {\r\ncase TDA18271_03_BYTE_CHUNK_INIT:\r\nmax = 3;\r\nbreak;\r\ncase TDA18271_08_BYTE_CHUNK_INIT:\r\nmax = 8;\r\nbreak;\r\ncase TDA18271_16_BYTE_CHUNK_INIT:\r\nmax = 16;\r\nbreak;\r\ncase TDA18271_39_BYTE_CHUNK_INIT:\r\ndefault:\r\nmax = 39;\r\n}\r\ntda18271_i2c_gate_ctrl(fe, 1);\r\nwhile (len) {\r\nif (max > len)\r\nmax = len;\r\nbuf[0] = idx;\r\nfor (i = 1; i <= max; i++)\r\nbuf[i] = regs[idx - 1 + i];\r\nmsg.len = max + 1;\r\nret = i2c_transfer(priv->i2c_props.adap, &msg, 1);\r\nif (ret != 1)\r\nbreak;\r\nidx += max;\r\nlen -= max;\r\n}\r\ntda18271_i2c_gate_ctrl(fe, 0);\r\nif (ret != 1)\r\ntda_err("ERROR: idx = 0x%x, len = %d, "\r\n"i2c_transfer returned: %d\n", idx, max, ret);\r\nreturn (ret == 1 ? 0 : ret);\r\n}\r\nint tda18271_charge_pump_source(struct dvb_frontend *fe,\r\nenum tda18271_pll pll, int force)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint r_cp = (pll == TDA18271_CAL_PLL) ? R_EB7 : R_EB4;\r\nregs[r_cp] &= ~0x20;\r\nregs[r_cp] |= ((force & 1) << 5);\r\nreturn tda18271_write_regs(fe, r_cp, 1);\r\n}\r\nint tda18271_init_regs(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\ntda_dbg("initializing registers for device @ %d-%04x\n",\r\ni2c_adapter_id(priv->i2c_props.adap),\r\npriv->i2c_props.addr);\r\nswitch (priv->id) {\r\ncase TDA18271HDC1:\r\nregs[R_ID] = 0x83;\r\nbreak;\r\ncase TDA18271HDC2:\r\nregs[R_ID] = 0x84;\r\nbreak;\r\n};\r\nregs[R_TM] = 0x08;\r\nregs[R_PL] = 0x80;\r\nregs[R_EP1] = 0xc6;\r\nregs[R_EP2] = 0xdf;\r\nregs[R_EP3] = 0x16;\r\nregs[R_EP4] = 0x60;\r\nregs[R_EP5] = 0x80;\r\nregs[R_CPD] = 0x80;\r\nregs[R_CD1] = 0x00;\r\nregs[R_CD2] = 0x00;\r\nregs[R_CD3] = 0x00;\r\nregs[R_MPD] = 0x00;\r\nregs[R_MD1] = 0x00;\r\nregs[R_MD2] = 0x00;\r\nregs[R_MD3] = 0x00;\r\nswitch (priv->id) {\r\ncase TDA18271HDC1:\r\nregs[R_EB1] = 0xff;\r\nbreak;\r\ncase TDA18271HDC2:\r\nregs[R_EB1] = 0xfc;\r\nbreak;\r\n};\r\nregs[R_EB2] = 0x01;\r\nregs[R_EB3] = 0x84;\r\nregs[R_EB4] = 0x41;\r\nregs[R_EB5] = 0x01;\r\nregs[R_EB6] = 0x84;\r\nregs[R_EB7] = 0x40;\r\nregs[R_EB8] = 0x07;\r\nregs[R_EB9] = 0x00;\r\nregs[R_EB10] = 0x00;\r\nregs[R_EB11] = 0x96;\r\nswitch (priv->id) {\r\ncase TDA18271HDC1:\r\nregs[R_EB12] = 0x0f;\r\nbreak;\r\ncase TDA18271HDC2:\r\nregs[R_EB12] = 0x33;\r\nbreak;\r\n};\r\nregs[R_EB13] = 0xc1;\r\nregs[R_EB14] = 0x00;\r\nregs[R_EB15] = 0x8f;\r\nregs[R_EB16] = 0x00;\r\nregs[R_EB17] = 0x00;\r\nswitch (priv->id) {\r\ncase TDA18271HDC1:\r\nregs[R_EB18] = 0x00;\r\nbreak;\r\ncase TDA18271HDC2:\r\nregs[R_EB18] = 0x8c;\r\nbreak;\r\n};\r\nregs[R_EB19] = 0x00;\r\nregs[R_EB20] = 0x20;\r\nswitch (priv->id) {\r\ncase TDA18271HDC1:\r\nregs[R_EB21] = 0x33;\r\nbreak;\r\ncase TDA18271HDC2:\r\nregs[R_EB21] = 0xb3;\r\nbreak;\r\n};\r\nregs[R_EB22] = 0x48;\r\nregs[R_EB23] = 0xb0;\r\ntda18271_write_regs(fe, 0x00, TDA18271_NUM_REGS);\r\nregs[R_EB17] = 0x00;\r\ntda18271_write_regs(fe, R_EB17, 1);\r\nregs[R_EB17] = 0x03;\r\ntda18271_write_regs(fe, R_EB17, 1);\r\nregs[R_EB17] = 0x43;\r\ntda18271_write_regs(fe, R_EB17, 1);\r\nregs[R_EB17] = 0x4c;\r\ntda18271_write_regs(fe, R_EB17, 1);\r\nif ((priv->id) == TDA18271HDC1) {\r\nregs[R_EB20] = 0xa0;\r\ntda18271_write_regs(fe, R_EB20, 1);\r\nregs[R_EB20] = 0xa7;\r\ntda18271_write_regs(fe, R_EB20, 1);\r\nregs[R_EB20] = 0xe7;\r\ntda18271_write_regs(fe, R_EB20, 1);\r\nregs[R_EB20] = 0xec;\r\ntda18271_write_regs(fe, R_EB20, 1);\r\n}\r\nregs[R_EP3] = 0x1f;\r\nregs[R_EP4] = 0x66;\r\nregs[R_EP5] = 0x81;\r\nregs[R_CPD] = 0xcc;\r\nregs[R_CD1] = 0x6c;\r\nregs[R_CD2] = 0x00;\r\nregs[R_CD3] = 0x00;\r\nregs[R_MPD] = 0xcd;\r\nregs[R_MD1] = 0x77;\r\nregs[R_MD2] = 0x08;\r\nregs[R_MD3] = 0x00;\r\ntda18271_write_regs(fe, R_EP3, 11);\r\nif ((priv->id) == TDA18271HDC2) {\r\ntda18271_charge_pump_source(fe, TDA18271_MAIN_PLL, 1);\r\nmsleep(1);\r\ntda18271_charge_pump_source(fe, TDA18271_MAIN_PLL, 0);\r\n}\r\nmsleep(5);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\nmsleep(5);\r\nregs[R_EP5] = 0x85;\r\nregs[R_CPD] = 0xcb;\r\nregs[R_CD1] = 0x66;\r\nregs[R_CD2] = 0x70;\r\ntda18271_write_regs(fe, R_EP3, 7);\r\nmsleep(5);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\nmsleep(30);\r\nregs[R_EP5] = 0x82;\r\nregs[R_CPD] = 0xa8;\r\nregs[R_CD2] = 0x00;\r\nregs[R_MPD] = 0xa9;\r\nregs[R_MD1] = 0x73;\r\nregs[R_MD2] = 0x1a;\r\ntda18271_write_regs(fe, R_EP3, 11);\r\nmsleep(5);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\nmsleep(5);\r\nregs[R_EP5] = 0x86;\r\nregs[R_CPD] = 0xa8;\r\nregs[R_CD1] = 0x66;\r\nregs[R_CD2] = 0xa0;\r\ntda18271_write_regs(fe, R_EP3, 7);\r\nmsleep(5);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\nmsleep(30);\r\nregs[R_EP5] = 0x83;\r\nregs[R_CPD] = 0x98;\r\nregs[R_CD1] = 0x65;\r\nregs[R_CD2] = 0x00;\r\nregs[R_MPD] = 0x99;\r\nregs[R_MD1] = 0x71;\r\nregs[R_MD2] = 0xcd;\r\ntda18271_write_regs(fe, R_EP3, 11);\r\nmsleep(5);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\nmsleep(5);\r\nregs[R_EP5] = 0x87;\r\nregs[R_CD1] = 0x65;\r\nregs[R_CD2] = 0x50;\r\ntda18271_write_regs(fe, R_EP3, 7);\r\nmsleep(5);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\nmsleep(30);\r\nregs[R_EP4] = 0x64;\r\ntda18271_write_regs(fe, R_EP4, 1);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\nreturn 0;\r\n}\r\nint tda18271_set_standby_mode(struct dvb_frontend *fe,\r\nint sm, int sm_lt, int sm_xt)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nif (tda18271_debug & DBG_ADV)\r\ntda_dbg("sm = %d, sm_lt = %d, sm_xt = %d\n", sm, sm_lt, sm_xt);\r\nregs[R_EP3] &= ~0xe0;\r\nregs[R_EP3] |= (sm ? (1 << 7) : 0) |\r\n(sm_lt ? (1 << 6) : 0) |\r\n(sm_xt ? (1 << 5) : 0);\r\nreturn tda18271_write_regs(fe, R_EP3, 1);\r\n}\r\nint tda18271_calc_main_pll(struct dvb_frontend *fe, u32 freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu8 d, pd;\r\nu32 div;\r\nint ret = tda18271_lookup_pll_map(fe, MAIN_PLL, &freq, &pd, &d);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_MPD] = (0x7f & pd);\r\ndiv = ((d * (freq / 1000)) << 7) / 125;\r\nregs[R_MD1] = 0x7f & (div >> 16);\r\nregs[R_MD2] = 0xff & (div >> 8);\r\nregs[R_MD3] = 0xff & div;\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_calc_cal_pll(struct dvb_frontend *fe, u32 freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu8 d, pd;\r\nu32 div;\r\nint ret = tda18271_lookup_pll_map(fe, CAL_PLL, &freq, &pd, &d);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_CPD] = pd;\r\ndiv = ((d * (freq / 1000)) << 7) / 125;\r\nregs[R_CD1] = 0x7f & (div >> 16);\r\nregs[R_CD2] = 0xff & (div >> 8);\r\nregs[R_CD3] = 0xff & div;\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_calc_bp_filter(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu8 val;\r\nint ret = tda18271_lookup_map(fe, BP_FILTER, freq, &val);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EP1] &= ~0x07;\r\nregs[R_EP1] |= (0x07 & val);\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_calc_km(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu8 val;\r\nint ret = tda18271_lookup_map(fe, RF_CAL_KMCO, freq, &val);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EB13] &= ~0x7c;\r\nregs[R_EB13] |= (0x7c & val);\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_calc_rf_band(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu8 val;\r\nint ret = tda18271_lookup_map(fe, RF_BAND, freq, &val);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EP2] &= ~0xe0;\r\nregs[R_EP2] |= (0xe0 & (val << 5));\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_calc_gain_taper(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu8 val;\r\nint ret = tda18271_lookup_map(fe, GAIN_TAPER, freq, &val);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EP2] &= ~0x1f;\r\nregs[R_EP2] |= (0x1f & val);\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_calc_ir_measure(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu8 val;\r\nint ret = tda18271_lookup_map(fe, IR_MEASURE, freq, &val);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EP5] &= ~0x07;\r\nregs[R_EP5] |= (0x07 & val);\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_calc_rf_cal(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu8 val;\r\nint ret = tda18271_lookup_map(fe, RF_CAL, freq, &val);\r\nif (ret < 0)\r\ngoto fail;\r\nregs[R_EB14] = val;\r\nfail:\r\nreturn ret;\r\n}
