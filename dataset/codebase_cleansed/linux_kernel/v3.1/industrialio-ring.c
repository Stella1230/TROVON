static int iio_ring_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct iio_handler *hand\r\n= container_of(inode->i_cdev, struct iio_handler, chrdev);\r\nstruct iio_ring_buffer *rb = hand->private;\r\nfilp->private_data = hand->private;\r\nif (rb->access->mark_in_use)\r\nrb->access->mark_in_use(rb);\r\nreturn 0;\r\n}\r\nstatic int iio_ring_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct cdev *cd = inode->i_cdev;\r\nstruct iio_handler *hand = iio_cdev_to_handler(cd);\r\nstruct iio_ring_buffer *rb = hand->private;\r\nclear_bit(IIO_BUSY_BIT_POS, &rb->access_handler.flags);\r\nif (rb->access->unmark_in_use)\r\nrb->access->unmark_in_use(rb);\r\nreturn 0;\r\n}\r\nstatic ssize_t iio_ring_read_first_n_outer(struct file *filp, char __user *buf,\r\nsize_t n, loff_t *f_ps)\r\n{\r\nstruct iio_ring_buffer *rb = filp->private_data;\r\nif (!rb->access->read_first_n)\r\nreturn -EINVAL;\r\nreturn rb->access->read_first_n(rb, n, buf);\r\n}\r\nstatic unsigned int iio_ring_poll(struct file *filp,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct iio_ring_buffer *rb = filp->private_data;\r\npoll_wait(filp, &rb->pollq, wait);\r\nif (rb->stufftoread)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nvoid iio_ring_access_release(struct device *dev)\r\n{\r\nstruct iio_ring_buffer *buf\r\n= container_of(dev, struct iio_ring_buffer, dev);\r\ncdev_del(&buf->access_handler.chrdev);\r\niio_device_free_chrdev_minor(MINOR(dev->devt));\r\n}\r\nstatic inline int\r\n__iio_request_ring_buffer_chrdev(struct iio_ring_buffer *buf,\r\nstruct module *owner,\r\nint id)\r\n{\r\nint ret;\r\nbuf->access_handler.flags = 0;\r\nbuf->dev.bus = &iio_bus_type;\r\ndevice_initialize(&buf->dev);\r\nret = iio_device_get_chrdev_minor();\r\nif (ret < 0)\r\ngoto error_device_put;\r\nbuf->dev.devt = MKDEV(MAJOR(iio_devt), ret);\r\ndev_set_name(&buf->dev, "%s:buffer%d",\r\ndev_name(buf->dev.parent),\r\nid);\r\nret = device_add(&buf->dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "failed to add the ring dev\n");\r\ngoto error_device_put;\r\n}\r\ncdev_init(&buf->access_handler.chrdev, &iio_ring_fileops);\r\nbuf->access_handler.chrdev.owner = owner;\r\nret = cdev_add(&buf->access_handler.chrdev, buf->dev.devt, 1);\r\nif (ret) {\r\nprintk(KERN_ERR "failed to allocate ring chrdev\n");\r\ngoto error_device_unregister;\r\n}\r\nreturn 0;\r\nerror_device_unregister:\r\ndevice_unregister(&buf->dev);\r\nerror_device_put:\r\nput_device(&buf->dev);\r\nreturn ret;\r\n}\r\nstatic void __iio_free_ring_buffer_chrdev(struct iio_ring_buffer *buf)\r\n{\r\ndevice_unregister(&buf->dev);\r\n}\r\nvoid iio_ring_buffer_init(struct iio_ring_buffer *ring,\r\nstruct iio_dev *dev_info)\r\n{\r\nring->indio_dev = dev_info;\r\nring->access_handler.private = ring;\r\ninit_waitqueue_head(&ring->pollq);\r\n}\r\nstatic ssize_t iio_show_scan_index(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", to_iio_dev_attr(attr)->c->scan_index);\r\n}\r\nstatic ssize_t iio_show_fixed_type(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nreturn sprintf(buf, "%c%d/%d>>%u\n",\r\nthis_attr->c->scan_type.sign,\r\nthis_attr->c->scan_type.realbits,\r\nthis_attr->c->scan_type.storagebits,\r\nthis_attr->c->scan_type.shift);\r\n}\r\nstatic ssize_t iio_scan_el_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nret = iio_scan_mask_query(ring, to_iio_dev_attr(attr)->address);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic int iio_scan_mask_clear(struct iio_ring_buffer *ring, int bit)\r\n{\r\nif (bit > IIO_MAX_SCAN_LENGTH)\r\nreturn -EINVAL;\r\nring->scan_mask &= ~(1 << bit);\r\nring->scan_count--;\r\nreturn 0;\r\n}\r\nstatic ssize_t iio_scan_el_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nint ret = 0;\r\nbool state;\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nstruct iio_dev *indio_dev = ring->indio_dev;\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nstate = !(buf[0] == '0');\r\nmutex_lock(&indio_dev->mlock);\r\nif (indio_dev->currentmode == INDIO_RING_TRIGGERED) {\r\nret = -EBUSY;\r\ngoto error_ret;\r\n}\r\nret = iio_scan_mask_query(ring, this_attr->address);\r\nif (ret < 0)\r\ngoto error_ret;\r\nif (!state && ret) {\r\nret = iio_scan_mask_clear(ring, this_attr->address);\r\nif (ret)\r\ngoto error_ret;\r\n} else if (state && !ret) {\r\nret = iio_scan_mask_set(ring, this_attr->address);\r\nif (ret)\r\ngoto error_ret;\r\n}\r\nerror_ret:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t iio_scan_el_ts_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", ring->scan_timestamp);\r\n}\r\nstatic ssize_t iio_scan_el_ts_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nint ret = 0;\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nstruct iio_dev *indio_dev = ring->indio_dev;\r\nbool state;\r\nstate = !(buf[0] == '0');\r\nmutex_lock(&indio_dev->mlock);\r\nif (indio_dev->currentmode == INDIO_RING_TRIGGERED) {\r\nret = -EBUSY;\r\ngoto error_ret;\r\n}\r\nring->scan_timestamp = state;\r\nerror_ret:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic int iio_ring_add_channel_sysfs(struct iio_ring_buffer *ring,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nint ret;\r\nret = __iio_add_chan_devattr("index", "scan_elements",\r\nchan,\r\n&iio_show_scan_index,\r\nNULL,\r\n0,\r\n0,\r\n&ring->dev,\r\n&ring->scan_el_dev_attr_list);\r\nif (ret)\r\ngoto error_ret;\r\nret = __iio_add_chan_devattr("type", "scan_elements",\r\nchan,\r\n&iio_show_fixed_type,\r\nNULL,\r\n0,\r\n0,\r\n&ring->dev,\r\n&ring->scan_el_dev_attr_list);\r\nif (ret)\r\ngoto error_ret;\r\nif (chan->type != IIO_TIMESTAMP)\r\nret = __iio_add_chan_devattr("en", "scan_elements",\r\nchan,\r\n&iio_scan_el_show,\r\n&iio_scan_el_store,\r\nchan->scan_index,\r\n0,\r\n&ring->dev,\r\n&ring->scan_el_dev_attr_list);\r\nelse\r\nret = __iio_add_chan_devattr("en", "scan_elements",\r\nchan,\r\n&iio_scan_el_ts_show,\r\n&iio_scan_el_ts_store,\r\nchan->scan_index,\r\n0,\r\n&ring->dev,\r\n&ring->scan_el_dev_attr_list);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic void iio_ring_remove_and_free_scan_dev_attr(struct iio_ring_buffer *ring,\r\nstruct iio_dev_attr *p)\r\n{\r\nsysfs_remove_file_from_group(&ring->dev.kobj,\r\n&p->dev_attr.attr, "scan_elements");\r\nkfree(p->dev_attr.attr.name);\r\nkfree(p);\r\n}\r\nstatic void __iio_ring_attr_cleanup(struct iio_ring_buffer *ring)\r\n{\r\nstruct iio_dev_attr *p, *n;\r\nint anydynamic = !list_empty(&ring->scan_el_dev_attr_list);\r\nlist_for_each_entry_safe(p, n,\r\n&ring->scan_el_dev_attr_list, l)\r\niio_ring_remove_and_free_scan_dev_attr(ring, p);\r\nif (ring->scan_el_attrs)\r\nsysfs_remove_group(&ring->dev.kobj,\r\nring->scan_el_attrs);\r\nelse if (anydynamic)\r\nsysfs_remove_group(&ring->dev.kobj,\r\n&iio_scan_el_dummy_group);\r\n}\r\nint iio_ring_buffer_register_ex(struct iio_ring_buffer *ring, int id,\r\nconst struct iio_chan_spec *channels,\r\nint num_channels)\r\n{\r\nint ret, i;\r\nret = __iio_request_ring_buffer_chrdev(ring, ring->owner, id);\r\nif (ret)\r\ngoto error_ret;\r\nif (ring->scan_el_attrs) {\r\nret = sysfs_create_group(&ring->dev.kobj,\r\nring->scan_el_attrs);\r\nif (ret) {\r\ndev_err(&ring->dev,\r\n"Failed to add sysfs scan elements\n");\r\ngoto error_free_ring_buffer_chrdev;\r\n}\r\n} else if (channels) {\r\nret = sysfs_create_group(&ring->dev.kobj,\r\n&iio_scan_el_dummy_group);\r\nif (ret)\r\ngoto error_free_ring_buffer_chrdev;\r\n}\r\nINIT_LIST_HEAD(&ring->scan_el_dev_attr_list);\r\nif (channels) {\r\nfor (i = 0; i < num_channels; i++) {\r\nret = iio_ring_add_channel_sysfs(ring, &channels[i]);\r\nif (ret < 0)\r\ngoto error_cleanup_dynamic;\r\n}\r\n}\r\nreturn 0;\r\nerror_cleanup_dynamic:\r\n__iio_ring_attr_cleanup(ring);\r\nerror_free_ring_buffer_chrdev:\r\n__iio_free_ring_buffer_chrdev(ring);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nvoid iio_ring_buffer_unregister(struct iio_ring_buffer *ring)\r\n{\r\n__iio_ring_attr_cleanup(ring);\r\n__iio_free_ring_buffer_chrdev(ring);\r\n}\r\nssize_t iio_read_ring_length(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nif (ring->access->get_length)\r\nreturn sprintf(buf, "%d\n",\r\nring->access->get_length(ring));\r\nreturn 0;\r\n}\r\nssize_t iio_write_ring_length(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nint ret;\r\nulong val;\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nret = strict_strtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (ring->access->get_length)\r\nif (val == ring->access->get_length(ring))\r\nreturn len;\r\nif (ring->access->set_length) {\r\nring->access->set_length(ring, val);\r\nif (ring->access->mark_param_change)\r\nring->access->mark_param_change(ring);\r\n}\r\nreturn len;\r\n}\r\nssize_t iio_read_ring_bytes_per_datum(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nif (ring->access->get_bytes_per_datum)\r\nreturn sprintf(buf, "%d\n",\r\nring->access->get_bytes_per_datum(ring));\r\nreturn 0;\r\n}\r\nssize_t iio_store_ring_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nint ret;\r\nbool requested_state, current_state;\r\nint previous_mode;\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nstruct iio_dev *dev_info = ring->indio_dev;\r\nmutex_lock(&dev_info->mlock);\r\nprevious_mode = dev_info->currentmode;\r\nrequested_state = !(buf[0] == '0');\r\ncurrent_state = !!(previous_mode & INDIO_ALL_RING_MODES);\r\nif (current_state == requested_state) {\r\nprintk(KERN_INFO "iio-ring, current state requested again\n");\r\ngoto done;\r\n}\r\nif (requested_state) {\r\nif (ring->setup_ops->preenable) {\r\nret = ring->setup_ops->preenable(dev_info);\r\nif (ret) {\r\nprintk(KERN_ERR\r\n"Buffer not started:"\r\n"ring preenable failed\n");\r\ngoto error_ret;\r\n}\r\n}\r\nif (ring->access->request_update) {\r\nret = ring->access->request_update(ring);\r\nif (ret) {\r\nprintk(KERN_INFO\r\n"Buffer not started:"\r\n"ring parameter update failed\n");\r\ngoto error_ret;\r\n}\r\n}\r\nif (ring->access->mark_in_use)\r\nring->access->mark_in_use(ring);\r\nif (dev_info->modes & INDIO_RING_TRIGGERED) {\r\nif (!dev_info->trig) {\r\nprintk(KERN_INFO\r\n"Buffer not started: no trigger\n");\r\nret = -EINVAL;\r\nif (ring->access->unmark_in_use)\r\nring->access->unmark_in_use(ring);\r\ngoto error_ret;\r\n}\r\ndev_info->currentmode = INDIO_RING_TRIGGERED;\r\n} else if (dev_info->modes & INDIO_RING_HARDWARE_BUFFER)\r\ndev_info->currentmode = INDIO_RING_HARDWARE_BUFFER;\r\nelse {\r\nret = -EINVAL;\r\ngoto error_ret;\r\n}\r\nif (ring->setup_ops->postenable) {\r\nret = ring->setup_ops->postenable(dev_info);\r\nif (ret) {\r\nprintk(KERN_INFO\r\n"Buffer not started:"\r\n"postenable failed\n");\r\nif (ring->access->unmark_in_use)\r\nring->access->unmark_in_use(ring);\r\ndev_info->currentmode = previous_mode;\r\nif (ring->setup_ops->postdisable)\r\nring->setup_ops->postdisable(dev_info);\r\ngoto error_ret;\r\n}\r\n}\r\n} else {\r\nif (ring->setup_ops->predisable) {\r\nret = ring->setup_ops->predisable(dev_info);\r\nif (ret)\r\ngoto error_ret;\r\n}\r\nif (ring->access->unmark_in_use)\r\nring->access->unmark_in_use(ring);\r\ndev_info->currentmode = INDIO_DIRECT_MODE;\r\nif (ring->setup_ops->postdisable) {\r\nret = ring->setup_ops->postdisable(dev_info);\r\nif (ret)\r\ngoto error_ret;\r\n}\r\n}\r\ndone:\r\nmutex_unlock(&dev_info->mlock);\r\nreturn len;\r\nerror_ret:\r\nmutex_unlock(&dev_info->mlock);\r\nreturn ret;\r\n}\r\nssize_t iio_show_ring_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_ring_buffer *ring = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", !!(ring->indio_dev->currentmode\r\n& INDIO_ALL_RING_MODES));\r\n}\r\nint iio_sw_ring_preenable(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_ring_buffer *ring = indio_dev->ring;\r\nsize_t size;\r\ndev_dbg(&indio_dev->dev, "%s\n", __func__);\r\nif (!(ring->scan_count || ring->scan_timestamp))\r\nreturn -EINVAL;\r\nif (ring->scan_timestamp)\r\nif (ring->scan_count)\r\nsize = (((ring->scan_count * ring->bpe)\r\n+ sizeof(s64) - 1)\r\n& ~(sizeof(s64) - 1))\r\n+ sizeof(s64);\r\nelse\r\nsize = sizeof(s64);\r\nelse\r\nsize = ring->scan_count * ring->bpe;\r\nring->access->set_bytes_per_datum(ring, size);\r\nreturn 0;\r\n}
