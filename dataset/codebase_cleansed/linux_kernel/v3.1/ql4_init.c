static void ql4xxx_set_mac_number(struct scsi_qla_host *ha)\r\n{\r\nuint32_t value;\r\nuint8_t func_number;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvalue = readw(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nfunc_number = (uint8_t) ((value >> 4) & 0x30);\r\nswitch (value & ISP_CONTROL_FN_MASK) {\r\ncase ISP_CONTROL_FN0_SCSI:\r\nha->mac_index = 1;\r\nbreak;\r\ncase ISP_CONTROL_FN1_SCSI:\r\nha->mac_index = 3;\r\nbreak;\r\ndefault:\r\nDEBUG2(printk("scsi%ld: %s: Invalid function number, "\r\n"ispControlStatus = 0x%x\n", ha->host_no,\r\n__func__, value));\r\nbreak;\r\n}\r\nDEBUG2(printk("scsi%ld: %s: mac_index %d.\n", ha->host_no, __func__,\r\nha->mac_index));\r\n}\r\nvoid qla4xxx_free_ddb(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry)\r\n{\r\nlist_del_init(&ddb_entry->list);\r\nha->fw_ddb_index_map[ddb_entry->fw_ddb_index] =\r\n(struct ddb_entry *) INVALID_ENTRY;\r\nha->tot_ddbs--;\r\nqla4xxx_destroy_sess(ddb_entry);\r\n}\r\nvoid qla4xxx_free_ddb_list(struct scsi_qla_host *ha)\r\n{\r\nstruct list_head *ptr;\r\nstruct ddb_entry *ddb_entry;\r\nwhile (!list_empty(&ha->ddb_list)) {\r\nptr = ha->ddb_list.next;\r\nddb_entry = list_entry(ptr, struct ddb_entry, list);\r\nqla4xxx_free_ddb(ha, ddb_entry);\r\n}\r\n}\r\nstatic void qla4xxx_init_response_q_entries(struct scsi_qla_host *ha)\r\n{\r\nuint16_t cnt;\r\nstruct response *pkt;\r\npkt = (struct response *)ha->response_ptr;\r\nfor (cnt = 0; cnt < RESPONSE_QUEUE_DEPTH; cnt++) {\r\npkt->signature = RESPONSE_PROCESSED;\r\npkt++;\r\n}\r\n}\r\nint qla4xxx_init_rings(struct scsi_qla_host *ha)\r\n{\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->request_out = 0;\r\nha->request_in = 0;\r\nha->request_ptr = &ha->request_ring[ha->request_in];\r\nha->req_q_count = REQUEST_QUEUE_DEPTH;\r\nha->response_in = 0;\r\nha->response_out = 0;\r\nha->response_ptr = &ha->response_ring[ha->response_out];\r\nif (is_qla8022(ha)) {\r\nwritel(0,\r\n(unsigned long __iomem *)&ha->qla4_8xxx_reg->req_q_out);\r\nwritel(0,\r\n(unsigned long __iomem *)&ha->qla4_8xxx_reg->rsp_q_in);\r\nwritel(0,\r\n(unsigned long __iomem *)&ha->qla4_8xxx_reg->rsp_q_out);\r\n} else {\r\nha->shadow_regs->req_q_out = __constant_cpu_to_le32(0);\r\nha->shadow_regs->rsp_q_in = __constant_cpu_to_le32(0);\r\nwmb();\r\nwritel(0, &ha->reg->req_q_in);\r\nwritel(0, &ha->reg->rsp_q_out);\r\nreadl(&ha->reg->rsp_q_out);\r\n}\r\nqla4xxx_init_response_q_entries(ha);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_get_sys_info(struct scsi_qla_host *ha)\r\n{\r\nstruct flash_sys_info *sys_info;\r\ndma_addr_t sys_info_dma;\r\nint status = QLA_ERROR;\r\nsys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),\r\n&sys_info_dma, GFP_KERNEL);\r\nif (sys_info == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",\r\nha->host_no, __func__));\r\ngoto exit_get_sys_info_no_free;\r\n}\r\nmemset(sys_info, 0, sizeof(*sys_info));\r\nif (qla4xxx_get_flash(ha, sys_info_dma, FLASH_OFFSET_SYS_INFO,\r\nsizeof(*sys_info)) != QLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: get_flash FLASH_OFFSET_SYS_INFO "\r\n"failed\n", ha->host_no, __func__));\r\ngoto exit_get_sys_info;\r\n}\r\nmemcpy(ha->my_mac, &sys_info->physAddr[0].address[0],\r\nmin(sizeof(ha->my_mac),\r\nsizeof(sys_info->physAddr[0].address)));\r\nmemcpy(ha->serial_number, &sys_info->acSerialNumber,\r\nmin(sizeof(ha->serial_number),\r\nsizeof(sys_info->acSerialNumber)));\r\nstatus = QLA_SUCCESS;\r\nexit_get_sys_info:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,\r\nsys_info_dma);\r\nexit_get_sys_info_no_free:\r\nreturn status;\r\n}\r\nstatic int qla4xxx_init_local_data(struct scsi_qla_host *ha)\r\n{\r\nha->aen_q_count = MAX_AEN_ENTRIES;\r\nreturn qla4xxx_get_firmware_status(ha);\r\n}\r\nstatic uint8_t\r\nqla4xxx_wait_for_ip_config(struct scsi_qla_host *ha)\r\n{\r\nuint8_t ipv4_wait = 0;\r\nuint8_t ipv6_wait = 0;\r\nint8_t ip_address[IPv6_ADDR_LEN] = {0} ;\r\nif (is_ipv4_enabled(ha) && is_ipv6_enabled(ha)) {\r\nif (((ha->addl_fw_state & FW_ADDSTATE_DHCPv4_ENABLED) != 0) &&\r\n((ha->addl_fw_state &\r\nFW_ADDSTATE_DHCPv4_LEASE_ACQUIRED) == 0)) {\r\nipv4_wait = 1;\r\n}\r\nif (((ha->ipv6_addl_options &\r\nIPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE) != 0) &&\r\n((ha->ipv6_link_local_state == IP_ADDRSTATE_ACQUIRING) ||\r\n(ha->ipv6_addr0_state == IP_ADDRSTATE_ACQUIRING) ||\r\n(ha->ipv6_addr1_state == IP_ADDRSTATE_ACQUIRING))) {\r\nipv6_wait = 1;\r\nif ((ha->ipv6_link_local_state ==\r\nIP_ADDRSTATE_PREFERRED) ||\r\n(ha->ipv6_addr0_state == IP_ADDRSTATE_PREFERRED) ||\r\n(ha->ipv6_addr1_state == IP_ADDRSTATE_PREFERRED)) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: "\r\n"Preferred IP configured."\r\n" Don't wait!\n", ha->host_no,\r\n__func__));\r\nipv6_wait = 0;\r\n}\r\nif (memcmp(&ha->ipv6_default_router_addr, ip_address,\r\nIPv6_ADDR_LEN) == 0) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: "\r\n"No Router configured. "\r\n"Don't wait!\n", ha->host_no,\r\n__func__));\r\nipv6_wait = 0;\r\n}\r\nif ((ha->ipv6_default_router_state ==\r\nIPV6_RTRSTATE_MANUAL) &&\r\n(ha->ipv6_link_local_state ==\r\nIP_ADDRSTATE_TENTATIVE) &&\r\n(memcmp(&ha->ipv6_link_local_addr,\r\n&ha->ipv6_default_router_addr, 4) == 0)) {\r\nDEBUG2(printk("scsi%ld: %s: LinkLocal Router & "\r\n"IP configured. Don't wait!\n",\r\nha->host_no, __func__));\r\nipv6_wait = 0;\r\n}\r\n}\r\nif (ipv4_wait || ipv6_wait) {\r\nDEBUG2(printk("scsi%ld: %s: Wait for additional "\r\n"IP(s) \"", ha->host_no, __func__));\r\nif (ipv4_wait)\r\nDEBUG2(printk("IPv4 "));\r\nif (ha->ipv6_link_local_state == IP_ADDRSTATE_ACQUIRING)\r\nDEBUG2(printk("IPv6LinkLocal "));\r\nif (ha->ipv6_addr0_state == IP_ADDRSTATE_ACQUIRING)\r\nDEBUG2(printk("IPv6Addr0 "));\r\nif (ha->ipv6_addr1_state == IP_ADDRSTATE_ACQUIRING)\r\nDEBUG2(printk("IPv6Addr1 "));\r\nDEBUG2(printk("\"\n"));\r\n}\r\n}\r\nreturn ipv4_wait|ipv6_wait;\r\n}\r\nstatic int qla4xxx_fw_ready(struct scsi_qla_host *ha)\r\n{\r\nuint32_t timeout_count;\r\nint ready = 0;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Waiting for Firmware Ready..\n"));\r\nfor (timeout_count = ADAPTER_INIT_TOV; timeout_count > 0;\r\ntimeout_count--) {\r\nif (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))\r\nqla4xxx_get_dhcp_ip_address(ha);\r\nif (qla4xxx_get_firmware_state(ha) != QLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: unable to get firmware "\r\n"state\n", ha->host_no, __func__));\r\nbreak;\r\n}\r\nif (ha->firmware_state & FW_STATE_ERROR) {\r\nDEBUG2(printk("scsi%ld: %s: an unrecoverable error has"\r\n" occurred\n", ha->host_no, __func__));\r\nbreak;\r\n}\r\nif (ha->firmware_state & FW_STATE_CONFIG_WAIT) {\r\nif (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR)\r\nbreak;\r\ncontinue;\r\n}\r\nif (ha->firmware_state & FW_STATE_WAIT_AUTOCONNECT) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: fwstate:"\r\n"AUTOCONNECT in progress\n",\r\nha->host_no, __func__));\r\n}\r\nif (ha->firmware_state & FW_STATE_CONFIGURING_IP) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: fwstate:"\r\n" CONFIGURING IP\n",\r\nha->host_no, __func__));\r\nif (timeout_count <= (ADAPTER_INIT_TOV - 15)) {\r\nif (ha->addl_fw_state & FW_ADDSTATE_LINK_UP) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s:"\r\n" LINK UP (Cable plugged)\n",\r\nha->host_no, __func__));\r\n} else if (ha->firmware_state &\r\n(FW_STATE_CONFIGURING_IP |\r\nFW_STATE_READY)) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: "\r\n"LINK DOWN (Cable unplugged)\n",\r\nha->host_no, __func__));\r\nha->firmware_state = FW_STATE_READY;\r\n}\r\n}\r\n}\r\nif (ha->firmware_state == FW_STATE_READY) {\r\nif (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR,\r\n&ha->dpc_flags))\r\nqla4xxx_get_dhcp_ip_address(ha);\r\nif (!qla4xxx_wait_for_ip_config(ha) ||\r\ntimeout_count == 1) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Firmware Ready..\n"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: MEDIA TYPE"\r\n" - %s\n", ha->host_no,\r\n__func__, (ha->addl_fw_state &\r\nFW_ADDSTATE_OPTICAL_MEDIA)\r\n!= 0 ? "OPTICAL" : "COPPER"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: DHCPv4 STATE"\r\n" Enabled %s\n", ha->host_no,\r\n__func__, (ha->addl_fw_state &\r\nFW_ADDSTATE_DHCPv4_ENABLED) != 0 ?\r\n"YES" : "NO"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: LINK %s\n",\r\nha->host_no, __func__,\r\n(ha->addl_fw_state &\r\nFW_ADDSTATE_LINK_UP) != 0 ?\r\n"UP" : "DOWN"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: iSNS Service "\r\n"Started %s\n",\r\nha->host_no, __func__,\r\n(ha->addl_fw_state &\r\nFW_ADDSTATE_ISNS_SVC_ENABLED) != 0 ?\r\n"YES" : "NO"));\r\nready = 1;\r\nbreak;\r\n}\r\n}\r\nDEBUG2(printk("scsi%ld: %s: waiting on fw, state=%x:%x - "\r\n"seconds expired= %d\n", ha->host_no, __func__,\r\nha->firmware_state, ha->addl_fw_state,\r\ntimeout_count));\r\nif (is_qla4032(ha) &&\r\n!(ha->addl_fw_state & FW_ADDSTATE_LINK_UP) &&\r\n(timeout_count < ADAPTER_INIT_TOV - 5)) {\r\nbreak;\r\n}\r\nmsleep(1000);\r\n}\r\nif (timeout_count <= 0)\r\nDEBUG2(printk("scsi%ld: %s: FW Initialization timed out!\n",\r\nha->host_no, __func__));\r\nif (ha->firmware_state & FW_STATE_CONFIGURING_IP) {\r\nDEBUG2(printk("scsi%ld: %s: FW initialized, but is reporting "\r\n"it's waiting to configure an IP address\n",\r\nha->host_no, __func__));\r\nready = 1;\r\n} else if (ha->firmware_state & FW_STATE_WAIT_AUTOCONNECT) {\r\nDEBUG2(printk("scsi%ld: %s: FW initialized, but "\r\n"auto-discovery still in process\n",\r\nha->host_no, __func__));\r\nready = 1;\r\n}\r\nreturn ready;\r\n}\r\nstatic int qla4xxx_init_firmware(struct scsi_qla_host *ha)\r\n{\r\nint status = QLA_ERROR;\r\nif (is_aer_supported(ha) &&\r\ntest_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))\r\nreturn status;\r\nif (is_qla8022(ha))\r\nqla4_8xxx_stop_firmware(ha);\r\nql4_printk(KERN_INFO, ha, "Initializing firmware..\n");\r\nif (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR) {\r\nDEBUG2(printk("scsi%ld: %s: Failed to initialize firmware "\r\n"control block\n", ha->host_no, __func__));\r\nreturn status;\r\n}\r\nif (!qla4xxx_fw_ready(ha))\r\nreturn status;\r\nreturn qla4xxx_get_firmware_status(ha);\r\n}\r\nstatic struct ddb_entry* qla4xxx_get_ddb_entry(struct scsi_qla_host *ha,\r\nuint32_t fw_ddb_index,\r\nuint32_t *new_tgt)\r\n{\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nstruct ddb_entry *ddb_entry = NULL;\r\nint found = 0;\r\nuint32_t device_state;\r\n*new_tgt = 0;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (fw_ddb_entry == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",\r\nha->host_no, __func__));\r\ngoto exit_get_ddb_entry_no_free;\r\n}\r\nif (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,\r\nfw_ddb_entry_dma, NULL, NULL,\r\n&device_state, NULL, NULL, NULL) ==\r\nQLA_ERROR) {\r\nDEBUG2(printk("scsi%ld: %s: failed get_ddb_entry for "\r\n"fw_ddb_index %d\n", ha->host_no, __func__,\r\nfw_ddb_index));\r\ngoto exit_get_ddb_entry;\r\n}\r\nDEBUG2(printk("scsi%ld: %s: Looking for ddb[%d]\n", ha->host_no,\r\n__func__, fw_ddb_index));\r\nlist_for_each_entry(ddb_entry, &ha->ddb_list, list) {\r\nif ((memcmp(ddb_entry->iscsi_name, fw_ddb_entry->iscsi_name,\r\nISCSI_NAME_SIZE) == 0) &&\r\n(ddb_entry->tpgt ==\r\nle32_to_cpu(fw_ddb_entry->tgt_portal_grp)) &&\r\n(memcmp(ddb_entry->isid, fw_ddb_entry->isid,\r\nsizeof(ddb_entry->isid)) == 0)) {\r\nfound++;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nDEBUG2(printk("scsi%ld: %s: ddb[%d] not found - allocating "\r\n"new ddb\n", ha->host_no, __func__,\r\nfw_ddb_index));\r\n*new_tgt = 1;\r\nddb_entry = qla4xxx_alloc_ddb(ha, fw_ddb_index);\r\n}\r\nexit_get_ddb_entry:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,\r\nfw_ddb_entry_dma);\r\nexit_get_ddb_entry_no_free:\r\nreturn ddb_entry;\r\n}\r\nstatic int qla4xxx_update_ddb_entry(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry,\r\nuint32_t fw_ddb_index)\r\n{\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nint status = QLA_ERROR;\r\nuint32_t conn_err;\r\nif (ddb_entry == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: ddb_entry is NULL\n", ha->host_no,\r\n__func__));\r\ngoto exit_update_ddb_no_free;\r\n}\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (fw_ddb_entry == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",\r\nha->host_no, __func__));\r\ngoto exit_update_ddb_no_free;\r\n}\r\nif (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,\r\nfw_ddb_entry_dma, NULL, NULL,\r\n&ddb_entry->fw_ddb_device_state, &conn_err,\r\n&ddb_entry->tcp_source_port_num,\r\n&ddb_entry->connection_id) ==\r\nQLA_ERROR) {\r\nDEBUG2(printk("scsi%ld: %s: failed get_ddb_entry for "\r\n"fw_ddb_index %d\n", ha->host_no, __func__,\r\nfw_ddb_index));\r\ngoto exit_update_ddb;\r\n}\r\nstatus = QLA_SUCCESS;\r\nddb_entry->options = le16_to_cpu(fw_ddb_entry->options);\r\nddb_entry->target_session_id = le16_to_cpu(fw_ddb_entry->tsid);\r\nddb_entry->task_mgmt_timeout =\r\nle16_to_cpu(fw_ddb_entry->def_timeout);\r\nddb_entry->CmdSn = 0;\r\nddb_entry->exe_throttle = le16_to_cpu(fw_ddb_entry->exec_throttle);\r\nddb_entry->default_relogin_timeout =\r\nle16_to_cpu(fw_ddb_entry->def_timeout);\r\nddb_entry->default_time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\r\nddb_entry->fw_ddb_index = fw_ddb_index;\r\nha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;\r\nddb_entry->port = le16_to_cpu(fw_ddb_entry->port);\r\nddb_entry->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\r\nmemcpy(ddb_entry->isid, fw_ddb_entry->isid, sizeof(ddb_entry->isid));\r\nmemcpy(&ddb_entry->iscsi_name[0], &fw_ddb_entry->iscsi_name[0],\r\nmin(sizeof(ddb_entry->iscsi_name),\r\nsizeof(fw_ddb_entry->iscsi_name)));\r\nmemcpy(&ddb_entry->iscsi_alias[0], &fw_ddb_entry->iscsi_alias[0],\r\nmin(sizeof(ddb_entry->iscsi_alias),\r\nsizeof(fw_ddb_entry->iscsi_alias)));\r\nmemcpy(&ddb_entry->ip_addr[0], &fw_ddb_entry->ip_addr[0],\r\nmin(sizeof(ddb_entry->ip_addr), sizeof(fw_ddb_entry->ip_addr)));\r\nddb_entry->iscsi_max_burst_len = fw_ddb_entry->iscsi_max_burst_len;\r\nddb_entry->iscsi_max_outsnd_r2t = fw_ddb_entry->iscsi_max_outsnd_r2t;\r\nddb_entry->iscsi_first_burst_len = fw_ddb_entry->iscsi_first_burst_len;\r\nddb_entry->iscsi_max_rcv_data_seg_len =\r\nfw_ddb_entry->iscsi_max_rcv_data_seg_len;\r\nddb_entry->iscsi_max_snd_data_seg_len =\r\nfw_ddb_entry->iscsi_max_snd_data_seg_len;\r\nif (ddb_entry->options & DDB_OPT_IPV6_DEVICE) {\r\nmemcpy(&ddb_entry->remote_ipv6_addr,\r\nfw_ddb_entry->ip_addr,\r\nmin(sizeof(ddb_entry->remote_ipv6_addr),\r\nsizeof(fw_ddb_entry->ip_addr)));\r\nmemcpy(&ddb_entry->link_local_ipv6_addr,\r\nfw_ddb_entry->link_local_ipv6_addr,\r\nmin(sizeof(ddb_entry->link_local_ipv6_addr),\r\nsizeof(fw_ddb_entry->link_local_ipv6_addr)));\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: DDB[%d] State %04x"\r\n" ConnErr %08x IP %pI6 "\r\n":%04d \"%s\"\n",\r\n__func__, fw_ddb_index,\r\nddb_entry->fw_ddb_device_state,\r\nconn_err, fw_ddb_entry->ip_addr,\r\nle16_to_cpu(fw_ddb_entry->port),\r\nfw_ddb_entry->iscsi_name));\r\n} else\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: DDB[%d] State %04x"\r\n" ConnErr %08x IP %pI4 "\r\n":%04d \"%s\"\n",\r\n__func__, fw_ddb_index,\r\nddb_entry->fw_ddb_device_state,\r\nconn_err, fw_ddb_entry->ip_addr,\r\nle16_to_cpu(fw_ddb_entry->port),\r\nfw_ddb_entry->iscsi_name));\r\nexit_update_ddb:\r\nif (fw_ddb_entry)\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nexit_update_ddb_no_free:\r\nreturn status;\r\n}\r\nstatic struct ddb_entry * qla4xxx_alloc_ddb(struct scsi_qla_host *ha,\r\nuint32_t fw_ddb_index)\r\n{\r\nstruct ddb_entry *ddb_entry;\r\nDEBUG2(printk("scsi%ld: %s: fw_ddb_index [%d]\n", ha->host_no,\r\n__func__, fw_ddb_index));\r\nddb_entry = qla4xxx_alloc_sess(ha);\r\nif (ddb_entry == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Unable to allocate memory "\r\n"to add fw_ddb_index [%d]\n",\r\nha->host_no, __func__, fw_ddb_index));\r\nreturn ddb_entry;\r\n}\r\nddb_entry->fw_ddb_index = fw_ddb_index;\r\natomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);\r\natomic_set(&ddb_entry->relogin_timer, 0);\r\natomic_set(&ddb_entry->relogin_retry_count, 0);\r\natomic_set(&ddb_entry->state, DDB_STATE_ONLINE);\r\nlist_add_tail(&ddb_entry->list, &ha->ddb_list);\r\nha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;\r\nha->tot_ddbs++;\r\nreturn ddb_entry;\r\n}\r\nint qla4_is_relogin_allowed(struct scsi_qla_host *ha, uint32_t conn_err)\r\n{\r\nuint32_t err_code, login_rsp_sts_class;\r\nint relogin = 1;\r\nerr_code = ((conn_err & 0x00ff0000) >> 16);\r\nlogin_rsp_sts_class = ((conn_err & 0x0000ff00) >> 8);\r\nif (err_code == 0x1c || err_code == 0x06) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n": conn_err=0x%08x, send target completed"\r\n" or access denied failure\n", conn_err));\r\nrelogin = 0;\r\n}\r\nif ((err_code == 0x08) && (login_rsp_sts_class == 0x02)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n": conn_err=0x%08x, do not retry relogin\n",\r\nconn_err));\r\nrelogin = 0;\r\n}\r\nreturn relogin;\r\n}\r\nstatic void qla4xxx_flush_AENS(struct scsi_qla_host *ha)\r\n{\r\nunsigned long wtime;\r\nwtime = jiffies + (2 * HZ);\r\ndo {\r\nif (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS)\r\nif (ha->firmware_state & (BIT_2 | BIT_0))\r\nreturn;\r\nif (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nmsleep(1000);\r\n} while (!time_after_eq(jiffies, wtime));\r\n}\r\nstatic int qla4xxx_build_ddb_list(struct scsi_qla_host *ha)\r\n{\r\nint status = QLA_ERROR;\r\nuint32_t fw_ddb_index = 0;\r\nuint32_t next_fw_ddb_index = 0;\r\nuint32_t ddb_state;\r\nuint32_t conn_err;\r\nstruct ddb_entry *ddb_entry;\r\nstruct dev_db_entry *fw_ddb_entry = NULL;\r\ndma_addr_t fw_ddb_entry_dma;\r\nuint32_t ipv6_device;\r\nuint32_t new_tgt;\r\nqla4xxx_flush_AENS(ha);\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (fw_ddb_entry == NULL) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: DMA alloc failed\n",\r\n__func__));\r\ngoto exit_build_ddb_list_no_free;\r\n}\r\nql4_printk(KERN_INFO, ha, "Initializing DDBs ...\n");\r\nfor (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES;\r\nfw_ddb_index = next_fw_ddb_index) {\r\nif (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,\r\n0, NULL, &next_fw_ddb_index,\r\n&ddb_state, &conn_err,\r\nNULL, NULL) ==\r\nQLA_ERROR) {\r\nDEBUG2(printk("scsi%ld: %s: get_ddb_entry, "\r\n"fw_ddb_index %d failed", ha->host_no,\r\n__func__, fw_ddb_index));\r\ngoto exit_build_ddb_list;\r\n}\r\nDEBUG2(printk("scsi%ld: %s: Getting DDB[%d] ddbstate=0x%x, "\r\n"next_fw_ddb_index=%d.\n", ha->host_no, __func__,\r\nfw_ddb_index, ddb_state, next_fw_ddb_index));\r\nif (ddb_state == DDB_DS_SESSION_FAILED ||\r\nddb_state == DDB_DS_NO_CONNECTION_ACTIVE) {\r\nDEBUG2(printk("scsi%ld: %s: Login to DDB[%d]\n",\r\nha->host_no, __func__, fw_ddb_index));\r\nipv6_device = le16_to_cpu(fw_ddb_entry->options) &\r\nDDB_OPT_IPV6_DEVICE;\r\nif (qla4_is_relogin_allowed(ha, conn_err) &&\r\n((!ipv6_device &&\r\n*((uint32_t *)fw_ddb_entry->ip_addr))\r\n|| ipv6_device)) {\r\nqla4xxx_set_ddb_entry(ha, fw_ddb_index, 0);\r\nif (qla4xxx_get_fwddb_entry(ha, fw_ddb_index,\r\nNULL, 0, NULL,\r\n&next_fw_ddb_index,\r\n&ddb_state, &conn_err,\r\nNULL, NULL)\r\n== QLA_ERROR) {\r\nDEBUG2(printk("scsi%ld: %s:"\r\n"get_ddb_entry %d failed\n",\r\nha->host_no,\r\n__func__, fw_ddb_index));\r\ngoto exit_build_ddb_list;\r\n}\r\n}\r\n}\r\nif (ddb_state != DDB_DS_SESSION_ACTIVE)\r\ngoto next_one;\r\nDEBUG2(printk("scsi%ld: %s: DDB[%d] added to list\n",\r\nha->host_no, __func__, fw_ddb_index));\r\nddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index, &new_tgt);\r\nif (ddb_entry == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Unable to allocate memory "\r\n"for device at fw_ddb_index %d\n",\r\nha->host_no, __func__, fw_ddb_index));\r\ngoto exit_build_ddb_list;\r\n}\r\nif (qla4xxx_update_ddb_entry(ha, ddb_entry, fw_ddb_index) ==\r\nQLA_ERROR) {\r\nha->fw_ddb_index_map[fw_ddb_index] =\r\n(struct ddb_entry *)INVALID_ENTRY;\r\nDEBUG2(printk("scsi%ld: %s: update_ddb_entry failed "\r\n"for fw_ddb_index %d.\n",\r\nha->host_no, __func__, fw_ddb_index));\r\ngoto exit_build_ddb_list;\r\n}\r\nnext_one:\r\nif (next_fw_ddb_index == 0)\r\nbreak;\r\n}\r\nstatus = QLA_SUCCESS;\r\nql4_printk(KERN_INFO, ha, "DDB list done..\n");\r\nexit_build_ddb_list:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,\r\nfw_ddb_entry_dma);\r\nexit_build_ddb_list_no_free:\r\nreturn status;\r\n}\r\nstatic int qla4xxx_initialize_ddb_list(struct scsi_qla_host *ha)\r\n{\r\nuint16_t fw_ddb_index;\r\nint status = QLA_SUCCESS;\r\nif (!list_empty(&ha->ddb_list))\r\nqla4xxx_free_ddb_list(ha);\r\nfor (fw_ddb_index = 0; fw_ddb_index < MAX_DDB_ENTRIES; fw_ddb_index++)\r\nha->fw_ddb_index_map[fw_ddb_index] =\r\n(struct ddb_entry *)INVALID_ENTRY;\r\nha->tot_ddbs = 0;\r\nstatus = qla4xxx_build_ddb_list(ha);\r\nreturn status;\r\n}\r\nint qla4xxx_reinitialize_ddb_list(struct scsi_qla_host *ha)\r\n{\r\nint status = QLA_SUCCESS;\r\nstruct ddb_entry *ddb_entry, *detemp;\r\nlist_for_each_entry_safe(ddb_entry, detemp, &ha->ddb_list, list) {\r\nqla4xxx_update_ddb_entry(ha, ddb_entry,\r\nddb_entry->fw_ddb_index);\r\nif (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {\r\natomic_set(&ddb_entry->state, DDB_STATE_ONLINE);\r\nDEBUG2(printk ("scsi%ld: %s: ddb index [%d] marked "\r\n"ONLINE\n", ha->host_no, __func__,\r\nddb_entry->fw_ddb_index));\r\niscsi_unblock_session(ddb_entry->sess);\r\n} else if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)\r\nqla4xxx_mark_device_missing(ha, ddb_entry);\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_relogin_device(struct scsi_qla_host *ha,\r\nstruct ddb_entry * ddb_entry)\r\n{\r\nuint16_t relogin_timer;\r\nrelogin_timer = max(ddb_entry->default_relogin_timeout,\r\n(uint16_t)RELOGIN_TOV);\r\natomic_set(&ddb_entry->relogin_timer, relogin_timer);\r\nDEBUG2(printk("scsi%ld: Relogin ddb [%d]. TOV=%d\n", ha->host_no,\r\nddb_entry->fw_ddb_index, relogin_timer));\r\nqla4xxx_set_ddb_entry(ha, ddb_entry->fw_ddb_index, 0);\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int qla4xxx_config_nvram(struct scsi_qla_host *ha)\r\n{\r\nunsigned long flags;\r\nunion external_hw_config_reg extHwConfig;\r\nDEBUG2(printk("scsi%ld: %s: Get EEProm parameters \n", ha->host_no,\r\n__func__));\r\nif (ql4xxx_lock_flash(ha) != QLA_SUCCESS)\r\nreturn QLA_ERROR;\r\nif (ql4xxx_lock_nvram(ha) != QLA_SUCCESS) {\r\nql4xxx_unlock_flash(ha);\r\nreturn QLA_ERROR;\r\n}\r\nql4_printk(KERN_INFO, ha, "Configuring NVRAM ...\n");\r\nif (qla4xxx_is_nvram_configuration_valid(ha) == QLA_SUCCESS) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nextHwConfig.Asuint32_t =\r\nrd_nvram_word(ha, eeprom_ext_hw_conf_offset(ha));\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n} else {\r\nql4_printk(KERN_WARNING, ha,\r\n"scsi%ld: %s: EEProm checksum invalid. "\r\n"Please update your EEPROM\n", ha->host_no,\r\n__func__);\r\nif (is_qla4010(ha))\r\nextHwConfig.Asuint32_t = 0x1912;\r\nelse if (is_qla4022(ha) | is_qla4032(ha))\r\nextHwConfig.Asuint32_t = 0x0023;\r\nelse\r\nreturn QLA_ERROR;\r\n}\r\nDEBUG(printk("scsi%ld: %s: Setting extHwConfig to 0xFFFF%04x\n",\r\nha->host_no, __func__, extHwConfig.Asuint32_t));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel((0xFFFF << 16) | extHwConfig.Asuint32_t, isp_ext_hw_conf(ha));\r\nreadl(isp_ext_hw_conf(ha));\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nql4xxx_unlock_nvram(ha);\r\nql4xxx_unlock_flash(ha);\r\nreturn QLA_SUCCESS;\r\n}\r\nvoid qla4_8xxx_pci_config(struct scsi_qla_host *ha)\r\n{\r\npci_set_master(ha->pdev);\r\n}\r\nvoid qla4xxx_pci_config(struct scsi_qla_host *ha)\r\n{\r\nuint16_t w;\r\nint status;\r\nql4_printk(KERN_INFO, ha, "Configuring PCI space...\n");\r\npci_set_master(ha->pdev);\r\nstatus = pci_set_mwi(ha->pdev);\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &w);\r\nw |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;\r\nw &= ~PCI_COMMAND_INTX_DISABLE;\r\npci_write_config_word(ha->pdev, PCI_COMMAND, w);\r\n}\r\nstatic int qla4xxx_start_firmware_from_flash(struct scsi_qla_host *ha)\r\n{\r\nint status = QLA_ERROR;\r\nunsigned long max_wait_time;\r\nunsigned long flags;\r\nuint32_t mbox_status;\r\nql4_printk(KERN_INFO, ha, "Starting firmware ...\n");\r\nDEBUG(printk("scsi%d: %s: Start firmware from flash ROM\n",\r\nha->host_no, __func__));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel(jiffies, &ha->reg->mailbox[7]);\r\nif (is_qla4022(ha) | is_qla4032(ha))\r\nwritel(set_rmask(NVR_WRITE_ENABLE),\r\n&ha->reg->u1.isp4022.nvram);\r\nwritel(2, &ha->reg->mailbox[6]);\r\nreadl(&ha->reg->mailbox[6]);\r\nwritel(set_rmask(CSR_BOOT_ENABLE), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: Wait up to %d seconds for "\r\n"boot firmware to complete...\n",\r\nha->host_no, __func__, FIRMWARE_UP_TOV));\r\nmax_wait_time = jiffies + (FIRMWARE_UP_TOV * HZ);\r\ndo {\r\nuint32_t ctrl_status;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nmbox_status = readw(&ha->reg->mailbox[0]);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (ctrl_status & set_rmask(CSR_SCSI_PROCESSOR_INTR))\r\nbreak;\r\nif (mbox_status == MBOX_STS_COMMAND_COMPLETE)\r\nbreak;\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: Waiting for boot "\r\n"firmware to complete... ctrl_sts=0x%x, remaining=%ld\n",\r\nha->host_no, __func__, ctrl_status, max_wait_time));\r\nmsleep_interruptible(250);\r\n} while (!time_after_eq(jiffies, max_wait_time));\r\nif (mbox_status == MBOX_STS_COMMAND_COMPLETE) {\r\nDEBUG(printk(KERN_INFO "scsi%ld: %s: Firmware has started\n",\r\nha->host_no, __func__));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\r\n&ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nstatus = QLA_SUCCESS;\r\n} else {\r\nprintk(KERN_INFO "scsi%ld: %s: Boot firmware failed "\r\n"- mbox status 0x%x\n", ha->host_no, __func__,\r\nmbox_status);\r\nstatus = QLA_ERROR;\r\n}\r\nreturn status;\r\n}\r\nint ql4xxx_lock_drvr_wait(struct scsi_qla_host *a)\r\n{\r\n#define QL4_LOCK_DRVR_WAIT 60\r\n#define QL4_LOCK_DRVR_SLEEP 1\r\nint drvr_wait = QL4_LOCK_DRVR_WAIT;\r\nwhile (drvr_wait) {\r\nif (ql4xxx_lock_drvr(a) == 0) {\r\nssleep(QL4_LOCK_DRVR_SLEEP);\r\nif (drvr_wait) {\r\nDEBUG2(printk("scsi%ld: %s: Waiting for "\r\n"Global Init Semaphore(%d)...\n",\r\na->host_no,\r\n__func__, drvr_wait));\r\n}\r\ndrvr_wait -= QL4_LOCK_DRVR_SLEEP;\r\n} else {\r\nDEBUG2(printk("scsi%ld: %s: Global Init Semaphore "\r\n"acquired\n", a->host_no, __func__));\r\nreturn QLA_SUCCESS;\r\n}\r\n}\r\nreturn QLA_ERROR;\r\n}\r\nint qla4xxx_start_firmware(struct scsi_qla_host *ha)\r\n{\r\nunsigned long flags = 0;\r\nuint32_t mbox_status;\r\nint status = QLA_ERROR;\r\nint soft_reset = 1;\r\nint config_chip = 0;\r\nif (is_qla4022(ha) | is_qla4032(ha))\r\nql4xxx_set_mac_number(ha);\r\nif (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)\r\nreturn QLA_ERROR;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nDEBUG2(printk("scsi%ld: %s: port_ctrl = 0x%08X\n", ha->host_no,\r\n__func__, readw(isp_port_ctrl(ha))));\r\nDEBUG(printk("scsi%ld: %s: port_status = 0x%08X\n", ha->host_no,\r\n__func__, readw(isp_port_status(ha))));\r\nif ((readw(isp_port_ctrl(ha)) & 0x8000) != 0) {\r\nDEBUG(printk("scsi%ld: %s: Hardware has already been "\r\n"initialized\n", ha->host_no, __func__));\r\nmbox_status = readw(&ha->reg->mailbox[0]);\r\nDEBUG2(printk("scsi%ld: %s: H/W Config complete - mbox[0]= "\r\n"0x%x\n", ha->host_no, __func__, mbox_status));\r\nif (mbox_status == 0) {\r\nconfig_chip = 1;\r\nsoft_reset = 0;\r\n} else {\r\nwritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\r\n&ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: Get firmware "\r\n"state -- state = 0x%x\n",\r\nha->host_no,\r\n__func__, ha->firmware_state));\r\nif (ha->firmware_state &\r\nFW_STATE_CONFIG_WAIT) {\r\nDEBUG2(printk("scsi%ld: %s: Firmware "\r\n"in known state -- "\r\n"config and "\r\n"boot, state = 0x%x\n",\r\nha->host_no, __func__,\r\nha->firmware_state));\r\nconfig_chip = 1;\r\nsoft_reset = 0;\r\n}\r\n} else {\r\nDEBUG2(printk("scsi%ld: %s: Firmware in "\r\n"unknown state -- resetting,"\r\n" state = "\r\n"0x%x\n", ha->host_no, __func__,\r\nha->firmware_state));\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\n}\r\n} else {\r\nDEBUG(printk("scsi%ld: %s: H/W initialization hasn't been "\r\n"started - resetting\n", ha->host_no, __func__));\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nDEBUG(printk("scsi%ld: %s: Flags soft_rest=%d, config= %d\n ",\r\nha->host_no, __func__, soft_reset, config_chip));\r\nif (soft_reset) {\r\nDEBUG(printk("scsi%ld: %s: Issue Soft Reset\n", ha->host_no,\r\n__func__));\r\nstatus = qla4xxx_soft_reset(ha);\r\nif (status == QLA_ERROR) {\r\nDEBUG(printk("scsi%d: %s: Soft Reset failed!\n",\r\nha->host_no, __func__));\r\nql4xxx_unlock_drvr(ha);\r\nreturn QLA_ERROR;\r\n}\r\nconfig_chip = 1;\r\nif (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)\r\nreturn QLA_ERROR;\r\n}\r\nif (config_chip) {\r\nif ((status = qla4xxx_config_nvram(ha)) == QLA_SUCCESS)\r\nstatus = qla4xxx_start_firmware_from_flash(ha);\r\n}\r\nql4xxx_unlock_drvr(ha);\r\nif (status == QLA_SUCCESS) {\r\nif (test_and_clear_bit(AF_GET_CRASH_RECORD, &ha->flags))\r\nqla4xxx_get_crash_record(ha);\r\n} else {\r\nDEBUG(printk("scsi%ld: %s: Firmware has NOT started\n",\r\nha->host_no, __func__));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_initialize_adapter(struct scsi_qla_host *ha,\r\nuint8_t renew_ddb_list)\r\n{\r\nint status = QLA_ERROR;\r\nint8_t ip_address[IP_ADDR_LEN] = {0} ;\r\nha->eeprom_cmd_data = 0;\r\nql4_printk(KERN_INFO, ha, "Configuring PCI space...\n");\r\nha->isp_ops->pci_config(ha);\r\nha->isp_ops->disable_intrs(ha);\r\nif (ha->isp_ops->start_firmware(ha) == QLA_ERROR)\r\ngoto exit_init_hba;\r\nif (qla4xxx_about_firmware(ha) == QLA_ERROR)\r\ngoto exit_init_hba;\r\nif (ha->isp_ops->get_sys_info(ha) == QLA_ERROR)\r\ngoto exit_init_hba;\r\nif (qla4xxx_init_local_data(ha) == QLA_ERROR)\r\ngoto exit_init_hba;\r\nstatus = qla4xxx_init_firmware(ha);\r\nif (status == QLA_ERROR)\r\ngoto exit_init_hba;\r\nif (ha->firmware_state & FW_STATE_CONFIGURING_IP)\r\ngoto exit_init_online;\r\nif (memcmp(ha->ip_address, ip_address, IP_ADDR_LEN) == 0 ||\r\nmemcmp(ha->subnet_mask, ip_address, IP_ADDR_LEN) == 0)\r\ngoto exit_init_online;\r\nif (renew_ddb_list == PRESERVE_DDB_LIST) {\r\nqla4xxx_reinitialize_ddb_list(ha);\r\n} else if (renew_ddb_list == REBUILD_DDB_LIST) {\r\nstatus = qla4xxx_initialize_ddb_list(ha);\r\nif (status == QLA_ERROR) {\r\nDEBUG2(printk("%s(%ld) Error occurred during build"\r\n"ddb list\n", __func__, ha->host_no));\r\ngoto exit_init_hba;\r\n}\r\n}\r\nif (!ha->tot_ddbs) {\r\nDEBUG2(printk("scsi%ld: Failed to initialize devices or none "\r\n"present in Firmware device database\n",\r\nha->host_no));\r\n}\r\nexit_init_online:\r\nset_bit(AF_ONLINE, &ha->flags);\r\nexit_init_hba:\r\nif (is_qla8022(ha) && (status == QLA_ERROR)) {\r\nqla4xxx_free_irqs(ha);\r\n}\r\nDEBUG2(printk("scsi%ld: initialize adapter: %s\n", ha->host_no,\r\nstatus == QLA_ERROR ? "FAILED" : "SUCCEEDED"));\r\nreturn status;\r\n}\r\nstatic void qla4xxx_add_device_dynamically(struct scsi_qla_host *ha,\r\nuint32_t fw_ddb_index)\r\n{\r\nstruct ddb_entry * ddb_entry;\r\nuint32_t new_tgt;\r\nddb_entry = qla4xxx_get_ddb_entry(ha, fw_ddb_index, &new_tgt);\r\nif (ddb_entry == NULL) {\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: Unable to allocate memory to add "\r\n"fw_ddb_index %d\n", ha->host_no, fw_ddb_index));\r\nreturn;\r\n}\r\nif (!new_tgt && (ddb_entry->fw_ddb_index != fw_ddb_index)) {\r\nqla4xxx_free_ddb(ha, ddb_entry);\r\nddb_entry = qla4xxx_alloc_ddb(ha, fw_ddb_index);\r\nif (ddb_entry == NULL) {\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: Unable to allocate memory"\r\n" to add fw_ddb_index %d\n",\r\nha->host_no, fw_ddb_index));\r\nreturn;\r\n}\r\n}\r\nif (qla4xxx_update_ddb_entry(ha, ddb_entry, fw_ddb_index) ==\r\nQLA_ERROR) {\r\nha->fw_ddb_index_map[fw_ddb_index] =\r\n(struct ddb_entry *)INVALID_ENTRY;\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: failed to add new device at index "\r\n"[%d]\n Unable to retrieve fw ddb entry\n",\r\nha->host_no, fw_ddb_index));\r\nqla4xxx_free_ddb(ha, ddb_entry);\r\nreturn;\r\n}\r\nif (qla4xxx_add_sess(ddb_entry)) {\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: failed to add new device at index "\r\n"[%d]\n Unable to add connection and session\n",\r\nha->host_no, fw_ddb_index));\r\nqla4xxx_free_ddb(ha, ddb_entry);\r\n}\r\n}\r\nint qla4xxx_process_ddb_changed(struct scsi_qla_host *ha, uint32_t fw_ddb_index,\r\nuint32_t state, uint32_t conn_err)\r\n{\r\nstruct ddb_entry * ddb_entry;\r\nif (fw_ddb_index >= MAX_DDB_ENTRIES)\r\nreturn QLA_ERROR;\r\nddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);\r\nif (ddb_entry == NULL) {\r\nif (state == DDB_DS_SESSION_ACTIVE)\r\nqla4xxx_add_device_dynamically(ha, fw_ddb_index);\r\nreturn QLA_SUCCESS;\r\n}\r\nDEBUG2(printk("scsi%ld: %s DDB - old state= 0x%x, new state=0x%x for "\r\n"index [%d]\n", ha->host_no, __func__,\r\nddb_entry->fw_ddb_device_state, state, fw_ddb_index));\r\nddb_entry->fw_ddb_device_state = state;\r\nif ((ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) &&\r\n(atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE)) {\r\natomic_set(&ddb_entry->state, DDB_STATE_ONLINE);\r\natomic_set(&ddb_entry->relogin_retry_count, 0);\r\natomic_set(&ddb_entry->relogin_timer, 0);\r\nclear_bit(DF_RELOGIN, &ddb_entry->flags);\r\niscsi_unblock_session(ddb_entry->sess);\r\niscsi_session_event(ddb_entry->sess,\r\nISCSI_KEVENT_CREATE_SESSION);\r\n} else if (ddb_entry->fw_ddb_device_state != DDB_DS_SESSION_ACTIVE) {\r\nif (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s mark missing "\r\n"ddb_entry 0x%p sess 0x%p conn 0x%p\n",\r\n__func__, ddb_entry,\r\nddb_entry->sess, ddb_entry->conn));\r\nqla4xxx_mark_device_missing(ha, ddb_entry);\r\n}\r\nif (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_FAILED &&\r\n!test_bit(DF_RELOGIN, &ddb_entry->flags) &&\r\nqla4_is_relogin_allowed(ha, conn_err)) {\r\natomic_set(&ddb_entry->relogin_timer, 0);\r\natomic_set(&ddb_entry->retry_relogin_timer,\r\nddb_entry->default_time2wait + 4);\r\nDEBUG(printk("scsi%ld: %s: ddb[%d] "\r\n"initiate relogin after %d seconds\n",\r\nha->host_no, __func__,\r\nddb_entry->fw_ddb_index,\r\nddb_entry->default_time2wait + 4));\r\n} else {\r\nDEBUG(printk("scsi%ld: %s: ddb[%d] "\r\n"relogin not initiated, state = %d, "\r\n"ddb_entry->flags = 0x%lx\n",\r\nha->host_no, __func__,\r\nddb_entry->fw_ddb_index,\r\nddb_entry->fw_ddb_device_state,\r\nddb_entry->flags));\r\n}\r\n}\r\nreturn QLA_SUCCESS;\r\n}
