static void elmc_do_attn586(int ioaddr, int ints)\r\n{\r\noutb(ELMC_CTRL_RST | 0x3 | ELMC_CTRL_CA | ints, ioaddr + ELMC_CTRL);\r\nDELAY_16();\r\noutb(ELMC_CTRL_RST | 0x3 | ints, ioaddr + ELMC_CTRL);\r\n}\r\nstatic void elmc_do_reset586(int ioaddr, int ints)\r\n{\r\noutb(0x3 | ELMC_CTRL_LBK, ioaddr + ELMC_CTRL);\r\nDELAY_16();\r\noutb(ELMC_CTRL_RST | ELMC_CTRL_LBK | 0x3, ioaddr + ELMC_CTRL);\r\nelmc_do_attn586(ioaddr, ints);\r\n}\r\nstatic int elmc_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nelmc_id_reset586();\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic int elmc_open(struct net_device *dev)\r\n{\r\nint ret;\r\nelmc_id_attn586();\r\nret = request_irq(dev->irq, elmc_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (ret) {\r\npr_err("%s: couldn't get irq %d\n", dev->name, dev->irq);\r\nelmc_id_reset586();\r\nreturn ret;\r\n}\r\nalloc586(dev);\r\ninit586(dev);\r\nstartrecv586(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int __init check586(struct net_device *dev, unsigned long where, unsigned size)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nchar *iscp_addrs[2];\r\nint i = 0;\r\np->base = (unsigned long) isa_bus_to_virt((unsigned long)where) + size - 0x01000000;\r\np->memtop = isa_bus_to_virt((unsigned long)where) + size;\r\np->scp = (struct scp_struct *)(p->base + SCP_DEFAULT_ADDRESS);\r\nmemset((char *) p->scp, 0, sizeof(struct scp_struct));\r\np->scp->sysbus = SYSBUSVAL;\r\niscp_addrs[0] = isa_bus_to_virt((unsigned long)where);\r\niscp_addrs[1] = (char *) p->scp - sizeof(struct iscp_struct);\r\nfor (i = 0; i < 2; i++) {\r\np->iscp = (struct iscp_struct *) iscp_addrs[i];\r\nmemset((char *) p->iscp, 0, sizeof(struct iscp_struct));\r\np->scp->iscp = make24(p->iscp);\r\np->iscp->busy = 1;\r\nelmc_id_reset586();\r\nelmc_id_attn586();\r\nDELAY(1);\r\nif (p->iscp->busy) {\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void alloc586(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nelmc_id_reset586();\r\nDELAY(2);\r\np->scp = (struct scp_struct *) (p->base + SCP_DEFAULT_ADDRESS);\r\np->scb = (struct scb_struct *) isa_bus_to_virt(dev->mem_start);\r\np->iscp = (struct iscp_struct *) ((char *) p->scp - sizeof(struct iscp_struct));\r\nmemset((char *) p->iscp, 0, sizeof(struct iscp_struct));\r\nmemset((char *) p->scp, 0, sizeof(struct scp_struct));\r\np->scp->iscp = make24(p->iscp);\r\np->scp->sysbus = SYSBUSVAL;\r\np->iscp->scb_offset = make16(p->scb);\r\np->iscp->busy = 1;\r\nelmc_id_reset586();\r\nelmc_id_attn586();\r\nDELAY(2);\r\nif (p->iscp->busy)\r\npr_err("%s: Init-Problems (alloc).\n", dev->name);\r\nmemset((char *) p->scb, 0, sizeof(struct scb_struct));\r\n}\r\nstatic int elmc_getinfo(char *buf, int slot, void *d)\r\n{\r\nint len = 0;\r\nstruct net_device *dev = d;\r\nif (dev == NULL)\r\nreturn len;\r\nlen += sprintf(buf + len, "Revision: 0x%x\n",\r\ninb(dev->base_addr + ELMC_REVISION) & 0xf);\r\nlen += sprintf(buf + len, "IRQ: %d\n", dev->irq);\r\nlen += sprintf(buf + len, "IO Address: %#lx-%#lx\n", dev->base_addr,\r\ndev->base_addr + ELMC_IO_EXTENT);\r\nlen += sprintf(buf + len, "Memory: %#lx-%#lx\n", dev->mem_start,\r\ndev->mem_end - 1);\r\nlen += sprintf(buf + len, "Transceiver: %s\n", dev->if_port ?\r\n"External" : "Internal");\r\nlen += sprintf(buf + len, "Device: %s\n", dev->name);\r\nlen += sprintf(buf + len, "Hardware Address: %pM\n",\r\ndev->dev_addr);\r\nreturn len;\r\n}\r\nstatic int __init do_elmc_probe(struct net_device *dev)\r\n{\r\nstatic int slot;\r\nint base_addr = dev->base_addr;\r\nint irq = dev->irq;\r\nu_char status = 0;\r\nu_char revision = 0;\r\nint i = 0;\r\nunsigned int size = 0;\r\nint retval;\r\nstruct priv *pr = netdev_priv(dev);\r\nif (MCA_bus == 0) {\r\nreturn -ENODEV;\r\n}\r\nslot = mca_find_adapter(ELMC_MCA_ID, 0);\r\nwhile (slot != -1) {\r\nstatus = mca_read_stored_pos(slot, 2);\r\ndev->irq=irq_table[(status & ELMC_STATUS_IRQ_SELECT) >> 6];\r\ndev->base_addr=csr_table[(status & ELMC_STATUS_CSR_SELECT) >> 1];\r\nif ((irq && irq != dev->irq) ||\r\n(base_addr && base_addr != dev->base_addr)) {\r\nslot = mca_find_adapter(ELMC_MCA_ID, slot + 1);\r\ncontinue;\r\n}\r\nif (!request_region(dev->base_addr, ELMC_IO_EXTENT, DRV_NAME)) {\r\nslot = mca_find_adapter(ELMC_MCA_ID, slot + 1);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (slot == MCA_NOTFOUND)\r\nreturn (base_addr || irq) ? -ENXIO : -ENODEV;\r\nmca_set_adapter_name(slot, "3Com 3c523 Etherlink/MC");\r\nmca_set_adapter_procfn(slot, (MCA_ProcFn) elmc_getinfo, dev);\r\npr_info("%s: 3c523 adapter found in slot %d\n", dev->name, slot + 1);\r\nrevision = inb(dev->base_addr + ELMC_REVISION) & 0xf;\r\nswitch (dev->irq) {\r\ncase 3:\r\nmca_write_pos(slot, 3, 0x04);\r\nbreak;\r\ncase 7:\r\nmca_write_pos(slot, 3, 0x02);\r\nbreak;\r\ncase 9:\r\nmca_write_pos(slot, 3, 0x08);\r\nbreak;\r\ncase 12:\r\nmca_write_pos(slot, 3, 0x01);\r\nbreak;\r\n}\r\npr->slot = slot;\r\npr_info("%s: 3Com 3c523 Rev 0x%x at %#lx\n", dev->name, (int) revision,\r\ndev->base_addr);\r\ndev->if_port = (status & ELMC_STATUS_DISABLE_THIN);\r\ndev->mem_start = shm_table[(status & ELMC_STATUS_MEMORY_SELECT) >> 3];\r\nelmc_id_reset586();\r\nsize = 0x4000;\r\nif (!check586(dev, dev->mem_start, size)) {\r\npr_err("%s: memprobe, Can't find memory at 0x%lx!\n", dev->name,\r\ndev->mem_start);\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\ndev->mem_end = dev->mem_start + size;\r\npr->memtop = isa_bus_to_virt(dev->mem_start) + size;\r\npr->base = (unsigned long) isa_bus_to_virt(dev->mem_start) + size - 0x01000000;\r\nalloc586(dev);\r\nelmc_id_reset586();\r\npr->num_recv_buffs = NUM_RECV_BUFFS_16;\r\npr_info("%s: IRQ %d, %sternal xcvr, memory %#lx-%#lx.\n", dev->name,\r\ndev->irq, dev->if_port ? "ex" : "in",\r\ndev->mem_start, dev->mem_end - 1);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(dev->base_addr + i);\r\npr_info("%s: hardware address %pM\n",\r\ndev->name, dev->dev_addr);\r\ndev->netdev_ops = &netdev_ops;\r\ndev->watchdog_timeo = HZ;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\n#ifndef ELMC_MULTICAST\r\ndev->flags&=~IFF_MULTICAST;\r\n#endif\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nmca_set_adapter_procfn(slot, NULL, NULL);\r\nrelease_region(dev->base_addr, ELMC_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nmca_set_adapter_procfn(((struct priv *)netdev_priv(dev))->slot,\r\nNULL, NULL);\r\nrelease_region(dev->base_addr, ELMC_IO_EXTENT);\r\n}\r\nstruct net_device * __init elmc_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct priv));\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_elmc_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int init586(struct net_device *dev)\r\n{\r\nvoid *ptr;\r\nunsigned long s;\r\nint i, result = 0;\r\nstruct priv *p = netdev_priv(dev);\r\nvolatile struct configure_cmd_struct *cfg_cmd;\r\nvolatile struct iasetup_cmd_struct *ias_cmd;\r\nvolatile struct tdr_cmd_struct *tdr_cmd;\r\nvolatile struct mcsetup_cmd_struct *mc_cmd;\r\nstruct netdev_hw_addr *ha;\r\nint num_addrs = netdev_mc_count(dev);\r\nptr = (void *) ((char *) p->scb + sizeof(struct scb_struct));\r\ncfg_cmd = (struct configure_cmd_struct *) ptr;\r\ncfg_cmd->cmd_status = 0;\r\ncfg_cmd->cmd_cmd = CMD_CONFIGURE | CMD_LAST;\r\ncfg_cmd->cmd_link = 0xffff;\r\ncfg_cmd->byte_cnt = 0x0a;\r\ncfg_cmd->fifo = 0x08;\r\ncfg_cmd->sav_bf = 0x40;\r\ncfg_cmd->adr_len = 0x2e;\r\ncfg_cmd->priority = 0x00;\r\ncfg_cmd->ifs = 0x60;\r\ncfg_cmd->time_low = 0x00;\r\ncfg_cmd->time_high = 0xf2;\r\ncfg_cmd->promisc = 0;\r\nif (dev->flags & (IFF_ALLMULTI | IFF_PROMISC))\r\ncfg_cmd->promisc = 1;\r\ncfg_cmd->carr_coll = 0x00;\r\np->scb->cbl_offset = make16(cfg_cmd);\r\np->scb->cmd = CUC_START;\r\nelmc_id_attn586();\r\ns = jiffies;\r\nwhile (!(cfg_cmd->cmd_status & STAT_COMPL)) {\r\nif (time_after(jiffies, s + 30*HZ/100))\r\nbreak;\r\n}\r\nif ((cfg_cmd->cmd_status & (STAT_OK | STAT_COMPL)) != (STAT_COMPL | STAT_OK)) {\r\npr_warning("%s (elmc): configure command failed: %x\n", dev->name, cfg_cmd->cmd_status);\r\nreturn 1;\r\n}\r\nias_cmd = (struct iasetup_cmd_struct *) ptr;\r\nias_cmd->cmd_status = 0;\r\nias_cmd->cmd_cmd = CMD_IASETUP | CMD_LAST;\r\nias_cmd->cmd_link = 0xffff;\r\nmemcpy((char *) &ias_cmd->iaddr, (char *) dev->dev_addr, ETH_ALEN);\r\np->scb->cbl_offset = make16(ias_cmd);\r\np->scb->cmd = CUC_START;\r\nelmc_id_attn586();\r\ns = jiffies;\r\nwhile (!(ias_cmd->cmd_status & STAT_COMPL)) {\r\nif (time_after(jiffies, s + 30*HZ/100))\r\nbreak;\r\n}\r\nif ((ias_cmd->cmd_status & (STAT_OK | STAT_COMPL)) != (STAT_OK | STAT_COMPL)) {\r\npr_warning("%s (elmc): individual address setup command failed: %04x\n",\r\ndev->name, ias_cmd->cmd_status);\r\nreturn 1;\r\n}\r\ntdr_cmd = (struct tdr_cmd_struct *) ptr;\r\ntdr_cmd->cmd_status = 0;\r\ntdr_cmd->cmd_cmd = CMD_TDR | CMD_LAST;\r\ntdr_cmd->cmd_link = 0xffff;\r\ntdr_cmd->status = 0;\r\np->scb->cbl_offset = make16(tdr_cmd);\r\np->scb->cmd = CUC_START;\r\nelmc_attn586();\r\ns = jiffies;\r\nwhile (!(tdr_cmd->cmd_status & STAT_COMPL)) {\r\nif (time_after(jiffies, s + 30*HZ/100)) {\r\npr_warning("%s: %d Problems while running the TDR.\n", dev->name, __LINE__);\r\nresult = 1;\r\nbreak;\r\n}\r\n}\r\nif (!result) {\r\nDELAY(2);\r\nresult = tdr_cmd->status;\r\np->scb->cmd = p->scb->status & STAT_MASK;\r\nelmc_id_attn586();\r\nif (result & TDR_LNK_OK) {\r\n} else if (result & TDR_XCVR_PRB) {\r\npr_warning("%s: TDR: Transceiver problem!\n", dev->name);\r\n} else if (result & TDR_ET_OPN) {\r\npr_warning("%s: TDR: No correct termination %d clocks away.\n", dev->name, result & TDR_TIMEMASK);\r\n} else if (result & TDR_ET_SRT) {\r\nif (result & TDR_TIMEMASK)\r\npr_warning("%s: TDR: Detected a short circuit %d clocks away.\n", dev->name, result & TDR_TIMEMASK);\r\n} else {\r\npr_warning("%s: TDR: Unknown status %04x\n", dev->name, result);\r\n}\r\n}\r\np->scb->cmd = p->scb->status & STAT_MASK;\r\nelmc_id_attn586();\r\n#if (NUM_XMIT_BUFFS == 1)\r\nfor (i = 0; i < 2; i++) {\r\np->nop_cmds[i] = (struct nop_cmd_struct *) ptr;\r\np->nop_cmds[i]->cmd_cmd = CMD_NOP;\r\np->nop_cmds[i]->cmd_status = 0;\r\np->nop_cmds[i]->cmd_link = make16((p->nop_cmds[i]));\r\nptr = (char *) ptr + sizeof(struct nop_cmd_struct);\r\n}\r\np->xmit_cmds[0] = (struct transmit_cmd_struct *) ptr;\r\nptr = (char *) ptr + sizeof(struct transmit_cmd_struct);\r\n#else\r\nfor (i = 0; i < NUM_XMIT_BUFFS; i++) {\r\np->nop_cmds[i] = (struct nop_cmd_struct *) ptr;\r\np->nop_cmds[i]->cmd_cmd = CMD_NOP;\r\np->nop_cmds[i]->cmd_status = 0;\r\np->nop_cmds[i]->cmd_link = make16((p->nop_cmds[i]));\r\nptr = (char *) ptr + sizeof(struct nop_cmd_struct);\r\np->xmit_cmds[i] = (struct transmit_cmd_struct *) ptr;\r\nptr = (char *) ptr + sizeof(struct transmit_cmd_struct);\r\n}\r\n#endif\r\nptr = alloc_rfa(dev, (void *) ptr);\r\nif (num_addrs) {\r\nint len = ((char *) p->iscp - (char *) ptr - 8) / 6;\r\nif (len <= 0) {\r\npr_err("%s: Ooooops, no memory for MC-Setup!\n", dev->name);\r\n} else {\r\nif (len < num_addrs) {\r\nnum_addrs = len;\r\npr_warning("%s: Sorry, can only apply %d MC-Address(es).\n",\r\ndev->name, num_addrs);\r\n}\r\nmc_cmd = (struct mcsetup_cmd_struct *) ptr;\r\nmc_cmd->cmd_status = 0;\r\nmc_cmd->cmd_cmd = CMD_MCSETUP | CMD_LAST;\r\nmc_cmd->cmd_link = 0xffff;\r\nmc_cmd->mc_cnt = num_addrs * 6;\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nmemcpy((char *) mc_cmd->mc_list[i++],\r\nha->addr, 6);\r\np->scb->cbl_offset = make16(mc_cmd);\r\np->scb->cmd = CUC_START;\r\nelmc_id_attn586();\r\ns = jiffies;\r\nwhile (!(mc_cmd->cmd_status & STAT_COMPL)) {\r\nif (time_after(jiffies, s + 30*HZ/100))\r\nbreak;\r\n}\r\nif (!(mc_cmd->cmd_status & STAT_COMPL)) {\r\npr_warning("%s: Can't apply multicast-address-list.\n", dev->name);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < NUM_XMIT_BUFFS; i++) {\r\np->xmit_cbuffs[i] = (char *) ptr;\r\nptr = (char *) ptr + XMIT_BUFF_SIZE;\r\np->xmit_buffs[i] = (struct tbd_struct *) ptr;\r\nptr = (char *) ptr + sizeof(struct tbd_struct);\r\nif ((void *) ptr > (void *) p->iscp) {\r\npr_err("%s: not enough shared-mem for your configuration!\n", dev->name);\r\nreturn 1;\r\n}\r\nmemset((char *) (p->xmit_cmds[i]), 0, sizeof(struct transmit_cmd_struct));\r\nmemset((char *) (p->xmit_buffs[i]), 0, sizeof(struct tbd_struct));\r\np->xmit_cmds[i]->cmd_status = STAT_COMPL;\r\np->xmit_cmds[i]->cmd_cmd = CMD_XMIT | CMD_INT;\r\np->xmit_cmds[i]->tbd_offset = make16((p->xmit_buffs[i]));\r\np->xmit_buffs[i]->next = 0xffff;\r\np->xmit_buffs[i]->buffer = make24((p->xmit_cbuffs[i]));\r\n}\r\np->xmit_count = 0;\r\np->xmit_last = 0;\r\n#ifndef NO_NOPCOMMANDS\r\np->nop_point = 0;\r\n#endif\r\n#ifndef NO_NOPCOMMANDS\r\np->scb->cbl_offset = make16(p->nop_cmds[0]);\r\np->scb->cmd = CUC_START;\r\nelmc_id_attn586();\r\nWAIT_4_SCB_CMD();\r\n#else\r\np->xmit_cmds[0]->cmd_link = 0xffff;\r\np->xmit_cmds[0]->cmd_cmd = CMD_XMIT | CMD_LAST | CMD_INT;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void *alloc_rfa(struct net_device *dev, void *ptr)\r\n{\r\nvolatile struct rfd_struct *rfd = (struct rfd_struct *) ptr;\r\nvolatile struct rbd_struct *rbd;\r\nint i;\r\nstruct priv *p = netdev_priv(dev);\r\nmemset((char *) rfd, 0, sizeof(struct rfd_struct) * p->num_recv_buffs);\r\np->rfd_first = rfd;\r\nfor (i = 0; i < p->num_recv_buffs; i++) {\r\nrfd[i].next = make16(rfd + (i + 1) % p->num_recv_buffs);\r\n}\r\nrfd[p->num_recv_buffs - 1].last = RFD_SUSP;\r\nptr = (void *) (rfd + p->num_recv_buffs);\r\nrbd = (struct rbd_struct *) ptr;\r\nptr = (void *) (rbd + p->num_recv_buffs);\r\nmemset((char *) rbd, 0, sizeof(struct rbd_struct) * p->num_recv_buffs);\r\nfor (i = 0; i < p->num_recv_buffs; i++) {\r\nrbd[i].next = make16((rbd + (i + 1) % p->num_recv_buffs));\r\nrbd[i].size = RECV_BUFF_SIZE;\r\nrbd[i].buffer = make24(ptr);\r\nptr = (char *) ptr + RECV_BUFF_SIZE;\r\n}\r\np->rfd_top = p->rfd_first;\r\np->rfd_last = p->rfd_first + p->num_recv_buffs - 1;\r\np->scb->rfa_offset = make16(p->rfd_first);\r\np->rfd_first->rbd_offset = make16(rbd);\r\nreturn ptr;\r\n}\r\nstatic irqreturn_t\r\nelmc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nunsigned short stat;\r\nstruct priv *p;\r\nif (!netif_running(dev)) {\r\nelmc_id_attn586();\r\nreturn IRQ_HANDLED;\r\n} else if (!(ELMC_CTRL_INT & inb(dev->base_addr + ELMC_CTRL))) {\r\nreturn IRQ_NONE;\r\n}\r\np = netdev_priv(dev);\r\nwhile ((stat = p->scb->status & STAT_MASK))\r\n{\r\np->scb->cmd = stat;\r\nelmc_attn586();\r\nif (stat & STAT_CX) {\r\nelmc_xmt_int(dev);\r\n}\r\nif (stat & STAT_FR) {\r\nelmc_rcv_int(dev);\r\n}\r\n#ifndef NO_NOPCOMMANDS\r\nif (stat & STAT_CNA) {\r\nif (netif_running(dev)) {\r\npr_warning("%s: oops! CU has left active state. stat: %04x/%04x.\n",\r\ndev->name, (int) stat, (int) p->scb->status);\r\n}\r\n}\r\n#endif\r\nif (stat & STAT_RNR) {\r\nif (p->scb->status & RU_SUSPEND) {\r\nWAIT_4_SCB_CMD();\r\np->scb->cmd = RUC_RESUME;\r\nelmc_attn586();\r\n} else {\r\npr_warning("%s: Receiver-Unit went 'NOT READY': %04x/%04x.\n",\r\ndev->name, (int) stat, (int) p->scb->status);\r\nelmc_rnr_int(dev);\r\n}\r\n}\r\nWAIT_4_SCB_CMD();\r\nif (p->scb->cmd) {\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void elmc_rcv_int(struct net_device *dev)\r\n{\r\nint status;\r\nunsigned short totlen;\r\nstruct sk_buff *skb;\r\nstruct rbd_struct *rbd;\r\nstruct priv *p = netdev_priv(dev);\r\nfor (; (status = p->rfd_top->status) & STAT_COMPL;) {\r\nrbd = (struct rbd_struct *) make32(p->rfd_top->rbd_offset);\r\nif (status & STAT_OK) {\r\nif ((totlen = rbd->status) & RBD_LAST) {\r\ntotlen &= RBD_MASK;\r\nrbd->status = 0;\r\nskb = (struct sk_buff *) dev_alloc_skb(totlen + 2);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\nskb_put(skb,totlen);\r\nskb_copy_to_linear_data(skb, (char *) p->base+(unsigned long) rbd->buffer,totlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += totlen;\r\n} else {\r\ndev->stats.rx_dropped++;\r\n}\r\n} else {\r\npr_warning("%s: received oversized frame.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\n}\r\n} else {\r\npr_warning("%s: oops! rfd-error-status: %04x\n", dev->name, status);\r\ndev->stats.rx_errors++;\r\n}\r\np->rfd_top->status = 0;\r\np->rfd_top->last = RFD_SUSP;\r\np->rfd_last->last = 0;\r\np->rfd_last = p->rfd_top;\r\np->rfd_top = (struct rfd_struct *) make32(p->rfd_top->next);\r\n}\r\n}\r\nstatic void elmc_rnr_int(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\ndev->stats.rx_errors++;\r\nWAIT_4_SCB_CMD();\r\np->scb->cmd = RUC_ABORT;\r\nelmc_attn586();\r\nWAIT_4_SCB_CMD();\r\nalloc_rfa(dev, (char *) p->rfd_first);\r\nstartrecv586(dev);\r\npr_warning("%s: Receive-Unit restarted. Status: %04x\n", dev->name, p->scb->status);\r\n}\r\nstatic void elmc_xmt_int(struct net_device *dev)\r\n{\r\nint status;\r\nstruct priv *p = netdev_priv(dev);\r\nstatus = p->xmit_cmds[p->xmit_last]->cmd_status;\r\nif (!(status & STAT_COMPL)) {\r\npr_warning("%s: strange .. xmit-int without a 'COMPLETE'\n", dev->name);\r\n}\r\nif (status & STAT_OK) {\r\ndev->stats.tx_packets++;\r\ndev->stats.collisions += (status & TCMD_MAXCOLLMASK);\r\n} else {\r\ndev->stats.tx_errors++;\r\nif (status & TCMD_LATECOLL) {\r\npr_warning("%s: late collision detected.\n", dev->name);\r\ndev->stats.collisions++;\r\n} else if (status & TCMD_NOCARRIER) {\r\ndev->stats.tx_carrier_errors++;\r\npr_warning("%s: no carrier detected.\n", dev->name);\r\n} else if (status & TCMD_LOSTCTS) {\r\npr_warning("%s: loss of CTS detected.\n", dev->name);\r\n} else if (status & TCMD_UNDERRUN) {\r\ndev->stats.tx_fifo_errors++;\r\npr_warning("%s: DMA underrun detected.\n", dev->name);\r\n} else if (status & TCMD_MAXCOLL) {\r\npr_warning("%s: Max. collisions exceeded.\n", dev->name);\r\ndev->stats.collisions += 16;\r\n}\r\n}\r\n#if (NUM_XMIT_BUFFS != 1)\r\nif ((++p->xmit_last) == NUM_XMIT_BUFFS) {\r\np->xmit_last = 0;\r\n}\r\n#endif\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void startrecv586(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\np->scb->rfa_offset = make16(p->rfd_first);\r\np->scb->cmd = RUC_START;\r\nelmc_attn586();\r\nWAIT_4_SCB_CMD();\r\n}\r\nstatic void elmc_timeout(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nif (p->scb->status & CU_ACTIVE) {\r\npr_debug("%s: strange ... timeout with CU active?!?\n", dev->name);\r\npr_debug("%s: X0: %04x N0: %04x N1: %04x %d\n", dev->name,\r\n(int)p->xmit_cmds[0]->cmd_status,\r\n(int)p->nop_cmds[0]->cmd_status,\r\n(int)p->nop_cmds[1]->cmd_status, (int)p->nop_point);\r\np->scb->cmd = CUC_ABORT;\r\nelmc_attn586();\r\nWAIT_4_SCB_CMD();\r\np->scb->cbl_offset = make16(p->nop_cmds[p->nop_point]);\r\np->scb->cmd = CUC_START;\r\nelmc_attn586();\r\nWAIT_4_SCB_CMD();\r\nnetif_wake_queue(dev);\r\n} else {\r\npr_debug("%s: xmitter timed out, try to restart! stat: %04x\n",\r\ndev->name, p->scb->status);\r\npr_debug("%s: command-stats: %04x %04x\n", dev->name,\r\np->xmit_cmds[0]->cmd_status, p->xmit_cmds[1]->cmd_status);\r\nelmc_close(dev);\r\nelmc_open(dev);\r\n}\r\n}\r\nstatic netdev_tx_t elmc_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint len;\r\nint i;\r\n#ifndef NO_NOPCOMMANDS\r\nint next_nop;\r\n#endif\r\nstruct priv *p = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nlen = (ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN;\r\nif (len != skb->len)\r\nmemset((char *) p->xmit_cbuffs[p->xmit_count], 0, ETH_ZLEN);\r\nskb_copy_from_linear_data(skb, (char *) p->xmit_cbuffs[p->xmit_count], skb->len);\r\n#if (NUM_XMIT_BUFFS == 1)\r\n#ifdef NO_NOPCOMMANDS\r\np->xmit_buffs[0]->size = TBD_LAST | len;\r\nfor (i = 0; i < 16; i++) {\r\np->scb->cbl_offset = make16(p->xmit_cmds[0]);\r\np->scb->cmd = CUC_START;\r\np->xmit_cmds[0]->cmd_status = 0;\r\nelmc_attn586();\r\nif (!i) {\r\ndev_kfree_skb(skb);\r\n}\r\nWAIT_4_SCB_CMD();\r\nif ((p->scb->status & CU_ACTIVE)) {\r\nbreak;\r\n}\r\nif (p->xmit_cmds[0]->cmd_status) {\r\nbreak;\r\n}\r\nif (i == 15) {\r\npr_warning("%s: Can't start transmit-command.\n", dev->name);\r\n}\r\n}\r\n#else\r\nnext_nop = (p->nop_point + 1) & 0x1;\r\np->xmit_buffs[0]->size = TBD_LAST | len;\r\np->xmit_cmds[0]->cmd_link = p->nop_cmds[next_nop]->cmd_link\r\n= make16((p->nop_cmds[next_nop]));\r\np->xmit_cmds[0]->cmd_status = p->nop_cmds[next_nop]->cmd_status = 0;\r\np->nop_cmds[p->nop_point]->cmd_link = make16((p->xmit_cmds[0]));\r\np->nop_point = next_nop;\r\ndev_kfree_skb(skb);\r\n#endif\r\n#else\r\np->xmit_buffs[p->xmit_count]->size = TBD_LAST | len;\r\nif ((next_nop = p->xmit_count + 1) == NUM_XMIT_BUFFS) {\r\nnext_nop = 0;\r\n}\r\np->xmit_cmds[p->xmit_count]->cmd_status = 0;\r\np->xmit_cmds[p->xmit_count]->cmd_link = p->nop_cmds[next_nop]->cmd_link\r\n= make16((p->nop_cmds[next_nop]));\r\np->nop_cmds[next_nop]->cmd_status = 0;\r\np->nop_cmds[p->xmit_count]->cmd_link = make16((p->xmit_cmds[p->xmit_count]));\r\np->xmit_count = next_nop;\r\nif (p->xmit_count != p->xmit_last)\r\nnetif_wake_queue(dev);\r\ndev_kfree_skb(skb);\r\n#endif\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *elmc_get_stats(struct net_device *dev)\r\n{\r\nstruct priv *p = netdev_priv(dev);\r\nunsigned short crc, aln, rsc, ovrn;\r\ncrc = p->scb->crc_errs;\r\np->scb->crc_errs -= crc;\r\naln = p->scb->aln_errs;\r\np->scb->aln_errs -= aln;\r\nrsc = p->scb->rsc_errs;\r\np->scb->rsc_errs -= rsc;\r\novrn = p->scb->ovrn_errs;\r\np->scb->ovrn_errs -= ovrn;\r\ndev->stats.rx_crc_errors += crc;\r\ndev->stats.rx_fifo_errors += ovrn;\r\ndev->stats.rx_frame_errors += aln;\r\ndev->stats.rx_dropped += rsc;\r\nreturn &dev->stats;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nif (!dev->start) {\r\nreturn;\r\n}\r\ndev->start = 0;\r\nalloc586(dev);\r\ninit586(dev);\r\nstartrecv586(dev);\r\ndev->start = 1;\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->bus_info, "MCA 0x%lx", dev->base_addr);\r\n}\r\nint __init init_module(void)\r\n{\r\nint this_dev,found = 0;\r\nfor(this_dev=0; this_dev<MAX_3C523_CARDS; this_dev++) {\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct priv));\r\nif (!dev)\r\nbreak;\r\ndev->irq=irq[this_dev];\r\ndev->base_addr=io[this_dev];\r\nif (do_elmc_probe(dev) == 0) {\r\ndev_elmc[this_dev] = dev;\r\nfound++;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nif (io[this_dev]==0)\r\nbreak;\r\npr_warning("3c523.c: No 3c523 card found at io=%#x\n",io[this_dev]);\r\n}\r\nif(found==0) {\r\nif (io[0]==0)\r\npr_notice("3c523.c: No 3c523 cards found\n");\r\nreturn -ENXIO;\r\n} else return 0;\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev=0; this_dev<MAX_3C523_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_elmc[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
