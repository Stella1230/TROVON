static inline u8 virtfn_bus(struct pci_dev *dev, int id)\r\n{\r\nreturn dev->bus->number + ((dev->devfn + dev->sriov->offset +\r\ndev->sriov->stride * id) >> 8);\r\n}\r\nstatic inline u8 virtfn_devfn(struct pci_dev *dev, int id)\r\n{\r\nreturn (dev->devfn + dev->sriov->offset +\r\ndev->sriov->stride * id) & 0xff;\r\n}\r\nstatic struct pci_bus *virtfn_add_bus(struct pci_bus *bus, int busnr)\r\n{\r\nint rc;\r\nstruct pci_bus *child;\r\nif (bus->number == busnr)\r\nreturn bus;\r\nchild = pci_find_bus(pci_domain_nr(bus), busnr);\r\nif (child)\r\nreturn child;\r\nchild = pci_add_new_bus(bus, NULL, busnr);\r\nif (!child)\r\nreturn NULL;\r\nchild->subordinate = busnr;\r\nchild->dev.parent = bus->bridge;\r\nrc = pci_bus_add_child(child);\r\nif (rc) {\r\npci_remove_bus(child);\r\nreturn NULL;\r\n}\r\nreturn child;\r\n}\r\nstatic void virtfn_remove_bus(struct pci_bus *bus, int busnr)\r\n{\r\nstruct pci_bus *child;\r\nif (bus->number == busnr)\r\nreturn;\r\nchild = pci_find_bus(pci_domain_nr(bus), busnr);\r\nBUG_ON(!child);\r\nif (list_empty(&child->devices))\r\npci_remove_bus(child);\r\n}\r\nstatic int virtfn_add(struct pci_dev *dev, int id, int reset)\r\n{\r\nint i;\r\nint rc;\r\nu64 size;\r\nchar buf[VIRTFN_ID_LEN];\r\nstruct pci_dev *virtfn;\r\nstruct resource *res;\r\nstruct pci_sriov *iov = dev->sriov;\r\nvirtfn = alloc_pci_dev();\r\nif (!virtfn)\r\nreturn -ENOMEM;\r\nmutex_lock(&iov->dev->sriov->lock);\r\nvirtfn->bus = virtfn_add_bus(dev->bus, virtfn_bus(dev, id));\r\nif (!virtfn->bus) {\r\nkfree(virtfn);\r\nmutex_unlock(&iov->dev->sriov->lock);\r\nreturn -ENOMEM;\r\n}\r\nvirtfn->devfn = virtfn_devfn(dev, id);\r\nvirtfn->vendor = dev->vendor;\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_DID, &virtfn->device);\r\npci_setup_device(virtfn);\r\nvirtfn->dev.parent = dev->dev.parent;\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = dev->resource + PCI_IOV_RESOURCES + i;\r\nif (!res->parent)\r\ncontinue;\r\nvirtfn->resource[i].name = pci_name(virtfn);\r\nvirtfn->resource[i].flags = res->flags;\r\nsize = resource_size(res);\r\ndo_div(size, iov->total);\r\nvirtfn->resource[i].start = res->start + size * id;\r\nvirtfn->resource[i].end = virtfn->resource[i].start + size - 1;\r\nrc = request_resource(res, &virtfn->resource[i]);\r\nBUG_ON(rc);\r\n}\r\nif (reset)\r\n__pci_reset_function(virtfn);\r\npci_device_add(virtfn, virtfn->bus);\r\nmutex_unlock(&iov->dev->sriov->lock);\r\nvirtfn->physfn = pci_dev_get(dev);\r\nvirtfn->is_virtfn = 1;\r\nrc = pci_bus_add_device(virtfn);\r\nif (rc)\r\ngoto failed1;\r\nsprintf(buf, "virtfn%u", id);\r\nrc = sysfs_create_link(&dev->dev.kobj, &virtfn->dev.kobj, buf);\r\nif (rc)\r\ngoto failed1;\r\nrc = sysfs_create_link(&virtfn->dev.kobj, &dev->dev.kobj, "physfn");\r\nif (rc)\r\ngoto failed2;\r\nkobject_uevent(&virtfn->dev.kobj, KOBJ_CHANGE);\r\nreturn 0;\r\nfailed2:\r\nsysfs_remove_link(&dev->dev.kobj, buf);\r\nfailed1:\r\npci_dev_put(dev);\r\nmutex_lock(&iov->dev->sriov->lock);\r\npci_remove_bus_device(virtfn);\r\nvirtfn_remove_bus(dev->bus, virtfn_bus(dev, id));\r\nmutex_unlock(&iov->dev->sriov->lock);\r\nreturn rc;\r\n}\r\nstatic void virtfn_remove(struct pci_dev *dev, int id, int reset)\r\n{\r\nchar buf[VIRTFN_ID_LEN];\r\nstruct pci_bus *bus;\r\nstruct pci_dev *virtfn;\r\nstruct pci_sriov *iov = dev->sriov;\r\nbus = pci_find_bus(pci_domain_nr(dev->bus), virtfn_bus(dev, id));\r\nif (!bus)\r\nreturn;\r\nvirtfn = pci_get_slot(bus, virtfn_devfn(dev, id));\r\nif (!virtfn)\r\nreturn;\r\npci_dev_put(virtfn);\r\nif (reset) {\r\ndevice_release_driver(&virtfn->dev);\r\n__pci_reset_function(virtfn);\r\n}\r\nsprintf(buf, "virtfn%u", id);\r\nsysfs_remove_link(&dev->dev.kobj, buf);\r\nsysfs_remove_link(&virtfn->dev.kobj, "physfn");\r\nmutex_lock(&iov->dev->sriov->lock);\r\npci_remove_bus_device(virtfn);\r\nvirtfn_remove_bus(dev->bus, virtfn_bus(dev, id));\r\nmutex_unlock(&iov->dev->sriov->lock);\r\npci_dev_put(dev);\r\n}\r\nstatic int sriov_migration(struct pci_dev *dev)\r\n{\r\nu16 status;\r\nstruct pci_sriov *iov = dev->sriov;\r\nif (!iov->nr_virtfn)\r\nreturn 0;\r\nif (!(iov->cap & PCI_SRIOV_CAP_VFM))\r\nreturn 0;\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_STATUS, &status);\r\nif (!(status & PCI_SRIOV_STATUS_VFM))\r\nreturn 0;\r\nschedule_work(&iov->mtask);\r\nreturn 1;\r\n}\r\nstatic void sriov_migration_task(struct work_struct *work)\r\n{\r\nint i;\r\nu8 state;\r\nu16 status;\r\nstruct pci_sriov *iov = container_of(work, struct pci_sriov, mtask);\r\nfor (i = iov->initial; i < iov->nr_virtfn; i++) {\r\nstate = readb(iov->mstate + i);\r\nif (state == PCI_SRIOV_VFM_MI) {\r\nwriteb(PCI_SRIOV_VFM_AV, iov->mstate + i);\r\nstate = readb(iov->mstate + i);\r\nif (state == PCI_SRIOV_VFM_AV)\r\nvirtfn_add(iov->self, i, 1);\r\n} else if (state == PCI_SRIOV_VFM_MO) {\r\nvirtfn_remove(iov->self, i, 1);\r\nwriteb(PCI_SRIOV_VFM_UA, iov->mstate + i);\r\nstate = readb(iov->mstate + i);\r\nif (state == PCI_SRIOV_VFM_AV)\r\nvirtfn_add(iov->self, i, 0);\r\n}\r\n}\r\npci_read_config_word(iov->self, iov->pos + PCI_SRIOV_STATUS, &status);\r\nstatus &= ~PCI_SRIOV_STATUS_VFM;\r\npci_write_config_word(iov->self, iov->pos + PCI_SRIOV_STATUS, status);\r\n}\r\nstatic int sriov_enable_migration(struct pci_dev *dev, int nr_virtfn)\r\n{\r\nint bir;\r\nu32 table;\r\nresource_size_t pa;\r\nstruct pci_sriov *iov = dev->sriov;\r\nif (nr_virtfn <= iov->initial)\r\nreturn 0;\r\npci_read_config_dword(dev, iov->pos + PCI_SRIOV_VFM, &table);\r\nbir = PCI_SRIOV_VFM_BIR(table);\r\nif (bir > PCI_STD_RESOURCE_END)\r\nreturn -EIO;\r\ntable = PCI_SRIOV_VFM_OFFSET(table);\r\nif (table + nr_virtfn > pci_resource_len(dev, bir))\r\nreturn -EIO;\r\npa = pci_resource_start(dev, bir) + table;\r\niov->mstate = ioremap(pa, nr_virtfn);\r\nif (!iov->mstate)\r\nreturn -ENOMEM;\r\nINIT_WORK(&iov->mtask, sriov_migration_task);\r\niov->ctrl |= PCI_SRIOV_CTRL_VFM | PCI_SRIOV_CTRL_INTR;\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\nreturn 0;\r\n}\r\nstatic void sriov_disable_migration(struct pci_dev *dev)\r\n{\r\nstruct pci_sriov *iov = dev->sriov;\r\niov->ctrl &= ~(PCI_SRIOV_CTRL_VFM | PCI_SRIOV_CTRL_INTR);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\ncancel_work_sync(&iov->mtask);\r\niounmap(iov->mstate);\r\n}\r\nstatic int sriov_enable(struct pci_dev *dev, int nr_virtfn)\r\n{\r\nint rc;\r\nint i, j;\r\nint nres;\r\nu16 offset, stride, initial;\r\nstruct resource *res;\r\nstruct pci_dev *pdev;\r\nstruct pci_sriov *iov = dev->sriov;\r\nif (!nr_virtfn)\r\nreturn 0;\r\nif (iov->nr_virtfn)\r\nreturn -EINVAL;\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_INITIAL_VF, &initial);\r\nif (initial > iov->total ||\r\n(!(iov->cap & PCI_SRIOV_CAP_VFM) && (initial != iov->total)))\r\nreturn -EIO;\r\nif (nr_virtfn < 0 || nr_virtfn > iov->total ||\r\n(!(iov->cap & PCI_SRIOV_CAP_VFM) && (nr_virtfn > initial)))\r\nreturn -EINVAL;\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, nr_virtfn);\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_OFFSET, &offset);\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_STRIDE, &stride);\r\nif (!offset || (nr_virtfn > 1 && !stride))\r\nreturn -EIO;\r\nnres = 0;\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = dev->resource + PCI_IOV_RESOURCES + i;\r\nif (res->parent)\r\nnres++;\r\n}\r\nif (nres != iov->nres) {\r\ndev_err(&dev->dev, "not enough MMIO resources for SR-IOV\n");\r\nreturn -ENOMEM;\r\n}\r\niov->offset = offset;\r\niov->stride = stride;\r\nif (virtfn_bus(dev, nr_virtfn - 1) > dev->bus->subordinate) {\r\ndev_err(&dev->dev, "SR-IOV: bus number out of range\n");\r\nreturn -ENOMEM;\r\n}\r\nif (iov->link != dev->devfn) {\r\npdev = pci_get_slot(dev->bus, iov->link);\r\nif (!pdev)\r\nreturn -ENODEV;\r\npci_dev_put(pdev);\r\nif (!pdev->is_physfn)\r\nreturn -ENODEV;\r\nrc = sysfs_create_link(&dev->dev.kobj,\r\n&pdev->dev.kobj, "dep_link");\r\nif (rc)\r\nreturn rc;\r\n}\r\niov->ctrl |= PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE;\r\npci_block_user_cfg_access(dev);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\nmsleep(100);\r\npci_unblock_user_cfg_access(dev);\r\niov->initial = initial;\r\nif (nr_virtfn < initial)\r\ninitial = nr_virtfn;\r\nfor (i = 0; i < initial; i++) {\r\nrc = virtfn_add(dev, i, 0);\r\nif (rc)\r\ngoto failed;\r\n}\r\nif (iov->cap & PCI_SRIOV_CAP_VFM) {\r\nrc = sriov_enable_migration(dev, nr_virtfn);\r\nif (rc)\r\ngoto failed;\r\n}\r\nkobject_uevent(&dev->dev.kobj, KOBJ_CHANGE);\r\niov->nr_virtfn = nr_virtfn;\r\nreturn 0;\r\nfailed:\r\nfor (j = 0; j < i; j++)\r\nvirtfn_remove(dev, j, 0);\r\niov->ctrl &= ~(PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE);\r\npci_block_user_cfg_access(dev);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\nssleep(1);\r\npci_unblock_user_cfg_access(dev);\r\nif (iov->link != dev->devfn)\r\nsysfs_remove_link(&dev->dev.kobj, "dep_link");\r\nreturn rc;\r\n}\r\nstatic void sriov_disable(struct pci_dev *dev)\r\n{\r\nint i;\r\nstruct pci_sriov *iov = dev->sriov;\r\nif (!iov->nr_virtfn)\r\nreturn;\r\nif (iov->cap & PCI_SRIOV_CAP_VFM)\r\nsriov_disable_migration(dev);\r\nfor (i = 0; i < iov->nr_virtfn; i++)\r\nvirtfn_remove(dev, i, 0);\r\niov->ctrl &= ~(PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE);\r\npci_block_user_cfg_access(dev);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\nssleep(1);\r\npci_unblock_user_cfg_access(dev);\r\nif (iov->link != dev->devfn)\r\nsysfs_remove_link(&dev->dev.kobj, "dep_link");\r\niov->nr_virtfn = 0;\r\n}\r\nstatic int sriov_init(struct pci_dev *dev, int pos)\r\n{\r\nint i;\r\nint rc;\r\nint nres;\r\nu32 pgsz;\r\nu16 ctrl, total, offset, stride;\r\nstruct pci_sriov *iov;\r\nstruct resource *res;\r\nstruct pci_dev *pdev;\r\nif (dev->pcie_type != PCI_EXP_TYPE_RC_END &&\r\ndev->pcie_type != PCI_EXP_TYPE_ENDPOINT)\r\nreturn -ENODEV;\r\npci_read_config_word(dev, pos + PCI_SRIOV_CTRL, &ctrl);\r\nif (ctrl & PCI_SRIOV_CTRL_VFE) {\r\npci_write_config_word(dev, pos + PCI_SRIOV_CTRL, 0);\r\nssleep(1);\r\n}\r\npci_read_config_word(dev, pos + PCI_SRIOV_TOTAL_VF, &total);\r\nif (!total)\r\nreturn 0;\r\nctrl = 0;\r\nlist_for_each_entry(pdev, &dev->bus->devices, bus_list)\r\nif (pdev->is_physfn)\r\ngoto found;\r\npdev = NULL;\r\nif (pci_ari_enabled(dev->bus))\r\nctrl |= PCI_SRIOV_CTRL_ARI;\r\nfound:\r\npci_write_config_word(dev, pos + PCI_SRIOV_CTRL, ctrl);\r\npci_write_config_word(dev, pos + PCI_SRIOV_NUM_VF, total);\r\npci_read_config_word(dev, pos + PCI_SRIOV_VF_OFFSET, &offset);\r\npci_read_config_word(dev, pos + PCI_SRIOV_VF_STRIDE, &stride);\r\nif (!offset || (total > 1 && !stride))\r\nreturn -EIO;\r\npci_read_config_dword(dev, pos + PCI_SRIOV_SUP_PGSIZE, &pgsz);\r\ni = PAGE_SHIFT > 12 ? PAGE_SHIFT - 12 : 0;\r\npgsz &= ~((1 << i) - 1);\r\nif (!pgsz)\r\nreturn -EIO;\r\npgsz &= ~(pgsz - 1);\r\npci_write_config_dword(dev, pos + PCI_SRIOV_SYS_PGSIZE, pgsz);\r\nnres = 0;\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = dev->resource + PCI_IOV_RESOURCES + i;\r\ni += __pci_read_base(dev, pci_bar_unknown, res,\r\npos + PCI_SRIOV_BAR + i * 4);\r\nif (!res->flags)\r\ncontinue;\r\nif (resource_size(res) & (PAGE_SIZE - 1)) {\r\nrc = -EIO;\r\ngoto failed;\r\n}\r\nres->end = res->start + resource_size(res) * total - 1;\r\nnres++;\r\n}\r\niov = kzalloc(sizeof(*iov), GFP_KERNEL);\r\nif (!iov) {\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\niov->pos = pos;\r\niov->nres = nres;\r\niov->ctrl = ctrl;\r\niov->total = total;\r\niov->offset = offset;\r\niov->stride = stride;\r\niov->pgsz = pgsz;\r\niov->self = dev;\r\npci_read_config_dword(dev, pos + PCI_SRIOV_CAP, &iov->cap);\r\npci_read_config_byte(dev, pos + PCI_SRIOV_FUNC_LINK, &iov->link);\r\nif (dev->pcie_type == PCI_EXP_TYPE_RC_END)\r\niov->link = PCI_DEVFN(PCI_SLOT(dev->devfn), iov->link);\r\nif (pdev)\r\niov->dev = pci_dev_get(pdev);\r\nelse\r\niov->dev = dev;\r\nmutex_init(&iov->lock);\r\ndev->sriov = iov;\r\ndev->is_physfn = 1;\r\nreturn 0;\r\nfailed:\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = dev->resource + PCI_IOV_RESOURCES + i;\r\nres->flags = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic void sriov_release(struct pci_dev *dev)\r\n{\r\nBUG_ON(dev->sriov->nr_virtfn);\r\nif (dev != dev->sriov->dev)\r\npci_dev_put(dev->sriov->dev);\r\nmutex_destroy(&dev->sriov->lock);\r\nkfree(dev->sriov);\r\ndev->sriov = NULL;\r\n}\r\nstatic void sriov_restore_state(struct pci_dev *dev)\r\n{\r\nint i;\r\nu16 ctrl;\r\nstruct pci_sriov *iov = dev->sriov;\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_CTRL, &ctrl);\r\nif (ctrl & PCI_SRIOV_CTRL_VFE)\r\nreturn;\r\nfor (i = PCI_IOV_RESOURCES; i <= PCI_IOV_RESOURCE_END; i++)\r\npci_update_resource(dev, i);\r\npci_write_config_dword(dev, iov->pos + PCI_SRIOV_SYS_PGSIZE, iov->pgsz);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, iov->nr_virtfn);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\nif (iov->ctrl & PCI_SRIOV_CTRL_VFE)\r\nmsleep(100);\r\n}\r\nint pci_iov_init(struct pci_dev *dev)\r\n{\r\nint pos;\r\nif (!pci_is_pcie(dev))\r\nreturn -ENODEV;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);\r\nif (pos)\r\nreturn sriov_init(dev, pos);\r\nreturn -ENODEV;\r\n}\r\nvoid pci_iov_release(struct pci_dev *dev)\r\n{\r\nif (dev->is_physfn)\r\nsriov_release(dev);\r\n}\r\nint pci_iov_resource_bar(struct pci_dev *dev, int resno,\r\nenum pci_bar_type *type)\r\n{\r\nif (resno < PCI_IOV_RESOURCES || resno > PCI_IOV_RESOURCE_END)\r\nreturn 0;\r\nBUG_ON(!dev->is_physfn);\r\n*type = pci_bar_unknown;\r\nreturn dev->sriov->pos + PCI_SRIOV_BAR +\r\n4 * (resno - PCI_IOV_RESOURCES);\r\n}\r\nresource_size_t pci_sriov_resource_alignment(struct pci_dev *dev, int resno)\r\n{\r\nstruct resource tmp;\r\nenum pci_bar_type type;\r\nint reg = pci_iov_resource_bar(dev, resno, &type);\r\nif (!reg)\r\nreturn 0;\r\n__pci_read_base(dev, type, &tmp, reg);\r\nreturn resource_alignment(&tmp);\r\n}\r\nvoid pci_restore_iov_state(struct pci_dev *dev)\r\n{\r\nif (dev->is_physfn)\r\nsriov_restore_state(dev);\r\n}\r\nint pci_iov_bus_range(struct pci_bus *bus)\r\n{\r\nint max = 0;\r\nu8 busnr;\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (!dev->is_physfn)\r\ncontinue;\r\nbusnr = virtfn_bus(dev, dev->sriov->total - 1);\r\nif (busnr > max)\r\nmax = busnr;\r\n}\r\nreturn max ? max - bus->number : 0;\r\n}\r\nint pci_enable_sriov(struct pci_dev *dev, int nr_virtfn)\r\n{\r\nmight_sleep();\r\nif (!dev->is_physfn)\r\nreturn -ENODEV;\r\nreturn sriov_enable(dev, nr_virtfn);\r\n}\r\nvoid pci_disable_sriov(struct pci_dev *dev)\r\n{\r\nmight_sleep();\r\nif (!dev->is_physfn)\r\nreturn;\r\nsriov_disable(dev);\r\n}\r\nirqreturn_t pci_sriov_migration(struct pci_dev *dev)\r\n{\r\nif (!dev->is_physfn)\r\nreturn IRQ_NONE;\r\nreturn sriov_migration(dev) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nint pci_num_vf(struct pci_dev *dev)\r\n{\r\nif (!dev || !dev->is_physfn)\r\nreturn 0;\r\nelse\r\nreturn dev->sriov->nr_virtfn;\r\n}\r\nstatic int ats_alloc_one(struct pci_dev *dev, int ps)\r\n{\r\nint pos;\r\nu16 cap;\r\nstruct pci_ats *ats;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ATS);\r\nif (!pos)\r\nreturn -ENODEV;\r\nats = kzalloc(sizeof(*ats), GFP_KERNEL);\r\nif (!ats)\r\nreturn -ENOMEM;\r\nats->pos = pos;\r\nats->stu = ps;\r\npci_read_config_word(dev, pos + PCI_ATS_CAP, &cap);\r\nats->qdep = PCI_ATS_CAP_QDEP(cap) ? PCI_ATS_CAP_QDEP(cap) :\r\nPCI_ATS_MAX_QDEP;\r\ndev->ats = ats;\r\nreturn 0;\r\n}\r\nstatic void ats_free_one(struct pci_dev *dev)\r\n{\r\nkfree(dev->ats);\r\ndev->ats = NULL;\r\n}\r\nint pci_enable_ats(struct pci_dev *dev, int ps)\r\n{\r\nint rc;\r\nu16 ctrl;\r\nBUG_ON(dev->ats && dev->ats->is_enabled);\r\nif (ps < PCI_ATS_MIN_STU)\r\nreturn -EINVAL;\r\nif (dev->is_physfn || dev->is_virtfn) {\r\nstruct pci_dev *pdev = dev->is_physfn ? dev : dev->physfn;\r\nmutex_lock(&pdev->sriov->lock);\r\nif (pdev->ats)\r\nrc = pdev->ats->stu == ps ? 0 : -EINVAL;\r\nelse\r\nrc = ats_alloc_one(pdev, ps);\r\nif (!rc)\r\npdev->ats->ref_cnt++;\r\nmutex_unlock(&pdev->sriov->lock);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (!dev->is_physfn) {\r\nrc = ats_alloc_one(dev, ps);\r\nif (rc)\r\nreturn rc;\r\n}\r\nctrl = PCI_ATS_CTRL_ENABLE;\r\nif (!dev->is_virtfn)\r\nctrl |= PCI_ATS_CTRL_STU(ps - PCI_ATS_MIN_STU);\r\npci_write_config_word(dev, dev->ats->pos + PCI_ATS_CTRL, ctrl);\r\ndev->ats->is_enabled = 1;\r\nreturn 0;\r\n}\r\nvoid pci_disable_ats(struct pci_dev *dev)\r\n{\r\nu16 ctrl;\r\nBUG_ON(!dev->ats || !dev->ats->is_enabled);\r\npci_read_config_word(dev, dev->ats->pos + PCI_ATS_CTRL, &ctrl);\r\nctrl &= ~PCI_ATS_CTRL_ENABLE;\r\npci_write_config_word(dev, dev->ats->pos + PCI_ATS_CTRL, ctrl);\r\ndev->ats->is_enabled = 0;\r\nif (dev->is_physfn || dev->is_virtfn) {\r\nstruct pci_dev *pdev = dev->is_physfn ? dev : dev->physfn;\r\nmutex_lock(&pdev->sriov->lock);\r\npdev->ats->ref_cnt--;\r\nif (!pdev->ats->ref_cnt)\r\nats_free_one(pdev);\r\nmutex_unlock(&pdev->sriov->lock);\r\n}\r\nif (!dev->is_physfn)\r\nats_free_one(dev);\r\n}\r\nint pci_ats_queue_depth(struct pci_dev *dev)\r\n{\r\nint pos;\r\nu16 cap;\r\nif (dev->is_virtfn)\r\nreturn 0;\r\nif (dev->ats)\r\nreturn dev->ats->qdep;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ATS);\r\nif (!pos)\r\nreturn -ENODEV;\r\npci_read_config_word(dev, pos + PCI_ATS_CAP, &cap);\r\nreturn PCI_ATS_CAP_QDEP(cap) ? PCI_ATS_CAP_QDEP(cap) :\r\nPCI_ATS_MAX_QDEP;\r\n}
