int\r\nsal_pcibr_slot_enable(struct pcibus_info *soft, int device, void *resp,\r\nchar **ssdt)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nu64 busnum;\r\nu64 segment;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nsegment = soft->pbi_buscommon.bs_persist_segment;\r\nbusnum = soft->pbi_buscommon.bs_persist_busnum;\r\nSAL_CALL_NOLOCK(ret_stuff, (u64) SN_SAL_IOIF_SLOT_ENABLE, segment,\r\nbusnum, (u64) device, (u64) resp, (u64)ia64_tpa(ssdt),\r\n0, 0);\r\nreturn (int)ret_stuff.v0;\r\n}\r\nint\r\nsal_pcibr_slot_disable(struct pcibus_info *soft, int device, int action,\r\nvoid *resp)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nu64 busnum;\r\nu64 segment;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nsegment = soft->pbi_buscommon.bs_persist_segment;\r\nbusnum = soft->pbi_buscommon.bs_persist_busnum;\r\nSAL_CALL_NOLOCK(ret_stuff, (u64) SN_SAL_IOIF_SLOT_DISABLE,\r\nsegment, busnum, (u64) device, (u64) action,\r\n(u64) resp, 0, 0);\r\nreturn (int)ret_stuff.v0;\r\n}\r\nstatic int sal_pcibr_error_interrupt(struct pcibus_info *soft)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nu64 busnum;\r\nint segment;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nsegment = soft->pbi_buscommon.bs_persist_segment;\r\nbusnum = soft->pbi_buscommon.bs_persist_busnum;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_ERROR_INTERRUPT,\r\n(u64) segment, (u64) busnum, 0, 0, 0, 0, 0);\r\nreturn (int)ret_stuff.v0;\r\n}\r\nu16 sn_ioboard_to_pci_bus(struct pci_bus *pci_bus)\r\n{\r\nlong rc;\r\nu16 uninitialized_var(ioboard);\r\nnasid_t nasid = NASID_GET(SN_PCIBUS_BUSSOFT(pci_bus)->bs_base);\r\nrc = ia64_sn_sysctl_ioboard_get(nasid, &ioboard);\r\nif (rc) {\r\nprintk(KERN_WARNING "ia64_sn_sysctl_ioboard_get failed: %ld\n",\r\nrc);\r\nreturn 0;\r\n}\r\nreturn ioboard;\r\n}\r\nstatic irqreturn_t\r\npcibr_error_intr_handler(int irq, void *arg)\r\n{\r\nstruct pcibus_info *soft = arg;\r\nif (sal_pcibr_error_interrupt(soft) < 0)\r\npanic("pcibr_error_intr_handler(): Fatal Bridge Error");\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid *\r\npcibr_bus_fixup(struct pcibus_bussoft *prom_bussoft, struct pci_controller *controller)\r\n{\r\nint nasid, cnode, j;\r\nstruct hubdev_info *hubdev_info;\r\nstruct pcibus_info *soft;\r\nstruct sn_flush_device_kernel *sn_flush_device_kernel;\r\nstruct sn_flush_device_common *common;\r\nif (! IS_PCI_BRIDGE_ASIC(prom_bussoft->bs_asic_type)) {\r\nreturn NULL;\r\n}\r\nsoft = kmalloc(sizeof(struct pcibus_info), GFP_KERNEL);\r\nif (!soft) {\r\nreturn NULL;\r\n}\r\nmemcpy(soft, prom_bussoft, sizeof(struct pcibus_info));\r\nsoft->pbi_buscommon.bs_base = (unsigned long)\r\nioremap(REGION_OFFSET(soft->pbi_buscommon.bs_base),\r\nsizeof(struct pic));\r\nspin_lock_init(&soft->pbi_lock);\r\nif (request_irq(SGI_PCIASIC_ERROR, pcibr_error_intr_handler,\r\nIRQF_SHARED, "PCIBR error", (void *)(soft))) {\r\nprintk(KERN_WARNING\r\n"pcibr cannot allocate interrupt for error handler\n");\r\n}\r\nsn_set_err_irq_affinity(SGI_PCIASIC_ERROR);\r\nif (PAGE_SIZE < 16384) {\r\npcireg_control_bit_clr(soft, PCIBR_CTRL_PAGE_SIZE);\r\n} else {\r\npcireg_control_bit_set(soft, PCIBR_CTRL_PAGE_SIZE);\r\n}\r\nnasid = NASID_GET(soft->pbi_buscommon.bs_base);\r\ncnode = nasid_to_cnodeid(nasid);\r\nhubdev_info = (struct hubdev_info *)(NODEPDA(cnode)->pdinfo);\r\nif (hubdev_info->hdi_flush_nasid_list.widget_p) {\r\nsn_flush_device_kernel = hubdev_info->hdi_flush_nasid_list.\r\nwidget_p[(int)soft->pbi_buscommon.bs_xid];\r\nif (sn_flush_device_kernel) {\r\nfor (j = 0; j < DEV_PER_WIDGET;\r\nj++, sn_flush_device_kernel++) {\r\ncommon = sn_flush_device_kernel->common;\r\nif (common->sfdl_slot == -1)\r\ncontinue;\r\nif ((common->sfdl_persistent_segment ==\r\nsoft->pbi_buscommon.bs_persist_segment) &&\r\n(common->sfdl_persistent_busnum ==\r\nsoft->pbi_buscommon.bs_persist_busnum))\r\ncommon->sfdl_pcibus_info =\r\nsoft;\r\n}\r\n}\r\n}\r\nsoft->pbi_int_ate_resource.lowest_free_index = 0;\r\nsoft->pbi_int_ate_resource.ate =\r\nkzalloc(soft->pbi_int_ate_size * sizeof(u64), GFP_KERNEL);\r\nif (!soft->pbi_int_ate_resource.ate) {\r\nkfree(soft);\r\nreturn NULL;\r\n}\r\nreturn soft;\r\n}\r\nvoid pcibr_force_interrupt(struct sn_irq_info *sn_irq_info)\r\n{\r\nstruct pcidev_info *pcidev_info;\r\nstruct pcibus_info *pcibus_info;\r\nint bit = sn_irq_info->irq_int_bit;\r\nif (! sn_irq_info->irq_bridge)\r\nreturn;\r\npcidev_info = (struct pcidev_info *)sn_irq_info->irq_pciioinfo;\r\nif (pcidev_info) {\r\npcibus_info =\r\n(struct pcibus_info *)pcidev_info->pdi_host_pcidev_info->\r\npdi_pcibus_info;\r\npcireg_force_intr_set(pcibus_info, bit);\r\n}\r\n}\r\nvoid pcibr_target_interrupt(struct sn_irq_info *sn_irq_info)\r\n{\r\nstruct pcidev_info *pcidev_info;\r\nstruct pcibus_info *pcibus_info;\r\nint bit = sn_irq_info->irq_int_bit;\r\nu64 xtalk_addr = sn_irq_info->irq_xtalkaddr;\r\npcidev_info = (struct pcidev_info *)sn_irq_info->irq_pciioinfo;\r\nif (pcidev_info) {\r\npcibus_info =\r\n(struct pcibus_info *)pcidev_info->pdi_host_pcidev_info->\r\npdi_pcibus_info;\r\npcireg_intr_enable_bit_clr(pcibus_info, (1 << bit));\r\npcireg_intr_addr_addr_set(pcibus_info, bit, xtalk_addr);\r\npcireg_intr_enable_bit_set(pcibus_info, (1 << bit));\r\npcibr_force_interrupt(sn_irq_info);\r\n}\r\n}\r\nint\r\npcibr_init_provider(void)\r\n{\r\nsn_pci_provider[PCIIO_ASIC_TYPE_PIC] = &pcibr_provider;\r\nsn_pci_provider[PCIIO_ASIC_TYPE_TIOCP] = &pcibr_provider;\r\nreturn 0;\r\n}
