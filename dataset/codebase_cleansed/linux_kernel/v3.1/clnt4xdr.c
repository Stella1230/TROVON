static s64 loff_t_to_s64(loff_t offset)\r\n{\r\ns64 res;\r\nif (offset >= NLM4_OFFSET_MAX)\r\nres = NLM4_OFFSET_MAX;\r\nelse if (offset <= -NLM4_OFFSET_MAX)\r\nres = -NLM4_OFFSET_MAX;\r\nelse\r\nres = offset;\r\nreturn res;\r\n}\r\nstatic void nlm4_compute_offsets(const struct nlm_lock *lock,\r\nu64 *l_offset, u64 *l_len)\r\n{\r\nconst struct file_lock *fl = &lock->fl;\r\nBUG_ON(fl->fl_start > NLM4_OFFSET_MAX);\r\nBUG_ON(fl->fl_end > NLM4_OFFSET_MAX &&\r\nfl->fl_end != OFFSET_MAX);\r\n*l_offset = loff_t_to_s64(fl->fl_start);\r\nif (fl->fl_end == OFFSET_MAX)\r\n*l_len = 0;\r\nelse\r\n*l_len = loff_t_to_s64(fl->fl_end - fl->fl_start + 1);\r\n}\r\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\r\n{\r\ndprintk("lockd: %s prematurely hit the end of our receive buffer. "\r\n"Remaining buffer length is %tu words.\n",\r\nfunc, xdr->end - xdr->p);\r\n}\r\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4);\r\n*p = value ? xdr_one : xdr_zero;\r\n}\r\nstatic void encode_int32(struct xdr_stream *xdr, const s32 value)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4);\r\n*p = cpu_to_be32(value);\r\n}\r\nstatic void encode_netobj(struct xdr_stream *xdr,\r\nconst u8 *data, const unsigned int length)\r\n{\r\n__be32 *p;\r\nBUG_ON(length > XDR_MAX_NETOBJ);\r\np = xdr_reserve_space(xdr, 4 + length);\r\nxdr_encode_opaque(p, data, length);\r\n}\r\nstatic int decode_netobj(struct xdr_stream *xdr,\r\nstruct xdr_netobj *obj)\r\n{\r\nu32 length;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nlength = be32_to_cpup(p++);\r\nif (unlikely(length > XDR_MAX_NETOBJ))\r\ngoto out_size;\r\nobj->len = length;\r\nobj->data = (u8 *)p;\r\nreturn 0;\r\nout_size:\r\ndprintk("NFS: returned netobj was too long: %u\n", length);\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_cookie(struct xdr_stream *xdr,\r\nconst struct nlm_cookie *cookie)\r\n{\r\nBUG_ON(cookie->len > NLM_MAXCOOKIELEN);\r\nencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\r\n}\r\nstatic int decode_cookie(struct xdr_stream *xdr,\r\nstruct nlm_cookie *cookie)\r\n{\r\nu32 length;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nlength = be32_to_cpup(p++);\r\nif (length == 0)\r\ngoto out_hpux;\r\nif (length > NLM_MAXCOOKIELEN)\r\ngoto out_size;\r\np = xdr_inline_decode(xdr, length);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\ncookie->len = length;\r\nmemcpy(cookie->data, p, length);\r\nreturn 0;\r\nout_hpux:\r\ncookie->len = 4;\r\nmemset(cookie->data, 0, 4);\r\nreturn 0;\r\nout_size:\r\ndprintk("NFS: returned cookie was too long: %u\n", length);\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_fh(struct xdr_stream *xdr, const struct nfs_fh *fh)\r\n{\r\nBUG_ON(fh->size > NFS3_FHSIZE);\r\nencode_netobj(xdr, (u8 *)&fh->data, fh->size);\r\n}\r\nstatic void encode_nlm4_stat(struct xdr_stream *xdr,\r\nconst __be32 stat)\r\n{\r\n__be32 *p;\r\nBUG_ON(be32_to_cpu(stat) > NLM_FAILED);\r\np = xdr_reserve_space(xdr, 4);\r\n*p = stat;\r\n}\r\nstatic int decode_nlm4_stat(struct xdr_stream *xdr, __be32 *stat)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (unlikely(*p > nlm4_failed))\r\ngoto out_bad_xdr;\r\n*stat = *p;\r\nreturn 0;\r\nout_bad_xdr:\r\ndprintk("%s: server returned invalid nlm4_stats value: %u\n",\r\n__func__, be32_to_cpup(p));\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_nlm4_holder(struct xdr_stream *xdr,\r\nconst struct nlm_res *result)\r\n{\r\nconst struct nlm_lock *lock = &result->lock;\r\nu64 l_offset, l_len;\r\n__be32 *p;\r\nencode_bool(xdr, lock->fl.fl_type == F_RDLCK);\r\nencode_int32(xdr, lock->svid);\r\nencode_netobj(xdr, lock->oh.data, lock->oh.len);\r\np = xdr_reserve_space(xdr, 4 + 4);\r\nnlm4_compute_offsets(lock, &l_offset, &l_len);\r\np = xdr_encode_hyper(p, l_offset);\r\nxdr_encode_hyper(p, l_len);\r\n}\r\nstatic int decode_nlm4_holder(struct xdr_stream *xdr, struct nlm_res *result)\r\n{\r\nstruct nlm_lock *lock = &result->lock;\r\nstruct file_lock *fl = &lock->fl;\r\nu64 l_offset, l_len;\r\nu32 exclusive;\r\nint error;\r\n__be32 *p;\r\ns32 end;\r\nmemset(lock, 0, sizeof(*lock));\r\nlocks_init_lock(fl);\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nexclusive = be32_to_cpup(p++);\r\nlock->svid = be32_to_cpup(p);\r\nfl->fl_pid = (pid_t)lock->svid;\r\nerror = decode_netobj(xdr, &lock->oh);\r\nif (unlikely(error))\r\ngoto out;\r\np = xdr_inline_decode(xdr, 8 + 8);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nfl->fl_flags = FL_POSIX;\r\nfl->fl_type = exclusive != 0 ? F_WRLCK : F_RDLCK;\r\np = xdr_decode_hyper(p, &l_offset);\r\nxdr_decode_hyper(p, &l_len);\r\nend = l_offset + l_len - 1;\r\nfl->fl_start = (loff_t)l_offset;\r\nif (l_len == 0 || end < 0)\r\nfl->fl_end = OFFSET_MAX;\r\nelse\r\nfl->fl_end = (loff_t)end;\r\nerror = 0;\r\nout:\r\nreturn error;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_caller_name(struct xdr_stream *xdr, const char *name)\r\n{\r\nu32 length = strlen(name);\r\n__be32 *p;\r\nBUG_ON(length > NLM_MAXSTRLEN);\r\np = xdr_reserve_space(xdr, 4 + length);\r\nxdr_encode_opaque(p, name, length);\r\n}\r\nstatic void encode_nlm4_lock(struct xdr_stream *xdr,\r\nconst struct nlm_lock *lock)\r\n{\r\nu64 l_offset, l_len;\r\n__be32 *p;\r\nencode_caller_name(xdr, lock->caller);\r\nencode_fh(xdr, &lock->fh);\r\nencode_netobj(xdr, lock->oh.data, lock->oh.len);\r\np = xdr_reserve_space(xdr, 4 + 8 + 8);\r\n*p++ = cpu_to_be32(lock->svid);\r\nnlm4_compute_offsets(lock, &l_offset, &l_len);\r\np = xdr_encode_hyper(p, l_offset);\r\nxdr_encode_hyper(p, l_len);\r\n}\r\nstatic void nlm4_xdr_enc_testargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_args *args)\r\n{\r\nconst struct nlm_lock *lock = &args->lock;\r\nencode_cookie(xdr, &args->cookie);\r\nencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\r\nencode_nlm4_lock(xdr, lock);\r\n}\r\nstatic void nlm4_xdr_enc_lockargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_args *args)\r\n{\r\nconst struct nlm_lock *lock = &args->lock;\r\nencode_cookie(xdr, &args->cookie);\r\nencode_bool(xdr, args->block);\r\nencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\r\nencode_nlm4_lock(xdr, lock);\r\nencode_bool(xdr, args->reclaim);\r\nencode_int32(xdr, args->state);\r\n}\r\nstatic void nlm4_xdr_enc_cancargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_args *args)\r\n{\r\nconst struct nlm_lock *lock = &args->lock;\r\nencode_cookie(xdr, &args->cookie);\r\nencode_bool(xdr, args->block);\r\nencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\r\nencode_nlm4_lock(xdr, lock);\r\n}\r\nstatic void nlm4_xdr_enc_unlockargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_args *args)\r\n{\r\nconst struct nlm_lock *lock = &args->lock;\r\nencode_cookie(xdr, &args->cookie);\r\nencode_nlm4_lock(xdr, lock);\r\n}\r\nstatic void nlm4_xdr_enc_res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_res *result)\r\n{\r\nencode_cookie(xdr, &result->cookie);\r\nencode_nlm4_stat(xdr, result->status);\r\n}\r\nstatic void nlm4_xdr_enc_testres(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_res *result)\r\n{\r\nencode_cookie(xdr, &result->cookie);\r\nencode_nlm4_stat(xdr, result->status);\r\nif (result->status == nlm_lck_denied)\r\nencode_nlm4_holder(xdr, result);\r\n}\r\nstatic int decode_nlm4_testrply(struct xdr_stream *xdr,\r\nstruct nlm_res *result)\r\n{\r\nint error;\r\nerror = decode_nlm4_stat(xdr, &result->status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (result->status == nlm_lck_denied)\r\nerror = decode_nlm4_holder(xdr, result);\r\nout:\r\nreturn error;\r\n}\r\nstatic int nlm4_xdr_dec_testres(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nlm_res *result)\r\n{\r\nint error;\r\nerror = decode_cookie(xdr, &result->cookie);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_nlm4_testrply(xdr, result);\r\nout:\r\nreturn error;\r\n}\r\nstatic int nlm4_xdr_dec_res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nlm_res *result)\r\n{\r\nint error;\r\nerror = decode_cookie(xdr, &result->cookie);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_nlm4_stat(xdr, &result->status);\r\nout:\r\nreturn error;\r\n}
