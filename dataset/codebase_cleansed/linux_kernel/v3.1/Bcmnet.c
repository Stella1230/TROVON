static INT bcm_open(struct net_device *dev)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(dev);\r\nif (Adapter->fw_download_done == FALSE) {\r\npr_notice(PFX "%s: link up failed (download in progress)\n",\r\ndev->name);\r\nreturn -EBUSY;\r\n}\r\nif (netif_msg_ifup(Adapter))\r\npr_info(PFX "%s: enabling interface\n", dev->name);\r\nif (Adapter->LinkUpStatus) {\r\nif (netif_msg_link(Adapter))\r\npr_info(PFX "%s: link up\n", dev->name);\r\nnetif_carrier_on(Adapter->dev);\r\nnetif_start_queue(Adapter->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic INT bcm_close(struct net_device *dev)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(dev);\r\nif (netif_msg_ifdown(Adapter))\r\npr_info(PFX "%s: disabling interface\n", dev->name);\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic u16 bcm_select_queue(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nreturn ClassifyPacket(netdev_priv(dev), skb);\r\n}\r\nstatic netdev_tx_t bcm_transmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(dev);\r\nu16 qindex = skb_get_queue_mapping(skb);\r\nif (Adapter->device_removed || !Adapter->LinkUpStatus)\r\ngoto drop;\r\nif (Adapter->TransferMode != IP_PACKET_ONLY_MODE)\r\ngoto drop;\r\nif (INVALID_QUEUE_INDEX == qindex)\r\ngoto drop;\r\nif (Adapter->PackInfo[qindex].uiCurrentPacketsOnHost >=\r\nSF_MAX_ALLOWED_PACKETS_TO_BACKUP)\r\nreturn NETDEV_TX_BUSY;\r\nif (netif_msg_tx_queued(Adapter))\r\npr_info(PFX "%s: enqueueing packet to queue %d\n",\r\ndev->name, qindex);\r\nspin_lock(&Adapter->PackInfo[qindex].SFQueueLock);\r\nAdapter->PackInfo[qindex].uiCurrentBytesOnHost += skb->len;\r\nAdapter->PackInfo[qindex].uiCurrentPacketsOnHost++;\r\n*((B_UINT32 *) skb->cb + SKB_CB_LATENCY_OFFSET) = jiffies;\r\nENQUEUEPACKET(Adapter->PackInfo[qindex].FirstTxQueue,\r\nAdapter->PackInfo[qindex].LastTxQueue, skb);\r\natomic_inc(&Adapter->TotalPacketCount);\r\nspin_unlock(&Adapter->PackInfo[qindex].SFQueueLock);\r\nif (!atomic_read(&Adapter->TxPktAvail)) {\r\natomic_set(&Adapter->TxPktAvail, 1);\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\n}\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int bcm_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\ncmd->supported = 0;\r\ncmd->advertising = 0;\r\ncmd->speed = SPEED_10000;\r\ncmd->duplex = DUPLEX_FULL;\r\ncmd->port = PORT_TP;\r\ncmd->phy_address = 0;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->maxtxpkt = 0;\r\ncmd->maxrxpkt = 0;\r\nreturn 0;\r\n}\r\nstatic void bcm_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(dev);\r\nPS_INTERFACE_ADAPTER psIntfAdapter = Adapter->pvInterfaceAdapter;\r\nstruct usb_device *udev = interface_to_usbdev(psIntfAdapter->interface);\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsnprintf(info->fw_version, sizeof(info->fw_version), "%u.%u",\r\nAdapter->uiFlashLayoutMajorVersion,\r\nAdapter->uiFlashLayoutMinorVersion);\r\nusb_make_path(udev, info->bus_info, sizeof(info->bus_info));\r\n}\r\nstatic u32 bcm_get_link(struct net_device *dev)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(dev);\r\nreturn Adapter->LinkUpStatus;\r\n}\r\nstatic u32 bcm_get_msglevel(struct net_device *dev)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(dev);\r\nreturn Adapter->msg_enable;\r\n}\r\nstatic void bcm_set_msglevel(struct net_device *dev, u32 level)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(dev);\r\nAdapter->msg_enable = level;\r\n}\r\nint register_networkdev(PMINI_ADAPTER Adapter)\r\n{\r\nstruct net_device *net = Adapter->dev;\r\nPS_INTERFACE_ADAPTER IntfAdapter = Adapter->pvInterfaceAdapter;\r\nstruct usb_interface *udev = IntfAdapter->interface;\r\nstruct usb_device *xdev = IntfAdapter->udev;\r\nint result;\r\nnet->netdev_ops = &bcmNetDevOps;\r\nnet->ethtool_ops = &bcm_ethtool_ops;\r\nnet->mtu = MTU_SIZE;\r\nnet->tx_queue_len = TX_QLEN;\r\nnet->flags |= IFF_NOARP;\r\nnetif_carrier_off(net);\r\nSET_NETDEV_DEVTYPE(net, &wimax_type);\r\nresult = ReadMacAddressFromNVM(Adapter);\r\nif (result != STATUS_SUCCESS) {\r\ndev_err(&udev->dev,\r\nPFX "Error in Reading the mac Address: %d", result);\r\nreturn -EIO;\r\n}\r\nresult = register_netdev(net);\r\nif (result)\r\nreturn result;\r\ngblpnetdev = Adapter->dev;\r\nif (netif_msg_probe(Adapter))\r\ndev_info(&udev->dev, PFX "%s: register usb-%s-%s %pM\n",\r\nnet->name, xdev->bus->bus_name, xdev->devpath,\r\nnet->dev_addr);\r\nreturn 0;\r\n}\r\nvoid unregister_networkdev(PMINI_ADAPTER Adapter)\r\n{\r\nstruct net_device *net = Adapter->dev;\r\nPS_INTERFACE_ADAPTER IntfAdapter = Adapter->pvInterfaceAdapter;\r\nstruct usb_interface *udev = IntfAdapter->interface;\r\nstruct usb_device *xdev = IntfAdapter->udev;\r\nif (netif_msg_probe(Adapter))\r\ndev_info(&udev->dev, PFX "%s: unregister usb-%s%s\n",\r\nnet->name, xdev->bus->bus_name, xdev->devpath);\r\nunregister_netdev(Adapter->dev);\r\n}
