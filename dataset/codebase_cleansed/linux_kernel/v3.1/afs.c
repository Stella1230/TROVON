static u32 word_sum(void *words, int num)\r\n{\r\nu32 *p = words;\r\nu32 sum = 0;\r\nwhile (num--)\r\nsum += *p++;\r\nreturn sum;\r\n}\r\nstatic int\r\nafs_read_footer(struct mtd_info *mtd, u_int *img_start, u_int *iis_start,\r\nu_int off, u_int mask)\r\n{\r\nstruct footer_struct fs;\r\nu_int ptr = off + mtd->erasesize - sizeof(fs);\r\nsize_t sz;\r\nint ret;\r\nret = mtd->read(mtd, ptr, sizeof(fs), &sz, (u_char *) &fs);\r\nif (ret >= 0 && sz != sizeof(fs))\r\nret = -EINVAL;\r\nif (ret < 0) {\r\nprintk(KERN_ERR "AFS: mtd read failed at 0x%x: %d\n",\r\nptr, ret);\r\nreturn ret;\r\n}\r\nret = 1;\r\nif (fs.signature != 0xa0ffff9f)\r\nret = 0;\r\nif (word_sum(&fs, sizeof(fs) / sizeof(u32)) != 0xffffffff)\r\nret = 0;\r\nif (fs.type == 2)\r\nret = 0;\r\n*iis_start = fs.image_info_base & mask;\r\n*img_start = fs.image_start & mask;\r\nif (*iis_start >= ptr)\r\nret = 0;\r\nif (*img_start > off)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int\r\nafs_read_iis(struct mtd_info *mtd, struct image_info_struct *iis, u_int ptr)\r\n{\r\nsize_t sz;\r\nint ret, i;\r\nmemset(iis, 0, sizeof(*iis));\r\nret = mtd->read(mtd, ptr, sizeof(*iis), &sz, (u_char *) iis);\r\nif (ret < 0)\r\ngoto failed;\r\nif (sz != sizeof(*iis)) {\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nret = 0;\r\nfor (i = 0; i < sizeof(iis->name); i++)\r\nif (iis->name[i] == '\0')\r\nbreak;\r\nif (i < sizeof(iis->name))\r\nret = 1;\r\nreturn ret;\r\nfailed:\r\nprintk(KERN_ERR "AFS: mtd read failed at 0x%x: %d\n",\r\nptr, ret);\r\nreturn ret;\r\n}\r\nstatic int parse_afs_partitions(struct mtd_info *mtd,\r\nstruct mtd_partition **pparts,\r\nunsigned long origin)\r\n{\r\nstruct mtd_partition *parts;\r\nu_int mask, off, idx, sz;\r\nint ret = 0;\r\nchar *str;\r\nmask = mtd->size - 1;\r\nfor (idx = off = sz = 0; off < mtd->size; off += mtd->erasesize) {\r\nstruct image_info_struct iis;\r\nu_int iis_ptr, img_ptr;\r\nret = afs_read_footer(mtd, &img_ptr, &iis_ptr, off, mask);\r\nif (ret < 0)\r\nbreak;\r\nif (ret == 0)\r\ncontinue;\r\nret = afs_read_iis(mtd, &iis, iis_ptr);\r\nif (ret < 0)\r\nbreak;\r\nif (ret == 0)\r\ncontinue;\r\nsz += sizeof(struct mtd_partition);\r\nsz += strlen(iis.name) + 1;\r\nidx += 1;\r\n}\r\nif (!sz)\r\nreturn ret;\r\nparts = kzalloc(sz, GFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\nstr = (char *)(parts + idx);\r\nfor (idx = off = 0; off < mtd->size; off += mtd->erasesize) {\r\nstruct image_info_struct iis;\r\nu_int iis_ptr, img_ptr;\r\nret = afs_read_footer(mtd, &img_ptr, &iis_ptr, off, mask);\r\nif (ret < 0)\r\nbreak;\r\nif (ret == 0)\r\ncontinue;\r\nret = afs_read_iis(mtd, &iis, iis_ptr);\r\nif (ret < 0)\r\nbreak;\r\nif (ret == 0)\r\ncontinue;\r\nstrcpy(str, iis.name);\r\nparts[idx].name = str;\r\nparts[idx].size = (iis.length + mtd->erasesize - 1) & ~(mtd->erasesize - 1);\r\nparts[idx].offset = img_ptr;\r\nparts[idx].mask_flags = 0;\r\nprintk(" mtd%d: at 0x%08x, %5lluKiB, %8u, %s\n",\r\nidx, img_ptr, parts[idx].size / 1024,\r\niis.imageNumber, str);\r\nidx += 1;\r\nstr = str + strlen(iis.name) + 1;\r\n}\r\nif (!idx) {\r\nkfree(parts);\r\nparts = NULL;\r\n}\r\n*pparts = parts;\r\nreturn idx ? idx : ret;\r\n}\r\nstatic int __init afs_parser_init(void)\r\n{\r\nreturn register_mtd_parser(&afs_parser);\r\n}\r\nstatic void __exit afs_parser_exit(void)\r\n{\r\nderegister_mtd_parser(&afs_parser);\r\n}
