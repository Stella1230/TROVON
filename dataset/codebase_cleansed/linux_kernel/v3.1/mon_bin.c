static inline struct mon_bin_hdr *MON_OFF2HDR(const struct mon_reader_bin *rp,\r\nunsigned int offset)\r\n{\r\nreturn (struct mon_bin_hdr *)\r\n(rp->b_vec[offset / CHUNK_SIZE].ptr + offset % CHUNK_SIZE);\r\n}\r\nstatic unsigned int mon_copy_to_buff(const struct mon_reader_bin *this,\r\nunsigned int off, const unsigned char *from, unsigned int length)\r\n{\r\nunsigned int step_len;\r\nunsigned char *buf;\r\nunsigned int in_page;\r\nwhile (length) {\r\nstep_len = length;\r\nin_page = CHUNK_SIZE - (off & (CHUNK_SIZE-1));\r\nif (in_page < step_len)\r\nstep_len = in_page;\r\nbuf = this->b_vec[off / CHUNK_SIZE].ptr + off % CHUNK_SIZE;\r\nmemcpy(buf, from, step_len);\r\nif ((off += step_len) >= this->b_size) off = 0;\r\nfrom += step_len;\r\nlength -= step_len;\r\n}\r\nreturn off;\r\n}\r\nstatic int copy_from_buf(const struct mon_reader_bin *this, unsigned int off,\r\nchar __user *to, int length)\r\n{\r\nunsigned int step_len;\r\nunsigned char *buf;\r\nunsigned int in_page;\r\nwhile (length) {\r\nstep_len = length;\r\nin_page = CHUNK_SIZE - (off & (CHUNK_SIZE-1));\r\nif (in_page < step_len)\r\nstep_len = in_page;\r\nbuf = this->b_vec[off / CHUNK_SIZE].ptr + off % CHUNK_SIZE;\r\nif (copy_to_user(to, buf, step_len))\r\nreturn -EINVAL;\r\nif ((off += step_len) >= this->b_size) off = 0;\r\nto += step_len;\r\nlength -= step_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int mon_buff_area_alloc(struct mon_reader_bin *rp,\r\nunsigned int size)\r\n{\r\nunsigned int offset;\r\nsize = (size + PKT_ALIGN-1) & ~(PKT_ALIGN-1);\r\nif (rp->b_cnt + size > rp->b_size)\r\nreturn ~0;\r\noffset = rp->b_in;\r\nrp->b_cnt += size;\r\nif ((rp->b_in += size) >= rp->b_size)\r\nrp->b_in -= rp->b_size;\r\nreturn offset;\r\n}\r\nstatic unsigned int mon_buff_area_alloc_contiguous(struct mon_reader_bin *rp,\r\nunsigned int size)\r\n{\r\nunsigned int offset;\r\nunsigned int fill_size;\r\nsize = (size + PKT_ALIGN-1) & ~(PKT_ALIGN-1);\r\nif (rp->b_cnt + size > rp->b_size)\r\nreturn ~0;\r\nif (rp->b_in + size > rp->b_size) {\r\nfill_size = rp->b_size - rp->b_in;\r\nif (rp->b_cnt + size + fill_size > rp->b_size)\r\nreturn ~0;\r\nmon_buff_area_fill(rp, rp->b_in, fill_size);\r\noffset = 0;\r\nrp->b_in = size;\r\nrp->b_cnt += size + fill_size;\r\n} else if (rp->b_in + size == rp->b_size) {\r\noffset = rp->b_in;\r\nrp->b_in = 0;\r\nrp->b_cnt += size;\r\n} else {\r\noffset = rp->b_in;\r\nrp->b_in += size;\r\nrp->b_cnt += size;\r\n}\r\nreturn offset;\r\n}\r\nstatic void mon_buff_area_shrink(struct mon_reader_bin *rp, unsigned int size)\r\n{\r\nrp->b_cnt -= size;\r\nif (rp->b_in < size)\r\nrp->b_in += rp->b_size;\r\nrp->b_in -= size;\r\n}\r\nstatic void mon_buff_area_free(struct mon_reader_bin *rp, unsigned int size)\r\n{\r\nsize = (size + PKT_ALIGN-1) & ~(PKT_ALIGN-1);\r\nrp->b_cnt -= size;\r\nif ((rp->b_out += size) >= rp->b_size)\r\nrp->b_out -= rp->b_size;\r\n}\r\nstatic void mon_buff_area_fill(const struct mon_reader_bin *rp,\r\nunsigned int offset, unsigned int size)\r\n{\r\nstruct mon_bin_hdr *ep;\r\nep = MON_OFF2HDR(rp, offset);\r\nmemset(ep, 0, PKT_SIZE);\r\nep->type = '@';\r\nep->len_cap = size - PKT_SIZE;\r\n}\r\nstatic inline char mon_bin_get_setup(unsigned char *setupb,\r\nconst struct urb *urb, char ev_type)\r\n{\r\nif (urb->setup_packet == NULL)\r\nreturn 'Z';\r\nmemcpy(setupb, urb->setup_packet, SETUP_LEN);\r\nreturn 0;\r\n}\r\nstatic unsigned int mon_bin_get_data(const struct mon_reader_bin *rp,\r\nunsigned int offset, struct urb *urb, unsigned int length,\r\nchar *flag)\r\n{\r\nint i;\r\nstruct scatterlist *sg;\r\nunsigned int this_len;\r\n*flag = 0;\r\nif (urb->num_sgs == 0) {\r\nif (urb->transfer_buffer == NULL) {\r\n*flag = 'Z';\r\nreturn length;\r\n}\r\nmon_copy_to_buff(rp, offset, urb->transfer_buffer, length);\r\nlength = 0;\r\n} else {\r\nif (urb->transfer_flags & URB_DMA_SG_COMBINED) {\r\n*flag = 'D';\r\nreturn length;\r\n}\r\nfor_each_sg(urb->sg, sg, urb->num_sgs, i) {\r\nif (length == 0 || PageHighMem(sg_page(sg)))\r\nbreak;\r\nthis_len = min_t(unsigned int, sg->length, length);\r\noffset = mon_copy_to_buff(rp, offset, sg_virt(sg),\r\nthis_len);\r\nlength -= this_len;\r\n}\r\nif (i == 0)\r\n*flag = 'D';\r\n}\r\nreturn length;\r\n}\r\nstatic unsigned int mon_bin_collate_isodesc(const struct mon_reader_bin *rp,\r\nstruct urb *urb, unsigned int ndesc)\r\n{\r\nstruct usb_iso_packet_descriptor *fp;\r\nunsigned int length;\r\nlength = 0;\r\nfp = urb->iso_frame_desc;\r\nwhile (ndesc-- != 0) {\r\nif (fp->actual_length != 0) {\r\nif (fp->offset + fp->actual_length > length)\r\nlength = fp->offset + fp->actual_length;\r\n}\r\nfp++;\r\n}\r\nreturn length;\r\n}\r\nstatic void mon_bin_get_isodesc(const struct mon_reader_bin *rp,\r\nunsigned int offset, struct urb *urb, char ev_type, unsigned int ndesc)\r\n{\r\nstruct mon_bin_isodesc *dp;\r\nstruct usb_iso_packet_descriptor *fp;\r\nfp = urb->iso_frame_desc;\r\nwhile (ndesc-- != 0) {\r\ndp = (struct mon_bin_isodesc *)\r\n(rp->b_vec[offset / CHUNK_SIZE].ptr + offset % CHUNK_SIZE);\r\ndp->iso_status = fp->status;\r\ndp->iso_off = fp->offset;\r\ndp->iso_len = (ev_type == 'S') ? fp->length : fp->actual_length;\r\ndp->_pad = 0;\r\nif ((offset += sizeof(struct mon_bin_isodesc)) >= rp->b_size)\r\noffset = 0;\r\nfp++;\r\n}\r\n}\r\nstatic void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,\r\nchar ev_type, int status)\r\n{\r\nconst struct usb_endpoint_descriptor *epd = &urb->ep->desc;\r\nstruct timeval ts;\r\nunsigned long flags;\r\nunsigned int urb_length;\r\nunsigned int offset;\r\nunsigned int length;\r\nunsigned int delta;\r\nunsigned int ndesc, lendesc;\r\nunsigned char dir;\r\nstruct mon_bin_hdr *ep;\r\nchar data_tag = 0;\r\ndo_gettimeofday(&ts);\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nurb_length = (ev_type == 'S') ?\r\nurb->transfer_buffer_length : urb->actual_length;\r\nlength = urb_length;\r\nif (usb_endpoint_xfer_isoc(epd)) {\r\nif (urb->number_of_packets < 0) {\r\nndesc = 0;\r\n} else if (urb->number_of_packets >= ISODESC_MAX) {\r\nndesc = ISODESC_MAX;\r\n} else {\r\nndesc = urb->number_of_packets;\r\n}\r\nif (ev_type == 'C' && usb_urb_dir_in(urb))\r\nlength = mon_bin_collate_isodesc(rp, urb, ndesc);\r\n} else {\r\nndesc = 0;\r\n}\r\nlendesc = ndesc*sizeof(struct mon_bin_isodesc);\r\nif (length >= urb->transfer_buffer_length)\r\nlength = urb->transfer_buffer_length;\r\nif (length >= rp->b_size/5)\r\nlength = rp->b_size/5;\r\nif (usb_urb_dir_in(urb)) {\r\nif (ev_type == 'S') {\r\nlength = 0;\r\ndata_tag = '<';\r\n}\r\ndir = USB_DIR_IN;\r\n} else {\r\nif (ev_type == 'C') {\r\nlength = 0;\r\ndata_tag = '>';\r\n}\r\ndir = 0;\r\n}\r\nif (rp->mmap_active) {\r\noffset = mon_buff_area_alloc_contiguous(rp,\r\nlength + PKT_SIZE + lendesc);\r\n} else {\r\noffset = mon_buff_area_alloc(rp, length + PKT_SIZE + lendesc);\r\n}\r\nif (offset == ~0) {\r\nrp->cnt_lost++;\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nreturn;\r\n}\r\nep = MON_OFF2HDR(rp, offset);\r\nif ((offset += PKT_SIZE) >= rp->b_size) offset = 0;\r\nmemset(ep, 0, PKT_SIZE);\r\nep->type = ev_type;\r\nep->xfer_type = xfer_to_pipe[usb_endpoint_type(epd)];\r\nep->epnum = dir | usb_endpoint_num(epd);\r\nep->devnum = urb->dev->devnum;\r\nep->busnum = urb->dev->bus->busnum;\r\nep->id = (unsigned long) urb;\r\nep->ts_sec = ts.tv_sec;\r\nep->ts_usec = ts.tv_usec;\r\nep->status = status;\r\nep->len_urb = urb_length;\r\nep->len_cap = length + lendesc;\r\nep->xfer_flags = urb->transfer_flags;\r\nif (usb_endpoint_xfer_int(epd)) {\r\nep->interval = urb->interval;\r\n} else if (usb_endpoint_xfer_isoc(epd)) {\r\nep->interval = urb->interval;\r\nep->start_frame = urb->start_frame;\r\nep->s.iso.error_count = urb->error_count;\r\nep->s.iso.numdesc = urb->number_of_packets;\r\n}\r\nif (usb_endpoint_xfer_control(epd) && ev_type == 'S') {\r\nep->flag_setup = mon_bin_get_setup(ep->s.setup, urb, ev_type);\r\n} else {\r\nep->flag_setup = '-';\r\n}\r\nif (ndesc != 0) {\r\nep->ndesc = ndesc;\r\nmon_bin_get_isodesc(rp, offset, urb, ev_type, ndesc);\r\nif ((offset += lendesc) >= rp->b_size)\r\noffset -= rp->b_size;\r\n}\r\nif (length != 0) {\r\nlength = mon_bin_get_data(rp, offset, urb, length,\r\n&ep->flag_data);\r\nif (length > 0) {\r\ndelta = (ep->len_cap + PKT_ALIGN-1) & ~(PKT_ALIGN-1);\r\nep->len_cap -= length;\r\ndelta -= (ep->len_cap + PKT_ALIGN-1) & ~(PKT_ALIGN-1);\r\nmon_buff_area_shrink(rp, delta);\r\n}\r\n} else {\r\nep->flag_data = data_tag;\r\n}\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nwake_up(&rp->b_wait);\r\n}\r\nstatic void mon_bin_submit(void *data, struct urb *urb)\r\n{\r\nstruct mon_reader_bin *rp = data;\r\nmon_bin_event(rp, urb, 'S', -EINPROGRESS);\r\n}\r\nstatic void mon_bin_complete(void *data, struct urb *urb, int status)\r\n{\r\nstruct mon_reader_bin *rp = data;\r\nmon_bin_event(rp, urb, 'C', status);\r\n}\r\nstatic void mon_bin_error(void *data, struct urb *urb, int error)\r\n{\r\nstruct mon_reader_bin *rp = data;\r\nstruct timeval ts;\r\nunsigned long flags;\r\nunsigned int offset;\r\nstruct mon_bin_hdr *ep;\r\ndo_gettimeofday(&ts);\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\noffset = mon_buff_area_alloc(rp, PKT_SIZE);\r\nif (offset == ~0) {\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nreturn;\r\n}\r\nep = MON_OFF2HDR(rp, offset);\r\nmemset(ep, 0, PKT_SIZE);\r\nep->type = 'E';\r\nep->xfer_type = xfer_to_pipe[usb_endpoint_type(&urb->ep->desc)];\r\nep->epnum = usb_urb_dir_in(urb) ? USB_DIR_IN : 0;\r\nep->epnum |= usb_endpoint_num(&urb->ep->desc);\r\nep->devnum = urb->dev->devnum;\r\nep->busnum = urb->dev->bus->busnum;\r\nep->id = (unsigned long) urb;\r\nep->ts_sec = ts.tv_sec;\r\nep->ts_usec = ts.tv_usec;\r\nep->status = error;\r\nep->flag_setup = '-';\r\nep->flag_data = 'E';\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nwake_up(&rp->b_wait);\r\n}\r\nstatic int mon_bin_open(struct inode *inode, struct file *file)\r\n{\r\nstruct mon_bus *mbus;\r\nstruct mon_reader_bin *rp;\r\nsize_t size;\r\nint rc;\r\nmutex_lock(&mon_lock);\r\nif ((mbus = mon_bus_lookup(iminor(inode))) == NULL) {\r\nmutex_unlock(&mon_lock);\r\nreturn -ENODEV;\r\n}\r\nif (mbus != &mon_bus0 && mbus->u_bus == NULL) {\r\nprintk(KERN_ERR TAG ": consistency error on open\n");\r\nmutex_unlock(&mon_lock);\r\nreturn -ENODEV;\r\n}\r\nrp = kzalloc(sizeof(struct mon_reader_bin), GFP_KERNEL);\r\nif (rp == NULL) {\r\nrc = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nspin_lock_init(&rp->b_lock);\r\ninit_waitqueue_head(&rp->b_wait);\r\nmutex_init(&rp->fetch_lock);\r\nrp->b_size = BUFF_DFL;\r\nsize = sizeof(struct mon_pgmap) * (rp->b_size/CHUNK_SIZE);\r\nif ((rp->b_vec = kzalloc(size, GFP_KERNEL)) == NULL) {\r\nrc = -ENOMEM;\r\ngoto err_allocvec;\r\n}\r\nif ((rc = mon_alloc_buff(rp->b_vec, rp->b_size/CHUNK_SIZE)) < 0)\r\ngoto err_allocbuff;\r\nrp->r.m_bus = mbus;\r\nrp->r.r_data = rp;\r\nrp->r.rnf_submit = mon_bin_submit;\r\nrp->r.rnf_error = mon_bin_error;\r\nrp->r.rnf_complete = mon_bin_complete;\r\nmon_reader_add(mbus, &rp->r);\r\nfile->private_data = rp;\r\nmutex_unlock(&mon_lock);\r\nreturn 0;\r\nerr_allocbuff:\r\nkfree(rp->b_vec);\r\nerr_allocvec:\r\nkfree(rp);\r\nerr_alloc:\r\nmutex_unlock(&mon_lock);\r\nreturn rc;\r\n}\r\nstatic int mon_bin_get_event(struct file *file, struct mon_reader_bin *rp,\r\nstruct mon_bin_hdr __user *hdr, unsigned int hdrbytes,\r\nvoid __user *data, unsigned int nbytes)\r\n{\r\nunsigned long flags;\r\nstruct mon_bin_hdr *ep;\r\nsize_t step_len;\r\nunsigned int offset;\r\nint rc;\r\nmutex_lock(&rp->fetch_lock);\r\nif ((rc = mon_bin_wait_event(file, rp)) < 0) {\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn rc;\r\n}\r\nep = MON_OFF2HDR(rp, rp->b_out);\r\nif (copy_to_user(hdr, ep, hdrbytes)) {\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn -EFAULT;\r\n}\r\nstep_len = min(ep->len_cap, nbytes);\r\nif ((offset = rp->b_out + PKT_SIZE) >= rp->b_size) offset = 0;\r\nif (copy_from_buf(rp, offset, data, step_len)) {\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn -EFAULT;\r\n}\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nmon_buff_area_free(rp, PKT_SIZE + ep->len_cap);\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nrp->b_read = 0;\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn 0;\r\n}\r\nstatic int mon_bin_release(struct inode *inode, struct file *file)\r\n{\r\nstruct mon_reader_bin *rp = file->private_data;\r\nstruct mon_bus* mbus = rp->r.m_bus;\r\nmutex_lock(&mon_lock);\r\nif (mbus->nreaders <= 0) {\r\nprintk(KERN_ERR TAG ": consistency error on close\n");\r\nmutex_unlock(&mon_lock);\r\nreturn 0;\r\n}\r\nmon_reader_del(mbus, &rp->r);\r\nmon_free_buff(rp->b_vec, rp->b_size/CHUNK_SIZE);\r\nkfree(rp->b_vec);\r\nkfree(rp);\r\nmutex_unlock(&mon_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t mon_bin_read(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct mon_reader_bin *rp = file->private_data;\r\nunsigned int hdrbytes = PKT_SZ_API0;\r\nunsigned long flags;\r\nstruct mon_bin_hdr *ep;\r\nunsigned int offset;\r\nsize_t step_len;\r\nchar *ptr;\r\nssize_t done = 0;\r\nint rc;\r\nmutex_lock(&rp->fetch_lock);\r\nif ((rc = mon_bin_wait_event(file, rp)) < 0) {\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn rc;\r\n}\r\nep = MON_OFF2HDR(rp, rp->b_out);\r\nif (rp->b_read < hdrbytes) {\r\nstep_len = min(nbytes, (size_t)(hdrbytes - rp->b_read));\r\nptr = ((char *)ep) + rp->b_read;\r\nif (step_len && copy_to_user(buf, ptr, step_len)) {\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn -EFAULT;\r\n}\r\nnbytes -= step_len;\r\nbuf += step_len;\r\nrp->b_read += step_len;\r\ndone += step_len;\r\n}\r\nif (rp->b_read >= hdrbytes) {\r\nstep_len = ep->len_cap;\r\nstep_len -= rp->b_read - hdrbytes;\r\nif (step_len > nbytes)\r\nstep_len = nbytes;\r\noffset = rp->b_out + PKT_SIZE;\r\noffset += rp->b_read - hdrbytes;\r\nif (offset >= rp->b_size)\r\noffset -= rp->b_size;\r\nif (copy_from_buf(rp, offset, buf, step_len)) {\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn -EFAULT;\r\n}\r\nnbytes -= step_len;\r\nbuf += step_len;\r\nrp->b_read += step_len;\r\ndone += step_len;\r\n}\r\nif (rp->b_read >= hdrbytes + ep->len_cap) {\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nmon_buff_area_free(rp, PKT_SIZE + ep->len_cap);\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nrp->b_read = 0;\r\n}\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn done;\r\n}\r\nstatic int mon_bin_flush(struct mon_reader_bin *rp, unsigned nevents)\r\n{\r\nunsigned long flags;\r\nstruct mon_bin_hdr *ep;\r\nint i;\r\nmutex_lock(&rp->fetch_lock);\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nfor (i = 0; i < nevents; ++i) {\r\nif (MON_RING_EMPTY(rp))\r\nbreak;\r\nep = MON_OFF2HDR(rp, rp->b_out);\r\nmon_buff_area_free(rp, PKT_SIZE + ep->len_cap);\r\n}\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nrp->b_read = 0;\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn i;\r\n}\r\nstatic int mon_bin_fetch(struct file *file, struct mon_reader_bin *rp,\r\nu32 __user *vec, unsigned int max)\r\n{\r\nunsigned int cur_out;\r\nunsigned int bytes, avail;\r\nunsigned int size;\r\nunsigned int nevents;\r\nstruct mon_bin_hdr *ep;\r\nunsigned long flags;\r\nint rc;\r\nmutex_lock(&rp->fetch_lock);\r\nif ((rc = mon_bin_wait_event(file, rp)) < 0) {\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn rc;\r\n}\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\navail = rp->b_cnt;\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\ncur_out = rp->b_out;\r\nnevents = 0;\r\nbytes = 0;\r\nwhile (bytes < avail) {\r\nif (nevents >= max)\r\nbreak;\r\nep = MON_OFF2HDR(rp, cur_out);\r\nif (put_user(cur_out, &vec[nevents])) {\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn -EFAULT;\r\n}\r\nnevents++;\r\nsize = ep->len_cap + PKT_SIZE;\r\nsize = (size + PKT_ALIGN-1) & ~(PKT_ALIGN-1);\r\nif ((cur_out += size) >= rp->b_size)\r\ncur_out -= rp->b_size;\r\nbytes += size;\r\n}\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn nevents;\r\n}\r\nstatic int mon_bin_queued(struct mon_reader_bin *rp)\r\n{\r\nunsigned int cur_out;\r\nunsigned int bytes, avail;\r\nunsigned int size;\r\nunsigned int nevents;\r\nstruct mon_bin_hdr *ep;\r\nunsigned long flags;\r\nmutex_lock(&rp->fetch_lock);\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\navail = rp->b_cnt;\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\ncur_out = rp->b_out;\r\nnevents = 0;\r\nbytes = 0;\r\nwhile (bytes < avail) {\r\nep = MON_OFF2HDR(rp, cur_out);\r\nnevents++;\r\nsize = ep->len_cap + PKT_SIZE;\r\nsize = (size + PKT_ALIGN-1) & ~(PKT_ALIGN-1);\r\nif ((cur_out += size) >= rp->b_size)\r\ncur_out -= rp->b_size;\r\nbytes += size;\r\n}\r\nmutex_unlock(&rp->fetch_lock);\r\nreturn nevents;\r\n}\r\nstatic long mon_bin_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct mon_reader_bin *rp = file->private_data;\r\nint ret = 0;\r\nstruct mon_bin_hdr *ep;\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase MON_IOCQ_URB_LEN:\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nif (!MON_RING_EMPTY(rp)) {\r\nep = MON_OFF2HDR(rp, rp->b_out);\r\nret = ep->len_cap;\r\n}\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nbreak;\r\ncase MON_IOCQ_RING_SIZE:\r\nret = rp->b_size;\r\nbreak;\r\ncase MON_IOCT_RING_SIZE:\r\n{\r\nint size;\r\nstruct mon_pgmap *vec;\r\nif (arg < BUFF_MIN || arg > BUFF_MAX)\r\nreturn -EINVAL;\r\nsize = CHUNK_ALIGN(arg);\r\nif ((vec = kzalloc(sizeof(struct mon_pgmap) * (size/CHUNK_SIZE),\r\nGFP_KERNEL)) == NULL) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = mon_alloc_buff(vec, size/CHUNK_SIZE);\r\nif (ret < 0) {\r\nkfree(vec);\r\nbreak;\r\n}\r\nmutex_lock(&rp->fetch_lock);\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nmon_free_buff(rp->b_vec, rp->b_size/CHUNK_SIZE);\r\nkfree(rp->b_vec);\r\nrp->b_vec = vec;\r\nrp->b_size = size;\r\nrp->b_read = rp->b_in = rp->b_out = rp->b_cnt = 0;\r\nrp->cnt_lost = 0;\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nmutex_unlock(&rp->fetch_lock);\r\n}\r\nbreak;\r\ncase MON_IOCH_MFLUSH:\r\nret = mon_bin_flush(rp, arg);\r\nbreak;\r\ncase MON_IOCX_GET:\r\ncase MON_IOCX_GETX:\r\n{\r\nstruct mon_bin_get getb;\r\nif (copy_from_user(&getb, (void __user *)arg,\r\nsizeof(struct mon_bin_get)))\r\nreturn -EFAULT;\r\nif (getb.alloc > 0x10000000)\r\nreturn -EINVAL;\r\nret = mon_bin_get_event(file, rp, getb.hdr,\r\n(cmd == MON_IOCX_GET)? PKT_SZ_API0: PKT_SZ_API1,\r\ngetb.data, (unsigned int)getb.alloc);\r\n}\r\nbreak;\r\ncase MON_IOCX_MFETCH:\r\n{\r\nstruct mon_bin_mfetch mfetch;\r\nstruct mon_bin_mfetch __user *uptr;\r\nuptr = (struct mon_bin_mfetch __user *)arg;\r\nif (copy_from_user(&mfetch, uptr, sizeof(mfetch)))\r\nreturn -EFAULT;\r\nif (mfetch.nflush) {\r\nret = mon_bin_flush(rp, mfetch.nflush);\r\nif (ret < 0)\r\nreturn ret;\r\nif (put_user(ret, &uptr->nflush))\r\nreturn -EFAULT;\r\n}\r\nret = mon_bin_fetch(file, rp, mfetch.offvec, mfetch.nfetch);\r\nif (ret < 0)\r\nreturn ret;\r\nif (put_user(ret, &uptr->nfetch))\r\nreturn -EFAULT;\r\nret = 0;\r\n}\r\nbreak;\r\ncase MON_IOCG_STATS: {\r\nstruct mon_bin_stats __user *sp;\r\nunsigned int nevents;\r\nunsigned int ndropped;\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nndropped = rp->cnt_lost;\r\nrp->cnt_lost = 0;\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nnevents = mon_bin_queued(rp);\r\nsp = (struct mon_bin_stats __user *)arg;\r\nif (put_user(rp->cnt_lost, &sp->dropped))\r\nreturn -EFAULT;\r\nif (put_user(nevents, &sp->queued))\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic long mon_bin_compat_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct mon_reader_bin *rp = file->private_data;\r\nint ret;\r\nswitch (cmd) {\r\ncase MON_IOCX_GET32:\r\ncase MON_IOCX_GETX32:\r\n{\r\nstruct mon_bin_get32 getb;\r\nif (copy_from_user(&getb, (void __user *)arg,\r\nsizeof(struct mon_bin_get32)))\r\nreturn -EFAULT;\r\nret = mon_bin_get_event(file, rp, compat_ptr(getb.hdr32),\r\n(cmd == MON_IOCX_GET32)? PKT_SZ_API0: PKT_SZ_API1,\r\ncompat_ptr(getb.data32), getb.alloc32);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\ncase MON_IOCX_MFETCH32:\r\n{\r\nstruct mon_bin_mfetch32 mfetch;\r\nstruct mon_bin_mfetch32 __user *uptr;\r\nuptr = (struct mon_bin_mfetch32 __user *) compat_ptr(arg);\r\nif (copy_from_user(&mfetch, uptr, sizeof(mfetch)))\r\nreturn -EFAULT;\r\nif (mfetch.nflush32) {\r\nret = mon_bin_flush(rp, mfetch.nflush32);\r\nif (ret < 0)\r\nreturn ret;\r\nif (put_user(ret, &uptr->nflush32))\r\nreturn -EFAULT;\r\n}\r\nret = mon_bin_fetch(file, rp, compat_ptr(mfetch.offvec32),\r\nmfetch.nfetch32);\r\nif (ret < 0)\r\nreturn ret;\r\nif (put_user(ret, &uptr->nfetch32))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\ncase MON_IOCG_STATS:\r\nreturn mon_bin_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\r\ncase MON_IOCQ_URB_LEN:\r\ncase MON_IOCQ_RING_SIZE:\r\ncase MON_IOCT_RING_SIZE:\r\ncase MON_IOCH_MFLUSH:\r\nreturn mon_bin_ioctl(file, cmd, arg);\r\ndefault:\r\n;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic unsigned int\r\nmon_bin_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct mon_reader_bin *rp = file->private_data;\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\nif (file->f_mode & FMODE_READ)\r\npoll_wait(file, &rp->b_wait, wait);\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nif (!MON_RING_EMPTY(rp))\r\nmask |= POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nreturn mask;\r\n}\r\nstatic void mon_bin_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct mon_reader_bin *rp = vma->vm_private_data;\r\nrp->mmap_active++;\r\n}\r\nstatic void mon_bin_vma_close(struct vm_area_struct *vma)\r\n{\r\nstruct mon_reader_bin *rp = vma->vm_private_data;\r\nrp->mmap_active--;\r\n}\r\nstatic int mon_bin_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct mon_reader_bin *rp = vma->vm_private_data;\r\nunsigned long offset, chunk_idx;\r\nstruct page *pageptr;\r\noffset = vmf->pgoff << PAGE_SHIFT;\r\nif (offset >= rp->b_size)\r\nreturn VM_FAULT_SIGBUS;\r\nchunk_idx = offset / CHUNK_SIZE;\r\npageptr = rp->b_vec[chunk_idx].pg;\r\nget_page(pageptr);\r\nvmf->page = pageptr;\r\nreturn 0;\r\n}\r\nstatic int mon_bin_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nvma->vm_ops = &mon_bin_vm_ops;\r\nvma->vm_flags |= VM_RESERVED;\r\nvma->vm_private_data = filp->private_data;\r\nmon_bin_vma_open(vma);\r\nreturn 0;\r\n}\r\nstatic int mon_bin_wait_event(struct file *file, struct mon_reader_bin *rp)\r\n{\r\nDECLARE_WAITQUEUE(waita, current);\r\nunsigned long flags;\r\nadd_wait_queue(&rp->b_wait, &waita);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\nwhile (MON_RING_EMPTY(rp)) {\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nif (file->f_flags & O_NONBLOCK) {\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&rp->b_wait, &waita);\r\nreturn -EWOULDBLOCK;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\nremove_wait_queue(&rp->b_wait, &waita);\r\nreturn -EINTR;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock_irqsave(&rp->b_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&rp->b_lock, flags);\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&rp->b_wait, &waita);\r\nreturn 0;\r\n}\r\nstatic int mon_alloc_buff(struct mon_pgmap *map, int npages)\r\n{\r\nint n;\r\nunsigned long vaddr;\r\nfor (n = 0; n < npages; n++) {\r\nvaddr = get_zeroed_page(GFP_KERNEL);\r\nif (vaddr == 0) {\r\nwhile (n-- != 0)\r\nfree_page((unsigned long) map[n].ptr);\r\nreturn -ENOMEM;\r\n}\r\nmap[n].ptr = (unsigned char *) vaddr;\r\nmap[n].pg = virt_to_page((void *) vaddr);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mon_free_buff(struct mon_pgmap *map, int npages)\r\n{\r\nint n;\r\nfor (n = 0; n < npages; n++)\r\nfree_page((unsigned long) map[n].ptr);\r\n}\r\nint mon_bin_add(struct mon_bus *mbus, const struct usb_bus *ubus)\r\n{\r\nstruct device *dev;\r\nunsigned minor = ubus? ubus->busnum: 0;\r\nif (minor >= MON_BIN_MAX_MINOR)\r\nreturn 0;\r\ndev = device_create(mon_bin_class, ubus ? ubus->controller : NULL,\r\nMKDEV(MAJOR(mon_bin_dev0), minor), NULL,\r\n"usbmon%d", minor);\r\nif (IS_ERR(dev))\r\nreturn 0;\r\nmbus->classdev = dev;\r\nreturn 1;\r\n}\r\nvoid mon_bin_del(struct mon_bus *mbus)\r\n{\r\ndevice_destroy(mon_bin_class, mbus->classdev->devt);\r\n}\r\nint __init mon_bin_init(void)\r\n{\r\nint rc;\r\nmon_bin_class = class_create(THIS_MODULE, "usbmon");\r\nif (IS_ERR(mon_bin_class)) {\r\nrc = PTR_ERR(mon_bin_class);\r\ngoto err_class;\r\n}\r\nrc = alloc_chrdev_region(&mon_bin_dev0, 0, MON_BIN_MAX_MINOR, "usbmon");\r\nif (rc < 0)\r\ngoto err_dev;\r\ncdev_init(&mon_bin_cdev, &mon_fops_binary);\r\nmon_bin_cdev.owner = THIS_MODULE;\r\nrc = cdev_add(&mon_bin_cdev, mon_bin_dev0, MON_BIN_MAX_MINOR);\r\nif (rc < 0)\r\ngoto err_add;\r\nreturn 0;\r\nerr_add:\r\nunregister_chrdev_region(mon_bin_dev0, MON_BIN_MAX_MINOR);\r\nerr_dev:\r\nclass_destroy(mon_bin_class);\r\nerr_class:\r\nreturn rc;\r\n}\r\nvoid mon_bin_exit(void)\r\n{\r\ncdev_del(&mon_bin_cdev);\r\nunregister_chrdev_region(mon_bin_dev0, MON_BIN_MAX_MINOR);\r\nclass_destroy(mon_bin_class);\r\n}
