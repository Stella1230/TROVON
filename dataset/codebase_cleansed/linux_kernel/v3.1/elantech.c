static int synaptics_send_cmd(struct psmouse *psmouse, unsigned char c,\r\nunsigned char *param)\r\n{\r\nif (psmouse_sliced_command(psmouse, c) ||\r\nps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\npr_err("synaptics_send_cmd query 0x%02x failed.\n", c);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elantech_ps2_command(struct psmouse *psmouse,\r\nunsigned char *param, int command)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nint rc;\r\nint tries = ETP_PS2_COMMAND_TRIES;\r\ndo {\r\nrc = ps2_command(ps2dev, param, command);\r\nif (rc == 0)\r\nbreak;\r\ntries--;\r\nelantech_debug("retrying ps2 command 0x%02x (%d).\n",\r\ncommand, tries);\r\nmsleep(ETP_PS2_COMMAND_DELAY);\r\n} while (tries > 0);\r\nif (rc)\r\npr_err("ps2 command 0x%02x failed.\n", command);\r\nreturn rc;\r\n}\r\nstatic int elantech_read_reg(struct psmouse *psmouse, unsigned char reg,\r\nunsigned char *val)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char param[3];\r\nint rc = 0;\r\nif (reg < 0x10 || reg > 0x26)\r\nreturn -1;\r\nif (reg > 0x11 && reg < 0x20)\r\nreturn -1;\r\nswitch (etd->hw_version) {\r\ncase 1:\r\nif (psmouse_sliced_command(psmouse, ETP_REGISTER_READ) ||\r\npsmouse_sliced_command(psmouse, reg) ||\r\nps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 2:\r\nif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_REGISTER_READ) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, reg) ||\r\nelantech_ps2_command(psmouse, param, PSMOUSE_CMD_GETINFO)) {\r\nrc = -1;\r\n}\r\nbreak;\r\n}\r\nif (rc)\r\npr_err("failed to read register 0x%02x.\n", reg);\r\nelse\r\n*val = param[0];\r\nreturn rc;\r\n}\r\nstatic int elantech_write_reg(struct psmouse *psmouse, unsigned char reg,\r\nunsigned char val)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nint rc = 0;\r\nif (reg < 0x10 || reg > 0x26)\r\nreturn -1;\r\nif (reg > 0x11 && reg < 0x20)\r\nreturn -1;\r\nswitch (etd->hw_version) {\r\ncase 1:\r\nif (psmouse_sliced_command(psmouse, ETP_REGISTER_WRITE) ||\r\npsmouse_sliced_command(psmouse, reg) ||\r\npsmouse_sliced_command(psmouse, val) ||\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 2:\r\nif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_REGISTER_WRITE) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, reg) ||\r\nelantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\r\nelantech_ps2_command(psmouse, NULL, val) ||\r\nelantech_ps2_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11)) {\r\nrc = -1;\r\n}\r\nbreak;\r\n}\r\nif (rc)\r\npr_err("failed to write register 0x%02x with value 0x%02x.\n",\r\nreg, val);\r\nreturn rc;\r\n}\r\nstatic void elantech_packet_dump(unsigned char *packet, int size)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG pr_fmt("PS/2 packet ["));\r\nfor (i = 0; i < size; i++)\r\nprintk("%s0x%02x ", (i) ? ", " : " ", packet[i]);\r\nprintk("]\n");\r\n}\r\nstatic void elantech_report_absolute_v1(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nint fingers;\r\nif (etd->fw_version < 0x020000) {\r\nfingers = ((packet[1] & 0x80) >> 7) +\r\n((packet[1] & 0x30) >> 4);\r\n} else {\r\nfingers = (packet[0] & 0xc0) >> 6;\r\n}\r\nif (etd->jumpy_cursor) {\r\nif (fingers != 1) {\r\netd->single_finger_reports = 0;\r\n} else if (etd->single_finger_reports < 2) {\r\netd->single_finger_reports++;\r\nelantech_debug("discarding packet\n");\r\nreturn;\r\n}\r\n}\r\ninput_report_key(dev, BTN_TOUCH, fingers != 0);\r\nif (fingers) {\r\ninput_report_abs(dev, ABS_X,\r\n((packet[1] & 0x0c) << 6) | packet[2]);\r\ninput_report_abs(dev, ABS_Y,\r\nETP_YMAX_V1 - (((packet[1] & 0x03) << 8) | packet[3]));\r\n}\r\ninput_report_key(dev, BTN_TOOL_FINGER, fingers == 1);\r\ninput_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);\r\ninput_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x01);\r\ninput_report_key(dev, BTN_RIGHT, packet[0] & 0x02);\r\nif (etd->fw_version < 0x020000 &&\r\n(etd->capabilities & ETP_CAP_HAS_ROCKER)) {\r\ninput_report_key(dev, BTN_FORWARD, packet[0] & 0x40);\r\ninput_report_key(dev, BTN_BACK, packet[0] & 0x80);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void elantech_set_slot(struct input_dev *dev, int slot, bool active,\r\nunsigned int x, unsigned int y)\r\n{\r\ninput_mt_slot(dev, slot);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\r\nif (active) {\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\nstatic void elantech_report_semi_mt_data(struct input_dev *dev,\r\nunsigned int num_fingers,\r\nunsigned int x1, unsigned int y1,\r\nunsigned int x2, unsigned int y2)\r\n{\r\nelantech_set_slot(dev, 0, num_fingers != 0, x1, y1);\r\nelantech_set_slot(dev, 1, num_fingers == 2, x2, y2);\r\n}\r\nstatic void elantech_report_absolute_v2(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nstruct input_dev *dev = psmouse->dev;\r\nunsigned char *packet = psmouse->packet;\r\nunsigned int fingers, x1 = 0, y1 = 0, x2 = 0, y2 = 0, width = 0, pres = 0;\r\nfingers = (packet[0] & 0xc0) >> 6;\r\ninput_report_key(dev, BTN_TOUCH, fingers != 0);\r\nswitch (fingers) {\r\ncase 3:\r\nif (packet[3] & 0x80)\r\nfingers = 4;\r\ncase 1:\r\nx1 = ((packet[1] & 0x07) << 8) | packet[2];\r\ny1 = ETP_YMAX_V2 - (((packet[4] & 0x03) << 8) | packet[5]);\r\ninput_report_abs(dev, ABS_X, x1);\r\ninput_report_abs(dev, ABS_Y, y1);\r\npres = (packet[1] & 0xf0) | ((packet[4] & 0xf0) >> 4);\r\nwidth = ((packet[0] & 0x30) >> 2) | ((packet[3] & 0x30) >> 4);\r\nbreak;\r\ncase 2:\r\nx1 = ((packet[0] & 0x10) << 4) | packet[1];\r\ny1 = ETP_2FT_YMAX - (((packet[0] & 0x20) << 3) | packet[2]);\r\nx2 = ((packet[3] & 0x10) << 4) | packet[4];\r\ny2 = ETP_2FT_YMAX - (((packet[3] & 0x20) << 3) | packet[5]);\r\ninput_report_abs(dev, ABS_X, x1 << 2);\r\ninput_report_abs(dev, ABS_Y, y1 << 2);\r\npres = 127;\r\nwidth = 7;\r\nbreak;\r\n}\r\nelantech_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\r\ninput_report_key(dev, BTN_TOOL_FINGER, fingers == 1);\r\ninput_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);\r\ninput_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);\r\ninput_report_key(dev, BTN_TOOL_QUADTAP, fingers == 4);\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 0x01);\r\ninput_report_key(dev, BTN_RIGHT, packet[0] & 0x02);\r\nif (etd->reports_pressure) {\r\ninput_report_abs(dev, ABS_PRESSURE, pres);\r\ninput_report_abs(dev, ABS_TOOL_WIDTH, width);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic int elantech_check_parity_v1(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nunsigned char p1, p2, p3;\r\nif (etd->fw_version < 0x020000) {\r\np1 = (packet[0] & 0x20) >> 5;\r\np2 = (packet[0] & 0x10) >> 4;\r\n} else {\r\np1 = (packet[0] & 0x10) >> 4;\r\np2 = (packet[0] & 0x20) >> 5;\r\n}\r\np3 = (packet[0] & 0x04) >> 2;\r\nreturn etd->parity[packet[1]] == p1 &&\r\netd->parity[packet[2]] == p2 &&\r\netd->parity[packet[3]] == p3;\r\n}\r\nstatic psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nif (psmouse->pktcnt < psmouse->pktsize)\r\nreturn PSMOUSE_GOOD_DATA;\r\nif (etd->debug > 1)\r\nelantech_packet_dump(psmouse->packet, psmouse->pktsize);\r\nswitch (etd->hw_version) {\r\ncase 1:\r\nif (etd->paritycheck && !elantech_check_parity_v1(psmouse))\r\nreturn PSMOUSE_BAD_DATA;\r\nelantech_report_absolute_v1(psmouse);\r\nbreak;\r\ncase 2:\r\nelantech_report_absolute_v2(psmouse);\r\nbreak;\r\n}\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nstatic int elantech_set_absolute_mode(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nunsigned char val;\r\nint tries = ETP_READ_BACK_TRIES;\r\nint rc = 0;\r\nswitch (etd->hw_version) {\r\ncase 1:\r\netd->reg_10 = 0x16;\r\netd->reg_11 = 0x8f;\r\nif (elantech_write_reg(psmouse, 0x10, etd->reg_10) ||\r\nelantech_write_reg(psmouse, 0x11, etd->reg_11)) {\r\nrc = -1;\r\n}\r\nbreak;\r\ncase 2:\r\netd->reg_10 = 0x54;\r\netd->reg_11 = 0x88;\r\netd->reg_21 = 0x60;\r\nif (elantech_write_reg(psmouse, 0x10, etd->reg_10) ||\r\nelantech_write_reg(psmouse, 0x11, etd->reg_11) ||\r\nelantech_write_reg(psmouse, 0x21, etd->reg_21)) {\r\nrc = -1;\r\nbreak;\r\n}\r\n}\r\nif (rc == 0) {\r\ndo {\r\nrc = elantech_read_reg(psmouse, 0x10, &val);\r\nif (rc == 0)\r\nbreak;\r\ntries--;\r\nelantech_debug("retrying read (%d).\n", tries);\r\nmsleep(ETP_READ_BACK_DELAY);\r\n} while (tries > 0);\r\nif (rc) {\r\npr_err("failed to read back register 0x10.\n");\r\n} else if (etd->hw_version == 1 &&\r\n!(val & ETP_R10_ABSOLUTE_MODE)) {\r\npr_err("touchpad refuses to switch to absolute mode.\n");\r\nrc = -1;\r\n}\r\n}\r\nif (rc)\r\npr_err("failed to initialise registers.\n");\r\nreturn rc;\r\n}\r\nstatic void elantech_set_input_params(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct elantech_data *etd = psmouse->private;\r\n__set_bit(EV_KEY, dev->evbit);\r\n__set_bit(EV_ABS, dev->evbit);\r\n__clear_bit(EV_REL, dev->evbit);\r\n__set_bit(BTN_LEFT, dev->keybit);\r\n__set_bit(BTN_RIGHT, dev->keybit);\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(BTN_TOOL_FINGER, dev->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\r\n__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);\r\nswitch (etd->hw_version) {\r\ncase 1:\r\nif (etd->fw_version < 0x020000 &&\r\n(etd->capabilities & ETP_CAP_HAS_ROCKER)) {\r\n__set_bit(BTN_FORWARD, dev->keybit);\r\n__set_bit(BTN_BACK, dev->keybit);\r\n}\r\ninput_set_abs_params(dev, ABS_X, ETP_XMIN_V1, ETP_XMAX_V1, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, ETP_YMIN_V1, ETP_YMAX_V1, 0, 0);\r\nbreak;\r\ncase 2:\r\n__set_bit(BTN_TOOL_QUADTAP, dev->keybit);\r\ninput_set_abs_params(dev, ABS_X, ETP_XMIN_V2, ETP_XMAX_V2, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, ETP_YMIN_V2, ETP_YMAX_V2, 0, 0);\r\nif (etd->reports_pressure) {\r\ninput_set_abs_params(dev, ABS_PRESSURE, ETP_PMIN_V2,\r\nETP_PMAX_V2, 0, 0);\r\ninput_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2,\r\nETP_WMAX_V2, 0, 0);\r\n}\r\n__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);\r\ninput_mt_init_slots(dev, 2);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_X, ETP_XMIN_V2, ETP_XMAX_V2, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_Y, ETP_YMIN_V2, ETP_YMAX_V2, 0, 0);\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t elantech_show_int_attr(struct psmouse *psmouse, void *data,\r\nchar *buf)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nstruct elantech_attr_data *attr = data;\r\nunsigned char *reg = (unsigned char *) etd + attr->field_offset;\r\nint rc = 0;\r\nif (attr->reg)\r\nrc = elantech_read_reg(psmouse, attr->reg, reg);\r\nreturn sprintf(buf, "0x%02x\n", (attr->reg && rc) ? -1 : *reg);\r\n}\r\nstatic ssize_t elantech_set_int_attr(struct psmouse *psmouse,\r\nvoid *data, const char *buf, size_t count)\r\n{\r\nstruct elantech_data *etd = psmouse->private;\r\nstruct elantech_attr_data *attr = data;\r\nunsigned char *reg = (unsigned char *) etd + attr->field_offset;\r\nunsigned long value;\r\nint err;\r\nerr = strict_strtoul(buf, 16, &value);\r\nif (err)\r\nreturn err;\r\nif (value > 0xff)\r\nreturn -EINVAL;\r\nif (etd->hw_version == 1) {\r\nif (attr->reg == 0x10)\r\nvalue |= ETP_R10_ABSOLUTE_MODE;\r\nelse if (attr->reg == 0x11)\r\nvalue |= ETP_R11_4_BYTE_MODE;\r\n}\r\nif (!attr->reg || elantech_write_reg(psmouse, attr->reg, value) == 0)\r\n*reg = value;\r\nreturn count;\r\n}\r\nstatic bool elantech_is_signature_valid(const unsigned char *param)\r\n{\r\nstatic const unsigned char rates[] = { 200, 100, 80, 60, 40, 20, 10 };\r\nint i;\r\nif (param[0] == 0)\r\nreturn false;\r\nif (param[1] == 0)\r\nreturn true;\r\nfor (i = 0; i < ARRAY_SIZE(rates); i++)\r\nif (param[2] == rates[i])\r\nreturn false;\r\nreturn true;\r\n}\r\nint elantech_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[3];\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\npr_debug("sending Elantech magic knock failed.\n");\r\nreturn -1;\r\n}\r\nif (param[0] != 0x3c || param[1] != 0x03 || param[2] != 0xc8) {\r\npr_debug("unexpected magic knock result 0x%02x, 0x%02x, 0x%02x.\n",\r\nparam[0], param[1], param[2]);\r\nreturn -1;\r\n}\r\nif (synaptics_send_cmd(psmouse, ETP_FW_VERSION_QUERY, param)) {\r\npr_debug("failed to query firmware version.\n");\r\nreturn -1;\r\n}\r\npr_debug("Elantech version query result 0x%02x, 0x%02x, 0x%02x.\n",\r\nparam[0], param[1], param[2]);\r\nif (!elantech_is_signature_valid(param)) {\r\nif (!force_elantech) {\r\npr_debug("Probably not a real Elantech touchpad. Aborting.\n");\r\nreturn -1;\r\n}\r\npr_debug("Probably not a real Elantech touchpad. Enabling anyway due to force_elantech.\n");\r\n}\r\nif (set_properties) {\r\npsmouse->vendor = "Elantech";\r\npsmouse->name = "Touchpad";\r\n}\r\nreturn 0;\r\n}\r\nstatic void elantech_disconnect(struct psmouse *psmouse)\r\n{\r\nsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj,\r\n&elantech_attr_group);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\n}\r\nstatic int elantech_reconnect(struct psmouse *psmouse)\r\n{\r\nif (elantech_detect(psmouse, 0))\r\nreturn -1;\r\nif (elantech_set_absolute_mode(psmouse)) {\r\npr_err("failed to put touchpad back into absolute mode.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint elantech_init(struct psmouse *psmouse)\r\n{\r\nstruct elantech_data *etd;\r\nint i, error;\r\nunsigned char param[3];\r\npsmouse->private = etd = kzalloc(sizeof(struct elantech_data), GFP_KERNEL);\r\nif (!etd)\r\nreturn -ENOMEM;\r\netd->parity[0] = 1;\r\nfor (i = 1; i < 256; i++)\r\netd->parity[i] = etd->parity[i & (i - 1)] ^ 1;\r\nif (synaptics_send_cmd(psmouse, ETP_FW_VERSION_QUERY, param)) {\r\npr_err("failed to query firmware version.\n");\r\ngoto init_fail;\r\n}\r\netd->fw_version = (param[0] << 16) | (param[1] << 8) | param[2];\r\nif (etd->fw_version >= 0x020030) {\r\netd->hw_version = 2;\r\netd->debug = 1;\r\netd->paritycheck = 0;\r\nif (etd->fw_version >= 0x020800)\r\netd->reports_pressure = true;\r\n} else {\r\netd->hw_version = 1;\r\netd->paritycheck = 1;\r\n}\r\npr_info("assuming hardware version %d, firmware version %d.%d.%d\n",\r\netd->hw_version, param[0], param[1], param[2]);\r\nif (synaptics_send_cmd(psmouse, ETP_CAPABILITIES_QUERY, param)) {\r\npr_err("failed to query capabilities.\n");\r\ngoto init_fail;\r\n}\r\npr_info("Synaptics capabilities query result 0x%02x, 0x%02x, 0x%02x.\n",\r\nparam[0], param[1], param[2]);\r\netd->capabilities = param[0];\r\nif (etd->fw_version == 0x020022 || etd->fw_version == 0x020600) {\r\npr_info("firmware version 2.0.34/2.6.0 detected, enabling jumpy cursor workaround\n");\r\netd->jumpy_cursor = true;\r\n}\r\nif (elantech_set_absolute_mode(psmouse)) {\r\npr_err("failed to put touchpad into absolute mode.\n");\r\ngoto init_fail;\r\n}\r\nelantech_set_input_params(psmouse);\r\nerror = sysfs_create_group(&psmouse->ps2dev.serio->dev.kobj,\r\n&elantech_attr_group);\r\nif (error) {\r\npr_err("failed to create sysfs attributes, error: %d.\n", error);\r\ngoto init_fail;\r\n}\r\npsmouse->protocol_handler = elantech_process_byte;\r\npsmouse->disconnect = elantech_disconnect;\r\npsmouse->reconnect = elantech_reconnect;\r\npsmouse->pktsize = etd->hw_version == 2 ? 6 : 4;\r\nreturn 0;\r\ninit_fail:\r\nkfree(etd);\r\nreturn -1;\r\n}
