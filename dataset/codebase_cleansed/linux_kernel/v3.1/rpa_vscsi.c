static irqreturn_t rpavscsi_handle_event(int irq, void *dev_instance)\r\n{\r\nstruct ibmvscsi_host_data *hostdata =\r\n(struct ibmvscsi_host_data *)dev_instance;\r\nvio_disable_interrupts(to_vio_dev(hostdata->dev));\r\ntasklet_schedule(&hostdata->srp_task);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rpavscsi_release_crq_queue(struct crq_queue *queue,\r\nstruct ibmvscsi_host_data *hostdata,\r\nint max_requests)\r\n{\r\nlong rc = 0;\r\nstruct vio_dev *vdev = to_vio_dev(hostdata->dev);\r\nfree_irq(vdev->irq, (void *)hostdata);\r\ntasklet_kill(&hostdata->srp_task);\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\r\n} while ((rc == H_BUSY) || (H_IS_LONG_BUSY(rc)));\r\ndma_unmap_single(hostdata->dev,\r\nqueue->msg_token,\r\nqueue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);\r\nfree_page((unsigned long)queue->msgs);\r\n}\r\nstatic struct viosrp_crq *crq_queue_next_crq(struct crq_queue *queue)\r\n{\r\nstruct viosrp_crq *crq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->lock, flags);\r\ncrq = &queue->msgs[queue->cur];\r\nif (crq->valid & 0x80) {\r\nif (++queue->cur == queue->size)\r\nqueue->cur = 0;\r\n} else\r\ncrq = NULL;\r\nspin_unlock_irqrestore(&queue->lock, flags);\r\nreturn crq;\r\n}\r\nstatic int rpavscsi_send_crq(struct ibmvscsi_host_data *hostdata,\r\nu64 word1, u64 word2)\r\n{\r\nstruct vio_dev *vdev = to_vio_dev(hostdata->dev);\r\nreturn plpar_hcall_norets(H_SEND_CRQ, vdev->unit_address, word1, word2);\r\n}\r\nstatic void rpavscsi_task(void *data)\r\n{\r\nstruct ibmvscsi_host_data *hostdata = (struct ibmvscsi_host_data *)data;\r\nstruct vio_dev *vdev = to_vio_dev(hostdata->dev);\r\nstruct viosrp_crq *crq;\r\nint done = 0;\r\nwhile (!done) {\r\nwhile ((crq = crq_queue_next_crq(&hostdata->queue)) != NULL) {\r\nibmvscsi_handle_crq(crq, hostdata);\r\ncrq->valid = 0x00;\r\n}\r\nvio_enable_interrupts(vdev);\r\nif ((crq = crq_queue_next_crq(&hostdata->queue)) != NULL) {\r\nvio_disable_interrupts(vdev);\r\nibmvscsi_handle_crq(crq, hostdata);\r\ncrq->valid = 0x00;\r\n} else {\r\ndone = 1;\r\n}\r\n}\r\n}\r\nstatic void gather_partition_info(void)\r\n{\r\nstruct device_node *rootdn;\r\nconst char *ppartition_name;\r\nconst unsigned int *p_number_ptr;\r\nrootdn = of_find_node_by_path("/");\r\nif (!rootdn) {\r\nreturn;\r\n}\r\nppartition_name = of_get_property(rootdn, "ibm,partition-name", NULL);\r\nif (ppartition_name)\r\nstrncpy(partition_name, ppartition_name,\r\nsizeof(partition_name));\r\np_number_ptr = of_get_property(rootdn, "ibm,partition-no", NULL);\r\nif (p_number_ptr)\r\npartition_number = *p_number_ptr;\r\nof_node_put(rootdn);\r\n}\r\nstatic void set_adapter_info(struct ibmvscsi_host_data *hostdata)\r\n{\r\nmemset(&hostdata->madapter_info, 0x00,\r\nsizeof(hostdata->madapter_info));\r\ndev_info(hostdata->dev, "SRP_VERSION: %s\n", SRP_VERSION);\r\nstrcpy(hostdata->madapter_info.srp_version, SRP_VERSION);\r\nstrncpy(hostdata->madapter_info.partition_name, partition_name,\r\nsizeof(hostdata->madapter_info.partition_name));\r\nhostdata->madapter_info.partition_number = partition_number;\r\nhostdata->madapter_info.mad_version = 1;\r\nhostdata->madapter_info.os_type = 2;\r\n}\r\nstatic int rpavscsi_reset_crq_queue(struct crq_queue *queue,\r\nstruct ibmvscsi_host_data *hostdata)\r\n{\r\nint rc = 0;\r\nstruct vio_dev *vdev = to_vio_dev(hostdata->dev);\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\r\n} while ((rc == H_BUSY) || (H_IS_LONG_BUSY(rc)));\r\nmemset(queue->msgs, 0x00, PAGE_SIZE);\r\nqueue->cur = 0;\r\nset_adapter_info(hostdata);\r\nrc = plpar_hcall_norets(H_REG_CRQ,\r\nvdev->unit_address,\r\nqueue->msg_token, PAGE_SIZE);\r\nif (rc == 2) {\r\ndev_warn(hostdata->dev, "Partner adapter not ready\n");\r\n} else if (rc != 0) {\r\ndev_warn(hostdata->dev, "couldn't register crq--rc 0x%x\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int rpavscsi_init_crq_queue(struct crq_queue *queue,\r\nstruct ibmvscsi_host_data *hostdata,\r\nint max_requests)\r\n{\r\nint rc;\r\nint retrc;\r\nstruct vio_dev *vdev = to_vio_dev(hostdata->dev);\r\nqueue->msgs = (struct viosrp_crq *)get_zeroed_page(GFP_KERNEL);\r\nif (!queue->msgs)\r\ngoto malloc_failed;\r\nqueue->size = PAGE_SIZE / sizeof(*queue->msgs);\r\nqueue->msg_token = dma_map_single(hostdata->dev, queue->msgs,\r\nqueue->size * sizeof(*queue->msgs),\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(hostdata->dev, queue->msg_token))\r\ngoto map_failed;\r\ngather_partition_info();\r\nset_adapter_info(hostdata);\r\nretrc = rc = plpar_hcall_norets(H_REG_CRQ,\r\nvdev->unit_address,\r\nqueue->msg_token, PAGE_SIZE);\r\nif (rc == H_RESOURCE)\r\nrc = rpavscsi_reset_crq_queue(queue,\r\nhostdata);\r\nif (rc == 2) {\r\ndev_warn(hostdata->dev, "Partner adapter not ready\n");\r\nretrc = 0;\r\n} else if (rc != 0) {\r\ndev_warn(hostdata->dev, "Error %d opening adapter\n", rc);\r\ngoto reg_crq_failed;\r\n}\r\nqueue->cur = 0;\r\nspin_lock_init(&queue->lock);\r\ntasklet_init(&hostdata->srp_task, (void *)rpavscsi_task,\r\n(unsigned long)hostdata);\r\nif (request_irq(vdev->irq,\r\nrpavscsi_handle_event,\r\n0, "ibmvscsi", (void *)hostdata) != 0) {\r\ndev_err(hostdata->dev, "couldn't register irq 0x%x\n",\r\nvdev->irq);\r\ngoto req_irq_failed;\r\n}\r\nrc = vio_enable_interrupts(vdev);\r\nif (rc != 0) {\r\ndev_err(hostdata->dev, "Error %d enabling interrupts!!!\n", rc);\r\ngoto req_irq_failed;\r\n}\r\nreturn retrc;\r\nreq_irq_failed:\r\ntasklet_kill(&hostdata->srp_task);\r\nrc = 0;\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\r\n} while ((rc == H_BUSY) || (H_IS_LONG_BUSY(rc)));\r\nreg_crq_failed:\r\ndma_unmap_single(hostdata->dev,\r\nqueue->msg_token,\r\nqueue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);\r\nmap_failed:\r\nfree_page((unsigned long)queue->msgs);\r\nmalloc_failed:\r\nreturn -1;\r\n}\r\nstatic int rpavscsi_reenable_crq_queue(struct crq_queue *queue,\r\nstruct ibmvscsi_host_data *hostdata)\r\n{\r\nint rc = 0;\r\nstruct vio_dev *vdev = to_vio_dev(hostdata->dev);\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_ENABLE_CRQ, vdev->unit_address);\r\n} while ((rc == H_IN_PROGRESS) || (rc == H_BUSY) || (H_IS_LONG_BUSY(rc)));\r\nif (rc)\r\ndev_err(hostdata->dev, "Error %d enabling adapter\n", rc);\r\nreturn rc;\r\n}\r\nstatic int rpavscsi_resume(struct ibmvscsi_host_data *hostdata)\r\n{\r\nvio_disable_interrupts(to_vio_dev(hostdata->dev));\r\ntasklet_schedule(&hostdata->srp_task);\r\nreturn 0;\r\n}
