static const char *ccid3_tx_state_name(enum ccid3_hc_tx_states state)\r\n{\r\nstatic const char *const ccid3_state_names[] = {\r\n[TFRC_SSTATE_NO_SENT] = "NO_SENT",\r\n[TFRC_SSTATE_NO_FBACK] = "NO_FBACK",\r\n[TFRC_SSTATE_FBACK] = "FBACK",\r\n};\r\nreturn ccid3_state_names[state];\r\n}\r\nstatic void ccid3_hc_tx_set_state(struct sock *sk,\r\nenum ccid3_hc_tx_states state)\r\n{\r\nstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\nenum ccid3_hc_tx_states oldstate = hc->tx_state;\r\nccid3_pr_debug("%s(%p) %-8.8s -> %s\n",\r\ndccp_role(sk), sk, ccid3_tx_state_name(oldstate),\r\nccid3_tx_state_name(state));\r\nWARN_ON(state == oldstate);\r\nhc->tx_state = state;\r\n}\r\nstatic inline u64 rfc3390_initial_rate(struct sock *sk)\r\n{\r\nconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\nconst __u32 w_init = clamp_t(__u32, 4380U, 2 * hc->tx_s, 4 * hc->tx_s);\r\nreturn scaled_div(w_init << 6, hc->tx_rtt);\r\n}\r\nstatic void ccid3_update_send_interval(struct ccid3_hc_tx_sock *hc)\r\n{\r\nhc->tx_t_ipi = scaled_div32(((u64)hc->tx_s) << 6, hc->tx_x);\r\nccid3_pr_debug("t_ipi=%u, s=%u, X=%u\n", hc->tx_t_ipi,\r\nhc->tx_s, (unsigned)(hc->tx_x >> 6));\r\n}\r\nstatic u32 ccid3_hc_tx_idle_rtt(struct ccid3_hc_tx_sock *hc, ktime_t now)\r\n{\r\nu32 delta = ktime_us_delta(now, hc->tx_t_last_win_count);\r\nreturn delta / hc->tx_rtt;\r\n}\r\nstatic void ccid3_hc_tx_update_x(struct sock *sk, ktime_t *stamp)\r\n{\r\nstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\n__u64 min_rate = 2 * hc->tx_x_recv;\r\nconst __u64 old_x = hc->tx_x;\r\nktime_t now = stamp ? *stamp : ktime_get_real();\r\nif (ccid3_hc_tx_idle_rtt(hc, now) >= 2) {\r\nmin_rate = rfc3390_initial_rate(sk);\r\nmin_rate = max(min_rate, 2 * hc->tx_x_recv);\r\n}\r\nif (hc->tx_p > 0) {\r\nhc->tx_x = min(((__u64)hc->tx_x_calc) << 6, min_rate);\r\nhc->tx_x = max(hc->tx_x, (((__u64)hc->tx_s) << 6) / TFRC_T_MBI);\r\n} else if (ktime_us_delta(now, hc->tx_t_ld) - (s64)hc->tx_rtt >= 0) {\r\nhc->tx_x = min(2 * hc->tx_x, min_rate);\r\nhc->tx_x = max(hc->tx_x,\r\nscaled_div(((__u64)hc->tx_s) << 6, hc->tx_rtt));\r\nhc->tx_t_ld = now;\r\n}\r\nif (hc->tx_x != old_x) {\r\nccid3_pr_debug("X_prev=%u, X_now=%u, X_calc=%u, "\r\n"X_recv=%u\n", (unsigned)(old_x >> 6),\r\n(unsigned)(hc->tx_x >> 6), hc->tx_x_calc,\r\n(unsigned)(hc->tx_x_recv >> 6));\r\nccid3_update_send_interval(hc);\r\n}\r\n}\r\nstatic inline void ccid3_hc_tx_update_s(struct ccid3_hc_tx_sock *hc, int len)\r\n{\r\nconst u16 old_s = hc->tx_s;\r\nhc->tx_s = tfrc_ewma(hc->tx_s, len, 9);\r\nif (hc->tx_s != old_s)\r\nccid3_update_send_interval(hc);\r\n}\r\nstatic inline void ccid3_hc_tx_update_win_count(struct ccid3_hc_tx_sock *hc,\r\nktime_t now)\r\n{\r\nu32 delta = ktime_us_delta(now, hc->tx_t_last_win_count),\r\nquarter_rtts = (4 * delta) / hc->tx_rtt;\r\nif (quarter_rtts > 0) {\r\nhc->tx_t_last_win_count = now;\r\nhc->tx_last_win_count += min(quarter_rtts, 5U);\r\nhc->tx_last_win_count &= 0xF;\r\n}\r\n}\r\nstatic void ccid3_hc_tx_no_feedback_timer(unsigned long data)\r\n{\r\nstruct sock *sk = (struct sock *)data;\r\nstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\nunsigned long t_nfb = USEC_PER_SEC / 5;\r\nbh_lock_sock(sk);\r\nif (sock_owned_by_user(sk)) {\r\ngoto restart_timer;\r\n}\r\nccid3_pr_debug("%s(%p, state=%s) - entry\n", dccp_role(sk), sk,\r\nccid3_tx_state_name(hc->tx_state));\r\nif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\r\ngoto out;\r\nif (hc->tx_state == TFRC_SSTATE_FBACK)\r\nccid3_hc_tx_set_state(sk, TFRC_SSTATE_NO_FBACK);\r\nif (hc->tx_t_rto == 0 || hc->tx_p == 0) {\r\nhc->tx_x = max(hc->tx_x / 2,\r\n(((__u64)hc->tx_s) << 6) / TFRC_T_MBI);\r\nccid3_update_send_interval(hc);\r\n} else {\r\nBUG_ON(hc->tx_p && !hc->tx_x_calc);\r\nif (hc->tx_x_calc > (hc->tx_x_recv >> 5))\r\nhc->tx_x_recv =\r\nmax(hc->tx_x_recv / 2,\r\n(((__u64)hc->tx_s) << 6) / (2*TFRC_T_MBI));\r\nelse {\r\nhc->tx_x_recv = hc->tx_x_calc;\r\nhc->tx_x_recv <<= 4;\r\n}\r\nccid3_hc_tx_update_x(sk, NULL);\r\n}\r\nccid3_pr_debug("Reduced X to %llu/64 bytes/sec\n",\r\n(unsigned long long)hc->tx_x);\r\nif (unlikely(hc->tx_t_rto == 0))\r\nt_nfb = TFRC_INITIAL_TIMEOUT;\r\nelse\r\nt_nfb = max(hc->tx_t_rto, 2 * hc->tx_t_ipi);\r\nrestart_timer:\r\nsk_reset_timer(sk, &hc->tx_no_feedback_timer,\r\njiffies + usecs_to_jiffies(t_nfb));\r\nout:\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\n}\r\nstatic int ccid3_hc_tx_send_packet(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\nktime_t now = ktime_get_real();\r\ns64 delay;\r\nif (unlikely(skb->len == 0))\r\nreturn -EBADMSG;\r\nif (hc->tx_state == TFRC_SSTATE_NO_SENT) {\r\nsk_reset_timer(sk, &hc->tx_no_feedback_timer, (jiffies +\r\nusecs_to_jiffies(TFRC_INITIAL_TIMEOUT)));\r\nhc->tx_last_win_count = 0;\r\nhc->tx_t_last_win_count = now;\r\nhc->tx_t_nom = now;\r\nhc->tx_s = skb->len;\r\nif (dp->dccps_syn_rtt) {\r\nccid3_pr_debug("SYN RTT = %uus\n", dp->dccps_syn_rtt);\r\nhc->tx_rtt = dp->dccps_syn_rtt;\r\nhc->tx_x = rfc3390_initial_rate(sk);\r\nhc->tx_t_ld = now;\r\n} else {\r\nhc->tx_rtt = DCCP_FALLBACK_RTT;\r\nhc->tx_x = hc->tx_s;\r\nhc->tx_x <<= 6;\r\n}\r\nccid3_update_send_interval(hc);\r\nccid3_hc_tx_set_state(sk, TFRC_SSTATE_NO_FBACK);\r\n} else {\r\ndelay = ktime_us_delta(hc->tx_t_nom, now);\r\nccid3_pr_debug("delay=%ld\n", (long)delay);\r\nif (delay >= TFRC_T_DELTA)\r\nreturn (u32)delay / USEC_PER_MSEC;\r\nccid3_hc_tx_update_win_count(hc, now);\r\n}\r\ndp->dccps_hc_tx_insert_options = 1;\r\nDCCP_SKB_CB(skb)->dccpd_ccval = hc->tx_last_win_count;\r\nhc->tx_t_nom = ktime_add_us(hc->tx_t_nom, hc->tx_t_ipi);\r\nreturn CCID_PACKET_SEND_AT_ONCE;\r\n}\r\nstatic void ccid3_hc_tx_packet_sent(struct sock *sk, unsigned int len)\r\n{\r\nstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\nccid3_hc_tx_update_s(hc, len);\r\nif (tfrc_tx_hist_add(&hc->tx_hist, dccp_sk(sk)->dccps_gss))\r\nDCCP_CRIT("packet history - out of memory!");\r\n}\r\nstatic void ccid3_hc_tx_packet_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\nstruct tfrc_tx_hist_entry *acked;\r\nktime_t now;\r\nunsigned long t_nfb;\r\nu32 r_sample;\r\nif (!(DCCP_SKB_CB(skb)->dccpd_type == DCCP_PKT_ACK ||\r\nDCCP_SKB_CB(skb)->dccpd_type == DCCP_PKT_DATAACK))\r\nreturn;\r\nacked = tfrc_tx_hist_find_entry(hc->tx_hist, dccp_hdr_ack_seq(skb));\r\nif (acked == NULL)\r\nreturn;\r\ntfrc_tx_hist_purge(&acked->next);\r\nnow = ktime_get_real();\r\nr_sample = dccp_sample_rtt(sk, ktime_us_delta(now, acked->stamp));\r\nhc->tx_rtt = tfrc_ewma(hc->tx_rtt, r_sample, 9);\r\nif (hc->tx_state == TFRC_SSTATE_NO_FBACK) {\r\nccid3_hc_tx_set_state(sk, TFRC_SSTATE_FBACK);\r\nif (hc->tx_t_rto == 0) {\r\nhc->tx_x = rfc3390_initial_rate(sk);\r\nhc->tx_t_ld = now;\r\nccid3_update_send_interval(hc);\r\ngoto done_computing_x;\r\n} else if (hc->tx_p == 0) {\r\ngoto done_computing_x;\r\n}\r\n}\r\nif (hc->tx_p > 0)\r\nhc->tx_x_calc = tfrc_calc_x(hc->tx_s, hc->tx_rtt, hc->tx_p);\r\nccid3_hc_tx_update_x(sk, &now);\r\ndone_computing_x:\r\nccid3_pr_debug("%s(%p), RTT=%uus (sample=%uus), s=%u, "\r\n"p=%u, X_calc=%u, X_recv=%u, X=%u\n",\r\ndccp_role(sk), sk, hc->tx_rtt, r_sample,\r\nhc->tx_s, hc->tx_p, hc->tx_x_calc,\r\n(unsigned)(hc->tx_x_recv >> 6),\r\n(unsigned)(hc->tx_x >> 6));\r\nsk_stop_timer(sk, &hc->tx_no_feedback_timer);\r\nsk->sk_write_space(sk);\r\nhc->tx_t_rto = max_t(u32, 4 * hc->tx_rtt,\r\nUSEC_PER_SEC/HZ * tcp_rto_min(sk));\r\nt_nfb = max(hc->tx_t_rto, 2 * hc->tx_t_ipi);\r\nccid3_pr_debug("%s(%p), Scheduled no feedback timer to "\r\n"expire in %lu jiffies (%luus)\n",\r\ndccp_role(sk), sk, usecs_to_jiffies(t_nfb), t_nfb);\r\nsk_reset_timer(sk, &hc->tx_no_feedback_timer,\r\njiffies + usecs_to_jiffies(t_nfb));\r\n}\r\nstatic int ccid3_hc_tx_parse_options(struct sock *sk, u8 packet_type,\r\nu8 option, u8 *optval, u8 optlen)\r\n{\r\nstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\n__be32 opt_val;\r\nswitch (option) {\r\ncase TFRC_OPT_RECEIVE_RATE:\r\ncase TFRC_OPT_LOSS_EVENT_RATE:\r\nif (packet_type == DCCP_PKT_DATA)\r\nbreak;\r\nif (unlikely(optlen != 4)) {\r\nDCCP_WARN("%s(%p), invalid len %d for %u\n",\r\ndccp_role(sk), sk, optlen, option);\r\nreturn -EINVAL;\r\n}\r\nopt_val = ntohl(get_unaligned((__be32 *)optval));\r\nif (option == TFRC_OPT_RECEIVE_RATE) {\r\nhc->tx_x_recv = opt_val;\r\nhc->tx_x_recv <<= 6;\r\nccid3_pr_debug("%s(%p), RECEIVE_RATE=%u\n",\r\ndccp_role(sk), sk, opt_val);\r\n} else {\r\nhc->tx_p = tfrc_invert_loss_event_rate(opt_val);\r\nccid3_pr_debug("%s(%p), LOSS_EVENT_RATE=%u\n",\r\ndccp_role(sk), sk, opt_val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccid3_hc_tx_init(struct ccid *ccid, struct sock *sk)\r\n{\r\nstruct ccid3_hc_tx_sock *hc = ccid_priv(ccid);\r\nhc->tx_state = TFRC_SSTATE_NO_SENT;\r\nhc->tx_hist = NULL;\r\nsetup_timer(&hc->tx_no_feedback_timer,\r\nccid3_hc_tx_no_feedback_timer, (unsigned long)sk);\r\nreturn 0;\r\n}\r\nstatic void ccid3_hc_tx_exit(struct sock *sk)\r\n{\r\nstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\nsk_stop_timer(sk, &hc->tx_no_feedback_timer);\r\ntfrc_tx_hist_purge(&hc->tx_hist);\r\n}\r\nstatic void ccid3_hc_tx_get_info(struct sock *sk, struct tcp_info *info)\r\n{\r\ninfo->tcpi_rto = ccid3_hc_tx_sk(sk)->tx_t_rto;\r\ninfo->tcpi_rtt = ccid3_hc_tx_sk(sk)->tx_rtt;\r\n}\r\nstatic int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\r\nu32 __user *optval, int __user *optlen)\r\n{\r\nconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\r\nstruct tfrc_tx_info tfrc;\r\nconst void *val;\r\nswitch (optname) {\r\ncase DCCP_SOCKOPT_CCID_TX_INFO:\r\nif (len < sizeof(tfrc))\r\nreturn -EINVAL;\r\ntfrc.tfrctx_x = hc->tx_x;\r\ntfrc.tfrctx_x_recv = hc->tx_x_recv;\r\ntfrc.tfrctx_x_calc = hc->tx_x_calc;\r\ntfrc.tfrctx_rtt = hc->tx_rtt;\r\ntfrc.tfrctx_p = hc->tx_p;\r\ntfrc.tfrctx_rto = hc->tx_t_rto;\r\ntfrc.tfrctx_ipi = hc->tx_t_ipi;\r\nlen = sizeof(tfrc);\r\nval = &tfrc;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (put_user(len, optlen) || copy_to_user(optval, val, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic const char *ccid3_rx_state_name(enum ccid3_hc_rx_states state)\r\n{\r\nstatic const char *const ccid3_rx_state_names[] = {\r\n[TFRC_RSTATE_NO_DATA] = "NO_DATA",\r\n[TFRC_RSTATE_DATA] = "DATA",\r\n};\r\nreturn ccid3_rx_state_names[state];\r\n}\r\nstatic void ccid3_hc_rx_set_state(struct sock *sk,\r\nenum ccid3_hc_rx_states state)\r\n{\r\nstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\r\nenum ccid3_hc_rx_states oldstate = hc->rx_state;\r\nccid3_pr_debug("%s(%p) %-8.8s -> %s\n",\r\ndccp_role(sk), sk, ccid3_rx_state_name(oldstate),\r\nccid3_rx_state_name(state));\r\nWARN_ON(state == oldstate);\r\nhc->rx_state = state;\r\n}\r\nstatic void ccid3_hc_rx_send_feedback(struct sock *sk,\r\nconst struct sk_buff *skb,\r\nenum ccid3_fback_type fbtype)\r\n{\r\nstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nktime_t now = ktime_get_real();\r\ns64 delta = 0;\r\nswitch (fbtype) {\r\ncase CCID3_FBACK_INITIAL:\r\nhc->rx_x_recv = 0;\r\nhc->rx_pinv = ~0U;\r\nbreak;\r\ncase CCID3_FBACK_PARAM_CHANGE:\r\nif (hc->rx_x_recv > 0)\r\nbreak;\r\ncase CCID3_FBACK_PERIODIC:\r\ndelta = ktime_us_delta(now, hc->rx_tstamp_last_feedback);\r\nif (delta <= 0)\r\nDCCP_BUG("delta (%ld) <= 0", (long)delta);\r\nelse\r\nhc->rx_x_recv = scaled_div32(hc->rx_bytes_recv, delta);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nccid3_pr_debug("Interval %ldusec, X_recv=%u, 1/p=%u\n", (long)delta,\r\nhc->rx_x_recv, hc->rx_pinv);\r\nhc->rx_tstamp_last_feedback = now;\r\nhc->rx_last_counter = dccp_hdr(skb)->dccph_ccval;\r\nhc->rx_bytes_recv = 0;\r\ndp->dccps_hc_rx_insert_options = 1;\r\ndccp_send_ack(sk);\r\n}\r\nstatic int ccid3_hc_rx_insert_options(struct sock *sk, struct sk_buff *skb)\r\n{\r\nconst struct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\r\n__be32 x_recv, pinv;\r\nif (!(sk->sk_state == DCCP_OPEN || sk->sk_state == DCCP_PARTOPEN))\r\nreturn 0;\r\nif (dccp_packet_without_ack(skb))\r\nreturn 0;\r\nx_recv = htonl(hc->rx_x_recv);\r\npinv = htonl(hc->rx_pinv);\r\nif (dccp_insert_option(skb, TFRC_OPT_LOSS_EVENT_RATE,\r\n&pinv, sizeof(pinv)) ||\r\ndccp_insert_option(skb, TFRC_OPT_RECEIVE_RATE,\r\n&x_recv, sizeof(x_recv)))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic u32 ccid3_first_li(struct sock *sk)\r\n{\r\nstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\r\nu32 x_recv, p, delta;\r\nu64 fval;\r\nif (hc->rx_rtt == 0) {\r\nDCCP_WARN("No RTT estimate available, using fallback RTT\n");\r\nhc->rx_rtt = DCCP_FALLBACK_RTT;\r\n}\r\ndelta = ktime_to_us(net_timedelta(hc->rx_tstamp_last_feedback));\r\nx_recv = scaled_div32(hc->rx_bytes_recv, delta);\r\nif (x_recv == 0) {\r\nDCCP_WARN("X_recv==0\n");\r\nif (hc->rx_x_recv == 0) {\r\nDCCP_BUG("stored value of X_recv is zero");\r\nreturn ~0U;\r\n}\r\nx_recv = hc->rx_x_recv;\r\n}\r\nfval = scaled_div(hc->rx_s, hc->rx_rtt);\r\nfval = scaled_div32(fval, x_recv);\r\np = tfrc_calc_x_reverse_lookup(fval);\r\nccid3_pr_debug("%s(%p), receive rate=%u bytes/s, implied "\r\n"loss rate=%u\n", dccp_role(sk), sk, x_recv, p);\r\nreturn p == 0 ? ~0U : scaled_div(1, p);\r\n}\r\nstatic void ccid3_hc_rx_packet_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\r\nenum ccid3_fback_type do_feedback = CCID3_FBACK_NONE;\r\nconst u64 ndp = dccp_sk(sk)->dccps_options_received.dccpor_ndp;\r\nconst bool is_data_packet = dccp_data_packet(skb);\r\nif (unlikely(hc->rx_state == TFRC_RSTATE_NO_DATA)) {\r\nif (is_data_packet) {\r\nconst u32 payload = skb->len - dccp_hdr(skb)->dccph_doff * 4;\r\ndo_feedback = CCID3_FBACK_INITIAL;\r\nccid3_hc_rx_set_state(sk, TFRC_RSTATE_DATA);\r\nhc->rx_s = payload;\r\n}\r\ngoto update_records;\r\n}\r\nif (tfrc_rx_hist_duplicate(&hc->rx_hist, skb))\r\nreturn;\r\nif (is_data_packet) {\r\nconst u32 payload = skb->len - dccp_hdr(skb)->dccph_doff * 4;\r\nhc->rx_s = tfrc_ewma(hc->rx_s, payload, 9);\r\nhc->rx_bytes_recv += payload;\r\n}\r\nif (tfrc_rx_handle_loss(&hc->rx_hist, &hc->rx_li_hist,\r\nskb, ndp, ccid3_first_li, sk)) {\r\ndo_feedback = CCID3_FBACK_PARAM_CHANGE;\r\ngoto done_receiving;\r\n}\r\nif (tfrc_rx_hist_loss_pending(&hc->rx_hist))\r\nreturn;\r\nif (unlikely(!is_data_packet))\r\ngoto update_records;\r\nif (!tfrc_lh_is_initialised(&hc->rx_li_hist)) {\r\nconst u32 sample = tfrc_rx_hist_sample_rtt(&hc->rx_hist, skb);\r\nif (sample != 0)\r\nhc->rx_rtt = tfrc_ewma(hc->rx_rtt, sample, 9);\r\n} else if (tfrc_lh_update_i_mean(&hc->rx_li_hist, skb)) {\r\ndo_feedback = CCID3_FBACK_PARAM_CHANGE;\r\n}\r\nif (SUB16(dccp_hdr(skb)->dccph_ccval, hc->rx_last_counter) > 3)\r\ndo_feedback = CCID3_FBACK_PERIODIC;\r\nupdate_records:\r\ntfrc_rx_hist_add_packet(&hc->rx_hist, skb, ndp);\r\ndone_receiving:\r\nif (do_feedback)\r\nccid3_hc_rx_send_feedback(sk, skb, do_feedback);\r\n}\r\nstatic int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)\r\n{\r\nstruct ccid3_hc_rx_sock *hc = ccid_priv(ccid);\r\nhc->rx_state = TFRC_RSTATE_NO_DATA;\r\ntfrc_lh_init(&hc->rx_li_hist);\r\nreturn tfrc_rx_hist_alloc(&hc->rx_hist);\r\n}\r\nstatic void ccid3_hc_rx_exit(struct sock *sk)\r\n{\r\nstruct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\r\ntfrc_rx_hist_purge(&hc->rx_hist);\r\ntfrc_lh_cleanup(&hc->rx_li_hist);\r\n}\r\nstatic void ccid3_hc_rx_get_info(struct sock *sk, struct tcp_info *info)\r\n{\r\ninfo->tcpi_ca_state = ccid3_hc_rx_sk(sk)->rx_state;\r\ninfo->tcpi_options |= TCPI_OPT_TIMESTAMPS;\r\ninfo->tcpi_rcv_rtt = ccid3_hc_rx_sk(sk)->rx_rtt;\r\n}\r\nstatic int ccid3_hc_rx_getsockopt(struct sock *sk, const int optname, int len,\r\nu32 __user *optval, int __user *optlen)\r\n{\r\nconst struct ccid3_hc_rx_sock *hc = ccid3_hc_rx_sk(sk);\r\nstruct tfrc_rx_info rx_info;\r\nconst void *val;\r\nswitch (optname) {\r\ncase DCCP_SOCKOPT_CCID_RX_INFO:\r\nif (len < sizeof(rx_info))\r\nreturn -EINVAL;\r\nrx_info.tfrcrx_x_recv = hc->rx_x_recv;\r\nrx_info.tfrcrx_rtt = hc->rx_rtt;\r\nrx_info.tfrcrx_p = tfrc_invert_loss_event_rate(hc->rx_pinv);\r\nlen = sizeof(rx_info);\r\nval = &rx_info;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (put_user(len, optlen) || copy_to_user(optval, val, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}
