int ipath_make_uc_req(struct ipath_qp *qp)\r\n{\r\nstruct ipath_other_headers *ohdr;\r\nstruct ipath_swqe *wqe;\r\nunsigned long flags;\r\nu32 hwords;\r\nu32 bth0;\r\nu32 len;\r\nu32 pmtu = ib_mtu_enum_to_int(qp->path_mtu);\r\nint ret = 0;\r\nspin_lock_irqsave(&qp->s_lock, flags);\r\nif (!(ib_ipath_state_ops[qp->state] & IPATH_PROCESS_SEND_OK)) {\r\nif (!(ib_ipath_state_ops[qp->state] & IPATH_FLUSH_SEND))\r\ngoto bail;\r\nif (qp->s_last == qp->s_head)\r\ngoto bail;\r\nif (atomic_read(&qp->s_dma_busy)) {\r\nqp->s_flags |= IPATH_S_WAIT_DMA;\r\ngoto bail;\r\n}\r\nwqe = get_swqe_ptr(qp, qp->s_last);\r\nipath_send_complete(qp, wqe, IB_WC_WR_FLUSH_ERR);\r\ngoto done;\r\n}\r\nohdr = &qp->s_hdr.u.oth;\r\nif (qp->remote_ah_attr.ah_flags & IB_AH_GRH)\r\nohdr = &qp->s_hdr.u.l.oth;\r\nhwords = 5;\r\nbth0 = 1 << 22;\r\nwqe = get_swqe_ptr(qp, qp->s_cur);\r\nqp->s_wqe = NULL;\r\nswitch (qp->s_state) {\r\ndefault:\r\nif (!(ib_ipath_state_ops[qp->state] &\r\nIPATH_PROCESS_NEXT_SEND_OK))\r\ngoto bail;\r\nif (qp->s_cur == qp->s_head)\r\ngoto bail;\r\nqp->s_psn = wqe->psn = qp->s_next_psn;\r\nqp->s_sge.sge = wqe->sg_list[0];\r\nqp->s_sge.sg_list = wqe->sg_list + 1;\r\nqp->s_sge.num_sge = wqe->wr.num_sge;\r\nqp->s_len = len = wqe->length;\r\nswitch (wqe->wr.opcode) {\r\ncase IB_WR_SEND:\r\ncase IB_WR_SEND_WITH_IMM:\r\nif (len > pmtu) {\r\nqp->s_state = OP(SEND_FIRST);\r\nlen = pmtu;\r\nbreak;\r\n}\r\nif (wqe->wr.opcode == IB_WR_SEND)\r\nqp->s_state = OP(SEND_ONLY);\r\nelse {\r\nqp->s_state =\r\nOP(SEND_ONLY_WITH_IMMEDIATE);\r\nohdr->u.imm_data = wqe->wr.ex.imm_data;\r\nhwords += 1;\r\n}\r\nif (wqe->wr.send_flags & IB_SEND_SOLICITED)\r\nbth0 |= 1 << 23;\r\nqp->s_wqe = wqe;\r\nif (++qp->s_cur >= qp->s_size)\r\nqp->s_cur = 0;\r\nbreak;\r\ncase IB_WR_RDMA_WRITE:\r\ncase IB_WR_RDMA_WRITE_WITH_IMM:\r\nohdr->u.rc.reth.vaddr =\r\ncpu_to_be64(wqe->wr.wr.rdma.remote_addr);\r\nohdr->u.rc.reth.rkey =\r\ncpu_to_be32(wqe->wr.wr.rdma.rkey);\r\nohdr->u.rc.reth.length = cpu_to_be32(len);\r\nhwords += sizeof(struct ib_reth) / 4;\r\nif (len > pmtu) {\r\nqp->s_state = OP(RDMA_WRITE_FIRST);\r\nlen = pmtu;\r\nbreak;\r\n}\r\nif (wqe->wr.opcode == IB_WR_RDMA_WRITE)\r\nqp->s_state = OP(RDMA_WRITE_ONLY);\r\nelse {\r\nqp->s_state =\r\nOP(RDMA_WRITE_ONLY_WITH_IMMEDIATE);\r\nohdr->u.rc.imm_data = wqe->wr.ex.imm_data;\r\nhwords += 1;\r\nif (wqe->wr.send_flags & IB_SEND_SOLICITED)\r\nbth0 |= 1 << 23;\r\n}\r\nqp->s_wqe = wqe;\r\nif (++qp->s_cur >= qp->s_size)\r\nqp->s_cur = 0;\r\nbreak;\r\ndefault:\r\ngoto bail;\r\n}\r\nbreak;\r\ncase OP(SEND_FIRST):\r\nqp->s_state = OP(SEND_MIDDLE);\r\ncase OP(SEND_MIDDLE):\r\nlen = qp->s_len;\r\nif (len > pmtu) {\r\nlen = pmtu;\r\nbreak;\r\n}\r\nif (wqe->wr.opcode == IB_WR_SEND)\r\nqp->s_state = OP(SEND_LAST);\r\nelse {\r\nqp->s_state = OP(SEND_LAST_WITH_IMMEDIATE);\r\nohdr->u.imm_data = wqe->wr.ex.imm_data;\r\nhwords += 1;\r\n}\r\nif (wqe->wr.send_flags & IB_SEND_SOLICITED)\r\nbth0 |= 1 << 23;\r\nqp->s_wqe = wqe;\r\nif (++qp->s_cur >= qp->s_size)\r\nqp->s_cur = 0;\r\nbreak;\r\ncase OP(RDMA_WRITE_FIRST):\r\nqp->s_state = OP(RDMA_WRITE_MIDDLE);\r\ncase OP(RDMA_WRITE_MIDDLE):\r\nlen = qp->s_len;\r\nif (len > pmtu) {\r\nlen = pmtu;\r\nbreak;\r\n}\r\nif (wqe->wr.opcode == IB_WR_RDMA_WRITE)\r\nqp->s_state = OP(RDMA_WRITE_LAST);\r\nelse {\r\nqp->s_state =\r\nOP(RDMA_WRITE_LAST_WITH_IMMEDIATE);\r\nohdr->u.imm_data = wqe->wr.ex.imm_data;\r\nhwords += 1;\r\nif (wqe->wr.send_flags & IB_SEND_SOLICITED)\r\nbth0 |= 1 << 23;\r\n}\r\nqp->s_wqe = wqe;\r\nif (++qp->s_cur >= qp->s_size)\r\nqp->s_cur = 0;\r\nbreak;\r\n}\r\nqp->s_len -= len;\r\nqp->s_hdrwords = hwords;\r\nqp->s_cur_sge = &qp->s_sge;\r\nqp->s_cur_size = len;\r\nipath_make_ruc_header(to_idev(qp->ibqp.device),\r\nqp, ohdr, bth0 | (qp->s_state << 24),\r\nqp->s_next_psn++ & IPATH_PSN_MASK);\r\ndone:\r\nret = 1;\r\ngoto unlock;\r\nbail:\r\nqp->s_flags &= ~IPATH_S_BUSY;\r\nunlock:\r\nspin_unlock_irqrestore(&qp->s_lock, flags);\r\nreturn ret;\r\n}\r\nvoid ipath_uc_rcv(struct ipath_ibdev *dev, struct ipath_ib_header *hdr,\r\nint has_grh, void *data, u32 tlen, struct ipath_qp *qp)\r\n{\r\nstruct ipath_other_headers *ohdr;\r\nint opcode;\r\nu32 hdrsize;\r\nu32 psn;\r\nu32 pad;\r\nstruct ib_wc wc;\r\nu32 pmtu = ib_mtu_enum_to_int(qp->path_mtu);\r\nstruct ib_reth *reth;\r\nint header_in_data;\r\nif (unlikely(be16_to_cpu(hdr->lrh[3]) != qp->remote_ah_attr.dlid))\r\ngoto done;\r\nif (!has_grh) {\r\nohdr = &hdr->u.oth;\r\nhdrsize = 8 + 12;\r\npsn = be32_to_cpu(ohdr->bth[2]);\r\nheader_in_data = 0;\r\n} else {\r\nohdr = &hdr->u.l.oth;\r\nhdrsize = 8 + 40 + 12;\r\nheader_in_data = dev->dd->ipath_rcvhdrentsize == 16;\r\nif (header_in_data) {\r\npsn = be32_to_cpu(((__be32 *) data)[0]);\r\ndata += sizeof(__be32);\r\n} else\r\npsn = be32_to_cpu(ohdr->bth[2]);\r\n}\r\nopcode = be32_to_cpu(ohdr->bth[0]) >> 24;\r\nmemset(&wc, 0, sizeof wc);\r\nif (unlikely(ipath_cmp24(psn, qp->r_psn) != 0)) {\r\nqp->r_psn = psn;\r\ninv:\r\nqp->r_state = OP(SEND_LAST);\r\nswitch (opcode) {\r\ncase OP(SEND_FIRST):\r\ncase OP(SEND_ONLY):\r\ncase OP(SEND_ONLY_WITH_IMMEDIATE):\r\ngoto send_first;\r\ncase OP(RDMA_WRITE_FIRST):\r\ncase OP(RDMA_WRITE_ONLY):\r\ncase OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE):\r\ngoto rdma_first;\r\ndefault:\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\n}\r\nswitch (qp->r_state) {\r\ncase OP(SEND_FIRST):\r\ncase OP(SEND_MIDDLE):\r\nif (opcode == OP(SEND_MIDDLE) ||\r\nopcode == OP(SEND_LAST) ||\r\nopcode == OP(SEND_LAST_WITH_IMMEDIATE))\r\nbreak;\r\ngoto inv;\r\ncase OP(RDMA_WRITE_FIRST):\r\ncase OP(RDMA_WRITE_MIDDLE):\r\nif (opcode == OP(RDMA_WRITE_MIDDLE) ||\r\nopcode == OP(RDMA_WRITE_LAST) ||\r\nopcode == OP(RDMA_WRITE_LAST_WITH_IMMEDIATE))\r\nbreak;\r\ngoto inv;\r\ndefault:\r\nif (opcode == OP(SEND_FIRST) ||\r\nopcode == OP(SEND_ONLY) ||\r\nopcode == OP(SEND_ONLY_WITH_IMMEDIATE) ||\r\nopcode == OP(RDMA_WRITE_FIRST) ||\r\nopcode == OP(RDMA_WRITE_ONLY) ||\r\nopcode == OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE))\r\nbreak;\r\ngoto inv;\r\n}\r\nswitch (opcode) {\r\ncase OP(SEND_FIRST):\r\ncase OP(SEND_ONLY):\r\ncase OP(SEND_ONLY_WITH_IMMEDIATE):\r\nsend_first:\r\nif (qp->r_flags & IPATH_R_REUSE_SGE) {\r\nqp->r_flags &= ~IPATH_R_REUSE_SGE;\r\nqp->r_sge = qp->s_rdma_read_sge;\r\n} else if (!ipath_get_rwqe(qp, 0)) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nqp->s_rdma_read_sge = qp->r_sge;\r\nqp->r_rcv_len = 0;\r\nif (opcode == OP(SEND_ONLY))\r\ngoto send_last;\r\nelse if (opcode == OP(SEND_ONLY_WITH_IMMEDIATE))\r\ngoto send_last_imm;\r\ncase OP(SEND_MIDDLE):\r\nif (unlikely(tlen != (hdrsize + pmtu + 4))) {\r\nqp->r_flags |= IPATH_R_REUSE_SGE;\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nqp->r_rcv_len += pmtu;\r\nif (unlikely(qp->r_rcv_len > qp->r_len)) {\r\nqp->r_flags |= IPATH_R_REUSE_SGE;\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nipath_copy_sge(&qp->r_sge, data, pmtu);\r\nbreak;\r\ncase OP(SEND_LAST_WITH_IMMEDIATE):\r\nsend_last_imm:\r\nif (header_in_data) {\r\nwc.ex.imm_data = *(__be32 *) data;\r\ndata += sizeof(__be32);\r\n} else {\r\nwc.ex.imm_data = ohdr->u.imm_data;\r\n}\r\nhdrsize += 4;\r\nwc.wc_flags = IB_WC_WITH_IMM;\r\ncase OP(SEND_LAST):\r\nsend_last:\r\npad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\r\nif (unlikely(tlen < (hdrsize + pad + 4))) {\r\nqp->r_flags |= IPATH_R_REUSE_SGE;\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\ntlen -= (hdrsize + pad + 4);\r\nwc.byte_len = tlen + qp->r_rcv_len;\r\nif (unlikely(wc.byte_len > qp->r_len)) {\r\nqp->r_flags |= IPATH_R_REUSE_SGE;\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nwc.opcode = IB_WC_RECV;\r\nlast_imm:\r\nipath_copy_sge(&qp->r_sge, data, tlen);\r\nwc.wr_id = qp->r_wr_id;\r\nwc.status = IB_WC_SUCCESS;\r\nwc.qp = &qp->ibqp;\r\nwc.src_qp = qp->remote_qpn;\r\nwc.slid = qp->remote_ah_attr.dlid;\r\nwc.sl = qp->remote_ah_attr.sl;\r\nipath_cq_enter(to_icq(qp->ibqp.recv_cq), &wc,\r\n(ohdr->bth[0] &\r\ncpu_to_be32(1 << 23)) != 0);\r\nbreak;\r\ncase OP(RDMA_WRITE_FIRST):\r\ncase OP(RDMA_WRITE_ONLY):\r\ncase OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE):\r\nrdma_first:\r\nif (!header_in_data)\r\nreth = &ohdr->u.rc.reth;\r\nelse {\r\nreth = (struct ib_reth *)data;\r\ndata += sizeof(*reth);\r\n}\r\nhdrsize += sizeof(*reth);\r\nqp->r_len = be32_to_cpu(reth->length);\r\nqp->r_rcv_len = 0;\r\nif (qp->r_len != 0) {\r\nu32 rkey = be32_to_cpu(reth->rkey);\r\nu64 vaddr = be64_to_cpu(reth->vaddr);\r\nint ok;\r\nok = ipath_rkey_ok(qp, &qp->r_sge, qp->r_len,\r\nvaddr, rkey,\r\nIB_ACCESS_REMOTE_WRITE);\r\nif (unlikely(!ok)) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\n} else {\r\nqp->r_sge.sg_list = NULL;\r\nqp->r_sge.sge.mr = NULL;\r\nqp->r_sge.sge.vaddr = NULL;\r\nqp->r_sge.sge.length = 0;\r\nqp->r_sge.sge.sge_length = 0;\r\n}\r\nif (unlikely(!(qp->qp_access_flags &\r\nIB_ACCESS_REMOTE_WRITE))) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nif (opcode == OP(RDMA_WRITE_ONLY))\r\ngoto rdma_last;\r\nelse if (opcode == OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE))\r\ngoto rdma_last_imm;\r\ncase OP(RDMA_WRITE_MIDDLE):\r\nif (unlikely(tlen != (hdrsize + pmtu + 4))) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nqp->r_rcv_len += pmtu;\r\nif (unlikely(qp->r_rcv_len > qp->r_len)) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nipath_copy_sge(&qp->r_sge, data, pmtu);\r\nbreak;\r\ncase OP(RDMA_WRITE_LAST_WITH_IMMEDIATE):\r\nrdma_last_imm:\r\nif (header_in_data) {\r\nwc.ex.imm_data = *(__be32 *) data;\r\ndata += sizeof(__be32);\r\n} else {\r\nwc.ex.imm_data = ohdr->u.imm_data;\r\n}\r\nhdrsize += 4;\r\nwc.wc_flags = IB_WC_WITH_IMM;\r\npad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\r\nif (unlikely(tlen < (hdrsize + pad + 4))) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\ntlen -= (hdrsize + pad + 4);\r\nif (unlikely(tlen + qp->r_rcv_len != qp->r_len)) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nif (qp->r_flags & IPATH_R_REUSE_SGE)\r\nqp->r_flags &= ~IPATH_R_REUSE_SGE;\r\nelse if (!ipath_get_rwqe(qp, 1)) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nwc.byte_len = qp->r_len;\r\nwc.opcode = IB_WC_RECV_RDMA_WITH_IMM;\r\ngoto last_imm;\r\ncase OP(RDMA_WRITE_LAST):\r\nrdma_last:\r\npad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\r\nif (unlikely(tlen < (hdrsize + pad + 4))) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\ntlen -= (hdrsize + pad + 4);\r\nif (unlikely(tlen + qp->r_rcv_len != qp->r_len)) {\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nipath_copy_sge(&qp->r_sge, data, tlen);\r\nbreak;\r\ndefault:\r\ndev->n_pkt_drops++;\r\ngoto done;\r\n}\r\nqp->r_psn++;\r\nqp->r_state = opcode;\r\ndone:\r\nreturn;\r\n}
