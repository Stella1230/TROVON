static int parse_cfe_partitions(struct mtd_info *master,\r\nstruct mtd_partition **pparts)\r\n{\r\nint nrparts = 3, curpart = 0;\r\nstruct bcm_tag *buf;\r\nstruct mtd_partition *parts;\r\nint ret;\r\nsize_t retlen;\r\nunsigned int rootfsaddr, kerneladdr, spareaddr;\r\nunsigned int rootfslen, kernellen, sparelen, totallen;\r\nint namelen = 0;\r\nint i;\r\nchar *boardid;\r\nchar *tagversion;\r\nbuf = vmalloc(sizeof(struct bcm_tag));\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = master->read(master, master->erasesize, sizeof(struct bcm_tag),\r\n&retlen, (void *)buf);\r\nif (retlen != sizeof(struct bcm_tag)) {\r\nvfree(buf);\r\nreturn -EIO;\r\n}\r\nsscanf(buf->kernel_address, "%u", &kerneladdr);\r\nsscanf(buf->kernel_length, "%u", &kernellen);\r\nsscanf(buf->total_length, "%u", &totallen);\r\ntagversion = &(buf->tag_version[0]);\r\nboardid = &(buf->board_id[0]);\r\nprintk(KERN_INFO PFX "CFE boot tag found with version %s "\r\n"and board type %s\n", tagversion, boardid);\r\nkerneladdr = kerneladdr - BCM63XX_EXTENDED_SIZE;\r\nrootfsaddr = kerneladdr + kernellen;\r\nspareaddr = roundup(totallen, master->erasesize) + master->erasesize;\r\nsparelen = master->size - spareaddr - master->erasesize;\r\nrootfslen = spareaddr - rootfsaddr;\r\nnamelen = 8;\r\nif (rootfslen > 0) {\r\nnrparts++;\r\nnamelen += 6;\r\n};\r\nif (kernellen > 0) {\r\nnrparts++;\r\nnamelen += 6;\r\n};\r\nparts = kzalloc(sizeof(*parts) * nrparts + 10 * nrparts, GFP_KERNEL);\r\nif (!parts) {\r\nvfree(buf);\r\nreturn -ENOMEM;\r\n};\r\nparts[curpart].name = "CFE";\r\nparts[curpart].offset = 0;\r\nparts[curpart].size = master->erasesize;\r\ncurpart++;\r\nif (kernellen > 0) {\r\nparts[curpart].name = "kernel";\r\nparts[curpart].offset = kerneladdr;\r\nparts[curpart].size = kernellen;\r\ncurpart++;\r\n};\r\nif (rootfslen > 0) {\r\nparts[curpart].name = "rootfs";\r\nparts[curpart].offset = rootfsaddr;\r\nparts[curpart].size = rootfslen;\r\nif (sparelen > 0)\r\nparts[curpart].size += sparelen;\r\ncurpart++;\r\n};\r\nparts[curpart].name = "nvram";\r\nparts[curpart].offset = master->size - master->erasesize;\r\nparts[curpart].size = master->erasesize;\r\ncurpart++;\r\nparts[curpart].name = "linux";\r\nparts[curpart].offset = parts[0].size;\r\nparts[curpart].size = master->size - parts[0].size - parts[3].size;\r\nfor (i = 0; i < nrparts; i++)\r\nprintk(KERN_INFO PFX "Partition %d is %s offset %lx and "\r\n"length %lx\n", i, parts[i].name,\r\n(long unsigned int)(parts[i].offset),\r\n(long unsigned int)(parts[i].size));\r\nprintk(KERN_INFO PFX "Spare partition is %x offset and length %x\n",\r\nspareaddr, sparelen);\r\n*pparts = parts;\r\nvfree(buf);\r\nreturn nrparts;\r\n}\r\nstatic int bcm963xx_detect_cfe(struct mtd_info *master)\r\n{\r\nint idoffset = 0x4e0;\r\nstatic char idstring[8] = "CFE1CFE1";\r\nchar buf[9];\r\nint ret;\r\nsize_t retlen;\r\nret = master->read(master, idoffset, 8, &retlen, (void *)buf);\r\nbuf[retlen] = 0;\r\nprintk(KERN_INFO PFX "Read Signature value of %s\n", buf);\r\nreturn strncmp(idstring, buf, 8);\r\n}\r\nstatic int bcm963xx_probe(struct platform_device *pdev)\r\n{\r\nint err = 0;\r\nint parsed_nr_parts = 0;\r\nchar *part_type;\r\nstruct resource *r;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no resource supplied\n");\r\nreturn -ENODEV;\r\n}\r\nbcm963xx_map.phys = r->start;\r\nbcm963xx_map.size = resource_size(r);\r\nbcm963xx_map.virt = ioremap(r->start, resource_size(r));\r\nif (!bcm963xx_map.virt) {\r\ndev_err(&pdev->dev, "failed to ioremap\n");\r\nreturn -EIO;\r\n}\r\ndev_info(&pdev->dev, "0x%08lx at 0x%08x\n",\r\nbcm963xx_map.size, bcm963xx_map.phys);\r\nsimple_map_init(&bcm963xx_map);\r\nbcm963xx_mtd_info = do_map_probe("cfi_probe", &bcm963xx_map);\r\nif (!bcm963xx_mtd_info) {\r\ndev_err(&pdev->dev, "failed to probe using CFI\n");\r\nbcm963xx_mtd_info = do_map_probe("jedec_probe", &bcm963xx_map);\r\nif (bcm963xx_mtd_info)\r\ngoto probe_ok;\r\ndev_err(&pdev->dev, "failed to probe using JEDEC\n");\r\nerr = -EIO;\r\ngoto err_probe;\r\n}\r\nprobe_ok:\r\nbcm963xx_mtd_info->owner = THIS_MODULE;\r\nif (bcm963xx_detect_cfe(bcm963xx_mtd_info) == 0) {\r\ndev_info(&pdev->dev, "CFE bootloader detected\n");\r\nif (parsed_nr_parts == 0) {\r\nint ret = parse_cfe_partitions(bcm963xx_mtd_info,\r\n&parsed_parts);\r\nif (ret > 0) {\r\npart_type = "CFE";\r\nparsed_nr_parts = ret;\r\n}\r\n}\r\n} else {\r\ndev_info(&pdev->dev, "unsupported bootloader\n");\r\nerr = -ENODEV;\r\ngoto err_probe;\r\n}\r\nreturn mtd_device_register(bcm963xx_mtd_info, parsed_parts,\r\nparsed_nr_parts);\r\nerr_probe:\r\niounmap(bcm963xx_map.virt);\r\nreturn err;\r\n}\r\nstatic int bcm963xx_remove(struct platform_device *pdev)\r\n{\r\nif (bcm963xx_mtd_info) {\r\nmtd_device_unregister(bcm963xx_mtd_info);\r\nmap_destroy(bcm963xx_mtd_info);\r\n}\r\nif (bcm963xx_map.virt) {\r\niounmap(bcm963xx_map.virt);\r\nbcm963xx_map.virt = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bcm963xx_mtd_init(void)\r\n{\r\nreturn platform_driver_register(&bcm63xx_mtd_dev);\r\n}\r\nstatic void __exit bcm963xx_mtd_exit(void)\r\n{\r\nplatform_driver_unregister(&bcm63xx_mtd_dev);\r\n}
