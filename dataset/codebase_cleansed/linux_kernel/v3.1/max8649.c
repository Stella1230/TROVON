static inline int max8649_read_device(struct i2c_client *i2c,\r\nint reg, int bytes, void *dest)\r\n{\r\nunsigned char data;\r\nint ret;\r\ndata = (unsigned char)reg;\r\nret = i2c_master_send(i2c, &data, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_master_recv(i2c, dest, bytes);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic inline int max8649_write_device(struct i2c_client *i2c,\r\nint reg, int bytes, void *src)\r\n{\r\nunsigned char buf[bytes + 1];\r\nint ret;\r\nbuf[0] = (unsigned char)reg;\r\nmemcpy(&buf[1], src, bytes);\r\nret = i2c_master_send(i2c, buf, bytes + 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int max8649_reg_read(struct i2c_client *i2c, int reg)\r\n{\r\nstruct max8649_regulator_info *info = i2c_get_clientdata(i2c);\r\nunsigned char data;\r\nint ret;\r\nmutex_lock(&info->io_lock);\r\nret = max8649_read_device(i2c, reg, 1, &data);\r\nmutex_unlock(&info->io_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (int)data;\r\n}\r\nstatic int max8649_set_bits(struct i2c_client *i2c, int reg,\r\nunsigned char mask, unsigned char data)\r\n{\r\nstruct max8649_regulator_info *info = i2c_get_clientdata(i2c);\r\nunsigned char value;\r\nint ret;\r\nmutex_lock(&info->io_lock);\r\nret = max8649_read_device(i2c, reg, 1, &value);\r\nif (ret < 0)\r\ngoto out;\r\nvalue &= ~mask;\r\nvalue |= data;\r\nret = max8649_write_device(i2c, reg, 1, &value);\r\nout:\r\nmutex_unlock(&info->io_lock);\r\nreturn ret;\r\n}\r\nstatic inline int check_range(int min_uV, int max_uV)\r\n{\r\nif ((min_uV < MAX8649_DCDC_VMIN) || (max_uV > MAX8649_DCDC_VMAX)\r\n|| (min_uV > max_uV))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int max8649_list_voltage(struct regulator_dev *rdev, unsigned index)\r\n{\r\nreturn (MAX8649_DCDC_VMIN + index * MAX8649_DCDC_STEP);\r\n}\r\nstatic int max8649_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\r\nunsigned char data;\r\nint ret;\r\nret = max8649_reg_read(info->i2c, info->vol_reg);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = (unsigned char)ret & MAX8649_VOL_MASK;\r\nreturn max8649_list_voltage(rdev, data);\r\n}\r\nstatic int max8649_set_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV, unsigned *selector)\r\n{\r\nstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\r\nunsigned char data, mask;\r\nif (check_range(min_uV, max_uV)) {\r\ndev_err(info->dev, "invalid voltage range (%d, %d) uV\n",\r\nmin_uV, max_uV);\r\nreturn -EINVAL;\r\n}\r\ndata = (min_uV - MAX8649_DCDC_VMIN + MAX8649_DCDC_STEP - 1)\r\n/ MAX8649_DCDC_STEP;\r\nmask = MAX8649_VOL_MASK;\r\n*selector = data & mask;\r\nreturn max8649_set_bits(info->i2c, info->vol_reg, mask, data);\r\n}\r\nstatic int max8649_enable(struct regulator_dev *rdev)\r\n{\r\nstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\r\nreturn max8649_set_bits(info->i2c, MAX8649_CONTROL, MAX8649_EN_PD, 0);\r\n}\r\nstatic int max8649_disable(struct regulator_dev *rdev)\r\n{\r\nstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\r\nreturn max8649_set_bits(info->i2c, MAX8649_CONTROL, MAX8649_EN_PD,\r\nMAX8649_EN_PD);\r\n}\r\nstatic int max8649_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\r\nint ret;\r\nret = max8649_reg_read(info->i2c, MAX8649_CONTROL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !((unsigned char)ret & MAX8649_EN_PD);\r\n}\r\nstatic int max8649_enable_time(struct regulator_dev *rdev)\r\n{\r\nstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\r\nint voltage, rate, ret;\r\nret = max8649_reg_read(info->i2c, info->vol_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= MAX8649_VOL_MASK;\r\nvoltage = max8649_list_voltage(rdev, (unsigned char)ret);\r\nret = max8649_reg_read(info->i2c, MAX8649_RAMP);\r\nif (ret < 0)\r\nreturn ret;\r\nret = (ret & MAX8649_RAMP_MASK) >> 5;\r\nrate = (32 * 1000) >> ret;\r\nreturn (voltage / rate);\r\n}\r\nstatic int max8649_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nmax8649_set_bits(info->i2c, info->vol_reg, MAX8649_FORCE_PWM,\r\nMAX8649_FORCE_PWM);\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nmax8649_set_bits(info->i2c, info->vol_reg,\r\nMAX8649_FORCE_PWM, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int max8649_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\r\nint ret;\r\nret = max8649_reg_read(info->i2c, info->vol_reg);\r\nif (ret & MAX8649_FORCE_PWM)\r\nreturn REGULATOR_MODE_FAST;\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int __devinit max8649_regulator_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max8649_platform_data *pdata = client->dev.platform_data;\r\nstruct max8649_regulator_info *info = NULL;\r\nunsigned char data;\r\nint ret;\r\ninfo = kzalloc(sizeof(struct max8649_regulator_info), GFP_KERNEL);\r\nif (!info) {\r\ndev_err(&client->dev, "No enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->i2c = client;\r\ninfo->dev = &client->dev;\r\nmutex_init(&info->io_lock);\r\ni2c_set_clientdata(client, info);\r\ninfo->mode = pdata->mode;\r\nswitch (info->mode) {\r\ncase 0:\r\ninfo->vol_reg = MAX8649_MODE0;\r\nbreak;\r\ncase 1:\r\ninfo->vol_reg = MAX8649_MODE1;\r\nbreak;\r\ncase 2:\r\ninfo->vol_reg = MAX8649_MODE2;\r\nbreak;\r\ncase 3:\r\ninfo->vol_reg = MAX8649_MODE3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = max8649_reg_read(info->i2c, MAX8649_CHIP_ID1);\r\nif (ret < 0) {\r\ndev_err(info->dev, "Failed to detect ID of MAX8649:%d\n",\r\nret);\r\ngoto out;\r\n}\r\ndev_info(info->dev, "Detected MAX8649 (ID:%x)\n", ret);\r\nmax8649_set_bits(info->i2c, MAX8649_CONTROL, MAX8649_VID_MASK, 0);\r\ninfo->extclk = pdata->extclk;\r\ndata = (info->extclk) ? MAX8649_SYNC_EXTCLK : 0;\r\nmax8649_set_bits(info->i2c, info->vol_reg, MAX8649_SYNC_EXTCLK, data);\r\nif (info->extclk) {\r\ninfo->extclk_freq = pdata->extclk_freq;\r\nmax8649_set_bits(info->i2c, MAX8649_SYNC, MAX8649_EXT_MASK,\r\ninfo->extclk_freq << 6);\r\n}\r\nif (pdata->ramp_timing) {\r\ninfo->ramp_timing = pdata->ramp_timing;\r\nmax8649_set_bits(info->i2c, MAX8649_RAMP, MAX8649_RAMP_MASK,\r\ninfo->ramp_timing << 5);\r\n}\r\ninfo->ramp_down = pdata->ramp_down;\r\nif (info->ramp_down) {\r\nmax8649_set_bits(info->i2c, MAX8649_RAMP, MAX8649_RAMP_DOWN,\r\nMAX8649_RAMP_DOWN);\r\n}\r\ninfo->regulator = regulator_register(&dcdc_desc, &client->dev,\r\npdata->regulator, info);\r\nif (IS_ERR(info->regulator)) {\r\ndev_err(info->dev, "failed to register regulator %s\n",\r\ndcdc_desc.name);\r\nret = PTR_ERR(info->regulator);\r\ngoto out;\r\n}\r\ndev_info(info->dev, "Max8649 regulator device is detected.\n");\r\nreturn 0;\r\nout:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int __devexit max8649_regulator_remove(struct i2c_client *client)\r\n{\r\nstruct max8649_regulator_info *info = i2c_get_clientdata(client);\r\nif (info) {\r\nif (info->regulator)\r\nregulator_unregister(info->regulator);\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init max8649_init(void)\r\n{\r\nreturn i2c_add_driver(&max8649_driver);\r\n}\r\nstatic void __exit max8649_exit(void)\r\n{\r\ni2c_del_driver(&max8649_driver);\r\n}
