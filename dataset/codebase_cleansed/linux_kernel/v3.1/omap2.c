static void omap_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nif (cmd != NAND_CMD_NONE) {\r\nif (ctrl & NAND_CLE)\r\ngpmc_nand_write(info->gpmc_cs, GPMC_NAND_COMMAND, cmd);\r\nelse if (ctrl & NAND_ALE)\r\ngpmc_nand_write(info->gpmc_cs, GPMC_NAND_ADDRESS, cmd);\r\nelse\r\ngpmc_nand_write(info->gpmc_cs, GPMC_NAND_DATA, cmd);\r\n}\r\n}\r\nstatic void omap_read_buf8(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nioread8_rep(nand->IO_ADDR_R, buf, len);\r\n}\r\nstatic void omap_write_buf8(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nu_char *p = (u_char *)buf;\r\nu32 status = 0;\r\nwhile (len--) {\r\niowrite8(*p++, info->nand.IO_ADDR_W);\r\ndo {\r\nstatus = gpmc_read_status(GPMC_STATUS_BUFFER);\r\n} while (!status);\r\n}\r\n}\r\nstatic void omap_read_buf16(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nioread16_rep(nand->IO_ADDR_R, buf, len / 2);\r\n}\r\nstatic void omap_write_buf16(struct mtd_info *mtd, const u_char * buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nu16 *p = (u16 *) buf;\r\nu32 status = 0;\r\nlen >>= 1;\r\nwhile (len--) {\r\niowrite16(*p++, info->nand.IO_ADDR_W);\r\ndo {\r\nstatus = gpmc_read_status(GPMC_STATUS_BUFFER);\r\n} while (!status);\r\n}\r\n}\r\nstatic void omap_read_buf_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nuint32_t r_count = 0;\r\nint ret = 0;\r\nu32 *p = (u32 *)buf;\r\nif (len % 4) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, buf, len % 4);\r\nelse\r\nomap_read_buf8(mtd, buf, len % 4);\r\np = (u32 *) (buf + len % 4);\r\nlen -= len % 4;\r\n}\r\nret = gpmc_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x0, len, 0x0);\r\nif (ret) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, (u_char *)p, len);\r\nelse\r\nomap_read_buf8(mtd, (u_char *)p, len);\r\n} else {\r\ndo {\r\nr_count = gpmc_read_status(GPMC_PREFETCH_FIFO_CNT);\r\nr_count = r_count >> 2;\r\nioread32_rep(info->nand.IO_ADDR_R, p, r_count);\r\np += r_count;\r\nlen -= r_count << 2;\r\n} while (len);\r\ngpmc_prefetch_reset(info->gpmc_cs);\r\n}\r\n}\r\nstatic void omap_write_buf_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nuint32_t w_count = 0;\r\nint i = 0, ret = 0;\r\nu16 *p = (u16 *)buf;\r\nunsigned long tim, limit;\r\nif (len % 2 != 0) {\r\nwriteb(*buf, info->nand.IO_ADDR_W);\r\np = (u16 *)(buf + 1);\r\nlen--;\r\n}\r\nret = gpmc_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x0, len, 0x1);\r\nif (ret) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_write_buf16(mtd, (u_char *)p, len);\r\nelse\r\nomap_write_buf8(mtd, (u_char *)p, len);\r\n} else {\r\nwhile (len) {\r\nw_count = gpmc_read_status(GPMC_PREFETCH_FIFO_CNT);\r\nw_count = w_count >> 1;\r\nfor (i = 0; (i < w_count) && len; i++, len -= 2)\r\niowrite16(*p++, info->nand.IO_ADDR_W);\r\n}\r\ntim = 0;\r\nlimit = (loops_per_jiffy *\r\nmsecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\nwhile (gpmc_read_status(GPMC_PREFETCH_COUNT) && (tim++ < limit))\r\ncpu_relax();\r\ngpmc_prefetch_reset(info->gpmc_cs);\r\n}\r\n}\r\nstatic void omap_nand_dma_cb(int lch, u16 ch_status, void *data)\r\n{\r\ncomplete((struct completion *) data);\r\n}\r\nstatic inline int omap_nand_dma_transfer(struct mtd_info *mtd, void *addr,\r\nunsigned int len, int is_write)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nenum dma_data_direction dir = is_write ? DMA_TO_DEVICE :\r\nDMA_FROM_DEVICE;\r\ndma_addr_t dma_addr;\r\nint ret;\r\nunsigned long tim, limit;\r\nint buf_len = len >> 6;\r\nif (addr >= high_memory) {\r\nstruct page *p1;\r\nif (((size_t)addr & PAGE_MASK) !=\r\n((size_t)(addr + len - 1) & PAGE_MASK))\r\ngoto out_copy;\r\np1 = vmalloc_to_page(addr);\r\nif (!p1)\r\ngoto out_copy;\r\naddr = page_address(p1) + ((size_t)addr & ~PAGE_MASK);\r\n}\r\ndma_addr = dma_map_single(&info->pdev->dev, addr, len, dir);\r\nif (dma_mapping_error(&info->pdev->dev, dma_addr)) {\r\ndev_err(&info->pdev->dev,\r\n"Couldn't DMA map a %d byte buffer\n", len);\r\ngoto out_copy;\r\n}\r\nif (is_write) {\r\nomap_set_dma_dest_params(info->dma_ch, 0, OMAP_DMA_AMODE_CONSTANT,\r\ninfo->phys_base, 0, 0);\r\nomap_set_dma_src_params(info->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_addr, 0, 0);\r\nomap_set_dma_transfer_params(info->dma_ch, OMAP_DMA_DATA_TYPE_S32,\r\n0x10, buf_len, OMAP_DMA_SYNC_FRAME,\r\nOMAP24XX_DMA_GPMC, OMAP_DMA_DST_SYNC);\r\n} else {\r\nomap_set_dma_src_params(info->dma_ch, 0, OMAP_DMA_AMODE_CONSTANT,\r\ninfo->phys_base, 0, 0);\r\nomap_set_dma_dest_params(info->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,\r\ndma_addr, 0, 0);\r\nomap_set_dma_transfer_params(info->dma_ch, OMAP_DMA_DATA_TYPE_S32,\r\n0x10, buf_len, OMAP_DMA_SYNC_FRAME,\r\nOMAP24XX_DMA_GPMC, OMAP_DMA_SRC_SYNC);\r\n}\r\nret = gpmc_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x1, len, is_write);\r\nif (ret)\r\ngoto out_copy;\r\ninit_completion(&info->comp);\r\nomap_start_dma(info->dma_ch);\r\nwait_for_completion(&info->comp);\r\ntim = 0;\r\nlimit = (loops_per_jiffy * msecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\nwhile (gpmc_read_status(GPMC_PREFETCH_COUNT) && (tim++ < limit))\r\ncpu_relax();\r\ngpmc_prefetch_reset(info->gpmc_cs);\r\ndma_unmap_single(&info->pdev->dev, dma_addr, len, dir);\r\nreturn 0;\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nis_write == 0 ? omap_read_buf16(mtd, (u_char *) addr, len)\r\n: omap_write_buf16(mtd, (u_char *) addr, len);\r\nelse\r\nis_write == 0 ? omap_read_buf8(mtd, (u_char *) addr, len)\r\n: omap_write_buf8(mtd, (u_char *) addr, len);\r\nreturn 0;\r\n}\r\nstatic void omap_read_buf_dma_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nif (len <= mtd->oobsize)\r\nomap_read_buf_pref(mtd, buf, len);\r\nelse\r\nomap_nand_dma_transfer(mtd, buf, len, 0x0);\r\n}\r\nstatic void omap_write_buf_dma_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nif (len <= mtd->oobsize)\r\nomap_write_buf_pref(mtd, buf, len);\r\nelse\r\nomap_nand_dma_transfer(mtd, (u_char *) buf, len, 0x1);\r\n}\r\nstatic irqreturn_t omap_nand_irq(int this_irq, void *dev)\r\n{\r\nstruct omap_nand_info *info = (struct omap_nand_info *) dev;\r\nu32 bytes;\r\nu32 irq_stat;\r\nirq_stat = gpmc_read_status(GPMC_GET_IRQ_STATUS);\r\nbytes = gpmc_read_status(GPMC_PREFETCH_FIFO_CNT);\r\nbytes = bytes & 0xFFFC;\r\nif (info->iomode == OMAP_NAND_IO_WRITE) {\r\nif (irq_stat & 0x2)\r\ngoto done;\r\nif (info->buf_len && (info->buf_len < bytes))\r\nbytes = info->buf_len;\r\nelse if (!info->buf_len)\r\nbytes = 0;\r\niowrite32_rep(info->nand.IO_ADDR_W,\r\n(u32 *)info->buf, bytes >> 2);\r\ninfo->buf = info->buf + bytes;\r\ninfo->buf_len -= bytes;\r\n} else {\r\nioread32_rep(info->nand.IO_ADDR_R,\r\n(u32 *)info->buf, bytes >> 2);\r\ninfo->buf = info->buf + bytes;\r\nif (irq_stat & 0x2)\r\ngoto done;\r\n}\r\ngpmc_cs_configure(info->gpmc_cs, GPMC_SET_IRQ_STATUS, irq_stat);\r\nreturn IRQ_HANDLED;\r\ndone:\r\ncomplete(&info->comp);\r\ngpmc_cs_configure(info->gpmc_cs, GPMC_ENABLE_IRQ, 0);\r\ngpmc_cs_configure(info->gpmc_cs, GPMC_SET_IRQ_STATUS, irq_stat);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void omap_read_buf_irq_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nint ret = 0;\r\nif (len <= mtd->oobsize) {\r\nomap_read_buf_pref(mtd, buf, len);\r\nreturn;\r\n}\r\ninfo->iomode = OMAP_NAND_IO_READ;\r\ninfo->buf = buf;\r\ninit_completion(&info->comp);\r\nret = gpmc_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX/2, 0x0, len, 0x0);\r\nif (ret)\r\ngoto out_copy;\r\ninfo->buf_len = len;\r\ngpmc_cs_configure(info->gpmc_cs, GPMC_ENABLE_IRQ,\r\n(GPMC_IRQ_FIFOEVENTENABLE | GPMC_IRQ_COUNT_EVENT));\r\nwait_for_completion(&info->comp);\r\ngpmc_prefetch_reset(info->gpmc_cs);\r\nreturn;\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, buf, len);\r\nelse\r\nomap_read_buf8(mtd, buf, len);\r\n}\r\nstatic void omap_write_buf_irq_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nint ret = 0;\r\nunsigned long tim, limit;\r\nif (len <= mtd->oobsize) {\r\nomap_write_buf_pref(mtd, buf, len);\r\nreturn;\r\n}\r\ninfo->iomode = OMAP_NAND_IO_WRITE;\r\ninfo->buf = (u_char *) buf;\r\ninit_completion(&info->comp);\r\nret = gpmc_prefetch_enable(info->gpmc_cs,\r\n(PREFETCH_FIFOTHRESHOLD_MAX * 3) / 8, 0x0, len, 0x1);\r\nif (ret)\r\ngoto out_copy;\r\ninfo->buf_len = len;\r\ngpmc_cs_configure(info->gpmc_cs, GPMC_ENABLE_IRQ,\r\n(GPMC_IRQ_FIFOEVENTENABLE | GPMC_IRQ_COUNT_EVENT));\r\nwait_for_completion(&info->comp);\r\ntim = 0;\r\nlimit = (loops_per_jiffy * msecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\nwhile (gpmc_read_status(GPMC_PREFETCH_COUNT) && (tim++ < limit))\r\ncpu_relax();\r\ngpmc_prefetch_reset(info->gpmc_cs);\r\nreturn;\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_write_buf16(mtd, buf, len);\r\nelse\r\nomap_write_buf8(mtd, buf, len);\r\n}\r\nstatic int omap_verify_buf(struct mtd_info *mtd, const u_char * buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nwhile (len--) {\r\nif (*p++ != cpu_to_le16(readw(info->nand.IO_ADDR_R)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gen_true_ecc(u8 *ecc_buf)\r\n{\r\nu32 tmp = ecc_buf[0] | (ecc_buf[1] << 16) |\r\n((ecc_buf[2] & 0xF0) << 20) | ((ecc_buf[2] & 0x0F) << 8);\r\necc_buf[0] = ~(P64o(tmp) | P64e(tmp) | P32o(tmp) | P32e(tmp) |\r\nP16o(tmp) | P16e(tmp) | P8o(tmp) | P8e(tmp));\r\necc_buf[1] = ~(P1024o(tmp) | P1024e(tmp) | P512o(tmp) | P512e(tmp) |\r\nP256o(tmp) | P256e(tmp) | P128o(tmp) | P128e(tmp));\r\necc_buf[2] = ~(P4o(tmp) | P4e(tmp) | P2o(tmp) | P2e(tmp) | P1o(tmp) |\r\nP1e(tmp) | P2048o(tmp) | P2048e(tmp));\r\n}\r\nstatic int omap_compare_ecc(u8 *ecc_data1,\r\nu8 *ecc_data2,\r\nu8 *page_data)\r\n{\r\nuint i;\r\nu8 tmp0_bit[8], tmp1_bit[8], tmp2_bit[8];\r\nu8 comp0_bit[8], comp1_bit[8], comp2_bit[8];\r\nu8 ecc_bit[24];\r\nu8 ecc_sum = 0;\r\nu8 find_bit = 0;\r\nuint find_byte = 0;\r\nint isEccFF;\r\nisEccFF = ((*(u32 *)ecc_data1 & 0xFFFFFF) == 0xFFFFFF);\r\ngen_true_ecc(ecc_data1);\r\ngen_true_ecc(ecc_data2);\r\nfor (i = 0; i <= 2; i++) {\r\n*(ecc_data1 + i) = ~(*(ecc_data1 + i));\r\n*(ecc_data2 + i) = ~(*(ecc_data2 + i));\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp0_bit[i] = *ecc_data1 % 2;\r\n*ecc_data1 = *ecc_data1 / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp1_bit[i] = *(ecc_data1 + 1) % 2;\r\n*(ecc_data1 + 1) = *(ecc_data1 + 1) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp2_bit[i] = *(ecc_data1 + 2) % 2;\r\n*(ecc_data1 + 2) = *(ecc_data1 + 2) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp0_bit[i] = *ecc_data2 % 2;\r\n*ecc_data2 = *ecc_data2 / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp1_bit[i] = *(ecc_data2 + 1) % 2;\r\n*(ecc_data2 + 1) = *(ecc_data2 + 1) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp2_bit[i] = *(ecc_data2 + 2) % 2;\r\n*(ecc_data2 + 2) = *(ecc_data2 + 2) / 2;\r\n}\r\nfor (i = 0; i < 6; i++)\r\necc_bit[i] = tmp2_bit[i + 2] ^ comp2_bit[i + 2];\r\nfor (i = 0; i < 8; i++)\r\necc_bit[i + 6] = tmp0_bit[i] ^ comp0_bit[i];\r\nfor (i = 0; i < 8; i++)\r\necc_bit[i + 14] = tmp1_bit[i] ^ comp1_bit[i];\r\necc_bit[22] = tmp2_bit[0] ^ comp2_bit[0];\r\necc_bit[23] = tmp2_bit[1] ^ comp2_bit[1];\r\nfor (i = 0; i < 24; i++)\r\necc_sum += ecc_bit[i];\r\nswitch (ecc_sum) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nDEBUG(MTD_DEBUG_LEVEL0, "ECC UNCORRECTED_ERROR 1\n");\r\nreturn -1;\r\ncase 11:\r\nDEBUG(MTD_DEBUG_LEVEL0, "ECC UNCORRECTED_ERROR B\n");\r\nreturn -1;\r\ncase 12:\r\nfind_byte = (ecc_bit[23] << 8) +\r\n(ecc_bit[21] << 7) +\r\n(ecc_bit[19] << 6) +\r\n(ecc_bit[17] << 5) +\r\n(ecc_bit[15] << 4) +\r\n(ecc_bit[13] << 3) +\r\n(ecc_bit[11] << 2) +\r\n(ecc_bit[9] << 1) +\r\necc_bit[7];\r\nfind_bit = (ecc_bit[5] << 2) + (ecc_bit[3] << 1) + ecc_bit[1];\r\nDEBUG(MTD_DEBUG_LEVEL0, "Correcting single bit ECC error at "\r\n"offset: %d, bit: %d\n", find_byte, find_bit);\r\npage_data[find_byte] ^= (1 << find_bit);\r\nreturn 1;\r\ndefault:\r\nif (isEccFF) {\r\nif (ecc_data2[0] == 0 &&\r\necc_data2[1] == 0 &&\r\necc_data2[2] == 0)\r\nreturn 0;\r\n}\r\nDEBUG(MTD_DEBUG_LEVEL0, "UNCORRECTED_ERROR default\n");\r\nreturn -1;\r\n}\r\n}\r\nstatic int omap_correct_data(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nint blockCnt = 0, i = 0, ret = 0;\r\nint stat = 0;\r\nif ((info->nand.ecc.mode == NAND_ECC_HW) &&\r\n(info->nand.ecc.size == 2048))\r\nblockCnt = 4;\r\nelse\r\nblockCnt = 1;\r\nfor (i = 0; i < blockCnt; i++) {\r\nif (memcmp(read_ecc, calc_ecc, 3) != 0) {\r\nret = omap_compare_ecc(read_ecc, calc_ecc, dat);\r\nif (ret < 0)\r\nreturn ret;\r\nstat += ret;\r\n}\r\nread_ecc += 3;\r\ncalc_ecc += 3;\r\ndat += 512;\r\n}\r\nreturn stat;\r\n}\r\nstatic int omap_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nreturn gpmc_calculate_ecc(info->gpmc_cs, dat, ecc_code);\r\n}\r\nstatic void omap_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nunsigned int dev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;\r\ngpmc_enable_hwecc(info->gpmc_cs, mode, dev_width, info->nand.ecc.size);\r\n}\r\nstatic int omap_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nunsigned long timeo = jiffies;\r\nint status = NAND_STATUS_FAIL, state = this->state;\r\nif (state == FL_ERASING)\r\ntimeo += (HZ * 400) / 1000;\r\nelse\r\ntimeo += (HZ * 20) / 1000;\r\ngpmc_nand_write(info->gpmc_cs,\r\nGPMC_NAND_COMMAND, (NAND_CMD_STATUS & 0xFF));\r\nwhile (time_before(jiffies, timeo)) {\r\nstatus = gpmc_nand_read(info->gpmc_cs, GPMC_NAND_DATA);\r\nif (status & NAND_STATUS_READY)\r\nbreak;\r\ncond_resched();\r\n}\r\nreturn status;\r\n}\r\nstatic int omap_dev_ready(struct mtd_info *mtd)\r\n{\r\nunsigned int val = 0;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nval = gpmc_read_status(GPMC_GET_IRQ_STATUS);\r\nif ((val & 0x100) == 0x100) {\r\nval |= 0x100;\r\nval &= ~(0x0);\r\ngpmc_cs_configure(info->gpmc_cs, GPMC_SET_IRQ_STATUS, val);\r\n} else {\r\nunsigned int cnt = 0;\r\nwhile (cnt++ < 0x1FF) {\r\nif ((val & 0x100) == 0x100)\r\nreturn 0;\r\nval = gpmc_read_status(GPMC_GET_IRQ_STATUS);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int __devinit omap_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_nand_info *info;\r\nstruct omap_nand_platform_data *pdata;\r\nint err;\r\nint i, offset;\r\npdata = pdev->dev.platform_data;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "platform data missing\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = kzalloc(sizeof(struct omap_nand_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, info);\r\nspin_lock_init(&info->controller.lock);\r\ninit_waitqueue_head(&info->controller.wq);\r\ninfo->pdev = pdev;\r\ninfo->gpmc_cs = pdata->cs;\r\ninfo->phys_base = pdata->phys_base;\r\ninfo->mtd.priv = &info->nand;\r\ninfo->mtd.name = dev_name(&pdev->dev);\r\ninfo->mtd.owner = THIS_MODULE;\r\ninfo->nand.options = pdata->devsize;\r\ninfo->nand.options |= NAND_SKIP_BBTSCAN;\r\ngpmc_cs_configure(info->gpmc_cs, GPMC_CONFIG_WP, 0);\r\nif (!request_mem_region(info->phys_base, NAND_IO_SIZE,\r\npdev->dev.driver->name)) {\r\nerr = -EBUSY;\r\ngoto out_free_info;\r\n}\r\ninfo->nand.IO_ADDR_R = ioremap(info->phys_base, NAND_IO_SIZE);\r\nif (!info->nand.IO_ADDR_R) {\r\nerr = -ENOMEM;\r\ngoto out_release_mem_region;\r\n}\r\ninfo->nand.controller = &info->controller;\r\ninfo->nand.IO_ADDR_W = info->nand.IO_ADDR_R;\r\ninfo->nand.cmd_ctrl = omap_hwcontrol;\r\nif (pdata->dev_ready) {\r\ninfo->nand.dev_ready = omap_dev_ready;\r\ninfo->nand.chip_delay = 0;\r\n} else {\r\ninfo->nand.waitfunc = omap_wait;\r\ninfo->nand.chip_delay = 50;\r\n}\r\nswitch (pdata->xfer_type) {\r\ncase NAND_OMAP_PREFETCH_POLLED:\r\ninfo->nand.read_buf = omap_read_buf_pref;\r\ninfo->nand.write_buf = omap_write_buf_pref;\r\nbreak;\r\ncase NAND_OMAP_POLLED:\r\nif (info->nand.options & NAND_BUSWIDTH_16) {\r\ninfo->nand.read_buf = omap_read_buf16;\r\ninfo->nand.write_buf = omap_write_buf16;\r\n} else {\r\ninfo->nand.read_buf = omap_read_buf8;\r\ninfo->nand.write_buf = omap_write_buf8;\r\n}\r\nbreak;\r\ncase NAND_OMAP_PREFETCH_DMA:\r\nerr = omap_request_dma(OMAP24XX_DMA_GPMC, "NAND",\r\nomap_nand_dma_cb, &info->comp, &info->dma_ch);\r\nif (err < 0) {\r\ninfo->dma_ch = -1;\r\ndev_err(&pdev->dev, "DMA request failed!\n");\r\ngoto out_release_mem_region;\r\n} else {\r\nomap_set_dma_dest_burst_mode(info->dma_ch,\r\nOMAP_DMA_DATA_BURST_16);\r\nomap_set_dma_src_burst_mode(info->dma_ch,\r\nOMAP_DMA_DATA_BURST_16);\r\ninfo->nand.read_buf = omap_read_buf_dma_pref;\r\ninfo->nand.write_buf = omap_write_buf_dma_pref;\r\n}\r\nbreak;\r\ncase NAND_OMAP_PREFETCH_IRQ:\r\nerr = request_irq(pdata->gpmc_irq,\r\nomap_nand_irq, IRQF_SHARED, "gpmc-nand", info);\r\nif (err) {\r\ndev_err(&pdev->dev, "requesting irq(%d) error:%d",\r\npdata->gpmc_irq, err);\r\ngoto out_release_mem_region;\r\n} else {\r\ninfo->gpmc_irq = pdata->gpmc_irq;\r\ninfo->nand.read_buf = omap_read_buf_irq_pref;\r\ninfo->nand.write_buf = omap_write_buf_irq_pref;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev,\r\n"xfer_type(%d) not supported!\n", pdata->xfer_type);\r\nerr = -EINVAL;\r\ngoto out_release_mem_region;\r\n}\r\ninfo->nand.verify_buf = omap_verify_buf;\r\nif (pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_DEFAULT)\r\ninfo->nand.ecc.mode = NAND_ECC_SOFT;\r\nelse if ((pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW) ||\r\n(pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW_ROMCODE)) {\r\ninfo->nand.ecc.bytes = 3;\r\ninfo->nand.ecc.size = 512;\r\ninfo->nand.ecc.calculate = omap_calculate_ecc;\r\ninfo->nand.ecc.hwctl = omap_enable_hwecc;\r\ninfo->nand.ecc.correct = omap_correct_data;\r\ninfo->nand.ecc.mode = NAND_ECC_HW;\r\n}\r\nif (nand_scan_ident(&info->mtd, 1, NULL)) {\r\ninfo->nand.options ^= NAND_BUSWIDTH_16;\r\nif (nand_scan_ident(&info->mtd, 1, NULL)) {\r\nerr = -ENXIO;\r\ngoto out_release_mem_region;\r\n}\r\n}\r\nif (pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW_ROMCODE) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\noffset = 2;\r\nelse {\r\noffset = 1;\r\ninfo->nand.badblock_pattern = &bb_descrip_flashbased;\r\n}\r\nomap_oobinfo.eccbytes = 3 * (info->mtd.oobsize/16);\r\nfor (i = 0; i < omap_oobinfo.eccbytes; i++)\r\nomap_oobinfo.eccpos[i] = i+offset;\r\nomap_oobinfo.oobfree->offset = offset + omap_oobinfo.eccbytes;\r\nomap_oobinfo.oobfree->length = info->mtd.oobsize -\r\n(offset + omap_oobinfo.eccbytes);\r\ninfo->nand.ecc.layout = &omap_oobinfo;\r\n}\r\nif (nand_scan_tail(&info->mtd)) {\r\nerr = -ENXIO;\r\ngoto out_release_mem_region;\r\n}\r\nerr = parse_mtd_partitions(&info->mtd, part_probes, &info->parts, 0);\r\nif (err > 0)\r\nmtd_device_register(&info->mtd, info->parts, err);\r\nelse if (pdata->parts)\r\nmtd_device_register(&info->mtd, pdata->parts, pdata->nr_parts);\r\nelse\r\nmtd_device_register(&info->mtd, NULL, 0);\r\nplatform_set_drvdata(pdev, &info->mtd);\r\nreturn 0;\r\nout_release_mem_region:\r\nrelease_mem_region(info->phys_base, NAND_IO_SIZE);\r\nout_free_info:\r\nkfree(info);\r\nreturn err;\r\n}\r\nstatic int omap_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (info->dma_ch != -1)\r\nomap_free_dma(info->dma_ch);\r\nif (info->gpmc_irq)\r\nfree_irq(info->gpmc_irq, info);\r\nnand_release(&info->mtd);\r\niounmap(info->nand.IO_ADDR_R);\r\nkfree(&info->mtd);\r\nreturn 0;\r\n}\r\nstatic int __init omap_nand_init(void)\r\n{\r\npr_info("%s driver initializing\n", DRIVER_NAME);\r\nreturn platform_driver_register(&omap_nand_driver);\r\n}\r\nstatic void __exit omap_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&omap_nand_driver);\r\n}
