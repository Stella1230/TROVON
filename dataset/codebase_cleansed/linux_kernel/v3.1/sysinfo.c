static inline int stsi_0(void)\r\n{\r\nint rc = stsi(NULL, 0, 0, 0);\r\nreturn rc == -ENOSYS ? rc : (((unsigned int) rc) >> 28);\r\n}\r\nstatic int stsi_1_1_1(struct sysinfo_1_1_1 *info, char *page, int len)\r\n{\r\nif (stsi(info, 1, 1, 1) == -ENOSYS)\r\nreturn len;\r\nEBCASC(info->manufacturer, sizeof(info->manufacturer));\r\nEBCASC(info->type, sizeof(info->type));\r\nEBCASC(info->model, sizeof(info->model));\r\nEBCASC(info->sequence, sizeof(info->sequence));\r\nEBCASC(info->plant, sizeof(info->plant));\r\nEBCASC(info->model_capacity, sizeof(info->model_capacity));\r\nEBCASC(info->model_perm_cap, sizeof(info->model_perm_cap));\r\nEBCASC(info->model_temp_cap, sizeof(info->model_temp_cap));\r\nlen += sprintf(page + len, "Manufacturer: %-16.16s\n",\r\ninfo->manufacturer);\r\nlen += sprintf(page + len, "Type: %-4.4s\n",\r\ninfo->type);\r\nif (info->model[0] != '\0')\r\nlen += sprintf(page + len,\r\n"Model: %-16.16s %-16.16s\n",\r\ninfo->model_capacity, info->model);\r\nelse\r\nlen += sprintf(page + len, "Model: %-16.16s\n",\r\ninfo->model_capacity);\r\nlen += sprintf(page + len, "Sequence Code: %-16.16s\n",\r\ninfo->sequence);\r\nlen += sprintf(page + len, "Plant: %-4.4s\n",\r\ninfo->plant);\r\nlen += sprintf(page + len, "Model Capacity: %-16.16s %08u\n",\r\ninfo->model_capacity, *(u32 *) info->model_cap_rating);\r\nif (info->model_perm_cap[0] != '\0')\r\nlen += sprintf(page + len,\r\n"Model Perm. Capacity: %-16.16s %08u\n",\r\ninfo->model_perm_cap,\r\n*(u32 *) info->model_perm_cap_rating);\r\nif (info->model_temp_cap[0] != '\0')\r\nlen += sprintf(page + len,\r\n"Model Temp. Capacity: %-16.16s %08u\n",\r\ninfo->model_temp_cap,\r\n*(u32 *) info->model_temp_cap_rating);\r\nif (info->cai) {\r\nlen += sprintf(page + len,\r\n"Capacity Adj. Ind.: %d\n",\r\ninfo->cai);\r\nlen += sprintf(page + len, "Capacity Ch. Reason: %d\n",\r\ninfo->ccr);\r\n}\r\nreturn len;\r\n}\r\nstatic int stsi_15_1_x(struct sysinfo_15_1_x *info, char *page, int len)\r\n{\r\nstatic int max_mnest;\r\nint i, rc;\r\nlen += sprintf(page + len, "\n");\r\nif (!MACHINE_HAS_TOPOLOGY)\r\nreturn len;\r\nif (max_mnest) {\r\nstsi(info, 15, 1, max_mnest);\r\n} else {\r\nfor (max_mnest = 6; max_mnest > 1; max_mnest--) {\r\nrc = stsi(info, 15, 1, max_mnest);\r\nif (rc != -ENOSYS)\r\nbreak;\r\n}\r\n}\r\nlen += sprintf(page + len, "CPU Topology HW: ");\r\nfor (i = 0; i < TOPOLOGY_NR_MAG; i++)\r\nlen += sprintf(page + len, " %d", info->mag[i]);\r\nlen += sprintf(page + len, "\n");\r\n#ifdef CONFIG_SCHED_MC\r\nstore_topology(info);\r\nlen += sprintf(page + len, "CPU Topology SW: ");\r\nfor (i = 0; i < TOPOLOGY_NR_MAG; i++)\r\nlen += sprintf(page + len, " %d", info->mag[i]);\r\nlen += sprintf(page + len, "\n");\r\n#endif\r\nreturn len;\r\n}\r\nstatic int stsi_1_2_2(struct sysinfo_1_2_2 *info, char *page, int len)\r\n{\r\nstruct sysinfo_1_2_2_extension *ext;\r\nint i;\r\nif (stsi(info, 1, 2, 2) == -ENOSYS)\r\nreturn len;\r\next = (struct sysinfo_1_2_2_extension *)\r\n((unsigned long) info + info->acc_offset);\r\nlen += sprintf(page + len, "CPUs Total: %d\n",\r\ninfo->cpus_total);\r\nlen += sprintf(page + len, "CPUs Configured: %d\n",\r\ninfo->cpus_configured);\r\nlen += sprintf(page + len, "CPUs Standby: %d\n",\r\ninfo->cpus_standby);\r\nlen += sprintf(page + len, "CPUs Reserved: %d\n",\r\ninfo->cpus_reserved);\r\nif (info->format == 1) {\r\nlen += sprintf(page + len, "Capability: %u %u\n",\r\ninfo->capability, ext->alt_capability);\r\nfor (i = 2; i <= info->cpus_total; i++)\r\nlen += sprintf(page + len,\r\n"Adjustment %02d-way: %u %u\n",\r\ni, info->adjustment[i-2],\r\next->alt_adjustment[i-2]);\r\n} else {\r\nlen += sprintf(page + len, "Capability: %u\n",\r\ninfo->capability);\r\nfor (i = 2; i <= info->cpus_total; i++)\r\nlen += sprintf(page + len,\r\n"Adjustment %02d-way: %u\n",\r\ni, info->adjustment[i-2]);\r\n}\r\nif (info->secondary_capability != 0)\r\nlen += sprintf(page + len, "Secondary Capability: %d\n",\r\ninfo->secondary_capability);\r\nreturn len;\r\n}\r\nstatic int stsi_2_2_2(struct sysinfo_2_2_2 *info, char *page, int len)\r\n{\r\nif (stsi(info, 2, 2, 2) == -ENOSYS)\r\nreturn len;\r\nEBCASC(info->name, sizeof(info->name));\r\nlen += sprintf(page + len, "\n");\r\nlen += sprintf(page + len, "LPAR Number: %d\n",\r\ninfo->lpar_number);\r\nlen += sprintf(page + len, "LPAR Characteristics: ");\r\nif (info->characteristics & LPAR_CHAR_DEDICATED)\r\nlen += sprintf(page + len, "Dedicated ");\r\nif (info->characteristics & LPAR_CHAR_SHARED)\r\nlen += sprintf(page + len, "Shared ");\r\nif (info->characteristics & LPAR_CHAR_LIMITED)\r\nlen += sprintf(page + len, "Limited ");\r\nlen += sprintf(page + len, "\n");\r\nlen += sprintf(page + len, "LPAR Name: %-8.8s\n",\r\ninfo->name);\r\nlen += sprintf(page + len, "LPAR Adjustment: %d\n",\r\ninfo->caf);\r\nlen += sprintf(page + len, "LPAR CPUs Total: %d\n",\r\ninfo->cpus_total);\r\nlen += sprintf(page + len, "LPAR CPUs Configured: %d\n",\r\ninfo->cpus_configured);\r\nlen += sprintf(page + len, "LPAR CPUs Standby: %d\n",\r\ninfo->cpus_standby);\r\nlen += sprintf(page + len, "LPAR CPUs Reserved: %d\n",\r\ninfo->cpus_reserved);\r\nlen += sprintf(page + len, "LPAR CPUs Dedicated: %d\n",\r\ninfo->cpus_dedicated);\r\nlen += sprintf(page + len, "LPAR CPUs Shared: %d\n",\r\ninfo->cpus_shared);\r\nreturn len;\r\n}\r\nstatic int stsi_3_2_2(struct sysinfo_3_2_2 *info, char *page, int len)\r\n{\r\nint i;\r\nif (stsi(info, 3, 2, 2) == -ENOSYS)\r\nreturn len;\r\nfor (i = 0; i < info->count; i++) {\r\nEBCASC(info->vm[i].name, sizeof(info->vm[i].name));\r\nEBCASC(info->vm[i].cpi, sizeof(info->vm[i].cpi));\r\nlen += sprintf(page + len, "\n");\r\nlen += sprintf(page + len, "VM%02d Name: %-8.8s\n",\r\ni, info->vm[i].name);\r\nlen += sprintf(page + len, "VM%02d Control Program: %-16.16s\n",\r\ni, info->vm[i].cpi);\r\nlen += sprintf(page + len, "VM%02d Adjustment: %d\n",\r\ni, info->vm[i].caf);\r\nlen += sprintf(page + len, "VM%02d CPUs Total: %d\n",\r\ni, info->vm[i].cpus_total);\r\nlen += sprintf(page + len, "VM%02d CPUs Configured: %d\n",\r\ni, info->vm[i].cpus_configured);\r\nlen += sprintf(page + len, "VM%02d CPUs Standby: %d\n",\r\ni, info->vm[i].cpus_standby);\r\nlen += sprintf(page + len, "VM%02d CPUs Reserved: %d\n",\r\ni, info->vm[i].cpus_reserved);\r\n}\r\nreturn len;\r\n}\r\nstatic int proc_read_sysinfo(char *page, char **start,\r\noff_t off, int count,\r\nint *eof, void *data)\r\n{\r\nunsigned long info = get_zeroed_page(GFP_KERNEL);\r\nint level, len;\r\nif (!info)\r\nreturn 0;\r\nlen = 0;\r\nlevel = stsi_0();\r\nif (level >= 1)\r\nlen = stsi_1_1_1((struct sysinfo_1_1_1 *) info, page, len);\r\nif (level >= 1)\r\nlen = stsi_15_1_x((struct sysinfo_15_1_x *) info, page, len);\r\nif (level >= 1)\r\nlen = stsi_1_2_2((struct sysinfo_1_2_2 *) info, page, len);\r\nif (level >= 2)\r\nlen = stsi_2_2_2((struct sysinfo_2_2_2 *) info, page, len);\r\nif (level >= 3)\r\nlen = stsi_3_2_2((struct sysinfo_3_2_2 *) info, page, len);\r\nfree_page(info);\r\nreturn len;\r\n}\r\nstatic __init int create_proc_sysinfo(void)\r\n{\r\ncreate_proc_read_entry("sysinfo", 0444, NULL,\r\nproc_read_sysinfo, NULL);\r\nreturn 0;\r\n}\r\nint register_service_level(struct service_level *slr)\r\n{\r\nstruct service_level *ptr;\r\ndown_write(&service_level_sem);\r\nlist_for_each_entry(ptr, &service_level_list, list)\r\nif (ptr == slr) {\r\nup_write(&service_level_sem);\r\nreturn -EEXIST;\r\n}\r\nlist_add_tail(&slr->list, &service_level_list);\r\nup_write(&service_level_sem);\r\nreturn 0;\r\n}\r\nint unregister_service_level(struct service_level *slr)\r\n{\r\nstruct service_level *ptr, *next;\r\nint rc = -ENOENT;\r\ndown_write(&service_level_sem);\r\nlist_for_each_entry_safe(ptr, next, &service_level_list, list) {\r\nif (ptr != slr)\r\ncontinue;\r\nlist_del(&ptr->list);\r\nrc = 0;\r\nbreak;\r\n}\r\nup_write(&service_level_sem);\r\nreturn rc;\r\n}\r\nstatic void *service_level_start(struct seq_file *m, loff_t *pos)\r\n{\r\ndown_read(&service_level_sem);\r\nreturn seq_list_start(&service_level_list, *pos);\r\n}\r\nstatic void *service_level_next(struct seq_file *m, void *p, loff_t *pos)\r\n{\r\nreturn seq_list_next(p, &service_level_list, pos);\r\n}\r\nstatic void service_level_stop(struct seq_file *m, void *p)\r\n{\r\nup_read(&service_level_sem);\r\n}\r\nstatic int service_level_show(struct seq_file *m, void *p)\r\n{\r\nstruct service_level *slr;\r\nslr = list_entry(p, struct service_level, list);\r\nslr->seq_print(m, slr);\r\nreturn 0;\r\n}\r\nstatic int service_level_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &service_level_seq_ops);\r\n}\r\nstatic void service_level_vm_print(struct seq_file *m,\r\nstruct service_level *slr)\r\n{\r\nchar *query_buffer, *str;\r\nquery_buffer = kmalloc(1024, GFP_KERNEL | GFP_DMA);\r\nif (!query_buffer)\r\nreturn;\r\ncpcmd("QUERY CPLEVEL", query_buffer, 1024, NULL);\r\nstr = strchr(query_buffer, '\n');\r\nif (str)\r\n*str = 0;\r\nseq_printf(m, "VM: %s\n", query_buffer);\r\nkfree(query_buffer);\r\n}\r\nstatic __init int create_proc_service_level(void)\r\n{\r\nproc_create("service_levels", 0, NULL, &service_level_ops);\r\nif (MACHINE_IS_VM)\r\nregister_service_level(&service_level_vm);\r\nreturn 0;\r\n}\r\nint get_cpu_capability(unsigned int *capability)\r\n{\r\nstruct sysinfo_1_2_2 *info;\r\nint rc;\r\ninfo = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nrc = stsi(info, 1, 2, 2);\r\nif (rc == -ENOSYS)\r\ngoto out;\r\nrc = 0;\r\n*capability = info->capability;\r\nout:\r\nfree_page((unsigned long) info);\r\nreturn rc;\r\n}\r\nvoid s390_adjust_jiffies(void)\r\n{\r\nstruct sysinfo_1_2_2 *info;\r\nconst unsigned int fmil = 0x4b189680;\r\nFP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);\r\nFP_DECL_EX;\r\nunsigned int capability;\r\ninfo = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!info)\r\nreturn;\r\nif (stsi(info, 1, 2, 2) != -ENOSYS) {\r\nFP_UNPACK_SP(SA, &fmil);\r\nif ((info->capability >> 23) == 0)\r\nFP_FROM_INT_S(SB, info->capability, 32, int);\r\nelse\r\nFP_UNPACK_SP(SB, &info->capability);\r\nFP_DIV_S(SR, SA, SB);\r\nFP_TO_INT_S(capability, SR, 32, 0);\r\n} else\r\ncapability = 42;\r\nloops_per_jiffy = capability * (500000/HZ);\r\nfree_page((unsigned long) info);\r\n}\r\nvoid __cpuinit calibrate_delay(void)\r\n{\r\ns390_adjust_jiffies();\r\nprintk(KERN_DEBUG "Calibrating delay loop (skipped)... "\r\n"%lu.%02lu BogoMIPS preset\n", loops_per_jiffy/(500000/HZ),\r\n(loops_per_jiffy/(5000/HZ)) % 100);\r\n}
