static inline unsigned long sh_tmu_read(struct sh_tmu_priv *p, int reg_nr)\r\n{\r\nstruct sh_timer_config *cfg = p->pdev->dev.platform_data;\r\nvoid __iomem *base = p->mapbase;\r\nunsigned long offs;\r\nif (reg_nr == TSTR)\r\nreturn ioread8(base - cfg->channel_offset);\r\noffs = reg_nr << 2;\r\nif (reg_nr == TCR)\r\nreturn ioread16(base + offs);\r\nelse\r\nreturn ioread32(base + offs);\r\n}\r\nstatic inline void sh_tmu_write(struct sh_tmu_priv *p, int reg_nr,\r\nunsigned long value)\r\n{\r\nstruct sh_timer_config *cfg = p->pdev->dev.platform_data;\r\nvoid __iomem *base = p->mapbase;\r\nunsigned long offs;\r\nif (reg_nr == TSTR) {\r\niowrite8(value, base - cfg->channel_offset);\r\nreturn;\r\n}\r\noffs = reg_nr << 2;\r\nif (reg_nr == TCR)\r\niowrite16(value, base + offs);\r\nelse\r\niowrite32(value, base + offs);\r\n}\r\nstatic void sh_tmu_start_stop_ch(struct sh_tmu_priv *p, int start)\r\n{\r\nstruct sh_timer_config *cfg = p->pdev->dev.platform_data;\r\nunsigned long flags, value;\r\nspin_lock_irqsave(&sh_tmu_lock, flags);\r\nvalue = sh_tmu_read(p, TSTR);\r\nif (start)\r\nvalue |= 1 << cfg->timer_bit;\r\nelse\r\nvalue &= ~(1 << cfg->timer_bit);\r\nsh_tmu_write(p, TSTR, value);\r\nspin_unlock_irqrestore(&sh_tmu_lock, flags);\r\n}\r\nstatic int sh_tmu_enable(struct sh_tmu_priv *p)\r\n{\r\nint ret;\r\nret = clk_enable(p->clk);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "cannot enable clock\n");\r\nreturn ret;\r\n}\r\nsh_tmu_start_stop_ch(p, 0);\r\nsh_tmu_write(p, TCOR, 0xffffffff);\r\nsh_tmu_write(p, TCNT, 0xffffffff);\r\np->rate = clk_get_rate(p->clk) / 4;\r\nsh_tmu_write(p, TCR, 0x0000);\r\nsh_tmu_start_stop_ch(p, 1);\r\nreturn 0;\r\n}\r\nstatic void sh_tmu_disable(struct sh_tmu_priv *p)\r\n{\r\nsh_tmu_start_stop_ch(p, 0);\r\nsh_tmu_write(p, TCR, 0x0000);\r\nclk_disable(p->clk);\r\n}\r\nstatic void sh_tmu_set_next(struct sh_tmu_priv *p, unsigned long delta,\r\nint periodic)\r\n{\r\nsh_tmu_start_stop_ch(p, 0);\r\nsh_tmu_read(p, TCR);\r\nsh_tmu_write(p, TCR, 0x0020);\r\nif (periodic)\r\nsh_tmu_write(p, TCOR, delta);\r\nelse\r\nsh_tmu_write(p, TCOR, 0xffffffff);\r\nsh_tmu_write(p, TCNT, delta);\r\nsh_tmu_start_stop_ch(p, 1);\r\n}\r\nstatic irqreturn_t sh_tmu_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sh_tmu_priv *p = dev_id;\r\nif (p->ced.mode == CLOCK_EVT_MODE_ONESHOT)\r\nsh_tmu_write(p, TCR, 0x0000);\r\nelse\r\nsh_tmu_write(p, TCR, 0x0020);\r\np->ced.event_handler(&p->ced);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct sh_tmu_priv *cs_to_sh_tmu(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct sh_tmu_priv, cs);\r\n}\r\nstatic cycle_t sh_tmu_clocksource_read(struct clocksource *cs)\r\n{\r\nstruct sh_tmu_priv *p = cs_to_sh_tmu(cs);\r\nreturn sh_tmu_read(p, TCNT) ^ 0xffffffff;\r\n}\r\nstatic int sh_tmu_clocksource_enable(struct clocksource *cs)\r\n{\r\nstruct sh_tmu_priv *p = cs_to_sh_tmu(cs);\r\nint ret;\r\nret = sh_tmu_enable(p);\r\nif (!ret)\r\n__clocksource_updatefreq_hz(cs, p->rate);\r\nreturn ret;\r\n}\r\nstatic void sh_tmu_clocksource_disable(struct clocksource *cs)\r\n{\r\nsh_tmu_disable(cs_to_sh_tmu(cs));\r\n}\r\nstatic int sh_tmu_register_clocksource(struct sh_tmu_priv *p,\r\nchar *name, unsigned long rating)\r\n{\r\nstruct clocksource *cs = &p->cs;\r\ncs->name = name;\r\ncs->rating = rating;\r\ncs->read = sh_tmu_clocksource_read;\r\ncs->enable = sh_tmu_clocksource_enable;\r\ncs->disable = sh_tmu_clocksource_disable;\r\ncs->mask = CLOCKSOURCE_MASK(32);\r\ncs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\ndev_info(&p->pdev->dev, "used as clock source\n");\r\nclocksource_register_hz(cs, 1);\r\nreturn 0;\r\n}\r\nstatic struct sh_tmu_priv *ced_to_sh_tmu(struct clock_event_device *ced)\r\n{\r\nreturn container_of(ced, struct sh_tmu_priv, ced);\r\n}\r\nstatic void sh_tmu_clock_event_start(struct sh_tmu_priv *p, int periodic)\r\n{\r\nstruct clock_event_device *ced = &p->ced;\r\nsh_tmu_enable(p);\r\nced->shift = 32;\r\nced->mult = div_sc(p->rate, NSEC_PER_SEC, ced->shift);\r\nced->max_delta_ns = clockevent_delta2ns(0xffffffff, ced);\r\nced->min_delta_ns = 5000;\r\nif (periodic) {\r\np->periodic = (p->rate + HZ/2) / HZ;\r\nsh_tmu_set_next(p, p->periodic, 1);\r\n}\r\n}\r\nstatic void sh_tmu_clock_event_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct sh_tmu_priv *p = ced_to_sh_tmu(ced);\r\nint disabled = 0;\r\nswitch (ced->mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nsh_tmu_disable(p);\r\ndisabled = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\ndev_info(&p->pdev->dev, "used for periodic clock events\n");\r\nsh_tmu_clock_event_start(p, 1);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\ndev_info(&p->pdev->dev, "used for oneshot clock events\n");\r\nsh_tmu_clock_event_start(p, 0);\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\nif (!disabled)\r\nsh_tmu_disable(p);\r\nbreak;\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int sh_tmu_clock_event_next(unsigned long delta,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct sh_tmu_priv *p = ced_to_sh_tmu(ced);\r\nBUG_ON(ced->mode != CLOCK_EVT_MODE_ONESHOT);\r\nsh_tmu_set_next(p, delta, 0);\r\nreturn 0;\r\n}\r\nstatic void sh_tmu_register_clockevent(struct sh_tmu_priv *p,\r\nchar *name, unsigned long rating)\r\n{\r\nstruct clock_event_device *ced = &p->ced;\r\nint ret;\r\nmemset(ced, 0, sizeof(*ced));\r\nced->name = name;\r\nced->features = CLOCK_EVT_FEAT_PERIODIC;\r\nced->features |= CLOCK_EVT_FEAT_ONESHOT;\r\nced->rating = rating;\r\nced->cpumask = cpumask_of(0);\r\nced->set_next_event = sh_tmu_clock_event_next;\r\nced->set_mode = sh_tmu_clock_event_mode;\r\ndev_info(&p->pdev->dev, "used for clock events\n");\r\nclockevents_register_device(ced);\r\nret = setup_irq(p->irqaction.irq, &p->irqaction);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "failed to request irq %d\n",\r\np->irqaction.irq);\r\nreturn;\r\n}\r\n}\r\nstatic int sh_tmu_register(struct sh_tmu_priv *p, char *name,\r\nunsigned long clockevent_rating,\r\nunsigned long clocksource_rating)\r\n{\r\nif (clockevent_rating)\r\nsh_tmu_register_clockevent(p, name, clockevent_rating);\r\nelse if (clocksource_rating)\r\nsh_tmu_register_clocksource(p, name, clocksource_rating);\r\nreturn 0;\r\n}\r\nstatic int sh_tmu_setup(struct sh_tmu_priv *p, struct platform_device *pdev)\r\n{\r\nstruct sh_timer_config *cfg = pdev->dev.platform_data;\r\nstruct resource *res;\r\nint irq, ret;\r\nret = -ENXIO;\r\nmemset(p, 0, sizeof(*p));\r\np->pdev = pdev;\r\nif (!cfg) {\r\ndev_err(&p->pdev->dev, "missing platform data\n");\r\ngoto err0;\r\n}\r\nplatform_set_drvdata(pdev, p);\r\nres = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&p->pdev->dev, "failed to get I/O memory\n");\r\ngoto err0;\r\n}\r\nirq = platform_get_irq(p->pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&p->pdev->dev, "failed to get irq\n");\r\ngoto err0;\r\n}\r\np->mapbase = ioremap_nocache(res->start, resource_size(res));\r\nif (p->mapbase == NULL) {\r\ndev_err(&p->pdev->dev, "failed to remap I/O memory\n");\r\ngoto err0;\r\n}\r\np->irqaction.name = dev_name(&p->pdev->dev);\r\np->irqaction.handler = sh_tmu_interrupt;\r\np->irqaction.dev_id = p;\r\np->irqaction.irq = irq;\r\np->irqaction.flags = IRQF_DISABLED | IRQF_TIMER | \\r\nIRQF_IRQPOLL | IRQF_NOBALANCING;\r\np->clk = clk_get(&p->pdev->dev, "tmu_fck");\r\nif (IS_ERR(p->clk)) {\r\ndev_err(&p->pdev->dev, "cannot get clock\n");\r\nret = PTR_ERR(p->clk);\r\ngoto err1;\r\n}\r\nreturn sh_tmu_register(p, (char *)dev_name(&p->pdev->dev),\r\ncfg->clockevent_rating,\r\ncfg->clocksource_rating);\r\nerr1:\r\niounmap(p->mapbase);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int __devinit sh_tmu_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_tmu_priv *p = platform_get_drvdata(pdev);\r\nint ret;\r\nif (p) {\r\ndev_info(&pdev->dev, "kept as earlytimer\n");\r\nreturn 0;\r\n}\r\np = kmalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\nret = sh_tmu_setup(p, pdev);\r\nif (ret) {\r\nkfree(p);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devexit sh_tmu_remove(struct platform_device *pdev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __init sh_tmu_init(void)\r\n{\r\nreturn platform_driver_register(&sh_tmu_device_driver);\r\n}\r\nstatic void __exit sh_tmu_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_tmu_device_driver);\r\n}
