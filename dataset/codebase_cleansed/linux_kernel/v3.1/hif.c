static struct hif_device *ath6kl_alloc_hifdev(struct sdio_func *func)\r\n{\r\nstruct hif_device *hifdevice;\r\nhifdevice = kzalloc(sizeof(struct hif_device), GFP_KERNEL);\r\n#if HIF_USE_DMA_BOUNCE_BUFFER\r\nhifdevice->dma_buffer = kmalloc(HIF_DMA_BUFFER_SIZE, GFP_KERNEL);\r\n#endif\r\nhifdevice->func = func;\r\nhifdevice->powerConfig = HIF_DEVICE_POWER_UP;\r\nsdio_set_drvdata(func, hifdevice);\r\nreturn hifdevice;\r\n}\r\nstatic struct hif_device *ath6kl_get_hifdev(struct sdio_func *func)\r\n{\r\nreturn (struct hif_device *) sdio_get_drvdata(func);\r\n}\r\nstatic int ath6kl_hifdev_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nint ret;\r\nstruct hif_device *device;\r\nint count;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE,\r\n("ath6kl: Function: 0x%X, Vendor ID: 0x%X, "\r\n"Device ID: 0x%X, block size: 0x%X/0x%X\n",\r\nfunc->num, func->vendor, func->device,\r\nfunc->max_blksize, func->cur_blksize));\r\nath6kl_alloc_hifdev(func);\r\ndevice = ath6kl_get_hifdev(func);\r\ndevice->id = id;\r\ndevice->is_disabled = true;\r\nspin_lock_init(&device->lock);\r\nspin_lock_init(&device->asynclock);\r\nDL_LIST_INIT(&device->ScatterReqHead);\r\nif (!nohifscattersupport)\r\ndevice->scatter_enabled = true;\r\nA_MEMZERO(device->busRequest, sizeof(device->busRequest));\r\nfor (count = 0; count < BUS_REQUEST_MAX_NUM; count++) {\r\nsema_init(&device->busRequest[count].sem_req, 0);\r\nhifFreeBusRequest(device, &device->busRequest[count]);\r\n}\r\nsema_init(&device->sem_async, 0);\r\nret = hifEnableFunc(device, func);\r\nreturn ret;\r\n}\r\nstatic void ath6kl_hifdev_remove(struct sdio_func *func)\r\n{\r\nint status = 0;\r\nstruct hif_device *device;\r\ndevice = ath6kl_get_hifdev(func);\r\nif (device->claimedContext != NULL)\r\nstatus = osdrvCallbacks.\r\ndeviceRemovedHandler(device->claimedContext, device);\r\nif (device->is_disabled)\r\ndevice->is_disabled = false;\r\nelse\r\nstatus = hifDisableFunc(device, func);\r\nCleanupHIFScatterResources(device);\r\ndelHifDevice(device);\r\n}\r\nstatic int ath6kl_hifdev_suspend(struct device *dev)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(dev);\r\nint status = 0;\r\nstruct hif_device *device;\r\ndevice = ath6kl_get_hifdev(func);\r\nif (device && device->claimedContext &&\r\nosdrvCallbacks.deviceSuspendHandler) {\r\ndevice->is_suspend = true;\r\nstatus = osdrvCallbacks.\r\ndeviceSuspendHandler(device->claimedContext);\r\nif (status)\r\ndevice->is_suspend = false;\r\n}\r\nCleanupHIFScatterResources(device);\r\nswitch (status) {\r\ncase 0:\r\nreturn 0;\r\ncase A_EBUSY:\r\nreturn -EBUSY;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic int ath6kl_hifdev_resume(struct device *dev)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(dev);\r\nint status = 0;\r\nstruct hif_device *device;\r\ndevice = ath6kl_get_hifdev(func);\r\nif (device && device->claimedContext &&\r\nosdrvCallbacks.deviceSuspendHandler) {\r\nstatus = osdrvCallbacks.\r\ndeviceResumeHandler(device->claimedContext);\r\nif (status == 0)\r\ndevice->is_suspend = false;\r\n}\r\nreturn status;\r\n}\r\nint HIFInit(OSDRV_CALLBACKS *callbacks)\r\n{\r\nint r;\r\nAR_DEBUG_ASSERT(callbacks != NULL);\r\nA_REGISTER_MODULE_DEBUG_INFO(hif);\r\nosdrvCallbacks = *callbacks;\r\nregistered = 1;\r\nr = sdio_register_driver(&ath6kl_hifdev_driver);\r\nif (r < 0)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int\r\n__HIFReadWrite(struct hif_device *device,\r\nu32 address,\r\nu8 *buffer,\r\nu32 length,\r\nu32 request,\r\nvoid *context)\r\n{\r\nu8 opcode;\r\nint status = 0;\r\nint ret;\r\nu8 *tbuffer;\r\nbool bounced = false;\r\nAR_DEBUG_ASSERT(device != NULL);\r\nAR_DEBUG_ASSERT(device->func != NULL);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: Device: 0x%p, buffer:0x%p (addr:0x%X)\n",\r\ndevice, buffer, address));\r\ndo {\r\nif (request & HIF_EXTENDED_IO) {\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR,\r\n("AR6000: Invalid command type: 0x%08x\n", request));\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nif (request & HIF_BLOCK_BASIS) {\r\nlength = (length / HIF_MBOX_BLOCK_SIZE) * HIF_MBOX_BLOCK_SIZE;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE,\r\n("AR6000: Block mode (BlockLen: %d)\n",\r\nlength));\r\n} else if (request & HIF_BYTE_BASIS) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE,\r\n("AR6000: Byte mode (BlockLen: %d)\n",\r\nlength));\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR,\r\n("AR6000: Invalid data mode: 0x%08x\n", request));\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\n#if 0\r\nif (length & 0x3) {\r\nA_PRINTF(KERN_ALERT"AR6000: HIF (%s) is not a multiple of 4 bytes, addr:0x%X, len:%d\n",\r\nrequest & HIF_WRITE ? "write":"read", address, length);\r\n}\r\n#endif\r\nif (request & HIF_WRITE) {\r\nif ((address >= HIF_MBOX_START_ADDR(0)) &&\r\n(address <= HIF_MBOX_END_ADDR(3)))\r\n{\r\nAR_DEBUG_ASSERT(length <= HIF_MBOX_WIDTH);\r\naddress += (HIF_MBOX_WIDTH - length);\r\n}\r\n}\r\nif (request & HIF_FIXED_ADDRESS) {\r\nopcode = CMD53_FIXED_ADDRESS;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: Address mode: Fixed 0x%X\n", address));\r\n} else if (request & HIF_INCREMENTAL_ADDRESS) {\r\nopcode = CMD53_INCR_ADDRESS;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: Address mode: Incremental 0x%X\n", address));\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR,\r\n("AR6000: Invalid address mode: 0x%08x\n", request));\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nif (request & HIF_WRITE) {\r\n#if HIF_USE_DMA_BOUNCE_BUFFER\r\nif (BUFFER_NEEDS_BOUNCE(buffer)) {\r\nAR_DEBUG_ASSERT(device->dma_buffer != NULL);\r\ntbuffer = device->dma_buffer;\r\nAR_DEBUG_ASSERT(length <= HIF_DMA_BUFFER_SIZE);\r\nmemcpy(tbuffer, buffer, length);\r\nbounced = true;\r\n} else {\r\ntbuffer = buffer;\r\n}\r\n#else\r\ntbuffer = buffer;\r\n#endif\r\nif (opcode == CMD53_FIXED_ADDRESS) {\r\nret = sdio_writesb(device->func, address, tbuffer, length);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: writesb ret=%d address: 0x%X, len: %d, 0x%X\n",\r\nret, address, length, *(int *)tbuffer));\r\n} else {\r\nret = sdio_memcpy_toio(device->func, address, tbuffer, length);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: writeio ret=%d address: 0x%X, len: %d, 0x%X\n",\r\nret, address, length, *(int *)tbuffer));\r\n}\r\n} else if (request & HIF_READ) {\r\n#if HIF_USE_DMA_BOUNCE_BUFFER\r\nif (BUFFER_NEEDS_BOUNCE(buffer)) {\r\nAR_DEBUG_ASSERT(device->dma_buffer != NULL);\r\nAR_DEBUG_ASSERT(length <= HIF_DMA_BUFFER_SIZE);\r\ntbuffer = device->dma_buffer;\r\nbounced = true;\r\n} else {\r\ntbuffer = buffer;\r\n}\r\n#else\r\ntbuffer = buffer;\r\n#endif\r\nif (opcode == CMD53_FIXED_ADDRESS) {\r\nret = sdio_readsb(device->func, tbuffer, address, length);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: readsb ret=%d address: 0x%X, len: %d, 0x%X\n",\r\nret, address, length, *(int *)tbuffer));\r\n} else {\r\nret = sdio_memcpy_fromio(device->func, tbuffer, address, length);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: readio ret=%d address: 0x%X, len: %d, 0x%X\n",\r\nret, address, length, *(int *)tbuffer));\r\n}\r\n#if HIF_USE_DMA_BOUNCE_BUFFER\r\nif (bounced) {\r\nmemcpy(buffer, tbuffer, length);\r\n}\r\n#endif\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR,\r\n("AR6000: Invalid direction: 0x%08x\n", request));\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nif (ret) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR,\r\n("AR6000: SDIO bus operation failed! MMC stack returned : %d \n", ret));\r\nstatus = A_ERROR;\r\n}\r\n} while (false);\r\nreturn status;\r\n}\r\nvoid AddToAsyncList(struct hif_device *device, BUS_REQUEST *busrequest)\r\n{\r\nunsigned long flags;\r\nBUS_REQUEST *async;\r\nBUS_REQUEST *active;\r\nspin_lock_irqsave(&device->asynclock, flags);\r\nactive = device->asyncreq;\r\nif (active == NULL) {\r\ndevice->asyncreq = busrequest;\r\ndevice->asyncreq->inusenext = NULL;\r\n} else {\r\nfor (async = device->asyncreq;\r\nasync != NULL;\r\nasync = async->inusenext) {\r\nactive = async;\r\n}\r\nactive->inusenext = busrequest;\r\nbusrequest->inusenext = NULL;\r\n}\r\nspin_unlock_irqrestore(&device->asynclock, flags);\r\n}\r\nint\r\nHIFReadWrite(struct hif_device *device,\r\nu32 address,\r\nu8 *buffer,\r\nu32 length,\r\nu32 request,\r\nvoid *context)\r\n{\r\nint status = 0;\r\nBUS_REQUEST *busrequest;\r\nAR_DEBUG_ASSERT(device != NULL);\r\nAR_DEBUG_ASSERT(device->func != NULL);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: Device: %p addr:0x%X\n", device,address));\r\ndo {\r\nif ((request & HIF_ASYNCHRONOUS) || (request & HIF_SYNCHRONOUS)){\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: Execution mode: %s\n",\r\n(request & HIF_ASYNCHRONOUS)?"Async":"Synch"));\r\nbusrequest = hifAllocateBusRequest(device);\r\nif (busrequest == NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR,\r\n("AR6000: no async bus requests available (%s, addr:0x%X, len:%d) \n",\r\nrequest & HIF_READ ? "READ":"WRITE", address, length));\r\nreturn A_ERROR;\r\n}\r\nbusrequest->address = address;\r\nbusrequest->buffer = buffer;\r\nbusrequest->length = length;\r\nbusrequest->request = request;\r\nbusrequest->context = context;\r\nAddToAsyncList(device, busrequest);\r\nif (request & HIF_SYNCHRONOUS) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: queued sync req: 0x%lX\n", (unsigned long)busrequest));\r\nup(&device->sem_async);\r\nif (down_interruptible(&busrequest->sem_req) != 0) {\r\nreturn A_ERROR;\r\n} else {\r\nint status = busrequest->status;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: sync return freeing 0x%lX: 0x%X\n",\r\n(unsigned long)busrequest, busrequest->status));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: freeing req: 0x%X\n", (unsigned int)request));\r\nhifFreeBusRequest(device, busrequest);\r\nreturn status;\r\n}\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: queued async req: 0x%lX\n", (unsigned long)busrequest));\r\nup(&device->sem_async);\r\nreturn A_PENDING;\r\n}\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR,\r\n("AR6000: Invalid execution mode: 0x%08x\n", (unsigned int)request));\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\n} while(0);\r\nreturn status;\r\n}\r\nstatic int async_task(void *param)\r\n{\r\nstruct hif_device *device;\r\nBUS_REQUEST *request;\r\nint status;\r\nunsigned long flags;\r\ndevice = (struct hif_device *)param;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: async task\n"));\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile(!device->async_shutdown) {\r\nif (down_interruptible(&device->sem_async) != 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: async task interrupted\n"));\r\nbreak;\r\n}\r\nif (device->async_shutdown) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: async task stopping\n"));\r\nbreak;\r\n}\r\nsdio_claim_host(device->func);\r\nspin_lock_irqsave(&device->asynclock, flags);\r\nwhile (device->asyncreq != NULL) {\r\nrequest = device->asyncreq;\r\nif (request->inusenext != NULL) {\r\ndevice->asyncreq = request->inusenext;\r\n} else {\r\ndevice->asyncreq = NULL;\r\n}\r\nspin_unlock_irqrestore(&device->asynclock, flags);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: async_task processing req: 0x%lX\n", (unsigned long)request));\r\nif (request->pScatterReq != NULL) {\r\nA_ASSERT(device->scatter_enabled);\r\nstatus = DoHifReadWriteScatter(device,request);\r\n} else {\r\nstatus = __HIFReadWrite(device, request->address, request->buffer,\r\nrequest->length, request->request & ~HIF_SYNCHRONOUS, NULL);\r\nif (request->request & HIF_ASYNCHRONOUS) {\r\nvoid *context = request->context;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: async_task freeing req: 0x%lX\n", (unsigned long)request));\r\nhifFreeBusRequest(device, request);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: async_task completion routine req: 0x%lX\n", (unsigned long)request));\r\ndevice->htcCallbacks.rwCompletionHandler(context, status);\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: async_task upping req: 0x%lX\n", (unsigned long)request));\r\nrequest->status = status;\r\nup(&request->sem_req);\r\n}\r\n}\r\nspin_lock_irqsave(&device->asynclock, flags);\r\n}\r\nspin_unlock_irqrestore(&device->asynclock, flags);\r\nsdio_release_host(device->func);\r\n}\r\ncomplete_and_exit(&device->async_completion, 0);\r\nreturn 0;\r\n}\r\nstatic s32 IssueSDCommand(struct hif_device *device, u32 opcode, u32 arg, u32 flags, u32 *resp)\r\n{\r\nstruct mmc_command cmd;\r\ns32 err;\r\nstruct mmc_host *host;\r\nstruct sdio_func *func;\r\nfunc = device->func;\r\nhost = func->card->host;\r\nmemset(&cmd, 0, sizeof(struct mmc_command));\r\ncmd.opcode = opcode;\r\ncmd.arg = arg;\r\ncmd.flags = flags;\r\nerr = mmc_wait_for_cmd(host, &cmd, 3);\r\nif ((!err) && (resp)) {\r\n*resp = cmd.resp[0];\r\n}\r\nreturn err;\r\n}\r\nint ReinitSDIO(struct hif_device *device)\r\n{\r\ns32 err;\r\nstruct mmc_host *host;\r\nstruct mmc_card *card;\r\nstruct sdio_func *func;\r\nu8 cmd52_resp;\r\nu32 clock;\r\nfunc = device->func;\r\ncard = func->card;\r\nhost = card->host;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: +ReinitSDIO \n"));\r\nsdio_claim_host(func);\r\ndo {\r\nif (!device->is_suspend) {\r\nu32 resp;\r\nu16 rca;\r\nu32 i;\r\nint bit = fls(host->ocr_avail) - 1;\r\nhost->ios.vdd = bit;\r\nhost->ios.chip_select = MMC_CS_DONTCARE;\r\nhost->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;\r\nhost->ios.power_mode = MMC_POWER_UP;\r\nhost->ios.bus_width = MMC_BUS_WIDTH_1;\r\nhost->ios.timing = MMC_TIMING_LEGACY;\r\nhost->ops->set_ios(host, &host->ios);\r\nmsleep(2);\r\nhost->ios.clock = host->f_min;\r\nhost->ios.power_mode = MMC_POWER_ON;\r\nhost->ops->set_ios(host, &host->ios);\r\nmsleep(2);\r\nhost->ios.chip_select = MMC_CS_HIGH;\r\nhost->ops->set_ios(host, &host->ios);\r\nmsleep(1);\r\nerr = IssueSDCommand(device, MMC_GO_IDLE_STATE, 0, (MMC_RSP_NONE | MMC_CMD_BC), NULL);\r\nhost->ios.chip_select = MMC_CS_DONTCARE;\r\nhost->ops->set_ios(host, &host->ios);\r\nmsleep(1);\r\nhost->use_spi_crc = 0;\r\nif (err) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: CMD0 failed : %d \n",err));\r\nbreak;\r\n}\r\nif (!host->ocr) {\r\nerr = IssueSDCommand(device, SD_IO_SEND_OP_COND, 0, (MMC_RSP_R4 | MMC_CMD_BCR), &resp);\r\nif (err) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: CMD5 failed : %d \n",err));\r\nbreak;\r\n}\r\nhost->ocr = resp;\r\n}\r\nfor (i=0;i<100;i++) {\r\nerr = IssueSDCommand(device, SD_IO_SEND_OP_COND, host->ocr, (MMC_RSP_R4 | MMC_CMD_BCR), &resp);\r\nif (err) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: CMD5 failed : %d \n",err));\r\nbreak;\r\n}\r\nif (resp & MMC_CARD_BUSY) {\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\nif ((i == 100) || (err)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: card in not ready : %d %d \n",i,err));\r\nbreak;\r\n}\r\nerr = IssueSDCommand(device, SD_SEND_RELATIVE_ADDR, 0, MMC_RSP_R6 | MMC_CMD_BCR, &resp);\r\nif (err) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: CMD3 failed : %d \n",err));\r\nbreak;\r\n}\r\nrca = resp >> 16;\r\nhost->ios.bus_mode = MMC_BUSMODE_PUSHPULL;\r\nhost->ops->set_ios(host, &host->ios);\r\nerr = IssueSDCommand(device, MMC_SELECT_CARD, (rca << 16), MMC_RSP_R1 | MMC_CMD_AC, NULL);\r\nif (err) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: CMD7 failed : %d \n",err));\r\nbreak;\r\n}\r\n}\r\nif (card->host->caps & MMC_CAP_SD_HIGHSPEED) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("ReinitSDIO: Set high speed mode\n"));\r\nerr = Func0_CMD52ReadByte(card, SDIO_CCCR_SPEED, &cmd52_resp);\r\nif (err) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: CMD52 read to CCCR speed register failed : %d \n",err));\r\ncard->state &= ~MMC_STATE_HIGHSPEED;\r\n} else {\r\nerr = Func0_CMD52WriteByte(card, SDIO_CCCR_SPEED, (cmd52_resp | SDIO_SPEED_EHS));\r\nif (err) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: CMD52 write to CCCR speed register failed : %d \n",err));\r\nbreak;\r\n}\r\nmmc_card_set_highspeed(card);\r\nhost->ios.timing = MMC_TIMING_SD_HS;\r\nhost->ops->set_ios(host, &host->ios);\r\n}\r\n}\r\nif (mmc_card_highspeed(card)) {\r\nclock = 50000000;\r\n} else {\r\nclock = card->cis.max_dtr;\r\n}\r\nif (clock > host->f_max) {\r\nclock = host->f_max;\r\n}\r\nhost->ios.clock = clock;\r\nhost->ops->set_ios(host, &host->ios);\r\nif (card->host->caps & MMC_CAP_4_BIT_DATA) {\r\nerr = Func0_CMD52WriteByte(card, SDIO_CCCR_IF, SDIO_BUS_CD_DISABLE | SDIO_BUS_WIDTH_4BIT);\r\nif (err) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("ReinitSDIO: CMD52 to set bus mode failed : %d \n",err));\r\nbreak;\r\n}\r\nhost->ios.bus_width = MMC_BUS_WIDTH_4;\r\nhost->ops->set_ios(host, &host->ios);\r\n}\r\n} while (0);\r\nsdio_release_host(func);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: -ReinitSDIO \n"));\r\nreturn (err) ? A_ERROR : 0;\r\n}\r\nint\r\nPowerStateChangeNotify(struct hif_device *device, HIF_DEVICE_POWER_CHANGE_TYPE config)\r\n{\r\nint status = 0;\r\n#if defined(CONFIG_PM)\r\nstruct sdio_func *func = device->func;\r\nint old_reset_val;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: +PowerStateChangeNotify %d\n", config));\r\nswitch (config) {\r\ncase HIF_DEVICE_POWER_DOWN:\r\ncase HIF_DEVICE_POWER_CUT:\r\nold_reset_val = reset_sdio_on_unload;\r\nreset_sdio_on_unload = 1;\r\nstatus = hifDisableFunc(device, func);\r\nreset_sdio_on_unload = old_reset_val;\r\nif (!device->is_suspend) {\r\nstruct mmc_host *host = func->card->host;\r\nhost->ios.clock = 0;\r\nhost->ios.vdd = 0;\r\nhost->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;\r\nhost->ios.chip_select = MMC_CS_DONTCARE;\r\nhost->ios.power_mode = MMC_POWER_OFF;\r\nhost->ios.bus_width = MMC_BUS_WIDTH_1;\r\nhost->ios.timing = MMC_TIMING_LEGACY;\r\nhost->ops->set_ios(host, &host->ios);\r\n}\r\nbreak;\r\ncase HIF_DEVICE_POWER_UP:\r\nif (device->powerConfig == HIF_DEVICE_POWER_CUT) {\r\nstatus = ReinitSDIO(device);\r\n}\r\nif (status == 0) {\r\nstatus = hifEnableFunc(device, func);\r\n}\r\nbreak;\r\n}\r\ndevice->powerConfig = config;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: -PowerStateChangeNotify\n"));\r\n#endif\r\nreturn status;\r\n}\r\nint\r\nHIFConfigureDevice(struct hif_device *device, HIF_DEVICE_CONFIG_OPCODE opcode,\r\nvoid *config, u32 configLen)\r\n{\r\nu32 count;\r\nint status = 0;\r\nswitch(opcode) {\r\ncase HIF_DEVICE_GET_MBOX_BLOCK_SIZE:\r\n((u32 *)config)[0] = HIF_MBOX0_BLOCK_SIZE;\r\n((u32 *)config)[1] = HIF_MBOX1_BLOCK_SIZE;\r\n((u32 *)config)[2] = HIF_MBOX2_BLOCK_SIZE;\r\n((u32 *)config)[3] = HIF_MBOX3_BLOCK_SIZE;\r\nbreak;\r\ncase HIF_DEVICE_GET_MBOX_ADDR:\r\nfor (count = 0; count < 4; count ++) {\r\n((u32 *)config)[count] = HIF_MBOX_START_ADDR(count);\r\n}\r\nif (configLen >= sizeof(struct hif_device_mbox_info)) {\r\nSetExtendedMboxWindowInfo((u16)device->func->device,\r\n(struct hif_device_mbox_info *)config);\r\n}\r\nbreak;\r\ncase HIF_DEVICE_GET_IRQ_PROC_MODE:\r\n*((HIF_DEVICE_IRQ_PROCESSING_MODE *)config) = HIF_DEVICE_IRQ_SYNC_ONLY;\r\nbreak;\r\ncase HIF_CONFIGURE_QUERY_SCATTER_REQUEST_SUPPORT:\r\nif (!device->scatter_enabled) {\r\nreturn A_ENOTSUP;\r\n}\r\nstatus = SetupHIFScatterSupport(device, (struct hif_device_scatter_support_info *)config);\r\nif (status) {\r\ndevice->scatter_enabled = false;\r\n}\r\nbreak;\r\ncase HIF_DEVICE_GET_OS_DEVICE:\r\n((struct hif_device_os_device_info *)config)->pOSDevice = &device->func->dev;\r\nbreak;\r\ncase HIF_DEVICE_POWER_STATE_CHANGE:\r\nstatus = PowerStateChangeNotify(device, *(HIF_DEVICE_POWER_CHANGE_TYPE *)config);\r\nbreak;\r\ndefault:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN,\r\n("AR6000: Unsupported configuration opcode: %d\n", opcode));\r\nstatus = A_ERROR;\r\n}\r\nreturn status;\r\n}\r\nvoid\r\nHIFShutDownDevice(struct hif_device *device)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: +HIFShutDownDevice\n"));\r\nif (device != NULL) {\r\nAR_DEBUG_ASSERT(device->func != NULL);\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: HIFShutDownDevice, resetting\n"));\r\nResetAllCards();\r\nif (registered) {\r\nregistered = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE,\r\n("AR6000: Unregistering with the bus driver\n"));\r\nsdio_unregister_driver(&ath6kl_hifdev_driver);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE,\r\n("AR6000: Unregistered\n"));\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: -HIFShutDownDevice\n"));\r\n}\r\nstatic void\r\nhifIRQHandler(struct sdio_func *func)\r\n{\r\nint status;\r\nstruct hif_device *device;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: +hifIRQHandler\n"));\r\ndevice = ath6kl_get_hifdev(func);\r\natomic_set(&device->irqHandling, 1);\r\nsdio_release_host(device->func);\r\nstatus = device->htcCallbacks.dsrHandler(device->htcCallbacks.context);\r\nsdio_claim_host(device->func);\r\natomic_set(&device->irqHandling, 0);\r\nAR_DEBUG_ASSERT(status == 0 || status == A_ECANCELED);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: -hifIRQHandler\n"));\r\n}\r\nstatic int startup_task(void *param)\r\n{\r\nstruct hif_device *device;\r\ndevice = (struct hif_device *)param;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: call HTC from startup_task\n"));\r\nif ((osdrvCallbacks.deviceInsertedHandler(osdrvCallbacks.context,device)) != 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: Device rejected\n"));\r\n}\r\nreturn 0;\r\n}\r\nstatic int enable_task(void *param)\r\n{\r\nstruct hif_device *device;\r\ndevice = (struct hif_device *)param;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: call from resume_task\n"));\r\nif (device &&\r\ndevice->claimedContext &&\r\nosdrvCallbacks.devicePowerChangeHandler &&\r\nosdrvCallbacks.devicePowerChangeHandler(device->claimedContext, HIF_DEVICE_POWER_UP) != 0)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: Device rejected\n"));\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nHIFAckInterrupt(struct hif_device *device)\r\n{\r\nAR_DEBUG_ASSERT(device != NULL);\r\n}\r\nvoid\r\nHIFUnMaskInterrupt(struct hif_device *device)\r\n{\r\nint ret;\r\nAR_DEBUG_ASSERT(device != NULL);\r\nAR_DEBUG_ASSERT(device->func != NULL);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: HIFUnMaskInterrupt\n"));\r\nsdio_claim_host(device->func);\r\nret = sdio_claim_irq(device->func, hifIRQHandler);\r\nsdio_release_host(device->func);\r\nAR_DEBUG_ASSERT(ret == 0);\r\n}\r\nvoid HIFMaskInterrupt(struct hif_device *device)\r\n{\r\nint ret;\r\nAR_DEBUG_ASSERT(device != NULL);\r\nAR_DEBUG_ASSERT(device->func != NULL);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: HIFMaskInterrupt\n"));\r\nsdio_claim_host(device->func);\r\nwhile (atomic_read(&device->irqHandling)) {\r\nsdio_release_host(device->func);\r\nschedule_timeout(HZ/10);\r\nsdio_claim_host(device->func);\r\n}\r\nret = sdio_release_irq(device->func);\r\nsdio_release_host(device->func);\r\nAR_DEBUG_ASSERT(ret == 0);\r\n}\r\nBUS_REQUEST *hifAllocateBusRequest(struct hif_device *device)\r\n{\r\nBUS_REQUEST *busrequest;\r\nunsigned long flag;\r\nspin_lock_irqsave(&device->lock, flag);\r\nif((busrequest = device->s_busRequestFreeQueue) != NULL)\r\n{\r\ndevice->s_busRequestFreeQueue = busrequest->next;\r\n}\r\nspin_unlock_irqrestore(&device->lock, flag);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: hifAllocateBusRequest: 0x%p\n", busrequest));\r\nreturn busrequest;\r\n}\r\nvoid\r\nhifFreeBusRequest(struct hif_device *device, BUS_REQUEST *busrequest)\r\n{\r\nunsigned long flag;\r\nAR_DEBUG_ASSERT(busrequest != NULL);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: hifFreeBusRequest: 0x%p\n", busrequest));\r\nspin_lock_irqsave(&device->lock, flag);\r\nbusrequest->next = device->s_busRequestFreeQueue;\r\nbusrequest->inusenext = NULL;\r\ndevice->s_busRequestFreeQueue = busrequest;\r\nspin_unlock_irqrestore(&device->lock, flag);\r\n}\r\nstatic int hifDisableFunc(struct hif_device *device, struct sdio_func *func)\r\n{\r\nint ret;\r\nint status = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: +hifDisableFunc\n"));\r\ndevice = ath6kl_get_hifdev(func);\r\nif (!IS_ERR(device->async_task)) {\r\ninit_completion(&device->async_completion);\r\ndevice->async_shutdown = 1;\r\nup(&device->sem_async);\r\nwait_for_completion(&device->async_completion);\r\ndevice->async_task = NULL;\r\n}\r\nsdio_claim_host(device->func);\r\nret = sdio_disable_func(device->func);\r\nif (ret) {\r\nstatus = A_ERROR;\r\n}\r\nif (reset_sdio_on_unload) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, ("AR6000: reseting SDIO card back to uninitialized state \n"));\r\nret = Func0_CMD52WriteByte(device->func->card, SDIO_CCCR_ABORT, (1 << 3));\r\nif (ret) {\r\nstatus = A_ERROR;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("AR6000: reset failed : %d \n",ret));\r\n}\r\n}\r\nsdio_release_host(device->func);\r\nif (status == 0) {\r\ndevice->is_disabled = true;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: -hifDisableFunc\n"));\r\nreturn status;\r\n}\r\nstatic int hifEnableFunc(struct hif_device *device, struct sdio_func *func)\r\n{\r\nstruct task_struct* pTask;\r\nconst char *taskName = NULL;\r\nint (*taskFunc)(void *) = NULL;\r\nint ret = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: +hifEnableFunc\n"));\r\ndevice = ath6kl_get_hifdev(func);\r\nif (device->is_disabled) {\r\nsdio_claim_host(func);\r\nif ((device->id->device & MANUFACTURER_ID_AR6K_BASE_MASK) >= MANUFACTURER_ID_AR6003_BASE) {\r\nret = Func0_CMD52WriteByte(func->card, CCCR_SDIO_IRQ_MODE_REG, SDIO_IRQ_MODE_ASYNC_4BIT_IRQ);\r\nif (ret) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("AR6000: failed to enable 4-bit ASYNC IRQ mode %d \n",ret));\r\nsdio_release_host(func);\r\nreturn ret;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: 4-bit ASYNC IRQ mode enabled\n"));\r\n}\r\nfunc->enable_timeout = 100;\r\nret = sdio_enable_func(func);\r\nif (ret) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("AR6000: %s(), Unable to enable AR6K: 0x%X\n",\r\n__FUNCTION__, ret));\r\nsdio_release_host(func);\r\nreturn ret;\r\n}\r\nret = sdio_set_block_size(func, HIF_MBOX_BLOCK_SIZE);\r\nsdio_release_host(func);\r\nif (ret) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("AR6000: %s(), Unable to set block size 0x%x AR6K: 0x%X\n",\r\n__FUNCTION__, HIF_MBOX_BLOCK_SIZE, ret));\r\nreturn ret;\r\n}\r\ndevice->is_disabled = false;\r\nif (!device->async_task) {\r\ndevice->async_shutdown = 0;\r\ndevice->async_task = kthread_create(async_task,\r\n(void *)device,\r\n"AR6K Async");\r\nif (IS_ERR(device->async_task)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("AR6000: %s(), to create async task\n", __FUNCTION__));\r\nreturn -ENOMEM;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: start async task\n"));\r\nwake_up_process(device->async_task );\r\n}\r\n}\r\nif (!device->claimedContext) {\r\ntaskFunc = startup_task;\r\ntaskName = "AR6K startup";\r\nret = 0;\r\n#if defined(CONFIG_PM)\r\n} else {\r\ntaskFunc = enable_task;\r\ntaskName = "AR6K enable";\r\nret = -ENOMEM;\r\n#endif\r\n}\r\npTask = kthread_create(taskFunc, (void *)device, taskName);\r\nif (IS_ERR(pTask)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("AR6000: %s(), to create enabel task\n", __FUNCTION__));\r\nreturn -ENOMEM;\r\n}\r\nwake_up_process(pTask);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: -hifEnableFunc\n"));\r\nreturn ret;\r\n}\r\nint hifWaitForPendingRecv(struct hif_device *device)\r\n{\r\ns32 cnt = 10;\r\nu8 host_int_status;\r\nint status = 0;\r\ndo {\r\nwhile (atomic_read(&device->irqHandling)) {\r\nschedule_timeout(HZ/10);\r\n}\r\nhost_int_status = 0;\r\nstatus = HIFReadWrite(device, HOST_INT_STATUS_ADDRESS,\r\n(u8 *)&host_int_status, sizeof(host_int_status),\r\nHIF_RD_SYNC_BYTE_INC, NULL);\r\nhost_int_status = !status ? (host_int_status & (1 << 0)) : 0;\r\nif (host_int_status) {\r\nschedule();\r\n}\r\n} while (host_int_status && --cnt > 0);\r\nif (host_int_status && cnt == 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERROR,\r\n("AR6000: %s(), Unable clear up pending IRQ before the system suspended\n", __FUNCTION__));\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ndelHifDevice(struct hif_device * device)\r\n{\r\nAR_DEBUG_ASSERT(device!= NULL);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("AR6000: delHifDevice; 0x%p\n", device));\r\nkfree(device->dma_buffer);\r\nkfree(device);\r\n}\r\nstatic void ResetAllCards(void)\r\n{\r\n}\r\nvoid HIFClaimDevice(struct hif_device *device, void *context)\r\n{\r\ndevice->claimedContext = context;\r\n}\r\nvoid HIFReleaseDevice(struct hif_device *device)\r\n{\r\ndevice->claimedContext = NULL;\r\n}\r\nint HIFAttachHTC(struct hif_device *device, HTC_CALLBACKS *callbacks)\r\n{\r\nif (device->htcCallbacks.context != NULL) {\r\nreturn A_ERROR;\r\n}\r\ndevice->htcCallbacks = *callbacks;\r\nreturn 0;\r\n}\r\nvoid HIFDetachHTC(struct hif_device *device)\r\n{\r\nA_MEMZERO(&device->htcCallbacks,sizeof(device->htcCallbacks));\r\n}\r\nstatic int Func0_CMD52WriteByte(struct mmc_card *card, unsigned int address, unsigned char byte)\r\n{\r\nstruct mmc_command ioCmd;\r\nunsigned long arg;\r\nmemset(&ioCmd,0,sizeof(ioCmd));\r\nSDIO_SET_CMD52_WRITE_ARG(arg,0,address,byte);\r\nioCmd.opcode = SD_IO_RW_DIRECT;\r\nioCmd.arg = arg;\r\nioCmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\r\nreturn mmc_wait_for_cmd(card->host, &ioCmd, 0);\r\n}\r\nstatic int Func0_CMD52ReadByte(struct mmc_card *card, unsigned int address, unsigned char *byte)\r\n{\r\nstruct mmc_command ioCmd;\r\nunsigned long arg;\r\ns32 err;\r\nmemset(&ioCmd,0,sizeof(ioCmd));\r\nSDIO_SET_CMD52_READ_ARG(arg,0,address);\r\nioCmd.opcode = SD_IO_RW_DIRECT;\r\nioCmd.arg = arg;\r\nioCmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &ioCmd, 0);\r\nif ((!err) && (byte)) {\r\n*byte = ioCmd.resp[0] & 0xFF;\r\n}\r\nreturn err;\r\n}
