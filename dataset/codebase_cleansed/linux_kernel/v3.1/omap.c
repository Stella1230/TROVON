static void mmc_omap_fclk_offdelay(struct mmc_omap_slot *slot)\r\n{\r\nunsigned long tick_ns;\r\nif (slot != NULL && slot->host->fclk_enabled && slot->fclk_freq > 0) {\r\ntick_ns = (1000000000 + slot->fclk_freq - 1) / slot->fclk_freq;\r\nndelay(8 * tick_ns);\r\n}\r\n}\r\nstatic void mmc_omap_fclk_enable(struct mmc_omap_host *host, unsigned int enable)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->clk_lock, flags);\r\nif (host->fclk_enabled != enable) {\r\nhost->fclk_enabled = enable;\r\nif (enable)\r\nclk_enable(host->fclk);\r\nelse\r\nclk_disable(host->fclk);\r\n}\r\nspin_unlock_irqrestore(&host->clk_lock, flags);\r\n}\r\nstatic void mmc_omap_select_slot(struct mmc_omap_slot *slot, int claimed)\r\n{\r\nstruct mmc_omap_host *host = slot->host;\r\nunsigned long flags;\r\nif (claimed)\r\ngoto no_claim;\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\nwhile (host->mmc != NULL) {\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nwait_event(host->slot_wq, host->mmc == NULL);\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\n}\r\nhost->mmc = slot->mmc;\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nno_claim:\r\ndel_timer(&host->clk_timer);\r\nif (host->current_slot != slot || !claimed)\r\nmmc_omap_fclk_offdelay(host->current_slot);\r\nif (host->current_slot != slot) {\r\nOMAP_MMC_WRITE(host, CON, slot->saved_con & 0xFC00);\r\nif (host->pdata->switch_slot != NULL)\r\nhost->pdata->switch_slot(mmc_dev(slot->mmc), slot->id);\r\nhost->current_slot = slot;\r\n}\r\nif (claimed) {\r\nmmc_omap_fclk_enable(host, 1);\r\nOMAP_MMC_READ(host, CON);\r\nOMAP_MMC_WRITE(host, CON, slot->saved_con);\r\n} else\r\nmmc_omap_fclk_enable(host, 0);\r\n}\r\nstatic void mmc_omap_slot_release_work(struct work_struct *work)\r\n{\r\nstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\r\nslot_release_work);\r\nstruct mmc_omap_slot *next_slot = host->next_slot;\r\nstruct mmc_request *rq;\r\nhost->next_slot = NULL;\r\nmmc_omap_select_slot(next_slot, 1);\r\nrq = next_slot->mrq;\r\nnext_slot->mrq = NULL;\r\nmmc_omap_start_request(host, rq);\r\n}\r\nstatic void mmc_omap_release_slot(struct mmc_omap_slot *slot, int clk_enabled)\r\n{\r\nstruct mmc_omap_host *host = slot->host;\r\nunsigned long flags;\r\nint i;\r\nBUG_ON(slot == NULL || host->mmc == NULL);\r\nif (clk_enabled)\r\nmod_timer(&host->clk_timer, jiffies + HZ/10);\r\nelse {\r\ndel_timer(&host->clk_timer);\r\nmmc_omap_fclk_offdelay(slot);\r\nmmc_omap_fclk_enable(host, 0);\r\n}\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\nfor (i = 0; i < host->nr_slots; i++) {\r\nstruct mmc_omap_slot *new_slot;\r\nif (host->slots[i] == NULL || host->slots[i]->mrq == NULL)\r\ncontinue;\r\nBUG_ON(host->next_slot != NULL);\r\nnew_slot = host->slots[i];\r\nBUG_ON(new_slot == host->current_slot);\r\nhost->next_slot = new_slot;\r\nhost->mmc = new_slot->mmc;\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nqueue_work(mmc_omap_wq, &host->slot_release_work);\r\nreturn;\r\n}\r\nhost->mmc = NULL;\r\nwake_up(&host->slot_wq);\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\n}\r\nstatic inline\r\nint mmc_omap_cover_is_open(struct mmc_omap_slot *slot)\r\n{\r\nif (slot->pdata->get_cover_state)\r\nreturn slot->pdata->get_cover_state(mmc_dev(slot->mmc),\r\nslot->id);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nmmc_omap_show_cover_switch(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nreturn sprintf(buf, "%s\n", mmc_omap_cover_is_open(slot) ? "open" :\r\n"closed");\r\n}\r\nstatic ssize_t\r\nmmc_omap_show_slot_name(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nreturn sprintf(buf, "%s\n", slot->pdata->name);\r\n}\r\nstatic void\r\nmmc_omap_start_command(struct mmc_omap_host *host, struct mmc_command *cmd)\r\n{\r\nu32 cmdreg;\r\nu32 resptype;\r\nu32 cmdtype;\r\nhost->cmd = cmd;\r\nresptype = 0;\r\ncmdtype = 0;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\nbreak;\r\ncase MMC_RSP_R1:\r\ncase MMC_RSP_R1B:\r\nresptype = 1;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nresptype = 2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nresptype = 3;\r\nbreak;\r\ndefault:\r\ndev_err(mmc_dev(host->mmc), "Invalid response type: %04x\n", mmc_resp_type(cmd));\r\nbreak;\r\n}\r\nif (mmc_cmd_type(cmd) == MMC_CMD_ADTC) {\r\ncmdtype = OMAP_MMC_CMDTYPE_ADTC;\r\n} else if (mmc_cmd_type(cmd) == MMC_CMD_BC) {\r\ncmdtype = OMAP_MMC_CMDTYPE_BC;\r\n} else if (mmc_cmd_type(cmd) == MMC_CMD_BCR) {\r\ncmdtype = OMAP_MMC_CMDTYPE_BCR;\r\n} else {\r\ncmdtype = OMAP_MMC_CMDTYPE_AC;\r\n}\r\ncmdreg = cmd->opcode | (resptype << 8) | (cmdtype << 12);\r\nif (host->current_slot->bus_mode == MMC_BUSMODE_OPENDRAIN)\r\ncmdreg |= 1 << 6;\r\nif (cmd->flags & MMC_RSP_BUSY)\r\ncmdreg |= 1 << 11;\r\nif (host->data && !(host->data->flags & MMC_DATA_WRITE))\r\ncmdreg |= 1 << 15;\r\nmod_timer(&host->cmd_abort_timer, jiffies + HZ/2);\r\nOMAP_MMC_WRITE(host, CTO, 200);\r\nOMAP_MMC_WRITE(host, ARGL, cmd->arg & 0xffff);\r\nOMAP_MMC_WRITE(host, ARGH, cmd->arg >> 16);\r\nOMAP_MMC_WRITE(host, IE,\r\nOMAP_MMC_STAT_A_EMPTY | OMAP_MMC_STAT_A_FULL |\r\nOMAP_MMC_STAT_CMD_CRC | OMAP_MMC_STAT_CMD_TOUT |\r\nOMAP_MMC_STAT_DATA_CRC | OMAP_MMC_STAT_DATA_TOUT |\r\nOMAP_MMC_STAT_END_OF_CMD | OMAP_MMC_STAT_CARD_ERR |\r\nOMAP_MMC_STAT_END_OF_DATA);\r\nOMAP_MMC_WRITE(host, CMD, cmdreg);\r\n}\r\nstatic void\r\nmmc_omap_release_dma(struct mmc_omap_host *host, struct mmc_data *data,\r\nint abort)\r\n{\r\nenum dma_data_direction dma_data_dir;\r\nBUG_ON(host->dma_ch < 0);\r\nif (data->error)\r\nomap_stop_dma(host->dma_ch);\r\nmod_timer(&host->dma_timer, jiffies + HZ);\r\nif (data->flags & MMC_DATA_WRITE)\r\ndma_data_dir = DMA_TO_DEVICE;\r\nelse\r\ndma_data_dir = DMA_FROM_DEVICE;\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_len,\r\ndma_data_dir);\r\n}\r\nstatic void mmc_omap_send_stop_work(struct work_struct *work)\r\n{\r\nstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\r\nsend_stop_work);\r\nstruct mmc_omap_slot *slot = host->current_slot;\r\nstruct mmc_data *data = host->stop_data;\r\nunsigned long tick_ns;\r\ntick_ns = (1000000000 + slot->fclk_freq - 1)/slot->fclk_freq;\r\nndelay(8*tick_ns);\r\nmmc_omap_start_command(host, data->stop);\r\n}\r\nstatic void\r\nmmc_omap_xfer_done(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nif (host->dma_in_use)\r\nmmc_omap_release_dma(host, data, data->error);\r\nhost->data = NULL;\r\nhost->sg_len = 0;\r\nif (!data->stop) {\r\nstruct mmc_host *mmc;\r\nhost->mrq = NULL;\r\nmmc = host->mmc;\r\nmmc_omap_release_slot(host->current_slot, 1);\r\nmmc_request_done(mmc, data->mrq);\r\nreturn;\r\n}\r\nhost->stop_data = data;\r\nqueue_work(mmc_omap_wq, &host->send_stop_work);\r\n}\r\nstatic void\r\nmmc_omap_send_abort(struct mmc_omap_host *host, int maxloops)\r\n{\r\nstruct mmc_omap_slot *slot = host->current_slot;\r\nunsigned int restarts, passes, timeout;\r\nu16 stat = 0;\r\ntimeout = (120*1000000 + slot->fclk_freq - 1)/slot->fclk_freq;\r\nrestarts = 0;\r\nwhile (restarts < maxloops) {\r\nOMAP_MMC_WRITE(host, STAT, 0xFFFF);\r\nOMAP_MMC_WRITE(host, CMD, (3 << 12) | (1 << 7));\r\npasses = 0;\r\nwhile (passes < timeout) {\r\nstat = OMAP_MMC_READ(host, STAT);\r\nif (stat & OMAP_MMC_STAT_END_OF_CMD)\r\ngoto out;\r\nudelay(1);\r\npasses++;\r\n}\r\nrestarts++;\r\n}\r\nout:\r\nOMAP_MMC_WRITE(host, STAT, stat);\r\n}\r\nstatic void\r\nmmc_omap_abort_xfer(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nif (host->dma_in_use)\r\nmmc_omap_release_dma(host, data, 1);\r\nhost->data = NULL;\r\nhost->sg_len = 0;\r\nmmc_omap_send_abort(host, 10000);\r\n}\r\nstatic void\r\nmmc_omap_end_of_data(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nunsigned long flags;\r\nint done;\r\nif (!host->dma_in_use) {\r\nmmc_omap_xfer_done(host, data);\r\nreturn;\r\n}\r\ndone = 0;\r\nspin_lock_irqsave(&host->dma_lock, flags);\r\nif (host->dma_done)\r\ndone = 1;\r\nelse\r\nhost->brs_received = 1;\r\nspin_unlock_irqrestore(&host->dma_lock, flags);\r\nif (done)\r\nmmc_omap_xfer_done(host, data);\r\n}\r\nstatic void\r\nmmc_omap_dma_timer(unsigned long data)\r\n{\r\nstruct mmc_omap_host *host = (struct mmc_omap_host *) data;\r\nBUG_ON(host->dma_ch < 0);\r\nomap_free_dma(host->dma_ch);\r\nhost->dma_ch = -1;\r\n}\r\nstatic void\r\nmmc_omap_dma_done(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nunsigned long flags;\r\nint done;\r\ndone = 0;\r\nspin_lock_irqsave(&host->dma_lock, flags);\r\nif (host->brs_received)\r\ndone = 1;\r\nelse\r\nhost->dma_done = 1;\r\nspin_unlock_irqrestore(&host->dma_lock, flags);\r\nif (done)\r\nmmc_omap_xfer_done(host, data);\r\n}\r\nstatic void\r\nmmc_omap_cmd_done(struct mmc_omap_host *host, struct mmc_command *cmd)\r\n{\r\nhost->cmd = NULL;\r\ndel_timer(&host->cmd_abort_timer);\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[3] =\r\nOMAP_MMC_READ(host, RSP0) |\r\n(OMAP_MMC_READ(host, RSP1) << 16);\r\ncmd->resp[2] =\r\nOMAP_MMC_READ(host, RSP2) |\r\n(OMAP_MMC_READ(host, RSP3) << 16);\r\ncmd->resp[1] =\r\nOMAP_MMC_READ(host, RSP4) |\r\n(OMAP_MMC_READ(host, RSP5) << 16);\r\ncmd->resp[0] =\r\nOMAP_MMC_READ(host, RSP6) |\r\n(OMAP_MMC_READ(host, RSP7) << 16);\r\n} else {\r\ncmd->resp[0] =\r\nOMAP_MMC_READ(host, RSP6) |\r\n(OMAP_MMC_READ(host, RSP7) << 16);\r\n}\r\n}\r\nif (host->data == NULL || cmd->error) {\r\nstruct mmc_host *mmc;\r\nif (host->data != NULL)\r\nmmc_omap_abort_xfer(host, host->data);\r\nhost->mrq = NULL;\r\nmmc = host->mmc;\r\nmmc_omap_release_slot(host->current_slot, 1);\r\nmmc_request_done(mmc, cmd->mrq);\r\n}\r\n}\r\nstatic void mmc_omap_abort_command(struct work_struct *work)\r\n{\r\nstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\r\ncmd_abort_work);\r\nBUG_ON(!host->cmd);\r\ndev_dbg(mmc_dev(host->mmc), "Aborting stuck command CMD%d\n",\r\nhost->cmd->opcode);\r\nif (host->cmd->error == 0)\r\nhost->cmd->error = -ETIMEDOUT;\r\nif (host->data == NULL) {\r\nstruct mmc_command *cmd;\r\nstruct mmc_host *mmc;\r\ncmd = host->cmd;\r\nhost->cmd = NULL;\r\nmmc_omap_send_abort(host, 10000);\r\nhost->mrq = NULL;\r\nmmc = host->mmc;\r\nmmc_omap_release_slot(host->current_slot, 1);\r\nmmc_request_done(mmc, cmd->mrq);\r\n} else\r\nmmc_omap_cmd_done(host, host->cmd);\r\nhost->abort = 0;\r\nenable_irq(host->irq);\r\n}\r\nstatic void\r\nmmc_omap_cmd_timer(unsigned long data)\r\n{\r\nstruct mmc_omap_host *host = (struct mmc_omap_host *) data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\nif (host->cmd != NULL && !host->abort) {\r\nOMAP_MMC_WRITE(host, IE, 0);\r\ndisable_irq(host->irq);\r\nhost->abort = 1;\r\nqueue_work(mmc_omap_wq, &host->cmd_abort_work);\r\n}\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\n}\r\nstatic void\r\nmmc_omap_sg_to_buf(struct mmc_omap_host *host)\r\n{\r\nstruct scatterlist *sg;\r\nsg = host->data->sg + host->sg_idx;\r\nhost->buffer_bytes_left = sg->length;\r\nhost->buffer = sg_virt(sg);\r\nif (host->buffer_bytes_left > host->total_bytes_left)\r\nhost->buffer_bytes_left = host->total_bytes_left;\r\n}\r\nstatic void\r\nmmc_omap_clk_timer(unsigned long data)\r\n{\r\nstruct mmc_omap_host *host = (struct mmc_omap_host *) data;\r\nmmc_omap_fclk_enable(host, 0);\r\n}\r\nstatic void\r\nmmc_omap_xfer_data(struct mmc_omap_host *host, int write)\r\n{\r\nint n;\r\nif (host->buffer_bytes_left == 0) {\r\nhost->sg_idx++;\r\nBUG_ON(host->sg_idx == host->sg_len);\r\nmmc_omap_sg_to_buf(host);\r\n}\r\nn = 64;\r\nif (n > host->buffer_bytes_left)\r\nn = host->buffer_bytes_left;\r\nhost->buffer_bytes_left -= n;\r\nhost->total_bytes_left -= n;\r\nhost->data->bytes_xfered += n;\r\nif (write) {\r\n__raw_writesw(host->virt_base + OMAP_MMC_REG(host, DATA), host->buffer, n);\r\n} else {\r\n__raw_readsw(host->virt_base + OMAP_MMC_REG(host, DATA), host->buffer, n);\r\n}\r\n}\r\nstatic inline void mmc_omap_report_irq(u16 status)\r\n{\r\nstatic const char *mmc_omap_status_bits[] = {\r\n"EOC", "CD", "CB", "BRS", "EOFB", "DTO", "DCRC", "CTO",\r\n"CCRC", "CRW", "AF", "AE", "OCRB", "CIRQ", "CERR"\r\n};\r\nint i, c = 0;\r\nfor (i = 0; i < ARRAY_SIZE(mmc_omap_status_bits); i++)\r\nif (status & (1 << i)) {\r\nif (c)\r\nprintk(" ");\r\nprintk("%s", mmc_omap_status_bits[i]);\r\nc++;\r\n}\r\n}\r\nstatic irqreturn_t mmc_omap_irq(int irq, void *dev_id)\r\n{\r\nstruct mmc_omap_host * host = (struct mmc_omap_host *)dev_id;\r\nu16 status;\r\nint end_command;\r\nint end_transfer;\r\nint transfer_error, cmd_error;\r\nif (host->cmd == NULL && host->data == NULL) {\r\nstatus = OMAP_MMC_READ(host, STAT);\r\ndev_info(mmc_dev(host->slots[0]->mmc),\r\n"Spurious IRQ 0x%04x\n", status);\r\nif (status != 0) {\r\nOMAP_MMC_WRITE(host, STAT, status);\r\nOMAP_MMC_WRITE(host, IE, 0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nend_command = 0;\r\nend_transfer = 0;\r\ntransfer_error = 0;\r\ncmd_error = 0;\r\nwhile ((status = OMAP_MMC_READ(host, STAT)) != 0) {\r\nint cmd;\r\nOMAP_MMC_WRITE(host, STAT, status);\r\nif (host->cmd != NULL)\r\ncmd = host->cmd->opcode;\r\nelse\r\ncmd = -1;\r\n#ifdef CONFIG_MMC_DEBUG\r\ndev_dbg(mmc_dev(host->mmc), "MMC IRQ %04x (CMD %d): ",\r\nstatus, cmd);\r\nmmc_omap_report_irq(status);\r\nprintk("\n");\r\n#endif\r\nif (host->total_bytes_left) {\r\nif ((status & OMAP_MMC_STAT_A_FULL) ||\r\n(status & OMAP_MMC_STAT_END_OF_DATA))\r\nmmc_omap_xfer_data(host, 0);\r\nif (status & OMAP_MMC_STAT_A_EMPTY)\r\nmmc_omap_xfer_data(host, 1);\r\n}\r\nif (status & OMAP_MMC_STAT_END_OF_DATA)\r\nend_transfer = 1;\r\nif (status & OMAP_MMC_STAT_DATA_TOUT) {\r\ndev_dbg(mmc_dev(host->mmc), "data timeout (CMD%d)\n",\r\ncmd);\r\nif (host->data) {\r\nhost->data->error = -ETIMEDOUT;\r\ntransfer_error = 1;\r\n}\r\n}\r\nif (status & OMAP_MMC_STAT_DATA_CRC) {\r\nif (host->data) {\r\nhost->data->error = -EILSEQ;\r\ndev_dbg(mmc_dev(host->mmc),\r\n"data CRC error, bytes left %d\n",\r\nhost->total_bytes_left);\r\ntransfer_error = 1;\r\n} else {\r\ndev_dbg(mmc_dev(host->mmc), "data CRC error\n");\r\n}\r\n}\r\nif (status & OMAP_MMC_STAT_CMD_TOUT) {\r\nif (host->cmd) {\r\nstruct mmc_omap_slot *slot =\r\nhost->current_slot;\r\nif (slot == NULL ||\r\n!mmc_omap_cover_is_open(slot))\r\ndev_err(mmc_dev(host->mmc),\r\n"command timeout (CMD%d)\n",\r\ncmd);\r\nhost->cmd->error = -ETIMEDOUT;\r\nend_command = 1;\r\ncmd_error = 1;\r\n}\r\n}\r\nif (status & OMAP_MMC_STAT_CMD_CRC) {\r\nif (host->cmd) {\r\ndev_err(mmc_dev(host->mmc),\r\n"command CRC error (CMD%d, arg 0x%08x)\n",\r\ncmd, host->cmd->arg);\r\nhost->cmd->error = -EILSEQ;\r\nend_command = 1;\r\ncmd_error = 1;\r\n} else\r\ndev_err(mmc_dev(host->mmc),\r\n"command CRC error without cmd?\n");\r\n}\r\nif (status & OMAP_MMC_STAT_CARD_ERR) {\r\ndev_dbg(mmc_dev(host->mmc),\r\n"ignoring card status error (CMD%d)\n",\r\ncmd);\r\nend_command = 1;\r\n}\r\nif ((status & OMAP_MMC_STAT_END_OF_CMD) &&\r\n(!(status & OMAP_MMC_STAT_A_EMPTY))) {\r\nend_command = 1;\r\n}\r\n}\r\nif (cmd_error && host->data) {\r\ndel_timer(&host->cmd_abort_timer);\r\nhost->abort = 1;\r\nOMAP_MMC_WRITE(host, IE, 0);\r\ndisable_irq_nosync(host->irq);\r\nqueue_work(mmc_omap_wq, &host->cmd_abort_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (end_command && host->cmd)\r\nmmc_omap_cmd_done(host, host->cmd);\r\nif (host->data != NULL) {\r\nif (transfer_error)\r\nmmc_omap_xfer_done(host, host->data);\r\nelse if (end_transfer)\r\nmmc_omap_end_of_data(host, host->data);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid omap_mmc_notify_cover_event(struct device *dev, int num, int is_closed)\r\n{\r\nint cover_open;\r\nstruct mmc_omap_host *host = dev_get_drvdata(dev);\r\nstruct mmc_omap_slot *slot = host->slots[num];\r\nBUG_ON(num >= host->nr_slots);\r\nif (host->nr_slots == 0 || !host->slots[num])\r\nreturn;\r\ncover_open = mmc_omap_cover_is_open(slot);\r\nif (cover_open != slot->cover_open) {\r\nslot->cover_open = cover_open;\r\nsysfs_notify(&slot->mmc->class_dev.kobj, NULL, "cover_switch");\r\n}\r\ntasklet_hi_schedule(&slot->cover_tasklet);\r\n}\r\nstatic void mmc_omap_cover_timer(unsigned long arg)\r\n{\r\nstruct mmc_omap_slot *slot = (struct mmc_omap_slot *) arg;\r\ntasklet_schedule(&slot->cover_tasklet);\r\n}\r\nstatic void mmc_omap_cover_handler(unsigned long param)\r\n{\r\nstruct mmc_omap_slot *slot = (struct mmc_omap_slot *)param;\r\nint cover_open = mmc_omap_cover_is_open(slot);\r\nmmc_detect_change(slot->mmc, 0);\r\nif (!cover_open)\r\nreturn;\r\nif (slot->mmc->card == NULL || !mmc_card_present(slot->mmc->card))\r\nreturn;\r\nmod_timer(&slot->cover_timer,\r\njiffies + msecs_to_jiffies(OMAP_MMC_COVER_POLL_DELAY));\r\n}\r\nstatic void\r\nmmc_omap_prepare_dma(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nint dma_ch = host->dma_ch;\r\nunsigned long data_addr;\r\nu16 buf, frame;\r\nu32 count;\r\nstruct scatterlist *sg = &data->sg[host->sg_idx];\r\nint src_port = 0;\r\nint dst_port = 0;\r\nint sync_dev = 0;\r\ndata_addr = host->phys_base + OMAP_MMC_REG(host, DATA);\r\nframe = data->blksz;\r\ncount = sg_dma_len(sg);\r\nif ((data->blocks == 1) && (count > data->blksz))\r\ncount = frame;\r\nhost->dma_len = count;\r\nif (cpu_is_omap15xx() && frame > 32)\r\nframe = 32;\r\nelse if (frame > 64)\r\nframe = 64;\r\ncount /= frame;\r\nframe >>= 1;\r\nif (!(data->flags & MMC_DATA_WRITE)) {\r\nbuf = 0x800f | ((frame - 1) << 8);\r\nif (cpu_class_is_omap1()) {\r\nsrc_port = OMAP_DMA_PORT_TIPB;\r\ndst_port = OMAP_DMA_PORT_EMIFF;\r\n}\r\nif (cpu_is_omap24xx())\r\nsync_dev = OMAP24XX_DMA_MMC1_RX;\r\nomap_set_dma_src_params(dma_ch, src_port,\r\nOMAP_DMA_AMODE_CONSTANT,\r\ndata_addr, 0, 0);\r\nomap_set_dma_dest_params(dma_ch, dst_port,\r\nOMAP_DMA_AMODE_POST_INC,\r\nsg_dma_address(sg), 0, 0);\r\nomap_set_dma_dest_data_pack(dma_ch, 1);\r\nomap_set_dma_dest_burst_mode(dma_ch, OMAP_DMA_DATA_BURST_4);\r\n} else {\r\nbuf = 0x0f80 | ((frame - 1) << 0);\r\nif (cpu_class_is_omap1()) {\r\nsrc_port = OMAP_DMA_PORT_EMIFF;\r\ndst_port = OMAP_DMA_PORT_TIPB;\r\n}\r\nif (cpu_is_omap24xx())\r\nsync_dev = OMAP24XX_DMA_MMC1_TX;\r\nomap_set_dma_dest_params(dma_ch, dst_port,\r\nOMAP_DMA_AMODE_CONSTANT,\r\ndata_addr, 0, 0);\r\nomap_set_dma_src_params(dma_ch, src_port,\r\nOMAP_DMA_AMODE_POST_INC,\r\nsg_dma_address(sg), 0, 0);\r\nomap_set_dma_src_data_pack(dma_ch, 1);\r\nomap_set_dma_src_burst_mode(dma_ch, OMAP_DMA_DATA_BURST_4);\r\n}\r\nBUG_ON(count > 0xffff);\r\nOMAP_MMC_WRITE(host, BUF, buf);\r\nomap_set_dma_transfer_params(dma_ch, OMAP_DMA_DATA_TYPE_S16,\r\nframe, count, OMAP_DMA_SYNC_FRAME,\r\nsync_dev, 0);\r\n}\r\nstatic void mmc_omap_dma_cb(int lch, u16 ch_status, void *data)\r\n{\r\nstruct mmc_omap_host *host = (struct mmc_omap_host *) data;\r\nstruct mmc_data *mmcdat = host->data;\r\nif (unlikely(host->dma_ch < 0)) {\r\ndev_err(mmc_dev(host->mmc),\r\n"DMA callback while DMA not enabled\n");\r\nreturn;\r\n}\r\nif (ch_status & OMAP1_DMA_TOUT_IRQ) {\r\ndev_err(mmc_dev(host->mmc),"DMA timeout\n");\r\nreturn;\r\n}\r\nif (ch_status & OMAP_DMA_DROP_IRQ) {\r\ndev_err(mmc_dev(host->mmc), "DMA sync error\n");\r\nreturn;\r\n}\r\nif (!(ch_status & OMAP_DMA_BLOCK_IRQ)) {\r\nreturn;\r\n}\r\nmmcdat->bytes_xfered += host->dma_len;\r\nhost->sg_idx++;\r\nif (host->sg_idx < host->sg_len) {\r\nmmc_omap_prepare_dma(host, host->data);\r\nomap_start_dma(host->dma_ch);\r\n} else\r\nmmc_omap_dma_done(host, host->data);\r\n}\r\nstatic int mmc_omap_get_dma_channel(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nconst char *dma_dev_name;\r\nint sync_dev, dma_ch, is_read, r;\r\nis_read = !(data->flags & MMC_DATA_WRITE);\r\ndel_timer_sync(&host->dma_timer);\r\nif (host->dma_ch >= 0) {\r\nif (is_read == host->dma_is_read)\r\nreturn 0;\r\nomap_free_dma(host->dma_ch);\r\nhost->dma_ch = -1;\r\n}\r\nif (is_read) {\r\nif (host->id == 0) {\r\nsync_dev = OMAP_DMA_MMC_RX;\r\ndma_dev_name = "MMC1 read";\r\n} else {\r\nsync_dev = OMAP_DMA_MMC2_RX;\r\ndma_dev_name = "MMC2 read";\r\n}\r\n} else {\r\nif (host->id == 0) {\r\nsync_dev = OMAP_DMA_MMC_TX;\r\ndma_dev_name = "MMC1 write";\r\n} else {\r\nsync_dev = OMAP_DMA_MMC2_TX;\r\ndma_dev_name = "MMC2 write";\r\n}\r\n}\r\nr = omap_request_dma(sync_dev, dma_dev_name, mmc_omap_dma_cb,\r\nhost, &dma_ch);\r\nif (r != 0) {\r\ndev_dbg(mmc_dev(host->mmc), "omap_request_dma() failed with %d\n", r);\r\nreturn r;\r\n}\r\nhost->dma_ch = dma_ch;\r\nhost->dma_is_read = is_read;\r\nreturn 0;\r\n}\r\nstatic inline void set_cmd_timeout(struct mmc_omap_host *host, struct mmc_request *req)\r\n{\r\nu16 reg;\r\nreg = OMAP_MMC_READ(host, SDIO);\r\nreg &= ~(1 << 5);\r\nOMAP_MMC_WRITE(host, SDIO, reg);\r\nOMAP_MMC_WRITE(host, CTO, 0xff);\r\n}\r\nstatic inline void set_data_timeout(struct mmc_omap_host *host, struct mmc_request *req)\r\n{\r\nunsigned int timeout, cycle_ns;\r\nu16 reg;\r\ncycle_ns = 1000000000 / host->current_slot->fclk_freq;\r\ntimeout = req->data->timeout_ns / cycle_ns;\r\ntimeout += req->data->timeout_clks;\r\nreg = OMAP_MMC_READ(host, SDIO);\r\nif (timeout > 0xffff) {\r\nreg |= (1 << 5);\r\ntimeout /= 1024;\r\n} else\r\nreg &= ~(1 << 5);\r\nOMAP_MMC_WRITE(host, SDIO, reg);\r\nOMAP_MMC_WRITE(host, DTO, timeout);\r\n}\r\nstatic void\r\nmmc_omap_prepare_data(struct mmc_omap_host *host, struct mmc_request *req)\r\n{\r\nstruct mmc_data *data = req->data;\r\nint i, use_dma, block_size;\r\nunsigned sg_len;\r\nhost->data = data;\r\nif (data == NULL) {\r\nOMAP_MMC_WRITE(host, BLEN, 0);\r\nOMAP_MMC_WRITE(host, NBLK, 0);\r\nOMAP_MMC_WRITE(host, BUF, 0);\r\nhost->dma_in_use = 0;\r\nset_cmd_timeout(host, req);\r\nreturn;\r\n}\r\nblock_size = data->blksz;\r\nOMAP_MMC_WRITE(host, NBLK, data->blocks - 1);\r\nOMAP_MMC_WRITE(host, BLEN, block_size - 1);\r\nset_data_timeout(host, req);\r\nsg_len = (data->blocks == 1) ? 1 : data->sg_len;\r\nuse_dma = host->use_dma;\r\nif (use_dma) {\r\nfor (i = 0; i < sg_len; i++) {\r\nif ((data->sg[i].length % block_size) != 0) {\r\nuse_dma = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nhost->sg_idx = 0;\r\nif (use_dma) {\r\nif (mmc_omap_get_dma_channel(host, data) == 0) {\r\nenum dma_data_direction dma_data_dir;\r\nif (data->flags & MMC_DATA_WRITE)\r\ndma_data_dir = DMA_TO_DEVICE;\r\nelse\r\ndma_data_dir = DMA_FROM_DEVICE;\r\nhost->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg,\r\nsg_len, dma_data_dir);\r\nhost->total_bytes_left = 0;\r\nmmc_omap_prepare_dma(host, req->data);\r\nhost->brs_received = 0;\r\nhost->dma_done = 0;\r\nhost->dma_in_use = 1;\r\n} else\r\nuse_dma = 0;\r\n}\r\nif (!use_dma) {\r\nOMAP_MMC_WRITE(host, BUF, 0x1f1f);\r\nhost->total_bytes_left = data->blocks * block_size;\r\nhost->sg_len = sg_len;\r\nmmc_omap_sg_to_buf(host);\r\nhost->dma_in_use = 0;\r\n}\r\n}\r\nstatic void mmc_omap_start_request(struct mmc_omap_host *host,\r\nstruct mmc_request *req)\r\n{\r\nBUG_ON(host->mrq != NULL);\r\nhost->mrq = req;\r\nmmc_omap_prepare_data(host, req);\r\nmmc_omap_start_command(host, req->cmd);\r\nif (host->dma_in_use)\r\nomap_start_dma(host->dma_ch);\r\n}\r\nstatic void mmc_omap_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nstruct mmc_omap_host *host = slot->host;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\nif (host->mmc != NULL) {\r\nBUG_ON(slot->mrq != NULL);\r\nslot->mrq = req;\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nreturn;\r\n} else\r\nhost->mmc = mmc;\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nmmc_omap_select_slot(slot, 1);\r\nmmc_omap_start_request(host, req);\r\n}\r\nstatic void mmc_omap_set_power(struct mmc_omap_slot *slot, int power_on,\r\nint vdd)\r\n{\r\nstruct mmc_omap_host *host;\r\nhost = slot->host;\r\nif (slot->pdata->set_power != NULL)\r\nslot->pdata->set_power(mmc_dev(slot->mmc), slot->id, power_on,\r\nvdd);\r\nif (cpu_is_omap24xx()) {\r\nu16 w;\r\nif (power_on) {\r\nw = OMAP_MMC_READ(host, CON);\r\nOMAP_MMC_WRITE(host, CON, w | (1 << 11));\r\n} else {\r\nw = OMAP_MMC_READ(host, CON);\r\nOMAP_MMC_WRITE(host, CON, w & ~(1 << 11));\r\n}\r\n}\r\n}\r\nstatic int mmc_omap_calc_divisor(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nstruct mmc_omap_host *host = slot->host;\r\nint func_clk_rate = clk_get_rate(host->fclk);\r\nint dsor;\r\nif (ios->clock == 0)\r\nreturn 0;\r\ndsor = func_clk_rate / ios->clock;\r\nif (dsor < 1)\r\ndsor = 1;\r\nif (func_clk_rate / dsor > ios->clock)\r\ndsor++;\r\nif (dsor > 250)\r\ndsor = 250;\r\nslot->fclk_freq = func_clk_rate / dsor;\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\ndsor |= 1 << 15;\r\nreturn dsor;\r\n}\r\nstatic void mmc_omap_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nstruct mmc_omap_host *host = slot->host;\r\nint i, dsor;\r\nint clk_enabled;\r\nmmc_omap_select_slot(slot, 0);\r\ndsor = mmc_omap_calc_divisor(mmc, ios);\r\nif (ios->vdd != slot->vdd)\r\nslot->vdd = ios->vdd;\r\nclk_enabled = 0;\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nmmc_omap_set_power(slot, 0, ios->vdd);\r\nbreak;\r\ncase MMC_POWER_UP:\r\nmmc_omap_set_power(slot, 1, ios->vdd);\r\ngoto exit;\r\ncase MMC_POWER_ON:\r\nmmc_omap_fclk_enable(host, 1);\r\nclk_enabled = 1;\r\ndsor |= 1 << 11;\r\nbreak;\r\n}\r\nif (slot->bus_mode != ios->bus_mode) {\r\nif (slot->pdata->set_bus_mode != NULL)\r\nslot->pdata->set_bus_mode(mmc_dev(mmc), slot->id,\r\nios->bus_mode);\r\nslot->bus_mode = ios->bus_mode;\r\n}\r\nfor (i = 0; i < 2; i++)\r\nOMAP_MMC_WRITE(host, CON, dsor);\r\nslot->saved_con = dsor;\r\nif (ios->power_mode == MMC_POWER_ON) {\r\nint usecs = 250;\r\nOMAP_MMC_WRITE(host, IE, 0);\r\nOMAP_MMC_WRITE(host, STAT, 0xffff);\r\nOMAP_MMC_WRITE(host, CMD, 1 << 7);\r\nwhile (usecs > 0 && (OMAP_MMC_READ(host, STAT) & 1) == 0) {\r\nudelay(1);\r\nusecs--;\r\n}\r\nOMAP_MMC_WRITE(host, STAT, 1);\r\n}\r\nexit:\r\nmmc_omap_release_slot(slot, clk_enabled);\r\n}\r\nstatic int __init mmc_omap_new_slot(struct mmc_omap_host *host, int id)\r\n{\r\nstruct mmc_omap_slot *slot = NULL;\r\nstruct mmc_host *mmc;\r\nint r;\r\nmmc = mmc_alloc_host(sizeof(struct mmc_omap_slot), host->dev);\r\nif (mmc == NULL)\r\nreturn -ENOMEM;\r\nslot = mmc_priv(mmc);\r\nslot->host = host;\r\nslot->mmc = mmc;\r\nslot->id = id;\r\nslot->pdata = &host->pdata->slots[id];\r\nhost->slots[id] = slot;\r\nmmc->caps = 0;\r\nif (host->pdata->slots[id].wires >= 4)\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nmmc->ops = &mmc_omap_ops;\r\nmmc->f_min = 400000;\r\nif (cpu_class_is_omap2())\r\nmmc->f_max = 48000000;\r\nelse\r\nmmc->f_max = 24000000;\r\nif (host->pdata->max_freq)\r\nmmc->f_max = min(host->pdata->max_freq, mmc->f_max);\r\nmmc->ocr_avail = slot->pdata->ocr_mask;\r\nmmc->max_segs = 32;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_blk_count = 2048;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nr = mmc_add_host(mmc);\r\nif (r < 0)\r\ngoto err_remove_host;\r\nif (slot->pdata->name != NULL) {\r\nr = device_create_file(&mmc->class_dev,\r\n&dev_attr_slot_name);\r\nif (r < 0)\r\ngoto err_remove_host;\r\n}\r\nif (slot->pdata->get_cover_state != NULL) {\r\nr = device_create_file(&mmc->class_dev,\r\n&dev_attr_cover_switch);\r\nif (r < 0)\r\ngoto err_remove_slot_name;\r\nsetup_timer(&slot->cover_timer, mmc_omap_cover_timer,\r\n(unsigned long)slot);\r\ntasklet_init(&slot->cover_tasklet, mmc_omap_cover_handler,\r\n(unsigned long)slot);\r\ntasklet_schedule(&slot->cover_tasklet);\r\n}\r\nreturn 0;\r\nerr_remove_slot_name:\r\nif (slot->pdata->name != NULL)\r\ndevice_remove_file(&mmc->class_dev, &dev_attr_slot_name);\r\nerr_remove_host:\r\nmmc_remove_host(mmc);\r\nmmc_free_host(mmc);\r\nreturn r;\r\n}\r\nstatic void mmc_omap_remove_slot(struct mmc_omap_slot *slot)\r\n{\r\nstruct mmc_host *mmc = slot->mmc;\r\nif (slot->pdata->name != NULL)\r\ndevice_remove_file(&mmc->class_dev, &dev_attr_slot_name);\r\nif (slot->pdata->get_cover_state != NULL)\r\ndevice_remove_file(&mmc->class_dev, &dev_attr_cover_switch);\r\ntasklet_kill(&slot->cover_tasklet);\r\ndel_timer_sync(&slot->cover_timer);\r\nflush_workqueue(mmc_omap_wq);\r\nmmc_remove_host(mmc);\r\nmmc_free_host(mmc);\r\n}\r\nstatic int __init mmc_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_mmc_platform_data *pdata = pdev->dev.platform_data;\r\nstruct mmc_omap_host *host = NULL;\r\nstruct resource *res;\r\nint i, ret = 0;\r\nint irq;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "platform data missing\n");\r\nreturn -ENXIO;\r\n}\r\nif (pdata->nr_slots == 0) {\r\ndev_err(&pdev->dev, "no slots\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (res == NULL || irq < 0)\r\nreturn -ENXIO;\r\nres = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (res == NULL)\r\nreturn -EBUSY;\r\nhost = kzalloc(sizeof(struct mmc_omap_host), GFP_KERNEL);\r\nif (host == NULL) {\r\nret = -ENOMEM;\r\ngoto err_free_mem_region;\r\n}\r\nINIT_WORK(&host->slot_release_work, mmc_omap_slot_release_work);\r\nINIT_WORK(&host->send_stop_work, mmc_omap_send_stop_work);\r\nINIT_WORK(&host->cmd_abort_work, mmc_omap_abort_command);\r\nsetup_timer(&host->cmd_abort_timer, mmc_omap_cmd_timer,\r\n(unsigned long) host);\r\nspin_lock_init(&host->clk_lock);\r\nsetup_timer(&host->clk_timer, mmc_omap_clk_timer, (unsigned long) host);\r\nspin_lock_init(&host->dma_lock);\r\nsetup_timer(&host->dma_timer, mmc_omap_dma_timer, (unsigned long) host);\r\nspin_lock_init(&host->slot_lock);\r\ninit_waitqueue_head(&host->slot_wq);\r\nhost->pdata = pdata;\r\nhost->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, host);\r\nhost->id = pdev->id;\r\nhost->mem_res = res;\r\nhost->irq = irq;\r\nhost->use_dma = 1;\r\nhost->dev->dma_mask = &pdata->dma_mask;\r\nhost->dma_ch = -1;\r\nhost->irq = irq;\r\nhost->phys_base = host->mem_res->start;\r\nhost->virt_base = ioremap(res->start, resource_size(res));\r\nif (!host->virt_base)\r\ngoto err_ioremap;\r\nhost->iclk = clk_get(&pdev->dev, "ick");\r\nif (IS_ERR(host->iclk)) {\r\nret = PTR_ERR(host->iclk);\r\ngoto err_free_mmc_host;\r\n}\r\nclk_enable(host->iclk);\r\nhost->fclk = clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(host->fclk)) {\r\nret = PTR_ERR(host->fclk);\r\ngoto err_free_iclk;\r\n}\r\nret = request_irq(host->irq, mmc_omap_irq, 0, DRIVER_NAME, host);\r\nif (ret)\r\ngoto err_free_fclk;\r\nif (pdata->init != NULL) {\r\nret = pdata->init(&pdev->dev);\r\nif (ret < 0)\r\ngoto err_free_irq;\r\n}\r\nhost->nr_slots = pdata->nr_slots;\r\nfor (i = 0; i < pdata->nr_slots; i++) {\r\nret = mmc_omap_new_slot(host, i);\r\nif (ret < 0) {\r\nwhile (--i >= 0)\r\nmmc_omap_remove_slot(host->slots[i]);\r\ngoto err_plat_cleanup;\r\n}\r\n}\r\nhost->reg_shift = (cpu_is_omap7xx() ? 1 : 2);\r\nreturn 0;\r\nerr_plat_cleanup:\r\nif (pdata->cleanup)\r\npdata->cleanup(&pdev->dev);\r\nerr_free_irq:\r\nfree_irq(host->irq, host);\r\nerr_free_fclk:\r\nclk_put(host->fclk);\r\nerr_free_iclk:\r\nclk_disable(host->iclk);\r\nclk_put(host->iclk);\r\nerr_free_mmc_host:\r\niounmap(host->virt_base);\r\nerr_ioremap:\r\nkfree(host);\r\nerr_free_mem_region:\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn ret;\r\n}\r\nstatic int mmc_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_omap_host *host = platform_get_drvdata(pdev);\r\nint i;\r\nplatform_set_drvdata(pdev, NULL);\r\nBUG_ON(host == NULL);\r\nfor (i = 0; i < host->nr_slots; i++)\r\nmmc_omap_remove_slot(host->slots[i]);\r\nif (host->pdata->cleanup)\r\nhost->pdata->cleanup(&pdev->dev);\r\nmmc_omap_fclk_enable(host, 0);\r\nfree_irq(host->irq, host);\r\nclk_put(host->fclk);\r\nclk_disable(host->iclk);\r\nclk_put(host->iclk);\r\niounmap(host->virt_base);\r\nrelease_mem_region(pdev->resource[0].start,\r\npdev->resource[0].end - pdev->resource[0].start + 1);\r\nkfree(host);\r\nreturn 0;\r\n}\r\nstatic int mmc_omap_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nint i, ret = 0;\r\nstruct mmc_omap_host *host = platform_get_drvdata(pdev);\r\nif (host == NULL || host->suspended)\r\nreturn 0;\r\nfor (i = 0; i < host->nr_slots; i++) {\r\nstruct mmc_omap_slot *slot;\r\nslot = host->slots[i];\r\nret = mmc_suspend_host(slot->mmc);\r\nif (ret < 0) {\r\nwhile (--i >= 0) {\r\nslot = host->slots[i];\r\nmmc_resume_host(slot->mmc);\r\n}\r\nreturn ret;\r\n}\r\n}\r\nhost->suspended = 1;\r\nreturn 0;\r\n}\r\nstatic int mmc_omap_resume(struct platform_device *pdev)\r\n{\r\nint i, ret = 0;\r\nstruct mmc_omap_host *host = platform_get_drvdata(pdev);\r\nif (host == NULL || !host->suspended)\r\nreturn 0;\r\nfor (i = 0; i < host->nr_slots; i++) {\r\nstruct mmc_omap_slot *slot;\r\nslot = host->slots[i];\r\nret = mmc_resume_host(slot->mmc);\r\nif (ret < 0)\r\nreturn ret;\r\nhost->suspended = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mmc_omap_init(void)\r\n{\r\nint ret;\r\nmmc_omap_wq = alloc_workqueue("mmc_omap", 0, 0);\r\nif (!mmc_omap_wq)\r\nreturn -ENOMEM;\r\nret = platform_driver_probe(&mmc_omap_driver, mmc_omap_probe);\r\nif (ret)\r\ndestroy_workqueue(mmc_omap_wq);\r\nreturn ret;\r\n}\r\nstatic void __exit mmc_omap_exit(void)\r\n{\r\nplatform_driver_unregister(&mmc_omap_driver);\r\ndestroy_workqueue(mmc_omap_wq);\r\n}
