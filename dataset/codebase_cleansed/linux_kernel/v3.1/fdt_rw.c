static int _fdt_blocks_misordered(const void *fdt,\r\nint mem_rsv_size, int struct_size)\r\n{\r\nreturn (fdt_off_mem_rsvmap(fdt) < FDT_ALIGN(sizeof(struct fdt_header), 8))\r\n|| (fdt_off_dt_struct(fdt) <\r\n(fdt_off_mem_rsvmap(fdt) + mem_rsv_size))\r\n|| (fdt_off_dt_strings(fdt) <\r\n(fdt_off_dt_struct(fdt) + struct_size))\r\n|| (fdt_totalsize(fdt) <\r\n(fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));\r\n}\r\nstatic int _fdt_rw_check_header(void *fdt)\r\n{\r\nFDT_CHECK_HEADER(fdt);\r\nif (fdt_version(fdt) < 17)\r\nreturn -FDT_ERR_BADVERSION;\r\nif (_fdt_blocks_misordered(fdt, sizeof(struct fdt_reserve_entry),\r\nfdt_size_dt_struct(fdt)))\r\nreturn -FDT_ERR_BADLAYOUT;\r\nif (fdt_version(fdt) > 17)\r\nfdt_set_version(fdt, 17);\r\nreturn 0;\r\n}\r\nstatic inline int _fdt_data_size(void *fdt)\r\n{\r\nreturn fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);\r\n}\r\nstatic int _fdt_splice(void *fdt, void *splicepoint, int oldlen, int newlen)\r\n{\r\nchar *p = splicepoint;\r\nchar *end = (char *)fdt + _fdt_data_size(fdt);\r\nif (((p + oldlen) < p) || ((p + oldlen) > end))\r\nreturn -FDT_ERR_BADOFFSET;\r\nif ((end - oldlen + newlen) > ((char *)fdt + fdt_totalsize(fdt)))\r\nreturn -FDT_ERR_NOSPACE;\r\nmemmove(p + newlen, p + oldlen, end - p - oldlen);\r\nreturn 0;\r\n}\r\nstatic int _fdt_splice_mem_rsv(void *fdt, struct fdt_reserve_entry *p,\r\nint oldn, int newn)\r\n{\r\nint delta = (newn - oldn) * sizeof(*p);\r\nint err;\r\nerr = _fdt_splice(fdt, p, oldn * sizeof(*p), newn * sizeof(*p));\r\nif (err)\r\nreturn err;\r\nfdt_set_off_dt_struct(fdt, fdt_off_dt_struct(fdt) + delta);\r\nfdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);\r\nreturn 0;\r\n}\r\nstatic int _fdt_splice_struct(void *fdt, void *p,\r\nint oldlen, int newlen)\r\n{\r\nint delta = newlen - oldlen;\r\nint err;\r\nif ((err = _fdt_splice(fdt, p, oldlen, newlen)))\r\nreturn err;\r\nfdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);\r\nfdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);\r\nreturn 0;\r\n}\r\nstatic int _fdt_splice_string(void *fdt, int newlen)\r\n{\r\nvoid *p = (char *)fdt\r\n+ fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);\r\nint err;\r\nif ((err = _fdt_splice(fdt, p, 0, newlen)))\r\nreturn err;\r\nfdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);\r\nreturn 0;\r\n}\r\nstatic int _fdt_find_add_string(void *fdt, const char *s)\r\n{\r\nchar *strtab = (char *)fdt + fdt_off_dt_strings(fdt);\r\nconst char *p;\r\nchar *new;\r\nint len = strlen(s) + 1;\r\nint err;\r\np = _fdt_find_string(strtab, fdt_size_dt_strings(fdt), s);\r\nif (p)\r\nreturn (p - strtab);\r\nnew = strtab + fdt_size_dt_strings(fdt);\r\nerr = _fdt_splice_string(fdt, len);\r\nif (err)\r\nreturn err;\r\nmemcpy(new, s, len);\r\nreturn (new - strtab);\r\n}\r\nint fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size)\r\n{\r\nstruct fdt_reserve_entry *re;\r\nint err;\r\nFDT_RW_CHECK_HEADER(fdt);\r\nre = _fdt_mem_rsv_w(fdt, fdt_num_mem_rsv(fdt));\r\nerr = _fdt_splice_mem_rsv(fdt, re, 0, 1);\r\nif (err)\r\nreturn err;\r\nre->address = cpu_to_fdt64(address);\r\nre->size = cpu_to_fdt64(size);\r\nreturn 0;\r\n}\r\nint fdt_del_mem_rsv(void *fdt, int n)\r\n{\r\nstruct fdt_reserve_entry *re = _fdt_mem_rsv_w(fdt, n);\r\nint err;\r\nFDT_RW_CHECK_HEADER(fdt);\r\nif (n >= fdt_num_mem_rsv(fdt))\r\nreturn -FDT_ERR_NOTFOUND;\r\nerr = _fdt_splice_mem_rsv(fdt, re, 1, 0);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int _fdt_resize_property(void *fdt, int nodeoffset, const char *name,\r\nint len, struct fdt_property **prop)\r\n{\r\nint oldlen;\r\nint err;\r\n*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);\r\nif (! (*prop))\r\nreturn oldlen;\r\nif ((err = _fdt_splice_struct(fdt, (*prop)->data, FDT_TAGALIGN(oldlen),\r\nFDT_TAGALIGN(len))))\r\nreturn err;\r\n(*prop)->len = cpu_to_fdt32(len);\r\nreturn 0;\r\n}\r\nstatic int _fdt_add_property(void *fdt, int nodeoffset, const char *name,\r\nint len, struct fdt_property **prop)\r\n{\r\nint proplen;\r\nint nextoffset;\r\nint namestroff;\r\nint err;\r\nif ((nextoffset = _fdt_check_node_offset(fdt, nodeoffset)) < 0)\r\nreturn nextoffset;\r\nnamestroff = _fdt_find_add_string(fdt, name);\r\nif (namestroff < 0)\r\nreturn namestroff;\r\n*prop = _fdt_offset_ptr_w(fdt, nextoffset);\r\nproplen = sizeof(**prop) + FDT_TAGALIGN(len);\r\nerr = _fdt_splice_struct(fdt, *prop, 0, proplen);\r\nif (err)\r\nreturn err;\r\n(*prop)->tag = cpu_to_fdt32(FDT_PROP);\r\n(*prop)->nameoff = cpu_to_fdt32(namestroff);\r\n(*prop)->len = cpu_to_fdt32(len);\r\nreturn 0;\r\n}\r\nint fdt_set_name(void *fdt, int nodeoffset, const char *name)\r\n{\r\nchar *namep;\r\nint oldlen, newlen;\r\nint err;\r\nFDT_RW_CHECK_HEADER(fdt);\r\nnamep = (char *)(uintptr_t)fdt_get_name(fdt, nodeoffset, &oldlen);\r\nif (!namep)\r\nreturn oldlen;\r\nnewlen = strlen(name);\r\nerr = _fdt_splice_struct(fdt, namep, FDT_TAGALIGN(oldlen+1),\r\nFDT_TAGALIGN(newlen+1));\r\nif (err)\r\nreturn err;\r\nmemcpy(namep, name, newlen+1);\r\nreturn 0;\r\n}\r\nint fdt_setprop(void *fdt, int nodeoffset, const char *name,\r\nconst void *val, int len)\r\n{\r\nstruct fdt_property *prop;\r\nint err;\r\nFDT_RW_CHECK_HEADER(fdt);\r\nerr = _fdt_resize_property(fdt, nodeoffset, name, len, &prop);\r\nif (err == -FDT_ERR_NOTFOUND)\r\nerr = _fdt_add_property(fdt, nodeoffset, name, len, &prop);\r\nif (err)\r\nreturn err;\r\nmemcpy(prop->data, val, len);\r\nreturn 0;\r\n}\r\nint fdt_delprop(void *fdt, int nodeoffset, const char *name)\r\n{\r\nstruct fdt_property *prop;\r\nint len, proplen;\r\nFDT_RW_CHECK_HEADER(fdt);\r\nprop = fdt_get_property_w(fdt, nodeoffset, name, &len);\r\nif (! prop)\r\nreturn len;\r\nproplen = sizeof(*prop) + FDT_TAGALIGN(len);\r\nreturn _fdt_splice_struct(fdt, prop, proplen, 0);\r\n}\r\nint fdt_add_subnode_namelen(void *fdt, int parentoffset,\r\nconst char *name, int namelen)\r\n{\r\nstruct fdt_node_header *nh;\r\nint offset, nextoffset;\r\nint nodelen;\r\nint err;\r\nuint32_t tag;\r\nuint32_t *endtag;\r\nFDT_RW_CHECK_HEADER(fdt);\r\noffset = fdt_subnode_offset_namelen(fdt, parentoffset, name, namelen);\r\nif (offset >= 0)\r\nreturn -FDT_ERR_EXISTS;\r\nelse if (offset != -FDT_ERR_NOTFOUND)\r\nreturn offset;\r\nfdt_next_tag(fdt, parentoffset, &nextoffset);\r\ndo {\r\noffset = nextoffset;\r\ntag = fdt_next_tag(fdt, offset, &nextoffset);\r\n} while ((tag == FDT_PROP) || (tag == FDT_NOP));\r\nnh = _fdt_offset_ptr_w(fdt, offset);\r\nnodelen = sizeof(*nh) + FDT_TAGALIGN(namelen+1) + FDT_TAGSIZE;\r\nerr = _fdt_splice_struct(fdt, nh, 0, nodelen);\r\nif (err)\r\nreturn err;\r\nnh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);\r\nmemset(nh->name, 0, FDT_TAGALIGN(namelen+1));\r\nmemcpy(nh->name, name, namelen);\r\nendtag = (uint32_t *)((char *)nh + nodelen - FDT_TAGSIZE);\r\n*endtag = cpu_to_fdt32(FDT_END_NODE);\r\nreturn offset;\r\n}\r\nint fdt_add_subnode(void *fdt, int parentoffset, const char *name)\r\n{\r\nreturn fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));\r\n}\r\nint fdt_del_node(void *fdt, int nodeoffset)\r\n{\r\nint endoffset;\r\nFDT_RW_CHECK_HEADER(fdt);\r\nendoffset = _fdt_node_end_offset(fdt, nodeoffset);\r\nif (endoffset < 0)\r\nreturn endoffset;\r\nreturn _fdt_splice_struct(fdt, _fdt_offset_ptr_w(fdt, nodeoffset),\r\nendoffset - nodeoffset, 0);\r\n}\r\nstatic void _fdt_packblocks(const char *old, char *new,\r\nint mem_rsv_size, int struct_size)\r\n{\r\nint mem_rsv_off, struct_off, strings_off;\r\nmem_rsv_off = FDT_ALIGN(sizeof(struct fdt_header), 8);\r\nstruct_off = mem_rsv_off + mem_rsv_size;\r\nstrings_off = struct_off + struct_size;\r\nmemmove(new + mem_rsv_off, old + fdt_off_mem_rsvmap(old), mem_rsv_size);\r\nfdt_set_off_mem_rsvmap(new, mem_rsv_off);\r\nmemmove(new + struct_off, old + fdt_off_dt_struct(old), struct_size);\r\nfdt_set_off_dt_struct(new, struct_off);\r\nfdt_set_size_dt_struct(new, struct_size);\r\nmemmove(new + strings_off, old + fdt_off_dt_strings(old),\r\nfdt_size_dt_strings(old));\r\nfdt_set_off_dt_strings(new, strings_off);\r\nfdt_set_size_dt_strings(new, fdt_size_dt_strings(old));\r\n}\r\nint fdt_open_into(const void *fdt, void *buf, int bufsize)\r\n{\r\nint err;\r\nint mem_rsv_size, struct_size;\r\nint newsize;\r\nconst char *fdtstart = fdt;\r\nconst char *fdtend = fdtstart + fdt_totalsize(fdt);\r\nchar *tmp;\r\nFDT_CHECK_HEADER(fdt);\r\nmem_rsv_size = (fdt_num_mem_rsv(fdt)+1)\r\n* sizeof(struct fdt_reserve_entry);\r\nif (fdt_version(fdt) >= 17) {\r\nstruct_size = fdt_size_dt_struct(fdt);\r\n} else {\r\nstruct_size = 0;\r\nwhile (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)\r\n;\r\n}\r\nif (!_fdt_blocks_misordered(fdt, mem_rsv_size, struct_size)) {\r\nerr = fdt_move(fdt, buf, bufsize);\r\nif (err)\r\nreturn err;\r\nfdt_set_version(buf, 17);\r\nfdt_set_size_dt_struct(buf, struct_size);\r\nfdt_set_totalsize(buf, bufsize);\r\nreturn 0;\r\n}\r\nnewsize = FDT_ALIGN(sizeof(struct fdt_header), 8) + mem_rsv_size\r\n+ struct_size + fdt_size_dt_strings(fdt);\r\nif (bufsize < newsize)\r\nreturn -FDT_ERR_NOSPACE;\r\ntmp = buf;\r\nif (((tmp + newsize) > fdtstart) && (tmp < fdtend)) {\r\ntmp = (char *)(uintptr_t)fdtend;\r\nif ((tmp + newsize) > ((char *)buf + bufsize))\r\nreturn -FDT_ERR_NOSPACE;\r\n}\r\n_fdt_packblocks(fdt, tmp, mem_rsv_size, struct_size);\r\nmemmove(buf, tmp, newsize);\r\nfdt_set_magic(buf, FDT_MAGIC);\r\nfdt_set_totalsize(buf, bufsize);\r\nfdt_set_version(buf, 17);\r\nfdt_set_last_comp_version(buf, 16);\r\nfdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));\r\nreturn 0;\r\n}\r\nint fdt_pack(void *fdt)\r\n{\r\nint mem_rsv_size;\r\nFDT_RW_CHECK_HEADER(fdt);\r\nmem_rsv_size = (fdt_num_mem_rsv(fdt)+1)\r\n* sizeof(struct fdt_reserve_entry);\r\n_fdt_packblocks(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));\r\nfdt_set_totalsize(fdt, _fdt_data_size(fdt));\r\nreturn 0;\r\n}
