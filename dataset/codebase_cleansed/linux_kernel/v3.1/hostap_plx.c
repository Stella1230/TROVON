static inline void hfa384x_outb_debug(struct net_device *dev, int a, u8 v)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nunsigned long flags;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nspin_lock_irqsave(&local->lock, flags);\r\nprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTB, a, v);\r\noutb(v, dev->base_addr + a);\r\nspin_unlock_irqrestore(&local->lock, flags);\r\n}\r\nstatic inline u8 hfa384x_inb_debug(struct net_device *dev, int a)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nunsigned long flags;\r\nu8 v;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nspin_lock_irqsave(&local->lock, flags);\r\nv = inb(dev->base_addr + a);\r\nprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INB, a, v);\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nreturn v;\r\n}\r\nstatic inline void hfa384x_outw_debug(struct net_device *dev, int a, u16 v)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nunsigned long flags;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nspin_lock_irqsave(&local->lock, flags);\r\nprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTW, a, v);\r\noutw(v, dev->base_addr + a);\r\nspin_unlock_irqrestore(&local->lock, flags);\r\n}\r\nstatic inline u16 hfa384x_inw_debug(struct net_device *dev, int a)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nunsigned long flags;\r\nu16 v;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nspin_lock_irqsave(&local->lock, flags);\r\nv = inw(dev->base_addr + a);\r\nprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INW, a, v);\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nreturn v;\r\n}\r\nstatic inline void hfa384x_outsw_debug(struct net_device *dev, int a,\r\nu8 *buf, int wc)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nunsigned long flags;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nspin_lock_irqsave(&local->lock, flags);\r\nprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTSW, a, wc);\r\noutsw(dev->base_addr + a, buf, wc);\r\nspin_unlock_irqrestore(&local->lock, flags);\r\n}\r\nstatic inline void hfa384x_insw_debug(struct net_device *dev, int a,\r\nu8 *buf, int wc)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nunsigned long flags;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nspin_lock_irqsave(&local->lock, flags);\r\nprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INSW, a, wc);\r\ninsw(dev->base_addr + a, buf, wc);\r\nspin_unlock_irqrestore(&local->lock, flags);\r\n}\r\nstatic int hfa384x_from_bap(struct net_device *dev, u16 bap, void *buf,\r\nint len)\r\n{\r\nu16 d_off;\r\nu16 *pos;\r\nd_off = (bap == 1) ? HFA384X_DATA1_OFF : HFA384X_DATA0_OFF;\r\npos = (u16 *) buf;\r\nif (len / 2)\r\nHFA384X_INSW(d_off, buf, len / 2);\r\npos += len / 2;\r\nif (len & 1)\r\n*((char *) pos) = HFA384X_INB(d_off);\r\nreturn 0;\r\n}\r\nstatic int hfa384x_to_bap(struct net_device *dev, u16 bap, void *buf, int len)\r\n{\r\nu16 d_off;\r\nu16 *pos;\r\nd_off = (bap == 1) ? HFA384X_DATA1_OFF : HFA384X_DATA0_OFF;\r\npos = (u16 *) buf;\r\nif (len / 2)\r\nHFA384X_OUTSW(d_off, buf, len / 2);\r\npos += len / 2;\r\nif (len & 1)\r\nHFA384X_OUTB(*((char *) pos), d_off);\r\nreturn 0;\r\n}\r\nstatic void prism2_plx_cor_sreset(local_info_t *local)\r\n{\r\nunsigned char corsave;\r\nstruct hostap_plx_priv *hw_priv = local->hw_priv;\r\nprintk(KERN_DEBUG "%s: Doing reset via direct COR access.\n",\r\ndev_info);\r\nif (hw_priv->attr_mem == NULL) {\r\ncorsave = inb(hw_priv->cor_offset);\r\noutb(corsave | COR_SRESET, hw_priv->cor_offset);\r\nmdelay(2);\r\noutb(corsave & ~COR_SRESET, hw_priv->cor_offset);\r\nmdelay(2);\r\n} else {\r\ncorsave = readb(hw_priv->attr_mem + hw_priv->cor_offset);\r\nwriteb(corsave | COR_SRESET,\r\nhw_priv->attr_mem + hw_priv->cor_offset);\r\nmdelay(2);\r\nwriteb(corsave & ~COR_SRESET,\r\nhw_priv->attr_mem + hw_priv->cor_offset);\r\nmdelay(2);\r\n}\r\n}\r\nstatic void prism2_plx_genesis_reset(local_info_t *local, int hcr)\r\n{\r\nunsigned char corsave;\r\nstruct hostap_plx_priv *hw_priv = local->hw_priv;\r\nif (hw_priv->attr_mem == NULL) {\r\ncorsave = inb(hw_priv->cor_offset);\r\noutb(corsave | COR_SRESET, hw_priv->cor_offset);\r\nmdelay(10);\r\noutb(hcr, hw_priv->cor_offset + 2);\r\nmdelay(10);\r\noutb(corsave & ~COR_SRESET, hw_priv->cor_offset);\r\nmdelay(10);\r\n} else {\r\ncorsave = readb(hw_priv->attr_mem + hw_priv->cor_offset);\r\nwriteb(corsave | COR_SRESET,\r\nhw_priv->attr_mem + hw_priv->cor_offset);\r\nmdelay(10);\r\nwriteb(hcr, hw_priv->attr_mem + hw_priv->cor_offset + 2);\r\nmdelay(10);\r\nwriteb(corsave & ~COR_SRESET,\r\nhw_priv->attr_mem + hw_priv->cor_offset);\r\nmdelay(10);\r\n}\r\n}\r\nstatic int prism2_plx_check_cis(void __iomem *attr_mem, int attr_len,\r\nunsigned int *cor_offset,\r\nunsigned int *cor_index)\r\n{\r\n#define CISTPL_CONFIG 0x1A\r\n#define CISTPL_MANFID 0x20\r\n#define CISTPL_END 0xFF\r\n#define CIS_MAX_LEN 256\r\nu8 *cis;\r\nint i, pos;\r\nunsigned int rmsz, rasz, manfid1, manfid2;\r\nstruct prism2_plx_manfid *manfid;\r\ncis = kmalloc(CIS_MAX_LEN, GFP_KERNEL);\r\nif (cis == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < CIS_MAX_LEN; i++)\r\ncis[i] = readb(attr_mem + 2 * i);\r\nprintk(KERN_DEBUG "%s: CIS: %02x %02x %02x %02x %02x %02x ...\n",\r\ndev_info, cis[0], cis[1], cis[2], cis[3], cis[4], cis[5]);\r\n*cor_offset = 0x3e0;\r\n*cor_index = 0x01;\r\nmanfid1 = manfid2 = 0;\r\npos = 0;\r\nwhile (pos < CIS_MAX_LEN - 1 && cis[pos] != CISTPL_END) {\r\nif (pos + 2 + cis[pos + 1] > CIS_MAX_LEN)\r\ngoto cis_error;\r\nswitch (cis[pos]) {\r\ncase CISTPL_CONFIG:\r\nif (cis[pos + 1] < 2)\r\ngoto cis_error;\r\nrmsz = (cis[pos + 2] & 0x3c) >> 2;\r\nrasz = cis[pos + 2] & 0x03;\r\nif (4 + rasz + rmsz > cis[pos + 1])\r\ngoto cis_error;\r\n*cor_index = cis[pos + 3] & 0x3F;\r\n*cor_offset = 0;\r\nfor (i = 0; i <= rasz; i++)\r\n*cor_offset += cis[pos + 4 + i] << (8 * i);\r\nprintk(KERN_DEBUG "%s: cor_index=0x%x "\r\n"cor_offset=0x%x\n", dev_info,\r\n*cor_index, *cor_offset);\r\nif (*cor_offset > attr_len) {\r\nprintk(KERN_ERR "%s: COR offset not within "\r\n"attr_mem\n", dev_info);\r\nkfree(cis);\r\nreturn -1;\r\n}\r\nbreak;\r\ncase CISTPL_MANFID:\r\nif (cis[pos + 1] < 4)\r\ngoto cis_error;\r\nmanfid1 = cis[pos + 2] + (cis[pos + 3] << 8);\r\nmanfid2 = cis[pos + 4] + (cis[pos + 5] << 8);\r\nprintk(KERN_DEBUG "%s: manfid=0x%04x, 0x%04x\n",\r\ndev_info, manfid1, manfid2);\r\nbreak;\r\n}\r\npos += cis[pos + 1] + 2;\r\n}\r\nif (pos >= CIS_MAX_LEN || cis[pos] != CISTPL_END)\r\ngoto cis_error;\r\nfor (manfid = prism2_plx_known_manfids; manfid->manfid1 != 0; manfid++)\r\nif (manfid1 == manfid->manfid1 && manfid2 == manfid->manfid2) {\r\nkfree(cis);\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "%s: unknown manfid 0x%04x, 0x%04x - assuming this is"\r\n" not supported card\n", dev_info, manfid1, manfid2);\r\ngoto fail;\r\ncis_error:\r\nprintk(KERN_WARNING "%s: invalid CIS data\n", dev_info);\r\nfail:\r\nkfree(cis);\r\nif (ignore_cis) {\r\nprintk(KERN_INFO "%s: ignore_cis parameter set - ignoring "\r\n"errors during CIS verification\n", dev_info);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int prism2_plx_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned int pccard_ioaddr, plx_ioaddr;\r\nunsigned long pccard_attr_mem;\r\nunsigned int pccard_attr_len;\r\nvoid __iomem *attr_mem = NULL;\r\nunsigned int cor_offset = 0, cor_index = 0;\r\nu32 reg;\r\nlocal_info_t *local = NULL;\r\nstruct net_device *dev = NULL;\r\nstruct hostap_interface *iface;\r\nstatic int cards_found ;\r\nint irq_registered = 0;\r\nint tmd7160;\r\nstruct hostap_plx_priv *hw_priv;\r\nhw_priv = kzalloc(sizeof(*hw_priv), GFP_KERNEL);\r\nif (hw_priv == NULL)\r\nreturn -ENOMEM;\r\nif (pci_enable_device(pdev))\r\ngoto err_out_free;\r\ntmd7160 = (pdev->vendor == 0x15e8) && (pdev->device == 0x0131);\r\nplx_ioaddr = pci_resource_start(pdev, 1);\r\npccard_ioaddr = pci_resource_start(pdev, tmd7160 ? 2 : 3);\r\nif (tmd7160) {\r\nattr_mem = NULL;\r\nprintk(KERN_INFO "TMD7160 PCI/PCMCIA adapter: io=0x%x, "\r\n"irq=%d, pccard_io=0x%x\n",\r\nplx_ioaddr, pdev->irq, pccard_ioaddr);\r\ncor_offset = plx_ioaddr;\r\ncor_index = 0x04;\r\noutb(cor_index | COR_LEVLREQ | COR_ENABLE_FUNC, plx_ioaddr);\r\nmdelay(1);\r\nreg = inb(plx_ioaddr);\r\nif (reg != (cor_index | COR_LEVLREQ | COR_ENABLE_FUNC)) {\r\nprintk(KERN_ERR "%s: Error setting COR (expected="\r\n"0x%02x, was=0x%02x)\n", dev_info,\r\ncor_index | COR_LEVLREQ | COR_ENABLE_FUNC, reg);\r\ngoto fail;\r\n}\r\n} else {\r\npccard_attr_mem = pci_resource_start(pdev, 2);\r\npccard_attr_len = pci_resource_len(pdev, 2);\r\nif (pccard_attr_len < PLX_MIN_ATTR_LEN)\r\ngoto fail;\r\nattr_mem = ioremap(pccard_attr_mem, pccard_attr_len);\r\nif (attr_mem == NULL) {\r\nprintk(KERN_ERR "%s: cannot remap attr_mem\n",\r\ndev_info);\r\ngoto fail;\r\n}\r\nprintk(KERN_INFO "PLX9052 PCI/PCMCIA adapter: "\r\n"mem=0x%lx, plx_io=0x%x, irq=%d, pccard_io=0x%x\n",\r\npccard_attr_mem, plx_ioaddr, pdev->irq, pccard_ioaddr);\r\nif (prism2_plx_check_cis(attr_mem, pccard_attr_len,\r\n&cor_offset, &cor_index)) {\r\nprintk(KERN_INFO "Unknown PC Card CIS - not a "\r\n"Prism2/2.5 card?\n");\r\ngoto fail;\r\n}\r\nprintk(KERN_DEBUG "Prism2/2.5 PC Card detected in PLX9052 "\r\n"adapter\n");\r\nwriteb(cor_index | COR_LEVLREQ | COR_ENABLE_FUNC,\r\nattr_mem + cor_offset);\r\nreg = inl(plx_ioaddr + PLX_INTCSR);\r\nprintk(KERN_DEBUG "PLX_INTCSR=0x%x\n", reg);\r\nif (!(reg & PLX_INTCSR_PCI_INTEN)) {\r\noutl(reg | PLX_INTCSR_PCI_INTEN,\r\nplx_ioaddr + PLX_INTCSR);\r\nif (!(inl(plx_ioaddr + PLX_INTCSR) &\r\nPLX_INTCSR_PCI_INTEN)) {\r\nprintk(KERN_WARNING "%s: Could not enable "\r\n"Local Interrupts\n", dev_info);\r\ngoto fail;\r\n}\r\n}\r\nreg = inl(plx_ioaddr + PLX_CNTRL);\r\nprintk(KERN_DEBUG "PLX_CNTRL=0x%x (Serial EEPROM "\r\n"present=%d)\n",\r\nreg, (reg & PLX_CNTRL_SERIAL_EEPROM_PRESENT) != 0);\r\n}\r\ndev = prism2_init_local_data(&prism2_plx_funcs, cards_found,\r\n&pdev->dev);\r\nif (dev == NULL)\r\ngoto fail;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nlocal->hw_priv = hw_priv;\r\ncards_found++;\r\ndev->irq = pdev->irq;\r\ndev->base_addr = pccard_ioaddr;\r\nhw_priv->attr_mem = attr_mem;\r\nhw_priv->cor_offset = cor_offset;\r\npci_set_drvdata(pdev, dev);\r\nif (request_irq(dev->irq, prism2_interrupt, IRQF_SHARED, dev->name,\r\ndev)) {\r\nprintk(KERN_WARNING "%s: request_irq failed\n", dev->name);\r\ngoto fail;\r\n} else\r\nirq_registered = 1;\r\nif (prism2_hw_config(dev, 1)) {\r\nprintk(KERN_DEBUG "%s: hardware initialization failed\n",\r\ndev_info);\r\ngoto fail;\r\n}\r\nreturn hostap_hw_ready(dev);\r\nfail:\r\nif (irq_registered && dev)\r\nfree_irq(dev->irq, dev);\r\nif (attr_mem)\r\niounmap(attr_mem);\r\npci_disable_device(pdev);\r\nprism2_free_local_data(dev);\r\nerr_out_free:\r\nkfree(hw_priv);\r\nreturn -ENODEV;\r\n}\r\nstatic void prism2_plx_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct hostap_interface *iface;\r\nstruct hostap_plx_priv *hw_priv;\r\ndev = pci_get_drvdata(pdev);\r\niface = netdev_priv(dev);\r\nhw_priv = iface->local->hw_priv;\r\nprism2_plx_cor_sreset(iface->local);\r\nhfa384x_disable_interrupts(dev);\r\nif (hw_priv->attr_mem)\r\niounmap(hw_priv->attr_mem);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nprism2_free_local_data(dev);\r\nkfree(hw_priv);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init init_prism2_plx(void)\r\n{\r\nreturn pci_register_driver(&prism2_plx_driver);\r\n}\r\nstatic void __exit exit_prism2_plx(void)\r\n{\r\npci_unregister_driver(&prism2_plx_driver);\r\n}
