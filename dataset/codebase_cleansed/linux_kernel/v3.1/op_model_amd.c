static u32 get_ibs_caps(void)\r\n{\r\nu32 ibs_caps;\r\nunsigned int max_level;\r\nif (!boot_cpu_has(X86_FEATURE_IBS))\r\nreturn 0;\r\nmax_level = cpuid_eax(0x80000000);\r\nif (max_level < IBS_CPUID_FEATURES)\r\nreturn IBS_CAPS_DEFAULT;\r\nibs_caps = cpuid_eax(IBS_CPUID_FEATURES);\r\nif (!(ibs_caps & IBS_CAPS_AVAIL))\r\nreturn IBS_CAPS_DEFAULT;\r\nreturn ibs_caps;\r\n}\r\nstatic unsigned int lfsr_random(void)\r\n{\r\nstatic unsigned int lfsr_value = 0xF00D;\r\nunsigned int bit;\r\nbit = ((lfsr_value >> 0) ^\r\n(lfsr_value >> 2) ^\r\n(lfsr_value >> 3) ^\r\n(lfsr_value >> 5)) & 0x0001;\r\nlfsr_value = (lfsr_value >> 1) | (bit << 15);\r\nreturn lfsr_value;\r\n}\r\nstatic inline u64 op_amd_randomize_ibs_op(u64 val)\r\n{\r\nunsigned int random = lfsr_random();\r\nif (!(ibs_caps & IBS_CAPS_RDWROPCNT))\r\nval += (s8)(random >> 4);\r\nelse\r\nval |= (u64)(random & IBS_RANDOM_MASK) << 32;\r\nreturn val;\r\n}\r\nstatic inline void\r\nop_amd_handle_ibs(struct pt_regs * const regs,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val, ctl;\r\nstruct op_entry entry;\r\nif (!ibs_caps)\r\nreturn;\r\nif (ibs_config.fetch_enabled) {\r\nrdmsrl(MSR_AMD64_IBSFETCHCTL, ctl);\r\nif (ctl & IBS_FETCH_VAL) {\r\nrdmsrl(MSR_AMD64_IBSFETCHLINAD, val);\r\noprofile_write_reserve(&entry, regs, val,\r\nIBS_FETCH_CODE, IBS_FETCH_SIZE);\r\noprofile_add_data64(&entry, val);\r\noprofile_add_data64(&entry, ctl);\r\nrdmsrl(MSR_AMD64_IBSFETCHPHYSAD, val);\r\noprofile_add_data64(&entry, val);\r\noprofile_write_commit(&entry);\r\nctl &= ~(IBS_FETCH_VAL | IBS_FETCH_CNT);\r\nctl |= IBS_FETCH_ENABLE;\r\nwrmsrl(MSR_AMD64_IBSFETCHCTL, ctl);\r\n}\r\n}\r\nif (ibs_config.op_enabled) {\r\nrdmsrl(MSR_AMD64_IBSOPCTL, ctl);\r\nif (ctl & IBS_OP_VAL) {\r\nrdmsrl(MSR_AMD64_IBSOPRIP, val);\r\noprofile_write_reserve(&entry, regs, val, IBS_OP_CODE,\r\nibs_state.sample_size);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSOPDATA, val);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSOPDATA2, val);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSOPDATA3, val);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSDCLINAD, val);\r\noprofile_add_data64(&entry, val);\r\nrdmsrl(MSR_AMD64_IBSDCPHYSAD, val);\r\noprofile_add_data64(&entry, val);\r\nif (ibs_state.branch_target) {\r\nrdmsrl(MSR_AMD64_IBSBRTARGET, val);\r\noprofile_add_data(&entry, (unsigned long)val);\r\n}\r\noprofile_write_commit(&entry);\r\nctl = op_amd_randomize_ibs_op(ibs_state.ibs_op_ctl);\r\nwrmsrl(MSR_AMD64_IBSOPCTL, ctl);\r\n}\r\n}\r\n}\r\nstatic inline void op_amd_start_ibs(void)\r\n{\r\nu64 val;\r\nif (!ibs_caps)\r\nreturn;\r\nmemset(&ibs_state, 0, sizeof(ibs_state));\r\nif (ibs_config.fetch_enabled) {\r\nval = ibs_config.max_cnt_fetch >> 4;\r\nval = min(val, IBS_FETCH_MAX_CNT);\r\nibs_config.max_cnt_fetch = val << 4;\r\nval |= ibs_config.rand_en ? IBS_FETCH_RAND_EN : 0;\r\nval |= IBS_FETCH_ENABLE;\r\nwrmsrl(MSR_AMD64_IBSFETCHCTL, val);\r\n}\r\nif (ibs_config.op_enabled) {\r\nval = ibs_config.max_cnt_op >> 4;\r\nif (!(ibs_caps & IBS_CAPS_RDWROPCNT)) {\r\nval = clamp(val, 0x0081ULL, 0xFF80ULL);\r\nibs_config.max_cnt_op = val << 4;\r\n} else {\r\nval += IBS_RANDOM_MAXCNT_OFFSET;\r\nif (ibs_caps & IBS_CAPS_OPCNTEXT)\r\nval = min(val, IBS_OP_MAX_CNT_EXT);\r\nelse\r\nval = min(val, IBS_OP_MAX_CNT);\r\nibs_config.max_cnt_op =\r\n(val - IBS_RANDOM_MAXCNT_OFFSET) << 4;\r\n}\r\nval = ((val & ~IBS_OP_MAX_CNT) << 4) | (val & IBS_OP_MAX_CNT);\r\nval |= ibs_config.dispatched_ops ? IBS_OP_CNT_CTL : 0;\r\nval |= IBS_OP_ENABLE;\r\nibs_state.ibs_op_ctl = val;\r\nibs_state.sample_size = IBS_OP_SIZE;\r\nif (ibs_config.branch_target) {\r\nibs_state.branch_target = 1;\r\nibs_state.sample_size++;\r\n}\r\nval = op_amd_randomize_ibs_op(ibs_state.ibs_op_ctl);\r\nwrmsrl(MSR_AMD64_IBSOPCTL, val);\r\n}\r\n}\r\nstatic void op_amd_stop_ibs(void)\r\n{\r\nif (!ibs_caps)\r\nreturn;\r\nif (ibs_config.fetch_enabled)\r\nwrmsrl(MSR_AMD64_IBSFETCHCTL, 0);\r\nif (ibs_config.op_enabled)\r\nwrmsrl(MSR_AMD64_IBSOPCTL, 0);\r\n}\r\nstatic inline int get_eilvt(int offset)\r\n{\r\nreturn !setup_APIC_eilvt(offset, 0, APIC_EILVT_MSG_NMI, 1);\r\n}\r\nstatic inline int put_eilvt(int offset)\r\n{\r\nreturn !setup_APIC_eilvt(offset, 0, 0, 1);\r\n}\r\nstatic inline int ibs_eilvt_valid(void)\r\n{\r\nint offset;\r\nu64 val;\r\nint valid = 0;\r\npreempt_disable();\r\nrdmsrl(MSR_AMD64_IBSCTL, val);\r\noffset = val & IBSCTL_LVT_OFFSET_MASK;\r\nif (!(val & IBSCTL_LVT_OFFSET_VALID)) {\r\npr_err(FW_BUG "cpu %d, invalid IBS interrupt offset %d (MSR%08X=0x%016llx)\n",\r\nsmp_processor_id(), offset, MSR_AMD64_IBSCTL, val);\r\ngoto out;\r\n}\r\nif (!get_eilvt(offset)) {\r\npr_err(FW_BUG "cpu %d, IBS interrupt offset %d not available (MSR%08X=0x%016llx)\n",\r\nsmp_processor_id(), offset, MSR_AMD64_IBSCTL, val);\r\ngoto out;\r\n}\r\nvalid = 1;\r\nout:\r\npreempt_enable();\r\nreturn valid;\r\n}\r\nstatic inline int get_ibs_offset(void)\r\n{\r\nu64 val;\r\nrdmsrl(MSR_AMD64_IBSCTL, val);\r\nif (!(val & IBSCTL_LVT_OFFSET_VALID))\r\nreturn -EINVAL;\r\nreturn val & IBSCTL_LVT_OFFSET_MASK;\r\n}\r\nstatic void setup_APIC_ibs(void)\r\n{\r\nint offset;\r\noffset = get_ibs_offset();\r\nif (offset < 0)\r\ngoto failed;\r\nif (!setup_APIC_eilvt(offset, 0, APIC_EILVT_MSG_NMI, 0))\r\nreturn;\r\nfailed:\r\npr_warn("oprofile: IBS APIC setup failed on cpu #%d\n",\r\nsmp_processor_id());\r\n}\r\nstatic void clear_APIC_ibs(void)\r\n{\r\nint offset;\r\noffset = get_ibs_offset();\r\nif (offset >= 0)\r\nsetup_APIC_eilvt(offset, 0, APIC_EILVT_MSG_FIX, 1);\r\n}\r\nstatic void op_mux_switch_ctrl(struct op_x86_model_spec const *model,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nint virt = op_x86_phys_to_virt(i);\r\nif (!reset_value[virt])\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval &= model->reserved;\r\nval |= op_x86_get_ctrl(model, &counter_config[virt]);\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\n}\r\nstatic void op_amd_shutdown(struct op_msrs const * const msrs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!msrs->counters[i].addr)\r\ncontinue;\r\nrelease_perfctr_nmi(MSR_K7_PERFCTR0 + i);\r\nrelease_evntsel_nmi(MSR_K7_EVNTSEL0 + i);\r\n}\r\n}\r\nstatic int op_amd_fill_in_addresses(struct op_msrs * const msrs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_counters; i++) {\r\nif (!reserve_perfctr_nmi(MSR_K7_PERFCTR0 + i))\r\ngoto fail;\r\nif (!reserve_evntsel_nmi(MSR_K7_EVNTSEL0 + i)) {\r\nrelease_perfctr_nmi(MSR_K7_PERFCTR0 + i);\r\ngoto fail;\r\n}\r\nif (num_counters == NUM_COUNTERS_F15H) {\r\nmsrs->counters[i].addr = MSR_F15H_PERF_CTR + (i << 1);\r\nmsrs->controls[i].addr = MSR_F15H_PERF_CTL + (i << 1);\r\n} else {\r\nmsrs->controls[i].addr = MSR_K7_EVNTSEL0 + i;\r\nmsrs->counters[i].addr = MSR_K7_PERFCTR0 + i;\r\n}\r\ncontinue;\r\nfail:\r\nif (!counter_config[i].enabled)\r\ncontinue;\r\nop_x86_warn_reserved(i);\r\nop_amd_shutdown(msrs);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void op_amd_setup_ctrs(struct op_x86_model_spec const *model,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < OP_MAX_COUNTER; ++i) {\r\nif (counter_config[i].enabled\r\n&& msrs->counters[op_x86_virt_to_phys(i)].addr)\r\nreset_value[i] = counter_config[i].count;\r\nelse\r\nreset_value[i] = 0;\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!msrs->controls[i].addr)\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nif (val & ARCH_PERFMON_EVENTSEL_ENABLE)\r\nop_x86_warn_in_use(i);\r\nval &= model->reserved;\r\nwrmsrl(msrs->controls[i].addr, val);\r\nwrmsrl(msrs->counters[i].addr, -1LL);\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\nint virt = op_x86_phys_to_virt(i);\r\nif (!reset_value[virt])\r\ncontinue;\r\nwrmsrl(msrs->counters[i].addr, -(u64)reset_value[virt]);\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval &= model->reserved;\r\nval |= op_x86_get_ctrl(model, &counter_config[virt]);\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\nif (ibs_caps)\r\nsetup_APIC_ibs();\r\n}\r\nstatic void op_amd_cpu_shutdown(void)\r\n{\r\nif (ibs_caps)\r\nclear_APIC_ibs();\r\n}\r\nstatic int op_amd_check_ctrs(struct pt_regs * const regs,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nint virt = op_x86_phys_to_virt(i);\r\nif (!reset_value[virt])\r\ncontinue;\r\nrdmsrl(msrs->counters[i].addr, val);\r\nif (val & OP_CTR_OVERFLOW)\r\ncontinue;\r\noprofile_add_sample(regs, virt);\r\nwrmsrl(msrs->counters[i].addr, -(u64)reset_value[virt]);\r\n}\r\nop_amd_handle_ibs(regs, msrs);\r\nreturn 1;\r\n}\r\nstatic void op_amd_start(struct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[op_x86_phys_to_virt(i)])\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval |= ARCH_PERFMON_EVENTSEL_ENABLE;\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\nop_amd_start_ibs();\r\n}\r\nstatic void op_amd_stop(struct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[op_x86_phys_to_virt(i)])\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\nop_amd_stop_ibs();\r\n}\r\nstatic int setup_ibs_ctl(int ibs_eilvt_off)\r\n{\r\nstruct pci_dev *cpu_cfg;\r\nint nodes;\r\nu32 value = 0;\r\nnodes = 0;\r\ncpu_cfg = NULL;\r\ndo {\r\ncpu_cfg = pci_get_device(PCI_VENDOR_ID_AMD,\r\nPCI_DEVICE_ID_AMD_10H_NB_MISC,\r\ncpu_cfg);\r\nif (!cpu_cfg)\r\nbreak;\r\n++nodes;\r\npci_write_config_dword(cpu_cfg, IBSCTL, ibs_eilvt_off\r\n| IBSCTL_LVT_OFFSET_VALID);\r\npci_read_config_dword(cpu_cfg, IBSCTL, &value);\r\nif (value != (ibs_eilvt_off | IBSCTL_LVT_OFFSET_VALID)) {\r\npci_dev_put(cpu_cfg);\r\nprintk(KERN_DEBUG "Failed to setup IBS LVT offset, "\r\n"IBSCTL = 0x%08x\n", value);\r\nreturn -EINVAL;\r\n}\r\n} while (1);\r\nif (!nodes) {\r\nprintk(KERN_DEBUG "No CPU node configured for IBS\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int force_ibs_eilvt_setup(void)\r\n{\r\nint offset;\r\nint ret;\r\npreempt_disable();\r\nfor (offset = 1; offset < APIC_EILVT_NR_MAX; offset++) {\r\nif (get_eilvt(offset))\r\nbreak;\r\n}\r\npreempt_enable();\r\nif (offset == APIC_EILVT_NR_MAX) {\r\nprintk(KERN_DEBUG "No EILVT entry available\n");\r\nreturn -EBUSY;\r\n}\r\nret = setup_ibs_ctl(offset);\r\nif (ret)\r\ngoto out;\r\nif (!ibs_eilvt_valid()) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\npr_err(FW_BUG "using offset %d for IBS interrupts\n", offset);\r\npr_err(FW_BUG "workaround enabled for IBS LVT offset\n");\r\nreturn 0;\r\nout:\r\npreempt_disable();\r\nput_eilvt(offset);\r\npreempt_enable();\r\nreturn ret;\r\n}\r\nstatic void init_ibs(void)\r\n{\r\nibs_caps = get_ibs_caps();\r\nif (!ibs_caps)\r\nreturn;\r\nif (ibs_eilvt_valid())\r\ngoto out;\r\nif (!force_ibs_eilvt_setup())\r\ngoto out;\r\nibs_caps = 0;\r\nreturn;\r\nout:\r\nprintk(KERN_INFO "oprofile: AMD IBS detected (0x%08x)\n", ibs_caps);\r\n}\r\nstatic int setup_ibs_files(struct super_block *sb, struct dentry *root)\r\n{\r\nstruct dentry *dir;\r\nint ret = 0;\r\nif (create_arch_files)\r\nret = create_arch_files(sb, root);\r\nif (ret)\r\nreturn ret;\r\nif (!ibs_caps)\r\nreturn ret;\r\nmemset(&ibs_config, 0, sizeof(ibs_config));\r\nibs_config.max_cnt_fetch = 250000;\r\nibs_config.max_cnt_op = 250000;\r\nif (ibs_caps & IBS_CAPS_FETCHSAM) {\r\ndir = oprofilefs_mkdir(sb, root, "ibs_fetch");\r\noprofilefs_create_ulong(sb, dir, "enable",\r\n&ibs_config.fetch_enabled);\r\noprofilefs_create_ulong(sb, dir, "max_count",\r\n&ibs_config.max_cnt_fetch);\r\noprofilefs_create_ulong(sb, dir, "rand_enable",\r\n&ibs_config.rand_en);\r\n}\r\nif (ibs_caps & IBS_CAPS_OPSAM) {\r\ndir = oprofilefs_mkdir(sb, root, "ibs_op");\r\noprofilefs_create_ulong(sb, dir, "enable",\r\n&ibs_config.op_enabled);\r\noprofilefs_create_ulong(sb, dir, "max_count",\r\n&ibs_config.max_cnt_op);\r\nif (ibs_caps & IBS_CAPS_OPCNT)\r\noprofilefs_create_ulong(sb, dir, "dispatched_ops",\r\n&ibs_config.dispatched_ops);\r\nif (ibs_caps & IBS_CAPS_BRNTRGT)\r\noprofilefs_create_ulong(sb, dir, "branch_target",\r\n&ibs_config.branch_target);\r\n}\r\nreturn 0;\r\n}\r\nstatic int op_amd_init(struct oprofile_operations *ops)\r\n{\r\ninit_ibs();\r\ncreate_arch_files = ops->create_files;\r\nops->create_files = setup_ibs_files;\r\nif (boot_cpu_data.x86 == 0x15) {\r\nnum_counters = NUM_COUNTERS_F15H;\r\n} else {\r\nnum_counters = NUM_COUNTERS;\r\n}\r\nop_amd_spec.num_counters = num_counters;\r\nop_amd_spec.num_controls = num_counters;\r\nop_amd_spec.num_virt_counters = max(num_counters, NUM_VIRT_COUNTERS);\r\nreturn 0;\r\n}
