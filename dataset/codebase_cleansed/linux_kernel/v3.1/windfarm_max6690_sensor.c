static int wf_max6690_get(struct wf_sensor *sr, s32 *value)\r\n{\r\nstruct wf_6690_sensor *max = wf_to_6690(sr);\r\ns32 data;\r\nif (max->i2c == NULL)\r\nreturn -ENODEV;\r\ndata = i2c_smbus_read_byte_data(max->i2c, MAX6690_EXTERNAL_TEMP);\r\nif (data < 0)\r\nreturn data;\r\n*value = data << 16;\r\nreturn 0;\r\n}\r\nstatic void wf_max6690_release(struct wf_sensor *sr)\r\n{\r\nstruct wf_6690_sensor *max = wf_to_6690(sr);\r\nkfree(max);\r\n}\r\nstatic int wf_max6690_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wf_6690_sensor *max;\r\nint rc;\r\nmax = kzalloc(sizeof(struct wf_6690_sensor), GFP_KERNEL);\r\nif (max == NULL) {\r\nprintk(KERN_ERR "windfarm: Couldn't create MAX6690 sensor: "\r\n"no memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmax->i2c = client;\r\nmax->sens.name = client->dev.platform_data;\r\nmax->sens.ops = &wf_max6690_ops;\r\ni2c_set_clientdata(client, max);\r\nrc = wf_register_sensor(&max->sens);\r\nif (rc) {\r\nkfree(max);\r\n}\r\nreturn rc;\r\n}\r\nstatic struct i2c_client *wf_max6690_create(struct i2c_adapter *adapter,\r\nu8 addr, const char *loc)\r\n{\r\nstruct i2c_board_info info;\r\nstruct i2c_client *client;\r\nchar *name;\r\nif (!strcmp(loc, "BACKSIDE"))\r\nname = "backside-temp";\r\nelse if (!strcmp(loc, "NB Ambient"))\r\nname = "north-bridge-temp";\r\nelse if (!strcmp(loc, "GPU Ambient"))\r\nname = "gpu-temp";\r\nelse\r\ngoto fail;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = addr >> 1;\r\ninfo.platform_data = name;\r\nstrlcpy(info.type, "wf_max6690", I2C_NAME_SIZE);\r\nclient = i2c_new_device(adapter, &info);\r\nif (client == NULL) {\r\nprintk(KERN_ERR "windfarm: failed to attach MAX6690 sensor\n");\r\ngoto fail;\r\n}\r\nlist_add_tail(&client->detected, &wf_max6690_driver.clients);\r\nreturn client;\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic int wf_max6690_attach(struct i2c_adapter *adapter)\r\n{\r\nstruct device_node *busnode, *dev = NULL;\r\nstruct pmac_i2c_bus *bus;\r\nconst char *loc;\r\nbus = pmac_i2c_adapter_to_bus(adapter);\r\nif (bus == NULL)\r\nreturn -ENODEV;\r\nbusnode = pmac_i2c_get_bus_node(bus);\r\nwhile ((dev = of_get_next_child(busnode, dev)) != NULL) {\r\nu8 addr;\r\nif (!pmac_i2c_match_adapter(dev, adapter))\r\ncontinue;\r\nif (!of_device_is_compatible(dev, "max6690"))\r\ncontinue;\r\naddr = pmac_i2c_get_dev_addr(dev);\r\nloc = of_get_property(dev, "hwsensor-location", NULL);\r\nif (loc == NULL || addr == 0)\r\ncontinue;\r\nprintk("found max6690, loc=%s addr=0x%02x\n", loc, addr);\r\nwf_max6690_create(adapter, addr, loc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wf_max6690_remove(struct i2c_client *client)\r\n{\r\nstruct wf_6690_sensor *max = i2c_get_clientdata(client);\r\nmax->i2c = NULL;\r\nwf_unregister_sensor(&max->sens);\r\nreturn 0;\r\n}\r\nstatic int __init wf_max6690_sensor_init(void)\r\n{\r\nif (of_machine_is_compatible("PowerMac7,2") ||\r\nof_machine_is_compatible("PowerMac7,3") ||\r\nof_machine_is_compatible("RackMac3,1"))\r\nreturn -ENODEV;\r\nreturn i2c_add_driver(&wf_max6690_driver);\r\n}\r\nstatic void __exit wf_max6690_sensor_exit(void)\r\n{\r\ni2c_del_driver(&wf_max6690_driver);\r\n}
