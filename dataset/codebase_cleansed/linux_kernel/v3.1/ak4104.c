static int ak4104_fill_cache(struct snd_soc_codec *codec)\r\n{\r\nint i;\r\nu8 *reg_cache = codec->reg_cache;\r\nstruct spi_device *spi = codec->control_data;\r\nfor (i = 0; i < codec->driver->reg_cache_size; i++) {\r\nint ret = spi_w8r8(spi, i | AK4104_READ);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "SPI write failure\n");\r\nreturn ret;\r\n}\r\nreg_cache[i] = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ak4104_read_reg_cache(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nu8 *reg_cache = codec->reg_cache;\r\nif (reg >= codec->driver->reg_cache_size)\r\nreturn -EINVAL;\r\nreturn reg_cache[reg];\r\n}\r\nstatic int ak4104_spi_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nu8 *cache = codec->reg_cache;\r\nstruct spi_device *spi = codec->control_data;\r\nif (reg >= codec->driver->reg_cache_size)\r\nreturn -EINVAL;\r\nif (cache[reg] != value) {\r\nu8 tmp[2] = { (reg & AK4104_REG_MASK) | AK4104_WRITE, value };\r\nif (spi_write(spi, tmp, sizeof(tmp))) {\r\ndev_err(&spi->dev, "SPI write failed\n");\r\nreturn -EIO;\r\n}\r\ncache[reg] = value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak4104_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint val = 0;\r\nval = ak4104_read_reg_cache(codec, AK4104_REG_CONTROL1);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~(AK4104_CONTROL1_DIF0 | AK4104_CONTROL1_DIF1);\r\nswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval |= AK4104_CONTROL1_DIF0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval |= AK4104_CONTROL1_DIF0 | AK4104_CONTROL1_DIF1;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "invalid dai format\n");\r\nreturn -EINVAL;\r\n}\r\nif ((format & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)\r\nreturn -EINVAL;\r\nreturn ak4104_spi_write(codec, AK4104_REG_CONTROL1, val);\r\n}\r\nstatic int ak4104_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nint val = 0;\r\nval |= IEC958_AES0_CON_NOT_COPYRIGHT;\r\nak4104_spi_write(codec, AK4104_REG_CHN_STATUS(0), val);\r\nval = 0;\r\nswitch (params_rate(params)) {\r\ncase 44100:\r\nval |= IEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 48000:\r\nval |= IEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 32000:\r\nval |= IEC958_AES3_CON_FS_32000;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported sampling rate\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ak4104_spi_write(codec, AK4104_REG_CHN_STATUS(3), val);\r\n}\r\nstatic int ak4104_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4104_private *ak4104 = snd_soc_codec_get_drvdata(codec);\r\nint ret, val;\r\ncodec->control_data = ak4104->control_data;\r\nret = ak4104_fill_cache(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to fill register cache\n");\r\nreturn ret;\r\n}\r\nif (ak4104_read_reg_cache(codec, AK4104_REG_RESERVED) !=\r\nAK4104_RESERVED_VAL)\r\nreturn -ENODEV;\r\nval = ak4104_read_reg_cache(codec, AK4104_REG_CONTROL1);\r\nval |= AK4104_CONTROL1_PW | AK4104_CONTROL1_RSTN;\r\nret = ak4104_spi_write(codec, AK4104_REG_CONTROL1, val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = ak4104_read_reg_cache(codec, AK4104_REG_TX);\r\nval |= AK4104_TX_TXE;\r\nret = ak4104_spi_write(codec, AK4104_REG_TX, val);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(codec->dev, "SPI device initialized\n");\r\nreturn 0;\r\n}\r\nstatic int ak4104_remove(struct snd_soc_codec *codec)\r\n{\r\nint val, ret;\r\nval = ak4104_read_reg_cache(codec, AK4104_REG_CONTROL1);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~(AK4104_CONTROL1_PW | AK4104_CONTROL1_RSTN);\r\nret = ak4104_spi_write(codec, AK4104_REG_CONTROL1, val);\r\nreturn ret;\r\n}\r\nstatic int ak4104_spi_probe(struct spi_device *spi)\r\n{\r\nstruct ak4104_private *ak4104;\r\nint ret;\r\nspi->bits_per_word = 8;\r\nspi->mode = SPI_MODE_0;\r\nret = spi_setup(spi);\r\nif (ret < 0)\r\nreturn ret;\r\nak4104 = kzalloc(sizeof(struct ak4104_private), GFP_KERNEL);\r\nif (ak4104 == NULL)\r\nreturn -ENOMEM;\r\nak4104->control_data = spi;\r\nak4104->control_type = SND_SOC_SPI;\r\nspi_set_drvdata(spi, ak4104);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_device_ak4104, &ak4104_dai, 1);\r\nif (ret < 0)\r\nkfree(ak4104);\r\nreturn ret;\r\n}\r\nstatic int __devexit ak4104_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nkfree(spi_get_drvdata(spi));\r\nreturn 0;\r\n}\r\nstatic int __init ak4104_init(void)\r\n{\r\nreturn spi_register_driver(&ak4104_spi_driver);\r\n}\r\nstatic void __exit ak4104_exit(void)\r\n{\r\nspi_unregister_driver(&ak4104_spi_driver);\r\n}
