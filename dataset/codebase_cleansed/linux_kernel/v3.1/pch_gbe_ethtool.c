static int pch_gbe_get_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nint ret;\r\nret = mii_ethtool_gset(&adapter->mii, ecmd);\r\necmd->supported &= ~(SUPPORTED_TP | SUPPORTED_1000baseT_Half);\r\necmd->advertising &= ~(ADVERTISED_TP | ADVERTISED_1000baseT_Half);\r\nif (!netif_carrier_ok(adapter->netdev))\r\nethtool_cmd_speed_set(ecmd, -1);\r\nreturn ret;\r\n}\r\nstatic int pch_gbe_set_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nu32 speed = ethtool_cmd_speed(ecmd);\r\nint ret;\r\npch_gbe_hal_write_phy_reg(hw, MII_BMCR, BMCR_RESET);\r\nif (speed == UINT_MAX) {\r\nspeed = SPEED_1000;\r\necmd->duplex = DUPLEX_FULL;\r\n}\r\nret = mii_ethtool_sset(&adapter->mii, ecmd);\r\nif (ret) {\r\npr_err("Error: mii_ethtool_sset\n");\r\nreturn ret;\r\n}\r\nhw->mac.link_speed = speed;\r\nhw->mac.link_duplex = ecmd->duplex;\r\nhw->phy.autoneg_advertised = ecmd->advertising;\r\nhw->mac.autoneg = ecmd->autoneg;\r\npch_gbe_hal_phy_sw_reset(hw);\r\nif (netif_running(adapter->netdev)) {\r\npch_gbe_down(adapter);\r\nret = pch_gbe_up(adapter);\r\n} else {\r\npch_gbe_reset(adapter);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pch_gbe_get_regs_len(struct net_device *netdev)\r\n{\r\nreturn PCH_GBE_REGS_LEN * (int)sizeof(u32);\r\n}\r\nstatic void pch_gbe_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstrcpy(drvinfo->driver, KBUILD_MODNAME);\r\nstrcpy(drvinfo->version, pch_driver_version);\r\nstrcpy(drvinfo->fw_version, "N/A");\r\nstrcpy(drvinfo->bus_info, pci_name(adapter->pdev));\r\ndrvinfo->regdump_len = pch_gbe_get_regs_len(netdev);\r\n}\r\nstatic void pch_gbe_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu32 *regs_buff = p;\r\nu16 i, tmp;\r\nregs->version = 0x1000000 | (__u32)pdev->revision << 16 | pdev->device;\r\nfor (i = 0; i < PCH_GBE_MAC_REGS_LEN; i++)\r\n*regs_buff++ = ioread32(&hw->reg->INT_ST + i);\r\nfor (i = 0; i < PCH_GBE_PHY_REGS_LEN; i++) {\r\npch_gbe_hal_read_phy_reg(&adapter->hw, i, &tmp);\r\n*regs_buff++ = tmp;\r\n}\r\n}\r\nstatic void pch_gbe_get_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nwol->supported = WAKE_UCAST | WAKE_MCAST | WAKE_BCAST | WAKE_MAGIC;\r\nwol->wolopts = 0;\r\nif ((adapter->wake_up_evt & PCH_GBE_WLC_IND))\r\nwol->wolopts |= WAKE_UCAST;\r\nif ((adapter->wake_up_evt & PCH_GBE_WLC_MLT))\r\nwol->wolopts |= WAKE_MCAST;\r\nif ((adapter->wake_up_evt & PCH_GBE_WLC_BR))\r\nwol->wolopts |= WAKE_BCAST;\r\nif ((adapter->wake_up_evt & PCH_GBE_WLC_MP))\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int pch_gbe_set_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nif ((wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE)))\r\nreturn -EOPNOTSUPP;\r\nadapter->wake_up_evt = 0;\r\nif ((wol->wolopts & WAKE_UCAST))\r\nadapter->wake_up_evt |= PCH_GBE_WLC_IND;\r\nif ((wol->wolopts & WAKE_MCAST))\r\nadapter->wake_up_evt |= PCH_GBE_WLC_MLT;\r\nif ((wol->wolopts & WAKE_BCAST))\r\nadapter->wake_up_evt |= PCH_GBE_WLC_BR;\r\nif ((wol->wolopts & WAKE_MAGIC))\r\nadapter->wake_up_evt |= PCH_GBE_WLC_MP;\r\nreturn 0;\r\n}\r\nstatic int pch_gbe_nway_reset(struct net_device *netdev)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nreturn mii_nway_restart(&adapter->mii);\r\n}\r\nstatic void pch_gbe_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_tx_ring *txdr = adapter->tx_ring;\r\nstruct pch_gbe_rx_ring *rxdr = adapter->rx_ring;\r\nring->rx_max_pending = PCH_GBE_MAX_RXD;\r\nring->tx_max_pending = PCH_GBE_MAX_TXD;\r\nring->rx_mini_max_pending = 0;\r\nring->rx_jumbo_max_pending = 0;\r\nring->rx_pending = rxdr->count;\r\nring->tx_pending = txdr->count;\r\nring->rx_mini_pending = 0;\r\nring->rx_jumbo_pending = 0;\r\n}\r\nstatic int pch_gbe_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_tx_ring *txdr, *tx_old;\r\nstruct pch_gbe_rx_ring *rxdr, *rx_old;\r\nint tx_ring_size, rx_ring_size;\r\nint err = 0;\r\nif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\ntx_ring_size = (int)sizeof(struct pch_gbe_tx_ring);\r\nrx_ring_size = (int)sizeof(struct pch_gbe_rx_ring);\r\nif ((netif_running(adapter->netdev)))\r\npch_gbe_down(adapter);\r\ntx_old = adapter->tx_ring;\r\nrx_old = adapter->rx_ring;\r\ntxdr = kzalloc(tx_ring_size, GFP_KERNEL);\r\nif (!txdr) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_tx;\r\n}\r\nrxdr = kzalloc(rx_ring_size, GFP_KERNEL);\r\nif (!rxdr) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_rx;\r\n}\r\nadapter->tx_ring = txdr;\r\nadapter->rx_ring = rxdr;\r\nrxdr->count =\r\nclamp_val(ring->rx_pending, PCH_GBE_MIN_RXD, PCH_GBE_MAX_RXD);\r\nrxdr->count = roundup(rxdr->count, PCH_GBE_RX_DESC_MULTIPLE);\r\ntxdr->count =\r\nclamp_val(ring->tx_pending, PCH_GBE_MIN_RXD, PCH_GBE_MAX_RXD);\r\ntxdr->count = roundup(txdr->count, PCH_GBE_TX_DESC_MULTIPLE);\r\nif ((netif_running(adapter->netdev))) {\r\nerr = pch_gbe_setup_rx_resources(adapter, adapter->rx_ring);\r\nif (err)\r\ngoto err_setup_rx;\r\nerr = pch_gbe_setup_tx_resources(adapter, adapter->tx_ring);\r\nif (err)\r\ngoto err_setup_tx;\r\n#ifdef RINGFREE\r\nadapter->rx_ring = rx_old;\r\nadapter->tx_ring = tx_old;\r\npch_gbe_free_rx_resources(adapter, adapter->rx_ring);\r\npch_gbe_free_tx_resources(adapter, adapter->tx_ring);\r\nkfree(tx_old);\r\nkfree(rx_old);\r\nadapter->rx_ring = rxdr;\r\nadapter->tx_ring = txdr;\r\n#else\r\npch_gbe_free_rx_resources(adapter, rx_old);\r\npch_gbe_free_tx_resources(adapter, tx_old);\r\nkfree(tx_old);\r\nkfree(rx_old);\r\nadapter->rx_ring = rxdr;\r\nadapter->tx_ring = txdr;\r\n#endif\r\nerr = pch_gbe_up(adapter);\r\n}\r\nreturn err;\r\nerr_setup_tx:\r\npch_gbe_free_rx_resources(adapter, adapter->rx_ring);\r\nerr_setup_rx:\r\nadapter->rx_ring = rx_old;\r\nadapter->tx_ring = tx_old;\r\nkfree(rxdr);\r\nerr_alloc_rx:\r\nkfree(txdr);\r\nerr_alloc_tx:\r\nif (netif_running(adapter->netdev))\r\npch_gbe_up(adapter);\r\nreturn err;\r\n}\r\nstatic void pch_gbe_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\npause->autoneg =\r\n((hw->mac.fc_autoneg) ? AUTONEG_ENABLE : AUTONEG_DISABLE);\r\nif (hw->mac.fc == PCH_GBE_FC_RX_PAUSE) {\r\npause->rx_pause = 1;\r\n} else if (hw->mac.fc == PCH_GBE_FC_TX_PAUSE) {\r\npause->tx_pause = 1;\r\n} else if (hw->mac.fc == PCH_GBE_FC_FULL) {\r\npause->rx_pause = 1;\r\npause->tx_pause = 1;\r\n}\r\n}\r\nstatic int pch_gbe_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nint ret = 0;\r\nhw->mac.fc_autoneg = pause->autoneg;\r\nif ((pause->rx_pause) && (pause->tx_pause))\r\nhw->mac.fc = PCH_GBE_FC_FULL;\r\nelse if ((pause->rx_pause) && (!pause->tx_pause))\r\nhw->mac.fc = PCH_GBE_FC_RX_PAUSE;\r\nelse if ((!pause->rx_pause) && (pause->tx_pause))\r\nhw->mac.fc = PCH_GBE_FC_TX_PAUSE;\r\nelse if ((!pause->rx_pause) && (!pause->tx_pause))\r\nhw->mac.fc = PCH_GBE_FC_NONE;\r\nif (hw->mac.fc_autoneg == AUTONEG_ENABLE) {\r\nif ((netif_running(adapter->netdev))) {\r\npch_gbe_down(adapter);\r\nret = pch_gbe_up(adapter);\r\n} else {\r\npch_gbe_reset(adapter);\r\n}\r\n} else {\r\nret = pch_gbe_mac_force_mac_fc(hw);\r\n}\r\nreturn ret;\r\n}\r\nstatic void pch_gbe_get_strings(struct net_device *netdev, u32 stringset,\r\nu8 *data)\r\n{\r\nu8 *p = data;\r\nint i;\r\nswitch (stringset) {\r\ncase (u32) ETH_SS_STATS:\r\nfor (i = 0; i < PCH_GBE_GLOBAL_STATS_LEN; i++) {\r\nmemcpy(p, pch_gbe_gstrings_stats[i].string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void pch_gbe_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nint i;\r\nconst struct pch_gbe_stats *gstats = pch_gbe_gstrings_stats;\r\nchar *hw_stats = (char *)&adapter->stats;\r\npch_gbe_update_stats(adapter);\r\nfor (i = 0; i < PCH_GBE_GLOBAL_STATS_LEN; i++) {\r\nchar *p = hw_stats + gstats->offset;\r\ndata[i] = gstats->size == sizeof(u64) ? *(u64 *)p:(*(u32 *)p);\r\ngstats++;\r\n}\r\n}\r\nstatic int pch_gbe_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn PCH_GBE_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nvoid pch_gbe_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nSET_ETHTOOL_OPS(netdev, &pch_gbe_ethtool_ops);\r\n}
