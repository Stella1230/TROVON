static B_UINT16 CFG_CalculateChecksum(B_UINT8 *pu8Buffer, B_UINT32 u32Size)\r\n{\r\nB_UINT16 u16CheckSum=0;\r\nwhile(u32Size--) {\r\nu16CheckSum += (B_UINT8)~(*pu8Buffer);\r\npu8Buffer++;\r\n}\r\nreturn u16CheckSum;\r\n}\r\nBOOLEAN IsReqGpioIsLedInNVM(PMINI_ADAPTER Adapter, UINT gpios)\r\n{\r\nINT Status ;\r\nStatus = (Adapter->gpioBitMap & gpios) ^ gpios ;\r\nif(Status)\r\nreturn FALSE;\r\nelse\r\nreturn TRUE;\r\n}\r\nstatic INT LED_Blink(PMINI_ADAPTER Adapter, UINT GPIO_Num, UCHAR uiLedIndex, ULONG timeout, INT num_of_time, LedEventInfo_t currdriverstate)\r\n{\r\nint Status = STATUS_SUCCESS;\r\nBOOLEAN bInfinite = FALSE;\r\nif(num_of_time < 0)\r\n{\r\nbInfinite = TRUE;\r\nnum_of_time = 1;\r\n}\r\nwhile(num_of_time)\r\n{\r\nif(currdriverstate == Adapter->DriverState)\r\nTURN_ON_LED(GPIO_Num, uiLedIndex);\r\nStatus = wait_event_interruptible_timeout(Adapter->LEDInfo.notify_led_event,\r\ncurrdriverstate != Adapter->DriverState || kthread_should_stop(),\r\nmsecs_to_jiffies(timeout));\r\nif(kthread_should_stop())\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL, "Led thread got signal to exit..hence exiting");\r\nAdapter->LEDInfo.led_thread_running= BCM_LED_THREAD_DISABLED;\r\nTURN_OFF_LED(GPIO_Num, uiLedIndex);\r\nStatus=EVENT_SIGNALED;\r\nbreak;\r\n}\r\nif(Status)\r\n{\r\nTURN_OFF_LED(GPIO_Num, uiLedIndex);\r\nStatus=EVENT_SIGNALED;\r\nbreak;\r\n}\r\nTURN_OFF_LED(GPIO_Num, uiLedIndex);\r\nStatus = wait_event_interruptible_timeout(Adapter->LEDInfo.notify_led_event,\r\ncurrdriverstate!= Adapter->DriverState || kthread_should_stop(),\r\nmsecs_to_jiffies(timeout));\r\nif(bInfinite == FALSE)\r\nnum_of_time--;\r\n}\r\nreturn Status;\r\n}\r\nstatic INT ScaleRateofTransfer(ULONG rate)\r\n{\r\nif(rate <= 3)\r\nreturn rate;\r\nelse if((rate > 3) && (rate <= 100))\r\nreturn 5;\r\nelse if((rate > 100) && (rate <= 200))\r\nreturn 6;\r\nelse if((rate > 200) && (rate <= 300))\r\nreturn 7;\r\nelse if((rate > 300) && (rate <= 400))\r\nreturn 8;\r\nelse if((rate > 400) && (rate <= 500))\r\nreturn 9;\r\nelse if((rate > 500) && (rate <= 600))\r\nreturn 10;\r\nelse\r\nreturn MAX_NUM_OF_BLINKS;\r\n}\r\nstatic INT LED_Proportional_Blink(PMINI_ADAPTER Adapter, UCHAR GPIO_Num_tx,\r\nUCHAR uiTxLedIndex, UCHAR GPIO_Num_rx, UCHAR uiRxLedIndex, LedEventInfo_t currdriverstate)\r\n{\r\nULONG64 Initial_num_of_packts_tx = 0, Initial_num_of_packts_rx = 0;\r\nULONG64 Final_num_of_packts_tx = 0, Final_num_of_packts_rx = 0;\r\nULONG64 rate_of_transfer_tx = 0, rate_of_transfer_rx = 0;\r\nint Status = STATUS_SUCCESS;\r\nINT num_of_time = 0, num_of_time_tx = 0, num_of_time_rx = 0;\r\nUINT remDelay = 0;\r\nBOOLEAN bBlinkBothLED = TRUE;\r\nulong timeout = 0;\r\nInitial_num_of_packts_tx = Adapter->dev->stats.tx_packets;\r\nInitial_num_of_packts_rx = Adapter->dev->stats.rx_packets;\r\nnum_of_time_tx= ScaleRateofTransfer((ULONG)rate_of_transfer_tx);\r\nnum_of_time_rx= ScaleRateofTransfer((ULONG)rate_of_transfer_rx);\r\nwhile((Adapter->device_removed == FALSE))\r\n{\r\ntimeout = 50;\r\nif(bBlinkBothLED)\r\n{\r\nif(num_of_time_tx > num_of_time_rx)\r\nnum_of_time = num_of_time_rx;\r\nelse\r\nnum_of_time = num_of_time_tx;\r\nif(num_of_time > 0)\r\n{\r\nif(LED_Blink(Adapter, 1<<GPIO_Num_tx, uiTxLedIndex, timeout, num_of_time,currdriverstate)\r\n== EVENT_SIGNALED)\r\n{\r\nreturn EVENT_SIGNALED;\r\n}\r\nif(LED_Blink(Adapter, 1<<GPIO_Num_rx, uiRxLedIndex, timeout, num_of_time,currdriverstate)\r\n== EVENT_SIGNALED)\r\n{\r\nreturn EVENT_SIGNALED;\r\n}\r\n}\r\nif(num_of_time == num_of_time_tx)\r\n{\r\nif(LED_Blink(Adapter, (1 << GPIO_Num_rx), uiRxLedIndex, timeout,\r\nnum_of_time_rx-num_of_time,currdriverstate) == EVENT_SIGNALED)\r\n{\r\nreturn EVENT_SIGNALED;\r\n}\r\nnum_of_time = num_of_time_rx;\r\n}\r\nelse\r\n{\r\nif(LED_Blink(Adapter, 1<<GPIO_Num_tx, uiTxLedIndex, timeout,\r\nnum_of_time_tx-num_of_time,currdriverstate) == EVENT_SIGNALED)\r\n{\r\nreturn EVENT_SIGNALED;\r\n}\r\nnum_of_time = num_of_time_tx;\r\n}\r\n}\r\nelse\r\n{\r\nif(num_of_time == num_of_time_tx)\r\n{\r\nif(LED_Blink(Adapter, 1<<GPIO_Num_tx, uiTxLedIndex, timeout, num_of_time,currdriverstate)\r\n== EVENT_SIGNALED)\r\n{\r\nreturn EVENT_SIGNALED;\r\n}\r\n}\r\nelse\r\n{\r\nif(LED_Blink(Adapter, 1<<GPIO_Num_rx, uiRxLedIndex, timeout,\r\nnum_of_time,currdriverstate) == EVENT_SIGNALED)\r\n{\r\nreturn EVENT_SIGNALED;\r\n}\r\n}\r\n}\r\nremDelay = MAX_NUM_OF_BLINKS - num_of_time;\r\nif(remDelay > 0)\r\n{\r\ntimeout= 100 * remDelay;\r\nStatus = wait_event_interruptible_timeout(Adapter->LEDInfo.notify_led_event,\r\ncurrdriverstate!= Adapter->DriverState ||kthread_should_stop() ,\r\nmsecs_to_jiffies (timeout));\r\nif(kthread_should_stop())\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL, "Led thread got signal to exit..hence exiting");\r\nAdapter->LEDInfo.led_thread_running= BCM_LED_THREAD_DISABLED;\r\nreturn EVENT_SIGNALED;\r\n}\r\nif(Status)\r\nreturn EVENT_SIGNALED;\r\n}\r\nTURN_OFF_LED(1<<GPIO_Num_tx, uiTxLedIndex);\r\nTURN_OFF_LED(1<<GPIO_Num_rx, uiTxLedIndex);\r\nFinal_num_of_packts_tx = Adapter->dev->stats.tx_packets;\r\nFinal_num_of_packts_rx = Adapter->dev->stats.rx_packets;\r\nrate_of_transfer_tx = Final_num_of_packts_tx - Initial_num_of_packts_tx;\r\nrate_of_transfer_rx = Final_num_of_packts_rx - Initial_num_of_packts_rx;\r\nInitial_num_of_packts_tx = Final_num_of_packts_tx;\r\nInitial_num_of_packts_rx = Final_num_of_packts_rx ;\r\nnum_of_time_tx= ScaleRateofTransfer((ULONG)rate_of_transfer_tx);\r\nnum_of_time_rx= ScaleRateofTransfer((ULONG)rate_of_transfer_rx);\r\n}\r\nreturn Status;\r\n}\r\nstatic INT ValidateDSDParamsChecksum(\r\nPMINI_ADAPTER Adapter,\r\nULONG ulParamOffset,\r\nUSHORT usParamLen )\r\n{\r\nINT Status = STATUS_SUCCESS;\r\nPUCHAR puBuffer = NULL;\r\nUSHORT usChksmOrg = 0;\r\nUSHORT usChecksumCalculated = 0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread:ValidateDSDParamsChecksum: 0x%lx 0x%X",ulParamOffset, usParamLen);\r\npuBuffer = kmalloc(usParamLen, GFP_KERNEL);\r\nif(!puBuffer)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: ValidateDSDParamsChecksum Allocation failed");\r\nreturn -ENOMEM;\r\n}\r\nif(STATUS_SUCCESS != BeceemNVMRead(Adapter,(PUINT)puBuffer,ulParamOffset,usParamLen))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: ValidateDSDParamsChecksum BeceemNVMRead failed");\r\nStatus=STATUS_IMAGE_CHECKSUM_MISMATCH;\r\ngoto exit;\r\n}\r\nusChecksumCalculated = CFG_CalculateChecksum(puBuffer,usParamLen);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: usCheckSumCalculated = 0x%x\n", usChecksumCalculated);\r\nif(STATUS_SUCCESS != BeceemNVMRead(Adapter,(PUINT)&usChksmOrg,ulParamOffset+usParamLen,2))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: ValidateDSDParamsChecksum BeceemNVMRead failed");\r\nStatus=STATUS_IMAGE_CHECKSUM_MISMATCH;\r\ngoto exit;\r\n}\r\nusChksmOrg = ntohs(usChksmOrg);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: usChksmOrg = 0x%x", usChksmOrg);\r\nif(usChecksumCalculated ^ usChksmOrg)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: ValidateDSDParamsChecksum: Checksums don't match");\r\nStatus = STATUS_IMAGE_CHECKSUM_MISMATCH;\r\ngoto exit;\r\n}\r\nexit:\r\nkfree(puBuffer);\r\nreturn Status;\r\n}\r\nstatic INT ValidateHWParmStructure(PMINI_ADAPTER Adapter, ULONG ulHwParamOffset)\r\n{\r\nINT Status = STATUS_SUCCESS ;\r\nUSHORT HwParamLen = 0;\r\nulHwParamOffset += DSD_START_OFFSET;\r\nBeceemNVMRead(Adapter,(PUINT)&HwParamLen,ulHwParamOffset,2);\r\nHwParamLen = ntohs(HwParamLen);\r\nif(0==HwParamLen || HwParamLen > Adapter->uiNVMDSDSize)\r\n{\r\nreturn STATUS_IMAGE_CHECKSUM_MISMATCH;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL, "LED Thread:HwParamLen = 0x%x", HwParamLen);\r\nStatus =ValidateDSDParamsChecksum(Adapter,ulHwParamOffset,HwParamLen);\r\nreturn Status;\r\n}\r\nstatic int ReadLEDInformationFromEEPROM(PMINI_ADAPTER Adapter, UCHAR GPIO_Array[])\r\n{\r\nint Status = STATUS_SUCCESS;\r\nULONG dwReadValue = 0;\r\nUSHORT usHwParamData = 0;\r\nUSHORT usEEPROMVersion = 0;\r\nUCHAR ucIndex = 0;\r\nUCHAR ucGPIOInfo[32] = {0};\r\nBeceemNVMRead(Adapter,(PUINT)&usEEPROMVersion,EEPROM_VERSION_OFFSET,2);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"usEEPROMVersion: Minor:0x%X Major:0x%x",usEEPROMVersion&0xFF, ((usEEPROMVersion>>8)&0xFF));\r\nif(((usEEPROMVersion>>8)&0xFF) < EEPROM_MAP5_MAJORVERSION)\r\n{\r\nBeceemNVMRead(Adapter,(PUINT)&usHwParamData,EEPROM_HW_PARAM_POINTER_ADDRESS,2);\r\nusHwParamData = ntohs(usHwParamData);\r\ndwReadValue = usHwParamData;\r\n}\r\nelse\r\n{\r\nStatus = ValidateDSDParamsChecksum(Adapter,\r\nDSD_START_OFFSET,\r\nCOMPATIBILITY_SECTION_LENGTH_MAP5);\r\nif(Status != STATUS_SUCCESS)\r\n{\r\nreturn Status;\r\n}\r\nBeceemNVMRead(Adapter,(PUINT)&dwReadValue,EEPROM_HW_PARAM_POINTER_ADDRRES_MAP5,4);\r\ndwReadValue = ntohl(dwReadValue);\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: Start address of HW_PARAM structure = 0x%lx",dwReadValue);\r\nif(dwReadValue < DSD_START_OFFSET ||\r\ndwReadValue > (Adapter->uiNVMDSDSize-DSD_START_OFFSET))\r\n{\r\nreturn STATUS_IMAGE_CHECKSUM_MISMATCH;\r\n}\r\nStatus = ValidateHWParmStructure(Adapter, dwReadValue);\r\nif(Status){\r\nreturn Status;\r\n}\r\ndwReadValue += DSD_START_OFFSET;\r\ndwReadValue += GPIO_SECTION_START_OFFSET;\r\nBeceemNVMRead(Adapter, (UINT *)ucGPIOInfo,dwReadValue,32);\r\nfor(ucIndex = 0; ucIndex < 32; ucIndex++)\r\n{\r\nswitch(ucGPIOInfo[ucIndex])\r\n{\r\ncase RED_LED:\r\n{\r\nGPIO_Array[RED_LED] = ucIndex;\r\nAdapter->gpioBitMap |= (1<<ucIndex);\r\nbreak;\r\n}\r\ncase BLUE_LED:\r\n{\r\nGPIO_Array[BLUE_LED] = ucIndex;\r\nAdapter->gpioBitMap |= (1<<ucIndex);\r\nbreak;\r\n}\r\ncase YELLOW_LED:\r\n{\r\nGPIO_Array[YELLOW_LED] = ucIndex;\r\nAdapter->gpioBitMap |= (1<<ucIndex);\r\nbreak;\r\n}\r\ncase GREEN_LED:\r\n{\r\nGPIO_Array[GREEN_LED] = ucIndex;\r\nAdapter->gpioBitMap |= (1<<ucIndex);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"GPIO's bit map correspond to LED :0x%X",Adapter->gpioBitMap);\r\nreturn Status;\r\n}\r\nstatic int ReadConfigFileStructure(PMINI_ADAPTER Adapter, BOOLEAN *bEnableThread)\r\n{\r\nint Status = STATUS_SUCCESS;\r\nUCHAR GPIO_Array[NUM_OF_LEDS+1];\r\nUINT uiIndex = 0;\r\nUINT uiNum_of_LED_Type = 0;\r\nPUCHAR puCFGData = NULL;\r\nUCHAR bData = 0;\r\nmemset(GPIO_Array, DISABLE_GPIO_NUM, NUM_OF_LEDS+1);\r\nif(!Adapter->pstargetparams || IS_ERR(Adapter->pstargetparams))\r\n{\r\nBCM_DEBUG_PRINT (Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL, "Target Params not Avail.\n");\r\nreturn -ENOENT;\r\n}\r\nStatus = ReadLEDInformationFromEEPROM(Adapter, GPIO_Array);\r\nif(Status == STATUS_IMAGE_CHECKSUM_MISMATCH)\r\n{\r\n*bEnableThread = FALSE;\r\nreturn STATUS_SUCCESS;\r\n}\r\nelse if(Status)\r\n{\r\n*bEnableThread = FALSE;\r\nreturn Status;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: Config file read successfully\n");\r\npuCFGData = (PUCHAR) &Adapter->pstargetparams->HostDrvrConfig1;\r\nfor(uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++)\r\n{\r\nbData = *puCFGData;\r\nif(bData & 0x80)\r\n{\r\nAdapter->LEDInfo.LEDState[uiIndex].BitPolarity = 0;\r\nbData = bData & 0x7f;\r\n}\r\nAdapter->LEDInfo.LEDState[uiIndex].LED_Type = bData;\r\nif(bData <= NUM_OF_LEDS)\r\nAdapter->LEDInfo.LEDState[uiIndex].GPIO_Num = GPIO_Array[bData];\r\nelse\r\nAdapter->LEDInfo.LEDState[uiIndex].GPIO_Num = DISABLE_GPIO_NUM;\r\npuCFGData++;\r\nbData = *puCFGData;\r\nAdapter->LEDInfo.LEDState[uiIndex].LED_On_State = bData;\r\npuCFGData++;\r\nbData = *puCFGData;\r\nAdapter->LEDInfo.LEDState[uiIndex].LED_Blink_State= bData;\r\npuCFGData++;\r\n}\r\nfor(uiIndex = 0; uiIndex<NUM_OF_LEDS; uiIndex++)\r\n{\r\nif((Adapter->LEDInfo.LEDState[uiIndex].LED_Type == DISABLE_GPIO_NUM) ||\r\n(Adapter->LEDInfo.LEDState[uiIndex].LED_Type == 0x7f) ||\r\n(Adapter->LEDInfo.LEDState[uiIndex].LED_Type == 0))\r\nuiNum_of_LED_Type++;\r\n}\r\nif(uiNum_of_LED_Type >= NUM_OF_LEDS)\r\n*bEnableThread = FALSE;\r\nreturn Status;\r\n}\r\nstatic VOID LedGpioInit(PMINI_ADAPTER Adapter)\r\n{\r\nUINT uiResetValue = 0;\r\nUINT uiIndex = 0;\r\nif(rdmalt(Adapter, GPIO_MODE_REGISTER, &uiResetValue, sizeof(uiResetValue)) <0)\r\nBCM_DEBUG_PRINT (Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: RDM Failed\n");\r\nfor(uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++)\r\n{\r\nif(Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num != DISABLE_GPIO_NUM)\r\nuiResetValue |= (1 << Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num);\r\nTURN_OFF_LED(1<<Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num,uiIndex);\r\n}\r\nif(wrmalt(Adapter, GPIO_MODE_REGISTER, &uiResetValue, sizeof(uiResetValue)) < 0)\r\nBCM_DEBUG_PRINT (Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: WRM Failed\n");\r\nAdapter->LEDInfo.bIdle_led_off = FALSE;\r\n}\r\nstatic INT BcmGetGPIOPinInfo(PMINI_ADAPTER Adapter, UCHAR *GPIO_num_tx, UCHAR *GPIO_num_rx ,UCHAR *uiLedTxIndex, UCHAR *uiLedRxIndex,LedEventInfo_t currdriverstate)\r\n{\r\nUINT uiIndex = 0;\r\n*GPIO_num_tx = DISABLE_GPIO_NUM;\r\n*GPIO_num_rx = DISABLE_GPIO_NUM;\r\nfor(uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++)\r\n{\r\nif((currdriverstate == NORMAL_OPERATION)||\r\n(currdriverstate == IDLEMODE_EXIT)||\r\n(currdriverstate == FW_DOWNLOAD))\r\n{\r\nif(Adapter->LEDInfo.LEDState[uiIndex].LED_Blink_State & currdriverstate)\r\n{\r\nif(Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num != DISABLE_GPIO_NUM)\r\n{\r\nif(*GPIO_num_tx == DISABLE_GPIO_NUM)\r\n{\r\n*GPIO_num_tx = Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num;\r\n*uiLedTxIndex = uiIndex;\r\n}\r\nelse\r\n{\r\n*GPIO_num_rx = Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num;\r\n*uiLedRxIndex = uiIndex;\r\n}\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif(Adapter->LEDInfo.LEDState[uiIndex].LED_On_State & currdriverstate)\r\n{\r\nif(Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num != DISABLE_GPIO_NUM)\r\n{\r\n*GPIO_num_tx = Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num;\r\n*uiLedTxIndex = uiIndex;\r\n}\r\n}\r\n}\r\n}\r\nreturn STATUS_SUCCESS ;\r\n}\r\nstatic VOID LEDControlThread(PMINI_ADAPTER Adapter)\r\n{\r\nUINT uiIndex = 0;\r\nUCHAR GPIO_num = 0;\r\nUCHAR uiLedIndex = 0 ;\r\nUINT uiResetValue = 0;\r\nLedEventInfo_t currdriverstate = 0;\r\nulong timeout = 0;\r\nINT Status = 0;\r\nUCHAR dummyGPIONum = 0;\r\nUCHAR dummyIndex = 0;\r\nAdapter->LEDInfo.bIdleMode_tx_from_host = FALSE;\r\nGPIO_num = DISABLE_GPIO_NUM ;\r\nwhile(TRUE)\r\n{\r\nif( (GPIO_num == DISABLE_GPIO_NUM)\r\n||\r\n((currdriverstate != FW_DOWNLOAD) &&\r\n(currdriverstate != NORMAL_OPERATION) &&\r\n(currdriverstate != LOWPOWER_MODE_ENTER))\r\n||\r\n(currdriverstate == LED_THREAD_INACTIVE) )\r\n{\r\nStatus = wait_event_interruptible(Adapter->LEDInfo.notify_led_event,\r\ncurrdriverstate != Adapter->DriverState || kthread_should_stop());\r\n}\r\nif(kthread_should_stop() || Adapter->device_removed )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL, "Led thread got signal to exit..hence exiting");\r\nAdapter->LEDInfo.led_thread_running = BCM_LED_THREAD_DISABLED;\r\nTURN_OFF_LED(1<<GPIO_num, uiLedIndex);\r\nreturn ;\r\n}\r\nif(GPIO_num != DISABLE_GPIO_NUM)\r\n{\r\nTURN_OFF_LED(1<<GPIO_num, uiLedIndex);\r\n}\r\nif(Adapter->LEDInfo.bLedInitDone == FALSE)\r\n{\r\nLedGpioInit(Adapter);\r\nAdapter->LEDInfo.bLedInitDone = TRUE;\r\n}\r\nswitch(Adapter->DriverState)\r\n{\r\ncase DRIVER_INIT:\r\n{\r\ncurrdriverstate = DRIVER_INIT;\r\nBcmGetGPIOPinInfo(Adapter, &GPIO_num, &dummyGPIONum, &uiLedIndex, &dummyIndex, currdriverstate);\r\nif(GPIO_num != DISABLE_GPIO_NUM)\r\n{\r\nTURN_ON_LED(1<<GPIO_num, uiLedIndex);\r\n}\r\n}\r\nbreak;\r\ncase FW_DOWNLOAD:\r\n{\r\ncurrdriverstate = FW_DOWNLOAD;\r\nBcmGetGPIOPinInfo(Adapter, &GPIO_num, &dummyGPIONum, &uiLedIndex, &dummyIndex, currdriverstate);\r\nif(GPIO_num != DISABLE_GPIO_NUM)\r\n{\r\ntimeout = 50;\r\nLED_Blink(Adapter, 1<<GPIO_num, uiLedIndex, timeout, -1,currdriverstate);\r\n}\r\n}\r\nbreak;\r\ncase FW_DOWNLOAD_DONE:\r\n{\r\ncurrdriverstate = FW_DOWNLOAD_DONE;\r\nBcmGetGPIOPinInfo(Adapter, &GPIO_num, &dummyGPIONum, &uiLedIndex, &dummyIndex,currdriverstate);\r\nif(GPIO_num != DISABLE_GPIO_NUM)\r\n{\r\nTURN_ON_LED(1<<GPIO_num, uiLedIndex);\r\n}\r\n}\r\nbreak;\r\ncase SHUTDOWN_EXIT:\r\ncase NO_NETWORK_ENTRY:\r\n{\r\ncurrdriverstate = NO_NETWORK_ENTRY;\r\nBcmGetGPIOPinInfo(Adapter, &GPIO_num, &dummyGPIONum, &uiLedIndex,&dummyGPIONum,currdriverstate);\r\nif(GPIO_num != DISABLE_GPIO_NUM)\r\n{\r\nTURN_ON_LED(1<<GPIO_num, uiLedIndex);\r\n}\r\n}\r\nbreak;\r\ncase NORMAL_OPERATION:\r\n{\r\nUCHAR GPIO_num_tx = DISABLE_GPIO_NUM;\r\nUCHAR GPIO_num_rx = DISABLE_GPIO_NUM;\r\nUCHAR uiLEDTx = 0;\r\nUCHAR uiLEDRx = 0;\r\ncurrdriverstate = NORMAL_OPERATION;\r\nAdapter->LEDInfo.bIdle_led_off = FALSE;\r\nBcmGetGPIOPinInfo(Adapter, &GPIO_num_tx, &GPIO_num_rx, &uiLEDTx,&uiLEDRx,currdriverstate);\r\nif((GPIO_num_tx == DISABLE_GPIO_NUM) && (GPIO_num_rx == DISABLE_GPIO_NUM))\r\n{\r\nGPIO_num = DISABLE_GPIO_NUM ;\r\n}\r\nelse\r\n{\r\nif(GPIO_num_tx == DISABLE_GPIO_NUM)\r\n{\r\nGPIO_num_tx = GPIO_num_rx;\r\nuiLEDTx = uiLEDRx;\r\n}\r\nelse if(GPIO_num_rx == DISABLE_GPIO_NUM)\r\n{\r\nGPIO_num_rx = GPIO_num_tx;\r\nuiLEDRx = uiLEDTx;\r\n}\r\nLED_Proportional_Blink(Adapter, GPIO_num_tx, uiLEDTx, GPIO_num_rx, uiLEDRx,currdriverstate);\r\n}\r\n}\r\nbreak;\r\ncase LOWPOWER_MODE_ENTER:\r\n{\r\ncurrdriverstate = LOWPOWER_MODE_ENTER;\r\nif( DEVICE_POWERSAVE_MODE_AS_MANUAL_CLOCK_GATING == Adapter->ulPowerSaveMode)\r\n{\r\nuiResetValue = 0;\r\nfor(uiIndex =0; uiIndex < NUM_OF_LEDS; uiIndex++)\r\n{\r\nif(Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num != DISABLE_GPIO_NUM)\r\nTURN_OFF_LED((1<<Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num),uiIndex);\r\n}\r\n}\r\nAdapter->LEDInfo.bLedInitDone = FALSE;\r\nAdapter->LEDInfo.bIdle_led_off = TRUE;\r\nwake_up(&Adapter->LEDInfo.idleModeSyncEvent);\r\nGPIO_num = DISABLE_GPIO_NUM;\r\nbreak;\r\n}\r\ncase IDLEMODE_CONTINUE:\r\n{\r\ncurrdriverstate = IDLEMODE_CONTINUE;\r\nGPIO_num = DISABLE_GPIO_NUM;\r\n}\r\nbreak;\r\ncase IDLEMODE_EXIT:\r\n{\r\n}\r\nbreak;\r\ncase DRIVER_HALT:\r\n{\r\ncurrdriverstate = DRIVER_HALT;\r\nGPIO_num = DISABLE_GPIO_NUM;\r\nfor(uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++)\r\n{\r\nif(Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num !=\r\nDISABLE_GPIO_NUM)\r\nTURN_OFF_LED((1<<Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num),uiIndex);\r\n}\r\n}\r\nbreak;\r\ncase LED_THREAD_INACTIVE :\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"InActivating LED thread...");\r\ncurrdriverstate = LED_THREAD_INACTIVE;\r\nAdapter->LEDInfo.led_thread_running = BCM_LED_THREAD_RUNNING_INACTIVELY ;\r\nAdapter->LEDInfo.bLedInitDone = FALSE ;\r\nfor(uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++)\r\n{\r\nif(Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num !=\r\nDISABLE_GPIO_NUM)\r\nTURN_OFF_LED((1<<Adapter->LEDInfo.LEDState[uiIndex].GPIO_Num),uiIndex);\r\n}\r\n}\r\nbreak;\r\ncase LED_THREAD_ACTIVE :\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"Activating LED thread again...");\r\nif(Adapter->LinkUpStatus == FALSE)\r\nAdapter->DriverState = NO_NETWORK_ENTRY;\r\nelse\r\nAdapter->DriverState = NORMAL_OPERATION;\r\nAdapter->LEDInfo.led_thread_running = BCM_LED_THREAD_RUNNING_ACTIVELY ;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nAdapter->LEDInfo.led_thread_running = BCM_LED_THREAD_DISABLED;\r\n}\r\nint InitLedSettings(PMINI_ADAPTER Adapter)\r\n{\r\nint Status = STATUS_SUCCESS;\r\nBOOLEAN bEnableThread = TRUE;\r\nUCHAR uiIndex = 0;\r\nfor(uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++) {\r\nAdapter->LEDInfo.LEDState[uiIndex].BitPolarity = 1;\r\n}\r\nStatus = ReadConfigFileStructure(Adapter, &bEnableThread);\r\nif(STATUS_SUCCESS != Status)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,"LED Thread: FAILED in ReadConfigFileStructure\n");\r\nreturn Status;\r\n}\r\nif(Adapter->LEDInfo.led_thread_running)\r\n{\r\nif(bEnableThread)\r\n;\r\nelse\r\n{\r\nAdapter->DriverState = DRIVER_HALT;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\nAdapter->LEDInfo.led_thread_running = BCM_LED_THREAD_DISABLED;\r\n}\r\n}\r\nelse if(bEnableThread)\r\n{\r\ninit_waitqueue_head(&Adapter->LEDInfo.notify_led_event);\r\ninit_waitqueue_head(&Adapter->LEDInfo.idleModeSyncEvent);\r\nAdapter->LEDInfo.led_thread_running = BCM_LED_THREAD_RUNNING_ACTIVELY;\r\nAdapter->LEDInfo.bIdle_led_off = FALSE;\r\nAdapter->LEDInfo.led_cntrl_threadid = kthread_run((int (*)(void *))\r\nLEDControlThread, Adapter, "led_control_thread");\r\nif(IS_ERR(Adapter->LEDInfo.led_cntrl_threadid))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL, "Not able to spawn Kernel Thread\n");\r\nAdapter->LEDInfo.led_thread_running = BCM_LED_THREAD_DISABLED;\r\nreturn PTR_ERR(Adapter->LEDInfo.led_cntrl_threadid);\r\n}\r\n}\r\nreturn Status;\r\n}
