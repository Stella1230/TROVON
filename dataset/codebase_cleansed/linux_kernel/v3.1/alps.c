static bool alps_is_valid_first_byte(const struct alps_model_info *model,\r\nunsigned char data)\r\n{\r\nreturn (data & model->mask0) == model->byte0;\r\n}\r\nstatic void alps_report_buttons(struct psmouse *psmouse,\r\nstruct input_dev *dev1, struct input_dev *dev2,\r\nint left, int right, int middle)\r\n{\r\nstruct input_dev *dev;\r\ndev = test_bit(BTN_LEFT, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_LEFT, left);\r\ndev = test_bit(BTN_RIGHT, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ndev = test_bit(BTN_MIDDLE, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\ninput_sync(dev2);\r\n}\r\nstatic void alps_process_packet(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nconst struct alps_model_info *model = priv->i;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct input_dev *dev2 = priv->dev2;\r\nint x, y, z, ges, fin, left, right, middle;\r\nint back = 0, forward = 0;\r\nif (model->flags & ALPS_OLDPROTO) {\r\nleft = packet[2] & 0x10;\r\nright = packet[2] & 0x08;\r\nmiddle = 0;\r\nx = packet[1] | ((packet[0] & 0x07) << 7);\r\ny = packet[4] | ((packet[3] & 0x07) << 7);\r\nz = packet[5];\r\n} else {\r\nleft = packet[3] & 1;\r\nright = packet[3] & 2;\r\nmiddle = packet[3] & 4;\r\nx = packet[1] | ((packet[2] & 0x78) << (7 - 3));\r\ny = packet[4] | ((packet[3] & 0x70) << (7 - 4));\r\nz = packet[5];\r\n}\r\nif (model->flags & ALPS_FW_BK_1) {\r\nback = packet[0] & 0x10;\r\nforward = packet[2] & 4;\r\n}\r\nif (model->flags & ALPS_FW_BK_2) {\r\nback = packet[3] & 4;\r\nforward = packet[2] & 4;\r\nif ((middle = forward && back))\r\nforward = back = 0;\r\n}\r\nges = packet[2] & 1;\r\nfin = packet[2] & 2;\r\nif ((model->flags & ALPS_DUALPOINT) && z == 127) {\r\ninput_report_rel(dev2, REL_X, (x > 383 ? (x - 768) : x));\r\ninput_report_rel(dev2, REL_Y, -(y > 255 ? (y - 512) : y));\r\nalps_report_buttons(psmouse, dev2, dev, left, right, middle);\r\ninput_sync(dev2);\r\nreturn;\r\n}\r\nalps_report_buttons(psmouse, dev, dev2, left, right, middle);\r\nif (ges && !fin)\r\nz = 40;\r\nif (ges && fin && !priv->prev_fin) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\ninput_report_abs(dev, ABS_PRESSURE, 0);\r\ninput_report_key(dev, BTN_TOOL_FINGER, 0);\r\ninput_sync(dev);\r\n}\r\npriv->prev_fin = fin;\r\nif (z > 30)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nif (z < 25)\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nif (z > 0) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, z);\r\ninput_report_key(dev, BTN_TOOL_FINGER, z > 0);\r\nif (model->flags & ALPS_WHEEL)\r\ninput_report_rel(dev, REL_WHEEL, ((packet[2] << 1) & 0x08) - ((packet[0] >> 4) & 0x07));\r\nif (model->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\r\ninput_report_key(dev, BTN_FORWARD, forward);\r\ninput_report_key(dev, BTN_BACK, back);\r\n}\r\nif (model->flags & ALPS_FOUR_BUTTONS) {\r\ninput_report_key(dev, BTN_0, packet[2] & 4);\r\ninput_report_key(dev, BTN_1, packet[0] & 0x10);\r\ninput_report_key(dev, BTN_2, packet[3] & 4);\r\ninput_report_key(dev, BTN_3, packet[0] & 0x20);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void alps_report_bare_ps2_packet(struct psmouse *psmouse,\r\nunsigned char packet[],\r\nbool report_buttons)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct input_dev *dev2 = priv->dev2;\r\nif (report_buttons)\r\nalps_report_buttons(psmouse, dev2, psmouse->dev,\r\npacket[0] & 1, packet[0] & 2, packet[0] & 4);\r\ninput_report_rel(dev2, REL_X,\r\npacket[1] ? packet[1] - ((packet[0] << 4) & 0x100) : 0);\r\ninput_report_rel(dev2, REL_Y,\r\npacket[2] ? ((packet[0] << 3) & 0x100) - packet[2] : 0);\r\ninput_sync(dev2);\r\n}\r\nstatic psmouse_ret_t alps_handle_interleaved_ps2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nif (psmouse->pktcnt < 6)\r\nreturn PSMOUSE_GOOD_DATA;\r\nif (psmouse->pktcnt == 6) {\r\nmod_timer(&priv->timer, jiffies + msecs_to_jiffies(20));\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\ndel_timer(&priv->timer);\r\nif (psmouse->packet[6] & 0x80) {\r\nif (((psmouse->packet[3] |\r\npsmouse->packet[4] |\r\npsmouse->packet[5]) & 0x80) ||\r\n(!alps_is_valid_first_byte(priv->i, psmouse->packet[6]))) {\r\ndbg("refusing packet %x %x %x %x "\r\n"(suspected interleaved ps/2)\n",\r\npsmouse->packet[3], psmouse->packet[4],\r\npsmouse->packet[5], psmouse->packet[6]);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nalps_process_packet(psmouse);\r\npsmouse->packet[0] = psmouse->packet[6];\r\npsmouse->pktcnt = 1;\r\n} else {\r\nalps_report_bare_ps2_packet(psmouse, &psmouse->packet[3],\r\nfalse);\r\npsmouse->packet[3] = psmouse->packet[6] & 0xf7;\r\npsmouse->pktcnt = 4;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic void alps_flush_packet(unsigned long data)\r\n{\r\nstruct psmouse *psmouse = (struct psmouse *)data;\r\nserio_pause_rx(psmouse->ps2dev.serio);\r\nif (psmouse->pktcnt == 6) {\r\nif ((psmouse->packet[3] |\r\npsmouse->packet[4] |\r\npsmouse->packet[5]) & 0x80) {\r\ndbg("refusing packet %x %x %x "\r\n"(suspected interleaved ps/2)\n",\r\npsmouse->packet[3], psmouse->packet[4],\r\npsmouse->packet[5]);\r\n} else {\r\nalps_process_packet(psmouse);\r\n}\r\npsmouse->pktcnt = 0;\r\n}\r\nserio_continue_rx(psmouse->ps2dev.serio);\r\n}\r\nstatic psmouse_ret_t alps_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nconst struct alps_model_info *model = priv->i;\r\nif ((psmouse->packet[0] & 0xc8) == 0x08) {\r\nif (psmouse->pktcnt == 3) {\r\nalps_report_bare_ps2_packet(psmouse, psmouse->packet,\r\ntrue);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nif ((model->flags & ALPS_PS2_INTERLEAVED) &&\r\npsmouse->pktcnt >= 4 && (psmouse->packet[3] & 0x0f) == 0x0f) {\r\nreturn alps_handle_interleaved_ps2(psmouse);\r\n}\r\nif (!alps_is_valid_first_byte(model, psmouse->packet[0])) {\r\ndbg("refusing packet[0] = %x (mask0 = %x, byte0 = %x)\n",\r\npsmouse->packet[0], model->mask0, model->byte0);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (psmouse->pktcnt >= 2 && psmouse->pktcnt <= 6 &&\r\n(psmouse->packet[psmouse->pktcnt - 1] & 0x80)) {\r\ndbg("refusing packet[%i] = %x\n",\r\npsmouse->pktcnt - 1, psmouse->packet[psmouse->pktcnt - 1]);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (psmouse->pktcnt == 6) {\r\nalps_process_packet(psmouse);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int *version)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstatic const unsigned char rates[] = { 0, 10, 20, 40, 60, 80, 100, 200 };\r\nunsigned char param[4];\r\nint i;\r\nparam[0] = 0;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11))\r\nreturn NULL;\r\nparam[0] = param[1] = param[2] = 0xff;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn NULL;\r\ndbg("E6 report: %2.2x %2.2x %2.2x", param[0], param[1], param[2]);\r\nif (param[0] != 0 || param[1] != 0 || (param[2] != 10 && param[2] != 100))\r\nreturn NULL;\r\nparam[0] = 0;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21))\r\nreturn NULL;\r\nparam[0] = param[1] = param[2] = 0xff;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn NULL;\r\ndbg("E7 report: %2.2x %2.2x %2.2x", param[0], param[1], param[2]);\r\nif (version) {\r\nfor (i = 0; i < ARRAY_SIZE(rates) && param[2] != rates[i]; i++)\r\n;\r\n*version = (param[0] << 8) | (param[1] << 4) | i;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(alps_model_data); i++)\r\nif (!memcmp(param, alps_model_data[i].signature,\r\nsizeof(alps_model_data[i].signature)))\r\nreturn alps_model_data + i;\r\nreturn NULL;\r\n}\r\nstatic int alps_passthrough_mode(struct psmouse *psmouse, bool enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint cmd = enable ? PSMOUSE_CMD_SETSCALE21 : PSMOUSE_CMD_SETSCALE11;\r\nif (ps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))\r\nreturn -1;\r\nps2_drain(ps2dev, 3, 100);\r\nreturn 0;\r\n}\r\nstatic int alps_absolute_mode(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE))\r\nreturn -1;\r\nreturn ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETPOLL);\r\n}\r\nstatic int alps_get_status(struct psmouse *psmouse, char *param)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\ndbg("Status: %2.2x %2.2x %2.2x", param[0], param[1], param[2]);\r\nreturn 0;\r\n}\r\nstatic int alps_tap_mode(struct psmouse *psmouse, int enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint cmd = enable ? PSMOUSE_CMD_SETRATE : PSMOUSE_CMD_SETRES;\r\nunsigned char tap_arg = enable ? 0x0A : 0x00;\r\nunsigned char param[4];\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, &tap_arg, cmd))\r\nreturn -1;\r\nif (alps_get_status(psmouse, param))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_poll(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char buf[6];\r\nbool poll_failed;\r\nif (priv->i->flags & ALPS_PASS)\r\nalps_passthrough_mode(psmouse, true);\r\npoll_failed = ps2_command(&psmouse->ps2dev, buf,\r\nPSMOUSE_CMD_POLL | (psmouse->pktsize << 8)) < 0;\r\nif (priv->i->flags & ALPS_PASS)\r\nalps_passthrough_mode(psmouse, false);\r\nif (poll_failed || (buf[0] & priv->i->mask0) != priv->i->byte0)\r\nreturn -1;\r\nif ((psmouse->badbyte & 0xc8) == 0x08) {\r\nif (ps2_command(&psmouse->ps2dev, buf, PSMOUSE_CMD_POLL | (3 << 8)))\r\nreturn -1;\r\n}\r\nmemcpy(psmouse->packet, buf, sizeof(buf));\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nconst struct alps_model_info *model = priv->i;\r\nif ((model->flags & ALPS_PASS) &&\r\nalps_passthrough_mode(psmouse, true)) {\r\nreturn -1;\r\n}\r\nif (alps_tap_mode(psmouse, true)) {\r\nprintk(KERN_WARNING "alps.c: Failed to enable hardware tapping\n");\r\nreturn -1;\r\n}\r\nif (alps_absolute_mode(psmouse)) {\r\nprintk(KERN_ERR "alps.c: Failed to enable absolute mode\n");\r\nreturn -1;\r\n}\r\nif ((model->flags & ALPS_PASS) &&\r\nalps_passthrough_mode(psmouse, false)) {\r\nreturn -1;\r\n}\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSTREAM)) {\r\nprintk(KERN_ERR "alps.c: Failed to enable stream mode\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_reconnect(struct psmouse *psmouse)\r\n{\r\nconst struct alps_model_info *model;\r\npsmouse_reset(psmouse);\r\nmodel = alps_get_model(psmouse, NULL);\r\nif (!model)\r\nreturn -1;\r\nreturn alps_hw_init(psmouse);\r\n}\r\nstatic void alps_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\npsmouse_reset(psmouse);\r\ndel_timer_sync(&priv->timer);\r\ninput_unregister_device(priv->dev2);\r\nkfree(priv);\r\n}\r\nint alps_init(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv;\r\nconst struct alps_model_info *model;\r\nstruct input_dev *dev1 = psmouse->dev, *dev2;\r\nint version;\r\npriv = kzalloc(sizeof(struct alps_data), GFP_KERNEL);\r\ndev2 = input_allocate_device();\r\nif (!priv || !dev2)\r\ngoto init_fail;\r\npriv->dev2 = dev2;\r\nsetup_timer(&priv->timer, alps_flush_packet, (unsigned long)psmouse);\r\npsmouse->private = priv;\r\nmodel = alps_get_model(psmouse, &version);\r\nif (!model)\r\ngoto init_fail;\r\npriv->i = model;\r\nif (alps_hw_init(psmouse))\r\ngoto init_fail;\r\n__clear_bit(EV_REL, dev1->evbit);\r\n__clear_bit(REL_X, dev1->relbit);\r\n__clear_bit(REL_Y, dev1->relbit);\r\ndev1->evbit[BIT_WORD(EV_KEY)] |= BIT_MASK(EV_KEY);\r\ndev1->keybit[BIT_WORD(BTN_TOUCH)] |= BIT_MASK(BTN_TOUCH);\r\ndev1->keybit[BIT_WORD(BTN_TOOL_FINGER)] |= BIT_MASK(BTN_TOOL_FINGER);\r\ndev1->keybit[BIT_WORD(BTN_LEFT)] |=\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT);\r\ndev1->evbit[BIT_WORD(EV_ABS)] |= BIT_MASK(EV_ABS);\r\ninput_set_abs_params(dev1, ABS_X, 0, 1023, 0, 0);\r\ninput_set_abs_params(dev1, ABS_Y, 0, 767, 0, 0);\r\ninput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\r\nif (model->flags & ALPS_WHEEL) {\r\ndev1->evbit[BIT_WORD(EV_REL)] |= BIT_MASK(EV_REL);\r\ndev1->relbit[BIT_WORD(REL_WHEEL)] |= BIT_MASK(REL_WHEEL);\r\n}\r\nif (model->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\r\ndev1->keybit[BIT_WORD(BTN_FORWARD)] |= BIT_MASK(BTN_FORWARD);\r\ndev1->keybit[BIT_WORD(BTN_BACK)] |= BIT_MASK(BTN_BACK);\r\n}\r\nif (model->flags & ALPS_FOUR_BUTTONS) {\r\ndev1->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_0);\r\ndev1->keybit[BIT_WORD(BTN_1)] |= BIT_MASK(BTN_1);\r\ndev1->keybit[BIT_WORD(BTN_2)] |= BIT_MASK(BTN_2);\r\ndev1->keybit[BIT_WORD(BTN_3)] |= BIT_MASK(BTN_3);\r\n} else {\r\ndev1->keybit[BIT_WORD(BTN_MIDDLE)] |= BIT_MASK(BTN_MIDDLE);\r\n}\r\nsnprintf(priv->phys, sizeof(priv->phys), "%s/input1", psmouse->ps2dev.serio->phys);\r\ndev2->phys = priv->phys;\r\ndev2->name = (model->flags & ALPS_DUALPOINT) ? "DualPoint Stick" : "PS/2 Mouse";\r\ndev2->id.bustype = BUS_I8042;\r\ndev2->id.vendor = 0x0002;\r\ndev2->id.product = PSMOUSE_ALPS;\r\ndev2->id.version = 0x0000;\r\ndev2->dev.parent = &psmouse->ps2dev.serio->dev;\r\ndev2->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ndev2->relbit[BIT_WORD(REL_X)] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\ndev2->keybit[BIT_WORD(BTN_LEFT)] =\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\r\nif (input_register_device(priv->dev2))\r\ngoto init_fail;\r\npsmouse->protocol_handler = alps_process_byte;\r\npsmouse->poll = alps_poll;\r\npsmouse->disconnect = alps_disconnect;\r\npsmouse->reconnect = alps_reconnect;\r\npsmouse->pktsize = 6;\r\npsmouse->resync_time = 0;\r\nreturn 0;\r\ninit_fail:\r\npsmouse_reset(psmouse);\r\ninput_free_device(dev2);\r\nkfree(priv);\r\npsmouse->private = NULL;\r\nreturn -1;\r\n}\r\nint alps_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nint version;\r\nconst struct alps_model_info *model;\r\nmodel = alps_get_model(psmouse, &version);\r\nif (!model)\r\nreturn -1;\r\nif (set_properties) {\r\npsmouse->vendor = "ALPS";\r\npsmouse->name = model->flags & ALPS_DUALPOINT ?\r\n"DualPoint TouchPad" : "GlidePoint";\r\npsmouse->model = version;\r\n}\r\nreturn 0;\r\n}
