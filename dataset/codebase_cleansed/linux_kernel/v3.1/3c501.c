struct net_device * __init el1_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nstatic const unsigned ports[] = { 0x280, 0x300, 0};\r\nconst unsigned *port;\r\nint err = 0;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio = dev->base_addr;\r\nirq = dev->irq;\r\nmem_start = dev->mem_start & 7;\r\n}\r\nif (io > 0x1ff) {\r\nerr = el1_probe1(dev, io);\r\n} else if (io != 0) {\r\nerr = -ENXIO;\r\n} else {\r\nfor (port = ports; *port && el1_probe1(dev, *port); port++)\r\n;\r\nif (!*port)\r\nerr = -ENODEV;\r\n}\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\nrelease_region(dev->base_addr, EL1_IO_EXTENT);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init el1_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nstruct net_local *lp;\r\nconst char *mname;\r\nunsigned char station_addr[6];\r\nint autoirq = 0;\r\nint i;\r\nif (!request_region(ioaddr, EL1_IO_EXTENT, DRV_NAME))\r\nreturn -ENODEV;\r\nfor (i = 0; i < 6; i++) {\r\noutw(i, ioaddr + EL1_DATAPTR);\r\nstation_addr[i] = inb(ioaddr + EL1_SAPROM);\r\n}\r\nif (station_addr[0] == 0x02 && station_addr[1] == 0x60 &&\r\nstation_addr[2] == 0x8c)\r\nmname = "3c501";\r\nelse if (station_addr[0] == 0x00 && station_addr[1] == 0x80 &&\r\nstation_addr[2] == 0xC8)\r\nmname = "NP943";\r\nelse {\r\nrelease_region(ioaddr, EL1_IO_EXTENT);\r\nreturn -ENODEV;\r\n}\r\ndev->irq = irq;\r\nif (dev->irq < 2) {\r\nunsigned long irq_mask;\r\nirq_mask = probe_irq_on();\r\ninb(RX_STATUS);\r\ninb(TX_STATUS);\r\noutb(AX_LOOP + 1, AX_CMD);\r\noutb(0x00, AX_CMD);\r\nmdelay(20);\r\nautoirq = probe_irq_off(irq_mask);\r\nif (autoirq == 0) {\r\npr_warning("%s probe at %#x failed to detect IRQ line.\n",\r\nmname, ioaddr);\r\nrelease_region(ioaddr, EL1_IO_EXTENT);\r\nreturn -EAGAIN;\r\n}\r\n}\r\noutb(AX_RESET+AX_LOOP, AX_CMD);\r\ndev->base_addr = ioaddr;\r\nmemcpy(dev->dev_addr, station_addr, ETH_ALEN);\r\nif (mem_start & 0xf)\r\nel_debug = mem_start & 0x7;\r\nif (autoirq)\r\ndev->irq = autoirq;\r\npr_info("%s: %s EtherLink at %#lx, using %sIRQ %d.\n",\r\ndev->name, mname, dev->base_addr,\r\nautoirq ? "auto":"assigned ", dev->irq);\r\n#ifdef CONFIG_IP_MULTICAST\r\npr_warning("WARNING: Use of the 3c501 in a multicast kernel is NOT recommended.\n");\r\n#endif\r\nif (el_debug)\r\npr_debug("%s", version);\r\nlp = netdev_priv(dev);\r\nmemset(lp, 0, sizeof(struct net_local));\r\nspin_lock_init(&lp->lock);\r\ndev->netdev_ops = &el_netdev_ops;\r\ndev->watchdog_timeo = HZ;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\nreturn 0;\r\n}\r\nstatic int el_open(struct net_device *dev)\r\n{\r\nint retval;\r\nint ioaddr = dev->base_addr;\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nif (el_debug > 2)\r\npr_debug("%s: Doing el_open()...\n", dev->name);\r\nretval = request_irq(dev->irq, el_interrupt, 0, dev->name, dev);\r\nif (retval)\r\nreturn retval;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nel_reset(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nlp->txing = 0;\r\noutb(AX_RX, AX_CMD);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void el_timeout(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif (el_debug)\r\npr_debug("%s: transmit timed out, txsr %#2x axsr=%02x rxsr=%02x.\n",\r\ndev->name, inb(TX_STATUS),\r\ninb(AX_STATUS), inb(RX_STATUS));\r\ndev->stats.tx_errors++;\r\noutb(TX_NORM, TX_CMD);\r\noutb(RX_NORM, RX_CMD);\r\noutb(AX_OFF, AX_CMD);\r\noutb(AX_RX, AX_CMD);\r\nlp->txing = 0;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t el_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nnetif_stop_queue(dev);\r\ndo {\r\nint len = skb->len;\r\nint pad = 0;\r\nint gp_start;\r\nunsigned char *buf = skb->data;\r\nif (len < ETH_ZLEN)\r\npad = ETH_ZLEN - len;\r\ngp_start = 0x800 - (len + pad);\r\nlp->tx_pkt_start = gp_start;\r\nlp->collisions = 0;\r\ndev->stats.tx_bytes += skb->len;\r\noutb_p(AX_SYS, AX_CMD);\r\ninb_p(RX_STATUS);\r\ninb_p(TX_STATUS);\r\nlp->loading = 1;\r\nlp->txing = 1;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\noutw(0x00, RX_BUF_CLR);\r\noutw(gp_start, GP_LOW);\r\noutsb(DATAPORT, buf, len);\r\nif (pad) {\r\nwhile (pad--)\r\noutb(0, DATAPORT);\r\n}\r\noutw(gp_start, GP_LOW);\r\nif (lp->loading != 2) {\r\noutb(AX_XMIT, AX_CMD);\r\nlp->loading = 0;\r\nif (el_debug > 2)\r\npr_debug(" queued xmit.\n");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (el_debug > 2)\r\npr_debug("%s: burped during tx load.\n", dev->name);\r\nspin_lock_irqsave(&lp->lock, flags);\r\n} while (1);\r\n}\r\nstatic irqreturn_t el_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *lp;\r\nint ioaddr;\r\nint axsr;\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nspin_lock(&lp->lock);\r\naxsr = inb(AX_STATUS);\r\nif (el_debug > 3)\r\npr_debug("%s: el_interrupt() aux=%#02x\n", dev->name, axsr);\r\nif (lp->loading == 1 && !lp->txing)\r\npr_warning("%s: Inconsistent state loading while not in tx\n",\r\ndev->name);\r\nif (lp->txing) {\r\nint txsr = inb(TX_STATUS);\r\nif (lp->loading == 1) {\r\nif (el_debug > 2)\r\npr_debug("%s: Interrupt while loading [txsr=%02x gp=%04x rp=%04x]\n",\r\ndev->name, txsr, inw(GP_LOW), inw(RX_LOW));\r\nlp->loading = 2;\r\nspin_unlock(&lp->lock);\r\ngoto out;\r\n}\r\nif (el_debug > 6)\r\npr_debug("%s: txsr=%02x gp=%04x rp=%04x\n", dev->name,\r\ntxsr, inw(GP_LOW), inw(RX_LOW));\r\nif ((axsr & 0x80) && (txsr & TX_READY) == 0) {\r\nif (el_debug > 1)\r\npr_debug("%s: Unusual interrupt during Tx, txsr=%02x axsr=%02x gp=%03x rp=%03x.\n",\r\ndev->name, txsr, axsr,\r\ninw(ioaddr + EL1_DATAPTR),\r\ninw(ioaddr + EL1_RXPTR));\r\nlp->txing = 0;\r\nnetif_wake_queue(dev);\r\n} else if (txsr & TX_16COLLISIONS) {\r\nif (el_debug)\r\npr_debug("%s: Transmit failed 16 times, Ethernet jammed?\n", dev->name);\r\noutb(AX_SYS, AX_CMD);\r\nlp->txing = 0;\r\ndev->stats.tx_aborted_errors++;\r\nnetif_wake_queue(dev);\r\n} else if (txsr & TX_COLLISION) {\r\nif (el_debug > 6)\r\npr_debug("%s: retransmitting after a collision.\n", dev->name);\r\noutb(AX_SYS, AX_CMD);\r\noutw(lp->tx_pkt_start, GP_LOW);\r\noutb(AX_XMIT, AX_CMD);\r\ndev->stats.collisions++;\r\nspin_unlock(&lp->lock);\r\ngoto out;\r\n} else {\r\ndev->stats.tx_packets++;\r\nif (el_debug > 6)\r\npr_debug("%s: Tx succeeded %s\n", dev->name,\r\n(txsr & TX_RDY) ? "." : "but tx is busy!");\r\nlp->txing = 0;\r\nnetif_wake_queue(dev);\r\n}\r\n} else {\r\nint rxsr = inb(RX_STATUS);\r\nif (el_debug > 5)\r\npr_debug("%s: rxsr=%02x txsr=%02x rp=%04x\n",\r\ndev->name, rxsr, inb(TX_STATUS), inw(RX_LOW));\r\nif (rxsr & RX_MISSED)\r\ndev->stats.rx_missed_errors++;\r\nelse if (rxsr & RX_RUNT) {\r\ndev->stats.rx_length_errors++;\r\nif (el_debug > 5)\r\npr_debug("%s: runt.\n", dev->name);\r\n} else if (rxsr & RX_GOOD) {\r\nel_receive(dev);\r\n} else {\r\nif (el_debug > 2)\r\npr_debug("%s: No packet seen, rxsr=%02x **resetting 3c501***\n",\r\ndev->name, rxsr);\r\nel_reset(dev);\r\n}\r\n}\r\noutb(AX_RX, AX_CMD);\r\noutw(0x00, RX_BUF_CLR);\r\ninb(RX_STATUS);\r\ninb(TX_STATUS);\r\nspin_unlock(&lp->lock);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void el_receive(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint pkt_len;\r\nstruct sk_buff *skb;\r\npkt_len = inw(RX_LOW);\r\nif (el_debug > 4)\r\npr_debug(" el_receive %d.\n", pkt_len);\r\nif (pkt_len < 60 || pkt_len > 1536) {\r\nif (el_debug)\r\npr_debug("%s: bogus packet, length=%d\n",\r\ndev->name, pkt_len);\r\ndev->stats.rx_over_errors++;\r\nreturn;\r\n}\r\noutb(AX_SYS, AX_CMD);\r\nskb = dev_alloc_skb(pkt_len+2);\r\noutw(0x00, GP_LOW);\r\nif (skb == NULL) {\r\npr_info("%s: Memory squeeze, dropping packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n} else {\r\nskb_reserve(skb, 2);\r\ninsb(DATAPORT, skb_put(skb, pkt_len), pkt_len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\n}\r\nstatic void el_reset(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif (el_debug > 2)\r\npr_info("3c501 reset...\n");\r\noutb(AX_RESET, AX_CMD);\r\noutb(AX_LOOP, AX_CMD);\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\noutb(dev->dev_addr[i], ioaddr + i);\r\n}\r\noutw(0, RX_BUF_CLR);\r\noutb(TX_NORM, TX_CMD);\r\noutb(RX_NORM, RX_CMD);\r\ninb(RX_STATUS);\r\ninb(TX_STATUS);\r\nlp->txing = 0;\r\n}\r\nstatic int el1_close(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nif (el_debug > 2)\r\npr_info("%s: Shutting down Ethernet card at %#x.\n",\r\ndev->name, ioaddr);\r\nnetif_stop_queue(dev);\r\nfree_irq(dev->irq, dev);\r\noutb(AX_RESET, AX_CMD);\r\nreturn 0;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nif (dev->flags & IFF_PROMISC) {\r\noutb(RX_PROM, RX_CMD);\r\ninb(RX_STATUS);\r\n} else if (!netdev_mc_empty(dev) || dev->flags & IFF_ALLMULTI) {\r\noutb(RX_MULT, RX_CMD);\r\ninb(RX_STATUS);\r\n} else {\r\noutb(RX_NORM, RX_CMD);\r\ninb(RX_STATUS);\r\n}\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->bus_info, "ISA 0x%lx", dev->base_addr);\r\n}\r\nstatic u32 netdev_get_msglevel(struct net_device *dev)\r\n{\r\nreturn debug;\r\n}\r\nstatic void netdev_set_msglevel(struct net_device *dev, u32 level)\r\n{\r\ndebug = level;\r\n}\r\nint __init init_module(void)\r\n{\r\ndev_3c501 = el1_probe(-1);\r\nif (IS_ERR(dev_3c501))\r\nreturn PTR_ERR(dev_3c501);\r\nreturn 0;\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nstruct net_device *dev = dev_3c501;\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, EL1_IO_EXTENT);\r\nfree_netdev(dev);\r\n}
