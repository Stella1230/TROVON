static struct prpmc2800_board_info *prpmc2800_get_board_info(u8 *vpd)\r\n{\r\nstruct prpmc2800_board_info *bip;\r\nint i;\r\nfor (i=0,bip=prpmc2800_board_info; i<ARRAY_SIZE(prpmc2800_board_info);\r\ni++,bip++)\r\nif ((vpd[0] == bip->subsys0) && (vpd[1] == bip->subsys1)\r\n&& ((vpd[4] & bip->vpd4_mask) == bip->vpd4))\r\nreturn bip;\r\nreturn NULL;\r\n}\r\nstatic struct prpmc2800_board_info *prpmc2800_get_bip(void)\r\n{\r\nstruct prpmc2800_board_info *bip;\r\nu8 vpd[5];\r\nint rc;\r\nif (mv64x60_i2c_open())\r\nfatal("Error: Can't open i2c device\n\r");\r\nmemset(vpd, 0, sizeof(vpd));\r\nrc = mv64x60_i2c_read(EEPROM2_ADDR, vpd, 0x1fde, 2, sizeof(vpd));\r\nif (rc < 0)\r\nfatal("Error: Couldn't read eeprom2\n\r");\r\nmv64x60_i2c_close();\r\nbip = prpmc2800_get_board_info(vpd);\r\nif (bip == NULL) {\r\nprintf("Error: Unsupported board or corrupted VPD:\n\r");\r\nprintf(" 0x%x 0x%x 0x%x 0x%x 0x%x\n\r",\r\nvpd[0], vpd[1], vpd[2], vpd[3], vpd[4]);\r\nprintf("Using device tree defaults...\n\r");\r\n}\r\nreturn bip;\r\n}\r\nstatic void prpmc2800_bridge_setup(u32 mem_size)\r\n{\r\nu32 i, v[12], enables, acc_bits;\r\nu32 pci_base_hi, pci_base_lo, size, buf[2];\r\nunsigned long cpu_base;\r\nint rc;\r\nvoid *devp;\r\nu8 *bridge_pbase, is_coherent;\r\nstruct mv64x60_cpu2pci_win *tbl;\r\nbridge_pbase = mv64x60_get_bridge_pbase();\r\nis_coherent = mv64x60_is_coherent();\r\nif (is_coherent)\r\nacc_bits = MV64x60_PCI_ACC_CNTL_SNOOP_WB\r\n| MV64x60_PCI_ACC_CNTL_SWAP_NONE\r\n| MV64x60_PCI_ACC_CNTL_MBURST_32_BYTES\r\n| MV64x60_PCI_ACC_CNTL_RDSIZE_32_BYTES;\r\nelse\r\nacc_bits = MV64x60_PCI_ACC_CNTL_SNOOP_NONE\r\n| MV64x60_PCI_ACC_CNTL_SWAP_NONE\r\n| MV64x60_PCI_ACC_CNTL_MBURST_128_BYTES\r\n| MV64x60_PCI_ACC_CNTL_RDSIZE_256_BYTES;\r\nmv64x60_config_ctlr_windows(bridge_base, bridge_pbase, is_coherent);\r\nmv64x60_config_pci_windows(bridge_base, bridge_pbase, 0, 0, mem_size,\r\nacc_bits);\r\ndevp = find_node_by_compatible(NULL, "marvell,mv64360-pci");\r\nif (devp == NULL)\r\nfatal("Error: Missing marvell,mv64360-pci"\r\n" device tree node\n\r");\r\nrc = getprop(devp, "ranges", v, sizeof(v));\r\nif (rc != sizeof(v))\r\nfatal("Error: Can't find marvell,mv64360-pci ranges"\r\n" property\n\r");\r\ndevp = find_node_by_compatible(NULL, "marvell,mv64360");\r\nif (devp == NULL)\r\nfatal("Error: Missing marvell,mv64360 device tree node\n\r");\r\nenables = in_le32((u32 *)(bridge_base + MV64x60_CPU_BAR_ENABLE));\r\nenables |= 0x0007fe00;\r\nout_le32((u32 *)(bridge_base + MV64x60_CPU_BAR_ENABLE), enables);\r\nfor (i=0; i<12; i+=6) {\r\nswitch (v[i] & 0xff000000) {\r\ncase 0x01000000:\r\ntbl = mv64x60_cpu2pci_io;\r\nbreak;\r\ncase 0x02000000:\r\ntbl = mv64x60_cpu2pci_mem;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\npci_base_hi = v[i+1];\r\npci_base_lo = v[i+2];\r\ncpu_base = v[i+3];\r\nsize = v[i+5];\r\nbuf[0] = cpu_base;\r\nbuf[1] = size;\r\nif (!dt_xlate_addr(devp, buf, sizeof(buf), &cpu_base))\r\nfatal("Error: Can't translate PCI address 0x%x\n\r",\r\n(u32)cpu_base);\r\nmv64x60_config_cpu2pci_window(bridge_base, 0, pci_base_hi,\r\npci_base_lo, cpu_base, size, tbl);\r\n}\r\nenables &= ~0x00000600;\r\nout_le32((u32 *)(bridge_base + MV64x60_CPU_BAR_ENABLE), enables);\r\n}\r\nstatic void prpmc2800_fixups(void)\r\n{\r\nu32 v[2], l, mem_size;\r\nint rc;\r\nvoid *devp;\r\nchar model[BOARD_MODEL_MAX];\r\nstruct prpmc2800_board_info *bip;\r\nbip = prpmc2800_get_bip();\r\nmem_size = (bip) ? bip->mem_size : mv64x60_get_mem_size(bridge_base);\r\nprpmc2800_bridge_setup(mem_size);\r\nif (!bip)\r\nreturn;\r\ndevp = finddevice("/");\r\nif (devp == NULL)\r\nfatal("Error: Missing '/' device tree node\n\r");\r\nmemset(model, 0, BOARD_MODEL_MAX);\r\nstrncpy(model, BOARD_MODEL, BOARD_MODEL_MAX - 2);\r\nl = strlen(model);\r\nif (bip->model == BOARD_MODEL_PRPMC280)\r\nl--;\r\nmodel[l++] = bip->variant;\r\nmodel[l++] = '\0';\r\nsetprop(devp, "model", model, l);\r\ndevp = find_node_by_prop_value_str(NULL, "device_type", "cpu");\r\nif (devp == NULL)\r\nfatal("Error: Missing proper cpu device tree node\n\r");\r\nv[0] = bip->core_speed;\r\nsetprop(devp, "clock-frequency", &v[0], sizeof(v[0]));\r\ndevp = finddevice("/memory");\r\nif (devp == NULL)\r\nfatal("Error: Missing /memory device tree node\n\r");\r\nv[0] = 0;\r\nv[1] = bip->mem_size;\r\nsetprop(devp, "reg", v, sizeof(v));\r\nif (bip->bridge_type == BRIDGE_TYPE_MV64362) {\r\ndevp = find_node_by_compatible(NULL, "marvell,mv64360");\r\nif (devp == NULL)\r\nfatal("Error: Missing marvell,mv64360"\r\n" device tree node\n\r");\r\nsetprop(devp, "model", "mv64362", strlen("mv64362") + 1);\r\n}\r\ndevp = find_node_by_compatible(NULL, "direct-mapped");\r\nif (devp == NULL)\r\nfatal("Error: Missing User FLASH device tree node\n\r");\r\nrc = getprop(devp, "reg", v, sizeof(v));\r\nif (rc != sizeof(v))\r\nfatal("Error: Can't find User FLASH reg property\n\r");\r\nv[1] = bip->user_flash;\r\nsetprop(devp, "reg", v, sizeof(v));\r\n}\r\nstatic void prpmc2800_reset(void)\r\n{\r\nu32 temp;\r\nudelay(5000000);\r\nif (bridge_base != 0) {\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_MPP_CNTL_0));\r\ntemp &= 0xFFFF0FFF;\r\nout_le32((u32 *)(bridge_base + MV64x60_MPP_CNTL_0), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_GPP_LEVEL_CNTL));\r\ntemp |= 0x00000004;\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_LEVEL_CNTL), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_GPP_IO_CNTL));\r\ntemp |= 0x00000004;\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_IO_CNTL), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_MPP_CNTL_2));\r\ntemp &= 0xFFFF0FFF;\r\nout_le32((u32 *)(bridge_base + MV64x60_MPP_CNTL_2), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_GPP_LEVEL_CNTL));\r\ntemp |= 0x00080000;\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_LEVEL_CNTL), temp);\r\ntemp = in_le32((u32 *)(bridge_base + MV64x60_GPP_IO_CNTL));\r\ntemp |= 0x00080000;\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_IO_CNTL), temp);\r\nout_le32((u32 *)(bridge_base + MV64x60_GPP_VALUE_SET),\r\n0x00080004);\r\n}\r\nfor (;;);\r\n}\r\nvoid platform_init(unsigned long r3, unsigned long r4, unsigned long r5,\r\nunsigned long r6, unsigned long r7)\r\n{\r\nstruct elf_info ei;\r\nchar *heap_start, *dtb;\r\nint dt_size = _dtb_end - _dtb_start;\r\nvoid *vmlinuz_addr = _vmlinux_start;\r\nunsigned long vmlinuz_size = _vmlinux_end - _vmlinux_start;\r\nchar elfheader[256];\r\nif (dt_size <= 0)\r\nexit();\r\ngunzip_start(&gzstate, vmlinuz_addr, vmlinuz_size);\r\ngunzip_exactly(&gzstate, elfheader, sizeof(elfheader));\r\nif (!parse_elf32(elfheader, &ei))\r\nexit();\r\nheap_start = (char *)(ei.memsize + ei.elfoffset);\r\nheap_start = max(heap_start, (char *)_end);\r\nif ((unsigned)simple_alloc_init(heap_start, HEAP_SIZE, 2*KB, 16)\r\n> (128*MB))\r\nexit();\r\ndtb = malloc(dt_size);\r\nif (!dtb)\r\nexit();\r\nmemmove(dtb, _dtb_start, dt_size);\r\nfdt_init(dtb);\r\nbridge_base = mv64x60_get_bridge_base();\r\nplatform_ops.fixups = prpmc2800_fixups;\r\nplatform_ops.exit = prpmc2800_reset;\r\nif (serial_console_init() < 0)\r\nexit();\r\n}
