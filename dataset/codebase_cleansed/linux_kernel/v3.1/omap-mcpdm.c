static int omap_mcpdm_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint err = 0;\r\nif (!dai->active)\r\nerr = omap_mcpdm_request();\r\nreturn err;\r\n}\r\nstatic void omap_mcpdm_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nif (!dai->active)\r\nomap_mcpdm_free();\r\n}\r\nstatic int omap_mcpdm_dai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm_data *mcpdm_priv = snd_soc_dai_get_drvdata(dai);\r\nint stream = substream->stream;\r\nint err = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (!mcpdm_priv->active++)\r\nomap_mcpdm_start(stream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (!--mcpdm_priv->active)\r\nomap_mcpdm_stop(stream);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int omap_mcpdm_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm_data *mcpdm_priv = snd_soc_dai_get_drvdata(dai);\r\nstruct omap_mcpdm_link *mcpdm_links = mcpdm_priv->links;\r\nint stream = substream->stream;\r\nint channels, err, link_mask = 0;\r\nsnd_soc_dai_set_dma_data(dai, substream,\r\n&omap_mcpdm_dai_dma_params[stream]);\r\nchannels = params_channels(params);\r\nswitch (channels) {\r\ncase 4:\r\nif (stream == SNDRV_PCM_STREAM_CAPTURE)\r\nreturn -EINVAL;\r\nlink_mask |= 1 << 3;\r\ncase 3:\r\nif (stream == SNDRV_PCM_STREAM_CAPTURE)\r\nreturn -EINVAL;\r\nlink_mask |= 1 << 2;\r\ncase 2:\r\nlink_mask |= 1 << 1;\r\ncase 1:\r\nlink_mask |= 1 << 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmcpdm_links[stream].channels = link_mask << 3;\r\nerr = omap_mcpdm_playback_open(&mcpdm_links[stream]);\r\n} else {\r\nmcpdm_links[stream].channels = link_mask << 0;\r\nerr = omap_mcpdm_capture_open(&mcpdm_links[stream]);\r\n}\r\nreturn err;\r\n}\r\nstatic int omap_mcpdm_dai_hw_free(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm_data *mcpdm_priv = snd_soc_dai_get_drvdata(dai);\r\nstruct omap_mcpdm_link *mcpdm_links = mcpdm_priv->links;\r\nint stream = substream->stream;\r\nint err;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nerr = omap_mcpdm_playback_close(&mcpdm_links[stream]);\r\nelse\r\nerr = omap_mcpdm_capture_close(&mcpdm_links[stream]);\r\nreturn err;\r\n}\r\nstatic int omap_mcpdm_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nsnd_soc_dai_set_drvdata(dai, &mcpdm_data);\r\nreturn 0;\r\n}\r\nstatic __devinit int asoc_mcpdm_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nret = omap_mcpdm_probe(pdev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_register_dai(&pdev->dev, &omap_mcpdm_dai);\r\nif (ret < 0)\r\nomap_mcpdm_remove(pdev);\r\nreturn ret;\r\n}\r\nstatic int __devexit asoc_mcpdm_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nomap_mcpdm_remove(pdev);\r\nreturn 0;\r\n}\r\nstatic int __init snd_omap_mcpdm_init(void)\r\n{\r\nreturn platform_driver_register(&asoc_mcpdm_driver);\r\n}\r\nstatic void __exit snd_omap_mcpdm_exit(void)\r\n{\r\nplatform_driver_unregister(&asoc_mcpdm_driver);\r\n}
