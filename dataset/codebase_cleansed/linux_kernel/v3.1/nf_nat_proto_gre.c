static void\r\ngre_unique_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_nat_range *range,\r\nenum nf_nat_manip_type maniptype,\r\nconst struct nf_conn *ct)\r\n{\r\nstatic u_int16_t key;\r\n__be16 *keyptr;\r\nunsigned int min, i, range_size;\r\nif (!ct->master)\r\nreturn;\r\nif (maniptype == IP_NAT_MANIP_SRC)\r\nkeyptr = &tuple->src.u.gre.key;\r\nelse\r\nkeyptr = &tuple->dst.u.gre.key;\r\nif (!(range->flags & IP_NAT_RANGE_PROTO_SPECIFIED)) {\r\npr_debug("%p: NATing GRE PPTP\n", ct);\r\nmin = 1;\r\nrange_size = 0xffff;\r\n} else {\r\nmin = ntohs(range->min.gre.key);\r\nrange_size = ntohs(range->max.gre.key) - min + 1;\r\n}\r\npr_debug("min = %u, range_size = %u\n", min, range_size);\r\nfor (i = 0; ; ++key) {\r\n*keyptr = htons(min + key % range_size);\r\nif (++i == range_size || !nf_nat_used_tuple(tuple, ct))\r\nreturn;\r\n}\r\npr_debug("%p: no NAT mapping\n", ct);\r\nreturn;\r\n}\r\nstatic bool\r\ngre_manip_pkt(struct sk_buff *skb, unsigned int iphdroff,\r\nconst struct nf_conntrack_tuple *tuple,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nconst struct gre_hdr *greh;\r\nstruct gre_hdr_pptp *pgreh;\r\nconst struct iphdr *iph = (struct iphdr *)(skb->data + iphdroff);\r\nunsigned int hdroff = iphdroff + iph->ihl * 4;\r\nif (!skb_make_writable(skb, hdroff + sizeof(*pgreh) - 8))\r\nreturn false;\r\ngreh = (void *)skb->data + hdroff;\r\npgreh = (struct gre_hdr_pptp *)greh;\r\nif (maniptype != IP_NAT_MANIP_DST)\r\nreturn true;\r\nswitch (greh->version) {\r\ncase GRE_VERSION_1701:\r\nbreak;\r\ncase GRE_VERSION_PPTP:\r\npr_debug("call_id -> 0x%04x\n", ntohs(tuple->dst.u.gre.key));\r\npgreh->call_id = tuple->dst.u.gre.key;\r\nbreak;\r\ndefault:\r\npr_debug("can't nat unknown GRE version\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int __init nf_nat_proto_gre_init(void)\r\n{\r\nreturn nf_nat_protocol_register(&gre);\r\n}\r\nstatic void __exit nf_nat_proto_gre_fini(void)\r\n{\r\nnf_nat_protocol_unregister(&gre);\r\n}\r\nvoid nf_nat_need_gre(void)\r\n{\r\nreturn;\r\n}
