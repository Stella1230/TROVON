static void inftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\r\n{\r\nstruct INFTLrecord *inftl;\r\nunsigned long temp;\r\nif (mtd->type != MTD_NANDFLASH || mtd->size > UINT_MAX)\r\nreturn;\r\nif (memcmp(mtd->name, "DiskOnChip", 10))\r\nreturn;\r\nif (!mtd->block_isbad) {\r\nprintk(KERN_ERR\r\n"INFTL no longer supports the old DiskOnChip drivers loaded via docprobe.\n"\r\n"Please use the new diskonchip driver under the NAND subsystem.\n");\r\nreturn;\r\n}\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: add_mtd for %s\n", mtd->name);\r\ninftl = kzalloc(sizeof(*inftl), GFP_KERNEL);\r\nif (!inftl) {\r\nprintk(KERN_WARNING "INFTL: Out of memory for data structures\n");\r\nreturn;\r\n}\r\ninftl->mbd.mtd = mtd;\r\ninftl->mbd.devnum = -1;\r\ninftl->mbd.tr = tr;\r\nif (INFTL_mount(inftl) < 0) {\r\nprintk(KERN_WARNING "INFTL: could not mount device\n");\r\nkfree(inftl);\r\nreturn;\r\n}\r\ninftl->cylinders = 1024;\r\ninftl->heads = 16;\r\ntemp = inftl->cylinders * inftl->heads;\r\ninftl->sectors = inftl->mbd.size / temp;\r\nif (inftl->mbd.size % temp) {\r\ninftl->sectors++;\r\ntemp = inftl->cylinders * inftl->sectors;\r\ninftl->heads = inftl->mbd.size / temp;\r\nif (inftl->mbd.size % temp) {\r\ninftl->heads++;\r\ntemp = inftl->heads * inftl->sectors;\r\ninftl->cylinders = inftl->mbd.size / temp;\r\n}\r\n}\r\nif (inftl->mbd.size != inftl->heads * inftl->cylinders * inftl->sectors) {\r\nprintk(KERN_WARNING "INFTL: cannot calculate a geometry to "\r\n"match size of 0x%lx.\n", inftl->mbd.size);\r\nprintk(KERN_WARNING "INFTL: using C:%d H:%d S:%d "\r\n"(== 0x%lx sects)\n",\r\ninftl->cylinders, inftl->heads , inftl->sectors,\r\n(long)inftl->cylinders * (long)inftl->heads *\r\n(long)inftl->sectors );\r\n}\r\nif (add_mtd_blktrans_dev(&inftl->mbd)) {\r\nkfree(inftl->PUtable);\r\nkfree(inftl->VUtable);\r\nkfree(inftl);\r\nreturn;\r\n}\r\n#ifdef PSYCHO_DEBUG\r\nprintk(KERN_INFO "INFTL: Found new inftl%c\n", inftl->mbd.devnum + 'a');\r\n#endif\r\nreturn;\r\n}\r\nstatic void inftl_remove_dev(struct mtd_blktrans_dev *dev)\r\n{\r\nstruct INFTLrecord *inftl = (void *)dev;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: remove_dev (i=%d)\n", dev->devnum);\r\ndel_mtd_blktrans_dev(dev);\r\nkfree(inftl->PUtable);\r\nkfree(inftl->VUtable);\r\n}\r\nint inftl_read_oob(struct mtd_info *mtd, loff_t offs, size_t len,\r\nsize_t *retlen, uint8_t *buf)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint res;\r\nops.mode = MTD_OOB_PLACE;\r\nops.ooboffs = offs & (mtd->writesize - 1);\r\nops.ooblen = len;\r\nops.oobbuf = buf;\r\nops.datbuf = NULL;\r\nres = mtd->read_oob(mtd, offs & ~(mtd->writesize - 1), &ops);\r\n*retlen = ops.oobretlen;\r\nreturn res;\r\n}\r\nint inftl_write_oob(struct mtd_info *mtd, loff_t offs, size_t len,\r\nsize_t *retlen, uint8_t *buf)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint res;\r\nops.mode = MTD_OOB_PLACE;\r\nops.ooboffs = offs & (mtd->writesize - 1);\r\nops.ooblen = len;\r\nops.oobbuf = buf;\r\nops.datbuf = NULL;\r\nres = mtd->write_oob(mtd, offs & ~(mtd->writesize - 1), &ops);\r\n*retlen = ops.oobretlen;\r\nreturn res;\r\n}\r\nstatic int inftl_write(struct mtd_info *mtd, loff_t offs, size_t len,\r\nsize_t *retlen, uint8_t *buf, uint8_t *oob)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint res;\r\nops.mode = MTD_OOB_PLACE;\r\nops.ooboffs = offs;\r\nops.ooblen = mtd->oobsize;\r\nops.oobbuf = oob;\r\nops.datbuf = buf;\r\nops.len = len;\r\nres = mtd->write_oob(mtd, offs & ~(mtd->writesize - 1), &ops);\r\n*retlen = ops.retlen;\r\nreturn res;\r\n}\r\nstatic u16 INFTL_findfreeblock(struct INFTLrecord *inftl, int desperate)\r\n{\r\nu16 pot = inftl->LastFreeEUN;\r\nint silly = inftl->nb_blocks;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_findfreeblock(inftl=%p,"\r\n"desperate=%d)\n", inftl, desperate);\r\nif (!desperate && inftl->numfreeEUNs < 2) {\r\nDEBUG(MTD_DEBUG_LEVEL1, "INFTL: there are too few free "\r\n"EUNs (%d)\n", inftl->numfreeEUNs);\r\nreturn BLOCK_NIL;\r\n}\r\ndo {\r\nif (inftl->PUtable[pot] == BLOCK_FREE) {\r\ninftl->LastFreeEUN = pot;\r\nreturn pot;\r\n}\r\nif (++pot > inftl->lastEUN)\r\npot = 0;\r\nif (!silly--) {\r\nprintk(KERN_WARNING "INFTL: no free blocks found! "\r\n"EUN range = %d - %d\n", 0, inftl->LastFreeEUN);\r\nreturn BLOCK_NIL;\r\n}\r\n} while (pot != inftl->LastFreeEUN);\r\nreturn BLOCK_NIL;\r\n}\r\nstatic u16 INFTL_foldchain(struct INFTLrecord *inftl, unsigned thisVUC, unsigned pendingblock)\r\n{\r\nu16 BlockMap[MAX_SECTORS_PER_UNIT];\r\nunsigned char BlockDeleted[MAX_SECTORS_PER_UNIT];\r\nunsigned int thisEUN, prevEUN, status;\r\nstruct mtd_info *mtd = inftl->mbd.mtd;\r\nint block, silly;\r\nunsigned int targetEUN;\r\nstruct inftl_oob oob;\r\nsize_t retlen;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_foldchain(inftl=%p,thisVUC=%d,"\r\n"pending=%d)\n", inftl, thisVUC, pendingblock);\r\nmemset(BlockMap, 0xff, sizeof(BlockMap));\r\nmemset(BlockDeleted, 0, sizeof(BlockDeleted));\r\nthisEUN = targetEUN = inftl->VUtable[thisVUC];\r\nif (thisEUN == BLOCK_NIL) {\r\nprintk(KERN_WARNING "INFTL: trying to fold non-existent "\r\n"Virtual Unit Chain %d!\n", thisVUC);\r\nreturn BLOCK_NIL;\r\n}\r\nsilly = MAX_LOOPS;\r\nwhile (thisEUN < inftl->nb_blocks) {\r\nfor (block = 0; block < inftl->EraseSize/SECTORSIZE; block ++) {\r\nif ((BlockMap[block] != BLOCK_NIL) ||\r\nBlockDeleted[block])\r\ncontinue;\r\nif (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize)\r\n+ (block * SECTORSIZE), 16, &retlen,\r\n(char *)&oob) < 0)\r\nstatus = SECTOR_IGNORE;\r\nelse\r\nstatus = oob.b.Status | oob.b.Status1;\r\nswitch(status) {\r\ncase SECTOR_FREE:\r\ncase SECTOR_IGNORE:\r\nbreak;\r\ncase SECTOR_USED:\r\nBlockMap[block] = thisEUN;\r\ncontinue;\r\ncase SECTOR_DELETED:\r\nBlockDeleted[block] = 1;\r\ncontinue;\r\ndefault:\r\nprintk(KERN_WARNING "INFTL: unknown status "\r\n"for block %d in EUN %d: %x\n",\r\nblock, thisEUN, status);\r\nbreak;\r\n}\r\n}\r\nif (!silly--) {\r\nprintk(KERN_WARNING "INFTL: infinite loop in Virtual "\r\n"Unit Chain 0x%x\n", thisVUC);\r\nreturn BLOCK_NIL;\r\n}\r\nthisEUN = inftl->PUtable[thisEUN];\r\n}\r\nDEBUG(MTD_DEBUG_LEVEL1, "INFTL: folding chain %d into unit %d\n",\r\nthisVUC, targetEUN);\r\nfor (block = 0; block < inftl->EraseSize/SECTORSIZE ; block++) {\r\nunsigned char movebuf[SECTORSIZE];\r\nint ret;\r\nif (BlockMap[block] == targetEUN || (pendingblock ==\r\n(thisVUC * (inftl->EraseSize / SECTORSIZE) + block))) {\r\ncontinue;\r\n}\r\nif (BlockMap[block] == BLOCK_NIL)\r\ncontinue;\r\nret = mtd->read(mtd, (inftl->EraseSize * BlockMap[block]) +\r\n(block * SECTORSIZE), SECTORSIZE, &retlen,\r\nmovebuf);\r\nif (ret < 0 && ret != -EUCLEAN) {\r\nret = mtd->read(mtd,\r\n(inftl->EraseSize * BlockMap[block]) +\r\n(block * SECTORSIZE), SECTORSIZE,\r\n&retlen, movebuf);\r\nif (ret != -EIO)\r\nDEBUG(MTD_DEBUG_LEVEL1, "INFTL: error went "\r\n"away on retry?\n");\r\n}\r\nmemset(&oob, 0xff, sizeof(struct inftl_oob));\r\noob.b.Status = oob.b.Status1 = SECTOR_USED;\r\ninftl_write(inftl->mbd.mtd, (inftl->EraseSize * targetEUN) +\r\n(block * SECTORSIZE), SECTORSIZE, &retlen,\r\nmovebuf, (char *)&oob);\r\n}\r\nDEBUG(MTD_DEBUG_LEVEL1, "INFTL: want to erase virtual chain %d\n",\r\nthisVUC);\r\nfor (;;) {\r\nthisEUN = inftl->VUtable[thisVUC];\r\nprevEUN = BLOCK_NIL;\r\nwhile (inftl->PUtable[thisEUN] != BLOCK_NIL) {\r\nprevEUN = thisEUN;\r\nthisEUN = inftl->PUtable[thisEUN];\r\n}\r\nif (thisEUN == targetEUN)\r\nbreak;\r\ninftl->PUtable[prevEUN] = BLOCK_NIL;\r\nif (INFTL_formatblock(inftl, thisEUN) < 0) {\r\ninftl->PUtable[thisEUN] = BLOCK_RESERVED;\r\n} else {\r\ninftl->PUtable[thisEUN] = BLOCK_FREE;\r\ninftl->numfreeEUNs++;\r\n}\r\n}\r\nreturn targetEUN;\r\n}\r\nstatic u16 INFTL_makefreeblock(struct INFTLrecord *inftl, unsigned pendingblock)\r\n{\r\nu16 LongestChain = 0;\r\nu16 ChainLength = 0, thislen;\r\nu16 chain, EUN;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_makefreeblock(inftl=%p,"\r\n"pending=%d)\n", inftl, pendingblock);\r\nfor (chain = 0; chain < inftl->nb_blocks; chain++) {\r\nEUN = inftl->VUtable[chain];\r\nthislen = 0;\r\nwhile (EUN <= inftl->lastEUN) {\r\nthislen++;\r\nEUN = inftl->PUtable[EUN];\r\nif (thislen > 0xff00) {\r\nprintk(KERN_WARNING "INFTL: endless loop in "\r\n"Virtual Chain %d: Unit %x\n",\r\nchain, EUN);\r\nthislen = 0;\r\nbreak;\r\n}\r\n}\r\nif (thislen > ChainLength) {\r\nChainLength = thislen;\r\nLongestChain = chain;\r\n}\r\n}\r\nif (ChainLength < 2) {\r\nprintk(KERN_WARNING "INFTL: no Virtual Unit Chains available "\r\n"for folding. Failing request\n");\r\nreturn BLOCK_NIL;\r\n}\r\nreturn INFTL_foldchain(inftl, LongestChain, pendingblock);\r\n}\r\nstatic int nrbits(unsigned int val, int bitcount)\r\n{\r\nint i, total = 0;\r\nfor (i = 0; (i < bitcount); i++)\r\ntotal += (((0x1 << i) & val) ? 1 : 0);\r\nreturn total;\r\n}\r\nstatic inline u16 INFTL_findwriteunit(struct INFTLrecord *inftl, unsigned block)\r\n{\r\nunsigned int thisVUC = block / (inftl->EraseSize / SECTORSIZE);\r\nunsigned int thisEUN, writeEUN, prev_block, status;\r\nunsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize -1);\r\nstruct mtd_info *mtd = inftl->mbd.mtd;\r\nstruct inftl_oob oob;\r\nstruct inftl_bci bci;\r\nunsigned char anac, nacs, parity;\r\nsize_t retlen;\r\nint silly, silly2 = 3;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_findwriteunit(inftl=%p,"\r\n"block=%d)\n", inftl, block);\r\ndo {\r\nwriteEUN = BLOCK_NIL;\r\nthisEUN = inftl->VUtable[thisVUC];\r\nsilly = MAX_LOOPS;\r\nwhile (thisEUN <= inftl->lastEUN) {\r\ninftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +\r\nblockofs, 8, &retlen, (char *)&bci);\r\nstatus = bci.Status | bci.Status1;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: status of block %d in "\r\n"EUN %d is %x\n", block , writeEUN, status);\r\nswitch(status) {\r\ncase SECTOR_FREE:\r\nwriteEUN = thisEUN;\r\nbreak;\r\ncase SECTOR_DELETED:\r\ncase SECTOR_USED:\r\ngoto hitused;\r\ncase SECTOR_IGNORE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!silly--) {\r\nprintk(KERN_WARNING "INFTL: infinite loop in "\r\n"Virtual Unit Chain 0x%x\n", thisVUC);\r\nreturn BLOCK_NIL;\r\n}\r\nthisEUN = inftl->PUtable[thisEUN];\r\n}\r\nhitused:\r\nif (writeEUN != BLOCK_NIL)\r\nreturn writeEUN;\r\nwriteEUN = INFTL_findfreeblock(inftl, 0);\r\nif (writeEUN == BLOCK_NIL) {\r\nthisEUN = INFTL_makefreeblock(inftl, block);\r\nDEBUG(MTD_DEBUG_LEVEL1, "INFTL: using desperate==1 "\r\n"to find free EUN to accommodate write to "\r\n"VUC %d\n", thisVUC);\r\nwriteEUN = INFTL_findfreeblock(inftl, 1);\r\nif (writeEUN == BLOCK_NIL) {\r\nprintk(KERN_WARNING "INFTL: cannot make free "\r\n"space.\n");\r\n#ifdef DEBUG\r\nINFTL_dumptables(inftl);\r\nINFTL_dumpVUchains(inftl);\r\n#endif\r\nreturn BLOCK_NIL;\r\n}\r\n}\r\nanac = 0;\r\nnacs = 0;\r\nthisEUN = inftl->VUtable[thisVUC];\r\nif (thisEUN != BLOCK_NIL) {\r\ninftl_read_oob(mtd, thisEUN * inftl->EraseSize\r\n+ 8, 8, &retlen, (char *)&oob.u);\r\nanac = oob.u.a.ANAC + 1;\r\nnacs = oob.u.a.NACs + 1;\r\n}\r\nprev_block = inftl->VUtable[thisVUC];\r\nif (prev_block < inftl->nb_blocks)\r\nprev_block -= inftl->firstEUN;\r\nparity = (nrbits(thisVUC, 16) & 0x1) ? 0x1 : 0;\r\nparity |= (nrbits(prev_block, 16) & 0x1) ? 0x2 : 0;\r\nparity |= (nrbits(anac, 8) & 0x1) ? 0x4 : 0;\r\nparity |= (nrbits(nacs, 8) & 0x1) ? 0x8 : 0;\r\noob.u.a.virtualUnitNo = cpu_to_le16(thisVUC);\r\noob.u.a.prevUnitNo = cpu_to_le16(prev_block);\r\noob.u.a.ANAC = anac;\r\noob.u.a.NACs = nacs;\r\noob.u.a.parityPerField = parity;\r\noob.u.a.discarded = 0xaa;\r\ninftl_write_oob(mtd, writeEUN * inftl->EraseSize + 8, 8,\r\n&retlen, (char *)&oob.u);\r\noob.u.b.virtualUnitNo = cpu_to_le16(thisVUC);\r\noob.u.b.prevUnitNo = cpu_to_le16(prev_block);\r\noob.u.b.ANAC = anac;\r\noob.u.b.NACs = nacs;\r\noob.u.b.parityPerField = parity;\r\noob.u.b.discarded = 0xaa;\r\ninftl_write_oob(mtd, writeEUN * inftl->EraseSize +\r\nSECTORSIZE * 4 + 8, 8, &retlen, (char *)&oob.u);\r\ninftl->PUtable[writeEUN] = inftl->VUtable[thisVUC];\r\ninftl->VUtable[thisVUC] = writeEUN;\r\ninftl->numfreeEUNs--;\r\nreturn writeEUN;\r\n} while (silly2--);\r\nprintk(KERN_WARNING "INFTL: error folding to make room for Virtual "\r\n"Unit Chain 0x%x\n", thisVUC);\r\nreturn BLOCK_NIL;\r\n}\r\nstatic void INFTL_trydeletechain(struct INFTLrecord *inftl, unsigned thisVUC)\r\n{\r\nstruct mtd_info *mtd = inftl->mbd.mtd;\r\nunsigned char BlockUsed[MAX_SECTORS_PER_UNIT];\r\nunsigned char BlockDeleted[MAX_SECTORS_PER_UNIT];\r\nunsigned int thisEUN, status;\r\nint block, silly;\r\nstruct inftl_bci bci;\r\nsize_t retlen;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_trydeletechain(inftl=%p,"\r\n"thisVUC=%d)\n", inftl, thisVUC);\r\nmemset(BlockUsed, 0, sizeof(BlockUsed));\r\nmemset(BlockDeleted, 0, sizeof(BlockDeleted));\r\nthisEUN = inftl->VUtable[thisVUC];\r\nif (thisEUN == BLOCK_NIL) {\r\nprintk(KERN_WARNING "INFTL: trying to delete non-existent "\r\n"Virtual Unit Chain %d!\n", thisVUC);\r\nreturn;\r\n}\r\nsilly = MAX_LOOPS;\r\nwhile (thisEUN < inftl->nb_blocks) {\r\nfor (block = 0; block < inftl->EraseSize/SECTORSIZE; block++) {\r\nif (BlockUsed[block] || BlockDeleted[block])\r\ncontinue;\r\nif (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize)\r\n+ (block * SECTORSIZE), 8 , &retlen,\r\n(char *)&bci) < 0)\r\nstatus = SECTOR_IGNORE;\r\nelse\r\nstatus = bci.Status | bci.Status1;\r\nswitch(status) {\r\ncase SECTOR_FREE:\r\ncase SECTOR_IGNORE:\r\nbreak;\r\ncase SECTOR_USED:\r\nBlockUsed[block] = 1;\r\ncontinue;\r\ncase SECTOR_DELETED:\r\nBlockDeleted[block] = 1;\r\ncontinue;\r\ndefault:\r\nprintk(KERN_WARNING "INFTL: unknown status "\r\n"for block %d in EUN %d: 0x%x\n",\r\nblock, thisEUN, status);\r\n}\r\n}\r\nif (!silly--) {\r\nprintk(KERN_WARNING "INFTL: infinite loop in Virtual "\r\n"Unit Chain 0x%x\n", thisVUC);\r\nreturn;\r\n}\r\nthisEUN = inftl->PUtable[thisEUN];\r\n}\r\nfor (block = 0; block < inftl->EraseSize/SECTORSIZE; block++)\r\nif (BlockUsed[block])\r\nreturn;\r\nDEBUG(MTD_DEBUG_LEVEL1, "INFTL: deleting empty VUC %d\n", thisVUC);\r\nfor (;;) {\r\nu16 *prevEUN = &inftl->VUtable[thisVUC];\r\nthisEUN = *prevEUN;\r\nif (thisEUN == BLOCK_NIL) {\r\nDEBUG(MTD_DEBUG_LEVEL2, "INFTL: Empty VUC %d for deletion was already absent\n", thisEUN);\r\nreturn;\r\n}\r\nwhile (inftl->PUtable[thisEUN] != BLOCK_NIL) {\r\nBUG_ON(thisEUN >= inftl->nb_blocks);\r\nprevEUN = &inftl->PUtable[thisEUN];\r\nthisEUN = *prevEUN;\r\n}\r\nDEBUG(MTD_DEBUG_LEVEL3, "Deleting EUN %d from VUC %d\n",\r\nthisEUN, thisVUC);\r\nif (INFTL_formatblock(inftl, thisEUN) < 0) {\r\ninftl->PUtable[thisEUN] = BLOCK_RESERVED;\r\n} else {\r\ninftl->PUtable[thisEUN] = BLOCK_FREE;\r\ninftl->numfreeEUNs++;\r\n}\r\n*prevEUN = BLOCK_NIL;\r\ncond_resched();\r\n}\r\ninftl->VUtable[thisVUC] = BLOCK_NIL;\r\n}\r\nstatic int INFTL_deleteblock(struct INFTLrecord *inftl, unsigned block)\r\n{\r\nunsigned int thisEUN = inftl->VUtable[block / (inftl->EraseSize / SECTORSIZE)];\r\nunsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);\r\nstruct mtd_info *mtd = inftl->mbd.mtd;\r\nunsigned int status;\r\nint silly = MAX_LOOPS;\r\nsize_t retlen;\r\nstruct inftl_bci bci;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_deleteblock(inftl=%p,"\r\n"block=%d)\n", inftl, block);\r\nwhile (thisEUN < inftl->nb_blocks) {\r\nif (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +\r\nblockofs, 8, &retlen, (char *)&bci) < 0)\r\nstatus = SECTOR_IGNORE;\r\nelse\r\nstatus = bci.Status | bci.Status1;\r\nswitch (status) {\r\ncase SECTOR_FREE:\r\ncase SECTOR_IGNORE:\r\nbreak;\r\ncase SECTOR_DELETED:\r\nthisEUN = BLOCK_NIL;\r\ngoto foundit;\r\ncase SECTOR_USED:\r\ngoto foundit;\r\ndefault:\r\nprintk(KERN_WARNING "INFTL: unknown status for "\r\n"block %d in EUN %d: 0x%x\n",\r\nblock, thisEUN, status);\r\nbreak;\r\n}\r\nif (!silly--) {\r\nprintk(KERN_WARNING "INFTL: infinite loop in Virtual "\r\n"Unit Chain 0x%x\n",\r\nblock / (inftl->EraseSize / SECTORSIZE));\r\nreturn 1;\r\n}\r\nthisEUN = inftl->PUtable[thisEUN];\r\n}\r\nfoundit:\r\nif (thisEUN != BLOCK_NIL) {\r\nloff_t ptr = (thisEUN * inftl->EraseSize) + blockofs;\r\nif (inftl_read_oob(mtd, ptr, 8, &retlen, (char *)&bci) < 0)\r\nreturn -EIO;\r\nbci.Status = bci.Status1 = SECTOR_DELETED;\r\nif (inftl_write_oob(mtd, ptr, 8, &retlen, (char *)&bci) < 0)\r\nreturn -EIO;\r\nINFTL_trydeletechain(inftl, block / (inftl->EraseSize / SECTORSIZE));\r\n}\r\nreturn 0;\r\n}\r\nstatic int inftl_writeblock(struct mtd_blktrans_dev *mbd, unsigned long block,\r\nchar *buffer)\r\n{\r\nstruct INFTLrecord *inftl = (void *)mbd;\r\nunsigned int writeEUN;\r\nunsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);\r\nsize_t retlen;\r\nstruct inftl_oob oob;\r\nchar *p, *pend;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: inftl_writeblock(inftl=%p,block=%ld,"\r\n"buffer=%p)\n", inftl, block, buffer);\r\npend = buffer + SECTORSIZE;\r\nfor (p = buffer; p < pend && !*p; p++)\r\n;\r\nif (p < pend) {\r\nwriteEUN = INFTL_findwriteunit(inftl, block);\r\nif (writeEUN == BLOCK_NIL) {\r\nprintk(KERN_WARNING "inftl_writeblock(): cannot find "\r\n"block to write to\n");\r\nreturn 1;\r\n}\r\nmemset(&oob, 0xff, sizeof(struct inftl_oob));\r\noob.b.Status = oob.b.Status1 = SECTOR_USED;\r\ninftl_write(inftl->mbd.mtd, (writeEUN * inftl->EraseSize) +\r\nblockofs, SECTORSIZE, &retlen, (char *)buffer,\r\n(char *)&oob);\r\n} else {\r\nINFTL_deleteblock(inftl, block);\r\n}\r\nreturn 0;\r\n}\r\nstatic int inftl_readblock(struct mtd_blktrans_dev *mbd, unsigned long block,\r\nchar *buffer)\r\n{\r\nstruct INFTLrecord *inftl = (void *)mbd;\r\nunsigned int thisEUN = inftl->VUtable[block / (inftl->EraseSize / SECTORSIZE)];\r\nunsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);\r\nstruct mtd_info *mtd = inftl->mbd.mtd;\r\nunsigned int status;\r\nint silly = MAX_LOOPS;\r\nstruct inftl_bci bci;\r\nsize_t retlen;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: inftl_readblock(inftl=%p,block=%ld,"\r\n"buffer=%p)\n", inftl, block, buffer);\r\nwhile (thisEUN < inftl->nb_blocks) {\r\nif (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +\r\nblockofs, 8, &retlen, (char *)&bci) < 0)\r\nstatus = SECTOR_IGNORE;\r\nelse\r\nstatus = bci.Status | bci.Status1;\r\nswitch (status) {\r\ncase SECTOR_DELETED:\r\nthisEUN = BLOCK_NIL;\r\ngoto foundit;\r\ncase SECTOR_USED:\r\ngoto foundit;\r\ncase SECTOR_FREE:\r\ncase SECTOR_IGNORE:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "INFTL: unknown status for "\r\n"block %ld in EUN %d: 0x%04x\n",\r\nblock, thisEUN, status);\r\nbreak;\r\n}\r\nif (!silly--) {\r\nprintk(KERN_WARNING "INFTL: infinite loop in "\r\n"Virtual Unit Chain 0x%lx\n",\r\nblock / (inftl->EraseSize / SECTORSIZE));\r\nreturn 1;\r\n}\r\nthisEUN = inftl->PUtable[thisEUN];\r\n}\r\nfoundit:\r\nif (thisEUN == BLOCK_NIL) {\r\nmemset(buffer, 0, SECTORSIZE);\r\n} else {\r\nsize_t retlen;\r\nloff_t ptr = (thisEUN * inftl->EraseSize) + blockofs;\r\nint ret = mtd->read(mtd, ptr, SECTORSIZE, &retlen, buffer);\r\nif (ret < 0 && ret != -EUCLEAN)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int inftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\r\n{\r\nstruct INFTLrecord *inftl = (void *)dev;\r\ngeo->heads = inftl->heads;\r\ngeo->sectors = inftl->sectors;\r\ngeo->cylinders = inftl->cylinders;\r\nreturn 0;\r\n}\r\nstatic int __init init_inftl(void)\r\n{\r\nreturn register_mtd_blktrans(&inftl_tr);\r\n}\r\nstatic void __exit cleanup_inftl(void)\r\n{\r\nderegister_mtd_blktrans(&inftl_tr);\r\n}
