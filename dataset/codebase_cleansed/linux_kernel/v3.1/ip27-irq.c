static inline int alloc_level(int cpu, int irq)\r\n{\r\nstruct hub_data *hub = hub_data(cpu_to_node(cpu));\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nint level;\r\nlevel = find_first_zero_bit(hub->irq_alloc_mask, LEVELS_PER_SLICE);\r\nif (level >= LEVELS_PER_SLICE)\r\npanic("Cpu %d flooded with devices\n", cpu);\r\n__set_bit(level, hub->irq_alloc_mask);\r\nsi->level_to_irq[level] = irq;\r\nreturn level;\r\n}\r\nstatic inline int find_level(cpuid_t *cpunum, int irq)\r\n{\r\nint cpu, i;\r\nfor_each_online_cpu(cpu) {\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nfor (i = BASE_PCI_IRQ; i < LEVELS_PER_SLICE; i++)\r\nif (si->level_to_irq[i] == irq) {\r\n*cpunum = cpu;\r\nreturn i;\r\n}\r\n}\r\npanic("Could not identify cpu/level for irq %d\n", irq);\r\n}\r\nstatic int ms1bit(unsigned long x)\r\n{\r\nint b = 0, s;\r\ns = 16; if (x >> 16 == 0) s = 0; b += s; x >>= s;\r\ns = 8; if (x >> 8 == 0) s = 0; b += s; x >>= s;\r\ns = 4; if (x >> 4 == 0) s = 0; b += s; x >>= s;\r\ns = 2; if (x >> 2 == 0) s = 0; b += s; x >>= s;\r\ns = 1; if (x >> 1 == 0) s = 0; b += s;\r\nreturn b;\r\n}\r\nstatic void ip27_do_irq_mask0(void)\r\n{\r\nint irq, swlevel;\r\nhubreg_t pend0, mask0;\r\ncpuid_t cpu = smp_processor_id();\r\nint pi_int_mask0 =\r\n(cputoslice(cpu) == 0) ? PI_INT_MASK0_A : PI_INT_MASK0_B;\r\npend0 = LOCAL_HUB_L(PI_INT_PEND0);\r\nmask0 = LOCAL_HUB_L(pi_int_mask0);\r\npend0 &= mask0;\r\nif (!pend0)\r\nreturn;\r\nswlevel = ms1bit(pend0);\r\n#ifdef CONFIG_SMP\r\nif (pend0 & (1UL << CPU_RESCHED_A_IRQ)) {\r\nLOCAL_HUB_CLR_INTR(CPU_RESCHED_A_IRQ);\r\nscheduler_ipi();\r\n} else if (pend0 & (1UL << CPU_RESCHED_B_IRQ)) {\r\nLOCAL_HUB_CLR_INTR(CPU_RESCHED_B_IRQ);\r\nscheduler_ipi();\r\n} else if (pend0 & (1UL << CPU_CALL_A_IRQ)) {\r\nLOCAL_HUB_CLR_INTR(CPU_CALL_A_IRQ);\r\nsmp_call_function_interrupt();\r\n} else if (pend0 & (1UL << CPU_CALL_B_IRQ)) {\r\nLOCAL_HUB_CLR_INTR(CPU_CALL_B_IRQ);\r\nsmp_call_function_interrupt();\r\n} else\r\n#endif\r\n{\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nirq = si->level_to_irq[swlevel];\r\ndo_IRQ(irq);\r\n}\r\nLOCAL_HUB_L(PI_INT_PEND0);\r\n}\r\nstatic void ip27_do_irq_mask1(void)\r\n{\r\nint irq, swlevel;\r\nhubreg_t pend1, mask1;\r\ncpuid_t cpu = smp_processor_id();\r\nint pi_int_mask1 = (cputoslice(cpu) == 0) ? PI_INT_MASK1_A : PI_INT_MASK1_B;\r\nstruct slice_data *si = cpu_data[cpu].data;\r\npend1 = LOCAL_HUB_L(PI_INT_PEND1);\r\nmask1 = LOCAL_HUB_L(pi_int_mask1);\r\npend1 &= mask1;\r\nif (!pend1)\r\nreturn;\r\nswlevel = ms1bit(pend1);\r\nirq = si->level_to_irq[swlevel];\r\nLOCAL_HUB_CLR_INTR(swlevel);\r\ndo_IRQ(irq);\r\nLOCAL_HUB_L(PI_INT_PEND1);\r\n}\r\nstatic void ip27_prof_timer(void)\r\n{\r\npanic("CPU %d got a profiling interrupt", smp_processor_id());\r\n}\r\nstatic void ip27_hub_error(void)\r\n{\r\npanic("CPU %d got a hub error interrupt", smp_processor_id());\r\n}\r\nstatic int intr_connect_level(int cpu, int bit)\r\n{\r\nnasid_t nasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nset_bit(bit, si->irq_enable_mask);\r\nif (!cputoslice(cpu)) {\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_A, si->irq_enable_mask[0]);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_A, si->irq_enable_mask[1]);\r\n} else {\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_B, si->irq_enable_mask[0]);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_B, si->irq_enable_mask[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int intr_disconnect_level(int cpu, int bit)\r\n{\r\nnasid_t nasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nclear_bit(bit, si->irq_enable_mask);\r\nif (!cputoslice(cpu)) {\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_A, si->irq_enable_mask[0]);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_A, si->irq_enable_mask[1]);\r\n} else {\r\nREMOTE_HUB_S(nasid, PI_INT_MASK0_B, si->irq_enable_mask[0]);\r\nREMOTE_HUB_S(nasid, PI_INT_MASK1_B, si->irq_enable_mask[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int startup_bridge_irq(struct irq_data *d)\r\n{\r\nstruct bridge_controller *bc;\r\nbridgereg_t device;\r\nbridge_t *bridge;\r\nint pin, swlevel;\r\ncpuid_t cpu;\r\npin = SLOT_FROM_PCI_IRQ(d->irq);\r\nbc = IRQ_TO_BRIDGE(d->irq);\r\nbridge = bc->base;\r\npr_debug("bridge_startup(): irq= 0x%x pin=%d\n", d->irq, pin);\r\nswlevel = find_level(&cpu, d->irq);\r\nbridge->b_int_addr[pin].addr = (0x20000 | swlevel | (bc->nasid << 8));\r\nbridge->b_int_enable |= (1 << pin);\r\nbridge->b_int_enable |= 0x7ffffe00;\r\nbridge->b_int_mode |= (1UL << pin);\r\ndevice = bridge->b_int_device;\r\ndevice &= ~(7 << (pin*3));\r\ndevice |= (pin << (pin*3));\r\nbridge->b_int_device = device;\r\nbridge->b_wid_tflush;\r\nintr_connect_level(cpu, swlevel);\r\nreturn 0;\r\n}\r\nstatic void shutdown_bridge_irq(struct irq_data *d)\r\n{\r\nstruct bridge_controller *bc = IRQ_TO_BRIDGE(d->irq);\r\nbridge_t *bridge = bc->base;\r\nint pin, swlevel;\r\ncpuid_t cpu;\r\npr_debug("bridge_shutdown: irq 0x%x\n", d->irq);\r\npin = SLOT_FROM_PCI_IRQ(d->irq);\r\nswlevel = find_level(&cpu, d->irq);\r\nintr_disconnect_level(cpu, swlevel);\r\nbridge->b_int_enable &= ~(1 << pin);\r\nbridge->b_wid_tflush;\r\n}\r\nstatic inline void enable_bridge_irq(struct irq_data *d)\r\n{\r\ncpuid_t cpu;\r\nint swlevel;\r\nswlevel = find_level(&cpu, d->irq);\r\nintr_connect_level(cpu, swlevel);\r\n}\r\nstatic inline void disable_bridge_irq(struct irq_data *d)\r\n{\r\ncpuid_t cpu;\r\nint swlevel;\r\nswlevel = find_level(&cpu, d->irq);\r\nintr_disconnect_level(cpu, swlevel);\r\n}\r\nvoid __devinit register_bridge_irq(unsigned int irq)\r\n{\r\nirq_set_chip_and_handler(irq, &bridge_irq_type, handle_level_irq);\r\n}\r\nint __devinit request_bridge_irq(struct bridge_controller *bc)\r\n{\r\nint irq = allocate_irqno();\r\nint swlevel, cpu;\r\nnasid_t nasid;\r\nif (irq < 0)\r\nreturn irq;\r\ncpu = bc->irq_cpu;\r\nswlevel = alloc_level(cpu, irq);\r\nif (unlikely(swlevel < 0)) {\r\nfree_irqno(irq);\r\nreturn -EAGAIN;\r\n}\r\nnasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));\r\nREMOTE_HUB_CLR_INTR(nasid, swlevel);\r\nintr_connect_level(cpu, swlevel);\r\nregister_bridge_irq(irq);\r\nreturn irq;\r\n}\r\nasmlinkage void plat_irq_dispatch(void)\r\n{\r\nunsigned long pending = read_c0_cause() & read_c0_status();\r\nextern unsigned int rt_timer_irq;\r\nif (pending & CAUSEF_IP4)\r\ndo_IRQ(rt_timer_irq);\r\nelse if (pending & CAUSEF_IP2)\r\nip27_do_irq_mask0();\r\nelse if (pending & CAUSEF_IP3)\r\nip27_do_irq_mask1();\r\nelse if (pending & CAUSEF_IP5)\r\nip27_prof_timer();\r\nelse if (pending & CAUSEF_IP6)\r\nip27_hub_error();\r\n}\r\nvoid __init arch_init_irq(void)\r\n{\r\n}\r\nvoid install_ipi(void)\r\n{\r\nint slice = LOCAL_HUB_L(PI_CPU_NUM);\r\nint cpu = smp_processor_id();\r\nstruct slice_data *si = cpu_data[cpu].data;\r\nstruct hub_data *hub = hub_data(cpu_to_node(cpu));\r\nint resched, call;\r\nresched = CPU_RESCHED_A_IRQ + slice;\r\n__set_bit(resched, hub->irq_alloc_mask);\r\n__set_bit(resched, si->irq_enable_mask);\r\nLOCAL_HUB_CLR_INTR(resched);\r\ncall = CPU_CALL_A_IRQ + slice;\r\n__set_bit(call, hub->irq_alloc_mask);\r\n__set_bit(call, si->irq_enable_mask);\r\nLOCAL_HUB_CLR_INTR(call);\r\nif (slice == 0) {\r\nLOCAL_HUB_S(PI_INT_MASK0_A, si->irq_enable_mask[0]);\r\nLOCAL_HUB_S(PI_INT_MASK1_A, si->irq_enable_mask[1]);\r\n} else {\r\nLOCAL_HUB_S(PI_INT_MASK0_B, si->irq_enable_mask[0]);\r\nLOCAL_HUB_S(PI_INT_MASK1_B, si->irq_enable_mask[1]);\r\n}\r\n}
