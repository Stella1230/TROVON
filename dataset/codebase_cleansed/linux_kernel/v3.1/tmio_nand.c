static void tmio_nand_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nu8 mode;\r\nif (ctrl & NAND_NCE) {\r\nmode = FCR_MODE_DATA;\r\nif (ctrl & NAND_CLE)\r\nmode |= FCR_MODE_CLE;\r\nelse\r\nmode &= ~FCR_MODE_CLE;\r\nif (ctrl & NAND_ALE)\r\nmode |= FCR_MODE_ALE;\r\nelse\r\nmode &= ~FCR_MODE_ALE;\r\n} else {\r\nmode = FCR_MODE_STANDBY;\r\n}\r\ntmio_iowrite8(mode, tmio->fcr + FCR_MODE);\r\ntmio->read_good = 0;\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\ntmio_iowrite8(cmd, chip->IO_ADDR_W);\r\n}\r\nstatic int tmio_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\nreturn !(tmio_ioread8(tmio->fcr + FCR_STATUS) & FCR_STATUS_BUSY);\r\n}\r\nstatic irqreturn_t tmio_irq(int irq, void *__tmio)\r\n{\r\nstruct tmio_nand *tmio = __tmio;\r\nstruct nand_chip *nand_chip = &tmio->chip;\r\ntmio_iowrite8(0x00, tmio->fcr + FCR_IMR);\r\nif (unlikely(!waitqueue_active(&nand_chip->controller->wq)))\r\ndev_warn(&tmio->dev->dev, "spurious interrupt\n");\r\nwake_up(&nand_chip->controller->wq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\ntmio_nand_wait(struct mtd_info *mtd, struct nand_chip *nand_chip)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\nlong timeout;\r\ntmio_iowrite8(0x0f, tmio->fcr + FCR_ISR);\r\ntmio_iowrite8(0x81, tmio->fcr + FCR_IMR);\r\ntimeout = wait_event_timeout(nand_chip->controller->wq,\r\ntmio_nand_dev_ready(mtd),\r\nmsecs_to_jiffies(nand_chip->state == FL_ERASING ? 400 : 20));\r\nif (unlikely(!tmio_nand_dev_ready(mtd))) {\r\ntmio_iowrite8(0x00, tmio->fcr + FCR_IMR);\r\ndev_warn(&tmio->dev->dev, "still busy with %s after %d ms\n",\r\nnand_chip->state == FL_ERASING ? "erase" : "program",\r\nnand_chip->state == FL_ERASING ? 400 : 20);\r\n} else if (unlikely(!timeout)) {\r\ntmio_iowrite8(0x00, tmio->fcr + FCR_IMR);\r\ndev_warn(&tmio->dev->dev, "timeout waiting for interrupt\n");\r\n}\r\nnand_chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);\r\nreturn nand_chip->read_byte(mtd);\r\n}\r\nstatic u_char tmio_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\nunsigned int data;\r\nif (tmio->read_good--)\r\nreturn tmio->read;\r\ndata = tmio_ioread16(tmio->fcr + FCR_DATA);\r\ntmio->read = data >> 8;\r\nreturn data;\r\n}\r\nstatic void\r\ntmio_nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\ntmio_iowrite16_rep(tmio->fcr + FCR_DATA, buf, len >> 1);\r\n}\r\nstatic void tmio_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\ntmio_ioread16_rep(tmio->fcr + FCR_DATA, buf, len >> 1);\r\n}\r\nstatic int\r\ntmio_nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\nu16 *p = (u16 *) buf;\r\nfor (len >>= 1; len; len--)\r\nif (*(p++) != tmio_ioread16(tmio->fcr + FCR_DATA))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void tmio_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\ntmio_iowrite8(FCR_MODE_HWECC_RESET, tmio->fcr + FCR_MODE);\r\ntmio_ioread8(tmio->fcr + FCR_DATA);\r\ntmio_iowrite8(FCR_MODE_HWECC_CALC, tmio->fcr + FCR_MODE);\r\n}\r\nstatic int tmio_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct tmio_nand *tmio = mtd_to_tmio(mtd);\r\nunsigned int ecc;\r\ntmio_iowrite8(FCR_MODE_HWECC_RESULT, tmio->fcr + FCR_MODE);\r\necc = tmio_ioread16(tmio->fcr + FCR_DATA);\r\necc_code[1] = ecc;\r\necc_code[0] = ecc >> 8;\r\necc = tmio_ioread16(tmio->fcr + FCR_DATA);\r\necc_code[2] = ecc;\r\necc_code[4] = ecc >> 8;\r\necc = tmio_ioread16(tmio->fcr + FCR_DATA);\r\necc_code[3] = ecc;\r\necc_code[5] = ecc >> 8;\r\ntmio_iowrite8(FCR_MODE_DATA, tmio->fcr + FCR_MODE);\r\nreturn 0;\r\n}\r\nstatic int tmio_nand_correct_data(struct mtd_info *mtd, unsigned char *buf,\r\nunsigned char *read_ecc, unsigned char *calc_ecc)\r\n{\r\nint r0, r1;\r\nr0 = __nand_correct_data(buf, read_ecc, calc_ecc, 256);\r\nif (r0 < 0)\r\nreturn r0;\r\nr1 = __nand_correct_data(buf + 256, read_ecc + 3, calc_ecc + 3, 256);\r\nif (r1 < 0)\r\nreturn r1;\r\nreturn r0 + r1;\r\n}\r\nstatic int tmio_hw_init(struct platform_device *dev, struct tmio_nand *tmio)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nint ret;\r\nif (cell->enable) {\r\nret = cell->enable(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\ntmio_iowrite8(0x81, tmio->ccr + CCR_ICC);\r\ntmio_iowrite16(tmio->fcr_base, tmio->ccr + CCR_BASE);\r\ntmio_iowrite16(tmio->fcr_base >> 16, tmio->ccr + CCR_BASE + 2);\r\ntmio_iowrite8(0x02, tmio->ccr + CCR_COMMAND);\r\ntmio_iowrite8(0x02, tmio->ccr + CCR_NFPSC);\r\ntmio_iowrite8(0x02, tmio->ccr + CCR_NFDC);\r\ntmio_iowrite8(0x0f, tmio->fcr + FCR_ISR);\r\ntmio_iowrite8(FCR_MODE_POWER_ON, tmio->fcr + FCR_MODE);\r\ntmio_iowrite8(FCR_MODE_COMMAND, tmio->fcr + FCR_MODE);\r\ntmio_iowrite8(NAND_CMD_RESET, tmio->fcr + FCR_DATA);\r\ntmio_iowrite8(FCR_MODE_STANDBY, tmio->fcr + FCR_MODE);\r\nmdelay(5);\r\nreturn 0;\r\n}\r\nstatic void tmio_hw_stop(struct platform_device *dev, struct tmio_nand *tmio)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\ntmio_iowrite8(FCR_MODE_POWER_OFF, tmio->fcr + FCR_MODE);\r\nif (cell->disable)\r\ncell->disable(dev);\r\n}\r\nstatic int tmio_probe(struct platform_device *dev)\r\n{\r\nstruct tmio_nand_data *data = dev->dev.platform_data;\r\nstruct resource *fcr = platform_get_resource(dev,\r\nIORESOURCE_MEM, 0);\r\nstruct resource *ccr = platform_get_resource(dev,\r\nIORESOURCE_MEM, 1);\r\nint irq = platform_get_irq(dev, 0);\r\nstruct tmio_nand *tmio;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand_chip;\r\nstruct mtd_partition *parts;\r\nint nbparts = 0;\r\nint retval;\r\nif (data == NULL)\r\ndev_warn(&dev->dev, "NULL platform data!\n");\r\ntmio = kzalloc(sizeof *tmio, GFP_KERNEL);\r\nif (!tmio) {\r\nretval = -ENOMEM;\r\ngoto err_kzalloc;\r\n}\r\ntmio->dev = dev;\r\nplatform_set_drvdata(dev, tmio);\r\nmtd = &tmio->mtd;\r\nnand_chip = &tmio->chip;\r\nmtd->priv = nand_chip;\r\nmtd->name = "tmio-nand";\r\ntmio->ccr = ioremap(ccr->start, resource_size(ccr));\r\nif (!tmio->ccr) {\r\nretval = -EIO;\r\ngoto err_iomap_ccr;\r\n}\r\ntmio->fcr_base = fcr->start & 0xfffff;\r\ntmio->fcr = ioremap(fcr->start, resource_size(fcr));\r\nif (!tmio->fcr) {\r\nretval = -EIO;\r\ngoto err_iomap_fcr;\r\n}\r\nretval = tmio_hw_init(dev, tmio);\r\nif (retval)\r\ngoto err_hwinit;\r\nnand_chip->IO_ADDR_R = tmio->fcr;\r\nnand_chip->IO_ADDR_W = tmio->fcr;\r\nnand_chip->cmd_ctrl = tmio_nand_hwcontrol;\r\nnand_chip->dev_ready = tmio_nand_dev_ready;\r\nnand_chip->read_byte = tmio_nand_read_byte;\r\nnand_chip->write_buf = tmio_nand_write_buf;\r\nnand_chip->read_buf = tmio_nand_read_buf;\r\nnand_chip->verify_buf = tmio_nand_verify_buf;\r\nnand_chip->ecc.mode = NAND_ECC_HW;\r\nnand_chip->ecc.size = 512;\r\nnand_chip->ecc.bytes = 6;\r\nnand_chip->ecc.hwctl = tmio_nand_enable_hwecc;\r\nnand_chip->ecc.calculate = tmio_nand_calculate_ecc;\r\nnand_chip->ecc.correct = tmio_nand_correct_data;\r\nif (data)\r\nnand_chip->badblock_pattern = data->badblock_pattern;\r\nnand_chip->chip_delay = 15;\r\nretval = request_irq(irq, &tmio_irq,\r\nIRQF_DISABLED, dev_name(&dev->dev), tmio);\r\nif (retval) {\r\ndev_err(&dev->dev, "request_irq error %d\n", retval);\r\ngoto err_irq;\r\n}\r\ntmio->irq = irq;\r\nnand_chip->waitfunc = tmio_nand_wait;\r\nif (nand_scan(mtd, 1)) {\r\nretval = -ENODEV;\r\ngoto err_scan;\r\n}\r\n#ifdef CONFIG_MTD_CMDLINE_PARTS\r\nnbparts = parse_mtd_partitions(mtd, part_probes, &parts, 0);\r\n#endif\r\nif (nbparts <= 0 && data) {\r\nparts = data->partition;\r\nnbparts = data->num_partitions;\r\n}\r\nretval = mtd_device_register(mtd, parts, nbparts);\r\nif (!retval)\r\nreturn retval;\r\nnand_release(mtd);\r\nerr_scan:\r\nif (tmio->irq)\r\nfree_irq(tmio->irq, tmio);\r\nerr_irq:\r\ntmio_hw_stop(dev, tmio);\r\nerr_hwinit:\r\niounmap(tmio->fcr);\r\nerr_iomap_fcr:\r\niounmap(tmio->ccr);\r\nerr_iomap_ccr:\r\nkfree(tmio);\r\nerr_kzalloc:\r\nreturn retval;\r\n}\r\nstatic int tmio_remove(struct platform_device *dev)\r\n{\r\nstruct tmio_nand *tmio = platform_get_drvdata(dev);\r\nnand_release(&tmio->mtd);\r\nif (tmio->irq)\r\nfree_irq(tmio->irq, tmio);\r\ntmio_hw_stop(dev, tmio);\r\niounmap(tmio->fcr);\r\niounmap(tmio->ccr);\r\nkfree(tmio);\r\nreturn 0;\r\n}\r\nstatic int tmio_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nif (cell->suspend)\r\ncell->suspend(dev);\r\ntmio_hw_stop(dev, platform_get_drvdata(dev));\r\nreturn 0;\r\n}\r\nstatic int tmio_resume(struct platform_device *dev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\ntmio_hw_init(dev, platform_get_drvdata(dev));\r\nif (cell->resume)\r\ncell->resume(dev);\r\nreturn 0;\r\n}\r\nstatic int __init tmio_init(void)\r\n{\r\nreturn platform_driver_register(&tmio_driver);\r\n}\r\nstatic void __exit tmio_exit(void)\r\n{\r\nplatform_driver_unregister(&tmio_driver);\r\n}
