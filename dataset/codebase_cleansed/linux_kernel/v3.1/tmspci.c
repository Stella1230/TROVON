static unsigned short tms_pci_sifreadb(struct net_device *dev, unsigned short reg)\r\n{\r\nreturn inb(dev->base_addr + reg);\r\n}\r\nstatic unsigned short tms_pci_sifreadw(struct net_device *dev, unsigned short reg)\r\n{\r\nreturn inw(dev->base_addr + reg);\r\n}\r\nstatic void tms_pci_sifwriteb(struct net_device *dev, unsigned short val, unsigned short reg)\r\n{\r\noutb(val, dev->base_addr + reg);\r\n}\r\nstatic void tms_pci_sifwritew(struct net_device *dev, unsigned short val, unsigned short reg)\r\n{\r\noutw(val, dev->base_addr + reg);\r\n}\r\nstatic int __devinit tms_pci_attach(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstatic int versionprinted;\r\nstruct net_device *dev;\r\nstruct net_local *tp;\r\nint ret;\r\nunsigned int pci_irq_line;\r\nunsigned long pci_ioaddr;\r\nstruct card_info *cardinfo = &card_info_table[ent->driver_data];\r\nif (versionprinted++ == 0)\r\nprintk("%s", version);\r\nif (pci_enable_device(pdev))\r\nreturn -EIO;\r\npci_irq_line = pdev->irq;\r\npci_ioaddr = pci_resource_start (pdev, 0);\r\ndev = alloc_trdev(sizeof(struct net_local));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nif (!request_region(pci_ioaddr, TMS_PCI_IO_EXTENT, dev->name)) {\r\nret = -EBUSY;\r\ngoto err_out_trdev;\r\n}\r\ndev->base_addr = pci_ioaddr;\r\ndev->irq = pci_irq_line;\r\ndev->dma = 0;\r\ndev_info(&pdev->dev, "%s\n", cardinfo->name);\r\ndev_info(&pdev->dev, " IO: %#4lx IRQ: %d\n", dev->base_addr, dev->irq);\r\ntms_pci_read_eeprom(dev);\r\ndev_info(&pdev->dev, " Ring Station Address: %pM\n", dev->dev_addr);\r\nret = tmsdev_init(dev, &pdev->dev);\r\nif (ret) {\r\ndev_info(&pdev->dev, "unable to get memory for dev->priv.\n");\r\ngoto err_out_region;\r\n}\r\ntp = netdev_priv(dev);\r\ntp->setnselout = tms_pci_setnselout_pins;\r\ntp->sifreadb = tms_pci_sifreadb;\r\ntp->sifreadw = tms_pci_sifreadw;\r\ntp->sifwriteb = tms_pci_sifwriteb;\r\ntp->sifwritew = tms_pci_sifwritew;\r\nmemcpy(tp->ProductID, cardinfo->name, PROD_ID_SIZE + 1);\r\ntp->tmspriv = cardinfo;\r\ndev->netdev_ops = &tms380tr_netdev_ops;\r\nret = request_irq(pdev->irq, tms380tr_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (ret)\r\ngoto err_out_tmsdev;\r\npci_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto err_out_irq;\r\nreturn 0;\r\nerr_out_irq:\r\nfree_irq(pdev->irq, dev);\r\nerr_out_tmsdev:\r\npci_set_drvdata(pdev, NULL);\r\ntmsdev_term(dev);\r\nerr_out_region:\r\nrelease_region(pci_ioaddr, TMS_PCI_IO_EXTENT);\r\nerr_out_trdev:\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nstatic void tms_pci_read_eeprom(struct net_device *dev)\r\n{\r\nint i;\r\ntms_pci_sifwritew(dev, 0, SIFADX);\r\ntms_pci_sifwritew(dev, 0, SIFADR);\r\ndev->addr_len = 6;\r\nfor(i = 0; i < 6; i++)\r\ndev->dev_addr[i] = tms_pci_sifreadw(dev, SIFINC) >> 8;\r\n}\r\nstatic unsigned short tms_pci_setnselout_pins(struct net_device *dev)\r\n{\r\nunsigned short val = 0;\r\nstruct net_local *tp = netdev_priv(dev);\r\nstruct card_info *cardinfo = tp->tmspriv;\r\nif(tp->DataRate == SPEED_4)\r\nval |= cardinfo->nselout[0];\r\nelse\r\nval |= cardinfo->nselout[1];\r\nreturn val;\r\n}\r\nstatic void __devexit tms_pci_detach (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nBUG_ON(!dev);\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, TMS_PCI_IO_EXTENT);\r\nfree_irq(dev->irq, dev);\r\ntmsdev_term(dev);\r\nfree_netdev(dev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int __init tms_pci_init (void)\r\n{\r\nreturn pci_register_driver(&tms_pci_driver);\r\n}\r\nstatic void __exit tms_pci_rmmod (void)\r\n{\r\npci_unregister_driver (&tms_pci_driver);\r\n}
