static void relay_file_mmap_close(struct vm_area_struct *vma)\r\n{\r\nstruct rchan_buf *buf = vma->vm_private_data;\r\nbuf->chan->cb->buf_unmapped(buf, vma->vm_file);\r\n}\r\nstatic int relay_buf_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct page *page;\r\nstruct rchan_buf *buf = vma->vm_private_data;\r\npgoff_t pgoff = vmf->pgoff;\r\nif (!buf)\r\nreturn VM_FAULT_OOM;\r\npage = vmalloc_to_page(buf->start + (pgoff << PAGE_SHIFT));\r\nif (!page)\r\nreturn VM_FAULT_SIGBUS;\r\nget_page(page);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nstatic struct page **relay_alloc_page_array(unsigned int n_pages)\r\n{\r\nconst size_t pa_size = n_pages * sizeof(struct page *);\r\nif (pa_size > PAGE_SIZE)\r\nreturn vzalloc(pa_size);\r\nreturn kzalloc(pa_size, GFP_KERNEL);\r\n}\r\nstatic void relay_free_page_array(struct page **array)\r\n{\r\nif (is_vmalloc_addr(array))\r\nvfree(array);\r\nelse\r\nkfree(array);\r\n}\r\nstatic int relay_mmap_buf(struct rchan_buf *buf, struct vm_area_struct *vma)\r\n{\r\nunsigned long length = vma->vm_end - vma->vm_start;\r\nstruct file *filp = vma->vm_file;\r\nif (!buf)\r\nreturn -EBADF;\r\nif (length != (unsigned long)buf->chan->alloc_size)\r\nreturn -EINVAL;\r\nvma->vm_ops = &relay_file_mmap_ops;\r\nvma->vm_flags |= VM_DONTEXPAND;\r\nvma->vm_private_data = buf;\r\nbuf->chan->cb->buf_mapped(buf, filp);\r\nreturn 0;\r\n}\r\nstatic void *relay_alloc_buf(struct rchan_buf *buf, size_t *size)\r\n{\r\nvoid *mem;\r\nunsigned int i, j, n_pages;\r\n*size = PAGE_ALIGN(*size);\r\nn_pages = *size >> PAGE_SHIFT;\r\nbuf->page_array = relay_alloc_page_array(n_pages);\r\nif (!buf->page_array)\r\nreturn NULL;\r\nfor (i = 0; i < n_pages; i++) {\r\nbuf->page_array[i] = alloc_page(GFP_KERNEL);\r\nif (unlikely(!buf->page_array[i]))\r\ngoto depopulate;\r\nset_page_private(buf->page_array[i], (unsigned long)buf);\r\n}\r\nmem = vmap(buf->page_array, n_pages, VM_MAP, PAGE_KERNEL);\r\nif (!mem)\r\ngoto depopulate;\r\nmemset(mem, 0, *size);\r\nbuf->page_count = n_pages;\r\nreturn mem;\r\ndepopulate:\r\nfor (j = 0; j < i; j++)\r\n__free_page(buf->page_array[j]);\r\nrelay_free_page_array(buf->page_array);\r\nreturn NULL;\r\n}\r\nstatic struct rchan_buf *relay_create_buf(struct rchan *chan)\r\n{\r\nstruct rchan_buf *buf = kzalloc(sizeof(struct rchan_buf), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->padding = kmalloc(chan->n_subbufs * sizeof(size_t *), GFP_KERNEL);\r\nif (!buf->padding)\r\ngoto free_buf;\r\nbuf->start = relay_alloc_buf(buf, &chan->alloc_size);\r\nif (!buf->start)\r\ngoto free_buf;\r\nbuf->chan = chan;\r\nkref_get(&buf->chan->kref);\r\nreturn buf;\r\nfree_buf:\r\nkfree(buf->padding);\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nstatic void relay_destroy_channel(struct kref *kref)\r\n{\r\nstruct rchan *chan = container_of(kref, struct rchan, kref);\r\nkfree(chan);\r\n}\r\nstatic void relay_destroy_buf(struct rchan_buf *buf)\r\n{\r\nstruct rchan *chan = buf->chan;\r\nunsigned int i;\r\nif (likely(buf->start)) {\r\nvunmap(buf->start);\r\nfor (i = 0; i < buf->page_count; i++)\r\n__free_page(buf->page_array[i]);\r\nrelay_free_page_array(buf->page_array);\r\n}\r\nchan->buf[buf->cpu] = NULL;\r\nkfree(buf->padding);\r\nkfree(buf);\r\nkref_put(&chan->kref, relay_destroy_channel);\r\n}\r\nstatic void relay_remove_buf(struct kref *kref)\r\n{\r\nstruct rchan_buf *buf = container_of(kref, struct rchan_buf, kref);\r\nbuf->chan->cb->remove_buf_file(buf->dentry);\r\nrelay_destroy_buf(buf);\r\n}\r\nstatic int relay_buf_empty(struct rchan_buf *buf)\r\n{\r\nreturn (buf->subbufs_produced - buf->subbufs_consumed) ? 0 : 1;\r\n}\r\nint relay_buf_full(struct rchan_buf *buf)\r\n{\r\nsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\r\nreturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\r\n}\r\nstatic int subbuf_start_default_callback (struct rchan_buf *buf,\r\nvoid *subbuf,\r\nvoid *prev_subbuf,\r\nsize_t prev_padding)\r\n{\r\nif (relay_buf_full(buf))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void buf_mapped_default_callback(struct rchan_buf *buf,\r\nstruct file *filp)\r\n{\r\n}\r\nstatic void buf_unmapped_default_callback(struct rchan_buf *buf,\r\nstruct file *filp)\r\n{\r\n}\r\nstatic struct dentry *create_buf_file_default_callback(const char *filename,\r\nstruct dentry *parent,\r\nint mode,\r\nstruct rchan_buf *buf,\r\nint *is_global)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int remove_buf_file_default_callback(struct dentry *dentry)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void wakeup_readers(unsigned long data)\r\n{\r\nstruct rchan_buf *buf = (struct rchan_buf *)data;\r\nwake_up_interruptible(&buf->read_wait);\r\n}\r\nstatic void __relay_reset(struct rchan_buf *buf, unsigned int init)\r\n{\r\nsize_t i;\r\nif (init) {\r\ninit_waitqueue_head(&buf->read_wait);\r\nkref_init(&buf->kref);\r\nsetup_timer(&buf->timer, wakeup_readers, (unsigned long)buf);\r\n} else\r\ndel_timer_sync(&buf->timer);\r\nbuf->subbufs_produced = 0;\r\nbuf->subbufs_consumed = 0;\r\nbuf->bytes_consumed = 0;\r\nbuf->finalized = 0;\r\nbuf->data = buf->start;\r\nbuf->offset = 0;\r\nfor (i = 0; i < buf->chan->n_subbufs; i++)\r\nbuf->padding[i] = 0;\r\nbuf->chan->cb->subbuf_start(buf, buf->data, NULL, 0);\r\n}\r\nvoid relay_reset(struct rchan *chan)\r\n{\r\nunsigned int i;\r\nif (!chan)\r\nreturn;\r\nif (chan->is_global && chan->buf[0]) {\r\n__relay_reset(chan->buf[0], 0);\r\nreturn;\r\n}\r\nmutex_lock(&relay_channels_mutex);\r\nfor_each_possible_cpu(i)\r\nif (chan->buf[i])\r\n__relay_reset(chan->buf[i], 0);\r\nmutex_unlock(&relay_channels_mutex);\r\n}\r\nstatic inline void relay_set_buf_dentry(struct rchan_buf *buf,\r\nstruct dentry *dentry)\r\n{\r\nbuf->dentry = dentry;\r\nbuf->dentry->d_inode->i_size = buf->early_bytes;\r\n}\r\nstatic struct dentry *relay_create_buf_file(struct rchan *chan,\r\nstruct rchan_buf *buf,\r\nunsigned int cpu)\r\n{\r\nstruct dentry *dentry;\r\nchar *tmpname;\r\ntmpname = kzalloc(NAME_MAX + 1, GFP_KERNEL);\r\nif (!tmpname)\r\nreturn NULL;\r\nsnprintf(tmpname, NAME_MAX, "%s%d", chan->base_filename, cpu);\r\ndentry = chan->cb->create_buf_file(tmpname, chan->parent,\r\nS_IRUSR, buf,\r\n&chan->is_global);\r\nkfree(tmpname);\r\nreturn dentry;\r\n}\r\nstatic struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\r\n{\r\nstruct rchan_buf *buf = NULL;\r\nstruct dentry *dentry;\r\nif (chan->is_global)\r\nreturn chan->buf[0];\r\nbuf = relay_create_buf(chan);\r\nif (!buf)\r\nreturn NULL;\r\nif (chan->has_base_filename) {\r\ndentry = relay_create_buf_file(chan, buf, cpu);\r\nif (!dentry)\r\ngoto free_buf;\r\nrelay_set_buf_dentry(buf, dentry);\r\n}\r\nbuf->cpu = cpu;\r\n__relay_reset(buf, 1);\r\nif(chan->is_global) {\r\nchan->buf[0] = buf;\r\nbuf->cpu = 0;\r\n}\r\nreturn buf;\r\nfree_buf:\r\nrelay_destroy_buf(buf);\r\nreturn NULL;\r\n}\r\nstatic void relay_close_buf(struct rchan_buf *buf)\r\n{\r\nbuf->finalized = 1;\r\ndel_timer_sync(&buf->timer);\r\nkref_put(&buf->kref, relay_remove_buf);\r\n}\r\nstatic void setup_callbacks(struct rchan *chan,\r\nstruct rchan_callbacks *cb)\r\n{\r\nif (!cb) {\r\nchan->cb = &default_channel_callbacks;\r\nreturn;\r\n}\r\nif (!cb->subbuf_start)\r\ncb->subbuf_start = subbuf_start_default_callback;\r\nif (!cb->buf_mapped)\r\ncb->buf_mapped = buf_mapped_default_callback;\r\nif (!cb->buf_unmapped)\r\ncb->buf_unmapped = buf_unmapped_default_callback;\r\nif (!cb->create_buf_file)\r\ncb->create_buf_file = create_buf_file_default_callback;\r\nif (!cb->remove_buf_file)\r\ncb->remove_buf_file = remove_buf_file_default_callback;\r\nchan->cb = cb;\r\n}\r\nstatic int __cpuinit relay_hotcpu_callback(struct notifier_block *nb,\r\nunsigned long action,\r\nvoid *hcpu)\r\n{\r\nunsigned int hotcpu = (unsigned long)hcpu;\r\nstruct rchan *chan;\r\nswitch(action) {\r\ncase CPU_UP_PREPARE:\r\ncase CPU_UP_PREPARE_FROZEN:\r\nmutex_lock(&relay_channels_mutex);\r\nlist_for_each_entry(chan, &relay_channels, list) {\r\nif (chan->buf[hotcpu])\r\ncontinue;\r\nchan->buf[hotcpu] = relay_open_buf(chan, hotcpu);\r\nif(!chan->buf[hotcpu]) {\r\nprintk(KERN_ERR\r\n"relay_hotcpu_callback: cpu %d buffer "\r\n"creation failed\n", hotcpu);\r\nmutex_unlock(&relay_channels_mutex);\r\nreturn notifier_from_errno(-ENOMEM);\r\n}\r\n}\r\nmutex_unlock(&relay_channels_mutex);\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstruct rchan *relay_open(const char *base_filename,\r\nstruct dentry *parent,\r\nsize_t subbuf_size,\r\nsize_t n_subbufs,\r\nstruct rchan_callbacks *cb,\r\nvoid *private_data)\r\n{\r\nunsigned int i;\r\nstruct rchan *chan;\r\nif (!(subbuf_size && n_subbufs))\r\nreturn NULL;\r\nchan = kzalloc(sizeof(struct rchan), GFP_KERNEL);\r\nif (!chan)\r\nreturn NULL;\r\nchan->version = RELAYFS_CHANNEL_VERSION;\r\nchan->n_subbufs = n_subbufs;\r\nchan->subbuf_size = subbuf_size;\r\nchan->alloc_size = FIX_SIZE(subbuf_size * n_subbufs);\r\nchan->parent = parent;\r\nchan->private_data = private_data;\r\nif (base_filename) {\r\nchan->has_base_filename = 1;\r\nstrlcpy(chan->base_filename, base_filename, NAME_MAX);\r\n}\r\nsetup_callbacks(chan, cb);\r\nkref_init(&chan->kref);\r\nmutex_lock(&relay_channels_mutex);\r\nfor_each_online_cpu(i) {\r\nchan->buf[i] = relay_open_buf(chan, i);\r\nif (!chan->buf[i])\r\ngoto free_bufs;\r\n}\r\nlist_add(&chan->list, &relay_channels);\r\nmutex_unlock(&relay_channels_mutex);\r\nreturn chan;\r\nfree_bufs:\r\nfor_each_possible_cpu(i) {\r\nif (chan->buf[i])\r\nrelay_close_buf(chan->buf[i]);\r\n}\r\nkref_put(&chan->kref, relay_destroy_channel);\r\nmutex_unlock(&relay_channels_mutex);\r\nreturn NULL;\r\n}\r\nstatic void __relay_set_buf_dentry(void *info)\r\n{\r\nstruct rchan_percpu_buf_dispatcher *p = info;\r\nrelay_set_buf_dentry(p->buf, p->dentry);\r\n}\r\nint relay_late_setup_files(struct rchan *chan,\r\nconst char *base_filename,\r\nstruct dentry *parent)\r\n{\r\nint err = 0;\r\nunsigned int i, curr_cpu;\r\nunsigned long flags;\r\nstruct dentry *dentry;\r\nstruct rchan_percpu_buf_dispatcher disp;\r\nif (!chan || !base_filename)\r\nreturn -EINVAL;\r\nstrlcpy(chan->base_filename, base_filename, NAME_MAX);\r\nmutex_lock(&relay_channels_mutex);\r\nif (unlikely(chan->has_base_filename)) {\r\nmutex_unlock(&relay_channels_mutex);\r\nreturn -EEXIST;\r\n}\r\nchan->has_base_filename = 1;\r\nchan->parent = parent;\r\ncurr_cpu = get_cpu();\r\nfor_each_online_cpu(i) {\r\nif (unlikely(!chan->buf[i])) {\r\nWARN_ONCE(1, KERN_ERR "CPU has no buffer!\n");\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ndentry = relay_create_buf_file(chan, chan->buf[i], i);\r\nif (unlikely(!dentry)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (curr_cpu == i) {\r\nlocal_irq_save(flags);\r\nrelay_set_buf_dentry(chan->buf[i], dentry);\r\nlocal_irq_restore(flags);\r\n} else {\r\ndisp.buf = chan->buf[i];\r\ndisp.dentry = dentry;\r\nsmp_mb();\r\nerr = smp_call_function_single(i,\r\n__relay_set_buf_dentry,\r\n&disp, 1);\r\n}\r\nif (unlikely(err))\r\nbreak;\r\n}\r\nput_cpu();\r\nmutex_unlock(&relay_channels_mutex);\r\nreturn err;\r\n}\r\nsize_t relay_switch_subbuf(struct rchan_buf *buf, size_t length)\r\n{\r\nvoid *old, *new;\r\nsize_t old_subbuf, new_subbuf;\r\nif (unlikely(length > buf->chan->subbuf_size))\r\ngoto toobig;\r\nif (buf->offset != buf->chan->subbuf_size + 1) {\r\nbuf->prev_padding = buf->chan->subbuf_size - buf->offset;\r\nold_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\r\nbuf->padding[old_subbuf] = buf->prev_padding;\r\nbuf->subbufs_produced++;\r\nif (buf->dentry)\r\nbuf->dentry->d_inode->i_size +=\r\nbuf->chan->subbuf_size -\r\nbuf->padding[old_subbuf];\r\nelse\r\nbuf->early_bytes += buf->chan->subbuf_size -\r\nbuf->padding[old_subbuf];\r\nsmp_mb();\r\nif (waitqueue_active(&buf->read_wait))\r\nmod_timer(&buf->timer, jiffies + 1);\r\n}\r\nold = buf->data;\r\nnew_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\r\nnew = buf->start + new_subbuf * buf->chan->subbuf_size;\r\nbuf->offset = 0;\r\nif (!buf->chan->cb->subbuf_start(buf, new, old, buf->prev_padding)) {\r\nbuf->offset = buf->chan->subbuf_size + 1;\r\nreturn 0;\r\n}\r\nbuf->data = new;\r\nbuf->padding[new_subbuf] = 0;\r\nif (unlikely(length + buf->offset > buf->chan->subbuf_size))\r\ngoto toobig;\r\nreturn length;\r\ntoobig:\r\nbuf->chan->last_toobig = length;\r\nreturn 0;\r\n}\r\nvoid relay_subbufs_consumed(struct rchan *chan,\r\nunsigned int cpu,\r\nsize_t subbufs_consumed)\r\n{\r\nstruct rchan_buf *buf;\r\nif (!chan)\r\nreturn;\r\nif (cpu >= NR_CPUS || !chan->buf[cpu] ||\r\nsubbufs_consumed > chan->n_subbufs)\r\nreturn;\r\nbuf = chan->buf[cpu];\r\nif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\r\nbuf->subbufs_consumed = buf->subbufs_produced;\r\nelse\r\nbuf->subbufs_consumed += subbufs_consumed;\r\n}\r\nvoid relay_close(struct rchan *chan)\r\n{\r\nunsigned int i;\r\nif (!chan)\r\nreturn;\r\nmutex_lock(&relay_channels_mutex);\r\nif (chan->is_global && chan->buf[0])\r\nrelay_close_buf(chan->buf[0]);\r\nelse\r\nfor_each_possible_cpu(i)\r\nif (chan->buf[i])\r\nrelay_close_buf(chan->buf[i]);\r\nif (chan->last_toobig)\r\nprintk(KERN_WARNING "relay: one or more items not logged "\r\n"[item size (%Zd) > sub-buffer size (%Zd)]\n",\r\nchan->last_toobig, chan->subbuf_size);\r\nlist_del(&chan->list);\r\nkref_put(&chan->kref, relay_destroy_channel);\r\nmutex_unlock(&relay_channels_mutex);\r\n}\r\nvoid relay_flush(struct rchan *chan)\r\n{\r\nunsigned int i;\r\nif (!chan)\r\nreturn;\r\nif (chan->is_global && chan->buf[0]) {\r\nrelay_switch_subbuf(chan->buf[0], 0);\r\nreturn;\r\n}\r\nmutex_lock(&relay_channels_mutex);\r\nfor_each_possible_cpu(i)\r\nif (chan->buf[i])\r\nrelay_switch_subbuf(chan->buf[i], 0);\r\nmutex_unlock(&relay_channels_mutex);\r\n}\r\nstatic int relay_file_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct rchan_buf *buf = inode->i_private;\r\nkref_get(&buf->kref);\r\nfilp->private_data = buf;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int relay_file_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct rchan_buf *buf = filp->private_data;\r\nreturn relay_mmap_buf(buf, vma);\r\n}\r\nstatic unsigned int relay_file_poll(struct file *filp, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\nstruct rchan_buf *buf = filp->private_data;\r\nif (buf->finalized)\r\nreturn POLLERR;\r\nif (filp->f_mode & FMODE_READ) {\r\npoll_wait(filp, &buf->read_wait, wait);\r\nif (!relay_buf_empty(buf))\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic int relay_file_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct rchan_buf *buf = filp->private_data;\r\nkref_put(&buf->kref, relay_remove_buf);\r\nreturn 0;\r\n}\r\nstatic void relay_file_read_consume(struct rchan_buf *buf,\r\nsize_t read_pos,\r\nsize_t bytes_consumed)\r\n{\r\nsize_t subbuf_size = buf->chan->subbuf_size;\r\nsize_t n_subbufs = buf->chan->n_subbufs;\r\nsize_t read_subbuf;\r\nif (buf->subbufs_produced == buf->subbufs_consumed &&\r\nbuf->offset == buf->bytes_consumed)\r\nreturn;\r\nif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\r\nrelay_subbufs_consumed(buf->chan, buf->cpu, 1);\r\nbuf->bytes_consumed = 0;\r\n}\r\nbuf->bytes_consumed += bytes_consumed;\r\nif (!read_pos)\r\nread_subbuf = buf->subbufs_consumed % n_subbufs;\r\nelse\r\nread_subbuf = read_pos / buf->chan->subbuf_size;\r\nif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\r\nif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\r\n(buf->offset == subbuf_size))\r\nreturn;\r\nrelay_subbufs_consumed(buf->chan, buf->cpu, 1);\r\nbuf->bytes_consumed = 0;\r\n}\r\n}\r\nstatic int relay_file_read_avail(struct rchan_buf *buf, size_t read_pos)\r\n{\r\nsize_t subbuf_size = buf->chan->subbuf_size;\r\nsize_t n_subbufs = buf->chan->n_subbufs;\r\nsize_t produced = buf->subbufs_produced;\r\nsize_t consumed = buf->subbufs_consumed;\r\nrelay_file_read_consume(buf, read_pos, 0);\r\nconsumed = buf->subbufs_consumed;\r\nif (unlikely(buf->offset > subbuf_size)) {\r\nif (produced == consumed)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nif (unlikely(produced - consumed >= n_subbufs)) {\r\nconsumed = produced - n_subbufs + 1;\r\nbuf->subbufs_consumed = consumed;\r\nbuf->bytes_consumed = 0;\r\n}\r\nproduced = (produced % n_subbufs) * subbuf_size + buf->offset;\r\nconsumed = (consumed % n_subbufs) * subbuf_size + buf->bytes_consumed;\r\nif (consumed > produced)\r\nproduced += n_subbufs * subbuf_size;\r\nif (consumed == produced) {\r\nif (buf->offset == subbuf_size &&\r\nbuf->subbufs_produced > buf->subbufs_consumed)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic size_t relay_file_read_subbuf_avail(size_t read_pos,\r\nstruct rchan_buf *buf)\r\n{\r\nsize_t padding, avail = 0;\r\nsize_t read_subbuf, read_offset, write_subbuf, write_offset;\r\nsize_t subbuf_size = buf->chan->subbuf_size;\r\nwrite_subbuf = (buf->data - buf->start) / subbuf_size;\r\nwrite_offset = buf->offset > subbuf_size ? subbuf_size : buf->offset;\r\nread_subbuf = read_pos / subbuf_size;\r\nread_offset = read_pos % subbuf_size;\r\npadding = buf->padding[read_subbuf];\r\nif (read_subbuf == write_subbuf) {\r\nif (read_offset + padding < write_offset)\r\navail = write_offset - (read_offset + padding);\r\n} else\r\navail = (subbuf_size - padding) - read_offset;\r\nreturn avail;\r\n}\r\nstatic size_t relay_file_read_start_pos(size_t read_pos,\r\nstruct rchan_buf *buf)\r\n{\r\nsize_t read_subbuf, padding, padding_start, padding_end;\r\nsize_t subbuf_size = buf->chan->subbuf_size;\r\nsize_t n_subbufs = buf->chan->n_subbufs;\r\nsize_t consumed = buf->subbufs_consumed % n_subbufs;\r\nif (!read_pos)\r\nread_pos = consumed * subbuf_size + buf->bytes_consumed;\r\nread_subbuf = read_pos / subbuf_size;\r\npadding = buf->padding[read_subbuf];\r\npadding_start = (read_subbuf + 1) * subbuf_size - padding;\r\npadding_end = (read_subbuf + 1) * subbuf_size;\r\nif (read_pos >= padding_start && read_pos < padding_end) {\r\nread_subbuf = (read_subbuf + 1) % n_subbufs;\r\nread_pos = read_subbuf * subbuf_size;\r\n}\r\nreturn read_pos;\r\n}\r\nstatic size_t relay_file_read_end_pos(struct rchan_buf *buf,\r\nsize_t read_pos,\r\nsize_t count)\r\n{\r\nsize_t read_subbuf, padding, end_pos;\r\nsize_t subbuf_size = buf->chan->subbuf_size;\r\nsize_t n_subbufs = buf->chan->n_subbufs;\r\nread_subbuf = read_pos / subbuf_size;\r\npadding = buf->padding[read_subbuf];\r\nif (read_pos % subbuf_size + count + padding == subbuf_size)\r\nend_pos = (read_subbuf + 1) * subbuf_size;\r\nelse\r\nend_pos = read_pos + count;\r\nif (end_pos >= subbuf_size * n_subbufs)\r\nend_pos = 0;\r\nreturn end_pos;\r\n}\r\nstatic int subbuf_read_actor(size_t read_start,\r\nstruct rchan_buf *buf,\r\nsize_t avail,\r\nread_descriptor_t *desc,\r\nread_actor_t actor)\r\n{\r\nvoid *from;\r\nint ret = 0;\r\nfrom = buf->start + read_start;\r\nret = avail;\r\nif (copy_to_user(desc->arg.buf, from, avail)) {\r\ndesc->error = -EFAULT;\r\nret = 0;\r\n}\r\ndesc->arg.data += ret;\r\ndesc->written += ret;\r\ndesc->count -= ret;\r\nreturn ret;\r\n}\r\nstatic ssize_t relay_file_read_subbufs(struct file *filp, loff_t *ppos,\r\nsubbuf_actor_t subbuf_actor,\r\nread_actor_t actor,\r\nread_descriptor_t *desc)\r\n{\r\nstruct rchan_buf *buf = filp->private_data;\r\nsize_t read_start, avail;\r\nint ret;\r\nif (!desc->count)\r\nreturn 0;\r\nmutex_lock(&filp->f_path.dentry->d_inode->i_mutex);\r\ndo {\r\nif (!relay_file_read_avail(buf, *ppos))\r\nbreak;\r\nread_start = relay_file_read_start_pos(*ppos, buf);\r\navail = relay_file_read_subbuf_avail(read_start, buf);\r\nif (!avail)\r\nbreak;\r\navail = min(desc->count, avail);\r\nret = subbuf_actor(read_start, buf, avail, desc, actor);\r\nif (desc->error < 0)\r\nbreak;\r\nif (ret) {\r\nrelay_file_read_consume(buf, read_start, ret);\r\n*ppos = relay_file_read_end_pos(buf, read_start, ret);\r\n}\r\n} while (desc->count && ret);\r\nmutex_unlock(&filp->f_path.dentry->d_inode->i_mutex);\r\nreturn desc->written;\r\n}\r\nstatic ssize_t relay_file_read(struct file *filp,\r\nchar __user *buffer,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nread_descriptor_t desc;\r\ndesc.written = 0;\r\ndesc.count = count;\r\ndesc.arg.buf = buffer;\r\ndesc.error = 0;\r\nreturn relay_file_read_subbufs(filp, ppos, subbuf_read_actor,\r\nNULL, &desc);\r\n}\r\nstatic void relay_consume_bytes(struct rchan_buf *rbuf, int bytes_consumed)\r\n{\r\nrbuf->bytes_consumed += bytes_consumed;\r\nif (rbuf->bytes_consumed >= rbuf->chan->subbuf_size) {\r\nrelay_subbufs_consumed(rbuf->chan, rbuf->cpu, 1);\r\nrbuf->bytes_consumed %= rbuf->chan->subbuf_size;\r\n}\r\n}\r\nstatic void relay_pipe_buf_release(struct pipe_inode_info *pipe,\r\nstruct pipe_buffer *buf)\r\n{\r\nstruct rchan_buf *rbuf;\r\nrbuf = (struct rchan_buf *)page_private(buf->page);\r\nrelay_consume_bytes(rbuf, buf->private);\r\n}\r\nstatic void relay_page_release(struct splice_pipe_desc *spd, unsigned int i)\r\n{\r\n}\r\nstatic ssize_t subbuf_splice_actor(struct file *in,\r\nloff_t *ppos,\r\nstruct pipe_inode_info *pipe,\r\nsize_t len,\r\nunsigned int flags,\r\nint *nonpad_ret)\r\n{\r\nunsigned int pidx, poff, total_len, subbuf_pages, nr_pages;\r\nstruct rchan_buf *rbuf = in->private_data;\r\nunsigned int subbuf_size = rbuf->chan->subbuf_size;\r\nuint64_t pos = (uint64_t) *ppos;\r\nuint32_t alloc_size = (uint32_t) rbuf->chan->alloc_size;\r\nsize_t read_start = (size_t) do_div(pos, alloc_size);\r\nsize_t read_subbuf = read_start / subbuf_size;\r\nsize_t padding = rbuf->padding[read_subbuf];\r\nsize_t nonpad_end = read_subbuf * subbuf_size + subbuf_size - padding;\r\nstruct page *pages[PIPE_DEF_BUFFERS];\r\nstruct partial_page partial[PIPE_DEF_BUFFERS];\r\nstruct splice_pipe_desc spd = {\r\n.pages = pages,\r\n.nr_pages = 0,\r\n.partial = partial,\r\n.flags = flags,\r\n.ops = &relay_pipe_buf_ops,\r\n.spd_release = relay_page_release,\r\n};\r\nssize_t ret;\r\nif (rbuf->subbufs_produced == rbuf->subbufs_consumed)\r\nreturn 0;\r\nif (splice_grow_spd(pipe, &spd))\r\nreturn -ENOMEM;\r\nif (len > (subbuf_size - read_start % subbuf_size))\r\nlen = subbuf_size - read_start % subbuf_size;\r\nsubbuf_pages = rbuf->chan->alloc_size >> PAGE_SHIFT;\r\npidx = (read_start / PAGE_SIZE) % subbuf_pages;\r\npoff = read_start & ~PAGE_MASK;\r\nnr_pages = min_t(unsigned int, subbuf_pages, pipe->buffers);\r\nfor (total_len = 0; spd.nr_pages < nr_pages; spd.nr_pages++) {\r\nunsigned int this_len, this_end, private;\r\nunsigned int cur_pos = read_start + total_len;\r\nif (!len)\r\nbreak;\r\nthis_len = min_t(unsigned long, len, PAGE_SIZE - poff);\r\nprivate = this_len;\r\nspd.pages[spd.nr_pages] = rbuf->page_array[pidx];\r\nspd.partial[spd.nr_pages].offset = poff;\r\nthis_end = cur_pos + this_len;\r\nif (this_end >= nonpad_end) {\r\nthis_len = nonpad_end - cur_pos;\r\nprivate = this_len + padding;\r\n}\r\nspd.partial[spd.nr_pages].len = this_len;\r\nspd.partial[spd.nr_pages].private = private;\r\nlen -= this_len;\r\ntotal_len += this_len;\r\npoff = 0;\r\npidx = (pidx + 1) % subbuf_pages;\r\nif (this_end >= nonpad_end) {\r\nspd.nr_pages++;\r\nbreak;\r\n}\r\n}\r\nret = 0;\r\nif (!spd.nr_pages)\r\ngoto out;\r\nret = *nonpad_ret = splice_to_pipe(pipe, &spd);\r\nif (ret < 0 || ret < total_len)\r\ngoto out;\r\nif (read_start + ret == nonpad_end)\r\nret += padding;\r\nout:\r\nsplice_shrink_spd(pipe, &spd);\r\nreturn ret;\r\n}\r\nstatic ssize_t relay_file_splice_read(struct file *in,\r\nloff_t *ppos,\r\nstruct pipe_inode_info *pipe,\r\nsize_t len,\r\nunsigned int flags)\r\n{\r\nssize_t spliced;\r\nint ret;\r\nint nonpad_ret = 0;\r\nret = 0;\r\nspliced = 0;\r\nwhile (len && !spliced) {\r\nret = subbuf_splice_actor(in, ppos, pipe, len, flags, &nonpad_ret);\r\nif (ret < 0)\r\nbreak;\r\nelse if (!ret) {\r\nif (flags & SPLICE_F_NONBLOCK)\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\n*ppos += ret;\r\nif (ret > len)\r\nlen = 0;\r\nelse\r\nlen -= ret;\r\nspliced += nonpad_ret;\r\nnonpad_ret = 0;\r\n}\r\nif (spliced)\r\nreturn spliced;\r\nreturn ret;\r\n}\r\nstatic __init int relay_init(void)\r\n{\r\nhotcpu_notifier(relay_hotcpu_callback, 0);\r\nreturn 0;\r\n}
