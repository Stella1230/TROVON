static void find_start_end(unsigned long flags, unsigned long *begin,\r\nunsigned long *end)\r\n{\r\nif (!test_thread_flag(TIF_IA32) && (flags & MAP_32BIT)) {\r\nunsigned long new_begin;\r\n*begin = 0x40000000;\r\n*end = 0x80000000;\r\nif (current->flags & PF_RANDOMIZE) {\r\nnew_begin = randomize_range(*begin, *begin + 0x02000000, 0);\r\nif (new_begin)\r\n*begin = new_begin;\r\n}\r\n} else {\r\n*begin = TASK_UNMAPPED_BASE;\r\n*end = TASK_SIZE;\r\n}\r\n}\r\nunsigned long\r\narch_get_unmapped_area(struct file *filp, unsigned long addr,\r\nunsigned long len, unsigned long pgoff, unsigned long flags)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nunsigned long start_addr;\r\nunsigned long begin, end;\r\nif (flags & MAP_FIXED)\r\nreturn addr;\r\nfind_start_end(flags, &begin, &end);\r\nif (len > end)\r\nreturn -ENOMEM;\r\nif (addr) {\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(mm, addr);\r\nif (end - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\nreturn addr;\r\n}\r\nif (((flags & MAP_32BIT) || test_thread_flag(TIF_IA32))\r\n&& len <= mm->cached_hole_size) {\r\nmm->cached_hole_size = 0;\r\nmm->free_area_cache = begin;\r\n}\r\naddr = mm->free_area_cache;\r\nif (addr < begin)\r\naddr = begin;\r\nstart_addr = addr;\r\nfull_search:\r\nfor (vma = find_vma(mm, addr); ; vma = vma->vm_next) {\r\nif (end - len < addr) {\r\nif (start_addr != begin) {\r\nstart_addr = addr = begin;\r\nmm->cached_hole_size = 0;\r\ngoto full_search;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nif (!vma || addr + len <= vma->vm_start) {\r\nmm->free_area_cache = addr + len;\r\nreturn addr;\r\n}\r\nif (addr + mm->cached_hole_size < vma->vm_start)\r\nmm->cached_hole_size = vma->vm_start - addr;\r\naddr = vma->vm_end;\r\n}\r\n}\r\nunsigned long\r\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\r\nconst unsigned long len, const unsigned long pgoff,\r\nconst unsigned long flags)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long addr = addr0;\r\nif (len > TASK_SIZE)\r\nreturn -ENOMEM;\r\nif (flags & MAP_FIXED)\r\nreturn addr;\r\nif (!test_thread_flag(TIF_IA32) && (flags & MAP_32BIT))\r\ngoto bottomup;\r\nif (addr) {\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(mm, addr);\r\nif (TASK_SIZE - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\nreturn addr;\r\n}\r\nif (len <= mm->cached_hole_size) {\r\nmm->cached_hole_size = 0;\r\nmm->free_area_cache = mm->mmap_base;\r\n}\r\naddr = mm->free_area_cache;\r\nif (addr > len) {\r\nvma = find_vma(mm, addr-len);\r\nif (!vma || addr <= vma->vm_start)\r\nreturn mm->free_area_cache = addr-len;\r\n}\r\nif (mm->mmap_base < len)\r\ngoto bottomup;\r\naddr = mm->mmap_base-len;\r\ndo {\r\nvma = find_vma(mm, addr);\r\nif (!vma || addr+len <= vma->vm_start)\r\nreturn mm->free_area_cache = addr;\r\nif (addr + mm->cached_hole_size < vma->vm_start)\r\nmm->cached_hole_size = vma->vm_start - addr;\r\naddr = vma->vm_start-len;\r\n} while (len < vma->vm_start);\r\nbottomup:\r\nmm->cached_hole_size = ~0UL;\r\nmm->free_area_cache = TASK_UNMAPPED_BASE;\r\naddr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);\r\nmm->free_area_cache = mm->mmap_base;\r\nmm->cached_hole_size = ~0UL;\r\nreturn addr;\r\n}
