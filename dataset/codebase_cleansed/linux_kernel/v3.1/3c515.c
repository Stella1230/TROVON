int init_module(void)\r\n{\r\nint found = 0;\r\nif (debug >= 0)\r\ncorkscrew_debug = debug;\r\nif (corkscrew_debug)\r\npr_debug("%s", version);\r\nwhile (corkscrew_scan(-1))\r\nfound++;\r\nreturn found ? 0 : -ENODEV;\r\n}\r\nstruct net_device *tc515_probe(int unit)\r\n{\r\nstruct net_device *dev = corkscrew_scan(unit);\r\nstatic int printed;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nif (corkscrew_debug > 0 && !printed) {\r\nprinted = 1;\r\npr_debug("%s", version);\r\n}\r\nreturn dev;\r\n}\r\nstatic int check_device(unsigned ioaddr)\r\n{\r\nint timer;\r\nif (!request_region(ioaddr, CORKSCREW_TOTAL_SIZE, "3c515"))\r\nreturn 0;\r\nif ((inw(ioaddr + 0x2002) & 0x1f0) != (ioaddr & 0x1f0)) {\r\nrelease_region(ioaddr, CORKSCREW_TOTAL_SIZE);\r\nreturn 0;\r\n}\r\noutw(EEPROM_Read + 7, ioaddr + Wn0EepromCmd);\r\nfor (timer = 4; timer >= 0; timer--) {\r\nudelay(162);\r\nif ((inw(ioaddr + Wn0EepromCmd) & 0x0200) == 0)\r\nbreak;\r\n}\r\nif (inw(ioaddr + Wn0EepromData) != 0x6d50) {\r\nrelease_region(ioaddr, CORKSCREW_TOTAL_SIZE);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\nlist_del_init(&vp->list);\r\nif (dev->dma)\r\nfree_dma(dev->dma);\r\noutw(TotalReset, dev->base_addr + EL3_CMD);\r\nrelease_region(dev->base_addr, CORKSCREW_TOTAL_SIZE);\r\nif (vp->dev)\r\npnp_device_detach(to_pnp_dev(vp->dev));\r\n}\r\nstatic struct net_device *corkscrew_scan(int unit)\r\n{\r\nstruct net_device *dev;\r\nstatic int cards_found = 0;\r\nstatic int ioaddr;\r\nint err;\r\n#ifdef __ISAPNP__\r\nshort i;\r\nstatic int pnp_cards;\r\n#endif\r\ndev = alloc_etherdev(sizeof(struct corkscrew_private));\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\n#ifdef __ISAPNP__\r\nif(nopnp == 1)\r\ngoto no_pnp;\r\nfor(i=0; corkscrew_isapnp_adapters[i].vendor != 0; i++) {\r\nstruct pnp_dev *idev = NULL;\r\nint irq;\r\nwhile((idev = pnp_find_dev(NULL,\r\ncorkscrew_isapnp_adapters[i].vendor,\r\ncorkscrew_isapnp_adapters[i].function,\r\nidev))) {\r\nif (pnp_device_attach(idev) < 0)\r\ncontinue;\r\nif (pnp_activate_dev(idev) < 0) {\r\npr_warning("pnp activate failed (out of resources?)\n");\r\npnp_device_detach(idev);\r\ncontinue;\r\n}\r\nif (!pnp_port_valid(idev, 0) || !pnp_irq_valid(idev, 0)) {\r\npnp_device_detach(idev);\r\ncontinue;\r\n}\r\nioaddr = pnp_port_start(idev, 0);\r\nirq = pnp_irq(idev, 0);\r\nif (!check_device(ioaddr)) {\r\npnp_device_detach(idev);\r\ncontinue;\r\n}\r\nif(corkscrew_debug)\r\npr_debug("ISAPNP reports %s at i/o 0x%x, irq %d\n",\r\n(char*) corkscrew_isapnp_adapters[i].driver_data, ioaddr, irq);\r\npr_info("3c515 Resource configuration register %#4.4x, DCR %4.4x.\n",\r\ninl(ioaddr + 0x2002), inw(ioaddr + 0x2000));\r\nSET_NETDEV_DEV(dev, &idev->dev);\r\npnp_cards++;\r\nerr = corkscrew_setup(dev, ioaddr, idev, cards_found++);\r\nif (!err)\r\nreturn dev;\r\ncleanup_card(dev);\r\n}\r\n}\r\nno_pnp:\r\n#endif\r\nfor (ioaddr = 0x100; ioaddr < 0x400; ioaddr += 0x20) {\r\nif (!check_device(ioaddr))\r\ncontinue;\r\npr_info("3c515 Resource configuration register %#4.4x, DCR %4.4x.\n",\r\ninl(ioaddr + 0x2002), inw(ioaddr + 0x2000));\r\nerr = corkscrew_setup(dev, ioaddr, NULL, cards_found++);\r\nif (!err)\r\nreturn dev;\r\ncleanup_card(dev);\r\n}\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nstatic int corkscrew_setup(struct net_device *dev, int ioaddr,\r\nstruct pnp_dev *idev, int card_number)\r\n{\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\nunsigned int eeprom[0x40], checksum = 0;\r\nint i;\r\nint irq;\r\n#ifdef __ISAPNP__\r\nif (idev) {\r\nirq = pnp_irq(idev, 0);\r\nvp->dev = &idev->dev;\r\n} else {\r\nirq = inw(ioaddr + 0x2002) & 15;\r\n}\r\n#else\r\nirq = inw(ioaddr + 0x2002) & 15;\r\n#endif\r\ndev->base_addr = ioaddr;\r\ndev->irq = irq;\r\ndev->dma = inw(ioaddr + 0x2000) & 7;\r\nvp->product_name = "3c515";\r\nvp->options = dev->mem_start;\r\nvp->our_dev = dev;\r\nif (!vp->options) {\r\nif (card_number >= MAX_UNITS)\r\nvp->options = -1;\r\nelse\r\nvp->options = options[card_number];\r\n}\r\nif (vp->options >= 0) {\r\nvp->media_override = vp->options & 7;\r\nif (vp->media_override == 2)\r\nvp->media_override = 0;\r\nvp->full_duplex = (vp->options & 8) ? 1 : 0;\r\nvp->bus_master = (vp->options & 16) ? 1 : 0;\r\n} else {\r\nvp->media_override = 7;\r\nvp->full_duplex = 0;\r\nvp->bus_master = 0;\r\n}\r\n#ifdef MODULE\r\nlist_add(&vp->list, &root_corkscrew_dev);\r\n#endif\r\npr_info("%s: 3Com %s at %#3x,", dev->name, vp->product_name, ioaddr);\r\nspin_lock_init(&vp->lock);\r\nEL3WINDOW(0);\r\nfor (i = 0; i < 0x18; i++) {\r\n__be16 *phys_addr = (__be16 *) dev->dev_addr;\r\nint timer;\r\noutw(EEPROM_Read + i, ioaddr + Wn0EepromCmd);\r\nfor (timer = 4; timer >= 0; timer--) {\r\nudelay(162);\r\nif ((inw(ioaddr + Wn0EepromCmd) & 0x0200) == 0)\r\nbreak;\r\n}\r\neeprom[i] = inw(ioaddr + Wn0EepromData);\r\nchecksum ^= eeprom[i];\r\nif (i < 3)\r\nphys_addr[i] = htons(eeprom[i]);\r\n}\r\nchecksum = (checksum ^ (checksum >> 8)) & 0xff;\r\nif (checksum != 0x00)\r\npr_cont(" ***INVALID CHECKSUM %4.4x*** ", checksum);\r\npr_cont(" %pM", dev->dev_addr);\r\nif (eeprom[16] == 0x11c7) {\r\nif (request_dma(dev->dma, "3c515")) {\r\npr_cont(", DMA %d allocation failed", dev->dma);\r\ndev->dma = 0;\r\n} else\r\npr_cont(", DMA %d", dev->dma);\r\n}\r\npr_cont(", IRQ %d\n", dev->irq);\r\nif (corkscrew_debug && (dev->irq <= 0 || dev->irq > 15))\r\npr_warning(" *** Warning: this IRQ is unlikely to work! ***\n");\r\n{\r\nstatic const char * const ram_split[] = {\r\n"5:3", "3:1", "1:1", "3:5"\r\n};\r\n__u32 config;\r\nEL3WINDOW(3);\r\nvp->available_media = inw(ioaddr + Wn3_Options);\r\nconfig = inl(ioaddr + Wn3_Config);\r\nif (corkscrew_debug > 1)\r\npr_info(" Internal config register is %4.4x, transceivers %#x.\n",\r\nconfig, inw(ioaddr + Wn3_Options));\r\npr_info(" %dK %s-wide RAM %s Rx:Tx split, %s%s interface.\n",\r\n8 << config & Ram_size,\r\nconfig & Ram_width ? "word" : "byte",\r\nram_split[(config & Ram_split) >> Ram_split_shift],\r\nconfig & Autoselect ? "autoselect/" : "",\r\nmedia_tbl[(config & Xcvr) >> Xcvr_shift].name);\r\nvp->default_media = (config & Xcvr) >> Xcvr_shift;\r\nvp->autoselect = config & Autoselect ? 1 : 0;\r\ndev->if_port = vp->default_media;\r\n}\r\nif (vp->media_override != 7) {\r\npr_info(" Media override to transceiver type %d (%s).\n",\r\nvp->media_override,\r\nmedia_tbl[vp->media_override].name);\r\ndev->if_port = vp->media_override;\r\n}\r\nvp->capabilities = eeprom[16];\r\nvp->full_bus_master_tx = (vp->capabilities & 0x20) ? 1 : 0;\r\nvp->full_bus_master_rx = (vp->capabilities & 0x20) ? 1 : 0;\r\ndev->netdev_ops = &netdev_ops;\r\ndev->watchdog_timeo = (400 * HZ) / 1000;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\nreturn register_netdev(dev);\r\n}\r\nstatic int corkscrew_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\n__u32 config;\r\nint i;\r\nEL3WINDOW(3);\r\nif (vp->full_duplex)\r\noutb(0x20, ioaddr + Wn3_MAC_Ctrl);\r\nconfig = inl(ioaddr + Wn3_Config);\r\nif (vp->media_override != 7) {\r\nif (corkscrew_debug > 1)\r\npr_info("%s: Media override to transceiver %d (%s).\n",\r\ndev->name, vp->media_override,\r\nmedia_tbl[vp->media_override].name);\r\ndev->if_port = vp->media_override;\r\n} else if (vp->autoselect) {\r\ndev->if_port = 4;\r\nwhile (!(vp->available_media & media_tbl[dev->if_port].mask))\r\ndev->if_port = media_tbl[dev->if_port].next;\r\nif (corkscrew_debug > 1)\r\npr_debug("%s: Initial media type %s.\n",\r\ndev->name, media_tbl[dev->if_port].name);\r\ninit_timer(&vp->timer);\r\nvp->timer.expires = jiffies + media_tbl[dev->if_port].wait;\r\nvp->timer.data = (unsigned long) dev;\r\nvp->timer.function = corkscrew_timer;\r\nadd_timer(&vp->timer);\r\n} else\r\ndev->if_port = vp->default_media;\r\nconfig = (config & ~Xcvr) | (dev->if_port << Xcvr_shift);\r\noutl(config, ioaddr + Wn3_Config);\r\nif (corkscrew_debug > 1) {\r\npr_debug("%s: corkscrew_open() InternalConfig %8.8x.\n",\r\ndev->name, config);\r\n}\r\noutw(TxReset, ioaddr + EL3_CMD);\r\nfor (i = 20; i >= 0; i--)\r\nif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\r\nbreak;\r\noutw(RxReset, ioaddr + EL3_CMD);\r\nfor (i = 20; i >= 0; i--)\r\nif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\r\nbreak;\r\noutw(SetStatusEnb | 0x00, ioaddr + EL3_CMD);\r\nif (vp->capabilities == 0x11c7) {\r\nif (dev->irq == 0 ||\r\ndev->dma == 0 ||\r\nrequest_irq(dev->irq, corkscrew_interrupt, 0,\r\nvp->product_name, dev))\r\nreturn -EAGAIN;\r\nenable_dma(dev->dma);\r\nset_dma_mode(dev->dma, DMA_MODE_CASCADE);\r\n} else if (request_irq(dev->irq, corkscrew_interrupt, IRQF_SHARED,\r\nvp->product_name, dev)) {\r\nreturn -EAGAIN;\r\n}\r\nif (corkscrew_debug > 1) {\r\nEL3WINDOW(4);\r\npr_debug("%s: corkscrew_open() irq %d media status %4.4x.\n",\r\ndev->name, dev->irq, inw(ioaddr + Wn4_Media));\r\n}\r\nEL3WINDOW(2);\r\nfor (i = 0; i < 6; i++)\r\noutb(dev->dev_addr[i], ioaddr + i);\r\nfor (; i < 12; i += 2)\r\noutw(0, ioaddr + i);\r\nif (dev->if_port == 3)\r\noutw(StartCoax, ioaddr + EL3_CMD);\r\nEL3WINDOW(4);\r\noutw((inw(ioaddr + Wn4_Media) & ~(Media_10TP | Media_SQE)) |\r\nmedia_tbl[dev->if_port].media_bits, ioaddr + Wn4_Media);\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\nEL3WINDOW(6);\r\nfor (i = 0; i < 10; i++)\r\ninb(ioaddr + i);\r\ninw(ioaddr + 10);\r\ninw(ioaddr + 12);\r\nEL3WINDOW(4);\r\ninb(ioaddr + 12);\r\noutw(0x0040, ioaddr + Wn4_NetDiag);\r\nEL3WINDOW(7);\r\nif (vp->full_bus_master_rx) {\r\nvp->cur_rx = vp->dirty_rx = 0;\r\nif (corkscrew_debug > 2)\r\npr_debug("%s: Filling in the Rx ring.\n", dev->name);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nif (i < (RX_RING_SIZE - 1))\r\nvp->rx_ring[i].next =\r\nisa_virt_to_bus(&vp->rx_ring[i + 1]);\r\nelse\r\nvp->rx_ring[i].next = 0;\r\nvp->rx_ring[i].status = 0;\r\nvp->rx_ring[i].length = PKT_BUF_SZ | 0x80000000;\r\nskb = dev_alloc_skb(PKT_BUF_SZ);\r\nvp->rx_skbuff[i] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nskb->dev = dev;\r\nskb_reserve(skb, 2);\r\nvp->rx_ring[i].addr = isa_virt_to_bus(skb->data);\r\n}\r\nif (i != 0)\r\nvp->rx_ring[i - 1].next =\r\nisa_virt_to_bus(&vp->rx_ring[0]);\r\noutl(isa_virt_to_bus(&vp->rx_ring[0]), ioaddr + UpListPtr);\r\n}\r\nif (vp->full_bus_master_tx) {\r\nvp->cur_tx = vp->dirty_tx = 0;\r\noutb(PKT_BUF_SZ >> 8, ioaddr + TxFreeThreshold);\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\nvp->tx_skbuff[i] = NULL;\r\noutl(0, ioaddr + DownListPtr);\r\n}\r\nset_rx_mode(dev);\r\noutw(StatsEnable, ioaddr + EL3_CMD);\r\nnetif_start_queue(dev);\r\noutw(RxEnable, ioaddr + EL3_CMD);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\noutw(SetStatusEnb | AdapterFailure | IntReq | StatsFull |\r\n(vp->full_bus_master_tx ? DownComplete : TxAvailable) |\r\n(vp->full_bus_master_rx ? UpComplete : RxComplete) |\r\n(vp->bus_master ? DMADone : 0), ioaddr + EL3_CMD);\r\noutw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\r\nioaddr + EL3_CMD);\r\noutw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull\r\n| (vp->bus_master ? DMADone : 0) | UpComplete | DownComplete,\r\nioaddr + EL3_CMD);\r\nreturn 0;\r\n}\r\nstatic void corkscrew_timer(unsigned long data)\r\n{\r\n#ifdef AUTOMEDIA\r\nstruct net_device *dev = (struct net_device *) data;\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nint ok = 0;\r\nif (corkscrew_debug > 1)\r\npr_debug("%s: Media selection timer tick happened, %s.\n",\r\ndev->name, media_tbl[dev->if_port].name);\r\nspin_lock_irqsave(&vp->lock, flags);\r\n{\r\nint old_window = inw(ioaddr + EL3_CMD) >> 13;\r\nint media_status;\r\nEL3WINDOW(4);\r\nmedia_status = inw(ioaddr + Wn4_Media);\r\nswitch (dev->if_port) {\r\ncase 0:\r\ncase 4:\r\ncase 5:\r\nif (media_status & Media_LnkBeat) {\r\nok = 1;\r\nif (corkscrew_debug > 1)\r\npr_debug("%s: Media %s has link beat, %x.\n",\r\ndev->name,\r\nmedia_tbl[dev->if_port].name,\r\nmedia_status);\r\n} else if (corkscrew_debug > 1)\r\npr_debug("%s: Media %s is has no link beat, %x.\n",\r\ndev->name,\r\nmedia_tbl[dev->if_port].name,\r\nmedia_status);\r\nbreak;\r\ndefault:\r\nif (corkscrew_debug > 1)\r\npr_debug("%s: Media %s is has no indication, %x.\n",\r\ndev->name,\r\nmedia_tbl[dev->if_port].name,\r\nmedia_status);\r\nok = 1;\r\n}\r\nif (!ok) {\r\n__u32 config;\r\ndo {\r\ndev->if_port =\r\nmedia_tbl[dev->if_port].next;\r\n}\r\nwhile (!(vp->available_media & media_tbl[dev->if_port].mask));\r\nif (dev->if_port == 8) {\r\ndev->if_port = vp->default_media;\r\nif (corkscrew_debug > 1)\r\npr_debug("%s: Media selection failing, using default %s port.\n",\r\ndev->name,\r\nmedia_tbl[dev->if_port].name);\r\n} else {\r\nif (corkscrew_debug > 1)\r\npr_debug("%s: Media selection failed, now trying %s port.\n",\r\ndev->name,\r\nmedia_tbl[dev->if_port].name);\r\nvp->timer.expires = jiffies + media_tbl[dev->if_port].wait;\r\nadd_timer(&vp->timer);\r\n}\r\noutw((media_status & ~(Media_10TP | Media_SQE)) |\r\nmedia_tbl[dev->if_port].media_bits,\r\nioaddr + Wn4_Media);\r\nEL3WINDOW(3);\r\nconfig = inl(ioaddr + Wn3_Config);\r\nconfig = (config & ~Xcvr) | (dev->if_port << Xcvr_shift);\r\noutl(config, ioaddr + Wn3_Config);\r\noutw(dev->if_port == 3 ? StartCoax : StopCoax,\r\nioaddr + EL3_CMD);\r\n}\r\nEL3WINDOW(old_window);\r\n}\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\nif (corkscrew_debug > 1)\r\npr_debug("%s: Media selection timer finished, %s.\n",\r\ndev->name, media_tbl[dev->if_port].name);\r\n#endif\r\n}\r\nstatic void corkscrew_timeout(struct net_device *dev)\r\n{\r\nint i;\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\npr_warning("%s: transmit timed out, tx_status %2.2x status %4.4x.\n",\r\ndev->name, inb(ioaddr + TxStatus),\r\ninw(ioaddr + EL3_STATUS));\r\nif ((inb(ioaddr + TxStatus) & 0x88) == 0x88)\r\npr_warning("%s: Transmitter encountered 16 collisions --"\r\n" network cable problem?\n", dev->name);\r\n#ifndef final_version\r\npr_debug(" Flags; bus-master %d, full %d; dirty %d current %d.\n",\r\nvp->full_bus_master_tx, vp->tx_full, vp->dirty_tx,\r\nvp->cur_tx);\r\npr_debug(" Down list %8.8x vs. %p.\n", inl(ioaddr + DownListPtr),\r\n&vp->tx_ring[0]);\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\npr_debug(" %d: %p length %8.8x status %8.8x\n", i,\r\n&vp->tx_ring[i],\r\nvp->tx_ring[i].length, vp->tx_ring[i].status);\r\n}\r\n#endif\r\noutw(TxReset, ioaddr + EL3_CMD);\r\nfor (i = 20; i >= 0; i--)\r\nif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\r\nbreak;\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_dropped++;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t corkscrew_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nnetif_stop_queue(dev);\r\nif (vp->full_bus_master_tx) {\r\nint entry = vp->cur_tx % TX_RING_SIZE;\r\nstruct boom_tx_desc *prev_entry;\r\nunsigned long flags;\r\nint i;\r\nif (vp->tx_full)\r\nreturn NETDEV_TX_BUSY;\r\nif (vp->cur_tx != 0)\r\nprev_entry = &vp->tx_ring[(vp->cur_tx - 1) % TX_RING_SIZE];\r\nelse\r\nprev_entry = NULL;\r\nif (corkscrew_debug > 3)\r\npr_debug("%s: Trying to send a packet, Tx index %d.\n",\r\ndev->name, vp->cur_tx);\r\nvp->tx_skbuff[entry] = skb;\r\nvp->tx_ring[entry].next = 0;\r\nvp->tx_ring[entry].addr = isa_virt_to_bus(skb->data);\r\nvp->tx_ring[entry].length = skb->len | 0x80000000;\r\nvp->tx_ring[entry].status = skb->len | 0x80000000;\r\nspin_lock_irqsave(&vp->lock, flags);\r\noutw(DownStall, ioaddr + EL3_CMD);\r\nfor (i = 20; i >= 0; i--)\r\nif ((inw(ioaddr + EL3_STATUS) & CmdInProgress) == 0)\r\nbreak;\r\nif (prev_entry)\r\nprev_entry->next = isa_virt_to_bus(&vp->tx_ring[entry]);\r\nif (inl(ioaddr + DownListPtr) == 0) {\r\noutl(isa_virt_to_bus(&vp->tx_ring[entry]),\r\nioaddr + DownListPtr);\r\nqueued_packet++;\r\n}\r\noutw(DownUnstall, ioaddr + EL3_CMD);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\nvp->cur_tx++;\r\nif (vp->cur_tx - vp->dirty_tx > TX_RING_SIZE - 1)\r\nvp->tx_full = 1;\r\nelse {\r\nif (prev_entry)\r\nprev_entry->status &= ~0x80000000;\r\nnetif_wake_queue(dev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\noutl(skb->len, ioaddr + TX_FIFO);\r\ndev->stats.tx_bytes += skb->len;\r\n#ifdef VORTEX_BUS_MASTER\r\nif (vp->bus_master) {\r\noutl((int) (skb->data), ioaddr + Wn7_MasterAddr);\r\noutw((skb->len + 3) & ~3, ioaddr + Wn7_MasterLen);\r\nvp->tx_skb = skb;\r\noutw(StartDMADown, ioaddr + EL3_CMD);\r\n} else {\r\noutsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\r\ndev_kfree_skb(skb);\r\nif (inw(ioaddr + TxFree) > 1536) {\r\nnetif_wake_queue(dev);\r\n} else\r\noutw(SetTxThreshold + (1536 >> 2),\r\nioaddr + EL3_CMD);\r\n}\r\n#else\r\noutsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\r\ndev_kfree_skb(skb);\r\nif (inw(ioaddr + TxFree) > 1536) {\r\nnetif_wake_queue(dev);\r\n} else\r\noutw(SetTxThreshold + (1536 >> 2), ioaddr + EL3_CMD);\r\n#endif\r\n{\r\nshort tx_status;\r\nint i = 4;\r\nwhile (--i > 0 && (tx_status = inb(ioaddr + TxStatus)) > 0) {\r\nif (tx_status & 0x3C) {\r\nif (corkscrew_debug > 2)\r\npr_debug("%s: Tx error, status %2.2x.\n",\r\ndev->name, tx_status);\r\nif (tx_status & 0x04)\r\ndev->stats.tx_fifo_errors++;\r\nif (tx_status & 0x38)\r\ndev->stats.tx_aborted_errors++;\r\nif (tx_status & 0x30) {\r\nint j;\r\noutw(TxReset, ioaddr + EL3_CMD);\r\nfor (j = 20; j >= 0; j--)\r\nif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\r\nbreak;\r\n}\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\n}\r\noutb(0x00, ioaddr + TxStatus);\r\n}\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t corkscrew_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct corkscrew_private *lp = netdev_priv(dev);\r\nint ioaddr, status;\r\nint latency;\r\nint i = max_interrupt_work;\r\nioaddr = dev->base_addr;\r\nlatency = inb(ioaddr + Timer);\r\nspin_lock(&lp->lock);\r\nstatus = inw(ioaddr + EL3_STATUS);\r\nif (corkscrew_debug > 4)\r\npr_debug("%s: interrupt, status %4.4x, timer %d.\n",\r\ndev->name, status, latency);\r\nif ((status & 0xE000) != 0xE000) {\r\nstatic int donedidthis;\r\nif (donedidthis++ > 100) {\r\npr_err("%s: Bogus interrupt, bailing. Status %4.4x, start=%d.\n",\r\ndev->name, status, netif_running(dev));\r\nfree_irq(dev->irq, dev);\r\ndev->irq = -1;\r\n}\r\n}\r\ndo {\r\nif (corkscrew_debug > 5)\r\npr_debug("%s: In interrupt loop, status %4.4x.\n",\r\ndev->name, status);\r\nif (status & RxComplete)\r\ncorkscrew_rx(dev);\r\nif (status & TxAvailable) {\r\nif (corkscrew_debug > 5)\r\npr_debug(" TX room bit was handled.\n");\r\noutw(AckIntr | TxAvailable, ioaddr + EL3_CMD);\r\nnetif_wake_queue(dev);\r\n}\r\nif (status & DownComplete) {\r\nunsigned int dirty_tx = lp->dirty_tx;\r\nwhile (lp->cur_tx - dirty_tx > 0) {\r\nint entry = dirty_tx % TX_RING_SIZE;\r\nif (inl(ioaddr + DownListPtr) == isa_virt_to_bus(&lp->tx_ring[entry]))\r\nbreak;\r\nif (lp->tx_skbuff[entry]) {\r\ndev_kfree_skb_irq(lp->tx_skbuff[entry]);\r\nlp->tx_skbuff[entry] = NULL;\r\n}\r\ndirty_tx++;\r\n}\r\nlp->dirty_tx = dirty_tx;\r\noutw(AckIntr | DownComplete, ioaddr + EL3_CMD);\r\nif (lp->tx_full && (lp->cur_tx - dirty_tx <= TX_RING_SIZE - 1)) {\r\nlp->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\n#ifdef VORTEX_BUS_MASTER\r\nif (status & DMADone) {\r\noutw(0x1000, ioaddr + Wn7_MasterStatus);\r\ndev_kfree_skb_irq(lp->tx_skb);\r\nnetif_wake_queue(dev);\r\n}\r\n#endif\r\nif (status & UpComplete) {\r\nboomerang_rx(dev);\r\noutw(AckIntr | UpComplete, ioaddr + EL3_CMD);\r\n}\r\nif (status & (AdapterFailure | RxEarly | StatsFull)) {\r\nif (status & RxEarly) {\r\ncorkscrew_rx(dev);\r\noutw(AckIntr | RxEarly, ioaddr + EL3_CMD);\r\n}\r\nif (status & StatsFull) {\r\nstatic int DoneDidThat;\r\nif (corkscrew_debug > 4)\r\npr_debug("%s: Updating stats.\n", dev->name);\r\nupdate_stats(ioaddr, dev);\r\nif (DoneDidThat == 0 && inw(ioaddr + EL3_STATUS) & StatsFull) {\r\nint win, reg;\r\npr_notice("%s: Updating stats failed, disabling stats as an interrupt source.\n",\r\ndev->name);\r\nfor (win = 0; win < 8; win++) {\r\nEL3WINDOW(win);\r\npr_notice("Vortex window %d:", win);\r\nfor (reg = 0; reg < 16; reg++)\r\npr_cont(" %2.2x", inb(ioaddr + reg));\r\npr_cont("\n");\r\n}\r\nEL3WINDOW(7);\r\noutw(SetIntrEnb | TxAvailable |\r\nRxComplete | AdapterFailure |\r\nUpComplete | DownComplete |\r\nTxComplete, ioaddr + EL3_CMD);\r\nDoneDidThat++;\r\n}\r\n}\r\nif (status & AdapterFailure) {\r\noutw(RxReset, ioaddr + EL3_CMD);\r\nset_rx_mode(dev);\r\noutw(RxEnable, ioaddr + EL3_CMD);\r\noutw(AckIntr | AdapterFailure,\r\nioaddr + EL3_CMD);\r\n}\r\n}\r\nif (--i < 0) {\r\npr_err("%s: Too much work in interrupt, status %4.4x. Disabling functions (%4.4x).\n",\r\ndev->name, status, SetStatusEnb | ((~status) & 0x7FE));\r\noutw(SetStatusEnb | ((~status) & 0x7FE), ioaddr + EL3_CMD);\r\noutw(AckIntr | 0x7FF, ioaddr + EL3_CMD);\r\nbreak;\r\n}\r\noutw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\r\n} while ((status = inw(ioaddr + EL3_STATUS)) & (IntLatch | RxComplete));\r\nspin_unlock(&lp->lock);\r\nif (corkscrew_debug > 4)\r\npr_debug("%s: exiting interrupt, status %4.4x.\n", dev->name, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int corkscrew_rx(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint i;\r\nshort rx_status;\r\nif (corkscrew_debug > 5)\r\npr_debug(" In rx_packet(), status %4.4x, rx_status %4.4x.\n",\r\ninw(ioaddr + EL3_STATUS), inw(ioaddr + RxStatus));\r\nwhile ((rx_status = inw(ioaddr + RxStatus)) > 0) {\r\nif (rx_status & 0x4000) {\r\nunsigned char rx_error = inb(ioaddr + RxErrors);\r\nif (corkscrew_debug > 2)\r\npr_debug(" Rx error: status %2.2x.\n",\r\nrx_error);\r\ndev->stats.rx_errors++;\r\nif (rx_error & 0x01)\r\ndev->stats.rx_over_errors++;\r\nif (rx_error & 0x02)\r\ndev->stats.rx_length_errors++;\r\nif (rx_error & 0x04)\r\ndev->stats.rx_frame_errors++;\r\nif (rx_error & 0x08)\r\ndev->stats.rx_crc_errors++;\r\nif (rx_error & 0x10)\r\ndev->stats.rx_length_errors++;\r\n} else {\r\nshort pkt_len = rx_status & 0x1fff;\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(pkt_len + 5 + 2);\r\nif (corkscrew_debug > 4)\r\npr_debug("Receiving packet size %d status %4.4x.\n",\r\npkt_len, rx_status);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\ninsl(ioaddr + RX_FIFO,\r\nskb_put(skb, pkt_len),\r\n(pkt_len + 3) >> 2);\r\noutw(RxDiscard, ioaddr + EL3_CMD);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\nfor (i = 200; i >= 0; i--)\r\nif (! (inw(ioaddr + EL3_STATUS) & CmdInProgress))\r\nbreak;\r\ncontinue;\r\n} else if (corkscrew_debug)\r\npr_debug("%s: Couldn't allocate a sk_buff of size %d.\n", dev->name, pkt_len);\r\n}\r\noutw(RxDiscard, ioaddr + EL3_CMD);\r\ndev->stats.rx_dropped++;\r\nfor (i = 200; i >= 0; i--)\r\nif (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int boomerang_rx(struct net_device *dev)\r\n{\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\nint entry = vp->cur_rx % RX_RING_SIZE;\r\nint ioaddr = dev->base_addr;\r\nint rx_status;\r\nif (corkscrew_debug > 5)\r\npr_debug(" In boomerang_rx(), status %4.4x, rx_status %4.4x.\n",\r\ninw(ioaddr + EL3_STATUS), inw(ioaddr + RxStatus));\r\nwhile ((rx_status = vp->rx_ring[entry].status) & RxDComplete) {\r\nif (rx_status & RxDError) {\r\nunsigned char rx_error = rx_status >> 16;\r\nif (corkscrew_debug > 2)\r\npr_debug(" Rx error: status %2.2x.\n",\r\nrx_error);\r\ndev->stats.rx_errors++;\r\nif (rx_error & 0x01)\r\ndev->stats.rx_over_errors++;\r\nif (rx_error & 0x02)\r\ndev->stats.rx_length_errors++;\r\nif (rx_error & 0x04)\r\ndev->stats.rx_frame_errors++;\r\nif (rx_error & 0x08)\r\ndev->stats.rx_crc_errors++;\r\nif (rx_error & 0x10)\r\ndev->stats.rx_length_errors++;\r\n} else {\r\nshort pkt_len = rx_status & 0x1fff;\r\nstruct sk_buff *skb;\r\ndev->stats.rx_bytes += pkt_len;\r\nif (corkscrew_debug > 4)\r\npr_debug("Receiving packet size %d status %4.4x.\n",\r\npkt_len, rx_status);\r\nif (pkt_len < rx_copybreak &&\r\n(skb = dev_alloc_skb(pkt_len + 4)) != NULL) {\r\nskb_reserve(skb, 2);\r\nmemcpy(skb_put(skb, pkt_len),\r\nisa_bus_to_virt(vp->rx_ring[entry].\r\naddr), pkt_len);\r\nrx_copy++;\r\n} else {\r\nvoid *temp;\r\nskb = vp->rx_skbuff[entry];\r\nvp->rx_skbuff[entry] = NULL;\r\ntemp = skb_put(skb, pkt_len);\r\nif (isa_bus_to_virt(vp->rx_ring[entry].addr) != temp)\r\npr_warning("%s: Warning -- the skbuff addresses do not match"\r\n" in boomerang_rx: %p vs. %p / %p.\n",\r\ndev->name,\r\nisa_bus_to_virt(vp->\r\nrx_ring[entry].\r\naddr), skb->head,\r\ntemp);\r\nrx_nocopy++;\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nentry = (++vp->cur_rx) % RX_RING_SIZE;\r\n}\r\nfor (; vp->cur_rx - vp->dirty_rx > 0; vp->dirty_rx++) {\r\nstruct sk_buff *skb;\r\nentry = vp->dirty_rx % RX_RING_SIZE;\r\nif (vp->rx_skbuff[entry] == NULL) {\r\nskb = dev_alloc_skb(PKT_BUF_SZ);\r\nif (skb == NULL)\r\nbreak;\r\nskb->dev = dev;\r\nskb_reserve(skb, 2);\r\nvp->rx_ring[entry].addr = isa_virt_to_bus(skb->data);\r\nvp->rx_skbuff[entry] = skb;\r\n}\r\nvp->rx_ring[entry].status = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int corkscrew_close(struct net_device *dev)\r\n{\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nint i;\r\nnetif_stop_queue(dev);\r\nif (corkscrew_debug > 1) {\r\npr_debug("%s: corkscrew_close() status %4.4x, Tx status %2.2x.\n",\r\ndev->name, inw(ioaddr + EL3_STATUS),\r\ninb(ioaddr + TxStatus));\r\npr_debug("%s: corkscrew close stats: rx_nocopy %d rx_copy %d tx_queued %d.\n",\r\ndev->name, rx_nocopy, rx_copy, queued_packet);\r\n}\r\ndel_timer(&vp->timer);\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\noutw(RxDisable, ioaddr + EL3_CMD);\r\noutw(TxDisable, ioaddr + EL3_CMD);\r\nif (dev->if_port == XCVR_10base2)\r\noutw(StopCoax, ioaddr + EL3_CMD);\r\nfree_irq(dev->irq, dev);\r\noutw(SetIntrEnb | 0x0000, ioaddr + EL3_CMD);\r\nupdate_stats(ioaddr, dev);\r\nif (vp->full_bus_master_rx) {\r\noutl(0, ioaddr + UpListPtr);\r\nfor (i = 0; i < RX_RING_SIZE; i++)\r\nif (vp->rx_skbuff[i]) {\r\ndev_kfree_skb(vp->rx_skbuff[i]);\r\nvp->rx_skbuff[i] = NULL;\r\n}\r\n}\r\nif (vp->full_bus_master_tx) {\r\noutl(0, ioaddr + DownListPtr);\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\nif (vp->tx_skbuff[i]) {\r\ndev_kfree_skb(vp->tx_skbuff[i]);\r\nvp->tx_skbuff[i] = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *corkscrew_get_stats(struct net_device *dev)\r\n{\r\nstruct corkscrew_private *vp = netdev_priv(dev);\r\nunsigned long flags;\r\nif (netif_running(dev)) {\r\nspin_lock_irqsave(&vp->lock, flags);\r\nupdate_stats(dev->base_addr, dev);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void update_stats(int ioaddr, struct net_device *dev)\r\n{\r\nEL3WINDOW(6);\r\ndev->stats.tx_carrier_errors += inb(ioaddr + 0);\r\ndev->stats.tx_heartbeat_errors += inb(ioaddr + 1);\r\ninb(ioaddr + 2);\r\ndev->stats.collisions += inb(ioaddr + 3);\r\ndev->stats.tx_window_errors += inb(ioaddr + 4);\r\ndev->stats.rx_fifo_errors += inb(ioaddr + 5);\r\ndev->stats.tx_packets += inb(ioaddr + 6);\r\ndev->stats.tx_packets += (inb(ioaddr + 9) & 0x30) << 4;\r\ninb(ioaddr + 7);\r\ninb(ioaddr + 8);\r\ninw(ioaddr + 10);\r\ninw(ioaddr + 12);\r\nEL3WINDOW(4);\r\ninb(ioaddr + 12);\r\nEL3WINDOW(7);\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nshort new_mode;\r\nif (dev->flags & IFF_PROMISC) {\r\nif (corkscrew_debug > 3)\r\npr_debug("%s: Setting promiscuous mode.\n",\r\ndev->name);\r\nnew_mode = SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm;\r\n} else if (!netdev_mc_empty(dev) || dev->flags & IFF_ALLMULTI) {\r\nnew_mode = SetRxFilter | RxStation | RxMulticast | RxBroadcast;\r\n} else\r\nnew_mode = SetRxFilter | RxStation | RxBroadcast;\r\noutw(new_mode, ioaddr + EL3_CMD);\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->bus_info, "ISA 0x%lx", dev->base_addr);\r\n}\r\nstatic u32 netdev_get_msglevel(struct net_device *dev)\r\n{\r\nreturn corkscrew_debug;\r\n}\r\nstatic void netdev_set_msglevel(struct net_device *dev, u32 level)\r\n{\r\ncorkscrew_debug = level;\r\n}\r\nvoid cleanup_module(void)\r\n{\r\nwhile (!list_empty(&root_corkscrew_dev)) {\r\nstruct net_device *dev;\r\nstruct corkscrew_private *vp;\r\nvp = list_entry(root_corkscrew_dev.next,\r\nstruct corkscrew_private, list);\r\ndev = vp->our_dev;\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}
