static int ch341_control_out(struct usb_device *dev, u8 request,\r\nu16 value, u16 index)\r\n{\r\nint r;\r\ndbg("ch341_control_out(%02x,%02x,%04x,%04x)", USB_DIR_OUT|0x40,\r\n(int)request, (int)value, (int)index);\r\nr = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), request,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\nvalue, index, NULL, 0, DEFAULT_TIMEOUT);\r\nreturn r;\r\n}\r\nstatic int ch341_control_in(struct usb_device *dev,\r\nu8 request, u16 value, u16 index,\r\nchar *buf, unsigned bufsize)\r\n{\r\nint r;\r\ndbg("ch341_control_in(%02x,%02x,%04x,%04x,%p,%u)", USB_DIR_IN|0x40,\r\n(int)request, (int)value, (int)index, buf, (int)bufsize);\r\nr = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\nvalue, index, buf, bufsize, DEFAULT_TIMEOUT);\r\nreturn r;\r\n}\r\nstatic int ch341_set_baudrate(struct usb_device *dev,\r\nstruct ch341_private *priv)\r\n{\r\nshort a, b;\r\nint r;\r\nunsigned long factor;\r\nshort divisor;\r\ndbg("ch341_set_baudrate(%d)", priv->baud_rate);\r\nif (!priv->baud_rate)\r\nreturn -EINVAL;\r\nfactor = (CH341_BAUDBASE_FACTOR / priv->baud_rate);\r\ndivisor = CH341_BAUDBASE_DIVMAX;\r\nwhile ((factor > 0xfff0) && divisor) {\r\nfactor >>= 3;\r\ndivisor--;\r\n}\r\nif (factor > 0xfff0)\r\nreturn -EINVAL;\r\nfactor = 0x10000 - factor;\r\na = (factor & 0xff00) | divisor;\r\nb = factor & 0xff;\r\nr = ch341_control_out(dev, 0x9a, 0x1312, a);\r\nif (!r)\r\nr = ch341_control_out(dev, 0x9a, 0x0f2c, b);\r\nreturn r;\r\n}\r\nstatic int ch341_set_handshake(struct usb_device *dev, u8 control)\r\n{\r\ndbg("ch341_set_handshake(0x%02x)", control);\r\nreturn ch341_control_out(dev, 0xa4, ~control, 0);\r\n}\r\nstatic int ch341_get_status(struct usb_device *dev, struct ch341_private *priv)\r\n{\r\nchar *buffer;\r\nint r;\r\nconst unsigned size = 8;\r\nunsigned long flags;\r\ndbg("ch341_get_status()");\r\nbuffer = kmalloc(size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nr = ch341_control_in(dev, 0x95, 0x0706, 0, buffer, size);\r\nif (r < 0)\r\ngoto out;\r\nif (r == 2) {\r\nr = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->line_status = (~(*buffer)) & CH341_BITS_MODEM_STAT;\r\npriv->multi_status_change = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n} else\r\nr = -EPROTO;\r\nout: kfree(buffer);\r\nreturn r;\r\n}\r\nstatic int ch341_configure(struct usb_device *dev, struct ch341_private *priv)\r\n{\r\nchar *buffer;\r\nint r;\r\nconst unsigned size = 8;\r\ndbg("ch341_configure()");\r\nbuffer = kmalloc(size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nr = ch341_control_in(dev, 0x5f, 0, 0, buffer, size);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_control_out(dev, 0xa1, 0, 0);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_set_baudrate(dev, priv);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_control_in(dev, 0x95, 0x2518, 0, buffer, size);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_control_out(dev, 0x9a, 0x2518, 0x0050);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_get_status(dev, priv);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_control_out(dev, 0xa1, 0x501f, 0xd90a);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_set_baudrate(dev, priv);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_set_handshake(dev, priv->line_control);\r\nif (r < 0)\r\ngoto out;\r\nr = ch341_get_status(dev, priv);\r\nout: kfree(buffer);\r\nreturn r;\r\n}\r\nstatic int ch341_attach(struct usb_serial *serial)\r\n{\r\nstruct ch341_private *priv;\r\nint r;\r\ndbg("ch341_attach()");\r\npriv = kzalloc(sizeof(struct ch341_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\ninit_waitqueue_head(&priv->delta_msr_wait);\r\npriv->baud_rate = DEFAULT_BAUD_RATE;\r\npriv->line_control = CH341_BIT_RTS | CH341_BIT_DTR;\r\nr = ch341_configure(serial->dev, priv);\r\nif (r < 0)\r\ngoto error;\r\nusb_set_serial_port_data(serial->port[0], priv);\r\nreturn 0;\r\nerror: kfree(priv);\r\nreturn r;\r\n}\r\nstatic int ch341_carrier_raised(struct usb_serial_port *port)\r\n{\r\nstruct ch341_private *priv = usb_get_serial_port_data(port);\r\nif (priv->line_status & CH341_BIT_DCD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ch341_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct ch341_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (on)\r\npriv->line_control |= CH341_BIT_RTS | CH341_BIT_DTR;\r\nelse\r\npriv->line_control &= ~(CH341_BIT_RTS | CH341_BIT_DTR);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nch341_set_handshake(port->serial->dev, priv->line_control);\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\n}\r\nstatic void ch341_close(struct usb_serial_port *port)\r\n{\r\ndbg("%s - port %d", __func__, port->number);\r\nusb_serial_generic_close(port);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic int ch341_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct ch341_private *priv = usb_get_serial_port_data(serial->port[0]);\r\nint r;\r\ndbg("ch341_open()");\r\npriv->baud_rate = DEFAULT_BAUD_RATE;\r\nr = ch341_configure(serial->dev, priv);\r\nif (r)\r\ngoto out;\r\nr = ch341_set_handshake(serial->dev, priv->line_control);\r\nif (r)\r\ngoto out;\r\nr = ch341_set_baudrate(serial->dev, priv);\r\nif (r)\r\ngoto out;\r\ndbg("%s - submitting interrupt urb", __func__);\r\nport->interrupt_in_urb->dev = serial->dev;\r\nr = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (r) {\r\ndev_err(&port->dev, "%s - failed submitting interrupt urb,"\r\n" error %d\n", __func__, r);\r\nch341_close(port);\r\nreturn -EPROTO;\r\n}\r\nr = usb_serial_generic_open(tty, port);\r\nout: return r;\r\n}\r\nstatic void ch341_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct ch341_private *priv = usb_get_serial_port_data(port);\r\nunsigned baud_rate;\r\nunsigned long flags;\r\ndbg("ch341_set_termios()");\r\nbaud_rate = tty_get_baud_rate(tty);\r\npriv->baud_rate = baud_rate;\r\nif (baud_rate) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->line_control |= (CH341_BIT_DTR | CH341_BIT_RTS);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nch341_set_baudrate(port->serial->dev, priv);\r\n} else {\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->line_control &= ~(CH341_BIT_DTR | CH341_BIT_RTS);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nch341_set_handshake(port->serial->dev, priv->line_control);\r\n}\r\nstatic void ch341_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nconst uint16_t ch341_break_reg =\r\nCH341_REG_BREAK1 | ((uint16_t) CH341_REG_BREAK2 << 8);\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint r;\r\nuint16_t reg_contents;\r\nuint8_t *break_reg;\r\ndbg("%s()", __func__);\r\nbreak_reg = kmalloc(2, GFP_KERNEL);\r\nif (!break_reg) {\r\ndev_err(&port->dev, "%s - kmalloc failed\n", __func__);\r\nreturn;\r\n}\r\nr = ch341_control_in(port->serial->dev, CH341_REQ_READ_REG,\r\nch341_break_reg, 0, break_reg, 2);\r\nif (r < 0) {\r\ndev_err(&port->dev, "%s - USB control read error (%d)\n",\r\n__func__, r);\r\ngoto out;\r\n}\r\ndbg("%s - initial ch341 break register contents - reg1: %x, reg2: %x",\r\n__func__, break_reg[0], break_reg[1]);\r\nif (break_state != 0) {\r\ndbg("%s - Enter break state requested", __func__);\r\nbreak_reg[0] &= ~CH341_NBREAK_BITS_REG1;\r\nbreak_reg[1] &= ~CH341_NBREAK_BITS_REG2;\r\n} else {\r\ndbg("%s - Leave break state requested", __func__);\r\nbreak_reg[0] |= CH341_NBREAK_BITS_REG1;\r\nbreak_reg[1] |= CH341_NBREAK_BITS_REG2;\r\n}\r\ndbg("%s - New ch341 break register contents - reg1: %x, reg2: %x",\r\n__func__, break_reg[0], break_reg[1]);\r\nreg_contents = get_unaligned_le16(break_reg);\r\nr = ch341_control_out(port->serial->dev, CH341_REQ_WRITE_REG,\r\nch341_break_reg, reg_contents);\r\nif (r < 0)\r\ndev_err(&port->dev, "%s - USB control write error (%d)\n",\r\n__func__, r);\r\nout:\r\nkfree(break_reg);\r\n}\r\nstatic int ch341_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ch341_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (set & TIOCM_RTS)\r\npriv->line_control |= CH341_BIT_RTS;\r\nif (set & TIOCM_DTR)\r\npriv->line_control |= CH341_BIT_DTR;\r\nif (clear & TIOCM_RTS)\r\npriv->line_control &= ~CH341_BIT_RTS;\r\nif (clear & TIOCM_DTR)\r\npriv->line_control &= ~CH341_BIT_DTR;\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ch341_set_handshake(port->serial->dev, control);\r\n}\r\nstatic void ch341_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = (struct usb_serial_port *) urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned int actual_length = urb->actual_length;\r\nint status;\r\ndbg("%s (%d)", __func__, port->number);\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d", __func__,\r\nurb->status);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d", __func__,\r\nurb->status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(debug, &port->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\nif (actual_length >= 4) {\r\nstruct ch341_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 prev_line_status = priv->line_status;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->line_status = (~(data[2])) & CH341_BITS_MODEM_STAT;\r\nif ((data[1] & CH341_MULT_STAT))\r\npriv->multi_status_change = 1;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif ((priv->line_status ^ prev_line_status) & CH341_BIT_DCD) {\r\nstruct tty_struct *tty = tty_port_tty_get(&port->port);\r\nif (tty)\r\nusb_serial_handle_dcd_change(port, tty,\r\npriv->line_status & CH341_BIT_DCD);\r\ntty_kref_put(tty);\r\n}\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\n}\r\nexit:\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status)\r\ndev_err(&urb->dev->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, status);\r\n}\r\nstatic int wait_modem_info(struct usb_serial_port *port, unsigned int arg)\r\n{\r\nstruct ch341_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 prevstatus;\r\nu8 status;\r\nu8 changed;\r\nu8 multi_change = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nprevstatus = priv->line_status;\r\npriv->multi_status_change = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwhile (!multi_change) {\r\ninterruptible_sleep_on(&priv->delta_msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = priv->line_status;\r\nmulti_change = priv->multi_status_change;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nchanged = prevstatus ^ status;\r\nif (((arg & TIOCM_RNG) && (changed & CH341_BIT_RI)) ||\r\n((arg & TIOCM_DSR) && (changed & CH341_BIT_DSR)) ||\r\n((arg & TIOCM_CD) && (changed & CH341_BIT_DCD)) ||\r\n((arg & TIOCM_CTS) && (changed & CH341_BIT_CTS))) {\r\nreturn 0;\r\n}\r\nprevstatus = status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ch341_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndbg("%s (%d) cmd = 0x%04x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCMIWAIT:\r\ndbg("%s (%d) TIOCMIWAIT", __func__, port->number);\r\nreturn wait_modem_info(port, arg);\r\ndefault:\r\ndbg("%s not supported = 0x%04x", __func__, cmd);\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int ch341_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ch341_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 mcr;\r\nu8 status;\r\nunsigned int result;\r\ndbg("%s (%d)", __func__, port->number);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nmcr = priv->line_control;\r\nstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nresult = ((mcr & CH341_BIT_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & CH341_BIT_RTS) ? TIOCM_RTS : 0)\r\n| ((status & CH341_BIT_CTS) ? TIOCM_CTS : 0)\r\n| ((status & CH341_BIT_DSR) ? TIOCM_DSR : 0)\r\n| ((status & CH341_BIT_RI) ? TIOCM_RI : 0)\r\n| ((status & CH341_BIT_DCD) ? TIOCM_CD : 0);\r\ndbg("%s - result = %x", __func__, result);\r\nreturn result;\r\n}\r\nstatic int ch341_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct usb_serial *serial = NULL;\r\nstruct ch341_private *priv;\r\nserial = usb_get_intfdata(intf);\r\npriv = usb_get_serial_port_data(serial->port[0]);\r\nch341_configure(dev, priv);\r\nusb_serial_resume(intf);\r\nreturn 0;\r\n}\r\nstatic int __init ch341_init(void)\r\n{\r\nint retval;\r\nretval = usb_serial_register(&ch341_device);\r\nif (retval)\r\nreturn retval;\r\nretval = usb_register(&ch341_driver);\r\nif (retval)\r\nusb_serial_deregister(&ch341_device);\r\nreturn retval;\r\n}\r\nstatic void __exit ch341_exit(void)\r\n{\r\nusb_deregister(&ch341_driver);\r\nusb_serial_deregister(&ch341_device);\r\n}
