int\r\nnv04_pm_clock_get(struct drm_device *dev, u32 id)\r\n{\r\nreturn nouveau_hw_get_clock(dev, id);\r\n}\r\nvoid *\r\nnv04_pm_clock_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl,\r\nu32 id, int khz)\r\n{\r\nstruct nv04_pm_state *state;\r\nint ret;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = get_pll_limits(dev, id, &state->pll);\r\nif (ret) {\r\nkfree(state);\r\nreturn (ret == -ENOENT) ? NULL : ERR_PTR(ret);\r\n}\r\nret = nouveau_calc_pll_mnp(dev, &state->pll, khz, &state->calc);\r\nif (!ret) {\r\nkfree(state);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn state;\r\n}\r\nvoid\r\nnv04_pm_clock_set(struct drm_device *dev, void *pre_state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_pm_state *state = pre_state;\r\nu32 reg = state->pll.reg;\r\nif (dev_priv->card_type >= NV_40)\r\nreg += 4;\r\nnouveau_hw_setpll(dev, reg, &state->calc);\r\nif (dev_priv->card_type < NV_30 && reg == NV_PRAMDAC_MPLL_COEFF) {\r\nif (dev_priv->card_type == NV_20)\r\nnv_mask(dev, 0x1002c4, 0, 1 << 20);\r\nnv_mask(dev, 0x1002c0, 0, 1 << 8);\r\n}\r\nkfree(state);\r\n}
