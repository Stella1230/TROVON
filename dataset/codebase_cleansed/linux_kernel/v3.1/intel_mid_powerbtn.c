static irqreturn_t mfld_pb_isr(int irq, void *dev_id)\r\n{\r\nstruct input_dev *input = dev_id;\r\nint ret;\r\nu8 pbstat;\r\nret = intel_scu_ipc_ioread8(MSIC_PB_STATUS, &pbstat);\r\nif (ret < 0) {\r\ndev_err(input->dev.parent, "Read error %d while reading"\r\n" MSIC_PB_STATUS\n", ret);\r\n} else {\r\ninput_event(input, EV_KEY, KEY_POWER,\r\n!(pbstat & MSIC_PB_LEVEL));\r\ninput_sync(input);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit mfld_pb_probe(struct platform_device *pdev)\r\n{\r\nstruct input_dev *input;\r\nint irq = platform_get_irq(pdev, 0);\r\nint error;\r\nif (irq < 0)\r\nreturn -EINVAL;\r\ninput = input_allocate_device();\r\nif (!input) {\r\ndev_err(&pdev->dev, "Input device allocation error\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = pdev->name;\r\ninput->phys = "power-button/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &pdev->dev;\r\ninput_set_capability(input, EV_KEY, KEY_POWER);\r\nerror = request_threaded_irq(irq, NULL, mfld_pb_isr, 0,\r\nDRIVER_NAME, input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Unable to request irq %d for mfld power"\r\n"button\n", irq);\r\ngoto err_free_input;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Unable to register input dev, error "\r\n"%d\n", error);\r\ngoto err_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, input);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq, input);\r\nerr_free_input:\r\ninput_free_device(input);\r\nreturn error;\r\n}\r\nstatic int __devexit mfld_pb_remove(struct platform_device *pdev)\r\n{\r\nstruct input_dev *input = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nfree_irq(irq, input);\r\ninput_unregister_device(input);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init mfld_pb_init(void)\r\n{\r\nreturn platform_driver_register(&mfld_pb_driver);\r\n}\r\nstatic void __exit mfld_pb_exit(void)\r\n{\r\nplatform_driver_unregister(&mfld_pb_driver);\r\n}
