static int pn_socket_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk) {\r\nsock->sk = NULL;\r\nsk->sk_prot->close(sk, 0);\r\n}\r\nreturn 0;\r\n}\r\nvoid __init pn_sock_init(void)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < PN_HASHSIZE; i++)\r\nINIT_HLIST_HEAD(pnsocks.hlist + i);\r\nmutex_init(&pnsocks.lock);\r\n}\r\nstatic struct hlist_head *pn_hash_list(u16 obj)\r\n{\r\nreturn pnsocks.hlist + (obj & PN_HASHMASK);\r\n}\r\nstruct sock *pn_find_sock_by_sa(struct net *net, const struct sockaddr_pn *spn)\r\n{\r\nstruct hlist_node *node;\r\nstruct sock *sknode;\r\nstruct sock *rval = NULL;\r\nu16 obj = pn_sockaddr_get_object(spn);\r\nu8 res = spn->spn_resource;\r\nstruct hlist_head *hlist = pn_hash_list(obj);\r\nrcu_read_lock();\r\nsk_for_each_rcu(sknode, node, hlist) {\r\nstruct pn_sock *pn = pn_sk(sknode);\r\nBUG_ON(!pn->sobject);\r\nif (!net_eq(sock_net(sknode), net))\r\ncontinue;\r\nif (pn_port(obj)) {\r\nif (pn_port(pn->sobject) != pn_port(obj))\r\ncontinue;\r\n} else {\r\nif (pn->resource != res)\r\ncontinue;\r\n}\r\nif (pn_addr(pn->sobject) &&\r\npn_addr(pn->sobject) != pn_addr(obj))\r\ncontinue;\r\nrval = sknode;\r\nsock_hold(sknode);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn rval;\r\n}\r\nvoid pn_deliver_sock_broadcast(struct net *net, struct sk_buff *skb)\r\n{\r\nstruct hlist_head *hlist = pnsocks.hlist;\r\nunsigned h;\r\nrcu_read_lock();\r\nfor (h = 0; h < PN_HASHSIZE; h++) {\r\nstruct hlist_node *node;\r\nstruct sock *sknode;\r\nsk_for_each(sknode, node, hlist) {\r\nstruct sk_buff *clone;\r\nif (!net_eq(sock_net(sknode), net))\r\ncontinue;\r\nif (!sock_flag(sknode, SOCK_BROADCAST))\r\ncontinue;\r\nclone = skb_clone(skb, GFP_ATOMIC);\r\nif (clone) {\r\nsock_hold(sknode);\r\nsk_receive_skb(sknode, clone, 0);\r\n}\r\n}\r\nhlist++;\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid pn_sock_hash(struct sock *sk)\r\n{\r\nstruct hlist_head *hlist = pn_hash_list(pn_sk(sk)->sobject);\r\nmutex_lock(&pnsocks.lock);\r\nsk_add_node_rcu(sk, hlist);\r\nmutex_unlock(&pnsocks.lock);\r\n}\r\nvoid pn_sock_unhash(struct sock *sk)\r\n{\r\nmutex_lock(&pnsocks.lock);\r\nsk_del_node_init_rcu(sk);\r\nmutex_unlock(&pnsocks.lock);\r\npn_sock_unbind_all_res(sk);\r\nsynchronize_rcu();\r\n}\r\nstatic int pn_socket_bind(struct socket *sock, struct sockaddr *addr, int len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct pn_sock *pn = pn_sk(sk);\r\nstruct sockaddr_pn *spn = (struct sockaddr_pn *)addr;\r\nint err;\r\nu16 handle;\r\nu8 saddr;\r\nif (sk->sk_prot->bind)\r\nreturn sk->sk_prot->bind(sk, addr, len);\r\nif (len < sizeof(struct sockaddr_pn))\r\nreturn -EINVAL;\r\nif (spn->spn_family != AF_PHONET)\r\nreturn -EAFNOSUPPORT;\r\nhandle = pn_sockaddr_get_object((struct sockaddr_pn *)addr);\r\nsaddr = pn_addr(handle);\r\nif (saddr && phonet_address_lookup(sock_net(sk), saddr))\r\nreturn -EADDRNOTAVAIL;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_CLOSE || pn_port(pn->sobject)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nWARN_ON(sk_hashed(sk));\r\nmutex_lock(&port_mutex);\r\nerr = sk->sk_prot->get_port(sk, pn_port(handle));\r\nif (err)\r\ngoto out_port;\r\npn->sobject = pn_object(saddr, pn_port(pn->sobject));\r\npn->resource = spn->spn_resource;\r\nsk->sk_prot->hash(sk);\r\nout_port:\r\nmutex_unlock(&port_mutex);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int pn_socket_autobind(struct socket *sock)\r\n{\r\nstruct sockaddr_pn sa;\r\nint err;\r\nmemset(&sa, 0, sizeof(sa));\r\nsa.spn_family = AF_PHONET;\r\nerr = pn_socket_bind(sock, (struct sockaddr *)&sa,\r\nsizeof(struct sockaddr_pn));\r\nif (err != -EINVAL)\r\nreturn err;\r\nBUG_ON(!pn_port(pn_sk(sock->sk)->sobject));\r\nreturn 0;\r\n}\r\nstatic int pn_socket_connect(struct socket *sock, struct sockaddr *addr,\r\nint len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct pn_sock *pn = pn_sk(sk);\r\nstruct sockaddr_pn *spn = (struct sockaddr_pn *)addr;\r\nstruct task_struct *tsk = current;\r\nlong timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\r\nint err;\r\nif (pn_socket_autobind(sock))\r\nreturn -ENOBUFS;\r\nif (len < sizeof(struct sockaddr_pn))\r\nreturn -EINVAL;\r\nif (spn->spn_family != AF_PHONET)\r\nreturn -EAFNOSUPPORT;\r\nlock_sock(sk);\r\nswitch (sock->state) {\r\ncase SS_UNCONNECTED:\r\nif (sk->sk_state != TCP_CLOSE) {\r\nerr = -EISCONN;\r\ngoto out;\r\n}\r\nbreak;\r\ncase SS_CONNECTING:\r\nerr = -EALREADY;\r\ngoto out;\r\ndefault:\r\nerr = -EISCONN;\r\ngoto out;\r\n}\r\npn->dobject = pn_sockaddr_get_object(spn);\r\npn->resource = pn_sockaddr_get_resource(spn);\r\nsock->state = SS_CONNECTING;\r\nerr = sk->sk_prot->connect(sk, addr, len);\r\nif (err) {\r\nsock->state = SS_UNCONNECTED;\r\npn->dobject = 0;\r\ngoto out;\r\n}\r\nwhile (sk->sk_state == TCP_SYN_SENT) {\r\nDEFINE_WAIT(wait);\r\nif (!timeo) {\r\nerr = -EINPROGRESS;\r\ngoto out;\r\n}\r\nif (signal_pending(tsk)) {\r\nerr = sock_intr_errno(timeo);\r\ngoto out;\r\n}\r\nprepare_to_wait_exclusive(sk_sleep(sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock(sk);\r\nfinish_wait(sk_sleep(sk), &wait);\r\n}\r\nif ((1 << sk->sk_state) & (TCPF_SYN_RECV|TCPF_ESTABLISHED))\r\nerr = 0;\r\nelse if (sk->sk_state == TCP_CLOSE_WAIT)\r\nerr = -ECONNRESET;\r\nelse\r\nerr = -ECONNREFUSED;\r\nsock->state = err ? SS_UNCONNECTED : SS_CONNECTED;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int pn_socket_accept(struct socket *sock, struct socket *newsock,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sock *newsk;\r\nint err;\r\nif (unlikely(sk->sk_state != TCP_LISTEN))\r\nreturn -EINVAL;\r\nnewsk = sk->sk_prot->accept(sk, flags, &err);\r\nif (!newsk)\r\nreturn err;\r\nlock_sock(newsk);\r\nsock_graft(newsk, newsock);\r\nnewsock->state = SS_CONNECTED;\r\nrelease_sock(newsk);\r\nreturn 0;\r\n}\r\nstatic int pn_socket_getname(struct socket *sock, struct sockaddr *addr,\r\nint *sockaddr_len, int peer)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct pn_sock *pn = pn_sk(sk);\r\nmemset(addr, 0, sizeof(struct sockaddr_pn));\r\naddr->sa_family = AF_PHONET;\r\nif (!peer)\r\npn_sockaddr_set_object((struct sockaddr_pn *)addr,\r\npn->sobject);\r\n*sockaddr_len = sizeof(struct sockaddr_pn);\r\nreturn 0;\r\n}\r\nstatic unsigned int pn_socket_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct pep_sock *pn = pep_sk(sk);\r\nunsigned int mask = 0;\r\npoll_wait(file, sk_sleep(sk), wait);\r\nif (sk->sk_state == TCP_CLOSE)\r\nreturn POLLERR;\r\nif (!skb_queue_empty(&sk->sk_receive_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (!skb_queue_empty(&pn->ctrlreq_queue))\r\nmask |= POLLPRI;\r\nif (!mask && sk->sk_state == TCP_CLOSE_WAIT)\r\nreturn POLLHUP;\r\nif (sk->sk_state == TCP_ESTABLISHED &&\r\natomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf &&\r\natomic_read(&pn->tx_credits))\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nreturn mask;\r\n}\r\nstatic int pn_socket_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct pn_sock *pn = pn_sk(sk);\r\nif (cmd == SIOCPNGETOBJECT) {\r\nstruct net_device *dev;\r\nu16 handle;\r\nu8 saddr;\r\nif (get_user(handle, (__u16 __user *)arg))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nif (sk->sk_bound_dev_if)\r\ndev = dev_get_by_index(sock_net(sk),\r\nsk->sk_bound_dev_if);\r\nelse\r\ndev = phonet_device_get(sock_net(sk));\r\nif (dev && (dev->flags & IFF_UP))\r\nsaddr = phonet_address_get(dev, pn_addr(handle));\r\nelse\r\nsaddr = PN_NO_ADDR;\r\nrelease_sock(sk);\r\nif (dev)\r\ndev_put(dev);\r\nif (saddr == PN_NO_ADDR)\r\nreturn -EHOSTUNREACH;\r\nhandle = pn_object(saddr, pn_port(pn->sobject));\r\nreturn put_user(handle, (__u16 __user *)arg);\r\n}\r\nreturn sk->sk_prot->ioctl(sk, cmd, arg);\r\n}\r\nstatic int pn_socket_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nif (pn_socket_autobind(sock))\r\nreturn -ENOBUFS;\r\nlock_sock(sk);\r\nif (sock->state != SS_UNCONNECTED) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (sk->sk_state != TCP_LISTEN) {\r\nsk->sk_state = TCP_LISTEN;\r\nsk->sk_ack_backlog = 0;\r\n}\r\nsk->sk_max_ack_backlog = backlog;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int pn_socket_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *m, size_t total_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (pn_socket_autobind(sock))\r\nreturn -EAGAIN;\r\nreturn sk->sk_prot->sendmsg(iocb, sk, m, total_len);\r\n}\r\nint pn_sock_get_port(struct sock *sk, unsigned short sport)\r\n{\r\nstatic int port_cur;\r\nstruct net *net = sock_net(sk);\r\nstruct pn_sock *pn = pn_sk(sk);\r\nstruct sockaddr_pn try_sa;\r\nstruct sock *tmpsk;\r\nmemset(&try_sa, 0, sizeof(struct sockaddr_pn));\r\ntry_sa.spn_family = AF_PHONET;\r\nWARN_ON(!mutex_is_locked(&port_mutex));\r\nif (!sport) {\r\nint port, pmin, pmax;\r\nphonet_get_local_port_range(&pmin, &pmax);\r\nfor (port = pmin; port <= pmax; port++) {\r\nport_cur++;\r\nif (port_cur < pmin || port_cur > pmax)\r\nport_cur = pmin;\r\npn_sockaddr_set_port(&try_sa, port_cur);\r\ntmpsk = pn_find_sock_by_sa(net, &try_sa);\r\nif (tmpsk == NULL) {\r\nsport = port_cur;\r\ngoto found;\r\n} else\r\nsock_put(tmpsk);\r\n}\r\n} else {\r\npn_sockaddr_set_port(&try_sa, sport);\r\ntmpsk = pn_find_sock_by_sa(net, &try_sa);\r\nif (tmpsk == NULL)\r\ngoto found;\r\nelse\r\nsock_put(tmpsk);\r\n}\r\nreturn -EADDRINUSE;\r\nfound:\r\npn->sobject = pn_object(pn_addr(pn->sobject), sport);\r\nreturn 0;\r\n}\r\nstatic struct sock *pn_sock_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct hlist_head *hlist = pnsocks.hlist;\r\nstruct hlist_node *node;\r\nstruct sock *sknode;\r\nunsigned h;\r\nfor (h = 0; h < PN_HASHSIZE; h++) {\r\nsk_for_each_rcu(sknode, node, hlist) {\r\nif (!net_eq(net, sock_net(sknode)))\r\ncontinue;\r\nif (!pos)\r\nreturn sknode;\r\npos--;\r\n}\r\nhlist++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sock *pn_sock_get_next(struct seq_file *seq, struct sock *sk)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\ndo\r\nsk = sk_next(sk);\r\nwhile (sk && !net_eq(net, sock_net(sk)));\r\nreturn sk;\r\n}\r\nstatic void *pn_sock_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rcu)\r\n{\r\nrcu_read_lock();\r\nreturn *pos ? pn_sock_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *pn_sock_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct sock *sk;\r\nif (v == SEQ_START_TOKEN)\r\nsk = pn_sock_get_idx(seq, 0);\r\nelse\r\nsk = pn_sock_get_next(seq, v);\r\n(*pos)++;\r\nreturn sk;\r\n}\r\nstatic void pn_sock_seq_stop(struct seq_file *seq, void *v)\r\n__releases(rcu)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int pn_sock_seq_show(struct seq_file *seq, void *v)\r\n{\r\nint len;\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(seq, "%s%n", "pt loc rem rs st tx_queue rx_queue "\r\n" uid inode ref pointer drops", &len);\r\nelse {\r\nstruct sock *sk = v;\r\nstruct pn_sock *pn = pn_sk(sk);\r\nseq_printf(seq, "%2d %04X:%04X:%02X %02X %08X:%08X %5d %lu "\r\n"%d %pK %d%n",\r\nsk->sk_protocol, pn->sobject, pn->dobject,\r\npn->resource, sk->sk_state,\r\nsk_wmem_alloc_get(sk), sk_rmem_alloc_get(sk),\r\nsock_i_uid(sk), sock_i_ino(sk),\r\natomic_read(&sk->sk_refcnt), sk,\r\natomic_read(&sk->sk_drops), &len);\r\n}\r\nseq_printf(seq, "%*s\n", 127 - len, "");\r\nreturn 0;\r\n}\r\nstatic int pn_sock_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &pn_sock_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstruct sock *pn_find_sock_by_res(struct net *net, u8 res)\r\n{\r\nstruct sock *sk;\r\nif (!net_eq(net, &init_net))\r\nreturn NULL;\r\nrcu_read_lock();\r\nsk = rcu_dereference(pnres.sk[res]);\r\nif (sk)\r\nsock_hold(sk);\r\nrcu_read_unlock();\r\nreturn sk;\r\n}\r\nint pn_sock_bind_res(struct sock *sk, u8 res)\r\n{\r\nint ret = -EADDRINUSE;\r\nif (!net_eq(sock_net(sk), &init_net))\r\nreturn -ENOIOCTLCMD;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (pn_socket_autobind(sk->sk_socket))\r\nreturn -EAGAIN;\r\nmutex_lock(&resource_mutex);\r\nif (pnres.sk[res] == NULL) {\r\nsock_hold(sk);\r\nrcu_assign_pointer(pnres.sk[res], sk);\r\nret = 0;\r\n}\r\nmutex_unlock(&resource_mutex);\r\nreturn ret;\r\n}\r\nint pn_sock_unbind_res(struct sock *sk, u8 res)\r\n{\r\nint ret = -ENOENT;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nmutex_lock(&resource_mutex);\r\nif (pnres.sk[res] == sk) {\r\nrcu_assign_pointer(pnres.sk[res], NULL);\r\nret = 0;\r\n}\r\nmutex_unlock(&resource_mutex);\r\nif (ret == 0) {\r\nsynchronize_rcu();\r\nsock_put(sk);\r\n}\r\nreturn ret;\r\n}\r\nvoid pn_sock_unbind_all_res(struct sock *sk)\r\n{\r\nunsigned res, match = 0;\r\nmutex_lock(&resource_mutex);\r\nfor (res = 0; res < 256; res++) {\r\nif (pnres.sk[res] == sk) {\r\nrcu_assign_pointer(pnres.sk[res], NULL);\r\nmatch++;\r\n}\r\n}\r\nmutex_unlock(&resource_mutex);\r\nwhile (match > 0) {\r\n__sock_put(sk);\r\nmatch--;\r\n}\r\n}\r\nstatic struct sock **pn_res_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nunsigned i;\r\nif (!net_eq(net, &init_net))\r\nreturn NULL;\r\nfor (i = 0; i < 256; i++) {\r\nif (pnres.sk[i] == NULL)\r\ncontinue;\r\nif (!pos)\r\nreturn pnres.sk + i;\r\npos--;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sock **pn_res_get_next(struct seq_file *seq, struct sock **sk)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nunsigned i;\r\nBUG_ON(!net_eq(net, &init_net));\r\nfor (i = (sk - pnres.sk) + 1; i < 256; i++)\r\nif (pnres.sk[i])\r\nreturn pnres.sk + i;\r\nreturn NULL;\r\n}\r\nstatic void *pn_res_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(resource_mutex)\r\n{\r\nmutex_lock(&resource_mutex);\r\nreturn *pos ? pn_res_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *pn_res_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct sock **sk;\r\nif (v == SEQ_START_TOKEN)\r\nsk = pn_res_get_idx(seq, 0);\r\nelse\r\nsk = pn_res_get_next(seq, v);\r\n(*pos)++;\r\nreturn sk;\r\n}\r\nstatic void pn_res_seq_stop(struct seq_file *seq, void *v)\r\n__releases(resource_mutex)\r\n{\r\nmutex_unlock(&resource_mutex);\r\n}\r\nstatic int pn_res_seq_show(struct seq_file *seq, void *v)\r\n{\r\nint len;\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(seq, "%s%n", "rs uid inode", &len);\r\nelse {\r\nstruct sock **psk = v;\r\nstruct sock *sk = *psk;\r\nseq_printf(seq, "%02X %5d %lu%n",\r\n(int) (psk - pnres.sk), sock_i_uid(sk),\r\nsock_i_ino(sk), &len);\r\n}\r\nseq_printf(seq, "%*s\n", 63 - len, "");\r\nreturn 0;\r\n}\r\nstatic int pn_res_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &pn_res_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}
