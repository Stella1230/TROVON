static int proc_viotape_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nseq_printf(m, "viotape driver version " VIOTAPE_VERSION "\n");\r\nfor (i = 0; i < viotape_numdev; i++) {\r\nseq_printf(m, "viotape device %d is iSeries resource %10.10s"\r\n"type %4.4s, model %3.3s\n",\r\ni, viotape_unitinfo[i].rsrcname,\r\nviotape_unitinfo[i].type,\r\nviotape_unitinfo[i].model);\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_viotape_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_viotape_show, NULL);\r\n}\r\nvoid get_dev_info(struct inode *ino, struct viot_devinfo_struct *devi)\r\n{\r\ndevi->devno = iminor(ino) & 0x1F;\r\ndevi->mode = (iminor(ino) & 0x60) >> 5;\r\ndevi->rewind = (iminor(ino) & 0x80) == 0;\r\n}\r\nstatic void clear_op_struct_pool(void)\r\n{\r\nwhile (op_struct_list) {\r\nstruct op_struct *toFree = op_struct_list;\r\nop_struct_list = op_struct_list->next;\r\nkfree(toFree);\r\n}\r\n}\r\nstatic int add_op_structs(int structs)\r\n{\r\nint i;\r\nfor (i = 0; i < structs; ++i) {\r\nstruct op_struct *new_struct =\r\nkmalloc(sizeof(*new_struct), GFP_KERNEL);\r\nif (!new_struct) {\r\nclear_op_struct_pool();\r\nreturn -ENOMEM;\r\n}\r\nnew_struct->next = op_struct_list;\r\nop_struct_list = new_struct;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct op_struct *get_op_struct(void)\r\n{\r\nstruct op_struct *retval;\r\nunsigned long flags;\r\nspin_lock_irqsave(&op_struct_list_lock, flags);\r\nretval = op_struct_list;\r\nif (retval)\r\nop_struct_list = retval->next;\r\nspin_unlock_irqrestore(&op_struct_list_lock, flags);\r\nif (retval) {\r\nmemset(retval, 0, sizeof(*retval));\r\ninit_completion(&retval->com);\r\n}\r\nreturn retval;\r\n}\r\nstatic void free_op_struct(struct op_struct *op_struct)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&op_struct_list_lock, flags);\r\nop_struct->next = op_struct_list;\r\nop_struct_list = op_struct;\r\nspin_unlock_irqrestore(&op_struct_list_lock, flags);\r\n}\r\nint tape_rc_to_errno(int tape_rc, char *operation, int tapeno)\r\n{\r\nconst struct vio_error_entry *err;\r\nif (tape_rc == 0)\r\nreturn 0;\r\nerr = vio_lookup_rc(viotape_err_table, tape_rc);\r\nprintk(VIOTAPE_KERN_WARN "error(%s) 0x%04x on Device %d (%-10s): %s\n",\r\noperation, tape_rc, tapeno,\r\nviotape_unitinfo[tapeno].rsrcname, err->msg);\r\nreturn -err->errno;\r\n}\r\nstatic ssize_t viotap_write(struct file *file, const char *buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nunsigned short flags = file->f_flags;\r\nint noblock = ((flags & O_NONBLOCK) != 0);\r\nssize_t ret;\r\nstruct viot_devinfo_struct devi;\r\nstruct op_struct *op = get_op_struct();\r\nif (op == NULL)\r\nreturn -ENOMEM;\r\nget_dev_info(file->f_path.dentry->d_inode, &devi);\r\nif (noblock) {\r\nif (down_trylock(&reqSem)) {\r\nret = -EWOULDBLOCK;\r\ngoto free_op;\r\n}\r\n} else\r\ndown(&reqSem);\r\nop->dev = tape_device[devi.devno];\r\nop->buffer = dma_alloc_coherent(op->dev, count, &op->dmaaddr,\r\nGFP_ATOMIC);\r\nif (op->buffer == NULL) {\r\nprintk(VIOTAPE_KERN_WARN\r\n"error allocating dma buffer for len %ld\n",\r\ncount);\r\nret = -EFAULT;\r\ngoto up_sem;\r\n}\r\nif (copy_from_user(op->buffer, buf, count)) {\r\nprintk(VIOTAPE_KERN_WARN "tape: error on copy from user\n");\r\nret = -EFAULT;\r\ngoto free_dma;\r\n}\r\nop->non_blocking = noblock;\r\ninit_completion(&op->com);\r\nop->count = count;\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_tape | viotapewrite,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)op, VIOVERSION << 16,\r\n((u64)devi.devno << 48) | op->dmaaddr, count, 0, 0);\r\nif (hvrc != HvLpEvent_Rc_Good) {\r\nprintk(VIOTAPE_KERN_WARN "hv error on op %d\n",\r\n(int)hvrc);\r\nret = -EIO;\r\ngoto free_dma;\r\n}\r\nif (noblock)\r\nreturn count;\r\nwait_for_completion(&op->com);\r\nif (op->rc)\r\nret = tape_rc_to_errno(op->rc, "write", devi.devno);\r\nelse {\r\nchg_state(devi.devno, VIOT_WRITING, file);\r\nret = op->count;\r\n}\r\nfree_dma:\r\ndma_free_coherent(op->dev, count, op->buffer, op->dmaaddr);\r\nup_sem:\r\nup(&reqSem);\r\nfree_op:\r\nfree_op_struct(op);\r\nreturn ret;\r\n}\r\nstatic ssize_t viotap_read(struct file *file, char *buf, size_t count,\r\nloff_t *ptr)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nunsigned short flags = file->f_flags;\r\nstruct op_struct *op = get_op_struct();\r\nint noblock = ((flags & O_NONBLOCK) != 0);\r\nssize_t ret;\r\nstruct viot_devinfo_struct devi;\r\nif (op == NULL)\r\nreturn -ENOMEM;\r\nget_dev_info(file->f_path.dentry->d_inode, &devi);\r\nif (noblock) {\r\nif (down_trylock(&reqSem)) {\r\nret = -EWOULDBLOCK;\r\ngoto free_op;\r\n}\r\n} else\r\ndown(&reqSem);\r\nchg_state(devi.devno, VIOT_READING, file);\r\nop->dev = tape_device[devi.devno];\r\nop->buffer = dma_alloc_coherent(op->dev, count, &op->dmaaddr,\r\nGFP_ATOMIC);\r\nif (op->buffer == NULL) {\r\nret = -EFAULT;\r\ngoto up_sem;\r\n}\r\nop->count = count;\r\ninit_completion(&op->com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_tape | viotaperead,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)op, VIOVERSION << 16,\r\n((u64)devi.devno << 48) | op->dmaaddr, count, 0, 0);\r\nif (hvrc != HvLpEvent_Rc_Good) {\r\nprintk(VIOTAPE_KERN_WARN "tape hv error on op %d\n",\r\n(int)hvrc);\r\nret = -EIO;\r\ngoto free_dma;\r\n}\r\nwait_for_completion(&op->com);\r\nif (op->rc)\r\nret = tape_rc_to_errno(op->rc, "read", devi.devno);\r\nelse {\r\nret = op->count;\r\nif (ret && copy_to_user(buf, op->buffer, ret)) {\r\nprintk(VIOTAPE_KERN_WARN "error on copy_to_user\n");\r\nret = -EFAULT;\r\n}\r\n}\r\nfree_dma:\r\ndma_free_coherent(op->dev, count, op->buffer, op->dmaaddr);\r\nup_sem:\r\nup(&reqSem);\r\nfree_op:\r\nfree_op_struct(op);\r\nreturn ret;\r\n}\r\nstatic int viotap_ioctl(struct inode *inode, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nint ret;\r\nstruct viot_devinfo_struct devi;\r\nstruct mtop mtc;\r\nu32 myOp;\r\nstruct op_struct *op = get_op_struct();\r\nif (op == NULL)\r\nreturn -ENOMEM;\r\nget_dev_info(file->f_path.dentry->d_inode, &devi);\r\ndown(&reqSem);\r\nret = -EINVAL;\r\nswitch (cmd) {\r\ncase MTIOCTOP:\r\nret = -EFAULT;\r\nif (inode == NULL)\r\nmemcpy(&mtc, (void *) arg, sizeof(struct mtop));\r\nelse if (copy_from_user((char *)&mtc, (char *)arg,\r\nsizeof(struct mtop)))\r\ngoto free_op;\r\nret = -EIO;\r\nswitch (mtc.mt_op) {\r\ncase MTRESET:\r\nmyOp = VIOTAPOP_RESET;\r\nbreak;\r\ncase MTFSF:\r\nmyOp = VIOTAPOP_FSF;\r\nbreak;\r\ncase MTBSF:\r\nmyOp = VIOTAPOP_BSF;\r\nbreak;\r\ncase MTFSR:\r\nmyOp = VIOTAPOP_FSR;\r\nbreak;\r\ncase MTBSR:\r\nmyOp = VIOTAPOP_BSR;\r\nbreak;\r\ncase MTWEOF:\r\nmyOp = VIOTAPOP_WEOF;\r\nbreak;\r\ncase MTREW:\r\nmyOp = VIOTAPOP_REW;\r\nbreak;\r\ncase MTNOP:\r\nmyOp = VIOTAPOP_NOP;\r\nbreak;\r\ncase MTEOM:\r\nmyOp = VIOTAPOP_EOM;\r\nbreak;\r\ncase MTERASE:\r\nmyOp = VIOTAPOP_ERASE;\r\nbreak;\r\ncase MTSETBLK:\r\nmyOp = VIOTAPOP_SETBLK;\r\nbreak;\r\ncase MTSETDENSITY:\r\nmyOp = VIOTAPOP_SETDENSITY;\r\nbreak;\r\ncase MTTELL:\r\nmyOp = VIOTAPOP_GETPOS;\r\nbreak;\r\ncase MTSEEK:\r\nmyOp = VIOTAPOP_SETPOS;\r\nbreak;\r\ncase MTSETPART:\r\nmyOp = VIOTAPOP_SETPART;\r\nbreak;\r\ncase MTOFFL:\r\nmyOp = VIOTAPOP_UNLOAD;\r\nbreak;\r\ndefault:\r\nprintk(VIOTAPE_KERN_WARN "MTIOCTOP called "\r\n"with invalid op 0x%x\n", mtc.mt_op);\r\ngoto free_op;\r\n}\r\nswitch (mtc.mt_op) {\r\ncase MTFSF:\r\ncase MTBSF:\r\ncase MTFSR:\r\ncase MTBSR:\r\ncase MTTELL:\r\ncase MTSEEK:\r\ncase MTREW:\r\nchg_state(devi.devno, VIOT_IDLE, file);\r\n}\r\ninit_completion(&op->com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_tape | viotapeop,\r\nHvLpEvent_AckInd_DoAck,\r\nHvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)op,\r\nVIOVERSION << 16,\r\n((u64)devi.devno << 48), 0,\r\n(((u64)myOp) << 32) | mtc.mt_count, 0);\r\nif (hvrc != HvLpEvent_Rc_Good) {\r\nprintk(VIOTAPE_KERN_WARN "hv error on op %d\n",\r\n(int)hvrc);\r\ngoto free_op;\r\n}\r\nwait_for_completion(&op->com);\r\nret = tape_rc_to_errno(op->rc, "tape operation", devi.devno);\r\ngoto free_op;\r\ncase MTIOCGET:\r\nret = -EIO;\r\ninit_completion(&op->com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_tape | viotapegetstatus,\r\nHvLpEvent_AckInd_DoAck,\r\nHvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)op, VIOVERSION << 16,\r\n((u64)devi.devno << 48), 0, 0, 0);\r\nif (hvrc != HvLpEvent_Rc_Good) {\r\nprintk(VIOTAPE_KERN_WARN "hv error on op %d\n",\r\n(int)hvrc);\r\ngoto free_op;\r\n}\r\nwait_for_completion(&op->com);\r\nret = tape_rc_to_errno(op->rc, "get status", devi.devno);\r\nfree_op_struct(op);\r\nup(&reqSem);\r\nif ((ret == 0) && copy_to_user((void *)arg,\r\n&viomtget[devi.devno],\r\nsizeof(viomtget[0])))\r\nret = -EFAULT;\r\nreturn ret;\r\ncase MTIOCPOS:\r\nprintk(VIOTAPE_KERN_WARN "Got an (unsupported) MTIOCPOS\n");\r\nbreak;\r\ndefault:\r\nprintk(VIOTAPE_KERN_WARN "got an unsupported ioctl 0x%0x\n",\r\ncmd);\r\nbreak;\r\n}\r\nfree_op:\r\nfree_op_struct(op);\r\nup(&reqSem);\r\nreturn ret;\r\n}\r\nstatic long viotap_unlocked_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nlong rc;\r\nmutex_lock(&proc_viotape_mutex);\r\nrc = viotap_ioctl(file->f_path.dentry->d_inode, file, cmd, arg);\r\nmutex_unlock(&proc_viotape_mutex);\r\nreturn rc;\r\n}\r\nstatic int viotap_open(struct inode *inode, struct file *file)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nstruct viot_devinfo_struct devi;\r\nint ret;\r\nstruct op_struct *op = get_op_struct();\r\nif (op == NULL)\r\nreturn -ENOMEM;\r\nmutex_lock(&proc_viotape_mutex);\r\nget_dev_info(file->f_path.dentry->d_inode, &devi);\r\nif ((devi.devno >= viotape_numdev) || (devi.mode)) {\r\nret = -ENODEV;\r\ngoto free_op;\r\n}\r\ninit_completion(&op->com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_tape | viotapeopen,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)op, VIOVERSION << 16,\r\n((u64)devi.devno << 48), 0, 0, 0);\r\nif (hvrc != 0) {\r\nprintk(VIOTAPE_KERN_WARN "bad rc on signalLpEvent %d\n",\r\n(int) hvrc);\r\nret = -EIO;\r\ngoto free_op;\r\n}\r\nwait_for_completion(&op->com);\r\nret = tape_rc_to_errno(op->rc, "open", devi.devno);\r\nfree_op:\r\nfree_op_struct(op);\r\nmutex_unlock(&proc_viotape_mutex);\r\nreturn ret;\r\n}\r\nstatic int viotap_release(struct inode *inode, struct file *file)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nstruct viot_devinfo_struct devi;\r\nint ret = 0;\r\nstruct op_struct *op = get_op_struct();\r\nif (op == NULL)\r\nreturn -ENOMEM;\r\ninit_completion(&op->com);\r\nget_dev_info(file->f_path.dentry->d_inode, &devi);\r\nif (devi.devno >= viotape_numdev) {\r\nret = -ENODEV;\r\ngoto free_op;\r\n}\r\nchg_state(devi.devno, VIOT_IDLE, file);\r\nif (devi.rewind) {\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_tape | viotapeop,\r\nHvLpEvent_AckInd_DoAck,\r\nHvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)op, VIOVERSION << 16,\r\n((u64)devi.devno << 48), 0,\r\n((u64)VIOTAPOP_REW) << 32, 0);\r\nwait_for_completion(&op->com);\r\ntape_rc_to_errno(op->rc, "rewind", devi.devno);\r\n}\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_tape | viotapeclose,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)op, VIOVERSION << 16,\r\n((u64)devi.devno << 48), 0, 0, 0);\r\nif (hvrc != 0) {\r\nprintk(VIOTAPE_KERN_WARN "bad rc on signalLpEvent %d\n",\r\n(int) hvrc);\r\nret = -EIO;\r\ngoto free_op;\r\n}\r\nwait_for_completion(&op->com);\r\nif (op->rc)\r\nprintk(VIOTAPE_KERN_WARN "close failed\n");\r\nfree_op:\r\nfree_op_struct(op);\r\nreturn ret;\r\n}\r\nstatic void vioHandleTapeEvent(struct HvLpEvent *event)\r\n{\r\nint tapeminor;\r\nstruct op_struct *op;\r\nstruct viotapelpevent *tevent = (struct viotapelpevent *)event;\r\nif (event == NULL) {\r\nif (!viopath_isactive(viopath_hostLp)) {\r\n}\r\nreturn;\r\n}\r\ntapeminor = event->xSubtype & VIOMINOR_SUBTYPE_MASK;\r\nop = (struct op_struct *)event->xCorrelationToken;\r\nswitch (tapeminor) {\r\ncase viotapeopen:\r\ncase viotapeclose:\r\nop->rc = tevent->sub_type_result;\r\ncomplete(&op->com);\r\nbreak;\r\ncase viotaperead:\r\nop->rc = tevent->sub_type_result;\r\nop->count = tevent->len;\r\ncomplete(&op->com);\r\nbreak;\r\ncase viotapewrite:\r\nif (op->non_blocking) {\r\ndma_free_coherent(op->dev, op->count,\r\nop->buffer, op->dmaaddr);\r\nfree_op_struct(op);\r\nup(&reqSem);\r\n} else {\r\nop->rc = tevent->sub_type_result;\r\nop->count = tevent->len;\r\ncomplete(&op->com);\r\n}\r\nbreak;\r\ncase viotapeop:\r\ncase viotapegetpos:\r\ncase viotapesetpos:\r\ncase viotapegetstatus:\r\nif (op) {\r\nop->count = tevent->u.op.count;\r\nop->rc = tevent->sub_type_result;\r\nif (!op->non_blocking)\r\ncomplete(&op->com);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(VIOTAPE_KERN_WARN "weird ack\n");\r\n}\r\n}\r\nstatic int viotape_probe(struct vio_dev *vdev, const struct vio_device_id *id)\r\n{\r\nint i = vdev->unit_address;\r\nint j;\r\nstruct device_node *node = vdev->dev.of_node;\r\nif (i >= VIOTAPE_MAX_TAPE)\r\nreturn -ENODEV;\r\nif (!node)\r\nreturn -ENODEV;\r\nif (i >= viotape_numdev)\r\nviotape_numdev = i + 1;\r\ntape_device[i] = &vdev->dev;\r\nviotape_unitinfo[i].rsrcname = of_get_property(node,\r\n"linux,vio_rsrcname", NULL);\r\nviotape_unitinfo[i].type = of_get_property(node, "linux,vio_type",\r\nNULL);\r\nviotape_unitinfo[i].model = of_get_property(node, "linux,vio_model",\r\nNULL);\r\nstate[i].cur_part = 0;\r\nfor (j = 0; j < MAX_PARTITIONS; ++j)\r\nstate[i].part_stat_rwi[j] = VIOT_IDLE;\r\ndevice_create(tape_class, NULL, MKDEV(VIOTAPE_MAJOR, i), NULL,\r\n"iseries!vt%d", i);\r\ndevice_create(tape_class, NULL, MKDEV(VIOTAPE_MAJOR, i | 0x80), NULL,\r\n"iseries!nvt%d", i);\r\nprintk(VIOTAPE_KERN_INFO "tape iseries/vt%d is iSeries "\r\n"resource %10.10s type %4.4s, model %3.3s\n",\r\ni, viotape_unitinfo[i].rsrcname,\r\nviotape_unitinfo[i].type, viotape_unitinfo[i].model);\r\nreturn 0;\r\n}\r\nstatic int viotape_remove(struct vio_dev *vdev)\r\n{\r\nint i = vdev->unit_address;\r\ndevice_destroy(tape_class, MKDEV(VIOTAPE_MAJOR, i | 0x80));\r\ndevice_destroy(tape_class, MKDEV(VIOTAPE_MAJOR, i));\r\nreturn 0;\r\n}\r\nint __init viotap_init(void)\r\n{\r\nint ret;\r\nif (!firmware_has_feature(FW_FEATURE_ISERIES))\r\nreturn -ENODEV;\r\nop_struct_list = NULL;\r\nif ((ret = add_op_structs(VIOTAPE_MAXREQ)) < 0) {\r\nprintk(VIOTAPE_KERN_WARN "couldn't allocate op structs\n");\r\nreturn ret;\r\n}\r\nspin_lock_init(&op_struct_list_lock);\r\nsema_init(&reqSem, VIOTAPE_MAXREQ);\r\nif (viopath_hostLp == HvLpIndexInvalid) {\r\nvio_set_hostlp();\r\nif (viopath_hostLp == HvLpIndexInvalid) {\r\nret = -ENODEV;\r\ngoto clear_op;\r\n}\r\n}\r\nret = viopath_open(viopath_hostLp, viomajorsubtype_tape,\r\nVIOTAPE_MAXREQ + 2);\r\nif (ret) {\r\nprintk(VIOTAPE_KERN_WARN\r\n"error on viopath_open to hostlp %d\n", ret);\r\nret = -EIO;\r\ngoto clear_op;\r\n}\r\nprintk(VIOTAPE_KERN_INFO "vers " VIOTAPE_VERSION\r\n", hosting partition %d\n", viopath_hostLp);\r\nvio_setHandler(viomajorsubtype_tape, vioHandleTapeEvent);\r\nret = register_chrdev(VIOTAPE_MAJOR, "viotape", &viotap_fops);\r\nif (ret < 0) {\r\nprintk(VIOTAPE_KERN_WARN "Error registering viotape device\n");\r\ngoto clear_handler;\r\n}\r\ntape_class = class_create(THIS_MODULE, "tape");\r\nif (IS_ERR(tape_class)) {\r\nprintk(VIOTAPE_KERN_WARN "Unable to allocat class\n");\r\nret = PTR_ERR(tape_class);\r\ngoto unreg_chrdev;\r\n}\r\nret = vio_register_driver(&viotape_driver);\r\nif (ret)\r\ngoto unreg_class;\r\nproc_create("iSeries/viotape", S_IFREG|S_IRUGO, NULL,\r\n&proc_viotape_operations);\r\nreturn 0;\r\nunreg_class:\r\nclass_destroy(tape_class);\r\nunreg_chrdev:\r\nunregister_chrdev(VIOTAPE_MAJOR, "viotape");\r\nclear_handler:\r\nvio_clearHandler(viomajorsubtype_tape);\r\nviopath_close(viopath_hostLp, viomajorsubtype_tape, VIOTAPE_MAXREQ + 2);\r\nclear_op:\r\nclear_op_struct_pool();\r\nreturn ret;\r\n}\r\nstatic int chg_state(int index, unsigned char new_state, struct file *file)\r\n{\r\nunsigned char *cur_state =\r\n&state[index].part_stat_rwi[state[index].cur_part];\r\nint rc = 0;\r\nif (*cur_state == new_state)\r\nreturn 0;\r\nif (*cur_state == VIOT_WRITING) {\r\nstruct mtop write_eof = { MTWEOF, 1 };\r\nrc = viotap_ioctl(NULL, file, MTIOCTOP,\r\n(unsigned long)&write_eof);\r\n}\r\n*cur_state = new_state;\r\nreturn rc;\r\n}\r\nstatic void __exit viotap_exit(void)\r\n{\r\nremove_proc_entry("iSeries/viotape", NULL);\r\nvio_unregister_driver(&viotape_driver);\r\nclass_destroy(tape_class);\r\nunregister_chrdev(VIOTAPE_MAJOR, "viotape");\r\nviopath_close(viopath_hostLp, viomajorsubtype_tape, VIOTAPE_MAXREQ + 2);\r\nvio_clearHandler(viomajorsubtype_tape);\r\nclear_op_struct_pool();\r\n}
