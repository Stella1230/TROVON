static void cfi_tell_features(struct cfi_pri_amdstd *extp)\r\n{\r\nconst char* erase_suspend[3] = {\r\n"Not supported", "Read only", "Read/write"\r\n};\r\nconst char* top_bottom[6] = {\r\n"No WP", "8x8KiB sectors at top & bottom, no WP",\r\n"Bottom boot", "Top boot",\r\n"Uniform, Bottom WP", "Uniform, Top WP"\r\n};\r\nprintk(" Silicon revision: %d\n", extp->SiliconRevision >> 1);\r\nprintk(" Address sensitive unlock: %s\n",\r\n(extp->SiliconRevision & 1) ? "Not required" : "Required");\r\nif (extp->EraseSuspend < ARRAY_SIZE(erase_suspend))\r\nprintk(" Erase Suspend: %s\n", erase_suspend[extp->EraseSuspend]);\r\nelse\r\nprintk(" Erase Suspend: Unknown value %d\n", extp->EraseSuspend);\r\nif (extp->BlkProt == 0)\r\nprintk(" Block protection: Not supported\n");\r\nelse\r\nprintk(" Block protection: %d sectors per group\n", extp->BlkProt);\r\nprintk(" Temporary block unprotect: %s\n",\r\nextp->TmpBlkUnprotect ? "Supported" : "Not supported");\r\nprintk(" Block protect/unprotect scheme: %d\n", extp->BlkProtUnprot);\r\nprintk(" Number of simultaneous operations: %d\n", extp->SimultaneousOps);\r\nprintk(" Burst mode: %s\n",\r\nextp->BurstMode ? "Supported" : "Not supported");\r\nif (extp->PageMode == 0)\r\nprintk(" Page mode: Not supported\n");\r\nelse\r\nprintk(" Page mode: %d word page\n", extp->PageMode << 2);\r\nprintk(" Vpp Supply Minimum Program/Erase Voltage: %d.%d V\n",\r\nextp->VppMin >> 4, extp->VppMin & 0xf);\r\nprintk(" Vpp Supply Maximum Program/Erase Voltage: %d.%d V\n",\r\nextp->VppMax >> 4, extp->VppMax & 0xf);\r\nif (extp->TopBottom < ARRAY_SIZE(top_bottom))\r\nprintk(" Top/Bottom Boot Block: %s\n", top_bottom[extp->TopBottom]);\r\nelse\r\nprintk(" Top/Bottom Boot Block: Unknown value %d\n", extp->TopBottom);\r\n}\r\nstatic void fixup_amd_bootblock(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_amdstd *extp = cfi->cmdset_priv;\r\n__u8 major = extp->MajorVersion;\r\n__u8 minor = extp->MinorVersion;\r\nif (((major << 8) | minor) < 0x3131) {\r\nDEBUG(MTD_DEBUG_LEVEL1,\r\n"%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X\n",\r\nmap->name, cfi->mfr, cfi->id);\r\nif (((cfi->id == 0xBA) || (cfi->id == 0x22BA)) &&\r\n(cfi->mfr == CFI_MFR_MACRONIX)) {\r\nDEBUG(MTD_DEBUG_LEVEL1,\r\n"%s: Macronix MX29LV400C with bottom boot block"\r\n" detected\n", map->name);\r\nextp->TopBottom = 2;\r\n} else\r\nif (cfi->id & 0x80) {\r\nprintk(KERN_WARNING "%s: JEDEC Device ID is 0x%02X. Assuming broken CFI table.\n", map->name, cfi->id);\r\nextp->TopBottom = 3;\r\n} else {\r\nextp->TopBottom = 2;\r\n}\r\nDEBUG(MTD_DEBUG_LEVEL1,\r\n"%s: AMD CFI PRI V%c.%c has no boot block field;"\r\n" deduced %s from Device ID\n", map->name, major, minor,\r\nextp->TopBottom == 2 ? "bottom" : "top");\r\n}\r\n}\r\nstatic void fixup_use_write_buffers(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nif (cfi->cfiq->BufWriteTimeoutTyp) {\r\nDEBUG(MTD_DEBUG_LEVEL1, "Using buffer write method\n" );\r\nmtd->write = cfi_amdstd_write_buffers;\r\n}\r\n}\r\nstatic void fixup_convert_atmel_pri(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_amdstd *extp = cfi->cmdset_priv;\r\nstruct cfi_pri_atmel atmel_pri;\r\nmemcpy(&atmel_pri, extp, sizeof(atmel_pri));\r\nmemset((char *)extp + 5, 0, sizeof(*extp) - 5);\r\nif (atmel_pri.Features & 0x02)\r\nextp->EraseSuspend = 2;\r\nif (cfi->id == AT49BV6416) {\r\nif (atmel_pri.BottomBoot)\r\nextp->TopBottom = 3;\r\nelse\r\nextp->TopBottom = 2;\r\n} else {\r\nif (atmel_pri.BottomBoot)\r\nextp->TopBottom = 2;\r\nelse\r\nextp->TopBottom = 3;\r\n}\r\ncfi->cfiq->BufWriteTimeoutTyp = 0;\r\ncfi->cfiq->BufWriteTimeoutMax = 0;\r\n}\r\nstatic void fixup_use_secsi(struct mtd_info *mtd)\r\n{\r\nmtd->read_user_prot_reg = cfi_amdstd_secsi_read;\r\nmtd->read_fact_prot_reg = cfi_amdstd_secsi_read;\r\n}\r\nstatic void fixup_use_erase_chip(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nif ((cfi->cfiq->NumEraseRegions == 1) &&\r\n((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0)) {\r\nmtd->erase = cfi_amdstd_erase_chip;\r\n}\r\n}\r\nstatic void fixup_use_atmel_lock(struct mtd_info *mtd)\r\n{\r\nmtd->lock = cfi_atmel_lock;\r\nmtd->unlock = cfi_atmel_unlock;\r\nmtd->flags |= MTD_POWERUP_LOCK;\r\n}\r\nstatic void fixup_old_sst_eraseregion(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\ncfi->cfiq->NumEraseRegions = 1;\r\n}\r\nstatic void fixup_sst39vf(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nfixup_old_sst_eraseregion(mtd);\r\ncfi->addr_unlock1 = 0x5555;\r\ncfi->addr_unlock2 = 0x2AAA;\r\n}\r\nstatic void fixup_sst39vf_rev_b(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nfixup_old_sst_eraseregion(mtd);\r\ncfi->addr_unlock1 = 0x555;\r\ncfi->addr_unlock2 = 0x2AA;\r\ncfi->sector_erase_cmd = CMD(0x50);\r\n}\r\nstatic void fixup_sst38vf640x_sectorsize(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nfixup_sst39vf_rev_b(mtd);\r\ncfi->cfiq->EraseRegionInfo[0] = 0x002003ff;\r\npr_warning("%s: Bad 38VF640x CFI data; adjusting sector size from 64 to 8KiB\n", mtd->name);\r\n}\r\nstatic void fixup_s29gl064n_sectors(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nif ((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0x003f) {\r\ncfi->cfiq->EraseRegionInfo[0] |= 0x0040;\r\npr_warning("%s: Bad S29GL064N CFI data, adjust from 64 to 128 sectors\n", mtd->name);\r\n}\r\n}\r\nstatic void fixup_s29gl032n_sectors(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nif ((cfi->cfiq->EraseRegionInfo[1] & 0xffff) == 0x007e) {\r\ncfi->cfiq->EraseRegionInfo[1] &= ~0x0040;\r\npr_warning("%s: Bad S29GL032N CFI data, adjust from 127 to 63 sectors\n", mtd->name);\r\n}\r\n}\r\nstatic void cfi_fixup_major_minor(struct cfi_private *cfi,\r\nstruct cfi_pri_amdstd *extp)\r\n{\r\nif (cfi->mfr == CFI_MFR_SAMSUNG) {\r\nif ((extp->MajorVersion == '0' && extp->MinorVersion == '0') ||\r\n(extp->MajorVersion == '3' && extp->MinorVersion == '3')) {\r\nprintk(KERN_NOTICE " Fixing Samsung's Amd/Fujitsu"\r\n" Extended Query version to 1.%c\n",\r\nextp->MinorVersion);\r\nextp->MajorVersion = '1';\r\n}\r\n}\r\nif (cfi->mfr == CFI_MFR_SST && (cfi->id >> 4) == 0x0536) {\r\nextp->MajorVersion = '1';\r\nextp->MinorVersion = '0';\r\n}\r\n}\r\nstruct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct mtd_info *mtd;\r\nint i;\r\nmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\r\nif (!mtd) {\r\nprintk(KERN_WARNING "Failed to allocate memory for MTD device\n");\r\nreturn NULL;\r\n}\r\nmtd->priv = map;\r\nmtd->type = MTD_NORFLASH;\r\nmtd->erase = cfi_amdstd_erase_varsize;\r\nmtd->write = cfi_amdstd_write_words;\r\nmtd->read = cfi_amdstd_read;\r\nmtd->sync = cfi_amdstd_sync;\r\nmtd->suspend = cfi_amdstd_suspend;\r\nmtd->resume = cfi_amdstd_resume;\r\nmtd->flags = MTD_CAP_NORFLASH;\r\nmtd->name = map->name;\r\nmtd->writesize = 1;\r\nmtd->writebufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\r\nDEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): write buffer size %d\n",\r\n__func__, mtd->writebufsize);\r\nmtd->reboot_notifier.notifier_call = cfi_amdstd_reboot;\r\nif (cfi->cfi_mode==CFI_MODE_CFI){\r\nunsigned char bootloc;\r\n__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;\r\nstruct cfi_pri_amdstd *extp;\r\nextp = (struct cfi_pri_amdstd*)cfi_read_pri(map, adr, sizeof(*extp), "Amd/Fujitsu");\r\nif (extp) {\r\ncfi_fixup_major_minor(cfi, extp);\r\nif (extp->MajorVersion != '1' ||\r\n(extp->MajorVersion == '1' && (extp->MinorVersion < '0' || extp->MinorVersion > '5'))) {\r\nprintk(KERN_ERR " Unknown Amd/Fujitsu Extended Query "\r\n"version %c.%c (%#02x/%#02x).\n",\r\nextp->MajorVersion, extp->MinorVersion,\r\nextp->MajorVersion, extp->MinorVersion);\r\nkfree(extp);\r\nkfree(mtd);\r\nreturn NULL;\r\n}\r\nprintk(KERN_INFO " Amd/Fujitsu Extended Query version %c.%c.\n",\r\nextp->MajorVersion, extp->MinorVersion);\r\ncfi->cmdset_priv = extp;\r\ncfi_fixup(mtd, cfi_fixup_table);\r\n#ifdef DEBUG_CFI_FEATURES\r\ncfi_tell_features(extp);\r\n#endif\r\nbootloc = extp->TopBottom;\r\nif ((bootloc < 2) || (bootloc > 5)) {\r\nprintk(KERN_WARNING "%s: CFI contains unrecognised boot "\r\n"bank location (%d). Assuming bottom.\n",\r\nmap->name, bootloc);\r\nbootloc = 2;\r\n}\r\nif (bootloc == 3 && cfi->cfiq->NumEraseRegions > 1) {\r\nprintk(KERN_WARNING "%s: Swapping erase regions for top-boot CFI table.\n", map->name);\r\nfor (i=0; i<cfi->cfiq->NumEraseRegions / 2; i++) {\r\nint j = (cfi->cfiq->NumEraseRegions-1)-i;\r\n__u32 swap;\r\nswap = cfi->cfiq->EraseRegionInfo[i];\r\ncfi->cfiq->EraseRegionInfo[i] = cfi->cfiq->EraseRegionInfo[j];\r\ncfi->cfiq->EraseRegionInfo[j] = swap;\r\n}\r\n}\r\ncfi->addr_unlock1 = 0x555;\r\ncfi->addr_unlock2 = 0x2aa;\r\n}\r\ncfi_fixup(mtd, cfi_nopri_fixup_table);\r\nif (!cfi->addr_unlock1 || !cfi->addr_unlock2) {\r\nkfree(mtd);\r\nreturn NULL;\r\n}\r\n}\r\nelse if (cfi->cfi_mode == CFI_MODE_JEDEC) {\r\ncfi_fixup(mtd, jedec_fixup_table);\r\n}\r\ncfi_fixup(mtd, fixup_table);\r\nfor (i=0; i< cfi->numchips; i++) {\r\ncfi->chips[i].word_write_time = 1<<cfi->cfiq->WordWriteTimeoutTyp;\r\ncfi->chips[i].buffer_write_time = 1<<cfi->cfiq->BufWriteTimeoutTyp;\r\ncfi->chips[i].erase_time = 1<<cfi->cfiq->BlockEraseTimeoutTyp;\r\ncfi->chips[i].ref_point_counter = 0;\r\ninit_waitqueue_head(&(cfi->chips[i].wq));\r\n}\r\nmap->fldrv = &cfi_amdstd_chipdrv;\r\nreturn cfi_amdstd_setup(mtd);\r\n}\r\nstatic struct mtd_info *cfi_amdstd_setup(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;\r\nunsigned long offset = 0;\r\nint i,j;\r\nprintk(KERN_NOTICE "number of %s chips: %d\n",\r\n(cfi->cfi_mode == CFI_MODE_CFI)?"CFI":"JEDEC",cfi->numchips);\r\nmtd->size = devsize * cfi->numchips;\r\nmtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;\r\nmtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info)\r\n* mtd->numeraseregions, GFP_KERNEL);\r\nif (!mtd->eraseregions) {\r\nprintk(KERN_WARNING "Failed to allocate memory for MTD erase region info\n");\r\ngoto setup_err;\r\n}\r\nfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\r\nunsigned long ernum, ersize;\r\nersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;\r\nernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;\r\nif (mtd->erasesize < ersize) {\r\nmtd->erasesize = ersize;\r\n}\r\nfor (j=0; j<cfi->numchips; j++) {\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;\r\n}\r\noffset += (ersize * ernum);\r\n}\r\nif (offset != devsize) {\r\nprintk(KERN_WARNING "Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);\r\ngoto setup_err;\r\n}\r\n__module_get(THIS_MODULE);\r\nregister_reboot_notifier(&mtd->reboot_notifier);\r\nreturn mtd;\r\nsetup_err:\r\nkfree(mtd->eraseregions);\r\nkfree(mtd);\r\nkfree(cfi->cmdset_priv);\r\nkfree(cfi->cfiq);\r\nreturn NULL;\r\n}\r\nstatic int __xipram chip_ready(struct map_info *map, unsigned long addr)\r\n{\r\nmap_word d, t;\r\nd = map_read(map, addr);\r\nt = map_read(map, addr);\r\nreturn map_word_equal(map, d, t);\r\n}\r\nstatic int __xipram chip_good(struct map_info *map, unsigned long addr, map_word expected)\r\n{\r\nmap_word oldd, curd;\r\noldd = map_read(map, addr);\r\ncurd = map_read(map, addr);\r\nreturn map_word_equal(map, oldd, curd) &&\r\nmap_word_equal(map, curd, expected);\r\n}\r\nstatic int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long timeo;\r\nstruct cfi_pri_amdstd *cfip = (struct cfi_pri_amdstd *)cfi->cmdset_priv;\r\nresettime:\r\ntimeo = jiffies + HZ;\r\nretry:\r\nswitch (chip->state) {\r\ncase FL_STATUS:\r\nfor (;;) {\r\nif (chip_ready(map, adr))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nprintk(KERN_ERR "Waiting for chip to be ready timed out.\n");\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\ngoto retry;\r\n}\r\ncase FL_READY:\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nreturn 0;\r\ncase FL_ERASING:\r\nif (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||\r\n!(mode == FL_READY || mode == FL_POINT ||\r\n(mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))\r\ngoto sleep;\r\nmap_write(map, CMD(0xB0), chip->in_progress_block_addr);\r\nchip->oldstate = FL_ERASING;\r\nchip->state = FL_ERASE_SUSPENDING;\r\nchip->erase_suspended = 1;\r\nfor (;;) {\r\nif (chip_ready(map, adr))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nput_chip(map, chip, adr);\r\nprintk(KERN_ERR "MTD %s(): chip not ready after erase suspend\n", __func__);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\n}\r\nchip->state = FL_READY;\r\nreturn 0;\r\ncase FL_XIP_WHILE_ERASING:\r\nif (mode != FL_READY && mode != FL_POINT &&\r\n(!cfip || !(cfip->EraseSuspend&2)))\r\ngoto sleep;\r\nchip->oldstate = chip->state;\r\nchip->state = FL_READY;\r\nreturn 0;\r\ncase FL_SHUTDOWN:\r\nreturn -EIO;\r\ncase FL_POINT:\r\nif (mode == FL_READY && chip->oldstate == FL_READY)\r\nreturn 0;\r\ndefault:\r\nsleep:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\ngoto resettime;\r\n}\r\n}\r\nstatic void put_chip(struct map_info *map, struct flchip *chip, unsigned long adr)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nswitch(chip->oldstate) {\r\ncase FL_ERASING:\r\nmap_write(map, cfi->sector_erase_cmd, chip->in_progress_block_addr);\r\nchip->oldstate = FL_READY;\r\nchip->state = FL_ERASING;\r\nbreak;\r\ncase FL_XIP_WHILE_ERASING:\r\nchip->state = chip->oldstate;\r\nchip->oldstate = FL_READY;\r\nbreak;\r\ncase FL_READY:\r\ncase FL_STATUS:\r\nDISABLE_VPP(map);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "MTD: put_chip() called with oldstate %d!!\n", chip->oldstate);\r\n}\r\nwake_up(&chip->wq);\r\n}\r\nstatic void xip_disable(struct map_info *map, struct flchip *chip,\r\nunsigned long adr)\r\n{\r\n(void) map_read(map, adr);\r\nlocal_irq_disable();\r\n}\r\nstatic void __xipram xip_enable(struct map_info *map, struct flchip *chip,\r\nunsigned long adr)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nif (chip->state != FL_POINT && chip->state != FL_READY) {\r\nmap_write(map, CMD(0xf0), adr);\r\nchip->state = FL_READY;\r\n}\r\n(void) map_read(map, adr);\r\nxip_iprefetch();\r\nlocal_irq_enable();\r\n}\r\nstatic void __xipram xip_udelay(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, int usec)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_amdstd *extp = cfi->cmdset_priv;\r\nmap_word status, OK = CMD(0x80);\r\nunsigned long suspended, start = xip_currtime();\r\nflstate_t oldstate;\r\ndo {\r\ncpu_relax();\r\nif (xip_irqpending() && extp &&\r\n((chip->state == FL_ERASING && (extp->EraseSuspend & 2))) &&\r\n(cfi_interleave_is_1(cfi) || chip->oldstate == FL_READY)) {\r\nmap_write(map, CMD(0xb0), adr);\r\nusec -= xip_elapsed_since(start);\r\nsuspended = xip_currtime();\r\ndo {\r\nif (xip_elapsed_since(suspended) > 100000) {\r\nreturn;\r\n}\r\nstatus = map_read(map, adr);\r\n} while (!map_word_andequal(map, status, OK, OK));\r\noldstate = chip->state;\r\nif (!map_word_bitsset(map, status, CMD(0x40)))\r\nbreak;\r\nchip->state = FL_XIP_WHILE_ERASING;\r\nchip->erase_suspended = 1;\r\nmap_write(map, CMD(0xf0), adr);\r\n(void) map_read(map, adr);\r\nxip_iprefetch();\r\nlocal_irq_enable();\r\nmutex_unlock(&chip->mutex);\r\nxip_iprefetch();\r\ncond_resched();\r\nmutex_lock(&chip->mutex);\r\nwhile (chip->state != FL_XIP_WHILE_ERASING) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\n}\r\nlocal_irq_disable();\r\nmap_write(map, cfi->sector_erase_cmd, adr);\r\nchip->state = oldstate;\r\nstart = xip_currtime();\r\n} else if (usec >= 1000000/HZ) {\r\nxip_cpu_idle();\r\n}\r\nstatus = map_read(map, adr);\r\n} while (!map_word_andequal(map, status, OK, OK)\r\n&& xip_elapsed_since(start) < usec);\r\n}\r\nstatic inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)\r\n{\r\nunsigned long cmd_addr;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret;\r\nadr += chip->start;\r\ncmd_addr = adr & ~(map_bankwidth(map)-1);\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, cmd_addr, FL_READY);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nif (chip->state != FL_POINT && chip->state != FL_READY) {\r\nmap_write(map, CMD(0xf0), cmd_addr);\r\nchip->state = FL_READY;\r\n}\r\nmap_copy_from(map, buf, adr, len);\r\nput_chip(map, chip, cmd_addr);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int cfi_amdstd_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long ofs;\r\nint chipnum;\r\nint ret = 0;\r\nchipnum = (from >> cfi->chipshift);\r\nofs = from - (chipnum << cfi->chipshift);\r\n*retlen = 0;\r\nwhile (len) {\r\nunsigned long thislen;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\nif ((len + ofs -1) >> cfi->chipshift)\r\nthislen = (1<<cfi->chipshift) - ofs;\r\nelse\r\nthislen = len;\r\nret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);\r\nif (ret)\r\nbreak;\r\n*retlen += thislen;\r\nlen -= thislen;\r\nbuf += thislen;\r\nofs = 0;\r\nchipnum++;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int do_read_secsi_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long timeo = jiffies + HZ;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nretry:\r\nmutex_lock(&chip->mutex);\r\nif (chip->state != FL_READY){\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + HZ;\r\ngoto retry;\r\n}\r\nadr += chip->start;\r\nchip->state = FL_READY;\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x88, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\nmap_copy_from(map, buf, adr, len);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x90, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x00, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\nwake_up(&chip->wq);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int cfi_amdstd_secsi_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long ofs;\r\nint chipnum;\r\nint ret = 0;\r\nchipnum=from>>3;\r\nofs=from & 7;\r\n*retlen = 0;\r\nwhile (len) {\r\nunsigned long thislen;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\nif ((len + ofs -1) >> 3)\r\nthislen = (1<<3) - ofs;\r\nelse\r\nthislen = len;\r\nret = do_read_secsi_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);\r\nif (ret)\r\nbreak;\r\n*retlen += thislen;\r\nlen -= thislen;\r\nbuf += thislen;\r\nofs = 0;\r\nchipnum++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __xipram do_write_oneword(struct map_info *map, struct flchip *chip, unsigned long adr, map_word datum)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long timeo = jiffies + HZ;\r\nunsigned long uWriteTimeout = ( HZ / 1000 ) + 1;\r\nint ret = 0;\r\nmap_word oldd;\r\nint retry_cnt = 0;\r\nadr += chip->start;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr, FL_WRITING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nDEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",\r\n__func__, adr, datum.x[0] );\r\noldd = map_read(map, adr);\r\nif (map_word_equal(map, oldd, datum)) {\r\nDEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): NOP\n",\r\n__func__);\r\ngoto op_done;\r\n}\r\nXIP_INVAL_CACHED_RANGE(map, adr, map_bankwidth(map));\r\nENABLE_VPP(map);\r\nxip_disable(map, chip, adr);\r\nretry:\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\nmap_write(map, datum, adr);\r\nchip->state = FL_WRITING;\r\nINVALIDATE_CACHE_UDELAY(map, chip,\r\nadr, map_bankwidth(map),\r\nchip->word_write_time);\r\ntimeo = jiffies + uWriteTimeout;\r\nfor (;;) {\r\nif (chip->state != FL_WRITING) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + (HZ / 2);\r\nmutex_lock(&chip->mutex);\r\ncontinue;\r\n}\r\nif (time_after(jiffies, timeo) && !chip_ready(map, adr)){\r\nxip_enable(map, chip, adr);\r\nprintk(KERN_WARNING "MTD %s(): software timeout\n", __func__);\r\nxip_disable(map, chip, adr);\r\nbreak;\r\n}\r\nif (chip_ready(map, adr))\r\nbreak;\r\nUDELAY(map, chip, adr, 1);\r\n}\r\nif (!chip_good(map, adr, datum)) {\r\nmap_write( map, CMD(0xF0), chip->start );\r\nif (++retry_cnt <= MAX_WORD_RETRIES)\r\ngoto retry;\r\nret = -EIO;\r\n}\r\nxip_enable(map, chip, adr);\r\nop_done:\r\nchip->state = FL_READY;\r\nput_chip(map, chip, adr);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_amdstd_write_words(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret = 0;\r\nint chipnum;\r\nunsigned long ofs, chipstart;\r\nDECLARE_WAITQUEUE(wait, current);\r\n*retlen = 0;\r\nif (!len)\r\nreturn 0;\r\nchipnum = to >> cfi->chipshift;\r\nofs = to - (chipnum << cfi->chipshift);\r\nchipstart = cfi->chips[chipnum].start;\r\nif (ofs & (map_bankwidth(map)-1)) {\r\nunsigned long bus_ofs = ofs & ~(map_bankwidth(map)-1);\r\nint i = ofs - bus_ofs;\r\nint n = 0;\r\nmap_word tmp_buf;\r\nretry:\r\nmutex_lock(&cfi->chips[chipnum].mutex);\r\nif (cfi->chips[chipnum].state != FL_READY) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&cfi->chips[chipnum].wq, &wait);\r\nmutex_unlock(&cfi->chips[chipnum].mutex);\r\nschedule();\r\nremove_wait_queue(&cfi->chips[chipnum].wq, &wait);\r\ngoto retry;\r\n}\r\ntmp_buf = map_read(map, bus_ofs+chipstart);\r\nmutex_unlock(&cfi->chips[chipnum].mutex);\r\nn = min_t(int, len, map_bankwidth(map)-i);\r\ntmp_buf = map_word_load_partial(map, tmp_buf, buf, i, n);\r\nret = do_write_oneword(map, &cfi->chips[chipnum],\r\nbus_ofs, tmp_buf);\r\nif (ret)\r\nreturn ret;\r\nofs += n;\r\nbuf += n;\r\n(*retlen) += n;\r\nlen -= n;\r\nif (ofs >> cfi->chipshift) {\r\nchipnum ++;\r\nofs = 0;\r\nif (chipnum == cfi->numchips)\r\nreturn 0;\r\n}\r\n}\r\nwhile(len >= map_bankwidth(map)) {\r\nmap_word datum;\r\ndatum = map_word_load(map, buf);\r\nret = do_write_oneword(map, &cfi->chips[chipnum],\r\nofs, datum);\r\nif (ret)\r\nreturn ret;\r\nofs += map_bankwidth(map);\r\nbuf += map_bankwidth(map);\r\n(*retlen) += map_bankwidth(map);\r\nlen -= map_bankwidth(map);\r\nif (ofs >> cfi->chipshift) {\r\nchipnum ++;\r\nofs = 0;\r\nif (chipnum == cfi->numchips)\r\nreturn 0;\r\nchipstart = cfi->chips[chipnum].start;\r\n}\r\n}\r\nif (len & (map_bankwidth(map)-1)) {\r\nmap_word tmp_buf;\r\nretry1:\r\nmutex_lock(&cfi->chips[chipnum].mutex);\r\nif (cfi->chips[chipnum].state != FL_READY) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&cfi->chips[chipnum].wq, &wait);\r\nmutex_unlock(&cfi->chips[chipnum].mutex);\r\nschedule();\r\nremove_wait_queue(&cfi->chips[chipnum].wq, &wait);\r\ngoto retry1;\r\n}\r\ntmp_buf = map_read(map, ofs + chipstart);\r\nmutex_unlock(&cfi->chips[chipnum].mutex);\r\ntmp_buf = map_word_load_partial(map, tmp_buf, buf, 0, len);\r\nret = do_write_oneword(map, &cfi->chips[chipnum],\r\nofs, tmp_buf);\r\nif (ret)\r\nreturn ret;\r\n(*retlen) += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, const u_char *buf,\r\nint len)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long timeo = jiffies + HZ;\r\nunsigned long uWriteTimeout = ( HZ / 1000 ) + 1;\r\nint ret = -EIO;\r\nunsigned long cmd_adr;\r\nint z, words;\r\nmap_word datum;\r\nadr += chip->start;\r\ncmd_adr = adr;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr, FL_WRITING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\ndatum = map_word_load(map, buf);\r\nDEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",\r\n__func__, adr, datum.x[0] );\r\nXIP_INVAL_CACHED_RANGE(map, adr, len);\r\nENABLE_VPP(map);\r\nxip_disable(map, chip, cmd_adr);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\r\nmap_write(map, CMD(0x25), cmd_adr);\r\nchip->state = FL_WRITING_TO_BUFFER;\r\nwords = len / map_bankwidth(map);\r\nmap_write(map, CMD(words - 1), cmd_adr);\r\nz = 0;\r\nwhile(z < words * map_bankwidth(map)) {\r\ndatum = map_word_load(map, buf);\r\nmap_write(map, datum, adr + z);\r\nz += map_bankwidth(map);\r\nbuf += map_bankwidth(map);\r\n}\r\nz -= map_bankwidth(map);\r\nadr += z;\r\nmap_write(map, CMD(0x29), cmd_adr);\r\nchip->state = FL_WRITING;\r\nINVALIDATE_CACHE_UDELAY(map, chip,\r\nadr, map_bankwidth(map),\r\nchip->word_write_time);\r\ntimeo = jiffies + uWriteTimeout;\r\nfor (;;) {\r\nif (chip->state != FL_WRITING) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ntimeo = jiffies + (HZ / 2);\r\nmutex_lock(&chip->mutex);\r\ncontinue;\r\n}\r\nif (time_after(jiffies, timeo) && !chip_ready(map, adr))\r\nbreak;\r\nif (chip_ready(map, adr)) {\r\nxip_enable(map, chip, adr);\r\ngoto op_done;\r\n}\r\nUDELAY(map, chip, adr, 1);\r\n}\r\nmap_write( map, CMD(0xF0), chip->start );\r\nxip_enable(map, chip, adr);\r\nprintk(KERN_WARNING "MTD %s(): software timeout\n",\r\n__func__ );\r\nret = -EIO;\r\nop_done:\r\nchip->state = FL_READY;\r\nput_chip(map, chip, adr);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint wbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\r\nint ret = 0;\r\nint chipnum;\r\nunsigned long ofs;\r\n*retlen = 0;\r\nif (!len)\r\nreturn 0;\r\nchipnum = to >> cfi->chipshift;\r\nofs = to - (chipnum << cfi->chipshift);\r\nif (ofs & (map_bankwidth(map)-1)) {\r\nsize_t local_len = (-ofs)&(map_bankwidth(map)-1);\r\nif (local_len > len)\r\nlocal_len = len;\r\nret = cfi_amdstd_write_words(mtd, ofs + (chipnum<<cfi->chipshift),\r\nlocal_len, retlen, buf);\r\nif (ret)\r\nreturn ret;\r\nofs += local_len;\r\nbuf += local_len;\r\nlen -= local_len;\r\nif (ofs >> cfi->chipshift) {\r\nchipnum ++;\r\nofs = 0;\r\nif (chipnum == cfi->numchips)\r\nreturn 0;\r\n}\r\n}\r\nwhile (len >= map_bankwidth(map) * 2) {\r\nint size = wbufsize - (ofs & (wbufsize-1));\r\nif (size > len)\r\nsize = len;\r\nif (size % map_bankwidth(map))\r\nsize -= size % map_bankwidth(map);\r\nret = do_write_buffer(map, &cfi->chips[chipnum],\r\nofs, buf, size);\r\nif (ret)\r\nreturn ret;\r\nofs += size;\r\nbuf += size;\r\n(*retlen) += size;\r\nlen -= size;\r\nif (ofs >> cfi->chipshift) {\r\nchipnum ++;\r\nofs = 0;\r\nif (chipnum == cfi->numchips)\r\nreturn 0;\r\n}\r\n}\r\nif (len) {\r\nsize_t retlen_dregs = 0;\r\nret = cfi_amdstd_write_words(mtd, ofs + (chipnum<<cfi->chipshift),\r\nlen, &retlen_dregs, buf);\r\n*retlen += retlen_dregs;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long timeo = jiffies + HZ;\r\nunsigned long int adr;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint ret = 0;\r\nadr = cfi->addr_unlock1;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr, FL_WRITING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nDEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): ERASE 0x%.8lx\n",\r\n__func__, chip->start );\r\nXIP_INVAL_CACHED_RANGE(map, adr, map->size);\r\nENABLE_VPP(map);\r\nxip_disable(map, chip, adr);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x10, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\nchip->state = FL_ERASING;\r\nchip->erase_suspended = 0;\r\nchip->in_progress_block_addr = adr;\r\nINVALIDATE_CACHE_UDELAY(map, chip,\r\nadr, map->size,\r\nchip->erase_time*500);\r\ntimeo = jiffies + (HZ*20);\r\nfor (;;) {\r\nif (chip->state != FL_ERASING) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\ncontinue;\r\n}\r\nif (chip->erase_suspended) {\r\ntimeo = jiffies + (HZ*20);\r\nchip->erase_suspended = 0;\r\n}\r\nif (chip_ready(map, adr))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nprintk(KERN_WARNING "MTD %s(): software timeout\n",\r\n__func__ );\r\nbreak;\r\n}\r\nUDELAY(map, chip, adr, 1000000/HZ);\r\n}\r\nif (!chip_good(map, adr, map_word_ff(map))) {\r\nmap_write( map, CMD(0xF0), chip->start );\r\nret = -EIO;\r\n}\r\nchip->state = FL_READY;\r\nxip_enable(map, chip, adr);\r\nput_chip(map, chip, adr);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr, int len, void *thunk)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long timeo = jiffies + HZ;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint ret = 0;\r\nadr += chip->start;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr, FL_ERASING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nDEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): ERASE 0x%.8lx\n",\r\n__func__, adr );\r\nXIP_INVAL_CACHED_RANGE(map, adr, len);\r\nENABLE_VPP(map);\r\nxip_disable(map, chip, adr);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\r\nmap_write(map, cfi->sector_erase_cmd, adr);\r\nchip->state = FL_ERASING;\r\nchip->erase_suspended = 0;\r\nchip->in_progress_block_addr = adr;\r\nINVALIDATE_CACHE_UDELAY(map, chip,\r\nadr, len,\r\nchip->erase_time*500);\r\ntimeo = jiffies + (HZ*20);\r\nfor (;;) {\r\nif (chip->state != FL_ERASING) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\ncontinue;\r\n}\r\nif (chip->erase_suspended) {\r\ntimeo = jiffies + (HZ*20);\r\nchip->erase_suspended = 0;\r\n}\r\nif (chip_ready(map, adr)) {\r\nxip_enable(map, chip, adr);\r\nbreak;\r\n}\r\nif (time_after(jiffies, timeo)) {\r\nxip_enable(map, chip, adr);\r\nprintk(KERN_WARNING "MTD %s(): software timeout\n",\r\n__func__ );\r\nbreak;\r\n}\r\nUDELAY(map, chip, adr, 1000000/HZ);\r\n}\r\nif (!chip_good(map, adr, map_word_ff(map))) {\r\nmap_write( map, CMD(0xF0), chip->start );\r\nret = -EIO;\r\n}\r\nchip->state = FL_READY;\r\nput_chip(map, chip, adr);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_amdstd_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nunsigned long ofs, len;\r\nint ret;\r\nofs = instr->addr;\r\nlen = instr->len;\r\nret = cfi_varsize_frob(mtd, do_erase_oneblock, ofs, len, NULL);\r\nif (ret)\r\nreturn ret;\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic int cfi_amdstd_erase_chip(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret = 0;\r\nif (instr->addr != 0)\r\nreturn -EINVAL;\r\nif (instr->len != mtd->size)\r\nreturn -EINVAL;\r\nret = do_erase_chip(map, &cfi->chips[0]);\r\nif (ret)\r\nreturn ret;\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic int do_atmel_lock(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, int len, void *thunk)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr + chip->start, FL_LOCKING);\r\nif (ret)\r\ngoto out_unlock;\r\nchip->state = FL_LOCKING;\r\nDEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): LOCK 0x%08lx len %d\n",\r\n__func__, adr, len);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\r\ncfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\r\ncfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi,\r\ncfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\r\ncfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\r\ncfi->device_type, NULL);\r\nmap_write(map, CMD(0x40), chip->start + adr);\r\nchip->state = FL_READY;\r\nput_chip(map, chip, adr + chip->start);\r\nret = 0;\r\nout_unlock:\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int do_atmel_unlock(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, int len, void *thunk)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr + chip->start, FL_UNLOCKING);\r\nif (ret)\r\ngoto out_unlock;\r\nchip->state = FL_UNLOCKING;\r\nDEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): LOCK 0x%08lx len %d\n",\r\n__func__, adr, len);\r\ncfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\r\ncfi->device_type, NULL);\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_READY;\r\nput_chip(map, chip, adr + chip->start);\r\nret = 0;\r\nout_unlock:\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_atmel_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nreturn cfi_varsize_frob(mtd, do_atmel_lock, ofs, len, NULL);\r\n}\r\nstatic int cfi_atmel_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nreturn cfi_varsize_frob(mtd, do_atmel_unlock, ofs, len, NULL);\r\n}\r\nstatic void cfi_amdstd_sync (struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i;\r\nstruct flchip *chip;\r\nint ret = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nfor (i=0; !ret && i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nretry:\r\nmutex_lock(&chip->mutex);\r\nswitch(chip->state) {\r\ncase FL_READY:\r\ncase FL_STATUS:\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nchip->oldstate = chip->state;\r\nchip->state = FL_SYNCING;\r\ncase FL_SYNCING:\r\nmutex_unlock(&chip->mutex);\r\nbreak;\r\ndefault:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\ngoto retry;\r\n}\r\n}\r\nfor (i--; i >=0; i--) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_SYNCING) {\r\nchip->state = chip->oldstate;\r\nwake_up(&chip->wq);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\n}\r\nstatic int cfi_amdstd_suspend(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i;\r\nstruct flchip *chip;\r\nint ret = 0;\r\nfor (i=0; !ret && i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nswitch(chip->state) {\r\ncase FL_READY:\r\ncase FL_STATUS:\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nchip->oldstate = chip->state;\r\nchip->state = FL_PM_SUSPENDED;\r\ncase FL_PM_SUSPENDED:\r\nbreak;\r\ndefault:\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\nif (ret) {\r\nfor (i--; i >=0; i--) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_PM_SUSPENDED) {\r\nchip->state = chip->oldstate;\r\nwake_up(&chip->wq);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void cfi_amdstd_resume(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i;\r\nstruct flchip *chip;\r\nfor (i=0; i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_PM_SUSPENDED) {\r\nchip->state = FL_READY;\r\nmap_write(map, CMD(0xF0), chip->start);\r\nwake_up(&chip->wq);\r\n}\r\nelse\r\nprintk(KERN_ERR "Argh. Chip not in PM_SUSPENDED state upon resume()\n");\r\nmutex_unlock(&chip->mutex);\r\n}\r\n}\r\nstatic int cfi_amdstd_reset(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i, ret;\r\nstruct flchip *chip;\r\nfor (i = 0; i < cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, chip->start, FL_SHUTDOWN);\r\nif (!ret) {\r\nmap_write(map, CMD(0xF0), chip->start);\r\nchip->state = FL_SHUTDOWN;\r\nput_chip(map, chip, chip->start);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfi_amdstd_reboot(struct notifier_block *nb, unsigned long val,\r\nvoid *v)\r\n{\r\nstruct mtd_info *mtd;\r\nmtd = container_of(nb, struct mtd_info, reboot_notifier);\r\ncfi_amdstd_reset(mtd);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void cfi_amdstd_destroy(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\ncfi_amdstd_reset(mtd);\r\nunregister_reboot_notifier(&mtd->reboot_notifier);\r\nkfree(cfi->cmdset_priv);\r\nkfree(cfi->cfiq);\r\nkfree(cfi);\r\nkfree(mtd->eraseregions);\r\n}
