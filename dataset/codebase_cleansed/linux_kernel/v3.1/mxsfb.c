static inline u32 set_hsync_pulse_width(struct mxsfb_info *host, unsigned val)\r\n{\r\nreturn (val & host->devdata->hs_wdth_mask) <<\r\nhost->devdata->hs_wdth_shift;\r\n}\r\nstatic inline u32 get_hsync_pulse_width(struct mxsfb_info *host, unsigned val)\r\n{\r\nreturn (val >> host->devdata->hs_wdth_shift) &\r\nhost->devdata->hs_wdth_mask;\r\n}\r\nstatic inline unsigned chan_to_field(unsigned chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int mxsfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nconst struct fb_bitfield *rgb = NULL;\r\nif (var->xres < MIN_XRES)\r\nvar->xres = MIN_XRES;\r\nif (var->yres < MIN_YRES)\r\nvar->yres = MIN_YRES;\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nrgb = def_rgb565;\r\nbreak;\r\ncase 32:\r\nswitch (host->ld_intf_width) {\r\ncase STMLCDIF_8BIT:\r\npr_debug("Unsupported LCD bus width mapping\n");\r\nbreak;\r\ncase STMLCDIF_16BIT:\r\ncase STMLCDIF_18BIT:\r\nrgb = def_rgb666;\r\nbreak;\r\ncase STMLCDIF_24BIT:\r\nrgb = def_rgb888;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\npr_debug("Unsupported colour depth: %u\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nvar->red = rgb[RED];\r\nvar->green = rgb[GREEN];\r\nvar->blue = rgb[BLUE];\r\nvar->transp = rgb[TRANSP];\r\nreturn 0;\r\n}\r\nstatic void mxsfb_enable_controller(struct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nu32 reg;\r\ndev_dbg(&host->pdev->dev, "%s\n", __func__);\r\nclk_enable(host->clk);\r\nclk_set_rate(host->clk, PICOS2KHZ(fb_info->var.pixclock) * 1000U);\r\nwritel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_SET);\r\nreg = readl(host->base + LCDC_VDCTRL4);\r\nreg |= VDCTRL4_SYNC_SIGNALS_ON;\r\nwritel(reg, host->base + LCDC_VDCTRL4);\r\nwritel(CTRL_RUN, host->base + LCDC_CTRL + REG_SET);\r\nhost->enabled = 1;\r\n}\r\nstatic void mxsfb_disable_controller(struct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nunsigned loop;\r\nu32 reg;\r\ndev_dbg(&host->pdev->dev, "%s\n", __func__);\r\nwritel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_CLR);\r\nloop = 1000;\r\nwhile (loop) {\r\nreg = readl(host->base + LCDC_CTRL);\r\nif (!(reg & CTRL_RUN))\r\nbreak;\r\nloop--;\r\n}\r\nwritel(VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4 + REG_CLR);\r\nclk_disable(host->clk);\r\nhost->enabled = 0;\r\n}\r\nstatic int mxsfb_set_par(struct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nu32 ctrl, vdctrl0, vdctrl4;\r\nint line_size, fb_size;\r\nint reenable = 0;\r\nline_size = fb_info->var.xres * (fb_info->var.bits_per_pixel >> 3);\r\nfb_size = fb_info->var.yres_virtual * line_size;\r\nif (fb_size > fb_info->fix.smem_len)\r\nreturn -ENOMEM;\r\nfb_info->fix.line_length = line_size;\r\nif (host->enabled) {\r\nreenable = 1;\r\nmxsfb_disable_controller(fb_info);\r\n}\r\nwritel(CTRL1_FIFO_CLEAR, host->base + LCDC_CTRL1 + REG_SET);\r\nctrl = CTRL_BYPASS_COUNT | CTRL_MASTER |\r\nCTRL_SET_BUS_WIDTH(host->ld_intf_width);\r\nswitch (fb_info->var.bits_per_pixel) {\r\ncase 16:\r\ndev_dbg(&host->pdev->dev, "Setting up RGB565 mode\n");\r\nctrl |= CTRL_SET_WORD_LENGTH(0);\r\nwritel(CTRL1_SET_BYTE_PACKAGING(0xf), host->base + LCDC_CTRL1);\r\nbreak;\r\ncase 32:\r\ndev_dbg(&host->pdev->dev, "Setting up RGB888/666 mode\n");\r\nctrl |= CTRL_SET_WORD_LENGTH(3);\r\nswitch (host->ld_intf_width) {\r\ncase STMLCDIF_8BIT:\r\ndev_dbg(&host->pdev->dev,\r\n"Unsupported LCD bus width mapping\n");\r\nreturn -EINVAL;\r\ncase STMLCDIF_16BIT:\r\ncase STMLCDIF_18BIT:\r\nctrl |= CTRL_DF24;\r\nbreak;\r\ncase STMLCDIF_24BIT:\r\nbreak;\r\n}\r\nwritel(CTRL1_SET_BYTE_PACKAGING(0x7), host->base + LCDC_CTRL1);\r\nbreak;\r\ndefault:\r\ndev_dbg(&host->pdev->dev, "Unhandled color depth of %u\n",\r\nfb_info->var.bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nwritel(ctrl, host->base + LCDC_CTRL);\r\nwritel(TRANSFER_COUNT_SET_VCOUNT(fb_info->var.yres) |\r\nTRANSFER_COUNT_SET_HCOUNT(fb_info->var.xres),\r\nhost->base + host->devdata->transfer_count);\r\nvdctrl0 = VDCTRL0_ENABLE_PRESENT |\r\nVDCTRL0_VSYNC_PERIOD_UNIT |\r\nVDCTRL0_VSYNC_PULSE_WIDTH_UNIT |\r\nVDCTRL0_SET_VSYNC_PULSE_WIDTH(fb_info->var.vsync_len);\r\nif (fb_info->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\nvdctrl0 |= VDCTRL0_HSYNC_ACT_HIGH;\r\nif (fb_info->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\nvdctrl0 |= VDCTRL0_VSYNC_ACT_HIGH;\r\nif (fb_info->var.sync & FB_SYNC_DATA_ENABLE_HIGH_ACT)\r\nvdctrl0 |= VDCTRL0_ENABLE_ACT_HIGH;\r\nif (fb_info->var.sync & FB_SYNC_DOTCLK_FAILING_ACT)\r\nvdctrl0 |= VDCTRL0_DOTCLK_ACT_FAILING;\r\nwritel(vdctrl0, host->base + LCDC_VDCTRL0);\r\nwritel(fb_info->var.upper_margin + fb_info->var.vsync_len +\r\nfb_info->var.lower_margin + fb_info->var.yres,\r\nhost->base + LCDC_VDCTRL1);\r\nwritel(set_hsync_pulse_width(host, fb_info->var.hsync_len) |\r\nVDCTRL2_SET_HSYNC_PERIOD(fb_info->var.left_margin +\r\nfb_info->var.hsync_len + fb_info->var.right_margin +\r\nfb_info->var.xres),\r\nhost->base + LCDC_VDCTRL2);\r\nwritel(SET_HOR_WAIT_CNT(fb_info->var.left_margin +\r\nfb_info->var.hsync_len) |\r\nSET_VERT_WAIT_CNT(fb_info->var.upper_margin +\r\nfb_info->var.vsync_len),\r\nhost->base + LCDC_VDCTRL3);\r\nvdctrl4 = SET_DOTCLK_H_VALID_DATA_CNT(fb_info->var.xres);\r\nif (mxsfb_is_v4(host))\r\nvdctrl4 |= VDCTRL4_SET_DOTCLK_DLY(host->dotclk_delay);\r\nwritel(vdctrl4, host->base + LCDC_VDCTRL4);\r\nwritel(fb_info->fix.smem_start +\r\nfb_info->fix.line_length * fb_info->var.yoffset,\r\nhost->base + host->devdata->next_buf);\r\nif (reenable)\r\nmxsfb_enable_controller(fb_info);\r\nreturn 0;\r\n}\r\nstatic int mxsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *fb_info)\r\n{\r\nunsigned int val;\r\nint ret = -EINVAL;\r\nif (fb_info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (fb_info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = fb_info->pseudo_palette;\r\nval = chan_to_field(red, &fb_info->var.red);\r\nval |= chan_to_field(green, &fb_info->var.green);\r\nval |= chan_to_field(blue, &fb_info->var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_STATIC_PSEUDOCOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxsfb_blank(int blank, struct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nif (host->enabled)\r\nmxsfb_disable_controller(fb_info);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nif (!host->enabled)\r\nmxsfb_enable_controller(fb_info);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxsfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nunsigned offset;\r\nif (var->xoffset != 0)\r\nreturn -EINVAL;\r\noffset = fb_info->fix.line_length * var->yoffset;\r\nwritel(fb_info->fix.smem_start + offset,\r\nhost->base + host->devdata->next_buf);\r\nreturn 0;\r\n}\r\nstatic int __devinit mxsfb_restore_mode(struct mxsfb_info *host)\r\n{\r\nstruct fb_info *fb_info = &host->fb_info;\r\nunsigned line_count;\r\nunsigned period;\r\nunsigned long pa, fbsize;\r\nint bits_per_pixel, ofs;\r\nu32 transfer_count, vdctrl0, vdctrl2, vdctrl3, vdctrl4, ctrl;\r\nstruct fb_videomode vmode;\r\nctrl = readl(host->base + LCDC_CTRL);\r\nif (!(ctrl & CTRL_RUN))\r\nreturn -EINVAL;\r\nvdctrl0 = readl(host->base + LCDC_VDCTRL0);\r\nvdctrl2 = readl(host->base + LCDC_VDCTRL2);\r\nvdctrl3 = readl(host->base + LCDC_VDCTRL3);\r\nvdctrl4 = readl(host->base + LCDC_VDCTRL4);\r\ntransfer_count = readl(host->base + host->devdata->transfer_count);\r\nvmode.xres = TRANSFER_COUNT_GET_HCOUNT(transfer_count);\r\nvmode.yres = TRANSFER_COUNT_GET_VCOUNT(transfer_count);\r\nswitch (CTRL_GET_WORD_LENGTH(ctrl)) {\r\ncase 0:\r\nbits_per_pixel = 16;\r\nbreak;\r\ncase 3:\r\nbits_per_pixel = 32;\r\ncase 1:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfb_info->var.bits_per_pixel = bits_per_pixel;\r\nvmode.pixclock = KHZ2PICOS(clk_get_rate(host->clk) / 1000U);\r\nvmode.hsync_len = get_hsync_pulse_width(host, vdctrl2);\r\nvmode.left_margin = GET_HOR_WAIT_CNT(vdctrl3) - vmode.hsync_len;\r\nvmode.right_margin = VDCTRL2_GET_HSYNC_PERIOD(vdctrl2) - vmode.hsync_len -\r\nvmode.left_margin - vmode.xres;\r\nvmode.vsync_len = VDCTRL0_GET_VSYNC_PULSE_WIDTH(vdctrl0);\r\nperiod = readl(host->base + LCDC_VDCTRL1);\r\nvmode.upper_margin = GET_VERT_WAIT_CNT(vdctrl3) - vmode.vsync_len;\r\nvmode.lower_margin = period - vmode.vsync_len - vmode.upper_margin - vmode.yres;\r\nvmode.vmode = FB_VMODE_NONINTERLACED;\r\nvmode.sync = 0;\r\nif (vdctrl0 & VDCTRL0_HSYNC_ACT_HIGH)\r\nvmode.sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (vdctrl0 & VDCTRL0_VSYNC_ACT_HIGH)\r\nvmode.sync |= FB_SYNC_VERT_HIGH_ACT;\r\npr_debug("Reconstructed video mode:\n");\r\npr_debug("%dx%d, hsync: %u left: %u, right: %u, vsync: %u, upper: %u, lower: %u\n",\r\nvmode.xres, vmode.yres,\r\nvmode.hsync_len, vmode.left_margin, vmode.right_margin,\r\nvmode.vsync_len, vmode.upper_margin, vmode.lower_margin);\r\npr_debug("pixclk: %ldkHz\n", PICOS2KHZ(vmode.pixclock));\r\nfb_add_videomode(&vmode, &fb_info->modelist);\r\nhost->ld_intf_width = CTRL_GET_BUS_WIDTH(ctrl);\r\nhost->dotclk_delay = VDCTRL4_GET_DOTCLK_DLY(vdctrl4);\r\nfb_info->fix.line_length = vmode.xres * (bits_per_pixel >> 3);\r\npa = readl(host->base + host->devdata->cur_buf);\r\nfbsize = fb_info->fix.line_length * vmode.yres;\r\nif (pa < fb_info->fix.smem_start)\r\nreturn -EINVAL;\r\nif (pa + fbsize > fb_info->fix.smem_start + fb_info->fix.smem_len)\r\nreturn -EINVAL;\r\nofs = pa - fb_info->fix.smem_start;\r\nif (ofs) {\r\nmemmove(fb_info->screen_base, fb_info->screen_base + ofs, fbsize);\r\nwritel(fb_info->fix.smem_start, host->base + host->devdata->next_buf);\r\n}\r\nline_count = fb_info->fix.smem_len / fb_info->fix.line_length;\r\nfb_info->fix.ypanstep = 1;\r\nclk_enable(host->clk);\r\nhost->enabled = 1;\r\nreturn 0;\r\n}\r\nstatic int __devinit mxsfb_init_fbinfo(struct mxsfb_info *host)\r\n{\r\nstruct fb_info *fb_info = &host->fb_info;\r\nstruct fb_var_screeninfo *var = &fb_info->var;\r\nstruct mxsfb_platform_data *pdata = host->pdev->dev.platform_data;\r\ndma_addr_t fb_phys;\r\nvoid *fb_virt;\r\nunsigned fb_size = pdata->fb_size;\r\nfb_info->fbops = &mxsfb_ops;\r\nfb_info->flags = FBINFO_FLAG_DEFAULT | FBINFO_READS_FAST;\r\nstrlcpy(fb_info->fix.id, "mxs", sizeof(fb_info->fix.id));\r\nfb_info->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfb_info->fix.ypanstep = 1;\r\nfb_info->fix.visual = FB_VISUAL_TRUECOLOR,\r\nfb_info->fix.accel = FB_ACCEL_NONE;\r\nvar->bits_per_pixel = pdata->default_bpp ? pdata->default_bpp : 16;\r\nvar->nonstd = 0;\r\nvar->activate = FB_ACTIVATE_NOW;\r\nvar->accel_flags = 0;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nhost->dotclk_delay = pdata->dotclk_delay;\r\nhost->ld_intf_width = pdata->ld_intf_width;\r\nif (pdata->fb_phys) {\r\nif (!fb_size)\r\nreturn -EINVAL;\r\nfb_phys = pdata->fb_phys;\r\nif (!request_mem_region(fb_phys, fb_size, host->pdev->name))\r\nreturn -ENOMEM;\r\nfb_virt = ioremap(fb_phys, fb_size);\r\nif (!fb_virt) {\r\nrelease_mem_region(fb_phys, fb_size);\r\nreturn -ENOMEM;\r\n}\r\nhost->mapped = 1;\r\n} else {\r\nif (!fb_size)\r\nfb_size = SZ_2M;\r\nfb_virt = alloc_pages_exact(fb_size, GFP_DMA);\r\nif (!fb_virt)\r\nreturn -ENOMEM;\r\nfb_phys = virt_to_phys(fb_virt);\r\n}\r\nfb_info->fix.smem_start = fb_phys;\r\nfb_info->screen_base = fb_virt;\r\nfb_info->screen_size = fb_info->fix.smem_len = fb_size;\r\nif (mxsfb_restore_mode(host))\r\nmemset(fb_virt, 0, fb_size);\r\nreturn 0;\r\n}\r\nstatic void __devexit mxsfb_free_videomem(struct mxsfb_info *host)\r\n{\r\nstruct fb_info *fb_info = &host->fb_info;\r\nif (host->mapped) {\r\niounmap(fb_info->screen_base);\r\nrelease_mem_region(fb_info->fix.smem_start,\r\nfb_info->screen_size);\r\n} else {\r\nfree_pages_exact(fb_info->screen_base, fb_info->fix.smem_len);\r\n}\r\n}\r\nstatic int __devinit mxsfb_probe(struct platform_device *pdev)\r\n{\r\nstruct mxsfb_platform_data *pdata = pdev->dev.platform_data;\r\nstruct resource *res;\r\nstruct mxsfb_info *host;\r\nstruct fb_info *fb_info;\r\nstruct fb_modelist *modelist;\r\nint i, ret;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platformdata. Giving up\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Cannot get memory IO resource\n");\r\nreturn -ENODEV;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name))\r\nreturn -EBUSY;\r\nfb_info = framebuffer_alloc(sizeof(struct mxsfb_info), &pdev->dev);\r\nif (!fb_info) {\r\ndev_err(&pdev->dev, "Failed to allocate fbdev\n");\r\nret = -ENOMEM;\r\ngoto error_alloc_info;\r\n}\r\nhost = to_imxfb_host(fb_info);\r\nhost->base = ioremap(res->start, resource_size(res));\r\nif (!host->base) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto error_ioremap;\r\n}\r\nhost->pdev = pdev;\r\nplatform_set_drvdata(pdev, host);\r\nhost->devdata = &mxsfb_devdata[pdev->id_entry->driver_data];\r\nhost->clk = clk_get(&host->pdev->dev, NULL);\r\nif (IS_ERR(host->clk)) {\r\nret = PTR_ERR(host->clk);\r\ngoto error_getclock;\r\n}\r\nfb_info->pseudo_palette = kmalloc(sizeof(u32) * 16, GFP_KERNEL);\r\nif (!fb_info->pseudo_palette) {\r\nret = -ENOMEM;\r\ngoto error_pseudo_pallette;\r\n}\r\nINIT_LIST_HEAD(&fb_info->modelist);\r\nret = mxsfb_init_fbinfo(host);\r\nif (ret != 0)\r\ngoto error_init_fb;\r\nfor (i = 0; i < pdata->mode_count; i++)\r\nfb_add_videomode(&pdata->mode_list[i], &fb_info->modelist);\r\nmodelist = list_first_entry(&fb_info->modelist,\r\nstruct fb_modelist, list);\r\nfb_videomode_to_var(&fb_info->var, &modelist->mode);\r\nmxsfb_check_var(&fb_info->var, fb_info);\r\nplatform_set_drvdata(pdev, fb_info);\r\nret = register_framebuffer(fb_info);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev,"Failed to register framebuffer\n");\r\ngoto error_register;\r\n}\r\nif (!host->enabled) {\r\nwritel(0, host->base + LCDC_CTRL);\r\nmxsfb_set_par(fb_info);\r\nmxsfb_enable_controller(fb_info);\r\n}\r\ndev_info(&pdev->dev, "initialized\n");\r\nreturn 0;\r\nerror_register:\r\nif (host->enabled)\r\nclk_disable(host->clk);\r\nfb_destroy_modelist(&fb_info->modelist);\r\nerror_init_fb:\r\nkfree(fb_info->pseudo_palette);\r\nerror_pseudo_pallette:\r\nclk_put(host->clk);\r\nerror_getclock:\r\niounmap(host->base);\r\nerror_ioremap:\r\nframebuffer_release(fb_info);\r\nerror_alloc_info:\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn ret;\r\n}\r\nstatic int __devexit mxsfb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fb_info = platform_get_drvdata(pdev);\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (host->enabled)\r\nmxsfb_disable_controller(fb_info);\r\nunregister_framebuffer(fb_info);\r\nkfree(fb_info->pseudo_palette);\r\nmxsfb_free_videomem(host);\r\niounmap(host->base);\r\nclk_put(host->clk);\r\nframebuffer_release(fb_info);\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init mxsfb_init(void)\r\n{\r\nreturn platform_driver_register(&mxsfb_driver);\r\n}\r\nstatic void __exit mxsfb_exit(void)\r\n{\r\nplatform_driver_unregister(&mxsfb_driver);\r\n}
