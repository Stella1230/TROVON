static void isci_task_refuse(struct isci_host *ihost, struct sas_task *task,\r\nenum service_response response,\r\nenum exec_status status)\r\n{\r\nenum isci_completion_selection disposition;\r\ndisposition = isci_perform_normal_io_completion;\r\ndisposition = isci_task_set_completion_status(task, response, status,\r\ndisposition);\r\nswitch (disposition) {\r\ncase isci_perform_normal_io_completion:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: Normal - task = %p, response=%d, "\r\n"status=%d\n",\r\n__func__, task, response, status);\r\ntask->lldd_task = NULL;\r\nisci_execpath_callback(ihost, task, task->task_done);\r\nbreak;\r\ncase isci_perform_aborted_io_completion:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: Aborted - task = %p, response=%d, "\r\n"status=%d\n",\r\n__func__, task, response, status);\r\nbreak;\r\ncase isci_perform_error_io_completion:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: Error - task = %p, response=%d, "\r\n"status=%d\n",\r\n__func__, task, response, status);\r\nisci_execpath_callback(ihost, task, sas_task_abort);\r\nbreak;\r\ndefault:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci task notification default case!",\r\n__func__);\r\nsas_task_abort(task);\r\nbreak;\r\n}\r\n}\r\nstatic inline int isci_device_io_ready(struct isci_remote_device *idev,\r\nstruct sas_task *task)\r\n{\r\nreturn idev ? test_bit(IDEV_IO_READY, &idev->flags) ||\r\n(test_bit(IDEV_IO_NCQERROR, &idev->flags) &&\r\nisci_task_is_ncq_recovery(task))\r\n: 0;\r\n}\r\nint isci_task_execute_task(struct sas_task *task, int num, gfp_t gfp_flags)\r\n{\r\nstruct isci_host *ihost = dev_to_ihost(task->dev);\r\nstruct isci_remote_device *idev;\r\nunsigned long flags;\r\nbool io_ready;\r\nu16 tag;\r\ndev_dbg(&ihost->pdev->dev, "%s: num=%d\n", __func__, num);\r\nfor_each_sas_task(num, task) {\r\nenum sci_status status = SCI_FAILURE;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nidev = isci_lookup_device(task->dev);\r\nio_ready = isci_device_io_ready(idev, task);\r\ntag = isci_alloc_tag(ihost);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\ndev_dbg(&ihost->pdev->dev,\r\n"task: %p, num: %d dev: %p idev: %p:%#lx cmd = %p\n",\r\ntask, num, task->dev, idev, idev ? idev->flags : 0,\r\ntask->uldd_task);\r\nif (!idev) {\r\nisci_task_refuse(ihost, task, SAS_TASK_UNDELIVERED,\r\nSAS_DEVICE_UNKNOWN);\r\n} else if (!io_ready || tag == SCI_CONTROLLER_INVALID_IO_TAG) {\r\nisci_task_refuse(ihost, task, SAS_TASK_COMPLETE,\r\nSAS_QUEUE_FULL);\r\n} else {\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (task->task_state_flags & SAS_TASK_STATE_ABORTED) {\r\nspin_unlock_irqrestore(&task->task_state_lock,\r\nflags);\r\nisci_task_refuse(ihost, task,\r\nSAS_TASK_UNDELIVERED,\r\nSAM_STAT_TASK_ABORTED);\r\n} else {\r\ntask->task_state_flags |= SAS_TASK_AT_INITIATOR;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nstatus = isci_request_execute(ihost, idev, task, tag);\r\nif (status != SCI_SUCCESS) {\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\ntask->task_state_flags &= ~SAS_TASK_AT_INITIATOR;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nisci_task_refuse(ihost, task,\r\nSAS_TASK_COMPLETE,\r\nSAS_QUEUE_FULL);\r\n}\r\n}\r\n}\r\nif (status != SCI_SUCCESS && tag != SCI_CONTROLLER_INVALID_IO_TAG) {\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nisci_tci_free(ihost, ISCI_TAG_TCI(tag));\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\n}\r\nisci_put_device(idev);\r\n}\r\nreturn 0;\r\n}\r\nstatic enum sci_status isci_sata_management_task_request_build(struct isci_request *ireq)\r\n{\r\nstruct isci_tmf *isci_tmf;\r\nenum sci_status status;\r\nif (tmf_task != ireq->ttype)\r\nreturn SCI_FAILURE;\r\nisci_tmf = isci_request_access_tmf(ireq);\r\nswitch (isci_tmf->tmf_code) {\r\ncase isci_tmf_sata_srst_high:\r\ncase isci_tmf_sata_srst_low: {\r\nstruct host_to_dev_fis *fis = &ireq->stp.cmd;\r\nmemset(fis, 0, sizeof(*fis));\r\nfis->fis_type = 0x27;\r\nfis->flags &= ~0x80;\r\nfis->flags &= 0xF0;\r\nif (isci_tmf->tmf_code == isci_tmf_sata_srst_high)\r\nfis->control |= ATA_SRST;\r\nelse\r\nfis->control &= ~ATA_SRST;\r\nbreak;\r\n}\r\ndefault:\r\nreturn SCI_FAILURE;\r\n}\r\nstatus = sci_task_request_construct_sata(ireq);\r\nreturn status;\r\n}\r\nstatic struct isci_request *isci_task_request_build(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nu16 tag, struct isci_tmf *isci_tmf)\r\n{\r\nenum sci_status status = SCI_FAILURE;\r\nstruct isci_request *ireq = NULL;\r\nstruct domain_device *dev;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_tmf = %p\n", __func__, isci_tmf);\r\ndev = idev->domain_dev;\r\nireq = isci_tmf_request_from_tag(ihost, isci_tmf, tag);\r\nif (!ireq)\r\nreturn NULL;\r\nstatus = sci_task_request_construct(ihost, idev, tag,\r\nireq);\r\nif (status != SCI_SUCCESS) {\r\ndev_warn(&ihost->pdev->dev,\r\n"%s: sci_task_request_construct failed - "\r\n"status = 0x%x\n",\r\n__func__,\r\nstatus);\r\nreturn NULL;\r\n}\r\nif (dev->dev_type == SAS_END_DEV) {\r\nisci_tmf->proto = SAS_PROTOCOL_SSP;\r\nstatus = sci_task_request_construct_ssp(ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn NULL;\r\n}\r\nif (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {\r\nisci_tmf->proto = SAS_PROTOCOL_SATA;\r\nstatus = isci_sata_management_task_request_build(ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn NULL;\r\n}\r\nreturn ireq;\r\n}\r\nstatic int isci_task_execute_tmf(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_tmf *tmf, unsigned long timeout_ms)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nenum sci_task_status status = SCI_TASK_FAILURE;\r\nstruct isci_request *ireq;\r\nint ret = TMF_RESP_FUNC_FAILED;\r\nunsigned long flags;\r\nunsigned long timeleft;\r\nu16 tag;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\ntag = isci_alloc_tag(ihost);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (tag == SCI_CONTROLLER_INVALID_IO_TAG)\r\nreturn ret;\r\nif (!idev ||\r\n(!test_bit(IDEV_IO_READY, &idev->flags) &&\r\n!test_bit(IDEV_IO_NCQERROR, &idev->flags))) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev = %p not ready (%#lx)\n",\r\n__func__,\r\nidev, idev ? idev->flags : 0);\r\ngoto err_tci;\r\n} else\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev = %p\n",\r\n__func__, idev);\r\ntmf->complete = &completion;\r\nireq = isci_task_request_build(ihost, idev, tag, tmf);\r\nif (!ireq)\r\ngoto err_tci;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nstatus = sci_controller_start_task(ihost, idev, ireq);\r\nif (status != SCI_TASK_SUCCESS) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: start_io failed - status = 0x%x, request = %p\n",\r\n__func__,\r\nstatus,\r\nireq);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\ngoto err_tci;\r\n}\r\nif (tmf->cb_state_func != NULL)\r\ntmf->cb_state_func(isci_tmf_started, tmf, tmf->cb_data);\r\nisci_request_change_state(ireq, started);\r\nlist_add(&ireq->dev_node, &idev->reqs_in_process);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\ntimeleft = wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(timeout_ms));\r\nif (timeleft == 0) {\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nif (tmf->cb_state_func != NULL)\r\ntmf->cb_state_func(isci_tmf_timed_out, tmf, tmf->cb_data);\r\nsci_controller_terminate_request(ihost,\r\nidev,\r\nireq);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nwait_for_completion(tmf->complete);\r\n}\r\nisci_print_tmf(tmf);\r\nif (tmf->status == SCI_SUCCESS)\r\nret = TMF_RESP_FUNC_COMPLETE;\r\nelse if (tmf->status == SCI_FAILURE_IO_RESPONSE_VALID) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: tmf.status == "\r\n"SCI_FAILURE_IO_RESPONSE_VALID\n",\r\n__func__);\r\nret = TMF_RESP_FUNC_COMPLETE;\r\n}\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: completed request = %p\n",\r\n__func__,\r\nireq);\r\nreturn ret;\r\nerr_tci:\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nisci_tci_free(ihost, ISCI_TAG_TCI(tag));\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void isci_task_build_tmf(struct isci_tmf *tmf,\r\nenum isci_tmf_function_codes code,\r\nvoid (*tmf_sent_cb)(enum isci_tmf_cb_state,\r\nstruct isci_tmf *,\r\nvoid *),\r\nvoid *cb_data)\r\n{\r\nmemset(tmf, 0, sizeof(*tmf));\r\ntmf->tmf_code = code;\r\ntmf->cb_state_func = tmf_sent_cb;\r\ntmf->cb_data = cb_data;\r\n}\r\nstatic void isci_task_build_abort_task_tmf(struct isci_tmf *tmf,\r\nenum isci_tmf_function_codes code,\r\nvoid (*tmf_sent_cb)(enum isci_tmf_cb_state,\r\nstruct isci_tmf *,\r\nvoid *),\r\nstruct isci_request *old_request)\r\n{\r\nisci_task_build_tmf(tmf, code, tmf_sent_cb, old_request);\r\ntmf->io_tag = old_request->io_tag;\r\n}\r\nstatic enum isci_request_status isci_task_validate_request_to_abort(\r\nstruct isci_request *isci_request,\r\nstruct isci_host *isci_host,\r\nstruct isci_remote_device *isci_device,\r\nstruct completion *aborted_io_completion)\r\n{\r\nenum isci_request_status old_state = unallocated;\r\nif (isci_request && !list_empty(&isci_request->dev_node)) {\r\nold_state = isci_request_change_started_to_aborted(\r\nisci_request, aborted_io_completion);\r\n}\r\nreturn old_state;\r\n}\r\nstatic void isci_request_cleanup_completed_loiterer(\r\nstruct isci_host *isci_host,\r\nstruct isci_remote_device *isci_device,\r\nstruct isci_request *isci_request,\r\nstruct sas_task *task)\r\n{\r\nunsigned long flags;\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: isci_device=%p, request=%p, task=%p\n",\r\n__func__, isci_device, isci_request, task);\r\nif (task != NULL) {\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\ntask->lldd_task = NULL;\r\ntask->task_state_flags &= ~SAS_TASK_NEED_DEV_RESET;\r\nisci_set_task_doneflags(task);\r\nif (!(task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\ntask->task_done(task);\r\n} else\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\n}\r\nif (isci_request != NULL) {\r\nspin_lock_irqsave(&isci_host->scic_lock, flags);\r\nlist_del_init(&isci_request->dev_node);\r\nspin_unlock_irqrestore(&isci_host->scic_lock, flags);\r\n}\r\n}\r\nstatic void isci_terminate_request_core(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *isci_request)\r\n{\r\nenum sci_status status = SCI_SUCCESS;\r\nbool was_terminated = false;\r\nbool needs_cleanup_handling = false;\r\nenum isci_request_status request_status;\r\nunsigned long flags;\r\nunsigned long termination_completed = 1;\r\nstruct completion *io_request_completion;\r\nstruct sas_task *task;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: device = %p; request = %p\n",\r\n__func__, idev, isci_request);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nio_request_completion = isci_request->io_request_completion;\r\ntask = (isci_request->ttype == io_task)\r\n? isci_request_access_task(isci_request)\r\n: NULL;\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &isci_request->flags);\r\nif (!test_bit(IREQ_TERMINATED, &isci_request->flags)) {\r\nwas_terminated = true;\r\nneeds_cleanup_handling = true;\r\nstatus = sci_controller_terminate_request(ihost,\r\nidev,\r\nisci_request);\r\n}\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (status != SCI_SUCCESS) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: sci_controller_terminate_request"\r\n" returned = 0x%x\n",\r\n__func__, status);\r\nisci_request->io_request_completion = NULL;\r\n} else {\r\nif (was_terminated) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: before completion wait (%p/%p)\n",\r\n__func__, isci_request, io_request_completion);\r\n#define TERMINATION_TIMEOUT_MSEC 500\r\ntermination_completed\r\n= wait_for_completion_timeout(\r\nio_request_completion,\r\nmsecs_to_jiffies(TERMINATION_TIMEOUT_MSEC));\r\nif (!termination_completed) {\r\nspin_lock_irqsave(&ihost->scic_lock,\r\nflags);\r\nif (!test_bit(IREQ_TERMINATED, &isci_request->flags)) {\r\nisci_request->status = dead;\r\nisci_request->io_request_completion\r\n= NULL;\r\nif (isci_request->ttype == io_task) {\r\nisci_request->ttype_ptr.io_task_ptr\r\n= NULL;\r\n}\r\n} else\r\ntermination_completed = 1;\r\nspin_unlock_irqrestore(&ihost->scic_lock,\r\nflags);\r\nif (!termination_completed) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: *** Timeout waiting for "\r\n"termination(%p/%p)\n",\r\n__func__, io_request_completion,\r\nisci_request);\r\nisci_request = NULL;\r\n}\r\n}\r\nif (termination_completed)\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: after completion wait (%p/%p)\n",\r\n__func__, isci_request, io_request_completion);\r\n}\r\nif (termination_completed) {\r\nisci_request->io_request_completion = NULL;\r\nspin_lock_irqsave(&isci_request->state_lock, flags);\r\nrequest_status = isci_request->status;\r\nif ((isci_request->ttype == io_task)\r\n&& ((request_status == aborted)\r\n|| (request_status == aborting)\r\n|| (request_status == terminating)\r\n|| (request_status == completed)\r\n|| (request_status == dead)\r\n)\r\n) {\r\nneeds_cleanup_handling = true;\r\n}\r\nspin_unlock_irqrestore(&isci_request->state_lock, flags);\r\n}\r\nif (needs_cleanup_handling)\r\nisci_request_cleanup_completed_loiterer(\r\nihost, idev, isci_request, task);\r\n}\r\n}\r\nvoid isci_terminate_pending_requests(struct isci_host *ihost,\r\nstruct isci_remote_device *idev)\r\n{\r\nstruct completion request_completion;\r\nenum isci_request_status old_state;\r\nunsigned long flags;\r\nLIST_HEAD(list);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nlist_splice_init(&idev->reqs_in_process, &list);\r\nwhile (!list_empty(&list)) {\r\nstruct isci_request *ireq = list_entry(list.next, typeof(*ireq), dev_node);\r\nold_state = isci_request_change_started_to_newstate(ireq,\r\n&request_completion,\r\nterminating);\r\nswitch (old_state) {\r\ncase started:\r\ncase completed:\r\ncase aborting:\r\nbreak;\r\ndefault:\r\nlist_move(&ireq->dev_node, &idev->reqs_in_process);\r\nireq = NULL;\r\nbreak;\r\n}\r\nif (!ireq)\r\ncontinue;\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\ninit_completion(&request_completion);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev=%p request=%p; task=%p old_state=%d\n",\r\n__func__, idev, ireq,\r\nireq->ttype == io_task ? isci_request_access_task(ireq) : NULL,\r\nold_state);\r\nisci_terminate_request_core(ihost, idev, ireq);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\n}\r\nstatic int isci_task_send_lu_reset_sas(\r\nstruct isci_host *isci_host,\r\nstruct isci_remote_device *isci_device,\r\nu8 *lun)\r\n{\r\nstruct isci_tmf tmf;\r\nint ret = TMF_RESP_FUNC_FAILED;\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: isci_host = %p, isci_device = %p\n",\r\n__func__, isci_host, isci_device);\r\nisci_task_build_tmf(&tmf, isci_tmf_ssp_lun_reset, NULL, NULL);\r\n#define ISCI_LU_RESET_TIMEOUT_MS 2000\r\nret = isci_task_execute_tmf(isci_host, isci_device, &tmf, ISCI_LU_RESET_TIMEOUT_MS);\r\nif (ret == TMF_RESP_FUNC_COMPLETE)\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: %p: TMF_LU_RESET passed\n",\r\n__func__, isci_device);\r\nelse\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: %p: TMF_LU_RESET failed (%x)\n",\r\n__func__, isci_device, ret);\r\nreturn ret;\r\n}\r\nstatic int isci_task_send_lu_reset_sata(struct isci_host *ihost,\r\nstruct isci_remote_device *idev, u8 *lun)\r\n{\r\nint ret = TMF_RESP_FUNC_FAILED;\r\nstruct isci_tmf tmf;\r\n#define ISCI_SRST_TIMEOUT_MS 25000\r\nisci_task_build_tmf(&tmf, isci_tmf_sata_srst_high, NULL, NULL);\r\nret = isci_task_execute_tmf(ihost, idev, &tmf, ISCI_SRST_TIMEOUT_MS);\r\nif (ret != TMF_RESP_FUNC_COMPLETE) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: Assert SRST failed (%p) = %x",\r\n__func__, idev, ret);\r\n}\r\nreturn ret;\r\n}\r\nint isci_task_lu_reset(struct domain_device *domain_device, u8 *lun)\r\n{\r\nstruct isci_host *isci_host = dev_to_ihost(domain_device);\r\nstruct isci_remote_device *isci_device;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&isci_host->scic_lock, flags);\r\nisci_device = isci_lookup_device(domain_device);\r\nspin_unlock_irqrestore(&isci_host->scic_lock, flags);\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: domain_device=%p, isci_host=%p; isci_device=%p\n",\r\n__func__, domain_device, isci_host, isci_device);\r\nif (isci_device)\r\nset_bit(IDEV_EH, &isci_device->flags);\r\nif (!isci_device ||\r\nisci_device_is_reset_pending(isci_host, isci_device)) {\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: No dev (%p), or "\r\n"RESET PENDING: domain_device=%p\n",\r\n__func__, isci_device, domain_device);\r\nret = TMF_RESP_FUNC_FAILED;\r\ngoto out;\r\n}\r\nif (sas_protocol_ata(domain_device->tproto)) {\r\nret = isci_task_send_lu_reset_sata(isci_host, isci_device, lun);\r\n} else\r\nret = isci_task_send_lu_reset_sas(isci_host, isci_device, lun);\r\nif (ret == TMF_RESP_FUNC_COMPLETE)\r\nisci_terminate_pending_requests(isci_host,\r\nisci_device);\r\nout:\r\nisci_put_device(isci_device);\r\nreturn ret;\r\n}\r\nint isci_task_clear_nexus_port(struct asd_sas_port *port)\r\n{\r\nreturn TMF_RESP_FUNC_FAILED;\r\n}\r\nint isci_task_clear_nexus_ha(struct sas_ha_struct *ha)\r\n{\r\nreturn TMF_RESP_FUNC_FAILED;\r\n}\r\nstatic void isci_abort_task_process_cb(\r\nenum isci_tmf_cb_state cb_state,\r\nstruct isci_tmf *tmf,\r\nvoid *cb_data)\r\n{\r\nstruct isci_request *old_request;\r\nold_request = (struct isci_request *)cb_data;\r\ndev_dbg(&old_request->isci_host->pdev->dev,\r\n"%s: tmf=%p, old_request=%p\n",\r\n__func__, tmf, old_request);\r\nswitch (cb_state) {\r\ncase isci_tmf_started:\r\nif ((old_request->status != aborted)\r\n&& (old_request->status != completed))\r\ndev_dbg(&old_request->isci_host->pdev->dev,\r\n"%s: Bad request status (%d): tmf=%p, old_request=%p\n",\r\n__func__, old_request->status, tmf, old_request);\r\nbreak;\r\ncase isci_tmf_timed_out:\r\nisci_request_change_state(old_request, aborting);\r\nbreak;\r\ndefault:\r\ndev_dbg(&old_request->isci_host->pdev->dev,\r\n"%s: Bad cb_state (%d): tmf=%p, old_request=%p\n",\r\n__func__, cb_state, tmf, old_request);\r\nbreak;\r\n}\r\n}\r\nint isci_task_abort_task(struct sas_task *task)\r\n{\r\nstruct isci_host *isci_host = dev_to_ihost(task->dev);\r\nDECLARE_COMPLETION_ONSTACK(aborted_io_completion);\r\nstruct isci_request *old_request = NULL;\r\nenum isci_request_status old_state;\r\nstruct isci_remote_device *isci_device = NULL;\r\nstruct isci_tmf tmf;\r\nint ret = TMF_RESP_FUNC_FAILED;\r\nunsigned long flags;\r\nbool any_dev_reset = false;\r\nspin_lock_irqsave(&isci_host->scic_lock, flags);\r\nspin_lock(&task->task_state_lock);\r\nold_request = task->lldd_task;\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE) &&\r\n(task->task_state_flags & SAS_TASK_AT_INITIATOR) &&\r\nold_request)\r\nisci_device = isci_lookup_device(task->dev);\r\nspin_unlock(&task->task_state_lock);\r\nspin_unlock_irqrestore(&isci_host->scic_lock, flags);\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: task = %p\n", __func__, task);\r\nif (!isci_device || !old_request)\r\ngoto out;\r\nset_bit(IDEV_EH, &isci_device->flags);\r\nif (sas_protocol_ata(task->task_proto)) {\r\ndev_dbg(&isci_host->pdev->dev,\r\n" task %p is for a STP/SATA device;"\r\n" returning TMF_RESP_FUNC_FAILED\n"\r\n" to cause a LUN reset...\n", task);\r\ngoto out;\r\n}\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: old_request == %p\n", __func__, old_request);\r\nany_dev_reset = isci_device_is_reset_pending(isci_host, isci_device);\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nany_dev_reset = any_dev_reset || (task->task_state_flags & SAS_TASK_NEED_DEV_RESET);\r\nif ((old_request == NULL) || any_dev_reset) {\r\nif (any_dev_reset) {\r\ntask->task_state_flags &= ~SAS_TASK_STATE_DONE;\r\ntask->task_state_flags |= SAS_TASK_NEED_DEV_RESET;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nret = TMF_RESP_FUNC_FAILED;\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: Failing task abort in order to "\r\n"escalate to target reset because\n"\r\n"SAS_TASK_NEED_DEV_RESET is set for "\r\n"task %p on dev %p\n",\r\n__func__, task, isci_device);\r\n} else {\r\nisci_set_task_doneflags(task);\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nret = TMF_RESP_FUNC_COMPLETE;\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: abort task not needed for %p\n",\r\n__func__, task);\r\n}\r\ngoto out;\r\n} else {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\n}\r\nspin_lock_irqsave(&isci_host->scic_lock, flags);\r\nold_state = isci_task_validate_request_to_abort(\r\nold_request, isci_host, isci_device,\r\n&aborted_io_completion);\r\nif ((old_state != started) &&\r\n(old_state != completed) &&\r\n(old_state != aborting)) {\r\nspin_unlock_irqrestore(&isci_host->scic_lock, flags);\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: device = %p; old_request %p already being aborted\n",\r\n__func__,\r\nisci_device, old_request);\r\nret = TMF_RESP_FUNC_COMPLETE;\r\ngoto out;\r\n}\r\nif (task->task_proto == SAS_PROTOCOL_SMP ||\r\ntest_bit(IREQ_COMPLETE_IN_TARGET, &old_request->flags)) {\r\nspin_unlock_irqrestore(&isci_host->scic_lock, flags);\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: SMP request (%d)"\r\n" or complete_in_target (%d), thus no TMF\n",\r\n__func__, (task->task_proto == SAS_PROTOCOL_SMP),\r\ntest_bit(IREQ_COMPLETE_IN_TARGET, &old_request->flags));\r\nisci_task_all_done(task);\r\nret = TMF_RESP_FUNC_COMPLETE;\r\n} else {\r\nisci_task_build_abort_task_tmf(&tmf, isci_tmf_ssp_task_abort,\r\nisci_abort_task_process_cb,\r\nold_request);\r\nspin_unlock_irqrestore(&isci_host->scic_lock, flags);\r\n#define ISCI_ABORT_TASK_TIMEOUT_MS 500\r\nret = isci_task_execute_tmf(isci_host, isci_device, &tmf,\r\nISCI_ABORT_TASK_TIMEOUT_MS);\r\nif (ret != TMF_RESP_FUNC_COMPLETE)\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: isci_task_send_tmf failed\n",\r\n__func__);\r\n}\r\nif (ret == TMF_RESP_FUNC_COMPLETE) {\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &old_request->flags);\r\nisci_terminate_request_core(isci_host, isci_device, old_request);\r\n}\r\nold_request->io_request_completion = NULL;\r\nout:\r\nisci_put_device(isci_device);\r\nreturn ret;\r\n}\r\nint isci_task_abort_task_set(\r\nstruct domain_device *d_device,\r\nu8 *lun)\r\n{\r\nreturn TMF_RESP_FUNC_FAILED;\r\n}\r\nint isci_task_clear_aca(\r\nstruct domain_device *d_device,\r\nu8 *lun)\r\n{\r\nreturn TMF_RESP_FUNC_FAILED;\r\n}\r\nint isci_task_clear_task_set(\r\nstruct domain_device *d_device,\r\nu8 *lun)\r\n{\r\nreturn TMF_RESP_FUNC_FAILED;\r\n}\r\nint isci_task_query_task(\r\nstruct sas_task *task)\r\n{\r\nif (task->task_state_flags & SAS_TASK_NEED_DEV_RESET)\r\nreturn TMF_RESP_FUNC_FAILED;\r\nelse\r\nreturn TMF_RESP_FUNC_SUCC;\r\n}\r\nvoid\r\nisci_task_request_complete(struct isci_host *ihost,\r\nstruct isci_request *ireq,\r\nenum sci_task_status completion_status)\r\n{\r\nstruct isci_tmf *tmf = isci_request_access_tmf(ireq);\r\nstruct completion *tmf_complete;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: request = %p, status=%d\n",\r\n__func__, ireq, completion_status);\r\nisci_request_change_state(ireq, completed);\r\ntmf->status = completion_status;\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &ireq->flags);\r\nif (tmf->proto == SAS_PROTOCOL_SSP) {\r\nmemcpy(&tmf->resp.resp_iu,\r\n&ireq->ssp.rsp,\r\nSSP_RESP_IU_MAX_SIZE);\r\n} else if (tmf->proto == SAS_PROTOCOL_SATA) {\r\nmemcpy(&tmf->resp.d2h_fis,\r\n&ireq->stp.rsp,\r\nsizeof(struct dev_to_host_fis));\r\n}\r\ntmf_complete = tmf->complete;\r\nsci_controller_complete_io(ihost, ireq->target_device, ireq);\r\nset_bit(IREQ_TERMINATED, &ireq->flags);\r\nisci_request_change_state(ireq, unallocated);\r\nlist_del_init(&ireq->dev_node);\r\ncomplete(tmf_complete);\r\n}\r\nstatic void isci_smp_task_timedout(unsigned long _task)\r\n{\r\nstruct sas_task *task = (void *) _task;\r\nunsigned long flags;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\r\ntask->task_state_flags |= SAS_TASK_STATE_ABORTED;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\ncomplete(&task->completion);\r\n}\r\nstatic void isci_smp_task_done(struct sas_task *task)\r\n{\r\nif (!del_timer(&task->timer))\r\nreturn;\r\ncomplete(&task->completion);\r\n}\r\nstatic struct sas_task *isci_alloc_task(void)\r\n{\r\nstruct sas_task *task = kzalloc(sizeof(*task), GFP_KERNEL);\r\nif (task) {\r\nINIT_LIST_HEAD(&task->list);\r\nspin_lock_init(&task->task_state_lock);\r\ntask->task_state_flags = SAS_TASK_STATE_PENDING;\r\ninit_timer(&task->timer);\r\ninit_completion(&task->completion);\r\n}\r\nreturn task;\r\n}\r\nstatic void isci_free_task(struct isci_host *ihost, struct sas_task *task)\r\n{\r\nif (task) {\r\nBUG_ON(!list_empty(&task->list));\r\nkfree(task);\r\n}\r\n}\r\nstatic int isci_smp_execute_task(struct isci_host *ihost,\r\nstruct domain_device *dev, void *req,\r\nint req_size, void *resp, int resp_size)\r\n{\r\nint res, retry;\r\nstruct sas_task *task = NULL;\r\nfor (retry = 0; retry < 3; retry++) {\r\ntask = isci_alloc_task();\r\nif (!task)\r\nreturn -ENOMEM;\r\ntask->dev = dev;\r\ntask->task_proto = dev->tproto;\r\nsg_init_one(&task->smp_task.smp_req, req, req_size);\r\nsg_init_one(&task->smp_task.smp_resp, resp, resp_size);\r\ntask->task_done = isci_smp_task_done;\r\ntask->timer.data = (unsigned long) task;\r\ntask->timer.function = isci_smp_task_timedout;\r\ntask->timer.expires = jiffies + 10*HZ;\r\nadd_timer(&task->timer);\r\nres = isci_task_execute_task(task, 1, GFP_KERNEL);\r\nif (res) {\r\ndel_timer(&task->timer);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: executing SMP task failed:%d\n",\r\n__func__, res);\r\ngoto ex_err;\r\n}\r\nwait_for_completion(&task->completion);\r\nres = -ECOMM;\r\nif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: smp task timed out or aborted\n",\r\n__func__);\r\nisci_task_abort_task(task);\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: SMP task aborted and not done\n",\r\n__func__);\r\ngoto ex_err;\r\n}\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAM_STAT_GOOD) {\r\nres = 0;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAS_DATA_UNDERRUN) {\r\nres = task->task_status.residual;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAS_DATA_OVERRUN) {\r\nres = -EMSGSIZE;\r\nbreak;\r\n} else {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: task to dev %016llx response: 0x%x "\r\n"status 0x%x\n", __func__,\r\nSAS_ADDR(dev->sas_addr),\r\ntask->task_status.resp,\r\ntask->task_status.stat);\r\nisci_free_task(ihost, task);\r\ntask = NULL;\r\n}\r\n}\r\nex_err:\r\nBUG_ON(retry == 3 && task != NULL);\r\nisci_free_task(ihost, task);\r\nreturn res;\r\n}\r\nint isci_smp_get_phy_attached_dev_type(struct isci_host *ihost,\r\nstruct domain_device *dev,\r\nint phy_id, int *adt)\r\n{\r\nstruct smp_resp *disc_resp;\r\nu8 *disc_req;\r\nint res;\r\ndisc_resp = kzalloc(DISCOVER_RESP_SIZE, GFP_KERNEL);\r\nif (!disc_resp)\r\nreturn -ENOMEM;\r\ndisc_req = kzalloc(DISCOVER_REQ_SIZE, GFP_KERNEL);\r\nif (disc_req) {\r\ndisc_req[0] = SMP_REQUEST;\r\ndisc_req[1] = SMP_DISCOVER;\r\ndisc_req[9] = phy_id;\r\n} else {\r\nkfree(disc_resp);\r\nreturn -ENOMEM;\r\n}\r\nres = isci_smp_execute_task(ihost, dev, disc_req, DISCOVER_REQ_SIZE,\r\ndisc_resp, DISCOVER_RESP_SIZE);\r\nif (!res) {\r\nif (disc_resp->result != SMP_RESP_FUNC_ACC)\r\nres = disc_resp->result;\r\nelse\r\n*adt = disc_resp->disc.attached_dev_type;\r\n}\r\nkfree(disc_req);\r\nkfree(disc_resp);\r\nreturn res;\r\n}\r\nstatic void isci_wait_for_smp_phy_reset(struct isci_remote_device *idev, int phy_num)\r\n{\r\nstruct domain_device *dev = idev->domain_dev;\r\nstruct isci_port *iport = idev->isci_port;\r\nstruct isci_host *ihost = iport->isci_host;\r\nint res, iteration = 0, attached_device_type;\r\n#define STP_WAIT_MSECS 25000\r\nunsigned long tmo = msecs_to_jiffies(STP_WAIT_MSECS);\r\nunsigned long deadline = jiffies + tmo;\r\nenum {\r\nSMP_PHYWAIT_PHYDOWN,\r\nSMP_PHYWAIT_PHYUP,\r\nSMP_PHYWAIT_DONE\r\n} phy_state = SMP_PHYWAIT_PHYDOWN;\r\nwhile (time_is_after_jiffies(deadline) && phy_state != SMP_PHYWAIT_DONE) {\r\nint event = atomic_read(&iport->event);\r\n++iteration;\r\ntmo = wait_event_timeout(ihost->eventq,\r\nevent != atomic_read(&iport->event) ||\r\n!test_bit(IPORT_BCN_BLOCKED, &iport->flags),\r\ntmo);\r\nif (!test_bit(IPORT_BCN_BLOCKED, &iport->flags))\r\nbreak;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: iport %p, iteration %d,"\r\n" phase %d: time_remaining %lu, bcns = %d\n",\r\n__func__, iport, iteration, phy_state,\r\ntmo, test_bit(IPORT_BCN_PENDING, &iport->flags));\r\nres = isci_smp_get_phy_attached_dev_type(ihost, dev, phy_num,\r\n&attached_device_type);\r\ntmo = deadline - jiffies;\r\nif (res) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: iteration %d, phase %d:"\r\n" SMP error=%d, time_remaining=%lu\n",\r\n__func__, iteration, phy_state, res, tmo);\r\nbreak;\r\n}\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: iport %p, iteration %d,"\r\n" phase %d: time_remaining %lu, bcns = %d, "\r\n"attdevtype = %x\n",\r\n__func__, iport, iteration, phy_state,\r\ntmo, test_bit(IPORT_BCN_PENDING, &iport->flags),\r\nattached_device_type);\r\nswitch (phy_state) {\r\ncase SMP_PHYWAIT_PHYDOWN:\r\nif (!attached_device_type)\r\nphy_state = SMP_PHYWAIT_PHYUP;\r\nbreak;\r\ncase SMP_PHYWAIT_PHYUP:\r\nif (attached_device_type)\r\nphy_state = SMP_PHYWAIT_DONE;\r\nbreak;\r\ncase SMP_PHYWAIT_DONE:\r\nbreak;\r\n}\r\n}\r\ndev_dbg(&ihost->pdev->dev, "%s: done\n", __func__);\r\n}\r\nstatic int isci_reset_device(struct isci_host *ihost,\r\nstruct isci_remote_device *idev)\r\n{\r\nstruct sas_phy *phy = sas_find_local_phy(idev->domain_dev);\r\nstruct isci_port *iport = idev->isci_port;\r\nenum sci_status status;\r\nunsigned long flags;\r\nint rc;\r\ndev_dbg(&ihost->pdev->dev, "%s: idev %p\n", __func__, idev);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nstatus = sci_remote_device_reset(idev);\r\nif (status != SCI_SUCCESS) {\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: sci_remote_device_reset(%p) returned %d!\n",\r\n__func__, idev, status);\r\nreturn TMF_RESP_FUNC_FAILED;\r\n}\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nisci_device_clear_reset_pending(ihost, idev);\r\nif (!scsi_is_sas_phy_local(phy))\r\nset_bit(IPORT_BCN_BLOCKED, &iport->flags);\r\nrc = sas_phy_reset(phy, true);\r\nisci_remote_device_nuke_requests(ihost, idev);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nstatus = sci_remote_device_reset_complete(idev);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (!scsi_is_sas_phy_local(phy)) {\r\nisci_wait_for_smp_phy_reset(idev, phy->number);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nisci_port_bcn_enable(ihost, idev->isci_port);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\n}\r\nif (status != SCI_SUCCESS) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: sci_remote_device_reset_complete(%p) "\r\n"returned %d!\n", __func__, idev, status);\r\n}\r\ndev_dbg(&ihost->pdev->dev, "%s: idev %p complete.\n", __func__, idev);\r\nreturn rc;\r\n}\r\nint isci_task_I_T_nexus_reset(struct domain_device *dev)\r\n{\r\nstruct isci_host *ihost = dev_to_ihost(dev);\r\nstruct isci_remote_device *idev;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nidev = isci_lookup_device(dev);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (!idev || !test_bit(IDEV_EH, &idev->flags)) {\r\nret = TMF_RESP_FUNC_COMPLETE;\r\ngoto out;\r\n}\r\nret = isci_reset_device(ihost, idev);\r\nout:\r\nisci_put_device(idev);\r\nreturn ret;\r\n}\r\nint isci_bus_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nstruct domain_device *dev = sdev_to_domain_dev(cmd->device);\r\nstruct isci_host *ihost = dev_to_ihost(dev);\r\nstruct isci_remote_device *idev;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nidev = isci_lookup_device(dev);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (!idev) {\r\nret = TMF_RESP_FUNC_COMPLETE;\r\ngoto out;\r\n}\r\nret = isci_reset_device(ihost, idev);\r\nout:\r\nisci_put_device(idev);\r\nreturn ret;\r\n}
