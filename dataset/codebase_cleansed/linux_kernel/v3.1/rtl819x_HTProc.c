void HTUpdateDefaultSetting(struct ieee80211_device* ieee)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\npHTInfo->bRegShortGI20MHz= 1;\r\npHTInfo->bRegShortGI40MHz= 1;\r\npHTInfo->bRegBW40MHz = 1;\r\nif(pHTInfo->bRegBW40MHz)\r\npHTInfo->bRegSuppCCK = 1;\r\nelse\r\npHTInfo->bRegSuppCCK = true;\r\npHTInfo->nAMSDU_MaxSize = 7935UL;\r\npHTInfo->bAMSDU_Support = 0;\r\npHTInfo->bAMPDUEnable = 1;\r\npHTInfo->AMPDU_Factor = 2;\r\npHTInfo->MPDU_Density = 0;\r\npHTInfo->SelfMimoPs = 3;\r\nif(pHTInfo->SelfMimoPs == 2)\r\npHTInfo->SelfMimoPs = 3;\r\nieee->bTxDisableRateFallBack = 0;\r\nieee->bTxUseDriverAssingedRate = 0;\r\n#ifdef TO_DO_LIST\r\npMgntInfo->bTxEnableFwCalcDur = (BOOLEAN)pNdisCommon->bRegTxEnableFwCalcDur;\r\n#endif\r\npHTInfo->bRegRT2RTAggregation = 1;\r\npHTInfo->bRegRxReorderEnable = 1;\r\npHTInfo->RxReorderWinSize = 64;\r\npHTInfo->RxReorderPendingTime = 30;\r\n#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE\r\npHTInfo->UsbTxAggrNum = 4;\r\n#endif\r\n#ifdef USB_RX_AGGREGATION_SUPPORT\r\npHTInfo->UsbRxFwAggrEn = 1;\r\npHTInfo->UsbRxFwAggrPageNum = 24;\r\npHTInfo->UsbRxFwAggrPacketNum = 8;\r\npHTInfo->UsbRxFwAggrTimeout = 16;\r\n#endif\r\n}\r\nvoid HTDebugHTCapability(u8* CapIE, u8* TitleString )\r\n{\r\nstatic u8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\r\nPHT_CAPABILITY_ELE pCapELE;\r\nif(!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap)))\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __FUNCTION__);\r\npCapELE = (PHT_CAPABILITY_ELE)(&CapIE[4]);\r\n}else\r\npCapELE = (PHT_CAPABILITY_ELE)(&CapIE[0]);\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "<Log HT Capability>. Called by %s\n", TitleString );\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tSupported Channel Width = %s\n", (pCapELE->ChlWidth)?"20MHz": "20/40MHz");\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tSupport Short GI for 20M = %s\n", (pCapELE->ShortGI20Mhz)?"YES": "NO");\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tSupport Short GI for 40M = %s\n", (pCapELE->ShortGI40Mhz)?"YES": "NO");\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tSupport TX STBC = %s\n", (pCapELE->TxSTBC)?"YES": "NO");\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tMax AMSDU Size = %s\n", (pCapELE->MaxAMSDUSize)?"3839": "7935");\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tSupport CCK in 20/40 mode = %s\n", (pCapELE->DssCCk)?"YES": "NO");\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tMax AMPDU Factor = %d\n", pCapELE->MaxRxAMPDUFactor);\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tMPDU Density = %d\n", pCapELE->MPDUDensity);\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tMCS Rate Set = [%x][%x][%x][%x][%x]\n", pCapELE->MCS[0],\\r\npCapELE->MCS[1], pCapELE->MCS[2], pCapELE->MCS[3], pCapELE->MCS[4]);\r\n}\r\nvoid HTDebugHTInfo(u8* InfoIE, u8* TitleString)\r\n{\r\nstatic u8 EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};\r\nPHT_INFORMATION_ELE pHTInfoEle;\r\nif(!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo)))\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __FUNCTION__);\r\npHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[4]);\r\n}else\r\npHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[0]);\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "<Log HT Information Element>. Called by %s\n", TitleString);\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tPrimary channel = %d\n", pHTInfoEle->ControlChl);\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tSenondary channel =");\r\nswitch(pHTInfoEle->ExtChlOffset)\r\n{\r\ncase 0:\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "Not Present\n");\r\nbreak;\r\ncase 1:\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "Upper channel\n");\r\nbreak;\r\ncase 2:\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "Reserved. Eooro!!!\n");\r\nbreak;\r\ncase 3:\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "Lower Channel\n");\r\nbreak;\r\n}\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tRecommended channel width = %s\n", (pHTInfoEle->RecommemdedTxWidth)?"20Mhz": "40Mhz");\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tOperation mode for protection = ");\r\nswitch(pHTInfoEle->OptMode)\r\n{\r\ncase 0:\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "No Protection\n");\r\nbreak;\r\ncase 1:\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "HT non-member protection mode\n");\r\nbreak;\r\ncase 2:\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "Suggest to open protection\n");\r\nbreak;\r\ncase 3:\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "HT mixed mode\n");\r\nbreak;\r\n}\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "\tBasic MCS Rate Set = [%x][%x][%x][%x][%x]\n", pHTInfoEle->BasicMSC[0],\\r\npHTInfoEle->BasicMSC[1], pHTInfoEle->BasicMSC[2], pHTInfoEle->BasicMSC[3], pHTInfoEle->BasicMSC[4]);\r\n}\r\nbool IsHTHalfNmode40Bandwidth(struct ieee80211_device* ieee)\r\n{\r\nbool retValue = false;\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nif(pHTInfo->bCurrentHTSupport == false )\r\nretValue = false;\r\nelse if(pHTInfo->bRegBW40MHz == false)\r\nretValue = false;\r\nelse if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee))\r\nretValue = false;\r\nelse if(((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ChlWidth)\r\nretValue = true;\r\nelse\r\nretValue = false;\r\nreturn retValue;\r\n}\r\nbool IsHTHalfNmodeSGI(struct ieee80211_device* ieee, bool is40MHz)\r\n{\r\nbool retValue = false;\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nif(pHTInfo->bCurrentHTSupport == false )\r\nretValue = false;\r\nelse if (!ieee->GetHalfNmodeSupportByAPsHandler(ieee))\r\nretValue = false;\r\nelse if(is40MHz)\r\n{\r\nif(((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ShortGI40Mhz)\r\nretValue = true;\r\nelse\r\nretValue = false;\r\n}\r\nelse\r\n{\r\nif(((PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf))->ShortGI20Mhz)\r\nretValue = true;\r\nelse\r\nretValue = false;\r\n}\r\nreturn retValue;\r\n}\r\nu16 HTHalfMcsToDataRate(struct ieee80211_device* ieee, u8 nMcsRate)\r\n{\r\nu8 is40MHz;\r\nu8 isShortGI;\r\nis40MHz = (IsHTHalfNmode40Bandwidth(ieee))?1:0;\r\nisShortGI = (IsHTHalfNmodeSGI(ieee, is40MHz))? 1:0;\r\nreturn MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate&0x7f)];\r\n}\r\nu16 HTMcsToDataRate( struct ieee80211_device* ieee, u8 nMcsRate)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nu8 is40MHz = (pHTInfo->bCurBW40MHz)?1:0;\r\nu8 isShortGI = (pHTInfo->bCurBW40MHz)?\r\n((pHTInfo->bCurShortGI40MHz)?1:0):\r\n((pHTInfo->bCurShortGI20MHz)?1:0);\r\nreturn MCS_DATA_RATE[is40MHz][isShortGI][(nMcsRate&0x7f)];\r\n}\r\nu16 TxCountToDataRate( struct ieee80211_device* ieee, u8 nDataRate)\r\n{\r\nu16 CCKOFDMRate[12] = {0x02 , 0x04 , 0x0b , 0x16 , 0x0c , 0x12 , 0x18 , 0x24 , 0x30 , 0x48 , 0x60 , 0x6c};\r\nu8 is40MHz = 0;\r\nu8 isShortGI = 0;\r\nif(nDataRate < 12)\r\n{\r\nreturn CCKOFDMRate[nDataRate];\r\n}\r\nelse\r\n{\r\nif (nDataRate >= 0x10 && nDataRate <= 0x1f)\r\n{\r\nis40MHz = 0;\r\nisShortGI = 0;\r\n}\r\nelse if(nDataRate >=0x20 && nDataRate <= 0x2f )\r\n{\r\nis40MHz = 1;\r\nisShortGI = 0;\r\n}\r\nelse if(nDataRate >= 0x30 && nDataRate <= 0x3f )\r\n{\r\nis40MHz = 0;\r\nisShortGI = 1;\r\n}\r\nelse if(nDataRate >= 0x40 && nDataRate <= 0x4f )\r\n{\r\nis40MHz = 1;\r\nisShortGI = 1;\r\n}\r\nreturn MCS_DATA_RATE[is40MHz][isShortGI][nDataRate&0xf];\r\n}\r\n}\r\nbool IsHTHalfNmodeAPs(struct ieee80211_device* ieee)\r\n{\r\nbool retValue = false;\r\nstruct ieee80211_network* net = &ieee->current_network;\r\n#if 0\r\nif(ieee->bHalfNMode == false)\r\nretValue = false;\r\nelse\r\n#endif\r\nif((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||\r\n(memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3)==0) ||\r\n(memcmp(net->bssid, PCI_RALINK, 3)==0) ||\r\n(memcmp(net->bssid, EDIMAX_RALINK, 3)==0) ||\r\n(memcmp(net->bssid, AIRLINK_RALINK, 3)==0) ||\r\n(net->ralink_cap_exist))\r\nretValue = true;\r\nelse if((memcmp(net->bssid, UNKNOWN_BORADCOM, 3)==0) ||\r\n(memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||\r\n(memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)||\r\n(net->broadcom_cap_exist))\r\nretValue = true;\r\nelse if(net->bssht.bdRT2RTAggregation)\r\nretValue = true;\r\nelse\r\nretValue = false;\r\nreturn retValue;\r\n}\r\nvoid HTIOTPeerDetermine(struct ieee80211_device* ieee)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nstruct ieee80211_network* net = &ieee->current_network;\r\nif(net->bssht.bdRT2RTAggregation)\r\npHTInfo->IOTPeer = HT_IOT_PEER_REALTEK;\r\nelse if(net->broadcom_cap_exist){\r\npHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;\r\n}\r\nelse if((memcmp(net->bssid, UNKNOWN_BORADCOM, 3)==0) ||\r\n(memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||\r\n(memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)){\r\npHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;\r\n}\r\nelse if((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||\r\n(memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3)==0) ||\r\n(memcmp(net->bssid, PCI_RALINK, 3)==0) ||\r\n(memcmp(net->bssid, EDIMAX_RALINK, 3)==0) ||\r\n(memcmp(net->bssid, AIRLINK_RALINK, 3)==0) ||\r\nnet->ralink_cap_exist)\r\npHTInfo->IOTPeer = HT_IOT_PEER_RALINK;\r\nelse if((net->atheros_cap_exist )|| (memcmp(net->bssid, DLINK_ATHEROS, 3) == 0))\r\npHTInfo->IOTPeer = HT_IOT_PEER_ATHEROS;\r\nelse if(memcmp(net->bssid, CISCO_BROADCOM, 3)==0)\r\npHTInfo->IOTPeer = HT_IOT_PEER_CISCO;\r\nelse if ((memcmp(net->bssid, LINKSYS_MARVELL_4400N, 3) == 0) ||\r\nnet->marvell_cap_exist){\r\npHTInfo->IOTPeer = HT_IOT_PEER_MARVELL;\r\n}\r\nelse\r\npHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;\r\nIEEE80211_DEBUG(IEEE80211_DL_IOT, "Joseph debug!! IOTPEER: %x\n", pHTInfo->IOTPeer);\r\n}\r\nu8 HTIOTActIsDisableMCS14(struct ieee80211_device* ieee, u8* PeerMacAddr)\r\n{\r\nu8 ret = 0;\r\n#if 0\r\n#if (HAL_CODE_BASE==RTL8192 && DEV_BUS_TYPE==USB_INTERFACE)\r\nif((memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3)==0) ||\r\n(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)\r\n)\r\n{\r\nret = 1;\r\n}\r\nif(pHTInfo->bCurrentRT2RTAggregation)\r\n{\r\nret = 1;\r\n}\r\n#endif\r\n#endif\r\nreturn ret;\r\n}\r\nu8 HTIOTActIsForcedCTS2Self(struct ieee80211_device *ieee, struct ieee80211_network *network)\r\n{\r\nu8 retValue = 0;\r\nif(ieee->pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)\r\n{\r\nretValue = 1;\r\n}\r\nreturn retValue;\r\n}\r\nbool HTIOTActIsDisableMCS15(struct ieee80211_device* ieee)\r\n{\r\nbool retValue = false;\r\n#ifdef TODO\r\n#if (HAL_CODE_BASE==RTL8192)\r\n#if (DEV_BUS_TYPE == USB_INTERFACE)\r\nretValue = true;\r\n#elif (DEV_BUS_TYPE == PCI_INTERFACE)\r\nretValue = false;\r\n#endif\r\n#endif\r\n#endif\r\nreturn retValue;\r\n}\r\nbool HTIOTActIsDisableMCSTwoSpatialStream(struct ieee80211_device* ieee, u8 *PeerMacAddr)\r\n{\r\nbool retValue = false;\r\n#ifdef TODO\r\nif(IS_UNDER_11N_AES_MODE(Adapter))\r\n{\r\nif((PlatformCompareMemory(PeerMacAddr, BELKINF5D8233V1_RALINK, 3)==0) ||\r\n(PlatformCompareMemory(PeerMacAddr, PCI_RALINK, 3)==0) ||\r\n(PlatformCompareMemory(PeerMacAddr, EDIMAX_RALINK, 3)==0))\r\n{\r\nretValue = false;\r\n}\r\n}\r\n#endif\r\nreturn retValue;\r\n}\r\nu8 HTIOTActIsDisableEDCATurbo(struct ieee80211_device* ieee, u8* PeerMacAddr)\r\n{\r\nu8 retValue = false;\r\nreturn retValue;\r\n#if 0\r\nif((memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3)==0)||\r\n(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||\r\n(memcmp(PeerMacAddr, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)||\r\n(memcmp(PeerMacAddr, NETGEAR834Bv2_BROADCOM, 3)==0))\r\n{\r\nretValue = 1;\r\n}\r\nreturn retValue;\r\n#endif\r\n}\r\nu8 HTIOTActIsMgntUseCCK6M(struct ieee80211_network *network)\r\n{\r\nu8 retValue = 0;\r\nif(network->broadcom_cap_exist)\r\n{\r\nretValue = 1;\r\n}\r\nreturn retValue;\r\n}\r\nu8 HTIOTActIsCCDFsync(u8* PeerMacAddr)\r\n{\r\nu8 retValue = 0;\r\nif( (memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3)==0) ||\r\n(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0) ||\r\n(memcmp(PeerMacAddr, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) ==0))\r\n{\r\nretValue = 1;\r\n}\r\nreturn retValue;\r\n}\r\nbool\r\nHTIOTActIsNullDataPowerSaving(struct ieee80211_device* ieee,struct ieee80211_network *network)\r\n{\r\nbool retValue = false;\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\n{\r\nif(pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM)\r\nreturn true;\r\n}\r\nreturn retValue;\r\n}\r\nvoid HTResetIOTSetting(\r\nPRT_HIGH_THROUGHPUT pHTInfo\r\n)\r\n{\r\npHTInfo->IOTAction = 0;\r\npHTInfo->IOTPeer = HT_IOT_PEER_UNKNOWN;\r\n}\r\nvoid HTConstructCapabilityElement(struct ieee80211_device* ieee, u8* posHTCap, u8* len, u8 IsEncrypt)\r\n{\r\nPRT_HIGH_THROUGHPUT pHT = ieee->pHTInfo;\r\nPHT_CAPABILITY_ELE pCapELE = NULL;\r\nif ((posHTCap == NULL) || (pHT == NULL))\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "posHTCap or pHTInfo can't be null in HTConstructCapabilityElement()\n");\r\nreturn;\r\n}\r\nmemset(posHTCap, 0, *len);\r\nif(pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC)\r\n{\r\nu8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\r\nmemcpy(posHTCap, EWC11NHTCap, sizeof(EWC11NHTCap));\r\npCapELE = (PHT_CAPABILITY_ELE)&(posHTCap[4]);\r\n}else\r\n{\r\npCapELE = (PHT_CAPABILITY_ELE)posHTCap;\r\n}\r\npCapELE->AdvCoding = 0;\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee))\r\n{\r\npCapELE->ChlWidth = 0;\r\n}\r\nelse\r\n{\r\npCapELE->ChlWidth = (pHT->bRegBW40MHz?1:0);\r\n}\r\npCapELE->MimoPwrSave = pHT->SelfMimoPs;\r\npCapELE->GreenField = 0;\r\npCapELE->ShortGI20Mhz = 1;\r\npCapELE->ShortGI40Mhz = 1;\r\npCapELE->TxSTBC = 1;\r\npCapELE->RxSTBC = 0;\r\npCapELE->DelayBA = 0;\r\npCapELE->MaxAMSDUSize = (MAX_RECEIVE_BUFFER_SIZE>=7935)?1:0;\r\npCapELE->DssCCk = ((pHT->bRegBW40MHz)?(pHT->bRegSuppCCK?1:0):0);\r\npCapELE->PSMP = 0;\r\npCapELE->LSigTxopProtect = 0;\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\n", pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);\r\nif( IsEncrypt)\r\n{\r\npCapELE->MPDUDensity = 7;\r\npCapELE->MaxRxAMPDUFactor = 2;\r\n}\r\nelse\r\n{\r\npCapELE->MaxRxAMPDUFactor = 3;\r\npCapELE->MPDUDensity = 0;\r\n}\r\nmemcpy(pCapELE->MCS, ieee->Regdot11HTOperationalRateSet, 16);\r\nif(pHT->IOTAction & HT_IOT_ACT_DISABLE_MCS15)\r\npCapELE->MCS[1] &= 0x7f;\r\nif(pHT->IOTAction & HT_IOT_ACT_DISABLE_MCS14)\r\npCapELE->MCS[1] &= 0xbf;\r\nif(pHT->IOTAction & HT_IOT_ACT_DISABLE_ALL_2SS)\r\npCapELE->MCS[1] &= 0x00;\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee))\r\n{\r\nint i;\r\nfor(i = 1; i< 16; i++)\r\npCapELE->MCS[i] = 0;\r\n}\r\nmemset(&pCapELE->ExtHTCapInfo, 0, 2);\r\nmemset(pCapELE->TxBFCap, 0, 4);\r\npCapELE->ASCap = 0;\r\nif(pHT->ePeerHTSpecVer == HT_SPEC_VER_EWC)\r\n*len = 30 + 2;\r\nelse\r\n*len = 26 + 2;\r\n}\r\nvoid HTConstructInfoElement(struct ieee80211_device* ieee, u8* posHTInfo, u8* len, u8 IsEncrypt)\r\n{\r\nPRT_HIGH_THROUGHPUT pHT = ieee->pHTInfo;\r\nPHT_INFORMATION_ELE pHTInfoEle = (PHT_INFORMATION_ELE)posHTInfo;\r\nif ((posHTInfo == NULL) || (pHTInfoEle == NULL))\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "posHTInfo or pHTInfoEle can't be null in HTConstructInfoElement()\n");\r\nreturn;\r\n}\r\nmemset(posHTInfo, 0, *len);\r\nif ( (ieee->iw_mode == IW_MODE_ADHOC) || (ieee->iw_mode == IW_MODE_MASTER))\r\n{\r\npHTInfoEle->ControlChl = ieee->current_network.channel;\r\npHTInfoEle->ExtChlOffset = ((pHT->bRegBW40MHz == false)?HT_EXTCHNL_OFFSET_NO_EXT:\r\n(ieee->current_network.channel<=6)?\r\nHT_EXTCHNL_OFFSET_UPPER:HT_EXTCHNL_OFFSET_LOWER);\r\npHTInfoEle->RecommemdedTxWidth = pHT->bRegBW40MHz;\r\npHTInfoEle->RIFS = 0;\r\npHTInfoEle->PSMPAccessOnly = 0;\r\npHTInfoEle->SrvIntGranularity = 0;\r\npHTInfoEle->OptMode = pHT->CurrentOpMode;\r\npHTInfoEle->NonGFDevPresent = 0;\r\npHTInfoEle->DualBeacon = 0;\r\npHTInfoEle->SecondaryBeacon = 0;\r\npHTInfoEle->LSigTxopProtectFull = 0;\r\npHTInfoEle->PcoActive = 0;\r\npHTInfoEle->PcoPhase = 0;\r\nmemset(pHTInfoEle->BasicMSC, 0, 16);\r\n*len = 22 + 2;\r\n}\r\nelse\r\n{\r\n*len = 0;\r\n}\r\n}\r\nvoid HTConstructRT2RTAggElement(struct ieee80211_device* ieee, u8* posRT2RTAgg, u8* len)\r\n{\r\nif (posRT2RTAgg == NULL) {\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "posRT2RTAgg can't be null in HTConstructRT2RTAggElement()\n");\r\nreturn;\r\n}\r\nmemset(posRT2RTAgg, 0, *len);\r\n*posRT2RTAgg++ = 0x00;\r\n*posRT2RTAgg++ = 0xe0;\r\n*posRT2RTAgg++ = 0x4c;\r\n*posRT2RTAgg++ = 0x02;\r\n*posRT2RTAgg++ = 0x01;\r\n*posRT2RTAgg = 0x10;\r\nif(ieee->bSupportRemoteWakeUp) {\r\n*posRT2RTAgg |= 0x08;\r\n}\r\n*len = 6 + 2;\r\nreturn;\r\n#ifdef TODO\r\n#if(HAL_CODE_BASE == RTL8192 && DEV_BUS_TYPE == USB_INTERFACE)\r\n#else\r\n#endif\r\nposRT2RTAgg->Length = 6;\r\n#endif\r\n}\r\nu8 HT_PickMCSRate(struct ieee80211_device* ieee, u8* pOperateMCS)\r\n{\r\nu8 i;\r\nif (pOperateMCS == NULL)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "pOperateMCS can't be null in HT_PickMCSRate()\n");\r\nreturn false;\r\n}\r\nswitch(ieee->mode)\r\n{\r\ncase IEEE_A:\r\ncase IEEE_B:\r\ncase IEEE_G:\r\nfor(i=0;i<=15;i++){\r\npOperateMCS[i] = 0;\r\n}\r\nbreak;\r\ncase IEEE_N_24G:\r\ncase IEEE_N_5G:\r\npOperateMCS[0] &=RATE_ADPT_1SS_MASK;\r\npOperateMCS[1] &=RATE_ADPT_2SS_MASK;\r\npOperateMCS[3] &=RATE_ADPT_MCS32_MASK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nu8 HTGetHighestMCSRate(struct ieee80211_device* ieee, u8* pMCSRateSet, u8* pMCSFilter)\r\n{\r\nu8 i, j;\r\nu8 bitMap;\r\nu8 mcsRate = 0;\r\nu8 availableMcsRate[16];\r\nif (pMCSRateSet == NULL || pMCSFilter == NULL)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "pMCSRateSet or pMCSFilter can't be null in HTGetHighestMCSRate()\n");\r\nreturn false;\r\n}\r\nfor(i=0; i<16; i++)\r\navailableMcsRate[i] = pMCSRateSet[i] & pMCSFilter[i];\r\nfor(i = 0; i < 16; i++)\r\n{\r\nif(availableMcsRate[i] != 0)\r\nbreak;\r\n}\r\nif(i == 16)\r\nreturn false;\r\nfor(i = 0; i < 16; i++)\r\n{\r\nif(availableMcsRate[i] != 0)\r\n{\r\nbitMap = availableMcsRate[i];\r\nfor(j = 0; j < 8; j++)\r\n{\r\nif((bitMap%2) != 0)\r\n{\r\nif(HTMcsToDataRate(ieee, (8*i+j)) > HTMcsToDataRate(ieee, mcsRate))\r\nmcsRate = (8*i+j);\r\n}\r\nbitMap = bitMap>>1;\r\n}\r\n}\r\n}\r\nreturn (mcsRate|0x80);\r\n}\r\nu8 HTFilterMCSRate( struct ieee80211_device* ieee, u8* pSupportMCS, u8* pOperateMCS)\r\n{\r\nu8 i=0;\r\nfor(i=0;i<=15;i++){\r\npOperateMCS[i] = ieee->Regdot11HTOperationalRateSet[i]&pSupportMCS[i];\r\n}\r\nHT_PickMCSRate(ieee, pOperateMCS);\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee))\r\npOperateMCS[1] = 0;\r\nfor(i=2; i<=15; i++)\r\npOperateMCS[i] = 0;\r\nreturn true;\r\n}\r\nvoid HTOnAssocRsp(struct ieee80211_device *ieee)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nPHT_CAPABILITY_ELE pPeerHTCap = NULL;\r\nPHT_INFORMATION_ELE pPeerHTInfo = NULL;\r\nu16 nMaxAMSDUSize = 0;\r\nu8* pMcsFilter = NULL;\r\nstatic u8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\r\nstatic u8 EWC11NHTInfo[] = {0x00, 0x90, 0x4c, 0x34};\r\nif( pHTInfo->bCurrentHTSupport == false )\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "<=== HTOnAssocRsp(): HT_DISABLE\n");\r\nreturn;\r\n}\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");\r\nif(!memcmp(pHTInfo->PeerHTCapBuf,EWC11NHTCap, sizeof(EWC11NHTCap)))\r\npPeerHTCap = (PHT_CAPABILITY_ELE)(&pHTInfo->PeerHTCapBuf[4]);\r\nelse\r\npPeerHTCap = (PHT_CAPABILITY_ELE)(pHTInfo->PeerHTCapBuf);\r\nif(!memcmp(pHTInfo->PeerHTInfoBuf, EWC11NHTInfo, sizeof(EWC11NHTInfo)))\r\npPeerHTInfo = (PHT_INFORMATION_ELE)(&pHTInfo->PeerHTInfoBuf[4]);\r\nelse\r\npPeerHTInfo = (PHT_INFORMATION_ELE)(pHTInfo->PeerHTInfoBuf);\r\nIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_HT, pPeerHTCap, sizeof(HT_CAPABILITY_ELE));\r\nHTSetConnectBwMode(ieee, (HT_CHANNEL_WIDTH)(pPeerHTCap->ChlWidth), (HT_EXTCHNL_OFFSET)(pPeerHTInfo->ExtChlOffset));\r\npHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1)?true:false);\r\npHTInfo->bCurShortGI20MHz=\r\n((pHTInfo->bRegShortGI20MHz)?((pPeerHTCap->ShortGI20Mhz==1)?true:false):false);\r\npHTInfo->bCurShortGI40MHz=\r\n((pHTInfo->bRegShortGI40MHz)?((pPeerHTCap->ShortGI40Mhz==1)?true:false):false);\r\npHTInfo->bCurSuppCCK =\r\n((pHTInfo->bRegSuppCCK)?((pPeerHTCap->DssCCk==1)?true:false):false);\r\npHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;\r\nif (ieee->rtllib_ap_sec_type &&\r\n(ieee->rtllib_ap_sec_type(ieee)&(SEC_ALG_WEP|SEC_ALG_TKIP))){\r\nif( (pHTInfo->IOTPeer== HT_IOT_PEER_ATHEROS) ||\r\n(pHTInfo->IOTPeer == HT_IOT_PEER_UNKNOWN) )\r\npHTInfo->bCurrentAMPDUEnable = false;\r\n}\r\nnMaxAMSDUSize = (pPeerHTCap->MaxAMSDUSize==0)?3839:7935;\r\nif(pHTInfo->nAMSDU_MaxSize > nMaxAMSDUSize )\r\npHTInfo->nCurrent_AMSDU_MaxSize = nMaxAMSDUSize;\r\nelse\r\npHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;\r\npHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;\r\nif(!pHTInfo->bRegRT2RTAggregation)\r\n{\r\nif(pHTInfo->AMPDU_Factor > pPeerHTCap->MaxRxAMPDUFactor)\r\npHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;\r\nelse\r\npHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;\r\n}else\r\n{\r\n#if 0\r\nosTmp= PacketGetElement( asocpdu, EID_Vendor, OUI_SUB_REALTEK_AGG, OUI_SUBTYPE_DONT_CARE);\r\nif(osTmp.Length >= 5)\r\n#endif\r\nif (ieee->current_network.bssht.bdRT2RTAggregation)\r\n{\r\nif( ieee->pairwise_key_type != KEY_TYPE_NA)\r\npHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;\r\nelse\r\npHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_64K;\r\n}else\r\n{\r\nif(pPeerHTCap->MaxRxAMPDUFactor < HT_AGG_SIZE_32K)\r\npHTInfo->CurrentAMPDUFactor = pPeerHTCap->MaxRxAMPDUFactor;\r\nelse\r\npHTInfo->CurrentAMPDUFactor = HT_AGG_SIZE_32K;\r\n}\r\n}\r\n#if 1\r\nif(pHTInfo->MPDU_Density > pPeerHTCap->MPDUDensity)\r\npHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;\r\nelse\r\npHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;\r\nif(ieee->pairwise_key_type != KEY_TYPE_NA )\r\npHTInfo->CurrentMPDUDensity = 7;\r\n#else\r\nif(pHTInfo->MPDU_Density > pPeerHTCap->MPDUDensity)\r\npHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;\r\nelse\r\npHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;\r\n#endif\r\nif(0)\r\n{\r\npHTInfo->bCurrentAMPDUEnable = false;\r\npHTInfo->ForcedAMSDUMode = HT_AGG_FORCE_ENABLE;\r\npHTInfo->ForcedAMSDUMaxSize = 7935;\r\npHTInfo->IOTAction |= HT_IOT_ACT_TX_USE_AMSDU_8K;\r\n}\r\npHTInfo->bCurRxReorderEnable = pHTInfo->bRegRxReorderEnable;\r\nif(pPeerHTCap->MCS[0] == 0)\r\npPeerHTCap->MCS[0] = 0xff;\r\nHTFilterMCSRate(ieee, pPeerHTCap->MCS, ieee->dot11HTOperationalRateSet);\r\npHTInfo->PeerMimoPs = pPeerHTCap->MimoPwrSave;\r\nif(pHTInfo->PeerMimoPs == MIMO_PS_STATIC)\r\npMcsFilter = MCS_FILTER_1SS;\r\nelse\r\npMcsFilter = MCS_FILTER_ALL;\r\nieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, pMcsFilter);\r\nieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;\r\npHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;\r\n}\r\nvoid HTInitializeHTInfo(struct ieee80211_device* ieee)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "===========>%s()\n", __FUNCTION__);\r\npHTInfo->bCurrentHTSupport = false;\r\npHTInfo->bCurBW40MHz = false;\r\npHTInfo->bCurTxBW40MHz = false;\r\npHTInfo->bCurShortGI20MHz = false;\r\npHTInfo->bCurShortGI40MHz = false;\r\npHTInfo->bForcedShortGI = false;\r\npHTInfo->bCurSuppCCK = true;\r\npHTInfo->bCurrent_AMSDU_Support = false;\r\npHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;\r\npHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;\r\npHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;\r\nmemset((void*)(&(pHTInfo->SelfHTCap)), 0, sizeof(pHTInfo->SelfHTCap));\r\nmemset((void*)(&(pHTInfo->SelfHTInfo)), 0, sizeof(pHTInfo->SelfHTInfo));\r\nmemset((void*)(&(pHTInfo->PeerHTCapBuf)), 0, sizeof(pHTInfo->PeerHTCapBuf));\r\nmemset((void*)(&(pHTInfo->PeerHTInfoBuf)), 0, sizeof(pHTInfo->PeerHTInfoBuf));\r\npHTInfo->bSwBwInProgress = false;\r\npHTInfo->ChnlOp = CHNLOP_NONE;\r\npHTInfo->ePeerHTSpecVer = HT_SPEC_VER_IEEE;\r\npHTInfo->bCurrentRT2RTAggregation = false;\r\npHTInfo->bCurrentRT2RTLongSlotTime = false;\r\npHTInfo->IOTPeer = 0;\r\npHTInfo->IOTAction = 0;\r\n{\r\nu8* RegHTSuppRateSets = &(ieee->RegHTSuppRateSet[0]);\r\nRegHTSuppRateSets[0] = 0xFF;\r\nRegHTSuppRateSets[1] = 0xFF;\r\nRegHTSuppRateSets[4] = 0x01;\r\n}\r\n}\r\nvoid HTInitializeBssDesc(PBSS_HT pBssHT)\r\n{\r\npBssHT->bdSupportHT = false;\r\nmemset(pBssHT->bdHTCapBuf, 0, sizeof(pBssHT->bdHTCapBuf));\r\npBssHT->bdHTCapLen = 0;\r\nmemset(pBssHT->bdHTInfoBuf, 0, sizeof(pBssHT->bdHTInfoBuf));\r\npBssHT->bdHTInfoLen = 0;\r\npBssHT->bdHTSpecVer= HT_SPEC_VER_IEEE;\r\npBssHT->bdRT2RTAggregation = false;\r\npBssHT->bdRT2RTLongSlotTime = false;\r\n}\r\nvoid HTResetSelfAndSavePeerSetting(struct ieee80211_device* ieee, struct ieee80211_network * pNetwork)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nu8 bIOTAction = 0;\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "==============>%s()\n", __FUNCTION__);\r\nif (pNetwork->bssht.bdSupportHT)\r\n{\r\npHTInfo->bCurrentHTSupport = true;\r\npHTInfo->ePeerHTSpecVer = pNetwork->bssht.bdHTSpecVer;\r\nif(pNetwork->bssht.bdHTCapLen > 0 && pNetwork->bssht.bdHTCapLen <= sizeof(pHTInfo->PeerHTCapBuf))\r\nmemcpy(pHTInfo->PeerHTCapBuf, pNetwork->bssht.bdHTCapBuf, pNetwork->bssht.bdHTCapLen);\r\nif(pNetwork->bssht.bdHTInfoLen > 0 && pNetwork->bssht.bdHTInfoLen <= sizeof(pHTInfo->PeerHTInfoBuf))\r\nmemcpy(pHTInfo->PeerHTInfoBuf, pNetwork->bssht.bdHTInfoBuf, pNetwork->bssht.bdHTInfoLen);\r\nif(pHTInfo->bRegRT2RTAggregation)\r\n{\r\npHTInfo->bCurrentRT2RTAggregation = pNetwork->bssht.bdRT2RTAggregation;\r\npHTInfo->bCurrentRT2RTLongSlotTime = pNetwork->bssht.bdRT2RTLongSlotTime;\r\n}\r\nelse\r\n{\r\npHTInfo->bCurrentRT2RTAggregation = false;\r\npHTInfo->bCurrentRT2RTLongSlotTime = false;\r\n}\r\nHTIOTPeerDetermine(ieee);\r\npHTInfo->IOTAction = 0;\r\nbIOTAction = HTIOTActIsDisableMCS14(ieee, pNetwork->bssid);\r\nif(bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS14;\r\nbIOTAction = HTIOTActIsForcedCTS2Self(ieee, pNetwork);\r\nif(bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_FORCED_CTS2SELF;\r\nbIOTAction = HTIOTActIsDisableMCS15(ieee);\r\nif(bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_MCS15;\r\nbIOTAction = HTIOTActIsDisableMCSTwoSpatialStream(ieee, pNetwork->bssid);\r\nif(bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_ALL_2SS;\r\nbIOTAction = HTIOTActIsDisableEDCATurbo(ieee, pNetwork->bssid);\r\nif(bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_EDCA_TURBO;\r\nbIOTAction = HTIOTActIsMgntUseCCK6M(pNetwork);\r\nif(bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_MGNT_USE_CCK_6M;\r\nbIOTAction = HTIOTActIsCCDFsync(pNetwork->bssid);\r\nif(bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_CDD_FSYNC;\r\nbIOTAction = HTIOTActIsNullDataPowerSaving(ieee, pNetwork);\r\nif(bIOTAction)\r\npHTInfo->IOTAction |= HT_IOT_ACT_NULL_DATA_POWER_SAVING;\r\n}\r\nelse\r\n{\r\npHTInfo->bCurrentHTSupport = false;\r\npHTInfo->bCurrentRT2RTAggregation = false;\r\npHTInfo->bCurrentRT2RTLongSlotTime = false;\r\npHTInfo->IOTAction = 0;\r\n}\r\n}\r\nvoid HTUpdateSelfAndPeerSetting(struct ieee80211_device* ieee, struct ieee80211_network * pNetwork)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nPHT_INFORMATION_ELE pPeerHTInfo = (PHT_INFORMATION_ELE)pNetwork->bssht.bdHTInfoBuf;\r\nif(pHTInfo->bCurrentHTSupport)\r\n{\r\nif(pNetwork->bssht.bdHTInfoLen != 0)\r\npHTInfo->CurrentOpMode = pPeerHTInfo->OptMode;\r\n}\r\n}\r\nvoid HTUseDefaultSetting(struct ieee80211_device* ieee)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nif(pHTInfo->bEnableHT)\r\n{\r\npHTInfo->bCurrentHTSupport = true;\r\npHTInfo->bCurSuppCCK = pHTInfo->bRegSuppCCK;\r\npHTInfo->bCurBW40MHz = pHTInfo->bRegBW40MHz;\r\npHTInfo->bCurShortGI20MHz= pHTInfo->bRegShortGI20MHz;\r\npHTInfo->bCurShortGI40MHz= pHTInfo->bRegShortGI40MHz;\r\npHTInfo->bCurrent_AMSDU_Support = pHTInfo->bAMSDU_Support;\r\npHTInfo->nCurrent_AMSDU_MaxSize = pHTInfo->nAMSDU_MaxSize;\r\npHTInfo->bCurrentAMPDUEnable = pHTInfo->bAMPDUEnable;\r\npHTInfo->CurrentAMPDUFactor = pHTInfo->AMPDU_Factor;\r\npHTInfo->CurrentMPDUDensity = pHTInfo->CurrentMPDUDensity;\r\nHTFilterMCSRate(ieee, ieee->Regdot11HTOperationalRateSet, ieee->dot11HTOperationalRateSet);\r\n#ifdef TODO\r\nAdapter->HalFunc.InitHalRATRTableHandler( Adapter, &pMgntInfo->dot11OperationalRateSet, pMgntInfo->dot11HTOperationalRateSet);\r\n#endif\r\nieee->HTHighestOperaRate = HTGetHighestMCSRate(ieee, ieee->dot11HTOperationalRateSet, MCS_FILTER_ALL);\r\nieee->HTCurrentOperaRate = ieee->HTHighestOperaRate;\r\n}\r\nelse\r\n{\r\npHTInfo->bCurrentHTSupport = false;\r\n}\r\n}\r\nu8 HTCCheck(struct ieee80211_device* ieee, u8* pFrame)\r\n{\r\nif(ieee->pHTInfo->bCurrentHTSupport)\r\n{\r\nif( (IsQoSDataFrame(pFrame) && Frame_Order(pFrame)) == 1)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "HT CONTROL FILED EXIST!!\n");\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nvoid HTSetConnectBwMode(struct ieee80211_device* ieee, HT_CHANNEL_WIDTH Bandwidth, HT_EXTCHNL_OFFSET Offset)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nif(pHTInfo->bRegBW40MHz == false)\r\nreturn;\r\nif(pHTInfo->bSwBwInProgress) {\r\nreturn;\r\n}\r\nif (Bandwidth==HT_CHANNEL_WIDTH_20_40 && (!ieee->GetHalfNmodeSupportByAPsHandler(ieee)))\r\n{\r\nif(ieee->current_network.channel<2 && Offset==HT_EXTCHNL_OFFSET_LOWER)\r\nOffset = HT_EXTCHNL_OFFSET_NO_EXT;\r\nif(Offset==HT_EXTCHNL_OFFSET_UPPER || Offset==HT_EXTCHNL_OFFSET_LOWER) {\r\npHTInfo->bCurBW40MHz = true;\r\npHTInfo->CurSTAExtChnlOffset = Offset;\r\n} else {\r\npHTInfo->bCurBW40MHz = false;\r\npHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;\r\n}\r\n} else {\r\npHTInfo->bCurBW40MHz = false;\r\npHTInfo->CurSTAExtChnlOffset = HT_EXTCHNL_OFFSET_NO_EXT;\r\n}\r\npHTInfo->bSwBwInProgress = true;\r\nHTSetConnectBwModeCallback(ieee);\r\n}\r\nvoid HTSetConnectBwModeCallback(struct ieee80211_device* ieee)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nIEEE80211_DEBUG(IEEE80211_DL_HT, "======>%s()\n", __FUNCTION__);\r\nif(pHTInfo->bCurBW40MHz)\r\n{\r\nif(pHTInfo->CurSTAExtChnlOffset==HT_EXTCHNL_OFFSET_UPPER)\r\nieee->set_chan(ieee, ieee->current_network.channel+2);\r\nelse if(pHTInfo->CurSTAExtChnlOffset==HT_EXTCHNL_OFFSET_LOWER)\r\nieee->set_chan(ieee, ieee->current_network.channel-2);\r\nelse\r\nieee->set_chan(ieee, ieee->current_network.channel);\r\nieee->SetBWModeHandler(ieee, HT_CHANNEL_WIDTH_20_40, pHTInfo->CurSTAExtChnlOffset);\r\n} else {\r\nieee->set_chan(ieee, ieee->current_network.channel);\r\nieee->SetBWModeHandler(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\r\n}\r\npHTInfo->bSwBwInProgress = false;\r\n}
