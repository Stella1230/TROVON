static void dump_err_buf(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\nmlx4_err(dev, "Internal error detected:\n");\r\nfor (i = 0; i < priv->fw.catas_size; ++i)\r\nmlx4_err(dev, " buf[%02x]: %08x\n",\r\ni, swab32(readl(priv->catas_err.map + i)));\r\n}\r\nstatic void poll_catas(unsigned long dev_ptr)\r\n{\r\nstruct mlx4_dev *dev = (struct mlx4_dev *) dev_ptr;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nif (readl(priv->catas_err.map)) {\r\ndump_err_buf(dev);\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_CATASTROPHIC_ERROR, 0);\r\nif (internal_err_reset) {\r\nspin_lock(&catas_lock);\r\nlist_add(&priv->catas_err.list, &catas_list);\r\nspin_unlock(&catas_lock);\r\nqueue_work(mlx4_wq, &catas_work);\r\n}\r\n} else\r\nmod_timer(&priv->catas_err.timer,\r\nround_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL));\r\n}\r\nstatic void catas_reset(struct work_struct *work)\r\n{\r\nstruct mlx4_priv *priv, *tmppriv;\r\nstruct mlx4_dev *dev;\r\nLIST_HEAD(tlist);\r\nint ret;\r\nspin_lock_irq(&catas_lock);\r\nlist_splice_init(&catas_list, &tlist);\r\nspin_unlock_irq(&catas_lock);\r\nlist_for_each_entry_safe(priv, tmppriv, &tlist, catas_err.list) {\r\nstruct pci_dev *pdev = priv->dev.pdev;\r\nret = mlx4_restart_one(priv->dev.pdev);\r\nif (ret)\r\npr_err("mlx4 %s: Reset failed (%d)\n",\r\npci_name(pdev), ret);\r\nelse {\r\ndev = pci_get_drvdata(pdev);\r\nmlx4_dbg(dev, "Reset succeeded\n");\r\n}\r\n}\r\n}\r\nvoid mlx4_start_catas_poll(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nphys_addr_t addr;\r\nINIT_LIST_HEAD(&priv->catas_err.list);\r\ninit_timer(&priv->catas_err.timer);\r\npriv->catas_err.map = NULL;\r\naddr = pci_resource_start(dev->pdev, priv->fw.catas_bar) +\r\npriv->fw.catas_offset;\r\npriv->catas_err.map = ioremap(addr, priv->fw.catas_size * 4);\r\nif (!priv->catas_err.map) {\r\nmlx4_warn(dev, "Failed to map internal error buffer at 0x%llx\n",\r\n(unsigned long long) addr);\r\nreturn;\r\n}\r\npriv->catas_err.timer.data = (unsigned long) dev;\r\npriv->catas_err.timer.function = poll_catas;\r\npriv->catas_err.timer.expires =\r\nround_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL);\r\nadd_timer(&priv->catas_err.timer);\r\n}\r\nvoid mlx4_stop_catas_poll(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\ndel_timer_sync(&priv->catas_err.timer);\r\nif (priv->catas_err.map)\r\niounmap(priv->catas_err.map);\r\nspin_lock_irq(&catas_lock);\r\nlist_del(&priv->catas_err.list);\r\nspin_unlock_irq(&catas_lock);\r\n}\r\nvoid __init mlx4_catas_init(void)\r\n{\r\nINIT_WORK(&catas_work, catas_reset);\r\n}
