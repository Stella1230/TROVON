static void rpcb_wake_rpcbind_waiters(struct rpc_xprt *xprt, int status)\r\n{\r\nxprt_clear_binding(xprt);\r\nrpc_wake_up_status(&xprt->binding, status);\r\n}\r\nstatic void rpcb_map_release(void *data)\r\n{\r\nstruct rpcbind_args *map = data;\r\nrpcb_wake_rpcbind_waiters(map->r_xprt, map->r_status);\r\nxprt_put(map->r_xprt);\r\nkfree(map->r_addr);\r\nkfree(map);\r\n}\r\nstatic int rpcb_create_local_unix(void)\r\n{\r\nstatic const struct sockaddr_un rpcb_localaddr_rpcbind = {\r\n.sun_family = AF_LOCAL,\r\n.sun_path = RPCBIND_SOCK_PATHNAME,\r\n};\r\nstruct rpc_create_args args = {\r\n.net = &init_net,\r\n.protocol = XPRT_TRANSPORT_LOCAL,\r\n.address = (struct sockaddr *)&rpcb_localaddr_rpcbind,\r\n.addrsize = sizeof(rpcb_localaddr_rpcbind),\r\n.servername = "localhost",\r\n.program = &rpcb_program,\r\n.version = RPCBVERS_2,\r\n.authflavor = RPC_AUTH_NULL,\r\n};\r\nstruct rpc_clnt *clnt, *clnt4;\r\nint result = 0;\r\nclnt = rpc_create(&args);\r\nif (IS_ERR(clnt)) {\r\ndprintk("RPC: failed to create AF_LOCAL rpcbind "\r\n"client (errno %ld).\n", PTR_ERR(clnt));\r\nresult = -PTR_ERR(clnt);\r\ngoto out;\r\n}\r\nclnt4 = rpc_bind_new_program(clnt, &rpcb_program, RPCBVERS_4);\r\nif (IS_ERR(clnt4)) {\r\ndprintk("RPC: failed to bind second program to "\r\n"rpcbind v4 client (errno %ld).\n",\r\nPTR_ERR(clnt4));\r\nclnt4 = NULL;\r\n}\r\nrpcb_local_clnt = clnt;\r\nrpcb_local_clnt4 = clnt4;\r\nout:\r\nreturn result;\r\n}\r\nstatic int rpcb_create_local_net(void)\r\n{\r\nstatic const struct sockaddr_in rpcb_inaddr_loopback = {\r\n.sin_family = AF_INET,\r\n.sin_addr.s_addr = htonl(INADDR_LOOPBACK),\r\n.sin_port = htons(RPCBIND_PORT),\r\n};\r\nstruct rpc_create_args args = {\r\n.net = &init_net,\r\n.protocol = XPRT_TRANSPORT_TCP,\r\n.address = (struct sockaddr *)&rpcb_inaddr_loopback,\r\n.addrsize = sizeof(rpcb_inaddr_loopback),\r\n.servername = "localhost",\r\n.program = &rpcb_program,\r\n.version = RPCBVERS_2,\r\n.authflavor = RPC_AUTH_UNIX,\r\n.flags = RPC_CLNT_CREATE_NOPING,\r\n};\r\nstruct rpc_clnt *clnt, *clnt4;\r\nint result = 0;\r\nclnt = rpc_create(&args);\r\nif (IS_ERR(clnt)) {\r\ndprintk("RPC: failed to create local rpcbind "\r\n"client (errno %ld).\n", PTR_ERR(clnt));\r\nresult = -PTR_ERR(clnt);\r\ngoto out;\r\n}\r\nclnt4 = rpc_bind_new_program(clnt, &rpcb_program, RPCBVERS_4);\r\nif (IS_ERR(clnt4)) {\r\ndprintk("RPC: failed to bind second program to "\r\n"rpcbind v4 client (errno %ld).\n",\r\nPTR_ERR(clnt4));\r\nclnt4 = NULL;\r\n}\r\nrpcb_local_clnt = clnt;\r\nrpcb_local_clnt4 = clnt4;\r\nout:\r\nreturn result;\r\n}\r\nstatic int rpcb_create_local(void)\r\n{\r\nstatic DEFINE_MUTEX(rpcb_create_local_mutex);\r\nint result = 0;\r\nif (rpcb_local_clnt)\r\nreturn result;\r\nmutex_lock(&rpcb_create_local_mutex);\r\nif (rpcb_local_clnt)\r\ngoto out;\r\nif (rpcb_create_local_unix() != 0)\r\nresult = rpcb_create_local_net();\r\nout:\r\nmutex_unlock(&rpcb_create_local_mutex);\r\nreturn result;\r\n}\r\nstatic struct rpc_clnt *rpcb_create(char *hostname, struct sockaddr *srvaddr,\r\nsize_t salen, int proto, u32 version)\r\n{\r\nstruct rpc_create_args args = {\r\n.net = &init_net,\r\n.protocol = proto,\r\n.address = srvaddr,\r\n.addrsize = salen,\r\n.servername = hostname,\r\n.program = &rpcb_program,\r\n.version = version,\r\n.authflavor = RPC_AUTH_UNIX,\r\n.flags = (RPC_CLNT_CREATE_NOPING |\r\nRPC_CLNT_CREATE_NONPRIVPORT),\r\n};\r\nswitch (srvaddr->sa_family) {\r\ncase AF_INET:\r\n((struct sockaddr_in *)srvaddr)->sin_port = htons(RPCBIND_PORT);\r\nbreak;\r\ncase AF_INET6:\r\n((struct sockaddr_in6 *)srvaddr)->sin6_port = htons(RPCBIND_PORT);\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EAFNOSUPPORT);\r\n}\r\nreturn rpc_create(&args);\r\n}\r\nstatic int rpcb_register_call(struct rpc_clnt *clnt, struct rpc_message *msg)\r\n{\r\nint result, error = 0;\r\nmsg->rpc_resp = &result;\r\nerror = rpc_call_sync(clnt, msg, RPC_TASK_SOFTCONN);\r\nif (error < 0) {\r\ndprintk("RPC: failed to contact local rpcbind "\r\n"server (errno %d).\n", -error);\r\nreturn error;\r\n}\r\nif (!result)\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nint rpcb_register(u32 prog, u32 vers, int prot, unsigned short port)\r\n{\r\nstruct rpcbind_args map = {\r\n.r_prog = prog,\r\n.r_vers = vers,\r\n.r_prot = prot,\r\n.r_port = port,\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_argp = &map,\r\n};\r\nint error;\r\nerror = rpcb_create_local();\r\nif (error)\r\nreturn error;\r\ndprintk("RPC: %sregistering (%u, %u, %d, %u) with local "\r\n"rpcbind\n", (port ? "" : "un"),\r\nprog, vers, prot, port);\r\nmsg.rpc_proc = &rpcb_procedures2[RPCBPROC_UNSET];\r\nif (port)\r\nmsg.rpc_proc = &rpcb_procedures2[RPCBPROC_SET];\r\nreturn rpcb_register_call(rpcb_local_clnt, &msg);\r\n}\r\nstatic int rpcb_register_inet4(const struct sockaddr *sap,\r\nstruct rpc_message *msg)\r\n{\r\nconst struct sockaddr_in *sin = (const struct sockaddr_in *)sap;\r\nstruct rpcbind_args *map = msg->rpc_argp;\r\nunsigned short port = ntohs(sin->sin_port);\r\nint result;\r\nmap->r_addr = rpc_sockaddr2uaddr(sap);\r\ndprintk("RPC: %sregistering [%u, %u, %s, '%s'] with "\r\n"local rpcbind\n", (port ? "" : "un"),\r\nmap->r_prog, map->r_vers,\r\nmap->r_addr, map->r_netid);\r\nmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_UNSET];\r\nif (port)\r\nmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_SET];\r\nresult = rpcb_register_call(rpcb_local_clnt4, msg);\r\nkfree(map->r_addr);\r\nreturn result;\r\n}\r\nstatic int rpcb_register_inet6(const struct sockaddr *sap,\r\nstruct rpc_message *msg)\r\n{\r\nconst struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)sap;\r\nstruct rpcbind_args *map = msg->rpc_argp;\r\nunsigned short port = ntohs(sin6->sin6_port);\r\nint result;\r\nmap->r_addr = rpc_sockaddr2uaddr(sap);\r\ndprintk("RPC: %sregistering [%u, %u, %s, '%s'] with "\r\n"local rpcbind\n", (port ? "" : "un"),\r\nmap->r_prog, map->r_vers,\r\nmap->r_addr, map->r_netid);\r\nmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_UNSET];\r\nif (port)\r\nmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_SET];\r\nresult = rpcb_register_call(rpcb_local_clnt4, msg);\r\nkfree(map->r_addr);\r\nreturn result;\r\n}\r\nstatic int rpcb_unregister_all_protofamilies(struct rpc_message *msg)\r\n{\r\nstruct rpcbind_args *map = msg->rpc_argp;\r\ndprintk("RPC: unregistering [%u, %u, '%s'] with "\r\n"local rpcbind\n",\r\nmap->r_prog, map->r_vers, map->r_netid);\r\nmap->r_addr = "";\r\nmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_UNSET];\r\nreturn rpcb_register_call(rpcb_local_clnt4, msg);\r\n}\r\nint rpcb_v4_register(const u32 program, const u32 version,\r\nconst struct sockaddr *address, const char *netid)\r\n{\r\nstruct rpcbind_args map = {\r\n.r_prog = program,\r\n.r_vers = version,\r\n.r_netid = netid,\r\n.r_owner = RPCB_OWNER_STRING,\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_argp = &map,\r\n};\r\nint error;\r\nerror = rpcb_create_local();\r\nif (error)\r\nreturn error;\r\nif (rpcb_local_clnt4 == NULL)\r\nreturn -EPROTONOSUPPORT;\r\nif (address == NULL)\r\nreturn rpcb_unregister_all_protofamilies(&msg);\r\nswitch (address->sa_family) {\r\ncase AF_INET:\r\nreturn rpcb_register_inet4(address, &msg);\r\ncase AF_INET6:\r\nreturn rpcb_register_inet6(address, &msg);\r\n}\r\nreturn -EAFNOSUPPORT;\r\n}\r\nstatic struct rpc_task *rpcb_call_async(struct rpc_clnt *rpcb_clnt, struct rpcbind_args *map, struct rpc_procinfo *proc)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = proc,\r\n.rpc_argp = map,\r\n.rpc_resp = map,\r\n};\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_client = rpcb_clnt,\r\n.rpc_message = &msg,\r\n.callback_ops = &rpcb_getport_ops,\r\n.callback_data = map,\r\n.flags = RPC_TASK_ASYNC | RPC_TASK_SOFTCONN,\r\n};\r\nreturn rpc_run_task(&task_setup_data);\r\n}\r\nstatic struct rpc_clnt *rpcb_find_transport_owner(struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_clnt *parent = clnt->cl_parent;\r\nwhile (parent != clnt) {\r\nif (parent->cl_xprt != clnt->cl_xprt)\r\nbreak;\r\nif (clnt->cl_autobind)\r\nbreak;\r\nclnt = parent;\r\nparent = parent->cl_parent;\r\n}\r\nreturn clnt;\r\n}\r\nvoid rpcb_getport_async(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt;\r\nstruct rpc_procinfo *proc;\r\nu32 bind_version;\r\nstruct rpc_xprt *xprt;\r\nstruct rpc_clnt *rpcb_clnt;\r\nstruct rpcbind_args *map;\r\nstruct rpc_task *child;\r\nstruct sockaddr_storage addr;\r\nstruct sockaddr *sap = (struct sockaddr *)&addr;\r\nsize_t salen;\r\nint status;\r\nclnt = rpcb_find_transport_owner(task->tk_client);\r\nxprt = clnt->cl_xprt;\r\ndprintk("RPC: %5u %s(%s, %u, %u, %d)\n",\r\ntask->tk_pid, __func__,\r\nclnt->cl_server, clnt->cl_prog, clnt->cl_vers, xprt->prot);\r\nrpc_sleep_on(&xprt->binding, task, NULL);\r\nif (xprt_test_and_set_binding(xprt)) {\r\ndprintk("RPC: %5u %s: waiting for another binder\n",\r\ntask->tk_pid, __func__);\r\nreturn;\r\n}\r\nif (xprt_bound(xprt)) {\r\nstatus = 0;\r\ndprintk("RPC: %5u %s: already bound\n",\r\ntask->tk_pid, __func__);\r\ngoto bailout_nofree;\r\n}\r\nsalen = rpc_peeraddr(clnt, sap, sizeof(addr));\r\nswitch (sap->sa_family) {\r\ncase AF_INET:\r\nproc = rpcb_next_version[xprt->bind_index].rpc_proc;\r\nbind_version = rpcb_next_version[xprt->bind_index].rpc_vers;\r\nbreak;\r\ncase AF_INET6:\r\nproc = rpcb_next_version6[xprt->bind_index].rpc_proc;\r\nbind_version = rpcb_next_version6[xprt->bind_index].rpc_vers;\r\nbreak;\r\ndefault:\r\nstatus = -EAFNOSUPPORT;\r\ndprintk("RPC: %5u %s: bad address family\n",\r\ntask->tk_pid, __func__);\r\ngoto bailout_nofree;\r\n}\r\nif (proc == NULL) {\r\nxprt->bind_index = 0;\r\nstatus = -EPFNOSUPPORT;\r\ndprintk("RPC: %5u %s: no more getport versions available\n",\r\ntask->tk_pid, __func__);\r\ngoto bailout_nofree;\r\n}\r\ndprintk("RPC: %5u %s: trying rpcbind version %u\n",\r\ntask->tk_pid, __func__, bind_version);\r\nrpcb_clnt = rpcb_create(clnt->cl_server, sap, salen, xprt->prot,\r\nbind_version);\r\nif (IS_ERR(rpcb_clnt)) {\r\nstatus = PTR_ERR(rpcb_clnt);\r\ndprintk("RPC: %5u %s: rpcb_create failed, error %ld\n",\r\ntask->tk_pid, __func__, PTR_ERR(rpcb_clnt));\r\ngoto bailout_nofree;\r\n}\r\nmap = kzalloc(sizeof(struct rpcbind_args), GFP_ATOMIC);\r\nif (!map) {\r\nstatus = -ENOMEM;\r\ndprintk("RPC: %5u %s: no memory available\n",\r\ntask->tk_pid, __func__);\r\ngoto bailout_release_client;\r\n}\r\nmap->r_prog = clnt->cl_prog;\r\nmap->r_vers = clnt->cl_vers;\r\nmap->r_prot = xprt->prot;\r\nmap->r_port = 0;\r\nmap->r_xprt = xprt_get(xprt);\r\nmap->r_status = -EIO;\r\nswitch (bind_version) {\r\ncase RPCBVERS_4:\r\ncase RPCBVERS_3:\r\nmap->r_netid = rpc_peeraddr2str(clnt, RPC_DISPLAY_NETID);\r\nmap->r_addr = rpc_sockaddr2uaddr(sap);\r\nmap->r_owner = "";\r\nbreak;\r\ncase RPCBVERS_2:\r\nmap->r_addr = NULL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nchild = rpcb_call_async(rpcb_clnt, map, proc);\r\nrpc_release_client(rpcb_clnt);\r\nif (IS_ERR(child)) {\r\ndprintk("RPC: %5u %s: rpc_run_task failed\n",\r\ntask->tk_pid, __func__);\r\nreturn;\r\n}\r\nxprt->stat.bind_count++;\r\nrpc_put_task(child);\r\nreturn;\r\nbailout_release_client:\r\nrpc_release_client(rpcb_clnt);\r\nbailout_nofree:\r\nrpcb_wake_rpcbind_waiters(xprt, status);\r\ntask->tk_status = status;\r\n}\r\nstatic void rpcb_getport_done(struct rpc_task *child, void *data)\r\n{\r\nstruct rpcbind_args *map = data;\r\nstruct rpc_xprt *xprt = map->r_xprt;\r\nint status = child->tk_status;\r\nif (status == -EIO)\r\nstatus = -EPROTONOSUPPORT;\r\nif (status == -EPROTONOSUPPORT)\r\nxprt->bind_index++;\r\nif (status < 0) {\r\nxprt->ops->set_port(xprt, 0);\r\n} else if (map->r_port == 0) {\r\nxprt->ops->set_port(xprt, 0);\r\nstatus = -EACCES;\r\n} else {\r\nxprt->ops->set_port(xprt, map->r_port);\r\nxprt_set_bound(xprt);\r\nstatus = 0;\r\n}\r\ndprintk("RPC: %5u rpcb_getport_done(status %d, port %u)\n",\r\nchild->tk_pid, status, map->r_port);\r\nmap->r_status = status;\r\n}\r\nstatic void rpcb_enc_mapping(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nconst struct rpcbind_args *rpcb)\r\n{\r\nstruct rpc_task *task = req->rq_task;\r\n__be32 *p;\r\ndprintk("RPC: %5u encoding PMAP_%s call (%u, %u, %d, %u)\n",\r\ntask->tk_pid, task->tk_msg.rpc_proc->p_name,\r\nrpcb->r_prog, rpcb->r_vers, rpcb->r_prot, rpcb->r_port);\r\np = xdr_reserve_space(xdr, RPCB_mappingargs_sz << 2);\r\n*p++ = cpu_to_be32(rpcb->r_prog);\r\n*p++ = cpu_to_be32(rpcb->r_vers);\r\n*p++ = cpu_to_be32(rpcb->r_prot);\r\n*p = cpu_to_be32(rpcb->r_port);\r\n}\r\nstatic int rpcb_dec_getport(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct rpcbind_args *rpcb)\r\n{\r\nstruct rpc_task *task = req->rq_task;\r\nunsigned long port;\r\n__be32 *p;\r\nrpcb->r_port = 0;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nport = be32_to_cpup(p);\r\ndprintk("RPC: %5u PMAP_%s result: %lu\n", task->tk_pid,\r\ntask->tk_msg.rpc_proc->p_name, port);\r\nif (unlikely(port > USHRT_MAX))\r\nreturn -EIO;\r\nrpcb->r_port = port;\r\nreturn 0;\r\n}\r\nstatic int rpcb_dec_set(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nunsigned int *boolp)\r\n{\r\nstruct rpc_task *task = req->rq_task;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\n*boolp = 0;\r\nif (*p != xdr_zero)\r\n*boolp = 1;\r\ndprintk("RPC: %5u RPCB_%s call %s\n",\r\ntask->tk_pid, task->tk_msg.rpc_proc->p_name,\r\n(*boolp ? "succeeded" : "failed"));\r\nreturn 0;\r\n}\r\nstatic void encode_rpcb_string(struct xdr_stream *xdr, const char *string,\r\nconst u32 maxstrlen)\r\n{\r\n__be32 *p;\r\nu32 len;\r\nlen = strlen(string);\r\nBUG_ON(len > maxstrlen);\r\np = xdr_reserve_space(xdr, 4 + len);\r\nxdr_encode_opaque(p, string, len);\r\n}\r\nstatic void rpcb_enc_getaddr(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nconst struct rpcbind_args *rpcb)\r\n{\r\nstruct rpc_task *task = req->rq_task;\r\n__be32 *p;\r\ndprintk("RPC: %5u encoding RPCB_%s call (%u, %u, '%s', '%s')\n",\r\ntask->tk_pid, task->tk_msg.rpc_proc->p_name,\r\nrpcb->r_prog, rpcb->r_vers,\r\nrpcb->r_netid, rpcb->r_addr);\r\np = xdr_reserve_space(xdr, (RPCB_program_sz + RPCB_version_sz) << 2);\r\n*p++ = cpu_to_be32(rpcb->r_prog);\r\n*p = cpu_to_be32(rpcb->r_vers);\r\nencode_rpcb_string(xdr, rpcb->r_netid, RPCBIND_MAXNETIDLEN);\r\nencode_rpcb_string(xdr, rpcb->r_addr, RPCBIND_MAXUADDRLEN);\r\nencode_rpcb_string(xdr, rpcb->r_owner, RPCB_MAXOWNERLEN);\r\n}\r\nstatic int rpcb_dec_getaddr(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct rpcbind_args *rpcb)\r\n{\r\nstruct sockaddr_storage address;\r\nstruct sockaddr *sap = (struct sockaddr *)&address;\r\nstruct rpc_task *task = req->rq_task;\r\n__be32 *p;\r\nu32 len;\r\nrpcb->r_port = 0;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_fail;\r\nlen = be32_to_cpup(p);\r\nif (len == 0) {\r\ndprintk("RPC: %5u RPCB reply: program not registered\n",\r\ntask->tk_pid);\r\nreturn 0;\r\n}\r\nif (unlikely(len > RPCBIND_MAXUADDRLEN))\r\ngoto out_fail;\r\np = xdr_inline_decode(xdr, len);\r\nif (unlikely(p == NULL))\r\ngoto out_fail;\r\ndprintk("RPC: %5u RPCB_%s reply: %s\n", task->tk_pid,\r\ntask->tk_msg.rpc_proc->p_name, (char *)p);\r\nif (rpc_uaddr2sockaddr((char *)p, len, sap, sizeof(address)) == 0)\r\ngoto out_fail;\r\nrpcb->r_port = rpc_get_port(sap);\r\nreturn 0;\r\nout_fail:\r\ndprintk("RPC: %5u malformed RPCB_%s reply\n",\r\ntask->tk_pid, task->tk_msg.rpc_proc->p_name);\r\nreturn -EIO;\r\n}\r\nvoid cleanup_rpcb_clnt(void)\r\n{\r\nif (rpcb_local_clnt4)\r\nrpc_shutdown_client(rpcb_local_clnt4);\r\nif (rpcb_local_clnt)\r\nrpc_shutdown_client(rpcb_local_clnt);\r\n}
