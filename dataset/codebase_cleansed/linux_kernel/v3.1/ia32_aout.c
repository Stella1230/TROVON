static void dump_thread32(struct pt_regs *regs, struct user32 *dump)\r\n{\r\nu32 fs, gs;\r\ndump->magic = CMAGIC;\r\ndump->start_code = 0;\r\ndump->start_stack = regs->sp & ~(PAGE_SIZE - 1);\r\ndump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;\r\ndump->u_dsize = ((unsigned long)\r\n(current->mm->brk + (PAGE_SIZE-1))) >> PAGE_SHIFT;\r\ndump->u_dsize -= dump->u_tsize;\r\ndump->u_ssize = 0;\r\ndump->u_debugreg[0] = current->thread.debugreg0;\r\ndump->u_debugreg[1] = current->thread.debugreg1;\r\ndump->u_debugreg[2] = current->thread.debugreg2;\r\ndump->u_debugreg[3] = current->thread.debugreg3;\r\ndump->u_debugreg[4] = 0;\r\ndump->u_debugreg[5] = 0;\r\ndump->u_debugreg[6] = current->thread.debugreg6;\r\ndump->u_debugreg[7] = current->thread.debugreg7;\r\nif (dump->start_stack < 0xc0000000) {\r\nunsigned long tmp;\r\ntmp = (unsigned long) (0xc0000000 - dump->start_stack);\r\ndump->u_ssize = tmp >> PAGE_SHIFT;\r\n}\r\ndump->regs.bx = regs->bx;\r\ndump->regs.cx = regs->cx;\r\ndump->regs.dx = regs->dx;\r\ndump->regs.si = regs->si;\r\ndump->regs.di = regs->di;\r\ndump->regs.bp = regs->bp;\r\ndump->regs.ax = regs->ax;\r\ndump->regs.ds = current->thread.ds;\r\ndump->regs.es = current->thread.es;\r\nsavesegment(fs, fs);\r\ndump->regs.fs = fs;\r\nsavesegment(gs, gs);\r\ndump->regs.gs = gs;\r\ndump->regs.orig_ax = regs->orig_ax;\r\ndump->regs.ip = regs->ip;\r\ndump->regs.cs = regs->cs;\r\ndump->regs.flags = regs->flags;\r\ndump->regs.sp = regs->sp;\r\ndump->regs.ss = regs->ss;\r\n#if 1\r\ndump->u_fpvalid = 0;\r\n#else\r\ndump->u_fpvalid = dump_fpu(regs, &dump->i387);\r\n#endif\r\n}\r\nstatic void set_brk(unsigned long start, unsigned long end)\r\n{\r\nstart = PAGE_ALIGN(start);\r\nend = PAGE_ALIGN(end);\r\nif (end <= start)\r\nreturn;\r\ndown_write(&current->mm->mmap_sem);\r\ndo_brk(start, end - start);\r\nup_write(&current->mm->mmap_sem);\r\n}\r\nstatic int aout_core_dump(long signr, struct pt_regs *regs, struct file *file,\r\nunsigned long limit)\r\n{\r\nmm_segment_t fs;\r\nint has_dumped = 0;\r\nunsigned long dump_start, dump_size;\r\nstruct user32 dump;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nhas_dumped = 1;\r\ncurrent->flags |= PF_DUMPCORE;\r\nstrncpy(dump.u_comm, current->comm, sizeof(current->comm));\r\ndump.u_ar0 = offsetof(struct user32, regs);\r\ndump.signal = signr;\r\ndump_thread32(regs, &dump);\r\nif ((dump.u_dsize + dump.u_ssize + 1) * PAGE_SIZE > limit)\r\ndump.u_dsize = 0;\r\nif ((dump.u_ssize + 1) * PAGE_SIZE > limit)\r\ndump.u_ssize = 0;\r\nset_fs(USER_DS);\r\nif (!access_ok(VERIFY_READ, (void *) (unsigned long)START_DATA(dump),\r\ndump.u_dsize << PAGE_SHIFT))\r\ndump.u_dsize = 0;\r\nif (!access_ok(VERIFY_READ, (void *) (unsigned long)START_STACK(dump),\r\ndump.u_ssize << PAGE_SHIFT))\r\ndump.u_ssize = 0;\r\nset_fs(KERNEL_DS);\r\nDUMP_WRITE(&dump, sizeof(dump));\r\nDUMP_SEEK(PAGE_SIZE);\r\nset_fs(USER_DS);\r\nif (dump.u_dsize != 0) {\r\ndump_start = START_DATA(dump);\r\ndump_size = dump.u_dsize << PAGE_SHIFT;\r\nDUMP_WRITE(dump_start, dump_size);\r\n}\r\nif (dump.u_ssize != 0) {\r\ndump_start = START_STACK(dump);\r\ndump_size = dump.u_ssize << PAGE_SHIFT;\r\nDUMP_WRITE(dump_start, dump_size);\r\n}\r\nend_coredump:\r\nset_fs(fs);\r\nreturn has_dumped;\r\n}\r\nstatic u32 __user *create_aout_tables(char __user *p, struct linux_binprm *bprm)\r\n{\r\nu32 __user *argv, *envp, *sp;\r\nint argc = bprm->argc, envc = bprm->envc;\r\nsp = (u32 __user *) ((-(unsigned long)sizeof(u32)) & (unsigned long) p);\r\nsp -= envc+1;\r\nenvp = sp;\r\nsp -= argc+1;\r\nargv = sp;\r\nput_user((unsigned long) envp, --sp);\r\nput_user((unsigned long) argv, --sp);\r\nput_user(argc, --sp);\r\ncurrent->mm->arg_start = (unsigned long) p;\r\nwhile (argc-- > 0) {\r\nchar c;\r\nput_user((u32)(unsigned long)p, argv++);\r\ndo {\r\nget_user(c, p++);\r\n} while (c);\r\n}\r\nput_user(0, argv);\r\ncurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\r\nwhile (envc-- > 0) {\r\nchar c;\r\nput_user((u32)(unsigned long)p, envp++);\r\ndo {\r\nget_user(c, p++);\r\n} while (c);\r\n}\r\nput_user(0, envp);\r\ncurrent->mm->env_end = (unsigned long) p;\r\nreturn sp;\r\n}\r\nstatic int load_aout_binary(struct linux_binprm *bprm, struct pt_regs *regs)\r\n{\r\nunsigned long error, fd_offset, rlim;\r\nstruct exec ex;\r\nint retval;\r\nex = *((struct exec *) bprm->buf);\r\nif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != OMAGIC &&\r\nN_MAGIC(ex) != QMAGIC && N_MAGIC(ex) != NMAGIC) ||\r\nN_TRSIZE(ex) || N_DRSIZE(ex) ||\r\ni_size_read(bprm->file->f_path.dentry->d_inode) <\r\nex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\r\nreturn -ENOEXEC;\r\n}\r\nfd_offset = N_TXTOFF(ex);\r\nrlim = rlimit(RLIMIT_DATA);\r\nif (rlim >= RLIM_INFINITY)\r\nrlim = ~0;\r\nif (ex.a_data + ex.a_bss > rlim)\r\nreturn -ENOMEM;\r\nretval = flush_old_exec(bprm);\r\nif (retval)\r\nreturn retval;\r\nset_personality(PER_LINUX);\r\nset_thread_flag(TIF_IA32);\r\ncurrent->mm->context.ia32_compat = 1;\r\nsetup_new_exec(bprm);\r\nregs->cs = __USER32_CS;\r\nregs->r8 = regs->r9 = regs->r10 = regs->r11 = regs->r12 =\r\nregs->r13 = regs->r14 = regs->r15 = 0;\r\ncurrent->mm->end_code = ex.a_text +\r\n(current->mm->start_code = N_TXTADDR(ex));\r\ncurrent->mm->end_data = ex.a_data +\r\n(current->mm->start_data = N_DATADDR(ex));\r\ncurrent->mm->brk = ex.a_bss +\r\n(current->mm->start_brk = N_BSSADDR(ex));\r\ncurrent->mm->free_area_cache = TASK_UNMAPPED_BASE;\r\ncurrent->mm->cached_hole_size = 0;\r\ninstall_exec_creds(bprm);\r\ncurrent->flags &= ~PF_FORKNOEXEC;\r\nif (N_MAGIC(ex) == OMAGIC) {\r\nunsigned long text_addr, map_size;\r\nloff_t pos;\r\ntext_addr = N_TXTADDR(ex);\r\npos = 32;\r\nmap_size = ex.a_text+ex.a_data;\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_brk(text_addr & PAGE_MASK, map_size);\r\nup_write(&current->mm->mmap_sem);\r\nif (error != (text_addr & PAGE_MASK)) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn error;\r\n}\r\nerror = bprm->file->f_op->read(bprm->file,\r\n(char __user *)text_addr,\r\nex.a_text+ex.a_data, &pos);\r\nif ((signed long)error < 0) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn error;\r\n}\r\nflush_icache_range(text_addr, text_addr+ex.a_text+ex.a_data);\r\n} else {\r\n#ifdef WARN_OLD\r\nstatic unsigned long error_time, error_time2;\r\nif ((ex.a_text & 0xfff || ex.a_data & 0xfff) &&\r\n(N_MAGIC(ex) != NMAGIC) &&\r\ntime_after(jiffies, error_time2 + 5*HZ)) {\r\nprintk(KERN_NOTICE "executable not page aligned\n");\r\nerror_time2 = jiffies;\r\n}\r\nif ((fd_offset & ~PAGE_MASK) != 0 &&\r\ntime_after(jiffies, error_time + 5*HZ)) {\r\nprintk(KERN_WARNING\r\n"fd_offset is not page aligned. Please convert "\r\n"program: %s\n",\r\nbprm->file->f_path.dentry->d_name.name);\r\nerror_time = jiffies;\r\n}\r\n#endif\r\nif (!bprm->file->f_op->mmap || (fd_offset & ~PAGE_MASK) != 0) {\r\nloff_t pos = fd_offset;\r\ndown_write(&current->mm->mmap_sem);\r\ndo_brk(N_TXTADDR(ex), ex.a_text+ex.a_data);\r\nup_write(&current->mm->mmap_sem);\r\nbprm->file->f_op->read(bprm->file,\r\n(char __user *)N_TXTADDR(ex),\r\nex.a_text+ex.a_data, &pos);\r\nflush_icache_range((unsigned long) N_TXTADDR(ex),\r\n(unsigned long) N_TXTADDR(ex) +\r\nex.a_text+ex.a_data);\r\ngoto beyond_if;\r\n}\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_mmap(bprm->file, N_TXTADDR(ex), ex.a_text,\r\nPROT_READ | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE |\r\nMAP_EXECUTABLE | MAP_32BIT,\r\nfd_offset);\r\nup_write(&current->mm->mmap_sem);\r\nif (error != N_TXTADDR(ex)) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn error;\r\n}\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE |\r\nMAP_EXECUTABLE | MAP_32BIT,\r\nfd_offset + ex.a_text);\r\nup_write(&current->mm->mmap_sem);\r\nif (error != N_DATADDR(ex)) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn error;\r\n}\r\n}\r\nbeyond_if:\r\nset_binfmt(&aout_format);\r\nset_brk(current->mm->start_brk, current->mm->brk);\r\nretval = setup_arg_pages(bprm, IA32_STACK_TOP, EXSTACK_DEFAULT);\r\nif (retval < 0) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn retval;\r\n}\r\ncurrent->mm->start_stack =\r\n(unsigned long)create_aout_tables((char __user *)bprm->p, bprm);\r\nloadsegment(fs, 0);\r\nloadsegment(ds, __USER32_DS);\r\nloadsegment(es, __USER32_DS);\r\nload_gs_index(0);\r\n(regs)->ip = ex.a_entry;\r\n(regs)->sp = current->mm->start_stack;\r\n(regs)->flags = 0x200;\r\n(regs)->cs = __USER32_CS;\r\n(regs)->ss = __USER32_DS;\r\nregs->r8 = regs->r9 = regs->r10 = regs->r11 =\r\nregs->r12 = regs->r13 = regs->r14 = regs->r15 = 0;\r\nset_fs(USER_DS);\r\nreturn 0;\r\n}\r\nstatic int load_aout_library(struct file *file)\r\n{\r\nstruct inode *inode;\r\nunsigned long bss, start_addr, len, error;\r\nint retval;\r\nstruct exec ex;\r\ninode = file->f_path.dentry->d_inode;\r\nretval = -ENOEXEC;\r\nerror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\r\nif (error != sizeof(ex))\r\ngoto out;\r\nif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\r\nN_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\r\ni_size_read(inode) <\r\nex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\r\ngoto out;\r\n}\r\nif (N_FLAGS(ex))\r\ngoto out;\r\nstart_addr = ex.a_entry & 0xfffff000;\r\nif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\r\nloff_t pos = N_TXTOFF(ex);\r\n#ifdef WARN_OLD\r\nstatic unsigned long error_time;\r\nif (time_after(jiffies, error_time + 5*HZ)) {\r\nprintk(KERN_WARNING\r\n"N_TXTOFF is not page aligned. Please convert "\r\n"library: %s\n",\r\nfile->f_path.dentry->d_name.name);\r\nerror_time = jiffies;\r\n}\r\n#endif\r\ndown_write(&current->mm->mmap_sem);\r\ndo_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\r\nup_write(&current->mm->mmap_sem);\r\nfile->f_op->read(file, (char __user *)start_addr,\r\nex.a_text + ex.a_data, &pos);\r\nflush_icache_range((unsigned long) start_addr,\r\n(unsigned long) start_addr + ex.a_text +\r\nex.a_data);\r\nretval = 0;\r\ngoto out;\r\n}\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_mmap(file, start_addr, ex.a_text + ex.a_data,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_32BIT,\r\nN_TXTOFF(ex));\r\nup_write(&current->mm->mmap_sem);\r\nretval = error;\r\nif (error != start_addr)\r\ngoto out;\r\nlen = PAGE_ALIGN(ex.a_text + ex.a_data);\r\nbss = ex.a_text + ex.a_data + ex.a_bss;\r\nif (bss > len) {\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_brk(start_addr + len, bss - len);\r\nup_write(&current->mm->mmap_sem);\r\nretval = error;\r\nif (error != start_addr + len)\r\ngoto out;\r\n}\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int __init init_aout_binfmt(void)\r\n{\r\nreturn register_binfmt(&aout_format);\r\n}\r\nstatic void __exit exit_aout_binfmt(void)\r\n{\r\nunregister_binfmt(&aout_format);\r\n}
