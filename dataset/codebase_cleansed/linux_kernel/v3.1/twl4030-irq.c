static int twl4030_irq_thread(void *data)\r\n{\r\nlong irq = (long)data;\r\nstatic unsigned i2c_errors;\r\nstatic const unsigned max_i2c_errors = 100;\r\ncurrent->flags |= PF_NOFREEZE;\r\nwhile (!kthread_should_stop()) {\r\nint ret;\r\nint module_irq;\r\nu8 pih_isr;\r\nwait_for_completion_interruptible(&irq_event);\r\nret = twl_i2c_read_u8(TWL4030_MODULE_PIH, &pih_isr,\r\nREG_PIH_ISR_P1);\r\nif (ret) {\r\npr_warning("twl4030: I2C error %d reading PIH ISR\n",\r\nret);\r\nif (++i2c_errors >= max_i2c_errors) {\r\nprintk(KERN_ERR "Maximum I2C error count"\r\n" exceeded. Terminating %s.\n",\r\n__func__);\r\nbreak;\r\n}\r\ncomplete(&irq_event);\r\ncontinue;\r\n}\r\nlocal_irq_disable();\r\nfor (module_irq = twl4030_irq_base;\r\npih_isr;\r\npih_isr >>= 1, module_irq++) {\r\nif (pih_isr & 0x1)\r\ngeneric_handle_irq(module_irq);\r\n}\r\nlocal_irq_enable();\r\nenable_irq(irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t handle_twl4030_pih(int irq, void *devid)\r\n{\r\ndisable_irq_nosync(irq);\r\ncomplete(devid);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl4030_init_sih_modules(unsigned line)\r\n{\r\nconst struct sih *sih;\r\nu8 buf[4];\r\nint i;\r\nint status;\r\nif (line > 1)\r\nreturn -EINVAL;\r\nirq_line = line;\r\nmemset(buf, 0xff, sizeof buf);\r\nsih = sih_modules;\r\nfor (i = 0; i < nr_sih_modules; i++, sih++) {\r\nif (!sih->bytes_ixr)\r\ncontinue;\r\nif (sih->irq_lines <= line)\r\ncontinue;\r\nstatus = twl_i2c_write(sih->module, buf,\r\nsih->mask[line].imr_offset, sih->bytes_ixr);\r\nif (status < 0)\r\npr_err("twl4030: err %d initializing %s %s\n",\r\nstatus, sih->name, "IMR");\r\nif (sih->set_cor) {\r\nstatus = twl_i2c_write_u8(sih->module,\r\nTWL4030_SIH_CTRL_COR_MASK,\r\nsih->control_offset);\r\nif (status < 0)\r\npr_err("twl4030: err %d initializing %s %s\n",\r\nstatus, sih->name, "SIH_CTRL");\r\n}\r\n}\r\nsih = sih_modules;\r\nfor (i = 0; i < nr_sih_modules; i++, sih++) {\r\nu8 rxbuf[4];\r\nint j;\r\nif (!sih->bytes_ixr)\r\ncontinue;\r\nif (sih->irq_lines <= line)\r\ncontinue;\r\nfor (j = 0; j < 2; j++) {\r\nstatus = twl_i2c_read(sih->module, rxbuf,\r\nsih->mask[line].isr_offset, sih->bytes_ixr);\r\nif (status < 0)\r\npr_err("twl4030: err %d initializing %s %s\n",\r\nstatus, sih->name, "ISR");\r\nif (!sih->set_cor)\r\nstatus = twl_i2c_write(sih->module, buf,\r\nsih->mask[line].isr_offset,\r\nsih->bytes_ixr);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void activate_irq(int irq)\r\n{\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nstatic void twl4030_sih_do_mask(struct work_struct *work)\r\n{\r\nstruct sih_agent *agent;\r\nconst struct sih *sih;\r\nunion {\r\nu8 bytes[4];\r\nu32 word;\r\n} imr;\r\nint status;\r\nagent = container_of(work, struct sih_agent, mask_work);\r\nspin_lock_irq(&sih_agent_lock);\r\nif (agent->imr_change_pending) {\r\nsih = agent->sih;\r\nimr.word = cpu_to_le32(agent->imr << 8);\r\nagent->imr_change_pending = false;\r\n} else\r\nsih = NULL;\r\nspin_unlock_irq(&sih_agent_lock);\r\nif (!sih)\r\nreturn;\r\nstatus = twl_i2c_write(sih->module, imr.bytes,\r\nsih->mask[irq_line].imr_offset, sih->bytes_ixr);\r\nif (status)\r\npr_err("twl4030: %s, %s --> %d\n", __func__,\r\n"write", status);\r\n}\r\nstatic void twl4030_sih_do_edge(struct work_struct *work)\r\n{\r\nstruct sih_agent *agent;\r\nconst struct sih *sih;\r\nu8 bytes[6];\r\nu32 edge_change;\r\nint status;\r\nagent = container_of(work, struct sih_agent, edge_work);\r\nspin_lock_irq(&sih_agent_lock);\r\nedge_change = agent->edge_change;\r\nagent->edge_change = 0;\r\nsih = edge_change ? agent->sih : NULL;\r\nspin_unlock_irq(&sih_agent_lock);\r\nif (!sih)\r\nreturn;\r\nstatus = twl_i2c_read(sih->module, bytes + 1,\r\nsih->edr_offset, sih->bytes_edr);\r\nif (status) {\r\npr_err("twl4030: %s, %s --> %d\n", __func__,\r\n"read", status);\r\nreturn;\r\n}\r\nwhile (edge_change) {\r\nint i = fls(edge_change) - 1;\r\nstruct irq_data *idata = irq_get_irq_data(i + agent->irq_base);\r\nint byte = 1 + (i >> 2);\r\nint off = (i & 0x3) * 2;\r\nunsigned int type;\r\nbytes[byte] &= ~(0x03 << off);\r\ntype = irqd_get_trigger_type(idata);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nbytes[byte] |= BIT(off + 1);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nbytes[byte] |= BIT(off + 0);\r\nedge_change &= ~BIT(i);\r\n}\r\nstatus = twl_i2c_write(sih->module, bytes,\r\nsih->edr_offset, sih->bytes_edr);\r\nif (status)\r\npr_err("twl4030: %s, %s --> %d\n", __func__,\r\n"write", status);\r\n}\r\nstatic void twl4030_sih_mask(struct irq_data *data)\r\n{\r\nstruct sih_agent *sih = irq_data_get_irq_chip_data(data);\r\nunsigned long flags;\r\nspin_lock_irqsave(&sih_agent_lock, flags);\r\nsih->imr |= BIT(data->irq - sih->irq_base);\r\nsih->imr_change_pending = true;\r\nqueue_work(wq, &sih->mask_work);\r\nspin_unlock_irqrestore(&sih_agent_lock, flags);\r\n}\r\nstatic void twl4030_sih_unmask(struct irq_data *data)\r\n{\r\nstruct sih_agent *sih = irq_data_get_irq_chip_data(data);\r\nunsigned long flags;\r\nspin_lock_irqsave(&sih_agent_lock, flags);\r\nsih->imr &= ~BIT(data->irq - sih->irq_base);\r\nsih->imr_change_pending = true;\r\nqueue_work(wq, &sih->mask_work);\r\nspin_unlock_irqrestore(&sih_agent_lock, flags);\r\n}\r\nstatic int twl4030_sih_set_type(struct irq_data *data, unsigned trigger)\r\n{\r\nstruct sih_agent *sih = irq_data_get_irq_chip_data(data);\r\nunsigned long flags;\r\nif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&sih_agent_lock, flags);\r\nif (irqd_get_trigger_type(data) != trigger) {\r\nsih->edge_change |= BIT(data->irq - sih->irq_base);\r\nqueue_work(wq, &sih->edge_work);\r\n}\r\nspin_unlock_irqrestore(&sih_agent_lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline int sih_read_isr(const struct sih *sih)\r\n{\r\nint status;\r\nunion {\r\nu8 bytes[4];\r\nu32 word;\r\n} isr;\r\nisr.word = 0;\r\nstatus = twl_i2c_read(sih->module, isr.bytes,\r\nsih->mask[irq_line].isr_offset, sih->bytes_ixr);\r\nreturn (status < 0) ? status : le32_to_cpu(isr.word);\r\n}\r\nstatic void handle_twl4030_sih(unsigned irq, struct irq_desc *desc)\r\n{\r\nstruct sih_agent *agent = irq_get_handler_data(irq);\r\nconst struct sih *sih = agent->sih;\r\nint isr;\r\nlocal_irq_enable();\r\nisr = sih_read_isr(sih);\r\nlocal_irq_disable();\r\nif (isr < 0) {\r\npr_err("twl4030: %s SIH, read ISR error %d\n",\r\nsih->name, isr);\r\nreturn;\r\n}\r\nwhile (isr) {\r\nirq = fls(isr);\r\nirq--;\r\nisr &= ~BIT(irq);\r\nif (irq < sih->bits)\r\ngeneric_handle_irq(agent->irq_base + irq);\r\nelse\r\npr_err("twl4030: %s SIH, invalid ISR bit %d\n",\r\nsih->name, irq);\r\n}\r\n}\r\nint twl4030_sih_setup(int module)\r\n{\r\nint sih_mod;\r\nconst struct sih *sih = NULL;\r\nstruct sih_agent *agent;\r\nint i, irq;\r\nint status = -EINVAL;\r\nunsigned irq_base = twl4030_irq_next;\r\nfor (sih_mod = 0, sih = sih_modules;\r\nsih_mod < nr_sih_modules;\r\nsih_mod++, sih++) {\r\nif (sih->module == module && sih->set_cor) {\r\nif (!WARN((irq_base + sih->bits) > NR_IRQS,\r\n"irq %d for %s too big\n",\r\nirq_base + sih->bits,\r\nsih->name))\r\nstatus = 0;\r\nbreak;\r\n}\r\n}\r\nif (status < 0)\r\nreturn status;\r\nagent = kzalloc(sizeof *agent, GFP_KERNEL);\r\nif (!agent)\r\nreturn -ENOMEM;\r\nstatus = 0;\r\nagent->irq_base = irq_base;\r\nagent->sih = sih;\r\nagent->imr = ~0;\r\nINIT_WORK(&agent->mask_work, twl4030_sih_do_mask);\r\nINIT_WORK(&agent->edge_work, twl4030_sih_do_edge);\r\nfor (i = 0; i < sih->bits; i++) {\r\nirq = irq_base + i;\r\nirq_set_chip_and_handler(irq, &twl4030_sih_irq_chip,\r\nhandle_edge_irq);\r\nirq_set_chip_data(irq, agent);\r\nactivate_irq(irq);\r\n}\r\nstatus = irq_base;\r\ntwl4030_irq_next += i;\r\nirq = sih_mod + twl4030_irq_base;\r\nirq_set_handler_data(irq, agent);\r\nirq_set_chained_handler(irq, handle_twl4030_sih);\r\npr_info("twl4030: %s (irq %d) chaining IRQs %d..%d\n", sih->name,\r\nirq, irq_base, twl4030_irq_next - 1);\r\nreturn status;\r\n}\r\nint twl4030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end)\r\n{\r\nstatic struct irq_chip twl4030_irq_chip;\r\nint status;\r\nint i;\r\nstruct task_struct *task;\r\nstatus = twl4030_init_sih_modules(twl_irq_line);\r\nif (status < 0)\r\nreturn status;\r\nwq = create_singlethread_workqueue("twl4030-irqchip");\r\nif (!wq) {\r\npr_err("twl4030: workqueue FAIL\n");\r\nreturn -ESRCH;\r\n}\r\ntwl4030_irq_base = irq_base;\r\ntwl4030_irq_chip = dummy_irq_chip;\r\ntwl4030_irq_chip.name = "twl4030";\r\ntwl4030_sih_irq_chip.irq_ack = dummy_irq_chip.irq_ack;\r\nfor (i = irq_base; i < irq_end; i++) {\r\nirq_set_chip_and_handler(i, &twl4030_irq_chip,\r\nhandle_simple_irq);\r\nactivate_irq(i);\r\n}\r\ntwl4030_irq_next = i;\r\npr_info("twl4030: %s (irq %d) chaining IRQs %d..%d\n", "PIH",\r\nirq_num, irq_base, twl4030_irq_next - 1);\r\nstatus = twl4030_sih_setup(TWL4030_MODULE_INT);\r\nif (status < 0) {\r\npr_err("twl4030: sih_setup PWR INT --> %d\n", status);\r\ngoto fail;\r\n}\r\ninit_completion(&irq_event);\r\nstatus = request_irq(irq_num, handle_twl4030_pih, IRQF_DISABLED,\r\n"TWL4030-PIH", &irq_event);\r\nif (status < 0) {\r\npr_err("twl4030: could not claim irq%d: %d\n", irq_num, status);\r\ngoto fail_rqirq;\r\n}\r\ntask = kthread_run(twl4030_irq_thread, (void *)(long)irq_num,\r\n"twl4030-irq");\r\nif (IS_ERR(task)) {\r\npr_err("twl4030: could not create irq %d thread!\n", irq_num);\r\nstatus = PTR_ERR(task);\r\ngoto fail_kthread;\r\n}\r\nreturn status;\r\nfail_kthread:\r\nfree_irq(irq_num, &irq_event);\r\nfail_rqirq:\r\nfail:\r\nfor (i = irq_base; i < irq_end; i++)\r\nirq_set_chip_and_handler(i, NULL, NULL);\r\ndestroy_workqueue(wq);\r\nwq = NULL;\r\nreturn status;\r\n}\r\nint twl4030_exit_irq(void)\r\n{\r\nif (twl4030_irq_base) {\r\npr_err("twl4030: can't yet clean up IRQs?\n");\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nint twl4030_init_chip_irq(const char *chip)\r\n{\r\nif (!strcmp(chip, "twl5031")) {\r\nsih_modules = sih_modules_twl5031;\r\nnr_sih_modules = ARRAY_SIZE(sih_modules_twl5031);\r\n} else {\r\nsih_modules = sih_modules_twl4030;\r\nnr_sih_modules = ARRAY_SIZE(sih_modules_twl4030);\r\n}\r\nreturn 0;\r\n}
