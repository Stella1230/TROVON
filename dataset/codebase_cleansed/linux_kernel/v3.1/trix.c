static unsigned char trix_read(int addr)\r\n{\r\noutb(((unsigned char) addr), 0x390);\r\nreturn inb(0x391);\r\n}\r\nstatic void trix_write(int addr, int data)\r\n{\r\noutb(((unsigned char) addr), 0x390);\r\noutb(((unsigned char) data), 0x391);\r\n}\r\nstatic void download_boot(int base)\r\n{\r\nint i = 0, n = trix_boot_len;\r\nif (trix_boot_len == 0)\r\nreturn;\r\ntrix_write(0xf8, 0x00);\r\noutb((0x01), base + 6);\r\noutb((0x00), base + 6);\r\noutb((0x01), base + 6);\r\noutb((0x1A), 0x390);\r\nfor (i = 0; i < n; i++)\r\noutb((trix_boot[i]), 0x391);\r\nfor (i = n; i < 10016; i++)\r\noutb((0x00), 0x391);\r\noutb((0x00), base + 6);\r\noutb((0x50), 0x390);\r\n}\r\nstatic int trix_set_wss_port(struct address_info *hw_config)\r\n{\r\nunsigned char addr_bits;\r\nif (trix_read(0x15) != 0x71)\r\n{\r\nMDB(printk(KERN_ERR "No AudioTrix ASIC signature found\n"));\r\nreturn 0;\r\n}\r\ntrix_write(0x13, 0);\r\ntrix_write(0x14, 0);\r\nswitch (hw_config->io_base)\r\n{\r\ncase 0x530:\r\naddr_bits = 0;\r\nbreak;\r\ncase 0x604:\r\naddr_bits = 1;\r\nbreak;\r\ncase 0xE80:\r\naddr_bits = 2;\r\nbreak;\r\ncase 0xF40:\r\naddr_bits = 3;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ntrix_write(0x19, (trix_read(0x19) & 0x03) | addr_bits);\r\nreturn 1;\r\n}\r\nstatic int __init init_trix_wss(struct address_info *hw_config)\r\n{\r\nstatic unsigned char dma_bits[4] = {\r\n1, 2, 0, 3\r\n};\r\nstruct resource *ports;\r\nint config_port = hw_config->io_base + 0;\r\nint dma1 = hw_config->dma, dma2 = hw_config->dma2;\r\nint old_num_mixers = num_mixers;\r\nu8 config, bits;\r\nint ret;\r\nswitch(hw_config->irq) {\r\ncase 7:\r\nbits = 8;\r\nbreak;\r\ncase 9:\r\nbits = 0x10;\r\nbreak;\r\ncase 10:\r\nbits = 0x18;\r\nbreak;\r\ncase 11:\r\nbits = 0x20;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "AudioTrix: Bad WSS IRQ %d\n", hw_config->irq);\r\nreturn 0;\r\n}\r\nswitch (dma1) {\r\ncase 0:\r\ncase 1:\r\ncase 3:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "AudioTrix: Bad WSS DMA %d\n", dma1);\r\nreturn 0;\r\n}\r\nswitch (dma2) {\r\ncase -1:\r\ncase 0:\r\ncase 1:\r\ncase 3:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "AudioTrix: Bad capture DMA %d\n", dma2);\r\nreturn 0;\r\n}\r\nports = request_region(hw_config->io_base + 4, 4, "ad1848");\r\nif (!ports) {\r\nprintk(KERN_ERR "AudioTrix: MSS I/O port conflict (%x)\n", hw_config->io_base);\r\nreturn 0;\r\n}\r\nif (!request_region(hw_config->io_base, 4, "MSS config")) {\r\nprintk(KERN_ERR "AudioTrix: MSS I/O port conflict (%x)\n", hw_config->io_base);\r\nrelease_region(hw_config->io_base + 4, 4);\r\nreturn 0;\r\n}\r\nif (!trix_set_wss_port(hw_config))\r\ngoto fail;\r\nconfig = inb(hw_config->io_base + 3);\r\nif ((config & 0x3f) != 0x00)\r\n{\r\nMDB(printk(KERN_ERR "No MSS signature detected on port 0x%x\n", hw_config->io_base));\r\ngoto fail;\r\n}\r\nif (dma1 == 0 && config & 0x80)\r\n{\r\nprintk(KERN_ERR "AudioTrix: Can't use DMA0 with a 8 bit card slot\n");\r\ngoto fail;\r\n}\r\nif (hw_config->irq > 9 && config & 0x80)\r\n{\r\nprintk(KERN_ERR "AudioTrix: Can't use IRQ%d with a 8 bit card slot\n", hw_config->irq);\r\ngoto fail;\r\n}\r\nret = ad1848_detect(ports, NULL, hw_config->osp);\r\nif (!ret)\r\ngoto fail;\r\nif (joystick==1)\r\ntrix_write(0x15, 0x80);\r\noutb((bits | 0x40), config_port);\r\nif (dma2 == -1 || dma2 == dma1)\r\n{\r\nbits |= dma_bits[dma1];\r\ndma2 = dma1;\r\n}\r\nelse\r\n{\r\nunsigned char tmp;\r\ntmp = trix_read(0x13) & ~30;\r\ntrix_write(0x13, tmp | 0x80 | (dma1 << 4));\r\ntmp = trix_read(0x14) & ~30;\r\ntrix_write(0x14, tmp | 0x80 | (dma2 << 4));\r\n}\r\noutb((bits), config_port);\r\nhw_config->slots[0] = ad1848_init("AudioTrix Pro", ports,\r\nhw_config->irq,\r\ndma1,\r\ndma2,\r\n0,\r\nhw_config->osp,\r\nTHIS_MODULE);\r\nif (num_mixers > old_num_mixers)\r\n{\r\nAD1848_REROUTE(SOUND_MIXER_LINE1, SOUND_MIXER_LINE);\r\nAD1848_REROUTE(SOUND_MIXER_LINE2, SOUND_MIXER_CD);\r\nAD1848_REROUTE(SOUND_MIXER_LINE3, SOUND_MIXER_SYNTH);\r\nAD1848_REROUTE(SOUND_MIXER_SPEAKER, SOUND_MIXER_ALTPCM);\r\n}\r\nreturn 1;\r\nfail:\r\nrelease_region(hw_config->io_base, 4);\r\nrelease_region(hw_config->io_base + 4, 4);\r\nreturn 0;\r\n}\r\nstatic int __init probe_trix_sb(struct address_info *hw_config)\r\n{\r\nint tmp;\r\nunsigned char conf;\r\nextern int sb_be_quiet;\r\nint old_quiet;\r\nstatic signed char irq_translate[] = {\r\n-1, -1, -1, 0, 1, 2, -1, 3\r\n};\r\nif (trix_boot_len == 0)\r\nreturn 0;\r\nif ((hw_config->io_base & 0xffffff8f) != 0x200)\r\nreturn 0;\r\ntmp = hw_config->irq;\r\nif (tmp > 7)\r\nreturn 0;\r\nif (irq_translate[tmp] == -1)\r\nreturn 0;\r\ntmp = hw_config->dma;\r\nif (tmp != 1 && tmp != 3)\r\nreturn 0;\r\nif (!request_region(hw_config->io_base, 16, "soundblaster")) {\r\nprintk(KERN_ERR "AudioTrix: SB I/O port conflict (%x)\n", hw_config->io_base);\r\nreturn 0;\r\n}\r\nconf = 0x84;\r\nconf |= hw_config->io_base & 0x70;\r\nconf |= irq_translate[hw_config->irq];\r\nif (hw_config->dma == 3)\r\nconf |= 0x08;\r\ntrix_write(0x1b, conf);\r\ndownload_boot(hw_config->io_base);\r\nhw_config->name = "AudioTrix SB";\r\nif (!sb_dsp_detect(hw_config, 0, 0, NULL)) {\r\nrelease_region(hw_config->io_base, 16);\r\nreturn 0;\r\n}\r\nhw_config->driver_use_1 = SB_NO_MIDI | SB_NO_MIXER | SB_NO_RECORDING;\r\nold_quiet = sb_be_quiet;\r\nsb_be_quiet = 1;\r\nsb_dsp_init(hw_config, THIS_MODULE);\r\nsb_be_quiet = old_quiet;\r\nreturn 1;\r\n}\r\nstatic int __init probe_trix_mpu(struct address_info *hw_config)\r\n{\r\nunsigned char conf;\r\nstatic int irq_bits[] = {\r\n-1, -1, -1, 1, 2, 3, -1, 4, -1, 5\r\n};\r\nif (hw_config->irq > 9)\r\n{\r\nprintk(KERN_ERR "AudioTrix: Bad MPU IRQ %d\n", hw_config->irq);\r\nreturn 0;\r\n}\r\nif (irq_bits[hw_config->irq] == -1)\r\n{\r\nprintk(KERN_ERR "AudioTrix: Bad MPU IRQ %d\n", hw_config->irq);\r\nreturn 0;\r\n}\r\nswitch (hw_config->io_base)\r\n{\r\ncase 0x330:\r\nconf = 0x00;\r\nbreak;\r\ncase 0x370:\r\nconf = 0x04;\r\nbreak;\r\ncase 0x3b0:\r\nconf = 0x08;\r\nbreak;\r\ncase 0x3f0:\r\nconf = 0x0c;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nconf |= irq_bits[hw_config->irq] << 4;\r\ntrix_write(0x19, (trix_read(0x19) & 0x83) | conf);\r\nhw_config->name = "AudioTrix Pro";\r\nreturn probe_uart401(hw_config, THIS_MODULE);\r\n}\r\nstatic void __exit unload_trix_wss(struct address_info *hw_config)\r\n{\r\nint dma2 = hw_config->dma2;\r\nif (dma2 == -1)\r\ndma2 = hw_config->dma;\r\nrelease_region(0x390, 2);\r\nrelease_region(hw_config->io_base, 4);\r\nad1848_unload(hw_config->io_base + 4,\r\nhw_config->irq,\r\nhw_config->dma,\r\ndma2,\r\n0);\r\nsound_unload_audiodev(hw_config->slots[0]);\r\n}\r\nstatic inline void __exit unload_trix_mpu(struct address_info *hw_config)\r\n{\r\nunload_uart401(hw_config);\r\n}\r\nstatic inline void __exit unload_trix_sb(struct address_info *hw_config)\r\n{\r\nsb_dsp_unload(hw_config, mpu);\r\n}\r\nstatic int __init init_trix(void)\r\n{\r\nprintk(KERN_INFO "MediaTrix audio driver Copyright (C) by Hannu Savolainen 1993-1996\n");\r\ncfg.io_base = io;\r\ncfg.irq = irq;\r\ncfg.dma = dma;\r\ncfg.dma2 = dma2;\r\ncfg2.io_base = sb_io;\r\ncfg2.irq = sb_irq;\r\ncfg2.dma = sb_dma;\r\ncfg_mpu.io_base = mpu_io;\r\ncfg_mpu.irq = mpu_irq;\r\nif (cfg.io_base == -1 || cfg.dma == -1 || cfg.irq == -1) {\r\nprintk(KERN_INFO "I/O, IRQ, DMA and type are mandatory\n");\r\nreturn -EINVAL;\r\n}\r\nif (cfg2.io_base != -1 && (cfg2.irq == -1 || cfg2.dma == -1)) {\r\nprintk(KERN_INFO "CONFIG_SB_IRQ and CONFIG_SB_DMA must be specified if SB_IO is set.\n");\r\nreturn -EINVAL;\r\n}\r\nif (cfg_mpu.io_base != -1 && cfg_mpu.irq == -1) {\r\nprintk(KERN_INFO "CONFIG_MPU_IRQ must be specified if MPU_IO is set.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!trix_boot)\r\n{\r\nfw_load = 1;\r\ntrix_boot_len = mod_firmware_load("/etc/sound/trxpro.bin",\r\n(char **) &trix_boot);\r\n}\r\nif (!request_region(0x390, 2, "AudioTrix")) {\r\nprintk(KERN_ERR "AudioTrix: Config port I/O conflict\n");\r\nreturn -ENODEV;\r\n}\r\nif (!init_trix_wss(&cfg)) {\r\nrelease_region(0x390, 2);\r\nreturn -ENODEV;\r\n}\r\nif (cfg2.io_base != -1) {\r\nsb = probe_trix_sb(&cfg2);\r\n}\r\nif (cfg_mpu.io_base != -1)\r\nmpu = probe_trix_mpu(&cfg_mpu);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_trix(void)\r\n{\r\nif (fw_load && trix_boot)\r\nvfree(trix_boot);\r\nif (sb)\r\nunload_trix_sb(&cfg2);\r\nif (mpu)\r\nunload_trix_mpu(&cfg_mpu);\r\nunload_trix_wss(&cfg);\r\n}\r\nstatic int __init setup_trix (char *str)\r\n{\r\nint ints[9];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nio = ints[1];\r\nirq = ints[2];\r\ndma = ints[3];\r\ndma2 = ints[4];\r\nsb_io = ints[5];\r\nsb_irq = ints[6];\r\nsb_dma = ints[6];\r\nmpu_io = ints[7];\r\nmpu_irq = ints[8];\r\nreturn 1;\r\n}
