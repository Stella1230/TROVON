static void wdtpci_ctr_mode(int ctr, int mode)\r\n{\r\nctr <<= 6;\r\nctr |= 0x30;\r\nctr |= (mode << 1);\r\noutb(ctr, WDT_CR);\r\nudelay(8);\r\n}\r\nstatic void wdtpci_ctr_load(int ctr, int val)\r\n{\r\noutb(val & 0xFF, WDT_COUNT0 + ctr);\r\nudelay(8);\r\noutb(val >> 8, WDT_COUNT0 + ctr);\r\nudelay(8);\r\n}\r\nstatic int wdtpci_start(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdtpci_lock, flags);\r\ninb(WDT_DC);\r\nudelay(8);\r\nwdtpci_ctr_mode(2, 0);\r\noutb(0, WDT_DC);\r\nudelay(8);\r\ninb(WDT_DC);\r\nudelay(8);\r\noutb(0, WDT_CLOCK);\r\nudelay(8);\r\ninb(WDT_BUZZER);\r\nudelay(8);\r\ninb(WDT_OPTONOTRST);\r\nudelay(8);\r\ninb(WDT_OPTORST);\r\nudelay(8);\r\ninb(WDT_PROGOUT);\r\nudelay(8);\r\nwdtpci_ctr_mode(0, 3);\r\nwdtpci_ctr_mode(1, 2);\r\nwdtpci_ctr_mode(2, 1);\r\nwdtpci_ctr_load(0, 20833);\r\nwdtpci_ctr_load(1, wd_heartbeat);\r\noutb(0, WDT_DC);\r\nudelay(8);\r\nspin_unlock_irqrestore(&wdtpci_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int wdtpci_stop(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdtpci_lock, flags);\r\ninb(WDT_DC);\r\nudelay(8);\r\nwdtpci_ctr_load(2, 0);\r\nspin_unlock_irqrestore(&wdtpci_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int wdtpci_ping(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdtpci_lock, flags);\r\ninb(WDT_DC);\r\nudelay(8);\r\nwdtpci_ctr_mode(1, 2);\r\nwdtpci_ctr_load(1, wd_heartbeat);\r\noutb(0, WDT_DC);\r\nudelay(8);\r\nspin_unlock_irqrestore(&wdtpci_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int wdtpci_set_heartbeat(int t)\r\n{\r\nif (t < 1 || t > 65535)\r\nreturn -EINVAL;\r\nheartbeat = t;\r\nwd_heartbeat = t * 100;\r\nreturn 0;\r\n}\r\nstatic int wdtpci_get_status(int *status)\r\n{\r\nunsigned char new_status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdtpci_lock, flags);\r\nnew_status = inb(WDT_SR);\r\nspin_unlock_irqrestore(&wdtpci_lock, flags);\r\n*status = 0;\r\nif (new_status & WDC_SR_ISOI0)\r\n*status |= WDIOF_EXTERN1;\r\nif (new_status & WDC_SR_ISII1)\r\n*status |= WDIOF_EXTERN2;\r\nif (type == 501) {\r\nif (!(new_status & WDC_SR_TGOOD))\r\n*status |= WDIOF_OVERHEAT;\r\nif (!(new_status & WDC_SR_PSUOVER))\r\n*status |= WDIOF_POWEROVER;\r\nif (!(new_status & WDC_SR_PSUUNDR))\r\n*status |= WDIOF_POWERUNDER;\r\nif (tachometer) {\r\nif (!(new_status & WDC_SR_FANGOOD))\r\n*status |= WDIOF_FANFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdtpci_get_temperature(int *temperature)\r\n{\r\nunsigned short c;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdtpci_lock, flags);\r\nc = inb(WDT_RT);\r\nudelay(8);\r\nspin_unlock_irqrestore(&wdtpci_lock, flags);\r\n*temperature = (c * 11 / 15) + 7;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wdtpci_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned char status;\r\nspin_lock(&wdtpci_lock);\r\nstatus = inb(WDT_SR);\r\nudelay(8);\r\nprintk(KERN_CRIT PFX "status %d\n", status);\r\nif (type == 501) {\r\nif (!(status & WDC_SR_TGOOD)) {\r\nprintk(KERN_CRIT PFX "Overheat alarm.(%d)\n",\r\ninb(WDT_RT));\r\nudelay(8);\r\n}\r\nif (!(status & WDC_SR_PSUOVER))\r\nprintk(KERN_CRIT PFX "PSU over voltage.\n");\r\nif (!(status & WDC_SR_PSUUNDR))\r\nprintk(KERN_CRIT PFX "PSU under voltage.\n");\r\nif (tachometer) {\r\nif (!(status & WDC_SR_FANGOOD))\r\nprintk(KERN_CRIT PFX "Possible fan fault.\n");\r\n}\r\n}\r\nif (!(status & WDC_SR_WCCR)) {\r\n#ifdef SOFTWARE_REBOOT\r\n#ifdef ONLY_TESTING\r\nprintk(KERN_CRIT PFX "Would Reboot.\n");\r\n#else\r\nprintk(KERN_CRIT PFX "Initiating system reboot.\n");\r\nemergency_restart(NULL);\r\n#endif\r\n#else\r\nprintk(KERN_CRIT PFX "Reset in 5ms.\n");\r\n#endif\r\n}\r\nspin_unlock(&wdtpci_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t wdtpci_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nwdtpci_ping();\r\n}\r\nreturn count;\r\n}\r\nstatic long wdtpci_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint new_heartbeat;\r\nint status;\r\nstruct watchdog_info ident = {\r\n.options = WDIOF_SETTIMEOUT|\r\nWDIOF_MAGICCLOSE|\r\nWDIOF_KEEPALIVEPING,\r\n.firmware_version = 1,\r\n.identity = "PCI-WDT500/501",\r\n};\r\nident.options |= (WDIOF_EXTERN1|WDIOF_EXTERN2);\r\nif (type == 501) {\r\nident.options |= (WDIOF_OVERHEAT|WDIOF_POWERUNDER|\r\nWDIOF_POWEROVER);\r\nif (tachometer)\r\nident.options |= WDIOF_FANFAULT;\r\n}\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nwdtpci_get_status(&status);\r\nreturn put_user(status, p);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nwdtpci_ping();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_heartbeat, p))\r\nreturn -EFAULT;\r\nif (wdtpci_set_heartbeat(new_heartbeat))\r\nreturn -EINVAL;\r\nwdtpci_ping();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int wdtpci_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &open_lock))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nwdtpci_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wdtpci_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42) {\r\nwdtpci_stop();\r\n} else {\r\nprintk(KERN_CRIT PFX "Unexpected close, not stopping timer!");\r\nwdtpci_ping();\r\n}\r\nexpect_close = 0;\r\nclear_bit(0, &open_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t wdtpci_temp_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ptr)\r\n{\r\nint temperature;\r\nif (wdtpci_get_temperature(&temperature))\r\nreturn -EFAULT;\r\nif (copy_to_user(buf, &temperature, 1))\r\nreturn -EFAULT;\r\nreturn 1;\r\n}\r\nstatic int wdtpci_temp_open(struct inode *inode, struct file *file)\r\n{\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wdtpci_temp_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wdtpci_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdtpci_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __devinit wdtpci_init_one(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret = -EIO;\r\ndev_count++;\r\nif (dev_count > 1) {\r\nprintk(KERN_ERR PFX "This driver only supports one device\n");\r\nreturn -ENODEV;\r\n}\r\nif (type != 500 && type != 501) {\r\nprintk(KERN_ERR PFX "unknown card type '%d'.\n", type);\r\nreturn -ENODEV;\r\n}\r\nif (pci_enable_device(dev)) {\r\nprintk(KERN_ERR PFX "Not possible to enable PCI Device\n");\r\nreturn -ENODEV;\r\n}\r\nif (pci_resource_start(dev, 2) == 0x0000) {\r\nprintk(KERN_ERR PFX "No I/O-Address for card detected\n");\r\nret = -ENODEV;\r\ngoto out_pci;\r\n}\r\nif (pci_request_region(dev, 2, "wdt_pci")) {\r\nprintk(KERN_ERR PFX "I/O address 0x%llx already in use\n",\r\n(unsigned long long)pci_resource_start(dev, 2));\r\ngoto out_pci;\r\n}\r\nirq = dev->irq;\r\nio = pci_resource_start(dev, 2);\r\nif (request_irq(irq, wdtpci_interrupt, IRQF_DISABLED | IRQF_SHARED,\r\n"wdt_pci", &wdtpci_miscdev)) {\r\nprintk(KERN_ERR PFX "IRQ %d is not free\n", irq);\r\ngoto out_reg;\r\n}\r\nprintk(KERN_INFO\r\n"PCI-WDT500/501 (PCI-WDG-CSM) driver 0.10 at 0x%llx (Interrupt %d)\n",\r\n(unsigned long long)io, irq);\r\nif (wdtpci_set_heartbeat(heartbeat)) {\r\nwdtpci_set_heartbeat(WD_TIMO);\r\nprintk(KERN_INFO PFX\r\n"heartbeat value must be 0 < heartbeat < 65536, using %d\n",\r\nWD_TIMO);\r\n}\r\nret = register_reboot_notifier(&wdtpci_notifier);\r\nif (ret) {\r\nprintk(KERN_ERR PFX\r\n"cannot register reboot notifier (err=%d)\n", ret);\r\ngoto out_irq;\r\n}\r\nif (type == 501) {\r\nret = misc_register(&temp_miscdev);\r\nif (ret) {\r\nprintk(KERN_ERR PFX\r\n"cannot register miscdev on minor=%d (err=%d)\n",\r\nTEMP_MINOR, ret);\r\ngoto out_rbt;\r\n}\r\n}\r\nret = misc_register(&wdtpci_miscdev);\r\nif (ret) {\r\nprintk(KERN_ERR PFX\r\n"cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto out_misc;\r\n}\r\nprintk(KERN_INFO PFX "initialized. heartbeat=%d sec (nowayout=%d)\n",\r\nheartbeat, nowayout);\r\nif (type == 501)\r\nprintk(KERN_INFO "wdt: Fan Tachometer is %s\n",\r\n(tachometer ? "Enabled" : "Disabled"));\r\nret = 0;\r\nout:\r\nreturn ret;\r\nout_misc:\r\nif (type == 501)\r\nmisc_deregister(&temp_miscdev);\r\nout_rbt:\r\nunregister_reboot_notifier(&wdtpci_notifier);\r\nout_irq:\r\nfree_irq(irq, &wdtpci_miscdev);\r\nout_reg:\r\npci_release_region(dev, 2);\r\nout_pci:\r\npci_disable_device(dev);\r\ngoto out;\r\n}\r\nstatic void __devexit wdtpci_remove_one(struct pci_dev *pdev)\r\n{\r\nmisc_deregister(&wdtpci_miscdev);\r\nif (type == 501)\r\nmisc_deregister(&temp_miscdev);\r\nunregister_reboot_notifier(&wdtpci_notifier);\r\nfree_irq(irq, &wdtpci_miscdev);\r\npci_release_region(pdev, 2);\r\npci_disable_device(pdev);\r\ndev_count--;\r\n}\r\nstatic void __exit wdtpci_cleanup(void)\r\n{\r\npci_unregister_driver(&wdtpci_driver);\r\n}\r\nstatic int __init wdtpci_init(void)\r\n{\r\nreturn pci_register_driver(&wdtpci_driver);\r\n}
