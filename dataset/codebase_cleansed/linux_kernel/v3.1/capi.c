static inline void ignore_cstruct_param(struct cardstate *cs, _cstruct param,\r\nchar *msgname, char *paramname)\r\n{\r\nif (param && *param)\r\ndev_warn(cs->dev, "%s: ignoring unsupported parameter: %s\n",\r\nmsgname, paramname);\r\n}\r\nstatic int encode_ie(char *in, u8 *out, int maxlen)\r\n{\r\nint l = 0;\r\nwhile (*in) {\r\nif (!isxdigit(in[0]) || !isxdigit(in[1]) || l >= maxlen)\r\nreturn -1;\r\nout[++l] = (hex_to_bin(in[0]) << 4) + hex_to_bin(in[1]);\r\nin += 2;\r\n}\r\nout[0] = l;\r\nreturn l;\r\n}\r\nstatic void decode_ie(u8 *in, char *out)\r\n{\r\nint i = *in;\r\nwhile (i-- > 0) {\r\n*out++ = toupper(hex_asc_hi(*++in));\r\n*out++ = toupper(hex_asc_lo(*in));\r\n}\r\n}\r\nstatic inline struct gigaset_capi_appl *\r\nget_appl(struct gigaset_capi_ctr *iif, u16 appl)\r\n{\r\nstruct gigaset_capi_appl *ap;\r\nlist_for_each_entry(ap, &iif->appls, ctrlist)\r\nif (ap->id == appl)\r\nreturn ap;\r\nreturn NULL;\r\n}\r\nstatic inline void dump_cmsg(enum debuglevel level, const char *tag, _cmsg *p)\r\n{\r\n#ifdef CONFIG_GIGASET_DEBUG\r\n_cdebbuf *cdb;\r\nif (!(gigaset_debuglevel & level))\r\nreturn;\r\ncdb = capi_cmsg2str(p);\r\nif (cdb) {\r\ngig_dbg(level, "%s: [%d] %s", tag, p->ApplId, cdb->buf);\r\ncdebbuf_free(cdb);\r\n} else {\r\ngig_dbg(level, "%s: [%d] %s", tag, p->ApplId,\r\ncapi_cmd2str(p->Command, p->Subcommand));\r\n}\r\n#endif\r\n}\r\nstatic inline void dump_rawmsg(enum debuglevel level, const char *tag,\r\nunsigned char *data)\r\n{\r\n#ifdef CONFIG_GIGASET_DEBUG\r\nchar *dbgline;\r\nint i, l;\r\nif (!(gigaset_debuglevel & level))\r\nreturn;\r\nl = CAPIMSG_LEN(data);\r\nif (l < 12) {\r\ngig_dbg(level, "%s: ??? LEN=%04d", tag, l);\r\nreturn;\r\n}\r\ngig_dbg(level, "%s: 0x%02x:0x%02x: ID=%03d #0x%04x LEN=%04d NCCI=0x%x",\r\ntag, CAPIMSG_COMMAND(data), CAPIMSG_SUBCOMMAND(data),\r\nCAPIMSG_APPID(data), CAPIMSG_MSGID(data), l,\r\nCAPIMSG_CONTROL(data));\r\nl -= 12;\r\ndbgline = kmalloc(3*l, GFP_ATOMIC);\r\nif (!dbgline)\r\nreturn;\r\nfor (i = 0; i < l; i++) {\r\ndbgline[3*i] = hex_asc_hi(data[12+i]);\r\ndbgline[3*i+1] = hex_asc_lo(data[12+i]);\r\ndbgline[3*i+2] = ' ';\r\n}\r\ndbgline[3*l-1] = '\0';\r\ngig_dbg(level, " %s", dbgline);\r\nkfree(dbgline);\r\nif (CAPIMSG_COMMAND(data) == CAPI_DATA_B3 &&\r\n(CAPIMSG_SUBCOMMAND(data) == CAPI_REQ ||\r\nCAPIMSG_SUBCOMMAND(data) == CAPI_IND)) {\r\nl = CAPIMSG_DATALEN(data);\r\ngig_dbg(level, " DataLength=%d", l);\r\nif (l <= 0 || !(gigaset_debuglevel & DEBUG_LLDATA))\r\nreturn;\r\nif (l > 64)\r\nl = 64;\r\ndbgline = kmalloc(3*l, GFP_ATOMIC);\r\nif (!dbgline)\r\nreturn;\r\ndata += CAPIMSG_LEN(data);\r\nfor (i = 0; i < l; i++) {\r\ndbgline[3*i] = hex_asc_hi(data[i]);\r\ndbgline[3*i+1] = hex_asc_lo(data[i]);\r\ndbgline[3*i+2] = ' ';\r\n}\r\ndbgline[3*l-1] = '\0';\r\ngig_dbg(level, " %s", dbgline);\r\nkfree(dbgline);\r\n}\r\n#endif\r\n}\r\nstatic const char *format_ie(const char *ie)\r\n{\r\nstatic char result[3*MAX_FMT_IE_LEN];\r\nint len, count;\r\nchar *pout = result;\r\nif (!ie)\r\nreturn "NULL";\r\ncount = len = ie[0];\r\nif (count > MAX_FMT_IE_LEN)\r\ncount = MAX_FMT_IE_LEN-1;\r\nwhile (count--) {\r\n*pout++ = hex_asc_hi(*++ie);\r\n*pout++ = hex_asc_lo(*ie);\r\n*pout++ = ' ';\r\n}\r\nif (len > MAX_FMT_IE_LEN) {\r\n*pout++ = '.';\r\n*pout++ = '.';\r\n*pout++ = '.';\r\n}\r\n*--pout = 0;\r\nreturn result;\r\n}\r\nstatic void send_data_b3_conf(struct cardstate *cs, struct capi_ctr *ctr,\r\nu16 appl, u16 msgid, int channel,\r\nu16 handle, u16 info)\r\n{\r\nstruct sk_buff *cskb;\r\nu8 *msg;\r\ncskb = alloc_skb(CAPI_DATA_B3_CONF_LEN, GFP_ATOMIC);\r\nif (!cskb) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\nmsg = __skb_put(cskb, CAPI_DATA_B3_CONF_LEN);\r\nCAPIMSG_SETLEN(msg, CAPI_DATA_B3_CONF_LEN);\r\nCAPIMSG_SETAPPID(msg, appl);\r\nCAPIMSG_SETCOMMAND(msg, CAPI_DATA_B3);\r\nCAPIMSG_SETSUBCOMMAND(msg, CAPI_CONF);\r\nCAPIMSG_SETMSGID(msg, msgid);\r\nCAPIMSG_SETCONTROLLER(msg, ctr->cnr);\r\nCAPIMSG_SETPLCI_PART(msg, channel);\r\nCAPIMSG_SETNCCI_PART(msg, 1);\r\nCAPIMSG_SETHANDLE_CONF(msg, handle);\r\nCAPIMSG_SETINFO_CONF(msg, info);\r\ndump_rawmsg(DEBUG_MCMD, __func__, msg);\r\ncapi_ctr_handle_message(ctr, appl, cskb);\r\n}\r\nvoid gigaset_skb_sent(struct bc_state *bcs, struct sk_buff *dskb)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\nstruct gigaset_capi_appl *ap = bcs->ap;\r\nunsigned char *req = skb_mac_header(dskb);\r\nu16 flags;\r\n++bcs->trans_up;\r\nif (!ap) {\r\ngig_dbg(DEBUG_MCMD, "%s: application gone", __func__);\r\nreturn;\r\n}\r\nif (bcs->apconnstate < APCONN_ACTIVE) {\r\ngig_dbg(DEBUG_MCMD, "%s: disconnected", __func__);\r\nreturn;\r\n}\r\nflags = CAPIMSG_FLAGS(req);\r\nif (flags & CAPI_FLAGS_DELIVERY_CONFIRMATION)\r\nsend_data_b3_conf(cs, &iif->ctr, ap->id, CAPIMSG_MSGID(req),\r\nbcs->channel + 1, CAPIMSG_HANDLE_REQ(req),\r\n(flags & ~CAPI_FLAGS_DELIVERY_CONFIRMATION) ?\r\nCapiFlagsNotSupportedByProtocol :\r\nCAPI_NOERROR);\r\n}\r\nvoid gigaset_skb_rcvd(struct bc_state *bcs, struct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\nstruct gigaset_capi_appl *ap = bcs->ap;\r\nint len = skb->len;\r\nbcs->trans_down++;\r\nif (!ap) {\r\ngig_dbg(DEBUG_MCMD, "%s: application gone", __func__);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (bcs->apconnstate < APCONN_ACTIVE) {\r\ngig_dbg(DEBUG_MCMD, "%s: disconnected", __func__);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nskb_push(skb, CAPI_DATA_B3_REQ_LEN);\r\nCAPIMSG_SETLEN(skb->data, CAPI_DATA_B3_REQ_LEN);\r\nCAPIMSG_SETAPPID(skb->data, ap->id);\r\nCAPIMSG_SETCOMMAND(skb->data, CAPI_DATA_B3);\r\nCAPIMSG_SETSUBCOMMAND(skb->data, CAPI_IND);\r\nCAPIMSG_SETMSGID(skb->data, ap->nextMessageNumber++);\r\nCAPIMSG_SETCONTROLLER(skb->data, iif->ctr.cnr);\r\nCAPIMSG_SETPLCI_PART(skb->data, bcs->channel + 1);\r\nCAPIMSG_SETNCCI_PART(skb->data, 1);\r\nCAPIMSG_SETDATALEN(skb->data, len);\r\nCAPIMSG_SETFLAGS(skb->data, 0);\r\ndump_rawmsg(DEBUG_MCMD, __func__, skb->data);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, skb);\r\n}\r\nvoid gigaset_isdn_rcv_err(struct bc_state *bcs)\r\n{\r\nif (bcs->ignore) {\r\nbcs->ignore--;\r\nreturn;\r\n}\r\nbcs->corrupted++;\r\n}\r\nint gigaset_isdn_icall(struct at_state_t *at_state)\r\n{\r\nstruct cardstate *cs = at_state->cs;\r\nstruct bc_state *bcs = at_state->bcs;\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\nstruct gigaset_capi_appl *ap;\r\nu32 actCIPmask;\r\nstruct sk_buff *skb;\r\nunsigned int msgsize;\r\nunsigned long flags;\r\nint i;\r\nif (!bcs)\r\nreturn ICALL_IGNORE;\r\ncapi_cmsg_header(&iif->hcmsg, 0, CAPI_CONNECT, CAPI_IND, 0,\r\niif->ctr.cnr | ((bcs->channel + 1) << 8));\r\nmsgsize = CAPI_CONNECT_IND_BASELEN;\r\nif (at_state->str_var[STR_ZBC]) {\r\nif (encode_ie(at_state->str_var[STR_ZBC], iif->bc_buf,\r\nMAX_BC_OCTETS) < 0) {\r\ndev_warn(cs->dev, "RING ignored - bad BC %s\n",\r\nat_state->str_var[STR_ZBC]);\r\nreturn ICALL_IGNORE;\r\n}\r\niif->hcmsg.CIPValue = 0;\r\nfor (i = 0; i < ARRAY_SIZE(cip2bchlc); i++)\r\nif (cip2bchlc[i].bc != NULL &&\r\ncip2bchlc[i].hlc == NULL &&\r\n!strcmp(cip2bchlc[i].bc,\r\nat_state->str_var[STR_ZBC])) {\r\niif->hcmsg.CIPValue = i;\r\nbreak;\r\n}\r\n} else {\r\niif->hcmsg.CIPValue = 1;\r\nencode_ie(cip2bchlc[1].bc, iif->bc_buf, MAX_BC_OCTETS);\r\n}\r\niif->hcmsg.BC = iif->bc_buf;\r\nmsgsize += iif->hcmsg.BC[0];\r\nif (at_state->str_var[STR_ZHLC]) {\r\nif (encode_ie(at_state->str_var[STR_ZHLC], iif->hlc_buf,\r\nMAX_HLC_OCTETS) < 0) {\r\ndev_warn(cs->dev, "RING ignored - bad HLC %s\n",\r\nat_state->str_var[STR_ZHLC]);\r\nreturn ICALL_IGNORE;\r\n}\r\niif->hcmsg.HLC = iif->hlc_buf;\r\nmsgsize += iif->hcmsg.HLC[0];\r\nif (at_state->str_var[STR_ZBC])\r\nfor (i = 0; i < ARRAY_SIZE(cip2bchlc); i++)\r\nif (cip2bchlc[i].hlc != NULL &&\r\n!strcmp(cip2bchlc[i].hlc,\r\nat_state->str_var[STR_ZHLC]) &&\r\n!strcmp(cip2bchlc[i].bc,\r\nat_state->str_var[STR_ZBC])) {\r\niif->hcmsg.CIPValue = i;\r\nbreak;\r\n}\r\n}\r\nif (at_state->str_var[STR_ZCPN]) {\r\ni = strlen(at_state->str_var[STR_ZCPN]);\r\nif (i > MAX_NUMBER_DIGITS) {\r\ndev_warn(cs->dev, "RING ignored - bad number %s\n",\r\nat_state->str_var[STR_ZBC]);\r\nreturn ICALL_IGNORE;\r\n}\r\niif->cdpty_buf[0] = i + 1;\r\niif->cdpty_buf[1] = 0x80;\r\nmemcpy(iif->cdpty_buf+2, at_state->str_var[STR_ZCPN], i);\r\niif->hcmsg.CalledPartyNumber = iif->cdpty_buf;\r\nmsgsize += iif->hcmsg.CalledPartyNumber[0];\r\n}\r\nif (at_state->str_var[STR_NMBR]) {\r\ni = strlen(at_state->str_var[STR_NMBR]);\r\nif (i > MAX_NUMBER_DIGITS) {\r\ndev_warn(cs->dev, "RING ignored - bad number %s\n",\r\nat_state->str_var[STR_ZBC]);\r\nreturn ICALL_IGNORE;\r\n}\r\niif->cgpty_buf[0] = i + 2;\r\niif->cgpty_buf[1] = 0x00;\r\niif->cgpty_buf[2] = 0x80;\r\nmemcpy(iif->cgpty_buf+3, at_state->str_var[STR_NMBR], i);\r\niif->hcmsg.CallingPartyNumber = iif->cgpty_buf;\r\nmsgsize += iif->hcmsg.CallingPartyNumber[0];\r\n}\r\ngig_dbg(DEBUG_CMD, "icall: PLCI %x CIP %d BC %s",\r\niif->hcmsg.adr.adrPLCI, iif->hcmsg.CIPValue,\r\nformat_ie(iif->hcmsg.BC));\r\ngig_dbg(DEBUG_CMD, "icall: HLC %s",\r\nformat_ie(iif->hcmsg.HLC));\r\ngig_dbg(DEBUG_CMD, "icall: CgPty %s",\r\nformat_ie(iif->hcmsg.CallingPartyNumber));\r\ngig_dbg(DEBUG_CMD, "icall: CdPty %s",\r\nformat_ie(iif->hcmsg.CalledPartyNumber));\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nif (bcs->ap != NULL || bcs->apconnstate != APCONN_NONE) {\r\ndev_warn(cs->dev, "%s: channel not properly cleared (%p/%d)\n",\r\n__func__, bcs->ap, bcs->apconnstate);\r\nbcs->ap = NULL;\r\nbcs->apconnstate = APCONN_NONE;\r\n}\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nactCIPmask = 1 | (1 << iif->hcmsg.CIPValue);\r\nlist_for_each_entry(ap, &iif->appls, ctrlist)\r\nif (actCIPmask & ap->listenCIPmask) {\r\niif->hcmsg.ApplId = ap->id;\r\niif->hcmsg.Messagenumber = ap->nextMessageNumber++;\r\nskb = alloc_skb(msgsize, GFP_ATOMIC);\r\nif (!skb) {\r\ndev_err(cs->dev, "%s: out of memory\n",\r\n__func__);\r\nbreak;\r\n}\r\ncapi_cmsg2message(&iif->hcmsg, __skb_put(skb, msgsize));\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->hcmsg);\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nap->bcnext = bcs->ap;\r\nbcs->ap = ap;\r\nbcs->chstate |= CHS_NOTIFY_LL;\r\nbcs->apconnstate = APCONN_SETUP;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, skb);\r\n}\r\nreturn bcs->ap ? ICALL_ACCEPT : ICALL_IGNORE;\r\n}\r\nstatic void send_disconnect_ind(struct bc_state *bcs,\r\nstruct gigaset_capi_appl *ap, u16 reason)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\nstruct sk_buff *skb;\r\nif (bcs->apconnstate == APCONN_NONE)\r\nreturn;\r\ncapi_cmsg_header(&iif->hcmsg, ap->id, CAPI_DISCONNECT, CAPI_IND,\r\nap->nextMessageNumber++,\r\niif->ctr.cnr | ((bcs->channel + 1) << 8));\r\niif->hcmsg.Reason = reason;\r\nskb = alloc_skb(CAPI_DISCONNECT_IND_LEN, GFP_ATOMIC);\r\nif (!skb) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\ncapi_cmsg2message(&iif->hcmsg, __skb_put(skb, CAPI_DISCONNECT_IND_LEN));\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->hcmsg);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, skb);\r\n}\r\nstatic void send_disconnect_b3_ind(struct bc_state *bcs,\r\nstruct gigaset_capi_appl *ap)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\nstruct sk_buff *skb;\r\nif (bcs->apconnstate < APCONN_ACTIVE)\r\nreturn;\r\nbcs->apconnstate = APCONN_SETUP;\r\ncapi_cmsg_header(&iif->hcmsg, ap->id, CAPI_DISCONNECT_B3, CAPI_IND,\r\nap->nextMessageNumber++,\r\niif->ctr.cnr | ((bcs->channel + 1) << 8) | (1 << 16));\r\nskb = alloc_skb(CAPI_DISCONNECT_B3_IND_BASELEN, GFP_ATOMIC);\r\nif (!skb) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\ncapi_cmsg2message(&iif->hcmsg,\r\n__skb_put(skb, CAPI_DISCONNECT_B3_IND_BASELEN));\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->hcmsg);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, skb);\r\n}\r\nvoid gigaset_isdn_connD(struct bc_state *bcs)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\nstruct gigaset_capi_appl *ap;\r\nstruct sk_buff *skb;\r\nunsigned int msgsize;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nap = bcs->ap;\r\nif (!ap) {\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\ngig_dbg(DEBUG_CMD, "%s: application gone", __func__);\r\nreturn;\r\n}\r\nif (bcs->apconnstate == APCONN_NONE) {\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\ndev_warn(cs->dev, "%s: application %u not connected\n",\r\n__func__, ap->id);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nwhile (ap->bcnext) {\r\ndev_warn(cs->dev, "%s: dropping extra application %u\n",\r\n__func__, ap->bcnext->id);\r\nsend_disconnect_ind(bcs, ap->bcnext,\r\nCapiCallGivenToOtherApplication);\r\nap->bcnext = ap->bcnext->bcnext;\r\n}\r\ncapi_cmsg_header(&iif->hcmsg, ap->id, CAPI_CONNECT_ACTIVE, CAPI_IND,\r\nap->nextMessageNumber++,\r\niif->ctr.cnr | ((bcs->channel + 1) << 8));\r\nmsgsize = CAPI_CONNECT_ACTIVE_IND_BASELEN;\r\nskb = alloc_skb(msgsize, GFP_ATOMIC);\r\nif (!skb) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\ncapi_cmsg2message(&iif->hcmsg, __skb_put(skb, msgsize));\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->hcmsg);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, skb);\r\n}\r\nvoid gigaset_isdn_hupD(struct bc_state *bcs)\r\n{\r\nstruct gigaset_capi_appl *ap;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nwhile (bcs->ap != NULL) {\r\nap = bcs->ap;\r\nbcs->ap = ap->bcnext;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nsend_disconnect_b3_ind(bcs, ap);\r\nsend_disconnect_ind(bcs, ap, 0);\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\n}\r\nbcs->apconnstate = APCONN_NONE;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\n}\r\nvoid gigaset_isdn_connB(struct bc_state *bcs)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\nstruct gigaset_capi_appl *ap;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nunsigned int msgsize;\r\nu8 command;\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nap = bcs->ap;\r\nif (!ap) {\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\ngig_dbg(DEBUG_CMD, "%s: application gone", __func__);\r\nreturn;\r\n}\r\nif (!bcs->apconnstate) {\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\ndev_warn(cs->dev, "%s: application %u not connected\n",\r\n__func__, ap->id);\r\nreturn;\r\n}\r\nif (bcs->apconnstate >= APCONN_ACTIVE) {\r\ncommand = CAPI_CONNECT_B3_ACTIVE;\r\nmsgsize = CAPI_CONNECT_B3_ACTIVE_IND_BASELEN;\r\n} else {\r\ncommand = CAPI_CONNECT_B3;\r\nmsgsize = CAPI_CONNECT_B3_IND_BASELEN;\r\n}\r\nbcs->apconnstate = APCONN_ACTIVE;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nwhile (ap->bcnext) {\r\ndev_warn(cs->dev, "%s: dropping extra application %u\n",\r\n__func__, ap->bcnext->id);\r\nsend_disconnect_ind(bcs, ap->bcnext,\r\nCapiCallGivenToOtherApplication);\r\nap->bcnext = ap->bcnext->bcnext;\r\n}\r\ncapi_cmsg_header(&iif->hcmsg, ap->id, command, CAPI_IND,\r\nap->nextMessageNumber++,\r\niif->ctr.cnr | ((bcs->channel + 1) << 8) | (1 << 16));\r\nskb = alloc_skb(msgsize, GFP_ATOMIC);\r\nif (!skb) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\ncapi_cmsg2message(&iif->hcmsg, __skb_put(skb, msgsize));\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->hcmsg);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, skb);\r\n}\r\nvoid gigaset_isdn_hupB(struct bc_state *bcs)\r\n{\r\nstruct gigaset_capi_appl *ap = bcs->ap;\r\nif (!ap) {\r\ngig_dbg(DEBUG_CMD, "%s: application gone", __func__);\r\nreturn;\r\n}\r\nsend_disconnect_b3_ind(bcs, ap);\r\n}\r\nvoid gigaset_isdn_start(struct cardstate *cs)\r\n{\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\nstrcpy(iif->ctr.manu, "Siemens");\r\niif->ctr.version.majorversion = 2;\r\niif->ctr.version.minorversion = 0;\r\niif->ctr.version.majormanuversion = cs->fwver[0];\r\niif->ctr.version.minormanuversion = cs->fwver[1];\r\niif->ctr.profile.nbchannel = cs->channels;\r\niif->ctr.profile.goptions = 0x11;\r\niif->ctr.profile.support1 = 0x03;\r\niif->ctr.profile.support2 = 0x02;\r\niif->ctr.profile.support3 = 0x01;\r\nstrcpy(iif->ctr.serial, "0");\r\ncapi_ctr_ready(&iif->ctr);\r\n}\r\nvoid gigaset_isdn_stop(struct cardstate *cs)\r\n{\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\ncapi_ctr_down(&iif->ctr);\r\n}\r\nstatic void gigaset_register_appl(struct capi_ctr *ctr, u16 appl,\r\ncapi_register_params *rp)\r\n{\r\nstruct gigaset_capi_ctr *iif\r\n= container_of(ctr, struct gigaset_capi_ctr, ctr);\r\nstruct cardstate *cs = ctr->driverdata;\r\nstruct gigaset_capi_appl *ap;\r\ngig_dbg(DEBUG_CMD, "%s [%u] l3cnt=%u blkcnt=%u blklen=%u",\r\n__func__, appl, rp->level3cnt, rp->datablkcnt, rp->datablklen);\r\nlist_for_each_entry(ap, &iif->appls, ctrlist)\r\nif (ap->id == appl) {\r\ndev_notice(cs->dev,\r\n"application %u already registered\n", appl);\r\nreturn;\r\n}\r\nap = kzalloc(sizeof(*ap), GFP_KERNEL);\r\nif (!ap) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\nap->id = appl;\r\nap->rp = *rp;\r\nlist_add(&ap->ctrlist, &iif->appls);\r\ndev_info(cs->dev, "application %u registered\n", ap->id);\r\n}\r\nstatic inline void remove_appl_from_channel(struct bc_state *bcs,\r\nstruct gigaset_capi_appl *ap)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nstruct gigaset_capi_appl *bcap;\r\nunsigned long flags;\r\nint prevconnstate;\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nbcap = bcs->ap;\r\nif (bcap == NULL) {\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nreturn;\r\n}\r\nif (bcap == ap) {\r\nbcs->ap = ap->bcnext;\r\nif (bcs->ap != NULL) {\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nreturn;\r\n}\r\nprevconnstate = bcs->apconnstate;\r\nbcs->apconnstate = APCONN_NONE;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nif (prevconnstate == APCONN_ACTIVE) {\r\ndev_notice(cs->dev, "%s: hanging up channel %u\n",\r\n__func__, bcs->channel);\r\ngigaset_add_event(cs, &bcs->at_state,\r\nEV_HUP, NULL, 0, NULL);\r\ngigaset_schedule_event(cs);\r\n}\r\nreturn;\r\n}\r\ndo {\r\nif (bcap->bcnext == ap) {\r\nbcap->bcnext = bcap->bcnext->bcnext;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nreturn;\r\n}\r\nbcap = bcap->bcnext;\r\n} while (bcap != NULL);\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\n}\r\nstatic void gigaset_release_appl(struct capi_ctr *ctr, u16 appl)\r\n{\r\nstruct gigaset_capi_ctr *iif\r\n= container_of(ctr, struct gigaset_capi_ctr, ctr);\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\nstruct gigaset_capi_appl *ap, *tmp;\r\nunsigned ch;\r\ngig_dbg(DEBUG_CMD, "%s [%u]", __func__, appl);\r\nlist_for_each_entry_safe(ap, tmp, &iif->appls, ctrlist)\r\nif (ap->id == appl) {\r\nfor (ch = 0; ch < cs->channels; ch++)\r\nremove_appl_from_channel(&cs->bcs[ch], ap);\r\nlist_del(&ap->ctrlist);\r\nkfree(ap);\r\ndev_info(cs->dev, "application %u released\n", appl);\r\n}\r\n}\r\nstatic void send_conf(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb,\r\nu16 info)\r\n{\r\ncapi_cmsg_answer(&iif->acmsg);\r\niif->acmsg.Info = info;\r\ncapi_cmsg2message(&iif->acmsg, skb->data);\r\n__skb_trim(skb, CAPI_STDCONF_LEN);\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->acmsg);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, skb);\r\n}\r\nstatic void do_facility_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\n_cmsg *cmsg = &iif->acmsg;\r\nstruct sk_buff *cskb;\r\nu8 *pparam;\r\nunsigned int msgsize = CAPI_FACILITY_CONF_BASELEN;\r\nu16 function, info;\r\nstatic u8 confparam[10];\r\ncapi_message2cmsg(cmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\nswitch (cmsg->FacilitySelector) {\r\ncase CAPI_FACILITY_DTMF:\r\ninfo = CapiFacilityNotSupported;\r\nconfparam[0] = 2;\r\ncapimsg_setu16(confparam, 1, 2);\r\nbreak;\r\ncase CAPI_FACILITY_V42BIS:\r\ninfo = CapiFacilityNotSupported;\r\nconfparam[0] = 2;\r\ncapimsg_setu16(confparam, 1, 1);\r\nbreak;\r\ncase CAPI_FACILITY_SUPPSVC:\r\npparam = cmsg->FacilityRequestParameter;\r\nif (pparam == NULL || pparam[0] < 2) {\r\ndev_notice(cs->dev, "%s: %s missing\n", "FACILITY_REQ",\r\n"Facility Request Parameter");\r\nsend_conf(iif, ap, skb, CapiIllMessageParmCoding);\r\nreturn;\r\n}\r\nfunction = CAPIMSG_U16(pparam, 1);\r\nswitch (function) {\r\ncase CAPI_SUPPSVC_GETSUPPORTED:\r\ninfo = CapiSuccess;\r\nconfparam[3] = 6;\r\ncapimsg_setu16(confparam, 4, CapiSuccess);\r\ncapimsg_setu32(confparam, 6, 0);\r\nbreak;\r\ncase CAPI_SUPPSVC_LISTEN:\r\nif (pparam[0] < 7 || pparam[3] < 4) {\r\ndev_notice(cs->dev, "%s: %s missing\n",\r\n"FACILITY_REQ", "Notification Mask");\r\nsend_conf(iif, ap, skb,\r\nCapiIllMessageParmCoding);\r\nreturn;\r\n}\r\nif (CAPIMSG_U32(pparam, 4) != 0) {\r\ndev_notice(cs->dev,\r\n"%s: unsupported supplementary service notification mask 0x%x\n",\r\n"FACILITY_REQ", CAPIMSG_U32(pparam, 4));\r\ninfo = CapiFacilitySpecificFunctionNotSupported;\r\nconfparam[3] = 2;\r\ncapimsg_setu16(confparam, 4,\r\nCapiSupplementaryServiceNotSupported);\r\n}\r\ninfo = CapiSuccess;\r\nconfparam[3] = 2;\r\ncapimsg_setu16(confparam, 4, CapiSuccess);\r\nbreak;\r\ndefault:\r\ndev_notice(cs->dev,\r\n"%s: unsupported supplementary service function 0x%04x\n",\r\n"FACILITY_REQ", function);\r\ninfo = CapiFacilitySpecificFunctionNotSupported;\r\nconfparam[3] = 2;\r\ncapimsg_setu16(confparam, 4,\r\nCapiSupplementaryServiceNotSupported);\r\n}\r\nconfparam[0] = confparam[3] + 3;\r\ncapimsg_setu16(confparam, 1, function);\r\nbreak;\r\ncase CAPI_FACILITY_WAKEUP:\r\ninfo = CapiFacilityNotSupported;\r\nconfparam[0] = 2;\r\ncapimsg_setu16(confparam, 1, 0);\r\nbreak;\r\ndefault:\r\ninfo = CapiFacilityNotSupported;\r\nconfparam[0] = 0;\r\n}\r\ncapi_cmsg_answer(cmsg);\r\ncmsg->Info = info;\r\ncmsg->FacilityConfirmationParameter = confparam;\r\nmsgsize += confparam[0];\r\ncskb = alloc_skb(msgsize, GFP_ATOMIC);\r\nif (!cskb) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\ncapi_cmsg2message(cmsg, __skb_put(cskb, msgsize));\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, cskb);\r\n}\r\nstatic void do_listen_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\ncapi_message2cmsg(&iif->acmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->acmsg);\r\nap->listenInfoMask = iif->acmsg.InfoMask;\r\nap->listenCIPmask = iif->acmsg.CIPmask;\r\nsend_conf(iif, ap, skb, CapiSuccess);\r\n}\r\nstatic void do_alert_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\ncapi_message2cmsg(&iif->acmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->acmsg);\r\nsend_conf(iif, ap, skb, CapiAlertAlreadySent);\r\n}\r\nstatic void do_connect_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\n_cmsg *cmsg = &iif->acmsg;\r\nstruct bc_state *bcs;\r\nchar **commands;\r\nchar *s;\r\nu8 *pp;\r\nunsigned long flags;\r\nint i, l, lbc, lhlc;\r\nu16 info;\r\ncapi_message2cmsg(cmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\nbcs = gigaset_get_free_channel(cs);\r\nif (!bcs) {\r\ndev_notice(cs->dev, "%s: no B channel available\n",\r\n"CONNECT_REQ");\r\nsend_conf(iif, ap, skb, CapiNoPlciAvailable);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nif (bcs->ap != NULL || bcs->apconnstate != APCONN_NONE)\r\ndev_warn(cs->dev, "%s: channel not properly cleared (%p/%d)\n",\r\n__func__, bcs->ap, bcs->apconnstate);\r\nap->bcnext = NULL;\r\nbcs->ap = ap;\r\nbcs->apconnstate = APCONN_SETUP;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nbcs->rx_bufsize = ap->rp.datablklen;\r\ndev_kfree_skb(bcs->rx_skb);\r\ngigaset_new_rx_skb(bcs);\r\ncmsg->adr.adrPLCI |= (bcs->channel + 1) << 8;\r\ncommands = kzalloc(AT_NUM*(sizeof *commands), GFP_KERNEL);\r\nif (!commands)\r\ngoto oom;\r\npp = cmsg->CalledPartyNumber;\r\nif (pp == NULL || *pp == 0) {\r\ndev_notice(cs->dev, "%s: %s missing\n",\r\n"CONNECT_REQ", "Called party number");\r\ninfo = CapiIllMessageParmCoding;\r\ngoto error;\r\n}\r\nl = *pp++;\r\nswitch (*pp) {\r\ncase 0x80:\r\ncase 0x81:\r\nbreak;\r\ndefault:\r\ndev_notice(cs->dev, "%s: %s type/plan 0x%02x unsupported\n",\r\n"CONNECT_REQ", "Called party number", *pp);\r\n}\r\npp++;\r\nl--;\r\nif (l >= 2 && pp[0] == '*' && pp[1] == '*') {\r\ns = "^SCTP=0\r";\r\npp += 2;\r\nl -= 2;\r\n} else {\r\ns = "^SCTP=1\r";\r\n}\r\ncommands[AT_TYPE] = kstrdup(s, GFP_KERNEL);\r\nif (!commands[AT_TYPE])\r\ngoto oom;\r\ncommands[AT_DIAL] = kmalloc(l+3, GFP_KERNEL);\r\nif (!commands[AT_DIAL])\r\ngoto oom;\r\nsnprintf(commands[AT_DIAL], l+3, "D%.*s\r", l, pp);\r\npp = cmsg->CallingPartyNumber;\r\nif (pp != NULL && *pp > 0) {\r\nl = *pp++;\r\nswitch (*pp) {\r\ncase 0x00:\r\ncase 0x01:\r\nbreak;\r\ndefault:\r\ndev_notice(cs->dev,\r\n"%s: %s type/plan 0x%02x unsupported\n",\r\n"CONNECT_REQ", "Calling party number", *pp);\r\n}\r\npp++;\r\nl--;\r\nif (!l) {\r\ndev_notice(cs->dev, "%s: %s IE truncated\n",\r\n"CONNECT_REQ", "Calling party number");\r\ninfo = CapiIllMessageParmCoding;\r\ngoto error;\r\n}\r\nswitch (*pp & 0xfc) {\r\ncase 0x80:\r\ns = "^SCLIP=1\r";\r\nbreak;\r\ncase 0xa0:\r\ns = "^SCLIP=0\r";\r\nbreak;\r\ndefault:\r\ndev_notice(cs->dev, "%s: invalid %s 0x%02x\n",\r\n"CONNECT_REQ",\r\n"Presentation/Screening indicator",\r\n*pp);\r\ns = "^SCLIP=1\r";\r\n}\r\ncommands[AT_CLIP] = kstrdup(s, GFP_KERNEL);\r\nif (!commands[AT_CLIP])\r\ngoto oom;\r\npp++;\r\nl--;\r\nif (l) {\r\ncommands[AT_MSN] = kmalloc(l+8, GFP_KERNEL);\r\nif (!commands[AT_MSN])\r\ngoto oom;\r\nsnprintf(commands[AT_MSN], l+8, "^SMSN=%*s\r", l, pp);\r\n}\r\n}\r\nif (cmsg->CIPValue >= ARRAY_SIZE(cip2bchlc) ||\r\n(cmsg->CIPValue > 0 && cip2bchlc[cmsg->CIPValue].bc == NULL)) {\r\ndev_notice(cs->dev, "%s: unknown CIP value %d\n",\r\n"CONNECT_REQ", cmsg->CIPValue);\r\ninfo = CapiCipValueUnknown;\r\ngoto error;\r\n}\r\nif (cmsg->BC && cmsg->BC[0])\r\nlbc = 2*cmsg->BC[0];\r\nelse if (cip2bchlc[cmsg->CIPValue].bc)\r\nlbc = strlen(cip2bchlc[cmsg->CIPValue].bc);\r\nelse\r\nlbc = 0;\r\nif (cmsg->HLC && cmsg->HLC[0])\r\nlhlc = 2*cmsg->HLC[0];\r\nelse if (cip2bchlc[cmsg->CIPValue].hlc)\r\nlhlc = strlen(cip2bchlc[cmsg->CIPValue].hlc);\r\nelse\r\nlhlc = 0;\r\nif (lbc) {\r\nl = lbc + 7;\r\nif (lhlc)\r\nl += lhlc + 7;\r\ncommands[AT_BC] = kmalloc(l, GFP_KERNEL);\r\nif (!commands[AT_BC])\r\ngoto oom;\r\nstrcpy(commands[AT_BC], "^SBC=");\r\nif (cmsg->BC && cmsg->BC[0])\r\ndecode_ie(cmsg->BC, commands[AT_BC] + 5);\r\nelse\r\nstrcpy(commands[AT_BC] + 5,\r\ncip2bchlc[cmsg->CIPValue].bc);\r\nif (lhlc) {\r\nstrcpy(commands[AT_BC] + lbc + 5, ";^SHLC=");\r\nif (cmsg->HLC && cmsg->HLC[0])\r\ndecode_ie(cmsg->HLC,\r\ncommands[AT_BC] + lbc + 12);\r\nelse\r\nstrcpy(commands[AT_BC] + lbc + 12,\r\ncip2bchlc[cmsg->CIPValue].hlc);\r\n}\r\nstrcpy(commands[AT_BC] + l - 2, "\r");\r\n} else {\r\nif (lhlc) {\r\ndev_notice(cs->dev, "%s: cannot set HLC without BC\n",\r\n"CONNECT_REQ");\r\ninfo = CapiIllMessageParmCoding;\r\ngoto error;\r\n}\r\n}\r\nif (cmsg->BProtocol == CAPI_DEFAULT) {\r\nbcs->proto2 = L2_HDLC;\r\ndev_warn(cs->dev,\r\n"B2 Protocol X.75 SLP unsupported, using Transparent\n");\r\n} else {\r\nswitch (cmsg->B1protocol) {\r\ncase 0:\r\nbcs->proto2 = L2_HDLC;\r\nbreak;\r\ncase 1:\r\nbcs->proto2 = L2_VOICE;\r\nbreak;\r\ndefault:\r\ndev_warn(cs->dev,\r\n"B1 Protocol %u unsupported, using Transparent\n",\r\ncmsg->B1protocol);\r\nbcs->proto2 = L2_VOICE;\r\n}\r\nif (cmsg->B2protocol != 1)\r\ndev_warn(cs->dev,\r\n"B2 Protocol %u unsupported, using Transparent\n",\r\ncmsg->B2protocol);\r\nif (cmsg->B3protocol != 0)\r\ndev_warn(cs->dev,\r\n"B3 Protocol %u unsupported, using Transparent\n",\r\ncmsg->B3protocol);\r\nignore_cstruct_param(cs, cmsg->B1configuration,\r\n"CONNECT_REQ", "B1 Configuration");\r\nignore_cstruct_param(cs, cmsg->B2configuration,\r\n"CONNECT_REQ", "B2 Configuration");\r\nignore_cstruct_param(cs, cmsg->B3configuration,\r\n"CONNECT_REQ", "B3 Configuration");\r\n}\r\ncommands[AT_PROTO] = kmalloc(9, GFP_KERNEL);\r\nif (!commands[AT_PROTO])\r\ngoto oom;\r\nsnprintf(commands[AT_PROTO], 9, "^SBPR=%u\r", bcs->proto2);\r\nignore_cstruct_param(cs, cmsg->CalledPartySubaddress,\r\n"CONNECT_REQ", "Called pty subaddr");\r\nignore_cstruct_param(cs, cmsg->CallingPartySubaddress,\r\n"CONNECT_REQ", "Calling pty subaddr");\r\nignore_cstruct_param(cs, cmsg->LLC,\r\n"CONNECT_REQ", "LLC");\r\nif (cmsg->AdditionalInfo != CAPI_DEFAULT) {\r\nignore_cstruct_param(cs, cmsg->BChannelinformation,\r\n"CONNECT_REQ", "B Channel Information");\r\nignore_cstruct_param(cs, cmsg->Keypadfacility,\r\n"CONNECT_REQ", "Keypad Facility");\r\nignore_cstruct_param(cs, cmsg->Useruserdata,\r\n"CONNECT_REQ", "User-User Data");\r\nignore_cstruct_param(cs, cmsg->Facilitydataarray,\r\n"CONNECT_REQ", "Facility Data Array");\r\n}\r\ncommands[AT_ISO] = kmalloc(9, GFP_KERNEL);\r\nif (!commands[AT_ISO])\r\ngoto oom;\r\nsnprintf(commands[AT_ISO], 9, "^SISO=%u\r",\r\n(unsigned) bcs->channel + 1);\r\nif (!gigaset_add_event(cs, &bcs->at_state, EV_DIAL, commands,\r\nbcs->at_state.seq_index, NULL)) {\r\ninfo = CAPI_MSGOSRESOURCEERR;\r\ngoto error;\r\n}\r\ngigaset_schedule_event(cs);\r\nsend_conf(iif, ap, skb, CapiSuccess);\r\nreturn;\r\noom:\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\ninfo = CAPI_MSGOSRESOURCEERR;\r\nerror:\r\nif (commands)\r\nfor (i = 0; i < AT_NUM; i++)\r\nkfree(commands[i]);\r\nkfree(commands);\r\ngigaset_free_channel(bcs);\r\nsend_conf(iif, ap, skb, info);\r\n}\r\nstatic void do_connect_resp(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\n_cmsg *cmsg = &iif->acmsg;\r\nstruct bc_state *bcs;\r\nstruct gigaset_capi_appl *oap;\r\nunsigned long flags;\r\nint channel;\r\ncapi_message2cmsg(cmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\ndev_kfree_skb_any(skb);\r\nchannel = (cmsg->adr.adrPLCI >> 8) & 0xff;\r\nif (!channel || channel > cs->channels) {\r\ndev_notice(cs->dev, "%s: invalid %s 0x%02x\n",\r\n"CONNECT_RESP", "PLCI", cmsg->adr.adrPLCI);\r\nreturn;\r\n}\r\nbcs = cs->bcs + channel - 1;\r\nswitch (cmsg->Reject) {\r\ncase 0:\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nwhile (bcs->ap != NULL) {\r\noap = bcs->ap;\r\nbcs->ap = oap->bcnext;\r\nif (oap != ap) {\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nsend_disconnect_ind(bcs, oap,\r\nCapiCallGivenToOtherApplication);\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\n}\r\n}\r\nap->bcnext = NULL;\r\nbcs->ap = ap;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nbcs->rx_bufsize = ap->rp.datablklen;\r\ndev_kfree_skb(bcs->rx_skb);\r\ngigaset_new_rx_skb(bcs);\r\nbcs->chstate |= CHS_NOTIFY_LL;\r\nif (cmsg->BProtocol == CAPI_DEFAULT) {\r\nbcs->proto2 = L2_HDLC;\r\ndev_warn(cs->dev,\r\n"B2 Protocol X.75 SLP unsupported, using Transparent\n");\r\n} else {\r\nswitch (cmsg->B1protocol) {\r\ncase 0:\r\nbcs->proto2 = L2_HDLC;\r\nbreak;\r\ncase 1:\r\nbcs->proto2 = L2_VOICE;\r\nbreak;\r\ndefault:\r\ndev_warn(cs->dev,\r\n"B1 Protocol %u unsupported, using Transparent\n",\r\ncmsg->B1protocol);\r\nbcs->proto2 = L2_VOICE;\r\n}\r\nif (cmsg->B2protocol != 1)\r\ndev_warn(cs->dev,\r\n"B2 Protocol %u unsupported, using Transparent\n",\r\ncmsg->B2protocol);\r\nif (cmsg->B3protocol != 0)\r\ndev_warn(cs->dev,\r\n"B3 Protocol %u unsupported, using Transparent\n",\r\ncmsg->B3protocol);\r\nignore_cstruct_param(cs, cmsg->B1configuration,\r\n"CONNECT_RESP", "B1 Configuration");\r\nignore_cstruct_param(cs, cmsg->B2configuration,\r\n"CONNECT_RESP", "B2 Configuration");\r\nignore_cstruct_param(cs, cmsg->B3configuration,\r\n"CONNECT_RESP", "B3 Configuration");\r\n}\r\nignore_cstruct_param(cs, cmsg->ConnectedNumber,\r\n"CONNECT_RESP", "Connected Number");\r\nignore_cstruct_param(cs, cmsg->ConnectedSubaddress,\r\n"CONNECT_RESP", "Connected Subaddress");\r\nignore_cstruct_param(cs, cmsg->LLC,\r\n"CONNECT_RESP", "LLC");\r\nif (cmsg->AdditionalInfo != CAPI_DEFAULT) {\r\nignore_cstruct_param(cs, cmsg->BChannelinformation,\r\n"CONNECT_RESP", "BChannel Information");\r\nignore_cstruct_param(cs, cmsg->Keypadfacility,\r\n"CONNECT_RESP", "Keypad Facility");\r\nignore_cstruct_param(cs, cmsg->Useruserdata,\r\n"CONNECT_RESP", "User-User Data");\r\nignore_cstruct_param(cs, cmsg->Facilitydataarray,\r\n"CONNECT_RESP", "Facility Data Array");\r\n}\r\nif (!gigaset_add_event(cs, &cs->bcs[channel-1].at_state,\r\nEV_ACCEPT, NULL, 0, NULL))\r\nreturn;\r\ngigaset_schedule_event(cs);\r\nreturn;\r\ncase 1:\r\nsend_disconnect_ind(bcs, ap, 0);\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nif (bcs->ap == ap) {\r\nbcs->ap = ap->bcnext;\r\nif (bcs->ap == NULL) {\r\nbcs->apconnstate = APCONN_NONE;\r\nbcs->chstate &= ~CHS_NOTIFY_LL;\r\n}\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nreturn;\r\n}\r\nfor (oap = bcs->ap; oap != NULL; oap = oap->bcnext) {\r\nif (oap->bcnext == ap) {\r\noap->bcnext = oap->bcnext->bcnext;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nreturn;\r\n}\r\n}\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\ndev_err(cs->dev, "%s: application %u not found\n",\r\n__func__, ap->id);\r\nreturn;\r\ndefault:\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\nwhile (bcs->ap != NULL) {\r\noap = bcs->ap;\r\nbcs->ap = oap->bcnext;\r\nif (oap != ap) {\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\nsend_disconnect_ind(bcs, oap,\r\nCapiCallGivenToOtherApplication);\r\nspin_lock_irqsave(&bcs->aplock, flags);\r\n}\r\n}\r\nap->bcnext = NULL;\r\nbcs->ap = ap;\r\nspin_unlock_irqrestore(&bcs->aplock, flags);\r\ndev_info(cs->dev, "%s: Reject=%x\n",\r\n"CONNECT_RESP", cmsg->Reject);\r\nif (!gigaset_add_event(cs, &cs->bcs[channel-1].at_state,\r\nEV_HUP, NULL, 0, NULL))\r\nreturn;\r\ngigaset_schedule_event(cs);\r\nreturn;\r\n}\r\n}\r\nstatic void do_connect_b3_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\n_cmsg *cmsg = &iif->acmsg;\r\nstruct bc_state *bcs;\r\nint channel;\r\ncapi_message2cmsg(cmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\nchannel = (cmsg->adr.adrPLCI >> 8) & 0xff;\r\nif (!channel || channel > cs->channels) {\r\ndev_notice(cs->dev, "%s: invalid %s 0x%02x\n",\r\n"CONNECT_B3_REQ", "PLCI", cmsg->adr.adrPLCI);\r\nsend_conf(iif, ap, skb, CapiIllContrPlciNcci);\r\nreturn;\r\n}\r\nbcs = &cs->bcs[channel-1];\r\nbcs->apconnstate = APCONN_ACTIVE;\r\ncmsg->adr.adrNCCI |= 1 << 16;\r\nignore_cstruct_param(cs, cmsg->NCPI, "CONNECT_B3_REQ", "NCPI");\r\nsend_conf(iif, ap, skb, (cmsg->NCPI && cmsg->NCPI[0]) ?\r\nCapiNcpiNotSupportedByProtocol : CapiSuccess);\r\n}\r\nstatic void do_connect_b3_resp(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\n_cmsg *cmsg = &iif->acmsg;\r\nstruct bc_state *bcs;\r\nint channel;\r\nunsigned int msgsize;\r\nu8 command;\r\ncapi_message2cmsg(cmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\nchannel = (cmsg->adr.adrNCCI >> 8) & 0xff;\r\nif (!channel || channel > cs->channels ||\r\n((cmsg->adr.adrNCCI >> 16) & 0xffff) != 1) {\r\ndev_notice(cs->dev, "%s: invalid %s 0x%02x\n",\r\n"CONNECT_B3_RESP", "NCCI", cmsg->adr.adrNCCI);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nbcs = &cs->bcs[channel-1];\r\nif (cmsg->Reject) {\r\nbcs->apconnstate = APCONN_SETUP;\r\nif (!gigaset_add_event(cs, &bcs->at_state,\r\nEV_HUP, NULL, 0, NULL)) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\ngigaset_schedule_event(cs);\r\ncommand = CAPI_DISCONNECT_B3;\r\nmsgsize = CAPI_DISCONNECT_B3_IND_BASELEN;\r\n} else {\r\ncommand = CAPI_CONNECT_B3_ACTIVE;\r\nmsgsize = CAPI_CONNECT_B3_ACTIVE_IND_BASELEN;\r\n}\r\ncapi_cmsg_header(cmsg, ap->id, command, CAPI_IND,\r\nap->nextMessageNumber++, cmsg->adr.adrNCCI);\r\n__skb_trim(skb, msgsize);\r\ncapi_cmsg2message(cmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, skb);\r\n}\r\nstatic void do_disconnect_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\n_cmsg *cmsg = &iif->acmsg;\r\nstruct bc_state *bcs;\r\n_cmsg *b3cmsg;\r\nstruct sk_buff *b3skb;\r\nint channel;\r\ncapi_message2cmsg(cmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\nchannel = (cmsg->adr.adrPLCI >> 8) & 0xff;\r\nif (!channel || channel > cs->channels) {\r\ndev_notice(cs->dev, "%s: invalid %s 0x%02x\n",\r\n"DISCONNECT_REQ", "PLCI", cmsg->adr.adrPLCI);\r\nsend_conf(iif, ap, skb, CapiIllContrPlciNcci);\r\nreturn;\r\n}\r\nbcs = cs->bcs + channel - 1;\r\nif (cmsg->AdditionalInfo != CAPI_DEFAULT) {\r\nignore_cstruct_param(cs, cmsg->BChannelinformation,\r\n"DISCONNECT_REQ", "B Channel Information");\r\nignore_cstruct_param(cs, cmsg->Keypadfacility,\r\n"DISCONNECT_REQ", "Keypad Facility");\r\nignore_cstruct_param(cs, cmsg->Useruserdata,\r\n"DISCONNECT_REQ", "User-User Data");\r\nignore_cstruct_param(cs, cmsg->Facilitydataarray,\r\n"DISCONNECT_REQ", "Facility Data Array");\r\n}\r\nif (!bcs->apconnstate)\r\nreturn;\r\nif (bcs->apconnstate >= APCONN_ACTIVE) {\r\nb3cmsg = kmalloc(sizeof(*b3cmsg), GFP_KERNEL);\r\nif (!b3cmsg) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nsend_conf(iif, ap, skb, CAPI_MSGOSRESOURCEERR);\r\nreturn;\r\n}\r\ncapi_cmsg_header(b3cmsg, ap->id, CAPI_DISCONNECT_B3, CAPI_IND,\r\nap->nextMessageNumber++,\r\ncmsg->adr.adrPLCI | (1 << 16));\r\nb3cmsg->Reason_B3 = CapiProtocolErrorLayer1;\r\nb3skb = alloc_skb(CAPI_DISCONNECT_B3_IND_BASELEN, GFP_KERNEL);\r\nif (b3skb == NULL) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nsend_conf(iif, ap, skb, CAPI_MSGOSRESOURCEERR);\r\nkfree(b3cmsg);\r\nreturn;\r\n}\r\ncapi_cmsg2message(b3cmsg,\r\n__skb_put(b3skb, CAPI_DISCONNECT_B3_IND_BASELEN));\r\nkfree(b3cmsg);\r\ncapi_ctr_handle_message(&iif->ctr, ap->id, b3skb);\r\n}\r\nif (!gigaset_add_event(cs, &bcs->at_state, EV_HUP, NULL, 0, NULL)) {\r\nsend_conf(iif, ap, skb, CAPI_MSGOSRESOURCEERR);\r\nreturn;\r\n}\r\ngigaset_schedule_event(cs);\r\nsend_conf(iif, ap, skb, CapiSuccess);\r\n}\r\nstatic void do_disconnect_b3_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\n_cmsg *cmsg = &iif->acmsg;\r\nstruct bc_state *bcs;\r\nint channel;\r\ncapi_message2cmsg(cmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, cmsg);\r\nchannel = (cmsg->adr.adrNCCI >> 8) & 0xff;\r\nif (!channel || channel > cs->channels ||\r\n((cmsg->adr.adrNCCI >> 16) & 0xffff) != 1) {\r\ndev_notice(cs->dev, "%s: invalid %s 0x%02x\n",\r\n"DISCONNECT_B3_REQ", "NCCI", cmsg->adr.adrNCCI);\r\nsend_conf(iif, ap, skb, CapiIllContrPlciNcci);\r\nreturn;\r\n}\r\nbcs = &cs->bcs[channel-1];\r\nif (bcs->apconnstate < APCONN_ACTIVE) {\r\nsend_conf(iif, ap, skb,\r\nCapiMessageNotSupportedInCurrentState);\r\nreturn;\r\n}\r\nif (!gigaset_add_event(cs, &bcs->at_state, EV_HUP, NULL, 0, NULL)) {\r\nsend_conf(iif, ap, skb, CAPI_MSGOSRESOURCEERR);\r\nreturn;\r\n}\r\ngigaset_schedule_event(cs);\r\nignore_cstruct_param(cs, cmsg->NCPI,\r\n"DISCONNECT_B3_REQ", "NCPI");\r\nsend_conf(iif, ap, skb, (cmsg->NCPI && cmsg->NCPI[0]) ?\r\nCapiNcpiNotSupportedByProtocol : CapiSuccess);\r\n}\r\nstatic void do_data_b3_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = iif->ctr.driverdata;\r\nstruct bc_state *bcs;\r\nint channel = CAPIMSG_PLCI_PART(skb->data);\r\nu16 ncci = CAPIMSG_NCCI_PART(skb->data);\r\nu16 msglen = CAPIMSG_LEN(skb->data);\r\nu16 datalen = CAPIMSG_DATALEN(skb->data);\r\nu16 flags = CAPIMSG_FLAGS(skb->data);\r\nu16 msgid = CAPIMSG_MSGID(skb->data);\r\nu16 handle = CAPIMSG_HANDLE_REQ(skb->data);\r\ndump_rawmsg(DEBUG_MCMD, __func__, skb->data);\r\nif (channel == 0 || channel > cs->channels || ncci != 1) {\r\ndev_notice(cs->dev, "%s: invalid %s 0x%02x\n",\r\n"DATA_B3_REQ", "NCCI", CAPIMSG_NCCI(skb->data));\r\nsend_conf(iif, ap, skb, CapiIllContrPlciNcci);\r\nreturn;\r\n}\r\nbcs = &cs->bcs[channel-1];\r\nif (msglen != CAPI_DATA_B3_REQ_LEN && msglen != CAPI_DATA_B3_REQ_LEN64)\r\ndev_notice(cs->dev, "%s: unexpected length %d\n",\r\n"DATA_B3_REQ", msglen);\r\nif (msglen + datalen != skb->len)\r\ndev_notice(cs->dev, "%s: length mismatch (%d+%d!=%d)\n",\r\n"DATA_B3_REQ", msglen, datalen, skb->len);\r\nif (msglen + datalen > skb->len) {\r\nsend_conf(iif, ap, skb, CapiIllMessageParmCoding);\r\nreturn;\r\n}\r\nif (flags & CAPI_FLAGS_RESERVED) {\r\ndev_notice(cs->dev, "%s: reserved flags set (%x)\n",\r\n"DATA_B3_REQ", flags);\r\nsend_conf(iif, ap, skb, CapiIllMessageParmCoding);\r\nreturn;\r\n}\r\nif (bcs->apconnstate < APCONN_ACTIVE) {\r\nsend_conf(iif, ap, skb, CapiMessageNotSupportedInCurrentState);\r\nreturn;\r\n}\r\nskb_reset_mac_header(skb);\r\nskb->mac_len = msglen;\r\nskb_pull(skb, msglen);\r\nif (cs->ops->send_skb(bcs, skb) < 0) {\r\nsend_conf(iif, ap, skb, CAPI_MSGOSRESOURCEERR);\r\nreturn;\r\n}\r\nif (!(flags & CAPI_FLAGS_DELIVERY_CONFIRMATION))\r\nsend_data_b3_conf(cs, &iif->ctr, ap->id, msgid, channel, handle,\r\nflags ? CapiFlagsNotSupportedByProtocol\r\n: CAPI_NOERROR);\r\n}\r\nstatic void do_reset_b3_req(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\ncapi_message2cmsg(&iif->acmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->acmsg);\r\nsend_conf(iif, ap, skb,\r\nCapiResetProcedureNotSupportedByCurrentProtocol);\r\n}\r\nstatic void do_unsupported(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\ncapi_message2cmsg(&iif->acmsg, skb->data);\r\nif (printk_timed_ratelimit(&ignored_msg_dump_time, 30 * 1000))\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->acmsg);\r\nsend_conf(iif, ap, skb, CapiMessageNotSupportedInCurrentState);\r\n}\r\nstatic void do_nothing(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\nif (printk_timed_ratelimit(&ignored_msg_dump_time, 30 * 1000)) {\r\ncapi_message2cmsg(&iif->acmsg, skb->data);\r\ndump_cmsg(DEBUG_CMD, __func__, &iif->acmsg);\r\n}\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void do_data_b3_resp(struct gigaset_capi_ctr *iif,\r\nstruct gigaset_capi_appl *ap,\r\nstruct sk_buff *skb)\r\n{\r\ndump_rawmsg(DEBUG_MCMD, __func__, skb->data);\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic inline capi_send_handler_t lookup_capi_send_handler(const u16 cmd)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < ARRAY_SIZE(capi_send_handler_table); i++)\r\nif (capi_send_handler_table[i].cmd == cmd)\r\nreturn capi_send_handler_table[i].handler;\r\nreturn NULL;\r\n}\r\nstatic u16 gigaset_send_message(struct capi_ctr *ctr, struct sk_buff *skb)\r\n{\r\nstruct gigaset_capi_ctr *iif\r\n= container_of(ctr, struct gigaset_capi_ctr, ctr);\r\nstruct cardstate *cs = ctr->driverdata;\r\nstruct gigaset_capi_appl *ap;\r\ncapi_send_handler_t handler;\r\nif (skb_linearize(skb) < 0) {\r\ndev_warn(cs->dev, "%s: skb_linearize failed\n", __func__);\r\nreturn CAPI_MSGOSRESOURCEERR;\r\n}\r\nap = get_appl(iif, CAPIMSG_APPID(skb->data));\r\nif (!ap) {\r\ndev_notice(cs->dev, "%s: application %u not registered\n",\r\n__func__, CAPIMSG_APPID(skb->data));\r\nreturn CAPI_ILLAPPNR;\r\n}\r\nhandler = lookup_capi_send_handler(CAPIMSG_CMD(skb->data));\r\nif (!handler) {\r\nif (printk_ratelimit())\r\ndev_notice(cs->dev, "%s: unsupported message %u\n",\r\n__func__, CAPIMSG_CMD(skb->data));\r\nreturn CAPI_ILLCMDORSUBCMDORMSGTOSMALL;\r\n}\r\nif (atomic_add_return(1, &iif->sendqlen) > 1) {\r\nskb_queue_tail(&iif->sendqueue, skb);\r\nreturn CAPI_NOERROR;\r\n}\r\nhandler(iif, ap, skb);\r\nwhile (atomic_sub_return(1, &iif->sendqlen) > 0) {\r\nskb = skb_dequeue(&iif->sendqueue);\r\nif (!skb) {\r\ndev_err(cs->dev, "%s: send queue empty\n", __func__);\r\ncontinue;\r\n}\r\nap = get_appl(iif, CAPIMSG_APPID(skb->data));\r\nif (!ap) {\r\ndev_warn(cs->dev, "%s: application %u vanished\n",\r\n__func__, CAPIMSG_APPID(skb->data));\r\ncontinue;\r\n}\r\nhandler = lookup_capi_send_handler(CAPIMSG_CMD(skb->data));\r\nif (!handler) {\r\ndev_err(cs->dev, "%s: handler %x vanished\n",\r\n__func__, CAPIMSG_CMD(skb->data));\r\ncontinue;\r\n}\r\nhandler(iif, ap, skb);\r\n}\r\nreturn CAPI_NOERROR;\r\n}\r\nstatic char *gigaset_procinfo(struct capi_ctr *ctr)\r\n{\r\nreturn ctr->name;\r\n}\r\nstatic int gigaset_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct capi_ctr *ctr = m->private;\r\nstruct cardstate *cs = ctr->driverdata;\r\nchar *s;\r\nint i;\r\nseq_printf(m, "%-16s %s\n", "name", ctr->name);\r\nseq_printf(m, "%-16s %s %s\n", "dev",\r\ndev_driver_string(cs->dev), dev_name(cs->dev));\r\nseq_printf(m, "%-16s %d\n", "id", cs->myid);\r\nif (cs->gotfwver)\r\nseq_printf(m, "%-16s %d.%d.%d.%d\n", "firmware",\r\ncs->fwver[0], cs->fwver[1], cs->fwver[2], cs->fwver[3]);\r\nseq_printf(m, "%-16s %d\n", "channels", cs->channels);\r\nseq_printf(m, "%-16s %s\n", "onechannel", cs->onechannel ? "yes" : "no");\r\nswitch (cs->mode) {\r\ncase M_UNKNOWN:\r\ns = "unknown";\r\nbreak;\r\ncase M_CONFIG:\r\ns = "config";\r\nbreak;\r\ncase M_UNIMODEM:\r\ns = "Unimodem";\r\nbreak;\r\ncase M_CID:\r\ns = "CID";\r\nbreak;\r\ndefault:\r\ns = "??";\r\n}\r\nseq_printf(m, "%-16s %s\n", "mode", s);\r\nswitch (cs->mstate) {\r\ncase MS_UNINITIALIZED:\r\ns = "uninitialized";\r\nbreak;\r\ncase MS_INIT:\r\ns = "init";\r\nbreak;\r\ncase MS_LOCKED:\r\ns = "locked";\r\nbreak;\r\ncase MS_SHUTDOWN:\r\ns = "shutdown";\r\nbreak;\r\ncase MS_RECOVER:\r\ns = "recover";\r\nbreak;\r\ncase MS_READY:\r\ns = "ready";\r\nbreak;\r\ndefault:\r\ns = "??";\r\n}\r\nseq_printf(m, "%-16s %s\n", "mstate", s);\r\nseq_printf(m, "%-16s %s\n", "running", cs->running ? "yes" : "no");\r\nseq_printf(m, "%-16s %s\n", "connected", cs->connected ? "yes" : "no");\r\nseq_printf(m, "%-16s %s\n", "isdn_up", cs->isdn_up ? "yes" : "no");\r\nseq_printf(m, "%-16s %s\n", "cidmode", cs->cidmode ? "yes" : "no");\r\nfor (i = 0; i < cs->channels; i++) {\r\nseq_printf(m, "[%d]%-13s %d\n", i, "corrupted",\r\ncs->bcs[i].corrupted);\r\nseq_printf(m, "[%d]%-13s %d\n", i, "trans_down",\r\ncs->bcs[i].trans_down);\r\nseq_printf(m, "[%d]%-13s %d\n", i, "trans_up",\r\ncs->bcs[i].trans_up);\r\nseq_printf(m, "[%d]%-13s %d\n", i, "chstate",\r\ncs->bcs[i].chstate);\r\nswitch (cs->bcs[i].proto2) {\r\ncase L2_BITSYNC:\r\ns = "bitsync";\r\nbreak;\r\ncase L2_HDLC:\r\ns = "HDLC";\r\nbreak;\r\ncase L2_VOICE:\r\ns = "voice";\r\nbreak;\r\ndefault:\r\ns = "??";\r\n}\r\nseq_printf(m, "[%d]%-13s %s\n", i, "proto2", s);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gigaset_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, gigaset_proc_show, PDE(inode)->data);\r\n}\r\nint gigaset_isdn_regdev(struct cardstate *cs, const char *isdnid)\r\n{\r\nstruct gigaset_capi_ctr *iif;\r\nint rc;\r\niif = kmalloc(sizeof(*iif), GFP_KERNEL);\r\nif (!iif) {\r\npr_err("%s: out of memory\n", __func__);\r\nreturn 0;\r\n}\r\niif->ctr.owner = THIS_MODULE;\r\niif->ctr.driverdata = cs;\r\nstrncpy(iif->ctr.name, isdnid, sizeof(iif->ctr.name));\r\niif->ctr.driver_name = "gigaset";\r\niif->ctr.load_firmware = NULL;\r\niif->ctr.reset_ctr = NULL;\r\niif->ctr.register_appl = gigaset_register_appl;\r\niif->ctr.release_appl = gigaset_release_appl;\r\niif->ctr.send_message = gigaset_send_message;\r\niif->ctr.procinfo = gigaset_procinfo;\r\niif->ctr.proc_fops = &gigaset_proc_fops;\r\nINIT_LIST_HEAD(&iif->appls);\r\nskb_queue_head_init(&iif->sendqueue);\r\natomic_set(&iif->sendqlen, 0);\r\nrc = attach_capi_ctr(&iif->ctr);\r\nif (rc) {\r\npr_err("attach_capi_ctr failed (%d)\n", rc);\r\nkfree(iif);\r\nreturn 0;\r\n}\r\ncs->iif = iif;\r\ncs->hw_hdr_len = CAPI_DATA_B3_REQ_LEN;\r\nreturn 1;\r\n}\r\nvoid gigaset_isdn_unregdev(struct cardstate *cs)\r\n{\r\nstruct gigaset_capi_ctr *iif = cs->iif;\r\ndetach_capi_ctr(&iif->ctr);\r\nkfree(iif);\r\ncs->iif = NULL;\r\n}\r\nvoid gigaset_isdn_regdrv(void)\r\n{\r\npr_info("Kernel CAPI interface\n");\r\nregister_capi_driver(&capi_driver_gigaset);\r\n}\r\nvoid gigaset_isdn_unregdrv(void)\r\n{\r\nunregister_capi_driver(&capi_driver_gigaset);\r\n}
