static inline int hub_is_superspeed(struct usb_device *hdev)\r\n{\r\nreturn (hdev->descriptor.bDeviceProtocol == 3);\r\n}\r\nstatic inline char *portspeed(struct usb_hub *hub, int portstatus)\r\n{\r\nif (hub_is_superspeed(hub->hdev))\r\nreturn "5.0 Gb/s";\r\nif (portstatus & USB_PORT_STAT_HIGH_SPEED)\r\nreturn "480 Mb/s";\r\nelse if (portstatus & USB_PORT_STAT_LOW_SPEED)\r\nreturn "1.5 Mb/s";\r\nelse\r\nreturn "12 Mb/s";\r\n}\r\nstatic struct usb_hub *hdev_to_hub(struct usb_device *hdev)\r\n{\r\nif (!hdev || !hdev->actconfig)\r\nreturn NULL;\r\nreturn usb_get_intfdata(hdev->actconfig->interface[0]);\r\n}\r\nstatic int get_hub_descriptor(struct usb_device *hdev, void *data)\r\n{\r\nint i, ret, size;\r\nunsigned dtype;\r\nif (hub_is_superspeed(hdev)) {\r\ndtype = USB_DT_SS_HUB;\r\nsize = USB_DT_SS_HUB_SIZE;\r\n} else {\r\ndtype = USB_DT_HUB;\r\nsize = sizeof(struct usb_hub_descriptor);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nret = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\r\nUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,\r\ndtype << 8, 0, data, size,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (ret >= (USB_DT_HUB_NONVAR_SIZE + 2))\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clear_hub_feature(struct usb_device *hdev, int feature)\r\n{\r\nreturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\r\nUSB_REQ_CLEAR_FEATURE, USB_RT_HUB, feature, 0, NULL, 0, 1000);\r\n}\r\nstatic int clear_port_feature(struct usb_device *hdev, int port1, int feature)\r\n{\r\nreturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\r\nUSB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port1,\r\nNULL, 0, 1000);\r\n}\r\nstatic int set_port_feature(struct usb_device *hdev, int port1, int feature)\r\n{\r\nreturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\r\nUSB_REQ_SET_FEATURE, USB_RT_PORT, feature, port1,\r\nNULL, 0, 1000);\r\n}\r\nstatic void set_port_led(\r\nstruct usb_hub *hub,\r\nint port1,\r\nint selector\r\n)\r\n{\r\nint status = set_port_feature(hub->hdev, (selector << 8) | port1,\r\nUSB_PORT_FEAT_INDICATOR);\r\nif (status < 0)\r\ndev_dbg (hub->intfdev,\r\n"port %d indicator %s status %d\n",\r\nport1,\r\n({ char *s; switch (selector) {\r\ncase HUB_LED_AMBER: s = "amber"; break;\r\ncase HUB_LED_GREEN: s = "green"; break;\r\ncase HUB_LED_OFF: s = "off"; break;\r\ncase HUB_LED_AUTO: s = "auto"; break;\r\ndefault: s = "??"; break;\r\n}; s; }),\r\nstatus);\r\n}\r\nstatic void led_work (struct work_struct *work)\r\n{\r\nstruct usb_hub *hub =\r\ncontainer_of(work, struct usb_hub, leds.work);\r\nstruct usb_device *hdev = hub->hdev;\r\nunsigned i;\r\nunsigned changed = 0;\r\nint cursor = -1;\r\nif (hdev->state != USB_STATE_CONFIGURED || hub->quiescing)\r\nreturn;\r\nfor (i = 0; i < hub->descriptor->bNbrPorts; i++) {\r\nunsigned selector, mode;\r\nswitch (hub->indicator[i]) {\r\ncase INDICATOR_CYCLE:\r\ncursor = i;\r\nselector = HUB_LED_AUTO;\r\nmode = INDICATOR_AUTO;\r\nbreak;\r\ncase INDICATOR_GREEN_BLINK:\r\nselector = HUB_LED_GREEN;\r\nmode = INDICATOR_GREEN_BLINK_OFF;\r\nbreak;\r\ncase INDICATOR_GREEN_BLINK_OFF:\r\nselector = HUB_LED_OFF;\r\nmode = INDICATOR_GREEN_BLINK;\r\nbreak;\r\ncase INDICATOR_AMBER_BLINK:\r\nselector = HUB_LED_AMBER;\r\nmode = INDICATOR_AMBER_BLINK_OFF;\r\nbreak;\r\ncase INDICATOR_AMBER_BLINK_OFF:\r\nselector = HUB_LED_OFF;\r\nmode = INDICATOR_AMBER_BLINK;\r\nbreak;\r\ncase INDICATOR_ALT_BLINK:\r\nselector = HUB_LED_GREEN;\r\nmode = INDICATOR_ALT_BLINK_OFF;\r\nbreak;\r\ncase INDICATOR_ALT_BLINK_OFF:\r\nselector = HUB_LED_AMBER;\r\nmode = INDICATOR_ALT_BLINK;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (selector != HUB_LED_AUTO)\r\nchanged = 1;\r\nset_port_led(hub, i + 1, selector);\r\nhub->indicator[i] = mode;\r\n}\r\nif (!changed && blinkenlights) {\r\ncursor++;\r\ncursor %= hub->descriptor->bNbrPorts;\r\nset_port_led(hub, cursor + 1, HUB_LED_GREEN);\r\nhub->indicator[cursor] = INDICATOR_CYCLE;\r\nchanged++;\r\n}\r\nif (changed)\r\nschedule_delayed_work(&hub->leds, LED_CYCLE_PERIOD);\r\n}\r\nstatic int get_hub_status(struct usb_device *hdev,\r\nstruct usb_hub_status *data)\r\n{\r\nint i, status = -ETIMEDOUT;\r\nfor (i = 0; i < USB_STS_RETRIES &&\r\n(status == -ETIMEDOUT || status == -EPIPE); i++) {\r\nstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\r\nUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_HUB, 0, 0,\r\ndata, sizeof(*data), USB_STS_TIMEOUT);\r\n}\r\nreturn status;\r\n}\r\nstatic int get_port_status(struct usb_device *hdev, int port1,\r\nstruct usb_port_status *data)\r\n{\r\nint i, status = -ETIMEDOUT;\r\nfor (i = 0; i < USB_STS_RETRIES &&\r\n(status == -ETIMEDOUT || status == -EPIPE); i++) {\r\nstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\r\nUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, port1,\r\ndata, sizeof(*data), USB_STS_TIMEOUT);\r\n}\r\nreturn status;\r\n}\r\nstatic int hub_port_status(struct usb_hub *hub, int port1,\r\nu16 *status, u16 *change)\r\n{\r\nint ret;\r\nmutex_lock(&hub->status_mutex);\r\nret = get_port_status(hub->hdev, port1, &hub->status->port);\r\nif (ret < 4) {\r\ndev_err(hub->intfdev,\r\n"%s failed (err = %d)\n", __func__, ret);\r\nif (ret >= 0)\r\nret = -EIO;\r\n} else {\r\n*status = le16_to_cpu(hub->status->port.wPortStatus);\r\n*change = le16_to_cpu(hub->status->port.wPortChange);\r\nret = 0;\r\n}\r\nmutex_unlock(&hub->status_mutex);\r\nreturn ret;\r\n}\r\nstatic void kick_khubd(struct usb_hub *hub)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hub_event_lock, flags);\r\nif (!hub->disconnected && list_empty(&hub->event_list)) {\r\nlist_add_tail(&hub->event_list, &hub_event_list);\r\nusb_autopm_get_interface_no_resume(\r\nto_usb_interface(hub->intfdev));\r\nwake_up(&khubd_wait);\r\n}\r\nspin_unlock_irqrestore(&hub_event_lock, flags);\r\n}\r\nvoid usb_kick_khubd(struct usb_device *hdev)\r\n{\r\nstruct usb_hub *hub = hdev_to_hub(hdev);\r\nif (hub)\r\nkick_khubd(hub);\r\n}\r\nstatic void hub_irq(struct urb *urb)\r\n{\r\nstruct usb_hub *hub = urb->context;\r\nint status = urb->status;\r\nunsigned i;\r\nunsigned long bits;\r\nswitch (status) {\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_dbg (hub->intfdev, "transfer --> %d\n", status);\r\nif ((++hub->nerrors < 10) || hub->error)\r\ngoto resubmit;\r\nhub->error = status;\r\ncase 0:\r\nbits = 0;\r\nfor (i = 0; i < urb->actual_length; ++i)\r\nbits |= ((unsigned long) ((*hub->buffer)[i]))\r\n<< (i*8);\r\nhub->event_bits[0] = bits;\r\nbreak;\r\n}\r\nhub->nerrors = 0;\r\nkick_khubd(hub);\r\nresubmit:\r\nif (hub->quiescing)\r\nreturn;\r\nif ((status = usb_submit_urb (hub->urb, GFP_ATOMIC)) != 0\r\n&& status != -ENODEV && status != -EPERM)\r\ndev_err (hub->intfdev, "resubmit --> %d\n", status);\r\n}\r\nstatic inline int\r\nhub_clear_tt_buffer (struct usb_device *hdev, u16 devinfo, u16 tt)\r\n{\r\nreturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\r\nHUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,\r\ntt, NULL, 0, 1000);\r\n}\r\nstatic void hub_tt_work(struct work_struct *work)\r\n{\r\nstruct usb_hub *hub =\r\ncontainer_of(work, struct usb_hub, tt.clear_work);\r\nunsigned long flags;\r\nint limit = 100;\r\nspin_lock_irqsave (&hub->tt.lock, flags);\r\nwhile (--limit && !list_empty (&hub->tt.clear_list)) {\r\nstruct list_head *next;\r\nstruct usb_tt_clear *clear;\r\nstruct usb_device *hdev = hub->hdev;\r\nconst struct hc_driver *drv;\r\nint status;\r\nnext = hub->tt.clear_list.next;\r\nclear = list_entry (next, struct usb_tt_clear, clear_list);\r\nlist_del (&clear->clear_list);\r\nspin_unlock_irqrestore (&hub->tt.lock, flags);\r\nstatus = hub_clear_tt_buffer (hdev, clear->devinfo, clear->tt);\r\nif (status)\r\ndev_err (&hdev->dev,\r\n"clear tt %d (%04x) error %d\n",\r\nclear->tt, clear->devinfo, status);\r\ndrv = clear->hcd->driver;\r\nif (drv->clear_tt_buffer_complete)\r\n(drv->clear_tt_buffer_complete)(clear->hcd, clear->ep);\r\nkfree(clear);\r\nspin_lock_irqsave(&hub->tt.lock, flags);\r\n}\r\nspin_unlock_irqrestore (&hub->tt.lock, flags);\r\n}\r\nint usb_hub_clear_tt_buffer(struct urb *urb)\r\n{\r\nstruct usb_device *udev = urb->dev;\r\nint pipe = urb->pipe;\r\nstruct usb_tt *tt = udev->tt;\r\nunsigned long flags;\r\nstruct usb_tt_clear *clear;\r\nif ((clear = kmalloc (sizeof *clear, GFP_ATOMIC)) == NULL) {\r\ndev_err (&udev->dev, "can't save CLEAR_TT_BUFFER state\n");\r\nreturn -ENOMEM;\r\n}\r\nclear->tt = tt->multi ? udev->ttport : 1;\r\nclear->devinfo = usb_pipeendpoint (pipe);\r\nclear->devinfo |= udev->devnum << 4;\r\nclear->devinfo |= usb_pipecontrol (pipe)\r\n? (USB_ENDPOINT_XFER_CONTROL << 11)\r\n: (USB_ENDPOINT_XFER_BULK << 11);\r\nif (usb_pipein (pipe))\r\nclear->devinfo |= 1 << 15;\r\nclear->hcd = bus_to_hcd(udev->bus);\r\nclear->ep = urb->ep;\r\nspin_lock_irqsave (&tt->lock, flags);\r\nlist_add_tail (&clear->clear_list, &tt->clear_list);\r\nschedule_work(&tt->clear_work);\r\nspin_unlock_irqrestore (&tt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic unsigned hub_power_on(struct usb_hub *hub, bool do_delay)\r\n{\r\nint port1;\r\nunsigned pgood_delay = hub->descriptor->bPwrOn2PwrGood * 2;\r\nunsigned delay;\r\nu16 wHubCharacteristics =\r\nle16_to_cpu(hub->descriptor->wHubCharacteristics);\r\nif ((wHubCharacteristics & HUB_CHAR_LPSM) < 2)\r\ndev_dbg(hub->intfdev, "enabling power on all ports\n");\r\nelse\r\ndev_dbg(hub->intfdev, "trying to enable port power on "\r\n"non-switchable hub\n");\r\nfor (port1 = 1; port1 <= hub->descriptor->bNbrPorts; port1++)\r\nset_port_feature(hub->hdev, port1, USB_PORT_FEAT_POWER);\r\ndelay = max(pgood_delay, (unsigned) 100);\r\nif (do_delay)\r\nmsleep(delay);\r\nreturn delay;\r\n}\r\nstatic int hub_hub_status(struct usb_hub *hub,\r\nu16 *status, u16 *change)\r\n{\r\nint ret;\r\nmutex_lock(&hub->status_mutex);\r\nret = get_hub_status(hub->hdev, &hub->status->hub);\r\nif (ret < 0)\r\ndev_err (hub->intfdev,\r\n"%s failed (err = %d)\n", __func__, ret);\r\nelse {\r\n*status = le16_to_cpu(hub->status->hub.wHubStatus);\r\n*change = le16_to_cpu(hub->status->hub.wHubChange);\r\nret = 0;\r\n}\r\nmutex_unlock(&hub->status_mutex);\r\nreturn ret;\r\n}\r\nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state)\r\n{\r\nstruct usb_device *hdev = hub->hdev;\r\nint ret = 0;\r\nif (hdev->children[port1-1] && set_state)\r\nusb_set_device_state(hdev->children[port1-1],\r\nUSB_STATE_NOTATTACHED);\r\nif (!hub->error && !hub_is_superspeed(hub->hdev))\r\nret = clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE);\r\nif (ret)\r\ndev_err(hub->intfdev, "cannot disable port %d (err = %d)\n",\r\nport1, ret);\r\nreturn ret;\r\n}\r\nstatic void hub_port_logical_disconnect(struct usb_hub *hub, int port1)\r\n{\r\ndev_dbg(hub->intfdev, "logical disconnect on port %d\n", port1);\r\nhub_port_disable(hub, port1, 1);\r\nset_bit(port1, hub->change_bits);\r\nkick_khubd(hub);\r\n}\r\nint usb_remove_device(struct usb_device *udev)\r\n{\r\nstruct usb_hub *hub;\r\nstruct usb_interface *intf;\r\nif (!udev->parent)\r\nreturn -EINVAL;\r\nhub = hdev_to_hub(udev->parent);\r\nintf = to_usb_interface(hub->intfdev);\r\nusb_autopm_get_interface(intf);\r\nset_bit(udev->portnum, hub->removed_bits);\r\nhub_port_logical_disconnect(hub, udev->portnum);\r\nusb_autopm_put_interface(intf);\r\nreturn 0;\r\n}\r\nstatic void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\r\n{\r\nstruct usb_device *hdev = hub->hdev;\r\nstruct usb_hcd *hcd;\r\nint ret;\r\nint port1;\r\nint status;\r\nbool need_debounce_delay = false;\r\nunsigned delay;\r\nif (type == HUB_INIT2)\r\ngoto init2;\r\nif (type == HUB_INIT3)\r\ngoto init3;\r\nif (type != HUB_RESUME) {\r\nif (type == HUB_INIT) {\r\ndelay = hub_power_on(hub, false);\r\nPREPARE_DELAYED_WORK(&hub->init_work, hub_init_func2);\r\nschedule_delayed_work(&hub->init_work,\r\nmsecs_to_jiffies(delay));\r\nusb_autopm_get_interface_no_resume(\r\nto_usb_interface(hub->intfdev));\r\nreturn;\r\n} else if (type == HUB_RESET_RESUME) {\r\nhcd = bus_to_hcd(hdev->bus);\r\nif (hcd->driver->update_hub_device) {\r\nret = hcd->driver->update_hub_device(hcd, hdev,\r\n&hub->tt, GFP_NOIO);\r\nif (ret < 0) {\r\ndev_err(hub->intfdev, "Host not "\r\n"accepting hub info "\r\n"update.\n");\r\ndev_err(hub->intfdev, "LS/FS devices "\r\n"and hubs may not work "\r\n"under this hub\n.");\r\n}\r\n}\r\nhub_power_on(hub, true);\r\n} else {\r\nhub_power_on(hub, true);\r\n}\r\n}\r\ninit2:\r\nfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\r\nstruct usb_device *udev = hdev->children[port1-1];\r\nu16 portstatus, portchange;\r\nportstatus = portchange = 0;\r\nstatus = hub_port_status(hub, port1, &portstatus, &portchange);\r\nif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\r\ndev_dbg(hub->intfdev,\r\n"port %d: status %04x change %04x\n",\r\nport1, portstatus, portchange);\r\nif ((portstatus & USB_PORT_STAT_ENABLE) && (\r\ntype != HUB_RESUME ||\r\n!(portstatus & USB_PORT_STAT_CONNECTION) ||\r\n!udev ||\r\nudev->state == USB_STATE_NOTATTACHED)) {\r\nif (!hub_is_superspeed(hdev)) {\r\nclear_port_feature(hdev, port1,\r\nUSB_PORT_FEAT_ENABLE);\r\nportstatus &= ~USB_PORT_STAT_ENABLE;\r\n} else {\r\nportstatus &= ~USB_PORT_STAT_ENABLE;\r\n}\r\n}\r\nif (portchange & USB_PORT_STAT_C_CONNECTION) {\r\nneed_debounce_delay = true;\r\nclear_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_C_CONNECTION);\r\n}\r\nif (portchange & USB_PORT_STAT_C_ENABLE) {\r\nneed_debounce_delay = true;\r\nclear_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_C_ENABLE);\r\n}\r\nif (portchange & USB_PORT_STAT_C_LINK_STATE) {\r\nneed_debounce_delay = true;\r\nclear_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_C_PORT_LINK_STATE);\r\n}\r\nif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\r\n(portchange & USB_PORT_STAT_C_CONNECTION))\r\nclear_bit(port1, hub->removed_bits);\r\nif (!udev || udev->state == USB_STATE_NOTATTACHED) {\r\nif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\r\nset_bit(port1, hub->change_bits);\r\n} else if (portstatus & USB_PORT_STAT_ENABLE) {\r\nif (portchange)\r\nset_bit(port1, hub->change_bits);\r\n} else if (udev->persist_enabled) {\r\n#ifdef CONFIG_PM\r\nudev->reset_resume = 1;\r\n#endif\r\nset_bit(port1, hub->change_bits);\r\n} else {\r\nusb_set_device_state(udev, USB_STATE_NOTATTACHED);\r\nset_bit(port1, hub->change_bits);\r\n}\r\n}\r\nif (need_debounce_delay) {\r\ndelay = HUB_DEBOUNCE_STABLE;\r\nif (type == HUB_INIT2) {\r\nPREPARE_DELAYED_WORK(&hub->init_work, hub_init_func3);\r\nschedule_delayed_work(&hub->init_work,\r\nmsecs_to_jiffies(delay));\r\nreturn;\r\n} else {\r\nmsleep(delay);\r\n}\r\n}\r\ninit3:\r\nhub->quiescing = 0;\r\nstatus = usb_submit_urb(hub->urb, GFP_NOIO);\r\nif (status < 0)\r\ndev_err(hub->intfdev, "activate --> %d\n", status);\r\nif (hub->has_indicators && blinkenlights)\r\nschedule_delayed_work(&hub->leds, LED_CYCLE_PERIOD);\r\nkick_khubd(hub);\r\nif (type <= HUB_INIT3)\r\nusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\r\n}\r\nstatic void hub_init_func2(struct work_struct *ws)\r\n{\r\nstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\r\nhub_activate(hub, HUB_INIT2);\r\n}\r\nstatic void hub_init_func3(struct work_struct *ws)\r\n{\r\nstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\r\nhub_activate(hub, HUB_INIT3);\r\n}\r\nstatic void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)\r\n{\r\nstruct usb_device *hdev = hub->hdev;\r\nint i;\r\ncancel_delayed_work_sync(&hub->init_work);\r\nhub->quiescing = 1;\r\nif (type != HUB_SUSPEND) {\r\nfor (i = 0; i < hdev->maxchild; ++i) {\r\nif (hdev->children[i])\r\nusb_disconnect(&hdev->children[i]);\r\n}\r\n}\r\nusb_kill_urb(hub->urb);\r\nif (hub->has_indicators)\r\ncancel_delayed_work_sync(&hub->leds);\r\nif (hub->tt.hub)\r\ncancel_work_sync(&hub->tt.clear_work);\r\n}\r\nstatic int hub_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct usb_hub *hub = usb_get_intfdata(intf);\r\nhub_quiesce(hub, HUB_PRE_RESET);\r\nreturn 0;\r\n}\r\nstatic int hub_post_reset(struct usb_interface *intf)\r\n{\r\nstruct usb_hub *hub = usb_get_intfdata(intf);\r\nhub_activate(hub, HUB_POST_RESET);\r\nreturn 0;\r\n}\r\nstatic int hub_configure(struct usb_hub *hub,\r\nstruct usb_endpoint_descriptor *endpoint)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct usb_device *hdev = hub->hdev;\r\nstruct device *hub_dev = hub->intfdev;\r\nu16 hubstatus, hubchange;\r\nu16 wHubCharacteristics;\r\nunsigned int pipe;\r\nint maxp, ret;\r\nchar *message = "out of memory";\r\nhub->buffer = kmalloc(sizeof(*hub->buffer), GFP_KERNEL);\r\nif (!hub->buffer) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nhub->status = kmalloc(sizeof(*hub->status), GFP_KERNEL);\r\nif (!hub->status) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmutex_init(&hub->status_mutex);\r\nhub->descriptor = kmalloc(sizeof(*hub->descriptor), GFP_KERNEL);\r\nif (!hub->descriptor) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (hub_is_superspeed(hdev) && (hdev->parent != NULL)) {\r\nret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\r\nHUB_SET_DEPTH, USB_RT_HUB,\r\nhdev->level - 1, 0, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret < 0) {\r\nmessage = "can't set hub depth";\r\ngoto fail;\r\n}\r\n}\r\nret = get_hub_descriptor(hdev, hub->descriptor);\r\nif (ret < 0) {\r\nmessage = "can't read hub descriptor";\r\ngoto fail;\r\n} else if (hub->descriptor->bNbrPorts > USB_MAXCHILDREN) {\r\nmessage = "hub has too many ports!";\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nhdev->maxchild = hub->descriptor->bNbrPorts;\r\ndev_info (hub_dev, "%d port%s detected\n", hdev->maxchild,\r\n(hdev->maxchild == 1) ? "" : "s");\r\nhub->port_owners = kzalloc(hdev->maxchild * sizeof(void *), GFP_KERNEL);\r\nif (!hub->port_owners) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nwHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\r\nif ((wHubCharacteristics & HUB_CHAR_COMPOUND) &&\r\n!(hub_is_superspeed(hdev))) {\r\nint i;\r\nchar portstr [USB_MAXCHILDREN + 1];\r\nfor (i = 0; i < hdev->maxchild; i++)\r\nportstr[i] = hub->descriptor->u.hs.DeviceRemovable\r\n[((i + 1) / 8)] & (1 << ((i + 1) % 8))\r\n? 'F' : 'R';\r\nportstr[hdev->maxchild] = 0;\r\ndev_dbg(hub_dev, "compound device; port removable status: %s\n", portstr);\r\n} else\r\ndev_dbg(hub_dev, "standalone hub\n");\r\nswitch (wHubCharacteristics & HUB_CHAR_LPSM) {\r\ncase 0x00:\r\ndev_dbg(hub_dev, "ganged power switching\n");\r\nbreak;\r\ncase 0x01:\r\ndev_dbg(hub_dev, "individual port power switching\n");\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\ndev_dbg(hub_dev, "no power switching (usb 1.0)\n");\r\nbreak;\r\n}\r\nswitch (wHubCharacteristics & HUB_CHAR_OCPM) {\r\ncase 0x00:\r\ndev_dbg(hub_dev, "global over-current protection\n");\r\nbreak;\r\ncase 0x08:\r\ndev_dbg(hub_dev, "individual port over-current protection\n");\r\nbreak;\r\ncase 0x10:\r\ncase 0x18:\r\ndev_dbg(hub_dev, "no over-current protection\n");\r\nbreak;\r\n}\r\nspin_lock_init (&hub->tt.lock);\r\nINIT_LIST_HEAD (&hub->tt.clear_list);\r\nINIT_WORK(&hub->tt.clear_work, hub_tt_work);\r\nswitch (hdev->descriptor.bDeviceProtocol) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ndev_dbg(hub_dev, "Single TT\n");\r\nhub->tt.hub = hdev;\r\nbreak;\r\ncase 2:\r\nret = usb_set_interface(hdev, 0, 1);\r\nif (ret == 0) {\r\ndev_dbg(hub_dev, "TT per port\n");\r\nhub->tt.multi = 1;\r\n} else\r\ndev_err(hub_dev, "Using single TT (err %d)\n",\r\nret);\r\nhub->tt.hub = hdev;\r\nbreak;\r\ncase 3:\r\nbreak;\r\ndefault:\r\ndev_dbg(hub_dev, "Unrecognized hub protocol %d\n",\r\nhdev->descriptor.bDeviceProtocol);\r\nbreak;\r\n}\r\nswitch (wHubCharacteristics & HUB_CHAR_TTTT) {\r\ncase HUB_TTTT_8_BITS:\r\nif (hdev->descriptor.bDeviceProtocol != 0) {\r\nhub->tt.think_time = 666;\r\ndev_dbg(hub_dev, "TT requires at most %d "\r\n"FS bit times (%d ns)\n",\r\n8, hub->tt.think_time);\r\n}\r\nbreak;\r\ncase HUB_TTTT_16_BITS:\r\nhub->tt.think_time = 666 * 2;\r\ndev_dbg(hub_dev, "TT requires at most %d "\r\n"FS bit times (%d ns)\n",\r\n16, hub->tt.think_time);\r\nbreak;\r\ncase HUB_TTTT_24_BITS:\r\nhub->tt.think_time = 666 * 3;\r\ndev_dbg(hub_dev, "TT requires at most %d "\r\n"FS bit times (%d ns)\n",\r\n24, hub->tt.think_time);\r\nbreak;\r\ncase HUB_TTTT_32_BITS:\r\nhub->tt.think_time = 666 * 4;\r\ndev_dbg(hub_dev, "TT requires at most %d "\r\n"FS bit times (%d ns)\n",\r\n32, hub->tt.think_time);\r\nbreak;\r\n}\r\nif (wHubCharacteristics & HUB_CHAR_PORTIND) {\r\nhub->has_indicators = 1;\r\ndev_dbg(hub_dev, "Port indicators are supported\n");\r\n}\r\ndev_dbg(hub_dev, "power on to power good time: %dms\n",\r\nhub->descriptor->bPwrOn2PwrGood * 2);\r\nret = usb_get_status(hdev, USB_RECIP_DEVICE, 0, &hubstatus);\r\nif (ret < 2) {\r\nmessage = "can't get hub status";\r\ngoto fail;\r\n}\r\nle16_to_cpus(&hubstatus);\r\nif (hdev == hdev->bus->root_hub) {\r\nif (hdev->bus_mA == 0 || hdev->bus_mA >= 500)\r\nhub->mA_per_port = 500;\r\nelse {\r\nhub->mA_per_port = hdev->bus_mA;\r\nhub->limited_power = 1;\r\n}\r\n} else if ((hubstatus & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\r\ndev_dbg(hub_dev, "hub controller current requirement: %dmA\n",\r\nhub->descriptor->bHubContrCurrent);\r\nhub->limited_power = 1;\r\nif (hdev->maxchild > 0) {\r\nint remaining = hdev->bus_mA -\r\nhub->descriptor->bHubContrCurrent;\r\nif (remaining < hdev->maxchild * 100)\r\ndev_warn(hub_dev,\r\n"insufficient power available "\r\n"to use all downstream ports\n");\r\nhub->mA_per_port = 100;\r\n}\r\n} else {\r\nhub->mA_per_port = 500;\r\n}\r\nif (hub->mA_per_port < 500)\r\ndev_dbg(hub_dev, "%umA bus power budget for each child\n",\r\nhub->mA_per_port);\r\nhcd = bus_to_hcd(hdev->bus);\r\nif (hcd->driver->update_hub_device) {\r\nret = hcd->driver->update_hub_device(hcd, hdev,\r\n&hub->tt, GFP_KERNEL);\r\nif (ret < 0) {\r\nmessage = "can't update HCD hub info";\r\ngoto fail;\r\n}\r\n}\r\nret = hub_hub_status(hub, &hubstatus, &hubchange);\r\nif (ret < 0) {\r\nmessage = "can't get hub status";\r\ngoto fail;\r\n}\r\nif (hdev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_SELFPOWER)\r\ndev_dbg(hub_dev, "local power source is %s\n",\r\n(hubstatus & HUB_STATUS_LOCAL_POWER)\r\n? "lost (inactive)" : "good");\r\nif ((wHubCharacteristics & HUB_CHAR_OCPM) == 0)\r\ndev_dbg(hub_dev, "%sover-current condition exists\n",\r\n(hubstatus & HUB_STATUS_OVERCURRENT) ? "" : "no ");\r\npipe = usb_rcvintpipe(hdev, endpoint->bEndpointAddress);\r\nmaxp = usb_maxpacket(hdev, pipe, usb_pipeout(pipe));\r\nif (maxp > sizeof(*hub->buffer))\r\nmaxp = sizeof(*hub->buffer);\r\nhub->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!hub->urb) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nusb_fill_int_urb(hub->urb, hdev, pipe, *hub->buffer, maxp, hub_irq,\r\nhub, endpoint->bInterval);\r\nif (hub->has_indicators && blinkenlights)\r\nhub->indicator [0] = INDICATOR_CYCLE;\r\nhub_activate(hub, HUB_INIT);\r\nreturn 0;\r\nfail:\r\ndev_err (hub_dev, "config failed, %s (err %d)\n",\r\nmessage, ret);\r\nreturn ret;\r\n}\r\nstatic void hub_release(struct kref *kref)\r\n{\r\nstruct usb_hub *hub = container_of(kref, struct usb_hub, kref);\r\nusb_put_intf(to_usb_interface(hub->intfdev));\r\nkfree(hub);\r\n}\r\nstatic void hub_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_hub *hub = usb_get_intfdata (intf);\r\nspin_lock_irq(&hub_event_lock);\r\nif (!list_empty(&hub->event_list)) {\r\nlist_del_init(&hub->event_list);\r\nusb_autopm_put_interface_no_suspend(intf);\r\n}\r\nhub->disconnected = 1;\r\nspin_unlock_irq(&hub_event_lock);\r\nhub->error = 0;\r\nhub_quiesce(hub, HUB_DISCONNECT);\r\nusb_set_intfdata (intf, NULL);\r\nhub->hdev->maxchild = 0;\r\nif (hub->hdev->speed == USB_SPEED_HIGH)\r\nhighspeed_hubs--;\r\nusb_free_urb(hub->urb);\r\nkfree(hub->port_owners);\r\nkfree(hub->descriptor);\r\nkfree(hub->status);\r\nkfree(hub->buffer);\r\nkref_put(&hub->kref, hub_release);\r\n}\r\nstatic int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_host_interface *desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_device *hdev;\r\nstruct usb_hub *hub;\r\ndesc = intf->cur_altsetting;\r\nhdev = interface_to_usbdev(intf);\r\nif (!hub_is_superspeed(hdev) || !hdev->parent)\r\nusb_enable_autosuspend(hdev);\r\nif (hdev->level == MAX_TOPO_LEVEL) {\r\ndev_err(&intf->dev,\r\n"Unsupported bus topology: hub nested too deep\n");\r\nreturn -E2BIG;\r\n}\r\n#ifdef CONFIG_USB_OTG_BLACKLIST_HUB\r\nif (hdev->parent) {\r\ndev_warn(&intf->dev, "ignoring external hub\n");\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nif ((desc->desc.bInterfaceSubClass != 0) &&\r\n(desc->desc.bInterfaceSubClass != 1)) {\r\ndescriptor_error:\r\ndev_err (&intf->dev, "bad descriptor, ignoring hub\n");\r\nreturn -EIO;\r\n}\r\nif (desc->desc.bNumEndpoints != 1)\r\ngoto descriptor_error;\r\nendpoint = &desc->endpoint[0].desc;\r\nif (!usb_endpoint_is_int_in(endpoint))\r\ngoto descriptor_error;\r\ndev_info (&intf->dev, "USB hub found\n");\r\nhub = kzalloc(sizeof(*hub), GFP_KERNEL);\r\nif (!hub) {\r\ndev_dbg (&intf->dev, "couldn't kmalloc hub struct\n");\r\nreturn -ENOMEM;\r\n}\r\nkref_init(&hub->kref);\r\nINIT_LIST_HEAD(&hub->event_list);\r\nhub->intfdev = &intf->dev;\r\nhub->hdev = hdev;\r\nINIT_DELAYED_WORK(&hub->leds, led_work);\r\nINIT_DELAYED_WORK(&hub->init_work, NULL);\r\nusb_get_intf(intf);\r\nusb_set_intfdata (intf, hub);\r\nintf->needs_remote_wakeup = 1;\r\nif (hdev->speed == USB_SPEED_HIGH)\r\nhighspeed_hubs++;\r\nif (hub_configure(hub, endpoint) >= 0)\r\nreturn 0;\r\nhub_disconnect (intf);\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nhub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)\r\n{\r\nstruct usb_device *hdev = interface_to_usbdev (intf);\r\nswitch (code) {\r\ncase USBDEVFS_HUB_PORTINFO: {\r\nstruct usbdevfs_hub_portinfo *info = user_data;\r\nint i;\r\nspin_lock_irq(&device_state_lock);\r\nif (hdev->devnum <= 0)\r\ninfo->nports = 0;\r\nelse {\r\ninfo->nports = hdev->maxchild;\r\nfor (i = 0; i < info->nports; i++) {\r\nif (hdev->children[i] == NULL)\r\ninfo->port[i] = 0;\r\nelse\r\ninfo->port[i] =\r\nhdev->children[i]->devnum;\r\n}\r\n}\r\nspin_unlock_irq(&device_state_lock);\r\nreturn info->nports + 1;\r\n}\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\n}\r\nstatic int find_port_owner(struct usb_device *hdev, unsigned port1,\r\nvoid ***ppowner)\r\n{\r\nif (hdev->state == USB_STATE_NOTATTACHED)\r\nreturn -ENODEV;\r\nif (port1 == 0 || port1 > hdev->maxchild)\r\nreturn -EINVAL;\r\n*ppowner = &(hdev_to_hub(hdev)->port_owners[port1 - 1]);\r\nreturn 0;\r\n}\r\nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1, void *owner)\r\n{\r\nint rc;\r\nvoid **powner;\r\nrc = find_port_owner(hdev, port1, &powner);\r\nif (rc)\r\nreturn rc;\r\nif (*powner)\r\nreturn -EBUSY;\r\n*powner = owner;\r\nreturn rc;\r\n}\r\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1, void *owner)\r\n{\r\nint rc;\r\nvoid **powner;\r\nrc = find_port_owner(hdev, port1, &powner);\r\nif (rc)\r\nreturn rc;\r\nif (*powner != owner)\r\nreturn -ENOENT;\r\n*powner = NULL;\r\nreturn rc;\r\n}\r\nvoid usb_hub_release_all_ports(struct usb_device *hdev, void *owner)\r\n{\r\nint n;\r\nvoid **powner;\r\nn = find_port_owner(hdev, 1, &powner);\r\nif (n == 0) {\r\nfor (; n < hdev->maxchild; (++n, ++powner)) {\r\nif (*powner == owner)\r\n*powner = NULL;\r\n}\r\n}\r\n}\r\nbool usb_device_is_owned(struct usb_device *udev)\r\n{\r\nstruct usb_hub *hub;\r\nif (udev->state == USB_STATE_NOTATTACHED || !udev->parent)\r\nreturn false;\r\nhub = hdev_to_hub(udev->parent);\r\nreturn !!hub->port_owners[udev->portnum - 1];\r\n}\r\nstatic void recursively_mark_NOTATTACHED(struct usb_device *udev)\r\n{\r\nint i;\r\nfor (i = 0; i < udev->maxchild; ++i) {\r\nif (udev->children[i])\r\nrecursively_mark_NOTATTACHED(udev->children[i]);\r\n}\r\nif (udev->state == USB_STATE_SUSPENDED)\r\nudev->active_duration -= jiffies;\r\nudev->state = USB_STATE_NOTATTACHED;\r\n}\r\nvoid usb_set_device_state(struct usb_device *udev,\r\nenum usb_device_state new_state)\r\n{\r\nunsigned long flags;\r\nint wakeup = -1;\r\nspin_lock_irqsave(&device_state_lock, flags);\r\nif (udev->state == USB_STATE_NOTATTACHED)\r\n;\r\nelse if (new_state != USB_STATE_NOTATTACHED) {\r\nif (udev->parent) {\r\nif (udev->state == USB_STATE_SUSPENDED\r\n|| new_state == USB_STATE_SUSPENDED)\r\n;\r\nelse if (new_state == USB_STATE_CONFIGURED)\r\nwakeup = udev->actconfig->desc.bmAttributes\r\n& USB_CONFIG_ATT_WAKEUP;\r\nelse\r\nwakeup = 0;\r\n}\r\nif (udev->state == USB_STATE_SUSPENDED &&\r\nnew_state != USB_STATE_SUSPENDED)\r\nudev->active_duration -= jiffies;\r\nelse if (new_state == USB_STATE_SUSPENDED &&\r\nudev->state != USB_STATE_SUSPENDED)\r\nudev->active_duration += jiffies;\r\nudev->state = new_state;\r\n} else\r\nrecursively_mark_NOTATTACHED(udev);\r\nspin_unlock_irqrestore(&device_state_lock, flags);\r\nif (wakeup >= 0)\r\ndevice_set_wakeup_capable(&udev->dev, wakeup);\r\n}\r\nstatic void choose_devnum(struct usb_device *udev)\r\n{\r\nint devnum;\r\nstruct usb_bus *bus = udev->bus;\r\nif (udev->wusb) {\r\ndevnum = udev->portnum + 1;\r\nBUG_ON(test_bit(devnum, bus->devmap.devicemap));\r\n} else {\r\ndevnum = find_next_zero_bit(bus->devmap.devicemap, 128,\r\nbus->devnum_next);\r\nif (devnum >= 128)\r\ndevnum = find_next_zero_bit(bus->devmap.devicemap,\r\n128, 1);\r\nbus->devnum_next = ( devnum >= 127 ? 1 : devnum + 1);\r\n}\r\nif (devnum < 128) {\r\nset_bit(devnum, bus->devmap.devicemap);\r\nudev->devnum = devnum;\r\n}\r\n}\r\nstatic void release_devnum(struct usb_device *udev)\r\n{\r\nif (udev->devnum > 0) {\r\nclear_bit(udev->devnum, udev->bus->devmap.devicemap);\r\nudev->devnum = -1;\r\n}\r\n}\r\nstatic void update_devnum(struct usb_device *udev, int devnum)\r\n{\r\nif (!udev->wusb)\r\nudev->devnum = devnum;\r\n}\r\nstatic void hub_free_dev(struct usb_device *udev)\r\n{\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nif (hcd->driver->free_dev && udev->parent)\r\nhcd->driver->free_dev(hcd, udev);\r\n}\r\nvoid usb_disconnect(struct usb_device **pdev)\r\n{\r\nstruct usb_device *udev = *pdev;\r\nint i;\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nif (!udev) {\r\npr_debug ("%s nodev\n", __func__);\r\nreturn;\r\n}\r\nusb_set_device_state(udev, USB_STATE_NOTATTACHED);\r\ndev_info(&udev->dev, "USB disconnect, device number %d\n",\r\nudev->devnum);\r\nusb_lock_device(udev);\r\nfor (i = 0; i < USB_MAXCHILDREN; i++) {\r\nif (udev->children[i])\r\nusb_disconnect(&udev->children[i]);\r\n}\r\ndev_dbg (&udev->dev, "unregistering device\n");\r\nmutex_lock(hcd->bandwidth_mutex);\r\nusb_disable_device(udev, 0);\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nusb_hcd_synchronize_unlinks(udev);\r\nusb_remove_ep_devs(&udev->ep0);\r\nusb_unlock_device(udev);\r\ndevice_del(&udev->dev);\r\nrelease_devnum(udev);\r\nspin_lock_irq(&device_state_lock);\r\n*pdev = NULL;\r\nspin_unlock_irq(&device_state_lock);\r\nhub_free_dev(udev);\r\nput_device(&udev->dev);\r\n}\r\nstatic void show_string(struct usb_device *udev, char *id, char *string)\r\n{\r\nif (!string)\r\nreturn;\r\ndev_printk(KERN_INFO, &udev->dev, "%s: %s\n", id, string);\r\n}\r\nstatic void announce_device(struct usb_device *udev)\r\n{\r\ndev_info(&udev->dev, "New USB device found, idVendor=%04x, idProduct=%04x\n",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\ndev_info(&udev->dev,\r\n"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\n",\r\nudev->descriptor.iManufacturer,\r\nudev->descriptor.iProduct,\r\nudev->descriptor.iSerialNumber);\r\nshow_string(udev, "Product", udev->product);\r\nshow_string(udev, "Manufacturer", udev->manufacturer);\r\nshow_string(udev, "SerialNumber", udev->serial);\r\n}\r\nstatic inline void announce_device(struct usb_device *udev) { }\r\nstatic int usb_enumerate_device_otg(struct usb_device *udev)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_USB_OTG\r\nif (!udev->bus->is_b_host\r\n&& udev->config\r\n&& udev->parent == udev->bus->root_hub) {\r\nstruct usb_otg_descriptor *desc = NULL;\r\nstruct usb_bus *bus = udev->bus;\r\nif (__usb_get_extra_descriptor (udev->rawdescriptors[0],\r\nle16_to_cpu(udev->config[0].desc.wTotalLength),\r\nUSB_DT_OTG, (void **) &desc) == 0) {\r\nif (desc->bmAttributes & USB_OTG_HNP) {\r\nunsigned port1 = udev->portnum;\r\ndev_info(&udev->dev,\r\n"Dual-Role OTG device on %sHNP port\n",\r\n(port1 == bus->otg_port)\r\n? "" : "non-");\r\nif (port1 == bus->otg_port)\r\nbus->b_hnp_enable = 1;\r\nerr = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nUSB_REQ_SET_FEATURE, 0,\r\nbus->b_hnp_enable\r\n? USB_DEVICE_B_HNP_ENABLE\r\n: USB_DEVICE_A_ALT_HNP_SUPPORT,\r\n0, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\nif (err < 0) {\r\ndev_info(&udev->dev,\r\n"can't set HNP mode: %d\n",\r\nerr);\r\nbus->b_hnp_enable = 0;\r\n}\r\n}\r\n}\r\n}\r\nif (!is_targeted(udev)) {\r\nif (udev->bus->b_hnp_enable || udev->bus->is_b_host) {\r\nerr = usb_port_suspend(udev, PMSG_SUSPEND);\r\nif (err < 0)\r\ndev_dbg(&udev->dev, "HNP fail, %d\n", err);\r\n}\r\nerr = -ENOTSUPP;\r\ngoto fail;\r\n}\r\nfail:\r\n#endif\r\nreturn err;\r\n}\r\nstatic int usb_enumerate_device(struct usb_device *udev)\r\n{\r\nint err;\r\nif (udev->config == NULL) {\r\nerr = usb_get_configuration(udev);\r\nif (err < 0) {\r\ndev_err(&udev->dev, "can't read configurations, error %d\n",\r\nerr);\r\ngoto fail;\r\n}\r\n}\r\nif (udev->wusb == 1 && udev->authorized == 0) {\r\nudev->product = kstrdup("n/a (unauthorized)", GFP_KERNEL);\r\nudev->manufacturer = kstrdup("n/a (unauthorized)", GFP_KERNEL);\r\nudev->serial = kstrdup("n/a (unauthorized)", GFP_KERNEL);\r\n}\r\nelse {\r\nudev->product = usb_cache_string(udev, udev->descriptor.iProduct);\r\nudev->manufacturer = usb_cache_string(udev,\r\nudev->descriptor.iManufacturer);\r\nudev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);\r\n}\r\nerr = usb_enumerate_device_otg(udev);\r\nfail:\r\nreturn err;\r\n}\r\nint usb_new_device(struct usb_device *udev)\r\n{\r\nint err;\r\nif (udev->parent) {\r\ndevice_init_wakeup(&udev->dev, 0);\r\n}\r\npm_runtime_set_active(&udev->dev);\r\npm_runtime_get_noresume(&udev->dev);\r\npm_runtime_use_autosuspend(&udev->dev);\r\npm_runtime_enable(&udev->dev);\r\nusb_disable_autosuspend(udev);\r\nerr = usb_enumerate_device(udev);\r\nif (err < 0)\r\ngoto fail;\r\ndev_dbg(&udev->dev, "udev %d, busnum %d, minor = %d\n",\r\nudev->devnum, udev->bus->busnum,\r\n(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\r\nudev->dev.devt = MKDEV(USB_DEVICE_MAJOR,\r\n(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\r\nannounce_device(udev);\r\ndevice_enable_async_suspend(&udev->dev);\r\nerr = device_add(&udev->dev);\r\nif (err) {\r\ndev_err(&udev->dev, "can't device_add, error %d\n", err);\r\ngoto fail;\r\n}\r\n(void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);\r\nusb_mark_last_busy(udev);\r\npm_runtime_put_sync_autosuspend(&udev->dev);\r\nreturn err;\r\nfail:\r\nusb_set_device_state(udev, USB_STATE_NOTATTACHED);\r\npm_runtime_disable(&udev->dev);\r\npm_runtime_set_suspended(&udev->dev);\r\nreturn err;\r\n}\r\nint usb_deauthorize_device(struct usb_device *usb_dev)\r\n{\r\nusb_lock_device(usb_dev);\r\nif (usb_dev->authorized == 0)\r\ngoto out_unauthorized;\r\nusb_dev->authorized = 0;\r\nusb_set_configuration(usb_dev, -1);\r\nkfree(usb_dev->product);\r\nusb_dev->product = kstrdup("n/a (unauthorized)", GFP_KERNEL);\r\nkfree(usb_dev->manufacturer);\r\nusb_dev->manufacturer = kstrdup("n/a (unauthorized)", GFP_KERNEL);\r\nkfree(usb_dev->serial);\r\nusb_dev->serial = kstrdup("n/a (unauthorized)", GFP_KERNEL);\r\nusb_destroy_configuration(usb_dev);\r\nusb_dev->descriptor.bNumConfigurations = 0;\r\nout_unauthorized:\r\nusb_unlock_device(usb_dev);\r\nreturn 0;\r\n}\r\nint usb_authorize_device(struct usb_device *usb_dev)\r\n{\r\nint result = 0, c;\r\nusb_lock_device(usb_dev);\r\nif (usb_dev->authorized == 1)\r\ngoto out_authorized;\r\nresult = usb_autoresume_device(usb_dev);\r\nif (result < 0) {\r\ndev_err(&usb_dev->dev,\r\n"can't autoresume for authorization: %d\n", result);\r\ngoto error_autoresume;\r\n}\r\nresult = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));\r\nif (result < 0) {\r\ndev_err(&usb_dev->dev, "can't re-read device descriptor for "\r\n"authorization: %d\n", result);\r\ngoto error_device_descriptor;\r\n}\r\nkfree(usb_dev->product);\r\nusb_dev->product = NULL;\r\nkfree(usb_dev->manufacturer);\r\nusb_dev->manufacturer = NULL;\r\nkfree(usb_dev->serial);\r\nusb_dev->serial = NULL;\r\nusb_dev->authorized = 1;\r\nresult = usb_enumerate_device(usb_dev);\r\nif (result < 0)\r\ngoto error_enumerate;\r\nc = usb_choose_configuration(usb_dev);\r\nif (c >= 0) {\r\nresult = usb_set_configuration(usb_dev, c);\r\nif (result) {\r\ndev_err(&usb_dev->dev,\r\n"can't set config #%d, error %d\n", c, result);\r\n}\r\n}\r\ndev_info(&usb_dev->dev, "authorized to connect\n");\r\nerror_enumerate:\r\nerror_device_descriptor:\r\nusb_autosuspend_device(usb_dev);\r\nerror_autoresume:\r\nout_authorized:\r\nusb_unlock_device(usb_dev);\r\nreturn result;\r\n}\r\nstatic unsigned hub_is_wusb(struct usb_hub *hub)\r\n{\r\nstruct usb_hcd *hcd;\r\nif (hub->hdev->parent != NULL)\r\nreturn 0;\r\nhcd = container_of(hub->hdev->bus, struct usb_hcd, self);\r\nreturn hcd->wireless;\r\n}\r\nstatic int hub_port_wait_reset(struct usb_hub *hub, int port1,\r\nstruct usb_device *udev, unsigned int delay)\r\n{\r\nint delay_time, ret;\r\nu16 portstatus;\r\nu16 portchange;\r\nfor (delay_time = 0;\r\ndelay_time < HUB_RESET_TIMEOUT;\r\ndelay_time += delay) {\r\nmsleep(delay);\r\nret = hub_port_status(hub, port1, &portstatus, &portchange);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(portstatus & USB_PORT_STAT_CONNECTION))\r\nreturn -ENOTCONN;\r\nif ((portchange & USB_PORT_STAT_C_CONNECTION))\r\nreturn -ENOTCONN;\r\nif (!(portstatus & USB_PORT_STAT_RESET) &&\r\n(portstatus & USB_PORT_STAT_ENABLE)) {\r\nif (hub_is_wusb(hub))\r\nudev->speed = USB_SPEED_WIRELESS;\r\nelse if (hub_is_superspeed(hub->hdev))\r\nudev->speed = USB_SPEED_SUPER;\r\nelse if (portstatus & USB_PORT_STAT_HIGH_SPEED)\r\nudev->speed = USB_SPEED_HIGH;\r\nelse if (portstatus & USB_PORT_STAT_LOW_SPEED)\r\nudev->speed = USB_SPEED_LOW;\r\nelse\r\nudev->speed = USB_SPEED_FULL;\r\nreturn 0;\r\n}\r\nif (delay_time >= 2 * HUB_SHORT_RESET_TIME)\r\ndelay = HUB_LONG_RESET_TIME;\r\ndev_dbg (hub->intfdev,\r\n"port %d not reset yet, waiting %dms\n",\r\nport1, delay);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int hub_port_reset(struct usb_hub *hub, int port1,\r\nstruct usb_device *udev, unsigned int delay)\r\n{\r\nint i, status;\r\nstruct usb_hcd *hcd;\r\nhcd = bus_to_hcd(udev->bus);\r\ndown_read(&ehci_cf_port_reset_rwsem);\r\nfor (i = 0; i < PORT_RESET_TRIES; i++) {\r\nstatus = set_port_feature(hub->hdev,\r\nport1, USB_PORT_FEAT_RESET);\r\nif (status)\r\ndev_err(hub->intfdev,\r\n"cannot reset port %d (err = %d)\n",\r\nport1, status);\r\nelse {\r\nstatus = hub_port_wait_reset(hub, port1, udev, delay);\r\nif (status && status != -ENOTCONN)\r\ndev_dbg(hub->intfdev,\r\n"port_wait_reset: err = %d\n",\r\nstatus);\r\n}\r\nswitch (status) {\r\ncase 0:\r\nmsleep(10 + 40);\r\nupdate_devnum(udev, 0);\r\nif (hcd->driver->reset_device) {\r\nstatus = hcd->driver->reset_device(hcd, udev);\r\nif (status < 0) {\r\ndev_err(&udev->dev, "Cannot reset "\r\n"HCD device state\n");\r\nbreak;\r\n}\r\n}\r\ncase -ENOTCONN:\r\ncase -ENODEV:\r\nclear_port_feature(hub->hdev,\r\nport1, USB_PORT_FEAT_C_RESET);\r\nusb_set_device_state(udev, status\r\n? USB_STATE_NOTATTACHED\r\n: USB_STATE_DEFAULT);\r\ngoto done;\r\n}\r\ndev_dbg (hub->intfdev,\r\n"port %d not enabled, trying reset again...\n",\r\nport1);\r\ndelay = HUB_LONG_RESET_TIME;\r\n}\r\ndev_err (hub->intfdev,\r\n"Cannot enable port %i. Maybe the USB cable is bad?\n",\r\nport1);\r\ndone:\r\nup_read(&ehci_cf_port_reset_rwsem);\r\nreturn status;\r\n}\r\nstatic int hub_port_warm_reset(struct usb_hub *hub, int port)\r\n{\r\nint ret;\r\nu16 portstatus, portchange;\r\nif (!hub_is_superspeed(hub->hdev)) {\r\ndev_err(hub->intfdev, "only USB3 hub support warm reset\n");\r\nreturn -EINVAL;\r\n}\r\nret = set_port_feature(hub->hdev,\r\nport, USB_PORT_FEAT_BH_PORT_RESET);\r\nif (ret) {\r\ndev_err(hub->intfdev, "cannot warm reset port %d\n", port);\r\nreturn ret;\r\n}\r\nmsleep(20);\r\nret = hub_port_status(hub, port, &portstatus, &portchange);\r\nif (portchange & USB_PORT_STAT_C_RESET)\r\nclear_port_feature(hub->hdev, port, USB_PORT_FEAT_C_RESET);\r\nif (portchange & USB_PORT_STAT_C_BH_RESET)\r\nclear_port_feature(hub->hdev, port,\r\nUSB_PORT_FEAT_C_BH_PORT_RESET);\r\nif (portchange & USB_PORT_STAT_C_LINK_STATE)\r\nclear_port_feature(hub->hdev, port,\r\nUSB_PORT_FEAT_C_PORT_LINK_STATE);\r\nreturn ret;\r\n}\r\nstatic int port_is_power_on(struct usb_hub *hub, unsigned portstatus)\r\n{\r\nint ret = 0;\r\nif (hub_is_superspeed(hub->hdev)) {\r\nif (portstatus & USB_SS_PORT_STAT_POWER)\r\nret = 1;\r\n} else {\r\nif (portstatus & USB_PORT_STAT_POWER)\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int port_is_suspended(struct usb_hub *hub, unsigned portstatus)\r\n{\r\nint ret = 0;\r\nif (hub_is_superspeed(hub->hdev)) {\r\nif ((portstatus & USB_PORT_STAT_LINK_STATE)\r\n== USB_SS_PORT_LS_U3)\r\nret = 1;\r\n} else {\r\nif (portstatus & USB_PORT_STAT_SUSPEND)\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int check_port_resume_type(struct usb_device *udev,\r\nstruct usb_hub *hub, int port1,\r\nint status, unsigned portchange, unsigned portstatus)\r\n{\r\nif (status || port_is_suspended(hub, portstatus) ||\r\n!port_is_power_on(hub, portstatus) ||\r\n!(portstatus & USB_PORT_STAT_CONNECTION)) {\r\nif (status >= 0)\r\nstatus = -ENODEV;\r\n}\r\nelse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\r\nif (udev->persist_enabled)\r\nudev->reset_resume = 1;\r\nelse\r\nstatus = -ENODEV;\r\n}\r\nif (status) {\r\ndev_dbg(hub->intfdev,\r\n"port %d status %04x.%04x after resume, %d\n",\r\nport1, portchange, portstatus, status);\r\n} else if (udev->reset_resume) {\r\nif (portchange & USB_PORT_STAT_C_CONNECTION)\r\nclear_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_C_CONNECTION);\r\nif (portchange & USB_PORT_STAT_C_ENABLE)\r\nclear_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_C_ENABLE);\r\n}\r\nreturn status;\r\n}\r\nint usb_port_suspend(struct usb_device *udev, pm_message_t msg)\r\n{\r\nstruct usb_hub *hub = hdev_to_hub(udev->parent);\r\nint port1 = udev->portnum;\r\nint status;\r\nif (udev->do_remote_wakeup) {\r\nstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\r\nUSB_DEVICE_REMOTE_WAKEUP, 0,\r\nNULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (status) {\r\ndev_dbg(&udev->dev, "won't remote wakeup, status %d\n",\r\nstatus);\r\nif (msg.event & PM_EVENT_AUTO)\r\nreturn status;\r\n}\r\n}\r\nif (hub_is_superspeed(hub->hdev))\r\nstatus = set_port_feature(hub->hdev,\r\nport1 | (USB_SS_PORT_LS_U3 << 3),\r\nUSB_PORT_FEAT_LINK_STATE);\r\nelse\r\nstatus = set_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_SUSPEND);\r\nif (status) {\r\ndev_dbg(hub->intfdev, "can't suspend port %d, status %d\n",\r\nport1, status);\r\nif (udev->do_remote_wakeup)\r\n(void) usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\r\nUSB_DEVICE_REMOTE_WAKEUP, 0,\r\nNULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (!(msg.event & PM_EVENT_AUTO))\r\nstatus = 0;\r\n} else {\r\ndev_dbg(&udev->dev, "usb %ssuspend\n",\r\n(msg.event & PM_EVENT_AUTO ? "auto-" : ""));\r\nusb_set_device_state(udev, USB_STATE_SUSPENDED);\r\nmsleep(10);\r\n}\r\nusb_mark_last_busy(hub->hdev);\r\nreturn status;\r\n}\r\nstatic int finish_port_resume(struct usb_device *udev)\r\n{\r\nint status = 0;\r\nu16 devstatus;\r\ndev_dbg(&udev->dev, "%s\n",\r\nudev->reset_resume ? "finish reset-resume" : "finish resume");\r\nusb_set_device_state(udev, udev->actconfig\r\n? USB_STATE_CONFIGURED\r\n: USB_STATE_ADDRESS);\r\nif (udev->reset_resume)\r\nretry_reset_resume:\r\nstatus = usb_reset_and_verify_device(udev);\r\nif (status == 0) {\r\ndevstatus = 0;\r\nstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstatus);\r\nif (status >= 0)\r\nstatus = (status > 0 ? 0 : -ENODEV);\r\nif (status && !udev->reset_resume && udev->persist_enabled) {\r\ndev_dbg(&udev->dev, "retry with reset-resume\n");\r\nudev->reset_resume = 1;\r\ngoto retry_reset_resume;\r\n}\r\n}\r\nif (status) {\r\ndev_dbg(&udev->dev, "gone after usb resume? status %d\n",\r\nstatus);\r\n} else if (udev->actconfig) {\r\nle16_to_cpus(&devstatus);\r\nif (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP)) {\r\nstatus = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nUSB_REQ_CLEAR_FEATURE,\r\nUSB_RECIP_DEVICE,\r\nUSB_DEVICE_REMOTE_WAKEUP, 0,\r\nNULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (status)\r\ndev_dbg(&udev->dev,\r\n"disable remote wakeup, status %d\n",\r\nstatus);\r\n}\r\nstatus = 0;\r\n}\r\nreturn status;\r\n}\r\nint usb_port_resume(struct usb_device *udev, pm_message_t msg)\r\n{\r\nstruct usb_hub *hub = hdev_to_hub(udev->parent);\r\nint port1 = udev->portnum;\r\nint status;\r\nu16 portchange, portstatus;\r\nstatus = hub_port_status(hub, port1, &portstatus, &portchange);\r\nif (status == 0 && !port_is_suspended(hub, portstatus))\r\ngoto SuspendCleared;\r\nset_bit(port1, hub->busy_bits);\r\nif (hub_is_superspeed(hub->hdev))\r\nstatus = set_port_feature(hub->hdev,\r\nport1 | (USB_SS_PORT_LS_U0 << 3),\r\nUSB_PORT_FEAT_LINK_STATE);\r\nelse\r\nstatus = clear_port_feature(hub->hdev,\r\nport1, USB_PORT_FEAT_SUSPEND);\r\nif (status) {\r\ndev_dbg(hub->intfdev, "can't resume port %d, status %d\n",\r\nport1, status);\r\n} else {\r\ndev_dbg(&udev->dev, "usb %sresume\n",\r\n(msg.event & PM_EVENT_AUTO ? "auto-" : ""));\r\nmsleep(25);\r\nstatus = hub_port_status(hub, port1, &portstatus, &portchange);\r\nmsleep(10);\r\n}\r\nSuspendCleared:\r\nif (status == 0) {\r\nif (hub_is_superspeed(hub->hdev)) {\r\nif (portchange & USB_PORT_STAT_C_LINK_STATE)\r\nclear_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_C_PORT_LINK_STATE);\r\n} else {\r\nif (portchange & USB_PORT_STAT_C_SUSPEND)\r\nclear_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_C_SUSPEND);\r\n}\r\n}\r\nclear_bit(port1, hub->busy_bits);\r\nstatus = check_port_resume_type(udev,\r\nhub, port1, status, portchange, portstatus);\r\nif (status == 0)\r\nstatus = finish_port_resume(udev);\r\nif (status < 0) {\r\ndev_dbg(&udev->dev, "can't resume, status %d\n", status);\r\nhub_port_logical_disconnect(hub, port1);\r\n}\r\nreturn status;\r\n}\r\nint usb_remote_wakeup(struct usb_device *udev)\r\n{\r\nint status = 0;\r\nif (udev->state == USB_STATE_SUSPENDED) {\r\ndev_dbg(&udev->dev, "usb %sresume\n", "wakeup-");\r\nstatus = usb_autoresume_device(udev);\r\nif (status == 0) {\r\nusb_autosuspend_device(udev);\r\n}\r\n}\r\nreturn status;\r\n}\r\nint usb_port_suspend(struct usb_device *udev, pm_message_t msg)\r\n{\r\nreturn 0;\r\n}\r\nint usb_port_resume(struct usb_device *udev, pm_message_t msg)\r\n{\r\nstruct usb_hub *hub = hdev_to_hub(udev->parent);\r\nint port1 = udev->portnum;\r\nint status;\r\nu16 portchange, portstatus;\r\nstatus = hub_port_status(hub, port1, &portstatus, &portchange);\r\nstatus = check_port_resume_type(udev,\r\nhub, port1, status, portchange, portstatus);\r\nif (status) {\r\ndev_dbg(&udev->dev, "can't resume, status %d\n", status);\r\nhub_port_logical_disconnect(hub, port1);\r\n} else if (udev->reset_resume) {\r\ndev_dbg(&udev->dev, "reset-resume\n");\r\nstatus = usb_reset_and_verify_device(udev);\r\n}\r\nreturn status;\r\n}\r\nstatic int hub_suspend(struct usb_interface *intf, pm_message_t msg)\r\n{\r\nstruct usb_hub *hub = usb_get_intfdata (intf);\r\nstruct usb_device *hdev = hub->hdev;\r\nunsigned port1;\r\nfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\r\nstruct usb_device *udev;\r\nudev = hdev->children [port1-1];\r\nif (udev && udev->can_submit) {\r\ndev_warn(&intf->dev, "port %d nyet suspended\n", port1);\r\nif (msg.event & PM_EVENT_AUTO)\r\nreturn -EBUSY;\r\n}\r\n}\r\ndev_dbg(&intf->dev, "%s\n", __func__);\r\nhub_quiesce(hub, HUB_SUSPEND);\r\nreturn 0;\r\n}\r\nstatic int hub_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_hub *hub = usb_get_intfdata(intf);\r\ndev_dbg(&intf->dev, "%s\n", __func__);\r\nhub_activate(hub, HUB_RESUME);\r\nreturn 0;\r\n}\r\nstatic int hub_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_hub *hub = usb_get_intfdata(intf);\r\ndev_dbg(&intf->dev, "%s\n", __func__);\r\nhub_activate(hub, HUB_RESET_RESUME);\r\nreturn 0;\r\n}\r\nvoid usb_root_hub_lost_power(struct usb_device *rhdev)\r\n{\r\ndev_warn(&rhdev->dev, "root hub lost power or was reset\n");\r\nrhdev->reset_resume = 1;\r\n}\r\nstatic int hub_port_debounce(struct usb_hub *hub, int port1)\r\n{\r\nint ret;\r\nint total_time, stable_time = 0;\r\nu16 portchange, portstatus;\r\nunsigned connection = 0xffff;\r\nfor (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {\r\nret = hub_port_status(hub, port1, &portstatus, &portchange);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(portchange & USB_PORT_STAT_C_CONNECTION) &&\r\n(portstatus & USB_PORT_STAT_CONNECTION) == connection) {\r\nstable_time += HUB_DEBOUNCE_STEP;\r\nif (stable_time >= HUB_DEBOUNCE_STABLE)\r\nbreak;\r\n} else {\r\nstable_time = 0;\r\nconnection = portstatus & USB_PORT_STAT_CONNECTION;\r\n}\r\nif (portchange & USB_PORT_STAT_C_CONNECTION) {\r\nclear_port_feature(hub->hdev, port1,\r\nUSB_PORT_FEAT_C_CONNECTION);\r\n}\r\nif (total_time >= HUB_DEBOUNCE_TIMEOUT)\r\nbreak;\r\nmsleep(HUB_DEBOUNCE_STEP);\r\n}\r\ndev_dbg (hub->intfdev,\r\n"debounce: port %d: total %dms stable %dms status 0x%x\n",\r\nport1, total_time, stable_time, portstatus);\r\nif (stable_time < HUB_DEBOUNCE_STABLE)\r\nreturn -ETIMEDOUT;\r\nreturn portstatus;\r\n}\r\nvoid usb_ep0_reinit(struct usb_device *udev)\r\n{\r\nusb_disable_endpoint(udev, 0 + USB_DIR_IN, true);\r\nusb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);\r\nusb_enable_endpoint(udev, &udev->ep0, true);\r\n}\r\nstatic int hub_set_address(struct usb_device *udev, int devnum)\r\n{\r\nint retval;\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nif (!hcd->driver->address_device && devnum <= 1)\r\nreturn -EINVAL;\r\nif (udev->state == USB_STATE_ADDRESS)\r\nreturn 0;\r\nif (udev->state != USB_STATE_DEFAULT)\r\nreturn -EINVAL;\r\nif (hcd->driver->address_device)\r\nretval = hcd->driver->address_device(hcd, udev);\r\nelse\r\nretval = usb_control_msg(udev, usb_sndaddr0pipe(),\r\nUSB_REQ_SET_ADDRESS, 0, devnum, 0,\r\nNULL, 0, USB_CTRL_SET_TIMEOUT);\r\nif (retval == 0) {\r\nupdate_devnum(udev, devnum);\r\nusb_set_device_state(udev, USB_STATE_ADDRESS);\r\nusb_ep0_reinit(udev);\r\n}\r\nreturn retval;\r\n}\r\nstatic int\r\nhub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,\r\nint retry_counter)\r\n{\r\nstatic DEFINE_MUTEX(usb_address0_mutex);\r\nstruct usb_device *hdev = hub->hdev;\r\nstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\r\nint i, j, retval;\r\nunsigned delay = HUB_SHORT_RESET_TIME;\r\nenum usb_device_speed oldspeed = udev->speed;\r\nchar *speed, *type;\r\nint devnum = udev->devnum;\r\nif (!hdev->parent) {\r\ndelay = HUB_ROOT_RESET_TIME;\r\nif (port1 == hdev->bus->otg_port)\r\nhdev->bus->b_hnp_enable = 0;\r\n}\r\nif (oldspeed == USB_SPEED_LOW)\r\ndelay = HUB_LONG_RESET_TIME;\r\nmutex_lock(&usb_address0_mutex);\r\nretval = hub_port_reset(hub, port1, udev, delay);\r\nif (retval < 0)\r\ngoto fail;\r\nretval = -ENODEV;\r\nif (oldspeed != USB_SPEED_UNKNOWN && oldspeed != udev->speed) {\r\ndev_dbg(&udev->dev, "device reset changed speed!\n");\r\ngoto fail;\r\n}\r\noldspeed = udev->speed;\r\nswitch (udev->speed) {\r\ncase USB_SPEED_SUPER:\r\ncase USB_SPEED_WIRELESS:\r\nudev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\r\nbreak;\r\ncase USB_SPEED_LOW:\r\nudev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\ntype = "";\r\nswitch (udev->speed) {\r\ncase USB_SPEED_LOW: speed = "low"; break;\r\ncase USB_SPEED_FULL: speed = "full"; break;\r\ncase USB_SPEED_HIGH: speed = "high"; break;\r\ncase USB_SPEED_SUPER:\r\nspeed = "super";\r\nbreak;\r\ncase USB_SPEED_WIRELESS:\r\nspeed = "variable";\r\ntype = "Wireless ";\r\nbreak;\r\ndefault: speed = "?"; break;\r\n}\r\nif (udev->speed != USB_SPEED_SUPER)\r\ndev_info(&udev->dev,\r\n"%s %s speed %sUSB device number %d using %s\n",\r\n(udev->config) ? "reset" : "new", speed, type,\r\ndevnum, udev->bus->controller->driver->name);\r\nif (hdev->tt) {\r\nudev->tt = hdev->tt;\r\nudev->ttport = hdev->ttport;\r\n} else if (udev->speed != USB_SPEED_HIGH\r\n&& hdev->speed == USB_SPEED_HIGH) {\r\nif (!hub->tt.hub) {\r\ndev_err(&udev->dev, "parent hub has no TT\n");\r\nretval = -EINVAL;\r\ngoto fail;\r\n}\r\nudev->tt = &hub->tt;\r\nudev->ttport = port1;\r\n}\r\nfor (i = 0; i < GET_DESCRIPTOR_TRIES; (++i, msleep(100))) {\r\nif (USE_NEW_SCHEME(retry_counter) && !(hcd->driver->flags & HCD_USB3)) {\r\nstruct usb_device_descriptor *buf;\r\nint r = 0;\r\n#define GET_DESCRIPTOR_BUFSIZE 64\r\nbuf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);\r\nif (!buf) {\r\nretval = -ENOMEM;\r\ncontinue;\r\n}\r\nfor (j = 0; j < 3; ++j) {\r\nbuf->bMaxPacketSize0 = 0;\r\nr = usb_control_msg(udev, usb_rcvaddr0pipe(),\r\nUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\r\nUSB_DT_DEVICE << 8, 0,\r\nbuf, GET_DESCRIPTOR_BUFSIZE,\r\ninitial_descriptor_timeout);\r\nswitch (buf->bMaxPacketSize0) {\r\ncase 8: case 16: case 32: case 64: case 255:\r\nif (buf->bDescriptorType ==\r\nUSB_DT_DEVICE) {\r\nr = 0;\r\nbreak;\r\n}\r\ndefault:\r\nif (r == 0)\r\nr = -EPROTO;\r\nbreak;\r\n}\r\nif (r == 0)\r\nbreak;\r\n}\r\nudev->descriptor.bMaxPacketSize0 =\r\nbuf->bMaxPacketSize0;\r\nkfree(buf);\r\nretval = hub_port_reset(hub, port1, udev, delay);\r\nif (retval < 0)\r\ngoto fail;\r\nif (oldspeed != udev->speed) {\r\ndev_dbg(&udev->dev,\r\n"device reset changed speed!\n");\r\nretval = -ENODEV;\r\ngoto fail;\r\n}\r\nif (r) {\r\ndev_err(&udev->dev,\r\n"device descriptor read/64, error %d\n",\r\nr);\r\nretval = -EMSGSIZE;\r\ncontinue;\r\n}\r\n#undef GET_DESCRIPTOR_BUFSIZE\r\n}\r\nif (udev->wusb == 0) {\r\nfor (j = 0; j < SET_ADDRESS_TRIES; ++j) {\r\nretval = hub_set_address(udev, devnum);\r\nif (retval >= 0)\r\nbreak;\r\nmsleep(200);\r\n}\r\nif (retval < 0) {\r\ndev_err(&udev->dev,\r\n"device not accepting address %d, error %d\n",\r\ndevnum, retval);\r\ngoto fail;\r\n}\r\nif (udev->speed == USB_SPEED_SUPER) {\r\ndevnum = udev->devnum;\r\ndev_info(&udev->dev,\r\n"%s SuperSpeed USB device number %d using %s\n",\r\n(udev->config) ? "reset" : "new",\r\ndevnum, udev->bus->controller->driver->name);\r\n}\r\nmsleep(10);\r\nif (USE_NEW_SCHEME(retry_counter) && !(hcd->driver->flags & HCD_USB3))\r\nbreak;\r\n}\r\nretval = usb_get_device_descriptor(udev, 8);\r\nif (retval < 8) {\r\ndev_err(&udev->dev,\r\n"device descriptor read/8, error %d\n",\r\nretval);\r\nif (retval >= 0)\r\nretval = -EMSGSIZE;\r\n} else {\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\nif (retval)\r\ngoto fail;\r\nif (udev->descriptor.bMaxPacketSize0 == 0xff ||\r\nudev->speed == USB_SPEED_SUPER)\r\ni = 512;\r\nelse\r\ni = udev->descriptor.bMaxPacketSize0;\r\nif (le16_to_cpu(udev->ep0.desc.wMaxPacketSize) != i) {\r\nif (udev->speed == USB_SPEED_LOW ||\r\n!(i == 8 || i == 16 || i == 32 || i == 64)) {\r\ndev_err(&udev->dev, "Invalid ep0 maxpacket: %d\n", i);\r\nretval = -EMSGSIZE;\r\ngoto fail;\r\n}\r\nif (udev->speed == USB_SPEED_FULL)\r\ndev_dbg(&udev->dev, "ep0 maxpacket = %d\n", i);\r\nelse\r\ndev_warn(&udev->dev, "Using ep0 maxpacket: %d\n", i);\r\nudev->ep0.desc.wMaxPacketSize = cpu_to_le16(i);\r\nusb_ep0_reinit(udev);\r\n}\r\nretval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);\r\nif (retval < (signed)sizeof(udev->descriptor)) {\r\ndev_err(&udev->dev, "device descriptor read/all, error %d\n",\r\nretval);\r\nif (retval >= 0)\r\nretval = -ENOMSG;\r\ngoto fail;\r\n}\r\nretval = 0;\r\nif (hcd->driver->update_device)\r\nhcd->driver->update_device(hcd, udev);\r\nfail:\r\nif (retval) {\r\nhub_port_disable(hub, port1, 0);\r\nupdate_devnum(udev, devnum);\r\n}\r\nmutex_unlock(&usb_address0_mutex);\r\nreturn retval;\r\n}\r\nstatic void\r\ncheck_highspeed (struct usb_hub *hub, struct usb_device *udev, int port1)\r\n{\r\nstruct usb_qualifier_descriptor *qual;\r\nint status;\r\nqual = kmalloc (sizeof *qual, GFP_KERNEL);\r\nif (qual == NULL)\r\nreturn;\r\nstatus = usb_get_descriptor (udev, USB_DT_DEVICE_QUALIFIER, 0,\r\nqual, sizeof *qual);\r\nif (status == sizeof *qual) {\r\ndev_info(&udev->dev, "not running at top speed; "\r\n"connect to a high speed hub\n");\r\nif (hub->has_indicators) {\r\nhub->indicator[port1-1] = INDICATOR_GREEN_BLINK;\r\nschedule_delayed_work (&hub->leds, 0);\r\n}\r\n}\r\nkfree(qual);\r\n}\r\nstatic unsigned\r\nhub_power_remaining (struct usb_hub *hub)\r\n{\r\nstruct usb_device *hdev = hub->hdev;\r\nint remaining;\r\nint port1;\r\nif (!hub->limited_power)\r\nreturn 0;\r\nremaining = hdev->bus_mA - hub->descriptor->bHubContrCurrent;\r\nfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\r\nstruct usb_device *udev = hdev->children[port1 - 1];\r\nint delta;\r\nif (!udev)\r\ncontinue;\r\nif (udev->actconfig)\r\ndelta = udev->actconfig->desc.bMaxPower * 2;\r\nelse if (port1 != udev->bus->otg_port || hdev->parent)\r\ndelta = 100;\r\nelse\r\ndelta = 8;\r\nif (delta > hub->mA_per_port)\r\ndev_warn(&udev->dev,\r\n"%dmA is over %umA budget for port %d!\n",\r\ndelta, hub->mA_per_port, port1);\r\nremaining -= delta;\r\n}\r\nif (remaining < 0) {\r\ndev_warn(hub->intfdev, "%dmA over power budget!\n",\r\n- remaining);\r\nremaining = 0;\r\n}\r\nreturn remaining;\r\n}\r\nstatic void hub_port_connect_change(struct usb_hub *hub, int port1,\r\nu16 portstatus, u16 portchange)\r\n{\r\nstruct usb_device *hdev = hub->hdev;\r\nstruct device *hub_dev = hub->intfdev;\r\nstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\r\nunsigned wHubCharacteristics =\r\nle16_to_cpu(hub->descriptor->wHubCharacteristics);\r\nstruct usb_device *udev;\r\nint status, i;\r\ndev_dbg (hub_dev,\r\n"port %d, status %04x, change %04x, %s\n",\r\nport1, portstatus, portchange, portspeed(hub, portstatus));\r\nif (hub->has_indicators) {\r\nset_port_led(hub, port1, HUB_LED_AUTO);\r\nhub->indicator[port1-1] = INDICATOR_AUTO;\r\n}\r\n#ifdef CONFIG_USB_OTG\r\nif (hdev->bus->is_b_host)\r\nportchange &= ~(USB_PORT_STAT_C_CONNECTION |\r\nUSB_PORT_STAT_C_ENABLE);\r\n#endif\r\nudev = hdev->children[port1-1];\r\nif ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&\r\nudev->state != USB_STATE_NOTATTACHED) {\r\nusb_lock_device(udev);\r\nif (portstatus & USB_PORT_STAT_ENABLE) {\r\nstatus = 0;\r\n#ifdef CONFIG_USB_SUSPEND\r\n} else if (udev->state == USB_STATE_SUSPENDED &&\r\nudev->persist_enabled) {\r\nstatus = usb_remote_wakeup(udev);\r\n#endif\r\n} else {\r\nstatus = -ENODEV;\r\n}\r\nusb_unlock_device(udev);\r\nif (status == 0) {\r\nclear_bit(port1, hub->change_bits);\r\nreturn;\r\n}\r\n}\r\nif (udev)\r\nusb_disconnect(&hdev->children[port1-1]);\r\nclear_bit(port1, hub->change_bits);\r\nif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\r\n(portchange & USB_PORT_STAT_C_CONNECTION))\r\nclear_bit(port1, hub->removed_bits);\r\nif (portchange & (USB_PORT_STAT_C_CONNECTION |\r\nUSB_PORT_STAT_C_ENABLE)) {\r\nstatus = hub_port_debounce(hub, port1);\r\nif (status < 0) {\r\nif (printk_ratelimit())\r\ndev_err(hub_dev, "connect-debounce failed, "\r\n"port %d disabled\n", port1);\r\nportstatus &= ~USB_PORT_STAT_CONNECTION;\r\n} else {\r\nportstatus = status;\r\n}\r\n}\r\nif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\r\ntest_bit(port1, hub->removed_bits)) {\r\nif ((wHubCharacteristics & HUB_CHAR_LPSM) < 2\r\n&& !port_is_power_on(hub, portstatus))\r\nset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\r\nif (portstatus & USB_PORT_STAT_ENABLE)\r\ngoto done;\r\nreturn;\r\n}\r\nfor (i = 0; i < SET_CONFIG_TRIES; i++) {\r\nudev = usb_alloc_dev(hdev, hdev->bus, port1);\r\nif (!udev) {\r\ndev_err (hub_dev,\r\n"couldn't allocate port %d usb_device\n",\r\nport1);\r\ngoto done;\r\n}\r\nusb_set_device_state(udev, USB_STATE_POWERED);\r\nudev->bus_mA = hub->mA_per_port;\r\nudev->level = hdev->level + 1;\r\nudev->wusb = hub_is_wusb(hub);\r\nif (hub_is_superspeed(hub->hdev))\r\nudev->speed = USB_SPEED_SUPER;\r\nelse\r\nudev->speed = USB_SPEED_UNKNOWN;\r\nchoose_devnum(udev);\r\nif (udev->devnum <= 0) {\r\nstatus = -ENOTCONN;\r\ngoto loop;\r\n}\r\nstatus = hub_port_init(hub, udev, port1, i);\r\nif (status < 0)\r\ngoto loop;\r\nusb_detect_quirks(udev);\r\nif (udev->quirks & USB_QUIRK_DELAY_INIT)\r\nmsleep(1000);\r\nif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\r\n&& udev->bus_mA <= 100) {\r\nu16 devstat;\r\nstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0,\r\n&devstat);\r\nif (status < 2) {\r\ndev_dbg(&udev->dev, "get status %d ?\n", status);\r\ngoto loop_disable;\r\n}\r\nle16_to_cpus(&devstat);\r\nif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\r\ndev_err(&udev->dev,\r\n"can't connect bus-powered hub "\r\n"to this port\n");\r\nif (hub->has_indicators) {\r\nhub->indicator[port1-1] =\r\nINDICATOR_AMBER_BLINK;\r\nschedule_delayed_work (&hub->leds, 0);\r\n}\r\nstatus = -ENOTCONN;\r\ngoto loop_disable;\r\n}\r\n}\r\nif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\r\n&& udev->speed == USB_SPEED_FULL\r\n&& highspeed_hubs != 0)\r\ncheck_highspeed (hub, udev, port1);\r\nstatus = 0;\r\nspin_lock_irq(&device_state_lock);\r\nif (hdev->state == USB_STATE_NOTATTACHED)\r\nstatus = -ENOTCONN;\r\nelse\r\nhdev->children[port1-1] = udev;\r\nspin_unlock_irq(&device_state_lock);\r\nif (!status) {\r\nstatus = usb_new_device(udev);\r\nif (status) {\r\nspin_lock_irq(&device_state_lock);\r\nhdev->children[port1-1] = NULL;\r\nspin_unlock_irq(&device_state_lock);\r\n}\r\n}\r\nif (status)\r\ngoto loop_disable;\r\nstatus = hub_power_remaining(hub);\r\nif (status)\r\ndev_dbg(hub_dev, "%dmA power budget left\n", status);\r\nreturn;\r\nloop_disable:\r\nhub_port_disable(hub, port1, 1);\r\nloop:\r\nusb_ep0_reinit(udev);\r\nrelease_devnum(udev);\r\nhub_free_dev(udev);\r\nusb_put_dev(udev);\r\nif ((status == -ENOTCONN) || (status == -ENOTSUPP))\r\nbreak;\r\n}\r\nif (hub->hdev->parent ||\r\n!hcd->driver->port_handed_over ||\r\n!(hcd->driver->port_handed_over)(hcd, port1))\r\ndev_err(hub_dev, "unable to enumerate USB device on port %d\n",\r\nport1);\r\ndone:\r\nhub_port_disable(hub, port1, 1);\r\nif (hcd->driver->relinquish_port && !hub->hdev->parent)\r\nhcd->driver->relinquish_port(hcd, port1);\r\n}\r\nstatic void hub_events(void)\r\n{\r\nstruct list_head *tmp;\r\nstruct usb_device *hdev;\r\nstruct usb_interface *intf;\r\nstruct usb_hub *hub;\r\nstruct device *hub_dev;\r\nu16 hubstatus;\r\nu16 hubchange;\r\nu16 portstatus;\r\nu16 portchange;\r\nint i, ret;\r\nint connect_change;\r\nwhile (1) {\r\nspin_lock_irq(&hub_event_lock);\r\nif (list_empty(&hub_event_list)) {\r\nspin_unlock_irq(&hub_event_lock);\r\nbreak;\r\n}\r\ntmp = hub_event_list.next;\r\nlist_del_init(tmp);\r\nhub = list_entry(tmp, struct usb_hub, event_list);\r\nkref_get(&hub->kref);\r\nspin_unlock_irq(&hub_event_lock);\r\nhdev = hub->hdev;\r\nhub_dev = hub->intfdev;\r\nintf = to_usb_interface(hub_dev);\r\ndev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",\r\nhdev->state, hub->descriptor\r\n? hub->descriptor->bNbrPorts\r\n: 0,\r\n(u16) hub->change_bits[0],\r\n(u16) hub->event_bits[0]);\r\nusb_lock_device(hdev);\r\nif (unlikely(hub->disconnected))\r\ngoto loop_disconnected;\r\nif (hdev->state == USB_STATE_NOTATTACHED) {\r\nhub->error = -ENODEV;\r\nhub_quiesce(hub, HUB_DISCONNECT);\r\ngoto loop;\r\n}\r\nret = usb_autopm_get_interface(intf);\r\nif (ret) {\r\ndev_dbg(hub_dev, "Can't autoresume: %d\n", ret);\r\ngoto loop;\r\n}\r\nif (hub->quiescing)\r\ngoto loop_autopm;\r\nif (hub->error) {\r\ndev_dbg (hub_dev, "resetting for error %d\n",\r\nhub->error);\r\nret = usb_reset_device(hdev);\r\nif (ret) {\r\ndev_dbg (hub_dev,\r\n"error resetting hub: %d\n", ret);\r\ngoto loop_autopm;\r\n}\r\nhub->nerrors = 0;\r\nhub->error = 0;\r\n}\r\nfor (i = 1; i <= hub->descriptor->bNbrPorts; i++) {\r\nif (test_bit(i, hub->busy_bits))\r\ncontinue;\r\nconnect_change = test_bit(i, hub->change_bits);\r\nif (!test_and_clear_bit(i, hub->event_bits) &&\r\n!connect_change)\r\ncontinue;\r\nret = hub_port_status(hub, i,\r\n&portstatus, &portchange);\r\nif (ret < 0)\r\ncontinue;\r\nif (portchange & USB_PORT_STAT_C_CONNECTION) {\r\nclear_port_feature(hdev, i,\r\nUSB_PORT_FEAT_C_CONNECTION);\r\nconnect_change = 1;\r\n}\r\nif (portchange & USB_PORT_STAT_C_ENABLE) {\r\nif (!connect_change)\r\ndev_dbg (hub_dev,\r\n"port %d enable change, "\r\n"status %08x\n",\r\ni, portstatus);\r\nclear_port_feature(hdev, i,\r\nUSB_PORT_FEAT_C_ENABLE);\r\nif (!(portstatus & USB_PORT_STAT_ENABLE)\r\n&& !connect_change\r\n&& hdev->children[i-1]) {\r\ndev_err (hub_dev,\r\n"port %i "\r\n"disabled by hub (EMI?), "\r\n"re-enabling...\n",\r\ni);\r\nconnect_change = 1;\r\n}\r\n}\r\nif (portchange & USB_PORT_STAT_C_SUSPEND) {\r\nstruct usb_device *udev;\r\nclear_port_feature(hdev, i,\r\nUSB_PORT_FEAT_C_SUSPEND);\r\nudev = hdev->children[i-1];\r\nif (udev) {\r\nmsleep(10);\r\nusb_lock_device(udev);\r\nret = usb_remote_wakeup(hdev->\r\nchildren[i-1]);\r\nusb_unlock_device(udev);\r\nif (ret < 0)\r\nconnect_change = 1;\r\n} else {\r\nret = -ENODEV;\r\nhub_port_disable(hub, i, 1);\r\n}\r\ndev_dbg (hub_dev,\r\n"resume on port %d, status %d\n",\r\ni, ret);\r\n}\r\nif (portchange & USB_PORT_STAT_C_OVERCURRENT) {\r\nu16 status = 0;\r\nu16 unused;\r\ndev_dbg(hub_dev, "over-current change on port "\r\n"%d\n", i);\r\nclear_port_feature(hdev, i,\r\nUSB_PORT_FEAT_C_OVER_CURRENT);\r\nmsleep(100);\r\nhub_power_on(hub, true);\r\nhub_port_status(hub, i, &status, &unused);\r\nif (status & USB_PORT_STAT_OVERCURRENT)\r\ndev_err(hub_dev, "over-current "\r\n"condition on port %d\n", i);\r\n}\r\nif (portchange & USB_PORT_STAT_C_RESET) {\r\ndev_dbg (hub_dev,\r\n"reset change on port %d\n",\r\ni);\r\nclear_port_feature(hdev, i,\r\nUSB_PORT_FEAT_C_RESET);\r\n}\r\nif ((portchange & USB_PORT_STAT_C_BH_RESET) &&\r\nhub_is_superspeed(hub->hdev)) {\r\ndev_dbg(hub_dev,\r\n"warm reset change on port %d\n",\r\ni);\r\nclear_port_feature(hdev, i,\r\nUSB_PORT_FEAT_C_BH_PORT_RESET);\r\n}\r\nif (portchange & USB_PORT_STAT_C_LINK_STATE) {\r\nclear_port_feature(hub->hdev, i,\r\nUSB_PORT_FEAT_C_PORT_LINK_STATE);\r\n}\r\nif (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {\r\ndev_warn(hub_dev,\r\n"config error on port %d\n",\r\ni);\r\nclear_port_feature(hub->hdev, i,\r\nUSB_PORT_FEAT_C_PORT_CONFIG_ERROR);\r\n}\r\nif (hub_is_superspeed(hub->hdev) &&\r\n(portstatus & USB_PORT_STAT_LINK_STATE)\r\n== USB_SS_PORT_LS_SS_INACTIVE) {\r\ndev_dbg(hub_dev, "warm reset port %d\n", i);\r\nhub_port_warm_reset(hub, i);\r\n}\r\nif (connect_change)\r\nhub_port_connect_change(hub, i,\r\nportstatus, portchange);\r\n}\r\nif (test_and_clear_bit(0, hub->event_bits) == 0)\r\n;\r\nelse if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)\r\ndev_err (hub_dev, "get_hub_status failed\n");\r\nelse {\r\nif (hubchange & HUB_CHANGE_LOCAL_POWER) {\r\ndev_dbg (hub_dev, "power change\n");\r\nclear_hub_feature(hdev, C_HUB_LOCAL_POWER);\r\nif (hubstatus & HUB_STATUS_LOCAL_POWER)\r\nhub->limited_power = 1;\r\nelse\r\nhub->limited_power = 0;\r\n}\r\nif (hubchange & HUB_CHANGE_OVERCURRENT) {\r\nu16 status = 0;\r\nu16 unused;\r\ndev_dbg(hub_dev, "over-current change\n");\r\nclear_hub_feature(hdev, C_HUB_OVER_CURRENT);\r\nmsleep(500);\r\nhub_power_on(hub, true);\r\nhub_hub_status(hub, &status, &unused);\r\nif (status & HUB_STATUS_OVERCURRENT)\r\ndev_err(hub_dev, "over-current "\r\n"condition\n");\r\n}\r\n}\r\nloop_autopm:\r\nusb_autopm_put_interface_no_suspend(intf);\r\nloop:\r\nusb_autopm_put_interface(intf);\r\nloop_disconnected:\r\nusb_unlock_device(hdev);\r\nkref_put(&hub->kref, hub_release);\r\n}\r\n}\r\nstatic int hub_thread(void *__unused)\r\n{\r\nset_freezable();\r\ndo {\r\nhub_events();\r\nwait_event_freezable(khubd_wait,\r\n!list_empty(&hub_event_list) ||\r\nkthread_should_stop());\r\n} while (!kthread_should_stop() || !list_empty(&hub_event_list));\r\npr_debug("%s: khubd exiting\n", usbcore_name);\r\nreturn 0;\r\n}\r\nint usb_hub_init(void)\r\n{\r\nif (usb_register(&hub_driver) < 0) {\r\nprintk(KERN_ERR "%s: can't register hub driver\n",\r\nusbcore_name);\r\nreturn -1;\r\n}\r\nkhubd_task = kthread_run(hub_thread, NULL, "khubd");\r\nif (!IS_ERR(khubd_task))\r\nreturn 0;\r\nusb_deregister(&hub_driver);\r\nprintk(KERN_ERR "%s: can't start khubd\n", usbcore_name);\r\nreturn -1;\r\n}\r\nvoid usb_hub_cleanup(void)\r\n{\r\nkthread_stop(khubd_task);\r\nusb_deregister(&hub_driver);\r\n}\r\nstatic int descriptors_changed(struct usb_device *udev,\r\nstruct usb_device_descriptor *old_device_descriptor)\r\n{\r\nint changed = 0;\r\nunsigned index;\r\nunsigned serial_len = 0;\r\nunsigned len;\r\nunsigned old_length;\r\nint length;\r\nchar *buf;\r\nif (memcmp(&udev->descriptor, old_device_descriptor,\r\nsizeof(*old_device_descriptor)) != 0)\r\nreturn 1;\r\nif (udev->serial)\r\nserial_len = strlen(udev->serial) + 1;\r\nlen = serial_len;\r\nfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\r\nold_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\r\nlen = max(len, old_length);\r\n}\r\nbuf = kmalloc(len, GFP_NOIO);\r\nif (buf == NULL) {\r\ndev_err(&udev->dev, "no mem to re-read configs after reset\n");\r\nreturn 1;\r\n}\r\nfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\r\nold_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\r\nlength = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,\r\nold_length);\r\nif (length != old_length) {\r\ndev_dbg(&udev->dev, "config index %d, error %d\n",\r\nindex, length);\r\nchanged = 1;\r\nbreak;\r\n}\r\nif (memcmp (buf, udev->rawdescriptors[index], old_length)\r\n!= 0) {\r\ndev_dbg(&udev->dev, "config index %d changed (#%d)\n",\r\nindex,\r\n((struct usb_config_descriptor *) buf)->\r\nbConfigurationValue);\r\nchanged = 1;\r\nbreak;\r\n}\r\n}\r\nif (!changed && serial_len) {\r\nlength = usb_string(udev, udev->descriptor.iSerialNumber,\r\nbuf, serial_len);\r\nif (length + 1 != serial_len) {\r\ndev_dbg(&udev->dev, "serial string error %d\n",\r\nlength);\r\nchanged = 1;\r\n} else if (memcmp(buf, udev->serial, length) != 0) {\r\ndev_dbg(&udev->dev, "serial string changed\n");\r\nchanged = 1;\r\n}\r\n}\r\nkfree(buf);\r\nreturn changed;\r\n}\r\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\r\n{\r\nstruct usb_device *parent_hdev = udev->parent;\r\nstruct usb_hub *parent_hub;\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nstruct usb_device_descriptor descriptor = udev->descriptor;\r\nint i, ret = 0;\r\nint port1 = udev->portnum;\r\nif (udev->state == USB_STATE_NOTATTACHED ||\r\nudev->state == USB_STATE_SUSPENDED) {\r\ndev_dbg(&udev->dev, "device reset not allowed in state %d\n",\r\nudev->state);\r\nreturn -EINVAL;\r\n}\r\nif (!parent_hdev) {\r\ndev_dbg(&udev->dev, "%s for root hub!\n", __func__);\r\nreturn -EISDIR;\r\n}\r\nparent_hub = hdev_to_hub(parent_hdev);\r\nset_bit(port1, parent_hub->busy_bits);\r\nfor (i = 0; i < SET_CONFIG_TRIES; ++i) {\r\nusb_ep0_reinit(udev);\r\nret = hub_port_init(parent_hub, udev, port1, i);\r\nif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\r\nbreak;\r\n}\r\nclear_bit(port1, parent_hub->busy_bits);\r\nif (ret < 0)\r\ngoto re_enumerate;\r\nif (descriptors_changed(udev, &descriptor)) {\r\ndev_info(&udev->dev, "device firmware changed\n");\r\nudev->descriptor = descriptor;\r\ngoto re_enumerate;\r\n}\r\nif (!udev->actconfig)\r\ngoto done;\r\nmutex_lock(hcd->bandwidth_mutex);\r\nret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\r\nif (ret < 0) {\r\ndev_warn(&udev->dev,\r\n"Busted HC? Not enough HCD resources for "\r\n"old configuration.\n");\r\nmutex_unlock(hcd->bandwidth_mutex);\r\ngoto re_enumerate;\r\n}\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nUSB_REQ_SET_CONFIGURATION, 0,\r\nudev->actconfig->desc.bConfigurationValue, 0,\r\nNULL, 0, USB_CTRL_SET_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(&udev->dev,\r\n"can't restore configuration #%d (error=%d)\n",\r\nudev->actconfig->desc.bConfigurationValue, ret);\r\nmutex_unlock(hcd->bandwidth_mutex);\r\ngoto re_enumerate;\r\n}\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nusb_set_device_state(udev, USB_STATE_CONFIGURED);\r\nfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\r\nstruct usb_host_config *config = udev->actconfig;\r\nstruct usb_interface *intf = config->interface[i];\r\nstruct usb_interface_descriptor *desc;\r\ndesc = &intf->cur_altsetting->desc;\r\nif (desc->bAlternateSetting == 0) {\r\nusb_disable_interface(udev, intf, true);\r\nusb_enable_interface(udev, intf, true);\r\nret = 0;\r\n} else {\r\nintf->resetting_device = 1;\r\nret = usb_set_interface(udev, desc->bInterfaceNumber,\r\ndesc->bAlternateSetting);\r\nintf->resetting_device = 0;\r\n}\r\nif (ret < 0) {\r\ndev_err(&udev->dev, "failed to restore interface %d "\r\n"altsetting %d (error=%d)\n",\r\ndesc->bInterfaceNumber,\r\ndesc->bAlternateSetting,\r\nret);\r\ngoto re_enumerate;\r\n}\r\n}\r\ndone:\r\nreturn 0;\r\nre_enumerate:\r\nhub_port_logical_disconnect(parent_hub, port1);\r\nreturn -ENODEV;\r\n}\r\nint usb_reset_device(struct usb_device *udev)\r\n{\r\nint ret;\r\nint i;\r\nstruct usb_host_config *config = udev->actconfig;\r\nif (udev->state == USB_STATE_NOTATTACHED ||\r\nudev->state == USB_STATE_SUSPENDED) {\r\ndev_dbg(&udev->dev, "device reset not allowed in state %d\n",\r\nudev->state);\r\nreturn -EINVAL;\r\n}\r\nusb_autoresume_device(udev);\r\nif (config) {\r\nfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\r\nstruct usb_interface *cintf = config->interface[i];\r\nstruct usb_driver *drv;\r\nint unbind = 0;\r\nif (cintf->dev.driver) {\r\ndrv = to_usb_driver(cintf->dev.driver);\r\nif (drv->pre_reset && drv->post_reset)\r\nunbind = (drv->pre_reset)(cintf);\r\nelse if (cintf->condition ==\r\nUSB_INTERFACE_BOUND)\r\nunbind = 1;\r\nif (unbind)\r\nusb_forced_unbind_intf(cintf);\r\n}\r\n}\r\n}\r\nret = usb_reset_and_verify_device(udev);\r\nif (config) {\r\nfor (i = config->desc.bNumInterfaces - 1; i >= 0; --i) {\r\nstruct usb_interface *cintf = config->interface[i];\r\nstruct usb_driver *drv;\r\nint rebind = cintf->needs_binding;\r\nif (!rebind && cintf->dev.driver) {\r\ndrv = to_usb_driver(cintf->dev.driver);\r\nif (drv->post_reset)\r\nrebind = (drv->post_reset)(cintf);\r\nelse if (cintf->condition ==\r\nUSB_INTERFACE_BOUND)\r\nrebind = 1;\r\n}\r\nif (ret == 0 && rebind)\r\nusb_rebind_intf(cintf);\r\n}\r\n}\r\nusb_autosuspend_device(udev);\r\nreturn ret;\r\n}\r\nvoid usb_queue_reset_device(struct usb_interface *iface)\r\n{\r\nschedule_work(&iface->reset_ws);\r\n}
