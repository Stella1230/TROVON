static int r8192_wx_get_freq(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nreturn ieee80211_wx_get_freq(priv->ieee80211,a,wrqu,b);\r\n}\r\nstatic int r8192_wx_get_mode(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv=ieee80211_priv(dev);\r\nreturn ieee80211_wx_get_mode(priv->ieee80211,a,wrqu,b);\r\n}\r\nstatic int r8192_wx_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nreturn ieee80211_wx_get_rate(priv->ieee80211,info,wrqu,extra);\r\n}\r\nstatic int r8192_wx_set_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_set_rate(priv->ieee80211,info,wrqu,extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_set_rts(priv->ieee80211,info,wrqu,extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nreturn ieee80211_wx_get_rts(priv->ieee80211,info,wrqu,extra);\r\n}\r\nstatic int r8192_wx_set_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_set_power(priv->ieee80211,info,wrqu,extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nreturn ieee80211_wx_get_power(priv->ieee80211,info,wrqu,extra);\r\n}\r\nstatic int r8192_wx_set_rawtx(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint ret;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_set_rawtx(priv->ieee80211, info, wrqu, extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_force_reset(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\ndown(&priv->wx_sem);\r\nprintk("%s(): force reset ! extra is %d\n",__FUNCTION__, *extra);\r\npriv->force_reset = *extra;\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_crcmon(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint *parms = (int *)extra;\r\nint enable = (parms[0] > 0);\r\nshort prev = priv->crcmon;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nif(enable)\r\npriv->crcmon=1;\r\nelse\r\npriv->crcmon=0;\r\nDMESG("bad CRC in monitor mode are %s",\r\npriv->crcmon ? "accepted" : "rejected");\r\nif(prev != priv->crcmon && priv->up){\r\n}\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_mode(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nRT_RF_POWER_STATE rtState;\r\nint ret;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\nrtState = priv->eRFPowerState;\r\ndown(&priv->wx_sem);\r\n#ifdef ENABLE_IPS\r\nif(wrqu->mode == IW_MODE_ADHOC){\r\nif (priv->PowerSaveControl.bInactivePs) {\r\nif(rtState == eRfOff){\r\nif(priv->RfOffReason > RF_CHANGE_BY_IPS)\r\n{\r\nRT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__FUNCTION__);\r\nup(&priv->wx_sem);\r\nreturn -1;\r\n}\r\nelse{\r\nRT_TRACE(COMP_ERR, "%s(): IPSLeave\n",__FUNCTION__);\r\ndown(&priv->ieee80211->ips_sem);\r\nIPSLeave(priv);\r\nup(&priv->ieee80211->ips_sem);\r\n}\r\n}\r\n}\r\n}\r\n#endif\r\nret = ieee80211_wx_set_mode(priv->ieee80211,a,wrqu,b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_scan(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device* ieee = priv->ieee80211;\r\nRT_RF_POWER_STATE rtState;\r\nint ret;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\nrtState = priv->eRFPowerState;\r\nif(!priv->up) return -ENETDOWN;\r\nif (priv->ieee80211->LinkDetectInfo.bBusyTraffic == true)\r\nreturn -EAGAIN;\r\nif (wrqu->data.flags & IW_SCAN_THIS_ESSID)\r\n{\r\nstruct iw_scan_req* req = (struct iw_scan_req*)b;\r\nif (req->essid_len)\r\n{\r\nieee->current_network.ssid_len = req->essid_len;\r\nmemcpy(ieee->current_network.ssid, req->essid, req->essid_len);\r\n}\r\n}\r\ndown(&priv->wx_sem);\r\n#ifdef ENABLE_IPS\r\npriv->ieee80211->actscanning = true;\r\nif(priv->ieee80211->state != IEEE80211_LINKED){\r\nif (priv->PowerSaveControl.bInactivePs) {\r\nif(rtState == eRfOff){\r\nif(priv->RfOffReason > RF_CHANGE_BY_IPS)\r\n{\r\nRT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__FUNCTION__);\r\nup(&priv->wx_sem);\r\nreturn -1;\r\n}\r\nelse{\r\ndown(&priv->ieee80211->ips_sem);\r\nIPSLeave(priv);\r\nup(&priv->ieee80211->ips_sem);\r\n}\r\n}\r\n}\r\npriv->ieee80211->scanning = 0;\r\nieee80211_softmac_scan_syncro(priv->ieee80211);\r\nret = 0;\r\n}\r\nelse\r\n#else\r\nif(priv->ieee80211->state != IEEE80211_LINKED){\r\npriv->ieee80211->scanning = 0;\r\nieee80211_softmac_scan_syncro(priv->ieee80211);\r\nret = 0;\r\n}\r\nelse\r\n#endif\r\nret = ieee80211_wx_set_scan(priv->ieee80211,a,wrqu,b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_scan(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\nif(!priv->up) return -ENETDOWN;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_get_scan(priv->ieee80211,a,wrqu,b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_essid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nRT_RF_POWER_STATE rtState;\r\nint ret;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\nrtState = priv->eRFPowerState;\r\ndown(&priv->wx_sem);\r\n#ifdef ENABLE_IPS\r\ndown(&priv->ieee80211->ips_sem);\r\nIPSLeave(priv);\r\nup(&priv->ieee80211->ips_sem);\r\n#endif\r\nret = ieee80211_wx_set_essid(priv->ieee80211,a,wrqu,b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_essid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_get_essid(priv->ieee80211, a, wrqu, b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_freq(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_set_freq(priv->ieee80211, a, wrqu, b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nreturn ieee80211_wx_get_name(priv->ieee80211, info, wrqu, extra);\r\n}\r\nstatic int r8192_wx_set_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\nif (wrqu->frag.disabled)\r\npriv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;\r\nelse {\r\nif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\r\nwrqu->frag.value > MAX_FRAG_THRESHOLD)\r\nreturn -EINVAL;\r\npriv->ieee80211->fts = wrqu->frag.value & ~0x1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_get_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nwrqu->frag.value = priv->ieee80211->fts;\r\nwrqu->frag.fixed = 0;\r\nwrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *awrq,\r\nchar *extra)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\n#ifdef ENABLE_IPS\r\ndown(&priv->ieee80211->ips_sem);\r\nIPSLeave(priv);\r\nup(&priv->ieee80211->ips_sem);\r\n#endif\r\nret = ieee80211_wx_set_wap(priv->ieee80211,info,awrq,extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nreturn ieee80211_wx_get_wap(priv->ieee80211,info,wrqu,extra);\r\n}\r\nstatic int r8192_wx_get_enc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *key)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nreturn ieee80211_wx_get_encode(priv->ieee80211, info, wrqu, key);\r\n}\r\nstatic int r8192_wx_set_enc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *key)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint ret;\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nu32 hwkey[4]={0,0,0,0};\r\nu8 mask=0xff;\r\nu32 key_idx=0;\r\nu8 zero_addr[4][6] ={{0x00,0x00,0x00,0x00,0x00,0x00},\r\n{0x00,0x00,0x00,0x00,0x00,0x01},\r\n{0x00,0x00,0x00,0x00,0x00,0x02},\r\n{0x00,0x00,0x00,0x00,0x00,0x03} };\r\nint i;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\nif(!priv->up) return -ENETDOWN;\r\npriv->ieee80211->wx_set_enc = 1;\r\n#ifdef ENABLE_IPS\r\ndown(&priv->ieee80211->ips_sem);\r\nIPSLeave(priv);\r\nup(&priv->ieee80211->ips_sem);\r\n#endif\r\ndown(&priv->wx_sem);\r\nRT_TRACE(COMP_SEC, "Setting SW wep key\n");\r\nret = ieee80211_wx_set_encode(priv->ieee80211,info,wrqu,key);\r\nup(&priv->wx_sem);\r\nif(wrqu->encoding.length!=0){\r\nfor(i=0 ; i<4 ; i++){\r\nhwkey[i] |= key[4*i+0]&mask;\r\nif(i==1&&(4*i+1)==wrqu->encoding.length) mask=0x00;\r\nif(i==3&&(4*i+1)==wrqu->encoding.length) mask=0x00;\r\nhwkey[i] |= (key[4*i+1]&mask)<<8;\r\nhwkey[i] |= (key[4*i+2]&mask)<<16;\r\nhwkey[i] |= (key[4*i+3]&mask)<<24;\r\n}\r\n#define CONF_WEP40 0x4\r\n#define CONF_WEP104 0x14\r\nswitch(wrqu->encoding.flags & IW_ENCODE_INDEX){\r\ncase 0: key_idx = ieee->tx_keyidx; break;\r\ncase 1: key_idx = 0; break;\r\ncase 2: key_idx = 1; break;\r\ncase 3: key_idx = 2; break;\r\ncase 4: key_idx = 3; break;\r\ndefault: break;\r\n}\r\nif(wrqu->encoding.length==0x5){\r\nieee->pairwise_key_type = KEY_TYPE_WEP40;\r\nEnableHWSecurityConfig8192(priv);\r\nsetKey(priv, key_idx, key_idx, KEY_TYPE_WEP40,\r\nzero_addr[key_idx], 0, hwkey);\r\n}\r\nelse if(wrqu->encoding.length==0xd){\r\nieee->pairwise_key_type = KEY_TYPE_WEP104;\r\nEnableHWSecurityConfig8192(priv);\r\nsetKey(priv, key_idx, key_idx, KEY_TYPE_WEP104,\r\nzero_addr[key_idx], 0, hwkey);\r\n}\r\nelse printk("wrong type in WEP, not WEP40 and WEP104\n");\r\n}\r\npriv->ieee80211->wx_set_enc = 0;\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_scan_type(struct net_device *dev, struct iw_request_info *aa, union\r\niwreq_data *wrqu, char *p){\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint *parms=(int*)p;\r\nint mode=parms[0];\r\npriv->ieee80211->active_scan = mode;\r\nreturn 1;\r\n}\r\nstatic int r8192_wx_set_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint err = 0;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nif (wrqu->retry.flags & IW_RETRY_LIFETIME ||\r\nwrqu->retry.disabled){\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nif (!(wrqu->retry.flags & IW_RETRY_LIMIT)){\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nif(wrqu->retry.value > R8180_MAX_RETRY){\r\nerr= -EINVAL;\r\ngoto exit;\r\n}\r\nif (wrqu->retry.flags & IW_RETRY_MAX) {\r\npriv->retry_rts = wrqu->retry.value;\r\nDMESG("Setting retry for RTS/CTS data to %d", wrqu->retry.value);\r\n}else {\r\npriv->retry_data = wrqu->retry.value;\r\nDMESG("Setting retry for non RTS/CTS data to %d", wrqu->retry.value);\r\n}\r\nrtl8192_commit(priv);\r\nexit:\r\nup(&priv->wx_sem);\r\nreturn err;\r\n}\r\nstatic int r8192_wx_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nwrqu->retry.disabled = 0;\r\nif ((wrqu->retry.flags & IW_RETRY_TYPE) ==\r\nIW_RETRY_LIFETIME)\r\nreturn -EINVAL;\r\nif (wrqu->retry.flags & IW_RETRY_MAX) {\r\nwrqu->retry.flags = IW_RETRY_LIMIT & IW_RETRY_MAX;\r\nwrqu->retry.value = priv->retry_rts;\r\n} else {\r\nwrqu->retry.flags = IW_RETRY_LIMIT & IW_RETRY_MIN;\r\nwrqu->retry.value = priv->retry_data;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_get_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif(priv->rf_set_sens == NULL)\r\nreturn -1;\r\nwrqu->sens.value = priv->sens;\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nshort err = 0;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nif(priv->rf_set_sens == NULL) {\r\nerr= -1;\r\ngoto exit;\r\n}\r\nif(priv->rf_set_sens(dev, wrqu->sens.value) == 0)\r\npriv->sens = wrqu->sens.value;\r\nelse\r\nerr= -EINVAL;\r\nexit:\r\nup(&priv->wx_sem);\r\nreturn err;\r\n}\r\nstatic int r8192_wx_set_enc_ext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret=0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device* ieee = priv->ieee80211;\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\npriv->ieee80211->wx_set_enc = 1;\r\n#ifdef ENABLE_IPS\r\ndown(&priv->ieee80211->ips_sem);\r\nIPSLeave(priv);\r\nup(&priv->ieee80211->ips_sem);\r\n#endif\r\nret = ieee80211_wx_set_encode_ext(ieee, info, wrqu, extra);\r\n{\r\nu8 broadcast_addr[6] = {0xff,0xff,0xff,0xff,0xff,0xff};\r\nu8 zero[6] = {0};\r\nu32 key[4] = {0};\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nu8 idx = 0, alg = 0, group = 0;\r\nif ((encoding->flags & IW_ENCODE_DISABLED) ||\r\next->alg == IW_ENCODE_ALG_NONE)\r\n{\r\nieee->pairwise_key_type = ieee->group_key_type = KEY_TYPE_NA;\r\nCamResetAllEntry(priv);\r\ngoto end_hw_sec;\r\n}\r\nalg = (ext->alg == IW_ENCODE_ALG_CCMP)?KEY_TYPE_CCMP:ext->alg;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx)\r\nidx --;\r\ngroup = ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY;\r\nif ((!group) || (IW_MODE_ADHOC == ieee->iw_mode) || (alg == KEY_TYPE_WEP40))\r\n{\r\nif ((ext->key_len == 13) && (alg == KEY_TYPE_WEP40) )\r\nalg = KEY_TYPE_WEP104;\r\nieee->pairwise_key_type = alg;\r\nEnableHWSecurityConfig8192(priv);\r\n}\r\nmemcpy((u8*)key, ext->key, 16);\r\nif ((alg & KEY_TYPE_WEP40) && (ieee->auth_mode !=2) )\r\n{\r\nif (ext->key_len == 13)\r\nieee->pairwise_key_type = alg = KEY_TYPE_WEP104;\r\nsetKey(priv, idx, idx, alg, zero, 0, key);\r\n}\r\nelse if (group)\r\n{\r\nieee->group_key_type = alg;\r\nsetKey(priv, idx, idx, alg, broadcast_addr, 0, key);\r\n}\r\nelse\r\n{\r\nif ((ieee->pairwise_key_type == KEY_TYPE_CCMP) && ieee->pHTInfo->bCurrentHTSupport){\r\nwrite_nic_byte(priv, 0x173, 1);\r\n}\r\nsetKey(priv, 4, idx, alg,\r\n(u8*)ieee->ap_mac_addr, 0, key);\r\n}\r\n}\r\nend_hw_sec:\r\npriv->ieee80211->wx_set_enc = 0;\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nint ret=0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_set_auth(priv->ieee80211, info, &(data->param), extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_mlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret=0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_set_mlme(priv->ieee80211, info, wrqu, extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_gen_ie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nint ret=0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->bHwRadioOff)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int dummy(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu,char *b)\r\n{\r\nreturn -1;\r\n}\r\nstatic int r8192_wx_adapter_power_status(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\n#ifdef ENABLE_LPS\r\nPRT_POWER_SAVE_CONTROL pPSC = &priv->PowerSaveControl;\r\nstruct ieee80211_device* ieee = priv->ieee80211;\r\n#endif\r\ndown(&priv->wx_sem);\r\n#ifdef ENABLE_LPS\r\nRT_TRACE(COMP_POWER, "%s(): %s\n",__FUNCTION__, (*extra == 6)?"DC power":"AC power");\r\nif(*extra || priv->force_lps) {\r\npriv->ps_force = false;\r\npPSC->bLeisurePs = true;\r\n} else {\r\nif(priv->ieee80211->state == IEEE80211_LINKED)\r\nLeisurePSLeave(priv->ieee80211);\r\npriv->ps_force = true;\r\npPSC->bLeisurePs = false;\r\nieee->ps = *extra;\r\n}\r\n#endif\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic struct iw_statistics *r8192_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device* ieee = priv->ieee80211;\r\nstruct iw_statistics* wstats = &priv->wstats;\r\nint tmp_level = 0;\r\nint tmp_qual = 0;\r\nint tmp_noise = 0;\r\nif(ieee->state < IEEE80211_LINKED)\r\n{\r\nwstats->qual.qual = 0;\r\nwstats->qual.level = 0;\r\nwstats->qual.noise = 0;\r\nwstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\r\nreturn wstats;\r\n}\r\ntmp_level = (&ieee->current_network)->stats.rssi;\r\ntmp_qual = (&ieee->current_network)->stats.signal;\r\ntmp_noise = (&ieee->current_network)->stats.noise;\r\nwstats->qual.level = tmp_level;\r\nwstats->qual.qual = tmp_qual;\r\nwstats->qual.noise = tmp_noise;\r\nwstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\r\nreturn wstats;\r\n}
