static int __init driver_icp_multi_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_icp_multi);\r\n}\r\nstatic void __exit driver_icp_multi_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_icp_multi);\r\n}\r\nstatic int icp_multi_insn_read_ai(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n, timeout;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG "icp multi EDBG: BGN: icp_multi_insn_read_ai(...)\n");\r\n#endif\r\ndevpriv->IntEnable &= ~ADC_READY;\r\nwritew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= ADC_READY;\r\nwritew(devpriv->IntStatus, devpriv->io_addr + ICP_MULTI_INT_STAT);\r\nsetup_channel_list(dev, s, &insn->chanspec, 1);\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG "icp_multi A ST=%4x IO=%p\n",\r\nreadw(devpriv->io_addr + ICP_MULTI_ADC_CSR),\r\ndevpriv->io_addr + ICP_MULTI_ADC_CSR);\r\n#endif\r\nfor (n = 0; n < insn->n; n++) {\r\ndevpriv->AdcCmdStatus |= ADC_ST;\r\nwritew(devpriv->AdcCmdStatus,\r\ndevpriv->io_addr + ICP_MULTI_ADC_CSR);\r\ndevpriv->AdcCmdStatus &= ~ADC_ST;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG "icp multi B n=%d ST=%4x\n", n,\r\nreadw(devpriv->io_addr + ICP_MULTI_ADC_CSR));\r\n#endif\r\nudelay(1);\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG "icp multi C n=%d ST=%4x\n", n,\r\nreadw(devpriv->io_addr + ICP_MULTI_ADC_CSR));\r\n#endif\r\ntimeout = 100;\r\nwhile (timeout--) {\r\nif (!(readw(devpriv->io_addr +\r\nICP_MULTI_ADC_CSR) & ADC_BSY))\r\ngoto conv_finish;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nif (!(timeout % 10))\r\nprintk(KERN_DEBUG\r\n"icp multi D n=%d tm=%d ST=%4x\n", n,\r\ntimeout,\r\nreadw(devpriv->io_addr +\r\nICP_MULTI_ADC_CSR));\r\n#endif\r\nudelay(1);\r\n}\r\ncomedi_error(dev, "A/D insn timeout");\r\ndevpriv->IntEnable &= ~ADC_READY;\r\nwritew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= ADC_READY;\r\nwritew(devpriv->IntStatus,\r\ndevpriv->io_addr + ICP_MULTI_INT_STAT);\r\ndata[n] = 0;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: END: icp_multi_insn_read_ai(...) n=%d\n",\r\nn);\r\n#endif\r\nreturn -ETIME;\r\nconv_finish:\r\ndata[n] =\r\n(readw(devpriv->io_addr + ICP_MULTI_AI) >> 4) & 0x0fff;\r\n}\r\ndevpriv->IntEnable &= ~ADC_READY;\r\nwritew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= ADC_READY;\r\nwritew(devpriv->IntStatus, devpriv->io_addr + ICP_MULTI_INT_STAT);\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: END: icp_multi_insn_read_ai(...) n=%d\n", n);\r\n#endif\r\nreturn n;\r\n}\r\nstatic int icp_multi_insn_write_ao(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n, chan, range, timeout;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: BGN: icp_multi_insn_write_ao(...)\n");\r\n#endif\r\ndevpriv->IntEnable &= ~DAC_READY;\r\nwritew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= DAC_READY;\r\nwritew(devpriv->IntStatus, devpriv->io_addr + ICP_MULTI_INT_STAT);\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\ndevpriv->DacCmdStatus &= 0xfccf;\r\ndevpriv->DacCmdStatus |= this_board->rangecode[range];\r\ndevpriv->DacCmdStatus |= (chan << 8);\r\nwritew(devpriv->DacCmdStatus, devpriv->io_addr + ICP_MULTI_DAC_CSR);\r\nfor (n = 0; n < insn->n; n++) {\r\ntimeout = 100;\r\nwhile (timeout--) {\r\nif (!(readw(devpriv->io_addr +\r\nICP_MULTI_DAC_CSR) & DAC_BSY))\r\ngoto dac_ready;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nif (!(timeout % 10))\r\nprintk(KERN_DEBUG\r\n"icp multi A n=%d tm=%d ST=%4x\n", n,\r\ntimeout,\r\nreadw(devpriv->io_addr +\r\nICP_MULTI_DAC_CSR));\r\n#endif\r\nudelay(1);\r\n}\r\ncomedi_error(dev, "D/A insn timeout");\r\ndevpriv->IntEnable &= ~DAC_READY;\r\nwritew(devpriv->IntEnable, devpriv->io_addr + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= DAC_READY;\r\nwritew(devpriv->IntStatus,\r\ndevpriv->io_addr + ICP_MULTI_INT_STAT);\r\ndevpriv->ao_data[chan] = 0;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: END: icp_multi_insn_write_ao(...) n=%d\n",\r\nn);\r\n#endif\r\nreturn -ETIME;\r\ndac_ready:\r\nwritew(data[n], devpriv->io_addr + ICP_MULTI_AO);\r\ndevpriv->DacCmdStatus |= DAC_ST;\r\nwritew(devpriv->DacCmdStatus,\r\ndevpriv->io_addr + ICP_MULTI_DAC_CSR);\r\ndevpriv->DacCmdStatus &= ~DAC_ST;\r\ndevpriv->ao_data[chan] = data[n];\r\n}\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: END: icp_multi_insn_write_ao(...) n=%d\n", n);\r\n#endif\r\nreturn n;\r\n}\r\nstatic int icp_multi_insn_read_ao(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n, chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = devpriv->ao_data[chan];\r\nreturn n;\r\n}\r\nstatic int icp_multi_insn_bits_di(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = readw(devpriv->io_addr + ICP_MULTI_DI);\r\nreturn 2;\r\n}\r\nstatic int icp_multi_insn_bits_do(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG "icp multi EDBG: BGN: icp_multi_insn_bits_do(...)\n");\r\n#endif\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nprintk(KERN_DEBUG "Digital outputs = %4x \n", s->state);\r\nwritew(s->state, devpriv->io_addr + ICP_MULTI_DO);\r\n}\r\ndata[1] = readw(devpriv->io_addr + ICP_MULTI_DI);\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG "icp multi EDBG: END: icp_multi_insn_bits_do(...)\n");\r\n#endif\r\nreturn 2;\r\n}\r\nstatic int icp_multi_insn_read_ctr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int icp_multi_insn_write_ctr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic irqreturn_t interrupt_service_icp_multi(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nint int_no;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: BGN: interrupt_service_icp_multi(%d,...)\n",\r\nirq);\r\n#endif\r\nint_no = readw(devpriv->io_addr + ICP_MULTI_INT_STAT) & Status_IRQ;\r\nif (!int_no)\r\nreturn IRQ_NONE;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: interrupt_service_icp_multi() ST: %4x\n",\r\nreadw(devpriv->io_addr + ICP_MULTI_INT_STAT));\r\n#endif\r\nswitch (int_no) {\r\ncase ADC_READY:\r\nbreak;\r\ncase DAC_READY:\r\nbreak;\r\ncase DOUT_ERROR:\r\nbreak;\r\ncase DIN_STATUS:\r\nbreak;\r\ncase CIE0:\r\nbreak;\r\ncase CIE1:\r\nbreak;\r\ncase CIE2:\r\nbreak;\r\ncase CIE3:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: END: interrupt_service_icp_multi(...)\n");\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void setup_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chanlist, unsigned int n_chan)\r\n{\r\nunsigned int i, range, chanprog;\r\nunsigned int diff;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: setup_channel_list(...,%d)\n", n_chan);\r\n#endif\r\ndevpriv->act_chanlist_len = n_chan;\r\ndevpriv->act_chanlist_pos = 0;\r\nfor (i = 0; i < n_chan; i++) {\r\nchanprog = CR_CHAN(chanlist[i]);\r\nif (CR_AREF(chanlist[i]) == AREF_DIFF) {\r\ndiff = 1;\r\nchanprog &= 0x0007;\r\n} else {\r\ndiff = 0;\r\nchanprog &= 0x000f;\r\n}\r\ndevpriv->AdcCmdStatus &= 0xf00f;\r\nif (diff) {\r\ndevpriv->AdcCmdStatus |= (chanprog << 9);\r\ndevpriv->AdcCmdStatus |= ADC_DI;\r\n} else\r\ndevpriv->AdcCmdStatus |= (chanprog << 8);\r\nrange = this_board->rangecode[CR_RANGE(chanlist[i])];\r\ndevpriv->AdcCmdStatus |= range;\r\nwritew(devpriv->AdcCmdStatus,\r\ndevpriv->io_addr + ICP_MULTI_ADC_CSR);\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"GS: %2d. [%4x]=%4x %4x\n", i, chanprog, range,\r\ndevpriv->act_chanlist[i]);\r\n#endif\r\n}\r\n}\r\nstatic int icp_multi_reset(struct comedi_device *dev)\r\n{\r\nunsigned int i;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp_multi EDBG: BGN: icp_multi_reset(...)\n");\r\n#endif\r\nwritew(0, devpriv->io_addr + ICP_MULTI_INT_EN);\r\nwritew(0x00ff, devpriv->io_addr + ICP_MULTI_INT_STAT);\r\nif (this_board->n_aochan)\r\nfor (i = 0; i < this_board->n_aochan; i++) {\r\ndevpriv->DacCmdStatus &= 0xfcce;\r\ndevpriv->DacCmdStatus |= (i << 8);\r\nwritew(0, devpriv->io_addr + ICP_MULTI_AO);\r\ndevpriv->DacCmdStatus |= DAC_ST;\r\nwritew(devpriv->DacCmdStatus,\r\ndevpriv->io_addr + ICP_MULTI_DAC_CSR);\r\nudelay(1);\r\n}\r\nwritew(0, devpriv->io_addr + ICP_MULTI_DO);\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"icp multi EDBG: END: icp_multi_reset(...)\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int icp_multi_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret, subdev, n_subdevices;\r\nunsigned int irq;\r\nstruct pcilst_struct *card = NULL;\r\nresource_size_t io_addr[5], iobase;\r\nunsigned char pci_bus, pci_slot, pci_func;\r\nprintk(KERN_WARNING\r\n"icp_multi EDBG: BGN: icp_multi_attach(...)\n");\r\nret = alloc_private(dev, sizeof(struct icp_multi_private));\r\nif (ret < 0)\r\nreturn ret;\r\nif (pci_list_builded++ == 0) {\r\npci_card_list_init(PCI_VENDOR_ID_ICP,\r\n#ifdef ICP_MULTI_EXTDEBUG\r\n1\r\n#else\r\n0\r\n#endif\r\n);\r\n}\r\nprintk(KERN_WARNING\r\n"Anne's comedi%d: icp_multi: board=%s", dev->minor,\r\nthis_board->name);\r\ncard = select_and_alloc_pci_card(PCI_VENDOR_ID_ICP,\r\nthis_board->device_id, it->options[0],\r\nit->options[1]);\r\nif (card == NULL)\r\nreturn -EIO;\r\ndevpriv->card = card;\r\nif ((pci_card_data(card, &pci_bus, &pci_slot, &pci_func, &io_addr[0],\r\n&irq)) < 0) {\r\nprintk(KERN_WARNING " - Can't get configuration data!\n");\r\nreturn -EIO;\r\n}\r\niobase = io_addr[2];\r\ndevpriv->phys_iobase = iobase;\r\nprintk(KERN_WARNING\r\n", b:s:f=%d:%d:%d, io=0x%8llx \n", pci_bus, pci_slot, pci_func,\r\n(unsigned long long)iobase);\r\ndevpriv->io_addr = ioremap(iobase, ICP_MULTI_SIZE);\r\nif (devpriv->io_addr == NULL) {\r\nprintk(KERN_WARNING "ioremap failed.\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG\r\n"0x%08llx mapped to %p, ", (unsigned long long)iobase,\r\ndevpriv->io_addr);\r\n#endif\r\ndev->board_name = this_board->name;\r\nn_subdevices = 0;\r\nif (this_board->n_aichan)\r\nn_subdevices++;\r\nif (this_board->n_aochan)\r\nn_subdevices++;\r\nif (this_board->n_dichan)\r\nn_subdevices++;\r\nif (this_board->n_dochan)\r\nn_subdevices++;\r\nif (this_board->n_ctrs)\r\nn_subdevices++;\r\nret = alloc_subdevices(dev, n_subdevices);\r\nif (ret < 0)\r\nreturn ret;\r\nicp_multi_reset(dev);\r\nif (this_board->have_irq) {\r\nif (irq) {\r\nif (request_irq(irq, interrupt_service_icp_multi,\r\nIRQF_SHARED, "Inova Icp Multi", dev)) {\r\nprintk(KERN_WARNING\r\n"unable to allocate IRQ %u, DISABLING IT",\r\nirq);\r\nirq = 0;\r\n} else\r\nprintk(KERN_WARNING ", irq=%u", irq);\r\n} else\r\nprintk(KERN_WARNING ", IRQ disabled");\r\n} else\r\nirq = 0;\r\ndev->irq = irq;\r\nprintk(KERN_WARNING ".\n");\r\nsubdev = 0;\r\nif (this_board->n_aichan) {\r\ns = dev->subdevices + subdev;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND;\r\nif (this_board->n_aichand)\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = this_board->n_aichan;\r\ns->maxdata = this_board->ai_maxdata;\r\ns->len_chanlist = this_board->n_aichan;\r\ns->range_table = this_board->rangelist_ai;\r\ns->insn_read = icp_multi_insn_read_ai;\r\nsubdev++;\r\n}\r\nif (this_board->n_aochan) {\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = this_board->n_aochan;\r\ns->maxdata = this_board->ao_maxdata;\r\ns->len_chanlist = this_board->n_aochan;\r\ns->range_table = this_board->rangelist_ao;\r\ns->insn_write = icp_multi_insn_write_ao;\r\ns->insn_read = icp_multi_insn_read_ao;\r\nsubdev++;\r\n}\r\nif (this_board->n_dichan) {\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = this_board->n_dichan;\r\ns->maxdata = 1;\r\ns->len_chanlist = this_board->n_dichan;\r\ns->range_table = &range_digital;\r\ns->io_bits = 0;\r\ns->insn_bits = icp_multi_insn_bits_di;\r\nsubdev++;\r\n}\r\nif (this_board->n_dochan) {\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = this_board->n_dochan;\r\ns->maxdata = 1;\r\ns->len_chanlist = this_board->n_dochan;\r\ns->range_table = &range_digital;\r\ns->io_bits = (1 << this_board->n_dochan) - 1;\r\ns->state = 0;\r\ns->insn_bits = icp_multi_insn_bits_do;\r\nsubdev++;\r\n}\r\nif (this_board->n_ctrs) {\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = this_board->n_ctrs;\r\ns->maxdata = 0xffff;\r\ns->len_chanlist = this_board->n_ctrs;\r\ns->state = 0;\r\ns->insn_read = icp_multi_insn_read_ctr;\r\ns->insn_write = icp_multi_insn_write_ctr;\r\nsubdev++;\r\n}\r\ndevpriv->valid = 1;\r\n#ifdef ICP_MULTI_EXTDEBUG\r\nprintk(KERN_DEBUG "icp multi EDBG: END: icp_multi_attach(...)\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int icp_multi_detach(struct comedi_device *dev)\r\n{\r\nif (dev->private)\r\nif (devpriv->valid)\r\nicp_multi_reset(dev);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->private && devpriv->io_addr)\r\niounmap(devpriv->io_addr);\r\nif (dev->private && devpriv->card)\r\npci_card_free(devpriv->card);\r\nif (--pci_list_builded == 0)\r\npci_card_list_cleanup(PCI_VENDOR_ID_ICP);\r\nreturn 0;\r\n}
