static void lpc32xx_fifo_clear(struct lpc32xx_tsc *tsc)\r\n{\r\nwhile (!(tsc_readl(tsc, LPC32XX_TSC_STAT) &\r\nLPC32XX_TSC_STAT_FIFO_EMPTY))\r\ntsc_readl(tsc, LPC32XX_TSC_FIFO);\r\n}\r\nstatic irqreturn_t lpc32xx_ts_interrupt(int irq, void *dev_id)\r\n{\r\nu32 tmp, rv[4], xs[4], ys[4];\r\nint idx;\r\nstruct lpc32xx_tsc *tsc = dev_id;\r\nstruct input_dev *input = tsc->dev;\r\ntmp = tsc_readl(tsc, LPC32XX_TSC_STAT);\r\nif (tmp & LPC32XX_TSC_STAT_FIFO_OVRRN) {\r\nlpc32xx_fifo_clear(tsc);\r\nreturn IRQ_HANDLED;\r\n}\r\nidx = 0;\r\nwhile (idx < 4 &&\r\n!(tsc_readl(tsc, LPC32XX_TSC_STAT) &\r\nLPC32XX_TSC_STAT_FIFO_EMPTY)) {\r\ntmp = tsc_readl(tsc, LPC32XX_TSC_FIFO);\r\nxs[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -\r\nLPC32XX_TSC_FIFO_NORMALIZE_X_VAL(tmp);\r\nys[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -\r\nLPC32XX_TSC_FIFO_NORMALIZE_Y_VAL(tmp);\r\nrv[idx] = tmp;\r\nidx++;\r\n}\r\nif (!(rv[3] & LPC32XX_TSC_FIFO_TS_P_LEVEL) && idx == 4) {\r\ninput_report_abs(input, ABS_X, (xs[1] + xs[2]) / 2);\r\ninput_report_abs(input, ABS_Y, (ys[1] + ys[2]) / 2);\r\ninput_report_key(input, BTN_TOUCH, 1);\r\n} else {\r\ninput_report_key(input, BTN_TOUCH, 0);\r\n}\r\ninput_sync(input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void lpc32xx_stop_tsc(struct lpc32xx_tsc *tsc)\r\n{\r\ntsc_writel(tsc, LPC32XX_TSC_CON,\r\ntsc_readl(tsc, LPC32XX_TSC_CON) &\r\n~LPC32XX_TSC_ADCCON_AUTO_EN);\r\nclk_disable(tsc->clk);\r\n}\r\nstatic void lpc32xx_setup_tsc(struct lpc32xx_tsc *tsc)\r\n{\r\nu32 tmp;\r\nclk_enable(tsc->clk);\r\ntmp = tsc_readl(tsc, LPC32XX_TSC_CON) & ~LPC32XX_TSC_ADCCON_POWER_UP;\r\ntmp = LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4 |\r\nLPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(10) |\r\nLPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(10);\r\ntsc_writel(tsc, LPC32XX_TSC_CON, tmp);\r\ntsc_writel(tsc, LPC32XX_TSC_SEL, LPC32XX_TSC_SEL_DEFVAL);\r\ntsc_writel(tsc, LPC32XX_TSC_MIN_X, LPC32XX_TSC_MIN_XY_VAL);\r\ntsc_writel(tsc, LPC32XX_TSC_MAX_X, LPC32XX_TSC_MAX_XY_VAL);\r\ntsc_writel(tsc, LPC32XX_TSC_MIN_Y, LPC32XX_TSC_MIN_XY_VAL);\r\ntsc_writel(tsc, LPC32XX_TSC_MAX_Y, LPC32XX_TSC_MAX_XY_VAL);\r\ntsc_writel(tsc, LPC32XX_TSC_AUX_UTR, 0);\r\ntsc_writel(tsc, LPC32XX_TSC_AUX_MIN, 0);\r\ntsc_writel(tsc, LPC32XX_TSC_AUX_MAX, 0);\r\ntsc_writel(tsc, LPC32XX_TSC_RTR, 0x2);\r\ntsc_writel(tsc, LPC32XX_TSC_DTR, 0x2);\r\ntsc_writel(tsc, LPC32XX_TSC_TTR, 0x10);\r\ntsc_writel(tsc, LPC32XX_TSC_DXP, 0x4);\r\ntsc_writel(tsc, LPC32XX_TSC_UTR, 88);\r\nlpc32xx_fifo_clear(tsc);\r\ntsc_writel(tsc, LPC32XX_TSC_CON, tmp | LPC32XX_TSC_ADCCON_AUTO_EN);\r\n}\r\nstatic int lpc32xx_ts_open(struct input_dev *dev)\r\n{\r\nstruct lpc32xx_tsc *tsc = input_get_drvdata(dev);\r\nlpc32xx_setup_tsc(tsc);\r\nreturn 0;\r\n}\r\nstatic void lpc32xx_ts_close(struct input_dev *dev)\r\n{\r\nstruct lpc32xx_tsc *tsc = input_get_drvdata(dev);\r\nlpc32xx_stop_tsc(tsc);\r\n}\r\nstatic int __devinit lpc32xx_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_tsc *tsc;\r\nstruct input_dev *input;\r\nstruct resource *res;\r\nresource_size_t size;\r\nint irq;\r\nint error;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Can't get memory resource\n");\r\nreturn -ENOENT;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "Can't get interrupt resource\n");\r\nreturn irq;\r\n}\r\ntsc = kzalloc(sizeof(*tsc), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!tsc || !input) {\r\ndev_err(&pdev->dev, "failed allocating memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ntsc->dev = input;\r\ntsc->irq = irq;\r\nsize = resource_size(res);\r\nif (!request_mem_region(res->start, size, pdev->name)) {\r\ndev_err(&pdev->dev, "TSC registers are not free\n");\r\nerror = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\ntsc->tsc_base = ioremap(res->start, size);\r\nif (!tsc->tsc_base) {\r\ndev_err(&pdev->dev, "Can't map memory\n");\r\nerror = -ENOMEM;\r\ngoto err_release_mem;\r\n}\r\ntsc->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(tsc->clk)) {\r\ndev_err(&pdev->dev, "failed getting clock\n");\r\nerror = PTR_ERR(tsc->clk);\r\ngoto err_unmap;\r\n}\r\ninput->name = MOD_NAME;\r\ninput->phys = "lpc32xx/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0002;\r\ninput->id.version = 0x0100;\r\ninput->dev.parent = &pdev->dev;\r\ninput->open = lpc32xx_ts_open;\r\ninput->close = lpc32xx_ts_close;\r\ninput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input, ABS_X, LPC32XX_TSC_MIN_XY_VAL,\r\nLPC32XX_TSC_MAX_XY_VAL, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, LPC32XX_TSC_MIN_XY_VAL,\r\nLPC32XX_TSC_MAX_XY_VAL, 0, 0);\r\ninput_set_drvdata(input, tsc);\r\nerror = request_irq(tsc->irq, lpc32xx_ts_interrupt,\r\nIRQF_DISABLED, pdev->name, tsc);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed requesting interrupt\n");\r\ngoto err_put_clock;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed registering input device\n");\r\ngoto err_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, tsc);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(tsc->irq, tsc);\r\nerr_put_clock:\r\nclk_put(tsc->clk);\r\nerr_unmap:\r\niounmap(tsc->tsc_base);\r\nerr_release_mem:\r\nrelease_mem_region(res->start, size);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(tsc);\r\nreturn error;\r\n}\r\nstatic int __devexit lpc32xx_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_tsc *tsc = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nfree_irq(tsc->irq, tsc);\r\ninput_unregister_device(tsc->dev);\r\nclk_put(tsc->clk);\r\niounmap(tsc->tsc_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(tsc);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_ts_suspend(struct device *dev)\r\n{\r\nstruct lpc32xx_tsc *tsc = dev_get_drvdata(dev);\r\nstruct input_dev *input = tsc->dev;\r\nmutex_lock(&input->mutex);\r\nif (input->users) {\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(tsc->irq);\r\nelse\r\nlpc32xx_stop_tsc(tsc);\r\n}\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_ts_resume(struct device *dev)\r\n{\r\nstruct lpc32xx_tsc *tsc = dev_get_drvdata(dev);\r\nstruct input_dev *input = tsc->dev;\r\nmutex_lock(&input->mutex);\r\nif (input->users) {\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(tsc->irq);\r\nelse\r\nlpc32xx_setup_tsc(tsc);\r\n}\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}\r\nstatic int __init lpc32xx_ts_init(void)\r\n{\r\nreturn platform_driver_register(&lpc32xx_ts_driver);\r\n}\r\nstatic void __exit lpc32xx_ts_exit(void)\r\n{\r\nplatform_driver_unregister(&lpc32xx_ts_driver);\r\n}
