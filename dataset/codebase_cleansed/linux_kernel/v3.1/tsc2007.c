static inline int tsc2007_xfer(struct tsc2007 *tsc, u8 cmd)\r\n{\r\ns32 data;\r\nu16 val;\r\ndata = i2c_smbus_read_word_data(tsc->client, cmd);\r\nif (data < 0) {\r\ndev_err(&tsc->client->dev, "i2c io error: %d\n", data);\r\nreturn data;\r\n}\r\nval = swab16(data) >> 4;\r\ndev_dbg(&tsc->client->dev, "data: 0x%x, val: 0x%x\n", data, val);\r\nreturn val;\r\n}\r\nstatic void tsc2007_read_values(struct tsc2007 *tsc, struct ts_event *tc)\r\n{\r\ntc->y = tsc2007_xfer(tsc, READ_Y);\r\ntc->x = tsc2007_xfer(tsc, READ_X);\r\ntc->z1 = tsc2007_xfer(tsc, READ_Z1);\r\ntc->z2 = tsc2007_xfer(tsc, READ_Z2);\r\ntsc2007_xfer(tsc, PWRDOWN);\r\n}\r\nstatic u32 tsc2007_calculate_pressure(struct tsc2007 *tsc, struct ts_event *tc)\r\n{\r\nu32 rt = 0;\r\nif (tc->x == MAX_12BIT)\r\ntc->x = 0;\r\nif (likely(tc->x && tc->z1)) {\r\nrt = tc->z2 - tc->z1;\r\nrt *= tc->x;\r\nrt *= tsc->x_plate_ohms;\r\nrt /= tc->z1;\r\nrt = (rt + 2047) >> 12;\r\n}\r\nreturn rt;\r\n}\r\nstatic void tsc2007_send_up_event(struct tsc2007 *tsc)\r\n{\r\nstruct input_dev *input = tsc->input;\r\ndev_dbg(&tsc->client->dev, "UP\n");\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\ninput_sync(input);\r\n}\r\nstatic void tsc2007_work(struct work_struct *work)\r\n{\r\nstruct tsc2007 *ts =\r\ncontainer_of(to_delayed_work(work), struct tsc2007, work);\r\nbool debounced = false;\r\nstruct ts_event tc;\r\nu32 rt;\r\nif (ts->get_pendown_state) {\r\nif (unlikely(!ts->get_pendown_state())) {\r\ntsc2007_send_up_event(ts);\r\nts->pendown = false;\r\ngoto out;\r\n}\r\ndev_dbg(&ts->client->dev, "pen is still down\n");\r\n}\r\ntsc2007_read_values(ts, &tc);\r\nrt = tsc2007_calculate_pressure(ts, &tc);\r\nif (rt > ts->max_rt) {\r\ndev_dbg(&ts->client->dev, "ignored pressure %d\n", rt);\r\ndebounced = true;\r\ngoto out;\r\n}\r\nif (rt) {\r\nstruct input_dev *input = ts->input;\r\nif (!ts->pendown) {\r\ndev_dbg(&ts->client->dev, "DOWN\n");\r\ninput_report_key(input, BTN_TOUCH, 1);\r\nts->pendown = true;\r\n}\r\ninput_report_abs(input, ABS_X, tc.x);\r\ninput_report_abs(input, ABS_Y, tc.y);\r\ninput_report_abs(input, ABS_PRESSURE, rt);\r\ninput_sync(input);\r\ndev_dbg(&ts->client->dev, "point(%4d,%4d), pressure (%4u)\n",\r\ntc.x, tc.y, rt);\r\n} else if (!ts->get_pendown_state && ts->pendown) {\r\ntsc2007_send_up_event(ts);\r\nts->pendown = false;\r\n}\r\nout:\r\nif (ts->pendown || debounced)\r\nschedule_delayed_work(&ts->work,\r\nmsecs_to_jiffies(ts->poll_period));\r\nelse\r\nenable_irq(ts->irq);\r\n}\r\nstatic irqreturn_t tsc2007_irq(int irq, void *handle)\r\n{\r\nstruct tsc2007 *ts = handle;\r\nif (!ts->get_pendown_state || likely(ts->get_pendown_state())) {\r\ndisable_irq_nosync(ts->irq);\r\nschedule_delayed_work(&ts->work,\r\nmsecs_to_jiffies(ts->poll_delay));\r\n}\r\nif (ts->clear_penirq)\r\nts->clear_penirq();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsc2007_free_irq(struct tsc2007 *ts)\r\n{\r\nfree_irq(ts->irq, ts);\r\nif (cancel_delayed_work_sync(&ts->work)) {\r\nenable_irq(ts->irq);\r\n}\r\n}\r\nstatic int __devinit tsc2007_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tsc2007 *ts;\r\nstruct tsc2007_platform_data *pdata = client->dev.platform_data;\r\nstruct input_dev *input_dev;\r\nint err;\r\nif (!pdata) {\r\ndev_err(&client->dev, "platform data is required!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA))\r\nreturn -EIO;\r\nts = kzalloc(sizeof(struct tsc2007), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nts->client = client;\r\nts->irq = client->irq;\r\nts->input = input_dev;\r\nINIT_DELAYED_WORK(&ts->work, tsc2007_work);\r\nts->model = pdata->model;\r\nts->x_plate_ohms = pdata->x_plate_ohms;\r\nts->max_rt = pdata->max_rt ? : MAX_12BIT;\r\nts->poll_delay = pdata->poll_delay ? : 1;\r\nts->poll_period = pdata->poll_period ? : 1;\r\nts->get_pendown_state = pdata->get_pendown_state;\r\nts->clear_penirq = pdata->clear_penirq;\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input0", dev_name(&client->dev));\r\ninput_dev->name = "TSC2007 Touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, pdata->fuzzx, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, pdata->fuzzy, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT,\r\npdata->fuzzz, 0);\r\nif (pdata->init_platform_hw)\r\npdata->init_platform_hw();\r\nerr = request_irq(ts->irq, tsc2007_irq, 0,\r\nclient->dev.driver->name, ts);\r\nif (err < 0) {\r\ndev_err(&client->dev, "irq %d busy?\n", ts->irq);\r\ngoto err_free_mem;\r\n}\r\nerr = tsc2007_xfer(ts, PWRDOWN);\r\nif (err < 0)\r\ngoto err_free_irq;\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_free_irq;\r\ni2c_set_clientdata(client, ts);\r\nreturn 0;\r\nerr_free_irq:\r\ntsc2007_free_irq(ts);\r\nif (pdata->exit_platform_hw)\r\npdata->exit_platform_hw();\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ts);\r\nreturn err;\r\n}\r\nstatic int __devexit tsc2007_remove(struct i2c_client *client)\r\n{\r\nstruct tsc2007 *ts = i2c_get_clientdata(client);\r\nstruct tsc2007_platform_data *pdata = client->dev.platform_data;\r\ntsc2007_free_irq(ts);\r\nif (pdata->exit_platform_hw)\r\npdata->exit_platform_hw();\r\ninput_unregister_device(ts->input);\r\nkfree(ts);\r\nreturn 0;\r\n}\r\nstatic int __init tsc2007_init(void)\r\n{\r\nreturn i2c_add_driver(&tsc2007_driver);\r\n}\r\nstatic void __exit tsc2007_exit(void)\r\n{\r\ni2c_del_driver(&tsc2007_driver);\r\n}
