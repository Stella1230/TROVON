static int\r\nauxch_rd(struct drm_encoder *encoder, int address, uint8_t *buf, int size)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_i2c_chan *auxch;\r\nint ret;\r\nauxch = nouveau_i2c_find(dev, nv_encoder->dcb->i2c_index);\r\nif (!auxch)\r\nreturn -ENODEV;\r\nret = nouveau_dp_auxch(auxch, 9, address, buf, size);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int\r\nauxch_wr(struct drm_encoder *encoder, int address, uint8_t *buf, int size)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_i2c_chan *auxch;\r\nint ret;\r\nauxch = nouveau_i2c_find(dev, nv_encoder->dcb->i2c_index);\r\nif (!auxch)\r\nreturn -ENODEV;\r\nret = nouveau_dp_auxch(auxch, 8, address, buf, size);\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_dp_lane_count_set(struct drm_encoder *encoder, uint8_t cmd)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nuint32_t tmp;\r\nint or = nv_encoder->or, link = !(nv_encoder->dcb->sorconf.link & 1);\r\ntmp = nv_rd32(dev, NV50_SOR_DP_CTRL(or, link));\r\ntmp &= ~(NV50_SOR_DP_CTRL_ENHANCED_FRAME_ENABLED |\r\nNV50_SOR_DP_CTRL_LANE_MASK);\r\ntmp |= ((1 << (cmd & DP_LANE_COUNT_MASK)) - 1) << 16;\r\nif (cmd & DP_LANE_COUNT_ENHANCED_FRAME_EN)\r\ntmp |= NV50_SOR_DP_CTRL_ENHANCED_FRAME_ENABLED;\r\nnv_wr32(dev, NV50_SOR_DP_CTRL(or, link), tmp);\r\nreturn auxch_wr(encoder, DP_LANE_COUNT_SET, &cmd, 1);\r\n}\r\nstatic int\r\nnouveau_dp_link_bw_set(struct drm_encoder *encoder, uint8_t cmd)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nuint32_t tmp;\r\nint reg = 0x614300 + (nv_encoder->or * 0x800);\r\ntmp = nv_rd32(dev, reg);\r\ntmp &= 0xfff3ffff;\r\nif (cmd == DP_LINK_BW_2_7)\r\ntmp |= 0x00040000;\r\nnv_wr32(dev, reg, tmp);\r\nreturn auxch_wr(encoder, DP_LINK_BW_SET, &cmd, 1);\r\n}\r\nstatic int\r\nnouveau_dp_link_train_set(struct drm_encoder *encoder, int pattern)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nuint32_t tmp;\r\nuint8_t cmd;\r\nint or = nv_encoder->or, link = !(nv_encoder->dcb->sorconf.link & 1);\r\nint ret;\r\ntmp = nv_rd32(dev, NV50_SOR_DP_CTRL(or, link));\r\ntmp &= ~NV50_SOR_DP_CTRL_TRAINING_PATTERN;\r\ntmp |= (pattern << 24);\r\nnv_wr32(dev, NV50_SOR_DP_CTRL(or, link), tmp);\r\nret = auxch_rd(encoder, DP_TRAINING_PATTERN_SET, &cmd, 1);\r\nif (ret)\r\nreturn ret;\r\ncmd &= ~DP_TRAINING_PATTERN_MASK;\r\ncmd |= (pattern & DP_TRAINING_PATTERN_MASK);\r\nreturn auxch_wr(encoder, DP_TRAINING_PATTERN_SET, &cmd, 1);\r\n}\r\nstatic int\r\nnouveau_dp_max_voltage_swing(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct bit_displayport_encoder_table_entry *dpse;\r\nstruct bit_displayport_encoder_table *dpe;\r\nint i, dpe_headerlen, max_vs = 0;\r\ndpe = nouveau_bios_dp_table(dev, nv_encoder->dcb, &dpe_headerlen);\r\nif (!dpe)\r\nreturn false;\r\ndpse = (void *)((char *)dpe + dpe_headerlen);\r\nfor (i = 0; i < dpe_headerlen; i++, dpse++) {\r\nif (dpse->vs_level > max_vs)\r\nmax_vs = dpse->vs_level;\r\n}\r\nreturn max_vs;\r\n}\r\nstatic int\r\nnouveau_dp_max_pre_emphasis(struct drm_encoder *encoder, int vs)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct bit_displayport_encoder_table_entry *dpse;\r\nstruct bit_displayport_encoder_table *dpe;\r\nint i, dpe_headerlen, max_pre = 0;\r\ndpe = nouveau_bios_dp_table(dev, nv_encoder->dcb, &dpe_headerlen);\r\nif (!dpe)\r\nreturn false;\r\ndpse = (void *)((char *)dpe + dpe_headerlen);\r\nfor (i = 0; i < dpe_headerlen; i++, dpse++) {\r\nif (dpse->vs_level != vs)\r\ncontinue;\r\nif (dpse->pre_level > max_pre)\r\nmax_pre = dpse->pre_level;\r\n}\r\nreturn max_pre;\r\n}\r\nstatic bool\r\nnouveau_dp_link_train_adjust(struct drm_encoder *encoder, uint8_t *config)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct bit_displayport_encoder_table *dpe;\r\nint ret, i, dpe_headerlen, vs = 0, pre = 0;\r\nuint8_t request[2];\r\ndpe = nouveau_bios_dp_table(dev, nv_encoder->dcb, &dpe_headerlen);\r\nif (!dpe)\r\nreturn false;\r\nret = auxch_rd(encoder, DP_ADJUST_REQUEST_LANE0_1, request, 2);\r\nif (ret)\r\nreturn false;\r\nNV_DEBUG_KMS(dev, "\t\tadjust 0x%02x 0x%02x\n", request[0], request[1]);\r\nfor (i = 0; i < nv_encoder->dp.link_nr; i++) {\r\nint lane_req = (request[i >> 1] >> ((i & 1) << 2)) & 0xf;\r\nint lane_vs = lane_req & 3;\r\nint lane_pre = (lane_req >> 2) & 3;\r\nif (lane_vs > vs)\r\nvs = lane_vs;\r\nif (lane_pre > pre)\r\npre = lane_pre;\r\n}\r\nif (vs >= nouveau_dp_max_voltage_swing(encoder)) {\r\nvs = nouveau_dp_max_voltage_swing(encoder);\r\nvs |= 4;\r\n}\r\nif (pre >= nouveau_dp_max_pre_emphasis(encoder, vs & 3)) {\r\npre = nouveau_dp_max_pre_emphasis(encoder, vs & 3);\r\npre |= 4;\r\n}\r\nfor (i = 0; i < nv_encoder->dp.link_nr; i++)\r\nconfig[i] = (pre << 3) | vs;\r\nreturn true;\r\n}\r\nstatic bool\r\nnouveau_dp_link_train_commit(struct drm_encoder *encoder, uint8_t *config)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct bit_displayport_encoder_table_entry *dpse;\r\nstruct bit_displayport_encoder_table *dpe;\r\nint or = nv_encoder->or, link = !(nv_encoder->dcb->sorconf.link & 1);\r\nint dpe_headerlen, ret, i;\r\nNV_DEBUG_KMS(dev, "\t\tconfig 0x%02x 0x%02x 0x%02x 0x%02x\n",\r\nconfig[0], config[1], config[2], config[3]);\r\ndpe = nouveau_bios_dp_table(dev, nv_encoder->dcb, &dpe_headerlen);\r\nif (!dpe)\r\nreturn false;\r\ndpse = (void *)((char *)dpe + dpe_headerlen);\r\nfor (i = 0; i < dpe->record_nr; i++, dpse++) {\r\nif (dpse->vs_level == (config[0] & 3) &&\r\ndpse->pre_level == ((config[0] >> 3) & 3))\r\nbreak;\r\n}\r\nBUG_ON(i == dpe->record_nr);\r\nfor (i = 0; i < nv_encoder->dp.link_nr; i++) {\r\nconst int shift[4] = { 16, 8, 0, 24 };\r\nuint32_t mask = 0xff << shift[i];\r\nuint32_t reg0, reg1, reg2;\r\nreg0 = nv_rd32(dev, NV50_SOR_DP_UNK118(or, link)) & ~mask;\r\nreg0 |= (dpse->reg0 << shift[i]);\r\nreg1 = nv_rd32(dev, NV50_SOR_DP_UNK120(or, link)) & ~mask;\r\nreg1 |= (dpse->reg1 << shift[i]);\r\nreg2 = nv_rd32(dev, NV50_SOR_DP_UNK130(or, link)) & 0xffff00ff;\r\nreg2 |= (dpse->reg2 << 8);\r\nnv_wr32(dev, NV50_SOR_DP_UNK118(or, link), reg0);\r\nnv_wr32(dev, NV50_SOR_DP_UNK120(or, link), reg1);\r\nnv_wr32(dev, NV50_SOR_DP_UNK130(or, link), reg2);\r\n}\r\nret = auxch_wr(encoder, DP_TRAINING_LANE0_SET, config, 4);\r\nif (ret)\r\nreturn false;\r\nreturn true;\r\n}\r\nbool\r\nnouveau_dp_link_train(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_connector *nv_connector;\r\nstruct bit_displayport_encoder_table *dpe;\r\nint dpe_headerlen;\r\nuint8_t config[4], status[3];\r\nbool cr_done, cr_max_vs, eq_done, hpd_state;\r\nint ret = 0, i, tries, voltage;\r\nNV_DEBUG_KMS(dev, "link training!!\n");\r\nnv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nif (!nv_connector)\r\nreturn false;\r\ndpe = nouveau_bios_dp_table(dev, nv_encoder->dcb, &dpe_headerlen);\r\nif (!dpe) {\r\nNV_ERROR(dev, "SOR-%d: no DP encoder table!\n", nv_encoder->or);\r\nreturn false;\r\n}\r\nhpd_state = pgpio->irq_enable(dev, nv_connector->dcb->gpio_tag, false);\r\nif (dpe->script0) {\r\nNV_DEBUG_KMS(dev, "SOR-%d: running DP script 0\n", nv_encoder->or);\r\nnouveau_bios_run_init_table(dev, le16_to_cpu(dpe->script0),\r\nnv_encoder->dcb);\r\n}\r\ntrain:\r\ncr_done = eq_done = false;\r\nNV_DEBUG_KMS(dev, "\tbegin train: bw %d, lanes %d\n",\r\nnv_encoder->dp.link_bw, nv_encoder->dp.link_nr);\r\nret = nouveau_dp_link_bw_set(encoder, nv_encoder->dp.link_bw);\r\nif (ret)\r\nreturn false;\r\nconfig[0] = nv_encoder->dp.link_nr;\r\nif (nv_encoder->dp.dpcd_version >= 0x11 &&\r\nnv_encoder->dp.enhanced_frame)\r\nconfig[0] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\r\nret = nouveau_dp_lane_count_set(encoder, config[0]);\r\nif (ret)\r\nreturn false;\r\nNV_DEBUG_KMS(dev, "\tbegin cr\n");\r\nret = nouveau_dp_link_train_set(encoder, DP_TRAINING_PATTERN_1);\r\nif (ret)\r\ngoto stop;\r\ntries = 0;\r\nvoltage = -1;\r\nmemset(config, 0x00, sizeof(config));\r\nfor (;;) {\r\nif (!nouveau_dp_link_train_commit(encoder, config))\r\nbreak;\r\nudelay(100);\r\nret = auxch_rd(encoder, DP_LANE0_1_STATUS, status, 2);\r\nif (ret)\r\nbreak;\r\nNV_DEBUG_KMS(dev, "\t\tstatus: 0x%02x 0x%02x\n",\r\nstatus[0], status[1]);\r\ncr_done = true;\r\ncr_max_vs = false;\r\nfor (i = 0; i < nv_encoder->dp.link_nr; i++) {\r\nint lane = (status[i >> 1] >> ((i & 1) * 4)) & 0xf;\r\nif (!(lane & DP_LANE_CR_DONE)) {\r\ncr_done = false;\r\nif (config[i] & DP_TRAIN_MAX_PRE_EMPHASIS_REACHED)\r\ncr_max_vs = true;\r\nbreak;\r\n}\r\n}\r\nif ((config[0] & DP_TRAIN_VOLTAGE_SWING_MASK) != voltage) {\r\nvoltage = config[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\r\ntries = 0;\r\n}\r\nif (cr_done || cr_max_vs || (++tries == 5))\r\nbreak;\r\nif (!nouveau_dp_link_train_adjust(encoder, config))\r\nbreak;\r\n}\r\nif (!cr_done)\r\ngoto stop;\r\nNV_DEBUG_KMS(dev, "\tbegin eq\n");\r\nret = nouveau_dp_link_train_set(encoder, DP_TRAINING_PATTERN_2);\r\nif (ret)\r\ngoto stop;\r\nfor (tries = 0; tries <= 5; tries++) {\r\nudelay(400);\r\nret = auxch_rd(encoder, DP_LANE0_1_STATUS, status, 3);\r\nif (ret)\r\nbreak;\r\nNV_DEBUG_KMS(dev, "\t\tstatus: 0x%02x 0x%02x\n",\r\nstatus[0], status[1]);\r\neq_done = true;\r\nif (!(status[2] & DP_INTERLANE_ALIGN_DONE))\r\neq_done = false;\r\nfor (i = 0; eq_done && i < nv_encoder->dp.link_nr; i++) {\r\nint lane = (status[i >> 1] >> ((i & 1) * 4)) & 0xf;\r\nif (!(lane & DP_LANE_CR_DONE)) {\r\ncr_done = false;\r\nbreak;\r\n}\r\nif (!(lane & DP_LANE_CHANNEL_EQ_DONE) ||\r\n!(lane & DP_LANE_SYMBOL_LOCKED)) {\r\neq_done = false;\r\nbreak;\r\n}\r\n}\r\nif (eq_done || !cr_done)\r\nbreak;\r\nif (!nouveau_dp_link_train_adjust(encoder, config) ||\r\n!nouveau_dp_link_train_commit(encoder, config))\r\nbreak;\r\n}\r\nstop:\r\nret = nouveau_dp_link_train_set(encoder, DP_TRAINING_PATTERN_DISABLE);\r\nif (ret)\r\nreturn false;\r\nif (!ret && !(eq_done && cr_done)) {\r\nNV_DEBUG_KMS(dev, "\twe failed\n");\r\nif (nv_encoder->dp.link_bw != DP_LINK_BW_1_62) {\r\nNV_DEBUG_KMS(dev, "retry link training at low rate\n");\r\nnv_encoder->dp.link_bw = DP_LINK_BW_1_62;\r\ngoto train;\r\n}\r\n}\r\nif (dpe->script1) {\r\nNV_DEBUG_KMS(dev, "SOR-%d: running DP script 1\n", nv_encoder->or);\r\nnouveau_bios_run_init_table(dev, le16_to_cpu(dpe->script1),\r\nnv_encoder->dcb);\r\n}\r\npgpio->irq_enable(dev, nv_connector->dcb->gpio_tag, hpd_state);\r\nreturn eq_done;\r\n}\r\nbool\r\nnouveau_dp_detect(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nuint8_t dpcd[4];\r\nint ret;\r\nret = auxch_rd(encoder, 0x0000, dpcd, 4);\r\nif (ret)\r\nreturn false;\r\nNV_DEBUG_KMS(dev, "encoder: link_bw %d, link_nr %d\n"\r\n"display: link_bw %d, link_nr %d version 0x%02x\n",\r\nnv_encoder->dcb->dpconf.link_bw,\r\nnv_encoder->dcb->dpconf.link_nr,\r\ndpcd[1], dpcd[2] & 0x0f, dpcd[0]);\r\nnv_encoder->dp.dpcd_version = dpcd[0];\r\nnv_encoder->dp.link_bw = dpcd[1];\r\nif (nv_encoder->dp.link_bw != DP_LINK_BW_1_62 &&\r\n!nv_encoder->dcb->dpconf.link_bw)\r\nnv_encoder->dp.link_bw = DP_LINK_BW_1_62;\r\nnv_encoder->dp.link_nr = dpcd[2] & DP_MAX_LANE_COUNT_MASK;\r\nif (nv_encoder->dp.link_nr > nv_encoder->dcb->dpconf.link_nr)\r\nnv_encoder->dp.link_nr = nv_encoder->dcb->dpconf.link_nr;\r\nnv_encoder->dp.enhanced_frame = (dpcd[2] & DP_ENHANCED_FRAME_CAP);\r\nreturn true;\r\n}\r\nint\r\nnouveau_dp_auxch(struct nouveau_i2c_chan *auxch, int cmd, int addr,\r\nuint8_t *data, int data_nr)\r\n{\r\nstruct drm_device *dev = auxch->dev;\r\nuint32_t tmp, ctrl, stat = 0, data32[4] = {};\r\nint ret = 0, i, index = auxch->rd;\r\nNV_DEBUG_KMS(dev, "ch %d cmd %d addr 0x%x len %d\n", index, cmd, addr, data_nr);\r\ntmp = nv_rd32(dev, NV50_AUXCH_CTRL(auxch->rd));\r\nnv_wr32(dev, NV50_AUXCH_CTRL(auxch->rd), tmp | 0x00100000);\r\ntmp = nv_rd32(dev, NV50_AUXCH_CTRL(auxch->rd));\r\nif (!(tmp & 0x01000000)) {\r\nNV_ERROR(dev, "expected bit 24 == 1, got 0x%08x\n", tmp);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\ntmp = nv_rd32(dev, NV50_AUXCH_STAT(auxch->rd));\r\nif (tmp & NV50_AUXCH_STAT_STATE_READY)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (i == 3) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (!(cmd & 1)) {\r\nmemcpy(data32, data, data_nr);\r\nfor (i = 0; i < 4; i++) {\r\nNV_DEBUG_KMS(dev, "wr %d: 0x%08x\n", i, data32[i]);\r\nnv_wr32(dev, NV50_AUXCH_DATA_OUT(index, i), data32[i]);\r\n}\r\n}\r\nnv_wr32(dev, NV50_AUXCH_ADDR(index), addr);\r\nctrl = nv_rd32(dev, NV50_AUXCH_CTRL(index));\r\nctrl &= ~(NV50_AUXCH_CTRL_CMD | NV50_AUXCH_CTRL_LEN);\r\nctrl |= (cmd << NV50_AUXCH_CTRL_CMD_SHIFT);\r\nctrl |= ((data_nr - 1) << NV50_AUXCH_CTRL_LEN_SHIFT);\r\nfor (i = 0; i < 16; i++) {\r\nnv_wr32(dev, NV50_AUXCH_CTRL(index), ctrl | 0x80000000);\r\nnv_wr32(dev, NV50_AUXCH_CTRL(index), ctrl);\r\nnv_wr32(dev, NV50_AUXCH_CTRL(index), ctrl | 0x00010000);\r\nif (!nv_wait(dev, NV50_AUXCH_CTRL(index),\r\n0x00010000, 0x00000000)) {\r\nNV_ERROR(dev, "expected bit 16 == 0, got 0x%08x\n",\r\nnv_rd32(dev, NV50_AUXCH_CTRL(index)));\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nudelay(400);\r\nstat = nv_rd32(dev, NV50_AUXCH_STAT(index));\r\nif ((stat & NV50_AUXCH_STAT_REPLY_AUX) !=\r\nNV50_AUXCH_STAT_REPLY_AUX_DEFER)\r\nbreak;\r\n}\r\nif (i == 16) {\r\nNV_ERROR(dev, "auxch DEFER too many times, bailing\n");\r\nret = -EREMOTEIO;\r\ngoto out;\r\n}\r\nif (cmd & 1) {\r\nif ((stat & NV50_AUXCH_STAT_COUNT) != data_nr) {\r\nret = -EREMOTEIO;\r\ngoto out;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ndata32[i] = nv_rd32(dev, NV50_AUXCH_DATA_IN(index, i));\r\nNV_DEBUG_KMS(dev, "rd %d: 0x%08x\n", i, data32[i]);\r\n}\r\nmemcpy(data, data32, data_nr);\r\n}\r\nout:\r\ntmp = nv_rd32(dev, NV50_AUXCH_CTRL(auxch->rd));\r\nnv_wr32(dev, NV50_AUXCH_CTRL(auxch->rd), tmp & ~0x00100000);\r\ntmp = nv_rd32(dev, NV50_AUXCH_CTRL(auxch->rd));\r\nif (tmp & 0x01000000) {\r\nNV_ERROR(dev, "expected bit 24 == 0, got 0x%08x\n", tmp);\r\nret = -EIO;\r\n}\r\nudelay(400);\r\nreturn ret ? ret : (stat & NV50_AUXCH_STAT_REPLY);\r\n}\r\nstatic int\r\nnouveau_dp_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct nouveau_i2c_chan *auxch = (struct nouveau_i2c_chan *)adap;\r\nstruct drm_device *dev = auxch->dev;\r\nstruct i2c_msg *msg = msgs;\r\nint ret, mcnt = num;\r\nwhile (mcnt--) {\r\nu8 remaining = msg->len;\r\nu8 *ptr = msg->buf;\r\nwhile (remaining) {\r\nu8 cnt = (remaining > 16) ? 16 : remaining;\r\nu8 cmd;\r\nif (msg->flags & I2C_M_RD)\r\ncmd = AUX_I2C_READ;\r\nelse\r\ncmd = AUX_I2C_WRITE;\r\nif (mcnt || remaining > 16)\r\ncmd |= AUX_I2C_MOT;\r\nret = nouveau_dp_auxch(auxch, cmd, msg->addr, ptr, cnt);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (ret & NV50_AUXCH_STAT_REPLY_I2C) {\r\ncase NV50_AUXCH_STAT_REPLY_I2C_ACK:\r\nbreak;\r\ncase NV50_AUXCH_STAT_REPLY_I2C_NACK:\r\nreturn -EREMOTEIO;\r\ncase NV50_AUXCH_STAT_REPLY_I2C_DEFER:\r\nudelay(100);\r\ncontinue;\r\ndefault:\r\nNV_ERROR(dev, "bad auxch reply: 0x%08x\n", ret);\r\nreturn -EREMOTEIO;\r\n}\r\nptr += cnt;\r\nremaining -= cnt;\r\n}\r\nmsg++;\r\n}\r\nreturn num;\r\n}\r\nstatic u32\r\nnouveau_dp_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}
