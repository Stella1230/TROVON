int dbg_set_reg(int regno, void *mem, struct pt_regs *regs)\r\n{\r\nint fp_reg;\r\nif (regno < 0 || regno >= DBG_MAX_REG_NUM)\r\nreturn -EINVAL;\r\nif (dbg_reg_def[regno].offset != -1 && regno < 38) {\r\nmemcpy((void *)regs + dbg_reg_def[regno].offset, mem,\r\ndbg_reg_def[regno].size);\r\n} else if (current && dbg_reg_def[regno].offset != -1 && regno < 72) {\r\nif (!(regs->cp0_status & ST0_CU1))\r\nreturn 0;\r\nif (regno == 70) {\r\nmemcpy((void *)&current->thread.fpu.fcr31, mem,\r\ndbg_reg_def[regno].size);\r\ngoto out_save;\r\n} else if (regno == 71) {\r\ngoto out_save;\r\n}\r\nfp_reg = dbg_reg_def[regno].offset;\r\nmemcpy((void *)&current->thread.fpu.fpr[fp_reg], mem,\r\ndbg_reg_def[regno].size);\r\nout_save:\r\nrestore_fp(current);\r\n}\r\nreturn 0;\r\n}\r\nchar *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)\r\n{\r\nint fp_reg;\r\nif (regno >= DBG_MAX_REG_NUM || regno < 0)\r\nreturn NULL;\r\nif (dbg_reg_def[regno].offset != -1 && regno < 38) {\r\nmemcpy(mem, (void *)regs + dbg_reg_def[regno].offset,\r\ndbg_reg_def[regno].size);\r\n} else if (current && dbg_reg_def[regno].offset != -1 && regno < 72) {\r\nif (!(regs->cp0_status & ST0_CU1))\r\ngoto out;\r\nsave_fp(current);\r\nif (regno == 70) {\r\nmemcpy(mem, (void *)&current->thread.fpu.fcr31,\r\ndbg_reg_def[regno].size);\r\ngoto out;\r\n} else if (regno == 71) {\r\nmemset(mem, 0, dbg_reg_def[regno].size);\r\ngoto out;\r\n}\r\nfp_reg = dbg_reg_def[regno].offset;\r\nmemcpy(mem, (void *)&current->thread.fpu.fpr[fp_reg],\r\ndbg_reg_def[regno].size);\r\n}\r\nout:\r\nreturn dbg_reg_def[regno].name;\r\n}\r\nvoid arch_kgdb_breakpoint(void)\r\n{\r\n__asm__ __volatile__(\r\n".globl breakinst\n\t"\r\n".set\tnoreorder\n\t"\r\n"nop\n"\r\n"breakinst:\tbreak\n\t"\r\n"nop\n\t"\r\n".set\treorder");\r\n}\r\nstatic void kgdb_call_nmi_hook(void *ignored)\r\n{\r\nkgdb_nmicallback(raw_smp_processor_id(), NULL);\r\n}\r\nvoid kgdb_roundup_cpus(unsigned long flags)\r\n{\r\nlocal_irq_enable();\r\nsmp_call_function(kgdb_call_nmi_hook, NULL, 0);\r\nlocal_irq_disable();\r\n}\r\nstatic int compute_signal(int tt)\r\n{\r\nstruct hard_trap_info *ht;\r\nfor (ht = hard_trap_info; ht->tt && ht->signo; ht++)\r\nif (ht->tt == tt)\r\nreturn ht->signo;\r\nreturn SIGHUP;\r\n}\r\nvoid sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)\r\n{\r\nint reg;\r\nstruct thread_info *ti = task_thread_info(p);\r\nunsigned long ksp = (unsigned long)ti + THREAD_SIZE - 32;\r\nstruct pt_regs *regs = (struct pt_regs *)ksp - 1;\r\n#if (KGDB_GDB_REG_SIZE == 32)\r\nu32 *ptr = (u32 *)gdb_regs;\r\n#else\r\nu64 *ptr = (u64 *)gdb_regs;\r\n#endif\r\nfor (reg = 0; reg < 16; reg++)\r\n*(ptr++) = regs->regs[reg];\r\nfor (reg = 16; reg < 24; reg++)\r\n*(ptr++) = regs->regs[reg];\r\nfor (reg = 24; reg < 28; reg++)\r\n*(ptr++) = 0;\r\nfor (reg = 28; reg < 32; reg++)\r\n*(ptr++) = regs->regs[reg];\r\n*(ptr++) = regs->cp0_status;\r\n*(ptr++) = regs->lo;\r\n*(ptr++) = regs->hi;\r\n*(ptr++) = regs->cp0_badvaddr;\r\n*(ptr++) = regs->cp0_cause;\r\n*(ptr++) = regs->cp0_epc;\r\n}\r\nvoid kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)\r\n{\r\nregs->cp0_epc = pc;\r\n}\r\nstatic int kgdb_mips_notify(struct notifier_block *self, unsigned long cmd,\r\nvoid *ptr)\r\n{\r\nstruct die_args *args = (struct die_args *)ptr;\r\nstruct pt_regs *regs = args->regs;\r\nint trap = (regs->cp0_cause & 0x7c) >> 2;\r\nif (user_mode(regs))\r\nreturn NOTIFY_DONE;\r\nif (atomic_read(&kgdb_active) != -1)\r\nkgdb_nmicallback(smp_processor_id(), regs);\r\nif (kgdb_handle_exception(trap, compute_signal(trap), cmd, regs))\r\nreturn NOTIFY_DONE;\r\nif (atomic_read(&kgdb_setting_breakpoint))\r\nif ((trap == 9) && (regs->cp0_epc == (unsigned long)breakinst))\r\nregs->cp0_epc += 4;\r\nlocal_irq_enable();\r\n__flush_cache_all();\r\nreturn NOTIFY_STOP;\r\n}\r\nint kgdb_ll_trap(int cmd, const char *str,\r\nstruct pt_regs *regs, long err, int trap, int sig)\r\n{\r\nstruct die_args args = {\r\n.regs = regs,\r\n.str = str,\r\n.err = err,\r\n.trapnr = trap,\r\n.signr = sig,\r\n};\r\nif (!kgdb_io_module_registered)\r\nreturn NOTIFY_DONE;\r\nreturn kgdb_mips_notify(NULL, cmd, &args);\r\n}\r\nint kgdb_arch_handle_exception(int vector, int signo, int err_code,\r\nchar *remcom_in_buffer, char *remcom_out_buffer,\r\nstruct pt_regs *regs)\r\n{\r\nchar *ptr;\r\nunsigned long address;\r\nswitch (remcom_in_buffer[0]) {\r\ncase 'c':\r\nptr = &remcom_in_buffer[1];\r\nif (kgdb_hex2long(&ptr, &address))\r\nregs->cp0_epc = address;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nint kgdb_arch_init(void)\r\n{\r\nunion mips_instruction insn = {\r\n.r_format = {\r\n.opcode = spec_op,\r\n.func = break_op,\r\n}\r\n};\r\nmemcpy(arch_kgdb_ops.gdb_bpt_instr, insn.byte, BREAK_INSTR_SIZE);\r\nregister_die_notifier(&kgdb_notifier);\r\nreturn 0;\r\n}\r\nvoid kgdb_arch_exit(void)\r\n{\r\nunregister_die_notifier(&kgdb_notifier);\r\n}
