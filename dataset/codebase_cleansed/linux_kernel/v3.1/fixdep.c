static void usage(void)\r\n{\r\nfprintf(stderr, "Usage: fixdep <depfile> <target> <cmdline>\n");\r\nexit(1);\r\n}\r\nstatic void print_cmdline(void)\r\n{\r\nprintf("cmd_%s := %s\n\n", target, cmdline);\r\n}\r\nstatic unsigned int strhash(const char *str, unsigned int sz)\r\n{\r\nunsigned int i, hash = 2166136261U;\r\nfor (i = 0; i < sz; i++)\r\nhash = (hash ^ str[i]) * 0x01000193;\r\nreturn hash;\r\n}\r\nstatic int is_defined_config(const char *name, int len, unsigned int hash)\r\n{\r\nstruct item *aux;\r\nfor (aux = hashtab[hash % HASHSZ]; aux; aux = aux->next) {\r\nif (aux->hash == hash && aux->len == len &&\r\nmemcmp(aux->name, name, len) == 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void define_config(const char *name, int len, unsigned int hash)\r\n{\r\nstruct item *aux = malloc(sizeof(*aux) + len);\r\nif (!aux) {\r\nperror("fixdep:malloc");\r\nexit(1);\r\n}\r\nmemcpy(aux->name, name, len);\r\naux->len = len;\r\naux->hash = hash;\r\naux->next = hashtab[hash % HASHSZ];\r\nhashtab[hash % HASHSZ] = aux;\r\n}\r\nstatic void clear_config(void)\r\n{\r\nstruct item *aux, *next;\r\nunsigned int i;\r\nfor (i = 0; i < HASHSZ; i++) {\r\nfor (aux = hashtab[i]; aux; aux = next) {\r\nnext = aux->next;\r\nfree(aux);\r\n}\r\nhashtab[i] = NULL;\r\n}\r\n}\r\nstatic void use_config(const char *m, int slen)\r\n{\r\nunsigned int hash = strhash(m, slen);\r\nint c, i;\r\nif (is_defined_config(m, slen, hash))\r\nreturn;\r\ndefine_config(m, slen, hash);\r\nprintf(" $(wildcard include/config/");\r\nfor (i = 0; i < slen; i++) {\r\nc = m[i];\r\nif (c == '_')\r\nc = '/';\r\nelse\r\nc = tolower(c);\r\nputchar(c);\r\n}\r\nprintf(".h) \\\n");\r\n}\r\nstatic void parse_config_file(const char *map, size_t len)\r\n{\r\nconst int *end = (const int *) (map + len);\r\nconst int *m = (const int *) map + 1;\r\nconst char *p, *q;\r\nfor (; m < end; m++) {\r\nif (*m == INT_CONF) { p = (char *) m ; goto conf; }\r\nif (*m == INT_ONFI) { p = (char *) m-1; goto conf; }\r\nif (*m == INT_NFIG) { p = (char *) m-2; goto conf; }\r\nif (*m == INT_FIG_) { p = (char *) m-3; goto conf; }\r\ncontinue;\r\nconf:\r\nif (p > map + len - 7)\r\ncontinue;\r\nif (memcmp(p, "CONFIG_", 7))\r\ncontinue;\r\nfor (q = p + 7; q < map + len; q++) {\r\nif (!(isalnum(*q) || *q == '_'))\r\ngoto found;\r\n}\r\ncontinue;\r\nfound:\r\nif (!memcmp(q - 7, "_MODULE", 7))\r\nq -= 7;\r\nif( (q-p-7) < 0 )\r\ncontinue;\r\nuse_config(p+7, q-p-7);\r\n}\r\n}\r\nstatic int strrcmp(char *s, char *sub)\r\n{\r\nint slen = strlen(s);\r\nint sublen = strlen(sub);\r\nif (sublen > slen)\r\nreturn 1;\r\nreturn memcmp(s + slen - sublen, sub, sublen);\r\n}\r\nstatic void do_config_file(const char *filename)\r\n{\r\nstruct stat st;\r\nint fd;\r\nvoid *map;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0) {\r\nfprintf(stderr, "fixdep: error opening config file: ");\r\nperror(filename);\r\nexit(2);\r\n}\r\nfstat(fd, &st);\r\nif (st.st_size == 0) {\r\nclose(fd);\r\nreturn;\r\n}\r\nmap = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\r\nif ((long) map == -1) {\r\nperror("fixdep: mmap");\r\nclose(fd);\r\nreturn;\r\n}\r\nparse_config_file(map, st.st_size);\r\nmunmap(map, st.st_size);\r\nclose(fd);\r\n}\r\nstatic void parse_dep_file(void *map, size_t len)\r\n{\r\nchar *m = map;\r\nchar *end = m + len;\r\nchar *p;\r\nchar s[PATH_MAX];\r\nint first;\r\np = strchr(m, ':');\r\nif (!p) {\r\nfprintf(stderr, "fixdep: parse error\n");\r\nexit(1);\r\n}\r\nmemcpy(s, m, p-m); s[p-m] = 0;\r\nm = p+1;\r\nclear_config();\r\nfirst = 1;\r\nwhile (m < end) {\r\nwhile (m < end && (*m == ' ' || *m == '\\' || *m == '\n'))\r\nm++;\r\np = m;\r\nwhile (p < end && *p != ' ') p++;\r\nif (p == end) {\r\ndo p--; while (!isalnum(*p));\r\np++;\r\n}\r\nmemcpy(s, m, p-m); s[p-m] = 0;\r\nif (strrcmp(s, "include/generated/autoconf.h") &&\r\nstrrcmp(s, "arch/um/include/uml-config.h") &&\r\nstrrcmp(s, ".ver")) {\r\nif (first) {\r\nprintf("source_%s := %s\n\n", target, s);\r\nprintf("deps_%s := \\\n", target);\r\n} else\r\nprintf(" %s \\\n", s);\r\ndo_config_file(s);\r\n}\r\nfirst = 0;\r\nm = p + 1;\r\n}\r\nprintf("\n%s: $(deps_%s)\n\n", target, target);\r\nprintf("$(deps_%s):\n", target);\r\n}\r\nstatic void print_deps(void)\r\n{\r\nstruct stat st;\r\nint fd;\r\nvoid *map;\r\nfd = open(depfile, O_RDONLY);\r\nif (fd < 0) {\r\nfprintf(stderr, "fixdep: error opening depfile: ");\r\nperror(depfile);\r\nexit(2);\r\n}\r\nif (fstat(fd, &st) < 0) {\r\nfprintf(stderr, "fixdep: error fstat'ing depfile: ");\r\nperror(depfile);\r\nexit(2);\r\n}\r\nif (st.st_size == 0) {\r\nfprintf(stderr,"fixdep: %s is empty\n",depfile);\r\nclose(fd);\r\nreturn;\r\n}\r\nmap = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\r\nif ((long) map == -1) {\r\nperror("fixdep: mmap");\r\nclose(fd);\r\nreturn;\r\n}\r\nparse_dep_file(map, st.st_size);\r\nmunmap(map, st.st_size);\r\nclose(fd);\r\n}\r\nstatic void traps(void)\r\n{\r\nstatic char test[] __attribute__((aligned(sizeof(int)))) = "CONF";\r\nint *p = (int *)test;\r\nif (*p != INT_CONF) {\r\nfprintf(stderr, "fixdep: sizeof(int) != 4 or wrong endianess? %#x\n",\r\n*p);\r\nexit(2);\r\n}\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\ntraps();\r\nif (argc != 4)\r\nusage();\r\ndepfile = argv[1];\r\ntarget = argv[2];\r\ncmdline = argv[3];\r\nprint_cmdline();\r\nprint_deps();\r\nreturn 0;\r\n}
