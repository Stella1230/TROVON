static struct hid_report *picolcd_report(int id, struct hid_device *hdev, int dir)\r\n{\r\nstruct list_head *feature_report_list = &hdev->report_enum[dir].report_list;\r\nstruct hid_report *report = NULL;\r\nlist_for_each_entry(report, feature_report_list, list) {\r\nif (report->id == id)\r\nreturn report;\r\n}\r\nhid_warn(hdev, "No report with id 0x%x found\n", id);\r\nreturn NULL;\r\n}\r\nstatic struct picolcd_pending *picolcd_send_and_wait(struct hid_device *hdev,\r\nint report_id, const u8 *raw_data, int size)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nstruct picolcd_pending *work;\r\nstruct hid_report *report = picolcd_out_report(report_id, hdev);\r\nunsigned long flags;\r\nint i, j, k;\r\nif (!report || !data)\r\nreturn NULL;\r\nif (data->status & PICOLCD_FAILED)\r\nreturn NULL;\r\nwork = kzalloc(sizeof(*work), GFP_KERNEL);\r\nif (!work)\r\nreturn NULL;\r\ninit_completion(&work->ready);\r\nwork->out_report = report;\r\nwork->in_report = NULL;\r\nwork->raw_size = 0;\r\nmutex_lock(&data->mutex);\r\nspin_lock_irqsave(&data->lock, flags);\r\nfor (i = k = 0; i < report->maxfield; i++)\r\nfor (j = 0; j < report->field[i]->report_count; j++) {\r\nhid_set_field(report->field[i], j, k < size ? raw_data[k] : 0);\r\nk++;\r\n}\r\ndata->pending = work;\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nwait_for_completion_interruptible_timeout(&work->ready, HZ*2);\r\nspin_lock_irqsave(&data->lock, flags);\r\ndata->pending = NULL;\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nmutex_unlock(&data->mutex);\r\nreturn work;\r\n}\r\nstatic int picolcd_fb_send_tile(struct hid_device *hdev, int chip, int tile)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nstruct hid_report *report1 = picolcd_out_report(REPORT_LCD_CMD_DATA, hdev);\r\nstruct hid_report *report2 = picolcd_out_report(REPORT_LCD_DATA, hdev);\r\nunsigned long flags;\r\nu8 *tdata;\r\nint i;\r\nif (!report1 || report1->maxfield != 1 || !report2 || report2->maxfield != 1)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhid_set_field(report1->field[0], 0, chip << 2);\r\nhid_set_field(report1->field[0], 1, 0x02);\r\nhid_set_field(report1->field[0], 2, 0x00);\r\nhid_set_field(report1->field[0], 3, 0x00);\r\nhid_set_field(report1->field[0], 4, 0xb8 | tile);\r\nhid_set_field(report1->field[0], 5, 0x00);\r\nhid_set_field(report1->field[0], 6, 0x00);\r\nhid_set_field(report1->field[0], 7, 0x40);\r\nhid_set_field(report1->field[0], 8, 0x00);\r\nhid_set_field(report1->field[0], 9, 0x00);\r\nhid_set_field(report1->field[0], 10, 32);\r\nhid_set_field(report2->field[0], 0, (chip << 2) | 0x01);\r\nhid_set_field(report2->field[0], 1, 0x00);\r\nhid_set_field(report2->field[0], 2, 0x00);\r\nhid_set_field(report2->field[0], 3, 32);\r\ntdata = data->fb_vbitmap + (tile * 4 + chip) * 64;\r\nfor (i = 0; i < 64; i++)\r\nif (i < 32)\r\nhid_set_field(report1->field[0], 11 + i, tdata[i]);\r\nelse\r\nhid_set_field(report2->field[0], 4 + i - 32, tdata[i]);\r\nusbhid_submit_report(data->hdev, report1, USB_DIR_OUT);\r\nusbhid_submit_report(data->hdev, report2, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int picolcd_fb_update_tile(u8 *vbitmap, const u8 *bitmap, int bpp,\r\nint chip, int tile)\r\n{\r\nint i, b, changed = 0;\r\nu8 tdata[64];\r\nu8 *vdata = vbitmap + (tile * 4 + chip) * 64;\r\nif (bpp == 1) {\r\nfor (b = 7; b >= 0; b--) {\r\nconst u8 *bdata = bitmap + tile * 256 + chip * 8 + b * 32;\r\nfor (i = 0; i < 64; i++) {\r\ntdata[i] <<= 1;\r\ntdata[i] |= (bdata[i/8] >> (i % 8)) & 0x01;\r\n}\r\n}\r\n} else if (bpp == 8) {\r\nfor (b = 7; b >= 0; b--) {\r\nconst u8 *bdata = bitmap + (tile * 256 + chip * 8 + b * 32) * 8;\r\nfor (i = 0; i < 64; i++) {\r\ntdata[i] <<= 1;\r\ntdata[i] |= (bdata[i] & 0x80) ? 0x01 : 0x00;\r\n}\r\n}\r\n} else {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 64; i++)\r\nif (tdata[i] != vdata[i]) {\r\nchanged = 1;\r\nvdata[i] = tdata[i];\r\n}\r\nreturn changed;\r\n}\r\nstatic int picolcd_fb_reset(struct picolcd_data *data, int clear)\r\n{\r\nstruct hid_report *report = picolcd_out_report(REPORT_LCD_CMD, data->hdev);\r\nint i, j;\r\nunsigned long flags;\r\nstatic const u8 mapcmd[8] = { 0x00, 0x02, 0x00, 0x64, 0x3f, 0x00, 0x64, 0xc0 };\r\nif (!report || report->maxfield != 1)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&data->lock, flags);\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = 0; j < report->field[0]->maxusage; j++)\r\nif (j == 0)\r\nhid_set_field(report->field[0], j, i << 2);\r\nelse if (j < sizeof(mapcmd))\r\nhid_set_field(report->field[0], j, mapcmd[j]);\r\nelse\r\nhid_set_field(report->field[0], j, 0);\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\n}\r\ndata->status |= PICOLCD_READY_FB;\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nif (data->fb_bitmap) {\r\nif (clear) {\r\nmemset(data->fb_vbitmap, 0, PICOLCDFB_SIZE);\r\nmemset(data->fb_bitmap, 0, PICOLCDFB_SIZE*data->fb_bpp);\r\n}\r\ndata->fb_force = 1;\r\n}\r\nif (data->fb_info)\r\nschedule_delayed_work(&data->fb_info->deferred_work, 0);\r\nreturn 0;\r\n}\r\nstatic void picolcd_fb_update(struct picolcd_data *data)\r\n{\r\nint chip, tile, n;\r\nunsigned long flags;\r\nif (!data)\r\nreturn;\r\nspin_lock_irqsave(&data->lock, flags);\r\nif (!(data->status & PICOLCD_READY_FB)) {\r\nspin_unlock_irqrestore(&data->lock, flags);\r\npicolcd_fb_reset(data, 0);\r\n} else {\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\nn = 0;\r\nfor (chip = 0; chip < 4; chip++)\r\nfor (tile = 0; tile < 8; tile++)\r\nif (picolcd_fb_update_tile(data->fb_vbitmap,\r\ndata->fb_bitmap, data->fb_bpp, chip, tile) ||\r\ndata->fb_force) {\r\nn += 2;\r\nif (!data->fb_info->par)\r\nreturn;\r\nif (n >= HID_OUTPUT_FIFO_SIZE / 2) {\r\nusbhid_wait_io(data->hdev);\r\nn = 0;\r\n}\r\npicolcd_fb_send_tile(data->hdev, chip, tile);\r\n}\r\ndata->fb_force = false;\r\nif (n)\r\nusbhid_wait_io(data->hdev);\r\n}\r\nstatic void picolcd_fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nif (!info->par)\r\nreturn;\r\nsys_fillrect(info, rect);\r\nschedule_delayed_work(&info->deferred_work, 0);\r\n}\r\nstatic void picolcd_fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nif (!info->par)\r\nreturn;\r\nsys_copyarea(info, area);\r\nschedule_delayed_work(&info->deferred_work, 0);\r\n}\r\nstatic void picolcd_fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nif (!info->par)\r\nreturn;\r\nsys_imageblit(info, image);\r\nschedule_delayed_work(&info->deferred_work, 0);\r\n}\r\nstatic ssize_t picolcd_fb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nif (!info->par)\r\nreturn -ENODEV;\r\nret = fb_sys_write(info, buf, count, ppos);\r\nif (ret >= 0)\r\nschedule_delayed_work(&info->deferred_work, 0);\r\nreturn ret;\r\n}\r\nstatic int picolcd_fb_blank(int blank, struct fb_info *info)\r\n{\r\nif (!info->par)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void picolcd_fb_destroy(struct fb_info *info)\r\n{\r\nstruct picolcd_data *data = info->par;\r\nu32 *ref_cnt = info->pseudo_palette;\r\nint may_release;\r\ninfo->par = NULL;\r\nif (data)\r\ndata->fb_info = NULL;\r\nfb_deferred_io_cleanup(info);\r\nref_cnt--;\r\nmutex_lock(&info->lock);\r\n(*ref_cnt)--;\r\nmay_release = !*ref_cnt;\r\nmutex_unlock(&info->lock);\r\nif (may_release) {\r\nvfree((u8 *)info->fix.smem_start);\r\nframebuffer_release(info);\r\n}\r\n}\r\nstatic int picolcd_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\n__u32 bpp = var->bits_per_pixel;\r\n__u32 activate = var->activate;\r\n*var = picolcdfb_var;\r\nvar->activate = activate;\r\nif (bpp >= 8) {\r\nvar->bits_per_pixel = 8;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\n} else {\r\nvar->bits_per_pixel = 1;\r\nvar->red.length = 1;\r\nvar->green.length = 1;\r\nvar->blue.length = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int picolcd_set_par(struct fb_info *info)\r\n{\r\nstruct picolcd_data *data = info->par;\r\nu8 *tmp_fb, *o_fb;\r\nif (!data)\r\nreturn -ENODEV;\r\nif (info->var.bits_per_pixel == data->fb_bpp)\r\nreturn 0;\r\nif (info->var.bits_per_pixel != 1 && info->var.bits_per_pixel != 8)\r\nreturn -EINVAL;\r\no_fb = data->fb_bitmap;\r\ntmp_fb = kmalloc(PICOLCDFB_SIZE*info->var.bits_per_pixel, GFP_KERNEL);\r\nif (!tmp_fb)\r\nreturn -ENOMEM;\r\nif (info->var.bits_per_pixel == 1) {\r\nint i, b;\r\nfor (i = 0; i < PICOLCDFB_SIZE; i++) {\r\nu8 p = 0;\r\nfor (b = 0; b < 8; b++) {\r\np <<= 1;\r\np |= o_fb[i*8+b] ? 0x01 : 0x00;\r\n}\r\ntmp_fb[i] = p;\r\n}\r\nmemcpy(o_fb, tmp_fb, PICOLCDFB_SIZE);\r\ninfo->fix.visual = FB_VISUAL_MONO01;\r\ninfo->fix.line_length = PICOLCDFB_WIDTH / 8;\r\n} else {\r\nint i;\r\nmemcpy(tmp_fb, o_fb, PICOLCDFB_SIZE);\r\nfor (i = 0; i < PICOLCDFB_SIZE * 8; i++)\r\no_fb[i] = tmp_fb[i/8] & (0x01 << (7 - i % 8)) ? 0xff : 0x00;\r\ninfo->fix.visual = FB_VISUAL_DIRECTCOLOR;\r\ninfo->fix.line_length = PICOLCDFB_WIDTH;\r\n}\r\nkfree(tmp_fb);\r\ndata->fb_bpp = info->var.bits_per_pixel;\r\nreturn 0;\r\n}\r\nstatic void picolcd_fb_do_cleanup(struct work_struct *data)\r\n{\r\nstruct picolcd_fb_cleanup_item *item;\r\nunsigned long flags;\r\ndo {\r\nspin_lock_irqsave(&fb_pending_lock, flags);\r\nitem = fb_pending;\r\nfb_pending = item ? item->next : NULL;\r\nspin_unlock_irqrestore(&fb_pending_lock, flags);\r\nif (item) {\r\nu8 *fb = (u8 *)item->info->fix.smem_start;\r\nmutex_lock(&item->info->lock);\r\nmutex_unlock(&item->info->lock);\r\nframebuffer_release(item->info);\r\nvfree(fb);\r\n}\r\n} while (item);\r\n}\r\nstatic int picolcd_fb_open(struct fb_info *info, int u)\r\n{\r\nu32 *ref_cnt = info->pseudo_palette;\r\nref_cnt--;\r\n(*ref_cnt)++;\r\nreturn 0;\r\n}\r\nstatic int picolcd_fb_release(struct fb_info *info, int u)\r\n{\r\nu32 *ref_cnt = info->pseudo_palette;\r\nref_cnt--;\r\n(*ref_cnt)++;\r\nif (!*ref_cnt) {\r\nunsigned long flags;\r\nstruct picolcd_fb_cleanup_item *item = (struct picolcd_fb_cleanup_item *)ref_cnt;\r\nitem--;\r\nspin_lock_irqsave(&fb_pending_lock, flags);\r\nitem->next = fb_pending;\r\nfb_pending = item;\r\nspin_unlock_irqrestore(&fb_pending_lock, flags);\r\nschedule_work(&picolcd_fb_cleanup);\r\n}\r\nreturn 0;\r\n}\r\nstatic void picolcd_fb_deferred_io(struct fb_info *info, struct list_head *pagelist)\r\n{\r\npicolcd_fb_update(info->par);\r\n}\r\nstatic ssize_t picolcd_fb_update_rate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nunsigned i, fb_update_rate = data->fb_update_rate;\r\nsize_t ret = 0;\r\nfor (i = 1; i <= PICOLCDFB_UPDATE_RATE_LIMIT; i++)\r\nif (ret >= PAGE_SIZE)\r\nbreak;\r\nelse if (i == fb_update_rate)\r\nret += snprintf(buf+ret, PAGE_SIZE-ret, "[%u] ", i);\r\nelse\r\nret += snprintf(buf+ret, PAGE_SIZE-ret, "%u ", i);\r\nif (ret > 0)\r\nbuf[min(ret, (size_t)PAGE_SIZE)-1] = '\n';\r\nreturn ret;\r\n}\r\nstatic ssize_t picolcd_fb_update_rate_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nint i;\r\nunsigned u;\r\nif (count < 1 || count > 10)\r\nreturn -EINVAL;\r\ni = sscanf(buf, "%u", &u);\r\nif (i != 1)\r\nreturn -EINVAL;\r\nif (u > PICOLCDFB_UPDATE_RATE_LIMIT)\r\nreturn -ERANGE;\r\nelse if (u == 0)\r\nu = PICOLCDFB_UPDATE_RATE_DEFAULT;\r\ndata->fb_update_rate = u;\r\ndata->fb_defio.delay = HZ / data->fb_update_rate;\r\nreturn count;\r\n}\r\nstatic int picolcd_init_framebuffer(struct picolcd_data *data)\r\n{\r\nstruct device *dev = &data->hdev->dev;\r\nstruct fb_info *info = NULL;\r\nint i, error = -ENOMEM;\r\nu8 *fb_vbitmap = NULL;\r\nu8 *fb_bitmap = NULL;\r\nu32 *palette;\r\nfb_bitmap = vmalloc(PICOLCDFB_SIZE*8);\r\nif (fb_bitmap == NULL) {\r\ndev_err(dev, "can't get a free page for framebuffer\n");\r\ngoto err_nomem;\r\n}\r\nfb_vbitmap = kmalloc(PICOLCDFB_SIZE, GFP_KERNEL);\r\nif (fb_vbitmap == NULL) {\r\ndev_err(dev, "can't alloc vbitmap image buffer\n");\r\ngoto err_nomem;\r\n}\r\ndata->fb_update_rate = PICOLCDFB_UPDATE_RATE_DEFAULT;\r\ndata->fb_defio = picolcd_fb_defio;\r\ninfo = framebuffer_alloc(257 * sizeof(u32) + sizeof(struct picolcd_fb_cleanup_item), dev);\r\nif (info == NULL) {\r\ndev_err(dev, "failed to allocate a framebuffer\n");\r\ngoto err_nomem;\r\n}\r\npalette = info->par + sizeof(struct picolcd_fb_cleanup_item);\r\n*palette = 1;\r\npalette++;\r\nfor (i = 0; i < 256; i++)\r\npalette[i] = i > 0 && i < 16 ? 0xff : 0;\r\ninfo->pseudo_palette = palette;\r\ninfo->fbdefio = &data->fb_defio;\r\ninfo->screen_base = (char __force __iomem *)fb_bitmap;\r\ninfo->fbops = &picolcdfb_ops;\r\ninfo->var = picolcdfb_var;\r\ninfo->fix = picolcdfb_fix;\r\ninfo->fix.smem_len = PICOLCDFB_SIZE*8;\r\ninfo->fix.smem_start = (unsigned long)fb_bitmap;\r\ninfo->par = data;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\ndata->fb_vbitmap = fb_vbitmap;\r\ndata->fb_bitmap = fb_bitmap;\r\ndata->fb_bpp = picolcdfb_var.bits_per_pixel;\r\nerror = picolcd_fb_reset(data, 1);\r\nif (error) {\r\ndev_err(dev, "failed to configure display\n");\r\ngoto err_cleanup;\r\n}\r\nerror = device_create_file(dev, &dev_attr_fb_update_rate);\r\nif (error) {\r\ndev_err(dev, "failed to create sysfs attributes\n");\r\ngoto err_cleanup;\r\n}\r\nfb_deferred_io_init(info);\r\ndata->fb_info = info;\r\nerror = register_framebuffer(info);\r\nif (error) {\r\ndev_err(dev, "failed to register framebuffer\n");\r\ngoto err_sysfs;\r\n}\r\ndata->fb_force = 1;\r\nschedule_delayed_work(&info->deferred_work, 0);\r\nreturn 0;\r\nerr_sysfs:\r\nfb_deferred_io_cleanup(info);\r\ndevice_remove_file(dev, &dev_attr_fb_update_rate);\r\nerr_cleanup:\r\ndata->fb_vbitmap = NULL;\r\ndata->fb_bitmap = NULL;\r\ndata->fb_bpp = 0;\r\ndata->fb_info = NULL;\r\nerr_nomem:\r\nframebuffer_release(info);\r\nvfree(fb_bitmap);\r\nkfree(fb_vbitmap);\r\nreturn error;\r\n}\r\nstatic void picolcd_exit_framebuffer(struct picolcd_data *data)\r\n{\r\nstruct fb_info *info = data->fb_info;\r\nu8 *fb_vbitmap = data->fb_vbitmap;\r\nif (!info)\r\nreturn;\r\ninfo->par = NULL;\r\ndevice_remove_file(&data->hdev->dev, &dev_attr_fb_update_rate);\r\nunregister_framebuffer(info);\r\ndata->fb_vbitmap = NULL;\r\ndata->fb_bitmap = NULL;\r\ndata->fb_bpp = 0;\r\ndata->fb_info = NULL;\r\nkfree(fb_vbitmap);\r\n}\r\nstatic inline int picolcd_fb_reset(struct picolcd_data *data, int clear)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int picolcd_init_framebuffer(struct picolcd_data *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void picolcd_exit_framebuffer(struct picolcd_data *data)\r\n{\r\n}\r\nstatic int picolcd_get_brightness(struct backlight_device *bdev)\r\n{\r\nstruct picolcd_data *data = bl_get_data(bdev);\r\nreturn data->lcd_brightness;\r\n}\r\nstatic int picolcd_set_brightness(struct backlight_device *bdev)\r\n{\r\nstruct picolcd_data *data = bl_get_data(bdev);\r\nstruct hid_report *report = picolcd_out_report(REPORT_BRIGHTNESS, data->hdev);\r\nunsigned long flags;\r\nif (!report || report->maxfield != 1 || report->field[0]->report_count != 1)\r\nreturn -ENODEV;\r\ndata->lcd_brightness = bdev->props.brightness & 0x0ff;\r\ndata->lcd_power = bdev->props.power;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhid_set_field(report->field[0], 0, data->lcd_power == FB_BLANK_UNBLANK ? data->lcd_brightness : 0);\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int picolcd_check_bl_fb(struct backlight_device *bdev, struct fb_info *fb)\r\n{\r\nreturn fb && fb == picolcd_fbinfo((struct picolcd_data *)bl_get_data(bdev));\r\n}\r\nstatic int picolcd_init_backlight(struct picolcd_data *data, struct hid_report *report)\r\n{\r\nstruct device *dev = &data->hdev->dev;\r\nstruct backlight_device *bdev;\r\nstruct backlight_properties props;\r\nif (!report)\r\nreturn -ENODEV;\r\nif (report->maxfield != 1 || report->field[0]->report_count != 1 ||\r\nreport->field[0]->report_size != 8) {\r\ndev_err(dev, "unsupported BRIGHTNESS report");\r\nreturn -EINVAL;\r\n}\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 0xff;\r\nbdev = backlight_device_register(dev_name(dev), dev, data,\r\n&picolcd_blops, &props);\r\nif (IS_ERR(bdev)) {\r\ndev_err(dev, "failed to register backlight\n");\r\nreturn PTR_ERR(bdev);\r\n}\r\nbdev->props.brightness = 0xff;\r\ndata->lcd_brightness = 0xff;\r\ndata->backlight = bdev;\r\npicolcd_set_brightness(bdev);\r\nreturn 0;\r\n}\r\nstatic void picolcd_exit_backlight(struct picolcd_data *data)\r\n{\r\nstruct backlight_device *bdev = data->backlight;\r\ndata->backlight = NULL;\r\nif (bdev)\r\nbacklight_device_unregister(bdev);\r\n}\r\nstatic inline int picolcd_resume_backlight(struct picolcd_data *data)\r\n{\r\nif (!data->backlight)\r\nreturn 0;\r\nreturn picolcd_set_brightness(data->backlight);\r\n}\r\nstatic void picolcd_suspend_backlight(struct picolcd_data *data)\r\n{\r\nint bl_power = data->lcd_power;\r\nif (!data->backlight)\r\nreturn;\r\ndata->backlight->props.power = FB_BLANK_POWERDOWN;\r\npicolcd_set_brightness(data->backlight);\r\ndata->lcd_power = data->backlight->props.power = bl_power;\r\n}\r\nstatic inline int picolcd_init_backlight(struct picolcd_data *data,\r\nstruct hid_report *report)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void picolcd_exit_backlight(struct picolcd_data *data)\r\n{\r\n}\r\nstatic inline int picolcd_resume_backlight(struct picolcd_data *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void picolcd_suspend_backlight(struct picolcd_data *data)\r\n{\r\n}\r\nstatic int picolcd_get_contrast(struct lcd_device *ldev)\r\n{\r\nstruct picolcd_data *data = lcd_get_data(ldev);\r\nreturn data->lcd_contrast;\r\n}\r\nstatic int picolcd_set_contrast(struct lcd_device *ldev, int contrast)\r\n{\r\nstruct picolcd_data *data = lcd_get_data(ldev);\r\nstruct hid_report *report = picolcd_out_report(REPORT_CONTRAST, data->hdev);\r\nunsigned long flags;\r\nif (!report || report->maxfield != 1 || report->field[0]->report_count != 1)\r\nreturn -ENODEV;\r\ndata->lcd_contrast = contrast & 0x0ff;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhid_set_field(report->field[0], 0, data->lcd_contrast);\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int picolcd_check_lcd_fb(struct lcd_device *ldev, struct fb_info *fb)\r\n{\r\nreturn fb && fb == picolcd_fbinfo((struct picolcd_data *)lcd_get_data(ldev));\r\n}\r\nstatic int picolcd_init_lcd(struct picolcd_data *data, struct hid_report *report)\r\n{\r\nstruct device *dev = &data->hdev->dev;\r\nstruct lcd_device *ldev;\r\nif (!report)\r\nreturn -ENODEV;\r\nif (report->maxfield != 1 || report->field[0]->report_count != 1 ||\r\nreport->field[0]->report_size != 8) {\r\ndev_err(dev, "unsupported CONTRAST report");\r\nreturn -EINVAL;\r\n}\r\nldev = lcd_device_register(dev_name(dev), dev, data, &picolcd_lcdops);\r\nif (IS_ERR(ldev)) {\r\ndev_err(dev, "failed to register LCD\n");\r\nreturn PTR_ERR(ldev);\r\n}\r\nldev->props.max_contrast = 0x0ff;\r\ndata->lcd_contrast = 0xe5;\r\ndata->lcd = ldev;\r\npicolcd_set_contrast(ldev, 0xe5);\r\nreturn 0;\r\n}\r\nstatic void picolcd_exit_lcd(struct picolcd_data *data)\r\n{\r\nstruct lcd_device *ldev = data->lcd;\r\ndata->lcd = NULL;\r\nif (ldev)\r\nlcd_device_unregister(ldev);\r\n}\r\nstatic inline int picolcd_resume_lcd(struct picolcd_data *data)\r\n{\r\nif (!data->lcd)\r\nreturn 0;\r\nreturn picolcd_set_contrast(data->lcd, data->lcd_contrast);\r\n}\r\nstatic inline int picolcd_init_lcd(struct picolcd_data *data,\r\nstruct hid_report *report)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void picolcd_exit_lcd(struct picolcd_data *data)\r\n{\r\n}\r\nstatic inline int picolcd_resume_lcd(struct picolcd_data *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic void picolcd_leds_set(struct picolcd_data *data)\r\n{\r\nstruct hid_report *report;\r\nunsigned long flags;\r\nif (!data->led[0])\r\nreturn;\r\nreport = picolcd_out_report(REPORT_LED_STATE, data->hdev);\r\nif (!report || report->maxfield != 1 || report->field[0]->report_count != 1)\r\nreturn;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhid_set_field(report->field[0], 0, data->led_state);\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\nstatic void picolcd_led_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev;\r\nstruct hid_device *hdev;\r\nstruct picolcd_data *data;\r\nint i, state = 0;\r\ndev = led_cdev->dev->parent;\r\nhdev = container_of(dev, struct hid_device, dev);\r\ndata = hid_get_drvdata(hdev);\r\nfor (i = 0; i < 8; i++) {\r\nif (led_cdev != data->led[i])\r\ncontinue;\r\nstate = (data->led_state >> i) & 1;\r\nif (value == LED_OFF && state) {\r\ndata->led_state &= ~(1 << i);\r\npicolcd_leds_set(data);\r\n} else if (value != LED_OFF && !state) {\r\ndata->led_state |= 1 << i;\r\npicolcd_leds_set(data);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic enum led_brightness picolcd_led_get_brightness(struct led_classdev *led_cdev)\r\n{\r\nstruct device *dev;\r\nstruct hid_device *hdev;\r\nstruct picolcd_data *data;\r\nint i, value = 0;\r\ndev = led_cdev->dev->parent;\r\nhdev = container_of(dev, struct hid_device, dev);\r\ndata = hid_get_drvdata(hdev);\r\nfor (i = 0; i < 8; i++)\r\nif (led_cdev == data->led[i]) {\r\nvalue = (data->led_state >> i) & 1;\r\nbreak;\r\n}\r\nreturn value ? LED_FULL : LED_OFF;\r\n}\r\nstatic int picolcd_init_leds(struct picolcd_data *data, struct hid_report *report)\r\n{\r\nstruct device *dev = &data->hdev->dev;\r\nstruct led_classdev *led;\r\nsize_t name_sz = strlen(dev_name(dev)) + 8;\r\nchar *name;\r\nint i, ret = 0;\r\nif (!report)\r\nreturn -ENODEV;\r\nif (report->maxfield != 1 || report->field[0]->report_count != 1 ||\r\nreport->field[0]->report_size != 8) {\r\ndev_err(dev, "unsupported LED_STATE report");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\r\nif (!led) {\r\ndev_err(dev, "can't allocate memory for LED %d\n", i);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nname = (void *)(&led[1]);\r\nsnprintf(name, name_sz, "%s::GPO%d", dev_name(dev), i);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 1;\r\nled->brightness_get = picolcd_led_get_brightness;\r\nled->brightness_set = picolcd_led_set_brightness;\r\ndata->led[i] = led;\r\nret = led_classdev_register(dev, data->led[i]);\r\nif (ret) {\r\ndata->led[i] = NULL;\r\nkfree(led);\r\ndev_err(dev, "can't register LED %d\n", i);\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfor (i = 0; i < 8; i++)\r\nif (data->led[i]) {\r\nled = data->led[i];\r\ndata->led[i] = NULL;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\nreturn ret;\r\n}\r\nstatic void picolcd_exit_leds(struct picolcd_data *data)\r\n{\r\nstruct led_classdev *led;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nled = data->led[i];\r\ndata->led[i] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\n}\r\nstatic inline int picolcd_init_leds(struct picolcd_data *data,\r\nstruct hid_report *report)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void picolcd_exit_leds(struct picolcd_data *data)\r\n{\r\n}\r\nstatic inline int picolcd_leds_set(struct picolcd_data *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int picolcd_raw_keypad(struct picolcd_data *data,\r\nstruct hid_report *report, u8 *raw_data, int size)\r\n{\r\nint i, j;\r\nfor (i = 0; i < size; i++) {\r\nunsigned int key_code;\r\nif (raw_data[i] == 0)\r\ncontinue;\r\nfor (j = 0; j < sizeof(data->pressed_keys); j++)\r\nif (data->pressed_keys[j] == raw_data[i])\r\ngoto key_already_down;\r\nfor (j = 0; j < sizeof(data->pressed_keys); j++)\r\nif (data->pressed_keys[j] == 0) {\r\ndata->pressed_keys[j] = raw_data[i];\r\nbreak;\r\n}\r\ninput_event(data->input_keys, EV_MSC, MSC_SCAN, raw_data[i]);\r\nif (raw_data[i] < PICOLCD_KEYS)\r\nkey_code = data->keycode[raw_data[i]];\r\nelse\r\nkey_code = KEY_UNKNOWN;\r\nif (key_code != KEY_UNKNOWN) {\r\ndbg_hid(PICOLCD_NAME " got key press for %u:%d",\r\nraw_data[i], key_code);\r\ninput_report_key(data->input_keys, key_code, 1);\r\n}\r\ninput_sync(data->input_keys);\r\nkey_already_down:\r\ncontinue;\r\n}\r\nfor (j = 0; j < sizeof(data->pressed_keys); j++) {\r\nunsigned int key_code;\r\nif (data->pressed_keys[j] == 0)\r\ncontinue;\r\nfor (i = 0; i < size; i++)\r\nif (data->pressed_keys[j] == raw_data[i])\r\ngoto key_still_down;\r\ninput_event(data->input_keys, EV_MSC, MSC_SCAN, data->pressed_keys[j]);\r\nif (data->pressed_keys[j] < PICOLCD_KEYS)\r\nkey_code = data->keycode[data->pressed_keys[j]];\r\nelse\r\nkey_code = KEY_UNKNOWN;\r\nif (key_code != KEY_UNKNOWN) {\r\ndbg_hid(PICOLCD_NAME " got key release for %u:%d",\r\ndata->pressed_keys[j], key_code);\r\ninput_report_key(data->input_keys, key_code, 0);\r\n}\r\ninput_sync(data->input_keys);\r\ndata->pressed_keys[j] = 0;\r\nkey_still_down:\r\ncontinue;\r\n}\r\nreturn 1;\r\n}\r\nstatic int picolcd_raw_cir(struct picolcd_data *data,\r\nstruct hid_report *report, u8 *raw_data, int size)\r\n{\r\nreturn 1;\r\n}\r\nstatic int picolcd_check_version(struct hid_device *hdev)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nstruct picolcd_pending *verinfo;\r\nint ret = 0;\r\nif (!data)\r\nreturn -ENODEV;\r\nverinfo = picolcd_send_and_wait(hdev, REPORT_VERSION, NULL, 0);\r\nif (!verinfo) {\r\nhid_err(hdev, "no version response from PicoLCD\n");\r\nreturn -ENODEV;\r\n}\r\nif (verinfo->raw_size == 2) {\r\ndata->version[0] = verinfo->raw_data[1];\r\ndata->version[1] = verinfo->raw_data[0];\r\nif (data->status & PICOLCD_BOOTLOADER) {\r\nhid_info(hdev, "PicoLCD, bootloader version %d.%d\n",\r\nverinfo->raw_data[1], verinfo->raw_data[0]);\r\n} else {\r\nhid_info(hdev, "PicoLCD, firmware version %d.%d\n",\r\nverinfo->raw_data[1], verinfo->raw_data[0]);\r\n}\r\n} else {\r\nhid_err(hdev, "confused, got unexpected version response from PicoLCD\n");\r\nret = -EINVAL;\r\n}\r\nkfree(verinfo);\r\nreturn ret;\r\n}\r\nstatic int picolcd_reset(struct hid_device *hdev)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nstruct hid_report *report = picolcd_out_report(REPORT_RESET, hdev);\r\nunsigned long flags;\r\nint error;\r\nif (!data || !report || report->maxfield != 1)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&data->lock, flags);\r\nif (hdev->product == USB_DEVICE_ID_PICOLCD_BOOTLOADER)\r\ndata->status |= PICOLCD_BOOTLOADER;\r\nhid_set_field(report->field[0], 0, 1);\r\nusbhid_submit_report(hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nerror = picolcd_check_version(hdev);\r\nif (error)\r\nreturn error;\r\npicolcd_resume_lcd(data);\r\npicolcd_resume_backlight(data);\r\n#ifdef CONFIG_HID_PICOLCD_FB\r\nif (data->fb_info)\r\nschedule_delayed_work(&data->fb_info->deferred_work, 0);\r\n#endif\r\npicolcd_leds_set(data);\r\nreturn 0;\r\n}\r\nstatic ssize_t picolcd_operation_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nif (data->status & PICOLCD_BOOTLOADER)\r\nreturn snprintf(buf, PAGE_SIZE, "[bootloader] lcd\n");\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "bootloader [lcd]\n");\r\n}\r\nstatic ssize_t picolcd_operation_mode_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nstruct hid_report *report = NULL;\r\nsize_t cnt = count;\r\nint timeout = data->opmode_delay;\r\nunsigned long flags;\r\nif (cnt >= 3 && strncmp("lcd", buf, 3) == 0) {\r\nif (data->status & PICOLCD_BOOTLOADER)\r\nreport = picolcd_out_report(REPORT_EXIT_FLASHER, data->hdev);\r\nbuf += 3;\r\ncnt -= 3;\r\n} else if (cnt >= 10 && strncmp("bootloader", buf, 10) == 0) {\r\nif (!(data->status & PICOLCD_BOOTLOADER))\r\nreport = picolcd_out_report(REPORT_EXIT_KEYBOARD, data->hdev);\r\nbuf += 10;\r\ncnt -= 10;\r\n}\r\nif (!report)\r\nreturn -EINVAL;\r\nwhile (cnt > 0 && (buf[cnt-1] == '\n' || buf[cnt-1] == '\r'))\r\ncnt--;\r\nif (cnt != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhid_set_field(report->field[0], 0, timeout & 0xff);\r\nhid_set_field(report->field[0], 1, (timeout >> 8) & 0xff);\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t picolcd_operation_mode_delay_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%hu\n", data->opmode_delay);\r\n}\r\nstatic ssize_t picolcd_operation_mode_delay_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nunsigned u;\r\nif (sscanf(buf, "%u", &u) != 1)\r\nreturn -EINVAL;\r\nif (u > 30000)\r\nreturn -EINVAL;\r\nelse\r\ndata->opmode_delay = u;\r\nreturn count;\r\n}\r\nstatic int picolcd_debug_reset_show(struct seq_file *f, void *p)\r\n{\r\nif (picolcd_fbinfo((struct picolcd_data *)f->private))\r\nseq_printf(f, "all fb\n");\r\nelse\r\nseq_printf(f, "all\n");\r\nreturn 0;\r\n}\r\nstatic int picolcd_debug_reset_open(struct inode *inode, struct file *f)\r\n{\r\nreturn single_open(f, picolcd_debug_reset_show, inode->i_private);\r\n}\r\nstatic ssize_t picolcd_debug_reset_write(struct file *f, const char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct picolcd_data *data = ((struct seq_file *)f->private_data)->private;\r\nchar buf[32];\r\nsize_t cnt = min(count, sizeof(buf)-1);\r\nif (copy_from_user(buf, user_buf, cnt))\r\nreturn -EFAULT;\r\nwhile (cnt > 0 && (buf[cnt-1] == ' ' || buf[cnt-1] == '\n'))\r\ncnt--;\r\nbuf[cnt] = '\0';\r\nif (strcmp(buf, "all") == 0) {\r\npicolcd_reset(data->hdev);\r\npicolcd_fb_reset(data, 1);\r\n} else if (strcmp(buf, "fb") == 0) {\r\npicolcd_fb_reset(data, 1);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic int picolcd_debug_eeprom_open(struct inode *i, struct file *f)\r\n{\r\nf->private_data = i->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t picolcd_debug_eeprom_read(struct file *f, char __user *u,\r\nsize_t s, loff_t *off)\r\n{\r\nstruct picolcd_data *data = f->private_data;\r\nstruct picolcd_pending *resp;\r\nu8 raw_data[3];\r\nssize_t ret = -EIO;\r\nif (s == 0)\r\nreturn -EINVAL;\r\nif (*off > 0x0ff)\r\nreturn 0;\r\nraw_data[0] = *off & 0xff;\r\nraw_data[1] = (*off >> 8) & 0xff;\r\nraw_data[2] = s < 20 ? s : 20;\r\nif (*off + raw_data[2] > 0xff)\r\nraw_data[2] = 0x100 - *off;\r\nresp = picolcd_send_and_wait(data->hdev, REPORT_EE_READ, raw_data,\r\nsizeof(raw_data));\r\nif (!resp)\r\nreturn -EIO;\r\nif (resp->in_report && resp->in_report->id == REPORT_EE_DATA) {\r\nret = resp->raw_data[2];\r\nif (ret > s)\r\nret = s;\r\nif (copy_to_user(u, resp->raw_data+3, ret))\r\nret = -EFAULT;\r\nelse\r\n*off += ret;\r\n}\r\nkfree(resp);\r\nreturn ret;\r\n}\r\nstatic ssize_t picolcd_debug_eeprom_write(struct file *f, const char __user *u,\r\nsize_t s, loff_t *off)\r\n{\r\nstruct picolcd_data *data = f->private_data;\r\nstruct picolcd_pending *resp;\r\nssize_t ret = -EIO;\r\nu8 raw_data[23];\r\nif (s == 0)\r\nreturn -EINVAL;\r\nif (*off > 0x0ff)\r\nreturn -ENOSPC;\r\nmemset(raw_data, 0, sizeof(raw_data));\r\nraw_data[0] = *off & 0xff;\r\nraw_data[1] = (*off >> 8) & 0xff;\r\nraw_data[2] = min((size_t)20, s);\r\nif (*off + raw_data[2] > 0xff)\r\nraw_data[2] = 0x100 - *off;\r\nif (copy_from_user(raw_data+3, u, min((u8)20, raw_data[2])))\r\nreturn -EFAULT;\r\nresp = picolcd_send_and_wait(data->hdev, REPORT_EE_WRITE, raw_data,\r\nsizeof(raw_data));\r\nif (!resp)\r\nreturn -EIO;\r\nif (resp->in_report && resp->in_report->id == REPORT_EE_DATA) {\r\nif (memcmp(raw_data, resp->raw_data, 3+raw_data[2]) == 0) {\r\n*off += raw_data[2];\r\nret = raw_data[2];\r\n}\r\n}\r\nkfree(resp);\r\nreturn ret;\r\n}\r\nstatic int picolcd_debug_flash_open(struct inode *i, struct file *f)\r\n{\r\nf->private_data = i->i_private;\r\nreturn 0;\r\n}\r\nstatic int _picolcd_flash_setaddr(struct picolcd_data *data, u8 *buf, long off)\r\n{\r\nbuf[0] = off & 0xff;\r\nbuf[1] = (off >> 8) & 0xff;\r\nif (data->addr_sz == 3)\r\nbuf[2] = (off >> 16) & 0xff;\r\nreturn data->addr_sz == 2 ? 2 : 3;\r\n}\r\nstatic ssize_t _picolcd_flash_read(struct picolcd_data *data, int report_id,\r\nchar __user *u, size_t s, loff_t *off)\r\n{\r\nstruct picolcd_pending *resp;\r\nu8 raw_data[4];\r\nssize_t ret = 0;\r\nint len_off, err = -EIO;\r\nwhile (s > 0) {\r\nerr = -EIO;\r\nlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\r\nraw_data[len_off] = s > 32 ? 32 : s;\r\nresp = picolcd_send_and_wait(data->hdev, report_id, raw_data, len_off+1);\r\nif (!resp || !resp->in_report)\r\ngoto skip;\r\nif (resp->in_report->id == REPORT_MEMORY ||\r\nresp->in_report->id == REPORT_BL_READ_MEMORY) {\r\nif (memcmp(raw_data, resp->raw_data, len_off+1) != 0)\r\ngoto skip;\r\nif (copy_to_user(u+ret, resp->raw_data+len_off+1, raw_data[len_off])) {\r\nerr = -EFAULT;\r\ngoto skip;\r\n}\r\n*off += raw_data[len_off];\r\ns -= raw_data[len_off];\r\nret += raw_data[len_off];\r\nerr = 0;\r\n}\r\nskip:\r\nkfree(resp);\r\nif (err)\r\nreturn ret > 0 ? ret : err;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t picolcd_debug_flash_read(struct file *f, char __user *u,\r\nsize_t s, loff_t *off)\r\n{\r\nstruct picolcd_data *data = f->private_data;\r\nif (s == 0)\r\nreturn -EINVAL;\r\nif (*off > 0x05fff)\r\nreturn 0;\r\nif (*off + s > 0x05fff)\r\ns = 0x06000 - *off;\r\nif (data->status & PICOLCD_BOOTLOADER)\r\nreturn _picolcd_flash_read(data, REPORT_BL_READ_MEMORY, u, s, off);\r\nelse\r\nreturn _picolcd_flash_read(data, REPORT_READ_MEMORY, u, s, off);\r\n}\r\nstatic ssize_t _picolcd_flash_erase64(struct picolcd_data *data, int report_id,\r\nloff_t *off)\r\n{\r\nstruct picolcd_pending *resp;\r\nu8 raw_data[3];\r\nint len_off;\r\nssize_t ret = -EIO;\r\nif (*off & 0x3f)\r\nreturn -EINVAL;\r\nlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\r\nresp = picolcd_send_and_wait(data->hdev, report_id, raw_data, len_off);\r\nif (!resp || !resp->in_report)\r\ngoto skip;\r\nif (resp->in_report->id == REPORT_MEMORY ||\r\nresp->in_report->id == REPORT_BL_ERASE_MEMORY) {\r\nif (memcmp(raw_data, resp->raw_data, len_off) != 0)\r\ngoto skip;\r\nret = 0;\r\n}\r\nskip:\r\nkfree(resp);\r\nreturn ret;\r\n}\r\nstatic ssize_t _picolcd_flash_write(struct picolcd_data *data, int report_id,\r\nconst char __user *u, size_t s, loff_t *off)\r\n{\r\nstruct picolcd_pending *resp;\r\nu8 raw_data[36];\r\nssize_t ret = 0;\r\nint len_off, err = -EIO;\r\nwhile (s > 0) {\r\nerr = -EIO;\r\nlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\r\nraw_data[len_off] = s > 32 ? 32 : s;\r\nif (copy_from_user(raw_data+len_off+1, u, raw_data[len_off])) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nresp = picolcd_send_and_wait(data->hdev, report_id, raw_data,\r\nlen_off+1+raw_data[len_off]);\r\nif (!resp || !resp->in_report)\r\ngoto skip;\r\nif (resp->in_report->id == REPORT_MEMORY ||\r\nresp->in_report->id == REPORT_BL_WRITE_MEMORY) {\r\nif (memcmp(raw_data, resp->raw_data, len_off+1+raw_data[len_off]) != 0)\r\ngoto skip;\r\n*off += raw_data[len_off];\r\ns -= raw_data[len_off];\r\nret += raw_data[len_off];\r\nerr = 0;\r\n}\r\nskip:\r\nkfree(resp);\r\nif (err)\r\nbreak;\r\n}\r\nreturn ret > 0 ? ret : err;\r\n}\r\nstatic ssize_t picolcd_debug_flash_write(struct file *f, const char __user *u,\r\nsize_t s, loff_t *off)\r\n{\r\nstruct picolcd_data *data = f->private_data;\r\nssize_t err, ret = 0;\r\nint report_erase, report_write;\r\nif (s == 0)\r\nreturn -EINVAL;\r\nif (*off > 0x5fff)\r\nreturn -ENOSPC;\r\nif (s & 0x3f)\r\nreturn -EINVAL;\r\nif (*off & 0x3f)\r\nreturn -EINVAL;\r\nif (data->status & PICOLCD_BOOTLOADER) {\r\nreport_erase = REPORT_BL_ERASE_MEMORY;\r\nreport_write = REPORT_BL_WRITE_MEMORY;\r\n} else {\r\nreport_erase = REPORT_ERASE_MEMORY;\r\nreport_write = REPORT_WRITE_MEMORY;\r\n}\r\nmutex_lock(&data->mutex_flash);\r\nwhile (s > 0) {\r\nerr = _picolcd_flash_erase64(data, report_erase, off);\r\nif (err)\r\nbreak;\r\nerr = _picolcd_flash_write(data, report_write, u, 64, off);\r\nif (err < 0)\r\nbreak;\r\nret += err;\r\n*off += err;\r\ns -= err;\r\nif (err != 64)\r\nbreak;\r\n}\r\nmutex_unlock(&data->mutex_flash);\r\nreturn ret > 0 ? ret : err;\r\n}\r\nstatic void dump_buff_as_hex(char *dst, size_t dst_sz, const u8 *data,\r\nconst size_t data_len)\r\n{\r\nint i, j;\r\nfor (i = j = 0; i < data_len && j + 3 < dst_sz; i++) {\r\ndst[j++] = hex_asc[(data[i] >> 4) & 0x0f];\r\ndst[j++] = hex_asc[data[i] & 0x0f];\r\ndst[j++] = ' ';\r\n}\r\nif (j < dst_sz) {\r\ndst[j--] = '\0';\r\ndst[j] = '\n';\r\n} else\r\ndst[j] = '\0';\r\n}\r\nstatic void picolcd_debug_out_report(struct picolcd_data *data,\r\nstruct hid_device *hdev, struct hid_report *report)\r\n{\r\nu8 raw_data[70];\r\nint raw_size = (report->size >> 3) + 1;\r\nchar *buff;\r\n#define BUFF_SZ 256\r\nif (!hdev->debug_events)\r\nreturn;\r\nbuff = kmalloc(BUFF_SZ, GFP_ATOMIC);\r\nif (!buff)\r\nreturn;\r\nsnprintf(buff, BUFF_SZ, "\nout report %d (size %d) = ",\r\nreport->id, raw_size);\r\nhid_debug_event(hdev, buff);\r\nif (raw_size + 5 > sizeof(raw_data)) {\r\nkfree(buff);\r\nhid_debug_event(hdev, " TOO BIG\n");\r\nreturn;\r\n} else {\r\nraw_data[0] = report->id;\r\nhid_output_report(report, raw_data);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data, raw_size);\r\nhid_debug_event(hdev, buff);\r\n}\r\nswitch (report->id) {\r\ncase REPORT_LED_STATE:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_LED_STATE", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tGPO state: 0x%02x\n", raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_BRIGHTNESS:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_BRIGHTNESS", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tBrightness: 0x%02x\n", raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_CONTRAST:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_CONTRAST", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tContrast: 0x%02x\n", raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_RESET:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_RESET", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tDuration: 0x%02x%02x (%dms)\n",\r\nraw_data[2], raw_data[1], raw_data[2] << 8 | raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_LCD_CMD:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_LCD_CMD", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_LCD_DATA:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_LCD_CMD", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_LCD_CMD_DATA:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_LCD_CMD", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_EE_READ:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_EE_READ", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_EE_WRITE:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_EE_WRITE", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[3] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[3] + 4 <= raw_size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_ERASE_MEMORY:\r\ncase REPORT_BL_ERASE_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_ERASE_MEMORY", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nswitch (data->addr_sz) {\r\ncase 2:\r\nsnprintf(buff, BUFF_SZ, "\tAddress inside 64 byte block: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nbreak;\r\ncase 3:\r\nsnprintf(buff, BUFF_SZ, "\tAddress inside 64 byte block: 0x%02x%02x%02x\n",\r\nraw_data[3], raw_data[2], raw_data[1]);\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "\tNot supported\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_READ_MEMORY:\r\ncase REPORT_BL_READ_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_READ_MEMORY", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nswitch (data->addr_sz) {\r\ncase 2:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nbreak;\r\ncase 3:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x%02x\n",\r\nraw_data[3], raw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[4]);\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "\tNot supported\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_WRITE_MEMORY:\r\ncase REPORT_BL_WRITE_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_WRITE_MEMORY", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nswitch (data->addr_sz) {\r\ncase 2:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[3] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[3] + 4 <= raw_size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nbreak;\r\ncase 3:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x%02x\n",\r\nraw_data[3], raw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[4]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[4] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[4] + 5 <= raw_size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+5, raw_data[4]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "\tNot supported\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_SPLASH_RESTART:\r\nbreak;\r\ncase REPORT_EXIT_KEYBOARD:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_EXIT_KEYBOARD", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tRestart delay: %dms (0x%02x%02x)\n",\r\nraw_data[1] | (raw_data[2] << 8),\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_VERSION:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_VERSION", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_DEVID:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_DEVID", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_SPLASH_SIZE:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_SPLASH_SIZE", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_HOOK_VERSION:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_HOOK_VERSION", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_EXIT_FLASHER:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_VERSION", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tRestart delay: %dms (0x%02x%02x)\n",\r\nraw_data[1] | (raw_data[2] << 8),\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"<unknown>", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\n}\r\nwake_up_interruptible(&hdev->debug_wait);\r\nkfree(buff);\r\n}\r\nstatic void picolcd_debug_raw_event(struct picolcd_data *data,\r\nstruct hid_device *hdev, struct hid_report *report,\r\nu8 *raw_data, int size)\r\n{\r\nchar *buff;\r\n#define BUFF_SZ 256\r\nif (!hdev->debug_events)\r\nreturn;\r\nbuff = kmalloc(BUFF_SZ, GFP_ATOMIC);\r\nif (!buff)\r\nreturn;\r\nswitch (report->id) {\r\ncase REPORT_ERROR_CODE:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_ERROR_CODE", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[2] < ARRAY_SIZE(error_codes))\r\nsnprintf(buff, BUFF_SZ, "\tError code 0x%02x (%s) in reply to report 0x%02x\n",\r\nraw_data[2], error_codes[raw_data[2]], raw_data[1]);\r\nelse\r\nsnprintf(buff, BUFF_SZ, "\tError code 0x%02x in reply to report 0x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_KEY_STATE:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_KEY_STATE", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[1] == 0)\r\nsnprintf(buff, BUFF_SZ, "\tNo key pressed\n");\r\nelse if (raw_data[2] == 0)\r\nsnprintf(buff, BUFF_SZ, "\tOne key pressed: 0x%02x (%d)\n",\r\nraw_data[1], raw_data[1]);\r\nelse\r\nsnprintf(buff, BUFF_SZ, "\tTwo keys pressed: 0x%02x (%d), 0x%02x (%d)\n",\r\nraw_data[1], raw_data[1], raw_data[2], raw_data[2]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_IR_DATA:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_IR_DATA", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[1] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tUnexpectedly 0 data length\n");\r\nhid_debug_event(hdev, buff);\r\n} else if (raw_data[1] + 1 <= size) {\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n\tIR Data: ",\r\nraw_data[1]-1);\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+2, raw_data[1]-1);\r\nhid_debug_event(hdev, buff);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tOverflowing data length: %d\n",\r\nraw_data[1]-1);\r\nhid_debug_event(hdev, buff);\r\n}\r\nbreak;\r\ncase REPORT_EE_DATA:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_EE_DATA", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[3] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\nhid_debug_event(hdev, buff);\r\n} else if (raw_data[3] + 4 <= size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\nhid_debug_event(hdev, buff);\r\n}\r\nbreak;\r\ncase REPORT_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_MEMORY", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nswitch (data->addr_sz) {\r\ncase 2:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[3] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[3] + 4 <= size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nbreak;\r\ncase 3:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x%02x\n",\r\nraw_data[3], raw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[4]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[4] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[4] + 5 <= size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+5, raw_data[4]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "\tNot supported\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_VERSION:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_VERSION", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tFirmware version: %d.%d\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_BL_ERASE_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_BL_ERASE_MEMORY", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_BL_READ_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_BL_READ_MEMORY", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_BL_WRITE_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_BL_WRITE_MEMORY", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_DEVID:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_DEVID", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tSerial: 0x%02x%02x%02x%02x\n",\r\nraw_data[1], raw_data[2], raw_data[3], raw_data[4]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tType: 0x%02x\n",\r\nraw_data[5]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_SPLASH_SIZE:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_SPLASH_SIZE", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tTotal splash space: %d\n",\r\n(raw_data[2] << 8) | raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tUsed splash space: %d\n",\r\n(raw_data[4] << 8) | raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_HOOK_VERSION:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_HOOK_VERSION", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tFirmware version: %d.%d\n",\r\nraw_data[1], raw_data[2]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"<unknown>", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\n}\r\nwake_up_interruptible(&hdev->debug_wait);\r\nkfree(buff);\r\n}\r\nstatic void picolcd_init_devfs(struct picolcd_data *data,\r\nstruct hid_report *eeprom_r, struct hid_report *eeprom_w,\r\nstruct hid_report *flash_r, struct hid_report *flash_w,\r\nstruct hid_report *reset)\r\n{\r\nstruct hid_device *hdev = data->hdev;\r\nmutex_init(&data->mutex_flash);\r\nif (reset)\r\ndata->debug_reset = debugfs_create_file("reset", 0600,\r\nhdev->debug_dir, data, &picolcd_debug_reset_fops);\r\nif (eeprom_r || eeprom_w)\r\ndata->debug_eeprom = debugfs_create_file("eeprom",\r\n(eeprom_w ? S_IWUSR : 0) | (eeprom_r ? S_IRUSR : 0),\r\nhdev->debug_dir, data, &picolcd_debug_eeprom_fops);\r\nif (flash_r && flash_r->maxfield == 1 && flash_r->field[0]->report_size == 8)\r\ndata->addr_sz = flash_r->field[0]->report_count - 1;\r\nelse\r\ndata->addr_sz = -1;\r\nif (data->addr_sz == 2 || data->addr_sz == 3) {\r\ndata->debug_flash = debugfs_create_file("flash",\r\n(flash_w ? S_IWUSR : 0) | (flash_r ? S_IRUSR : 0),\r\nhdev->debug_dir, data, &picolcd_debug_flash_fops);\r\n} else if (flash_r || flash_w)\r\nhid_warn(hdev, "Unexpected FLASH access reports, please submit rdesc for review\n");\r\n}\r\nstatic void picolcd_exit_devfs(struct picolcd_data *data)\r\n{\r\nstruct dentry *dent;\r\ndent = data->debug_reset;\r\ndata->debug_reset = NULL;\r\nif (dent)\r\ndebugfs_remove(dent);\r\ndent = data->debug_eeprom;\r\ndata->debug_eeprom = NULL;\r\nif (dent)\r\ndebugfs_remove(dent);\r\ndent = data->debug_flash;\r\ndata->debug_flash = NULL;\r\nif (dent)\r\ndebugfs_remove(dent);\r\nmutex_destroy(&data->mutex_flash);\r\n}\r\nstatic inline void picolcd_debug_raw_event(struct picolcd_data *data,\r\nstruct hid_device *hdev, struct hid_report *report,\r\nu8 *raw_data, int size)\r\n{\r\n}\r\nstatic inline void picolcd_init_devfs(struct picolcd_data *data,\r\nstruct hid_report *eeprom_r, struct hid_report *eeprom_w,\r\nstruct hid_report *flash_r, struct hid_report *flash_w,\r\nstruct hid_report *reset)\r\n{\r\n}\r\nstatic inline void picolcd_exit_devfs(struct picolcd_data *data)\r\n{\r\n}\r\nstatic int picolcd_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *raw_data, int size)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!data)\r\nreturn 1;\r\nif (report->id == REPORT_KEY_STATE) {\r\nif (data->input_keys)\r\nret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\r\n} else if (report->id == REPORT_IR_DATA) {\r\nif (data->input_cir)\r\nret = picolcd_raw_cir(data, report, raw_data+1, size-1);\r\n} else {\r\nspin_lock_irqsave(&data->lock, flags);\r\nif (data->pending) {\r\nmemcpy(data->pending->raw_data, raw_data+1, size-1);\r\ndata->pending->raw_size = size-1;\r\ndata->pending->in_report = report;\r\ncomplete(&data->pending->ready);\r\n}\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\npicolcd_debug_raw_event(data, hdev, report, raw_data, size);\r\nreturn 1;\r\n}\r\nstatic int picolcd_suspend(struct hid_device *hdev, pm_message_t message)\r\n{\r\nif (message.event & PM_EVENT_AUTO)\r\nreturn 0;\r\npicolcd_suspend_backlight(hid_get_drvdata(hdev));\r\ndbg_hid(PICOLCD_NAME " device ready for suspend\n");\r\nreturn 0;\r\n}\r\nstatic int picolcd_resume(struct hid_device *hdev)\r\n{\r\nint ret;\r\nret = picolcd_resume_backlight(hid_get_drvdata(hdev));\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " restoring backlight failed: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int picolcd_reset_resume(struct hid_device *hdev)\r\n{\r\nint ret;\r\nret = picolcd_reset(hdev);\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " resetting our device failed: %d\n", ret);\r\nret = picolcd_fb_reset(hid_get_drvdata(hdev), 0);\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " restoring framebuffer content failed: %d\n", ret);\r\nret = picolcd_resume_lcd(hid_get_drvdata(hdev));\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " restoring lcd failed: %d\n", ret);\r\nret = picolcd_resume_backlight(hid_get_drvdata(hdev));\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " restoring backlight failed: %d\n", ret);\r\npicolcd_leds_set(hid_get_drvdata(hdev));\r\nreturn 0;\r\n}\r\nstatic int picolcd_init_keys(struct picolcd_data *data,\r\nstruct hid_report *report)\r\n{\r\nstruct hid_device *hdev = data->hdev;\r\nstruct input_dev *idev;\r\nint error, i;\r\nif (!report)\r\nreturn -ENODEV;\r\nif (report->maxfield != 1 || report->field[0]->report_count != 2 ||\r\nreport->field[0]->report_size != 8) {\r\nhid_err(hdev, "unsupported KEY_STATE report\n");\r\nreturn -EINVAL;\r\n}\r\nidev = input_allocate_device();\r\nif (idev == NULL) {\r\nhid_err(hdev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_set_drvdata(idev, hdev);\r\nmemcpy(data->keycode, def_keymap, sizeof(def_keymap));\r\nidev->name = hdev->name;\r\nidev->phys = hdev->phys;\r\nidev->uniq = hdev->uniq;\r\nidev->id.bustype = hdev->bus;\r\nidev->id.vendor = hdev->vendor;\r\nidev->id.product = hdev->product;\r\nidev->id.version = hdev->version;\r\nidev->dev.parent = hdev->dev.parent;\r\nidev->keycode = &data->keycode;\r\nidev->keycodemax = PICOLCD_KEYS;\r\nidev->keycodesize = sizeof(data->keycode[0]);\r\ninput_set_capability(idev, EV_MSC, MSC_SCAN);\r\nset_bit(EV_REP, idev->evbit);\r\nfor (i = 0; i < PICOLCD_KEYS; i++)\r\ninput_set_capability(idev, EV_KEY, data->keycode[i]);\r\nerror = input_register_device(idev);\r\nif (error) {\r\nhid_err(hdev, "error registering the input device\n");\r\ninput_free_device(idev);\r\nreturn error;\r\n}\r\ndata->input_keys = idev;\r\nreturn 0;\r\n}\r\nstatic void picolcd_exit_keys(struct picolcd_data *data)\r\n{\r\nstruct input_dev *idev = data->input_keys;\r\ndata->input_keys = NULL;\r\nif (idev)\r\ninput_unregister_device(idev);\r\n}\r\nstatic inline int picolcd_init_cir(struct picolcd_data *data, struct hid_report *report)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void picolcd_exit_cir(struct picolcd_data *data)\r\n{\r\n}\r\nstatic int picolcd_probe_lcd(struct hid_device *hdev, struct picolcd_data *data)\r\n{\r\nint error;\r\nerror = picolcd_check_version(hdev);\r\nif (error)\r\nreturn error;\r\nif (data->version[0] != 0 && data->version[1] != 3)\r\nhid_info(hdev, "Device with untested firmware revision, please submit /sys/kernel/debug/hid/%s/rdesc for this device.\n",\r\ndev_name(&hdev->dev));\r\nerror = picolcd_init_keys(data, picolcd_in_report(REPORT_KEY_STATE, hdev));\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_cir(data, picolcd_in_report(REPORT_IR_DATA, hdev));\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_framebuffer(data);\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_lcd(data, picolcd_out_report(REPORT_CONTRAST, hdev));\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_backlight(data, picolcd_out_report(REPORT_BRIGHTNESS, hdev));\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_leds(data, picolcd_out_report(REPORT_LED_STATE, hdev));\r\nif (error)\r\ngoto err;\r\npicolcd_init_devfs(data, picolcd_out_report(REPORT_EE_READ, hdev),\r\npicolcd_out_report(REPORT_EE_WRITE, hdev),\r\npicolcd_out_report(REPORT_READ_MEMORY, hdev),\r\npicolcd_out_report(REPORT_WRITE_MEMORY, hdev),\r\npicolcd_out_report(REPORT_RESET, hdev));\r\nreturn 0;\r\nerr:\r\npicolcd_exit_leds(data);\r\npicolcd_exit_backlight(data);\r\npicolcd_exit_lcd(data);\r\npicolcd_exit_framebuffer(data);\r\npicolcd_exit_cir(data);\r\npicolcd_exit_keys(data);\r\nreturn error;\r\n}\r\nstatic int picolcd_probe_bootloader(struct hid_device *hdev, struct picolcd_data *data)\r\n{\r\nint error;\r\nerror = picolcd_check_version(hdev);\r\nif (error)\r\nreturn error;\r\nif (data->version[0] != 1 && data->version[1] != 0)\r\nhid_info(hdev, "Device with untested bootloader revision, please submit /sys/kernel/debug/hid/%s/rdesc for this device.\n",\r\ndev_name(&hdev->dev));\r\npicolcd_init_devfs(data, NULL, NULL,\r\npicolcd_out_report(REPORT_BL_READ_MEMORY, hdev),\r\npicolcd_out_report(REPORT_BL_WRITE_MEMORY, hdev), NULL);\r\nreturn 0;\r\n}\r\nstatic int picolcd_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nstruct picolcd_data *data;\r\nint error = -ENOMEM;\r\ndbg_hid(PICOLCD_NAME " hardware probe...\n");\r\ndata = kzalloc(sizeof(struct picolcd_data), GFP_KERNEL);\r\nif (data == NULL) {\r\nhid_err(hdev, "can't allocate space for Minibox PicoLCD device data\n");\r\nerror = -ENOMEM;\r\ngoto err_no_cleanup;\r\n}\r\nspin_lock_init(&data->lock);\r\nmutex_init(&data->mutex);\r\ndata->hdev = hdev;\r\ndata->opmode_delay = 5000;\r\nif (hdev->product == USB_DEVICE_ID_PICOLCD_BOOTLOADER)\r\ndata->status |= PICOLCD_BOOTLOADER;\r\nhid_set_drvdata(hdev, data);\r\nerror = hid_parse(hdev);\r\nif (error) {\r\nhid_err(hdev, "device report parse failed\n");\r\ngoto err_cleanup_data;\r\n}\r\nhdev->claimed = HID_CLAIMED_INPUT;\r\nerror = hid_hw_start(hdev, 0);\r\nhdev->claimed = 0;\r\nif (error) {\r\nhid_err(hdev, "hardware start failed\n");\r\ngoto err_cleanup_data;\r\n}\r\nerror = hid_hw_open(hdev);\r\nif (error) {\r\nhid_err(hdev, "failed to open input interrupt pipe for key and IR events\n");\r\ngoto err_cleanup_hid_hw;\r\n}\r\nerror = device_create_file(&hdev->dev, &dev_attr_operation_mode_delay);\r\nif (error) {\r\nhid_err(hdev, "failed to create sysfs attributes\n");\r\ngoto err_cleanup_hid_ll;\r\n}\r\nerror = device_create_file(&hdev->dev, &dev_attr_operation_mode);\r\nif (error) {\r\nhid_err(hdev, "failed to create sysfs attributes\n");\r\ngoto err_cleanup_sysfs1;\r\n}\r\nif (data->status & PICOLCD_BOOTLOADER)\r\nerror = picolcd_probe_bootloader(hdev, data);\r\nelse\r\nerror = picolcd_probe_lcd(hdev, data);\r\nif (error)\r\ngoto err_cleanup_sysfs2;\r\ndbg_hid(PICOLCD_NAME " activated and initialized\n");\r\nreturn 0;\r\nerr_cleanup_sysfs2:\r\ndevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\r\nerr_cleanup_sysfs1:\r\ndevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\r\nerr_cleanup_hid_ll:\r\nhid_hw_close(hdev);\r\nerr_cleanup_hid_hw:\r\nhid_hw_stop(hdev);\r\nerr_cleanup_data:\r\nkfree(data);\r\nerr_no_cleanup:\r\nhid_set_drvdata(hdev, NULL);\r\nreturn error;\r\n}\r\nstatic void picolcd_remove(struct hid_device *hdev)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nunsigned long flags;\r\ndbg_hid(PICOLCD_NAME " hardware remove...\n");\r\nspin_lock_irqsave(&data->lock, flags);\r\ndata->status |= PICOLCD_FAILED;\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n#ifdef CONFIG_HID_PICOLCD_FB\r\nif (data->fb_info)\r\ndata->fb_info->par = NULL;\r\n#endif\r\npicolcd_exit_devfs(data);\r\ndevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\r\ndevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\r\nhid_hw_close(hdev);\r\nhid_hw_stop(hdev);\r\nhid_set_drvdata(hdev, NULL);\r\nspin_lock_irqsave(&data->lock, flags);\r\nif (data->pending)\r\ncomplete(&data->pending->ready);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\npicolcd_exit_leds(data);\r\npicolcd_exit_backlight(data);\r\npicolcd_exit_lcd(data);\r\npicolcd_exit_framebuffer(data);\r\npicolcd_exit_cir(data);\r\npicolcd_exit_keys(data);\r\nmutex_destroy(&data->mutex);\r\nkfree(data);\r\n}\r\nstatic int __init picolcd_init(void)\r\n{\r\nreturn hid_register_driver(&picolcd_driver);\r\n}\r\nstatic void __exit picolcd_exit(void)\r\n{\r\nhid_unregister_driver(&picolcd_driver);\r\n#ifdef CONFIG_HID_PICOLCD_FB\r\nflush_work_sync(&picolcd_fb_cleanup);\r\nWARN_ON(fb_pending);\r\n#endif\r\n}
