static inline int __iio_allocate_sw_ring_buffer(struct iio_sw_ring_buffer *ring,\r\nint bytes_per_datum, int length)\r\n{\r\nif ((length == 0) || (bytes_per_datum == 0))\r\nreturn -EINVAL;\r\n__iio_update_ring_buffer(&ring->buf, bytes_per_datum, length);\r\nring->data = kmalloc(length*ring->buf.bytes_per_datum, GFP_ATOMIC);\r\nring->read_p = NULL;\r\nring->write_p = NULL;\r\nring->last_written_p = NULL;\r\nring->half_p = NULL;\r\nreturn ring->data ? 0 : -ENOMEM;\r\n}\r\nstatic inline void __iio_init_sw_ring_buffer(struct iio_sw_ring_buffer *ring)\r\n{\r\nspin_lock_init(&ring->use_lock);\r\n}\r\nstatic inline void __iio_free_sw_ring_buffer(struct iio_sw_ring_buffer *ring)\r\n{\r\nkfree(ring->data);\r\n}\r\nstatic void iio_mark_sw_rb_in_use(struct iio_ring_buffer *r)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nspin_lock(&ring->use_lock);\r\nring->use_count++;\r\nspin_unlock(&ring->use_lock);\r\n}\r\nstatic void iio_unmark_sw_rb_in_use(struct iio_ring_buffer *r)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nspin_lock(&ring->use_lock);\r\nring->use_count--;\r\nspin_unlock(&ring->use_lock);\r\n}\r\nstatic int iio_store_to_sw_ring(struct iio_sw_ring_buffer *ring,\r\nunsigned char *data, s64 timestamp)\r\n{\r\nint ret = 0;\r\nunsigned char *temp_ptr, *change_test_ptr;\r\nif (unlikely(ring->write_p == NULL)) {\r\nring->write_p = ring->data;\r\nring->half_p = ring->data - ring->buf.length*ring->buf.bytes_per_datum/2;\r\n}\r\nmemcpy(ring->write_p, data, ring->buf.bytes_per_datum);\r\nbarrier();\r\nring->last_written_p = ring->write_p;\r\nbarrier();\r\ntemp_ptr = ring->write_p + ring->buf.bytes_per_datum;\r\nif (temp_ptr == ring->data + ring->buf.length*ring->buf.bytes_per_datum)\r\ntemp_ptr = ring->data;\r\nring->write_p = temp_ptr;\r\nif (ring->read_p == NULL)\r\nring->read_p = ring->data;\r\nelse if (ring->write_p == ring->read_p) {\r\nchange_test_ptr = ring->read_p;\r\ntemp_ptr = change_test_ptr + ring->buf.bytes_per_datum;\r\nif (temp_ptr\r\n== ring->data + ring->buf.length*ring->buf.bytes_per_datum) {\r\ntemp_ptr = ring->data;\r\n}\r\nif (change_test_ptr == ring->read_p)\r\nring->read_p = temp_ptr;\r\n}\r\nring->half_p += ring->buf.bytes_per_datum;\r\nif (ring->half_p == ring->data + ring->buf.length*ring->buf.bytes_per_datum)\r\nring->half_p = ring->data;\r\nif (ring->half_p == ring->read_p) {\r\nring->buf.stufftoread = true;\r\nwake_up_interruptible(&ring->buf.pollq);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iio_read_first_n_sw_rb(struct iio_ring_buffer *r,\r\nsize_t n, char __user *buf)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nu8 *initial_read_p, *initial_write_p, *current_read_p, *end_read_p;\r\nu8 *data;\r\nint ret, max_copied, bytes_to_rip, dead_offset;\r\nif (n % ring->buf.bytes_per_datum) {\r\nret = -EINVAL;\r\nprintk(KERN_INFO "Ring buffer read request not whole number of"\r\n"samples: Request bytes %zd, Current bytes per datum %d\n",\r\nn, ring->buf.bytes_per_datum);\r\ngoto error_ret;\r\n}\r\nbytes_to_rip = min((size_t)(ring->buf.bytes_per_datum*ring->buf.length),\r\nn);\r\ndata = kmalloc(bytes_to_rip, GFP_KERNEL);\r\nif (data == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\ninitial_read_p = ring->read_p;\r\nif (unlikely(initial_read_p == NULL)) {\r\nret = 0;\r\ngoto error_free_data_cpy;\r\n}\r\ninitial_write_p = ring->write_p;\r\nwhile ((initial_read_p != ring->read_p)\r\n|| (initial_write_p != ring->write_p)) {\r\ninitial_read_p = ring->read_p;\r\ninitial_write_p = ring->write_p;\r\n}\r\nif (initial_write_p == initial_read_p) {\r\nret = 0;\r\ngoto error_free_data_cpy;\r\n}\r\nif (initial_write_p >= initial_read_p + bytes_to_rip) {\r\nmax_copied = bytes_to_rip;\r\nmemcpy(data, initial_read_p, max_copied);\r\nend_read_p = initial_read_p + max_copied;\r\n} else if (initial_write_p > initial_read_p) {\r\nmax_copied = initial_write_p - initial_read_p;\r\nmemcpy(data, initial_read_p, max_copied);\r\nend_read_p = initial_write_p;\r\n} else {\r\nmax_copied = ring->data\r\n+ ring->buf.length*ring->buf.bytes_per_datum - initial_read_p;\r\nmemcpy(data, initial_read_p, max_copied);\r\nif (max_copied == bytes_to_rip)\r\nend_read_p = ring->data;\r\nelse if (initial_write_p\r\n> ring->data + bytes_to_rip - max_copied) {\r\nmemcpy(data + max_copied, ring->data,\r\nbytes_to_rip - max_copied);\r\nmax_copied = bytes_to_rip;\r\nend_read_p = ring->data + (bytes_to_rip - max_copied);\r\n} else {\r\nmemcpy(data + max_copied, ring->data,\r\ninitial_write_p - ring->data);\r\nmax_copied += initial_write_p - ring->data;\r\nend_read_p = initial_write_p;\r\n}\r\n}\r\ncurrent_read_p = ring->read_p;\r\nif (initial_read_p <= current_read_p)\r\ndead_offset = current_read_p - initial_read_p;\r\nelse\r\ndead_offset = ring->buf.length*ring->buf.bytes_per_datum\r\n- (initial_read_p - current_read_p);\r\nif (max_copied - dead_offset < 0) {\r\nret = 0;\r\ngoto error_free_data_cpy;\r\n}\r\nwhile (ring->read_p != end_read_p)\r\nring->read_p = end_read_p;\r\nret = max_copied - dead_offset;\r\nif (copy_to_user(buf, data + dead_offset, ret)) {\r\nret = -EFAULT;\r\ngoto error_free_data_cpy;\r\n}\r\nif (bytes_to_rip >= ring->buf.length*ring->buf.bytes_per_datum/2)\r\nring->buf.stufftoread = 0;\r\nerror_free_data_cpy:\r\nkfree(data);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int iio_store_to_sw_rb(struct iio_ring_buffer *r,\r\nu8 *data,\r\ns64 timestamp)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nreturn iio_store_to_sw_ring(ring, data, timestamp);\r\n}\r\nstatic int iio_read_last_from_sw_ring(struct iio_sw_ring_buffer *ring,\r\nunsigned char *data)\r\n{\r\nunsigned char *last_written_p_copy;\r\niio_mark_sw_rb_in_use(&ring->buf);\r\nagain:\r\nbarrier();\r\nlast_written_p_copy = ring->last_written_p;\r\nbarrier();\r\nif (last_written_p_copy == NULL)\r\nreturn -EAGAIN;\r\nmemcpy(data, last_written_p_copy, ring->buf.bytes_per_datum);\r\nif (unlikely(ring->last_written_p != last_written_p_copy))\r\ngoto again;\r\niio_unmark_sw_rb_in_use(&ring->buf);\r\nreturn 0;\r\n}\r\nstatic int iio_read_last_from_sw_rb(struct iio_ring_buffer *r,\r\nunsigned char *data)\r\n{\r\nreturn iio_read_last_from_sw_ring(iio_to_sw_ring(r), data);\r\n}\r\nstatic int iio_request_update_sw_rb(struct iio_ring_buffer *r)\r\n{\r\nint ret = 0;\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nr->stufftoread = false;\r\nspin_lock(&ring->use_lock);\r\nif (!ring->update_needed)\r\ngoto error_ret;\r\nif (ring->use_count) {\r\nret = -EAGAIN;\r\ngoto error_ret;\r\n}\r\n__iio_free_sw_ring_buffer(ring);\r\nret = __iio_allocate_sw_ring_buffer(ring, ring->buf.bytes_per_datum,\r\nring->buf.length);\r\nerror_ret:\r\nspin_unlock(&ring->use_lock);\r\nreturn ret;\r\n}\r\nstatic int iio_get_bytes_per_datum_sw_rb(struct iio_ring_buffer *r)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nreturn ring->buf.bytes_per_datum;\r\n}\r\nstatic int iio_set_bytes_per_datum_sw_rb(struct iio_ring_buffer *r, size_t bpd)\r\n{\r\nif (r->bytes_per_datum != bpd) {\r\nr->bytes_per_datum = bpd;\r\nif (r->access->mark_param_change)\r\nr->access->mark_param_change(r);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iio_get_length_sw_rb(struct iio_ring_buffer *r)\r\n{\r\nreturn r->length;\r\n}\r\nstatic int iio_set_length_sw_rb(struct iio_ring_buffer *r, int length)\r\n{\r\nif (r->length != length) {\r\nr->length = length;\r\nif (r->access->mark_param_change)\r\nr->access->mark_param_change(r);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iio_mark_update_needed_sw_rb(struct iio_ring_buffer *r)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nring->update_needed = true;\r\nreturn 0;\r\n}\r\nstatic void iio_sw_rb_release(struct device *dev)\r\n{\r\nstruct iio_ring_buffer *r = to_iio_ring_buffer(dev);\r\niio_ring_access_release(&r->dev);\r\nkfree(iio_to_sw_ring(r));\r\n}\r\nstruct iio_ring_buffer *iio_sw_rb_allocate(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_ring_buffer *buf;\r\nstruct iio_sw_ring_buffer *ring;\r\nring = kzalloc(sizeof *ring, GFP_KERNEL);\r\nif (!ring)\r\nreturn NULL;\r\nring->update_needed = true;\r\nbuf = &ring->buf;\r\niio_ring_buffer_init(buf, indio_dev);\r\n__iio_init_sw_ring_buffer(ring);\r\nbuf->dev.type = &iio_sw_ring_type;\r\nbuf->dev.parent = &indio_dev->dev;\r\ndev_set_drvdata(&buf->dev, (void *)buf);\r\nreturn buf;\r\n}\r\nvoid iio_sw_rb_free(struct iio_ring_buffer *r)\r\n{\r\nif (r)\r\niio_put_ring_buffer(r);\r\n}
