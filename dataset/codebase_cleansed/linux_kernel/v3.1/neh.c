static void uwb_rc_neh_release(struct kref *kref)\r\n{\r\nstruct uwb_rc_neh *neh = container_of(kref, struct uwb_rc_neh, kref);\r\nkfree(neh);\r\n}\r\nstatic void uwb_rc_neh_get(struct uwb_rc_neh *neh)\r\n{\r\nkref_get(&neh->kref);\r\n}\r\nvoid uwb_rc_neh_put(struct uwb_rc_neh *neh)\r\n{\r\nkref_put(&neh->kref, uwb_rc_neh_release);\r\n}\r\nstatic\r\nint __uwb_rc_ctx_get(struct uwb_rc *rc, struct uwb_rc_neh *neh)\r\n{\r\nint result;\r\nresult = find_next_zero_bit(rc->ctx_bm, UWB_RC_CTX_MAX,\r\nrc->ctx_roll++);\r\nif (result < UWB_RC_CTX_MAX)\r\ngoto found;\r\nresult = find_first_zero_bit(rc->ctx_bm, UWB_RC_CTX_MAX);\r\nif (result < UWB_RC_CTX_MAX)\r\ngoto found;\r\nreturn -ENFILE;\r\nfound:\r\nset_bit(result, rc->ctx_bm);\r\nneh->context = result;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid __uwb_rc_ctx_put(struct uwb_rc *rc, struct uwb_rc_neh *neh)\r\n{\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nif (neh->context == 0)\r\nreturn;\r\nif (test_bit(neh->context, rc->ctx_bm) == 0) {\r\ndev_err(dev, "context %u not set in bitmap\n",\r\nneh->context);\r\nWARN_ON(1);\r\n}\r\nclear_bit(neh->context, rc->ctx_bm);\r\nneh->context = 0;\r\n}\r\nstruct uwb_rc_neh *uwb_rc_neh_add(struct uwb_rc *rc, struct uwb_rccb *cmd,\r\nu8 expected_type, u16 expected_event,\r\nuwb_rc_cmd_cb_f cb, void *arg)\r\n{\r\nint result;\r\nunsigned long flags;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_rc_neh *neh;\r\nneh = kzalloc(sizeof(*neh), GFP_KERNEL);\r\nif (neh == NULL) {\r\nresult = -ENOMEM;\r\ngoto error_kzalloc;\r\n}\r\nkref_init(&neh->kref);\r\nINIT_LIST_HEAD(&neh->list_node);\r\ninit_timer(&neh->timer);\r\nneh->timer.function = uwb_rc_neh_timer;\r\nneh->timer.data = (unsigned long)neh;\r\nneh->rc = rc;\r\nneh->evt_type = expected_type;\r\nneh->evt = cpu_to_le16(expected_event);\r\nneh->cb = cb;\r\nneh->arg = arg;\r\nspin_lock_irqsave(&rc->neh_lock, flags);\r\nresult = __uwb_rc_ctx_get(rc, neh);\r\nif (result >= 0) {\r\ncmd->bCommandContext = neh->context;\r\nlist_add_tail(&neh->list_node, &rc->neh_list);\r\nuwb_rc_neh_get(neh);\r\n}\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\nif (result < 0)\r\ngoto error_ctx_get;\r\nreturn neh;\r\nerror_ctx_get:\r\nkfree(neh);\r\nerror_kzalloc:\r\ndev_err(dev, "cannot open handle to radio controller: %d\n", result);\r\nreturn ERR_PTR(result);\r\n}\r\nstatic void __uwb_rc_neh_rm(struct uwb_rc *rc, struct uwb_rc_neh *neh)\r\n{\r\n__uwb_rc_ctx_put(rc, neh);\r\nlist_del(&neh->list_node);\r\n}\r\nvoid uwb_rc_neh_rm(struct uwb_rc *rc, struct uwb_rc_neh *neh)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rc->neh_lock, flags);\r\n__uwb_rc_neh_rm(rc, neh);\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\ndel_timer_sync(&neh->timer);\r\nuwb_rc_neh_put(neh);\r\n}\r\nvoid uwb_rc_neh_arm(struct uwb_rc *rc, struct uwb_rc_neh *neh)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rc->neh_lock, flags);\r\nif (neh->context)\r\nmod_timer(&neh->timer,\r\njiffies + msecs_to_jiffies(UWB_RC_CMD_TIMEOUT_MS));\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\n}\r\nstatic void uwb_rc_neh_cb(struct uwb_rc_neh *neh, struct uwb_rceb *rceb, size_t size)\r\n{\r\n(*neh->cb)(neh->rc, neh->arg, rceb, size);\r\nuwb_rc_neh_put(neh);\r\n}\r\nstatic bool uwb_rc_neh_match(struct uwb_rc_neh *neh, const struct uwb_rceb *rceb)\r\n{\r\nreturn neh->evt_type == rceb->bEventType\r\n&& neh->evt == rceb->wEvent\r\n&& neh->context == rceb->bEventContext;\r\n}\r\nstatic\r\nstruct uwb_rc_neh *uwb_rc_neh_lookup(struct uwb_rc *rc,\r\nconst struct uwb_rceb *rceb)\r\n{\r\nstruct uwb_rc_neh *neh = NULL, *h;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rc->neh_lock, flags);\r\nlist_for_each_entry(h, &rc->neh_list, list_node) {\r\nif (uwb_rc_neh_match(h, rceb)) {\r\nneh = h;\r\nbreak;\r\n}\r\n}\r\nif (neh)\r\n__uwb_rc_neh_rm(rc, neh);\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\nreturn neh;\r\n}\r\nstatic\r\nvoid uwb_rc_notif(struct uwb_rc *rc, struct uwb_rceb *rceb, ssize_t size)\r\n{\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_event *uwb_evt;\r\nif (size == -ESHUTDOWN)\r\nreturn;\r\nif (size < 0) {\r\ndev_err(dev, "ignoring event with error code %zu\n",\r\nsize);\r\nreturn;\r\n}\r\nuwb_evt = kzalloc(sizeof(*uwb_evt), GFP_ATOMIC);\r\nif (unlikely(uwb_evt == NULL)) {\r\ndev_err(dev, "no memory to queue event 0x%02x/%04x/%02x\n",\r\nrceb->bEventType, le16_to_cpu(rceb->wEvent),\r\nrceb->bEventContext);\r\nreturn;\r\n}\r\nuwb_evt->rc = __uwb_rc_get(rc);\r\nuwb_evt->ts_jiffies = jiffies;\r\nuwb_evt->type = UWB_EVT_TYPE_NOTIF;\r\nuwb_evt->notif.size = size;\r\nuwb_evt->notif.rceb = rceb;\r\nuwbd_event_queue(uwb_evt);\r\n}\r\nstatic void uwb_rc_neh_grok_event(struct uwb_rc *rc, struct uwb_rceb *rceb, size_t size)\r\n{\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_rc_neh *neh;\r\nstruct uwb_rceb *notif;\r\nif (rceb->bEventContext == 0) {\r\nnotif = kmalloc(size, GFP_ATOMIC);\r\nif (notif) {\r\nmemcpy(notif, rceb, size);\r\nuwb_rc_notif(rc, notif, size);\r\n} else\r\ndev_err(dev, "event 0x%02x/%04x/%02x (%zu bytes): no memory\n",\r\nrceb->bEventType, le16_to_cpu(rceb->wEvent),\r\nrceb->bEventContext, size);\r\n} else {\r\nneh = uwb_rc_neh_lookup(rc, rceb);\r\nif (neh) {\r\ndel_timer_sync(&neh->timer);\r\nuwb_rc_neh_cb(neh, rceb, size);\r\n} else\r\ndev_warn(dev, "event 0x%02x/%04x/%02x (%zu bytes): nobody cared\n",\r\nrceb->bEventType, le16_to_cpu(rceb->wEvent),\r\nrceb->bEventContext, size);\r\n}\r\n}\r\nvoid uwb_rc_neh_grok(struct uwb_rc *rc, void *buf, size_t buf_size)\r\n{\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nvoid *itr;\r\nstruct uwb_rceb *rceb;\r\nsize_t size, real_size, event_size;\r\nint needtofree;\r\nitr = buf;\r\nsize = buf_size;\r\nwhile (size > 0) {\r\nif (size < sizeof(*rceb)) {\r\ndev_err(dev, "not enough data in event buffer to "\r\n"process incoming events (%zu left, minimum is "\r\n"%zu)\n", size, sizeof(*rceb));\r\nbreak;\r\n}\r\nrceb = itr;\r\nif (rc->filter_event) {\r\nneedtofree = rc->filter_event(rc, &rceb, size,\r\n&real_size, &event_size);\r\nif (needtofree < 0 && needtofree != -ENOANO) {\r\ndev_err(dev, "BUG: Unable to filter event "\r\n"(0x%02x/%04x/%02x) from "\r\n"device. \n", rceb->bEventType,\r\nle16_to_cpu(rceb->wEvent),\r\nrceb->bEventContext);\r\nbreak;\r\n}\r\n} else\r\nneedtofree = -ENOANO;\r\nif (needtofree == -ENOANO) {\r\nssize_t ret = uwb_est_find_size(rc, rceb, size);\r\nif (ret < 0)\r\nbreak;\r\nif (ret > size) {\r\ndev_err(dev, "BUG: hw sent incomplete event "\r\n"0x%02x/%04x/%02x (%zd bytes), only got "\r\n"%zu bytes. We don't handle that.\n",\r\nrceb->bEventType, le16_to_cpu(rceb->wEvent),\r\nrceb->bEventContext, ret, size);\r\nbreak;\r\n}\r\nreal_size = event_size = ret;\r\n}\r\nuwb_rc_neh_grok_event(rc, rceb, event_size);\r\nif (needtofree == 1)\r\nkfree(rceb);\r\nitr += real_size;\r\nsize -= real_size;\r\n}\r\n}\r\nvoid uwb_rc_neh_error(struct uwb_rc *rc, int error)\r\n{\r\nstruct uwb_rc_neh *neh;\r\nunsigned long flags;\r\nfor (;;) {\r\nspin_lock_irqsave(&rc->neh_lock, flags);\r\nif (list_empty(&rc->neh_list)) {\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\nbreak;\r\n}\r\nneh = list_first_entry(&rc->neh_list, struct uwb_rc_neh, list_node);\r\n__uwb_rc_neh_rm(rc, neh);\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\ndel_timer_sync(&neh->timer);\r\nuwb_rc_neh_cb(neh, NULL, error);\r\n}\r\n}\r\nstatic void uwb_rc_neh_timer(unsigned long arg)\r\n{\r\nstruct uwb_rc_neh *neh = (struct uwb_rc_neh *)arg;\r\nstruct uwb_rc *rc = neh->rc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rc->neh_lock, flags);\r\nif (neh->context)\r\n__uwb_rc_neh_rm(rc, neh);\r\nelse\r\nneh = NULL;\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\nif (neh)\r\nuwb_rc_neh_cb(neh, NULL, -ETIMEDOUT);\r\n}\r\nvoid uwb_rc_neh_create(struct uwb_rc *rc)\r\n{\r\nspin_lock_init(&rc->neh_lock);\r\nINIT_LIST_HEAD(&rc->neh_list);\r\nset_bit(0, rc->ctx_bm);\r\nset_bit(0xff, rc->ctx_bm);\r\nrc->ctx_roll = 1;\r\n}\r\nvoid uwb_rc_neh_destroy(struct uwb_rc *rc)\r\n{\r\nunsigned long flags;\r\nstruct uwb_rc_neh *neh;\r\nfor (;;) {\r\nspin_lock_irqsave(&rc->neh_lock, flags);\r\nif (list_empty(&rc->neh_list)) {\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\nbreak;\r\n}\r\nneh = list_first_entry(&rc->neh_list, struct uwb_rc_neh, list_node);\r\n__uwb_rc_neh_rm(rc, neh);\r\nspin_unlock_irqrestore(&rc->neh_lock, flags);\r\ndel_timer_sync(&neh->timer);\r\nuwb_rc_neh_put(neh);\r\n}\r\n}
