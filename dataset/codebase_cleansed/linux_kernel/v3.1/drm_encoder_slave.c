int drm_i2c_encoder_init(struct drm_device *dev,\r\nstruct drm_encoder_slave *encoder,\r\nstruct i2c_adapter *adap,\r\nconst struct i2c_board_info *info)\r\n{\r\nchar modalias[sizeof(I2C_MODULE_PREFIX)\r\n+ I2C_NAME_SIZE];\r\nstruct module *module = NULL;\r\nstruct i2c_client *client;\r\nstruct drm_i2c_encoder_driver *encoder_drv;\r\nint err = 0;\r\nsnprintf(modalias, sizeof(modalias),\r\n"%s%s", I2C_MODULE_PREFIX, info->type);\r\nrequest_module(modalias);\r\nclient = i2c_new_device(adap, info);\r\nif (!client) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (!client->driver) {\r\nerr = -ENODEV;\r\ngoto fail_unregister;\r\n}\r\nmodule = client->driver->driver.owner;\r\nif (!try_module_get(module)) {\r\nerr = -ENODEV;\r\ngoto fail_unregister;\r\n}\r\nencoder->bus_priv = client;\r\nencoder_drv = to_drm_i2c_encoder_driver(client->driver);\r\nerr = encoder_drv->encoder_init(client, dev, encoder);\r\nif (err)\r\ngoto fail_unregister;\r\nif (info->platform_data)\r\nencoder->slave_funcs->set_config(&encoder->base,\r\ninfo->platform_data);\r\nreturn 0;\r\nfail_unregister:\r\ni2c_unregister_device(client);\r\nmodule_put(module);\r\nfail:\r\nreturn err;\r\n}\r\nvoid drm_i2c_encoder_destroy(struct drm_encoder *drm_encoder)\r\n{\r\nstruct drm_encoder_slave *encoder = to_encoder_slave(drm_encoder);\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(drm_encoder);\r\nstruct module *module = client->driver->driver.owner;\r\ni2c_unregister_device(client);\r\nencoder->bus_priv = NULL;\r\nmodule_put(module);\r\n}
