void *\r\ngetuserbychan (int channum)\r\n{\r\nmch_t *ch;\r\nch = c4_find_chan (channum);\r\nreturn ch ? ch->user : 0;\r\n}\r\nchar *\r\nget_hdlc_name (hdlc_device * hdlc)\r\n{\r\nstruct c4_priv *priv = hdlc->priv;\r\nstruct net_device *dev = getuserbychan (priv->channum);\r\nreturn dev->name;\r\n}\r\nstatic status_t\r\nmkret (int bsd)\r\n{\r\nif (bsd > 0)\r\nreturn -bsd;\r\nelse\r\nreturn bsd;\r\n}\r\nvoid\r\nc4_wk_chan_restart (mch_t * ch)\r\n{\r\nmpi_t *pi = ch->up;\r\n#ifdef RLD_RESTART_DEBUG\r\npr_info(">> %s: queueing Port %d Chan %d, mch_t @ %p\n",\r\n__func__, pi->portnum, ch->channum, ch);\r\n#endif\r\nqueue_work (pi->wq_port, &ch->ch_work);\r\n}\r\nstatus_t\r\nc4_wk_chan_init (mpi_t * pi, mch_t * ch)\r\n{\r\nINIT_WORK(&ch->ch_work, (void *)musycc_wq_chan_restart);\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_wq_port_init (mpi_t * pi)\r\n{\r\nchar name[16], *np;\r\nif (pi->wq_port)\r\nreturn 0;\r\nnp = name;\r\nmemset (name, 0, 16);\r\nsprintf (np, "%s%d", pi->up->devname, pi->portnum);\r\n#ifdef RLD_RESTART_DEBUG\r\npr_info(">> %s: creating workqueue <%s> for Port %d.\n",\r\n__func__, name, pi->portnum);\r\n#endif\r\nif (!(pi->wq_port = create_singlethread_workqueue (name)))\r\nreturn ENOMEM;\r\nreturn 0;\r\n}\r\nvoid\r\nc4_wq_port_cleanup (mpi_t * pi)\r\n{\r\nif (pi->wq_port)\r\n{\r\ndestroy_workqueue (pi->wq_port);\r\npi->wq_port = 0;\r\n}\r\n}\r\nirqreturn_t\r\nc4_linux_interrupt (int irq, void *dev_instance)\r\n{\r\nstruct net_device *ndev = dev_instance;\r\nreturn musycc_intr_th_handler(netdev_priv(ndev));\r\n}\r\nirqreturn_t\r\nc4_ebus_interrupt (int irq, void *dev_instance)\r\n{\r\nstruct net_device *ndev = dev_instance;\r\nreturn c4_ebus_intr_th_handler(netdev_priv(ndev));\r\n}\r\nstatic int\r\nvoid_open (struct net_device * ndev)\r\n{\r\npr_info("%s: trying to open master device !\n", ndev->name);\r\nreturn -1;\r\n}\r\nSTATIC int\r\nchan_open (struct net_device * ndev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc (ndev);\r\nconst struct c4_priv *priv = hdlc->priv;\r\nint ret;\r\nif ((ret = hdlc_open (ndev)))\r\n{\r\npr_info("hdlc_open failure, err %d.\n", ret);\r\nreturn ret;\r\n}\r\nif ((ret = c4_chan_up (priv->ci, priv->channum)))\r\nreturn -ret;\r\ntry_module_get (THIS_MODULE);\r\nnetif_start_queue (ndev);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nchan_close (struct net_device * ndev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc (ndev);\r\nconst struct c4_priv *priv = hdlc->priv;\r\nnetif_stop_queue (ndev);\r\nmusycc_chan_down ((ci_t *) 0, priv->channum);\r\nhdlc_close (ndev);\r\nmodule_put (THIS_MODULE);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nchan_dev_ioctl (struct net_device * dev, struct ifreq * ifr, int cmd)\r\n{\r\nreturn hdlc_ioctl (dev, ifr, cmd);\r\n}\r\nSTATIC int\r\nchan_attach_noop (struct net_device * ndev, unsigned short foo_1, unsigned short foo_2)\r\n{\r\nreturn 0;\r\n}\r\nSTATIC struct net_device_stats *\r\nchan_get_stats (struct net_device * ndev)\r\n{\r\nmch_t *ch;\r\nstruct net_device_stats *nstats;\r\nstruct sbecom_chan_stats *stats;\r\nint channum;\r\n{\r\nstruct c4_priv *priv;\r\npriv = (struct c4_priv *) dev_to_hdlc (ndev)->priv;\r\nchannum = priv->channum;\r\n}\r\nch = c4_find_chan (channum);\r\nif (ch == NULL)\r\nreturn NULL;\r\nnstats = &ndev->stats;\r\nstats = &ch->s;\r\nmemset (nstats, 0, sizeof (struct net_device_stats));\r\nnstats->rx_packets = stats->rx_packets;\r\nnstats->tx_packets = stats->tx_packets;\r\nnstats->rx_bytes = stats->rx_bytes;\r\nnstats->tx_bytes = stats->tx_bytes;\r\nnstats->rx_errors = stats->rx_length_errors +\r\nstats->rx_over_errors +\r\nstats->rx_crc_errors +\r\nstats->rx_frame_errors +\r\nstats->rx_fifo_errors +\r\nstats->rx_missed_errors;\r\nnstats->tx_errors = stats->tx_dropped +\r\nstats->tx_aborted_errors +\r\nstats->tx_fifo_errors;\r\nnstats->rx_dropped = stats->rx_dropped;\r\nnstats->tx_dropped = stats->tx_dropped;\r\nnstats->rx_length_errors = stats->rx_length_errors;\r\nnstats->rx_over_errors = stats->rx_over_errors;\r\nnstats->rx_crc_errors = stats->rx_crc_errors;\r\nnstats->rx_frame_errors = stats->rx_frame_errors;\r\nnstats->rx_fifo_errors = stats->rx_fifo_errors;\r\nnstats->rx_missed_errors = stats->rx_missed_errors;\r\nnstats->tx_aborted_errors = stats->tx_aborted_errors;\r\nnstats->tx_fifo_errors = stats->tx_fifo_errors;\r\nreturn nstats;\r\n}\r\nstatic ci_t *\r\nget_ci_by_dev (struct net_device * ndev)\r\n{\r\nreturn (ci_t *)(netdev_priv(ndev));\r\n}\r\nSTATIC int\r\nc4_linux_xmit (struct sk_buff * skb, struct net_device * ndev)\r\n{\r\nconst struct c4_priv *priv;\r\nint rval;\r\nhdlc_device *hdlc = dev_to_hdlc (ndev);\r\npriv = hdlc->priv;\r\nrval = musycc_start_xmit (priv->ci, priv->channum, skb);\r\nreturn -rval;\r\n}\r\nSTATIC struct net_device *\r\ncreate_chan (struct net_device * ndev, ci_t * ci,\r\nstruct sbecom_chan_param * cp)\r\n{\r\nhdlc_device *hdlc;\r\nstruct net_device *dev;\r\nhdw_info_t *hi;\r\nint ret;\r\nif (c4_find_chan (cp->channum))\r\nreturn 0;\r\n{\r\nstruct c4_priv *priv;\r\npriv = OS_kmalloc (sizeof (struct c4_priv));\r\nif (!priv)\r\n{\r\npr_warning("%s: no memory for net_device !\n", ci->devname);\r\nreturn 0;\r\n}\r\ndev = alloc_hdlcdev (priv);\r\nif (!dev)\r\n{\r\npr_warning("%s: no memory for hdlc_device !\n", ci->devname);\r\nOS_kfree (priv);\r\nreturn 0;\r\n}\r\npriv->ci = ci;\r\npriv->channum = cp->channum;\r\n}\r\nhdlc = dev_to_hdlc (dev);\r\ndev->base_addr = 0;\r\ndev->irq = ndev->irq;\r\ndev->type = ARPHRD_RAWHDLC;\r\n*dev->name = 0;\r\nhi = (hdw_info_t *) ci->hdw_info;\r\nif (hi->mfg_info_sts == EEPROM_OK)\r\n{\r\nswitch (hi->promfmt)\r\n{\r\ncase PROM_FORMAT_TYPE1:\r\nmemcpy (dev->dev_addr, (FLD_TYPE1 *) (hi->mfg_info.pft1.Serial), 6);\r\nbreak;\r\ncase PROM_FORMAT_TYPE2:\r\nmemcpy (dev->dev_addr, (FLD_TYPE2 *) (hi->mfg_info.pft2.Serial), 6);\r\nbreak;\r\ndefault:\r\nmemset (dev->dev_addr, 0, 6);\r\nbreak;\r\n}\r\n} else\r\n{\r\nmemset (dev->dev_addr, 0, 6);\r\n}\r\nhdlc->xmit = c4_linux_xmit;\r\ndev->netdev_ops = &chan_ops;\r\nhdlc->attach = chan_attach_noop;\r\nrtnl_unlock ();\r\nret = register_hdlc_device (dev);\r\ndev->tx_queue_len = MAX_DEFAULT_IFQLEN;\r\nrtnl_lock ();\r\nif (ret)\r\n{\r\nif (cxt1e1_log_level >= LOG_WARN)\r\npr_info("%s: create_chan[%d] registration error = %d.\n",\r\nci->devname, cp->channum, ret);\r\nfree_netdev (dev);\r\nreturn 0;\r\n}\r\nreturn dev;\r\n}\r\nSTATIC status_t\r\ndo_get_port (struct net_device * ndev, void *data)\r\n{\r\nint ret;\r\nci_t *ci;\r\nstruct sbecom_port_param pp;\r\nif (copy_from_user (&pp, data, sizeof (struct sbecom_port_param)))\r\nreturn -EFAULT;\r\nif (pp.portnum >= MUSYCC_NPORTS)\r\nreturn -EFAULT;\r\nci = get_ci_by_dev (ndev);\r\nif (!ci)\r\nreturn -EINVAL;\r\nret = mkret (c4_get_port (ci, pp.portnum));\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user (data, &ci->port[pp.portnum].p,\r\nsizeof (struct sbecom_port_param)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC status_t\r\ndo_set_port (struct net_device * ndev, void *data)\r\n{\r\nci_t *ci;\r\nstruct sbecom_port_param pp;\r\nif (copy_from_user (&pp, data, sizeof (struct sbecom_port_param)))\r\nreturn -EFAULT;\r\nif (pp.portnum >= MUSYCC_NPORTS)\r\nreturn -EFAULT;\r\nci = get_ci_by_dev (ndev);\r\nif (!ci)\r\nreturn -EINVAL;\r\nif (pp.portnum >= ci->max_port)\r\nreturn -ENXIO;\r\nmemcpy (&ci->port[pp.portnum].p, &pp, sizeof (struct sbecom_port_param));\r\nreturn mkret (c4_set_port (ci, pp.portnum));\r\n}\r\nSTATIC status_t\r\ndo_port_loop (struct net_device * ndev, void *data)\r\n{\r\nstruct sbecom_port_param pp;\r\nci_t *ci;\r\nif (copy_from_user (&pp, data, sizeof (struct sbecom_port_param)))\r\nreturn -EFAULT;\r\nci = get_ci_by_dev (ndev);\r\nif (!ci)\r\nreturn -EINVAL;\r\nreturn mkret (c4_loop_port (ci, pp.portnum, pp.port_mode));\r\n}\r\nSTATIC status_t\r\ndo_framer_rw (struct net_device * ndev, void *data)\r\n{\r\nstruct sbecom_port_param pp;\r\nci_t *ci;\r\nint ret;\r\nif (copy_from_user (&pp, data, sizeof (struct sbecom_port_param)))\r\nreturn -EFAULT;\r\nci = get_ci_by_dev (ndev);\r\nif (!ci)\r\nreturn -EINVAL;\r\nret = mkret (c4_frame_rw (ci, &pp));\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user (data, &pp, sizeof (struct sbecom_port_param)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC status_t\r\ndo_pld_rw (struct net_device * ndev, void *data)\r\n{\r\nstruct sbecom_port_param pp;\r\nci_t *ci;\r\nint ret;\r\nif (copy_from_user (&pp, data, sizeof (struct sbecom_port_param)))\r\nreturn -EFAULT;\r\nci = get_ci_by_dev (ndev);\r\nif (!ci)\r\nreturn -EINVAL;\r\nret = mkret (c4_pld_rw (ci, &pp));\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user (data, &pp, sizeof (struct sbecom_port_param)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC status_t\r\ndo_musycc_rw (struct net_device * ndev, void *data)\r\n{\r\nstruct c4_musycc_param mp;\r\nci_t *ci;\r\nint ret;\r\nif (copy_from_user (&mp, data, sizeof (struct c4_musycc_param)))\r\nreturn -EFAULT;\r\nci = get_ci_by_dev (ndev);\r\nif (!ci)\r\nreturn -EINVAL;\r\nret = mkret (c4_musycc_rw (ci, &mp));\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user (data, &mp, sizeof (struct c4_musycc_param)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC status_t\r\ndo_get_chan (struct net_device * ndev, void *data)\r\n{\r\nstruct sbecom_chan_param cp;\r\nint ret;\r\nif (copy_from_user (&cp, data,\r\nsizeof (struct sbecom_chan_param)))\r\nreturn -EFAULT;\r\nif ((ret = mkret (c4_get_chan (cp.channum, &cp))))\r\nreturn ret;\r\nif (copy_to_user (data, &cp, sizeof (struct sbecom_chan_param)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC status_t\r\ndo_set_chan (struct net_device * ndev, void *data)\r\n{\r\nstruct sbecom_chan_param cp;\r\nint ret;\r\nci_t *ci;\r\nif (copy_from_user (&cp, data, sizeof (struct sbecom_chan_param)))\r\nreturn -EFAULT;\r\nci = get_ci_by_dev (ndev);\r\nif (!ci)\r\nreturn -EINVAL;\r\nswitch (ret = mkret (c4_set_chan (cp.channum, &cp)))\r\n{\r\ncase 0:\r\nreturn 0;\r\ndefault:\r\nreturn ret;\r\n}\r\n}\r\nSTATIC status_t\r\ndo_create_chan (struct net_device * ndev, void *data)\r\n{\r\nci_t *ci;\r\nstruct net_device *dev;\r\nstruct sbecom_chan_param cp;\r\nint ret;\r\nif (copy_from_user (&cp, data, sizeof (struct sbecom_chan_param)))\r\nreturn -EFAULT;\r\nci = get_ci_by_dev (ndev);\r\nif (!ci)\r\nreturn -EINVAL;\r\ndev = create_chan (ndev, ci, &cp);\r\nif (!dev)\r\nreturn -EBUSY;\r\nret = mkret (c4_new_chan (ci, cp.port, cp.channum, dev));\r\nif (ret)\r\n{\r\nrtnl_unlock ();\r\nunregister_hdlc_device (dev);\r\nrtnl_lock ();\r\nfree_netdev (dev);\r\n}\r\nreturn ret;\r\n}\r\nSTATIC status_t\r\ndo_get_chan_stats (struct net_device * ndev, void *data)\r\n{\r\nstruct c4_chan_stats_wrap ccs;\r\nint ret;\r\nif (copy_from_user (&ccs, data,\r\nsizeof (struct c4_chan_stats_wrap)))\r\nreturn -EFAULT;\r\nswitch (ret = mkret (c4_get_chan_stats (ccs.channum, &ccs.stats)))\r\n{\r\ncase 0:\r\nbreak;\r\ndefault:\r\nreturn ret;\r\n}\r\nif (copy_to_user (data, &ccs,\r\nsizeof (struct c4_chan_stats_wrap)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC status_t\r\ndo_set_loglevel (struct net_device * ndev, void *data)\r\n{\r\nunsigned int cxt1e1_log_level;\r\nif (copy_from_user (&cxt1e1_log_level, data, sizeof (int)))\r\nreturn -EFAULT;\r\nsbecom_set_loglevel (cxt1e1_log_level);\r\nreturn 0;\r\n}\r\nSTATIC status_t\r\ndo_deluser (struct net_device * ndev, int lockit)\r\n{\r\nif (ndev->flags & IFF_UP)\r\nreturn -EBUSY;\r\n{\r\nci_t *ci;\r\nmch_t *ch;\r\nconst struct c4_priv *priv;\r\nint channum;\r\npriv = (struct c4_priv *) dev_to_hdlc (ndev)->priv;\r\nci = priv->ci;\r\nchannum = priv->channum;\r\nch = c4_find_chan (channum);\r\nif (ch == NULL)\r\nreturn -ENOENT;\r\nch->user = 0;\r\n}\r\nif (lockit)\r\nrtnl_unlock ();\r\nunregister_hdlc_device (ndev);\r\nif (lockit)\r\nrtnl_lock ();\r\nfree_netdev (ndev);\r\nreturn 0;\r\n}\r\nint\r\ndo_del_chan (struct net_device * musycc_dev, void *data)\r\n{\r\nstruct sbecom_chan_param cp;\r\nchar buf[sizeof (CHANNAME) + 3];\r\nstruct net_device *dev;\r\nint ret;\r\nif (copy_from_user (&cp, data,\r\nsizeof (struct sbecom_chan_param)))\r\nreturn -EFAULT;\r\nsprintf (buf, CHANNAME "%d", cp.channum);\r\nif (!(dev = dev_get_by_name (&init_net, buf)))\r\nreturn -ENOENT;\r\ndev_put (dev);\r\nret = do_deluser (dev, 1);\r\nif (ret)\r\nreturn ret;\r\nreturn c4_del_chan (cp.channum);\r\n}\r\nint\r\ndo_reset (struct net_device * musycc_dev, void *data)\r\n{\r\nconst struct c4_priv *priv;\r\nint i;\r\nfor (i = 0; i < 128; i++)\r\n{\r\nstruct net_device *ndev;\r\nchar buf[sizeof (CHANNAME) + 3];\r\nsprintf (buf, CHANNAME "%d", i);\r\nif (!(ndev = dev_get_by_name(&init_net, buf)))\r\ncontinue;\r\npriv = dev_to_hdlc (ndev)->priv;\r\nif ((unsigned long) (priv->ci) ==\r\n(unsigned long) (netdev_priv(musycc_dev)))\r\n{\r\nndev->flags &= ~IFF_UP;\r\ndev_put (ndev);\r\nnetif_stop_queue (ndev);\r\ndo_deluser (ndev, 1);\r\n} else\r\ndev_put (ndev);\r\n}\r\nreturn 0;\r\n}\r\nint\r\ndo_reset_chan_stats (struct net_device * musycc_dev, void *data)\r\n{\r\nstruct sbecom_chan_param cp;\r\nif (copy_from_user (&cp, data,\r\nsizeof (struct sbecom_chan_param)))\r\nreturn -EFAULT;\r\nreturn mkret (c4_del_chan_stats (cp.channum));\r\n}\r\nSTATIC status_t\r\nc4_ioctl (struct net_device * ndev, struct ifreq * ifr, int cmd)\r\n{\r\nci_t *ci;\r\nvoid *data;\r\nint iocmd, iolen;\r\nstatus_t ret;\r\nstatic struct data\r\n{\r\nunion\r\n{\r\nu_int8_t c;\r\nu_int32_t i;\r\nstruct sbe_brd_info bip;\r\nstruct sbe_drv_info dip;\r\nstruct sbe_iid_info iip;\r\nstruct sbe_brd_addr bap;\r\nstruct sbecom_chan_stats stats;\r\nstruct sbecom_chan_param param;\r\nstruct temux_card_stats cards;\r\nstruct sbecom_card_param cardp;\r\nstruct sbecom_framer_param frp;\r\n} u;\r\n} arg;\r\nif (!capable (CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (cmd != SIOCDEVPRIVATE + 15)\r\nreturn -EINVAL;\r\nif (!(ci = get_ci_by_dev (ndev)))\r\nreturn -EINVAL;\r\nif (ci->state != C_RUNNING)\r\nreturn -ENODEV;\r\nif (copy_from_user (&iocmd, ifr->ifr_data, sizeof (iocmd)))\r\nreturn -EFAULT;\r\n#if 0\r\nif (copy_from_user (&len, ifr->ifr_data + sizeof (iocmd), sizeof (len)))\r\nreturn -EFAULT;\r\n#endif\r\n#if 0\r\npr_info("c4_ioctl: iocmd %x, dir %x type %x nr %x iolen %d.\n", iocmd,\r\n_IOC_DIR (iocmd), _IOC_TYPE (iocmd), _IOC_NR (iocmd),\r\n_IOC_SIZE (iocmd));\r\n#endif\r\niolen = _IOC_SIZE (iocmd);\r\ndata = ifr->ifr_data + sizeof (iocmd);\r\nif (copy_from_user (&arg, data, iolen))\r\nreturn -EFAULT;\r\nret = 0;\r\nswitch (iocmd)\r\n{\r\ncase SBE_IOC_PORT_GET:\r\nret = do_get_port (ndev, data);\r\nbreak;\r\ncase SBE_IOC_PORT_SET:\r\nret = do_set_port (ndev, data);\r\nbreak;\r\ncase SBE_IOC_CHAN_GET:\r\nret = do_get_chan (ndev, data);\r\nbreak;\r\ncase SBE_IOC_CHAN_SET:\r\nret = do_set_chan (ndev, data);\r\nbreak;\r\ncase C4_DEL_CHAN:\r\nret = do_del_chan (ndev, data);\r\nbreak;\r\ncase SBE_IOC_CHAN_NEW:\r\nret = do_create_chan (ndev, data);\r\nbreak;\r\ncase SBE_IOC_CHAN_GET_STAT:\r\nret = do_get_chan_stats (ndev, data);\r\nbreak;\r\ncase SBE_IOC_LOGLEVEL:\r\nret = do_set_loglevel (ndev, data);\r\nbreak;\r\ncase SBE_IOC_RESET_DEV:\r\nret = do_reset (ndev, data);\r\nbreak;\r\ncase SBE_IOC_CHAN_DEL_STAT:\r\nret = do_reset_chan_stats (ndev, data);\r\nbreak;\r\ncase C4_LOOP_PORT:\r\nret = do_port_loop (ndev, data);\r\nbreak;\r\ncase C4_RW_FRMR:\r\nret = do_framer_rw (ndev, data);\r\nbreak;\r\ncase C4_RW_MSYC:\r\nret = do_musycc_rw (ndev, data);\r\nbreak;\r\ncase C4_RW_PLD:\r\nret = do_pld_rw (ndev, data);\r\nbreak;\r\ncase SBE_IOC_IID_GET:\r\nret = (iolen == sizeof (struct sbe_iid_info)) ? c4_get_iidinfo (ci, &arg.u.iip) : -EFAULT;\r\nif (ret == 0)\r\nif (copy_to_user (data, &arg, iolen))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn mkret (ret);\r\n}\r\nstatic void c4_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_VOID;\r\ndev->netdev_ops = &c4_ops;\r\n}\r\nstruct net_device *__init\r\nc4_add_dev (hdw_info_t * hi, int brdno, unsigned long f0, unsigned long f1,\r\nint irq0, int irq1)\r\n{\r\nstruct net_device *ndev;\r\nci_t *ci;\r\nndev = alloc_netdev(sizeof(ci_t), SBE_IFACETMPL, c4_setup);\r\nif (!ndev)\r\n{\r\npr_warning("%s: no memory for struct net_device !\n", hi->devname);\r\nerror_flag = ENOMEM;\r\nreturn 0;\r\n}\r\nci = (ci_t *)(netdev_priv(ndev));\r\nndev->irq = irq0;\r\nci->hdw_info = hi;\r\nci->state = C_INIT;\r\nci->next = c4_list;\r\nc4_list = ci;\r\nci->brdno = ci->next ? ci->next->brdno + 1 : 0;\r\nif (CI == 0)\r\nCI = ci;\r\nstrcpy (ci->devname, hi->devname);\r\nci->release = &pmcc4_OSSI_release[0];\r\n#if defined(SBE_ISR_TASKLET)\r\ntasklet_init (&ci->ci_musycc_isr_tasklet,\r\n(void (*) (unsigned long)) musycc_intr_bh_tasklet,\r\n(unsigned long) ci);\r\nif (atomic_read (&ci->ci_musycc_isr_tasklet.count) == 0)\r\ntasklet_disable_nosync (&ci->ci_musycc_isr_tasklet);\r\n#elif defined(SBE_ISR_IMMEDIATE)\r\nci->ci_musycc_isr_tq.routine = (void *) (unsigned long) musycc_intr_bh_tasklet;\r\nci->ci_musycc_isr_tq.data = ci;\r\n#endif\r\nif (register_netdev (ndev) ||\r\n(c4_init (ci, (u_char *) f0, (u_char *) f1) != SBE_DRVR_SUCCESS))\r\n{\r\nOS_kfree (netdev_priv(ndev));\r\nOS_kfree (ndev);\r\nerror_flag = ENODEV;\r\nreturn 0;\r\n}\r\nif (request_irq (irq0, &c4_linux_interrupt,\r\n#if defined(SBE_ISR_TASKLET)\r\nIRQF_DISABLED | IRQF_SHARED,\r\n#elif defined(SBE_ISR_IMMEDIATE)\r\nIRQF_DISABLED | IRQF_SHARED,\r\n#elif defined(SBE_ISR_INLINE)\r\nIRQF_SHARED,\r\n#endif\r\nndev->name, ndev))\r\n{\r\npr_warning("%s: MUSYCC could not get irq: %d\n", ndev->name, irq0);\r\nunregister_netdev (ndev);\r\nOS_kfree (netdev_priv(ndev));\r\nOS_kfree (ndev);\r\nerror_flag = EIO;\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_SBE_PMCC4_NCOMM\r\nif (request_irq (irq1, &c4_ebus_interrupt, IRQF_SHARED, ndev->name, ndev))\r\n{\r\npr_warning("%s: EBUS could not get irq: %d\n", hi->devname, irq1);\r\nunregister_netdev (ndev);\r\nfree_irq (irq0, ndev);\r\nOS_kfree (netdev_priv(ndev));\r\nOS_kfree (ndev);\r\nerror_flag = EIO;\r\nreturn 0;\r\n}\r\n#endif\r\n{\r\nu_int32_t tmp;\r\nhdw_sn_get (hi, brdno);\r\nswitch (hi->promfmt)\r\n{\r\ncase PROM_FORMAT_TYPE1:\r\nmemcpy (ndev->dev_addr, (FLD_TYPE1 *) (hi->mfg_info.pft1.Serial), 6);\r\nmemcpy (&tmp, (FLD_TYPE1 *) (hi->mfg_info.pft1.Id), 4);\r\nci->brd_id = cpu_to_be32 (tmp);\r\nbreak;\r\ncase PROM_FORMAT_TYPE2:\r\nmemcpy (ndev->dev_addr, (FLD_TYPE2 *) (hi->mfg_info.pft2.Serial), 6);\r\nmemcpy (&tmp, (FLD_TYPE2 *) (hi->mfg_info.pft2.Id), 4);\r\nci->brd_id = cpu_to_be32 (tmp);\r\nbreak;\r\ndefault:\r\nci->brd_id = 0;\r\nmemset (ndev->dev_addr, 0, 6);\r\nbreak;\r\n}\r\n#if 1\r\nsbeid_set_hdwbid (ci);\r\n#else\r\nsbeid_set_bdtype (ci);\r\n#endif\r\n}\r\n#ifdef CONFIG_PROC_FS\r\nsbecom_proc_brd_init (ci);\r\n#endif\r\n#if defined(SBE_ISR_TASKLET)\r\ntasklet_enable (&ci->ci_musycc_isr_tasklet);\r\n#endif\r\nif ((error_flag = c4_init2 (ci)) != SBE_DRVR_SUCCESS)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nsbecom_proc_brd_cleanup (ci);\r\n#endif\r\nunregister_netdev (ndev);\r\nfree_irq (irq1, ndev);\r\nfree_irq (irq0, ndev);\r\nOS_kfree (netdev_priv(ndev));\r\nOS_kfree (ndev);\r\nreturn 0;\r\n}\r\nreturn ndev;\r\n}\r\nSTATIC int __init\r\nc4_mod_init (void)\r\n{\r\nint rtn;\r\npr_warning("%s\n", pmcc4_OSSI_release);\r\nif ((rtn = c4hw_attach_all ()))\r\nreturn -rtn;\r\nif (cxt1e1_log_level != log_level_default)\r\npr_info("NOTE: driver parameter <cxt1e1_log_level> changed from default %d to %d.\n",\r\nlog_level_default, cxt1e1_log_level);\r\nif (cxt1e1_max_mru != max_mru_default)\r\npr_info("NOTE: driver parameter <cxt1e1_max_mru> changed from default %d to %d.\n",\r\nmax_mru_default, cxt1e1_max_mru);\r\nif (cxt1e1_max_mtu != max_mtu_default)\r\npr_info("NOTE: driver parameter <cxt1e1_max_mtu> changed from default %d to %d.\n",\r\nmax_mtu_default, cxt1e1_max_mtu);\r\nif (max_rxdesc_used != max_rxdesc_default)\r\n{\r\nif (max_rxdesc_used > 2000)\r\nmax_rxdesc_used = 2000;\r\npr_info("NOTE: driver parameter <max_rxdesc_used> changed from default %d to %d.\n",\r\nmax_rxdesc_default, max_rxdesc_used);\r\n}\r\nif (max_txdesc_used != max_txdesc_default)\r\n{\r\nif (max_txdesc_used > 1000)\r\nmax_txdesc_used = 1000;\r\npr_info("NOTE: driver parameter <max_txdesc_used> changed from default %d to %d.\n",\r\nmax_txdesc_default, max_txdesc_used);\r\n}\r\nreturn 0;\r\n}\r\nSTATIC void __exit\r\ncleanup_hdlc (void)\r\n{\r\nhdw_info_t *hi;\r\nci_t *ci;\r\nstruct net_device *ndev;\r\nint i, j, k;\r\nfor (i = 0, hi = hdw_info; i < MAX_BOARDS; i++, hi++)\r\n{\r\nif (hi->ndev)\r\n{\r\nci = (ci_t *)(netdev_priv(hi->ndev));\r\nfor (j = 0; j < ci->max_port; j++)\r\nfor (k = 0; k < MUSYCC_NCHANS; k++)\r\nif ((ndev = ci->port[j].chan[k]->user))\r\n{\r\ndo_deluser (ndev, 0);\r\n}\r\n}\r\n}\r\n}\r\nSTATIC void __exit\r\nc4_mod_remove (void)\r\n{\r\ncleanup_hdlc ();\r\ncleanup_devs ();\r\nc4_cleanup ();\r\ncleanup_ioremap ();\r\npr_info("SBE - driver removed.\n");\r\n}
