static void set_vbus_draw(struct gpio_vbus_data *gpio_vbus, unsigned mA)\r\n{\r\nstruct regulator *vbus_draw = gpio_vbus->vbus_draw;\r\nint enabled;\r\nif (!vbus_draw)\r\nreturn;\r\nenabled = gpio_vbus->vbus_draw_enabled;\r\nif (mA) {\r\nregulator_set_current_limit(vbus_draw, 0, 1000 * mA);\r\nif (!enabled) {\r\nregulator_enable(vbus_draw);\r\ngpio_vbus->vbus_draw_enabled = 1;\r\n}\r\n} else {\r\nif (enabled) {\r\nregulator_disable(vbus_draw);\r\ngpio_vbus->vbus_draw_enabled = 0;\r\n}\r\n}\r\ngpio_vbus->mA = mA;\r\n}\r\nstatic int is_vbus_powered(struct gpio_vbus_mach_info *pdata)\r\n{\r\nint vbus;\r\nvbus = gpio_get_value(pdata->gpio_vbus);\r\nif (pdata->gpio_vbus_inverted)\r\nvbus = !vbus;\r\nreturn vbus;\r\n}\r\nstatic void gpio_vbus_work(struct work_struct *work)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus =\r\ncontainer_of(work, struct gpio_vbus_data, work);\r\nstruct gpio_vbus_mach_info *pdata = gpio_vbus->dev->platform_data;\r\nint gpio;\r\nif (!gpio_vbus->otg.gadget)\r\nreturn;\r\ngpio = pdata->gpio_pullup;\r\nif (is_vbus_powered(pdata)) {\r\ngpio_vbus->otg.state = OTG_STATE_B_PERIPHERAL;\r\nusb_gadget_vbus_connect(gpio_vbus->otg.gadget);\r\nset_vbus_draw(gpio_vbus, 100);\r\nif (gpio_is_valid(gpio))\r\ngpio_set_value(gpio, !pdata->gpio_pullup_inverted);\r\n} else {\r\nif (gpio_is_valid(gpio))\r\ngpio_set_value(gpio, pdata->gpio_pullup_inverted);\r\nset_vbus_draw(gpio_vbus, 0);\r\nusb_gadget_vbus_disconnect(gpio_vbus->otg.gadget);\r\ngpio_vbus->otg.state = OTG_STATE_B_IDLE;\r\n}\r\n}\r\nstatic irqreturn_t gpio_vbus_irq(int irq, void *data)\r\n{\r\nstruct platform_device *pdev = data;\r\nstruct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;\r\nstruct gpio_vbus_data *gpio_vbus = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "VBUS %s (gadget: %s)\n",\r\nis_vbus_powered(pdata) ? "supplied" : "inactive",\r\ngpio_vbus->otg.gadget ? gpio_vbus->otg.gadget->name : "none");\r\nif (gpio_vbus->otg.gadget)\r\nschedule_work(&gpio_vbus->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gpio_vbus_set_peripheral(struct otg_transceiver *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus;\r\nstruct gpio_vbus_mach_info *pdata;\r\nstruct platform_device *pdev;\r\nint gpio, irq;\r\ngpio_vbus = container_of(otg, struct gpio_vbus_data, otg);\r\npdev = to_platform_device(gpio_vbus->dev);\r\npdata = gpio_vbus->dev->platform_data;\r\nirq = gpio_to_irq(pdata->gpio_vbus);\r\ngpio = pdata->gpio_pullup;\r\nif (!gadget) {\r\ndev_dbg(&pdev->dev, "unregistering gadget '%s'\n",\r\notg->gadget->name);\r\nif (gpio_is_valid(gpio))\r\ngpio_set_value(gpio, pdata->gpio_pullup_inverted);\r\nset_vbus_draw(gpio_vbus, 0);\r\nusb_gadget_vbus_disconnect(otg->gadget);\r\notg->state = OTG_STATE_UNDEFINED;\r\notg->gadget = NULL;\r\nreturn 0;\r\n}\r\notg->gadget = gadget;\r\ndev_dbg(&pdev->dev, "registered gadget '%s'\n", gadget->name);\r\ngpio_vbus_irq(irq, pdev);\r\nreturn 0;\r\n}\r\nstatic int gpio_vbus_set_power(struct otg_transceiver *otg, unsigned mA)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus;\r\ngpio_vbus = container_of(otg, struct gpio_vbus_data, otg);\r\nif (otg->state == OTG_STATE_B_PERIPHERAL)\r\nset_vbus_draw(gpio_vbus, mA);\r\nreturn 0;\r\n}\r\nstatic int gpio_vbus_set_suspend(struct otg_transceiver *otg, int suspend)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus;\r\ngpio_vbus = container_of(otg, struct gpio_vbus_data, otg);\r\nreturn gpio_vbus_set_power(otg, suspend ? 0 : gpio_vbus->mA);\r\n}\r\nstatic int __init gpio_vbus_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;\r\nstruct gpio_vbus_data *gpio_vbus;\r\nstruct resource *res;\r\nint err, gpio, irq;\r\nif (!pdata || !gpio_is_valid(pdata->gpio_vbus))\r\nreturn -EINVAL;\r\ngpio = pdata->gpio_vbus;\r\ngpio_vbus = kzalloc(sizeof(struct gpio_vbus_data), GFP_KERNEL);\r\nif (!gpio_vbus)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, gpio_vbus);\r\ngpio_vbus->dev = &pdev->dev;\r\ngpio_vbus->otg.label = "gpio-vbus";\r\ngpio_vbus->otg.state = OTG_STATE_UNDEFINED;\r\ngpio_vbus->otg.set_peripheral = gpio_vbus_set_peripheral;\r\ngpio_vbus->otg.set_power = gpio_vbus_set_power;\r\ngpio_vbus->otg.set_suspend = gpio_vbus_set_suspend;\r\nerr = gpio_request(gpio, "vbus_detect");\r\nif (err) {\r\ndev_err(&pdev->dev, "can't request vbus gpio %d, err: %d\n",\r\ngpio, err);\r\ngoto err_gpio;\r\n}\r\ngpio_direction_input(gpio);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res) {\r\nirq = res->start;\r\nres->flags &= IRQF_TRIGGER_MASK;\r\nres->flags |= IRQF_SAMPLE_RANDOM | IRQF_SHARED;\r\n} else\r\nirq = gpio_to_irq(gpio);\r\ngpio = pdata->gpio_pullup;\r\nif (gpio_is_valid(gpio)) {\r\nerr = gpio_request(gpio, "udc_pullup");\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"can't request pullup gpio %d, err: %d\n",\r\ngpio, err);\r\ngpio_free(pdata->gpio_vbus);\r\ngoto err_gpio;\r\n}\r\ngpio_direction_output(gpio, pdata->gpio_pullup_inverted);\r\n}\r\nerr = request_irq(irq, gpio_vbus_irq, VBUS_IRQ_FLAGS,\r\n"vbus_detect", pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "can't request irq %i, err: %d\n",\r\nirq, err);\r\ngoto err_irq;\r\n}\r\nINIT_WORK(&gpio_vbus->work, gpio_vbus_work);\r\ngpio_vbus->vbus_draw = regulator_get(&pdev->dev, "vbus_draw");\r\nif (IS_ERR(gpio_vbus->vbus_draw)) {\r\ndev_dbg(&pdev->dev, "can't get vbus_draw regulator, err: %ld\n",\r\nPTR_ERR(gpio_vbus->vbus_draw));\r\ngpio_vbus->vbus_draw = NULL;\r\n}\r\nerr = otg_set_transceiver(&gpio_vbus->otg);\r\nif (err) {\r\ndev_err(&pdev->dev, "can't register transceiver, err: %d\n",\r\nerr);\r\ngoto err_otg;\r\n}\r\nreturn 0;\r\nerr_otg:\r\nfree_irq(irq, &pdev->dev);\r\nerr_irq:\r\nif (gpio_is_valid(pdata->gpio_pullup))\r\ngpio_free(pdata->gpio_pullup);\r\ngpio_free(pdata->gpio_vbus);\r\nerr_gpio:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(gpio_vbus);\r\nreturn err;\r\n}\r\nstatic int __exit gpio_vbus_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus = platform_get_drvdata(pdev);\r\nstruct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;\r\nint gpio = pdata->gpio_vbus;\r\nregulator_put(gpio_vbus->vbus_draw);\r\notg_set_transceiver(NULL);\r\nfree_irq(gpio_to_irq(gpio), &pdev->dev);\r\nif (gpio_is_valid(pdata->gpio_pullup))\r\ngpio_free(pdata->gpio_pullup);\r\ngpio_free(gpio);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(gpio_vbus);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_vbus_init(void)\r\n{\r\nreturn platform_driver_probe(&gpio_vbus_driver, gpio_vbus_probe);\r\n}\r\nstatic void __exit gpio_vbus_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_vbus_driver);\r\n}
