static int eeprom_wait_ready(struct pci_dev *pdev, u32 *status)\r\n{\r\nu32 reg;\r\nint i;\r\nfor (i = 0; i < MAX_NUM_REGISTER_POLLS; i++) {\r\nif (pci_read_config_dword(pdev, LBCIF_DWORD1_GROUP, &reg))\r\nreturn -EIO;\r\nif ((reg & 0x3000) == 0x3000) {\r\nif (status)\r\n*status = reg;\r\nreturn reg & 0xFF;\r\n}\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int eeprom_write(struct et131x_adapter *etdev, u32 addr, u8 data)\r\n{\r\nstruct pci_dev *pdev = etdev->pdev;\r\nint index = 0;\r\nint retries;\r\nint err = 0;\r\nint i2c_wack = 0;\r\nint writeok = 0;\r\nu32 status;\r\nu32 val = 0;\r\nerr = eeprom_wait_ready(pdev, NULL);\r\nif (err)\r\nreturn err;\r\nif (pci_write_config_byte(pdev, LBCIF_CONTROL_REGISTER,\r\nLBCIF_CONTROL_LBCIF_ENABLE | LBCIF_CONTROL_I2C_WRITE))\r\nreturn -EIO;\r\ni2c_wack = 1;\r\nfor (retries = 0; retries < MAX_NUM_WRITE_RETRIES; retries++) {\r\nif (pci_write_config_dword(pdev, LBCIF_ADDRESS_REGISTER, addr))\r\nbreak;\r\nif (pci_write_config_byte(pdev, LBCIF_DATA_REGISTER, data))\r\nbreak;\r\nerr = eeprom_wait_ready(pdev, &status);\r\nif (err < 0)\r\nreturn 0;\r\nif ((status & LBCIF_STATUS_GENERAL_ERROR)\r\n&& etdev->pdev->revision == 0)\r\nbreak;\r\nif (status & LBCIF_STATUS_ACK_ERROR) {\r\nudelay(10);\r\ncontinue;\r\n}\r\nwriteok = 1;\r\nbreak;\r\n}\r\nudelay(10);\r\nwhile (i2c_wack) {\r\nif (pci_write_config_byte(pdev, LBCIF_CONTROL_REGISTER,\r\nLBCIF_CONTROL_LBCIF_ENABLE))\r\nwriteok = 0;\r\ndo {\r\npci_write_config_dword(pdev,\r\nLBCIF_ADDRESS_REGISTER,\r\naddr);\r\ndo {\r\npci_read_config_dword(pdev,\r\nLBCIF_DATA_REGISTER, &val);\r\n} while ((val & 0x00010000) == 0);\r\n} while (val & 0x00040000);\r\nif ((val & 0xFF00) != 0xC000 || index == 10000)\r\nbreak;\r\nindex++;\r\n}\r\nreturn writeok ? 0 : -EIO;\r\n}\r\nstatic int eeprom_read(struct et131x_adapter *etdev, u32 addr, u8 *pdata)\r\n{\r\nstruct pci_dev *pdev = etdev->pdev;\r\nint err;\r\nu32 status;\r\nerr = eeprom_wait_ready(pdev, NULL);\r\nif (err)\r\nreturn err;\r\nif (pci_write_config_byte(pdev, LBCIF_CONTROL_REGISTER,\r\nLBCIF_CONTROL_LBCIF_ENABLE))\r\nreturn -EIO;\r\nif (pci_write_config_dword(pdev, LBCIF_ADDRESS_REGISTER, addr))\r\nreturn -EIO;\r\nerr = eeprom_wait_ready(pdev, &status);\r\nif (err < 0)\r\nreturn err;\r\n*pdata = err;\r\nreturn (status & LBCIF_STATUS_ACK_ERROR) ? -EIO : 0;\r\n}\r\nint et131x_init_eeprom(struct et131x_adapter *etdev)\r\n{\r\nstruct pci_dev *pdev = etdev->pdev;\r\nu8 eestatus;\r\npci_read_config_byte(pdev, ET1310_PCI_EEPROM_STATUS,\r\n&eestatus);\r\nif (pci_read_config_byte(pdev, ET1310_PCI_EEPROM_STATUS, &eestatus)) {\r\ndev_err(&pdev->dev,\r\n"Could not read PCI config space for EEPROM Status\n");\r\nreturn -EIO;\r\n}\r\nif (eestatus & 0x4C) {\r\nint write_failed = 0;\r\nif (pdev->revision == 0x01) {\r\nint i;\r\nstatic const u8 eedata[4] = { 0xFE, 0x13, 0x10, 0xFF };\r\nfor (i = 0; i < 3; i++)\r\nif (eeprom_write(etdev, i, eedata[i]) < 0)\r\nwrite_failed = 1;\r\n}\r\nif (pdev->revision != 0x01 || write_failed) {\r\ndev_err(&pdev->dev,\r\n"Fatal EEPROM Status Error - 0x%04x\n", eestatus);\r\netdev->has_eeprom = 0;\r\nreturn -EIO;\r\n}\r\n}\r\netdev->has_eeprom = 1;\r\neeprom_read(etdev, 0x70, &etdev->eeprom_data[0]);\r\neeprom_read(etdev, 0x71, &etdev->eeprom_data[1]);\r\nif (etdev->eeprom_data[0] != 0xcd)\r\netdev->eeprom_data[1] = 0x00;\r\nreturn 0;\r\n}
