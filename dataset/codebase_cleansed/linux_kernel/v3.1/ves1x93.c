static int ves1x93_writereg (struct ves1x93_state* state, u8 reg, u8 data)\r\n{\r\nu8 buf [] = { 0x00, reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 3 };\r\nint err;\r\nif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\r\ndprintk ("%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\n", __func__, err, reg, data);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 ves1x93_readreg (struct ves1x93_state* state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0 [] = { 0x00, reg };\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\nret = i2c_transfer (state->i2c, msg, 2);\r\nif (ret != 2) return ret;\r\nreturn b1[0];\r\n}\r\nstatic int ves1x93_clr_bit (struct ves1x93_state* state)\r\n{\r\nmsleep(10);\r\nves1x93_writereg (state, 0, state->init_1x93_tab[0] & 0xfe);\r\nves1x93_writereg (state, 0, state->init_1x93_tab[0]);\r\nmsleep(50);\r\nreturn 0;\r\n}\r\nstatic int ves1x93_set_inversion (struct ves1x93_state* state, fe_spectral_inversion_t inversion)\r\n{\r\nu8 val;\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\nval = 0xc0;\r\nbreak;\r\ncase INVERSION_ON:\r\nval = 0x80;\r\nbreak;\r\ncase INVERSION_AUTO:\r\nval = 0x00;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ves1x93_writereg (state, 0x0c, (state->init_1x93_tab[0x0c] & 0x3f) | val);\r\n}\r\nstatic int ves1x93_set_fec (struct ves1x93_state* state, fe_code_rate_t fec)\r\n{\r\nif (fec == FEC_AUTO)\r\nreturn ves1x93_writereg (state, 0x0d, 0x08);\r\nelse if (fec < FEC_1_2 || fec > FEC_8_9)\r\nreturn -EINVAL;\r\nelse\r\nreturn ves1x93_writereg (state, 0x0d, fec - FEC_1_2);\r\n}\r\nstatic fe_code_rate_t ves1x93_get_fec (struct ves1x93_state* state)\r\n{\r\nreturn FEC_1_2 + ((ves1x93_readreg (state, 0x0d) >> 4) & 0x7);\r\n}\r\nstatic int ves1x93_set_symbolrate (struct ves1x93_state* state, u32 srate)\r\n{\r\nu32 BDR;\r\nu32 ratio;\r\nu8 ADCONF, FCONF, FNR, AGCR;\r\nu32 BDRI;\r\nu32 tmp;\r\nu32 FIN;\r\ndprintk("%s: srate == %d\n", __func__, (unsigned int) srate);\r\nif (srate > state->config->xin/2)\r\nsrate = state->config->xin/2;\r\nif (srate < 500000)\r\nsrate = 500000;\r\n#define MUL (1UL<<26)\r\nFIN = (state->config->xin + 6000) >> 4;\r\ntmp = srate << 6;\r\nratio = tmp / FIN;\r\ntmp = (tmp % FIN) << 8;\r\nratio = (ratio << 8) + tmp / FIN;\r\ntmp = (tmp % FIN) << 8;\r\nratio = (ratio << 8) + tmp / FIN;\r\nFNR = 0xff;\r\nif (ratio < MUL/3) FNR = 0;\r\nif (ratio < (MUL*11)/50) FNR = 1;\r\nif (ratio < MUL/6) FNR = 2;\r\nif (ratio < MUL/9) FNR = 3;\r\nif (ratio < MUL/12) FNR = 4;\r\nif (ratio < (MUL*11)/200) FNR = 5;\r\nif (ratio < MUL/24) FNR = 6;\r\nif (ratio < (MUL*27)/1000) FNR = 7;\r\nif (ratio < MUL/48) FNR = 8;\r\nif (ratio < (MUL*137)/10000) FNR = 9;\r\nif (FNR == 0xff) {\r\nADCONF = 0x89;\r\nFCONF = 0x80;\r\nFNR = 0;\r\n} else {\r\nADCONF = 0x81;\r\nFCONF = 0x88 | (FNR >> 1) | ((FNR & 0x01) << 5);\r\n}\r\nBDR = (( (ratio << (FNR >> 1)) >> 4) + 1) >> 1;\r\nBDRI = ( ((FIN << 8) / ((srate << (FNR >> 1)) >> 2)) + 1) >> 1;\r\ndprintk("FNR= %d\n", FNR);\r\ndprintk("ratio= %08x\n", (unsigned int) ratio);\r\ndprintk("BDR= %08x\n", (unsigned int) BDR);\r\ndprintk("BDRI= %02x\n", (unsigned int) BDRI);\r\nif (BDRI > 0xff)\r\nBDRI = 0xff;\r\nves1x93_writereg (state, 0x06, 0xff & BDR);\r\nves1x93_writereg (state, 0x07, 0xff & (BDR >> 8));\r\nves1x93_writereg (state, 0x08, 0x0f & (BDR >> 16));\r\nves1x93_writereg (state, 0x09, BDRI);\r\nves1x93_writereg (state, 0x20, ADCONF);\r\nves1x93_writereg (state, 0x21, FCONF);\r\nAGCR = state->init_1x93_tab[0x05];\r\nif (state->config->invert_pwm)\r\nAGCR |= 0x20;\r\nif (srate < 6000000)\r\nAGCR |= 0x80;\r\nelse\r\nAGCR &= ~0x80;\r\nves1x93_writereg (state, 0x05, AGCR);\r\nif (state->demod_type != DEMOD_VES1993)\r\nves1x93_clr_bit (state);\r\nreturn 0;\r\n}\r\nstatic int ves1x93_init (struct dvb_frontend* fe)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nint i;\r\nint val;\r\ndprintk("%s: init chip\n", __func__);\r\nfor (i = 0; i < state->tab_size; i++) {\r\nif (state->init_1x93_wtab[i]) {\r\nval = state->init_1x93_tab[i];\r\nif (state->config->invert_pwm && (i == 0x05)) val |= 0x20;\r\nves1x93_writereg (state, i, val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ves1x93_set_voltage (struct dvb_frontend* fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\nreturn ves1x93_writereg (state, 0x1f, 0x20);\r\ncase SEC_VOLTAGE_18:\r\nreturn ves1x93_writereg (state, 0x1f, 0x30);\r\ncase SEC_VOLTAGE_OFF:\r\nreturn ves1x93_writereg (state, 0x1f, 0x00);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ves1x93_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nu8 sync = ves1x93_readreg (state, 0x0e);\r\nint maxtry = 10;\r\nwhile ((sync & 0x03) != 0x03 && (sync & 0x0c) && maxtry--) {\r\nmsleep(10);\r\nsync = ves1x93_readreg (state, 0x0e);\r\n}\r\n*status = 0;\r\nif (sync & 1)\r\n*status |= FE_HAS_SIGNAL;\r\nif (sync & 2)\r\n*status |= FE_HAS_CARRIER;\r\nif (sync & 4)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 8)\r\n*status |= FE_HAS_SYNC;\r\nif ((sync & 0x1f) == 0x1f)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int ves1x93_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\n*ber = ves1x93_readreg (state, 0x15);\r\n*ber |= (ves1x93_readreg (state, 0x16) << 8);\r\n*ber |= ((ves1x93_readreg (state, 0x17) & 0x0F) << 16);\r\n*ber *= 10;\r\nreturn 0;\r\n}\r\nstatic int ves1x93_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nu8 signal = ~ves1x93_readreg (state, 0x0b);\r\n*strength = (signal << 8) | signal;\r\nreturn 0;\r\n}\r\nstatic int ves1x93_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nu8 _snr = ~ves1x93_readreg (state, 0x1c);\r\n*snr = (_snr << 8) | _snr;\r\nreturn 0;\r\n}\r\nstatic int ves1x93_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\n*ucblocks = ves1x93_readreg (state, 0x18) & 0x7f;\r\nif (*ucblocks == 0x7f)\r\n*ucblocks = 0xffffffff;\r\nves1x93_writereg (state, 0x18, 0x00);\r\nves1x93_writereg (state, 0x18, 0x80);\r\nreturn 0;\r\n}\r\nstatic int ves1x93_set_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe, p);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nves1x93_set_inversion (state, p->inversion);\r\nves1x93_set_fec (state, p->u.qpsk.fec_inner);\r\nves1x93_set_symbolrate (state, p->u.qpsk.symbol_rate);\r\nstate->inversion = p->inversion;\r\nreturn 0;\r\n}\r\nstatic int ves1x93_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nint afc;\r\nafc = ((int)((char)(ves1x93_readreg (state, 0x0a) << 1)))/2;\r\nafc = (afc * (int)(p->u.qpsk.symbol_rate/1000/8))/16;\r\np->frequency -= afc;\r\nif (state->inversion == INVERSION_AUTO)\r\np->inversion = (ves1x93_readreg (state, 0x0f) & 2) ?\r\nINVERSION_OFF : INVERSION_ON;\r\np->u.qpsk.fec_inner = ves1x93_get_fec (state);\r\nreturn 0;\r\n}\r\nstatic int ves1x93_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nreturn ves1x93_writereg (state, 0x00, 0x08);\r\n}\r\nstatic void ves1x93_release(struct dvb_frontend* fe)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstatic int ves1x93_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct ves1x93_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nreturn ves1x93_writereg(state, 0x00, 0x11);\r\n} else {\r\nreturn ves1x93_writereg(state, 0x00, 0x01);\r\n}\r\n}\r\nstruct dvb_frontend* ves1x93_attach(const struct ves1x93_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct ves1x93_state* state = NULL;\r\nu8 identity;\r\nstate = kzalloc(sizeof(struct ves1x93_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->inversion = INVERSION_OFF;\r\nidentity = ves1x93_readreg(state, 0x1e);\r\nswitch (identity) {\r\ncase 0xdc:\r\nprintk("ves1x93: Detected ves1893a rev1\n");\r\nstate->demod_type = DEMOD_VES1893;\r\nstate->init_1x93_tab = init_1893_tab;\r\nstate->init_1x93_wtab = init_1893_wtab;\r\nstate->tab_size = sizeof(init_1893_tab);\r\nbreak;\r\ncase 0xdd:\r\nprintk("ves1x93: Detected ves1893a rev2\n");\r\nstate->demod_type = DEMOD_VES1893;\r\nstate->init_1x93_tab = init_1893_tab;\r\nstate->init_1x93_wtab = init_1893_wtab;\r\nstate->tab_size = sizeof(init_1893_tab);\r\nbreak;\r\ncase 0xde:\r\nprintk("ves1x93: Detected ves1993\n");\r\nstate->demod_type = DEMOD_VES1993;\r\nstate->init_1x93_tab = init_1993_tab;\r\nstate->init_1x93_wtab = init_1993_wtab;\r\nstate->tab_size = sizeof(init_1993_tab);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nmemcpy(&state->frontend.ops, &ves1x93_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
