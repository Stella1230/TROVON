static inline __u32 iov_crc32( __u32 c, struct kvec *iov, unsigned int cnt )\r\n{\r\nunsigned int j;\r\nfor (j = 0; j < cnt; j++)\r\nc = crc32_be( c, iov[j].iov_base, iov[j].iov_len );\r\nreturn c;\r\n}\r\nstatic void hexdump( const unsigned char *buf, unsigned short len )\r\n{\r\nchar str[80], octet[10];\r\nint ofs, i, l;\r\nfor (ofs = 0; ofs < len; ofs += 16) {\r\nsprintf( str, "%03d: ", ofs );\r\nfor (i = 0; i < 16; i++) {\r\nif ((i + ofs) < len)\r\nsprintf( octet, "%02x ", buf[ofs + i] );\r\nelse\r\nstrcpy( octet, " " );\r\nstrcat( str, octet );\r\n}\r\nstrcat( str, " " );\r\nl = strlen( str );\r\nfor (i = 0; (i < 16) && ((i + ofs) < len); i++)\r\nstr[l++] = isprint( buf[ofs + i] ) ? buf[ofs + i] : '.';\r\nstr[l] = '\0';\r\nprintk( KERN_WARNING "%s\n", str );\r\n}\r\n}\r\nstatic __be16 dvb_net_eth_type_trans(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ethhdr *eth;\r\nunsigned char *rawp;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb,dev->hard_header_len);\r\neth = eth_hdr(skb);\r\nif (*eth->h_dest & 1) {\r\nif(memcmp(eth->h_dest,dev->broadcast, ETH_ALEN)==0)\r\nskb->pkt_type=PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type=PACKET_MULTICAST;\r\n}\r\nif (ntohs(eth->h_proto) >= 1536)\r\nreturn eth->h_proto;\r\nrawp = skb->data;\r\nif (*(unsigned short *)rawp == 0xFFFF)\r\nreturn htons(ETH_P_802_3);\r\nreturn htons(ETH_P_802_2);\r\n}\r\nstatic int ule_test_sndu( struct dvb_net_priv *p )\r\n{\r\nreturn -1;\r\n}\r\nstatic int ule_bridged_sndu( struct dvb_net_priv *p )\r\n{\r\nstruct ethhdr *hdr = (struct ethhdr*) p->ule_next_hdr;\r\nif(ntohs(hdr->h_proto) < 1536) {\r\nint framelen = p->ule_sndu_len - ((p->ule_next_hdr+sizeof(struct ethhdr)) - p->ule_skb->data);\r\nif(framelen != ntohs(hdr->h_proto)) {\r\nreturn -1;\r\n}\r\n}\r\np->ule_bridged = 1;\r\nreturn 0;\r\n}\r\nstatic int ule_exthdr_padding(struct dvb_net_priv *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic int handle_one_ule_extension( struct dvb_net_priv *p )\r\n{\r\nstatic int (*ule_mandatory_ext_handlers[255])( struct dvb_net_priv *p ) =\r\n{ [0] = ule_test_sndu, [1] = ule_bridged_sndu, [2] = NULL, }\r\nint handle_ule_extensions( struct dvb_net_priv *p )\r\n{\r\nint total_ext_len = 0, l;\r\np->ule_next_hdr = p->ule_skb->data;\r\ndo {\r\nl = handle_one_ule_extension( p );\r\nif (l < 0)\r\nreturn l;\r\ntotal_ext_len += l;\r\n#ifdef ULE_DEBUG\r\ndprintk("handle_ule_extensions: ule_next_hdr=%p, ule_sndu_type=%i, "\r\n"l=%i, total_ext_len=%i\n", p->ule_next_hdr,\r\n(int) p->ule_sndu_type, l, total_ext_len);\r\n#endif\r\n} while (p->ule_sndu_type < 1536);\r\nreturn total_ext_len;\r\n}\r\nstatic inline void reset_ule( struct dvb_net_priv *p )\r\n{\r\np->ule_skb = NULL;\r\np->ule_next_hdr = NULL;\r\np->ule_sndu_len = 0;\r\np->ule_sndu_type = 0;\r\np->ule_sndu_type_1 = 0;\r\np->ule_sndu_remain = 0;\r\np->ule_dbit = 0xFF;\r\np->ule_bridged = 0;\r\n}\r\nstatic void dvb_net_ule( struct net_device *dev, const u8 *buf, size_t buf_len )\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nunsigned long skipped = 0L;\r\nconst u8 *ts, *ts_end, *from_where = NULL;\r\nu8 ts_remain = 0, how_much = 0, new_ts = 1;\r\nstruct ethhdr *ethh = NULL;\r\nbool error = false;\r\n#ifdef ULE_DEBUG\r\nstatic unsigned char ule_hist[100*TS_SZ];\r\nstatic unsigned char *ule_where = ule_hist, ule_dump;\r\n#endif\r\nfor (ts = buf, ts_end = buf + buf_len; ts < ts_end; ) {\r\nif (new_ts) {\r\n#ifdef ULE_DEBUG\r\nif (ule_where >= &ule_hist[100*TS_SZ]) ule_where = ule_hist;\r\nmemcpy( ule_where, ts, TS_SZ );\r\nif (ule_dump) {\r\nhexdump( ule_where, TS_SZ );\r\nule_dump = 0;\r\n}\r\nule_where += TS_SZ;\r\n#endif\r\nif ((ts[0] != TS_SYNC) || (ts[1] & TS_TEI) || ((ts[3] & TS_SC) != 0)) {\r\nprintk(KERN_WARNING "%lu: Invalid TS cell: SYNC %#x, TEI %u, SC %#x.\n",\r\npriv->ts_count, ts[0], ts[1] & TS_TEI >> 7, ts[3] & 0xC0 >> 6);\r\nif (priv->ule_skb) {\r\ndev_kfree_skb( priv->ule_skb );\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_frame_errors++;\r\n}\r\nreset_ule(priv);\r\npriv->need_pusi = 1;\r\nts += TS_SZ;\r\npriv->ts_count++;\r\ncontinue;\r\n}\r\nts_remain = 184;\r\nfrom_where = ts + 4;\r\n}\r\nif (priv->need_pusi) {\r\nif (ts[1] & TS_PUSI) {\r\npriv->tscc = ts[3] & 0x0F;\r\nif (ts[4] > ts_remain) {\r\nprintk(KERN_ERR "%lu: Invalid ULE packet "\r\n"(pointer field %d)\n", priv->ts_count, ts[4]);\r\nts += TS_SZ;\r\npriv->ts_count++;\r\ncontinue;\r\n}\r\nfrom_where = &ts[5] + ts[4];\r\nts_remain -= 1 + ts[4];\r\nskipped = 0;\r\n} else {\r\nskipped++;\r\nts += TS_SZ;\r\npriv->ts_count++;\r\ncontinue;\r\n}\r\n}\r\nif (new_ts) {\r\nif ((ts[3] & 0x0F) == priv->tscc)\r\npriv->tscc = (priv->tscc + 1) & 0x0F;\r\nelse {\r\nprintk(KERN_WARNING "%lu: TS discontinuity: got %#x, "\r\n"expected %#x.\n", priv->ts_count, ts[3] & 0x0F, priv->tscc);\r\nif (priv->ule_skb) {\r\ndev_kfree_skb( priv->ule_skb );\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_frame_errors++;\r\n}\r\nreset_ule(priv);\r\npriv->need_pusi = 1;\r\ncontinue;\r\n}\r\nif (ts[1] & TS_PUSI) {\r\nif (! priv->need_pusi) {\r\nif (!(*from_where < (ts_remain-1)) || *from_where != priv->ule_sndu_remain) {\r\nprintk(KERN_WARNING "%lu: Invalid pointer "\r\n"field: %u.\n", priv->ts_count, *from_where);\r\nif (priv->ule_skb) {\r\nerror = true;\r\ndev_kfree_skb(priv->ule_skb);\r\n}\r\nif (error || priv->ule_sndu_remain) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_frame_errors++;\r\nerror = false;\r\n}\r\nreset_ule(priv);\r\npriv->need_pusi = 1;\r\ncontinue;\r\n}\r\nfrom_where += 1;\r\nts_remain -= 1;\r\n} else\r\npriv->need_pusi = 0;\r\nif (priv->ule_sndu_remain > 183) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\nprintk(KERN_WARNING "%lu: Expected %d more SNDU bytes, but "\r\n"got PUSI (pf %d, ts_remain %d). Flushing incomplete payload.\n",\r\npriv->ts_count, priv->ule_sndu_remain, ts[4], ts_remain);\r\ndev_kfree_skb(priv->ule_skb);\r\nreset_ule(priv);\r\nfrom_where += ts[4];\r\nts_remain -= ts[4];\r\n}\r\n}\r\n}\r\nif (priv->ule_skb == NULL) {\r\nif (ts_remain < 2) {\r\nprintk(KERN_WARNING "Invalid payload packing: only %d "\r\n"bytes left in TS. Resyncing.\n", ts_remain);\r\npriv->ule_sndu_len = 0;\r\npriv->need_pusi = 1;\r\nts += TS_SZ;\r\ncontinue;\r\n}\r\nif (! priv->ule_sndu_len) {\r\npriv->ule_sndu_len = from_where[0] << 8 | from_where[1];\r\nif (priv->ule_sndu_len & 0x8000) {\r\npriv->ule_sndu_len &= 0x7FFF;\r\npriv->ule_dbit = 1;\r\n} else\r\npriv->ule_dbit = 0;\r\nif (priv->ule_sndu_len < 5) {\r\nprintk(KERN_WARNING "%lu: Invalid ULE SNDU length %u. "\r\n"Resyncing.\n", priv->ts_count, priv->ule_sndu_len);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\npriv->ule_sndu_len = 0;\r\npriv->need_pusi = 1;\r\nnew_ts = 1;\r\nts += TS_SZ;\r\npriv->ts_count++;\r\ncontinue;\r\n}\r\nts_remain -= 2;\r\nfrom_where += 2;\r\n}\r\npriv->ule_sndu_remain = priv->ule_sndu_len + 2;\r\nswitch (ts_remain) {\r\ncase 1:\r\npriv->ule_sndu_remain--;\r\npriv->ule_sndu_type = from_where[0] << 8;\r\npriv->ule_sndu_type_1 = 1;\r\nts_remain -= 1; from_where += 1;\r\ncase 0:\r\nnew_ts = 1;\r\nts += TS_SZ;\r\npriv->ts_count++;\r\ncontinue;\r\ndefault:\r\nif (priv->ule_sndu_type_1) {\r\npriv->ule_sndu_type_1 = 0;\r\npriv->ule_sndu_type |= from_where[0];\r\nfrom_where += 1;\r\nts_remain -= 1;\r\n} else {\r\npriv->ule_sndu_type = from_where[0] << 8 | from_where[1];\r\nfrom_where += 2;\r\nts_remain -= 2;\r\n}\r\nbreak;\r\n}\r\npriv->ule_skb = dev_alloc_skb( priv->ule_sndu_len + ETH_HLEN + ETH_ALEN );\r\nif (priv->ule_skb == NULL) {\r\nprintk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n",\r\ndev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\npriv->ule_sndu_remain = priv->ule_sndu_len;\r\npriv->ule_skb->dev = dev;\r\nskb_reserve( priv->ule_skb, ETH_HLEN + ETH_ALEN );\r\n}\r\nhow_much = min(priv->ule_sndu_remain, (int)ts_remain);\r\nmemcpy(skb_put(priv->ule_skb, how_much), from_where, how_much);\r\npriv->ule_sndu_remain -= how_much;\r\nts_remain -= how_much;\r\nfrom_where += how_much;\r\nif (priv->ule_sndu_remain <= 0) {\r\n__be16 ulen = htons(priv->ule_sndu_len);\r\n__be16 utype = htons(priv->ule_sndu_type);\r\nconst u8 *tail;\r\nstruct kvec iov[3] = {\r\n{ &ulen, sizeof ulen },\r\n{ &utype, sizeof utype },\r\n{ priv->ule_skb->data, priv->ule_skb->len - 4 }\r\n};\r\nu32 ule_crc = ~0L, expected_crc;\r\nif (priv->ule_dbit) {\r\nulen |= htons(0x8000);\r\n}\r\nule_crc = iov_crc32(ule_crc, iov, 3);\r\ntail = skb_tail_pointer(priv->ule_skb);\r\nexpected_crc = *(tail - 4) << 24 |\r\n*(tail - 3) << 16 |\r\n*(tail - 2) << 8 |\r\n*(tail - 1);\r\nif (ule_crc != expected_crc) {\r\nprintk(KERN_WARNING "%lu: CRC32 check FAILED: %08x / %08x, SNDU len %d type %#x, ts_remain %d, next 2: %x.\n",\r\npriv->ts_count, ule_crc, expected_crc, priv->ule_sndu_len, priv->ule_sndu_type, ts_remain, ts_remain > 2 ? *(unsigned short *)from_where : 0);\r\n#ifdef ULE_DEBUG\r\nhexdump( iov[0].iov_base, iov[0].iov_len );\r\nhexdump( iov[1].iov_base, iov[1].iov_len );\r\nhexdump( iov[2].iov_base, iov[2].iov_len );\r\nif (ule_where == ule_hist) {\r\nhexdump( &ule_hist[98*TS_SZ], TS_SZ );\r\nhexdump( &ule_hist[99*TS_SZ], TS_SZ );\r\n} else if (ule_where == &ule_hist[TS_SZ]) {\r\nhexdump( &ule_hist[99*TS_SZ], TS_SZ );\r\nhexdump( ule_hist, TS_SZ );\r\n} else {\r\nhexdump( ule_where - TS_SZ - TS_SZ, TS_SZ );\r\nhexdump( ule_where - TS_SZ, TS_SZ );\r\n}\r\nule_dump = 1;\r\n#endif\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_crc_errors++;\r\ndev_kfree_skb(priv->ule_skb);\r\n} else {\r\nu8 dest_addr[ETH_ALEN];\r\nstatic const u8 bc_addr[ETH_ALEN] =\r\n{ [ 0 ... ETH_ALEN-1] = 0xff };\r\npriv->ule_skb->tail -= 4;\r\npriv->ule_skb->len -= 4;\r\nif (!priv->ule_dbit) {\r\nregister int drop = 0;\r\nif (priv->rx_mode != RX_MODE_PROMISC) {\r\nif (priv->ule_skb->data[0] & 0x01) {\r\nif (memcmp(priv->ule_skb->data, bc_addr, ETH_ALEN)) {\r\nif (priv->rx_mode == RX_MODE_MULTI) {\r\nint i;\r\nfor(i = 0; i < priv->multi_num && memcmp(priv->ule_skb->data, priv->multi_macs[i], ETH_ALEN); i++)\r\n;\r\nif (i == priv->multi_num)\r\ndrop = 1;\r\n} else if (priv->rx_mode != RX_MODE_ALL_MULTI)\r\ndrop = 1;\r\n}\r\n}\r\nelse if (memcmp(priv->ule_skb->data, dev->dev_addr, ETH_ALEN))\r\ndrop = 1;\r\n}\r\nif (drop) {\r\n#ifdef ULE_DEBUG\r\ndprintk("Dropping SNDU: MAC destination address does not match: dest addr: "MAC_ADDR_PRINTFMT", dev addr: "MAC_ADDR_PRINTFMT"\n",\r\nMAX_ADDR_PRINTFMT_ARGS(priv->ule_skb->data), MAX_ADDR_PRINTFMT_ARGS(dev->dev_addr));\r\n#endif\r\ndev_kfree_skb(priv->ule_skb);\r\ngoto sndu_done;\r\n}\r\nelse\r\n{\r\nskb_copy_from_linear_data(priv->ule_skb,\r\ndest_addr,\r\nETH_ALEN);\r\nskb_pull(priv->ule_skb, ETH_ALEN);\r\n}\r\n}\r\nif (priv->ule_sndu_type < 1536) {\r\nint l = handle_ule_extensions(priv);\r\nif (l < 0) {\r\ndev_kfree_skb(priv->ule_skb);\r\ngoto sndu_done;\r\n}\r\nskb_pull(priv->ule_skb, l);\r\n}\r\nif (!priv->ule_bridged) {\r\nskb_push(priv->ule_skb, ETH_HLEN);\r\nethh = (struct ethhdr *)priv->ule_skb->data;\r\nif (!priv->ule_dbit) {\r\nmemcpy(ethh->h_dest, dest_addr, ETH_ALEN);\r\nmemset(ethh->h_source, 0, ETH_ALEN);\r\n}\r\nelse\r\nmemset( ethh, 0, ETH_ALEN*2 );\r\nethh->h_proto = htons(priv->ule_sndu_type);\r\n}\r\npriv->ule_bridged = 0;\r\npriv->ule_skb->protocol = dvb_net_eth_type_trans(priv->ule_skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += priv->ule_skb->len;\r\nnetif_rx(priv->ule_skb);\r\n}\r\nsndu_done:\r\nreset_ule(priv);\r\n}\r\nif (ts_remain >= 2 && *((unsigned short *)from_where) != 0xFFFF) {\r\nnew_ts = 0;\r\npriv->ule_skb = NULL;\r\npriv->ule_sndu_type_1 = 0;\r\npriv->ule_sndu_len = 0;\r\n} else {\r\nnew_ts = 1;\r\nts += TS_SZ;\r\npriv->ts_count++;\r\nif (priv->ule_skb == NULL) {\r\npriv->need_pusi = 1;\r\npriv->ule_sndu_type_1 = 0;\r\npriv->ule_sndu_len = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic int dvb_net_ts_callback(const u8 *buffer1, size_t buffer1_len,\r\nconst u8 *buffer2, size_t buffer2_len,\r\nstruct dmx_ts_feed *feed, enum dmx_success success)\r\n{\r\nstruct net_device *dev = feed->priv;\r\nif (buffer2)\r\nprintk(KERN_WARNING "buffer2 not NULL: %p.\n", buffer2);\r\nif (buffer1_len > 32768)\r\nprintk(KERN_WARNING "length > 32k: %zu.\n", buffer1_len);\r\ndvb_net_ule(dev, buffer1, buffer1_len);\r\nreturn 0;\r\n}\r\nstatic void dvb_net_sec(struct net_device *dev,\r\nconst u8 *pkt, int pkt_len)\r\n{\r\nu8 *eth;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats = &dev->stats;\r\nint snap = 0;\r\nif (pkt_len < 16) {\r\nprintk("%s: IP/MPE packet length = %d too small.\n",\r\ndev->name, pkt_len);\r\nstats->rx_errors++;\r\nstats->rx_length_errors++;\r\nreturn;\r\n}\r\n#if 0\r\nif ((pkt[5] & 0xfd) != 0xc1) {\r\n#else\r\nif ((pkt[5] & 0x3c) != 0x00) {\r\n#endif\r\nstats->rx_errors++;\r\nstats->rx_crc_errors++;\r\nreturn;\r\n}\r\nif (pkt[5] & 0x02) {\r\nif (pkt_len < 24 || memcmp(&pkt[12], "\xaa\xaa\x03\0\0\0", 6)) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nsnap = 8;\r\n}\r\nif (pkt[7]) {\r\nstats->rx_errors++;\r\nstats->rx_frame_errors++;\r\nreturn;\r\n}\r\nif (!(skb = dev_alloc_skb(pkt_len - 4 - 12 + 14 + 2 - snap))) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nskb->dev = dev;\r\neth = (u8 *) skb_put(skb, pkt_len - 12 - 4 + 14 - snap);\r\nmemcpy(eth + 14, pkt + 12 + snap, pkt_len - 12 - 4 - snap);\r\neth[0]=pkt[0x0b];\r\neth[1]=pkt[0x0a];\r\neth[2]=pkt[0x09];\r\neth[3]=pkt[0x08];\r\neth[4]=pkt[0x04];\r\neth[5]=pkt[0x03];\r\neth[6]=eth[7]=eth[8]=eth[9]=eth[10]=eth[11]=0;\r\nif (snap) {\r\neth[12] = pkt[18];\r\neth[13] = pkt[19];\r\n} else {\r\nif (pkt[12] >> 4 == 6) {\r\neth[12] = 0x86;\r\neth[13] = 0xdd;\r\n} else {\r\neth[12] = 0x08;\r\neth[13] = 0x00;\r\n}\r\n}\r\nskb->protocol = dvb_net_eth_type_trans(skb, dev);\r\nstats->rx_packets++;\r\nstats->rx_bytes+=skb->len;\r\nnetif_rx(skb);\r\n}\r\nstatic int dvb_net_sec_callback(const u8 *buffer1, size_t buffer1_len,\r\nconst u8 *buffer2, size_t buffer2_len,\r\nstruct dmx_section_filter *filter,\r\nenum dmx_success success)\r\n{\r\nstruct net_device *dev = filter->priv;\r\ndvb_net_sec (dev, buffer1, buffer1_len);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int dvb_net_filter_sec_set(struct net_device *dev,\r\nstruct dmx_section_filter **secfilter,\r\nu8 *mac, u8 *mac_mask)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nint ret;\r\n*secfilter=NULL;\r\nret = priv->secfeed->allocate_filter(priv->secfeed, secfilter);\r\nif (ret<0) {\r\nprintk("%s: could not get filter\n", dev->name);\r\nreturn ret;\r\n}\r\n(*secfilter)->priv=(void *) dev;\r\nmemset((*secfilter)->filter_value, 0x00, DMX_MAX_FILTER_SIZE);\r\nmemset((*secfilter)->filter_mask, 0x00, DMX_MAX_FILTER_SIZE);\r\nmemset((*secfilter)->filter_mode, 0xff, DMX_MAX_FILTER_SIZE);\r\n(*secfilter)->filter_value[0]=0x3e;\r\n(*secfilter)->filter_value[3]=mac[5];\r\n(*secfilter)->filter_value[4]=mac[4];\r\n(*secfilter)->filter_value[8]=mac[3];\r\n(*secfilter)->filter_value[9]=mac[2];\r\n(*secfilter)->filter_value[10]=mac[1];\r\n(*secfilter)->filter_value[11]=mac[0];\r\n(*secfilter)->filter_mask[0] = 0xff;\r\n(*secfilter)->filter_mask[3] = mac_mask[5];\r\n(*secfilter)->filter_mask[4] = mac_mask[4];\r\n(*secfilter)->filter_mask[8] = mac_mask[3];\r\n(*secfilter)->filter_mask[9] = mac_mask[2];\r\n(*secfilter)->filter_mask[10] = mac_mask[1];\r\n(*secfilter)->filter_mask[11]=mac_mask[0];\r\ndprintk("%s: filter mac=%pM\n", dev->name, mac);\r\ndprintk("%s: filter mask=%pM\n", dev->name, mac_mask);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_feed_start(struct net_device *dev)\r\n{\r\nint ret = 0, i;\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nstruct dmx_demux *demux = priv->demux;\r\nunsigned char *mac = (unsigned char *) dev->dev_addr;\r\ndprintk("%s: rx_mode %i\n", __func__, priv->rx_mode);\r\nmutex_lock(&priv->mutex);\r\nif (priv->tsfeed || priv->secfeed || priv->secfilter || priv->multi_secfilter[0])\r\nprintk("%s: BUG %d\n", __func__, __LINE__);\r\npriv->secfeed=NULL;\r\npriv->secfilter=NULL;\r\npriv->tsfeed = NULL;\r\nif (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {\r\ndprintk("%s: alloc secfeed\n", __func__);\r\nret=demux->allocate_section_feed(demux, &priv->secfeed,\r\ndvb_net_sec_callback);\r\nif (ret<0) {\r\nprintk("%s: could not allocate section feed\n", dev->name);\r\ngoto error;\r\n}\r\nret = priv->secfeed->set(priv->secfeed, priv->pid, 32768, 1);\r\nif (ret<0) {\r\nprintk("%s: could not set section feed\n", dev->name);\r\npriv->demux->release_section_feed(priv->demux, priv->secfeed);\r\npriv->secfeed=NULL;\r\ngoto error;\r\n}\r\nif (priv->rx_mode != RX_MODE_PROMISC) {\r\ndprintk("%s: set secfilter\n", __func__);\r\ndvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_normal);\r\n}\r\nswitch (priv->rx_mode) {\r\ncase RX_MODE_MULTI:\r\nfor (i = 0; i < priv->multi_num; i++) {\r\ndprintk("%s: set multi_secfilter[%d]\n", __func__, i);\r\ndvb_net_filter_sec_set(dev, &priv->multi_secfilter[i],\r\npriv->multi_macs[i], mask_normal);\r\n}\r\nbreak;\r\ncase RX_MODE_ALL_MULTI:\r\npriv->multi_num=1;\r\ndprintk("%s: set multi_secfilter[0]\n", __func__);\r\ndvb_net_filter_sec_set(dev, &priv->multi_secfilter[0],\r\nmac_allmulti, mask_allmulti);\r\nbreak;\r\ncase RX_MODE_PROMISC:\r\npriv->multi_num=0;\r\ndprintk("%s: set secfilter\n", __func__);\r\ndvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_promisc);\r\nbreak;\r\n}\r\ndprintk("%s: start filtering\n", __func__);\r\npriv->secfeed->start_filtering(priv->secfeed);\r\n} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {\r\nstruct timespec timeout = { 0, 10000000 };\r\ndprintk("%s: alloc tsfeed\n", __func__);\r\nret = demux->allocate_ts_feed(demux, &priv->tsfeed, dvb_net_ts_callback);\r\nif (ret < 0) {\r\nprintk("%s: could not allocate ts feed\n", dev->name);\r\ngoto error;\r\n}\r\npriv->tsfeed->priv = (void *)dev;\r\nret = priv->tsfeed->set(priv->tsfeed,\r\npriv->pid,\r\nTS_PACKET,\r\nDMX_TS_PES_OTHER,\r\n32768,\r\ntimeout\r\n);\r\nif (ret < 0) {\r\nprintk("%s: could not set ts feed\n", dev->name);\r\npriv->demux->release_ts_feed(priv->demux, priv->tsfeed);\r\npriv->tsfeed = NULL;\r\ngoto error;\r\n}\r\ndprintk("%s: start filtering\n", __func__);\r\npriv->tsfeed->start_filtering(priv->tsfeed);\r\n} else\r\nret = -EINVAL;\r\nerror:\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int dvb_net_feed_stop(struct net_device *dev)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nint i, ret = 0;\r\ndprintk("%s\n", __func__);\r\nmutex_lock(&priv->mutex);\r\nif (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {\r\nif (priv->secfeed) {\r\nif (priv->secfeed->is_filtering) {\r\ndprintk("%s: stop secfeed\n", __func__);\r\npriv->secfeed->stop_filtering(priv->secfeed);\r\n}\r\nif (priv->secfilter) {\r\ndprintk("%s: release secfilter\n", __func__);\r\npriv->secfeed->release_filter(priv->secfeed,\r\npriv->secfilter);\r\npriv->secfilter=NULL;\r\n}\r\nfor (i=0; i<priv->multi_num; i++) {\r\nif (priv->multi_secfilter[i]) {\r\ndprintk("%s: release multi_filter[%d]\n",\r\n__func__, i);\r\npriv->secfeed->release_filter(priv->secfeed,\r\npriv->multi_secfilter[i]);\r\npriv->multi_secfilter[i] = NULL;\r\n}\r\n}\r\npriv->demux->release_section_feed(priv->demux, priv->secfeed);\r\npriv->secfeed = NULL;\r\n} else\r\nprintk("%s: no feed to stop\n", dev->name);\r\n} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {\r\nif (priv->tsfeed) {\r\nif (priv->tsfeed->is_filtering) {\r\ndprintk("%s: stop tsfeed\n", __func__);\r\npriv->tsfeed->stop_filtering(priv->tsfeed);\r\n}\r\npriv->demux->release_ts_feed(priv->demux, priv->tsfeed);\r\npriv->tsfeed = NULL;\r\n}\r\nelse\r\nprintk("%s: no ts feed to stop\n", dev->name);\r\n} else\r\nret = -EINVAL;\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int dvb_set_mc_filter(struct net_device *dev, unsigned char *addr)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nif (priv->multi_num == DVB_NET_MULTICAST_MAX)\r\nreturn -ENOMEM;\r\nmemcpy(priv->multi_macs[priv->multi_num], addr, ETH_ALEN);\r\npriv->multi_num++;\r\nreturn 0;\r\n}\r\nstatic void wq_set_multicast_list (struct work_struct *work)\r\n{\r\nstruct dvb_net_priv *priv =\r\ncontainer_of(work, struct dvb_net_priv, set_multicast_list_wq);\r\nstruct net_device *dev = priv->net;\r\ndvb_net_feed_stop(dev);\r\npriv->rx_mode = RX_MODE_UNI;\r\nnetif_addr_lock_bh(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\ndprintk("%s: promiscuous mode\n", dev->name);\r\npriv->rx_mode = RX_MODE_PROMISC;\r\n} else if ((dev->flags & IFF_ALLMULTI)) {\r\ndprintk("%s: allmulti mode\n", dev->name);\r\npriv->rx_mode = RX_MODE_ALL_MULTI;\r\n} else if (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\ndprintk("%s: set_mc_list, %d entries\n",\r\ndev->name, netdev_mc_count(dev));\r\npriv->rx_mode = RX_MODE_MULTI;\r\npriv->multi_num = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\ndvb_set_mc_filter(dev, ha->addr);\r\n}\r\nnetif_addr_unlock_bh(dev);\r\ndvb_net_feed_start(dev);\r\n}\r\nstatic void dvb_net_set_multicast_list (struct net_device *dev)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nschedule_work(&priv->set_multicast_list_wq);\r\n}\r\nstatic void wq_restart_net_feed (struct work_struct *work)\r\n{\r\nstruct dvb_net_priv *priv =\r\ncontainer_of(work, struct dvb_net_priv, restart_net_feed_wq);\r\nstruct net_device *dev = priv->net;\r\nif (netif_running(dev)) {\r\ndvb_net_feed_stop(dev);\r\ndvb_net_feed_start(dev);\r\n}\r\n}\r\nstatic int dvb_net_set_mac (struct net_device *dev, void *p)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nstruct sockaddr *addr=p;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nif (netif_running(dev))\r\nschedule_work(&priv->restart_net_feed_wq);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_open(struct net_device *dev)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\npriv->in_use++;\r\ndvb_net_feed_start(dev);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_stop(struct net_device *dev)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\npriv->in_use--;\r\nreturn dvb_net_feed_stop(dev);\r\n}\r\nstatic void dvb_net_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->header_ops = &dvb_header_ops;\r\ndev->netdev_ops = &dvb_netdev_ops;\r\ndev->mtu = 4096;\r\ndev->flags |= IFF_NOARP;\r\n}\r\nstatic int get_if(struct dvb_net *dvbnet)\r\n{\r\nint i;\r\nfor (i=0; i<DVB_NET_DEVICES_MAX; i++)\r\nif (!dvbnet->state[i])\r\nbreak;\r\nif (i == DVB_NET_DEVICES_MAX)\r\nreturn -1;\r\ndvbnet->state[i]=1;\r\nreturn i;\r\n}\r\nstatic int dvb_net_add_if(struct dvb_net *dvbnet, u16 pid, u8 feedtype)\r\n{\r\nstruct net_device *net;\r\nstruct dvb_net_priv *priv;\r\nint result;\r\nint if_num;\r\nif (feedtype != DVB_NET_FEEDTYPE_MPE && feedtype != DVB_NET_FEEDTYPE_ULE)\r\nreturn -EINVAL;\r\nif ((if_num = get_if(dvbnet)) < 0)\r\nreturn -EINVAL;\r\nnet = alloc_netdev(sizeof(struct dvb_net_priv), "dvb", dvb_net_setup);\r\nif (!net)\r\nreturn -ENOMEM;\r\nif (dvbnet->dvbdev->id)\r\nsnprintf(net->name, IFNAMSIZ, "dvb%d%u%d",\r\ndvbnet->dvbdev->adapter->num, dvbnet->dvbdev->id, if_num);\r\nelse\r\nsnprintf(net->name, IFNAMSIZ, "dvb%d_%d",\r\ndvbnet->dvbdev->adapter->num, if_num);\r\nnet->addr_len = 6;\r\nmemcpy(net->dev_addr, dvbnet->dvbdev->adapter->proposed_mac, 6);\r\ndvbnet->device[if_num] = net;\r\npriv = netdev_priv(net);\r\npriv->net = net;\r\npriv->demux = dvbnet->demux;\r\npriv->pid = pid;\r\npriv->rx_mode = RX_MODE_UNI;\r\npriv->need_pusi = 1;\r\npriv->tscc = 0;\r\npriv->feedtype = feedtype;\r\nreset_ule(priv);\r\nINIT_WORK(&priv->set_multicast_list_wq, wq_set_multicast_list);\r\nINIT_WORK(&priv->restart_net_feed_wq, wq_restart_net_feed);\r\nmutex_init(&priv->mutex);\r\nnet->base_addr = pid;\r\nif ((result = register_netdev(net)) < 0) {\r\ndvbnet->device[if_num] = NULL;\r\nfree_netdev(net);\r\nreturn result;\r\n}\r\nprintk("dvb_net: created network interface %s\n", net->name);\r\nreturn if_num;\r\n}\r\nstatic int dvb_net_remove_if(struct dvb_net *dvbnet, unsigned long num)\r\n{\r\nstruct net_device *net = dvbnet->device[num];\r\nstruct dvb_net_priv *priv;\r\nif (!dvbnet->state[num])\r\nreturn -EINVAL;\r\npriv = netdev_priv(net);\r\nif (priv->in_use)\r\nreturn -EBUSY;\r\ndvb_net_stop(net);\r\nflush_work_sync(&priv->set_multicast_list_wq);\r\nflush_work_sync(&priv->restart_net_feed_wq);\r\nprintk("dvb_net: removed network interface %s\n", net->name);\r\nunregister_netdev(net);\r\ndvbnet->state[num]=0;\r\ndvbnet->device[num] = NULL;\r\nfree_netdev(net);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_do_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_net *dvbnet = dvbdev->priv;\r\nif (((file->f_flags&O_ACCMODE)==O_RDONLY))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase NET_ADD_IF:\r\n{\r\nstruct dvb_net_if *dvbnetif = parg;\r\nint result;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (!try_module_get(dvbdev->adapter->module))\r\nreturn -EPERM;\r\nresult=dvb_net_add_if(dvbnet, dvbnetif->pid, dvbnetif->feedtype);\r\nif (result<0) {\r\nmodule_put(dvbdev->adapter->module);\r\nreturn result;\r\n}\r\ndvbnetif->if_num=result;\r\nbreak;\r\n}\r\ncase NET_GET_IF:\r\n{\r\nstruct net_device *netdev;\r\nstruct dvb_net_priv *priv_data;\r\nstruct dvb_net_if *dvbnetif = parg;\r\nif (dvbnetif->if_num >= DVB_NET_DEVICES_MAX ||\r\n!dvbnet->state[dvbnetif->if_num])\r\nreturn -EINVAL;\r\nnetdev = dvbnet->device[dvbnetif->if_num];\r\npriv_data = netdev_priv(netdev);\r\ndvbnetif->pid=priv_data->pid;\r\ndvbnetif->feedtype=priv_data->feedtype;\r\nbreak;\r\n}\r\ncase NET_REMOVE_IF:\r\n{\r\nint ret;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif ((unsigned long) parg >= DVB_NET_DEVICES_MAX)\r\nreturn -EINVAL;\r\nret = dvb_net_remove_if(dvbnet, (unsigned long) parg);\r\nif (!ret)\r\nmodule_put(dvbdev->adapter->module);\r\nreturn ret;\r\n}\r\ncase __NET_ADD_IF_OLD:\r\n{\r\nstruct __dvb_net_if_old *dvbnetif = parg;\r\nint result;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (!try_module_get(dvbdev->adapter->module))\r\nreturn -EPERM;\r\nresult=dvb_net_add_if(dvbnet, dvbnetif->pid, DVB_NET_FEEDTYPE_MPE);\r\nif (result<0) {\r\nmodule_put(dvbdev->adapter->module);\r\nreturn result;\r\n}\r\ndvbnetif->if_num=result;\r\nbreak;\r\n}\r\ncase __NET_GET_IF_OLD:\r\n{\r\nstruct net_device *netdev;\r\nstruct dvb_net_priv *priv_data;\r\nstruct __dvb_net_if_old *dvbnetif = parg;\r\nif (dvbnetif->if_num >= DVB_NET_DEVICES_MAX ||\r\n!dvbnet->state[dvbnetif->if_num])\r\nreturn -EINVAL;\r\nnetdev = dvbnet->device[dvbnetif->if_num];\r\npriv_data = netdev_priv(netdev);\r\ndvbnetif->pid=priv_data->pid;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic long dvb_net_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn dvb_usercopy(file, cmd, arg, dvb_net_do_ioctl);\r\n}\r\nstatic int dvb_net_close(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_net *dvbnet = dvbdev->priv;\r\ndvb_generic_release(inode, file);\r\nif(dvbdev->users == 1 && dvbnet->exit == 1) {\r\nfops_put(file->f_op);\r\nfile->f_op = NULL;\r\nwake_up(&dvbdev->wait_queue);\r\n}\r\nreturn 0;\r\n}\r\nvoid dvb_net_release (struct dvb_net *dvbnet)\r\n{\r\nint i;\r\ndvbnet->exit = 1;\r\nif (dvbnet->dvbdev->users < 1)\r\nwait_event(dvbnet->dvbdev->wait_queue,\r\ndvbnet->dvbdev->users==1);\r\ndvb_unregister_device(dvbnet->dvbdev);\r\nfor (i=0; i<DVB_NET_DEVICES_MAX; i++) {\r\nif (!dvbnet->state[i])\r\ncontinue;\r\ndvb_net_remove_if(dvbnet, i);\r\n}\r\n}\r\nint dvb_net_init (struct dvb_adapter *adap, struct dvb_net *dvbnet,\r\nstruct dmx_demux *dmx)\r\n{\r\nint i;\r\ndvbnet->demux = dmx;\r\nfor (i=0; i<DVB_NET_DEVICES_MAX; i++)\r\ndvbnet->state[i] = 0;\r\ndvb_register_device (adap, &dvbnet->dvbdev, &dvbdev_net,\r\ndvbnet, DVB_DEVICE_NET);\r\nreturn 0;\r\n}
