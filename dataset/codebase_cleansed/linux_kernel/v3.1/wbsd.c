static inline void wbsd_unlock_config(struct wbsd_host *host)\r\n{\r\nBUG_ON(host->config == 0);\r\noutb(host->unlock_code, host->config);\r\noutb(host->unlock_code, host->config);\r\n}\r\nstatic inline void wbsd_lock_config(struct wbsd_host *host)\r\n{\r\nBUG_ON(host->config == 0);\r\noutb(LOCK_CODE, host->config);\r\n}\r\nstatic inline void wbsd_write_config(struct wbsd_host *host, u8 reg, u8 value)\r\n{\r\nBUG_ON(host->config == 0);\r\noutb(reg, host->config);\r\noutb(value, host->config + 1);\r\n}\r\nstatic inline u8 wbsd_read_config(struct wbsd_host *host, u8 reg)\r\n{\r\nBUG_ON(host->config == 0);\r\noutb(reg, host->config);\r\nreturn inb(host->config + 1);\r\n}\r\nstatic inline void wbsd_write_index(struct wbsd_host *host, u8 index, u8 value)\r\n{\r\noutb(index, host->base + WBSD_IDXR);\r\noutb(value, host->base + WBSD_DATAR);\r\n}\r\nstatic inline u8 wbsd_read_index(struct wbsd_host *host, u8 index)\r\n{\r\noutb(index, host->base + WBSD_IDXR);\r\nreturn inb(host->base + WBSD_DATAR);\r\n}\r\nstatic void wbsd_init_device(struct wbsd_host *host)\r\n{\r\nu8 setup, ier;\r\nsetup = wbsd_read_index(host, WBSD_IDX_SETUP);\r\nsetup |= WBSD_FIFO_RESET | WBSD_SOFT_RESET;\r\nwbsd_write_index(host, WBSD_IDX_SETUP, setup);\r\nsetup &= ~WBSD_DAT3_H;\r\nwbsd_write_index(host, WBSD_IDX_SETUP, setup);\r\nhost->flags &= ~WBSD_FIGNORE_DETECT;\r\nhost->clk = wbsd_read_index(host, WBSD_IDX_CLK);\r\noutb(WBSD_POWER_N, host->base + WBSD_CSR);\r\nwbsd_write_index(host, WBSD_IDX_TAAC, 0x7F);\r\nif (inb(host->base + WBSD_CSR) & WBSD_CARDPRESENT)\r\nhost->flags |= WBSD_FCARD_PRESENT;\r\nelse\r\nhost->flags &= ~WBSD_FCARD_PRESENT;\r\nier = 0;\r\nier |= WBSD_EINT_CARD;\r\nier |= WBSD_EINT_FIFO_THRE;\r\nier |= WBSD_EINT_CRC;\r\nier |= WBSD_EINT_TIMEOUT;\r\nier |= WBSD_EINT_TC;\r\noutb(ier, host->base + WBSD_EIR);\r\ninb(host->base + WBSD_ISR);\r\n}\r\nstatic void wbsd_reset(struct wbsd_host *host)\r\n{\r\nu8 setup;\r\nprintk(KERN_ERR "%s: Resetting chip\n", mmc_hostname(host->mmc));\r\nsetup = wbsd_read_index(host, WBSD_IDX_SETUP);\r\nsetup |= WBSD_SOFT_RESET;\r\nwbsd_write_index(host, WBSD_IDX_SETUP, setup);\r\n}\r\nstatic void wbsd_request_end(struct wbsd_host *host, struct mmc_request *mrq)\r\n{\r\nunsigned long dmaflags;\r\nif (host->dma >= 0) {\r\ndmaflags = claim_dma_lock();\r\ndisable_dma(host->dma);\r\nclear_dma_ff(host->dma);\r\nrelease_dma_lock(dmaflags);\r\nwbsd_write_index(host, WBSD_IDX_DMA, 0);\r\n}\r\nhost->mrq = NULL;\r\nspin_unlock(&host->lock);\r\nmmc_request_done(host->mmc, mrq);\r\nspin_lock(&host->lock);\r\n}\r\nstatic inline void wbsd_init_sg(struct wbsd_host *host, struct mmc_data *data)\r\n{\r\nhost->cur_sg = data->sg;\r\nhost->num_sg = data->sg_len;\r\nhost->offset = 0;\r\nhost->remain = host->cur_sg->length;\r\n}\r\nstatic inline int wbsd_next_sg(struct wbsd_host *host)\r\n{\r\nhost->cur_sg++;\r\nhost->num_sg--;\r\nif (host->num_sg > 0) {\r\nhost->offset = 0;\r\nhost->remain = host->cur_sg->length;\r\n}\r\nreturn host->num_sg;\r\n}\r\nstatic inline char *wbsd_sg_to_buffer(struct wbsd_host *host)\r\n{\r\nreturn sg_virt(host->cur_sg);\r\n}\r\nstatic inline void wbsd_sg_to_dma(struct wbsd_host *host, struct mmc_data *data)\r\n{\r\nunsigned int len, i;\r\nstruct scatterlist *sg;\r\nchar *dmabuf = host->dma_buffer;\r\nchar *sgbuf;\r\nsg = data->sg;\r\nlen = data->sg_len;\r\nfor (i = 0; i < len; i++) {\r\nsgbuf = sg_virt(&sg[i]);\r\nmemcpy(dmabuf, sgbuf, sg[i].length);\r\ndmabuf += sg[i].length;\r\n}\r\n}\r\nstatic inline void wbsd_dma_to_sg(struct wbsd_host *host, struct mmc_data *data)\r\n{\r\nunsigned int len, i;\r\nstruct scatterlist *sg;\r\nchar *dmabuf = host->dma_buffer;\r\nchar *sgbuf;\r\nsg = data->sg;\r\nlen = data->sg_len;\r\nfor (i = 0; i < len; i++) {\r\nsgbuf = sg_virt(&sg[i]);\r\nmemcpy(sgbuf, dmabuf, sg[i].length);\r\ndmabuf += sg[i].length;\r\n}\r\n}\r\nstatic inline void wbsd_get_short_reply(struct wbsd_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nif (wbsd_read_index(host, WBSD_IDX_RSPLEN) != WBSD_RSP_SHORT) {\r\ncmd->error = -EILSEQ;\r\nreturn;\r\n}\r\ncmd->resp[0] = wbsd_read_index(host, WBSD_IDX_RESP12) << 24;\r\ncmd->resp[0] |= wbsd_read_index(host, WBSD_IDX_RESP13) << 16;\r\ncmd->resp[0] |= wbsd_read_index(host, WBSD_IDX_RESP14) << 8;\r\ncmd->resp[0] |= wbsd_read_index(host, WBSD_IDX_RESP15) << 0;\r\ncmd->resp[1] = wbsd_read_index(host, WBSD_IDX_RESP16) << 24;\r\n}\r\nstatic inline void wbsd_get_long_reply(struct wbsd_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nint i;\r\nif (wbsd_read_index(host, WBSD_IDX_RSPLEN) != WBSD_RSP_LONG) {\r\ncmd->error = -EILSEQ;\r\nreturn;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ncmd->resp[i] =\r\nwbsd_read_index(host, WBSD_IDX_RESP1 + i * 4) << 24;\r\ncmd->resp[i] |=\r\nwbsd_read_index(host, WBSD_IDX_RESP2 + i * 4) << 16;\r\ncmd->resp[i] |=\r\nwbsd_read_index(host, WBSD_IDX_RESP3 + i * 4) << 8;\r\ncmd->resp[i] |=\r\nwbsd_read_index(host, WBSD_IDX_RESP4 + i * 4) << 0;\r\n}\r\n}\r\nstatic void wbsd_send_command(struct wbsd_host *host, struct mmc_command *cmd)\r\n{\r\nint i;\r\nu8 status, isr;\r\nhost->isr = 0;\r\noutb(cmd->opcode, host->base + WBSD_CMDR);\r\nfor (i = 3; i >= 0; i--)\r\noutb((cmd->arg >> (i * 8)) & 0xff, host->base + WBSD_CMDR);\r\ncmd->error = 0;\r\ndo {\r\nstatus = wbsd_read_index(host, WBSD_IDX_STATUS);\r\n} while (status & WBSD_CARDTRAFFIC);\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nisr = host->isr;\r\nif (isr & WBSD_INT_CARD)\r\ncmd->error = -ENOMEDIUM;\r\nelse if (isr & WBSD_INT_TIMEOUT)\r\ncmd->error = -ETIMEDOUT;\r\nelse if ((cmd->flags & MMC_RSP_CRC) && (isr & WBSD_INT_CRC))\r\ncmd->error = -EILSEQ;\r\nelse {\r\nif (cmd->flags & MMC_RSP_136)\r\nwbsd_get_long_reply(host, cmd);\r\nelse\r\nwbsd_get_short_reply(host, cmd);\r\n}\r\n}\r\n}\r\nstatic void wbsd_empty_fifo(struct wbsd_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->cmd->data;\r\nchar *buffer;\r\nint i, fsr, fifo;\r\nif (host->num_sg == 0)\r\nreturn;\r\nbuffer = wbsd_sg_to_buffer(host) + host->offset;\r\nwhile (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_EMPTY)) {\r\nif (fsr & WBSD_FIFO_FULL)\r\nfifo = 16;\r\nelse if (fsr & WBSD_FIFO_FUTHRE)\r\nfifo = 8;\r\nelse\r\nfifo = 1;\r\nfor (i = 0; i < fifo; i++) {\r\n*buffer = inb(host->base + WBSD_DFR);\r\nbuffer++;\r\nhost->offset++;\r\nhost->remain--;\r\ndata->bytes_xfered++;\r\nif (host->remain == 0) {\r\nif (!wbsd_next_sg(host))\r\nreturn;\r\nbuffer = wbsd_sg_to_buffer(host);\r\n}\r\n}\r\n}\r\nif ((data->blocks * data->blksz - data->bytes_xfered) < 16)\r\ntasklet_schedule(&host->fifo_tasklet);\r\n}\r\nstatic void wbsd_fill_fifo(struct wbsd_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->cmd->data;\r\nchar *buffer;\r\nint i, fsr, fifo;\r\nif (host->num_sg == 0)\r\nreturn;\r\nbuffer = wbsd_sg_to_buffer(host) + host->offset;\r\nwhile (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_FULL)) {\r\nif (fsr & WBSD_FIFO_EMPTY)\r\nfifo = 0;\r\nelse if (fsr & WBSD_FIFO_EMTHRE)\r\nfifo = 8;\r\nelse\r\nfifo = 15;\r\nfor (i = 16; i > fifo; i--) {\r\noutb(*buffer, host->base + WBSD_DFR);\r\nbuffer++;\r\nhost->offset++;\r\nhost->remain--;\r\ndata->bytes_xfered++;\r\nif (host->remain == 0) {\r\nif (!wbsd_next_sg(host))\r\nreturn;\r\nbuffer = wbsd_sg_to_buffer(host);\r\n}\r\n}\r\n}\r\ntasklet_schedule(&host->fifo_tasklet);\r\n}\r\nstatic void wbsd_prepare_data(struct wbsd_host *host, struct mmc_data *data)\r\n{\r\nu16 blksize;\r\nu8 setup;\r\nunsigned long dmaflags;\r\nunsigned int size;\r\nsize = data->blocks * data->blksz;\r\nif (data->timeout_ns > 127000000)\r\nwbsd_write_index(host, WBSD_IDX_TAAC, 127);\r\nelse {\r\nwbsd_write_index(host, WBSD_IDX_TAAC,\r\ndata->timeout_ns / 1000000);\r\n}\r\nif (data->timeout_clks > 255)\r\nwbsd_write_index(host, WBSD_IDX_NSAC, 255);\r\nelse\r\nwbsd_write_index(host, WBSD_IDX_NSAC, data->timeout_clks);\r\nif (host->bus_width == MMC_BUS_WIDTH_1) {\r\nblksize = data->blksz + 2;\r\nwbsd_write_index(host, WBSD_IDX_PBSMSB, (blksize >> 4) & 0xF0);\r\nwbsd_write_index(host, WBSD_IDX_PBSLSB, blksize & 0xFF);\r\n} else if (host->bus_width == MMC_BUS_WIDTH_4) {\r\nblksize = data->blksz + 2 * 4;\r\nwbsd_write_index(host, WBSD_IDX_PBSMSB,\r\n((blksize >> 4) & 0xF0) | WBSD_DATA_WIDTH);\r\nwbsd_write_index(host, WBSD_IDX_PBSLSB, blksize & 0xFF);\r\n} else {\r\ndata->error = -EINVAL;\r\nreturn;\r\n}\r\nsetup = wbsd_read_index(host, WBSD_IDX_SETUP);\r\nsetup |= WBSD_FIFO_RESET;\r\nwbsd_write_index(host, WBSD_IDX_SETUP, setup);\r\nif (host->dma >= 0) {\r\nBUG_ON(size > 0x10000);\r\nif (size > 0x10000) {\r\ndata->error = -EINVAL;\r\nreturn;\r\n}\r\nif (data->flags & MMC_DATA_WRITE)\r\nwbsd_sg_to_dma(host, data);\r\ndmaflags = claim_dma_lock();\r\ndisable_dma(host->dma);\r\nclear_dma_ff(host->dma);\r\nif (data->flags & MMC_DATA_READ)\r\nset_dma_mode(host->dma, DMA_MODE_READ & ~0x40);\r\nelse\r\nset_dma_mode(host->dma, DMA_MODE_WRITE & ~0x40);\r\nset_dma_addr(host->dma, host->dma_addr);\r\nset_dma_count(host->dma, size);\r\nenable_dma(host->dma);\r\nrelease_dma_lock(dmaflags);\r\nwbsd_write_index(host, WBSD_IDX_DMA, WBSD_DMA_ENABLE);\r\n} else {\r\nhost->firsterr = 1;\r\nwbsd_init_sg(host, data);\r\nwbsd_write_index(host, WBSD_IDX_DMA, 0);\r\nif (data->flags & MMC_DATA_READ) {\r\nwbsd_write_index(host, WBSD_IDX_FIFOEN,\r\nWBSD_FIFOEN_FULL | 8);\r\n} else {\r\nwbsd_write_index(host, WBSD_IDX_FIFOEN,\r\nWBSD_FIFOEN_EMPTY | 8);\r\nwbsd_fill_fifo(host);\r\n}\r\n}\r\ndata->error = 0;\r\n}\r\nstatic void wbsd_finish_data(struct wbsd_host *host, struct mmc_data *data)\r\n{\r\nunsigned long dmaflags;\r\nint count;\r\nu8 status;\r\nWARN_ON(host->mrq == NULL);\r\nif (data->stop)\r\nwbsd_send_command(host, data->stop);\r\ndo {\r\nstatus = wbsd_read_index(host, WBSD_IDX_STATUS);\r\n} while (status & (WBSD_BLOCK_READ | WBSD_BLOCK_WRITE));\r\nif (host->dma >= 0) {\r\nwbsd_write_index(host, WBSD_IDX_DMA, 0);\r\ndmaflags = claim_dma_lock();\r\ndisable_dma(host->dma);\r\nclear_dma_ff(host->dma);\r\ncount = get_dma_residue(host->dma);\r\nrelease_dma_lock(dmaflags);\r\ndata->bytes_xfered = host->mrq->data->blocks *\r\nhost->mrq->data->blksz - count;\r\ndata->bytes_xfered -= data->bytes_xfered % data->blksz;\r\nif (count) {\r\nprintk(KERN_ERR "%s: Incomplete DMA transfer. "\r\n"%d bytes left.\n",\r\nmmc_hostname(host->mmc), count);\r\nif (!data->error)\r\ndata->error = -EIO;\r\n} else {\r\nif (data->flags & MMC_DATA_READ)\r\nwbsd_dma_to_sg(host, data);\r\n}\r\nif (data->error) {\r\nif (data->bytes_xfered)\r\ndata->bytes_xfered -= data->blksz;\r\n}\r\n}\r\nwbsd_request_end(host, host->mrq);\r\n}\r\nstatic void wbsd_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct wbsd_host *host = mmc_priv(mmc);\r\nstruct mmc_command *cmd;\r\nspin_lock_bh(&host->lock);\r\nBUG_ON(host->mrq != NULL);\r\ncmd = mrq->cmd;\r\nhost->mrq = mrq;\r\nif (!(host->flags & WBSD_FCARD_PRESENT)) {\r\ncmd->error = -ENOMEDIUM;\r\ngoto done;\r\n}\r\nif (cmd->data) {\r\nswitch (cmd->opcode) {\r\ncase 11:\r\ncase 17:\r\ncase 18:\r\ncase 20:\r\ncase 24:\r\ncase 25:\r\ncase 26:\r\ncase 27:\r\ncase 30:\r\ncase 42:\r\ncase 56:\r\nbreak;\r\ncase 51:\r\nbreak;\r\ndefault:\r\n#ifdef CONFIG_MMC_DEBUG\r\nprintk(KERN_WARNING "%s: Data command %d is not "\r\n"supported by this controller.\n",\r\nmmc_hostname(host->mmc), cmd->opcode);\r\n#endif\r\ncmd->error = -EINVAL;\r\ngoto done;\r\n};\r\n}\r\nif (cmd->data) {\r\nwbsd_prepare_data(host, cmd->data);\r\nif (cmd->data->error)\r\ngoto done;\r\n}\r\nwbsd_send_command(host, cmd);\r\nif (cmd->data && !cmd->error) {\r\nif (host->dma == -1)\r\ntasklet_schedule(&host->fifo_tasklet);\r\nspin_unlock_bh(&host->lock);\r\nreturn;\r\n}\r\ndone:\r\nwbsd_request_end(host, mrq);\r\nspin_unlock_bh(&host->lock);\r\n}\r\nstatic void wbsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct wbsd_host *host = mmc_priv(mmc);\r\nu8 clk, setup, pwr;\r\nspin_lock_bh(&host->lock);\r\nif (ios->power_mode == MMC_POWER_OFF)\r\nwbsd_init_device(host);\r\nif (ios->clock >= 24000000)\r\nclk = WBSD_CLK_24M;\r\nelse if (ios->clock >= 16000000)\r\nclk = WBSD_CLK_16M;\r\nelse if (ios->clock >= 12000000)\r\nclk = WBSD_CLK_12M;\r\nelse\r\nclk = WBSD_CLK_375K;\r\nif (clk != host->clk) {\r\nwbsd_write_index(host, WBSD_IDX_CLK, clk);\r\nhost->clk = clk;\r\n}\r\nif (ios->power_mode != MMC_POWER_OFF) {\r\npwr = inb(host->base + WBSD_CSR);\r\npwr &= ~WBSD_POWER_N;\r\noutb(pwr, host->base + WBSD_CSR);\r\n}\r\nsetup = wbsd_read_index(host, WBSD_IDX_SETUP);\r\nif (ios->chip_select == MMC_CS_HIGH) {\r\nBUG_ON(ios->bus_width != MMC_BUS_WIDTH_1);\r\nsetup |= WBSD_DAT3_H;\r\nhost->flags |= WBSD_FIGNORE_DETECT;\r\n} else {\r\nif (setup & WBSD_DAT3_H) {\r\nsetup &= ~WBSD_DAT3_H;\r\nmod_timer(&host->ignore_timer, jiffies + HZ / 100);\r\n}\r\n}\r\nwbsd_write_index(host, WBSD_IDX_SETUP, setup);\r\nhost->bus_width = ios->bus_width;\r\nspin_unlock_bh(&host->lock);\r\n}\r\nstatic int wbsd_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct wbsd_host *host = mmc_priv(mmc);\r\nu8 csr;\r\nspin_lock_bh(&host->lock);\r\ncsr = inb(host->base + WBSD_CSR);\r\ncsr |= WBSD_MSLED;\r\noutb(csr, host->base + WBSD_CSR);\r\nmdelay(1);\r\ncsr = inb(host->base + WBSD_CSR);\r\ncsr &= ~WBSD_MSLED;\r\noutb(csr, host->base + WBSD_CSR);\r\nspin_unlock_bh(&host->lock);\r\nreturn !!(csr & WBSD_WRPT);\r\n}\r\nstatic void wbsd_reset_ignore(unsigned long data)\r\n{\r\nstruct wbsd_host *host = (struct wbsd_host *)data;\r\nBUG_ON(host == NULL);\r\nDBG("Resetting card detection ignore\n");\r\nspin_lock_bh(&host->lock);\r\nhost->flags &= ~WBSD_FIGNORE_DETECT;\r\ntasklet_schedule(&host->card_tasklet);\r\nspin_unlock_bh(&host->lock);\r\n}\r\nstatic inline struct mmc_data *wbsd_get_data(struct wbsd_host *host)\r\n{\r\nWARN_ON(!host->mrq);\r\nif (!host->mrq)\r\nreturn NULL;\r\nWARN_ON(!host->mrq->cmd);\r\nif (!host->mrq->cmd)\r\nreturn NULL;\r\nWARN_ON(!host->mrq->cmd->data);\r\nif (!host->mrq->cmd->data)\r\nreturn NULL;\r\nreturn host->mrq->cmd->data;\r\n}\r\nstatic void wbsd_tasklet_card(unsigned long param)\r\n{\r\nstruct wbsd_host *host = (struct wbsd_host *)param;\r\nu8 csr;\r\nint delay = -1;\r\nspin_lock(&host->lock);\r\nif (host->flags & WBSD_FIGNORE_DETECT) {\r\nspin_unlock(&host->lock);\r\nreturn;\r\n}\r\ncsr = inb(host->base + WBSD_CSR);\r\nWARN_ON(csr == 0xff);\r\nif (csr & WBSD_CARDPRESENT) {\r\nif (!(host->flags & WBSD_FCARD_PRESENT)) {\r\nDBG("Card inserted\n");\r\nhost->flags |= WBSD_FCARD_PRESENT;\r\ndelay = 500;\r\n}\r\n} else if (host->flags & WBSD_FCARD_PRESENT) {\r\nDBG("Card removed\n");\r\nhost->flags &= ~WBSD_FCARD_PRESENT;\r\nif (host->mrq) {\r\nprintk(KERN_ERR "%s: Card removed during transfer!\n",\r\nmmc_hostname(host->mmc));\r\nwbsd_reset(host);\r\nhost->mrq->cmd->error = -ENOMEDIUM;\r\ntasklet_schedule(&host->finish_tasklet);\r\n}\r\ndelay = 0;\r\n}\r\nspin_unlock(&host->lock);\r\nif (delay != -1)\r\nmmc_detect_change(host->mmc, msecs_to_jiffies(delay));\r\n}\r\nstatic void wbsd_tasklet_fifo(unsigned long param)\r\n{\r\nstruct wbsd_host *host = (struct wbsd_host *)param;\r\nstruct mmc_data *data;\r\nspin_lock(&host->lock);\r\nif (!host->mrq)\r\ngoto end;\r\ndata = wbsd_get_data(host);\r\nif (!data)\r\ngoto end;\r\nif (data->flags & MMC_DATA_WRITE)\r\nwbsd_fill_fifo(host);\r\nelse\r\nwbsd_empty_fifo(host);\r\nif (host->num_sg == 0) {\r\nwbsd_write_index(host, WBSD_IDX_FIFOEN, 0);\r\ntasklet_schedule(&host->finish_tasklet);\r\n}\r\nend:\r\nspin_unlock(&host->lock);\r\n}\r\nstatic void wbsd_tasklet_crc(unsigned long param)\r\n{\r\nstruct wbsd_host *host = (struct wbsd_host *)param;\r\nstruct mmc_data *data;\r\nspin_lock(&host->lock);\r\nif (!host->mrq)\r\ngoto end;\r\ndata = wbsd_get_data(host);\r\nif (!data)\r\ngoto end;\r\nDBGF("CRC error\n");\r\ndata->error = -EILSEQ;\r\ntasklet_schedule(&host->finish_tasklet);\r\nend:\r\nspin_unlock(&host->lock);\r\n}\r\nstatic void wbsd_tasklet_timeout(unsigned long param)\r\n{\r\nstruct wbsd_host *host = (struct wbsd_host *)param;\r\nstruct mmc_data *data;\r\nspin_lock(&host->lock);\r\nif (!host->mrq)\r\ngoto end;\r\ndata = wbsd_get_data(host);\r\nif (!data)\r\ngoto end;\r\nDBGF("Timeout\n");\r\ndata->error = -ETIMEDOUT;\r\ntasklet_schedule(&host->finish_tasklet);\r\nend:\r\nspin_unlock(&host->lock);\r\n}\r\nstatic void wbsd_tasklet_finish(unsigned long param)\r\n{\r\nstruct wbsd_host *host = (struct wbsd_host *)param;\r\nstruct mmc_data *data;\r\nspin_lock(&host->lock);\r\nWARN_ON(!host->mrq);\r\nif (!host->mrq)\r\ngoto end;\r\ndata = wbsd_get_data(host);\r\nif (!data)\r\ngoto end;\r\nwbsd_finish_data(host, data);\r\nend:\r\nspin_unlock(&host->lock);\r\n}\r\nstatic irqreturn_t wbsd_irq(int irq, void *dev_id)\r\n{\r\nstruct wbsd_host *host = dev_id;\r\nint isr;\r\nisr = inb(host->base + WBSD_ISR);\r\nif (isr == 0xff || isr == 0x00)\r\nreturn IRQ_NONE;\r\nhost->isr |= isr;\r\nif (isr & WBSD_INT_CARD)\r\ntasklet_schedule(&host->card_tasklet);\r\nif (isr & WBSD_INT_FIFO_THRE)\r\ntasklet_schedule(&host->fifo_tasklet);\r\nif (isr & WBSD_INT_CRC)\r\ntasklet_hi_schedule(&host->crc_tasklet);\r\nif (isr & WBSD_INT_TIMEOUT)\r\ntasklet_hi_schedule(&host->timeout_tasklet);\r\nif (isr & WBSD_INT_TC)\r\ntasklet_schedule(&host->finish_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit wbsd_alloc_mmc(struct device *dev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct wbsd_host *host;\r\nmmc = mmc_alloc_host(sizeof(struct wbsd_host), dev);\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->dma = -1;\r\nmmc->ops = &wbsd_ops;\r\nmmc->f_min = 375000;\r\nmmc->f_max = 24000000;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->caps = MMC_CAP_4_BIT_DATA;\r\nspin_lock_init(&host->lock);\r\ninit_timer(&host->ignore_timer);\r\nhost->ignore_timer.data = (unsigned long)host;\r\nhost->ignore_timer.function = wbsd_reset_ignore;\r\nmmc->max_segs = 128;\r\nmmc->max_req_size = 65536;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nmmc->max_blk_size = 4087;\r\nmmc->max_blk_count = mmc->max_req_size;\r\ndev_set_drvdata(dev, mmc);\r\nreturn 0;\r\n}\r\nstatic void wbsd_free_mmc(struct device *dev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct wbsd_host *host;\r\nmmc = dev_get_drvdata(dev);\r\nif (!mmc)\r\nreturn;\r\nhost = mmc_priv(mmc);\r\nBUG_ON(host == NULL);\r\ndel_timer_sync(&host->ignore_timer);\r\nmmc_free_host(mmc);\r\ndev_set_drvdata(dev, NULL);\r\n}\r\nstatic int __devinit wbsd_scan(struct wbsd_host *host)\r\n{\r\nint i, j, k;\r\nint id;\r\nfor (i = 0; i < ARRAY_SIZE(config_ports); i++) {\r\nif (!request_region(config_ports[i], 2, DRIVER_NAME))\r\ncontinue;\r\nfor (j = 0; j < ARRAY_SIZE(unlock_codes); j++) {\r\nid = 0xFFFF;\r\nhost->config = config_ports[i];\r\nhost->unlock_code = unlock_codes[j];\r\nwbsd_unlock_config(host);\r\noutb(WBSD_CONF_ID_HI, config_ports[i]);\r\nid = inb(config_ports[i] + 1) << 8;\r\noutb(WBSD_CONF_ID_LO, config_ports[i]);\r\nid |= inb(config_ports[i] + 1);\r\nwbsd_lock_config(host);\r\nfor (k = 0; k < ARRAY_SIZE(valid_ids); k++) {\r\nif (id == valid_ids[k]) {\r\nhost->chip_id = id;\r\nreturn 0;\r\n}\r\n}\r\nif (id != 0xFFFF) {\r\nDBG("Unknown hardware (id %x) found at %x\n",\r\nid, config_ports[i]);\r\n}\r\n}\r\nrelease_region(config_ports[i], 2);\r\n}\r\nhost->config = 0;\r\nhost->unlock_code = 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit wbsd_request_region(struct wbsd_host *host, int base)\r\n{\r\nif (base & 0x7)\r\nreturn -EINVAL;\r\nif (!request_region(base, 8, DRIVER_NAME))\r\nreturn -EIO;\r\nhost->base = base;\r\nreturn 0;\r\n}\r\nstatic void wbsd_release_regions(struct wbsd_host *host)\r\n{\r\nif (host->base)\r\nrelease_region(host->base, 8);\r\nhost->base = 0;\r\nif (host->config)\r\nrelease_region(host->config, 2);\r\nhost->config = 0;\r\n}\r\nstatic void __devinit wbsd_request_dma(struct wbsd_host *host, int dma)\r\n{\r\nif (dma < 0)\r\nreturn;\r\nif (request_dma(dma, DRIVER_NAME))\r\ngoto err;\r\nhost->dma_buffer = kmalloc(WBSD_DMA_SIZE,\r\nGFP_NOIO | GFP_DMA | __GFP_REPEAT | __GFP_NOWARN);\r\nif (!host->dma_buffer)\r\ngoto free;\r\nhost->dma_addr = dma_map_single(mmc_dev(host->mmc), host->dma_buffer,\r\nWBSD_DMA_SIZE, DMA_BIDIRECTIONAL);\r\nif ((host->dma_addr & 0xffff) != 0)\r\ngoto kfree;\r\nelse if (host->dma_addr >= 0x1000000)\r\ngoto kfree;\r\nhost->dma = dma;\r\nreturn;\r\nkfree:\r\nBUG_ON(1);\r\ndma_unmap_single(mmc_dev(host->mmc), host->dma_addr,\r\nWBSD_DMA_SIZE, DMA_BIDIRECTIONAL);\r\nhost->dma_addr = 0;\r\nkfree(host->dma_buffer);\r\nhost->dma_buffer = NULL;\r\nfree:\r\nfree_dma(dma);\r\nerr:\r\nprintk(KERN_WARNING DRIVER_NAME ": Unable to allocate DMA %d. "\r\n"Falling back on FIFO.\n", dma);\r\n}\r\nstatic void wbsd_release_dma(struct wbsd_host *host)\r\n{\r\nif (host->dma_addr) {\r\ndma_unmap_single(mmc_dev(host->mmc), host->dma_addr,\r\nWBSD_DMA_SIZE, DMA_BIDIRECTIONAL);\r\n}\r\nkfree(host->dma_buffer);\r\nif (host->dma >= 0)\r\nfree_dma(host->dma);\r\nhost->dma = -1;\r\nhost->dma_buffer = NULL;\r\nhost->dma_addr = 0;\r\n}\r\nstatic int __devinit wbsd_request_irq(struct wbsd_host *host, int irq)\r\n{\r\nint ret;\r\ntasklet_init(&host->card_tasklet, wbsd_tasklet_card,\r\n(unsigned long)host);\r\ntasklet_init(&host->fifo_tasklet, wbsd_tasklet_fifo,\r\n(unsigned long)host);\r\ntasklet_init(&host->crc_tasklet, wbsd_tasklet_crc,\r\n(unsigned long)host);\r\ntasklet_init(&host->timeout_tasklet, wbsd_tasklet_timeout,\r\n(unsigned long)host);\r\ntasklet_init(&host->finish_tasklet, wbsd_tasklet_finish,\r\n(unsigned long)host);\r\nret = request_irq(irq, wbsd_irq, IRQF_SHARED, DRIVER_NAME, host);\r\nif (ret)\r\nreturn ret;\r\nhost->irq = irq;\r\nreturn 0;\r\n}\r\nstatic void wbsd_release_irq(struct wbsd_host *host)\r\n{\r\nif (!host->irq)\r\nreturn;\r\nfree_irq(host->irq, host);\r\nhost->irq = 0;\r\ntasklet_kill(&host->card_tasklet);\r\ntasklet_kill(&host->fifo_tasklet);\r\ntasklet_kill(&host->crc_tasklet);\r\ntasklet_kill(&host->timeout_tasklet);\r\ntasklet_kill(&host->finish_tasklet);\r\n}\r\nstatic int __devinit wbsd_request_resources(struct wbsd_host *host,\r\nint base, int irq, int dma)\r\n{\r\nint ret;\r\nret = wbsd_request_region(host, base);\r\nif (ret)\r\nreturn ret;\r\nret = wbsd_request_irq(host, irq);\r\nif (ret)\r\nreturn ret;\r\nwbsd_request_dma(host, dma);\r\nreturn 0;\r\n}\r\nstatic void wbsd_release_resources(struct wbsd_host *host)\r\n{\r\nwbsd_release_dma(host);\r\nwbsd_release_irq(host);\r\nwbsd_release_regions(host);\r\n}\r\nstatic void wbsd_chip_config(struct wbsd_host *host)\r\n{\r\nwbsd_unlock_config(host);\r\nwbsd_write_config(host, WBSD_CONF_SWRST, 1);\r\nwbsd_write_config(host, WBSD_CONF_SWRST, 0);\r\nwbsd_write_config(host, WBSD_CONF_DEVICE, DEVICE_SD);\r\nwbsd_write_config(host, WBSD_CONF_PINS, WBSD_PINS_DETECT_GP11);\r\nwbsd_write_config(host, WBSD_CONF_PORT_HI, host->base >> 8);\r\nwbsd_write_config(host, WBSD_CONF_PORT_LO, host->base & 0xff);\r\nwbsd_write_config(host, WBSD_CONF_IRQ, host->irq);\r\nif (host->dma >= 0)\r\nwbsd_write_config(host, WBSD_CONF_DRQ, host->dma);\r\nwbsd_write_config(host, WBSD_CONF_ENABLE, 1);\r\nwbsd_write_config(host, WBSD_CONF_POWER, 0x20);\r\nwbsd_lock_config(host);\r\n}\r\nstatic int wbsd_chip_validate(struct wbsd_host *host)\r\n{\r\nint base, irq, dma;\r\nwbsd_unlock_config(host);\r\nwbsd_write_config(host, WBSD_CONF_DEVICE, DEVICE_SD);\r\nbase = wbsd_read_config(host, WBSD_CONF_PORT_HI) << 8;\r\nbase |= wbsd_read_config(host, WBSD_CONF_PORT_LO);\r\nirq = wbsd_read_config(host, WBSD_CONF_IRQ);\r\ndma = wbsd_read_config(host, WBSD_CONF_DRQ);\r\nwbsd_lock_config(host);\r\nif (base != host->base)\r\nreturn 0;\r\nif (irq != host->irq)\r\nreturn 0;\r\nif ((dma != host->dma) && (host->dma != -1))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void wbsd_chip_poweroff(struct wbsd_host *host)\r\n{\r\nwbsd_unlock_config(host);\r\nwbsd_write_config(host, WBSD_CONF_DEVICE, DEVICE_SD);\r\nwbsd_write_config(host, WBSD_CONF_ENABLE, 0);\r\nwbsd_lock_config(host);\r\n}\r\nstatic int __devinit wbsd_init(struct device *dev, int base, int irq, int dma,\r\nint pnp)\r\n{\r\nstruct wbsd_host *host = NULL;\r\nstruct mmc_host *mmc = NULL;\r\nint ret;\r\nret = wbsd_alloc_mmc(dev);\r\nif (ret)\r\nreturn ret;\r\nmmc = dev_get_drvdata(dev);\r\nhost = mmc_priv(mmc);\r\nret = wbsd_scan(host);\r\nif (ret) {\r\nif (pnp && (ret == -ENODEV)) {\r\nprintk(KERN_WARNING DRIVER_NAME\r\n": Unable to confirm device presence. You may "\r\n"experience lock-ups.\n");\r\n} else {\r\nwbsd_free_mmc(dev);\r\nreturn ret;\r\n}\r\n}\r\nret = wbsd_request_resources(host, base, irq, dma);\r\nif (ret) {\r\nwbsd_release_resources(host);\r\nwbsd_free_mmc(dev);\r\nreturn ret;\r\n}\r\nif (pnp) {\r\nif ((host->config != 0) && !wbsd_chip_validate(host)) {\r\nprintk(KERN_WARNING DRIVER_NAME\r\n": PnP active but chip not configured! "\r\n"You probably have a buggy BIOS. "\r\n"Configuring chip manually.\n");\r\nwbsd_chip_config(host);\r\n}\r\n} else\r\nwbsd_chip_config(host);\r\n#ifdef CONFIG_PM\r\nif (host->config) {\r\nwbsd_unlock_config(host);\r\nwbsd_write_config(host, WBSD_CONF_PME, 0xA0);\r\nwbsd_lock_config(host);\r\n}\r\n#endif\r\nmdelay(5);\r\nwbsd_init_device(host);\r\nmmc_add_host(mmc);\r\nprintk(KERN_INFO "%s: W83L51xD", mmc_hostname(mmc));\r\nif (host->chip_id != 0)\r\nprintk(" id %x", (int)host->chip_id);\r\nprintk(" at 0x%x irq %d", (int)host->base, (int)host->irq);\r\nif (host->dma >= 0)\r\nprintk(" dma %d", (int)host->dma);\r\nelse\r\nprintk(" FIFO");\r\nif (pnp)\r\nprintk(" PnP");\r\nprintk("\n");\r\nreturn 0;\r\n}\r\nstatic void __devexit wbsd_shutdown(struct device *dev, int pnp)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct wbsd_host *host;\r\nif (!mmc)\r\nreturn;\r\nhost = mmc_priv(mmc);\r\nmmc_remove_host(mmc);\r\nif (!pnp)\r\nwbsd_chip_poweroff(host);\r\nwbsd_release_resources(host);\r\nwbsd_free_mmc(dev);\r\n}\r\nstatic int __devinit wbsd_probe(struct platform_device *dev)\r\n{\r\nreturn wbsd_init(&dev->dev, param_io, param_irq, param_dma, 0);\r\n}\r\nstatic int __devexit wbsd_remove(struct platform_device *dev)\r\n{\r\nwbsd_shutdown(&dev->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nwbsd_pnp_probe(struct pnp_dev *pnpdev, const struct pnp_device_id *dev_id)\r\n{\r\nint io, irq, dma;\r\nio = pnp_port_start(pnpdev, 0);\r\nirq = pnp_irq(pnpdev, 0);\r\nif (pnp_dma_valid(pnpdev, 0))\r\ndma = pnp_dma(pnpdev, 0);\r\nelse\r\ndma = -1;\r\nDBGF("PnP resources: port %3x irq %d dma %d\n", io, irq, dma);\r\nreturn wbsd_init(&pnpdev->dev, io, irq, dma, 1);\r\n}\r\nstatic void __devexit wbsd_pnp_remove(struct pnp_dev *dev)\r\n{\r\nwbsd_shutdown(&dev->dev, 1);\r\n}\r\nstatic int wbsd_suspend(struct wbsd_host *host, pm_message_t state)\r\n{\r\nBUG_ON(host == NULL);\r\nreturn mmc_suspend_host(host->mmc);\r\n}\r\nstatic int wbsd_resume(struct wbsd_host *host)\r\n{\r\nBUG_ON(host == NULL);\r\nwbsd_init_device(host);\r\nreturn mmc_resume_host(host->mmc);\r\n}\r\nstatic int wbsd_platform_suspend(struct platform_device *dev,\r\npm_message_t state)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(dev);\r\nstruct wbsd_host *host;\r\nint ret;\r\nif (mmc == NULL)\r\nreturn 0;\r\nDBGF("Suspending...\n");\r\nhost = mmc_priv(mmc);\r\nret = wbsd_suspend(host, state);\r\nif (ret)\r\nreturn ret;\r\nwbsd_chip_poweroff(host);\r\nreturn 0;\r\n}\r\nstatic int wbsd_platform_resume(struct platform_device *dev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(dev);\r\nstruct wbsd_host *host;\r\nif (mmc == NULL)\r\nreturn 0;\r\nDBGF("Resuming...\n");\r\nhost = mmc_priv(mmc);\r\nwbsd_chip_config(host);\r\nmdelay(5);\r\nreturn wbsd_resume(host);\r\n}\r\nstatic int wbsd_pnp_suspend(struct pnp_dev *pnp_dev, pm_message_t state)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(&pnp_dev->dev);\r\nstruct wbsd_host *host;\r\nif (mmc == NULL)\r\nreturn 0;\r\nDBGF("Suspending...\n");\r\nhost = mmc_priv(mmc);\r\nreturn wbsd_suspend(host, state);\r\n}\r\nstatic int wbsd_pnp_resume(struct pnp_dev *pnp_dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(&pnp_dev->dev);\r\nstruct wbsd_host *host;\r\nif (mmc == NULL)\r\nreturn 0;\r\nDBGF("Resuming...\n");\r\nhost = mmc_priv(mmc);\r\nif (host->config != 0) {\r\nif (!wbsd_chip_validate(host)) {\r\nprintk(KERN_WARNING DRIVER_NAME\r\n": PnP active but chip not configured! "\r\n"You probably have a buggy BIOS. "\r\n"Configuring chip manually.\n");\r\nwbsd_chip_config(host);\r\n}\r\n}\r\nmdelay(5);\r\nreturn wbsd_resume(host);\r\n}\r\nstatic int __init wbsd_drv_init(void)\r\n{\r\nint result;\r\nprintk(KERN_INFO DRIVER_NAME\r\n": Winbond W83L51xD SD/MMC card interface driver\n");\r\nprintk(KERN_INFO DRIVER_NAME ": Copyright(c) Pierre Ossman\n");\r\n#ifdef CONFIG_PNP\r\nif (!param_nopnp) {\r\nresult = pnp_register_driver(&wbsd_pnp_driver);\r\nif (result < 0)\r\nreturn result;\r\n}\r\n#endif\r\nif (param_nopnp) {\r\nresult = platform_driver_register(&wbsd_driver);\r\nif (result < 0)\r\nreturn result;\r\nwbsd_device = platform_device_alloc(DRIVER_NAME, -1);\r\nif (!wbsd_device) {\r\nplatform_driver_unregister(&wbsd_driver);\r\nreturn -ENOMEM;\r\n}\r\nresult = platform_device_add(wbsd_device);\r\nif (result) {\r\nplatform_device_put(wbsd_device);\r\nplatform_driver_unregister(&wbsd_driver);\r\nreturn result;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit wbsd_drv_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (!param_nopnp)\r\npnp_unregister_driver(&wbsd_pnp_driver);\r\n#endif\r\nif (param_nopnp) {\r\nplatform_device_unregister(wbsd_device);\r\nplatform_driver_unregister(&wbsd_driver);\r\n}\r\nDBG("unloaded\n");\r\n}
