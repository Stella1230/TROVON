static void do_sony_laptop_release_key(unsigned long unused)\r\n{\r\nstruct sony_laptop_keypress kp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sony_laptop_input.fifo_lock, flags);\r\nif (kfifo_out(&sony_laptop_input.fifo,\r\n(unsigned char *)&kp, sizeof(kp)) == sizeof(kp)) {\r\ninput_report_key(kp.dev, kp.key, 0);\r\ninput_sync(kp.dev);\r\n}\r\nif (kfifo_len(&sony_laptop_input.fifo) != 0)\r\nmod_timer(&sony_laptop_input.release_key_timer,\r\njiffies + msecs_to_jiffies(10));\r\nspin_unlock_irqrestore(&sony_laptop_input.fifo_lock, flags);\r\n}\r\nstatic void sony_laptop_report_input_event(u8 event)\r\n{\r\nstruct input_dev *jog_dev = sony_laptop_input.jog_dev;\r\nstruct input_dev *key_dev = sony_laptop_input.key_dev;\r\nstruct sony_laptop_keypress kp = { NULL };\r\nif (event == SONYPI_EVENT_FNKEY_RELEASED ||\r\nevent == SONYPI_EVENT_ANYBUTTON_RELEASED) {\r\nreturn;\r\n}\r\nswitch (event) {\r\ncase SONYPI_EVENT_JOGDIAL_UP:\r\ncase SONYPI_EVENT_JOGDIAL_UP_PRESSED:\r\ninput_report_rel(jog_dev, REL_WHEEL, 1);\r\ninput_sync(jog_dev);\r\nreturn;\r\ncase SONYPI_EVENT_JOGDIAL_DOWN:\r\ncase SONYPI_EVENT_JOGDIAL_DOWN_PRESSED:\r\ninput_report_rel(jog_dev, REL_WHEEL, -1);\r\ninput_sync(jog_dev);\r\nreturn;\r\ncase SONYPI_EVENT_JOGDIAL_PRESSED:\r\nkp.key = BTN_MIDDLE;\r\nkp.dev = jog_dev;\r\nbreak;\r\ndefault:\r\nif (event >= ARRAY_SIZE(sony_laptop_input_index)) {\r\ndprintk("sony_laptop_report_input_event, event not known: %d\n", event);\r\nbreak;\r\n}\r\nif (sony_laptop_input_index[event] != -1) {\r\nkp.key = sony_laptop_input_keycode_map[sony_laptop_input_index[event]];\r\nif (kp.key != KEY_UNKNOWN)\r\nkp.dev = key_dev;\r\n}\r\nbreak;\r\n}\r\nif (kp.dev) {\r\ninput_report_key(kp.dev, kp.key, 1);\r\ninput_event(kp.dev, EV_MSC, MSC_SCAN, event);\r\ninput_sync(kp.dev);\r\nkfifo_in_locked(&sony_laptop_input.fifo,\r\n(unsigned char *)&kp, sizeof(kp),\r\n&sony_laptop_input.fifo_lock);\r\nmod_timer(&sony_laptop_input.release_key_timer,\r\njiffies + msecs_to_jiffies(10));\r\n} else\r\ndprintk("unknown input event %.2x\n", event);\r\n}\r\nstatic int sony_laptop_setup_input(struct acpi_device *acpi_device)\r\n{\r\nstruct input_dev *jog_dev;\r\nstruct input_dev *key_dev;\r\nint i;\r\nint error;\r\nif (atomic_add_return(1, &sony_laptop_input.users) > 1)\r\nreturn 0;\r\nspin_lock_init(&sony_laptop_input.fifo_lock);\r\nerror = kfifo_alloc(&sony_laptop_input.fifo,\r\nSONY_LAPTOP_BUF_SIZE, GFP_KERNEL);\r\nif (error) {\r\npr_err("kfifo_alloc failed\n");\r\ngoto err_dec_users;\r\n}\r\nsetup_timer(&sony_laptop_input.release_key_timer,\r\ndo_sony_laptop_release_key, 0);\r\nkey_dev = input_allocate_device();\r\nif (!key_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_kfifo;\r\n}\r\nkey_dev->name = "Sony Vaio Keys";\r\nkey_dev->id.bustype = BUS_ISA;\r\nkey_dev->id.vendor = PCI_VENDOR_ID_SONY;\r\nkey_dev->dev.parent = &acpi_device->dev;\r\ninput_set_capability(key_dev, EV_MSC, MSC_SCAN);\r\n__set_bit(EV_KEY, key_dev->evbit);\r\nkey_dev->keycodesize = sizeof(sony_laptop_input_keycode_map[0]);\r\nkey_dev->keycodemax = ARRAY_SIZE(sony_laptop_input_keycode_map);\r\nkey_dev->keycode = &sony_laptop_input_keycode_map;\r\nfor (i = 0; i < ARRAY_SIZE(sony_laptop_input_keycode_map); i++)\r\n__set_bit(sony_laptop_input_keycode_map[i], key_dev->keybit);\r\n__clear_bit(KEY_RESERVED, key_dev->keybit);\r\nerror = input_register_device(key_dev);\r\nif (error)\r\ngoto err_free_keydev;\r\nsony_laptop_input.key_dev = key_dev;\r\njog_dev = input_allocate_device();\r\nif (!jog_dev) {\r\nerror = -ENOMEM;\r\ngoto err_unregister_keydev;\r\n}\r\njog_dev->name = "Sony Vaio Jogdial";\r\njog_dev->id.bustype = BUS_ISA;\r\njog_dev->id.vendor = PCI_VENDOR_ID_SONY;\r\nkey_dev->dev.parent = &acpi_device->dev;\r\ninput_set_capability(jog_dev, EV_KEY, BTN_MIDDLE);\r\ninput_set_capability(jog_dev, EV_REL, REL_WHEEL);\r\nerror = input_register_device(jog_dev);\r\nif (error)\r\ngoto err_free_jogdev;\r\nsony_laptop_input.jog_dev = jog_dev;\r\nreturn 0;\r\nerr_free_jogdev:\r\ninput_free_device(jog_dev);\r\nerr_unregister_keydev:\r\ninput_unregister_device(key_dev);\r\nkey_dev = NULL;\r\nerr_free_keydev:\r\ninput_free_device(key_dev);\r\nerr_free_kfifo:\r\nkfifo_free(&sony_laptop_input.fifo);\r\nerr_dec_users:\r\natomic_dec(&sony_laptop_input.users);\r\nreturn error;\r\n}\r\nstatic void sony_laptop_remove_input(void)\r\n{\r\nstruct sony_laptop_keypress kp = { NULL };\r\nif (!atomic_dec_and_test(&sony_laptop_input.users))\r\nreturn;\r\ndel_timer_sync(&sony_laptop_input.release_key_timer);\r\nwhile (kfifo_out(&sony_laptop_input.fifo,\r\n(unsigned char *)&kp, sizeof(kp)) == sizeof(kp)) {\r\ninput_report_key(kp.dev, kp.key, 0);\r\ninput_sync(kp.dev);\r\n}\r\ninput_unregister_device(sony_laptop_input.key_dev);\r\nsony_laptop_input.key_dev = NULL;\r\nif (sony_laptop_input.jog_dev) {\r\ninput_unregister_device(sony_laptop_input.jog_dev);\r\nsony_laptop_input.jog_dev = NULL;\r\n}\r\nkfifo_free(&sony_laptop_input.fifo);\r\n}\r\nstatic int sony_pf_add(void)\r\n{\r\nint ret = 0;\r\nif (atomic_add_return(1, &sony_pf_users) > 1)\r\nreturn 0;\r\nret = platform_driver_register(&sony_pf_driver);\r\nif (ret)\r\ngoto out;\r\nsony_pf_device = platform_device_alloc("sony-laptop", -1);\r\nif (!sony_pf_device) {\r\nret = -ENOMEM;\r\ngoto out_platform_registered;\r\n}\r\nret = platform_device_add(sony_pf_device);\r\nif (ret)\r\ngoto out_platform_alloced;\r\nreturn 0;\r\nout_platform_alloced:\r\nplatform_device_put(sony_pf_device);\r\nsony_pf_device = NULL;\r\nout_platform_registered:\r\nplatform_driver_unregister(&sony_pf_driver);\r\nout:\r\natomic_dec(&sony_pf_users);\r\nreturn ret;\r\n}\r\nstatic void sony_pf_remove(void)\r\n{\r\nif (!atomic_dec_and_test(&sony_pf_users))\r\nreturn;\r\nplatform_device_unregister(sony_pf_device);\r\nplatform_driver_unregister(&sony_pf_driver);\r\n}\r\nstatic int acpi_callgetfunc(acpi_handle handle, char *name, int *result)\r\n{\r\nstruct acpi_buffer output;\r\nunion acpi_object out_obj;\r\nacpi_status status;\r\noutput.length = sizeof(out_obj);\r\noutput.pointer = &out_obj;\r\nstatus = acpi_evaluate_object(handle, name, NULL, &output);\r\nif ((status == AE_OK) && (out_obj.type == ACPI_TYPE_INTEGER)) {\r\n*result = out_obj.integer.value;\r\nreturn 0;\r\n}\r\npr_warn("acpi_callreadfunc failed\n");\r\nreturn -1;\r\n}\r\nstatic int acpi_callsetfunc(acpi_handle handle, char *name, int value,\r\nint *result)\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nstruct acpi_buffer output;\r\nunion acpi_object out_obj;\r\nacpi_status status;\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = value;\r\noutput.length = sizeof(out_obj);\r\noutput.pointer = &out_obj;\r\nstatus = acpi_evaluate_object(handle, name, &params, &output);\r\nif (status == AE_OK) {\r\nif (result != NULL) {\r\nif (out_obj.type != ACPI_TYPE_INTEGER) {\r\npr_warn("acpi_evaluate_object bad return type\n");\r\nreturn -1;\r\n}\r\n*result = out_obj.integer.value;\r\n}\r\nreturn 0;\r\n}\r\npr_warn("acpi_evaluate_object failed\n");\r\nreturn -1;\r\n}\r\nstatic ssize_t sony_nc_handles_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t len = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\r\nlen += snprintf(buffer + len, PAGE_SIZE - len, "0x%.4x ",\r\nhandles->cap[i]);\r\n}\r\nlen += snprintf(buffer + len, PAGE_SIZE - len, "\n");\r\nreturn len;\r\n}\r\nstatic int sony_nc_handles_setup(struct platform_device *pd)\r\n{\r\nint i;\r\nint result;\r\nhandles = kzalloc(sizeof(*handles), GFP_KERNEL);\r\nif (!handles)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\r\nif (!acpi_callsetfunc(sony_nc_acpi_handle,\r\n"SN00", i + 0x20, &result)) {\r\ndprintk("caching handle 0x%.4x (offset: 0x%.2x)\n",\r\nresult, i);\r\nhandles->cap[i] = result;\r\n}\r\n}\r\nif (debug) {\r\nsysfs_attr_init(&handles->devattr.attr);\r\nhandles->devattr.attr.name = "handles";\r\nhandles->devattr.attr.mode = S_IRUGO;\r\nhandles->devattr.show = sony_nc_handles_show;\r\nif (device_create_file(&pd->dev, &handles->devattr)) {\r\nkfree(handles);\r\nhandles = NULL;\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_nc_handles_cleanup(struct platform_device *pd)\r\n{\r\nif (handles) {\r\nif (debug)\r\ndevice_remove_file(&pd->dev, &handles->devattr);\r\nkfree(handles);\r\nhandles = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_find_snc_handle(int handle)\r\n{\r\nint i;\r\nif (!handles)\r\nreturn -1;\r\nfor (i = 0; i < 0x10; i++) {\r\nif (handles->cap[i] == handle) {\r\ndprintk("found handle 0x%.4x (offset: 0x%.2x)\n",\r\nhandle, i);\r\nreturn i;\r\n}\r\n}\r\ndprintk("handle 0x%.4x not found\n", handle);\r\nreturn -1;\r\n}\r\nstatic int sony_call_snc_handle(int handle, int argument, int *result)\r\n{\r\nint ret = 0;\r\nint offset = sony_find_snc_handle(handle);\r\nif (offset < 0)\r\nreturn -1;\r\nret = acpi_callsetfunc(sony_nc_acpi_handle, "SN07", offset | argument,\r\nresult);\r\ndprintk("called SN07 with 0x%.4x (result: 0x%.4x)\n", offset | argument,\r\n*result);\r\nreturn ret;\r\n}\r\nstatic int brightness_default_validate(const int direction, const int value)\r\n{\r\nswitch (direction) {\r\ncase SNC_VALIDATE_OUT:\r\nreturn value - 1;\r\ncase SNC_VALIDATE_IN:\r\nif (value >= 0 && value < SONY_MAX_BRIGHTNESS)\r\nreturn value + 1;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int boolean_validate(const int direction, const int value)\r\n{\r\nif (direction == SNC_VALIDATE_IN) {\r\nif (value != 0 && value != 1)\r\nreturn -EINVAL;\r\n}\r\nreturn value;\r\n}\r\nstatic ssize_t sony_nc_sysfs_show(struct device *dev, struct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nint value;\r\nstruct sony_nc_value *item =\r\ncontainer_of(attr, struct sony_nc_value, devattr);\r\nif (!*item->acpiget)\r\nreturn -EIO;\r\nif (acpi_callgetfunc(sony_nc_acpi_handle, *item->acpiget, &value) < 0)\r\nreturn -EIO;\r\nif (item->validate)\r\nvalue = item->validate(SNC_VALIDATE_OUT, value);\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic ssize_t sony_nc_sysfs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nint value;\r\nstruct sony_nc_value *item =\r\ncontainer_of(attr, struct sony_nc_value, devattr);\r\nif (!item->acpiset)\r\nreturn -EIO;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nvalue = simple_strtoul(buffer, NULL, 10);\r\nif (item->validate)\r\nvalue = item->validate(SNC_VALIDATE_IN, value);\r\nif (value < 0)\r\nreturn value;\r\nif (acpi_callsetfunc(sony_nc_acpi_handle, *item->acpiset, value, NULL) < 0)\r\nreturn -EIO;\r\nitem->value = value;\r\nitem->valid = 1;\r\nreturn count;\r\n}\r\nstatic int sony_backlight_update_status(struct backlight_device *bd)\r\n{\r\nreturn acpi_callsetfunc(sony_nc_acpi_handle, "SBRT",\r\nbd->props.brightness + 1, NULL);\r\n}\r\nstatic int sony_backlight_get_brightness(struct backlight_device *bd)\r\n{\r\nint value;\r\nif (acpi_callgetfunc(sony_nc_acpi_handle, "GBRT", &value))\r\nreturn 0;\r\nreturn value - 1;\r\n}\r\nstatic int sony_nc_get_brightness_ng(struct backlight_device *bd)\r\n{\r\nint result;\r\nstruct sony_backlight_props *sdev =\r\n(struct sony_backlight_props *)bl_get_data(bd);\r\nsony_call_snc_handle(sdev->handle, 0x0200, &result);\r\nreturn (result & 0xff) - sdev->offset;\r\n}\r\nstatic int sony_nc_update_status_ng(struct backlight_device *bd)\r\n{\r\nint value, result;\r\nstruct sony_backlight_props *sdev =\r\n(struct sony_backlight_props *)bl_get_data(bd);\r\nvalue = bd->props.brightness + sdev->offset;\r\nif (sony_call_snc_handle(sdev->handle, 0x0100 | (value << 16), &result))\r\nreturn -EIO;\r\nreturn value;\r\n}\r\nstatic void sony_nc_notify(struct acpi_device *device, u32 event)\r\n{\r\nu32 ev = event;\r\nif (ev >= 0x90) {\r\nint result;\r\nint key_handle = 0;\r\nev -= 0x90;\r\nif (sony_find_snc_handle(0x100) == ev)\r\nkey_handle = 0x100;\r\nif (sony_find_snc_handle(0x127) == ev)\r\nkey_handle = 0x127;\r\nif (key_handle) {\r\nstruct sony_nc_event *key_event;\r\nif (sony_call_snc_handle(key_handle, 0x200, &result)) {\r\ndprintk("sony_nc_notify, unable to decode"\r\n" event 0x%.2x 0x%.2x\n", key_handle,\r\nev);\r\nev = event;\r\n} else {\r\nev = result & 0xFF;\r\nif (key_handle == 0x100)\r\nkey_event = sony_100_events;\r\nelse\r\nkey_event = sony_127_events;\r\nfor (; key_event->data; key_event++) {\r\nif (key_event->data == ev) {\r\nev = key_event->event;\r\nbreak;\r\n}\r\n}\r\nif (!key_event->data)\r\npr_info("Unknown event: 0x%x 0x%x\n",\r\nkey_handle, ev);\r\nelse\r\nsony_laptop_report_input_event(ev);\r\n}\r\n} else if (sony_find_snc_handle(sony_rfkill_handle) == ev) {\r\nsony_nc_rfkill_update();\r\nreturn;\r\n}\r\n} else\r\nsony_laptop_report_input_event(ev);\r\ndprintk("sony_nc_notify, event: 0x%.2x\n", ev);\r\nacpi_bus_generate_proc_event(sony_nc_acpi_device, 1, ev);\r\n}\r\nstatic acpi_status sony_walk_callback(acpi_handle handle, u32 level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_device_info *info;\r\nif (ACPI_SUCCESS(acpi_get_object_info(handle, &info))) {\r\npr_warn("method: name: %4.4s, args %X\n",\r\n(char *)&info->name, info->param_count);\r\nkfree(info);\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic int sony_nc_function_setup(struct acpi_device *device)\r\n{\r\nint result;\r\nacpi_callsetfunc(sony_nc_acpi_handle, "SN02", 0xffff, &result);\r\nsony_call_snc_handle(0x0100, 0, &result);\r\nsony_call_snc_handle(0x0101, 0, &result);\r\nsony_call_snc_handle(0x0102, 0x100, &result);\r\nsony_call_snc_handle(0x0127, 0, &result);\r\nreturn 0;\r\n}\r\nstatic int sony_nc_resume(struct acpi_device *device)\r\n{\r\nstruct sony_nc_value *item;\r\nacpi_handle handle;\r\nfor (item = sony_nc_values; item->name; item++) {\r\nint ret;\r\nif (!item->valid)\r\ncontinue;\r\nret = acpi_callsetfunc(sony_nc_acpi_handle, *item->acpiset,\r\nitem->value, NULL);\r\nif (ret < 0) {\r\npr_err("%s: %d\n", __func__, ret);\r\nbreak;\r\n}\r\n}\r\nif (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "ECON",\r\n&handle))) {\r\nif (acpi_callsetfunc(sony_nc_acpi_handle, "ECON", 1, NULL))\r\ndprintk("ECON Method failed\n");\r\n}\r\nif (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "SN00",\r\n&handle))) {\r\ndprintk("Doing SNC setup\n");\r\nsony_nc_function_setup(device);\r\n}\r\nsony_nc_rfkill_update();\r\nsony_nc_kbd_backlight_resume();\r\nreturn 0;\r\n}\r\nstatic void sony_nc_rfkill_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < N_SONY_RFKILL; i++) {\r\nif (sony_rfkill_devices[i]) {\r\nrfkill_unregister(sony_rfkill_devices[i]);\r\nrfkill_destroy(sony_rfkill_devices[i]);\r\n}\r\n}\r\n}\r\nstatic int sony_nc_rfkill_set(void *data, bool blocked)\r\n{\r\nint result;\r\nint argument = sony_rfkill_address[(long) data] + 0x100;\r\nif (!blocked)\r\nargument |= 0xff0000;\r\nreturn sony_call_snc_handle(sony_rfkill_handle, argument, &result);\r\n}\r\nstatic int sony_nc_setup_rfkill(struct acpi_device *device,\r\nenum sony_nc_rfkill nc_type)\r\n{\r\nint err = 0;\r\nstruct rfkill *rfk;\r\nenum rfkill_type type;\r\nconst char *name;\r\nint result;\r\nbool hwblock;\r\nswitch (nc_type) {\r\ncase SONY_WIFI:\r\ntype = RFKILL_TYPE_WLAN;\r\nname = "sony-wifi";\r\nbreak;\r\ncase SONY_BLUETOOTH:\r\ntype = RFKILL_TYPE_BLUETOOTH;\r\nname = "sony-bluetooth";\r\nbreak;\r\ncase SONY_WWAN:\r\ntype = RFKILL_TYPE_WWAN;\r\nname = "sony-wwan";\r\nbreak;\r\ncase SONY_WIMAX:\r\ntype = RFKILL_TYPE_WIMAX;\r\nname = "sony-wimax";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrfk = rfkill_alloc(name, &device->dev, type,\r\n&sony_rfkill_ops, (void *)nc_type);\r\nif (!rfk)\r\nreturn -ENOMEM;\r\nsony_call_snc_handle(sony_rfkill_handle, 0x200, &result);\r\nhwblock = !(result & 0x1);\r\nrfkill_set_hw_state(rfk, hwblock);\r\nerr = rfkill_register(rfk);\r\nif (err) {\r\nrfkill_destroy(rfk);\r\nreturn err;\r\n}\r\nsony_rfkill_devices[nc_type] = rfk;\r\nreturn err;\r\n}\r\nstatic void sony_nc_rfkill_update(void)\r\n{\r\nenum sony_nc_rfkill i;\r\nint result;\r\nbool hwblock;\r\nsony_call_snc_handle(sony_rfkill_handle, 0x200, &result);\r\nhwblock = !(result & 0x1);\r\nfor (i = 0; i < N_SONY_RFKILL; i++) {\r\nint argument = sony_rfkill_address[i];\r\nif (!sony_rfkill_devices[i])\r\ncontinue;\r\nif (hwblock) {\r\nif (rfkill_set_hw_state(sony_rfkill_devices[i], true)) {\r\n}\r\ncontinue;\r\n}\r\nsony_call_snc_handle(sony_rfkill_handle, argument, &result);\r\nrfkill_set_states(sony_rfkill_devices[i],\r\n!(result & 0xf), false);\r\n}\r\n}\r\nstatic void sony_nc_rfkill_setup(struct acpi_device *device)\r\n{\r\nint offset;\r\nu8 dev_code, i;\r\nacpi_status status;\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nunion acpi_object *device_enum;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\noffset = sony_find_snc_handle(0x124);\r\nif (offset == -1) {\r\noffset = sony_find_snc_handle(0x135);\r\nif (offset == -1)\r\nreturn;\r\nelse\r\nsony_rfkill_handle = 0x135;\r\n} else\r\nsony_rfkill_handle = 0x124;\r\ndprintk("Found rkfill handle: 0x%.4x\n", sony_rfkill_handle);\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = offset;\r\nstatus = acpi_evaluate_object(sony_nc_acpi_handle, "SN06", &params,\r\n&buffer);\r\nif (ACPI_FAILURE(status)) {\r\ndprintk("Radio device enumeration failed\n");\r\nreturn;\r\n}\r\ndevice_enum = (union acpi_object *) buffer.pointer;\r\nif (!device_enum) {\r\npr_err("No SN06 return object\n");\r\ngoto out_no_enum;\r\n}\r\nif (device_enum->type != ACPI_TYPE_BUFFER) {\r\npr_err("Invalid SN06 return object 0x%.2x\n",\r\ndevice_enum->type);\r\ngoto out_no_enum;\r\n}\r\nfor (i = 0; i < device_enum->buffer.length; i++) {\r\ndev_code = *(device_enum->buffer.pointer + i);\r\nif (dev_code == 0xff)\r\nbreak;\r\ndprintk("Radio devices, looking at 0x%.2x\n", dev_code);\r\nif (dev_code == 0 && !sony_rfkill_devices[SONY_WIFI])\r\nsony_nc_setup_rfkill(device, SONY_WIFI);\r\nif (dev_code == 0x10 && !sony_rfkill_devices[SONY_BLUETOOTH])\r\nsony_nc_setup_rfkill(device, SONY_BLUETOOTH);\r\nif ((0xf0 & dev_code) == 0x20 &&\r\n!sony_rfkill_devices[SONY_WWAN])\r\nsony_nc_setup_rfkill(device, SONY_WWAN);\r\nif (dev_code == 0x30 && !sony_rfkill_devices[SONY_WIMAX])\r\nsony_nc_setup_rfkill(device, SONY_WIMAX);\r\n}\r\nout_no_enum:\r\nkfree(buffer.pointer);\r\nreturn;\r\n}\r\nstatic ssize_t __sony_nc_kbd_backlight_mode_set(u8 value)\r\n{\r\nint result;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(KBDBL_HANDLER,\r\n(value << 0x10) | SET_MODE, &result))\r\nreturn -EIO;\r\nsony_call_snc_handle(KBDBL_HANDLER, (value << 0x10) | SET_STATE,\r\n&result);\r\nkbdbl_handle->mode = value;\r\nreturn 0;\r\n}\r\nstatic ssize_t sony_nc_kbd_backlight_mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nint ret = 0;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (strict_strtoul(buffer, 10, &value))\r\nreturn -EINVAL;\r\nret = __sony_nc_kbd_backlight_mode_set(value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_kbd_backlight_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count = 0;\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", kbdbl_handle->mode);\r\nreturn count;\r\n}\r\nstatic int __sony_nc_kbd_backlight_timeout_set(u8 value)\r\n{\r\nint result;\r\nif (value > 3)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(KBDBL_HANDLER,\r\n(value << 0x10) | SET_TIMEOUT, &result))\r\nreturn -EIO;\r\nkbdbl_handle->timeout = value;\r\nreturn 0;\r\n}\r\nstatic ssize_t sony_nc_kbd_backlight_timeout_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nint ret = 0;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (strict_strtoul(buffer, 10, &value))\r\nreturn -EINVAL;\r\nret = __sony_nc_kbd_backlight_timeout_set(value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_kbd_backlight_timeout_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count = 0;\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", kbdbl_handle->timeout);\r\nreturn count;\r\n}\r\nstatic int sony_nc_kbd_backlight_setup(struct platform_device *pd)\r\n{\r\nint result;\r\nif (sony_call_snc_handle(KBDBL_HANDLER, KBDBL_PRESENT, &result))\r\nreturn 0;\r\nif (!(result & 0x02))\r\nreturn 0;\r\nkbdbl_handle = kzalloc(sizeof(*kbdbl_handle), GFP_KERNEL);\r\nif (!kbdbl_handle)\r\nreturn -ENOMEM;\r\nsysfs_attr_init(&kbdbl_handle->mode_attr.attr);\r\nkbdbl_handle->mode_attr.attr.name = "kbd_backlight";\r\nkbdbl_handle->mode_attr.attr.mode = S_IRUGO | S_IWUSR;\r\nkbdbl_handle->mode_attr.show = sony_nc_kbd_backlight_mode_show;\r\nkbdbl_handle->mode_attr.store = sony_nc_kbd_backlight_mode_store;\r\nsysfs_attr_init(&kbdbl_handle->timeout_attr.attr);\r\nkbdbl_handle->timeout_attr.attr.name = "kbd_backlight_timeout";\r\nkbdbl_handle->timeout_attr.attr.mode = S_IRUGO | S_IWUSR;\r\nkbdbl_handle->timeout_attr.show = sony_nc_kbd_backlight_timeout_show;\r\nkbdbl_handle->timeout_attr.store = sony_nc_kbd_backlight_timeout_store;\r\nif (device_create_file(&pd->dev, &kbdbl_handle->mode_attr))\r\ngoto outkzalloc;\r\nif (device_create_file(&pd->dev, &kbdbl_handle->timeout_attr))\r\ngoto outmode;\r\n__sony_nc_kbd_backlight_mode_set(kbd_backlight);\r\n__sony_nc_kbd_backlight_timeout_set(kbd_backlight_timeout);\r\nreturn 0;\r\noutmode:\r\ndevice_remove_file(&pd->dev, &kbdbl_handle->mode_attr);\r\noutkzalloc:\r\nkfree(kbdbl_handle);\r\nkbdbl_handle = NULL;\r\nreturn -1;\r\n}\r\nstatic int sony_nc_kbd_backlight_cleanup(struct platform_device *pd)\r\n{\r\nif (kbdbl_handle) {\r\nint result;\r\ndevice_remove_file(&pd->dev, &kbdbl_handle->mode_attr);\r\ndevice_remove_file(&pd->dev, &kbdbl_handle->timeout_attr);\r\nsony_call_snc_handle(KBDBL_HANDLER, 0x1000 | SET_MODE, &result);\r\nsony_call_snc_handle(KBDBL_HANDLER, SET_TIMEOUT, &result);\r\nkfree(kbdbl_handle);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_nc_kbd_backlight_resume(void)\r\n{\r\nint ignore = 0;\r\nif (!kbdbl_handle)\r\nreturn;\r\nif (kbdbl_handle->mode == 0)\r\nsony_call_snc_handle(KBDBL_HANDLER, SET_MODE, &ignore);\r\nif (kbdbl_handle->timeout != 0)\r\nsony_call_snc_handle(KBDBL_HANDLER,\r\n(kbdbl_handle->timeout << 0x10) | SET_TIMEOUT,\r\n&ignore);\r\n}\r\nstatic void sony_nc_backlight_ng_read_limits(int handle,\r\nstruct sony_backlight_props *props)\r\n{\r\nint offset;\r\nacpi_status status;\r\nu8 brlvl, i;\r\nu8 min = 0xff, max = 0x00;\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nunion acpi_object *lvl_enum;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nprops->handle = handle;\r\nprops->offset = 0;\r\nprops->maxlvl = 0xff;\r\noffset = sony_find_snc_handle(handle);\r\nif (offset < 0)\r\nreturn;\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = offset;\r\nstatus = acpi_evaluate_object(sony_nc_acpi_handle, "SN06", &params,\r\n&buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn;\r\nlvl_enum = (union acpi_object *) buffer.pointer;\r\nif (!lvl_enum) {\r\npr_err("No SN06 return object.");\r\nreturn;\r\n}\r\nif (lvl_enum->type != ACPI_TYPE_BUFFER) {\r\npr_err("Invalid SN06 return object 0x%.2x\n",\r\nlvl_enum->type);\r\ngoto out_invalid;\r\n}\r\nfor (i = 0; i < 9 && i < lvl_enum->buffer.length; i++) {\r\nbrlvl = *(lvl_enum->buffer.pointer + i);\r\ndprintk("Brightness level: %d\n", brlvl);\r\nif (!brlvl)\r\nbreak;\r\nif (brlvl > max)\r\nmax = brlvl;\r\nif (brlvl < min)\r\nmin = brlvl;\r\n}\r\nprops->offset = min;\r\nprops->maxlvl = max;\r\ndprintk("Brightness levels: min=%d max=%d\n", props->offset,\r\nprops->maxlvl);\r\nout_invalid:\r\nkfree(buffer.pointer);\r\nreturn;\r\n}\r\nstatic void sony_nc_backlight_setup(void)\r\n{\r\nacpi_handle unused;\r\nint max_brightness = 0;\r\nconst struct backlight_ops *ops = NULL;\r\nstruct backlight_properties props;\r\nif (sony_find_snc_handle(0x12f) != -1) {\r\nops = &sony_backlight_ng_ops;\r\nsony_nc_backlight_ng_read_limits(0x12f, &sony_bl_props);\r\nmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\r\n} else if (sony_find_snc_handle(0x137) != -1) {\r\nops = &sony_backlight_ng_ops;\r\nsony_nc_backlight_ng_read_limits(0x137, &sony_bl_props);\r\nmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\r\n} else if (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "GBRT",\r\n&unused))) {\r\nops = &sony_backlight_ops;\r\nmax_brightness = SONY_MAX_BRIGHTNESS - 1;\r\n} else\r\nreturn;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = max_brightness;\r\nsony_bl_props.dev = backlight_device_register("sony", NULL,\r\n&sony_bl_props,\r\nops, &props);\r\nif (IS_ERR(sony_bl_props.dev)) {\r\npr_warn("unable to register backlight device\n");\r\nsony_bl_props.dev = NULL;\r\n} else\r\nsony_bl_props.dev->props.brightness =\r\nops->get_brightness(sony_bl_props.dev);\r\n}\r\nstatic void sony_nc_backlight_cleanup(void)\r\n{\r\nif (sony_bl_props.dev)\r\nbacklight_device_unregister(sony_bl_props.dev);\r\n}\r\nstatic int sony_nc_add(struct acpi_device *device)\r\n{\r\nacpi_status status;\r\nint result = 0;\r\nacpi_handle handle;\r\nstruct sony_nc_value *item;\r\npr_info("%s v%s\n", SONY_NC_DRIVER_NAME, SONY_LAPTOP_DRIVER_VERSION);\r\nsony_nc_acpi_device = device;\r\nstrcpy(acpi_device_class(device), "sony/hotkey");\r\nsony_nc_acpi_handle = device->handle;\r\nresult = acpi_bus_get_status(device);\r\nif (!result && !device->status.present) {\r\ndprintk("Device not present\n");\r\nresult = -ENODEV;\r\ngoto outwalk;\r\n}\r\nresult = sony_pf_add();\r\nif (result)\r\ngoto outpresent;\r\nif (debug) {\r\nstatus = acpi_walk_namespace(ACPI_TYPE_METHOD,\r\nsony_nc_acpi_handle, 1, sony_walk_callback,\r\nNULL, NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_warn("unable to walk acpi resources\n");\r\nresult = -ENODEV;\r\ngoto outpresent;\r\n}\r\n}\r\nif (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "ECON",\r\n&handle))) {\r\nif (acpi_callsetfunc(sony_nc_acpi_handle, "ECON", 1, NULL))\r\ndprintk("ECON Method failed\n");\r\n}\r\nif (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "SN00",\r\n&handle))) {\r\ndprintk("Doing SNC setup\n");\r\nresult = sony_nc_handles_setup(sony_pf_device);\r\nif (result)\r\ngoto outpresent;\r\nresult = sony_nc_kbd_backlight_setup(sony_pf_device);\r\nif (result)\r\ngoto outsnc;\r\nsony_nc_function_setup(device);\r\nsony_nc_rfkill_setup(device);\r\n}\r\nresult = sony_laptop_setup_input(device);\r\nif (result) {\r\npr_err("Unable to create input devices\n");\r\ngoto outkbdbacklight;\r\n}\r\nif (acpi_video_backlight_support()) {\r\npr_info("brightness ignored, must be controlled by ACPI video driver\n");\r\n} else {\r\nsony_nc_backlight_setup();\r\n}\r\nfor (item = sony_nc_values; item->name; ++item) {\r\nif (!debug && item->debug)\r\ncontinue;\r\nfor (; item->acpiget && *item->acpiget; ++item->acpiget) {\r\nif (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle,\r\n*item->acpiget,\r\n&handle))) {\r\ndprintk("Found %s getter: %s\n",\r\nitem->name, *item->acpiget);\r\nitem->devattr.attr.mode |= S_IRUGO;\r\nbreak;\r\n}\r\n}\r\nfor (; item->acpiset && *item->acpiset; ++item->acpiset) {\r\nif (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle,\r\n*item->acpiset,\r\n&handle))) {\r\ndprintk("Found %s setter: %s\n",\r\nitem->name, *item->acpiset);\r\nitem->devattr.attr.mode |= S_IWUSR;\r\nbreak;\r\n}\r\n}\r\nif (item->devattr.attr.mode != 0) {\r\nresult =\r\ndevice_create_file(&sony_pf_device->dev,\r\n&item->devattr);\r\nif (result)\r\ngoto out_sysfs;\r\n}\r\n}\r\nreturn 0;\r\nout_sysfs:\r\nfor (item = sony_nc_values; item->name; ++item) {\r\ndevice_remove_file(&sony_pf_device->dev, &item->devattr);\r\n}\r\nsony_nc_backlight_cleanup();\r\nsony_laptop_remove_input();\r\noutkbdbacklight:\r\nsony_nc_kbd_backlight_cleanup(sony_pf_device);\r\noutsnc:\r\nsony_nc_handles_cleanup(sony_pf_device);\r\noutpresent:\r\nsony_pf_remove();\r\noutwalk:\r\nsony_nc_rfkill_cleanup();\r\nreturn result;\r\n}\r\nstatic int sony_nc_remove(struct acpi_device *device, int type)\r\n{\r\nstruct sony_nc_value *item;\r\nsony_nc_backlight_cleanup();\r\nsony_nc_acpi_device = NULL;\r\nfor (item = sony_nc_values; item->name; ++item) {\r\ndevice_remove_file(&sony_pf_device->dev, &item->devattr);\r\n}\r\nsony_nc_kbd_backlight_cleanup(sony_pf_device);\r\nsony_nc_handles_cleanup(sony_pf_device);\r\nsony_pf_remove();\r\nsony_laptop_remove_input();\r\nsony_nc_rfkill_cleanup();\r\ndprintk(SONY_NC_DRIVER_NAME " removed.\n");\r\nreturn 0;\r\n}\r\nstatic u8 sony_pic_call1(u8 dev)\r\n{\r\nu8 v1, v2;\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\r\nITERATIONS_LONG);\r\noutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\r\nv1 = inb_p(spic_dev.cur_ioport->io1.minimum + 4);\r\nv2 = inb_p(spic_dev.cur_ioport->io1.minimum);\r\ndprintk("sony_pic_call1(0x%.2x): 0x%.4x\n", dev, (v2 << 8) | v1);\r\nreturn v2;\r\n}\r\nstatic u8 sony_pic_call2(u8 dev, u8 fn)\r\n{\r\nu8 v1;\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\r\nITERATIONS_LONG);\r\noutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\r\nITERATIONS_LONG);\r\noutb(fn, spic_dev.cur_ioport->io1.minimum);\r\nv1 = inb_p(spic_dev.cur_ioport->io1.minimum);\r\ndprintk("sony_pic_call2(0x%.2x - 0x%.2x): 0x%.4x\n", dev, fn, v1);\r\nreturn v1;\r\n}\r\nstatic u8 sony_pic_call3(u8 dev, u8 fn, u8 v)\r\n{\r\nu8 v1;\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\r\noutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\r\noutb(fn, spic_dev.cur_ioport->io1.minimum);\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\r\noutb(v, spic_dev.cur_ioport->io1.minimum);\r\nv1 = inb_p(spic_dev.cur_ioport->io1.minimum);\r\ndprintk("sony_pic_call3(0x%.2x - 0x%.2x - 0x%.2x): 0x%.4x\n",\r\ndev, fn, v, v1);\r\nreturn v1;\r\n}\r\nstatic int type3_handle_irq(const u8 data_mask, const u8 ev)\r\n{\r\nif (data_mask == 0x31) {\r\nif (ev == 0x5c || ev == 0x5f)\r\nsony_pic_call1(0xA0);\r\nelse if (ev == 0x61)\r\nsony_pic_call1(0xB3);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void sony_pic_detect_device_type(struct sony_pic_dev *dev)\r\n{\r\nstruct pci_dev *pcidev;\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB_3, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE1;\r\ndev->evport_offset = SONYPI_TYPE1_OFFSET;\r\ndev->event_types = type1_events;\r\ngoto out;\r\n}\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH6_1, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE2;\r\ndev->evport_offset = SONYPI_TYPE2_OFFSET;\r\ndev->event_types = type2_events;\r\ngoto out;\r\n}\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH7_1, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE3;\r\ndev->handle_irq = type3_handle_irq;\r\ndev->evport_offset = SONYPI_TYPE3_OFFSET;\r\ndev->event_types = type3_events;\r\ngoto out;\r\n}\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH8_4, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE3;\r\ndev->handle_irq = type3_handle_irq;\r\ndev->evport_offset = SONYPI_TYPE3_OFFSET;\r\ndev->event_types = type3_events;\r\ngoto out;\r\n}\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH9_1, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE3;\r\ndev->handle_irq = type3_handle_irq;\r\ndev->evport_offset = SONYPI_TYPE3_OFFSET;\r\ndev->event_types = type3_events;\r\ngoto out;\r\n}\r\ndev->model = SONYPI_DEVICE_TYPE2;\r\ndev->evport_offset = SONYPI_TYPE2_OFFSET;\r\ndev->event_types = type2_events;\r\nout:\r\nif (pcidev)\r\npci_dev_put(pcidev);\r\npr_info("detected Type%d model\n",\r\ndev->model == SONYPI_DEVICE_TYPE1 ? 1 :\r\ndev->model == SONYPI_DEVICE_TYPE2 ? 2 : 3);\r\n}\r\nstatic int __sony_pic_camera_ready(void)\r\n{\r\nu8 v;\r\nv = sony_pic_call2(0x8f, SONYPI_CAMERA_STATUS);\r\nreturn (v != 0xff && (v & SONYPI_CAMERA_STATUS_READY));\r\n}\r\nstatic int __sony_pic_camera_off(void)\r\n{\r\nif (!camera) {\r\npr_warn("camera control not enabled\n");\r\nreturn -ENODEV;\r\n}\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE,\r\nSONYPI_CAMERA_MUTE_MASK),\r\nITERATIONS_SHORT);\r\nif (spic_dev.camera_power) {\r\nsony_pic_call2(0x91, 0);\r\nspic_dev.camera_power = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __sony_pic_camera_on(void)\r\n{\r\nint i, j, x;\r\nif (!camera) {\r\npr_warn("camera control not enabled\n");\r\nreturn -ENODEV;\r\n}\r\nif (spic_dev.camera_power)\r\nreturn 0;\r\nfor (j = 5; j > 0; j--) {\r\nfor (x = 0; x < 100 && sony_pic_call2(0x91, 0x1); x++)\r\nmsleep(10);\r\nsony_pic_call1(0x93);\r\nfor (i = 400; i > 0; i--) {\r\nif (__sony_pic_camera_ready())\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (i)\r\nbreak;\r\n}\r\nif (j == 0) {\r\npr_warn("failed to power on camera\n");\r\nreturn -ENODEV;\r\n}\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTROL,\r\n0x5a),\r\nITERATIONS_SHORT);\r\nspic_dev.camera_power = 1;\r\nreturn 0;\r\n}\r\nint sony_pic_camera_command(int command, u8 value)\r\n{\r\nif (!camera)\r\nreturn -EIO;\r\nmutex_lock(&spic_dev.lock);\r\nswitch (command) {\r\ncase SONY_PIC_COMMAND_SETCAMERA:\r\nif (value)\r\n__sony_pic_camera_on();\r\nelse\r\n__sony_pic_camera_off();\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERABRIGHTNESS:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_BRIGHTNESS, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERACONTRAST:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTRAST, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERAHUE:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_HUE, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERACOLOR:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_COLOR, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERASHARPNESS:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_SHARPNESS, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERAPICTURE:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERAAGC:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_AGC, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ndefault:\r\npr_err("sony_pic_camera_command invalid: %d\n", command);\r\nbreak;\r\n}\r\nmutex_unlock(&spic_dev.lock);\r\nreturn 0;\r\n}\r\nstatic void __sony_pic_set_wwanpower(u8 state)\r\n{\r\nstate = !!state;\r\nif (spic_dev.wwan_power == state)\r\nreturn;\r\nsony_pic_call2(0xB0, state);\r\nsony_pic_call1(0x82);\r\nspic_dev.wwan_power = state;\r\n}\r\nstatic ssize_t sony_pic_wwanpower_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nvalue = simple_strtoul(buffer, NULL, 10);\r\nmutex_lock(&spic_dev.lock);\r\n__sony_pic_set_wwanpower(value);\r\nmutex_unlock(&spic_dev.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sony_pic_wwanpower_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count;\r\nmutex_lock(&spic_dev.lock);\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", spic_dev.wwan_power);\r\nmutex_unlock(&spic_dev.lock);\r\nreturn count;\r\n}\r\nstatic void __sony_pic_set_bluetoothpower(u8 state)\r\n{\r\nstate = !!state;\r\nif (spic_dev.bluetooth_power == state)\r\nreturn;\r\nsony_pic_call2(0x96, state);\r\nsony_pic_call1(0x82);\r\nspic_dev.bluetooth_power = state;\r\n}\r\nstatic ssize_t sony_pic_bluetoothpower_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nvalue = simple_strtoul(buffer, NULL, 10);\r\nmutex_lock(&spic_dev.lock);\r\n__sony_pic_set_bluetoothpower(value);\r\nmutex_unlock(&spic_dev.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sony_pic_bluetoothpower_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count = 0;\r\nmutex_lock(&spic_dev.lock);\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", spic_dev.bluetooth_power);\r\nmutex_unlock(&spic_dev.lock);\r\nreturn count;\r\n}\r\nstatic int sony_pic_set_fanspeed(unsigned long value)\r\n{\r\nreturn ec_write(SONY_PIC_FAN0_STATUS, value);\r\n}\r\nstatic int sony_pic_get_fanspeed(u8 *value)\r\n{\r\nreturn ec_read(SONY_PIC_FAN0_STATUS, value);\r\n}\r\nstatic ssize_t sony_pic_fanspeed_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nvalue = simple_strtoul(buffer, NULL, 10);\r\nif (sony_pic_set_fanspeed(value))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_pic_fanspeed_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nu8 value = 0;\r\nif (sony_pic_get_fanspeed(&value))\r\nreturn -EIO;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic int sonypi_misc_fasync(int fd, struct file *filp, int on)\r\n{\r\nreturn fasync_helper(fd, filp, on, &sonypi_compat.fifo_async);\r\n}\r\nstatic int sonypi_misc_release(struct inode *inode, struct file *file)\r\n{\r\natomic_dec(&sonypi_compat.open_count);\r\nreturn 0;\r\n}\r\nstatic int sonypi_misc_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sonypi_compat.fifo_lock, flags);\r\nif (atomic_inc_return(&sonypi_compat.open_count) == 1)\r\nkfifo_reset(&sonypi_compat.fifo);\r\nspin_unlock_irqrestore(&sonypi_compat.fifo_lock, flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t sonypi_misc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nssize_t ret;\r\nunsigned char c;\r\nif ((kfifo_len(&sonypi_compat.fifo) == 0) &&\r\n(file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(sonypi_compat.fifo_proc_list,\r\nkfifo_len(&sonypi_compat.fifo) != 0);\r\nif (ret)\r\nreturn ret;\r\nwhile (ret < count &&\r\n(kfifo_out_locked(&sonypi_compat.fifo, &c, sizeof(c),\r\n&sonypi_compat.fifo_lock) == sizeof(c))) {\r\nif (put_user(c, buf++))\r\nreturn -EFAULT;\r\nret++;\r\n}\r\nif (ret > 0) {\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\ninode->i_atime = current_fs_time(inode->i_sb);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int sonypi_misc_poll(struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &sonypi_compat.fifo_proc_list, wait);\r\nif (kfifo_len(&sonypi_compat.fifo))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int ec_read16(u8 addr, u16 *value)\r\n{\r\nu8 val_lb, val_hb;\r\nif (ec_read(addr, &val_lb))\r\nreturn -1;\r\nif (ec_read(addr + 1, &val_hb))\r\nreturn -1;\r\n*value = val_lb | (val_hb << 8);\r\nreturn 0;\r\n}\r\nstatic long sonypi_misc_ioctl(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret = 0;\r\nvoid __user *argp = (void __user *)arg;\r\nu8 val8;\r\nu16 val16;\r\nint value;\r\nmutex_lock(&spic_dev.lock);\r\nswitch (cmd) {\r\ncase SONYPI_IOCGBRT:\r\nif (sony_bl_props.dev == NULL) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (acpi_callgetfunc(sony_nc_acpi_handle, "GBRT", &value)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nval8 = ((value & 0xff) - 1) << 5;\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSBRT:\r\nif (sony_bl_props.dev == NULL) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (acpi_callsetfunc(sony_nc_acpi_handle, "SBRT",\r\n(val8 >> 5) + 1, NULL)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nsony_bl_props.dev->props.brightness =\r\nsony_backlight_get_brightness(sony_bl_props.dev);\r\nbreak;\r\ncase SONYPI_IOCGBAT1CAP:\r\nif (ec_read16(SONYPI_BAT1_FULL, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT1REM:\r\nif (ec_read16(SONYPI_BAT1_LEFT, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT2CAP:\r\nif (ec_read16(SONYPI_BAT2_FULL, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT2REM:\r\nif (ec_read16(SONYPI_BAT2_LEFT, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBATFLAGS:\r\nif (ec_read(SONYPI_BAT_FLAGS, &val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nval8 &= 0x07;\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBLUE:\r\nval8 = spic_dev.bluetooth_power;\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSBLUE:\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n__sony_pic_set_bluetoothpower(val8);\r\nbreak;\r\ncase SONYPI_IOCGFAN:\r\nif (sony_pic_get_fanspeed(&val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSFAN:\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (sony_pic_set_fanspeed(val8))\r\nret = -EIO;\r\nbreak;\r\ncase SONYPI_IOCGTEMP:\r\nif (ec_read(SONYPI_TEMP_STATUS, &val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&spic_dev.lock);\r\nreturn ret;\r\n}\r\nstatic void sonypi_compat_report_event(u8 event)\r\n{\r\nkfifo_in_locked(&sonypi_compat.fifo, (unsigned char *)&event,\r\nsizeof(event), &sonypi_compat.fifo_lock);\r\nkill_fasync(&sonypi_compat.fifo_async, SIGIO, POLL_IN);\r\nwake_up_interruptible(&sonypi_compat.fifo_proc_list);\r\n}\r\nstatic int sonypi_compat_init(void)\r\n{\r\nint error;\r\nspin_lock_init(&sonypi_compat.fifo_lock);\r\nerror =\r\nkfifo_alloc(&sonypi_compat.fifo, SONY_LAPTOP_BUF_SIZE, GFP_KERNEL);\r\nif (error) {\r\npr_err("kfifo_alloc failed\n");\r\nreturn error;\r\n}\r\ninit_waitqueue_head(&sonypi_compat.fifo_proc_list);\r\nif (minor != -1)\r\nsonypi_misc_device.minor = minor;\r\nerror = misc_register(&sonypi_misc_device);\r\nif (error) {\r\npr_err("misc_register failed\n");\r\ngoto err_free_kfifo;\r\n}\r\nif (minor == -1)\r\npr_info("device allocated minor is %d\n",\r\nsonypi_misc_device.minor);\r\nreturn 0;\r\nerr_free_kfifo:\r\nkfifo_free(&sonypi_compat.fifo);\r\nreturn error;\r\n}\r\nstatic void sonypi_compat_exit(void)\r\n{\r\nmisc_deregister(&sonypi_misc_device);\r\nkfifo_free(&sonypi_compat.fifo);\r\n}\r\nstatic int sonypi_compat_init(void) { return 0; }\r\nstatic void sonypi_compat_exit(void) { }\r\nstatic void sonypi_compat_report_event(u8 event) { }\r\nstatic acpi_status\r\nsony_pic_read_possible_resource(struct acpi_resource *resource, void *context)\r\n{\r\nu32 i;\r\nstruct sony_pic_dev *dev = (struct sony_pic_dev *)context;\r\nswitch (resource->type) {\r\ncase ACPI_RESOURCE_TYPE_START_DEPENDENT:\r\n{\r\nstruct sony_pic_ioport *ioport = kzalloc(sizeof(*ioport), GFP_KERNEL);\r\nif (!ioport)\r\nreturn AE_ERROR;\r\nlist_add(&ioport->list, &dev->ioports);\r\nreturn AE_OK;\r\n}\r\ncase ACPI_RESOURCE_TYPE_END_DEPENDENT:\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\n{\r\nstruct acpi_resource_irq *p = &resource->data.irq;\r\nstruct sony_pic_irq *interrupt = NULL;\r\nif (!p || !p->interrupt_count) {\r\ndprintk("Blank IRQ resource\n");\r\nreturn AE_OK;\r\n}\r\nfor (i = 0; i < p->interrupt_count; i++) {\r\nif (!p->interrupts[i]) {\r\npr_warn("Invalid IRQ %d\n",\r\np->interrupts[i]);\r\ncontinue;\r\n}\r\ninterrupt = kzalloc(sizeof(*interrupt),\r\nGFP_KERNEL);\r\nif (!interrupt)\r\nreturn AE_ERROR;\r\nlist_add(&interrupt->list, &dev->interrupts);\r\ninterrupt->irq.triggering = p->triggering;\r\ninterrupt->irq.polarity = p->polarity;\r\ninterrupt->irq.sharable = p->sharable;\r\ninterrupt->irq.interrupt_count = 1;\r\ninterrupt->irq.interrupts[0] = p->interrupts[i];\r\n}\r\nreturn AE_OK;\r\n}\r\ncase ACPI_RESOURCE_TYPE_IO:\r\n{\r\nstruct acpi_resource_io *io = &resource->data.io;\r\nstruct sony_pic_ioport *ioport =\r\nlist_first_entry(&dev->ioports, struct sony_pic_ioport, list);\r\nif (!io) {\r\ndprintk("Blank IO resource\n");\r\nreturn AE_OK;\r\n}\r\nif (!ioport->io1.minimum) {\r\nmemcpy(&ioport->io1, io, sizeof(*io));\r\ndprintk("IO1 at 0x%.4x (0x%.2x)\n", ioport->io1.minimum,\r\nioport->io1.address_length);\r\n}\r\nelse if (!ioport->io2.minimum) {\r\nmemcpy(&ioport->io2, io, sizeof(*io));\r\ndprintk("IO2 at 0x%.4x (0x%.2x)\n", ioport->io2.minimum,\r\nioport->io2.address_length);\r\n}\r\nelse {\r\npr_err("Unknown SPIC Type, more than 2 IO Ports\n");\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\ndefault:\r\ndprintk("Resource %d isn't an IRQ nor an IO port\n",\r\nresource->type);\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\nreturn AE_OK;\r\n}\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int sony_pic_possible_resources(struct acpi_device *device)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nif (!device)\r\nreturn -EINVAL;\r\ndprintk("Evaluating _STA\n");\r\nresult = acpi_bus_get_status(device);\r\nif (result) {\r\npr_warn("Unable to read status\n");\r\ngoto end;\r\n}\r\nif (!device->status.enabled)\r\ndprintk("Device disabled\n");\r\nelse\r\ndprintk("Device enabled\n");\r\ndprintk("Evaluating %s\n", METHOD_NAME__PRS);\r\nstatus = acpi_walk_resources(device->handle, METHOD_NAME__PRS,\r\nsony_pic_read_possible_resource, &spic_dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_warn("Failure evaluating %s\n", METHOD_NAME__PRS);\r\nresult = -ENODEV;\r\n}\r\nend:\r\nreturn result;\r\n}\r\nstatic int sony_pic_disable(struct acpi_device *device)\r\n{\r\nacpi_status ret = acpi_evaluate_object(device->handle, "_DIS", NULL,\r\nNULL);\r\nif (ACPI_FAILURE(ret) && ret != AE_NOT_FOUND)\r\nreturn -ENXIO;\r\ndprintk("Device disabled\n");\r\nreturn 0;\r\n}\r\nstatic int sony_pic_enable(struct acpi_device *device,\r\nstruct sony_pic_ioport *ioport, struct sony_pic_irq *irq)\r\n{\r\nacpi_status status;\r\nint result = 0;\r\nstruct {\r\nstruct acpi_resource res1;\r\nstruct acpi_resource res2;\r\nstruct acpi_resource res3;\r\nstruct acpi_resource res4;\r\n} *resource;\r\nstruct acpi_buffer buffer = { 0, NULL };\r\nif (!ioport || !irq)\r\nreturn -EINVAL;\r\nresource = kzalloc(sizeof(*resource) + 1, GFP_KERNEL);\r\nif (!resource)\r\nreturn -ENOMEM;\r\nbuffer.length = sizeof(*resource) + 1;\r\nbuffer.pointer = resource;\r\nif (spic_dev.model == SONYPI_DEVICE_TYPE1) {\r\nresource->res1.type = ACPI_RESOURCE_TYPE_IO;\r\nresource->res1.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res1.data.io, &ioport->io1,\r\nsizeof(struct acpi_resource_io));\r\nresource->res2.type = ACPI_RESOURCE_TYPE_IO;\r\nresource->res2.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res2.data.io, &ioport->io2,\r\nsizeof(struct acpi_resource_io));\r\nresource->res3.type = ACPI_RESOURCE_TYPE_IRQ;\r\nresource->res3.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res3.data.irq, &irq->irq,\r\nsizeof(struct acpi_resource_irq));\r\nresource->res3.data.irq.sharable = ACPI_SHARED;\r\nresource->res4.type = ACPI_RESOURCE_TYPE_END_TAG;\r\n}\r\nelse {\r\nresource->res1.type = ACPI_RESOURCE_TYPE_IO;\r\nresource->res1.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res1.data.io, &ioport->io1,\r\nsizeof(struct acpi_resource_io));\r\nresource->res2.type = ACPI_RESOURCE_TYPE_IRQ;\r\nresource->res2.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res2.data.irq, &irq->irq,\r\nsizeof(struct acpi_resource_irq));\r\nresource->res2.data.irq.sharable = ACPI_SHARED;\r\nresource->res3.type = ACPI_RESOURCE_TYPE_END_TAG;\r\n}\r\ndprintk("Evaluating _SRS\n");\r\nstatus = acpi_set_current_resources(device->handle, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Error evaluating _SRS\n");\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nsony_pic_call1(0x82);\r\nsony_pic_call2(0x81, 0xff);\r\nsony_pic_call1(compat ? 0x92 : 0x82);\r\nend:\r\nkfree(resource);\r\nreturn result;\r\n}\r\nstatic irqreturn_t sony_pic_irq(int irq, void *dev_id)\r\n{\r\nint i, j;\r\nu8 ev = 0;\r\nu8 data_mask = 0;\r\nu8 device_event = 0;\r\nstruct sony_pic_dev *dev = (struct sony_pic_dev *) dev_id;\r\nev = inb_p(dev->cur_ioport->io1.minimum);\r\nif (dev->cur_ioport->io2.minimum)\r\ndata_mask = inb_p(dev->cur_ioport->io2.minimum);\r\nelse\r\ndata_mask = inb_p(dev->cur_ioport->io1.minimum +\r\ndev->evport_offset);\r\ndprintk("event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\n",\r\nev, data_mask, dev->cur_ioport->io1.minimum,\r\ndev->evport_offset);\r\nif (ev == 0x00 || ev == 0xff)\r\nreturn IRQ_HANDLED;\r\nfor (i = 0; dev->event_types[i].mask; i++) {\r\nif ((data_mask & dev->event_types[i].data) !=\r\ndev->event_types[i].data)\r\ncontinue;\r\nif (!(mask & dev->event_types[i].mask))\r\ncontinue;\r\nfor (j = 0; dev->event_types[i].events[j].event; j++) {\r\nif (ev == dev->event_types[i].events[j].data) {\r\ndevice_event =\r\ndev->event_types[i].events[j].event;\r\nif (!device_event)\r\nreturn IRQ_HANDLED;\r\ngoto found;\r\n}\r\n}\r\n}\r\nif (dev->handle_irq && dev->handle_irq(data_mask, ev) == 0)\r\nreturn IRQ_HANDLED;\r\ndprintk("unknown event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\n",\r\nev, data_mask, dev->cur_ioport->io1.minimum,\r\ndev->evport_offset);\r\nreturn IRQ_HANDLED;\r\nfound:\r\nsony_laptop_report_input_event(device_event);\r\nacpi_bus_generate_proc_event(dev->acpi_dev, 1, device_event);\r\nsonypi_compat_report_event(device_event);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sony_pic_remove(struct acpi_device *device, int type)\r\n{\r\nstruct sony_pic_ioport *io, *tmp_io;\r\nstruct sony_pic_irq *irq, *tmp_irq;\r\nif (sony_pic_disable(device)) {\r\npr_err("Couldn't disable device\n");\r\nreturn -ENXIO;\r\n}\r\nfree_irq(spic_dev.cur_irq->irq.interrupts[0], &spic_dev);\r\nrelease_region(spic_dev.cur_ioport->io1.minimum,\r\nspic_dev.cur_ioport->io1.address_length);\r\nif (spic_dev.cur_ioport->io2.minimum)\r\nrelease_region(spic_dev.cur_ioport->io2.minimum,\r\nspic_dev.cur_ioport->io2.address_length);\r\nsonypi_compat_exit();\r\nsony_laptop_remove_input();\r\nsysfs_remove_group(&sony_pf_device->dev.kobj, &spic_attribute_group);\r\nsony_pf_remove();\r\nlist_for_each_entry_safe(io, tmp_io, &spic_dev.ioports, list) {\r\nlist_del(&io->list);\r\nkfree(io);\r\n}\r\nlist_for_each_entry_safe(irq, tmp_irq, &spic_dev.interrupts, list) {\r\nlist_del(&irq->list);\r\nkfree(irq);\r\n}\r\nspic_dev.cur_ioport = NULL;\r\nspic_dev.cur_irq = NULL;\r\ndprintk(SONY_PIC_DRIVER_NAME " removed.\n");\r\nreturn 0;\r\n}\r\nstatic int sony_pic_add(struct acpi_device *device)\r\n{\r\nint result;\r\nstruct sony_pic_ioport *io, *tmp_io;\r\nstruct sony_pic_irq *irq, *tmp_irq;\r\npr_info("%s v%s\n", SONY_PIC_DRIVER_NAME, SONY_LAPTOP_DRIVER_VERSION);\r\nspic_dev.acpi_dev = device;\r\nstrcpy(acpi_device_class(device), "sony/hotkey");\r\nsony_pic_detect_device_type(&spic_dev);\r\nmutex_init(&spic_dev.lock);\r\nresult = sony_pic_possible_resources(device);\r\nif (result) {\r\npr_err("Unable to read possible resources\n");\r\ngoto err_free_resources;\r\n}\r\nresult = sony_laptop_setup_input(device);\r\nif (result) {\r\npr_err("Unable to create input devices\n");\r\ngoto err_free_resources;\r\n}\r\nif (sonypi_compat_init())\r\ngoto err_remove_input;\r\nlist_for_each_entry_reverse(io, &spic_dev.ioports, list) {\r\nif (request_region(io->io1.minimum, io->io1.address_length,\r\n"Sony Programmable I/O Device")) {\r\ndprintk("I/O port1: 0x%.4x (0x%.4x) + 0x%.2x\n",\r\nio->io1.minimum, io->io1.maximum,\r\nio->io1.address_length);\r\nif (io->io2.minimum) {\r\nif (request_region(io->io2.minimum,\r\nio->io2.address_length,\r\n"Sony Programmable I/O Device")) {\r\ndprintk("I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\n",\r\nio->io2.minimum, io->io2.maximum,\r\nio->io2.address_length);\r\nspic_dev.cur_ioport = io;\r\nbreak;\r\n}\r\nelse {\r\ndprintk("Unable to get I/O port2: "\r\n"0x%.4x (0x%.4x) + 0x%.2x\n",\r\nio->io2.minimum, io->io2.maximum,\r\nio->io2.address_length);\r\nrelease_region(io->io1.minimum,\r\nio->io1.address_length);\r\n}\r\n}\r\nelse {\r\nspic_dev.cur_ioport = io;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!spic_dev.cur_ioport) {\r\npr_err("Failed to request_region\n");\r\nresult = -ENODEV;\r\ngoto err_remove_compat;\r\n}\r\nlist_for_each_entry_reverse(irq, &spic_dev.interrupts, list) {\r\nif (!request_irq(irq->irq.interrupts[0], sony_pic_irq,\r\nIRQF_DISABLED, "sony-laptop", &spic_dev)) {\r\ndprintk("IRQ: %d - triggering: %d - "\r\n"polarity: %d - shr: %d\n",\r\nirq->irq.interrupts[0],\r\nirq->irq.triggering,\r\nirq->irq.polarity,\r\nirq->irq.sharable);\r\nspic_dev.cur_irq = irq;\r\nbreak;\r\n}\r\n}\r\nif (!spic_dev.cur_irq) {\r\npr_err("Failed to request_irq\n");\r\nresult = -ENODEV;\r\ngoto err_release_region;\r\n}\r\nresult = sony_pic_enable(device, spic_dev.cur_ioport, spic_dev.cur_irq);\r\nif (result) {\r\npr_err("Couldn't enable device\n");\r\ngoto err_free_irq;\r\n}\r\nspic_dev.bluetooth_power = -1;\r\nresult = sony_pf_add();\r\nif (result)\r\ngoto err_disable_device;\r\nresult = sysfs_create_group(&sony_pf_device->dev.kobj, &spic_attribute_group);\r\nif (result)\r\ngoto err_remove_pf;\r\nreturn 0;\r\nerr_remove_pf:\r\nsony_pf_remove();\r\nerr_disable_device:\r\nsony_pic_disable(device);\r\nerr_free_irq:\r\nfree_irq(spic_dev.cur_irq->irq.interrupts[0], &spic_dev);\r\nerr_release_region:\r\nrelease_region(spic_dev.cur_ioport->io1.minimum,\r\nspic_dev.cur_ioport->io1.address_length);\r\nif (spic_dev.cur_ioport->io2.minimum)\r\nrelease_region(spic_dev.cur_ioport->io2.minimum,\r\nspic_dev.cur_ioport->io2.address_length);\r\nerr_remove_compat:\r\nsonypi_compat_exit();\r\nerr_remove_input:\r\nsony_laptop_remove_input();\r\nerr_free_resources:\r\nlist_for_each_entry_safe(io, tmp_io, &spic_dev.ioports, list) {\r\nlist_del(&io->list);\r\nkfree(io);\r\n}\r\nlist_for_each_entry_safe(irq, tmp_irq, &spic_dev.interrupts, list) {\r\nlist_del(&irq->list);\r\nkfree(irq);\r\n}\r\nspic_dev.cur_ioport = NULL;\r\nspic_dev.cur_irq = NULL;\r\nreturn result;\r\n}\r\nstatic int sony_pic_suspend(struct acpi_device *device, pm_message_t state)\r\n{\r\nif (sony_pic_disable(device))\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic int sony_pic_resume(struct acpi_device *device)\r\n{\r\nsony_pic_enable(device, spic_dev.cur_ioport, spic_dev.cur_irq);\r\nreturn 0;\r\n}\r\nstatic int __init sony_laptop_init(void)\r\n{\r\nint result;\r\nif (!no_spic && dmi_check_system(sonypi_dmi_table)) {\r\nresult = acpi_bus_register_driver(&sony_pic_driver);\r\nif (result) {\r\npr_err("Unable to register SPIC driver\n");\r\ngoto out;\r\n}\r\nspic_drv_registered = 1;\r\n}\r\nresult = acpi_bus_register_driver(&sony_nc_driver);\r\nif (result) {\r\npr_err("Unable to register SNC driver\n");\r\ngoto out_unregister_pic;\r\n}\r\nreturn 0;\r\nout_unregister_pic:\r\nif (spic_drv_registered)\r\nacpi_bus_unregister_driver(&sony_pic_driver);\r\nout:\r\nreturn result;\r\n}\r\nstatic void __exit sony_laptop_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&sony_nc_driver);\r\nif (spic_drv_registered)\r\nacpi_bus_unregister_driver(&sony_pic_driver);\r\n}
