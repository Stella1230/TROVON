static int drm_proc_open(struct inode *inode, struct file *file)\r\n{\r\nstruct drm_info_node* node = PDE(inode)->data;\r\nreturn single_open(file, node->info_ent->show, node);\r\n}\r\nint drm_proc_create_files(struct drm_info_list *files, int count,\r\nstruct proc_dir_entry *root, struct drm_minor *minor)\r\n{\r\nstruct drm_device *dev = minor->dev;\r\nstruct proc_dir_entry *ent;\r\nstruct drm_info_node *tmp;\r\nchar name[64];\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nu32 features = files[i].driver_features;\r\nif (features != 0 &&\r\n(dev->driver->driver_features & features) != features)\r\ncontinue;\r\ntmp = kmalloc(sizeof(struct drm_info_node), GFP_KERNEL);\r\nif (tmp == NULL) {\r\nret = -1;\r\ngoto fail;\r\n}\r\ntmp->minor = minor;\r\ntmp->info_ent = &files[i];\r\nlist_add(&tmp->list, &minor->proc_nodes.list);\r\nent = proc_create_data(files[i].name, S_IRUGO, root,\r\n&drm_proc_fops, tmp);\r\nif (!ent) {\r\nDRM_ERROR("Cannot create /proc/dri/%s/%s\n",\r\nname, files[i].name);\r\nlist_del(&tmp->list);\r\nkfree(tmp);\r\nret = -1;\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nfor (i = 0; i < count; i++)\r\nremove_proc_entry(drm_proc_list[i].name, minor->proc_root);\r\nreturn ret;\r\n}\r\nint drm_proc_init(struct drm_minor *minor, int minor_id,\r\nstruct proc_dir_entry *root)\r\n{\r\nchar name[64];\r\nint ret;\r\nINIT_LIST_HEAD(&minor->proc_nodes.list);\r\nsprintf(name, "%d", minor_id);\r\nminor->proc_root = proc_mkdir(name, root);\r\nif (!minor->proc_root) {\r\nDRM_ERROR("Cannot create /proc/dri/%s\n", name);\r\nreturn -1;\r\n}\r\nret = drm_proc_create_files(drm_proc_list, DRM_PROC_ENTRIES,\r\nminor->proc_root, minor);\r\nif (ret) {\r\nremove_proc_entry(name, root);\r\nminor->proc_root = NULL;\r\nDRM_ERROR("Failed to create core drm proc files\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint drm_proc_remove_files(struct drm_info_list *files, int count,\r\nstruct drm_minor *minor)\r\n{\r\nstruct list_head *pos, *q;\r\nstruct drm_info_node *tmp;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nlist_for_each_safe(pos, q, &minor->proc_nodes.list) {\r\ntmp = list_entry(pos, struct drm_info_node, list);\r\nif (tmp->info_ent == &files[i]) {\r\nremove_proc_entry(files[i].name,\r\nminor->proc_root);\r\nlist_del(pos);\r\nkfree(tmp);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint drm_proc_cleanup(struct drm_minor *minor, struct proc_dir_entry *root)\r\n{\r\nchar name[64];\r\nif (!root || !minor->proc_root)\r\nreturn 0;\r\ndrm_proc_remove_files(drm_proc_list, DRM_PROC_ENTRIES, minor);\r\nsprintf(name, "%d", minor->index);\r\nremove_proc_entry(name, root);\r\nreturn 0;\r\n}
