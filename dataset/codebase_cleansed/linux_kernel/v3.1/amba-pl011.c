static int pl011_fifo_to_tty(struct uart_amba_port *uap)\r\n{\r\nu16 status, ch;\r\nunsigned int flag, max_count = 256;\r\nint fifotaken = 0;\r\nwhile (max_count--) {\r\nstatus = readw(uap->port.membase + UART01x_FR);\r\nif (status & UART01x_FR_RXFE)\r\nbreak;\r\nch = readw(uap->port.membase + UART01x_DR) |\r\nUART_DUMMY_DR_RX;\r\nflag = TTY_NORMAL;\r\nuap->port.icount.rx++;\r\nfifotaken++;\r\nif (unlikely(ch & UART_DR_ERROR)) {\r\nif (ch & UART011_DR_BE) {\r\nch &= ~(UART011_DR_FE | UART011_DR_PE);\r\nuap->port.icount.brk++;\r\nif (uart_handle_break(&uap->port))\r\ncontinue;\r\n} else if (ch & UART011_DR_PE)\r\nuap->port.icount.parity++;\r\nelse if (ch & UART011_DR_FE)\r\nuap->port.icount.frame++;\r\nif (ch & UART011_DR_OE)\r\nuap->port.icount.overrun++;\r\nch &= uap->port.read_status_mask;\r\nif (ch & UART011_DR_BE)\r\nflag = TTY_BREAK;\r\nelse if (ch & UART011_DR_PE)\r\nflag = TTY_PARITY;\r\nelse if (ch & UART011_DR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&uap->port, ch & 255))\r\ncontinue;\r\nuart_insert_char(&uap->port, ch, UART011_DR_OE, ch, flag);\r\n}\r\nreturn fifotaken;\r\n}\r\nstatic int pl011_sgbuf_init(struct dma_chan *chan, struct pl011_sgbuf *sg,\r\nenum dma_data_direction dir)\r\n{\r\nsg->buf = kmalloc(PL011_DMA_BUFFER_SIZE, GFP_KERNEL);\r\nif (!sg->buf)\r\nreturn -ENOMEM;\r\nsg_init_one(&sg->sg, sg->buf, PL011_DMA_BUFFER_SIZE);\r\nif (dma_map_sg(chan->device->dev, &sg->sg, 1, dir) != 1) {\r\nkfree(sg->buf);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pl011_sgbuf_free(struct dma_chan *chan, struct pl011_sgbuf *sg,\r\nenum dma_data_direction dir)\r\n{\r\nif (sg->buf) {\r\ndma_unmap_sg(chan->device->dev, &sg->sg, 1, dir);\r\nkfree(sg->buf);\r\n}\r\n}\r\nstatic void pl011_dma_probe_initcall(struct uart_amba_port *uap)\r\n{\r\nstruct amba_pl011_data *plat = uap->port.dev->platform_data;\r\nstruct dma_slave_config tx_conf = {\r\n.dst_addr = uap->port.mapbase + UART01x_DR,\r\n.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\r\n.direction = DMA_TO_DEVICE,\r\n.dst_maxburst = uap->fifosize >> 1,\r\n};\r\nstruct dma_chan *chan;\r\ndma_cap_mask_t mask;\r\nif (!plat || !plat->dma_filter) {\r\ndev_info(uap->port.dev, "no DMA platform data\n");\r\nreturn;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nchan = dma_request_channel(mask, plat->dma_filter, plat->dma_tx_param);\r\nif (!chan) {\r\ndev_err(uap->port.dev, "no TX DMA channel!\n");\r\nreturn;\r\n}\r\ndmaengine_slave_config(chan, &tx_conf);\r\nuap->dmatx.chan = chan;\r\ndev_info(uap->port.dev, "DMA channel TX %s\n",\r\ndma_chan_name(uap->dmatx.chan));\r\nif (plat->dma_rx_param) {\r\nstruct dma_slave_config rx_conf = {\r\n.src_addr = uap->port.mapbase + UART01x_DR,\r\n.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE,\r\n.direction = DMA_FROM_DEVICE,\r\n.src_maxburst = uap->fifosize >> 1,\r\n};\r\nchan = dma_request_channel(mask, plat->dma_filter, plat->dma_rx_param);\r\nif (!chan) {\r\ndev_err(uap->port.dev, "no RX DMA channel!\n");\r\nreturn;\r\n}\r\ndmaengine_slave_config(chan, &rx_conf);\r\nuap->dmarx.chan = chan;\r\ndev_info(uap->port.dev, "DMA channel RX %s\n",\r\ndma_chan_name(uap->dmarx.chan));\r\n}\r\n}\r\nstatic int __init pl011_dma_initcall(void)\r\n{\r\nstruct list_head *node, *tmp;\r\nlist_for_each_safe(node, tmp, &pl011_dma_uarts) {\r\nstruct dma_uap *dmau = list_entry(node, struct dma_uap, node);\r\npl011_dma_probe_initcall(dmau->uap);\r\nlist_del(node);\r\nkfree(dmau);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pl011_dma_probe(struct uart_amba_port *uap)\r\n{\r\nstruct dma_uap *dmau = kzalloc(sizeof(struct dma_uap), GFP_KERNEL);\r\nif (dmau) {\r\ndmau->uap = uap;\r\nlist_add_tail(&dmau->node, &pl011_dma_uarts);\r\n}\r\n}\r\nstatic void pl011_dma_probe(struct uart_amba_port *uap)\r\n{\r\npl011_dma_probe_initcall(uap);\r\n}\r\nstatic void pl011_dma_remove(struct uart_amba_port *uap)\r\n{\r\nif (uap->dmatx.chan)\r\ndma_release_channel(uap->dmatx.chan);\r\nif (uap->dmarx.chan)\r\ndma_release_channel(uap->dmarx.chan);\r\n}\r\nstatic void pl011_dma_tx_callback(void *data)\r\n{\r\nstruct uart_amba_port *uap = data;\r\nstruct pl011_dmatx_data *dmatx = &uap->dmatx;\r\nunsigned long flags;\r\nu16 dmacr;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nif (uap->dmatx.queued)\r\ndma_unmap_sg(dmatx->chan->device->dev, &dmatx->sg, 1,\r\nDMA_TO_DEVICE);\r\ndmacr = uap->dmacr;\r\nuap->dmacr = dmacr & ~UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nif (!(dmacr & UART011_TXDMAE) || uart_tx_stopped(&uap->port) ||\r\nuart_circ_empty(&uap->port.state->xmit)) {\r\nuap->dmatx.queued = false;\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\nreturn;\r\n}\r\nif (pl011_dma_tx_refill(uap) <= 0) {\r\nuap->im |= UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\n}\r\nstatic int pl011_dma_tx_refill(struct uart_amba_port *uap)\r\n{\r\nstruct pl011_dmatx_data *dmatx = &uap->dmatx;\r\nstruct dma_chan *chan = dmatx->chan;\r\nstruct dma_device *dma_dev = chan->device;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct circ_buf *xmit = &uap->port.state->xmit;\r\nunsigned int count;\r\ncount = uart_circ_chars_pending(xmit);\r\nif (count < (uap->fifosize >> 1)) {\r\nuap->dmatx.queued = false;\r\nreturn 0;\r\n}\r\ncount -= 1;\r\nif (count > PL011_DMA_BUFFER_SIZE)\r\ncount = PL011_DMA_BUFFER_SIZE;\r\nif (xmit->tail < xmit->head)\r\nmemcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], count);\r\nelse {\r\nsize_t first = UART_XMIT_SIZE - xmit->tail;\r\nsize_t second = xmit->head;\r\nmemcpy(&dmatx->buf[0], &xmit->buf[xmit->tail], first);\r\nif (second)\r\nmemcpy(&dmatx->buf[first], &xmit->buf[0], second);\r\n}\r\ndmatx->sg.length = count;\r\nif (dma_map_sg(dma_dev->dev, &dmatx->sg, 1, DMA_TO_DEVICE) != 1) {\r\nuap->dmatx.queued = false;\r\ndev_dbg(uap->port.dev, "unable to map TX DMA\n");\r\nreturn -EBUSY;\r\n}\r\ndesc = dma_dev->device_prep_slave_sg(chan, &dmatx->sg, 1, DMA_TO_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndma_unmap_sg(dma_dev->dev, &dmatx->sg, 1, DMA_TO_DEVICE);\r\nuap->dmatx.queued = false;\r\ndev_dbg(uap->port.dev, "TX DMA busy\n");\r\nreturn -EBUSY;\r\n}\r\ndesc->callback = pl011_dma_tx_callback;\r\ndesc->callback_param = uap;\r\ndmaengine_submit(desc);\r\ndma_dev->device_issue_pending(chan);\r\nuap->dmacr |= UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nuap->dmatx.queued = true;\r\nxmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);\r\nuap->port.icount.tx += count;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uap->port);\r\nreturn 1;\r\n}\r\nstatic bool pl011_dma_tx_irq(struct uart_amba_port *uap)\r\n{\r\nif (!uap->using_tx_dma)\r\nreturn false;\r\nif (uap->dmatx.queued) {\r\nuap->dmacr |= UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nuap->im &= ~UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nreturn true;\r\n}\r\nif (pl011_dma_tx_refill(uap) > 0) {\r\nuap->im &= ~UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline void pl011_dma_tx_stop(struct uart_amba_port *uap)\r\n{\r\nif (uap->dmatx.queued) {\r\nuap->dmacr &= ~UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\n}\r\n}\r\nstatic inline bool pl011_dma_tx_start(struct uart_amba_port *uap)\r\n{\r\nu16 dmacr;\r\nif (!uap->using_tx_dma)\r\nreturn false;\r\nif (!uap->port.x_char) {\r\nbool ret = true;\r\nif (!uap->dmatx.queued) {\r\nif (pl011_dma_tx_refill(uap) > 0) {\r\nuap->im &= ~UART011_TXIM;\r\nret = true;\r\n} else {\r\nuap->im |= UART011_TXIM;\r\nret = false;\r\n}\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n} else if (!(uap->dmacr & UART011_TXDMAE)) {\r\nuap->dmacr |= UART011_TXDMAE;\r\nwritew(uap->dmacr,\r\nuap->port.membase + UART011_DMACR);\r\n}\r\nreturn ret;\r\n}\r\ndmacr = uap->dmacr;\r\nuap->dmacr &= ~UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nif (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF) {\r\nreturn false;\r\n}\r\nwritew(uap->port.x_char, uap->port.membase + UART01x_DR);\r\nuap->port.icount.tx++;\r\nuap->port.x_char = 0;\r\nuap->dmacr = dmacr;\r\nwritew(dmacr, uap->port.membase + UART011_DMACR);\r\nreturn true;\r\n}\r\nstatic void pl011_dma_flush_buffer(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nif (!uap->using_tx_dma)\r\nreturn;\r\nspin_unlock(&uap->port.lock);\r\ndmaengine_terminate_all(uap->dmatx.chan);\r\nspin_lock(&uap->port.lock);\r\nif (uap->dmatx.queued) {\r\ndma_unmap_sg(uap->dmatx.chan->device->dev, &uap->dmatx.sg, 1,\r\nDMA_TO_DEVICE);\r\nuap->dmatx.queued = false;\r\nuap->dmacr &= ~UART011_TXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\n}\r\n}\r\nstatic int pl011_dma_rx_trigger_dma(struct uart_amba_port *uap)\r\n{\r\nstruct dma_chan *rxchan = uap->dmarx.chan;\r\nstruct dma_device *dma_dev;\r\nstruct pl011_dmarx_data *dmarx = &uap->dmarx;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct pl011_sgbuf *sgbuf;\r\nif (!rxchan)\r\nreturn -EIO;\r\nsgbuf = uap->dmarx.use_buf_b ?\r\n&uap->dmarx.sgbuf_b : &uap->dmarx.sgbuf_a;\r\ndma_dev = rxchan->device;\r\ndesc = rxchan->device->device_prep_slave_sg(rxchan, &sgbuf->sg, 1,\r\nDMA_FROM_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\nuap->dmarx.running = false;\r\ndmaengine_terminate_all(rxchan);\r\nreturn -EBUSY;\r\n}\r\ndesc->callback = pl011_dma_rx_callback;\r\ndesc->callback_param = uap;\r\ndmarx->cookie = dmaengine_submit(desc);\r\ndma_async_issue_pending(rxchan);\r\nuap->dmacr |= UART011_RXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nuap->dmarx.running = true;\r\nuap->im &= ~UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nreturn 0;\r\n}\r\nstatic void pl011_dma_rx_chars(struct uart_amba_port *uap,\r\nu32 pending, bool use_buf_b,\r\nbool readfifo)\r\n{\r\nstruct tty_struct *tty = uap->port.state->port.tty;\r\nstruct pl011_sgbuf *sgbuf = use_buf_b ?\r\n&uap->dmarx.sgbuf_b : &uap->dmarx.sgbuf_a;\r\nstruct device *dev = uap->dmarx.chan->device->dev;\r\nint dma_count = 0;\r\nu32 fifotaken = 0;\r\nif (pending) {\r\ndma_sync_sg_for_cpu(dev, &sgbuf->sg, 1, DMA_FROM_DEVICE);\r\ndma_count = tty_insert_flip_string(uap->port.state->port.tty,\r\nsgbuf->buf, pending);\r\ndma_sync_sg_for_device(dev, &sgbuf->sg, 1, DMA_FROM_DEVICE);\r\nuap->port.icount.rx += dma_count;\r\nif (dma_count < pending)\r\ndev_warn(uap->port.dev,\r\n"couldn't insert all characters (TTY is full?)\n");\r\n}\r\nif (dma_count == pending && readfifo) {\r\nwritew(UART011_OEIS | UART011_BEIS | UART011_PEIS | UART011_FEIS,\r\nuap->port.membase + UART011_ICR);\r\nfifotaken = pl011_fifo_to_tty(uap);\r\n}\r\nspin_unlock(&uap->port.lock);\r\ndev_vdbg(uap->port.dev,\r\n"Took %d chars from DMA buffer and %d chars from the FIFO\n",\r\ndma_count, fifotaken);\r\ntty_flip_buffer_push(tty);\r\nspin_lock(&uap->port.lock);\r\n}\r\nstatic void pl011_dma_rx_irq(struct uart_amba_port *uap)\r\n{\r\nstruct pl011_dmarx_data *dmarx = &uap->dmarx;\r\nstruct dma_chan *rxchan = dmarx->chan;\r\nstruct pl011_sgbuf *sgbuf = dmarx->use_buf_b ?\r\n&dmarx->sgbuf_b : &dmarx->sgbuf_a;\r\nsize_t pending;\r\nstruct dma_tx_state state;\r\nenum dma_status dmastat;\r\nif (dmaengine_pause(rxchan))\r\ndev_err(uap->port.dev, "unable to pause DMA transfer\n");\r\ndmastat = rxchan->device->device_tx_status(rxchan,\r\ndmarx->cookie, &state);\r\nif (dmastat != DMA_PAUSED)\r\ndev_err(uap->port.dev, "unable to pause DMA transfer\n");\r\nuap->dmacr &= ~UART011_RXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nuap->dmarx.running = false;\r\npending = sgbuf->sg.length - state.residue;\r\nBUG_ON(pending > PL011_DMA_BUFFER_SIZE);\r\ndmaengine_terminate_all(rxchan);\r\npl011_dma_rx_chars(uap, pending, dmarx->use_buf_b, true);\r\ndmarx->use_buf_b = !dmarx->use_buf_b;\r\nif (pl011_dma_rx_trigger_dma(uap)) {\r\ndev_dbg(uap->port.dev, "could not retrigger RX DMA job "\r\n"fall back to interrupt mode\n");\r\nuap->im |= UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\n}\r\nstatic void pl011_dma_rx_callback(void *data)\r\n{\r\nstruct uart_amba_port *uap = data;\r\nstruct pl011_dmarx_data *dmarx = &uap->dmarx;\r\nbool lastbuf = dmarx->use_buf_b;\r\nint ret;\r\nspin_lock_irq(&uap->port.lock);\r\nuap->dmarx.running = false;\r\ndmarx->use_buf_b = !lastbuf;\r\nret = pl011_dma_rx_trigger_dma(uap);\r\npl011_dma_rx_chars(uap, PL011_DMA_BUFFER_SIZE, lastbuf, false);\r\nspin_unlock_irq(&uap->port.lock);\r\nif (ret) {\r\ndev_dbg(uap->port.dev, "could not retrigger RX DMA job "\r\n"fall back to interrupt mode\n");\r\nuap->im |= UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\n}\r\nstatic inline void pl011_dma_rx_stop(struct uart_amba_port *uap)\r\n{\r\nuap->dmacr &= ~UART011_RXDMAE;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\n}\r\nstatic void pl011_dma_startup(struct uart_amba_port *uap)\r\n{\r\nint ret;\r\nif (!uap->dmatx.chan)\r\nreturn;\r\nuap->dmatx.buf = kmalloc(PL011_DMA_BUFFER_SIZE, GFP_KERNEL);\r\nif (!uap->dmatx.buf) {\r\ndev_err(uap->port.dev, "no memory for DMA TX buffer\n");\r\nuap->port.fifosize = uap->fifosize;\r\nreturn;\r\n}\r\nsg_init_one(&uap->dmatx.sg, uap->dmatx.buf, PL011_DMA_BUFFER_SIZE);\r\nuap->port.fifosize = PL011_DMA_BUFFER_SIZE;\r\nuap->using_tx_dma = true;\r\nif (!uap->dmarx.chan)\r\ngoto skip_rx;\r\nret = pl011_sgbuf_init(uap->dmarx.chan, &uap->dmarx.sgbuf_a,\r\nDMA_FROM_DEVICE);\r\nif (ret) {\r\ndev_err(uap->port.dev, "failed to init DMA %s: %d\n",\r\n"RX buffer A", ret);\r\ngoto skip_rx;\r\n}\r\nret = pl011_sgbuf_init(uap->dmarx.chan, &uap->dmarx.sgbuf_b,\r\nDMA_FROM_DEVICE);\r\nif (ret) {\r\ndev_err(uap->port.dev, "failed to init DMA %s: %d\n",\r\n"RX buffer B", ret);\r\npl011_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_a,\r\nDMA_FROM_DEVICE);\r\ngoto skip_rx;\r\n}\r\nuap->using_rx_dma = true;\r\nskip_rx:\r\nuap->dmacr |= UART011_DMAONERR;\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nif (uap->vendor->dma_threshold)\r\nwritew(ST_UART011_DMAWM_RX_16 | ST_UART011_DMAWM_TX_16,\r\nuap->port.membase + ST_UART011_DMAWM);\r\nif (uap->using_rx_dma) {\r\nif (pl011_dma_rx_trigger_dma(uap))\r\ndev_dbg(uap->port.dev, "could not trigger initial "\r\n"RX DMA job, fall back to interrupt mode\n");\r\n}\r\n}\r\nstatic void pl011_dma_shutdown(struct uart_amba_port *uap)\r\n{\r\nif (!(uap->using_tx_dma || uap->using_rx_dma))\r\nreturn;\r\nwhile (readw(uap->port.membase + UART01x_FR) & UART01x_FR_BUSY)\r\nbarrier();\r\nspin_lock_irq(&uap->port.lock);\r\nuap->dmacr &= ~(UART011_DMAONERR | UART011_RXDMAE | UART011_TXDMAE);\r\nwritew(uap->dmacr, uap->port.membase + UART011_DMACR);\r\nspin_unlock_irq(&uap->port.lock);\r\nif (uap->using_tx_dma) {\r\ndmaengine_terminate_all(uap->dmatx.chan);\r\nif (uap->dmatx.queued) {\r\ndma_unmap_sg(uap->dmatx.chan->device->dev, &uap->dmatx.sg, 1,\r\nDMA_TO_DEVICE);\r\nuap->dmatx.queued = false;\r\n}\r\nkfree(uap->dmatx.buf);\r\nuap->using_tx_dma = false;\r\n}\r\nif (uap->using_rx_dma) {\r\ndmaengine_terminate_all(uap->dmarx.chan);\r\npl011_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_a, DMA_FROM_DEVICE);\r\npl011_sgbuf_free(uap->dmarx.chan, &uap->dmarx.sgbuf_b, DMA_FROM_DEVICE);\r\nuap->using_rx_dma = false;\r\n}\r\n}\r\nstatic inline bool pl011_dma_rx_available(struct uart_amba_port *uap)\r\n{\r\nreturn uap->using_rx_dma;\r\n}\r\nstatic inline bool pl011_dma_rx_running(struct uart_amba_port *uap)\r\n{\r\nreturn uap->using_rx_dma && uap->dmarx.running;\r\n}\r\nstatic inline void pl011_dma_probe(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline void pl011_dma_remove(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline void pl011_dma_startup(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline void pl011_dma_shutdown(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline bool pl011_dma_tx_irq(struct uart_amba_port *uap)\r\n{\r\nreturn false;\r\n}\r\nstatic inline void pl011_dma_tx_stop(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline bool pl011_dma_tx_start(struct uart_amba_port *uap)\r\n{\r\nreturn false;\r\n}\r\nstatic inline void pl011_dma_rx_irq(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline void pl011_dma_rx_stop(struct uart_amba_port *uap)\r\n{\r\n}\r\nstatic inline int pl011_dma_rx_trigger_dma(struct uart_amba_port *uap)\r\n{\r\nreturn -EIO;\r\n}\r\nstatic inline bool pl011_dma_rx_available(struct uart_amba_port *uap)\r\n{\r\nreturn false;\r\n}\r\nstatic inline bool pl011_dma_rx_running(struct uart_amba_port *uap)\r\n{\r\nreturn false;\r\n}\r\nstatic void pl011_lockup_wa(unsigned long data)\r\n{\r\nstruct uart_amba_port *uap = amba_ports[0];\r\nvoid __iomem *base = uap->port.membase;\r\nstruct circ_buf *xmit = &uap->port.state->xmit;\r\nstruct tty_struct *tty = uap->port.state->port.tty;\r\nint buf_empty_retries = 200;\r\nint loop;\r\ntty->hw_stopped = 1;\r\nwhile (!uart_circ_empty(xmit)) {\r\nif (buf_empty_retries-- == 0)\r\nbreak;\r\nudelay(100);\r\n}\r\nfor (loop = 0; loop < UART_WA_SAVE_NR; loop++)\r\nuart_wa_regdata[loop] = readl(base + uart_wa_reg[loop]);\r\nwritew(0x00, uap->port.membase + UART011_CR);\r\nif (uap->port.dev->platform_data) {\r\nstruct amba_pl011_data *plat;\r\nplat = uap->port.dev->platform_data;\r\nif (plat->reset)\r\nplat->reset();\r\n}\r\nfor (loop = 0; loop < UART_WA_SAVE_NR; loop++)\r\nwritew(uart_wa_regdata[loop] ,\r\nuap->port.membase + uart_wa_reg[loop]);\r\nuap->old_status = readw(uap->port.membase + UART01x_FR) &\r\nUART01x_FR_MODEM_ANY;\r\nif (readl(base + UART011_MIS) & 0x2)\r\nprintk(KERN_EMERG "UART_BT_WA: ***FAILED***\n");\r\ntty->hw_stopped = 0;\r\n}\r\nstatic void pl011_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nuap->im &= ~UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\npl011_dma_tx_stop(uap);\r\n}\r\nstatic void pl011_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nif (!pl011_dma_tx_start(uap)) {\r\nuap->im |= UART011_TXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\n}\r\nstatic void pl011_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nuap->im &= ~(UART011_RXIM|UART011_RTIM|UART011_FEIM|\r\nUART011_PEIM|UART011_BEIM|UART011_OEIM);\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\npl011_dma_rx_stop(uap);\r\n}\r\nstatic void pl011_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nuap->im |= UART011_RIMIM|UART011_CTSMIM|UART011_DCDMIM|UART011_DSRMIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\nstatic void pl011_rx_chars(struct uart_amba_port *uap)\r\n{\r\nstruct tty_struct *tty = uap->port.state->port.tty;\r\npl011_fifo_to_tty(uap);\r\nspin_unlock(&uap->port.lock);\r\ntty_flip_buffer_push(tty);\r\nif (pl011_dma_rx_available(uap)) {\r\nif (pl011_dma_rx_trigger_dma(uap)) {\r\ndev_dbg(uap->port.dev, "could not trigger RX DMA job "\r\n"fall back to interrupt mode again\n");\r\nuap->im |= UART011_RXIM;\r\n} else\r\nuap->im &= ~UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\n}\r\nspin_lock(&uap->port.lock);\r\n}\r\nstatic void pl011_tx_chars(struct uart_amba_port *uap)\r\n{\r\nstruct circ_buf *xmit = &uap->port.state->xmit;\r\nint count;\r\nif (uap->port.x_char) {\r\nwritew(uap->port.x_char, uap->port.membase + UART01x_DR);\r\nuap->port.icount.tx++;\r\nuap->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&uap->port)) {\r\npl011_stop_tx(&uap->port);\r\nreturn;\r\n}\r\nif (pl011_dma_tx_irq(uap))\r\nreturn;\r\ncount = uap->fifosize >> 1;\r\ndo {\r\nwritew(xmit->buf[xmit->tail], uap->port.membase + UART01x_DR);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nuap->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uap->port);\r\nif (uart_circ_empty(xmit))\r\npl011_stop_tx(&uap->port);\r\n}\r\nstatic void pl011_modem_status(struct uart_amba_port *uap)\r\n{\r\nunsigned int status, delta;\r\nstatus = readw(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;\r\ndelta = status ^ uap->old_status;\r\nuap->old_status = status;\r\nif (!delta)\r\nreturn;\r\nif (delta & UART01x_FR_DCD)\r\nuart_handle_dcd_change(&uap->port, status & UART01x_FR_DCD);\r\nif (delta & UART01x_FR_DSR)\r\nuap->port.icount.dsr++;\r\nif (delta & UART01x_FR_CTS)\r\nuart_handle_cts_change(&uap->port, status & UART01x_FR_CTS);\r\nwake_up_interruptible(&uap->port.state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t pl011_int(int irq, void *dev_id)\r\n{\r\nstruct uart_amba_port *uap = dev_id;\r\nunsigned long flags;\r\nunsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;\r\nint handled = 0;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nstatus = readw(uap->port.membase + UART011_MIS);\r\nif (status) {\r\ndo {\r\nwritew(status & ~(UART011_TXIS|UART011_RTIS|\r\nUART011_RXIS),\r\nuap->port.membase + UART011_ICR);\r\nif (status & (UART011_RTIS|UART011_RXIS)) {\r\nif (pl011_dma_rx_running(uap))\r\npl011_dma_rx_irq(uap);\r\nelse\r\npl011_rx_chars(uap);\r\n}\r\nif (status & (UART011_DSRMIS|UART011_DCDMIS|\r\nUART011_CTSMIS|UART011_RIMIS))\r\npl011_modem_status(uap);\r\nif (status & UART011_TXIS)\r\npl011_tx_chars(uap);\r\nif (pass_counter-- == 0) {\r\nif (uap->interrupt_may_hang)\r\ntasklet_schedule(&pl011_lockup_tlet);\r\nbreak;\r\n}\r\nstatus = readw(uap->port.membase + UART011_MIS);\r\n} while (status != 0);\r\nhandled = 1;\r\n}\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic unsigned int pl01x_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int status = readw(uap->port.membase + UART01x_FR);\r\nreturn status & (UART01x_FR_BUSY|UART01x_FR_TXFF) ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int pl01x_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int result = 0;\r\nunsigned int status = readw(uap->port.membase + UART01x_FR);\r\n#define TIOCMBIT(uartbit, tiocmbit) \\r\nif (status & uartbit) \\r\nresult |= tiocmbit\r\nTIOCMBIT(UART01x_FR_DCD, TIOCM_CAR);\r\nTIOCMBIT(UART01x_FR_DSR, TIOCM_DSR);\r\nTIOCMBIT(UART01x_FR_CTS, TIOCM_CTS);\r\nTIOCMBIT(UART011_FR_RI, TIOCM_RNG);\r\n#undef TIOCMBIT\r\nreturn result;\r\n}\r\nstatic void pl011_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int cr;\r\ncr = readw(uap->port.membase + UART011_CR);\r\n#define TIOCMBIT(tiocmbit, uartbit) \\r\nif (mctrl & tiocmbit) \\r\ncr |= uartbit; \\r\nelse \\r\ncr &= ~uartbit\r\nTIOCMBIT(TIOCM_RTS, UART011_CR_RTS);\r\nTIOCMBIT(TIOCM_DTR, UART011_CR_DTR);\r\nTIOCMBIT(TIOCM_OUT1, UART011_CR_OUT1);\r\nTIOCMBIT(TIOCM_OUT2, UART011_CR_OUT2);\r\nTIOCMBIT(TIOCM_LOOP, UART011_CR_LBE);\r\nif (uap->autorts) {\r\nTIOCMBIT(TIOCM_RTS, UART011_CR_RTSEN);\r\n}\r\n#undef TIOCMBIT\r\nwritew(cr, uap->port.membase + UART011_CR);\r\n}\r\nstatic void pl011_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned long flags;\r\nunsigned int lcr_h;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nlcr_h = readw(uap->port.membase + uap->lcrh_tx);\r\nif (break_state == -1)\r\nlcr_h |= UART01x_LCRH_BRK;\r\nelse\r\nlcr_h &= ~UART01x_LCRH_BRK;\r\nwritew(lcr_h, uap->port.membase + uap->lcrh_tx);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\n}\r\nstatic int pl010_get_poll_char(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int status;\r\nstatus = readw(uap->port.membase + UART01x_FR);\r\nif (status & UART01x_FR_RXFE)\r\nreturn NO_POLL_CHAR;\r\nreturn readw(uap->port.membase + UART01x_DR);\r\n}\r\nstatic void pl010_put_poll_char(struct uart_port *port,\r\nunsigned char ch)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nwhile (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF)\r\nbarrier();\r\nwritew(ch, uap->port.membase + UART01x_DR);\r\n}\r\nstatic int pl011_startup(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int cr;\r\nint retval;\r\nretval = clk_enable(uap->clk);\r\nif (retval)\r\ngoto out;\r\nuap->port.uartclk = clk_get_rate(uap->clk);\r\nretval = request_irq(uap->port.irq, pl011_int, 0, "uart-pl011", uap);\r\nif (retval)\r\ngoto clk_dis;\r\nwritew(uap->vendor->ifls, uap->port.membase + UART011_IFLS);\r\ncr = UART01x_CR_UARTEN | UART011_CR_TXE | UART011_CR_LBE;\r\nwritew(cr, uap->port.membase + UART011_CR);\r\nwritew(0, uap->port.membase + UART011_FBRD);\r\nwritew(1, uap->port.membase + UART011_IBRD);\r\nwritew(0, uap->port.membase + uap->lcrh_rx);\r\nif (uap->lcrh_tx != uap->lcrh_rx) {\r\nint i;\r\nfor (i = 0; i < 10; ++i)\r\nwritew(0xff, uap->port.membase + UART011_MIS);\r\nwritew(0, uap->port.membase + uap->lcrh_tx);\r\n}\r\nwritew(0, uap->port.membase + UART01x_DR);\r\nwhile (readw(uap->port.membase + UART01x_FR) & UART01x_FR_BUSY)\r\nbarrier();\r\ncr = UART01x_CR_UARTEN | UART011_CR_RXE | UART011_CR_TXE;\r\nwritew(cr, uap->port.membase + UART011_CR);\r\nwritew(UART011_OEIS | UART011_BEIS | UART011_PEIS | UART011_FEIS,\r\nuap->port.membase + UART011_ICR);\r\nuap->old_status = readw(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;\r\npl011_dma_startup(uap);\r\nspin_lock_irq(&uap->port.lock);\r\nuap->im = UART011_RTIM;\r\nif (!pl011_dma_rx_running(uap))\r\nuap->im |= UART011_RXIM;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nspin_unlock_irq(&uap->port.lock);\r\nif (uap->port.dev->platform_data) {\r\nstruct amba_pl011_data *plat;\r\nplat = uap->port.dev->platform_data;\r\nif (plat->init)\r\nplat->init();\r\n}\r\nreturn 0;\r\nclk_dis:\r\nclk_disable(uap->clk);\r\nout:\r\nreturn retval;\r\n}\r\nstatic void pl011_shutdown_channel(struct uart_amba_port *uap,\r\nunsigned int lcrh)\r\n{\r\nunsigned long val;\r\nval = readw(uap->port.membase + lcrh);\r\nval &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);\r\nwritew(val, uap->port.membase + lcrh);\r\n}\r\nstatic void pl011_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nspin_lock_irq(&uap->port.lock);\r\nuap->im = 0;\r\nwritew(uap->im, uap->port.membase + UART011_IMSC);\r\nwritew(0xffff, uap->port.membase + UART011_ICR);\r\nspin_unlock_irq(&uap->port.lock);\r\npl011_dma_shutdown(uap);\r\nfree_irq(uap->port.irq, uap);\r\nuap->autorts = false;\r\nwritew(UART01x_CR_UARTEN | UART011_CR_TXE, uap->port.membase + UART011_CR);\r\npl011_shutdown_channel(uap, uap->lcrh_rx);\r\nif (uap->lcrh_rx != uap->lcrh_tx)\r\npl011_shutdown_channel(uap, uap->lcrh_tx);\r\nclk_disable(uap->clk);\r\nif (uap->port.dev->platform_data) {\r\nstruct amba_pl011_data *plat;\r\nplat = uap->port.dev->platform_data;\r\nif (plat->exit)\r\nplat->exit();\r\n}\r\n}\r\nstatic void\r\npl011_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int lcr_h, old_cr;\r\nunsigned long flags;\r\nunsigned int baud, quot, clkdiv;\r\nif (uap->vendor->oversampling)\r\nclkdiv = 8;\r\nelse\r\nclkdiv = 16;\r\nbaud = uart_get_baud_rate(port, termios, old, 0,\r\nport->uartclk / clkdiv);\r\nif (baud > port->uartclk/16)\r\nquot = DIV_ROUND_CLOSEST(port->uartclk * 8, baud);\r\nelse\r\nquot = DIV_ROUND_CLOSEST(port->uartclk * 4, baud);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr_h = UART01x_LCRH_WLEN_5;\r\nbreak;\r\ncase CS6:\r\nlcr_h = UART01x_LCRH_WLEN_6;\r\nbreak;\r\ncase CS7:\r\nlcr_h = UART01x_LCRH_WLEN_7;\r\nbreak;\r\ndefault:\r\nlcr_h = UART01x_LCRH_WLEN_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nlcr_h |= UART01x_LCRH_STP2;\r\nif (termios->c_cflag & PARENB) {\r\nlcr_h |= UART01x_LCRH_PEN;\r\nif (!(termios->c_cflag & PARODD))\r\nlcr_h |= UART01x_LCRH_EPS;\r\n}\r\nif (uap->fifosize > 1)\r\nlcr_h |= UART01x_LCRH_FEN;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nport->read_status_mask = UART011_DR_OE | 255;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UART011_DR_FE | UART011_DR_PE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= UART011_DR_BE;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART011_DR_FE | UART011_DR_PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= UART011_DR_BE;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART011_DR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= UART_DUMMY_DR_RX;\r\nif (UART_ENABLE_MS(port, termios->c_cflag))\r\npl011_enable_ms(port);\r\nold_cr = readw(port->membase + UART011_CR);\r\nwritew(0, port->membase + UART011_CR);\r\nif (termios->c_cflag & CRTSCTS) {\r\nif (old_cr & UART011_CR_RTS)\r\nold_cr |= UART011_CR_RTSEN;\r\nold_cr |= UART011_CR_CTSEN;\r\nuap->autorts = true;\r\n} else {\r\nold_cr &= ~(UART011_CR_CTSEN | UART011_CR_RTSEN);\r\nuap->autorts = false;\r\n}\r\nif (uap->vendor->oversampling) {\r\nif (baud > port->uartclk / 16)\r\nold_cr |= ST_UART011_CR_OVSFACT;\r\nelse\r\nold_cr &= ~ST_UART011_CR_OVSFACT;\r\n}\r\nwritew(quot & 0x3f, port->membase + UART011_FBRD);\r\nwritew(quot >> 6, port->membase + UART011_IBRD);\r\nwritew(lcr_h, port->membase + uap->lcrh_rx);\r\nif (uap->lcrh_rx != uap->lcrh_tx) {\r\nint i;\r\nfor (i = 0; i < 10; ++i)\r\nwritew(0xff, uap->port.membase + UART011_MIS);\r\nwritew(lcr_h, port->membase + uap->lcrh_tx);\r\n}\r\nwritew(old_cr, port->membase + UART011_CR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *pl011_type(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nreturn uap->port.type == PORT_AMBA ? uap->type : NULL;\r\n}\r\nstatic void pl010_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, SZ_4K);\r\n}\r\nstatic int pl010_request_port(struct uart_port *port)\r\n{\r\nreturn request_mem_region(port->mapbase, SZ_4K, "uart-pl011")\r\n!= NULL ? 0 : -EBUSY;\r\n}\r\nstatic void pl010_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_AMBA;\r\npl010_request_port(port);\r\n}\r\n}\r\nstatic int pl010_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)\r\nret = -EINVAL;\r\nif (ser->irq < 0 || ser->irq >= nr_irqs)\r\nret = -EINVAL;\r\nif (ser->baud_base < 9600)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void pl011_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nwhile (readw(uap->port.membase + UART01x_FR) & UART01x_FR_TXFF)\r\nbarrier();\r\nwritew(ch, uap->port.membase + UART01x_DR);\r\n}\r\nstatic void\r\npl011_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_amba_port *uap = amba_ports[co->index];\r\nunsigned int status, old_cr, new_cr;\r\nclk_enable(uap->clk);\r\nold_cr = readw(uap->port.membase + UART011_CR);\r\nnew_cr = old_cr & ~UART011_CR_CTSEN;\r\nnew_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;\r\nwritew(new_cr, uap->port.membase + UART011_CR);\r\nuart_console_write(&uap->port, s, count, pl011_console_putchar);\r\ndo {\r\nstatus = readw(uap->port.membase + UART01x_FR);\r\n} while (status & UART01x_FR_BUSY);\r\nwritew(old_cr, uap->port.membase + UART011_CR);\r\nclk_disable(uap->clk);\r\n}\r\nstatic void __init\r\npl011_console_get_options(struct uart_amba_port *uap, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (readw(uap->port.membase + UART011_CR) & UART01x_CR_UARTEN) {\r\nunsigned int lcr_h, ibrd, fbrd;\r\nlcr_h = readw(uap->port.membase + uap->lcrh_tx);\r\n*parity = 'n';\r\nif (lcr_h & UART01x_LCRH_PEN) {\r\nif (lcr_h & UART01x_LCRH_EPS)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\nif ((lcr_h & 0x60) == UART01x_LCRH_WLEN_7)\r\n*bits = 7;\r\nelse\r\n*bits = 8;\r\nibrd = readw(uap->port.membase + UART011_IBRD);\r\nfbrd = readw(uap->port.membase + UART011_FBRD);\r\n*baud = uap->port.uartclk * 4 / (64 * ibrd + fbrd);\r\nif (uap->vendor->oversampling) {\r\nif (readw(uap->port.membase + UART011_CR)\r\n& ST_UART011_CR_OVSFACT)\r\n*baud *= 2;\r\n}\r\n}\r\n}\r\nstatic int __init pl011_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_amba_port *uap;\r\nint baud = 38400;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= UART_NR)\r\nco->index = 0;\r\nuap = amba_ports[co->index];\r\nif (!uap)\r\nreturn -ENODEV;\r\nif (uap->port.dev->platform_data) {\r\nstruct amba_pl011_data *plat;\r\nplat = uap->port.dev->platform_data;\r\nif (plat->init)\r\nplat->init();\r\n}\r\nuap->port.uartclk = clk_get_rate(uap->clk);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\npl011_console_get_options(uap, &baud, &parity, &bits);\r\nreturn uart_set_options(&uap->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int pl011_probe(struct amba_device *dev, const struct amba_id *id)\r\n{\r\nstruct uart_amba_port *uap;\r\nstruct vendor_data *vendor = id->data;\r\nvoid __iomem *base;\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\r\nif (amba_ports[i] == NULL)\r\nbreak;\r\nif (i == ARRAY_SIZE(amba_ports)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nuap = kzalloc(sizeof(struct uart_amba_port), GFP_KERNEL);\r\nif (uap == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbase = ioremap(dev->res.start, resource_size(&dev->res));\r\nif (!base) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nuap->clk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(uap->clk)) {\r\nret = PTR_ERR(uap->clk);\r\ngoto unmap;\r\n}\r\nuap->vendor = vendor;\r\nuap->lcrh_rx = vendor->lcrh_rx;\r\nuap->lcrh_tx = vendor->lcrh_tx;\r\nuap->fifosize = vendor->fifosize;\r\nuap->interrupt_may_hang = vendor->interrupt_may_hang;\r\nuap->port.dev = &dev->dev;\r\nuap->port.mapbase = dev->res.start;\r\nuap->port.membase = base;\r\nuap->port.iotype = UPIO_MEM;\r\nuap->port.irq = dev->irq[0];\r\nuap->port.fifosize = uap->fifosize;\r\nuap->port.ops = &amba_pl011_pops;\r\nuap->port.flags = UPF_BOOT_AUTOCONF;\r\nuap->port.line = i;\r\npl011_dma_probe(uap);\r\nsnprintf(uap->type, sizeof(uap->type), "PL011 rev%u", amba_rev(dev));\r\namba_ports[i] = uap;\r\namba_set_drvdata(dev, uap);\r\nret = uart_add_one_port(&amba_reg, &uap->port);\r\nif (ret) {\r\namba_set_drvdata(dev, NULL);\r\namba_ports[i] = NULL;\r\npl011_dma_remove(uap);\r\nclk_put(uap->clk);\r\nunmap:\r\niounmap(base);\r\nfree:\r\nkfree(uap);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pl011_remove(struct amba_device *dev)\r\n{\r\nstruct uart_amba_port *uap = amba_get_drvdata(dev);\r\nint i;\r\namba_set_drvdata(dev, NULL);\r\nuart_remove_one_port(&amba_reg, &uap->port);\r\nfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\r\nif (amba_ports[i] == uap)\r\namba_ports[i] = NULL;\r\npl011_dma_remove(uap);\r\niounmap(uap->port.membase);\r\nclk_put(uap->clk);\r\nkfree(uap);\r\nreturn 0;\r\n}\r\nstatic int pl011_suspend(struct amba_device *dev, pm_message_t state)\r\n{\r\nstruct uart_amba_port *uap = amba_get_drvdata(dev);\r\nif (!uap)\r\nreturn -EINVAL;\r\nreturn uart_suspend_port(&amba_reg, &uap->port);\r\n}\r\nstatic int pl011_resume(struct amba_device *dev)\r\n{\r\nstruct uart_amba_port *uap = amba_get_drvdata(dev);\r\nif (!uap)\r\nreturn -EINVAL;\r\nreturn uart_resume_port(&amba_reg, &uap->port);\r\n}\r\nstatic int __init pl011_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Serial: AMBA PL011 UART driver\n");\r\nret = uart_register_driver(&amba_reg);\r\nif (ret == 0) {\r\nret = amba_driver_register(&pl011_driver);\r\nif (ret)\r\nuart_unregister_driver(&amba_reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit pl011_exit(void)\r\n{\r\namba_driver_unregister(&pl011_driver);\r\nuart_unregister_driver(&amba_reg);\r\n}
