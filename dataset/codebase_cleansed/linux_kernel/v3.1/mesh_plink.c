static inline\r\nvoid mesh_plink_inc_estab_count(struct ieee80211_sub_if_data *sdata)\r\n{\r\natomic_inc(&sdata->u.mesh.mshstats.estab_plinks);\r\nmesh_accept_plinks_update(sdata);\r\n}\r\nstatic inline\r\nvoid mesh_plink_dec_estab_count(struct ieee80211_sub_if_data *sdata)\r\n{\r\natomic_dec(&sdata->u.mesh.mshstats.estab_plinks);\r\nmesh_accept_plinks_update(sdata);\r\n}\r\nstatic inline void mesh_plink_fsm_restart(struct sta_info *sta)\r\n{\r\nsta->plink_state = NL80211_PLINK_LISTEN;\r\nsta->llid = sta->plid = sta->reason = 0;\r\nsta->plink_retries = 0;\r\n}\r\nstatic struct sta_info *mesh_plink_alloc(struct ieee80211_sub_if_data *sdata,\r\nu8 *hw_addr, u32 rates)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nif (local->num_sta >= MESH_MAX_PLINKS)\r\nreturn NULL;\r\nsta = sta_info_alloc(sdata, hw_addr, GFP_KERNEL);\r\nif (!sta)\r\nreturn NULL;\r\nsta->flags = WLAN_STA_AUTHORIZED | WLAN_STA_AUTH;\r\nsta->sta.supp_rates[local->hw.conf.channel->band] = rates;\r\nrate_control_rate_init(sta);\r\nreturn sta;\r\n}\r\nstatic bool __mesh_plink_deactivate(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nbool deactivated = false;\r\nif (sta->plink_state == NL80211_PLINK_ESTAB) {\r\nmesh_plink_dec_estab_count(sdata);\r\ndeactivated = true;\r\n}\r\nsta->plink_state = NL80211_PLINK_BLOCKED;\r\nmesh_path_flush_by_nexthop(sta);\r\nreturn deactivated;\r\n}\r\nvoid mesh_plink_deactivate(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nbool deactivated;\r\nspin_lock_bh(&sta->lock);\r\ndeactivated = __mesh_plink_deactivate(sta);\r\nspin_unlock_bh(&sta->lock);\r\nif (deactivated)\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);\r\n}\r\nstatic int mesh_plink_frame_tx(struct ieee80211_sub_if_data *sdata,\r\nenum plink_frame_type action, u8 *da, __le16 llid, __le16 plid,\r\n__le16 reason) {\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb = dev_alloc_skb(local->hw.extra_tx_headroom + 400 +\r\nsdata->u.mesh.ie_len);\r\nstruct ieee80211_mgmt *mgmt;\r\nbool include_plid = false;\r\nstatic const u8 meshpeeringproto[] = { 0x00, 0x0F, 0xAC, 0x2A };\r\nu8 *pos;\r\nint ie_len;\r\nif (!skb)\r\nreturn -1;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nmgmt = (struct ieee80211_mgmt *)\r\nskb_put(skb, 25 + sizeof(mgmt->u.action.u.plink_action));\r\nmemset(mgmt, 0, 25 + sizeof(mgmt->u.action.u.plink_action));\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\nmemcpy(mgmt->da, da, ETH_ALEN);\r\nmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\r\nmgmt->u.action.category = WLAN_CATEGORY_MESH_ACTION;\r\nmgmt->u.action.u.plink_action.action_code = action;\r\nif (action == PLINK_CLOSE)\r\nmgmt->u.action.u.plink_action.aux = reason;\r\nelse {\r\nmgmt->u.action.u.plink_action.aux = cpu_to_le16(0x0);\r\nif (action == PLINK_CONFIRM) {\r\npos = skb_put(skb, 4);\r\nmemset(pos, 0, 2);\r\nmemcpy(pos + 2, &plid, 2);\r\n}\r\nmesh_mgmt_ies_add(skb, sdata);\r\n}\r\nswitch (action) {\r\ncase PLINK_OPEN:\r\nie_len = 6;\r\nbreak;\r\ncase PLINK_CONFIRM:\r\nie_len = 8;\r\ninclude_plid = true;\r\nbreak;\r\ncase PLINK_CLOSE:\r\ndefault:\r\nif (!plid)\r\nie_len = 8;\r\nelse {\r\nie_len = 10;\r\ninclude_plid = true;\r\n}\r\nbreak;\r\n}\r\npos = skb_put(skb, 2 + ie_len);\r\n*pos++ = WLAN_EID_PEER_LINK;\r\n*pos++ = ie_len;\r\nmemcpy(pos, meshpeeringproto, sizeof(meshpeeringproto));\r\npos += 4;\r\nmemcpy(pos, &llid, 2);\r\nif (include_plid) {\r\npos += 2;\r\nmemcpy(pos, &plid, 2);\r\n}\r\nif (action == PLINK_CLOSE) {\r\npos += 2;\r\nmemcpy(pos, &reason, 2);\r\n}\r\nieee80211_tx_skb(sdata, skb);\r\nreturn 0;\r\n}\r\nvoid mesh_neighbour_update(u8 *hw_addr, u32 rates,\r\nstruct ieee80211_sub_if_data *sdata,\r\nstruct ieee802_11_elems *elems)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nrcu_read_lock();\r\nsta = sta_info_get(sdata, hw_addr);\r\nif (!sta) {\r\nrcu_read_unlock();\r\nif (sdata->u.mesh.security & IEEE80211_MESH_SEC_AUTHED)\r\ncfg80211_notify_new_peer_candidate(sdata->dev, hw_addr,\r\nelems->ie_start, elems->total_len,\r\nGFP_KERNEL);\r\nelse\r\nsta = mesh_plink_alloc(sdata, hw_addr, rates);\r\nif (!sta)\r\nreturn;\r\nif (sta_info_insert_rcu(sta)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\n}\r\nsta->last_rx = jiffies;\r\nsta->sta.supp_rates[local->hw.conf.channel->band] = rates;\r\nif (mesh_peer_accepts_plinks(elems) &&\r\nsta->plink_state == NL80211_PLINK_LISTEN &&\r\nsdata->u.mesh.accepting_plinks &&\r\nsdata->u.mesh.mshcfg.auto_open_plinks)\r\nmesh_plink_open(sta);\r\nrcu_read_unlock();\r\n}\r\nstatic void mesh_plink_timer(unsigned long data)\r\n{\r\nstruct sta_info *sta;\r\n__le16 llid, plid, reason;\r\nstruct ieee80211_sub_if_data *sdata;\r\nsta = (struct sta_info *) data;\r\nif (sta->sdata->local->quiescing) {\r\nsta->plink_timer_was_running = true;\r\nreturn;\r\n}\r\nspin_lock_bh(&sta->lock);\r\nif (sta->ignore_plink_timer) {\r\nsta->ignore_plink_timer = false;\r\nspin_unlock_bh(&sta->lock);\r\nreturn;\r\n}\r\nmpl_dbg("Mesh plink timer for %pM fired on state %d\n",\r\nsta->sta.addr, sta->plink_state);\r\nreason = 0;\r\nllid = sta->llid;\r\nplid = sta->plid;\r\nsdata = sta->sdata;\r\nswitch (sta->plink_state) {\r\ncase NL80211_PLINK_OPN_RCVD:\r\ncase NL80211_PLINK_OPN_SNT:\r\nif (sta->plink_retries < dot11MeshMaxRetries(sdata)) {\r\nu32 rand;\r\nmpl_dbg("Mesh plink for %pM (retry, timeout): %d %d\n",\r\nsta->sta.addr, sta->plink_retries,\r\nsta->plink_timeout);\r\nget_random_bytes(&rand, sizeof(u32));\r\nsta->plink_timeout = sta->plink_timeout +\r\nrand % sta->plink_timeout;\r\n++sta->plink_retries;\r\nmod_plink_timer(sta, sta->plink_timeout);\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_OPEN, sta->sta.addr, llid,\r\n0, 0);\r\nbreak;\r\n}\r\nreason = cpu_to_le16(MESH_MAX_RETRIES);\r\ncase NL80211_PLINK_CNF_RCVD:\r\nif (!reason)\r\nreason = cpu_to_le16(MESH_CONFIRM_TIMEOUT);\r\nsta->plink_state = NL80211_PLINK_HOLDING;\r\nmod_plink_timer(sta, dot11MeshHoldingTimeout(sdata));\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_CLOSE, sta->sta.addr, llid, plid,\r\nreason);\r\nbreak;\r\ncase NL80211_PLINK_HOLDING:\r\ndel_timer(&sta->plink_timer);\r\nmesh_plink_fsm_restart(sta);\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\ndefault:\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\n}\r\n}\r\nvoid mesh_plink_quiesce(struct sta_info *sta)\r\n{\r\nif (del_timer_sync(&sta->plink_timer))\r\nsta->plink_timer_was_running = true;\r\n}\r\nvoid mesh_plink_restart(struct sta_info *sta)\r\n{\r\nif (sta->plink_timer_was_running) {\r\nadd_timer(&sta->plink_timer);\r\nsta->plink_timer_was_running = false;\r\n}\r\n}\r\nstatic inline void mesh_plink_timer_set(struct sta_info *sta, int timeout)\r\n{\r\nsta->plink_timer.expires = jiffies + (HZ * timeout / 1000);\r\nsta->plink_timer.data = (unsigned long) sta;\r\nsta->plink_timer.function = mesh_plink_timer;\r\nsta->plink_timeout = timeout;\r\nadd_timer(&sta->plink_timer);\r\n}\r\nint mesh_plink_open(struct sta_info *sta)\r\n{\r\n__le16 llid;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nif (!test_sta_flags(sta, WLAN_STA_AUTH))\r\nreturn -EPERM;\r\nspin_lock_bh(&sta->lock);\r\nget_random_bytes(&llid, 2);\r\nsta->llid = llid;\r\nif (sta->plink_state != NL80211_PLINK_LISTEN) {\r\nspin_unlock_bh(&sta->lock);\r\nreturn -EBUSY;\r\n}\r\nsta->plink_state = NL80211_PLINK_OPN_SNT;\r\nmesh_plink_timer_set(sta, dot11MeshRetryTimeout(sdata));\r\nspin_unlock_bh(&sta->lock);\r\nmpl_dbg("Mesh plink: starting establishment with %pM\n",\r\nsta->sta.addr);\r\nreturn mesh_plink_frame_tx(sdata, PLINK_OPEN,\r\nsta->sta.addr, llid, 0, 0);\r\n}\r\nvoid mesh_plink_block(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nbool deactivated;\r\nspin_lock_bh(&sta->lock);\r\ndeactivated = __mesh_plink_deactivate(sta);\r\nsta->plink_state = NL80211_PLINK_BLOCKED;\r\nspin_unlock_bh(&sta->lock);\r\nif (deactivated)\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);\r\n}\r\nvoid mesh_rx_plink_frame(struct ieee80211_sub_if_data *sdata, struct ieee80211_mgmt *mgmt,\r\nsize_t len, struct ieee80211_rx_status *rx_status)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee802_11_elems elems;\r\nstruct sta_info *sta;\r\nenum plink_event event;\r\nenum plink_frame_type ftype;\r\nsize_t baselen;\r\nbool deactivated, matches_local = true;\r\nu8 ie_len;\r\nu8 *baseaddr;\r\n__le16 plid, llid, reason;\r\n#ifdef CONFIG_MAC80211_VERBOSE_MPL_DEBUG\r\nstatic const char *mplstates[] = {\r\n[NL80211_PLINK_LISTEN] = "LISTEN",\r\n[NL80211_PLINK_OPN_SNT] = "OPN-SNT",\r\n[NL80211_PLINK_OPN_RCVD] = "OPN-RCVD",\r\n[NL80211_PLINK_CNF_RCVD] = "CNF_RCVD",\r\n[NL80211_PLINK_ESTAB] = "ESTAB",\r\n[NL80211_PLINK_HOLDING] = "HOLDING",\r\n[NL80211_PLINK_BLOCKED] = "BLOCKED"\r\n};\r\n#endif\r\nif (len < IEEE80211_MIN_ACTION_SIZE + 3)\r\nreturn;\r\nif (is_multicast_ether_addr(mgmt->da)) {\r\nmpl_dbg("Mesh plink: ignore frame from multicast address");\r\nreturn;\r\n}\r\nbaseaddr = mgmt->u.action.u.plink_action.variable;\r\nbaselen = (u8 *) mgmt->u.action.u.plink_action.variable - (u8 *) mgmt;\r\nif (mgmt->u.action.u.plink_action.action_code == PLINK_CONFIRM) {\r\nbaseaddr += 4;\r\nbaselen += 4;\r\n}\r\nieee802_11_parse_elems(baseaddr, len - baselen, &elems);\r\nif (!elems.peer_link) {\r\nmpl_dbg("Mesh plink: missing necessary peer link ie\n");\r\nreturn;\r\n}\r\nif (elems.rsn_len &&\r\nsdata->u.mesh.security == IEEE80211_MESH_SEC_NONE) {\r\nmpl_dbg("Mesh plink: can't establish link with secure peer\n");\r\nreturn;\r\n}\r\nftype = mgmt->u.action.u.plink_action.action_code;\r\nie_len = elems.peer_link_len;\r\nif ((ftype == PLINK_OPEN && ie_len != 6) ||\r\n(ftype == PLINK_CONFIRM && ie_len != 8) ||\r\n(ftype == PLINK_CLOSE && ie_len != 8 && ie_len != 10)) {\r\nmpl_dbg("Mesh plink: incorrect plink ie length %d %d\n",\r\nftype, ie_len);\r\nreturn;\r\n}\r\nif (ftype != PLINK_CLOSE && (!elems.mesh_id || !elems.mesh_config)) {\r\nmpl_dbg("Mesh plink: missing necessary ie\n");\r\nreturn;\r\n}\r\nmemcpy(&plid, PLINK_GET_LLID(elems.peer_link), 2);\r\nif (ftype == PLINK_CONFIRM || (ftype == PLINK_CLOSE && ie_len == 10))\r\nmemcpy(&llid, PLINK_GET_PLID(elems.peer_link), 2);\r\nrcu_read_lock();\r\nsta = sta_info_get(sdata, mgmt->sa);\r\nif (!sta && ftype != PLINK_OPEN) {\r\nmpl_dbg("Mesh plink: cls or cnf from unknown peer\n");\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif (sta && !test_sta_flags(sta, WLAN_STA_AUTH)) {\r\nmpl_dbg("Mesh plink: Action frame from non-authed peer\n");\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif (sta && sta->plink_state == NL80211_PLINK_BLOCKED) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nevent = PLINK_UNDEFINED;\r\nif (ftype != PLINK_CLOSE && (!mesh_matches_local(&elems, sdata))) {\r\nmatches_local = false;\r\nswitch (ftype) {\r\ncase PLINK_OPEN:\r\nevent = OPN_RJCT;\r\nbreak;\r\ncase PLINK_CONFIRM:\r\nevent = CNF_RJCT;\r\nbreak;\r\ncase PLINK_CLOSE:\r\nbreak;\r\n}\r\n}\r\nif (!sta && !matches_local) {\r\nrcu_read_unlock();\r\nreason = cpu_to_le16(MESH_CAPABILITY_POLICY_VIOLATION);\r\nllid = 0;\r\nmesh_plink_frame_tx(sdata, PLINK_CLOSE, mgmt->sa, llid,\r\nplid, reason);\r\nreturn;\r\n} else if (!sta) {\r\nu32 rates;\r\nrcu_read_unlock();\r\nif (!mesh_plink_free_count(sdata)) {\r\nmpl_dbg("Mesh plink error: no more free plinks\n");\r\nreturn;\r\n}\r\nrates = ieee80211_sta_get_rates(local, &elems, rx_status->band);\r\nsta = mesh_plink_alloc(sdata, mgmt->sa, rates);\r\nif (!sta) {\r\nmpl_dbg("Mesh plink error: plink table full\n");\r\nreturn;\r\n}\r\nif (sta_info_insert_rcu(sta)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nevent = OPN_ACPT;\r\nspin_lock_bh(&sta->lock);\r\n} else if (matches_local) {\r\nspin_lock_bh(&sta->lock);\r\nswitch (ftype) {\r\ncase PLINK_OPEN:\r\nif (!mesh_plink_free_count(sdata) ||\r\n(sta->plid && sta->plid != plid))\r\nevent = OPN_IGNR;\r\nelse\r\nevent = OPN_ACPT;\r\nbreak;\r\ncase PLINK_CONFIRM:\r\nif (!mesh_plink_free_count(sdata) ||\r\n(sta->llid != llid || sta->plid != plid))\r\nevent = CNF_IGNR;\r\nelse\r\nevent = CNF_ACPT;\r\nbreak;\r\ncase PLINK_CLOSE:\r\nif (sta->plink_state == NL80211_PLINK_ESTAB)\r\nevent = CLS_ACPT;\r\nelse if (sta->plid != plid)\r\nevent = CLS_IGNR;\r\nelse if (ie_len == 7 && sta->llid != llid)\r\nevent = CLS_IGNR;\r\nelse\r\nevent = CLS_ACPT;\r\nbreak;\r\ndefault:\r\nmpl_dbg("Mesh plink: unknown frame subtype\n");\r\nspin_unlock_bh(&sta->lock);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\n} else {\r\nspin_lock_bh(&sta->lock);\r\n}\r\nmpl_dbg("Mesh plink (peer, state, llid, plid, event): %pM %s %d %d %d\n",\r\nmgmt->sa, mplstates[sta->plink_state],\r\nle16_to_cpu(sta->llid), le16_to_cpu(sta->plid),\r\nevent);\r\nreason = 0;\r\nswitch (sta->plink_state) {\r\ncase NL80211_PLINK_LISTEN:\r\nswitch (event) {\r\ncase CLS_ACPT:\r\nmesh_plink_fsm_restart(sta);\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\ncase OPN_ACPT:\r\nsta->plink_state = NL80211_PLINK_OPN_RCVD;\r\nsta->plid = plid;\r\nget_random_bytes(&llid, 2);\r\nsta->llid = llid;\r\nmesh_plink_timer_set(sta, dot11MeshRetryTimeout(sdata));\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_OPEN, sta->sta.addr, llid,\r\n0, 0);\r\nmesh_plink_frame_tx(sdata, PLINK_CONFIRM, sta->sta.addr,\r\nllid, plid, 0);\r\nbreak;\r\ndefault:\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_OPN_SNT:\r\nswitch (event) {\r\ncase OPN_RJCT:\r\ncase CNF_RJCT:\r\nreason = cpu_to_le16(MESH_CAPABILITY_POLICY_VIOLATION);\r\ncase CLS_ACPT:\r\nif (!reason)\r\nreason = cpu_to_le16(MESH_CLOSE_RCVD);\r\nsta->reason = reason;\r\nsta->plink_state = NL80211_PLINK_HOLDING;\r\nif (!mod_plink_timer(sta,\r\ndot11MeshHoldingTimeout(sdata)))\r\nsta->ignore_plink_timer = true;\r\nllid = sta->llid;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_CLOSE, sta->sta.addr, llid,\r\nplid, reason);\r\nbreak;\r\ncase OPN_ACPT:\r\nsta->plink_state = NL80211_PLINK_OPN_RCVD;\r\nsta->plid = plid;\r\nllid = sta->llid;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_CONFIRM, sta->sta.addr, llid,\r\nplid, 0);\r\nbreak;\r\ncase CNF_ACPT:\r\nsta->plink_state = NL80211_PLINK_CNF_RCVD;\r\nif (!mod_plink_timer(sta,\r\ndot11MeshConfirmTimeout(sdata)))\r\nsta->ignore_plink_timer = true;\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\ndefault:\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_OPN_RCVD:\r\nswitch (event) {\r\ncase OPN_RJCT:\r\ncase CNF_RJCT:\r\nreason = cpu_to_le16(MESH_CAPABILITY_POLICY_VIOLATION);\r\ncase CLS_ACPT:\r\nif (!reason)\r\nreason = cpu_to_le16(MESH_CLOSE_RCVD);\r\nsta->reason = reason;\r\nsta->plink_state = NL80211_PLINK_HOLDING;\r\nif (!mod_plink_timer(sta,\r\ndot11MeshHoldingTimeout(sdata)))\r\nsta->ignore_plink_timer = true;\r\nllid = sta->llid;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_CLOSE, sta->sta.addr, llid,\r\nplid, reason);\r\nbreak;\r\ncase OPN_ACPT:\r\nllid = sta->llid;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_CONFIRM, sta->sta.addr, llid,\r\nplid, 0);\r\nbreak;\r\ncase CNF_ACPT:\r\ndel_timer(&sta->plink_timer);\r\nsta->plink_state = NL80211_PLINK_ESTAB;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_inc_estab_count(sdata);\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);\r\nmpl_dbg("Mesh plink with %pM ESTABLISHED\n",\r\nsta->sta.addr);\r\nbreak;\r\ndefault:\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_CNF_RCVD:\r\nswitch (event) {\r\ncase OPN_RJCT:\r\ncase CNF_RJCT:\r\nreason = cpu_to_le16(MESH_CAPABILITY_POLICY_VIOLATION);\r\ncase CLS_ACPT:\r\nif (!reason)\r\nreason = cpu_to_le16(MESH_CLOSE_RCVD);\r\nsta->reason = reason;\r\nsta->plink_state = NL80211_PLINK_HOLDING;\r\nif (!mod_plink_timer(sta,\r\ndot11MeshHoldingTimeout(sdata)))\r\nsta->ignore_plink_timer = true;\r\nllid = sta->llid;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_CLOSE, sta->sta.addr, llid,\r\nplid, reason);\r\nbreak;\r\ncase OPN_ACPT:\r\ndel_timer(&sta->plink_timer);\r\nsta->plink_state = NL80211_PLINK_ESTAB;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_inc_estab_count(sdata);\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);\r\nmpl_dbg("Mesh plink with %pM ESTABLISHED\n",\r\nsta->sta.addr);\r\nmesh_plink_frame_tx(sdata, PLINK_CONFIRM, sta->sta.addr, llid,\r\nplid, 0);\r\nbreak;\r\ndefault:\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_ESTAB:\r\nswitch (event) {\r\ncase CLS_ACPT:\r\nreason = cpu_to_le16(MESH_CLOSE_RCVD);\r\nsta->reason = reason;\r\ndeactivated = __mesh_plink_deactivate(sta);\r\nsta->plink_state = NL80211_PLINK_HOLDING;\r\nllid = sta->llid;\r\nmod_plink_timer(sta, dot11MeshHoldingTimeout(sdata));\r\nspin_unlock_bh(&sta->lock);\r\nif (deactivated)\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);\r\nmesh_plink_frame_tx(sdata, PLINK_CLOSE, sta->sta.addr, llid,\r\nplid, reason);\r\nbreak;\r\ncase OPN_ACPT:\r\nllid = sta->llid;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_CONFIRM, sta->sta.addr, llid,\r\nplid, 0);\r\nbreak;\r\ndefault:\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_HOLDING:\r\nswitch (event) {\r\ncase CLS_ACPT:\r\nif (del_timer(&sta->plink_timer))\r\nsta->ignore_plink_timer = 1;\r\nmesh_plink_fsm_restart(sta);\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\ncase OPN_ACPT:\r\ncase CNF_ACPT:\r\ncase OPN_RJCT:\r\ncase CNF_RJCT:\r\nllid = sta->llid;\r\nreason = sta->reason;\r\nspin_unlock_bh(&sta->lock);\r\nmesh_plink_frame_tx(sdata, PLINK_CLOSE, sta->sta.addr,\r\nllid, plid, reason);\r\nbreak;\r\ndefault:\r\nspin_unlock_bh(&sta->lock);\r\n}\r\nbreak;\r\ndefault:\r\nspin_unlock_bh(&sta->lock);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\n}
