static inline int IN_FROM_REG(int reg, int nominal, int res)\r\n{\r\nreturn (reg * nominal + (3 << (res - 3))) / (3 << (res - 2));\r\n}\r\nstatic inline int IN_TO_REG(int val, int nominal)\r\n{\r\nreturn SENSORS_LIMIT((val * 192 + nominal / 2) / nominal, 0, 255);\r\n}\r\nstatic inline int TEMP_FROM_REG(int reg, int res)\r\n{\r\nreturn (reg * 1000) >> (res - 8);\r\n}\r\nstatic inline int TEMP_TO_REG(int val)\r\n{\r\nreturn SENSORS_LIMIT((val < 0 ? val - 500 : val + 500) / 1000,\r\n-128, 127);\r\n}\r\nstatic inline int TEMP_RANGE_FROM_REG(int reg)\r\n{\r\nreturn TEMP_RANGE[(reg >> 4) & 0x0f];\r\n}\r\nstatic int TEMP_RANGE_TO_REG(int val, int reg)\r\n{\r\nint i;\r\nfor (i = 15; i > 0; i--) {\r\nif (val > (TEMP_RANGE[i] + TEMP_RANGE[i - 1] + 1) / 2) {\r\nbreak;\r\n}\r\n}\r\nreturn (reg & 0x0f) | (i << 4);\r\n}\r\nstatic inline int TEMP_HYST_FROM_REG(int reg, int ix)\r\n{\r\nreturn (((ix == 1) ? reg : reg >> 4) & 0x0f) * 1000;\r\n}\r\nstatic inline int TEMP_HYST_TO_REG(int val, int ix, int reg)\r\n{\r\nint hyst = SENSORS_LIMIT((val + 500) / 1000, 0, 15);\r\nreturn (ix == 1) ? (reg & 0xf0) | hyst : (reg & 0x0f) | (hyst << 4);\r\n}\r\nstatic inline int FAN_FROM_REG(int reg, int tpc)\r\n{\r\nif (tpc) {\r\nreturn tpc * reg;\r\n} else {\r\nreturn (reg == 0 || reg == 0xffff) ? 0 : 90000 * 60 / reg;\r\n}\r\n}\r\nstatic inline int FAN_TO_REG(int val, int tpc)\r\n{\r\nif (tpc) {\r\nreturn SENSORS_LIMIT(val / tpc, 0, 0xffff);\r\n} else {\r\nreturn (val <= 0) ? 0xffff :\r\nSENSORS_LIMIT(90000 * 60 / val, 0, 0xfffe);\r\n}\r\n}\r\nstatic inline int FAN_TPC_FROM_REG(int reg)\r\n{\r\nreturn (reg & 0x20) ? 0 : 60 >> (reg & 0x03);\r\n}\r\nstatic inline int FAN_TYPE_FROM_REG(int reg)\r\n{\r\nint edge = (reg >> 1) & 0x03;\r\nreturn (edge > 0) ? 1 << (edge - 1) : 0;\r\n}\r\nstatic inline int FAN_TYPE_TO_REG(int val, int reg)\r\n{\r\nint edge = (val == 4) ? 3 : val;\r\nreturn (reg & 0xf9) | (edge << 1);\r\n}\r\nstatic int FAN_MAX_FROM_REG(int reg)\r\n{\r\nint i;\r\nfor (i = 10; i > 0; i--) {\r\nif (reg == FAN_MAX[i]) {\r\nbreak;\r\n}\r\n}\r\nreturn 1000 + i * 500;\r\n}\r\nstatic int FAN_MAX_TO_REG(int val)\r\n{\r\nint i;\r\nfor (i = 10; i > 0; i--) {\r\nif (val > (1000 + (i - 1) * 500)) {\r\nbreak;\r\n}\r\n}\r\nreturn FAN_MAX[i];\r\n}\r\nstatic inline int PWM_EN_FROM_REG(int reg)\r\n{\r\nstatic const int en[] = {2, 2, 2, 0, -1, 2, 2, 1};\r\nreturn en[(reg >> 5) & 0x07];\r\n}\r\nstatic inline int PWM_EN_TO_REG(int val, int reg)\r\n{\r\nint en = (val == 1) ? 7 : 3;\r\nreturn (reg & 0x1f) | ((en & 0x07) << 5);\r\n}\r\nstatic inline int PWM_ACZ_FROM_REG(int reg)\r\n{\r\nstatic const int acz[] = {1, 2, 4, 0, 0, 6, 7, 0};\r\nreturn acz[(reg >> 5) & 0x07];\r\n}\r\nstatic inline int PWM_ACZ_TO_REG(int val, int reg)\r\n{\r\nint acz = (val == 4) ? 2 : val - 1;\r\nreturn (reg & 0x1f) | ((acz & 0x07) << 5);\r\n}\r\nstatic inline int PWM_FREQ_FROM_REG(int reg)\r\n{\r\nreturn PWM_FREQ[reg & 0x0f];\r\n}\r\nstatic int PWM_FREQ_TO_REG(int val, int reg)\r\n{\r\nint i;\r\nif (val > 27500) {\r\ni = 10;\r\n} else if (val > 22500) {\r\ni = 11;\r\n} else {\r\nfor (i = 9; i > 0; i--) {\r\nif (val > (PWM_FREQ[i] + PWM_FREQ[i - 1] + 1) / 2) {\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn (reg & 0xf0) | i;\r\n}\r\nstatic inline int PWM_RR_FROM_REG(int reg, int ix)\r\n{\r\nint rr = (ix == 1) ? reg >> 4 : reg;\r\nreturn (rr & 0x08) ? PWM_RR[rr & 0x07] : 0;\r\n}\r\nstatic int PWM_RR_TO_REG(int val, int ix, int reg)\r\n{\r\nint i;\r\nfor (i = 0; i < 7; i++) {\r\nif (val > (PWM_RR[i] + PWM_RR[i + 1] + 1) / 2) {\r\nbreak;\r\n}\r\n}\r\nreturn (ix == 1) ? (reg & 0x8f) | (i << 4) : (reg & 0xf8) | i;\r\n}\r\nstatic inline int PWM_RR_EN_FROM_REG(int reg, int ix)\r\n{\r\nreturn PWM_RR_FROM_REG(reg, ix) ? 1 : 0;\r\n}\r\nstatic inline int PWM_RR_EN_TO_REG(int val, int ix, int reg)\r\n{\r\nint en = (ix == 1) ? 0x80 : 0x08;\r\nreturn val ? reg | en : reg & ~en;\r\n}\r\nstatic inline int PWM_OFF_FROM_REG(int reg, int ix)\r\n{\r\nreturn (reg >> (ix + 5)) & 0x01;\r\n}\r\nstatic inline int PWM_OFF_TO_REG(int val, int ix, int reg)\r\n{\r\nreturn (reg & ~(1 << (ix + 5))) | ((val & 0x01) << (ix + 5));\r\n}\r\nstatic u8 dme1737_read(const struct dme1737_data *data, u8 reg)\r\n{\r\nstruct i2c_client *client = data->client;\r\ns32 val;\r\nif (client) {\r\nval = i2c_smbus_read_byte_data(client, reg);\r\nif (val < 0) {\r\ndev_warn(&client->dev, "Read from register "\r\n"0x%02x failed! Please report to the driver "\r\n"maintainer.\n", reg);\r\n}\r\n} else {\r\noutb(reg, data->addr);\r\nval = inb(data->addr + 1);\r\n}\r\nreturn val;\r\n}\r\nstatic s32 dme1737_write(const struct dme1737_data *data, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = data->client;\r\ns32 res = 0;\r\nif (client) {\r\nres = i2c_smbus_write_byte_data(client, reg, val);\r\nif (res < 0) {\r\ndev_warn(&client->dev, "Write to register "\r\n"0x%02x failed! Please report to the driver "\r\n"maintainer.\n", reg);\r\n}\r\n} else {\r\noutb(reg, data->addr);\r\noutb(val, data->addr + 1);\r\n}\r\nreturn res;\r\n}\r\nstatic struct dme1737_data *dme1737_update_device(struct device *dev)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nint ix;\r\nu8 lsb[6];\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_vbat + 600 * HZ) || !data->valid) {\r\ndme1737_write(data, DME1737_REG_CONFIG, dme1737_read(data,\r\nDME1737_REG_CONFIG) | 0x10);\r\ndata->last_vbat = jiffies;\r\n}\r\nif (time_after(jiffies, data->last_update + HZ) || !data->valid) {\r\nif (data->has_features & HAS_VID) {\r\ndata->vid = dme1737_read(data, DME1737_REG_VID) &\r\n0x3f;\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->in); ix++) {\r\nif (ix == 7 && !(data->has_features & HAS_IN7)) {\r\ncontinue;\r\n}\r\ndata->in[ix] = dme1737_read(data,\r\nDME1737_REG_IN(ix)) << 8;\r\ndata->in_min[ix] = dme1737_read(data,\r\nDME1737_REG_IN_MIN(ix));\r\ndata->in_max[ix] = dme1737_read(data,\r\nDME1737_REG_IN_MAX(ix));\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->temp); ix++) {\r\ndata->temp[ix] = dme1737_read(data,\r\nDME1737_REG_TEMP(ix)) << 8;\r\ndata->temp_min[ix] = dme1737_read(data,\r\nDME1737_REG_TEMP_MIN(ix));\r\ndata->temp_max[ix] = dme1737_read(data,\r\nDME1737_REG_TEMP_MAX(ix));\r\nif (data->has_features & HAS_TEMP_OFFSET) {\r\ndata->temp_offset[ix] = dme1737_read(data,\r\nDME1737_REG_TEMP_OFFSET(ix));\r\n}\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(lsb); ix++) {\r\nif (ix == 5 && !(data->has_features & HAS_IN7)) {\r\ncontinue;\r\n}\r\nlsb[ix] = dme1737_read(data,\r\nDME1737_REG_IN_TEMP_LSB(ix));\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->in); ix++) {\r\nif (ix == 7 && !(data->has_features & HAS_IN7)) {\r\ncontinue;\r\n}\r\ndata->in[ix] |= (lsb[DME1737_REG_IN_LSB[ix]] <<\r\nDME1737_REG_IN_LSB_SHL[ix]) & 0xf0;\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->temp); ix++) {\r\ndata->temp[ix] |= (lsb[DME1737_REG_TEMP_LSB[ix]] <<\r\nDME1737_REG_TEMP_LSB_SHL[ix]) & 0xf0;\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->fan); ix++) {\r\nif (!(data->has_features & HAS_FAN(ix))) {\r\ncontinue;\r\n}\r\ndata->fan[ix] = dme1737_read(data,\r\nDME1737_REG_FAN(ix));\r\ndata->fan[ix] |= dme1737_read(data,\r\nDME1737_REG_FAN(ix) + 1) << 8;\r\ndata->fan_min[ix] = dme1737_read(data,\r\nDME1737_REG_FAN_MIN(ix));\r\ndata->fan_min[ix] |= dme1737_read(data,\r\nDME1737_REG_FAN_MIN(ix) + 1) << 8;\r\ndata->fan_opt[ix] = dme1737_read(data,\r\nDME1737_REG_FAN_OPT(ix));\r\nif (ix > 3) {\r\ndata->fan_max[ix - 4] = dme1737_read(data,\r\nDME1737_REG_FAN_MAX(ix));\r\n}\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->pwm); ix++) {\r\nif (!(data->has_features & HAS_PWM(ix))) {\r\ncontinue;\r\n}\r\ndata->pwm[ix] = dme1737_read(data,\r\nDME1737_REG_PWM(ix));\r\ndata->pwm_freq[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_FREQ(ix));\r\nif (ix < 3) {\r\ndata->pwm_config[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_CONFIG(ix));\r\ndata->pwm_min[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_MIN(ix));\r\n}\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->pwm_rr); ix++) {\r\ndata->pwm_rr[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_RR(ix));\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->zone_low); ix++) {\r\nif ((ix == 2) && !(data->has_features & HAS_ZONE3)) {\r\ncontinue;\r\n}\r\nif ((ix == 1) && (data->type == sch5127)) {\r\ndata->zone_low[1] = dme1737_read(data,\r\nDME1737_REG_ZONE_LOW(2));\r\ndata->zone_abs[1] = dme1737_read(data,\r\nDME1737_REG_ZONE_ABS(2));\r\n} else {\r\ndata->zone_low[ix] = dme1737_read(data,\r\nDME1737_REG_ZONE_LOW(ix));\r\ndata->zone_abs[ix] = dme1737_read(data,\r\nDME1737_REG_ZONE_ABS(ix));\r\n}\r\n}\r\nif (data->has_features & HAS_ZONE_HYST) {\r\nfor (ix = 0; ix < ARRAY_SIZE(data->zone_hyst); ix++) {\r\ndata->zone_hyst[ix] = dme1737_read(data,\r\nDME1737_REG_ZONE_HYST(ix));\r\n}\r\n}\r\ndata->alarms = dme1737_read(data,\r\nDME1737_REG_ALARM1);\r\nif (data->alarms & 0x80) {\r\ndata->alarms |= dme1737_read(data,\r\nDME1737_REG_ALARM2) << 8;\r\ndata->alarms |= dme1737_read(data,\r\nDME1737_REG_ALARM3) << 16;\r\n}\r\nif (!data->client) {\r\nif (data->alarms & 0xff0000) {\r\ndme1737_write(data, DME1737_REG_ALARM3,\r\n0xff);\r\n}\r\nif (data->alarms & 0xff00) {\r\ndme1737_write(data, DME1737_REG_ALARM2,\r\n0xff);\r\n}\r\nif (data->alarms & 0xff) {\r\ndme1737_write(data, DME1737_REG_ALARM1,\r\n0xff);\r\n}\r\n}\r\ndata->last_update = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dme1737_data *data = dme1737_update_device(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SYS_IN_INPUT:\r\nres = IN_FROM_REG(data->in[ix], data->in_nominal[ix], 16);\r\nbreak;\r\ncase SYS_IN_MIN:\r\nres = IN_FROM_REG(data->in_min[ix], data->in_nominal[ix], 8);\r\nbreak;\r\ncase SYS_IN_MAX:\r\nres = IN_FROM_REG(data->in_max[ix], data->in_nominal[ix], 8);\r\nbreak;\r\ncase SYS_IN_ALARM:\r\nres = (data->alarms >> DME1737_BIT_ALARM_IN[ix]) & 0x01;\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_in(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nlong val = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\nswitch (fn) {\r\ncase SYS_IN_MIN:\r\ndata->in_min[ix] = IN_TO_REG(val, data->in_nominal[ix]);\r\ndme1737_write(data, DME1737_REG_IN_MIN(ix),\r\ndata->in_min[ix]);\r\nbreak;\r\ncase SYS_IN_MAX:\r\ndata->in_max[ix] = IN_TO_REG(val, data->in_nominal[ix]);\r\ndme1737_write(data, DME1737_REG_IN_MAX(ix),\r\ndata->in_max[ix]);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dme1737_data *data = dme1737_update_device(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SYS_TEMP_INPUT:\r\nres = TEMP_FROM_REG(data->temp[ix], 16);\r\nbreak;\r\ncase SYS_TEMP_MIN:\r\nres = TEMP_FROM_REG(data->temp_min[ix], 8);\r\nbreak;\r\ncase SYS_TEMP_MAX:\r\nres = TEMP_FROM_REG(data->temp_max[ix], 8);\r\nbreak;\r\ncase SYS_TEMP_OFFSET:\r\nres = TEMP_FROM_REG(data->temp_offset[ix], 8);\r\nbreak;\r\ncase SYS_TEMP_ALARM:\r\nres = (data->alarms >> DME1737_BIT_ALARM_TEMP[ix]) & 0x01;\r\nbreak;\r\ncase SYS_TEMP_FAULT:\r\nres = (((u16)data->temp[ix] & 0xff00) == 0x8000);\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nlong val = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\nswitch (fn) {\r\ncase SYS_TEMP_MIN:\r\ndata->temp_min[ix] = TEMP_TO_REG(val);\r\ndme1737_write(data, DME1737_REG_TEMP_MIN(ix),\r\ndata->temp_min[ix]);\r\nbreak;\r\ncase SYS_TEMP_MAX:\r\ndata->temp_max[ix] = TEMP_TO_REG(val);\r\ndme1737_write(data, DME1737_REG_TEMP_MAX(ix),\r\ndata->temp_max[ix]);\r\nbreak;\r\ncase SYS_TEMP_OFFSET:\r\ndata->temp_offset[ix] = TEMP_TO_REG(val);\r\ndme1737_write(data, DME1737_REG_TEMP_OFFSET(ix),\r\ndata->temp_offset[ix]);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_zone(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dme1737_data *data = dme1737_update_device(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SYS_ZONE_AUTO_CHANNELS_TEMP:\r\nif ((ix == 1) && (data->config2 & 0x02)) {\r\nres = 4;\r\n} else {\r\nres = 1 << ix;\r\n}\r\nbreak;\r\ncase SYS_ZONE_AUTO_POINT1_TEMP_HYST:\r\nres = TEMP_FROM_REG(data->zone_low[ix], 8) -\r\nTEMP_HYST_FROM_REG(data->zone_hyst[ix == 2], ix);\r\nbreak;\r\ncase SYS_ZONE_AUTO_POINT1_TEMP:\r\nres = TEMP_FROM_REG(data->zone_low[ix], 8);\r\nbreak;\r\ncase SYS_ZONE_AUTO_POINT2_TEMP:\r\nres = TEMP_FROM_REG(data->zone_low[ix], 8) +\r\nTEMP_RANGE_FROM_REG(data->pwm_freq[ix]);\r\nbreak;\r\ncase SYS_ZONE_AUTO_POINT3_TEMP:\r\nres = TEMP_FROM_REG(data->zone_abs[ix], 8);\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_zone(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nlong val = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\nswitch (fn) {\r\ncase SYS_ZONE_AUTO_POINT1_TEMP_HYST:\r\ndata->zone_low[ix] = dme1737_read(data,\r\nDME1737_REG_ZONE_LOW(ix));\r\ndata->zone_hyst[ix == 2] = TEMP_HYST_TO_REG(\r\nTEMP_FROM_REG(data->zone_low[ix], 8) -\r\nval, ix, dme1737_read(data,\r\nDME1737_REG_ZONE_HYST(ix == 2)));\r\ndme1737_write(data, DME1737_REG_ZONE_HYST(ix == 2),\r\ndata->zone_hyst[ix == 2]);\r\nbreak;\r\ncase SYS_ZONE_AUTO_POINT1_TEMP:\r\ndata->zone_low[ix] = TEMP_TO_REG(val);\r\ndme1737_write(data, DME1737_REG_ZONE_LOW(ix),\r\ndata->zone_low[ix]);\r\nbreak;\r\ncase SYS_ZONE_AUTO_POINT2_TEMP:\r\ndata->zone_low[ix] = dme1737_read(data,\r\nDME1737_REG_ZONE_LOW(ix));\r\ndata->pwm_freq[ix] = TEMP_RANGE_TO_REG(val -\r\nTEMP_FROM_REG(data->zone_low[ix], 8),\r\ndme1737_read(data,\r\nDME1737_REG_PWM_FREQ(ix)));\r\ndme1737_write(data, DME1737_REG_PWM_FREQ(ix),\r\ndata->pwm_freq[ix]);\r\nbreak;\r\ncase SYS_ZONE_AUTO_POINT3_TEMP:\r\ndata->zone_abs[ix] = TEMP_TO_REG(val);\r\ndme1737_write(data, DME1737_REG_ZONE_ABS(ix),\r\ndata->zone_abs[ix]);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dme1737_data *data = dme1737_update_device(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SYS_FAN_INPUT:\r\nres = FAN_FROM_REG(data->fan[ix],\r\nix < 4 ? 0 :\r\nFAN_TPC_FROM_REG(data->fan_opt[ix]));\r\nbreak;\r\ncase SYS_FAN_MIN:\r\nres = FAN_FROM_REG(data->fan_min[ix],\r\nix < 4 ? 0 :\r\nFAN_TPC_FROM_REG(data->fan_opt[ix]));\r\nbreak;\r\ncase SYS_FAN_MAX:\r\nres = FAN_MAX_FROM_REG(data->fan_max[ix - 4]);\r\nbreak;\r\ncase SYS_FAN_ALARM:\r\nres = (data->alarms >> DME1737_BIT_ALARM_FAN[ix]) & 0x01;\r\nbreak;\r\ncase SYS_FAN_TYPE:\r\nres = FAN_TYPE_FROM_REG(data->fan_opt[ix]);\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nlong val = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\nswitch (fn) {\r\ncase SYS_FAN_MIN:\r\nif (ix < 4) {\r\ndata->fan_min[ix] = FAN_TO_REG(val, 0);\r\n} else {\r\ndata->fan_opt[ix] = dme1737_read(data,\r\nDME1737_REG_FAN_OPT(ix));\r\ndata->fan_min[ix] = FAN_TO_REG(val,\r\nFAN_TPC_FROM_REG(data->fan_opt[ix]));\r\n}\r\ndme1737_write(data, DME1737_REG_FAN_MIN(ix),\r\ndata->fan_min[ix] & 0xff);\r\ndme1737_write(data, DME1737_REG_FAN_MIN(ix) + 1,\r\ndata->fan_min[ix] >> 8);\r\nbreak;\r\ncase SYS_FAN_MAX:\r\ndata->fan_max[ix - 4] = FAN_MAX_TO_REG(val);\r\ndme1737_write(data, DME1737_REG_FAN_MAX(ix),\r\ndata->fan_max[ix - 4]);\r\nbreak;\r\ncase SYS_FAN_TYPE:\r\nif (!(val == 1 || val == 2 || val == 4)) {\r\ncount = -EINVAL;\r\ndev_warn(dev, "Fan type value %ld not "\r\n"supported. Choose one of 1, 2, or 4.\n",\r\nval);\r\ngoto exit;\r\n}\r\ndata->fan_opt[ix] = FAN_TYPE_TO_REG(val, dme1737_read(data,\r\nDME1737_REG_FAN_OPT(ix)));\r\ndme1737_write(data, DME1737_REG_FAN_OPT(ix),\r\ndata->fan_opt[ix]);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nexit:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dme1737_data *data = dme1737_update_device(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SYS_PWM:\r\nif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 0) {\r\nres = 255;\r\n} else {\r\nres = data->pwm[ix];\r\n}\r\nbreak;\r\ncase SYS_PWM_FREQ:\r\nres = PWM_FREQ_FROM_REG(data->pwm_freq[ix]);\r\nbreak;\r\ncase SYS_PWM_ENABLE:\r\nif (ix >= 3) {\r\nres = 1;\r\n} else {\r\nres = PWM_EN_FROM_REG(data->pwm_config[ix]);\r\n}\r\nbreak;\r\ncase SYS_PWM_RAMP_RATE:\r\nres = PWM_RR_FROM_REG(data->pwm_rr[ix > 0], ix);\r\nbreak;\r\ncase SYS_PWM_AUTO_CHANNELS_ZONE:\r\nif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 2) {\r\nres = PWM_ACZ_FROM_REG(data->pwm_config[ix]);\r\n} else {\r\nres = data->pwm_acz[ix];\r\n}\r\nbreak;\r\ncase SYS_PWM_AUTO_PWM_MIN:\r\nif (PWM_OFF_FROM_REG(data->pwm_rr[0], ix)) {\r\nres = data->pwm_min[ix];\r\n} else {\r\nres = 0;\r\n}\r\nbreak;\r\ncase SYS_PWM_AUTO_POINT1_PWM:\r\nres = data->pwm_min[ix];\r\nbreak;\r\ncase SYS_PWM_AUTO_POINT2_PWM:\r\nres = 255;\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2\r\n*sensor_attr_2 = to_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nlong val = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\nswitch (fn) {\r\ncase SYS_PWM:\r\ndata->pwm[ix] = SENSORS_LIMIT(val, 0, 255);\r\ndme1737_write(data, DME1737_REG_PWM(ix), data->pwm[ix]);\r\nbreak;\r\ncase SYS_PWM_FREQ:\r\ndata->pwm_freq[ix] = PWM_FREQ_TO_REG(val, dme1737_read(data,\r\nDME1737_REG_PWM_FREQ(ix)));\r\ndme1737_write(data, DME1737_REG_PWM_FREQ(ix),\r\ndata->pwm_freq[ix]);\r\nbreak;\r\ncase SYS_PWM_ENABLE:\r\nif (val < 0 || val > 2) {\r\ncount = -EINVAL;\r\ndev_warn(dev, "PWM enable %ld not "\r\n"supported. Choose one of 0, 1, or 2.\n",\r\nval);\r\ngoto exit;\r\n}\r\ndata->pwm_config[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_CONFIG(ix));\r\nif (val == PWM_EN_FROM_REG(data->pwm_config[ix])) {\r\ngoto exit;\r\n}\r\nif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 2) {\r\ndata->pwm_acz[ix] = PWM_ACZ_FROM_REG(\r\ndata->pwm_config[ix]);\r\ndata->pwm_rr[ix > 0] = dme1737_read(data,\r\nDME1737_REG_PWM_RR(ix > 0));\r\ndata->pwm_rr_en &= ~(1 << ix);\r\nif (PWM_RR_EN_FROM_REG(data->pwm_rr[ix > 0], ix)) {\r\ndata->pwm_rr_en |= (1 << ix);\r\ndata->pwm_rr[ix > 0] = PWM_RR_EN_TO_REG(0, ix,\r\ndata->pwm_rr[ix > 0]);\r\ndme1737_write(data,\r\nDME1737_REG_PWM_RR(ix > 0),\r\ndata->pwm_rr[ix > 0]);\r\n}\r\n}\r\nswitch (val) {\r\ncase 0:\r\ndme1737_chmod_file(dev, dme1737_pwm_chmod_attr[ix],\r\nS_IRUGO);\r\ndata->pwm_config[ix] = PWM_EN_TO_REG(0,\r\ndata->pwm_config[ix]);\r\ndme1737_write(data, DME1737_REG_PWM_CONFIG(ix),\r\ndata->pwm_config[ix]);\r\nbreak;\r\ncase 1:\r\ndata->pwm_config[ix] = PWM_EN_TO_REG(1,\r\ndata->pwm_config[ix]);\r\ndme1737_write(data, DME1737_REG_PWM_CONFIG(ix),\r\ndata->pwm_config[ix]);\r\ndme1737_chmod_file(dev, dme1737_pwm_chmod_attr[ix],\r\nS_IRUGO | S_IWUSR);\r\nbreak;\r\ncase 2:\r\ndme1737_chmod_file(dev, dme1737_pwm_chmod_attr[ix],\r\nS_IRUGO);\r\ndata->pwm_config[ix] = PWM_ACZ_TO_REG(\r\ndata->pwm_acz[ix],\r\ndata->pwm_config[ix]);\r\ndme1737_write(data, DME1737_REG_PWM_CONFIG(ix),\r\ndata->pwm_config[ix]);\r\nif (data->pwm_rr_en & (1 << ix)) {\r\ndata->pwm_rr[ix > 0] = PWM_RR_EN_TO_REG(1, ix,\r\ndme1737_read(data,\r\nDME1737_REG_PWM_RR(ix > 0)));\r\ndme1737_write(data,\r\nDME1737_REG_PWM_RR(ix > 0),\r\ndata->pwm_rr[ix > 0]);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase SYS_PWM_RAMP_RATE:\r\ndata->pwm_config[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_CONFIG(ix));\r\ndata->pwm_rr[ix > 0] = dme1737_read(data,\r\nDME1737_REG_PWM_RR(ix > 0));\r\nif (val > 0) {\r\ndata->pwm_rr[ix > 0] = PWM_RR_TO_REG(val, ix,\r\ndata->pwm_rr[ix > 0]);\r\n}\r\nif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 2) {\r\ndata->pwm_rr[ix > 0] = PWM_RR_EN_TO_REG(val > 0, ix,\r\ndata->pwm_rr[ix > 0]);\r\n}\r\ndme1737_write(data, DME1737_REG_PWM_RR(ix > 0),\r\ndata->pwm_rr[ix > 0]);\r\nbreak;\r\ncase SYS_PWM_AUTO_CHANNELS_ZONE:\r\nif (!(val == 1 || val == 2 || val == 4 ||\r\nval == 6 || val == 7)) {\r\ncount = -EINVAL;\r\ndev_warn(dev, "PWM auto channels zone %ld "\r\n"not supported. Choose one of 1, 2, 4, 6, "\r\n"or 7.\n", val);\r\ngoto exit;\r\n}\r\ndata->pwm_config[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_CONFIG(ix));\r\nif (PWM_EN_FROM_REG(data->pwm_config[ix]) == 2) {\r\ndata->pwm_config[ix] = PWM_ACZ_TO_REG(val,\r\ndata->pwm_config[ix]);\r\ndme1737_write(data, DME1737_REG_PWM_CONFIG(ix),\r\ndata->pwm_config[ix]);\r\n} else {\r\ndata->pwm_acz[ix] = val;\r\n}\r\nbreak;\r\ncase SYS_PWM_AUTO_PWM_MIN:\r\ndata->pwm_min[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_MIN(ix));\r\nif (val > ((data->pwm_min[ix] + 1) / 2)) {\r\ndata->pwm_rr[0] = PWM_OFF_TO_REG(1, ix,\r\ndme1737_read(data,\r\nDME1737_REG_PWM_RR(0)));\r\n} else {\r\ndata->pwm_rr[0] = PWM_OFF_TO_REG(0, ix,\r\ndme1737_read(data,\r\nDME1737_REG_PWM_RR(0)));\r\n}\r\ndme1737_write(data, DME1737_REG_PWM_RR(0),\r\ndata->pwm_rr[0]);\r\nbreak;\r\ncase SYS_PWM_AUTO_POINT1_PWM:\r\ndata->pwm_min[ix] = SENSORS_LIMIT(val, 0, 255);\r\ndme1737_write(data, DME1737_REG_PWM_MIN(ix),\r\ndata->pwm_min[ix]);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown function %d.\n", fn);\r\n}\r\nexit:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vrm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct dme1737_data *data = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d\n", data->vrm);\r\n}\r\nstatic ssize_t set_vrm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nlong val = simple_strtol(buf, NULL, 10);\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_vid(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dme1737_data *data = dme1737_update_device(dev);\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic inline void dme1737_sio_enter(int sio_cip)\r\n{\r\noutb(0x55, sio_cip);\r\n}\r\nstatic inline void dme1737_sio_exit(int sio_cip)\r\n{\r\noutb(0xaa, sio_cip);\r\n}\r\nstatic inline int dme1737_sio_inb(int sio_cip, int reg)\r\n{\r\noutb(reg, sio_cip);\r\nreturn inb(sio_cip + 1);\r\n}\r\nstatic inline void dme1737_sio_outb(int sio_cip, int reg, int val)\r\n{\r\noutb(reg, sio_cip);\r\noutb(val, sio_cip + 1);\r\n}\r\nstatic void dme1737_chmod_file(struct device *dev,\r\nstruct attribute *attr, mode_t mode)\r\n{\r\nif (sysfs_chmod_file(&dev->kobj, attr, mode)) {\r\ndev_warn(dev, "Failed to change permissions of %s.\n",\r\nattr->name);\r\n}\r\n}\r\nstatic void dme1737_chmod_group(struct device *dev,\r\nconst struct attribute_group *group,\r\nmode_t mode)\r\n{\r\nstruct attribute **attr;\r\nfor (attr = group->attrs; *attr; attr++) {\r\ndme1737_chmod_file(dev, *attr, mode);\r\n}\r\n}\r\nstatic void dme1737_remove_files(struct device *dev)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nint ix;\r\nfor (ix = 0; ix < ARRAY_SIZE(dme1737_fan_group); ix++) {\r\nif (data->has_features & HAS_FAN(ix)) {\r\nsysfs_remove_group(&dev->kobj,\r\n&dme1737_fan_group[ix]);\r\n}\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(dme1737_pwm_group); ix++) {\r\nif (data->has_features & HAS_PWM(ix)) {\r\nsysfs_remove_group(&dev->kobj,\r\n&dme1737_pwm_group[ix]);\r\nif ((data->has_features & HAS_PWM_MIN) && ix < 3) {\r\nsysfs_remove_file(&dev->kobj,\r\ndme1737_auto_pwm_min_attr[ix]);\r\n}\r\n}\r\n}\r\nif (data->has_features & HAS_TEMP_OFFSET) {\r\nsysfs_remove_group(&dev->kobj, &dme1737_temp_offset_group);\r\n}\r\nif (data->has_features & HAS_VID) {\r\nsysfs_remove_group(&dev->kobj, &dme1737_vid_group);\r\n}\r\nif (data->has_features & HAS_ZONE3) {\r\nsysfs_remove_group(&dev->kobj, &dme1737_zone3_group);\r\n}\r\nif (data->has_features & HAS_ZONE_HYST) {\r\nsysfs_remove_group(&dev->kobj, &dme1737_zone_hyst_group);\r\n}\r\nif (data->has_features & HAS_IN7) {\r\nsysfs_remove_group(&dev->kobj, &dme1737_in7_group);\r\n}\r\nsysfs_remove_group(&dev->kobj, &dme1737_group);\r\nif (!data->client) {\r\nsysfs_remove_file(&dev->kobj, &dev_attr_name.attr);\r\n}\r\n}\r\nstatic int dme1737_create_files(struct device *dev)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nint err, ix;\r\nif (!data->client) {\r\nerr = sysfs_create_file(&dev->kobj, &dev_attr_name.attr);\r\nif (err) {\r\ngoto exit;\r\n}\r\n}\r\nerr = sysfs_create_group(&dev->kobj, &dme1737_group);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\nif (data->has_features & HAS_TEMP_OFFSET) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&dme1737_temp_offset_group);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\n}\r\nif (data->has_features & HAS_VID) {\r\nerr = sysfs_create_group(&dev->kobj, &dme1737_vid_group);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\n}\r\nif (data->has_features & HAS_ZONE3) {\r\nerr = sysfs_create_group(&dev->kobj, &dme1737_zone3_group);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\n}\r\nif (data->has_features & HAS_ZONE_HYST) {\r\nerr = sysfs_create_group(&dev->kobj, &dme1737_zone_hyst_group);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\n}\r\nif (data->has_features & HAS_IN7) {\r\nerr = sysfs_create_group(&dev->kobj, &dme1737_in7_group);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(dme1737_fan_group); ix++) {\r\nif (data->has_features & HAS_FAN(ix)) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&dme1737_fan_group[ix]);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\n}\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(dme1737_pwm_group); ix++) {\r\nif (data->has_features & HAS_PWM(ix)) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&dme1737_pwm_group[ix]);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\nif ((data->has_features & HAS_PWM_MIN) && (ix < 3)) {\r\nerr = sysfs_create_file(&dev->kobj,\r\ndme1737_auto_pwm_min_attr[ix]);\r\nif (err) {\r\ngoto exit_remove;\r\n}\r\n}\r\n}\r\n}\r\nif (data->config & 0x02) {\r\ndev_info(dev, "Device is locked. Some attributes "\r\n"will be read-only.\n");\r\n} else {\r\ndme1737_chmod_group(dev, &dme1737_zone_chmod_group,\r\nS_IRUGO | S_IWUSR);\r\nif (data->has_features & HAS_TEMP_OFFSET) {\r\ndme1737_chmod_group(dev, &dme1737_temp_offset_group,\r\nS_IRUGO | S_IWUSR);\r\n}\r\nif (data->has_features & HAS_ZONE3) {\r\ndme1737_chmod_group(dev, &dme1737_zone3_chmod_group,\r\nS_IRUGO | S_IWUSR);\r\n}\r\nif (data->has_features & HAS_ZONE_HYST) {\r\ndme1737_chmod_group(dev, &dme1737_zone_hyst_group,\r\nS_IRUGO | S_IWUSR);\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(dme1737_pwm_chmod_group); ix++) {\r\nif (data->has_features & HAS_PWM(ix)) {\r\ndme1737_chmod_group(dev,\r\n&dme1737_pwm_chmod_group[ix],\r\nS_IRUGO | S_IWUSR);\r\nif ((data->has_features & HAS_PWM_MIN) &&\r\nix < 3) {\r\ndme1737_chmod_file(dev,\r\ndme1737_auto_pwm_min_attr[ix],\r\nS_IRUGO | S_IWUSR);\r\n}\r\n}\r\n}\r\nfor (ix = 0; ix < 3; ix++) {\r\nif ((data->has_features & HAS_PWM(ix)) &&\r\n(PWM_EN_FROM_REG(data->pwm_config[ix]) == 1)) {\r\ndme1737_chmod_file(dev,\r\ndme1737_pwm_chmod_attr[ix],\r\nS_IRUGO | S_IWUSR);\r\n}\r\n}\r\n}\r\nreturn 0;\r\nexit_remove:\r\ndme1737_remove_files(dev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int dme1737_init_device(struct device *dev)\r\n{\r\nstruct dme1737_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ix;\r\nu8 reg;\r\ndata->in_nominal = IN_NOMINAL(data->type);\r\ndata->config = dme1737_read(data, DME1737_REG_CONFIG);\r\nif (!(data->config & 0x01)) {\r\nif (!force_start) {\r\ndev_err(dev, "Device is not monitoring. "\r\n"Use the force_start load parameter to "\r\n"override.\n");\r\nreturn -EFAULT;\r\n}\r\ndata->config |= 0x01;\r\ndme1737_write(data, DME1737_REG_CONFIG, data->config);\r\n}\r\nif (!(data->config & 0x04)) {\r\ndev_err(dev, "Device is not ready.\n");\r\nreturn -EFAULT;\r\n}\r\nif (client) {\r\ndata->config2 = dme1737_read(data, DME1737_REG_CONFIG2);\r\nif (data->config2 & 0x04) {\r\ndata->has_features |= HAS_FAN(2);\r\n}\r\nif (client->addr == 0x2e) {\r\ndata->has_features |= HAS_FAN(3) | HAS_PWM(2);\r\n}\r\nif (dme1737_i2c_get_features(0x2e, data) &&\r\ndme1737_i2c_get_features(0x4e, data)) {\r\ndev_warn(dev, "Failed to query Super-IO for optional "\r\n"features.\n");\r\n}\r\n}\r\ndata->has_features |= HAS_FAN(0) | HAS_FAN(1) | HAS_PWM(0) | HAS_PWM(1);\r\nswitch (data->type) {\r\ncase dme1737:\r\ndata->has_features |= HAS_TEMP_OFFSET | HAS_VID | HAS_ZONE3 |\r\nHAS_ZONE_HYST | HAS_PWM_MIN;\r\nbreak;\r\ncase sch311x:\r\ndata->has_features |= HAS_TEMP_OFFSET | HAS_ZONE3 |\r\nHAS_ZONE_HYST | HAS_PWM_MIN | HAS_FAN(2) | HAS_PWM(2);\r\nbreak;\r\ncase sch5027:\r\ndata->has_features |= HAS_ZONE3;\r\nbreak;\r\ncase sch5127:\r\ndata->has_features |= HAS_FAN(2) | HAS_PWM(2) | HAS_IN7;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_info(dev, "Optional features: pwm3=%s, pwm5=%s, pwm6=%s, "\r\n"fan3=%s, fan4=%s, fan5=%s, fan6=%s.\n",\r\n(data->has_features & HAS_PWM(2)) ? "yes" : "no",\r\n(data->has_features & HAS_PWM(4)) ? "yes" : "no",\r\n(data->has_features & HAS_PWM(5)) ? "yes" : "no",\r\n(data->has_features & HAS_FAN(2)) ? "yes" : "no",\r\n(data->has_features & HAS_FAN(3)) ? "yes" : "no",\r\n(data->has_features & HAS_FAN(4)) ? "yes" : "no",\r\n(data->has_features & HAS_FAN(5)) ? "yes" : "no");\r\nreg = dme1737_read(data, DME1737_REG_TACH_PWM);\r\nif (client && reg != 0xa4) {\r\ndev_warn(dev, "Non-standard fan to pwm mapping: "\r\n"fan1->pwm%d, fan2->pwm%d, fan3->pwm%d, "\r\n"fan4->pwm%d. Please report to the driver "\r\n"maintainer.\n",\r\n(reg & 0x03) + 1, ((reg >> 2) & 0x03) + 1,\r\n((reg >> 4) & 0x03) + 1, ((reg >> 6) & 0x03) + 1);\r\n} else if (!client && reg != 0x24) {\r\ndev_warn(dev, "Non-standard fan to pwm mapping: "\r\n"fan1->pwm%d, fan2->pwm%d, fan3->pwm%d. "\r\n"Please report to the driver maintainer.\n",\r\n(reg & 0x03) + 1, ((reg >> 2) & 0x03) + 1,\r\n((reg >> 4) & 0x03) + 1);\r\n}\r\nif (!(data->config & 0x02)) {\r\nfor (ix = 0; ix < 3; ix++) {\r\ndata->pwm_config[ix] = dme1737_read(data,\r\nDME1737_REG_PWM_CONFIG(ix));\r\nif ((data->has_features & HAS_PWM(ix)) &&\r\n(PWM_EN_FROM_REG(data->pwm_config[ix]) == -1)) {\r\ndev_info(dev, "Switching pwm%d to "\r\n"manual mode.\n", ix + 1);\r\ndata->pwm_config[ix] = PWM_EN_TO_REG(1,\r\ndata->pwm_config[ix]);\r\ndme1737_write(data, DME1737_REG_PWM(ix), 0);\r\ndme1737_write(data,\r\nDME1737_REG_PWM_CONFIG(ix),\r\ndata->pwm_config[ix]);\r\n}\r\n}\r\n}\r\ndata->pwm_acz[0] = 1;\r\ndata->pwm_acz[1] = 2;\r\ndata->pwm_acz[2] = 4;\r\nif (data->has_features & HAS_VID) {\r\ndata->vrm = vid_which_vrm();\r\n}\r\nreturn 0;\r\n}\r\nstatic int dme1737_i2c_get_features(int sio_cip, struct dme1737_data *data)\r\n{\r\nint err = 0, reg;\r\nu16 addr;\r\ndme1737_sio_enter(sio_cip);\r\nreg = force_id ? force_id : dme1737_sio_inb(sio_cip, 0x20);\r\nif (!(reg == DME1737_ID_1 || reg == DME1737_ID_2 ||\r\nreg == SCH5027_ID)) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ndme1737_sio_outb(sio_cip, 0x07, 0x0a);\r\naddr = (dme1737_sio_inb(sio_cip, 0x60) << 8) |\r\ndme1737_sio_inb(sio_cip, 0x61);\r\nif (!addr) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nif ((inb(addr + 0x43) & 0x0c) == 0x08) {\r\ndata->has_features |= HAS_FAN(5);\r\n}\r\nif ((inb(addr + 0x44) & 0x0c) == 0x08) {\r\ndata->has_features |= HAS_PWM(5);\r\n}\r\nif ((inb(addr + 0x45) & 0x0c) == 0x08) {\r\ndata->has_features |= HAS_FAN(4);\r\n}\r\nif ((inb(addr + 0x46) & 0x0c) == 0x08) {\r\ndata->has_features |= HAS_PWM(4);\r\n}\r\nexit:\r\ndme1737_sio_exit(sio_cip);\r\nreturn err;\r\n}\r\nstatic int dme1737_i2c_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct device *dev = &adapter->dev;\r\nu8 company, verstep = 0;\r\nconst char *name;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\nreturn -ENODEV;\r\n}\r\ncompany = i2c_smbus_read_byte_data(client, DME1737_REG_COMPANY);\r\nverstep = i2c_smbus_read_byte_data(client, DME1737_REG_VERSTEP);\r\nif (company == DME1737_COMPANY_SMSC &&\r\nverstep == SCH5027_VERSTEP) {\r\nname = "sch5027";\r\n} else if (company == DME1737_COMPANY_SMSC &&\r\n(verstep & DME1737_VERSTEP_MASK) == DME1737_VERSTEP) {\r\nname = "dme1737";\r\n} else {\r\nreturn -ENODEV;\r\n}\r\ndev_info(dev, "Found a %s chip at 0x%02x (rev 0x%02x).\n",\r\nverstep == SCH5027_VERSTEP ? "SCH5027" : "DME1737",\r\nclient->addr, verstep);\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int dme1737_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct dme1737_data *data;\r\nstruct device *dev = &client->dev;\r\nint err;\r\ndata = kzalloc(sizeof(struct dme1737_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ni2c_set_clientdata(client, data);\r\ndata->type = id->driver_data;\r\ndata->client = client;\r\ndata->name = client->name;\r\nmutex_init(&data->update_lock);\r\nerr = dme1737_init_device(dev);\r\nif (err) {\r\ndev_err(dev, "Failed to initialize device.\n");\r\ngoto exit_kfree;\r\n}\r\nerr = dme1737_create_files(dev);\r\nif (err) {\r\ndev_err(dev, "Failed to create sysfs files.\n");\r\ngoto exit_kfree;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\ndev_err(dev, "Failed to register device.\n");\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\ndme1737_remove_files(dev);\r\nexit_kfree:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int dme1737_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct dme1737_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\ndme1737_remove_files(&client->dev);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init dme1737_isa_detect(int sio_cip, unsigned short *addr)\r\n{\r\nint err = 0, reg;\r\nunsigned short base_addr;\r\ndme1737_sio_enter(sio_cip);\r\nreg = force_id ? force_id : dme1737_sio_inb(sio_cip, 0x20);\r\nif (!(reg == SCH3112_ID || reg == SCH3114_ID || reg == SCH3116_ID ||\r\nreg == SCH5127_ID)) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ndme1737_sio_outb(sio_cip, 0x07, 0x0a);\r\nbase_addr = (dme1737_sio_inb(sio_cip, 0x60) << 8) |\r\ndme1737_sio_inb(sio_cip, 0x61);\r\nif (!base_addr) {\r\npr_err("Base address not set\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\n*addr = base_addr + 0x70;\r\nexit:\r\ndme1737_sio_exit(sio_cip);\r\nreturn err;\r\n}\r\nstatic int __init dme1737_isa_device_add(unsigned short addr)\r\n{\r\nstruct resource res = {\r\n.start = addr,\r\n.end = addr + DME1737_EXTENT - 1,\r\n.name = "dme1737",\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err)\r\ngoto exit;\r\npdev = platform_device_alloc("dme1737", addr);\r\nif (!pdev) {\r\npr_err("Failed to allocate device\n");\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Failed to add device resource (err = %d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Failed to add device (err = %d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\npdev = NULL;\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devinit dme1737_isa_probe(struct platform_device *pdev)\r\n{\r\nu8 company, device;\r\nstruct resource *res;\r\nstruct dme1737_data *data;\r\nstruct device *dev = &pdev->dev;\r\nint err;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!request_region(res->start, DME1737_EXTENT, "dme1737")) {\r\ndev_err(dev, "Failed to request region 0x%04x-0x%04x.\n",\r\n(unsigned short)res->start,\r\n(unsigned short)res->start + DME1737_EXTENT - 1);\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\ndata = kzalloc(sizeof(struct dme1737_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit_release_region;\r\n}\r\ndata->addr = res->start;\r\nplatform_set_drvdata(pdev, data);\r\nswitch (force_id) {\r\ncase SCH3112_ID:\r\ncase SCH3114_ID:\r\ncase SCH3116_ID:\r\ndata->type = sch311x;\r\nbreak;\r\ncase SCH5127_ID:\r\ndata->type = sch5127;\r\nbreak;\r\ndefault:\r\ncompany = dme1737_read(data, DME1737_REG_COMPANY);\r\ndevice = dme1737_read(data, DME1737_REG_DEVICE);\r\nif ((company == DME1737_COMPANY_SMSC) &&\r\n(device == SCH311X_DEVICE)) {\r\ndata->type = sch311x;\r\n} else if ((company == DME1737_COMPANY_SMSC) &&\r\n(device == SCH5127_DEVICE)) {\r\ndata->type = sch5127;\r\n} else {\r\nerr = -ENODEV;\r\ngoto exit_kfree;\r\n}\r\n}\r\nif (data->type == sch5127) {\r\ndata->name = "sch5127";\r\n} else {\r\ndata->name = "sch311x";\r\n}\r\nmutex_init(&data->update_lock);\r\ndev_info(dev, "Found a %s chip at 0x%04x\n",\r\ndata->type == sch5127 ? "SCH5127" : "SCH311x", data->addr);\r\nerr = dme1737_init_device(dev);\r\nif (err) {\r\ndev_err(dev, "Failed to initialize device.\n");\r\ngoto exit_kfree;\r\n}\r\nerr = dme1737_create_files(dev);\r\nif (err) {\r\ndev_err(dev, "Failed to create sysfs files.\n");\r\ngoto exit_kfree;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\ndev_err(dev, "Failed to register device.\n");\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\ndme1737_remove_files(dev);\r\nexit_kfree:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nexit_release_region:\r\nrelease_region(res->start, DME1737_EXTENT);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit dme1737_isa_remove(struct platform_device *pdev)\r\n{\r\nstruct dme1737_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\ndme1737_remove_files(&pdev->dev);\r\nrelease_region(data->addr, DME1737_EXTENT);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init dme1737_init(void)\r\n{\r\nint err;\r\nunsigned short addr;\r\nerr = i2c_add_driver(&dme1737_i2c_driver);\r\nif (err) {\r\ngoto exit;\r\n}\r\nif (dme1737_isa_detect(0x2e, &addr) &&\r\ndme1737_isa_detect(0x4e, &addr) &&\r\n(!probe_all_addr ||\r\n(dme1737_isa_detect(0x162e, &addr) &&\r\ndme1737_isa_detect(0x164e, &addr)))) {\r\nreturn 0;\r\n}\r\nerr = platform_driver_register(&dme1737_isa_driver);\r\nif (err) {\r\ngoto exit_del_i2c_driver;\r\n}\r\nerr = dme1737_isa_device_add(addr);\r\nif (err) {\r\ngoto exit_del_isa_driver;\r\n}\r\nreturn 0;\r\nexit_del_isa_driver:\r\nplatform_driver_unregister(&dme1737_isa_driver);\r\nexit_del_i2c_driver:\r\ni2c_del_driver(&dme1737_i2c_driver);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __exit dme1737_exit(void)\r\n{\r\nif (pdev) {\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&dme1737_isa_driver);\r\n}\r\ni2c_del_driver(&dme1737_i2c_driver);\r\n}
