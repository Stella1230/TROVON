static int acpi_pcc_write_sset(struct pcc_acpi *pcc, int func, int val)\r\n{\r\nunion acpi_object in_objs[] = {\r\n{ .integer.type = ACPI_TYPE_INTEGER,\r\n.integer.value = func, },\r\n{ .integer.type = ACPI_TYPE_INTEGER,\r\n.integer.value = val, },\r\n};\r\nstruct acpi_object_list params = {\r\n.count = ARRAY_SIZE(in_objs),\r\n.pointer = in_objs,\r\n};\r\nacpi_status status = AE_OK;\r\nstatus = acpi_evaluate_object(pcc->handle, METHOD_HKEY_SSET,\r\n&params, NULL);\r\nreturn (status == AE_OK) ? 0 : -EIO;\r\n}\r\nstatic inline int acpi_pcc_get_sqty(struct acpi_device *device)\r\n{\r\nunsigned long long s;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(device->handle, METHOD_HKEY_SQTY,\r\nNULL, &s);\r\nif (ACPI_SUCCESS(status))\r\nreturn s;\r\nelse {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"evaluation error HKEY.SQTY\n"));\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int acpi_pcc_retrieve_biosdata(struct pcc_acpi *pcc)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *hkey = NULL;\r\nint i;\r\nstatus = acpi_evaluate_object(pcc->handle, METHOD_HKEY_SINF, NULL,\r\n&buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"evaluation error HKEY.SINF\n"));\r\nreturn 0;\r\n}\r\nhkey = buffer.pointer;\r\nif (!hkey || (hkey->type != ACPI_TYPE_PACKAGE)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid HKEY.SINF\n"));\r\nstatus = AE_ERROR;\r\ngoto end;\r\n}\r\nif (pcc->num_sifr < hkey->package.count) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"SQTY reports bad SINF length\n"));\r\nstatus = AE_ERROR;\r\ngoto end;\r\n}\r\nfor (i = 0; i < hkey->package.count; i++) {\r\nunion acpi_object *element = &(hkey->package.elements[i]);\r\nif (likely(element->type == ACPI_TYPE_INTEGER)) {\r\npcc->sinf[i] = element->integer.value;\r\n} else\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Invalid HKEY.SINF data\n"));\r\n}\r\npcc->sinf[hkey->package.count] = -1;\r\nend:\r\nkfree(buffer.pointer);\r\nreturn status == AE_OK;\r\n}\r\nstatic int bl_get(struct backlight_device *bd)\r\n{\r\nstruct pcc_acpi *pcc = bl_get_data(bd);\r\nif (!acpi_pcc_retrieve_biosdata(pcc))\r\nreturn -EIO;\r\nreturn pcc->sinf[SINF_AC_CUR_BRIGHT];\r\n}\r\nstatic int bl_set_status(struct backlight_device *bd)\r\n{\r\nstruct pcc_acpi *pcc = bl_get_data(bd);\r\nint bright = bd->props.brightness;\r\nint rc;\r\nif (!acpi_pcc_retrieve_biosdata(pcc))\r\nreturn -EIO;\r\nif (bright < pcc->sinf[SINF_AC_MIN_BRIGHT])\r\nbright = pcc->sinf[SINF_AC_MIN_BRIGHT];\r\nif (bright < pcc->sinf[SINF_DC_MIN_BRIGHT])\r\nbright = pcc->sinf[SINF_DC_MIN_BRIGHT];\r\nif (bright < pcc->sinf[SINF_AC_MIN_BRIGHT] ||\r\nbright > pcc->sinf[SINF_AC_MAX_BRIGHT])\r\nreturn -EINVAL;\r\nrc = acpi_pcc_write_sset(pcc, SINF_AC_CUR_BRIGHT, bright);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn acpi_pcc_write_sset(pcc, SINF_DC_CUR_BRIGHT, bright);\r\n}\r\nstatic ssize_t show_numbatt(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi = to_acpi_device(dev);\r\nstruct pcc_acpi *pcc = acpi_driver_data(acpi);\r\nif (!acpi_pcc_retrieve_biosdata(pcc))\r\nreturn -EIO;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", pcc->sinf[SINF_NUM_BATTERIES]);\r\n}\r\nstatic ssize_t show_lcdtype(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi = to_acpi_device(dev);\r\nstruct pcc_acpi *pcc = acpi_driver_data(acpi);\r\nif (!acpi_pcc_retrieve_biosdata(pcc))\r\nreturn -EIO;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", pcc->sinf[SINF_LCD_TYPE]);\r\n}\r\nstatic ssize_t show_mute(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi = to_acpi_device(dev);\r\nstruct pcc_acpi *pcc = acpi_driver_data(acpi);\r\nif (!acpi_pcc_retrieve_biosdata(pcc))\r\nreturn -EIO;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", pcc->sinf[SINF_MUTE]);\r\n}\r\nstatic ssize_t show_sticky(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi = to_acpi_device(dev);\r\nstruct pcc_acpi *pcc = acpi_driver_data(acpi);\r\nif (!acpi_pcc_retrieve_biosdata(pcc))\r\nreturn -EIO;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", pcc->sinf[SINF_STICKY_KEY]);\r\n}\r\nstatic ssize_t set_sticky(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct acpi_device *acpi = to_acpi_device(dev);\r\nstruct pcc_acpi *pcc = acpi_driver_data(acpi);\r\nint val;\r\nif (count && sscanf(buf, "%i", &val) == 1 &&\r\n(val == 0 || val == 1)) {\r\nacpi_pcc_write_sset(pcc, SINF_STICKY_KEY, val);\r\npcc->sticky_mode = val;\r\n}\r\nreturn count;\r\n}\r\nstatic void acpi_pcc_generate_keyinput(struct pcc_acpi *pcc)\r\n{\r\nstruct input_dev *hotk_input_dev = pcc->input_dev;\r\nint rc;\r\nunsigned long long result;\r\nrc = acpi_evaluate_integer(pcc->handle, METHOD_HKEY_QUERY,\r\nNULL, &result);\r\nif (!ACPI_SUCCESS(rc)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"error getting hotkey status\n"));\r\nreturn;\r\n}\r\nacpi_bus_generate_proc_event(pcc->device, HKEY_NOTIFY, result);\r\nif (!sparse_keymap_report_event(hotk_input_dev,\r\nresult & 0xf, result & 0x80, false))\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Unknown hotkey event: %d\n", result));\r\n}\r\nstatic void acpi_pcc_hotkey_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct pcc_acpi *pcc = acpi_driver_data(device);\r\nswitch (event) {\r\ncase HKEY_NOTIFY:\r\nacpi_pcc_generate_keyinput(pcc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int acpi_pcc_init_input(struct pcc_acpi *pcc)\r\n{\r\nstruct input_dev *input_dev;\r\nint error;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Couldn't allocate input device for hotkey"));\r\nreturn -ENOMEM;\r\n}\r\ninput_dev->name = ACPI_PCC_DRIVER_NAME;\r\ninput_dev->phys = ACPI_PCC_INPUT_PHYS;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\nerror = sparse_keymap_setup(input_dev, panasonic_keymap, NULL);\r\nif (error) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Unable to setup input device keymap\n"));\r\ngoto err_free_dev;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Unable to register input device\n"));\r\ngoto err_free_keymap;\r\n}\r\npcc->input_dev = input_dev;\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(input_dev);\r\nerr_free_dev:\r\ninput_free_device(input_dev);\r\nreturn error;\r\n}\r\nstatic void acpi_pcc_destroy_input(struct pcc_acpi *pcc)\r\n{\r\nsparse_keymap_free(pcc->input_dev);\r\ninput_unregister_device(pcc->input_dev);\r\n}\r\nstatic int acpi_pcc_hotkey_resume(struct acpi_device *device)\r\n{\r\nstruct pcc_acpi *pcc = acpi_driver_data(device);\r\nif (device == NULL || pcc == NULL)\r\nreturn -EINVAL;\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Sticky mode restore: %d\n",\r\npcc->sticky_mode));\r\nreturn acpi_pcc_write_sset(pcc, SINF_STICKY_KEY, pcc->sticky_mode);\r\n}\r\nstatic int acpi_pcc_hotkey_add(struct acpi_device *device)\r\n{\r\nstruct backlight_properties props;\r\nstruct pcc_acpi *pcc;\r\nint num_sifr, result;\r\nif (!device)\r\nreturn -EINVAL;\r\nnum_sifr = acpi_pcc_get_sqty(device);\r\nif (num_sifr > 255) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR, "num_sifr too large"));\r\nreturn -ENODEV;\r\n}\r\npcc = kzalloc(sizeof(struct pcc_acpi), GFP_KERNEL);\r\nif (!pcc) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Couldn't allocate mem for pcc"));\r\nreturn -ENOMEM;\r\n}\r\npcc->sinf = kzalloc(sizeof(u32) * (num_sifr + 1), GFP_KERNEL);\r\nif (!pcc->sinf) {\r\nresult = -ENOMEM;\r\ngoto out_hotkey;\r\n}\r\npcc->device = device;\r\npcc->handle = device->handle;\r\npcc->num_sifr = num_sifr;\r\ndevice->driver_data = pcc;\r\nstrcpy(acpi_device_name(device), ACPI_PCC_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PCC_CLASS);\r\nresult = acpi_pcc_init_input(pcc);\r\nif (result) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Error installing keyinput handler\n"));\r\ngoto out_sinf;\r\n}\r\nif (!acpi_pcc_retrieve_biosdata(pcc)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Couldn't retrieve BIOS data\n"));\r\nresult = -EIO;\r\ngoto out_input;\r\n}\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = pcc->sinf[SINF_AC_MAX_BRIGHT];\r\npcc->backlight = backlight_device_register("panasonic", NULL, pcc,\r\n&pcc_backlight_ops, &props);\r\nif (IS_ERR(pcc->backlight)) {\r\nresult = PTR_ERR(pcc->backlight);\r\ngoto out_input;\r\n}\r\npcc->backlight->props.brightness = pcc->sinf[SINF_AC_CUR_BRIGHT];\r\npcc->sticky_mode = pcc->sinf[SINF_STICKY_KEY];\r\nresult = sysfs_create_group(&device->dev.kobj, &pcc_attr_group);\r\nif (result)\r\ngoto out_backlight;\r\nreturn 0;\r\nout_backlight:\r\nbacklight_device_unregister(pcc->backlight);\r\nout_input:\r\nacpi_pcc_destroy_input(pcc);\r\nout_sinf:\r\nkfree(pcc->sinf);\r\nout_hotkey:\r\nkfree(pcc);\r\nreturn result;\r\n}\r\nstatic int __init acpi_pcc_init(void)\r\n{\r\nint result = 0;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nresult = acpi_bus_register_driver(&acpi_pcc_driver);\r\nif (result < 0) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ERROR,\r\n"Error registering hotkey driver\n"));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_pcc_hotkey_remove(struct acpi_device *device, int type)\r\n{\r\nstruct pcc_acpi *pcc = acpi_driver_data(device);\r\nif (!device || !pcc)\r\nreturn -EINVAL;\r\nsysfs_remove_group(&device->dev.kobj, &pcc_attr_group);\r\nbacklight_device_unregister(pcc->backlight);\r\nacpi_pcc_destroy_input(pcc);\r\nkfree(pcc->sinf);\r\nkfree(pcc);\r\nreturn 0;\r\n}\r\nstatic void __exit acpi_pcc_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_pcc_driver);\r\n}
