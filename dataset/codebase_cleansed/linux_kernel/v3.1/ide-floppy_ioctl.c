static int ide_floppy_get_format_capacities(ide_drive_t *drive,\r\nstruct ide_atapi_pc *pc,\r\nint __user *arg)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nint i, blocks, length, u_array_size, u_index;\r\nint __user *argp;\r\nu8 pc_buf[256], header_len, desc_cnt;\r\nif (get_user(u_array_size, arg))\r\nreturn -EFAULT;\r\nif (u_array_size <= 0)\r\nreturn -EINVAL;\r\nide_floppy_create_read_capacity_cmd(pc);\r\nif (ide_queue_pc_tail(drive, floppy->disk, pc, pc_buf, pc->req_xfer)) {\r\nprintk(KERN_ERR "ide-floppy: Can't get floppy parameters\n");\r\nreturn -EIO;\r\n}\r\nheader_len = pc_buf[3];\r\ndesc_cnt = header_len / 8;\r\nu_index = 0;\r\nargp = arg + 1;\r\nfor (i = 1; i < desc_cnt; i++) {\r\nunsigned int desc_start = 4 + i*8;\r\nif (u_index >= u_array_size)\r\nbreak;\r\nblocks = be32_to_cpup((__be32 *)&pc_buf[desc_start]);\r\nlength = be16_to_cpup((__be16 *)&pc_buf[desc_start + 6]);\r\nif (put_user(blocks, argp))\r\nreturn -EFAULT;\r\n++argp;\r\nif (put_user(length, argp))\r\nreturn -EFAULT;\r\n++argp;\r\n++u_index;\r\n}\r\nif (put_user(u_index, arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void ide_floppy_create_format_unit_cmd(struct ide_atapi_pc *pc,\r\nu8 *buf, int b, int l,\r\nint flags)\r\n{\r\nide_init_pc(pc);\r\npc->c[0] = GPCMD_FORMAT_UNIT;\r\npc->c[1] = 0x17;\r\nmemset(buf, 0, 12);\r\nbuf[1] = 0xA2;\r\nif (flags & 1)\r\nbuf[1] ^= 0x20;\r\nbuf[3] = 8;\r\nput_unaligned(cpu_to_be32(b), (unsigned int *)(&buf[4]));\r\nput_unaligned(cpu_to_be32(l), (unsigned int *)(&buf[8]));\r\npc->req_xfer = 12;\r\npc->flags |= PC_FLAG_WRITING;\r\n}\r\nstatic int ide_floppy_get_sfrp_bit(ide_drive_t *drive, struct ide_atapi_pc *pc)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nu8 buf[20];\r\ndrive->atapi_flags &= ~IDE_AFLAG_SRFP;\r\nide_floppy_create_mode_sense_cmd(pc, IDEFLOPPY_CAPABILITIES_PAGE);\r\npc->flags |= PC_FLAG_SUPPRESS_ERROR;\r\nif (ide_queue_pc_tail(drive, floppy->disk, pc, buf, pc->req_xfer))\r\nreturn 1;\r\nif (buf[8 + 2] & 0x40)\r\ndrive->atapi_flags |= IDE_AFLAG_SRFP;\r\nreturn 0;\r\n}\r\nstatic int ide_floppy_format_unit(ide_drive_t *drive, struct ide_atapi_pc *pc,\r\nint __user *arg)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nu8 buf[12];\r\nint blocks, length, flags, err = 0;\r\nif (floppy->openers > 1) {\r\ndrive->dev_flags &= ~IDE_DFLAG_FORMAT_IN_PROGRESS;\r\nreturn -EBUSY;\r\n}\r\ndrive->dev_flags |= IDE_DFLAG_FORMAT_IN_PROGRESS;\r\nif (get_user(blocks, arg) ||\r\nget_user(length, arg+1) ||\r\nget_user(flags, arg+2)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nide_floppy_get_sfrp_bit(drive, pc);\r\nide_floppy_create_format_unit_cmd(pc, buf, blocks, length, flags);\r\nif (ide_queue_pc_tail(drive, floppy->disk, pc, buf, pc->req_xfer))\r\nerr = -EIO;\r\nout:\r\nif (err)\r\ndrive->dev_flags &= ~IDE_DFLAG_FORMAT_IN_PROGRESS;\r\nreturn err;\r\n}\r\nstatic int ide_floppy_get_format_progress(ide_drive_t *drive,\r\nstruct ide_atapi_pc *pc,\r\nint __user *arg)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nu8 sense_buf[18];\r\nint progress_indication = 0x10000;\r\nif (drive->atapi_flags & IDE_AFLAG_SRFP) {\r\nide_create_request_sense_cmd(drive, pc);\r\nif (ide_queue_pc_tail(drive, floppy->disk, pc, sense_buf,\r\npc->req_xfer))\r\nreturn -EIO;\r\nif (floppy->sense_key == 2 &&\r\nfloppy->asc == 4 &&\r\nfloppy->ascq == 4)\r\nprogress_indication = floppy->progress_indication;\r\n} else {\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long flags;\r\nu8 stat;\r\nlocal_irq_save(flags);\r\nstat = hwif->tp_ops->read_status(hwif);\r\nlocal_irq_restore(flags);\r\nprogress_indication = ((stat & ATA_DSC) == 0) ? 0 : 0x10000;\r\n}\r\nif (put_user(progress_indication, arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ide_floppy_lockdoor(ide_drive_t *drive, struct ide_atapi_pc *pc,\r\nunsigned long arg, unsigned int cmd)\r\n{\r\nstruct ide_disk_obj *floppy = drive->driver_data;\r\nstruct gendisk *disk = floppy->disk;\r\nint prevent = (arg && cmd != CDROMEJECT) ? 1 : 0;\r\nif (floppy->openers > 1)\r\nreturn -EBUSY;\r\nide_set_media_lock(drive, disk, prevent);\r\nif (cmd == CDROMEJECT)\r\nide_do_start_stop(drive, disk, 2);\r\nreturn 0;\r\n}\r\nstatic int ide_floppy_format_ioctl(ide_drive_t *drive, struct ide_atapi_pc *pc,\r\nfmode_t mode, unsigned int cmd,\r\nvoid __user *argp)\r\n{\r\nswitch (cmd) {\r\ncase IDEFLOPPY_IOCTL_FORMAT_SUPPORTED:\r\nreturn 0;\r\ncase IDEFLOPPY_IOCTL_FORMAT_GET_CAPACITY:\r\nreturn ide_floppy_get_format_capacities(drive, pc, argp);\r\ncase IDEFLOPPY_IOCTL_FORMAT_START:\r\nif (!(mode & FMODE_WRITE))\r\nreturn -EPERM;\r\nreturn ide_floppy_format_unit(drive, pc, (int __user *)argp);\r\ncase IDEFLOPPY_IOCTL_FORMAT_GET_PROGRESS:\r\nreturn ide_floppy_get_format_progress(drive, pc, argp);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nint ide_floppy_ioctl(ide_drive_t *drive, struct block_device *bdev,\r\nfmode_t mode, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct ide_atapi_pc pc;\r\nvoid __user *argp = (void __user *)arg;\r\nint err;\r\nmutex_lock(&ide_floppy_ioctl_mutex);\r\nif (cmd == CDROMEJECT || cmd == CDROM_LOCKDOOR) {\r\nerr = ide_floppy_lockdoor(drive, &pc, arg, cmd);\r\ngoto out;\r\n}\r\nerr = ide_floppy_format_ioctl(drive, &pc, mode, cmd, argp);\r\nif (err != -ENOTTY)\r\ngoto out;\r\nif (cmd != CDROM_SEND_PACKET && cmd != SCSI_IOCTL_SEND_COMMAND)\r\nerr = scsi_cmd_ioctl(bdev->bd_disk->queue, bdev->bd_disk,\r\nmode, cmd, argp);\r\nif (err == -ENOTTY)\r\nerr = generic_ide_ioctl(drive, bdev, cmd, arg);\r\nout:\r\nmutex_unlock(&ide_floppy_ioctl_mutex);\r\nreturn err;\r\n}
