static inline struct cx23888_ir_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn v4l2_get_subdevdata(sd);\r\n}\r\nstatic\r\ninline int cx23888_ir_write4(struct cx23885_dev *dev, u32 addr, u32 value)\r\n{\r\ncx_write(addr, value);\r\nreturn 0;\r\n}\r\nstatic inline u32 cx23888_ir_read4(struct cx23885_dev *dev, u32 addr)\r\n{\r\nreturn cx_read(addr);\r\n}\r\nstatic inline int cx23888_ir_and_or4(struct cx23885_dev *dev, u32 addr,\r\nu32 and_mask, u32 or_value)\r\n{\r\ncx_andor(addr, ~and_mask, or_value);\r\nreturn 0;\r\n}\r\nstatic inline u16 count_to_clock_divider(unsigned int d)\r\n{\r\nif (d > RXCLK_RCD + 1)\r\nd = RXCLK_RCD;\r\nelse if (d < 2)\r\nd = 1;\r\nelse\r\nd--;\r\nreturn (u16) d;\r\n}\r\nstatic inline u16 ns_to_clock_divider(unsigned int ns)\r\n{\r\nreturn count_to_clock_divider(\r\nDIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ / 1000000 * ns, 1000));\r\n}\r\nstatic inline unsigned int clock_divider_to_ns(unsigned int divider)\r\n{\r\nreturn DIV_ROUND_CLOSEST((divider + 1) * 1000,\r\nCX23888_IR_REFCLK_FREQ / 1000000);\r\n}\r\nstatic inline u16 carrier_freq_to_clock_divider(unsigned int freq)\r\n{\r\nreturn count_to_clock_divider(\r\nDIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, freq * 16));\r\n}\r\nstatic inline unsigned int clock_divider_to_carrier_freq(unsigned int divider)\r\n{\r\nreturn DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, (divider + 1) * 16);\r\n}\r\nstatic inline u16 freq_to_clock_divider(unsigned int freq,\r\nunsigned int rollovers)\r\n{\r\nreturn count_to_clock_divider(\r\nDIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ, freq * rollovers));\r\n}\r\nstatic inline unsigned int clock_divider_to_freq(unsigned int divider,\r\nunsigned int rollovers)\r\n{\r\nreturn DIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ,\r\n(divider + 1) * rollovers);\r\n}\r\nstatic inline u16 count_to_lpf_count(unsigned int d)\r\n{\r\nif (d > FILTR_LPF)\r\nd = FILTR_LPF;\r\nelse if (d < 4)\r\nd = 0;\r\nreturn (u16) d;\r\n}\r\nstatic inline u16 ns_to_lpf_count(unsigned int ns)\r\n{\r\nreturn count_to_lpf_count(\r\nDIV_ROUND_CLOSEST(CX23888_IR_REFCLK_FREQ / 1000000 * ns, 1000));\r\n}\r\nstatic inline unsigned int lpf_count_to_ns(unsigned int count)\r\n{\r\nreturn DIV_ROUND_CLOSEST(count * 1000,\r\nCX23888_IR_REFCLK_FREQ / 1000000);\r\n}\r\nstatic inline unsigned int lpf_count_to_us(unsigned int count)\r\n{\r\nreturn DIV_ROUND_CLOSEST(count, CX23888_IR_REFCLK_FREQ / 1000000);\r\n}\r\nstatic u32 clock_divider_to_resolution(u16 divider)\r\n{\r\nreturn DIV_ROUND_CLOSEST((1 << 2) * ((u32) divider + 1) * 1000,\r\nCX23888_IR_REFCLK_FREQ / 1000000);\r\n}\r\nstatic u64 pulse_width_count_to_ns(u16 count, u16 divider)\r\n{\r\nu64 n;\r\nu32 rem;\r\nn = (((u64) count << 2) | 0x3) * (divider + 1) * 1000;\r\nrem = do_div(n, CX23888_IR_REFCLK_FREQ / 1000000);\r\nif (rem >= CX23888_IR_REFCLK_FREQ / 1000000 / 2)\r\nn++;\r\nreturn n;\r\n}\r\nstatic unsigned int pulse_width_count_to_us(u16 count, u16 divider)\r\n{\r\nu64 n;\r\nu32 rem;\r\nn = (((u64) count << 2) | 0x3) * (divider + 1);\r\nrem = do_div(n, CX23888_IR_REFCLK_FREQ / 1000000);\r\nif (rem >= CX23888_IR_REFCLK_FREQ / 1000000 / 2)\r\nn++;\r\nreturn (unsigned int) n;\r\n}\r\nstatic u64 ns_to_pulse_clocks(u32 ns)\r\n{\r\nu64 clocks;\r\nu32 rem;\r\nclocks = CX23888_IR_REFCLK_FREQ / 1000000 * (u64) ns;\r\nrem = do_div(clocks, 1000);\r\nif (rem >= 1000 / 2)\r\nclocks++;\r\nreturn clocks;\r\n}\r\nstatic u16 pulse_clocks_to_clock_divider(u64 count)\r\n{\r\nu32 rem;\r\nrem = do_div(count, (FIFO_RXTX << 2) | 0x3);\r\nif (count > RXCLK_RCD + 1)\r\ncount = RXCLK_RCD;\r\nelse if (count < 2)\r\ncount = 1;\r\nelse\r\ncount--;\r\nreturn (u16) count;\r\n}\r\nstatic inline void control_tx_irq_watermark(struct cx23885_dev *dev,\r\nenum tx_fifo_watermark level)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_TIC, level);\r\n}\r\nstatic inline void control_rx_irq_watermark(struct cx23885_dev *dev,\r\nenum rx_fifo_watermark level)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_RIC, level);\r\n}\r\nstatic inline void control_tx_enable(struct cx23885_dev *dev, bool enable)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~(CNTRL_TXE | CNTRL_TFE),\r\nenable ? (CNTRL_TXE | CNTRL_TFE) : 0);\r\n}\r\nstatic inline void control_rx_enable(struct cx23885_dev *dev, bool enable)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~(CNTRL_RXE | CNTRL_RFE),\r\nenable ? (CNTRL_RXE | CNTRL_RFE) : 0);\r\n}\r\nstatic inline void control_tx_modulation_enable(struct cx23885_dev *dev,\r\nbool enable)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_MOD,\r\nenable ? CNTRL_MOD : 0);\r\n}\r\nstatic inline void control_rx_demodulation_enable(struct cx23885_dev *dev,\r\nbool enable)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_DMD,\r\nenable ? CNTRL_DMD : 0);\r\n}\r\nstatic inline void control_rx_s_edge_detection(struct cx23885_dev *dev,\r\nu32 edge_types)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_EDG_BOTH,\r\nedge_types & CNTRL_EDG_BOTH);\r\n}\r\nstatic void control_rx_s_carrier_window(struct cx23885_dev *dev,\r\nunsigned int carrier,\r\nunsigned int *carrier_range_low,\r\nunsigned int *carrier_range_high)\r\n{\r\nu32 v;\r\nunsigned int c16 = carrier * 16;\r\nif (*carrier_range_low < DIV_ROUND_CLOSEST(c16, 16 + 3)) {\r\nv = CNTRL_WIN_3_4;\r\n*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 4);\r\n} else {\r\nv = CNTRL_WIN_3_3;\r\n*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 3);\r\n}\r\nif (*carrier_range_high > DIV_ROUND_CLOSEST(c16, 16 - 3)) {\r\nv |= CNTRL_WIN_4_3;\r\n*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 4);\r\n} else {\r\nv |= CNTRL_WIN_3_3;\r\n*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 3);\r\n}\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_WIN, v);\r\n}\r\nstatic inline void control_tx_polarity_invert(struct cx23885_dev *dev,\r\nbool invert)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_CPL,\r\ninvert ? CNTRL_CPL : 0);\r\n}\r\nstatic inline void control_tx_level_invert(struct cx23885_dev *dev,\r\nbool invert)\r\n{\r\ncx23888_ir_and_or4(dev, CX23888_IR_CNTRL_REG, ~CNTRL_IVO,\r\ninvert ? CNTRL_IVO : 0);\r\n}\r\nstatic unsigned int txclk_tx_s_carrier(struct cx23885_dev *dev,\r\nunsigned int freq,\r\nu16 *divider)\r\n{\r\n*divider = carrier_freq_to_clock_divider(freq);\r\ncx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, *divider);\r\nreturn clock_divider_to_carrier_freq(*divider);\r\n}\r\nstatic unsigned int rxclk_rx_s_carrier(struct cx23885_dev *dev,\r\nunsigned int freq,\r\nu16 *divider)\r\n{\r\n*divider = carrier_freq_to_clock_divider(freq);\r\ncx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, *divider);\r\nreturn clock_divider_to_carrier_freq(*divider);\r\n}\r\nstatic u32 txclk_tx_s_max_pulse_width(struct cx23885_dev *dev, u32 ns,\r\nu16 *divider)\r\n{\r\nu64 pulse_clocks;\r\nif (ns > IR_MAX_DURATION)\r\nns = IR_MAX_DURATION;\r\npulse_clocks = ns_to_pulse_clocks(ns);\r\n*divider = pulse_clocks_to_clock_divider(pulse_clocks);\r\ncx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, *divider);\r\nreturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\r\n}\r\nstatic u32 rxclk_rx_s_max_pulse_width(struct cx23885_dev *dev, u32 ns,\r\nu16 *divider)\r\n{\r\nu64 pulse_clocks;\r\nif (ns > IR_MAX_DURATION)\r\nns = IR_MAX_DURATION;\r\npulse_clocks = ns_to_pulse_clocks(ns);\r\n*divider = pulse_clocks_to_clock_divider(pulse_clocks);\r\ncx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, *divider);\r\nreturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\r\n}\r\nstatic unsigned int cduty_tx_s_duty_cycle(struct cx23885_dev *dev,\r\nunsigned int duty_cycle)\r\n{\r\nu32 n;\r\nn = DIV_ROUND_CLOSEST(duty_cycle * 100, 625);\r\nif (n != 0)\r\nn--;\r\nif (n > 15)\r\nn = 15;\r\ncx23888_ir_write4(dev, CX23888_IR_CDUTY_REG, n);\r\nreturn DIV_ROUND_CLOSEST((n + 1) * 100, 16);\r\n}\r\nstatic u32 filter_rx_s_min_width(struct cx23885_dev *dev, u32 min_width_ns)\r\n{\r\nu32 count = ns_to_lpf_count(min_width_ns);\r\ncx23888_ir_write4(dev, CX23888_IR_FILTR_REG, count);\r\nreturn lpf_count_to_ns(count);\r\n}\r\nstatic inline void irqenable_rx(struct cx23885_dev *dev, u32 mask)\r\n{\r\nmask &= (IRQEN_RTE | IRQEN_ROE | IRQEN_RSE);\r\ncx23888_ir_and_or4(dev, CX23888_IR_IRQEN_REG,\r\n~(IRQEN_RTE | IRQEN_ROE | IRQEN_RSE), mask);\r\n}\r\nstatic inline void irqenable_tx(struct cx23885_dev *dev, u32 mask)\r\n{\r\nmask &= IRQEN_TSE;\r\ncx23888_ir_and_or4(dev, CX23888_IR_IRQEN_REG, ~IRQEN_TSE, mask);\r\n}\r\nstatic int cx23888_ir_irq_handler(struct v4l2_subdev *sd, u32 status,\r\nbool *handled)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nstruct cx23885_dev *dev = state->dev;\r\nunsigned long flags;\r\nu32 cntrl = cx23888_ir_read4(dev, CX23888_IR_CNTRL_REG);\r\nu32 irqen = cx23888_ir_read4(dev, CX23888_IR_IRQEN_REG);\r\nu32 stats = cx23888_ir_read4(dev, CX23888_IR_STATS_REG);\r\nunion cx23888_ir_fifo_rec rx_data[FIFO_RX_DEPTH];\r\nunsigned int i, j, k;\r\nu32 events, v;\r\nint tsr, rsr, rto, ror, tse, rse, rte, roe, kror;\r\ntsr = stats & STATS_TSR;\r\nrsr = stats & STATS_RSR;\r\nrto = stats & STATS_RTO;\r\nror = stats & STATS_ROR;\r\ntse = irqen & IRQEN_TSE;\r\nrse = irqen & IRQEN_RSE;\r\nrte = irqen & IRQEN_RTE;\r\nroe = irqen & IRQEN_ROE;\r\n*handled = false;\r\nv4l2_dbg(2, ir_888_debug, sd, "IRQ Status: %s %s %s %s %s %s\n",\r\ntsr ? "tsr" : " ", rsr ? "rsr" : " ",\r\nrto ? "rto" : " ", ror ? "ror" : " ",\r\nstats & STATS_TBY ? "tby" : " ",\r\nstats & STATS_RBY ? "rby" : " ");\r\nv4l2_dbg(2, ir_888_debug, sd, "IRQ Enables: %s %s %s %s\n",\r\ntse ? "tse" : " ", rse ? "rse" : " ",\r\nrte ? "rte" : " ", roe ? "roe" : " ");\r\nif (tse && tsr) {\r\nirqenable_tx(dev, 0);\r\nevents = V4L2_SUBDEV_IR_TX_FIFO_SERVICE_REQ;\r\nv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_TX_NOTIFY, &events);\r\n*handled = true;\r\n}\r\nkror = 0;\r\nif ((rse && rsr) || (rte && rto)) {\r\nfor (i = 0, v = FIFO_RX_NDV;\r\n(v & FIFO_RX_NDV) && !kror; i = 0) {\r\nfor (j = 0;\r\n(v & FIFO_RX_NDV) && j < FIFO_RX_DEPTH; j++) {\r\nv = cx23888_ir_read4(dev, CX23888_IR_FIFO_REG);\r\nrx_data[i].hw_fifo_data = v & ~FIFO_RX_NDV;\r\ni++;\r\n}\r\nif (i == 0)\r\nbreak;\r\nj = i * sizeof(union cx23888_ir_fifo_rec);\r\nk = kfifo_in_locked(&state->rx_kfifo,\r\n(unsigned char *) rx_data, j,\r\n&state->rx_kfifo_lock);\r\nif (k != j)\r\nkror++;\r\n}\r\n*handled = true;\r\n}\r\nevents = 0;\r\nv = 0;\r\nif (kror) {\r\nevents |= V4L2_SUBDEV_IR_RX_SW_FIFO_OVERRUN;\r\nv4l2_err(sd, "IR receiver software FIFO overrun\n");\r\n}\r\nif (roe && ror) {\r\nv |= CNTRL_RFE;\r\nevents |= V4L2_SUBDEV_IR_RX_HW_FIFO_OVERRUN;\r\nv4l2_err(sd, "IR receiver hardware FIFO overrun\n");\r\n}\r\nif (rte && rto) {\r\nv |= CNTRL_RXE;\r\nevents |= V4L2_SUBDEV_IR_RX_END_OF_RX_DETECTED;\r\n}\r\nif (v) {\r\ncx23888_ir_write4(dev, CX23888_IR_CNTRL_REG, cntrl & ~v);\r\ncx23888_ir_write4(dev, CX23888_IR_CNTRL_REG, cntrl);\r\n*handled = true;\r\n}\r\nspin_lock_irqsave(&state->rx_kfifo_lock, flags);\r\nif (kfifo_len(&state->rx_kfifo) >= CX23888_IR_RX_KFIFO_SIZE / 2)\r\nevents |= V4L2_SUBDEV_IR_RX_FIFO_SERVICE_REQ;\r\nspin_unlock_irqrestore(&state->rx_kfifo_lock, flags);\r\nif (events)\r\nv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_RX_NOTIFY, &events);\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_rx_read(struct v4l2_subdev *sd, u8 *buf, size_t count,\r\nssize_t *num)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nbool invert = (bool) atomic_read(&state->rx_invert);\r\nu16 divider = (u16) atomic_read(&state->rxclk_divider);\r\nunsigned int i, n;\r\nunion cx23888_ir_fifo_rec *p;\r\nunsigned u, v;\r\nn = count / sizeof(union cx23888_ir_fifo_rec)\r\n* sizeof(union cx23888_ir_fifo_rec);\r\nif (n == 0) {\r\n*num = 0;\r\nreturn 0;\r\n}\r\nn = kfifo_out_locked(&state->rx_kfifo, buf, n, &state->rx_kfifo_lock);\r\nn /= sizeof(union cx23888_ir_fifo_rec);\r\n*num = n * sizeof(union cx23888_ir_fifo_rec);\r\nfor (p = (union cx23888_ir_fifo_rec *) buf, i = 0; i < n; p++, i++) {\r\nif ((p->hw_fifo_data & FIFO_RXTX_RTO) == FIFO_RXTX_RTO) {\r\nu = 0;\r\nv4l2_dbg(2, ir_888_debug, sd, "rx read: end of rx\n");\r\n} else {\r\nu = (p->hw_fifo_data & FIFO_RXTX_LVL) ? 1 : 0;\r\nif (invert)\r\nu = u ? 0 : 1;\r\n}\r\nv = (unsigned) pulse_width_count_to_ns(\r\n(u16) (p->hw_fifo_data & FIFO_RXTX), divider);\r\nif (v > IR_MAX_DURATION)\r\nv = IR_MAX_DURATION;\r\ninit_ir_raw_event(&p->ir_core_data);\r\np->ir_core_data.pulse = u;\r\np->ir_core_data.duration = v;\r\nv4l2_dbg(2, ir_888_debug, sd, "rx read: %10u ns %s\n",\r\nv, u ? "mark" : "space");\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_rx_g_parameters(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_ir_parameters *p)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nmutex_lock(&state->rx_params_lock);\r\nmemcpy(p, &state->rx_params, sizeof(struct v4l2_subdev_ir_parameters));\r\nmutex_unlock(&state->rx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_rx_shutdown(struct v4l2_subdev *sd)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nstruct cx23885_dev *dev = state->dev;\r\nmutex_lock(&state->rx_params_lock);\r\nirqenable_rx(dev, 0);\r\ncontrol_rx_enable(dev, false);\r\ncontrol_rx_demodulation_enable(dev, false);\r\ncontrol_rx_s_edge_detection(dev, CNTRL_EDG_NONE);\r\nfilter_rx_s_min_width(dev, 0);\r\ncx23888_ir_write4(dev, CX23888_IR_RXCLK_REG, RXCLK_RCD);\r\nstate->rx_params.shutdown = true;\r\nmutex_unlock(&state->rx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_rx_s_parameters(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_ir_parameters *p)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nstruct cx23885_dev *dev = state->dev;\r\nstruct v4l2_subdev_ir_parameters *o = &state->rx_params;\r\nu16 rxclk_divider;\r\nif (p->shutdown)\r\nreturn cx23888_ir_rx_shutdown(sd);\r\nif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\r\nreturn -ENOSYS;\r\nmutex_lock(&state->rx_params_lock);\r\no->shutdown = p->shutdown;\r\no->mode = p->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\r\no->bytes_per_data_element = p->bytes_per_data_element\r\n= sizeof(union cx23888_ir_fifo_rec);\r\nirqenable_rx(dev, 0);\r\ncontrol_rx_enable(dev, false);\r\ncontrol_rx_demodulation_enable(dev, p->modulation);\r\no->modulation = p->modulation;\r\nif (p->modulation) {\r\np->carrier_freq = rxclk_rx_s_carrier(dev, p->carrier_freq,\r\n&rxclk_divider);\r\no->carrier_freq = p->carrier_freq;\r\no->duty_cycle = p->duty_cycle = 50;\r\ncontrol_rx_s_carrier_window(dev, p->carrier_freq,\r\n&p->carrier_range_lower,\r\n&p->carrier_range_upper);\r\no->carrier_range_lower = p->carrier_range_lower;\r\no->carrier_range_upper = p->carrier_range_upper;\r\np->max_pulse_width =\r\n(u32) pulse_width_count_to_ns(FIFO_RXTX, rxclk_divider);\r\n} else {\r\np->max_pulse_width =\r\nrxclk_rx_s_max_pulse_width(dev, p->max_pulse_width,\r\n&rxclk_divider);\r\n}\r\no->max_pulse_width = p->max_pulse_width;\r\natomic_set(&state->rxclk_divider, rxclk_divider);\r\np->noise_filter_min_width =\r\nfilter_rx_s_min_width(dev, p->noise_filter_min_width);\r\no->noise_filter_min_width = p->noise_filter_min_width;\r\np->resolution = clock_divider_to_resolution(rxclk_divider);\r\no->resolution = p->resolution;\r\ncontrol_rx_irq_watermark(dev, RX_FIFO_HALF_FULL);\r\ncontrol_rx_s_edge_detection(dev, CNTRL_EDG_BOTH);\r\no->invert_level = p->invert_level;\r\natomic_set(&state->rx_invert, p->invert_level);\r\no->interrupt_enable = p->interrupt_enable;\r\no->enable = p->enable;\r\nif (p->enable) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&state->rx_kfifo_lock, flags);\r\nkfifo_reset(&state->rx_kfifo);\r\nspin_unlock_irqrestore(&state->rx_kfifo_lock, flags);\r\nif (p->interrupt_enable)\r\nirqenable_rx(dev, IRQEN_RSE | IRQEN_RTE | IRQEN_ROE);\r\ncontrol_rx_enable(dev, p->enable);\r\n}\r\nmutex_unlock(&state->rx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_tx_write(struct v4l2_subdev *sd, u8 *buf, size_t count,\r\nssize_t *num)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nstruct cx23885_dev *dev = state->dev;\r\nirqenable_tx(dev, IRQEN_TSE);\r\n*num = count;\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_tx_g_parameters(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_ir_parameters *p)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nmutex_lock(&state->tx_params_lock);\r\nmemcpy(p, &state->tx_params, sizeof(struct v4l2_subdev_ir_parameters));\r\nmutex_unlock(&state->tx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_tx_shutdown(struct v4l2_subdev *sd)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nstruct cx23885_dev *dev = state->dev;\r\nmutex_lock(&state->tx_params_lock);\r\nirqenable_tx(dev, 0);\r\ncontrol_tx_enable(dev, false);\r\ncontrol_tx_modulation_enable(dev, false);\r\ncx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, TXCLK_TCD);\r\nstate->tx_params.shutdown = true;\r\nmutex_unlock(&state->tx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_tx_s_parameters(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_ir_parameters *p)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nstruct cx23885_dev *dev = state->dev;\r\nstruct v4l2_subdev_ir_parameters *o = &state->tx_params;\r\nu16 txclk_divider;\r\nif (p->shutdown)\r\nreturn cx23888_ir_tx_shutdown(sd);\r\nif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\r\nreturn -ENOSYS;\r\nmutex_lock(&state->tx_params_lock);\r\no->shutdown = p->shutdown;\r\no->mode = p->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\r\no->bytes_per_data_element = p->bytes_per_data_element\r\n= sizeof(union cx23888_ir_fifo_rec);\r\nirqenable_tx(dev, 0);\r\ncontrol_tx_enable(dev, false);\r\ncontrol_tx_modulation_enable(dev, p->modulation);\r\no->modulation = p->modulation;\r\nif (p->modulation) {\r\np->carrier_freq = txclk_tx_s_carrier(dev, p->carrier_freq,\r\n&txclk_divider);\r\no->carrier_freq = p->carrier_freq;\r\np->duty_cycle = cduty_tx_s_duty_cycle(dev, p->duty_cycle);\r\no->duty_cycle = p->duty_cycle;\r\np->max_pulse_width =\r\n(u32) pulse_width_count_to_ns(FIFO_RXTX, txclk_divider);\r\n} else {\r\np->max_pulse_width =\r\ntxclk_tx_s_max_pulse_width(dev, p->max_pulse_width,\r\n&txclk_divider);\r\n}\r\no->max_pulse_width = p->max_pulse_width;\r\natomic_set(&state->txclk_divider, txclk_divider);\r\np->resolution = clock_divider_to_resolution(txclk_divider);\r\no->resolution = p->resolution;\r\ncontrol_tx_irq_watermark(dev, TX_FIFO_HALF_EMPTY);\r\ncontrol_tx_polarity_invert(dev, p->invert_carrier_sense);\r\no->invert_carrier_sense = p->invert_carrier_sense;\r\ncontrol_tx_level_invert(dev, p->invert_level);\r\no->invert_level = p->invert_level;\r\no->interrupt_enable = p->interrupt_enable;\r\no->enable = p->enable;\r\nif (p->enable) {\r\nif (p->interrupt_enable)\r\nirqenable_tx(dev, IRQEN_TSE);\r\ncontrol_tx_enable(dev, p->enable);\r\n}\r\nmutex_unlock(&state->tx_params_lock);\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nstruct cx23885_dev *dev = state->dev;\r\nchar *s;\r\nint i, j;\r\nu32 cntrl = cx23888_ir_read4(dev, CX23888_IR_CNTRL_REG);\r\nu32 txclk = cx23888_ir_read4(dev, CX23888_IR_TXCLK_REG) & TXCLK_TCD;\r\nu32 rxclk = cx23888_ir_read4(dev, CX23888_IR_RXCLK_REG) & RXCLK_RCD;\r\nu32 cduty = cx23888_ir_read4(dev, CX23888_IR_CDUTY_REG) & CDUTY_CDC;\r\nu32 stats = cx23888_ir_read4(dev, CX23888_IR_STATS_REG);\r\nu32 irqen = cx23888_ir_read4(dev, CX23888_IR_IRQEN_REG);\r\nu32 filtr = cx23888_ir_read4(dev, CX23888_IR_FILTR_REG) & FILTR_LPF;\r\nv4l2_info(sd, "IR Receiver:\n");\r\nv4l2_info(sd, "\tEnabled: %s\n",\r\ncntrl & CNTRL_RXE ? "yes" : "no");\r\nv4l2_info(sd, "\tDemodulation from a carrier: %s\n",\r\ncntrl & CNTRL_DMD ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tFIFO: %s\n",\r\ncntrl & CNTRL_RFE ? "enabled" : "disabled");\r\nswitch (cntrl & CNTRL_EDG) {\r\ncase CNTRL_EDG_NONE:\r\ns = "disabled";\r\nbreak;\r\ncase CNTRL_EDG_FALL:\r\ns = "falling edge";\r\nbreak;\r\ncase CNTRL_EDG_RISE:\r\ns = "rising edge";\r\nbreak;\r\ncase CNTRL_EDG_BOTH:\r\ns = "rising & falling edges";\r\nbreak;\r\ndefault:\r\ns = "??? edge";\r\nbreak;\r\n}\r\nv4l2_info(sd, "\tPulse timers' start/stop trigger: %s\n", s);\r\nv4l2_info(sd, "\tFIFO data on pulse timer overflow: %s\n",\r\ncntrl & CNTRL_R ? "not loaded" : "overflow marker");\r\nv4l2_info(sd, "\tFIFO interrupt watermark: %s\n",\r\ncntrl & CNTRL_RIC ? "not empty" : "half full or greater");\r\nv4l2_info(sd, "\tLoopback mode: %s\n",\r\ncntrl & CNTRL_LBM ? "loopback active" : "normal receive");\r\nif (cntrl & CNTRL_DMD) {\r\nv4l2_info(sd, "\tExpected carrier (16 clocks): %u Hz\n",\r\nclock_divider_to_carrier_freq(rxclk));\r\nswitch (cntrl & CNTRL_WIN) {\r\ncase CNTRL_WIN_3_3:\r\ni = 3;\r\nj = 3;\r\nbreak;\r\ncase CNTRL_WIN_4_3:\r\ni = 4;\r\nj = 3;\r\nbreak;\r\ncase CNTRL_WIN_3_4:\r\ni = 3;\r\nj = 4;\r\nbreak;\r\ncase CNTRL_WIN_4_4:\r\ni = 4;\r\nj = 4;\r\nbreak;\r\ndefault:\r\ni = 0;\r\nj = 0;\r\nbreak;\r\n}\r\nv4l2_info(sd, "\tNext carrier edge window: 16 clocks "\r\n"-%1d/+%1d, %u to %u Hz\n", i, j,\r\nclock_divider_to_freq(rxclk, 16 + j),\r\nclock_divider_to_freq(rxclk, 16 - i));\r\n}\r\nv4l2_info(sd, "\tMax measurable pulse width: %u us, %llu ns\n",\r\npulse_width_count_to_us(FIFO_RXTX, rxclk),\r\npulse_width_count_to_ns(FIFO_RXTX, rxclk));\r\nv4l2_info(sd, "\tLow pass filter: %s\n",\r\nfiltr ? "enabled" : "disabled");\r\nif (filtr)\r\nv4l2_info(sd, "\tMin acceptable pulse width (LPF): %u us, "\r\n"%u ns\n",\r\nlpf_count_to_us(filtr),\r\nlpf_count_to_ns(filtr));\r\nv4l2_info(sd, "\tPulse width timer timed-out: %s\n",\r\nstats & STATS_RTO ? "yes" : "no");\r\nv4l2_info(sd, "\tPulse width timer time-out intr: %s\n",\r\nirqen & IRQEN_RTE ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tFIFO overrun: %s\n",\r\nstats & STATS_ROR ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO overrun interrupt: %s\n",\r\nirqen & IRQEN_ROE ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tBusy: %s\n",\r\nstats & STATS_RBY ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO service requested: %s\n",\r\nstats & STATS_RSR ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO service request interrupt: %s\n",\r\nirqen & IRQEN_RSE ? "enabled" : "disabled");\r\nv4l2_info(sd, "IR Transmitter:\n");\r\nv4l2_info(sd, "\tEnabled: %s\n",\r\ncntrl & CNTRL_TXE ? "yes" : "no");\r\nv4l2_info(sd, "\tModulation onto a carrier: %s\n",\r\ncntrl & CNTRL_MOD ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tFIFO: %s\n",\r\ncntrl & CNTRL_TFE ? "enabled" : "disabled");\r\nv4l2_info(sd, "\tFIFO interrupt watermark: %s\n",\r\ncntrl & CNTRL_TIC ? "not empty" : "half full or less");\r\nv4l2_info(sd, "\tOutput pin level inversion %s\n",\r\ncntrl & CNTRL_IVO ? "yes" : "no");\r\nv4l2_info(sd, "\tCarrier polarity: %s\n",\r\ncntrl & CNTRL_CPL ? "space:burst mark:noburst"\r\n: "space:noburst mark:burst");\r\nif (cntrl & CNTRL_MOD) {\r\nv4l2_info(sd, "\tCarrier (16 clocks): %u Hz\n",\r\nclock_divider_to_carrier_freq(txclk));\r\nv4l2_info(sd, "\tCarrier duty cycle: %2u/16\n",\r\ncduty + 1);\r\n}\r\nv4l2_info(sd, "\tMax pulse width: %u us, %llu ns\n",\r\npulse_width_count_to_us(FIFO_RXTX, txclk),\r\npulse_width_count_to_ns(FIFO_RXTX, txclk));\r\nv4l2_info(sd, "\tBusy: %s\n",\r\nstats & STATS_TBY ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO service requested: %s\n",\r\nstats & STATS_TSR ? "yes" : "no");\r\nv4l2_info(sd, "\tFIFO service request interrupt: %s\n",\r\nirqen & IRQEN_TSE ? "enabled" : "disabled");\r\nreturn 0;\r\n}\r\nstatic inline int cx23888_ir_dbg_match(const struct v4l2_dbg_match *match)\r\n{\r\nreturn match->type == V4L2_CHIP_MATCH_HOST && match->addr == 2;\r\n}\r\nstatic int cx23888_ir_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nif (cx23888_ir_dbg_match(&chip->match)) {\r\nchip->ident = state->id;\r\nchip->revision = state->rev;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nu32 addr = CX23888_IR_REG_BASE + (u32) reg->reg;\r\nif (!cx23888_ir_dbg_match(&reg->match))\r\nreturn -EINVAL;\r\nif ((addr & 0x3) != 0)\r\nreturn -EINVAL;\r\nif (addr < CX23888_IR_CNTRL_REG || addr > CX23888_IR_LEARN_REG)\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->size = 4;\r\nreg->val = cx23888_ir_read4(state->dev, addr);\r\nreturn 0;\r\n}\r\nstatic int cx23888_ir_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx23888_ir_state *state = to_state(sd);\r\nu32 addr = CX23888_IR_REG_BASE + (u32) reg->reg;\r\nif (!cx23888_ir_dbg_match(&reg->match))\r\nreturn -EINVAL;\r\nif ((addr & 0x3) != 0)\r\nreturn -EINVAL;\r\nif (addr < CX23888_IR_CNTRL_REG || addr > CX23888_IR_LEARN_REG)\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ncx23888_ir_write4(state->dev, addr, reg->val);\r\nreturn 0;\r\n}\r\nint cx23888_ir_probe(struct cx23885_dev *dev)\r\n{\r\nstruct cx23888_ir_state *state;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_subdev_ir_parameters default_params;\r\nint ret;\r\nstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&state->rx_kfifo_lock);\r\nif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nstate->dev = dev;\r\nstate->id = V4L2_IDENT_CX23888_IR;\r\nstate->rev = 0;\r\nsd = &state->sd;\r\nv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\r\nv4l2_set_subdevdata(sd, state);\r\nsnprintf(sd->name, sizeof(sd->name), "%s/888-ir", dev->name);\r\nsd->grp_id = CX23885_HW_888_IR;\r\nret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\r\nif (ret == 0) {\r\ncx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\r\nmutex_init(&state->rx_params_lock);\r\nmemcpy(&default_params, &default_rx_params,\r\nsizeof(struct v4l2_subdev_ir_parameters));\r\nv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\r\nmutex_init(&state->tx_params_lock);\r\nmemcpy(&default_params, &default_tx_params,\r\nsizeof(struct v4l2_subdev_ir_parameters));\r\nv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\r\n} else {\r\nkfifo_free(&state->rx_kfifo);\r\n}\r\nreturn ret;\r\n}\r\nint cx23888_ir_remove(struct cx23885_dev *dev)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct cx23888_ir_state *state;\r\nsd = cx23885_find_hw(dev, CX23885_HW_888_IR);\r\nif (sd == NULL)\r\nreturn -ENODEV;\r\ncx23888_ir_rx_shutdown(sd);\r\ncx23888_ir_tx_shutdown(sd);\r\nstate = to_state(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nkfifo_free(&state->rx_kfifo);\r\nkfree(state);\r\nreturn 0;\r\n}
