int chartab_get_value(char *keyword)\r\n{\r\nint value = 0;\r\nif (!strcmp(keyword, "ALPHA"))\r\nvalue = ALPHA;\r\nelse if (!strcmp(keyword, "B_CTL"))\r\nvalue = B_CTL;\r\nelse if (!strcmp(keyword, "WDLM"))\r\nvalue = WDLM;\r\nelse if (!strcmp(keyword, "A_PUNC"))\r\nvalue = A_PUNC;\r\nelse if (!strcmp(keyword, "PUNC"))\r\nvalue = PUNC;\r\nelse if (!strcmp(keyword, "NUM"))\r\nvalue = NUM;\r\nelse if (!strcmp(keyword, "A_CAP"))\r\nvalue = A_CAP;\r\nelse if (!strcmp(keyword, "B_CAPSYM"))\r\nvalue = B_CAPSYM;\r\nelse if (!strcmp(keyword, "B_SYM"))\r\nvalue = B_SYM;\r\nreturn value;\r\n}\r\nvoid speakup_register_var(struct var_t *var)\r\n{\r\nstatic char nothing[2] = "\0";\r\nint i;\r\nstruct st_var_header *p_header;\r\nBUG_ON(!var || var->var_id < 0 || var->var_id >= MAXVARS);\r\nif (var_ptrs[0] == NULL) {\r\nfor (i = 0; i < MAXVARS; i++) {\r\np_header = &var_headers[i];\r\nvar_ptrs[p_header->var_id] = p_header;\r\np_header->data = NULL;\r\n}\r\n}\r\np_header = var_ptrs[var->var_id];\r\nif (p_header->data != NULL)\r\nreturn;\r\np_header->data = var;\r\nswitch (p_header->var_type) {\r\ncase VAR_STRING:\r\nset_string_var(nothing, p_header, 0);\r\nbreak;\r\ncase VAR_NUM:\r\ncase VAR_TIME:\r\nset_num_var(0, p_header, E_DEFAULT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid speakup_unregister_var(enum var_id_t var_id)\r\n{\r\nstruct st_var_header *p_header;\r\nBUG_ON(var_id < 0 || var_id >= MAXVARS);\r\np_header = var_ptrs[var_id];\r\np_header->data = NULL;\r\n}\r\nstruct st_var_header *get_var_header(enum var_id_t var_id)\r\n{\r\nstruct st_var_header *p_header;\r\nif (var_id < 0 || var_id >= MAXVARS)\r\nreturn NULL;\r\np_header = var_ptrs[var_id];\r\nif (p_header->data == NULL)\r\nreturn NULL;\r\nreturn p_header;\r\n}\r\nstruct st_var_header *var_header_by_name(const char *name)\r\n{\r\nint i;\r\nstruct st_var_header *where = NULL;\r\nif (name != NULL) {\r\ni = 0;\r\nwhile ((i < MAXVARS) && (where == NULL)) {\r\nif (strcmp(name, var_ptrs[i]->name) == 0)\r\nwhere = var_ptrs[i];\r\nelse\r\ni++;\r\n}\r\n}\r\nreturn where;\r\n}\r\nstruct var_t *get_var(enum var_id_t var_id)\r\n{\r\nBUG_ON(var_id < 0 || var_id >= MAXVARS);\r\nBUG_ON(!var_ptrs[var_id]);\r\nreturn var_ptrs[var_id]->data;\r\n}\r\nstruct punc_var_t *get_punc_var(enum var_id_t var_id)\r\n{\r\nstruct punc_var_t *rv = NULL;\r\nstruct punc_var_t *where;\r\nwhere = punc_vars;\r\nwhile ((where->var_id != -1) && (rv == NULL)) {\r\nif (where->var_id == var_id)\r\nrv = where;\r\nelse\r\nwhere++;\r\n}\r\nreturn rv;\r\n}\r\nint set_num_var(int input, struct st_var_header *var, int how)\r\n{\r\nint val;\r\nshort ret = 0;\r\nint *p_val = var->p_val;\r\nint l;\r\nchar buf[32];\r\nchar *cp;\r\nstruct var_t *var_data = var->data;\r\nif (var_data == NULL)\r\nreturn E_UNDEF;\r\nif (how == E_NEW_DEFAULT) {\r\nif (input < var_data->u.n.low || input > var_data->u.n.high)\r\nret = E_RANGE;\r\nelse\r\nvar_data->u.n.default_val = input;\r\nreturn ret;\r\n}\r\nif (how == E_DEFAULT) {\r\nval = var_data->u.n.default_val;\r\nret = SET_DEFAULT;\r\n} else {\r\nif (how == E_SET)\r\nval = input;\r\nelse\r\nval = var_data->u.n.value;\r\nif (how == E_INC)\r\nval += input;\r\nelse if (how == E_DEC)\r\nval -= input;\r\nif (val < var_data->u.n.low || val > var_data->u.n.high)\r\nreturn E_RANGE;\r\n}\r\nvar_data->u.n.value = val;\r\nif (var->var_type == VAR_TIME && p_val != NULL) {\r\n*p_val = msecs_to_jiffies(val);\r\nreturn ret;\r\n}\r\nif (p_val != NULL)\r\n*p_val = val;\r\nif (var->var_id == PUNC_LEVEL) {\r\npunc_mask = punc_masks[val];\r\nreturn ret;\r\n}\r\nif (var_data->u.n.multiplier != 0)\r\nval *= var_data->u.n.multiplier;\r\nval += var_data->u.n.offset;\r\nif (var->var_id < FIRST_SYNTH_VAR || synth == NULL)\r\nreturn ret;\r\nif (synth->synth_adjust != NULL) {\r\nint status = synth->synth_adjust(var);\r\nreturn (status != 0) ? status : ret;\r\n}\r\nif (!var_data->u.n.synth_fmt)\r\nreturn ret;\r\nif (var->var_id == PITCH)\r\ncp = pitch_buff;\r\nelse\r\ncp = buf;\r\nif (!var_data->u.n.out_str)\r\nl = sprintf(cp, var_data->u.n.synth_fmt, (int)val);\r\nelse\r\nl = sprintf(cp,\r\nvar_data->u.n.synth_fmt, var_data->u.n.out_str[val]);\r\nsynth_printf("%s", cp);\r\nreturn ret;\r\n}\r\nint set_string_var(const char *page, struct st_var_header *var, int len)\r\n{\r\nint ret = 0;\r\nstruct var_t *var_data = var->data;\r\nif (var_data == NULL)\r\nreturn E_UNDEF;\r\nif (len > MAXVARLEN)\r\nreturn -E_TOOLONG;\r\nif (!len) {\r\nif (!var_data->u.s.default_val)\r\nreturn 0;\r\nret = SET_DEFAULT;\r\nif (!var->p_val)\r\nvar->p_val = var_data->u.s.default_val;\r\nif (var->p_val != var_data->u.s.default_val)\r\nstrcpy((char *)var->p_val, var_data->u.s.default_val);\r\n} else if (var->p_val)\r\nstrcpy((char *)var->p_val, page);\r\nelse\r\nreturn -E_TOOLONG;\r\nreturn ret;\r\n}\r\nint set_mask_bits(const char *input, const int which, const int how)\r\n{\r\nu_char *cp;\r\nshort mask = punc_info[which].mask;\r\nif (how&1) {\r\nfor (cp = (u_char *)punc_info[3].value; *cp; cp++)\r\nspk_chartab[*cp] &= ~mask;\r\n}\r\ncp = (u_char *)input;\r\nif (cp == 0)\r\ncp = punc_info[which].value;\r\nelse {\r\nfor ( ; *cp; cp++) {\r\nif (*cp < SPACE)\r\nbreak;\r\nif (mask < PUNC) {\r\nif (!(spk_chartab[*cp]&PUNC))\r\nbreak;\r\n} else if (spk_chartab[*cp]&B_NUM)\r\nbreak;\r\n}\r\nif (*cp)\r\nreturn -EINVAL;\r\ncp = (u_char *)input;\r\n}\r\nif (how&2) {\r\nfor ( ; *cp; cp++)\r\nif (*cp > SPACE)\r\nspk_chartab[*cp] |= mask;\r\n} else {\r\nfor ( ; *cp; cp++)\r\nif (*cp > SPACE)\r\nspk_chartab[*cp] &= ~mask;\r\n}\r\nreturn 0;\r\n}\r\nchar *strlwr(char *s)\r\n{\r\nchar *p;\r\nif (s == NULL)\r\nreturn NULL;\r\nfor (p = s; *p; p++)\r\n*p = tolower(*p);\r\nreturn s;\r\n}\r\nchar *speakup_s2i(char *start, int *dest)\r\n{\r\nint val;\r\nchar ch = *start;\r\nif (ch == '-' || ch == '+')\r\nstart++;\r\nif (*start < '0' || *start > '9')\r\nreturn start;\r\nval = (*start) - '0';\r\nstart++;\r\nwhile (*start >= '0' && *start <= '9') {\r\nval *= 10;\r\nval += (*start) - '0';\r\nstart++;\r\n}\r\nif (ch == '-')\r\n*dest = -val;\r\nelse\r\n*dest = val;\r\nreturn start;\r\n}\r\nchar *s2uchar(char *start, char *dest)\r\n{\r\nint val = 0;\r\nwhile (*start && *start <= SPACE)\r\nstart++;\r\nwhile (*start >= '0' && *start <= '9') {\r\nval *= 10;\r\nval += (*start) - '0';\r\nstart++;\r\n}\r\nif (*start == ',')\r\nstart++;\r\n*dest = (u_char)val;\r\nreturn start;\r\n}\r\nchar *xlate(char *s)\r\n{\r\nstatic const char finds[] = "nrtvafe";\r\nstatic const char subs[] = "\n\r\t\013\001\014\033";\r\nstatic const char hx[] = "0123456789abcdefABCDEF";\r\nchar *p = s, *p1, *p2, c;\r\nint num;\r\nwhile ((p = strchr(p, '\\'))) {\r\np1 = p+1;\r\np2 = strchr(finds, *p1);\r\nif (p2) {\r\n*p++ = subs[p2-finds];\r\np1++;\r\n} else if (*p1 >= '0' && *p1 <= '7') {\r\nnum = (*p1++)&7;\r\nwhile (num < 256 && *p1 >= '0' && *p1 <= '7') {\r\nnum <<= 3;\r\nnum = (*p1++)&7;\r\n}\r\n*p++ = num;\r\n} else if (*p1 == 'x' &&\r\nstrchr(hx, p1[1]) && strchr(hx, p1[2])) {\r\np1++;\r\nc = *p1++;\r\nif (c > '9')\r\nc = (c - '7') & 0x0f;\r\nelse\r\nc -= '0';\r\nnum = c << 4;\r\nc = *p1++;\r\nif (c > '9')\r\nc = (c-'7')&0x0f;\r\nelse\r\nc -= '0';\r\nnum += c;\r\n*p++ = num;\r\n} else\r\n*p++ = *p1++;\r\np2 = p;\r\nwhile (*p1)\r\n*p2++ = *p1++;\r\n*p2 = '\0';\r\n}\r\nreturn s;\r\n}
