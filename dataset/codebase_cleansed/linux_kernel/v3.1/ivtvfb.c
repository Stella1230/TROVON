static int ivtvfb_get_framebuffer(struct ivtv *itv, u32 *fbbase,\r\nu32 *fblength)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nint rc;\r\nivtv_firmware_check(itv, "ivtvfb_get_framebuffer");\r\nrc = ivtv_vapi_result(itv, data, CX2341X_OSD_GET_FRAMEBUFFER, 0);\r\n*fbbase = data[0];\r\n*fblength = data[1];\r\nreturn rc;\r\n}\r\nstatic int ivtvfb_get_osd_coords(struct ivtv *itv,\r\nstruct ivtv_osd_coords *osd)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nivtv_vapi_result(itv, data, CX2341X_OSD_GET_OSD_COORDS, 0);\r\nosd->offset = data[0] - oi->video_rbase;\r\nosd->max_offset = oi->display_width * oi->display_height * 4;\r\nosd->pixel_stride = data[1];\r\nosd->lines = data[2];\r\nosd->x = data[3];\r\nosd->y = data[4];\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_set_osd_coords(struct ivtv *itv, const struct ivtv_osd_coords *osd)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\noi->display_width = osd->pixel_stride;\r\noi->display_byte_stride = osd->pixel_stride * oi->bytes_per_pixel;\r\noi->set_osd_coords_x += osd->x;\r\noi->set_osd_coords_y = osd->y;\r\nreturn ivtv_vapi(itv, CX2341X_OSD_SET_OSD_COORDS, 5,\r\nosd->offset + oi->video_rbase,\r\nosd->pixel_stride,\r\nosd->lines, osd->x, osd->y);\r\n}\r\nstatic int ivtvfb_set_display_window(struct ivtv *itv, struct v4l2_rect *ivtv_window)\r\n{\r\nint osd_height_limit = itv->is_out_50hz ? 576 : 480;\r\nif ((ivtv_window->height > osd_height_limit) || (ivtv_window->width > IVTV_OSD_MAX_WIDTH))\r\nreturn -EINVAL;\r\nif (ivtv_window->top + ivtv_window->height > osd_height_limit) {\r\nIVTVFB_DEBUG_WARN("ivtv_ioctl_fb_set_display_window - Invalid height setting (%d, %d)\n",\r\nivtv_window->top, ivtv_window->height);\r\nivtv_window->top = osd_height_limit - ivtv_window->height;\r\n}\r\nif (ivtv_window->left + ivtv_window->width > IVTV_OSD_MAX_WIDTH) {\r\nIVTVFB_DEBUG_WARN("ivtv_ioctl_fb_set_display_window - Invalid width setting (%d, %d)\n",\r\nivtv_window->left, ivtv_window->width);\r\nivtv_window->left = IVTV_OSD_MAX_WIDTH - ivtv_window->width;\r\n}\r\nwrite_reg((ivtv_window->top << 16) | ivtv_window->left, 0x02a04);\r\nwrite_reg(((ivtv_window->top+ivtv_window->height) << 16) | (ivtv_window->left+ivtv_window->width), 0x02a08);\r\nitv->yuv_info.osd_vis_w = ivtv_window->width;\r\nitv->yuv_info.osd_vis_h = ivtv_window->height;\r\nitv->yuv_info.osd_x_offset = ivtv_window->left;\r\nitv->yuv_info.osd_y_offset = ivtv_window->top;\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_prep_dec_dma_to_device(struct ivtv *itv,\r\nunsigned long ivtv_dest_addr, void __user *userbuf,\r\nint size_in_bytes)\r\n{\r\nDEFINE_WAIT(wait);\r\nint got_sig = 0;\r\nmutex_lock(&itv->udma.lock);\r\nif (ivtv_udma_setup(itv, ivtv_dest_addr, userbuf, size_in_bytes) <= 0) {\r\nmutex_unlock(&itv->udma.lock);\r\nIVTVFB_WARN("ivtvfb_prep_dec_dma_to_device, "\r\n"Error with get_user_pages: %d bytes, %d pages returned\n",\r\nsize_in_bytes, itv->udma.page_count);\r\nreturn -EIO;\r\n}\r\nIVTVFB_DEBUG_INFO("ivtvfb_prep_dec_dma_to_device, %d bytes, %d pages\n",\r\nsize_in_bytes, itv->udma.page_count);\r\nivtv_udma_prepare(itv);\r\nprepare_to_wait(&itv->dma_waitq, &wait, TASK_INTERRUPTIBLE);\r\nwhile (test_bit(IVTV_F_I_UDMA_PENDING, &itv->i_flags) ||\r\ntest_bit(IVTV_F_I_UDMA, &itv->i_flags)) {\r\ngot_sig = signal_pending(current);\r\nif (got_sig && test_and_clear_bit(IVTV_F_I_UDMA_PENDING, &itv->i_flags))\r\nbreak;\r\ngot_sig = 0;\r\nschedule();\r\n}\r\nfinish_wait(&itv->dma_waitq, &wait);\r\nivtv_udma_unmap(itv);\r\nmutex_unlock(&itv->udma.lock);\r\nif (got_sig) {\r\nIVTV_DEBUG_INFO("User stopped OSD\n");\r\nreturn -EINTR;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_prep_frame(struct ivtv *itv, int cmd, void __user *source,\r\nunsigned long dest_offset, int count)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct osd_info *oi = itv->osd_info;\r\nif (count == 0) {\r\nIVTVFB_DEBUG_WARN("ivtvfb_prep_frame: Nothing to do. count = 0\n");\r\nreturn -EINVAL;\r\n}\r\nif ((dest_offset + count) > oi->video_buffer_size) {\r\nIVTVFB_WARN("ivtvfb_prep_frame: Overflowing the framebuffer %ld, only %d available\n",\r\ndest_offset + count, oi->video_buffer_size);\r\nreturn -E2BIG;\r\n}\r\nif ((unsigned long)source & 3)\r\nIVTVFB_WARN("ivtvfb_prep_frame: Source address not 32 bit aligned (0x%08lx)\n",\r\n(unsigned long)source);\r\nif (dest_offset & 3)\r\nIVTVFB_WARN("ivtvfb_prep_frame: Dest offset not 32 bit aligned (%ld)\n", dest_offset);\r\nif (count & 3)\r\nIVTVFB_WARN("ivtvfb_prep_frame: Count not a multiple of 4 (%d)\n", count);\r\nif (!access_ok(VERIFY_READ, source + dest_offset, count)) {\r\nIVTVFB_WARN("Invalid userspace pointer 0x%08lx\n",\r\n(unsigned long)source);\r\nIVTVFB_DEBUG_WARN("access_ok() failed for offset 0x%08lx source 0x%08lx count %d\n",\r\ndest_offset, (unsigned long)source,\r\ncount);\r\nreturn -EINVAL;\r\n}\r\ndest_offset += IVTV_DECODER_OFFSET + oi->video_rbase;\r\nreturn ivtvfb_prep_dec_dma_to_device(itv, dest_offset, source, count);\r\n}\r\nstatic ssize_t ivtvfb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long p = *ppos;\r\nvoid *dst;\r\nint err = 0;\r\nint dma_err;\r\nunsigned long total_size;\r\nstruct ivtv *itv = (struct ivtv *) info->par;\r\nunsigned long dma_offset =\r\nIVTV_DECODER_OFFSET + itv->osd_info->video_rbase;\r\nunsigned long dma_size;\r\nu16 lead = 0, tail = 0;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\ntotal_size = info->screen_size;\r\nif (total_size == 0)\r\ntotal_size = info->fix.smem_len;\r\nif (p > total_size)\r\nreturn -EFBIG;\r\nif (count > total_size) {\r\nerr = -EFBIG;\r\ncount = total_size;\r\n}\r\nif (count + p > total_size) {\r\nif (!err)\r\nerr = -ENOSPC;\r\ncount = total_size - p;\r\n}\r\ndst = (void __force *) (info->screen_base + p);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\nif (count >= 4096 &&\r\n((unsigned long)buf & 3) == ((unsigned long)dst & 3)) {\r\nif ((unsigned long)dst & 3) {\r\nlead = 4 - ((unsigned long)dst & 3);\r\nif (copy_from_user(dst, buf, lead))\r\nreturn -EFAULT;\r\nbuf += lead;\r\ndst += lead;\r\n}\r\nif ((count - lead) & 3)\r\ntail = (count - lead) & 3;\r\ndma_size = count - lead - tail;\r\ndma_err = ivtvfb_prep_dec_dma_to_device(itv,\r\np + lead + dma_offset, (void __user *)buf, dma_size);\r\nif (dma_err)\r\nreturn dma_err;\r\ndst += dma_size;\r\nbuf += dma_size;\r\nif (tail && copy_from_user(dst, buf, tail))\r\nreturn -EFAULT;\r\n} else if (copy_from_user(dst, buf, count)) {\r\nreturn -EFAULT;\r\n}\r\nif (!err)\r\n*ppos += count;\r\nreturn (err) ? err : count;\r\n}\r\nstatic int ivtvfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct ivtv *itv = (struct ivtv *)info->par;\r\nint rc = 0;\r\nswitch (cmd) {\r\ncase FBIOGET_VBLANK: {\r\nstruct fb_vblank vblank;\r\nu32 trace;\r\nmemset(&vblank, 0, sizeof(struct fb_vblank));\r\nvblank.flags = FB_VBLANK_HAVE_COUNT |FB_VBLANK_HAVE_VCOUNT |\r\nFB_VBLANK_HAVE_VSYNC;\r\ntrace = read_reg(IVTV_REG_DEC_LINE_FIELD) >> 16;\r\nif (itv->is_out_50hz && trace > 312)\r\ntrace -= 312;\r\nelse if (itv->is_out_60hz && trace > 262)\r\ntrace -= 262;\r\nif (trace == 1)\r\nvblank.flags |= FB_VBLANK_VSYNCING;\r\nvblank.count = itv->last_vsync_field;\r\nvblank.vcount = trace;\r\nvblank.hcount = 0;\r\nif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase FBIO_WAITFORVSYNC:\r\nprepare_to_wait(&itv->vsync_waitq, &wait, TASK_INTERRUPTIBLE);\r\nif (!schedule_timeout(msecs_to_jiffies(50)))\r\nrc = -ETIMEDOUT;\r\nfinish_wait(&itv->vsync_waitq, &wait);\r\nreturn rc;\r\ncase IVTVFB_IOC_DMA_FRAME: {\r\nstruct ivtvfb_dma_frame args;\r\nIVTVFB_DEBUG_INFO("IVTVFB_IOC_DMA_FRAME\n");\r\nif (copy_from_user(&args, (void __user *)arg, sizeof(args)))\r\nreturn -EFAULT;\r\nreturn ivtvfb_prep_frame(itv, cmd, args.source, args.dest_offset, args.count);\r\n}\r\ndefault:\r\nIVTVFB_DEBUG_INFO("Unknown ioctl %08x\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_set_var(struct ivtv *itv, struct fb_var_screeninfo *var)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\nstruct ivtv_osd_coords ivtv_osd;\r\nstruct v4l2_rect ivtv_window;\r\nint osd_mode = -1;\r\nIVTVFB_DEBUG_INFO("ivtvfb_set_var\n");\r\nif (var->nonstd)\r\nwrite_reg(read_reg(0x02a00) | 0x0002000, 0x02a00);\r\nelse\r\nwrite_reg(read_reg(0x02a00) & ~0x0002000, 0x02a00);\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nosd_mode = IVTV_OSD_BPP_8;\r\nbreak;\r\ncase 32:\r\nosd_mode = IVTV_OSD_BPP_32;\r\nbreak;\r\ncase 16:\r\nswitch (var->green.length) {\r\ncase 4:\r\nosd_mode = IVTV_OSD_BPP_16_444;\r\nbreak;\r\ncase 5:\r\nosd_mode = IVTV_OSD_BPP_16_555;\r\nbreak;\r\ncase 6:\r\nosd_mode = IVTV_OSD_BPP_16_565;\r\nbreak;\r\ndefault:\r\nIVTVFB_DEBUG_WARN("ivtvfb_set_var - Invalid bpp\n");\r\n}\r\nbreak;\r\ndefault:\r\nIVTVFB_DEBUG_WARN("ivtvfb_set_var - Invalid bpp\n");\r\n}\r\nif (osd_mode != -1) {\r\nivtv_vapi(itv, CX2341X_OSD_SET_PIXEL_FORMAT, 1, 0);\r\nivtv_vapi(itv, CX2341X_OSD_SET_PIXEL_FORMAT, 1, osd_mode);\r\n}\r\noi->bits_per_pixel = var->bits_per_pixel;\r\noi->bytes_per_pixel = var->bits_per_pixel / 8;\r\nswitch (var->vmode & FB_VMODE_MASK) {\r\ncase FB_VMODE_NONINTERLACED:\r\nivtv_vapi(itv, CX2341X_OSD_SET_FLICKER_STATE, 1, 1);\r\nbreak;\r\ncase FB_VMODE_INTERLACED:\r\nivtv_vapi(itv, CX2341X_OSD_SET_FLICKER_STATE, 1, 0);\r\nbreak;\r\ndefault:\r\nIVTVFB_DEBUG_WARN("ivtvfb_set_var - Invalid video mode\n");\r\n}\r\nivtvfb_get_osd_coords(itv, &ivtv_osd);\r\nivtv_osd.pixel_stride = var->xres_virtual;\r\nivtv_osd.lines = var->yres_virtual;\r\nivtv_osd.x = 0;\r\nivtv_osd.y = 0;\r\nivtvfb_set_osd_coords(itv, &ivtv_osd);\r\nivtv_window.width = var->xres;\r\nivtv_window.height = var->yres;\r\nif (!var->upper_margin)\r\nvar->upper_margin++;\r\nif (!var->left_margin)\r\nvar->left_margin++;\r\nivtv_window.top = var->upper_margin - 1;\r\nivtv_window.left = var->left_margin - 1;\r\nivtvfb_set_display_window(itv, &ivtv_window);\r\nitv->yuv_info.osd_full_w = ivtv_osd.pixel_stride;\r\nitv->yuv_info.osd_full_h = ivtv_osd.lines;\r\nitv->yuv_info.yuv_forced_update = 1;\r\nmemcpy(&oi->fbvar_cur, var, sizeof(oi->fbvar_cur));\r\nIVTVFB_DEBUG_INFO("Display size: %dx%d (virtual %dx%d) @ %dbpp\n",\r\nvar->xres, var->yres,\r\nvar->xres_virtual, var->yres_virtual,\r\nvar->bits_per_pixel);\r\nIVTVFB_DEBUG_INFO("Display position: %d, %d\n",\r\nvar->left_margin, var->upper_margin);\r\nIVTVFB_DEBUG_INFO("Display filter: %s\n",\r\n(var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED ? "on" : "off");\r\nIVTVFB_DEBUG_INFO("Color space: %s\n", var->nonstd ? "YUV" : "RGB");\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_get_fix(struct ivtv *itv, struct fb_fix_screeninfo *fix)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\nIVTVFB_DEBUG_INFO("ivtvfb_get_fix\n");\r\nmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\r\nstrlcpy(fix->id, "cx23415 TV out", sizeof(fix->id));\r\nfix->smem_start = oi->video_pbase;\r\nfix->smem_len = oi->video_buffer_size;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->visual = (oi->bits_per_pixel == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\nfix->xpanstep = 1;\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 0;\r\nfix->line_length = oi->display_byte_stride;\r\nfix->accel = FB_ACCEL_NONE;\r\nreturn 0;\r\n}\r\nstatic int _ivtvfb_check_var(struct fb_var_screeninfo *var, struct ivtv *itv)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\nint osd_height_limit;\r\nu32 pixclock, hlimit, vlimit;\r\nIVTVFB_DEBUG_INFO("ivtvfb_check_var\n");\r\nif (itv->is_out_50hz) {\r\npixclock = 84316;\r\nhlimit = 776;\r\nvlimit = 591;\r\nosd_height_limit = 576;\r\n}\r\nelse {\r\npixclock = 83926;\r\nhlimit = 776;\r\nvlimit = 495;\r\nosd_height_limit = 480;\r\n}\r\nif (var->bits_per_pixel == 8 || var->bits_per_pixel == 32) {\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\n}\r\nelse if (var->bits_per_pixel == 16) {\r\nswitch (var->green.length) {\r\ncase 4:\r\nvar->red.offset = 8;\r\nvar->red.length = 4;\r\nvar->green.offset = 4;\r\nvar->green.length = 4;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 4;\r\nvar->transp.offset = 12;\r\nvar->transp.length = 1;\r\nbreak;\r\ncase 5:\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 15;\r\nvar->transp.length = 1;\r\nbreak;\r\ndefault:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\n}\r\n}\r\nelse {\r\nIVTVFB_DEBUG_WARN("Invalid colour mode: %d\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres > IVTV_OSD_MAX_WIDTH || var->yres > osd_height_limit) {\r\nIVTVFB_DEBUG_WARN("Invalid resolution: %dx%d\n",\r\nvar->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres_virtual > 4095 / (var->bits_per_pixel / 8) ||\r\nvar->xres_virtual * var->yres_virtual * (var->bits_per_pixel / 8) > oi->video_buffer_size ||\r\nvar->xres_virtual < var->xres ||\r\nvar->yres_virtual < var->yres) {\r\nIVTVFB_DEBUG_WARN("Invalid virtual resolution: %dx%d\n",\r\nvar->xres_virtual, var->yres_virtual);\r\nreturn -EINVAL;\r\n}\r\nif (var->bits_per_pixel == 8) {\r\nif (var->xres & 3) {\r\nIVTVFB_DEBUG_WARN("Invalid resolution for 8bpp: %d\n", var->xres);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres_virtual & 3) {\r\nIVTVFB_DEBUG_WARN("Invalid virtual resolution for 8bpp: %d)\n", var->xres_virtual);\r\nreturn -EINVAL;\r\n}\r\n}\r\nelse if (var->bits_per_pixel == 16) {\r\nif (var->xres & 1) {\r\nIVTVFB_DEBUG_WARN("Invalid resolution for 16bpp: %d\n", var->xres);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres_virtual & 1) {\r\nIVTVFB_DEBUG_WARN("Invalid virtual resolution for 16bpp: %d)\n", var->xres_virtual);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (var->xoffset >= var->xres_virtual || var->yoffset >= var->yres_virtual) {\r\nIVTVFB_DEBUG_WARN("Invalid offset: %d (%d) %d (%d)\n",\r\nvar->xoffset, var->xres_virtual, var->yoffset, var->yres_virtual);\r\nreturn -EINVAL;\r\n}\r\nif (var->nonstd > 1) {\r\nIVTVFB_DEBUG_WARN("Invalid nonstd % d\n", var->nonstd);\r\nreturn -EINVAL;\r\n}\r\nif (((var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED) &&\r\n((var->vmode & FB_VMODE_MASK) != FB_VMODE_INTERLACED)) {\r\nIVTVFB_DEBUG_WARN("Invalid video mode: %d\n", var->vmode & FB_VMODE_MASK);\r\nreturn -EINVAL;\r\n}\r\nif (var->left_margin + var->xres > IVTV_OSD_MAX_WIDTH + 1)\r\nvar->left_margin = 1 + ((IVTV_OSD_MAX_WIDTH - var->xres) / 2);\r\nif (var->upper_margin + var->yres > (itv->is_out_50hz ? 577 : 481))\r\nvar->upper_margin = 1 + (((itv->is_out_50hz ? 576 : 480) -\r\nvar->yres) / 2);\r\nvar->right_margin = hlimit - var->left_margin - var->xres;\r\nvar->lower_margin = vlimit - var->upper_margin - var->yres;\r\nvar->hsync_len = 24;\r\nvar->vsync_len = 2;\r\nif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED)\r\nvar->pixclock = pixclock / 2;\r\nelse\r\nvar->pixclock = pixclock;\r\nitv->osd_rect.width = var->xres;\r\nitv->osd_rect.height = var->yres;\r\nIVTVFB_DEBUG_INFO("Display size: %dx%d (virtual %dx%d) @ %dbpp\n",\r\nvar->xres, var->yres,\r\nvar->xres_virtual, var->yres_virtual,\r\nvar->bits_per_pixel);\r\nIVTVFB_DEBUG_INFO("Display position: %d, %d\n",\r\nvar->left_margin, var->upper_margin);\r\nIVTVFB_DEBUG_INFO("Display filter: %s\n",\r\n(var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED ? "on" : "off");\r\nIVTVFB_DEBUG_INFO("Color space: %s\n", var->nonstd ? "YUV" : "RGB");\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct ivtv *itv = (struct ivtv *) info->par;\r\nIVTVFB_DEBUG_INFO("ivtvfb_check_var\n");\r\nreturn _ivtvfb_check_var(var, itv);\r\n}\r\nstatic int ivtvfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nu32 osd_pan_index;\r\nstruct ivtv *itv = (struct ivtv *) info->par;\r\nif (var->yoffset + info->var.yres > info->var.yres_virtual ||\r\nvar->xoffset + info->var.xres > info->var.xres_virtual)\r\nreturn -EINVAL;\r\nosd_pan_index = var->yoffset * info->fix.line_length\r\n+ var->xoffset * info->var.bits_per_pixel / 8;\r\nwrite_reg(osd_pan_index, 0x02A0C);\r\nitv->yuv_info.osd_x_pan = var->xoffset;\r\nitv->yuv_info.osd_y_pan = var->yoffset;\r\nitv->yuv_info.yuv_forced_update = 1;\r\nitv->osd_info->pan_cur = osd_pan_index;\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_set_par(struct fb_info *info)\r\n{\r\nint rc = 0;\r\nstruct ivtv *itv = (struct ivtv *) info->par;\r\nIVTVFB_DEBUG_INFO("ivtvfb_set_par\n");\r\nrc = ivtvfb_set_var(itv, &info->var);\r\nivtvfb_pan_display(&info->var, info);\r\nivtvfb_get_fix(itv, &info->fix);\r\nivtv_firmware_check(itv, "ivtvfb_set_par");\r\nreturn rc;\r\n}\r\nstatic int ivtvfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nu32 color, *palette;\r\nstruct ivtv *itv = (struct ivtv *)info->par;\r\nif (regno >= info->cmap.len)\r\nreturn -EINVAL;\r\ncolor = ((transp & 0xFF00) << 16) |((red & 0xFF00) << 8) | (green & 0xFF00) | ((blue & 0xFF00) >> 8);\r\nif (info->var.bits_per_pixel <= 8) {\r\nwrite_reg(regno, 0x02a30);\r\nwrite_reg(color, 0x02a34);\r\nitv->osd_info->palette_cur[regno] = color;\r\nreturn 0;\r\n}\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\npalette = info->pseudo_palette;\r\nif (info->var.bits_per_pixel == 16) {\r\nswitch (info->var.green.length) {\r\ncase 4:\r\ncolor = ((red & 0xf000) >> 4) |\r\n((green & 0xf000) >> 8) |\r\n((blue & 0xf000) >> 12);\r\nbreak;\r\ncase 5:\r\ncolor = ((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) |\r\n((blue & 0xf800) >> 11);\r\nbreak;\r\ncase 6:\r\ncolor = (red & 0xf800 ) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\nbreak;\r\n}\r\n}\r\npalette[regno] = color;\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct ivtv *itv = (struct ivtv *)info->par;\r\nIVTVFB_DEBUG_INFO("Set blanking mode : %d\n", blank_mode);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nivtv_vapi(itv, CX2341X_OSD_SET_STATE, 1, 1);\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 1);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nivtv_vapi(itv, CX2341X_OSD_SET_STATE, 1, 0);\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 1);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_stream, 0);\r\nivtv_vapi(itv, CX2341X_OSD_SET_STATE, 1, 0);\r\nbreak;\r\n}\r\nitv->osd_info->blank_cur = blank_mode;\r\nreturn 0;\r\n}\r\nstatic void ivtvfb_restore(struct ivtv *itv)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\nint i;\r\nivtvfb_set_var(itv, &oi->fbvar_cur);\r\nivtvfb_blank(oi->blank_cur, &oi->ivtvfb_info);\r\nfor (i = 0; i < 256; i++) {\r\nwrite_reg(i, 0x02a30);\r\nwrite_reg(oi->palette_cur[i], 0x02a34);\r\n}\r\nwrite_reg(oi->pan_cur, 0x02a0c);\r\n}\r\nstatic int ivtvfb_init_vidmode(struct ivtv *itv)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\nstruct v4l2_rect start_window;\r\nint max_height;\r\nif (osd_depth != 8 && osd_depth != 16 && osd_depth != 32)\r\nosd_depth = 8;\r\noi->bits_per_pixel = osd_depth;\r\noi->bytes_per_pixel = oi->bits_per_pixel / 8;\r\nif (osd_xres > 720)\r\nosd_xres = 720;\r\nif (osd_depth == 8)\r\nosd_xres &= ~3;\r\nelse if (osd_depth == 16)\r\nosd_xres &= ~1;\r\nstart_window.width = osd_xres ? osd_xres : 640;\r\nif (osd_left && osd_left + start_window.width > 721) {\r\nIVTVFB_ERR("Invalid osd_left - assuming default\n");\r\nosd_left = 0;\r\n}\r\nosd_left--;\r\nstart_window.left = osd_left >= 0 ?\r\nosd_left : ((IVTV_OSD_MAX_WIDTH - start_window.width) / 2);\r\noi->display_byte_stride =\r\nstart_window.width * oi->bytes_per_pixel;\r\nmax_height = itv->is_out_50hz ? 576 : 480;\r\nif (osd_yres > max_height)\r\nosd_yres = max_height;\r\nstart_window.height = osd_yres ?\r\nosd_yres : itv->is_out_50hz ? 480 : 400;\r\nif (osd_upper + start_window.height > max_height + 1) {\r\nIVTVFB_ERR("Invalid osd_upper - assuming default\n");\r\nosd_upper = 0;\r\n}\r\nosd_upper--;\r\nstart_window.top = osd_upper >= 0 ? osd_upper : ((max_height - start_window.height) / 2);\r\noi->display_width = start_window.width;\r\noi->display_height = start_window.height;\r\noi->ivtvfb_defined.xres = oi->display_width;\r\noi->ivtvfb_defined.yres = oi->display_height;\r\noi->ivtvfb_defined.xres_virtual = oi->display_width;\r\noi->ivtvfb_defined.yres_virtual = oi->display_height;\r\noi->ivtvfb_defined.bits_per_pixel = oi->bits_per_pixel;\r\noi->ivtvfb_defined.vmode = (osd_laced ? FB_VMODE_INTERLACED : FB_VMODE_NONINTERLACED);\r\noi->ivtvfb_defined.left_margin = start_window.left + 1;\r\noi->ivtvfb_defined.upper_margin = start_window.top + 1;\r\noi->ivtvfb_defined.accel_flags = FB_ACCEL_NONE;\r\noi->ivtvfb_defined.nonstd = 0;\r\n_ivtvfb_check_var(&oi->ivtvfb_defined, itv);\r\nivtvfb_get_fix(itv, &oi->ivtvfb_fix);\r\noi->ivtvfb_info.node = -1;\r\noi->ivtvfb_info.flags = FBINFO_FLAG_DEFAULT;\r\noi->ivtvfb_info.fbops = &ivtvfb_ops;\r\noi->ivtvfb_info.par = itv;\r\noi->ivtvfb_info.var = oi->ivtvfb_defined;\r\noi->ivtvfb_info.fix = oi->ivtvfb_fix;\r\noi->ivtvfb_info.screen_base = (u8 __iomem *)oi->video_vbase;\r\noi->ivtvfb_info.fbops = &ivtvfb_ops;\r\noi->ivtvfb_info.monspecs.hfmin = 8000;\r\noi->ivtvfb_info.monspecs.hfmax = 70000;\r\noi->ivtvfb_info.monspecs.vfmin = 10;\r\noi->ivtvfb_info.monspecs.vfmax = 100;\r\nif (fb_alloc_cmap(&oi->ivtvfb_info.cmap, 256, 1)) {\r\nIVTVFB_ERR("abort, unable to alloc cmap\n");\r\nreturn -ENOMEM;\r\n}\r\noi->ivtvfb_info.pseudo_palette =\r\nkmalloc(sizeof(u32) * 16, GFP_KERNEL|__GFP_NOWARN);\r\nif (!oi->ivtvfb_info.pseudo_palette) {\r\nIVTVFB_ERR("abort, unable to alloc pseudo palette\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_init_io(struct ivtv *itv)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\nmutex_lock(&itv->serialize_lock);\r\nif (ivtv_init_on_first_open(itv)) {\r\nmutex_unlock(&itv->serialize_lock);\r\nIVTVFB_ERR("Failed to initialize ivtv\n");\r\nreturn -ENXIO;\r\n}\r\nmutex_unlock(&itv->serialize_lock);\r\nif (ivtvfb_get_framebuffer(itv, &oi->video_rbase,\r\n&oi->video_buffer_size) < 0) {\r\nIVTVFB_ERR("Firmware failed to respond\n");\r\nreturn -EIO;\r\n}\r\noi->video_buffer_size = 1704960;\r\noi->video_pbase = itv->base_addr + IVTV_DECODER_OFFSET + oi->video_rbase;\r\noi->video_vbase = itv->dec_mem + oi->video_rbase;\r\nif (!oi->video_vbase) {\r\nIVTVFB_ERR("abort, video memory 0x%x @ 0x%lx isn't mapped!\n",\r\noi->video_buffer_size, oi->video_pbase);\r\nreturn -EIO;\r\n}\r\nIVTVFB_INFO("Framebuffer at 0x%lx, mapped to 0x%p, size %dk\n",\r\noi->video_pbase, oi->video_vbase,\r\noi->video_buffer_size / 1024);\r\n#ifdef CONFIG_MTRR\r\n{\r\nint size_shift = 31;\r\nwhile (!(oi->video_buffer_size & (1 << size_shift))) {\r\nsize_shift--;\r\n}\r\nsize_shift++;\r\noi->fb_start_aligned_physaddr = oi->video_pbase & ~((1 << size_shift) - 1);\r\noi->fb_end_aligned_physaddr = oi->video_pbase + oi->video_buffer_size;\r\noi->fb_end_aligned_physaddr += (1 << size_shift) - 1;\r\noi->fb_end_aligned_physaddr &= ~((1 << size_shift) - 1);\r\nif (mtrr_add(oi->fb_start_aligned_physaddr,\r\noi->fb_end_aligned_physaddr - oi->fb_start_aligned_physaddr,\r\nMTRR_TYPE_WRCOMB, 1) < 0) {\r\nIVTVFB_INFO("disabled mttr\n");\r\noi->fb_start_aligned_physaddr = 0;\r\noi->fb_end_aligned_physaddr = 0;\r\n}\r\n}\r\n#endif\r\nmemset_io(oi->video_vbase, 0, oi->video_buffer_size);\r\nreturn 0;\r\n}\r\nstatic void ivtvfb_release_buffers (struct ivtv *itv)\r\n{\r\nstruct osd_info *oi = itv->osd_info;\r\nif (oi->ivtvfb_info.cmap.len)\r\nfb_dealloc_cmap(&oi->ivtvfb_info.cmap);\r\nif (oi->ivtvfb_info.pseudo_palette)\r\nkfree(oi->ivtvfb_info.pseudo_palette);\r\n#ifdef CONFIG_MTRR\r\nif (oi->fb_end_aligned_physaddr) {\r\nmtrr_del(-1, oi->fb_start_aligned_physaddr,\r\noi->fb_end_aligned_physaddr - oi->fb_start_aligned_physaddr);\r\n}\r\n#endif\r\nkfree(oi);\r\nitv->osd_info = NULL;\r\n}\r\nstatic int ivtvfb_init_card(struct ivtv *itv)\r\n{\r\nint rc;\r\nif (itv->osd_info) {\r\nIVTVFB_ERR("Card %d already initialised\n", ivtvfb_card_id);\r\nreturn -EBUSY;\r\n}\r\nitv->osd_info = kzalloc(sizeof(struct osd_info),\r\nGFP_ATOMIC|__GFP_NOWARN);\r\nif (itv->osd_info == NULL) {\r\nIVTVFB_ERR("Failed to allocate memory for osd_info\n");\r\nreturn -ENOMEM;\r\n}\r\nrc = ivtvfb_init_io(itv);\r\nif (rc) {\r\nivtvfb_release_buffers(itv);\r\nreturn rc;\r\n}\r\nif ((rc = ivtvfb_init_vidmode(itv))) {\r\nivtvfb_release_buffers(itv);\r\nreturn rc;\r\n}\r\nif (register_framebuffer(&itv->osd_info->ivtvfb_info) < 0) {\r\nivtvfb_release_buffers(itv);\r\nreturn -EINVAL;\r\n}\r\nitv->osd_video_pbase = itv->osd_info->video_pbase;\r\nivtvfb_set_par(&itv->osd_info->ivtvfb_info);\r\nwrite_reg(0, 0x02a30);\r\nwrite_reg(0, 0x02a34);\r\nivtvfb_blank(FB_BLANK_UNBLANK, &itv->osd_info->ivtvfb_info);\r\nitv->ivtvfb_restore = ivtvfb_restore;\r\nivtv_udma_alloc(itv);\r\nreturn 0;\r\n}\r\nstatic int __init ivtvfb_callback_init(struct device *dev, void *p)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\r\nstruct ivtv *itv = container_of(v4l2_dev, struct ivtv, v4l2_dev);\r\nif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT) {\r\nif (ivtvfb_init_card(itv) == 0) {\r\nIVTVFB_INFO("Framebuffer registered on %s\n",\r\nitv->v4l2_dev.name);\r\n(*(int *)p)++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtvfb_callback_cleanup(struct device *dev, void *p)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\r\nstruct ivtv *itv = container_of(v4l2_dev, struct ivtv, v4l2_dev);\r\nstruct osd_info *oi = itv->osd_info;\r\nif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT) {\r\nif (unregister_framebuffer(&itv->osd_info->ivtvfb_info)) {\r\nIVTVFB_WARN("Framebuffer %d is in use, cannot unload\n",\r\nitv->instance);\r\nreturn 0;\r\n}\r\nIVTVFB_INFO("Unregister framebuffer %d\n", itv->instance);\r\nitv->ivtvfb_restore = NULL;\r\nivtvfb_blank(FB_BLANK_VSYNC_SUSPEND, &oi->ivtvfb_info);\r\nivtvfb_release_buffers(itv);\r\nitv->osd_video_pbase = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ivtvfb_init(void)\r\n{\r\nstruct device_driver *drv;\r\nint registered = 0;\r\nint err;\r\nif (ivtvfb_card_id < -1 || ivtvfb_card_id >= IVTV_MAX_CARDS) {\r\nprintk(KERN_ERR "ivtvfb: ivtvfb_card_id parameter is out of range (valid range: -1 - %d)\n",\r\nIVTV_MAX_CARDS - 1);\r\nreturn -EINVAL;\r\n}\r\ndrv = driver_find("ivtv", &pci_bus_type);\r\nerr = driver_for_each_device(drv, NULL, &registered, ivtvfb_callback_init);\r\nput_driver(drv);\r\nif (!registered) {\r\nprintk(KERN_ERR "ivtvfb: no cards found\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ivtvfb_cleanup(void)\r\n{\r\nstruct device_driver *drv;\r\nint err;\r\nprintk(KERN_INFO "ivtvfb: Unloading framebuffer module\n");\r\ndrv = driver_find("ivtv", &pci_bus_type);\r\nerr = driver_for_each_device(drv, NULL, NULL, ivtvfb_callback_cleanup);\r\nput_driver(drv);\r\n}
