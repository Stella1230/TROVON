static inline bool irq_work_is_set(struct irq_work *entry, int flags)\r\n{\r\nreturn (unsigned long)entry->next & flags;\r\n}\r\nstatic inline struct irq_work *irq_work_next(struct irq_work *entry)\r\n{\r\nunsigned long next = (unsigned long)entry->next;\r\nnext &= ~IRQ_WORK_FLAGS;\r\nreturn (struct irq_work *)next;\r\n}\r\nstatic inline struct irq_work *next_flags(struct irq_work *entry, int flags)\r\n{\r\nunsigned long next = (unsigned long)entry;\r\nnext |= flags;\r\nreturn (struct irq_work *)next;\r\n}\r\nstatic bool irq_work_claim(struct irq_work *entry)\r\n{\r\nstruct irq_work *next, *nflags;\r\ndo {\r\nnext = entry->next;\r\nif ((unsigned long)next & IRQ_WORK_PENDING)\r\nreturn false;\r\nnflags = next_flags(next, IRQ_WORK_FLAGS);\r\n} while (cmpxchg(&entry->next, next, nflags) != next);\r\nreturn true;\r\n}\r\nvoid __weak arch_irq_work_raise(void)\r\n{\r\n}\r\nstatic void __irq_work_queue(struct irq_work *entry)\r\n{\r\nstruct irq_work *next;\r\npreempt_disable();\r\ndo {\r\nnext = __this_cpu_read(irq_work_list);\r\nentry->next = next_flags(next, IRQ_WORK_FLAGS);\r\n} while (this_cpu_cmpxchg(irq_work_list, next, entry) != next);\r\nif (!irq_work_next(entry))\r\narch_irq_work_raise();\r\npreempt_enable();\r\n}\r\nbool irq_work_queue(struct irq_work *entry)\r\n{\r\nif (!irq_work_claim(entry)) {\r\nreturn false;\r\n}\r\n__irq_work_queue(entry);\r\nreturn true;\r\n}\r\nvoid irq_work_run(void)\r\n{\r\nstruct irq_work *list;\r\nif (this_cpu_read(irq_work_list) == NULL)\r\nreturn;\r\nBUG_ON(!in_irq());\r\nBUG_ON(!irqs_disabled());\r\nlist = this_cpu_xchg(irq_work_list, NULL);\r\nwhile (list != NULL) {\r\nstruct irq_work *entry = list;\r\nlist = irq_work_next(list);\r\nentry->next = next_flags(NULL, IRQ_WORK_BUSY);\r\nentry->func(entry);\r\n(void)cmpxchg(&entry->next,\r\nnext_flags(NULL, IRQ_WORK_BUSY),\r\nNULL);\r\n}\r\n}\r\nvoid irq_work_sync(struct irq_work *entry)\r\n{\r\nWARN_ON_ONCE(irqs_disabled());\r\nwhile (irq_work_is_set(entry, IRQ_WORK_BUSY))\r\ncpu_relax();\r\n}
