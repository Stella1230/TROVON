static int __devinit esp_sbus_setup_dma(struct esp *esp,\r\nstruct platform_device *dma_of)\r\n{\r\nesp->dma = dma_of;\r\nesp->dma_regs = of_ioremap(&dma_of->resource[0], 0,\r\nresource_size(&dma_of->resource[0]),\r\n"espdma");\r\nif (!esp->dma_regs)\r\nreturn -ENOMEM;\r\nswitch (dma_read32(DMA_CSR) & DMA_DEVICE_ID) {\r\ncase DMA_VERS0:\r\nesp->dmarev = dvmarev0;\r\nbreak;\r\ncase DMA_ESCV1:\r\nesp->dmarev = dvmaesc1;\r\nbreak;\r\ncase DMA_VERS1:\r\nesp->dmarev = dvmarev1;\r\nbreak;\r\ncase DMA_VERS2:\r\nesp->dmarev = dvmarev2;\r\nbreak;\r\ncase DMA_VERHME:\r\nesp->dmarev = dvmahme;\r\nbreak;\r\ncase DMA_VERSPLUS:\r\nesp->dmarev = dvmarevplus;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit esp_sbus_map_regs(struct esp *esp, int hme)\r\n{\r\nstruct platform_device *op = esp->dev;\r\nstruct resource *res;\r\nif (hme)\r\nres = &op->resource[1];\r\nelse\r\nres = &op->resource[0];\r\nesp->regs = of_ioremap(res, 0, SBUS_ESP_REG_SIZE, "ESP");\r\nif (!esp->regs)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int __devinit esp_sbus_map_command_block(struct esp *esp)\r\n{\r\nstruct platform_device *op = esp->dev;\r\nesp->command_block = dma_alloc_coherent(&op->dev, 16,\r\n&esp->command_block_dma,\r\nGFP_ATOMIC);\r\nif (!esp->command_block)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int __devinit esp_sbus_register_irq(struct esp *esp)\r\n{\r\nstruct Scsi_Host *host = esp->host;\r\nstruct platform_device *op = esp->dev;\r\nhost->irq = op->archdata.irqs[0];\r\nreturn request_irq(host->irq, scsi_esp_intr, IRQF_SHARED, "ESP", esp);\r\n}\r\nstatic void __devinit esp_get_scsi_id(struct esp *esp, struct platform_device *espdma)\r\n{\r\nstruct platform_device *op = esp->dev;\r\nstruct device_node *dp;\r\ndp = op->dev.of_node;\r\nesp->scsi_id = of_getintprop_default(dp, "initiator-id", 0xff);\r\nif (esp->scsi_id != 0xff)\r\ngoto done;\r\nesp->scsi_id = of_getintprop_default(dp, "scsi-initiator-id", 0xff);\r\nif (esp->scsi_id != 0xff)\r\ngoto done;\r\nesp->scsi_id = of_getintprop_default(espdma->dev.of_node,\r\n"scsi-initiator-id", 7);\r\ndone:\r\nesp->host->this_id = esp->scsi_id;\r\nesp->scsi_id_mask = (1 << esp->scsi_id);\r\n}\r\nstatic void __devinit esp_get_differential(struct esp *esp)\r\n{\r\nstruct platform_device *op = esp->dev;\r\nstruct device_node *dp;\r\ndp = op->dev.of_node;\r\nif (of_find_property(dp, "differential", NULL))\r\nesp->flags |= ESP_FLAG_DIFFERENTIAL;\r\nelse\r\nesp->flags &= ~ESP_FLAG_DIFFERENTIAL;\r\n}\r\nstatic void __devinit esp_get_clock_params(struct esp *esp)\r\n{\r\nstruct platform_device *op = esp->dev;\r\nstruct device_node *bus_dp, *dp;\r\nint fmhz;\r\ndp = op->dev.of_node;\r\nbus_dp = dp->parent;\r\nfmhz = of_getintprop_default(dp, "clock-frequency", 0);\r\nif (fmhz == 0)\r\nfmhz = of_getintprop_default(bus_dp, "clock-frequency", 0);\r\nesp->cfreq = fmhz;\r\n}\r\nstatic void __devinit esp_get_bursts(struct esp *esp, struct platform_device *dma_of)\r\n{\r\nstruct device_node *dma_dp = dma_of->dev.of_node;\r\nstruct platform_device *op = esp->dev;\r\nstruct device_node *dp;\r\nu8 bursts, val;\r\ndp = op->dev.of_node;\r\nbursts = of_getintprop_default(dp, "burst-sizes", 0xff);\r\nval = of_getintprop_default(dma_dp, "burst-sizes", 0xff);\r\nif (val != 0xff)\r\nbursts &= val;\r\nval = of_getintprop_default(dma_dp->parent, "burst-sizes", 0xff);\r\nif (val != 0xff)\r\nbursts &= val;\r\nif (bursts == 0xff ||\r\n(bursts & DMA_BURST16) == 0 ||\r\n(bursts & DMA_BURST32) == 0)\r\nbursts = (DMA_BURST32 - 1);\r\nesp->bursts = bursts;\r\n}\r\nstatic void __devinit esp_sbus_get_props(struct esp *esp, struct platform_device *espdma)\r\n{\r\nesp_get_scsi_id(esp, espdma);\r\nesp_get_differential(esp);\r\nesp_get_clock_params(esp);\r\nesp_get_bursts(esp, espdma);\r\n}\r\nstatic void sbus_esp_write8(struct esp *esp, u8 val, unsigned long reg)\r\n{\r\nsbus_writeb(val, esp->regs + (reg * 4UL));\r\n}\r\nstatic u8 sbus_esp_read8(struct esp *esp, unsigned long reg)\r\n{\r\nreturn sbus_readb(esp->regs + (reg * 4UL));\r\n}\r\nstatic dma_addr_t sbus_esp_map_single(struct esp *esp, void *buf,\r\nsize_t sz, int dir)\r\n{\r\nstruct platform_device *op = esp->dev;\r\nreturn dma_map_single(&op->dev, buf, sz, dir);\r\n}\r\nstatic int sbus_esp_map_sg(struct esp *esp, struct scatterlist *sg,\r\nint num_sg, int dir)\r\n{\r\nstruct platform_device *op = esp->dev;\r\nreturn dma_map_sg(&op->dev, sg, num_sg, dir);\r\n}\r\nstatic void sbus_esp_unmap_single(struct esp *esp, dma_addr_t addr,\r\nsize_t sz, int dir)\r\n{\r\nstruct platform_device *op = esp->dev;\r\ndma_unmap_single(&op->dev, addr, sz, dir);\r\n}\r\nstatic void sbus_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,\r\nint num_sg, int dir)\r\n{\r\nstruct platform_device *op = esp->dev;\r\ndma_unmap_sg(&op->dev, sg, num_sg, dir);\r\n}\r\nstatic int sbus_esp_irq_pending(struct esp *esp)\r\n{\r\nif (dma_read32(DMA_CSR) & (DMA_HNDL_INTR | DMA_HNDL_ERROR))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void sbus_esp_reset_dma(struct esp *esp)\r\n{\r\nint can_do_burst16, can_do_burst32, can_do_burst64;\r\nint can_do_sbus64, lim;\r\nstruct platform_device *op;\r\nu32 val;\r\ncan_do_burst16 = (esp->bursts & DMA_BURST16) != 0;\r\ncan_do_burst32 = (esp->bursts & DMA_BURST32) != 0;\r\ncan_do_burst64 = 0;\r\ncan_do_sbus64 = 0;\r\nop = esp->dev;\r\nif (sbus_can_dma_64bit())\r\ncan_do_sbus64 = 1;\r\nif (sbus_can_burst64())\r\ncan_do_burst64 = (esp->bursts & DMA_BURST64) != 0;\r\nif (esp->dmarev != dvmahme) {\r\nval = dma_read32(DMA_CSR);\r\ndma_write32(val | DMA_RST_SCSI, DMA_CSR);\r\ndma_write32(val & ~DMA_RST_SCSI, DMA_CSR);\r\n}\r\nswitch (esp->dmarev) {\r\ncase dvmahme:\r\ndma_write32(DMA_RESET_FAS366, DMA_CSR);\r\ndma_write32(DMA_RST_SCSI, DMA_CSR);\r\nesp->prev_hme_dmacsr = (DMA_PARITY_OFF | DMA_2CLKS |\r\nDMA_SCSI_DISAB | DMA_INT_ENAB);\r\nesp->prev_hme_dmacsr &= ~(DMA_ENABLE | DMA_ST_WRITE |\r\nDMA_BRST_SZ);\r\nif (can_do_burst64)\r\nesp->prev_hme_dmacsr |= DMA_BRST64;\r\nelse if (can_do_burst32)\r\nesp->prev_hme_dmacsr |= DMA_BRST32;\r\nif (can_do_sbus64) {\r\nesp->prev_hme_dmacsr |= DMA_SCSI_SBUS64;\r\nsbus_set_sbus64(&op->dev, esp->bursts);\r\n}\r\nlim = 1000;\r\nwhile (dma_read32(DMA_CSR) & DMA_PEND_READ) {\r\nif (--lim == 0) {\r\nprintk(KERN_ALERT PFX "esp%d: DMA_PEND_READ "\r\n"will not clear!\n",\r\nesp->host->unique_id);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\ndma_write32(0, DMA_CSR);\r\ndma_write32(esp->prev_hme_dmacsr, DMA_CSR);\r\ndma_write32(0, DMA_ADDR);\r\nbreak;\r\ncase dvmarev2:\r\nif (esp->rev != ESP100) {\r\nval = dma_read32(DMA_CSR);\r\ndma_write32(val | DMA_3CLKS, DMA_CSR);\r\n}\r\nbreak;\r\ncase dvmarev3:\r\nval = dma_read32(DMA_CSR);\r\nval &= ~DMA_3CLKS;\r\nval |= DMA_2CLKS;\r\nif (can_do_burst32) {\r\nval &= ~DMA_BRST_SZ;\r\nval |= DMA_BRST32;\r\n}\r\ndma_write32(val, DMA_CSR);\r\nbreak;\r\ncase dvmaesc1:\r\nval = dma_read32(DMA_CSR);\r\nval |= DMA_ADD_ENABLE;\r\nval &= ~DMA_BCNT_ENAB;\r\nif (!can_do_burst32 && can_do_burst16) {\r\nval |= DMA_ESC_BURST;\r\n} else {\r\nval &= ~(DMA_ESC_BURST);\r\n}\r\ndma_write32(val, DMA_CSR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nval = dma_read32(DMA_CSR);\r\ndma_write32(val | DMA_INT_ENAB, DMA_CSR);\r\n}\r\nstatic void sbus_esp_dma_drain(struct esp *esp)\r\n{\r\nu32 csr;\r\nint lim;\r\nif (esp->dmarev == dvmahme)\r\nreturn;\r\ncsr = dma_read32(DMA_CSR);\r\nif (!(csr & DMA_FIFO_ISDRAIN))\r\nreturn;\r\nif (esp->dmarev != dvmarev3 && esp->dmarev != dvmaesc1)\r\ndma_write32(csr | DMA_FIFO_STDRAIN, DMA_CSR);\r\nlim = 1000;\r\nwhile (dma_read32(DMA_CSR) & DMA_FIFO_ISDRAIN) {\r\nif (--lim == 0) {\r\nprintk(KERN_ALERT PFX "esp%d: DMA will not drain!\n",\r\nesp->host->unique_id);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\nstatic void sbus_esp_dma_invalidate(struct esp *esp)\r\n{\r\nif (esp->dmarev == dvmahme) {\r\ndma_write32(DMA_RST_SCSI, DMA_CSR);\r\nesp->prev_hme_dmacsr = ((esp->prev_hme_dmacsr |\r\n(DMA_PARITY_OFF | DMA_2CLKS |\r\nDMA_SCSI_DISAB | DMA_INT_ENAB)) &\r\n~(DMA_ST_WRITE | DMA_ENABLE));\r\ndma_write32(0, DMA_CSR);\r\ndma_write32(esp->prev_hme_dmacsr, DMA_CSR);\r\ndma_write32(0, DMA_ADDR);\r\n} else {\r\nu32 val;\r\nint lim;\r\nlim = 1000;\r\nwhile ((val = dma_read32(DMA_CSR)) & DMA_PEND_READ) {\r\nif (--lim == 0) {\r\nprintk(KERN_ALERT PFX "esp%d: DMA will not "\r\n"invalidate!\n", esp->host->unique_id);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nval &= ~(DMA_ENABLE | DMA_ST_WRITE | DMA_BCNT_ENAB);\r\nval |= DMA_FIFO_INV;\r\ndma_write32(val, DMA_CSR);\r\nval &= ~DMA_FIFO_INV;\r\ndma_write32(val, DMA_CSR);\r\n}\r\n}\r\nstatic void sbus_esp_send_dma_cmd(struct esp *esp, u32 addr, u32 esp_count,\r\nu32 dma_count, int write, u8 cmd)\r\n{\r\nu32 csr;\r\nBUG_ON(!(cmd & ESP_CMD_DMA));\r\nsbus_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\r\nsbus_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\r\nif (esp->rev == FASHME) {\r\nsbus_esp_write8(esp, (esp_count >> 16) & 0xff, FAS_RLO);\r\nsbus_esp_write8(esp, 0, FAS_RHI);\r\nscsi_esp_cmd(esp, cmd);\r\ncsr = esp->prev_hme_dmacsr;\r\ncsr |= DMA_SCSI_DISAB | DMA_ENABLE;\r\nif (write)\r\ncsr |= DMA_ST_WRITE;\r\nelse\r\ncsr &= ~DMA_ST_WRITE;\r\nesp->prev_hme_dmacsr = csr;\r\ndma_write32(dma_count, DMA_COUNT);\r\ndma_write32(addr, DMA_ADDR);\r\ndma_write32(csr, DMA_CSR);\r\n} else {\r\ncsr = dma_read32(DMA_CSR);\r\ncsr |= DMA_ENABLE;\r\nif (write)\r\ncsr |= DMA_ST_WRITE;\r\nelse\r\ncsr &= ~DMA_ST_WRITE;\r\ndma_write32(csr, DMA_CSR);\r\nif (esp->dmarev == dvmaesc1) {\r\nu32 end = PAGE_ALIGN(addr + dma_count + 16U);\r\ndma_write32(end - addr, DMA_COUNT);\r\n}\r\ndma_write32(addr, DMA_ADDR);\r\nscsi_esp_cmd(esp, cmd);\r\n}\r\n}\r\nstatic int sbus_esp_dma_error(struct esp *esp)\r\n{\r\nu32 csr = dma_read32(DMA_CSR);\r\nif (csr & DMA_HNDL_ERROR)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __devinit esp_sbus_probe_one(struct platform_device *op,\r\nstruct platform_device *espdma,\r\nint hme)\r\n{\r\nstruct scsi_host_template *tpnt = &scsi_esp_template;\r\nstruct Scsi_Host *host;\r\nstruct esp *esp;\r\nint err;\r\nhost = scsi_host_alloc(tpnt, sizeof(struct esp));\r\nerr = -ENOMEM;\r\nif (!host)\r\ngoto fail;\r\nhost->max_id = (hme ? 16 : 8);\r\nesp = shost_priv(host);\r\nesp->host = host;\r\nesp->dev = op;\r\nesp->ops = &sbus_esp_ops;\r\nif (hme)\r\nesp->flags |= ESP_FLAG_WIDE_CAPABLE;\r\nerr = esp_sbus_setup_dma(esp, espdma);\r\nif (err < 0)\r\ngoto fail_unlink;\r\nerr = esp_sbus_map_regs(esp, hme);\r\nif (err < 0)\r\ngoto fail_unlink;\r\nerr = esp_sbus_map_command_block(esp);\r\nif (err < 0)\r\ngoto fail_unmap_regs;\r\nerr = esp_sbus_register_irq(esp);\r\nif (err < 0)\r\ngoto fail_unmap_command_block;\r\nesp_sbus_get_props(esp, espdma);\r\nif (esp->dmarev == dvmaesc1) {\r\nu32 val = dma_read32(DMA_CSR);\r\ndma_write32(val & ~DMA_RST_SCSI, DMA_CSR);\r\n}\r\ndev_set_drvdata(&op->dev, esp);\r\nerr = scsi_esp_register(esp, &op->dev);\r\nif (err)\r\ngoto fail_free_irq;\r\nreturn 0;\r\nfail_free_irq:\r\nfree_irq(host->irq, esp);\r\nfail_unmap_command_block:\r\ndma_free_coherent(&op->dev, 16,\r\nesp->command_block,\r\nesp->command_block_dma);\r\nfail_unmap_regs:\r\nof_iounmap(&op->resource[(hme ? 1 : 0)], esp->regs, SBUS_ESP_REG_SIZE);\r\nfail_unlink:\r\nscsi_host_put(host);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int __devinit esp_sbus_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dma_node = NULL;\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct platform_device *dma_of = NULL;\r\nint hme = 0;\r\nif (dp->parent &&\r\n(!strcmp(dp->parent->name, "espdma") ||\r\n!strcmp(dp->parent->name, "dma")))\r\ndma_node = dp->parent;\r\nelse if (!strcmp(dp->name, "SUNW,fas")) {\r\ndma_node = op->dev.of_node;\r\nhme = 1;\r\n}\r\nif (dma_node)\r\ndma_of = of_find_device_by_node(dma_node);\r\nif (!dma_of)\r\nreturn -ENODEV;\r\nreturn esp_sbus_probe_one(op, dma_of, hme);\r\n}\r\nstatic int __devexit esp_sbus_remove(struct platform_device *op)\r\n{\r\nstruct esp *esp = dev_get_drvdata(&op->dev);\r\nstruct platform_device *dma_of = esp->dma;\r\nunsigned int irq = esp->host->irq;\r\nbool is_hme;\r\nu32 val;\r\nscsi_esp_unregister(esp);\r\nval = dma_read32(DMA_CSR);\r\ndma_write32(val & ~DMA_INT_ENAB, DMA_CSR);\r\nfree_irq(irq, esp);\r\nis_hme = (esp->dmarev == dvmahme);\r\ndma_free_coherent(&op->dev, 16,\r\nesp->command_block,\r\nesp->command_block_dma);\r\nof_iounmap(&op->resource[(is_hme ? 1 : 0)], esp->regs,\r\nSBUS_ESP_REG_SIZE);\r\nof_iounmap(&dma_of->resource[0], esp->dma_regs,\r\nresource_size(&dma_of->resource[0]));\r\nscsi_host_put(esp->host);\r\ndev_set_drvdata(&op->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init sunesp_init(void)\r\n{\r\nreturn platform_driver_register(&esp_sbus_driver);\r\n}\r\nstatic void __exit sunesp_exit(void)\r\n{\r\nplatform_driver_unregister(&esp_sbus_driver);\r\n}
