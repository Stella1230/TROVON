static bool udplite_pkt_to_tuple(const struct sk_buff *skb,\r\nunsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct udphdr *hp;\r\nstruct udphdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->src.u.udp.port = hp->source;\r\ntuple->dst.u.udp.port = hp->dest;\r\nreturn true;\r\n}\r\nstatic bool udplite_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u.udp.port = orig->dst.u.udp.port;\r\ntuple->dst.u.udp.port = orig->src.u.udp.port;\r\nreturn true;\r\n}\r\nstatic int udplite_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "sport=%hu dport=%hu ",\r\nntohs(tuple->src.u.udp.port),\r\nntohs(tuple->dst.u.udp.port));\r\n}\r\nstatic int udplite_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nif (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\r\nnf_ct_refresh_acct(ct, ctinfo, skb,\r\nnf_ct_udplite_timeout_stream);\r\nif (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))\r\nnf_conntrack_event_cache(IPCT_ASSURED, ct);\r\n} else\r\nnf_ct_refresh_acct(ct, ctinfo, skb, nf_ct_udplite_timeout);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool udplite_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff)\r\n{\r\nreturn true;\r\n}\r\nstatic int udplite_error(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info *ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nunsigned int udplen = skb->len - dataoff;\r\nconst struct udphdr *hdr;\r\nstruct udphdr _hdr;\r\nunsigned int cscov;\r\nhdr = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\r\nif (hdr == NULL) {\r\nif (LOG_INVALID(net, IPPROTO_UDPLITE))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_udplite: short packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\ncscov = ntohs(hdr->len);\r\nif (cscov == 0)\r\ncscov = udplen;\r\nelse if (cscov < sizeof(*hdr) || cscov > udplen) {\r\nif (LOG_INVALID(net, IPPROTO_UDPLITE))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_udplite: invalid checksum coverage ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (!hdr->check) {\r\nif (LOG_INVALID(net, IPPROTO_UDPLITE))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_udplite: checksum missing ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\r\nnf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_UDP,\r\npf)) {\r\nif (LOG_INVALID(net, IPPROTO_UDPLITE))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_udplite: bad UDPLite checksum ");\r\nreturn -NF_ACCEPT;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int __init nf_conntrack_proto_udplite_init(void)\r\n{\r\nint err;\r\nerr = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_udplite4);\r\nif (err < 0)\r\ngoto err1;\r\nerr = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_udplite6);\r\nif (err < 0)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_udplite4);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit nf_conntrack_proto_udplite_exit(void)\r\n{\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_udplite6);\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_udplite4);\r\n}
