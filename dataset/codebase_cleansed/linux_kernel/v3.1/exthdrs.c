int ipv6_find_tlv(struct sk_buff *skb, int offset, int type)\r\n{\r\nconst unsigned char *nh = skb_network_header(skb);\r\nint packet_len = skb->tail - skb->network_header;\r\nstruct ipv6_opt_hdr *hdr;\r\nint len;\r\nif (offset + 2 > packet_len)\r\ngoto bad;\r\nhdr = (struct ipv6_opt_hdr *)(nh + offset);\r\nlen = ((hdr->hdrlen + 1) << 3);\r\nif (offset + len > packet_len)\r\ngoto bad;\r\noffset += 2;\r\nlen -= 2;\r\nwhile (len > 0) {\r\nint opttype = nh[offset];\r\nint optlen;\r\nif (opttype == type)\r\nreturn offset;\r\nswitch (opttype) {\r\ncase IPV6_TLV_PAD0:\r\noptlen = 1;\r\nbreak;\r\ndefault:\r\noptlen = nh[offset + 1] + 2;\r\nif (optlen > len)\r\ngoto bad;\r\nbreak;\r\n}\r\noffset += optlen;\r\nlen -= optlen;\r\n}\r\nbad:\r\nreturn -1;\r\n}\r\nstatic int ip6_tlvopt_unknown(struct sk_buff *skb, int optoff)\r\n{\r\nswitch ((skb_network_header(skb)[optoff] & 0xC0) >> 6) {\r\ncase 0:\r\nreturn 1;\r\ncase 1:\r\nbreak;\r\ncase 3:\r\nif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr))\r\nbreak;\r\ncase 2:\r\nicmpv6_param_prob(skb, ICMPV6_UNK_OPTION, optoff);\r\nreturn 0;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ip6_parse_tlv(struct tlvtype_proc *procs, struct sk_buff *skb)\r\n{\r\nstruct tlvtype_proc *curr;\r\nconst unsigned char *nh = skb_network_header(skb);\r\nint off = skb_network_header_len(skb);\r\nint len = (skb_transport_header(skb)[1] + 1) << 3;\r\nif (skb_transport_offset(skb) + len > skb_headlen(skb))\r\ngoto bad;\r\noff += 2;\r\nlen -= 2;\r\nwhile (len > 0) {\r\nint optlen = nh[off + 1] + 2;\r\nswitch (nh[off]) {\r\ncase IPV6_TLV_PAD0:\r\noptlen = 1;\r\nbreak;\r\ncase IPV6_TLV_PADN:\r\nbreak;\r\ndefault:\r\nif (optlen > len)\r\ngoto bad;\r\nfor (curr=procs; curr->type >= 0; curr++) {\r\nif (curr->type == nh[off]) {\r\nif (curr->func(skb, off) == 0)\r\nreturn 0;\r\nbreak;\r\n}\r\n}\r\nif (curr->type < 0) {\r\nif (ip6_tlvopt_unknown(skb, off) == 0)\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\noff += optlen;\r\nlen -= optlen;\r\n}\r\nif (len == 0)\r\nreturn 1;\r\nbad:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ipv6_dest_hao(struct sk_buff *skb, int optoff)\r\n{\r\nstruct ipv6_destopt_hao *hao;\r\nstruct inet6_skb_parm *opt = IP6CB(skb);\r\nstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\nstruct in6_addr tmp_addr;\r\nint ret;\r\nif (opt->dsthao) {\r\nLIMIT_NETDEBUG(KERN_DEBUG "hao duplicated\n");\r\ngoto discard;\r\n}\r\nopt->dsthao = opt->dst1;\r\nopt->dst1 = 0;\r\nhao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);\r\nif (hao->length != 16) {\r\nLIMIT_NETDEBUG(\r\nKERN_DEBUG "hao invalid option length = %d\n", hao->length);\r\ngoto discard;\r\n}\r\nif (!(ipv6_addr_type(&hao->addr) & IPV6_ADDR_UNICAST)) {\r\nLIMIT_NETDEBUG(\r\nKERN_DEBUG "hao is not an unicast addr: %pI6\n", &hao->addr);\r\ngoto discard;\r\n}\r\nret = xfrm6_input_addr(skb, (xfrm_address_t *)&ipv6h->daddr,\r\n(xfrm_address_t *)&hao->addr, IPPROTO_DSTOPTS);\r\nif (unlikely(ret < 0))\r\ngoto discard;\r\nif (skb_cloned(skb)) {\r\nif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC))\r\ngoto discard;\r\nhao = (struct ipv6_destopt_hao *)(skb_network_header(skb) +\r\noptoff);\r\nipv6h = ipv6_hdr(skb);\r\n}\r\nif (skb->ip_summed == CHECKSUM_COMPLETE)\r\nskb->ip_summed = CHECKSUM_NONE;\r\nipv6_addr_copy(&tmp_addr, &ipv6h->saddr);\r\nipv6_addr_copy(&ipv6h->saddr, &hao->addr);\r\nipv6_addr_copy(&hao->addr, &tmp_addr);\r\nif (skb->tstamp.tv64 == 0)\r\n__net_timestamp(skb);\r\nreturn 1;\r\ndiscard:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ipv6_destopt_rcv(struct sk_buff *skb)\r\n{\r\nstruct inet6_skb_parm *opt = IP6CB(skb);\r\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\r\n__u16 dstbuf;\r\n#endif\r\nstruct dst_entry *dst;\r\nif (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) ||\r\n!pskb_may_pull(skb, (skb_transport_offset(skb) +\r\n((skb_transport_header(skb)[1] + 1) << 3)))) {\r\nIP6_INC_STATS_BH(dev_net(skb_dst(skb)->dev), ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nopt->lastopt = opt->dst1 = skb_network_header_len(skb);\r\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\r\ndstbuf = opt->dst1;\r\n#endif\r\ndst = dst_clone(skb_dst(skb));\r\nif (ip6_parse_tlv(tlvprocdestopt_lst, skb)) {\r\ndst_release(dst);\r\nskb->transport_header += (skb_transport_header(skb)[1] + 1) << 3;\r\nopt = IP6CB(skb);\r\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\r\nopt->nhoff = dstbuf;\r\n#else\r\nopt->nhoff = opt->dst1;\r\n#endif\r\nreturn 1;\r\n}\r\nIP6_INC_STATS_BH(dev_net(dst->dev),\r\nip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);\r\ndst_release(dst);\r\nreturn -1;\r\n}\r\nstatic int ipv6_rthdr_rcv(struct sk_buff *skb)\r\n{\r\nstruct inet6_skb_parm *opt = IP6CB(skb);\r\nstruct in6_addr *addr = NULL;\r\nstruct in6_addr daddr;\r\nstruct inet6_dev *idev;\r\nint n, i;\r\nstruct ipv6_rt_hdr *hdr;\r\nstruct rt0_hdr *rthdr;\r\nstruct net *net = dev_net(skb->dev);\r\nint accept_source_route = net->ipv6.devconf_all->accept_source_route;\r\nidev = __in6_dev_get(skb->dev);\r\nif (idev && accept_source_route > idev->cnf.accept_source_route)\r\naccept_source_route = idev->cnf.accept_source_route;\r\nif (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) ||\r\n!pskb_may_pull(skb, (skb_transport_offset(skb) +\r\n((skb_transport_header(skb)[1] + 1) << 3)))) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nhdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);\r\nif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) ||\r\nskb->pkt_type != PACKET_HOST) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INADDRERRORS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nlooped_back:\r\nif (hdr->segments_left == 0) {\r\nswitch (hdr->type) {\r\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\r\ncase IPV6_SRCRT_TYPE_2:\r\nif (!addr) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INADDRERRORS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nopt->lastopt = opt->srcrt = skb_network_header_len(skb);\r\nskb->transport_header += (hdr->hdrlen + 1) << 3;\r\nopt->dst0 = opt->dst1;\r\nopt->dst1 = 0;\r\nopt->nhoff = (&hdr->nexthdr) - skb_network_header(skb);\r\nreturn 1;\r\n}\r\nswitch (hdr->type) {\r\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\r\ncase IPV6_SRCRT_TYPE_2:\r\nif (accept_source_route < 0)\r\ngoto unknown_rh;\r\nif (hdr->hdrlen != 2 || hdr->segments_left != 1) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto unknown_rh;\r\n}\r\nn = hdr->hdrlen >> 1;\r\nif (hdr->segments_left > n) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\r\n((&hdr->segments_left) -\r\nskb_network_header(skb)));\r\nreturn -1;\r\n}\r\nif (skb_cloned(skb)) {\r\nif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_OUTDISCARDS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nhdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);\r\n}\r\nif (skb->ip_summed == CHECKSUM_COMPLETE)\r\nskb->ip_summed = CHECKSUM_NONE;\r\ni = n - --hdr->segments_left;\r\nrthdr = (struct rt0_hdr *) hdr;\r\naddr = rthdr->addr;\r\naddr += i - 1;\r\nswitch (hdr->type) {\r\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\r\ncase IPV6_SRCRT_TYPE_2:\r\nif (xfrm6_input_addr(skb, (xfrm_address_t *)addr,\r\n(xfrm_address_t *)&ipv6_hdr(skb)->saddr,\r\nIPPROTO_ROUTING) < 0) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INADDRERRORS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nif (!ipv6_chk_home_addr(dev_net(skb_dst(skb)->dev), addr)) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INADDRERRORS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nif (ipv6_addr_is_multicast(addr)) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INADDRERRORS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nipv6_addr_copy(&daddr, addr);\r\nipv6_addr_copy(addr, &ipv6_hdr(skb)->daddr);\r\nipv6_addr_copy(&ipv6_hdr(skb)->daddr, &daddr);\r\nskb_dst_drop(skb);\r\nip6_route_input(skb);\r\nif (skb_dst(skb)->error) {\r\nskb_push(skb, skb->data - skb_network_header(skb));\r\ndst_input(skb);\r\nreturn -1;\r\n}\r\nif (skb_dst(skb)->dev->flags&IFF_LOOPBACK) {\r\nif (ipv6_hdr(skb)->hop_limit <= 1) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT,\r\n0);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nipv6_hdr(skb)->hop_limit--;\r\ngoto looped_back;\r\n}\r\nskb_push(skb, skb->data - skb_network_header(skb));\r\ndst_input(skb);\r\nreturn -1;\r\nunknown_rh:\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\r\n(&hdr->type) - skb_network_header(skb));\r\nreturn -1;\r\n}\r\nint __init ipv6_exthdrs_init(void)\r\n{\r\nint ret;\r\nret = inet6_add_protocol(&rthdr_protocol, IPPROTO_ROUTING);\r\nif (ret)\r\ngoto out;\r\nret = inet6_add_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\r\nif (ret)\r\ngoto out_rthdr;\r\nret = inet6_add_protocol(&nodata_protocol, IPPROTO_NONE);\r\nif (ret)\r\ngoto out_destopt;\r\nout:\r\nreturn ret;\r\nout_rthdr:\r\ninet6_del_protocol(&rthdr_protocol, IPPROTO_ROUTING);\r\nout_destopt:\r\ninet6_del_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\r\ngoto out;\r\n}\r\nvoid ipv6_exthdrs_exit(void)\r\n{\r\ninet6_del_protocol(&nodata_protocol, IPPROTO_NONE);\r\ninet6_del_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\r\ninet6_del_protocol(&rthdr_protocol, IPPROTO_ROUTING);\r\n}\r\nstatic inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)\r\n{\r\nreturn skb_dst(skb) ? ip6_dst_idev(skb_dst(skb)) : __in6_dev_get(skb->dev);\r\n}\r\nstatic inline struct net *ipv6_skb_net(struct sk_buff *skb)\r\n{\r\nreturn skb_dst(skb) ? dev_net(skb_dst(skb)->dev) : dev_net(skb->dev);\r\n}\r\nstatic int ipv6_hop_ra(struct sk_buff *skb, int optoff)\r\n{\r\nconst unsigned char *nh = skb_network_header(skb);\r\nif (nh[optoff + 1] == 2) {\r\nIP6CB(skb)->ra = optoff;\r\nreturn 1;\r\n}\r\nLIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_ra: wrong RA length %d\n",\r\nnh[optoff + 1]);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ipv6_hop_jumbo(struct sk_buff *skb, int optoff)\r\n{\r\nconst unsigned char *nh = skb_network_header(skb);\r\nstruct net *net = ipv6_skb_net(skb);\r\nu32 pkt_len;\r\nif (nh[optoff + 1] != 4 || (optoff & 3) != 2) {\r\nLIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\n",\r\nnh[optoff+1]);\r\nIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\r\nIPSTATS_MIB_INHDRERRORS);\r\ngoto drop;\r\n}\r\npkt_len = ntohl(*(__be32 *)(nh + optoff + 2));\r\nif (pkt_len <= IPV6_MAXPLEN) {\r\nIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff+2);\r\nreturn 0;\r\n}\r\nif (ipv6_hdr(skb)->payload_len) {\r\nIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff);\r\nreturn 0;\r\n}\r\nif (pkt_len > skb->len - sizeof(struct ipv6hdr)) {\r\nIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\r\nIPSTATS_MIB_INTRUNCATEDPKTS);\r\ngoto drop;\r\n}\r\nif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\r\ngoto drop;\r\nreturn 1;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint ipv6_parse_hopopts(struct sk_buff *skb)\r\n{\r\nstruct inet6_skb_parm *opt = IP6CB(skb);\r\nif (!pskb_may_pull(skb, sizeof(struct ipv6hdr) + 8) ||\r\n!pskb_may_pull(skb, (sizeof(struct ipv6hdr) +\r\n((skb_transport_header(skb)[1] + 1) << 3)))) {\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nopt->hop = sizeof(struct ipv6hdr);\r\nif (ip6_parse_tlv(tlvprochopopt_lst, skb)) {\r\nskb->transport_header += (skb_transport_header(skb)[1] + 1) << 3;\r\nopt = IP6CB(skb);\r\nopt->nhoff = sizeof(struct ipv6hdr);\r\nreturn 1;\r\n}\r\nreturn -1;\r\n}\r\nstatic void ipv6_push_rthdr(struct sk_buff *skb, u8 *proto,\r\nstruct ipv6_rt_hdr *opt,\r\nstruct in6_addr **addr_p)\r\n{\r\nstruct rt0_hdr *phdr, *ihdr;\r\nint hops;\r\nihdr = (struct rt0_hdr *) opt;\r\nphdr = (struct rt0_hdr *) skb_push(skb, (ihdr->rt_hdr.hdrlen + 1) << 3);\r\nmemcpy(phdr, ihdr, sizeof(struct rt0_hdr));\r\nhops = ihdr->rt_hdr.hdrlen >> 1;\r\nif (hops > 1)\r\nmemcpy(phdr->addr, ihdr->addr + 1,\r\n(hops - 1) * sizeof(struct in6_addr));\r\nipv6_addr_copy(phdr->addr + (hops - 1), *addr_p);\r\n*addr_p = ihdr->addr;\r\nphdr->rt_hdr.nexthdr = *proto;\r\n*proto = NEXTHDR_ROUTING;\r\n}\r\nstatic void ipv6_push_exthdr(struct sk_buff *skb, u8 *proto, u8 type, struct ipv6_opt_hdr *opt)\r\n{\r\nstruct ipv6_opt_hdr *h = (struct ipv6_opt_hdr *)skb_push(skb, ipv6_optlen(opt));\r\nmemcpy(h, opt, ipv6_optlen(opt));\r\nh->nexthdr = *proto;\r\n*proto = type;\r\n}\r\nvoid ipv6_push_nfrag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\r\nu8 *proto,\r\nstruct in6_addr **daddr)\r\n{\r\nif (opt->srcrt) {\r\nipv6_push_rthdr(skb, proto, opt->srcrt, daddr);\r\nif (opt->dst0opt)\r\nipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst0opt);\r\n}\r\nif (opt->hopopt)\r\nipv6_push_exthdr(skb, proto, NEXTHDR_HOP, opt->hopopt);\r\n}\r\nvoid ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt, u8 *proto)\r\n{\r\nif (opt->dst1opt)\r\nipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst1opt);\r\n}\r\nstruct ipv6_txoptions *\r\nipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\r\n{\r\nstruct ipv6_txoptions *opt2;\r\nopt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\r\nif (opt2) {\r\nlong dif = (char*)opt2 - (char*)opt;\r\nmemcpy(opt2, opt, opt->tot_len);\r\nif (opt2->hopopt)\r\n*((char**)&opt2->hopopt) += dif;\r\nif (opt2->dst0opt)\r\n*((char**)&opt2->dst0opt) += dif;\r\nif (opt2->dst1opt)\r\n*((char**)&opt2->dst1opt) += dif;\r\nif (opt2->srcrt)\r\n*((char**)&opt2->srcrt) += dif;\r\n}\r\nreturn opt2;\r\n}\r\nstatic int ipv6_renew_option(void *ohdr,\r\nstruct ipv6_opt_hdr __user *newopt, int newoptlen,\r\nint inherit,\r\nstruct ipv6_opt_hdr **hdr,\r\nchar **p)\r\n{\r\nif (inherit) {\r\nif (ohdr) {\r\nmemcpy(*p, ohdr, ipv6_optlen((struct ipv6_opt_hdr *)ohdr));\r\n*hdr = (struct ipv6_opt_hdr *)*p;\r\n*p += CMSG_ALIGN(ipv6_optlen(*(struct ipv6_opt_hdr **)hdr));\r\n}\r\n} else {\r\nif (newopt) {\r\nif (copy_from_user(*p, newopt, newoptlen))\r\nreturn -EFAULT;\r\n*hdr = (struct ipv6_opt_hdr *)*p;\r\nif (ipv6_optlen(*(struct ipv6_opt_hdr **)hdr) > newoptlen)\r\nreturn -EINVAL;\r\n*p += CMSG_ALIGN(newoptlen);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstruct ipv6_txoptions *\r\nipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,\r\nint newtype,\r\nstruct ipv6_opt_hdr __user *newopt, int newoptlen)\r\n{\r\nint tot_len = 0;\r\nchar *p;\r\nstruct ipv6_txoptions *opt2;\r\nint err;\r\nif (opt) {\r\nif (newtype != IPV6_HOPOPTS && opt->hopopt)\r\ntot_len += CMSG_ALIGN(ipv6_optlen(opt->hopopt));\r\nif (newtype != IPV6_RTHDRDSTOPTS && opt->dst0opt)\r\ntot_len += CMSG_ALIGN(ipv6_optlen(opt->dst0opt));\r\nif (newtype != IPV6_RTHDR && opt->srcrt)\r\ntot_len += CMSG_ALIGN(ipv6_optlen(opt->srcrt));\r\nif (newtype != IPV6_DSTOPTS && opt->dst1opt)\r\ntot_len += CMSG_ALIGN(ipv6_optlen(opt->dst1opt));\r\n}\r\nif (newopt && newoptlen)\r\ntot_len += CMSG_ALIGN(newoptlen);\r\nif (!tot_len)\r\nreturn NULL;\r\ntot_len += sizeof(*opt2);\r\nopt2 = sock_kmalloc(sk, tot_len, GFP_ATOMIC);\r\nif (!opt2)\r\nreturn ERR_PTR(-ENOBUFS);\r\nmemset(opt2, 0, tot_len);\r\nopt2->tot_len = tot_len;\r\np = (char *)(opt2 + 1);\r\nerr = ipv6_renew_option(opt ? opt->hopopt : NULL, newopt, newoptlen,\r\nnewtype != IPV6_HOPOPTS,\r\n&opt2->hopopt, &p);\r\nif (err)\r\ngoto out;\r\nerr = ipv6_renew_option(opt ? opt->dst0opt : NULL, newopt, newoptlen,\r\nnewtype != IPV6_RTHDRDSTOPTS,\r\n&opt2->dst0opt, &p);\r\nif (err)\r\ngoto out;\r\nerr = ipv6_renew_option(opt ? opt->srcrt : NULL, newopt, newoptlen,\r\nnewtype != IPV6_RTHDR,\r\n(struct ipv6_opt_hdr **)&opt2->srcrt, &p);\r\nif (err)\r\ngoto out;\r\nerr = ipv6_renew_option(opt ? opt->dst1opt : NULL, newopt, newoptlen,\r\nnewtype != IPV6_DSTOPTS,\r\n&opt2->dst1opt, &p);\r\nif (err)\r\ngoto out;\r\nopt2->opt_nflen = (opt2->hopopt ? ipv6_optlen(opt2->hopopt) : 0) +\r\n(opt2->dst0opt ? ipv6_optlen(opt2->dst0opt) : 0) +\r\n(opt2->srcrt ? ipv6_optlen(opt2->srcrt) : 0);\r\nopt2->opt_flen = (opt2->dst1opt ? ipv6_optlen(opt2->dst1opt) : 0);\r\nreturn opt2;\r\nout:\r\nsock_kfree_s(sk, opt2, opt2->tot_len);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct ipv6_txoptions *ipv6_fixup_options(struct ipv6_txoptions *opt_space,\r\nstruct ipv6_txoptions *opt)\r\n{\r\nif (opt && opt->dst0opt && !opt->srcrt) {\r\nif (opt_space != opt) {\r\nmemcpy(opt_space, opt, sizeof(*opt_space));\r\nopt = opt_space;\r\n}\r\nopt->opt_nflen -= ipv6_optlen(opt->dst0opt);\r\nopt->dst0opt = NULL;\r\n}\r\nreturn opt;\r\n}\r\nstruct in6_addr *fl6_update_dst(struct flowi6 *fl6,\r\nconst struct ipv6_txoptions *opt,\r\nstruct in6_addr *orig)\r\n{\r\nif (!opt || !opt->srcrt)\r\nreturn NULL;\r\nipv6_addr_copy(orig, &fl6->daddr);\r\nipv6_addr_copy(&fl6->daddr, ((struct rt0_hdr *)opt->srcrt)->addr);\r\nreturn orig;\r\n}
