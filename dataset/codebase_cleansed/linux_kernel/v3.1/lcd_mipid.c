static void mipid_transfer(struct mipid_device *md, int cmd, const u8 *wbuf,\r\nint wlen, u8 *rbuf, int rlen)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer *x, xfer[4];\r\nu16 w;\r\nint r;\r\nBUG_ON(md->spi == NULL);\r\nspi_message_init(&m);\r\nmemset(xfer, 0, sizeof(xfer));\r\nx = &xfer[0];\r\ncmd &= 0xff;\r\nx->tx_buf = &cmd;\r\nx->bits_per_word = 9;\r\nx->len = 2;\r\nspi_message_add_tail(x, &m);\r\nif (wlen) {\r\nx++;\r\nx->tx_buf = wbuf;\r\nx->len = wlen;\r\nx->bits_per_word = 9;\r\nspi_message_add_tail(x, &m);\r\n}\r\nif (rlen) {\r\nx++;\r\nx->rx_buf = &w;\r\nx->len = 1;\r\nspi_message_add_tail(x, &m);\r\nif (rlen > 1) {\r\nx->bits_per_word = 9;\r\nx->len = 2;\r\nx++;\r\nx->rx_buf = &rbuf[1];\r\nx->len = rlen - 1;\r\nspi_message_add_tail(x, &m);\r\n}\r\n}\r\nr = spi_sync(md->spi, &m);\r\nif (r < 0)\r\ndev_dbg(&md->spi->dev, "spi_sync %d\n", r);\r\nif (rlen)\r\nrbuf[0] = w & 0xff;\r\n}\r\nstatic inline void mipid_cmd(struct mipid_device *md, int cmd)\r\n{\r\nmipid_transfer(md, cmd, NULL, 0, NULL, 0);\r\n}\r\nstatic inline void mipid_write(struct mipid_device *md,\r\nint reg, const u8 *buf, int len)\r\n{\r\nmipid_transfer(md, reg, buf, len, NULL, 0);\r\n}\r\nstatic inline void mipid_read(struct mipid_device *md,\r\nint reg, u8 *buf, int len)\r\n{\r\nmipid_transfer(md, reg, NULL, 0, buf, len);\r\n}\r\nstatic void set_data_lines(struct mipid_device *md, int data_lines)\r\n{\r\nu16 par;\r\nswitch (data_lines) {\r\ncase 16:\r\npar = 0x150;\r\nbreak;\r\ncase 18:\r\npar = 0x160;\r\nbreak;\r\ncase 24:\r\npar = 0x170;\r\nbreak;\r\n}\r\nmipid_write(md, 0x3a, (u8 *)&par, 2);\r\n}\r\nstatic void send_init_string(struct mipid_device *md)\r\n{\r\nu16 initpar[] = { 0x0102, 0x0100, 0x0100 };\r\nmipid_write(md, 0xc2, (u8 *)initpar, sizeof(initpar));\r\nset_data_lines(md, md->panel.data_lines);\r\n}\r\nstatic void hw_guard_start(struct mipid_device *md, int guard_msec)\r\n{\r\nmd->hw_guard_wait = msecs_to_jiffies(guard_msec);\r\nmd->hw_guard_end = jiffies + md->hw_guard_wait;\r\n}\r\nstatic void hw_guard_wait(struct mipid_device *md)\r\n{\r\nunsigned long wait = md->hw_guard_end - jiffies;\r\nif ((long)wait > 0 && wait <= md->hw_guard_wait) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(wait);\r\n}\r\n}\r\nstatic void set_sleep_mode(struct mipid_device *md, int on)\r\n{\r\nint cmd, sleep_time = 50;\r\nif (on)\r\ncmd = MIPID_CMD_SLEEP_IN;\r\nelse\r\ncmd = MIPID_CMD_SLEEP_OUT;\r\nhw_guard_wait(md);\r\nmipid_cmd(md, cmd);\r\nhw_guard_start(md, 120);\r\nif (!on)\r\nsleep_time = 120;\r\nmsleep(sleep_time);\r\n}\r\nstatic void set_display_state(struct mipid_device *md, int enabled)\r\n{\r\nint cmd = enabled ? MIPID_CMD_DISP_ON : MIPID_CMD_DISP_OFF;\r\nmipid_cmd(md, cmd);\r\n}\r\nstatic int mipid_set_bklight_level(struct lcd_panel *panel, unsigned int level)\r\n{\r\nstruct mipid_device *md = to_mipid_device(panel);\r\nstruct mipid_platform_data *pd = md->spi->dev.platform_data;\r\nif (pd->get_bklight_max == NULL || pd->set_bklight_level == NULL)\r\nreturn -ENODEV;\r\nif (level > pd->get_bklight_max(pd))\r\nreturn -EINVAL;\r\nif (!md->enabled) {\r\nmd->saved_bklight_level = level;\r\nreturn 0;\r\n}\r\npd->set_bklight_level(pd, level);\r\nreturn 0;\r\n}\r\nstatic unsigned int mipid_get_bklight_level(struct lcd_panel *panel)\r\n{\r\nstruct mipid_device *md = to_mipid_device(panel);\r\nstruct mipid_platform_data *pd = md->spi->dev.platform_data;\r\nif (pd->get_bklight_level == NULL)\r\nreturn -ENODEV;\r\nreturn pd->get_bklight_level(pd);\r\n}\r\nstatic unsigned int mipid_get_bklight_max(struct lcd_panel *panel)\r\n{\r\nstruct mipid_device *md = to_mipid_device(panel);\r\nstruct mipid_platform_data *pd = md->spi->dev.platform_data;\r\nif (pd->get_bklight_max == NULL)\r\nreturn -ENODEV;\r\nreturn pd->get_bklight_max(pd);\r\n}\r\nstatic unsigned long mipid_get_caps(struct lcd_panel *panel)\r\n{\r\nreturn OMAPFB_CAPS_SET_BACKLIGHT;\r\n}\r\nstatic u16 read_first_pixel(struct mipid_device *md)\r\n{\r\nu16 pixel;\r\nu8 red, green, blue;\r\nmutex_lock(&md->mutex);\r\nmipid_read(md, MIPID_CMD_READ_RED, &red, 1);\r\nmipid_read(md, MIPID_CMD_READ_GREEN, &green, 1);\r\nmipid_read(md, MIPID_CMD_READ_BLUE, &blue, 1);\r\nmutex_unlock(&md->mutex);\r\nswitch (md->panel.data_lines) {\r\ncase 16:\r\npixel = ((red >> 1) << 11) | (green << 5) | (blue >> 1);\r\nbreak;\r\ncase 24:\r\npixel = ((red >> 3) << 11) | ((green >> 2) << 5) |\r\n(blue >> 3);\r\nbreak;\r\ndefault:\r\npixel = 0;\r\nBUG();\r\n}\r\nreturn pixel;\r\n}\r\nstatic int mipid_run_test(struct lcd_panel *panel, int test_num)\r\n{\r\nstruct mipid_device *md = to_mipid_device(panel);\r\nstatic const u16 test_values[4] = {\r\n0x0000, 0xffff, 0xaaaa, 0x5555,\r\n};\r\nint i;\r\nif (test_num != MIPID_TEST_RGB_LINES)\r\nreturn MIPID_TEST_INVALID;\r\nfor (i = 0; i < ARRAY_SIZE(test_values); i++) {\r\nint delay;\r\nunsigned long tmo;\r\nomapfb_write_first_pixel(md->fbdev, test_values[i]);\r\ntmo = jiffies + msecs_to_jiffies(100);\r\ndelay = 25;\r\nwhile (1) {\r\nu16 pixel;\r\nmsleep(delay);\r\npixel = read_first_pixel(md);\r\nif (pixel == test_values[i])\r\nbreak;\r\nif (time_after(jiffies, tmo)) {\r\ndev_err(&md->spi->dev,\r\n"MIPI LCD RGB I/F test failed: "\r\n"expecting %04x, got %04x\n",\r\ntest_values[i], pixel);\r\nreturn MIPID_TEST_FAILED;\r\n}\r\ndelay = 10;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ls041y3_esd_recover(struct mipid_device *md)\r\n{\r\ndev_err(&md->spi->dev, "performing LCD ESD recovery\n");\r\nset_sleep_mode(md, 1);\r\nset_sleep_mode(md, 0);\r\n}\r\nstatic void ls041y3_esd_check_mode1(struct mipid_device *md)\r\n{\r\nu8 state1, state2;\r\nmipid_read(md, MIPID_CMD_RDDSDR, &state1, 1);\r\nset_sleep_mode(md, 0);\r\nmipid_read(md, MIPID_CMD_RDDSDR, &state2, 1);\r\ndev_dbg(&md->spi->dev, "ESD mode 1 state1 %02x state2 %02x\n",\r\nstate1, state2);\r\nif (!((state1 ^ state2) & (1 << 6)))\r\nls041y3_esd_recover(md);\r\n}\r\nstatic void ls041y3_esd_check_mode2(struct mipid_device *md)\r\n{\r\nint i;\r\nu8 rbuf[2];\r\nstatic const struct {\r\nint cmd;\r\nint wlen;\r\nu16 wbuf[3];\r\n} *rd, rd_ctrl[7] = {\r\n{ 0xb0, 4, { 0x0101, 0x01fe, } },\r\n{ 0xb1, 4, { 0x01de, 0x0121, } },\r\n{ 0xc2, 4, { 0x0100, 0x0100, } },\r\n{ 0xbd, 2, { 0x0100, } },\r\n{ 0xc2, 4, { 0x01fc, 0x0103, } },\r\n{ 0xb4, 0, },\r\n{ 0x00, 0, },\r\n};\r\nrd = rd_ctrl;\r\nfor (i = 0; i < 3; i++, rd++)\r\nmipid_write(md, rd->cmd, (u8 *)rd->wbuf, rd->wlen);\r\nudelay(10);\r\nmipid_read(md, rd->cmd, rbuf, 2);\r\nrd++;\r\nfor (i = 0; i < 3; i++, rd++) {\r\nudelay(10);\r\nmipid_write(md, rd->cmd, (u8 *)rd->wbuf, rd->wlen);\r\n}\r\ndev_dbg(&md->spi->dev, "ESD mode 2 state %02x\n", rbuf[1]);\r\nif (rbuf[1] == 0x00)\r\nls041y3_esd_recover(md);\r\n}\r\nstatic void ls041y3_esd_check(struct mipid_device *md)\r\n{\r\nls041y3_esd_check_mode1(md);\r\nif (md->revision >= 0x88)\r\nls041y3_esd_check_mode2(md);\r\n}\r\nstatic void mipid_esd_start_check(struct mipid_device *md)\r\n{\r\nif (md->esd_check != NULL)\r\nqueue_delayed_work(md->esd_wq, &md->esd_work,\r\nMIPID_ESD_CHECK_PERIOD);\r\n}\r\nstatic void mipid_esd_stop_check(struct mipid_device *md)\r\n{\r\nif (md->esd_check != NULL)\r\ncancel_delayed_work_sync(&md->esd_work);\r\n}\r\nstatic void mipid_esd_work(struct work_struct *work)\r\n{\r\nstruct mipid_device *md = container_of(work, struct mipid_device,\r\nesd_work.work);\r\nmutex_lock(&md->mutex);\r\nmd->esd_check(md);\r\nmutex_unlock(&md->mutex);\r\nmipid_esd_start_check(md);\r\n}\r\nstatic int mipid_enable(struct lcd_panel *panel)\r\n{\r\nstruct mipid_device *md = to_mipid_device(panel);\r\nmutex_lock(&md->mutex);\r\nif (md->enabled) {\r\nmutex_unlock(&md->mutex);\r\nreturn 0;\r\n}\r\nset_sleep_mode(md, 0);\r\nmd->enabled = 1;\r\nsend_init_string(md);\r\nset_display_state(md, 1);\r\nmipid_set_bklight_level(panel, md->saved_bklight_level);\r\nmipid_esd_start_check(md);\r\nmutex_unlock(&md->mutex);\r\nreturn 0;\r\n}\r\nstatic void mipid_disable(struct lcd_panel *panel)\r\n{\r\nstruct mipid_device *md = to_mipid_device(panel);\r\nmipid_esd_stop_check(md);\r\nmutex_lock(&md->mutex);\r\nif (!md->enabled) {\r\nmutex_unlock(&md->mutex);\r\nreturn;\r\n}\r\nmd->saved_bklight_level = mipid_get_bklight_level(panel);\r\nmipid_set_bklight_level(panel, 0);\r\nset_display_state(md, 0);\r\nset_sleep_mode(md, 1);\r\nmd->enabled = 0;\r\nmutex_unlock(&md->mutex);\r\n}\r\nstatic int panel_enabled(struct mipid_device *md)\r\n{\r\nu32 disp_status;\r\nint enabled;\r\nmipid_read(md, MIPID_CMD_READ_DISP_STATUS, (u8 *)&disp_status, 4);\r\ndisp_status = __be32_to_cpu(disp_status);\r\nenabled = (disp_status & (1 << 17)) && (disp_status & (1 << 10));\r\ndev_dbg(&md->spi->dev,\r\n"LCD panel %senabled by bootloader (status 0x%04x)\n",\r\nenabled ? "" : "not ", disp_status);\r\nreturn enabled;\r\n}\r\nstatic int mipid_init(struct lcd_panel *panel,\r\nstruct omapfb_device *fbdev)\r\n{\r\nstruct mipid_device *md = to_mipid_device(panel);\r\nmd->fbdev = fbdev;\r\nmd->esd_wq = create_singlethread_workqueue("mipid_esd");\r\nif (md->esd_wq == NULL) {\r\ndev_err(&md->spi->dev, "can't create ESD workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_DELAYED_WORK(&md->esd_work, mipid_esd_work);\r\nmutex_init(&md->mutex);\r\nmd->enabled = panel_enabled(md);\r\nif (md->enabled)\r\nmipid_esd_start_check(md);\r\nelse\r\nmd->saved_bklight_level = mipid_get_bklight_level(panel);\r\nreturn 0;\r\n}\r\nstatic void mipid_cleanup(struct lcd_panel *panel)\r\n{\r\nstruct mipid_device *md = to_mipid_device(panel);\r\nif (md->enabled)\r\nmipid_esd_stop_check(md);\r\ndestroy_workqueue(md->esd_wq);\r\n}\r\nstatic int mipid_detect(struct mipid_device *md)\r\n{\r\nstruct mipid_platform_data *pdata;\r\nu8 display_id[3];\r\npdata = md->spi->dev.platform_data;\r\nif (pdata == NULL) {\r\ndev_err(&md->spi->dev, "missing platform data\n");\r\nreturn -ENOENT;\r\n}\r\nmipid_read(md, MIPID_CMD_READ_DISP_ID, display_id, 3);\r\ndev_dbg(&md->spi->dev, "MIPI display ID: %02x%02x%02x\n",\r\ndisplay_id[0], display_id[1], display_id[2]);\r\nswitch (display_id[0]) {\r\ncase 0x45:\r\nmd->panel.name = "lph8923";\r\nbreak;\r\ncase 0x83:\r\nmd->panel.name = "ls041y3";\r\nmd->esd_check = ls041y3_esd_check;\r\nbreak;\r\ndefault:\r\nmd->panel.name = "unknown";\r\ndev_err(&md->spi->dev, "invalid display ID\n");\r\nreturn -ENODEV;\r\n}\r\nmd->revision = display_id[1];\r\nmd->panel.data_lines = pdata->data_lines;\r\npr_info("omapfb: %s rev %02x LCD detected, %d data lines\n",\r\nmd->panel.name, md->revision, md->panel.data_lines);\r\nreturn 0;\r\n}\r\nstatic int mipid_spi_probe(struct spi_device *spi)\r\n{\r\nstruct mipid_device *md;\r\nint r;\r\nmd = kzalloc(sizeof(*md), GFP_KERNEL);\r\nif (md == NULL) {\r\ndev_err(&spi->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nspi->mode = SPI_MODE_0;\r\nmd->spi = spi;\r\ndev_set_drvdata(&spi->dev, md);\r\nmd->panel = mipid_panel;\r\nr = mipid_detect(md);\r\nif (r < 0)\r\nreturn r;\r\nomapfb_register_panel(&md->panel);\r\nreturn 0;\r\n}\r\nstatic int mipid_spi_remove(struct spi_device *spi)\r\n{\r\nstruct mipid_device *md = dev_get_drvdata(&spi->dev);\r\nmipid_disable(&md->panel);\r\nkfree(md);\r\nreturn 0;\r\n}\r\nstatic int __init mipid_drv_init(void)\r\n{\r\nspi_register_driver(&mipid_spi_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit mipid_drv_cleanup(void)\r\n{\r\nspi_unregister_driver(&mipid_spi_driver);\r\n}
