int xtLookup(struct inode *ip, s64 lstart,\r\ns64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\r\n{\r\nint rc = 0;\r\nstruct btstack btstack;\r\nint cmp;\r\ns64 bn;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\nint index;\r\nxad_t *xad;\r\ns64 next, size, xoff, xend;\r\nint xlen;\r\ns64 xaddr;\r\n*paddr = 0;\r\n*plen = llen;\r\nif (!no_check) {\r\nsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\r\nJFS_SBI(ip->i_sb)->l2bsize;\r\nif (lstart >= size)\r\nreturn 0;\r\n}\r\nif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\r\njfs_err("xtLookup: xtSearch returned %d", rc);\r\nreturn rc;\r\n}\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif (cmp) {\r\nif (next)\r\n*plen = min(next - lstart, llen);\r\ngoto out;\r\n}\r\nxad = &p->xad[index];\r\nxoff = offsetXAD(xad);\r\nxlen = lengthXAD(xad);\r\nxend = xoff + xlen;\r\nxaddr = addressXAD(xad);\r\n*pflag = xad->flag;\r\n*paddr = xaddr + (lstart - xoff);\r\n*plen = min(xend - lstart, llen);\r\nout:\r\nXT_PUTPAGE(mp);\r\nreturn rc;\r\n}\r\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *nextp,\r\nint *cmpp, struct btstack * btstack, int flag)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nint rc = 0;\r\nint cmp = 1;\r\ns64 bn;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\nxad_t *xad;\r\nint base, index, lim, btindex;\r\nstruct btframe *btsp;\r\nint nsplit = 0;\r\ns64 t64;\r\ns64 next = 0;\r\nINCREMENT(xtStat.search);\r\nBT_CLR(btstack);\r\nbtstack->nsplit = 0;\r\nfor (bn = 0;;) {\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif ((jfs_ip->btorder & BT_SEQUENTIAL) &&\r\n(p->header.flag & BT_LEAF) &&\r\n(index = jfs_ip->btindex) <\r\nle16_to_cpu(p->header.nextindex)) {\r\nxad = &p->xad[index];\r\nt64 = offsetXAD(xad);\r\nif (xoff < t64 + lengthXAD(xad)) {\r\nif (xoff >= t64) {\r\n*cmpp = 0;\r\ngoto out;\r\n}\r\ngoto binarySearch;\r\n} else {\r\nindex++;\r\nif (index <\r\nle16_to_cpu(p->header.nextindex)) {\r\nxad++;\r\nt64 = offsetXAD(xad);\r\nif (xoff < t64 + lengthXAD(xad)) {\r\nif (xoff >= t64) {\r\n*cmpp = 0;\r\ngoto out;\r\n}\r\n*cmpp = 1;\r\nnext = t64;\r\ngoto out;\r\n}\r\ngoto binarySearch;\r\n}\r\n*cmpp = 1;\r\ngoto out;\r\n}\r\nout:\r\nif (flag & XT_INSERT) {\r\nif (p->header.nextindex ==\r\np->header.maxentry)\r\nnsplit++;\r\nelse\r\nnsplit = 0;\r\nbtstack->nsplit = nsplit;\r\n}\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = index;\r\nbtsp->mp = mp;\r\njfs_ip->btindex = index;\r\nif (nextp)\r\n*nextp = next;\r\nINCREMENT(xtStat.fastSearch);\r\nreturn 0;\r\n}\r\nbinarySearch:\r\nlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\r\nfor (base = XTENTRYSTART; lim; lim >>= 1) {\r\nindex = base + (lim >> 1);\r\nXT_CMP(cmp, xoff, &p->xad[index], t64);\r\nif (cmp == 0) {\r\nif (p->header.flag & BT_LEAF) {\r\n*cmpp = cmp;\r\nif (flag & XT_INSERT) {\r\nif (p->header.nextindex ==\r\np->header.maxentry)\r\nnsplit++;\r\nelse\r\nnsplit = 0;\r\nbtstack->nsplit = nsplit;\r\n}\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = index;\r\nbtsp->mp = mp;\r\nbtindex = jfs_ip->btindex;\r\nif (index == btindex ||\r\nindex == btindex + 1)\r\njfs_ip->btorder = BT_SEQUENTIAL;\r\nelse\r\njfs_ip->btorder = BT_RANDOM;\r\njfs_ip->btindex = index;\r\nreturn 0;\r\n}\r\nif (index < le16_to_cpu(p->header.nextindex)-1)\r\nnext = offsetXAD(&p->xad[index + 1]);\r\ngoto next;\r\n}\r\nif (cmp > 0) {\r\nbase = index + 1;\r\n--lim;\r\n}\r\n}\r\nif (base < le16_to_cpu(p->header.nextindex))\r\nnext = offsetXAD(&p->xad[base]);\r\nif (p->header.flag & BT_LEAF) {\r\n*cmpp = cmp;\r\nif (flag & XT_INSERT) {\r\nif (p->header.nextindex ==\r\np->header.maxentry)\r\nnsplit++;\r\nelse\r\nnsplit = 0;\r\nbtstack->nsplit = nsplit;\r\n}\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = base;\r\nbtsp->mp = mp;\r\nbtindex = jfs_ip->btindex;\r\nif (base == btindex || base == btindex + 1)\r\njfs_ip->btorder = BT_SEQUENTIAL;\r\nelse\r\njfs_ip->btorder = BT_RANDOM;\r\njfs_ip->btindex = base;\r\nif (nextp)\r\n*nextp = next;\r\nreturn 0;\r\n}\r\nindex = base ? base - 1 : base;\r\nnext:\r\nif (p->header.nextindex == p->header.maxentry)\r\nnsplit++;\r\nelse\r\nnsplit = 0;\r\nif (BT_STACK_FULL(btstack)) {\r\njfs_error(ip->i_sb, "stack overrun in xtSearch!");\r\nXT_PUTPAGE(mp);\r\nreturn -EIO;\r\n}\r\nBT_PUSH(btstack, bn, index);\r\nbn = addressXAD(&p->xad[index]);\r\nXT_PUTPAGE(mp);\r\n}\r\n}\r\nint xtInsert(tid_t tid,\r\nstruct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\r\nint flag)\r\n{\r\nint rc = 0;\r\ns64 xaddr, hint;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\ns64 bn;\r\nint index, nextindex;\r\nstruct btstack btstack;\r\nstruct xtsplit split;\r\nxad_t *xad;\r\nint cmp;\r\ns64 next;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck;\r\njfs_info("xtInsert: nxoff:0x%lx nxlen:0x%x", (ulong) xoff, xlen);\r\nif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif ((cmp == 0) || (next && (xlen > next - xoff))) {\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\nif ((xaddr = *xaddrp) == 0) {\r\nif (index > XTENTRYSTART) {\r\nxad = &p->xad[index - 1];\r\nhint = addressXAD(xad) + lengthXAD(xad) - 1;\r\n} else\r\nhint = 0;\r\nif ((rc = dquot_alloc_block(ip, xlen)))\r\ngoto out;\r\nif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\r\ndquot_free_block(ip, xlen);\r\ngoto out;\r\n}\r\n}\r\nxflag |= XAD_NEW;\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\nif (nextindex == le16_to_cpu(p->header.maxentry)) {\r\nsplit.mp = mp;\r\nsplit.index = index;\r\nsplit.flag = xflag;\r\nsplit.off = xoff;\r\nsplit.len = xlen;\r\nsplit.addr = xaddr;\r\nsplit.pxdlist = NULL;\r\nif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\r\nif (*xaddrp == 0) {\r\ndbFree(ip, xaddr, (s64) xlen);\r\ndquot_free_block(ip, xlen);\r\n}\r\nreturn rc;\r\n}\r\n*xaddrp = xaddr;\r\nreturn 0;\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\nif (index < nextindex)\r\nmemmove(&p->xad[index + 1], &p->xad[index],\r\n(nextindex - index) * sizeof(xad_t));\r\nxad = &p->xad[index];\r\nXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\r\nle16_add_cpu(&p->header.nextindex, 1);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->lwm.offset =\r\n(xtlck->lwm.offset) ? min(index,\r\n(int)xtlck->lwm.offset) : index;\r\nxtlck->lwm.length =\r\nle16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\r\n}\r\n*xaddrp = xaddr;\r\nout:\r\nXT_PUTPAGE(mp);\r\nreturn rc;\r\n}\r\nstatic int\r\nxtSplitUp(tid_t tid,\r\nstruct inode *ip, struct xtsplit * split, struct btstack * btstack)\r\n{\r\nint rc = 0;\r\nstruct metapage *smp;\r\nxtpage_t *sp;\r\nstruct metapage *rmp;\r\ns64 rbn;\r\nstruct metapage *rcmp;\r\nxtpage_t *rcp;\r\ns64 rcbn;\r\nint skip;\r\nint nextindex;\r\nstruct btframe *parent;\r\nxad_t *xad;\r\ns64 xaddr;\r\nint xlen;\r\nint nsplit;\r\nstruct pxdlist pxdlist;\r\npxd_t *pxd;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck;\r\nsmp = split->mp;\r\nsp = XT_PAGE(ip, smp);\r\nif ((sp->header.flag & BT_ROOT) && (!S_ISDIR(ip->i_mode)) &&\r\n(le16_to_cpu(sp->header.maxentry) < XTROOTMAXSLOT) &&\r\n(JFS_IP(ip)->mode2 & INLINEEA)) {\r\nsp->header.maxentry = cpu_to_le16(XTROOTMAXSLOT);\r\nJFS_IP(ip)->mode2 &= ~INLINEEA;\r\nBT_MARK_DIRTY(smp, ip);\r\nskip = split->index;\r\nnextindex = le16_to_cpu(sp->header.nextindex);\r\nif (skip < nextindex)\r\nmemmove(&sp->xad[skip + 1], &sp->xad[skip],\r\n(nextindex - skip) * sizeof(xad_t));\r\nxad = &sp->xad[skip];\r\nXT_PUTENTRY(xad, split->flag, split->off, split->len,\r\nsplit->addr);\r\nle16_add_cpu(&sp->header.nextindex, 1);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->lwm.offset = (xtlck->lwm.offset) ?\r\nmin(skip, (int)xtlck->lwm.offset) : skip;\r\nxtlck->lwm.length =\r\nle16_to_cpu(sp->header.nextindex) -\r\nxtlck->lwm.offset;\r\n}\r\nreturn 0;\r\n}\r\nif (split->pxdlist == NULL) {\r\nnsplit = btstack->nsplit;\r\nsplit->pxdlist = &pxdlist;\r\npxdlist.maxnpxd = pxdlist.npxd = 0;\r\npxd = &pxdlist.pxd[0];\r\nxlen = JFS_SBI(ip->i_sb)->nbperpage;\r\nfor (; nsplit > 0; nsplit--, pxd++) {\r\nif ((rc = dbAlloc(ip, (s64) 0, (s64) xlen, &xaddr))\r\n== 0) {\r\nPXDaddress(pxd, xaddr);\r\nPXDlength(pxd, xlen);\r\npxdlist.maxnpxd++;\r\ncontinue;\r\n}\r\nXT_PUTPAGE(smp);\r\nreturn rc;\r\n}\r\n}\r\nrc = (sp->header.flag & BT_ROOT) ?\r\nxtSplitRoot(tid, ip, split, &rmp) :\r\nxtSplitPage(tid, ip, split, &rmp, &rbn);\r\nXT_PUTPAGE(smp);\r\nif (rc)\r\nreturn -EIO;\r\nwhile ((parent = BT_POP(btstack)) != NULL) {\r\nrcmp = rmp;\r\nrcbn = rbn;\r\nrcp = XT_PAGE(ip, rcmp);\r\nXT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\r\nif (rc) {\r\nXT_PUTPAGE(rcmp);\r\nreturn rc;\r\n}\r\nskip = parent->index + 1;\r\nnextindex = le16_to_cpu(sp->header.nextindex);\r\nif (nextindex == le16_to_cpu(sp->header.maxentry)) {\r\nsplit->mp = smp;\r\nsplit->index = skip;\r\nsplit->flag = XAD_NEW;\r\nsplit->off = offsetXAD(&rcp->xad[XTENTRYSTART]);\r\nsplit->len = JFS_SBI(ip->i_sb)->nbperpage;\r\nsplit->addr = rcbn;\r\nXT_PUTPAGE(rcmp);\r\nrc = (sp->header.flag & BT_ROOT) ?\r\nxtSplitRoot(tid, ip, split, &rmp) :\r\nxtSplitPage(tid, ip, split, &rmp, &rbn);\r\nif (rc) {\r\nXT_PUTPAGE(smp);\r\nreturn rc;\r\n}\r\nXT_PUTPAGE(smp);\r\n}\r\nelse {\r\nBT_MARK_DIRTY(smp, ip);\r\nif (skip < nextindex)\r\nmemmove(&sp->xad[skip + 1], &sp->xad[skip],\r\n(nextindex -\r\nskip) << L2XTSLOTSIZE);\r\nxad = &sp->xad[skip];\r\nXT_PUTENTRY(xad, XAD_NEW,\r\noffsetXAD(&rcp->xad[XTENTRYSTART]),\r\nJFS_SBI(ip->i_sb)->nbperpage, rcbn);\r\nle16_add_cpu(&sp->header.nextindex, 1);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, smp,\r\ntlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->lwm.offset = (xtlck->lwm.offset) ?\r\nmin(skip, (int)xtlck->lwm.offset) : skip;\r\nxtlck->lwm.length =\r\nle16_to_cpu(sp->header.nextindex) -\r\nxtlck->lwm.offset;\r\n}\r\nXT_PUTPAGE(smp);\r\nbreak;\r\n}\r\n}\r\nXT_PUTPAGE(rmp);\r\nreturn 0;\r\n}\r\nstatic int\r\nxtSplitPage(tid_t tid, struct inode *ip,\r\nstruct xtsplit * split, struct metapage ** rmpp, s64 * rbnp)\r\n{\r\nint rc = 0;\r\nstruct metapage *smp;\r\nxtpage_t *sp;\r\nstruct metapage *rmp;\r\nxtpage_t *rp;\r\ns64 rbn;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\ns64 nextbn;\r\nint skip, maxentry, middle, righthalf, n;\r\nxad_t *xad;\r\nstruct pxdlist *pxdlist;\r\npxd_t *pxd;\r\nstruct tlock *tlck;\r\nstruct xtlock *sxtlck = NULL, *rxtlck = NULL;\r\nint quota_allocation = 0;\r\nsmp = split->mp;\r\nsp = XT_PAGE(ip, smp);\r\nINCREMENT(xtStat.split);\r\npxdlist = split->pxdlist;\r\npxd = &pxdlist->pxd[pxdlist->npxd];\r\npxdlist->npxd++;\r\nrbn = addressPXD(pxd);\r\nrc = dquot_alloc_block(ip, lengthPXD(pxd));\r\nif (rc)\r\ngoto clean_up;\r\nquota_allocation += lengthPXD(pxd);\r\nrmp = get_metapage(ip, rbn, PSIZE, 1);\r\nif (rmp == NULL) {\r\nrc = -EIO;\r\ngoto clean_up;\r\n}\r\njfs_info("xtSplitPage: ip:0x%p smp:0x%p rmp:0x%p", ip, smp, rmp);\r\nBT_MARK_DIRTY(rmp, ip);\r\nrp = (xtpage_t *) rmp->data;\r\nrp->header.self = *pxd;\r\nrp->header.flag = sp->header.flag & BT_TYPE;\r\nrp->header.maxentry = sp->header.maxentry;\r\nrp->header.nextindex = cpu_to_le16(XTENTRYSTART);\r\nBT_MARK_DIRTY(smp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\r\nrxtlck = (struct xtlock *) & tlck->lock;\r\nrxtlck->lwm.offset = XTENTRYSTART;\r\ntlck = txLock(tid, ip, smp, tlckXTREE | tlckGROW);\r\nsxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\nnextbn = le64_to_cpu(sp->header.next);\r\nrp->header.next = cpu_to_le64(nextbn);\r\nrp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\r\nsp->header.next = cpu_to_le64(rbn);\r\nskip = split->index;\r\nif (nextbn == 0 && skip == le16_to_cpu(sp->header.maxentry)) {\r\nxad = &rp->xad[XTENTRYSTART];\r\nXT_PUTENTRY(xad, split->flag, split->off, split->len,\r\nsplit->addr);\r\nrp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nrxtlck->lwm.length = 1;\r\n}\r\n*rmpp = rmp;\r\n*rbnp = rbn;\r\njfs_info("xtSplitPage: sp:0x%p rp:0x%p", sp, rp);\r\nreturn 0;\r\n}\r\nif (nextbn != 0) {\r\nXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\r\nif (rc) {\r\nXT_PUTPAGE(rmp);\r\ngoto clean_up;\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip))\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\r\np->header.prev = cpu_to_le64(rbn);\r\nXT_PUTPAGE(mp);\r\n}\r\nmaxentry = le16_to_cpu(sp->header.maxentry);\r\nmiddle = maxentry >> 1;\r\nrighthalf = maxentry - middle;\r\nif (skip <= middle) {\r\nmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\r\nrighthalf << L2XTSLOTSIZE);\r\nif (skip < middle)\r\nmemmove(&sp->xad[skip + 1], &sp->xad[skip],\r\n(middle - skip) << L2XTSLOTSIZE);\r\nxad = &sp->xad[skip];\r\nXT_PUTENTRY(xad, split->flag, split->off, split->len,\r\nsplit->addr);\r\nsp->header.nextindex = cpu_to_le16(middle + 1);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\r\nmin(skip, (int)sxtlck->lwm.offset) : skip;\r\n}\r\nrp->header.nextindex =\r\ncpu_to_le16(XTENTRYSTART + righthalf);\r\n}\r\nelse {\r\nn = skip - middle;\r\nmemmove(&rp->xad[XTENTRYSTART], &sp->xad[middle],\r\nn << L2XTSLOTSIZE);\r\nn += XTENTRYSTART;\r\nxad = &rp->xad[n];\r\nXT_PUTENTRY(xad, split->flag, split->off, split->len,\r\nsplit->addr);\r\nif (skip < maxentry)\r\nmemmove(&rp->xad[n + 1], &sp->xad[skip],\r\n(maxentry - skip) << L2XTSLOTSIZE);\r\nsp->header.nextindex = cpu_to_le16(middle);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nsxtlck->lwm.offset = (sxtlck->lwm.offset) ?\r\nmin(middle, (int)sxtlck->lwm.offset) : middle;\r\n}\r\nrp->header.nextindex = cpu_to_le16(XTENTRYSTART +\r\nrighthalf + 1);\r\n}\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nsxtlck->lwm.length = le16_to_cpu(sp->header.nextindex) -\r\nsxtlck->lwm.offset;\r\nrxtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\r\nXTENTRYSTART;\r\n}\r\n*rmpp = rmp;\r\n*rbnp = rbn;\r\njfs_info("xtSplitPage: sp:0x%p rp:0x%p", sp, rp);\r\nreturn rc;\r\nclean_up:\r\nif (quota_allocation)\r\ndquot_free_block(ip, quota_allocation);\r\nreturn (rc);\r\n}\r\nstatic int\r\nxtSplitRoot(tid_t tid,\r\nstruct inode *ip, struct xtsplit * split, struct metapage ** rmpp)\r\n{\r\nxtpage_t *sp;\r\nstruct metapage *rmp;\r\nxtpage_t *rp;\r\ns64 rbn;\r\nint skip, nextindex;\r\nxad_t *xad;\r\npxd_t *pxd;\r\nstruct pxdlist *pxdlist;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck;\r\nint rc;\r\nsp = &JFS_IP(ip)->i_xtroot;\r\nINCREMENT(xtStat.split);\r\npxdlist = split->pxdlist;\r\npxd = &pxdlist->pxd[pxdlist->npxd];\r\npxdlist->npxd++;\r\nrbn = addressPXD(pxd);\r\nrmp = get_metapage(ip, rbn, PSIZE, 1);\r\nif (rmp == NULL)\r\nreturn -EIO;\r\nrc = dquot_alloc_block(ip, lengthPXD(pxd));\r\nif (rc) {\r\nrelease_metapage(rmp);\r\nreturn rc;\r\n}\r\njfs_info("xtSplitRoot: ip:0x%p rmp:0x%p", ip, rmp);\r\nBT_MARK_DIRTY(rmp, ip);\r\nrp = (xtpage_t *) rmp->data;\r\nrp->header.flag =\r\n(sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\r\nrp->header.self = *pxd;\r\nrp->header.nextindex = cpu_to_le16(XTENTRYSTART);\r\nrp->header.maxentry = cpu_to_le16(PSIZE >> L2XTSLOTSIZE);\r\nrp->header.next = 0;\r\nrp->header.prev = 0;\r\nnextindex = le16_to_cpu(sp->header.maxentry);\r\nmemmove(&rp->xad[XTENTRYSTART], &sp->xad[XTENTRYSTART],\r\n(nextindex - XTENTRYSTART) << L2XTSLOTSIZE);\r\nskip = split->index;\r\nif (skip != nextindex)\r\nmemmove(&rp->xad[skip + 1], &rp->xad[skip],\r\n(nextindex - skip) * sizeof(xad_t));\r\nxad = &rp->xad[skip];\r\nXT_PUTENTRY(xad, split->flag, split->off, split->len, split->addr);\r\nrp->header.nextindex = cpu_to_le16(nextindex + 1);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, rmp, tlckXTREE | tlckNEW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->lwm.offset = XTENTRYSTART;\r\nxtlck->lwm.length = le16_to_cpu(rp->header.nextindex) -\r\nXTENTRYSTART;\r\n}\r\nBT_MARK_DIRTY(split->mp, ip);\r\nxad = &sp->xad[XTENTRYSTART];\r\nXT_PUTENTRY(xad, XAD_NEW, 0, JFS_SBI(ip->i_sb)->nbperpage, rbn);\r\nsp->header.flag &= ~BT_LEAF;\r\nsp->header.flag |= BT_INTERNAL;\r\nsp->header.nextindex = cpu_to_le16(XTENTRYSTART + 1);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, split->mp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->lwm.offset = XTENTRYSTART;\r\nxtlck->lwm.length = 1;\r\n}\r\n*rmpp = rmp;\r\njfs_info("xtSplitRoot: sp:0x%p rp:0x%p", sp, rp);\r\nreturn 0;\r\n}\r\nint xtExtend(tid_t tid,\r\nstruct inode *ip, s64 xoff,\r\ns32 xlen,\r\nint flag)\r\n{\r\nint rc = 0;\r\nint cmp;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\ns64 bn;\r\nint index, nextindex, len;\r\nstruct btstack btstack;\r\nstruct xtsplit split;\r\nxad_t *xad;\r\ns64 xaddr;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck = NULL;\r\njfs_info("xtExtend: nxoff:0x%lx nxlen:0x%x", (ulong) xoff, xlen);\r\nif ((rc = xtSearch(ip, xoff - 1, NULL, &cmp, &btstack, XT_INSERT)))\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif (cmp != 0) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb, "xtExtend: xtSearch did not find extent");\r\nreturn -EIO;\r\n}\r\nxad = &p->xad[index];\r\nif ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb, "xtExtend: extension is not contiguous");\r\nreturn -EIO;\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\nxlen = lengthXAD(xad) + xlen;\r\nif ((len = xlen - MAXXLEN) <= 0)\r\ngoto extendOld;\r\nxoff = offsetXAD(xad) + MAXXLEN;\r\nxaddr = addressXAD(xad) + MAXXLEN;\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\nif (nextindex == le16_to_cpu(p->header.maxentry)) {\r\nsplit.mp = mp;\r\nsplit.index = index + 1;\r\nsplit.flag = XAD_NEW;\r\nsplit.off = xoff;\r\nsplit.len = len;\r\nsplit.addr = xaddr;\r\nsplit.pxdlist = NULL;\r\nif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\r\nreturn rc;\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif (p->header.flag & BT_INTERNAL) {\r\nASSERT(p->header.nextindex ==\r\ncpu_to_le16(XTENTRYSTART + 1));\r\nxad = &p->xad[XTENTRYSTART];\r\nbn = addressXAD(xad);\r\nXT_PUTPAGE(mp);\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\n}\r\n}\r\nelse {\r\nxad = &p->xad[index + 1];\r\nXT_PUTENTRY(xad, XAD_NEW, xoff, len, xaddr);\r\nle16_add_cpu(&p->header.nextindex, 1);\r\n}\r\nxad = &p->xad[index];\r\nxlen = MAXXLEN;\r\nextendOld:\r\nXADlength(xad, xlen);\r\nif (!(xad->flag & XAD_NEW))\r\nxad->flag |= XAD_EXTENDED;\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nxtlck->lwm.offset =\r\n(xtlck->lwm.offset) ? min(index,\r\n(int)xtlck->lwm.offset) : index;\r\nxtlck->lwm.length =\r\nle16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\r\n}\r\nXT_PUTPAGE(mp);\r\nreturn rc;\r\n}\r\nint xtTailgate(tid_t tid,\r\nstruct inode *ip, s64 xoff,\r\ns32 xlen,\r\ns64 xaddr,\r\nint flag)\r\n{\r\nint rc = 0;\r\nint cmp;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\ns64 bn;\r\nint index, nextindex, llen, rlen;\r\nstruct btstack btstack;\r\nstruct xtsplit split;\r\nxad_t *xad;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck = 0;\r\nstruct tlock *mtlck;\r\nstruct maplock *pxdlock;\r\nif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, XT_INSERT)))\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif (cmp != 0) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb, "xtTailgate: couldn't find extent");\r\nreturn -EIO;\r\n}\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\nif (index != nextindex - 1) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb,\r\n"xtTailgate: the entry found is not the last entry");\r\nreturn -EIO;\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\nxad = &p->xad[index];\r\nif ((llen = xoff - offsetXAD(xad)) == 0)\r\ngoto updateOld;\r\nif (nextindex == le16_to_cpu(p->header.maxentry)) {\r\nsplit.mp = mp;\r\nsplit.index = index + 1;\r\nsplit.flag = XAD_NEW;\r\nsplit.off = xoff;\r\nsplit.len = xlen;\r\nsplit.addr = xaddr;\r\nsplit.pxdlist = NULL;\r\nif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\r\nreturn rc;\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif (p->header.flag & BT_INTERNAL) {\r\nASSERT(p->header.nextindex ==\r\ncpu_to_le16(XTENTRYSTART + 1));\r\nxad = &p->xad[XTENTRYSTART];\r\nbn = addressXAD(xad);\r\nXT_PUTPAGE(mp);\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\n}\r\n}\r\nelse {\r\nxad = &p->xad[index + 1];\r\nXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\r\nle16_add_cpu(&p->header.nextindex, 1);\r\n}\r\nxad = &p->xad[index];\r\nupdateOld:\r\nrlen = lengthXAD(xad) - llen;\r\nif (!(xad->flag & XAD_NEW)) {\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nmtlck = txMaplock(tid, ip, tlckMAP);\r\npxdlock = (struct maplock *) & mtlck->lock;\r\npxdlock->flag = mlckFREEPXD;\r\nPXDaddress(&pxdlock->pxd, addressXAD(xad) + llen);\r\nPXDlength(&pxdlock->pxd, rlen);\r\npxdlock->index = 1;\r\n}\r\n} else\r\ndbFree(ip, addressXAD(xad) + llen, (s64) rlen);\r\nif (llen)\r\nXADlength(xad, llen);\r\nelse\r\nXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nxtlck->lwm.offset = (xtlck->lwm.offset) ?\r\nmin(index, (int)xtlck->lwm.offset) : index;\r\nxtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\r\nxtlck->lwm.offset;\r\n}\r\nXT_PUTPAGE(mp);\r\nreturn rc;\r\n}\r\nint xtUpdate(tid_t tid, struct inode *ip, xad_t * nxad)\r\n{\r\nint rc = 0;\r\nint cmp;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\ns64 bn;\r\nint index0, index, newindex, nextindex;\r\nstruct btstack btstack;\r\nstruct xtsplit split;\r\nxad_t *xad, *lxad, *rxad;\r\nint xflag;\r\ns64 nxoff, xoff;\r\nint nxlen, xlen, lxlen, rxlen;\r\ns64 nxaddr, xaddr;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck = NULL;\r\nint newpage = 0;\r\nnxoff = offsetXAD(nxad);\r\nnxlen = lengthXAD(nxad);\r\nnxaddr = addressXAD(nxad);\r\nif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\r\nif (cmp != 0) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb, "xtUpdate: Could not find extent");\r\nreturn -EIO;\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\nxad = &p->xad[index0];\r\nxflag = xad->flag;\r\nxoff = offsetXAD(xad);\r\nxlen = lengthXAD(xad);\r\nxaddr = addressXAD(xad);\r\nif ((xoff > nxoff) ||\r\n(nxoff + nxlen > xoff + xlen)) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb,\r\n"xtUpdate: nXAD in not completely contained within XAD");\r\nreturn -EIO;\r\n}\r\nindex = index0;\r\nnewindex = index + 1;\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\n#ifdef _JFS_WIP_NOCOALESCE\r\nif (xoff < nxoff)\r\ngoto updateRight;\r\nreplace:\r\nif (nxlen == xlen) {\r\n*xad = *nxad;\r\nxad->flag = xflag & ~XAD_NOTRECORDED;\r\ngoto out;\r\n} else\r\ngoto updateLeft;\r\n#endif\r\nif (xoff < nxoff)\r\ngoto coalesceRight;\r\nif (index == XTENTRYSTART)\r\ngoto replace;\r\nlxad = &p->xad[index - 1];\r\nlxlen = lengthXAD(lxad);\r\nif (!(lxad->flag & XAD_NOTRECORDED) &&\r\n(nxoff == offsetXAD(lxad) + lxlen) &&\r\n(nxaddr == addressXAD(lxad) + lxlen) &&\r\n(lxlen + nxlen < MAXXLEN)) {\r\nindex0 = index - 1;\r\nXADlength(lxad, lxlen + nxlen);\r\nif (!(lxad->flag & XAD_NEW))\r\nlxad->flag |= XAD_EXTENDED;\r\nif (xlen > nxlen) {\r\nXADoffset(xad, xoff + nxlen);\r\nXADlength(xad, xlen - nxlen);\r\nXADaddress(xad, xaddr + nxlen);\r\ngoto out;\r\n} else {\r\nif (index < nextindex - 1)\r\nmemmove(&p->xad[index], &p->xad[index + 1],\r\n(nextindex - index -\r\n1) << L2XTSLOTSIZE);\r\np->header.nextindex =\r\ncpu_to_le16(le16_to_cpu(p->header.nextindex) -\r\n1);\r\nindex = index0;\r\nnewindex = index + 1;\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\nxoff = nxoff = offsetXAD(lxad);\r\nxlen = nxlen = lxlen + nxlen;\r\nxaddr = nxaddr = addressXAD(lxad);\r\ngoto coalesceRight;\r\n}\r\n}\r\nreplace:\r\nif (nxlen == xlen) {\r\n*xad = *nxad;\r\nxad->flag = xflag & ~XAD_NOTRECORDED;\r\ngoto coalesceRight;\r\n} else\r\ngoto updateLeft;\r\ncoalesceRight:\r\nif (newindex == nextindex) {\r\nif (xoff == nxoff)\r\ngoto out;\r\ngoto updateRight;\r\n}\r\nrxad = &p->xad[index + 1];\r\nrxlen = lengthXAD(rxad);\r\nif (!(rxad->flag & XAD_NOTRECORDED) &&\r\n(nxoff + nxlen == offsetXAD(rxad)) &&\r\n(nxaddr + nxlen == addressXAD(rxad)) &&\r\n(rxlen + nxlen < MAXXLEN)) {\r\nXADoffset(rxad, nxoff);\r\nXADlength(rxad, rxlen + nxlen);\r\nXADaddress(rxad, nxaddr);\r\nif (!(rxad->flag & XAD_NEW))\r\nrxad->flag |= XAD_EXTENDED;\r\nif (xlen > nxlen)\r\nXADlength(xad, xlen - nxlen);\r\nelse {\r\nmemmove(&p->xad[index], &p->xad[index + 1],\r\n(nextindex - index - 1) << L2XTSLOTSIZE);\r\np->header.nextindex =\r\ncpu_to_le16(le16_to_cpu(p->header.nextindex) -\r\n1);\r\n}\r\ngoto out;\r\n} else if (xoff == nxoff)\r\ngoto out;\r\nif (xoff >= nxoff) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb, "xtUpdate: xoff >= nxoff");\r\nreturn -EIO;\r\n}\r\nupdateRight:\r\nxad = &p->xad[index];\r\nXADlength(xad, nxoff - xoff);\r\nif (nextindex == le16_to_cpu(p->header.maxentry)) {\r\nsplit.mp = mp;\r\nsplit.index = newindex;\r\nsplit.flag = xflag & ~XAD_NOTRECORDED;\r\nsplit.off = nxoff;\r\nsplit.len = nxlen;\r\nsplit.addr = nxaddr;\r\nsplit.pxdlist = NULL;\r\nif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\r\nreturn rc;\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif (p->header.flag & BT_INTERNAL) {\r\nASSERT(p->header.nextindex ==\r\ncpu_to_le16(XTENTRYSTART + 1));\r\nxad = &p->xad[XTENTRYSTART];\r\nbn = addressXAD(xad);\r\nXT_PUTPAGE(mp);\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\n} else {\r\nif (newindex >\r\n(le16_to_cpu(p->header.maxentry) >> 1)) {\r\nnewindex =\r\nnewindex -\r\nle16_to_cpu(p->header.nextindex) +\r\nXTENTRYSTART;\r\nnewpage = 1;\r\n}\r\n}\r\n} else {\r\nif (newindex < nextindex)\r\nmemmove(&p->xad[newindex + 1], &p->xad[newindex],\r\n(nextindex - newindex) << L2XTSLOTSIZE);\r\nxad = &p->xad[newindex];\r\n*xad = *nxad;\r\nxad->flag = xflag & ~XAD_NOTRECORDED;\r\np->header.nextindex =\r\ncpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\r\n}\r\nif (nxoff + nxlen == xoff + xlen)\r\ngoto out;\r\nif (newpage) {\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nxtlck->lwm.offset = (xtlck->lwm.offset) ?\r\nmin(index0, (int)xtlck->lwm.offset) : index0;\r\nxtlck->lwm.length =\r\nle16_to_cpu(p->header.nextindex) -\r\nxtlck->lwm.offset;\r\n}\r\nbn = le64_to_cpu(p->header.next);\r\nXT_PUTPAGE(mp);\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\nindex0 = index = newindex;\r\n} else\r\nindex++;\r\nnewindex = index + 1;\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\nxlen = xlen - (nxoff - xoff);\r\nxoff = nxoff;\r\nxaddr = nxaddr;\r\nif (nextindex == le16_to_cpu(p->header.maxentry)) {\r\nXT_PUTPAGE(mp);\r\nif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\r\nif (cmp != 0) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb, "xtUpdate: xtSearch failed");\r\nreturn -EIO;\r\n}\r\nif (index0 != index) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb,\r\n"xtUpdate: unexpected value of index");\r\nreturn -EIO;\r\n}\r\n}\r\nupdateLeft:\r\nxad = &p->xad[index];\r\n*xad = *nxad;\r\nxad->flag = xflag & ~XAD_NOTRECORDED;\r\nxoff = xoff + nxlen;\r\nxlen = xlen - nxlen;\r\nxaddr = xaddr + nxlen;\r\nif (nextindex == le16_to_cpu(p->header.maxentry)) {\r\nsplit.mp = mp;\r\nsplit.index = newindex;\r\nsplit.flag = xflag;\r\nsplit.off = xoff;\r\nsplit.len = xlen;\r\nsplit.addr = xaddr;\r\nsplit.pxdlist = NULL;\r\nif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\r\nreturn rc;\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif (p->header.flag & BT_INTERNAL) {\r\nASSERT(p->header.nextindex ==\r\ncpu_to_le16(XTENTRYSTART + 1));\r\nxad = &p->xad[XTENTRYSTART];\r\nbn = addressXAD(xad);\r\nXT_PUTPAGE(mp);\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\n}\r\n}\r\n} else {\r\nif (newindex < nextindex)\r\nmemmove(&p->xad[newindex + 1], &p->xad[newindex],\r\n(nextindex - newindex) << L2XTSLOTSIZE);\r\nxad = &p->xad[newindex];\r\nXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\r\np->header.nextindex =\r\ncpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\r\n}\r\nout:\r\nif (!test_cflag(COMMIT_Nolink, ip)) {\r\nxtlck->lwm.offset = (xtlck->lwm.offset) ?\r\nmin(index0, (int)xtlck->lwm.offset) : index0;\r\nxtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\r\nxtlck->lwm.offset;\r\n}\r\nXT_PUTPAGE(mp);\r\nreturn rc;\r\n}\r\nint xtAppend(tid_t tid,\r\nstruct inode *ip, int xflag, s64 xoff, s32 maxblocks,\r\ns32 * xlenp,\r\ns64 * xaddrp,\r\nint flag)\r\n{\r\nint rc = 0;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\ns64 bn, xaddr;\r\nint index, nextindex;\r\nstruct btstack btstack;\r\nstruct xtsplit split;\r\nxad_t *xad;\r\nint cmp;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck;\r\nint nsplit, nblocks, xlen;\r\nstruct pxdlist pxdlist;\r\npxd_t *pxd;\r\ns64 next;\r\nxaddr = *xaddrp;\r\nxlen = *xlenp;\r\njfs_info("xtAppend: xoff:0x%lx maxblocks:%d xlen:%d xaddr:0x%lx",\r\n(ulong) xoff, maxblocks, xlen, (ulong) xaddr);\r\nif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif (cmp == 0) {\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\nif (next)\r\nxlen = min(xlen, (int)(next - xoff));\r\nxflag |= XAD_NEW;\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\nif (nextindex < le16_to_cpu(p->header.maxentry))\r\ngoto insertLeaf;\r\nnsplit = btstack.nsplit;\r\nsplit.pxdlist = &pxdlist;\r\npxdlist.maxnpxd = pxdlist.npxd = 0;\r\npxd = &pxdlist.pxd[0];\r\nnblocks = JFS_SBI(ip->i_sb)->nbperpage;\r\nfor (; nsplit > 0; nsplit--, pxd++, xaddr += nblocks, maxblocks -= nblocks) {\r\nif ((rc = dbAllocBottomUp(ip, xaddr, (s64) nblocks)) == 0) {\r\nPXDaddress(pxd, xaddr);\r\nPXDlength(pxd, nblocks);\r\npxdlist.maxnpxd++;\r\ncontinue;\r\n}\r\ngoto out;\r\n}\r\nxlen = min(xlen, maxblocks);\r\nif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\r\ngoto out;\r\nsplit.mp = mp;\r\nsplit.index = index;\r\nsplit.flag = xflag;\r\nsplit.off = xoff;\r\nsplit.len = xlen;\r\nsplit.addr = xaddr;\r\nif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\r\ndbFree(ip, *xaddrp, (s64) * xlenp);\r\nreturn rc;\r\n}\r\n*xaddrp = xaddr;\r\n*xlenp = xlen;\r\nreturn 0;\r\ninsertLeaf:\r\nif ((rc = dbAllocBottomUp(ip, xaddr, (s64) xlen)))\r\ngoto out;\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxad = &p->xad[index];\r\nXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\r\nle16_add_cpu(&p->header.nextindex, 1);\r\nxtlck->lwm.offset =\r\n(xtlck->lwm.offset) ? min(index,(int) xtlck->lwm.offset) : index;\r\nxtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\r\nxtlck->lwm.offset;\r\n*xaddrp = xaddr;\r\n*xlenp = xlen;\r\nout:\r\nXT_PUTPAGE(mp);\r\nreturn rc;\r\n}\r\nint xtDelete(tid_t tid, struct inode *ip, s64 xoff, s32 xlen, int flag)\r\n{\r\nint rc = 0;\r\nstruct btstack btstack;\r\nint cmp;\r\ns64 bn;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\nint index, nextindex;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck;\r\nif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0)))\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif (cmp) {\r\nXT_PUTPAGE(mp);\r\nreturn -ENOENT;\r\n}\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\nle16_add_cpu(&p->header.nextindex, -1);\r\nif (p->header.nextindex == cpu_to_le16(XTENTRYSTART))\r\nreturn (xtDeleteUp(tid, ip, mp, p, &btstack));\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckXTREE);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->lwm.offset =\r\n(xtlck->lwm.offset) ? min(index, xtlck->lwm.offset) : index;\r\nif (index < nextindex - 1)\r\nmemmove(&p->xad[index], &p->xad[index + 1],\r\n(nextindex - index - 1) * sizeof(xad_t));\r\nXT_PUTPAGE(mp);\r\nreturn 0;\r\n}\r\nstatic int\r\nxtDeleteUp(tid_t tid, struct inode *ip,\r\nstruct metapage * fmp, xtpage_t * fp, struct btstack * btstack)\r\n{\r\nint rc = 0;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\nint index, nextindex;\r\ns64 xaddr;\r\nint xlen;\r\nstruct btframe *parent;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck;\r\nif (fp->header.flag & BT_ROOT) {\r\nfp->header.flag &= ~BT_INTERNAL;\r\nfp->header.flag |= BT_LEAF;\r\nfp->header.nextindex = cpu_to_le16(XTENTRYSTART);\r\nreturn 0;\r\n}\r\nif ((rc = xtRelink(tid, ip, fp))) {\r\nXT_PUTPAGE(fmp);\r\nreturn rc;\r\n}\r\nxaddr = addressPXD(&fp->header.self);\r\nxlen = lengthPXD(&fp->header.self);\r\ndbFree(ip, xaddr, (s64) xlen);\r\ndiscard_metapage(fmp);\r\nwhile ((parent = BT_POP(btstack)) != NULL) {\r\nXT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nindex = parent->index;\r\nnextindex = le16_to_cpu(p->header.nextindex);\r\nif (nextindex == 1) {\r\nif (p->header.flag & BT_ROOT) {\r\np->header.flag &= ~BT_INTERNAL;\r\np->header.flag |= BT_LEAF;\r\np->header.nextindex =\r\ncpu_to_le16(XTENTRYSTART);\r\nbreak;\r\n} else {\r\nif ((rc = xtRelink(tid, ip, p)))\r\nreturn rc;\r\nxaddr = addressPXD(&p->header.self);\r\ndbFree(ip, xaddr,\r\n(s64) JFS_SBI(ip->i_sb)->nbperpage);\r\ndiscard_metapage(mp);\r\ncontinue;\r\n}\r\n}\r\nelse {\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckXTREE);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->lwm.offset =\r\n(xtlck->lwm.offset) ? min(index,\r\nxtlck->lwm.\r\noffset) : index;\r\nif (index < nextindex - 1)\r\nmemmove(&p->xad[index], &p->xad[index + 1],\r\n(nextindex - index -\r\n1) << L2XTSLOTSIZE);\r\nle16_add_cpu(&p->header.nextindex, -1);\r\njfs_info("xtDeleteUp(entry): 0x%lx[%d]",\r\n(ulong) parent->bn, index);\r\n}\r\nXT_PUTPAGE(mp);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxtRelocate(tid_t tid, struct inode * ip, xad_t * oxad,\r\ns64 nxaddr,\r\nint xtype)\r\n{\r\nint rc = 0;\r\nstruct tblock *tblk;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck;\r\nstruct metapage *mp, *pmp, *lmp, *rmp;\r\nxtpage_t *p, *pp, *rp, *lp;\r\nxad_t *xad;\r\npxd_t *pxd;\r\ns64 xoff, xsize;\r\nint xlen;\r\ns64 oxaddr, sxaddr, dxaddr, nextbn, prevbn;\r\ncbuf_t *cp;\r\ns64 offset, nbytes, nbrd, pno;\r\nint nb, npages, nblks;\r\ns64 bn;\r\nint cmp;\r\nint index;\r\nstruct pxd_lock *pxdlock;\r\nstruct btstack btstack;\r\nxtype = xtype & EXTENT_TYPE;\r\nxoff = offsetXAD(oxad);\r\noxaddr = addressXAD(oxad);\r\nxlen = lengthXAD(oxad);\r\noffset = xoff << JFS_SBI(ip->i_sb)->l2bsize;\r\nif (offset >= ip->i_size)\r\nreturn -ESTALE;\r\njfs_info("xtRelocate: xtype:%d xoff:0x%lx xlen:0x%x xaddr:0x%lx:0x%lx",\r\nxtype, (ulong) xoff, xlen, (ulong) oxaddr, (ulong) nxaddr);\r\nif (xtype == DATAEXT) {\r\nrc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\r\nif (rc)\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\r\nif (cmp) {\r\nXT_PUTPAGE(pmp);\r\nreturn -ESTALE;\r\n}\r\nxad = &pp->xad[index];\r\nif (addressXAD(xad) != oxaddr || lengthXAD(xad) != xlen) {\r\nXT_PUTPAGE(pmp);\r\nreturn -ESTALE;\r\n}\r\n} else {\r\nrc = xtSearchNode(ip, oxad, &cmp, &btstack, 0);\r\nif (rc)\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\r\nif (cmp) {\r\nXT_PUTPAGE(pmp);\r\nreturn -ESTALE;\r\n}\r\nxad = &pp->xad[index];\r\n}\r\njfs_info("xtRelocate: parent xad entry validated.");\r\nif (xtype == DATAEXT) {\r\nif (xad->flag & XAD_NOTRECORDED)\r\ngoto out;\r\nelse\r\nXT_PUTPAGE(pmp);\r\noffset = xoff << JFS_SBI(ip->i_sb)->l2bsize;\r\nassert((offset & CM_OFFSET) == 0);\r\nnbytes = xlen << JFS_SBI(ip->i_sb)->l2bsize;\r\npno = offset >> CM_L2BSIZE;\r\nnpages = (nbytes + (CM_BSIZE - 1)) >> CM_L2BSIZE;\r\nsxaddr = oxaddr;\r\ndxaddr = nxaddr;\r\nfor (nbrd = 0; nbrd < nbytes; nbrd += nb,\r\noffset += nb, pno++, npages--) {\r\nnb = min(nbytes - nbrd, CM_BSIZE);\r\nif (rc = cmRead(ip, offset, npages, &cp))\r\nbreak;\r\nassert(addressPXD(&cp->cm_pxd) == sxaddr);\r\nassert(!cp->cm_modified);\r\nnblks = nb >> JFS_IP(ip->i_sb)->l2bsize;\r\ncmSetXD(ip, cp, pno, dxaddr, nblks);\r\ncmPut(cp, true);\r\ndxaddr += nblks;\r\nsxaddr += nblks;\r\n}\r\nif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0)))\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\r\njfs_info("xtRelocate: target data extent relocated.");\r\n} else {\r\nXT_GETPAGE(ip, oxaddr, mp, PSIZE, p, rc);\r\nif (rc) {\r\nXT_PUTPAGE(pmp);\r\nreturn rc;\r\n}\r\nrmp = NULL;\r\nif (p->header.next) {\r\nnextbn = le64_to_cpu(p->header.next);\r\nXT_GETPAGE(ip, nextbn, rmp, PSIZE, rp, rc);\r\nif (rc) {\r\nXT_PUTPAGE(pmp);\r\nXT_PUTPAGE(mp);\r\nreturn (rc);\r\n}\r\n}\r\nlmp = NULL;\r\nif (p->header.prev) {\r\nprevbn = le64_to_cpu(p->header.prev);\r\nXT_GETPAGE(ip, prevbn, lmp, PSIZE, lp, rc);\r\nif (rc) {\r\nXT_PUTPAGE(pmp);\r\nXT_PUTPAGE(mp);\r\nif (rmp)\r\nXT_PUTPAGE(rmp);\r\nreturn (rc);\r\n}\r\n}\r\nif (lmp) {\r\nBT_MARK_DIRTY(lmp, ip);\r\ntlck = txLock(tid, ip, lmp, tlckXTREE | tlckRELINK);\r\nlp->header.next = cpu_to_le64(nxaddr);\r\nXT_PUTPAGE(lmp);\r\n}\r\nif (rmp) {\r\nBT_MARK_DIRTY(rmp, ip);\r\ntlck = txLock(tid, ip, rmp, tlckXTREE | tlckRELINK);\r\nrp->header.prev = cpu_to_le64(nxaddr);\r\nXT_PUTPAGE(rmp);\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckNEW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\npxd = &p->header.self;\r\nPXDaddress(pxd, nxaddr);\r\nxtlck->lwm.length =\r\nle16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\r\nxsize = xlen << JFS_SBI(ip->i_sb)->l2bsize;\r\nbmSetXD(mp, nxaddr, xsize);\r\nXT_PUTPAGE(mp);\r\njfs_info("xtRelocate: target xtpage relocated.");\r\n}\r\nout:\r\nif (xtype == DATAEXT)\r\ntlck = txMaplock(tid, ip, tlckMAP);\r\nelse\r\ntlck = txMaplock(tid, ip, tlckMAP | tlckRELOCATE);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\npxdlock->flag = mlckFREEPXD;\r\nPXDaddress(&pxdlock->pxd, oxaddr);\r\nPXDlength(&pxdlock->pxd, xlen);\r\npxdlock->index = 1;\r\njfs_info("xtRelocate: update parent xad entry.");\r\nBT_MARK_DIRTY(pmp, ip);\r\ntlck = txLock(tid, ip, pmp, tlckXTREE | tlckGROW);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxad = &pp->xad[index];\r\nxad->flag |= XAD_NEW;\r\nXADaddress(xad, nxaddr);\r\nxtlck->lwm.offset = min(index, xtlck->lwm.offset);\r\nxtlck->lwm.length = le16_to_cpu(pp->header.nextindex) -\r\nxtlck->lwm.offset;\r\nXT_PUTPAGE(pmp);\r\nreturn rc;\r\n}\r\nstatic int xtSearchNode(struct inode *ip, xad_t * xad,\r\nint *cmpp, struct btstack * btstack, int flag)\r\n{\r\nint rc = 0;\r\ns64 xoff, xaddr;\r\nint xlen;\r\nint cmp = 1;\r\ns64 bn;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\nint base, index, lim;\r\nstruct btframe *btsp;\r\ns64 t64;\r\nBT_CLR(btstack);\r\nxoff = offsetXAD(xad);\r\nxlen = lengthXAD(xad);\r\nxaddr = addressXAD(xad);\r\nfor (bn = 0;;) {\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nif (p->header.flag & BT_LEAF) {\r\nXT_PUTPAGE(mp);\r\nreturn -ESTALE;\r\n}\r\nlim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\r\nfor (base = XTENTRYSTART; lim; lim >>= 1) {\r\nindex = base + (lim >> 1);\r\nXT_CMP(cmp, xoff, &p->xad[index], t64);\r\nif (cmp == 0) {\r\nif (xaddr == addressXAD(&p->xad[index]) &&\r\nxoff == offsetXAD(&p->xad[index])) {\r\n*cmpp = cmp;\r\nbtsp = btstack->top;\r\nbtsp->bn = bn;\r\nbtsp->index = index;\r\nbtsp->mp = mp;\r\nreturn 0;\r\n}\r\ngoto next;\r\n}\r\nif (cmp > 0) {\r\nbase = index + 1;\r\n--lim;\r\n}\r\n}\r\nindex = base ? base - 1 : base;\r\nnext:\r\nbn = addressXAD(&p->xad[index]);\r\nXT_PUTPAGE(mp);\r\n}\r\n}\r\nstatic int xtRelink(tid_t tid, struct inode *ip, xtpage_t * p)\r\n{\r\nint rc = 0;\r\nstruct metapage *mp;\r\ns64 nextbn, prevbn;\r\nstruct tlock *tlck;\r\nnextbn = le64_to_cpu(p->header.next);\r\nprevbn = le64_to_cpu(p->header.prev);\r\nif (nextbn != 0) {\r\nXT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\r\np->header.prev = cpu_to_le64(prevbn);\r\nXT_PUTPAGE(mp);\r\n}\r\nif (prevbn != 0) {\r\nXT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nBT_MARK_DIRTY(mp, ip);\r\ntlck = txLock(tid, ip, mp, tlckXTREE | tlckRELINK);\r\np->header.next = le64_to_cpu(nextbn);\r\nXT_PUTPAGE(mp);\r\n}\r\nreturn 0;\r\n}\r\nvoid xtInitRoot(tid_t tid, struct inode *ip)\r\n{\r\nxtpage_t *p;\r\ntxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\r\ntlckXTREE | tlckNEW);\r\np = &JFS_IP(ip)->i_xtroot;\r\np->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\r\np->header.nextindex = cpu_to_le16(XTENTRYSTART);\r\nif (S_ISDIR(ip->i_mode))\r\np->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\r\nelse {\r\np->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\r\nip->i_size = 0;\r\n}\r\nreturn;\r\n}\r\ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\r\n{\r\nint rc = 0;\r\ns64 teof;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\ns64 bn;\r\nint index, nextindex;\r\nxad_t *xad;\r\ns64 xoff, xaddr;\r\nint xlen, len, freexlen;\r\nstruct btstack btstack;\r\nstruct btframe *parent;\r\nstruct tblock *tblk = NULL;\r\nstruct tlock *tlck = NULL;\r\nstruct xtlock *xtlck = NULL;\r\nstruct xdlistlock xadlock;\r\nstruct pxd_lock *pxdlock;\r\ns64 nfreed;\r\nint freed, log;\r\nint locked_leaves = 0;\r\nif (tid) {\r\ntblk = tid_to_tblock(tid);\r\ntblk->xflag |= flag;\r\n}\r\nnfreed = 0;\r\nflag &= COMMIT_MAP;\r\nassert(flag != COMMIT_PMAP);\r\nif (flag == COMMIT_PWMAP)\r\nlog = 1;\r\nelse {\r\nlog = 0;\r\nxadlock.flag = mlckFREEXADLIST;\r\nxadlock.index = 1;\r\n}\r\nteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\r\nJFS_SBI(ip->i_sb)->l2bsize;\r\nBT_CLR(&btstack);\r\nbn = 0;\r\ngetPage:\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nindex = le16_to_cpu(p->header.nextindex) - 1;\r\nif (p->header.next) {\r\nif (log)\r\ntlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\r\nBT_MARK_DIRTY(mp, ip);\r\np->header.next = 0;\r\n}\r\nif (p->header.flag & BT_INTERNAL)\r\ngoto getChild;\r\nfreed = 0;\r\nxad = &p->xad[index];\r\nxoff = offsetXAD(xad);\r\nxlen = lengthXAD(xad);\r\nif (teof >= xoff + xlen) {\r\nXT_PUTPAGE(mp);\r\ngoto getParent;\r\n}\r\nif (log) {\r\nif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\r\nXT_PUTPAGE(mp);\r\nnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\r\ngoto getParent;\r\n}\r\ntlck = txLock(tid, ip, mp, tlckXTREE);\r\ntlck->type = tlckXTREE | tlckTRUNCATE;\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\nfor (; index >= XTENTRYSTART; index--) {\r\nxad = &p->xad[index];\r\nxoff = offsetXAD(xad);\r\nxlen = lengthXAD(xad);\r\nxaddr = addressXAD(xad);\r\nif (S_ISDIR(ip->i_mode) && (teof == 0))\r\ninvalidate_xad_metapages(ip, *xad);\r\nif (teof < xoff) {\r\nnfreed += xlen;\r\ncontinue;\r\n}\r\nif (teof == xoff) {\r\nnfreed += xlen;\r\nif (index == XTENTRYSTART)\r\nbreak;\r\nnextindex = index;\r\n}\r\nelse if (teof < xoff + xlen) {\r\nlen = teof - xoff;\r\nfreexlen = xlen - len;\r\nXADlength(xad, len);\r\nxaddr += len;\r\nif (log) {\r\nxtlck->lwm.offset = (xtlck->lwm.offset) ?\r\nmin(index, (int)xtlck->lwm.offset) : index;\r\nxtlck->lwm.length = index + 1 -\r\nxtlck->lwm.offset;\r\nxtlck->twm.offset = index;\r\npxdlock = (struct pxd_lock *) & xtlck->pxdlock;\r\npxdlock->flag = mlckFREEPXD;\r\nPXDaddress(&pxdlock->pxd, xaddr);\r\nPXDlength(&pxdlock->pxd, freexlen);\r\n}\r\nelse {\r\npxdlock = (struct pxd_lock *) & xadlock;\r\npxdlock->flag = mlckFREEPXD;\r\nPXDaddress(&pxdlock->pxd, xaddr);\r\nPXDlength(&pxdlock->pxd, freexlen);\r\ntxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\r\nxadlock.flag = mlckFREEXADLIST;\r\n}\r\nnextindex = index + 1;\r\nnfreed += freexlen;\r\n}\r\nelse {\r\nnextindex = index + 1;\r\n}\r\nif (nextindex < le16_to_cpu(p->header.nextindex)) {\r\nif (!log) {\r\nxadlock.xdlist = &p->xad[nextindex];\r\nxadlock.count =\r\nle16_to_cpu(p->header.nextindex) -\r\nnextindex;\r\ntxFreeMap(ip, (struct maplock *) & xadlock,\r\nNULL, COMMIT_WMAP);\r\n}\r\np->header.nextindex = cpu_to_le16(nextindex);\r\n}\r\nXT_PUTPAGE(mp);\r\ngoto getParent;\r\n}\r\nfreed = 1;\r\nif (log) {\r\ntlck->type = tlckXTREE | tlckFREE;\r\n} else {\r\nxadlock.xdlist = &p->xad[XTENTRYSTART];\r\nxadlock.count =\r\nle16_to_cpu(p->header.nextindex) - XTENTRYSTART;\r\ntxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\r\n}\r\nif (p->header.flag & BT_ROOT) {\r\np->header.flag &= ~BT_INTERNAL;\r\np->header.flag |= BT_LEAF;\r\np->header.nextindex = cpu_to_le16(XTENTRYSTART);\r\nXT_PUTPAGE(mp);\r\ngoto out;\r\n} else {\r\nif (log) {\r\nXT_PUTPAGE(mp);\r\n} else {\r\nif (mp->lid)\r\nlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\r\ndiscard_metapage(mp);\r\n}\r\n}\r\ngetParent:\r\nif ((parent = BT_POP(&btstack)) == NULL)\r\ngoto out;\r\nbn = parent->bn;\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nindex = parent->index;\r\nif (freed == 0) {\r\nif (index < le16_to_cpu(p->header.nextindex) - 1) {\r\nif (log) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nif (!(tlck->type & tlckTRUNCATE)) {\r\nxtlck->hwm.offset =\r\nle16_to_cpu(p->header.\r\nnextindex) - 1;\r\ntlck->type =\r\ntlckXTREE | tlckTRUNCATE;\r\n}\r\n} else {\r\nxadlock.xdlist = &p->xad[index + 1];\r\nxadlock.count =\r\nle16_to_cpu(p->header.nextindex) -\r\nindex - 1;\r\ntxFreeMap(ip, (struct maplock *) & xadlock,\r\nNULL, COMMIT_WMAP);\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\np->header.nextindex = cpu_to_le16(index + 1);\r\n}\r\nXT_PUTPAGE(mp);\r\ngoto getParent;\r\n}\r\nnfreed += lengthXAD(&p->xad[index]);\r\nif (log && mp->lid && (tblk->last != mp->lid) &&\r\nlid_to_tlock(mp->lid)->tid) {\r\nlid_t lid = mp->lid;\r\nstruct tlock *prev;\r\ntlck = lid_to_tlock(lid);\r\nif (tblk->next == lid)\r\ntblk->next = tlck->next;\r\nelse {\r\nfor (prev = lid_to_tlock(tblk->next);\r\nprev->next != lid;\r\nprev = lid_to_tlock(prev->next)) {\r\nassert(prev->next);\r\n}\r\nprev->next = tlck->next;\r\n}\r\nlid_to_tlock(tblk->last)->next = lid;\r\ntlck->next = 0;\r\ntblk->last = lid;\r\n}\r\nif (index == XTENTRYSTART) {\r\nif (log) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->hwm.offset =\r\nle16_to_cpu(p->header.nextindex) - 1;\r\ntlck->type = tlckXTREE | tlckFREE;\r\n} else {\r\nxadlock.xdlist = &p->xad[XTENTRYSTART];\r\nxadlock.count =\r\nle16_to_cpu(p->header.nextindex) -\r\nXTENTRYSTART;\r\ntxFreeMap(ip, (struct maplock *) & xadlock, NULL,\r\nCOMMIT_WMAP);\r\n}\r\nBT_MARK_DIRTY(mp, ip);\r\nif (p->header.flag & BT_ROOT) {\r\np->header.flag &= ~BT_INTERNAL;\r\np->header.flag |= BT_LEAF;\r\np->header.nextindex = cpu_to_le16(XTENTRYSTART);\r\nif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\r\np->header.maxentry =\r\ncpu_to_le16(XTROOTINITSLOT);\r\nJFS_IP(ip)->mode2 |= INLINEEA;\r\n}\r\nXT_PUTPAGE(mp);\r\ngoto out;\r\n} else {\r\nif (log) {\r\nXT_PUTPAGE(mp);\r\n} else {\r\nif (mp->lid)\r\nlid_to_tlock(mp->lid)->flag |=\r\ntlckFREELOCK;\r\ndiscard_metapage(mp);\r\n}\r\ngoto getParent;\r\n}\r\n}\r\nelse {\r\nindex--;\r\ngoto getChild;\r\n}\r\ngetChild:\r\nif (BT_STACK_FULL(&btstack)) {\r\njfs_error(ip->i_sb, "stack overrun in xtTruncate!");\r\nXT_PUTPAGE(mp);\r\nreturn -EIO;\r\n}\r\nBT_PUSH(&btstack, bn, index);\r\nxad = &p->xad[index];\r\nbn = addressXAD(xad);\r\nXT_PUTPAGE(mp);\r\ngoto getPage;\r\nout:\r\nif (S_ISDIR(ip->i_mode) && !newsize)\r\nip->i_size = 1;\r\nelse\r\nip->i_size = newsize;\r\ndquot_free_block(ip, nfreed);\r\nif (flag == COMMIT_WMAP)\r\ntxFreelock(ip);\r\nreturn newsize;\r\n}\r\ns64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\r\n{\r\ns64 bn;\r\nstruct btstack btstack;\r\nint cmp;\r\nint index;\r\nint locked_leaves = 0;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\nstruct btframe *parent;\r\nint rc;\r\nstruct tblock *tblk;\r\nstruct tlock *tlck = NULL;\r\nxad_t *xad;\r\nint xlen;\r\ns64 xoff;\r\nstruct xtlock *xtlck = NULL;\r\ntblk = tid_to_tblock(tid);\r\ntblk->xflag |= COMMIT_PMAP;\r\nBT_CLR(&btstack);\r\nif (committed_size) {\r\nxoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\r\nrc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\r\nif (rc)\r\nreturn rc;\r\nXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\r\nif (cmp != 0) {\r\nXT_PUTPAGE(mp);\r\njfs_error(ip->i_sb,\r\n"xtTruncate_pmap: did not find extent");\r\nreturn -EIO;\r\n}\r\n} else {\r\nbn = 0;\r\ngetPage:\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nindex = le16_to_cpu(p->header.nextindex) - 1;\r\nif (p->header.flag & BT_INTERNAL)\r\ngoto getChild;\r\n}\r\nif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\r\nxad = &p->xad[index];\r\nxoff = offsetXAD(xad);\r\nxlen = lengthXAD(xad);\r\nXT_PUTPAGE(mp);\r\nreturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\r\n}\r\ntlck = txLock(tid, ip, mp, tlckXTREE);\r\ntlck->type = tlckXTREE | tlckFREE;\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->hwm.offset = index;\r\nXT_PUTPAGE(mp);\r\ngetParent:\r\nif ((parent = BT_POP(&btstack)) == NULL)\r\ngoto out;\r\nbn = parent->bn;\r\nXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\r\nif (rc)\r\nreturn rc;\r\nindex = parent->index;\r\nif (index == XTENTRYSTART) {\r\ntlck = txLock(tid, ip, mp, tlckXTREE);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nxtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\r\ntlck->type = tlckXTREE | tlckFREE;\r\nXT_PUTPAGE(mp);\r\nif (p->header.flag & BT_ROOT) {\r\ngoto out;\r\n} else {\r\ngoto getParent;\r\n}\r\n}\r\nelse\r\nindex--;\r\ngetChild:\r\nif (BT_STACK_FULL(&btstack)) {\r\njfs_error(ip->i_sb, "stack overrun in xtTruncate_pmap!");\r\nXT_PUTPAGE(mp);\r\nreturn -EIO;\r\n}\r\nBT_PUSH(&btstack, bn, index);\r\nxad = &p->xad[index];\r\nbn = addressXAD(xad);\r\nXT_PUTPAGE(mp);\r\ngoto getPage;\r\nout:\r\nreturn 0;\r\n}\r\nstatic int jfs_xtstat_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m,\r\n"JFS Xtree statistics\n"\r\n"====================\n"\r\n"searches = %d\n"\r\n"fast searches = %d\n"\r\n"splits = %d\n",\r\nxtStat.search,\r\nxtStat.fastSearch,\r\nxtStat.split);\r\nreturn 0;\r\n}\r\nstatic int jfs_xtstat_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, jfs_xtstat_proc_show, NULL);\r\n}
