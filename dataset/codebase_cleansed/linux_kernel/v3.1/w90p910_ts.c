static void w90p910_report_event(struct w90p910_ts *w90p910_ts, bool down)\r\n{\r\nstruct input_dev *dev = w90p910_ts->input;\r\nif (down) {\r\ninput_report_abs(dev, ABS_X,\r\n__raw_readl(w90p910_ts->ts_reg + 0x0c));\r\ninput_report_abs(dev, ABS_Y,\r\n__raw_readl(w90p910_ts->ts_reg + 0x10));\r\n}\r\ninput_report_key(dev, BTN_TOUCH, down);\r\ninput_sync(dev);\r\n}\r\nstatic void w90p910_prepare_x_reading(struct w90p910_ts *w90p910_ts)\r\n{\r\nunsigned long ctlreg;\r\n__raw_writel(ADC_TSC_X, w90p910_ts->ts_reg + 0x04);\r\nctlreg = __raw_readl(w90p910_ts->ts_reg);\r\nctlreg &= ~(ADC_WAITTRIG | WT_INT | WT_INT_EN);\r\nctlreg |= ADC_SEMIAUTO | ADC_INT_EN | ADC_CONV;\r\n__raw_writel(ctlreg, w90p910_ts->ts_reg);\r\nw90p910_ts->state = TS_WAIT_X_COORD;\r\n}\r\nstatic void w90p910_prepare_y_reading(struct w90p910_ts *w90p910_ts)\r\n{\r\nunsigned long ctlreg;\r\n__raw_writel(ADC_TSC_Y, w90p910_ts->ts_reg + 0x04);\r\nctlreg = __raw_readl(w90p910_ts->ts_reg);\r\nctlreg &= ~(ADC_WAITTRIG | ADC_INT | WT_INT_EN);\r\nctlreg |= ADC_SEMIAUTO | ADC_INT_EN | ADC_CONV;\r\n__raw_writel(ctlreg, w90p910_ts->ts_reg);\r\nw90p910_ts->state = TS_WAIT_Y_COORD;\r\n}\r\nstatic void w90p910_prepare_next_packet(struct w90p910_ts *w90p910_ts)\r\n{\r\nunsigned long ctlreg;\r\nctlreg = __raw_readl(w90p910_ts->ts_reg);\r\nctlreg &= ~(ADC_INT | ADC_INT_EN | ADC_SEMIAUTO | ADC_CONV);\r\nctlreg |= ADC_WAITTRIG | WT_INT_EN;\r\n__raw_writel(ctlreg, w90p910_ts->ts_reg);\r\nw90p910_ts->state = TS_WAIT_NEW_PACKET;\r\n}\r\nstatic irqreturn_t w90p910_ts_interrupt(int irq, void *dev_id)\r\n{\r\nstruct w90p910_ts *w90p910_ts = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&w90p910_ts->lock, flags);\r\nswitch (w90p910_ts->state) {\r\ncase TS_WAIT_NEW_PACKET:\r\ndel_timer(&w90p910_ts->timer);\r\nw90p910_prepare_x_reading(w90p910_ts);\r\nbreak;\r\ncase TS_WAIT_X_COORD:\r\nw90p910_prepare_y_reading(w90p910_ts);\r\nbreak;\r\ncase TS_WAIT_Y_COORD:\r\nw90p910_report_event(w90p910_ts, true);\r\nw90p910_prepare_next_packet(w90p910_ts);\r\nmod_timer(&w90p910_ts->timer, jiffies + msecs_to_jiffies(100));\r\nbreak;\r\ncase TS_IDLE:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&w90p910_ts->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void w90p910_check_pen_up(unsigned long data)\r\n{\r\nstruct w90p910_ts *w90p910_ts = (struct w90p910_ts *) data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&w90p910_ts->lock, flags);\r\nif (w90p910_ts->state == TS_WAIT_NEW_PACKET &&\r\n!(__raw_readl(w90p910_ts->ts_reg + 0x04) & ADC_DOWN)) {\r\nw90p910_report_event(w90p910_ts, false);\r\n}\r\nspin_unlock_irqrestore(&w90p910_ts->lock, flags);\r\n}\r\nstatic int w90p910_open(struct input_dev *dev)\r\n{\r\nstruct w90p910_ts *w90p910_ts = input_get_drvdata(dev);\r\nunsigned long val;\r\nclk_enable(w90p910_ts->clk);\r\n__raw_writel(ADC_RST1, w90p910_ts->ts_reg);\r\nmsleep(1);\r\n__raw_writel(ADC_RST0, w90p910_ts->ts_reg);\r\nmsleep(1);\r\nval = __raw_readl(w90p910_ts->ts_reg + 0x04);\r\n__raw_writel(val & TSC_FOURWIRE, w90p910_ts->ts_reg + 0x04);\r\n__raw_writel(ADC_DELAY, w90p910_ts->ts_reg + 0x08);\r\nw90p910_ts->state = TS_WAIT_NEW_PACKET;\r\nwmb();\r\nval = __raw_readl(w90p910_ts->ts_reg);\r\nval |= ADC_WAITTRIG | ADC_DIV | ADC_EN | WT_INT_EN;\r\n__raw_writel(val, w90p910_ts->ts_reg);\r\nreturn 0;\r\n}\r\nstatic void w90p910_close(struct input_dev *dev)\r\n{\r\nstruct w90p910_ts *w90p910_ts = input_get_drvdata(dev);\r\nunsigned long val;\r\nspin_lock_irq(&w90p910_ts->lock);\r\nw90p910_ts->state = TS_IDLE;\r\nval = __raw_readl(w90p910_ts->ts_reg);\r\nval &= ~(ADC_WAITTRIG | ADC_DIV | ADC_EN | WT_INT_EN | ADC_INT_EN);\r\n__raw_writel(val, w90p910_ts->ts_reg);\r\nspin_unlock_irq(&w90p910_ts->lock);\r\ndel_timer_sync(&w90p910_ts->timer);\r\nclk_disable(w90p910_ts->clk);\r\n}\r\nstatic int __devinit w90x900ts_probe(struct platform_device *pdev)\r\n{\r\nstruct w90p910_ts *w90p910_ts;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint err;\r\nw90p910_ts = kzalloc(sizeof(struct w90p910_ts), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!w90p910_ts || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nw90p910_ts->input = input_dev;\r\nw90p910_ts->state = TS_IDLE;\r\nspin_lock_init(&w90p910_ts->lock);\r\nsetup_timer(&w90p910_ts->timer, w90p910_check_pen_up,\r\n(unsigned long)w90p910_ts);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerr = -ENXIO;\r\ngoto fail1;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res),\r\npdev->name)) {\r\nerr = -EBUSY;\r\ngoto fail1;\r\n}\r\nw90p910_ts->ts_reg = ioremap(res->start, resource_size(res));\r\nif (!w90p910_ts->ts_reg) {\r\nerr = -ENOMEM;\r\ngoto fail2;\r\n}\r\nw90p910_ts->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(w90p910_ts->clk)) {\r\nerr = PTR_ERR(w90p910_ts->clk);\r\ngoto fail3;\r\n}\r\ninput_dev->name = "W90P910 TouchScreen";\r\ninput_dev->phys = "w90p910ts/event0";\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0005;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = w90p910_open;\r\ninput_dev->close = w90p910_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, 0x400, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, 0x400, 0, 0);\r\ninput_set_drvdata(input_dev, w90p910_ts);\r\nw90p910_ts->irq_num = platform_get_irq(pdev, 0);\r\nif (request_irq(w90p910_ts->irq_num, w90p910_ts_interrupt,\r\nIRQF_DISABLED, "w90p910ts", w90p910_ts)) {\r\nerr = -EBUSY;\r\ngoto fail4;\r\n}\r\nerr = input_register_device(w90p910_ts->input);\r\nif (err)\r\ngoto fail5;\r\nplatform_set_drvdata(pdev, w90p910_ts);\r\nreturn 0;\r\nfail5: free_irq(w90p910_ts->irq_num, w90p910_ts);\r\nfail4: clk_put(w90p910_ts->clk);\r\nfail3: iounmap(w90p910_ts->ts_reg);\r\nfail2: release_mem_region(res->start, resource_size(res));\r\nfail1: input_free_device(input_dev);\r\nkfree(w90p910_ts);\r\nreturn err;\r\n}\r\nstatic int __devexit w90x900ts_remove(struct platform_device *pdev)\r\n{\r\nstruct w90p910_ts *w90p910_ts = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nfree_irq(w90p910_ts->irq_num, w90p910_ts);\r\ndel_timer_sync(&w90p910_ts->timer);\r\niounmap(w90p910_ts->ts_reg);\r\nclk_put(w90p910_ts->clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\ninput_unregister_device(w90p910_ts->input);\r\nkfree(w90p910_ts);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init w90x900ts_init(void)\r\n{\r\nreturn platform_driver_register(&w90x900ts_driver);\r\n}\r\nstatic void __exit w90x900ts_exit(void)\r\n{\r\nplatform_driver_unregister(&w90x900ts_driver);\r\n}
