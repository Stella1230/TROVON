int ql_unpause_mpi_risc(struct ql_adapter *qdev)\r\n{\r\nu32 tmp;\r\ntmp = ql_read32(qdev, CSR);\r\nif (!(tmp & CSR_RP))\r\nreturn -EIO;\r\nql_write32(qdev, CSR, CSR_CMD_CLR_PAUSE);\r\nreturn 0;\r\n}\r\nint ql_pause_mpi_risc(struct ql_adapter *qdev)\r\n{\r\nu32 tmp;\r\nint count = UDELAY_COUNT;\r\nql_write32(qdev, CSR, CSR_CMD_SET_PAUSE);\r\ndo {\r\ntmp = ql_read32(qdev, CSR);\r\nif (tmp & CSR_RP)\r\nbreak;\r\nmdelay(UDELAY_DELAY);\r\ncount--;\r\n} while (count);\r\nreturn (count == 0) ? -ETIMEDOUT : 0;\r\n}\r\nint ql_hard_reset_mpi_risc(struct ql_adapter *qdev)\r\n{\r\nu32 tmp;\r\nint count = UDELAY_COUNT;\r\nql_write32(qdev, CSR, CSR_CMD_SET_RST);\r\ndo {\r\ntmp = ql_read32(qdev, CSR);\r\nif (tmp & CSR_RR) {\r\nql_write32(qdev, CSR, CSR_CMD_CLR_RST);\r\nbreak;\r\n}\r\nmdelay(UDELAY_DELAY);\r\ncount--;\r\n} while (count);\r\nreturn (count == 0) ? -ETIMEDOUT : 0;\r\n}\r\nint ql_read_mpi_reg(struct ql_adapter *qdev, u32 reg, u32 *data)\r\n{\r\nint status;\r\nstatus = ql_wait_reg_rdy(qdev, PROC_ADDR, PROC_ADDR_RDY, PROC_ADDR_ERR);\r\nif (status)\r\ngoto exit;\r\nql_write32(qdev, PROC_ADDR, reg | PROC_ADDR_R);\r\nstatus = ql_wait_reg_rdy(qdev, PROC_ADDR, PROC_ADDR_RDY, PROC_ADDR_ERR);\r\nif (status)\r\ngoto exit;\r\n*data = ql_read32(qdev, PROC_DATA);\r\nexit:\r\nreturn status;\r\n}\r\nint ql_write_mpi_reg(struct ql_adapter *qdev, u32 reg, u32 data)\r\n{\r\nint status = 0;\r\nstatus = ql_wait_reg_rdy(qdev, PROC_ADDR, PROC_ADDR_RDY, PROC_ADDR_ERR);\r\nif (status)\r\ngoto exit;\r\nql_write32(qdev, PROC_DATA, data);\r\nql_write32(qdev, PROC_ADDR, reg);\r\nstatus = ql_wait_reg_rdy(qdev, PROC_ADDR, PROC_ADDR_RDY, PROC_ADDR_ERR);\r\nif (status)\r\ngoto exit;\r\nexit:\r\nreturn status;\r\n}\r\nint ql_soft_reset_mpi_risc(struct ql_adapter *qdev)\r\n{\r\nint status;\r\nstatus = ql_write_mpi_reg(qdev, 0x00001010, 1);\r\nreturn status;\r\n}\r\nint ql_own_firmware(struct ql_adapter *qdev)\r\n{\r\nu32 temp;\r\nif (qdev->func < qdev->alt_func)\r\nreturn 1;\r\ntemp = ql_read32(qdev, STS);\r\nif (!(temp & (1 << (8 + qdev->alt_func))))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ql_get_mb_sts(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint i, status;\r\nstatus = ql_sem_spinlock(qdev, SEM_PROC_REG_MASK);\r\nif (status)\r\nreturn -EBUSY;\r\nfor (i = 0; i < mbcp->out_count; i++) {\r\nstatus =\r\nql_read_mpi_reg(qdev, qdev->mailbox_out + i,\r\n&mbcp->mbox_out[i]);\r\nif (status) {\r\nnetif_err(qdev, drv, qdev->ndev, "Failed mailbox read.\n");\r\nbreak;\r\n}\r\n}\r\nql_sem_unlock(qdev, SEM_PROC_REG_MASK);\r\nreturn status;\r\n}\r\nstatic int ql_wait_mbx_cmd_cmplt(struct ql_adapter *qdev)\r\n{\r\nint count = 100;\r\nu32 value;\r\ndo {\r\nvalue = ql_read32(qdev, STS);\r\nif (value & STS_PI)\r\nreturn 0;\r\nmdelay(UDELAY_DELAY);\r\n} while (--count);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ql_exec_mb_cmd(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint i, status;\r\nif (ql_read32(qdev, CSR) & CSR_HRI)\r\nreturn -EIO;\r\nstatus = ql_sem_spinlock(qdev, SEM_PROC_REG_MASK);\r\nif (status)\r\nreturn status;\r\nfor (i = 0; i < mbcp->in_count; i++) {\r\nstatus = ql_write_mpi_reg(qdev, qdev->mailbox_in + i,\r\nmbcp->mbox_in[i]);\r\nif (status)\r\ngoto end;\r\n}\r\nql_write32(qdev, CSR, CSR_CMD_SET_H2R_INT);\r\nend:\r\nql_sem_unlock(qdev, SEM_PROC_REG_MASK);\r\nreturn status;\r\n}\r\nstatic int ql_idc_req_aen(struct ql_adapter *qdev)\r\n{\r\nint status;\r\nstruct mbox_params *mbcp = &qdev->idc_mbc;\r\nnetif_err(qdev, drv, qdev->ndev, "Enter!\n");\r\nmbcp = &qdev->idc_mbc;\r\nmbcp->out_count = 4;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Could not read MPI, resetting ASIC!\n");\r\nql_queue_asic_error(qdev);\r\n} else {\r\nql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\r\nqueue_delayed_work(qdev->workqueue, &qdev->mpi_idc_work, 0);\r\n}\r\nreturn status;\r\n}\r\nstatic int ql_idc_cmplt_aen(struct ql_adapter *qdev)\r\n{\r\nint status;\r\nstruct mbox_params *mbcp = &qdev->idc_mbc;\r\nmbcp->out_count = 4;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Could not read MPI, resetting RISC!\n");\r\nql_queue_fw_error(qdev);\r\n} else\r\ncomplete(&qdev->ide_completion);\r\nreturn status;\r\n}\r\nstatic void ql_link_up(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint status;\r\nmbcp->out_count = 2;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"%s: Could not get mailbox status.\n", __func__);\r\nreturn;\r\n}\r\nqdev->link_status = mbcp->mbox_out[1];\r\nnetif_err(qdev, drv, qdev->ndev, "Link Up.\n");\r\nif (test_bit(QL_CAM_RT_SET, &qdev->flags)) {\r\nstatus = ql_cam_route_initialize(qdev);\r\nif (status) {\r\nnetif_err(qdev, ifup, qdev->ndev,\r\n"Failed to init CAM/Routing tables.\n");\r\nreturn;\r\n} else\r\nclear_bit(QL_CAM_RT_SET, &qdev->flags);\r\n}\r\nif (!test_bit(QL_PORT_CFG, &qdev->flags)) {\r\nnetif_err(qdev, drv, qdev->ndev, "Queue Port Config Worker!\n");\r\nset_bit(QL_PORT_CFG, &qdev->flags);\r\nql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\r\nqueue_delayed_work(qdev->workqueue,\r\n&qdev->mpi_port_cfg_work, 0);\r\n}\r\nql_link_on(qdev);\r\n}\r\nstatic void ql_link_down(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint status;\r\nmbcp->out_count = 3;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status)\r\nnetif_err(qdev, drv, qdev->ndev, "Link down AEN broken!\n");\r\nql_link_off(qdev);\r\n}\r\nstatic int ql_sfp_in(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint status;\r\nmbcp->out_count = 5;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status)\r\nnetif_err(qdev, drv, qdev->ndev, "SFP in AEN broken!\n");\r\nelse\r\nnetif_err(qdev, drv, qdev->ndev, "SFP insertion detected.\n");\r\nreturn status;\r\n}\r\nstatic int ql_sfp_out(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint status;\r\nmbcp->out_count = 1;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status)\r\nnetif_err(qdev, drv, qdev->ndev, "SFP out AEN broken!\n");\r\nelse\r\nnetif_err(qdev, drv, qdev->ndev, "SFP removal detected.\n");\r\nreturn status;\r\n}\r\nstatic int ql_aen_lost(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint status;\r\nmbcp->out_count = 6;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status)\r\nnetif_err(qdev, drv, qdev->ndev, "Lost AEN broken!\n");\r\nelse {\r\nint i;\r\nnetif_err(qdev, drv, qdev->ndev, "Lost AEN detected.\n");\r\nfor (i = 0; i < mbcp->out_count; i++)\r\nnetif_err(qdev, drv, qdev->ndev, "mbox_out[%d] = 0x%.08x.\n",\r\ni, mbcp->mbox_out[i]);\r\n}\r\nreturn status;\r\n}\r\nstatic void ql_init_fw_done(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint status;\r\nmbcp->out_count = 2;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status) {\r\nnetif_err(qdev, drv, qdev->ndev, "Firmware did not initialize!\n");\r\n} else {\r\nnetif_err(qdev, drv, qdev->ndev, "Firmware Revision = 0x%.08x.\n",\r\nmbcp->mbox_out[1]);\r\nqdev->fw_rev_id = mbcp->mbox_out[1];\r\nstatus = ql_cam_route_initialize(qdev);\r\nif (status)\r\nnetif_err(qdev, ifup, qdev->ndev,\r\n"Failed to init CAM/Routing tables.\n");\r\n}\r\n}\r\nstatic int ql_mpi_handler(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint status;\r\nint orig_count = mbcp->out_count;\r\nmbcp->out_count = 1;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nif (status) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Could not read MPI, resetting ASIC!\n");\r\nql_queue_asic_error(qdev);\r\ngoto end;\r\n}\r\nswitch (mbcp->mbox_out[0]) {\r\ncase MB_CMD_STS_INTRMDT:\r\ncase MB_CMD_STS_GOOD:\r\ncase MB_CMD_STS_INVLD_CMD:\r\ncase MB_CMD_STS_XFC_ERR:\r\ncase MB_CMD_STS_CSUM_ERR:\r\ncase MB_CMD_STS_ERR:\r\ncase MB_CMD_STS_PARAM_ERR:\r\nmbcp->out_count = orig_count;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nreturn status;\r\ncase AEN_IDC_REQ:\r\nstatus = ql_idc_req_aen(qdev);\r\nbreak;\r\ncase AEN_IDC_CMPLT:\r\ncase AEN_IDC_EXT:\r\nstatus = ql_idc_cmplt_aen(qdev);\r\nbreak;\r\ncase AEN_LINK_UP:\r\nql_link_up(qdev, mbcp);\r\nbreak;\r\ncase AEN_LINK_DOWN:\r\nql_link_down(qdev, mbcp);\r\nbreak;\r\ncase AEN_FW_INIT_DONE:\r\nif (mbcp->mbox_in[0] == MB_CMD_EX_FW) {\r\nmbcp->out_count = orig_count;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nmbcp->mbox_out[0] = MB_CMD_STS_GOOD;\r\nreturn status;\r\n}\r\nql_init_fw_done(qdev, mbcp);\r\nbreak;\r\ncase AEN_AEN_SFP_IN:\r\nql_sfp_in(qdev, mbcp);\r\nbreak;\r\ncase AEN_AEN_SFP_OUT:\r\nql_sfp_out(qdev, mbcp);\r\nbreak;\r\ncase AEN_FW_INIT_FAIL:\r\nif (mbcp->mbox_in[0] == MB_CMD_EX_FW) {\r\nmbcp->out_count = orig_count;\r\nstatus = ql_get_mb_sts(qdev, mbcp);\r\nmbcp->mbox_out[0] = MB_CMD_STS_ERR;\r\nreturn status;\r\n}\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Firmware initialization failed.\n");\r\nstatus = -EIO;\r\nql_queue_fw_error(qdev);\r\nbreak;\r\ncase AEN_SYS_ERR:\r\nnetif_err(qdev, drv, qdev->ndev, "System Error.\n");\r\nql_queue_fw_error(qdev);\r\nstatus = -EIO;\r\nbreak;\r\ncase AEN_AEN_LOST:\r\nql_aen_lost(qdev, mbcp);\r\nbreak;\r\ncase AEN_DCBX_CHG:\r\nbreak;\r\ndefault:\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Unsupported AE %.08x.\n", mbcp->mbox_out[0]);\r\n}\r\nend:\r\nql_write32(qdev, CSR, CSR_CMD_CLR_R2PCI_INT);\r\nmbcp->out_count = orig_count;\r\nreturn status;\r\n}\r\nstatic int ql_mailbox_command(struct ql_adapter *qdev, struct mbox_params *mbcp)\r\n{\r\nint status;\r\nunsigned long count;\r\nmutex_lock(&qdev->mpi_mutex);\r\nql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\r\nstatus = ql_exec_mb_cmd(qdev, mbcp);\r\nif (status)\r\ngoto end;\r\nif (mbcp->mbox_in[0] == MB_CMD_MAKE_SYS_ERR)\r\ngoto end;\r\ncount = jiffies + HZ * MAILBOX_TIMEOUT;\r\ndo {\r\nstatus = ql_wait_mbx_cmd_cmplt(qdev);\r\nif (status)\r\ncontinue;\r\nstatus = ql_mpi_handler(qdev, mbcp);\r\nif (status)\r\ngoto end;\r\nif (((mbcp->mbox_out[0] & 0x0000f000) ==\r\nMB_CMD_STS_GOOD) ||\r\n((mbcp->mbox_out[0] & 0x0000f000) ==\r\nMB_CMD_STS_INTRMDT))\r\ngoto done;\r\n} while (time_before(jiffies, count));\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Timed out waiting for mailbox complete.\n");\r\nstatus = -ETIMEDOUT;\r\ngoto end;\r\ndone:\r\nql_write32(qdev, CSR, CSR_CMD_CLR_R2PCI_INT);\r\nif (((mbcp->mbox_out[0] & 0x0000f000) !=\r\nMB_CMD_STS_GOOD) &&\r\n((mbcp->mbox_out[0] & 0x0000f000) !=\r\nMB_CMD_STS_INTRMDT)) {\r\nstatus = -EIO;\r\n}\r\nend:\r\nql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16) | INTR_MASK_PI);\r\nmutex_unlock(&qdev->mpi_mutex);\r\nreturn status;\r\n}\r\nint ql_mb_about_fw(struct ql_adapter *qdev)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status = 0;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 1;\r\nmbcp->out_count = 3;\r\nmbcp->mbox_in[0] = MB_CMD_ABOUT_FW;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Failed about firmware command\n");\r\nstatus = -EIO;\r\n}\r\nqdev->fw_rev_id = mbcp->mbox_out[1];\r\nreturn status;\r\n}\r\nint ql_mb_get_fw_state(struct ql_adapter *qdev)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status = 0;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 1;\r\nmbcp->out_count = 2;\r\nmbcp->mbox_in[0] = MB_CMD_GET_FW_STATE;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Failed Get Firmware State.\n");\r\nstatus = -EIO;\r\n}\r\nif (mbcp->mbox_out[1] & 1) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Firmware waiting for initialization.\n");\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nstatic int ql_mb_idc_ack(struct ql_adapter *qdev)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status = 0;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 5;\r\nmbcp->out_count = 1;\r\nmbcp->mbox_in[0] = MB_CMD_IDC_ACK;\r\nmbcp->mbox_in[1] = qdev->idc_mbc.mbox_out[1];\r\nmbcp->mbox_in[2] = qdev->idc_mbc.mbox_out[2];\r\nmbcp->mbox_in[3] = qdev->idc_mbc.mbox_out[3];\r\nmbcp->mbox_in[4] = qdev->idc_mbc.mbox_out[4];\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev, "Failed IDC ACK send.\n");\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nint ql_mb_set_port_cfg(struct ql_adapter *qdev)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status = 0;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 3;\r\nmbcp->out_count = 1;\r\nmbcp->mbox_in[0] = MB_CMD_SET_PORT_CFG;\r\nmbcp->mbox_in[1] = qdev->link_config;\r\nmbcp->mbox_in[2] = qdev->max_frame_size;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] == MB_CMD_STS_INTRMDT) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Port Config sent, wait for IDC.\n");\r\n} else if (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Failed Set Port Configuration.\n");\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nstatic int ql_mb_dump_ram(struct ql_adapter *qdev, u64 req_dma, u32 addr,\r\nu32 size)\r\n{\r\nint status = 0;\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 9;\r\nmbcp->out_count = 1;\r\nmbcp->mbox_in[0] = MB_CMD_DUMP_RISC_RAM;\r\nmbcp->mbox_in[1] = LSW(addr);\r\nmbcp->mbox_in[2] = MSW(req_dma);\r\nmbcp->mbox_in[3] = LSW(req_dma);\r\nmbcp->mbox_in[4] = MSW(size);\r\nmbcp->mbox_in[5] = LSW(size);\r\nmbcp->mbox_in[6] = MSW(MSD(req_dma));\r\nmbcp->mbox_in[7] = LSW(MSD(req_dma));\r\nmbcp->mbox_in[8] = MSW(addr);\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev, "Failed to dump risc RAM.\n");\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nint ql_dump_risc_ram_area(struct ql_adapter *qdev, void *buf,\r\nu32 ram_addr, int word_count)\r\n{\r\nint status;\r\nchar *my_buf;\r\ndma_addr_t buf_dma;\r\nmy_buf = pci_alloc_consistent(qdev->pdev, word_count * sizeof(u32),\r\n&buf_dma);\r\nif (!my_buf)\r\nreturn -EIO;\r\nstatus = ql_mb_dump_ram(qdev, buf_dma, ram_addr, word_count);\r\nif (!status)\r\nmemcpy(buf, my_buf, word_count * sizeof(u32));\r\npci_free_consistent(qdev->pdev, word_count * sizeof(u32), my_buf,\r\nbuf_dma);\r\nreturn status;\r\n}\r\nint ql_mb_get_port_cfg(struct ql_adapter *qdev)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status = 0;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 1;\r\nmbcp->out_count = 3;\r\nmbcp->mbox_in[0] = MB_CMD_GET_PORT_CFG;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Failed Get Port Configuration.\n");\r\nstatus = -EIO;\r\n} else {\r\nnetif_printk(qdev, drv, KERN_DEBUG, qdev->ndev,\r\n"Passed Get Port Configuration.\n");\r\nqdev->link_config = mbcp->mbox_out[1];\r\nqdev->max_frame_size = mbcp->mbox_out[2];\r\n}\r\nreturn status;\r\n}\r\nint ql_mb_wol_mode(struct ql_adapter *qdev, u32 wol)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 2;\r\nmbcp->out_count = 1;\r\nmbcp->mbox_in[0] = MB_CMD_SET_WOL_MODE;\r\nmbcp->mbox_in[1] = wol;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev, "Failed to set WOL mode.\n");\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nint ql_mb_wol_set_magic(struct ql_adapter *qdev, u32 enable_wol)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status;\r\nu8 *addr = qdev->ndev->dev_addr;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 8;\r\nmbcp->out_count = 1;\r\nmbcp->mbox_in[0] = MB_CMD_SET_WOL_MAGIC;\r\nif (enable_wol) {\r\nmbcp->mbox_in[1] = (u32)addr[0];\r\nmbcp->mbox_in[2] = (u32)addr[1];\r\nmbcp->mbox_in[3] = (u32)addr[2];\r\nmbcp->mbox_in[4] = (u32)addr[3];\r\nmbcp->mbox_in[5] = (u32)addr[4];\r\nmbcp->mbox_in[6] = (u32)addr[5];\r\nmbcp->mbox_in[7] = 0;\r\n} else {\r\nmbcp->mbox_in[1] = 0;\r\nmbcp->mbox_in[2] = 1;\r\nmbcp->mbox_in[3] = 1;\r\nmbcp->mbox_in[4] = 1;\r\nmbcp->mbox_in[5] = 1;\r\nmbcp->mbox_in[6] = 1;\r\nmbcp->mbox_in[7] = 0;\r\n}\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev, "Failed to set WOL mode.\n");\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nstatic int ql_idc_wait(struct ql_adapter *qdev)\r\n{\r\nint status = -ETIMEDOUT;\r\nlong wait_time = 1 * HZ;\r\nstruct mbox_params *mbcp = &qdev->idc_mbc;\r\ndo {\r\nwait_time =\r\nwait_for_completion_timeout(&qdev->ide_completion,\r\nwait_time);\r\nif (!wait_time) {\r\nnetif_err(qdev, drv, qdev->ndev, "IDC Timeout.\n");\r\nbreak;\r\n}\r\nif (mbcp->mbox_out[0] == AEN_IDC_EXT) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"IDC Time Extension from function.\n");\r\nwait_time += (mbcp->mbox_out[1] >> 8) & 0x0000000f;\r\n} else if (mbcp->mbox_out[0] == AEN_IDC_CMPLT) {\r\nnetif_err(qdev, drv, qdev->ndev, "IDC Success.\n");\r\nstatus = 0;\r\nbreak;\r\n} else {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"IDC: Invalid State 0x%.04x.\n",\r\nmbcp->mbox_out[0]);\r\nstatus = -EIO;\r\nbreak;\r\n}\r\n} while (wait_time);\r\nreturn status;\r\n}\r\nint ql_mb_set_led_cfg(struct ql_adapter *qdev, u32 led_config)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 2;\r\nmbcp->out_count = 1;\r\nmbcp->mbox_in[0] = MB_CMD_SET_LED_CFG;\r\nmbcp->mbox_in[1] = led_config;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Failed to set LED Configuration.\n");\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nint ql_mb_get_led_cfg(struct ql_adapter *qdev)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 1;\r\nmbcp->out_count = 2;\r\nmbcp->mbox_in[0] = MB_CMD_GET_LED_CFG;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] != MB_CMD_STS_GOOD) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Failed to get LED Configuration.\n");\r\nstatus = -EIO;\r\n} else\r\nqdev->led_config = mbcp->mbox_out[1];\r\nreturn status;\r\n}\r\nint ql_mb_set_mgmnt_traffic_ctl(struct ql_adapter *qdev, u32 control)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->in_count = 1;\r\nmbcp->out_count = 2;\r\nmbcp->mbox_in[0] = MB_CMD_SET_MGMNT_TFK_CTL;\r\nmbcp->mbox_in[1] = control;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] == MB_CMD_STS_GOOD)\r\nreturn status;\r\nif (mbcp->mbox_out[0] == MB_CMD_STS_INVLD_CMD) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Command not supported by firmware.\n");\r\nstatus = -EINVAL;\r\n} else if (mbcp->mbox_out[0] == MB_CMD_STS_ERR) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Command parameters make no change.\n");\r\n}\r\nreturn status;\r\n}\r\nstatic int ql_mb_get_mgmnt_traffic_ctl(struct ql_adapter *qdev, u32 *control)\r\n{\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint status;\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\n*control = 0;\r\nmbcp->in_count = 1;\r\nmbcp->out_count = 1;\r\nmbcp->mbox_in[0] = MB_CMD_GET_MGMNT_TFK_CTL;\r\nstatus = ql_mailbox_command(qdev, mbcp);\r\nif (status)\r\nreturn status;\r\nif (mbcp->mbox_out[0] == MB_CMD_STS_GOOD) {\r\n*control = mbcp->mbox_in[1];\r\nreturn status;\r\n}\r\nif (mbcp->mbox_out[0] == MB_CMD_STS_INVLD_CMD) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Command not supported by firmware.\n");\r\nstatus = -EINVAL;\r\n} else if (mbcp->mbox_out[0] == MB_CMD_STS_ERR) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Failed to get MPI traffic control.\n");\r\nstatus = -EIO;\r\n}\r\nreturn status;\r\n}\r\nint ql_wait_fifo_empty(struct ql_adapter *qdev)\r\n{\r\nint count = 5;\r\nu32 mgmnt_fifo_empty;\r\nu32 nic_fifo_empty;\r\ndo {\r\nnic_fifo_empty = ql_read32(qdev, STS) & STS_NFE;\r\nql_mb_get_mgmnt_traffic_ctl(qdev, &mgmnt_fifo_empty);\r\nmgmnt_fifo_empty &= MB_GET_MPI_TFK_FIFO_EMPTY;\r\nif (nic_fifo_empty && mgmnt_fifo_empty)\r\nreturn 0;\r\nmsleep(100);\r\n} while (count-- > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ql_set_port_cfg(struct ql_adapter *qdev)\r\n{\r\nint status;\r\nstatus = ql_mb_set_port_cfg(qdev);\r\nif (status)\r\nreturn status;\r\nstatus = ql_idc_wait(qdev);\r\nreturn status;\r\n}\r\nvoid ql_mpi_port_cfg_work(struct work_struct *work)\r\n{\r\nstruct ql_adapter *qdev =\r\ncontainer_of(work, struct ql_adapter, mpi_port_cfg_work.work);\r\nint status;\r\nstatus = ql_mb_get_port_cfg(qdev);\r\nif (status) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Bug: Failed to get port config data.\n");\r\ngoto err;\r\n}\r\nif (qdev->link_config & CFG_JUMBO_FRAME_SIZE &&\r\nqdev->max_frame_size ==\r\nCFG_DEFAULT_MAX_FRAME_SIZE)\r\ngoto end;\r\nqdev->link_config |= CFG_JUMBO_FRAME_SIZE;\r\nqdev->max_frame_size = CFG_DEFAULT_MAX_FRAME_SIZE;\r\nstatus = ql_set_port_cfg(qdev);\r\nif (status) {\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Bug: Failed to set port config data.\n");\r\ngoto err;\r\n}\r\nend:\r\nclear_bit(QL_PORT_CFG, &qdev->flags);\r\nreturn;\r\nerr:\r\nql_queue_fw_error(qdev);\r\ngoto end;\r\n}\r\nvoid ql_mpi_idc_work(struct work_struct *work)\r\n{\r\nstruct ql_adapter *qdev =\r\ncontainer_of(work, struct ql_adapter, mpi_idc_work.work);\r\nint status;\r\nstruct mbox_params *mbcp = &qdev->idc_mbc;\r\nu32 aen;\r\nint timeout;\r\naen = mbcp->mbox_out[1] >> 16;\r\ntimeout = (mbcp->mbox_out[1] >> 8) & 0xf;\r\nswitch (aen) {\r\ndefault:\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Bug: Unhandled IDC action.\n");\r\nbreak;\r\ncase MB_CMD_PORT_RESET:\r\ncase MB_CMD_STOP_FW:\r\nql_link_off(qdev);\r\ncase MB_CMD_SET_PORT_CFG:\r\nset_bit(QL_CAM_RT_SET, &qdev->flags);\r\nif (timeout) {\r\nstatus = ql_mb_idc_ack(qdev);\r\nif (status)\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Bug: No pending IDC!\n");\r\n} else {\r\nnetif_printk(qdev, drv, KERN_DEBUG, qdev->ndev,\r\n"IDC ACK not required\n");\r\nstatus = 0;\r\n}\r\nbreak;\r\ncase MB_CMD_IOP_RESTART_MPI:\r\ncase MB_CMD_IOP_PREP_LINK_DOWN:\r\nql_link_off(qdev);\r\nset_bit(QL_CAM_RT_SET, &qdev->flags);\r\ncase MB_CMD_IOP_DVR_START:\r\ncase MB_CMD_IOP_FLASH_ACC:\r\ncase MB_CMD_IOP_CORE_DUMP_MPI:\r\ncase MB_CMD_IOP_PREP_UPDATE_MPI:\r\ncase MB_CMD_IOP_COMP_UPDATE_MPI:\r\ncase MB_CMD_IOP_NONE:\r\nif (timeout) {\r\nstatus = ql_mb_idc_ack(qdev);\r\nif (status)\r\nnetif_err(qdev, drv, qdev->ndev,\r\n"Bug: No pending IDC!\n");\r\n} else {\r\nnetif_printk(qdev, drv, KERN_DEBUG, qdev->ndev,\r\n"IDC ACK not required\n");\r\nstatus = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nvoid ql_mpi_work(struct work_struct *work)\r\n{\r\nstruct ql_adapter *qdev =\r\ncontainer_of(work, struct ql_adapter, mpi_work.work);\r\nstruct mbox_params mbc;\r\nstruct mbox_params *mbcp = &mbc;\r\nint err = 0;\r\nmutex_lock(&qdev->mpi_mutex);\r\nql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));\r\nwhile (ql_read32(qdev, STS) & STS_PI) {\r\nmemset(mbcp, 0, sizeof(struct mbox_params));\r\nmbcp->out_count = 1;\r\nerr = ql_mpi_handler(qdev, mbcp);\r\nif (err)\r\nbreak;\r\n}\r\nql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16) | INTR_MASK_PI);\r\nmutex_unlock(&qdev->mpi_mutex);\r\nql_enable_completion_interrupt(qdev, 0);\r\n}\r\nvoid ql_mpi_reset_work(struct work_struct *work)\r\n{\r\nstruct ql_adapter *qdev =\r\ncontainer_of(work, struct ql_adapter, mpi_reset_work.work);\r\ncancel_delayed_work_sync(&qdev->mpi_work);\r\ncancel_delayed_work_sync(&qdev->mpi_port_cfg_work);\r\ncancel_delayed_work_sync(&qdev->mpi_idc_work);\r\nif (!ql_own_firmware(qdev)) {\r\nnetif_err(qdev, drv, qdev->ndev, "Don't own firmware!\n");\r\nreturn;\r\n}\r\nif (!ql_core_dump(qdev, qdev->mpi_coredump)) {\r\nnetif_err(qdev, drv, qdev->ndev, "Core is dumped!\n");\r\nqdev->core_is_dumped = 1;\r\nqueue_delayed_work(qdev->workqueue,\r\n&qdev->mpi_core_to_log, 5 * HZ);\r\n}\r\nql_soft_reset_mpi_risc(qdev);\r\n}
