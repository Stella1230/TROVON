static int ssctl(void *buffer)\r\n{\r\nint cc;\r\ncc = 1;\r\nasm volatile(\r\n"0: .insn s,0xB2870000,0(%1)\n"\r\n"1: ipm %0\n"\r\n" srl %0,28\n"\r\n"2:\n"\r\nEX_TABLE(0b, 2b) EX_TABLE(1b, 2b)\r\n: "+d" (cc), "+a" (buffer)\r\n: "m" (*((struct hws_ssctl_request_block *)buffer))\r\n: "cc", "memory");\r\nreturn cc ? -EINVAL : 0 ;\r\n}\r\nstatic int qsi(void *buffer)\r\n{\r\nint cc;\r\ncc = 1;\r\nasm volatile(\r\n"0: .insn s,0xB2860000,0(%1)\n"\r\n"1: lhi %0,0\n"\r\n"2:\n"\r\nEX_TABLE(0b, 2b) EX_TABLE(1b, 2b)\r\n: "=d" (cc), "+a" (buffer)\r\n: "m" (*((struct hws_qsi_info_block *)buffer))\r\n: "cc", "memory");\r\nreturn cc ? -EINVAL : 0;\r\n}\r\nstatic void execute_qsi(void *parms)\r\n{\r\nstruct hws_execute_parms *ep = parms;\r\nep->rc = qsi(ep->buffer);\r\n}\r\nstatic void execute_ssctl(void *parms)\r\n{\r\nstruct hws_execute_parms *ep = parms;\r\nep->rc = ssctl(ep->buffer);\r\n}\r\nstatic int smp_ctl_ssctl_stop(int cpu)\r\n{\r\nint rc;\r\nstruct hws_execute_parms ep;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\ncb->ssctl.es = 0;\r\ncb->ssctl.cs = 0;\r\nep.buffer = &cb->ssctl;\r\nsmp_call_function_single(cpu, execute_ssctl, &ep, 1);\r\nrc = ep.rc;\r\nif (rc) {\r\nprintk(KERN_ERR "hwsampler: CPU %d CPUMF SSCTL failed.\n", cpu);\r\ndump_stack();\r\n}\r\nep.buffer = &cb->qsi;\r\nsmp_call_function_single(cpu, execute_qsi, &ep, 1);\r\nif (cb->qsi.es || cb->qsi.cs) {\r\nprintk(KERN_EMERG "CPUMF sampling did not stop properly.\n");\r\ndump_stack();\r\n}\r\nreturn rc;\r\n}\r\nstatic int smp_ctl_ssctl_deactivate(int cpu)\r\n{\r\nint rc;\r\nstruct hws_execute_parms ep;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\ncb->ssctl.es = 1;\r\ncb->ssctl.cs = 0;\r\nep.buffer = &cb->ssctl;\r\nsmp_call_function_single(cpu, execute_ssctl, &ep, 1);\r\nrc = ep.rc;\r\nif (rc)\r\nprintk(KERN_ERR "hwsampler: CPU %d CPUMF SSCTL failed.\n", cpu);\r\nep.buffer = &cb->qsi;\r\nsmp_call_function_single(cpu, execute_qsi, &ep, 1);\r\nif (cb->qsi.cs)\r\nprintk(KERN_EMERG "CPUMF sampling was not set inactive.\n");\r\nreturn rc;\r\n}\r\nstatic int smp_ctl_ssctl_enable_activate(int cpu, unsigned long interval)\r\n{\r\nint rc;\r\nstruct hws_execute_parms ep;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\ncb->ssctl.h = 1;\r\ncb->ssctl.tear = cb->first_sdbt;\r\ncb->ssctl.dear = *(unsigned long *) cb->first_sdbt;\r\ncb->ssctl.interval = interval;\r\ncb->ssctl.es = 1;\r\ncb->ssctl.cs = 1;\r\nep.buffer = &cb->ssctl;\r\nsmp_call_function_single(cpu, execute_ssctl, &ep, 1);\r\nrc = ep.rc;\r\nif (rc)\r\nprintk(KERN_ERR "hwsampler: CPU %d CPUMF SSCTL failed.\n", cpu);\r\nep.buffer = &cb->qsi;\r\nsmp_call_function_single(cpu, execute_qsi, &ep, 1);\r\nif (ep.rc)\r\nprintk(KERN_ERR "hwsampler: CPU %d CPUMF QSI failed.\n", cpu);\r\nreturn rc;\r\n}\r\nstatic int smp_ctl_qsi(int cpu)\r\n{\r\nstruct hws_execute_parms ep;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nep.buffer = &cb->qsi;\r\nsmp_call_function_single(cpu, execute_qsi, &ep, 1);\r\nreturn ep.rc;\r\n}\r\nstatic inline unsigned long *trailer_entry_ptr(unsigned long v)\r\n{\r\nvoid *ret;\r\nret = (void *)v;\r\nret += PAGE_SIZE;\r\nret -= sizeof(struct hws_trailer_entry);\r\nreturn (unsigned long *) ret;\r\n}\r\nstatic void init_all_cpu_buffers(void)\r\n{\r\nint cpu;\r\nstruct hws_cpu_buffer *cb;\r\nfor_each_online_cpu(cpu) {\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nmemset(cb, 0, sizeof(struct hws_cpu_buffer));\r\n}\r\n}\r\nstatic int is_link_entry(unsigned long *s)\r\n{\r\nreturn *s & 0x1ul ? 1 : 0;\r\n}\r\nstatic unsigned long *get_next_sdbt(unsigned long *s)\r\n{\r\nreturn (unsigned long *) (*s & ~0x1ul);\r\n}\r\nstatic int prepare_cpu_buffers(void)\r\n{\r\nint cpu;\r\nint rc;\r\nstruct hws_cpu_buffer *cb;\r\nrc = 0;\r\nfor_each_online_cpu(cpu) {\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\natomic_set(&cb->ext_params, 0);\r\ncb->worker_entry = 0;\r\ncb->sample_overflow = 0;\r\ncb->req_alert = 0;\r\ncb->incorrect_sdbt_entry = 0;\r\ncb->invalid_entry_address = 0;\r\ncb->loss_of_sample_data = 0;\r\ncb->sample_auth_change_alert = 0;\r\ncb->finish = 0;\r\ncb->oom = 0;\r\ncb->stop_mode = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int allocate_sdbt(int cpu)\r\n{\r\nint j, k, rc;\r\nunsigned long *sdbt;\r\nunsigned long sdb;\r\nunsigned long *tail;\r\nunsigned long *trailer;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nif (cb->first_sdbt)\r\nreturn -EINVAL;\r\nsdbt = NULL;\r\ntail = sdbt;\r\nfor (j = 0; j < num_sdbt; j++) {\r\nsdbt = (unsigned long *)get_zeroed_page(GFP_KERNEL);\r\nmutex_lock(&hws_sem_oom);\r\nbarrier();\r\nif (oom_killer_was_active || !sdbt) {\r\nif (sdbt)\r\nfree_page((unsigned long)sdbt);\r\ngoto allocate_sdbt_error;\r\n}\r\nif (cb->first_sdbt == 0)\r\ncb->first_sdbt = (unsigned long)sdbt;\r\nif (tail)\r\n*tail = (unsigned long)(void *)sdbt + 1;\r\nmutex_unlock(&hws_sem_oom);\r\nfor (k = 0; k < num_sdb; k++) {\r\nsdb = get_zeroed_page(GFP_KERNEL);\r\nmutex_lock(&hws_sem_oom);\r\nbarrier();\r\nif (oom_killer_was_active || !sdb) {\r\nif (sdb)\r\nfree_page(sdb);\r\ngoto allocate_sdbt_error;\r\n}\r\n*sdbt = sdb;\r\ntrailer = trailer_entry_ptr(*sdbt);\r\n*trailer = ALERT_REQ_MASK;\r\nsdbt++;\r\nmutex_unlock(&hws_sem_oom);\r\n}\r\ntail = sdbt;\r\n}\r\nmutex_lock(&hws_sem_oom);\r\nif (oom_killer_was_active)\r\ngoto allocate_sdbt_error;\r\nrc = 0;\r\nif (tail)\r\n*tail = (unsigned long)\r\n((void *)cb->first_sdbt) + 1;\r\nallocate_sdbt_exit:\r\nmutex_unlock(&hws_sem_oom);\r\nreturn rc;\r\nallocate_sdbt_error:\r\nrc = -ENOMEM;\r\ngoto allocate_sdbt_exit;\r\n}\r\nstatic int deallocate_sdbt(void)\r\n{\r\nint cpu;\r\nint counter;\r\ncounter = 0;\r\nfor_each_online_cpu(cpu) {\r\nunsigned long start;\r\nunsigned long sdbt;\r\nunsigned long *curr;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nif (!cb->first_sdbt)\r\ncontinue;\r\nsdbt = cb->first_sdbt;\r\ncurr = (unsigned long *) sdbt;\r\nstart = sdbt;\r\nwhile (1) {\r\nif (!*curr || !sdbt)\r\nbreak;\r\nif (is_link_entry(curr)) {\r\ncurr = get_next_sdbt(curr);\r\nif (sdbt)\r\nfree_page(sdbt);\r\nif ((unsigned long) curr == start)\r\nbreak;\r\nelse\r\nsdbt = (unsigned long) curr;\r\n} else {\r\nif (*curr) {\r\nfree_page(*curr);\r\ncurr++;\r\n}\r\n}\r\ncounter++;\r\n}\r\ncb->first_sdbt = 0;\r\n}\r\nreturn counter;\r\n}\r\nstatic int start_sampling(int cpu)\r\n{\r\nint rc;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nrc = smp_ctl_ssctl_enable_activate(cpu, interval);\r\nif (rc) {\r\nprintk(KERN_INFO "hwsampler: CPU %d ssctl failed.\n", cpu);\r\ngoto start_exit;\r\n}\r\nrc = -EINVAL;\r\nif (!cb->qsi.es) {\r\nprintk(KERN_INFO "hwsampler: CPU %d ssctl not enabled.\n", cpu);\r\ngoto start_exit;\r\n}\r\nif (!cb->qsi.cs) {\r\nprintk(KERN_INFO "hwsampler: CPU %d ssctl not active.\n", cpu);\r\ngoto start_exit;\r\n}\r\nprintk(KERN_INFO\r\n"hwsampler: CPU %d, CPUMF Sampling started, interval %lu.\n",\r\ncpu, interval);\r\nrc = 0;\r\nstart_exit:\r\nreturn rc;\r\n}\r\nstatic int stop_sampling(int cpu)\r\n{\r\nunsigned long v;\r\nint rc;\r\nstruct hws_cpu_buffer *cb;\r\nrc = smp_ctl_qsi(cpu);\r\nWARN_ON(rc);\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nif (!rc && !cb->qsi.es)\r\nprintk(KERN_INFO "hwsampler: CPU %d, already stopped.\n", cpu);\r\nrc = smp_ctl_ssctl_stop(cpu);\r\nif (rc) {\r\nprintk(KERN_INFO "hwsampler: CPU %d, ssctl stop error %d.\n",\r\ncpu, rc);\r\ngoto stop_exit;\r\n}\r\nprintk(KERN_INFO "hwsampler: CPU %d, CPUMF Sampling stopped.\n", cpu);\r\nstop_exit:\r\nv = cb->req_alert;\r\nif (v)\r\nprintk(KERN_ERR "hwsampler: CPU %d CPUMF Request alert,"\r\n" count=%lu.\n", cpu, v);\r\nv = cb->loss_of_sample_data;\r\nif (v)\r\nprintk(KERN_ERR "hwsampler: CPU %d CPUMF Loss of sample data,"\r\n" count=%lu.\n", cpu, v);\r\nv = cb->invalid_entry_address;\r\nif (v)\r\nprintk(KERN_ERR "hwsampler: CPU %d CPUMF Invalid entry address,"\r\n" count=%lu.\n", cpu, v);\r\nv = cb->incorrect_sdbt_entry;\r\nif (v)\r\nprintk(KERN_ERR\r\n"hwsampler: CPU %d CPUMF Incorrect SDBT address,"\r\n" count=%lu.\n", cpu, v);\r\nv = cb->sample_auth_change_alert;\r\nif (v)\r\nprintk(KERN_ERR\r\n"hwsampler: CPU %d CPUMF Sample authorization change,"\r\n" count=%lu.\n", cpu, v);\r\nreturn rc;\r\n}\r\nstatic int check_hardware_prerequisites(void)\r\n{\r\nif (!test_facility(68))\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int hws_oom_callback(struct notifier_block *nfb,\r\nunsigned long dummy, void *parm)\r\n{\r\nunsigned long *freed;\r\nint cpu;\r\nstruct hws_cpu_buffer *cb;\r\nfreed = parm;\r\nmutex_lock(&hws_sem_oom);\r\nif (hws_state == HWS_DEALLOCATED) {\r\nif (oom_killer_was_active == 0) {\r\noom_killer_was_active = 1;\r\n*freed += deallocate_sdbt();\r\n}\r\n} else {\r\nint i;\r\ncpu = get_cpu();\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nif (!cb->oom) {\r\nfor_each_online_cpu(i) {\r\nsmp_ctl_ssctl_deactivate(i);\r\ncb->oom = 1;\r\n}\r\ncb->finish = 1;\r\nprintk(KERN_INFO\r\n"hwsampler: CPU %d, OOM notify during CPUMF Sampling.\n",\r\ncpu);\r\n}\r\n}\r\nmutex_unlock(&hws_sem_oom);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int hws_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nreturn (hws_state <= HWS_DEALLOCATED) ? NOTIFY_OK : NOTIFY_BAD;\r\n}\r\nint hwsampler_deactivate(unsigned int cpu)\r\n{\r\nint rc;\r\nstruct hws_cpu_buffer *cb;\r\nrc = 0;\r\nmutex_lock(&hws_sem);\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nif (hws_state == HWS_STARTED) {\r\nrc = smp_ctl_qsi(cpu);\r\nWARN_ON(rc);\r\nif (cb->qsi.cs) {\r\nrc = smp_ctl_ssctl_deactivate(cpu);\r\nif (rc) {\r\nprintk(KERN_INFO\r\n"hwsampler: CPU %d, CPUMF Deactivation failed.\n", cpu);\r\ncb->finish = 1;\r\nhws_state = HWS_STOPPING;\r\n} else {\r\nhws_flush_all = 1;\r\nqueue_work_on(cpu, hws_wq, &cb->worker);\r\n}\r\n}\r\n}\r\nmutex_unlock(&hws_sem);\r\nif (hws_wq)\r\nflush_workqueue(hws_wq);\r\nreturn rc;\r\n}\r\nint hwsampler_activate(unsigned int cpu)\r\n{\r\nint rc;\r\nstruct hws_cpu_buffer *cb;\r\nrc = 0;\r\nmutex_lock(&hws_sem);\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nif (hws_state == HWS_STARTED) {\r\nrc = smp_ctl_qsi(cpu);\r\nWARN_ON(rc);\r\nif (!cb->qsi.cs) {\r\nhws_flush_all = 0;\r\nrc = smp_ctl_ssctl_enable_activate(cpu, interval);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"CPU %d, CPUMF activate sampling failed.\n",\r\ncpu);\r\n}\r\n}\r\n}\r\nmutex_unlock(&hws_sem);\r\nreturn rc;\r\n}\r\nstatic void hws_ext_handler(unsigned int ext_int_code,\r\nunsigned int param32, unsigned long param64)\r\n{\r\nstruct hws_cpu_buffer *cb;\r\nkstat_cpu(smp_processor_id()).irqs[EXTINT_CPM]++;\r\ncb = &__get_cpu_var(sampler_cpu_buffer);\r\natomic_xchg(&cb->ext_params, atomic_read(&cb->ext_params) | param32);\r\nif (hws_wq)\r\nqueue_work(hws_wq, &cb->worker);\r\n}\r\nstatic int check_qsi_on_setup(void)\r\n{\r\nint rc;\r\nunsigned int cpu;\r\nstruct hws_cpu_buffer *cb;\r\nfor_each_online_cpu(cpu) {\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nrc = smp_ctl_qsi(cpu);\r\nWARN_ON(rc);\r\nif (rc)\r\nreturn -EOPNOTSUPP;\r\nif (!cb->qsi.as) {\r\nprintk(KERN_INFO "hwsampler: CPUMF sampling is not authorized.\n");\r\nreturn -EINVAL;\r\n}\r\nif (cb->qsi.es) {\r\nprintk(KERN_WARNING "hwsampler: CPUMF is still enabled.\n");\r\nrc = smp_ctl_ssctl_stop(cpu);\r\nif (rc)\r\nreturn -EINVAL;\r\nprintk(KERN_INFO\r\n"CPU %d, CPUMF Sampling stopped now.\n", cpu);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_qsi_on_start(void)\r\n{\r\nunsigned int cpu;\r\nint rc;\r\nstruct hws_cpu_buffer *cb;\r\nfor_each_online_cpu(cpu) {\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nrc = smp_ctl_qsi(cpu);\r\nWARN_ON(rc);\r\nif (!cb->qsi.as)\r\nreturn -EINVAL;\r\nif (cb->qsi.es)\r\nreturn -EINVAL;\r\nif (cb->qsi.cs)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void worker_on_start(unsigned int cpu)\r\n{\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\ncb->worker_entry = cb->first_sdbt;\r\n}\r\nstatic int worker_check_error(unsigned int cpu, int ext_params)\r\n{\r\nint rc;\r\nunsigned long *sdbt;\r\nstruct hws_cpu_buffer *cb;\r\nrc = 0;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nsdbt = (unsigned long *) cb->worker_entry;\r\nif (!sdbt || !*sdbt)\r\nreturn -EINVAL;\r\nif (ext_params & EI_PRA)\r\ncb->req_alert++;\r\nif (ext_params & EI_LSDA)\r\ncb->loss_of_sample_data++;\r\nif (ext_params & EI_IEA) {\r\ncb->invalid_entry_address++;\r\nrc = -EINVAL;\r\n}\r\nif (ext_params & EI_ISE) {\r\ncb->incorrect_sdbt_entry++;\r\nrc = -EINVAL;\r\n}\r\nif (ext_params & EI_SACA) {\r\ncb->sample_auth_change_alert++;\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic void worker_on_finish(unsigned int cpu)\r\n{\r\nint rc, i;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nif (cb->finish) {\r\nrc = smp_ctl_qsi(cpu);\r\nWARN_ON(rc);\r\nif (cb->qsi.es) {\r\nprintk(KERN_INFO\r\n"hwsampler: CPU %d, CPUMF Stop/Deactivate sampling.\n",\r\ncpu);\r\nrc = smp_ctl_ssctl_stop(cpu);\r\nif (rc)\r\nprintk(KERN_INFO\r\n"hwsampler: CPU %d, CPUMF Deactivation failed.\n",\r\ncpu);\r\nfor_each_online_cpu(i) {\r\nif (i == cpu)\r\ncontinue;\r\nif (!cb->finish) {\r\ncb->finish = 1;\r\nqueue_work_on(i, hws_wq,\r\n&cb->worker);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void worker_on_interrupt(unsigned int cpu)\r\n{\r\nunsigned long *sdbt;\r\nunsigned char done;\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nsdbt = (unsigned long *) cb->worker_entry;\r\ndone = 0;\r\nwhile (!done && !cb->stop_mode) {\r\nunsigned long *trailer;\r\nstruct hws_trailer_entry *te;\r\nunsigned long *dear = 0;\r\ntrailer = trailer_entry_ptr(*sdbt);\r\nif (!(*trailer & BUFFER_FULL_MASK)) {\r\ndone = 1;\r\nif (!hws_flush_all)\r\ncontinue;\r\n}\r\nte = (struct hws_trailer_entry *)trailer;\r\ncb->sample_overflow += te->overflow;\r\nadd_samples_to_oprofile(cpu, sdbt, dear);\r\nxchg((unsigned char *) te, 0x40);\r\nsdbt++;\r\nif (is_link_entry(sdbt))\r\nsdbt = get_next_sdbt(sdbt);\r\ncb->worker_entry = (unsigned long)sdbt;\r\n}\r\n}\r\nstatic void add_samples_to_oprofile(unsigned int cpu, unsigned long *sdbt,\r\nunsigned long *dear)\r\n{\r\nstruct hws_data_entry *sample_data_ptr;\r\nunsigned long *trailer;\r\ntrailer = trailer_entry_ptr(*sdbt);\r\nif (dear) {\r\nif (dear > trailer)\r\nreturn;\r\ntrailer = dear;\r\n}\r\nsample_data_ptr = (struct hws_data_entry *)(*sdbt);\r\nwhile ((unsigned long *)sample_data_ptr < trailer) {\r\nstruct pt_regs *regs = NULL;\r\nstruct task_struct *tsk = NULL;\r\nif (sample_data_ptr->def != 1) {\r\nbreak;\r\n} else {\r\nsample_data_ptr->def = 0;\r\n}\r\nif (sample_data_ptr->P == 1) {\r\nunsigned int pid = sample_data_ptr->prim_asn;\r\nrcu_read_lock();\r\ntsk = pid_task(find_vpid(pid), PIDTYPE_PID);\r\nif (tsk)\r\nregs = task_pt_regs(tsk);\r\nrcu_read_unlock();\r\n} else {\r\nregs = task_pt_regs(current);\r\n}\r\nmutex_lock(&hws_sem);\r\noprofile_add_ext_hw_sample(sample_data_ptr->ia, regs, 0,\r\n!sample_data_ptr->P, tsk);\r\nmutex_unlock(&hws_sem);\r\nsample_data_ptr++;\r\n}\r\n}\r\nstatic void worker(struct work_struct *work)\r\n{\r\nunsigned int cpu;\r\nint ext_params;\r\nstruct hws_cpu_buffer *cb;\r\ncb = container_of(work, struct hws_cpu_buffer, worker);\r\ncpu = smp_processor_id();\r\next_params = atomic_xchg(&cb->ext_params, 0);\r\nif (!cb->worker_entry)\r\nworker_on_start(cpu);\r\nif (worker_check_error(cpu, ext_params))\r\nreturn;\r\nif (!cb->finish)\r\nworker_on_interrupt(cpu);\r\nif (cb->finish)\r\nworker_on_finish(cpu);\r\n}\r\nint hwsampler_allocate(unsigned long sdbt, unsigned long sdb)\r\n{\r\nint cpu, rc;\r\nmutex_lock(&hws_sem);\r\nrc = -EINVAL;\r\nif (hws_state != HWS_DEALLOCATED)\r\ngoto allocate_exit;\r\nif (sdbt < 1)\r\ngoto allocate_exit;\r\nif (sdb > MAX_NUM_SDB || sdb < MIN_NUM_SDB)\r\ngoto allocate_exit;\r\nnum_sdbt = sdbt;\r\nnum_sdb = sdb;\r\noom_killer_was_active = 0;\r\nregister_oom_notifier(&hws_oom_notifier);\r\nfor_each_online_cpu(cpu) {\r\nif (allocate_sdbt(cpu)) {\r\nunregister_oom_notifier(&hws_oom_notifier);\r\ngoto allocate_error;\r\n}\r\n}\r\nunregister_oom_notifier(&hws_oom_notifier);\r\nif (oom_killer_was_active)\r\ngoto allocate_error;\r\nhws_state = HWS_STOPPED;\r\nrc = 0;\r\nallocate_exit:\r\nmutex_unlock(&hws_sem);\r\nreturn rc;\r\nallocate_error:\r\nrc = -ENOMEM;\r\nprintk(KERN_ERR "hwsampler: CPUMF Memory allocation failed.\n");\r\ngoto allocate_exit;\r\n}\r\nint hwsampler_deallocate()\r\n{\r\nint rc;\r\nmutex_lock(&hws_sem);\r\nrc = -EINVAL;\r\nif (hws_state != HWS_STOPPED)\r\ngoto deallocate_exit;\r\nctl_clear_bit(0, 5);\r\ndeallocate_sdbt();\r\nhws_state = HWS_DEALLOCATED;\r\nrc = 0;\r\ndeallocate_exit:\r\nmutex_unlock(&hws_sem);\r\nreturn rc;\r\n}\r\nunsigned long hwsampler_query_min_interval(void)\r\n{\r\nreturn min_sampler_rate;\r\n}\r\nunsigned long hwsampler_query_max_interval(void)\r\n{\r\nreturn max_sampler_rate;\r\n}\r\nunsigned long hwsampler_get_sample_overflow_count(unsigned int cpu)\r\n{\r\nstruct hws_cpu_buffer *cb;\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nreturn cb->sample_overflow;\r\n}\r\nint hwsampler_setup()\r\n{\r\nint rc;\r\nint cpu;\r\nstruct hws_cpu_buffer *cb;\r\nmutex_lock(&hws_sem);\r\nrc = -EINVAL;\r\nif (hws_state)\r\ngoto setup_exit;\r\nhws_state = HWS_INIT;\r\ninit_all_cpu_buffers();\r\nrc = check_hardware_prerequisites();\r\nif (rc)\r\ngoto setup_exit;\r\nrc = check_qsi_on_setup();\r\nif (rc)\r\ngoto setup_exit;\r\nrc = -EINVAL;\r\nhws_wq = create_workqueue("hwsampler");\r\nif (!hws_wq)\r\ngoto setup_exit;\r\nregister_cpu_notifier(&hws_cpu_notifier);\r\nfor_each_online_cpu(cpu) {\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\nINIT_WORK(&cb->worker, worker);\r\nrc = smp_ctl_qsi(cpu);\r\nWARN_ON(rc);\r\nif (min_sampler_rate != cb->qsi.min_sampl_rate) {\r\nif (min_sampler_rate) {\r\nprintk(KERN_WARNING\r\n"hwsampler: different min sampler rate values.\n");\r\nif (min_sampler_rate < cb->qsi.min_sampl_rate)\r\nmin_sampler_rate =\r\ncb->qsi.min_sampl_rate;\r\n} else\r\nmin_sampler_rate = cb->qsi.min_sampl_rate;\r\n}\r\nif (max_sampler_rate != cb->qsi.max_sampl_rate) {\r\nif (max_sampler_rate) {\r\nprintk(KERN_WARNING\r\n"hwsampler: different max sampler rate values.\n");\r\nif (max_sampler_rate > cb->qsi.max_sampl_rate)\r\nmax_sampler_rate =\r\ncb->qsi.max_sampl_rate;\r\n} else\r\nmax_sampler_rate = cb->qsi.max_sampl_rate;\r\n}\r\n}\r\nregister_external_interrupt(0x1407, hws_ext_handler);\r\nhws_state = HWS_DEALLOCATED;\r\nrc = 0;\r\nsetup_exit:\r\nmutex_unlock(&hws_sem);\r\nreturn rc;\r\n}\r\nint hwsampler_shutdown()\r\n{\r\nint rc;\r\nmutex_lock(&hws_sem);\r\nrc = -EINVAL;\r\nif (hws_state == HWS_DEALLOCATED || hws_state == HWS_STOPPED) {\r\nmutex_unlock(&hws_sem);\r\nif (hws_wq)\r\nflush_workqueue(hws_wq);\r\nmutex_lock(&hws_sem);\r\nif (hws_state == HWS_STOPPED) {\r\nctl_clear_bit(0, 5);\r\ndeallocate_sdbt();\r\n}\r\nif (hws_wq) {\r\ndestroy_workqueue(hws_wq);\r\nhws_wq = NULL;\r\n}\r\nunregister_external_interrupt(0x1407, hws_ext_handler);\r\nhws_state = HWS_INIT;\r\nrc = 0;\r\n}\r\nmutex_unlock(&hws_sem);\r\nunregister_cpu_notifier(&hws_cpu_notifier);\r\nreturn rc;\r\n}\r\nint hwsampler_start_all(unsigned long rate)\r\n{\r\nint rc, cpu;\r\nmutex_lock(&hws_sem);\r\nhws_oom = 0;\r\nrc = -EINVAL;\r\nif (hws_state != HWS_STOPPED)\r\ngoto start_all_exit;\r\ninterval = rate;\r\nif (interval < min_sampler_rate || interval > max_sampler_rate)\r\ngoto start_all_exit;\r\nrc = check_qsi_on_start();\r\nif (rc)\r\ngoto start_all_exit;\r\nrc = prepare_cpu_buffers();\r\nif (rc)\r\ngoto start_all_exit;\r\nfor_each_online_cpu(cpu) {\r\nrc = start_sampling(cpu);\r\nif (rc)\r\nbreak;\r\n}\r\nif (rc) {\r\nfor_each_online_cpu(cpu) {\r\nstop_sampling(cpu);\r\n}\r\ngoto start_all_exit;\r\n}\r\nhws_state = HWS_STARTED;\r\nrc = 0;\r\nstart_all_exit:\r\nmutex_unlock(&hws_sem);\r\nif (rc)\r\nreturn rc;\r\nregister_oom_notifier(&hws_oom_notifier);\r\nhws_oom = 1;\r\nhws_flush_all = 0;\r\nctl_set_bit(0, 5);\r\nreturn 0;\r\n}\r\nint hwsampler_stop_all()\r\n{\r\nint tmp_rc, rc, cpu;\r\nstruct hws_cpu_buffer *cb;\r\nmutex_lock(&hws_sem);\r\nrc = 0;\r\nif (hws_state == HWS_INIT) {\r\nmutex_unlock(&hws_sem);\r\nreturn rc;\r\n}\r\nhws_state = HWS_STOPPING;\r\nmutex_unlock(&hws_sem);\r\nfor_each_online_cpu(cpu) {\r\ncb = &per_cpu(sampler_cpu_buffer, cpu);\r\ncb->stop_mode = 1;\r\ntmp_rc = stop_sampling(cpu);\r\nif (tmp_rc)\r\nrc = tmp_rc;\r\n}\r\nif (hws_wq)\r\nflush_workqueue(hws_wq);\r\nmutex_lock(&hws_sem);\r\nif (hws_oom) {\r\nunregister_oom_notifier(&hws_oom_notifier);\r\nhws_oom = 0;\r\n}\r\nhws_state = HWS_STOPPED;\r\nmutex_unlock(&hws_sem);\r\nreturn rc;\r\n}
