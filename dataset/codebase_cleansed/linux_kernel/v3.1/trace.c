void decode_address(char *buf, unsigned long address)\r\n{\r\nstruct task_struct *p;\r\nstruct mm_struct *mm;\r\nunsigned long flags, offset;\r\nunsigned char in_atomic = (bfin_read_IPEND() & 0x10) || in_atomic();\r\nstruct rb_node *n;\r\n#ifdef CONFIG_KALLSYMS\r\nunsigned long symsize;\r\nconst char *symname;\r\nchar *modname;\r\nchar *delim = ":";\r\nchar namebuf[128];\r\n#endif\r\nbuf += sprintf(buf, "<0x%08lx> ", address);\r\n#ifdef CONFIG_KALLSYMS\r\nsymname = kallsyms_lookup(address, &symsize, &offset, &modname, namebuf);\r\nif (symname) {\r\nif (!modname)\r\nmodname = delim = "";\r\nsprintf(buf, "{ %s%s%s%s + 0x%lx }",\r\ndelim, modname, delim, symname,\r\n(unsigned long)offset);\r\nreturn;\r\n}\r\n#endif\r\nif (address >= FIXED_CODE_START && address < FIXED_CODE_END) {\r\nstrcat(buf, "/* Maybe fixed code section */");\r\nreturn;\r\n} else if (address < CONFIG_BOOT_LOAD) {\r\nstrcat(buf, "/* Maybe null pointer? */");\r\nreturn;\r\n} else if (address >= COREMMR_BASE) {\r\nstrcat(buf, "/* core mmrs */");\r\nreturn;\r\n} else if (address >= SYSMMR_BASE) {\r\nstrcat(buf, "/* system mmrs */");\r\nreturn;\r\n} else if (address >= L1_ROM_START && address < L1_ROM_START + L1_ROM_LENGTH) {\r\nstrcat(buf, "/* on-chip L1 ROM */");\r\nreturn;\r\n} else if (address >= L1_SCRATCH_START && address < L1_SCRATCH_START + L1_SCRATCH_LENGTH) {\r\nstrcat(buf, "/* on-chip scratchpad */");\r\nreturn;\r\n} else if (address >= physical_mem_end && address < ASYNC_BANK0_BASE) {\r\nstrcat(buf, "/* unconnected memory */");\r\nreturn;\r\n} else if (address >= ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE && address < BOOT_ROM_START) {\r\nstrcat(buf, "/* reserved memory */");\r\nreturn;\r\n} else if (address >= L1_DATA_A_START && address < L1_DATA_A_START + L1_DATA_A_LENGTH) {\r\nstrcat(buf, "/* on-chip Data Bank A */");\r\nreturn;\r\n} else if (address >= L1_DATA_B_START && address < L1_DATA_B_START + L1_DATA_B_LENGTH) {\r\nstrcat(buf, "/* on-chip Data Bank B */");\r\nreturn;\r\n}\r\nif (oops_in_progress) {\r\nstrcat(buf, "/* kernel dynamic memory (maybe user-space) */");\r\nreturn;\r\n}\r\nwrite_lock_irqsave(&tasklist_lock, flags);\r\nfor_each_process(p) {\r\nmm = (in_atomic ? p->mm : get_task_mm(p));\r\nif (!mm)\r\ncontinue;\r\nif (!down_read_trylock(&mm->mmap_sem)) {\r\nif (!in_atomic)\r\nmmput(mm);\r\ncontinue;\r\n}\r\nfor (n = rb_first(&mm->mm_rb); n; n = rb_next(n)) {\r\nstruct vm_area_struct *vma;\r\nvma = rb_entry(n, struct vm_area_struct, vm_rb);\r\nif (address >= vma->vm_start && address < vma->vm_end) {\r\nchar _tmpbuf[256];\r\nchar *name = p->comm;\r\nstruct file *file = vma->vm_file;\r\nif (file) {\r\nchar *d_name = d_path(&file->f_path, _tmpbuf,\r\nsizeof(_tmpbuf));\r\nif (!IS_ERR(d_name))\r\nname = d_name;\r\n}\r\nif ((unsigned long)current >= FIXED_CODE_START &&\r\n!((unsigned long)current & 0x3)) {\r\nif (current->mm &&\r\n(address > current->mm->start_code) &&\r\n(address < current->mm->end_code))\r\noffset = address - current->mm->start_code;\r\nelse\r\noffset = (address - vma->vm_start) +\r\n(vma->vm_pgoff << PAGE_SHIFT);\r\nsprintf(buf, "[ %s + 0x%lx ]", name, offset);\r\n} else\r\nsprintf(buf, "[ %s vma:0x%lx-0x%lx]",\r\nname, vma->vm_start, vma->vm_end);\r\nup_read(&mm->mmap_sem);\r\nif (!in_atomic)\r\nmmput(mm);\r\nif (buf[0] == '\0')\r\nsprintf(buf, "[ %s ] dynamic memory", name);\r\ngoto done;\r\n}\r\n}\r\nup_read(&mm->mmap_sem);\r\nif (!in_atomic)\r\nmmput(mm);\r\n}\r\nsprintf(buf, "/* kernel dynamic memory */");\r\ndone:\r\nwrite_unlock_irqrestore(&tasklist_lock, flags);\r\n}\r\nbool get_mem16(unsigned short *val, unsigned short *address)\r\n{\r\nunsigned long addr = (unsigned long)address;\r\nif (addr & 0x1)\r\nreturn false;\r\nswitch (bfin_mem_access_type(addr, 2)) {\r\ncase BFIN_MEM_ACCESS_CORE:\r\ncase BFIN_MEM_ACCESS_CORE_ONLY:\r\n*val = *address;\r\nreturn true;\r\ncase BFIN_MEM_ACCESS_DMA:\r\ndma_memcpy(val, address, 2);\r\nreturn true;\r\ncase BFIN_MEM_ACCESS_ITEST:\r\nisram_memcpy(val, address, 2);\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nbool get_instruction(unsigned int *val, unsigned short *address)\r\n{\r\nunsigned long addr = (unsigned long)address;\r\nunsigned short opcode0, opcode1;\r\nif (addr & 0x1)\r\nreturn false;\r\nif (addr >= SYSMMR_BASE)\r\nreturn false;\r\nif (addr >= L1_SCRATCH_START && addr < L1_SCRATCH_START + L1_SCRATCH_LENGTH)\r\nreturn false;\r\nif (addr >= BOOT_ROM_START + BOOT_ROM_LENGTH && addr < L1_CODE_START)\r\nreturn false;\r\nif (!get_mem16(&opcode0, address))\r\nreturn false;\r\nif ((opcode0 & 0xc000) == 0xc000) {\r\nif (!get_mem16(&opcode1, address + 1))\r\nreturn false;\r\n*val = (opcode0 << 16) + opcode1;\r\n} else\r\n*val = opcode0;\r\nreturn true;\r\n}\r\nstatic void decode_ProgCtrl_0(unsigned int opcode)\r\n{\r\nint poprnd = ((opcode >> ProgCtrl_poprnd_bits) & ProgCtrl_poprnd_mask);\r\nint prgfunc = ((opcode >> ProgCtrl_prgfunc_bits) & ProgCtrl_prgfunc_mask);\r\nif (prgfunc == 0 && poprnd == 0)\r\npr_cont("NOP");\r\nelse if (prgfunc == 1 && poprnd == 0)\r\npr_cont("RTS");\r\nelse if (prgfunc == 1 && poprnd == 1)\r\npr_cont("RTI");\r\nelse if (prgfunc == 1 && poprnd == 2)\r\npr_cont("RTX");\r\nelse if (prgfunc == 1 && poprnd == 3)\r\npr_cont("RTN");\r\nelse if (prgfunc == 1 && poprnd == 4)\r\npr_cont("RTE");\r\nelse if (prgfunc == 2 && poprnd == 0)\r\npr_cont("IDLE");\r\nelse if (prgfunc == 2 && poprnd == 3)\r\npr_cont("CSYNC");\r\nelse if (prgfunc == 2 && poprnd == 4)\r\npr_cont("SSYNC");\r\nelse if (prgfunc == 2 && poprnd == 5)\r\npr_cont("EMUEXCPT");\r\nelse if (prgfunc == 3)\r\npr_cont("CLI R%i", poprnd);\r\nelse if (prgfunc == 4)\r\npr_cont("STI R%i", poprnd);\r\nelse if (prgfunc == 5)\r\npr_cont("JUMP (P%i)", poprnd);\r\nelse if (prgfunc == 6)\r\npr_cont("CALL (P%i)", poprnd);\r\nelse if (prgfunc == 7)\r\npr_cont("CALL (PC + P%i)", poprnd);\r\nelse if (prgfunc == 8)\r\npr_cont("JUMP (PC + P%i", poprnd);\r\nelse if (prgfunc == 9)\r\npr_cont("RAISE %i", poprnd);\r\nelse if (prgfunc == 10)\r\npr_cont("EXCPT %i", poprnd);\r\nelse\r\npr_cont("0x%04x", opcode);\r\n}\r\nstatic void decode_BRCC_0(unsigned int opcode)\r\n{\r\nint B = ((opcode >> BRCC_B_bits) & BRCC_B_mask);\r\nint T = ((opcode >> BRCC_T_bits) & BRCC_T_mask);\r\npr_cont("IF %sCC JUMP pcrel %s", T ? "" : "!", B ? "(BP)" : "");\r\n}\r\nstatic void decode_CALLa_0(unsigned int opcode)\r\n{\r\nint S = ((opcode >> (CALLa_S_bits - 16)) & CALLa_S_mask);\r\nif (S)\r\npr_cont("CALL pcrel");\r\nelse\r\npr_cont("JUMP.L");\r\n}\r\nstatic void decode_LoopSetup_0(unsigned int opcode)\r\n{\r\nint c = ((opcode >> LoopSetup_c_bits) & LoopSetup_c_mask);\r\nint reg = ((opcode >> LoopSetup_reg_bits) & LoopSetup_reg_mask);\r\nint rop = ((opcode >> LoopSetup_rop_bits) & LoopSetup_rop_mask);\r\npr_cont("LSETUP <> LC%i", c);\r\nif ((rop & 1) == 1)\r\npr_cont("= P%i", reg);\r\nif ((rop & 2) == 2)\r\npr_cont(" >> 0x1");\r\n}\r\nstatic void decode_dspLDST_0(unsigned int opcode)\r\n{\r\nint i = ((opcode >> DspLDST_i_bits) & DspLDST_i_mask);\r\nint m = ((opcode >> DspLDST_m_bits) & DspLDST_m_mask);\r\nint W = ((opcode >> DspLDST_W_bits) & DspLDST_W_mask);\r\nint aop = ((opcode >> DspLDST_aop_bits) & DspLDST_aop_mask);\r\nint reg = ((opcode >> DspLDST_reg_bits) & DspLDST_reg_mask);\r\nif (W == 0) {\r\npr_cont("R%i", reg);\r\nswitch (m) {\r\ncase 0:\r\npr_cont(" = ");\r\nbreak;\r\ncase 1:\r\npr_cont(".L = ");\r\nbreak;\r\ncase 2:\r\npr_cont(".W = ");\r\nbreak;\r\n}\r\n}\r\npr_cont("[ I%i", i);\r\nswitch (aop) {\r\ncase 0:\r\npr_cont("++ ]");\r\nbreak;\r\ncase 1:\r\npr_cont("-- ]");\r\nbreak;\r\n}\r\nif (W == 1) {\r\npr_cont(" = R%i", reg);\r\nswitch (m) {\r\ncase 1:\r\npr_cont(".L = ");\r\nbreak;\r\ncase 2:\r\npr_cont(".W = ");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void decode_LDST_0(unsigned int opcode)\r\n{\r\nint Z = ((opcode >> LDST_Z_bits) & LDST_Z_mask);\r\nint W = ((opcode >> LDST_W_bits) & LDST_W_mask);\r\nint sz = ((opcode >> LDST_sz_bits) & LDST_sz_mask);\r\nint aop = ((opcode >> LDST_aop_bits) & LDST_aop_mask);\r\nint reg = ((opcode >> LDST_reg_bits) & LDST_reg_mask);\r\nint ptr = ((opcode >> LDST_ptr_bits) & LDST_ptr_mask);\r\nif (W == 0)\r\npr_cont("%s%i = ", (sz == 0 && Z == 1) ? "P" : "R", reg);\r\nswitch (sz) {\r\ncase 1:\r\npr_cont("W");\r\nbreak;\r\ncase 2:\r\npr_cont("B");\r\nbreak;\r\n}\r\npr_cont("[P%i", ptr);\r\nswitch (aop) {\r\ncase 0:\r\npr_cont("++");\r\nbreak;\r\ncase 1:\r\npr_cont("--");\r\nbreak;\r\n}\r\npr_cont("]");\r\nif (W == 1)\r\npr_cont(" = %s%i ", (sz == 0 && Z == 1) ? "P" : "R", reg);\r\nif (sz) {\r\nif (Z)\r\npr_cont(" (X)");\r\nelse\r\npr_cont(" (Z)");\r\n}\r\n}\r\nstatic void decode_LDSTii_0(unsigned int opcode)\r\n{\r\nint reg = ((opcode >> LDSTii_reg_bit) & LDSTii_reg_mask);\r\nint ptr = ((opcode >> LDSTii_ptr_bit) & LDSTii_ptr_mask);\r\nint offset = ((opcode >> LDSTii_offset_bit) & LDSTii_offset_mask);\r\nint op = ((opcode >> LDSTii_op_bit) & LDSTii_op_mask);\r\nint W = ((opcode >> LDSTii_W_bit) & LDSTii_W_mask);\r\nif (W == 0) {\r\npr_cont("%s%i = %s[P%i + %i]", op == 3 ? "R" : "P", reg,\r\nop == 1 || op == 2 ? "" : "W", ptr, offset);\r\nif (op == 2)\r\npr_cont("(Z)");\r\nif (op == 3)\r\npr_cont("(X)");\r\n} else {\r\npr_cont("%s[P%i + %i] = %s%i", op == 0 ? "" : "W", ptr,\r\noffset, op == 3 ? "P" : "R", reg);\r\n}\r\n}\r\nstatic void decode_LDSTidxI_0(unsigned int opcode)\r\n{\r\nint Z = ((opcode >> LDSTidxI_Z_bits) & LDSTidxI_Z_mask);\r\nint W = ((opcode >> LDSTidxI_W_bits) & LDSTidxI_W_mask);\r\nint sz = ((opcode >> LDSTidxI_sz_bits) & LDSTidxI_sz_mask);\r\nint reg = ((opcode >> LDSTidxI_reg_bits) & LDSTidxI_reg_mask);\r\nint ptr = ((opcode >> LDSTidxI_ptr_bits) & LDSTidxI_ptr_mask);\r\nint offset = ((opcode >> LDSTidxI_offset_bits) & LDSTidxI_offset_mask);\r\nif (W == 0)\r\npr_cont("%s%i = ", sz == 0 && Z == 1 ? "P" : "R", reg);\r\nif (sz == 1)\r\npr_cont("W");\r\nif (sz == 2)\r\npr_cont("B");\r\npr_cont("[P%i + %s0x%x]", ptr, offset & 0x20 ? "-" : "",\r\n(offset & 0x1f) << 2);\r\nif (W == 0 && sz != 0) {\r\nif (Z)\r\npr_cont("(X)");\r\nelse\r\npr_cont("(Z)");\r\n}\r\nif (W == 1)\r\npr_cont("= %s%i", (sz == 0 && Z == 1) ? "P" : "R", reg);\r\n}\r\nstatic void decode_opcode(unsigned int opcode)\r\n{\r\n#ifdef CONFIG_BUG\r\nif (opcode == BFIN_BUG_OPCODE)\r\npr_cont("BUG");\r\nelse\r\n#endif\r\nif ((opcode & 0xffffff00) == ProgCtrl_opcode)\r\ndecode_ProgCtrl_0(opcode);\r\nelse if ((opcode & 0xfffff000) == BRCC_opcode)\r\ndecode_BRCC_0(opcode);\r\nelse if ((opcode & 0xfffff000) == 0x2000)\r\npr_cont("JUMP.S");\r\nelse if ((opcode & 0xfe000000) == CALLa_opcode)\r\ndecode_CALLa_0(opcode);\r\nelse if ((opcode & 0xff8000C0) == LoopSetup_opcode)\r\ndecode_LoopSetup_0(opcode);\r\nelse if ((opcode & 0xfffffc00) == DspLDST_opcode)\r\ndecode_dspLDST_0(opcode);\r\nelse if ((opcode & 0xfffff000) == LDST_opcode)\r\ndecode_LDST_0(opcode);\r\nelse if ((opcode & 0xffffe000) == LDSTii_opcode)\r\ndecode_LDSTii_0(opcode);\r\nelse if ((opcode & 0xfc000000) == LDSTidxI_opcode)\r\ndecode_LDSTidxI_0(opcode);\r\nelse if (opcode & 0xffff0000)\r\npr_cont("0x%08x", opcode);\r\nelse\r\npr_cont("0x%04x", opcode);\r\n}\r\nstatic void decode_instruction(unsigned short *address)\r\n{\r\nunsigned int opcode;\r\nif (!get_instruction(&opcode, address))\r\nreturn;\r\ndecode_opcode(opcode);\r\nif ((opcode & 0xc0000000) == 0xc0000000 &&\r\n(opcode & BIT_MULTI_INS) &&\r\n(opcode & 0xe8000000) != 0xe8000000) {\r\npr_cont(" || ");\r\nif (!get_instruction(&opcode, address + 2))\r\nreturn;\r\ndecode_opcode(opcode);\r\npr_cont(" || ");\r\nif (!get_instruction(&opcode, address + 3))\r\nreturn;\r\ndecode_opcode(opcode);\r\n}\r\n}\r\nvoid dump_bfin_trace_buffer(void)\r\n{\r\n#ifdef CONFIG_DEBUG_BFIN_HWTRACE_ON\r\nint tflags, i = 0, fault = 0;\r\nchar buf[150];\r\nunsigned short *addr;\r\nunsigned int cpu = raw_smp_processor_id();\r\n#ifdef CONFIG_DEBUG_BFIN_HWTRACE_EXPAND\r\nint j, index;\r\n#endif\r\ntrace_buffer_save(tflags);\r\npr_notice("Hardware Trace:\n");\r\n#ifdef CONFIG_DEBUG_BFIN_HWTRACE_EXPAND\r\npr_notice("WARNING: Expanded trace turned on - can not trace exceptions\n");\r\n#endif\r\nif (likely(bfin_read_TBUFSTAT() & TBUFCNT)) {\r\nfor (; bfin_read_TBUFSTAT() & TBUFCNT; i++) {\r\naddr = (unsigned short *)bfin_read_TBUF();\r\ndecode_address(buf, (unsigned long)addr);\r\npr_notice("%4i Target : %s\n", i, buf);\r\nif (!fault && addr == ((unsigned short *)evt_ivhw)) {\r\naddr = (unsigned short *)bfin_read_TBUF();\r\ndecode_address(buf, (unsigned long)addr);\r\npr_notice(" FAULT : %s ", buf);\r\ndecode_instruction(addr);\r\npr_cont("\n");\r\nfault = 1;\r\ncontinue;\r\n}\r\nif (!fault && addr == (unsigned short *)trap &&\r\n(cpu_pda[cpu].seqstat & SEQSTAT_EXCAUSE) > VEC_EXCPT15) {\r\ndecode_address(buf, cpu_pda[cpu].icplb_fault_addr);\r\npr_notice(" FAULT : %s ", buf);\r\ndecode_instruction((unsigned short *)cpu_pda[cpu].icplb_fault_addr);\r\npr_cont("\n");\r\nfault = 1;\r\n}\r\naddr = (unsigned short *)bfin_read_TBUF();\r\ndecode_address(buf, (unsigned long)addr);\r\npr_notice(" Source : %s ", buf);\r\ndecode_instruction(addr);\r\npr_cont("\n");\r\n}\r\n}\r\n#ifdef CONFIG_DEBUG_BFIN_HWTRACE_EXPAND\r\nif (trace_buff_offset)\r\nindex = trace_buff_offset / 4;\r\nelse\r\nindex = EXPAND_LEN;\r\nj = (1 << CONFIG_DEBUG_BFIN_HWTRACE_EXPAND_LEN) * 128;\r\nwhile (j) {\r\ndecode_address(buf, software_trace_buff[index]);\r\npr_notice("%4i Target : %s\n", i, buf);\r\nindex -= 1;\r\nif (index < 0)\r\nindex = EXPAND_LEN;\r\ndecode_address(buf, software_trace_buff[index]);\r\npr_notice(" Source : %s ", buf);\r\ndecode_instruction((unsigned short *)software_trace_buff[index]);\r\npr_cont("\n");\r\nindex -= 1;\r\nif (index < 0)\r\nindex = EXPAND_LEN;\r\nj--;\r\ni++;\r\n}\r\n#endif\r\ntrace_buffer_restore(tflags);\r\n#endif\r\n}\r\nvoid dump_bfin_process(struct pt_regs *fp)\r\n{\r\nunsigned int context = bfin_read_IPEND();\r\nif (oops_in_progress)\r\npr_emerg("Kernel OOPS in progress\n");\r\nif (context & 0x0020 && (fp->seqstat & SEQSTAT_EXCAUSE) == VEC_HWERR)\r\npr_notice("HW Error context\n");\r\nelse if (context & 0x0020)\r\npr_notice("Deferred Exception context\n");\r\nelse if (context & 0x3FC0)\r\npr_notice("Interrupt context\n");\r\nelse if (context & 0x4000)\r\npr_notice("Deferred Interrupt context\n");\r\nelse if (context & 0x8000)\r\npr_notice("Kernel process context\n");\r\nif ((unsigned long)current >= FIXED_CODE_START &&\r\n!((unsigned long)current & 0x3) && current->pid) {\r\npr_notice("CURRENT PROCESS:\n");\r\nif (current->comm >= (char *)FIXED_CODE_START)\r\npr_notice("COMM=%s PID=%d",\r\ncurrent->comm, current->pid);\r\nelse\r\npr_notice("COMM= invalid");\r\npr_cont(" CPU=%d\n", current_thread_info()->cpu);\r\nif (!((unsigned long)current->mm & 0x3) &&\r\n(unsigned long)current->mm >= FIXED_CODE_START) {\r\npr_notice("TEXT = 0x%p-0x%p DATA = 0x%p-0x%p\n",\r\n(void *)current->mm->start_code,\r\n(void *)current->mm->end_code,\r\n(void *)current->mm->start_data,\r\n(void *)current->mm->end_data);\r\npr_notice(" BSS = 0x%p-0x%p USER-STACK = 0x%p\n\n",\r\n(void *)current->mm->end_data,\r\n(void *)current->mm->brk,\r\n(void *)current->mm->start_stack);\r\n} else\r\npr_notice("invalid mm\n");\r\n} else\r\npr_notice("No Valid process in current context\n");\r\n}\r\nvoid dump_bfin_mem(struct pt_regs *fp)\r\n{\r\nunsigned short *addr, *erraddr, val = 0, err = 0;\r\nchar sti = 0, buf[6];\r\nerraddr = (void *)fp->pc;\r\npr_notice("return address: [0x%p]; contents of:", erraddr);\r\nfor (addr = (unsigned short *)((unsigned long)erraddr & ~0xF) - 0x10;\r\naddr < (unsigned short *)((unsigned long)erraddr & ~0xF) + 0x10;\r\naddr++) {\r\nif (!((unsigned long)addr & 0xF))\r\npr_notice("0x%p: ", addr);\r\nif (!get_mem16(&val, addr)) {\r\nval = 0;\r\nsprintf(buf, "????");\r\n} else\r\nsprintf(buf, "%04x", val);\r\nif (addr == erraddr) {\r\npr_cont("[%s]", buf);\r\nerr = val;\r\n} else\r\npr_cont(" %s ", buf);\r\nif (addr <= erraddr &&\r\n((val >= 0x0040 && val <= 0x0047) ||\r\nval == 0x017b))\r\nsti = 1;\r\n}\r\npr_cont("\n");\r\nif (unlikely(sti && (fp->seqstat & SEQSTAT_EXCAUSE) == VEC_HWERR &&\r\noops_in_progress)){\r\npr_notice("Looks like this was a deferred error - sorry\n");\r\n#ifndef CONFIG_DEBUG_HWERR\r\npr_notice("The remaining message may be meaningless\n");\r\npr_notice("You should enable CONFIG_DEBUG_HWERR to get a better idea where it came from\n");\r\n#else\r\nif ((!(((fp)->ipend & ~0x30) & (((fp)->ipend & ~0x30) - 1))) &&\r\n(current->pid && current->mm)) {\r\nif ((fp + 1)->pc >= current->mm->start_code &&\r\n(fp + 1)->pc <= current->mm->end_code) {\r\npr_notice("It might be better to look around here :\n");\r\npr_notice("-------------------------------------------\n");\r\nshow_regs(fp + 1);\r\npr_notice("-------------------------------------------\n");\r\n}\r\n}\r\n#endif\r\n}\r\n}\r\nvoid show_regs(struct pt_regs *fp)\r\n{\r\nchar buf[150];\r\nstruct irqaction *action;\r\nunsigned int i;\r\nunsigned long flags = 0;\r\nunsigned int cpu = raw_smp_processor_id();\r\nunsigned char in_atomic = (bfin_read_IPEND() & 0x10) || in_atomic();\r\npr_notice("\n");\r\nif (CPUID != bfin_cpuid())\r\npr_notice("Compiled for cpu family 0x%04x (Rev %d), "\r\n"but running on:0x%04x (Rev %d)\n",\r\nCPUID, bfin_compiled_revid(), bfin_cpuid(), bfin_revid());\r\npr_notice("ADSP-%s-0.%d",\r\nCPU, bfin_compiled_revid());\r\nif (bfin_compiled_revid() != bfin_revid())\r\npr_cont("(Detected 0.%d)", bfin_revid());\r\npr_cont(" %lu(MHz CCLK) %lu(MHz SCLK) (%s)\n",\r\nget_cclk()/1000000, get_sclk()/1000000,\r\n#ifdef CONFIG_MPU\r\n"mpu on"\r\n#else\r\n"mpu off"\r\n#endif\r\n);\r\npr_notice("%s", linux_banner);\r\npr_notice("\nSEQUENCER STATUS:\t\t%s\n", print_tainted());\r\npr_notice(" SEQSTAT: %08lx IPEND: %04lx IMASK: %04lx SYSCFG: %04lx\n",\r\n(long)fp->seqstat, fp->ipend, cpu_pda[raw_smp_processor_id()].ex_imask, fp->syscfg);\r\nif (fp->ipend & EVT_IRPTEN)\r\npr_notice(" Global Interrupts Disabled (IPEND[4])\n");\r\nif (!(cpu_pda[raw_smp_processor_id()].ex_imask & (EVT_IVG13 | EVT_IVG12 | EVT_IVG11 |\r\nEVT_IVG10 | EVT_IVG9 | EVT_IVG8 | EVT_IVG7 | EVT_IVTMR)))\r\npr_notice(" Peripheral interrupts masked off\n");\r\nif (!(cpu_pda[raw_smp_processor_id()].ex_imask & (EVT_IVG15 | EVT_IVG14)))\r\npr_notice(" Kernel interrupts masked off\n");\r\nif ((fp->seqstat & SEQSTAT_EXCAUSE) == VEC_HWERR) {\r\npr_notice(" HWERRCAUSE: 0x%lx\n",\r\n(fp->seqstat & SEQSTAT_HWERRCAUSE) >> 14);\r\n#ifdef EBIU_ERRMST\r\nif (bfin_read_EBIU_ERRMST() & CORE_ERROR) {\r\npr_notice(" EBIU Error Reason : 0x%04x\n",\r\nbfin_read_EBIU_ERRMST());\r\npr_notice(" EBIU Error Address : 0x%08x\n",\r\nbfin_read_EBIU_ERRADD());\r\n}\r\n#endif\r\n}\r\npr_notice(" EXCAUSE : 0x%lx\n",\r\nfp->seqstat & SEQSTAT_EXCAUSE);\r\nfor (i = 2; i <= 15 ; i++) {\r\nif (fp->ipend & (1 << i)) {\r\nif (i != 4) {\r\ndecode_address(buf, bfin_read32(EVT0 + 4*i));\r\npr_notice(" physical IVG%i asserted : %s\n", i, buf);\r\n} else\r\npr_notice(" interrupts disabled\n");\r\n}\r\n}\r\nif (fp->ipend & ~0x3F) {\r\nfor (i = 0; i < (NR_IRQS - 1); i++) {\r\nstruct irq_desc *desc = irq_to_desc(i);\r\nif (!in_atomic)\r\nraw_spin_lock_irqsave(&desc->lock, flags);\r\naction = desc->action;\r\nif (!action)\r\ngoto unlock;\r\ndecode_address(buf, (unsigned int)action->handler);\r\npr_notice(" logical irq %3d mapped : %s", i, buf);\r\nfor (action = action->next; action; action = action->next) {\r\ndecode_address(buf, (unsigned int)action->handler);\r\npr_cont(", %s", buf);\r\n}\r\npr_cont("\n");\r\nunlock:\r\nif (!in_atomic)\r\nraw_spin_unlock_irqrestore(&desc->lock, flags);\r\n}\r\n}\r\ndecode_address(buf, fp->rete);\r\npr_notice(" RETE: %s\n", buf);\r\ndecode_address(buf, fp->retn);\r\npr_notice(" RETN: %s\n", buf);\r\ndecode_address(buf, fp->retx);\r\npr_notice(" RETX: %s\n", buf);\r\ndecode_address(buf, fp->rets);\r\npr_notice(" RETS: %s\n", buf);\r\ndecode_address(buf, fp->pc);\r\npr_notice(" PC : %s\n", buf);\r\nif (((long)fp->seqstat & SEQSTAT_EXCAUSE) &&\r\n(((long)fp->seqstat & SEQSTAT_EXCAUSE) != VEC_HWERR)) {\r\ndecode_address(buf, cpu_pda[cpu].dcplb_fault_addr);\r\npr_notice("DCPLB_FAULT_ADDR: %s\n", buf);\r\ndecode_address(buf, cpu_pda[cpu].icplb_fault_addr);\r\npr_notice("ICPLB_FAULT_ADDR: %s\n", buf);\r\n}\r\npr_notice("PROCESSOR STATE:\n");\r\npr_notice(" R0 : %08lx R1 : %08lx R2 : %08lx R3 : %08lx\n",\r\nfp->r0, fp->r1, fp->r2, fp->r3);\r\npr_notice(" R4 : %08lx R5 : %08lx R6 : %08lx R7 : %08lx\n",\r\nfp->r4, fp->r5, fp->r6, fp->r7);\r\npr_notice(" P0 : %08lx P1 : %08lx P2 : %08lx P3 : %08lx\n",\r\nfp->p0, fp->p1, fp->p2, fp->p3);\r\npr_notice(" P4 : %08lx P5 : %08lx FP : %08lx SP : %08lx\n",\r\nfp->p4, fp->p5, fp->fp, (long)fp);\r\npr_notice(" LB0: %08lx LT0: %08lx LC0: %08lx\n",\r\nfp->lb0, fp->lt0, fp->lc0);\r\npr_notice(" LB1: %08lx LT1: %08lx LC1: %08lx\n",\r\nfp->lb1, fp->lt1, fp->lc1);\r\npr_notice(" B0 : %08lx L0 : %08lx M0 : %08lx I0 : %08lx\n",\r\nfp->b0, fp->l0, fp->m0, fp->i0);\r\npr_notice(" B1 : %08lx L1 : %08lx M1 : %08lx I1 : %08lx\n",\r\nfp->b1, fp->l1, fp->m1, fp->i1);\r\npr_notice(" B2 : %08lx L2 : %08lx M2 : %08lx I2 : %08lx\n",\r\nfp->b2, fp->l2, fp->m2, fp->i2);\r\npr_notice(" B3 : %08lx L3 : %08lx M3 : %08lx I3 : %08lx\n",\r\nfp->b3, fp->l3, fp->m3, fp->i3);\r\npr_notice("A0.w: %08lx A0.x: %08lx A1.w: %08lx A1.x: %08lx\n",\r\nfp->a0w, fp->a0x, fp->a1w, fp->a1x);\r\npr_notice("USP : %08lx ASTAT: %08lx\n",\r\nrdusp(), fp->astat);\r\npr_notice("\n");\r\n}
