static void DevGMboxIRQActionAsyncHandler(void *Context, struct htc_packet *pPacket)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)Context;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevGMboxIRQActionAsyncHandler: (dev: 0x%lX)\n", (unsigned long)pDev));\r\nif (pPacket->Status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("IRQAction Operation (%d) failed! status:%d \n", pPacket->PktInfo.AsRx.HTCRxFlags,pPacket->Status));\r\n}\r\nAR6KFreeIOPacket(pDev,pPacket);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevGMboxIRQActionAsyncHandler \n"));\r\n}\r\nstatic int DevGMboxCounterEnableDisable(struct ar6k_device *pDev, GMBOX_IRQ_ACTION_TYPE IrqAction, bool AsyncMode)\r\n{\r\nint status = 0;\r\nstruct ar6k_irq_enable_registers regs;\r\nstruct htc_packet *pIOPacket = NULL;\r\nLOCK_AR6K(pDev);\r\nif (GMBOX_CREDIT_IRQ_ENABLE == IrqAction) {\r\npDev->GMboxInfo.CreditCountIRQEnabled = true;\r\npDev->IrqEnableRegisters.counter_int_status_enable |=\r\nCOUNTER_INT_STATUS_ENABLE_BIT_SET(1 << AR6K_GMBOX_CREDIT_COUNTER);\r\npDev->IrqEnableRegisters.int_status_enable |= INT_STATUS_ENABLE_COUNTER_SET(0x01);\r\n} else {\r\npDev->GMboxInfo.CreditCountIRQEnabled = false;\r\npDev->IrqEnableRegisters.counter_int_status_enable &=\r\n~(COUNTER_INT_STATUS_ENABLE_BIT_SET(1 << AR6K_GMBOX_CREDIT_COUNTER));\r\n}\r\nmemcpy(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);\r\nUNLOCK_AR6K(pDev);\r\ndo {\r\nif (AsyncMode) {\r\npIOPacket = AR6KAllocIOPacket(pDev);\r\nif (NULL == pIOPacket) {\r\nstatus = A_NO_MEMORY;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nmemcpy(pIOPacket->pBuffer,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);\r\npIOPacket->Completion = DevGMboxIRQActionAsyncHandler;\r\npIOPacket->pContext = pDev;\r\npIOPacket->PktInfo.AsRx.HTCRxFlags = IrqAction;\r\nHIFReadWrite(pDev->HIFDevice,\r\nINT_STATUS_ENABLE_ADDRESS,\r\npIOPacket->pBuffer,\r\nAR6K_IRQ_ENABLE_REGS_SIZE,\r\nHIF_WR_ASYNC_BYTE_INC,\r\npIOPacket);\r\npIOPacket = NULL;\r\nbreak;\r\n}\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nINT_STATUS_ENABLE_ADDRESS,\r\n&regs.int_status_enable,\r\nAR6K_IRQ_ENABLE_REGS_SIZE,\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\n} while (false);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n(" IRQAction Operation (%d) failed! status:%d \n", IrqAction, status));\r\n} else {\r\nif (!AsyncMode) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,\r\n(" IRQAction Operation (%d) success \n", IrqAction));\r\n}\r\n}\r\nif (pIOPacket != NULL) {\r\nAR6KFreeIOPacket(pDev,pIOPacket);\r\n}\r\nreturn status;\r\n}\r\nint DevGMboxIRQAction(struct ar6k_device *pDev, GMBOX_IRQ_ACTION_TYPE IrqAction, bool AsyncMode)\r\n{\r\nint status = 0;\r\nstruct htc_packet *pIOPacket = NULL;\r\nu8 GMboxIntControl[4];\r\nif (GMBOX_CREDIT_IRQ_ENABLE == IrqAction) {\r\nreturn DevGMboxCounterEnableDisable(pDev, GMBOX_CREDIT_IRQ_ENABLE, AsyncMode);\r\n} else if(GMBOX_CREDIT_IRQ_DISABLE == IrqAction) {\r\nreturn DevGMboxCounterEnableDisable(pDev, GMBOX_CREDIT_IRQ_DISABLE, AsyncMode);\r\n}\r\nif (GMBOX_DISABLE_ALL == IrqAction) {\r\nDevGMboxCounterEnableDisable(pDev, GMBOX_CREDIT_IRQ_DISABLE, AsyncMode);\r\n}\r\nLOCK_AR6K(pDev);\r\nswitch (IrqAction) {\r\ncase GMBOX_DISABLE_ALL:\r\npDev->GMboxControlRegisters.int_status_enable = 0;\r\nbreak;\r\ncase GMBOX_ERRORS_IRQ_ENABLE:\r\npDev->GMboxControlRegisters.int_status_enable |= GMBOX_INT_STATUS_TX_OVERFLOW |\r\nGMBOX_INT_STATUS_RX_OVERFLOW;\r\nbreak;\r\ncase GMBOX_RECV_IRQ_ENABLE:\r\npDev->GMboxControlRegisters.int_status_enable |= GMBOX_INT_STATUS_RX_DATA;\r\nbreak;\r\ncase GMBOX_RECV_IRQ_DISABLE:\r\npDev->GMboxControlRegisters.int_status_enable &= ~GMBOX_INT_STATUS_RX_DATA;\r\nbreak;\r\ncase GMBOX_ACTION_NONE:\r\ndefault:\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nGMboxIntControl[0] = pDev->GMboxControlRegisters.int_status_enable;\r\nGMboxIntControl[1] = GMboxIntControl[0];\r\nGMboxIntControl[2] = GMboxIntControl[0];\r\nGMboxIntControl[3] = GMboxIntControl[0];\r\nUNLOCK_AR6K(pDev);\r\ndo {\r\nif (AsyncMode) {\r\npIOPacket = AR6KAllocIOPacket(pDev);\r\nif (NULL == pIOPacket) {\r\nstatus = A_NO_MEMORY;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nmemcpy(pIOPacket->pBuffer,GMboxIntControl,sizeof(GMboxIntControl));\r\npIOPacket->Completion = DevGMboxIRQActionAsyncHandler;\r\npIOPacket->pContext = pDev;\r\npIOPacket->PktInfo.AsRx.HTCRxFlags = IrqAction;\r\nHIFReadWrite(pDev->HIFDevice,\r\nGMBOX_INT_STATUS_ENABLE_REG,\r\npIOPacket->pBuffer,\r\nsizeof(GMboxIntControl),\r\nHIF_WR_ASYNC_BYTE_FIX,\r\npIOPacket);\r\npIOPacket = NULL;\r\nbreak;\r\n}\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nGMBOX_INT_STATUS_ENABLE_REG,\r\nGMboxIntControl,\r\nsizeof(GMboxIntControl),\r\nHIF_WR_SYNC_BYTE_FIX,\r\nNULL);\r\n} while (false);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n(" IRQAction Operation (%d) failed! status:%d \n", IrqAction, status));\r\n} else {\r\nif (!AsyncMode) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,\r\n(" IRQAction Operation (%d) success \n", IrqAction));\r\n}\r\n}\r\nif (pIOPacket != NULL) {\r\nAR6KFreeIOPacket(pDev,pIOPacket);\r\n}\r\nreturn status;\r\n}\r\nvoid DevCleanupGMbox(struct ar6k_device *pDev)\r\n{\r\nif (pDev->GMboxEnabled) {\r\npDev->GMboxEnabled = false;\r\nGMboxProtocolUninstall(pDev);\r\n}\r\n}\r\nint DevSetupGMbox(struct ar6k_device *pDev)\r\n{\r\nint status = 0;\r\nu8 muxControl[4];\r\ndo {\r\nif (0 == pDev->MailBoxInfo.GMboxAddress) {\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,(" GMBOX Advertised: Address:0x%X , size:%d \n",\r\npDev->MailBoxInfo.GMboxAddress, pDev->MailBoxInfo.GMboxSize));\r\nstatus = DevGMboxIRQAction(pDev, GMBOX_DISABLE_ALL, PROC_IO_SYNC);\r\nif (status) {\r\nbreak;\r\n}\r\nmuxControl[0] = GMBOX_LA_MUX_OVERRIDE_2_3;\r\nmuxControl[1] = GMBOX_LA_MUX_OVERRIDE_2_3;\r\nmuxControl[2] = GMBOX_LA_MUX_OVERRIDE_2_3;\r\nmuxControl[3] = GMBOX_LA_MUX_OVERRIDE_2_3;\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nGMBOX_LOOKAHEAD_MUX_REG,\r\nmuxControl,\r\nsizeof(muxControl),\r\nHIF_WR_SYNC_BYTE_FIX,\r\nNULL);\r\nif (status) {\r\nbreak;\r\n}\r\nstatus = GMboxProtocolInstall(pDev);\r\nif (status) {\r\nbreak;\r\n}\r\npDev->GMboxEnabled = true;\r\n} while (false);\r\nreturn status;\r\n}\r\nint DevCheckGMboxInterrupts(struct ar6k_device *pDev)\r\n{\r\nint status = 0;\r\nu8 counter_int_status;\r\nint credits;\r\nu8 host_int_status2;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("+DevCheckGMboxInterrupts \n"));\r\ndo {\r\nhost_int_status2 = pDev->IrqProcRegisters.host_int_status2 &\r\npDev->GMboxControlRegisters.int_status_enable;\r\nif (host_int_status2 & GMBOX_INT_STATUS_TX_OVERFLOW) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("GMBOX : TX Overflow \n"));\r\nstatus = A_ECOMM;\r\n}\r\nif (host_int_status2 & GMBOX_INT_STATUS_RX_OVERFLOW) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("GMBOX : RX Overflow \n"));\r\nstatus = A_ECOMM;\r\n}\r\nif (status) {\r\nif (pDev->GMboxInfo.pTargetFailureCallback != NULL) {\r\npDev->GMboxInfo.pTargetFailureCallback(pDev->GMboxInfo.pProtocolContext, status);\r\n}\r\nbreak;\r\n}\r\nif (host_int_status2 & GMBOX_INT_STATUS_RX_DATA) {\r\nif (pDev->IrqProcRegisters.gmbox_rx_avail > 0) {\r\nA_ASSERT(pDev->GMboxInfo.pMessagePendingCallBack != NULL);\r\nstatus = pDev->GMboxInfo.pMessagePendingCallBack(\r\npDev->GMboxInfo.pProtocolContext,\r\n(u8 *)&pDev->IrqProcRegisters.rx_gmbox_lookahead_alias[0],\r\npDev->IrqProcRegisters.gmbox_rx_avail);\r\n}\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\ncounter_int_status = pDev->IrqProcRegisters.counter_int_status &\r\npDev->IrqEnableRegisters.counter_int_status_enable;\r\nif (counter_int_status & (COUNTER_INT_STATUS_ENABLE_BIT_SET(1 << AR6K_GMBOX_CREDIT_COUNTER))) {\r\nstatus = DevGMboxReadCreditCounter(pDev, PROC_IO_SYNC, &credits);\r\nif (status) {\r\nbreak;\r\n}\r\nA_ASSERT(pDev->GMboxInfo.pCreditsPendingCallback != NULL);\r\nstatus = pDev->GMboxInfo.pCreditsPendingCallback(pDev->GMboxInfo.pProtocolContext,\r\ncredits,\r\npDev->GMboxInfo.CreditCountIRQEnabled);\r\n}\r\n} while (false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("-DevCheckGMboxInterrupts (%d) \n",status));\r\nreturn status;\r\n}\r\nint DevGMboxWrite(struct ar6k_device *pDev, struct htc_packet *pPacket, u32 WriteLength)\r\n{\r\nu32 paddedLength;\r\nbool sync = (pPacket->Completion == NULL) ? true : false;\r\nint status;\r\nu32 address;\r\npaddedLength = DEV_CALC_SEND_PADDED_LEN(pDev, WriteLength);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,\r\n("DevGMboxWrite, Padded Length: %d Mbox:0x%X (mode:%s)\n",\r\nWriteLength,\r\npDev->MailBoxInfo.GMboxAddress,\r\nsync ? "SYNC" : "ASYNC"));\r\naddress = pDev->MailBoxInfo.GMboxAddress + pDev->MailBoxInfo.GMboxSize - paddedLength;\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\naddress,\r\npPacket->pBuffer,\r\npaddedLength,\r\nsync ? HIF_WR_SYNC_BLOCK_INC : HIF_WR_ASYNC_BLOCK_INC,\r\nsync ? NULL : pPacket);\r\nif (sync) {\r\npPacket->Status = status;\r\n} else {\r\nif (status == A_PENDING) {\r\nstatus = 0;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint DevGMboxRead(struct ar6k_device *pDev, struct htc_packet *pPacket, u32 ReadLength)\r\n{\r\nu32 paddedLength;\r\nint status;\r\nbool sync = (pPacket->Completion == NULL) ? true : false;\r\npaddedLength = DEV_CALC_RECV_PADDED_LEN(pDev, ReadLength);\r\nif (paddedLength > pPacket->BufferLength) {\r\nA_ASSERT(false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("DevGMboxRead, Not enough space for padlen:%d recvlen:%d bufferlen:%d \n",\r\npaddedLength,ReadLength,pPacket->BufferLength));\r\nif (pPacket->Completion != NULL) {\r\nCOMPLETE_HTC_PACKET(pPacket,A_EINVAL);\r\nreturn 0;\r\n}\r\nreturn A_EINVAL;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("DevGMboxRead (0x%lX : hdr:0x%X) Padded Length: %d Mbox:0x%X (mode:%s)\n",\r\n(unsigned long)pPacket, pPacket->PktInfo.AsRx.ExpectedHdr,\r\npaddedLength,\r\npDev->MailBoxInfo.GMboxAddress,\r\nsync ? "SYNC" : "ASYNC"));\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\npDev->MailBoxInfo.GMboxAddress,\r\npPacket->pBuffer,\r\npaddedLength,\r\nsync ? HIF_RD_SYNC_BLOCK_FIX : HIF_RD_ASYNC_BLOCK_FIX,\r\nsync ? NULL : pPacket);\r\nif (sync) {\r\npPacket->Status = status;\r\n}\r\nreturn status;\r\n}\r\nstatic int ProcessCreditCounterReadBuffer(u8 *pBuffer, int Length)\r\n{\r\nint credits = 0;\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {\r\nDebugDumpBytes(pBuffer, Length, "GMBOX Credit read buffer");\r\n}\r\nwhile (Length) {\r\nif (*pBuffer != 0) {\r\ncredits++;\r\n}\r\nLength--;\r\npBuffer++;\r\n}\r\nreturn credits;\r\n}\r\nstatic void DevGMboxReadCreditsAsyncHandler(void *Context, struct htc_packet *pPacket)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)Context;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevGMboxReadCreditsAsyncHandler: (dev: 0x%lX)\n", (unsigned long)pDev));\r\nif (pPacket->Status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Read Credit Operation failed! status:%d \n", pPacket->Status));\r\n} else {\r\nint credits = 0;\r\ncredits = ProcessCreditCounterReadBuffer(pPacket->pBuffer, AR6K_REG_IO_BUFFER_SIZE);\r\npDev->GMboxInfo.pCreditsPendingCallback(pDev->GMboxInfo.pProtocolContext,\r\ncredits,\r\npDev->GMboxInfo.CreditCountIRQEnabled);\r\n}\r\nAR6KFreeIOPacket(pDev,pPacket);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevGMboxReadCreditsAsyncHandler \n"));\r\n}\r\nint DevGMboxReadCreditCounter(struct ar6k_device *pDev, bool AsyncMode, int *pCredits)\r\n{\r\nint status = 0;\r\nstruct htc_packet *pIOPacket = NULL;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("+DevGMboxReadCreditCounter (%s) \n", AsyncMode ? "ASYNC" : "SYNC"));\r\ndo {\r\npIOPacket = AR6KAllocIOPacket(pDev);\r\nif (NULL == pIOPacket) {\r\nstatus = A_NO_MEMORY;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nA_MEMZERO(pIOPacket->pBuffer,AR6K_REG_IO_BUFFER_SIZE);\r\nif (AsyncMode) {\r\npIOPacket->Completion = DevGMboxReadCreditsAsyncHandler;\r\npIOPacket->pContext = pDev;\r\nHIFReadWrite(pDev->HIFDevice,\r\nAR6K_GMBOX_CREDIT_DEC_ADDRESS,\r\npIOPacket->pBuffer,\r\nAR6K_REG_IO_BUFFER_SIZE,\r\nHIF_RD_ASYNC_BYTE_FIX,\r\npIOPacket);\r\npIOPacket = NULL;\r\nbreak;\r\n}\r\npIOPacket->Completion = NULL;\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nAR6K_GMBOX_CREDIT_DEC_ADDRESS,\r\npIOPacket->pBuffer,\r\nAR6K_REG_IO_BUFFER_SIZE,\r\nHIF_RD_SYNC_BYTE_FIX,\r\nNULL);\r\n} while (false);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n(" DevGMboxReadCreditCounter failed! status:%d \n", status));\r\n}\r\nif (pIOPacket != NULL) {\r\nif (!status) {\r\n*pCredits = ProcessCreditCounterReadBuffer(pIOPacket->pBuffer, AR6K_REG_IO_BUFFER_SIZE);\r\n}\r\nAR6KFreeIOPacket(pDev,pIOPacket);\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("-DevGMboxReadCreditCounter (%s) (%d) \n",\r\nAsyncMode ? "ASYNC" : "SYNC", status));\r\nreturn status;\r\n}\r\nint DevGMboxReadCreditSize(struct ar6k_device *pDev, int *pCreditSize)\r\n{\r\nint status;\r\nu8 buffer[4];\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nAR6K_GMBOX_CREDIT_SIZE_ADDRESS,\r\nbuffer,\r\nsizeof(buffer),\r\nHIF_RD_SYNC_BYTE_FIX,\r\nNULL);\r\nif (!status) {\r\nif (buffer[0] == 0) {\r\n*pCreditSize = 256;\r\n} else {\r\n*pCreditSize = buffer[0];\r\n}\r\n}\r\nreturn status;\r\n}\r\nvoid DevNotifyGMboxTargetFailure(struct ar6k_device *pDev)\r\n{\r\nif (pDev->GMboxInfo.pTargetFailureCallback != NULL) {\r\npDev->GMboxInfo.pTargetFailureCallback(pDev->GMboxInfo.pProtocolContext, A_HARDWARE);\r\n}\r\n}\r\nint DevGMboxRecvLookAheadPeek(struct ar6k_device *pDev, u8 *pLookAheadBuffer, int *pLookAheadBytes)\r\n{\r\nint status = 0;\r\nstruct ar6k_irq_proc_registers procRegs;\r\nint maxCopy;\r\ndo {\r\nif (*pLookAheadBytes > sizeof(procRegs.rx_gmbox_lookahead_alias)) {\r\nA_ASSERT(false);\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nmaxCopy = *pLookAheadBytes;\r\n*pLookAheadBytes = 0;\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nHOST_INT_STATUS_ADDRESS,\r\n(u8 *)&procRegs,\r\nAR6K_IRQ_PROC_REGS_SIZE,\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("DevGMboxRecvLookAheadPeek : Failed to read register table (%d) \n",status));\r\nbreak;\r\n}\r\nif (procRegs.gmbox_rx_avail > 0) {\r\nint bytes = procRegs.gmbox_rx_avail > maxCopy ? maxCopy : procRegs.gmbox_rx_avail;\r\nmemcpy(pLookAheadBuffer,&procRegs.rx_gmbox_lookahead_alias[0],bytes);\r\n*pLookAheadBytes = bytes;\r\n}\r\n} while (false);\r\nreturn status;\r\n}\r\nint DevGMboxSetTargetInterrupt(struct ar6k_device *pDev, int Signal, int AckTimeoutMS)\r\n{\r\nint status = 0;\r\nint i;\r\nu8 buffer[4];\r\nA_MEMZERO(buffer, sizeof(buffer));\r\ndo {\r\nif (Signal >= MBOX_SIG_HCI_BRIDGE_MAX) {\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nbuffer[3] = (1 << Signal);\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nINT_WLAN_ADDRESS,\r\nbuffer,\r\nsizeof(buffer),\r\nHIF_WR_SYNC_BYTE_FIX,\r\nNULL);\r\nif (status) {\r\nbreak;\r\n}\r\n} while (false);\r\nif (!status) {\r\nwhile (AckTimeoutMS) {\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nINT_WLAN_ADDRESS,\r\nbuffer,\r\nsizeof(buffer),\r\nHIF_RD_SYNC_BYTE_FIX,\r\nNULL);\r\nif (status) {\r\nbreak;\r\n}\r\nfor (i = 0; i < sizeof(buffer); i++) {\r\nif (buffer[i] & (1 << Signal)) {\r\nbreak;\r\n}\r\n}\r\nif (i >= sizeof(buffer)) {\r\nbreak;\r\n}\r\nAckTimeoutMS--;\r\nA_MDELAY(1);\r\n}\r\nif (0 == AckTimeoutMS) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("DevGMboxSetTargetInterrupt : Ack Timed-out (sig:%d) \n",Signal));\r\nstatus = A_ERROR;\r\n}\r\n}\r\nreturn status;\r\n}
