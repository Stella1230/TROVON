static int\r\nccwgroup_bus_match (struct device * dev, struct device_driver * drv)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nstruct ccwgroup_driver *gdrv;\r\ngdev = to_ccwgroupdev(dev);\r\ngdrv = to_ccwgroupdrv(drv);\r\nif (gdev->creator_id == gdrv->driver_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nccwgroup_uevent (struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\n__ccwgroup_remove_symlinks(struct ccwgroup_device *gdev)\r\n{\r\nint i;\r\nchar str[8];\r\nfor (i = 0; i < gdev->count; i++) {\r\nsprintf(str, "cdev%d", i);\r\nsysfs_remove_link(&gdev->dev.kobj, str);\r\nsysfs_remove_link(&gdev->cdev[i]->dev.kobj, "group_device");\r\n}\r\n}\r\nstatic void __ccwgroup_remove_cdev_refs(struct ccwgroup_device *gdev)\r\n{\r\nstruct ccw_device *cdev;\r\nint i;\r\nfor (i = 0; i < gdev->count; i++) {\r\ncdev = gdev->cdev[i];\r\nif (!cdev)\r\ncontinue;\r\nspin_lock_irq(cdev->ccwlock);\r\ndev_set_drvdata(&cdev->dev, NULL);\r\nspin_unlock_irq(cdev->ccwlock);\r\ngdev->cdev[i] = NULL;\r\nput_device(&cdev->dev);\r\n}\r\n}\r\nstatic void ccwgroup_ungroup_callback(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nmutex_lock(&gdev->reg_mutex);\r\nif (device_is_registered(&gdev->dev)) {\r\n__ccwgroup_remove_symlinks(gdev);\r\ndevice_unregister(dev);\r\n__ccwgroup_remove_cdev_refs(gdev);\r\n}\r\nmutex_unlock(&gdev->reg_mutex);\r\n}\r\nstatic ssize_t\r\nccwgroup_ungroup_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nint rc;\r\ngdev = to_ccwgroupdev(dev);\r\nif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\r\nreturn -EAGAIN;\r\nif (gdev->state != CCWGROUP_OFFLINE) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = device_schedule_callback(dev, ccwgroup_ungroup_callback);\r\nout:\r\nif (rc) {\r\nif (rc != -EAGAIN)\r\natomic_set(&gdev->onoff, 0);\r\nreturn rc;\r\n}\r\nreturn count;\r\n}\r\nstatic void\r\nccwgroup_release (struct device *dev)\r\n{\r\nkfree(to_ccwgroupdev(dev));\r\n}\r\nstatic int\r\n__ccwgroup_create_symlinks(struct ccwgroup_device *gdev)\r\n{\r\nchar str[8];\r\nint i, rc;\r\nfor (i = 0; i < gdev->count; i++) {\r\nrc = sysfs_create_link(&gdev->cdev[i]->dev.kobj, &gdev->dev.kobj,\r\n"group_device");\r\nif (rc) {\r\nfor (--i; i >= 0; i--)\r\nsysfs_remove_link(&gdev->cdev[i]->dev.kobj,\r\n"group_device");\r\nreturn rc;\r\n}\r\n}\r\nfor (i = 0; i < gdev->count; i++) {\r\nsprintf(str, "cdev%d", i);\r\nrc = sysfs_create_link(&gdev->dev.kobj, &gdev->cdev[i]->dev.kobj,\r\nstr);\r\nif (rc) {\r\nfor (--i; i >= 0; i--) {\r\nsprintf(str, "cdev%d", i);\r\nsysfs_remove_link(&gdev->dev.kobj, str);\r\n}\r\nfor (i = 0; i < gdev->count; i++)\r\nsysfs_remove_link(&gdev->cdev[i]->dev.kobj,\r\n"group_device");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __get_next_bus_id(const char **buf, char *bus_id)\r\n{\r\nint rc, len;\r\nchar *start, *end;\r\nstart = (char *)*buf;\r\nend = strchr(start, ',');\r\nif (!end) {\r\nend = strchr(start, '\n');\r\nif (end)\r\n*end = '\0';\r\nlen = strlen(start) + 1;\r\n} else {\r\nlen = end - start + 1;\r\nend++;\r\n}\r\nif (len < CCW_BUS_ID_SIZE) {\r\nstrlcpy(bus_id, start, len);\r\nrc = 0;\r\n} else\r\nrc = -EINVAL;\r\n*buf = end;\r\nreturn rc;\r\n}\r\nstatic int __is_valid_bus_id(char bus_id[CCW_BUS_ID_SIZE])\r\n{\r\nint cssid, ssid, devno;\r\nif (sscanf(bus_id, "%x.%1x.%04x", &cssid, &ssid, &devno) != 3)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint ccwgroup_create_from_string(struct device *root, unsigned int creator_id,\r\nstruct ccw_driver *cdrv, int num_devices,\r\nconst char *buf)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nint rc, i;\r\nchar tmp_bus_id[CCW_BUS_ID_SIZE];\r\nconst char *curr_buf;\r\ngdev = kzalloc(sizeof(*gdev) + num_devices * sizeof(gdev->cdev[0]),\r\nGFP_KERNEL);\r\nif (!gdev)\r\nreturn -ENOMEM;\r\natomic_set(&gdev->onoff, 0);\r\nmutex_init(&gdev->reg_mutex);\r\nmutex_lock(&gdev->reg_mutex);\r\ngdev->creator_id = creator_id;\r\ngdev->count = num_devices;\r\ngdev->dev.bus = &ccwgroup_bus_type;\r\ngdev->dev.parent = root;\r\ngdev->dev.release = ccwgroup_release;\r\ndevice_initialize(&gdev->dev);\r\ncurr_buf = buf;\r\nfor (i = 0; i < num_devices && curr_buf; i++) {\r\nrc = __get_next_bus_id(&curr_buf, tmp_bus_id);\r\nif (rc != 0)\r\ngoto error;\r\nif (!__is_valid_bus_id(tmp_bus_id)) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\ngdev->cdev[i] = get_ccwdev_by_busid(cdrv, tmp_bus_id);\r\nif (!gdev->cdev[i]\r\n|| gdev->cdev[i]->id.driver_info !=\r\ngdev->cdev[0]->id.driver_info) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nspin_lock_irq(gdev->cdev[i]->ccwlock);\r\nif (dev_get_drvdata(&gdev->cdev[i]->dev)) {\r\nspin_unlock_irq(gdev->cdev[i]->ccwlock);\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\ndev_set_drvdata(&gdev->cdev[i]->dev, gdev);\r\nspin_unlock_irq(gdev->cdev[i]->ccwlock);\r\n}\r\nif (i < num_devices && !curr_buf) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nif (i == num_devices && strlen(curr_buf) > 0) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\ndev_set_name(&gdev->dev, "%s", dev_name(&gdev->cdev[0]->dev));\r\nrc = device_add(&gdev->dev);\r\nif (rc)\r\ngoto error;\r\nget_device(&gdev->dev);\r\nrc = device_create_file(&gdev->dev, &dev_attr_ungroup);\r\nif (rc) {\r\ndevice_unregister(&gdev->dev);\r\ngoto error;\r\n}\r\nrc = __ccwgroup_create_symlinks(gdev);\r\nif (!rc) {\r\nmutex_unlock(&gdev->reg_mutex);\r\nput_device(&gdev->dev);\r\nreturn 0;\r\n}\r\ndevice_remove_file(&gdev->dev, &dev_attr_ungroup);\r\ndevice_unregister(&gdev->dev);\r\nerror:\r\nfor (i = 0; i < num_devices; i++)\r\nif (gdev->cdev[i]) {\r\nspin_lock_irq(gdev->cdev[i]->ccwlock);\r\nif (dev_get_drvdata(&gdev->cdev[i]->dev) == gdev)\r\ndev_set_drvdata(&gdev->cdev[i]->dev, NULL);\r\nspin_unlock_irq(gdev->cdev[i]->ccwlock);\r\nput_device(&gdev->cdev[i]->dev);\r\ngdev->cdev[i] = NULL;\r\n}\r\nmutex_unlock(&gdev->reg_mutex);\r\nput_device(&gdev->dev);\r\nreturn rc;\r\n}\r\nstatic int __init init_ccwgroup(void)\r\n{\r\nint ret;\r\nret = bus_register(&ccwgroup_bus_type);\r\nif (ret)\r\nreturn ret;\r\nret = bus_register_notifier(&ccwgroup_bus_type, &ccwgroup_nb);\r\nif (ret)\r\nbus_unregister(&ccwgroup_bus_type);\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_ccwgroup(void)\r\n{\r\nbus_unregister_notifier(&ccwgroup_bus_type, &ccwgroup_nb);\r\nbus_unregister(&ccwgroup_bus_type);\r\n}\r\nstatic int\r\nccwgroup_set_online(struct ccwgroup_device *gdev)\r\n{\r\nstruct ccwgroup_driver *gdrv;\r\nint ret;\r\nif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\r\nreturn -EAGAIN;\r\nif (gdev->state == CCWGROUP_ONLINE) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (!gdev->dev.driver) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ngdrv = to_ccwgroupdrv (gdev->dev.driver);\r\nif ((ret = gdrv->set_online ? gdrv->set_online(gdev) : 0))\r\ngoto out;\r\ngdev->state = CCWGROUP_ONLINE;\r\nout:\r\natomic_set(&gdev->onoff, 0);\r\nreturn ret;\r\n}\r\nstatic int\r\nccwgroup_set_offline(struct ccwgroup_device *gdev)\r\n{\r\nstruct ccwgroup_driver *gdrv;\r\nint ret;\r\nif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\r\nreturn -EAGAIN;\r\nif (gdev->state == CCWGROUP_OFFLINE) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (!gdev->dev.driver) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ngdrv = to_ccwgroupdrv (gdev->dev.driver);\r\nif ((ret = gdrv->set_offline ? gdrv->set_offline(gdev) : 0))\r\ngoto out;\r\ngdev->state = CCWGROUP_OFFLINE;\r\nout:\r\natomic_set(&gdev->onoff, 0);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nccwgroup_online_store (struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nstruct ccwgroup_driver *gdrv;\r\nunsigned long value;\r\nint ret;\r\nif (!dev->driver)\r\nreturn -ENODEV;\r\ngdev = to_ccwgroupdev(dev);\r\ngdrv = to_ccwgroupdrv(dev->driver);\r\nif (!try_module_get(gdrv->driver.owner))\r\nreturn -EINVAL;\r\nret = strict_strtoul(buf, 0, &value);\r\nif (ret)\r\ngoto out;\r\nif (value == 1)\r\nret = ccwgroup_set_online(gdev);\r\nelse if (value == 0)\r\nret = ccwgroup_set_offline(gdev);\r\nelse\r\nret = -EINVAL;\r\nout:\r\nmodule_put(gdrv->driver.owner);\r\nreturn (ret == 0) ? count : ret;\r\n}\r\nstatic ssize_t\r\nccwgroup_online_show (struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint online;\r\nonline = (to_ccwgroupdev(dev)->state == CCWGROUP_ONLINE);\r\nreturn sprintf(buf, online ? "1\n" : "0\n");\r\n}\r\nstatic int\r\nccwgroup_probe (struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nstruct ccwgroup_driver *gdrv;\r\nint ret;\r\ngdev = to_ccwgroupdev(dev);\r\ngdrv = to_ccwgroupdrv(dev->driver);\r\nif ((ret = device_create_file(dev, &dev_attr_online)))\r\nreturn ret;\r\nret = gdrv->probe ? gdrv->probe(gdev) : -ENODEV;\r\nif (ret)\r\ndevice_remove_file(dev, &dev_attr_online);\r\nreturn ret;\r\n}\r\nstatic int\r\nccwgroup_remove (struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nstruct ccwgroup_driver *gdrv;\r\ndevice_remove_file(dev, &dev_attr_online);\r\ndevice_remove_file(dev, &dev_attr_ungroup);\r\nif (!dev->driver)\r\nreturn 0;\r\ngdev = to_ccwgroupdev(dev);\r\ngdrv = to_ccwgroupdrv(dev->driver);\r\nif (gdrv->remove)\r\ngdrv->remove(gdev);\r\nreturn 0;\r\n}\r\nstatic void ccwgroup_shutdown(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nstruct ccwgroup_driver *gdrv;\r\nif (!dev->driver)\r\nreturn;\r\ngdev = to_ccwgroupdev(dev);\r\ngdrv = to_ccwgroupdrv(dev->driver);\r\nif (gdrv->shutdown)\r\ngdrv->shutdown(gdev);\r\n}\r\nstatic int ccwgroup_pm_prepare(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nif (atomic_read(&gdev->onoff))\r\nreturn -EAGAIN;\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn 0;\r\nreturn gdrv->prepare ? gdrv->prepare(gdev) : 0;\r\n}\r\nstatic void ccwgroup_pm_complete(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(dev->driver);\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn;\r\nif (gdrv->complete)\r\ngdrv->complete(gdev);\r\n}\r\nstatic int ccwgroup_pm_freeze(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn 0;\r\nreturn gdrv->freeze ? gdrv->freeze(gdev) : 0;\r\n}\r\nstatic int ccwgroup_pm_thaw(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn 0;\r\nreturn gdrv->thaw ? gdrv->thaw(gdev) : 0;\r\n}\r\nstatic int ccwgroup_pm_restore(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn 0;\r\nreturn gdrv->restore ? gdrv->restore(gdev) : 0;\r\n}\r\nstatic int ccwgroup_notifier(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct device *dev = data;\r\nif (action == BUS_NOTIFY_UNBIND_DRIVER)\r\ndevice_schedule_callback(dev, ccwgroup_ungroup_callback);\r\nreturn NOTIFY_OK;\r\n}\r\nint ccwgroup_driver_register(struct ccwgroup_driver *cdriver)\r\n{\r\ncdriver->driver.bus = &ccwgroup_bus_type;\r\nreturn driver_register(&cdriver->driver);\r\n}\r\nstatic int\r\n__ccwgroup_match_all(struct device *dev, void *data)\r\n{\r\nreturn 1;\r\n}\r\nvoid ccwgroup_driver_unregister(struct ccwgroup_driver *cdriver)\r\n{\r\nstruct device *dev;\r\nget_driver(&cdriver->driver);\r\nwhile ((dev = driver_find_device(&cdriver->driver, NULL, NULL,\r\n__ccwgroup_match_all))) {\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nmutex_lock(&gdev->reg_mutex);\r\n__ccwgroup_remove_symlinks(gdev);\r\ndevice_unregister(dev);\r\n__ccwgroup_remove_cdev_refs(gdev);\r\nmutex_unlock(&gdev->reg_mutex);\r\nput_device(dev);\r\n}\r\nput_driver(&cdriver->driver);\r\ndriver_unregister(&cdriver->driver);\r\n}\r\nint ccwgroup_probe_ccwdev(struct ccw_device *cdev)\r\n{\r\nreturn 0;\r\n}\r\nvoid ccwgroup_remove_ccwdev(struct ccw_device *cdev)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nccw_device_set_offline(cdev);\r\nspin_lock_irq(cdev->ccwlock);\r\ngdev = dev_get_drvdata(&cdev->dev);\r\nif (!gdev) {\r\nspin_unlock_irq(cdev->ccwlock);\r\nreturn;\r\n}\r\nget_device(&gdev->dev);\r\nspin_unlock_irq(cdev->ccwlock);\r\nmutex_lock(&gdev->reg_mutex);\r\nif (device_is_registered(&gdev->dev)) {\r\n__ccwgroup_remove_symlinks(gdev);\r\ndevice_unregister(&gdev->dev);\r\n__ccwgroup_remove_cdev_refs(gdev);\r\n}\r\nmutex_unlock(&gdev->reg_mutex);\r\nput_device(&gdev->dev);\r\n}
