void AR6KFreeIOPacket(struct ar6k_device *pDev, struct htc_packet *pPacket)\r\n{\r\nLOCK_AR6K(pDev);\r\nHTC_PACKET_ENQUEUE(&pDev->RegisterIOList,pPacket);\r\nUNLOCK_AR6K(pDev);\r\n}\r\nstruct htc_packet *AR6KAllocIOPacket(struct ar6k_device *pDev)\r\n{\r\nstruct htc_packet *pPacket;\r\nLOCK_AR6K(pDev);\r\npPacket = HTC_PACKET_DEQUEUE(&pDev->RegisterIOList);\r\nUNLOCK_AR6K(pDev);\r\nreturn pPacket;\r\n}\r\nvoid DevCleanup(struct ar6k_device *pDev)\r\n{\r\nDevCleanupGMbox(pDev);\r\nif (pDev->HifAttached) {\r\nHIFDetachHTC(pDev->HIFDevice);\r\npDev->HifAttached = false;\r\n}\r\nDevCleanupVirtualScatterSupport(pDev);\r\nif (A_IS_MUTEX_VALID(&pDev->Lock)) {\r\nA_MUTEX_DELETE(&pDev->Lock);\r\n}\r\n}\r\nint DevSetup(struct ar6k_device *pDev)\r\n{\r\nu32 blocksizes[AR6K_MAILBOXES];\r\nint status = 0;\r\nint i;\r\nHTC_CALLBACKS htcCallbacks;\r\ndo {\r\nDL_LIST_INIT(&pDev->ScatterReqHead);\r\nINIT_HTC_PACKET_QUEUE(&pDev->RegisterIOList);\r\nA_MUTEX_INIT(&pDev->Lock);\r\nA_MEMZERO(&htcCallbacks, sizeof(HTC_CALLBACKS));\r\nhtcCallbacks.rwCompletionHandler = DevRWCompletionHandler;\r\nhtcCallbacks.dsrHandler = DevDsrHandler;\r\nhtcCallbacks.context = pDev;\r\nstatus = HIFAttachHTC(pDev->HIFDevice, &htcCallbacks);\r\nif (status) {\r\nbreak;\r\n}\r\npDev->HifAttached = true;\r\nstatus = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_ADDR,\r\n&pDev->MailBoxInfo, sizeof(pDev->MailBoxInfo));\r\nif (status) {\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nfor (i = 0; i < AR6K_MAX_REG_IO_BUFFERS; i++) {\r\nstruct htc_packet *pIOPacket;\r\npIOPacket = &pDev->RegIOBuffers[i].HtcPacket;\r\nSET_HTC_PACKET_INFO_RX_REFILL(pIOPacket,\r\npDev,\r\npDev->RegIOBuffers[i].Buffer,\r\nAR6K_REG_IO_BUFFER_SIZE,\r\n0);\r\nAR6KFreeIOPacket(pDev,pIOPacket);\r\n}\r\nstatus = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,\r\nblocksizes, sizeof(blocksizes));\r\nif (status) {\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\npDev->BlockSize = blocksizes[MAILBOX_FOR_BLOCK_SIZE];\r\nA_ASSERT((pDev->BlockSize & (pDev->BlockSize - 1)) == 0);\r\npDev->BlockMask = pDev->BlockSize - 1;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("BlockSize: %d, MailboxAddress:0x%X \n",\r\npDev->BlockSize, pDev->MailBoxInfo.MboxAddresses[HTC_MAILBOX]));\r\npDev->GetPendingEventsFunc = NULL;\r\nHIFConfigureDevice(pDev->HIFDevice,\r\nHIF_DEVICE_GET_PENDING_EVENTS_FUNC,\r\n&pDev->GetPendingEventsFunc,\r\nsizeof(pDev->GetPendingEventsFunc));\r\npDev->HifIRQProcessingMode = HIF_DEVICE_IRQ_ASYNC_SYNC;\r\nHIFConfigureDevice(pDev->HIFDevice,\r\nHIF_DEVICE_GET_IRQ_PROC_MODE,\r\n&pDev->HifIRQProcessingMode,\r\nsizeof(pDev->HifIRQProcessingMode));\r\nswitch (pDev->HifIRQProcessingMode) {\r\ncase HIF_DEVICE_IRQ_SYNC_ONLY:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN,("HIF Interrupt processing is SYNC ONLY\n"));\r\nHIFConfigureDevice(pDev->HIFDevice,\r\nHIF_DEVICE_GET_IRQ_YIELD_PARAMS,\r\n&pDev->HifIRQYieldParams,\r\nsizeof(pDev->HifIRQYieldParams));\r\nif (pDev->HifIRQYieldParams.RecvPacketYieldCount > 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN,\r\n("HIF requests that DSR yield per %d RECV packets \n",\r\npDev->HifIRQYieldParams.RecvPacketYieldCount));\r\npDev->DSRCanYield = true;\r\n}\r\nbreak;\r\ncase HIF_DEVICE_IRQ_ASYNC_SYNC:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("HIF Interrupt processing is ASYNC and SYNC\n"));\r\nbreak;\r\ndefault:\r\nA_ASSERT(false);\r\n}\r\npDev->HifMaskUmaskRecvEvent = NULL;\r\nHIFConfigureDevice(pDev->HIFDevice,\r\nHIF_DEVICE_GET_RECV_EVENT_MASK_UNMASK_FUNC,\r\n&pDev->HifMaskUmaskRecvEvent,\r\nsizeof(pDev->HifMaskUmaskRecvEvent));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("HIF special overrides : 0x%lX , 0x%lX\n",\r\n(unsigned long)pDev->GetPendingEventsFunc, (unsigned long)pDev->HifMaskUmaskRecvEvent));\r\nstatus = DevDisableInterrupts(pDev);\r\nif (status) {\r\nbreak;\r\n}\r\nstatus = DevSetupGMbox(pDev);\r\n} while (false);\r\nif (status) {\r\nif (pDev->HifAttached) {\r\nHIFDetachHTC(pDev->HIFDevice);\r\npDev->HifAttached = false;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint DevEnableInterrupts(struct ar6k_device *pDev)\r\n{\r\nint status;\r\nstruct ar6k_irq_enable_registers regs;\r\nLOCK_AR6K(pDev);\r\npDev->IrqEnableRegisters.int_status_enable = INT_STATUS_ENABLE_ERROR_SET(0x01) |\r\nINT_STATUS_ENABLE_CPU_SET(0x01) |\r\nINT_STATUS_ENABLE_COUNTER_SET(0x01);\r\nif (NULL == pDev->GetPendingEventsFunc) {\r\npDev->IrqEnableRegisters.int_status_enable |= INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);\r\n} else {\r\npDev->IrqEnableRegisters.int_status_enable &= ~INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);\r\n}\r\npDev->IrqEnableRegisters.cpu_int_status_enable = CPU_INT_STATUS_ENABLE_BIT_SET(0x00);\r\npDev->IrqEnableRegisters.error_status_enable =\r\nERROR_STATUS_ENABLE_RX_UNDERFLOW_SET(0x01) |\r\nERROR_STATUS_ENABLE_TX_OVERFLOW_SET(0x01);\r\npDev->IrqEnableRegisters.counter_int_status_enable =\r\nCOUNTER_INT_STATUS_ENABLE_BIT_SET(AR6K_TARGET_DEBUG_INTR_MASK);\r\nmemcpy(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);\r\nUNLOCK_AR6K(pDev);\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nINT_STATUS_ENABLE_ADDRESS,\r\n&regs.int_status_enable,\r\nAR6K_IRQ_ENABLE_REGS_SIZE,\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Failed to update interrupt control registers err: %d\n", status));\r\n}\r\nreturn status;\r\n}\r\nint DevDisableInterrupts(struct ar6k_device *pDev)\r\n{\r\nstruct ar6k_irq_enable_registers regs;\r\nLOCK_AR6K(pDev);\r\npDev->IrqEnableRegisters.int_status_enable = 0;\r\npDev->IrqEnableRegisters.cpu_int_status_enable = 0;\r\npDev->IrqEnableRegisters.error_status_enable = 0;\r\npDev->IrqEnableRegisters.counter_int_status_enable = 0;\r\nmemcpy(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);\r\nUNLOCK_AR6K(pDev);\r\nreturn HIFReadWrite(pDev->HIFDevice,\r\nINT_STATUS_ENABLE_ADDRESS,\r\n&regs.int_status_enable,\r\nAR6K_IRQ_ENABLE_REGS_SIZE,\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\n}\r\nint DevUnmaskInterrupts(struct ar6k_device *pDev)\r\n{\r\nint IntStatus = 0;\r\nDevDisableInterrupts(pDev);\r\n#ifdef THREAD_X\r\nIntStatus = DevEnableInterrupts(pDev);\r\nHIFUnMaskInterrupt(pDev->HIFDevice);\r\n#else\r\nHIFUnMaskInterrupt(pDev->HIFDevice);\r\nIntStatus = DevEnableInterrupts(pDev);\r\n#endif\r\nreturn IntStatus;\r\n}\r\nint DevMaskInterrupts(struct ar6k_device *pDev)\r\n{\r\nHIFMaskInterrupt(pDev->HIFDevice);\r\nreturn DevDisableInterrupts(pDev);\r\n}\r\nstatic void DevDoEnableDisableRecvAsyncHandler(void *Context, struct htc_packet *pPacket)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)Context;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevDoEnableDisableRecvAsyncHandler: (dev: 0x%lX)\n", (unsigned long)pDev));\r\nif (pPacket->Status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n(" Failed to disable receiver, status:%d \n", pPacket->Status));\r\n}\r\nAR6KFreeIOPacket(pDev,pPacket);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevDoEnableDisableRecvAsyncHandler \n"));\r\n}\r\nstatic int DevDoEnableDisableRecvOverride(struct ar6k_device *pDev, bool EnableRecv, bool AsyncMode)\r\n{\r\nint status = 0;\r\nstruct htc_packet *pIOPacket = NULL;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("DevDoEnableDisableRecvOverride: Enable:%d Mode:%d\n",\r\nEnableRecv,AsyncMode));\r\ndo {\r\nif (AsyncMode) {\r\npIOPacket = AR6KAllocIOPacket(pDev);\r\nif (NULL == pIOPacket) {\r\nstatus = A_NO_MEMORY;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\npIOPacket->Completion = DevDoEnableDisableRecvAsyncHandler;\r\npIOPacket->pContext = pDev;\r\nstatus = pDev->HifMaskUmaskRecvEvent(pDev->HIFDevice,\r\nEnableRecv ? HIF_UNMASK_RECV : HIF_MASK_RECV,\r\npIOPacket);\r\nbreak;\r\n}\r\nstatus = pDev->HifMaskUmaskRecvEvent(pDev->HIFDevice,\r\nEnableRecv ? HIF_UNMASK_RECV : HIF_MASK_RECV,\r\nNULL);\r\n} while (false);\r\nif (status && (pIOPacket != NULL)) {\r\nAR6KFreeIOPacket(pDev,pIOPacket);\r\n}\r\nreturn status;\r\n}\r\nstatic int DevDoEnableDisableRecvNormal(struct ar6k_device *pDev, bool EnableRecv, bool AsyncMode)\r\n{\r\nint status = 0;\r\nstruct htc_packet *pIOPacket = NULL;\r\nstruct ar6k_irq_enable_registers regs;\r\nLOCK_AR6K(pDev);\r\nif (EnableRecv) {\r\npDev->IrqEnableRegisters.int_status_enable |= INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);\r\n} else {\r\npDev->IrqEnableRegisters.int_status_enable &= ~INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);\r\n}\r\nmemcpy(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);\r\nUNLOCK_AR6K(pDev);\r\ndo {\r\nif (AsyncMode) {\r\npIOPacket = AR6KAllocIOPacket(pDev);\r\nif (NULL == pIOPacket) {\r\nstatus = A_NO_MEMORY;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nmemcpy(pIOPacket->pBuffer,&regs,AR6K_IRQ_ENABLE_REGS_SIZE);\r\npIOPacket->Completion = DevDoEnableDisableRecvAsyncHandler;\r\npIOPacket->pContext = pDev;\r\nHIFReadWrite(pDev->HIFDevice,\r\nINT_STATUS_ENABLE_ADDRESS,\r\npIOPacket->pBuffer,\r\nAR6K_IRQ_ENABLE_REGS_SIZE,\r\nHIF_WR_ASYNC_BYTE_INC,\r\npIOPacket);\r\nbreak;\r\n}\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nINT_STATUS_ENABLE_ADDRESS,\r\n&regs.int_status_enable,\r\nAR6K_IRQ_ENABLE_REGS_SIZE,\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\n} while (false);\r\nif (status && (pIOPacket != NULL)) {\r\nAR6KFreeIOPacket(pDev,pIOPacket);\r\n}\r\nreturn status;\r\n}\r\nint DevStopRecv(struct ar6k_device *pDev, bool AsyncMode)\r\n{\r\nif (NULL == pDev->HifMaskUmaskRecvEvent) {\r\nreturn DevDoEnableDisableRecvNormal(pDev,false,AsyncMode);\r\n} else {\r\nreturn DevDoEnableDisableRecvOverride(pDev,false,AsyncMode);\r\n}\r\n}\r\nint DevEnableRecv(struct ar6k_device *pDev, bool AsyncMode)\r\n{\r\nif (NULL == pDev->HifMaskUmaskRecvEvent) {\r\nreturn DevDoEnableDisableRecvNormal(pDev,true,AsyncMode);\r\n} else {\r\nreturn DevDoEnableDisableRecvOverride(pDev,true,AsyncMode);\r\n}\r\n}\r\nint DevWaitForPendingRecv(struct ar6k_device *pDev,u32 TimeoutInMs,bool *pbIsRecvPending)\r\n{\r\nint status = 0;\r\nu8 host_int_status = 0x0;\r\nu32 counter = 0x0;\r\nif(TimeoutInMs < 100)\r\n{\r\nTimeoutInMs = 100;\r\n}\r\ncounter = TimeoutInMs / 100;\r\ndo\r\n{\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nHOST_INT_STATUS_ADDRESS,\r\n&host_int_status,\r\nsizeof(u8),\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nif (status)\r\n{\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR,("DevWaitForPendingRecv:Read HOST_INT_STATUS_ADDRESS Failed 0x%X\n",status));\r\nbreak;\r\n}\r\nhost_int_status = !status ? (host_int_status & (1 << 0)):0;\r\nif(!host_int_status)\r\n{\r\nstatus = 0;\r\n*pbIsRecvPending = false;\r\nbreak;\r\n}\r\nelse\r\n{\r\n*pbIsRecvPending = true;\r\n}\r\nA_MDELAY(100);\r\ncounter--;\r\n}while(counter);\r\nreturn status;\r\n}\r\nvoid DevDumpRegisters(struct ar6k_device *pDev,\r\nstruct ar6k_irq_proc_registers *pIrqProcRegs,\r\nstruct ar6k_irq_enable_registers *pIrqEnableRegs)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("\n<------- Register Table -------->\n"));\r\nif (pIrqProcRegs != NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Host Int Status: 0x%x\n",pIrqProcRegs->host_int_status));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("CPU Int Status: 0x%x\n",pIrqProcRegs->cpu_int_status));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Error Int Status: 0x%x\n",pIrqProcRegs->error_int_status));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Counter Int Status: 0x%x\n",pIrqProcRegs->counter_int_status));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Mbox Frame: 0x%x\n",pIrqProcRegs->mbox_frame));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Rx Lookahead Valid: 0x%x\n",pIrqProcRegs->rx_lookahead_valid));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Rx Lookahead 0: 0x%x\n",pIrqProcRegs->rx_lookahead[0]));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Rx Lookahead 1: 0x%x\n",pIrqProcRegs->rx_lookahead[1]));\r\nif (pDev->MailBoxInfo.GMboxAddress != 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("GMBOX Host Int Status 2: 0x%x\n",pIrqProcRegs->host_int_status2));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("GMBOX RX Avail: 0x%x\n",pIrqProcRegs->gmbox_rx_avail));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("GMBOX lookahead alias 0: 0x%x\n",pIrqProcRegs->rx_gmbox_lookahead_alias[0]));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("GMBOX lookahead alias 1: 0x%x\n",pIrqProcRegs->rx_gmbox_lookahead_alias[1]));\r\n}\r\n}\r\nif (pIrqEnableRegs != NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Int Status Enable: 0x%x\n",pIrqEnableRegs->int_status_enable));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("Counter Int Status Enable: 0x%x\n",pIrqEnableRegs->counter_int_status_enable));\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("<------------------------------->\n"));\r\n}\r\nstatic struct hif_scatter_req *DevAllocScatterReq(struct hif_device *Context)\r\n{\r\nstruct dl_list *pItem;\r\nstruct ar6k_device *pDev = (struct ar6k_device *)Context;\r\nLOCK_AR6K(pDev);\r\npItem = DL_ListRemoveItemFromHead(&pDev->ScatterReqHead);\r\nUNLOCK_AR6K(pDev);\r\nif (pItem != NULL) {\r\nreturn A_CONTAINING_STRUCT(pItem, struct hif_scatter_req, ListLink);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void DevFreeScatterReq(struct hif_device *Context, struct hif_scatter_req *pReq)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)Context;\r\nLOCK_AR6K(pDev);\r\nDL_ListInsertTail(&pDev->ScatterReqHead, &pReq->ListLink);\r\nUNLOCK_AR6K(pDev);\r\n}\r\nint DevCopyScatterListToFromDMABuffer(struct hif_scatter_req *pReq, bool FromDMA)\r\n{\r\nu8 *pDMABuffer = NULL;\r\nint i, remaining;\r\nu32 length;\r\npDMABuffer = pReq->pScatterBounceBuffer;\r\nif (pDMABuffer == NULL) {\r\nA_ASSERT(false);\r\nreturn A_EINVAL;\r\n}\r\nremaining = (int)pReq->TotalLength;\r\nfor (i = 0; i < pReq->ValidScatterEntries; i++) {\r\nlength = min((int)pReq->ScatterList[i].Length, remaining);\r\nif (length != (int)pReq->ScatterList[i].Length) {\r\nA_ASSERT(false);\r\nreturn A_EINVAL;\r\n}\r\nif (FromDMA) {\r\nmemcpy(pReq->ScatterList[i].pBuffer, pDMABuffer , length);\r\n} else {\r\nmemcpy(pDMABuffer, pReq->ScatterList[i].pBuffer, length);\r\n}\r\npDMABuffer += length;\r\nremaining -= length;\r\n}\r\nreturn 0;\r\n}\r\nstatic void DevReadWriteScatterAsyncHandler(void *Context, struct htc_packet *pPacket)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)Context;\r\nstruct hif_scatter_req *pReq = (struct hif_scatter_req *)pPacket->pPktContext;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+DevReadWriteScatterAsyncHandler: (dev: 0x%lX)\n", (unsigned long)pDev));\r\npReq->CompletionStatus = pPacket->Status;\r\nAR6KFreeIOPacket(pDev,pPacket);\r\npReq->CompletionRoutine(pReq);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-DevReadWriteScatterAsyncHandler \n"));\r\n}\r\nstatic int DevReadWriteScatter(struct hif_device *Context, struct hif_scatter_req *pReq)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)Context;\r\nint status = 0;\r\nstruct htc_packet *pIOPacket = NULL;\r\nu32 request = pReq->Request;\r\ndo {\r\nif (pReq->TotalLength > AR6K_MAX_TRANSFER_SIZE_PER_SCATTER) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Invalid length: %d \n", pReq->TotalLength));\r\nbreak;\r\n}\r\nif (pReq->TotalLength == 0) {\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nif (request & HIF_ASYNCHRONOUS) {\r\npIOPacket = AR6KAllocIOPacket(pDev);\r\nif (NULL == pIOPacket) {\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\npIOPacket->pPktContext = pReq;\r\npIOPacket->Completion = DevReadWriteScatterAsyncHandler;\r\npIOPacket->pContext = pDev;\r\n}\r\nif (request & HIF_WRITE) {\r\nif (pReq->Address == pDev->MailBoxInfo.MboxProp[HTC_MAILBOX].ExtendedAddress) {\r\npReq->Address += pDev->MailBoxInfo.MboxProp[HTC_MAILBOX].ExtendedSize - pReq->TotalLength;\r\n}\r\n}\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\npReq->Address,\r\nDEV_GET_VIRT_DMA_INFO(pReq)->pVirtDmaBuffer,\r\npReq->TotalLength,\r\nrequest,\r\n(request & HIF_ASYNCHRONOUS) ? pIOPacket : NULL);\r\n} while (false);\r\nif ((status != A_PENDING) && status && (request & HIF_ASYNCHRONOUS)) {\r\nif (pIOPacket != NULL) {\r\nAR6KFreeIOPacket(pDev,pIOPacket);\r\n}\r\npReq->CompletionStatus = status;\r\npReq->CompletionRoutine(pReq);\r\nstatus = 0;\r\n}\r\nreturn status;\r\n}\r\nstatic void DevCleanupVirtualScatterSupport(struct ar6k_device *pDev)\r\n{\r\nstruct hif_scatter_req *pReq;\r\nwhile (1) {\r\npReq = DevAllocScatterReq((struct hif_device *)pDev);\r\nif (NULL == pReq) {\r\nbreak;\r\n}\r\nkfree(pReq);\r\n}\r\n}\r\nstatic int DevSetupVirtualScatterSupport(struct ar6k_device *pDev)\r\n{\r\nint status = 0;\r\nint bufferSize, sgreqSize;\r\nint i;\r\nstruct dev_scatter_dma_virtual_info *pVirtualInfo;\r\nstruct hif_scatter_req *pReq;\r\nbufferSize = sizeof(struct dev_scatter_dma_virtual_info) +\r\n2 * (A_GET_CACHE_LINE_BYTES()) + AR6K_MAX_TRANSFER_SIZE_PER_SCATTER;\r\nsgreqSize = sizeof(struct hif_scatter_req) +\r\n(AR6K_SCATTER_ENTRIES_PER_REQ - 1) * (sizeof(struct hif_scatter_item));\r\nfor (i = 0; i < AR6K_SCATTER_REQS; i++) {\r\npReq = (struct hif_scatter_req *)A_MALLOC(sgreqSize + bufferSize);\r\nif (NULL == pReq) {\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\nA_MEMZERO(pReq, sgreqSize);\r\npVirtualInfo = (struct dev_scatter_dma_virtual_info *)((u8 *)pReq + sgreqSize);\r\nA_MEMZERO(pVirtualInfo, sizeof(struct dev_scatter_dma_virtual_info));\r\npVirtualInfo->pVirtDmaBuffer = &pVirtualInfo->DataArea[0];\r\npVirtualInfo->pVirtDmaBuffer = A_ALIGN_TO_CACHE_LINE(pVirtualInfo->pVirtDmaBuffer);\r\npReq->HIFPrivate[0] = pVirtualInfo;\r\npReq->ScatterMethod = HIF_SCATTER_DMA_BOUNCE;\r\npReq->pScatterBounceBuffer = pVirtualInfo->pVirtDmaBuffer;\r\nDevFreeScatterReq((struct hif_device *)pDev,pReq);\r\n}\r\nif (status) {\r\nDevCleanupVirtualScatterSupport(pDev);\r\n} else {\r\npDev->HifScatterInfo.pAllocateReqFunc = DevAllocScatterReq;\r\npDev->HifScatterInfo.pFreeReqFunc = DevFreeScatterReq;\r\npDev->HifScatterInfo.pReadWriteScatterFunc = DevReadWriteScatter;\r\nif (pDev->MailBoxInfo.MboxBusIFType == MBOX_BUS_IF_SPI) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, ("AR6K: SPI bus requires RX scatter limits\n"));\r\npDev->HifScatterInfo.MaxScatterEntries = AR6K_MIN_SCATTER_ENTRIES_PER_REQ;\r\npDev->HifScatterInfo.MaxTransferSizePerScatterReq = AR6K_MIN_TRANSFER_SIZE_PER_SCATTER;\r\n} else {\r\npDev->HifScatterInfo.MaxScatterEntries = AR6K_SCATTER_ENTRIES_PER_REQ;\r\npDev->HifScatterInfo.MaxTransferSizePerScatterReq = AR6K_MAX_TRANSFER_SIZE_PER_SCATTER;\r\n}\r\npDev->ScatterIsVirtual = true;\r\n}\r\nreturn status;\r\n}\r\nint DevCleanupMsgBundling(struct ar6k_device *pDev)\r\n{\r\nif(NULL != pDev)\r\n{\r\nDevCleanupVirtualScatterSupport(pDev);\r\n}\r\nreturn 0;\r\n}\r\nint DevSetupMsgBundling(struct ar6k_device *pDev, int MaxMsgsPerTransfer)\r\n{\r\nint status;\r\nif (pDev->MailBoxInfo.Flags & HIF_MBOX_FLAG_NO_BUNDLING) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, ("HIF requires bundling disabled\n"));\r\nreturn A_ENOTSUP;\r\n}\r\nstatus = HIFConfigureDevice(pDev->HIFDevice,\r\nHIF_CONFIGURE_QUERY_SCATTER_REQUEST_SUPPORT,\r\n&pDev->HifScatterInfo,\r\nsizeof(pDev->HifScatterInfo));\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN,\r\n("AR6K: ** HIF layer does not support scatter requests (%d) \n",status));\r\nstatus = DevSetupVirtualScatterSupport(pDev);\r\nif (!status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("AR6K: virtual scatter transfers enabled (max scatter items:%d: maxlen:%d) \n",\r\nDEV_GET_MAX_MSG_PER_BUNDLE(pDev), DEV_GET_MAX_BUNDLE_LENGTH(pDev)));\r\n}\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("AR6K: HIF layer supports scatter requests (max scatter items:%d: maxlen:%d) \n",\r\nDEV_GET_MAX_MSG_PER_BUNDLE(pDev), DEV_GET_MAX_BUNDLE_LENGTH(pDev)));\r\n}\r\nif (!status) {\r\npDev->MaxRecvBundleSize = pDev->HifScatterInfo.MaxTransferSizePerScatterReq;\r\nif (pDev->MailBoxInfo.MboxBusIFType == MBOX_BUS_IF_SPI) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, ("AR6K : SPI bus requires TX bundling disabled\n"));\r\npDev->MaxSendBundleSize = 0;\r\n} else {\r\nif (pDev->MailBoxInfo.MboxProp[0].ExtendedAddress != 0) {\r\npDev->MaxSendBundleSize = pDev->MailBoxInfo.MboxProp[0].ExtendedSize;\r\n} else {\r\npDev->MaxSendBundleSize = AR6K_LEGACY_MAX_WRITE_LENGTH;\r\n}\r\nif (pDev->MaxSendBundleSize > pDev->HifScatterInfo.MaxTransferSizePerScatterReq) {\r\npDev->MaxSendBundleSize = pDev->HifScatterInfo.MaxTransferSizePerScatterReq;\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("AR6K: max recv: %d max send: %d \n",\r\nDEV_GET_MAX_BUNDLE_RECV_LENGTH(pDev), DEV_GET_MAX_BUNDLE_SEND_LENGTH(pDev)));\r\n}\r\nreturn status;\r\n}\r\nint DevSubmitScatterRequest(struct ar6k_device *pDev, struct hif_scatter_req *pScatterReq, bool Read, bool Async)\r\n{\r\nint status;\r\nif (Read) {\r\npScatterReq->Request = (Async) ? HIF_RD_ASYNC_BLOCK_FIX : HIF_RD_SYNC_BLOCK_FIX;\r\npScatterReq->Address = pDev->MailBoxInfo.MboxAddresses[HTC_MAILBOX];\r\nA_ASSERT(pScatterReq->TotalLength <= (u32)DEV_GET_MAX_BUNDLE_RECV_LENGTH(pDev));\r\n} else {\r\nu32 mailboxWidth;\r\npScatterReq->Request = (Async) ? HIF_WR_ASYNC_BLOCK_INC : HIF_WR_SYNC_BLOCK_INC;\r\nA_ASSERT(pScatterReq->TotalLength <= (u32)DEV_GET_MAX_BUNDLE_SEND_LENGTH(pDev));\r\nif (pScatterReq->TotalLength > AR6K_LEGACY_MAX_WRITE_LENGTH) {\r\npScatterReq->Address = pDev->MailBoxInfo.MboxProp[HTC_MAILBOX].ExtendedAddress;\r\nmailboxWidth = pDev->MailBoxInfo.MboxProp[HTC_MAILBOX].ExtendedSize;\r\n} else {\r\npScatterReq->Address = pDev->MailBoxInfo.MboxAddresses[HTC_MAILBOX];\r\nmailboxWidth = AR6K_LEGACY_MAX_WRITE_LENGTH;\r\n}\r\nif (!pDev->ScatterIsVirtual) {\r\npScatterReq->Address += (mailboxWidth - pScatterReq->TotalLength);\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV | ATH_DEBUG_SEND,\r\n("DevSubmitScatterRequest, Entries: %d, Total Length: %d Mbox:0x%X (mode: %s : %s)\n",\r\npScatterReq->ValidScatterEntries,\r\npScatterReq->TotalLength,\r\npScatterReq->Address,\r\nAsync ? "ASYNC" : "SYNC",\r\n(Read) ? "RD" : "WR"));\r\nstatus = DEV_PREPARE_SCATTER_OPERATION(pScatterReq);\r\nif (status) {\r\nif (Async) {\r\npScatterReq->CompletionStatus = status;\r\npScatterReq->CompletionRoutine(pScatterReq);\r\nreturn 0;\r\n}\r\nreturn status;\r\n}\r\nstatus = pDev->HifScatterInfo.pReadWriteScatterFunc(pDev->ScatterIsVirtual ? pDev : pDev->HIFDevice,\r\npScatterReq);\r\nif (!Async) {\r\npScatterReq->CompletionStatus = status;\r\nDEV_FINISH_SCATTER_OPERATION(pScatterReq);\r\n} else {\r\nif (status == A_PENDING) {\r\nstatus = 0;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void AssembleBufferList(struct buffer_proc_list *pList)\r\n{\r\nu8 *pBuffer = g_Buffer;\r\n#if BUFFER_PROC_LIST_DEPTH < 4\r\n#error "Buffer processing list depth is not deep enough!!"\r\n#endif\r\nPUSH_BUFF_PROC_ENTRY(pList,BUFFER1,pBuffer);\r\nPUSH_BUFF_PROC_ENTRY(pList,BUFFER2,pBuffer);\r\nPUSH_BUFF_PROC_ENTRY(pList,BUFFER3,pBuffer);\r\nPUSH_BUFF_PROC_ENTRY(pList,BUFFER4,pBuffer);\r\n}\r\nstatic void InitBuffers(bool Zero)\r\n{\r\nu16 *pBuffer16 = (u16 *)g_Buffer;\r\nint i;\r\nfor (i = 0; i < (TOTAL_BYTES / 2) ; i++) {\r\nif (!Zero) {\r\npBuffer16[i] = (u16)i;\r\n} else {\r\npBuffer16[i] = 0;\r\n}\r\n}\r\n}\r\nstatic bool CheckOneBuffer(u16 *pBuffer16, int Length)\r\n{\r\nint i;\r\nu16 startCount;\r\nbool success = true;\r\nstartCount = pBuffer16[0];\r\nstartCount = ~startCount;\r\nfor (i = 0; i < (Length / 2) ; i++,startCount++) {\r\nif ((u16)pBuffer16[i] != (u16)~startCount) {\r\nsuccess = false;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Invalid Data Got:0x%X, Expecting:0x%X (offset:%d, total:%d) \n",\r\npBuffer16[i], ((u16)~startCount), i, Length));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("0x%X 0x%X 0x%X 0x%X \n",\r\npBuffer16[i], pBuffer16[i + 1], pBuffer16[i + 2],pBuffer16[i+3]));\r\nbreak;\r\n}\r\n}\r\nreturn success;\r\n}\r\nstatic bool CheckBuffers(void)\r\n{\r\nint i;\r\nbool success = true;\r\nstruct buffer_proc_list checkList[BUFFER_PROC_LIST_DEPTH];\r\nAssembleBufferList(checkList);\r\nfor (i = 0; i < BUFFER_PROC_LIST_DEPTH ; i++) {\r\nsuccess = CheckOneBuffer((u16 *)checkList[i].pBuffer, checkList[i].length);\r\nif (!success) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Buffer : 0x%X, Length:%d failed verify \n",\r\n(u32)checkList[i].pBuffer, checkList[i].length));\r\nbreak;\r\n}\r\n}\r\nreturn success;\r\n}\r\nstatic u16 GetEndMarker(void)\r\n{\r\nu8 *pBuffer;\r\nstruct buffer_proc_list checkList[BUFFER_PROC_LIST_DEPTH];\r\nInitBuffers(FILL_COUNTING);\r\nAssembleBufferList(checkList);\r\npBuffer = &(checkList[BUFFER_PROC_LIST_DEPTH - 1].pBuffer[(checkList[BUFFER_PROC_LIST_DEPTH - 1].length) - 2]);\r\nreturn (u16)pBuffer[0] | ((u16)pBuffer[1] << 8);\r\n}\r\nstatic int SendBuffers(struct ar6k_device *pDev, int mbox)\r\n{\r\nint status = 0;\r\nu32 request = HIF_WR_SYNC_BLOCK_INC;\r\nstruct buffer_proc_list sendList[BUFFER_PROC_LIST_DEPTH];\r\nint i;\r\nint totalBytes = 0;\r\nint paddedLength;\r\nint totalwPadding = 0;\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Sending buffers on mailbox : %d \n",mbox));\r\nInitBuffers(FILL_COUNTING);\r\nAssembleBufferList(sendList);\r\nfor (i = 0; i < BUFFER_PROC_LIST_DEPTH; i++) {\r\npaddedLength = (sendList[i].length + (g_BlockSizes[mbox] - 1)) &\r\n(~(g_BlockSizes[mbox] - 1));\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\ng_MailboxAddrs[mbox],\r\nsendList[i].pBuffer,\r\npaddedLength,\r\nrequest,\r\nNULL);\r\nif (status) {\r\nbreak;\r\n}\r\ntotalBytes += sendList[i].length;\r\ntotalwPadding += paddedLength;\r\n}\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Sent %d bytes (%d padded bytes) to mailbox : %d \n",totalBytes,totalwPadding,mbox));\r\nreturn status;\r\n}\r\nstatic int GetCredits(struct ar6k_device *pDev, int mbox, int *pCredits)\r\n{\r\nint status = 0;\r\nint timeout = TEST_CREDITS_RECV_TIMEOUT;\r\nu8 credits = 0;\r\nu32 address;\r\nwhile (true) {\r\naddress = COUNT_DEC_ADDRESS + (AR6K_MAILBOXES + mbox) * 4;\r\nstatus = HIFReadWrite(pDev->HIFDevice, address, &credits, sizeof(credits),\r\nHIF_RD_SYNC_BYTE_FIX, NULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Unable to decrement the command credit count register (mbox=%d)\n",mbox));\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\nif (credits) {\r\nbreak;\r\n}\r\ntimeout--;\r\nif (timeout <= 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n(" Timeout reading credit registers (mbox=%d, address:0x%X) \n",mbox,address));\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\nA_MDELAY(1000);\r\n}\r\nif (status == 0) {\r\n*pCredits = credits;\r\n}\r\nreturn status;\r\n}\r\nstatic int RecvBuffers(struct ar6k_device *pDev, int mbox)\r\n{\r\nint status = 0;\r\nu32 request = HIF_RD_SYNC_BLOCK_INC;\r\nstruct buffer_proc_list recvList[BUFFER_PROC_LIST_DEPTH];\r\nint curBuffer;\r\nint credits;\r\nint i;\r\nint totalBytes = 0;\r\nint paddedLength;\r\nint totalwPadding = 0;\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Waiting for buffers on mailbox : %d \n",mbox));\r\nInitBuffers(FILL_ZERO);\r\nAssembleBufferList(recvList);\r\ncurBuffer = 0;\r\nwhile (curBuffer < BUFFER_PROC_LIST_DEPTH) {\r\nstatus = GetCredits(pDev, mbox, &credits);\r\nif (status) {\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Got %d messages on mailbox : %d \n",credits, mbox));\r\nfor (i = 0; i < credits; i++) {\r\nA_ASSERT(curBuffer < BUFFER_PROC_LIST_DEPTH);\r\npaddedLength = (recvList[curBuffer].length + (g_BlockSizes[mbox] - 1)) &\r\n(~(g_BlockSizes[mbox] - 1));\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\ng_MailboxAddrs[mbox],\r\nrecvList[curBuffer].pBuffer,\r\npaddedLength,\r\nrequest,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to read %d bytes on mailbox:%d : address:0x%X \n",\r\nrecvList[curBuffer].length, mbox, g_MailboxAddrs[mbox]));\r\nbreak;\r\n}\r\ntotalwPadding += paddedLength;\r\ntotalBytes += recvList[curBuffer].length;\r\ncurBuffer++;\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\ncredits = 0;\r\n}\r\nif (totalBytes != TEST_BYTES) {\r\nA_ASSERT(false);\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Got all buffers on mbox:%d total recv :%d (w/Padding : %d) \n",\r\nmbox, totalBytes, totalwPadding));\r\n}\r\nreturn status;\r\n}\r\nstatic int DoOneMboxHWTest(struct ar6k_device *pDev, int mbox)\r\n{\r\nint status;\r\ndo {\r\nstatus = SendBuffers(pDev,mbox);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Sending buffers Failed : %d mbox:%d\n",status,mbox));\r\nbreak;\r\n}\r\nstatus = RecvBuffers(pDev, mbox);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Recv buffers Failed : %d mbox:%d\n",status,mbox));\r\nbreak;\r\n}\r\nif (!CheckBuffers()) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Buffer Verify Failed : mbox:%d\n",mbox));\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" Send/Recv success! mailbox : %d \n",mbox));\r\n} while (false);\r\nreturn status;\r\n}\r\nint DoMboxHWTest(struct ar6k_device *pDev)\r\n{\r\nint i;\r\nint status;\r\nint credits = 0;\r\nu8 params[4];\r\nint numBufs;\r\nint bufferSize;\r\nu16 temp;\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest START - \n"));\r\ndo {\r\nstatus = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_ADDR,\r\ng_MailboxAddrs, sizeof(g_MailboxAddrs));\r\nif (status) {\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nstatus = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,\r\ng_BlockSizes, sizeof(g_BlockSizes));\r\nif (status) {\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\ng_BlockSizes[0] = g_BlockSizes[1];\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Block Size to use: %d \n",g_BlockSizes[0]));\r\nif (g_BlockSizes[1] > BUFFER_BLOCK_PAD) {\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("%d Block size is too large for buffer pad %d\n",\r\ng_BlockSizes[1], BUFFER_BLOCK_PAD));\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Waiting for target.... \n"));\r\nstatus = GetCredits(pDev, 0, &credits);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to wait for target ready \n"));\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Target is ready ...\n"));\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nSCRATCH_ADDRESS,\r\nparams,\r\n4,\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to wait get parameters \n"));\r\nbreak;\r\n}\r\nnumBufs = params[0];\r\nbufferSize = (int)(((u16)params[2] << 8) | (u16)params[1]);\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE,\r\n("Target parameters: bufs per mailbox:%d, buffer size:%d bytes (total space: %d, minimum required space (w/padding): %d) \n",\r\nnumBufs, bufferSize, (numBufs * bufferSize), TOTAL_BYTES));\r\nif ((numBufs * bufferSize) < TOTAL_BYTES) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Not Enough buffer space to run test! need:%d, got:%d \n",\r\nTOTAL_BYTES, (numBufs*bufferSize)));\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\ntemp = GetEndMarker();\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nSCRATCH_ADDRESS + 4,\r\n(u8 *)&temp,\r\n2,\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to write end marker \n"));\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("End Marker: 0x%X \n",temp));\r\ntemp = (u16)g_BlockSizes[1];\r\ntemp = temp - 1;\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nSCRATCH_ADDRESS + 6,\r\n(u8 *)&temp,\r\n2,\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to write block mask \n"));\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Set Block Mask: 0x%X \n",temp));\r\nfor (i = 0; i < AR6K_MAILBOXES; i++) {\r\nstatus = DoOneMboxHWTest(pDev, i);\r\nif (status) {\r\nbreak;\r\n}\r\n}\r\n} while (false);\r\nif (status == 0) {\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest DONE - SUCCESS! - \n"));\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest DONE - FAILED! - \n"));\r\n}\r\nreturn A_ERROR;\r\n}
