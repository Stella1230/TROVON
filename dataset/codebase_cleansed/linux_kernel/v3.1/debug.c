static void emac_desc_dump(struct emac_instance *p)\r\n{\r\nint i;\r\nprintk("** EMAC %s TX BDs **\n"\r\n" tx_cnt = %d tx_slot = %d ack_slot = %d\n",\r\np->ofdev->dev.of_node->full_name,\r\np->tx_cnt, p->tx_slot, p->ack_slot);\r\nfor (i = 0; i < NUM_TX_BUFF / 2; ++i)\r\nprintk\r\n("bd[%2d] 0x%08x %c 0x%04x %4u - bd[%2d] 0x%08x %c 0x%04x %4u\n",\r\ni, p->tx_desc[i].data_ptr, p->tx_skb[i] ? 'V' : ' ',\r\np->tx_desc[i].ctrl, p->tx_desc[i].data_len,\r\nNUM_TX_BUFF / 2 + i,\r\np->tx_desc[NUM_TX_BUFF / 2 + i].data_ptr,\r\np->tx_skb[NUM_TX_BUFF / 2 + i] ? 'V' : ' ',\r\np->tx_desc[NUM_TX_BUFF / 2 + i].ctrl,\r\np->tx_desc[NUM_TX_BUFF / 2 + i].data_len);\r\nprintk("** EMAC %s RX BDs **\n"\r\n" rx_slot = %d flags = 0x%lx rx_skb_size = %d rx_sync_size = %d\n"\r\n" rx_sg_skb = 0x%p\n",\r\np->ofdev->dev.of_node->full_name,\r\np->rx_slot, p->commac.flags, p->rx_skb_size,\r\np->rx_sync_size, p->rx_sg_skb);\r\nfor (i = 0; i < NUM_RX_BUFF / 2; ++i)\r\nprintk\r\n("bd[%2d] 0x%08x %c 0x%04x %4u - bd[%2d] 0x%08x %c 0x%04x %4u\n",\r\ni, p->rx_desc[i].data_ptr, p->rx_skb[i] ? 'V' : ' ',\r\np->rx_desc[i].ctrl, p->rx_desc[i].data_len,\r\nNUM_RX_BUFF / 2 + i,\r\np->rx_desc[NUM_RX_BUFF / 2 + i].data_ptr,\r\np->rx_skb[NUM_RX_BUFF / 2 + i] ? 'V' : ' ',\r\np->rx_desc[NUM_RX_BUFF / 2 + i].ctrl,\r\np->rx_desc[NUM_RX_BUFF / 2 + i].data_len);\r\n}\r\nstatic void emac_mac_dump(struct emac_instance *dev)\r\n{\r\nstruct emac_regs __iomem *p = dev->emacp;\r\nconst int xaht_regs = EMAC_XAHT_REGS(dev);\r\nu32 *gaht_base = emac_gaht_base(dev);\r\nu32 *iaht_base = emac_iaht_base(dev);\r\nint emac4sync = emac_has_feature(dev, EMAC_FTR_EMAC4SYNC);\r\nint n;\r\nprintk("** EMAC %s registers **\n"\r\n"MR0 = 0x%08x MR1 = 0x%08x TMR0 = 0x%08x TMR1 = 0x%08x\n"\r\n"RMR = 0x%08x ISR = 0x%08x ISER = 0x%08x\n"\r\n"IAR = %04x%08x VTPID = 0x%04x VTCI = 0x%04x\n",\r\ndev->ofdev->dev.of_node->full_name,\r\nin_be32(&p->mr0), in_be32(&p->mr1),\r\nin_be32(&p->tmr0), in_be32(&p->tmr1),\r\nin_be32(&p->rmr), in_be32(&p->isr), in_be32(&p->iser),\r\nin_be32(&p->iahr), in_be32(&p->ialr), in_be32(&p->vtpid),\r\nin_be32(&p->vtci)\r\n);\r\nif (emac4sync)\r\nprintk("MAR = %04x%08x MMAR = %04x%08x\n",\r\nin_be32(&p->u0.emac4sync.mahr),\r\nin_be32(&p->u0.emac4sync.malr),\r\nin_be32(&p->u0.emac4sync.mmahr),\r\nin_be32(&p->u0.emac4sync.mmalr)\r\n);\r\nfor (n = 0; n < xaht_regs; n++)\r\nprintk("IAHT%02d = 0x%08x\n", n + 1, in_be32(iaht_base + n));\r\nfor (n = 0; n < xaht_regs; n++)\r\nprintk("GAHT%02d = 0x%08x\n", n + 1, in_be32(gaht_base + n));\r\nprintk("LSA = %04x%08x IPGVR = 0x%04x\n"\r\n"STACR = 0x%08x TRTR = 0x%08x RWMR = 0x%08x\n"\r\n"OCTX = 0x%08x OCRX = 0x%08x\n",\r\nin_be32(&p->lsah), in_be32(&p->lsal), in_be32(&p->ipgvr),\r\nin_be32(&p->stacr), in_be32(&p->trtr), in_be32(&p->rwmr),\r\nin_be32(&p->octx), in_be32(&p->ocrx)\r\n);\r\nif (!emac4sync) {\r\nprintk("IPCR = 0x%08x\n",\r\nin_be32(&p->u1.emac4.ipcr)\r\n);\r\n} else {\r\nprintk("REVID = 0x%08x TPC = 0x%08x\n",\r\nin_be32(&p->u1.emac4sync.revid),\r\nin_be32(&p->u1.emac4sync.tpc)\r\n);\r\n}\r\nemac_desc_dump(dev);\r\n}\r\nstatic void emac_mal_dump(struct mal_instance *mal)\r\n{\r\nint i;\r\nprintk("** MAL %s Registers **\n"\r\n"CFG = 0x%08x ESR = 0x%08x IER = 0x%08x\n"\r\n"TX|CASR = 0x%08x CARR = 0x%08x EOBISR = 0x%08x DEIR = 0x%08x\n"\r\n"RX|CASR = 0x%08x CARR = 0x%08x EOBISR = 0x%08x DEIR = 0x%08x\n",\r\nmal->ofdev->dev.of_node->full_name,\r\nget_mal_dcrn(mal, MAL_CFG), get_mal_dcrn(mal, MAL_ESR),\r\nget_mal_dcrn(mal, MAL_IER),\r\nget_mal_dcrn(mal, MAL_TXCASR), get_mal_dcrn(mal, MAL_TXCARR),\r\nget_mal_dcrn(mal, MAL_TXEOBISR), get_mal_dcrn(mal, MAL_TXDEIR),\r\nget_mal_dcrn(mal, MAL_RXCASR), get_mal_dcrn(mal, MAL_RXCARR),\r\nget_mal_dcrn(mal, MAL_RXEOBISR), get_mal_dcrn(mal, MAL_RXDEIR)\r\n);\r\nprintk("TX|");\r\nfor (i = 0; i < mal->num_tx_chans; ++i) {\r\nif (i && !(i % 4))\r\nprintk("\n ");\r\nprintk("CTP%d = 0x%08x ", i, get_mal_dcrn(mal, MAL_TXCTPR(i)));\r\n}\r\nprintk("\nRX|");\r\nfor (i = 0; i < mal->num_rx_chans; ++i) {\r\nif (i && !(i % 4))\r\nprintk("\n ");\r\nprintk("CTP%d = 0x%08x ", i, get_mal_dcrn(mal, MAL_RXCTPR(i)));\r\n}\r\nprintk("\n ");\r\nfor (i = 0; i < mal->num_rx_chans; ++i) {\r\nu32 r = get_mal_dcrn(mal, MAL_RCBS(i));\r\nif (i && !(i % 3))\r\nprintk("\n ");\r\nprintk("RCBS%d = 0x%08x (%d) ", i, r, r * 16);\r\n}\r\nprintk("\n");\r\n}\r\nvoid emac_dbg_register(struct emac_instance *dev)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&emac_dbg_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(__emacs); i++)\r\nif (__emacs[i] == NULL) {\r\n__emacs[i] = dev;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&emac_dbg_lock, flags);\r\n}\r\nvoid emac_dbg_unregister(struct emac_instance *dev)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&emac_dbg_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(__emacs); i++)\r\nif (__emacs[i] == dev) {\r\n__emacs[i] = NULL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&emac_dbg_lock, flags);\r\n}\r\nvoid mal_dbg_register(struct mal_instance *mal)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&emac_dbg_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(__mals); i++)\r\nif (__mals[i] == NULL) {\r\n__mals[i] = mal;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&emac_dbg_lock, flags);\r\n}\r\nvoid mal_dbg_unregister(struct mal_instance *mal)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&emac_dbg_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(__mals); i++)\r\nif (__mals[i] == mal) {\r\n__mals[i] = NULL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&emac_dbg_lock, flags);\r\n}\r\nvoid emac_dbg_dump_all(void)\r\n{\r\nunsigned int i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emac_dbg_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(__mals); ++i)\r\nif (__mals[i])\r\nemac_mal_dump(__mals[i]);\r\nfor (i = 0; i < ARRAY_SIZE(__emacs); ++i)\r\nif (__emacs[i])\r\nemac_mac_dump(__emacs[i]);\r\nspin_unlock_irqrestore(&emac_dbg_lock, flags);\r\n}\r\nstatic void emac_sysrq_handler(int key)\r\n{\r\nemac_dbg_dump_all();\r\n}\r\nint __init emac_init_debug(void)\r\n{\r\nreturn register_sysrq_key('c', &emac_sysrq_op);\r\n}\r\nvoid __exit emac_fini_debug(void)\r\n{\r\nunregister_sysrq_key('c', &emac_sysrq_op);\r\n}\r\nint __init emac_init_debug(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid __exit emac_fini_debug(void)\r\n{\r\n}
