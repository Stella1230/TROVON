static inline struct indycam *to_indycam(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct indycam, sd);\r\n}\r\nstatic int indycam_read_reg(struct v4l2_subdev *sd, u8 reg, u8 *value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nif (reg == INDYCAM_REG_RESET) {\r\ndprintk("indycam_read_reg(): "\r\n"skipping write-only register %d\n", reg);\r\n*value = 0;\r\nreturn 0;\r\n}\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "IndyCam: indycam_read_reg(): read failed, "\r\n"register = 0x%02x\n", reg);\r\nreturn ret;\r\n}\r\n*value = (u8)ret;\r\nreturn 0;\r\n}\r\nstatic int indycam_write_reg(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint err;\r\nif (reg == INDYCAM_REG_BRIGHTNESS || reg == INDYCAM_REG_VERSION) {\r\ndprintk("indycam_write_reg(): "\r\n"skipping read-only register %d\n", reg);\r\nreturn 0;\r\n}\r\ndprintk("Writing Reg %d = 0x%02x\n", reg, value);\r\nerr = i2c_smbus_write_byte_data(client, reg, value);\r\nif (err) {\r\nprintk(KERN_ERR "IndyCam: indycam_write_reg(): write failed, "\r\n"register = 0x%02x, value = 0x%02x\n", reg, value);\r\n}\r\nreturn err;\r\n}\r\nstatic int indycam_write_block(struct v4l2_subdev *sd, u8 reg,\r\nu8 length, u8 *data)\r\n{\r\nint i, err;\r\nfor (i = 0; i < length; i++) {\r\nerr = indycam_write_reg(sd, reg + i, data[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void indycam_regdump_debug(struct v4l2_subdev *sd)\r\n{\r\nint i;\r\nu8 val;\r\nfor (i = 0; i < 9; i++) {\r\nindycam_read_reg(sd, i, &val);\r\ndprintk("Reg %d = 0x%02x\n", i, val);\r\n}\r\n}\r\nstatic int indycam_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct indycam *camera = to_indycam(sd);\r\nu8 reg;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nret = indycam_read_reg(sd, INDYCAM_REG_CONTROL, &reg);\r\nif (ret)\r\nreturn -EIO;\r\nif (ctrl->id == V4L2_CID_AUTOGAIN)\r\nctrl->value = (reg & INDYCAM_CONTROL_AGCENA)\r\n? 1 : 0;\r\nelse\r\nctrl->value = (reg & INDYCAM_CONTROL_AWBCTL)\r\n? 1 : 0;\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nret = indycam_read_reg(sd, INDYCAM_REG_SHUTTER, &reg);\r\nif (ret)\r\nreturn -EIO;\r\nctrl->value = ((s32)reg == 0x00) ? 0xff : ((s32)reg - 1);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nret = indycam_read_reg(sd, INDYCAM_REG_GAIN, &reg);\r\nif (ret)\r\nreturn -EIO;\r\nctrl->value = (s32)reg;\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nret = indycam_read_reg(sd, INDYCAM_REG_RED_BALANCE, &reg);\r\nif (ret)\r\nreturn -EIO;\r\nctrl->value = (s32)reg;\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nret = indycam_read_reg(sd, INDYCAM_REG_BLUE_BALANCE, &reg);\r\nif (ret)\r\nreturn -EIO;\r\nctrl->value = (s32)reg;\r\nbreak;\r\ncase INDYCAM_CONTROL_RED_SATURATION:\r\nret = indycam_read_reg(sd,\r\nINDYCAM_REG_RED_SATURATION, &reg);\r\nif (ret)\r\nreturn -EIO;\r\nctrl->value = (s32)reg;\r\nbreak;\r\ncase INDYCAM_CONTROL_BLUE_SATURATION:\r\nret = indycam_read_reg(sd,\r\nINDYCAM_REG_BLUE_SATURATION, &reg);\r\nif (ret)\r\nreturn -EIO;\r\nctrl->value = (s32)reg;\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nif (camera->version == CAMERA_VERSION_MOOSE) {\r\nret = indycam_read_reg(sd,\r\nINDYCAM_REG_GAMMA, &reg);\r\nif (ret)\r\nreturn -EIO;\r\nctrl->value = (s32)reg;\r\n} else {\r\nctrl->value = INDYCAM_GAMMA_DEFAULT;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int indycam_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct indycam *camera = to_indycam(sd);\r\nu8 reg;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nret = indycam_read_reg(sd, INDYCAM_REG_CONTROL, &reg);\r\nif (ret)\r\nbreak;\r\nif (ctrl->id == V4L2_CID_AUTOGAIN) {\r\nif (ctrl->value)\r\nreg |= INDYCAM_CONTROL_AGCENA;\r\nelse\r\nreg &= ~INDYCAM_CONTROL_AGCENA;\r\n} else {\r\nif (ctrl->value)\r\nreg |= INDYCAM_CONTROL_AWBCTL;\r\nelse\r\nreg &= ~INDYCAM_CONTROL_AWBCTL;\r\n}\r\nret = indycam_write_reg(sd, INDYCAM_REG_CONTROL, reg);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nreg = (ctrl->value == 0xff) ? 0x00 : (ctrl->value + 1);\r\nret = indycam_write_reg(sd, INDYCAM_REG_SHUTTER, reg);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nret = indycam_write_reg(sd, INDYCAM_REG_GAIN, ctrl->value);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nret = indycam_write_reg(sd, INDYCAM_REG_RED_BALANCE,\r\nctrl->value);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nret = indycam_write_reg(sd, INDYCAM_REG_BLUE_BALANCE,\r\nctrl->value);\r\nbreak;\r\ncase INDYCAM_CONTROL_RED_SATURATION:\r\nret = indycam_write_reg(sd, INDYCAM_REG_RED_SATURATION,\r\nctrl->value);\r\nbreak;\r\ncase INDYCAM_CONTROL_BLUE_SATURATION:\r\nret = indycam_write_reg(sd, INDYCAM_REG_BLUE_SATURATION,\r\nctrl->value);\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nif (camera->version == CAMERA_VERSION_MOOSE) {\r\nret = indycam_write_reg(sd, INDYCAM_REG_GAMMA,\r\nctrl->value);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int indycam_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct indycam *camera = to_indycam(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_INDYCAM,\r\ncamera->version);\r\n}\r\nstatic int indycam_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint err = 0;\r\nstruct indycam *camera;\r\nstruct v4l2_subdev *sd;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\ncamera = kzalloc(sizeof(struct indycam), GFP_KERNEL);\r\nif (!camera)\r\nreturn -ENOMEM;\r\nsd = &camera->sd;\r\nv4l2_i2c_subdev_init(sd, client, &indycam_ops);\r\ncamera->version = i2c_smbus_read_byte_data(client,\r\nINDYCAM_REG_VERSION);\r\nif (camera->version != CAMERA_VERSION_INDY &&\r\ncamera->version != CAMERA_VERSION_MOOSE) {\r\nkfree(camera);\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "IndyCam v%d.%d detected\n",\r\nINDYCAM_VERSION_MAJOR(camera->version),\r\nINDYCAM_VERSION_MINOR(camera->version));\r\nindycam_regdump(sd);\r\nerr = indycam_write_block(sd, 0, sizeof(initseq), (u8 *)&initseq);\r\nif (err) {\r\nprintk(KERN_ERR "IndyCam initialization failed\n");\r\nkfree(camera);\r\nreturn -EIO;\r\n}\r\nindycam_regdump(sd);\r\nerr = indycam_write_reg(sd, INDYCAM_REG_CONTROL,\r\nINDYCAM_CONTROL_AGCENA | INDYCAM_CONTROL_AWBCTL);\r\nif (err) {\r\nprintk(KERN_ERR "IndyCam: White balancing camera failed\n");\r\nkfree(camera);\r\nreturn -EIO;\r\n}\r\nindycam_regdump(sd);\r\nprintk(KERN_INFO "IndyCam initialized\n");\r\nreturn 0;\r\n}\r\nstatic int indycam_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_indycam(sd));\r\nreturn 0;\r\n}\r\nstatic __init int init_indycam(void)\r\n{\r\nreturn i2c_add_driver(&indycam_driver);\r\n}\r\nstatic __exit void exit_indycam(void)\r\n{\r\ni2c_del_driver(&indycam_driver);\r\n}
