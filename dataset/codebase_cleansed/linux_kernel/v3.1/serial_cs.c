static void quirk_setup_brainboxes_0104(struct pcmcia_device *link, struct uart_port *port)\r\n{\r\nport->uartclk = 14745600;\r\n}\r\nstatic int quirk_post_ibm(struct pcmcia_device *link)\r\n{\r\nu8 val;\r\nint ret;\r\nret = pcmcia_read_config_byte(link, 0x800, &val);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_write_config_byte(link, 0x800, val | 1);\r\nif (ret)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\nreturn -ENODEV;\r\n}\r\nstatic void quirk_config_nokia(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nif (info->multi > 1)\r\ninfo->multi = 1;\r\n}\r\nstatic void quirk_wakeup_oxsemi(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nif (info->c950ctrl)\r\noutb(12, info->c950ctrl + 1);\r\n}\r\nstatic void quirk_wakeup_possio_gcc(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nunsigned int ctrl = info->c950ctrl;\r\noutb(0xA, ctrl + 1);\r\nmsleep(100);\r\noutb(0xE, ctrl + 1);\r\nmsleep(300);\r\noutb(0xC, ctrl + 1);\r\nmsleep(100);\r\noutb(0xE, ctrl + 1);\r\nmsleep(200);\r\noutb(0xF, ctrl + 1);\r\nmsleep(100);\r\noutb(0xE, ctrl + 1);\r\nmsleep(100);\r\noutb(0xC, ctrl + 1);\r\n}\r\nstatic void quirk_config_socket(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nif (info->multi)\r\nlink->config_flags |= CONF_ENABLE_ESR;\r\n}\r\nstatic void serial_remove(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nint i;\r\ndev_dbg(&link->dev, "serial_release\n");\r\nfor (i = 0; i < info->ndev; i++)\r\nserial8250_unregister_port(info->line[i]);\r\nif (!info->slave)\r\npcmcia_disable_device(link);\r\n}\r\nstatic int serial_suspend(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nint i;\r\nfor (i = 0; i < info->ndev; i++)\r\nserial8250_suspend_port(info->line[i]);\r\nreturn 0;\r\n}\r\nstatic int serial_resume(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nint i;\r\nfor (i = 0; i < info->ndev; i++)\r\nserial8250_resume_port(info->line[i]);\r\nif (info->quirk && info->quirk->wakeup)\r\ninfo->quirk->wakeup(link);\r\nreturn 0;\r\n}\r\nstatic int serial_probe(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info;\r\ndev_dbg(&link->dev, "serial_attach()\n");\r\ninfo = kzalloc(sizeof (*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\nif (do_sound)\r\nlink->config_flags |= CONF_ENABLE_SPKR;\r\nreturn serial_config(link);\r\n}\r\nstatic void serial_detach(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\ndev_dbg(&link->dev, "serial_detach\n");\r\nserial_remove(link);\r\nkfree(info);\r\n}\r\nstatic int setup_serial(struct pcmcia_device *handle, struct serial_info * info,\r\nunsigned int iobase, int irq)\r\n{\r\nstruct uart_port port;\r\nint line;\r\nmemset(&port, 0, sizeof (struct uart_port));\r\nport.iobase = iobase;\r\nport.irq = irq;\r\nport.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_SHARE_IRQ;\r\nport.uartclk = 1843200;\r\nport.dev = &handle->dev;\r\nif (buggy_uart)\r\nport.flags |= UPF_BUGGY_UART;\r\nif (info->quirk && info->quirk->setup)\r\ninfo->quirk->setup(handle, &port);\r\nline = serial8250_register_port(&port);\r\nif (line < 0) {\r\nprintk(KERN_NOTICE "serial_cs: serial8250_register_port() at "\r\n"0x%04lx, irq %d failed\n", (u_long)iobase, irq);\r\nreturn -EINVAL;\r\n}\r\ninfo->line[info->ndev] = line;\r\ninfo->ndev++;\r\nreturn 0;\r\n}\r\nstatic int pfc_config(struct pcmcia_device *p_dev)\r\n{\r\nunsigned int port = 0;\r\nstruct serial_info *info = p_dev->priv;\r\nif ((p_dev->resource[1]->end != 0) &&\r\n(resource_size(p_dev->resource[1]) == 8)) {\r\nport = p_dev->resource[1]->start;\r\ninfo->slave = 1;\r\n} else if ((info->manfid == MANFID_OSITECH) &&\r\n(resource_size(p_dev->resource[0]) == 0x40)) {\r\nport = p_dev->resource[0]->start + 0x28;\r\ninfo->slave = 1;\r\n}\r\nif (info->slave)\r\nreturn setup_serial(p_dev, info, port, p_dev->irq);\r\ndev_warn(&p_dev->dev, "no usable port range found, giving up\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int simple_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nstatic const int size_table[2] = { 8, 16 };\r\nint *try = priv_data;\r\nif (p_dev->resource[0]->start == 0)\r\nreturn -ENODEV;\r\nif ((*try & 0x1) == 0)\r\np_dev->io_lines = 16;\r\nif (p_dev->resource[0]->end != size_table[(*try >> 1)])\r\nreturn -ENODEV;\r\np_dev->resource[0]->end = 8;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int simple_config_check_notpicky(struct pcmcia_device *p_dev,\r\nvoid *priv_data)\r\n{\r\nstatic const unsigned int base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };\r\nint j;\r\nif (p_dev->io_lines > 3)\r\nreturn -ENODEV;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\np_dev->resource[0]->end = 8;\r\nfor (j = 0; j < 5; j++) {\r\np_dev->resource[0]->start = base[j];\r\np_dev->io_lines = base[j] ? 16 : 3;\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int simple_config(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nint i = -ENODEV, try;\r\nlink->config_flags |= CONF_AUTO_SET_VPP | CONF_AUTO_SET_IO;\r\nfor (try = 0; try < 4; try++)\r\nif (!pcmcia_loop_config(link, simple_config_check, &try))\r\ngoto found_port;\r\nif (!pcmcia_loop_config(link, simple_config_check_notpicky, NULL))\r\ngoto found_port;\r\ndev_warn(&link->dev, "no usable port range found, giving up\n");\r\nreturn -1;\r\nfound_port:\r\nif (info->multi && (info->manfid == MANFID_3COM))\r\nlink->config_index &= ~(0x08);\r\nif (info->quirk && info->quirk->config)\r\ninfo->quirk->config(link);\r\ni = pcmcia_enable_device(link);\r\nif (i != 0)\r\nreturn -1;\r\nreturn setup_serial(link, info, link->resource[0]->start, link->irq);\r\n}\r\nstatic int multi_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint *multi = priv_data;\r\nif (p_dev->resource[1]->end)\r\nreturn -EINVAL;\r\nif (p_dev->resource[0]->end <= 8)\r\nreturn -EINVAL;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\np_dev->resource[0]->end = *multi * 8;\r\nif (pcmcia_request_io(p_dev))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int multi_config_check_notpicky(struct pcmcia_device *p_dev,\r\nvoid *priv_data)\r\n{\r\nint *base2 = priv_data;\r\nif (!p_dev->resource[0]->end || !p_dev->resource[1]->end)\r\nreturn -ENODEV;\r\np_dev->resource[0]->end = p_dev->resource[1]->end = 8;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nif (pcmcia_request_io(p_dev))\r\nreturn -ENODEV;\r\n*base2 = p_dev->resource[0]->start + 8;\r\nreturn 0;\r\n}\r\nstatic int multi_config(struct pcmcia_device *link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nint i, base2 = 0;\r\nlink->config_flags |= CONF_AUTO_SET_IO;\r\nif (!pcmcia_loop_config(link, multi_config_check, &info->multi))\r\nbase2 = link->resource[0]->start + 8;\r\nelse {\r\ninfo->multi = 2;\r\nif (pcmcia_loop_config(link, multi_config_check_notpicky,\r\n&base2)) {\r\ndev_warn(&link->dev, "no usable port range "\r\n"found, giving up\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (!link->irq)\r\ndev_warn(&link->dev, "no usable IRQ found, continuing...\n");\r\nif (info->quirk && info->quirk->config)\r\ninfo->quirk->config(link);\r\ni = pcmcia_enable_device(link);\r\nif (i != 0)\r\nreturn -ENODEV;\r\nif (info->manfid == MANFID_OXSEMI || (info->manfid == MANFID_POSSIO &&\r\ninfo->prodid == PRODID_POSSIO_GCC)) {\r\nint err;\r\nif (link->config_index == 1 ||\r\nlink->config_index == 3) {\r\nerr = setup_serial(link, info, base2,\r\nlink->irq);\r\nbase2 = link->resource[0]->start;\r\n} else {\r\nerr = setup_serial(link, info, link->resource[0]->start,\r\nlink->irq);\r\n}\r\ninfo->c950ctrl = base2;\r\nif (info->quirk && info->quirk->wakeup)\r\ninfo->quirk->wakeup(link);\r\nreturn 0;\r\n}\r\nsetup_serial(link, info, link->resource[0]->start, link->irq);\r\nfor (i = 0; i < info->multi - 1; i++)\r\nsetup_serial(link, info, base2 + (8 * i),\r\nlink->irq);\r\nreturn 0;\r\n}\r\nstatic int serial_check_for_multi(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nstruct serial_info *info = p_dev->priv;\r\nif (!p_dev->resource[0]->end)\r\nreturn -EINVAL;\r\nif ((!p_dev->resource[1]->end) && (p_dev->resource[0]->end % 8 == 0))\r\ninfo->multi = p_dev->resource[0]->end >> 3;\r\nif ((p_dev->resource[1]->end) && (p_dev->resource[0]->end == 8)\r\n&& (p_dev->resource[1]->end == 8))\r\ninfo->multi = 2;\r\nreturn 0;\r\n}\r\nstatic int serial_config(struct pcmcia_device * link)\r\n{\r\nstruct serial_info *info = link->priv;\r\nint i;\r\ndev_dbg(&link->dev, "serial_config\n");\r\ninfo->multi = (link->socket->functions > 1);\r\ninfo->manfid = link->manf_id;\r\ninfo->prodid = link->card_id;\r\nfor (i = 0; i < ARRAY_SIZE(quirks); i++)\r\nif ((quirks[i].manfid == ~0 ||\r\nquirks[i].manfid == info->manfid) &&\r\n(quirks[i].prodid == ~0 ||\r\nquirks[i].prodid == info->prodid)) {\r\ninfo->quirk = &quirks[i];\r\nbreak;\r\n}\r\nif ((info->multi == 0) &&\r\n(link->has_func_id) &&\r\n(link->socket->pcmcia_pfc == 0) &&\r\n((link->func_id == CISTPL_FUNCID_MULTI) ||\r\n(link->func_id == CISTPL_FUNCID_SERIAL)))\r\npcmcia_loop_config(link, serial_check_for_multi, info);\r\nif (info->quirk && info->quirk->multi != -1)\r\ninfo->multi = info->quirk->multi;\r\ndev_info(&link->dev,\r\n"trying to set up [0x%04x:0x%04x] (pfc: %d, multi: %d, quirk: %p)\n",\r\nlink->manf_id, link->card_id,\r\nlink->socket->pcmcia_pfc, info->multi, info->quirk);\r\nif (link->socket->pcmcia_pfc)\r\ni = pfc_config(link);\r\nelse if (info->multi > 1)\r\ni = multi_config(link);\r\nelse\r\ni = simple_config(link);\r\nif (i || info->ndev == 0)\r\ngoto failed;\r\nif (info->quirk && info->quirk->post)\r\nif (info->quirk->post(link))\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\ndev_warn(&link->dev, "failed to initialize\n");\r\nserial_remove(link);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init init_serial_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&serial_cs_driver);\r\n}\r\nstatic void __exit exit_serial_cs(void)\r\n{\r\npcmcia_unregister_driver(&serial_cs_driver);\r\n}
