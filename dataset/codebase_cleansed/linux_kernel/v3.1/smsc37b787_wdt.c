static inline void open_io_config(void)\r\n{\r\noutb(0x55, IOPORT);\r\nmdelay(1);\r\noutb(0x55, IOPORT);\r\n}\r\nstatic inline void close_io_config(void)\r\n{\r\noutb(0xAA, IOPORT);\r\n}\r\nstatic inline void select_io_device(unsigned char devno)\r\n{\r\noutb(0x07, IOPORT);\r\noutb(devno, IOPORT+1);\r\n}\r\nstatic inline void write_io_cr(unsigned char reg, unsigned char data)\r\n{\r\noutb(reg, IOPORT);\r\noutb(data, IOPORT+1);\r\n}\r\nstatic inline char read_io_cr(unsigned char reg)\r\n{\r\noutb(reg, IOPORT);\r\nreturn inb(IOPORT+1);\r\n}\r\nstatic inline void gpio_bit12(unsigned char reg)\r\n{\r\nwrite_io_cr(0xE2, reg);\r\n}\r\nstatic inline void gpio_bit13(unsigned char reg)\r\n{\r\nwrite_io_cr(0xE3, reg);\r\n}\r\nstatic inline void wdt_timer_units(unsigned char new_units)\r\n{\r\nwrite_io_cr(0xF1, new_units);\r\n}\r\nstatic inline void wdt_timeout_value(unsigned char new_timeout)\r\n{\r\nwrite_io_cr(0xF2, new_timeout);\r\n}\r\nstatic inline void wdt_timer_conf(unsigned char conf)\r\n{\r\nwrite_io_cr(0xF3, conf);\r\n}\r\nstatic inline void wdt_timer_ctrl(unsigned char reg)\r\n{\r\nwrite_io_cr(0xF4, reg);\r\n}\r\nstatic void wb_smsc_wdt_initialize(void)\r\n{\r\nunsigned char old;\r\nspin_lock(&io_lock);\r\nopen_io_config();\r\nselect_io_device(IODEV_NO);\r\ngpio_bit13(0x08);\r\ngpio_bit12(0x0A);\r\nwdt_timeout_value(0);\r\nwdt_timer_ctrl(0x00);\r\nwdt_timer_conf(0x00);\r\nold = read_io_cr(0xF1) & 0x7F;\r\nif (unit == UNIT_SECOND)\r\nold |= 0x80;\r\nwdt_timer_units(old);\r\nclose_io_config();\r\nspin_unlock(&io_lock);\r\n}\r\nstatic void wb_smsc_wdt_shutdown(void)\r\n{\r\nspin_lock(&io_lock);\r\nopen_io_config();\r\nselect_io_device(IODEV_NO);\r\ngpio_bit13(0x09);\r\ngpio_bit12(0x09);\r\nwdt_timer_conf(0x00);\r\nwdt_timer_ctrl(0x00);\r\nwdt_timeout_value(0x00);\r\nclose_io_config();\r\nspin_unlock(&io_lock);\r\n}\r\nstatic void wb_smsc_wdt_set_timeout(unsigned char new_timeout)\r\n{\r\nspin_lock(&io_lock);\r\nopen_io_config();\r\nselect_io_device(IODEV_NO);\r\nwdt_timer_ctrl((new_timeout == 0) ? 0x00 : 0x02);\r\nwdt_timeout_value(new_timeout);\r\nclose_io_config();\r\nspin_unlock(&io_lock);\r\n}\r\nstatic unsigned char wb_smsc_wdt_get_timeout(void)\r\n{\r\nunsigned char set_timeout;\r\nspin_lock(&io_lock);\r\nopen_io_config();\r\nselect_io_device(IODEV_NO);\r\nset_timeout = read_io_cr(0xF2);\r\nclose_io_config();\r\nspin_unlock(&io_lock);\r\nreturn set_timeout;\r\n}\r\nstatic void wb_smsc_wdt_disable(void)\r\n{\r\nwb_smsc_wdt_set_timeout(0);\r\n}\r\nstatic void wb_smsc_wdt_enable(void)\r\n{\r\nwb_smsc_wdt_set_timeout(timeout);\r\n}\r\nstatic void wb_smsc_wdt_reset_timer(void)\r\n{\r\nspin_lock(&io_lock);\r\nopen_io_config();\r\nselect_io_device(IODEV_NO);\r\nwdt_timeout_value(timeout);\r\nwdt_timer_conf(0x08);\r\nclose_io_config();\r\nspin_unlock(&io_lock);\r\n}\r\nstatic int wb_smsc_wdt_status(void)\r\n{\r\nreturn (wb_smsc_wdt_get_timeout() == 0) ? 0 : WDIOF_KEEPALIVEPING;\r\n}\r\nstatic int wb_smsc_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &timer_enabled))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nwb_smsc_wdt_enable();\r\nprintk(KERN_INFO MODNAME\r\n"Watchdog enabled. Timeout set to %d %s.\n",\r\ntimeout, (unit == UNIT_SECOND) ? "second(s)" : "minute(s)");\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wb_smsc_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42) {\r\nwb_smsc_wdt_disable();\r\nprintk(KERN_INFO MODNAME\r\n"Watchdog disabled, sleeping again...\n");\r\n} else {\r\nprintk(KERN_CRIT MODNAME\r\n"Unexpected close, not stopping watchdog!\n");\r\nwb_smsc_wdt_reset_timer();\r\n}\r\nclear_bit(0, &timer_enabled);\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t wb_smsc_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nwb_smsc_wdt_reset_timer();\r\n}\r\nreturn len;\r\n}\r\nstatic long wb_smsc_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint new_timeout;\r\nunion {\r\nstruct watchdog_info __user *ident;\r\nint __user *i;\r\n} uarg;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING |\r\nWDIOF_SETTIMEOUT |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 0,\r\n.identity = "SMsC 37B787 Watchdog",\r\n};\r\nuarg.i = (int __user *)arg;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(uarg.ident, &ident, sizeof(ident))\r\n? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nreturn put_user(wb_smsc_wdt_status(), uarg.i);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, uarg.i);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint options, retval = -EINVAL;\r\nif (get_user(options, uarg.i))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nwb_smsc_wdt_disable();\r\nretval = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nwb_smsc_wdt_enable();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nwb_smsc_wdt_reset_timer();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, uarg.i))\r\nreturn -EFAULT;\r\nif (unit == UNIT_MINUTE)\r\nnew_timeout /= 60;\r\nif (new_timeout < 0 || new_timeout > MAX_TIMEOUT)\r\nreturn -EINVAL;\r\ntimeout = new_timeout;\r\nwb_smsc_wdt_set_timeout(timeout);\r\ncase WDIOC_GETTIMEOUT:\r\nnew_timeout = timeout;\r\nif (unit == UNIT_MINUTE)\r\nnew_timeout *= 60;\r\nreturn put_user(new_timeout, uarg.i);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int wb_smsc_wdt_notify_sys(struct notifier_block *this,\r\nunsigned long code, void *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT) {\r\ntimeout = 0;\r\nwb_smsc_wdt_disable();\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init wb_smsc_wdt_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "SMsC 37B787 watchdog component driver "\r\nVERSION " initialising...\n");\r\nif (!request_region(IOPORT, IOPORT_SIZE, "SMsC 37B787 watchdog")) {\r\nprintk(KERN_ERR MODNAME "Unable to register IO port %#x\n",\r\nIOPORT);\r\nret = -EBUSY;\r\ngoto out_pnp;\r\n}\r\nif (timeout > MAX_TIMEOUT)\r\ntimeout = MAX_TIMEOUT;\r\nwb_smsc_wdt_initialize();\r\nret = register_reboot_notifier(&wb_smsc_wdt_notifier);\r\nif (ret) {\r\nprintk(KERN_ERR MODNAME\r\n"Unable to register reboot notifier err = %d\n", ret);\r\ngoto out_io;\r\n}\r\nret = misc_register(&wb_smsc_wdt_miscdev);\r\nif (ret) {\r\nprintk(KERN_ERR MODNAME\r\n"Unable to register miscdev on minor %d\n",\r\nWATCHDOG_MINOR);\r\ngoto out_rbt;\r\n}\r\nprintk(KERN_INFO MODNAME "Timeout set to %d %s.\n",\r\ntimeout, (unit == UNIT_SECOND) ? "second(s)" : "minute(s)");\r\nprintk(KERN_INFO MODNAME\r\n"Watchdog initialized and sleeping (nowayout=%d)...\n",\r\nnowayout);\r\nout_clean:\r\nreturn ret;\r\nout_rbt:\r\nunregister_reboot_notifier(&wb_smsc_wdt_notifier);\r\nout_io:\r\nrelease_region(IOPORT, IOPORT_SIZE);\r\nout_pnp:\r\ngoto out_clean;\r\n}\r\nstatic void __exit wb_smsc_wdt_exit(void)\r\n{\r\nif (!nowayout) {\r\nwb_smsc_wdt_shutdown();\r\nprintk(KERN_INFO MODNAME "Watchdog disabled.\n");\r\n}\r\nmisc_deregister(&wb_smsc_wdt_miscdev);\r\nunregister_reboot_notifier(&wb_smsc_wdt_notifier);\r\nrelease_region(IOPORT, IOPORT_SIZE);\r\nprintk(KERN_INFO "SMsC 37B787 watchdog component driver removed.\n");\r\n}
