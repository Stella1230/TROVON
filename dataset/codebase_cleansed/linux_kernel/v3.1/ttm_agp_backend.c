static int ttm_agp_populate(struct ttm_backend *backend,\r\nunsigned long num_pages, struct page **pages,\r\nstruct page *dummy_read_page,\r\ndma_addr_t *dma_addrs)\r\n{\r\nstruct ttm_agp_backend *agp_be =\r\ncontainer_of(backend, struct ttm_agp_backend, backend);\r\nstruct page **cur_page, **last_page = pages + num_pages;\r\nstruct agp_memory *mem;\r\nmem = agp_allocate_memory(agp_be->bridge, num_pages, AGP_USER_MEMORY);\r\nif (unlikely(mem == NULL))\r\nreturn -ENOMEM;\r\nmem->page_count = 0;\r\nfor (cur_page = pages; cur_page < last_page; ++cur_page) {\r\nstruct page *page = *cur_page;\r\nif (!page)\r\npage = dummy_read_page;\r\nmem->pages[mem->page_count++] = page;\r\n}\r\nagp_be->mem = mem;\r\nreturn 0;\r\n}\r\nstatic int ttm_agp_bind(struct ttm_backend *backend, struct ttm_mem_reg *bo_mem)\r\n{\r\nstruct ttm_agp_backend *agp_be =\r\ncontainer_of(backend, struct ttm_agp_backend, backend);\r\nstruct drm_mm_node *node = bo_mem->mm_node;\r\nstruct agp_memory *mem = agp_be->mem;\r\nint cached = (bo_mem->placement & TTM_PL_FLAG_CACHED);\r\nint ret;\r\nmem->is_flushed = 1;\r\nmem->type = (cached) ? AGP_USER_CACHED_MEMORY : AGP_USER_MEMORY;\r\nret = agp_bind_memory(mem, node->start);\r\nif (ret)\r\nprintk(KERN_ERR TTM_PFX "AGP Bind memory failed.\n");\r\nreturn ret;\r\n}\r\nstatic int ttm_agp_unbind(struct ttm_backend *backend)\r\n{\r\nstruct ttm_agp_backend *agp_be =\r\ncontainer_of(backend, struct ttm_agp_backend, backend);\r\nif (agp_be->mem->is_bound)\r\nreturn agp_unbind_memory(agp_be->mem);\r\nelse\r\nreturn 0;\r\n}\r\nstatic void ttm_agp_clear(struct ttm_backend *backend)\r\n{\r\nstruct ttm_agp_backend *agp_be =\r\ncontainer_of(backend, struct ttm_agp_backend, backend);\r\nstruct agp_memory *mem = agp_be->mem;\r\nif (mem) {\r\nttm_agp_unbind(backend);\r\nagp_free_memory(mem);\r\n}\r\nagp_be->mem = NULL;\r\n}\r\nstatic void ttm_agp_destroy(struct ttm_backend *backend)\r\n{\r\nstruct ttm_agp_backend *agp_be =\r\ncontainer_of(backend, struct ttm_agp_backend, backend);\r\nif (agp_be->mem)\r\nttm_agp_clear(backend);\r\nkfree(agp_be);\r\n}\r\nstruct ttm_backend *ttm_agp_backend_init(struct ttm_bo_device *bdev,\r\nstruct agp_bridge_data *bridge)\r\n{\r\nstruct ttm_agp_backend *agp_be;\r\nagp_be = kmalloc(sizeof(*agp_be), GFP_KERNEL);\r\nif (!agp_be)\r\nreturn NULL;\r\nagp_be->mem = NULL;\r\nagp_be->bridge = bridge;\r\nagp_be->backend.func = &ttm_agp_func;\r\nagp_be->backend.bdev = bdev;\r\nreturn &agp_be->backend;\r\n}
