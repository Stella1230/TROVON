unsigned int snd_usb_combine_bytes(unsigned char *bytes, int size)\r\n{\r\nswitch (size) {\r\ncase 1: return *bytes;\r\ncase 2: return combine_word(bytes);\r\ncase 3: return combine_triple(bytes);\r\ncase 4: return combine_quad(bytes);\r\ndefault: return 0;\r\n}\r\n}\r\nvoid *snd_usb_find_desc(void *descstart, int desclen, void *after, u8 dtype)\r\n{\r\nu8 *p, *end, *next;\r\np = descstart;\r\nend = p + desclen;\r\nfor (; p < end;) {\r\nif (p[0] < 2)\r\nreturn NULL;\r\nnext = p + p[0];\r\nif (next > end)\r\nreturn NULL;\r\nif (p[1] == dtype && (!after || (void *)p > after)) {\r\nreturn p;\r\n}\r\np = next;\r\n}\r\nreturn NULL;\r\n}\r\nvoid *snd_usb_find_csint_desc(void *buffer, int buflen, void *after, u8 dsubtype)\r\n{\r\nunsigned char *p = after;\r\nwhile ((p = snd_usb_find_desc(buffer, buflen, p,\r\nUSB_DT_CS_INTERFACE)) != NULL) {\r\nif (p[0] >= 3 && p[2] == dsubtype)\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nint snd_usb_ctl_msg(struct usb_device *dev, unsigned int pipe, __u8 request,\r\n__u8 requesttype, __u16 value, __u16 index, void *data,\r\n__u16 size, int timeout)\r\n{\r\nint err;\r\nvoid *buf = NULL;\r\nif (size > 0) {\r\nbuf = kmemdup(data, size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\n}\r\nerr = usb_control_msg(dev, pipe, request, requesttype,\r\nvalue, index, buf, size, timeout);\r\nif (size > 0) {\r\nmemcpy(data, buf, size);\r\nkfree(buf);\r\n}\r\nreturn err;\r\n}\r\nunsigned char snd_usb_parse_datainterval(struct snd_usb_audio *chip,\r\nstruct usb_host_interface *alts)\r\n{\r\nswitch (snd_usb_get_speed(chip->dev)) {\r\ncase USB_SPEED_HIGH:\r\ncase USB_SPEED_SUPER:\r\nif (get_endpoint(alts, 0)->bInterval >= 1 &&\r\nget_endpoint(alts, 0)->bInterval <= 4)\r\nreturn get_endpoint(alts, 0)->bInterval - 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}
