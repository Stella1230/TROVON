static void wdm_out_callback(struct urb *urb)\r\n{\r\nstruct wdm_device *desc;\r\ndesc = urb->context;\r\nspin_lock(&desc->iuspin);\r\ndesc->werr = urb->status;\r\nspin_unlock(&desc->iuspin);\r\nclear_bit(WDM_IN_USE, &desc->flags);\r\nkfree(desc->outbuf);\r\nwake_up(&desc->wait);\r\n}\r\nstatic void wdm_in_callback(struct urb *urb)\r\n{\r\nstruct wdm_device *desc = urb->context;\r\nint status = urb->status;\r\nspin_lock(&desc->iuspin);\r\nclear_bit(WDM_RESPONDING, &desc->flags);\r\nif (status) {\r\nswitch (status) {\r\ncase -ENOENT:\r\ndev_dbg(&desc->intf->dev,\r\n"nonzero urb status received: -ENOENT");\r\ngoto skip_error;\r\ncase -ECONNRESET:\r\ndev_dbg(&desc->intf->dev,\r\n"nonzero urb status received: -ECONNRESET");\r\ngoto skip_error;\r\ncase -ESHUTDOWN:\r\ndev_dbg(&desc->intf->dev,\r\n"nonzero urb status received: -ESHUTDOWN");\r\ngoto skip_error;\r\ncase -EPIPE:\r\ndev_err(&desc->intf->dev,\r\n"nonzero urb status received: -EPIPE\n");\r\nbreak;\r\ndefault:\r\ndev_err(&desc->intf->dev,\r\n"Unexpected error %d\n", status);\r\nbreak;\r\n}\r\n}\r\ndesc->rerr = status;\r\ndesc->reslength = urb->actual_length;\r\nmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\r\ndesc->length += desc->reslength;\r\nskip_error:\r\nwake_up(&desc->wait);\r\nset_bit(WDM_READ, &desc->flags);\r\nspin_unlock(&desc->iuspin);\r\n}\r\nstatic void wdm_int_callback(struct urb *urb)\r\n{\r\nint rv = 0;\r\nint status = urb->status;\r\nstruct wdm_device *desc;\r\nstruct usb_ctrlrequest *req;\r\nstruct usb_cdc_notification *dr;\r\ndesc = urb->context;\r\nreq = desc->irq;\r\ndr = (struct usb_cdc_notification *)desc->sbuf;\r\nif (status) {\r\nswitch (status) {\r\ncase -ESHUTDOWN:\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\nreturn;\r\ncase -EPIPE:\r\nset_bit(WDM_INT_STALL, &desc->flags);\r\ndev_err(&desc->intf->dev, "Stall on int endpoint\n");\r\ngoto sw;\r\ndefault:\r\ndev_err(&desc->intf->dev,\r\n"nonzero urb status received: %d\n", status);\r\nbreak;\r\n}\r\n}\r\nif (urb->actual_length < sizeof(struct usb_cdc_notification)) {\r\ndev_err(&desc->intf->dev, "wdm_int_callback - %d bytes\n",\r\nurb->actual_length);\r\ngoto exit;\r\n}\r\nswitch (dr->bNotificationType) {\r\ncase USB_CDC_NOTIFY_RESPONSE_AVAILABLE:\r\ndev_dbg(&desc->intf->dev,\r\n"NOTIFY_RESPONSE_AVAILABLE received: index %d len %d",\r\ndr->wIndex, dr->wLength);\r\nbreak;\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\ndev_dbg(&desc->intf->dev,\r\n"NOTIFY_NETWORK_CONNECTION %s network",\r\ndr->wValue ? "connected to" : "disconnected from");\r\ngoto exit;\r\ndefault:\r\nclear_bit(WDM_POLL_RUNNING, &desc->flags);\r\ndev_err(&desc->intf->dev,\r\n"unknown notification %d received: index %d len %d\n",\r\ndr->bNotificationType, dr->wIndex, dr->wLength);\r\ngoto exit;\r\n}\r\nreq->bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);\r\nreq->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;\r\nreq->wValue = 0;\r\nreq->wIndex = desc->inum;\r\nreq->wLength = cpu_to_le16(desc->wMaxCommand);\r\nusb_fill_control_urb(\r\ndesc->response,\r\ninterface_to_usbdev(desc->intf),\r\nusb_rcvctrlpipe(interface_to_usbdev(desc->intf), 0),\r\n(unsigned char *)req,\r\ndesc->inbuf,\r\ndesc->wMaxCommand,\r\nwdm_in_callback,\r\ndesc\r\n);\r\ndesc->response->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nspin_lock(&desc->iuspin);\r\nclear_bit(WDM_READ, &desc->flags);\r\nset_bit(WDM_RESPONDING, &desc->flags);\r\nif (!test_bit(WDM_DISCONNECTING, &desc->flags)\r\n&& !test_bit(WDM_SUSPENDING, &desc->flags)) {\r\nrv = usb_submit_urb(desc->response, GFP_ATOMIC);\r\ndev_dbg(&desc->intf->dev, "%s: usb_submit_urb %d",\r\n__func__, rv);\r\n}\r\nspin_unlock(&desc->iuspin);\r\nif (rv < 0) {\r\nclear_bit(WDM_RESPONDING, &desc->flags);\r\nif (rv == -EPERM)\r\nreturn;\r\nif (rv == -ENOMEM) {\r\nsw:\r\nrv = schedule_work(&desc->rxwork);\r\nif (rv)\r\ndev_err(&desc->intf->dev,\r\n"Cannot schedule work\n");\r\n}\r\n}\r\nexit:\r\nrv = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rv)\r\ndev_err(&desc->intf->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, rv);\r\n}\r\nstatic void kill_urbs(struct wdm_device *desc)\r\n{\r\nusb_kill_urb(desc->command);\r\nusb_kill_urb(desc->validity);\r\nusb_kill_urb(desc->response);\r\n}\r\nstatic void free_urbs(struct wdm_device *desc)\r\n{\r\nusb_free_urb(desc->validity);\r\nusb_free_urb(desc->response);\r\nusb_free_urb(desc->command);\r\n}\r\nstatic void cleanup(struct wdm_device *desc)\r\n{\r\nusb_free_coherent(interface_to_usbdev(desc->intf),\r\ndesc->wMaxPacketSize,\r\ndesc->sbuf,\r\ndesc->validity->transfer_dma);\r\nusb_free_coherent(interface_to_usbdev(desc->intf),\r\ndesc->bMaxPacketSize0,\r\ndesc->inbuf,\r\ndesc->response->transfer_dma);\r\nkfree(desc->orq);\r\nkfree(desc->irq);\r\nkfree(desc->ubuf);\r\nfree_urbs(desc);\r\nkfree(desc);\r\n}\r\nstatic ssize_t wdm_write\r\n(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nu8 *buf;\r\nint rv = -EMSGSIZE, r, we;\r\nstruct wdm_device *desc = file->private_data;\r\nstruct usb_ctrlrequest *req;\r\nif (count > desc->wMaxCommand)\r\ncount = desc->wMaxCommand;\r\nspin_lock_irq(&desc->iuspin);\r\nwe = desc->werr;\r\ndesc->werr = 0;\r\nspin_unlock_irq(&desc->iuspin);\r\nif (we < 0)\r\nreturn -EIO;\r\ndesc->outbuf = buf = kmalloc(count, GFP_KERNEL);\r\nif (!buf) {\r\nrv = -ENOMEM;\r\ngoto outnl;\r\n}\r\nr = copy_from_user(buf, buffer, count);\r\nif (r > 0) {\r\nkfree(buf);\r\nrv = -EFAULT;\r\ngoto outnl;\r\n}\r\nr = mutex_lock_interruptible(&desc->lock);\r\nrv = -ERESTARTSYS;\r\nif (r) {\r\nkfree(buf);\r\ngoto outnl;\r\n}\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nkfree(buf);\r\nrv = -ENODEV;\r\ngoto outnp;\r\n}\r\nr = usb_autopm_get_interface(desc->intf);\r\nif (r < 0) {\r\nkfree(buf);\r\ngoto outnp;\r\n}\r\nif (!(file->f_flags & O_NONBLOCK))\r\nr = wait_event_interruptible(desc->wait, !test_bit(WDM_IN_USE,\r\n&desc->flags));\r\nelse\r\nif (test_bit(WDM_IN_USE, &desc->flags))\r\nr = -EAGAIN;\r\nif (r < 0) {\r\nkfree(buf);\r\ngoto out;\r\n}\r\nreq = desc->orq;\r\nusb_fill_control_urb(\r\ndesc->command,\r\ninterface_to_usbdev(desc->intf),\r\nusb_sndctrlpipe(interface_to_usbdev(desc->intf), 0),\r\n(unsigned char *)req,\r\nbuf,\r\ncount,\r\nwdm_out_callback,\r\ndesc\r\n);\r\nreq->bRequestType = (USB_DIR_OUT | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE);\r\nreq->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\r\nreq->wValue = 0;\r\nreq->wIndex = desc->inum;\r\nreq->wLength = cpu_to_le16(count);\r\nset_bit(WDM_IN_USE, &desc->flags);\r\nrv = usb_submit_urb(desc->command, GFP_KERNEL);\r\nif (rv < 0) {\r\nkfree(buf);\r\nclear_bit(WDM_IN_USE, &desc->flags);\r\ndev_err(&desc->intf->dev, "Tx URB error: %d\n", rv);\r\n} else {\r\ndev_dbg(&desc->intf->dev, "Tx URB has been submitted index=%d",\r\nreq->wIndex);\r\n}\r\nout:\r\nusb_autopm_put_interface(desc->intf);\r\noutnp:\r\nmutex_unlock(&desc->lock);\r\noutnl:\r\nreturn rv < 0 ? rv : count;\r\n}\r\nstatic ssize_t wdm_read\r\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nint rv, cntr = 0;\r\nint i = 0;\r\nstruct wdm_device *desc = file->private_data;\r\nrv = mutex_lock_interruptible(&desc->lock);\r\nif (rv < 0)\r\nreturn -ERESTARTSYS;\r\nif (desc->length == 0) {\r\ndesc->read = 0;\r\nretry:\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nrv = -ENODEV;\r\ngoto err;\r\n}\r\ni++;\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (!test_bit(WDM_READ, &desc->flags)) {\r\nrv = cntr ? cntr : -EAGAIN;\r\ngoto err;\r\n}\r\nrv = 0;\r\n} else {\r\nrv = wait_event_interruptible(desc->wait,\r\ntest_bit(WDM_READ, &desc->flags));\r\n}\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nrv = -ENODEV;\r\ngoto err;\r\n}\r\nusb_mark_last_busy(interface_to_usbdev(desc->intf));\r\nif (rv < 0) {\r\nrv = -ERESTARTSYS;\r\ngoto err;\r\n}\r\nspin_lock_irq(&desc->iuspin);\r\nif (desc->rerr) {\r\ndesc->rerr = 0;\r\nspin_unlock_irq(&desc->iuspin);\r\nrv = -EIO;\r\ngoto err;\r\n}\r\nif (!test_bit(WDM_READ, &desc->flags)) {\r\nspin_unlock_irq(&desc->iuspin);\r\ngoto retry;\r\n}\r\nif (!desc->reslength) {\r\nspin_unlock_irq(&desc->iuspin);\r\ngoto retry;\r\n}\r\nclear_bit(WDM_READ, &desc->flags);\r\nspin_unlock_irq(&desc->iuspin);\r\n}\r\ncntr = count > desc->length ? desc->length : count;\r\nrv = copy_to_user(buffer, desc->ubuf, cntr);\r\nif (rv > 0) {\r\nrv = -EFAULT;\r\ngoto err;\r\n}\r\nfor (i = 0; i < desc->length - cntr; i++)\r\ndesc->ubuf[i] = desc->ubuf[i + cntr];\r\ndesc->length -= cntr;\r\nif (!desc->length)\r\nclear_bit(WDM_READ, &desc->flags);\r\nrv = cntr;\r\nerr:\r\nmutex_unlock(&desc->lock);\r\nreturn rv;\r\n}\r\nstatic int wdm_flush(struct file *file, fl_owner_t id)\r\n{\r\nstruct wdm_device *desc = file->private_data;\r\nwait_event(desc->wait, !test_bit(WDM_IN_USE, &desc->flags));\r\nif (desc->werr < 0)\r\ndev_err(&desc->intf->dev, "Error in flush path: %d\n",\r\ndesc->werr);\r\nreturn desc->werr;\r\n}\r\nstatic unsigned int wdm_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct wdm_device *desc = file->private_data;\r\nunsigned long flags;\r\nunsigned int mask = 0;\r\nspin_lock_irqsave(&desc->iuspin, flags);\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nmask = POLLERR;\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\ngoto desc_out;\r\n}\r\nif (test_bit(WDM_READ, &desc->flags))\r\nmask = POLLIN | POLLRDNORM;\r\nif (desc->rerr || desc->werr)\r\nmask |= POLLERR;\r\nif (!test_bit(WDM_IN_USE, &desc->flags))\r\nmask |= POLLOUT | POLLWRNORM;\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\npoll_wait(file, &desc->wait, wait);\r\ndesc_out:\r\nreturn mask;\r\n}\r\nstatic int wdm_open(struct inode *inode, struct file *file)\r\n{\r\nint minor = iminor(inode);\r\nint rv = -ENODEV;\r\nstruct usb_interface *intf;\r\nstruct wdm_device *desc;\r\nmutex_lock(&wdm_mutex);\r\nintf = usb_find_interface(&wdm_driver, minor);\r\nif (!intf)\r\ngoto out;\r\ndesc = usb_get_intfdata(intf);\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags))\r\ngoto out;\r\nfile->private_data = desc;\r\nrv = usb_autopm_get_interface(desc->intf);\r\nif (rv < 0) {\r\ndev_err(&desc->intf->dev, "Error autopm - %d\n", rv);\r\ngoto out;\r\n}\r\nintf->needs_remote_wakeup = 1;\r\nmutex_lock(&desc->lock);\r\nif (!desc->count++) {\r\ndesc->werr = 0;\r\ndesc->rerr = 0;\r\nrv = usb_submit_urb(desc->validity, GFP_KERNEL);\r\nif (rv < 0) {\r\ndesc->count--;\r\ndev_err(&desc->intf->dev,\r\n"Error submitting int urb - %d\n", rv);\r\n}\r\n} else {\r\nrv = 0;\r\n}\r\nmutex_unlock(&desc->lock);\r\nusb_autopm_put_interface(desc->intf);\r\nout:\r\nmutex_unlock(&wdm_mutex);\r\nreturn rv;\r\n}\r\nstatic int wdm_release(struct inode *inode, struct file *file)\r\n{\r\nstruct wdm_device *desc = file->private_data;\r\nmutex_lock(&wdm_mutex);\r\nmutex_lock(&desc->lock);\r\ndesc->count--;\r\nmutex_unlock(&desc->lock);\r\nif (!desc->count) {\r\ndev_dbg(&desc->intf->dev, "wdm_release: cleanup");\r\nkill_urbs(desc);\r\nif (!test_bit(WDM_DISCONNECTING, &desc->flags))\r\ndesc->intf->needs_remote_wakeup = 0;\r\n}\r\nmutex_unlock(&wdm_mutex);\r\nreturn 0;\r\n}\r\nstatic void wdm_rxwork(struct work_struct *work)\r\n{\r\nstruct wdm_device *desc = container_of(work, struct wdm_device, rxwork);\r\nunsigned long flags;\r\nint rv;\r\nspin_lock_irqsave(&desc->iuspin, flags);\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\n} else {\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\nrv = usb_submit_urb(desc->response, GFP_KERNEL);\r\nif (rv < 0 && rv != -EPERM) {\r\nspin_lock_irqsave(&desc->iuspin, flags);\r\nif (!test_bit(WDM_DISCONNECTING, &desc->flags))\r\nschedule_work(&desc->rxwork);\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\n}\r\n}\r\n}\r\nstatic int wdm_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nint rv = -EINVAL;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct wdm_device *desc;\r\nstruct usb_host_interface *iface;\r\nstruct usb_endpoint_descriptor *ep;\r\nstruct usb_cdc_dmm_desc *dmhd;\r\nu8 *buffer = intf->altsetting->extra;\r\nint buflen = intf->altsetting->extralen;\r\nu16 maxcom = 0;\r\nif (!buffer)\r\ngoto out;\r\nwhile (buflen > 2) {\r\nif (buffer [1] != USB_DT_CS_INTERFACE) {\r\ndev_err(&intf->dev, "skipping garbage\n");\r\ngoto next_desc;\r\n}\r\nswitch (buffer [2]) {\r\ncase USB_CDC_HEADER_TYPE:\r\nbreak;\r\ncase USB_CDC_DMM_TYPE:\r\ndmhd = (struct usb_cdc_dmm_desc *)buffer;\r\nmaxcom = le16_to_cpu(dmhd->wMaxCommand);\r\ndev_dbg(&intf->dev,\r\n"Finding maximum buffer length: %d", maxcom);\r\nbreak;\r\ndefault:\r\ndev_err(&intf->dev,\r\n"Ignoring extra header, type %d, length %d\n",\r\nbuffer[2], buffer[0]);\r\nbreak;\r\n}\r\nnext_desc:\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nrv = -ENOMEM;\r\ndesc = kzalloc(sizeof(struct wdm_device), GFP_KERNEL);\r\nif (!desc)\r\ngoto out;\r\nmutex_init(&desc->lock);\r\nspin_lock_init(&desc->iuspin);\r\ninit_waitqueue_head(&desc->wait);\r\ndesc->wMaxCommand = maxcom;\r\ndesc->inum = cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber);\r\ndesc->intf = intf;\r\nINIT_WORK(&desc->rxwork, wdm_rxwork);\r\nrv = -EINVAL;\r\niface = intf->cur_altsetting;\r\nif (iface->desc.bNumEndpoints != 1)\r\ngoto err;\r\nep = &iface->endpoint[0].desc;\r\nif (!ep || !usb_endpoint_is_int_in(ep))\r\ngoto err;\r\ndesc->wMaxPacketSize = le16_to_cpu(ep->wMaxPacketSize);\r\ndesc->bMaxPacketSize0 = udev->descriptor.bMaxPacketSize0;\r\ndesc->orq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\r\nif (!desc->orq)\r\ngoto err;\r\ndesc->irq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\r\nif (!desc->irq)\r\ngoto err;\r\ndesc->validity = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!desc->validity)\r\ngoto err;\r\ndesc->response = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!desc->response)\r\ngoto err;\r\ndesc->command = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!desc->command)\r\ngoto err;\r\ndesc->ubuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\r\nif (!desc->ubuf)\r\ngoto err;\r\ndesc->sbuf = usb_alloc_coherent(interface_to_usbdev(intf),\r\ndesc->wMaxPacketSize,\r\nGFP_KERNEL,\r\n&desc->validity->transfer_dma);\r\nif (!desc->sbuf)\r\ngoto err;\r\ndesc->inbuf = usb_alloc_coherent(interface_to_usbdev(intf),\r\ndesc->bMaxPacketSize0,\r\nGFP_KERNEL,\r\n&desc->response->transfer_dma);\r\nif (!desc->inbuf)\r\ngoto err2;\r\nusb_fill_int_urb(\r\ndesc->validity,\r\ninterface_to_usbdev(intf),\r\nusb_rcvintpipe(interface_to_usbdev(intf), ep->bEndpointAddress),\r\ndesc->sbuf,\r\ndesc->wMaxPacketSize,\r\nwdm_int_callback,\r\ndesc,\r\nep->bInterval\r\n);\r\ndesc->validity->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_set_intfdata(intf, desc);\r\nrv = usb_register_dev(intf, &wdm_class);\r\nif (rv < 0)\r\ngoto err3;\r\nelse\r\ndev_info(&intf->dev, "cdc-wdm%d: USB WDM device\n",\r\nintf->minor - WDM_MINOR_BASE);\r\nout:\r\nreturn rv;\r\nerr3:\r\nusb_set_intfdata(intf, NULL);\r\nusb_free_coherent(interface_to_usbdev(desc->intf),\r\ndesc->bMaxPacketSize0,\r\ndesc->inbuf,\r\ndesc->response->transfer_dma);\r\nerr2:\r\nusb_free_coherent(interface_to_usbdev(desc->intf),\r\ndesc->wMaxPacketSize,\r\ndesc->sbuf,\r\ndesc->validity->transfer_dma);\r\nerr:\r\nfree_urbs(desc);\r\nkfree(desc->ubuf);\r\nkfree(desc->orq);\r\nkfree(desc->irq);\r\nkfree(desc);\r\nreturn rv;\r\n}\r\nstatic void wdm_disconnect(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc;\r\nunsigned long flags;\r\nusb_deregister_dev(intf, &wdm_class);\r\nmutex_lock(&wdm_mutex);\r\ndesc = usb_get_intfdata(intf);\r\nspin_lock_irqsave(&desc->iuspin, flags);\r\nset_bit(WDM_DISCONNECTING, &desc->flags);\r\nset_bit(WDM_READ, &desc->flags);\r\nclear_bit(WDM_IN_USE, &desc->flags);\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\nmutex_lock(&desc->lock);\r\nkill_urbs(desc);\r\ncancel_work_sync(&desc->rxwork);\r\nmutex_unlock(&desc->lock);\r\nwake_up_all(&desc->wait);\r\nif (!desc->count)\r\ncleanup(desc);\r\nmutex_unlock(&wdm_mutex);\r\n}\r\nstatic int wdm_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct wdm_device *desc = usb_get_intfdata(intf);\r\nint rv = 0;\r\ndev_dbg(&desc->intf->dev, "wdm%d_suspend\n", intf->minor);\r\nif (!(message.event & PM_EVENT_AUTO))\r\nmutex_lock(&desc->lock);\r\nspin_lock_irq(&desc->iuspin);\r\nif ((message.event & PM_EVENT_AUTO) &&\r\n(test_bit(WDM_IN_USE, &desc->flags)\r\n|| test_bit(WDM_RESPONDING, &desc->flags))) {\r\nspin_unlock_irq(&desc->iuspin);\r\nrv = -EBUSY;\r\n} else {\r\nset_bit(WDM_SUSPENDING, &desc->flags);\r\nspin_unlock_irq(&desc->iuspin);\r\nkill_urbs(desc);\r\ncancel_work_sync(&desc->rxwork);\r\n}\r\nif (!(message.event & PM_EVENT_AUTO))\r\nmutex_unlock(&desc->lock);\r\nreturn rv;\r\n}\r\nstatic int recover_from_urb_loss(struct wdm_device *desc)\r\n{\r\nint rv = 0;\r\nif (desc->count) {\r\nrv = usb_submit_urb(desc->validity, GFP_NOIO);\r\nif (rv < 0)\r\ndev_err(&desc->intf->dev,\r\n"Error resume submitting int urb - %d\n", rv);\r\n}\r\nreturn rv;\r\n}\r\nstatic int wdm_resume(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc = usb_get_intfdata(intf);\r\nint rv;\r\ndev_dbg(&desc->intf->dev, "wdm%d_resume\n", intf->minor);\r\nclear_bit(WDM_SUSPENDING, &desc->flags);\r\nrv = recover_from_urb_loss(desc);\r\nreturn rv;\r\n}\r\nstatic int wdm_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc = usb_get_intfdata(intf);\r\nmutex_lock(&desc->lock);\r\nkill_urbs(desc);\r\nspin_lock_irq(&desc->iuspin);\r\ndesc->rerr = -EINTR;\r\nspin_unlock_irq(&desc->iuspin);\r\nwake_up_all(&desc->wait);\r\nreturn 0;\r\n}\r\nstatic int wdm_post_reset(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc = usb_get_intfdata(intf);\r\nint rv;\r\nrv = recover_from_urb_loss(desc);\r\nmutex_unlock(&desc->lock);\r\nreturn 0;\r\n}\r\nstatic int __init wdm_init(void)\r\n{\r\nint rv;\r\nrv = usb_register(&wdm_driver);\r\nreturn rv;\r\n}\r\nstatic void __exit wdm_exit(void)\r\n{\r\nusb_deregister(&wdm_driver);\r\n}
