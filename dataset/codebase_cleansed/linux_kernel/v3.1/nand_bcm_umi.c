static void nand_bcm_umi_bch_ecc_flip_bit(uint8_t *datap, int errorLocation)\r\n{\r\nint locWithinAByte = (errorLocation & REG_UMI_BCH_ERR_LOC_BYTE) >> 0;\r\nint locWithinAWord = (errorLocation & REG_UMI_BCH_ERR_LOC_WORD) >> 3;\r\nint locWithinAPage = (errorLocation & REG_UMI_BCH_ERR_LOC_PAGE) >> 5;\r\nuint8_t errorByte = 0;\r\nuint8_t byteMask = 1 << locWithinAByte;\r\nlocWithinAWord = 3 - locWithinAWord;\r\nerrorByte = datap[locWithinAPage * sizeof(uint32_t) + locWithinAWord];\r\n#ifdef BOOT0_BUILD\r\nputhexs("\nECC Correct Offset: ",\r\nlocWithinAPage * sizeof(uint32_t) + locWithinAWord);\r\nputhexs(" errorByte:", errorByte);\r\nputhex8(" Bit: ", locWithinAByte);\r\n#endif\r\nif (errorByte & byteMask) {\r\nerrorByte &= ~byteMask;\r\n} else {\r\nerrorByte |= byteMask;\r\n}\r\ndatap[locWithinAPage * sizeof(uint32_t) + locWithinAWord] = errorByte;\r\n}\r\nint nand_bcm_umi_bch_correct_page(uint8_t *datap, uint8_t *readEccData,\r\nint numEccBytes)\r\n{\r\nint numErrors;\r\nint errorLocation;\r\nint idx;\r\nuint32_t regValue;\r\nregValue = nand_bcm_umi_bch_poll_read_ecc_calc();\r\nif ((regValue & REG_UMI_BCH_CTRL_STATUS_UNCORR_ERR) > 0) {\r\nint i;\r\nfor (i = 0; i < numEccBytes; i++) {\r\nif (readEccData[i] != 0xff) {\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nif ((regValue & REG_UMI_BCH_CTRL_STATUS_CORR_ERR) == 0) {\r\nreturn 0;\r\n}\r\nnumErrors = (regValue & REG_UMI_BCH_CTRL_STATUS_NB_CORR_ERROR) >> 20;\r\nfor (idx = 0; idx < numErrors; idx++) {\r\nerrorLocation =\r\nREG_UMI_BCH_ERR_LOC_ADDR(idx) & REG_UMI_BCH_ERR_LOC_MASK;\r\nnand_bcm_umi_bch_ecc_flip_bit(datap, errorLocation);\r\n}\r\nreturn numErrors;\r\n}
