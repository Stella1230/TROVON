static int __init do_wd_probe(struct net_device *dev)\r\n{\r\nint i;\r\nstruct resource *r;\r\nint base_addr = dev->base_addr;\r\nint irq = dev->irq;\r\nint mem_start = dev->mem_start;\r\nint mem_end = dev->mem_end;\r\nif (base_addr > 0x1ff) {\r\nr = request_region(base_addr, WD_IO_EXTENT, "wd-probe");\r\nif ( r == NULL)\r\nreturn -EBUSY;\r\ni = wd_probe1(dev, base_addr);\r\nif (i != 0)\r\nrelease_region(base_addr, WD_IO_EXTENT);\r\nelse\r\nr->name = dev->name;\r\nreturn i;\r\n}\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\nfor (i = 0; wd_portlist[i]; i++) {\r\nint ioaddr = wd_portlist[i];\r\nr = request_region(ioaddr, WD_IO_EXTENT, "wd-probe");\r\nif (r == NULL)\r\ncontinue;\r\nif (wd_probe1(dev, ioaddr) == 0) {\r\nr->name = dev->name;\r\nreturn 0;\r\n}\r\nrelease_region(ioaddr, WD_IO_EXTENT);\r\ndev->irq = irq;\r\ndev->mem_start = mem_start;\r\ndev->mem_end = mem_end;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init wd_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_ei_netdev();\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_wd_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init wd_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i;\r\nint err;\r\nint checksum = 0;\r\nint ancient = 0;\r\nint word16 = 0;\r\nconst char *model_name;\r\nstatic unsigned version_printed;\r\nfor (i = 0; i < 8; i++)\r\nchecksum += inb(ioaddr + 8 + i);\r\nif (inb(ioaddr + 8) == 0xff\r\n|| inb(ioaddr + 9) == 0xff\r\n|| (checksum & 0xff) != 0xFF)\r\nreturn -ENODEV;\r\nif ((dev->mem_start % 0x2000) || (dev->mem_end % 0x2000)) {\r\nprintk(KERN_WARNING "wd.c: user supplied mem_start or mem_end not on 8kB boundary - ignored.\n");\r\ndev->mem_start = 0;\r\ndev->mem_end = 0;\r\n}\r\nif (ei_debug && version_printed++ == 0)\r\nprintk(version);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + 8 + i);\r\nprintk("%s: WD80x3 at %#3x, %pM",\r\ndev->name, ioaddr, dev->dev_addr);\r\nif (inb(ioaddr+0) == 'P' && inb(ioaddr+1) == 'D') {\r\nunsigned char reg5 = inb(ioaddr+5);\r\nswitch (inb(ioaddr+2)) {\r\ncase 0x03: word16 = 0; model_name = "PDI8023-8"; break;\r\ncase 0x05: word16 = 0; model_name = "PDUC8023"; break;\r\ncase 0x0a: word16 = 1; model_name = "PDI8023-16"; break;\r\ndefault: word16 = 0; model_name = "PDI8023"; break;\r\n}\r\ndev->mem_start = ((reg5 & 0x1c) + 0xc0) << 12;\r\ndev->irq = (reg5 & 0xe0) == 0xe0 ? 10 : (reg5 >> 5) + 1;\r\n} else {\r\nfor (i = 0; i < 6; i++)\r\nif (inb(ioaddr+i) != inb(ioaddr+8+i))\r\nbreak;\r\nif (i >= 6) {\r\nancient = 1;\r\nmodel_name = "WD8003-old";\r\nword16 = 0;\r\n} else {\r\nint tmp = inb(ioaddr+1);\r\noutb( tmp ^ 0x01, ioaddr+1 );\r\nif (((inb( ioaddr+1) & 0x01) == 0x01)\r\n&& (tmp & 0x01) == 0x01 ) {\r\nint asic_reg5 = inb(ioaddr+WD_CMDREG5);\r\noutb( NIC16 | (asic_reg5&0x1f), ioaddr+WD_CMDREG5);\r\noutb(tmp, ioaddr+1);\r\nmodel_name = "WD8013";\r\nword16 = 1;\r\n} else {\r\nmodel_name = "WD8003";\r\nword16 = 0;\r\n}\r\noutb(tmp, ioaddr+1);\r\n}\r\n#ifndef final_version\r\nif ( !ancient && (inb(ioaddr+1) & 0x01) != (word16 & 0x01))\r\nprintk("\nWD80?3: Bus width conflict, %d (probe) != %d (reg report).",\r\nword16 ? 16 : 8, (inb(ioaddr+1) & 0x01) ? 16 : 8);\r\n#endif\r\n}\r\n#if defined(WD_SHMEM) && WD_SHMEM > 0x80000\r\ndev->mem_start = WD_SHMEM;\r\n#else\r\nif (dev->mem_start == 0) {\r\nint reg0 = inb(ioaddr);\r\nif (reg0 == 0xff || reg0 == 0) {\r\ndev->mem_start = 0xd0000;\r\nprintk(" assigning address %#lx", dev->mem_start);\r\n} else {\r\nint high_addr_bits = inb(ioaddr+WD_CMDREG5) & 0x1f;\r\nif (high_addr_bits == 0x1f || word16 == 0)\r\nhigh_addr_bits = 0x01;\r\ndev->mem_start = ((reg0&0x3f) << 13) + (high_addr_bits << 19);\r\n}\r\n}\r\n#endif\r\ndev->base_addr = ioaddr+WD_NIC_OFFSET;\r\nif (dev->irq < 2) {\r\nstatic const int irqmap[] = {9, 3, 5, 7, 10, 11, 15, 4};\r\nint reg1 = inb(ioaddr+1);\r\nint reg4 = inb(ioaddr+4);\r\nif (ancient || reg1 == 0xff) {\r\nshort nic_addr = ioaddr+WD_NIC_OFFSET;\r\nunsigned long irq_mask;\r\noutb_p(E8390_NODMA + E8390_STOP, nic_addr);\r\noutb(0x00, nic_addr+EN0_IMR);\r\nirq_mask = probe_irq_on();\r\noutb_p(0xff, nic_addr + EN0_IMR);\r\noutb_p(0x00, nic_addr + EN0_RCNTLO);\r\noutb_p(0x00, nic_addr + EN0_RCNTHI);\r\noutb(E8390_RREAD+E8390_START, nic_addr);\r\nmdelay(20);\r\ndev->irq = probe_irq_off(irq_mask);\r\noutb_p(0x00, nic_addr+EN0_IMR);\r\nif (ei_debug > 2)\r\nprintk(" autoirq is %d", dev->irq);\r\nif (dev->irq < 2)\r\ndev->irq = word16 ? 10 : 5;\r\n} else\r\ndev->irq = irqmap[((reg4 >> 5) & 0x03) + (reg1 & 0x04)];\r\n} else if (dev->irq == 2)\r\ndev->irq = 9;\r\ni = request_irq(dev->irq, ei_interrupt, 0, DRV_NAME, dev);\r\nif (i) {\r\nprintk (" unable to get IRQ %d.\n", dev->irq);\r\nreturn i;\r\n}\r\nei_status.name = model_name;\r\nei_status.word16 = word16;\r\nei_status.tx_start_page = WD_START_PG;\r\nei_status.rx_start_page = WD_START_PG + TX_PAGES;\r\nif (dev->mem_end != 0) {\r\nei_status.stop_page = (dev->mem_end - dev->mem_start)/256;\r\nei_status.priv = dev->mem_end - dev->mem_start;\r\n} else {\r\nei_status.stop_page = word16 ? WD13_STOP_PG : WD03_STOP_PG;\r\ndev->mem_end = dev->mem_start + (ei_status.stop_page - WD_START_PG)*256;\r\nei_status.priv = (ei_status.stop_page - WD_START_PG)*256;\r\n}\r\nei_status.mem = ioremap(dev->mem_start, ei_status.priv);\r\nif (!ei_status.mem) {\r\nfree_irq(dev->irq, dev);\r\nreturn -ENOMEM;\r\n}\r\nprintk(" %s, IRQ %d, shared memory at %#lx-%#lx.\n",\r\nmodel_name, dev->irq, dev->mem_start, dev->mem_end-1);\r\nei_status.reset_8390 = wd_reset_8390;\r\nei_status.block_input = wd_block_input;\r\nei_status.block_output = wd_block_output;\r\nei_status.get_8390_hdr = wd_get_8390_hdr;\r\ndev->netdev_ops = &wd_netdev_ops;\r\nNS8390_init(dev, 0);\r\n#if 1\r\nif (inb(ioaddr+14) & 0x20)\r\noutb(inb(ioaddr+4)|0x80, ioaddr+4);\r\n#endif\r\nerr = register_netdev(dev);\r\nif (err) {\r\nfree_irq(dev->irq, dev);\r\niounmap(ei_status.mem);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nwd_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr - WD_NIC_OFFSET;\r\nei_status.reg0 = ((dev->mem_start>>13) & 0x3f) | WD_MEMENB;\r\nei_status.reg5 = ((dev->mem_start>>19) & 0x1f) | NIC16;\r\nif (ei_status.word16)\r\noutb(ei_status.reg5, ioaddr+WD_CMDREG5);\r\noutb(ei_status.reg0, ioaddr);\r\nreturn ei_open(dev);\r\n}\r\nstatic void\r\nwd_reset_8390(struct net_device *dev)\r\n{\r\nint wd_cmd_port = dev->base_addr - WD_NIC_OFFSET;\r\noutb(WD_RESET, wd_cmd_port);\r\nif (ei_debug > 1) printk("resetting the WD80x3 t=%lu...", jiffies);\r\nei_status.txing = 0;\r\noutb((((dev->mem_start>>13) & 0x3f)|WD_MEMENB), wd_cmd_port);\r\nif (ei_status.word16)\r\noutb(NIC16 | ((dev->mem_start>>19) & 0x1f), wd_cmd_port+WD_CMDREG5);\r\nif (ei_debug > 1) printk("reset done\n");\r\n}\r\nstatic void\r\nwd_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint wd_cmdreg = dev->base_addr - WD_NIC_OFFSET;\r\nvoid __iomem *hdr_start = ei_status.mem + ((ring_page - WD_START_PG)<<8);\r\nif (ei_status.word16)\r\noutb(ISA16 | ei_status.reg5, wd_cmdreg+WD_CMDREG5);\r\n#ifdef __BIG_ENDIAN\r\nmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\r\nhdr->count = le16_to_cpu(hdr->count);\r\n#else\r\n((unsigned int*)hdr)[0] = readl(hdr_start);\r\n#endif\r\n}\r\nstatic void\r\nwd_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nint wd_cmdreg = dev->base_addr - WD_NIC_OFFSET;\r\nunsigned long offset = ring_offset - (WD_START_PG<<8);\r\nvoid __iomem *xfer_start = ei_status.mem + offset;\r\nif (offset + count > ei_status.priv) {\r\nint semi_count = ei_status.priv - offset;\r\nmemcpy_fromio(skb->data, xfer_start, semi_count);\r\ncount -= semi_count;\r\nmemcpy_fromio(skb->data + semi_count, ei_status.mem + TX_PAGES * 256, count);\r\n} else {\r\nmemcpy_fromio(skb->data, xfer_start, count);\r\n}\r\nif (ei_status.word16)\r\noutb(ei_status.reg5, wd_cmdreg+WD_CMDREG5);\r\n}\r\nstatic void\r\nwd_block_output(struct net_device *dev, int count, const unsigned char *buf,\r\nint start_page)\r\n{\r\nint wd_cmdreg = dev->base_addr - WD_NIC_OFFSET;\r\nvoid __iomem *shmem = ei_status.mem + ((start_page - WD_START_PG)<<8);\r\nif (ei_status.word16) {\r\noutb(ISA16 | ei_status.reg5, wd_cmdreg+WD_CMDREG5);\r\nmemcpy_toio(shmem, buf, count);\r\noutb(ei_status.reg5, wd_cmdreg+WD_CMDREG5);\r\n} else\r\nmemcpy_toio(shmem, buf, count);\r\n}\r\nstatic int\r\nwd_close(struct net_device *dev)\r\n{\r\nint wd_cmdreg = dev->base_addr - WD_NIC_OFFSET;\r\nif (ei_debug > 1)\r\nprintk("%s: Shutting down ethercard.\n", dev->name);\r\nei_close(dev);\r\nif (ei_status.word16)\r\noutb(ei_status.reg5, wd_cmdreg + WD_CMDREG5 );\r\noutb(ei_status.reg0 & ~WD_MEMENB, wd_cmdreg);\r\nreturn 0;\r\n}\r\nint __init init_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_WD_CARDS; this_dev++) {\r\nif (io[this_dev] == 0) {\r\nif (this_dev != 0) break;\r\nprintk(KERN_NOTICE "wd.c: Presently autoprobing (not recommended) for a single card.\n");\r\n}\r\ndev = alloc_ei_netdev();\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\ndev->mem_start = mem[this_dev];\r\ndev->mem_end = mem_end[this_dev];\r\nif (do_wd_probe(dev) == 0) {\r\ndev_wd[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nprintk(KERN_WARNING "wd.c: No wd80x3 card found (i/o = 0x%x).\n", io[this_dev]);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr - WD_NIC_OFFSET, WD_IO_EXTENT);\r\niounmap(ei_status.mem);\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_WD_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_wd[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
