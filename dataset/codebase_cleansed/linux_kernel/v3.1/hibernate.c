void hibernation_set_ops(const struct platform_hibernation_ops *ops)\r\n{\r\nif (ops && !(ops->begin && ops->end && ops->pre_snapshot\r\n&& ops->prepare && ops->finish && ops->enter && ops->pre_restore\r\n&& ops->restore_cleanup && ops->leave)) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nmutex_lock(&pm_mutex);\r\nhibernation_ops = ops;\r\nif (ops)\r\nhibernation_mode = HIBERNATION_PLATFORM;\r\nelse if (hibernation_mode == HIBERNATION_PLATFORM)\r\nhibernation_mode = HIBERNATION_SHUTDOWN;\r\nmutex_unlock(&pm_mutex);\r\n}\r\nbool system_entering_hibernation(void)\r\n{\r\nreturn entering_platform_hibernation;\r\n}\r\nstatic void hibernation_debug_sleep(void)\r\n{\r\nprintk(KERN_INFO "hibernation debug: Waiting for 5 seconds.\n");\r\nmdelay(5000);\r\n}\r\nstatic int hibernation_testmode(int mode)\r\n{\r\nif (hibernation_mode == mode) {\r\nhibernation_debug_sleep();\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hibernation_test(int level)\r\n{\r\nif (pm_test_level == level) {\r\nhibernation_debug_sleep();\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hibernation_testmode(int mode) { return 0; }\r\nstatic int hibernation_test(int level) { return 0; }\r\nstatic int platform_begin(int platform_mode)\r\n{\r\nreturn (platform_mode && hibernation_ops) ?\r\nhibernation_ops->begin() : 0;\r\n}\r\nstatic void platform_end(int platform_mode)\r\n{\r\nif (platform_mode && hibernation_ops)\r\nhibernation_ops->end();\r\n}\r\nstatic int platform_pre_snapshot(int platform_mode)\r\n{\r\nreturn (platform_mode && hibernation_ops) ?\r\nhibernation_ops->pre_snapshot() : 0;\r\n}\r\nstatic void platform_leave(int platform_mode)\r\n{\r\nif (platform_mode && hibernation_ops)\r\nhibernation_ops->leave();\r\n}\r\nstatic void platform_finish(int platform_mode)\r\n{\r\nif (platform_mode && hibernation_ops)\r\nhibernation_ops->finish();\r\n}\r\nstatic int platform_pre_restore(int platform_mode)\r\n{\r\nreturn (platform_mode && hibernation_ops) ?\r\nhibernation_ops->pre_restore() : 0;\r\n}\r\nstatic void platform_restore_cleanup(int platform_mode)\r\n{\r\nif (platform_mode && hibernation_ops)\r\nhibernation_ops->restore_cleanup();\r\n}\r\nstatic void platform_recover(int platform_mode)\r\n{\r\nif (platform_mode && hibernation_ops && hibernation_ops->recover)\r\nhibernation_ops->recover();\r\n}\r\nvoid swsusp_show_speed(struct timeval *start, struct timeval *stop,\r\nunsigned nr_pages, char *msg)\r\n{\r\ns64 elapsed_centisecs64;\r\nint centisecs;\r\nint k;\r\nint kps;\r\nelapsed_centisecs64 = timeval_to_ns(stop) - timeval_to_ns(start);\r\ndo_div(elapsed_centisecs64, NSEC_PER_SEC / 100);\r\ncentisecs = elapsed_centisecs64;\r\nif (centisecs == 0)\r\ncentisecs = 1;\r\nk = nr_pages * (PAGE_SIZE / 1024);\r\nkps = (k * 100) / centisecs;\r\nprintk(KERN_INFO "PM: %s %d kbytes in %d.%02d seconds (%d.%02d MB/s)\n",\r\nmsg, k,\r\ncentisecs / 100, centisecs % 100,\r\nkps / 1000, (kps % 1000) / 10);\r\n}\r\nstatic int create_image(int platform_mode)\r\n{\r\nint error;\r\nerror = dpm_suspend_noirq(PMSG_FREEZE);\r\nif (error) {\r\nprintk(KERN_ERR "PM: Some devices failed to power down, "\r\n"aborting hibernation\n");\r\nreturn error;\r\n}\r\nerror = platform_pre_snapshot(platform_mode);\r\nif (error || hibernation_test(TEST_PLATFORM))\r\ngoto Platform_finish;\r\nerror = disable_nonboot_cpus();\r\nif (error || hibernation_test(TEST_CPUS)\r\n|| hibernation_testmode(HIBERNATION_TEST))\r\ngoto Enable_cpus;\r\nlocal_irq_disable();\r\nerror = syscore_suspend();\r\nif (error) {\r\nprintk(KERN_ERR "PM: Some system devices failed to power down, "\r\n"aborting hibernation\n");\r\ngoto Enable_irqs;\r\n}\r\nif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\r\ngoto Power_up;\r\nin_suspend = 1;\r\nsave_processor_state();\r\nerror = swsusp_arch_suspend();\r\nif (error)\r\nprintk(KERN_ERR "PM: Error %d creating hibernation image\n",\r\nerror);\r\nrestore_processor_state();\r\nif (!in_suspend) {\r\nevents_check_enabled = false;\r\nplatform_leave(platform_mode);\r\n}\r\nPower_up:\r\nsyscore_resume();\r\nEnable_irqs:\r\nlocal_irq_enable();\r\nEnable_cpus:\r\nenable_nonboot_cpus();\r\nPlatform_finish:\r\nplatform_finish(platform_mode);\r\ndpm_resume_noirq(in_suspend ?\r\n(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\r\nreturn error;\r\n}\r\nint hibernation_snapshot(int platform_mode)\r\n{\r\npm_message_t msg = PMSG_RECOVER;\r\nint error;\r\nerror = platform_begin(platform_mode);\r\nif (error)\r\ngoto Close;\r\nerror = dpm_prepare(PMSG_FREEZE);\r\nif (error)\r\ngoto Complete_devices;\r\nerror = hibernate_preallocate_memory();\r\nif (error)\r\ngoto Complete_devices;\r\nsuspend_console();\r\npm_restrict_gfp_mask();\r\nerror = dpm_suspend(PMSG_FREEZE);\r\nif (error)\r\ngoto Recover_platform;\r\nif (hibernation_test(TEST_DEVICES))\r\ngoto Recover_platform;\r\nerror = create_image(platform_mode);\r\nResume_devices:\r\nif (error || !in_suspend)\r\nswsusp_free();\r\nmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\r\ndpm_resume(msg);\r\nif (error || !in_suspend)\r\npm_restore_gfp_mask();\r\nresume_console();\r\nComplete_devices:\r\ndpm_complete(msg);\r\nClose:\r\nplatform_end(platform_mode);\r\nreturn error;\r\nRecover_platform:\r\nplatform_recover(platform_mode);\r\ngoto Resume_devices;\r\n}\r\nstatic int resume_target_kernel(bool platform_mode)\r\n{\r\nint error;\r\nerror = dpm_suspend_noirq(PMSG_QUIESCE);\r\nif (error) {\r\nprintk(KERN_ERR "PM: Some devices failed to power down, "\r\n"aborting resume\n");\r\nreturn error;\r\n}\r\nerror = platform_pre_restore(platform_mode);\r\nif (error)\r\ngoto Cleanup;\r\nerror = disable_nonboot_cpus();\r\nif (error)\r\ngoto Enable_cpus;\r\nlocal_irq_disable();\r\nerror = syscore_suspend();\r\nif (error)\r\ngoto Enable_irqs;\r\nsave_processor_state();\r\nerror = restore_highmem();\r\nif (!error) {\r\nerror = swsusp_arch_resume();\r\nBUG_ON(!error);\r\nrestore_highmem();\r\n}\r\nswsusp_free();\r\nrestore_processor_state();\r\ntouch_softlockup_watchdog();\r\nsyscore_resume();\r\nEnable_irqs:\r\nlocal_irq_enable();\r\nEnable_cpus:\r\nenable_nonboot_cpus();\r\nCleanup:\r\nplatform_restore_cleanup(platform_mode);\r\ndpm_resume_noirq(PMSG_RECOVER);\r\nreturn error;\r\n}\r\nint hibernation_restore(int platform_mode)\r\n{\r\nint error;\r\npm_prepare_console();\r\nsuspend_console();\r\npm_restrict_gfp_mask();\r\nerror = dpm_suspend_start(PMSG_QUIESCE);\r\nif (!error) {\r\nerror = resume_target_kernel(platform_mode);\r\ndpm_resume_end(PMSG_RECOVER);\r\n}\r\npm_restore_gfp_mask();\r\nresume_console();\r\npm_restore_console();\r\nreturn error;\r\n}\r\nint hibernation_platform_enter(void)\r\n{\r\nint error;\r\nif (!hibernation_ops)\r\nreturn -ENOSYS;\r\nerror = hibernation_ops->begin();\r\nif (error)\r\ngoto Close;\r\nentering_platform_hibernation = true;\r\nsuspend_console();\r\nerror = dpm_suspend_start(PMSG_HIBERNATE);\r\nif (error) {\r\nif (hibernation_ops->recover)\r\nhibernation_ops->recover();\r\ngoto Resume_devices;\r\n}\r\nerror = dpm_suspend_noirq(PMSG_HIBERNATE);\r\nif (error)\r\ngoto Resume_devices;\r\nerror = hibernation_ops->prepare();\r\nif (error)\r\ngoto Platform_finish;\r\nerror = disable_nonboot_cpus();\r\nif (error)\r\ngoto Platform_finish;\r\nlocal_irq_disable();\r\nsyscore_suspend();\r\nif (pm_wakeup_pending()) {\r\nerror = -EAGAIN;\r\ngoto Power_up;\r\n}\r\nhibernation_ops->enter();\r\nwhile (1);\r\nPower_up:\r\nsyscore_resume();\r\nlocal_irq_enable();\r\nenable_nonboot_cpus();\r\nPlatform_finish:\r\nhibernation_ops->finish();\r\ndpm_resume_noirq(PMSG_RESTORE);\r\nResume_devices:\r\nentering_platform_hibernation = false;\r\ndpm_resume_end(PMSG_RESTORE);\r\nresume_console();\r\nClose:\r\nhibernation_ops->end();\r\nreturn error;\r\n}\r\nstatic void power_down(void)\r\n{\r\nswitch (hibernation_mode) {\r\ncase HIBERNATION_TEST:\r\ncase HIBERNATION_TESTPROC:\r\nbreak;\r\ncase HIBERNATION_REBOOT:\r\nkernel_restart(NULL);\r\nbreak;\r\ncase HIBERNATION_PLATFORM:\r\nhibernation_platform_enter();\r\ncase HIBERNATION_SHUTDOWN:\r\nkernel_power_off();\r\nbreak;\r\n}\r\nkernel_halt();\r\nprintk(KERN_CRIT "PM: Please power down manually\n");\r\nwhile(1);\r\n}\r\nstatic int prepare_processes(void)\r\n{\r\nint error = 0;\r\nif (freeze_processes()) {\r\nerror = -EBUSY;\r\nthaw_processes();\r\n}\r\nreturn error;\r\n}\r\nint hibernate(void)\r\n{\r\nint error;\r\nmutex_lock(&pm_mutex);\r\nif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\r\nerror = -EBUSY;\r\ngoto Unlock;\r\n}\r\npm_prepare_console();\r\nerror = pm_notifier_call_chain(PM_HIBERNATION_PREPARE);\r\nif (error)\r\ngoto Exit;\r\nerror = usermodehelper_disable();\r\nif (error)\r\ngoto Exit;\r\nerror = create_basic_memory_bitmaps();\r\nif (error)\r\ngoto Exit;\r\nprintk(KERN_INFO "PM: Syncing filesystems ... ");\r\nsys_sync();\r\nprintk("done.\n");\r\nerror = prepare_processes();\r\nif (error)\r\ngoto Finish;\r\nif (hibernation_test(TEST_FREEZER))\r\ngoto Thaw;\r\nif (hibernation_testmode(HIBERNATION_TESTPROC))\r\ngoto Thaw;\r\nerror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\r\nif (error)\r\ngoto Thaw;\r\nif (in_suspend) {\r\nunsigned int flags = 0;\r\nif (hibernation_mode == HIBERNATION_PLATFORM)\r\nflags |= SF_PLATFORM_MODE;\r\nif (nocompress)\r\nflags |= SF_NOCOMPRESS_MODE;\r\npr_debug("PM: writing image.\n");\r\nerror = swsusp_write(flags);\r\nswsusp_free();\r\nif (!error)\r\npower_down();\r\nin_suspend = 0;\r\npm_restore_gfp_mask();\r\n} else {\r\npr_debug("PM: Image restored successfully.\n");\r\n}\r\nThaw:\r\nthaw_processes();\r\nFinish:\r\nfree_basic_memory_bitmaps();\r\nusermodehelper_enable();\r\nExit:\r\npm_notifier_call_chain(PM_POST_HIBERNATION);\r\npm_restore_console();\r\natomic_inc(&snapshot_device_available);\r\nUnlock:\r\nmutex_unlock(&pm_mutex);\r\nreturn error;\r\n}\r\nstatic int software_resume(void)\r\n{\r\nint error;\r\nunsigned int flags;\r\nif (noresume)\r\nreturn 0;\r\nmutex_lock_nested(&pm_mutex, SINGLE_DEPTH_NESTING);\r\nif (swsusp_resume_device)\r\ngoto Check_image;\r\nif (!strlen(resume_file)) {\r\nerror = -ENOENT;\r\ngoto Unlock;\r\n}\r\npr_debug("PM: Checking hibernation image partition %s\n", resume_file);\r\nswsusp_resume_device = name_to_dev_t(resume_file);\r\nif (!swsusp_resume_device) {\r\nwait_for_device_probe();\r\nscsi_complete_async_scans();\r\nswsusp_resume_device = name_to_dev_t(resume_file);\r\nif (!swsusp_resume_device) {\r\nerror = -ENODEV;\r\ngoto Unlock;\r\n}\r\n}\r\nCheck_image:\r\npr_debug("PM: Hibernation image partition %d:%d present\n",\r\nMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\r\npr_debug("PM: Looking for hibernation image.\n");\r\nerror = swsusp_check();\r\nif (error)\r\ngoto Unlock;\r\nif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\r\nerror = -EBUSY;\r\nswsusp_close(FMODE_READ);\r\ngoto Unlock;\r\n}\r\npm_prepare_console();\r\nerror = pm_notifier_call_chain(PM_RESTORE_PREPARE);\r\nif (error)\r\ngoto close_finish;\r\nerror = usermodehelper_disable();\r\nif (error)\r\ngoto close_finish;\r\nerror = create_basic_memory_bitmaps();\r\nif (error)\r\ngoto close_finish;\r\npr_debug("PM: Preparing processes for restore.\n");\r\nerror = prepare_processes();\r\nif (error) {\r\nswsusp_close(FMODE_READ);\r\ngoto Done;\r\n}\r\npr_debug("PM: Loading hibernation image.\n");\r\nerror = swsusp_read(&flags);\r\nswsusp_close(FMODE_READ);\r\nif (!error)\r\nhibernation_restore(flags & SF_PLATFORM_MODE);\r\nprintk(KERN_ERR "PM: Failed to load hibernation image, recovering.\n");\r\nswsusp_free();\r\nthaw_processes();\r\nDone:\r\nfree_basic_memory_bitmaps();\r\nusermodehelper_enable();\r\nFinish:\r\npm_notifier_call_chain(PM_POST_RESTORE);\r\npm_restore_console();\r\natomic_inc(&snapshot_device_available);\r\nUnlock:\r\nmutex_unlock(&pm_mutex);\r\npr_debug("PM: Hibernation image not present or could not be loaded.\n");\r\nreturn error;\r\nclose_finish:\r\nswsusp_close(FMODE_READ);\r\ngoto Finish;\r\n}\r\nstatic ssize_t disk_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nint i;\r\nchar *start = buf;\r\nfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\r\nif (!hibernation_modes[i])\r\ncontinue;\r\nswitch (i) {\r\ncase HIBERNATION_SHUTDOWN:\r\ncase HIBERNATION_REBOOT:\r\ncase HIBERNATION_TEST:\r\ncase HIBERNATION_TESTPROC:\r\nbreak;\r\ncase HIBERNATION_PLATFORM:\r\nif (hibernation_ops)\r\nbreak;\r\ncontinue;\r\n}\r\nif (i == hibernation_mode)\r\nbuf += sprintf(buf, "[%s] ", hibernation_modes[i]);\r\nelse\r\nbuf += sprintf(buf, "%s ", hibernation_modes[i]);\r\n}\r\nbuf += sprintf(buf, "\n");\r\nreturn buf-start;\r\n}\r\nstatic ssize_t disk_store(struct kobject *kobj, struct kobj_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nint error = 0;\r\nint i;\r\nint len;\r\nchar *p;\r\nint mode = HIBERNATION_INVALID;\r\np = memchr(buf, '\n', n);\r\nlen = p ? p - buf : n;\r\nmutex_lock(&pm_mutex);\r\nfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\r\nif (len == strlen(hibernation_modes[i])\r\n&& !strncmp(buf, hibernation_modes[i], len)) {\r\nmode = i;\r\nbreak;\r\n}\r\n}\r\nif (mode != HIBERNATION_INVALID) {\r\nswitch (mode) {\r\ncase HIBERNATION_SHUTDOWN:\r\ncase HIBERNATION_REBOOT:\r\ncase HIBERNATION_TEST:\r\ncase HIBERNATION_TESTPROC:\r\nhibernation_mode = mode;\r\nbreak;\r\ncase HIBERNATION_PLATFORM:\r\nif (hibernation_ops)\r\nhibernation_mode = mode;\r\nelse\r\nerror = -EINVAL;\r\n}\r\n} else\r\nerror = -EINVAL;\r\nif (!error)\r\npr_debug("PM: Hibernation mode set to '%s'\n",\r\nhibernation_modes[mode]);\r\nmutex_unlock(&pm_mutex);\r\nreturn error ? error : n;\r\n}\r\nstatic ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf,"%d:%d\n", MAJOR(swsusp_resume_device),\r\nMINOR(swsusp_resume_device));\r\n}\r\nstatic ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nunsigned int maj, min;\r\ndev_t res;\r\nint ret = -EINVAL;\r\nif (sscanf(buf, "%u:%u", &maj, &min) != 2)\r\ngoto out;\r\nres = MKDEV(maj,min);\r\nif (maj != MAJOR(res) || min != MINOR(res))\r\ngoto out;\r\nmutex_lock(&pm_mutex);\r\nswsusp_resume_device = res;\r\nmutex_unlock(&pm_mutex);\r\nprintk(KERN_INFO "PM: Starting manual resume from disk\n");\r\nnoresume = 0;\r\nsoftware_resume();\r\nret = n;\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", image_size);\r\n}\r\nstatic ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nunsigned long size;\r\nif (sscanf(buf, "%lu", &size) == 1) {\r\nimage_size = size;\r\nreturn n;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t reserved_size_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", reserved_size);\r\n}\r\nstatic ssize_t reserved_size_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nunsigned long size;\r\nif (sscanf(buf, "%lu", &size) == 1) {\r\nreserved_size = size;\r\nreturn n;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init pm_disk_init(void)\r\n{\r\nreturn sysfs_create_group(power_kobj, &attr_group);\r\n}\r\nstatic int __init resume_setup(char *str)\r\n{\r\nif (noresume)\r\nreturn 1;\r\nstrncpy( resume_file, str, 255 );\r\nreturn 1;\r\n}\r\nstatic int __init resume_offset_setup(char *str)\r\n{\r\nunsigned long long offset;\r\nif (noresume)\r\nreturn 1;\r\nif (sscanf(str, "%llu", &offset) == 1)\r\nswsusp_resume_block = offset;\r\nreturn 1;\r\n}\r\nstatic int __init hibernate_setup(char *str)\r\n{\r\nif (!strncmp(str, "noresume", 8))\r\nnoresume = 1;\r\nelse if (!strncmp(str, "nocompress", 10))\r\nnocompress = 1;\r\nreturn 1;\r\n}\r\nstatic int __init noresume_setup(char *str)\r\n{\r\nnoresume = 1;\r\nreturn 1;\r\n}
