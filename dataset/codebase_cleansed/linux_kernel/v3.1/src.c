static irqreturn_t aac_src_intr_message(int irq, void *dev_id)\r\n{\r\nstruct aac_dev *dev = dev_id;\r\nunsigned long bellbits, bellbits_shifted;\r\nint our_interrupt = 0;\r\nint isFastResponse;\r\nu32 index, handle;\r\nbellbits = src_readl(dev, MUnit.ODR_R);\r\nif (bellbits & PmDoorBellResponseSent) {\r\nbellbits = PmDoorBellResponseSent;\r\nour_interrupt = 1;\r\nindex = dev->host_rrq_idx;\r\nif (dev->host_rrq[index] == 0) {\r\nu32 old_index = index;\r\ndo {\r\nindex++;\r\nif (index == dev->scsi_host_ptr->can_queue +\r\nAAC_NUM_MGT_FIB)\r\nindex = 0;\r\nif (dev->host_rrq[index] != 0)\r\nbreak;\r\n} while (index != old_index);\r\ndev->host_rrq_idx = index;\r\n}\r\nfor (;;) {\r\nisFastResponse = 0;\r\nhandle = (dev->host_rrq[index] & 0x7fffffff);\r\nif (handle & 0x40000000)\r\nisFastResponse = 1;\r\nhandle &= 0x0000ffff;\r\nif (handle == 0)\r\nbreak;\r\naac_intr_normal(dev, handle-1, 0, isFastResponse, NULL);\r\ndev->host_rrq[index++] = 0;\r\nif (index == dev->scsi_host_ptr->can_queue +\r\nAAC_NUM_MGT_FIB)\r\nindex = 0;\r\ndev->host_rrq_idx = index;\r\n}\r\n} else {\r\nbellbits_shifted = (bellbits >> SRC_ODR_SHIFT);\r\nif (bellbits_shifted & DoorBellAifPending) {\r\nour_interrupt = 1;\r\naac_intr_normal(dev, 0, 2, 0, NULL);\r\n}\r\n}\r\nif (our_interrupt) {\r\nsrc_writel(dev, MUnit.ODR_C, bellbits);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void aac_src_disable_interrupt(struct aac_dev *dev)\r\n{\r\nsrc_writel(dev, MUnit.OIMR, dev->OIMR = 0xffffffff);\r\n}\r\nstatic void aac_src_enable_interrupt_message(struct aac_dev *dev)\r\n{\r\nsrc_writel(dev, MUnit.OIMR, dev->OIMR = 0xfffffff8);\r\n}\r\nstatic int src_sync_cmd(struct aac_dev *dev, u32 command,\r\nu32 p1, u32 p2, u32 p3, u32 p4, u32 p5, u32 p6,\r\nu32 *status, u32 * r1, u32 * r2, u32 * r3, u32 * r4)\r\n{\r\nunsigned long start;\r\nint ok;\r\nwritel(command, &dev->IndexRegs->Mailbox[0]);\r\nwritel(p1, &dev->IndexRegs->Mailbox[1]);\r\nwritel(p2, &dev->IndexRegs->Mailbox[2]);\r\nwritel(p3, &dev->IndexRegs->Mailbox[3]);\r\nwritel(p4, &dev->IndexRegs->Mailbox[4]);\r\nsrc_writel(dev, MUnit.ODR_C, OUTBOUNDDOORBELL_0 << SRC_ODR_SHIFT);\r\nsrc_writel(dev, MUnit.OIMR, dev->OIMR = 0xffffffff);\r\nsrc_readl(dev, MUnit.OIMR);\r\nsrc_writel(dev, MUnit.IDR, INBOUNDDOORBELL_0 << SRC_IDR_SHIFT);\r\nok = 0;\r\nstart = jiffies;\r\nwhile (time_before(jiffies, start+30*HZ)) {\r\nudelay(5);\r\nif ((src_readl(dev, MUnit.ODR_R) >> SRC_ODR_SHIFT) & OUTBOUNDDOORBELL_0) {\r\nsrc_writel(dev,\r\nMUnit.ODR_C,\r\nOUTBOUNDDOORBELL_0 << SRC_ODR_SHIFT);\r\nok = 1;\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\nif (unlikely(ok != 1)) {\r\naac_adapter_enable_int(dev);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (status)\r\n*status = readl(&dev->IndexRegs->Mailbox[0]);\r\nif (r1)\r\n*r1 = readl(&dev->IndexRegs->Mailbox[1]);\r\nif (r2)\r\n*r2 = readl(&dev->IndexRegs->Mailbox[2]);\r\nif (r3)\r\n*r3 = readl(&dev->IndexRegs->Mailbox[3]);\r\nif (r4)\r\n*r4 = readl(&dev->IndexRegs->Mailbox[4]);\r\nsrc_writel(dev, MUnit.ODR_C, OUTBOUNDDOORBELL_0 << SRC_ODR_SHIFT);\r\naac_adapter_enable_int(dev);\r\nreturn 0;\r\n}\r\nstatic void aac_src_interrupt_adapter(struct aac_dev *dev)\r\n{\r\nsrc_sync_cmd(dev, BREAKPOINT_REQUEST,\r\n0, 0, 0, 0, 0, 0,\r\nNULL, NULL, NULL, NULL, NULL);\r\n}\r\nstatic void aac_src_notify_adapter(struct aac_dev *dev, u32 event)\r\n{\r\nswitch (event) {\r\ncase AdapNormCmdQue:\r\nsrc_writel(dev, MUnit.ODR_C,\r\nINBOUNDDOORBELL_1 << SRC_ODR_SHIFT);\r\nbreak;\r\ncase HostNormRespNotFull:\r\nsrc_writel(dev, MUnit.ODR_C,\r\nINBOUNDDOORBELL_4 << SRC_ODR_SHIFT);\r\nbreak;\r\ncase AdapNormRespQue:\r\nsrc_writel(dev, MUnit.ODR_C,\r\nINBOUNDDOORBELL_2 << SRC_ODR_SHIFT);\r\nbreak;\r\ncase HostNormCmdNotFull:\r\nsrc_writel(dev, MUnit.ODR_C,\r\nINBOUNDDOORBELL_3 << SRC_ODR_SHIFT);\r\nbreak;\r\ncase FastIo:\r\nsrc_writel(dev, MUnit.ODR_C,\r\nINBOUNDDOORBELL_6 << SRC_ODR_SHIFT);\r\nbreak;\r\ncase AdapPrintfDone:\r\nsrc_writel(dev, MUnit.ODR_C,\r\nINBOUNDDOORBELL_5 << SRC_ODR_SHIFT);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic void aac_src_start_adapter(struct aac_dev *dev)\r\n{\r\nstruct aac_init *init;\r\ninit = dev->init;\r\ninit->HostElapsedSeconds = cpu_to_le32(get_seconds());\r\nsrc_sync_cmd(dev, INIT_STRUCT_BASE_ADDRESS, (u32)(ulong)dev->init_pa,\r\n0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL);\r\n}\r\nstatic int aac_src_check_health(struct aac_dev *dev)\r\n{\r\nu32 status = src_readl(dev, MUnit.OMR);\r\nif (unlikely(status & SELF_TEST_FAILED))\r\nreturn -1;\r\nif (unlikely(status & KERNEL_PANIC))\r\nreturn (status >> 16) & 0xFF;\r\nif (unlikely(!(status & KERNEL_UP_AND_RUNNING)))\r\nreturn -3;\r\nreturn 0;\r\n}\r\nstatic int aac_src_deliver_message(struct fib *fib)\r\n{\r\nstruct aac_dev *dev = fib->dev;\r\nstruct aac_queue *q = &dev->queues->queue[AdapNormCmdQueue];\r\nunsigned long qflags;\r\nu32 fibsize;\r\nu64 address;\r\nstruct aac_fib_xporthdr *pFibX;\r\nspin_lock_irqsave(q->lock, qflags);\r\nq->numpending++;\r\nspin_unlock_irqrestore(q->lock, qflags);\r\nfibsize = (sizeof(struct aac_fib_xporthdr) +\r\nfib->hw_fib_va->header.Size + 127) / 128 - 1;\r\nif (fibsize > (ALIGN32 - 1))\r\nfibsize = ALIGN32 - 1;\r\npFibX = (struct aac_fib_xporthdr *)\r\n((unsigned char *)fib->hw_fib_va -\r\nsizeof(struct aac_fib_xporthdr));\r\npFibX->Handle = fib->hw_fib_va->header.SenderData + 1;\r\npFibX->HostAddress = fib->hw_fib_pa;\r\npFibX->Size = fib->hw_fib_va->header.Size;\r\naddress = fib->hw_fib_pa - (u64)sizeof(struct aac_fib_xporthdr);\r\nsrc_writel(dev, MUnit.IQ_H, (u32)(address >> 32));\r\nsrc_writel(dev, MUnit.IQ_L, (u32)(address & 0xffffffff) + fibsize);\r\nreturn 0;\r\n}\r\nstatic int aac_src_ioremap(struct aac_dev *dev, u32 size)\r\n{\r\nif (!size) {\r\niounmap(dev->regs.src.bar0);\r\ndev->regs.src.bar0 = NULL;\r\niounmap(dev->base);\r\ndev->base = NULL;\r\nreturn 0;\r\n}\r\ndev->regs.src.bar1 = ioremap(pci_resource_start(dev->pdev, 2),\r\nAAC_MIN_SRC_BAR1_SIZE);\r\ndev->base = NULL;\r\nif (dev->regs.src.bar1 == NULL)\r\nreturn -1;\r\ndev->base = dev->regs.src.bar0 = ioremap(dev->scsi_host_ptr->base,\r\nsize);\r\nif (dev->base == NULL) {\r\niounmap(dev->regs.src.bar1);\r\ndev->regs.src.bar1 = NULL;\r\nreturn -1;\r\n}\r\ndev->IndexRegs = &((struct src_registers __iomem *)\r\ndev->base)->IndexRegs;\r\nreturn 0;\r\n}\r\nstatic int aac_src_restart_adapter(struct aac_dev *dev, int bled)\r\n{\r\nu32 var, reset_mask;\r\nif (bled >= 0) {\r\nif (bled)\r\nprintk(KERN_ERR "%s%d: adapter kernel panic'd %x.\n",\r\ndev->name, dev->id, bled);\r\nbled = aac_adapter_sync_cmd(dev, IOP_RESET_ALWAYS,\r\n0, 0, 0, 0, 0, 0, &var, &reset_mask, NULL, NULL, NULL);\r\nif (bled || (var != 0x00000001))\r\nbled = -EINVAL;\r\nif (dev->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_DOORBELL_RESET) {\r\nsrc_writel(dev, MUnit.IDR, reset_mask);\r\nmsleep(5000);\r\n}\r\n}\r\nif (src_readl(dev, MUnit.OMR) & KERNEL_PANIC)\r\nreturn -ENODEV;\r\nif (startup_timeout < 300)\r\nstartup_timeout = 300;\r\nreturn 0;\r\n}\r\nint aac_src_select_comm(struct aac_dev *dev, int comm)\r\n{\r\nswitch (comm) {\r\ncase AAC_COMM_MESSAGE:\r\ndev->a_ops.adapter_enable_int = aac_src_enable_interrupt_message;\r\ndev->a_ops.adapter_intr = aac_src_intr_message;\r\ndev->a_ops.adapter_deliver = aac_src_deliver_message;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint aac_src_init(struct aac_dev *dev)\r\n{\r\nunsigned long start;\r\nunsigned long status;\r\nint restart = 0;\r\nint instance = dev->id;\r\nconst char *name = dev->name;\r\ndev->a_ops.adapter_ioremap = aac_src_ioremap;\r\ndev->a_ops.adapter_comm = aac_src_select_comm;\r\ndev->base_size = AAC_MIN_SRC_BAR0_SIZE;\r\nif (aac_adapter_ioremap(dev, dev->base_size)) {\r\nprintk(KERN_WARNING "%s: unable to map adapter.\n", name);\r\ngoto error_iounmap;\r\n}\r\ndev->a_ops.adapter_sync_cmd = src_sync_cmd;\r\ndev->a_ops.adapter_enable_int = aac_src_disable_interrupt;\r\nif ((aac_reset_devices || reset_devices) &&\r\n!aac_src_restart_adapter(dev, 0))\r\n++restart;\r\nstatus = src_readl(dev, MUnit.OMR);\r\nif (status & KERNEL_PANIC) {\r\nif (aac_src_restart_adapter(dev, aac_src_check_health(dev)))\r\ngoto error_iounmap;\r\n++restart;\r\n}\r\nstatus = src_readl(dev, MUnit.OMR);\r\nif (status & SELF_TEST_FAILED) {\r\nprintk(KERN_ERR "%s%d: adapter self-test failed.\n",\r\ndev->name, instance);\r\ngoto error_iounmap;\r\n}\r\nif (status & MONITOR_PANIC) {\r\nprintk(KERN_ERR "%s%d: adapter monitor panic.\n",\r\ndev->name, instance);\r\ngoto error_iounmap;\r\n}\r\nstart = jiffies;\r\nwhile (!((status = src_readl(dev, MUnit.OMR)) &\r\nKERNEL_UP_AND_RUNNING)) {\r\nif ((restart &&\r\n(status & (KERNEL_PANIC|SELF_TEST_FAILED|MONITOR_PANIC))) ||\r\ntime_after(jiffies, start+HZ*startup_timeout)) {\r\nprintk(KERN_ERR "%s%d: adapter kernel failed to start, init status = %lx.\n",\r\ndev->name, instance, status);\r\ngoto error_iounmap;\r\n}\r\nif (!restart &&\r\n((status & (KERNEL_PANIC|SELF_TEST_FAILED|MONITOR_PANIC)) ||\r\ntime_after(jiffies, start + HZ *\r\n((startup_timeout > 60)\r\n? (startup_timeout - 60)\r\n: (startup_timeout / 2))))) {\r\nif (likely(!aac_src_restart_adapter(dev,\r\naac_src_check_health(dev))))\r\nstart = jiffies;\r\n++restart;\r\n}\r\nmsleep(1);\r\n}\r\nif (restart && aac_commit)\r\naac_commit = 1;\r\ndev->a_ops.adapter_interrupt = aac_src_interrupt_adapter;\r\ndev->a_ops.adapter_disable_int = aac_src_disable_interrupt;\r\ndev->a_ops.adapter_notify = aac_src_notify_adapter;\r\ndev->a_ops.adapter_sync_cmd = src_sync_cmd;\r\ndev->a_ops.adapter_check_health = aac_src_check_health;\r\ndev->a_ops.adapter_restart = aac_src_restart_adapter;\r\naac_adapter_comm(dev, AAC_COMM_MESSAGE);\r\naac_adapter_disable_int(dev);\r\nsrc_writel(dev, MUnit.ODR_C, 0xffffffff);\r\naac_adapter_enable_int(dev);\r\nif (aac_init_adapter(dev) == NULL)\r\ngoto error_iounmap;\r\nif (dev->comm_interface != AAC_COMM_MESSAGE_TYPE1)\r\ngoto error_iounmap;\r\ndev->msi = aac_msi && !pci_enable_msi(dev->pdev);\r\nif (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,\r\nIRQF_SHARED|IRQF_DISABLED, "aacraid", dev) < 0) {\r\nif (dev->msi)\r\npci_disable_msi(dev->pdev);\r\nprintk(KERN_ERR "%s%d: Interrupt unavailable.\n",\r\nname, instance);\r\ngoto error_iounmap;\r\n}\r\ndev->dbg_base = pci_resource_start(dev->pdev, 2);\r\ndev->dbg_base_mapped = dev->regs.src.bar1;\r\ndev->dbg_size = AAC_MIN_SRC_BAR1_SIZE;\r\naac_adapter_enable_int(dev);\r\naac_src_start_adapter(dev);\r\nreturn 0;\r\nerror_iounmap:\r\nreturn -1;\r\n}
