static struct qfq_class *qfq_find_class(struct Qdisc *sch, u32 classid)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct Qdisc_class_common *clc;\r\nclc = qdisc_class_find(&q->clhash, classid);\r\nif (clc == NULL)\r\nreturn NULL;\r\nreturn container_of(clc, struct qfq_class, common);\r\n}\r\nstatic void qfq_purge_queue(struct qfq_class *cl)\r\n{\r\nunsigned int len = cl->qdisc->q.qlen;\r\nqdisc_reset(cl->qdisc);\r\nqdisc_tree_decrease_qlen(cl->qdisc, len);\r\n}\r\nstatic int qfq_calc_index(u32 inv_w, unsigned int maxlen)\r\n{\r\nu64 slot_size = (u64)maxlen * inv_w;\r\nunsigned long size_map;\r\nint index = 0;\r\nsize_map = slot_size >> QFQ_MIN_SLOT_SHIFT;\r\nif (!size_map)\r\ngoto out;\r\nindex = __fls(size_map) + 1;\r\nindex -= !(slot_size - (1ULL << (index + QFQ_MIN_SLOT_SHIFT - 1)));\r\nif (index < 0)\r\nindex = 0;\r\nout:\r\npr_debug("qfq calc_index: W = %lu, L = %u, I = %d\n",\r\n(unsigned long) ONE_FP/inv_w, maxlen, index);\r\nreturn index;\r\n}\r\nstatic int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,\r\nstruct nlattr **tca, unsigned long *arg)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_class *cl = (struct qfq_class *)*arg;\r\nstruct nlattr *tb[TCA_QFQ_MAX + 1];\r\nu32 weight, lmax, inv_w;\r\nint i, err;\r\nif (tca[TCA_OPTIONS] == NULL) {\r\npr_notice("qfq: no options\n");\r\nreturn -EINVAL;\r\n}\r\nerr = nla_parse_nested(tb, TCA_QFQ_MAX, tca[TCA_OPTIONS], qfq_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_QFQ_WEIGHT]) {\r\nweight = nla_get_u32(tb[TCA_QFQ_WEIGHT]);\r\nif (!weight || weight > (1UL << QFQ_MAX_WSHIFT)) {\r\npr_notice("qfq: invalid weight %u\n", weight);\r\nreturn -EINVAL;\r\n}\r\n} else\r\nweight = 1;\r\ninv_w = ONE_FP / weight;\r\nweight = ONE_FP / inv_w;\r\nif (q->wsum + weight > QFQ_MAX_WSUM) {\r\npr_notice("qfq: total weight out of range (%u + %u)\n",\r\nweight, q->wsum);\r\nreturn -EINVAL;\r\n}\r\nif (tb[TCA_QFQ_LMAX]) {\r\nlmax = nla_get_u32(tb[TCA_QFQ_LMAX]);\r\nif (!lmax || lmax > (1UL << QFQ_MTU_SHIFT)) {\r\npr_notice("qfq: invalid max length %u\n", lmax);\r\nreturn -EINVAL;\r\n}\r\n} else\r\nlmax = 1UL << QFQ_MTU_SHIFT;\r\nif (cl != NULL) {\r\nif (tca[TCA_RATE]) {\r\nerr = gen_replace_estimator(&cl->bstats, &cl->rate_est,\r\nqdisc_root_sleeping_lock(sch),\r\ntca[TCA_RATE]);\r\nif (err)\r\nreturn err;\r\n}\r\nsch_tree_lock(sch);\r\nif (tb[TCA_QFQ_WEIGHT]) {\r\nq->wsum = weight - ONE_FP / cl->inv_w;\r\ncl->inv_w = inv_w;\r\n}\r\nsch_tree_unlock(sch);\r\nreturn 0;\r\n}\r\ncl = kzalloc(sizeof(struct qfq_class), GFP_KERNEL);\r\nif (cl == NULL)\r\nreturn -ENOBUFS;\r\ncl->refcnt = 1;\r\ncl->common.classid = classid;\r\ncl->lmax = lmax;\r\ncl->inv_w = inv_w;\r\ni = qfq_calc_index(cl->inv_w, cl->lmax);\r\ncl->grp = &q->groups[i];\r\nq->wsum += weight;\r\ncl->qdisc = qdisc_create_dflt(sch->dev_queue,\r\n&pfifo_qdisc_ops, classid);\r\nif (cl->qdisc == NULL)\r\ncl->qdisc = &noop_qdisc;\r\nif (tca[TCA_RATE]) {\r\nerr = gen_new_estimator(&cl->bstats, &cl->rate_est,\r\nqdisc_root_sleeping_lock(sch),\r\ntca[TCA_RATE]);\r\nif (err) {\r\nqdisc_destroy(cl->qdisc);\r\nkfree(cl);\r\nreturn err;\r\n}\r\n}\r\nsch_tree_lock(sch);\r\nqdisc_class_hash_insert(&q->clhash, &cl->common);\r\nsch_tree_unlock(sch);\r\nqdisc_class_hash_grow(sch, &q->clhash);\r\n*arg = (unsigned long)cl;\r\nreturn 0;\r\n}\r\nstatic void qfq_destroy_class(struct Qdisc *sch, struct qfq_class *cl)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nif (cl->inv_w) {\r\nq->wsum -= ONE_FP / cl->inv_w;\r\ncl->inv_w = 0;\r\n}\r\ngen_kill_estimator(&cl->bstats, &cl->rate_est);\r\nqdisc_destroy(cl->qdisc);\r\nkfree(cl);\r\n}\r\nstatic int qfq_delete_class(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_class *cl = (struct qfq_class *)arg;\r\nif (cl->filter_cnt > 0)\r\nreturn -EBUSY;\r\nsch_tree_lock(sch);\r\nqfq_purge_queue(cl);\r\nqdisc_class_hash_remove(&q->clhash, &cl->common);\r\nBUG_ON(--cl->refcnt == 0);\r\nsch_tree_unlock(sch);\r\nreturn 0;\r\n}\r\nstatic unsigned long qfq_get_class(struct Qdisc *sch, u32 classid)\r\n{\r\nstruct qfq_class *cl = qfq_find_class(sch, classid);\r\nif (cl != NULL)\r\ncl->refcnt++;\r\nreturn (unsigned long)cl;\r\n}\r\nstatic void qfq_put_class(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct qfq_class *cl = (struct qfq_class *)arg;\r\nif (--cl->refcnt == 0)\r\nqfq_destroy_class(sch, cl);\r\n}\r\nstatic struct tcf_proto **qfq_tcf_chain(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nif (cl)\r\nreturn NULL;\r\nreturn &q->filter_list;\r\n}\r\nstatic unsigned long qfq_bind_tcf(struct Qdisc *sch, unsigned long parent,\r\nu32 classid)\r\n{\r\nstruct qfq_class *cl = qfq_find_class(sch, classid);\r\nif (cl != NULL)\r\ncl->filter_cnt++;\r\nreturn (unsigned long)cl;\r\n}\r\nstatic void qfq_unbind_tcf(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct qfq_class *cl = (struct qfq_class *)arg;\r\ncl->filter_cnt--;\r\n}\r\nstatic int qfq_graft_class(struct Qdisc *sch, unsigned long arg,\r\nstruct Qdisc *new, struct Qdisc **old)\r\n{\r\nstruct qfq_class *cl = (struct qfq_class *)arg;\r\nif (new == NULL) {\r\nnew = qdisc_create_dflt(sch->dev_queue,\r\n&pfifo_qdisc_ops, cl->common.classid);\r\nif (new == NULL)\r\nnew = &noop_qdisc;\r\n}\r\nsch_tree_lock(sch);\r\nqfq_purge_queue(cl);\r\n*old = cl->qdisc;\r\ncl->qdisc = new;\r\nsch_tree_unlock(sch);\r\nreturn 0;\r\n}\r\nstatic struct Qdisc *qfq_class_leaf(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct qfq_class *cl = (struct qfq_class *)arg;\r\nreturn cl->qdisc;\r\n}\r\nstatic int qfq_dump_class(struct Qdisc *sch, unsigned long arg,\r\nstruct sk_buff *skb, struct tcmsg *tcm)\r\n{\r\nstruct qfq_class *cl = (struct qfq_class *)arg;\r\nstruct nlattr *nest;\r\ntcm->tcm_parent = TC_H_ROOT;\r\ntcm->tcm_handle = cl->common.classid;\r\ntcm->tcm_info = cl->qdisc->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nNLA_PUT_U32(skb, TCA_QFQ_WEIGHT, ONE_FP/cl->inv_w);\r\nNLA_PUT_U32(skb, TCA_QFQ_LMAX, cl->lmax);\r\nreturn nla_nest_end(skb, nest);\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int qfq_dump_class_stats(struct Qdisc *sch, unsigned long arg,\r\nstruct gnet_dump *d)\r\n{\r\nstruct qfq_class *cl = (struct qfq_class *)arg;\r\nstruct tc_qfq_stats xstats;\r\nmemset(&xstats, 0, sizeof(xstats));\r\ncl->qdisc->qstats.qlen = cl->qdisc->q.qlen;\r\nxstats.weight = ONE_FP/cl->inv_w;\r\nxstats.lmax = cl->lmax;\r\nif (gnet_stats_copy_basic(d, &cl->bstats) < 0 ||\r\ngnet_stats_copy_rate_est(d, &cl->bstats, &cl->rate_est) < 0 ||\r\ngnet_stats_copy_queue(d, &cl->qdisc->qstats) < 0)\r\nreturn -1;\r\nreturn gnet_stats_copy_app(d, &xstats, sizeof(xstats));\r\n}\r\nstatic void qfq_walk(struct Qdisc *sch, struct qdisc_walker *arg)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_class *cl;\r\nstruct hlist_node *n;\r\nunsigned int i;\r\nif (arg->stop)\r\nreturn;\r\nfor (i = 0; i < q->clhash.hashsize; i++) {\r\nhlist_for_each_entry(cl, n, &q->clhash.hash[i], common.hnode) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(sch, (unsigned long)cl, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\narg->count++;\r\n}\r\n}\r\n}\r\nstatic struct qfq_class *qfq_classify(struct sk_buff *skb, struct Qdisc *sch,\r\nint *qerr)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_class *cl;\r\nstruct tcf_result res;\r\nint result;\r\nif (TC_H_MAJ(skb->priority ^ sch->handle) == 0) {\r\npr_debug("qfq_classify: found %d\n", skb->priority);\r\ncl = qfq_find_class(sch, skb->priority);\r\nif (cl != NULL)\r\nreturn cl;\r\n}\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\r\nresult = tc_classify(skb, q->filter_list, &res);\r\nif (result >= 0) {\r\n#ifdef CONFIG_NET_CLS_ACT\r\nswitch (result) {\r\ncase TC_ACT_QUEUED:\r\ncase TC_ACT_STOLEN:\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\r\ncase TC_ACT_SHOT:\r\nreturn NULL;\r\n}\r\n#endif\r\ncl = (struct qfq_class *)res.class;\r\nif (cl == NULL)\r\ncl = qfq_find_class(sch, res.classid);\r\nreturn cl;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int qfq_gt(u64 a, u64 b)\r\n{\r\nreturn (s64)(a - b) > 0;\r\n}\r\nstatic inline u64 qfq_round_down(u64 ts, unsigned int shift)\r\n{\r\nreturn ts & ~((1ULL << shift) - 1);\r\n}\r\nstatic inline struct qfq_group *qfq_ffs(struct qfq_sched *q,\r\nunsigned long bitmap)\r\n{\r\nint index = __ffs(bitmap);\r\nreturn &q->groups[index];\r\n}\r\nstatic inline unsigned long mask_from(unsigned long bitmap, int from)\r\n{\r\nreturn bitmap & ~((1UL << from) - 1);\r\n}\r\nstatic int qfq_calc_state(struct qfq_sched *q, const struct qfq_group *grp)\r\n{\r\nunsigned int state = qfq_gt(grp->S, q->V);\r\nunsigned long mask = mask_from(q->bitmaps[ER], grp->index);\r\nstruct qfq_group *next;\r\nif (mask) {\r\nnext = qfq_ffs(q, mask);\r\nif (qfq_gt(grp->F, next->F))\r\nstate |= EB;\r\n}\r\nreturn state;\r\n}\r\nstatic inline void qfq_move_groups(struct qfq_sched *q, unsigned long mask,\r\nint src, int dst)\r\n{\r\nq->bitmaps[dst] |= q->bitmaps[src] & mask;\r\nq->bitmaps[src] &= ~mask;\r\n}\r\nstatic void qfq_unblock_groups(struct qfq_sched *q, int index, u64 old_F)\r\n{\r\nunsigned long mask = mask_from(q->bitmaps[ER], index + 1);\r\nstruct qfq_group *next;\r\nif (mask) {\r\nnext = qfq_ffs(q, mask);\r\nif (!qfq_gt(next->F, old_F))\r\nreturn;\r\n}\r\nmask = (1UL << index) - 1;\r\nqfq_move_groups(q, mask, EB, ER);\r\nqfq_move_groups(q, mask, IB, IR);\r\n}\r\nstatic void qfq_make_eligible(struct qfq_sched *q, u64 old_V)\r\n{\r\nunsigned long vslot = q->V >> QFQ_MIN_SLOT_SHIFT;\r\nunsigned long old_vslot = old_V >> QFQ_MIN_SLOT_SHIFT;\r\nif (vslot != old_vslot) {\r\nunsigned long mask = (1UL << fls(vslot ^ old_vslot)) - 1;\r\nqfq_move_groups(q, mask, IR, ER);\r\nqfq_move_groups(q, mask, IB, EB);\r\n}\r\n}\r\nstatic void qfq_slot_insert(struct qfq_group *grp, struct qfq_class *cl,\r\nu64 roundedS)\r\n{\r\nu64 slot = (roundedS - grp->S) >> grp->slot_shift;\r\nunsigned int i = (grp->front + slot) % QFQ_MAX_SLOTS;\r\nhlist_add_head(&cl->next, &grp->slots[i]);\r\n__set_bit(slot, &grp->full_slots);\r\n}\r\nstatic struct qfq_class *qfq_slot_head(struct qfq_group *grp)\r\n{\r\nreturn hlist_entry(grp->slots[grp->front].first,\r\nstruct qfq_class, next);\r\n}\r\nstatic void qfq_front_slot_remove(struct qfq_group *grp)\r\n{\r\nstruct qfq_class *cl = qfq_slot_head(grp);\r\nBUG_ON(!cl);\r\nhlist_del(&cl->next);\r\nif (hlist_empty(&grp->slots[grp->front]))\r\n__clear_bit(0, &grp->full_slots);\r\n}\r\nstatic struct qfq_class *qfq_slot_scan(struct qfq_group *grp)\r\n{\r\nunsigned int i;\r\npr_debug("qfq slot_scan: grp %u full %#lx\n",\r\ngrp->index, grp->full_slots);\r\nif (grp->full_slots == 0)\r\nreturn NULL;\r\ni = __ffs(grp->full_slots);\r\nif (i > 0) {\r\ngrp->front = (grp->front + i) % QFQ_MAX_SLOTS;\r\ngrp->full_slots >>= i;\r\n}\r\nreturn qfq_slot_head(grp);\r\n}\r\nstatic void qfq_slot_rotate(struct qfq_group *grp, u64 roundedS)\r\n{\r\nunsigned int i = (grp->S - roundedS) >> grp->slot_shift;\r\ngrp->full_slots <<= i;\r\ngrp->front = (grp->front - i) % QFQ_MAX_SLOTS;\r\n}\r\nstatic void qfq_update_eligible(struct qfq_sched *q, u64 old_V)\r\n{\r\nstruct qfq_group *grp;\r\nunsigned long ineligible;\r\nineligible = q->bitmaps[IR] | q->bitmaps[IB];\r\nif (ineligible) {\r\nif (!q->bitmaps[ER]) {\r\ngrp = qfq_ffs(q, ineligible);\r\nif (qfq_gt(grp->S, q->V))\r\nq->V = grp->S;\r\n}\r\nqfq_make_eligible(q, old_V);\r\n}\r\n}\r\nstatic unsigned int qdisc_peek_len(struct Qdisc *sch)\r\n{\r\nstruct sk_buff *skb;\r\nskb = sch->ops->peek(sch);\r\nreturn skb ? qdisc_pkt_len(skb) : 0;\r\n}\r\nstatic bool qfq_update_class(struct qfq_group *grp, struct qfq_class *cl)\r\n{\r\nunsigned int len = qdisc_peek_len(cl->qdisc);\r\ncl->S = cl->F;\r\nif (!len)\r\nqfq_front_slot_remove(grp);\r\nelse {\r\nu64 roundedS;\r\ncl->F = cl->S + (u64)len * cl->inv_w;\r\nroundedS = qfq_round_down(cl->S, grp->slot_shift);\r\nif (roundedS == grp->S)\r\nreturn false;\r\nqfq_front_slot_remove(grp);\r\nqfq_slot_insert(grp, cl, roundedS);\r\n}\r\nreturn true;\r\n}\r\nstatic struct sk_buff *qfq_dequeue(struct Qdisc *sch)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_group *grp;\r\nstruct qfq_class *cl;\r\nstruct sk_buff *skb;\r\nunsigned int len;\r\nu64 old_V;\r\nif (!q->bitmaps[ER])\r\nreturn NULL;\r\ngrp = qfq_ffs(q, q->bitmaps[ER]);\r\ncl = qfq_slot_head(grp);\r\nskb = qdisc_dequeue_peeked(cl->qdisc);\r\nif (!skb) {\r\nWARN_ONCE(1, "qfq_dequeue: non-workconserving leaf\n");\r\nreturn NULL;\r\n}\r\nsch->q.qlen--;\r\nqdisc_bstats_update(sch, skb);\r\nold_V = q->V;\r\nlen = qdisc_pkt_len(skb);\r\nq->V += (u64)len * IWSUM;\r\npr_debug("qfq dequeue: len %u F %lld now %lld\n",\r\nlen, (unsigned long long) cl->F, (unsigned long long) q->V);\r\nif (qfq_update_class(grp, cl)) {\r\nu64 old_F = grp->F;\r\ncl = qfq_slot_scan(grp);\r\nif (!cl)\r\n__clear_bit(grp->index, &q->bitmaps[ER]);\r\nelse {\r\nu64 roundedS = qfq_round_down(cl->S, grp->slot_shift);\r\nunsigned int s;\r\nif (grp->S == roundedS)\r\ngoto skip_unblock;\r\ngrp->S = roundedS;\r\ngrp->F = roundedS + (2ULL << grp->slot_shift);\r\n__clear_bit(grp->index, &q->bitmaps[ER]);\r\ns = qfq_calc_state(q, grp);\r\n__set_bit(grp->index, &q->bitmaps[s]);\r\n}\r\nqfq_unblock_groups(q, grp->index, old_F);\r\n}\r\nskip_unblock:\r\nqfq_update_eligible(q, old_V);\r\nreturn skb;\r\n}\r\nstatic void qfq_update_start(struct qfq_sched *q, struct qfq_class *cl)\r\n{\r\nunsigned long mask;\r\nuint32_t limit, roundedF;\r\nint slot_shift = cl->grp->slot_shift;\r\nroundedF = qfq_round_down(cl->F, slot_shift);\r\nlimit = qfq_round_down(q->V, slot_shift) + (1UL << slot_shift);\r\nif (!qfq_gt(cl->F, q->V) || qfq_gt(roundedF, limit)) {\r\nmask = mask_from(q->bitmaps[ER], cl->grp->index);\r\nif (mask) {\r\nstruct qfq_group *next = qfq_ffs(q, mask);\r\nif (qfq_gt(roundedF, next->F)) {\r\ncl->S = next->F;\r\nreturn;\r\n}\r\n}\r\ncl->S = q->V;\r\n} else\r\ncl->S = cl->F;\r\n}\r\nstatic int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_group *grp;\r\nstruct qfq_class *cl;\r\nint err;\r\nu64 roundedS;\r\nint s;\r\ncl = qfq_classify(skb, sch, &err);\r\nif (cl == NULL) {\r\nif (err & __NET_XMIT_BYPASS)\r\nsch->qstats.drops++;\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\npr_debug("qfq_enqueue: cl = %x\n", cl->common.classid);\r\nerr = qdisc_enqueue(skb, cl->qdisc);\r\nif (unlikely(err != NET_XMIT_SUCCESS)) {\r\npr_debug("qfq_enqueue: enqueue failed %d\n", err);\r\nif (net_xmit_drop_count(err)) {\r\ncl->qstats.drops++;\r\nsch->qstats.drops++;\r\n}\r\nreturn err;\r\n}\r\nbstats_update(&cl->bstats, skb);\r\n++sch->q.qlen;\r\nif (cl->qdisc->q.qlen != 1)\r\nreturn err;\r\ngrp = cl->grp;\r\nqfq_update_start(q, cl);\r\ncl->F = cl->S + (u64)qdisc_pkt_len(skb) * cl->inv_w;\r\nroundedS = qfq_round_down(cl->S, grp->slot_shift);\r\nif (grp->full_slots) {\r\nif (!qfq_gt(grp->S, cl->S))\r\ngoto skip_update;\r\nqfq_slot_rotate(grp, roundedS);\r\n__clear_bit(grp->index, &q->bitmaps[IR]);\r\n__clear_bit(grp->index, &q->bitmaps[IB]);\r\n} else if (!q->bitmaps[ER] && qfq_gt(roundedS, q->V))\r\nq->V = roundedS;\r\ngrp->S = roundedS;\r\ngrp->F = roundedS + (2ULL << grp->slot_shift);\r\ns = qfq_calc_state(q, grp);\r\n__set_bit(grp->index, &q->bitmaps[s]);\r\npr_debug("qfq enqueue: new state %d %#lx S %lld F %lld V %lld\n",\r\ns, q->bitmaps[s],\r\n(unsigned long long) cl->S,\r\n(unsigned long long) cl->F,\r\n(unsigned long long) q->V);\r\nskip_update:\r\nqfq_slot_insert(grp, cl, roundedS);\r\nreturn err;\r\n}\r\nstatic void qfq_slot_remove(struct qfq_sched *q, struct qfq_group *grp,\r\nstruct qfq_class *cl)\r\n{\r\nunsigned int i, offset;\r\nu64 roundedS;\r\nroundedS = qfq_round_down(cl->S, grp->slot_shift);\r\noffset = (roundedS - grp->S) >> grp->slot_shift;\r\ni = (grp->front + offset) % QFQ_MAX_SLOTS;\r\nhlist_del(&cl->next);\r\nif (hlist_empty(&grp->slots[i]))\r\n__clear_bit(offset, &grp->full_slots);\r\n}\r\nstatic void qfq_deactivate_class(struct qfq_sched *q, struct qfq_class *cl)\r\n{\r\nstruct qfq_group *grp = cl->grp;\r\nunsigned long mask;\r\nu64 roundedS;\r\nint s;\r\ncl->F = cl->S;\r\nqfq_slot_remove(q, grp, cl);\r\nif (!grp->full_slots) {\r\n__clear_bit(grp->index, &q->bitmaps[IR]);\r\n__clear_bit(grp->index, &q->bitmaps[EB]);\r\n__clear_bit(grp->index, &q->bitmaps[IB]);\r\nif (test_bit(grp->index, &q->bitmaps[ER]) &&\r\n!(q->bitmaps[ER] & ~((1UL << grp->index) - 1))) {\r\nmask = q->bitmaps[ER] & ((1UL << grp->index) - 1);\r\nif (mask)\r\nmask = ~((1UL << __fls(mask)) - 1);\r\nelse\r\nmask = ~0UL;\r\nqfq_move_groups(q, mask, EB, ER);\r\nqfq_move_groups(q, mask, IB, IR);\r\n}\r\n__clear_bit(grp->index, &q->bitmaps[ER]);\r\n} else if (hlist_empty(&grp->slots[grp->front])) {\r\ncl = qfq_slot_scan(grp);\r\nroundedS = qfq_round_down(cl->S, grp->slot_shift);\r\nif (grp->S != roundedS) {\r\n__clear_bit(grp->index, &q->bitmaps[ER]);\r\n__clear_bit(grp->index, &q->bitmaps[IR]);\r\n__clear_bit(grp->index, &q->bitmaps[EB]);\r\n__clear_bit(grp->index, &q->bitmaps[IB]);\r\ngrp->S = roundedS;\r\ngrp->F = roundedS + (2ULL << grp->slot_shift);\r\ns = qfq_calc_state(q, grp);\r\n__set_bit(grp->index, &q->bitmaps[s]);\r\n}\r\n}\r\nqfq_update_eligible(q, q->V);\r\n}\r\nstatic void qfq_qlen_notify(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_class *cl = (struct qfq_class *)arg;\r\nif (cl->qdisc->q.qlen == 0)\r\nqfq_deactivate_class(q, cl);\r\n}\r\nstatic unsigned int qfq_drop(struct Qdisc *sch)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_group *grp;\r\nunsigned int i, j, len;\r\nfor (i = 0; i <= QFQ_MAX_INDEX; i++) {\r\ngrp = &q->groups[i];\r\nfor (j = 0; j < QFQ_MAX_SLOTS; j++) {\r\nstruct qfq_class *cl;\r\nstruct hlist_node *n;\r\nhlist_for_each_entry(cl, n, &grp->slots[j], next) {\r\nif (!cl->qdisc->ops->drop)\r\ncontinue;\r\nlen = cl->qdisc->ops->drop(cl->qdisc);\r\nif (len > 0) {\r\nsch->q.qlen--;\r\nif (!cl->qdisc->q.qlen)\r\nqfq_deactivate_class(q, cl);\r\nreturn len;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qfq_init_qdisc(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_group *grp;\r\nint i, j, err;\r\nerr = qdisc_class_hash_init(&q->clhash);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i <= QFQ_MAX_INDEX; i++) {\r\ngrp = &q->groups[i];\r\ngrp->index = i;\r\ngrp->slot_shift = QFQ_MTU_SHIFT + FRAC_BITS\r\n- (QFQ_MAX_INDEX - i);\r\nfor (j = 0; j < QFQ_MAX_SLOTS; j++)\r\nINIT_HLIST_HEAD(&grp->slots[j]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void qfq_reset_qdisc(struct Qdisc *sch)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_group *grp;\r\nstruct qfq_class *cl;\r\nstruct hlist_node *n, *tmp;\r\nunsigned int i, j;\r\nfor (i = 0; i <= QFQ_MAX_INDEX; i++) {\r\ngrp = &q->groups[i];\r\nfor (j = 0; j < QFQ_MAX_SLOTS; j++) {\r\nhlist_for_each_entry_safe(cl, n, tmp,\r\n&grp->slots[j], next) {\r\nqfq_deactivate_class(q, cl);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < q->clhash.hashsize; i++) {\r\nhlist_for_each_entry(cl, n, &q->clhash.hash[i], common.hnode)\r\nqdisc_reset(cl->qdisc);\r\n}\r\nsch->q.qlen = 0;\r\n}\r\nstatic void qfq_destroy_qdisc(struct Qdisc *sch)\r\n{\r\nstruct qfq_sched *q = qdisc_priv(sch);\r\nstruct qfq_class *cl;\r\nstruct hlist_node *n, *next;\r\nunsigned int i;\r\ntcf_destroy_chain(&q->filter_list);\r\nfor (i = 0; i < q->clhash.hashsize; i++) {\r\nhlist_for_each_entry_safe(cl, n, next, &q->clhash.hash[i],\r\ncommon.hnode) {\r\nqfq_destroy_class(sch, cl);\r\n}\r\n}\r\nqdisc_class_hash_destroy(&q->clhash);\r\n}\r\nstatic int __init qfq_init(void)\r\n{\r\nreturn register_qdisc(&qfq_qdisc_ops);\r\n}\r\nstatic void __exit qfq_exit(void)\r\n{\r\nunregister_qdisc(&qfq_qdisc_ops);\r\n}
