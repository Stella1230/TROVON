static ssize_t aoedisk_show_state(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nreturn snprintf(page, PAGE_SIZE,\r\n"%s%s\n",\r\n(d->flags & DEVFL_UP) ? "up" : "down",\r\n(d->flags & DEVFL_KICKME) ? ",kickme" :\r\n(d->nopen && !(d->flags & DEVFL_UP)) ? ",closewait" : "");\r\n}\r\nstatic ssize_t aoedisk_show_mac(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nstruct aoetgt *t = d->targets[0];\r\nif (t == NULL)\r\nreturn snprintf(page, PAGE_SIZE, "none\n");\r\nreturn snprintf(page, PAGE_SIZE, "%pm\n", t->addr);\r\n}\r\nstatic ssize_t aoedisk_show_netif(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nstruct net_device *nds[8], **nd, **nnd, **ne;\r\nstruct aoetgt **t, **te;\r\nstruct aoeif *ifp, *e;\r\nchar *p;\r\nmemset(nds, 0, sizeof nds);\r\nnd = nds;\r\nne = nd + ARRAY_SIZE(nds);\r\nt = d->targets;\r\nte = t + NTARGETS;\r\nfor (; t < te && *t; t++) {\r\nifp = (*t)->ifs;\r\ne = ifp + NAOEIFS;\r\nfor (; ifp < e && ifp->nd; ifp++) {\r\nfor (nnd = nds; nnd < nd; nnd++)\r\nif (*nnd == ifp->nd)\r\nbreak;\r\nif (nnd == nd && nd != ne)\r\n*nd++ = ifp->nd;\r\n}\r\n}\r\nne = nd;\r\nnd = nds;\r\nif (*nd == NULL)\r\nreturn snprintf(page, PAGE_SIZE, "none\n");\r\nfor (p = page; nd < ne; nd++)\r\np += snprintf(p, PAGE_SIZE - (p-page), "%s%s",\r\np == page ? "" : ",", (*nd)->name);\r\np += snprintf(p, PAGE_SIZE - (p-page), "\n");\r\nreturn p-page;\r\n}\r\nstatic ssize_t aoedisk_show_fwver(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nreturn snprintf(page, PAGE_SIZE, "0x%04x\n", (unsigned int) d->fw_ver);\r\n}\r\nstatic int\r\naoedisk_add_sysfs(struct aoedev *d)\r\n{\r\nreturn sysfs_create_group(&disk_to_dev(d->gd)->kobj, &attr_group);\r\n}\r\nvoid\r\naoedisk_rm_sysfs(struct aoedev *d)\r\n{\r\nsysfs_remove_group(&disk_to_dev(d->gd)->kobj, &attr_group);\r\n}\r\nstatic int\r\naoeblk_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct aoedev *d = bdev->bd_disk->private_data;\r\nulong flags;\r\nmutex_lock(&aoeblk_mutex);\r\nspin_lock_irqsave(&d->lock, flags);\r\nif (d->flags & DEVFL_UP) {\r\nd->nopen++;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nmutex_unlock(&aoeblk_mutex);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nmutex_unlock(&aoeblk_mutex);\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\naoeblk_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct aoedev *d = disk->private_data;\r\nulong flags;\r\nspin_lock_irqsave(&d->lock, flags);\r\nif (--d->nopen == 0) {\r\nspin_unlock_irqrestore(&d->lock, flags);\r\naoecmd_cfg(d->aoemajor, d->aoeminor);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\naoeblk_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct sk_buff_head queue;\r\nstruct aoedev *d;\r\nstruct buf *buf;\r\nulong flags;\r\nblk_queue_bounce(q, &bio);\r\nif (bio == NULL) {\r\nprintk(KERN_ERR "aoe: bio is NULL\n");\r\nBUG();\r\nreturn 0;\r\n}\r\nd = bio->bi_bdev->bd_disk->private_data;\r\nif (d == NULL) {\r\nprintk(KERN_ERR "aoe: bd_disk->private_data is NULL\n");\r\nBUG();\r\nbio_endio(bio, -ENXIO);\r\nreturn 0;\r\n} else if (bio->bi_io_vec == NULL) {\r\nprintk(KERN_ERR "aoe: bi_io_vec is NULL\n");\r\nBUG();\r\nbio_endio(bio, -ENXIO);\r\nreturn 0;\r\n}\r\nbuf = mempool_alloc(d->bufpool, GFP_NOIO);\r\nif (buf == NULL) {\r\nprintk(KERN_INFO "aoe: buf allocation failure\n");\r\nbio_endio(bio, -ENOMEM);\r\nreturn 0;\r\n}\r\nmemset(buf, 0, sizeof(*buf));\r\nINIT_LIST_HEAD(&buf->bufs);\r\nbuf->stime = jiffies;\r\nbuf->bio = bio;\r\nbuf->resid = bio->bi_size;\r\nbuf->sector = bio->bi_sector;\r\nbuf->bv = &bio->bi_io_vec[bio->bi_idx];\r\nbuf->bv_resid = buf->bv->bv_len;\r\nWARN_ON(buf->bv_resid == 0);\r\nbuf->bv_off = buf->bv->bv_offset;\r\nspin_lock_irqsave(&d->lock, flags);\r\nif ((d->flags & DEVFL_UP) == 0) {\r\npr_info_ratelimited("aoe: device %ld.%d is not up\n",\r\nd->aoemajor, d->aoeminor);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nmempool_free(buf, d->bufpool);\r\nbio_endio(bio, -ENXIO);\r\nreturn 0;\r\n}\r\nlist_add_tail(&buf->bufs, &d->bufq);\r\naoecmd_work(d);\r\n__skb_queue_head_init(&queue);\r\nskb_queue_splice_init(&d->sendq, &queue);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\naoenet_xmit(&queue);\r\nreturn 0;\r\n}\r\nstatic int\r\naoeblk_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct aoedev *d = bdev->bd_disk->private_data;\r\nif ((d->flags & DEVFL_UP) == 0) {\r\nprintk(KERN_ERR "aoe: disk not up\n");\r\nreturn -ENODEV;\r\n}\r\ngeo->cylinders = d->geo.cylinders;\r\ngeo->heads = d->geo.heads;\r\ngeo->sectors = d->geo.sectors;\r\nreturn 0;\r\n}\r\nvoid\r\naoeblk_gdalloc(void *vp)\r\n{\r\nstruct aoedev *d = vp;\r\nstruct gendisk *gd;\r\nulong flags;\r\ngd = alloc_disk(AOE_PARTITIONS);\r\nif (gd == NULL) {\r\nprintk(KERN_ERR\r\n"aoe: cannot allocate disk structure for %ld.%d\n",\r\nd->aoemajor, d->aoeminor);\r\ngoto err;\r\n}\r\nd->bufpool = mempool_create_slab_pool(MIN_BUFS, buf_pool_cache);\r\nif (d->bufpool == NULL) {\r\nprintk(KERN_ERR "aoe: cannot allocate bufpool for %ld.%d\n",\r\nd->aoemajor, d->aoeminor);\r\ngoto err_disk;\r\n}\r\nd->blkq = blk_alloc_queue(GFP_KERNEL);\r\nif (!d->blkq)\r\ngoto err_mempool;\r\nblk_queue_make_request(d->blkq, aoeblk_make_request);\r\nd->blkq->backing_dev_info.name = "aoe";\r\nif (bdi_init(&d->blkq->backing_dev_info))\r\ngoto err_blkq;\r\nspin_lock_irqsave(&d->lock, flags);\r\ngd->major = AOE_MAJOR;\r\ngd->first_minor = d->sysminor * AOE_PARTITIONS;\r\ngd->fops = &aoe_bdops;\r\ngd->private_data = d;\r\nset_capacity(gd, d->ssize);\r\nsnprintf(gd->disk_name, sizeof gd->disk_name, "etherd/e%ld.%d",\r\nd->aoemajor, d->aoeminor);\r\ngd->queue = d->blkq;\r\nd->gd = gd;\r\nd->flags &= ~DEVFL_GDALLOC;\r\nd->flags |= DEVFL_UP;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nadd_disk(gd);\r\naoedisk_add_sysfs(d);\r\nreturn;\r\nerr_blkq:\r\nblk_cleanup_queue(d->blkq);\r\nd->blkq = NULL;\r\nerr_mempool:\r\nmempool_destroy(d->bufpool);\r\nerr_disk:\r\nput_disk(gd);\r\nerr:\r\nspin_lock_irqsave(&d->lock, flags);\r\nd->flags &= ~DEVFL_GDALLOC;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\n}\r\nvoid\r\naoeblk_exit(void)\r\n{\r\nkmem_cache_destroy(buf_pool_cache);\r\n}\r\nint __init\r\naoeblk_init(void)\r\n{\r\nbuf_pool_cache = kmem_cache_create("aoe_bufs",\r\nsizeof(struct buf),\r\n0, 0, NULL);\r\nif (buf_pool_cache == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
