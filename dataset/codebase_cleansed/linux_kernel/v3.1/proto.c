static const char *dccp_state_name(const int state)\r\n{\r\nstatic const char *const dccp_state_names[] = {\r\n[DCCP_OPEN] = "OPEN",\r\n[DCCP_REQUESTING] = "REQUESTING",\r\n[DCCP_PARTOPEN] = "PARTOPEN",\r\n[DCCP_LISTEN] = "LISTEN",\r\n[DCCP_RESPOND] = "RESPOND",\r\n[DCCP_CLOSING] = "CLOSING",\r\n[DCCP_ACTIVE_CLOSEREQ] = "CLOSEREQ",\r\n[DCCP_PASSIVE_CLOSE] = "PASSIVE_CLOSE",\r\n[DCCP_PASSIVE_CLOSEREQ] = "PASSIVE_CLOSEREQ",\r\n[DCCP_TIME_WAIT] = "TIME_WAIT",\r\n[DCCP_CLOSED] = "CLOSED",\r\n};\r\nif (state >= DCCP_MAX_STATES)\r\nreturn "INVALID STATE!";\r\nelse\r\nreturn dccp_state_names[state];\r\n}\r\nvoid dccp_set_state(struct sock *sk, const int state)\r\n{\r\nconst int oldstate = sk->sk_state;\r\ndccp_pr_debug("%s(%p) %s --> %s\n", dccp_role(sk), sk,\r\ndccp_state_name(oldstate), dccp_state_name(state));\r\nWARN_ON(state == oldstate);\r\nswitch (state) {\r\ncase DCCP_OPEN:\r\nif (oldstate != DCCP_OPEN)\r\nDCCP_INC_STATS(DCCP_MIB_CURRESTAB);\r\nif (oldstate == DCCP_PARTOPEN)\r\ndccp_feat_list_purge(&dccp_sk(sk)->dccps_featneg);\r\nbreak;\r\ncase DCCP_CLOSED:\r\nif (oldstate == DCCP_OPEN || oldstate == DCCP_ACTIVE_CLOSEREQ ||\r\noldstate == DCCP_CLOSING)\r\nDCCP_INC_STATS(DCCP_MIB_ESTABRESETS);\r\nsk->sk_prot->unhash(sk);\r\nif (inet_csk(sk)->icsk_bind_hash != NULL &&\r\n!(sk->sk_userlocks & SOCK_BINDPORT_LOCK))\r\ninet_put_port(sk);\r\ndefault:\r\nif (oldstate == DCCP_OPEN)\r\nDCCP_DEC_STATS(DCCP_MIB_CURRESTAB);\r\n}\r\nsk->sk_state = state;\r\n}\r\nstatic void dccp_finish_passive_close(struct sock *sk)\r\n{\r\nswitch (sk->sk_state) {\r\ncase DCCP_PASSIVE_CLOSE:\r\ndccp_send_reset(sk, DCCP_RESET_CODE_CLOSED);\r\ndccp_set_state(sk, DCCP_CLOSED);\r\nbreak;\r\ncase DCCP_PASSIVE_CLOSEREQ:\r\ndccp_send_close(sk, 1);\r\ndccp_set_state(sk, DCCP_CLOSING);\r\n}\r\n}\r\nvoid dccp_done(struct sock *sk)\r\n{\r\ndccp_set_state(sk, DCCP_CLOSED);\r\ndccp_clear_xmit_timers(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\nelse\r\ninet_csk_destroy_sock(sk);\r\n}\r\nconst char *dccp_packet_name(const int type)\r\n{\r\nstatic const char *const dccp_packet_names[] = {\r\n[DCCP_PKT_REQUEST] = "REQUEST",\r\n[DCCP_PKT_RESPONSE] = "RESPONSE",\r\n[DCCP_PKT_DATA] = "DATA",\r\n[DCCP_PKT_ACK] = "ACK",\r\n[DCCP_PKT_DATAACK] = "DATAACK",\r\n[DCCP_PKT_CLOSEREQ] = "CLOSEREQ",\r\n[DCCP_PKT_CLOSE] = "CLOSE",\r\n[DCCP_PKT_RESET] = "RESET",\r\n[DCCP_PKT_SYNC] = "SYNC",\r\n[DCCP_PKT_SYNCACK] = "SYNCACK",\r\n};\r\nif (type >= DCCP_NR_PKT_TYPES)\r\nreturn "INVALID";\r\nelse\r\nreturn dccp_packet_names[type];\r\n}\r\nint dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nicsk->icsk_rto = DCCP_TIMEOUT_INIT;\r\nicsk->icsk_syn_retries = sysctl_dccp_request_retries;\r\nsk->sk_state = DCCP_CLOSED;\r\nsk->sk_write_space = dccp_write_space;\r\nicsk->icsk_sync_mss = dccp_sync_mss;\r\ndp->dccps_mss_cache = 536;\r\ndp->dccps_rate_last = jiffies;\r\ndp->dccps_role = DCCP_ROLE_UNDEFINED;\r\ndp->dccps_service = DCCP_SERVICE_CODE_IS_ABSENT;\r\ndp->dccps_l_ack_ratio = dp->dccps_r_ack_ratio = 1;\r\ndp->dccps_tx_qlen = sysctl_dccp_tx_qlen;\r\ndccp_init_xmit_timers(sk);\r\nINIT_LIST_HEAD(&dp->dccps_featneg);\r\nif (likely(ctl_sock_initialized))\r\nreturn dccp_feat_init(sk);\r\nreturn 0;\r\n}\r\nvoid dccp_destroy_sock(struct sock *sk)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nif (sk->sk_send_head != NULL) {\r\nkfree_skb(sk->sk_send_head);\r\nsk->sk_send_head = NULL;\r\n}\r\nif (inet_csk(sk)->icsk_bind_hash != NULL)\r\ninet_put_port(sk);\r\nkfree(dp->dccps_service_list);\r\ndp->dccps_service_list = NULL;\r\nif (dp->dccps_hc_rx_ackvec != NULL) {\r\ndccp_ackvec_free(dp->dccps_hc_rx_ackvec);\r\ndp->dccps_hc_rx_ackvec = NULL;\r\n}\r\nccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\r\nccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\r\ndp->dccps_hc_rx_ccid = dp->dccps_hc_tx_ccid = NULL;\r\ndccp_feat_list_purge(&dp->dccps_featneg);\r\n}\r\nstatic inline int dccp_listen_start(struct sock *sk, int backlog)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\ndp->dccps_role = DCCP_ROLE_LISTEN;\r\nif (dccp_feat_finalise_settings(dp))\r\nreturn -EPROTO;\r\nreturn inet_csk_listen_start(sk, backlog);\r\n}\r\nstatic inline int dccp_need_reset(int state)\r\n{\r\nreturn state != DCCP_CLOSED && state != DCCP_LISTEN &&\r\nstate != DCCP_REQUESTING;\r\n}\r\nint dccp_disconnect(struct sock *sk, int flags)\r\n{\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct inet_sock *inet = inet_sk(sk);\r\nint err = 0;\r\nconst int old_state = sk->sk_state;\r\nif (old_state != DCCP_CLOSED)\r\ndccp_set_state(sk, DCCP_CLOSED);\r\nif (old_state == DCCP_LISTEN) {\r\ninet_csk_listen_stop(sk);\r\n} else if (dccp_need_reset(old_state)) {\r\ndccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\r\nsk->sk_err = ECONNRESET;\r\n} else if (old_state == DCCP_REQUESTING)\r\nsk->sk_err = ECONNRESET;\r\ndccp_clear_xmit_timers(sk);\r\n__skb_queue_purge(&sk->sk_receive_queue);\r\n__skb_queue_purge(&sk->sk_write_queue);\r\nif (sk->sk_send_head != NULL) {\r\n__kfree_skb(sk->sk_send_head);\r\nsk->sk_send_head = NULL;\r\n}\r\ninet->inet_dport = 0;\r\nif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\r\ninet_reset_saddr(sk);\r\nsk->sk_shutdown = 0;\r\nsock_reset_flag(sk, SOCK_DONE);\r\nicsk->icsk_backoff = 0;\r\ninet_csk_delack_init(sk);\r\n__sk_dst_reset(sk);\r\nWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\r\nsk->sk_error_report(sk);\r\nreturn err;\r\n}\r\nunsigned int dccp_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nunsigned int mask;\r\nstruct sock *sk = sock->sk;\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nif (sk->sk_state == DCCP_LISTEN)\r\nreturn inet_csk_listen_poll(sk);\r\nmask = 0;\r\nif (sk->sk_err)\r\nmask = POLLERR;\r\nif (sk->sk_shutdown == SHUTDOWN_MASK || sk->sk_state == DCCP_CLOSED)\r\nmask |= POLLHUP;\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nmask |= POLLIN | POLLRDNORM | POLLRDHUP;\r\nif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_RESPOND)) {\r\nif (atomic_read(&sk->sk_rmem_alloc) > 0)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (!(sk->sk_shutdown & SEND_SHUTDOWN)) {\r\nif (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk)) {\r\nmask |= POLLOUT | POLLWRNORM;\r\n} else {\r\nset_bit(SOCK_ASYNC_NOSPACE,\r\n&sk->sk_socket->flags);\r\nset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\r\nif (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk))\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\n}\r\n}\r\nreturn mask;\r\n}\r\nint dccp_ioctl(struct sock *sk, int cmd, unsigned long arg)\r\n{\r\nint rc = -ENOTCONN;\r\nlock_sock(sk);\r\nif (sk->sk_state == DCCP_LISTEN)\r\ngoto out;\r\nswitch (cmd) {\r\ncase SIOCINQ: {\r\nstruct sk_buff *skb;\r\nunsigned long amount = 0;\r\nskb = skb_peek(&sk->sk_receive_queue);\r\nif (skb != NULL) {\r\namount = skb->len;\r\n}\r\nrc = put_user(amount, (int __user *)arg);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int dccp_setsockopt_service(struct sock *sk, const __be32 service,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct dccp_service_list *sl = NULL;\r\nif (service == DCCP_SERVICE_INVALID_VALUE ||\r\noptlen > DCCP_SERVICE_LIST_MAX_LEN * sizeof(u32))\r\nreturn -EINVAL;\r\nif (optlen > sizeof(service)) {\r\nsl = kmalloc(optlen, GFP_KERNEL);\r\nif (sl == NULL)\r\nreturn -ENOMEM;\r\nsl->dccpsl_nr = optlen / sizeof(u32) - 1;\r\nif (copy_from_user(sl->dccpsl_list,\r\noptval + sizeof(service),\r\noptlen - sizeof(service)) ||\r\ndccp_list_has_service(sl, DCCP_SERVICE_INVALID_VALUE)) {\r\nkfree(sl);\r\nreturn -EFAULT;\r\n}\r\n}\r\nlock_sock(sk);\r\ndp->dccps_service = service;\r\nkfree(dp->dccps_service_list);\r\ndp->dccps_service_list = sl;\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nstatic int dccp_setsockopt_cscov(struct sock *sk, int cscov, bool rx)\r\n{\r\nu8 *list, len;\r\nint i, rc;\r\nif (cscov < 0 || cscov > 15)\r\nreturn -EINVAL;\r\nif (cscov == 0)\r\nreturn 0;\r\nlen = 16 - cscov;\r\nlist = kmalloc(len, GFP_KERNEL);\r\nif (list == NULL)\r\nreturn -ENOBUFS;\r\nfor (i = 0; i < len; i++)\r\nlist[i] = cscov++;\r\nrc = dccp_feat_register_sp(sk, DCCPF_MIN_CSUM_COVER, rx, list, len);\r\nif (rc == 0) {\r\nif (rx)\r\ndccp_sk(sk)->dccps_pcrlen = cscov;\r\nelse\r\ndccp_sk(sk)->dccps_pcslen = cscov;\r\n}\r\nkfree(list);\r\nreturn rc;\r\n}\r\nstatic int dccp_setsockopt_ccid(struct sock *sk, int type,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nu8 *val;\r\nint rc = 0;\r\nif (optlen < 1 || optlen > DCCP_FEAT_MAX_SP_VALS)\r\nreturn -EINVAL;\r\nval = memdup_user(optval, optlen);\r\nif (IS_ERR(val))\r\nreturn PTR_ERR(val);\r\nlock_sock(sk);\r\nif (type == DCCP_SOCKOPT_TX_CCID || type == DCCP_SOCKOPT_CCID)\r\nrc = dccp_feat_register_sp(sk, DCCPF_CCID, 1, val, optlen);\r\nif (!rc && (type == DCCP_SOCKOPT_RX_CCID || type == DCCP_SOCKOPT_CCID))\r\nrc = dccp_feat_register_sp(sk, DCCPF_CCID, 0, val, optlen);\r\nrelease_sock(sk);\r\nkfree(val);\r\nreturn rc;\r\n}\r\nstatic int do_dccp_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nint val, err = 0;\r\nswitch (optname) {\r\ncase DCCP_SOCKOPT_PACKET_SIZE:\r\nDCCP_WARN("sockopt(PACKET_SIZE) is deprecated: fix your app\n");\r\nreturn 0;\r\ncase DCCP_SOCKOPT_CHANGE_L:\r\ncase DCCP_SOCKOPT_CHANGE_R:\r\nDCCP_WARN("sockopt(CHANGE_L/R) is deprecated: fix your app\n");\r\nreturn 0;\r\ncase DCCP_SOCKOPT_CCID:\r\ncase DCCP_SOCKOPT_RX_CCID:\r\ncase DCCP_SOCKOPT_TX_CCID:\r\nreturn dccp_setsockopt_ccid(sk, optname, optval, optlen);\r\n}\r\nif (optlen < (int)sizeof(int))\r\nreturn -EINVAL;\r\nif (get_user(val, (int __user *)optval))\r\nreturn -EFAULT;\r\nif (optname == DCCP_SOCKOPT_SERVICE)\r\nreturn dccp_setsockopt_service(sk, val, optval, optlen);\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase DCCP_SOCKOPT_SERVER_TIMEWAIT:\r\nif (dp->dccps_role != DCCP_ROLE_SERVER)\r\nerr = -EOPNOTSUPP;\r\nelse\r\ndp->dccps_server_timewait = (val != 0);\r\nbreak;\r\ncase DCCP_SOCKOPT_SEND_CSCOV:\r\nerr = dccp_setsockopt_cscov(sk, val, false);\r\nbreak;\r\ncase DCCP_SOCKOPT_RECV_CSCOV:\r\nerr = dccp_setsockopt_cscov(sk, val, true);\r\nbreak;\r\ncase DCCP_SOCKOPT_QPOLICY_ID:\r\nif (sk->sk_state != DCCP_CLOSED)\r\nerr = -EISCONN;\r\nelse if (val < 0 || val >= DCCPQ_POLICY_MAX)\r\nerr = -EINVAL;\r\nelse\r\ndp->dccps_qpolicy = val;\r\nbreak;\r\ncase DCCP_SOCKOPT_QPOLICY_TXQLEN:\r\nif (val < 0)\r\nerr = -EINVAL;\r\nelse\r\ndp->dccps_tx_qlen = val;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nint dccp_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nif (level != SOL_DCCP)\r\nreturn inet_csk(sk)->icsk_af_ops->setsockopt(sk, level,\r\noptname, optval,\r\noptlen);\r\nreturn do_dccp_setsockopt(sk, level, optname, optval, optlen);\r\n}\r\nint compat_dccp_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nif (level != SOL_DCCP)\r\nreturn inet_csk_compat_setsockopt(sk, level, optname,\r\noptval, optlen);\r\nreturn do_dccp_setsockopt(sk, level, optname, optval, optlen);\r\n}\r\nstatic int dccp_getsockopt_service(struct sock *sk, int len,\r\n__be32 __user *optval,\r\nint __user *optlen)\r\n{\r\nconst struct dccp_sock *dp = dccp_sk(sk);\r\nconst struct dccp_service_list *sl;\r\nint err = -ENOENT, slen = 0, total_len = sizeof(u32);\r\nlock_sock(sk);\r\nif ((sl = dp->dccps_service_list) != NULL) {\r\nslen = sl->dccpsl_nr * sizeof(u32);\r\ntotal_len += slen;\r\n}\r\nerr = -EINVAL;\r\nif (total_len > len)\r\ngoto out;\r\nerr = 0;\r\nif (put_user(total_len, optlen) ||\r\nput_user(dp->dccps_service, optval) ||\r\n(sl != NULL && copy_to_user(optval + 1, sl->dccpsl_list, slen)))\r\nerr = -EFAULT;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int do_dccp_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct dccp_sock *dp;\r\nint val, len;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nif (len < (int)sizeof(int))\r\nreturn -EINVAL;\r\ndp = dccp_sk(sk);\r\nswitch (optname) {\r\ncase DCCP_SOCKOPT_PACKET_SIZE:\r\nDCCP_WARN("sockopt(PACKET_SIZE) is deprecated: fix your app\n");\r\nreturn 0;\r\ncase DCCP_SOCKOPT_SERVICE:\r\nreturn dccp_getsockopt_service(sk, len,\r\n(__be32 __user *)optval, optlen);\r\ncase DCCP_SOCKOPT_GET_CUR_MPS:\r\nval = dp->dccps_mss_cache;\r\nbreak;\r\ncase DCCP_SOCKOPT_AVAILABLE_CCIDS:\r\nreturn ccid_getsockopt_builtin_ccids(sk, len, optval, optlen);\r\ncase DCCP_SOCKOPT_TX_CCID:\r\nval = ccid_get_current_tx_ccid(dp);\r\nif (val < 0)\r\nreturn -ENOPROTOOPT;\r\nbreak;\r\ncase DCCP_SOCKOPT_RX_CCID:\r\nval = ccid_get_current_rx_ccid(dp);\r\nif (val < 0)\r\nreturn -ENOPROTOOPT;\r\nbreak;\r\ncase DCCP_SOCKOPT_SERVER_TIMEWAIT:\r\nval = dp->dccps_server_timewait;\r\nbreak;\r\ncase DCCP_SOCKOPT_SEND_CSCOV:\r\nval = dp->dccps_pcslen;\r\nbreak;\r\ncase DCCP_SOCKOPT_RECV_CSCOV:\r\nval = dp->dccps_pcrlen;\r\nbreak;\r\ncase DCCP_SOCKOPT_QPOLICY_ID:\r\nval = dp->dccps_qpolicy;\r\nbreak;\r\ncase DCCP_SOCKOPT_QPOLICY_TXQLEN:\r\nval = dp->dccps_tx_qlen;\r\nbreak;\r\ncase 128 ... 191:\r\nreturn ccid_hc_rx_getsockopt(dp->dccps_hc_rx_ccid, sk, optname,\r\nlen, (u32 __user *)optval, optlen);\r\ncase 192 ... 255:\r\nreturn ccid_hc_tx_getsockopt(dp->dccps_hc_tx_ccid, sk, optname,\r\nlen, (u32 __user *)optval, optlen);\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nlen = sizeof(val);\r\nif (put_user(len, optlen) || copy_to_user(optval, &val, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint dccp_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nif (level != SOL_DCCP)\r\nreturn inet_csk(sk)->icsk_af_ops->getsockopt(sk, level,\r\noptname, optval,\r\noptlen);\r\nreturn do_dccp_getsockopt(sk, level, optname, optval, optlen);\r\n}\r\nint compat_dccp_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nif (level != SOL_DCCP)\r\nreturn inet_csk_compat_getsockopt(sk, level, optname,\r\noptval, optlen);\r\nreturn do_dccp_getsockopt(sk, level, optname, optval, optlen);\r\n}\r\nstatic int dccp_msghdr_parse(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nstruct cmsghdr *cmsg = CMSG_FIRSTHDR(msg);\r\nskb->priority = 0;\r\nfor (; cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg)) {\r\nif (!CMSG_OK(msg, cmsg))\r\nreturn -EINVAL;\r\nif (cmsg->cmsg_level != SOL_DCCP)\r\ncontinue;\r\nif (cmsg->cmsg_type <= DCCP_SCM_QPOLICY_MAX &&\r\n!dccp_qpolicy_param_ok(skb->sk, cmsg->cmsg_type))\r\nreturn -EINVAL;\r\nswitch (cmsg->cmsg_type) {\r\ncase DCCP_SCM_PRIORITY:\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(__u32)))\r\nreturn -EINVAL;\r\nskb->priority = *(__u32 *)CMSG_DATA(cmsg);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dccp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nconst struct dccp_sock *dp = dccp_sk(sk);\r\nconst int flags = msg->msg_flags;\r\nconst int noblock = flags & MSG_DONTWAIT;\r\nstruct sk_buff *skb;\r\nint rc, size;\r\nlong timeo;\r\nif (len > dp->dccps_mss_cache)\r\nreturn -EMSGSIZE;\r\nlock_sock(sk);\r\nif (dccp_qpolicy_full(sk)) {\r\nrc = -EAGAIN;\r\ngoto out_release;\r\n}\r\ntimeo = sock_sndtimeo(sk, noblock);\r\nif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\r\nif ((rc = sk_stream_wait_connect(sk, &timeo)) != 0)\r\ngoto out_release;\r\nsize = sk->sk_prot->max_header + len;\r\nrelease_sock(sk);\r\nskb = sock_alloc_send_skb(sk, size, noblock, &rc);\r\nlock_sock(sk);\r\nif (skb == NULL)\r\ngoto out_release;\r\nskb_reserve(skb, sk->sk_prot->max_header);\r\nrc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\r\nif (rc != 0)\r\ngoto out_discard;\r\nrc = dccp_msghdr_parse(msg, skb);\r\nif (rc != 0)\r\ngoto out_discard;\r\ndccp_qpolicy_push(sk, skb);\r\nif (!timer_pending(&dp->dccps_xmit_timer))\r\ndccp_write_xmit(sk);\r\nout_release:\r\nrelease_sock(sk);\r\nreturn rc ? : len;\r\nout_discard:\r\nkfree_skb(skb);\r\ngoto out_release;\r\n}\r\nint dccp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\r\nsize_t len, int nonblock, int flags, int *addr_len)\r\n{\r\nconst struct dccp_hdr *dh;\r\nlong timeo;\r\nlock_sock(sk);\r\nif (sk->sk_state == DCCP_LISTEN) {\r\nlen = -ENOTCONN;\r\ngoto out;\r\n}\r\ntimeo = sock_rcvtimeo(sk, nonblock);\r\ndo {\r\nstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\r\nif (skb == NULL)\r\ngoto verify_sock_status;\r\ndh = dccp_hdr(skb);\r\nswitch (dh->dccph_type) {\r\ncase DCCP_PKT_DATA:\r\ncase DCCP_PKT_DATAACK:\r\ngoto found_ok_skb;\r\ncase DCCP_PKT_CLOSE:\r\ncase DCCP_PKT_CLOSEREQ:\r\nif (!(flags & MSG_PEEK))\r\ndccp_finish_passive_close(sk);\r\ncase DCCP_PKT_RESET:\r\ndccp_pr_debug("found fin (%s) ok!\n",\r\ndccp_packet_name(dh->dccph_type));\r\nlen = 0;\r\ngoto found_fin_ok;\r\ndefault:\r\ndccp_pr_debug("packet_type=%s\n",\r\ndccp_packet_name(dh->dccph_type));\r\nsk_eat_skb(sk, skb, 0);\r\n}\r\nverify_sock_status:\r\nif (sock_flag(sk, SOCK_DONE)) {\r\nlen = 0;\r\nbreak;\r\n}\r\nif (sk->sk_err) {\r\nlen = sock_error(sk);\r\nbreak;\r\n}\r\nif (sk->sk_shutdown & RCV_SHUTDOWN) {\r\nlen = 0;\r\nbreak;\r\n}\r\nif (sk->sk_state == DCCP_CLOSED) {\r\nif (!sock_flag(sk, SOCK_DONE)) {\r\nlen = -ENOTCONN;\r\nbreak;\r\n}\r\nlen = 0;\r\nbreak;\r\n}\r\nif (!timeo) {\r\nlen = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nlen = sock_intr_errno(timeo);\r\nbreak;\r\n}\r\nsk_wait_data(sk, &timeo);\r\ncontinue;\r\nfound_ok_skb:\r\nif (len > skb->len)\r\nlen = skb->len;\r\nelse if (len < skb->len)\r\nmsg->msg_flags |= MSG_TRUNC;\r\nif (skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len)) {\r\nlen = -EFAULT;\r\nbreak;\r\n}\r\nif (flags & MSG_TRUNC)\r\nlen = skb->len;\r\nfound_fin_ok:\r\nif (!(flags & MSG_PEEK))\r\nsk_eat_skb(sk, skb, 0);\r\nbreak;\r\n} while (1);\r\nout:\r\nrelease_sock(sk);\r\nreturn len;\r\n}\r\nint inet_dccp_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nunsigned char old_state;\r\nint err;\r\nlock_sock(sk);\r\nerr = -EINVAL;\r\nif (sock->state != SS_UNCONNECTED || sock->type != SOCK_DCCP)\r\ngoto out;\r\nold_state = sk->sk_state;\r\nif (!((1 << old_state) & (DCCPF_CLOSED | DCCPF_LISTEN)))\r\ngoto out;\r\nif (old_state != DCCP_LISTEN) {\r\nerr = dccp_listen_start(sk, backlog);\r\nif (err)\r\ngoto out;\r\n}\r\nsk->sk_max_ack_backlog = backlog;\r\nerr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic void dccp_terminate_connection(struct sock *sk)\r\n{\r\nu8 next_state = DCCP_CLOSED;\r\nswitch (sk->sk_state) {\r\ncase DCCP_PASSIVE_CLOSE:\r\ncase DCCP_PASSIVE_CLOSEREQ:\r\ndccp_finish_passive_close(sk);\r\nbreak;\r\ncase DCCP_PARTOPEN:\r\ndccp_pr_debug("Stop PARTOPEN timer (%p)\n", sk);\r\ninet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\r\ncase DCCP_OPEN:\r\ndccp_send_close(sk, 1);\r\nif (dccp_sk(sk)->dccps_role == DCCP_ROLE_SERVER &&\r\n!dccp_sk(sk)->dccps_server_timewait)\r\nnext_state = DCCP_ACTIVE_CLOSEREQ;\r\nelse\r\nnext_state = DCCP_CLOSING;\r\ndefault:\r\ndccp_set_state(sk, next_state);\r\n}\r\n}\r\nvoid dccp_close(struct sock *sk, long timeout)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct sk_buff *skb;\r\nu32 data_was_unread = 0;\r\nint state;\r\nlock_sock(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nif (sk->sk_state == DCCP_LISTEN) {\r\ndccp_set_state(sk, DCCP_CLOSED);\r\ninet_csk_listen_stop(sk);\r\ngoto adjudge_to_death;\r\n}\r\nsk_stop_timer(sk, &dp->dccps_xmit_timer);\r\nwhile ((skb = __skb_dequeue(&sk->sk_receive_queue)) != NULL) {\r\ndata_was_unread += skb->len;\r\n__kfree_skb(skb);\r\n}\r\nif (data_was_unread) {\r\nDCCP_WARN("ABORT with %u bytes unread\n", data_was_unread);\r\ndccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\r\ndccp_set_state(sk, DCCP_CLOSED);\r\n} else if (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime) {\r\nsk->sk_prot->disconnect(sk, 0);\r\n} else if (sk->sk_state != DCCP_CLOSED) {\r\ndccp_flush_write_queue(sk, &timeout);\r\ndccp_terminate_connection(sk);\r\n}\r\n__skb_queue_purge(&sk->sk_write_queue);\r\nsk_stream_wait_close(sk, timeout);\r\nadjudge_to_death:\r\nstate = sk->sk_state;\r\nsock_hold(sk);\r\nsock_orphan(sk);\r\nrelease_sock(sk);\r\nlocal_bh_disable();\r\nbh_lock_sock(sk);\r\nWARN_ON(sock_owned_by_user(sk));\r\npercpu_counter_inc(sk->sk_prot->orphan_count);\r\nif (state != DCCP_CLOSED && sk->sk_state == DCCP_CLOSED)\r\ngoto out;\r\nif (sk->sk_state == DCCP_CLOSED)\r\ninet_csk_destroy_sock(sk);\r\nout:\r\nbh_unlock_sock(sk);\r\nlocal_bh_enable();\r\nsock_put(sk);\r\n}\r\nvoid dccp_shutdown(struct sock *sk, int how)\r\n{\r\ndccp_pr_debug("called shutdown(%x)\n", how);\r\n}\r\nstatic inline int dccp_mib_init(void)\r\n{\r\nreturn snmp_mib_init((void __percpu **)dccp_statistics,\r\nsizeof(struct dccp_mib),\r\n__alignof__(struct dccp_mib));\r\n}\r\nstatic inline void dccp_mib_exit(void)\r\n{\r\nsnmp_mib_free((void __percpu **)dccp_statistics);\r\n}\r\nstatic int __init dccp_init(void)\r\n{\r\nunsigned long goal;\r\nint ehash_order, bhash_order, i;\r\nint rc;\r\nBUILD_BUG_ON(sizeof(struct dccp_skb_cb) >\r\nFIELD_SIZEOF(struct sk_buff, cb));\r\nrc = percpu_counter_init(&dccp_orphan_count, 0);\r\nif (rc)\r\ngoto out_fail;\r\nrc = -ENOBUFS;\r\ninet_hashinfo_init(&dccp_hashinfo);\r\ndccp_hashinfo.bind_bucket_cachep =\r\nkmem_cache_create("dccp_bind_bucket",\r\nsizeof(struct inet_bind_bucket), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!dccp_hashinfo.bind_bucket_cachep)\r\ngoto out_free_percpu;\r\nif (totalram_pages >= (128 * 1024))\r\ngoal = totalram_pages >> (21 - PAGE_SHIFT);\r\nelse\r\ngoal = totalram_pages >> (23 - PAGE_SHIFT);\r\nif (thash_entries)\r\ngoal = (thash_entries *\r\nsizeof(struct inet_ehash_bucket)) >> PAGE_SHIFT;\r\nfor (ehash_order = 0; (1UL << ehash_order) < goal; ehash_order++)\r\n;\r\ndo {\r\nunsigned long hash_size = (1UL << ehash_order) * PAGE_SIZE /\r\nsizeof(struct inet_ehash_bucket);\r\nwhile (hash_size & (hash_size - 1))\r\nhash_size--;\r\ndccp_hashinfo.ehash_mask = hash_size - 1;\r\ndccp_hashinfo.ehash = (struct inet_ehash_bucket *)\r\n__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, ehash_order);\r\n} while (!dccp_hashinfo.ehash && --ehash_order > 0);\r\nif (!dccp_hashinfo.ehash) {\r\nDCCP_CRIT("Failed to allocate DCCP established hash table");\r\ngoto out_free_bind_bucket_cachep;\r\n}\r\nfor (i = 0; i <= dccp_hashinfo.ehash_mask; i++) {\r\nINIT_HLIST_NULLS_HEAD(&dccp_hashinfo.ehash[i].chain, i);\r\nINIT_HLIST_NULLS_HEAD(&dccp_hashinfo.ehash[i].twchain, i);\r\n}\r\nif (inet_ehash_locks_alloc(&dccp_hashinfo))\r\ngoto out_free_dccp_ehash;\r\nbhash_order = ehash_order;\r\ndo {\r\ndccp_hashinfo.bhash_size = (1UL << bhash_order) * PAGE_SIZE /\r\nsizeof(struct inet_bind_hashbucket);\r\nif ((dccp_hashinfo.bhash_size > (64 * 1024)) &&\r\nbhash_order > 0)\r\ncontinue;\r\ndccp_hashinfo.bhash = (struct inet_bind_hashbucket *)\r\n__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, bhash_order);\r\n} while (!dccp_hashinfo.bhash && --bhash_order >= 0);\r\nif (!dccp_hashinfo.bhash) {\r\nDCCP_CRIT("Failed to allocate DCCP bind hash table");\r\ngoto out_free_dccp_locks;\r\n}\r\nfor (i = 0; i < dccp_hashinfo.bhash_size; i++) {\r\nspin_lock_init(&dccp_hashinfo.bhash[i].lock);\r\nINIT_HLIST_HEAD(&dccp_hashinfo.bhash[i].chain);\r\n}\r\nrc = dccp_mib_init();\r\nif (rc)\r\ngoto out_free_dccp_bhash;\r\nrc = dccp_ackvec_init();\r\nif (rc)\r\ngoto out_free_dccp_mib;\r\nrc = dccp_sysctl_init();\r\nif (rc)\r\ngoto out_ackvec_exit;\r\nrc = ccid_initialize_builtins();\r\nif (rc)\r\ngoto out_sysctl_exit;\r\ndccp_timestamping_init();\r\nreturn 0;\r\nout_sysctl_exit:\r\ndccp_sysctl_exit();\r\nout_ackvec_exit:\r\ndccp_ackvec_exit();\r\nout_free_dccp_mib:\r\ndccp_mib_exit();\r\nout_free_dccp_bhash:\r\nfree_pages((unsigned long)dccp_hashinfo.bhash, bhash_order);\r\nout_free_dccp_locks:\r\ninet_ehash_locks_free(&dccp_hashinfo);\r\nout_free_dccp_ehash:\r\nfree_pages((unsigned long)dccp_hashinfo.ehash, ehash_order);\r\nout_free_bind_bucket_cachep:\r\nkmem_cache_destroy(dccp_hashinfo.bind_bucket_cachep);\r\nout_free_percpu:\r\npercpu_counter_destroy(&dccp_orphan_count);\r\nout_fail:\r\ndccp_hashinfo.bhash = NULL;\r\ndccp_hashinfo.ehash = NULL;\r\ndccp_hashinfo.bind_bucket_cachep = NULL;\r\nreturn rc;\r\n}\r\nstatic void __exit dccp_fini(void)\r\n{\r\nccid_cleanup_builtins();\r\ndccp_mib_exit();\r\nfree_pages((unsigned long)dccp_hashinfo.bhash,\r\nget_order(dccp_hashinfo.bhash_size *\r\nsizeof(struct inet_bind_hashbucket)));\r\nfree_pages((unsigned long)dccp_hashinfo.ehash,\r\nget_order((dccp_hashinfo.ehash_mask + 1) *\r\nsizeof(struct inet_ehash_bucket)));\r\ninet_ehash_locks_free(&dccp_hashinfo);\r\nkmem_cache_destroy(dccp_hashinfo.bind_bucket_cachep);\r\ndccp_ackvec_exit();\r\ndccp_sysctl_exit();\r\npercpu_counter_destroy(&dccp_orphan_count);\r\n}
