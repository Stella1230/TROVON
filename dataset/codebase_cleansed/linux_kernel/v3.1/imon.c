static void free_imon_context(struct imon_context *ictx)\r\n{\r\nstruct device *dev = ictx->dev;\r\nusb_free_urb(ictx->tx_urb);\r\nusb_free_urb(ictx->rx_urb_intf0);\r\nusb_free_urb(ictx->rx_urb_intf1);\r\nkfree(ictx);\r\ndev_dbg(dev, "%s: iMON context freed\n", __func__);\r\n}\r\nstatic int display_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_interface *interface;\r\nstruct imon_context *ictx = NULL;\r\nint subminor;\r\nint retval = 0;\r\nmutex_lock(&driver_lock);\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&imon_driver, subminor);\r\nif (!interface) {\r\npr_err("could not find interface for minor %d\n", subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nictx = usb_get_intfdata(interface);\r\nif (!ictx) {\r\npr_err("no context found for minor %d\n", subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nmutex_lock(&ictx->lock);\r\nif (!ictx->display_supported) {\r\npr_err("display not supported by device\n");\r\nretval = -ENODEV;\r\n} else if (ictx->display_isopen) {\r\npr_err("display port is already open\n");\r\nretval = -EBUSY;\r\n} else {\r\nictx->display_isopen = true;\r\nfile->private_data = ictx;\r\ndev_dbg(ictx->dev, "display port opened\n");\r\n}\r\nmutex_unlock(&ictx->lock);\r\nexit:\r\nmutex_unlock(&driver_lock);\r\nreturn retval;\r\n}\r\nstatic int display_close(struct inode *inode, struct file *file)\r\n{\r\nstruct imon_context *ictx = NULL;\r\nint retval = 0;\r\nictx = file->private_data;\r\nif (!ictx) {\r\npr_err("no context for device\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&ictx->lock);\r\nif (!ictx->display_supported) {\r\npr_err("display not supported by device\n");\r\nretval = -ENODEV;\r\n} else if (!ictx->display_isopen) {\r\npr_err("display is not open\n");\r\nretval = -EIO;\r\n} else {\r\nictx->display_isopen = false;\r\ndev_dbg(ictx->dev, "display port closed\n");\r\n}\r\nmutex_unlock(&ictx->lock);\r\nreturn retval;\r\n}\r\nstatic int send_packet(struct imon_context *ictx)\r\n{\r\nunsigned int pipe;\r\nunsigned long timeout;\r\nint interval = 0;\r\nint retval = 0;\r\nstruct usb_ctrlrequest *control_req = NULL;\r\nif (!ictx->tx_control) {\r\npipe = usb_sndintpipe(ictx->usbdev_intf0,\r\nictx->tx_endpoint->bEndpointAddress);\r\ninterval = ictx->tx_endpoint->bInterval;\r\nusb_fill_int_urb(ictx->tx_urb, ictx->usbdev_intf0, pipe,\r\nictx->usb_tx_buf,\r\nsizeof(ictx->usb_tx_buf),\r\nusb_tx_callback, ictx, interval);\r\nictx->tx_urb->actual_length = 0;\r\n} else {\r\ncontrol_req = kmalloc(sizeof(struct usb_ctrlrequest),\r\nGFP_KERNEL);\r\nif (control_req == NULL)\r\nreturn -ENOMEM;\r\ncontrol_req->bRequestType = 0x21;\r\ncontrol_req->bRequest = 0x09;\r\ncontrol_req->wValue = cpu_to_le16(0x0200);\r\ncontrol_req->wIndex = cpu_to_le16(0x0001);\r\ncontrol_req->wLength = cpu_to_le16(0x0008);\r\npipe = usb_sndctrlpipe(ictx->usbdev_intf0, 0);\r\nusb_fill_control_urb(ictx->tx_urb, ictx->usbdev_intf0,\r\npipe, (unsigned char *)control_req,\r\nictx->usb_tx_buf,\r\nsizeof(ictx->usb_tx_buf),\r\nusb_tx_callback, ictx);\r\nictx->tx_urb->actual_length = 0;\r\n}\r\ninit_completion(&ictx->tx.finished);\r\nictx->tx.busy = true;\r\nsmp_rmb();\r\nretval = usb_submit_urb(ictx->tx_urb, GFP_KERNEL);\r\nif (retval) {\r\nictx->tx.busy = false;\r\nsmp_rmb();\r\npr_err("error submitting urb(%d)\n", retval);\r\n} else {\r\nmutex_unlock(&ictx->lock);\r\nretval = wait_for_completion_interruptible(\r\n&ictx->tx.finished);\r\nif (retval)\r\npr_err("task interrupted\n");\r\nmutex_lock(&ictx->lock);\r\nretval = ictx->tx.status;\r\nif (retval)\r\npr_err("packet tx failed (%d)\n", retval);\r\n}\r\nkfree(control_req);\r\ntimeout = msecs_to_jiffies(5);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(timeout);\r\nreturn retval;\r\n}\r\nstatic int send_associate_24g(struct imon_context *ictx)\r\n{\r\nint retval;\r\nconst unsigned char packet[8] = { 0x01, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x20 };\r\nif (!ictx) {\r\npr_err("no context for device\n");\r\nreturn -ENODEV;\r\n}\r\nif (!ictx->dev_present_intf0) {\r\npr_err("no iMON device present\n");\r\nreturn -ENODEV;\r\n}\r\nmemcpy(ictx->usb_tx_buf, packet, sizeof(packet));\r\nretval = send_packet(ictx);\r\nreturn retval;\r\n}\r\nstatic int send_set_imon_clock(struct imon_context *ictx,\r\nunsigned int year, unsigned int month,\r\nunsigned int day, unsigned int dow,\r\nunsigned int hour, unsigned int minute,\r\nunsigned int second)\r\n{\r\nunsigned char clock_enable_pkt[IMON_CLOCK_ENABLE_PACKETS][8];\r\nint retval = 0;\r\nint i;\r\nif (!ictx) {\r\npr_err("no context for device\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (ictx->display_type) {\r\ncase IMON_DISPLAY_TYPE_LCD:\r\nclock_enable_pkt[0][0] = 0x80;\r\nclock_enable_pkt[0][1] = year;\r\nclock_enable_pkt[0][2] = month-1;\r\nclock_enable_pkt[0][3] = day;\r\nclock_enable_pkt[0][4] = hour;\r\nclock_enable_pkt[0][5] = minute;\r\nclock_enable_pkt[0][6] = second;\r\nclock_enable_pkt[1][0] = 0x80;\r\nclock_enable_pkt[1][1] = 0;\r\nclock_enable_pkt[1][2] = 0;\r\nclock_enable_pkt[1][3] = 0;\r\nclock_enable_pkt[1][4] = 0;\r\nclock_enable_pkt[1][5] = 0;\r\nclock_enable_pkt[1][6] = 0;\r\nif (ictx->product == 0xffdc) {\r\nclock_enable_pkt[0][7] = 0x50;\r\nclock_enable_pkt[1][7] = 0x51;\r\n} else {\r\nclock_enable_pkt[0][7] = 0x88;\r\nclock_enable_pkt[1][7] = 0x8a;\r\n}\r\nbreak;\r\ncase IMON_DISPLAY_TYPE_VFD:\r\nclock_enable_pkt[0][0] = year;\r\nclock_enable_pkt[0][1] = month-1;\r\nclock_enable_pkt[0][2] = day;\r\nclock_enable_pkt[0][3] = dow;\r\nclock_enable_pkt[0][4] = hour;\r\nclock_enable_pkt[0][5] = minute;\r\nclock_enable_pkt[0][6] = second;\r\nclock_enable_pkt[0][7] = 0x40;\r\nclock_enable_pkt[1][0] = 0;\r\nclock_enable_pkt[1][1] = 0;\r\nclock_enable_pkt[1][2] = 1;\r\nclock_enable_pkt[1][3] = 0;\r\nclock_enable_pkt[1][4] = 0;\r\nclock_enable_pkt[1][5] = 0;\r\nclock_enable_pkt[1][6] = 0;\r\nclock_enable_pkt[1][7] = 0x42;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < IMON_CLOCK_ENABLE_PACKETS; i++) {\r\nmemcpy(ictx->usb_tx_buf, clock_enable_pkt[i], 8);\r\nretval = send_packet(ictx);\r\nif (retval) {\r\npr_err("send_packet failed for packet %d\n", i);\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic ssize_t show_associate_remote(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct imon_context *ictx = dev_get_drvdata(d);\r\nif (!ictx)\r\nreturn -ENODEV;\r\nmutex_lock(&ictx->lock);\r\nif (ictx->rf_isassociating)\r\nstrcpy(buf, "associating\n");\r\nelse\r\nstrcpy(buf, "closed\n");\r\ndev_info(d, "Visit http://www.lirc.org/html/imon-24g.html for "\r\n"instructions on how to associate your iMON 2.4G DT/LT "\r\n"remote\n");\r\nmutex_unlock(&ictx->lock);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t store_associate_remote(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct imon_context *ictx;\r\nictx = dev_get_drvdata(d);\r\nif (!ictx)\r\nreturn -ENODEV;\r\nmutex_lock(&ictx->lock);\r\nictx->rf_isassociating = true;\r\nsend_associate_24g(ictx);\r\nmutex_unlock(&ictx->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_imon_clock(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct imon_context *ictx = dev_get_drvdata(d);\r\nsize_t len;\r\nif (!ictx)\r\nreturn -ENODEV;\r\nmutex_lock(&ictx->lock);\r\nif (!ictx->display_supported) {\r\nlen = snprintf(buf, PAGE_SIZE, "Not supported.");\r\n} else {\r\nlen = snprintf(buf, PAGE_SIZE,\r\n"To set the clock on your iMON display:\n"\r\n"# date \"+%%y %%m %%d %%w %%H %%M %%S\" > imon_clock\n"\r\n"%s", ictx->display_isopen ?\r\n"\nNOTE: imon device must be closed\n" : "");\r\n}\r\nmutex_unlock(&ictx->lock);\r\nreturn len;\r\n}\r\nstatic ssize_t store_imon_clock(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct imon_context *ictx = dev_get_drvdata(d);\r\nssize_t retval;\r\nunsigned int year, month, day, dow, hour, minute, second;\r\nif (!ictx)\r\nreturn -ENODEV;\r\nmutex_lock(&ictx->lock);\r\nif (!ictx->display_supported) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n} else if (ictx->display_isopen) {\r\nretval = -EBUSY;\r\ngoto exit;\r\n}\r\nif (sscanf(buf, "%u %u %u %u %u %u %u", &year, &month, &day, &dow,\r\n&hour, &minute, &second) != 7) {\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\nif ((month < 1 || month > 12) ||\r\n(day < 1 || day > 31) || (dow > 6) ||\r\n(hour > 23) || (minute > 59) || (second > 59)) {\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\nretval = send_set_imon_clock(ictx, year, month, day, dow,\r\nhour, minute, second);\r\nif (retval)\r\ngoto exit;\r\nretval = count;\r\nexit:\r\nmutex_unlock(&ictx->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t vfd_write(struct file *file, const char *buf,\r\nsize_t n_bytes, loff_t *pos)\r\n{\r\nint i;\r\nint offset;\r\nint seq;\r\nint retval = 0;\r\nstruct imon_context *ictx;\r\nconst unsigned char vfd_packet6[] = {\r\n0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF };\r\nictx = file->private_data;\r\nif (!ictx) {\r\npr_err("no context for device\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&ictx->lock);\r\nif (!ictx->dev_present_intf0) {\r\npr_err("no iMON device present\n");\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (n_bytes <= 0 || n_bytes > 32) {\r\npr_err("invalid payload size\n");\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\nif (copy_from_user(ictx->tx.data_buf, buf, n_bytes)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\nfor (i = n_bytes; i < 32; ++i)\r\nictx->tx.data_buf[i] = ' ';\r\nfor (i = 32; i < 35; ++i)\r\nictx->tx.data_buf[i] = 0xFF;\r\noffset = 0;\r\nseq = 0;\r\ndo {\r\nmemcpy(ictx->usb_tx_buf, ictx->tx.data_buf + offset, 7);\r\nictx->usb_tx_buf[7] = (unsigned char) seq;\r\nretval = send_packet(ictx);\r\nif (retval) {\r\npr_err("send packet failed for packet #%d\n", seq / 2);\r\ngoto exit;\r\n} else {\r\nseq += 2;\r\noffset += 7;\r\n}\r\n} while (offset < 35);\r\nmemcpy(ictx->usb_tx_buf, &vfd_packet6, sizeof(vfd_packet6));\r\nictx->usb_tx_buf[7] = (unsigned char) seq;\r\nretval = send_packet(ictx);\r\nif (retval)\r\npr_err("send packet failed for packet #%d\n", seq / 2);\r\nexit:\r\nmutex_unlock(&ictx->lock);\r\nreturn (!retval) ? n_bytes : retval;\r\n}\r\nstatic ssize_t lcd_write(struct file *file, const char *buf,\r\nsize_t n_bytes, loff_t *pos)\r\n{\r\nint retval = 0;\r\nstruct imon_context *ictx;\r\nictx = file->private_data;\r\nif (!ictx) {\r\npr_err("no context for device\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&ictx->lock);\r\nif (!ictx->display_supported) {\r\npr_err("no iMON display present\n");\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (n_bytes != 8) {\r\npr_err("invalid payload size: %d (expected 8)\n", (int)n_bytes);\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\nif (copy_from_user(ictx->usb_tx_buf, buf, 8)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\nretval = send_packet(ictx);\r\nif (retval) {\r\npr_err("send packet failed!\n");\r\ngoto exit;\r\n} else {\r\ndev_dbg(ictx->dev, "%s: write %d bytes to LCD\n",\r\n__func__, (int) n_bytes);\r\n}\r\nexit:\r\nmutex_unlock(&ictx->lock);\r\nreturn (!retval) ? n_bytes : retval;\r\n}\r\nstatic void usb_tx_callback(struct urb *urb)\r\n{\r\nstruct imon_context *ictx;\r\nif (!urb)\r\nreturn;\r\nictx = (struct imon_context *)urb->context;\r\nif (!ictx)\r\nreturn;\r\nictx->tx.status = urb->status;\r\nictx->tx.busy = false;\r\nsmp_rmb();\r\ncomplete(&ictx->tx.finished);\r\n}\r\nstatic void imon_touch_display_timeout(unsigned long data)\r\n{\r\nstruct imon_context *ictx = (struct imon_context *)data;\r\nif (ictx->display_type != IMON_DISPLAY_TYPE_VGA)\r\nreturn;\r\ninput_report_abs(ictx->touch, ABS_X, ictx->touch_x);\r\ninput_report_abs(ictx->touch, ABS_Y, ictx->touch_y);\r\ninput_report_key(ictx->touch, BTN_TOUCH, 0x00);\r\ninput_sync(ictx->touch);\r\n}\r\nstatic int imon_ir_change_protocol(struct rc_dev *rc, u64 rc_type)\r\n{\r\nint retval;\r\nstruct imon_context *ictx = rc->priv;\r\nstruct device *dev = ictx->dev;\r\nbool unlock = false;\r\nunsigned char ir_proto_packet[] = {\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86 };\r\nif (rc_type && !(rc_type & rc->allowed_protos))\r\ndev_warn(dev, "Looks like you're trying to use an IR protocol "\r\n"this device does not support\n");\r\nswitch (rc_type) {\r\ncase RC_TYPE_RC6:\r\ndev_dbg(dev, "Configuring IR receiver for MCE protocol\n");\r\nir_proto_packet[0] = 0x01;\r\nbreak;\r\ncase RC_TYPE_UNKNOWN:\r\ncase RC_TYPE_OTHER:\r\ndev_dbg(dev, "Configuring IR receiver for iMON protocol\n");\r\nif (!pad_stabilize)\r\ndev_dbg(dev, "PAD stabilize functionality disabled\n");\r\nrc_type = RC_TYPE_OTHER;\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "Unsupported IR protocol specified, overriding "\r\n"to iMON IR protocol\n");\r\nif (!pad_stabilize)\r\ndev_dbg(dev, "PAD stabilize functionality disabled\n");\r\nrc_type = RC_TYPE_OTHER;\r\nbreak;\r\n}\r\nmemcpy(ictx->usb_tx_buf, &ir_proto_packet, sizeof(ir_proto_packet));\r\nif (!mutex_is_locked(&ictx->lock)) {\r\nunlock = true;\r\nmutex_lock(&ictx->lock);\r\n}\r\nretval = send_packet(ictx);\r\nif (retval)\r\ngoto out;\r\nictx->rc_type = rc_type;\r\nictx->pad_mouse = false;\r\nout:\r\nif (unlock)\r\nmutex_unlock(&ictx->lock);\r\nreturn retval;\r\n}\r\nstatic inline int tv2int(const struct timeval *a, const struct timeval *b)\r\n{\r\nint usecs = 0;\r\nint sec = 0;\r\nif (b->tv_usec > a->tv_usec) {\r\nusecs = 1000000;\r\nsec--;\r\n}\r\nusecs += a->tv_usec - b->tv_usec;\r\nsec += a->tv_sec - b->tv_sec;\r\nsec *= 1000;\r\nusecs /= 1000;\r\nsec += usecs;\r\nif (sec < 0)\r\nsec = 1000;\r\nreturn sec;\r\n}\r\nstatic int stabilize(int a, int b, u16 timeout, u16 threshold)\r\n{\r\nstruct timeval ct;\r\nstatic struct timeval prev_time = {0, 0};\r\nstatic struct timeval hit_time = {0, 0};\r\nstatic int x, y, prev_result, hits;\r\nint result = 0;\r\nint msec, msec_hit;\r\ndo_gettimeofday(&ct);\r\nmsec = tv2int(&ct, &prev_time);\r\nmsec_hit = tv2int(&ct, &hit_time);\r\nif (msec > 100) {\r\nx = 0;\r\ny = 0;\r\nhits = 0;\r\n}\r\nx += a;\r\ny += b;\r\nprev_time = ct;\r\nif (abs(x) > threshold || abs(y) > threshold) {\r\nif (abs(y) > abs(x))\r\nresult = (y > 0) ? 0x7F : 0x80;\r\nelse\r\nresult = (x > 0) ? 0x7F00 : 0x8000;\r\nx = 0;\r\ny = 0;\r\nif (result == prev_result) {\r\nhits++;\r\nif (hits > 3) {\r\nswitch (result) {\r\ncase 0x7F:\r\ny = 17 * threshold / 30;\r\nbreak;\r\ncase 0x80:\r\ny -= 17 * threshold / 30;\r\nbreak;\r\ncase 0x7F00:\r\nx = 17 * threshold / 30;\r\nbreak;\r\ncase 0x8000:\r\nx -= 17 * threshold / 30;\r\nbreak;\r\n}\r\n}\r\nif (hits == 2 && msec_hit < timeout) {\r\nresult = 0;\r\nhits = 1;\r\n}\r\n} else {\r\nprev_result = result;\r\nhits = 1;\r\nhit_time = ct;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic u32 imon_remote_key_lookup(struct imon_context *ictx, u32 scancode)\r\n{\r\nu32 keycode;\r\nu32 release;\r\nbool is_release_code = false;\r\nkeycode = rc_g_keycode_from_table(ictx->rdev, scancode);\r\nictx->rc_toggle = 0x0;\r\nictx->rc_scancode = scancode;\r\nif (keycode == KEY_RESERVED) {\r\nrelease = scancode & ~0x4000;\r\nkeycode = rc_g_keycode_from_table(ictx->rdev, release);\r\nif (keycode != KEY_RESERVED)\r\nis_release_code = true;\r\n}\r\nictx->release_code = is_release_code;\r\nreturn keycode;\r\n}\r\nstatic u32 imon_mce_key_lookup(struct imon_context *ictx, u32 scancode)\r\n{\r\nu32 keycode;\r\n#define MCE_KEY_MASK 0x7000\r\n#define MCE_TOGGLE_BIT 0x8000\r\nif (scancode & 0x80000000)\r\nscancode = scancode | MCE_KEY_MASK | MCE_TOGGLE_BIT;\r\nictx->rc_scancode = scancode;\r\nkeycode = rc_g_keycode_from_table(ictx->rdev, scancode);\r\nictx->release_code = false;\r\nreturn keycode;\r\n}\r\nstatic u32 imon_panel_key_lookup(u64 code)\r\n{\r\nint i;\r\nu32 keycode = KEY_RESERVED;\r\nfor (i = 0; i < ARRAY_SIZE(imon_panel_key_table); i++) {\r\nif (imon_panel_key_table[i].hw_code == (code | 0xffee)) {\r\nkeycode = imon_panel_key_table[i].keycode;\r\nbreak;\r\n}\r\n}\r\nreturn keycode;\r\n}\r\nstatic bool imon_mouse_event(struct imon_context *ictx,\r\nunsigned char *buf, int len)\r\n{\r\nchar rel_x = 0x00, rel_y = 0x00;\r\nu8 right_shift = 1;\r\nbool mouse_input = true;\r\nint dir = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nif (ictx->product != 0xffdc && (buf[0] & 0x01) && len == 5) {\r\nrel_x = buf[2];\r\nrel_y = buf[3];\r\nright_shift = 1;\r\n} else if (ictx->product == 0xffdc && (buf[0] & 0x40) &&\r\n!((buf[1] & 0x01) || ((buf[1] >> 2) & 0x01))) {\r\nrel_x = (buf[1] & 0x08) | (buf[1] & 0x10) >> 2 |\r\n(buf[1] & 0x20) >> 4 | (buf[1] & 0x40) >> 6;\r\nif (buf[0] & 0x02)\r\nrel_x |= ~0x0f;\r\nrel_x = rel_x + rel_x / 2;\r\nrel_y = (buf[2] & 0x08) | (buf[2] & 0x10) >> 2 |\r\n(buf[2] & 0x20) >> 4 | (buf[2] & 0x40) >> 6;\r\nif (buf[0] & 0x01)\r\nrel_y |= ~0x0f;\r\nrel_y = rel_y + rel_y / 2;\r\nright_shift = 2;\r\n} else if (ictx->product == 0xffdc && (buf[0] == 0x68)) {\r\nright_shift = 2;\r\n} else if (ictx->kc == KEY_CHANNELUP && (buf[2] & 0x40) != 0x40) {\r\ndir = 1;\r\n} else if (ictx->kc == KEY_CHANNELDOWN && (buf[2] & 0x40) != 0x40) {\r\ndir = -1;\r\n} else\r\nmouse_input = false;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\nif (mouse_input) {\r\ndev_dbg(ictx->dev, "sending mouse data via input subsystem\n");\r\nif (dir) {\r\ninput_report_rel(ictx->idev, REL_WHEEL, dir);\r\n} else if (rel_x || rel_y) {\r\ninput_report_rel(ictx->idev, REL_X, rel_x);\r\ninput_report_rel(ictx->idev, REL_Y, rel_y);\r\n} else {\r\ninput_report_key(ictx->idev, BTN_LEFT, buf[1] & 0x1);\r\ninput_report_key(ictx->idev, BTN_RIGHT,\r\nbuf[1] >> right_shift & 0x1);\r\n}\r\ninput_sync(ictx->idev);\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nictx->last_keycode = ictx->kc;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\n}\r\nreturn mouse_input;\r\n}\r\nstatic void imon_touch_event(struct imon_context *ictx, unsigned char *buf)\r\n{\r\nmod_timer(&ictx->ttimer, jiffies + TOUCH_TIMEOUT);\r\nictx->touch_x = (buf[0] << 4) | (buf[1] >> 4);\r\nictx->touch_y = 0xfff - ((buf[2] << 4) | (buf[1] & 0xf));\r\ninput_report_abs(ictx->touch, ABS_X, ictx->touch_x);\r\ninput_report_abs(ictx->touch, ABS_Y, ictx->touch_y);\r\ninput_report_key(ictx->touch, BTN_TOUCH, 0x01);\r\ninput_sync(ictx->touch);\r\n}\r\nstatic void imon_pad_to_keys(struct imon_context *ictx, unsigned char *buf)\r\n{\r\nint dir = 0;\r\nchar rel_x = 0x00, rel_y = 0x00;\r\nu16 timeout, threshold;\r\nu32 scancode = KEY_RESERVED;\r\nunsigned long flags;\r\nif (ictx->product != 0xffdc) {\r\nbuf[5] = buf[6] = buf[7] = 0;\r\ntimeout = 500;\r\nthreshold = pad_thresh ? pad_thresh : 28;\r\nrel_x = buf[2];\r\nrel_y = buf[3];\r\nif (ictx->rc_type == RC_TYPE_OTHER && pad_stabilize) {\r\nif ((buf[1] == 0) && ((rel_x != 0) || (rel_y != 0))) {\r\ndir = stabilize((int)rel_x, (int)rel_y,\r\ntimeout, threshold);\r\nif (!dir) {\r\nspin_lock_irqsave(&ictx->kc_lock,\r\nflags);\r\nictx->kc = KEY_UNKNOWN;\r\nspin_unlock_irqrestore(&ictx->kc_lock,\r\nflags);\r\nreturn;\r\n}\r\nbuf[2] = dir & 0xFF;\r\nbuf[3] = (dir >> 8) & 0xFF;\r\nscancode = be32_to_cpu(*((u32 *)buf));\r\n}\r\n} else {\r\nif (abs(rel_y) > abs(rel_x)) {\r\nbuf[2] = (rel_y > 0) ? 0x7F : 0x80;\r\nbuf[3] = 0;\r\nif (rel_y > 0)\r\nscancode = 0x01007f00;\r\nelse\r\nscancode = 0x01008000;\r\n} else {\r\nbuf[2] = 0;\r\nbuf[3] = (rel_x > 0) ? 0x7F : 0x80;\r\nif (rel_x > 0)\r\nscancode = 0x0100007f;\r\nelse\r\nscancode = 0x01000080;\r\n}\r\n}\r\n} else {\r\ntimeout = 10;\r\nthreshold = pad_thresh ? pad_thresh : 15;\r\nrel_x = (buf[1] & 0x08) | (buf[1] & 0x10) >> 2 |\r\n(buf[1] & 0x20) >> 4 | (buf[1] & 0x40) >> 6;\r\nif (buf[0] & 0x02)\r\nrel_x |= ~0x10+1;\r\nrel_y = (buf[2] & 0x08) | (buf[2] & 0x10) >> 2 |\r\n(buf[2] & 0x20) >> 4 | (buf[2] & 0x40) >> 6;\r\nif (buf[0] & 0x01)\r\nrel_y |= ~0x10+1;\r\nbuf[0] = 0x01;\r\nbuf[1] = buf[4] = buf[5] = buf[6] = buf[7] = 0;\r\nif (ictx->rc_type == RC_TYPE_OTHER && pad_stabilize) {\r\ndir = stabilize((int)rel_x, (int)rel_y,\r\ntimeout, threshold);\r\nif (!dir) {\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nictx->kc = KEY_UNKNOWN;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\nreturn;\r\n}\r\nbuf[2] = dir & 0xFF;\r\nbuf[3] = (dir >> 8) & 0xFF;\r\nscancode = be32_to_cpu(*((u32 *)buf));\r\n} else {\r\nif (abs(rel_y) > abs(rel_x)) {\r\nbuf[2] = (rel_y > 0) ? 0x7F : 0x80;\r\nbuf[3] = 0;\r\nif (rel_y > 0)\r\nscancode = 0x01007f00;\r\nelse\r\nscancode = 0x01008000;\r\n} else {\r\nbuf[2] = 0;\r\nbuf[3] = (rel_x > 0) ? 0x7F : 0x80;\r\nif (rel_x > 0)\r\nscancode = 0x0100007f;\r\nelse\r\nscancode = 0x01000080;\r\n}\r\n}\r\n}\r\nif (scancode) {\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nictx->kc = imon_remote_key_lookup(ictx, scancode);\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\n}\r\n}\r\nstatic int imon_parse_press_type(struct imon_context *ictx,\r\nunsigned char *buf, u8 ktype)\r\n{\r\nint press_type = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nif (ictx->kc == KEY_RESERVED && buf[0] == 0x02 && buf[3] == 0x00)\r\nictx->kc = ictx->last_keycode;\r\nelse if (ictx->kc == KEY_RESERVED && buf[0] == 0x68 && buf[1] == 0x82 &&\r\nbuf[2] == 0x81 && buf[3] == 0xb7)\r\nictx->kc = ictx->last_keycode;\r\nelse if (ictx->kc == KEY_RESERVED && buf[0] == 0x01 && buf[1] == 0x00 &&\r\nbuf[2] == 0x81 && buf[3] == 0xb7)\r\nictx->kc = ictx->last_keycode;\r\nelse if (ktype == IMON_KEY_MCE) {\r\nictx->rc_toggle = buf[2];\r\npress_type = 1;\r\n} else if (ictx->kc == KEY_RESERVED)\r\npress_type = -EINVAL;\r\nelse if (ictx->release_code)\r\npress_type = 0;\r\nelse\r\npress_type = 1;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\nreturn press_type;\r\n}\r\nstatic void imon_incoming_packet(struct imon_context *ictx,\r\nstruct urb *urb, int intf)\r\n{\r\nint len = urb->actual_length;\r\nunsigned char *buf = urb->transfer_buffer;\r\nstruct device *dev = ictx->dev;\r\nunsigned long flags;\r\nu32 kc;\r\nint i;\r\nu64 scancode;\r\nint press_type = 0;\r\nint msec;\r\nstruct timeval t;\r\nstatic struct timeval prev_time = { 0, 0 };\r\nu8 ktype;\r\nif ((buf[0] == 0xff) && (buf[1] == 0xff) && (buf[2] == 0xff))\r\nreturn;\r\nif (len == 8 && buf[7] == 0xee) {\r\nscancode = be64_to_cpu(*((u64 *)buf));\r\nktype = IMON_KEY_PANEL;\r\nkc = imon_panel_key_lookup(scancode);\r\n} else {\r\nscancode = be32_to_cpu(*((u32 *)buf));\r\nif (ictx->rc_type == RC_TYPE_RC6) {\r\nktype = IMON_KEY_IMON;\r\nif (buf[0] == 0x80)\r\nktype = IMON_KEY_MCE;\r\nkc = imon_mce_key_lookup(ictx, scancode);\r\n} else {\r\nktype = IMON_KEY_IMON;\r\nkc = imon_remote_key_lookup(ictx, scancode);\r\n}\r\n}\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nif (kc == KEY_KEYBOARD && !ictx->release_code) {\r\nictx->last_keycode = kc;\r\nif (!nomouse) {\r\nictx->pad_mouse = ~(ictx->pad_mouse) & 0x1;\r\ndev_dbg(dev, "toggling to %s mode\n",\r\nictx->pad_mouse ? "mouse" : "keyboard");\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\nreturn;\r\n} else {\r\nictx->pad_mouse = false;\r\ndev_dbg(dev, "mouse mode disabled, passing key value\n");\r\n}\r\n}\r\nictx->kc = kc;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\nif (ictx->display_type == IMON_DISPLAY_TYPE_VGA && len == 8 &&\r\nbuf[7] == 0x86) {\r\nimon_touch_event(ictx, buf);\r\nreturn;\r\n} else if (ictx->pad_mouse) {\r\nif (imon_mouse_event(ictx, buf, len))\r\nreturn;\r\n}\r\nif (((len == 5) && (buf[0] == 0x01) && (buf[4] == 0x00)) ||\r\n((len == 8) && (buf[0] & 0x40) &&\r\n!(buf[1] & 0x1 || buf[1] >> 2 & 0x1))) {\r\nlen = 8;\r\nimon_pad_to_keys(ictx, buf);\r\n}\r\nif (debug) {\r\nprintk(KERN_INFO "intf%d decoded packet: ", intf);\r\nfor (i = 0; i < len; ++i)\r\nprintk("%02x ", buf[i]);\r\nprintk("\n");\r\n}\r\npress_type = imon_parse_press_type(ictx, buf, ktype);\r\nif (press_type < 0)\r\ngoto not_input_data;\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nif (ictx->kc == KEY_UNKNOWN)\r\ngoto unknown_key;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\nif (ktype != IMON_KEY_PANEL) {\r\nif (press_type == 0)\r\nrc_keyup(ictx->rdev);\r\nelse {\r\nrc_keydown(ictx->rdev, ictx->rc_scancode, ictx->rc_toggle);\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nictx->last_keycode = ictx->kc;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\n}\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\ndo_gettimeofday(&t);\r\nif (ictx->kc == KEY_MUTE && ictx->kc == ictx->last_keycode) {\r\nmsec = tv2int(&t, &prev_time);\r\nif (msec < ictx->idev->rep[REP_DELAY]) {\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\nreturn;\r\n}\r\n}\r\nprev_time = t;\r\nkc = ictx->kc;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\ninput_report_key(ictx->idev, kc, press_type);\r\ninput_sync(ictx->idev);\r\ninput_report_key(ictx->idev, kc, 0);\r\ninput_sync(ictx->idev);\r\nspin_lock_irqsave(&ictx->kc_lock, flags);\r\nictx->last_keycode = kc;\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\nreturn;\r\nunknown_key:\r\nspin_unlock_irqrestore(&ictx->kc_lock, flags);\r\ndev_info(dev, "%s: unknown keypress, code 0x%llx\n", __func__,\r\n(long long)scancode);\r\nreturn;\r\nnot_input_data:\r\nif (len != 8) {\r\ndev_warn(dev, "imon %s: invalid incoming packet "\r\n"size (len = %d, intf%d)\n", __func__, len, intf);\r\nreturn;\r\n}\r\nif (buf[0] == 0x00 &&\r\nbuf[2] == 0xFF &&\r\nbuf[3] == 0xFF &&\r\nbuf[4] == 0xFF &&\r\nbuf[5] == 0xFF &&\r\n((buf[6] == 0x4E && buf[7] == 0xDF) ||\r\n(buf[6] == 0x5E && buf[7] == 0xDF))) {\r\ndev_warn(dev, "%s: remote associated refid=%02X\n",\r\n__func__, buf[1]);\r\nictx->rf_isassociating = false;\r\n}\r\n}\r\nstatic void usb_rx_callback_intf0(struct urb *urb)\r\n{\r\nstruct imon_context *ictx;\r\nint intfnum = 0;\r\nif (!urb)\r\nreturn;\r\nictx = (struct imon_context *)urb->context;\r\nif (!ictx)\r\nreturn;\r\nswitch (urb->status) {\r\ncase -ENOENT:\r\nreturn;\r\ncase -ESHUTDOWN:\r\nbreak;\r\ncase 0:\r\nimon_incoming_packet(ictx, urb, intfnum);\r\nbreak;\r\ndefault:\r\ndev_warn(ictx->dev, "imon %s: status(%d): ignored\n",\r\n__func__, urb->status);\r\nbreak;\r\n}\r\nusb_submit_urb(ictx->rx_urb_intf0, GFP_ATOMIC);\r\n}\r\nstatic void usb_rx_callback_intf1(struct urb *urb)\r\n{\r\nstruct imon_context *ictx;\r\nint intfnum = 1;\r\nif (!urb)\r\nreturn;\r\nictx = (struct imon_context *)urb->context;\r\nif (!ictx)\r\nreturn;\r\nswitch (urb->status) {\r\ncase -ENOENT:\r\nreturn;\r\ncase -ESHUTDOWN:\r\nbreak;\r\ncase 0:\r\nimon_incoming_packet(ictx, urb, intfnum);\r\nbreak;\r\ndefault:\r\ndev_warn(ictx->dev, "imon %s: status(%d): ignored\n",\r\n__func__, urb->status);\r\nbreak;\r\n}\r\nusb_submit_urb(ictx->rx_urb_intf1, GFP_ATOMIC);\r\n}\r\nstatic void imon_get_ffdc_type(struct imon_context *ictx)\r\n{\r\nu8 ffdc_cfg_byte = ictx->usb_rx_buf[6];\r\nu8 detected_display_type = IMON_DISPLAY_TYPE_NONE;\r\nu64 allowed_protos = RC_TYPE_OTHER;\r\nswitch (ffdc_cfg_byte) {\r\ncase 0x21:\r\ndev_info(ictx->dev, "0xffdc iMON Knob, iMON IR");\r\nictx->display_supported = false;\r\nbreak;\r\ncase 0x4e:\r\ndev_info(ictx->dev, "0xffdc iMON 2.4G LT, iMON RF");\r\nictx->display_supported = false;\r\nictx->rf_device = true;\r\nbreak;\r\ncase 0x35:\r\ndev_info(ictx->dev, "0xffdc iMON VFD + knob, no IR");\r\ndetected_display_type = IMON_DISPLAY_TYPE_VFD;\r\nbreak;\r\ncase 0x24:\r\ncase 0x85:\r\ndev_info(ictx->dev, "0xffdc iMON VFD, iMON IR");\r\ndetected_display_type = IMON_DISPLAY_TYPE_VFD;\r\nbreak;\r\ncase 0x46:\r\ncase 0x7e:\r\ncase 0x9e:\r\ndev_info(ictx->dev, "0xffdc iMON VFD, MCE IR");\r\ndetected_display_type = IMON_DISPLAY_TYPE_VFD;\r\nallowed_protos = RC_TYPE_RC6;\r\nbreak;\r\ncase 0x9f:\r\ndev_info(ictx->dev, "0xffdc iMON LCD, MCE IR");\r\ndetected_display_type = IMON_DISPLAY_TYPE_LCD;\r\nallowed_protos = RC_TYPE_RC6;\r\nbreak;\r\ndefault:\r\ndev_info(ictx->dev, "Unknown 0xffdc device, "\r\n"defaulting to VFD and iMON IR");\r\ndetected_display_type = IMON_DISPLAY_TYPE_VFD;\r\nallowed_protos |= RC_TYPE_RC6;\r\nbreak;\r\n}\r\nprintk(KERN_CONT " (id 0x%02x)\n", ffdc_cfg_byte);\r\nictx->display_type = detected_display_type;\r\nictx->rc_type = allowed_protos;\r\n}\r\nstatic void imon_set_display_type(struct imon_context *ictx)\r\n{\r\nu8 configured_display_type = IMON_DISPLAY_TYPE_VFD;\r\nif (display_type == IMON_DISPLAY_TYPE_AUTO) {\r\nswitch (ictx->product) {\r\ncase 0xffdc:\r\nconfigured_display_type = ictx->display_type;\r\nbreak;\r\ncase 0x0034:\r\ncase 0x0035:\r\nconfigured_display_type = IMON_DISPLAY_TYPE_VGA;\r\nbreak;\r\ncase 0x0038:\r\ncase 0x0039:\r\ncase 0x0045:\r\nconfigured_display_type = IMON_DISPLAY_TYPE_LCD;\r\nbreak;\r\ncase 0x003c:\r\ncase 0x0041:\r\ncase 0x0042:\r\ncase 0x0043:\r\nconfigured_display_type = IMON_DISPLAY_TYPE_NONE;\r\nictx->display_supported = false;\r\nbreak;\r\ncase 0x0036:\r\ncase 0x0044:\r\ndefault:\r\nconfigured_display_type = IMON_DISPLAY_TYPE_VFD;\r\nbreak;\r\n}\r\n} else {\r\nconfigured_display_type = display_type;\r\nif (display_type == IMON_DISPLAY_TYPE_NONE)\r\nictx->display_supported = false;\r\nelse\r\nictx->display_supported = true;\r\ndev_info(ictx->dev, "%s: overriding display type to %d via "\r\n"modparam\n", __func__, display_type);\r\n}\r\nictx->display_type = configured_display_type;\r\n}\r\nstatic struct rc_dev *imon_init_rdev(struct imon_context *ictx)\r\n{\r\nstruct rc_dev *rdev;\r\nint ret;\r\nconst unsigned char fp_packet[] = { 0x40, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x88 };\r\nrdev = rc_allocate_device();\r\nif (!rdev) {\r\ndev_err(ictx->dev, "remote control dev allocation failed\n");\r\ngoto out;\r\n}\r\nsnprintf(ictx->name_rdev, sizeof(ictx->name_rdev),\r\n"iMON Remote (%04x:%04x)", ictx->vendor, ictx->product);\r\nusb_make_path(ictx->usbdev_intf0, ictx->phys_rdev,\r\nsizeof(ictx->phys_rdev));\r\nstrlcat(ictx->phys_rdev, "/input0", sizeof(ictx->phys_rdev));\r\nrdev->input_name = ictx->name_rdev;\r\nrdev->input_phys = ictx->phys_rdev;\r\nusb_to_input_id(ictx->usbdev_intf0, &rdev->input_id);\r\nrdev->dev.parent = ictx->dev;\r\nrdev->priv = ictx;\r\nrdev->driver_type = RC_DRIVER_SCANCODE;\r\nrdev->allowed_protos = RC_TYPE_OTHER | RC_TYPE_RC6;\r\nrdev->change_protocol = imon_ir_change_protocol;\r\nrdev->driver_name = MOD_NAME;\r\nmemcpy(ictx->usb_tx_buf, &fp_packet, sizeof(fp_packet));\r\nret = send_packet(ictx);\r\nif (ret)\r\ndev_info(ictx->dev, "panel buttons/knobs setup failed\n");\r\nif (ictx->product == 0xffdc) {\r\nimon_get_ffdc_type(ictx);\r\nrdev->allowed_protos = ictx->rc_type;\r\n}\r\nimon_set_display_type(ictx);\r\nif (ictx->rc_type == RC_TYPE_RC6)\r\nrdev->map_name = RC_MAP_IMON_MCE;\r\nelse\r\nrdev->map_name = RC_MAP_IMON_PAD;\r\nret = rc_register_device(rdev);\r\nif (ret < 0) {\r\ndev_err(ictx->dev, "remote input dev register failed\n");\r\ngoto out;\r\n}\r\nreturn rdev;\r\nout:\r\nrc_free_device(rdev);\r\nreturn NULL;\r\n}\r\nstatic struct input_dev *imon_init_idev(struct imon_context *ictx)\r\n{\r\nstruct input_dev *idev;\r\nint ret, i;\r\nidev = input_allocate_device();\r\nif (!idev) {\r\ndev_err(ictx->dev, "input dev allocation failed\n");\r\ngoto out;\r\n}\r\nsnprintf(ictx->name_idev, sizeof(ictx->name_idev),\r\n"iMON Panel, Knob and Mouse(%04x:%04x)",\r\nictx->vendor, ictx->product);\r\nidev->name = ictx->name_idev;\r\nusb_make_path(ictx->usbdev_intf0, ictx->phys_idev,\r\nsizeof(ictx->phys_idev));\r\nstrlcat(ictx->phys_idev, "/input1", sizeof(ictx->phys_idev));\r\nidev->phys = ictx->phys_idev;\r\nidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) | BIT_MASK(EV_REL);\r\nidev->keybit[BIT_WORD(BTN_MOUSE)] =\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT);\r\nidev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y) |\r\nBIT_MASK(REL_WHEEL);\r\nfor (i = 0; i < ARRAY_SIZE(imon_panel_key_table); i++) {\r\nu32 kc = imon_panel_key_table[i].keycode;\r\n__set_bit(kc, idev->keybit);\r\n}\r\nusb_to_input_id(ictx->usbdev_intf0, &idev->id);\r\nidev->dev.parent = ictx->dev;\r\ninput_set_drvdata(idev, ictx);\r\nret = input_register_device(idev);\r\nif (ret < 0) {\r\ndev_err(ictx->dev, "input dev register failed\n");\r\ngoto out;\r\n}\r\nreturn idev;\r\nout:\r\ninput_free_device(idev);\r\nreturn NULL;\r\n}\r\nstatic struct input_dev *imon_init_touch(struct imon_context *ictx)\r\n{\r\nstruct input_dev *touch;\r\nint ret;\r\ntouch = input_allocate_device();\r\nif (!touch) {\r\ndev_err(ictx->dev, "touchscreen input dev allocation failed\n");\r\ngoto touch_alloc_failed;\r\n}\r\nsnprintf(ictx->name_touch, sizeof(ictx->name_touch),\r\n"iMON USB Touchscreen (%04x:%04x)",\r\nictx->vendor, ictx->product);\r\ntouch->name = ictx->name_touch;\r\nusb_make_path(ictx->usbdev_intf1, ictx->phys_touch,\r\nsizeof(ictx->phys_touch));\r\nstrlcat(ictx->phys_touch, "/input2", sizeof(ictx->phys_touch));\r\ntouch->phys = ictx->phys_touch;\r\ntouch->evbit[0] =\r\nBIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ntouch->keybit[BIT_WORD(BTN_TOUCH)] =\r\nBIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(touch, ABS_X,\r\n0x00, 0xfff, 0, 0);\r\ninput_set_abs_params(touch, ABS_Y,\r\n0x00, 0xfff, 0, 0);\r\ninput_set_drvdata(touch, ictx);\r\nusb_to_input_id(ictx->usbdev_intf1, &touch->id);\r\ntouch->dev.parent = ictx->dev;\r\nret = input_register_device(touch);\r\nif (ret < 0) {\r\ndev_info(ictx->dev, "touchscreen input dev register failed\n");\r\ngoto touch_register_failed;\r\n}\r\nreturn touch;\r\ntouch_register_failed:\r\ninput_free_device(touch);\r\ntouch_alloc_failed:\r\nreturn NULL;\r\n}\r\nstatic bool imon_find_endpoints(struct imon_context *ictx,\r\nstruct usb_host_interface *iface_desc)\r\n{\r\nstruct usb_endpoint_descriptor *ep;\r\nstruct usb_endpoint_descriptor *rx_endpoint = NULL;\r\nstruct usb_endpoint_descriptor *tx_endpoint = NULL;\r\nint ifnum = iface_desc->desc.bInterfaceNumber;\r\nint num_endpts = iface_desc->desc.bNumEndpoints;\r\nint i, ep_dir, ep_type;\r\nbool ir_ep_found = false;\r\nbool display_ep_found = false;\r\nbool tx_control = false;\r\nfor (i = 0; i < num_endpts && !(ir_ep_found && display_ep_found); ++i) {\r\nep = &iface_desc->endpoint[i].desc;\r\nep_dir = ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\r\nep_type = ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nif (!ir_ep_found && ep_dir == USB_DIR_IN &&\r\nep_type == USB_ENDPOINT_XFER_INT) {\r\nrx_endpoint = ep;\r\nir_ep_found = true;\r\ndev_dbg(ictx->dev, "%s: found IR endpoint\n", __func__);\r\n} else if (!display_ep_found && ep_dir == USB_DIR_OUT &&\r\nep_type == USB_ENDPOINT_XFER_INT) {\r\ntx_endpoint = ep;\r\ndisplay_ep_found = true;\r\ndev_dbg(ictx->dev, "%s: found display endpoint\n", __func__);\r\n}\r\n}\r\nif (ifnum == 0) {\r\nictx->rx_endpoint_intf0 = rx_endpoint;\r\nictx->tx_endpoint = tx_endpoint;\r\n} else {\r\nictx->rx_endpoint_intf1 = rx_endpoint;\r\n}\r\nif (!display_ep_found) {\r\ntx_control = true;\r\ndisplay_ep_found = true;\r\ndev_dbg(ictx->dev, "%s: device uses control endpoint, not "\r\n"interface OUT endpoint\n", __func__);\r\n}\r\nif (ictx->display_type == IMON_DISPLAY_TYPE_NONE) {\r\ndisplay_ep_found = false;\r\ndev_dbg(ictx->dev, "%s: device has no display\n", __func__);\r\n}\r\nif (ictx->display_type == IMON_DISPLAY_TYPE_VGA) {\r\ndisplay_ep_found = false;\r\ndev_dbg(ictx->dev, "%s: iMON Touch device found\n", __func__);\r\n}\r\nif (!ir_ep_found)\r\npr_err("no valid input (IR) endpoint found\n");\r\nictx->tx_control = tx_control;\r\nif (display_ep_found)\r\nictx->display_supported = true;\r\nreturn ir_ep_found;\r\n}\r\nstatic struct imon_context *imon_init_intf0(struct usb_interface *intf)\r\n{\r\nstruct imon_context *ictx;\r\nstruct urb *rx_urb;\r\nstruct urb *tx_urb;\r\nstruct device *dev = &intf->dev;\r\nstruct usb_host_interface *iface_desc;\r\nint ret = -ENOMEM;\r\nictx = kzalloc(sizeof(struct imon_context), GFP_KERNEL);\r\nif (!ictx) {\r\ndev_err(dev, "%s: kzalloc failed for context", __func__);\r\ngoto exit;\r\n}\r\nrx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rx_urb) {\r\ndev_err(dev, "%s: usb_alloc_urb failed for IR urb", __func__);\r\ngoto rx_urb_alloc_failed;\r\n}\r\ntx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!tx_urb) {\r\ndev_err(dev, "%s: usb_alloc_urb failed for display urb",\r\n__func__);\r\ngoto tx_urb_alloc_failed;\r\n}\r\nmutex_init(&ictx->lock);\r\nspin_lock_init(&ictx->kc_lock);\r\nmutex_lock(&ictx->lock);\r\nictx->dev = dev;\r\nictx->usbdev_intf0 = usb_get_dev(interface_to_usbdev(intf));\r\nictx->dev_present_intf0 = true;\r\nictx->rx_urb_intf0 = rx_urb;\r\nictx->tx_urb = tx_urb;\r\nictx->rf_device = false;\r\nictx->vendor = le16_to_cpu(ictx->usbdev_intf0->descriptor.idVendor);\r\nictx->product = le16_to_cpu(ictx->usbdev_intf0->descriptor.idProduct);\r\nret = -ENODEV;\r\niface_desc = intf->cur_altsetting;\r\nif (!imon_find_endpoints(ictx, iface_desc)) {\r\ngoto find_endpoint_failed;\r\n}\r\nusb_fill_int_urb(ictx->rx_urb_intf0, ictx->usbdev_intf0,\r\nusb_rcvintpipe(ictx->usbdev_intf0,\r\nictx->rx_endpoint_intf0->bEndpointAddress),\r\nictx->usb_rx_buf, sizeof(ictx->usb_rx_buf),\r\nusb_rx_callback_intf0, ictx,\r\nictx->rx_endpoint_intf0->bInterval);\r\nret = usb_submit_urb(ictx->rx_urb_intf0, GFP_KERNEL);\r\nif (ret) {\r\npr_err("usb_submit_urb failed for intf0 (%d)\n", ret);\r\ngoto urb_submit_failed;\r\n}\r\nictx->idev = imon_init_idev(ictx);\r\nif (!ictx->idev) {\r\ndev_err(dev, "%s: input device setup failed\n", __func__);\r\ngoto idev_setup_failed;\r\n}\r\nictx->rdev = imon_init_rdev(ictx);\r\nif (!ictx->rdev) {\r\ndev_err(dev, "%s: rc device setup failed\n", __func__);\r\ngoto rdev_setup_failed;\r\n}\r\nmutex_unlock(&ictx->lock);\r\nreturn ictx;\r\nrdev_setup_failed:\r\ninput_unregister_device(ictx->idev);\r\nidev_setup_failed:\r\nusb_kill_urb(ictx->rx_urb_intf0);\r\nurb_submit_failed:\r\nfind_endpoint_failed:\r\nmutex_unlock(&ictx->lock);\r\nusb_free_urb(tx_urb);\r\ntx_urb_alloc_failed:\r\nusb_free_urb(rx_urb);\r\nrx_urb_alloc_failed:\r\nkfree(ictx);\r\nexit:\r\ndev_err(dev, "unable to initialize intf0, err %d\n", ret);\r\nreturn NULL;\r\n}\r\nstatic struct imon_context *imon_init_intf1(struct usb_interface *intf,\r\nstruct imon_context *ictx)\r\n{\r\nstruct urb *rx_urb;\r\nstruct usb_host_interface *iface_desc;\r\nint ret = -ENOMEM;\r\nrx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rx_urb) {\r\npr_err("usb_alloc_urb failed for IR urb\n");\r\ngoto rx_urb_alloc_failed;\r\n}\r\nmutex_lock(&ictx->lock);\r\nif (ictx->display_type == IMON_DISPLAY_TYPE_VGA) {\r\ninit_timer(&ictx->ttimer);\r\nictx->ttimer.data = (unsigned long)ictx;\r\nictx->ttimer.function = imon_touch_display_timeout;\r\n}\r\nictx->usbdev_intf1 = usb_get_dev(interface_to_usbdev(intf));\r\nictx->dev_present_intf1 = true;\r\nictx->rx_urb_intf1 = rx_urb;\r\nret = -ENODEV;\r\niface_desc = intf->cur_altsetting;\r\nif (!imon_find_endpoints(ictx, iface_desc))\r\ngoto find_endpoint_failed;\r\nif (ictx->display_type == IMON_DISPLAY_TYPE_VGA) {\r\nictx->touch = imon_init_touch(ictx);\r\nif (!ictx->touch)\r\ngoto touch_setup_failed;\r\n} else\r\nictx->touch = NULL;\r\nusb_fill_int_urb(ictx->rx_urb_intf1, ictx->usbdev_intf1,\r\nusb_rcvintpipe(ictx->usbdev_intf1,\r\nictx->rx_endpoint_intf1->bEndpointAddress),\r\nictx->usb_rx_buf, sizeof(ictx->usb_rx_buf),\r\nusb_rx_callback_intf1, ictx,\r\nictx->rx_endpoint_intf1->bInterval);\r\nret = usb_submit_urb(ictx->rx_urb_intf1, GFP_KERNEL);\r\nif (ret) {\r\npr_err("usb_submit_urb failed for intf1 (%d)\n", ret);\r\ngoto urb_submit_failed;\r\n}\r\nmutex_unlock(&ictx->lock);\r\nreturn ictx;\r\nurb_submit_failed:\r\nif (ictx->touch)\r\ninput_unregister_device(ictx->touch);\r\ntouch_setup_failed:\r\nfind_endpoint_failed:\r\nmutex_unlock(&ictx->lock);\r\nusb_free_urb(rx_urb);\r\nrx_urb_alloc_failed:\r\ndev_err(ictx->dev, "unable to initialize intf0, err %d\n", ret);\r\nreturn NULL;\r\n}\r\nstatic void imon_init_display(struct imon_context *ictx,\r\nstruct usb_interface *intf)\r\n{\r\nint ret;\r\ndev_dbg(ictx->dev, "Registering iMON display with sysfs\n");\r\nret = sysfs_create_group(&intf->dev.kobj, &imon_display_attr_group);\r\nif (ret)\r\ndev_err(ictx->dev, "Could not create display sysfs "\r\n"entries(%d)", ret);\r\nif (ictx->display_type == IMON_DISPLAY_TYPE_LCD)\r\nret = usb_register_dev(intf, &imon_lcd_class);\r\nelse\r\nret = usb_register_dev(intf, &imon_vfd_class);\r\nif (ret)\r\ndev_info(ictx->dev, "could not get a minor number for "\r\n"display\n");\r\n}\r\nstatic int __devinit imon_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev = NULL;\r\nstruct usb_host_interface *iface_desc = NULL;\r\nstruct usb_interface *first_if;\r\nstruct device *dev = &interface->dev;\r\nint ifnum, sysfs_err;\r\nint ret = 0;\r\nstruct imon_context *ictx = NULL;\r\nstruct imon_context *first_if_ctx = NULL;\r\nu16 vendor, product;\r\nusbdev = usb_get_dev(interface_to_usbdev(interface));\r\niface_desc = interface->cur_altsetting;\r\nifnum = iface_desc->desc.bInterfaceNumber;\r\nvendor = le16_to_cpu(usbdev->descriptor.idVendor);\r\nproduct = le16_to_cpu(usbdev->descriptor.idProduct);\r\ndev_dbg(dev, "%s: found iMON device (%04x:%04x, intf%d)\n",\r\n__func__, vendor, product, ifnum);\r\nmutex_lock(&driver_lock);\r\nfirst_if = usb_ifnum_to_if(usbdev, 0);\r\nfirst_if_ctx = usb_get_intfdata(first_if);\r\nif (ifnum == 0) {\r\nictx = imon_init_intf0(interface);\r\nif (!ictx) {\r\npr_err("failed to initialize context!\n");\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\n} else {\r\nictx = imon_init_intf1(interface, first_if_ctx);\r\nif (!ictx) {\r\npr_err("failed to attach to context!\n");\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\n}\r\nusb_set_intfdata(interface, ictx);\r\nif (ifnum == 0) {\r\nmutex_lock(&ictx->lock);\r\nif (product == 0xffdc && ictx->rf_device) {\r\nsysfs_err = sysfs_create_group(&interface->dev.kobj,\r\n&imon_rf_attr_group);\r\nif (sysfs_err)\r\npr_err("Could not create RF sysfs entries(%d)\n",\r\nsysfs_err);\r\n}\r\nif (ictx->display_supported)\r\nimon_init_display(ictx, interface);\r\nmutex_unlock(&ictx->lock);\r\n}\r\ndev_info(dev, "iMON device (%04x:%04x, intf%d) on "\r\n"usb<%d:%d> initialized\n", vendor, product, ifnum,\r\nusbdev->bus->busnum, usbdev->devnum);\r\nmutex_unlock(&driver_lock);\r\nreturn 0;\r\nfail:\r\nmutex_unlock(&driver_lock);\r\ndev_err(dev, "unable to register, err %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __devexit imon_disconnect(struct usb_interface *interface)\r\n{\r\nstruct imon_context *ictx;\r\nstruct device *dev;\r\nint ifnum;\r\nmutex_lock(&driver_lock);\r\nictx = usb_get_intfdata(interface);\r\ndev = ictx->dev;\r\nifnum = interface->cur_altsetting->desc.bInterfaceNumber;\r\nsysfs_remove_group(&interface->dev.kobj, &imon_display_attr_group);\r\nsysfs_remove_group(&interface->dev.kobj, &imon_rf_attr_group);\r\nusb_set_intfdata(interface, NULL);\r\nif (ictx->tx.busy) {\r\nusb_kill_urb(ictx->tx_urb);\r\ncomplete_all(&ictx->tx.finished);\r\n}\r\nif (ifnum == 0) {\r\nictx->dev_present_intf0 = false;\r\nusb_kill_urb(ictx->rx_urb_intf0);\r\ninput_unregister_device(ictx->idev);\r\nrc_unregister_device(ictx->rdev);\r\nif (ictx->display_supported) {\r\nif (ictx->display_type == IMON_DISPLAY_TYPE_LCD)\r\nusb_deregister_dev(interface, &imon_lcd_class);\r\nelse if (ictx->display_type == IMON_DISPLAY_TYPE_VFD)\r\nusb_deregister_dev(interface, &imon_vfd_class);\r\n}\r\n} else {\r\nictx->dev_present_intf1 = false;\r\nusb_kill_urb(ictx->rx_urb_intf1);\r\nif (ictx->display_type == IMON_DISPLAY_TYPE_VGA) {\r\ninput_unregister_device(ictx->touch);\r\ndel_timer_sync(&ictx->ttimer);\r\n}\r\n}\r\nif (!ictx->dev_present_intf0 && !ictx->dev_present_intf1)\r\nfree_imon_context(ictx);\r\nmutex_unlock(&driver_lock);\r\ndev_dbg(dev, "%s: iMON device (intf%d) disconnected\n",\r\n__func__, ifnum);\r\n}\r\nstatic int imon_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct imon_context *ictx = usb_get_intfdata(intf);\r\nint ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nif (ifnum == 0)\r\nusb_kill_urb(ictx->rx_urb_intf0);\r\nelse\r\nusb_kill_urb(ictx->rx_urb_intf1);\r\nreturn 0;\r\n}\r\nstatic int imon_resume(struct usb_interface *intf)\r\n{\r\nint rc = 0;\r\nstruct imon_context *ictx = usb_get_intfdata(intf);\r\nint ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nif (ifnum == 0) {\r\nusb_fill_int_urb(ictx->rx_urb_intf0, ictx->usbdev_intf0,\r\nusb_rcvintpipe(ictx->usbdev_intf0,\r\nictx->rx_endpoint_intf0->bEndpointAddress),\r\nictx->usb_rx_buf, sizeof(ictx->usb_rx_buf),\r\nusb_rx_callback_intf0, ictx,\r\nictx->rx_endpoint_intf0->bInterval);\r\nrc = usb_submit_urb(ictx->rx_urb_intf0, GFP_ATOMIC);\r\n} else {\r\nusb_fill_int_urb(ictx->rx_urb_intf1, ictx->usbdev_intf1,\r\nusb_rcvintpipe(ictx->usbdev_intf1,\r\nictx->rx_endpoint_intf1->bEndpointAddress),\r\nictx->usb_rx_buf, sizeof(ictx->usb_rx_buf),\r\nusb_rx_callback_intf1, ictx,\r\nictx->rx_endpoint_intf1->bInterval);\r\nrc = usb_submit_urb(ictx->rx_urb_intf1, GFP_ATOMIC);\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init imon_init(void)\r\n{\r\nint rc;\r\nrc = usb_register(&imon_driver);\r\nif (rc) {\r\npr_err("usb register failed(%d)\n", rc);\r\nrc = -ENODEV;\r\n}\r\nreturn rc;\r\n}\r\nstatic void __exit imon_exit(void)\r\n{\r\nusb_deregister(&imon_driver);\r\n}
