static inline void w83697hf_unlock(void)\r\n{\r\noutb_p(0x87, W83697HF_EFER);\r\noutb_p(0x87, W83697HF_EFER);\r\n}\r\nstatic inline void w83697hf_lock(void)\r\n{\r\noutb_p(0xAA, W83697HF_EFER);\r\n}\r\nstatic unsigned char w83697hf_get_reg(unsigned char reg)\r\n{\r\noutb_p(reg, W83697HF_EFIR);\r\nreturn inb_p(W83697HF_EFDR);\r\n}\r\nstatic void w83697hf_set_reg(unsigned char reg, unsigned char data)\r\n{\r\noutb_p(reg, W83697HF_EFIR);\r\noutb_p(data, W83697HF_EFDR);\r\n}\r\nstatic void w83697hf_write_timeout(int timeout)\r\n{\r\nw83697hf_set_reg(0xF4, timeout);\r\n}\r\nstatic void w83697hf_select_wdt(void)\r\n{\r\nw83697hf_unlock();\r\nw83697hf_set_reg(0x07, 0x08);\r\n}\r\nstatic inline void w83697hf_deselect_wdt(void)\r\n{\r\nw83697hf_lock();\r\n}\r\nstatic void w83697hf_init(void)\r\n{\r\nunsigned char bbuf;\r\nw83697hf_select_wdt();\r\nbbuf = w83697hf_get_reg(0x29);\r\nbbuf &= ~0x60;\r\nbbuf |= 0x20;\r\nw83697hf_set_reg(0x29, bbuf);\r\nbbuf = w83697hf_get_reg(0xF3);\r\nbbuf &= ~0x04;\r\nw83697hf_set_reg(0xF3, bbuf);\r\nw83697hf_deselect_wdt();\r\n}\r\nstatic void wdt_ping(void)\r\n{\r\nspin_lock(&io_lock);\r\nw83697hf_select_wdt();\r\nw83697hf_write_timeout(timeout);\r\nw83697hf_deselect_wdt();\r\nspin_unlock(&io_lock);\r\n}\r\nstatic void wdt_enable(void)\r\n{\r\nspin_lock(&io_lock);\r\nw83697hf_select_wdt();\r\nw83697hf_write_timeout(timeout);\r\nw83697hf_set_reg(0x30, 1);\r\nw83697hf_deselect_wdt();\r\nspin_unlock(&io_lock);\r\n}\r\nstatic void wdt_disable(void)\r\n{\r\nspin_lock(&io_lock);\r\nw83697hf_select_wdt();\r\nw83697hf_set_reg(0x30, 0);\r\nw83697hf_write_timeout(0);\r\nw83697hf_deselect_wdt();\r\nspin_unlock(&io_lock);\r\n}\r\nstatic unsigned char wdt_running(void)\r\n{\r\nunsigned char t;\r\nspin_lock(&io_lock);\r\nw83697hf_select_wdt();\r\nt = w83697hf_get_reg(0xF4);\r\nw83697hf_deselect_wdt();\r\nspin_unlock(&io_lock);\r\nreturn t;\r\n}\r\nstatic int wdt_set_heartbeat(int t)\r\n{\r\nif (t < 1 || t > 255)\r\nreturn -EINVAL;\r\ntimeout = t;\r\nreturn 0;\r\n}\r\nstatic ssize_t wdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nwdt_ping();\r\n}\r\nreturn count;\r\n}\r\nstatic long wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint new_timeout;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT\r\n| WDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = "W83697HF WDT",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint options, retval = -EINVAL;\r\nif (get_user(options, p))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nwdt_disable();\r\nretval = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nwdt_enable();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nwdt_ping();\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, p))\r\nreturn -EFAULT;\r\nif (wdt_set_heartbeat(new_timeout))\r\nreturn -EINVAL;\r\nwdt_ping();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &wdt_is_open))\r\nreturn -EBUSY;\r\nwdt_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wdt_close(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42)\r\nwdt_disable();\r\nelse {\r\nprintk(KERN_CRIT PFX\r\n"Unexpected close, not stopping watchdog!\n");\r\nwdt_ping();\r\n}\r\nexpect_close = 0;\r\nclear_bit(0, &wdt_is_open);\r\nreturn 0;\r\n}\r\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdt_disable();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int w83697hf_check_wdt(void)\r\n{\r\nif (!request_region(wdt_io, 2, WATCHDOG_NAME)) {\r\nprintk(KERN_ERR PFX\r\n"I/O address 0x%x already in use\n", wdt_io);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_DEBUG PFX\r\n"Looking for watchdog at address 0x%x\n", wdt_io);\r\nw83697hf_unlock();\r\nif (w83697hf_get_reg(0x20) == 0x60) {\r\nprintk(KERN_INFO PFX\r\n"watchdog found at address 0x%x\n", wdt_io);\r\nw83697hf_lock();\r\nreturn 0;\r\n}\r\nw83697hf_lock();\r\nprintk(KERN_INFO PFX "watchdog not found at address 0x%x\n", wdt_io);\r\nrelease_region(wdt_io, 2);\r\nreturn -EIO;\r\n}\r\nstatic int __init wdt_init(void)\r\n{\r\nint ret, i, found = 0;\r\nprintk(KERN_INFO PFX "WDT driver for W83697HF/HG initializing\n");\r\nif (wdt_io == 0) {\r\nfor (i = 0; ((!found) && (w83697hf_ioports[i] != 0)); i++) {\r\nwdt_io = w83697hf_ioports[i];\r\nif (!w83697hf_check_wdt())\r\nfound++;\r\n}\r\n} else {\r\nif (!w83697hf_check_wdt())\r\nfound++;\r\n}\r\nif (!found) {\r\nprintk(KERN_ERR PFX "No W83697HF/HG could be found\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nw83697hf_init();\r\nif (early_disable) {\r\nif (wdt_running())\r\nprintk(KERN_WARNING PFX "Stopping previously enabled "\r\n"watchdog until userland kicks in\n");\r\nwdt_disable();\r\n}\r\nif (wdt_set_heartbeat(timeout)) {\r\nwdt_set_heartbeat(WATCHDOG_TIMEOUT);\r\nprintk(KERN_INFO PFX\r\n"timeout value must be 1 <= timeout <= 255, using %d\n",\r\nWATCHDOG_TIMEOUT);\r\n}\r\nret = register_reboot_notifier(&wdt_notifier);\r\nif (ret != 0) {\r\nprintk(KERN_ERR PFX\r\n"cannot register reboot notifier (err=%d)\n", ret);\r\ngoto unreg_regions;\r\n}\r\nret = misc_register(&wdt_miscdev);\r\nif (ret != 0) {\r\nprintk(KERN_ERR PFX\r\n"cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto unreg_reboot;\r\n}\r\nprintk(KERN_INFO PFX "initialized. timeout=%d sec (nowayout=%d)\n",\r\ntimeout, nowayout);\r\nout:\r\nreturn ret;\r\nunreg_reboot:\r\nunregister_reboot_notifier(&wdt_notifier);\r\nunreg_regions:\r\nrelease_region(wdt_io, 2);\r\ngoto out;\r\n}\r\nstatic void __exit wdt_exit(void)\r\n{\r\nmisc_deregister(&wdt_miscdev);\r\nunregister_reboot_notifier(&wdt_notifier);\r\nrelease_region(wdt_io, 2);\r\n}
