static bool s3fb_ddc_needs_mmio(int chip)\r\n{\r\nreturn !(chip == CHIP_360_TRIO3D_1X ||\r\nchip == CHIP_362_TRIO3D_2X ||\r\nchip == CHIP_368_TRIO3D_2X);\r\n}\r\nstatic u8 s3fb_ddc_read(struct s3fb_info *par)\r\n{\r\nif (s3fb_ddc_needs_mmio(par->chip))\r\nreturn readb(par->mmio + DDC_MMIO_REG);\r\nelse\r\nreturn vga_rcrt(par->state.vgabase, DDC_REG);\r\n}\r\nstatic void s3fb_ddc_write(struct s3fb_info *par, u8 val)\r\n{\r\nif (s3fb_ddc_needs_mmio(par->chip))\r\nwriteb(val, par->mmio + DDC_MMIO_REG);\r\nelse\r\nvga_wcrt(par->state.vgabase, DDC_REG, val);\r\n}\r\nstatic void s3fb_ddc_setscl(void *data, int val)\r\n{\r\nstruct s3fb_info *par = data;\r\nunsigned char reg;\r\nreg = s3fb_ddc_read(par) | DDC_DRIVE_EN;\r\nif (val)\r\nreg |= DDC_SCL_OUT;\r\nelse\r\nreg &= ~DDC_SCL_OUT;\r\ns3fb_ddc_write(par, reg);\r\n}\r\nstatic void s3fb_ddc_setsda(void *data, int val)\r\n{\r\nstruct s3fb_info *par = data;\r\nunsigned char reg;\r\nreg = s3fb_ddc_read(par) | DDC_DRIVE_EN;\r\nif (val)\r\nreg |= DDC_SDA_OUT;\r\nelse\r\nreg &= ~DDC_SDA_OUT;\r\ns3fb_ddc_write(par, reg);\r\n}\r\nstatic int s3fb_ddc_getscl(void *data)\r\n{\r\nstruct s3fb_info *par = data;\r\nreturn !!(s3fb_ddc_read(par) & DDC_SCL_IN);\r\n}\r\nstatic int s3fb_ddc_getsda(void *data)\r\n{\r\nstruct s3fb_info *par = data;\r\nreturn !!(s3fb_ddc_read(par) & DDC_SDA_IN);\r\n}\r\nstatic int __devinit s3fb_setup_ddc_bus(struct fb_info *info)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nstrlcpy(par->ddc_adapter.name, info->fix.id,\r\nsizeof(par->ddc_adapter.name));\r\npar->ddc_adapter.owner = THIS_MODULE;\r\npar->ddc_adapter.class = I2C_CLASS_DDC;\r\npar->ddc_adapter.algo_data = &par->ddc_algo;\r\npar->ddc_adapter.dev.parent = info->device;\r\npar->ddc_algo.setsda = s3fb_ddc_setsda;\r\npar->ddc_algo.setscl = s3fb_ddc_setscl;\r\npar->ddc_algo.getsda = s3fb_ddc_getsda;\r\npar->ddc_algo.getscl = s3fb_ddc_getscl;\r\npar->ddc_algo.udelay = 10;\r\npar->ddc_algo.timeout = 20;\r\npar->ddc_algo.data = par;\r\ni2c_set_adapdata(&par->ddc_adapter, par);\r\nif (par->chip == CHIP_357_VIRGE_GX2 ||\r\npar->chip == CHIP_359_VIRGE_GX2P)\r\nsvga_wseq_mask(par->state.vgabase, 0x0d, 0x01, 0x03);\r\nelse\r\nsvga_wseq_mask(par->state.vgabase, 0x0d, 0x00, 0x03);\r\nsvga_wcrt_mask(par->state.vgabase, 0x5c, 0x03, 0x03);\r\nreturn i2c_bit_add_bus(&par->ddc_adapter);\r\n}\r\nstatic void s3fb_settile_fast(struct fb_info *info, struct fb_tilemap *map)\r\n{\r\nconst u8 *font = map->data;\r\nu8 __iomem *fb = (u8 __iomem *) info->screen_base;\r\nint i, c;\r\nif ((map->width != 8) || (map->height != 16) ||\r\n(map->depth != 1) || (map->length != 256)) {\r\nprintk(KERN_ERR "fb%d: unsupported font parameters: width %d, height %d, depth %d, length %d\n",\r\ninfo->node, map->width, map->height, map->depth, map->length);\r\nreturn;\r\n}\r\nfb += 2;\r\nfor (i = 0; i < map->height; i++) {\r\nfor (c = 0; c < map->length; c++) {\r\nfb_writeb(font[c * map->height + i], fb + c * 4);\r\n}\r\nfb += 1024;\r\n}\r\n}\r\nstatic void s3fb_tilecursor(struct fb_info *info, struct fb_tilecursor *cursor)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nsvga_tilecursor(par->state.vgabase, info, cursor);\r\n}\r\nstatic inline u32 expand_color(u32 c)\r\n{\r\nreturn ((c & 1) | ((c & 2) << 7) | ((c & 4) << 14) | ((c & 8) << 21)) * 0xFF;\r\n}\r\nstatic void s3fb_iplan_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nu32 fg = expand_color(image->fg_color);\r\nu32 bg = expand_color(image->bg_color);\r\nconst u8 *src1, *src;\r\nu8 __iomem *dst1;\r\nu32 __iomem *dst;\r\nu32 val;\r\nint x, y;\r\nsrc1 = image->data;\r\ndst1 = info->screen_base + (image->dy * info->fix.line_length)\r\n+ ((image->dx / 8) * 4);\r\nfor (y = 0; y < image->height; y++) {\r\nsrc = src1;\r\ndst = (u32 __iomem *) dst1;\r\nfor (x = 0; x < image->width; x += 8) {\r\nval = *(src++) * 0x01010101;\r\nval = (val & fg) | (~val & bg);\r\nfb_writel(val, dst++);\r\n}\r\nsrc1 += image->width / 8;\r\ndst1 += info->fix.line_length;\r\n}\r\n}\r\nstatic void s3fb_iplan_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nu32 fg = expand_color(rect->color);\r\nu8 __iomem *dst1;\r\nu32 __iomem *dst;\r\nint x, y;\r\ndst1 = info->screen_base + (rect->dy * info->fix.line_length)\r\n+ ((rect->dx / 8) * 4);\r\nfor (y = 0; y < rect->height; y++) {\r\ndst = (u32 __iomem *) dst1;\r\nfor (x = 0; x < rect->width; x += 8) {\r\nfb_writel(fg, dst++);\r\n}\r\ndst1 += info->fix.line_length;\r\n}\r\n}\r\nstatic inline u32 expand_pixel(u32 c)\r\n{\r\nreturn (((c & 1) << 24) | ((c & 2) << 27) | ((c & 4) << 14) | ((c & 8) << 17) |\r\n((c & 16) << 4) | ((c & 32) << 7) | ((c & 64) >> 6) | ((c & 128) >> 3)) * 0xF;\r\n}\r\nstatic void s3fb_cfb4_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nu32 fg = image->fg_color * 0x11111111;\r\nu32 bg = image->bg_color * 0x11111111;\r\nconst u8 *src1, *src;\r\nu8 __iomem *dst1;\r\nu32 __iomem *dst;\r\nu32 val;\r\nint x, y;\r\nsrc1 = image->data;\r\ndst1 = info->screen_base + (image->dy * info->fix.line_length)\r\n+ ((image->dx / 8) * 4);\r\nfor (y = 0; y < image->height; y++) {\r\nsrc = src1;\r\ndst = (u32 __iomem *) dst1;\r\nfor (x = 0; x < image->width; x += 8) {\r\nval = expand_pixel(*(src++));\r\nval = (val & fg) | (~val & bg);\r\nfb_writel(val, dst++);\r\n}\r\nsrc1 += image->width / 8;\r\ndst1 += info->fix.line_length;\r\n}\r\n}\r\nstatic void s3fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nif ((info->var.bits_per_pixel == 4) && (image->depth == 1)\r\n&& ((image->width % 8) == 0) && ((image->dx % 8) == 0)) {\r\nif (info->fix.type == FB_TYPE_INTERLEAVED_PLANES)\r\ns3fb_iplan_imageblit(info, image);\r\nelse\r\ns3fb_cfb4_imageblit(info, image);\r\n} else\r\ncfb_imageblit(info, image);\r\n}\r\nstatic void s3fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nif ((info->var.bits_per_pixel == 4)\r\n&& ((rect->width % 8) == 0) && ((rect->dx % 8) == 0)\r\n&& (info->fix.type == FB_TYPE_INTERLEAVED_PLANES))\r\ns3fb_iplan_fillrect(info, rect);\r\nelse\r\ncfb_fillrect(info, rect);\r\n}\r\nstatic void s3_set_pixclock(struct fb_info *info, u32 pixclock)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nu16 m, n, r;\r\nu8 regval;\r\nint rv;\r\nrv = svga_compute_pll((par->chip == CHIP_365_TRIO3D) ? &s3_trio3d_pll : &s3_pll,\r\n1000000000 / pixclock, &m, &n, &r, info->node);\r\nif (rv < 0) {\r\nprintk(KERN_ERR "fb%d: cannot set requested pixclock, keeping old value\n", info->node);\r\nreturn;\r\n}\r\nregval = vga_r(par->state.vgabase, VGA_MIS_R);\r\nvga_w(par->state.vgabase, VGA_MIS_W, regval | VGA_MIS_ENB_PLL_LOAD);\r\nif (par->chip == CHIP_357_VIRGE_GX2 ||\r\npar->chip == CHIP_359_VIRGE_GX2P ||\r\npar->chip == CHIP_360_TRIO3D_1X ||\r\npar->chip == CHIP_362_TRIO3D_2X ||\r\npar->chip == CHIP_368_TRIO3D_2X) {\r\nvga_wseq(par->state.vgabase, 0x12, (n - 2) | ((r & 3) << 6));\r\nvga_wseq(par->state.vgabase, 0x29, r >> 2);\r\n} else\r\nvga_wseq(par->state.vgabase, 0x12, (n - 2) | (r << 5));\r\nvga_wseq(par->state.vgabase, 0x13, m - 2);\r\nudelay(1000);\r\nregval = vga_rseq (par->state.vgabase, 0x15);\r\nvga_wseq(par->state.vgabase, 0x15, regval & ~(1<<5));\r\nvga_wseq(par->state.vgabase, 0x15, regval | (1<<5));\r\nvga_wseq(par->state.vgabase, 0x15, regval & ~(1<<5));\r\n}\r\nstatic int s3fb_open(struct fb_info *info, int user)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nmutex_lock(&(par->open_lock));\r\nif (par->ref_count == 0) {\r\nvoid __iomem *vgabase = par->state.vgabase;\r\nmemset(&(par->state), 0, sizeof(struct vgastate));\r\npar->state.vgabase = vgabase;\r\npar->state.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS | VGA_SAVE_CMAP;\r\npar->state.num_crtc = 0x70;\r\npar->state.num_seq = 0x20;\r\nsave_vga(&(par->state));\r\n}\r\npar->ref_count++;\r\nmutex_unlock(&(par->open_lock));\r\nreturn 0;\r\n}\r\nstatic int s3fb_release(struct fb_info *info, int user)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nmutex_lock(&(par->open_lock));\r\nif (par->ref_count == 0) {\r\nmutex_unlock(&(par->open_lock));\r\nreturn -EINVAL;\r\n}\r\nif (par->ref_count == 1)\r\nrestore_vga(&(par->state));\r\npar->ref_count--;\r\nmutex_unlock(&(par->open_lock));\r\nreturn 0;\r\n}\r\nstatic int s3fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nint rv, mem, step;\r\nu16 m, n, r;\r\nrv = svga_match_format (s3fb_formats, var, NULL);\r\nif ((par->chip == CHIP_988_VIRGE_VX) ? (rv == 7) : (rv == 6))\r\nrv = -EINVAL;\r\nif (rv < 0) {\r\nprintk(KERN_ERR "fb%d: unsupported mode requested\n", info->node);\r\nreturn rv;\r\n}\r\nif (var->xres > var->xres_virtual)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres_virtual = var->yres;\r\nstep = s3fb_formats[rv].xresstep - 1;\r\nvar->xres_virtual = (var->xres_virtual+step) & ~step;\r\nmem = ((var->bits_per_pixel * var->xres_virtual) >> 3) * var->yres_virtual;\r\nif (mem > info->screen_size) {\r\nprintk(KERN_ERR "fb%d: not enough framebuffer memory (%d kB requested , %d kB available)\n",\r\ninfo->node, mem >> 10, (unsigned int) (info->screen_size >> 10));\r\nreturn -EINVAL;\r\n}\r\nrv = svga_check_timings (&s3_timing_regs, var, info->node);\r\nif (rv < 0) {\r\nprintk(KERN_ERR "fb%d: invalid timings requested\n", info->node);\r\nreturn rv;\r\n}\r\nrv = svga_compute_pll(&s3_pll, PICOS2KHZ(var->pixclock), &m, &n, &r,\r\ninfo->node);\r\nif (rv < 0) {\r\nprintk(KERN_ERR "fb%d: invalid pixclock value requested\n",\r\ninfo->node);\r\nreturn rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3fb_set_par(struct fb_info *info)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nu32 value, mode, hmul, offset_value, screen_size, multiplex, dbytes;\r\nu32 bpp = info->var.bits_per_pixel;\r\nu32 htotal, hsstart;\r\nif (bpp != 0) {\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.line_length = (info->var.xres_virtual * bpp) / 8;\r\ninfo->flags &= ~FBINFO_MISC_TILEBLITTING;\r\ninfo->tileops = NULL;\r\ninfo->pixmap.blit_x = (bpp == 4) ? (1 << (8 - 1)) : (~(u32)0);\r\ninfo->pixmap.blit_y = ~(u32)0;\r\noffset_value = (info->var.xres_virtual * bpp) / 64;\r\nscreen_size = info->var.yres_virtual * info->fix.line_length;\r\n} else {\r\ninfo->fix.ypanstep = 16;\r\ninfo->fix.line_length = 0;\r\ninfo->flags |= FBINFO_MISC_TILEBLITTING;\r\ninfo->tileops = fasttext ? &s3fb_fast_tile_ops : &s3fb_tile_ops;\r\ninfo->pixmap.blit_x = 1 << (8 - 1);\r\ninfo->pixmap.blit_y = 1 << (16 - 1);\r\noffset_value = info->var.xres_virtual / 16;\r\nscreen_size = (info->var.xres_virtual * info->var.yres_virtual) / 64;\r\n}\r\ninfo->var.xoffset = 0;\r\ninfo->var.yoffset = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\nvga_wcrt(par->state.vgabase, 0x38, 0x48);\r\nvga_wcrt(par->state.vgabase, 0x39, 0xA5);\r\nvga_wseq(par->state.vgabase, 0x08, 0x06);\r\nsvga_wcrt_mask(par->state.vgabase, 0x11, 0x00, 0x80);\r\nsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\r\nsvga_wcrt_mask(par->state.vgabase, 0x17, 0x00, 0x80);\r\nsvga_set_default_gfx_regs(par->state.vgabase);\r\nsvga_set_default_atc_regs(par->state.vgabase);\r\nsvga_set_default_seq_regs(par->state.vgabase);\r\nsvga_set_default_crt_regs(par->state.vgabase);\r\nsvga_wcrt_multi(par->state.vgabase, s3_line_compare_regs, 0xFFFFFFFF);\r\nsvga_wcrt_multi(par->state.vgabase, s3_start_address_regs, 0);\r\nsvga_wcrt_mask(par->state.vgabase, 0x58, 0x10, 0x10);\r\nsvga_wcrt_mask(par->state.vgabase, 0x31, 0x08, 0x08);\r\nsvga_wcrt_mask(par->state.vgabase, 0x33, 0x00, 0x08);\r\nsvga_wcrt_mask(par->state.vgabase, 0x43, 0x00, 0x01);\r\nsvga_wcrt_mask(par->state.vgabase, 0x5D, 0x00, 0x28);\r\npr_debug("fb%d: offset register : %d\n", info->node, offset_value);\r\nsvga_wcrt_multi(par->state.vgabase, s3_offset_regs, offset_value);\r\nif (par->chip != CHIP_357_VIRGE_GX2 &&\r\npar->chip != CHIP_359_VIRGE_GX2P &&\r\npar->chip != CHIP_360_TRIO3D_1X &&\r\npar->chip != CHIP_362_TRIO3D_2X &&\r\npar->chip != CHIP_368_TRIO3D_2X) {\r\nvga_wcrt(par->state.vgabase, 0x54, 0x18);\r\nvga_wcrt(par->state.vgabase, 0x60, 0xff);\r\nvga_wcrt(par->state.vgabase, 0x61, 0xff);\r\nvga_wcrt(par->state.vgabase, 0x62, 0xff);\r\n}\r\nvga_wcrt(par->state.vgabase, 0x3A, 0x35);\r\nsvga_wattr(par->state.vgabase, 0x33, 0x00);\r\nif (info->var.vmode & FB_VMODE_DOUBLE)\r\nsvga_wcrt_mask(par->state.vgabase, 0x09, 0x80, 0x80);\r\nelse\r\nsvga_wcrt_mask(par->state.vgabase, 0x09, 0x00, 0x80);\r\nif (info->var.vmode & FB_VMODE_INTERLACED)\r\nsvga_wcrt_mask(par->state.vgabase, 0x42, 0x20, 0x20);\r\nelse\r\nsvga_wcrt_mask(par->state.vgabase, 0x42, 0x00, 0x20);\r\nsvga_wcrt_mask(par->state.vgabase, 0x45, 0x00, 0x01);\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0x0C);\r\nmode = svga_match_format(s3fb_formats, &(info->var), &(info->fix));\r\nif (par->chip == CHIP_375_VIRGE_DX) {\r\nvga_wcrt(par->state.vgabase, 0x86, 0x80);\r\nvga_wcrt(par->state.vgabase, 0x90, 0x00);\r\n}\r\nif (par->chip == CHIP_988_VIRGE_VX) {\r\nvga_wcrt(par->state.vgabase, 0x50, 0x00);\r\nvga_wcrt(par->state.vgabase, 0x67, 0x50);\r\nvga_wcrt(par->state.vgabase, 0x63, (mode <= 2) ? 0x90 : 0x09);\r\nvga_wcrt(par->state.vgabase, 0x66, 0x90);\r\n}\r\nif (par->chip == CHIP_357_VIRGE_GX2 ||\r\npar->chip == CHIP_359_VIRGE_GX2P ||\r\npar->chip == CHIP_360_TRIO3D_1X ||\r\npar->chip == CHIP_362_TRIO3D_2X ||\r\npar->chip == CHIP_368_TRIO3D_2X ||\r\npar->chip == CHIP_365_TRIO3D ||\r\npar->chip == CHIP_375_VIRGE_DX ||\r\npar->chip == CHIP_385_VIRGE_GX) {\r\ndbytes = info->var.xres * ((bpp+7)/8);\r\nvga_wcrt(par->state.vgabase, 0x91, (dbytes + 7) / 8);\r\nvga_wcrt(par->state.vgabase, 0x90, (((dbytes + 7) / 8) >> 8) | 0x80);\r\nvga_wcrt(par->state.vgabase, 0x66, 0x81);\r\n}\r\nif (par->chip == CHIP_357_VIRGE_GX2 ||\r\npar->chip == CHIP_359_VIRGE_GX2P ||\r\npar->chip == CHIP_360_TRIO3D_1X ||\r\npar->chip == CHIP_362_TRIO3D_2X ||\r\npar->chip == CHIP_368_TRIO3D_2X)\r\nvga_wcrt(par->state.vgabase, 0x34, 0x00);\r\nelse\r\nvga_wcrt(par->state.vgabase, 0x34, 0x10);\r\nsvga_wcrt_mask(par->state.vgabase, 0x31, 0x00, 0x40);\r\nmultiplex = 0;\r\nhmul = 1;\r\nswitch (mode) {\r\ncase 0:\r\npr_debug("fb%d: text mode\n", info->node);\r\nsvga_set_textmode_vga_regs(par->state.vgabase);\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0xF0);\r\nsvga_wcrt_mask(par->state.vgabase, 0x3A, 0x00, 0x30);\r\nif (fasttext) {\r\npr_debug("fb%d: high speed text mode set\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x31, 0x40, 0x40);\r\n}\r\nbreak;\r\ncase 1:\r\npr_debug("fb%d: 4 bit pseudocolor\n", info->node);\r\nvga_wgfx(par->state.vgabase, VGA_GFX_MODE, 0x40);\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0xF0);\r\nsvga_wcrt_mask(par->state.vgabase, 0x3A, 0x00, 0x30);\r\nbreak;\r\ncase 2:\r\npr_debug("fb%d: 4 bit pseudocolor, planar\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0xF0);\r\nsvga_wcrt_mask(par->state.vgabase, 0x3A, 0x00, 0x30);\r\nbreak;\r\ncase 3:\r\npr_debug("fb%d: 8 bit pseudocolor\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);\r\nif (info->var.pixclock > 20000 ||\r\npar->chip == CHIP_357_VIRGE_GX2 ||\r\npar->chip == CHIP_359_VIRGE_GX2P ||\r\npar->chip == CHIP_360_TRIO3D_1X ||\r\npar->chip == CHIP_362_TRIO3D_2X ||\r\npar->chip == CHIP_368_TRIO3D_2X)\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x00, 0xF0);\r\nelse {\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x10, 0xF0);\r\nmultiplex = 1;\r\n}\r\nbreak;\r\ncase 4:\r\npr_debug("fb%d: 5/5/5 truecolor\n", info->node);\r\nif (par->chip == CHIP_988_VIRGE_VX) {\r\nif (info->var.pixclock > 20000)\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x20, 0xF0);\r\nelse\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x30, 0xF0);\r\n} else if (par->chip == CHIP_365_TRIO3D) {\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);\r\nif (info->var.pixclock > 8695) {\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x30, 0xF0);\r\nhmul = 2;\r\n} else {\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x20, 0xF0);\r\nmultiplex = 1;\r\n}\r\n} else {\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x30, 0xF0);\r\nif (par->chip != CHIP_357_VIRGE_GX2 &&\r\npar->chip != CHIP_359_VIRGE_GX2P &&\r\npar->chip != CHIP_360_TRIO3D_1X &&\r\npar->chip != CHIP_362_TRIO3D_2X &&\r\npar->chip != CHIP_368_TRIO3D_2X)\r\nhmul = 2;\r\n}\r\nbreak;\r\ncase 5:\r\npr_debug("fb%d: 5/6/5 truecolor\n", info->node);\r\nif (par->chip == CHIP_988_VIRGE_VX) {\r\nif (info->var.pixclock > 20000)\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x40, 0xF0);\r\nelse\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x50, 0xF0);\r\n} else if (par->chip == CHIP_365_TRIO3D) {\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);\r\nif (info->var.pixclock > 8695) {\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x50, 0xF0);\r\nhmul = 2;\r\n} else {\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x40, 0xF0);\r\nmultiplex = 1;\r\n}\r\n} else {\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0x50, 0xF0);\r\nif (par->chip != CHIP_357_VIRGE_GX2 &&\r\npar->chip != CHIP_359_VIRGE_GX2P &&\r\npar->chip != CHIP_360_TRIO3D_1X &&\r\npar->chip != CHIP_362_TRIO3D_2X &&\r\npar->chip != CHIP_368_TRIO3D_2X)\r\nhmul = 2;\r\n}\r\nbreak;\r\ncase 6:\r\npr_debug("fb%d: 8/8/8 truecolor\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0xD0, 0xF0);\r\nbreak;\r\ncase 7:\r\npr_debug("fb%d: 8/8/8/8 truecolor\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x50, 0x30, 0x30);\r\nsvga_wcrt_mask(par->state.vgabase, 0x67, 0xD0, 0xF0);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "fb%d: unsupported mode - bug\n", info->node);\r\nreturn -EINVAL;\r\n}\r\nif (par->chip != CHIP_988_VIRGE_VX) {\r\nsvga_wseq_mask(par->state.vgabase, 0x15, multiplex ? 0x10 : 0x00, 0x10);\r\nsvga_wseq_mask(par->state.vgabase, 0x18, multiplex ? 0x80 : 0x00, 0x80);\r\n}\r\ns3_set_pixclock(info, info->var.pixclock);\r\nsvga_set_timings(par->state.vgabase, &s3_timing_regs, &(info->var), hmul, 1,\r\n(info->var.vmode & FB_VMODE_DOUBLE) ? 2 : 1,\r\n(info->var.vmode & FB_VMODE_INTERLACED) ? 2 : 1,\r\nhmul, info->node);\r\nhtotal = info->var.xres + info->var.left_margin + info->var.right_margin + info->var.hsync_len;\r\nhtotal = ((htotal * hmul) / 8) - 5;\r\nvga_wcrt(par->state.vgabase, 0x3C, (htotal + 1) / 2);\r\nhsstart = ((info->var.xres + info->var.right_margin) * hmul) / 8;\r\nvalue = clamp((htotal + hsstart + 1) / 2, hsstart + 4, htotal + 1);\r\nsvga_wcrt_multi(par->state.vgabase, s3_dtpc_regs, value);\r\nmemset_io(info->screen_base, 0x00, screen_size);\r\nsvga_wcrt_mask(par->state.vgabase, 0x17, 0x80, 0x80);\r\nsvga_wseq_mask(par->state.vgabase, 0x01, 0x00, 0x20);\r\nreturn 0;\r\n}\r\nstatic int s3fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *fb)\r\n{\r\nswitch (fb->var.bits_per_pixel) {\r\ncase 0:\r\ncase 4:\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nif ((fb->var.bits_per_pixel == 4) &&\r\n(fb->var.nonstd == 0)) {\r\noutb(0xF0, VGA_PEL_MSK);\r\noutb(regno*16, VGA_PEL_IW);\r\n} else {\r\noutb(0x0F, VGA_PEL_MSK);\r\noutb(regno, VGA_PEL_IW);\r\n}\r\noutb(red >> 10, VGA_PEL_D);\r\noutb(green >> 10, VGA_PEL_D);\r\noutb(blue >> 10, VGA_PEL_D);\r\nbreak;\r\ncase 8:\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\noutb(0xFF, VGA_PEL_MSK);\r\noutb(regno, VGA_PEL_IW);\r\noutb(red >> 10, VGA_PEL_D);\r\noutb(green >> 10, VGA_PEL_D);\r\noutb(blue >> 10, VGA_PEL_D);\r\nbreak;\r\ncase 16:\r\nif (regno >= 16)\r\nreturn 0;\r\nif (fb->var.green.length == 5)\r\n((u32*)fb->pseudo_palette)[regno] = ((red & 0xF800) >> 1) |\r\n((green & 0xF800) >> 6) | ((blue & 0xF800) >> 11);\r\nelse if (fb->var.green.length == 6)\r\n((u32*)fb->pseudo_palette)[regno] = (red & 0xF800) |\r\n((green & 0xFC00) >> 5) | ((blue & 0xF800) >> 11);\r\nelse return -EINVAL;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nif (regno >= 16)\r\nreturn 0;\r\n((u32*)fb->pseudo_palette)[regno] = ((red & 0xFF00) << 8) |\r\n(green & 0xFF00) | ((blue & 0xFF00) >> 8);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\npr_debug("fb%d: unblank\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x56, 0x00, 0x06);\r\nsvga_wseq_mask(par->state.vgabase, 0x01, 0x00, 0x20);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\npr_debug("fb%d: blank\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x56, 0x00, 0x06);\r\nsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\npr_debug("fb%d: hsync\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x56, 0x02, 0x06);\r\nsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\npr_debug("fb%d: vsync\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x56, 0x04, 0x06);\r\nsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\npr_debug("fb%d: sync down\n", info->node);\r\nsvga_wcrt_mask(par->state.vgabase, 0x56, 0x06, 0x06);\r\nsvga_wseq_mask(par->state.vgabase, 0x01, 0x20, 0x20);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct s3fb_info *par = info->par;\r\nunsigned int offset;\r\nif (var->bits_per_pixel == 0) {\r\noffset = (var->yoffset / 16) * (var->xres_virtual / 2) + (var->xoffset / 2);\r\noffset = offset >> 2;\r\n} else {\r\noffset = (var->yoffset * info->fix.line_length) +\r\n(var->xoffset * var->bits_per_pixel / 8);\r\noffset = offset >> 2;\r\n}\r\nsvga_wcrt_multi(par->state.vgabase, s3_start_address_regs, offset);\r\nreturn 0;\r\n}\r\nstatic int __devinit s3_identification(struct s3fb_info *par)\r\n{\r\nint chip = par->chip;\r\nif (chip == CHIP_XXX_TRIO) {\r\nu8 cr30 = vga_rcrt(par->state.vgabase, 0x30);\r\nu8 cr2e = vga_rcrt(par->state.vgabase, 0x2e);\r\nu8 cr2f = vga_rcrt(par->state.vgabase, 0x2f);\r\nif ((cr30 == 0xE0) || (cr30 == 0xE1)) {\r\nif (cr2e == 0x10)\r\nreturn CHIP_732_TRIO32;\r\nif (cr2e == 0x11) {\r\nif (! (cr2f & 0x40))\r\nreturn CHIP_764_TRIO64;\r\nelse\r\nreturn CHIP_765_TRIO64VP;\r\n}\r\n}\r\n}\r\nif (chip == CHIP_XXX_TRIO64V2_DXGX) {\r\nu8 cr6f = vga_rcrt(par->state.vgabase, 0x6f);\r\nif (! (cr6f & 0x01))\r\nreturn CHIP_775_TRIO64V2_DX;\r\nelse\r\nreturn CHIP_785_TRIO64V2_GX;\r\n}\r\nif (chip == CHIP_XXX_VIRGE_DXGX) {\r\nu8 cr6f = vga_rcrt(par->state.vgabase, 0x6f);\r\nif (! (cr6f & 0x01))\r\nreturn CHIP_375_VIRGE_DX;\r\nelse\r\nreturn CHIP_385_VIRGE_GX;\r\n}\r\nif (chip == CHIP_36X_TRIO3D_1X_2X) {\r\nswitch (vga_rcrt(par->state.vgabase, 0x2f)) {\r\ncase 0x00:\r\nreturn CHIP_360_TRIO3D_1X;\r\ncase 0x01:\r\nreturn CHIP_362_TRIO3D_2X;\r\ncase 0x02:\r\nreturn CHIP_368_TRIO3D_2X;\r\n}\r\n}\r\nreturn CHIP_UNKNOWN;\r\n}\r\nstatic int __devinit s3_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct pci_bus_region bus_reg;\r\nstruct resource vga_res;\r\nstruct fb_info *info;\r\nstruct s3fb_info *par;\r\nint rc;\r\nu8 regval, cr38, cr39;\r\nbool found = false;\r\nif (! svga_primary_device(dev)) {\r\ndev_info(&(dev->dev), "ignoring secondary device\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct s3fb_info), &(dev->dev));\r\nif (!info) {\r\ndev_err(&(dev->dev), "cannot allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\nmutex_init(&par->open_lock);\r\ninfo->flags = FBINFO_PARTIAL_PAN_OK | FBINFO_HWACCEL_YPAN;\r\ninfo->fbops = &s3fb_ops;\r\nrc = pci_enable_device(dev);\r\nif (rc < 0) {\r\ndev_err(info->device, "cannot enable PCI device\n");\r\ngoto err_enable_device;\r\n}\r\nrc = pci_request_regions(dev, "s3fb");\r\nif (rc < 0) {\r\ndev_err(info->device, "cannot reserve framebuffer region\n");\r\ngoto err_request_regions;\r\n}\r\ninfo->fix.smem_start = pci_resource_start(dev, 0);\r\ninfo->fix.smem_len = pci_resource_len(dev, 0);\r\ninfo->screen_base = pci_iomap(dev, 0, 0);\r\nif (! info->screen_base) {\r\nrc = -ENOMEM;\r\ndev_err(info->device, "iomap for framebuffer failed\n");\r\ngoto err_iomap;\r\n}\r\nbus_reg.start = 0;\r\nbus_reg.end = 64 * 1024;\r\nvga_res.flags = IORESOURCE_IO;\r\npcibios_bus_to_resource(dev, &vga_res, &bus_reg);\r\npar->state.vgabase = (void __iomem *) vga_res.start;\r\ncr38 = vga_rcrt(par->state.vgabase, 0x38);\r\ncr39 = vga_rcrt(par->state.vgabase, 0x39);\r\nvga_wseq(par->state.vgabase, 0x08, 0x06);\r\nvga_wcrt(par->state.vgabase, 0x38, 0x48);\r\nvga_wcrt(par->state.vgabase, 0x39, 0xA5);\r\npar->chip = id->driver_data & CHIP_MASK;\r\npar->rev = vga_rcrt(par->state.vgabase, 0x2f);\r\nif (par->chip & CHIP_UNDECIDED_FLAG)\r\npar->chip = s3_identification(par);\r\nregval = vga_rcrt(par->state.vgabase, 0x36);\r\nif (par->chip == CHIP_360_TRIO3D_1X ||\r\npar->chip == CHIP_362_TRIO3D_2X ||\r\npar->chip == CHIP_368_TRIO3D_2X ||\r\npar->chip == CHIP_365_TRIO3D) {\r\nswitch ((regval & 0xE0) >> 5) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ninfo->screen_size = 4 << 20;\r\nbreak;\r\ncase 4:\r\ncase 6:\r\ninfo->screen_size = 2 << 20;\r\nbreak;\r\n}\r\n} else if (par->chip == CHIP_357_VIRGE_GX2 ||\r\npar->chip == CHIP_359_VIRGE_GX2P) {\r\nswitch ((regval & 0xC0) >> 6) {\r\ncase 1:\r\ninfo->screen_size = 4 << 20;\r\nbreak;\r\ncase 3:\r\ninfo->screen_size = 2 << 20;\r\nbreak;\r\n}\r\n} else\r\ninfo->screen_size = s3_memsizes[regval >> 5] << 10;\r\ninfo->fix.smem_len = info->screen_size;\r\nregval = vga_rseq(par->state.vgabase, 0x10);\r\npar->mclk_freq = ((vga_rseq(par->state.vgabase, 0x11) + 2) * 14318) / ((regval & 0x1F) + 2);\r\npar->mclk_freq = par->mclk_freq >> (regval >> 5);\r\nvga_wcrt(par->state.vgabase, 0x38, cr38);\r\nvga_wcrt(par->state.vgabase, 0x39, cr39);\r\nstrcpy(info->fix.id, s3_names [par->chip]);\r\ninfo->fix.mmio_start = 0;\r\ninfo->fix.mmio_len = 0;\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->pseudo_palette = (void*) (par->pseudo_palette);\r\ninfo->var.bits_per_pixel = 8;\r\n#ifdef CONFIG_FB_S3_DDC\r\nif (s3fb_ddc_needs_mmio(par->chip)) {\r\npar->mmio = ioremap(info->fix.smem_start + MMIO_OFFSET, MMIO_SIZE);\r\nif (par->mmio)\r\nsvga_wcrt_mask(par->state.vgabase, 0x53, 0x08, 0x08);\r\nelse\r\ndev_err(info->device, "unable to map MMIO at 0x%lx, disabling DDC",\r\ninfo->fix.smem_start + MMIO_OFFSET);\r\n}\r\nif (!s3fb_ddc_needs_mmio(par->chip) || par->mmio)\r\nif (s3fb_setup_ddc_bus(info) == 0) {\r\nu8 *edid = fb_ddc_read(&par->ddc_adapter);\r\npar->ddc_registered = true;\r\nif (edid) {\r\nfb_edid_to_monspecs(edid, &info->monspecs);\r\nkfree(edid);\r\nif (!info->monspecs.modedb)\r\ndev_err(info->device, "error getting mode database\n");\r\nelse {\r\nconst struct fb_videomode *m;\r\nfb_videomode_to_modelist(info->monspecs.modedb,\r\ninfo->monspecs.modedb_len,\r\n&info->modelist);\r\nm = fb_find_best_display(&info->monspecs, &info->modelist);\r\nif (m) {\r\nfb_videomode_to_var(&info->var, m);\r\nif (s3fb_check_var(&info->var, info) == 0)\r\nfound = true;\r\n}\r\n}\r\n}\r\n}\r\n#endif\r\nif (!mode_option && !found)\r\nmode_option = "640x480-8@60";\r\nif (mode_option) {\r\nrc = fb_find_mode(&info->var, info, mode_option,\r\ninfo->monspecs.modedb, info->monspecs.modedb_len,\r\nNULL, info->var.bits_per_pixel);\r\nif (!rc || rc == 4) {\r\nrc = -EINVAL;\r\ndev_err(info->device, "mode %s not found\n", mode_option);\r\nfb_destroy_modedb(info->monspecs.modedb);\r\ninfo->monspecs.modedb = NULL;\r\ngoto err_find_mode;\r\n}\r\n}\r\nfb_destroy_modedb(info->monspecs.modedb);\r\ninfo->monspecs.modedb = NULL;\r\ninfo->var.yres_virtual = info->fix.smem_len * 8 /\r\n(info->var.bits_per_pixel * info->var.xres_virtual);\r\nif (info->var.yres_virtual < info->var.yres) {\r\ndev_err(info->device, "virtual vertical size smaller than real\n");\r\ngoto err_find_mode;\r\n}\r\ninfo->var.yres_virtual = info->fix.smem_len * 8 /\r\n(info->var.bits_per_pixel * info->var.xres_virtual);\r\nif (info->var.yres_virtual < info->var.yres) {\r\ndev_err(info->device, "virtual vertical size smaller than real\n");\r\ngoto err_find_mode;\r\n}\r\nrc = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (rc < 0) {\r\ndev_err(info->device, "cannot allocate colormap\n");\r\ngoto err_alloc_cmap;\r\n}\r\nrc = register_framebuffer(info);\r\nif (rc < 0) {\r\ndev_err(info->device, "cannot register framebuffer\n");\r\ngoto err_reg_fb;\r\n}\r\nprintk(KERN_INFO "fb%d: %s on %s, %d MB RAM, %d MHz MCLK\n", info->node, info->fix.id,\r\npci_name(dev), info->fix.smem_len >> 20, (par->mclk_freq + 500) / 1000);\r\nif (par->chip == CHIP_UNKNOWN)\r\nprintk(KERN_INFO "fb%d: unknown chip, CR2D=%x, CR2E=%x, CRT2F=%x, CRT30=%x\n",\r\ninfo->node, vga_rcrt(par->state.vgabase, 0x2d), vga_rcrt(par->state.vgabase, 0x2e),\r\nvga_rcrt(par->state.vgabase, 0x2f), vga_rcrt(par->state.vgabase, 0x30));\r\npci_set_drvdata(dev, info);\r\n#ifdef CONFIG_MTRR\r\nif (mtrr) {\r\npar->mtrr_reg = -1;\r\npar->mtrr_reg = mtrr_add(info->fix.smem_start, info->fix.smem_len, MTRR_TYPE_WRCOMB, 1);\r\n}\r\n#endif\r\nreturn 0;\r\nerr_reg_fb:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_alloc_cmap:\r\nerr_find_mode:\r\n#ifdef CONFIG_FB_S3_DDC\r\nif (par->ddc_registered)\r\ni2c_del_adapter(&par->ddc_adapter);\r\nif (par->mmio)\r\niounmap(par->mmio);\r\n#endif\r\npci_iounmap(dev, info->screen_base);\r\nerr_iomap:\r\npci_release_regions(dev);\r\nerr_request_regions:\r\nerr_enable_device:\r\nframebuffer_release(info);\r\nreturn rc;\r\n}\r\nstatic void __devexit s3_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct s3fb_info __maybe_unused *par = info->par;\r\nif (info) {\r\n#ifdef CONFIG_MTRR\r\nif (par->mtrr_reg >= 0) {\r\nmtrr_del(par->mtrr_reg, 0, 0);\r\npar->mtrr_reg = -1;\r\n}\r\n#endif\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\n#ifdef CONFIG_FB_S3_DDC\r\nif (par->ddc_registered)\r\ni2c_del_adapter(&par->ddc_adapter);\r\nif (par->mmio)\r\niounmap(par->mmio);\r\n#endif\r\npci_iounmap(dev, info->screen_base);\r\npci_release_regions(dev);\r\npci_set_drvdata(dev, NULL);\r\nframebuffer_release(info);\r\n}\r\n}\r\nstatic int s3_pci_suspend(struct pci_dev* dev, pm_message_t state)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct s3fb_info *par = info->par;\r\ndev_info(info->device, "suspend\n");\r\nconsole_lock();\r\nmutex_lock(&(par->open_lock));\r\nif ((state.event == PM_EVENT_FREEZE) || (par->ref_count == 0)) {\r\nmutex_unlock(&(par->open_lock));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nfb_set_suspend(info, 1);\r\npci_save_state(dev);\r\npci_disable_device(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, state));\r\nmutex_unlock(&(par->open_lock));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int s3_pci_resume(struct pci_dev* dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct s3fb_info *par = info->par;\r\nint err;\r\ndev_info(info->device, "resume\n");\r\nconsole_lock();\r\nmutex_lock(&(par->open_lock));\r\nif (par->ref_count == 0) {\r\nmutex_unlock(&(par->open_lock));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nerr = pci_enable_device(dev);\r\nif (err) {\r\nmutex_unlock(&(par->open_lock));\r\nconsole_unlock();\r\ndev_err(info->device, "error %d enabling device for resume\n", err);\r\nreturn err;\r\n}\r\npci_set_master(dev);\r\ns3fb_set_par(info);\r\nfb_set_suspend(info, 0);\r\nmutex_unlock(&(par->open_lock));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int __init s3fb_setup(char *options)\r\n{\r\nchar *opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\n#ifdef CONFIG_MTRR\r\nelse if (!strncmp(opt, "mtrr:", 5))\r\nmtrr = simple_strtoul(opt + 5, NULL, 0);\r\n#endif\r\nelse if (!strncmp(opt, "fasttext:", 9))\r\nfasttext = simple_strtoul(opt + 9, NULL, 0);\r\nelse\r\nmode_option = opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit s3fb_cleanup(void)\r\n{\r\npr_debug("s3fb: cleaning up\n");\r\npci_unregister_driver(&s3fb_pci_driver);\r\n}\r\nstatic int __init s3fb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("s3fb", &option))\r\nreturn -ENODEV;\r\ns3fb_setup(option);\r\n#endif\r\npr_debug("s3fb: initializing\n");\r\nreturn pci_register_driver(&s3fb_pci_driver);\r\n}
