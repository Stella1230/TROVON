static void DoRecvCompletion(struct htc_endpoint *pEndpoint,\r\nstruct htc_packet_queue *pQueueToIndicate)\r\n{\r\ndo {\r\nif (HTC_QUEUE_EMPTY(pQueueToIndicate)) {\r\nbreak;\r\n}\r\nif (pEndpoint->EpCallBacks.EpRecvPktMultiple != NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, (" HTC calling ep %d, recv multiple callback (%d pkts) \n",\r\npEndpoint->Id, HTC_PACKET_QUEUE_DEPTH(pQueueToIndicate)));\r\npEndpoint->EpCallBacks.EpRecvPktMultiple(pEndpoint->EpCallBacks.pContext,\r\npQueueToIndicate);\r\nINIT_HTC_PACKET_QUEUE(pQueueToIndicate);\r\n} else {\r\nstruct htc_packet *pPacket;\r\ndo {\r\npPacket = HTC_PACKET_DEQUEUE(pQueueToIndicate);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, (" HTC calling ep %d recv callback on packet 0x%lX \n", \\r\npEndpoint->Id, (unsigned long)(pPacket)));\r\npEndpoint->EpCallBacks.EpRecv(pEndpoint->EpCallBacks.pContext, pPacket);\r\n} while (!HTC_QUEUE_EMPTY(pQueueToIndicate));\r\n}\r\n} while (false);\r\n}\r\nstatic INLINE int HTCProcessTrailer(struct htc_target *target,\r\nu8 *pBuffer,\r\nint Length,\r\nu32 *pNextLookAheads,\r\nint *pNumLookAheads,\r\nHTC_ENDPOINT_ID FromEndpoint)\r\n{\r\nHTC_RECORD_HDR *pRecord;\r\nu8 *pRecordBuf;\r\nHTC_LOOKAHEAD_REPORT *pLookAhead;\r\nu8 *pOrigBuffer;\r\nint origLength;\r\nint status;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCProcessTrailer (length:%d) \n", Length));\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {\r\nAR_DEBUG_PRINTBUF(pBuffer,Length,"Recv Trailer");\r\n}\r\npOrigBuffer = pBuffer;\r\norigLength = Length;\r\nstatus = 0;\r\nwhile (Length > 0) {\r\nif (Length < sizeof(HTC_RECORD_HDR)) {\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\npRecord = (HTC_RECORD_HDR *)pBuffer;\r\nLength -= sizeof(HTC_RECORD_HDR);\r\npBuffer += sizeof(HTC_RECORD_HDR);\r\nif (pRecord->Length > Length) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n(" invalid record length: %d (id:%d) buffer has: %d bytes left \n",\r\npRecord->Length, pRecord->RecordID, Length));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\npRecordBuf = pBuffer;\r\nswitch (pRecord->RecordID) {\r\ncase HTC_RECORD_CREDITS:\r\nAR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_CREDIT_REPORT));\r\nHTCProcessCreditRpt(target,\r\n(HTC_CREDIT_REPORT *)pRecordBuf,\r\npRecord->Length / (sizeof(HTC_CREDIT_REPORT)),\r\nFromEndpoint);\r\nbreak;\r\ncase HTC_RECORD_LOOKAHEAD:\r\nAR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_LOOKAHEAD_REPORT));\r\npLookAhead = (HTC_LOOKAHEAD_REPORT *)pRecordBuf;\r\nif ((pLookAhead->PreValid == ((~pLookAhead->PostValid) & 0xFF)) &&\r\n(pNextLookAheads != NULL)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n(" LookAhead Report Found (pre valid:0x%X, post valid:0x%X) \n",\r\npLookAhead->PreValid,\r\npLookAhead->PostValid));\r\n((u8 *)(&pNextLookAheads[0]))[0] = pLookAhead->LookAhead[0];\r\n((u8 *)(&pNextLookAheads[0]))[1] = pLookAhead->LookAhead[1];\r\n((u8 *)(&pNextLookAheads[0]))[2] = pLookAhead->LookAhead[2];\r\n((u8 *)(&pNextLookAheads[0]))[3] = pLookAhead->LookAhead[3];\r\n#ifdef ATH_DEBUG_MODULE\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {\r\nDebugDumpBytes((u8 *)pNextLookAheads,4,"Next Look Ahead");\r\n}\r\n#endif\r\n*pNumLookAheads = 1;\r\n}\r\nbreak;\r\ncase HTC_RECORD_LOOKAHEAD_BUNDLE:\r\nAR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_BUNDLED_LOOKAHEAD_REPORT));\r\nif (pRecord->Length >= sizeof(HTC_BUNDLED_LOOKAHEAD_REPORT) &&\r\n(pNextLookAheads != NULL)) {\r\nHTC_BUNDLED_LOOKAHEAD_REPORT *pBundledLookAheadRpt;\r\nint i;\r\npBundledLookAheadRpt = (HTC_BUNDLED_LOOKAHEAD_REPORT *)pRecordBuf;\r\n#ifdef ATH_DEBUG_MODULE\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {\r\nDebugDumpBytes(pRecordBuf,pRecord->Length,"Bundle LookAhead");\r\n}\r\n#endif\r\nif ((pRecord->Length / (sizeof(HTC_BUNDLED_LOOKAHEAD_REPORT))) >\r\nHTC_HOST_MAX_MSG_PER_BUNDLE) {\r\nA_ASSERT(false);\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nfor (i = 0; i < (int)(pRecord->Length / (sizeof(HTC_BUNDLED_LOOKAHEAD_REPORT))); i++) {\r\n((u8 *)(&pNextLookAheads[i]))[0] = pBundledLookAheadRpt->LookAhead[0];\r\n((u8 *)(&pNextLookAheads[i]))[1] = pBundledLookAheadRpt->LookAhead[1];\r\n((u8 *)(&pNextLookAheads[i]))[2] = pBundledLookAheadRpt->LookAhead[2];\r\n((u8 *)(&pNextLookAheads[i]))[3] = pBundledLookAheadRpt->LookAhead[3];\r\npBundledLookAheadRpt++;\r\n}\r\n*pNumLookAheads = i;\r\n}\r\nbreak;\r\ndefault:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" unhandled record: id:%d length:%d \n",\r\npRecord->RecordID, pRecord->Length));\r\nbreak;\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\npBuffer += pRecord->Length;\r\nLength -= pRecord->Length;\r\n}\r\n#ifdef ATH_DEBUG_MODULE\r\nif (status) {\r\nDebugDumpBytes(pOrigBuffer,origLength,"BAD Recv Trailer");\r\n}\r\n#endif\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCProcessTrailer \n"));\r\nreturn status;\r\n}\r\nstatic int HTCProcessRecvHeader(struct htc_target *target,\r\nstruct htc_packet *pPacket,\r\nu32 *pNextLookAheads,\r\nint *pNumLookAheads)\r\n{\r\nu8 temp;\r\nu8 *pBuf;\r\nint status = 0;\r\nu16 payloadLen;\r\nu32 lookAhead;\r\npBuf = pPacket->pBuffer;\r\nif (pNumLookAheads != NULL) {\r\n*pNumLookAheads = 0;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCProcessRecvHeader \n"));\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {\r\nAR_DEBUG_PRINTBUF(pBuf,pPacket->ActualLength,"HTC Recv PKT");\r\n}\r\ndo {\r\npayloadLen = A_GET_UINT16_FIELD(pBuf, struct htc_frame_hdr, PayloadLen);\r\n((u8 *)&lookAhead)[0] = pBuf[0];\r\n((u8 *)&lookAhead)[1] = pBuf[1];\r\n((u8 *)&lookAhead)[2] = pBuf[2];\r\n((u8 *)&lookAhead)[3] = pBuf[3];\r\nif (pPacket->PktInfo.AsRx.HTCRxFlags & HTC_RX_PKT_REFRESH_HDR) {\r\npPacket->PktInfo.AsRx.ExpectedHdr = lookAhead;\r\npPacket->ActualLength = payloadLen + HTC_HDR_LENGTH;\r\nif (pPacket->ActualLength > pPacket->BufferLength) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Refreshed HDR payload length (%d) in bundled RECV is invalid (hdr: 0x%X) \n",\r\npayloadLen, lookAhead));\r\npPacket->ActualLength = min(pPacket->ActualLength, pPacket->BufferLength);\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (pPacket->Endpoint != A_GET_UINT8_FIELD(pBuf, struct htc_frame_hdr, EndpointID)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Refreshed HDR endpoint (%d) does not match expected endpoint (%d) \n",\r\nA_GET_UINT8_FIELD(pBuf, struct htc_frame_hdr, EndpointID), pPacket->Endpoint));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\n}\r\nif (lookAhead != pPacket->PktInfo.AsRx.ExpectedHdr) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("HTCProcessRecvHeader, lookahead mismatch! (pPkt:0x%lX flags:0x%X) \n",\r\n(unsigned long)pPacket, pPacket->PktInfo.AsRx.HTCRxFlags));\r\n#ifdef ATH_DEBUG_MODULE\r\nDebugDumpBytes((u8 *)&pPacket->PktInfo.AsRx.ExpectedHdr,4,"Expected Message LookAhead");\r\nDebugDumpBytes(pBuf,sizeof(struct htc_frame_hdr),"Current Frame Header");\r\n#ifdef HTC_CAPTURE_LAST_FRAME\r\nDebugDumpBytes((u8 *)&target->LastFrameHdr,sizeof(struct htc_frame_hdr),"Last Frame Header");\r\nif (target->LastTrailerLength != 0) {\r\nDebugDumpBytes(target->LastTrailer,\r\ntarget->LastTrailerLength,\r\n"Last trailer");\r\n}\r\n#endif\r\n#endif\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\ntemp = A_GET_UINT8_FIELD(pBuf, struct htc_frame_hdr, Flags);\r\nif (temp & HTC_FLAGS_RECV_TRAILER) {\r\ntemp = A_GET_UINT8_FIELD(pBuf, struct htc_frame_hdr, ControlBytes[0]);\r\nif ((temp < sizeof(HTC_RECORD_HDR)) || (temp > payloadLen)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("HTCProcessRecvHeader, invalid header (payloadlength should be :%d, CB[0] is:%d) \n",\r\npayloadLen, temp));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (pPacket->PktInfo.AsRx.HTCRxFlags & HTC_RX_PKT_IGNORE_LOOKAHEAD) {\r\npNextLookAheads = NULL;\r\npNumLookAheads = NULL;\r\n}\r\nstatus = HTCProcessTrailer(target,\r\n(pBuf + HTC_HDR_LENGTH + payloadLen - temp),\r\ntemp,\r\npNextLookAheads,\r\npNumLookAheads,\r\npPacket->Endpoint);\r\nif (status) {\r\nbreak;\r\n}\r\n#ifdef HTC_CAPTURE_LAST_FRAME\r\nmemcpy(target->LastTrailer, (pBuf + HTC_HDR_LENGTH + payloadLen - temp), temp);\r\ntarget->LastTrailerLength = temp;\r\n#endif\r\npPacket->ActualLength -= temp;\r\n}\r\n#ifdef HTC_CAPTURE_LAST_FRAME\r\nelse {\r\ntarget->LastTrailerLength = 0;\r\n}\r\n#endif\r\npPacket->pBuffer += HTC_HDR_LENGTH;\r\npPacket->ActualLength -= HTC_HDR_LENGTH;\r\n} while (false);\r\nif (status) {\r\n#ifdef ATH_DEBUG_MODULE\r\nDebugDumpBytes(pBuf,pPacket->ActualLength < 256 ? pPacket->ActualLength : 256 ,"BAD HTC Recv PKT");\r\n#endif\r\n} else {\r\n#ifdef HTC_CAPTURE_LAST_FRAME\r\nmemcpy(&target->LastFrameHdr,pBuf,sizeof(struct htc_frame_hdr));\r\n#endif\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {\r\nif (pPacket->ActualLength > 0) {\r\nAR_DEBUG_PRINTBUF(pPacket->pBuffer,pPacket->ActualLength,"HTC - Application Msg");\r\n}\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCProcessRecvHeader \n"));\r\nreturn status;\r\n}\r\nstatic INLINE void HTCAsyncRecvCheckMorePackets(struct htc_target *target,\r\nu32 NextLookAheads[],\r\nint NumLookAheads,\r\nbool CheckMoreMsgs)\r\n{\r\nif (NumLookAheads > 0) {\r\nint nextStatus;\r\nint fetched = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("HTCAsyncRecvCheckMorePackets - num lookaheads were non-zero : %d \n",\r\nNumLookAheads));\r\nREF_IRQ_STATUS_RECHECK(&target->Device);\r\nnextStatus = HTCRecvMessagePendingHandler(target, NextLookAheads, NumLookAheads, NULL, &fetched);\r\nif (A_EPROTO == nextStatus) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Next look ahead from recv header was INVALID\n"));\r\n#ifdef ATH_DEBUG_MODULE\r\nDebugDumpBytes((u8 *)NextLookAheads,\r\nNumLookAheads * (sizeof(u32)),\r\n"BAD lookaheads from lookahead report");\r\n#endif\r\n}\r\nif (!nextStatus && !fetched) {\r\nDevAsyncIrqProcessComplete(&target->Device);\r\n}\r\n} else {\r\nif (CheckMoreMsgs) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("HTCAsyncRecvCheckMorePackets - rechecking for more messages...\n"));\r\nDevCheckPendingRecvMsgsAsync(&target->Device);\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("HTCAsyncRecvCheckMorePackets - no check \n"));\r\n}\r\n}\r\n}\r\nstatic INLINE void DrainRecvIndicationQueue(struct htc_target *target, struct htc_endpoint *pEndpoint)\r\n{\r\nstruct htc_packet_queue recvCompletions;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+DrainRecvIndicationQueue \n"));\r\nINIT_HTC_PACKET_QUEUE(&recvCompletions);\r\nLOCK_HTC_RX(target);\r\npEndpoint->RxProcessCount++;\r\nif (pEndpoint->RxProcessCount > 1) {\r\npEndpoint->RxProcessCount--;\r\nUNLOCK_HTC_RX(target);\r\nreturn;\r\n}\r\nwhile (true) {\r\nHTC_PACKET_QUEUE_TRANSFER_TO_TAIL(&recvCompletions, &pEndpoint->RecvIndicationQueue);\r\nif (HTC_QUEUE_EMPTY(&recvCompletions)) {\r\nbreak;\r\n}\r\nUNLOCK_HTC_RX(target);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("DrainRecvIndicationQueue : completing %d RECV packets \n",\r\nHTC_PACKET_QUEUE_DEPTH(&recvCompletions)));\r\nDO_RCV_COMPLETION(pEndpoint,&recvCompletions);\r\nLOCK_HTC_RX(target);\r\n}\r\npEndpoint->RxProcessCount = 0;\r\nUNLOCK_HTC_RX(target);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-DrainRecvIndicationQueue \n"));\r\n}\r\nstatic INLINE void SetRxPacketIndicationFlags(u32 LookAhead,\r\nstruct htc_endpoint *pEndpoint,\r\nstruct htc_packet *pPacket)\r\n{\r\nstruct htc_frame_hdr *pHdr = (struct htc_frame_hdr *)&LookAhead;\r\nif (pHdr->EndpointID == pPacket->Endpoint) {\r\nif (!HTC_QUEUE_EMPTY(&pEndpoint->RxBuffers)) {\r\nFORCE_MORE_RX_PACKET_INDICATION_FLAG(pPacket);\r\n}\r\n}\r\n}\r\nvoid HTCRecvCompleteHandler(void *Context, struct htc_packet *pPacket)\r\n{\r\nstruct htc_target *target = (struct htc_target *)Context;\r\nstruct htc_endpoint *pEndpoint;\r\nu32 nextLookAheads[HTC_HOST_MAX_MSG_PER_BUNDLE];\r\nint numLookAheads = 0;\r\nint status;\r\nbool checkMorePkts = true;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCRecvCompleteHandler (pkt:0x%lX, status:%d, ep:%d) \n",\r\n(unsigned long)pPacket, pPacket->Status, pPacket->Endpoint));\r\nA_ASSERT(!IS_DEV_IRQ_PROC_SYNC_MODE(&target->Device));\r\nAR_DEBUG_ASSERT(pPacket->Endpoint < ENDPOINT_MAX);\r\npEndpoint = &target->EndPoint[pPacket->Endpoint];\r\npPacket->Completion = NULL;\r\nstatus = pPacket->Status;\r\ndo {\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HTCRecvCompleteHandler: request failed (status:%d, ep:%d) \n",\r\npPacket->Status, pPacket->Endpoint));\r\nbreak;\r\n}\r\nstatus = HTCProcessRecvHeader(target,pPacket,nextLookAheads,&numLookAheads);\r\nif (status) {\r\nbreak;\r\n}\r\nif (pPacket->PktInfo.AsRx.HTCRxFlags & HTC_RX_PKT_IGNORE_LOOKAHEAD) {\r\ncheckMorePkts = false;\r\n}\r\nDUMP_RECV_PKT_INFO(pPacket);\r\nLOCK_HTC_RX(target);\r\nSET_MORE_RX_PACKET_INDICATION_FLAG(nextLookAheads,numLookAheads,pEndpoint,pPacket);\r\nHTC_PACKET_ENQUEUE(&pEndpoint->RecvIndicationQueue,pPacket);\r\nHTC_RX_STAT_PROFILE(target,pEndpoint,numLookAheads);\r\nUNLOCK_HTC_RX(target);\r\nHTCAsyncRecvCheckMorePackets(target,nextLookAheads,numLookAheads,checkMorePkts);\r\n} while (false);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("HTCRecvCompleteHandler , message fetch failed (status = %d) \n",\r\nstatus));\r\nHTC_RECYCLE_RX_PKT(target, pPacket, pEndpoint);\r\n} else {\r\nDrainRecvIndicationQueue(target,pEndpoint);\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCRecvCompleteHandler\n"));\r\n}\r\nint HTCWaitforControlMessage(struct htc_target *target, struct htc_packet **ppControlPacket)\r\n{\r\nint status;\r\nu32 lookAhead;\r\nstruct htc_packet *pPacket = NULL;\r\nstruct htc_frame_hdr *pHdr;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HTCWaitforControlMessage \n"));\r\ndo {\r\n*ppControlPacket = NULL;\r\nstatus = DevPollMboxMsgRecv(&target->Device,\r\n&lookAhead,\r\nHTC_TARGET_RESPONSE_TIMEOUT);\r\nif (status) {\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("HTCWaitforControlMessage : lookAhead : 0x%X \n", lookAhead));\r\npHdr = (struct htc_frame_hdr *)&lookAhead;\r\nif (pHdr->EndpointID != ENDPOINT_0) {\r\nAR_DEBUG_ASSERT(false);\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (status) {\r\nAR_DEBUG_ASSERT(false);\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\npPacket = HTC_ALLOC_CONTROL_RX(target);\r\nif (pPacket == NULL) {\r\nAR_DEBUG_ASSERT(false);\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\npPacket->PktInfo.AsRx.HTCRxFlags = 0;\r\npPacket->PktInfo.AsRx.ExpectedHdr = lookAhead;\r\npPacket->ActualLength = pHdr->PayloadLen + HTC_HDR_LENGTH;\r\nif (pPacket->ActualLength > pPacket->BufferLength) {\r\nAR_DEBUG_ASSERT(false);\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\npPacket->Completion = NULL;\r\nstatus = HTCIssueRecv(target, pPacket);\r\nif (status) {\r\nbreak;\r\n}\r\nstatus = HTCProcessRecvHeader(target,pPacket,NULL,NULL);\r\npPacket->Status = status;\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("HTCWaitforControlMessage, HTCProcessRecvHeader failed (status = %d) \n",\r\nstatus));\r\nbreak;\r\n}\r\n*ppControlPacket = pPacket;\r\n} while (false);\r\nif (status) {\r\nif (pPacket != NULL) {\r\nHTC_FREE_CONTROL_RX(target,pPacket);\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HTCWaitforControlMessage \n"));\r\nreturn status;\r\n}\r\nstatic int AllocAndPrepareRxPackets(struct htc_target *target,\r\nu32 LookAheads[],\r\nint Messages,\r\nstruct htc_endpoint *pEndpoint,\r\nstruct htc_packet_queue *pQueue)\r\n{\r\nint status = 0;\r\nstruct htc_packet *pPacket;\r\nstruct htc_frame_hdr *pHdr;\r\nint i,j;\r\nint numMessages;\r\nint fullLength;\r\nbool noRecycle;\r\nLOCK_HTC_RX(target);\r\nfor (i = 0; i < Messages; i++) {\r\npHdr = (struct htc_frame_hdr *)&LookAheads[i];\r\nif (pHdr->EndpointID >= ENDPOINT_MAX) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Invalid Endpoint in look-ahead: %d \n",pHdr->EndpointID));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (pHdr->EndpointID != pEndpoint->Id) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Invalid Endpoint in look-ahead: %d should be : %d (index:%d)\n",\r\npHdr->EndpointID, pEndpoint->Id, i));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (pHdr->PayloadLen > HTC_MAX_PAYLOAD_LENGTH) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Payload length %d exceeds max HTC : %d !\n",\r\npHdr->PayloadLen, (u32)HTC_MAX_PAYLOAD_LENGTH));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (0 == pEndpoint->ServiceID) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Endpoint %d is not connected !\n",pHdr->EndpointID));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif ((pHdr->Flags & HTC_FLAGS_RECV_BUNDLE_CNT_MASK) == 0) {\r\nnumMessages = 1;\r\n} else {\r\nnumMessages = (pHdr->Flags & HTC_FLAGS_RECV_BUNDLE_CNT_MASK) >> HTC_FLAGS_RECV_BUNDLE_CNT_SHIFT;\r\nnumMessages++;\r\nA_ASSERT(numMessages <= target->MaxMsgPerBundle);\r\nINC_HTC_EP_STAT(pEndpoint, RxBundleIndFromHdr, 1);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("HTC header indicates :%d messages can be fetched as a bundle \n",numMessages));\r\n}\r\nfullLength = DEV_CALC_RECV_PADDED_LEN(&target->Device,pHdr->PayloadLen + sizeof(struct htc_frame_hdr));\r\nfor (j = 0; j < numMessages; j++) {\r\nnoRecycle = false;\r\nif (pEndpoint->EpCallBacks.EpRecvAlloc != NULL) {\r\nUNLOCK_HTC_RX(target);\r\nnoRecycle = true;\r\npPacket = pEndpoint->EpCallBacks.EpRecvAlloc(pEndpoint->EpCallBacks.pContext,\r\npEndpoint->Id,\r\nfullLength);\r\nLOCK_HTC_RX(target);\r\n} else if ((pEndpoint->EpCallBacks.EpRecvAllocThresh != NULL) &&\r\n(fullLength > pEndpoint->EpCallBacks.RecvAllocThreshold)) {\r\nINC_HTC_EP_STAT(pEndpoint,RxAllocThreshHit,1);\r\nINC_HTC_EP_STAT(pEndpoint,RxAllocThreshBytes,pHdr->PayloadLen);\r\nUNLOCK_HTC_RX(target);\r\nnoRecycle = true;\r\npPacket = pEndpoint->EpCallBacks.EpRecvAllocThresh(pEndpoint->EpCallBacks.pContext,\r\npEndpoint->Id,\r\nfullLength);\r\nLOCK_HTC_RX(target);\r\n} else {\r\npPacket = HTC_PACKET_DEQUEUE(&pEndpoint->RxBuffers);\r\nif (NULL == pPacket) {\r\nif (pEndpoint->EpCallBacks.EpRecvRefill != NULL) {\r\nUNLOCK_HTC_RX(target);\r\npEndpoint->EpCallBacks.EpRecvRefill(pEndpoint->EpCallBacks.pContext,\r\npEndpoint->Id);\r\nLOCK_HTC_RX(target);\r\npPacket = HTC_PACKET_DEQUEUE(&pEndpoint->RxBuffers);\r\n}\r\n}\r\n}\r\nif (NULL == pPacket) {\r\ntarget->RecvStateFlags |= HTC_RECV_WAIT_BUFFERS;\r\ntarget->EpWaitingForBuffers = pEndpoint->Id;\r\nstatus = A_NO_RESOURCE;\r\nbreak;\r\n}\r\nAR_DEBUG_ASSERT(pPacket->Endpoint == pEndpoint->Id);\r\npPacket->PktInfo.AsRx.HTCRxFlags = 0;\r\npPacket->PktInfo.AsRx.IndicationFlags = 0;\r\npPacket->Status = 0;\r\nif (noRecycle) {\r\npPacket->PktInfo.AsRx.HTCRxFlags |= HTC_RX_PKT_NO_RECYCLE;\r\n}\r\nHTC_PACKET_ENQUEUE(pQueue,pPacket);\r\nif (HTC_STOPPING(target)) {\r\nstatus = A_ECANCELED;\r\nbreak;\r\n}\r\nif ((u32)fullLength > pPacket->BufferLength) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Payload Length Error : header reports payload of: %d (%d) endpoint buffer size: %d \n",\r\npHdr->PayloadLen, fullLength, pPacket->BufferLength));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (j > 0) {\r\npPacket->PktInfo.AsRx.HTCRxFlags |= HTC_RX_PKT_REFRESH_HDR;\r\npPacket->PktInfo.AsRx.ExpectedHdr = 0xFFFFFFFF;\r\n} else {\r\npPacket->PktInfo.AsRx.ExpectedHdr = LookAheads[i];\r\n}\r\npPacket->ActualLength = pHdr->PayloadLen + HTC_HDR_LENGTH;\r\n}\r\nif (status) {\r\nif (A_NO_RESOURCE == status) {\r\nstatus = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nUNLOCK_HTC_RX(target);\r\nif (status) {\r\nwhile (!HTC_QUEUE_EMPTY(pQueue)) {\r\npPacket = HTC_PACKET_DEQUEUE(pQueue);\r\nHTC_RECYCLE_RX_PKT(target,pPacket,&target->EndPoint[pPacket->Endpoint]);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void HTCAsyncRecvScatterCompletion(struct hif_scatter_req *pScatterReq)\r\n{\r\nint i;\r\nstruct htc_packet *pPacket;\r\nstruct htc_endpoint *pEndpoint;\r\nu32 lookAheads[HTC_HOST_MAX_MSG_PER_BUNDLE];\r\nint numLookAheads = 0;\r\nstruct htc_target *target = (struct htc_target *)pScatterReq->Context;\r\nint status;\r\nbool partialBundle = false;\r\nstruct htc_packet_queue localRecvQueue;\r\nbool procError = false;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HTCAsyncRecvScatterCompletion TotLen: %d Entries: %d\n",\r\npScatterReq->TotalLength, pScatterReq->ValidScatterEntries));\r\nA_ASSERT(!IS_DEV_IRQ_PROC_SYNC_MODE(&target->Device));\r\nif (pScatterReq->CompletionStatus) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("** Recv Scatter Request Failed: %d \n",pScatterReq->CompletionStatus));\r\n}\r\nif (pScatterReq->CallerFlags & HTC_SCATTER_REQ_FLAGS_PARTIAL_BUNDLE) {\r\npartialBundle = true;\r\n}\r\nDEV_FINISH_SCATTER_OPERATION(pScatterReq);\r\nINIT_HTC_PACKET_QUEUE(&localRecvQueue);\r\npPacket = (struct htc_packet *)pScatterReq->ScatterList[0].pCallerContexts[0];\r\npEndpoint = &target->EndPoint[pPacket->Endpoint];\r\nfor (i = 0; i < pScatterReq->ValidScatterEntries; i++) {\r\npPacket = (struct htc_packet *)pScatterReq->ScatterList[i].pCallerContexts[0];\r\nA_ASSERT(pPacket != NULL);\r\nnumLookAheads = 0;\r\nif (!pScatterReq->CompletionStatus) {\r\nstatus = HTCProcessRecvHeader(target,pPacket,lookAheads,&numLookAheads);\r\n} else {\r\nstatus = A_ERROR;\r\n}\r\nif (!status) {\r\nLOCK_HTC_RX(target);\r\nHTC_RX_STAT_PROFILE(target,pEndpoint,numLookAheads);\r\nINC_HTC_EP_STAT(pEndpoint, RxPacketsBundled, 1);\r\nUNLOCK_HTC_RX(target);\r\nif (i == (pScatterReq->ValidScatterEntries - 1)) {\r\nSET_MORE_RX_PACKET_INDICATION_FLAG(lookAheads,numLookAheads,pEndpoint,pPacket);\r\n} else {\r\nFORCE_MORE_RX_PACKET_INDICATION_FLAG(pPacket);\r\n}\r\nDUMP_RECV_PKT_INFO(pPacket);\r\nHTC_PACKET_ENQUEUE(&localRecvQueue,pPacket);\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" Recv packet scatter entry %d failed (out of %d) \n",\r\ni, pScatterReq->ValidScatterEntries));\r\nHTC_RECYCLE_RX_PKT(target, pPacket, pEndpoint);\r\nprocError = true;\r\n}\r\n}\r\nDEV_FREE_SCATTER_REQ(&target->Device,pScatterReq);\r\nLOCK_HTC_RX(target);\r\nHTC_PACKET_QUEUE_TRANSFER_TO_TAIL(&pEndpoint->RecvIndicationQueue, &localRecvQueue);\r\nUNLOCK_HTC_RX(target);\r\nif (!procError) {\r\nHTCAsyncRecvCheckMorePackets(target,\r\nlookAheads,\r\nnumLookAheads,\r\npartialBundle ? false : true);\r\n}\r\nDrainRecvIndicationQueue(target,pEndpoint);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HTCAsyncRecvScatterCompletion \n"));\r\n}\r\nstatic int HTCIssueRecvPacketBundle(struct htc_target *target,\r\nstruct htc_packet_queue *pRecvPktQueue,\r\nstruct htc_packet_queue *pSyncCompletionQueue,\r\nint *pNumPacketsFetched,\r\nbool PartialBundle)\r\n{\r\nint status = 0;\r\nstruct hif_scatter_req *pScatterReq;\r\nint i, totalLength;\r\nint pktsToScatter;\r\nstruct htc_packet *pPacket;\r\nbool asyncMode = (pSyncCompletionQueue == NULL) ? true : false;\r\nint scatterSpaceRemaining = DEV_GET_MAX_BUNDLE_RECV_LENGTH(&target->Device);\r\npktsToScatter = HTC_PACKET_QUEUE_DEPTH(pRecvPktQueue);\r\npktsToScatter = min(pktsToScatter, target->MaxMsgPerBundle);\r\nif ((HTC_PACKET_QUEUE_DEPTH(pRecvPktQueue) - pktsToScatter) > 0) {\r\nPartialBundle = true;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN,\r\n("HTCIssueRecvPacketBundle : partial bundle detected num:%d , %d \n",\r\nHTC_PACKET_QUEUE_DEPTH(pRecvPktQueue), pktsToScatter));\r\n}\r\ntotalLength = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HTCIssueRecvPacketBundle (Numpackets: %d , actual : %d) \n",\r\nHTC_PACKET_QUEUE_DEPTH(pRecvPktQueue), pktsToScatter));\r\ndo {\r\npScatterReq = DEV_ALLOC_SCATTER_REQ(&target->Device);\r\nif (pScatterReq == NULL) {\r\nbreak;\r\n}\r\npScatterReq->CallerFlags = 0;\r\nif (PartialBundle) {\r\npScatterReq->CallerFlags |= HTC_SCATTER_REQ_FLAGS_PARTIAL_BUNDLE;\r\n}\r\nfor (i = 0; i < pktsToScatter; i++) {\r\nint paddedLength;\r\npPacket = HTC_PACKET_DEQUEUE(pRecvPktQueue);\r\nA_ASSERT(pPacket != NULL);\r\npaddedLength = DEV_CALC_RECV_PADDED_LEN(&target->Device, pPacket->ActualLength);\r\nif ((scatterSpaceRemaining - paddedLength) < 0) {\r\nHTC_PACKET_ENQUEUE_TO_HEAD(pRecvPktQueue,pPacket);\r\nbreak;\r\n}\r\nscatterSpaceRemaining -= paddedLength;\r\nif (PartialBundle || (i < (pktsToScatter - 1))) {\r\npPacket->PktInfo.AsRx.HTCRxFlags |= HTC_RX_PKT_IGNORE_LOOKAHEAD;\r\n}\r\npScatterReq->ScatterList[i].pBuffer = pPacket->pBuffer;\r\npScatterReq->ScatterList[i].Length = paddedLength;\r\npPacket->PktInfo.AsRx.HTCRxFlags |= HTC_RX_PKT_PART_OF_BUNDLE;\r\nif (asyncMode) {\r\npScatterReq->ScatterList[i].pCallerContexts[0] = pPacket;\r\n} else {\r\nHTC_PACKET_ENQUEUE(pSyncCompletionQueue,pPacket);\r\n}\r\nA_ASSERT(pScatterReq->ScatterList[i].Length);\r\ntotalLength += pScatterReq->ScatterList[i].Length;\r\n}\r\npScatterReq->TotalLength = totalLength;\r\npScatterReq->ValidScatterEntries = i;\r\nif (asyncMode) {\r\npScatterReq->CompletionRoutine = HTCAsyncRecvScatterCompletion;\r\npScatterReq->Context = target;\r\n}\r\nstatus = DevSubmitScatterRequest(&target->Device, pScatterReq, DEV_SCATTER_READ, asyncMode);\r\nif (!status) {\r\n*pNumPacketsFetched = i;\r\n}\r\nif (!asyncMode) {\r\nDEV_FREE_SCATTER_REQ(&target->Device, pScatterReq);\r\n}\r\n} while (false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HTCIssueRecvPacketBundle (status:%d) (fetched:%d) \n",\r\nstatus,*pNumPacketsFetched));\r\nreturn status;\r\n}\r\nstatic INLINE void CheckRecvWaterMark(struct htc_endpoint *pEndpoint)\r\n{\r\nif (pEndpoint->EpCallBacks.RecvRefillWaterMark > 0) {\r\nif (HTC_PACKET_QUEUE_DEPTH(&pEndpoint->RxBuffers) < pEndpoint->EpCallBacks.RecvRefillWaterMark) {\r\npEndpoint->EpCallBacks.EpRecvRefill(pEndpoint->EpCallBacks.pContext,\r\npEndpoint->Id);\r\n}\r\n}\r\n}\r\nint HTCRecvMessagePendingHandler(void *Context, u32 MsgLookAheads[], int NumLookAheads, bool *pAsyncProc, int *pNumPktsFetched)\r\n{\r\nstruct htc_target *target = (struct htc_target *)Context;\r\nint status = 0;\r\nstruct htc_packet *pPacket;\r\nstruct htc_endpoint *pEndpoint;\r\nbool asyncProc = false;\r\nu32 lookAheads[HTC_HOST_MAX_MSG_PER_BUNDLE];\r\nint pktsFetched;\r\nstruct htc_packet_queue recvPktQueue, syncCompletedPktsQueue;\r\nbool partialBundle;\r\nHTC_ENDPOINT_ID id;\r\nint totalFetched = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HTCRecvMessagePendingHandler NumLookAheads: %d \n",NumLookAheads));\r\nif (pNumPktsFetched != NULL) {\r\n*pNumPktsFetched = 0;\r\n}\r\nif (IS_DEV_IRQ_PROCESSING_ASYNC_ALLOWED(&target->Device)) {\r\nasyncProc = true;\r\n}\r\nif (pAsyncProc != NULL) {\r\n*pAsyncProc = asyncProc;\r\n}\r\nif (NumLookAheads > HTC_HOST_MAX_MSG_PER_BUNDLE) {\r\nA_ASSERT(false);\r\nreturn A_EPROTO;\r\n}\r\nmemcpy(lookAheads, MsgLookAheads, (sizeof(u32)) * NumLookAheads);\r\nwhile (true) {\r\nINIT_HTC_PACKET_QUEUE(&recvPktQueue);\r\nINIT_HTC_PACKET_QUEUE(&syncCompletedPktsQueue);\r\nif (NumLookAheads > HTC_HOST_MAX_MSG_PER_BUNDLE) {\r\nstatus = A_EPROTO;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nid = ((struct htc_frame_hdr *)&lookAheads[0])->EndpointID;\r\npEndpoint = &target->EndPoint[id];\r\nif (id >= ENDPOINT_MAX) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("MsgPend, Invalid Endpoint in look-ahead: %d \n",id));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nstatus = AllocAndPrepareRxPackets(target,\r\nlookAheads,\r\nNumLookAheads,\r\npEndpoint,\r\n&recvPktQueue);\r\nif (status) {\r\nbreak;\r\n}\r\nif (HTC_PACKET_QUEUE_DEPTH(&recvPktQueue) >= 2) {\r\nREF_IRQ_STATUS_RECHECK(&target->Device);\r\n}\r\ntotalFetched += HTC_PACKET_QUEUE_DEPTH(&recvPktQueue);\r\nNumLookAheads = 0;\r\npartialBundle = false;\r\nwhile (!HTC_QUEUE_EMPTY(&recvPktQueue)) {\r\npktsFetched = 0;\r\nif (target->RecvBundlingEnabled && (HTC_PACKET_QUEUE_DEPTH(&recvPktQueue) > 1)) {\r\nstatus = HTCIssueRecvPacketBundle(target,\r\n&recvPktQueue,\r\nasyncProc ? NULL : &syncCompletedPktsQueue,\r\n&pktsFetched,\r\npartialBundle);\r\nif (status) {\r\nbreak;\r\n}\r\nif (HTC_PACKET_QUEUE_DEPTH(&recvPktQueue) != 0) {\r\npartialBundle = true;\r\n}\r\n}\r\nif (0 == pktsFetched) {\r\npPacket = HTC_PACKET_DEQUEUE(&recvPktQueue);\r\nA_ASSERT(pPacket != NULL);\r\nif (asyncProc) {\r\npPacket->Completion = HTCRecvCompleteHandler;\r\npPacket->pContext = target;\r\n} else {\r\npPacket->Completion = NULL;\r\n}\r\nif (HTC_PACKET_QUEUE_DEPTH(&recvPktQueue) > 0) {\r\npPacket->PktInfo.AsRx.HTCRxFlags |= HTC_RX_PKT_IGNORE_LOOKAHEAD;\r\n}\r\nstatus = HTCIssueRecv(target, pPacket);\r\nif (status) {\r\nbreak;\r\n}\r\nif (!asyncProc) {\r\nHTC_PACKET_ENQUEUE(&syncCompletedPktsQueue,pPacket);\r\n}\r\n}\r\n}\r\nif (!status) {\r\nCheckRecvWaterMark(pEndpoint);\r\n}\r\nif (asyncProc) {\r\nbreak;\r\n}\r\nif (target->Device.DSRCanYield) {\r\ntarget->Device.CurrentDSRRecvCount++;\r\n}\r\nwhile (!HTC_QUEUE_EMPTY(&syncCompletedPktsQueue)) {\r\nstruct htc_packet_queue container;\r\npPacket = HTC_PACKET_DEQUEUE(&syncCompletedPktsQueue);\r\nA_ASSERT(pPacket != NULL);\r\npEndpoint = &target->EndPoint[pPacket->Endpoint];\r\nNumLookAheads = 0;\r\nstatus = HTCProcessRecvHeader(target,pPacket,lookAheads,&NumLookAheads);\r\nif (status) {\r\nbreak;\r\n}\r\nif (HTC_QUEUE_EMPTY(&syncCompletedPktsQueue)) {\r\nSET_MORE_RX_PACKET_INDICATION_FLAG(lookAheads,NumLookAheads,pEndpoint,pPacket);\r\n} else {\r\nFORCE_MORE_RX_PACKET_INDICATION_FLAG(pPacket);\r\n}\r\nHTC_RX_STAT_PROFILE(target,pEndpoint,NumLookAheads);\r\nif (pPacket->PktInfo.AsRx.HTCRxFlags & HTC_RX_PKT_PART_OF_BUNDLE) {\r\nINC_HTC_EP_STAT(pEndpoint, RxPacketsBundled, 1);\r\n}\r\nINIT_HTC_PACKET_QUEUE_AND_ADD(&container,pPacket);\r\nDO_RCV_COMPLETION(pEndpoint,&container);\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\nif (NumLookAheads == 0) {\r\nbreak;\r\n}\r\nif (target->Device.DSRCanYield) {\r\nif (DEV_CHECK_RECV_YIELD(&target->Device)) {\r\nbreak;\r\n}\r\n}\r\nA_CHECK_DRV_TX();\r\nREF_IRQ_STATUS_RECHECK(&target->Device);\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("Failed to get pending recv messages (%d) \n",status));\r\nwhile (!HTC_QUEUE_EMPTY(&recvPktQueue)) {\r\npPacket = HTC_PACKET_DEQUEUE(&recvPktQueue);\r\nHTC_RECYCLE_RX_PKT(target, pPacket, &target->EndPoint[pPacket->Endpoint]);\r\n}\r\nwhile (!HTC_QUEUE_EMPTY(&syncCompletedPktsQueue)) {\r\npPacket = HTC_PACKET_DEQUEUE(&syncCompletedPktsQueue);\r\nHTC_RECYCLE_RX_PKT(target, pPacket, &target->EndPoint[pPacket->Endpoint]);\r\n}\r\nif (HTC_STOPPING(target)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN,\r\n(" Host is going to stop. blocking receiver for HTCStop.. \n"));\r\nDevStopRecv(&target->Device, asyncProc ? DEV_STOP_RECV_ASYNC : DEV_STOP_RECV_SYNC);\r\n}\r\n}\r\nif (target->RecvStateFlags & HTC_RECV_WAIT_BUFFERS) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN,\r\n(" Host has no RX buffers, blocking receiver to prevent overrun.. \n"));\r\nDevStopRecv(&target->Device, asyncProc ? DEV_STOP_RECV_ASYNC : DEV_STOP_RECV_SYNC);\r\n}\r\nif (pNumPktsFetched != NULL) {\r\n*pNumPktsFetched = totalFetched;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HTCRecvMessagePendingHandler \n"));\r\nreturn status;\r\n}\r\nint HTCAddReceivePktMultiple(HTC_HANDLE HTCHandle, struct htc_packet_queue *pPktQueue)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nstruct htc_endpoint *pEndpoint;\r\nbool unblockRecv = false;\r\nint status = 0;\r\nstruct htc_packet *pFirstPacket;\r\npFirstPacket = HTC_GET_PKT_AT_HEAD(pPktQueue);\r\nif (NULL == pFirstPacket) {\r\nA_ASSERT(false);\r\nreturn A_EINVAL;\r\n}\r\nAR_DEBUG_ASSERT(pFirstPacket->Endpoint < ENDPOINT_MAX);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("+- HTCAddReceivePktMultiple : endPointId: %d, cnt:%d, length: %d\n",\r\npFirstPacket->Endpoint,\r\nHTC_PACKET_QUEUE_DEPTH(pPktQueue),\r\npFirstPacket->BufferLength));\r\ndo {\r\npEndpoint = &target->EndPoint[pFirstPacket->Endpoint];\r\nLOCK_HTC_RX(target);\r\nif (HTC_STOPPING(target)) {\r\nstruct htc_packet *pPacket;\r\nUNLOCK_HTC_RX(target);\r\nHTC_PACKET_QUEUE_ITERATE_ALLOW_REMOVE(pPktQueue,pPacket) {\r\npPacket->Status = A_ECANCELED;\r\n} HTC_PACKET_QUEUE_ITERATE_END;\r\nDO_RCV_COMPLETION(pEndpoint,pPktQueue);\r\nbreak;\r\n}\r\nHTC_PACKET_QUEUE_TRANSFER_TO_TAIL(&pEndpoint->RxBuffers, pPktQueue);\r\nif (target->RecvStateFlags & HTC_RECV_WAIT_BUFFERS) {\r\nif (target->EpWaitingForBuffers == pFirstPacket->Endpoint) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,(" receiver was blocked on ep:%d, unblocking.. \n",\r\ntarget->EpWaitingForBuffers));\r\ntarget->RecvStateFlags &= ~HTC_RECV_WAIT_BUFFERS;\r\ntarget->EpWaitingForBuffers = ENDPOINT_MAX;\r\nunblockRecv = true;\r\n}\r\n}\r\nUNLOCK_HTC_RX(target);\r\nif (unblockRecv && !HTC_STOPPING(target)) {\r\nDevEnableRecv(&target->Device,DEV_ENABLE_RECV_SYNC);\r\n}\r\n} while (false);\r\nreturn status;\r\n}\r\nint HTCAddReceivePkt(HTC_HANDLE HTCHandle, struct htc_packet *pPacket)\r\n{\r\nstruct htc_packet_queue queue;\r\nINIT_HTC_PACKET_QUEUE_AND_ADD(&queue,pPacket);\r\nreturn HTCAddReceivePktMultiple(HTCHandle, &queue);\r\n}\r\nvoid HTCUnblockRecv(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nbool unblockRecv = false;\r\nLOCK_HTC_RX(target);\r\nif (target->RecvStateFlags & HTC_RECV_WAIT_BUFFERS) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("HTCUnblockRx : receiver was blocked on ep:%d, unblocking.. \n",\r\ntarget->EpWaitingForBuffers));\r\ntarget->RecvStateFlags &= ~HTC_RECV_WAIT_BUFFERS;\r\ntarget->EpWaitingForBuffers = ENDPOINT_MAX;\r\nunblockRecv = true;\r\n}\r\nUNLOCK_HTC_RX(target);\r\nif (unblockRecv && !HTC_STOPPING(target)) {\r\nDevEnableRecv(&target->Device,DEV_ENABLE_RECV_ASYNC);\r\n}\r\n}\r\nstatic void HTCFlushRxQueue(struct htc_target *target, struct htc_endpoint *pEndpoint, struct htc_packet_queue *pQueue)\r\n{\r\nstruct htc_packet *pPacket;\r\nstruct htc_packet_queue container;\r\nLOCK_HTC_RX(target);\r\nwhile (1) {\r\npPacket = HTC_PACKET_DEQUEUE(pQueue);\r\nif (NULL == pPacket) {\r\nbreak;\r\n}\r\nUNLOCK_HTC_RX(target);\r\npPacket->Status = A_ECANCELED;\r\npPacket->ActualLength = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV, (" Flushing RX packet:0x%lX, length:%d, ep:%d \n",\r\n(unsigned long)pPacket, pPacket->BufferLength, pPacket->Endpoint));\r\nINIT_HTC_PACKET_QUEUE_AND_ADD(&container,pPacket);\r\nDO_RCV_COMPLETION(pEndpoint,&container);\r\nLOCK_HTC_RX(target);\r\n}\r\nUNLOCK_HTC_RX(target);\r\n}\r\nstatic void HTCFlushEndpointRX(struct htc_target *target, struct htc_endpoint *pEndpoint)\r\n{\r\nHTCFlushRxQueue(target,pEndpoint,&pEndpoint->RecvIndicationQueue);\r\nHTCFlushRxQueue(target,pEndpoint,&pEndpoint->RxBuffers);\r\n}\r\nvoid HTCFlushRecvBuffers(struct htc_target *target)\r\n{\r\nstruct htc_endpoint *pEndpoint;\r\nint i;\r\nfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\r\npEndpoint = &target->EndPoint[i];\r\nif (pEndpoint->ServiceID == 0) {\r\ncontinue;\r\n}\r\nHTCFlushEndpointRX(target,pEndpoint);\r\n}\r\n}\r\nvoid HTCEnableRecv(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nif (!HTC_STOPPING(target)) {\r\nDevEnableRecv(&target->Device,DEV_ENABLE_RECV_SYNC);\r\n}\r\n}\r\nvoid HTCDisableRecv(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nif (!HTC_STOPPING(target)) {\r\nDevStopRecv(&target->Device,DEV_ENABLE_RECV_SYNC);\r\n}\r\n}\r\nint HTCGetNumRecvBuffers(HTC_HANDLE HTCHandle,\r\nHTC_ENDPOINT_ID Endpoint)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nreturn HTC_PACKET_QUEUE_DEPTH(&(target->EndPoint[Endpoint].RxBuffers));\r\n}\r\nint HTCWaitForPendingRecv(HTC_HANDLE HTCHandle,\r\nu32 TimeoutInMs,\r\nbool *pbIsRecvPending)\r\n{\r\nint status = 0;\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nstatus = DevWaitForPendingRecv(&target->Device,\r\nTimeoutInMs,\r\npbIsRecvPending);\r\nreturn status;\r\n}
