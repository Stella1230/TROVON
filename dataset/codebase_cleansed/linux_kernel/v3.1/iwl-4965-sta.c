static struct iwl_link_quality_cmd *\r\niwl4965_sta_alloc_lq(struct iwl_priv *priv, u8 sta_id)\r\n{\r\nint i, r;\r\nstruct iwl_link_quality_cmd *link_cmd;\r\nu32 rate_flags = 0;\r\n__le32 rate_n_flags;\r\nlink_cmd = kzalloc(sizeof(struct iwl_link_quality_cmd), GFP_KERNEL);\r\nif (!link_cmd) {\r\nIWL_ERR(priv, "Unable to allocate memory for LQ cmd.\n");\r\nreturn NULL;\r\n}\r\nif (priv->band == IEEE80211_BAND_5GHZ)\r\nr = IWL_RATE_6M_INDEX;\r\nelse\r\nr = IWL_RATE_1M_INDEX;\r\nif (r >= IWL_FIRST_CCK_RATE && r <= IWL_LAST_CCK_RATE)\r\nrate_flags |= RATE_MCS_CCK_MSK;\r\nrate_flags |= iwl4965_first_antenna(priv->hw_params.valid_tx_ant) <<\r\nRATE_MCS_ANT_POS;\r\nrate_n_flags = iwl4965_hw_set_rate_n_flags(iwlegacy_rates[r].plcp,\r\nrate_flags);\r\nfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\r\nlink_cmd->rs_table[i].rate_n_flags = rate_n_flags;\r\nlink_cmd->general_params.single_stream_ant_msk =\r\niwl4965_first_antenna(priv->hw_params.valid_tx_ant);\r\nlink_cmd->general_params.dual_stream_ant_msk =\r\npriv->hw_params.valid_tx_ant &\r\n~iwl4965_first_antenna(priv->hw_params.valid_tx_ant);\r\nif (!link_cmd->general_params.dual_stream_ant_msk) {\r\nlink_cmd->general_params.dual_stream_ant_msk = ANT_AB;\r\n} else if (iwl4965_num_of_ant(priv->hw_params.valid_tx_ant) == 2) {\r\nlink_cmd->general_params.dual_stream_ant_msk =\r\npriv->hw_params.valid_tx_ant;\r\n}\r\nlink_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;\r\nlink_cmd->agg_params.agg_time_limit =\r\ncpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\r\nlink_cmd->sta_id = sta_id;\r\nreturn link_cmd;\r\n}\r\nint\r\niwl4965_add_bssid_station(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\r\nconst u8 *addr, u8 *sta_id_r)\r\n{\r\nint ret;\r\nu8 sta_id;\r\nstruct iwl_link_quality_cmd *link_cmd;\r\nunsigned long flags;\r\nif (sta_id_r)\r\n*sta_id_r = IWL_INVALID_STATION;\r\nret = iwl_legacy_add_station_common(priv, ctx, addr, 0, NULL, &sta_id);\r\nif (ret) {\r\nIWL_ERR(priv, "Unable to add station %pM\n", addr);\r\nreturn ret;\r\n}\r\nif (sta_id_r)\r\n*sta_id_r = sta_id;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].used |= IWL_STA_LOCAL;\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nlink_cmd = iwl4965_sta_alloc_lq(priv, sta_id);\r\nif (!link_cmd) {\r\nIWL_ERR(priv,\r\n"Unable to initialize rate scaling for station %pM.\n",\r\naddr);\r\nreturn -ENOMEM;\r\n}\r\nret = iwl_legacy_send_lq_cmd(priv, ctx, link_cmd, CMD_SYNC, true);\r\nif (ret)\r\nIWL_ERR(priv, "Link quality command failed (%d)\n", ret);\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].lq = link_cmd;\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int iwl4965_static_wepkey_cmd(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nbool send_if_empty)\r\n{\r\nint i, not_empty = 0;\r\nu8 buff[sizeof(struct iwl_wep_cmd) +\r\nsizeof(struct iwl_wep_key) * WEP_KEYS_MAX];\r\nstruct iwl_wep_cmd *wep_cmd = (struct iwl_wep_cmd *)buff;\r\nsize_t cmd_size = sizeof(struct iwl_wep_cmd);\r\nstruct iwl_host_cmd cmd = {\r\n.id = ctx->wep_key_cmd,\r\n.data = wep_cmd,\r\n.flags = CMD_SYNC,\r\n};\r\nmight_sleep();\r\nmemset(wep_cmd, 0, cmd_size +\r\n(sizeof(struct iwl_wep_key) * WEP_KEYS_MAX));\r\nfor (i = 0; i < WEP_KEYS_MAX ; i++) {\r\nwep_cmd->key[i].key_index = i;\r\nif (ctx->wep_keys[i].key_size) {\r\nwep_cmd->key[i].key_offset = i;\r\nnot_empty = 1;\r\n} else {\r\nwep_cmd->key[i].key_offset = WEP_INVALID_OFFSET;\r\n}\r\nwep_cmd->key[i].key_size = ctx->wep_keys[i].key_size;\r\nmemcpy(&wep_cmd->key[i].key[3], ctx->wep_keys[i].key,\r\nctx->wep_keys[i].key_size);\r\n}\r\nwep_cmd->global_key_type = WEP_KEY_WEP_TYPE;\r\nwep_cmd->num_keys = WEP_KEYS_MAX;\r\ncmd_size += sizeof(struct iwl_wep_key) * WEP_KEYS_MAX;\r\ncmd.len = cmd_size;\r\nif (not_empty || send_if_empty)\r\nreturn iwl_legacy_send_cmd(priv, &cmd);\r\nelse\r\nreturn 0;\r\n}\r\nint iwl4965_restore_default_wep_keys(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nlockdep_assert_held(&priv->mutex);\r\nreturn iwl4965_static_wepkey_cmd(priv, ctx, false);\r\n}\r\nint iwl4965_remove_default_wep_key(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct ieee80211_key_conf *keyconf)\r\n{\r\nint ret;\r\nlockdep_assert_held(&priv->mutex);\r\nIWL_DEBUG_WEP(priv, "Removing default WEP key: idx=%d\n",\r\nkeyconf->keyidx);\r\nmemset(&ctx->wep_keys[keyconf->keyidx], 0, sizeof(ctx->wep_keys[0]));\r\nif (iwl_legacy_is_rfkill(priv)) {\r\nIWL_DEBUG_WEP(priv,\r\n"Not sending REPLY_WEPKEY command due to RFKILL.\n");\r\nreturn 0;\r\n}\r\nret = iwl4965_static_wepkey_cmd(priv, ctx, 1);\r\nIWL_DEBUG_WEP(priv, "Remove default WEP key: idx=%d ret=%d\n",\r\nkeyconf->keyidx, ret);\r\nreturn ret;\r\n}\r\nint iwl4965_set_default_wep_key(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct ieee80211_key_conf *keyconf)\r\n{\r\nint ret;\r\nlockdep_assert_held(&priv->mutex);\r\nif (keyconf->keylen != WEP_KEY_LEN_128 &&\r\nkeyconf->keylen != WEP_KEY_LEN_64) {\r\nIWL_DEBUG_WEP(priv, "Bad WEP key length %d\n", keyconf->keylen);\r\nreturn -EINVAL;\r\n}\r\nkeyconf->flags &= ~IEEE80211_KEY_FLAG_GENERATE_IV;\r\nkeyconf->hw_key_idx = HW_KEY_DEFAULT;\r\npriv->stations[ctx->ap_sta_id].keyinfo.cipher = keyconf->cipher;\r\nctx->wep_keys[keyconf->keyidx].key_size = keyconf->keylen;\r\nmemcpy(&ctx->wep_keys[keyconf->keyidx].key, &keyconf->key,\r\nkeyconf->keylen);\r\nret = iwl4965_static_wepkey_cmd(priv, ctx, false);\r\nIWL_DEBUG_WEP(priv, "Set default WEP key: len=%d idx=%d ret=%d\n",\r\nkeyconf->keylen, keyconf->keyidx, ret);\r\nreturn ret;\r\n}\r\nstatic int iwl4965_set_wep_dynamic_key_info(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct ieee80211_key_conf *keyconf,\r\nu8 sta_id)\r\n{\r\nunsigned long flags;\r\n__le16 key_flags = 0;\r\nstruct iwl_legacy_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&priv->mutex);\r\nkeyconf->flags &= ~IEEE80211_KEY_FLAG_GENERATE_IV;\r\nkey_flags |= (STA_KEY_FLG_WEP | STA_KEY_FLG_MAP_KEY_MSK);\r\nkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\r\nkey_flags &= ~STA_KEY_FLG_INVALID;\r\nif (keyconf->keylen == WEP_KEY_LEN_128)\r\nkey_flags |= STA_KEY_FLG_KEY_SIZE_MSK;\r\nif (sta_id == ctx->bcast_sta_id)\r\nkey_flags |= STA_KEY_MULTICAST_MSK;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].keyinfo.cipher = keyconf->cipher;\r\npriv->stations[sta_id].keyinfo.keylen = keyconf->keylen;\r\npriv->stations[sta_id].keyinfo.keyidx = keyconf->keyidx;\r\nmemcpy(priv->stations[sta_id].keyinfo.key,\r\nkeyconf->key, keyconf->keylen);\r\nmemcpy(&priv->stations[sta_id].sta.key.key[3],\r\nkeyconf->key, keyconf->keylen);\r\nif ((priv->stations[sta_id].sta.key.key_flags & STA_KEY_FLG_ENCRYPT_MSK)\r\n== STA_KEY_FLG_NO_ENC)\r\npriv->stations[sta_id].sta.key.key_offset =\r\niwl_legacy_get_free_ucode_key_index(priv);\r\nWARN(priv->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\r\n"no space for a new key");\r\npriv->stations[sta_id].sta.key.key_flags = key_flags;\r\npriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\npriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &priv->stations[sta_id].sta,\r\nsizeof(struct iwl_legacy_addsta_cmd));\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn iwl_legacy_send_add_sta(priv, &sta_cmd, CMD_SYNC);\r\n}\r\nstatic int iwl4965_set_ccmp_dynamic_key_info(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct ieee80211_key_conf *keyconf,\r\nu8 sta_id)\r\n{\r\nunsigned long flags;\r\n__le16 key_flags = 0;\r\nstruct iwl_legacy_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&priv->mutex);\r\nkey_flags |= (STA_KEY_FLG_CCMP | STA_KEY_FLG_MAP_KEY_MSK);\r\nkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\r\nkey_flags &= ~STA_KEY_FLG_INVALID;\r\nif (sta_id == ctx->bcast_sta_id)\r\nkey_flags |= STA_KEY_MULTICAST_MSK;\r\nkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].keyinfo.cipher = keyconf->cipher;\r\npriv->stations[sta_id].keyinfo.keylen = keyconf->keylen;\r\nmemcpy(priv->stations[sta_id].keyinfo.key, keyconf->key,\r\nkeyconf->keylen);\r\nmemcpy(priv->stations[sta_id].sta.key.key, keyconf->key,\r\nkeyconf->keylen);\r\nif ((priv->stations[sta_id].sta.key.key_flags & STA_KEY_FLG_ENCRYPT_MSK)\r\n== STA_KEY_FLG_NO_ENC)\r\npriv->stations[sta_id].sta.key.key_offset =\r\niwl_legacy_get_free_ucode_key_index(priv);\r\nWARN(priv->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\r\n"no space for a new key");\r\npriv->stations[sta_id].sta.key.key_flags = key_flags;\r\npriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\npriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &priv->stations[sta_id].sta,\r\nsizeof(struct iwl_legacy_addsta_cmd));\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn iwl_legacy_send_add_sta(priv, &sta_cmd, CMD_SYNC);\r\n}\r\nstatic int iwl4965_set_tkip_dynamic_key_info(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct ieee80211_key_conf *keyconf,\r\nu8 sta_id)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\n__le16 key_flags = 0;\r\nkey_flags |= (STA_KEY_FLG_TKIP | STA_KEY_FLG_MAP_KEY_MSK);\r\nkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\r\nkey_flags &= ~STA_KEY_FLG_INVALID;\r\nif (sta_id == ctx->bcast_sta_id)\r\nkey_flags |= STA_KEY_MULTICAST_MSK;\r\nkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].keyinfo.cipher = keyconf->cipher;\r\npriv->stations[sta_id].keyinfo.keylen = 16;\r\nif ((priv->stations[sta_id].sta.key.key_flags & STA_KEY_FLG_ENCRYPT_MSK)\r\n== STA_KEY_FLG_NO_ENC)\r\npriv->stations[sta_id].sta.key.key_offset =\r\niwl_legacy_get_free_ucode_key_index(priv);\r\nWARN(priv->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\r\n"no space for a new key");\r\npriv->stations[sta_id].sta.key.key_flags = key_flags;\r\nmemcpy(priv->stations[sta_id].keyinfo.key, keyconf->key, 16);\r\nmemcpy(priv->stations[sta_id].sta.key.key, keyconf->key, 16);\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn ret;\r\n}\r\nvoid iwl4965_update_tkip_key(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct ieee80211_key_conf *keyconf,\r\nstruct ieee80211_sta *sta, u32 iv32, u16 *phase1key)\r\n{\r\nu8 sta_id;\r\nunsigned long flags;\r\nint i;\r\nif (iwl_legacy_scan_cancel(priv)) {\r\nreturn;\r\n}\r\nsta_id = iwl_legacy_sta_id_or_broadcast(priv, ctx, sta);\r\nif (sta_id == IWL_INVALID_STATION)\r\nreturn;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].sta.key.tkip_rx_tsc_byte2 = (u8) iv32;\r\nfor (i = 0; i < 5; i++)\r\npriv->stations[sta_id].sta.key.tkip_rx_ttak[i] =\r\ncpu_to_le16(phase1key[i]);\r\npriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\npriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\niwl_legacy_send_add_sta(priv, &priv->stations[sta_id].sta, CMD_ASYNC);\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\n}\r\nint iwl4965_remove_dynamic_key(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct ieee80211_key_conf *keyconf,\r\nu8 sta_id)\r\n{\r\nunsigned long flags;\r\nu16 key_flags;\r\nu8 keyidx;\r\nstruct iwl_legacy_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&priv->mutex);\r\nctx->key_mapping_keys--;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\nkey_flags = le16_to_cpu(priv->stations[sta_id].sta.key.key_flags);\r\nkeyidx = (key_flags >> STA_KEY_FLG_KEYID_POS) & 0x3;\r\nIWL_DEBUG_WEP(priv, "Remove dynamic key: idx=%d sta=%d\n",\r\nkeyconf->keyidx, sta_id);\r\nif (keyconf->keyidx != keyidx) {\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn 0;\r\n}\r\nif (priv->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET) {\r\nIWL_WARN(priv, "Removing wrong key %d 0x%x\n",\r\nkeyconf->keyidx, key_flags);\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn 0;\r\n}\r\nif (!test_and_clear_bit(priv->stations[sta_id].sta.key.key_offset,\r\n&priv->ucode_key_table))\r\nIWL_ERR(priv, "index %d not used in uCode key table.\n",\r\npriv->stations[sta_id].sta.key.key_offset);\r\nmemset(&priv->stations[sta_id].keyinfo, 0,\r\nsizeof(struct iwl_hw_key));\r\nmemset(&priv->stations[sta_id].sta.key, 0,\r\nsizeof(struct iwl4965_keyinfo));\r\npriv->stations[sta_id].sta.key.key_flags =\r\nSTA_KEY_FLG_NO_ENC | STA_KEY_FLG_INVALID;\r\npriv->stations[sta_id].sta.key.key_offset = WEP_INVALID_OFFSET;\r\npriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\npriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nif (iwl_legacy_is_rfkill(priv)) {\r\nIWL_DEBUG_WEP(priv,\r\n"Not sending REPLY_ADD_STA command because RFKILL enabled.\n");\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn 0;\r\n}\r\nmemcpy(&sta_cmd, &priv->stations[sta_id].sta,\r\nsizeof(struct iwl_legacy_addsta_cmd));\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn iwl_legacy_send_add_sta(priv, &sta_cmd, CMD_SYNC);\r\n}\r\nint iwl4965_set_dynamic_key(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\r\nstruct ieee80211_key_conf *keyconf, u8 sta_id)\r\n{\r\nint ret;\r\nlockdep_assert_held(&priv->mutex);\r\nctx->key_mapping_keys++;\r\nkeyconf->hw_key_idx = HW_KEY_DYNAMIC;\r\nswitch (keyconf->cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nret = iwl4965_set_ccmp_dynamic_key_info(priv, ctx,\r\nkeyconf, sta_id);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nret = iwl4965_set_tkip_dynamic_key_info(priv, ctx,\r\nkeyconf, sta_id);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nret = iwl4965_set_wep_dynamic_key_info(priv, ctx,\r\nkeyconf, sta_id);\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv,\r\n"Unknown alg: %s cipher = %x\n", __func__,\r\nkeyconf->cipher);\r\nret = -EINVAL;\r\n}\r\nIWL_DEBUG_WEP(priv,\r\n"Set dynamic key: cipher=%x len=%d idx=%d sta=%d ret=%d\n",\r\nkeyconf->cipher, keyconf->keylen, keyconf->keyidx,\r\nsta_id, ret);\r\nreturn ret;\r\n}\r\nint iwl4965_alloc_bcast_station(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nstruct iwl_link_quality_cmd *link_cmd;\r\nunsigned long flags;\r\nu8 sta_id;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\nsta_id = iwl_legacy_prep_station(priv, ctx, iwlegacy_bcast_addr,\r\nfalse, NULL);\r\nif (sta_id == IWL_INVALID_STATION) {\r\nIWL_ERR(priv, "Unable to prepare broadcast station\n");\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn -EINVAL;\r\n}\r\npriv->stations[sta_id].used |= IWL_STA_DRIVER_ACTIVE;\r\npriv->stations[sta_id].used |= IWL_STA_BCAST;\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nlink_cmd = iwl4965_sta_alloc_lq(priv, sta_id);\r\nif (!link_cmd) {\r\nIWL_ERR(priv,\r\n"Unable to initialize rate scaling for bcast station.\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].lq = link_cmd;\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int iwl4965_update_bcast_station(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nunsigned long flags;\r\nstruct iwl_link_quality_cmd *link_cmd;\r\nu8 sta_id = ctx->bcast_sta_id;\r\nlink_cmd = iwl4965_sta_alloc_lq(priv, sta_id);\r\nif (!link_cmd) {\r\nIWL_ERR(priv,\r\n"Unable to initialize rate scaling for bcast station.\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\nif (priv->stations[sta_id].lq)\r\nkfree(priv->stations[sta_id].lq);\r\nelse\r\nIWL_DEBUG_INFO(priv,\r\n"Bcast station rate scaling has not been initialized yet.\n");\r\npriv->stations[sta_id].lq = link_cmd;\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn 0;\r\n}\r\nint iwl4965_update_bcast_stations(struct iwl_priv *priv)\r\n{\r\nstruct iwl_rxon_context *ctx;\r\nint ret = 0;\r\nfor_each_context(priv, ctx) {\r\nret = iwl4965_update_bcast_station(priv, ctx);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint iwl4965_sta_tx_modify_enable_tid(struct iwl_priv *priv, int sta_id, int tid)\r\n{\r\nunsigned long flags;\r\nstruct iwl_legacy_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&priv->mutex);\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_TID_DISABLE_TX;\r\npriv->stations[sta_id].sta.tid_disable_tx &= cpu_to_le16(~(1 << tid));\r\npriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &priv->stations[sta_id].sta,\r\nsizeof(struct iwl_legacy_addsta_cmd));\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn iwl_legacy_send_add_sta(priv, &sta_cmd, CMD_SYNC);\r\n}\r\nint iwl4965_sta_rx_agg_start(struct iwl_priv *priv, struct ieee80211_sta *sta,\r\nint tid, u16 ssn)\r\n{\r\nunsigned long flags;\r\nint sta_id;\r\nstruct iwl_legacy_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&priv->mutex);\r\nsta_id = iwl_legacy_sta_id(sta);\r\nif (sta_id == IWL_INVALID_STATION)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].sta.station_flags_msk = 0;\r\npriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_ADDBA_TID_MSK;\r\npriv->stations[sta_id].sta.add_immediate_ba_tid = (u8)tid;\r\npriv->stations[sta_id].sta.add_immediate_ba_ssn = cpu_to_le16(ssn);\r\npriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &priv->stations[sta_id].sta,\r\nsizeof(struct iwl_legacy_addsta_cmd));\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn iwl_legacy_send_add_sta(priv, &sta_cmd, CMD_SYNC);\r\n}\r\nint iwl4965_sta_rx_agg_stop(struct iwl_priv *priv, struct ieee80211_sta *sta,\r\nint tid)\r\n{\r\nunsigned long flags;\r\nint sta_id;\r\nstruct iwl_legacy_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&priv->mutex);\r\nsta_id = iwl_legacy_sta_id(sta);\r\nif (sta_id == IWL_INVALID_STATION) {\r\nIWL_ERR(priv, "Invalid station for AGG tid %d\n", tid);\r\nreturn -ENXIO;\r\n}\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].sta.station_flags_msk = 0;\r\npriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_DELBA_TID_MSK;\r\npriv->stations[sta_id].sta.remove_immediate_ba_tid = (u8)tid;\r\npriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &priv->stations[sta_id].sta,\r\nsizeof(struct iwl_legacy_addsta_cmd));\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\nreturn iwl_legacy_send_add_sta(priv, &sta_cmd, CMD_SYNC);\r\n}\r\nvoid\r\niwl4965_sta_modify_sleep_tx_count(struct iwl_priv *priv, int sta_id, int cnt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->sta_lock, flags);\r\npriv->stations[sta_id].sta.station_flags |= STA_FLG_PWR_SAVE_MSK;\r\npriv->stations[sta_id].sta.station_flags_msk = STA_FLG_PWR_SAVE_MSK;\r\npriv->stations[sta_id].sta.sta.modify_mask =\r\nSTA_MODIFY_SLEEP_TX_COUNT_MSK;\r\npriv->stations[sta_id].sta.sleep_tx_count = cpu_to_le16(cnt);\r\npriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\niwl_legacy_send_add_sta(priv,\r\n&priv->stations[sta_id].sta, CMD_ASYNC);\r\nspin_unlock_irqrestore(&priv->sta_lock, flags);\r\n}
