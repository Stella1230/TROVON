static inline void wf_notify(int event, void *param)\r\n{\r\nblocking_notifier_call_chain(&wf_client_list, event, param);\r\n}\r\nint wf_critical_overtemp(void)\r\n{\r\nstatic char * critical_overtemp_path = "/sbin/critical_overtemp";\r\nchar *argv[] = { critical_overtemp_path, NULL };\r\nstatic char *envp[] = { "HOME=/",\r\n"TERM=linux",\r\n"PATH=/sbin:/usr/sbin:/bin:/usr/bin",\r\nNULL };\r\nreturn call_usermodehelper(critical_overtemp_path,\r\nargv, envp, UMH_WAIT_EXEC);\r\n}\r\nstatic int wf_thread_func(void *data)\r\n{\r\nunsigned long next, delay;\r\nnext = jiffies;\r\nDBG("wf: thread started\n");\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\ntry_to_freeze();\r\nif (time_after_eq(jiffies, next)) {\r\nwf_notify(WF_EVENT_TICK, NULL);\r\nif (wf_overtemp) {\r\nwf_overtemp_counter++;\r\nif (wf_overtemp_counter > 10)\r\nwf_critical_overtemp();\r\nif (wf_overtemp_counter > 30) {\r\nprintk(KERN_ERR "windfarm: Overtemp "\r\n"for more than 30"\r\n" seconds, shutting down\n");\r\nmachine_power_off();\r\n}\r\n}\r\nnext += HZ;\r\n}\r\ndelay = next - jiffies;\r\nif (delay <= HZ)\r\nschedule_timeout_interruptible(delay);\r\n}\r\nDBG("wf: thread stopped\n");\r\nreturn 0;\r\n}\r\nstatic void wf_start_thread(void)\r\n{\r\nwf_thread = kthread_run(wf_thread_func, NULL, "kwindfarm");\r\nif (IS_ERR(wf_thread)) {\r\nprintk(KERN_ERR "windfarm: failed to create thread,err %ld\n",\r\nPTR_ERR(wf_thread));\r\nwf_thread = NULL;\r\n}\r\n}\r\nstatic void wf_stop_thread(void)\r\n{\r\nif (wf_thread)\r\nkthread_stop(wf_thread);\r\nwf_thread = NULL;\r\n}\r\nstatic void wf_control_release(struct kref *kref)\r\n{\r\nstruct wf_control *ct = container_of(kref, struct wf_control, ref);\r\nDBG("wf: Deleting control %s\n", ct->name);\r\nif (ct->ops && ct->ops->release)\r\nct->ops->release(ct);\r\nelse\r\nkfree(ct);\r\n}\r\nstatic ssize_t wf_show_control(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct wf_control *ctrl = container_of(attr, struct wf_control, attr);\r\ns32 val = 0;\r\nint err;\r\nerr = ctrl->ops->get_value(ctrl, &val);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t wf_store_control(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct wf_control *ctrl = container_of(attr, struct wf_control, attr);\r\nint val;\r\nint err;\r\nchar *endp;\r\nval = simple_strtoul(buf, &endp, 0);\r\nwhile (endp < buf + count && (*endp == ' ' || *endp == '\n'))\r\n++endp;\r\nif (endp - buf < count)\r\nreturn -EINVAL;\r\nerr = ctrl->ops->set_value(ctrl, val);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nint wf_register_control(struct wf_control *new_ct)\r\n{\r\nstruct wf_control *ct;\r\nmutex_lock(&wf_lock);\r\nlist_for_each_entry(ct, &wf_controls, link) {\r\nif (!strcmp(ct->name, new_ct->name)) {\r\nprintk(KERN_WARNING "windfarm: trying to register"\r\n" duplicate control %s\n", ct->name);\r\nmutex_unlock(&wf_lock);\r\nreturn -EEXIST;\r\n}\r\n}\r\nkref_init(&new_ct->ref);\r\nlist_add(&new_ct->link, &wf_controls);\r\nsysfs_attr_init(&new_ct->attr.attr);\r\nnew_ct->attr.attr.name = new_ct->name;\r\nnew_ct->attr.attr.mode = 0644;\r\nnew_ct->attr.show = wf_show_control;\r\nnew_ct->attr.store = wf_store_control;\r\nif (device_create_file(&wf_platform_device.dev, &new_ct->attr))\r\nprintk(KERN_WARNING "windfarm: device_create_file failed"\r\n" for %s\n", new_ct->name);\r\nDBG("wf: Registered control %s\n", new_ct->name);\r\nwf_notify(WF_EVENT_NEW_CONTROL, new_ct);\r\nmutex_unlock(&wf_lock);\r\nreturn 0;\r\n}\r\nvoid wf_unregister_control(struct wf_control *ct)\r\n{\r\nmutex_lock(&wf_lock);\r\nlist_del(&ct->link);\r\nmutex_unlock(&wf_lock);\r\nDBG("wf: Unregistered control %s\n", ct->name);\r\nkref_put(&ct->ref, wf_control_release);\r\n}\r\nstruct wf_control * wf_find_control(const char *name)\r\n{\r\nstruct wf_control *ct;\r\nmutex_lock(&wf_lock);\r\nlist_for_each_entry(ct, &wf_controls, link) {\r\nif (!strcmp(ct->name, name)) {\r\nif (wf_get_control(ct))\r\nct = NULL;\r\nmutex_unlock(&wf_lock);\r\nreturn ct;\r\n}\r\n}\r\nmutex_unlock(&wf_lock);\r\nreturn NULL;\r\n}\r\nint wf_get_control(struct wf_control *ct)\r\n{\r\nif (!try_module_get(ct->ops->owner))\r\nreturn -ENODEV;\r\nkref_get(&ct->ref);\r\nreturn 0;\r\n}\r\nvoid wf_put_control(struct wf_control *ct)\r\n{\r\nstruct module *mod = ct->ops->owner;\r\nkref_put(&ct->ref, wf_control_release);\r\nmodule_put(mod);\r\n}\r\nstatic void wf_sensor_release(struct kref *kref)\r\n{\r\nstruct wf_sensor *sr = container_of(kref, struct wf_sensor, ref);\r\nDBG("wf: Deleting sensor %s\n", sr->name);\r\nif (sr->ops && sr->ops->release)\r\nsr->ops->release(sr);\r\nelse\r\nkfree(sr);\r\n}\r\nstatic ssize_t wf_show_sensor(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct wf_sensor *sens = container_of(attr, struct wf_sensor, attr);\r\ns32 val = 0;\r\nint err;\r\nerr = sens->ops->get_value(sens, &val);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%d.%03d\n", FIX32TOPRINT(val));\r\n}\r\nint wf_register_sensor(struct wf_sensor *new_sr)\r\n{\r\nstruct wf_sensor *sr;\r\nmutex_lock(&wf_lock);\r\nlist_for_each_entry(sr, &wf_sensors, link) {\r\nif (!strcmp(sr->name, new_sr->name)) {\r\nprintk(KERN_WARNING "windfarm: trying to register"\r\n" duplicate sensor %s\n", sr->name);\r\nmutex_unlock(&wf_lock);\r\nreturn -EEXIST;\r\n}\r\n}\r\nkref_init(&new_sr->ref);\r\nlist_add(&new_sr->link, &wf_sensors);\r\nsysfs_attr_init(&new_sr->attr.attr);\r\nnew_sr->attr.attr.name = new_sr->name;\r\nnew_sr->attr.attr.mode = 0444;\r\nnew_sr->attr.show = wf_show_sensor;\r\nnew_sr->attr.store = NULL;\r\nif (device_create_file(&wf_platform_device.dev, &new_sr->attr))\r\nprintk(KERN_WARNING "windfarm: device_create_file failed"\r\n" for %s\n", new_sr->name);\r\nDBG("wf: Registered sensor %s\n", new_sr->name);\r\nwf_notify(WF_EVENT_NEW_SENSOR, new_sr);\r\nmutex_unlock(&wf_lock);\r\nreturn 0;\r\n}\r\nvoid wf_unregister_sensor(struct wf_sensor *sr)\r\n{\r\nmutex_lock(&wf_lock);\r\nlist_del(&sr->link);\r\nmutex_unlock(&wf_lock);\r\nDBG("wf: Unregistered sensor %s\n", sr->name);\r\nwf_put_sensor(sr);\r\n}\r\nstruct wf_sensor * wf_find_sensor(const char *name)\r\n{\r\nstruct wf_sensor *sr;\r\nmutex_lock(&wf_lock);\r\nlist_for_each_entry(sr, &wf_sensors, link) {\r\nif (!strcmp(sr->name, name)) {\r\nif (wf_get_sensor(sr))\r\nsr = NULL;\r\nmutex_unlock(&wf_lock);\r\nreturn sr;\r\n}\r\n}\r\nmutex_unlock(&wf_lock);\r\nreturn NULL;\r\n}\r\nint wf_get_sensor(struct wf_sensor *sr)\r\n{\r\nif (!try_module_get(sr->ops->owner))\r\nreturn -ENODEV;\r\nkref_get(&sr->ref);\r\nreturn 0;\r\n}\r\nvoid wf_put_sensor(struct wf_sensor *sr)\r\n{\r\nstruct module *mod = sr->ops->owner;\r\nkref_put(&sr->ref, wf_sensor_release);\r\nmodule_put(mod);\r\n}\r\nint wf_register_client(struct notifier_block *nb)\r\n{\r\nint rc;\r\nstruct wf_control *ct;\r\nstruct wf_sensor *sr;\r\nmutex_lock(&wf_lock);\r\nrc = blocking_notifier_chain_register(&wf_client_list, nb);\r\nif (rc != 0)\r\ngoto bail;\r\nwf_client_count++;\r\nlist_for_each_entry(ct, &wf_controls, link)\r\nwf_notify(WF_EVENT_NEW_CONTROL, ct);\r\nlist_for_each_entry(sr, &wf_sensors, link)\r\nwf_notify(WF_EVENT_NEW_SENSOR, sr);\r\nif (wf_client_count == 1)\r\nwf_start_thread();\r\nbail:\r\nmutex_unlock(&wf_lock);\r\nreturn rc;\r\n}\r\nint wf_unregister_client(struct notifier_block *nb)\r\n{\r\nmutex_lock(&wf_lock);\r\nblocking_notifier_chain_unregister(&wf_client_list, nb);\r\nwf_client_count++;\r\nif (wf_client_count == 0)\r\nwf_stop_thread();\r\nmutex_unlock(&wf_lock);\r\nreturn 0;\r\n}\r\nvoid wf_set_overtemp(void)\r\n{\r\nmutex_lock(&wf_lock);\r\nwf_overtemp++;\r\nif (wf_overtemp == 1) {\r\nprintk(KERN_WARNING "windfarm: Overtemp condition detected !\n");\r\nwf_overtemp_counter = 0;\r\nwf_notify(WF_EVENT_OVERTEMP, NULL);\r\n}\r\nmutex_unlock(&wf_lock);\r\n}\r\nvoid wf_clear_overtemp(void)\r\n{\r\nmutex_lock(&wf_lock);\r\nWARN_ON(wf_overtemp == 0);\r\nif (wf_overtemp == 0) {\r\nmutex_unlock(&wf_lock);\r\nreturn;\r\n}\r\nwf_overtemp--;\r\nif (wf_overtemp == 0) {\r\nprintk(KERN_WARNING "windfarm: Overtemp condition cleared !\n");\r\nwf_notify(WF_EVENT_NORMALTEMP, NULL);\r\n}\r\nmutex_unlock(&wf_lock);\r\n}\r\nint wf_is_overtemp(void)\r\n{\r\nreturn (wf_overtemp != 0);\r\n}\r\nstatic int __init windfarm_core_init(void)\r\n{\r\nDBG("wf: core loaded\n");\r\nif (of_machine_is_compatible("PowerMac7,2") ||\r\nof_machine_is_compatible("PowerMac7,3") ||\r\nof_machine_is_compatible("RackMac3,1"))\r\nreturn -ENODEV;\r\nplatform_device_register(&wf_platform_device);\r\nreturn 0;\r\n}\r\nstatic void __exit windfarm_core_exit(void)\r\n{\r\nBUG_ON(wf_client_count != 0);\r\nDBG("wf: core unloaded\n");\r\nplatform_device_unregister(&wf_platform_device);\r\n}
