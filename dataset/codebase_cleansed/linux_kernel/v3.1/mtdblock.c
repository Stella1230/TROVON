static void erase_callback(struct erase_info *done)\r\n{\r\nwait_queue_head_t *wait_q = (wait_queue_head_t *)done->priv;\r\nwake_up(wait_q);\r\n}\r\nstatic int erase_write (struct mtd_info *mtd, unsigned long pos,\r\nint len, const char *buf)\r\n{\r\nstruct erase_info erase;\r\nDECLARE_WAITQUEUE(wait, current);\r\nwait_queue_head_t wait_q;\r\nsize_t retlen;\r\nint ret;\r\ninit_waitqueue_head(&wait_q);\r\nerase.mtd = mtd;\r\nerase.callback = erase_callback;\r\nerase.addr = pos;\r\nerase.len = len;\r\nerase.priv = (u_long)&wait_q;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&wait_q, &wait);\r\nret = mtd->erase(mtd, &erase);\r\nif (ret) {\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&wait_q, &wait);\r\nprintk (KERN_WARNING "mtdblock: erase of region [0x%lx, 0x%x] "\r\n"on \"%s\" failed\n",\r\npos, len, mtd->name);\r\nreturn ret;\r\n}\r\nschedule();\r\nremove_wait_queue(&wait_q, &wait);\r\nret = mtd->write(mtd, pos, len, &retlen, buf);\r\nif (ret)\r\nreturn ret;\r\nif (retlen != len)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int write_cached_data (struct mtdblk_dev *mtdblk)\r\n{\r\nstruct mtd_info *mtd = mtdblk->mbd.mtd;\r\nint ret;\r\nif (mtdblk->cache_state != STATE_DIRTY)\r\nreturn 0;\r\nDEBUG(MTD_DEBUG_LEVEL2, "mtdblock: writing cached data for \"%s\" "\r\n"at 0x%lx, size 0x%x\n", mtd->name,\r\nmtdblk->cache_offset, mtdblk->cache_size);\r\nret = erase_write (mtd, mtdblk->cache_offset,\r\nmtdblk->cache_size, mtdblk->cache_data);\r\nif (ret)\r\nreturn ret;\r\nmtdblk->cache_state = STATE_EMPTY;\r\nreturn 0;\r\n}\r\nstatic int do_cached_write (struct mtdblk_dev *mtdblk, unsigned long pos,\r\nint len, const char *buf)\r\n{\r\nstruct mtd_info *mtd = mtdblk->mbd.mtd;\r\nunsigned int sect_size = mtdblk->cache_size;\r\nsize_t retlen;\r\nint ret;\r\nDEBUG(MTD_DEBUG_LEVEL2, "mtdblock: write on \"%s\" at 0x%lx, size 0x%x\n",\r\nmtd->name, pos, len);\r\nif (!sect_size)\r\nreturn mtd->write(mtd, pos, len, &retlen, buf);\r\nwhile (len > 0) {\r\nunsigned long sect_start = (pos/sect_size)*sect_size;\r\nunsigned int offset = pos - sect_start;\r\nunsigned int size = sect_size - offset;\r\nif( size > len )\r\nsize = len;\r\nif (size == sect_size) {\r\nret = erase_write (mtd, pos, size, buf);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nif (mtdblk->cache_state == STATE_DIRTY &&\r\nmtdblk->cache_offset != sect_start) {\r\nret = write_cached_data(mtdblk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (mtdblk->cache_state == STATE_EMPTY ||\r\nmtdblk->cache_offset != sect_start) {\r\nmtdblk->cache_state = STATE_EMPTY;\r\nret = mtd->read(mtd, sect_start, sect_size,\r\n&retlen, mtdblk->cache_data);\r\nif (ret)\r\nreturn ret;\r\nif (retlen != sect_size)\r\nreturn -EIO;\r\nmtdblk->cache_offset = sect_start;\r\nmtdblk->cache_size = sect_size;\r\nmtdblk->cache_state = STATE_CLEAN;\r\n}\r\nmemcpy (mtdblk->cache_data + offset, buf, size);\r\nmtdblk->cache_state = STATE_DIRTY;\r\n}\r\nbuf += size;\r\npos += size;\r\nlen -= size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_cached_read (struct mtdblk_dev *mtdblk, unsigned long pos,\r\nint len, char *buf)\r\n{\r\nstruct mtd_info *mtd = mtdblk->mbd.mtd;\r\nunsigned int sect_size = mtdblk->cache_size;\r\nsize_t retlen;\r\nint ret;\r\nDEBUG(MTD_DEBUG_LEVEL2, "mtdblock: read on \"%s\" at 0x%lx, size 0x%x\n",\r\nmtd->name, pos, len);\r\nif (!sect_size)\r\nreturn mtd->read(mtd, pos, len, &retlen, buf);\r\nwhile (len > 0) {\r\nunsigned long sect_start = (pos/sect_size)*sect_size;\r\nunsigned int offset = pos - sect_start;\r\nunsigned int size = sect_size - offset;\r\nif (size > len)\r\nsize = len;\r\nif (mtdblk->cache_state != STATE_EMPTY &&\r\nmtdblk->cache_offset == sect_start) {\r\nmemcpy (buf, mtdblk->cache_data + offset, size);\r\n} else {\r\nret = mtd->read(mtd, pos, size, &retlen, buf);\r\nif (ret)\r\nreturn ret;\r\nif (retlen != size)\r\nreturn -EIO;\r\n}\r\nbuf += size;\r\npos += size;\r\nlen -= size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtdblock_readsect(struct mtd_blktrans_dev *dev,\r\nunsigned long block, char *buf)\r\n{\r\nstruct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);\r\nreturn do_cached_read(mtdblk, block<<9, 512, buf);\r\n}\r\nstatic int mtdblock_writesect(struct mtd_blktrans_dev *dev,\r\nunsigned long block, char *buf)\r\n{\r\nstruct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);\r\nif (unlikely(!mtdblk->cache_data && mtdblk->cache_size)) {\r\nmtdblk->cache_data = vmalloc(mtdblk->mbd.mtd->erasesize);\r\nif (!mtdblk->cache_data)\r\nreturn -EINTR;\r\n}\r\nreturn do_cached_write(mtdblk, block<<9, 512, buf);\r\n}\r\nstatic int mtdblock_open(struct mtd_blktrans_dev *mbd)\r\n{\r\nstruct mtdblk_dev *mtdblk = container_of(mbd, struct mtdblk_dev, mbd);\r\nDEBUG(MTD_DEBUG_LEVEL1,"mtdblock_open\n");\r\nmutex_lock(&mtdblks_lock);\r\nif (mtdblk->count) {\r\nmtdblk->count++;\r\nmutex_unlock(&mtdblks_lock);\r\nreturn 0;\r\n}\r\nmtdblk->count = 1;\r\nmutex_init(&mtdblk->cache_mutex);\r\nmtdblk->cache_state = STATE_EMPTY;\r\nif (!(mbd->mtd->flags & MTD_NO_ERASE) && mbd->mtd->erasesize) {\r\nmtdblk->cache_size = mbd->mtd->erasesize;\r\nmtdblk->cache_data = NULL;\r\n}\r\nmutex_unlock(&mtdblks_lock);\r\nDEBUG(MTD_DEBUG_LEVEL1, "ok\n");\r\nreturn 0;\r\n}\r\nstatic int mtdblock_release(struct mtd_blktrans_dev *mbd)\r\n{\r\nstruct mtdblk_dev *mtdblk = container_of(mbd, struct mtdblk_dev, mbd);\r\nDEBUG(MTD_DEBUG_LEVEL1, "mtdblock_release\n");\r\nmutex_lock(&mtdblks_lock);\r\nmutex_lock(&mtdblk->cache_mutex);\r\nwrite_cached_data(mtdblk);\r\nmutex_unlock(&mtdblk->cache_mutex);\r\nif (!--mtdblk->count) {\r\nif (mbd->mtd->sync)\r\nmbd->mtd->sync(mbd->mtd);\r\nvfree(mtdblk->cache_data);\r\n}\r\nmutex_unlock(&mtdblks_lock);\r\nDEBUG(MTD_DEBUG_LEVEL1, "ok\n");\r\nreturn 0;\r\n}\r\nstatic int mtdblock_flush(struct mtd_blktrans_dev *dev)\r\n{\r\nstruct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);\r\nmutex_lock(&mtdblk->cache_mutex);\r\nwrite_cached_data(mtdblk);\r\nmutex_unlock(&mtdblk->cache_mutex);\r\nif (dev->mtd->sync)\r\ndev->mtd->sync(dev->mtd);\r\nreturn 0;\r\n}\r\nstatic void mtdblock_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\r\n{\r\nstruct mtdblk_dev *dev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn;\r\ndev->mbd.mtd = mtd;\r\ndev->mbd.devnum = mtd->index;\r\ndev->mbd.size = mtd->size >> 9;\r\ndev->mbd.tr = tr;\r\nif (!(mtd->flags & MTD_WRITEABLE))\r\ndev->mbd.readonly = 1;\r\nif (add_mtd_blktrans_dev(&dev->mbd))\r\nkfree(dev);\r\n}\r\nstatic void mtdblock_remove_dev(struct mtd_blktrans_dev *dev)\r\n{\r\ndel_mtd_blktrans_dev(dev);\r\n}\r\nstatic int __init init_mtdblock(void)\r\n{\r\nmutex_init(&mtdblks_lock);\r\nreturn register_mtd_blktrans(&mtdblock_tr);\r\n}\r\nstatic void __exit cleanup_mtdblock(void)\r\n{\r\nderegister_mtd_blktrans(&mtdblock_tr);\r\n}
