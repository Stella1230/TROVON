static int __pcf50633_read(struct pcf50633 *pcf, u8 reg, int num, u8 *data)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_i2c_block_data(pcf->i2c_client, reg,\r\nnum, data);\r\nif (ret < 0)\r\ndev_err(pcf->dev, "Error reading %d regs at %d\n", num, reg);\r\nreturn ret;\r\n}\r\nstatic int __pcf50633_write(struct pcf50633 *pcf, u8 reg, int num, u8 *data)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_i2c_block_data(pcf->i2c_client, reg,\r\nnum, data);\r\nif (ret < 0)\r\ndev_err(pcf->dev, "Error writing %d regs at %d\n", num, reg);\r\nreturn ret;\r\n}\r\nint pcf50633_read_block(struct pcf50633 *pcf, u8 reg,\r\nint nr_regs, u8 *data)\r\n{\r\nint ret;\r\nmutex_lock(&pcf->lock);\r\nret = __pcf50633_read(pcf, reg, nr_regs, data);\r\nmutex_unlock(&pcf->lock);\r\nreturn ret;\r\n}\r\nint pcf50633_write_block(struct pcf50633 *pcf , u8 reg,\r\nint nr_regs, u8 *data)\r\n{\r\nint ret;\r\nmutex_lock(&pcf->lock);\r\nret = __pcf50633_write(pcf, reg, nr_regs, data);\r\nmutex_unlock(&pcf->lock);\r\nreturn ret;\r\n}\r\nu8 pcf50633_reg_read(struct pcf50633 *pcf, u8 reg)\r\n{\r\nu8 val;\r\nmutex_lock(&pcf->lock);\r\n__pcf50633_read(pcf, reg, 1, &val);\r\nmutex_unlock(&pcf->lock);\r\nreturn val;\r\n}\r\nint pcf50633_reg_write(struct pcf50633 *pcf, u8 reg, u8 val)\r\n{\r\nint ret;\r\nmutex_lock(&pcf->lock);\r\nret = __pcf50633_write(pcf, reg, 1, &val);\r\nmutex_unlock(&pcf->lock);\r\nreturn ret;\r\n}\r\nint pcf50633_reg_set_bit_mask(struct pcf50633 *pcf, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nu8 tmp;\r\nval &= mask;\r\nmutex_lock(&pcf->lock);\r\nret = __pcf50633_read(pcf, reg, 1, &tmp);\r\nif (ret < 0)\r\ngoto out;\r\ntmp &= ~mask;\r\ntmp |= val;\r\nret = __pcf50633_write(pcf, reg, 1, &tmp);\r\nout:\r\nmutex_unlock(&pcf->lock);\r\nreturn ret;\r\n}\r\nint pcf50633_reg_clear_bits(struct pcf50633 *pcf, u8 reg, u8 val)\r\n{\r\nint ret;\r\nu8 tmp;\r\nmutex_lock(&pcf->lock);\r\nret = __pcf50633_read(pcf, reg, 1, &tmp);\r\nif (ret < 0)\r\ngoto out;\r\ntmp &= ~val;\r\nret = __pcf50633_write(pcf, reg, 1, &tmp);\r\nout:\r\nmutex_unlock(&pcf->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_dump_regs(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pcf50633 *pcf = dev_get_drvdata(dev);\r\nu8 dump[16];\r\nint n, n1, idx = 0;\r\nchar *buf1 = buf;\r\nstatic u8 address_no_read[] = {\r\nPCF50633_REG_INT1,\r\nPCF50633_REG_INT2,\r\nPCF50633_REG_INT3,\r\nPCF50633_REG_INT4,\r\nPCF50633_REG_INT5,\r\n0\r\n};\r\nfor (n = 0; n < 256; n += sizeof(dump)) {\r\nfor (n1 = 0; n1 < sizeof(dump); n1++)\r\nif (n == address_no_read[idx]) {\r\nidx++;\r\ndump[n1] = 0x00;\r\n} else\r\ndump[n1] = pcf50633_reg_read(pcf, n + n1);\r\nhex_dump_to_buffer(dump, sizeof(dump), 16, 1, buf1, 128, 0);\r\nbuf1 += strlen(buf1);\r\n*buf1++ = '\n';\r\n*buf1 = '\0';\r\n}\r\nreturn buf1 - buf;\r\n}\r\nstatic ssize_t show_resume_reason(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct pcf50633 *pcf = dev_get_drvdata(dev);\r\nint n;\r\nn = sprintf(buf, "%02x%02x%02x%02x%02x\n",\r\npcf->resume_reason[0],\r\npcf->resume_reason[1],\r\npcf->resume_reason[2],\r\npcf->resume_reason[3],\r\npcf->resume_reason[4]);\r\nreturn n;\r\n}\r\nstatic void\r\npcf50633_client_dev_register(struct pcf50633 *pcf, const char *name,\r\nstruct platform_device **pdev)\r\n{\r\nint ret;\r\n*pdev = platform_device_alloc(name, -1);\r\nif (!*pdev) {\r\ndev_err(pcf->dev, "Falied to allocate %s\n", name);\r\nreturn;\r\n}\r\n(*pdev)->dev.parent = pcf->dev;\r\nret = platform_device_add(*pdev);\r\nif (ret) {\r\ndev_err(pcf->dev, "Failed to register %s: %d\n", name, ret);\r\nplatform_device_put(*pdev);\r\n*pdev = NULL;\r\n}\r\n}\r\nstatic int pcf50633_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pcf50633 *pcf = i2c_get_clientdata(client);\r\nreturn pcf50633_irq_suspend(pcf);\r\n}\r\nstatic int pcf50633_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pcf50633 *pcf = i2c_get_clientdata(client);\r\nreturn pcf50633_irq_resume(pcf);\r\n}\r\nstatic int __devinit pcf50633_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *ids)\r\n{\r\nstruct pcf50633 *pcf;\r\nstruct pcf50633_platform_data *pdata = client->dev.platform_data;\r\nint i, ret;\r\nint version, variant;\r\nif (!client->irq) {\r\ndev_err(&client->dev, "Missing IRQ\n");\r\nreturn -ENOENT;\r\n}\r\npcf = kzalloc(sizeof(*pcf), GFP_KERNEL);\r\nif (!pcf)\r\nreturn -ENOMEM;\r\npcf->pdata = pdata;\r\nmutex_init(&pcf->lock);\r\ni2c_set_clientdata(client, pcf);\r\npcf->dev = &client->dev;\r\npcf->i2c_client = client;\r\nversion = pcf50633_reg_read(pcf, 0);\r\nvariant = pcf50633_reg_read(pcf, 1);\r\nif (version < 0 || variant < 0) {\r\ndev_err(pcf->dev, "Unable to probe pcf50633\n");\r\nret = -ENODEV;\r\ngoto err_free;\r\n}\r\ndev_info(pcf->dev, "Probed device version %d variant %d\n",\r\nversion, variant);\r\npcf50633_irq_init(pcf, client->irq);\r\npcf50633_client_dev_register(pcf, "pcf50633-input",\r\n&pcf->input_pdev);\r\npcf50633_client_dev_register(pcf, "pcf50633-rtc",\r\n&pcf->rtc_pdev);\r\npcf50633_client_dev_register(pcf, "pcf50633-mbc",\r\n&pcf->mbc_pdev);\r\npcf50633_client_dev_register(pcf, "pcf50633-adc",\r\n&pcf->adc_pdev);\r\npcf50633_client_dev_register(pcf, "pcf50633-backlight",\r\n&pcf->bl_pdev);\r\nfor (i = 0; i < PCF50633_NUM_REGULATORS; i++) {\r\nstruct platform_device *pdev;\r\npdev = platform_device_alloc("pcf50633-regltr", i);\r\nif (!pdev) {\r\ndev_err(pcf->dev, "Cannot create regulator %d\n", i);\r\ncontinue;\r\n}\r\npdev->dev.parent = pcf->dev;\r\nplatform_device_add_data(pdev, &pdata->reg_init_data[i],\r\nsizeof(pdata->reg_init_data[i]));\r\npcf->regulator_pdev[i] = pdev;\r\nplatform_device_add(pdev);\r\n}\r\nret = sysfs_create_group(&client->dev.kobj, &pcf_attr_group);\r\nif (ret)\r\ndev_err(pcf->dev, "error creating sysfs entries\n");\r\nif (pdata->probe_done)\r\npdata->probe_done(pcf);\r\nreturn 0;\r\nerr_free:\r\nkfree(pcf);\r\nreturn ret;\r\n}\r\nstatic int __devexit pcf50633_remove(struct i2c_client *client)\r\n{\r\nstruct pcf50633 *pcf = i2c_get_clientdata(client);\r\nint i;\r\nsysfs_remove_group(&client->dev.kobj, &pcf_attr_group);\r\npcf50633_irq_free(pcf);\r\nplatform_device_unregister(pcf->input_pdev);\r\nplatform_device_unregister(pcf->rtc_pdev);\r\nplatform_device_unregister(pcf->mbc_pdev);\r\nplatform_device_unregister(pcf->adc_pdev);\r\nplatform_device_unregister(pcf->bl_pdev);\r\nfor (i = 0; i < PCF50633_NUM_REGULATORS; i++)\r\nplatform_device_unregister(pcf->regulator_pdev[i]);\r\nkfree(pcf);\r\nreturn 0;\r\n}\r\nstatic int __init pcf50633_init(void)\r\n{\r\nreturn i2c_add_driver(&pcf50633_driver);\r\n}\r\nstatic void __exit pcf50633_exit(void)\r\n{\r\ni2c_del_driver(&pcf50633_driver);\r\n}
