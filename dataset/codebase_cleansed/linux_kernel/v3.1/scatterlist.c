struct scatterlist *sg_next(struct scatterlist *sg)\r\n{\r\n#ifdef CONFIG_DEBUG_SG\r\nBUG_ON(sg->sg_magic != SG_MAGIC);\r\n#endif\r\nif (sg_is_last(sg))\r\nreturn NULL;\r\nsg++;\r\nif (unlikely(sg_is_chain(sg)))\r\nsg = sg_chain_ptr(sg);\r\nreturn sg;\r\n}\r\nstruct scatterlist *sg_last(struct scatterlist *sgl, unsigned int nents)\r\n{\r\n#ifndef ARCH_HAS_SG_CHAIN\r\nstruct scatterlist *ret = &sgl[nents - 1];\r\n#else\r\nstruct scatterlist *sg, *ret = NULL;\r\nunsigned int i;\r\nfor_each_sg(sgl, sg, nents, i)\r\nret = sg;\r\n#endif\r\n#ifdef CONFIG_DEBUG_SG\r\nBUG_ON(sgl[0].sg_magic != SG_MAGIC);\r\nBUG_ON(!sg_is_last(ret));\r\n#endif\r\nreturn ret;\r\n}\r\nvoid sg_init_table(struct scatterlist *sgl, unsigned int nents)\r\n{\r\nmemset(sgl, 0, sizeof(*sgl) * nents);\r\n#ifdef CONFIG_DEBUG_SG\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < nents; i++)\r\nsgl[i].sg_magic = SG_MAGIC;\r\n}\r\n#endif\r\nsg_mark_end(&sgl[nents - 1]);\r\n}\r\nvoid sg_init_one(struct scatterlist *sg, const void *buf, unsigned int buflen)\r\n{\r\nsg_init_table(sg, 1);\r\nsg_set_buf(sg, buf, buflen);\r\n}\r\nstatic struct scatterlist *sg_kmalloc(unsigned int nents, gfp_t gfp_mask)\r\n{\r\nif (nents == SG_MAX_SINGLE_ALLOC) {\r\nvoid *ptr = (void *) __get_free_page(gfp_mask);\r\nkmemleak_alloc(ptr, PAGE_SIZE, 1, gfp_mask);\r\nreturn ptr;\r\n} else\r\nreturn kmalloc(nents * sizeof(struct scatterlist), gfp_mask);\r\n}\r\nstatic void sg_kfree(struct scatterlist *sg, unsigned int nents)\r\n{\r\nif (nents == SG_MAX_SINGLE_ALLOC) {\r\nkmemleak_free(sg);\r\nfree_page((unsigned long) sg);\r\n} else\r\nkfree(sg);\r\n}\r\nvoid __sg_free_table(struct sg_table *table, unsigned int max_ents,\r\nsg_free_fn *free_fn)\r\n{\r\nstruct scatterlist *sgl, *next;\r\nif (unlikely(!table->sgl))\r\nreturn;\r\nsgl = table->sgl;\r\nwhile (table->orig_nents) {\r\nunsigned int alloc_size = table->orig_nents;\r\nunsigned int sg_size;\r\nif (alloc_size > max_ents) {\r\nnext = sg_chain_ptr(&sgl[max_ents - 1]);\r\nalloc_size = max_ents;\r\nsg_size = alloc_size - 1;\r\n} else {\r\nsg_size = alloc_size;\r\nnext = NULL;\r\n}\r\ntable->orig_nents -= sg_size;\r\nfree_fn(sgl, alloc_size);\r\nsgl = next;\r\n}\r\ntable->sgl = NULL;\r\n}\r\nvoid sg_free_table(struct sg_table *table)\r\n{\r\n__sg_free_table(table, SG_MAX_SINGLE_ALLOC, sg_kfree);\r\n}\r\nint __sg_alloc_table(struct sg_table *table, unsigned int nents,\r\nunsigned int max_ents, gfp_t gfp_mask,\r\nsg_alloc_fn *alloc_fn)\r\n{\r\nstruct scatterlist *sg, *prv;\r\nunsigned int left;\r\n#ifndef ARCH_HAS_SG_CHAIN\r\nBUG_ON(nents > max_ents);\r\n#endif\r\nmemset(table, 0, sizeof(*table));\r\nleft = nents;\r\nprv = NULL;\r\ndo {\r\nunsigned int sg_size, alloc_size = left;\r\nif (alloc_size > max_ents) {\r\nalloc_size = max_ents;\r\nsg_size = alloc_size - 1;\r\n} else\r\nsg_size = alloc_size;\r\nleft -= sg_size;\r\nsg = alloc_fn(alloc_size, gfp_mask);\r\nif (unlikely(!sg)) {\r\nif (prv)\r\ntable->nents = ++table->orig_nents;\r\nreturn -ENOMEM;\r\n}\r\nsg_init_table(sg, alloc_size);\r\ntable->nents = table->orig_nents += sg_size;\r\nif (prv)\r\nsg_chain(prv, max_ents, sg);\r\nelse\r\ntable->sgl = sg;\r\nif (!left)\r\nsg_mark_end(&sg[sg_size - 1]);\r\ngfp_mask &= ~__GFP_WAIT;\r\ngfp_mask |= __GFP_HIGH;\r\nprv = sg;\r\n} while (left);\r\nreturn 0;\r\n}\r\nint sg_alloc_table(struct sg_table *table, unsigned int nents, gfp_t gfp_mask)\r\n{\r\nint ret;\r\nret = __sg_alloc_table(table, nents, SG_MAX_SINGLE_ALLOC,\r\ngfp_mask, sg_kmalloc);\r\nif (unlikely(ret))\r\n__sg_free_table(table, SG_MAX_SINGLE_ALLOC, sg_kfree);\r\nreturn ret;\r\n}\r\nvoid sg_miter_start(struct sg_mapping_iter *miter, struct scatterlist *sgl,\r\nunsigned int nents, unsigned int flags)\r\n{\r\nmemset(miter, 0, sizeof(struct sg_mapping_iter));\r\nmiter->__sg = sgl;\r\nmiter->__nents = nents;\r\nmiter->__offset = 0;\r\nWARN_ON(!(flags & (SG_MITER_TO_SG | SG_MITER_FROM_SG)));\r\nmiter->__flags = flags;\r\n}\r\nbool sg_miter_next(struct sg_mapping_iter *miter)\r\n{\r\nunsigned int off, len;\r\nif (!miter->__nents)\r\nreturn false;\r\nsg_miter_stop(miter);\r\nwhile (miter->__offset == miter->__sg->length) {\r\nif (--miter->__nents) {\r\nmiter->__sg = sg_next(miter->__sg);\r\nmiter->__offset = 0;\r\n} else\r\nreturn false;\r\n}\r\noff = miter->__sg->offset + miter->__offset;\r\nlen = miter->__sg->length - miter->__offset;\r\nmiter->page = nth_page(sg_page(miter->__sg), off >> PAGE_SHIFT);\r\noff &= ~PAGE_MASK;\r\nmiter->length = min_t(unsigned int, len, PAGE_SIZE - off);\r\nmiter->consumed = miter->length;\r\nif (miter->__flags & SG_MITER_ATOMIC)\r\nmiter->addr = kmap_atomic(miter->page, KM_BIO_SRC_IRQ) + off;\r\nelse\r\nmiter->addr = kmap(miter->page) + off;\r\nreturn true;\r\n}\r\nvoid sg_miter_stop(struct sg_mapping_iter *miter)\r\n{\r\nWARN_ON(miter->consumed > miter->length);\r\nif (miter->addr) {\r\nmiter->__offset += miter->consumed;\r\nif (miter->__flags & SG_MITER_TO_SG)\r\nflush_kernel_dcache_page(miter->page);\r\nif (miter->__flags & SG_MITER_ATOMIC) {\r\nWARN_ON(!irqs_disabled());\r\nkunmap_atomic(miter->addr, KM_BIO_SRC_IRQ);\r\n} else\r\nkunmap(miter->page);\r\nmiter->page = NULL;\r\nmiter->addr = NULL;\r\nmiter->length = 0;\r\nmiter->consumed = 0;\r\n}\r\n}\r\nstatic size_t sg_copy_buffer(struct scatterlist *sgl, unsigned int nents,\r\nvoid *buf, size_t buflen, int to_buffer)\r\n{\r\nunsigned int offset = 0;\r\nstruct sg_mapping_iter miter;\r\nunsigned long flags;\r\nunsigned int sg_flags = SG_MITER_ATOMIC;\r\nif (to_buffer)\r\nsg_flags |= SG_MITER_FROM_SG;\r\nelse\r\nsg_flags |= SG_MITER_TO_SG;\r\nsg_miter_start(&miter, sgl, nents, sg_flags);\r\nlocal_irq_save(flags);\r\nwhile (sg_miter_next(&miter) && offset < buflen) {\r\nunsigned int len;\r\nlen = min(miter.length, buflen - offset);\r\nif (to_buffer)\r\nmemcpy(buf + offset, miter.addr, len);\r\nelse\r\nmemcpy(miter.addr, buf + offset, len);\r\noffset += len;\r\n}\r\nsg_miter_stop(&miter);\r\nlocal_irq_restore(flags);\r\nreturn offset;\r\n}\r\nsize_t sg_copy_from_buffer(struct scatterlist *sgl, unsigned int nents,\r\nvoid *buf, size_t buflen)\r\n{\r\nreturn sg_copy_buffer(sgl, nents, buf, buflen, 0);\r\n}\r\nsize_t sg_copy_to_buffer(struct scatterlist *sgl, unsigned int nents,\r\nvoid *buf, size_t buflen)\r\n{\r\nreturn sg_copy_buffer(sgl, nents, buf, buflen, 1);\r\n}
