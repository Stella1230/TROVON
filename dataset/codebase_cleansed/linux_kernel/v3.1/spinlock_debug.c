void __raw_spin_lock_init(raw_spinlock_t *lock, const char *name,\r\nstruct lock_class_key *key)\r\n{\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\ndebug_check_no_locks_freed((void *)lock, sizeof(*lock));\r\nlockdep_init_map(&lock->dep_map, name, key, 0);\r\n#endif\r\nlock->raw_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\r\nlock->magic = SPINLOCK_MAGIC;\r\nlock->owner = SPINLOCK_OWNER_INIT;\r\nlock->owner_cpu = -1;\r\n}\r\nvoid __rwlock_init(rwlock_t *lock, const char *name,\r\nstruct lock_class_key *key)\r\n{\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\ndebug_check_no_locks_freed((void *)lock, sizeof(*lock));\r\nlockdep_init_map(&lock->dep_map, name, key, 0);\r\n#endif\r\nlock->raw_lock = (arch_rwlock_t) __ARCH_RW_LOCK_UNLOCKED;\r\nlock->magic = RWLOCK_MAGIC;\r\nlock->owner = SPINLOCK_OWNER_INIT;\r\nlock->owner_cpu = -1;\r\n}\r\nstatic void spin_bug(raw_spinlock_t *lock, const char *msg)\r\n{\r\nstruct task_struct *owner = NULL;\r\nif (!debug_locks_off())\r\nreturn;\r\nif (lock->owner && lock->owner != SPINLOCK_OWNER_INIT)\r\nowner = lock->owner;\r\nprintk(KERN_EMERG "BUG: spinlock %s on CPU#%d, %s/%d\n",\r\nmsg, raw_smp_processor_id(),\r\ncurrent->comm, task_pid_nr(current));\r\nprintk(KERN_EMERG " lock: %p, .magic: %08x, .owner: %s/%d, "\r\n".owner_cpu: %d\n",\r\nlock, lock->magic,\r\nowner ? owner->comm : "<none>",\r\nowner ? task_pid_nr(owner) : -1,\r\nlock->owner_cpu);\r\ndump_stack();\r\n}\r\nstatic inline void\r\ndebug_spin_lock_before(raw_spinlock_t *lock)\r\n{\r\nSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, "bad magic");\r\nSPIN_BUG_ON(lock->owner == current, lock, "recursion");\r\nSPIN_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\r\nlock, "cpu recursion");\r\n}\r\nstatic inline void debug_spin_lock_after(raw_spinlock_t *lock)\r\n{\r\nlock->owner_cpu = raw_smp_processor_id();\r\nlock->owner = current;\r\n}\r\nstatic inline void debug_spin_unlock(raw_spinlock_t *lock)\r\n{\r\nSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, "bad magic");\r\nSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, "already unlocked");\r\nSPIN_BUG_ON(lock->owner != current, lock, "wrong owner");\r\nSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\r\nlock, "wrong CPU");\r\nlock->owner = SPINLOCK_OWNER_INIT;\r\nlock->owner_cpu = -1;\r\n}\r\nstatic void __spin_lock_debug(raw_spinlock_t *lock)\r\n{\r\nu64 i;\r\nu64 loops = loops_per_jiffy * HZ;\r\nint print_once = 1;\r\nfor (;;) {\r\nfor (i = 0; i < loops; i++) {\r\nif (arch_spin_trylock(&lock->raw_lock))\r\nreturn;\r\n__delay(1);\r\n}\r\nif (print_once) {\r\nprint_once = 0;\r\nprintk(KERN_EMERG "BUG: spinlock lockup on CPU#%d, "\r\n"%s/%d, %p\n",\r\nraw_smp_processor_id(), current->comm,\r\ntask_pid_nr(current), lock);\r\ndump_stack();\r\n#ifdef CONFIG_SMP\r\ntrigger_all_cpu_backtrace();\r\n#endif\r\n}\r\n}\r\n}\r\nvoid do_raw_spin_lock(raw_spinlock_t *lock)\r\n{\r\ndebug_spin_lock_before(lock);\r\nif (unlikely(!arch_spin_trylock(&lock->raw_lock)))\r\n__spin_lock_debug(lock);\r\ndebug_spin_lock_after(lock);\r\n}\r\nint do_raw_spin_trylock(raw_spinlock_t *lock)\r\n{\r\nint ret = arch_spin_trylock(&lock->raw_lock);\r\nif (ret)\r\ndebug_spin_lock_after(lock);\r\n#ifndef CONFIG_SMP\r\nSPIN_BUG_ON(!ret, lock, "trylock failure on UP");\r\n#endif\r\nreturn ret;\r\n}\r\nvoid do_raw_spin_unlock(raw_spinlock_t *lock)\r\n{\r\ndebug_spin_unlock(lock);\r\narch_spin_unlock(&lock->raw_lock);\r\n}\r\nstatic void rwlock_bug(rwlock_t *lock, const char *msg)\r\n{\r\nif (!debug_locks_off())\r\nreturn;\r\nprintk(KERN_EMERG "BUG: rwlock %s on CPU#%d, %s/%d, %p\n",\r\nmsg, raw_smp_processor_id(), current->comm,\r\ntask_pid_nr(current), lock);\r\ndump_stack();\r\n}\r\nvoid do_raw_read_lock(rwlock_t *lock)\r\n{\r\nRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, "bad magic");\r\narch_read_lock(&lock->raw_lock);\r\n}\r\nint do_raw_read_trylock(rwlock_t *lock)\r\n{\r\nint ret = arch_read_trylock(&lock->raw_lock);\r\n#ifndef CONFIG_SMP\r\nRWLOCK_BUG_ON(!ret, lock, "trylock failure on UP");\r\n#endif\r\nreturn ret;\r\n}\r\nvoid do_raw_read_unlock(rwlock_t *lock)\r\n{\r\nRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, "bad magic");\r\narch_read_unlock(&lock->raw_lock);\r\n}\r\nstatic inline void debug_write_lock_before(rwlock_t *lock)\r\n{\r\nRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, "bad magic");\r\nRWLOCK_BUG_ON(lock->owner == current, lock, "recursion");\r\nRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\r\nlock, "cpu recursion");\r\n}\r\nstatic inline void debug_write_lock_after(rwlock_t *lock)\r\n{\r\nlock->owner_cpu = raw_smp_processor_id();\r\nlock->owner = current;\r\n}\r\nstatic inline void debug_write_unlock(rwlock_t *lock)\r\n{\r\nRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, "bad magic");\r\nRWLOCK_BUG_ON(lock->owner != current, lock, "wrong owner");\r\nRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\r\nlock, "wrong CPU");\r\nlock->owner = SPINLOCK_OWNER_INIT;\r\nlock->owner_cpu = -1;\r\n}\r\nvoid do_raw_write_lock(rwlock_t *lock)\r\n{\r\ndebug_write_lock_before(lock);\r\narch_write_lock(&lock->raw_lock);\r\ndebug_write_lock_after(lock);\r\n}\r\nint do_raw_write_trylock(rwlock_t *lock)\r\n{\r\nint ret = arch_write_trylock(&lock->raw_lock);\r\nif (ret)\r\ndebug_write_lock_after(lock);\r\n#ifndef CONFIG_SMP\r\nRWLOCK_BUG_ON(!ret, lock, "trylock failure on UP");\r\n#endif\r\nreturn ret;\r\n}\r\nvoid do_raw_write_unlock(rwlock_t *lock)\r\n{\r\ndebug_write_unlock(lock);\r\narch_write_unlock(&lock->raw_lock);\r\n}
