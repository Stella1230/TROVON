static unsigned int scsi_debug_lbp(void)\r\n{\r\nreturn scsi_debug_lbpu | scsi_debug_lbpws | scsi_debug_lbpws10;\r\n}\r\nstatic inline sector_t dif_offset(sector_t sector)\r\n{\r\nreturn sector << 3;\r\n}\r\nstatic void sdebug_max_tgts_luns(void)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct Scsi_Host *hpnt;\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_for_each_entry(sdbg_host, &sdebug_host_list, host_list) {\r\nhpnt = sdbg_host->shost;\r\nif ((hpnt->this_id >= 0) &&\r\n(scsi_debug_num_tgts > hpnt->this_id))\r\nhpnt->max_id = scsi_debug_num_tgts + 1;\r\nelse\r\nhpnt->max_id = scsi_debug_num_tgts;\r\nhpnt->max_lun = SAM2_WLUN_REPORT_LUNS;\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\n}\r\nstatic void mk_sense_buffer(struct sdebug_dev_info *devip, int key,\r\nint asc, int asq)\r\n{\r\nunsigned char *sbuff;\r\nsbuff = devip->sense_buff;\r\nmemset(sbuff, 0, SDEBUG_SENSE_LEN);\r\nscsi_build_sense_buffer(scsi_debug_dsense, sbuff, key, asc, asq);\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: [sense_key,asc,ascq]: "\r\n"[0x%x,0x%x,0x%x]\n", key, asc, asq);\r\n}\r\nstatic void get_data_transfer_info(unsigned char *cmd,\r\nunsigned long long *lba, unsigned int *num,\r\nu32 *ei_lba)\r\n{\r\n*ei_lba = 0;\r\nswitch (*cmd) {\r\ncase VARIABLE_LENGTH_CMD:\r\n*lba = (u64)cmd[19] | (u64)cmd[18] << 8 |\r\n(u64)cmd[17] << 16 | (u64)cmd[16] << 24 |\r\n(u64)cmd[15] << 32 | (u64)cmd[14] << 40 |\r\n(u64)cmd[13] << 48 | (u64)cmd[12] << 56;\r\n*ei_lba = (u32)cmd[23] | (u32)cmd[22] << 8 |\r\n(u32)cmd[21] << 16 | (u32)cmd[20] << 24;\r\n*num = (u32)cmd[31] | (u32)cmd[30] << 8 | (u32)cmd[29] << 16 |\r\n(u32)cmd[28] << 24;\r\nbreak;\r\ncase WRITE_SAME_16:\r\ncase WRITE_16:\r\ncase READ_16:\r\n*lba = (u64)cmd[9] | (u64)cmd[8] << 8 |\r\n(u64)cmd[7] << 16 | (u64)cmd[6] << 24 |\r\n(u64)cmd[5] << 32 | (u64)cmd[4] << 40 |\r\n(u64)cmd[3] << 48 | (u64)cmd[2] << 56;\r\n*num = (u32)cmd[13] | (u32)cmd[12] << 8 | (u32)cmd[11] << 16 |\r\n(u32)cmd[10] << 24;\r\nbreak;\r\ncase WRITE_12:\r\ncase READ_12:\r\n*lba = (u32)cmd[5] | (u32)cmd[4] << 8 | (u32)cmd[3] << 16 |\r\n(u32)cmd[2] << 24;\r\n*num = (u32)cmd[9] | (u32)cmd[8] << 8 | (u32)cmd[7] << 16 |\r\n(u32)cmd[6] << 24;\r\nbreak;\r\ncase WRITE_SAME:\r\ncase WRITE_10:\r\ncase READ_10:\r\ncase XDWRITEREAD_10:\r\n*lba = (u32)cmd[5] | (u32)cmd[4] << 8 | (u32)cmd[3] << 16 |\r\n(u32)cmd[2] << 24;\r\n*num = (u32)cmd[8] | (u32)cmd[7] << 8;\r\nbreak;\r\ncase WRITE_6:\r\ncase READ_6:\r\n*lba = (u32)cmd[3] | (u32)cmd[2] << 8 |\r\n(u32)(cmd[1] & 0x1f) << 16;\r\n*num = (0 == cmd[4]) ? 256 : cmd[4];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int scsi_debug_ioctl(struct scsi_device *dev, int cmd, void __user *arg)\r\n{\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts) {\r\nprintk(KERN_INFO "scsi_debug: ioctl: cmd=0x%x\n", cmd);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int check_readiness(struct scsi_cmnd * SCpnt, int reset_only,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nif (devip->reset) {\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: Reporting Unit "\r\n"attention: power on reset\n");\r\ndevip->reset = 0;\r\nmk_sense_buffer(devip, UNIT_ATTENTION, POWERON_RESET, 0);\r\nreturn check_condition_result;\r\n}\r\nif ((0 == reset_only) && devip->stopped) {\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: Reporting Not "\r\n"ready: initializing command required\n");\r\nmk_sense_buffer(devip, NOT_READY, LOGICAL_UNIT_NOT_READY,\r\n0x2);\r\nreturn check_condition_result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fill_from_dev_buffer(struct scsi_cmnd *scp, unsigned char *arr,\r\nint arr_len)\r\n{\r\nint act_len;\r\nstruct scsi_data_buffer *sdb = scsi_in(scp);\r\nif (!sdb->length)\r\nreturn 0;\r\nif (!(scsi_bidi_cmnd(scp) || scp->sc_data_direction == DMA_FROM_DEVICE))\r\nreturn (DID_ERROR << 16);\r\nact_len = sg_copy_from_buffer(sdb->table.sgl, sdb->table.nents,\r\narr, arr_len);\r\nif (sdb->resid)\r\nsdb->resid -= act_len;\r\nelse\r\nsdb->resid = scsi_bufflen(scp) - act_len;\r\nreturn 0;\r\n}\r\nstatic int fetch_to_dev_buffer(struct scsi_cmnd *scp, unsigned char *arr,\r\nint arr_len)\r\n{\r\nif (!scsi_bufflen(scp))\r\nreturn 0;\r\nif (!(scsi_bidi_cmnd(scp) || scp->sc_data_direction == DMA_TO_DEVICE))\r\nreturn -1;\r\nreturn scsi_sg_copy_to_buffer(scp, arr, arr_len);\r\n}\r\nstatic int inquiry_evpd_83(unsigned char * arr, int port_group_id,\r\nint target_dev_id, int dev_id_num,\r\nconst char * dev_id_str,\r\nint dev_id_str_len)\r\n{\r\nint num, port_a;\r\nchar b[32];\r\nport_a = target_dev_id + 1;\r\narr[0] = 0x2;\r\narr[1] = 0x1;\r\narr[2] = 0x0;\r\nmemcpy(&arr[4], inq_vendor_id, 8);\r\nmemcpy(&arr[12], inq_product_id, 16);\r\nmemcpy(&arr[28], dev_id_str, dev_id_str_len);\r\nnum = 8 + 16 + dev_id_str_len;\r\narr[3] = num;\r\nnum += 4;\r\nif (dev_id_num >= 0) {\r\narr[num++] = 0x1;\r\narr[num++] = 0x3;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x53;\r\narr[num++] = 0x33;\r\narr[num++] = 0x33;\r\narr[num++] = 0x30;\r\narr[num++] = (dev_id_num >> 24);\r\narr[num++] = (dev_id_num >> 16) & 0xff;\r\narr[num++] = (dev_id_num >> 8) & 0xff;\r\narr[num++] = dev_id_num & 0xff;\r\narr[num++] = 0x61;\r\narr[num++] = 0x94;\r\narr[num++] = 0x0;\r\narr[num++] = 0x4;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x1;\r\n}\r\narr[num++] = 0x61;\r\narr[num++] = 0x93;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x52;\r\narr[num++] = 0x22;\r\narr[num++] = 0x22;\r\narr[num++] = 0x20;\r\narr[num++] = (port_a >> 24);\r\narr[num++] = (port_a >> 16) & 0xff;\r\narr[num++] = (port_a >> 8) & 0xff;\r\narr[num++] = port_a & 0xff;\r\narr[num++] = 0x61;\r\narr[num++] = 0x95;\r\narr[num++] = 0x0;\r\narr[num++] = 0x4;\r\narr[num++] = 0;\r\narr[num++] = 0;\r\narr[num++] = (port_group_id >> 8) & 0xff;\r\narr[num++] = port_group_id & 0xff;\r\narr[num++] = 0x61;\r\narr[num++] = 0xa3;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x52;\r\narr[num++] = 0x22;\r\narr[num++] = 0x22;\r\narr[num++] = 0x20;\r\narr[num++] = (target_dev_id >> 24);\r\narr[num++] = (target_dev_id >> 16) & 0xff;\r\narr[num++] = (target_dev_id >> 8) & 0xff;\r\narr[num++] = target_dev_id & 0xff;\r\narr[num++] = 0x63;\r\narr[num++] = 0xa8;\r\narr[num++] = 0x0;\r\narr[num++] = 24;\r\nmemcpy(arr + num, "naa.52222220", 12);\r\nnum += 12;\r\nsnprintf(b, sizeof(b), "%08X", target_dev_id);\r\nmemcpy(arr + num, b, 8);\r\nnum += 8;\r\nmemset(arr + num, 0, 4);\r\nnum += 4;\r\nreturn num;\r\n}\r\nstatic int inquiry_evpd_84(unsigned char * arr)\r\n{\r\nmemcpy(arr, vpd84_data, sizeof(vpd84_data));\r\nreturn sizeof(vpd84_data);\r\n}\r\nstatic int inquiry_evpd_85(unsigned char * arr)\r\n{\r\nint num = 0;\r\nconst char * na1 = "https://www.kernel.org/config";\r\nconst char * na2 = "http://www.kernel.org/log";\r\nint plen, olen;\r\narr[num++] = 0x1;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\nolen = strlen(na1);\r\nplen = olen + 1;\r\nif (plen % 4)\r\nplen = ((plen / 4) + 1) * 4;\r\narr[num++] = plen;\r\nmemcpy(arr + num, na1, olen);\r\nmemset(arr + num + olen, 0, plen - olen);\r\nnum += plen;\r\narr[num++] = 0x4;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\nolen = strlen(na2);\r\nplen = olen + 1;\r\nif (plen % 4)\r\nplen = ((plen / 4) + 1) * 4;\r\narr[num++] = plen;\r\nmemcpy(arr + num, na2, olen);\r\nmemset(arr + num + olen, 0, plen - olen);\r\nnum += plen;\r\nreturn num;\r\n}\r\nstatic int inquiry_evpd_88(unsigned char * arr, int target_dev_id)\r\n{\r\nint num = 0;\r\nint port_a, port_b;\r\nport_a = target_dev_id + 1;\r\nport_b = port_a + 1;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x1;\r\nmemset(arr + num, 0, 6);\r\nnum += 6;\r\narr[num++] = 0x0;\r\narr[num++] = 12;\r\narr[num++] = 0x61;\r\narr[num++] = 0x93;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x52;\r\narr[num++] = 0x22;\r\narr[num++] = 0x22;\r\narr[num++] = 0x20;\r\narr[num++] = (port_a >> 24);\r\narr[num++] = (port_a >> 16) & 0xff;\r\narr[num++] = (port_a >> 8) & 0xff;\r\narr[num++] = port_a & 0xff;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x0;\r\narr[num++] = 0x2;\r\nmemset(arr + num, 0, 6);\r\nnum += 6;\r\narr[num++] = 0x0;\r\narr[num++] = 12;\r\narr[num++] = 0x61;\r\narr[num++] = 0x93;\r\narr[num++] = 0x0;\r\narr[num++] = 0x8;\r\narr[num++] = 0x52;\r\narr[num++] = 0x22;\r\narr[num++] = 0x22;\r\narr[num++] = 0x20;\r\narr[num++] = (port_b >> 24);\r\narr[num++] = (port_b >> 16) & 0xff;\r\narr[num++] = (port_b >> 8) & 0xff;\r\narr[num++] = port_b & 0xff;\r\nreturn num;\r\n}\r\nstatic int inquiry_evpd_89(unsigned char * arr)\r\n{\r\nmemcpy(arr, vpd89_data, sizeof(vpd89_data));\r\nreturn sizeof(vpd89_data);\r\n}\r\nstatic int inquiry_evpd_b0(unsigned char * arr)\r\n{\r\nunsigned int gran;\r\nmemcpy(arr, vpdb0_data, sizeof(vpdb0_data));\r\ngran = 1 << scsi_debug_physblk_exp;\r\narr[2] = (gran >> 8) & 0xff;\r\narr[3] = gran & 0xff;\r\nif (sdebug_store_sectors > 0x400) {\r\narr[4] = (sdebug_store_sectors >> 24) & 0xff;\r\narr[5] = (sdebug_store_sectors >> 16) & 0xff;\r\narr[6] = (sdebug_store_sectors >> 8) & 0xff;\r\narr[7] = sdebug_store_sectors & 0xff;\r\n}\r\nput_unaligned_be32(scsi_debug_opt_blks, &arr[8]);\r\nif (scsi_debug_lbpu) {\r\nput_unaligned_be32(scsi_debug_unmap_max_blocks, &arr[16]);\r\nput_unaligned_be32(scsi_debug_unmap_max_desc, &arr[20]);\r\n}\r\nif (scsi_debug_unmap_alignment) {\r\nput_unaligned_be32(scsi_debug_unmap_alignment, &arr[28]);\r\narr[28] |= 0x80;\r\n}\r\nput_unaligned_be32(scsi_debug_unmap_granularity, &arr[24]);\r\nput_unaligned_be64(scsi_debug_write_same_length, &arr[32]);\r\nreturn 0x3c;\r\nreturn sizeof(vpdb0_data);\r\n}\r\nstatic int inquiry_evpd_b1(unsigned char *arr)\r\n{\r\nmemset(arr, 0, 0x3c);\r\narr[0] = 0;\r\narr[1] = 1;\r\narr[2] = 0;\r\narr[3] = 5;\r\nreturn 0x3c;\r\n}\r\nstatic int inquiry_evpd_b2(unsigned char *arr)\r\n{\r\nmemset(arr, 0, 0x8);\r\narr[0] = 0;\r\nif (scsi_debug_lbpu)\r\narr[1] = 1 << 7;\r\nif (scsi_debug_lbpws)\r\narr[1] |= 1 << 6;\r\nif (scsi_debug_lbpws10)\r\narr[1] |= 1 << 5;\r\nreturn 0x8;\r\n}\r\nstatic int resp_inquiry(struct scsi_cmnd * scp, int target,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char pq_pdt;\r\nunsigned char * arr;\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nint alloc_len, n, ret;\r\nalloc_len = (cmd[3] << 8) + cmd[4];\r\narr = kzalloc(SDEBUG_MAX_INQ_ARR_SZ, GFP_ATOMIC);\r\nif (! arr)\r\nreturn DID_REQUEUE << 16;\r\nif (devip->wlun)\r\npq_pdt = 0x1e;\r\nelse if (scsi_debug_no_lun_0 && (0 == devip->lun))\r\npq_pdt = 0x7f;\r\nelse\r\npq_pdt = (scsi_debug_ptype & 0x1f);\r\narr[0] = pq_pdt;\r\nif (0x2 & cmd[1]) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB,\r\n0);\r\nkfree(arr);\r\nreturn check_condition_result;\r\n} else if (0x1 & cmd[1]) {\r\nint lu_id_num, port_group_id, target_dev_id, len;\r\nchar lu_id_str[6];\r\nint host_no = devip->sdbg_host->shost->host_no;\r\nport_group_id = (((host_no + 1) & 0x7f) << 8) +\r\n(devip->channel & 0x7f);\r\nif (0 == scsi_debug_vpd_use_hostno)\r\nhost_no = 0;\r\nlu_id_num = devip->wlun ? -1 : (((host_no + 1) * 2000) +\r\n(devip->target * 1000) + devip->lun);\r\ntarget_dev_id = ((host_no + 1) * 2000) +\r\n(devip->target * 1000) - 3;\r\nlen = scnprintf(lu_id_str, 6, "%d", lu_id_num);\r\nif (0 == cmd[2]) {\r\narr[1] = cmd[2];\r\nn = 4;\r\narr[n++] = 0x0;\r\narr[n++] = 0x80;\r\narr[n++] = 0x83;\r\narr[n++] = 0x84;\r\narr[n++] = 0x85;\r\narr[n++] = 0x86;\r\narr[n++] = 0x87;\r\narr[n++] = 0x88;\r\narr[n++] = 0x89;\r\narr[n++] = 0xb0;\r\narr[n++] = 0xb1;\r\nif (scsi_debug_lbp())\r\narr[n++] = 0xb2;\r\narr[3] = n - 4;\r\n} else if (0x80 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = len;\r\nmemcpy(&arr[4], lu_id_str, len);\r\n} else if (0x83 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_83(&arr[4], port_group_id,\r\ntarget_dev_id, lu_id_num,\r\nlu_id_str, len);\r\n} else if (0x84 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_84(&arr[4]);\r\n} else if (0x85 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_85(&arr[4]);\r\n} else if (0x86 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = 0x3c;\r\nif (scsi_debug_dif == SD_DIF_TYPE3_PROTECTION)\r\narr[4] = 0x4;\r\nelse if (scsi_debug_dif)\r\narr[4] = 0x5;\r\nelse\r\narr[4] = 0x0;\r\narr[5] = 0x7;\r\n} else if (0x87 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = 0x8;\r\narr[4] = 0x2;\r\narr[6] = 0x80;\r\narr[8] = 0x18;\r\narr[10] = 0x82;\r\n} else if (0x88 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_88(&arr[4], target_dev_id);\r\n} else if (0x89 == cmd[2]) {\r\narr[1] = cmd[2];\r\nn = inquiry_evpd_89(&arr[4]);\r\narr[2] = (n >> 8);\r\narr[3] = (n & 0xff);\r\n} else if (0xb0 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_b0(&arr[4]);\r\n} else if (0xb1 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_b1(&arr[4]);\r\n} else if (0xb2 == cmd[2]) {\r\narr[1] = cmd[2];\r\narr[3] = inquiry_evpd_b2(&arr[4]);\r\n} else {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nkfree(arr);\r\nreturn check_condition_result;\r\n}\r\nlen = min(((arr[2] << 8) + arr[3]) + 4, alloc_len);\r\nret = fill_from_dev_buffer(scp, arr,\r\nmin(len, SDEBUG_MAX_INQ_ARR_SZ));\r\nkfree(arr);\r\nreturn ret;\r\n}\r\narr[1] = DEV_REMOVEABLE(target) ? 0x80 : 0;\r\narr[2] = scsi_debug_scsi_level;\r\narr[3] = 2;\r\narr[4] = SDEBUG_LONG_INQ_SZ - 5;\r\narr[5] = scsi_debug_dif ? 1 : 0;\r\nif (0 == scsi_debug_vpd_use_hostno)\r\narr[5] = 0x10;\r\narr[6] = 0x10;\r\narr[7] = 0xa;\r\nmemcpy(&arr[8], inq_vendor_id, 8);\r\nmemcpy(&arr[16], inq_product_id, 16);\r\nmemcpy(&arr[32], inq_product_rev, 4);\r\narr[58] = 0x0; arr[59] = 0x77;\r\narr[60] = 0x3; arr[61] = 0x14;\r\nn = 62;\r\nif (scsi_debug_ptype == 0) {\r\narr[n++] = 0x3; arr[n++] = 0x3d;\r\n} else if (scsi_debug_ptype == 1) {\r\narr[n++] = 0x3; arr[n++] = 0x60;\r\n}\r\narr[n++] = 0xc; arr[n++] = 0xf;\r\nret = fill_from_dev_buffer(scp, arr,\r\nmin(alloc_len, SDEBUG_LONG_INQ_SZ));\r\nkfree(arr);\r\nreturn ret;\r\n}\r\nstatic int resp_requests(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char * sbuff;\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nunsigned char arr[SDEBUG_SENSE_LEN];\r\nint want_dsense;\r\nint len = 18;\r\nmemset(arr, 0, sizeof(arr));\r\nif (devip->reset == 1)\r\nmk_sense_buffer(devip, 0, NO_ADDITIONAL_SENSE, 0);\r\nwant_dsense = !!(cmd[1] & 1) || scsi_debug_dsense;\r\nsbuff = devip->sense_buff;\r\nif ((iec_m_pg[2] & 0x4) && (6 == (iec_m_pg[3] & 0xf))) {\r\nif (want_dsense) {\r\narr[0] = 0x72;\r\narr[1] = 0x0;\r\narr[2] = THRESHOLD_EXCEEDED;\r\narr[3] = 0xff;\r\n} else {\r\narr[0] = 0x70;\r\narr[2] = 0x0;\r\narr[7] = 0xa;\r\narr[12] = THRESHOLD_EXCEEDED;\r\narr[13] = 0xff;\r\n}\r\n} else {\r\nmemcpy(arr, sbuff, SDEBUG_SENSE_LEN);\r\nif ((cmd[1] & 1) && (! scsi_debug_dsense)) {\r\nmemset(arr, 0, sizeof(arr));\r\narr[0] = 0x72;\r\narr[1] = sbuff[2];\r\narr[2] = sbuff[12];\r\narr[3] = sbuff[13];\r\nlen = 8;\r\n}\r\n}\r\nmk_sense_buffer(devip, 0, NO_ADDITIONAL_SENSE, 0);\r\nreturn fill_from_dev_buffer(scp, arr, len);\r\n}\r\nstatic int resp_start_stop(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nint power_cond, errsts, start;\r\nif ((errsts = check_readiness(scp, 1, devip)))\r\nreturn errsts;\r\npower_cond = (cmd[4] & 0xf0) >> 4;\r\nif (power_cond) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB,\r\n0);\r\nreturn check_condition_result;\r\n}\r\nstart = cmd[4] & 1;\r\nif (start == devip->stopped)\r\ndevip->stopped = !start;\r\nreturn 0;\r\n}\r\nstatic sector_t get_sdebug_capacity(void)\r\n{\r\nif (scsi_debug_virtual_gb > 0)\r\nreturn (sector_t)scsi_debug_virtual_gb *\r\n(1073741824 / scsi_debug_sector_size);\r\nelse\r\nreturn sdebug_store_sectors;\r\n}\r\nstatic int resp_readcap(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char arr[SDEBUG_READCAP_ARR_SZ];\r\nunsigned int capac;\r\nint errsts;\r\nif ((errsts = check_readiness(scp, 1, devip)))\r\nreturn errsts;\r\nsdebug_capacity = get_sdebug_capacity();\r\nmemset(arr, 0, SDEBUG_READCAP_ARR_SZ);\r\nif (sdebug_capacity < 0xffffffff) {\r\ncapac = (unsigned int)sdebug_capacity - 1;\r\narr[0] = (capac >> 24);\r\narr[1] = (capac >> 16) & 0xff;\r\narr[2] = (capac >> 8) & 0xff;\r\narr[3] = capac & 0xff;\r\n} else {\r\narr[0] = 0xff;\r\narr[1] = 0xff;\r\narr[2] = 0xff;\r\narr[3] = 0xff;\r\n}\r\narr[6] = (scsi_debug_sector_size >> 8) & 0xff;\r\narr[7] = scsi_debug_sector_size & 0xff;\r\nreturn fill_from_dev_buffer(scp, arr, SDEBUG_READCAP_ARR_SZ);\r\n}\r\nstatic int resp_readcap16(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nunsigned char arr[SDEBUG_READCAP16_ARR_SZ];\r\nunsigned long long capac;\r\nint errsts, k, alloc_len;\r\nif ((errsts = check_readiness(scp, 1, devip)))\r\nreturn errsts;\r\nalloc_len = ((cmd[10] << 24) + (cmd[11] << 16) + (cmd[12] << 8)\r\n+ cmd[13]);\r\nsdebug_capacity = get_sdebug_capacity();\r\nmemset(arr, 0, SDEBUG_READCAP16_ARR_SZ);\r\ncapac = sdebug_capacity - 1;\r\nfor (k = 0; k < 8; ++k, capac >>= 8)\r\narr[7 - k] = capac & 0xff;\r\narr[8] = (scsi_debug_sector_size >> 24) & 0xff;\r\narr[9] = (scsi_debug_sector_size >> 16) & 0xff;\r\narr[10] = (scsi_debug_sector_size >> 8) & 0xff;\r\narr[11] = scsi_debug_sector_size & 0xff;\r\narr[13] = scsi_debug_physblk_exp & 0xf;\r\narr[14] = (scsi_debug_lowest_aligned >> 8) & 0x3f;\r\nif (scsi_debug_lbp())\r\narr[14] |= 0x80;\r\narr[15] = scsi_debug_lowest_aligned & 0xff;\r\nif (scsi_debug_dif) {\r\narr[12] = (scsi_debug_dif - 1) << 1;\r\narr[12] |= 1;\r\n}\r\nreturn fill_from_dev_buffer(scp, arr,\r\nmin(alloc_len, SDEBUG_READCAP16_ARR_SZ));\r\n}\r\nstatic int resp_report_tgtpgs(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nunsigned char * arr;\r\nint host_no = devip->sdbg_host->shost->host_no;\r\nint n, ret, alen, rlen;\r\nint port_group_a, port_group_b, port_a, port_b;\r\nalen = ((cmd[6] << 24) + (cmd[7] << 16) + (cmd[8] << 8)\r\n+ cmd[9]);\r\narr = kzalloc(SDEBUG_MAX_TGTPGS_ARR_SZ, GFP_ATOMIC);\r\nif (! arr)\r\nreturn DID_REQUEUE << 16;\r\nport_a = 0x1;\r\nport_b = 0x2;\r\nport_group_a = (((host_no + 1) & 0x7f) << 8) +\r\n(devip->channel & 0x7f);\r\nport_group_b = (((host_no + 1) & 0x7f) << 8) +\r\n(devip->channel & 0x7f) + 0x80;\r\nn = 4;\r\nif (0 == scsi_debug_vpd_use_hostno) {\r\narr[n++] = host_no % 3;\r\narr[n++] = 0x0F;\r\n} else {\r\narr[n++] = 0x0;\r\narr[n++] = 0x01;\r\n}\r\narr[n++] = (port_group_a >> 8) & 0xff;\r\narr[n++] = port_group_a & 0xff;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = 0x1;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = (port_a >> 8) & 0xff;\r\narr[n++] = port_a & 0xff;\r\narr[n++] = 3;\r\narr[n++] = 0x08;\r\narr[n++] = (port_group_b >> 8) & 0xff;\r\narr[n++] = port_group_b & 0xff;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = 0x1;\r\narr[n++] = 0;\r\narr[n++] = 0;\r\narr[n++] = (port_b >> 8) & 0xff;\r\narr[n++] = port_b & 0xff;\r\nrlen = n - 4;\r\narr[0] = (rlen >> 24) & 0xff;\r\narr[1] = (rlen >> 16) & 0xff;\r\narr[2] = (rlen >> 8) & 0xff;\r\narr[3] = rlen & 0xff;\r\nrlen = min(alen,n);\r\nret = fill_from_dev_buffer(scp, arr,\r\nmin(rlen, SDEBUG_MAX_TGTPGS_ARR_SZ));\r\nkfree(arr);\r\nreturn ret;\r\n}\r\nstatic int resp_err_recov_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char err_recov_pg[] = {0x1, 0xa, 0xc0, 11, 240, 0, 0, 0,\r\n5, 0, 0xff, 0xff};\r\nmemcpy(p, err_recov_pg, sizeof(err_recov_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(err_recov_pg) - 2);\r\nreturn sizeof(err_recov_pg);\r\n}\r\nstatic int resp_disconnect_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char disconnect_pg[] = {0x2, 0xe, 128, 128, 0, 10, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0};\r\nmemcpy(p, disconnect_pg, sizeof(disconnect_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(disconnect_pg) - 2);\r\nreturn sizeof(disconnect_pg);\r\n}\r\nstatic int resp_format_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char format_pg[] = {0x3, 0x16, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0x40, 0, 0, 0};\r\nmemcpy(p, format_pg, sizeof(format_pg));\r\np[10] = (sdebug_sectors_per >> 8) & 0xff;\r\np[11] = sdebug_sectors_per & 0xff;\r\np[12] = (scsi_debug_sector_size >> 8) & 0xff;\r\np[13] = scsi_debug_sector_size & 0xff;\r\nif (DEV_REMOVEABLE(target))\r\np[20] |= 0x20;\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(format_pg) - 2);\r\nreturn sizeof(format_pg);\r\n}\r\nstatic int resp_caching_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char caching_pg[] = {0x8, 18, 0x14, 0, 0xff, 0xff, 0, 0,\r\n0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0, 0, 0, 0, 0, 0};\r\nmemcpy(p, caching_pg, sizeof(caching_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(caching_pg) - 2);\r\nreturn sizeof(caching_pg);\r\n}\r\nstatic int resp_ctrl_m_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char ch_ctrl_m_pg[] = { 0x6, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0};\r\nunsigned char d_ctrl_m_pg[] = {0xa, 10, 2, 0, 0, 0, 0, 0,\r\n0, 0, 0x2, 0x4b};\r\nif (scsi_debug_dsense)\r\nctrl_m_pg[2] |= 0x4;\r\nelse\r\nctrl_m_pg[2] &= ~0x4;\r\nif (scsi_debug_ato)\r\nctrl_m_pg[5] |= 0x80;\r\nmemcpy(p, ctrl_m_pg, sizeof(ctrl_m_pg));\r\nif (1 == pcontrol)\r\nmemcpy(p + 2, ch_ctrl_m_pg, sizeof(ch_ctrl_m_pg));\r\nelse if (2 == pcontrol)\r\nmemcpy(p, d_ctrl_m_pg, sizeof(d_ctrl_m_pg));\r\nreturn sizeof(ctrl_m_pg);\r\n}\r\nstatic int resp_iec_m_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char ch_iec_m_pg[] = { 0x4, 0xf, 0, 0, 0, 0,\r\n0, 0, 0x0, 0x0};\r\nunsigned char d_iec_m_pg[] = {0x1c, 0xa, 0x08, 0, 0, 0, 0, 0,\r\n0, 0, 0x0, 0x0};\r\nmemcpy(p, iec_m_pg, sizeof(iec_m_pg));\r\nif (1 == pcontrol)\r\nmemcpy(p + 2, ch_iec_m_pg, sizeof(ch_iec_m_pg));\r\nelse if (2 == pcontrol)\r\nmemcpy(p, d_iec_m_pg, sizeof(d_iec_m_pg));\r\nreturn sizeof(iec_m_pg);\r\n}\r\nstatic int resp_sas_sf_m_pg(unsigned char * p, int pcontrol, int target)\r\n{\r\nunsigned char sas_sf_m_pg[] = {0x19, 0x6,\r\n0x6, 0x0, 0x7, 0xd0, 0x0, 0x0};\r\nmemcpy(p, sas_sf_m_pg, sizeof(sas_sf_m_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 2, 0, sizeof(sas_sf_m_pg) - 2);\r\nreturn sizeof(sas_sf_m_pg);\r\n}\r\nstatic int resp_sas_pcd_m_spg(unsigned char * p, int pcontrol, int target,\r\nint target_dev_id)\r\n{\r\nunsigned char sas_pcd_m_pg[] = {0x59, 0x1, 0, 0x64, 0, 0x6, 0, 2,\r\n0, 0, 0, 0, 0x10, 0x9, 0x8, 0x0,\r\n0x52, 0x22, 0x22, 0x20, 0x0, 0x0, 0x0, 0x0,\r\n0x51, 0x11, 0x11, 0x10, 0x0, 0x0, 0x0, 0x1,\r\n0x2, 0, 0, 0, 0, 0, 0, 0,\r\n0x88, 0x99, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 1, 0, 0, 0x10, 0x9, 0x8, 0x0,\r\n0x52, 0x22, 0x22, 0x20, 0x0, 0x0, 0x0, 0x0,\r\n0x51, 0x11, 0x11, 0x10, 0x0, 0x0, 0x0, 0x1,\r\n0x3, 0, 0, 0, 0, 0, 0, 0,\r\n0x88, 0x99, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n};\r\nint port_a, port_b;\r\nport_a = target_dev_id + 1;\r\nport_b = port_a + 1;\r\nmemcpy(p, sas_pcd_m_pg, sizeof(sas_pcd_m_pg));\r\np[20] = (port_a >> 24);\r\np[21] = (port_a >> 16) & 0xff;\r\np[22] = (port_a >> 8) & 0xff;\r\np[23] = port_a & 0xff;\r\np[48 + 20] = (port_b >> 24);\r\np[48 + 21] = (port_b >> 16) & 0xff;\r\np[48 + 22] = (port_b >> 8) & 0xff;\r\np[48 + 23] = port_b & 0xff;\r\nif (1 == pcontrol)\r\nmemset(p + 4, 0, sizeof(sas_pcd_m_pg) - 4);\r\nreturn sizeof(sas_pcd_m_pg);\r\n}\r\nstatic int resp_sas_sha_m_spg(unsigned char * p, int pcontrol)\r\n{\r\nunsigned char sas_sha_m_pg[] = {0x59, 0x2, 0, 0xc, 0, 0x6, 0x10, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n};\r\nmemcpy(p, sas_sha_m_pg, sizeof(sas_sha_m_pg));\r\nif (1 == pcontrol)\r\nmemset(p + 4, 0, sizeof(sas_sha_m_pg) - 4);\r\nreturn sizeof(sas_sha_m_pg);\r\n}\r\nstatic int resp_mode_sense(struct scsi_cmnd * scp, int target,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned char dbd, llbaa;\r\nint pcontrol, pcode, subpcode, bd_len;\r\nunsigned char dev_spec;\r\nint k, alloc_len, msense_6, offset, len, errsts, target_dev_id;\r\nunsigned char * ap;\r\nunsigned char arr[SDEBUG_MAX_MSENSE_SZ];\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nif ((errsts = check_readiness(scp, 1, devip)))\r\nreturn errsts;\r\ndbd = !!(cmd[1] & 0x8);\r\npcontrol = (cmd[2] & 0xc0) >> 6;\r\npcode = cmd[2] & 0x3f;\r\nsubpcode = cmd[3];\r\nmsense_6 = (MODE_SENSE == cmd[0]);\r\nllbaa = msense_6 ? 0 : !!(cmd[1] & 0x10);\r\nif ((0 == scsi_debug_ptype) && (0 == dbd))\r\nbd_len = llbaa ? 16 : 8;\r\nelse\r\nbd_len = 0;\r\nalloc_len = msense_6 ? cmd[4] : ((cmd[7] << 8) | cmd[8]);\r\nmemset(arr, 0, SDEBUG_MAX_MSENSE_SZ);\r\nif (0x3 == pcontrol) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, SAVING_PARAMS_UNSUP,\r\n0);\r\nreturn check_condition_result;\r\n}\r\ntarget_dev_id = ((devip->sdbg_host->shost->host_no + 1) * 2000) +\r\n(devip->target * 1000) - 3;\r\nif (0 == scsi_debug_ptype)\r\ndev_spec = (DEV_READONLY(target) ? 0x80 : 0x0) | 0x10;\r\nelse\r\ndev_spec = 0x0;\r\nif (msense_6) {\r\narr[2] = dev_spec;\r\narr[3] = bd_len;\r\noffset = 4;\r\n} else {\r\narr[3] = dev_spec;\r\nif (16 == bd_len)\r\narr[4] = 0x1;\r\narr[7] = bd_len;\r\noffset = 8;\r\n}\r\nap = arr + offset;\r\nif ((bd_len > 0) && (!sdebug_capacity))\r\nsdebug_capacity = get_sdebug_capacity();\r\nif (8 == bd_len) {\r\nif (sdebug_capacity > 0xfffffffe) {\r\nap[0] = 0xff;\r\nap[1] = 0xff;\r\nap[2] = 0xff;\r\nap[3] = 0xff;\r\n} else {\r\nap[0] = (sdebug_capacity >> 24) & 0xff;\r\nap[1] = (sdebug_capacity >> 16) & 0xff;\r\nap[2] = (sdebug_capacity >> 8) & 0xff;\r\nap[3] = sdebug_capacity & 0xff;\r\n}\r\nap[6] = (scsi_debug_sector_size >> 8) & 0xff;\r\nap[7] = scsi_debug_sector_size & 0xff;\r\noffset += bd_len;\r\nap = arr + offset;\r\n} else if (16 == bd_len) {\r\nunsigned long long capac = sdebug_capacity;\r\nfor (k = 0; k < 8; ++k, capac >>= 8)\r\nap[7 - k] = capac & 0xff;\r\nap[12] = (scsi_debug_sector_size >> 24) & 0xff;\r\nap[13] = (scsi_debug_sector_size >> 16) & 0xff;\r\nap[14] = (scsi_debug_sector_size >> 8) & 0xff;\r\nap[15] = scsi_debug_sector_size & 0xff;\r\noffset += bd_len;\r\nap = arr + offset;\r\n}\r\nif ((subpcode > 0x0) && (subpcode < 0xff) && (0x19 != pcode)) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB,\r\n0);\r\nreturn check_condition_result;\r\n}\r\nswitch (pcode) {\r\ncase 0x1:\r\nlen = resp_err_recov_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x2:\r\nlen = resp_disconnect_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x3:\r\nlen = resp_format_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x8:\r\nlen = resp_caching_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0xa:\r\nlen = resp_ctrl_m_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x19:\r\nif ((subpcode > 0x2) && (subpcode < 0xff)) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\nlen = 0;\r\nif ((0x0 == subpcode) || (0xff == subpcode))\r\nlen += resp_sas_sf_m_pg(ap + len, pcontrol, target);\r\nif ((0x1 == subpcode) || (0xff == subpcode))\r\nlen += resp_sas_pcd_m_spg(ap + len, pcontrol, target,\r\ntarget_dev_id);\r\nif ((0x2 == subpcode) || (0xff == subpcode))\r\nlen += resp_sas_sha_m_spg(ap + len, pcontrol);\r\noffset += len;\r\nbreak;\r\ncase 0x1c:\r\nlen = resp_iec_m_pg(ap, pcontrol, target);\r\noffset += len;\r\nbreak;\r\ncase 0x3f:\r\nif ((0 == subpcode) || (0xff == subpcode)) {\r\nlen = resp_err_recov_pg(ap, pcontrol, target);\r\nlen += resp_disconnect_pg(ap + len, pcontrol, target);\r\nlen += resp_format_pg(ap + len, pcontrol, target);\r\nlen += resp_caching_pg(ap + len, pcontrol, target);\r\nlen += resp_ctrl_m_pg(ap + len, pcontrol, target);\r\nlen += resp_sas_sf_m_pg(ap + len, pcontrol, target);\r\nif (0xff == subpcode) {\r\nlen += resp_sas_pcd_m_spg(ap + len, pcontrol,\r\ntarget, target_dev_id);\r\nlen += resp_sas_sha_m_spg(ap + len, pcontrol);\r\n}\r\nlen += resp_iec_m_pg(ap + len, pcontrol, target);\r\n} else {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\noffset += len;\r\nbreak;\r\ndefault:\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB,\r\n0);\r\nreturn check_condition_result;\r\n}\r\nif (msense_6)\r\narr[0] = offset - 1;\r\nelse {\r\narr[0] = ((offset - 2) >> 8) & 0xff;\r\narr[1] = (offset - 2) & 0xff;\r\n}\r\nreturn fill_from_dev_buffer(scp, arr, min(alloc_len, offset));\r\n}\r\nstatic int resp_mode_select(struct scsi_cmnd * scp, int mselect6,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nint pf, sp, ps, md_len, bd_len, off, spf, pg_len;\r\nint param_len, res, errsts, mpage;\r\nunsigned char arr[SDEBUG_MAX_MSELECT_SZ];\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nif ((errsts = check_readiness(scp, 1, devip)))\r\nreturn errsts;\r\nmemset(arr, 0, sizeof(arr));\r\npf = cmd[1] & 0x10;\r\nsp = cmd[1] & 0x1;\r\nparam_len = mselect6 ? cmd[4] : ((cmd[7] << 8) + cmd[8]);\r\nif ((0 == pf) || sp || (param_len > SDEBUG_MAX_MSELECT_SZ)) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\nres = fetch_to_dev_buffer(scp, arr, param_len);\r\nif (-1 == res)\r\nreturn (DID_ERROR << 16);\r\nelse if ((res < param_len) &&\r\n(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts))\r\nprintk(KERN_INFO "scsi_debug: mode_select: cdb indicated=%d, "\r\n" IO sent=%d bytes\n", param_len, res);\r\nmd_len = mselect6 ? (arr[0] + 1) : ((arr[0] << 8) + arr[1] + 2);\r\nbd_len = mselect6 ? arr[3] : ((arr[6] << 8) + arr[7]);\r\nif (md_len > 2) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_PARAM_LIST, 0);\r\nreturn check_condition_result;\r\n}\r\noff = bd_len + (mselect6 ? 4 : 8);\r\nmpage = arr[off] & 0x3f;\r\nps = !!(arr[off] & 0x80);\r\nif (ps) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_PARAM_LIST, 0);\r\nreturn check_condition_result;\r\n}\r\nspf = !!(arr[off] & 0x40);\r\npg_len = spf ? ((arr[off + 2] << 8) + arr[off + 3] + 4) :\r\n(arr[off + 1] + 2);\r\nif ((pg_len + off) > param_len) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nPARAMETER_LIST_LENGTH_ERR, 0);\r\nreturn check_condition_result;\r\n}\r\nswitch (mpage) {\r\ncase 0xa:\r\nif (ctrl_m_pg[1] == arr[off + 1]) {\r\nmemcpy(ctrl_m_pg + 2, arr + off + 2,\r\nsizeof(ctrl_m_pg) - 2);\r\nscsi_debug_dsense = !!(ctrl_m_pg[2] & 0x4);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase 0x1c:\r\nif (iec_m_pg[1] == arr[off + 1]) {\r\nmemcpy(iec_m_pg + 2, arr + off + 2,\r\nsizeof(iec_m_pg) - 2);\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_PARAM_LIST, 0);\r\nreturn check_condition_result;\r\n}\r\nstatic int resp_temp_l_pg(unsigned char * arr)\r\n{\r\nunsigned char temp_l_pg[] = {0x0, 0x0, 0x3, 0x2, 0x0, 38,\r\n0x0, 0x1, 0x3, 0x2, 0x0, 65,\r\n};\r\nmemcpy(arr, temp_l_pg, sizeof(temp_l_pg));\r\nreturn sizeof(temp_l_pg);\r\n}\r\nstatic int resp_ie_l_pg(unsigned char * arr)\r\n{\r\nunsigned char ie_l_pg[] = {0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 38,\r\n};\r\nmemcpy(arr, ie_l_pg, sizeof(ie_l_pg));\r\nif (iec_m_pg[2] & 0x4) {\r\narr[4] = THRESHOLD_EXCEEDED;\r\narr[5] = 0xff;\r\n}\r\nreturn sizeof(ie_l_pg);\r\n}\r\nstatic int resp_log_sense(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nint ppc, sp, pcontrol, pcode, subpcode, alloc_len, errsts, len, n;\r\nunsigned char arr[SDEBUG_MAX_LSENSE_SZ];\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nif ((errsts = check_readiness(scp, 1, devip)))\r\nreturn errsts;\r\nmemset(arr, 0, sizeof(arr));\r\nppc = cmd[1] & 0x2;\r\nsp = cmd[1] & 0x1;\r\nif (ppc || sp) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\npcontrol = (cmd[2] & 0xc0) >> 6;\r\npcode = cmd[2] & 0x3f;\r\nsubpcode = cmd[3] & 0xff;\r\nalloc_len = (cmd[7] << 8) + cmd[8];\r\narr[0] = pcode;\r\nif (0 == subpcode) {\r\nswitch (pcode) {\r\ncase 0x0:\r\nn = 4;\r\narr[n++] = 0x0;\r\narr[n++] = 0xd;\r\narr[n++] = 0x2f;\r\narr[3] = n - 4;\r\nbreak;\r\ncase 0xd:\r\narr[3] = resp_temp_l_pg(arr + 4);\r\nbreak;\r\ncase 0x2f:\r\narr[3] = resp_ie_l_pg(arr + 4);\r\nbreak;\r\ndefault:\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\n} else if (0xff == subpcode) {\r\narr[0] |= 0x40;\r\narr[1] = subpcode;\r\nswitch (pcode) {\r\ncase 0x0:\r\nn = 4;\r\narr[n++] = 0x0;\r\narr[n++] = 0x0;\r\narr[n++] = 0x0;\r\narr[n++] = 0xff;\r\narr[n++] = 0xd;\r\narr[n++] = 0x0;\r\narr[n++] = 0x2f;\r\narr[n++] = 0x0;\r\narr[3] = n - 4;\r\nbreak;\r\ncase 0xd:\r\nn = 4;\r\narr[n++] = 0xd;\r\narr[n++] = 0x0;\r\narr[3] = n - 4;\r\nbreak;\r\ncase 0x2f:\r\nn = 4;\r\narr[n++] = 0x2f;\r\narr[n++] = 0x0;\r\narr[3] = n - 4;\r\nbreak;\r\ndefault:\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\n} else {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\nlen = min(((arr[2] << 8) + arr[3]) + 4, alloc_len);\r\nreturn fill_from_dev_buffer(scp, arr,\r\nmin(len, SDEBUG_MAX_INQ_ARR_SZ));\r\n}\r\nstatic int check_device_access_params(struct sdebug_dev_info *devi,\r\nunsigned long long lba, unsigned int num)\r\n{\r\nif (lba + num > sdebug_capacity) {\r\nmk_sense_buffer(devi, ILLEGAL_REQUEST, ADDR_OUT_OF_RANGE, 0);\r\nreturn check_condition_result;\r\n}\r\nif (num > sdebug_store_sectors) {\r\nmk_sense_buffer(devi, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);\r\nreturn check_condition_result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_device_access(struct scsi_cmnd *scmd,\r\nstruct sdebug_dev_info *devi,\r\nunsigned long long lba, unsigned int num, int write)\r\n{\r\nint ret;\r\nunsigned long long block, rest = 0;\r\nint (*func)(struct scsi_cmnd *, unsigned char *, int);\r\nfunc = write ? fetch_to_dev_buffer : fill_from_dev_buffer;\r\nblock = do_div(lba, sdebug_store_sectors);\r\nif (block + num > sdebug_store_sectors)\r\nrest = block + num - sdebug_store_sectors;\r\nret = func(scmd, fake_storep + (block * scsi_debug_sector_size),\r\n(num - rest) * scsi_debug_sector_size);\r\nif (!ret && rest)\r\nret = func(scmd, fake_storep, rest * scsi_debug_sector_size);\r\nreturn ret;\r\n}\r\nstatic int prot_verify_read(struct scsi_cmnd *SCpnt, sector_t start_sec,\r\nunsigned int sectors, u32 ei_lba)\r\n{\r\nunsigned int i, resid;\r\nstruct scatterlist *psgl;\r\nstruct sd_dif_tuple *sdt;\r\nsector_t sector;\r\nsector_t tmp_sec = start_sec;\r\nvoid *paddr;\r\nstart_sec = do_div(tmp_sec, sdebug_store_sectors);\r\nsdt = (struct sd_dif_tuple *)(dif_storep + dif_offset(start_sec));\r\nfor (i = 0 ; i < sectors ; i++) {\r\nu16 csum;\r\nif (sdt[i].app_tag == 0xffff)\r\ncontinue;\r\nsector = start_sec + i;\r\nswitch (scsi_debug_guard) {\r\ncase 1:\r\ncsum = ip_compute_csum(fake_storep +\r\nsector * scsi_debug_sector_size,\r\nscsi_debug_sector_size);\r\nbreak;\r\ncase 0:\r\ncsum = crc_t10dif(fake_storep +\r\nsector * scsi_debug_sector_size,\r\nscsi_debug_sector_size);\r\ncsum = cpu_to_be16(csum);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (sdt[i].guard_tag != csum) {\r\nprintk(KERN_ERR "%s: GUARD check failed on sector %lu" \\r\n" rcvd 0x%04x, data 0x%04x\n", __func__,\r\n(unsigned long)sector,\r\nbe16_to_cpu(sdt[i].guard_tag),\r\nbe16_to_cpu(csum));\r\ndif_errors++;\r\nreturn 0x01;\r\n}\r\nif (scsi_debug_dif == SD_DIF_TYPE1_PROTECTION &&\r\nbe32_to_cpu(sdt[i].ref_tag) != (sector & 0xffffffff)) {\r\nprintk(KERN_ERR "%s: REF check failed on sector %lu\n",\r\n__func__, (unsigned long)sector);\r\ndif_errors++;\r\nreturn 0x03;\r\n}\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION &&\r\nbe32_to_cpu(sdt[i].ref_tag) != ei_lba) {\r\nprintk(KERN_ERR "%s: REF check failed on sector %lu\n",\r\n__func__, (unsigned long)sector);\r\ndif_errors++;\r\nreturn 0x03;\r\n}\r\nei_lba++;\r\n}\r\nresid = sectors * 8;\r\nsector = start_sec;\r\nscsi_for_each_prot_sg(SCpnt, psgl, scsi_prot_sg_count(SCpnt), i) {\r\nint len = min(psgl->length, resid);\r\npaddr = kmap_atomic(sg_page(psgl), KM_IRQ0) + psgl->offset;\r\nmemcpy(paddr, dif_storep + dif_offset(sector), len);\r\nsector += len >> 3;\r\nif (sector >= sdebug_store_sectors) {\r\ntmp_sec = sector;\r\nsector = do_div(tmp_sec, sdebug_store_sectors);\r\n}\r\nresid -= len;\r\nkunmap_atomic(paddr, KM_IRQ0);\r\n}\r\ndix_reads++;\r\nreturn 0;\r\n}\r\nstatic int resp_read(struct scsi_cmnd *SCpnt, unsigned long long lba,\r\nunsigned int num, struct sdebug_dev_info *devip,\r\nu32 ei_lba)\r\n{\r\nunsigned long iflags;\r\nint ret;\r\nret = check_device_access_params(devip, lba, num);\r\nif (ret)\r\nreturn ret;\r\nif ((SCSI_DEBUG_OPT_MEDIUM_ERR & scsi_debug_opts) &&\r\n(lba <= (OPT_MEDIUM_ERR_ADDR + OPT_MEDIUM_ERR_NUM - 1)) &&\r\n((lba + num) > OPT_MEDIUM_ERR_ADDR)) {\r\nmk_sense_buffer(devip, MEDIUM_ERROR, UNRECOVERED_READ_ERR, 0);\r\nif (0x70 == (devip->sense_buff[0] & 0x7f)) {\r\ndevip->sense_buff[0] |= 0x80;\r\nret = (lba < OPT_MEDIUM_ERR_ADDR)\r\n? OPT_MEDIUM_ERR_ADDR : (int)lba;\r\ndevip->sense_buff[3] = (ret >> 24) & 0xff;\r\ndevip->sense_buff[4] = (ret >> 16) & 0xff;\r\ndevip->sense_buff[5] = (ret >> 8) & 0xff;\r\ndevip->sense_buff[6] = ret & 0xff;\r\n}\r\nscsi_set_resid(SCpnt, scsi_bufflen(SCpnt));\r\nreturn check_condition_result;\r\n}\r\nif (scsi_debug_dix && scsi_prot_sg_count(SCpnt)) {\r\nint prot_ret = prot_verify_read(SCpnt, lba, num, ei_lba);\r\nif (prot_ret) {\r\nmk_sense_buffer(devip, ABORTED_COMMAND, 0x10, prot_ret);\r\nreturn illegal_condition_result;\r\n}\r\n}\r\nread_lock_irqsave(&atomic_rw, iflags);\r\nret = do_device_access(SCpnt, devip, lba, num, 0);\r\nread_unlock_irqrestore(&atomic_rw, iflags);\r\nreturn ret;\r\n}\r\nvoid dump_sector(unsigned char *buf, int len)\r\n{\r\nint i, j;\r\nprintk(KERN_ERR ">>> Sector Dump <<<\n");\r\nfor (i = 0 ; i < len ; i += 16) {\r\nprintk(KERN_ERR "%04d: ", i);\r\nfor (j = 0 ; j < 16 ; j++) {\r\nunsigned char c = buf[i+j];\r\nif (c >= 0x20 && c < 0x7e)\r\nprintk(" %c ", buf[i+j]);\r\nelse\r\nprintk("%02x ", buf[i+j]);\r\n}\r\nprintk("\n");\r\n}\r\n}\r\nstatic int prot_verify_write(struct scsi_cmnd *SCpnt, sector_t start_sec,\r\nunsigned int sectors, u32 ei_lba)\r\n{\r\nint i, j, ret;\r\nstruct sd_dif_tuple *sdt;\r\nstruct scatterlist *dsgl = scsi_sglist(SCpnt);\r\nstruct scatterlist *psgl = scsi_prot_sglist(SCpnt);\r\nvoid *daddr, *paddr;\r\nsector_t tmp_sec = start_sec;\r\nsector_t sector;\r\nint ppage_offset;\r\nunsigned short csum;\r\nsector = do_div(tmp_sec, sdebug_store_sectors);\r\nBUG_ON(scsi_sg_count(SCpnt) == 0);\r\nBUG_ON(scsi_prot_sg_count(SCpnt) == 0);\r\npaddr = kmap_atomic(sg_page(psgl), KM_IRQ1) + psgl->offset;\r\nppage_offset = 0;\r\nscsi_for_each_sg(SCpnt, dsgl, scsi_sg_count(SCpnt), i) {\r\ndaddr = kmap_atomic(sg_page(dsgl), KM_IRQ0) + dsgl->offset;\r\nfor (j = 0 ; j < dsgl->length ; j += scsi_debug_sector_size) {\r\nif (ppage_offset >= psgl->length) {\r\nkunmap_atomic(paddr, KM_IRQ1);\r\npsgl = sg_next(psgl);\r\nBUG_ON(psgl == NULL);\r\npaddr = kmap_atomic(sg_page(psgl), KM_IRQ1)\r\n+ psgl->offset;\r\nppage_offset = 0;\r\n}\r\nsdt = paddr + ppage_offset;\r\nswitch (scsi_debug_guard) {\r\ncase 1:\r\ncsum = ip_compute_csum(daddr,\r\nscsi_debug_sector_size);\r\nbreak;\r\ncase 0:\r\ncsum = cpu_to_be16(crc_t10dif(daddr,\r\nscsi_debug_sector_size));\r\nbreak;\r\ndefault:\r\nBUG();\r\nret = 0;\r\ngoto out;\r\n}\r\nif (sdt->guard_tag != csum) {\r\nprintk(KERN_ERR\r\n"%s: GUARD check failed on sector %lu " \\r\n"rcvd 0x%04x, calculated 0x%04x\n",\r\n__func__, (unsigned long)sector,\r\nbe16_to_cpu(sdt->guard_tag),\r\nbe16_to_cpu(csum));\r\nret = 0x01;\r\ndump_sector(daddr, scsi_debug_sector_size);\r\ngoto out;\r\n}\r\nif (scsi_debug_dif == SD_DIF_TYPE1_PROTECTION &&\r\nbe32_to_cpu(sdt->ref_tag)\r\n!= (start_sec & 0xffffffff)) {\r\nprintk(KERN_ERR\r\n"%s: REF check failed on sector %lu\n",\r\n__func__, (unsigned long)sector);\r\nret = 0x03;\r\ndump_sector(daddr, scsi_debug_sector_size);\r\ngoto out;\r\n}\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION &&\r\nbe32_to_cpu(sdt->ref_tag) != ei_lba) {\r\nprintk(KERN_ERR\r\n"%s: REF check failed on sector %lu\n",\r\n__func__, (unsigned long)sector);\r\nret = 0x03;\r\ndump_sector(daddr, scsi_debug_sector_size);\r\ngoto out;\r\n}\r\nmemcpy(dif_storep + dif_offset(sector), sdt, 8);\r\nsector++;\r\nif (sector == sdebug_store_sectors)\r\nsector = 0;\r\nstart_sec++;\r\nei_lba++;\r\ndaddr += scsi_debug_sector_size;\r\nppage_offset += sizeof(struct sd_dif_tuple);\r\n}\r\nkunmap_atomic(daddr, KM_IRQ0);\r\n}\r\nkunmap_atomic(paddr, KM_IRQ1);\r\ndix_writes++;\r\nreturn 0;\r\nout:\r\ndif_errors++;\r\nkunmap_atomic(daddr, KM_IRQ0);\r\nkunmap_atomic(paddr, KM_IRQ1);\r\nreturn ret;\r\n}\r\nstatic unsigned int map_state(sector_t lba, unsigned int *num)\r\n{\r\nunsigned int granularity, alignment, mapped;\r\nsector_t block, next, end;\r\ngranularity = scsi_debug_unmap_granularity;\r\nalignment = granularity - scsi_debug_unmap_alignment;\r\nblock = lba + alignment;\r\ndo_div(block, granularity);\r\nmapped = test_bit(block, map_storep);\r\nif (mapped)\r\nnext = find_next_zero_bit(map_storep, map_size, block);\r\nelse\r\nnext = find_next_bit(map_storep, map_size, block);\r\nend = next * granularity - scsi_debug_unmap_alignment;\r\n*num = end - lba;\r\nreturn mapped;\r\n}\r\nstatic void map_region(sector_t lba, unsigned int len)\r\n{\r\nunsigned int granularity, alignment;\r\nsector_t end = lba + len;\r\ngranularity = scsi_debug_unmap_granularity;\r\nalignment = granularity - scsi_debug_unmap_alignment;\r\nwhile (lba < end) {\r\nsector_t block, rem;\r\nblock = lba + alignment;\r\nrem = do_div(block, granularity);\r\nif (block < map_size)\r\nset_bit(block, map_storep);\r\nlba += granularity - rem;\r\n}\r\n}\r\nstatic void unmap_region(sector_t lba, unsigned int len)\r\n{\r\nunsigned int granularity, alignment;\r\nsector_t end = lba + len;\r\ngranularity = scsi_debug_unmap_granularity;\r\nalignment = granularity - scsi_debug_unmap_alignment;\r\nwhile (lba < end) {\r\nsector_t block, rem;\r\nblock = lba + alignment;\r\nrem = do_div(block, granularity);\r\nif (rem == 0 && lba + granularity <= end &&\r\nblock < map_size)\r\nclear_bit(block, map_storep);\r\nlba += granularity - rem;\r\n}\r\n}\r\nstatic int resp_write(struct scsi_cmnd *SCpnt, unsigned long long lba,\r\nunsigned int num, struct sdebug_dev_info *devip,\r\nu32 ei_lba)\r\n{\r\nunsigned long iflags;\r\nint ret;\r\nret = check_device_access_params(devip, lba, num);\r\nif (ret)\r\nreturn ret;\r\nif (scsi_debug_dix && scsi_prot_sg_count(SCpnt)) {\r\nint prot_ret = prot_verify_write(SCpnt, lba, num, ei_lba);\r\nif (prot_ret) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, 0x10, prot_ret);\r\nreturn illegal_condition_result;\r\n}\r\n}\r\nwrite_lock_irqsave(&atomic_rw, iflags);\r\nret = do_device_access(SCpnt, devip, lba, num, 1);\r\nif (scsi_debug_unmap_granularity)\r\nmap_region(lba, num);\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nif (-1 == ret)\r\nreturn (DID_ERROR << 16);\r\nelse if ((ret < (num * scsi_debug_sector_size)) &&\r\n(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts))\r\nprintk(KERN_INFO "scsi_debug: write: cdb indicated=%u, "\r\n" IO sent=%d bytes\n", num * scsi_debug_sector_size, ret);\r\nreturn 0;\r\n}\r\nstatic int resp_write_same(struct scsi_cmnd *scmd, unsigned long long lba,\r\nunsigned int num, struct sdebug_dev_info *devip,\r\nu32 ei_lba, unsigned int unmap)\r\n{\r\nunsigned long iflags;\r\nunsigned long long i;\r\nint ret;\r\nret = check_device_access_params(devip, lba, num);\r\nif (ret)\r\nreturn ret;\r\nif (num > scsi_debug_write_same_length) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB,\r\n0);\r\nreturn check_condition_result;\r\n}\r\nwrite_lock_irqsave(&atomic_rw, iflags);\r\nif (unmap && scsi_debug_unmap_granularity) {\r\nunmap_region(lba, num);\r\ngoto out;\r\n}\r\nret = fetch_to_dev_buffer(scmd,\r\nfake_storep + (lba * scsi_debug_sector_size),\r\nscsi_debug_sector_size);\r\nif (-1 == ret) {\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nreturn (DID_ERROR << 16);\r\n} else if ((ret < (num * scsi_debug_sector_size)) &&\r\n(SCSI_DEBUG_OPT_NOISE & scsi_debug_opts))\r\nprintk(KERN_INFO "scsi_debug: write same: cdb indicated=%u, "\r\n" IO sent=%d bytes\n", num * scsi_debug_sector_size, ret);\r\nfor (i = 1 ; i < num ; i++)\r\nmemcpy(fake_storep + ((lba + i) * scsi_debug_sector_size),\r\nfake_storep + (lba * scsi_debug_sector_size),\r\nscsi_debug_sector_size);\r\nif (scsi_debug_unmap_granularity)\r\nmap_region(lba, num);\r\nout:\r\nwrite_unlock_irqrestore(&atomic_rw, iflags);\r\nreturn 0;\r\n}\r\nstatic int resp_unmap(struct scsi_cmnd * scmd, struct sdebug_dev_info * devip)\r\n{\r\nunsigned char *buf;\r\nstruct unmap_block_desc *desc;\r\nunsigned int i, payload_len, descriptors;\r\nint ret;\r\nret = check_readiness(scmd, 1, devip);\r\nif (ret)\r\nreturn ret;\r\npayload_len = get_unaligned_be16(&scmd->cmnd[7]);\r\nBUG_ON(scsi_bufflen(scmd) != payload_len);\r\ndescriptors = (payload_len - 8) / 16;\r\nbuf = kmalloc(scsi_bufflen(scmd), GFP_ATOMIC);\r\nif (!buf)\r\nreturn check_condition_result;\r\nscsi_sg_copy_to_buffer(scmd, buf, scsi_bufflen(scmd));\r\nBUG_ON(get_unaligned_be16(&buf[0]) != payload_len - 2);\r\nBUG_ON(get_unaligned_be16(&buf[2]) != descriptors * 16);\r\ndesc = (void *)&buf[8];\r\nfor (i = 0 ; i < descriptors ; i++) {\r\nunsigned long long lba = get_unaligned_be64(&desc[i].lba);\r\nunsigned int num = get_unaligned_be32(&desc[i].blocks);\r\nret = check_device_access_params(devip, lba, num);\r\nif (ret)\r\ngoto out;\r\nunmap_region(lba, num);\r\n}\r\nret = 0;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int resp_get_lba_status(struct scsi_cmnd * scmd,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned long long lba;\r\nunsigned int alloc_len, mapped, num;\r\nunsigned char arr[SDEBUG_GET_LBA_STATUS_LEN];\r\nint ret;\r\nret = check_readiness(scmd, 1, devip);\r\nif (ret)\r\nreturn ret;\r\nlba = get_unaligned_be64(&scmd->cmnd[2]);\r\nalloc_len = get_unaligned_be32(&scmd->cmnd[10]);\r\nif (alloc_len < 24)\r\nreturn 0;\r\nret = check_device_access_params(devip, lba, 1);\r\nif (ret)\r\nreturn ret;\r\nmapped = map_state(lba, &num);\r\nmemset(arr, 0, SDEBUG_GET_LBA_STATUS_LEN);\r\nput_unaligned_be32(16, &arr[0]);\r\nput_unaligned_be64(lba, &arr[8]);\r\nput_unaligned_be32(num, &arr[16]);\r\narr[20] = !mapped;\r\nreturn fill_from_dev_buffer(scmd, arr, SDEBUG_GET_LBA_STATUS_LEN);\r\n}\r\nstatic int resp_report_luns(struct scsi_cmnd * scp,\r\nstruct sdebug_dev_info * devip)\r\n{\r\nunsigned int alloc_len;\r\nint lun_cnt, i, upper, num, n, wlun, lun;\r\nunsigned char *cmd = (unsigned char *)scp->cmnd;\r\nint select_report = (int)cmd[2];\r\nstruct scsi_lun *one_lun;\r\nunsigned char arr[SDEBUG_RLUN_ARR_SZ];\r\nunsigned char * max_addr;\r\nalloc_len = cmd[9] + (cmd[8] << 8) + (cmd[7] << 16) + (cmd[6] << 24);\r\nif ((alloc_len < 4) || (select_report > 2)) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB,\r\n0);\r\nreturn check_condition_result;\r\n}\r\nmemset(arr, 0, SDEBUG_RLUN_ARR_SZ);\r\nlun_cnt = scsi_debug_max_luns;\r\nif (1 == select_report)\r\nlun_cnt = 0;\r\nelse if (scsi_debug_no_lun_0 && (lun_cnt > 0))\r\n--lun_cnt;\r\nwlun = (select_report > 0) ? 1 : 0;\r\nnum = lun_cnt + wlun;\r\narr[2] = ((sizeof(struct scsi_lun) * num) >> 8) & 0xff;\r\narr[3] = (sizeof(struct scsi_lun) * num) & 0xff;\r\nn = min((int)((SDEBUG_RLUN_ARR_SZ - 8) /\r\nsizeof(struct scsi_lun)), num);\r\nif (n < num) {\r\nwlun = 0;\r\nlun_cnt = n;\r\n}\r\none_lun = (struct scsi_lun *) &arr[8];\r\nmax_addr = arr + SDEBUG_RLUN_ARR_SZ;\r\nfor (i = 0, lun = (scsi_debug_no_lun_0 ? 1 : 0);\r\n((i < lun_cnt) && ((unsigned char *)(one_lun + i) < max_addr));\r\ni++, lun++) {\r\nupper = (lun >> 8) & 0x3f;\r\nif (upper)\r\none_lun[i].scsi_lun[0] =\r\n(upper | (SAM2_LUN_ADDRESS_METHOD << 6));\r\none_lun[i].scsi_lun[1] = lun & 0xff;\r\n}\r\nif (wlun) {\r\none_lun[i].scsi_lun[0] = (SAM2_WLUN_REPORT_LUNS >> 8) & 0xff;\r\none_lun[i].scsi_lun[1] = SAM2_WLUN_REPORT_LUNS & 0xff;\r\ni++;\r\n}\r\nalloc_len = (unsigned char *)(one_lun + i) - arr;\r\nreturn fill_from_dev_buffer(scp, arr,\r\nmin((int)alloc_len, SDEBUG_RLUN_ARR_SZ));\r\n}\r\nstatic int resp_xdwriteread(struct scsi_cmnd *scp, unsigned long long lba,\r\nunsigned int num, struct sdebug_dev_info *devip)\r\n{\r\nint i, j, ret = -1;\r\nunsigned char *kaddr, *buf;\r\nunsigned int offset;\r\nstruct scatterlist *sg;\r\nstruct scsi_data_buffer *sdb = scsi_in(scp);\r\nbuf = kmalloc(scsi_bufflen(scp), GFP_ATOMIC);\r\nif (!buf)\r\nreturn ret;\r\nscsi_sg_copy_to_buffer(scp, buf, scsi_bufflen(scp));\r\noffset = 0;\r\nfor_each_sg(sdb->table.sgl, sg, sdb->table.nents, i) {\r\nkaddr = (unsigned char *)kmap_atomic(sg_page(sg), KM_USER0);\r\nif (!kaddr)\r\ngoto out;\r\nfor (j = 0; j < sg->length; j++)\r\n*(kaddr + sg->offset + j) ^= *(buf + offset + j);\r\noffset += sg->length;\r\nkunmap_atomic(kaddr, KM_USER0);\r\n}\r\nret = 0;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void timer_intr_handler(unsigned long indx)\r\n{\r\nstruct sdebug_queued_cmd * sqcp;\r\nunsigned long iflags;\r\nif (indx >= scsi_debug_max_queue) {\r\nprintk(KERN_ERR "scsi_debug:timer_intr_handler: indx too "\r\n"large\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nsqcp = &queued_arr[(int)indx];\r\nif (! sqcp->in_use) {\r\nprintk(KERN_ERR "scsi_debug:timer_intr_handler: Unexpected "\r\n"interrupt\n");\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nreturn;\r\n}\r\nsqcp->in_use = 0;\r\nif (sqcp->done_funct) {\r\nsqcp->a_cmnd->result = sqcp->scsi_result;\r\nsqcp->done_funct(sqcp->a_cmnd);\r\n}\r\nsqcp->done_funct = NULL;\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\n}\r\nstatic struct sdebug_dev_info *\r\nsdebug_device_create(struct sdebug_host_info *sdbg_host, gfp_t flags)\r\n{\r\nstruct sdebug_dev_info *devip;\r\ndevip = kzalloc(sizeof(*devip), flags);\r\nif (devip) {\r\ndevip->sdbg_host = sdbg_host;\r\nlist_add_tail(&devip->dev_list, &sdbg_host->dev_info_list);\r\n}\r\nreturn devip;\r\n}\r\nstatic struct sdebug_dev_info * devInfoReg(struct scsi_device * sdev)\r\n{\r\nstruct sdebug_host_info * sdbg_host;\r\nstruct sdebug_dev_info * open_devip = NULL;\r\nstruct sdebug_dev_info * devip =\r\n(struct sdebug_dev_info *)sdev->hostdata;\r\nif (devip)\r\nreturn devip;\r\nsdbg_host = *(struct sdebug_host_info **)shost_priv(sdev->host);\r\nif (!sdbg_host) {\r\nprintk(KERN_ERR "Host info NULL\n");\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(devip, &sdbg_host->dev_info_list, dev_list) {\r\nif ((devip->used) && (devip->channel == sdev->channel) &&\r\n(devip->target == sdev->id) &&\r\n(devip->lun == sdev->lun))\r\nreturn devip;\r\nelse {\r\nif ((!devip->used) && (!open_devip))\r\nopen_devip = devip;\r\n}\r\n}\r\nif (!open_devip) {\r\nopen_devip = sdebug_device_create(sdbg_host, GFP_ATOMIC);\r\nif (!open_devip) {\r\nprintk(KERN_ERR "%s: out of memory at line %d\n",\r\n__func__, __LINE__);\r\nreturn NULL;\r\n}\r\n}\r\nopen_devip->channel = sdev->channel;\r\nopen_devip->target = sdev->id;\r\nopen_devip->lun = sdev->lun;\r\nopen_devip->sdbg_host = sdbg_host;\r\nopen_devip->reset = 1;\r\nopen_devip->used = 1;\r\nmemset(open_devip->sense_buff, 0, SDEBUG_SENSE_LEN);\r\nif (scsi_debug_dsense)\r\nopen_devip->sense_buff[0] = 0x72;\r\nelse {\r\nopen_devip->sense_buff[0] = 0x70;\r\nopen_devip->sense_buff[7] = 0xa;\r\n}\r\nif (sdev->lun == SAM2_WLUN_REPORT_LUNS)\r\nopen_devip->wlun = SAM2_WLUN_REPORT_LUNS & 0xff;\r\nreturn open_devip;\r\n}\r\nstatic int scsi_debug_slave_alloc(struct scsi_device *sdp)\r\n{\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: slave_alloc <%u %u %u %u>\n",\r\nsdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\r\nqueue_flag_set_unlocked(QUEUE_FLAG_BIDI, sdp->request_queue);\r\nreturn 0;\r\n}\r\nstatic int scsi_debug_slave_configure(struct scsi_device *sdp)\r\n{\r\nstruct sdebug_dev_info *devip;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: slave_configure <%u %u %u %u>\n",\r\nsdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\r\nif (sdp->host->max_cmd_len != SCSI_DEBUG_MAX_CMD_LEN)\r\nsdp->host->max_cmd_len = SCSI_DEBUG_MAX_CMD_LEN;\r\ndevip = devInfoReg(sdp);\r\nif (NULL == devip)\r\nreturn 1;\r\nsdp->hostdata = devip;\r\nif (sdp->host->cmd_per_lun)\r\nscsi_adjust_queue_depth(sdp, SDEBUG_TAGGED_QUEUING,\r\nsdp->host->cmd_per_lun);\r\nblk_queue_max_segment_size(sdp->request_queue, 256 * 1024);\r\nif (scsi_debug_no_uld)\r\nsdp->no_uld_attach = 1;\r\nreturn 0;\r\n}\r\nstatic void scsi_debug_slave_destroy(struct scsi_device *sdp)\r\n{\r\nstruct sdebug_dev_info *devip =\r\n(struct sdebug_dev_info *)sdp->hostdata;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: slave_destroy <%u %u %u %u>\n",\r\nsdp->host->host_no, sdp->channel, sdp->id, sdp->lun);\r\nif (devip) {\r\ndevip->used = 0;\r\nsdp->hostdata = NULL;\r\n}\r\n}\r\nstatic int stop_queued_cmnd(struct scsi_cmnd *cmnd)\r\n{\r\nunsigned long iflags;\r\nint k;\r\nstruct sdebug_queued_cmd *sqcp;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nfor (k = 0; k < scsi_debug_max_queue; ++k) {\r\nsqcp = &queued_arr[k];\r\nif (sqcp->in_use && (cmnd == sqcp->a_cmnd)) {\r\ndel_timer_sync(&sqcp->cmnd_timer);\r\nsqcp->in_use = 0;\r\nsqcp->a_cmnd = NULL;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nreturn (k < scsi_debug_max_queue) ? 1 : 0;\r\n}\r\nstatic void stop_all_queued(void)\r\n{\r\nunsigned long iflags;\r\nint k;\r\nstruct sdebug_queued_cmd *sqcp;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nfor (k = 0; k < scsi_debug_max_queue; ++k) {\r\nsqcp = &queued_arr[k];\r\nif (sqcp->in_use && sqcp->a_cmnd) {\r\ndel_timer_sync(&sqcp->cmnd_timer);\r\nsqcp->in_use = 0;\r\nsqcp->a_cmnd = NULL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\n}\r\nstatic int scsi_debug_abort(struct scsi_cmnd * SCpnt)\r\n{\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: abort\n");\r\n++num_aborts;\r\nstop_queued_cmnd(SCpnt);\r\nreturn SUCCESS;\r\n}\r\nstatic int scsi_debug_biosparam(struct scsi_device *sdev,\r\nstruct block_device * bdev, sector_t capacity, int *info)\r\n{\r\nint res;\r\nunsigned char *buf;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: biosparam\n");\r\nbuf = scsi_bios_ptable(bdev);\r\nif (buf) {\r\nres = scsi_partsize(buf, capacity,\r\n&info[2], &info[0], &info[1]);\r\nkfree(buf);\r\nif (! res)\r\nreturn res;\r\n}\r\ninfo[0] = sdebug_heads;\r\ninfo[1] = sdebug_sectors_per;\r\ninfo[2] = sdebug_cylinders_per;\r\nreturn 0;\r\n}\r\nstatic int scsi_debug_device_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nstruct sdebug_dev_info * devip;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: device_reset\n");\r\n++num_dev_resets;\r\nif (SCpnt) {\r\ndevip = devInfoReg(SCpnt->device);\r\nif (devip)\r\ndevip->reset = 1;\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int scsi_debug_bus_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct sdebug_dev_info * dev_info;\r\nstruct scsi_device * sdp;\r\nstruct Scsi_Host * hp;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: bus_reset\n");\r\n++num_bus_resets;\r\nif (SCpnt && ((sdp = SCpnt->device)) && ((hp = sdp->host))) {\r\nsdbg_host = *(struct sdebug_host_info **)shost_priv(hp);\r\nif (sdbg_host) {\r\nlist_for_each_entry(dev_info,\r\n&sdbg_host->dev_info_list,\r\ndev_list)\r\ndev_info->reset = 1;\r\n}\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int scsi_debug_host_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nstruct sdebug_host_info * sdbg_host;\r\nstruct sdebug_dev_info * dev_info;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: host_reset\n");\r\n++num_host_resets;\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_for_each_entry(sdbg_host, &sdebug_host_list, host_list) {\r\nlist_for_each_entry(dev_info, &sdbg_host->dev_info_list,\r\ndev_list)\r\ndev_info->reset = 1;\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\nstop_all_queued();\r\nreturn SUCCESS;\r\n}\r\nstatic void __init init_all_queued(void)\r\n{\r\nunsigned long iflags;\r\nint k;\r\nstruct sdebug_queued_cmd * sqcp;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nfor (k = 0; k < scsi_debug_max_queue; ++k) {\r\nsqcp = &queued_arr[k];\r\ninit_timer(&sqcp->cmnd_timer);\r\nsqcp->in_use = 0;\r\nsqcp->a_cmnd = NULL;\r\n}\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\n}\r\nstatic void __init sdebug_build_parts(unsigned char *ramp,\r\nunsigned long store_size)\r\n{\r\nstruct partition * pp;\r\nint starts[SDEBUG_MAX_PARTS + 2];\r\nint sectors_per_part, num_sectors, k;\r\nint heads_by_sects, start_sec, end_sec;\r\nif ((scsi_debug_num_parts < 1) || (store_size < 1048576))\r\nreturn;\r\nif (scsi_debug_num_parts > SDEBUG_MAX_PARTS) {\r\nscsi_debug_num_parts = SDEBUG_MAX_PARTS;\r\nprintk(KERN_WARNING "scsi_debug:build_parts: reducing "\r\n"partitions to %d\n", SDEBUG_MAX_PARTS);\r\n}\r\nnum_sectors = (int)sdebug_store_sectors;\r\nsectors_per_part = (num_sectors - sdebug_sectors_per)\r\n/ scsi_debug_num_parts;\r\nheads_by_sects = sdebug_heads * sdebug_sectors_per;\r\nstarts[0] = sdebug_sectors_per;\r\nfor (k = 1; k < scsi_debug_num_parts; ++k)\r\nstarts[k] = ((k * sectors_per_part) / heads_by_sects)\r\n* heads_by_sects;\r\nstarts[scsi_debug_num_parts] = num_sectors;\r\nstarts[scsi_debug_num_parts + 1] = 0;\r\nramp[510] = 0x55;\r\nramp[511] = 0xAA;\r\npp = (struct partition *)(ramp + 0x1be);\r\nfor (k = 0; starts[k + 1]; ++k, ++pp) {\r\nstart_sec = starts[k];\r\nend_sec = starts[k + 1] - 1;\r\npp->boot_ind = 0;\r\npp->cyl = start_sec / heads_by_sects;\r\npp->head = (start_sec - (pp->cyl * heads_by_sects))\r\n/ sdebug_sectors_per;\r\npp->sector = (start_sec % sdebug_sectors_per) + 1;\r\npp->end_cyl = end_sec / heads_by_sects;\r\npp->end_head = (end_sec - (pp->end_cyl * heads_by_sects))\r\n/ sdebug_sectors_per;\r\npp->end_sector = (end_sec % sdebug_sectors_per) + 1;\r\npp->start_sect = start_sec;\r\npp->nr_sects = end_sec - start_sec + 1;\r\npp->sys_ind = 0x83;\r\n}\r\n}\r\nstatic int schedule_resp(struct scsi_cmnd * cmnd,\r\nstruct sdebug_dev_info * devip,\r\ndone_funct_t done, int scsi_result, int delta_jiff)\r\n{\r\nif ((SCSI_DEBUG_OPT_NOISE & scsi_debug_opts) && cmnd) {\r\nif (scsi_result) {\r\nstruct scsi_device * sdp = cmnd->device;\r\nprintk(KERN_INFO "scsi_debug: <%u %u %u %u> "\r\n"non-zero result=0x%x\n", sdp->host->host_no,\r\nsdp->channel, sdp->id, sdp->lun, scsi_result);\r\n}\r\n}\r\nif (cmnd && devip) {\r\nif (SAM_STAT_CHECK_CONDITION == (scsi_result & 0xff))\r\nmemcpy(cmnd->sense_buffer, devip->sense_buff,\r\n(SCSI_SENSE_BUFFERSIZE > SDEBUG_SENSE_LEN) ?\r\nSDEBUG_SENSE_LEN : SCSI_SENSE_BUFFERSIZE);\r\n}\r\nif (delta_jiff <= 0) {\r\nif (cmnd)\r\ncmnd->result = scsi_result;\r\nif (done)\r\ndone(cmnd);\r\nreturn 0;\r\n} else {\r\nunsigned long iflags;\r\nint k;\r\nstruct sdebug_queued_cmd * sqcp = NULL;\r\nspin_lock_irqsave(&queued_arr_lock, iflags);\r\nfor (k = 0; k < scsi_debug_max_queue; ++k) {\r\nsqcp = &queued_arr[k];\r\nif (! sqcp->in_use)\r\nbreak;\r\n}\r\nif (k >= scsi_debug_max_queue) {\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nprintk(KERN_WARNING "scsi_debug: can_queue exceeded\n");\r\nreturn 1;\r\n}\r\nsqcp->in_use = 1;\r\nsqcp->a_cmnd = cmnd;\r\nsqcp->scsi_result = scsi_result;\r\nsqcp->done_funct = done;\r\nsqcp->cmnd_timer.function = timer_intr_handler;\r\nsqcp->cmnd_timer.data = k;\r\nsqcp->cmnd_timer.expires = jiffies + delta_jiff;\r\nadd_timer(&sqcp->cmnd_timer);\r\nspin_unlock_irqrestore(&queued_arr_lock, iflags);\r\nif (cmnd)\r\ncmnd->result = 0;\r\nreturn 0;\r\n}\r\n}\r\nstatic const char * scsi_debug_info(struct Scsi_Host * shp)\r\n{\r\nsprintf(sdebug_info, "scsi_debug, version %s [%s], "\r\n"dev_size_mb=%d, opts=0x%x", SCSI_DEBUG_VERSION,\r\nscsi_debug_version_date, scsi_debug_dev_size_mb,\r\nscsi_debug_opts);\r\nreturn sdebug_info;\r\n}\r\nstatic int scsi_debug_proc_info(struct Scsi_Host *host, char *buffer, char **start, off_t offset,\r\nint length, int inout)\r\n{\r\nint len, pos, begin;\r\nint orig_length;\r\norig_length = length;\r\nif (inout == 1) {\r\nchar arr[16];\r\nint minLen = length > 15 ? 15 : length;\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nmemcpy(arr, buffer, minLen);\r\narr[minLen] = '\0';\r\nif (1 != sscanf(arr, "%d", &pos))\r\nreturn -EINVAL;\r\nscsi_debug_opts = pos;\r\nif (scsi_debug_every_nth != 0)\r\nscsi_debug_cmnd_count = 0;\r\nreturn length;\r\n}\r\nbegin = 0;\r\npos = len = sprintf(buffer, "scsi_debug adapter driver, version "\r\n"%s [%s]\n"\r\n"num_tgts=%d, shared (ram) size=%d MB, opts=0x%x, "\r\n"every_nth=%d(curr:%d)\n"\r\n"delay=%d, max_luns=%d, scsi_level=%d\n"\r\n"sector_size=%d bytes, cylinders=%d, heads=%d, sectors=%d\n"\r\n"number of aborts=%d, device_reset=%d, bus_resets=%d, "\r\n"host_resets=%d\ndix_reads=%d dix_writes=%d dif_errors=%d\n",\r\nSCSI_DEBUG_VERSION, scsi_debug_version_date, scsi_debug_num_tgts,\r\nscsi_debug_dev_size_mb, scsi_debug_opts, scsi_debug_every_nth,\r\nscsi_debug_cmnd_count, scsi_debug_delay,\r\nscsi_debug_max_luns, scsi_debug_scsi_level,\r\nscsi_debug_sector_size, sdebug_cylinders_per, sdebug_heads,\r\nsdebug_sectors_per, num_aborts, num_dev_resets, num_bus_resets,\r\nnum_host_resets, dix_reads, dix_writes, dif_errors);\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\n*start = buffer + (offset - begin);\r\nlen -= (offset - begin);\r\nif (len > length)\r\nlen = length;\r\nreturn len;\r\n}\r\nstatic ssize_t sdebug_delay_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_delay);\r\n}\r\nstatic ssize_t sdebug_delay_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint delay;\r\nchar work[20];\r\nif (1 == sscanf(buf, "%10s", work)) {\r\nif ((1 == sscanf(work, "%d", &delay)) && (delay >= 0)) {\r\nscsi_debug_delay = delay;\r\nreturn count;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_opts_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x\n", scsi_debug_opts);\r\n}\r\nstatic ssize_t sdebug_opts_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint opts;\r\nchar work[20];\r\nif (1 == sscanf(buf, "%10s", work)) {\r\nif (0 == strnicmp(work,"0x", 2)) {\r\nif (1 == sscanf(&work[2], "%x", &opts))\r\ngoto opts_done;\r\n} else {\r\nif (1 == sscanf(work, "%d", &opts))\r\ngoto opts_done;\r\n}\r\n}\r\nreturn -EINVAL;\r\nopts_done:\r\nscsi_debug_opts = opts;\r\nscsi_debug_cmnd_count = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t sdebug_ptype_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_ptype);\r\n}\r\nstatic ssize_t sdebug_ptype_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_ptype = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_dsense_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dsense);\r\n}\r\nstatic ssize_t sdebug_dsense_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_dsense = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_fake_rw_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_fake_rw);\r\n}\r\nstatic ssize_t sdebug_fake_rw_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_fake_rw = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_no_lun_0_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_no_lun_0);\r\n}\r\nstatic ssize_t sdebug_no_lun_0_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_no_lun_0 = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_num_tgts_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_num_tgts);\r\n}\r\nstatic ssize_t sdebug_num_tgts_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_num_tgts = n;\r\nsdebug_max_tgts_luns();\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_dev_size_mb_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dev_size_mb);\r\n}\r\nstatic ssize_t sdebug_num_parts_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_num_parts);\r\n}\r\nstatic ssize_t sdebug_every_nth_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_every_nth);\r\n}\r\nstatic ssize_t sdebug_every_nth_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint nth;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &nth))) {\r\nscsi_debug_every_nth = nth;\r\nscsi_debug_cmnd_count = 0;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_max_luns_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_max_luns);\r\n}\r\nstatic ssize_t sdebug_max_luns_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_max_luns = n;\r\nsdebug_max_tgts_luns();\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_max_queue_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_max_queue);\r\n}\r\nstatic ssize_t sdebug_max_queue_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n > 0) &&\r\n(n <= SCSI_DEBUG_CANQUEUE)) {\r\nscsi_debug_max_queue = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_no_uld_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_no_uld);\r\n}\r\nstatic ssize_t sdebug_scsi_level_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_scsi_level);\r\n}\r\nstatic ssize_t sdebug_virtual_gb_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_virtual_gb);\r\n}\r\nstatic ssize_t sdebug_virtual_gb_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_virtual_gb = n;\r\nsdebug_capacity = get_sdebug_capacity();\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_add_host_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_add_host);\r\n}\r\nstatic ssize_t sdebug_add_host_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint delta_hosts;\r\nif (sscanf(buf, "%d", &delta_hosts) != 1)\r\nreturn -EINVAL;\r\nif (delta_hosts > 0) {\r\ndo {\r\nsdebug_add_adapter();\r\n} while (--delta_hosts);\r\n} else if (delta_hosts < 0) {\r\ndo {\r\nsdebug_remove_adapter();\r\n} while (++delta_hosts);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t sdebug_vpd_use_hostno_show(struct device_driver * ddp,\r\nchar * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_vpd_use_hostno);\r\n}\r\nstatic ssize_t sdebug_vpd_use_hostno_store(struct device_driver * ddp,\r\nconst char * buf, size_t count)\r\n{\r\nint n;\r\nif ((count > 0) && (1 == sscanf(buf, "%d", &n)) && (n >= 0)) {\r\nscsi_debug_vpd_use_hostno = n;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sdebug_sector_size_show(struct device_driver * ddp, char * buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", scsi_debug_sector_size);\r\n}\r\nstatic ssize_t sdebug_dix_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dix);\r\n}\r\nstatic ssize_t sdebug_dif_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dif);\r\n}\r\nstatic ssize_t sdebug_guard_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_guard);\r\n}\r\nstatic ssize_t sdebug_ato_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_ato);\r\n}\r\nstatic ssize_t sdebug_map_show(struct device_driver *ddp, char *buf)\r\n{\r\nssize_t count;\r\nif (!scsi_debug_lbp())\r\nreturn scnprintf(buf, PAGE_SIZE, "0-%u\n",\r\nsdebug_store_sectors);\r\ncount = bitmap_scnlistprintf(buf, PAGE_SIZE, map_storep, map_size);\r\nbuf[count++] = '\n';\r\nbuf[count++] = 0;\r\nreturn count;\r\n}\r\nstatic int do_create_driverfs_files(void)\r\n{\r\nint ret;\r\nret = driver_create_file(&sdebug_driverfs_driver, &driver_attr_add_host);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_delay);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_dev_size_mb);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_dsense);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_every_nth);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_fake_rw);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_max_luns);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_max_queue);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_no_lun_0);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_no_uld);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_num_parts);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_num_tgts);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_ptype);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_opts);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_scsi_level);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_virtual_gb);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_vpd_use_hostno);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_sector_size);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_dix);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_dif);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_guard);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_ato);\r\nret |= driver_create_file(&sdebug_driverfs_driver, &driver_attr_map);\r\nreturn ret;\r\n}\r\nstatic void do_remove_driverfs_files(void)\r\n{\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_map);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_ato);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_guard);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_dif);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_dix);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_sector_size);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_vpd_use_hostno);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_virtual_gb);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_scsi_level);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_opts);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_ptype);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_num_tgts);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_num_parts);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_no_uld);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_no_lun_0);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_max_queue);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_max_luns);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_fake_rw);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_every_nth);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_dsense);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_dev_size_mb);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_delay);\r\ndriver_remove_file(&sdebug_driverfs_driver, &driver_attr_add_host);\r\n}\r\nstatic int __init scsi_debug_init(void)\r\n{\r\nunsigned long sz;\r\nint host_to_add;\r\nint k;\r\nint ret;\r\nswitch (scsi_debug_sector_size) {\r\ncase 512:\r\ncase 1024:\r\ncase 2048:\r\ncase 4096:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi_debug_init: invalid sector_size %d\n",\r\nscsi_debug_sector_size);\r\nreturn -EINVAL;\r\n}\r\nswitch (scsi_debug_dif) {\r\ncase SD_DIF_TYPE0_PROTECTION:\r\ncase SD_DIF_TYPE1_PROTECTION:\r\ncase SD_DIF_TYPE2_PROTECTION:\r\ncase SD_DIF_TYPE3_PROTECTION:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi_debug_init: dif must be 0, 1, 2 or 3\n");\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_guard > 1) {\r\nprintk(KERN_ERR "scsi_debug_init: guard must be 0 or 1\n");\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_ato > 1) {\r\nprintk(KERN_ERR "scsi_debug_init: ato must be 0 or 1\n");\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_physblk_exp > 15) {\r\nprintk(KERN_ERR "scsi_debug_init: invalid physblk_exp %u\n",\r\nscsi_debug_physblk_exp);\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_lowest_aligned > 0x3fff) {\r\nprintk(KERN_ERR "scsi_debug_init: lowest_aligned too big: %u\n",\r\nscsi_debug_lowest_aligned);\r\nreturn -EINVAL;\r\n}\r\nif (scsi_debug_dev_size_mb < 1)\r\nscsi_debug_dev_size_mb = 1;\r\nsz = (unsigned long)scsi_debug_dev_size_mb * 1048576;\r\nsdebug_store_sectors = sz / scsi_debug_sector_size;\r\nsdebug_capacity = get_sdebug_capacity();\r\nsdebug_heads = 8;\r\nsdebug_sectors_per = 32;\r\nif (scsi_debug_dev_size_mb >= 16)\r\nsdebug_heads = 32;\r\nelse if (scsi_debug_dev_size_mb >= 256)\r\nsdebug_heads = 64;\r\nsdebug_cylinders_per = (unsigned long)sdebug_capacity /\r\n(sdebug_sectors_per * sdebug_heads);\r\nif (sdebug_cylinders_per >= 1024) {\r\nsdebug_heads = 255;\r\nsdebug_sectors_per = 63;\r\nsdebug_cylinders_per = (unsigned long)sdebug_capacity /\r\n(sdebug_sectors_per * sdebug_heads);\r\n}\r\nfake_storep = vmalloc(sz);\r\nif (NULL == fake_storep) {\r\nprintk(KERN_ERR "scsi_debug_init: out of memory, 1\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(fake_storep, 0, sz);\r\nif (scsi_debug_num_parts > 0)\r\nsdebug_build_parts(fake_storep, sz);\r\nif (scsi_debug_dif) {\r\nint dif_size;\r\ndif_size = sdebug_store_sectors * sizeof(struct sd_dif_tuple);\r\ndif_storep = vmalloc(dif_size);\r\nprintk(KERN_ERR "scsi_debug_init: dif_storep %u bytes @ %p\n",\r\ndif_size, dif_storep);\r\nif (dif_storep == NULL) {\r\nprintk(KERN_ERR "scsi_debug_init: out of mem. (DIX)\n");\r\nret = -ENOMEM;\r\ngoto free_vm;\r\n}\r\nmemset(dif_storep, 0xff, dif_size);\r\n}\r\nif (scsi_debug_lbp()) {\r\nunsigned int map_bytes;\r\nscsi_debug_unmap_max_blocks =\r\nclamp(scsi_debug_unmap_max_blocks, 0U, 0xffffffffU);\r\nscsi_debug_unmap_max_desc =\r\nclamp(scsi_debug_unmap_max_desc, 0U, 256U);\r\nscsi_debug_unmap_granularity =\r\nclamp(scsi_debug_unmap_granularity, 1U, 0xffffffffU);\r\nif (scsi_debug_unmap_alignment &&\r\nscsi_debug_unmap_granularity < scsi_debug_unmap_alignment) {\r\nprintk(KERN_ERR\r\n"%s: ERR: unmap_granularity < unmap_alignment\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nmap_size = (sdebug_store_sectors / scsi_debug_unmap_granularity);\r\nmap_bytes = map_size >> 3;\r\nmap_storep = vmalloc(map_bytes);\r\nprintk(KERN_INFO "scsi_debug_init: %lu provisioning blocks\n",\r\nmap_size);\r\nif (map_storep == NULL) {\r\nprintk(KERN_ERR "scsi_debug_init: out of mem. (MAP)\n");\r\nret = -ENOMEM;\r\ngoto free_vm;\r\n}\r\nmemset(map_storep, 0x0, map_bytes);\r\nif (scsi_debug_num_parts)\r\nmap_region(0, 2);\r\n}\r\npseudo_primary = root_device_register("pseudo_0");\r\nif (IS_ERR(pseudo_primary)) {\r\nprintk(KERN_WARNING "scsi_debug: root_device_register() error\n");\r\nret = PTR_ERR(pseudo_primary);\r\ngoto free_vm;\r\n}\r\nret = bus_register(&pseudo_lld_bus);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "scsi_debug: bus_register error: %d\n",\r\nret);\r\ngoto dev_unreg;\r\n}\r\nret = driver_register(&sdebug_driverfs_driver);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "scsi_debug: driver_register error: %d\n",\r\nret);\r\ngoto bus_unreg;\r\n}\r\nret = do_create_driverfs_files();\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "scsi_debug: driver_create_file error: %d\n",\r\nret);\r\ngoto del_files;\r\n}\r\ninit_all_queued();\r\nhost_to_add = scsi_debug_add_host;\r\nscsi_debug_add_host = 0;\r\nfor (k = 0; k < host_to_add; k++) {\r\nif (sdebug_add_adapter()) {\r\nprintk(KERN_ERR "scsi_debug_init: "\r\n"sdebug_add_adapter failed k=%d\n", k);\r\nbreak;\r\n}\r\n}\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts) {\r\nprintk(KERN_INFO "scsi_debug_init: built %d host(s)\n",\r\nscsi_debug_add_host);\r\n}\r\nreturn 0;\r\ndel_files:\r\ndo_remove_driverfs_files();\r\ndriver_unregister(&sdebug_driverfs_driver);\r\nbus_unreg:\r\nbus_unregister(&pseudo_lld_bus);\r\ndev_unreg:\r\nroot_device_unregister(pseudo_primary);\r\nfree_vm:\r\nif (map_storep)\r\nvfree(map_storep);\r\nif (dif_storep)\r\nvfree(dif_storep);\r\nvfree(fake_storep);\r\nreturn ret;\r\n}\r\nstatic void __exit scsi_debug_exit(void)\r\n{\r\nint k = scsi_debug_add_host;\r\nstop_all_queued();\r\nfor (; k; k--)\r\nsdebug_remove_adapter();\r\ndo_remove_driverfs_files();\r\ndriver_unregister(&sdebug_driverfs_driver);\r\nbus_unregister(&pseudo_lld_bus);\r\nroot_device_unregister(pseudo_primary);\r\nif (dif_storep)\r\nvfree(dif_storep);\r\nvfree(fake_storep);\r\n}\r\nstatic void sdebug_release_adapter(struct device * dev)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nsdbg_host = to_sdebug_host(dev);\r\nkfree(sdbg_host);\r\n}\r\nstatic int sdebug_add_adapter(void)\r\n{\r\nint k, devs_per_host;\r\nint error = 0;\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct sdebug_dev_info *sdbg_devinfo, *tmp;\r\nsdbg_host = kzalloc(sizeof(*sdbg_host),GFP_KERNEL);\r\nif (NULL == sdbg_host) {\r\nprintk(KERN_ERR "%s: out of memory at line %d\n",\r\n__func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&sdbg_host->dev_info_list);\r\ndevs_per_host = scsi_debug_num_tgts * scsi_debug_max_luns;\r\nfor (k = 0; k < devs_per_host; k++) {\r\nsdbg_devinfo = sdebug_device_create(sdbg_host, GFP_KERNEL);\r\nif (!sdbg_devinfo) {\r\nprintk(KERN_ERR "%s: out of memory at line %d\n",\r\n__func__, __LINE__);\r\nerror = -ENOMEM;\r\ngoto clean;\r\n}\r\n}\r\nspin_lock(&sdebug_host_list_lock);\r\nlist_add_tail(&sdbg_host->host_list, &sdebug_host_list);\r\nspin_unlock(&sdebug_host_list_lock);\r\nsdbg_host->dev.bus = &pseudo_lld_bus;\r\nsdbg_host->dev.parent = pseudo_primary;\r\nsdbg_host->dev.release = &sdebug_release_adapter;\r\ndev_set_name(&sdbg_host->dev, "adapter%d", scsi_debug_add_host);\r\nerror = device_register(&sdbg_host->dev);\r\nif (error)\r\ngoto clean;\r\n++scsi_debug_add_host;\r\nreturn error;\r\nclean:\r\nlist_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,\r\ndev_list) {\r\nlist_del(&sdbg_devinfo->dev_list);\r\nkfree(sdbg_devinfo);\r\n}\r\nkfree(sdbg_host);\r\nreturn error;\r\n}\r\nstatic void sdebug_remove_adapter(void)\r\n{\r\nstruct sdebug_host_info * sdbg_host = NULL;\r\nspin_lock(&sdebug_host_list_lock);\r\nif (!list_empty(&sdebug_host_list)) {\r\nsdbg_host = list_entry(sdebug_host_list.prev,\r\nstruct sdebug_host_info, host_list);\r\nlist_del(&sdbg_host->host_list);\r\n}\r\nspin_unlock(&sdebug_host_list_lock);\r\nif (!sdbg_host)\r\nreturn;\r\ndevice_unregister(&sdbg_host->dev);\r\n--scsi_debug_add_host;\r\n}\r\nstatic\r\nint scsi_debug_queuecommand_lck(struct scsi_cmnd *SCpnt, done_funct_t done)\r\n{\r\nunsigned char *cmd = (unsigned char *) SCpnt->cmnd;\r\nint len, k;\r\nunsigned int num;\r\nunsigned long long lba;\r\nu32 ei_lba;\r\nint errsts = 0;\r\nint target = SCpnt->device->id;\r\nstruct sdebug_dev_info *devip = NULL;\r\nint inj_recovered = 0;\r\nint inj_transport = 0;\r\nint inj_dif = 0;\r\nint inj_dix = 0;\r\nint delay_override = 0;\r\nint unmap = 0;\r\nscsi_set_resid(SCpnt, 0);\r\nif ((SCSI_DEBUG_OPT_NOISE & scsi_debug_opts) && cmd) {\r\nprintk(KERN_INFO "scsi_debug: cmd ");\r\nfor (k = 0, len = SCpnt->cmd_len; k < len; ++k)\r\nprintk("%02x ", (int)cmd[k]);\r\nprintk("\n");\r\n}\r\nif (target == SCpnt->device->host->hostt->this_id) {\r\nprintk(KERN_INFO "scsi_debug: initiator's id used as "\r\n"target!\n");\r\nreturn schedule_resp(SCpnt, NULL, done,\r\nDID_NO_CONNECT << 16, 0);\r\n}\r\nif ((SCpnt->device->lun >= scsi_debug_max_luns) &&\r\n(SCpnt->device->lun != SAM2_WLUN_REPORT_LUNS))\r\nreturn schedule_resp(SCpnt, NULL, done,\r\nDID_NO_CONNECT << 16, 0);\r\ndevip = devInfoReg(SCpnt->device);\r\nif (NULL == devip)\r\nreturn schedule_resp(SCpnt, NULL, done,\r\nDID_NO_CONNECT << 16, 0);\r\nif ((scsi_debug_every_nth != 0) &&\r\n(++scsi_debug_cmnd_count >= abs(scsi_debug_every_nth))) {\r\nscsi_debug_cmnd_count = 0;\r\nif (scsi_debug_every_nth < -1)\r\nscsi_debug_every_nth = -1;\r\nif (SCSI_DEBUG_OPT_TIMEOUT & scsi_debug_opts)\r\nreturn 0;\r\nelse if (SCSI_DEBUG_OPT_RECOVERED_ERR & scsi_debug_opts)\r\ninj_recovered = 1;\r\nelse if (SCSI_DEBUG_OPT_TRANSPORT_ERR & scsi_debug_opts)\r\ninj_transport = 1;\r\nelse if (SCSI_DEBUG_OPT_DIF_ERR & scsi_debug_opts)\r\ninj_dif = 1;\r\nelse if (SCSI_DEBUG_OPT_DIX_ERR & scsi_debug_opts)\r\ninj_dix = 1;\r\n}\r\nif (devip->wlun) {\r\nswitch (*cmd) {\r\ncase INQUIRY:\r\ncase REQUEST_SENSE:\r\ncase TEST_UNIT_READY:\r\ncase REPORT_LUNS:\r\nbreak;\r\ndefault:\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: Opcode: 0x%x "\r\n"not supported for wlun\n", *cmd);\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_OPCODE, 0);\r\nerrsts = check_condition_result;\r\nreturn schedule_resp(SCpnt, devip, done, errsts,\r\n0);\r\n}\r\n}\r\nswitch (*cmd) {\r\ncase INQUIRY:\r\ndelay_override = 1;\r\nerrsts = resp_inquiry(SCpnt, target, devip);\r\nbreak;\r\ncase REQUEST_SENSE:\r\ndelay_override = 1;\r\nerrsts = resp_requests(SCpnt, devip);\r\nbreak;\r\ncase REZERO_UNIT:\r\ncase START_STOP:\r\nerrsts = resp_start_stop(SCpnt, devip);\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\nerrsts = check_readiness(SCpnt, 1, devip);\r\nif (errsts)\r\nbreak;\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: Medium removal %s\n",\r\ncmd[4] ? "inhibited" : "enabled");\r\nbreak;\r\ncase SEND_DIAGNOSTIC:\r\nerrsts = check_readiness(SCpnt, 1, devip);\r\nbreak;\r\ncase TEST_UNIT_READY:\r\ndelay_override = 1;\r\nerrsts = check_readiness(SCpnt, 0, devip);\r\nbreak;\r\ncase RESERVE:\r\nerrsts = check_readiness(SCpnt, 1, devip);\r\nbreak;\r\ncase RESERVE_10:\r\nerrsts = check_readiness(SCpnt, 1, devip);\r\nbreak;\r\ncase RELEASE:\r\nerrsts = check_readiness(SCpnt, 1, devip);\r\nbreak;\r\ncase RELEASE_10:\r\nerrsts = check_readiness(SCpnt, 1, devip);\r\nbreak;\r\ncase READ_CAPACITY:\r\nerrsts = resp_readcap(SCpnt, devip);\r\nbreak;\r\ncase SERVICE_ACTION_IN:\r\nif (cmd[1] == SAI_READ_CAPACITY_16)\r\nerrsts = resp_readcap16(SCpnt, devip);\r\nelse if (cmd[1] == SAI_GET_LBA_STATUS) {\r\nif (scsi_debug_lbp() == 0) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_COMMAND_OPCODE, 0);\r\nerrsts = check_condition_result;\r\n} else\r\nerrsts = resp_get_lba_status(SCpnt, devip);\r\n} else {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_OPCODE, 0);\r\nerrsts = check_condition_result;\r\n}\r\nbreak;\r\ncase MAINTENANCE_IN:\r\nif (MI_REPORT_TARGET_PGS != cmd[1]) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_OPCODE, 0);\r\nerrsts = check_condition_result;\r\nbreak;\r\n}\r\nerrsts = resp_report_tgtpgs(SCpnt, devip);\r\nbreak;\r\ncase READ_16:\r\ncase READ_12:\r\ncase READ_10:\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION &&\r\ncmd[1] & 0xe0) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_COMMAND_OPCODE, 0);\r\nerrsts = check_condition_result;\r\nbreak;\r\n}\r\nif ((scsi_debug_dif == SD_DIF_TYPE1_PROTECTION ||\r\nscsi_debug_dif == SD_DIF_TYPE3_PROTECTION) &&\r\n(cmd[1] & 0xe0) == 0)\r\nprintk(KERN_ERR "Unprotected RD/WR to DIF device\n");\r\ncase READ_6:\r\nread:\r\nerrsts = check_readiness(SCpnt, 0, devip);\r\nif (errsts)\r\nbreak;\r\nif (scsi_debug_fake_rw)\r\nbreak;\r\nget_data_transfer_info(cmd, &lba, &num, &ei_lba);\r\nerrsts = resp_read(SCpnt, lba, num, devip, ei_lba);\r\nif (inj_recovered && (0 == errsts)) {\r\nmk_sense_buffer(devip, RECOVERED_ERROR,\r\nTHRESHOLD_EXCEEDED, 0);\r\nerrsts = check_condition_result;\r\n} else if (inj_transport && (0 == errsts)) {\r\nmk_sense_buffer(devip, ABORTED_COMMAND,\r\nTRANSPORT_PROBLEM, ACK_NAK_TO);\r\nerrsts = check_condition_result;\r\n} else if (inj_dif && (0 == errsts)) {\r\nmk_sense_buffer(devip, ABORTED_COMMAND, 0x10, 1);\r\nerrsts = illegal_condition_result;\r\n} else if (inj_dix && (0 == errsts)) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, 0x10, 1);\r\nerrsts = illegal_condition_result;\r\n}\r\nbreak;\r\ncase REPORT_LUNS:\r\ndelay_override = 1;\r\nerrsts = resp_report_luns(SCpnt, devip);\r\nbreak;\r\ncase VERIFY:\r\nerrsts = check_readiness(SCpnt, 0, devip);\r\nbreak;\r\ncase WRITE_16:\r\ncase WRITE_12:\r\ncase WRITE_10:\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION &&\r\ncmd[1] & 0xe0) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_COMMAND_OPCODE, 0);\r\nerrsts = check_condition_result;\r\nbreak;\r\n}\r\nif ((scsi_debug_dif == SD_DIF_TYPE1_PROTECTION ||\r\nscsi_debug_dif == SD_DIF_TYPE3_PROTECTION) &&\r\n(cmd[1] & 0xe0) == 0)\r\nprintk(KERN_ERR "Unprotected RD/WR to DIF device\n");\r\ncase WRITE_6:\r\nwrite:\r\nerrsts = check_readiness(SCpnt, 0, devip);\r\nif (errsts)\r\nbreak;\r\nif (scsi_debug_fake_rw)\r\nbreak;\r\nget_data_transfer_info(cmd, &lba, &num, &ei_lba);\r\nerrsts = resp_write(SCpnt, lba, num, devip, ei_lba);\r\nif (inj_recovered && (0 == errsts)) {\r\nmk_sense_buffer(devip, RECOVERED_ERROR,\r\nTHRESHOLD_EXCEEDED, 0);\r\nerrsts = check_condition_result;\r\n} else if (inj_dif && (0 == errsts)) {\r\nmk_sense_buffer(devip, ABORTED_COMMAND, 0x10, 1);\r\nerrsts = illegal_condition_result;\r\n} else if (inj_dix && (0 == errsts)) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, 0x10, 1);\r\nerrsts = illegal_condition_result;\r\n}\r\nbreak;\r\ncase WRITE_SAME_16:\r\ncase WRITE_SAME:\r\nif (cmd[1] & 0x8) {\r\nif ((*cmd == WRITE_SAME_16 && scsi_debug_lbpws == 0) ||\r\n(*cmd == WRITE_SAME && scsi_debug_lbpws10 == 0)) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nerrsts = check_condition_result;\r\n} else\r\nunmap = 1;\r\n}\r\nif (errsts)\r\nbreak;\r\nerrsts = check_readiness(SCpnt, 0, devip);\r\nif (errsts)\r\nbreak;\r\nget_data_transfer_info(cmd, &lba, &num, &ei_lba);\r\nerrsts = resp_write_same(SCpnt, lba, num, devip, ei_lba, unmap);\r\nbreak;\r\ncase UNMAP:\r\nerrsts = check_readiness(SCpnt, 0, devip);\r\nif (errsts)\r\nbreak;\r\nif (scsi_debug_unmap_max_desc == 0 || scsi_debug_lbpu == 0) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_COMMAND_OPCODE, 0);\r\nerrsts = check_condition_result;\r\n} else\r\nerrsts = resp_unmap(SCpnt, devip);\r\nbreak;\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\nerrsts = resp_mode_sense(SCpnt, target, devip);\r\nbreak;\r\ncase MODE_SELECT:\r\nerrsts = resp_mode_select(SCpnt, 1, devip);\r\nbreak;\r\ncase MODE_SELECT_10:\r\nerrsts = resp_mode_select(SCpnt, 0, devip);\r\nbreak;\r\ncase LOG_SENSE:\r\nerrsts = resp_log_sense(SCpnt, devip);\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\ndelay_override = 1;\r\nerrsts = check_readiness(SCpnt, 0, devip);\r\nbreak;\r\ncase WRITE_BUFFER:\r\nerrsts = check_readiness(SCpnt, 1, devip);\r\nbreak;\r\ncase XDWRITEREAD_10:\r\nif (!scsi_bidi_cmnd(SCpnt)) {\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nerrsts = check_condition_result;\r\nbreak;\r\n}\r\nerrsts = check_readiness(SCpnt, 0, devip);\r\nif (errsts)\r\nbreak;\r\nif (scsi_debug_fake_rw)\r\nbreak;\r\nget_data_transfer_info(cmd, &lba, &num, &ei_lba);\r\nerrsts = resp_read(SCpnt, lba, num, devip, ei_lba);\r\nif (errsts)\r\nbreak;\r\nerrsts = resp_write(SCpnt, lba, num, devip, ei_lba);\r\nif (errsts)\r\nbreak;\r\nerrsts = resp_xdwriteread(SCpnt, lba, num, devip);\r\nbreak;\r\ncase VARIABLE_LENGTH_CMD:\r\nif (scsi_debug_dif == SD_DIF_TYPE2_PROTECTION) {\r\nif ((cmd[10] & 0xe0) == 0)\r\nprintk(KERN_ERR\r\n"Unprotected RD/WR to DIF device\n");\r\nif (cmd[9] == READ_32) {\r\nBUG_ON(SCpnt->cmd_len < 32);\r\ngoto read;\r\n}\r\nif (cmd[9] == WRITE_32) {\r\nBUG_ON(SCpnt->cmd_len < 32);\r\ngoto write;\r\n}\r\n}\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST,\r\nINVALID_FIELD_IN_CDB, 0);\r\nerrsts = check_condition_result;\r\nbreak;\r\ndefault:\r\nif (SCSI_DEBUG_OPT_NOISE & scsi_debug_opts)\r\nprintk(KERN_INFO "scsi_debug: Opcode: 0x%x not "\r\n"supported\n", *cmd);\r\nerrsts = check_readiness(SCpnt, 1, devip);\r\nif (errsts)\r\nbreak;\r\nmk_sense_buffer(devip, ILLEGAL_REQUEST, INVALID_OPCODE, 0);\r\nerrsts = check_condition_result;\r\nbreak;\r\n}\r\nreturn schedule_resp(SCpnt, devip, done, errsts,\r\n(delay_override ? 0 : scsi_debug_delay));\r\n}\r\nstatic int sdebug_driver_probe(struct device * dev)\r\n{\r\nint error = 0;\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct Scsi_Host *hpnt;\r\nint host_prot;\r\nsdbg_host = to_sdebug_host(dev);\r\nsdebug_driver_template.can_queue = scsi_debug_max_queue;\r\nhpnt = scsi_host_alloc(&sdebug_driver_template, sizeof(sdbg_host));\r\nif (NULL == hpnt) {\r\nprintk(KERN_ERR "%s: scsi_register failed\n", __func__);\r\nerror = -ENODEV;\r\nreturn error;\r\n}\r\nsdbg_host->shost = hpnt;\r\n*((struct sdebug_host_info **)hpnt->hostdata) = sdbg_host;\r\nif ((hpnt->this_id >= 0) && (scsi_debug_num_tgts > hpnt->this_id))\r\nhpnt->max_id = scsi_debug_num_tgts + 1;\r\nelse\r\nhpnt->max_id = scsi_debug_num_tgts;\r\nhpnt->max_lun = SAM2_WLUN_REPORT_LUNS;\r\nhost_prot = 0;\r\nswitch (scsi_debug_dif) {\r\ncase SD_DIF_TYPE1_PROTECTION:\r\nhost_prot = SHOST_DIF_TYPE1_PROTECTION;\r\nif (scsi_debug_dix)\r\nhost_prot |= SHOST_DIX_TYPE1_PROTECTION;\r\nbreak;\r\ncase SD_DIF_TYPE2_PROTECTION:\r\nhost_prot = SHOST_DIF_TYPE2_PROTECTION;\r\nif (scsi_debug_dix)\r\nhost_prot |= SHOST_DIX_TYPE2_PROTECTION;\r\nbreak;\r\ncase SD_DIF_TYPE3_PROTECTION:\r\nhost_prot = SHOST_DIF_TYPE3_PROTECTION;\r\nif (scsi_debug_dix)\r\nhost_prot |= SHOST_DIX_TYPE3_PROTECTION;\r\nbreak;\r\ndefault:\r\nif (scsi_debug_dix)\r\nhost_prot |= SHOST_DIX_TYPE0_PROTECTION;\r\nbreak;\r\n}\r\nscsi_host_set_prot(hpnt, host_prot);\r\nprintk(KERN_INFO "scsi_debug: host protection%s%s%s%s%s%s%s\n",\r\n(host_prot & SHOST_DIF_TYPE1_PROTECTION) ? " DIF1" : "",\r\n(host_prot & SHOST_DIF_TYPE2_PROTECTION) ? " DIF2" : "",\r\n(host_prot & SHOST_DIF_TYPE3_PROTECTION) ? " DIF3" : "",\r\n(host_prot & SHOST_DIX_TYPE0_PROTECTION) ? " DIX0" : "",\r\n(host_prot & SHOST_DIX_TYPE1_PROTECTION) ? " DIX1" : "",\r\n(host_prot & SHOST_DIX_TYPE2_PROTECTION) ? " DIX2" : "",\r\n(host_prot & SHOST_DIX_TYPE3_PROTECTION) ? " DIX3" : "");\r\nif (scsi_debug_guard == 1)\r\nscsi_host_set_guard(hpnt, SHOST_DIX_GUARD_IP);\r\nelse\r\nscsi_host_set_guard(hpnt, SHOST_DIX_GUARD_CRC);\r\nerror = scsi_add_host(hpnt, &sdbg_host->dev);\r\nif (error) {\r\nprintk(KERN_ERR "%s: scsi_add_host failed\n", __func__);\r\nerror = -ENODEV;\r\nscsi_host_put(hpnt);\r\n} else\r\nscsi_scan_host(hpnt);\r\nreturn error;\r\n}\r\nstatic int sdebug_driver_remove(struct device * dev)\r\n{\r\nstruct sdebug_host_info *sdbg_host;\r\nstruct sdebug_dev_info *sdbg_devinfo, *tmp;\r\nsdbg_host = to_sdebug_host(dev);\r\nif (!sdbg_host) {\r\nprintk(KERN_ERR "%s: Unable to locate host info\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nscsi_remove_host(sdbg_host->shost);\r\nlist_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,\r\ndev_list) {\r\nlist_del(&sdbg_devinfo->dev_list);\r\nkfree(sdbg_devinfo);\r\n}\r\nscsi_host_put(sdbg_host->shost);\r\nreturn 0;\r\n}\r\nstatic int pseudo_lld_bus_match(struct device *dev,\r\nstruct device_driver *dev_driver)\r\n{\r\nreturn 1;\r\n}
