static unsigned summit_get_apic_id(unsigned long x)\r\n{\r\nreturn (x >> 24) & 0xFF;\r\n}\r\nstatic inline void summit_send_IPI_mask(const struct cpumask *mask, int vector)\r\n{\r\ndefault_send_IPI_mask_sequence_logical(mask, vector);\r\n}\r\nstatic void summit_send_IPI_allbutself(int vector)\r\n{\r\ndefault_send_IPI_mask_allbutself_logical(cpu_online_mask, vector);\r\n}\r\nstatic void summit_send_IPI_all(int vector)\r\n{\r\nsummit_send_IPI_mask(cpu_online_mask, vector);\r\n}\r\nstatic inline void setup_summit(void) {}\r\nstatic int summit_mps_oem_check(struct mpc_table *mpc, char *oem,\r\nchar *productid)\r\n{\r\nif (!strncmp(oem, "IBM ENSW", 8) &&\r\n(!strncmp(productid, "VIGIL SMP", 9)\r\n|| !strncmp(productid, "EXA", 3)\r\n|| !strncmp(productid, "RUTHLESS SMP", 12))){\r\nmark_tsc_unstable("Summit based system");\r\nuse_cyclone = 1;\r\nsetup_summit();\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int summit_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\r\n{\r\nif (!strncmp(oem_id, "IBM", 3) &&\r\n(!strncmp(oem_table_id, "SERVIGIL", 8)\r\n|| !strncmp(oem_table_id, "EXA", 3))){\r\nmark_tsc_unstable("Summit based system");\r\nuse_cyclone = 1;\r\nsetup_summit();\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int is_WPEG(struct rio_detail *rio){\r\nreturn (rio->type == CompatWPEG || rio->type == AltWPEG ||\r\nrio->type == LookOutAWPEG || rio->type == LookOutBWPEG);\r\n}\r\nstatic const struct cpumask *summit_target_cpus(void)\r\n{\r\nreturn cpumask_of(0);\r\n}\r\nstatic unsigned long summit_check_apicid_used(physid_mask_t *map, int apicid)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned long summit_check_apicid_present(int bit)\r\n{\r\nreturn 1;\r\n}\r\nstatic int summit_early_logical_apicid(int cpu)\r\n{\r\nint count = 0;\r\nu8 my_id = early_per_cpu(x86_cpu_to_apicid, cpu);\r\nu8 my_cluster = APIC_CLUSTER(my_id);\r\n#ifdef CONFIG_SMP\r\nu8 lid;\r\nint i;\r\nfor (count = 0, i = nr_cpu_ids; --i >= 0; ) {\r\nlid = early_per_cpu(x86_cpu_to_logical_apicid, i);\r\nif (lid != BAD_APICID && APIC_CLUSTER(lid) == my_cluster)\r\n++count;\r\n}\r\n#endif\r\nBUG_ON(count >= XAPIC_DEST_CPUS_SHIFT);\r\nreturn my_cluster | (1UL << count);\r\n}\r\nstatic void summit_init_apic_ldr(void)\r\n{\r\nint cpu = smp_processor_id();\r\nunsigned long id = early_per_cpu(x86_cpu_to_logical_apicid, cpu);\r\nunsigned long val;\r\napic_write(APIC_DFR, SUMMIT_APIC_DFR_VALUE);\r\nval = apic_read(APIC_LDR) & ~APIC_LDR_MASK;\r\nval |= SET_APIC_LOGICAL_ID(id);\r\napic_write(APIC_LDR, val);\r\n}\r\nstatic int summit_apic_id_registered(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic void summit_setup_apic_routing(void)\r\n{\r\nprintk("Enabling APIC mode: Summit. Using %d I/O APICs\n",\r\nnr_ioapics);\r\n}\r\nstatic int summit_cpu_present_to_apicid(int mps_cpu)\r\n{\r\nif (mps_cpu < nr_cpu_ids)\r\nreturn (int)per_cpu(x86_bios_cpu_apicid, mps_cpu);\r\nelse\r\nreturn BAD_APICID;\r\n}\r\nstatic void summit_ioapic_phys_id_map(physid_mask_t *phys_id_map, physid_mask_t *retmap)\r\n{\r\nphysids_promote(0x0FL, retmap);\r\n}\r\nstatic void summit_apicid_to_cpu_present(int apicid, physid_mask_t *retmap)\r\n{\r\nphysid_set_mask_of_physid(0, retmap);\r\n}\r\nstatic int summit_check_phys_apicid_present(int physical_apicid)\r\n{\r\nreturn 1;\r\n}\r\nstatic unsigned int summit_cpu_mask_to_apicid(const struct cpumask *cpumask)\r\n{\r\nunsigned int round = 0;\r\nint cpu, apicid = 0;\r\nfor_each_cpu(cpu, cpumask) {\r\nint new_apicid = early_per_cpu(x86_cpu_to_logical_apicid, cpu);\r\nif (round && APIC_CLUSTER(apicid) != APIC_CLUSTER(new_apicid)) {\r\nprintk("%s: Not a valid mask!\n", __func__);\r\nreturn BAD_APICID;\r\n}\r\napicid |= new_apicid;\r\nround++;\r\n}\r\nreturn apicid;\r\n}\r\nstatic unsigned int summit_cpu_mask_to_apicid_and(const struct cpumask *inmask,\r\nconst struct cpumask *andmask)\r\n{\r\nint apicid = early_per_cpu(x86_cpu_to_logical_apicid, 0);\r\ncpumask_var_t cpumask;\r\nif (!alloc_cpumask_var(&cpumask, GFP_ATOMIC))\r\nreturn apicid;\r\ncpumask_and(cpumask, inmask, andmask);\r\ncpumask_and(cpumask, cpumask, cpu_online_mask);\r\napicid = summit_cpu_mask_to_apicid(cpumask);\r\nfree_cpumask_var(cpumask);\r\nreturn apicid;\r\n}\r\nstatic int summit_phys_pkg_id(int cpuid_apic, int index_msb)\r\n{\r\nreturn hard_smp_processor_id() >> index_msb;\r\n}\r\nstatic int probe_summit(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void summit_vector_allocation_domain(int cpu, struct cpumask *retmask)\r\n{\r\ncpumask_clear(retmask);\r\ncpumask_bits(retmask)[0] = APIC_ALL_CPUS;\r\n}\r\nstatic int setup_pci_node_map_for_wpeg(int wpeg_num, int last_bus)\r\n{\r\nint twister = 0, node = 0;\r\nint i, bus, num_buses;\r\nfor (i = 0; i < rio_table_hdr->num_rio_dev; i++) {\r\nif (rio_devs[i]->node_id == rio_devs[wpeg_num]->owner_id) {\r\ntwister = rio_devs[i]->owner_id;\r\nbreak;\r\n}\r\n}\r\nif (i == rio_table_hdr->num_rio_dev) {\r\nprintk(KERN_ERR "%s: Couldn't find owner Cyclone for Winnipeg!\n", __func__);\r\nreturn last_bus;\r\n}\r\nfor (i = 0; i < rio_table_hdr->num_scal_dev; i++) {\r\nif (scal_devs[i]->node_id == twister) {\r\nnode = scal_devs[i]->node_id;\r\nbreak;\r\n}\r\n}\r\nif (i == rio_table_hdr->num_scal_dev) {\r\nprintk(KERN_ERR "%s: Couldn't find owner Twister for Cyclone!\n", __func__);\r\nreturn last_bus;\r\n}\r\nswitch (rio_devs[wpeg_num]->type) {\r\ncase CompatWPEG:\r\nnum_buses = 5;\r\nbreak;\r\ncase AltWPEG:\r\nnum_buses = 7;\r\nbreak;\r\ncase LookOutAWPEG:\r\ncase LookOutBWPEG:\r\nnum_buses = 9;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: Unsupported Winnipeg type!\n", __func__);\r\nreturn last_bus;\r\n}\r\nfor (bus = last_bus; bus < last_bus + num_buses; bus++)\r\nmp_bus_id_to_node[bus] = node;\r\nreturn bus;\r\n}\r\nstatic int build_detail_arrays(void)\r\n{\r\nunsigned long ptr;\r\nint i, scal_detail_size, rio_detail_size;\r\nif (rio_table_hdr->num_scal_dev > MAX_NUMNODES) {\r\nprintk(KERN_WARNING "%s: MAX_NUMNODES too low! Defined as %d, but system has %d nodes.\n", __func__, MAX_NUMNODES, rio_table_hdr->num_scal_dev);\r\nreturn 0;\r\n}\r\nswitch (rio_table_hdr->version) {\r\ndefault:\r\nprintk(KERN_WARNING "%s: Invalid Rio Grande Table Version: %d\n", __func__, rio_table_hdr->version);\r\nreturn 0;\r\ncase 2:\r\nscal_detail_size = 11;\r\nrio_detail_size = 13;\r\nbreak;\r\ncase 3:\r\nscal_detail_size = 12;\r\nrio_detail_size = 15;\r\nbreak;\r\n}\r\nptr = (unsigned long)rio_table_hdr + 3;\r\nfor (i = 0; i < rio_table_hdr->num_scal_dev; i++, ptr += scal_detail_size)\r\nscal_devs[i] = (struct scal_detail *)ptr;\r\nfor (i = 0; i < rio_table_hdr->num_rio_dev; i++, ptr += rio_detail_size)\r\nrio_devs[i] = (struct rio_detail *)ptr;\r\nreturn 1;\r\n}\r\nvoid setup_summit(void)\r\n{\r\nunsigned long ptr;\r\nunsigned short offset;\r\nint i, next_wpeg, next_bus = 0;\r\nptr = get_bios_ebda();\r\nptr = (unsigned long)phys_to_virt(ptr);\r\nrio_table_hdr = NULL;\r\noffset = 0x180;\r\nwhile (offset) {\r\nif (*((unsigned short *)(ptr + offset + 2)) == 0x4752) {\r\nrio_table_hdr = (struct rio_table_hdr *)(ptr + offset + 4);\r\nbreak;\r\n}\r\noffset = *((unsigned short *)(ptr + offset));\r\n}\r\nif (!rio_table_hdr) {\r\nprintk(KERN_ERR "%s: Unable to locate Rio Grande Table in EBDA - bailing!\n", __func__);\r\nreturn;\r\n}\r\nif (!build_detail_arrays())\r\nreturn;\r\nnext_wpeg = 0;\r\ndo {\r\nfor (i = 0; i < rio_table_hdr->num_rio_dev; i++) {\r\nif (is_WPEG(rio_devs[i]) && rio_devs[i]->WP_index == next_wpeg) {\r\nnext_bus = setup_pci_node_map_for_wpeg(i, next_bus);\r\nnext_wpeg++;\r\nbreak;\r\n}\r\n}\r\nif (i == rio_table_hdr->num_rio_dev)\r\nnext_wpeg = 0;\r\n} while (next_wpeg != 0);\r\n}
