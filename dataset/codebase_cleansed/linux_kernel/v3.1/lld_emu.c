int emu_load_file_to_mem(void)\r\n{\r\nmm_segment_t fs;\r\nstruct file *nef_filp = NULL;\r\nstruct inode *inode = NULL;\r\nloff_t nef_size = 0;\r\nloff_t tmp_file_offset, file_offset;\r\nssize_t nread;\r\nint i, rc = -EINVAL;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nfs = get_fs();\r\nset_fs(get_ds());\r\nnef_filp = filp_open("/root/nand_emu_file", O_RDWR | O_LARGEFILE, 0);\r\nif (IS_ERR(nef_filp)) {\r\nprintk(KERN_ERR "filp_open error: "\r\n"Unable to open nand emu file!\n");\r\nreturn PTR_ERR(nef_filp);\r\n}\r\nif (nef_filp->f_path.dentry) {\r\ninode = nef_filp->f_path.dentry->d_inode;\r\n} else {\r\nprintk(KERN_ERR "Can not get valid inode!\n");\r\ngoto out;\r\n}\r\nnef_size = i_size_read(inode->i_mapping->host);\r\nif (nef_size <= 0) {\r\nprintk(KERN_ERR "Invalid nand emu file size: "\r\n"0x%llx\n", nef_size);\r\ngoto out;\r\n} else {\r\nnand_dbg_print(NAND_DBG_DEBUG, "nand emu file size: %lld\n",\r\nnef_size);\r\n}\r\nfile_offset = 0;\r\nfor (i = 0; i < GLOB_LLD_BLOCKS * GLOB_LLD_PAGES; i++) {\r\ntmp_file_offset = file_offset;\r\nnread = vfs_read(nef_filp,\r\n(char __user *)flash_memory[i],\r\nGLOB_LLD_PAGE_SIZE, &tmp_file_offset);\r\nif (nread < GLOB_LLD_PAGE_SIZE) {\r\nprintk(KERN_ERR "%s, Line %d - "\r\n"nand emu file partial read: "\r\n"%d bytes\n", __FILE__, __LINE__, (int)nread);\r\ngoto out;\r\n}\r\nfile_offset += GLOB_LLD_PAGE_SIZE;\r\n}\r\nrc = 0;\r\nout:\r\nfilp_close(nef_filp, current->files);\r\nset_fs(fs);\r\nreturn rc;\r\n}\r\nint emu_write_mem_to_file(void)\r\n{\r\nmm_segment_t fs;\r\nstruct file *nef_filp = NULL;\r\nstruct inode *inode = NULL;\r\nloff_t nef_size = 0;\r\nloff_t tmp_file_offset, file_offset;\r\nssize_t nwritten;\r\nint i, rc = -EINVAL;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nfs = get_fs();\r\nset_fs(get_ds());\r\nnef_filp = filp_open("/root/nand_emu_file", O_RDWR | O_LARGEFILE, 0);\r\nif (IS_ERR(nef_filp)) {\r\nprintk(KERN_ERR "filp_open error: "\r\n"Unable to open nand emu file!\n");\r\nreturn PTR_ERR(nef_filp);\r\n}\r\nif (nef_filp->f_path.dentry) {\r\ninode = nef_filp->f_path.dentry->d_inode;\r\n} else {\r\nprintk(KERN_ERR "Invalid " "nef_filp->f_path.dentry value!\n");\r\ngoto out;\r\n}\r\nnef_size = i_size_read(inode->i_mapping->host);\r\nif (nef_size <= 0) {\r\nprintk(KERN_ERR "Invalid "\r\n"nand emu file size: 0x%llx\n", nef_size);\r\ngoto out;\r\n} else {\r\nnand_dbg_print(NAND_DBG_DEBUG, "nand emu file size: "\r\n"%lld\n", nef_size);\r\n}\r\nfile_offset = 0;\r\nfor (i = 0; i < GLOB_LLD_BLOCKS * GLOB_LLD_PAGES; i++) {\r\ntmp_file_offset = file_offset;\r\nnwritten = vfs_write(nef_filp,\r\n(char __user *)flash_memory[i],\r\nGLOB_LLD_PAGE_SIZE, &tmp_file_offset);\r\nif (nwritten < GLOB_LLD_PAGE_SIZE) {\r\nprintk(KERN_ERR "%s, Line %d - "\r\n"nand emu file partial write: "\r\n"%d bytes\n", __FILE__, __LINE__, (int)nwritten);\r\ngoto out;\r\n}\r\nfile_offset += GLOB_LLD_PAGE_SIZE;\r\n}\r\nrc = 0;\r\nout:\r\nfilp_close(nef_filp, current->files);\r\nset_fs(fs);\r\nreturn rc;\r\n}\r\nu16 emu_Flash_Init(void)\r\n{\r\nint i;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nflash_memory[0] = vmalloc(GLOB_LLD_PAGE_SIZE * GLOB_LLD_BLOCKS *\r\nGLOB_LLD_PAGES * sizeof(u8));\r\nif (!flash_memory[0]) {\r\nprintk(KERN_ERR "Fail to allocate memory "\r\n"for nand emulator!\n");\r\nreturn ERR;\r\n}\r\nmemset((char *)(flash_memory[0]), 0xFF,\r\nGLOB_LLD_PAGE_SIZE * GLOB_LLD_BLOCKS * GLOB_LLD_PAGES *\r\nsizeof(u8));\r\nfor (i = 1; i < GLOB_LLD_BLOCKS * GLOB_LLD_PAGES; i++)\r\nflash_memory[i] = flash_memory[i - 1] + GLOB_LLD_PAGE_SIZE;\r\nemu_load_file_to_mem();\r\nreturn PASS;\r\n}\r\nint emu_Flash_Release(void)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nemu_write_mem_to_file();\r\nvfree(flash_memory[0]);\r\nreturn PASS;\r\n}\r\nu16 emu_Read_Device_ID(void)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nDeviceInfo.wDeviceMaker = 0;\r\nDeviceInfo.wDeviceType = 8;\r\nDeviceInfo.wSpectraStartBlock = 36;\r\nDeviceInfo.wSpectraEndBlock = GLOB_LLD_BLOCKS - 1;\r\nDeviceInfo.wTotalBlocks = GLOB_LLD_BLOCKS;\r\nDeviceInfo.wPagesPerBlock = GLOB_LLD_PAGES;\r\nDeviceInfo.wPageSize = GLOB_LLD_PAGE_SIZE;\r\nDeviceInfo.wPageDataSize = GLOB_LLD_PAGE_DATA_SIZE;\r\nDeviceInfo.wPageSpareSize = GLOB_LLD_PAGE_SIZE -\r\nGLOB_LLD_PAGE_DATA_SIZE;\r\nDeviceInfo.wBlockSize = DeviceInfo.wPageSize * GLOB_LLD_PAGES;\r\nDeviceInfo.wBlockDataSize = DeviceInfo.wPageDataSize * GLOB_LLD_PAGES;\r\nDeviceInfo.wDataBlockNum = (u32) (DeviceInfo.wSpectraEndBlock -\r\nDeviceInfo.wSpectraStartBlock\r\n+ 1);\r\nDeviceInfo.MLCDevice = 1;\r\nDeviceInfo.nBitsInPageNumber =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wPagesPerBlock);\r\nDeviceInfo.nBitsInPageDataSize =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wPageDataSize);\r\nDeviceInfo.nBitsInBlockDataSize =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wBlockDataSize);\r\n#if CMD_DMA\r\ntotalUsedBanks = 4;\r\nvalid_banks[0] = 1;\r\nvalid_banks[1] = 1;\r\nvalid_banks[2] = 1;\r\nvalid_banks[3] = 1;\r\n#endif\r\nreturn PASS;\r\n}\r\nu16 emu_Flash_Reset(void)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn PASS;\r\n}\r\nu16 emu_Erase_Block(u32 block_add)\r\n{\r\nint i;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (block_add >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "emu_Erase_Block error! "\r\n"Too big block address: %d\n", block_add);\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Erasing block %d\n",\r\n(int)block_add);\r\nfor (i = block_add * GLOB_LLD_PAGES;\r\ni < ((block_add + 1) * GLOB_LLD_PAGES); i++) {\r\nif (flash_memory[i]) {\r\nmemset((u8 *)(flash_memory[i]), 0xFF,\r\nDeviceInfo.wPageSize * sizeof(u8));\r\n}\r\n}\r\nreturn PASS;\r\n}\r\nu16 emu_Write_Page_Main(u8 *write_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nint i;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks)\r\nreturn FAIL;\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock)\r\nreturn FAIL;\r\nnand_dbg_print(NAND_DBG_DEBUG, "emu_Write_Page_Main: "\r\n"lba %u Page %u PageCount %u\n",\r\n(unsigned int)Block,\r\n(unsigned int)Page, (unsigned int)PageCount);\r\nfor (i = 0; i < PageCount; i++) {\r\nif (NULL == flash_memory[Block * GLOB_LLD_PAGES + Page]) {\r\nprintk(KERN_ERR "Run out of memory\n");\r\nreturn FAIL;\r\n}\r\nmemcpy((u8 *) (flash_memory[Block * GLOB_LLD_PAGES + Page]),\r\nwrite_data, DeviceInfo.wPageDataSize);\r\nwrite_data += DeviceInfo.wPageDataSize;\r\nPage++;\r\n}\r\nreturn PASS;\r\n}\r\nu16 emu_Read_Page_Main(u8 *read_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nint i;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks)\r\nreturn FAIL;\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock)\r\nreturn FAIL;\r\nnand_dbg_print(NAND_DBG_DEBUG, "emu_Read_Page_Main: "\r\n"lba %u Page %u PageCount %u\n",\r\n(unsigned int)Block,\r\n(unsigned int)Page, (unsigned int)PageCount);\r\nfor (i = 0; i < PageCount; i++) {\r\nif (NULL == flash_memory[Block * GLOB_LLD_PAGES + Page]) {\r\nmemset(read_data, 0xFF, DeviceInfo.wPageDataSize);\r\n} else {\r\nmemcpy(read_data,\r\n(u8 *) (flash_memory[Block * GLOB_LLD_PAGES\r\n+ Page]),\r\nDeviceInfo.wPageDataSize);\r\n}\r\nread_data += DeviceInfo.wPageDataSize;\r\nPage++;\r\n}\r\nreturn PASS;\r\n}\r\nu16 emu_Read_Page_Main_Spare(u8 *read_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nint i;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "Read Page Main+Spare "\r\n"Error: Block Address too big\n");\r\nreturn FAIL;\r\n}\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock) {\r\nprintk(KERN_ERR "Read Page Main+Spare "\r\n"Error: Page number too big\n");\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Read Page Main + Spare - "\r\n"No. of pages %u block %u start page %u\n",\r\n(unsigned int)PageCount,\r\n(unsigned int)Block, (unsigned int)Page);\r\nfor (i = 0; i < PageCount; i++) {\r\nif (NULL == flash_memory[Block * GLOB_LLD_PAGES + Page]) {\r\nmemset(read_data, 0xFF, DeviceInfo.wPageSize);\r\n} else {\r\nmemcpy(read_data, (u8 *) (flash_memory[Block *\r\nGLOB_LLD_PAGES\r\n+ Page]),\r\nDeviceInfo.wPageSize);\r\n}\r\nread_data += DeviceInfo.wPageSize;\r\nPage++;\r\n}\r\nreturn PASS;\r\n}\r\nu16 emu_Write_Page_Main_Spare(u8 *write_data, u32 Block,\r\nu16 Page, u16 page_count)\r\n{\r\nu16 i;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "Write Page Main + Spare "\r\n"Error: Block Address too big\n");\r\nreturn FAIL;\r\n}\r\nif (Page + page_count > DeviceInfo.wPagesPerBlock) {\r\nprintk(KERN_ERR "Write Page Main + Spare "\r\n"Error: Page number too big\n");\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Write Page Main+Spare - "\r\n"No. of pages %u block %u start page %u\n",\r\n(unsigned int)page_count,\r\n(unsigned int)Block, (unsigned int)Page);\r\nfor (i = 0; i < page_count; i++) {\r\nif (NULL == flash_memory[Block * GLOB_LLD_PAGES + Page]) {\r\nprintk(KERN_ERR "Run out of memory!\n");\r\nreturn FAIL;\r\n}\r\nmemcpy((u8 *) (flash_memory[Block * GLOB_LLD_PAGES + Page]),\r\nwrite_data, DeviceInfo.wPageSize);\r\nwrite_data += DeviceInfo.wPageSize;\r\nPage++;\r\n}\r\nreturn PASS;\r\n}\r\nu16 emu_Write_Page_Spare(u8 *write_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "Read Page Spare Error: "\r\n"Block Address too big\n");\r\nreturn FAIL;\r\n}\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock) {\r\nprintk(KERN_ERR "Read Page Spare Error: "\r\n"Page number too big\n");\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Write Page Spare- "\r\n"block %u page %u\n",\r\n(unsigned int)Block, (unsigned int)Page);\r\nif (NULL == flash_memory[Block * GLOB_LLD_PAGES + Page]) {\r\nprintk(KERN_ERR "Run out of memory!\n");\r\nreturn FAIL;\r\n}\r\nmemcpy((u8 *) (flash_memory[Block * GLOB_LLD_PAGES + Page] +\r\nDeviceInfo.wPageDataSize), write_data,\r\n(DeviceInfo.wPageSize - DeviceInfo.wPageDataSize));\r\nreturn PASS;\r\n}\r\nu16 emu_Read_Page_Spare(u8 *write_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "Read Page Spare "\r\n"Error: Block Address too big\n");\r\nreturn FAIL;\r\n}\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock) {\r\nprintk(KERN_ERR "Read Page Spare "\r\n"Error: Page number too big\n");\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Read Page Spare- "\r\n"block %u page %u\n",\r\n(unsigned int)Block, (unsigned int)Page);\r\nif (NULL == flash_memory[Block * GLOB_LLD_PAGES + Page]) {\r\nmemset(write_data, 0xFF,\r\n(DeviceInfo.wPageSize - DeviceInfo.wPageDataSize));\r\n} else {\r\nmemcpy(write_data,\r\n(u8 *) (flash_memory[Block * GLOB_LLD_PAGES + Page]\r\n+ DeviceInfo.wPageDataSize),\r\n(DeviceInfo.wPageSize - DeviceInfo.wPageDataSize));\r\n}\r\nreturn PASS;\r\n}\r\nvoid emu_Enable_Disable_Interrupts(u16 INT_ENABLE)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\n}\r\nu16 emu_Get_Bad_Block(u32 block)\r\n{\r\nreturn 0;\r\n}\r\nu16 emu_CDMA_Flash_Init(void)\r\n{\r\nu16 i;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nfor (i = 0; i < MAX_DESCS + MAX_CHANS; i++) {\r\nPendingCMD[i].CMD = 0;\r\nPendingCMD[i].Tag = 0;\r\nPendingCMD[i].DataAddr = 0;\r\nPendingCMD[i].Block = 0;\r\nPendingCMD[i].Page = 0;\r\nPendingCMD[i].PageCount = 0;\r\nPendingCMD[i].DataDestAddr = 0;\r\nPendingCMD[i].DataSrcAddr = 0;\r\nPendingCMD[i].MemCopyByteCnt = 0;\r\nPendingCMD[i].ChanSync[0] = 0;\r\nPendingCMD[i].ChanSync[1] = 0;\r\nPendingCMD[i].ChanSync[2] = 0;\r\nPendingCMD[i].ChanSync[3] = 0;\r\nPendingCMD[i].ChanSync[4] = 0;\r\nPendingCMD[i].Status = 3;\r\n}\r\nreturn PASS;\r\n}\r\nstatic void emu_isr(int irq, void *dev_id)\r\n{\r\n}\r\nu16 emu_CDMA_Execute_CMDs(u16 tag_count)\r\n{\r\nu16 i, j;\r\nu8 CMD;\r\nu8 *data;\r\nu32 block;\r\nu16 page;\r\nu16 count;\r\nu16 status = PASS;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nnand_dbg_print(NAND_DBG_TRACE, "At start of Execute CMDs: "\r\n"Tag Count %u\n", tag_count);\r\nfor (i = 0; i < totalUsedBanks; i++) {\r\nPendingCMD[i].CMD = DUMMY_CMD;\r\nPendingCMD[i].Tag = 0xFF;\r\nPendingCMD[i].Block =\r\n(DeviceInfo.wTotalBlocks / totalUsedBanks) * i;\r\nfor (j = 0; j <= MAX_CHANS; j++)\r\nPendingCMD[i].ChanSync[j] = 0;\r\n}\r\nCDMA_Execute_CMDs(tag_count);\r\nprint_pending_cmds(tag_count);\r\n#if DEBUG_SYNC\r\n}
