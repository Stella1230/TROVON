static int _cpuidle_allow_idle(struct powerdomain *pwrdm,\r\nstruct clockdomain *clkdm)\r\n{\r\nclkdm_allow_idle(clkdm);\r\nreturn 0;\r\n}\r\nstatic int _cpuidle_deny_idle(struct powerdomain *pwrdm,\r\nstruct clockdomain *clkdm)\r\n{\r\nclkdm_deny_idle(clkdm);\r\nreturn 0;\r\n}\r\nstatic int omap3_enter_idle(struct cpuidle_device *dev,\r\nstruct cpuidle_state *state)\r\n{\r\nstruct omap3_idle_statedata *cx = cpuidle_get_statedata(state);\r\nstruct timespec ts_preidle, ts_postidle, ts_idle;\r\nu32 mpu_state = cx->mpu_state, core_state = cx->core_state;\r\ngetnstimeofday(&ts_preidle);\r\nlocal_irq_disable();\r\nlocal_fiq_disable();\r\npwrdm_set_next_pwrst(mpu_pd, mpu_state);\r\npwrdm_set_next_pwrst(core_pd, core_state);\r\nif (omap_irq_pending() || need_resched())\r\ngoto return_sleep_time;\r\nif (state == &dev->states[0]) {\r\npwrdm_for_each_clkdm(mpu_pd, _cpuidle_deny_idle);\r\npwrdm_for_each_clkdm(core_pd, _cpuidle_deny_idle);\r\n}\r\nomap_sram_idle();\r\nif (state == &dev->states[0]) {\r\npwrdm_for_each_clkdm(mpu_pd, _cpuidle_allow_idle);\r\npwrdm_for_each_clkdm(core_pd, _cpuidle_allow_idle);\r\n}\r\nreturn_sleep_time:\r\ngetnstimeofday(&ts_postidle);\r\nts_idle = timespec_sub(ts_postidle, ts_preidle);\r\nlocal_irq_enable();\r\nlocal_fiq_enable();\r\nreturn ts_idle.tv_nsec / NSEC_PER_USEC + ts_idle.tv_sec * USEC_PER_SEC;\r\n}\r\nstatic struct cpuidle_state *next_valid_state(struct cpuidle_device *dev,\r\nstruct cpuidle_state *curr)\r\n{\r\nstruct cpuidle_state *next = NULL;\r\nstruct omap3_idle_statedata *cx = cpuidle_get_statedata(curr);\r\nu32 mpu_deepest_state = PWRDM_POWER_RET;\r\nu32 core_deepest_state = PWRDM_POWER_RET;\r\nif (enable_off_mode) {\r\nmpu_deepest_state = PWRDM_POWER_OFF;\r\nif (!IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583))\r\ncore_deepest_state = PWRDM_POWER_OFF;\r\n}\r\nif ((cx->valid) &&\r\n(cx->mpu_state >= mpu_deepest_state) &&\r\n(cx->core_state >= core_deepest_state)) {\r\nreturn curr;\r\n} else {\r\nint idx = OMAP3_NUM_STATES - 1;\r\nfor (; idx >= 0; idx--) {\r\nif (&dev->states[idx] == curr) {\r\nnext = &dev->states[idx];\r\nbreak;\r\n}\r\n}\r\nWARN_ON(next == NULL);\r\nidx--;\r\nfor (; idx >= 0; idx--) {\r\ncx = cpuidle_get_statedata(&dev->states[idx]);\r\nif ((cx->valid) &&\r\n(cx->mpu_state >= mpu_deepest_state) &&\r\n(cx->core_state >= core_deepest_state)) {\r\nnext = &dev->states[idx];\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn next;\r\n}\r\nstatic int omap3_enter_idle_bm(struct cpuidle_device *dev,\r\nstruct cpuidle_state *state)\r\n{\r\nstruct cpuidle_state *new_state;\r\nu32 core_next_state, per_next_state = 0, per_saved_state = 0, cam_state;\r\nstruct omap3_idle_statedata *cx;\r\nint ret;\r\nif (!omap3_can_sleep()) {\r\nnew_state = dev->safe_state;\r\ngoto select_state;\r\n}\r\ncam_state = pwrdm_read_pwrst(cam_pd);\r\nif (cam_state == PWRDM_POWER_ON) {\r\nnew_state = dev->safe_state;\r\ngoto select_state;\r\n}\r\ncx = cpuidle_get_statedata(state);\r\ncore_next_state = cx->core_state;\r\nper_next_state = per_saved_state = pwrdm_read_next_pwrst(per_pd);\r\nif ((per_next_state == PWRDM_POWER_OFF) &&\r\n(core_next_state > PWRDM_POWER_RET))\r\nper_next_state = PWRDM_POWER_RET;\r\nif (per_next_state != per_saved_state)\r\npwrdm_set_next_pwrst(per_pd, per_next_state);\r\nnew_state = next_valid_state(dev, state);\r\nselect_state:\r\ndev->last_state = new_state;\r\nret = omap3_enter_idle(dev, new_state);\r\nif (per_next_state != per_saved_state)\r\npwrdm_set_next_pwrst(per_pd, per_saved_state);\r\nreturn ret;\r\n}\r\nvoid omap3_pm_init_cpuidle(struct cpuidle_params *cpuidle_board_params)\r\n{\r\nint i;\r\nif (!cpuidle_board_params)\r\nreturn;\r\nfor (i = 0; i < OMAP3_NUM_STATES; i++) {\r\ncpuidle_params_table[i].valid = cpuidle_board_params[i].valid;\r\ncpuidle_params_table[i].exit_latency =\r\ncpuidle_board_params[i].exit_latency;\r\ncpuidle_params_table[i].target_residency =\r\ncpuidle_board_params[i].target_residency;\r\n}\r\nreturn;\r\n}\r\nstatic inline struct omap3_idle_statedata *_fill_cstate(\r\nstruct cpuidle_device *dev,\r\nint idx, const char *descr)\r\n{\r\nstruct omap3_idle_statedata *cx = &omap3_idle_data[idx];\r\nstruct cpuidle_state *state = &dev->states[idx];\r\nstate->exit_latency = cpuidle_params_table[idx].exit_latency;\r\nstate->target_residency = cpuidle_params_table[idx].target_residency;\r\nstate->flags = CPUIDLE_FLAG_TIME_VALID;\r\nstate->enter = omap3_enter_idle_bm;\r\ncx->valid = cpuidle_params_table[idx].valid;\r\nsprintf(state->name, "C%d", idx + 1);\r\nstrncpy(state->desc, descr, CPUIDLE_DESC_LEN);\r\ncpuidle_set_statedata(state, cx);\r\nreturn cx;\r\n}\r\nint __init omap3_idle_init(void)\r\n{\r\nstruct cpuidle_device *dev;\r\nstruct omap3_idle_statedata *cx;\r\nmpu_pd = pwrdm_lookup("mpu_pwrdm");\r\ncore_pd = pwrdm_lookup("core_pwrdm");\r\nper_pd = pwrdm_lookup("per_pwrdm");\r\ncam_pd = pwrdm_lookup("cam_pwrdm");\r\ncpuidle_register_driver(&omap3_idle_driver);\r\ndev = &per_cpu(omap3_idle_dev, smp_processor_id());\r\ncx = _fill_cstate(dev, 0, "MPU ON + CORE ON");\r\n(&dev->states[0])->enter = omap3_enter_idle;\r\ndev->safe_state = &dev->states[0];\r\ncx->valid = 1;\r\ncx->mpu_state = PWRDM_POWER_ON;\r\ncx->core_state = PWRDM_POWER_ON;\r\ncx = _fill_cstate(dev, 1, "MPU ON + CORE ON");\r\ncx->mpu_state = PWRDM_POWER_ON;\r\ncx->core_state = PWRDM_POWER_ON;\r\ncx = _fill_cstate(dev, 2, "MPU RET + CORE ON");\r\ncx->mpu_state = PWRDM_POWER_RET;\r\ncx->core_state = PWRDM_POWER_ON;\r\ncx = _fill_cstate(dev, 3, "MPU OFF + CORE ON");\r\ncx->mpu_state = PWRDM_POWER_OFF;\r\ncx->core_state = PWRDM_POWER_ON;\r\ncx = _fill_cstate(dev, 4, "MPU RET + CORE RET");\r\ncx->mpu_state = PWRDM_POWER_RET;\r\ncx->core_state = PWRDM_POWER_RET;\r\ncx = _fill_cstate(dev, 5, "MPU OFF + CORE RET");\r\ncx->mpu_state = PWRDM_POWER_OFF;\r\ncx->core_state = PWRDM_POWER_RET;\r\ncx = _fill_cstate(dev, 6, "MPU OFF + CORE OFF");\r\nif (IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583)) {\r\ncx->valid = 0;\r\npr_warn("%s: core off state C7 disabled due to i583\n",\r\n__func__);\r\n}\r\ncx->mpu_state = PWRDM_POWER_OFF;\r\ncx->core_state = PWRDM_POWER_OFF;\r\ndev->state_count = OMAP3_NUM_STATES;\r\nif (cpuidle_register_device(dev)) {\r\nprintk(KERN_ERR "%s: CPUidle register device failed\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint __init omap3_idle_init(void)\r\n{\r\nreturn 0;\r\n}
