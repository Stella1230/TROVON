static inline const char * pcid_name (struct pci_dev *pdev)\r\n{\r\nif (pdev && pdev->dev.driver)\r\nreturn pdev->dev.driver->name;\r\nreturn "";\r\n}\r\nstatic void eeh_disable_irq(struct pci_dev *dev)\r\n{\r\nstruct device_node *dn = pci_device_to_OF_node(dev);\r\nif (dev->msi_enabled || dev->msix_enabled)\r\nreturn;\r\nif (!irq_has_action(dev->irq))\r\nreturn;\r\nPCI_DN(dn)->eeh_mode |= EEH_MODE_IRQ_DISABLED;\r\ndisable_irq_nosync(dev->irq);\r\n}\r\nstatic void eeh_enable_irq(struct pci_dev *dev)\r\n{\r\nstruct device_node *dn = pci_device_to_OF_node(dev);\r\nif ((PCI_DN(dn)->eeh_mode) & EEH_MODE_IRQ_DISABLED) {\r\nPCI_DN(dn)->eeh_mode &= ~EEH_MODE_IRQ_DISABLED;\r\nenable_irq(dev->irq);\r\n}\r\n}\r\nstatic int eeh_report_error(struct pci_dev *dev, void *userdata)\r\n{\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver = dev->driver;\r\ndev->error_state = pci_channel_io_frozen;\r\nif (!driver)\r\nreturn 0;\r\neeh_disable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->error_detected)\r\nreturn 0;\r\nrc = driver->err_handler->error_detected (dev, pci_channel_io_frozen);\r\nif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nif (*res == PCI_ERS_RESULT_NONE) *res = rc;\r\nreturn 0;\r\n}\r\nstatic int eeh_report_mmio_enabled(struct pci_dev *dev, void *userdata)\r\n{\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver = dev->driver;\r\nif (!driver ||\r\n!driver->err_handler ||\r\n!driver->err_handler->mmio_enabled)\r\nreturn 0;\r\nrc = driver->err_handler->mmio_enabled (dev);\r\nif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nif (*res == PCI_ERS_RESULT_NONE) *res = rc;\r\nreturn 0;\r\n}\r\nstatic int eeh_report_reset(struct pci_dev *dev, void *userdata)\r\n{\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver = dev->driver;\r\nif (!driver)\r\nreturn 0;\r\ndev->error_state = pci_channel_io_normal;\r\neeh_enable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->slot_reset)\r\nreturn 0;\r\nrc = driver->err_handler->slot_reset(dev);\r\nif ((*res == PCI_ERS_RESULT_NONE) ||\r\n(*res == PCI_ERS_RESULT_RECOVERED)) *res = rc;\r\nif (*res == PCI_ERS_RESULT_DISCONNECT &&\r\nrc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nreturn 0;\r\n}\r\nstatic int eeh_report_resume(struct pci_dev *dev, void *userdata)\r\n{\r\nstruct pci_driver *driver = dev->driver;\r\ndev->error_state = pci_channel_io_normal;\r\nif (!driver)\r\nreturn 0;\r\neeh_enable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->resume)\r\nreturn 0;\r\ndriver->err_handler->resume(dev);\r\nreturn 0;\r\n}\r\nstatic int eeh_report_failure(struct pci_dev *dev, void *userdata)\r\n{\r\nstruct pci_driver *driver = dev->driver;\r\ndev->error_state = pci_channel_io_perm_failure;\r\nif (!driver)\r\nreturn 0;\r\neeh_disable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->error_detected)\r\nreturn 0;\r\ndriver->err_handler->error_detected(dev, pci_channel_io_perm_failure);\r\nreturn 0;\r\n}\r\nstatic int eeh_reset_device (struct pci_dn *pe_dn, struct pci_bus *bus)\r\n{\r\nstruct device_node *dn;\r\nint cnt, rc;\r\ncnt = pe_dn->eeh_freeze_count;\r\nif (bus)\r\npcibios_remove_pci_devices(bus);\r\nrc = rtas_set_slot_reset(pe_dn);\r\nif (rc)\r\nreturn rc;\r\ndn = pe_dn->node;\r\nif (!pcibios_find_pci_bus(dn) && PCI_DN(dn->parent))\r\ndn = dn->parent->child;\r\nwhile (dn) {\r\nstruct pci_dn *ppe = PCI_DN(dn);\r\nif (pe_dn->eeh_pe_config_addr == ppe->eeh_pe_config_addr) {\r\nrtas_configure_bridge(ppe);\r\neeh_restore_bars(ppe);\r\n}\r\ndn = dn->sibling;\r\n}\r\nif (bus) {\r\nssleep (5);\r\npcibios_add_pci_devices(bus);\r\n}\r\npe_dn->eeh_freeze_count = cnt;\r\nreturn 0;\r\n}\r\nstruct pci_dn * handle_eeh_events (struct eeh_event *event)\r\n{\r\nstruct device_node *frozen_dn;\r\nstruct pci_dn *frozen_pdn;\r\nstruct pci_bus *frozen_bus;\r\nint rc = 0;\r\nenum pci_ers_result result = PCI_ERS_RESULT_NONE;\r\nconst char *location, *pci_str, *drv_str, *bus_pci_str, *bus_drv_str;\r\nfrozen_dn = find_device_pe(event->dn);\r\nif (!frozen_dn) {\r\nlocation = of_get_property(event->dn, "ibm,loc-code", NULL);\r\nlocation = location ? location : "unknown";\r\nprintk(KERN_ERR "EEH: Error: Cannot find partition endpoint "\r\n"for location=%s pci addr=%s\n",\r\nlocation, eeh_pci_name(event->dev));\r\nreturn NULL;\r\n}\r\nfrozen_bus = pcibios_find_pci_bus(frozen_dn);\r\nlocation = of_get_property(frozen_dn, "ibm,loc-code", NULL);\r\nlocation = location ? location : "unknown";\r\nif (!frozen_bus)\r\nfrozen_bus = pcibios_find_pci_bus (frozen_dn->parent);\r\nif (!frozen_bus) {\r\nprintk(KERN_ERR "EEH: Cannot find PCI bus "\r\n"for location=%s dn=%s\n",\r\nlocation, frozen_dn->full_name);\r\nreturn NULL;\r\n}\r\nfrozen_pdn = PCI_DN(frozen_dn);\r\nfrozen_pdn->eeh_freeze_count++;\r\npci_str = eeh_pci_name(event->dev);\r\ndrv_str = pcid_name(event->dev);\r\nif (frozen_pdn->eeh_freeze_count > EEH_MAX_ALLOWED_FREEZES)\r\ngoto excess_failures;\r\nprintk(KERN_WARNING\r\n"EEH: This PCI device has failed %d times in the last hour:\n",\r\nfrozen_pdn->eeh_freeze_count);\r\nif (frozen_pdn->pcidev) {\r\nbus_pci_str = pci_name(frozen_pdn->pcidev);\r\nbus_drv_str = pcid_name(frozen_pdn->pcidev);\r\nprintk(KERN_WARNING\r\n"EEH: Bus location=%s driver=%s pci addr=%s\n",\r\nlocation, bus_drv_str, bus_pci_str);\r\n}\r\nprintk(KERN_WARNING\r\n"EEH: Device location=%s driver=%s pci addr=%s\n",\r\nlocation, drv_str, pci_str);\r\npci_walk_bus(frozen_bus, eeh_report_error, &result);\r\nrc = eeh_wait_for_slot_status (frozen_pdn, MAX_WAIT_FOR_RECOVERY*1000);\r\nif (rc < 0) {\r\nprintk(KERN_WARNING "EEH: Permanent failure\n");\r\ngoto hard_fail;\r\n}\r\neeh_slot_error_detail(frozen_pdn, EEH_LOG_TEMP_FAILURE);\r\nif (result == PCI_ERS_RESULT_NONE) {\r\nrc = eeh_reset_device(frozen_pdn, frozen_bus);\r\nif (rc) {\r\nprintk(KERN_WARNING "EEH: Unable to reset, rc=%d\n", rc);\r\ngoto hard_fail;\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_CAN_RECOVER) {\r\nrc = rtas_pci_enable(frozen_pdn, EEH_THAW_MMIO);\r\nif (rc < 0)\r\ngoto hard_fail;\r\nif (rc) {\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\n} else {\r\nresult = PCI_ERS_RESULT_NONE;\r\npci_walk_bus(frozen_bus, eeh_report_mmio_enabled, &result);\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_CAN_RECOVER) {\r\nrc = rtas_pci_enable(frozen_pdn, EEH_THAW_DMA);\r\nif (rc < 0)\r\ngoto hard_fail;\r\nif (rc)\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\nelse\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\n}\r\nif (result == PCI_ERS_RESULT_DISCONNECT) {\r\nprintk(KERN_WARNING "EEH: Device driver gave up\n");\r\ngoto hard_fail;\r\n}\r\nif (result == PCI_ERS_RESULT_NEED_RESET) {\r\nrc = eeh_reset_device(frozen_pdn, NULL);\r\nif (rc) {\r\nprintk(KERN_WARNING "EEH: Cannot reset, rc=%d\n", rc);\r\ngoto hard_fail;\r\n}\r\nresult = PCI_ERS_RESULT_NONE;\r\npci_walk_bus(frozen_bus, eeh_report_reset, &result);\r\n}\r\nif ((result != PCI_ERS_RESULT_RECOVERED) &&\r\n(result != PCI_ERS_RESULT_NONE)) {\r\nprintk(KERN_WARNING "EEH: Not recovered\n");\r\ngoto hard_fail;\r\n}\r\npci_walk_bus(frozen_bus, eeh_report_resume, NULL);\r\nreturn frozen_pdn;\r\nexcess_failures:\r\nprintk(KERN_ERR\r\n"EEH: PCI device at location=%s driver=%s pci addr=%s\n"\r\n"has failed %d times in the last hour "\r\n"and has been permanently disabled.\n"\r\n"Please try reseating this device or replacing it.\n",\r\nlocation, drv_str, pci_str, frozen_pdn->eeh_freeze_count);\r\ngoto perm_error;\r\nhard_fail:\r\nprintk(KERN_ERR\r\n"EEH: Unable to recover from failure of PCI device "\r\n"at location=%s driver=%s pci addr=%s\n"\r\n"Please try reseating this device or replacing it.\n",\r\nlocation, drv_str, pci_str);\r\nperm_error:\r\neeh_slot_error_detail(frozen_pdn, EEH_LOG_PERM_FAILURE);\r\npci_walk_bus(frozen_bus, eeh_report_failure, NULL);\r\npcibios_remove_pci_devices(frozen_bus);\r\nreturn NULL;\r\n}
