static struct sk_buff *\r\nzaurus_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nint padlen;\r\nstruct sk_buff *skb2;\r\npadlen = 2;\r\nif (!skb_cloned(skb)) {\r\nint tailroom = skb_tailroom(skb);\r\nif ((padlen + 4) <= tailroom)\r\ngoto done;\r\n}\r\nskb2 = skb_copy_expand(skb, 0, 4 + padlen, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (skb) {\r\nu32 fcs;\r\ndone:\r\nfcs = crc32_le(~0, skb->data, skb->len);\r\nfcs = ~fcs;\r\n*skb_put (skb, 1) = fcs & 0xff;\r\n*skb_put (skb, 1) = (fcs>> 8) & 0xff;\r\n*skb_put (skb, 1) = (fcs>>16) & 0xff;\r\n*skb_put (skb, 1) = (fcs>>24) & 0xff;\r\n}\r\nreturn skb;\r\n}\r\nstatic int zaurus_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\ndev->net->hard_header_len += 6;\r\ndev->rx_urb_size = dev->net->hard_header_len + dev->net->mtu;\r\nreturn usbnet_generic_cdc_bind(dev, intf);\r\n}\r\nstatic int always_connected (struct usbnet *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int blan_mdlm_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nu8 *buf = intf->cur_altsetting->extra;\r\nint len = intf->cur_altsetting->extralen;\r\nstruct usb_cdc_mdlm_desc *desc = NULL;\r\nstruct usb_cdc_mdlm_detail_desc *detail = NULL;\r\nwhile (len > 3) {\r\nif (buf [1] != USB_DT_CS_INTERFACE)\r\ngoto next_desc;\r\nswitch (buf [2]) {\r\ncase USB_CDC_MDLM_TYPE:\r\nif (desc) {\r\ndev_dbg(&intf->dev, "extra MDLM\n");\r\ngoto bad_desc;\r\n}\r\ndesc = (void *) buf;\r\nif (desc->bLength != sizeof *desc) {\r\ndev_dbg(&intf->dev, "MDLM len %u\n",\r\ndesc->bLength);\r\ngoto bad_desc;\r\n}\r\nif (memcmp(&desc->bGUID, blan_guid, 16) &&\r\nmemcmp(&desc->bGUID, safe_guid, 16)) {\r\ndev_dbg(&intf->dev, "MDLM guid\n");\r\ngoto bad_desc;\r\n}\r\nbreak;\r\ncase USB_CDC_MDLM_DETAIL_TYPE:\r\nif (detail) {\r\ndev_dbg(&intf->dev, "extra MDLM detail\n");\r\ngoto bad_desc;\r\n}\r\ndetail = (void *) buf;\r\nswitch (detail->bGuidDescriptorType) {\r\ncase 0:\r\nif (detail->bLength != (sizeof *detail + 2))\r\ngoto bad_detail;\r\nbreak;\r\ncase 1:\r\nif (detail->bLength != (sizeof *detail + 3))\r\ngoto bad_detail;\r\nbreak;\r\ndefault:\r\ngoto bad_detail;\r\n}\r\nif ((detail->bDetailData[1] & ~0x02) != 0x01) {\r\nbad_detail:\r\ndev_dbg(&intf->dev,\r\n"bad MDLM detail, %d %d %d\n",\r\ndetail->bLength,\r\ndetail->bDetailData[0],\r\ndetail->bDetailData[2]);\r\ngoto bad_desc;\r\n}\r\ndev->net->hard_header_len += 6;\r\ndev->rx_urb_size = dev->net->hard_header_len\r\n+ dev->net->mtu;\r\nbreak;\r\n}\r\nnext_desc:\r\nlen -= buf [0];\r\nbuf += buf [0];\r\n}\r\nif (!desc || !detail) {\r\ndev_dbg(&intf->dev, "missing cdc mdlm %s%sdescriptor\n",\r\ndesc ? "" : "func ",\r\ndetail ? "" : "detail ");\r\ngoto bad_desc;\r\n}\r\nreturn usbnet_get_endpoints(dev, intf);\r\nbad_desc:\r\ndev_info(&dev->udev->dev, "unsupported MDLM descriptors\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int __init zaurus_init(void)\r\n{\r\nreturn usb_register(&zaurus_driver);\r\n}\r\nstatic void __exit zaurus_exit(void)\r\n{\r\nusb_deregister(&zaurus_driver);\r\n}
