static u32 page_to_balloon_pfn(struct page *page)\r\n{\r\nunsigned long pfn = page_to_pfn(page);\r\nBUILD_BUG_ON(PAGE_SHIFT < VIRTIO_BALLOON_PFN_SHIFT);\r\nreturn pfn >> (PAGE_SHIFT - VIRTIO_BALLOON_PFN_SHIFT);\r\n}\r\nstatic void balloon_ack(struct virtqueue *vq)\r\n{\r\nstruct virtio_balloon *vb;\r\nunsigned int len;\r\nvb = virtqueue_get_buf(vq, &len);\r\nif (vb)\r\ncomplete(&vb->acked);\r\n}\r\nstatic void tell_host(struct virtio_balloon *vb, struct virtqueue *vq)\r\n{\r\nstruct scatterlist sg;\r\nsg_init_one(&sg, vb->pfns, sizeof(vb->pfns[0]) * vb->num_pfns);\r\ninit_completion(&vb->acked);\r\nif (virtqueue_add_buf(vq, &sg, 1, 0, vb) < 0)\r\nBUG();\r\nvirtqueue_kick(vq);\r\nwait_for_completion(&vb->acked);\r\n}\r\nstatic void fill_balloon(struct virtio_balloon *vb, size_t num)\r\n{\r\nnum = min(num, ARRAY_SIZE(vb->pfns));\r\nfor (vb->num_pfns = 0; vb->num_pfns < num; vb->num_pfns++) {\r\nstruct page *page = alloc_page(GFP_HIGHUSER | __GFP_NORETRY |\r\n__GFP_NOMEMALLOC | __GFP_NOWARN);\r\nif (!page) {\r\nif (printk_ratelimit())\r\ndev_printk(KERN_INFO, &vb->vdev->dev,\r\n"Out of puff! Can't get %zu pages\n",\r\nnum);\r\nmsleep(200);\r\nbreak;\r\n}\r\nvb->pfns[vb->num_pfns] = page_to_balloon_pfn(page);\r\ntotalram_pages--;\r\nvb->num_pages++;\r\nlist_add(&page->lru, &vb->pages);\r\n}\r\nif (vb->num_pfns == 0)\r\nreturn;\r\ntell_host(vb, vb->inflate_vq);\r\n}\r\nstatic void release_pages_by_pfn(const u32 pfns[], unsigned int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i++) {\r\n__free_page(pfn_to_page(pfns[i]));\r\ntotalram_pages++;\r\n}\r\n}\r\nstatic void leak_balloon(struct virtio_balloon *vb, size_t num)\r\n{\r\nstruct page *page;\r\nnum = min(num, ARRAY_SIZE(vb->pfns));\r\nfor (vb->num_pfns = 0; vb->num_pfns < num; vb->num_pfns++) {\r\npage = list_first_entry(&vb->pages, struct page, lru);\r\nlist_del(&page->lru);\r\nvb->pfns[vb->num_pfns] = page_to_balloon_pfn(page);\r\nvb->num_pages--;\r\n}\r\ntell_host(vb, vb->deflate_vq);\r\nrelease_pages_by_pfn(vb->pfns, vb->num_pfns);\r\n}\r\nstatic inline void update_stat(struct virtio_balloon *vb, int idx,\r\nu16 tag, u64 val)\r\n{\r\nBUG_ON(idx >= VIRTIO_BALLOON_S_NR);\r\nvb->stats[idx].tag = tag;\r\nvb->stats[idx].val = val;\r\n}\r\nstatic void update_balloon_stats(struct virtio_balloon *vb)\r\n{\r\nunsigned long events[NR_VM_EVENT_ITEMS];\r\nstruct sysinfo i;\r\nint idx = 0;\r\nall_vm_events(events);\r\nsi_meminfo(&i);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_IN,\r\npages_to_bytes(events[PSWPIN]));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_OUT,\r\npages_to_bytes(events[PSWPOUT]));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MAJFLT, events[PGMAJFAULT]);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MINFLT, events[PGFAULT]);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMFREE,\r\npages_to_bytes(i.freeram));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMTOT,\r\npages_to_bytes(i.totalram));\r\n}\r\nstatic void stats_request(struct virtqueue *vq)\r\n{\r\nstruct virtio_balloon *vb;\r\nunsigned int len;\r\nvb = virtqueue_get_buf(vq, &len);\r\nif (!vb)\r\nreturn;\r\nvb->need_stats_update = 1;\r\nwake_up(&vb->config_change);\r\n}\r\nstatic void stats_handle_request(struct virtio_balloon *vb)\r\n{\r\nstruct virtqueue *vq;\r\nstruct scatterlist sg;\r\nvb->need_stats_update = 0;\r\nupdate_balloon_stats(vb);\r\nvq = vb->stats_vq;\r\nsg_init_one(&sg, vb->stats, sizeof(vb->stats));\r\nif (virtqueue_add_buf(vq, &sg, 1, 0, vb) < 0)\r\nBUG();\r\nvirtqueue_kick(vq);\r\n}\r\nstatic void virtballoon_changed(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nwake_up(&vb->config_change);\r\n}\r\nstatic inline s64 towards_target(struct virtio_balloon *vb)\r\n{\r\nu32 v;\r\nvb->vdev->config->get(vb->vdev,\r\noffsetof(struct virtio_balloon_config, num_pages),\r\n&v, sizeof(v));\r\nreturn (s64)v - vb->num_pages;\r\n}\r\nstatic void update_balloon_size(struct virtio_balloon *vb)\r\n{\r\n__le32 actual = cpu_to_le32(vb->num_pages);\r\nvb->vdev->config->set(vb->vdev,\r\noffsetof(struct virtio_balloon_config, actual),\r\n&actual, sizeof(actual));\r\n}\r\nstatic int balloon(void *_vballoon)\r\n{\r\nstruct virtio_balloon *vb = _vballoon;\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\ns64 diff;\r\ntry_to_freeze();\r\nwait_event_interruptible(vb->config_change,\r\n(diff = towards_target(vb)) != 0\r\n|| vb->need_stats_update\r\n|| kthread_should_stop()\r\n|| freezing(current));\r\nif (vb->need_stats_update)\r\nstats_handle_request(vb);\r\nif (diff > 0)\r\nfill_balloon(vb, diff);\r\nelse if (diff < 0)\r\nleak_balloon(vb, -diff);\r\nupdate_balloon_size(vb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int virtballoon_probe(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb;\r\nstruct virtqueue *vqs[3];\r\nvq_callback_t *callbacks[] = { balloon_ack, balloon_ack, stats_request };\r\nconst char *names[] = { "inflate", "deflate", "stats" };\r\nint err, nvqs;\r\nvdev->priv = vb = kmalloc(sizeof(*vb), GFP_KERNEL);\r\nif (!vb) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&vb->pages);\r\nvb->num_pages = 0;\r\ninit_waitqueue_head(&vb->config_change);\r\nvb->vdev = vdev;\r\nvb->need_stats_update = 0;\r\nnvqs = virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ) ? 3 : 2;\r\nerr = vdev->config->find_vqs(vdev, nvqs, vqs, callbacks, names);\r\nif (err)\r\ngoto out_free_vb;\r\nvb->inflate_vq = vqs[0];\r\nvb->deflate_vq = vqs[1];\r\nif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ)) {\r\nstruct scatterlist sg;\r\nvb->stats_vq = vqs[2];\r\nsg_init_one(&sg, vb->stats, sizeof vb->stats);\r\nif (virtqueue_add_buf(vb->stats_vq, &sg, 1, 0, vb) < 0)\r\nBUG();\r\nvirtqueue_kick(vb->stats_vq);\r\n}\r\nvb->thread = kthread_run(balloon, vb, "vballoon");\r\nif (IS_ERR(vb->thread)) {\r\nerr = PTR_ERR(vb->thread);\r\ngoto out_del_vqs;\r\n}\r\nreturn 0;\r\nout_del_vqs:\r\nvdev->config->del_vqs(vdev);\r\nout_free_vb:\r\nkfree(vb);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __devexit virtballoon_remove(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nkthread_stop(vb->thread);\r\nwhile (vb->num_pages)\r\nleak_balloon(vb, vb->num_pages);\r\nvdev->config->reset(vdev);\r\nvdev->config->del_vqs(vdev);\r\nkfree(vb);\r\n}\r\nstatic int __init init(void)\r\n{\r\nreturn register_virtio_driver(&virtio_balloon_driver);\r\n}\r\nstatic void __exit fini(void)\r\n{\r\nunregister_virtio_driver(&virtio_balloon_driver);\r\n}
