static inline struct hashlimit_net *hashlimit_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, hashlimit_net_id);\r\n}\r\nstatic inline bool dst_cmp(const struct dsthash_ent *ent,\r\nconst struct dsthash_dst *b)\r\n{\r\nreturn !memcmp(&ent->dst, b, sizeof(ent->dst));\r\n}\r\nstatic u_int32_t\r\nhash_dst(const struct xt_hashlimit_htable *ht, const struct dsthash_dst *dst)\r\n{\r\nu_int32_t hash = jhash2((const u32 *)dst,\r\nsizeof(*dst)/sizeof(u32),\r\nht->rnd);\r\nreturn ((u64)hash * ht->cfg.size) >> 32;\r\n}\r\nstatic struct dsthash_ent *\r\ndsthash_find(const struct xt_hashlimit_htable *ht,\r\nconst struct dsthash_dst *dst)\r\n{\r\nstruct dsthash_ent *ent;\r\nstruct hlist_node *pos;\r\nu_int32_t hash = hash_dst(ht, dst);\r\nif (!hlist_empty(&ht->hash[hash])) {\r\nhlist_for_each_entry_rcu(ent, pos, &ht->hash[hash], node)\r\nif (dst_cmp(ent, dst)) {\r\nspin_lock(&ent->lock);\r\nreturn ent;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct dsthash_ent *\r\ndsthash_alloc_init(struct xt_hashlimit_htable *ht,\r\nconst struct dsthash_dst *dst)\r\n{\r\nstruct dsthash_ent *ent;\r\nspin_lock(&ht->lock);\r\nif (unlikely(!ht->rnd_initialized)) {\r\nget_random_bytes(&ht->rnd, sizeof(ht->rnd));\r\nht->rnd_initialized = true;\r\n}\r\nif (ht->cfg.max && ht->count >= ht->cfg.max) {\r\nif (net_ratelimit())\r\npr_err("max count of %u reached\n", ht->cfg.max);\r\nent = NULL;\r\n} else\r\nent = kmem_cache_alloc(hashlimit_cachep, GFP_ATOMIC);\r\nif (!ent) {\r\nif (net_ratelimit())\r\npr_err("cannot allocate dsthash_ent\n");\r\n} else {\r\nmemcpy(&ent->dst, dst, sizeof(ent->dst));\r\nspin_lock_init(&ent->lock);\r\nspin_lock(&ent->lock);\r\nhlist_add_head_rcu(&ent->node, &ht->hash[hash_dst(ht, dst)]);\r\nht->count++;\r\n}\r\nspin_unlock(&ht->lock);\r\nreturn ent;\r\n}\r\nstatic void dsthash_free_rcu(struct rcu_head *head)\r\n{\r\nstruct dsthash_ent *ent = container_of(head, struct dsthash_ent, rcu);\r\nkmem_cache_free(hashlimit_cachep, ent);\r\n}\r\nstatic inline void\r\ndsthash_free(struct xt_hashlimit_htable *ht, struct dsthash_ent *ent)\r\n{\r\nhlist_del_rcu(&ent->node);\r\ncall_rcu_bh(&ent->rcu, dsthash_free_rcu);\r\nht->count--;\r\n}\r\nstatic int htable_create(struct net *net, struct xt_hashlimit_mtinfo1 *minfo,\r\nu_int8_t family)\r\n{\r\nstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\r\nstruct xt_hashlimit_htable *hinfo;\r\nunsigned int size;\r\nunsigned int i;\r\nif (minfo->cfg.size) {\r\nsize = minfo->cfg.size;\r\n} else {\r\nsize = (totalram_pages << PAGE_SHIFT) / 16384 /\r\nsizeof(struct list_head);\r\nif (totalram_pages > 1024 * 1024 * 1024 / PAGE_SIZE)\r\nsize = 8192;\r\nif (size < 16)\r\nsize = 16;\r\n}\r\nhinfo = vmalloc(sizeof(struct xt_hashlimit_htable) +\r\nsizeof(struct list_head) * size);\r\nif (hinfo == NULL)\r\nreturn -ENOMEM;\r\nminfo->hinfo = hinfo;\r\nmemcpy(&hinfo->cfg, &minfo->cfg, sizeof(hinfo->cfg));\r\nhinfo->cfg.size = size;\r\nif (hinfo->cfg.max == 0)\r\nhinfo->cfg.max = 8 * hinfo->cfg.size;\r\nelse if (hinfo->cfg.max < hinfo->cfg.size)\r\nhinfo->cfg.max = hinfo->cfg.size;\r\nfor (i = 0; i < hinfo->cfg.size; i++)\r\nINIT_HLIST_HEAD(&hinfo->hash[i]);\r\nhinfo->use = 1;\r\nhinfo->count = 0;\r\nhinfo->family = family;\r\nhinfo->rnd_initialized = false;\r\nspin_lock_init(&hinfo->lock);\r\nhinfo->pde = proc_create_data(minfo->name, 0,\r\n(family == NFPROTO_IPV4) ?\r\nhashlimit_net->ipt_hashlimit : hashlimit_net->ip6t_hashlimit,\r\n&dl_file_ops, hinfo);\r\nif (hinfo->pde == NULL) {\r\nvfree(hinfo);\r\nreturn -ENOMEM;\r\n}\r\nhinfo->net = net;\r\nsetup_timer(&hinfo->timer, htable_gc, (unsigned long)hinfo);\r\nhinfo->timer.expires = jiffies + msecs_to_jiffies(hinfo->cfg.gc_interval);\r\nadd_timer(&hinfo->timer);\r\nhlist_add_head(&hinfo->node, &hashlimit_net->htables);\r\nreturn 0;\r\n}\r\nstatic bool select_all(const struct xt_hashlimit_htable *ht,\r\nconst struct dsthash_ent *he)\r\n{\r\nreturn 1;\r\n}\r\nstatic bool select_gc(const struct xt_hashlimit_htable *ht,\r\nconst struct dsthash_ent *he)\r\n{\r\nreturn time_after_eq(jiffies, he->expires);\r\n}\r\nstatic void htable_selective_cleanup(struct xt_hashlimit_htable *ht,\r\nbool (*select)(const struct xt_hashlimit_htable *ht,\r\nconst struct dsthash_ent *he))\r\n{\r\nunsigned int i;\r\nspin_lock_bh(&ht->lock);\r\nfor (i = 0; i < ht->cfg.size; i++) {\r\nstruct dsthash_ent *dh;\r\nstruct hlist_node *pos, *n;\r\nhlist_for_each_entry_safe(dh, pos, n, &ht->hash[i], node) {\r\nif ((*select)(ht, dh))\r\ndsthash_free(ht, dh);\r\n}\r\n}\r\nspin_unlock_bh(&ht->lock);\r\n}\r\nstatic void htable_gc(unsigned long htlong)\r\n{\r\nstruct xt_hashlimit_htable *ht = (struct xt_hashlimit_htable *)htlong;\r\nhtable_selective_cleanup(ht, select_gc);\r\nht->timer.expires = jiffies + msecs_to_jiffies(ht->cfg.gc_interval);\r\nadd_timer(&ht->timer);\r\n}\r\nstatic void htable_destroy(struct xt_hashlimit_htable *hinfo)\r\n{\r\nstruct hashlimit_net *hashlimit_net = hashlimit_pernet(hinfo->net);\r\nstruct proc_dir_entry *parent;\r\ndel_timer_sync(&hinfo->timer);\r\nif (hinfo->family == NFPROTO_IPV4)\r\nparent = hashlimit_net->ipt_hashlimit;\r\nelse\r\nparent = hashlimit_net->ip6t_hashlimit;\r\nremove_proc_entry(hinfo->pde->name, parent);\r\nhtable_selective_cleanup(hinfo, select_all);\r\nvfree(hinfo);\r\n}\r\nstatic struct xt_hashlimit_htable *htable_find_get(struct net *net,\r\nconst char *name,\r\nu_int8_t family)\r\n{\r\nstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\r\nstruct xt_hashlimit_htable *hinfo;\r\nstruct hlist_node *pos;\r\nhlist_for_each_entry(hinfo, pos, &hashlimit_net->htables, node) {\r\nif (!strcmp(name, hinfo->pde->name) &&\r\nhinfo->family == family) {\r\nhinfo->use++;\r\nreturn hinfo;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void htable_put(struct xt_hashlimit_htable *hinfo)\r\n{\r\nmutex_lock(&hashlimit_mutex);\r\nif (--hinfo->use == 0) {\r\nhlist_del(&hinfo->node);\r\nhtable_destroy(hinfo);\r\n}\r\nmutex_unlock(&hashlimit_mutex);\r\n}\r\nstatic inline u_int32_t\r\nuser2credits(u_int32_t user)\r\n{\r\nif (user > 0xFFFFFFFF / (HZ*CREDITS_PER_JIFFY))\r\nreturn (user / XT_HASHLIMIT_SCALE) * HZ * CREDITS_PER_JIFFY;\r\nreturn (user * HZ * CREDITS_PER_JIFFY) / XT_HASHLIMIT_SCALE;\r\n}\r\nstatic inline void rateinfo_recalc(struct dsthash_ent *dh, unsigned long now)\r\n{\r\ndh->rateinfo.credit += (now - dh->rateinfo.prev) * CREDITS_PER_JIFFY;\r\nif (dh->rateinfo.credit > dh->rateinfo.credit_cap)\r\ndh->rateinfo.credit = dh->rateinfo.credit_cap;\r\ndh->rateinfo.prev = now;\r\n}\r\nstatic inline __be32 maskl(__be32 a, unsigned int l)\r\n{\r\nreturn l ? htonl(ntohl(a) & ~0 << (32 - l)) : 0;\r\n}\r\nstatic void hashlimit_ipv6_mask(__be32 *i, unsigned int p)\r\n{\r\nswitch (p) {\r\ncase 0 ... 31:\r\ni[0] = maskl(i[0], p);\r\ni[1] = i[2] = i[3] = 0;\r\nbreak;\r\ncase 32 ... 63:\r\ni[1] = maskl(i[1], p - 32);\r\ni[2] = i[3] = 0;\r\nbreak;\r\ncase 64 ... 95:\r\ni[2] = maskl(i[2], p - 64);\r\ni[3] = 0;\r\nbreak;\r\ncase 96 ... 127:\r\ni[3] = maskl(i[3], p - 96);\r\nbreak;\r\ncase 128:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nhashlimit_init_dst(const struct xt_hashlimit_htable *hinfo,\r\nstruct dsthash_dst *dst,\r\nconst struct sk_buff *skb, unsigned int protoff)\r\n{\r\n__be16 _ports[2], *ports;\r\nu8 nexthdr;\r\nint poff;\r\nmemset(dst, 0, sizeof(*dst));\r\nswitch (hinfo->family) {\r\ncase NFPROTO_IPV4:\r\nif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_DIP)\r\ndst->ip.dst = maskl(ip_hdr(skb)->daddr,\r\nhinfo->cfg.dstmask);\r\nif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_SIP)\r\ndst->ip.src = maskl(ip_hdr(skb)->saddr,\r\nhinfo->cfg.srcmask);\r\nif (!(hinfo->cfg.mode &\r\n(XT_HASHLIMIT_HASH_DPT | XT_HASHLIMIT_HASH_SPT)))\r\nreturn 0;\r\nnexthdr = ip_hdr(skb)->protocol;\r\nbreak;\r\n#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)\r\ncase NFPROTO_IPV6:\r\nif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_DIP) {\r\nmemcpy(&dst->ip6.dst, &ipv6_hdr(skb)->daddr,\r\nsizeof(dst->ip6.dst));\r\nhashlimit_ipv6_mask(dst->ip6.dst, hinfo->cfg.dstmask);\r\n}\r\nif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_SIP) {\r\nmemcpy(&dst->ip6.src, &ipv6_hdr(skb)->saddr,\r\nsizeof(dst->ip6.src));\r\nhashlimit_ipv6_mask(dst->ip6.src, hinfo->cfg.srcmask);\r\n}\r\nif (!(hinfo->cfg.mode &\r\n(XT_HASHLIMIT_HASH_DPT | XT_HASHLIMIT_HASH_SPT)))\r\nreturn 0;\r\nnexthdr = ipv6_hdr(skb)->nexthdr;\r\nprotoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr);\r\nif ((int)protoff < 0)\r\nreturn -1;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\npoff = proto_ports_offset(nexthdr);\r\nif (poff >= 0) {\r\nports = skb_header_pointer(skb, protoff + poff, sizeof(_ports),\r\n&_ports);\r\n} else {\r\n_ports[0] = _ports[1] = 0;\r\nports = _ports;\r\n}\r\nif (!ports)\r\nreturn -1;\r\nif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_SPT)\r\ndst->src_port = ports[0];\r\nif (hinfo->cfg.mode & XT_HASHLIMIT_HASH_DPT)\r\ndst->dst_port = ports[1];\r\nreturn 0;\r\n}\r\nstatic bool\r\nhashlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_hashlimit_mtinfo1 *info = par->matchinfo;\r\nstruct xt_hashlimit_htable *hinfo = info->hinfo;\r\nunsigned long now = jiffies;\r\nstruct dsthash_ent *dh;\r\nstruct dsthash_dst dst;\r\nif (hashlimit_init_dst(hinfo, &dst, skb, par->thoff) < 0)\r\ngoto hotdrop;\r\nrcu_read_lock_bh();\r\ndh = dsthash_find(hinfo, &dst);\r\nif (dh == NULL) {\r\ndh = dsthash_alloc_init(hinfo, &dst);\r\nif (dh == NULL) {\r\nrcu_read_unlock_bh();\r\ngoto hotdrop;\r\n}\r\ndh->expires = jiffies + msecs_to_jiffies(hinfo->cfg.expire);\r\ndh->rateinfo.prev = jiffies;\r\ndh->rateinfo.credit = user2credits(hinfo->cfg.avg *\r\nhinfo->cfg.burst);\r\ndh->rateinfo.credit_cap = user2credits(hinfo->cfg.avg *\r\nhinfo->cfg.burst);\r\ndh->rateinfo.cost = user2credits(hinfo->cfg.avg);\r\n} else {\r\ndh->expires = now + msecs_to_jiffies(hinfo->cfg.expire);\r\nrateinfo_recalc(dh, now);\r\n}\r\nif (dh->rateinfo.credit >= dh->rateinfo.cost) {\r\ndh->rateinfo.credit -= dh->rateinfo.cost;\r\nspin_unlock(&dh->lock);\r\nrcu_read_unlock_bh();\r\nreturn !(info->cfg.mode & XT_HASHLIMIT_INVERT);\r\n}\r\nspin_unlock(&dh->lock);\r\nrcu_read_unlock_bh();\r\nreturn info->cfg.mode & XT_HASHLIMIT_INVERT;\r\nhotdrop:\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nstatic int hashlimit_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nstruct net *net = par->net;\r\nstruct xt_hashlimit_mtinfo1 *info = par->matchinfo;\r\nint ret;\r\nif (info->cfg.burst == 0 ||\r\nuser2credits(info->cfg.avg * info->cfg.burst) <\r\nuser2credits(info->cfg.avg)) {\r\npr_info("overflow, try lower: %u/%u\n",\r\ninfo->cfg.avg, info->cfg.burst);\r\nreturn -ERANGE;\r\n}\r\nif (info->cfg.gc_interval == 0 || info->cfg.expire == 0)\r\nreturn -EINVAL;\r\nif (info->name[sizeof(info->name)-1] != '\0')\r\nreturn -EINVAL;\r\nif (par->family == NFPROTO_IPV4) {\r\nif (info->cfg.srcmask > 32 || info->cfg.dstmask > 32)\r\nreturn -EINVAL;\r\n} else {\r\nif (info->cfg.srcmask > 128 || info->cfg.dstmask > 128)\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&hashlimit_mutex);\r\ninfo->hinfo = htable_find_get(net, info->name, par->family);\r\nif (info->hinfo == NULL) {\r\nret = htable_create(net, info, par->family);\r\nif (ret < 0) {\r\nmutex_unlock(&hashlimit_mutex);\r\nreturn ret;\r\n}\r\n}\r\nmutex_unlock(&hashlimit_mutex);\r\nreturn 0;\r\n}\r\nstatic void hashlimit_mt_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nconst struct xt_hashlimit_mtinfo1 *info = par->matchinfo;\r\nhtable_put(info->hinfo);\r\n}\r\nstatic void *dl_seq_start(struct seq_file *s, loff_t *pos)\r\n__acquires(htable->lock)\r\n{\r\nstruct xt_hashlimit_htable *htable = s->private;\r\nunsigned int *bucket;\r\nspin_lock_bh(&htable->lock);\r\nif (*pos >= htable->cfg.size)\r\nreturn NULL;\r\nbucket = kmalloc(sizeof(unsigned int), GFP_ATOMIC);\r\nif (!bucket)\r\nreturn ERR_PTR(-ENOMEM);\r\n*bucket = *pos;\r\nreturn bucket;\r\n}\r\nstatic void *dl_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct xt_hashlimit_htable *htable = s->private;\r\nunsigned int *bucket = (unsigned int *)v;\r\n*pos = ++(*bucket);\r\nif (*pos >= htable->cfg.size) {\r\nkfree(v);\r\nreturn NULL;\r\n}\r\nreturn bucket;\r\n}\r\nstatic void dl_seq_stop(struct seq_file *s, void *v)\r\n__releases(htable->lock)\r\n{\r\nstruct xt_hashlimit_htable *htable = s->private;\r\nunsigned int *bucket = (unsigned int *)v;\r\nif (!IS_ERR(bucket))\r\nkfree(bucket);\r\nspin_unlock_bh(&htable->lock);\r\n}\r\nstatic int dl_seq_real_show(struct dsthash_ent *ent, u_int8_t family,\r\nstruct seq_file *s)\r\n{\r\nint res;\r\nspin_lock(&ent->lock);\r\nrateinfo_recalc(ent, jiffies);\r\nswitch (family) {\r\ncase NFPROTO_IPV4:\r\nres = seq_printf(s, "%ld %pI4:%u->%pI4:%u %u %u %u\n",\r\n(long)(ent->expires - jiffies)/HZ,\r\n&ent->dst.ip.src,\r\nntohs(ent->dst.src_port),\r\n&ent->dst.ip.dst,\r\nntohs(ent->dst.dst_port),\r\nent->rateinfo.credit, ent->rateinfo.credit_cap,\r\nent->rateinfo.cost);\r\nbreak;\r\n#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)\r\ncase NFPROTO_IPV6:\r\nres = seq_printf(s, "%ld %pI6:%u->%pI6:%u %u %u %u\n",\r\n(long)(ent->expires - jiffies)/HZ,\r\n&ent->dst.ip6.src,\r\nntohs(ent->dst.src_port),\r\n&ent->dst.ip6.dst,\r\nntohs(ent->dst.dst_port),\r\nent->rateinfo.credit, ent->rateinfo.credit_cap,\r\nent->rateinfo.cost);\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\nres = 0;\r\n}\r\nspin_unlock(&ent->lock);\r\nreturn res;\r\n}\r\nstatic int dl_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct xt_hashlimit_htable *htable = s->private;\r\nunsigned int *bucket = (unsigned int *)v;\r\nstruct dsthash_ent *ent;\r\nstruct hlist_node *pos;\r\nif (!hlist_empty(&htable->hash[*bucket])) {\r\nhlist_for_each_entry(ent, pos, &htable->hash[*bucket], node)\r\nif (dl_seq_real_show(ent, htable->family, s))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dl_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &dl_seq_ops);\r\nif (!ret) {\r\nstruct seq_file *sf = file->private_data;\r\nsf->private = PDE(inode)->data;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __net_init hashlimit_proc_net_init(struct net *net)\r\n{\r\nstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\r\nhashlimit_net->ipt_hashlimit = proc_mkdir("ipt_hashlimit", net->proc_net);\r\nif (!hashlimit_net->ipt_hashlimit)\r\nreturn -ENOMEM;\r\n#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)\r\nhashlimit_net->ip6t_hashlimit = proc_mkdir("ip6t_hashlimit", net->proc_net);\r\nif (!hashlimit_net->ip6t_hashlimit) {\r\nproc_net_remove(net, "ipt_hashlimit");\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __net_exit hashlimit_proc_net_exit(struct net *net)\r\n{\r\nproc_net_remove(net, "ipt_hashlimit");\r\n#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)\r\nproc_net_remove(net, "ip6t_hashlimit");\r\n#endif\r\n}\r\nstatic int __net_init hashlimit_net_init(struct net *net)\r\n{\r\nstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\r\nINIT_HLIST_HEAD(&hashlimit_net->htables);\r\nreturn hashlimit_proc_net_init(net);\r\n}\r\nstatic void __net_exit hashlimit_net_exit(struct net *net)\r\n{\r\nstruct hashlimit_net *hashlimit_net = hashlimit_pernet(net);\r\nBUG_ON(!hlist_empty(&hashlimit_net->htables));\r\nhashlimit_proc_net_exit(net);\r\n}\r\nstatic int __init hashlimit_mt_init(void)\r\n{\r\nint err;\r\nerr = register_pernet_subsys(&hashlimit_net_ops);\r\nif (err < 0)\r\nreturn err;\r\nerr = xt_register_matches(hashlimit_mt_reg,\r\nARRAY_SIZE(hashlimit_mt_reg));\r\nif (err < 0)\r\ngoto err1;\r\nerr = -ENOMEM;\r\nhashlimit_cachep = kmem_cache_create("xt_hashlimit",\r\nsizeof(struct dsthash_ent), 0, 0,\r\nNULL);\r\nif (!hashlimit_cachep) {\r\npr_warning("unable to create slab cache\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nxt_unregister_matches(hashlimit_mt_reg, ARRAY_SIZE(hashlimit_mt_reg));\r\nerr1:\r\nunregister_pernet_subsys(&hashlimit_net_ops);\r\nreturn err;\r\n}\r\nstatic void __exit hashlimit_mt_exit(void)\r\n{\r\nxt_unregister_matches(hashlimit_mt_reg, ARRAY_SIZE(hashlimit_mt_reg));\r\nunregister_pernet_subsys(&hashlimit_net_ops);\r\nrcu_barrier_bh();\r\nkmem_cache_destroy(hashlimit_cachep);\r\n}
