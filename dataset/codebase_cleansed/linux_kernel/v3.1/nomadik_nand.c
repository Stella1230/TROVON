static void nomadik_ecc_control(struct mtd_info *mtd, int mode)\r\n{\r\n}\r\nstatic void nomadik_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct nomadik_nand_host *host = nand->priv;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, host->cmd_va);\r\nelse\r\nwriteb(cmd, host->addr_va);\r\n}\r\nstatic int nomadik_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct nomadik_nand_platform_data *pdata = pdev->dev.platform_data;\r\nstruct nomadik_nand_host *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand;\r\nstruct resource *res;\r\nint ret = 0;\r\nhost = kzalloc(sizeof(struct nomadik_nand_host), GFP_KERNEL);\r\nif (!host) {\r\ndev_err(&pdev->dev, "Failed to allocate device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (pdata->init)\r\nret = pdata->init();\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Init function failed\n");\r\ngoto err;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nand_addr");\r\nif (!res) {\r\nret = -EIO;\r\ngoto err_unmap;\r\n}\r\nhost->addr_va = ioremap(res->start, resource_size(res));\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nand_data");\r\nif (!res) {\r\nret = -EIO;\r\ngoto err_unmap;\r\n}\r\nhost->data_va = ioremap(res->start, resource_size(res));\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nand_cmd");\r\nif (!res) {\r\nret = -EIO;\r\ngoto err_unmap;\r\n}\r\nhost->cmd_va = ioremap(res->start, resource_size(res));\r\nif (!host->addr_va || !host->data_va || !host->cmd_va) {\r\nret = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\nmtd = &host->mtd;\r\nnand = &host->nand;\r\nmtd->priv = nand;\r\nnand->priv = host;\r\nhost->mtd.owner = THIS_MODULE;\r\nnand->IO_ADDR_R = host->data_va;\r\nnand->IO_ADDR_W = host->data_va;\r\nnand->cmd_ctrl = nomadik_cmd_ctrl;\r\nnand->ecc.mode = NAND_ECC_SOFT;\r\nnand->ecc.layout = &nomadik_ecc_layout;\r\nnand->ecc.hwctl = nomadik_ecc_control;\r\nnand->ecc.size = 512;\r\nnand->ecc.bytes = 3;\r\nnand->options = pdata->options;\r\nif (nand_scan(&host->mtd, 1)) {\r\nret = -ENXIO;\r\ngoto err_unmap;\r\n}\r\nmtd_device_register(&host->mtd, pdata->parts, pdata->nparts);\r\nplatform_set_drvdata(pdev, host);\r\nreturn 0;\r\nerr_unmap:\r\nif (host->cmd_va)\r\niounmap(host->cmd_va);\r\nif (host->data_va)\r\niounmap(host->data_va);\r\nif (host->addr_va)\r\niounmap(host->addr_va);\r\nerr:\r\nkfree(host);\r\nreturn ret;\r\n}\r\nstatic int nomadik_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct nomadik_nand_host *host = platform_get_drvdata(pdev);\r\nstruct nomadik_nand_platform_data *pdata = pdev->dev.platform_data;\r\nif (pdata->exit)\r\npdata->exit();\r\nif (host) {\r\niounmap(host->cmd_va);\r\niounmap(host->data_va);\r\niounmap(host->addr_va);\r\nkfree(host);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nomadik_nand_suspend(struct device *dev)\r\n{\r\nstruct nomadik_nand_host *host = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (host)\r\nret = host->mtd.suspend(&host->mtd);\r\nreturn ret;\r\n}\r\nstatic int nomadik_nand_resume(struct device *dev)\r\n{\r\nstruct nomadik_nand_host *host = dev_get_drvdata(dev);\r\nif (host)\r\nhost->mtd.resume(&host->mtd);\r\nreturn 0;\r\n}\r\nstatic int __init nand_nomadik_init(void)\r\n{\r\npr_info("Nomadik NAND driver\n");\r\nreturn platform_driver_register(&nomadik_nand_driver);\r\n}\r\nstatic void __exit nand_nomadik_exit(void)\r\n{\r\nplatform_driver_unregister(&nomadik_nand_driver);\r\n}
