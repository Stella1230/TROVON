static int send_command(int cmd, int *msb, int *lsb)\r\n{\r\nint got_response, count;\r\nif (debug >= DEBUG)\r\nprintk(KERN_DEBUG PFX "sending following data "\r\n"cmd=0x%02x msb=0x%02x lsb=0x%02x\n", cmd, *msb, *lsb);\r\nspin_lock(&pcipcwd_private.io_lock);\r\noutb_p(*lsb, pcipcwd_private.io_addr + 4);\r\noutb_p(*msb, pcipcwd_private.io_addr + 5);\r\noutb_p(cmd, pcipcwd_private.io_addr + 6);\r\ngot_response = inb_p(pcipcwd_private.io_addr + 2) & WD_PCI_WRSP;\r\nfor (count = 0; (count < PCI_COMMAND_TIMEOUT) && (!got_response);\r\ncount++) {\r\nmdelay(1);\r\ngot_response = inb_p(pcipcwd_private.io_addr + 2) & WD_PCI_WRSP;\r\n}\r\nif (debug >= DEBUG) {\r\nif (got_response) {\r\nprintk(KERN_DEBUG PFX\r\n"time to process command was: %d ms\n",\r\ncount);\r\n} else {\r\nprintk(KERN_DEBUG PFX\r\n"card did not respond on command!\n");\r\n}\r\n}\r\nif (got_response) {\r\n*lsb = inb_p(pcipcwd_private.io_addr + 4);\r\n*msb = inb_p(pcipcwd_private.io_addr + 5);\r\ninb_p(pcipcwd_private.io_addr + 6);\r\nif (debug >= DEBUG)\r\nprintk(KERN_DEBUG PFX "received following data for "\r\n"cmd=0x%02x: msb=0x%02x lsb=0x%02x\n",\r\ncmd, *msb, *lsb);\r\n}\r\nspin_unlock(&pcipcwd_private.io_lock);\r\nreturn got_response;\r\n}\r\nstatic inline void pcipcwd_check_temperature_support(void)\r\n{\r\nif (inb_p(pcipcwd_private.io_addr) != 0xF0)\r\npcipcwd_private.supports_temp = 1;\r\n}\r\nstatic int pcipcwd_get_option_switches(void)\r\n{\r\nint option_switches;\r\noption_switches = inb_p(pcipcwd_private.io_addr + 3);\r\nreturn option_switches;\r\n}\r\nstatic void pcipcwd_show_card_info(void)\r\n{\r\nint got_fw_rev, fw_rev_major, fw_rev_minor;\r\nchar fw_ver_str[20];\r\nint option_switches;\r\ngot_fw_rev = send_command(CMD_GET_FIRMWARE_VERSION, &fw_rev_major,\r\n&fw_rev_minor);\r\nif (got_fw_rev)\r\nsprintf(fw_ver_str, "%u.%02u", fw_rev_major, fw_rev_minor);\r\nelse\r\nsprintf(fw_ver_str, "<card no answer>");\r\noption_switches = pcipcwd_get_option_switches();\r\nprintk(KERN_INFO PFX "Found card at port "\r\n"0x%04x (Firmware: %s) %s temp option\n",\r\n(int) pcipcwd_private.io_addr, fw_ver_str,\r\n(pcipcwd_private.supports_temp ? "with" : "without"));\r\nprintk(KERN_INFO PFX "Option switches (0x%02x): "\r\n"Temperature Reset Enable=%s, Power On Delay=%s\n",\r\noption_switches,\r\n((option_switches & 0x10) ? "ON" : "OFF"),\r\n((option_switches & 0x08) ? "ON" : "OFF"));\r\nif (pcipcwd_private.boot_status & WDIOF_CARDRESET)\r\nprintk(KERN_INFO PFX\r\n"Previous reset was caused by the Watchdog card\n");\r\nif (pcipcwd_private.boot_status & WDIOF_OVERHEAT)\r\nprintk(KERN_INFO PFX "Card sensed a CPU Overheat\n");\r\nif (pcipcwd_private.boot_status == 0)\r\nprintk(KERN_INFO PFX\r\n"No previous trip detected - Cold boot or reset\n");\r\n}\r\nstatic int pcipcwd_start(void)\r\n{\r\nint stat_reg;\r\nspin_lock(&pcipcwd_private.io_lock);\r\noutb_p(0x00, pcipcwd_private.io_addr + 3);\r\nudelay(1000);\r\nstat_reg = inb_p(pcipcwd_private.io_addr + 2);\r\nspin_unlock(&pcipcwd_private.io_lock);\r\nif (stat_reg & WD_PCI_WDIS) {\r\nprintk(KERN_ERR PFX "Card timer not enabled\n");\r\nreturn -1;\r\n}\r\nif (debug >= VERBOSE)\r\nprintk(KERN_DEBUG PFX "Watchdog started\n");\r\nreturn 0;\r\n}\r\nstatic int pcipcwd_stop(void)\r\n{\r\nint stat_reg;\r\nspin_lock(&pcipcwd_private.io_lock);\r\noutb_p(0xA5, pcipcwd_private.io_addr + 3);\r\nudelay(1000);\r\noutb_p(0xA5, pcipcwd_private.io_addr + 3);\r\nudelay(1000);\r\nstat_reg = inb_p(pcipcwd_private.io_addr + 2);\r\nspin_unlock(&pcipcwd_private.io_lock);\r\nif (!(stat_reg & WD_PCI_WDIS)) {\r\nprintk(KERN_ERR PFX\r\n"Card did not acknowledge disable attempt\n");\r\nreturn -1;\r\n}\r\nif (debug >= VERBOSE)\r\nprintk(KERN_DEBUG PFX "Watchdog stopped\n");\r\nreturn 0;\r\n}\r\nstatic int pcipcwd_keepalive(void)\r\n{\r\nspin_lock(&pcipcwd_private.io_lock);\r\noutb_p(0x42, pcipcwd_private.io_addr);\r\nspin_unlock(&pcipcwd_private.io_lock);\r\nif (debug >= DEBUG)\r\nprintk(KERN_DEBUG PFX "Watchdog keepalive signal send\n");\r\nreturn 0;\r\n}\r\nstatic int pcipcwd_set_heartbeat(int t)\r\n{\r\nint t_msb = t / 256;\r\nint t_lsb = t % 256;\r\nif ((t < 0x0001) || (t > 0xFFFF))\r\nreturn -EINVAL;\r\nsend_command(CMD_WRITE_WATCHDOG_TIMEOUT, &t_msb, &t_lsb);\r\nheartbeat = t;\r\nif (debug >= VERBOSE)\r\nprintk(KERN_DEBUG PFX "New heartbeat: %d\n",\r\nheartbeat);\r\nreturn 0;\r\n}\r\nstatic int pcipcwd_get_status(int *status)\r\n{\r\nint control_status;\r\n*status = 0;\r\ncontrol_status = inb_p(pcipcwd_private.io_addr + 1);\r\nif (control_status & WD_PCI_WTRP)\r\n*status |= WDIOF_CARDRESET;\r\nif (control_status & WD_PCI_TTRP) {\r\n*status |= WDIOF_OVERHEAT;\r\nif (temp_panic)\r\npanic(PFX "Temperature overheat trip!\n");\r\n}\r\nif (debug >= DEBUG)\r\nprintk(KERN_DEBUG PFX "Control Status #1: 0x%02x\n",\r\ncontrol_status);\r\nreturn 0;\r\n}\r\nstatic int pcipcwd_clear_status(void)\r\n{\r\nint control_status;\r\nint msb;\r\nint reset_counter;\r\nif (debug >= VERBOSE)\r\nprintk(KERN_INFO PFX "clearing watchdog trip status & LED\n");\r\ncontrol_status = inb_p(pcipcwd_private.io_addr + 1);\r\nif (debug >= DEBUG) {\r\nprintk(KERN_DEBUG PFX "status was: 0x%02x\n", control_status);\r\nprintk(KERN_DEBUG PFX "sending: 0x%02x\n",\r\n(control_status & WD_PCI_R2DS) | WD_PCI_WTRP);\r\n}\r\noutb_p((control_status & WD_PCI_R2DS) | WD_PCI_WTRP,\r\npcipcwd_private.io_addr + 1);\r\nmsb = 0;\r\nreset_counter = 0xff;\r\nsend_command(CMD_GET_CLEAR_RESET_COUNT, &msb, &reset_counter);\r\nif (debug >= DEBUG) {\r\nprintk(KERN_DEBUG PFX "reset count was: 0x%02x\n",\r\nreset_counter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcipcwd_get_temperature(int *temperature)\r\n{\r\n*temperature = 0;\r\nif (!pcipcwd_private.supports_temp)\r\nreturn -ENODEV;\r\nspin_lock(&pcipcwd_private.io_lock);\r\n*temperature = inb_p(pcipcwd_private.io_addr);\r\nspin_unlock(&pcipcwd_private.io_lock);\r\n*temperature = (*temperature * 9 / 5) + 32;\r\nif (debug >= DEBUG) {\r\nprintk(KERN_DEBUG PFX "temperature is: %d F\n",\r\n*temperature);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcipcwd_get_timeleft(int *time_left)\r\n{\r\nint msb;\r\nint lsb;\r\nsend_command(CMD_READ_WATCHDOG_TIMEOUT, &msb, &lsb);\r\n*time_left = (msb << 8) + lsb;\r\nif (debug >= VERBOSE)\r\nprintk(KERN_DEBUG PFX "Time left before next reboot: %d\n",\r\n*time_left);\r\nreturn 0;\r\n}\r\nstatic ssize_t pcipcwd_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_release = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_release = 42;\r\n}\r\n}\r\npcipcwd_keepalive();\r\n}\r\nreturn len;\r\n}\r\nstatic long pcipcwd_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_OVERHEAT |\r\nWDIOF_CARDRESET |\r\nWDIOF_KEEPALIVEPING |\r\nWDIOF_SETTIMEOUT |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = WATCHDOG_DRIVER_NAME,\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\n{\r\nint status;\r\npcipcwd_get_status(&status);\r\nreturn put_user(status, p);\r\n}\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(pcipcwd_private.boot_status, p);\r\ncase WDIOC_GETTEMP:\r\n{\r\nint temperature;\r\nif (pcipcwd_get_temperature(&temperature))\r\nreturn -EFAULT;\r\nreturn put_user(temperature, p);\r\n}\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint new_options, retval = -EINVAL;\r\nif (get_user(new_options, p))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD) {\r\nif (pcipcwd_stop())\r\nreturn -EIO;\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_ENABLECARD) {\r\nif (pcipcwd_start())\r\nreturn -EIO;\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_TEMPPANIC) {\r\ntemp_panic = 1;\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\npcipcwd_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\n{\r\nint new_heartbeat;\r\nif (get_user(new_heartbeat, p))\r\nreturn -EFAULT;\r\nif (pcipcwd_set_heartbeat(new_heartbeat))\r\nreturn -EINVAL;\r\npcipcwd_keepalive();\r\n}\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, p);\r\ncase WDIOC_GETTIMELEFT:\r\n{\r\nint time_left;\r\nif (pcipcwd_get_timeleft(&time_left))\r\nreturn -EFAULT;\r\nreturn put_user(time_left, p);\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int pcipcwd_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &is_active)) {\r\nif (debug >= VERBOSE)\r\nprintk(KERN_ERR PFX\r\n"Attempt to open already opened device.\n");\r\nreturn -EBUSY;\r\n}\r\npcipcwd_start();\r\npcipcwd_keepalive();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int pcipcwd_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_release == 42) {\r\npcipcwd_stop();\r\n} else {\r\nprintk(KERN_CRIT PFX\r\n"Unexpected close, not stopping watchdog!\n");\r\npcipcwd_keepalive();\r\n}\r\nexpect_release = 0;\r\nclear_bit(0, &is_active);\r\nreturn 0;\r\n}\r\nstatic ssize_t pcipcwd_temp_read(struct file *file, char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nint temperature;\r\nif (pcipcwd_get_temperature(&temperature))\r\nreturn -EFAULT;\r\nif (copy_to_user(data, &temperature, 1))\r\nreturn -EFAULT;\r\nreturn 1;\r\n}\r\nstatic int pcipcwd_temp_open(struct inode *inode, struct file *file)\r\n{\r\nif (!pcipcwd_private.supports_temp)\r\nreturn -ENODEV;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int pcipcwd_temp_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pcipcwd_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\npcipcwd_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __devinit pcipcwd_card_init(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret = -EIO;\r\ncards_found++;\r\nif (cards_found == 1)\r\nprintk(KERN_INFO PFX DRIVER_VERSION);\r\nif (cards_found > 1) {\r\nprintk(KERN_ERR PFX "This driver only supports 1 device\n");\r\nreturn -ENODEV;\r\n}\r\nif (pci_enable_device(pdev)) {\r\nprintk(KERN_ERR PFX "Not possible to enable PCI Device\n");\r\nreturn -ENODEV;\r\n}\r\nif (pci_resource_start(pdev, 0) == 0x0000) {\r\nprintk(KERN_ERR PFX "No I/O-Address for card detected\n");\r\nret = -ENODEV;\r\ngoto err_out_disable_device;\r\n}\r\npcipcwd_private.pdev = pdev;\r\npcipcwd_private.io_addr = pci_resource_start(pdev, 0);\r\nif (pci_request_regions(pdev, WATCHDOG_NAME)) {\r\nprintk(KERN_ERR PFX "I/O address 0x%04x already in use\n",\r\n(int) pcipcwd_private.io_addr);\r\nret = -EIO;\r\ngoto err_out_disable_device;\r\n}\r\npcipcwd_get_status(&pcipcwd_private.boot_status);\r\npcipcwd_clear_status();\r\npcipcwd_stop();\r\npcipcwd_check_temperature_support();\r\npcipcwd_show_card_info();\r\nif (heartbeat == 0)\r\nheartbeat =\r\nheartbeat_tbl[(pcipcwd_get_option_switches() & 0x07)];\r\nif (pcipcwd_set_heartbeat(heartbeat)) {\r\npcipcwd_set_heartbeat(WATCHDOG_HEARTBEAT);\r\nprintk(KERN_INFO PFX\r\n"heartbeat value must be 0<heartbeat<65536, using %d\n",\r\nWATCHDOG_HEARTBEAT);\r\n}\r\nret = register_reboot_notifier(&pcipcwd_notifier);\r\nif (ret != 0) {\r\nprintk(KERN_ERR PFX\r\n"cannot register reboot notifier (err=%d)\n", ret);\r\ngoto err_out_release_region;\r\n}\r\nif (pcipcwd_private.supports_temp) {\r\nret = misc_register(&pcipcwd_temp_miscdev);\r\nif (ret != 0) {\r\nprintk(KERN_ERR PFX "cannot register miscdev on "\r\n"minor=%d (err=%d)\n", TEMP_MINOR, ret);\r\ngoto err_out_unregister_reboot;\r\n}\r\n}\r\nret = misc_register(&pcipcwd_miscdev);\r\nif (ret != 0) {\r\nprintk(KERN_ERR PFX\r\n"cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto err_out_misc_deregister;\r\n}\r\nprintk(KERN_INFO PFX "initialized. heartbeat=%d sec (nowayout=%d)\n",\r\nheartbeat, nowayout);\r\nreturn 0;\r\nerr_out_misc_deregister:\r\nif (pcipcwd_private.supports_temp)\r\nmisc_deregister(&pcipcwd_temp_miscdev);\r\nerr_out_unregister_reboot:\r\nunregister_reboot_notifier(&pcipcwd_notifier);\r\nerr_out_release_region:\r\npci_release_regions(pdev);\r\nerr_out_disable_device:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void __devexit pcipcwd_card_exit(struct pci_dev *pdev)\r\n{\r\nif (!nowayout)\r\npcipcwd_stop();\r\nmisc_deregister(&pcipcwd_miscdev);\r\nif (pcipcwd_private.supports_temp)\r\nmisc_deregister(&pcipcwd_temp_miscdev);\r\nunregister_reboot_notifier(&pcipcwd_notifier);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\ncards_found--;\r\n}\r\nstatic int __init pcipcwd_init_module(void)\r\n{\r\nspin_lock_init(&pcipcwd_private.io_lock);\r\nreturn pci_register_driver(&pcipcwd_driver);\r\n}\r\nstatic void __exit pcipcwd_cleanup_module(void)\r\n{\r\npci_unregister_driver(&pcipcwd_driver);\r\nprintk(KERN_INFO PFX "Watchdog Module Unloaded.\n");\r\n}
