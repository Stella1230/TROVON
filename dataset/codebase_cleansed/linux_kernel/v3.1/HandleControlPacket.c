static VOID handle_rx_control_packet(PMINI_ADAPTER Adapter, struct sk_buff *skb)\r\n{\r\nPPER_TARANG_DATA pTarang = NULL;\r\nBOOLEAN HighPriorityMessage = FALSE;\r\nstruct sk_buff * newPacket = NULL;\r\nCHAR cntrl_msg_mask_bit = 0;\r\nBOOLEAN drop_pkt_flag = TRUE ;\r\nUSHORT usStatus = *(PUSHORT)(skb->data);\r\nif (netif_msg_pktdata(Adapter))\r\nprint_hex_dump(KERN_DEBUG, PFX "rx control: ", DUMP_PREFIX_NONE,\r\n16, 1, skb->data, skb->len, 0);\r\nswitch(usStatus)\r\n{\r\ncase CM_RESPONSES:\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL, "MAC Version Seems to be Non Multi-Classifier, rejected by Driver");\r\nHighPriorityMessage = TRUE ;\r\nbreak;\r\ncase CM_CONTROL_NEWDSX_MULTICLASSIFIER_RESP:\r\nHighPriorityMessage = TRUE ;\r\nif(Adapter->LinkStatus==LINKUP_DONE)\r\n{\r\nCmControlResponseMessage(Adapter,(skb->data +sizeof(USHORT)));\r\n}\r\nbreak;\r\ncase LINK_CONTROL_RESP:\r\ncase STATUS_RSP:\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL,"LINK_CONTROL_RESP");\r\nHighPriorityMessage = TRUE ;\r\nLinkControlResponseMessage(Adapter,(skb->data + sizeof(USHORT)));\r\nbreak;\r\ncase STATS_POINTER_RESP:\r\nHighPriorityMessage = TRUE ;\r\nStatisticsResponse(Adapter, (skb->data + sizeof(USHORT)));\r\nbreak;\r\ncase IDLE_MODE_STATUS:\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL,"IDLE_MODE_STATUS Type Message Got from F/W");\r\nInterfaceIdleModeRespond(Adapter, (PUINT)(skb->data +\r\nsizeof(USHORT)));\r\nHighPriorityMessage = TRUE ;\r\nbreak;\r\ncase AUTH_SS_HOST_MSG:\r\nHighPriorityMessage = TRUE ;\r\nbreak;\r\ndefault:\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL,"Got Default Response");\r\nbreak;\r\n}\r\ndown(&Adapter->RxAppControlQueuelock);\r\nfor (pTarang = Adapter->pTarangs; pTarang; pTarang = pTarang->next)\r\n{\r\nif(Adapter->device_removed)\r\n{\r\nbreak;\r\n}\r\ndrop_pkt_flag = TRUE ;\r\ncntrl_msg_mask_bit = (usStatus & 0x1F);\r\nif(pTarang->RxCntrlMsgBitMask & (1<<cntrl_msg_mask_bit))\r\ndrop_pkt_flag = FALSE;\r\nif ((drop_pkt_flag == TRUE) || (pTarang->AppCtrlQueueLen > MAX_APP_QUEUE_LEN) ||\r\n((pTarang->AppCtrlQueueLen > MAX_APP_QUEUE_LEN/2) && (HighPriorityMessage == FALSE)))\r\n{\r\nswitch(*(PUSHORT)skb->data)\r\n{\r\ncase CM_RESPONSES:\r\npTarang->stDroppedAppCntrlMsgs.cm_responses++;\r\nbreak;\r\ncase CM_CONTROL_NEWDSX_MULTICLASSIFIER_RESP:\r\npTarang->stDroppedAppCntrlMsgs.cm_control_newdsx_multiclassifier_resp++;\r\nbreak;\r\ncase LINK_CONTROL_RESP:\r\npTarang->stDroppedAppCntrlMsgs.link_control_resp++;\r\nbreak;\r\ncase STATUS_RSP:\r\npTarang->stDroppedAppCntrlMsgs.status_rsp++;\r\nbreak;\r\ncase STATS_POINTER_RESP:\r\npTarang->stDroppedAppCntrlMsgs.stats_pointer_resp++;\r\nbreak;\r\ncase IDLE_MODE_STATUS:\r\npTarang->stDroppedAppCntrlMsgs.idle_mode_status++ ;\r\nbreak;\r\ncase AUTH_SS_HOST_MSG:\r\npTarang->stDroppedAppCntrlMsgs.auth_ss_host_msg++ ;\r\nbreak;\r\ndefault:\r\npTarang->stDroppedAppCntrlMsgs.low_priority_message++ ;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nnewPacket = skb_clone(skb, GFP_KERNEL);\r\nif (!newPacket)\r\nbreak;\r\nENQUEUEPACKET(pTarang->RxAppControlHead,pTarang->RxAppControlTail,\r\nnewPacket);\r\npTarang->AppCtrlQueueLen++;\r\n}\r\nup(&Adapter->RxAppControlQueuelock);\r\nwake_up(&Adapter->process_read_wait_queue);\r\ndev_kfree_skb(skb);\r\nBCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL, "After wake_up_interruptible");\r\n}\r\nint control_packet_handler (PMINI_ADAPTER Adapter\r\n)\r\n{\r\nstruct sk_buff *ctrl_packet= NULL;\r\nunsigned long flags = 0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL, "Entering to make thread wait on control packet event!");\r\nwhile(1)\r\n{\r\nwait_event_interruptible(Adapter->process_rx_cntrlpkt,\r\natomic_read(&Adapter->cntrlpktCnt) ||\r\nAdapter->bWakeUpDevice ||\r\nkthread_should_stop()\r\n);\r\nif(kthread_should_stop())\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL, "Exiting \n");\r\nreturn 0;\r\n}\r\nif(TRUE == Adapter->bWakeUpDevice)\r\n{\r\nAdapter->bWakeUpDevice = FALSE;\r\nif((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) &&\r\n((TRUE == Adapter->IdleMode)|| (TRUE == Adapter->bShutStatus)))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL, "Calling InterfaceAbortIdlemode\n");\r\nInterfaceIdleModeWakeup (Adapter);\r\n}\r\ncontinue;\r\n}\r\nwhile(atomic_read(&Adapter->cntrlpktCnt))\r\n{\r\nspin_lock_irqsave(&Adapter->control_queue_lock, flags);\r\nctrl_packet = Adapter->RxControlHead;\r\nif(ctrl_packet)\r\n{\r\nDEQUEUEPACKET(Adapter->RxControlHead,Adapter->RxControlTail);\r\n}\r\nspin_unlock_irqrestore (&Adapter->control_queue_lock, flags);\r\nhandle_rx_control_packet(Adapter, ctrl_packet);\r\natomic_dec(&Adapter->cntrlpktCnt);\r\n}\r\nSetUpTargetDsxBuffers(Adapter);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT flushAllAppQ(void)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nPPER_TARANG_DATA pTarang = NULL;\r\nstruct sk_buff *PacketToDrop = NULL;\r\nfor(pTarang = Adapter->pTarangs; pTarang; pTarang = pTarang->next)\r\n{\r\nwhile(pTarang->RxAppControlHead != NULL)\r\n{\r\nPacketToDrop=pTarang->RxAppControlHead;\r\nDEQUEUEPACKET(pTarang->RxAppControlHead,pTarang->RxAppControlTail);\r\ndev_kfree_skb(PacketToDrop);\r\n}\r\npTarang->AppCtrlQueueLen = 0;\r\nmemset((PVOID)&pTarang->stDroppedAppCntrlMsgs, 0, sizeof(S_MIBS_DROPPED_APP_CNTRL_MESSAGES));\r\n}\r\nreturn STATUS_SUCCESS ;\r\n}
