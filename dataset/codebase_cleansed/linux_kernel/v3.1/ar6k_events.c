int DevRWCompletionHandler(void *context, int status)\r\n{\r\nstruct htc_packet *pPacket = (struct htc_packet *)context;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("+DevRWCompletionHandler (Pkt:0x%lX) , Status: %d \n",\r\n(unsigned long)pPacket,\r\nstatus));\r\nCOMPLETE_HTC_PACKET(pPacket,status);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("-DevRWCompletionHandler\n"));\r\nreturn 0;\r\n}\r\nint DevPollMboxMsgRecv(struct ar6k_device *pDev,\r\nu32 *pLookAhead,\r\nint TimeoutMS)\r\n{\r\nint status = 0;\r\nint timeout = TimeoutMS/DELAY_PER_INTERVAL_MS;\r\nA_ASSERT(timeout > 0);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+DevPollMboxMsgRecv \n"));\r\nwhile (true) {\r\nif (pDev->GetPendingEventsFunc != NULL) {\r\nstruct hif_pending_events_info events;\r\n#ifdef THREAD_X\r\nevents.Polling =1;\r\n#endif\r\nstatus = pDev->GetPendingEventsFunc(pDev->HIFDevice,\r\n&events,\r\nNULL);\r\nif (status)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to get pending events \n"));\r\nbreak;\r\n}\r\nif (events.Events & HIF_RECV_MSG_AVAIL)\r\n{\r\n*pLookAhead = events.LookAhead;\r\nbreak;\r\n}\r\n} else {\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nHOST_INT_STATUS_ADDRESS,\r\n(u8 *)&pDev->IrqProcRegisters,\r\nAR6K_IRQ_PROC_REGS_SIZE,\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nif (status){\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to read register table \n"));\r\nbreak;\r\n}\r\nif (pDev->IrqProcRegisters.host_int_status & (1 << HTC_MAILBOX)) {\r\nif (pDev->IrqProcRegisters.rx_lookahead_valid & (1 << HTC_MAILBOX))\r\n{\r\n*pLookAhead = pDev->IrqProcRegisters.rx_lookahead[HTC_MAILBOX];\r\nbreak;\r\n}\r\n}\r\n}\r\ntimeout--;\r\nif (timeout <= 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" Timeout waiting for recv message \n"));\r\nstatus = A_ERROR;\r\nif ( pDev->IrqProcRegisters.counter_int_status & AR6K_TARGET_DEBUG_INTR_MASK) {\r\nDevServiceDebugInterrupt(pDev);\r\n}\r\nbreak;\r\n}\r\nA_MDELAY(DELAY_PER_INTERVAL_MS);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,(" Retry Mbox Poll : %d \n",timeout));\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-DevPollMboxMsgRecv \n"));\r\nreturn status;\r\n}\r\nstatic int DevServiceCPUInterrupt(struct ar6k_device *pDev)\r\n{\r\nint status;\r\nu8 cpu_int_status;\r\nu8 regBuffer[4];\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("CPU Interrupt\n"));\r\ncpu_int_status = pDev->IrqProcRegisters.cpu_int_status &\r\npDev->IrqEnableRegisters.cpu_int_status_enable;\r\nA_ASSERT(cpu_int_status);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,\r\n("Valid interrupt source(s) in CPU_INT_STATUS: 0x%x\n",\r\ncpu_int_status));\r\npDev->IrqProcRegisters.cpu_int_status &= ~cpu_int_status;\r\nregBuffer[0] = cpu_int_status;\r\nregBuffer[1] = 0;\r\nregBuffer[2] = 0;\r\nregBuffer[3] = 0;\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nCPU_INT_STATUS_ADDRESS,\r\nregBuffer,\r\n4,\r\nHIF_WR_SYNC_BYTE_FIX,\r\nNULL);\r\nA_ASSERT(status == 0);\r\nreturn status;\r\n}\r\nstatic int DevServiceErrorInterrupt(struct ar6k_device *pDev)\r\n{\r\nint status;\r\nu8 error_int_status;\r\nu8 regBuffer[4];\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Error Interrupt\n"));\r\nerror_int_status = pDev->IrqProcRegisters.error_int_status & 0x0F;\r\nA_ASSERT(error_int_status);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,\r\n("Valid interrupt source(s) in ERROR_INT_STATUS: 0x%x\n",\r\nerror_int_status));\r\nif (ERROR_INT_STATUS_WAKEUP_GET(error_int_status)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Error : Wakeup\n"));\r\n}\r\nif (ERROR_INT_STATUS_RX_UNDERFLOW_GET(error_int_status)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Error : Rx Underflow\n"));\r\n}\r\nif (ERROR_INT_STATUS_TX_OVERFLOW_GET(error_int_status)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Error : Tx Overflow\n"));\r\n}\r\npDev->IrqProcRegisters.error_int_status &= ~error_int_status;\r\nregBuffer[0] = error_int_status;\r\nregBuffer[1] = 0;\r\nregBuffer[2] = 0;\r\nregBuffer[3] = 0;\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nERROR_INT_STATUS_ADDRESS,\r\nregBuffer,\r\n4,\r\nHIF_WR_SYNC_BYTE_FIX,\r\nNULL);\r\nA_ASSERT(status == 0);\r\nreturn status;\r\n}\r\nstatic int DevServiceDebugInterrupt(struct ar6k_device *pDev)\r\n{\r\nu32 dummy;\r\nint status;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Target debug interrupt\n"));\r\nif (pDev->TargetFailureCallback != NULL) {\r\npDev->TargetFailureCallback(pDev->HTCContext);\r\n}\r\nif (pDev->GMboxEnabled) {\r\nDevNotifyGMboxTargetFailure(pDev);\r\n}\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nCOUNT_DEC_ADDRESS,\r\n(u8 *)&dummy,\r\n4,\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nA_ASSERT(status == 0);\r\nreturn status;\r\n}\r\nstatic int DevServiceCounterInterrupt(struct ar6k_device *pDev)\r\n{\r\nu8 counter_int_status;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Counter Interrupt\n"));\r\ncounter_int_status = pDev->IrqProcRegisters.counter_int_status &\r\npDev->IrqEnableRegisters.counter_int_status_enable;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,\r\n("Valid interrupt source(s) in COUNTER_INT_STATUS: 0x%x\n",\r\ncounter_int_status));\r\nif (counter_int_status & AR6K_TARGET_DEBUG_INTR_MASK) {\r\nreturn DevServiceDebugInterrupt(pDev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void DevGetEventAsyncHandler(void *Context, struct htc_packet *pPacket)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)Context;\r\nu32 lookAhead = 0;\r\nbool otherInts = false;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevGetEventAsyncHandler: (dev: 0x%lX)\n", (unsigned long)pDev));\r\ndo {\r\nif (pPacket->Status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n(" GetEvents I/O request failed, status:%d \n", pPacket->Status));\r\nbreak;\r\n}\r\nif (pDev->GetPendingEventsFunc != NULL) {\r\nstruct hif_pending_events_info *pEvents = (struct hif_pending_events_info *)pPacket->pBuffer;\r\nif (pEvents->Events & HIF_RECV_MSG_AVAIL) {\r\nlookAhead = pEvents->LookAhead;\r\nif (0 == lookAhead) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" DevGetEventAsyncHandler1, lookAhead is zero! \n"));\r\n}\r\n}\r\nif (pEvents->Events & HIF_OTHER_EVENTS) {\r\notherInts = true;\r\n}\r\n} else {\r\nstruct ar6k_irq_proc_registers *pReg = (struct ar6k_irq_proc_registers *)pPacket->pBuffer;\r\nu8 host_int_status;\r\nhost_int_status = pReg->host_int_status & pDev->IrqEnableRegisters.int_status_enable;\r\nif (host_int_status & (1 << HTC_MAILBOX)) {\r\nhost_int_status &= ~(1 << HTC_MAILBOX);\r\nif (pReg->rx_lookahead_valid & (1 << HTC_MAILBOX)) {\r\nlookAhead = pReg->rx_lookahead[HTC_MAILBOX];\r\nif (0 == lookAhead) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" DevGetEventAsyncHandler2, lookAhead is zero! \n"));\r\n}\r\n}\r\n}\r\nif (host_int_status) {\r\notherInts = true;\r\n}\r\n}\r\nif (otherInts || (lookAhead == 0)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,\r\n(" Acking interrupt from DevGetEventAsyncHandler (otherints:%d, lookahead:0x%X)\n",\r\notherInts, lookAhead));\r\nHIFAckInterrupt(pDev->HIFDevice);\r\n} else {\r\nint fetched = 0;\r\nint status;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,\r\n(" DevGetEventAsyncHandler : detected another message, lookahead :0x%X \n",\r\nlookAhead));\r\nstatus = pDev->MessagePendingCallback(pDev->HTCContext, &lookAhead, 1, NULL, &fetched);\r\nif (!status && !fetched) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("MessagePendingCallback did not pull any messages, force-ack \n"));\r\nDevAsyncIrqProcessComplete(pDev);\r\n}\r\n}\r\n} while (false);\r\nAR6KFreeIOPacket(pDev,pPacket);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevGetEventAsyncHandler \n"));\r\n}\r\nint DevCheckPendingRecvMsgsAsync(void *context)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)context;\r\nint status = 0;\r\nstruct htc_packet *pIOPacket;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevCheckPendingRecvMsgsAsync: (dev: 0x%lX)\n", (unsigned long)pDev));\r\ndo {\r\nif (HIF_DEVICE_IRQ_SYNC_ONLY == pDev->HifIRQProcessingMode) {\r\nbreak;\r\n}\r\nif (pDev->RecheckIRQStatusCnt == 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("Bypassing IRQ Status re-check, re-acking HIF interrupts\n"));\r\nHIFAckInterrupt(pDev->HIFDevice);\r\nbreak;\r\n}\r\npIOPacket = AR6KAllocIOPacket(pDev);\r\nif (NULL == pIOPacket) {\r\nstatus = A_NO_MEMORY;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\npIOPacket->Completion = DevGetEventAsyncHandler;\r\npIOPacket->pContext = pDev;\r\nif (pDev->GetPendingEventsFunc) {\r\nstatus = pDev->GetPendingEventsFunc(pDev->HIFDevice,\r\n(struct hif_pending_events_info *)pIOPacket->pBuffer,\r\npIOPacket);\r\n} else {\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nHOST_INT_STATUS_ADDRESS,\r\npIOPacket->pBuffer,\r\nAR6K_IRQ_PROC_REGS_SIZE,\r\nHIF_RD_ASYNC_BYTE_INC,\r\npIOPacket);\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,(" Async IO issued to get interrupt status...\n"));\r\n} while (false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevCheckPendingRecvMsgsAsync \n"));\r\nreturn status;\r\n}\r\nvoid DevAsyncIrqProcessComplete(struct ar6k_device *pDev)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("DevAsyncIrqProcessComplete - forcing HIF IRQ ACK \n"));\r\nHIFAckInterrupt(pDev->HIFDevice);\r\n}\r\nstatic int ProcessPendingIRQs(struct ar6k_device *pDev, bool *pDone, bool *pASyncProcessing)\r\n{\r\nint status = 0;\r\nu8 host_int_status = 0;\r\nu32 lookAhead = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+ProcessPendingIRQs: (dev: 0x%lX)\n", (unsigned long)pDev));\r\ndo {\r\nif (pDev->IrqEnableRegisters.int_status_enable == 0) {\r\nbreak;\r\n}\r\nif (pDev->GetPendingEventsFunc != NULL) {\r\nstruct hif_pending_events_info events;\r\n#ifdef THREAD_X\r\nevents.Polling= 0;\r\n#endif\r\nstatus = pDev->GetPendingEventsFunc(pDev->HIFDevice,\r\n&events,\r\nNULL);\r\nif (status) {\r\nbreak;\r\n}\r\nif (events.Events & HIF_RECV_MSG_AVAIL) {\r\nlookAhead = events.LookAhead;\r\nif (0 == lookAhead) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" ProcessPendingIRQs1 lookAhead is zero! \n"));\r\n}\r\n}\r\nif (!(events.Events & HIF_OTHER_EVENTS) ||\r\n!(pDev->IrqEnableRegisters.int_status_enable & OTHER_INTS_ENABLED)) {\r\nbreak;\r\n}\r\n}\r\n#ifdef CONFIG_MMC_SDHCI_S3C\r\npDev->IrqProcRegisters.host_int_status = 0;\r\npDev->IrqProcRegisters.rx_lookahead_valid = 0;\r\npDev->IrqProcRegisters.host_int_status2 = 0;\r\npDev->IrqProcRegisters.rx_lookahead[0] = 0;\r\npDev->IrqProcRegisters.rx_lookahead[1] = 0xaaa5555;\r\n#endif\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nHOST_INT_STATUS_ADDRESS,\r\n(u8 *)&pDev->IrqProcRegisters,\r\nAR6K_IRQ_PROC_REGS_SIZE,\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nbreak;\r\n}\r\n#ifdef ATH_DEBUG_MODULE\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_IRQ)) {\r\nDevDumpRegisters(pDev,\r\n&pDev->IrqProcRegisters,\r\n&pDev->IrqEnableRegisters);\r\n}\r\n#endif\r\nhost_int_status = pDev->IrqProcRegisters.host_int_status &\r\npDev->IrqEnableRegisters.int_status_enable;\r\nif (NULL == pDev->GetPendingEventsFunc) {\r\nif (host_int_status & (1 << HTC_MAILBOX)) {\r\nhost_int_status &= ~(1 << HTC_MAILBOX);\r\nif (pDev->IrqProcRegisters.rx_lookahead_valid & (1 << HTC_MAILBOX)) {\r\nlookAhead = pDev->IrqProcRegisters.rx_lookahead[HTC_MAILBOX];\r\nif (0 == lookAhead) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" ProcessPendingIRQs2, lookAhead is zero! \n"));\r\n}\r\n}\r\n}\r\n} else {\r\nhost_int_status &= ~(1 << HTC_MAILBOX);\r\n}\r\nif (pDev->GMboxEnabled) {\r\nstatus = DevCheckGMboxInterrupts(pDev);\r\n}\r\n} while (false);\r\ndo {\r\nif (status) {\r\nbreak;\r\n}\r\nif ((0 == host_int_status) && (0 == lookAhead)) {\r\n*pDone = true;\r\nbreak;\r\n}\r\nif (lookAhead != 0) {\r\nint fetched = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("Pending mailbox message, LookAhead: 0x%X\n",lookAhead));\r\nstatus = pDev->MessagePendingCallback(pDev->HTCContext, &lookAhead, 1, pASyncProcessing, &fetched);\r\nif (status) {\r\nbreak;\r\n}\r\nif (!fetched) {\r\n*pASyncProcessing = false;\r\npDev->RecheckIRQStatusCnt = 0;\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,\r\n(" Valid interrupt source(s) for OTHER interrupts: 0x%x\n",\r\nhost_int_status));\r\nif (HOST_INT_STATUS_CPU_GET(host_int_status)) {\r\nstatus = DevServiceCPUInterrupt(pDev);\r\nif (status){\r\nbreak;\r\n}\r\n}\r\nif (HOST_INT_STATUS_ERROR_GET(host_int_status)) {\r\nstatus = DevServiceErrorInterrupt(pDev);\r\nif (status){\r\nbreak;\r\n}\r\n}\r\nif (HOST_INT_STATUS_COUNTER_GET(host_int_status)) {\r\nstatus = DevServiceCounterInterrupt(pDev);\r\nif (status){\r\nbreak;\r\n}\r\n}\r\n} while (false);\r\nif (!(*pASyncProcessing) && (pDev->RecheckIRQStatusCnt == 0) && (pDev->GetPendingEventsFunc == NULL)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("Bypassing IRQ Status re-check, forcing done \n"));\r\n*pDone = true;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-ProcessPendingIRQs: (done:%d, async:%d) status=%d \n",\r\n*pDone, *pASyncProcessing, status));\r\nreturn status;\r\n}\r\nint DevDsrHandler(void *context)\r\n{\r\nstruct ar6k_device *pDev = (struct ar6k_device *)context;\r\nint status = 0;\r\nbool done = false;\r\nbool asyncProc = false;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevDsrHandler: (dev: 0x%lX)\n", (unsigned long)pDev));\r\npDev->CurrentDSRRecvCount = 0;\r\npDev->RecheckIRQStatusCnt = 0;\r\nwhile (!done) {\r\nstatus = ProcessPendingIRQs(pDev, &done, &asyncProc);\r\nif (status) {\r\nbreak;\r\n}\r\nif (HIF_DEVICE_IRQ_SYNC_ONLY == pDev->HifIRQProcessingMode) {\r\nasyncProc = false;\r\nif (pDev->DSRCanYield && DEV_CHECK_RECV_YIELD(pDev)) {\r\nbreak;\r\n}\r\n}\r\nif (asyncProc) {\r\nbreak;\r\n}\r\n}\r\nif (!status && !asyncProc) {\r\nif (pDev->DSRCanYield) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,(" Yield in effect (cur RX count: %d) \n", pDev->CurrentDSRRecvCount));\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,(" Acking interrupt from DevDsrHandler \n"));\r\nHIFAckInterrupt(pDev->HIFDevice);\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevDsrHandler \n"));\r\nreturn status;\r\n}\r\nvoid DumpAR6KDevState(struct ar6k_device *pDev)\r\n{\r\nint status;\r\nstruct ar6k_irq_enable_registers regs;\r\nstruct ar6k_irq_proc_registers procRegs;\r\nLOCK_AR6K(pDev);\r\nmemcpy(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);\r\nUNLOCK_AR6K(pDev);\r\nstatus = HIFReadWrite(pDev->HIFDevice,\r\nHOST_INT_STATUS_ADDRESS,\r\n(u8 *)&procRegs,\r\nAR6K_IRQ_PROC_REGS_SIZE,\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("DumpAR6KDevState : Failed to read register table (%d) \n",status));\r\nreturn;\r\n}\r\nDevDumpRegisters(pDev,&procRegs,&regs);\r\nif (pDev->GMboxInfo.pStateDumpCallback != NULL) {\r\npDev->GMboxInfo.pStateDumpCallback(pDev->GMboxInfo.pProtocolContext);\r\n}\r\nHIFConfigureDevice(pDev->HIFDevice,HIF_DEVICE_DEBUG_BUS_STATE,NULL,0);\r\n}
