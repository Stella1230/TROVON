static const char *pvr2_buffer_state_decode(enum pvr2_buffer_state st)\r\n{\r\nswitch (st) {\r\ncase pvr2_buffer_state_none: return "none";\r\ncase pvr2_buffer_state_idle: return "idle";\r\ncase pvr2_buffer_state_queued: return "queued";\r\ncase pvr2_buffer_state_ready: return "ready";\r\n}\r\nreturn "unknown";\r\n}\r\nstatic void pvr2_buffer_describe(struct pvr2_buffer *bp,const char *msg)\r\n{\r\npvr2_trace(PVR2_TRACE_INFO,\r\n"buffer%s%s %p state=%s id=%d status=%d"\r\n" stream=%p purb=%p sig=0x%x",\r\n(msg ? " " : ""),\r\n(msg ? msg : ""),\r\nbp,\r\n(bp ? pvr2_buffer_state_decode(bp->state) : "(invalid)"),\r\n(bp ? bp->id : 0),\r\n(bp ? bp->status : 0),\r\n(bp ? bp->stream : NULL),\r\n(bp ? bp->purb : NULL),\r\n(bp ? bp->signature : 0));\r\n}\r\nstatic void pvr2_buffer_remove(struct pvr2_buffer *bp)\r\n{\r\nunsigned int *cnt;\r\nunsigned int *bcnt;\r\nunsigned int ccnt;\r\nstruct pvr2_stream *sp = bp->stream;\r\nswitch (bp->state) {\r\ncase pvr2_buffer_state_idle:\r\ncnt = &sp->i_count;\r\nbcnt = &sp->i_bcount;\r\nccnt = bp->max_count;\r\nbreak;\r\ncase pvr2_buffer_state_queued:\r\ncnt = &sp->q_count;\r\nbcnt = &sp->q_bcount;\r\nccnt = bp->max_count;\r\nbreak;\r\ncase pvr2_buffer_state_ready:\r\ncnt = &sp->r_count;\r\nbcnt = &sp->r_bcount;\r\nccnt = bp->used_count;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nlist_del_init(&bp->list_overhead);\r\n(*cnt)--;\r\n(*bcnt) -= ccnt;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/"\r\n" bufferPool %8s dec cap=%07d cnt=%02d",\r\npvr2_buffer_state_decode(bp->state),*bcnt,*cnt);\r\nbp->state = pvr2_buffer_state_none;\r\n}\r\nstatic void pvr2_buffer_set_none(struct pvr2_buffer *bp)\r\n{\r\nunsigned long irq_flags;\r\nstruct pvr2_stream *sp;\r\nBUFFER_CHECK(bp);\r\nsp = bp->stream;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/ bufferState %p %6s --> %6s",\r\nbp,\r\npvr2_buffer_state_decode(bp->state),\r\npvr2_buffer_state_decode(pvr2_buffer_state_none));\r\nspin_lock_irqsave(&sp->list_lock,irq_flags);\r\npvr2_buffer_remove(bp);\r\nspin_unlock_irqrestore(&sp->list_lock,irq_flags);\r\n}\r\nstatic int pvr2_buffer_set_ready(struct pvr2_buffer *bp)\r\n{\r\nint fl;\r\nunsigned long irq_flags;\r\nstruct pvr2_stream *sp;\r\nBUFFER_CHECK(bp);\r\nsp = bp->stream;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/ bufferState %p %6s --> %6s",\r\nbp,\r\npvr2_buffer_state_decode(bp->state),\r\npvr2_buffer_state_decode(pvr2_buffer_state_ready));\r\nspin_lock_irqsave(&sp->list_lock,irq_flags);\r\nfl = (sp->r_count == 0);\r\npvr2_buffer_remove(bp);\r\nlist_add_tail(&bp->list_overhead,&sp->ready_list);\r\nbp->state = pvr2_buffer_state_ready;\r\n(sp->r_count)++;\r\nsp->r_bcount += bp->used_count;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/"\r\n" bufferPool %8s inc cap=%07d cnt=%02d",\r\npvr2_buffer_state_decode(bp->state),\r\nsp->r_bcount,sp->r_count);\r\nspin_unlock_irqrestore(&sp->list_lock,irq_flags);\r\nreturn fl;\r\n}\r\nstatic void pvr2_buffer_set_idle(struct pvr2_buffer *bp)\r\n{\r\nunsigned long irq_flags;\r\nstruct pvr2_stream *sp;\r\nBUFFER_CHECK(bp);\r\nsp = bp->stream;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/ bufferState %p %6s --> %6s",\r\nbp,\r\npvr2_buffer_state_decode(bp->state),\r\npvr2_buffer_state_decode(pvr2_buffer_state_idle));\r\nspin_lock_irqsave(&sp->list_lock,irq_flags);\r\npvr2_buffer_remove(bp);\r\nlist_add_tail(&bp->list_overhead,&sp->idle_list);\r\nbp->state = pvr2_buffer_state_idle;\r\n(sp->i_count)++;\r\nsp->i_bcount += bp->max_count;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/"\r\n" bufferPool %8s inc cap=%07d cnt=%02d",\r\npvr2_buffer_state_decode(bp->state),\r\nsp->i_bcount,sp->i_count);\r\nspin_unlock_irqrestore(&sp->list_lock,irq_flags);\r\n}\r\nstatic void pvr2_buffer_set_queued(struct pvr2_buffer *bp)\r\n{\r\nunsigned long irq_flags;\r\nstruct pvr2_stream *sp;\r\nBUFFER_CHECK(bp);\r\nsp = bp->stream;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/ bufferState %p %6s --> %6s",\r\nbp,\r\npvr2_buffer_state_decode(bp->state),\r\npvr2_buffer_state_decode(pvr2_buffer_state_queued));\r\nspin_lock_irqsave(&sp->list_lock,irq_flags);\r\npvr2_buffer_remove(bp);\r\nlist_add_tail(&bp->list_overhead,&sp->queued_list);\r\nbp->state = pvr2_buffer_state_queued;\r\n(sp->q_count)++;\r\nsp->q_bcount += bp->max_count;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/"\r\n" bufferPool %8s inc cap=%07d cnt=%02d",\r\npvr2_buffer_state_decode(bp->state),\r\nsp->q_bcount,sp->q_count);\r\nspin_unlock_irqrestore(&sp->list_lock,irq_flags);\r\n}\r\nstatic void pvr2_buffer_wipe(struct pvr2_buffer *bp)\r\n{\r\nif (bp->state == pvr2_buffer_state_queued) {\r\nusb_kill_urb(bp->purb);\r\n}\r\n}\r\nstatic int pvr2_buffer_init(struct pvr2_buffer *bp,\r\nstruct pvr2_stream *sp,\r\nunsigned int id)\r\n{\r\nmemset(bp,0,sizeof(*bp));\r\nbp->signature = BUFFER_SIG;\r\nbp->id = id;\r\npvr2_trace(PVR2_TRACE_BUF_POOL,\r\n"/*---TRACE_FLOW---*/ bufferInit %p stream=%p",bp,sp);\r\nbp->stream = sp;\r\nbp->state = pvr2_buffer_state_none;\r\nINIT_LIST_HEAD(&bp->list_overhead);\r\nbp->purb = usb_alloc_urb(0,GFP_KERNEL);\r\nif (! bp->purb) return -ENOMEM;\r\n#ifdef SANITY_CHECK_BUFFERS\r\npvr2_buffer_describe(bp,"create");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void pvr2_buffer_done(struct pvr2_buffer *bp)\r\n{\r\n#ifdef SANITY_CHECK_BUFFERS\r\npvr2_buffer_describe(bp,"delete");\r\n#endif\r\npvr2_buffer_wipe(bp);\r\npvr2_buffer_set_none(bp);\r\nbp->signature = 0;\r\nbp->stream = NULL;\r\nusb_free_urb(bp->purb);\r\npvr2_trace(PVR2_TRACE_BUF_POOL,"/*---TRACE_FLOW---*/"\r\n" bufferDone %p",bp);\r\n}\r\nstatic int pvr2_stream_buffer_count(struct pvr2_stream *sp,unsigned int cnt)\r\n{\r\nint ret;\r\nunsigned int scnt;\r\nif (cnt == sp->buffer_total_count) return 0;\r\npvr2_trace(PVR2_TRACE_BUF_POOL,\r\n"/*---TRACE_FLOW---*/ poolResize "\r\n" stream=%p cur=%d adj=%+d",\r\nsp,\r\nsp->buffer_total_count,\r\ncnt-sp->buffer_total_count);\r\nscnt = cnt & ~0x1f;\r\nif (cnt > scnt) scnt += 0x20;\r\nif (cnt > sp->buffer_total_count) {\r\nif (scnt > sp->buffer_slot_count) {\r\nstruct pvr2_buffer **nb;\r\nnb = kmalloc(scnt * sizeof(*nb),GFP_KERNEL);\r\nif (!nb) return -ENOMEM;\r\nif (sp->buffer_slot_count) {\r\nmemcpy(nb,sp->buffers,\r\nsp->buffer_slot_count * sizeof(*nb));\r\nkfree(sp->buffers);\r\n}\r\nsp->buffers = nb;\r\nsp->buffer_slot_count = scnt;\r\n}\r\nwhile (sp->buffer_total_count < cnt) {\r\nstruct pvr2_buffer *bp;\r\nbp = kmalloc(sizeof(*bp),GFP_KERNEL);\r\nif (!bp) return -ENOMEM;\r\nret = pvr2_buffer_init(bp,sp,sp->buffer_total_count);\r\nif (ret) {\r\nkfree(bp);\r\nreturn -ENOMEM;\r\n}\r\nsp->buffers[sp->buffer_total_count] = bp;\r\n(sp->buffer_total_count)++;\r\npvr2_buffer_set_idle(bp);\r\n}\r\n} else {\r\nwhile (sp->buffer_total_count > cnt) {\r\nstruct pvr2_buffer *bp;\r\nbp = sp->buffers[sp->buffer_total_count - 1];\r\nsp->buffers[sp->buffer_total_count - 1] = NULL;\r\n(sp->buffer_total_count)--;\r\npvr2_buffer_done(bp);\r\nkfree(bp);\r\n}\r\nif (scnt < sp->buffer_slot_count) {\r\nstruct pvr2_buffer **nb = NULL;\r\nif (scnt) {\r\nnb = kmalloc(scnt * sizeof(*nb),GFP_KERNEL);\r\nif (!nb) return -ENOMEM;\r\nmemcpy(nb,sp->buffers,scnt * sizeof(*nb));\r\n}\r\nkfree(sp->buffers);\r\nsp->buffers = nb;\r\nsp->buffer_slot_count = scnt;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_stream_achieve_buffer_count(struct pvr2_stream *sp)\r\n{\r\nstruct pvr2_buffer *bp;\r\nunsigned int cnt;\r\nif (sp->buffer_total_count == sp->buffer_target_count) return 0;\r\npvr2_trace(PVR2_TRACE_BUF_POOL,\r\n"/*---TRACE_FLOW---*/"\r\n" poolCheck stream=%p cur=%d tgt=%d",\r\nsp,sp->buffer_total_count,sp->buffer_target_count);\r\nif (sp->buffer_total_count < sp->buffer_target_count) {\r\nreturn pvr2_stream_buffer_count(sp,sp->buffer_target_count);\r\n}\r\ncnt = 0;\r\nwhile ((sp->buffer_total_count - cnt) > sp->buffer_target_count) {\r\nbp = sp->buffers[sp->buffer_total_count - (cnt + 1)];\r\nif (bp->state != pvr2_buffer_state_idle) break;\r\ncnt++;\r\n}\r\nif (cnt) {\r\npvr2_stream_buffer_count(sp,sp->buffer_total_count - cnt);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pvr2_stream_internal_flush(struct pvr2_stream *sp)\r\n{\r\nstruct list_head *lp;\r\nstruct pvr2_buffer *bp1;\r\nwhile ((lp = sp->queued_list.next) != &sp->queued_list) {\r\nbp1 = list_entry(lp,struct pvr2_buffer,list_overhead);\r\npvr2_buffer_wipe(bp1);\r\nif (bp1->state != pvr2_buffer_state_queued) continue;\r\npvr2_buffer_set_idle(bp1);\r\n}\r\nif (sp->buffer_total_count != sp->buffer_target_count) {\r\npvr2_stream_achieve_buffer_count(sp);\r\n}\r\n}\r\nstatic void pvr2_stream_init(struct pvr2_stream *sp)\r\n{\r\nspin_lock_init(&sp->list_lock);\r\nmutex_init(&sp->mutex);\r\nINIT_LIST_HEAD(&sp->queued_list);\r\nINIT_LIST_HEAD(&sp->ready_list);\r\nINIT_LIST_HEAD(&sp->idle_list);\r\n}\r\nstatic void pvr2_stream_done(struct pvr2_stream *sp)\r\n{\r\nmutex_lock(&sp->mutex); do {\r\npvr2_stream_internal_flush(sp);\r\npvr2_stream_buffer_count(sp,0);\r\n} while (0); mutex_unlock(&sp->mutex);\r\n}\r\nstatic void buffer_complete(struct urb *urb)\r\n{\r\nstruct pvr2_buffer *bp = urb->context;\r\nstruct pvr2_stream *sp;\r\nunsigned long irq_flags;\r\nBUFFER_CHECK(bp);\r\nsp = bp->stream;\r\nbp->used_count = 0;\r\nbp->status = 0;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/ bufferComplete %p stat=%d cnt=%d",\r\nbp,urb->status,urb->actual_length);\r\nspin_lock_irqsave(&sp->list_lock,irq_flags);\r\nif ((!(urb->status)) ||\r\n(urb->status == -ENOENT) ||\r\n(urb->status == -ECONNRESET) ||\r\n(urb->status == -ESHUTDOWN)) {\r\n(sp->buffers_processed)++;\r\nsp->bytes_processed += urb->actual_length;\r\nbp->used_count = urb->actual_length;\r\nif (sp->fail_count) {\r\npvr2_trace(PVR2_TRACE_TOLERANCE,\r\n"stream %p transfer ok"\r\n" - fail count reset",sp);\r\nsp->fail_count = 0;\r\n}\r\n} else if (sp->fail_count < sp->fail_tolerance) {\r\n(sp->fail_count)++;\r\n(sp->buffers_failed)++;\r\npvr2_trace(PVR2_TRACE_TOLERANCE,\r\n"stream %p ignoring error %d"\r\n" - fail count increased to %u",\r\nsp,urb->status,sp->fail_count);\r\n} else {\r\n(sp->buffers_failed)++;\r\nbp->status = urb->status;\r\n}\r\nspin_unlock_irqrestore(&sp->list_lock,irq_flags);\r\npvr2_buffer_set_ready(bp);\r\nif (sp && sp->callback_func) {\r\nsp->callback_func(sp->callback_data);\r\n}\r\n}\r\nstruct pvr2_stream *pvr2_stream_create(void)\r\n{\r\nstruct pvr2_stream *sp;\r\nsp = kzalloc(sizeof(*sp),GFP_KERNEL);\r\nif (!sp) return sp;\r\npvr2_trace(PVR2_TRACE_INIT,"pvr2_stream_create: sp=%p",sp);\r\npvr2_stream_init(sp);\r\nreturn sp;\r\n}\r\nvoid pvr2_stream_destroy(struct pvr2_stream *sp)\r\n{\r\nif (!sp) return;\r\npvr2_trace(PVR2_TRACE_INIT,"pvr2_stream_destroy: sp=%p",sp);\r\npvr2_stream_done(sp);\r\nkfree(sp);\r\n}\r\nvoid pvr2_stream_setup(struct pvr2_stream *sp,\r\nstruct usb_device *dev,\r\nint endpoint,\r\nunsigned int tolerance)\r\n{\r\nmutex_lock(&sp->mutex); do {\r\npvr2_stream_internal_flush(sp);\r\nsp->dev = dev;\r\nsp->endpoint = endpoint;\r\nsp->fail_tolerance = tolerance;\r\n} while(0); mutex_unlock(&sp->mutex);\r\n}\r\nvoid pvr2_stream_set_callback(struct pvr2_stream *sp,\r\npvr2_stream_callback func,\r\nvoid *data)\r\n{\r\nunsigned long irq_flags;\r\nmutex_lock(&sp->mutex); do {\r\nspin_lock_irqsave(&sp->list_lock,irq_flags);\r\nsp->callback_data = data;\r\nsp->callback_func = func;\r\nspin_unlock_irqrestore(&sp->list_lock,irq_flags);\r\n} while(0); mutex_unlock(&sp->mutex);\r\n}\r\nvoid pvr2_stream_get_stats(struct pvr2_stream *sp,\r\nstruct pvr2_stream_stats *stats,\r\nint zero_counts)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&sp->list_lock,irq_flags);\r\nif (stats) {\r\nstats->buffers_in_queue = sp->q_count;\r\nstats->buffers_in_idle = sp->i_count;\r\nstats->buffers_in_ready = sp->r_count;\r\nstats->buffers_processed = sp->buffers_processed;\r\nstats->buffers_failed = sp->buffers_failed;\r\nstats->bytes_processed = sp->bytes_processed;\r\n}\r\nif (zero_counts) {\r\nsp->buffers_processed = 0;\r\nsp->buffers_failed = 0;\r\nsp->bytes_processed = 0;\r\n}\r\nspin_unlock_irqrestore(&sp->list_lock,irq_flags);\r\n}\r\nint pvr2_stream_get_buffer_count(struct pvr2_stream *sp)\r\n{\r\nreturn sp->buffer_target_count;\r\n}\r\nint pvr2_stream_set_buffer_count(struct pvr2_stream *sp,unsigned int cnt)\r\n{\r\nint ret;\r\nif (sp->buffer_target_count == cnt) return 0;\r\nmutex_lock(&sp->mutex); do {\r\nsp->buffer_target_count = cnt;\r\nret = pvr2_stream_achieve_buffer_count(sp);\r\n} while(0); mutex_unlock(&sp->mutex);\r\nreturn ret;\r\n}\r\nstruct pvr2_buffer *pvr2_stream_get_idle_buffer(struct pvr2_stream *sp)\r\n{\r\nstruct list_head *lp = sp->idle_list.next;\r\nif (lp == &sp->idle_list) return NULL;\r\nreturn list_entry(lp,struct pvr2_buffer,list_overhead);\r\n}\r\nstruct pvr2_buffer *pvr2_stream_get_ready_buffer(struct pvr2_stream *sp)\r\n{\r\nstruct list_head *lp = sp->ready_list.next;\r\nif (lp == &sp->ready_list) return NULL;\r\nreturn list_entry(lp,struct pvr2_buffer,list_overhead);\r\n}\r\nstruct pvr2_buffer *pvr2_stream_get_buffer(struct pvr2_stream *sp,int id)\r\n{\r\nif (id < 0) return NULL;\r\nif (id >= sp->buffer_total_count) return NULL;\r\nreturn sp->buffers[id];\r\n}\r\nint pvr2_stream_get_ready_count(struct pvr2_stream *sp)\r\n{\r\nreturn sp->r_count;\r\n}\r\nvoid pvr2_stream_kill(struct pvr2_stream *sp)\r\n{\r\nstruct pvr2_buffer *bp;\r\nmutex_lock(&sp->mutex); do {\r\npvr2_stream_internal_flush(sp);\r\nwhile ((bp = pvr2_stream_get_ready_buffer(sp)) != NULL) {\r\npvr2_buffer_set_idle(bp);\r\n}\r\nif (sp->buffer_total_count != sp->buffer_target_count) {\r\npvr2_stream_achieve_buffer_count(sp);\r\n}\r\n} while(0); mutex_unlock(&sp->mutex);\r\n}\r\nint pvr2_buffer_queue(struct pvr2_buffer *bp)\r\n{\r\n#undef SEED_BUFFER\r\n#ifdef SEED_BUFFER\r\nunsigned int idx;\r\nunsigned int val;\r\n#endif\r\nint ret = 0;\r\nstruct pvr2_stream *sp;\r\nif (!bp) return -EINVAL;\r\nsp = bp->stream;\r\nmutex_lock(&sp->mutex); do {\r\npvr2_buffer_wipe(bp);\r\nif (!sp->dev) {\r\nret = -EIO;\r\nbreak;\r\n}\r\npvr2_buffer_set_queued(bp);\r\n#ifdef SEED_BUFFER\r\nfor (idx = 0; idx < (bp->max_count) / 4; idx++) {\r\nval = bp->id << 24;\r\nval |= idx;\r\n((unsigned int *)(bp->ptr))[idx] = val;\r\n}\r\n#endif\r\nbp->status = -EINPROGRESS;\r\nusb_fill_bulk_urb(bp->purb,\r\nsp->dev,\r\nusb_rcvbulkpipe(sp->dev,sp->endpoint),\r\nbp->ptr,\r\nbp->max_count,\r\nbuffer_complete,\r\nbp);\r\nusb_submit_urb(bp->purb,GFP_KERNEL);\r\n} while(0); mutex_unlock(&sp->mutex);\r\nreturn ret;\r\n}\r\nint pvr2_buffer_set_buffer(struct pvr2_buffer *bp,void *ptr,unsigned int cnt)\r\n{\r\nint ret = 0;\r\nunsigned long irq_flags;\r\nstruct pvr2_stream *sp;\r\nif (!bp) return -EINVAL;\r\nsp = bp->stream;\r\nmutex_lock(&sp->mutex); do {\r\nspin_lock_irqsave(&sp->list_lock,irq_flags);\r\nif (bp->state != pvr2_buffer_state_idle) {\r\nret = -EPERM;\r\n} else {\r\nbp->ptr = ptr;\r\nbp->stream->i_bcount -= bp->max_count;\r\nbp->max_count = cnt;\r\nbp->stream->i_bcount += bp->max_count;\r\npvr2_trace(PVR2_TRACE_BUF_FLOW,\r\n"/*---TRACE_FLOW---*/ bufferPool "\r\n" %8s cap cap=%07d cnt=%02d",\r\npvr2_buffer_state_decode(\r\npvr2_buffer_state_idle),\r\nbp->stream->i_bcount,bp->stream->i_count);\r\n}\r\nspin_unlock_irqrestore(&sp->list_lock,irq_flags);\r\n} while(0); mutex_unlock(&sp->mutex);\r\nreturn ret;\r\n}\r\nunsigned int pvr2_buffer_get_count(struct pvr2_buffer *bp)\r\n{\r\nreturn bp->used_count;\r\n}\r\nint pvr2_buffer_get_status(struct pvr2_buffer *bp)\r\n{\r\nreturn bp->status;\r\n}\r\nint pvr2_buffer_get_id(struct pvr2_buffer *bp)\r\n{\r\nreturn bp->id;\r\n}
