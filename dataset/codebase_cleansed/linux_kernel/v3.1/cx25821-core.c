static int cx25821_risc_decode(u32 risc)\r\n{\r\nstatic const char * const instr[16] = {\r\n[RISC_SYNC >> 28] = "sync",\r\n[RISC_WRITE >> 28] = "write",\r\n[RISC_WRITEC >> 28] = "writec",\r\n[RISC_READ >> 28] = "read",\r\n[RISC_READC >> 28] = "readc",\r\n[RISC_JUMP >> 28] = "jump",\r\n[RISC_SKIP >> 28] = "skip",\r\n[RISC_WRITERM >> 28] = "writerm",\r\n[RISC_WRITECM >> 28] = "writecm",\r\n[RISC_WRITECR >> 28] = "writecr",\r\n};\r\nstatic const int incr[16] = {\r\n[RISC_WRITE >> 28] = 3,\r\n[RISC_JUMP >> 28] = 3,\r\n[RISC_SKIP >> 28] = 1,\r\n[RISC_SYNC >> 28] = 1,\r\n[RISC_WRITERM >> 28] = 3,\r\n[RISC_WRITECM >> 28] = 3,\r\n[RISC_WRITECR >> 28] = 4,\r\n};\r\nstatic const char * const bits[] = {\r\n"12", "13", "14", "resync",\r\n"cnt0", "cnt1", "18", "19",\r\n"20", "21", "22", "23",\r\n"irq1", "irq2", "eol", "sol",\r\n};\r\nint i;\r\npr_cont("0x%08x [ %s",\r\nrisc, instr[risc >> 28] ? instr[risc >> 28] : "INVALID");\r\nfor (i = ARRAY_SIZE(bits) - 1; i >= 0; i--) {\r\nif (risc & (1 << (i + 12)))\r\npr_cont(" %s", bits[i]);\r\n}\r\npr_cont(" count=%d ]\n", risc & 0xfff);\r\nreturn incr[risc >> 28] ? incr[risc >> 28] : 1;\r\n}\r\nstatic inline int i2c_slave_did_ack(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct cx25821_i2c *bus = i2c_adap->algo_data;\r\nstruct cx25821_dev *dev = bus->dev;\r\nreturn cx_read(bus->reg_stat) & 0x01;\r\n}\r\nvoid cx_i2c_read_print(struct cx25821_dev *dev, u32 reg, const char *reg_string)\r\n{\r\nint tmp = 0;\r\nu32 value = 0;\r\nvalue = cx25821_i2c_read(&dev->i2c_bus[0], reg, &tmp);\r\n}\r\nstatic void cx25821_registers_init(struct cx25821_dev *dev)\r\n{\r\nu32 tmp;\r\ncx_write(DEV_CNTRL2, 0x20);\r\ncx_write(PCI_INT_MSK, 0x2001FFFF);\r\ntmp = cx_read(RDR_TLCTL0);\r\ntmp &= ~FLD_CFG_RCB_CK_EN;\r\ncx_write(RDR_TLCTL0, tmp);\r\ncx_write(PLL_A_INT_FRAC, 0x9807A58B);\r\ncx_write(PLL_A_POST_STAT_BIST, 0x8000019C);\r\ntmp = cx_read(PLL_A_INT_FRAC);\r\ncx_write(PLL_A_INT_FRAC, tmp & 0x7FFFFFFF);\r\ncx_write(PLL_B_INT_FRAC, 0x9883A86F);\r\ncx_write(PLL_B_POST_STAT_BIST, 0x8000018D);\r\ntmp = cx_read(PLL_B_INT_FRAC);\r\ncx_write(PLL_B_INT_FRAC, tmp & 0x7FFFFFFF);\r\ncx_write(PLL_C_INT_FRAC, 0x96A0EA3F);\r\ncx_write(PLL_C_POST_STAT_BIST, 0x80000103);\r\ntmp = cx_read(PLL_C_INT_FRAC);\r\ncx_write(PLL_C_INT_FRAC, tmp & 0x7FFFFFFF);\r\ncx_write(PLL_D_INT_FRAC, 0x98757F5B);\r\ncx_write(PLL_D_POST_STAT_BIST, 0x80000113);\r\ntmp = cx_read(PLL_D_INT_FRAC);\r\ncx_write(PLL_D_INT_FRAC, tmp & 0x7FFFFFFF);\r\ntmp = cx_read(VID_CH_CLK_SEL);\r\ncx_write(VID_CH_CLK_SEL, (tmp & 0x00FFFFFF) | 0x24000000);\r\ntmp = cx_read(VID_CH_MODE_SEL);\r\ncx_write(VID_CH_MODE_SEL, tmp & 0xFFFFFE00);\r\ntmp = cx_read(CLK_RST);\r\ntmp |= FLD_USE_ALT_PLL_REF;\r\ncx_write(CLK_RST, tmp & ~(FLD_VID_I_CLK_NOE | FLD_VID_J_CLK_NOE));\r\nmdelay(100);\r\n}\r\nint cx25821_sram_channel_setup(struct cx25821_dev *dev,\r\nstruct sram_channel *ch,\r\nunsigned int bpl, u32 risc)\r\n{\r\nunsigned int i, lines;\r\nu32 cdt;\r\nif (ch->cmds_start == 0) {\r\ncx_write(ch->ptr1_reg, 0);\r\ncx_write(ch->ptr2_reg, 0);\r\ncx_write(ch->cnt2_reg, 0);\r\ncx_write(ch->cnt1_reg, 0);\r\nreturn 0;\r\n}\r\nbpl = (bpl + 7) & ~7;\r\ncdt = ch->cdt;\r\nlines = ch->fifo_size / bpl;\r\nif (lines > 4)\r\nlines = 4;\r\nBUG_ON(lines < 2);\r\ncx_write(8 + 0, RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\r\ncx_write(8 + 4, 8);\r\ncx_write(8 + 8, 0);\r\nfor (i = 0; i < lines; i++) {\r\ncx_write(cdt + 16 * i, ch->fifo_start + bpl * i);\r\ncx_write(cdt + 16 * i + 4, 0);\r\ncx_write(cdt + 16 * i + 8, 0);\r\ncx_write(cdt + 16 * i + 12, 0);\r\n}\r\nfor (i = 0; i < 128; i++)\r\ncx_write(ch->fifo_start + 4 * i, i);\r\nif (ch->jumponly)\r\ncx_write(ch->cmds_start + 0, 8);\r\nelse\r\ncx_write(ch->cmds_start + 0, risc);\r\ncx_write(ch->cmds_start + 4, 0);\r\ncx_write(ch->cmds_start + 8, cdt);\r\ncx_write(ch->cmds_start + 12, (lines * 16) >> 3);\r\ncx_write(ch->cmds_start + 16, ch->ctrl_start);\r\nif (ch->jumponly)\r\ncx_write(ch->cmds_start + 20, 0x80000000 | (64 >> 2));\r\nelse\r\ncx_write(ch->cmds_start + 20, 64 >> 2);\r\nfor (i = 24; i < 80; i += 4)\r\ncx_write(ch->cmds_start + i, 0);\r\ncx_write(ch->ptr1_reg, ch->fifo_start);\r\ncx_write(ch->ptr2_reg, cdt);\r\ncx_write(ch->cnt2_reg, (lines * 16) >> 3);\r\ncx_write(ch->cnt1_reg, (bpl >> 3) - 1);\r\nreturn 0;\r\n}\r\nint cx25821_sram_channel_setup_audio(struct cx25821_dev *dev,\r\nstruct sram_channel *ch,\r\nunsigned int bpl, u32 risc)\r\n{\r\nunsigned int i, lines;\r\nu32 cdt;\r\nif (ch->cmds_start == 0) {\r\ncx_write(ch->ptr1_reg, 0);\r\ncx_write(ch->ptr2_reg, 0);\r\ncx_write(ch->cnt2_reg, 0);\r\ncx_write(ch->cnt1_reg, 0);\r\nreturn 0;\r\n}\r\nbpl = (bpl + 7) & ~7;\r\ncdt = ch->cdt;\r\nlines = ch->fifo_size / bpl;\r\nif (lines > 3)\r\nlines = 3;\r\nBUG_ON(lines < 2);\r\ncx_write(8 + 0, RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\r\ncx_write(8 + 4, 8);\r\ncx_write(8 + 8, 0);\r\nfor (i = 0; i < lines; i++) {\r\ncx_write(cdt + 16 * i, ch->fifo_start + bpl * i);\r\ncx_write(cdt + 16 * i + 4, 0);\r\ncx_write(cdt + 16 * i + 8, 0);\r\ncx_write(cdt + 16 * i + 12, 0);\r\n}\r\nif (ch->jumponly)\r\ncx_write(ch->cmds_start + 0, 8);\r\nelse\r\ncx_write(ch->cmds_start + 0, risc);\r\ncx_write(ch->cmds_start + 4, 0);\r\ncx_write(ch->cmds_start + 8, cdt);\r\ncx_write(ch->cmds_start + 12, (lines * 16) >> 3);\r\ncx_write(ch->cmds_start + 16, ch->ctrl_start);\r\nif (ch->jumponly)\r\ncx_write(ch->cmds_start + 20, 0x80000000 | (64 >> 2));\r\nelse\r\ncx_write(ch->cmds_start + 20, 64 >> 2);\r\nfor (i = 24; i < 80; i += 4)\r\ncx_write(ch->cmds_start + i, 0);\r\ncx_write(ch->ptr1_reg, ch->fifo_start);\r\ncx_write(ch->ptr2_reg, cdt);\r\ncx_write(ch->cnt2_reg, (lines * 16) >> 3);\r\ncx_write(ch->cnt1_reg, (bpl >> 3) - 1);\r\nreturn 0;\r\n}\r\nvoid cx25821_sram_channel_dump(struct cx25821_dev *dev, struct sram_channel *ch)\r\n{\r\nstatic char *name[] = {\r\n"init risc lo",\r\n"init risc hi",\r\n"cdt base",\r\n"cdt size",\r\n"iq base",\r\n"iq size",\r\n"risc pc lo",\r\n"risc pc hi",\r\n"iq wr ptr",\r\n"iq rd ptr",\r\n"cdt current",\r\n"pci target lo",\r\n"pci target hi",\r\n"line / byte",\r\n};\r\nu32 risc;\r\nunsigned int i, j, n;\r\npr_warn("%s: %s - dma channel status dump\n", dev->name, ch->name);\r\nfor (i = 0; i < ARRAY_SIZE(name); i++)\r\npr_warn("cmds + 0x%2x: %-15s: 0x%08x\n",\r\ni * 4, name[i], cx_read(ch->cmds_start + 4 * i));\r\nj = i * 4;\r\nfor (i = 0; i < 4;) {\r\nrisc = cx_read(ch->cmds_start + 4 * (i + 14));\r\npr_warn("cmds + 0x%2x: risc%d: ", j + i * 4, i);\r\ni += cx25821_risc_decode(risc);\r\n}\r\nfor (i = 0; i < (64 >> 2); i += n) {\r\nrisc = cx_read(ch->ctrl_start + 4 * i);\r\npr_warn("ctrl + 0x%2x (0x%08x): iq %x: ",\r\ni * 4, ch->ctrl_start + 4 * i, i);\r\nn = cx25821_risc_decode(risc);\r\nfor (j = 1; j < n; j++) {\r\nrisc = cx_read(ch->ctrl_start + 4 * (i + j));\r\npr_warn("ctrl + 0x%2x : iq %x: 0x%08x [ arg #%d ]\n",\r\n4 * (i + j), i + j, risc, j);\r\n}\r\n}\r\npr_warn(" : fifo: 0x%08x -> 0x%x\n",\r\nch->fifo_start, ch->fifo_start + ch->fifo_size);\r\npr_warn(" : ctrl: 0x%08x -> 0x%x\n",\r\nch->ctrl_start, ch->ctrl_start + 6 * 16);\r\npr_warn(" : ptr1_reg: 0x%08x\n",\r\ncx_read(ch->ptr1_reg));\r\npr_warn(" : ptr2_reg: 0x%08x\n",\r\ncx_read(ch->ptr2_reg));\r\npr_warn(" : cnt1_reg: 0x%08x\n",\r\ncx_read(ch->cnt1_reg));\r\npr_warn(" : cnt2_reg: 0x%08x\n",\r\ncx_read(ch->cnt2_reg));\r\n}\r\nvoid cx25821_sram_channel_dump_audio(struct cx25821_dev *dev,\r\nstruct sram_channel *ch)\r\n{\r\nstatic const char * const name[] = {\r\n"init risc lo",\r\n"init risc hi",\r\n"cdt base",\r\n"cdt size",\r\n"iq base",\r\n"iq size",\r\n"risc pc lo",\r\n"risc pc hi",\r\n"iq wr ptr",\r\n"iq rd ptr",\r\n"cdt current",\r\n"pci target lo",\r\n"pci target hi",\r\n"line / byte",\r\n};\r\nu32 risc, value, tmp;\r\nunsigned int i, j, n;\r\npr_info("\n%s: %s - dma Audio channel status dump\n",\r\ndev->name, ch->name);\r\nfor (i = 0; i < ARRAY_SIZE(name); i++)\r\npr_info("%s: cmds + 0x%2x: %-15s: 0x%08x\n",\r\ndev->name, i * 4, name[i],\r\ncx_read(ch->cmds_start + 4 * i));\r\nj = i * 4;\r\nfor (i = 0; i < 4;) {\r\nrisc = cx_read(ch->cmds_start + 4 * (i + 14));\r\npr_warn("cmds + 0x%2x: risc%d: ", j + i * 4, i);\r\ni += cx25821_risc_decode(risc);\r\n}\r\nfor (i = 0; i < (64 >> 2); i += n) {\r\nrisc = cx_read(ch->ctrl_start + 4 * i);\r\npr_warn("ctrl + 0x%2x (0x%08x): iq %x: ",\r\ni * 4, ch->ctrl_start + 4 * i, i);\r\nn = cx25821_risc_decode(risc);\r\nfor (j = 1; j < n; j++) {\r\nrisc = cx_read(ch->ctrl_start + 4 * (i + j));\r\npr_warn("ctrl + 0x%2x : iq %x: 0x%08x [ arg #%d ]\n",\r\n4 * (i + j), i + j, risc, j);\r\n}\r\n}\r\npr_warn(" : fifo: 0x%08x -> 0x%x\n",\r\nch->fifo_start, ch->fifo_start + ch->fifo_size);\r\npr_warn(" : ctrl: 0x%08x -> 0x%x\n",\r\nch->ctrl_start, ch->ctrl_start + 6 * 16);\r\npr_warn(" : ptr1_reg: 0x%08x\n",\r\ncx_read(ch->ptr1_reg));\r\npr_warn(" : ptr2_reg: 0x%08x\n",\r\ncx_read(ch->ptr2_reg));\r\npr_warn(" : cnt1_reg: 0x%08x\n",\r\ncx_read(ch->cnt1_reg));\r\npr_warn(" : cnt2_reg: 0x%08x\n",\r\ncx_read(ch->cnt2_reg));\r\nfor (i = 0; i < 4; i++) {\r\nrisc = cx_read(ch->cmds_start + 56 + (i * 4));\r\npr_warn("instruction %d = 0x%x\n", i, risc);\r\n}\r\nrisc = cx_read(AUD_A_CDT);\r\npr_warn("\nread cdt loc=0x%x\n", risc);\r\nfor (i = 0; i < 8; i++) {\r\nn = cx_read(risc + i * 4);\r\npr_cont("0x%x ", n);\r\n}\r\npr_cont("\n\n");\r\nvalue = cx_read(CLK_RST);\r\nCX25821_INFO(" CLK_RST = 0x%x\n\n", value);\r\nvalue = cx_read(PLL_A_POST_STAT_BIST);\r\nCX25821_INFO(" PLL_A_POST_STAT_BIST = 0x%x\n\n", value);\r\nvalue = cx_read(PLL_A_INT_FRAC);\r\nCX25821_INFO(" PLL_A_INT_FRAC = 0x%x\n\n", value);\r\nvalue = cx_read(PLL_B_POST_STAT_BIST);\r\nCX25821_INFO(" PLL_B_POST_STAT_BIST = 0x%x\n\n", value);\r\nvalue = cx_read(PLL_B_INT_FRAC);\r\nCX25821_INFO(" PLL_B_INT_FRAC = 0x%x\n\n", value);\r\nvalue = cx_read(PLL_C_POST_STAT_BIST);\r\nCX25821_INFO(" PLL_C_POST_STAT_BIST = 0x%x\n\n", value);\r\nvalue = cx_read(PLL_C_INT_FRAC);\r\nCX25821_INFO(" PLL_C_INT_FRAC = 0x%x\n\n", value);\r\nvalue = cx_read(PLL_D_POST_STAT_BIST);\r\nCX25821_INFO(" PLL_D_POST_STAT_BIST = 0x%x\n\n", value);\r\nvalue = cx_read(PLL_D_INT_FRAC);\r\nCX25821_INFO(" PLL_D_INT_FRAC = 0x%x\n\n", value);\r\nvalue = cx25821_i2c_read(&dev->i2c_bus[0], AFE_AB_DIAG_CTRL, &tmp);\r\nCX25821_INFO(" AFE_AB_DIAG_CTRL (0x10900090) = 0x%x\n\n", value);\r\n}\r\nstatic void cx25821_shutdown(struct cx25821_dev *dev)\r\n{\r\nint i;\r\ncx_write(DEV_CNTRL2, 0);\r\nfor (i = 0; i < VID_CHANNEL_NUM; i++) {\r\ncx_write(dev->channels[i].sram_channels->dma_ctl, 0);\r\ncx_write(dev->channels[i].sram_channels->int_msk, 0);\r\n}\r\nfor (i = VID_UPSTREAM_SRAM_CHANNEL_I;\r\ni <= VID_UPSTREAM_SRAM_CHANNEL_J; i++) {\r\ncx_write(dev->channels[i].sram_channels->dma_ctl, 0);\r\ncx_write(dev->channels[i].sram_channels->int_msk, 0);\r\n}\r\ncx_write(AUD_INT_DMA_CTL, 0);\r\ncx_write(UART_CTL, 0);\r\ncx_write(PCI_INT_MSK, 0);\r\ncx_write(AUD_A_INT_MSK, 0);\r\n}\r\nvoid cx25821_set_pixel_format(struct cx25821_dev *dev, int channel_select,\r\nu32 format)\r\n{\r\nif (channel_select <= 7 && channel_select >= 0) {\r\ncx_write(dev->channels[channel_select].\r\nsram_channels->pix_frmt, format);\r\ndev->channels[channel_select].pixel_formats = format;\r\n}\r\n}\r\nstatic void cx25821_set_vip_mode(struct cx25821_dev *dev,\r\nstruct sram_channel *ch)\r\n{\r\ncx_write(ch->pix_frmt, PIXEL_FRMT_422);\r\ncx_write(ch->vip_ctl, PIXEL_ENGINE_VIP1);\r\n}\r\nstatic void cx25821_initialize(struct cx25821_dev *dev)\r\n{\r\nint i;\r\ndprintk(1, "%s()\n", __func__);\r\ncx25821_shutdown(dev);\r\ncx_write(PCI_INT_STAT, 0xffffffff);\r\nfor (i = 0; i < VID_CHANNEL_NUM; i++)\r\ncx_write(dev->channels[i].sram_channels->int_stat, 0xffffffff);\r\ncx_write(AUD_A_INT_STAT, 0xffffffff);\r\ncx_write(AUD_B_INT_STAT, 0xffffffff);\r\ncx_write(AUD_C_INT_STAT, 0xffffffff);\r\ncx_write(AUD_D_INT_STAT, 0xffffffff);\r\ncx_write(AUD_E_INT_STAT, 0xffffffff);\r\ncx_write(CLK_DELAY, cx_read(CLK_DELAY) & 0x80000000);\r\ncx_write(PAD_CTRL, 0x12);\r\ncx25821_registers_init(dev);\r\nmdelay(100);\r\nfor (i = 0; i < VID_CHANNEL_NUM; i++) {\r\ncx25821_set_vip_mode(dev, dev->channels[i].sram_channels);\r\ncx25821_sram_channel_setup(dev, dev->channels[i].sram_channels,\r\n1440, 0);\r\ndev->channels[i].pixel_formats = PIXEL_FRMT_422;\r\ndev->channels[i].use_cif_resolution = FALSE;\r\n}\r\nfor (i = VID_UPSTREAM_SRAM_CHANNEL_I;\r\ni <= VID_UPSTREAM_SRAM_CHANNEL_J; i++) {\r\ncx25821_set_vip_mode(dev, dev->channels[i].sram_channels);\r\n}\r\ncx25821_sram_channel_setup_audio(dev,\r\ndev->channels[SRAM_CH08].sram_channels,\r\n128, 0);\r\ncx25821_gpio_init(dev);\r\n}\r\nstatic int cx25821_get_resources(struct cx25821_dev *dev)\r\n{\r\nif (request_mem_region\r\n(pci_resource_start(dev->pci, 0), pci_resource_len(dev->pci, 0),\r\ndev->name))\r\nreturn 0;\r\npr_err("%s: can't get MMIO memory @ 0x%llx\n",\r\ndev->name, (unsigned long long)pci_resource_start(dev->pci, 0));\r\nreturn -EBUSY;\r\n}\r\nstatic void cx25821_dev_checkrevision(struct cx25821_dev *dev)\r\n{\r\ndev->hwrevision = cx_read(RDR_CFG2) & 0xff;\r\npr_info("%s(): Hardware revision = 0x%02x\n",\r\n__func__, dev->hwrevision);\r\n}\r\nstatic void cx25821_iounmap(struct cx25821_dev *dev)\r\n{\r\nif (dev == NULL)\r\nreturn;\r\nif (dev->lmmio != NULL) {\r\nCX25821_INFO("Releasing lmmio.\n");\r\niounmap(dev->lmmio);\r\ndev->lmmio = NULL;\r\n}\r\n}\r\nstatic int cx25821_dev_setup(struct cx25821_dev *dev)\r\n{\r\nint io_size = 0, i;\r\npr_info("\n***********************************\n");\r\npr_info("cx25821 set up\n");\r\npr_info("***********************************\n\n");\r\nmutex_init(&dev->lock);\r\natomic_inc(&dev->refcount);\r\ndev->nr = ++cx25821_devcount;\r\nsprintf(dev->name, "cx25821[%d]", dev->nr);\r\nmutex_lock(&cx25821_devlist_mutex);\r\nlist_add_tail(&dev->devlist, &cx25821_devlist);\r\nmutex_unlock(&cx25821_devlist_mutex);\r\nstrcpy(cx25821_boards[UNKNOWN_BOARD].name, "unknown");\r\nstrcpy(cx25821_boards[CX25821_BOARD].name, "cx25821");\r\nif (dev->pci->device != 0x8210) {\r\npr_info("%s(): Exiting. Incorrect Hardware device = 0x%02x\n",\r\n__func__, dev->pci->device);\r\nreturn -1;\r\n} else {\r\npr_info("Athena Hardware device = 0x%02x\n", dev->pci->device);\r\n}\r\ndev->clk_freq = 28000000;\r\nfor (i = 0; i < MAX_VID_CHANNEL_NUM; i++)\r\ndev->channels[i].sram_channels = &cx25821_sram_channels[i];\r\nif (dev->nr > 1)\r\nCX25821_INFO("dev->nr > 1!");\r\ndev->board = 1;\r\ndev->_max_num_decoders = MAX_DECODERS;\r\ndev->pci_bus = dev->pci->bus->number;\r\ndev->pci_slot = PCI_SLOT(dev->pci->devfn);\r\ndev->pci_irqmask = 0x001f00;\r\ndev->i2c_bus[0].nr = 0;\r\ndev->i2c_bus[0].dev = dev;\r\ndev->i2c_bus[0].reg_stat = I2C1_STAT;\r\ndev->i2c_bus[0].reg_ctrl = I2C1_CTRL;\r\ndev->i2c_bus[0].reg_addr = I2C1_ADDR;\r\ndev->i2c_bus[0].reg_rdata = I2C1_RDATA;\r\ndev->i2c_bus[0].reg_wdata = I2C1_WDATA;\r\ndev->i2c_bus[0].i2c_period = (0x07 << 24);\r\nif (cx25821_get_resources(dev) < 0) {\r\npr_err("%s: No more PCIe resources for subsystem: %04x:%04x\n",\r\ndev->name, dev->pci->subsystem_vendor,\r\ndev->pci->subsystem_device);\r\ncx25821_devcount--;\r\nreturn -EBUSY;\r\n}\r\ndev->base_io_addr = pci_resource_start(dev->pci, 0);\r\nio_size = pci_resource_len(dev->pci, 0);\r\nif (!dev->base_io_addr) {\r\nCX25821_ERR("No PCI Memory resources, exiting!\n");\r\nreturn -ENODEV;\r\n}\r\ndev->lmmio = ioremap(dev->base_io_addr, pci_resource_len(dev->pci, 0));\r\nif (!dev->lmmio) {\r\nCX25821_ERR\r\n("ioremap failed, maybe increasing __VMALLOC_RESERVE in page.h\n");\r\ncx25821_iounmap(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev->bmmio = (u8 __iomem *) dev->lmmio;\r\npr_info("%s: subsystem: %04x:%04x, board: %s [card=%d,%s]\n",\r\ndev->name, dev->pci->subsystem_vendor,\r\ndev->pci->subsystem_device, cx25821_boards[dev->board].name,\r\ndev->board, card[dev->nr] == dev->board ?\r\n"insmod option" : "autodetected");\r\ncx25821_initialize(dev);\r\ncx25821_i2c_register(&dev->i2c_bus[0]);\r\nCX25821_INFO("i2c register! bus->i2c_rc = %d\n",\r\ndev->i2c_bus[0].i2c_rc);\r\ncx25821_card_setup(dev);\r\nif (medusa_video_init(dev) < 0)\r\nCX25821_ERR("%s(): Failed to initialize medusa!\n", __func__);\r\ncx25821_video_register(dev);\r\ndev->ioctl_dev =\r\ncx25821_vdev_init(dev, dev->pci, &cx25821_videoioctl_template,\r\n"video");\r\nif (video_register_device\r\n(dev->ioctl_dev, VFL_TYPE_GRABBER, VIDEO_IOCTL_CH) < 0) {\r\ncx25821_videoioctl_unregister(dev);\r\npr_err("%s(): Failed to register video adapter for IOCTL, so unregistering videoioctl device\n",\r\n__func__);\r\n}\r\ncx25821_dev_checkrevision(dev);\r\nCX25821_INFO("setup done!\n");\r\nreturn 0;\r\n}\r\nvoid cx25821_start_upstream_video_ch1(struct cx25821_dev *dev,\r\nstruct upstream_user_struct *up_data)\r\n{\r\ndev->_isNTSC = !strcmp(dev->vid_stdname, "NTSC") ? 1 : 0;\r\ndev->tvnorm = !dev->_isNTSC ? V4L2_STD_PAL_BG : V4L2_STD_NTSC_M;\r\nmedusa_set_videostandard(dev);\r\ncx25821_vidupstream_init_ch1(dev, dev->channel_select,\r\ndev->pixel_format);\r\n}\r\nvoid cx25821_start_upstream_video_ch2(struct cx25821_dev *dev,\r\nstruct upstream_user_struct *up_data)\r\n{\r\ndev->_isNTSC_ch2 = !strcmp(dev->vid_stdname_ch2, "NTSC") ? 1 : 0;\r\ndev->tvnorm = !dev->_isNTSC_ch2 ? V4L2_STD_PAL_BG : V4L2_STD_NTSC_M;\r\nmedusa_set_videostandard(dev);\r\ncx25821_vidupstream_init_ch2(dev, dev->channel_select_ch2,\r\ndev->pixel_format_ch2);\r\n}\r\nvoid cx25821_start_upstream_audio(struct cx25821_dev *dev,\r\nstruct upstream_user_struct *up_data)\r\n{\r\ncx25821_audio_upstream_init(dev, AUDIO_UPSTREAM_SRAM_CHANNEL_B);\r\n}\r\nvoid cx25821_dev_unregister(struct cx25821_dev *dev)\r\n{\r\nint i;\r\nif (!dev->base_io_addr)\r\nreturn;\r\ncx25821_free_mem_upstream_ch1(dev);\r\ncx25821_free_mem_upstream_ch2(dev);\r\ncx25821_free_mem_upstream_audio(dev);\r\nrelease_mem_region(dev->base_io_addr, pci_resource_len(dev->pci, 0));\r\nif (!atomic_dec_and_test(&dev->refcount))\r\nreturn;\r\nfor (i = 0; i < VID_CHANNEL_NUM; i++)\r\ncx25821_video_unregister(dev, i);\r\nfor (i = VID_UPSTREAM_SRAM_CHANNEL_I;\r\ni <= AUDIO_UPSTREAM_SRAM_CHANNEL_B; i++) {\r\ncx25821_video_unregister(dev, i);\r\n}\r\ncx25821_videoioctl_unregister(dev);\r\ncx25821_i2c_unregister(&dev->i2c_bus[0]);\r\ncx25821_iounmap(dev);\r\n}\r\nstatic __le32 *cx25821_risc_field(__le32 * rp, struct scatterlist *sglist,\r\nunsigned int offset, u32 sync_line,\r\nunsigned int bpl, unsigned int padding,\r\nunsigned int lines)\r\n{\r\nstruct scatterlist *sg;\r\nunsigned int line, todo;\r\nif (sync_line != NO_SYNC_LINE)\r\n*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);\r\nsg = sglist;\r\nfor (line = 0; line < lines; line++) {\r\nwhile (offset && offset >= sg_dma_len(sg)) {\r\noffset -= sg_dma_len(sg);\r\nsg++;\r\n}\r\nif (bpl <= sg_dma_len(sg) - offset) {\r\n*(rp++) =\r\ncpu_to_le32(RISC_WRITE | RISC_SOL | RISC_EOL | bpl);\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\r\n*(rp++) = cpu_to_le32(0);\r\noffset += bpl;\r\n} else {\r\ntodo = bpl;\r\n*(rp++) =\r\ncpu_to_le32(RISC_WRITE | RISC_SOL |\r\n(sg_dma_len(sg) - offset));\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\r\n*(rp++) = cpu_to_le32(0);\r\ntodo -= (sg_dma_len(sg) - offset);\r\noffset = 0;\r\nsg++;\r\nwhile (todo > sg_dma_len(sg)) {\r\n*(rp++) =\r\ncpu_to_le32(RISC_WRITE | sg_dma_len(sg));\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg));\r\n*(rp++) = cpu_to_le32(0);\r\ntodo -= sg_dma_len(sg);\r\nsg++;\r\n}\r\n*(rp++) = cpu_to_le32(RISC_WRITE | RISC_EOL | todo);\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg));\r\n*(rp++) = cpu_to_le32(0);\r\noffset += todo;\r\n}\r\noffset += padding;\r\n}\r\nreturn rp;\r\n}\r\nint cx25821_risc_buffer(struct pci_dev *pci, struct btcx_riscmem *risc,\r\nstruct scatterlist *sglist, unsigned int top_offset,\r\nunsigned int bottom_offset, unsigned int bpl,\r\nunsigned int padding, unsigned int lines)\r\n{\r\nu32 instructions;\r\nu32 fields;\r\n__le32 *rp;\r\nint rc;\r\nfields = 0;\r\nif (UNSET != top_offset)\r\nfields++;\r\nif (UNSET != bottom_offset)\r\nfields++;\r\ninstructions =\r\nfields * (1 + ((bpl + padding) * lines) / PAGE_SIZE + lines);\r\ninstructions += 2;\r\nrc = btcx_riscmem_alloc(pci, risc, instructions * 12);\r\nif (rc < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\nif (UNSET != top_offset) {\r\nrp = cx25821_risc_field(rp, sglist, top_offset, 0, bpl, padding,\r\nlines);\r\n}\r\nif (UNSET != bottom_offset) {\r\nrp = cx25821_risc_field(rp, sglist, bottom_offset, 0x200, bpl,\r\npadding, lines);\r\n}\r\nrisc->jmp = rp;\r\nBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nstatic __le32 *cx25821_risc_field_audio(__le32 * rp, struct scatterlist *sglist,\r\nunsigned int offset, u32 sync_line,\r\nunsigned int bpl, unsigned int padding,\r\nunsigned int lines, unsigned int lpi)\r\n{\r\nstruct scatterlist *sg;\r\nunsigned int line, todo, sol;\r\nif (sync_line != NO_SYNC_LINE)\r\n*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);\r\nsg = sglist;\r\nfor (line = 0; line < lines; line++) {\r\nwhile (offset && offset >= sg_dma_len(sg)) {\r\noffset -= sg_dma_len(sg);\r\nsg++;\r\n}\r\nif (lpi && line > 0 && !(line % lpi))\r\nsol = RISC_SOL | RISC_IRQ1 | RISC_CNT_INC;\r\nelse\r\nsol = RISC_SOL;\r\nif (bpl <= sg_dma_len(sg) - offset) {\r\n*(rp++) =\r\ncpu_to_le32(RISC_WRITE | sol | RISC_EOL | bpl);\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\r\n*(rp++) = cpu_to_le32(0);\r\noffset += bpl;\r\n} else {\r\ntodo = bpl;\r\n*(rp++) = cpu_to_le32(RISC_WRITE | sol |\r\n(sg_dma_len(sg) - offset));\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\r\n*(rp++) = cpu_to_le32(0);\r\ntodo -= (sg_dma_len(sg) - offset);\r\noffset = 0;\r\nsg++;\r\nwhile (todo > sg_dma_len(sg)) {\r\n*(rp++) = cpu_to_le32(RISC_WRITE |\r\nsg_dma_len(sg));\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg));\r\n*(rp++) = cpu_to_le32(0);\r\ntodo -= sg_dma_len(sg);\r\nsg++;\r\n}\r\n*(rp++) = cpu_to_le32(RISC_WRITE | RISC_EOL | todo);\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg));\r\n*(rp++) = cpu_to_le32(0);\r\noffset += todo;\r\n}\r\noffset += padding;\r\n}\r\nreturn rp;\r\n}\r\nint cx25821_risc_databuffer_audio(struct pci_dev *pci,\r\nstruct btcx_riscmem *risc,\r\nstruct scatterlist *sglist,\r\nunsigned int bpl,\r\nunsigned int lines, unsigned int lpi)\r\n{\r\nu32 instructions;\r\n__le32 *rp;\r\nint rc;\r\ninstructions = 1 + (bpl * lines) / PAGE_SIZE + lines;\r\ninstructions += 1;\r\nrc = btcx_riscmem_alloc(pci, risc, instructions * 12);\r\nif (rc < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\nrp = cx25821_risc_field_audio(rp, sglist, 0, NO_SYNC_LINE, bpl, 0,\r\nlines, lpi);\r\nrisc->jmp = rp;\r\nBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nint cx25821_risc_stopper(struct pci_dev *pci, struct btcx_riscmem *risc,\r\nu32 reg, u32 mask, u32 value)\r\n{\r\n__le32 *rp;\r\nint rc;\r\nrc = btcx_riscmem_alloc(pci, risc, 4 * 16);\r\nif (rc < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\n*(rp++) = cpu_to_le32(RISC_WRITECR | RISC_IRQ1);\r\n*(rp++) = cpu_to_le32(reg);\r\n*(rp++) = cpu_to_le32(value);\r\n*(rp++) = cpu_to_le32(mask);\r\n*(rp++) = cpu_to_le32(RISC_JUMP);\r\n*(rp++) = cpu_to_le32(risc->dma);\r\n*(rp++) = cpu_to_le32(0);\r\nreturn 0;\r\n}\r\nvoid cx25821_free_buffer(struct videobuf_queue *q, struct cx25821_buffer *buf)\r\n{\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);\r\nBUG_ON(in_interrupt());\r\nvideobuf_waiton(q, &buf->vb, 0, 0);\r\nvideobuf_dma_unmap(q->dev, dma);\r\nvideobuf_dma_free(dma);\r\nbtcx_riscmem_free(to_pci_dev(q->dev), &buf->risc);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic irqreturn_t cx25821_irq(int irq, void *dev_id)\r\n{\r\nstruct cx25821_dev *dev = dev_id;\r\nu32 pci_status, pci_mask;\r\nu32 vid_status;\r\nint i, handled = 0;\r\nu32 mask[8] = { 1, 2, 4, 8, 16, 32, 64, 128 };\r\npci_status = cx_read(PCI_INT_STAT);\r\npci_mask = cx_read(PCI_INT_MSK);\r\nif (pci_status == 0)\r\ngoto out;\r\nfor (i = 0; i < VID_CHANNEL_NUM; i++) {\r\nif (pci_status & mask[i]) {\r\nvid_status = cx_read(dev->channels[i].\r\nsram_channels->int_stat);\r\nif (vid_status)\r\nhandled +=\r\ncx25821_video_irq(dev, i, vid_status);\r\ncx_write(PCI_INT_STAT, mask[i]);\r\n}\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nvoid cx25821_print_irqbits(char *name, char *tag, char **strings,\r\nint len, u32 bits, u32 mask)\r\n{\r\nunsigned int i;\r\nprintk(KERN_DEBUG pr_fmt("%s: %s [0x%x]"), name, tag, bits);\r\nfor (i = 0; i < len; i++) {\r\nif (!(bits & (1 << i)))\r\ncontinue;\r\nif (strings[i])\r\npr_cont(" %s", strings[i]);\r\nelse\r\npr_cont(" %d", i);\r\nif (!(mask & (1 << i)))\r\ncontinue;\r\npr_cont("*");\r\n}\r\npr_cont("\n");\r\n}\r\nstruct cx25821_dev *cx25821_dev_get(struct pci_dev *pci)\r\n{\r\nstruct cx25821_dev *dev = pci_get_drvdata(pci);\r\nreturn dev;\r\n}\r\nstatic int __devinit cx25821_initdev(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct cx25821_dev *dev;\r\nint err = 0;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (NULL == dev)\r\nreturn -ENOMEM;\r\nerr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\r\nif (err < 0)\r\ngoto fail_free;\r\ndev->pci = pci_dev;\r\nif (pci_enable_device(pci_dev)) {\r\nerr = -EIO;\r\npr_info("pci enable failed!\n");\r\ngoto fail_unregister_device;\r\n}\r\npr_info("Athena pci enable !\n");\r\nerr = cx25821_dev_setup(dev);\r\nif (err) {\r\nif (err == -EBUSY)\r\ngoto fail_unregister_device;\r\nelse\r\ngoto fail_unregister_pci;\r\n}\r\npci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &dev->pci_rev);\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &dev->pci_lat);\r\npr_info("%s/0: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\n",\r\ndev->name, pci_name(pci_dev), dev->pci_rev, pci_dev->irq,\r\ndev->pci_lat, (unsigned long long)dev->base_io_addr);\r\npci_set_master(pci_dev);\r\nif (!pci_dma_supported(pci_dev, 0xffffffff)) {\r\npr_err("%s/0: Oops: no 32bit PCI DMA ???\n", dev->name);\r\nerr = -EIO;\r\ngoto fail_irq;\r\n}\r\nerr =\r\nrequest_irq(pci_dev->irq, cx25821_irq, IRQF_SHARED | IRQF_DISABLED,\r\ndev->name, dev);\r\nif (err < 0) {\r\npr_err("%s: can't get IRQ %d\n", dev->name, pci_dev->irq);\r\ngoto fail_irq;\r\n}\r\nreturn 0;\r\nfail_irq:\r\npr_info("cx25821_initdev() can't get IRQ !\n");\r\ncx25821_dev_unregister(dev);\r\nfail_unregister_pci:\r\npci_disable_device(pci_dev);\r\nfail_unregister_device:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nfail_free:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void __devexit cx25821_finidev(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct cx25821_dev *dev = get_cx25821(v4l2_dev);\r\ncx25821_shutdown(dev);\r\npci_disable_device(pci_dev);\r\nif (pci_dev->irq)\r\nfree_irq(pci_dev->irq, dev);\r\nmutex_lock(&cx25821_devlist_mutex);\r\nlist_del(&dev->devlist);\r\nmutex_unlock(&cx25821_devlist_mutex);\r\ncx25821_dev_unregister(dev);\r\nv4l2_device_unregister(v4l2_dev);\r\nkfree(dev);\r\n}\r\nstatic int __init cx25821_init(void)\r\n{\r\npr_info("driver version %d.%d.%d loaded\n",\r\n(CX25821_VERSION_CODE >> 16) & 0xff,\r\n(CX25821_VERSION_CODE >> 8) & 0xff,\r\nCX25821_VERSION_CODE & 0xff);\r\nreturn pci_register_driver(&cx25821_pci_driver);\r\n}\r\nstatic void __exit cx25821_fini(void)\r\n{\r\npci_unregister_driver(&cx25821_pci_driver);\r\n}
