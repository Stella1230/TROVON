int of_getintprop_default(struct device_node *np, const char *name, int def)\r\n{\r\nstruct property *prop;\r\nint len;\r\nprop = of_find_property(np, name, &len);\r\nif (!prop || len != 4)\r\nreturn def;\r\nreturn *(int *) prop->value;\r\n}\r\nint of_set_property(struct device_node *dp, const char *name, void *val, int len)\r\n{\r\nstruct property **prevp;\r\nvoid *new_val;\r\nint err;\r\nnew_val = kmalloc(len, GFP_KERNEL);\r\nif (!new_val)\r\nreturn -ENOMEM;\r\nmemcpy(new_val, val, len);\r\nerr = -ENODEV;\r\nmutex_lock(&of_set_property_mutex);\r\nwrite_lock(&devtree_lock);\r\nprevp = &dp->properties;\r\nwhile (*prevp) {\r\nstruct property *prop = *prevp;\r\nif (!strcasecmp(prop->name, name)) {\r\nvoid *old_val = prop->value;\r\nint ret;\r\nret = prom_setprop(dp->phandle, name, val, len);\r\nerr = -EINVAL;\r\nif (ret >= 0) {\r\nprop->value = new_val;\r\nprop->length = len;\r\nif (OF_IS_DYNAMIC(prop))\r\nkfree(old_val);\r\nOF_MARK_DYNAMIC(prop);\r\nerr = 0;\r\n}\r\nbreak;\r\n}\r\nprevp = &(*prevp)->next;\r\n}\r\nwrite_unlock(&devtree_lock);\r\nmutex_unlock(&of_set_property_mutex);\r\nreturn err;\r\n}\r\nint of_find_in_proplist(const char *list, const char *match, int len)\r\n{\r\nwhile (len > 0) {\r\nint l;\r\nif (!strcmp(list, match))\r\nreturn 1;\r\nl = strlen(list) + 1;\r\nlist += l;\r\nlen -= l;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init handle_nextprop_quirks(char *buf, const char *name)\r\n{\r\nif (!name || strlen(name) == 0)\r\nreturn -1;\r\n#ifdef CONFIG_SPARC32\r\nstrcpy(buf, name);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init prom_common_nextprop(phandle node, char *prev, char *buf)\r\n{\r\nconst char *name;\r\nbuf[0] = '\0';\r\nname = prom_nextprop(node, prev, buf);\r\nreturn handle_nextprop_quirks(buf, name);\r\n}\r\nvoid __init prom_build_devicetree(void)\r\n{\r\nof_pdt_build_devicetree(prom_root_node, &prom_sparc_ops);\r\nof_console_init();\r\npr_info("PROM: Built device tree with %u bytes of memory.\n",\r\nprom_early_allocated);\r\n}
