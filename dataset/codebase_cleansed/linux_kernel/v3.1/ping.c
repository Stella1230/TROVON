static inline int ping_hashfn(struct net *net, unsigned num, unsigned mask)\r\n{\r\nint res = (num + net_hash_mix(net)) & mask;\r\npr_debug("hash(%d) = %d\n", num, res);\r\nreturn res;\r\n}\r\nstatic inline struct hlist_nulls_head *ping_hashslot(struct ping_table *table,\r\nstruct net *net, unsigned num)\r\n{\r\nreturn &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];\r\n}\r\nstatic int ping_v4_get_port(struct sock *sk, unsigned short ident)\r\n{\r\nstruct hlist_nulls_node *node;\r\nstruct hlist_nulls_head *hlist;\r\nstruct inet_sock *isk, *isk2;\r\nstruct sock *sk2 = NULL;\r\nisk = inet_sk(sk);\r\nwrite_lock_bh(&ping_table.lock);\r\nif (ident == 0) {\r\nu32 i;\r\nu16 result = ping_port_rover + 1;\r\nfor (i = 0; i < (1L << 16); i++, result++) {\r\nif (!result)\r\nresult++;\r\nhlist = ping_hashslot(&ping_table, sock_net(sk),\r\nresult);\r\nping_portaddr_for_each_entry(sk2, node, hlist) {\r\nisk2 = inet_sk(sk2);\r\nif (isk2->inet_num == result)\r\ngoto next_port;\r\n}\r\nping_port_rover = ident = result;\r\nbreak;\r\nnext_port:\r\n;\r\n}\r\nif (i >= (1L << 16))\r\ngoto fail;\r\n} else {\r\nhlist = ping_hashslot(&ping_table, sock_net(sk), ident);\r\nping_portaddr_for_each_entry(sk2, node, hlist) {\r\nisk2 = inet_sk(sk2);\r\nif ((isk2->inet_num == ident) &&\r\n(sk2 != sk) &&\r\n(!sk2->sk_reuse || !sk->sk_reuse))\r\ngoto fail;\r\n}\r\n}\r\npr_debug("found port/ident = %d\n", ident);\r\nisk->inet_num = ident;\r\nif (sk_unhashed(sk)) {\r\npr_debug("was not hashed\n");\r\nsock_hold(sk);\r\nhlist_nulls_add_head(&sk->sk_nulls_node, hlist);\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\n}\r\nwrite_unlock_bh(&ping_table.lock);\r\nreturn 0;\r\nfail:\r\nwrite_unlock_bh(&ping_table.lock);\r\nreturn 1;\r\n}\r\nstatic void ping_v4_hash(struct sock *sk)\r\n{\r\npr_debug("ping_v4_hash(sk->port=%u)\n", inet_sk(sk)->inet_num);\r\nBUG();\r\n}\r\nstatic void ping_v4_unhash(struct sock *sk)\r\n{\r\nstruct inet_sock *isk = inet_sk(sk);\r\npr_debug("ping_v4_unhash(isk=%p,isk->num=%u)\n", isk, isk->inet_num);\r\nif (sk_hashed(sk)) {\r\nwrite_lock_bh(&ping_table.lock);\r\nhlist_nulls_del(&sk->sk_nulls_node);\r\nsock_put(sk);\r\nisk->inet_num = isk->inet_sport = 0;\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\r\nwrite_unlock_bh(&ping_table.lock);\r\n}\r\n}\r\nstatic struct sock *ping_v4_lookup(struct net *net, u32 saddr, u32 daddr,\r\nu16 ident, int dif)\r\n{\r\nstruct hlist_nulls_head *hslot = ping_hashslot(&ping_table, net, ident);\r\nstruct sock *sk = NULL;\r\nstruct inet_sock *isk;\r\nstruct hlist_nulls_node *hnode;\r\npr_debug("try to find: num = %d, daddr = %ld, dif = %d\n",\r\n(int)ident, (unsigned long)daddr, dif);\r\nread_lock_bh(&ping_table.lock);\r\nping_portaddr_for_each_entry(sk, hnode, hslot) {\r\nisk = inet_sk(sk);\r\npr_debug("found: %p: num = %d, daddr = %ld, dif = %d\n", sk,\r\n(int)isk->inet_num, (unsigned long)isk->inet_rcv_saddr,\r\nsk->sk_bound_dev_if);\r\npr_debug("iterate\n");\r\nif (isk->inet_num != ident)\r\ncontinue;\r\nif (isk->inet_rcv_saddr && isk->inet_rcv_saddr != daddr)\r\ncontinue;\r\nif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)\r\ncontinue;\r\nsock_hold(sk);\r\ngoto exit;\r\n}\r\nsk = NULL;\r\nexit:\r\nread_unlock_bh(&ping_table.lock);\r\nreturn sk;\r\n}\r\nstatic void inet_get_ping_group_range_net(struct net *net, gid_t *low,\r\ngid_t *high)\r\n{\r\ngid_t *data = net->ipv4.sysctl_ping_group_range;\r\nunsigned seq;\r\ndo {\r\nseq = read_seqbegin(&sysctl_local_ports.lock);\r\n*low = data[0];\r\n*high = data[1];\r\n} while (read_seqretry(&sysctl_local_ports.lock, seq));\r\n}\r\nstatic int ping_init_sock(struct sock *sk)\r\n{\r\nstruct net *net = sock_net(sk);\r\ngid_t group = current_egid();\r\ngid_t range[2];\r\nstruct group_info *group_info = get_current_groups();\r\nint i, j, count = group_info->ngroups;\r\ninet_get_ping_group_range_net(net, range, range+1);\r\nif (range[0] <= group && group <= range[1])\r\nreturn 0;\r\nfor (i = 0; i < group_info->nblocks; i++) {\r\nint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\r\nfor (j = 0; j < cp_count; j++) {\r\ngroup = group_info->blocks[i][j];\r\nif (range[0] <= group && group <= range[1])\r\nreturn 0;\r\n}\r\ncount -= cp_count;\r\n}\r\nreturn -EACCES;\r\n}\r\nstatic void ping_close(struct sock *sk, long timeout)\r\n{\r\npr_debug("ping_close(sk=%p,sk->num=%u)\n",\r\ninet_sk(sk), inet_sk(sk)->inet_num);\r\npr_debug("isk->refcnt = %d\n", sk->sk_refcnt.counter);\r\nsk_common_release(sk);\r\n}\r\nstatic int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sockaddr_in *addr = (struct sockaddr_in *)uaddr;\r\nstruct inet_sock *isk = inet_sk(sk);\r\nunsigned short snum;\r\nint chk_addr_ret;\r\nint err;\r\nif (addr_len < sizeof(struct sockaddr_in))\r\nreturn -EINVAL;\r\npr_debug("ping_v4_bind(sk=%p,sa_addr=%08x,sa_port=%d)\n",\r\nsk, addr->sin_addr.s_addr, ntohs(addr->sin_port));\r\nchk_addr_ret = inet_addr_type(sock_net(sk), addr->sin_addr.s_addr);\r\nif (addr->sin_addr.s_addr == INADDR_ANY)\r\nchk_addr_ret = RTN_LOCAL;\r\nif ((sysctl_ip_nonlocal_bind == 0 &&\r\nisk->freebind == 0 && isk->transparent == 0 &&\r\nchk_addr_ret != RTN_LOCAL) ||\r\nchk_addr_ret == RTN_MULTICAST ||\r\nchk_addr_ret == RTN_BROADCAST)\r\nreturn -EADDRNOTAVAIL;\r\nlock_sock(sk);\r\nerr = -EINVAL;\r\nif (isk->inet_num != 0)\r\ngoto out;\r\nerr = -EADDRINUSE;\r\nisk->inet_rcv_saddr = isk->inet_saddr = addr->sin_addr.s_addr;\r\nsnum = ntohs(addr->sin_port);\r\nif (ping_v4_get_port(sk, snum) != 0) {\r\nisk->inet_saddr = isk->inet_rcv_saddr = 0;\r\ngoto out;\r\n}\r\npr_debug("after bind(): num = %d, daddr = %ld, dif = %d\n",\r\n(int)isk->inet_num,\r\n(unsigned long) isk->inet_rcv_saddr,\r\n(int)sk->sk_bound_dev_if);\r\nerr = 0;\r\nif (isk->inet_rcv_saddr)\r\nsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\r\nif (snum)\r\nsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\r\nisk->inet_sport = htons(isk->inet_num);\r\nisk->inet_daddr = 0;\r\nisk->inet_dport = 0;\r\nsk_dst_reset(sk);\r\nout:\r\nrelease_sock(sk);\r\npr_debug("ping_v4_bind -> %d\n", err);\r\nreturn err;\r\n}\r\nstatic inline int ping_supported(int type, int code)\r\n{\r\nif (type == ICMP_ECHO && code == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid ping_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct iphdr *iph = (struct iphdr *)skb->data;\r\nstruct icmphdr *icmph = (struct icmphdr *)(skb->data+(iph->ihl<<2));\r\nstruct inet_sock *inet_sock;\r\nint type = icmph->type;\r\nint code = icmph->code;\r\nstruct net *net = dev_net(skb->dev);\r\nstruct sock *sk;\r\nint harderr;\r\nint err;\r\nif (!ping_supported(icmph->type, icmph->code))\r\nreturn;\r\npr_debug("ping_err(type=%04x,code=%04x,id=%04x,seq=%04x)\n", type,\r\ncode, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\r\nsk = ping_v4_lookup(net, iph->daddr, iph->saddr,\r\nntohs(icmph->un.echo.id), skb->dev->ifindex);\r\nif (sk == NULL) {\r\nICMP_INC_STATS_BH(net, ICMP_MIB_INERRORS);\r\npr_debug("no socket, dropping\n");\r\nreturn;\r\n}\r\npr_debug("err on socket %p\n", sk);\r\nerr = 0;\r\nharderr = 0;\r\ninet_sock = inet_sk(sk);\r\nswitch (type) {\r\ndefault:\r\ncase ICMP_TIME_EXCEEDED:\r\nerr = EHOSTUNREACH;\r\nbreak;\r\ncase ICMP_SOURCE_QUENCH:\r\nerr = EREMOTEIO;\r\nbreak;\r\ncase ICMP_PARAMETERPROB:\r\nerr = EPROTO;\r\nharderr = 1;\r\nbreak;\r\ncase ICMP_DEST_UNREACH:\r\nif (code == ICMP_FRAG_NEEDED) {\r\nif (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {\r\nerr = EMSGSIZE;\r\nharderr = 1;\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nerr = EHOSTUNREACH;\r\nif (code <= NR_ICMP_UNREACH) {\r\nharderr = icmp_err_convert[code].fatal;\r\nerr = icmp_err_convert[code].errno;\r\n}\r\nbreak;\r\ncase ICMP_REDIRECT:\r\nerr = EREMOTEIO;\r\nbreak;\r\n}\r\nif (!inet_sock->recverr) {\r\nif (!harderr || sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\n} else {\r\nip_icmp_error(sk, skb, err, 0 ,\r\ninfo, (u8 *)icmph);\r\n}\r\nsk->sk_err = err;\r\nsk->sk_error_report(sk);\r\nout:\r\nsock_put(sk);\r\n}\r\nstatic int ping_getfrag(void *from, char * to,\r\nint offset, int fraglen, int odd, struct sk_buff *skb)\r\n{\r\nstruct pingfakehdr *pfh = (struct pingfakehdr *)from;\r\nif (offset == 0) {\r\nif (fraglen < sizeof(struct icmphdr))\r\nBUG();\r\nif (csum_partial_copy_fromiovecend(to + sizeof(struct icmphdr),\r\npfh->iov, 0, fraglen - sizeof(struct icmphdr),\r\n&pfh->wcheck))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (offset < sizeof(struct icmphdr))\r\nBUG();\r\nif (csum_partial_copy_fromiovecend\r\n(to, pfh->iov, offset - sizeof(struct icmphdr),\r\nfraglen, &pfh->wcheck))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ping_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,\r\nstruct flowi4 *fl4)\r\n{\r\nstruct sk_buff *skb = skb_peek(&sk->sk_write_queue);\r\npfh->wcheck = csum_partial((char *)&pfh->icmph,\r\nsizeof(struct icmphdr), pfh->wcheck);\r\npfh->icmph.checksum = csum_fold(pfh->wcheck);\r\nmemcpy(icmp_hdr(skb), &pfh->icmph, sizeof(struct icmphdr));\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn ip_push_pending_frames(sk, fl4);\r\n}\r\nstatic int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct flowi4 fl4;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipcm_cookie ipc;\r\nstruct icmphdr user_icmph;\r\nstruct pingfakehdr pfh;\r\nstruct rtable *rt = NULL;\r\nstruct ip_options_data opt_copy;\r\nint free = 0;\r\nu32 saddr, daddr, faddr;\r\nu8 tos;\r\nint err;\r\npr_debug("ping_sendmsg(sk=%p,sk->num=%u)\n", inet, inet->inet_num);\r\nif (len > 0xFFFF)\r\nreturn -EMSGSIZE;\r\nif (msg->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nif (memcpy_fromiovec((u8 *)&user_icmph, msg->msg_iov,\r\nsizeof(struct icmphdr)))\r\nreturn -EFAULT;\r\nif (!ping_supported(user_icmph.type, user_icmph.code))\r\nreturn -EINVAL;\r\nif (msg->msg_name) {\r\nstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;\r\nif (msg->msg_namelen < sizeof(*usin))\r\nreturn -EINVAL;\r\nif (usin->sin_family != AF_INET)\r\nreturn -EINVAL;\r\ndaddr = usin->sin_addr.s_addr;\r\n} else {\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -EDESTADDRREQ;\r\ndaddr = inet->inet_daddr;\r\n}\r\nipc.addr = inet->inet_saddr;\r\nipc.opt = NULL;\r\nipc.oif = sk->sk_bound_dev_if;\r\nipc.tx_flags = 0;\r\nerr = sock_tx_timestamp(sk, &ipc.tx_flags);\r\nif (err)\r\nreturn err;\r\nif (msg->msg_controllen) {\r\nerr = ip_cmsg_send(sock_net(sk), msg, &ipc);\r\nif (err)\r\nreturn err;\r\nif (ipc.opt)\r\nfree = 1;\r\n}\r\nif (!ipc.opt) {\r\nstruct ip_options_rcu *inet_opt;\r\nrcu_read_lock();\r\ninet_opt = rcu_dereference(inet->inet_opt);\r\nif (inet_opt) {\r\nmemcpy(&opt_copy, inet_opt,\r\nsizeof(*inet_opt) + inet_opt->opt.optlen);\r\nipc.opt = &opt_copy.opt;\r\n}\r\nrcu_read_unlock();\r\n}\r\nsaddr = ipc.addr;\r\nipc.addr = faddr = daddr;\r\nif (ipc.opt && ipc.opt->opt.srr) {\r\nif (!daddr)\r\nreturn -EINVAL;\r\nfaddr = ipc.opt->opt.faddr;\r\n}\r\ntos = RT_TOS(inet->tos);\r\nif (sock_flag(sk, SOCK_LOCALROUTE) ||\r\n(msg->msg_flags & MSG_DONTROUTE) ||\r\n(ipc.opt && ipc.opt->opt.is_strictroute)) {\r\ntos |= RTO_ONLINK;\r\n}\r\nif (ipv4_is_multicast(daddr)) {\r\nif (!ipc.oif)\r\nipc.oif = inet->mc_index;\r\nif (!saddr)\r\nsaddr = inet->mc_addr;\r\n}\r\nflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\r\nRT_SCOPE_UNIVERSE, sk->sk_protocol,\r\ninet_sk_flowi_flags(sk), faddr, saddr, 0, 0);\r\nsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\r\nrt = ip_route_output_flow(net, &fl4, sk);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\nrt = NULL;\r\nif (err == -ENETUNREACH)\r\nIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\r\ngoto out;\r\n}\r\nerr = -EACCES;\r\nif ((rt->rt_flags & RTCF_BROADCAST) &&\r\n!sock_flag(sk, SOCK_BROADCAST))\r\ngoto out;\r\nif (msg->msg_flags & MSG_CONFIRM)\r\ngoto do_confirm;\r\nback_from_confirm:\r\nif (!ipc.addr)\r\nipc.addr = fl4.daddr;\r\nlock_sock(sk);\r\npfh.icmph.type = user_icmph.type;\r\npfh.icmph.code = user_icmph.code;\r\npfh.icmph.checksum = 0;\r\npfh.icmph.un.echo.id = inet->inet_sport;\r\npfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;\r\npfh.iov = msg->msg_iov;\r\npfh.wcheck = 0;\r\nerr = ip_append_data(sk, &fl4, ping_getfrag, &pfh, len,\r\n0, &ipc, &rt, msg->msg_flags);\r\nif (err)\r\nip_flush_pending_frames(sk);\r\nelse\r\nerr = ping_push_pending_frames(sk, &pfh, &fl4);\r\nrelease_sock(sk);\r\nout:\r\nip_rt_put(rt);\r\nif (free)\r\nkfree(ipc.opt);\r\nif (!err) {\r\nicmp_out_count(sock_net(sk), user_icmph.type);\r\nreturn len;\r\n}\r\nreturn err;\r\ndo_confirm:\r\ndst_confirm(&rt->dst);\r\nif (!(msg->msg_flags & MSG_PROBE) || len)\r\ngoto back_from_confirm;\r\nerr = 0;\r\ngoto out;\r\n}\r\nstatic int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\r\nsize_t len, int noblock, int flags, int *addr_len)\r\n{\r\nstruct inet_sock *isk = inet_sk(sk);\r\nstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\r\nstruct sk_buff *skb;\r\nint copied, err;\r\npr_debug("ping_recvmsg(sk=%p,sk->num=%u)\n", isk, isk->inet_num);\r\nif (flags & MSG_OOB)\r\ngoto out;\r\nif (addr_len)\r\n*addr_len = sizeof(*sin);\r\nif (flags & MSG_ERRQUEUE)\r\nreturn ip_recv_error(sk, msg, len);\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (copied > len) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (err)\r\ngoto done;\r\nsock_recv_timestamp(msg, sk, skb);\r\nif (sin) {\r\nsin->sin_family = AF_INET;\r\nsin->sin_port = 0 ;\r\nsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\r\nmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\r\n}\r\nif (isk->cmsg_flags)\r\nip_cmsg_recv(msg, skb);\r\nerr = copied;\r\ndone:\r\nskb_free_datagram(sk, skb);\r\nout:\r\npr_debug("ping_recvmsg -> %d\n", err);\r\nreturn err;\r\n}\r\nstatic int ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\r\n{\r\npr_debug("ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\n",\r\ninet_sk(sk), inet_sk(sk)->inet_num, skb);\r\nif (sock_queue_rcv_skb(sk, skb) < 0) {\r\nICMP_INC_STATS_BH(sock_net(sk), ICMP_MIB_INERRORS);\r\nkfree_skb(skb);\r\npr_debug("ping_queue_rcv_skb -> failed\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid ping_rcv(struct sk_buff *skb)\r\n{\r\nstruct sock *sk;\r\nstruct net *net = dev_net(skb->dev);\r\nstruct iphdr *iph = ip_hdr(skb);\r\nstruct icmphdr *icmph = icmp_hdr(skb);\r\nu32 saddr = iph->saddr;\r\nu32 daddr = iph->daddr;\r\npr_debug("ping_rcv(skb=%p,id=%04x,seq=%04x)\n",\r\nskb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\r\nskb_push(skb, skb->data - (u8 *)icmph);\r\nsk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),\r\nskb->dev->ifindex);\r\nif (sk != NULL) {\r\npr_debug("rcv on socket %p\n", sk);\r\nping_queue_rcv_skb(sk, skb_get(skb));\r\nsock_put(sk);\r\nreturn;\r\n}\r\npr_debug("no socket, dropping\n");\r\n}\r\nstatic struct sock *ping_get_first(struct seq_file *seq, int start)\r\n{\r\nstruct sock *sk;\r\nstruct ping_iter_state *state = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nfor (state->bucket = start; state->bucket < PING_HTABLE_SIZE;\r\n++state->bucket) {\r\nstruct hlist_nulls_node *node;\r\nstruct hlist_nulls_head *hslot;\r\nhslot = &ping_table.hash[state->bucket];\r\nif (hlist_nulls_empty(hslot))\r\ncontinue;\r\nsk_nulls_for_each(sk, node, hslot) {\r\nif (net_eq(sock_net(sk), net))\r\ngoto found;\r\n}\r\n}\r\nsk = NULL;\r\nfound:\r\nreturn sk;\r\n}\r\nstatic struct sock *ping_get_next(struct seq_file *seq, struct sock *sk)\r\n{\r\nstruct ping_iter_state *state = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\ndo {\r\nsk = sk_nulls_next(sk);\r\n} while (sk && (!net_eq(sock_net(sk), net)));\r\nif (!sk)\r\nreturn ping_get_first(seq, state->bucket + 1);\r\nreturn sk;\r\n}\r\nstatic struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct sock *sk = ping_get_first(seq, 0);\r\nif (sk)\r\nwhile (pos && (sk = ping_get_next(seq, sk)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : sk;\r\n}\r\nstatic void *ping_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct ping_iter_state *state = seq->private;\r\nstate->bucket = 0;\r\nread_lock_bh(&ping_table.lock);\r\nreturn *pos ? ping_get_idx(seq, *pos-1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *ping_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct sock *sk;\r\nif (v == SEQ_START_TOKEN)\r\nsk = ping_get_idx(seq, 0);\r\nelse\r\nsk = ping_get_next(seq, v);\r\n++*pos;\r\nreturn sk;\r\n}\r\nstatic void ping_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nread_unlock_bh(&ping_table.lock);\r\n}\r\nstatic void ping_format_sock(struct sock *sp, struct seq_file *f,\r\nint bucket, int *len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sp);\r\n__be32 dest = inet->inet_daddr;\r\n__be32 src = inet->inet_rcv_saddr;\r\n__u16 destp = ntohs(inet->inet_dport);\r\n__u16 srcp = ntohs(inet->inet_sport);\r\nseq_printf(f, "%5d: %08X:%04X %08X:%04X"\r\n" %02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %pK %d%n",\r\nbucket, src, srcp, dest, destp, sp->sk_state,\r\nsk_wmem_alloc_get(sp),\r\nsk_rmem_alloc_get(sp),\r\n0, 0L, 0, sock_i_uid(sp), 0, sock_i_ino(sp),\r\natomic_read(&sp->sk_refcnt), sp,\r\natomic_read(&sp->sk_drops), len);\r\n}\r\nstatic int ping_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(seq, "%-127s\n",\r\n" sl local_address rem_address st tx_queue "\r\n"rx_queue tr tm->when retrnsmt uid timeout "\r\n"inode ref pointer drops");\r\nelse {\r\nstruct ping_iter_state *state = seq->private;\r\nint len;\r\nping_format_sock(v, seq, state->bucket, &len);\r\nseq_printf(seq, "%*s\n", 127 - len, "");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ping_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ping_seq_ops,\r\nsizeof(struct ping_iter_state));\r\n}\r\nstatic int ping_proc_register(struct net *net)\r\n{\r\nstruct proc_dir_entry *p;\r\nint rc = 0;\r\np = proc_net_fops_create(net, "icmp", S_IRUGO, &ping_seq_fops);\r\nif (!p)\r\nrc = -ENOMEM;\r\nreturn rc;\r\n}\r\nstatic void ping_proc_unregister(struct net *net)\r\n{\r\nproc_net_remove(net, "icmp");\r\n}\r\nstatic int __net_init ping_proc_init_net(struct net *net)\r\n{\r\nreturn ping_proc_register(net);\r\n}\r\nstatic void __net_exit ping_proc_exit_net(struct net *net)\r\n{\r\nping_proc_unregister(net);\r\n}\r\nint __init ping_proc_init(void)\r\n{\r\nreturn register_pernet_subsys(&ping_net_ops);\r\n}\r\nvoid ping_proc_exit(void)\r\n{\r\nunregister_pernet_subsys(&ping_net_ops);\r\n}\r\nvoid __init ping_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < PING_HTABLE_SIZE; i++)\r\nINIT_HLIST_NULLS_HEAD(&ping_table.hash[i], i);\r\nrwlock_init(&ping_table.lock);\r\n}
