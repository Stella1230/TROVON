const struct tile_opcode *\r\nfind_opcode(tile_bundle_bits bits, tile_pipeline pipe)\r\n{\r\nconst unsigned short *table = tile_bundle_decoder_fsms[pipe];\r\nint index = 0;\r\nwhile (1)\r\n{\r\nunsigned short bitspec = table[index];\r\nunsigned int bitfield =\r\n((unsigned int)(bits >> (bitspec & 63))) & (bitspec >> 6);\r\nunsigned short next = table[index + 1 + bitfield];\r\nif (next <= TILE_OPC_NONE)\r\nreturn &tile_opcodes[next];\r\nindex = next - TILE_OPC_NONE;\r\n}\r\n}\r\nint\r\nparse_insn_tile(tile_bundle_bits bits,\r\nunsigned int pc,\r\nstruct tile_decoded_instruction\r\ndecoded[TILE_MAX_INSTRUCTIONS_PER_BUNDLE])\r\n{\r\nint num_instructions = 0;\r\nint pipe;\r\nint min_pipe, max_pipe;\r\nif ((bits & TILE_BUNDLE_Y_ENCODING_MASK) == 0)\r\n{\r\nmin_pipe = TILE_PIPELINE_X0;\r\nmax_pipe = TILE_PIPELINE_X1;\r\n}\r\nelse\r\n{\r\nmin_pipe = TILE_PIPELINE_Y0;\r\nmax_pipe = TILE_PIPELINE_Y2;\r\n}\r\nfor (pipe = min_pipe; pipe <= max_pipe; pipe++)\r\n{\r\nconst struct tile_opcode *opc;\r\nstruct tile_decoded_instruction *d;\r\nint i;\r\nd = &decoded[num_instructions++];\r\nopc = find_opcode (bits, (tile_pipeline)pipe);\r\nd->opcode = opc;\r\nfor (i = 0; i < opc->num_operands; i++)\r\n{\r\nconst struct tile_operand *op =\r\n&tile_operands[opc->operands[pipe][i]];\r\nint opval = op->extract (bits);\r\nif (op->is_signed)\r\n{\r\nint shift = (int)((sizeof(int) * 8) - op->num_bits);\r\nopval = (opval << shift) >> shift;\r\n}\r\nif (op->type == TILE_OP_TYPE_ADDRESS)\r\n{\r\nopval *= TILE_BUNDLE_SIZE_IN_BYTES;\r\nopval += (int)pc;\r\n}\r\nd->operands[i] = op;\r\nd->operand_values[i] = opval;\r\n}\r\n}\r\nreturn num_instructions;\r\n}
