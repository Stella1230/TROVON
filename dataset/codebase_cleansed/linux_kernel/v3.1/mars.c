static void reg_w(struct gspca_dev *gspca_dev,\r\nint len)\r\n{\r\nint alen, ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_bulk_msg(gspca_dev->dev,\r\nusb_sndbulkpipe(gspca_dev->dev, 4),\r\ngspca_dev->usb_buf,\r\nlen,\r\n&alen,\r\n500);\r\nif (ret < 0) {\r\nerr("reg write [%02x] error %d",\r\ngspca_dev->usb_buf[0], ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void mi_w(struct gspca_dev *gspca_dev,\r\nu8 addr,\r\nu8 value)\r\n{\r\ngspca_dev->usb_buf[0] = 0x1f;\r\ngspca_dev->usb_buf[1] = 0;\r\ngspca_dev->usb_buf[2] = addr;\r\ngspca_dev->usb_buf[3] = value;\r\nreg_w(gspca_dev, 4);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->usb_buf[0] = 0x61;\r\ngspca_dev->usb_buf[1] = sd->ctrls[BRIGHTNESS].val;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns16 val;\r\nval = sd->ctrls[COLORS].val;\r\ngspca_dev->usb_buf[0] = 0x5f;\r\ngspca_dev->usb_buf[1] = val << 3;\r\ngspca_dev->usb_buf[2] = ((val >> 2) & 0xf8) | 0x04;\r\nreg_w(gspca_dev, 3);\r\n}\r\nstatic void setgamma(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->usb_buf[0] = 0x06;\r\ngspca_dev->usb_buf[1] = sd->ctrls[GAMMA].val * 0x40;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->usb_buf[0] = 0x67;\r\ngspca_dev->usb_buf[1] = sd->ctrls[SHARPNESS].val * 4 + 3;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic void setilluminators(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->usb_buf[0] = 0x22;\r\nif (sd->ctrls[ILLUM_TOP].val)\r\ngspca_dev->usb_buf[1] = 0x76;\r\nelse if (sd->ctrls[ILLUM_BOT].val)\r\ngspca_dev->usb_buf[1] = 0x7a;\r\nelse\r\ngspca_dev->usb_buf[1] = 0x7e;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\ncam->ctrls = sd->ctrls;\r\nsd->quality = QUALITY_DEF;\r\ngspca_dev->nbalt = 9;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->ctrl_inac = (1 << ILLUM_TOP) | (1 << ILLUM_BOT);\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 *data;\r\nint i;\r\njpeg_define(sd->jpeg_hdr, gspca_dev->height, gspca_dev->width,\r\n0x21);\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\ndata = gspca_dev->usb_buf;\r\ndata[0] = 0x01;\r\ndata[1] = 0x01;\r\nreg_w(gspca_dev, 2);\r\ndata[0] = 0x00;\r\ndata[1] = 0x0c | 0x01;\r\ndata[2] = 0x01;\r\ndata[3] = gspca_dev->width / 8;\r\ndata[4] = gspca_dev->height / 8;\r\ndata[5] = 0x30;\r\ndata[6] = 0x02;\r\ndata[7] = sd->ctrls[GAMMA].val * 0x40;\r\ndata[8] = 0x01;\r\ndata[9] = 0x52;\r\ndata[10] = 0x18;\r\nreg_w(gspca_dev, 11);\r\ndata[0] = 0x23;\r\ndata[1] = 0x09;\r\nreg_w(gspca_dev, 2);\r\ndata[0] = 0x3c;\r\ndata[1] = 50;\r\nreg_w(gspca_dev, 2);\r\ndata[0] = 0x5e;\r\ndata[1] = 0;\r\ndata[2] = sd->ctrls[COLORS].val << 3;\r\ndata[3] = ((sd->ctrls[COLORS].val >> 2) & 0xf8) | 0x04;\r\ndata[4] = sd->ctrls[BRIGHTNESS].val;\r\ndata[5] = 0x00;\r\nreg_w(gspca_dev, 6);\r\ndata[0] = 0x67;\r\ndata[1] = sd->ctrls[SHARPNESS].val * 4 + 3;\r\ndata[2] = 0x14;\r\nreg_w(gspca_dev, 3);\r\ndata[0] = 0x69;\r\ndata[1] = 0x2f;\r\ndata[2] = 0x28;\r\ndata[3] = 0x42;\r\nreg_w(gspca_dev, 4);\r\ndata[0] = 0x63;\r\ndata[1] = 0x07;\r\nreg_w(gspca_dev, 2);\r\nfor (i = 0; i < sizeof mi_data; i++)\r\nmi_w(gspca_dev, i + 1, mi_data[i]);\r\ndata[0] = 0x00;\r\ndata[1] = 0x4d;\r\nreg_w(gspca_dev, 2);\r\ngspca_dev->ctrl_inac = 0;\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->ctrl_inac = (1 << ILLUM_TOP) | (1 << ILLUM_BOT);\r\nif (sd->ctrls[ILLUM_TOP].val || sd->ctrls[ILLUM_BOT].val) {\r\nsd->ctrls[ILLUM_TOP].val = 0;\r\nsd->ctrls[ILLUM_BOT].val = 0;\r\nsetilluminators(gspca_dev);\r\nmsleep(20);\r\n}\r\ngspca_dev->usb_buf[0] = 1;\r\ngspca_dev->usb_buf[1] = 0;\r\nreg_w(gspca_dev, 2);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint p;\r\nif (len < 6) {\r\nreturn;\r\n}\r\nfor (p = 0; p < len - 6; p++) {\r\nif (data[0 + p] == 0xff\r\n&& data[1 + p] == 0xff\r\n&& data[2 + p] == 0x00\r\n&& data[3 + p] == 0xff\r\n&& data[4 + p] == 0x96) {\r\nif (data[5 + p] == 0x64\r\n|| data[5 + p] == 0x65\r\n|| data[5 + p] == 0x66\r\n|| data[5 + p] == 0x67) {\r\nPDEBUG(D_PACK, "sof offset: %d len: %d",\r\np, len);\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata, p);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ndata += p + 16;\r\nlen -= p + 16;\r\nbreak;\r\n}\r\n}\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_setilluminator1(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->ctrls[ILLUM_TOP].val = val;\r\nif (val)\r\nsd->ctrls[ILLUM_BOT].val = 0;\r\nsetilluminators(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_setilluminator2(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->ctrls[ILLUM_BOT].val = val;\r\nif (val)\r\nsd->ctrls[ILLUM_TOP].val = 0;\r\nsetilluminators(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (jcomp->quality < QUALITY_MIN)\r\nsd->quality = QUALITY_MIN;\r\nelse if (jcomp->quality > QUALITY_MAX)\r\nsd->quality = QUALITY_MAX;\r\nelse\r\nsd->quality = jcomp->quality;\r\nif (gspca_dev->streaming)\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\nreturn 0;\r\n}\r\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nmemset(jcomp, 0, sizeof *jcomp);\r\njcomp->quality = sd->quality;\r\njcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT\r\n| V4L2_JPEG_MARKER_DQT;\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int __init sd_mod_init(void)\r\n{\r\nreturn usb_register(&sd_driver);\r\n}\r\nstatic void __exit sd_mod_exit(void)\r\n{\r\nusb_deregister(&sd_driver);\r\n}
