static int solo_is_motion_on(struct solo_enc_dev *solo_enc)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nu8 ch = solo_enc->ch;\r\nif (solo_dev->motion_mask & (1 << ch))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void solo_motion_toggle(struct solo_enc_dev *solo_enc, int on)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nu8 ch = solo_enc->ch;\r\nspin_lock(&solo_enc->lock);\r\nif (on)\r\nsolo_dev->motion_mask |= (1 << ch);\r\nelse\r\nsolo_dev->motion_mask &= ~(1 << ch);\r\nsolo_reg_write(solo_enc->solo_dev, SOLO_VI_MOT_CLEAR,\r\n1 << solo_enc->ch);\r\nsolo_enc->motion_detected = 0;\r\nsolo_reg_write(solo_dev, SOLO_VI_MOT_ADR,\r\nSOLO_VI_MOTION_EN(solo_dev->motion_mask) |\r\n(SOLO_MOTION_EXT_ADDR(solo_dev) >> 16));\r\nif (solo_dev->motion_mask)\r\nsolo_irq_on(solo_dev, SOLO_IRQ_MOTION);\r\nelse\r\nsolo_irq_off(solo_dev, SOLO_IRQ_MOTION);\r\nspin_unlock(&solo_enc->lock);\r\n}\r\nstatic void solo_update_mode(struct solo_enc_dev *solo_enc)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nassert_spin_locked(&solo_enc->lock);\r\nsolo_enc->interlaced = (solo_enc->mode & 0x08) ? 1 : 0;\r\nsolo_enc->bw_weight = max(solo_dev->fps / solo_enc->interval, 1);\r\nswitch (solo_enc->mode) {\r\ncase SOLO_ENC_MODE_CIF:\r\nsolo_enc->width = solo_dev->video_hsize >> 1;\r\nsolo_enc->height = solo_dev->video_vsize;\r\nbreak;\r\ncase SOLO_ENC_MODE_D1:\r\nsolo_enc->width = solo_dev->video_hsize;\r\nsolo_enc->height = solo_dev->video_vsize << 1;\r\nsolo_enc->bw_weight <<= 2;\r\nbreak;\r\ndefault:\r\nWARN(1, "mode is unknown\n");\r\n}\r\n}\r\nstatic int solo_enc_on(struct solo_enc_fh *fh)\r\n{\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nu8 ch = solo_enc->ch;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nu8 interval;\r\nassert_spin_locked(&solo_enc->lock);\r\nif (fh->enc_on)\r\nreturn 0;\r\nsolo_update_mode(solo_enc);\r\nif (!atomic_read(&solo_enc->readers)) {\r\nif (solo_enc->bw_weight > solo_dev->enc_bw_remain)\r\nreturn -EBUSY;\r\nelse\r\nsolo_dev->enc_bw_remain -= solo_enc->bw_weight;\r\n}\r\nfh->enc_on = 1;\r\nfh->rd_idx = solo_enc->solo_dev->enc_wr_idx;\r\nif (fh->type == SOLO_ENC_TYPE_EXT)\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_COMP_ENA_E(ch), 1);\r\nif (atomic_inc_return(&solo_enc->readers) > 1)\r\nreturn 0;\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(ch), 0);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_INTL(ch),\r\nsolo_enc->interlaced ? 1 : 0);\r\nif (solo_enc->interlaced)\r\ninterval = solo_enc->interval - 1;\r\nelse\r\ninterval = solo_enc->interval;\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP(ch), solo_enc->gop);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_QP(ch), solo_enc->qp);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_INTV(ch), interval);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP_E(ch), solo_enc->gop);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_QP_E(ch), solo_enc->qp);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_INTV_E(ch), interval);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(ch), solo_enc->mode);\r\nmdelay(10);\r\nreturn 0;\r\n}\r\nstatic void solo_enc_off(struct solo_enc_fh *fh)\r\n{\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nif (!fh->enc_on)\r\nreturn;\r\nif (fh->kthread) {\r\nkthread_stop(fh->kthread);\r\nfh->kthread = NULL;\r\n}\r\nsolo_dev->enc_bw_remain += solo_enc->bw_weight;\r\nfh->enc_on = 0;\r\nif (atomic_dec_return(&solo_enc->readers) > 0)\r\nreturn;\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(solo_enc->ch), 0);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_COMP_ENA_E(solo_enc->ch), 0);\r\n}\r\nstatic int solo_start_fh_thread(struct solo_enc_fh *fh)\r\n{\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nfh->kthread = kthread_run(solo_enc_thread, fh, SOLO6X10_NAME "_enc");\r\nif (IS_ERR(fh->kthread)) {\r\nspin_lock(&solo_enc->lock);\r\nsolo_enc_off(fh);\r\nspin_unlock(&solo_enc->lock);\r\nreturn PTR_ERR(fh->kthread);\r\n}\r\nreturn 0;\r\n}\r\nstatic void enc_reset_gop(struct solo_dev *solo_dev, u8 ch)\r\n{\r\nBUG_ON(ch >= solo_dev->nr_chans);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP(ch), 1);\r\nsolo_dev->v4l2_enc[ch]->reset_gop = 1;\r\n}\r\nstatic int enc_gop_reset(struct solo_dev *solo_dev, u8 ch, u8 vop)\r\n{\r\nBUG_ON(ch >= solo_dev->nr_chans);\r\nif (!solo_dev->v4l2_enc[ch]->reset_gop)\r\nreturn 0;\r\nif (vop)\r\nreturn 1;\r\nsolo_dev->v4l2_enc[ch]->reset_gop = 0;\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP(ch),\r\nsolo_dev->v4l2_enc[ch]->gop);\r\nreturn 0;\r\n}\r\nstatic void enc_write_sg(struct scatterlist *sglist, void *buf, int size)\r\n{\r\nstruct scatterlist *sg;\r\nu8 *src = buf;\r\nfor (sg = sglist; sg && size > 0; sg = sg_next(sg)) {\r\nu8 *p = sg_virt(sg);\r\nsize_t len = sg_dma_len(sg);\r\nint i;\r\nfor (i = 0; i < len && size; i++)\r\np[i] = *(src++);\r\n}\r\n}\r\nstatic int enc_get_mpeg_dma_sg(struct solo_dev *solo_dev,\r\nstruct p2m_desc *desc,\r\nstruct scatterlist *sglist, int skip,\r\nunsigned int off, unsigned int size)\r\n{\r\nint ret;\r\nif (off > SOLO_MP4E_EXT_SIZE(solo_dev))\r\nreturn -EINVAL;\r\nif (off + size <= SOLO_MP4E_EXT_SIZE(solo_dev)) {\r\nreturn solo_p2m_dma_sg(solo_dev, SOLO_P2M_DMA_ID_MP4E,\r\ndesc, 0, sglist, skip,\r\nSOLO_MP4E_EXT_ADDR(solo_dev) + off, size);\r\n}\r\nret = solo_p2m_dma_sg(solo_dev, SOLO_P2M_DMA_ID_MP4E, desc, 0,\r\nsglist, skip, SOLO_MP4E_EXT_ADDR(solo_dev) + off,\r\nSOLO_MP4E_EXT_SIZE(solo_dev) - off);\r\nret |= solo_p2m_dma_sg(solo_dev, SOLO_P2M_DMA_ID_MP4E, desc, 0,\r\nsglist, skip + SOLO_MP4E_EXT_SIZE(solo_dev) - off,\r\nSOLO_MP4E_EXT_ADDR(solo_dev),\r\nsize + off - SOLO_MP4E_EXT_SIZE(solo_dev));\r\nreturn ret;\r\n}\r\nstatic int enc_get_mpeg_dma_t(struct solo_dev *solo_dev,\r\ndma_addr_t buf, unsigned int off,\r\nunsigned int size)\r\n{\r\nint ret;\r\nif (off > SOLO_MP4E_EXT_SIZE(solo_dev))\r\nreturn -EINVAL;\r\nif (off + size <= SOLO_MP4E_EXT_SIZE(solo_dev)) {\r\nreturn solo_p2m_dma_t(solo_dev, SOLO_P2M_DMA_ID_MP4E, 0, buf,\r\nSOLO_MP4E_EXT_ADDR(solo_dev) + off, size);\r\n}\r\nret = solo_p2m_dma_t(solo_dev, SOLO_P2M_DMA_ID_MP4E, 0, buf,\r\nSOLO_MP4E_EXT_ADDR(solo_dev) + off,\r\nSOLO_MP4E_EXT_SIZE(solo_dev) - off);\r\nret |= solo_p2m_dma_t(solo_dev, SOLO_P2M_DMA_ID_MP4E, 0,\r\nbuf + SOLO_MP4E_EXT_SIZE(solo_dev) - off,\r\nSOLO_MP4E_EXT_ADDR(solo_dev),\r\nsize + off - SOLO_MP4E_EXT_SIZE(solo_dev));\r\nreturn ret;\r\n}\r\nstatic int enc_get_mpeg_dma(struct solo_dev *solo_dev, void *buf,\r\nunsigned int off, unsigned int size)\r\n{\r\nint ret;\r\ndma_addr_t dma_addr = pci_map_single(solo_dev->pdev, buf, size,\r\nPCI_DMA_FROMDEVICE);\r\nret = enc_get_mpeg_dma_t(solo_dev, dma_addr, off, size);\r\npci_unmap_single(solo_dev->pdev, dma_addr, size, PCI_DMA_FROMDEVICE);\r\nreturn ret;\r\n}\r\nstatic int enc_get_jpeg_dma_sg(struct solo_dev *solo_dev,\r\nstruct p2m_desc *desc,\r\nstruct scatterlist *sglist, int skip,\r\nunsigned int off, unsigned int size)\r\n{\r\nint ret;\r\nif (off > SOLO_JPEG_EXT_SIZE(solo_dev))\r\nreturn -EINVAL;\r\nif (off + size <= SOLO_JPEG_EXT_SIZE(solo_dev)) {\r\nreturn solo_p2m_dma_sg(solo_dev, SOLO_P2M_DMA_ID_JPEG,\r\ndesc, 0, sglist, skip,\r\nSOLO_JPEG_EXT_ADDR(solo_dev) + off, size);\r\n}\r\nret = solo_p2m_dma_sg(solo_dev, SOLO_P2M_DMA_ID_JPEG, desc, 0,\r\nsglist, skip, SOLO_JPEG_EXT_ADDR(solo_dev) + off,\r\nSOLO_JPEG_EXT_SIZE(solo_dev) - off);\r\nret |= solo_p2m_dma_sg(solo_dev, SOLO_P2M_DMA_ID_JPEG, desc, 0,\r\nsglist, skip + SOLO_JPEG_EXT_SIZE(solo_dev) - off,\r\nSOLO_JPEG_EXT_ADDR(solo_dev),\r\nsize + off - SOLO_JPEG_EXT_SIZE(solo_dev));\r\nreturn ret;\r\n}\r\nstatic void solo_jpeg_header(struct solo_enc_dev *solo_enc,\r\nstruct videobuf_dmabuf *vbuf)\r\n{\r\nstruct scatterlist *sg;\r\nvoid *src = jpeg_header;\r\nsize_t copied = 0;\r\nsize_t to_copy = sizeof(jpeg_header);\r\nfor (sg = vbuf->sglist; sg && copied < to_copy; sg = sg_next(sg)) {\r\nsize_t this_copy = min(sg_dma_len(sg),\r\n(unsigned int)(to_copy - copied));\r\nu8 *p = sg_virt(sg);\r\nmemcpy(p, src + copied, this_copy);\r\nif (OFF_IN_RANGE(copied, this_copy, SOF0_START + 5))\r\np[(SOF0_START + 5) - copied] =\r\n0xff & (solo_enc->height >> 8);\r\nif (OFF_IN_RANGE(copied, this_copy, SOF0_START + 6))\r\np[(SOF0_START + 6) - copied] = 0xff & solo_enc->height;\r\nif (OFF_IN_RANGE(copied, this_copy, SOF0_START + 7))\r\np[(SOF0_START + 7) - copied] =\r\n0xff & (solo_enc->width >> 8);\r\nif (OFF_IN_RANGE(copied, this_copy, SOF0_START + 8))\r\np[(SOF0_START + 8) - copied] = 0xff & solo_enc->width;\r\ncopied += this_copy;\r\n}\r\n}\r\nstatic int solo_fill_jpeg(struct solo_enc_fh *fh, struct solo_enc_buf *enc_buf,\r\nstruct videobuf_buffer *vb,\r\nstruct videobuf_dmabuf *vbuf)\r\n{\r\nstruct solo_dev *solo_dev = fh->enc->solo_dev;\r\nint size = enc_buf->jpeg_size;\r\nsolo_jpeg_header(fh->enc, vbuf);\r\nvb->size = size + sizeof(jpeg_header);\r\nreturn enc_get_jpeg_dma_sg(solo_dev, fh->desc, vbuf->sglist,\r\nsizeof(jpeg_header),\r\nenc_buf->jpeg_off, size);\r\n}\r\nstatic inline int vop_interlaced(__le32 *vh)\r\n{\r\nreturn (__le32_to_cpu(vh[0]) >> 30) & 1;\r\n}\r\nstatic inline u32 vop_size(__le32 *vh)\r\n{\r\nreturn __le32_to_cpu(vh[0]) & 0xFFFFF;\r\n}\r\nstatic inline u8 vop_hsize(__le32 *vh)\r\n{\r\nreturn (__le32_to_cpu(vh[1]) >> 8) & 0xFF;\r\n}\r\nstatic inline u8 vop_vsize(__le32 *vh)\r\n{\r\nreturn __le32_to_cpu(vh[1]) & 0xFF;\r\n}\r\nstatic void write_bytes(u8 **out, unsigned *bits, const u8 *src, unsigned count)\r\n{\r\nmemcpy(*out, src, count);\r\n*out += count;\r\n*bits += count * 8;\r\n}\r\nstatic void write_bits(u8 **out, unsigned *bits, u32 value, unsigned count)\r\n{\r\nvalue <<= 32 - count;\r\nwhile (count--) {\r\n**out <<= 1;\r\n**out |= !!(value & (1 << 31));\r\nvalue <<= 1;\r\nif (++(*bits) % 8 == 0)\r\n(*out)++;\r\n}\r\n}\r\nstatic void write_ue(u8 **out, unsigned *bits, unsigned value)\r\n{\r\nuint32_t max = 0, cnt = 0;\r\nwhile (value > max) {\r\nmax = (max + 2) * 2 - 2;\r\ncnt++;\r\n}\r\nwrite_bits(out, bits, 1, cnt + 1);\r\nwrite_bits(out, bits, ~(max - value), cnt);\r\n}\r\nstatic void write_se(u8 **out, unsigned *bits, int value)\r\n{\r\nif (value <= 0)\r\nwrite_ue(out, bits, -value * 2);\r\nelse\r\nwrite_ue(out, bits, value * 2 - 1);\r\n}\r\nstatic void write_mpeg4_end(u8 **out, unsigned *bits)\r\n{\r\nwrite_bits(out, bits, 0, 1);\r\nif (*bits % 32)\r\nwrite_bits(out, bits, 0xFFFFFFFF, 32 - *bits % 32);\r\n}\r\nstatic void write_h264_end(u8 **out, unsigned *bits, int align)\r\n{\r\nwrite_bits(out, bits, 1, 1);\r\nwhile ((*bits) % 8)\r\nwrite_bits(out, bits, 0, 1);\r\nif (align)\r\nwhile ((*bits) % 32)\r\nwrite_bits(out, bits, 0, 1);\r\n}\r\nstatic void mpeg4_write_vol(u8 **out, struct solo_dev *solo_dev,\r\n__le32 *vh, unsigned fps, unsigned interval)\r\n{\r\nstatic const u8 hdr[] = {\r\n0, 0, 1, 0x00 ,\r\n0, 0, 1, 0x20\r\n};\r\nunsigned bits = 0;\r\nunsigned width = vop_hsize(vh) << 4;\r\nunsigned height = vop_vsize(vh) << 4;\r\nunsigned interlaced = vop_interlaced(vh);\r\nwrite_bytes(out, &bits, hdr, sizeof(hdr));\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0x04, 8);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 2, 4);\r\nwrite_bits(out, &bits, 0, 3);\r\nif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC)\r\nwrite_bits(out, &bits, 3, 4);\r\nelse\r\nwrite_bits(out, &bits, 2, 4);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 1, 2);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 2);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, fps, 16);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, interval, 15);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, width, 13);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, height, 13);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, interlaced, 1);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 0, 2);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 1, 0);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_mpeg4_end(out, &bits);\r\n}\r\nstatic void h264_write_vol(u8 **out, struct solo_dev *solo_dev, __le32 *vh)\r\n{\r\nstatic const u8 sps[] = {\r\n0, 0, 0, 1 , 0x67, 66 ,\r\n0 , 30\r\n};\r\nstatic const u8 pps[] = {\r\n0, 0, 0, 1 , 0x68\r\n};\r\nunsigned bits = 0;\r\nunsigned mbs_w = vop_hsize(vh);\r\nunsigned mbs_h = vop_vsize(vh);\r\nwrite_bytes(out, &bits, sps, sizeof(sps));\r\nwrite_ue(out, &bits, 0);\r\nwrite_ue(out, &bits, 5);\r\nwrite_ue(out, &bits, 0);\r\nwrite_ue(out, &bits, 6);\r\nwrite_ue(out, &bits, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_ue(out, &bits, mbs_w - 1);\r\nwrite_ue(out, &bits, mbs_h - 1);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_h264_end(out, &bits, 0);\r\nwrite_bytes(out, &bits, pps, sizeof(pps));\r\nwrite_ue(out, &bits, 0);\r\nwrite_ue(out, &bits, 0);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_ue(out, &bits, 0);\r\nwrite_ue(out, &bits, 0);\r\nwrite_ue(out, &bits, 0);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 0, 2);\r\nwrite_se(out, &bits, 0);\r\nwrite_se(out, &bits, 0);\r\nwrite_se(out, &bits, 2);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_bits(out, &bits, 1, 1);\r\nwrite_bits(out, &bits, 0, 1);\r\nwrite_h264_end(out, &bits, 1);\r\n}\r\nstatic int solo_fill_mpeg(struct solo_enc_fh *fh, struct solo_enc_buf *enc_buf,\r\nstruct videobuf_buffer *vb,\r\nstruct videobuf_dmabuf *vbuf)\r\n{\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\n#define VH_WORDS 16\r\n#define MAX_VOL_HEADER_LENGTH 64\r\n__le32 vh[VH_WORDS];\r\nint ret;\r\nint frame_size, frame_off;\r\nint skip = 0;\r\nif (WARN_ON_ONCE(enc_buf->size <= sizeof(vh)))\r\nreturn -EINVAL;\r\nret = enc_get_mpeg_dma(solo_dev, vh, enc_buf->off, sizeof(vh));\r\nif (WARN_ON_ONCE(ret))\r\nreturn ret;\r\nif (WARN_ON_ONCE(vop_size(vh) > enc_buf->size))\r\nreturn -EINVAL;\r\nvb->width = vop_hsize(vh) << 4;\r\nvb->height = vop_vsize(vh) << 4;\r\nvb->size = vop_size(vh);\r\nif (!enc_buf->vop) {\r\nu8 header[MAX_VOL_HEADER_LENGTH], *out = header;\r\nif (solo_dev->flags & FLAGS_6110)\r\nh264_write_vol(&out, solo_dev, vh);\r\nelse\r\nmpeg4_write_vol(&out, solo_dev, vh,\r\nsolo_dev->fps * 1000,\r\nsolo_enc->interval * 1000);\r\nskip = out - header;\r\nenc_write_sg(vbuf->sglist, header, skip);\r\nvb->size += skip;\r\n}\r\nframe_off = (enc_buf->off + sizeof(vh)) % SOLO_MP4E_EXT_SIZE(solo_dev);\r\nframe_size = enc_buf->size - sizeof(vh);\r\nret = enc_get_mpeg_dma_sg(solo_dev, fh->desc, vbuf->sglist,\r\nskip, frame_off, frame_size);\r\nWARN_ON_ONCE(ret);\r\nreturn ret;\r\n}\r\nstatic void solo_enc_fillbuf(struct solo_enc_fh *fh,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct solo_enc_buf *enc_buf = NULL;\r\nstruct videobuf_dmabuf *vbuf;\r\nint ret;\r\nint error = 1;\r\nu16 idx = fh->rd_idx;\r\nwhile (idx != solo_dev->enc_wr_idx) {\r\nstruct solo_enc_buf *ebuf = &solo_dev->enc_buf[idx];\r\nidx = (idx + 1) % SOLO_NR_RING_BUFS;\r\nif (ebuf->ch != solo_enc->ch)\r\ncontinue;\r\nif (fh->fmt == V4L2_PIX_FMT_MPEG) {\r\nif (fh->type == ebuf->type) {\r\nenc_buf = ebuf;\r\nbreak;\r\n}\r\n} else {\r\nenc_buf = ebuf;\r\n}\r\n}\r\nfh->rd_idx = idx;\r\nif (WARN_ON_ONCE(!enc_buf))\r\ngoto buf_err;\r\nif ((fh->fmt == V4L2_PIX_FMT_MPEG &&\r\nvb->bsize < enc_buf->size) ||\r\n(fh->fmt == V4L2_PIX_FMT_MJPEG &&\r\nvb->bsize < (enc_buf->jpeg_size + sizeof(jpeg_header)))) {\r\nWARN_ON_ONCE(1);\r\ngoto buf_err;\r\n}\r\nvbuf = videobuf_to_dma(vb);\r\nif (WARN_ON_ONCE(!vbuf))\r\ngoto buf_err;\r\nif (fh->fmt == V4L2_PIX_FMT_MPEG)\r\nret = solo_fill_mpeg(fh, enc_buf, vb, vbuf);\r\nelse\r\nret = solo_fill_jpeg(fh, enc_buf, vb, vbuf);\r\nif (!ret)\r\nerror = 0;\r\nbuf_err:\r\nif (error) {\r\nvb->state = VIDEOBUF_ERROR;\r\n} else {\r\nvb->field_count++;\r\nvb->ts = enc_buf->ts;\r\nvb->state = VIDEOBUF_DONE;\r\n}\r\nwake_up(&vb->done);\r\nreturn;\r\n}\r\nstatic void solo_enc_thread_try(struct solo_enc_fh *fh)\r\n{\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct videobuf_buffer *vb;\r\nfor (;;) {\r\nspin_lock(&solo_enc->lock);\r\nif (fh->rd_idx == solo_dev->enc_wr_idx)\r\nbreak;\r\nif (list_empty(&fh->vidq_active))\r\nbreak;\r\nvb = list_first_entry(&fh->vidq_active,\r\nstruct videobuf_buffer, queue);\r\nif (!waitqueue_active(&vb->done))\r\nbreak;\r\nlist_del(&vb->queue);\r\nspin_unlock(&solo_enc->lock);\r\nsolo_enc_fillbuf(fh, vb);\r\n}\r\nassert_spin_locked(&solo_enc->lock);\r\nspin_unlock(&solo_enc->lock);\r\n}\r\nstatic int solo_enc_thread(void *data)\r\n{\r\nstruct solo_enc_fh *fh = data;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_freezable();\r\nadd_wait_queue(&solo_enc->thread_wait, &wait);\r\nfor (;;) {\r\nlong timeout = schedule_timeout_interruptible(HZ);\r\nif (timeout == -ERESTARTSYS || kthread_should_stop())\r\nbreak;\r\nsolo_enc_thread_try(fh);\r\ntry_to_freeze();\r\n}\r\nremove_wait_queue(&solo_enc->thread_wait, &wait);\r\nreturn 0;\r\n}\r\nvoid solo_motion_isr(struct solo_dev *solo_dev)\r\n{\r\nu32 status;\r\nint i;\r\nsolo_reg_write(solo_dev, SOLO_IRQ_STAT, SOLO_IRQ_MOTION);\r\nstatus = solo_reg_read(solo_dev, SOLO_VI_MOT_STATUS);\r\nfor (i = 0; i < solo_dev->nr_chans; i++) {\r\nstruct solo_enc_dev *solo_enc = solo_dev->v4l2_enc[i];\r\nBUG_ON(solo_enc == NULL);\r\nif (solo_enc->motion_detected)\r\ncontinue;\r\nif (!(status & (1 << i)))\r\ncontinue;\r\nsolo_enc->motion_detected = 1;\r\n}\r\n}\r\nvoid solo_enc_v4l2_isr(struct solo_dev *solo_dev)\r\n{\r\nstruct solo_enc_buf *enc_buf;\r\nu32 mpeg_current, mpeg_next, mpeg_size;\r\nu32 jpeg_current, jpeg_next, jpeg_size;\r\nu32 reg_mpeg_size;\r\nu8 cur_q, vop_type;\r\nu8 ch;\r\nenum solo_enc_types enc_type;\r\nsolo_reg_write(solo_dev, SOLO_IRQ_STAT, SOLO_IRQ_ENCODER);\r\ncur_q = ((solo_reg_read(solo_dev, SOLO_VE_STATE(11)) & 0xF) + 1) % MP4_QS;\r\nreg_mpeg_size = ((solo_reg_read(solo_dev, SOLO_VE_STATE(0)) & 0xFFFFF) + 64 + 8) & ~7;\r\nwhile (solo_dev->enc_idx != cur_q) {\r\nmpeg_current = solo_reg_read(solo_dev,\r\nSOLO_VE_MPEG4_QUE(solo_dev->enc_idx));\r\njpeg_current = solo_reg_read(solo_dev,\r\nSOLO_VE_JPEG_QUE(solo_dev->enc_idx));\r\nsolo_dev->enc_idx = (solo_dev->enc_idx + 1) % MP4_QS;\r\nmpeg_next = solo_reg_read(solo_dev,\r\nSOLO_VE_MPEG4_QUE(solo_dev->enc_idx));\r\njpeg_next = solo_reg_read(solo_dev,\r\nSOLO_VE_JPEG_QUE(solo_dev->enc_idx));\r\nch = (mpeg_current >> 24) & 0x1f;\r\nif (ch >= SOLO_MAX_CHANNELS) {\r\nch -= SOLO_MAX_CHANNELS;\r\nenc_type = SOLO_ENC_TYPE_EXT;\r\n} else\r\nenc_type = SOLO_ENC_TYPE_STD;\r\nvop_type = (mpeg_current >> 29) & 3;\r\nmpeg_current &= 0x00ffffff;\r\nmpeg_next &= 0x00ffffff;\r\njpeg_current &= 0x00ffffff;\r\njpeg_next &= 0x00ffffff;\r\nmpeg_size = (SOLO_MP4E_EXT_SIZE(solo_dev) +\r\nmpeg_next - mpeg_current) %\r\nSOLO_MP4E_EXT_SIZE(solo_dev);\r\njpeg_size = (SOLO_JPEG_EXT_SIZE(solo_dev) +\r\njpeg_next - jpeg_current) %\r\nSOLO_JPEG_EXT_SIZE(solo_dev);\r\nif (mpeg_current > mpeg_next && mpeg_size != reg_mpeg_size) {\r\nenc_reset_gop(solo_dev, ch);\r\ncontinue;\r\n}\r\nif (enc_gop_reset(solo_dev, ch, vop_type))\r\ncontinue;\r\nenc_buf = &solo_dev->enc_buf[solo_dev->enc_wr_idx];\r\nenc_buf->vop = vop_type;\r\nenc_buf->ch = ch;\r\nenc_buf->off = mpeg_current;\r\nenc_buf->size = mpeg_size;\r\nenc_buf->jpeg_off = jpeg_current;\r\nenc_buf->jpeg_size = jpeg_size;\r\nenc_buf->type = enc_type;\r\ndo_gettimeofday(&enc_buf->ts);\r\nsolo_dev->enc_wr_idx = (solo_dev->enc_wr_idx + 1) %\r\nSOLO_NR_RING_BUFS;\r\nwake_up_interruptible(&solo_dev->v4l2_enc[ch]->thread_wait);\r\n}\r\nreturn;\r\n}\r\nstatic int solo_enc_buf_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\n*size = FRAME_BUF_SIZE;\r\nif (*count < MIN_VID_BUFFERS)\r\n*count = MIN_VID_BUFFERS;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_buf_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct solo_enc_fh *fh = vq->priv_data;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nvb->size = FRAME_BUF_SIZE;\r\nif (vb->baddr != 0 && vb->bsize < vb->size)\r\nreturn -EINVAL;\r\nvb->width = solo_enc->width;\r\nvb->height = solo_enc->height;\r\nvb->field = field;\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nint rc = videobuf_iolock(vq, vb, NULL);\r\nif (rc < 0) {\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nvideobuf_dma_unmap(vq->dev, dma);\r\nvideobuf_dma_free(dma);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\nreturn rc;\r\n}\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\n}\r\nstatic void solo_enc_buf_queue(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct solo_enc_fh *fh = vq->priv_data;\r\nvb->state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&vb->queue, &fh->vidq_active);\r\nwake_up_interruptible(&fh->enc->thread_wait);\r\n}\r\nstatic void solo_enc_buf_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nvideobuf_dma_unmap(vq->dev, dma);\r\nvideobuf_dma_free(dma);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic unsigned int solo_enc_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct solo_enc_fh *fh = file->private_data;\r\nreturn videobuf_poll_stream(file, &fh->vidq, wait);\r\n}\r\nstatic int solo_enc_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct solo_enc_fh *fh = file->private_data;\r\nreturn videobuf_mmap_mapper(&fh->vidq, vma);\r\n}\r\nstatic int solo_enc_open(struct file *file)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct solo_enc_fh *fh;\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (fh == NULL)\r\nreturn -ENOMEM;\r\nfh->enc = solo_enc;\r\nfile->private_data = fh;\r\nINIT_LIST_HEAD(&fh->vidq_active);\r\nfh->fmt = V4L2_PIX_FMT_MPEG;\r\nfh->type = SOLO_ENC_TYPE_STD;\r\nvideobuf_queue_sg_init(&fh->vidq, &solo_enc_video_qops,\r\n&solo_enc->solo_dev->pdev->dev,\r\n&solo_enc->lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct videobuf_buffer), fh, NULL);\r\nreturn 0;\r\n}\r\nstatic ssize_t solo_enc_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct solo_enc_fh *fh = file->private_data;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nif (!fh->enc_on) {\r\nint ret;\r\nspin_lock(&solo_enc->lock);\r\nret = solo_enc_on(fh);\r\nspin_unlock(&solo_enc->lock);\r\nif (ret)\r\nreturn ret;\r\nret = solo_start_fh_thread(fh);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn videobuf_read_stream(&fh->vidq, data, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int solo_enc_release(struct file *file)\r\n{\r\nstruct solo_enc_fh *fh = file->private_data;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nvideobuf_stop(&fh->vidq);\r\nvideobuf_mmap_free(&fh->vidq);\r\nspin_lock(&solo_enc->lock);\r\nsolo_enc_off(fh);\r\nspin_unlock(&solo_enc->lock);\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int solo_enc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstrcpy(cap->driver, SOLO6X10_NAME);\r\nsnprintf(cap->card, sizeof(cap->card), "Softlogic 6x10 Enc %d",\r\nsolo_enc->ch);\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "PCI %s",\r\npci_name(solo_dev->pdev));\r\ncap->version = SOLO6X10_VER_NUM;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nif (input->index)\r\nreturn -EINVAL;\r\nsnprintf(input->name, sizeof(input->name), "Encoder %d",\r\nsolo_enc->ch + 1);\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\nif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC)\r\ninput->std = V4L2_STD_NTSC_M;\r\nelse\r\ninput->std = V4L2_STD_PAL_B;\r\nif (!tw28_get_video_status(solo_dev, solo_enc->ch))\r\ninput->status = V4L2_IN_ST_NO_SIGNAL;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_set_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nif (index)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_get_input(struct file *file, void *priv,\r\nunsigned int *index)\r\n{\r\n*index = 0;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_enum_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nswitch (f->index) {\r\ncase 0:\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nstrcpy(f->description, "MPEG-4 AVC");\r\nbreak;\r\ncase 1:\r\nf->pixelformat = V4L2_PIX_FMT_MJPEG;\r\nstrcpy(f->description, "MJPEG");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_try_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nif (pix->pixelformat != V4L2_PIX_FMT_MPEG &&\r\npix->pixelformat != V4L2_PIX_FMT_MJPEG)\r\nreturn -EINVAL;\r\nif (atomic_read(&solo_enc->readers) > 0) {\r\nif (pix->width != solo_enc->width ||\r\npix->height != solo_enc->height)\r\nreturn -EBUSY;\r\n}\r\nif (pix->width < solo_dev->video_hsize ||\r\npix->height < solo_dev->video_vsize << 1) {\r\npix->width = solo_dev->video_hsize >> 1;\r\npix->height = solo_dev->video_vsize;\r\n} else {\r\npix->width = solo_dev->video_hsize;\r\npix->height = solo_dev->video_vsize << 1;\r\n}\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = V4L2_FIELD_INTERLACED;\r\nelse if (pix->field != V4L2_FIELD_INTERLACED)\r\npix->field = V4L2_FIELD_INTERLACED;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\npix->sizeimage = FRAME_BUF_SIZE;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_set_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nint ret;\r\nspin_lock(&solo_enc->lock);\r\nret = solo_enc_try_fmt_cap(file, priv, f);\r\nif (ret) {\r\nspin_unlock(&solo_enc->lock);\r\nreturn ret;\r\n}\r\nif (pix->width == solo_dev->video_hsize)\r\nsolo_enc->mode = SOLO_ENC_MODE_D1;\r\nelse\r\nsolo_enc->mode = SOLO_ENC_MODE_CIF;\r\nfh->fmt = pix->pixelformat;\r\nif (pix->priv)\r\nfh->type = SOLO_ENC_TYPE_EXT;\r\nret = solo_enc_on(fh);\r\nspin_unlock(&solo_enc->lock);\r\nif (ret)\r\nreturn ret;\r\nreturn solo_start_fh_thread(fh);\r\n}\r\nstatic int solo_enc_get_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\npix->width = solo_enc->width;\r\npix->height = solo_enc->height;\r\npix->pixelformat = fh->fmt;\r\npix->field = solo_enc->interlaced ? V4L2_FIELD_INTERLACED :\r\nV4L2_FIELD_NONE;\r\npix->sizeimage = FRAME_BUF_SIZE;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nreturn videobuf_reqbufs(&fh->vidq, req);\r\n}\r\nstatic int solo_enc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nreturn videobuf_querybuf(&fh->vidq, buf);\r\n}\r\nstatic int solo_enc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nreturn videobuf_qbuf(&fh->vidq, buf);\r\n}\r\nstatic int solo_enc_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nint ret;\r\nif (!fh->enc_on) {\r\nspin_lock(&solo_enc->lock);\r\nret = solo_enc_on(fh);\r\nspin_unlock(&solo_enc->lock);\r\nif (ret)\r\nreturn ret;\r\nret = solo_start_fh_thread(fh);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = videobuf_dqbuf(&fh->vidq, buf, file->f_flags & O_NONBLOCK);\r\nif (ret)\r\nreturn ret;\r\nif (solo_is_motion_on(solo_enc)) {\r\nbuf->flags |= V4L2_BUF_FLAG_MOTION_ON;\r\nif (solo_enc->motion_detected) {\r\nbuf->flags |= V4L2_BUF_FLAG_MOTION_DETECTED;\r\nsolo_reg_write(solo_enc->solo_dev, SOLO_VI_MOT_CLEAR,\r\n1 << solo_enc->ch);\r\nsolo_enc->motion_detected = 0;\r\n}\r\n}\r\nif (fh->fmt == V4L2_PIX_FMT_MPEG) {\r\nstruct videobuf_dmabuf *vbuf =\r\nvideobuf_to_dma(fh->vidq.bufs[buf->index]);\r\nif (vbuf) {\r\nu8 *p = sg_virt(vbuf->sglist);\r\nif (p[3] == 0x00)\r\nbuf->flags |= V4L2_BUF_FLAG_KEYFRAME;\r\nelse\r\nbuf->flags |= V4L2_BUF_FLAG_PFRAME;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int solo_enc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nif (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn videobuf_streamon(&fh->vidq);\r\n}\r\nstatic int solo_enc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nif (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn videobuf_streamoff(&fh->vidq);\r\n}\r\nstatic int solo_enc_s_std(struct file *file, void *priv, v4l2_std_id *i)\r\n{\r\nreturn 0;\r\n}\r\nstatic int solo_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_dev *solo_dev = fh->enc->solo_dev;\r\nif (fsize->pixel_format != V4L2_PIX_FMT_MPEG)\r\nreturn -EINVAL;\r\nswitch (fsize->index) {\r\ncase 0:\r\nfsize->discrete.width = solo_dev->video_hsize >> 1;\r\nfsize->discrete.height = solo_dev->video_vsize;\r\nbreak;\r\ncase 1:\r\nfsize->discrete.width = solo_dev->video_hsize;\r\nfsize->discrete.height = solo_dev->video_vsize << 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nreturn 0;\r\n}\r\nstatic int solo_enum_frameintervals(struct file *file, void *priv,\r\nstruct v4l2_frmivalenum *fintv)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_dev *solo_dev = fh->enc->solo_dev;\r\nif (fintv->pixel_format != V4L2_PIX_FMT_MPEG || fintv->index)\r\nreturn -EINVAL;\r\nfintv->type = V4L2_FRMIVAL_TYPE_STEPWISE;\r\nfintv->stepwise.min.numerator = solo_dev->fps;\r\nfintv->stepwise.min.denominator = 1;\r\nfintv->stepwise.max.numerator = solo_dev->fps;\r\nfintv->stepwise.max.denominator = 15;\r\nfintv->stepwise.step.numerator = 1;\r\nfintv->stepwise.step.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int solo_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = solo_enc->interval;\r\ncp->timeperframe.denominator = solo_dev->fps;\r\ncp->capturemode = 0;\r\ncp->readbuffers = 2;\r\nreturn 0;\r\n}\r\nstatic int solo_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\nspin_lock(&solo_enc->lock);\r\nif (atomic_read(&solo_enc->readers) > 0) {\r\nspin_unlock(&solo_enc->lock);\r\nreturn -EBUSY;\r\n}\r\nif ((cp->timeperframe.numerator == 0) ||\r\n(cp->timeperframe.denominator == 0)) {\r\ncp->timeperframe.numerator = 1;\r\ncp->timeperframe.denominator = solo_dev->fps;\r\n}\r\nif (cp->timeperframe.denominator != solo_dev->fps)\r\ncp->timeperframe.denominator = solo_dev->fps;\r\nif (cp->timeperframe.numerator > 15)\r\ncp->timeperframe.numerator = 15;\r\nsolo_enc->interval = cp->timeperframe.numerator;\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\nsolo_enc->gop = max(solo_dev->fps / solo_enc->interval, 1);\r\nsolo_update_mode(solo_enc);\r\nspin_unlock(&solo_enc->lock);\r\nreturn 0;\r\n}\r\nstatic int solo_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nqc->id = v4l2_ctrl_next(solo_ctrl_classes, qc->id);\r\nif (!qc->id)\r\nreturn -EINVAL;\r\nswitch (qc->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_CONTRAST:\r\ncase V4L2_CID_SATURATION:\r\ncase V4L2_CID_HUE:\r\nreturn v4l2_ctrl_query_fill(qc, 0x00, 0xff, 1, 0x80);\r\ncase V4L2_CID_SHARPNESS:\r\nreturn v4l2_ctrl_query_fill(qc, 0x00, 0x0f, 1, 0x00);\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nreturn v4l2_ctrl_query_fill(\r\nqc, V4L2_MPEG_VIDEO_ENCODING_MPEG_1,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC, 1,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC);\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nreturn v4l2_ctrl_query_fill(qc, 1, 255, 1, solo_dev->fps);\r\n#ifdef PRIVATE_CIDS\r\ncase V4L2_CID_MOTION_THRESHOLD:\r\nqc->flags |= V4L2_CTRL_FLAG_SLIDER;\r\nqc->type = V4L2_CTRL_TYPE_INTEGER;\r\nqc->minimum = 0;\r\nqc->maximum = 0xffff;\r\nqc->step = 1;\r\nqc->default_value = SOLO_DEF_MOT_THRESH;\r\nstrlcpy(qc->name, "Motion Detection Threshold",\r\nsizeof(qc->name));\r\nreturn 0;\r\ncase V4L2_CID_MOTION_ENABLE:\r\nqc->type = V4L2_CTRL_TYPE_BOOLEAN;\r\nqc->minimum = 0;\r\nqc->maximum = qc->step = 1;\r\nqc->default_value = 0;\r\nstrlcpy(qc->name, "Motion Detection Enable", sizeof(qc->name));\r\nreturn 0;\r\n#else\r\ncase V4L2_CID_MOTION_THRESHOLD:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 0xffff, 1,\r\nSOLO_DEF_MOT_THRESH);\r\ncase V4L2_CID_MOTION_ENABLE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);\r\n#endif\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nqc->type = V4L2_CTRL_TYPE_STRING;\r\nqc->minimum = 0;\r\nqc->maximum = OSD_TEXT_MAX;\r\nqc->step = 1;\r\nqc->default_value = 0;\r\nstrlcpy(qc->name, "OSD Text", sizeof(qc->name));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int solo_querymenu(struct file *file, void *priv,\r\nstruct v4l2_querymenu *qmenu)\r\n{\r\nstruct v4l2_queryctrl qctrl;\r\nint err;\r\nqctrl.id = qmenu->id;\r\nerr = solo_queryctrl(file, priv, &qctrl);\r\nif (err)\r\nreturn err;\r\nreturn v4l2_ctrl_query_menu(qmenu, &qctrl, NULL);\r\n}\r\nstatic int solo_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_CONTRAST:\r\ncase V4L2_CID_SATURATION:\r\ncase V4L2_CID_HUE:\r\ncase V4L2_CID_SHARPNESS:\r\nreturn tw28_get_ctrl_val(solo_dev, ctrl->id, solo_enc->ch,\r\n&ctrl->value);\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nctrl->value = V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nctrl->value = solo_enc->gop;\r\nbreak;\r\ncase V4L2_CID_MOTION_THRESHOLD:\r\nctrl->value = solo_enc->motion_thresh;\r\nbreak;\r\ncase V4L2_CID_MOTION_ENABLE:\r\nctrl->value = solo_is_motion_on(solo_enc);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int solo_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_CONTRAST:\r\ncase V4L2_CID_SATURATION:\r\ncase V4L2_CID_HUE:\r\ncase V4L2_CID_SHARPNESS:\r\nreturn tw28_set_ctrl_val(solo_dev, ctrl->id, solo_enc->ch,\r\nctrl->value);\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nif (ctrl->value != V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC)\r\nreturn -ERANGE;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nif (ctrl->value < 1 || ctrl->value > 255)\r\nreturn -ERANGE;\r\nsolo_enc->gop = ctrl->value;\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP(solo_enc->ch),\r\nsolo_enc->gop);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP_E(solo_enc->ch),\r\nsolo_enc->gop);\r\nbreak;\r\ncase V4L2_CID_MOTION_THRESHOLD:\r\nif (ctrl->value < 0 || ctrl->value > 0xffff)\r\nreturn -ERANGE;\r\nsolo_enc->motion_thresh = ctrl->value;\r\nsolo_set_motion_threshold(solo_dev, solo_enc->ch, ctrl->value);\r\nbreak;\r\ncase V4L2_CID_MOTION_ENABLE:\r\nsolo_motion_toggle(solo_enc, ctrl->value);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int solo_s_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nint i;\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = (ctrls->controls + i);\r\nint err;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nif (ctrl->size - 1 > OSD_TEXT_MAX)\r\nerr = -ERANGE;\r\nelse {\r\nerr = copy_from_user(solo_enc->osd_text,\r\nctrl->string,\r\nOSD_TEXT_MAX);\r\nsolo_enc->osd_text[OSD_TEXT_MAX] = '\0';\r\nif (!err)\r\nerr = solo_osd_print(solo_enc);\r\n}\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (err < 0) {\r\nctrls->error_idx = i;\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int solo_g_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct solo_enc_fh *fh = priv;\r\nstruct solo_enc_dev *solo_enc = fh->enc;\r\nint i;\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = (ctrls->controls + i);\r\nint err;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nif (ctrl->size < OSD_TEXT_MAX) {\r\nctrl->size = OSD_TEXT_MAX;\r\nerr = -ENOSPC;\r\n} else {\r\nerr = copy_to_user(ctrl->string,\r\nsolo_enc->osd_text,\r\nOSD_TEXT_MAX);\r\n}\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (err < 0) {\r\nctrls->error_idx = i;\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct solo_enc_dev *solo_enc_alloc(struct solo_dev *solo_dev, u8 ch)\r\n{\r\nstruct solo_enc_dev *solo_enc;\r\nint ret;\r\nsolo_enc = kzalloc(sizeof(*solo_enc), GFP_KERNEL);\r\nif (!solo_enc)\r\nreturn ERR_PTR(-ENOMEM);\r\nsolo_enc->vfd = video_device_alloc();\r\nif (!solo_enc->vfd) {\r\nkfree(solo_enc);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nsolo_enc->solo_dev = solo_dev;\r\nsolo_enc->ch = ch;\r\n*solo_enc->vfd = solo_enc_template;\r\nsolo_enc->vfd->parent = &solo_dev->pdev->dev;\r\nret = video_register_device(solo_enc->vfd, VFL_TYPE_GRABBER,\r\nvideo_nr);\r\nif (ret < 0) {\r\nvideo_device_release(solo_enc->vfd);\r\nkfree(solo_enc);\r\nreturn ERR_PTR(ret);\r\n}\r\nvideo_set_drvdata(solo_enc->vfd, solo_enc);\r\nsnprintf(solo_enc->vfd->name, sizeof(solo_enc->vfd->name),\r\n"%s-enc (%i/%i)", SOLO6X10_NAME, solo_dev->vfd->num,\r\nsolo_enc->vfd->num);\r\nif (video_nr != -1)\r\nvideo_nr++;\r\nspin_lock_init(&solo_enc->lock);\r\ninit_waitqueue_head(&solo_enc->thread_wait);\r\natomic_set(&solo_enc->readers, 0);\r\nsolo_enc->qp = SOLO_DEFAULT_QP;\r\nsolo_enc->gop = solo_dev->fps;\r\nsolo_enc->interval = 1;\r\nsolo_enc->mode = SOLO_ENC_MODE_CIF;\r\nsolo_enc->motion_thresh = SOLO_DEF_MOT_THRESH;\r\nspin_lock(&solo_enc->lock);\r\nsolo_update_mode(solo_enc);\r\nspin_unlock(&solo_enc->lock);\r\nreturn solo_enc;\r\n}\r\nstatic void solo_enc_free(struct solo_enc_dev *solo_enc)\r\n{\r\nif (solo_enc == NULL)\r\nreturn;\r\nvideo_unregister_device(solo_enc->vfd);\r\nkfree(solo_enc);\r\n}\r\nint solo_enc_v4l2_init(struct solo_dev *solo_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < solo_dev->nr_chans; i++) {\r\nsolo_dev->v4l2_enc[i] = solo_enc_alloc(solo_dev, i);\r\nif (IS_ERR(solo_dev->v4l2_enc[i]))\r\nbreak;\r\n}\r\nif (i != solo_dev->nr_chans) {\r\nint ret = PTR_ERR(solo_dev->v4l2_enc[i]);\r\nwhile (i--)\r\nsolo_enc_free(solo_dev->v4l2_enc[i]);\r\nreturn ret;\r\n}\r\nsolo_dev->enc_bw_remain = solo_dev->fps * 4 * 4;\r\ndev_info(&solo_dev->pdev->dev, "Encoders as /dev/video%d-%d\n",\r\nsolo_dev->v4l2_enc[0]->vfd->num,\r\nsolo_dev->v4l2_enc[solo_dev->nr_chans - 1]->vfd->num);\r\nreturn 0;\r\n}\r\nvoid solo_enc_v4l2_exit(struct solo_dev *solo_dev)\r\n{\r\nint i;\r\nsolo_irq_off(solo_dev, SOLO_IRQ_MOTION);\r\nfor (i = 0; i < solo_dev->nr_chans; i++)\r\nsolo_enc_free(solo_dev->v4l2_enc[i]);\r\n}
