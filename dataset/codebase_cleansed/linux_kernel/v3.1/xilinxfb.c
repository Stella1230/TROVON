static void xilinx_fb_out_be32(struct xilinxfb_drvdata *drvdata, u32 offset,\r\nu32 val)\r\n{\r\nif (drvdata->flags & PLB_ACCESS_FLAG)\r\nout_be32(drvdata->regs + (offset << 2), val);\r\n#ifdef CONFIG_PPC_DCR\r\nelse\r\ndcr_write(drvdata->dcr_host, offset, val);\r\n#endif\r\n}\r\nstatic int\r\nxilinx_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *fbi)\r\n{\r\nu32 *palette = fbi->pseudo_palette;\r\nif (regno >= PALETTE_ENTRIES_NO)\r\nreturn -EINVAL;\r\nif (fbi->var.grayscale) {\r\nred = green = blue =\r\n(red * 77 + green * 151 + blue * 28 + 127) >> 8;\r\n}\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\npalette[regno] = (red << RED_SHIFT) | (green << GREEN_SHIFT) |\r\n(blue << BLUE_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int\r\nxilinx_fb_blank(int blank_mode, struct fb_info *fbi)\r\n{\r\nstruct xilinxfb_drvdata *drvdata = to_xilinxfb_drvdata(fbi);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nxilinx_fb_out_be32(drvdata, REG_CTRL, drvdata->reg_ctrl_default);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nxilinx_fb_out_be32(drvdata, REG_CTRL, 0);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xilinxfb_assign(struct device *dev,\r\nstruct xilinxfb_drvdata *drvdata,\r\nunsigned long physaddr,\r\nstruct xilinxfb_platform_data *pdata)\r\n{\r\nint rc;\r\nint fbsize = pdata->xvirt * pdata->yvirt * BYTES_PER_PIXEL;\r\nif (drvdata->flags & PLB_ACCESS_FLAG) {\r\nif (!request_mem_region(physaddr, 8, DRIVER_NAME)) {\r\ndev_err(dev, "Couldn't lock memory region at 0x%08lX\n",\r\nphysaddr);\r\nrc = -ENODEV;\r\ngoto err_region;\r\n}\r\ndrvdata->regs_phys = physaddr;\r\ndrvdata->regs = ioremap(physaddr, 8);\r\nif (!drvdata->regs) {\r\ndev_err(dev, "Couldn't lock memory region at 0x%08lX\n",\r\nphysaddr);\r\nrc = -ENODEV;\r\ngoto err_map;\r\n}\r\n}\r\nif (pdata->fb_phys) {\r\ndrvdata->fb_phys = pdata->fb_phys;\r\ndrvdata->fb_virt = ioremap(pdata->fb_phys, fbsize);\r\n} else {\r\ndrvdata->fb_alloced = 1;\r\ndrvdata->fb_virt = dma_alloc_coherent(dev, PAGE_ALIGN(fbsize),\r\n&drvdata->fb_phys, GFP_KERNEL);\r\n}\r\nif (!drvdata->fb_virt) {\r\ndev_err(dev, "Could not allocate frame buffer memory\n");\r\nrc = -ENOMEM;\r\nif (drvdata->flags & PLB_ACCESS_FLAG)\r\ngoto err_fbmem;\r\nelse\r\ngoto err_region;\r\n}\r\nmemset_io((void __iomem *)drvdata->fb_virt, 0, fbsize);\r\nxilinx_fb_out_be32(drvdata, REG_FB_ADDR, drvdata->fb_phys);\r\ndrvdata->reg_ctrl_default = REG_CTRL_ENABLE;\r\nif (pdata->rotate_screen)\r\ndrvdata->reg_ctrl_default |= REG_CTRL_ROTATE;\r\nxilinx_fb_out_be32(drvdata, REG_CTRL,\r\ndrvdata->reg_ctrl_default);\r\ndrvdata->info.device = dev;\r\ndrvdata->info.screen_base = (void __iomem *)drvdata->fb_virt;\r\ndrvdata->info.fbops = &xilinxfb_ops;\r\ndrvdata->info.fix = xilinx_fb_fix;\r\ndrvdata->info.fix.smem_start = drvdata->fb_phys;\r\ndrvdata->info.fix.smem_len = fbsize;\r\ndrvdata->info.fix.line_length = pdata->xvirt * BYTES_PER_PIXEL;\r\ndrvdata->info.pseudo_palette = drvdata->pseudo_palette;\r\ndrvdata->info.flags = FBINFO_DEFAULT;\r\ndrvdata->info.var = xilinx_fb_var;\r\ndrvdata->info.var.height = pdata->screen_height_mm;\r\ndrvdata->info.var.width = pdata->screen_width_mm;\r\ndrvdata->info.var.xres = pdata->xres;\r\ndrvdata->info.var.yres = pdata->yres;\r\ndrvdata->info.var.xres_virtual = pdata->xvirt;\r\ndrvdata->info.var.yres_virtual = pdata->yvirt;\r\nrc = fb_alloc_cmap(&drvdata->info.cmap, PALETTE_ENTRIES_NO, 0);\r\nif (rc) {\r\ndev_err(dev, "Fail to allocate colormap (%d entries)\n",\r\nPALETTE_ENTRIES_NO);\r\ngoto err_cmap;\r\n}\r\nrc = register_framebuffer(&drvdata->info);\r\nif (rc) {\r\ndev_err(dev, "Could not register frame buffer\n");\r\ngoto err_regfb;\r\n}\r\nif (drvdata->flags & PLB_ACCESS_FLAG) {\r\ndev_dbg(dev, "regs: phys=%lx, virt=%p\n", physaddr,\r\ndrvdata->regs);\r\n}\r\ndev_dbg(dev, "fb: phys=%llx, virt=%p, size=%x\n",\r\n(unsigned long long)drvdata->fb_phys, drvdata->fb_virt, fbsize);\r\nreturn 0;\r\nerr_regfb:\r\nfb_dealloc_cmap(&drvdata->info.cmap);\r\nerr_cmap:\r\nif (drvdata->fb_alloced)\r\ndma_free_coherent(dev, PAGE_ALIGN(fbsize), drvdata->fb_virt,\r\ndrvdata->fb_phys);\r\nelse\r\niounmap(drvdata->fb_virt);\r\nxilinx_fb_out_be32(drvdata, REG_CTRL, 0);\r\nerr_fbmem:\r\nif (drvdata->flags & PLB_ACCESS_FLAG)\r\niounmap(drvdata->regs);\r\nerr_map:\r\nif (drvdata->flags & PLB_ACCESS_FLAG)\r\nrelease_mem_region(physaddr, 8);\r\nerr_region:\r\nkfree(drvdata);\r\ndev_set_drvdata(dev, NULL);\r\nreturn rc;\r\n}\r\nstatic int xilinxfb_release(struct device *dev)\r\n{\r\nstruct xilinxfb_drvdata *drvdata = dev_get_drvdata(dev);\r\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\r\nxilinx_fb_blank(VESA_POWERDOWN, &drvdata->info);\r\n#endif\r\nunregister_framebuffer(&drvdata->info);\r\nfb_dealloc_cmap(&drvdata->info.cmap);\r\nif (drvdata->fb_alloced)\r\ndma_free_coherent(dev, PAGE_ALIGN(drvdata->info.fix.smem_len),\r\ndrvdata->fb_virt, drvdata->fb_phys);\r\nelse\r\niounmap(drvdata->fb_virt);\r\nxilinx_fb_out_be32(drvdata, REG_CTRL, 0);\r\nif (drvdata->flags & PLB_ACCESS_FLAG) {\r\niounmap(drvdata->regs);\r\nrelease_mem_region(drvdata->regs_phys, 8);\r\n}\r\n#ifdef CONFIG_PPC_DCR\r\nelse\r\ndcr_unmap(drvdata->dcr_host, drvdata->dcr_len);\r\n#endif\r\nkfree(drvdata);\r\ndev_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __devinit xilinxfb_of_probe(struct platform_device *op)\r\n{\r\nconst u32 *prop;\r\nu32 *p;\r\nu32 tft_access;\r\nstruct xilinxfb_platform_data pdata;\r\nstruct resource res;\r\nint size, rc;\r\nstruct xilinxfb_drvdata *drvdata;\r\npdata = xilinx_fb_default_pdata;\r\ndrvdata = kzalloc(sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata) {\r\ndev_err(&op->dev, "Couldn't allocate device private record\n");\r\nreturn -ENOMEM;\r\n}\r\np = (u32 *)of_get_property(op->dev.of_node, "xlnx,dcr-splb-slave-if", NULL);\r\ntft_access = p ? *p : 0;\r\nif (tft_access) {\r\ndrvdata->flags |= PLB_ACCESS_FLAG;\r\nrc = of_address_to_resource(op->dev.of_node, 0, &res);\r\nif (rc) {\r\ndev_err(&op->dev, "invalid address\n");\r\ngoto err;\r\n}\r\n}\r\n#ifdef CONFIG_PPC_DCR\r\nelse {\r\nint start;\r\nres.start = 0;\r\nstart = dcr_resource_start(op->dev.of_node, 0);\r\ndrvdata->dcr_len = dcr_resource_len(op->dev.of_node, 0);\r\ndrvdata->dcr_host = dcr_map(op->dev.of_node, start, drvdata->dcr_len);\r\nif (!DCR_MAP_OK(drvdata->dcr_host)) {\r\ndev_err(&op->dev, "invalid DCR address\n");\r\ngoto err;\r\n}\r\n}\r\n#endif\r\nprop = of_get_property(op->dev.of_node, "phys-size", &size);\r\nif ((prop) && (size >= sizeof(u32)*2)) {\r\npdata.screen_width_mm = prop[0];\r\npdata.screen_height_mm = prop[1];\r\n}\r\nprop = of_get_property(op->dev.of_node, "resolution", &size);\r\nif ((prop) && (size >= sizeof(u32)*2)) {\r\npdata.xres = prop[0];\r\npdata.yres = prop[1];\r\n}\r\nprop = of_get_property(op->dev.of_node, "virtual-resolution", &size);\r\nif ((prop) && (size >= sizeof(u32)*2)) {\r\npdata.xvirt = prop[0];\r\npdata.yvirt = prop[1];\r\n}\r\nif (of_find_property(op->dev.of_node, "rotate-display", NULL))\r\npdata.rotate_screen = 1;\r\ndev_set_drvdata(&op->dev, drvdata);\r\nreturn xilinxfb_assign(&op->dev, drvdata, res.start, &pdata);\r\nerr:\r\nkfree(drvdata);\r\nreturn -ENODEV;\r\n}\r\nstatic int __devexit xilinxfb_of_remove(struct platform_device *op)\r\n{\r\nreturn xilinxfb_release(&op->dev);\r\n}\r\nstatic int __init\r\nxilinxfb_init(void)\r\n{\r\nreturn platform_driver_register(&xilinxfb_of_driver);\r\n}\r\nstatic void __exit\r\nxilinxfb_cleanup(void)\r\n{\r\nplatform_driver_unregister(&xilinxfb_of_driver);\r\n}
