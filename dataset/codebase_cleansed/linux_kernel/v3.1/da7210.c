static inline u32 da7210_read_reg_cache(struct snd_soc_codec *codec, u32 reg)\r\n{\r\nu8 *cache = codec->reg_cache;\r\nBUG_ON(reg >= ARRAY_SIZE(da7210_reg));\r\nreturn cache[reg];\r\n}\r\nstatic int da7210_write(struct snd_soc_codec *codec, u32 reg, u32 value)\r\n{\r\nu8 *cache = codec->reg_cache;\r\nu8 data[2];\r\nBUG_ON(codec->driver->volatile_register);\r\ndata[0] = reg & 0xff;\r\ndata[1] = value & 0xff;\r\nif (reg >= codec->driver->reg_cache_size)\r\nreturn -EIO;\r\nif (2 != codec->hw_write(codec->control_data, data, 2))\r\nreturn -EIO;\r\ncache[reg] = value;\r\nreturn 0;\r\n}\r\nstatic inline u32 da7210_read(struct snd_soc_codec *codec, u32 reg)\r\n{\r\nif (DA7210_STATUS == reg)\r\nreturn i2c_smbus_read_byte_data(codec->control_data, reg);\r\nreturn da7210_read_reg_cache(codec, reg);\r\n}\r\nstatic int da7210_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (is_play) {\r\nsnd_soc_update_bits(codec, DA7210_OUTMIX_L, 0x1F, 0x10);\r\nsnd_soc_update_bits(codec, DA7210_OUTMIX_R, 0x1F, 0x10);\r\n} else {\r\nsnd_soc_update_bits(codec, DA7210_MIC_L, 0x7, 0x7);\r\nsnd_soc_update_bits(codec, DA7210_MIC_R, 0x7, 0x7);\r\nsnd_soc_update_bits(codec, DA7210_INMIX_L, 0x1F, 0x1);\r\nsnd_soc_update_bits(codec, DA7210_INMIX_R, 0x1F, 0x1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int da7210_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nu32 dai_cfg1;\r\nu32 hpf_reg, hpf_mask, hpf_value;\r\nu32 fs, bypass;\r\nda7210_write(codec, DA7210_DAI_SRC_SEL,\r\nDA7210_DAI_OUT_R_SRC | DA7210_DAI_OUT_L_SRC);\r\nda7210_write(codec, DA7210_DAI_CFG3, DA7210_DAI_OE | DA7210_DAI_EN);\r\ndai_cfg1 = 0xFC & da7210_read(codec, DA7210_DAI_CFG1);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndai_cfg1 |= DA7210_DAI_WORD_S16_LE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ndai_cfg1 |= DA7210_DAI_WORD_S24_LE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nda7210_write(codec, DA7210_DAI_CFG1, dai_cfg1);\r\nhpf_reg = (SNDRV_PCM_STREAM_PLAYBACK == substream->stream) ?\r\nDA7210_DAC_HPF : DA7210_ADC_HPF;\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nfs = DA7210_PLL_FS_8000;\r\nhpf_mask = DA7210_VOICE_F0_MASK | DA7210_VOICE_EN;\r\nhpf_value = DA7210_VOICE_F0_25 | DA7210_VOICE_EN;\r\nbypass = DA7210_PLL_BYP;\r\nbreak;\r\ncase 11025:\r\nfs = DA7210_PLL_FS_11025;\r\nhpf_mask = DA7210_VOICE_F0_MASK | DA7210_VOICE_EN;\r\nhpf_value = DA7210_VOICE_F0_25 | DA7210_VOICE_EN;\r\nbypass = 0;\r\nbreak;\r\ncase 12000:\r\nfs = DA7210_PLL_FS_12000;\r\nhpf_mask = DA7210_VOICE_F0_MASK | DA7210_VOICE_EN;\r\nhpf_value = DA7210_VOICE_F0_25 | DA7210_VOICE_EN;\r\nbypass = DA7210_PLL_BYP;\r\nbreak;\r\ncase 16000:\r\nfs = DA7210_PLL_FS_16000;\r\nhpf_mask = DA7210_VOICE_F0_MASK | DA7210_VOICE_EN;\r\nhpf_value = DA7210_VOICE_F0_25 | DA7210_VOICE_EN;\r\nbypass = DA7210_PLL_BYP;\r\nbreak;\r\ncase 22050:\r\nfs = DA7210_PLL_FS_22050;\r\nhpf_mask = DA7210_VOICE_EN;\r\nhpf_value = 0;\r\nbypass = 0;\r\nbreak;\r\ncase 32000:\r\nfs = DA7210_PLL_FS_32000;\r\nhpf_mask = DA7210_VOICE_EN;\r\nhpf_value = 0;\r\nbypass = DA7210_PLL_BYP;\r\nbreak;\r\ncase 44100:\r\nfs = DA7210_PLL_FS_44100;\r\nhpf_mask = DA7210_VOICE_EN;\r\nhpf_value = 0;\r\nbypass = 0;\r\nbreak;\r\ncase 48000:\r\nfs = DA7210_PLL_FS_48000;\r\nhpf_mask = DA7210_VOICE_EN;\r\nhpf_value = 0;\r\nbypass = DA7210_PLL_BYP;\r\nbreak;\r\ncase 88200:\r\nfs = DA7210_PLL_FS_88200;\r\nhpf_mask = DA7210_VOICE_EN;\r\nhpf_value = 0;\r\nbypass = 0;\r\nbreak;\r\ncase 96000:\r\nfs = DA7210_PLL_FS_96000;\r\nhpf_mask = DA7210_VOICE_EN;\r\nhpf_value = 0;\r\nbypass = DA7210_PLL_BYP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, DA7210_STARTUP1, DA7210_SC_MST_EN, 0);\r\nsnd_soc_update_bits(codec, hpf_reg, hpf_mask, hpf_value);\r\nsnd_soc_update_bits(codec, DA7210_PLL, DA7210_PLL_FS_MASK, fs);\r\nsnd_soc_update_bits(codec, DA7210_PLL_DIV3, DA7210_PLL_BYP, bypass);\r\nsnd_soc_update_bits(codec, DA7210_STARTUP1,\r\nDA7210_SC_MST_EN, DA7210_SC_MST_EN);\r\nreturn 0;\r\n}\r\nstatic int da7210_set_dai_fmt(struct snd_soc_dai *codec_dai, u32 fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu32 dai_cfg1;\r\nu32 dai_cfg3;\r\ndai_cfg1 = 0x7f & da7210_read(codec, DA7210_DAI_CFG1);\r\ndai_cfg3 = 0xfc & da7210_read(codec, DA7210_DAI_CFG3);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ndai_cfg1 |= DA7210_DAI_MODE_MASTER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ndai_cfg3 |= DA7210_DAI_FORMAT_I2SMODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndai_cfg1 |= DA7210_DAI_FLEN_64BIT;\r\nda7210_write(codec, DA7210_DAI_CFG1, dai_cfg1);\r\nda7210_write(codec, DA7210_DAI_CFG3, dai_cfg3);\r\nreturn 0;\r\n}\r\nstatic int da7210_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct da7210_priv *da7210 = snd_soc_codec_get_drvdata(codec);\r\ndev_info(codec->dev, "DA7210 Audio Codec %s\n", DA7210_VERSION);\r\ncodec->control_data = da7210->control_data;\r\ncodec->hw_write = (hw_write_t)i2c_master_send;\r\nda7210_write(codec, DA7210_STARTUP1, 0);\r\nda7210_write(codec, DA7210_PLL_DIV3,\r\nDA7210_MCLK_RANGE_10_20_MHZ | DA7210_PLL_BYP);\r\nda7210_write(codec, DA7210_MIC_L, DA7210_MIC_L_EN | DA7210_MICBIAS_EN);\r\nda7210_write(codec, DA7210_MIC_R, DA7210_MIC_R_EN);\r\nda7210_write(codec, DA7210_INMIX_L, DA7210_IN_L_EN);\r\nda7210_write(codec, DA7210_INMIX_R, DA7210_IN_R_EN);\r\nda7210_write(codec, DA7210_ADC, DA7210_ADC_L_EN | DA7210_ADC_R_EN);\r\nda7210_write(codec, DA7210_DAC_SEL,\r\nDA7210_DAC_L_SRC_DAI_L | DA7210_DAC_L_EN |\r\nDA7210_DAC_R_SRC_DAI_R | DA7210_DAC_R_EN);\r\nda7210_write(codec, DA7210_OUTMIX_L, DA7210_OUT_L_EN);\r\nda7210_write(codec, DA7210_OUTMIX_R, DA7210_OUT_R_EN);\r\nda7210_write(codec, DA7210_HP_CFG,\r\nDA7210_HP_2CAP_MODE | DA7210_HP_SENSE_EN |\r\nDA7210_HP_L_EN | DA7210_HP_MODE | DA7210_HP_R_EN);\r\nda7210_write(codec, DA7210_PLL, DA7210_PLL_FS_48000);\r\nda7210_write(codec, DA7210_PLL_DIV1, 0xE5);\r\nda7210_write(codec, DA7210_PLL_DIV2, 0x99);\r\nda7210_write(codec, DA7210_PLL_DIV3, 0x0A |\r\nDA7210_MCLK_RANGE_10_20_MHZ | DA7210_PLL_BYP);\r\nsnd_soc_update_bits(codec, DA7210_PLL, DA7210_PLL_EN, DA7210_PLL_EN);\r\nda7210_write(codec, DA7210_A_HID_UNLOCK, 0x8B);\r\nda7210_write(codec, DA7210_A_TEST_UNLOCK, 0xB4);\r\nda7210_write(codec, DA7210_A_PLL1, 0x01);\r\nda7210_write(codec, DA7210_A_CP_MODE, 0x7C);\r\nda7210_write(codec, DA7210_A_HID_UNLOCK, 0x00);\r\nda7210_write(codec, DA7210_A_TEST_UNLOCK, 0x00);\r\nda7210_write(codec, DA7210_STARTUP1, DA7210_SC_MST_EN);\r\nsnd_soc_add_controls(codec, da7210_snd_controls,\r\nARRAY_SIZE(da7210_snd_controls));\r\ndev_info(codec->dev, "DA7210 Audio Codec %s\n", DA7210_VERSION);\r\nreturn 0;\r\n}\r\nstatic int __devinit da7210_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da7210_priv *da7210;\r\nint ret;\r\nda7210 = kzalloc(sizeof(struct da7210_priv), GFP_KERNEL);\r\nif (!da7210)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, da7210);\r\nda7210->control_data = i2c;\r\nda7210->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_da7210, &da7210_dai, 1);\r\nif (ret < 0)\r\nkfree(da7210);\r\nreturn ret;\r\n}\r\nstatic int __devexit da7210_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int __init da7210_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&da7210_i2c_driver);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit da7210_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&da7210_i2c_driver);\r\n#endif\r\n}
