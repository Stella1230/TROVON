void get_filesystem(struct file_system_type *fs)\r\n{\r\n__module_get(fs->owner);\r\n}\r\nvoid put_filesystem(struct file_system_type *fs)\r\n{\r\nmodule_put(fs->owner);\r\n}\r\nstatic struct file_system_type **find_filesystem(const char *name, unsigned len)\r\n{\r\nstruct file_system_type **p;\r\nfor (p=&file_systems; *p; p=&(*p)->next)\r\nif (strlen((*p)->name) == len &&\r\nstrncmp((*p)->name, name, len) == 0)\r\nbreak;\r\nreturn p;\r\n}\r\nint register_filesystem(struct file_system_type * fs)\r\n{\r\nint res = 0;\r\nstruct file_system_type ** p;\r\nBUG_ON(strchr(fs->name, '.'));\r\nif (fs->next)\r\nreturn -EBUSY;\r\nINIT_LIST_HEAD(&fs->fs_supers);\r\nwrite_lock(&file_systems_lock);\r\np = find_filesystem(fs->name, strlen(fs->name));\r\nif (*p)\r\nres = -EBUSY;\r\nelse\r\n*p = fs;\r\nwrite_unlock(&file_systems_lock);\r\nreturn res;\r\n}\r\nint unregister_filesystem(struct file_system_type * fs)\r\n{\r\nstruct file_system_type ** tmp;\r\nwrite_lock(&file_systems_lock);\r\ntmp = &file_systems;\r\nwhile (*tmp) {\r\nif (fs == *tmp) {\r\n*tmp = fs->next;\r\nfs->next = NULL;\r\nwrite_unlock(&file_systems_lock);\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\ntmp = &(*tmp)->next;\r\n}\r\nwrite_unlock(&file_systems_lock);\r\nreturn -EINVAL;\r\n}\r\nstatic int fs_index(const char __user * __name)\r\n{\r\nstruct file_system_type * tmp;\r\nchar * name;\r\nint err, index;\r\nname = getname(__name);\r\nerr = PTR_ERR(name);\r\nif (IS_ERR(name))\r\nreturn err;\r\nerr = -EINVAL;\r\nread_lock(&file_systems_lock);\r\nfor (tmp=file_systems, index=0 ; tmp ; tmp=tmp->next, index++) {\r\nif (strcmp(tmp->name,name) == 0) {\r\nerr = index;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&file_systems_lock);\r\nputname(name);\r\nreturn err;\r\n}\r\nstatic int fs_name(unsigned int index, char __user * buf)\r\n{\r\nstruct file_system_type * tmp;\r\nint len, res;\r\nread_lock(&file_systems_lock);\r\nfor (tmp = file_systems; tmp; tmp = tmp->next, index--)\r\nif (index <= 0 && try_module_get(tmp->owner))\r\nbreak;\r\nread_unlock(&file_systems_lock);\r\nif (!tmp)\r\nreturn -EINVAL;\r\nlen = strlen(tmp->name) + 1;\r\nres = copy_to_user(buf, tmp->name, len) ? -EFAULT : 0;\r\nput_filesystem(tmp);\r\nreturn res;\r\n}\r\nstatic int fs_maxindex(void)\r\n{\r\nstruct file_system_type * tmp;\r\nint index;\r\nread_lock(&file_systems_lock);\r\nfor (tmp = file_systems, index = 0 ; tmp ; tmp = tmp->next, index++)\r\n;\r\nread_unlock(&file_systems_lock);\r\nreturn index;\r\n}\r\nint __init get_filesystem_list(char *buf)\r\n{\r\nint len = 0;\r\nstruct file_system_type * tmp;\r\nread_lock(&file_systems_lock);\r\ntmp = file_systems;\r\nwhile (tmp && len < PAGE_SIZE - 80) {\r\nlen += sprintf(buf+len, "%s\t%s\n",\r\n(tmp->fs_flags & FS_REQUIRES_DEV) ? "" : "nodev",\r\ntmp->name);\r\ntmp = tmp->next;\r\n}\r\nread_unlock(&file_systems_lock);\r\nreturn len;\r\n}\r\nstatic int filesystems_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct file_system_type * tmp;\r\nread_lock(&file_systems_lock);\r\ntmp = file_systems;\r\nwhile (tmp) {\r\nseq_printf(m, "%s\t%s\n",\r\n(tmp->fs_flags & FS_REQUIRES_DEV) ? "" : "nodev",\r\ntmp->name);\r\ntmp = tmp->next;\r\n}\r\nread_unlock(&file_systems_lock);\r\nreturn 0;\r\n}\r\nstatic int filesystems_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, filesystems_proc_show, NULL);\r\n}\r\nstatic int __init proc_filesystems_init(void)\r\n{\r\nproc_create("filesystems", 0, NULL, &filesystems_proc_fops);\r\nreturn 0;\r\n}\r\nstatic struct file_system_type *__get_fs_type(const char *name, int len)\r\n{\r\nstruct file_system_type *fs;\r\nread_lock(&file_systems_lock);\r\nfs = *(find_filesystem(name, len));\r\nif (fs && !try_module_get(fs->owner))\r\nfs = NULL;\r\nread_unlock(&file_systems_lock);\r\nreturn fs;\r\n}\r\nstruct file_system_type *get_fs_type(const char *name)\r\n{\r\nstruct file_system_type *fs;\r\nconst char *dot = strchr(name, '.');\r\nint len = dot ? dot - name : strlen(name);\r\nfs = __get_fs_type(name, len);\r\nif (!fs && (request_module("%.*s", len, name) == 0))\r\nfs = __get_fs_type(name, len);\r\nif (dot && fs && !(fs->fs_flags & FS_HAS_SUBTYPE)) {\r\nput_filesystem(fs);\r\nfs = NULL;\r\n}\r\nreturn fs;\r\n}
