static void adx_wdt_start_locked(struct adx_wdt *wdt)\r\n{\r\nu32 ctrl;\r\nctrl = readl(wdt->base + ADX_WDT_CONTROL);\r\nctrl |= ADX_WDT_CONTROL_ENABLE;\r\nwritel(ctrl, wdt->base + ADX_WDT_CONTROL);\r\nwdt->state = WDT_STATE_START;\r\n}\r\nstatic void adx_wdt_start(struct adx_wdt *wdt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nadx_wdt_start_locked(wdt);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\n}\r\nstatic void adx_wdt_stop_locked(struct adx_wdt *wdt)\r\n{\r\nu32 ctrl;\r\nctrl = readl(wdt->base + ADX_WDT_CONTROL);\r\nctrl &= ~ADX_WDT_CONTROL_ENABLE;\r\nwritel(ctrl, wdt->base + ADX_WDT_CONTROL);\r\nwdt->state = WDT_STATE_STOP;\r\n}\r\nstatic void adx_wdt_stop(struct adx_wdt *wdt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nadx_wdt_stop_locked(wdt);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\n}\r\nstatic void adx_wdt_set_timeout(struct adx_wdt *wdt, unsigned long seconds)\r\n{\r\nunsigned long timeout = seconds * 1000;\r\nunsigned long flags;\r\nunsigned int state;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nstate = wdt->state;\r\nadx_wdt_stop_locked(wdt);\r\nwritel(timeout, wdt->base + ADX_WDT_TIMEOUT);\r\nif (state == WDT_STATE_START)\r\nadx_wdt_start_locked(wdt);\r\nwdt->timeout = timeout;\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\n}\r\nstatic void adx_wdt_get_timeout(struct adx_wdt *wdt, unsigned long *seconds)\r\n{\r\n*seconds = wdt->timeout / 1000;\r\n}\r\nstatic void adx_wdt_keepalive(struct adx_wdt *wdt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nwritel(wdt->timeout, wdt->base + ADX_WDT_TIMEOUT);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\n}\r\nstatic int adx_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nstruct adx_wdt *wdt = platform_get_drvdata(adx_wdt_dev);\r\nif (test_and_set_bit(0, &driver_open))\r\nreturn -EBUSY;\r\nfile->private_data = wdt;\r\nadx_wdt_set_timeout(wdt, 30);\r\nadx_wdt_start(wdt);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int adx_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nstruct adx_wdt *wdt = file->private_data;\r\nadx_wdt_stop(wdt);\r\nclear_bit(0, &driver_open);\r\nreturn 0;\r\n}\r\nstatic long adx_wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct adx_wdt *wdt = file->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nunsigned long __user *p = argp;\r\nunsigned long seconds = 0;\r\nunsigned int options;\r\nlong ret = -EINVAL;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &adx_wdt_info, sizeof(adx_wdt_info)))\r\nreturn -EFAULT;\r\nelse\r\nreturn 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nadx_wdt_keepalive(wdt);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(seconds, p))\r\nreturn -EFAULT;\r\nadx_wdt_set_timeout(wdt, seconds);\r\ncase WDIOC_GETTIMEOUT:\r\nadx_wdt_get_timeout(wdt, &seconds);\r\nreturn put_user(seconds, p);\r\ncase WDIOC_SETOPTIONS:\r\nif (copy_from_user(&options, argp, sizeof(options)))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nadx_wdt_stop(wdt);\r\nret = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nadx_wdt_start(wdt);\r\nret = 0;\r\n}\r\nreturn ret;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic ssize_t adx_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct adx_wdt *wdt = file->private_data;\r\nif (len)\r\nadx_wdt_keepalive(wdt);\r\nreturn len;\r\n}\r\nstatic int __devinit adx_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct adx_wdt *wdt;\r\nint ret = 0;\r\nu32 ctrl;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt) {\r\ndev_err(&pdev->dev, "cannot allocate WDT structure\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&wdt->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot obtain I/O memory region\n");\r\nreturn -ENXIO;\r\n}\r\nres = devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), res->name);\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot request I/O memory region\n");\r\nreturn -ENXIO;\r\n}\r\nwdt->base = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!wdt->base) {\r\ndev_err(&pdev->dev, "cannot remap I/O memory region\n");\r\nreturn -ENXIO;\r\n}\r\nctrl = readl(wdt->base + ADX_WDT_CONTROL);\r\nctrl &= ~ADX_WDT_CONTROL_ENABLE;\r\nctrl &= ~ADX_WDT_CONTROL_nRESET;\r\nwritel(ctrl, wdt->base + ADX_WDT_CONTROL);\r\nplatform_set_drvdata(pdev, wdt);\r\nadx_wdt_dev = pdev;\r\nret = misc_register(&adx_wdt_miscdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot register miscdev on minor %d "\r\n"(err=%d)\n", WATCHDOG_MINOR, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit adx_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct adx_wdt *wdt = platform_get_drvdata(pdev);\r\nmisc_deregister(&adx_wdt_miscdev);\r\nadx_wdt_stop(wdt);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic void adx_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct adx_wdt *wdt = platform_get_drvdata(pdev);\r\nadx_wdt_stop(wdt);\r\n}\r\nstatic int adx_wdt_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct adx_wdt *wdt = platform_get_drvdata(pdev);\r\nwdt->wake = (wdt->state == WDT_STATE_START) ? 1 : 0;\r\nadx_wdt_stop(wdt);\r\nreturn 0;\r\n}\r\nstatic int adx_wdt_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct adx_wdt *wdt = platform_get_drvdata(pdev);\r\nif (wdt->wake)\r\nadx_wdt_start(wdt);\r\nreturn 0;\r\n}\r\nstatic int __init adx_wdt_init(void)\r\n{\r\nreturn platform_driver_register(&adx_wdt_driver);\r\n}\r\nstatic void __exit adx_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&adx_wdt_driver);\r\n}
