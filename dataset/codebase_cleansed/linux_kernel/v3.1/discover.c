static struct sk_buff *tipc_disc_init_msg(u32 type,\r\nu32 dest_domain,\r\nstruct tipc_bearer *b_ptr)\r\n{\r\nstruct sk_buff *buf = tipc_buf_acquire(INT_H_SIZE);\r\nstruct tipc_msg *msg;\r\nif (buf) {\r\nmsg = buf_msg(buf);\r\ntipc_msg_init(msg, LINK_CONFIG, type, INT_H_SIZE, dest_domain);\r\nmsg_set_non_seq(msg, 1);\r\nmsg_set_dest_domain(msg, dest_domain);\r\nmsg_set_bc_netid(msg, tipc_net_id);\r\nmsg_set_media_addr(msg, &b_ptr->addr);\r\n}\r\nreturn buf;\r\n}\r\nstatic void disc_dupl_alert(struct tipc_bearer *b_ptr, u32 node_addr,\r\nstruct tipc_media_addr *media_addr)\r\n{\r\nchar node_addr_str[16];\r\nchar media_addr_str[64];\r\nstruct print_buf pb;\r\ntipc_addr_string_fill(node_addr_str, node_addr);\r\ntipc_printbuf_init(&pb, media_addr_str, sizeof(media_addr_str));\r\ntipc_media_addr_printf(&pb, media_addr);\r\ntipc_printbuf_validate(&pb);\r\nwarn("Duplicate %s using %s seen on <%s>\n",\r\nnode_addr_str, media_addr_str, b_ptr->name);\r\n}\r\nvoid tipc_disc_recv_msg(struct sk_buff *buf, struct tipc_bearer *b_ptr)\r\n{\r\nstruct tipc_node *n_ptr;\r\nstruct link *link;\r\nstruct tipc_media_addr media_addr, *addr;\r\nstruct sk_buff *rbuf;\r\nstruct tipc_msg *msg = buf_msg(buf);\r\nu32 dest = msg_dest_domain(msg);\r\nu32 orig = msg_prevnode(msg);\r\nu32 net_id = msg_bc_netid(msg);\r\nu32 type = msg_type(msg);\r\nint link_fully_up;\r\nmsg_get_media_addr(msg, &media_addr);\r\nbuf_discard(buf);\r\nif (net_id != tipc_net_id)\r\nreturn;\r\nif (!tipc_addr_domain_valid(dest))\r\nreturn;\r\nif (!tipc_addr_node_valid(orig))\r\nreturn;\r\nif (orig == tipc_own_addr) {\r\nif (memcmp(&media_addr, &b_ptr->addr, sizeof(media_addr)))\r\ndisc_dupl_alert(b_ptr, tipc_own_addr, &media_addr);\r\nreturn;\r\n}\r\nif (!tipc_in_scope(dest, tipc_own_addr))\r\nreturn;\r\nif (!tipc_in_scope(b_ptr->link_req->domain, orig))\r\nreturn;\r\nn_ptr = tipc_node_find(orig);\r\nif (!n_ptr) {\r\nn_ptr = tipc_node_create(orig);\r\nif (!n_ptr)\r\nreturn;\r\n}\r\ntipc_node_lock(n_ptr);\r\nif (n_ptr->cleanup_required) {\r\ntipc_node_unlock(n_ptr);\r\nreturn;\r\n}\r\nlink = n_ptr->links[b_ptr->identity];\r\nif (!link) {\r\nlink = tipc_link_create(n_ptr, b_ptr, &media_addr);\r\nif (!link) {\r\ntipc_node_unlock(n_ptr);\r\nreturn;\r\n}\r\n}\r\naddr = &link->media_addr;\r\nif (memcmp(addr, &media_addr, sizeof(*addr))) {\r\nif (tipc_link_is_up(link) || (!link->started)) {\r\ndisc_dupl_alert(b_ptr, orig, &media_addr);\r\ntipc_node_unlock(n_ptr);\r\nreturn;\r\n}\r\nwarn("Resetting link <%s>, peer interface address changed\n",\r\nlink->name);\r\nmemcpy(addr, &media_addr, sizeof(*addr));\r\ntipc_link_reset(link);\r\n}\r\nlink_fully_up = link_working_working(link);\r\nif ((type == DSC_REQ_MSG) && !link_fully_up && !b_ptr->blocked) {\r\nrbuf = tipc_disc_init_msg(DSC_RESP_MSG, orig, b_ptr);\r\nif (rbuf) {\r\nb_ptr->media->send_msg(rbuf, b_ptr, &media_addr);\r\nbuf_discard(rbuf);\r\n}\r\n}\r\ntipc_node_unlock(n_ptr);\r\n}\r\nstatic void disc_update(struct link_req *req)\r\n{\r\nif (!req->num_nodes) {\r\nif ((req->timer_intv == TIPC_LINK_REQ_INACTIVE) ||\r\n(req->timer_intv > TIPC_LINK_REQ_FAST)) {\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nk_start_timer(&req->timer, req->timer_intv);\r\n}\r\n}\r\n}\r\nvoid tipc_disc_add_dest(struct link_req *req)\r\n{\r\nreq->num_nodes++;\r\n}\r\nvoid tipc_disc_remove_dest(struct link_req *req)\r\n{\r\nreq->num_nodes--;\r\ndisc_update(req);\r\n}\r\nstatic void disc_send_msg(struct link_req *req)\r\n{\r\nif (!req->bearer->blocked)\r\ntipc_bearer_send(req->bearer, req->buf, &req->dest);\r\n}\r\nstatic void disc_timeout(struct link_req *req)\r\n{\r\nint max_delay;\r\nspin_lock_bh(&req->bearer->lock);\r\nif (tipc_node(req->domain) && req->num_nodes) {\r\nreq->timer_intv = TIPC_LINK_REQ_INACTIVE;\r\ngoto exit;\r\n}\r\ndisc_send_msg(req);\r\nreq->timer_intv *= 2;\r\nif (req->num_nodes)\r\nmax_delay = TIPC_LINK_REQ_SLOW;\r\nelse\r\nmax_delay = TIPC_LINK_REQ_FAST;\r\nif (req->timer_intv > max_delay)\r\nreq->timer_intv = max_delay;\r\nk_start_timer(&req->timer, req->timer_intv);\r\nexit:\r\nspin_unlock_bh(&req->bearer->lock);\r\n}\r\nint tipc_disc_create(struct tipc_bearer *b_ptr,\r\nstruct tipc_media_addr *dest, u32 dest_domain)\r\n{\r\nstruct link_req *req;\r\nreq = kmalloc(sizeof(*req), GFP_ATOMIC);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->buf = tipc_disc_init_msg(DSC_REQ_MSG, dest_domain, b_ptr);\r\nif (!req->buf) {\r\nkfree(req);\r\nreturn -ENOMSG;\r\n}\r\nmemcpy(&req->dest, dest, sizeof(*dest));\r\nreq->bearer = b_ptr;\r\nreq->domain = dest_domain;\r\nreq->num_nodes = 0;\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nk_init_timer(&req->timer, (Handler)disc_timeout, (unsigned long)req);\r\nk_start_timer(&req->timer, req->timer_intv);\r\nb_ptr->link_req = req;\r\ndisc_send_msg(req);\r\nreturn 0;\r\n}\r\nvoid tipc_disc_delete(struct link_req *req)\r\n{\r\nk_cancel_timer(&req->timer);\r\nk_term_timer(&req->timer);\r\nbuf_discard(req->buf);\r\nkfree(req);\r\n}
