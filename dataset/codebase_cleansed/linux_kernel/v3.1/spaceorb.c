static void spaceorb_process_packet(struct spaceorb *spaceorb)\r\n{\r\nstruct input_dev *dev = spaceorb->dev;\r\nunsigned char *data = spaceorb->data;\r\nunsigned char c = 0;\r\nint axes[6];\r\nint i;\r\nif (spaceorb->idx < 2) return;\r\nfor (i = 0; i < spaceorb->idx; i++) c ^= data[i];\r\nif (c) return;\r\nswitch (data[0]) {\r\ncase 'R':\r\nspaceorb->data[spaceorb->idx - 1] = 0;\r\nfor (i = 1; i < spaceorb->idx && spaceorb->data[i] == ' '; i++);\r\nprintk(KERN_INFO "input: %s [%s] is %s\n",\r\ndev->name, spaceorb->data + i, spaceorb->phys);\r\nbreak;\r\ncase 'D':\r\nif (spaceorb->idx != 12) return;\r\nfor (i = 0; i < 9; i++) spaceorb->data[i+2] ^= spaceorb_xor[i];\r\naxes[0] = ( data[2] << 3) | (data[ 3] >> 4);\r\naxes[1] = ((data[3] & 0x0f) << 6) | (data[ 4] >> 1);\r\naxes[2] = ((data[4] & 0x01) << 9) | (data[ 5] << 2) | (data[4] >> 5);\r\naxes[3] = ((data[6] & 0x1f) << 5) | (data[ 7] >> 2);\r\naxes[4] = ((data[7] & 0x03) << 8) | (data[ 8] << 1) | (data[7] >> 6);\r\naxes[5] = ((data[9] & 0x3f) << 4) | (data[10] >> 3);\r\nfor (i = 0; i < 6; i++)\r\ninput_report_abs(dev, spaceorb_axes[i], axes[i] - ((axes[i] & 0x200) ? 1024 : 0));\r\nfor (i = 0; i < 6; i++)\r\ninput_report_key(dev, spaceorb_buttons[i], (data[1] >> i) & 1);\r\nbreak;\r\ncase 'K':\r\nif (spaceorb->idx != 5) return;\r\nfor (i = 0; i < 6; i++)\r\ninput_report_key(dev, spaceorb_buttons[i], (data[2] >> i) & 1);\r\nbreak;\r\ncase 'E':\r\nif (spaceorb->idx != 4) return;\r\nprintk(KERN_ERR "spaceorb: Device error. [ ");\r\nfor (i = 0; i < 7; i++) if (data[1] & (1 << i)) printk("%s ", spaceorb_errors[i]);\r\nprintk("]\n");\r\nbreak;\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic irqreturn_t spaceorb_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct spaceorb* spaceorb = serio_get_drvdata(serio);\r\nif (~data & 0x80) {\r\nif (spaceorb->idx) spaceorb_process_packet(spaceorb);\r\nspaceorb->idx = 0;\r\n}\r\nif (spaceorb->idx < SPACEORB_MAX_LENGTH)\r\nspaceorb->data[spaceorb->idx++] = data & 0x7f;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void spaceorb_disconnect(struct serio *serio)\r\n{\r\nstruct spaceorb* spaceorb = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_unregister_device(spaceorb->dev);\r\nkfree(spaceorb);\r\n}\r\nstatic int spaceorb_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct spaceorb *spaceorb;\r\nstruct input_dev *input_dev;\r\nint err = -ENOMEM;\r\nint i;\r\nspaceorb = kzalloc(sizeof(struct spaceorb), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!spaceorb || !input_dev)\r\ngoto fail1;\r\nspaceorb->dev = input_dev;\r\nsnprintf(spaceorb->phys, sizeof(spaceorb->phys), "%s/input0", serio->phys);\r\ninput_dev->name = "SpaceTec SpaceOrb 360 / Avenger";\r\ninput_dev->phys = spaceorb->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_SPACEORB;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (i = 0; i < 6; i++)\r\nset_bit(spaceorb_buttons[i], input_dev->keybit);\r\nfor (i = 0; i < 6; i++)\r\ninput_set_abs_params(input_dev, spaceorb_axes[i], -508, 508, 0, 0);\r\nserio_set_drvdata(serio, spaceorb);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = input_register_device(spaceorb->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(spaceorb);\r\nreturn err;\r\n}\r\nstatic int __init spaceorb_init(void)\r\n{\r\nreturn serio_register_driver(&spaceorb_drv);\r\n}\r\nstatic void __exit spaceorb_exit(void)\r\n{\r\nserio_unregister_driver(&spaceorb_drv);\r\n}
