static int build_block_map(struct partition *part, int block_no)\r\n{\r\nstruct block *block = &part->blocks[block_no];\r\nint i;\r\nblock->offset = part->block_size * block_no;\r\nif (le16_to_cpu(part->header_cache[0]) != RFD_MAGIC) {\r\nblock->state = BLOCK_UNUSED;\r\nreturn -ENOENT;\r\n}\r\nblock->state = BLOCK_OK;\r\nfor (i=0; i<part->data_sectors_per_block; i++) {\r\nu16 entry;\r\nentry = le16_to_cpu(part->header_cache[HEADER_MAP_OFFSET + i]);\r\nif (entry == SECTOR_DELETED)\r\ncontinue;\r\nif (entry == SECTOR_FREE) {\r\nblock->free_sectors++;\r\ncontinue;\r\n}\r\nif (entry == SECTOR_ZERO)\r\nentry = 0;\r\nif (entry >= part->sector_count) {\r\nprintk(KERN_WARNING PREFIX\r\n"'%s': unit #%d: entry %d corrupt, "\r\n"sector %d out of range\n",\r\npart->mbd.mtd->name, block_no, i, entry);\r\ncontinue;\r\n}\r\nif (part->sector_map[entry] != -1) {\r\nprintk(KERN_WARNING PREFIX\r\n"'%s': more than one entry for sector %d\n",\r\npart->mbd.mtd->name, entry);\r\npart->errors = 1;\r\ncontinue;\r\n}\r\npart->sector_map[entry] = block->offset +\r\n(i + part->header_sectors_per_block) * SECTOR_SIZE;\r\nblock->used_sectors++;\r\n}\r\nif (block->free_sectors == part->data_sectors_per_block)\r\npart->reserved_block = block_no;\r\nreturn 0;\r\n}\r\nstatic int scan_header(struct partition *part)\r\n{\r\nint sectors_per_block;\r\nint i, rc = -ENOMEM;\r\nint blocks_found;\r\nsize_t retlen;\r\nsectors_per_block = part->block_size / SECTOR_SIZE;\r\npart->total_blocks = (u32)part->mbd.mtd->size / part->block_size;\r\nif (part->total_blocks < 2)\r\nreturn -ENOENT;\r\npart->header_sectors_per_block =\r\n((HEADER_MAP_OFFSET + sectors_per_block) *\r\nsizeof(u16) + SECTOR_SIZE - 1) / SECTOR_SIZE;\r\npart->data_sectors_per_block = sectors_per_block -\r\npart->header_sectors_per_block;\r\npart->header_size = (HEADER_MAP_OFFSET +\r\npart->data_sectors_per_block) * sizeof(u16);\r\npart->cylinders = (part->data_sectors_per_block *\r\n(part->total_blocks - 1) - 1) / SECTORS_PER_TRACK;\r\npart->sector_count = part->cylinders * SECTORS_PER_TRACK;\r\npart->current_block = -1;\r\npart->reserved_block = -1;\r\npart->is_reclaiming = 0;\r\npart->header_cache = kmalloc(part->header_size, GFP_KERNEL);\r\nif (!part->header_cache)\r\ngoto err;\r\npart->blocks = kcalloc(part->total_blocks, sizeof(struct block),\r\nGFP_KERNEL);\r\nif (!part->blocks)\r\ngoto err;\r\npart->sector_map = vmalloc(part->sector_count * sizeof(u_long));\r\nif (!part->sector_map) {\r\nprintk(KERN_ERR PREFIX "'%s': unable to allocate memory for "\r\n"sector map", part->mbd.mtd->name);\r\ngoto err;\r\n}\r\nfor (i=0; i<part->sector_count; i++)\r\npart->sector_map[i] = -1;\r\nfor (i=0, blocks_found=0; i<part->total_blocks; i++) {\r\nrc = part->mbd.mtd->read(part->mbd.mtd,\r\ni * part->block_size, part->header_size,\r\n&retlen, (u_char*)part->header_cache);\r\nif (!rc && retlen != part->header_size)\r\nrc = -EIO;\r\nif (rc)\r\ngoto err;\r\nif (!build_block_map(part, i))\r\nblocks_found++;\r\n}\r\nif (blocks_found == 0) {\r\nprintk(KERN_NOTICE PREFIX "no RFD magic found in '%s'\n",\r\npart->mbd.mtd->name);\r\nrc = -ENOENT;\r\ngoto err;\r\n}\r\nif (part->reserved_block == -1) {\r\nprintk(KERN_WARNING PREFIX "'%s': no empty erase unit found\n",\r\npart->mbd.mtd->name);\r\npart->errors = 1;\r\n}\r\nreturn 0;\r\nerr:\r\nvfree(part->sector_map);\r\nkfree(part->header_cache);\r\nkfree(part->blocks);\r\nreturn rc;\r\n}\r\nstatic int rfd_ftl_readsect(struct mtd_blktrans_dev *dev, u_long sector, char *buf)\r\n{\r\nstruct partition *part = (struct partition*)dev;\r\nu_long addr;\r\nsize_t retlen;\r\nint rc;\r\nif (sector >= part->sector_count)\r\nreturn -EIO;\r\naddr = part->sector_map[sector];\r\nif (addr != -1) {\r\nrc = part->mbd.mtd->read(part->mbd.mtd, addr, SECTOR_SIZE,\r\n&retlen, (u_char*)buf);\r\nif (!rc && retlen != SECTOR_SIZE)\r\nrc = -EIO;\r\nif (rc) {\r\nprintk(KERN_WARNING PREFIX "error reading '%s' at "\r\n"0x%lx\n", part->mbd.mtd->name, addr);\r\nreturn rc;\r\n}\r\n} else\r\nmemset(buf, 0, SECTOR_SIZE);\r\nreturn 0;\r\n}\r\nstatic void erase_callback(struct erase_info *erase)\r\n{\r\nstruct partition *part;\r\nu16 magic;\r\nint i, rc;\r\nsize_t retlen;\r\npart = (struct partition*)erase->priv;\r\ni = (u32)erase->addr / part->block_size;\r\nif (i >= part->total_blocks || part->blocks[i].offset != erase->addr ||\r\nerase->addr > UINT_MAX) {\r\nprintk(KERN_ERR PREFIX "erase callback for unknown offset %llx "\r\n"on '%s'\n", (unsigned long long)erase->addr, part->mbd.mtd->name);\r\nreturn;\r\n}\r\nif (erase->state != MTD_ERASE_DONE) {\r\nprintk(KERN_WARNING PREFIX "erase failed at 0x%llx on '%s', "\r\n"state %d\n", (unsigned long long)erase->addr,\r\npart->mbd.mtd->name, erase->state);\r\npart->blocks[i].state = BLOCK_FAILED;\r\npart->blocks[i].free_sectors = 0;\r\npart->blocks[i].used_sectors = 0;\r\nkfree(erase);\r\nreturn;\r\n}\r\nmagic = cpu_to_le16(RFD_MAGIC);\r\npart->blocks[i].state = BLOCK_ERASED;\r\npart->blocks[i].free_sectors = part->data_sectors_per_block;\r\npart->blocks[i].used_sectors = 0;\r\npart->blocks[i].erases++;\r\nrc = part->mbd.mtd->write(part->mbd.mtd,\r\npart->blocks[i].offset, sizeof(magic), &retlen,\r\n(u_char*)&magic);\r\nif (!rc && retlen != sizeof(magic))\r\nrc = -EIO;\r\nif (rc) {\r\nprintk(KERN_ERR PREFIX "'%s': unable to write RFD "\r\n"header at 0x%lx\n",\r\npart->mbd.mtd->name,\r\npart->blocks[i].offset);\r\npart->blocks[i].state = BLOCK_FAILED;\r\n}\r\nelse\r\npart->blocks[i].state = BLOCK_OK;\r\nkfree(erase);\r\n}\r\nstatic int erase_block(struct partition *part, int block)\r\n{\r\nstruct erase_info *erase;\r\nint rc = -ENOMEM;\r\nerase = kmalloc(sizeof(struct erase_info), GFP_KERNEL);\r\nif (!erase)\r\ngoto err;\r\nerase->mtd = part->mbd.mtd;\r\nerase->callback = erase_callback;\r\nerase->addr = part->blocks[block].offset;\r\nerase->len = part->block_size;\r\nerase->priv = (u_long)part;\r\npart->blocks[block].state = BLOCK_ERASING;\r\npart->blocks[block].free_sectors = 0;\r\nrc = part->mbd.mtd->erase(part->mbd.mtd, erase);\r\nif (rc) {\r\nprintk(KERN_ERR PREFIX "erase of region %llx,%llx on '%s' "\r\n"failed\n", (unsigned long long)erase->addr,\r\n(unsigned long long)erase->len, part->mbd.mtd->name);\r\nkfree(erase);\r\n}\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int move_block_contents(struct partition *part, int block_no, u_long *old_sector)\r\n{\r\nvoid *sector_data;\r\nu16 *map;\r\nsize_t retlen;\r\nint i, rc = -ENOMEM;\r\npart->is_reclaiming = 1;\r\nsector_data = kmalloc(SECTOR_SIZE, GFP_KERNEL);\r\nif (!sector_data)\r\ngoto err3;\r\nmap = kmalloc(part->header_size, GFP_KERNEL);\r\nif (!map)\r\ngoto err2;\r\nrc = part->mbd.mtd->read(part->mbd.mtd,\r\npart->blocks[block_no].offset, part->header_size,\r\n&retlen, (u_char*)map);\r\nif (!rc && retlen != part->header_size)\r\nrc = -EIO;\r\nif (rc) {\r\nprintk(KERN_ERR PREFIX "error reading '%s' at "\r\n"0x%lx\n", part->mbd.mtd->name,\r\npart->blocks[block_no].offset);\r\ngoto err;\r\n}\r\nfor (i=0; i<part->data_sectors_per_block; i++) {\r\nu16 entry = le16_to_cpu(map[HEADER_MAP_OFFSET + i]);\r\nu_long addr;\r\nif (entry == SECTOR_FREE || entry == SECTOR_DELETED)\r\ncontinue;\r\nif (entry == SECTOR_ZERO)\r\nentry = 0;\r\nif (entry >= part->sector_count)\r\ncontinue;\r\naddr = part->blocks[block_no].offset +\r\n(i + part->header_sectors_per_block) * SECTOR_SIZE;\r\nif (*old_sector == addr) {\r\n*old_sector = -1;\r\nif (!part->blocks[block_no].used_sectors--) {\r\nrc = erase_block(part, block_no);\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nrc = part->mbd.mtd->read(part->mbd.mtd, addr,\r\nSECTOR_SIZE, &retlen, sector_data);\r\nif (!rc && retlen != SECTOR_SIZE)\r\nrc = -EIO;\r\nif (rc) {\r\nprintk(KERN_ERR PREFIX "'%s': Unable to "\r\n"read sector for relocation\n",\r\npart->mbd.mtd->name);\r\ngoto err;\r\n}\r\nrc = rfd_ftl_writesect((struct mtd_blktrans_dev*)part,\r\nentry, sector_data);\r\nif (rc)\r\ngoto err;\r\n}\r\nerr:\r\nkfree(map);\r\nerr2:\r\nkfree(sector_data);\r\nerr3:\r\npart->is_reclaiming = 0;\r\nreturn rc;\r\n}\r\nstatic int reclaim_block(struct partition *part, u_long *old_sector)\r\n{\r\nint block, best_block, score, old_sector_block;\r\nint rc;\r\nif (part->mbd.mtd->sync)\r\npart->mbd.mtd->sync(part->mbd.mtd);\r\nscore = 0x7fffffff;\r\nbest_block = -1;\r\nif (*old_sector != -1)\r\nold_sector_block = *old_sector / part->block_size;\r\nelse\r\nold_sector_block = -1;\r\nfor (block=0; block<part->total_blocks; block++) {\r\nint this_score;\r\nif (block == part->reserved_block)\r\ncontinue;\r\nif (part->blocks[block].free_sectors)\r\nreturn 0;\r\nthis_score = part->blocks[block].used_sectors;\r\nif (block == old_sector_block)\r\nthis_score--;\r\nelse {\r\nif (part->blocks[block].used_sectors ==\r\npart->data_sectors_per_block)\r\ncontinue;\r\n}\r\nthis_score += part->blocks[block].erases;\r\nif (this_score < score) {\r\nbest_block = block;\r\nscore = this_score;\r\n}\r\n}\r\nif (best_block == -1)\r\nreturn -ENOSPC;\r\npart->current_block = -1;\r\npart->reserved_block = best_block;\r\npr_debug("reclaim_block: reclaiming block #%d with %d used "\r\n"%d free sectors\n", best_block,\r\npart->blocks[best_block].used_sectors,\r\npart->blocks[best_block].free_sectors);\r\nif (part->blocks[best_block].used_sectors)\r\nrc = move_block_contents(part, best_block, old_sector);\r\nelse\r\nrc = erase_block(part, best_block);\r\nreturn rc;\r\n}\r\nstatic int find_free_block(struct partition *part)\r\n{\r\nint block, stop;\r\nblock = part->current_block == -1 ?\r\njiffies % part->total_blocks : part->current_block;\r\nstop = block;\r\ndo {\r\nif (part->blocks[block].free_sectors &&\r\nblock != part->reserved_block)\r\nreturn block;\r\nif (part->blocks[block].state == BLOCK_UNUSED)\r\nerase_block(part, block);\r\nif (++block >= part->total_blocks)\r\nblock = 0;\r\n} while (block != stop);\r\nreturn -1;\r\n}\r\nstatic int find_writable_block(struct partition *part, u_long *old_sector)\r\n{\r\nint rc, block;\r\nsize_t retlen;\r\nblock = find_free_block(part);\r\nif (block == -1) {\r\nif (!part->is_reclaiming) {\r\nrc = reclaim_block(part, old_sector);\r\nif (rc)\r\ngoto err;\r\nblock = find_free_block(part);\r\n}\r\nif (block == -1) {\r\nrc = -ENOSPC;\r\ngoto err;\r\n}\r\n}\r\nrc = part->mbd.mtd->read(part->mbd.mtd, part->blocks[block].offset,\r\npart->header_size, &retlen, (u_char*)part->header_cache);\r\nif (!rc && retlen != part->header_size)\r\nrc = -EIO;\r\nif (rc) {\r\nprintk(KERN_ERR PREFIX "'%s': unable to read header at "\r\n"0x%lx\n", part->mbd.mtd->name,\r\npart->blocks[block].offset);\r\ngoto err;\r\n}\r\npart->current_block = block;\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int mark_sector_deleted(struct partition *part, u_long old_addr)\r\n{\r\nint block, offset, rc;\r\nu_long addr;\r\nsize_t retlen;\r\nu16 del = cpu_to_le16(SECTOR_DELETED);\r\nblock = old_addr / part->block_size;\r\noffset = (old_addr % part->block_size) / SECTOR_SIZE -\r\npart->header_sectors_per_block;\r\naddr = part->blocks[block].offset +\r\n(HEADER_MAP_OFFSET + offset) * sizeof(u16);\r\nrc = part->mbd.mtd->write(part->mbd.mtd, addr,\r\nsizeof(del), &retlen, (u_char*)&del);\r\nif (!rc && retlen != sizeof(del))\r\nrc = -EIO;\r\nif (rc) {\r\nprintk(KERN_ERR PREFIX "error writing '%s' at "\r\n"0x%lx\n", part->mbd.mtd->name, addr);\r\nif (rc)\r\ngoto err;\r\n}\r\nif (block == part->current_block)\r\npart->header_cache[offset + HEADER_MAP_OFFSET] = del;\r\npart->blocks[block].used_sectors--;\r\nif (!part->blocks[block].used_sectors &&\r\n!part->blocks[block].free_sectors)\r\nrc = erase_block(part, block);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int find_free_sector(const struct partition *part, const struct block *block)\r\n{\r\nint i, stop;\r\ni = stop = part->data_sectors_per_block - block->free_sectors;\r\ndo {\r\nif (le16_to_cpu(part->header_cache[HEADER_MAP_OFFSET + i])\r\n== SECTOR_FREE)\r\nreturn i;\r\nif (++i == part->data_sectors_per_block)\r\ni = 0;\r\n}\r\nwhile(i != stop);\r\nreturn -1;\r\n}\r\nstatic int do_writesect(struct mtd_blktrans_dev *dev, u_long sector, char *buf, ulong *old_addr)\r\n{\r\nstruct partition *part = (struct partition*)dev;\r\nstruct block *block;\r\nu_long addr;\r\nint i;\r\nint rc;\r\nsize_t retlen;\r\nu16 entry;\r\nif (part->current_block == -1 ||\r\n!part->blocks[part->current_block].free_sectors) {\r\nrc = find_writable_block(part, old_addr);\r\nif (rc)\r\ngoto err;\r\n}\r\nblock = &part->blocks[part->current_block];\r\ni = find_free_sector(part, block);\r\nif (i < 0) {\r\nrc = -ENOSPC;\r\ngoto err;\r\n}\r\naddr = (i + part->header_sectors_per_block) * SECTOR_SIZE +\r\nblock->offset;\r\nrc = part->mbd.mtd->write(part->mbd.mtd,\r\naddr, SECTOR_SIZE, &retlen, (u_char*)buf);\r\nif (!rc && retlen != SECTOR_SIZE)\r\nrc = -EIO;\r\nif (rc) {\r\nprintk(KERN_ERR PREFIX "error writing '%s' at 0x%lx\n",\r\npart->mbd.mtd->name, addr);\r\nif (rc)\r\ngoto err;\r\n}\r\npart->sector_map[sector] = addr;\r\nentry = cpu_to_le16(sector == 0 ? SECTOR_ZERO : sector);\r\npart->header_cache[i + HEADER_MAP_OFFSET] = entry;\r\naddr = block->offset + (HEADER_MAP_OFFSET + i) * sizeof(u16);\r\nrc = part->mbd.mtd->write(part->mbd.mtd, addr,\r\nsizeof(entry), &retlen, (u_char*)&entry);\r\nif (!rc && retlen != sizeof(entry))\r\nrc = -EIO;\r\nif (rc) {\r\nprintk(KERN_ERR PREFIX "error writing '%s' at 0x%lx\n",\r\npart->mbd.mtd->name, addr);\r\nif (rc)\r\ngoto err;\r\n}\r\nblock->used_sectors++;\r\nblock->free_sectors--;\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int rfd_ftl_writesect(struct mtd_blktrans_dev *dev, u_long sector, char *buf)\r\n{\r\nstruct partition *part = (struct partition*)dev;\r\nu_long old_addr;\r\nint i;\r\nint rc = 0;\r\npr_debug("rfd_ftl_writesect(sector=0x%lx)\n", sector);\r\nif (part->reserved_block == -1) {\r\nrc = -EACCES;\r\ngoto err;\r\n}\r\nif (sector >= part->sector_count) {\r\nrc = -EIO;\r\ngoto err;\r\n}\r\nold_addr = part->sector_map[sector];\r\nfor (i=0; i<SECTOR_SIZE; i++) {\r\nif (!buf[i])\r\ncontinue;\r\nrc = do_writesect(dev, sector, buf, &old_addr);\r\nif (rc)\r\ngoto err;\r\nbreak;\r\n}\r\nif (i == SECTOR_SIZE)\r\npart->sector_map[sector] = -1;\r\nif (old_addr != -1)\r\nrc = mark_sector_deleted(part, old_addr);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int rfd_ftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\r\n{\r\nstruct partition *part = (struct partition*)dev;\r\ngeo->heads = 1;\r\ngeo->sectors = SECTORS_PER_TRACK;\r\ngeo->cylinders = part->cylinders;\r\nreturn 0;\r\n}\r\nstatic void rfd_ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\r\n{\r\nstruct partition *part;\r\nif (mtd->type != MTD_NORFLASH || mtd->size > UINT_MAX)\r\nreturn;\r\npart = kzalloc(sizeof(struct partition), GFP_KERNEL);\r\nif (!part)\r\nreturn;\r\npart->mbd.mtd = mtd;\r\nif (block_size)\r\npart->block_size = block_size;\r\nelse {\r\nif (!mtd->erasesize) {\r\nprintk(KERN_WARNING PREFIX "please provide block_size");\r\ngoto out;\r\n} else\r\npart->block_size = mtd->erasesize;\r\n}\r\nif (scan_header(part) == 0) {\r\npart->mbd.size = part->sector_count;\r\npart->mbd.tr = tr;\r\npart->mbd.devnum = -1;\r\nif (!(mtd->flags & MTD_WRITEABLE))\r\npart->mbd.readonly = 1;\r\nelse if (part->errors) {\r\nprintk(KERN_WARNING PREFIX "'%s': errors found, "\r\n"setting read-only\n", mtd->name);\r\npart->mbd.readonly = 1;\r\n}\r\nprintk(KERN_INFO PREFIX "name: '%s' type: %d flags %x\n",\r\nmtd->name, mtd->type, mtd->flags);\r\nif (!add_mtd_blktrans_dev((void*)part))\r\nreturn;\r\n}\r\nout:\r\nkfree(part);\r\n}\r\nstatic void rfd_ftl_remove_dev(struct mtd_blktrans_dev *dev)\r\n{\r\nstruct partition *part = (struct partition*)dev;\r\nint i;\r\nfor (i=0; i<part->total_blocks; i++) {\r\npr_debug("rfd_ftl_remove_dev:'%s': erase unit #%02d: %d erases\n",\r\npart->mbd.mtd->name, i, part->blocks[i].erases);\r\n}\r\ndel_mtd_blktrans_dev(dev);\r\nvfree(part->sector_map);\r\nkfree(part->header_cache);\r\nkfree(part->blocks);\r\n}\r\nstatic int __init init_rfd_ftl(void)\r\n{\r\nreturn register_mtd_blktrans(&rfd_ftl_tr);\r\n}\r\nstatic void __exit cleanup_rfd_ftl(void)\r\n{\r\nderegister_mtd_blktrans(&rfd_ftl_tr);\r\n}
