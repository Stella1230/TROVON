static unsigned int helper_hash(const struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn (((tuple->src.l3num << 8) | tuple->dst.protonum) ^\r\n(__force __u16)tuple->src.u.all) % nf_ct_helper_hsize;\r\n}\r\nstatic struct nf_conntrack_helper *\r\n__nf_ct_helper_find(const struct nf_conntrack_tuple *tuple)\r\n{\r\nstruct nf_conntrack_helper *helper;\r\nstruct nf_conntrack_tuple_mask mask = { .src.u.all = htons(0xFFFF) };\r\nstruct hlist_node *n;\r\nunsigned int h;\r\nif (!nf_ct_helper_count)\r\nreturn NULL;\r\nh = helper_hash(tuple);\r\nhlist_for_each_entry_rcu(helper, n, &nf_ct_helper_hash[h], hnode) {\r\nif (nf_ct_tuple_src_mask_cmp(tuple, &helper->tuple, &mask))\r\nreturn helper;\r\n}\r\nreturn NULL;\r\n}\r\nstruct nf_conntrack_helper *\r\n__nf_conntrack_helper_find(const char *name, u16 l3num, u8 protonum)\r\n{\r\nstruct nf_conntrack_helper *h;\r\nstruct hlist_node *n;\r\nunsigned int i;\r\nfor (i = 0; i < nf_ct_helper_hsize; i++) {\r\nhlist_for_each_entry_rcu(h, n, &nf_ct_helper_hash[i], hnode) {\r\nif (!strcmp(h->name, name) &&\r\nh->tuple.src.l3num == l3num &&\r\nh->tuple.dst.protonum == protonum)\r\nreturn h;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct nf_conntrack_helper *\r\nnf_conntrack_helper_try_module_get(const char *name, u16 l3num, u8 protonum)\r\n{\r\nstruct nf_conntrack_helper *h;\r\nh = __nf_conntrack_helper_find(name, l3num, protonum);\r\n#ifdef CONFIG_MODULES\r\nif (h == NULL) {\r\nif (request_module("nfct-helper-%s", name) == 0)\r\nh = __nf_conntrack_helper_find(name, l3num, protonum);\r\n}\r\n#endif\r\nif (h != NULL && !try_module_get(h->me))\r\nh = NULL;\r\nreturn h;\r\n}\r\nstruct nf_conn_help *nf_ct_helper_ext_add(struct nf_conn *ct, gfp_t gfp)\r\n{\r\nstruct nf_conn_help *help;\r\nhelp = nf_ct_ext_add(ct, NF_CT_EXT_HELPER, gfp);\r\nif (help)\r\nINIT_HLIST_HEAD(&help->expectations);\r\nelse\r\npr_debug("failed to add helper extension area");\r\nreturn help;\r\n}\r\nint __nf_ct_try_assign_helper(struct nf_conn *ct, struct nf_conn *tmpl,\r\ngfp_t flags)\r\n{\r\nstruct nf_conntrack_helper *helper = NULL;\r\nstruct nf_conn_help *help;\r\nint ret = 0;\r\nif (tmpl != NULL) {\r\nhelp = nfct_help(tmpl);\r\nif (help != NULL)\r\nhelper = help->helper;\r\n}\r\nhelp = nfct_help(ct);\r\nif (helper == NULL)\r\nhelper = __nf_ct_helper_find(&ct->tuplehash[IP_CT_DIR_REPLY].tuple);\r\nif (helper == NULL) {\r\nif (help)\r\nrcu_assign_pointer(help->helper, NULL);\r\ngoto out;\r\n}\r\nif (help == NULL) {\r\nhelp = nf_ct_helper_ext_add(ct, flags);\r\nif (help == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n} else {\r\nmemset(&help->help, 0, sizeof(help->help));\r\n}\r\nrcu_assign_pointer(help->helper, helper);\r\nout:\r\nreturn ret;\r\n}\r\nstatic inline int unhelp(struct nf_conntrack_tuple_hash *i,\r\nconst struct nf_conntrack_helper *me)\r\n{\r\nstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(i);\r\nstruct nf_conn_help *help = nfct_help(ct);\r\nif (help && rcu_dereference_protected(\r\nhelp->helper,\r\nlockdep_is_held(&nf_conntrack_lock)\r\n) == me) {\r\nnf_conntrack_event(IPCT_HELPER, ct);\r\nrcu_assign_pointer(help->helper, NULL);\r\n}\r\nreturn 0;\r\n}\r\nvoid nf_ct_helper_destroy(struct nf_conn *ct)\r\n{\r\nstruct nf_conn_help *help = nfct_help(ct);\r\nstruct nf_conntrack_helper *helper;\r\nif (help) {\r\nrcu_read_lock();\r\nhelper = rcu_dereference(help->helper);\r\nif (helper && helper->destroy)\r\nhelper->destroy(ct);\r\nrcu_read_unlock();\r\n}\r\n}\r\nint nf_conntrack_helper_register(struct nf_conntrack_helper *me)\r\n{\r\nunsigned int h = helper_hash(&me->tuple);\r\nBUG_ON(me->expect_policy == NULL);\r\nBUG_ON(me->expect_class_max >= NF_CT_MAX_EXPECT_CLASSES);\r\nBUG_ON(strlen(me->name) > NF_CT_HELPER_NAME_LEN - 1);\r\nmutex_lock(&nf_ct_helper_mutex);\r\nhlist_add_head_rcu(&me->hnode, &nf_ct_helper_hash[h]);\r\nnf_ct_helper_count++;\r\nmutex_unlock(&nf_ct_helper_mutex);\r\nreturn 0;\r\n}\r\nstatic void __nf_conntrack_helper_unregister(struct nf_conntrack_helper *me,\r\nstruct net *net)\r\n{\r\nstruct nf_conntrack_tuple_hash *h;\r\nstruct nf_conntrack_expect *exp;\r\nconst struct hlist_node *n, *next;\r\nconst struct hlist_nulls_node *nn;\r\nunsigned int i;\r\nfor (i = 0; i < nf_ct_expect_hsize; i++) {\r\nhlist_for_each_entry_safe(exp, n, next,\r\n&net->ct.expect_hash[i], hnode) {\r\nstruct nf_conn_help *help = nfct_help(exp->master);\r\nif ((rcu_dereference_protected(\r\nhelp->helper,\r\nlockdep_is_held(&nf_conntrack_lock)\r\n) == me || exp->helper == me) &&\r\ndel_timer(&exp->timeout)) {\r\nnf_ct_unlink_expect(exp);\r\nnf_ct_expect_put(exp);\r\n}\r\n}\r\n}\r\nhlist_nulls_for_each_entry(h, nn, &net->ct.unconfirmed, hnnode)\r\nunhelp(h, me);\r\nfor (i = 0; i < net->ct.htable_size; i++) {\r\nhlist_nulls_for_each_entry(h, nn, &net->ct.hash[i], hnnode)\r\nunhelp(h, me);\r\n}\r\n}\r\nvoid nf_conntrack_helper_unregister(struct nf_conntrack_helper *me)\r\n{\r\nstruct net *net;\r\nmutex_lock(&nf_ct_helper_mutex);\r\nhlist_del_rcu(&me->hnode);\r\nnf_ct_helper_count--;\r\nmutex_unlock(&nf_ct_helper_mutex);\r\nsynchronize_rcu();\r\nrtnl_lock();\r\nspin_lock_bh(&nf_conntrack_lock);\r\nfor_each_net(net)\r\n__nf_conntrack_helper_unregister(me, net);\r\nspin_unlock_bh(&nf_conntrack_lock);\r\nrtnl_unlock();\r\n}\r\nint nf_conntrack_helper_init(void)\r\n{\r\nint err;\r\nnf_ct_helper_hsize = 1;\r\nnf_ct_helper_hash = nf_ct_alloc_hashtable(&nf_ct_helper_hsize, 0);\r\nif (!nf_ct_helper_hash)\r\nreturn -ENOMEM;\r\nerr = nf_ct_extend_register(&helper_extend);\r\nif (err < 0)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\nnf_ct_free_hashtable(nf_ct_helper_hash, nf_ct_helper_hsize);\r\nreturn err;\r\n}\r\nvoid nf_conntrack_helper_fini(void)\r\n{\r\nnf_ct_extend_unregister(&helper_extend);\r\nnf_ct_free_hashtable(nf_ct_helper_hash, nf_ct_helper_hsize);\r\n}
