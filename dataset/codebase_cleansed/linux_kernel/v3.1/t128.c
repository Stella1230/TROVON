void __init t128_setup(char *str, int *ints){\r\nstatic int commandline_current = 0;\r\nint i;\r\nif (ints[0] != 2)\r\nprintk("t128_setup : usage t128=address,irq\n");\r\nelse\r\nif (commandline_current < NO_OVERRIDES) {\r\noverrides[commandline_current].address = ints[1];\r\noverrides[commandline_current].irq = ints[2];\r\nfor (i = 0; i < NO_BASES; ++i)\r\nif (bases[i].address == ints[1]) {\r\nbases[i].noauto = 1;\r\nbreak;\r\n}\r\n++commandline_current;\r\n}\r\n}\r\nint __init t128_detect(struct scsi_host_template * tpnt){\r\nstatic int current_override = 0, current_base = 0;\r\nstruct Scsi_Host *instance;\r\nunsigned long base;\r\nvoid __iomem *p;\r\nint sig, count;\r\ntpnt->proc_name = "t128";\r\ntpnt->proc_info = &t128_proc_info;\r\nfor (count = 0; current_override < NO_OVERRIDES; ++current_override) {\r\nbase = 0;\r\np = NULL;\r\nif (overrides[current_override].address) {\r\nbase = overrides[current_override].address;\r\np = ioremap(bases[current_base].address, 0x2000);\r\nif (!p)\r\nbase = 0;\r\n} else\r\nfor (; !base && (current_base < NO_BASES); ++current_base) {\r\n#if (TDEBUG & TDEBUG_INIT)\r\nprintk("scsi-t128 : probing address %08x\n", bases[current_base].address);\r\n#endif\r\nif (bases[current_base].noauto)\r\ncontinue;\r\np = ioremap(bases[current_base].address, 0x2000);\r\nif (!p)\r\ncontinue;\r\nfor (sig = 0; sig < NO_SIGNATURES; ++sig)\r\nif (check_signature(p + signatures[sig].offset,\r\nsignatures[sig].string,\r\nstrlen(signatures[sig].string))) {\r\nbase = bases[current_base].address;\r\n#if (TDEBUG & TDEBUG_INIT)\r\nprintk("scsi-t128 : detected board.\n");\r\n#endif\r\ngoto found;\r\n}\r\niounmap(p);\r\n}\r\n#if defined(TDEBUG) && (TDEBUG & TDEBUG_INIT)\r\nprintk("scsi-t128 : base = %08x\n", (unsigned int) base);\r\n#endif\r\nif (!base)\r\nbreak;\r\nfound:\r\ninstance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));\r\nif(instance == NULL)\r\nbreak;\r\ninstance->base = base;\r\n((struct NCR5380_hostdata *)instance->hostdata)->base = p;\r\nNCR5380_init(instance, 0);\r\nif (overrides[current_override].irq != IRQ_AUTO)\r\ninstance->irq = overrides[current_override].irq;\r\nelse\r\ninstance->irq = NCR5380_probe_irq(instance, T128_IRQS);\r\nif (instance->irq != SCSI_IRQ_NONE)\r\nif (request_irq(instance->irq, t128_intr, IRQF_DISABLED, "t128",\r\ninstance)) {\r\nprintk("scsi%d : IRQ%d not free, interrupts disabled\n",\r\ninstance->host_no, instance->irq);\r\ninstance->irq = SCSI_IRQ_NONE;\r\n}\r\nif (instance->irq == SCSI_IRQ_NONE) {\r\nprintk("scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);\r\nprintk("scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);\r\n}\r\n#if defined(TDEBUG) && (TDEBUG & TDEBUG_INIT)\r\nprintk("scsi%d : irq = %d\n", instance->host_no, instance->irq);\r\n#endif\r\nprintk("scsi%d : at 0x%08lx", instance->host_no, instance->base);\r\nif (instance->irq == SCSI_IRQ_NONE)\r\nprintk (" interrupts disabled");\r\nelse\r\nprintk (" irq %d", instance->irq);\r\nprintk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d",\r\nCAN_QUEUE, CMD_PER_LUN, T128_PUBLIC_RELEASE);\r\nNCR5380_print_options(instance);\r\nprintk("\n");\r\n++current_override;\r\n++count;\r\n}\r\nreturn count;\r\n}\r\nstatic int t128_release(struct Scsi_Host *shost)\r\n{\r\nNCR5380_local_declare();\r\nNCR5380_setup(shost);\r\nif (shost->irq)\r\nfree_irq(shost->irq, shost);\r\nNCR5380_exit(shost);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nscsi_unregister(shost);\r\niounmap(base);\r\nreturn 0;\r\n}\r\nint t128_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int * ip)\r\n{\r\nip[0] = 64;\r\nip[1] = 32;\r\nip[2] = capacity >> 11;\r\nreturn 0;\r\n}\r\nstatic inline int NCR5380_pread (struct Scsi_Host *instance, unsigned char *dst,\r\nint len) {\r\nNCR5380_local_declare();\r\nvoid __iomem *reg;\r\nunsigned char *d = dst;\r\nregister int i = len;\r\nNCR5380_setup(instance);\r\nreg = base + T_DATA_REG_OFFSET;\r\n#if 0\r\nfor (; i; --i) {\r\nwhile (!(readb(base+T_STATUS_REG_OFFSET) & T_ST_RDY)) barrier();\r\n#else\r\nwhile (!(readb(base+T_STATUS_REG_OFFSET) & T_ST_RDY)) barrier();\r\nfor (; i; --i) {\r\n#endif\r\n*d++ = readb(reg);\r\n}\r\nif (readb(base + T_STATUS_REG_OFFSET) & T_ST_TIM) {\r\nunsigned char tmp;\r\nvoid __iomem *foo = base + T_CONTROL_REG_OFFSET;\r\ntmp = readb(foo);\r\nwriteb(tmp | T_CR_CT, foo);\r\nwriteb(tmp, foo);\r\nprintk("scsi%d : watchdog timer fired in NCR5380_pread()\n",\r\ninstance->host_no);\r\nreturn -1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic inline int NCR5380_pwrite (struct Scsi_Host *instance, unsigned char *src,\r\nint len) {\r\nNCR5380_local_declare();\r\nvoid __iomem *reg;\r\nunsigned char *s = src;\r\nregister int i = len;\r\nNCR5380_setup(instance);\r\nreg = base + T_DATA_REG_OFFSET;\r\n#if 0\r\nfor (; i; --i) {\r\nwhile (!(readb(base+T_STATUS_REG_OFFSET) & T_ST_RDY)) barrier();\r\n#else\r\nwhile (!(readb(base+T_STATUS_REG_OFFSET) & T_ST_RDY)) barrier();\r\nfor (; i; --i) {\r\n#endif\r\nwriteb(*s++, reg);\r\n}\r\nif (readb(base + T_STATUS_REG_OFFSET) & T_ST_TIM) {\r\nunsigned char tmp;\r\nvoid __iomem *foo = base + T_CONTROL_REG_OFFSET;\r\ntmp = readb(foo);\r\nwriteb(tmp | T_CR_CT, foo);\r\nwriteb(tmp, foo);\r\nprintk("scsi%d : watchdog timer fired in NCR5380_pwrite()\n",\r\ninstance->host_no);\r\nreturn -1;\r\n} else\r\nreturn 0;\r\n}
