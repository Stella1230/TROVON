static int\r\nnouveau_pm_clock_set(struct drm_device *dev, struct nouveau_pm_level *perflvl,\r\nu8 id, u32 khz)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nvoid *pre_state;\r\nif (khz == 0)\r\nreturn 0;\r\npre_state = pm->clock_pre(dev, perflvl, id, khz);\r\nif (IS_ERR(pre_state))\r\nreturn PTR_ERR(pre_state);\r\nif (pre_state)\r\npm->clock_set(dev, pre_state);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_pm_perflvl_set(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nint ret;\r\nif (perflvl == pm->cur)\r\nreturn 0;\r\nif (pm->voltage.supported && pm->voltage_set && perflvl->voltage) {\r\nret = pm->voltage_set(dev, perflvl->voltage);\r\nif (ret) {\r\nNV_ERROR(dev, "voltage_set %d failed: %d\n",\r\nperflvl->voltage, ret);\r\n}\r\n}\r\nnouveau_pm_clock_set(dev, perflvl, PLL_CORE, perflvl->core);\r\nnouveau_pm_clock_set(dev, perflvl, PLL_SHADER, perflvl->shader);\r\nnouveau_pm_clock_set(dev, perflvl, PLL_MEMORY, perflvl->memory);\r\nnouveau_pm_clock_set(dev, perflvl, PLL_UNK05, perflvl->unk05);\r\npm->cur = perflvl;\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_pm_profile_set(struct drm_device *dev, const char *profile)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_level *perflvl = NULL;\r\nif (nouveau_perflvl_wr != 7777)\r\nreturn -EPERM;\r\nif (!pm->clock_set)\r\nreturn -EINVAL;\r\nif (!strncmp(profile, "boot", 4))\r\nperflvl = &pm->boot;\r\nelse {\r\nint pl = simple_strtol(profile, NULL, 10);\r\nint i;\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nif (pm->perflvl[i].id == pl) {\r\nperflvl = &pm->perflvl[i];\r\nbreak;\r\n}\r\n}\r\nif (!perflvl)\r\nreturn -EINVAL;\r\n}\r\nNV_INFO(dev, "setting performance level: %s\n", profile);\r\nreturn nouveau_pm_perflvl_set(dev, perflvl);\r\n}\r\nstatic int\r\nnouveau_pm_perflvl_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nint ret;\r\nif (!pm->clock_get)\r\nreturn -EINVAL;\r\nmemset(perflvl, 0, sizeof(*perflvl));\r\nret = pm->clock_get(dev, PLL_CORE);\r\nif (ret > 0)\r\nperflvl->core = ret;\r\nret = pm->clock_get(dev, PLL_MEMORY);\r\nif (ret > 0)\r\nperflvl->memory = ret;\r\nret = pm->clock_get(dev, PLL_SHADER);\r\nif (ret > 0)\r\nperflvl->shader = ret;\r\nret = pm->clock_get(dev, PLL_UNK05);\r\nif (ret > 0)\r\nperflvl->unk05 = ret;\r\nif (pm->voltage.supported && pm->voltage_get) {\r\nret = pm->voltage_get(dev);\r\nif (ret > 0)\r\nperflvl->voltage = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_pm_perflvl_info(struct nouveau_pm_level *perflvl, char *ptr, int len)\r\n{\r\nchar c[16], s[16], v[16], f[16], t[16];\r\nc[0] = '\0';\r\nif (perflvl->core)\r\nsnprintf(c, sizeof(c), " core %dMHz", perflvl->core / 1000);\r\ns[0] = '\0';\r\nif (perflvl->shader)\r\nsnprintf(s, sizeof(s), " shader %dMHz", perflvl->shader / 1000);\r\nv[0] = '\0';\r\nif (perflvl->voltage)\r\nsnprintf(v, sizeof(v), " voltage %dmV", perflvl->voltage * 10);\r\nf[0] = '\0';\r\nif (perflvl->fanspeed)\r\nsnprintf(f, sizeof(f), " fanspeed %d%%", perflvl->fanspeed);\r\nt[0] = '\0';\r\nif (perflvl->timing)\r\nsnprintf(t, sizeof(t), " timing %d", perflvl->timing->id);\r\nsnprintf(ptr, len, "memory %dMHz%s%s%s%s%s\n", perflvl->memory / 1000,\r\nc, s, v, f, t);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_get_perflvl_info(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct nouveau_pm_level *perflvl = (struct nouveau_pm_level *)a;\r\nchar *ptr = buf;\r\nint len = PAGE_SIZE;\r\nsnprintf(ptr, len, "%d: ", perflvl->id);\r\nptr += strlen(buf);\r\nlen -= strlen(buf);\r\nnouveau_pm_perflvl_info(perflvl, ptr, len);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_get_perflvl(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(to_pci_dev(d));\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_level cur;\r\nint len = PAGE_SIZE, ret;\r\nchar *ptr = buf;\r\nif (!pm->cur)\r\nsnprintf(ptr, len, "setting: boot\n");\r\nelse if (pm->cur == &pm->boot)\r\nsnprintf(ptr, len, "setting: boot\nc: ");\r\nelse\r\nsnprintf(ptr, len, "setting: static %d\nc: ", pm->cur->id);\r\nptr += strlen(buf);\r\nlen -= strlen(buf);\r\nret = nouveau_pm_perflvl_get(dev, &cur);\r\nif (ret == 0)\r\nnouveau_pm_perflvl_info(&cur, ptr, len);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_set_perflvl(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(to_pci_dev(d));\r\nint ret;\r\nret = nouveau_pm_profile_set(dev, buf);\r\nif (ret)\r\nreturn ret;\r\nreturn strlen(buf);\r\n}\r\nstatic int\r\nnouveau_sysfs_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct device *d = &dev->pdev->dev;\r\nint ret, i;\r\nret = device_create_file(d, &dev_attr_performance_level);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nstruct nouveau_pm_level *perflvl = &pm->perflvl[i];\r\nperflvl->dev_attr.attr.name = perflvl->name;\r\nperflvl->dev_attr.attr.mode = S_IRUGO;\r\nperflvl->dev_attr.show = nouveau_pm_get_perflvl_info;\r\nperflvl->dev_attr.store = NULL;\r\nsysfs_attr_init(&perflvl->dev_attr.attr);\r\nret = device_create_file(d, &perflvl->dev_attr);\r\nif (ret) {\r\nNV_ERROR(dev, "failed pervlvl %d sysfs: %d\n",\r\nperflvl->id, i);\r\nperflvl->dev_attr.attr.name = NULL;\r\nnouveau_pm_fini(dev);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_sysfs_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct device *d = &dev->pdev->dev;\r\nint i;\r\ndevice_remove_file(d, &dev_attr_performance_level);\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nstruct nouveau_pm_level *pl = &pm->perflvl[i];\r\nif (!pl->dev_attr.attr.name)\r\nbreak;\r\ndevice_remove_file(d, &pl->dev_attr);\r\n}\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_show_temp(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", pm->temp_get(dev)*1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_max_temp(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temp = &pm->threshold_temp;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp->down_clock*1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_max_temp(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temp = &pm->threshold_temp;\r\nlong value;\r\nif (strict_strtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntemp->down_clock = value/1000;\r\nnouveau_temp_safety_checks(dev);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_critical_temp(struct device *d, struct device_attribute *a,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temp = &pm->threshold_temp;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp->critical*1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_critical_temp(struct device *d, struct device_attribute *a,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temp = &pm->threshold_temp;\r\nlong value;\r\nif (strict_strtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntemp->critical = value/1000;\r\nnouveau_temp_safety_checks(dev);\r\nreturn count;\r\n}\r\nstatic ssize_t nouveau_hwmon_show_name(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "nouveau\n");\r\n}\r\nstatic ssize_t nouveau_hwmon_show_update_rate(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "1000\n");\r\n}\r\nstatic int\r\nnouveau_hwmon_init(struct drm_device *dev)\r\n{\r\n#ifdef CONFIG_HWMON\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct device *hwmon_dev;\r\nint ret;\r\nif (!pm->temp_get)\r\nreturn -ENODEV;\r\nhwmon_dev = hwmon_device_register(&dev->pdev->dev);\r\nif (IS_ERR(hwmon_dev)) {\r\nret = PTR_ERR(hwmon_dev);\r\nNV_ERROR(dev,\r\n"Unable to register hwmon device: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(hwmon_dev, dev);\r\nret = sysfs_create_group(&dev->pdev->dev.kobj, &hwmon_attrgroup);\r\nif (ret) {\r\nNV_ERROR(dev,\r\n"Unable to create hwmon sysfs file: %d\n", ret);\r\nhwmon_device_unregister(hwmon_dev);\r\nreturn ret;\r\n}\r\npm->hwmon = hwmon_dev;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_hwmon_fini(struct drm_device *dev)\r\n{\r\n#ifdef CONFIG_HWMON\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nif (pm->hwmon) {\r\nsysfs_remove_group(&dev->pdev->dev.kobj, &hwmon_attrgroup);\r\nhwmon_device_unregister(pm->hwmon);\r\n}\r\n#endif\r\n}\r\nstatic int\r\nnouveau_pm_acpi_event(struct notifier_block *nb, unsigned long val, void *data)\r\n{\r\nstruct drm_nouveau_private *dev_priv =\r\ncontainer_of(nb, struct drm_nouveau_private, engine.pm.acpi_nb);\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct acpi_bus_event *entry = (struct acpi_bus_event *)data;\r\nif (strcmp(entry->device_class, "ac_adapter") == 0) {\r\nbool ac = power_supply_is_system_supplied();\r\nNV_DEBUG(dev, "power supply changed: %s\n", ac ? "AC" : "DC");\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nint\r\nnouveau_pm_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nchar info[256];\r\nint ret, i;\r\nnouveau_mem_timing_init(dev);\r\nnouveau_volt_init(dev);\r\nnouveau_perf_init(dev);\r\nnouveau_temp_init(dev);\r\nNV_INFO(dev, "%d available performance level(s)\n", pm->nr_perflvl);\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nnouveau_pm_perflvl_info(&pm->perflvl[i], info, sizeof(info));\r\nNV_INFO(dev, "%d: %s", pm->perflvl[i].id, info);\r\n}\r\nret = nouveau_pm_perflvl_get(dev, &pm->boot);\r\nif (ret == 0) {\r\nstrncpy(pm->boot.name, "boot", 4);\r\npm->cur = &pm->boot;\r\nnouveau_pm_perflvl_info(&pm->boot, info, sizeof(info));\r\nNV_INFO(dev, "c: %s", info);\r\n}\r\nif (nouveau_perflvl != NULL) {\r\nret = nouveau_pm_profile_set(dev, nouveau_perflvl);\r\nif (ret) {\r\nNV_ERROR(dev, "error setting perflvl \"%s\": %d\n",\r\nnouveau_perflvl, ret);\r\n}\r\n}\r\nnouveau_sysfs_init(dev);\r\nnouveau_hwmon_init(dev);\r\n#if defined(CONFIG_ACPI) && defined(CONFIG_POWER_SUPPLY)\r\npm->acpi_nb.notifier_call = nouveau_pm_acpi_event;\r\nregister_acpi_notifier(&pm->acpi_nb);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_pm_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nif (pm->cur != &pm->boot)\r\nnouveau_pm_perflvl_set(dev, &pm->boot);\r\nnouveau_temp_fini(dev);\r\nnouveau_perf_fini(dev);\r\nnouveau_volt_fini(dev);\r\nnouveau_mem_timing_fini(dev);\r\n#if defined(CONFIG_ACPI) && defined(CONFIG_POWER_SUPPLY)\r\nunregister_acpi_notifier(&pm->acpi_nb);\r\n#endif\r\nnouveau_hwmon_fini(dev);\r\nnouveau_sysfs_fini(dev);\r\n}\r\nvoid\r\nnouveau_pm_resume(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_level *perflvl;\r\nif (!pm->cur || pm->cur == &pm->boot)\r\nreturn;\r\nperflvl = pm->cur;\r\npm->cur = &pm->boot;\r\nnouveau_pm_perflvl_set(dev, perflvl);\r\n}
