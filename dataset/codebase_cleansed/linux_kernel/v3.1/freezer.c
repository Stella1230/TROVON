static inline void frozen_process(void)\r\n{\r\nif (!unlikely(current->flags & PF_NOFREEZE)) {\r\ncurrent->flags |= PF_FROZEN;\r\nsmp_wmb();\r\n}\r\nclear_freeze_flag(current);\r\n}\r\nvoid refrigerator(void)\r\n{\r\nlong save;\r\ntask_lock(current);\r\nif (freezing(current)) {\r\nfrozen_process();\r\ntask_unlock(current);\r\n} else {\r\ntask_unlock(current);\r\nreturn;\r\n}\r\nsave = current->state;\r\npr_debug("%s entered refrigerator\n", current->comm);\r\nspin_lock_irq(&current->sighand->siglock);\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\ncurrent->flags |= PF_FREEZING;\r\nfor (;;) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (!frozen(current))\r\nbreak;\r\nschedule();\r\n}\r\ncurrent->flags &= ~PF_FREEZING;\r\npr_debug("%s left refrigerator\n", current->comm);\r\n__set_current_state(save);\r\n}\r\nstatic void fake_signal_wake_up(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->sighand->siglock, flags);\r\nsignal_wake_up(p, 0);\r\nspin_unlock_irqrestore(&p->sighand->siglock, flags);\r\n}\r\nbool freeze_task(struct task_struct *p, bool sig_only)\r\n{\r\nif (!freezing(p)) {\r\nsmp_rmb();\r\nif (frozen(p))\r\nreturn false;\r\nif (!sig_only || should_send_signal(p))\r\nset_freeze_flag(p);\r\nelse\r\nreturn false;\r\n}\r\nif (should_send_signal(p)) {\r\nfake_signal_wake_up(p);\r\n} else if (sig_only) {\r\nreturn false;\r\n} else {\r\nwake_up_state(p, TASK_INTERRUPTIBLE);\r\n}\r\nreturn true;\r\n}\r\nvoid cancel_freezing(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nif (freezing(p)) {\r\npr_debug(" clean up: %s\n", p->comm);\r\nclear_freeze_flag(p);\r\nspin_lock_irqsave(&p->sighand->siglock, flags);\r\nrecalc_sigpending_and_wake(p);\r\nspin_unlock_irqrestore(&p->sighand->siglock, flags);\r\n}\r\n}\r\nstatic int __thaw_process(struct task_struct *p)\r\n{\r\nif (frozen(p)) {\r\np->flags &= ~PF_FROZEN;\r\nreturn 1;\r\n}\r\nclear_freeze_flag(p);\r\nreturn 0;\r\n}\r\nint thaw_process(struct task_struct *p)\r\n{\r\ntask_lock(p);\r\nif (__thaw_process(p) == 1) {\r\ntask_unlock(p);\r\nwake_up_process(p);\r\nreturn 1;\r\n}\r\ntask_unlock(p);\r\nreturn 0;\r\n}
