static inline int signal_is_set(struct parport *port)\r\n{\r\nreturn (port->ops->read_status(port) & PARPORT_STATUS_ACK) != 0;\r\n}\r\nstatic void parport_irq(void *handle)\r\n{\r\nstruct pps_event_time ts_assert, ts_clear;\r\nstruct pps_client_pp *dev = handle;\r\nstruct parport *port = dev->pardev->port;\r\nunsigned int i;\r\nunsigned long flags;\r\npps_get_ts(&ts_assert);\r\nif (dev->cw == 0)\r\ngoto out_assert;\r\nlocal_irq_save(flags);\r\nif (!signal_is_set(port)) {\r\nlocal_irq_restore(flags);\r\ndev_err(dev->pps->dev, "lost the signal\n");\r\ngoto out_assert;\r\n}\r\nfor (i = dev->cw; i; i--)\r\nif (!signal_is_set(port)) {\r\npps_get_ts(&ts_clear);\r\nlocal_irq_restore(flags);\r\ndev->cw_err = 0;\r\ngoto out_both;\r\n}\r\nlocal_irq_restore(flags);\r\ndev->cw_err++;\r\nif (dev->cw_err >= CLEAR_WAIT_MAX_ERRORS) {\r\ndev_err(dev->pps->dev, "disabled clear edge capture after %d"\r\n" timeouts\n", dev->cw_err);\r\ndev->cw = 0;\r\ndev->cw_err = 0;\r\n}\r\nout_assert:\r\npps_event(dev->pps, &ts_assert,\r\nPPS_CAPTUREASSERT, NULL);\r\nreturn;\r\nout_both:\r\npps_event(dev->pps, &ts_assert,\r\nPPS_CAPTUREASSERT, NULL);\r\npps_event(dev->pps, &ts_clear,\r\nPPS_CAPTURECLEAR, NULL);\r\nreturn;\r\n}\r\nstatic void pps_echo(struct pps_device *pps, int event, void *data)\r\n{\r\ndev_info(pps->dev, "echo %s %s\n",\r\nevent & PPS_CAPTUREASSERT ? "assert" : "",\r\nevent & PPS_CAPTURECLEAR ? "clear" : "");\r\n}\r\nstatic void parport_attach(struct parport *port)\r\n{\r\nstruct pps_client_pp *device;\r\nstruct pps_source_info info = {\r\n.name = KBUILD_MODNAME,\r\n.path = "",\r\n.mode = PPS_CAPTUREBOTH | \\r\nPPS_OFFSETASSERT | PPS_OFFSETCLEAR | \\r\nPPS_ECHOASSERT | PPS_ECHOCLEAR | \\r\nPPS_CANWAIT | PPS_TSFMT_TSPEC,\r\n.echo = pps_echo,\r\n.owner = THIS_MODULE,\r\n.dev = NULL\r\n};\r\ndevice = kzalloc(sizeof(struct pps_client_pp), GFP_KERNEL);\r\nif (!device) {\r\npr_err("memory allocation failed, not attaching\n");\r\nreturn;\r\n}\r\ndevice->pardev = parport_register_device(port, KBUILD_MODNAME,\r\nNULL, NULL, parport_irq, PARPORT_FLAG_EXCL, device);\r\nif (!device->pardev) {\r\npr_err("couldn't register with %s\n", port->name);\r\ngoto err_free;\r\n}\r\nif (parport_claim_or_block(device->pardev) < 0) {\r\npr_err("couldn't claim %s\n", port->name);\r\ngoto err_unregister_dev;\r\n}\r\ndevice->pps = pps_register_source(&info,\r\nPPS_CAPTUREBOTH | PPS_OFFSETASSERT | PPS_OFFSETCLEAR);\r\nif (device->pps == NULL) {\r\npr_err("couldn't register PPS source\n");\r\ngoto err_release_dev;\r\n}\r\ndevice->cw = clear_wait;\r\nport->ops->enable_irq(port);\r\npr_info("attached to %s\n", port->name);\r\nreturn;\r\nerr_release_dev:\r\nparport_release(device->pardev);\r\nerr_unregister_dev:\r\nparport_unregister_device(device->pardev);\r\nerr_free:\r\nkfree(device);\r\n}\r\nstatic void parport_detach(struct parport *port)\r\n{\r\nstruct pardevice *pardev = port->cad;\r\nstruct pps_client_pp *device;\r\nif (strcmp(pardev->name, KBUILD_MODNAME))\r\nreturn;\r\ndevice = pardev->private;\r\nport->ops->disable_irq(port);\r\npps_unregister_source(device->pps);\r\nparport_release(pardev);\r\nparport_unregister_device(pardev);\r\nkfree(device);\r\n}\r\nstatic int __init pps_parport_init(void)\r\n{\r\nint ret;\r\npr_info(DRVDESC "\n");\r\nif (clear_wait > CLEAR_WAIT_MAX) {\r\npr_err("clear_wait value should be not greater"\r\n" then %d\n", CLEAR_WAIT_MAX);\r\nreturn -EINVAL;\r\n}\r\nret = parport_register_driver(&pps_parport_driver);\r\nif (ret) {\r\npr_err("unable to register with parport\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit pps_parport_exit(void)\r\n{\r\nparport_unregister_driver(&pps_parport_driver);\r\n}
