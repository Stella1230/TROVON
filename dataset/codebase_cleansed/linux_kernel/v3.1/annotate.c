int symbol__annotate_init(struct map *map __used, struct symbol *sym)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\npthread_mutex_init(&notes->lock, NULL);\r\nreturn 0;\r\n}\r\nint symbol__alloc_hist(struct symbol *sym, int nevents)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nsize_t sizeof_sym_hist = (sizeof(struct sym_hist) +\r\n(sym->end - sym->start) * sizeof(u64));\r\nnotes->src = zalloc(sizeof(*notes->src) + nevents * sizeof_sym_hist);\r\nif (notes->src == NULL)\r\nreturn -1;\r\nnotes->src->sizeof_sym_hist = sizeof_sym_hist;\r\nnotes->src->nr_histograms = nevents;\r\nINIT_LIST_HEAD(&notes->src->source);\r\nreturn 0;\r\n}\r\nvoid symbol__annotate_zero_histograms(struct symbol *sym)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\npthread_mutex_lock(&notes->lock);\r\nif (notes->src != NULL)\r\nmemset(notes->src->histograms, 0,\r\nnotes->src->nr_histograms * notes->src->sizeof_sym_hist);\r\npthread_mutex_unlock(&notes->lock);\r\n}\r\nint symbol__inc_addr_samples(struct symbol *sym, struct map *map,\r\nint evidx, u64 addr)\r\n{\r\nunsigned offset;\r\nstruct annotation *notes;\r\nstruct sym_hist *h;\r\nnotes = symbol__annotation(sym);\r\nif (notes->src == NULL)\r\nreturn -ENOMEM;\r\npr_debug3("%s: addr=%#" PRIx64 "\n", __func__, map->unmap_ip(map, addr));\r\nif (addr >= sym->end)\r\nreturn 0;\r\noffset = addr - sym->start;\r\nh = annotation__histogram(notes, evidx);\r\nh->sum++;\r\nh->addr[offset]++;\r\npr_debug3("%#" PRIx64 " %s: period++ [addr: %#" PRIx64 ", %#" PRIx64\r\n", evidx=%d] => %" PRIu64 "\n", sym->start, sym->name,\r\naddr, addr - sym->start, evidx, h->addr[offset]);\r\nreturn 0;\r\n}\r\nstatic struct objdump_line *objdump_line__new(s64 offset, char *line, size_t privsize)\r\n{\r\nstruct objdump_line *self = malloc(sizeof(*self) + privsize);\r\nif (self != NULL) {\r\nself->offset = offset;\r\nself->line = line;\r\n}\r\nreturn self;\r\n}\r\nvoid objdump_line__free(struct objdump_line *self)\r\n{\r\nfree(self->line);\r\nfree(self);\r\n}\r\nstatic void objdump__add_line(struct list_head *head, struct objdump_line *line)\r\n{\r\nlist_add_tail(&line->node, head);\r\n}\r\nstruct objdump_line *objdump__get_next_ip_line(struct list_head *head,\r\nstruct objdump_line *pos)\r\n{\r\nlist_for_each_entry_continue(pos, head, node)\r\nif (pos->offset >= 0)\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nstatic int objdump_line__print(struct objdump_line *oline, struct symbol *sym,\r\nint evidx, u64 len, int min_pcnt,\r\nint printed, int max_lines,\r\nstruct objdump_line *queue)\r\n{\r\nstatic const char *prev_line;\r\nstatic const char *prev_color;\r\nif (oline->offset != -1) {\r\nconst char *path = NULL;\r\nunsigned int hits = 0;\r\ndouble percent = 0.0;\r\nconst char *color;\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct source_line *src_line = notes->src->lines;\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\ns64 offset = oline->offset;\r\nstruct objdump_line *next;\r\nnext = objdump__get_next_ip_line(&notes->src->source, oline);\r\nwhile (offset < (s64)len &&\r\n(next == NULL || offset < next->offset)) {\r\nif (src_line) {\r\nif (path == NULL)\r\npath = src_line[offset].path;\r\npercent += src_line[offset].percent;\r\n} else\r\nhits += h->addr[offset];\r\n++offset;\r\n}\r\nif (src_line == NULL && h->sum)\r\npercent = 100.0 * hits / h->sum;\r\nif (percent < min_pcnt)\r\nreturn -1;\r\nif (max_lines && printed >= max_lines)\r\nreturn 1;\r\nif (queue != NULL) {\r\nlist_for_each_entry_from(queue, &notes->src->source, node) {\r\nif (queue == oline)\r\nbreak;\r\nobjdump_line__print(queue, sym, evidx, len,\r\n0, 0, 1, NULL);\r\n}\r\n}\r\ncolor = get_percent_color(percent);\r\nif (path) {\r\nif (!prev_line || strcmp(prev_line, path)\r\n|| color != prev_color) {\r\ncolor_fprintf(stdout, color, " %s", path);\r\nprev_line = path;\r\nprev_color = color;\r\n}\r\n}\r\ncolor_fprintf(stdout, color, " %7.2f", percent);\r\nprintf(" : ");\r\ncolor_fprintf(stdout, PERF_COLOR_BLUE, "%s\n", oline->line);\r\n} else if (max_lines && printed >= max_lines)\r\nreturn 1;\r\nelse {\r\nif (queue)\r\nreturn -1;\r\nif (!*oline->line)\r\nprintf(" :\n");\r\nelse\r\nprintf(" : %s\n", oline->line);\r\n}\r\nreturn 0;\r\n}\r\nstatic int symbol__parse_objdump_line(struct symbol *sym, struct map *map,\r\nFILE *file, size_t privsize)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct objdump_line *objdump_line;\r\nchar *line = NULL, *tmp, *tmp2, *c;\r\nsize_t line_len;\r\ns64 line_ip, offset = -1;\r\nif (getline(&line, &line_len, file) < 0)\r\nreturn -1;\r\nif (!line)\r\nreturn -1;\r\nwhile (line_len != 0 && isspace(line[line_len - 1]))\r\nline[--line_len] = '\0';\r\nc = strchr(line, '\n');\r\nif (c)\r\n*c = 0;\r\nline_ip = -1;\r\ntmp = line;\r\nwhile (*tmp) {\r\nif (*tmp != ' ')\r\nbreak;\r\ntmp++;\r\n}\r\nif (*tmp) {\r\nline_ip = strtoull(tmp, &tmp2, 16);\r\nif (*tmp2 != ':' || tmp == tmp2 || tmp2[1] == '\0')\r\nline_ip = -1;\r\n}\r\nif (line_ip != -1) {\r\nu64 start = map__rip_2objdump(map, sym->start),\r\nend = map__rip_2objdump(map, sym->end);\r\noffset = line_ip - start;\r\nif (offset < 0 || (u64)line_ip > end)\r\noffset = -1;\r\n}\r\nobjdump_line = objdump_line__new(offset, line, privsize);\r\nif (objdump_line == NULL) {\r\nfree(line);\r\nreturn -1;\r\n}\r\nobjdump__add_line(&notes->src->source, objdump_line);\r\nreturn 0;\r\n}\r\nint symbol__annotate(struct symbol *sym, struct map *map, size_t privsize)\r\n{\r\nstruct dso *dso = map->dso;\r\nchar *filename = dso__build_id_filename(dso, NULL, 0);\r\nbool free_filename = true;\r\nchar command[PATH_MAX * 2];\r\nFILE *file;\r\nint err = 0;\r\nchar symfs_filename[PATH_MAX];\r\nif (filename) {\r\nsnprintf(symfs_filename, sizeof(symfs_filename), "%s%s",\r\nsymbol_conf.symfs, filename);\r\n}\r\nif (filename == NULL) {\r\nif (dso->has_build_id) {\r\npr_err("Can't annotate %s: not enough memory\n",\r\nsym->name);\r\nreturn -ENOMEM;\r\n}\r\ngoto fallback;\r\n} else if (readlink(symfs_filename, command, sizeof(command)) < 0 ||\r\nstrstr(command, "[kernel.kallsyms]") ||\r\naccess(symfs_filename, R_OK)) {\r\nfree(filename);\r\nfallback:\r\nfilename = dso->long_name;\r\nsnprintf(symfs_filename, sizeof(symfs_filename), "%s%s",\r\nsymbol_conf.symfs, filename);\r\nfree_filename = false;\r\n}\r\nif (dso->symtab_type == SYMTAB__KALLSYMS) {\r\nchar bf[BUILD_ID_SIZE * 2 + 16] = " with build id ";\r\nchar *build_id_msg = NULL;\r\nif (dso->annotate_warned)\r\ngoto out_free_filename;\r\nif (dso->has_build_id) {\r\nbuild_id__sprintf(dso->build_id,\r\nsizeof(dso->build_id), bf + 15);\r\nbuild_id_msg = bf;\r\n}\r\nerr = -ENOENT;\r\ndso->annotate_warned = 1;\r\npr_err("Can't annotate %s: No vmlinux file%s was found in the "\r\n"path.\nPlease use 'perf buildid-cache -av vmlinux' or "\r\n"--vmlinux vmlinux.\n",\r\nsym->name, build_id_msg ?: "");\r\ngoto out_free_filename;\r\n}\r\npr_debug("%s: filename=%s, sym=%s, start=%#" PRIx64 ", end=%#" PRIx64 "\n", __func__,\r\nfilename, sym->name, map->unmap_ip(map, sym->start),\r\nmap->unmap_ip(map, sym->end));\r\npr_debug("annotating [%p] %30s : [%p] %30s\n",\r\ndso, dso->long_name, sym, sym->name);\r\nsnprintf(command, sizeof(command),\r\n"objdump --start-address=0x%016" PRIx64\r\n" --stop-address=0x%016" PRIx64 " -dS -C %s|grep -v %s|expand",\r\nmap__rip_2objdump(map, sym->start),\r\nmap__rip_2objdump(map, sym->end),\r\nsymfs_filename, filename);\r\npr_debug("Executing: %s\n", command);\r\nfile = popen(command, "r");\r\nif (!file)\r\ngoto out_free_filename;\r\nwhile (!feof(file))\r\nif (symbol__parse_objdump_line(sym, map, file, privsize) < 0)\r\nbreak;\r\npclose(file);\r\nout_free_filename:\r\nif (free_filename)\r\nfree(filename);\r\nreturn err;\r\n}\r\nstatic void insert_source_line(struct rb_root *root, struct source_line *src_line)\r\n{\r\nstruct source_line *iter;\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\niter = rb_entry(parent, struct source_line, node);\r\nif (src_line->percent > iter->percent)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&src_line->node, parent, p);\r\nrb_insert_color(&src_line->node, root);\r\n}\r\nstatic void symbol__free_source_line(struct symbol *sym, int len)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct source_line *src_line = notes->src->lines;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nfree(src_line[i].path);\r\nfree(src_line);\r\nnotes->src->lines = NULL;\r\n}\r\nstatic int symbol__get_source_line(struct symbol *sym, struct map *map,\r\nint evidx, struct rb_root *root, int len,\r\nconst char *filename)\r\n{\r\nu64 start;\r\nint i;\r\nchar cmd[PATH_MAX * 2];\r\nstruct source_line *src_line;\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\nif (!h->sum)\r\nreturn 0;\r\nsrc_line = notes->src->lines = calloc(len, sizeof(struct source_line));\r\nif (!notes->src->lines)\r\nreturn -1;\r\nstart = map->unmap_ip(map, sym->start);\r\nfor (i = 0; i < len; i++) {\r\nchar *path = NULL;\r\nsize_t line_len;\r\nu64 offset;\r\nFILE *fp;\r\nsrc_line[i].percent = 100.0 * h->addr[i] / h->sum;\r\nif (src_line[i].percent <= 0.5)\r\ncontinue;\r\noffset = start + i;\r\nsprintf(cmd, "addr2line -e %s %016" PRIx64, filename, offset);\r\nfp = popen(cmd, "r");\r\nif (!fp)\r\ncontinue;\r\nif (getline(&path, &line_len, fp) < 0 || !line_len)\r\ngoto next;\r\nsrc_line[i].path = malloc(sizeof(char) * line_len + 1);\r\nif (!src_line[i].path)\r\ngoto next;\r\nstrcpy(src_line[i].path, path);\r\ninsert_source_line(root, &src_line[i]);\r\nnext:\r\npclose(fp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void print_summary(struct rb_root *root, const char *filename)\r\n{\r\nstruct source_line *src_line;\r\nstruct rb_node *node;\r\nprintf("\nSorted summary for file %s\n", filename);\r\nprintf("----------------------------------------------\n\n");\r\nif (RB_EMPTY_ROOT(root)) {\r\nprintf(" Nothing higher than %1.1f%%\n", MIN_GREEN);\r\nreturn;\r\n}\r\nnode = rb_first(root);\r\nwhile (node) {\r\ndouble percent;\r\nconst char *color;\r\nchar *path;\r\nsrc_line = rb_entry(node, struct source_line, node);\r\npercent = src_line->percent;\r\ncolor = get_percent_color(percent);\r\npath = src_line->path;\r\ncolor_fprintf(stdout, color, " %7.2f %s", percent, path);\r\nnode = rb_next(node);\r\n}\r\n}\r\nstatic void symbol__annotate_hits(struct symbol *sym, int evidx)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\nu64 len = sym->end - sym->start, offset;\r\nfor (offset = 0; offset < len; ++offset)\r\nif (h->addr[offset] != 0)\r\nprintf("%*" PRIx64 ": %" PRIu64 "\n", BITS_PER_LONG / 2,\r\nsym->start + offset, h->addr[offset]);\r\nprintf("%*s: %" PRIu64 "\n", BITS_PER_LONG / 2, "h->sum", h->sum);\r\n}\r\nint symbol__annotate_printf(struct symbol *sym, struct map *map, int evidx,\r\nbool full_paths, int min_pcnt, int max_lines,\r\nint context)\r\n{\r\nstruct dso *dso = map->dso;\r\nconst char *filename = dso->long_name, *d_filename;\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct objdump_line *pos, *queue = NULL;\r\nint printed = 2, queue_len = 0;\r\nint more = 0;\r\nu64 len;\r\nif (full_paths)\r\nd_filename = filename;\r\nelse\r\nd_filename = basename(filename);\r\nlen = sym->end - sym->start;\r\nprintf(" Percent | Source code & Disassembly of %s\n", d_filename);\r\nprintf("------------------------------------------------\n");\r\nif (verbose)\r\nsymbol__annotate_hits(sym, evidx);\r\nlist_for_each_entry(pos, &notes->src->source, node) {\r\nif (context && queue == NULL) {\r\nqueue = pos;\r\nqueue_len = 0;\r\n}\r\nswitch (objdump_line__print(pos, sym, evidx, len, min_pcnt,\r\nprinted, max_lines, queue)) {\r\ncase 0:\r\n++printed;\r\nif (context) {\r\nprinted += queue_len;\r\nqueue = NULL;\r\nqueue_len = 0;\r\n}\r\nbreak;\r\ncase 1:\r\n++more;\r\nbreak;\r\ncase -1:\r\ndefault:\r\nif (!context)\r\nbreak;\r\nif (queue_len == context)\r\nqueue = list_entry(queue->node.next, typeof(*queue), node);\r\nelse\r\n++queue_len;\r\nbreak;\r\n}\r\n}\r\nreturn more;\r\n}\r\nvoid symbol__annotate_zero_histogram(struct symbol *sym, int evidx)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\nmemset(h, 0, notes->src->sizeof_sym_hist);\r\n}\r\nvoid symbol__annotate_decay_histogram(struct symbol *sym, int evidx)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\nstruct objdump_line *pos;\r\nint len = sym->end - sym->start;\r\nh->sum = 0;\r\nlist_for_each_entry(pos, &notes->src->source, node) {\r\nif (pos->offset != -1 && pos->offset < len) {\r\nh->addr[pos->offset] = h->addr[pos->offset] * 7 / 8;\r\nh->sum += h->addr[pos->offset];\r\n}\r\n}\r\n}\r\nvoid objdump_line_list__purge(struct list_head *head)\r\n{\r\nstruct objdump_line *pos, *n;\r\nlist_for_each_entry_safe(pos, n, head, node) {\r\nlist_del(&pos->node);\r\nobjdump_line__free(pos);\r\n}\r\n}\r\nint symbol__tty_annotate(struct symbol *sym, struct map *map, int evidx,\r\nbool print_lines, bool full_paths, int min_pcnt,\r\nint max_lines)\r\n{\r\nstruct dso *dso = map->dso;\r\nconst char *filename = dso->long_name;\r\nstruct rb_root source_line = RB_ROOT;\r\nu64 len;\r\nif (symbol__annotate(sym, map, 0) < 0)\r\nreturn -1;\r\nlen = sym->end - sym->start;\r\nif (print_lines) {\r\nsymbol__get_source_line(sym, map, evidx, &source_line,\r\nlen, filename);\r\nprint_summary(&source_line, filename);\r\n}\r\nsymbol__annotate_printf(sym, map, evidx, full_paths,\r\nmin_pcnt, max_lines, 0);\r\nif (print_lines)\r\nsymbol__free_source_line(sym, len);\r\nobjdump_line_list__purge(&symbol__annotation(sym)->src->source);\r\nreturn 0;\r\n}
