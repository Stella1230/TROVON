static inline void isp1362_enable_int(struct isp1362_hcd *isp1362_hcd, u16 mask)\r\n{\r\nif ((isp1362_hcd->irqenb | mask) == isp1362_hcd->irqenb)\r\nreturn;\r\nif (mask & ~isp1362_hcd->irqenb)\r\nisp1362_write_reg16(isp1362_hcd, HCuPINT, mask & ~isp1362_hcd->irqenb);\r\nisp1362_hcd->irqenb |= mask;\r\nif (isp1362_hcd->irq_active)\r\nreturn;\r\nisp1362_write_reg16(isp1362_hcd, HCuPINTENB, isp1362_hcd->irqenb);\r\n}\r\nstatic inline struct isp1362_ep_queue *get_ptd_queue(struct isp1362_hcd *isp1362_hcd,\r\nu16 offset)\r\n{\r\nstruct isp1362_ep_queue *epq = NULL;\r\nif (offset < isp1362_hcd->istl_queue[1].buf_start)\r\nepq = &isp1362_hcd->istl_queue[0];\r\nelse if (offset < isp1362_hcd->intl_queue.buf_start)\r\nepq = &isp1362_hcd->istl_queue[1];\r\nelse if (offset < isp1362_hcd->atl_queue.buf_start)\r\nepq = &isp1362_hcd->intl_queue;\r\nelse if (offset < isp1362_hcd->atl_queue.buf_start +\r\nisp1362_hcd->atl_queue.buf_size)\r\nepq = &isp1362_hcd->atl_queue;\r\nif (epq)\r\nDBG(1, "%s: PTD $%04x is on %s queue\n", __func__, offset, epq->name);\r\nelse\r\npr_warning("%s: invalid PTD $%04x\n", __func__, offset);\r\nreturn epq;\r\n}\r\nstatic inline int get_ptd_offset(struct isp1362_ep_queue *epq, u8 index)\r\n{\r\nint offset;\r\nif (index * epq->blk_size > epq->buf_size) {\r\npr_warning("%s: Bad %s index %d(%d)\n", __func__, epq->name, index,\r\nepq->buf_size / epq->blk_size);\r\nreturn -EINVAL;\r\n}\r\noffset = epq->buf_start + index * epq->blk_size;\r\nDBG(3, "%s: %s PTD[%02x] # %04x\n", __func__, epq->name, index, offset);\r\nreturn offset;\r\n}\r\nstatic inline u16 max_transfer_size(struct isp1362_ep_queue *epq, size_t size,\r\nint mps)\r\n{\r\nu16 xfer_size = min_t(size_t, MAX_XFER_SIZE, size);\r\nxfer_size = min_t(size_t, xfer_size, epq->buf_avail * epq->blk_size - PTD_HEADER_SIZE);\r\nif (xfer_size < size && xfer_size % mps)\r\nxfer_size -= xfer_size % mps;\r\nreturn xfer_size;\r\n}\r\nstatic int claim_ptd_buffers(struct isp1362_ep_queue *epq,\r\nstruct isp1362_ep *ep, u16 len)\r\n{\r\nint ptd_offset = -EINVAL;\r\nint num_ptds = ((len + PTD_HEADER_SIZE - 1) / epq->blk_size) + 1;\r\nint found;\r\nBUG_ON(len > epq->buf_size);\r\nif (!epq->buf_avail)\r\nreturn -ENOMEM;\r\nif (ep->num_ptds)\r\npr_err("%s: %s len %d/%d num_ptds %d buf_map %08lx skip_map %08lx\n", __func__,\r\nepq->name, len, epq->blk_size, num_ptds, epq->buf_map, epq->skip_map);\r\nBUG_ON(ep->num_ptds != 0);\r\nfound = bitmap_find_next_zero_area(&epq->buf_map, epq->buf_count, 0,\r\nnum_ptds, 0);\r\nif (found >= epq->buf_count)\r\nreturn -EOVERFLOW;\r\nDBG(1, "%s: Found %d PTDs[%d] for %d/%d byte\n", __func__,\r\nnum_ptds, found, len, (int)(epq->blk_size - PTD_HEADER_SIZE));\r\nptd_offset = get_ptd_offset(epq, found);\r\nWARN_ON(ptd_offset < 0);\r\nep->ptd_offset = ptd_offset;\r\nep->num_ptds += num_ptds;\r\nepq->buf_avail -= num_ptds;\r\nBUG_ON(epq->buf_avail > epq->buf_count);\r\nep->ptd_index = found;\r\nbitmap_set(&epq->buf_map, found, num_ptds);\r\nDBG(1, "%s: Done %s PTD[%d] $%04x, avail %d count %d claimed %d %08lx:%08lx\n",\r\n__func__, epq->name, ep->ptd_index, ep->ptd_offset,\r\nepq->buf_avail, epq->buf_count, num_ptds, epq->buf_map, epq->skip_map);\r\nreturn found;\r\n}\r\nstatic inline void release_ptd_buffers(struct isp1362_ep_queue *epq, struct isp1362_ep *ep)\r\n{\r\nint last = ep->ptd_index + ep->num_ptds;\r\nif (last > epq->buf_count)\r\npr_err("%s: ep %p req %d len %d %s PTD[%d] $%04x num_ptds %d buf_count %d buf_avail %d buf_map %08lx skip_map %08lx\n",\r\n__func__, ep, ep->num_req, ep->length, epq->name, ep->ptd_index,\r\nep->ptd_offset, ep->num_ptds, epq->buf_count, epq->buf_avail,\r\nepq->buf_map, epq->skip_map);\r\nBUG_ON(last > epq->buf_count);\r\nbitmap_clear(&epq->buf_map, ep->ptd_index, ep->num_ptds);\r\nbitmap_set(&epq->skip_map, ep->ptd_index, ep->num_ptds);\r\nepq->buf_avail += ep->num_ptds;\r\nepq->ptd_count--;\r\nBUG_ON(epq->buf_avail > epq->buf_count);\r\nBUG_ON(epq->ptd_count > epq->buf_count);\r\nDBG(1, "%s: Done %s PTDs $%04x released %d avail %d count %d\n",\r\n__func__, epq->name,\r\nep->ptd_offset, ep->num_ptds, epq->buf_avail, epq->buf_count);\r\nDBG(1, "%s: buf_map %08lx skip_map %08lx\n", __func__,\r\nepq->buf_map, epq->skip_map);\r\nep->num_ptds = 0;\r\nep->ptd_offset = -EINVAL;\r\nep->ptd_index = -EINVAL;\r\n}\r\nstatic void prepare_ptd(struct isp1362_hcd *isp1362_hcd, struct urb *urb,\r\nstruct isp1362_ep *ep, struct isp1362_ep_queue *epq,\r\nu16 fno)\r\n{\r\nstruct ptd *ptd;\r\nint toggle;\r\nint dir;\r\nu16 len;\r\nsize_t buf_len = urb->transfer_buffer_length - urb->actual_length;\r\nDBG(3, "%s: %s ep %p\n", __func__, epq->name, ep);\r\nptd = &ep->ptd;\r\nep->data = (unsigned char *)urb->transfer_buffer + urb->actual_length;\r\nswitch (ep->nextpid) {\r\ncase USB_PID_IN:\r\ntoggle = usb_gettoggle(urb->dev, ep->epnum, 0);\r\ndir = PTD_DIR_IN;\r\nif (usb_pipecontrol(urb->pipe)) {\r\nlen = min_t(size_t, ep->maxpacket, buf_len);\r\n} else if (usb_pipeisoc(urb->pipe)) {\r\nlen = min_t(size_t, urb->iso_frame_desc[fno].length, MAX_XFER_SIZE);\r\nep->data = urb->transfer_buffer + urb->iso_frame_desc[fno].offset;\r\n} else\r\nlen = max_transfer_size(epq, buf_len, ep->maxpacket);\r\nDBG(1, "%s: IN len %d/%d/%d from URB\n", __func__, len, ep->maxpacket,\r\n(int)buf_len);\r\nbreak;\r\ncase USB_PID_OUT:\r\ntoggle = usb_gettoggle(urb->dev, ep->epnum, 1);\r\ndir = PTD_DIR_OUT;\r\nif (usb_pipecontrol(urb->pipe))\r\nlen = min_t(size_t, ep->maxpacket, buf_len);\r\nelse if (usb_pipeisoc(urb->pipe))\r\nlen = min_t(size_t, urb->iso_frame_desc[0].length, MAX_XFER_SIZE);\r\nelse\r\nlen = max_transfer_size(epq, buf_len, ep->maxpacket);\r\nif (len == 0)\r\npr_info("%s: Sending ZERO packet: %d\n", __func__,\r\nurb->transfer_flags & URB_ZERO_PACKET);\r\nDBG(1, "%s: OUT len %d/%d/%d from URB\n", __func__, len, ep->maxpacket,\r\n(int)buf_len);\r\nbreak;\r\ncase USB_PID_SETUP:\r\ntoggle = 0;\r\ndir = PTD_DIR_SETUP;\r\nlen = sizeof(struct usb_ctrlrequest);\r\nDBG(1, "%s: SETUP len %d\n", __func__, len);\r\nep->data = urb->setup_packet;\r\nbreak;\r\ncase USB_PID_ACK:\r\ntoggle = 1;\r\nlen = 0;\r\ndir = (urb->transfer_buffer_length && usb_pipein(urb->pipe)) ?\r\nPTD_DIR_OUT : PTD_DIR_IN;\r\nDBG(1, "%s: ACK len %d\n", __func__, len);\r\nbreak;\r\ndefault:\r\ntoggle = dir = len = 0;\r\npr_err("%s@%d: ep->nextpid %02x\n", __func__, __LINE__, ep->nextpid);\r\nBUG_ON(1);\r\n}\r\nep->length = len;\r\nif (!len)\r\nep->data = NULL;\r\nptd->count = PTD_CC_MSK | PTD_ACTIVE_MSK | PTD_TOGGLE(toggle);\r\nptd->mps = PTD_MPS(ep->maxpacket) | PTD_SPD(urb->dev->speed == USB_SPEED_LOW) |\r\nPTD_EP(ep->epnum);\r\nptd->len = PTD_LEN(len) | PTD_DIR(dir);\r\nptd->faddr = PTD_FA(usb_pipedevice(urb->pipe));\r\nif (usb_pipeint(urb->pipe)) {\r\nptd->faddr |= PTD_SF_INT(ep->branch);\r\nptd->faddr |= PTD_PR(ep->interval ? __ffs(ep->interval) : 0);\r\n}\r\nif (usb_pipeisoc(urb->pipe))\r\nptd->faddr |= PTD_SF_ISO(fno);\r\nDBG(1, "%s: Finished\n", __func__);\r\n}\r\nstatic void isp1362_write_ptd(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep,\r\nstruct isp1362_ep_queue *epq)\r\n{\r\nstruct ptd *ptd = &ep->ptd;\r\nint len = PTD_GET_DIR(ptd) == PTD_DIR_IN ? 0 : ep->length;\r\n_BUG_ON(ep->ptd_offset < 0);\r\nprefetch(ptd);\r\nisp1362_write_buffer(isp1362_hcd, ptd, ep->ptd_offset, PTD_HEADER_SIZE);\r\nif (len)\r\nisp1362_write_buffer(isp1362_hcd, ep->data,\r\nep->ptd_offset + PTD_HEADER_SIZE, len);\r\ndump_ptd(ptd);\r\ndump_ptd_out_data(ptd, ep->data);\r\n}\r\nstatic void isp1362_read_ptd(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep,\r\nstruct isp1362_ep_queue *epq)\r\n{\r\nstruct ptd *ptd = &ep->ptd;\r\nint act_len;\r\nWARN_ON(list_empty(&ep->active));\r\nBUG_ON(ep->ptd_offset < 0);\r\nlist_del_init(&ep->active);\r\nDBG(1, "%s: ep %p removed from active list %p\n", __func__, ep, &epq->active);\r\nprefetchw(ptd);\r\nisp1362_read_buffer(isp1362_hcd, ptd, ep->ptd_offset, PTD_HEADER_SIZE);\r\ndump_ptd(ptd);\r\nact_len = PTD_GET_COUNT(ptd);\r\nif (PTD_GET_DIR(ptd) != PTD_DIR_IN || act_len == 0)\r\nreturn;\r\nif (act_len > ep->length)\r\npr_err("%s: ep %p PTD $%04x act_len %d ep->length %d\n", __func__, ep,\r\nep->ptd_offset, act_len, ep->length);\r\nBUG_ON(act_len > ep->length);\r\nprefetchw(ep->data);\r\nisp1362_read_buffer(isp1362_hcd, ep->data,\r\nep->ptd_offset + PTD_HEADER_SIZE, act_len);\r\ndump_ptd_in_data(ptd, ep->data);\r\n}\r\nstatic void remove_ptd(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep)\r\n{\r\nint index;\r\nstruct isp1362_ep_queue *epq;\r\nDBG(1, "%s: ep %p PTD[%d] $%04x\n", __func__, ep, ep->ptd_index, ep->ptd_offset);\r\nBUG_ON(ep->ptd_offset < 0);\r\nepq = get_ptd_queue(isp1362_hcd, ep->ptd_offset);\r\nBUG_ON(!epq);\r\nWARN_ON(!list_empty(&ep->remove_list));\r\nlist_add_tail(&ep->remove_list, &isp1362_hcd->remove_list);\r\nisp1362_enable_int(isp1362_hcd, HCuPINT_SOF);\r\nindex = ep->ptd_index;\r\nif (index < 0)\r\nreturn;\r\nDBG(1, "%s: Disabling PTD[%02x] $%04x %08lx|%08x\n", __func__,\r\nindex, ep->ptd_offset, epq->skip_map, 1 << index);\r\nepq->skip_map |= 1 << index;\r\nif (epq == &isp1362_hcd->atl_queue) {\r\nDBG(2, "%s: ATLSKIP = %08x -> %08lx\n", __func__,\r\nisp1362_read_reg32(isp1362_hcd, HCATLSKIP), epq->skip_map);\r\nisp1362_write_reg32(isp1362_hcd, HCATLSKIP, epq->skip_map);\r\nif (~epq->skip_map == 0)\r\nisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ATL_ACTIVE);\r\n} else if (epq == &isp1362_hcd->intl_queue) {\r\nDBG(2, "%s: INTLSKIP = %08x -> %08lx\n", __func__,\r\nisp1362_read_reg32(isp1362_hcd, HCINTLSKIP), epq->skip_map);\r\nisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, epq->skip_map);\r\nif (~epq->skip_map == 0)\r\nisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_INTL_ACTIVE);\r\n}\r\n}\r\nstatic void finish_request(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep,\r\nstruct urb *urb, int status)\r\n__releases(isp1362_hcd->lock)\r\n__acquires(isp1362_hcd->lock)\r\n{\r\nurb->hcpriv = NULL;\r\nep->error_count = 0;\r\nif (usb_pipecontrol(urb->pipe))\r\nep->nextpid = USB_PID_SETUP;\r\nURB_DBG("%s: req %d FA %d ep%d%s %s: len %d/%d %s stat %d\n", __func__,\r\nep->num_req, usb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe),\r\n!usb_pipein(urb->pipe) ? "out" : "in",\r\nusb_pipecontrol(urb->pipe) ? "ctrl" :\r\nusb_pipeint(urb->pipe) ? "int" :\r\nusb_pipebulk(urb->pipe) ? "bulk" :\r\n"iso",\r\nurb->actual_length, urb->transfer_buffer_length,\r\n!(urb->transfer_flags & URB_SHORT_NOT_OK) ?\r\n"short_ok" : "", urb->status);\r\nusb_hcd_unlink_urb_from_ep(isp1362_hcd_to_hcd(isp1362_hcd), urb);\r\nspin_unlock(&isp1362_hcd->lock);\r\nusb_hcd_giveback_urb(isp1362_hcd_to_hcd(isp1362_hcd), urb, status);\r\nspin_lock(&isp1362_hcd->lock);\r\nif (!list_empty(&ep->hep->urb_list))\r\nreturn;\r\nif (!list_empty(&ep->schedule)) {\r\nlist_del_init(&ep->schedule);\r\nreturn;\r\n}\r\nif (ep->interval) {\r\nDBG(1, "deschedule qh%d/%p branch %d load %d bandwidth %d -> %d\n", ep->interval,\r\nep, ep->branch, ep->load,\r\nisp1362_hcd->load[ep->branch],\r\nisp1362_hcd->load[ep->branch] - ep->load);\r\nisp1362_hcd->load[ep->branch] -= ep->load;\r\nep->branch = PERIODIC_SIZE;\r\n}\r\n}\r\nstatic void postproc_ep(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep)\r\n{\r\nstruct urb *urb = get_urb(ep);\r\nstruct usb_device *udev;\r\nstruct ptd *ptd;\r\nint short_ok;\r\nu16 len;\r\nint urbstat = -EINPROGRESS;\r\nu8 cc;\r\nDBG(2, "%s: ep %p req %d\n", __func__, ep, ep->num_req);\r\nudev = urb->dev;\r\nptd = &ep->ptd;\r\ncc = PTD_GET_CC(ptd);\r\nif (cc == PTD_NOTACCESSED) {\r\npr_err("%s: req %d PTD %p Untouched by ISP1362\n", __func__,\r\nep->num_req, ptd);\r\ncc = PTD_DEVNOTRESP;\r\n}\r\nshort_ok = !(urb->transfer_flags & URB_SHORT_NOT_OK);\r\nlen = urb->transfer_buffer_length - urb->actual_length;\r\nif (cc == PTD_DATAUNDERRUN) {\r\nif (short_ok) {\r\nDBG(1, "%s: req %d Allowed data underrun short_%sok %d/%d/%d byte\n",\r\n__func__, ep->num_req, short_ok ? "" : "not_",\r\nPTD_GET_COUNT(ptd), ep->maxpacket, len);\r\ncc = PTD_CC_NOERROR;\r\nurbstat = 0;\r\n} else {\r\nDBG(1, "%s: req %d Data Underrun %s nextpid %02x short_%sok %d/%d/%d byte\n",\r\n__func__, ep->num_req,\r\nusb_pipein(urb->pipe) ? "IN" : "OUT", ep->nextpid,\r\nshort_ok ? "" : "not_",\r\nPTD_GET_COUNT(ptd), ep->maxpacket, len);\r\nif (usb_pipecontrol(urb->pipe)) {\r\nep->nextpid = USB_PID_ACK;\r\nurb->actual_length += PTD_GET_COUNT(ptd);\r\nBUG_ON(urb->actual_length > urb->transfer_buffer_length);\r\nif (urb->status == -EINPROGRESS)\r\nurb->status = cc_to_error[PTD_DATAUNDERRUN];\r\n} else {\r\nusb_settoggle(udev, ep->epnum, ep->nextpid == USB_PID_OUT,\r\nPTD_GET_TOGGLE(ptd));\r\nurbstat = cc_to_error[PTD_DATAUNDERRUN];\r\n}\r\ngoto out;\r\n}\r\n}\r\nif (cc != PTD_CC_NOERROR) {\r\nif (++ep->error_count >= 3 || cc == PTD_CC_STALL || cc == PTD_DATAOVERRUN) {\r\nurbstat = cc_to_error[cc];\r\nDBG(1, "%s: req %d nextpid %02x, status %d, error %d, error_count %d\n",\r\n__func__, ep->num_req, ep->nextpid, urbstat, cc,\r\nep->error_count);\r\n}\r\ngoto out;\r\n}\r\nswitch (ep->nextpid) {\r\ncase USB_PID_OUT:\r\nif (PTD_GET_COUNT(ptd) != ep->length)\r\npr_err("%s: count=%d len=%d\n", __func__,\r\nPTD_GET_COUNT(ptd), ep->length);\r\nBUG_ON(PTD_GET_COUNT(ptd) != ep->length);\r\nurb->actual_length += ep->length;\r\nBUG_ON(urb->actual_length > urb->transfer_buffer_length);\r\nusb_settoggle(udev, ep->epnum, 1, PTD_GET_TOGGLE(ptd));\r\nif (urb->actual_length == urb->transfer_buffer_length) {\r\nDBG(3, "%s: req %d xfer complete %d/%d status %d -> 0\n", __func__,\r\nep->num_req, len, ep->maxpacket, urbstat);\r\nif (usb_pipecontrol(urb->pipe)) {\r\nDBG(3, "%s: req %d %s Wait for ACK\n", __func__,\r\nep->num_req,\r\nusb_pipein(urb->pipe) ? "IN" : "OUT");\r\nep->nextpid = USB_PID_ACK;\r\n} else {\r\nif (len % ep->maxpacket ||\r\n!(urb->transfer_flags & URB_ZERO_PACKET)) {\r\nurbstat = 0;\r\nDBG(3, "%s: req %d URB %s status %d count %d/%d/%d\n",\r\n__func__, ep->num_req, usb_pipein(urb->pipe) ? "IN" : "OUT",\r\nurbstat, len, ep->maxpacket, urb->actual_length);\r\n}\r\n}\r\n}\r\nbreak;\r\ncase USB_PID_IN:\r\nlen = PTD_GET_COUNT(ptd);\r\nBUG_ON(len > ep->length);\r\nurb->actual_length += len;\r\nBUG_ON(urb->actual_length > urb->transfer_buffer_length);\r\nusb_settoggle(udev, ep->epnum, 0, PTD_GET_TOGGLE(ptd));\r\nif ((urb->transfer_buffer_length == urb->actual_length) ||\r\nlen % ep->maxpacket) {\r\nDBG(3, "%s: req %d xfer complete %d/%d status %d -> 0\n", __func__,\r\nep->num_req, len, ep->maxpacket, urbstat);\r\nif (usb_pipecontrol(urb->pipe)) {\r\nDBG(3, "%s: req %d %s Wait for ACK\n", __func__,\r\nep->num_req,\r\nusb_pipein(urb->pipe) ? "IN" : "OUT");\r\nep->nextpid = USB_PID_ACK;\r\n} else {\r\nurbstat = 0;\r\nDBG(3, "%s: req %d URB %s status %d count %d/%d/%d\n",\r\n__func__, ep->num_req, usb_pipein(urb->pipe) ? "IN" : "OUT",\r\nurbstat, len, ep->maxpacket, urb->actual_length);\r\n}\r\n}\r\nbreak;\r\ncase USB_PID_SETUP:\r\nif (urb->transfer_buffer_length == urb->actual_length) {\r\nep->nextpid = USB_PID_ACK;\r\n} else if (usb_pipeout(urb->pipe)) {\r\nusb_settoggle(udev, 0, 1, 1);\r\nep->nextpid = USB_PID_OUT;\r\n} else {\r\nusb_settoggle(udev, 0, 0, 1);\r\nep->nextpid = USB_PID_IN;\r\n}\r\nbreak;\r\ncase USB_PID_ACK:\r\nDBG(3, "%s: req %d got ACK %d -> 0\n", __func__, ep->num_req,\r\nurbstat);\r\nWARN_ON(urbstat != -EINPROGRESS);\r\nurbstat = 0;\r\nep->nextpid = 0;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nout:\r\nif (urbstat != -EINPROGRESS) {\r\nDBG(2, "%s: Finishing ep %p req %d urb %p status %d\n", __func__,\r\nep, ep->num_req, urb, urbstat);\r\nfinish_request(isp1362_hcd, ep, urb, urbstat);\r\n}\r\n}\r\nstatic void finish_unlinks(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nstruct isp1362_ep *ep;\r\nstruct isp1362_ep *tmp;\r\nlist_for_each_entry_safe(ep, tmp, &isp1362_hcd->remove_list, remove_list) {\r\nstruct isp1362_ep_queue *epq =\r\nget_ptd_queue(isp1362_hcd, ep->ptd_offset);\r\nint index = ep->ptd_index;\r\nBUG_ON(epq == NULL);\r\nif (index >= 0) {\r\nDBG(1, "%s: remove PTD[%d] $%04x\n", __func__, index, ep->ptd_offset);\r\nBUG_ON(ep->num_ptds == 0);\r\nrelease_ptd_buffers(epq, ep);\r\n}\r\nif (!list_empty(&ep->hep->urb_list)) {\r\nstruct urb *urb = get_urb(ep);\r\nDBG(1, "%s: Finishing req %d ep %p from remove_list\n", __func__,\r\nep->num_req, ep);\r\nfinish_request(isp1362_hcd, ep, urb, -ESHUTDOWN);\r\n}\r\nWARN_ON(list_empty(&ep->active));\r\nif (!list_empty(&ep->active)) {\r\nlist_del_init(&ep->active);\r\nDBG(1, "%s: ep %p removed from active list\n", __func__, ep);\r\n}\r\nlist_del_init(&ep->remove_list);\r\nDBG(1, "%s: ep %p removed from remove_list\n", __func__, ep);\r\n}\r\nDBG(1, "%s: Done\n", __func__);\r\n}\r\nstatic inline void enable_atl_transfers(struct isp1362_hcd *isp1362_hcd, int count)\r\n{\r\nif (count > 0) {\r\nif (count < isp1362_hcd->atl_queue.ptd_count)\r\nisp1362_write_reg16(isp1362_hcd, HCATLDTC, count);\r\nisp1362_enable_int(isp1362_hcd, HCuPINT_ATL);\r\nisp1362_write_reg32(isp1362_hcd, HCATLSKIP, isp1362_hcd->atl_queue.skip_map);\r\nisp1362_set_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ATL_ACTIVE);\r\n} else\r\nisp1362_enable_int(isp1362_hcd, HCuPINT_SOF);\r\n}\r\nstatic inline void enable_intl_transfers(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nisp1362_enable_int(isp1362_hcd, HCuPINT_INTL);\r\nisp1362_set_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_INTL_ACTIVE);\r\nisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, isp1362_hcd->intl_queue.skip_map);\r\n}\r\nstatic inline void enable_istl_transfers(struct isp1362_hcd *isp1362_hcd, int flip)\r\n{\r\nisp1362_enable_int(isp1362_hcd, flip ? HCuPINT_ISTL1 : HCuPINT_ISTL0);\r\nisp1362_set_mask16(isp1362_hcd, HCBUFSTAT, flip ?\r\nHCBUFSTAT_ISTL1_FULL : HCBUFSTAT_ISTL0_FULL);\r\n}\r\nstatic int submit_req(struct isp1362_hcd *isp1362_hcd, struct urb *urb,\r\nstruct isp1362_ep *ep, struct isp1362_ep_queue *epq)\r\n{\r\nint index = epq->free_ptd;\r\nprepare_ptd(isp1362_hcd, urb, ep, epq, 0);\r\nindex = claim_ptd_buffers(epq, ep, ep->length);\r\nif (index == -ENOMEM) {\r\nDBG(1, "%s: req %d No free %s PTD available: %d, %08lx:%08lx\n", __func__,\r\nep->num_req, epq->name, ep->num_ptds, epq->buf_map, epq->skip_map);\r\nreturn index;\r\n} else if (index == -EOVERFLOW) {\r\nDBG(1, "%s: req %d Not enough space for %d byte %s PTD %d %08lx:%08lx\n",\r\n__func__, ep->num_req, ep->length, epq->name, ep->num_ptds,\r\nepq->buf_map, epq->skip_map);\r\nreturn index;\r\n} else\r\nBUG_ON(index < 0);\r\nlist_add_tail(&ep->active, &epq->active);\r\nDBG(1, "%s: ep %p req %d len %d added to active list %p\n", __func__,\r\nep, ep->num_req, ep->length, &epq->active);\r\nDBG(1, "%s: Submitting %s PTD $%04x for ep %p req %d\n", __func__, epq->name,\r\nep->ptd_offset, ep, ep->num_req);\r\nisp1362_write_ptd(isp1362_hcd, ep, epq);\r\n__clear_bit(ep->ptd_index, &epq->skip_map);\r\nreturn 0;\r\n}\r\nstatic void start_atl_transfers(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nint ptd_count = 0;\r\nstruct isp1362_ep_queue *epq = &isp1362_hcd->atl_queue;\r\nstruct isp1362_ep *ep;\r\nint defer = 0;\r\nif (atomic_read(&epq->finishing)) {\r\nDBG(1, "%s: finish_transfers is active for %s\n", __func__, epq->name);\r\nreturn;\r\n}\r\nlist_for_each_entry(ep, &isp1362_hcd->async, schedule) {\r\nstruct urb *urb = get_urb(ep);\r\nint ret;\r\nif (!list_empty(&ep->active)) {\r\nDBG(2, "%s: Skipping active %s ep %p\n", __func__, epq->name, ep);\r\ncontinue;\r\n}\r\nDBG(1, "%s: Processing %s ep %p req %d\n", __func__, epq->name,\r\nep, ep->num_req);\r\nret = submit_req(isp1362_hcd, urb, ep, epq);\r\nif (ret == -ENOMEM) {\r\ndefer = 1;\r\nbreak;\r\n} else if (ret == -EOVERFLOW) {\r\ndefer = 1;\r\ncontinue;\r\n}\r\n#ifdef BUGGY_PXA2XX_UDC_USBTEST\r\ndefer = ep->nextpid == USB_PID_SETUP;\r\n#endif\r\nptd_count++;\r\n}\r\nif (isp1362_hcd->async.next != isp1362_hcd->async.prev) {\r\nDBG(2, "%s: Cycling ASYNC schedule %d\n", __func__, ptd_count);\r\nlist_move(&isp1362_hcd->async, isp1362_hcd->async.next);\r\n}\r\nif (ptd_count || defer)\r\nenable_atl_transfers(isp1362_hcd, defer ? 0 : ptd_count);\r\nepq->ptd_count += ptd_count;\r\nif (epq->ptd_count > epq->stat_maxptds) {\r\nepq->stat_maxptds = epq->ptd_count;\r\nDBG(0, "%s: max_ptds: %d\n", __func__, epq->stat_maxptds);\r\n}\r\n}\r\nstatic void start_intl_transfers(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nint ptd_count = 0;\r\nstruct isp1362_ep_queue *epq = &isp1362_hcd->intl_queue;\r\nstruct isp1362_ep *ep;\r\nif (atomic_read(&epq->finishing)) {\r\nDBG(1, "%s: finish_transfers is active for %s\n", __func__, epq->name);\r\nreturn;\r\n}\r\nlist_for_each_entry(ep, &isp1362_hcd->periodic, schedule) {\r\nstruct urb *urb = get_urb(ep);\r\nint ret;\r\nif (!list_empty(&ep->active)) {\r\nDBG(1, "%s: Skipping active %s ep %p\n", __func__,\r\nepq->name, ep);\r\ncontinue;\r\n}\r\nDBG(1, "%s: Processing %s ep %p req %d\n", __func__,\r\nepq->name, ep, ep->num_req);\r\nret = submit_req(isp1362_hcd, urb, ep, epq);\r\nif (ret == -ENOMEM)\r\nbreak;\r\nelse if (ret == -EOVERFLOW)\r\ncontinue;\r\nptd_count++;\r\n}\r\nif (ptd_count) {\r\nstatic int last_count;\r\nif (ptd_count != last_count) {\r\nDBG(0, "%s: ptd_count: %d\n", __func__, ptd_count);\r\nlast_count = ptd_count;\r\n}\r\nenable_intl_transfers(isp1362_hcd);\r\n}\r\nepq->ptd_count += ptd_count;\r\nif (epq->ptd_count > epq->stat_maxptds)\r\nepq->stat_maxptds = epq->ptd_count;\r\n}\r\nstatic inline int next_ptd(struct isp1362_ep_queue *epq, struct isp1362_ep *ep)\r\n{\r\nu16 ptd_offset = ep->ptd_offset;\r\nint num_ptds = (ep->length + PTD_HEADER_SIZE + (epq->blk_size - 1)) / epq->blk_size;\r\nDBG(2, "%s: PTD offset $%04x + %04x => %d * %04x -> $%04x\n", __func__, ptd_offset,\r\nep->length, num_ptds, epq->blk_size, ptd_offset + num_ptds * epq->blk_size);\r\nptd_offset += num_ptds * epq->blk_size;\r\nif (ptd_offset < epq->buf_start + epq->buf_size)\r\nreturn ptd_offset;\r\nelse\r\nreturn -ENOMEM;\r\n}\r\nstatic void start_iso_transfers(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nint ptd_count = 0;\r\nint flip = isp1362_hcd->istl_flip;\r\nstruct isp1362_ep_queue *epq;\r\nint ptd_offset;\r\nstruct isp1362_ep *ep;\r\nstruct isp1362_ep *tmp;\r\nu16 fno = isp1362_read_reg32(isp1362_hcd, HCFMNUM);\r\nfill2:\r\nepq = &isp1362_hcd->istl_queue[flip];\r\nif (atomic_read(&epq->finishing)) {\r\nDBG(1, "%s: finish_transfers is active for %s\n", __func__, epq->name);\r\nreturn;\r\n}\r\nif (!list_empty(&epq->active))\r\nreturn;\r\nptd_offset = epq->buf_start;\r\nlist_for_each_entry_safe(ep, tmp, &isp1362_hcd->isoc, schedule) {\r\nstruct urb *urb = get_urb(ep);\r\ns16 diff = fno - (u16)urb->start_frame;\r\nDBG(1, "%s: Processing %s ep %p\n", __func__, epq->name, ep);\r\nif (diff > urb->number_of_packets) {\r\nfinish_request(isp1362_hcd, ep, urb, -EOVERFLOW);\r\ncontinue;\r\n} else if (diff < -1) {\r\n} else if (diff == -1) {\r\nprepare_ptd(isp1362_hcd, urb, ep, epq, fno);\r\nif (ptd_offset + PTD_HEADER_SIZE + ep->length >\r\nepq->buf_start + epq->buf_size) {\r\npr_err("%s: Not enough ISO buffer space for %d byte PTD\n",\r\n__func__, ep->length);\r\ncontinue;\r\n}\r\nep->ptd_offset = ptd_offset;\r\nlist_add_tail(&ep->active, &epq->active);\r\nptd_offset = next_ptd(epq, ep);\r\nif (ptd_offset < 0) {\r\npr_warning("%s: req %d No more %s PTD buffers available\n", __func__,\r\nep->num_req, epq->name);\r\nbreak;\r\n}\r\n}\r\n}\r\nlist_for_each_entry(ep, &epq->active, active) {\r\nif (epq->active.next == &ep->active)\r\nep->ptd.mps |= PTD_LAST_MSK;\r\nisp1362_write_ptd(isp1362_hcd, ep, epq);\r\nptd_count++;\r\n}\r\nif (ptd_count)\r\nenable_istl_transfers(isp1362_hcd, flip);\r\nepq->ptd_count += ptd_count;\r\nif (epq->ptd_count > epq->stat_maxptds)\r\nepq->stat_maxptds = epq->ptd_count;\r\nif (!(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\r\n(flip ? HCBUFSTAT_ISTL0_FULL : HCBUFSTAT_ISTL1_FULL))) {\r\nfno++;\r\nptd_count = 0;\r\nflip = 1 - flip;\r\ngoto fill2;\r\n}\r\n}\r\nstatic void finish_transfers(struct isp1362_hcd *isp1362_hcd, unsigned long done_map,\r\nstruct isp1362_ep_queue *epq)\r\n{\r\nstruct isp1362_ep *ep;\r\nstruct isp1362_ep *tmp;\r\nif (list_empty(&epq->active)) {\r\nDBG(1, "%s: Nothing to do for %s queue\n", __func__, epq->name);\r\nreturn;\r\n}\r\nDBG(1, "%s: Finishing %s transfers %08lx\n", __func__, epq->name, done_map);\r\natomic_inc(&epq->finishing);\r\nlist_for_each_entry_safe(ep, tmp, &epq->active, active) {\r\nint index = ep->ptd_index;\r\nDBG(1, "%s: Checking %s PTD[%02x] $%04x\n", __func__, epq->name,\r\nindex, ep->ptd_offset);\r\nBUG_ON(index < 0);\r\nif (__test_and_clear_bit(index, &done_map)) {\r\nisp1362_read_ptd(isp1362_hcd, ep, epq);\r\nepq->free_ptd = index;\r\nBUG_ON(ep->num_ptds == 0);\r\nrelease_ptd_buffers(epq, ep);\r\nDBG(1, "%s: ep %p req %d removed from active list\n", __func__,\r\nep, ep->num_req);\r\nif (!list_empty(&ep->remove_list)) {\r\nlist_del_init(&ep->remove_list);\r\nDBG(1, "%s: ep %p removed from remove list\n", __func__, ep);\r\n}\r\nDBG(1, "%s: Postprocessing %s ep %p req %d\n", __func__, epq->name,\r\nep, ep->num_req);\r\npostproc_ep(isp1362_hcd, ep);\r\n}\r\nif (!done_map)\r\nbreak;\r\n}\r\nif (done_map)\r\npr_warning("%s: done_map not clear: %08lx:%08lx\n", __func__, done_map,\r\nepq->skip_map);\r\natomic_dec(&epq->finishing);\r\n}\r\nstatic void finish_iso_transfers(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep_queue *epq)\r\n{\r\nstruct isp1362_ep *ep;\r\nstruct isp1362_ep *tmp;\r\nif (list_empty(&epq->active)) {\r\nDBG(1, "%s: Nothing to do for %s queue\n", __func__, epq->name);\r\nreturn;\r\n}\r\nDBG(1, "%s: Finishing %s transfers\n", __func__, epq->name);\r\natomic_inc(&epq->finishing);\r\nlist_for_each_entry_safe(ep, tmp, &epq->active, active) {\r\nDBG(1, "%s: Checking PTD $%04x\n", __func__, ep->ptd_offset);\r\nisp1362_read_ptd(isp1362_hcd, ep, epq);\r\nDBG(1, "%s: Postprocessing %s ep %p\n", __func__, epq->name, ep);\r\npostproc_ep(isp1362_hcd, ep);\r\n}\r\nWARN_ON(epq->blk_size != 0);\r\natomic_dec(&epq->finishing);\r\n}\r\nstatic irqreturn_t isp1362_irq(struct usb_hcd *hcd)\r\n{\r\nint handled = 0;\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nu16 irqstat;\r\nu16 svc_mask;\r\nspin_lock(&isp1362_hcd->lock);\r\nBUG_ON(isp1362_hcd->irq_active++);\r\nisp1362_write_reg16(isp1362_hcd, HCuPINTENB, 0);\r\nirqstat = isp1362_read_reg16(isp1362_hcd, HCuPINT);\r\nDBG(3, "%s: got IRQ %04x:%04x\n", __func__, irqstat, isp1362_hcd->irqenb);\r\nirqstat &= isp1362_hcd->irqenb;\r\nisp1362_write_reg16(isp1362_hcd, HCuPINT, irqstat);\r\nsvc_mask = irqstat;\r\nif (irqstat & HCuPINT_SOF) {\r\nisp1362_hcd->irqenb &= ~HCuPINT_SOF;\r\nisp1362_hcd->irq_stat[ISP1362_INT_SOF]++;\r\nhandled = 1;\r\nsvc_mask &= ~HCuPINT_SOF;\r\nDBG(3, "%s: SOF\n", __func__);\r\nisp1362_hcd->fmindex = isp1362_read_reg32(isp1362_hcd, HCFMNUM);\r\nif (!list_empty(&isp1362_hcd->remove_list))\r\nfinish_unlinks(isp1362_hcd);\r\nif (!list_empty(&isp1362_hcd->async) && !(irqstat & HCuPINT_ATL)) {\r\nif (list_empty(&isp1362_hcd->atl_queue.active)) {\r\nstart_atl_transfers(isp1362_hcd);\r\n} else {\r\nisp1362_enable_int(isp1362_hcd, HCuPINT_ATL);\r\nisp1362_write_reg32(isp1362_hcd, HCATLSKIP,\r\nisp1362_hcd->atl_queue.skip_map);\r\nisp1362_set_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ATL_ACTIVE);\r\n}\r\n}\r\n}\r\nif (irqstat & HCuPINT_ISTL0) {\r\nisp1362_hcd->irq_stat[ISP1362_INT_ISTL0]++;\r\nhandled = 1;\r\nsvc_mask &= ~HCuPINT_ISTL0;\r\nisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ISTL0_FULL);\r\nDBG(1, "%s: ISTL0\n", __func__);\r\nWARN_ON((int)!!isp1362_hcd->istl_flip);\r\nWARN_ON(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\r\nHCBUFSTAT_ISTL0_ACTIVE);\r\nWARN_ON(!(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\r\nHCBUFSTAT_ISTL0_DONE));\r\nisp1362_hcd->irqenb &= ~HCuPINT_ISTL0;\r\n}\r\nif (irqstat & HCuPINT_ISTL1) {\r\nisp1362_hcd->irq_stat[ISP1362_INT_ISTL1]++;\r\nhandled = 1;\r\nsvc_mask &= ~HCuPINT_ISTL1;\r\nisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ISTL1_FULL);\r\nDBG(1, "%s: ISTL1\n", __func__);\r\nWARN_ON(!(int)isp1362_hcd->istl_flip);\r\nWARN_ON(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\r\nHCBUFSTAT_ISTL1_ACTIVE);\r\nWARN_ON(!(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\r\nHCBUFSTAT_ISTL1_DONE));\r\nisp1362_hcd->irqenb &= ~HCuPINT_ISTL1;\r\n}\r\nif (irqstat & (HCuPINT_ISTL0 | HCuPINT_ISTL1)) {\r\nWARN_ON((irqstat & (HCuPINT_ISTL0 | HCuPINT_ISTL1)) ==\r\n(HCuPINT_ISTL0 | HCuPINT_ISTL1));\r\nfinish_iso_transfers(isp1362_hcd,\r\n&isp1362_hcd->istl_queue[isp1362_hcd->istl_flip]);\r\nstart_iso_transfers(isp1362_hcd);\r\nisp1362_hcd->istl_flip = 1 - isp1362_hcd->istl_flip;\r\n}\r\nif (irqstat & HCuPINT_INTL) {\r\nu32 done_map = isp1362_read_reg32(isp1362_hcd, HCINTLDONE);\r\nu32 skip_map = isp1362_read_reg32(isp1362_hcd, HCINTLSKIP);\r\nisp1362_hcd->irq_stat[ISP1362_INT_INTL]++;\r\nDBG(2, "%s: INTL\n", __func__);\r\nsvc_mask &= ~HCuPINT_INTL;\r\nisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, skip_map | done_map);\r\nif (~(done_map | skip_map) == 0)\r\nisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_INTL_ACTIVE);\r\nhandled = 1;\r\nWARN_ON(!done_map);\r\nif (done_map) {\r\nDBG(3, "%s: INTL done_map %08x\n", __func__, done_map);\r\nfinish_transfers(isp1362_hcd, done_map, &isp1362_hcd->intl_queue);\r\nstart_intl_transfers(isp1362_hcd);\r\n}\r\n}\r\nif (irqstat & HCuPINT_ATL) {\r\nu32 done_map = isp1362_read_reg32(isp1362_hcd, HCATLDONE);\r\nu32 skip_map = isp1362_read_reg32(isp1362_hcd, HCATLSKIP);\r\nisp1362_hcd->irq_stat[ISP1362_INT_ATL]++;\r\nDBG(2, "%s: ATL\n", __func__);\r\nsvc_mask &= ~HCuPINT_ATL;\r\nisp1362_write_reg32(isp1362_hcd, HCATLSKIP, skip_map | done_map);\r\nif (~(done_map | skip_map) == 0)\r\nisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ATL_ACTIVE);\r\nif (done_map) {\r\nDBG(3, "%s: ATL done_map %08x\n", __func__, done_map);\r\nfinish_transfers(isp1362_hcd, done_map, &isp1362_hcd->atl_queue);\r\nstart_atl_transfers(isp1362_hcd);\r\n}\r\nhandled = 1;\r\n}\r\nif (irqstat & HCuPINT_OPR) {\r\nu32 intstat = isp1362_read_reg32(isp1362_hcd, HCINTSTAT);\r\nisp1362_hcd->irq_stat[ISP1362_INT_OPR]++;\r\nsvc_mask &= ~HCuPINT_OPR;\r\nDBG(2, "%s: OPR %08x:%08x\n", __func__, intstat, isp1362_hcd->intenb);\r\nintstat &= isp1362_hcd->intenb;\r\nif (intstat & OHCI_INTR_UE) {\r\npr_err("Unrecoverable error\n");\r\n}\r\nif (intstat & OHCI_INTR_RHSC) {\r\nisp1362_hcd->rhstatus = isp1362_read_reg32(isp1362_hcd, HCRHSTATUS);\r\nisp1362_hcd->rhport[0] = isp1362_read_reg32(isp1362_hcd, HCRHPORT1);\r\nisp1362_hcd->rhport[1] = isp1362_read_reg32(isp1362_hcd, HCRHPORT2);\r\n}\r\nif (intstat & OHCI_INTR_RD) {\r\npr_info("%s: RESUME DETECTED\n", __func__);\r\nisp1362_show_reg(isp1362_hcd, HCCONTROL);\r\nusb_hcd_resume_root_hub(hcd);\r\n}\r\nisp1362_write_reg32(isp1362_hcd, HCINTSTAT, intstat);\r\nirqstat &= ~HCuPINT_OPR;\r\nhandled = 1;\r\n}\r\nif (irqstat & HCuPINT_SUSP) {\r\nisp1362_hcd->irq_stat[ISP1362_INT_SUSP]++;\r\nhandled = 1;\r\nsvc_mask &= ~HCuPINT_SUSP;\r\npr_info("%s: SUSPEND IRQ\n", __func__);\r\n}\r\nif (irqstat & HCuPINT_CLKRDY) {\r\nisp1362_hcd->irq_stat[ISP1362_INT_CLKRDY]++;\r\nhandled = 1;\r\nisp1362_hcd->irqenb &= ~HCuPINT_CLKRDY;\r\nsvc_mask &= ~HCuPINT_CLKRDY;\r\npr_info("%s: CLKRDY IRQ\n", __func__);\r\n}\r\nif (svc_mask)\r\npr_err("%s: Unserviced interrupt(s) %04x\n", __func__, svc_mask);\r\nisp1362_write_reg16(isp1362_hcd, HCuPINTENB, isp1362_hcd->irqenb);\r\nisp1362_hcd->irq_active--;\r\nspin_unlock(&isp1362_hcd->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int balance(struct isp1362_hcd *isp1362_hcd, u16 interval, u16 load)\r\n{\r\nint i, branch = -ENOSPC;\r\nfor (i = 0; i < interval; i++) {\r\nif (branch < 0 || isp1362_hcd->load[branch] > isp1362_hcd->load[i]) {\r\nint j;\r\nfor (j = i; j < PERIODIC_SIZE; j += interval) {\r\nif ((isp1362_hcd->load[j] + load) > MAX_PERIODIC_LOAD) {\r\npr_err("%s: new load %d load[%02x] %d max %d\n", __func__,\r\nload, j, isp1362_hcd->load[j], MAX_PERIODIC_LOAD);\r\nbreak;\r\n}\r\n}\r\nif (j < PERIODIC_SIZE)\r\ncontinue;\r\nbranch = i;\r\n}\r\n}\r\nreturn branch;\r\n}\r\nstatic int isp1362_urb_enqueue(struct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nstruct usb_device *udev = urb->dev;\r\nunsigned int pipe = urb->pipe;\r\nint is_out = !usb_pipein(pipe);\r\nint type = usb_pipetype(pipe);\r\nint epnum = usb_pipeendpoint(pipe);\r\nstruct usb_host_endpoint *hep = urb->ep;\r\nstruct isp1362_ep *ep = NULL;\r\nunsigned long flags;\r\nint retval = 0;\r\nDBG(3, "%s: urb %p\n", __func__, urb);\r\nif (type == PIPE_ISOCHRONOUS) {\r\npr_err("Isochronous transfers not supported\n");\r\nreturn -ENOSPC;\r\n}\r\nURB_DBG("%s: FA %d ep%d%s %s: len %d %s%s\n", __func__,\r\nusb_pipedevice(pipe), epnum,\r\nis_out ? "out" : "in",\r\nusb_pipecontrol(pipe) ? "ctrl" :\r\nusb_pipeint(pipe) ? "int" :\r\nusb_pipebulk(pipe) ? "bulk" :\r\n"iso",\r\nurb->transfer_buffer_length,\r\n(urb->transfer_flags & URB_ZERO_PACKET) ? "ZERO_PACKET " : "",\r\n!(urb->transfer_flags & URB_SHORT_NOT_OK) ?\r\n"short_ok" : "");\r\nif (!hep->hcpriv) {\r\nep = kzalloc(sizeof *ep, mem_flags);\r\nif (!ep)\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nif (!((isp1362_hcd->rhport[0] | isp1362_hcd->rhport[1]) &\r\nUSB_PORT_STAT_ENABLE) ||\r\n!HC_IS_RUNNING(hcd->state)) {\r\nkfree(ep);\r\nretval = -ENODEV;\r\ngoto fail_not_linked;\r\n}\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval) {\r\nkfree(ep);\r\ngoto fail_not_linked;\r\n}\r\nif (hep->hcpriv) {\r\nep = hep->hcpriv;\r\n} else {\r\nINIT_LIST_HEAD(&ep->schedule);\r\nINIT_LIST_HEAD(&ep->active);\r\nINIT_LIST_HEAD(&ep->remove_list);\r\nep->udev = usb_get_dev(udev);\r\nep->hep = hep;\r\nep->epnum = epnum;\r\nep->maxpacket = usb_maxpacket(udev, urb->pipe, is_out);\r\nep->ptd_offset = -EINVAL;\r\nep->ptd_index = -EINVAL;\r\nusb_settoggle(udev, epnum, is_out, 0);\r\nif (type == PIPE_CONTROL)\r\nep->nextpid = USB_PID_SETUP;\r\nelse if (is_out)\r\nep->nextpid = USB_PID_OUT;\r\nelse\r\nep->nextpid = USB_PID_IN;\r\nswitch (type) {\r\ncase PIPE_ISOCHRONOUS:\r\ncase PIPE_INTERRUPT:\r\nif (urb->interval > PERIODIC_SIZE)\r\nurb->interval = PERIODIC_SIZE;\r\nep->interval = urb->interval;\r\nep->branch = PERIODIC_SIZE;\r\nep->load = usb_calc_bus_time(udev->speed, !is_out,\r\n(type == PIPE_ISOCHRONOUS),\r\nusb_maxpacket(udev, pipe, is_out)) / 1000;\r\nbreak;\r\n}\r\nhep->hcpriv = ep;\r\n}\r\nep->num_req = isp1362_hcd->req_serial++;\r\nswitch (type) {\r\ncase PIPE_CONTROL:\r\ncase PIPE_BULK:\r\nif (list_empty(&ep->schedule)) {\r\nDBG(1, "%s: Adding ep %p req %d to async schedule\n",\r\n__func__, ep, ep->num_req);\r\nlist_add_tail(&ep->schedule, &isp1362_hcd->async);\r\n}\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\ncase PIPE_INTERRUPT:\r\nurb->interval = ep->interval;\r\nif (ep->branch < PERIODIC_SIZE)\r\nbreak;\r\nretval = balance(isp1362_hcd, ep->interval, ep->load);\r\nif (retval < 0) {\r\npr_err("%s: balance returned %d\n", __func__, retval);\r\ngoto fail;\r\n}\r\nep->branch = retval;\r\nretval = 0;\r\nisp1362_hcd->fmindex = isp1362_read_reg32(isp1362_hcd, HCFMNUM);\r\nDBG(1, "%s: Current frame %04x branch %02x start_frame %04x(%04x)\n",\r\n__func__, isp1362_hcd->fmindex, ep->branch,\r\n((isp1362_hcd->fmindex + PERIODIC_SIZE - 1) &\r\n~(PERIODIC_SIZE - 1)) + ep->branch,\r\n(isp1362_hcd->fmindex & (PERIODIC_SIZE - 1)) + ep->branch);\r\nif (list_empty(&ep->schedule)) {\r\nif (type == PIPE_ISOCHRONOUS) {\r\nu16 frame = isp1362_hcd->fmindex;\r\nframe += max_t(u16, 8, ep->interval);\r\nframe &= ~(ep->interval - 1);\r\nframe |= ep->branch;\r\nif (frame_before(frame, isp1362_hcd->fmindex))\r\nframe += ep->interval;\r\nurb->start_frame = frame;\r\nDBG(1, "%s: Adding ep %p to isoc schedule\n", __func__, ep);\r\nlist_add_tail(&ep->schedule, &isp1362_hcd->isoc);\r\n} else {\r\nDBG(1, "%s: Adding ep %p to periodic schedule\n", __func__, ep);\r\nlist_add_tail(&ep->schedule, &isp1362_hcd->periodic);\r\n}\r\n} else\r\nDBG(1, "%s: ep %p already scheduled\n", __func__, ep);\r\nDBG(2, "%s: load %d bandwidth %d -> %d\n", __func__,\r\nep->load / ep->interval, isp1362_hcd->load[ep->branch],\r\nisp1362_hcd->load[ep->branch] + ep->load);\r\nisp1362_hcd->load[ep->branch] += ep->load;\r\n}\r\nurb->hcpriv = hep;\r\nALIGNSTAT(isp1362_hcd, urb->transfer_buffer);\r\nswitch (type) {\r\ncase PIPE_CONTROL:\r\ncase PIPE_BULK:\r\nstart_atl_transfers(isp1362_hcd);\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nstart_intl_transfers(isp1362_hcd);\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\nstart_iso_transfers(isp1362_hcd);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nfail:\r\nif (retval)\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nfail_not_linked:\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (retval)\r\nDBG(0, "%s: urb %p failed with %d\n", __func__, urb, retval);\r\nreturn retval;\r\n}\r\nstatic int isp1362_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nstruct usb_host_endpoint *hep;\r\nunsigned long flags;\r\nstruct isp1362_ep *ep;\r\nint retval = 0;\r\nDBG(3, "%s: urb %p\n", __func__, urb);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nretval = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (retval)\r\ngoto done;\r\nhep = urb->hcpriv;\r\nif (!hep) {\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nreturn -EIDRM;\r\n}\r\nep = hep->hcpriv;\r\nif (ep) {\r\nif (ep->hep->urb_list.next == &urb->urb_list) {\r\nif (!list_empty(&ep->active)) {\r\nDBG(1, "%s: urb %p ep %p req %d active PTD[%d] $%04x\n", __func__,\r\nurb, ep, ep->num_req, ep->ptd_index, ep->ptd_offset);\r\nremove_ptd(isp1362_hcd, ep);\r\nurb = NULL;\r\n}\r\n}\r\nif (urb) {\r\nDBG(1, "%s: Finishing ep %p req %d\n", __func__, ep,\r\nep->num_req);\r\nfinish_request(isp1362_hcd, ep, urb, status);\r\n} else\r\nDBG(1, "%s: urb %p active; wait4irq\n", __func__, urb);\r\n} else {\r\npr_warning("%s: No EP in URB %p\n", __func__, urb);\r\nretval = -EINVAL;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nDBG(3, "%s: exit\n", __func__);\r\nreturn retval;\r\n}\r\nstatic void isp1362_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)\r\n{\r\nstruct isp1362_ep *ep = hep->hcpriv;\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nunsigned long flags;\r\nDBG(1, "%s: ep %p\n", __func__, ep);\r\nif (!ep)\r\nreturn;\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nif (!list_empty(&hep->urb_list)) {\r\nif (!list_empty(&ep->active) && list_empty(&ep->remove_list)) {\r\nDBG(1, "%s: Removing ep %p req %d PTD[%d] $%04x\n", __func__,\r\nep, ep->num_req, ep->ptd_index, ep->ptd_offset);\r\nremove_ptd(isp1362_hcd, ep);\r\npr_info("%s: Waiting for Interrupt to clean up\n", __func__);\r\n}\r\n}\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nwhile (!list_empty(&ep->active))\r\nmsleep(1);\r\nDBG(1, "%s: Freeing EP %p\n", __func__, ep);\r\nusb_put_dev(ep->udev);\r\nkfree(ep);\r\nhep->hcpriv = NULL;\r\n}\r\nstatic int isp1362_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nu32 fmnum;\r\nunsigned long flags;\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nfmnum = isp1362_read_reg32(isp1362_hcd, HCFMNUM);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nreturn (int)fmnum;\r\n}\r\nstatic int isp1362_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nint ports, i, changed = 0;\r\nunsigned long flags;\r\nif (!HC_IS_RUNNING(hcd->state))\r\nreturn -ESHUTDOWN;\r\nif (timer_pending(&hcd->rh_timer))\r\nreturn 0;\r\nports = isp1362_hcd->rhdesca & RH_A_NDP;\r\nBUG_ON(ports > 2);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nif (isp1362_hcd->rhstatus & (RH_HS_LPSC | RH_HS_OCIC))\r\nbuf[0] = changed = 1;\r\nelse\r\nbuf[0] = 0;\r\nfor (i = 0; i < ports; i++) {\r\nu32 status = isp1362_hcd->rhport[i];\r\nif (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC |\r\nRH_PS_OCIC | RH_PS_PRSC)) {\r\nchanged = 1;\r\nbuf[0] |= 1 << (i + 1);\r\ncontinue;\r\n}\r\nif (!(status & RH_PS_CCS))\r\ncontinue;\r\n}\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nreturn changed;\r\n}\r\nstatic void isp1362_hub_descriptor(struct isp1362_hcd *isp1362_hcd,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nu32 reg = isp1362_hcd->rhdesca;\r\nDBG(3, "%s: enter\n", __func__);\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bDescLength = 9;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = reg & 0x3;\r\ndesc->wHubCharacteristics = cpu_to_le16((reg >> 8) & 0x1f);\r\nDBG(0, "%s: hubcharacteristics = %02x\n", __func__, cpu_to_le16((reg >> 8) & 0x1f));\r\ndesc->bPwrOn2PwrGood = (reg >> 24) & 0xff;\r\ndesc->u.hs.DeviceRemovable[0] = desc->bNbrPorts == 1 ? 1 << 1 : 3 << 1;\r\ndesc->u.hs.DeviceRemovable[1] = ~0;\r\nDBG(3, "%s: exit\n", __func__);\r\n}\r\nstatic int isp1362_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nint retval = 0;\r\nunsigned long flags;\r\nunsigned long t1;\r\nint ports = isp1362_hcd->rhdesca & RH_A_NDP;\r\nu32 tmp = 0;\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nDBG(0, "ClearHubFeature: ");\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\n_DBG(0, "C_HUB_OVER_CURRENT\n");\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_OCIC);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\ncase C_HUB_LOCAL_POWER:\r\n_DBG(0, "C_HUB_LOCAL_POWER\n");\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetHubFeature:\r\nDBG(0, "SetHubFeature: ");\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\n_DBG(0, "C_HUB_OVER_CURRENT or C_HUB_LOCAL_POWER\n");\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase GetHubDescriptor:\r\nDBG(0, "GetHubDescriptor\n");\r\nisp1362_hub_descriptor(isp1362_hcd, (struct usb_hub_descriptor *)buf);\r\nbreak;\r\ncase GetHubStatus:\r\nDBG(0, "GetHubStatus\n");\r\nput_unaligned(cpu_to_le32(0), (__le32 *) buf);\r\nbreak;\r\ncase GetPortStatus:\r\n#ifndef VERBOSE\r\nDBG(0, "GetPortStatus\n");\r\n#endif\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\ntmp = isp1362_hcd->rhport[--wIndex];\r\nput_unaligned(cpu_to_le32(tmp), (__le32 *) buf);\r\nbreak;\r\ncase ClearPortFeature:\r\nDBG(0, "ClearPortFeature: ");\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\n_DBG(0, "USB_PORT_FEAT_ENABLE\n");\r\ntmp = RH_PS_CCS;\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\n_DBG(0, "USB_PORT_FEAT_C_ENABLE\n");\r\ntmp = RH_PS_PESC;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\n_DBG(0, "USB_PORT_FEAT_SUSPEND\n");\r\ntmp = RH_PS_POCI;\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\n_DBG(0, "USB_PORT_FEAT_C_SUSPEND\n");\r\ntmp = RH_PS_PSSC;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\n_DBG(0, "USB_PORT_FEAT_POWER\n");\r\ntmp = RH_PS_LSDA;\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\n_DBG(0, "USB_PORT_FEAT_C_CONNECTION\n");\r\ntmp = RH_PS_CSC;\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\n_DBG(0, "USB_PORT_FEAT_C_OVER_CURRENT\n");\r\ntmp = RH_PS_OCIC;\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\n_DBG(0, "USB_PORT_FEAT_C_RESET\n");\r\ntmp = RH_PS_PRSC;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + wIndex, tmp);\r\nisp1362_hcd->rhport[wIndex] =\r\nisp1362_read_reg32(isp1362_hcd, HCRHPORT1 + wIndex);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nbreak;\r\ncase SetPortFeature:\r\nDBG(0, "SetPortFeature: ");\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\n_DBG(0, "USB_PORT_FEAT_SUSPEND\n");\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + wIndex, RH_PS_PSS);\r\nisp1362_hcd->rhport[wIndex] =\r\nisp1362_read_reg32(isp1362_hcd, HCRHPORT1 + wIndex);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\n_DBG(0, "USB_PORT_FEAT_POWER\n");\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + wIndex, RH_PS_PPS);\r\nisp1362_hcd->rhport[wIndex] =\r\nisp1362_read_reg32(isp1362_hcd, HCRHPORT1 + wIndex);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\n_DBG(0, "USB_PORT_FEAT_RESET\n");\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nt1 = jiffies + msecs_to_jiffies(USB_RESET_WIDTH);\r\nwhile (time_before(jiffies, t1)) {\r\nfor (;;) {\r\ntmp = isp1362_read_reg32(isp1362_hcd, HCRHPORT1 + wIndex);\r\nif (!(tmp & RH_PS_PRS))\r\nbreak;\r\nudelay(500);\r\n}\r\nif (!(tmp & RH_PS_CCS))\r\nbreak;\r\nisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + wIndex, (RH_PS_PRS));\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\n}\r\nisp1362_hcd->rhport[wIndex] = isp1362_read_reg32(isp1362_hcd,\r\nHCRHPORT1 + wIndex);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\nerror:\r\n_DBG(0, "PROTOCOL STALL\n");\r\nretval = -EPIPE;\r\n}\r\nreturn retval;\r\n}\r\nstatic int isp1362_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nint status = 0;\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nunsigned long flags;\r\nif (time_before(jiffies, isp1362_hcd->next_statechange))\r\nmsleep(5);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_hcd->hc_control = isp1362_read_reg32(isp1362_hcd, HCCONTROL);\r\nswitch (isp1362_hcd->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_RESUME:\r\nDBG(0, "%s: resume/suspend?\n", __func__);\r\nisp1362_hcd->hc_control &= ~OHCI_CTRL_HCFS;\r\nisp1362_hcd->hc_control |= OHCI_USB_RESET;\r\nisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\r\ncase OHCI_USB_RESET:\r\nstatus = -EBUSY;\r\npr_warning("%s: needs reinit!\n", __func__);\r\ngoto done;\r\ncase OHCI_USB_SUSPEND:\r\npr_warning("%s: already suspended?\n", __func__);\r\ngoto done;\r\n}\r\nDBG(0, "%s: suspend root hub\n", __func__);\r\nhcd->state = HC_STATE_QUIESCING;\r\nif (!list_empty(&isp1362_hcd->atl_queue.active) ||\r\n!list_empty(&isp1362_hcd->intl_queue.active) ||\r\n!list_empty(&isp1362_hcd->istl_queue[0] .active) ||\r\n!list_empty(&isp1362_hcd->istl_queue[1] .active)) {\r\nint limit;\r\nisp1362_write_reg32(isp1362_hcd, HCATLSKIP, ~0);\r\nisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, ~0);\r\nisp1362_write_reg16(isp1362_hcd, HCBUFSTAT, 0);\r\nisp1362_write_reg16(isp1362_hcd, HCuPINTENB, 0);\r\nisp1362_write_reg32(isp1362_hcd, HCINTSTAT, OHCI_INTR_SF);\r\nDBG(0, "%s: stopping schedules ...\n", __func__);\r\nlimit = 2000;\r\nwhile (limit > 0) {\r\nudelay(250);\r\nlimit -= 250;\r\nif (isp1362_read_reg32(isp1362_hcd, HCINTSTAT) & OHCI_INTR_SF)\r\nbreak;\r\n}\r\nmdelay(7);\r\nif (isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_ATL) {\r\nu32 done_map = isp1362_read_reg32(isp1362_hcd, HCATLDONE);\r\nfinish_transfers(isp1362_hcd, done_map, &isp1362_hcd->atl_queue);\r\n}\r\nif (isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_INTL) {\r\nu32 done_map = isp1362_read_reg32(isp1362_hcd, HCINTLDONE);\r\nfinish_transfers(isp1362_hcd, done_map, &isp1362_hcd->intl_queue);\r\n}\r\nif (isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_ISTL0)\r\nfinish_iso_transfers(isp1362_hcd, &isp1362_hcd->istl_queue[0]);\r\nif (isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_ISTL1)\r\nfinish_iso_transfers(isp1362_hcd, &isp1362_hcd->istl_queue[1]);\r\n}\r\nDBG(0, "%s: HCINTSTAT: %08x\n", __func__,\r\nisp1362_read_reg32(isp1362_hcd, HCINTSTAT));\r\nisp1362_write_reg32(isp1362_hcd, HCINTSTAT,\r\nisp1362_read_reg32(isp1362_hcd, HCINTSTAT));\r\nisp1362_hcd->hc_control = OHCI_USB_SUSPEND;\r\nisp1362_show_reg(isp1362_hcd, HCCONTROL);\r\nisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\r\nisp1362_show_reg(isp1362_hcd, HCCONTROL);\r\n#if 1\r\nisp1362_hcd->hc_control = isp1362_read_reg32(isp1362_hcd, HCCONTROL);\r\nif ((isp1362_hcd->hc_control & OHCI_CTRL_HCFS) != OHCI_USB_SUSPEND) {\r\npr_err("%s: controller won't suspend %08x\n", __func__,\r\nisp1362_hcd->hc_control);\r\nstatus = -EBUSY;\r\n} else\r\n#endif\r\n{\r\nisp1362_hcd->next_statechange = jiffies + msecs_to_jiffies(5);\r\n}\r\ndone:\r\nif (status == 0) {\r\nhcd->state = HC_STATE_SUSPENDED;\r\nDBG(0, "%s: HCD suspended: %08x\n", __func__,\r\nisp1362_read_reg32(isp1362_hcd, HCCONTROL));\r\n}\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nreturn status;\r\n}\r\nstatic int isp1362_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nu32 port;\r\nunsigned long flags;\r\nint status = -EINPROGRESS;\r\nif (time_before(jiffies, isp1362_hcd->next_statechange))\r\nmsleep(5);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_hcd->hc_control = isp1362_read_reg32(isp1362_hcd, HCCONTROL);\r\npr_info("%s: HCCONTROL: %08x\n", __func__, isp1362_hcd->hc_control);\r\nif (hcd->state == HC_STATE_RESUMING) {\r\npr_warning("%s: duplicate resume\n", __func__);\r\nstatus = 0;\r\n} else\r\nswitch (isp1362_hcd->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_SUSPEND:\r\nDBG(0, "%s: resume root hub\n", __func__);\r\nisp1362_hcd->hc_control &= ~OHCI_CTRL_HCFS;\r\nisp1362_hcd->hc_control |= OHCI_USB_RESUME;\r\nisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\r\nbreak;\r\ncase OHCI_USB_RESUME:\r\nDBG(0, "%s: remote wakeup\n", __func__);\r\nbreak;\r\ncase OHCI_USB_OPER:\r\nDBG(0, "%s: odd resume\n", __func__);\r\nstatus = 0;\r\nhcd->self.root_hub->dev.power.power_state = PMSG_ON;\r\nbreak;\r\ndefault:\r\nDBG(0, "%s: root hub hardware reset\n", __func__);\r\nstatus = -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (status == -EBUSY) {\r\nDBG(0, "%s: Restarting HC\n", __func__);\r\nisp1362_hc_stop(hcd);\r\nreturn isp1362_hc_start(hcd);\r\n}\r\nif (status != -EINPROGRESS)\r\nreturn status;\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nport = isp1362_read_reg32(isp1362_hcd, HCRHDESCA) & RH_A_NDP;\r\nwhile (port--) {\r\nu32 stat = isp1362_read_reg32(isp1362_hcd, HCRHPORT1 + port);\r\nif (!(stat & RH_PS_PSS)) {\r\nDBG(0, "%s: Not Resuming RH port %d\n", __func__, port);\r\ncontinue;\r\n}\r\nDBG(0, "%s: Resuming RH port %d\n", __func__, port);\r\nisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + port, RH_PS_POCI);\r\n}\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nhcd->state = HC_STATE_RESUMING;\r\nmdelay(20 + 15);\r\nisp1362_hcd->hc_control = OHCI_USB_OPER;\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_show_reg(isp1362_hcd, HCCONTROL);\r\nisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nmsleep(10);\r\nisp1362_hcd->next_statechange = jiffies + msecs_to_jiffies(250);\r\nhcd->self.root_hub->dev.power.power_state = PMSG_ON;\r\nhcd->state = HC_STATE_RUNNING;\r\nreturn 0;\r\n}\r\nstatic inline void create_debug_file(struct isp1362_hcd *isp1362_hcd)\r\n{\r\n}\r\nstatic inline void remove_debug_file(struct isp1362_hcd *isp1362_hcd)\r\n{\r\n}\r\nstatic void dump_irq(struct seq_file *s, char *label, u16 mask)\r\n{\r\nseq_printf(s, "%-15s %04x%s%s%s%s%s%s\n", label, mask,\r\nmask & HCuPINT_CLKRDY ? " clkrdy" : "",\r\nmask & HCuPINT_SUSP ? " susp" : "",\r\nmask & HCuPINT_OPR ? " opr" : "",\r\nmask & HCuPINT_EOT ? " eot" : "",\r\nmask & HCuPINT_ATL ? " atl" : "",\r\nmask & HCuPINT_SOF ? " sof" : "");\r\n}\r\nstatic void dump_int(struct seq_file *s, char *label, u32 mask)\r\n{\r\nseq_printf(s, "%-15s %08x%s%s%s%s%s%s%s\n", label, mask,\r\nmask & OHCI_INTR_MIE ? " MIE" : "",\r\nmask & OHCI_INTR_RHSC ? " rhsc" : "",\r\nmask & OHCI_INTR_FNO ? " fno" : "",\r\nmask & OHCI_INTR_UE ? " ue" : "",\r\nmask & OHCI_INTR_RD ? " rd" : "",\r\nmask & OHCI_INTR_SF ? " sof" : "",\r\nmask & OHCI_INTR_SO ? " so" : "");\r\n}\r\nstatic void dump_ctrl(struct seq_file *s, char *label, u32 mask)\r\n{\r\nseq_printf(s, "%-15s %08x%s%s%s\n", label, mask,\r\nmask & OHCI_CTRL_RWC ? " rwc" : "",\r\nmask & OHCI_CTRL_RWE ? " rwe" : "",\r\n({\r\nchar *hcfs;\r\nswitch (mask & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_OPER:\r\nhcfs = " oper";\r\nbreak;\r\ncase OHCI_USB_RESET:\r\nhcfs = " reset";\r\nbreak;\r\ncase OHCI_USB_RESUME:\r\nhcfs = " resume";\r\nbreak;\r\ncase OHCI_USB_SUSPEND:\r\nhcfs = " suspend";\r\nbreak;\r\ndefault:\r\nhcfs = " ?";\r\n}\r\nhcfs;\r\n}));\r\n}\r\nstatic void dump_regs(struct seq_file *s, struct isp1362_hcd *isp1362_hcd)\r\n{\r\nseq_printf(s, "HCREVISION [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCREVISION),\r\nisp1362_read_reg32(isp1362_hcd, HCREVISION));\r\nseq_printf(s, "HCCONTROL [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCCONTROL),\r\nisp1362_read_reg32(isp1362_hcd, HCCONTROL));\r\nseq_printf(s, "HCCMDSTAT [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCCMDSTAT),\r\nisp1362_read_reg32(isp1362_hcd, HCCMDSTAT));\r\nseq_printf(s, "HCINTSTAT [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCINTSTAT),\r\nisp1362_read_reg32(isp1362_hcd, HCINTSTAT));\r\nseq_printf(s, "HCINTENB [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCINTENB),\r\nisp1362_read_reg32(isp1362_hcd, HCINTENB));\r\nseq_printf(s, "HCFMINTVL [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCFMINTVL),\r\nisp1362_read_reg32(isp1362_hcd, HCFMINTVL));\r\nseq_printf(s, "HCFMREM [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCFMREM),\r\nisp1362_read_reg32(isp1362_hcd, HCFMREM));\r\nseq_printf(s, "HCFMNUM [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCFMNUM),\r\nisp1362_read_reg32(isp1362_hcd, HCFMNUM));\r\nseq_printf(s, "HCLSTHRESH [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCLSTHRESH),\r\nisp1362_read_reg32(isp1362_hcd, HCLSTHRESH));\r\nseq_printf(s, "HCRHDESCA [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCRHDESCA),\r\nisp1362_read_reg32(isp1362_hcd, HCRHDESCA));\r\nseq_printf(s, "HCRHDESCB [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCRHDESCB),\r\nisp1362_read_reg32(isp1362_hcd, HCRHDESCB));\r\nseq_printf(s, "HCRHSTATUS [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCRHSTATUS),\r\nisp1362_read_reg32(isp1362_hcd, HCRHSTATUS));\r\nseq_printf(s, "HCRHPORT1 [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCRHPORT1),\r\nisp1362_read_reg32(isp1362_hcd, HCRHPORT1));\r\nseq_printf(s, "HCRHPORT2 [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCRHPORT2),\r\nisp1362_read_reg32(isp1362_hcd, HCRHPORT2));\r\nseq_printf(s, "\n");\r\nseq_printf(s, "HCHWCFG [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCHWCFG),\r\nisp1362_read_reg16(isp1362_hcd, HCHWCFG));\r\nseq_printf(s, "HCDMACFG [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCDMACFG),\r\nisp1362_read_reg16(isp1362_hcd, HCDMACFG));\r\nseq_printf(s, "HCXFERCTR [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCXFERCTR),\r\nisp1362_read_reg16(isp1362_hcd, HCXFERCTR));\r\nseq_printf(s, "HCuPINT [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCuPINT),\r\nisp1362_read_reg16(isp1362_hcd, HCuPINT));\r\nseq_printf(s, "HCuPINTENB [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCuPINTENB),\r\nisp1362_read_reg16(isp1362_hcd, HCuPINTENB));\r\nseq_printf(s, "HCCHIPID [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCCHIPID),\r\nisp1362_read_reg16(isp1362_hcd, HCCHIPID));\r\nseq_printf(s, "HCSCRATCH [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCSCRATCH),\r\nisp1362_read_reg16(isp1362_hcd, HCSCRATCH));\r\nseq_printf(s, "HCBUFSTAT [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCBUFSTAT),\r\nisp1362_read_reg16(isp1362_hcd, HCBUFSTAT));\r\nseq_printf(s, "HCDIRADDR [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCDIRADDR),\r\nisp1362_read_reg32(isp1362_hcd, HCDIRADDR));\r\n#if 0\r\nseq_printf(s, "HCDIRDATA [%02x] %04x\n", ISP1362_REG_NO(HCDIRDATA),\r\nisp1362_read_reg16(isp1362_hcd, HCDIRDATA));\r\n#endif\r\nseq_printf(s, "HCISTLBUFSZ[%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCISTLBUFSZ),\r\nisp1362_read_reg16(isp1362_hcd, HCISTLBUFSZ));\r\nseq_printf(s, "HCISTLRATE [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCISTLRATE),\r\nisp1362_read_reg16(isp1362_hcd, HCISTLRATE));\r\nseq_printf(s, "\n");\r\nseq_printf(s, "HCINTLBUFSZ[%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCINTLBUFSZ),\r\nisp1362_read_reg16(isp1362_hcd, HCINTLBUFSZ));\r\nseq_printf(s, "HCINTLBLKSZ[%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCINTLBLKSZ),\r\nisp1362_read_reg16(isp1362_hcd, HCINTLBLKSZ));\r\nseq_printf(s, "HCINTLDONE [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCINTLDONE),\r\nisp1362_read_reg32(isp1362_hcd, HCINTLDONE));\r\nseq_printf(s, "HCINTLSKIP [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCINTLSKIP),\r\nisp1362_read_reg32(isp1362_hcd, HCINTLSKIP));\r\nseq_printf(s, "HCINTLLAST [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCINTLLAST),\r\nisp1362_read_reg32(isp1362_hcd, HCINTLLAST));\r\nseq_printf(s, "HCINTLCURR [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCINTLCURR),\r\nisp1362_read_reg16(isp1362_hcd, HCINTLCURR));\r\nseq_printf(s, "\n");\r\nseq_printf(s, "HCATLBUFSZ [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCATLBUFSZ),\r\nisp1362_read_reg16(isp1362_hcd, HCATLBUFSZ));\r\nseq_printf(s, "HCATLBLKSZ [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCATLBLKSZ),\r\nisp1362_read_reg16(isp1362_hcd, HCATLBLKSZ));\r\n#if 0\r\nseq_printf(s, "HCATLDONE [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCATLDONE),\r\nisp1362_read_reg32(isp1362_hcd, HCATLDONE));\r\n#endif\r\nseq_printf(s, "HCATLSKIP [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCATLSKIP),\r\nisp1362_read_reg32(isp1362_hcd, HCATLSKIP));\r\nseq_printf(s, "HCATLLAST [%02x] %08x\n", ISP1362_REG_NO(ISP1362_REG_HCATLLAST),\r\nisp1362_read_reg32(isp1362_hcd, HCATLLAST));\r\nseq_printf(s, "HCATLCURR [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCATLCURR),\r\nisp1362_read_reg16(isp1362_hcd, HCATLCURR));\r\nseq_printf(s, "\n");\r\nseq_printf(s, "HCATLDTC [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCATLDTC),\r\nisp1362_read_reg16(isp1362_hcd, HCATLDTC));\r\nseq_printf(s, "HCATLDTCTO [%02x] %04x\n", ISP1362_REG_NO(ISP1362_REG_HCATLDTCTO),\r\nisp1362_read_reg16(isp1362_hcd, HCATLDTCTO));\r\n}\r\nstatic int proc_isp1362_show(struct seq_file *s, void *unused)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = s->private;\r\nstruct isp1362_ep *ep;\r\nint i;\r\nseq_printf(s, "%s\n%s version %s\n",\r\nisp1362_hcd_to_hcd(isp1362_hcd)->product_desc, hcd_name, DRIVER_VERSION);\r\nseq_printf(s, "alignment: 16b/%ld 8b/%ld 4b/%ld 2b/%ld 1b/%ld\n",\r\nisp1362_hcd->stat16, isp1362_hcd->stat8, isp1362_hcd->stat4,\r\nisp1362_hcd->stat2, isp1362_hcd->stat1);\r\nseq_printf(s, "max # ptds in ATL fifo: %d\n", isp1362_hcd->atl_queue.stat_maxptds);\r\nseq_printf(s, "max # ptds in INTL fifo: %d\n", isp1362_hcd->intl_queue.stat_maxptds);\r\nseq_printf(s, "max # ptds in ISTL fifo: %d\n",\r\nmax(isp1362_hcd->istl_queue[0] .stat_maxptds,\r\nisp1362_hcd->istl_queue[1] .stat_maxptds));\r\nspin_lock_irq(&isp1362_hcd->lock);\r\ndump_irq(s, "hc_irq_enable", isp1362_read_reg16(isp1362_hcd, HCuPINTENB));\r\ndump_irq(s, "hc_irq_status", isp1362_read_reg16(isp1362_hcd, HCuPINT));\r\ndump_int(s, "ohci_int_enable", isp1362_read_reg32(isp1362_hcd, HCINTENB));\r\ndump_int(s, "ohci_int_status", isp1362_read_reg32(isp1362_hcd, HCINTSTAT));\r\ndump_ctrl(s, "ohci_control", isp1362_read_reg32(isp1362_hcd, HCCONTROL));\r\nfor (i = 0; i < NUM_ISP1362_IRQS; i++)\r\nif (isp1362_hcd->irq_stat[i])\r\nseq_printf(s, "%-15s: %d\n",\r\nISP1362_INT_NAME(i), isp1362_hcd->irq_stat[i]);\r\ndump_regs(s, isp1362_hcd);\r\nlist_for_each_entry(ep, &isp1362_hcd->async, schedule) {\r\nstruct urb *urb;\r\nseq_printf(s, "%p, ep%d%s, maxpacket %d:\n", ep, ep->epnum,\r\n({\r\nchar *s;\r\nswitch (ep->nextpid) {\r\ncase USB_PID_IN:\r\ns = "in";\r\nbreak;\r\ncase USB_PID_OUT:\r\ns = "out";\r\nbreak;\r\ncase USB_PID_SETUP:\r\ns = "setup";\r\nbreak;\r\ncase USB_PID_ACK:\r\ns = "status";\r\nbreak;\r\ndefault:\r\ns = "?";\r\nbreak;\r\n};\r\ns;}), ep->maxpacket) ;\r\nlist_for_each_entry(urb, &ep->hep->urb_list, urb_list) {\r\nseq_printf(s, " urb%p, %d/%d\n", urb,\r\nurb->actual_length,\r\nurb->transfer_buffer_length);\r\n}\r\n}\r\nif (!list_empty(&isp1362_hcd->async))\r\nseq_printf(s, "\n");\r\ndump_ptd_queue(&isp1362_hcd->atl_queue);\r\nseq_printf(s, "periodic size= %d\n", PERIODIC_SIZE);\r\nlist_for_each_entry(ep, &isp1362_hcd->periodic, schedule) {\r\nseq_printf(s, "branch:%2d load:%3d PTD[%d] $%04x:\n", ep->branch,\r\nisp1362_hcd->load[ep->branch], ep->ptd_index, ep->ptd_offset);\r\nseq_printf(s, " %d/%p (%sdev%d ep%d%s max %d)\n",\r\nep->interval, ep,\r\n(ep->udev->speed == USB_SPEED_FULL) ? "" : "ls ",\r\nep->udev->devnum, ep->epnum,\r\n(ep->epnum == 0) ? "" :\r\n((ep->nextpid == USB_PID_IN) ?\r\n"in" : "out"), ep->maxpacket);\r\n}\r\ndump_ptd_queue(&isp1362_hcd->intl_queue);\r\nseq_printf(s, "ISO:\n");\r\nlist_for_each_entry(ep, &isp1362_hcd->isoc, schedule) {\r\nseq_printf(s, " %d/%p (%sdev%d ep%d%s max %d)\n",\r\nep->interval, ep,\r\n(ep->udev->speed == USB_SPEED_FULL) ? "" : "ls ",\r\nep->udev->devnum, ep->epnum,\r\n(ep->epnum == 0) ? "" :\r\n((ep->nextpid == USB_PID_IN) ?\r\n"in" : "out"), ep->maxpacket);\r\n}\r\nspin_unlock_irq(&isp1362_hcd->lock);\r\nseq_printf(s, "\n");\r\nreturn 0;\r\n}\r\nstatic int proc_isp1362_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_isp1362_show, PDE(inode)->data);\r\n}\r\nstatic void create_debug_file(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nstruct proc_dir_entry *pde;\r\npde = create_proc_entry(proc_filename, 0, NULL);\r\nif (pde == NULL) {\r\npr_warning("%s: Failed to create debug file '%s'\n", __func__, proc_filename);\r\nreturn;\r\n}\r\npde->proc_fops = &proc_ops;\r\npde->data = isp1362_hcd;\r\nisp1362_hcd->pde = pde;\r\n}\r\nstatic void remove_debug_file(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nif (isp1362_hcd->pde)\r\nremove_proc_entry(proc_filename, NULL);\r\n}\r\nstatic void __isp1362_sw_reset(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nint tmp = 20;\r\nisp1362_write_reg16(isp1362_hcd, HCSWRES, HCSWRES_MAGIC);\r\nisp1362_write_reg32(isp1362_hcd, HCCMDSTAT, OHCI_HCR);\r\nwhile (--tmp) {\r\nmdelay(1);\r\nif (!(isp1362_read_reg32(isp1362_hcd, HCCMDSTAT) & OHCI_HCR))\r\nbreak;\r\n}\r\nif (!tmp)\r\npr_err("Software reset timeout\n");\r\n}\r\nstatic void isp1362_sw_reset(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\n__isp1362_sw_reset(isp1362_hcd);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\n}\r\nstatic int isp1362_mem_config(struct usb_hcd *hcd)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nunsigned long flags;\r\nu32 total;\r\nu16 istl_size = ISP1362_ISTL_BUFSIZE;\r\nu16 intl_blksize = ISP1362_INTL_BLKSIZE + PTD_HEADER_SIZE;\r\nu16 intl_size = ISP1362_INTL_BUFFERS * intl_blksize;\r\nu16 atl_blksize = ISP1362_ATL_BLKSIZE + PTD_HEADER_SIZE;\r\nu16 atl_buffers = (ISP1362_BUF_SIZE - (istl_size + intl_size)) / atl_blksize;\r\nu16 atl_size;\r\nint i;\r\nWARN_ON(istl_size & 3);\r\nWARN_ON(atl_blksize & 3);\r\nWARN_ON(intl_blksize & 3);\r\nWARN_ON(atl_blksize < PTD_HEADER_SIZE);\r\nWARN_ON(intl_blksize < PTD_HEADER_SIZE);\r\nBUG_ON((unsigned)ISP1362_INTL_BUFFERS > 32);\r\nif (atl_buffers > 32)\r\natl_buffers = 32;\r\natl_size = atl_buffers * atl_blksize;\r\ntotal = atl_size + intl_size + istl_size;\r\ndev_info(hcd->self.controller, "ISP1362 Memory usage:\n");\r\ndev_info(hcd->self.controller, " ISTL: 2 * %4d: %4d @ $%04x:$%04x\n",\r\nistl_size / 2, istl_size, 0, istl_size / 2);\r\ndev_info(hcd->self.controller, " INTL: %4d * (%3zu+8): %4d @ $%04x\n",\r\nISP1362_INTL_BUFFERS, intl_blksize - PTD_HEADER_SIZE,\r\nintl_size, istl_size);\r\ndev_info(hcd->self.controller, " ATL : %4d * (%3zu+8): %4d @ $%04x\n",\r\natl_buffers, atl_blksize - PTD_HEADER_SIZE,\r\natl_size, istl_size + intl_size);\r\ndev_info(hcd->self.controller, " USED/FREE: %4d %4d\n", total,\r\nISP1362_BUF_SIZE - total);\r\nif (total > ISP1362_BUF_SIZE) {\r\ndev_err(hcd->self.controller, "%s: Memory requested: %d, available %d\n",\r\n__func__, total, ISP1362_BUF_SIZE);\r\nreturn -ENOMEM;\r\n}\r\ntotal = istl_size + intl_size + atl_size;\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nfor (i = 0; i < 2; i++) {\r\nisp1362_hcd->istl_queue[i].buf_start = i * istl_size / 2,\r\nisp1362_hcd->istl_queue[i].buf_size = istl_size / 2;\r\nisp1362_hcd->istl_queue[i].blk_size = 4;\r\nINIT_LIST_HEAD(&isp1362_hcd->istl_queue[i].active);\r\nsnprintf(isp1362_hcd->istl_queue[i].name,\r\nsizeof(isp1362_hcd->istl_queue[i].name), "ISTL%d", i);\r\nDBG(3, "%s: %5s buf $%04x %d\n", __func__,\r\nisp1362_hcd->istl_queue[i].name,\r\nisp1362_hcd->istl_queue[i].buf_start,\r\nisp1362_hcd->istl_queue[i].buf_size);\r\n}\r\nisp1362_write_reg16(isp1362_hcd, HCISTLBUFSZ, istl_size / 2);\r\nisp1362_hcd->intl_queue.buf_start = istl_size;\r\nisp1362_hcd->intl_queue.buf_size = intl_size;\r\nisp1362_hcd->intl_queue.buf_count = ISP1362_INTL_BUFFERS;\r\nisp1362_hcd->intl_queue.blk_size = intl_blksize;\r\nisp1362_hcd->intl_queue.buf_avail = isp1362_hcd->intl_queue.buf_count;\r\nisp1362_hcd->intl_queue.skip_map = ~0;\r\nINIT_LIST_HEAD(&isp1362_hcd->intl_queue.active);\r\nisp1362_write_reg16(isp1362_hcd, HCINTLBUFSZ,\r\nisp1362_hcd->intl_queue.buf_size);\r\nisp1362_write_reg16(isp1362_hcd, HCINTLBLKSZ,\r\nisp1362_hcd->intl_queue.blk_size - PTD_HEADER_SIZE);\r\nisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, ~0);\r\nisp1362_write_reg32(isp1362_hcd, HCINTLLAST,\r\n1 << (ISP1362_INTL_BUFFERS - 1));\r\nisp1362_hcd->atl_queue.buf_start = istl_size + intl_size;\r\nisp1362_hcd->atl_queue.buf_size = atl_size;\r\nisp1362_hcd->atl_queue.buf_count = atl_buffers;\r\nisp1362_hcd->atl_queue.blk_size = atl_blksize;\r\nisp1362_hcd->atl_queue.buf_avail = isp1362_hcd->atl_queue.buf_count;\r\nisp1362_hcd->atl_queue.skip_map = ~0;\r\nINIT_LIST_HEAD(&isp1362_hcd->atl_queue.active);\r\nisp1362_write_reg16(isp1362_hcd, HCATLBUFSZ,\r\nisp1362_hcd->atl_queue.buf_size);\r\nisp1362_write_reg16(isp1362_hcd, HCATLBLKSZ,\r\nisp1362_hcd->atl_queue.blk_size - PTD_HEADER_SIZE);\r\nisp1362_write_reg32(isp1362_hcd, HCATLSKIP, ~0);\r\nisp1362_write_reg32(isp1362_hcd, HCATLLAST,\r\n1 << (atl_buffers - 1));\r\nsnprintf(isp1362_hcd->atl_queue.name,\r\nsizeof(isp1362_hcd->atl_queue.name), "ATL");\r\nsnprintf(isp1362_hcd->intl_queue.name,\r\nsizeof(isp1362_hcd->intl_queue.name), "INTL");\r\nDBG(3, "%s: %5s buf $%04x %2d * %4d = %4d\n", __func__,\r\nisp1362_hcd->intl_queue.name,\r\nisp1362_hcd->intl_queue.buf_start,\r\nISP1362_INTL_BUFFERS, isp1362_hcd->intl_queue.blk_size,\r\nisp1362_hcd->intl_queue.buf_size);\r\nDBG(3, "%s: %5s buf $%04x %2d * %4d = %4d\n", __func__,\r\nisp1362_hcd->atl_queue.name,\r\nisp1362_hcd->atl_queue.buf_start,\r\natl_buffers, isp1362_hcd->atl_queue.blk_size,\r\nisp1362_hcd->atl_queue.buf_size);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int isp1362_hc_reset(struct usb_hcd *hcd)\r\n{\r\nint ret = 0;\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nunsigned long t;\r\nunsigned long timeout = 100;\r\nunsigned long flags;\r\nint clkrdy = 0;\r\npr_info("%s:\n", __func__);\r\nif (isp1362_hcd->board && isp1362_hcd->board->reset) {\r\nisp1362_hcd->board->reset(hcd->self.controller, 1);\r\nmsleep(20);\r\nif (isp1362_hcd->board->clock)\r\nisp1362_hcd->board->clock(hcd->self.controller, 1);\r\nisp1362_hcd->board->reset(hcd->self.controller, 0);\r\n} else\r\nisp1362_sw_reset(isp1362_hcd);\r\nt = jiffies + msecs_to_jiffies(timeout);\r\nwhile (!clkrdy && time_before_eq(jiffies, t)) {\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nclkrdy = isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_CLKRDY;\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (!clkrdy)\r\nmsleep(4);\r\n}\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg16(isp1362_hcd, HCuPINT, HCuPINT_CLKRDY);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (!clkrdy) {\r\npr_err("Clock not ready after %lums\n", timeout);\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic void isp1362_hc_stop(struct usb_hcd *hcd)\r\n{\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nunsigned long flags;\r\nu32 tmp;\r\npr_info("%s:\n", __func__);\r\ndel_timer_sync(&hcd->rh_timer);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg16(isp1362_hcd, HCuPINTENB, 0);\r\ntmp = isp1362_read_reg32(isp1362_hcd, HCRHDESCA);\r\ntmp &= ~(RH_A_NPS | RH_A_PSM);\r\nisp1362_write_reg32(isp1362_hcd, HCRHDESCA, tmp);\r\nisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_LPS);\r\nif (isp1362_hcd->board && isp1362_hcd->board->reset)\r\nisp1362_hcd->board->reset(hcd->self.controller, 1);\r\nelse\r\n__isp1362_sw_reset(isp1362_hcd);\r\nif (isp1362_hcd->board && isp1362_hcd->board->clock)\r\nisp1362_hcd->board->clock(hcd->self.controller, 0);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\n}\r\nstatic int isp1362_chip_test(struct isp1362_hcd *isp1362_hcd)\r\n{\r\nint ret = 0;\r\nu16 *ref;\r\nunsigned long flags;\r\nref = kmalloc(2 * ISP1362_BUF_SIZE, GFP_KERNEL);\r\nif (ref) {\r\nint offset;\r\nu16 *tst = &ref[ISP1362_BUF_SIZE / 2];\r\nfor (offset = 0; offset < ISP1362_BUF_SIZE / 2; offset++) {\r\nref[offset] = ~offset;\r\ntst[offset] = offset;\r\n}\r\nfor (offset = 0; offset < 4; offset++) {\r\nint j;\r\nfor (j = 0; j < 8; j++) {\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_buffer(isp1362_hcd, (u8 *)ref + offset, 0, j);\r\nisp1362_read_buffer(isp1362_hcd, (u8 *)tst + offset, 0, j);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (memcmp(ref, tst, j)) {\r\nret = -ENODEV;\r\npr_err("%s: memory check with %d byte offset %d failed\n",\r\n__func__, j, offset);\r\ndump_data((u8 *)ref + offset, j);\r\ndump_data((u8 *)tst + offset, j);\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_buffer(isp1362_hcd, ref, 0, ISP1362_BUF_SIZE);\r\nisp1362_read_buffer(isp1362_hcd, tst, 0, ISP1362_BUF_SIZE);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (memcmp(ref, tst, ISP1362_BUF_SIZE)) {\r\nret = -ENODEV;\r\npr_err("%s: memory check failed\n", __func__);\r\ndump_data((u8 *)tst, ISP1362_BUF_SIZE / 2);\r\n}\r\nfor (offset = 0; offset < 256; offset++) {\r\nint test_size = 0;\r\nyield();\r\nmemset(tst, 0, ISP1362_BUF_SIZE);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_buffer(isp1362_hcd, tst, 0, ISP1362_BUF_SIZE);\r\nisp1362_read_buffer(isp1362_hcd, tst, 0, ISP1362_BUF_SIZE);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (memcmp(tst, tst + (ISP1362_BUF_SIZE / (2 * sizeof(*tst))),\r\nISP1362_BUF_SIZE / 2)) {\r\npr_err("%s: Failed to clear buffer\n", __func__);\r\ndump_data((u8 *)tst, ISP1362_BUF_SIZE);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_buffer(isp1362_hcd, ref, offset * 2, PTD_HEADER_SIZE);\r\nisp1362_write_buffer(isp1362_hcd, ref + PTD_HEADER_SIZE / sizeof(*ref),\r\noffset * 2 + PTD_HEADER_SIZE, test_size);\r\nisp1362_read_buffer(isp1362_hcd, tst, offset * 2,\r\nPTD_HEADER_SIZE + test_size);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (memcmp(ref, tst, PTD_HEADER_SIZE + test_size)) {\r\ndump_data(((u8 *)ref) + offset, PTD_HEADER_SIZE + test_size);\r\ndump_data((u8 *)tst, PTD_HEADER_SIZE + test_size);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_read_buffer(isp1362_hcd, tst, offset * 2,\r\nPTD_HEADER_SIZE + test_size);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif (memcmp(ref, tst, PTD_HEADER_SIZE + test_size)) {\r\nret = -ENODEV;\r\npr_err("%s: memory check with offset %02x failed\n",\r\n__func__, offset);\r\nbreak;\r\n}\r\npr_warning("%s: memory check with offset %02x ok after second read\n",\r\n__func__, offset);\r\n}\r\n}\r\nkfree(ref);\r\n}\r\nreturn ret;\r\n}\r\nstatic int isp1362_hc_start(struct usb_hcd *hcd)\r\n{\r\nint ret;\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nstruct isp1362_platform_data *board = isp1362_hcd->board;\r\nu16 hwcfg;\r\nu16 chipid;\r\nunsigned long flags;\r\npr_info("%s:\n", __func__);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nchipid = isp1362_read_reg16(isp1362_hcd, HCCHIPID);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nif ((chipid & HCCHIPID_MASK) != HCCHIPID_MAGIC) {\r\npr_err("%s: Invalid chip ID %04x\n", __func__, chipid);\r\nreturn -ENODEV;\r\n}\r\n#ifdef CHIP_BUFFER_TEST\r\nret = isp1362_chip_test(isp1362_hcd);\r\nif (ret)\r\nreturn -ENODEV;\r\n#endif\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg16(isp1362_hcd, HCuPINT, 0xff);\r\nisp1362_write_reg16(isp1362_hcd, HCuPINTENB, 0);\r\nhwcfg = HCHWCFG_INT_ENABLE | HCHWCFG_DBWIDTH(1);\r\nif (board->sel15Kres)\r\nhwcfg |= HCHWCFG_PULLDOWN_DS2 |\r\n((MAX_ROOT_PORTS > 1) ? HCHWCFG_PULLDOWN_DS1 : 0);\r\nif (board->clknotstop)\r\nhwcfg |= HCHWCFG_CLKNOTSTOP;\r\nif (board->oc_enable)\r\nhwcfg |= HCHWCFG_ANALOG_OC;\r\nif (board->int_act_high)\r\nhwcfg |= HCHWCFG_INT_POL;\r\nif (board->int_edge_triggered)\r\nhwcfg |= HCHWCFG_INT_TRIGGER;\r\nif (board->dreq_act_high)\r\nhwcfg |= HCHWCFG_DREQ_POL;\r\nif (board->dack_act_high)\r\nhwcfg |= HCHWCFG_DACK_POL;\r\nisp1362_write_reg16(isp1362_hcd, HCHWCFG, hwcfg);\r\nisp1362_show_reg(isp1362_hcd, HCHWCFG);\r\nisp1362_write_reg16(isp1362_hcd, HCDMACFG, 0);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nret = isp1362_mem_config(hcd);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_hcd->rhdesca = 0;\r\nif (board->no_power_switching)\r\nisp1362_hcd->rhdesca |= RH_A_NPS;\r\nif (board->power_switching_mode)\r\nisp1362_hcd->rhdesca |= RH_A_PSM;\r\nif (board->potpg)\r\nisp1362_hcd->rhdesca |= (board->potpg << 24) & RH_A_POTPGT;\r\nelse\r\nisp1362_hcd->rhdesca |= (25 << 24) & RH_A_POTPGT;\r\nisp1362_write_reg32(isp1362_hcd, HCRHDESCA, isp1362_hcd->rhdesca & ~RH_A_OCPM);\r\nisp1362_write_reg32(isp1362_hcd, HCRHDESCA, isp1362_hcd->rhdesca | RH_A_OCPM);\r\nisp1362_hcd->rhdesca = isp1362_read_reg32(isp1362_hcd, HCRHDESCA);\r\nisp1362_hcd->rhdescb = RH_B_PPCM;\r\nisp1362_write_reg32(isp1362_hcd, HCRHDESCB, isp1362_hcd->rhdescb);\r\nisp1362_hcd->rhdescb = isp1362_read_reg32(isp1362_hcd, HCRHDESCB);\r\nisp1362_read_reg32(isp1362_hcd, HCFMINTVL);\r\nisp1362_write_reg32(isp1362_hcd, HCFMINTVL, (FSMP(FI) << 16) | FI);\r\nisp1362_write_reg32(isp1362_hcd, HCLSTHRESH, LSTHRESH);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nisp1362_hcd->hc_control = OHCI_USB_OPER;\r\nhcd->state = HC_STATE_RUNNING;\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_hcd->intenb = OHCI_INTR_MIE | OHCI_INTR_RHSC | OHCI_INTR_UE;\r\nisp1362_hcd->intenb |= OHCI_INTR_RD;\r\nisp1362_hcd->irqenb = HCuPINT_OPR | HCuPINT_SUSP;\r\nisp1362_write_reg32(isp1362_hcd, HCINTENB, isp1362_hcd->intenb);\r\nisp1362_write_reg16(isp1362_hcd, HCuPINTENB, isp1362_hcd->irqenb);\r\nisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\r\nisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_LPSC | RH_HS_DRWE);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __devexit isp1362_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nstruct resource *res;\r\nremove_debug_file(isp1362_hcd);\r\nDBG(0, "%s: Removing HCD\n", __func__);\r\nusb_remove_hcd(hcd);\r\nDBG(0, "%s: Unmapping data_reg @ %p\n", __func__,\r\nisp1362_hcd->data_reg);\r\niounmap(isp1362_hcd->data_reg);\r\nDBG(0, "%s: Unmapping addr_reg @ %p\n", __func__,\r\nisp1362_hcd->addr_reg);\r\niounmap(isp1362_hcd->addr_reg);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nDBG(0, "%s: release mem_region: %08lx\n", __func__, (long unsigned int)res->start);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nDBG(0, "%s: release mem_region: %08lx\n", __func__, (long unsigned int)res->start);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nDBG(0, "%s: put_hcd\n", __func__);\r\nusb_put_hcd(hcd);\r\nDBG(0, "%s: Done\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int __devinit isp1362_probe(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct isp1362_hcd *isp1362_hcd;\r\nstruct resource *addr, *data;\r\nvoid __iomem *addr_reg;\r\nvoid __iomem *data_reg;\r\nint irq;\r\nint retval = 0;\r\nstruct resource *irq_res;\r\nunsigned int irq_flags = 0;\r\nif (pdev->num_resources < 3) {\r\nretval = -ENODEV;\r\ngoto err1;\r\n}\r\ndata = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!addr || !data || !irq_res) {\r\nretval = -ENODEV;\r\ngoto err1;\r\n}\r\nirq = irq_res->start;\r\nif (pdev->dev.dma_mask) {\r\nDBG(1, "won't do DMA");\r\nretval = -ENODEV;\r\ngoto err1;\r\n}\r\nif (!request_mem_region(addr->start, resource_size(addr), hcd_name)) {\r\nretval = -EBUSY;\r\ngoto err1;\r\n}\r\naddr_reg = ioremap(addr->start, resource_size(addr));\r\nif (addr_reg == NULL) {\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\nif (!request_mem_region(data->start, resource_size(data), hcd_name)) {\r\nretval = -EBUSY;\r\ngoto err3;\r\n}\r\ndata_reg = ioremap(data->start, resource_size(data));\r\nif (data_reg == NULL) {\r\nretval = -ENOMEM;\r\ngoto err4;\r\n}\r\nhcd = usb_create_hcd(&isp1362_hc_driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto err5;\r\n}\r\nhcd->rsrc_start = data->start;\r\nisp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nisp1362_hcd->data_reg = data_reg;\r\nisp1362_hcd->addr_reg = addr_reg;\r\nisp1362_hcd->next_statechange = jiffies;\r\nspin_lock_init(&isp1362_hcd->lock);\r\nINIT_LIST_HEAD(&isp1362_hcd->async);\r\nINIT_LIST_HEAD(&isp1362_hcd->periodic);\r\nINIT_LIST_HEAD(&isp1362_hcd->isoc);\r\nINIT_LIST_HEAD(&isp1362_hcd->remove_list);\r\nisp1362_hcd->board = pdev->dev.platform_data;\r\n#if USE_PLATFORM_DELAY\r\nif (!isp1362_hcd->board->delay) {\r\ndev_err(hcd->self.controller, "No platform delay function given\n");\r\nretval = -ENODEV;\r\ngoto err6;\r\n}\r\n#endif\r\nif (irq_res->flags & IORESOURCE_IRQ_HIGHEDGE)\r\nirq_flags |= IRQF_TRIGGER_RISING;\r\nif (irq_res->flags & IORESOURCE_IRQ_LOWEDGE)\r\nirq_flags |= IRQF_TRIGGER_FALLING;\r\nif (irq_res->flags & IORESOURCE_IRQ_HIGHLEVEL)\r\nirq_flags |= IRQF_TRIGGER_HIGH;\r\nif (irq_res->flags & IORESOURCE_IRQ_LOWLEVEL)\r\nirq_flags |= IRQF_TRIGGER_LOW;\r\nretval = usb_add_hcd(hcd, irq, irq_flags | IRQF_DISABLED | IRQF_SHARED);\r\nif (retval != 0)\r\ngoto err6;\r\npr_info("%s, irq %d\n", hcd->product_desc, irq);\r\ncreate_debug_file(isp1362_hcd);\r\nreturn 0;\r\nerr6:\r\nDBG(0, "%s: Freeing dev %p\n", __func__, isp1362_hcd);\r\nusb_put_hcd(hcd);\r\nerr5:\r\nDBG(0, "%s: Unmapping data_reg @ %p\n", __func__, data_reg);\r\niounmap(data_reg);\r\nerr4:\r\nDBG(0, "%s: Releasing mem region %08lx\n", __func__, (long unsigned int)data->start);\r\nrelease_mem_region(data->start, resource_size(data));\r\nerr3:\r\nDBG(0, "%s: Unmapping addr_reg @ %p\n", __func__, addr_reg);\r\niounmap(addr_reg);\r\nerr2:\r\nDBG(0, "%s: Releasing mem region %08lx\n", __func__, (long unsigned int)addr->start);\r\nrelease_mem_region(addr->start, resource_size(addr));\r\nerr1:\r\npr_err("%s: init error, %d\n", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic int isp1362_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nunsigned long flags;\r\nint retval = 0;\r\nDBG(0, "%s: Suspending device\n", __func__);\r\nif (state.event == PM_EVENT_FREEZE) {\r\nDBG(0, "%s: Suspending root hub\n", __func__);\r\nretval = isp1362_bus_suspend(hcd);\r\n} else {\r\nDBG(0, "%s: Suspending RH ports\n", __func__);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_LPS);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\n}\r\nif (retval == 0)\r\npdev->dev.power.power_state = state;\r\nreturn retval;\r\n}\r\nstatic int isp1362_resume(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\r\nunsigned long flags;\r\nDBG(0, "%s: Resuming\n", __func__);\r\nif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {\r\nDBG(0, "%s: Resume RH ports\n", __func__);\r\nspin_lock_irqsave(&isp1362_hcd->lock, flags);\r\nisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_LPSC);\r\nspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\r\nreturn 0;\r\n}\r\npdev->dev.power.power_state = PMSG_ON;\r\nreturn isp1362_bus_resume(isp1362_hcd_to_hcd(isp1362_hcd));\r\n}\r\nstatic int __init isp1362_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("driver %s, %s\n", hcd_name, DRIVER_VERSION);\r\nreturn platform_driver_register(&isp1362_driver);\r\n}\r\nstatic void __exit isp1362_cleanup(void)\r\n{\r\nplatform_driver_unregister(&isp1362_driver);\r\n}
