static void camellia_setup_tail(u32 *subkey, u32 *subL, u32 *subR, int max)\r\n{\r\nu32 dw, tl, tr;\r\nu32 kw4l, kw4r;\r\nint i;\r\nsubL[3] ^= subL[1]; subR[3] ^= subR[1];\r\nsubL[5] ^= subL[1]; subR[5] ^= subR[1];\r\nsubL[7] ^= subL[1]; subR[7] ^= subR[1];\r\nsubL[1] ^= subR[1] & ~subR[9];\r\ndw = subL[1] & subL[9],\r\nsubR[1] ^= rol32(dw, 1);\r\nsubL[11] ^= subL[1]; subR[11] ^= subR[1];\r\nsubL[13] ^= subL[1]; subR[13] ^= subR[1];\r\nsubL[15] ^= subL[1]; subR[15] ^= subR[1];\r\nsubL[1] ^= subR[1] & ~subR[17];\r\ndw = subL[1] & subL[17],\r\nsubR[1] ^= rol32(dw, 1);\r\nsubL[19] ^= subL[1]; subR[19] ^= subR[1];\r\nsubL[21] ^= subL[1]; subR[21] ^= subR[1];\r\nsubL[23] ^= subL[1]; subR[23] ^= subR[1];\r\nif (max == 24) {\r\nsubL[24] ^= subL[1]; subR[24] ^= subR[1];\r\nkw4l = subL[25]; kw4r = subR[25];\r\n} else {\r\nsubL[1] ^= subR[1] & ~subR[25];\r\ndw = subL[1] & subL[25],\r\nsubR[1] ^= rol32(dw, 1);\r\nsubL[27] ^= subL[1]; subR[27] ^= subR[1];\r\nsubL[29] ^= subL[1]; subR[29] ^= subR[1];\r\nsubL[31] ^= subL[1]; subR[31] ^= subR[1];\r\nsubL[32] ^= subL[1]; subR[32] ^= subR[1];\r\nkw4l = subL[33]; kw4r = subR[33];\r\nsubL[30] ^= kw4l; subR[30] ^= kw4r;\r\nsubL[28] ^= kw4l; subR[28] ^= kw4r;\r\nsubL[26] ^= kw4l; subR[26] ^= kw4r;\r\nkw4l ^= kw4r & ~subR[24];\r\ndw = kw4l & subL[24],\r\nkw4r ^= rol32(dw, 1);\r\n}\r\nsubL[22] ^= kw4l; subR[22] ^= kw4r;\r\nsubL[20] ^= kw4l; subR[20] ^= kw4r;\r\nsubL[18] ^= kw4l; subR[18] ^= kw4r;\r\nkw4l ^= kw4r & ~subR[16];\r\ndw = kw4l & subL[16],\r\nkw4r ^= rol32(dw, 1);\r\nsubL[14] ^= kw4l; subR[14] ^= kw4r;\r\nsubL[12] ^= kw4l; subR[12] ^= kw4r;\r\nsubL[10] ^= kw4l; subR[10] ^= kw4r;\r\nkw4l ^= kw4r & ~subR[8];\r\ndw = kw4l & subL[8],\r\nkw4r ^= rol32(dw, 1);\r\nsubL[6] ^= kw4l; subR[6] ^= kw4r;\r\nsubL[4] ^= kw4l; subR[4] ^= kw4r;\r\nsubL[2] ^= kw4l; subR[2] ^= kw4r;\r\nsubL[0] ^= kw4l; subR[0] ^= kw4r;\r\nSUBKEY_L(0) = subL[0] ^ subL[2];\r\nSUBKEY_R(0) = subR[0] ^ subR[2];\r\nSUBKEY_L(2) = subL[3];\r\nSUBKEY_R(2) = subR[3];\r\nSUBKEY_L(3) = subL[2] ^ subL[4];\r\nSUBKEY_R(3) = subR[2] ^ subR[4];\r\nSUBKEY_L(4) = subL[3] ^ subL[5];\r\nSUBKEY_R(4) = subR[3] ^ subR[5];\r\nSUBKEY_L(5) = subL[4] ^ subL[6];\r\nSUBKEY_R(5) = subR[4] ^ subR[6];\r\nSUBKEY_L(6) = subL[5] ^ subL[7];\r\nSUBKEY_R(6) = subR[5] ^ subR[7];\r\ntl = subL[10] ^ (subR[10] & ~subR[8]);\r\ndw = tl & subL[8],\r\ntr = subR[10] ^ rol32(dw, 1);\r\nSUBKEY_L(7) = subL[6] ^ tl;\r\nSUBKEY_R(7) = subR[6] ^ tr;\r\nSUBKEY_L(8) = subL[8];\r\nSUBKEY_R(8) = subR[8];\r\nSUBKEY_L(9) = subL[9];\r\nSUBKEY_R(9) = subR[9];\r\ntl = subL[7] ^ (subR[7] & ~subR[9]);\r\ndw = tl & subL[9],\r\ntr = subR[7] ^ rol32(dw, 1);\r\nSUBKEY_L(10) = tl ^ subL[11];\r\nSUBKEY_R(10) = tr ^ subR[11];\r\nSUBKEY_L(11) = subL[10] ^ subL[12];\r\nSUBKEY_R(11) = subR[10] ^ subR[12];\r\nSUBKEY_L(12) = subL[11] ^ subL[13];\r\nSUBKEY_R(12) = subR[11] ^ subR[13];\r\nSUBKEY_L(13) = subL[12] ^ subL[14];\r\nSUBKEY_R(13) = subR[12] ^ subR[14];\r\nSUBKEY_L(14) = subL[13] ^ subL[15];\r\nSUBKEY_R(14) = subR[13] ^ subR[15];\r\ntl = subL[18] ^ (subR[18] & ~subR[16]);\r\ndw = tl & subL[16],\r\ntr = subR[18] ^ rol32(dw, 1);\r\nSUBKEY_L(15) = subL[14] ^ tl;\r\nSUBKEY_R(15) = subR[14] ^ tr;\r\nSUBKEY_L(16) = subL[16];\r\nSUBKEY_R(16) = subR[16];\r\nSUBKEY_L(17) = subL[17];\r\nSUBKEY_R(17) = subR[17];\r\ntl = subL[15] ^ (subR[15] & ~subR[17]);\r\ndw = tl & subL[17],\r\ntr = subR[15] ^ rol32(dw, 1);\r\nSUBKEY_L(18) = tl ^ subL[19];\r\nSUBKEY_R(18) = tr ^ subR[19];\r\nSUBKEY_L(19) = subL[18] ^ subL[20];\r\nSUBKEY_R(19) = subR[18] ^ subR[20];\r\nSUBKEY_L(20) = subL[19] ^ subL[21];\r\nSUBKEY_R(20) = subR[19] ^ subR[21];\r\nSUBKEY_L(21) = subL[20] ^ subL[22];\r\nSUBKEY_R(21) = subR[20] ^ subR[22];\r\nSUBKEY_L(22) = subL[21] ^ subL[23];\r\nSUBKEY_R(22) = subR[21] ^ subR[23];\r\nif (max == 24) {\r\nSUBKEY_L(23) = subL[22];\r\nSUBKEY_R(23) = subR[22];\r\nSUBKEY_L(24) = subL[24] ^ subL[23];\r\nSUBKEY_R(24) = subR[24] ^ subR[23];\r\n} else {\r\ntl = subL[26] ^ (subR[26] & ~subR[24]);\r\ndw = tl & subL[24],\r\ntr = subR[26] ^ rol32(dw, 1);\r\nSUBKEY_L(23) = subL[22] ^ tl;\r\nSUBKEY_R(23) = subR[22] ^ tr;\r\nSUBKEY_L(24) = subL[24];\r\nSUBKEY_R(24) = subR[24];\r\nSUBKEY_L(25) = subL[25];\r\nSUBKEY_R(25) = subR[25];\r\ntl = subL[23] ^ (subR[23] & ~subR[25]);\r\ndw = tl & subL[25],\r\ntr = subR[23] ^ rol32(dw, 1);\r\nSUBKEY_L(26) = tl ^ subL[27];\r\nSUBKEY_R(26) = tr ^ subR[27];\r\nSUBKEY_L(27) = subL[26] ^ subL[28];\r\nSUBKEY_R(27) = subR[26] ^ subR[28];\r\nSUBKEY_L(28) = subL[27] ^ subL[29];\r\nSUBKEY_R(28) = subR[27] ^ subR[29];\r\nSUBKEY_L(29) = subL[28] ^ subL[30];\r\nSUBKEY_R(29) = subR[28] ^ subR[30];\r\nSUBKEY_L(30) = subL[29] ^ subL[31];\r\nSUBKEY_R(30) = subR[29] ^ subR[31];\r\nSUBKEY_L(31) = subL[30];\r\nSUBKEY_R(31) = subR[30];\r\nSUBKEY_L(32) = subL[32] ^ subL[31];\r\nSUBKEY_R(32) = subR[32] ^ subR[31];\r\n}\r\ni = 2;\r\ndo {\r\ndw = SUBKEY_L(i + 0) ^ SUBKEY_R(i + 0); dw = rol32(dw, 8);\r\nSUBKEY_R(i + 0) = SUBKEY_L(i + 0) ^ dw; SUBKEY_L(i + 0) = dw;\r\ndw = SUBKEY_L(i + 1) ^ SUBKEY_R(i + 1); dw = rol32(dw, 8);\r\nSUBKEY_R(i + 1) = SUBKEY_L(i + 1) ^ dw; SUBKEY_L(i + 1) = dw;\r\ndw = SUBKEY_L(i + 2) ^ SUBKEY_R(i + 2); dw = rol32(dw, 8);\r\nSUBKEY_R(i + 2) = SUBKEY_L(i + 2) ^ dw; SUBKEY_L(i + 2) = dw;\r\ndw = SUBKEY_L(i + 3) ^ SUBKEY_R(i + 3); dw = rol32(dw, 8);\r\nSUBKEY_R(i + 3) = SUBKEY_L(i + 3) ^ dw; SUBKEY_L(i + 3) = dw;\r\ndw = SUBKEY_L(i + 4) ^ SUBKEY_R(i + 4); dw = rol32(dw, 8);\r\nSUBKEY_R(i + 4) = SUBKEY_L(i + 4) ^ dw; SUBKEY_L(i + 4) = dw;\r\ndw = SUBKEY_L(i + 5) ^ SUBKEY_R(i + 5); dw = rol32(dw, 8);\r\nSUBKEY_R(i + 5) = SUBKEY_L(i + 5) ^ dw; SUBKEY_L(i + 5) = dw;\r\ni += 8;\r\n} while (i < max);\r\n}\r\nstatic void camellia_setup128(const unsigned char *key, u32 *subkey)\r\n{\r\nu32 kll, klr, krl, krr;\r\nu32 il, ir, t0, t1, w0, w1;\r\nu32 subL[26];\r\nu32 subR[26];\r\nkll = get_unaligned_be32(key);\r\nklr = get_unaligned_be32(key + 4);\r\nkrl = get_unaligned_be32(key + 8);\r\nkrr = get_unaligned_be32(key + 12);\r\nsubL[0] = kll; subR[0] = klr;\r\nsubL[1] = krl; subR[1] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 15);\r\nsubL[4] = kll; subR[4] = klr;\r\nsubL[5] = krl; subR[5] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 30);\r\nsubL[10] = kll; subR[10] = klr;\r\nsubL[11] = krl; subR[11] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 15);\r\nsubL[13] = krl; subR[13] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 17);\r\nsubL[16] = kll; subR[16] = klr;\r\nsubL[17] = krl; subR[17] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 17);\r\nsubL[18] = kll; subR[18] = klr;\r\nsubL[19] = krl; subR[19] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 17);\r\nsubL[22] = kll; subR[22] = klr;\r\nsubL[23] = krl; subR[23] = krr;\r\nkll = subL[0]; klr = subR[0];\r\nkrl = subL[1]; krr = subR[1];\r\nCAMELLIA_F(kll, klr,\r\nCAMELLIA_SIGMA1L, CAMELLIA_SIGMA1R,\r\nw0, w1, il, ir, t0, t1);\r\nkrl ^= w0; krr ^= w1;\r\nCAMELLIA_F(krl, krr,\r\nCAMELLIA_SIGMA2L, CAMELLIA_SIGMA2R,\r\nkll, klr, il, ir, t0, t1);\r\nCAMELLIA_F(kll, klr,\r\nCAMELLIA_SIGMA3L, CAMELLIA_SIGMA3R,\r\nkrl, krr, il, ir, t0, t1);\r\nkrl ^= w0; krr ^= w1;\r\nCAMELLIA_F(krl, krr,\r\nCAMELLIA_SIGMA4L, CAMELLIA_SIGMA4R,\r\nw0, w1, il, ir, t0, t1);\r\nkll ^= w0; klr ^= w1;\r\nsubL[2] = kll; subR[2] = klr;\r\nsubL[3] = krl; subR[3] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 15);\r\nsubL[6] = kll; subR[6] = klr;\r\nsubL[7] = krl; subR[7] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 15);\r\nsubL[8] = kll; subR[8] = klr;\r\nsubL[9] = krl; subR[9] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 15);\r\nsubL[12] = kll; subR[12] = klr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 15);\r\nsubL[14] = kll; subR[14] = klr;\r\nsubL[15] = krl; subR[15] = krr;\r\nROLDQo32(kll, klr, krl, krr, w0, w1, 34);\r\nsubL[20] = kll; subR[20] = klr;\r\nsubL[21] = krl; subR[21] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 17);\r\nsubL[24] = kll; subR[24] = klr;\r\nsubL[25] = krl; subR[25] = krr;\r\ncamellia_setup_tail(subkey, subL, subR, 24);\r\n}\r\nstatic void camellia_setup256(const unsigned char *key, u32 *subkey)\r\n{\r\nu32 kll, klr, krl, krr;\r\nu32 krll, krlr, krrl, krrr;\r\nu32 il, ir, t0, t1, w0, w1;\r\nu32 subL[34];\r\nu32 subR[34];\r\nkll = get_unaligned_be32(key);\r\nklr = get_unaligned_be32(key + 4);\r\nkrl = get_unaligned_be32(key + 8);\r\nkrr = get_unaligned_be32(key + 12);\r\nkrll = get_unaligned_be32(key + 16);\r\nkrlr = get_unaligned_be32(key + 20);\r\nkrrl = get_unaligned_be32(key + 24);\r\nkrrr = get_unaligned_be32(key + 28);\r\nsubL[0] = kll; subR[0] = klr;\r\nsubL[1] = krl; subR[1] = krr;\r\nROLDQo32(kll, klr, krl, krr, w0, w1, 45);\r\nsubL[12] = kll; subR[12] = klr;\r\nsubL[13] = krl; subR[13] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 15);\r\nsubL[16] = kll; subR[16] = klr;\r\nsubL[17] = krl; subR[17] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 17);\r\nsubL[22] = kll; subR[22] = klr;\r\nsubL[23] = krl; subR[23] = krr;\r\nROLDQo32(kll, klr, krl, krr, w0, w1, 34);\r\nsubL[30] = kll; subR[30] = klr;\r\nsubL[31] = krl; subR[31] = krr;\r\nROLDQ(krll, krlr, krrl, krrr, w0, w1, 15);\r\nsubL[4] = krll; subR[4] = krlr;\r\nsubL[5] = krrl; subR[5] = krrr;\r\nROLDQ(krll, krlr, krrl, krrr, w0, w1, 15);\r\nsubL[8] = krll; subR[8] = krlr;\r\nsubL[9] = krrl; subR[9] = krrr;\r\nROLDQ(krll, krlr, krrl, krrr, w0, w1, 30);\r\nsubL[18] = krll; subR[18] = krlr;\r\nsubL[19] = krrl; subR[19] = krrr;\r\nROLDQo32(krll, krlr, krrl, krrr, w0, w1, 34);\r\nsubL[26] = krll; subR[26] = krlr;\r\nsubL[27] = krrl; subR[27] = krrr;\r\nROLDQo32(krll, krlr, krrl, krrr, w0, w1, 34);\r\nkll = subL[0] ^ krll; klr = subR[0] ^ krlr;\r\nkrl = subL[1] ^ krrl; krr = subR[1] ^ krrr;\r\nCAMELLIA_F(kll, klr,\r\nCAMELLIA_SIGMA1L, CAMELLIA_SIGMA1R,\r\nw0, w1, il, ir, t0, t1);\r\nkrl ^= w0; krr ^= w1;\r\nCAMELLIA_F(krl, krr,\r\nCAMELLIA_SIGMA2L, CAMELLIA_SIGMA2R,\r\nkll, klr, il, ir, t0, t1);\r\nkll ^= krll; klr ^= krlr;\r\nCAMELLIA_F(kll, klr,\r\nCAMELLIA_SIGMA3L, CAMELLIA_SIGMA3R,\r\nkrl, krr, il, ir, t0, t1);\r\nkrl ^= w0 ^ krrl; krr ^= w1 ^ krrr;\r\nCAMELLIA_F(krl, krr,\r\nCAMELLIA_SIGMA4L, CAMELLIA_SIGMA4R,\r\nw0, w1, il, ir, t0, t1);\r\nkll ^= w0; klr ^= w1;\r\nkrll ^= kll; krlr ^= klr;\r\nkrrl ^= krl; krrr ^= krr;\r\nCAMELLIA_F(krll, krlr,\r\nCAMELLIA_SIGMA5L, CAMELLIA_SIGMA5R,\r\nw0, w1, il, ir, t0, t1);\r\nkrrl ^= w0; krrr ^= w1;\r\nCAMELLIA_F(krrl, krrr,\r\nCAMELLIA_SIGMA6L, CAMELLIA_SIGMA6R,\r\nw0, w1, il, ir, t0, t1);\r\nkrll ^= w0; krlr ^= w1;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 15);\r\nsubL[6] = kll; subR[6] = klr;\r\nsubL[7] = krl; subR[7] = krr;\r\nROLDQ(kll, klr, krl, krr, w0, w1, 30);\r\nsubL[14] = kll; subR[14] = klr;\r\nsubL[15] = krl; subR[15] = krr;\r\nsubL[24] = klr; subR[24] = krl;\r\nsubL[25] = krr; subR[25] = kll;\r\nROLDQo32(kll, klr, krl, krr, w0, w1, 49);\r\nsubL[28] = kll; subR[28] = klr;\r\nsubL[29] = krl; subR[29] = krr;\r\nsubL[2] = krll; subR[2] = krlr;\r\nsubL[3] = krrl; subR[3] = krrr;\r\nROLDQ(krll, krlr, krrl, krrr, w0, w1, 30);\r\nsubL[10] = krll; subR[10] = krlr;\r\nsubL[11] = krrl; subR[11] = krrr;\r\nROLDQ(krll, krlr, krrl, krrr, w0, w1, 30);\r\nsubL[20] = krll; subR[20] = krlr;\r\nsubL[21] = krrl; subR[21] = krrr;\r\nROLDQo32(krll, krlr, krrl, krrr, w0, w1, 51);\r\nsubL[32] = krll; subR[32] = krlr;\r\nsubL[33] = krrl; subR[33] = krrr;\r\ncamellia_setup_tail(subkey, subL, subR, 32);\r\n}\r\nstatic void camellia_setup192(const unsigned char *key, u32 *subkey)\r\n{\r\nunsigned char kk[32];\r\nu32 krll, krlr, krrl, krrr;\r\nmemcpy(kk, key, 24);\r\nmemcpy((unsigned char *)&krll, key+16, 4);\r\nmemcpy((unsigned char *)&krlr, key+20, 4);\r\nkrrl = ~krll;\r\nkrrr = ~krlr;\r\nmemcpy(kk+24, (unsigned char *)&krrl, 4);\r\nmemcpy(kk+28, (unsigned char *)&krrr, 4);\r\ncamellia_setup256(kk, subkey);\r\n}\r\nstatic void camellia_do_encrypt(const u32 *subkey, u32 *io, unsigned max)\r\n{\r\nu32 il, ir, t0, t1;\r\nio[0] ^= SUBKEY_L(0);\r\nio[1] ^= SUBKEY_R(0);\r\n#define ROUNDS(i) do { \\r\nCAMELLIA_ROUNDSM(io[0], io[1], \\r\nSUBKEY_L(i + 2), SUBKEY_R(i + 2), \\r\nio[2], io[3], il, ir); \\r\nCAMELLIA_ROUNDSM(io[2], io[3], \\r\nSUBKEY_L(i + 3), SUBKEY_R(i + 3), \\r\nio[0], io[1], il, ir); \\r\nCAMELLIA_ROUNDSM(io[0], io[1], \\r\nSUBKEY_L(i + 4), SUBKEY_R(i + 4), \\r\nio[2], io[3], il, ir); \\r\nCAMELLIA_ROUNDSM(io[2], io[3], \\r\nSUBKEY_L(i + 5), SUBKEY_R(i + 5), \\r\nio[0], io[1], il, ir); \\r\nCAMELLIA_ROUNDSM(io[0], io[1], \\r\nSUBKEY_L(i + 6), SUBKEY_R(i + 6), \\r\nio[2], io[3], il, ir); \\r\nCAMELLIA_ROUNDSM(io[2], io[3], \\r\nSUBKEY_L(i + 7), SUBKEY_R(i + 7), \\r\nio[0], io[1], il, ir); \\r\n} while (0)\r\n#define FLS(i) do { \\r\nCAMELLIA_FLS(io[0], io[1], io[2], io[3], \\r\nSUBKEY_L(i + 0), SUBKEY_R(i + 0), \\r\nSUBKEY_L(i + 1), SUBKEY_R(i + 1), \\r\nt0, t1, il, ir); \\r\n} while (0)\r\nROUNDS(0);\r\nFLS(8);\r\nROUNDS(8);\r\nFLS(16);\r\nROUNDS(16);\r\nif (max == 32) {\r\nFLS(24);\r\nROUNDS(24);\r\n}\r\n#undef ROUNDS\r\n#undef FLS\r\nio[2] ^= SUBKEY_L(max);\r\nio[3] ^= SUBKEY_R(max);\r\n}\r\nstatic void camellia_do_decrypt(const u32 *subkey, u32 *io, unsigned i)\r\n{\r\nu32 il, ir, t0, t1;\r\nio[0] ^= SUBKEY_L(i);\r\nio[1] ^= SUBKEY_R(i);\r\n#define ROUNDS(i) do { \\r\nCAMELLIA_ROUNDSM(io[0], io[1], \\r\nSUBKEY_L(i + 7), SUBKEY_R(i + 7), \\r\nio[2], io[3], il, ir); \\r\nCAMELLIA_ROUNDSM(io[2], io[3], \\r\nSUBKEY_L(i + 6), SUBKEY_R(i + 6), \\r\nio[0], io[1], il, ir); \\r\nCAMELLIA_ROUNDSM(io[0], io[1], \\r\nSUBKEY_L(i + 5), SUBKEY_R(i + 5), \\r\nio[2], io[3], il, ir); \\r\nCAMELLIA_ROUNDSM(io[2], io[3], \\r\nSUBKEY_L(i + 4), SUBKEY_R(i + 4), \\r\nio[0], io[1], il, ir); \\r\nCAMELLIA_ROUNDSM(io[0], io[1], \\r\nSUBKEY_L(i + 3), SUBKEY_R(i + 3), \\r\nio[2], io[3], il, ir); \\r\nCAMELLIA_ROUNDSM(io[2], io[3], \\r\nSUBKEY_L(i + 2), SUBKEY_R(i + 2), \\r\nio[0], io[1], il, ir); \\r\n} while (0)\r\n#define FLS(i) do { \\r\nCAMELLIA_FLS(io[0], io[1], io[2], io[3], \\r\nSUBKEY_L(i + 1), SUBKEY_R(i + 1), \\r\nSUBKEY_L(i + 0), SUBKEY_R(i + 0), \\r\nt0, t1, il, ir); \\r\n} while (0)\r\nif (i == 32) {\r\nROUNDS(24);\r\nFLS(24);\r\n}\r\nROUNDS(16);\r\nFLS(16);\r\nROUNDS(8);\r\nFLS(8);\r\nROUNDS(0);\r\n#undef ROUNDS\r\n#undef FLS\r\nio[2] ^= SUBKEY_L(0);\r\nio[3] ^= SUBKEY_R(0);\r\n}\r\nstatic int\r\ncamellia_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct camellia_ctx *cctx = crypto_tfm_ctx(tfm);\r\nconst unsigned char *key = (const unsigned char *)in_key;\r\nu32 *flags = &tfm->crt_flags;\r\nif (key_len != 16 && key_len != 24 && key_len != 32) {\r\n*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\ncctx->key_length = key_len;\r\nswitch (key_len) {\r\ncase 16:\r\ncamellia_setup128(key, cctx->key_table);\r\nbreak;\r\ncase 24:\r\ncamellia_setup192(key, cctx->key_table);\r\nbreak;\r\ncase 32:\r\ncamellia_setup256(key, cctx->key_table);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void camellia_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\nconst struct camellia_ctx *cctx = crypto_tfm_ctx(tfm);\r\nconst __be32 *src = (const __be32 *)in;\r\n__be32 *dst = (__be32 *)out;\r\nu32 tmp[4];\r\ntmp[0] = be32_to_cpu(src[0]);\r\ntmp[1] = be32_to_cpu(src[1]);\r\ntmp[2] = be32_to_cpu(src[2]);\r\ntmp[3] = be32_to_cpu(src[3]);\r\ncamellia_do_encrypt(cctx->key_table, tmp,\r\ncctx->key_length == 16 ? 24 : 32\r\n);\r\ndst[0] = cpu_to_be32(tmp[2]);\r\ndst[1] = cpu_to_be32(tmp[3]);\r\ndst[2] = cpu_to_be32(tmp[0]);\r\ndst[3] = cpu_to_be32(tmp[1]);\r\n}\r\nstatic void camellia_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\nconst struct camellia_ctx *cctx = crypto_tfm_ctx(tfm);\r\nconst __be32 *src = (const __be32 *)in;\r\n__be32 *dst = (__be32 *)out;\r\nu32 tmp[4];\r\ntmp[0] = be32_to_cpu(src[0]);\r\ntmp[1] = be32_to_cpu(src[1]);\r\ntmp[2] = be32_to_cpu(src[2]);\r\ntmp[3] = be32_to_cpu(src[3]);\r\ncamellia_do_decrypt(cctx->key_table, tmp,\r\ncctx->key_length == 16 ? 24 : 32\r\n);\r\ndst[0] = cpu_to_be32(tmp[2]);\r\ndst[1] = cpu_to_be32(tmp[3]);\r\ndst[2] = cpu_to_be32(tmp[0]);\r\ndst[3] = cpu_to_be32(tmp[1]);\r\n}\r\nstatic int __init camellia_init(void)\r\n{\r\nreturn crypto_register_alg(&camellia_alg);\r\n}\r\nstatic void __exit camellia_fini(void)\r\n{\r\ncrypto_unregister_alg(&camellia_alg);\r\n}
