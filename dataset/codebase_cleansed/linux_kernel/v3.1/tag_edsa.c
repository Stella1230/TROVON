netdev_tx_t edsa_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nu8 *edsa_header;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nif (skb->protocol == htons(ETH_P_8021Q)) {\r\nif (skb_cow_head(skb, DSA_HLEN) < 0)\r\ngoto out_free;\r\nskb_push(skb, DSA_HLEN);\r\nmemmove(skb->data, skb->data + DSA_HLEN, 2 * ETH_ALEN);\r\nedsa_header = skb->data + 2 * ETH_ALEN;\r\nedsa_header[0] = (ETH_P_EDSA >> 8) & 0xff;\r\nedsa_header[1] = ETH_P_EDSA & 0xff;\r\nedsa_header[2] = 0x00;\r\nedsa_header[3] = 0x00;\r\nedsa_header[4] = 0x60 | p->parent->index;\r\nedsa_header[5] = p->port << 3;\r\nif (edsa_header[6] & 0x10) {\r\nedsa_header[5] |= 0x01;\r\nedsa_header[6] &= ~0x10;\r\n}\r\n} else {\r\nif (skb_cow_head(skb, EDSA_HLEN) < 0)\r\ngoto out_free;\r\nskb_push(skb, EDSA_HLEN);\r\nmemmove(skb->data, skb->data + EDSA_HLEN, 2 * ETH_ALEN);\r\nedsa_header = skb->data + 2 * ETH_ALEN;\r\nedsa_header[0] = (ETH_P_EDSA >> 8) & 0xff;\r\nedsa_header[1] = ETH_P_EDSA & 0xff;\r\nedsa_header[2] = 0x00;\r\nedsa_header[3] = 0x00;\r\nedsa_header[4] = 0x40 | p->parent->index;\r\nedsa_header[5] = p->port << 3;\r\nedsa_header[6] = 0x00;\r\nedsa_header[7] = 0x00;\r\n}\r\nskb->protocol = htons(ETH_P_EDSA);\r\nskb->dev = p->parent->dst->master_netdev;\r\ndev_queue_xmit(skb);\r\nreturn NETDEV_TX_OK;\r\nout_free:\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int edsa_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct dsa_switch_tree *dst = dev->dsa_ptr;\r\nstruct dsa_switch *ds;\r\nu8 *edsa_header;\r\nint source_device;\r\nint source_port;\r\nif (unlikely(dst == NULL))\r\ngoto out_drop;\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto out;\r\nif (unlikely(!pskb_may_pull(skb, EDSA_HLEN)))\r\ngoto out_drop;\r\nedsa_header = skb->data + 2;\r\nif ((edsa_header[0] & 0xc0) != 0x00 && (edsa_header[0] & 0xc0) != 0xc0)\r\ngoto out_drop;\r\nsource_device = edsa_header[0] & 0x1f;\r\nsource_port = (edsa_header[1] >> 3) & 0x1f;\r\nif (source_device >= dst->pd->nr_chips)\r\ngoto out_drop;\r\nds = dst->ds[source_device];\r\nif (source_port >= DSA_MAX_PORTS || ds->ports[source_port] == NULL)\r\ngoto out_drop;\r\nif (edsa_header[0] & 0x20) {\r\nu8 new_header[4];\r\nnew_header[0] = (ETH_P_8021Q >> 8) & 0xff;\r\nnew_header[1] = ETH_P_8021Q & 0xff;\r\nnew_header[2] = edsa_header[2] & ~0x10;\r\nnew_header[3] = edsa_header[3];\r\nif (edsa_header[1] & 0x01)\r\nnew_header[2] |= 0x10;\r\nskb_pull_rcsum(skb, DSA_HLEN);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\n__wsum c = skb->csum;\r\nc = csum_add(c, csum_partial(new_header + 2, 2, 0));\r\nc = csum_sub(c, csum_partial(edsa_header + 2, 2, 0));\r\nskb->csum = c;\r\n}\r\nmemcpy(edsa_header, new_header, DSA_HLEN);\r\nmemmove(skb->data - ETH_HLEN,\r\nskb->data - ETH_HLEN - DSA_HLEN,\r\n2 * ETH_ALEN);\r\n} else {\r\nskb_pull_rcsum(skb, EDSA_HLEN);\r\nmemmove(skb->data - ETH_HLEN,\r\nskb->data - ETH_HLEN - EDSA_HLEN,\r\n2 * ETH_ALEN);\r\n}\r\nskb->dev = ds->ports[source_port];\r\nskb_push(skb, ETH_HLEN);\r\nskb->pkt_type = PACKET_HOST;\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nskb->dev->stats.rx_packets++;\r\nskb->dev->stats.rx_bytes += skb->len;\r\nnetif_receive_skb(skb);\r\nreturn 0;\r\nout_drop:\r\nkfree_skb(skb);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int __init edsa_init_module(void)\r\n{\r\ndev_add_pack(&edsa_packet_type);\r\nreturn 0;\r\n}\r\nstatic void __exit edsa_cleanup_module(void)\r\n{\r\ndev_remove_pack(&edsa_packet_type);\r\n}
