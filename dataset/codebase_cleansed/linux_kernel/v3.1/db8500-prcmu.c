int prcmu_enable_dsipll(void)\r\n{\r\nint i;\r\nunsigned int plldsifreq;\r\nwritel(PRCMU_RESET_DSIPLL, (_PRCMU_BASE + PRCM_APE_RESETN_CLR));\r\nwritel(PRCMU_UNCLAMP_DSIPLL, (_PRCMU_BASE + PRCM_MMIP_LS_CLAMP_CLR));\r\nif (prcmu_is_u8400())\r\nplldsifreq = PRCMU_PLLDSI_FREQ_SETTING_U8400;\r\nelse\r\nplldsifreq = PRCMU_PLLDSI_FREQ_SETTING;\r\nwritel(plldsifreq, (_PRCMU_BASE + PRCM_PLLDSI_FREQ));\r\nwritel(PRCMU_DSI_PLLOUT_SEL_SETTING,\r\n(_PRCMU_BASE + PRCM_DSI_PLLOUT_SEL));\r\nwritel(PRCMU_ENABLE_ESCAPE_CLOCK_DIV,\r\n(_PRCMU_BASE + PRCM_DSITVCLK_DIV));\r\nwritel(PRCMU_ENABLE_PLLDSI, (_PRCMU_BASE + PRCM_PLLDSI_ENABLE));\r\nwritel(PRCMU_DSI_RESET_SW, (_PRCMU_BASE + PRCM_DSI_SW_RESET));\r\nfor (i = 0; i < 10; i++) {\r\nif ((readl(_PRCMU_BASE + PRCM_PLLDSI_LOCKP) &\r\nPRCMU_PLLDSI_LOCKP_LOCKED)\r\n== PRCMU_PLLDSI_LOCKP_LOCKED)\r\nbreak;\r\nudelay(100);\r\n}\r\nwritel(PRCMU_RESET_DSIPLL, (_PRCMU_BASE + PRCM_APE_RESETN_SET));\r\nreturn 0;\r\n}\r\nint prcmu_disable_dsipll(void)\r\n{\r\nwritel(PRCMU_DISABLE_PLLDSI, (_PRCMU_BASE + PRCM_PLLDSI_ENABLE));\r\nwritel(PRCMU_DISABLE_ESCAPE_CLOCK_DIV,\r\n(_PRCMU_BASE + PRCM_DSITVCLK_DIV));\r\nreturn 0;\r\n}\r\nint prcmu_set_display_clocks(void)\r\n{\r\nunsigned long flags;\r\nunsigned int dsiclk;\r\nif (prcmu_is_u8400())\r\ndsiclk = PRCMU_DSI_CLOCK_SETTING_U8400;\r\nelse\r\ndsiclk = PRCMU_DSI_CLOCK_SETTING;\r\nspin_lock_irqsave(&clk_mgt_lock, flags);\r\nwhile ((readl(_PRCMU_BASE + PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\r\ncpu_relax();\r\nwritel(dsiclk, (_PRCMU_BASE + PRCM_HDMICLK_MGT));\r\nwritel(PRCMU_DSI_LP_CLOCK_SETTING, (_PRCMU_BASE + PRCM_TVCLK_MGT));\r\nwritel(PRCMU_DPI_CLOCK_SETTING, (_PRCMU_BASE + PRCM_LCDCLK_MGT));\r\nwritel(0, (_PRCMU_BASE + PRCM_SEM));\r\nspin_unlock_irqrestore(&clk_mgt_lock, flags);\r\nreturn 0;\r\n}\r\nvoid prcmu_enable_spi2(void)\r\n{\r\nu32 reg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpiocr_lock, flags);\r\nreg = readl(_PRCMU_BASE + PRCM_GPIOCR);\r\nwritel(reg | PRCM_GPIOCR_SPI2_SELECT, _PRCMU_BASE + PRCM_GPIOCR);\r\nspin_unlock_irqrestore(&gpiocr_lock, flags);\r\n}\r\nvoid prcmu_disable_spi2(void)\r\n{\r\nu32 reg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpiocr_lock, flags);\r\nreg = readl(_PRCMU_BASE + PRCM_GPIOCR);\r\nwritel(reg & ~PRCM_GPIOCR_SPI2_SELECT, _PRCMU_BASE + PRCM_GPIOCR);\r\nspin_unlock_irqrestore(&gpiocr_lock, flags);\r\n}\r\nbool prcmu_has_arm_maxopp(void)\r\n{\r\nreturn (readb(tcdm_base + PRCM_AVS_VARM_MAX_OPP) &\r\nPRCM_AVS_ISMODEENABLE_MASK) == PRCM_AVS_ISMODEENABLE_MASK;\r\n}\r\nbool prcmu_is_u8400(void)\r\n{\r\nreturn prcmu_version.project_number == PRCMU_PROJECT_ID_8400V2_0;\r\n}\r\nint prcmu_get_boot_status(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_BOOT_STATUS);\r\n}\r\nint prcmu_set_rc_a2p(enum romcode_write val)\r\n{\r\nif (val < RDY_2_DS || val > RDY_2_XP70_RST)\r\nreturn -EINVAL;\r\nwriteb(val, (tcdm_base + PRCM_ROMCODE_A2P));\r\nreturn 0;\r\n}\r\nenum romcode_read prcmu_get_rc_p2a(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_ROMCODE_P2A);\r\n}\r\nenum ap_pwrst prcmu_get_xp70_current_state(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_XP70_CUR_PWR_STATE);\r\n}\r\nint prcmu_config_clkout(u8 clkout, u8 source, u8 div)\r\n{\r\nstatic int requests[2];\r\nint r = 0;\r\nunsigned long flags;\r\nu32 val;\r\nu32 bits;\r\nu32 mask;\r\nu32 div_mask;\r\nBUG_ON(clkout > 1);\r\nBUG_ON(div > 63);\r\nBUG_ON((clkout == 0) && (source > PRCMU_CLKSRC_CLK009));\r\nif (!div && !requests[clkout])\r\nreturn -EINVAL;\r\nswitch (clkout) {\r\ncase 0:\r\ndiv_mask = PRCM_CLKOCR_CLKODIV0_MASK;\r\nmask = (PRCM_CLKOCR_CLKODIV0_MASK | PRCM_CLKOCR_CLKOSEL0_MASK);\r\nbits = ((source << PRCM_CLKOCR_CLKOSEL0_SHIFT) |\r\n(div << PRCM_CLKOCR_CLKODIV0_SHIFT));\r\nbreak;\r\ncase 1:\r\ndiv_mask = PRCM_CLKOCR_CLKODIV1_MASK;\r\nmask = (PRCM_CLKOCR_CLKODIV1_MASK | PRCM_CLKOCR_CLKOSEL1_MASK |\r\nPRCM_CLKOCR_CLK1TYPE);\r\nbits = ((source << PRCM_CLKOCR_CLKOSEL1_SHIFT) |\r\n(div << PRCM_CLKOCR_CLKODIV1_SHIFT));\r\nbreak;\r\n}\r\nbits &= mask;\r\nspin_lock_irqsave(&clkout_lock, flags);\r\nval = readl(_PRCMU_BASE + PRCM_CLKOCR);\r\nif (val & div_mask) {\r\nif (div) {\r\nif ((val & mask) != bits) {\r\nr = -EBUSY;\r\ngoto unlock_and_return;\r\n}\r\n} else {\r\nif ((val & mask & ~div_mask) != bits) {\r\nr = -EINVAL;\r\ngoto unlock_and_return;\r\n}\r\n}\r\n}\r\nwritel((bits | (val & ~mask)), (_PRCMU_BASE + PRCM_CLKOCR));\r\nrequests[clkout] += (div ? 1 : -1);\r\nunlock_and_return:\r\nspin_unlock_irqrestore(&clkout_lock, flags);\r\nreturn r;\r\n}\r\nint prcmu_set_power_state(u8 state, bool keep_ulp_clk, bool keep_ap_pll)\r\n{\r\nunsigned long flags;\r\nBUG_ON((state < PRCMU_AP_SLEEP) || (PRCMU_AP_DEEP_IDLE < state));\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\r\ncpu_relax();\r\nwriteb(MB0H_POWER_STATE_TRANS, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\r\nwriteb(state, (tcdm_base + PRCM_REQ_MB0_AP_POWER_STATE));\r\nwriteb((keep_ap_pll ? 1 : 0), (tcdm_base + PRCM_REQ_MB0_AP_PLL_STATE));\r\nwriteb((keep_ulp_clk ? 1 : 0),\r\n(tcdm_base + PRCM_REQ_MB0_ULP_CLOCK_STATE));\r\nwriteb(0, (tcdm_base + PRCM_REQ_MB0_DO_NOT_WFI));\r\nwritel(MBOX_BIT(0), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void config_wakeups(void)\r\n{\r\nconst u8 header[2] = {\r\nMB0H_CONFIG_WAKEUPS_EXE,\r\nMB0H_CONFIG_WAKEUPS_SLEEP\r\n};\r\nstatic u32 last_dbb_events;\r\nstatic u32 last_abb_events;\r\nu32 dbb_events;\r\nu32 abb_events;\r\nunsigned int i;\r\ndbb_events = mb0_transfer.req.dbb_irqs | mb0_transfer.req.dbb_wakeups;\r\ndbb_events |= (WAKEUP_BIT_AC_WAKE_ACK | WAKEUP_BIT_AC_SLEEP_ACK);\r\nabb_events = mb0_transfer.req.abb_events;\r\nif ((dbb_events == last_dbb_events) && (abb_events == last_abb_events))\r\nreturn;\r\nfor (i = 0; i < 2; i++) {\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\r\ncpu_relax();\r\nwritel(dbb_events, (tcdm_base + PRCM_REQ_MB0_WAKEUP_8500));\r\nwritel(abb_events, (tcdm_base + PRCM_REQ_MB0_WAKEUP_4500));\r\nwriteb(header[i], (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\r\nwritel(MBOX_BIT(0), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\n}\r\nlast_dbb_events = dbb_events;\r\nlast_abb_events = abb_events;\r\n}\r\nvoid prcmu_enable_wakeups(u32 wakeups)\r\n{\r\nunsigned long flags;\r\nu32 bits;\r\nint i;\r\nBUG_ON(wakeups != (wakeups & VALID_WAKEUPS));\r\nfor (i = 0, bits = 0; i < NUM_PRCMU_WAKEUP_INDICES; i++) {\r\nif (wakeups & BIT(i))\r\nbits |= prcmu_wakeup_bit[i];\r\n}\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nmb0_transfer.req.dbb_wakeups = bits;\r\nconfig_wakeups();\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\n}\r\nvoid prcmu_config_abb_event_readout(u32 abb_events)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nmb0_transfer.req.abb_events = abb_events;\r\nconfig_wakeups();\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\n}\r\nvoid prcmu_get_abb_event_buffer(void __iomem **buf)\r\n{\r\nif (readb(tcdm_base + PRCM_ACK_MB0_READ_POINTER) & 1)\r\n*buf = (tcdm_base + PRCM_ACK_MB0_WAKEUP_1_4500);\r\nelse\r\n*buf = (tcdm_base + PRCM_ACK_MB0_WAKEUP_0_4500);\r\n}\r\nint prcmu_set_arm_opp(u8 opp)\r\n{\r\nint r;\r\nif (opp < ARM_NO_CHANGE || opp > ARM_EXTCLK)\r\nreturn -EINVAL;\r\nr = 0;\r\nmutex_lock(&mb1_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_ARM_APE_OPP, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwriteb(opp, (tcdm_base + PRCM_REQ_MB1_ARM_OPP));\r\nwriteb(APE_NO_CHANGE, (tcdm_base + PRCM_REQ_MB1_APE_OPP));\r\nwritel(MBOX_BIT(1), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb1_transfer.work);\r\nif ((mb1_transfer.ack.header != MB1H_ARM_APE_OPP) ||\r\n(mb1_transfer.ack.arm_opp != opp))\r\nr = -EIO;\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nint prcmu_get_arm_opp(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_ACK_MB1_CURRENT_ARM_OPP);\r\n}\r\nint prcmu_get_ddr_opp(void)\r\n{\r\nreturn readb(_PRCMU_BASE + PRCM_DDR_SUBSYS_APE_MINBW);\r\n}\r\nint prcmu_set_ddr_opp(u8 opp)\r\n{\r\nif (opp < DDR_100_OPP || opp > DDR_25_OPP)\r\nreturn -EINVAL;\r\nif (cpu_is_u8500v20_or_later() && !cpu_is_u8500v20())\r\nwriteb(opp, (_PRCMU_BASE + PRCM_DDR_SUBSYS_APE_MINBW));\r\nreturn 0;\r\n}\r\nint prcmu_set_ape_opp(u8 opp)\r\n{\r\nint r = 0;\r\nmutex_lock(&mb1_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_ARM_APE_OPP, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwriteb(ARM_NO_CHANGE, (tcdm_base + PRCM_REQ_MB1_ARM_OPP));\r\nwriteb(opp, (tcdm_base + PRCM_REQ_MB1_APE_OPP));\r\nwritel(MBOX_BIT(1), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb1_transfer.work);\r\nif ((mb1_transfer.ack.header != MB1H_ARM_APE_OPP) ||\r\n(mb1_transfer.ack.ape_opp != opp))\r\nr = -EIO;\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nint prcmu_get_ape_opp(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_ACK_MB1_CURRENT_APE_OPP);\r\n}\r\nint prcmu_request_ape_opp_100_voltage(bool enable)\r\n{\r\nint r = 0;\r\nu8 header;\r\nstatic unsigned int requests;\r\nmutex_lock(&mb1_transfer.lock);\r\nif (enable) {\r\nif (0 != requests++)\r\ngoto unlock_and_return;\r\nheader = MB1H_REQUEST_APE_OPP_100_VOLT;\r\n} else {\r\nif (requests == 0) {\r\nr = -EIO;\r\ngoto unlock_and_return;\r\n} else if (1 != requests--) {\r\ngoto unlock_and_return;\r\n}\r\nheader = MB1H_RELEASE_APE_OPP_100_VOLT;\r\n}\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(header, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwritel(MBOX_BIT(1), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb1_transfer.work);\r\nif ((mb1_transfer.ack.header != header) ||\r\n((mb1_transfer.ack.ape_voltage_status & BIT(0)) != 0))\r\nr = -EIO;\r\nunlock_and_return:\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nint prcmu_release_usb_wakeup_state(void)\r\n{\r\nint r = 0;\r\nmutex_lock(&mb1_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_RELEASE_USB_WAKEUP,\r\n(tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwritel(MBOX_BIT(1), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb1_transfer.work);\r\nif ((mb1_transfer.ack.header != MB1H_RELEASE_USB_WAKEUP) ||\r\n((mb1_transfer.ack.ape_voltage_status & BIT(0)) != 0))\r\nr = -EIO;\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nint prcmu_set_epod(u16 epod_id, u8 epod_state)\r\n{\r\nint r = 0;\r\nbool ram_retention = false;\r\nint i;\r\nBUG_ON(epod_id >= NUM_EPOD_ID);\r\nswitch (epod_id) {\r\ncase EPOD_ID_SVAMMDSP:\r\ncase EPOD_ID_SIAMMDSP:\r\ncase EPOD_ID_ESRAM12:\r\ncase EPOD_ID_ESRAM34:\r\nram_retention = true;\r\nbreak;\r\n}\r\nBUG_ON(epod_state > EPOD_STATE_ON);\r\nBUG_ON(epod_state == EPOD_STATE_RAMRET && !ram_retention);\r\nmutex_lock(&mb2_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(2))\r\ncpu_relax();\r\nfor (i = 0; i < NUM_EPOD_ID; i++)\r\nwriteb(EPOD_STATE_NO_CHANGE, (tcdm_base + PRCM_REQ_MB2 + i));\r\nwriteb(epod_state, (tcdm_base + PRCM_REQ_MB2 + epod_id));\r\nwriteb(MB2H_DPS, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB2));\r\nwritel(MBOX_BIT(2), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nif (!wait_for_completion_timeout(&mb2_transfer.work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\nr = -EIO;\r\ngoto unlock_and_return;\r\n}\r\nif (mb2_transfer.ack.status != HWACC_PWR_ST_OK)\r\nr = -EIO;\r\nunlock_and_return:\r\nmutex_unlock(&mb2_transfer.lock);\r\nreturn r;\r\n}\r\nvoid prcmu_configure_auto_pm(struct prcmu_auto_pm_config *sleep,\r\nstruct prcmu_auto_pm_config *idle)\r\n{\r\nu32 sleep_cfg;\r\nu32 idle_cfg;\r\nunsigned long flags;\r\nBUG_ON((sleep == NULL) || (idle == NULL));\r\nsleep_cfg = (sleep->sva_auto_pm_enable & 0xF);\r\nsleep_cfg = ((sleep_cfg << 4) | (sleep->sia_auto_pm_enable & 0xF));\r\nsleep_cfg = ((sleep_cfg << 8) | (sleep->sva_power_on & 0xFF));\r\nsleep_cfg = ((sleep_cfg << 8) | (sleep->sia_power_on & 0xFF));\r\nsleep_cfg = ((sleep_cfg << 4) | (sleep->sva_policy & 0xF));\r\nsleep_cfg = ((sleep_cfg << 4) | (sleep->sia_policy & 0xF));\r\nidle_cfg = (idle->sva_auto_pm_enable & 0xF);\r\nidle_cfg = ((idle_cfg << 4) | (idle->sia_auto_pm_enable & 0xF));\r\nidle_cfg = ((idle_cfg << 8) | (idle->sva_power_on & 0xFF));\r\nidle_cfg = ((idle_cfg << 8) | (idle->sia_power_on & 0xFF));\r\nidle_cfg = ((idle_cfg << 4) | (idle->sva_policy & 0xF));\r\nidle_cfg = ((idle_cfg << 4) | (idle->sia_policy & 0xF));\r\nspin_lock_irqsave(&mb2_transfer.auto_pm_lock, flags);\r\nwritel(sleep_cfg, (tcdm_base + PRCM_REQ_MB2_AUTO_PM_SLEEP));\r\nwritel(idle_cfg, (tcdm_base + PRCM_REQ_MB2_AUTO_PM_IDLE));\r\nmb2_transfer.auto_pm_enabled =\r\n((sleep->sva_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\r\n(sleep->sia_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\r\n(idle->sva_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\r\n(idle->sia_auto_pm_enable == PRCMU_AUTO_PM_ON));\r\nspin_unlock_irqrestore(&mb2_transfer.auto_pm_lock, flags);\r\n}\r\nbool prcmu_is_auto_pm_enabled(void)\r\n{\r\nreturn mb2_transfer.auto_pm_enabled;\r\n}\r\nstatic int request_sysclk(bool enable)\r\n{\r\nint r;\r\nunsigned long flags;\r\nr = 0;\r\nmutex_lock(&mb3_transfer.sysclk_lock);\r\nspin_lock_irqsave(&mb3_transfer.lock, flags);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(3))\r\ncpu_relax();\r\nwriteb((enable ? ON : OFF), (tcdm_base + PRCM_REQ_MB3_SYSCLK_MGT));\r\nwriteb(MB3H_SYSCLK, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB3));\r\nwritel(MBOX_BIT(3), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nspin_unlock_irqrestore(&mb3_transfer.lock, flags);\r\nif (enable && !wait_for_completion_timeout(&mb3_transfer.sysclk_work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\nr = -EIO;\r\n}\r\nmutex_unlock(&mb3_transfer.sysclk_lock);\r\nreturn r;\r\n}\r\nstatic int request_timclk(bool enable)\r\n{\r\nu32 val = (PRCM_TCR_DOZE_MODE | PRCM_TCR_TENSEL_MASK);\r\nif (!enable)\r\nval |= PRCM_TCR_STOP_TIMERS;\r\nwritel(val, (_PRCMU_BASE + PRCM_TCR));\r\nreturn 0;\r\n}\r\nstatic int request_reg_clock(u8 clock, bool enable)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&clk_mgt_lock, flags);\r\nwhile ((readl(_PRCMU_BASE + PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\r\ncpu_relax();\r\nval = readl(_PRCMU_BASE + clk_mgt[clock].offset);\r\nif (enable) {\r\nval |= (PRCM_CLK_MGT_CLKEN | clk_mgt[clock].pllsw);\r\n} else {\r\nclk_mgt[clock].pllsw = (val & PRCM_CLK_MGT_CLKPLLSW_MASK);\r\nval &= ~(PRCM_CLK_MGT_CLKEN | PRCM_CLK_MGT_CLKPLLSW_MASK);\r\n}\r\nwritel(val, (_PRCMU_BASE + clk_mgt[clock].offset));\r\nwritel(0, (_PRCMU_BASE + PRCM_SEM));\r\nspin_unlock_irqrestore(&clk_mgt_lock, flags);\r\nreturn 0;\r\n}\r\nint prcmu_request_clock(u8 clock, bool enable)\r\n{\r\nif (clock < PRCMU_NUM_REG_CLOCKS)\r\nreturn request_reg_clock(clock, enable);\r\nelse if (clock == PRCMU_TIMCLK)\r\nreturn request_timclk(enable);\r\nelse if (clock == PRCMU_SYSCLK)\r\nreturn request_sysclk(enable);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nint prcmu_config_esram0_deep_sleep(u8 state)\r\n{\r\nif ((state > ESRAM0_DEEP_SLEEP_STATE_RET) ||\r\n(state < ESRAM0_DEEP_SLEEP_STATE_OFF))\r\nreturn -EINVAL;\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwriteb(MB4H_MEM_ST, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwriteb(((DDR_PWR_STATE_OFFHIGHLAT << 4) | DDR_PWR_STATE_ON),\r\n(tcdm_base + PRCM_REQ_MB4_DDR_ST_AP_SLEEP_IDLE));\r\nwriteb(DDR_PWR_STATE_ON,\r\n(tcdm_base + PRCM_REQ_MB4_DDR_ST_AP_DEEP_IDLE));\r\nwriteb(state, (tcdm_base + PRCM_REQ_MB4_ESRAM0_ST));\r\nwritel(MBOX_BIT(4), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nint prcmu_config_hotdog(u8 threshold)\r\n{\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwriteb(threshold, (tcdm_base + PRCM_REQ_MB4_HOTDOG_THRESHOLD));\r\nwriteb(MB4H_HOTDOG, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwritel(MBOX_BIT(4), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nint prcmu_config_hotmon(u8 low, u8 high)\r\n{\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwriteb(low, (tcdm_base + PRCM_REQ_MB4_HOTMON_LOW));\r\nwriteb(high, (tcdm_base + PRCM_REQ_MB4_HOTMON_HIGH));\r\nwriteb((HOTMON_CONFIG_LOW | HOTMON_CONFIG_HIGH),\r\n(tcdm_base + PRCM_REQ_MB4_HOTMON_CONFIG));\r\nwriteb(MB4H_HOTMON, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwritel(MBOX_BIT(4), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nstatic int config_hot_period(u16 val)\r\n{\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwritew(val, (tcdm_base + PRCM_REQ_MB4_HOT_PERIOD));\r\nwriteb(MB4H_HOT_PERIOD, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwritel(MBOX_BIT(4), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nint prcmu_start_temp_sense(u16 cycles32k)\r\n{\r\nif (cycles32k == 0xFFFF)\r\nreturn -EINVAL;\r\nreturn config_hot_period(cycles32k);\r\n}\r\nint prcmu_stop_temp_sense(void)\r\n{\r\nreturn config_hot_period(0xFFFF);\r\n}\r\nint prcmu_set_clock_divider(u8 clock, u8 divider)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nif ((clock >= PRCMU_NUM_REG_CLOCKS) || (divider < 1) || (31 < divider))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&clk_mgt_lock, flags);\r\nwhile ((readl(_PRCMU_BASE + PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\r\ncpu_relax();\r\nval = readl(_PRCMU_BASE + clk_mgt[clock].offset);\r\nval &= ~(PRCM_CLK_MGT_CLKPLLDIV_MASK);\r\nval |= (u32)divider;\r\nwritel(val, (_PRCMU_BASE + clk_mgt[clock].offset));\r\nwritel(0, (_PRCMU_BASE + PRCM_SEM));\r\nspin_unlock_irqrestore(&clk_mgt_lock, flags);\r\nreturn 0;\r\n}\r\nint prcmu_abb_read(u8 slave, u8 reg, u8 *value, u8 size)\r\n{\r\nint r;\r\nif (size != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&mb5_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(5))\r\ncpu_relax();\r\nwriteb(PRCMU_I2C_READ(slave), (tcdm_base + PRCM_REQ_MB5_I2C_SLAVE_OP));\r\nwriteb(PRCMU_I2C_STOP_EN, (tcdm_base + PRCM_REQ_MB5_I2C_HW_BITS));\r\nwriteb(reg, (tcdm_base + PRCM_REQ_MB5_I2C_REG));\r\nwriteb(0, (tcdm_base + PRCM_REQ_MB5_I2C_VAL));\r\nwritel(MBOX_BIT(5), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nif (!wait_for_completion_timeout(&mb5_transfer.work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\nr = -EIO;\r\n} else {\r\nr = ((mb5_transfer.ack.status == I2C_RD_OK) ? 0 : -EIO);\r\n}\r\nif (!r)\r\n*value = mb5_transfer.ack.value;\r\nmutex_unlock(&mb5_transfer.lock);\r\nreturn r;\r\n}\r\nint prcmu_abb_write(u8 slave, u8 reg, u8 *value, u8 size)\r\n{\r\nint r;\r\nif (size != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&mb5_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(5))\r\ncpu_relax();\r\nwriteb(PRCMU_I2C_WRITE(slave), (tcdm_base + PRCM_REQ_MB5_I2C_SLAVE_OP));\r\nwriteb(PRCMU_I2C_STOP_EN, (tcdm_base + PRCM_REQ_MB5_I2C_HW_BITS));\r\nwriteb(reg, (tcdm_base + PRCM_REQ_MB5_I2C_REG));\r\nwriteb(*value, (tcdm_base + PRCM_REQ_MB5_I2C_VAL));\r\nwritel(MBOX_BIT(5), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nif (!wait_for_completion_timeout(&mb5_transfer.work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\nr = -EIO;\r\n} else {\r\nr = ((mb5_transfer.ack.status == I2C_WR_OK) ? 0 : -EIO);\r\n}\r\nmutex_unlock(&mb5_transfer.lock);\r\nreturn r;\r\n}\r\nvoid prcmu_ac_wake_req(void)\r\n{\r\nu32 val;\r\nmutex_lock(&mb0_transfer.ac_wake_lock);\r\nval = readl(_PRCMU_BASE + PRCM_HOSTACCESS_REQ);\r\nif (val & PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ)\r\ngoto unlock_and_return;\r\natomic_set(&ac_wake_req_state, 1);\r\nwritel((val | PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ),\r\n(_PRCMU_BASE + PRCM_HOSTACCESS_REQ));\r\nif (!wait_for_completion_timeout(&mb0_transfer.ac_wake_work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\n}\r\nunlock_and_return:\r\nmutex_unlock(&mb0_transfer.ac_wake_lock);\r\n}\r\nvoid prcmu_ac_sleep_req()\r\n{\r\nu32 val;\r\nmutex_lock(&mb0_transfer.ac_wake_lock);\r\nval = readl(_PRCMU_BASE + PRCM_HOSTACCESS_REQ);\r\nif (!(val & PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ))\r\ngoto unlock_and_return;\r\nwritel((val & ~PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ),\r\n(_PRCMU_BASE + PRCM_HOSTACCESS_REQ));\r\nif (!wait_for_completion_timeout(&mb0_transfer.ac_wake_work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\n}\r\natomic_set(&ac_wake_req_state, 0);\r\nunlock_and_return:\r\nmutex_unlock(&mb0_transfer.ac_wake_lock);\r\n}\r\nbool prcmu_is_ac_wake_requested(void)\r\n{\r\nreturn (atomic_read(&ac_wake_req_state) != 0);\r\n}\r\nvoid prcmu_system_reset(u16 reset_code)\r\n{\r\nwritew(reset_code, (tcdm_base + PRCM_SW_RST_REASON));\r\nwritel(1, (_PRCMU_BASE + PRCM_APE_SOFTRST));\r\n}\r\nvoid prcmu_modem_reset(void)\r\n{\r\nmutex_lock(&mb1_transfer.lock);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_RESET_MODEM, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwritel(MBOX_BIT(1), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nwait_for_completion(&mb1_transfer.work);\r\nmutex_unlock(&mb1_transfer.lock);\r\n}\r\nstatic void ack_dbb_wakeup(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nwhile (readl(_PRCMU_BASE + PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\r\ncpu_relax();\r\nwriteb(MB0H_READ_WAKEUP_ACK, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\r\nwritel(MBOX_BIT(0), (_PRCMU_BASE + PRCM_MBOX_CPU_SET));\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\n}\r\nstatic inline void print_unknown_header_warning(u8 n, u8 header)\r\n{\r\npr_warning("prcmu: Unknown message header (%d) in mailbox %d.\n",\r\nheader, n);\r\n}\r\nstatic bool read_mailbox_0(void)\r\n{\r\nbool r;\r\nu32 ev;\r\nunsigned int n;\r\nu8 header;\r\nheader = readb(tcdm_base + PRCM_MBOX_HEADER_ACK_MB0);\r\nswitch (header) {\r\ncase MB0H_WAKEUP_EXE:\r\ncase MB0H_WAKEUP_SLEEP:\r\nif (readb(tcdm_base + PRCM_ACK_MB0_READ_POINTER) & 1)\r\nev = readl(tcdm_base + PRCM_ACK_MB0_WAKEUP_1_8500);\r\nelse\r\nev = readl(tcdm_base + PRCM_ACK_MB0_WAKEUP_0_8500);\r\nif (ev & (WAKEUP_BIT_AC_WAKE_ACK | WAKEUP_BIT_AC_SLEEP_ACK))\r\ncomplete(&mb0_transfer.ac_wake_work);\r\nif (ev & WAKEUP_BIT_SYSCLK_OK)\r\ncomplete(&mb3_transfer.sysclk_work);\r\nev &= mb0_transfer.req.dbb_irqs;\r\nfor (n = 0; n < NUM_PRCMU_WAKEUPS; n++) {\r\nif (ev & prcmu_irq_bit[n])\r\ngeneric_handle_irq(IRQ_PRCMU_BASE + n);\r\n}\r\nr = true;\r\nbreak;\r\ndefault:\r\nprint_unknown_header_warning(0, header);\r\nr = false;\r\nbreak;\r\n}\r\nwritel(MBOX_BIT(0), (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\nreturn r;\r\n}\r\nstatic bool read_mailbox_1(void)\r\n{\r\nmb1_transfer.ack.header = readb(tcdm_base + PRCM_MBOX_HEADER_REQ_MB1);\r\nmb1_transfer.ack.arm_opp = readb(tcdm_base +\r\nPRCM_ACK_MB1_CURRENT_ARM_OPP);\r\nmb1_transfer.ack.ape_opp = readb(tcdm_base +\r\nPRCM_ACK_MB1_CURRENT_APE_OPP);\r\nmb1_transfer.ack.ape_voltage_status = readb(tcdm_base +\r\nPRCM_ACK_MB1_APE_VOLTAGE_STATUS);\r\nwritel(MBOX_BIT(1), (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\ncomplete(&mb1_transfer.work);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_2(void)\r\n{\r\nmb2_transfer.ack.status = readb(tcdm_base + PRCM_ACK_MB2_DPS_STATUS);\r\nwritel(MBOX_BIT(2), (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\ncomplete(&mb2_transfer.work);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_3(void)\r\n{\r\nwritel(MBOX_BIT(3), (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_4(void)\r\n{\r\nu8 header;\r\nbool do_complete = true;\r\nheader = readb(tcdm_base + PRCM_MBOX_HEADER_REQ_MB4);\r\nswitch (header) {\r\ncase MB4H_MEM_ST:\r\ncase MB4H_HOTDOG:\r\ncase MB4H_HOTMON:\r\ncase MB4H_HOT_PERIOD:\r\nbreak;\r\ndefault:\r\nprint_unknown_header_warning(4, header);\r\ndo_complete = false;\r\nbreak;\r\n}\r\nwritel(MBOX_BIT(4), (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\nif (do_complete)\r\ncomplete(&mb4_transfer.work);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_5(void)\r\n{\r\nmb5_transfer.ack.status = readb(tcdm_base + PRCM_ACK_MB5_I2C_STATUS);\r\nmb5_transfer.ack.value = readb(tcdm_base + PRCM_ACK_MB5_I2C_VAL);\r\nwritel(MBOX_BIT(5), (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\ncomplete(&mb5_transfer.work);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_6(void)\r\n{\r\nwritel(MBOX_BIT(6), (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_7(void)\r\n{\r\nwritel(MBOX_BIT(7), (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\nreturn false;\r\n}\r\nstatic irqreturn_t prcmu_irq_handler(int irq, void *data)\r\n{\r\nu32 bits;\r\nu8 n;\r\nirqreturn_t r;\r\nbits = (readl(_PRCMU_BASE + PRCM_ARM_IT1_VAL) & ALL_MBOX_BITS);\r\nif (unlikely(!bits))\r\nreturn IRQ_NONE;\r\nr = IRQ_HANDLED;\r\nfor (n = 0; bits; n++) {\r\nif (bits & MBOX_BIT(n)) {\r\nbits -= MBOX_BIT(n);\r\nif (read_mailbox[n]())\r\nr = IRQ_WAKE_THREAD;\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic irqreturn_t prcmu_irq_thread_fn(int irq, void *data)\r\n{\r\nack_dbb_wakeup();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void prcmu_mask_work(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nconfig_wakeups();\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\n}\r\nstatic void prcmu_irq_mask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.dbb_irqs_lock, flags);\r\nmb0_transfer.req.dbb_irqs &= ~prcmu_irq_bit[d->irq - IRQ_PRCMU_BASE];\r\nspin_unlock_irqrestore(&mb0_transfer.dbb_irqs_lock, flags);\r\nif (d->irq != IRQ_PRCMU_CA_SLEEP)\r\nschedule_work(&mb0_transfer.mask_work);\r\n}\r\nstatic void prcmu_irq_unmask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.dbb_irqs_lock, flags);\r\nmb0_transfer.req.dbb_irqs |= prcmu_irq_bit[d->irq - IRQ_PRCMU_BASE];\r\nspin_unlock_irqrestore(&mb0_transfer.dbb_irqs_lock, flags);\r\nif (d->irq != IRQ_PRCMU_CA_SLEEP)\r\nschedule_work(&mb0_transfer.mask_work);\r\n}\r\nstatic void noop(struct irq_data *d)\r\n{\r\n}\r\nvoid __init prcmu_early_init(void)\r\n{\r\nunsigned int i;\r\nif (cpu_is_u8500v1()) {\r\ntcdm_base = __io_address(U8500_PRCMU_TCDM_BASE_V1);\r\n} else if (cpu_is_u8500v2()) {\r\nvoid *tcpm_base = ioremap_nocache(U8500_PRCMU_TCPM_BASE, SZ_4K);\r\nif (tcpm_base != NULL) {\r\nint version;\r\nversion = readl(tcpm_base + PRCMU_FW_VERSION_OFFSET);\r\nprcmu_version.project_number = version & 0xFF;\r\nprcmu_version.api_version = (version >> 8) & 0xFF;\r\nprcmu_version.func_version = (version >> 16) & 0xFF;\r\nprcmu_version.errata = (version >> 24) & 0xFF;\r\npr_info("PRCMU firmware version %d.%d.%d\n",\r\n(version >> 8) & 0xFF, (version >> 16) & 0xFF,\r\n(version >> 24) & 0xFF);\r\niounmap(tcpm_base);\r\n}\r\ntcdm_base = __io_address(U8500_PRCMU_TCDM_BASE);\r\n} else {\r\npr_err("prcmu: Unsupported chip version\n");\r\nBUG();\r\n}\r\nspin_lock_init(&mb0_transfer.lock);\r\nspin_lock_init(&mb0_transfer.dbb_irqs_lock);\r\nmutex_init(&mb0_transfer.ac_wake_lock);\r\ninit_completion(&mb0_transfer.ac_wake_work);\r\nmutex_init(&mb1_transfer.lock);\r\ninit_completion(&mb1_transfer.work);\r\nmutex_init(&mb2_transfer.lock);\r\ninit_completion(&mb2_transfer.work);\r\nspin_lock_init(&mb2_transfer.auto_pm_lock);\r\nspin_lock_init(&mb3_transfer.lock);\r\nmutex_init(&mb3_transfer.sysclk_lock);\r\ninit_completion(&mb3_transfer.sysclk_work);\r\nmutex_init(&mb4_transfer.lock);\r\ninit_completion(&mb4_transfer.work);\r\nmutex_init(&mb5_transfer.lock);\r\ninit_completion(&mb5_transfer.work);\r\nINIT_WORK(&mb0_transfer.mask_work, prcmu_mask_work);\r\nfor (i = 0; i < NUM_PRCMU_WAKEUPS; i++) {\r\nunsigned int irq;\r\nirq = IRQ_PRCMU_BASE + i;\r\nirq_set_chip_and_handler(irq, &prcmu_irq_chip,\r\nhandle_simple_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\n}\r\n}\r\nstatic int __init db8500_prcmu_probe(struct platform_device *pdev)\r\n{\r\nint err = 0;\r\nif (ux500_is_svp())\r\nreturn -ENODEV;\r\nwritel(ALL_MBOX_BITS, (_PRCMU_BASE + PRCM_ARM_IT1_CLR));\r\nerr = request_threaded_irq(IRQ_DB8500_PRCMU1, prcmu_irq_handler,\r\nprcmu_irq_thread_fn, IRQF_NO_SUSPEND, "prcmu", NULL);\r\nif (err < 0) {\r\npr_err("prcmu: Failed to allocate IRQ_DB8500_PRCMU1.\n");\r\nerr = -EBUSY;\r\ngoto no_irq_return;\r\n}\r\nif (cpu_is_u8500v20_or_later())\r\nprcmu_config_esram0_deep_sleep(ESRAM0_DEEP_SLEEP_STATE_RET);\r\nerr = mfd_add_devices(&pdev->dev, 0, db8500_prcmu_devs,\r\nARRAY_SIZE(db8500_prcmu_devs), NULL,\r\n0);\r\nif (err)\r\npr_err("prcmu: Failed to add subdevices\n");\r\nelse\r\npr_info("DB8500 PRCMU initialized\n");\r\nno_irq_return:\r\nreturn err;\r\n}\r\nstatic int __init db8500_prcmu_init(void)\r\n{\r\nreturn platform_driver_probe(&db8500_prcmu_driver, db8500_prcmu_probe);\r\n}
