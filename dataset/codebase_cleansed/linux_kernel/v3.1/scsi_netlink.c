static void\r\nscsi_nl_rcv_msg(struct sk_buff *skb)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct scsi_nl_hdr *hdr;\r\nunsigned long flags;\r\nu32 rlen;\r\nint err, tport;\r\nwhile (skb->len >= NLMSG_SPACE(0)) {\r\nerr = 0;\r\nnlh = nlmsg_hdr(skb);\r\nif ((nlh->nlmsg_len < (sizeof(*nlh) + sizeof(*hdr))) ||\r\n(skb->len < nlh->nlmsg_len)) {\r\nprintk(KERN_WARNING "%s: discarding partial skb\n",\r\n__func__);\r\nreturn;\r\n}\r\nrlen = NLMSG_ALIGN(nlh->nlmsg_len);\r\nif (rlen > skb->len)\r\nrlen = skb->len;\r\nif (nlh->nlmsg_type != SCSI_TRANSPORT_MSG) {\r\nerr = -EBADMSG;\r\ngoto next_msg;\r\n}\r\nhdr = NLMSG_DATA(nlh);\r\nif ((hdr->version != SCSI_NL_VERSION) ||\r\n(hdr->magic != SCSI_NL_MAGIC)) {\r\nerr = -EPROTOTYPE;\r\ngoto next_msg;\r\n}\r\nif (security_netlink_recv(skb, CAP_SYS_ADMIN)) {\r\nerr = -EPERM;\r\ngoto next_msg;\r\n}\r\nif (nlh->nlmsg_len < (sizeof(*nlh) + hdr->msglen)) {\r\nprintk(KERN_WARNING "%s: discarding partial message\n",\r\n__func__);\r\ngoto next_msg;\r\n}\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\ntport = hdr->transport;\r\nif ((tport < SCSI_NL_MAX_TRANSPORTS) &&\r\n!(transports[tport].flags & HANDLER_DELETING) &&\r\n(transports[tport].msg_handler)) {\r\ntransports[tport].refcnt++;\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nerr = transports[tport].msg_handler(skb);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\ntransports[tport].refcnt--;\r\n} else\r\nerr = -ENOENT;\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nnext_msg:\r\nif ((err) || (nlh->nlmsg_flags & NLM_F_ACK))\r\nnetlink_ack(skb, nlh, err);\r\nskb_pull(skb, rlen);\r\n}\r\n}\r\nstatic int\r\nscsi_nl_rcv_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nstruct netlink_notify *n = ptr;\r\nstruct scsi_nl_drvr *driver;\r\nunsigned long flags;\r\nint tport;\r\nif (n->protocol != NETLINK_SCSITRANSPORT)\r\nreturn NOTIFY_DONE;\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\nscsi_nl_state |= STATE_EHANDLER_BSY;\r\nfor (tport = 0; tport < SCSI_NL_MAX_TRANSPORTS; tport++) {\r\nif (!(transports[tport].flags & HANDLER_DELETING) &&\r\n(transports[tport].event_handler)) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\ntransports[tport].event_handler(this, event, ptr);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\n}\r\n}\r\nlist_for_each_entry(driver, &scsi_nl_drivers, next) {\r\nif (!(driver->flags & HANDLER_DELETING) &&\r\n(driver->devt_handler)) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\ndriver->devt_handler(this, event, ptr);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\n}\r\n}\r\nscsi_nl_state &= ~STATE_EHANDLER_BSY;\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nscsi_generic_msg_handler(struct sk_buff *skb)\r\n{\r\nstruct nlmsghdr *nlh = nlmsg_hdr(skb);\r\nstruct scsi_nl_hdr *snlh = NLMSG_DATA(nlh);\r\nstruct scsi_nl_drvr *driver;\r\nstruct Scsi_Host *shost;\r\nunsigned long flags;\r\nint err = 0, match, pid;\r\npid = NETLINK_CREDS(skb)->pid;\r\nswitch (snlh->msgtype) {\r\ncase SCSI_NL_SHOST_VENDOR:\r\n{\r\nstruct scsi_nl_host_vendor_msg *msg = NLMSG_DATA(nlh);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\nmatch = 0;\r\nlist_for_each_entry(driver, &scsi_nl_drivers, next) {\r\nif (driver->vendor_id == msg->vendor_id) {\r\nmatch = 1;\r\nbreak;\r\n}\r\n}\r\nif ((!match) || (!driver->dmsg_handler)) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nerr = -ESRCH;\r\ngoto rcv_exit;\r\n}\r\nif (driver->flags & HANDLER_DELETING) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nerr = -ESHUTDOWN;\r\ngoto rcv_exit;\r\n}\r\ndriver->refcnt++;\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nshost = scsi_host_lookup(msg->host_no);\r\nif (!shost) {\r\nerr = -ENODEV;\r\ngoto driver_exit;\r\n}\r\nif (shost->hostt != driver->hostt) {\r\nerr = -EINVAL;\r\ngoto vendormsg_put;\r\n}\r\nerr = driver->dmsg_handler(shost, (void *)&msg[1],\r\nmsg->vmsg_datalen, pid);\r\nvendormsg_put:\r\nscsi_host_put(shost);\r\ndriver_exit:\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\ndriver->refcnt--;\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EBADR;\r\nbreak;\r\n}\r\nrcv_exit:\r\nif (err)\r\nprintk(KERN_WARNING "%s: Msgtype %d failed - err %d\n",\r\n__func__, snlh->msgtype, err);\r\nreturn err;\r\n}\r\nint\r\nscsi_nl_add_transport(u8 tport,\r\nint (*msg_handler)(struct sk_buff *),\r\nvoid (*event_handler)(struct notifier_block *, unsigned long, void *))\r\n{\r\nunsigned long flags;\r\nint err = 0;\r\nif (tport >= SCSI_NL_MAX_TRANSPORTS)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\nif (scsi_nl_state & STATE_EHANDLER_BSY) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nmsleep(1);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\n}\r\nif (transports[tport].msg_handler || transports[tport].event_handler) {\r\nerr = -EALREADY;\r\ngoto register_out;\r\n}\r\ntransports[tport].msg_handler = msg_handler;\r\ntransports[tport].event_handler = event_handler;\r\ntransports[tport].flags = 0;\r\ntransports[tport].refcnt = 0;\r\nregister_out:\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nreturn err;\r\n}\r\nvoid\r\nscsi_nl_remove_transport(u8 tport)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\nif (scsi_nl_state & STATE_EHANDLER_BSY) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nmsleep(1);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\n}\r\nif (tport < SCSI_NL_MAX_TRANSPORTS) {\r\ntransports[tport].flags |= HANDLER_DELETING;\r\nwhile (transports[tport].refcnt != 0) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nschedule_timeout_uninterruptible(HZ/4);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\n}\r\ntransports[tport].msg_handler = NULL;\r\ntransports[tport].event_handler = NULL;\r\ntransports[tport].flags = 0;\r\n}\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nreturn;\r\n}\r\nint\r\nscsi_nl_add_driver(u64 vendor_id, struct scsi_host_template *hostt,\r\nint (*nlmsg_handler)(struct Scsi_Host *shost, void *payload,\r\nu32 len, u32 pid),\r\nvoid (*nlevt_handler)(struct notifier_block *nb,\r\nunsigned long event, void *notify_ptr))\r\n{\r\nstruct scsi_nl_drvr *driver;\r\nunsigned long flags;\r\ndriver = kzalloc(sizeof(*driver), GFP_KERNEL);\r\nif (unlikely(!driver)) {\r\nprintk(KERN_ERR "%s: allocation failure\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ndriver->dmsg_handler = nlmsg_handler;\r\ndriver->devt_handler = nlevt_handler;\r\ndriver->hostt = hostt;\r\ndriver->vendor_id = vendor_id;\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\nif (scsi_nl_state & STATE_EHANDLER_BSY) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nmsleep(1);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\n}\r\nlist_add_tail(&driver->next, &scsi_nl_drivers);\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nreturn 0;\r\n}\r\nvoid\r\nscsi_nl_remove_driver(u64 vendor_id)\r\n{\r\nstruct scsi_nl_drvr *driver;\r\nunsigned long flags;\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\nif (scsi_nl_state & STATE_EHANDLER_BSY) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nmsleep(1);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\n}\r\nlist_for_each_entry(driver, &scsi_nl_drivers, next) {\r\nif (driver->vendor_id == vendor_id) {\r\ndriver->flags |= HANDLER_DELETING;\r\nwhile (driver->refcnt != 0) {\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nschedule_timeout_uninterruptible(HZ/4);\r\nspin_lock_irqsave(&scsi_nl_lock, flags);\r\n}\r\nlist_del(&driver->next);\r\nkfree(driver);\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nreturn;\r\n}\r\n}\r\nspin_unlock_irqrestore(&scsi_nl_lock, flags);\r\nprintk(KERN_ERR "%s: removal of driver failed - vendor_id 0x%llx\n",\r\n__func__, (unsigned long long)vendor_id);\r\nreturn;\r\n}\r\nvoid\r\nscsi_netlink_init(void)\r\n{\r\nint error;\r\nINIT_LIST_HEAD(&scsi_nl_drivers);\r\nerror = netlink_register_notifier(&scsi_netlink_notifier);\r\nif (error) {\r\nprintk(KERN_ERR "%s: register of event handler failed - %d\n",\r\n__func__, error);\r\nreturn;\r\n}\r\nscsi_nl_sock = netlink_kernel_create(&init_net, NETLINK_SCSITRANSPORT,\r\nSCSI_NL_GRP_CNT, scsi_nl_rcv_msg, NULL,\r\nTHIS_MODULE);\r\nif (!scsi_nl_sock) {\r\nprintk(KERN_ERR "%s: register of receive handler failed\n",\r\n__func__);\r\nnetlink_unregister_notifier(&scsi_netlink_notifier);\r\nreturn;\r\n}\r\nerror = scsi_nl_add_transport(SCSI_NL_TRANSPORT,\r\nscsi_generic_msg_handler, NULL);\r\nif (error)\r\nprintk(KERN_ERR "%s: register of GENERIC transport handler"\r\n" failed - %d\n", __func__, error);\r\nreturn;\r\n}\r\nvoid\r\nscsi_netlink_exit(void)\r\n{\r\nscsi_nl_remove_transport(SCSI_NL_TRANSPORT);\r\nif (scsi_nl_sock) {\r\nnetlink_kernel_release(scsi_nl_sock);\r\nnetlink_unregister_notifier(&scsi_netlink_notifier);\r\n}\r\nreturn;\r\n}\r\nvoid\r\nscsi_nl_send_transport_msg(u32 pid, struct scsi_nl_hdr *hdr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nconst char *fn;\r\nchar *datab;\r\nu32 len, skblen;\r\nint err;\r\nif (!scsi_nl_sock) {\r\nerr = -ENOENT;\r\nfn = "netlink socket";\r\ngoto msg_fail;\r\n}\r\nlen = NLMSG_SPACE(hdr->msglen);\r\nskblen = NLMSG_SPACE(len);\r\nskb = alloc_skb(skblen, GFP_KERNEL);\r\nif (!skb) {\r\nerr = -ENOBUFS;\r\nfn = "alloc_skb";\r\ngoto msg_fail;\r\n}\r\nnlh = nlmsg_put(skb, pid, 0, SCSI_TRANSPORT_MSG, len - sizeof(*nlh), 0);\r\nif (!nlh) {\r\nerr = -ENOBUFS;\r\nfn = "nlmsg_put";\r\ngoto msg_fail_skb;\r\n}\r\ndatab = NLMSG_DATA(nlh);\r\nmemcpy(datab, hdr, hdr->msglen);\r\nerr = nlmsg_unicast(scsi_nl_sock, skb, pid);\r\nif (err < 0) {\r\nfn = "nlmsg_unicast";\r\ngoto msg_fail;\r\n}\r\nreturn;\r\nmsg_fail_skb:\r\nkfree_skb(skb);\r\nmsg_fail:\r\nprintk(KERN_WARNING\r\n"%s: Dropped Message : pid %d Transport %d, msgtype x%x, "\r\n"msglen %d: %s : err %d\n",\r\n__func__, pid, hdr->transport, hdr->msgtype, hdr->msglen,\r\nfn, err);\r\nreturn;\r\n}\r\nint\r\nscsi_nl_send_vendor_msg(u32 pid, unsigned short host_no, u64 vendor_id,\r\nchar *data_buf, u32 data_len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct scsi_nl_host_vendor_msg *msg;\r\nu32 len, skblen;\r\nint err;\r\nif (!scsi_nl_sock) {\r\nerr = -ENOENT;\r\ngoto send_vendor_fail;\r\n}\r\nlen = SCSI_NL_MSGALIGN(sizeof(*msg) + data_len);\r\nskblen = NLMSG_SPACE(len);\r\nskb = alloc_skb(skblen, GFP_KERNEL);\r\nif (!skb) {\r\nerr = -ENOBUFS;\r\ngoto send_vendor_fail;\r\n}\r\nnlh = nlmsg_put(skb, 0, 0, SCSI_TRANSPORT_MSG,\r\nskblen - sizeof(*nlh), 0);\r\nif (!nlh) {\r\nerr = -ENOBUFS;\r\ngoto send_vendor_fail_skb;\r\n}\r\nmsg = NLMSG_DATA(nlh);\r\nINIT_SCSI_NL_HDR(&msg->snlh, SCSI_NL_TRANSPORT,\r\nSCSI_NL_SHOST_VENDOR, len);\r\nmsg->vendor_id = vendor_id;\r\nmsg->host_no = host_no;\r\nmsg->vmsg_datalen = data_len;\r\nmemcpy(&msg[1], data_buf, data_len);\r\nerr = nlmsg_unicast(scsi_nl_sock, skb, pid);\r\nif (err)\r\ngoto send_vendor_fail;\r\nreturn 0;\r\nsend_vendor_fail_skb:\r\nkfree_skb(skb);\r\nsend_vendor_fail:\r\nprintk(KERN_WARNING\r\n"%s: Dropped SCSI Msg : host %d vendor_unique - err %d\n",\r\n__func__, host_no, err);\r\nreturn err;\r\n}
