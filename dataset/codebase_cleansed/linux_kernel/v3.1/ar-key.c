static int rxrpc_vet_description_s(const char *desc)\r\n{\r\nunsigned long num;\r\nchar *p;\r\nnum = simple_strtoul(desc, &p, 10);\r\nif (*p != ':' || num > 65535)\r\nreturn -EINVAL;\r\nnum = simple_strtoul(p + 1, &p, 10);\r\nif (*p || num < 1 || num > 255)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rxrpc_instantiate_xdr_rxkad(struct key *key, const __be32 *xdr,\r\nunsigned toklen)\r\n{\r\nstruct rxrpc_key_token *token, **pptoken;\r\nsize_t plen;\r\nu32 tktlen;\r\nint ret;\r\n_enter(",{%x,%x,%x,%x},%u",\r\nntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\r\ntoklen);\r\nif (toklen <= 8 * 4)\r\nreturn -EKEYREJECTED;\r\ntktlen = ntohl(xdr[7]);\r\n_debug("tktlen: %x", tktlen);\r\nif (tktlen > AFSTOKEN_RK_TIX_MAX)\r\nreturn -EKEYREJECTED;\r\nif (8 * 4 + tktlen != toklen)\r\nreturn -EKEYREJECTED;\r\nplen = sizeof(*token) + sizeof(*token->kad) + tktlen;\r\nret = key_payload_reserve(key, key->datalen + plen);\r\nif (ret < 0)\r\nreturn ret;\r\nplen -= sizeof(*token);\r\ntoken = kzalloc(sizeof(*token), GFP_KERNEL);\r\nif (!token)\r\nreturn -ENOMEM;\r\ntoken->kad = kzalloc(plen, GFP_KERNEL);\r\nif (!token->kad) {\r\nkfree(token);\r\nreturn -ENOMEM;\r\n}\r\ntoken->security_index = RXRPC_SECURITY_RXKAD;\r\ntoken->kad->ticket_len = tktlen;\r\ntoken->kad->vice_id = ntohl(xdr[0]);\r\ntoken->kad->kvno = ntohl(xdr[1]);\r\ntoken->kad->start = ntohl(xdr[4]);\r\ntoken->kad->expiry = ntohl(xdr[5]);\r\ntoken->kad->primary_flag = ntohl(xdr[6]);\r\nmemcpy(&token->kad->session_key, &xdr[2], 8);\r\nmemcpy(&token->kad->ticket, &xdr[8], tktlen);\r\n_debug("SCIX: %u", token->security_index);\r\n_debug("TLEN: %u", token->kad->ticket_len);\r\n_debug("EXPY: %x", token->kad->expiry);\r\n_debug("KVNO: %u", token->kad->kvno);\r\n_debug("PRIM: %u", token->kad->primary_flag);\r\n_debug("SKEY: %02x%02x%02x%02x%02x%02x%02x%02x",\r\ntoken->kad->session_key[0], token->kad->session_key[1],\r\ntoken->kad->session_key[2], token->kad->session_key[3],\r\ntoken->kad->session_key[4], token->kad->session_key[5],\r\ntoken->kad->session_key[6], token->kad->session_key[7]);\r\nif (token->kad->ticket_len >= 8)\r\n_debug("TCKT: %02x%02x%02x%02x%02x%02x%02x%02x",\r\ntoken->kad->ticket[0], token->kad->ticket[1],\r\ntoken->kad->ticket[2], token->kad->ticket[3],\r\ntoken->kad->ticket[4], token->kad->ticket[5],\r\ntoken->kad->ticket[6], token->kad->ticket[7]);\r\nkey->type_data.x[0]++;\r\nfor (pptoken = (struct rxrpc_key_token **)&key->payload.data;\r\n*pptoken;\r\npptoken = &(*pptoken)->next)\r\ncontinue;\r\n*pptoken = token;\r\nif (token->kad->expiry < key->expiry)\r\nkey->expiry = token->kad->expiry;\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void rxrpc_free_krb5_principal(struct krb5_principal *princ)\r\n{\r\nint loop;\r\nif (princ->name_parts) {\r\nfor (loop = princ->n_name_parts - 1; loop >= 0; loop--)\r\nkfree(princ->name_parts[loop]);\r\nkfree(princ->name_parts);\r\n}\r\nkfree(princ->realm);\r\n}\r\nstatic void rxrpc_free_krb5_tagged(struct krb5_tagged_data *td)\r\n{\r\nkfree(td->data);\r\n}\r\nstatic void rxrpc_rxk5_free(struct rxk5_key *rxk5)\r\n{\r\nint loop;\r\nrxrpc_free_krb5_principal(&rxk5->client);\r\nrxrpc_free_krb5_principal(&rxk5->server);\r\nrxrpc_free_krb5_tagged(&rxk5->session);\r\nif (rxk5->addresses) {\r\nfor (loop = rxk5->n_addresses - 1; loop >= 0; loop--)\r\nrxrpc_free_krb5_tagged(&rxk5->addresses[loop]);\r\nkfree(rxk5->addresses);\r\n}\r\nif (rxk5->authdata) {\r\nfor (loop = rxk5->n_authdata - 1; loop >= 0; loop--)\r\nrxrpc_free_krb5_tagged(&rxk5->authdata[loop]);\r\nkfree(rxk5->authdata);\r\n}\r\nkfree(rxk5->ticket);\r\nkfree(rxk5->ticket2);\r\nkfree(rxk5);\r\n}\r\nstatic int rxrpc_krb5_decode_principal(struct krb5_principal *princ,\r\nconst __be32 **_xdr,\r\nunsigned *_toklen)\r\n{\r\nconst __be32 *xdr = *_xdr;\r\nunsigned toklen = *_toklen, n_parts, loop, tmp;\r\nif (toklen <= 12)\r\nreturn -EINVAL;\r\n_enter(",{%x,%x,%x},%u",\r\nntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), toklen);\r\nn_parts = ntohl(*xdr++);\r\ntoklen -= 4;\r\nif (n_parts <= 0 || n_parts > AFSTOKEN_K5_COMPONENTS_MAX)\r\nreturn -EINVAL;\r\nprinc->n_name_parts = n_parts;\r\nif (toklen <= (n_parts + 1) * 4)\r\nreturn -EINVAL;\r\nprinc->name_parts = kcalloc(sizeof(char *), n_parts, GFP_KERNEL);\r\nif (!princ->name_parts)\r\nreturn -ENOMEM;\r\nfor (loop = 0; loop < n_parts; loop++) {\r\nif (toklen < 4)\r\nreturn -EINVAL;\r\ntmp = ntohl(*xdr++);\r\ntoklen -= 4;\r\nif (tmp <= 0 || tmp > AFSTOKEN_STRING_MAX)\r\nreturn -EINVAL;\r\nif (tmp > toklen)\r\nreturn -EINVAL;\r\nprinc->name_parts[loop] = kmalloc(tmp + 1, GFP_KERNEL);\r\nif (!princ->name_parts[loop])\r\nreturn -ENOMEM;\r\nmemcpy(princ->name_parts[loop], xdr, tmp);\r\nprinc->name_parts[loop][tmp] = 0;\r\ntmp = (tmp + 3) & ~3;\r\ntoklen -= tmp;\r\nxdr += tmp >> 2;\r\n}\r\nif (toklen < 4)\r\nreturn -EINVAL;\r\ntmp = ntohl(*xdr++);\r\ntoklen -= 4;\r\nif (tmp <= 0 || tmp > AFSTOKEN_K5_REALM_MAX)\r\nreturn -EINVAL;\r\nif (tmp > toklen)\r\nreturn -EINVAL;\r\nprinc->realm = kmalloc(tmp + 1, GFP_KERNEL);\r\nif (!princ->realm)\r\nreturn -ENOMEM;\r\nmemcpy(princ->realm, xdr, tmp);\r\nprinc->realm[tmp] = 0;\r\ntmp = (tmp + 3) & ~3;\r\ntoklen -= tmp;\r\nxdr += tmp >> 2;\r\n_debug("%s/...@%s", princ->name_parts[0], princ->realm);\r\n*_xdr = xdr;\r\n*_toklen = toklen;\r\n_leave(" = 0 [toklen=%u]", toklen);\r\nreturn 0;\r\n}\r\nstatic int rxrpc_krb5_decode_tagged_data(struct krb5_tagged_data *td,\r\nsize_t max_data_size,\r\nconst __be32 **_xdr,\r\nunsigned *_toklen)\r\n{\r\nconst __be32 *xdr = *_xdr;\r\nunsigned toklen = *_toklen, len;\r\nif (toklen <= 8)\r\nreturn -EINVAL;\r\n_enter(",%zu,{%x,%x},%u",\r\nmax_data_size, ntohl(xdr[0]), ntohl(xdr[1]), toklen);\r\ntd->tag = ntohl(*xdr++);\r\nlen = ntohl(*xdr++);\r\ntoklen -= 8;\r\nif (len > max_data_size)\r\nreturn -EINVAL;\r\ntd->data_len = len;\r\nif (len > 0) {\r\ntd->data = kmalloc(len, GFP_KERNEL);\r\nif (!td->data)\r\nreturn -ENOMEM;\r\nmemcpy(td->data, xdr, len);\r\nlen = (len + 3) & ~3;\r\ntoklen -= len;\r\nxdr += len >> 2;\r\n}\r\n_debug("tag %x len %x", td->tag, td->data_len);\r\n*_xdr = xdr;\r\n*_toklen = toklen;\r\n_leave(" = 0 [toklen=%u]", toklen);\r\nreturn 0;\r\n}\r\nstatic int rxrpc_krb5_decode_tagged_array(struct krb5_tagged_data **_td,\r\nu8 *_n_elem,\r\nu8 max_n_elem,\r\nsize_t max_elem_size,\r\nconst __be32 **_xdr,\r\nunsigned *_toklen)\r\n{\r\nstruct krb5_tagged_data *td;\r\nconst __be32 *xdr = *_xdr;\r\nunsigned toklen = *_toklen, n_elem, loop;\r\nint ret;\r\nif (toklen < 4)\r\nreturn -EINVAL;\r\n_enter(",,%u,%zu,{%x},%u",\r\nmax_n_elem, max_elem_size, ntohl(xdr[0]), toklen);\r\nn_elem = ntohl(*xdr++);\r\ntoklen -= 4;\r\nif (n_elem < 0 || n_elem > max_n_elem)\r\nreturn -EINVAL;\r\n*_n_elem = n_elem;\r\nif (n_elem > 0) {\r\nif (toklen <= (n_elem + 1) * 4)\r\nreturn -EINVAL;\r\n_debug("n_elem %d", n_elem);\r\ntd = kcalloc(sizeof(struct krb5_tagged_data), n_elem,\r\nGFP_KERNEL);\r\nif (!td)\r\nreturn -ENOMEM;\r\n*_td = td;\r\nfor (loop = 0; loop < n_elem; loop++) {\r\nret = rxrpc_krb5_decode_tagged_data(&td[loop],\r\nmax_elem_size,\r\n&xdr, &toklen);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\n*_xdr = xdr;\r\n*_toklen = toklen;\r\n_leave(" = 0 [toklen=%u]", toklen);\r\nreturn 0;\r\n}\r\nstatic int rxrpc_krb5_decode_ticket(u8 **_ticket, u16 *_tktlen,\r\nconst __be32 **_xdr, unsigned *_toklen)\r\n{\r\nconst __be32 *xdr = *_xdr;\r\nunsigned toklen = *_toklen, len;\r\nif (toklen <= 4)\r\nreturn -EINVAL;\r\n_enter(",{%x},%u", ntohl(xdr[0]), toklen);\r\nlen = ntohl(*xdr++);\r\ntoklen -= 4;\r\nif (len > AFSTOKEN_K5_TIX_MAX)\r\nreturn -EINVAL;\r\n*_tktlen = len;\r\n_debug("ticket len %u", len);\r\nif (len > 0) {\r\n*_ticket = kmalloc(len, GFP_KERNEL);\r\nif (!*_ticket)\r\nreturn -ENOMEM;\r\nmemcpy(*_ticket, xdr, len);\r\nlen = (len + 3) & ~3;\r\ntoklen -= len;\r\nxdr += len >> 2;\r\n}\r\n*_xdr = xdr;\r\n*_toklen = toklen;\r\n_leave(" = 0 [toklen=%u]", toklen);\r\nreturn 0;\r\n}\r\nstatic int rxrpc_instantiate_xdr_rxk5(struct key *key, const __be32 *xdr,\r\nunsigned toklen)\r\n{\r\nstruct rxrpc_key_token *token, **pptoken;\r\nstruct rxk5_key *rxk5;\r\nconst __be32 *end_xdr = xdr + (toklen >> 2);\r\nint ret;\r\n_enter(",{%x,%x,%x,%x},%u",\r\nntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\r\ntoklen);\r\nret = key_payload_reserve(key, key->datalen + toklen);\r\nif (ret < 0)\r\nreturn ret;\r\ntoken = kzalloc(sizeof(*token), GFP_KERNEL);\r\nif (!token)\r\nreturn -ENOMEM;\r\nrxk5 = kzalloc(sizeof(*rxk5), GFP_KERNEL);\r\nif (!rxk5) {\r\nkfree(token);\r\nreturn -ENOMEM;\r\n}\r\ntoken->security_index = RXRPC_SECURITY_RXK5;\r\ntoken->k5 = rxk5;\r\nret = rxrpc_krb5_decode_principal(&rxk5->client, &xdr, &toklen);\r\nif (ret < 0)\r\ngoto error;\r\nret = rxrpc_krb5_decode_principal(&rxk5->server, &xdr, &toklen);\r\nif (ret < 0)\r\ngoto error;\r\nret = rxrpc_krb5_decode_tagged_data(&rxk5->session, AFSTOKEN_DATA_MAX,\r\n&xdr, &toklen);\r\nif (ret < 0)\r\ngoto error;\r\nif (toklen < 4 * 8 + 2 * 4)\r\ngoto inval;\r\nrxk5->authtime = be64_to_cpup((const __be64 *) xdr);\r\nxdr += 2;\r\nrxk5->starttime = be64_to_cpup((const __be64 *) xdr);\r\nxdr += 2;\r\nrxk5->endtime = be64_to_cpup((const __be64 *) xdr);\r\nxdr += 2;\r\nrxk5->renew_till = be64_to_cpup((const __be64 *) xdr);\r\nxdr += 2;\r\nrxk5->is_skey = ntohl(*xdr++);\r\nrxk5->flags = ntohl(*xdr++);\r\ntoklen -= 4 * 8 + 2 * 4;\r\n_debug("times: a=%llx s=%llx e=%llx rt=%llx",\r\nrxk5->authtime, rxk5->starttime, rxk5->endtime,\r\nrxk5->renew_till);\r\n_debug("is_skey=%x flags=%x", rxk5->is_skey, rxk5->flags);\r\nret = rxrpc_krb5_decode_tagged_array(&rxk5->addresses,\r\n&rxk5->n_addresses,\r\nAFSTOKEN_K5_ADDRESSES_MAX,\r\nAFSTOKEN_DATA_MAX,\r\n&xdr, &toklen);\r\nif (ret < 0)\r\ngoto error;\r\nASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\r\nret = rxrpc_krb5_decode_ticket(&rxk5->ticket, &rxk5->ticket_len,\r\n&xdr, &toklen);\r\nif (ret < 0)\r\ngoto error;\r\nret = rxrpc_krb5_decode_ticket(&rxk5->ticket2, &rxk5->ticket2_len,\r\n&xdr, &toklen);\r\nif (ret < 0)\r\ngoto error;\r\nASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\r\nret = rxrpc_krb5_decode_tagged_array(&rxk5->authdata,\r\n&rxk5->n_authdata,\r\nAFSTOKEN_K5_AUTHDATA_MAX,\r\nAFSTOKEN_BDATALN_MAX,\r\n&xdr, &toklen);\r\nif (ret < 0)\r\ngoto error;\r\nASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\r\nif (toklen != 0)\r\ngoto inval;\r\nfor (pptoken = (struct rxrpc_key_token **)&key->payload.data;\r\n*pptoken;\r\npptoken = &(*pptoken)->next)\r\ncontinue;\r\n*pptoken = token;\r\nif (token->kad->expiry < key->expiry)\r\nkey->expiry = token->kad->expiry;\r\n_leave(" = 0");\r\nreturn 0;\r\ninval:\r\nret = -EINVAL;\r\nerror:\r\nrxrpc_rxk5_free(rxk5);\r\nkfree(token);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_instantiate_xdr(struct key *key, const void *data, size_t datalen)\r\n{\r\nconst __be32 *xdr = data, *token;\r\nconst char *cp;\r\nunsigned len, tmp, loop, ntoken, toklen, sec_ix;\r\nint ret;\r\n_enter(",{%x,%x,%x,%x},%zu",\r\nntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\r\ndatalen);\r\nif (datalen > AFSTOKEN_LENGTH_MAX)\r\ngoto not_xdr;\r\nif (datalen & 3)\r\ngoto not_xdr;\r\nif (ntohl(*xdr++) != 0)\r\ngoto not_xdr;\r\ndatalen -= 4;\r\nlen = ntohl(*xdr++);\r\nif (len < 1 || len > AFSTOKEN_CELL_MAX)\r\ngoto not_xdr;\r\ndatalen -= 4;\r\ntmp = (len + 3) & ~3;\r\nif (tmp > datalen)\r\ngoto not_xdr;\r\ncp = (const char *) xdr;\r\nfor (loop = 0; loop < len; loop++)\r\nif (!isprint(cp[loop]))\r\ngoto not_xdr;\r\nif (len < tmp)\r\nfor (; loop < tmp; loop++)\r\nif (cp[loop])\r\ngoto not_xdr;\r\n_debug("cellname: [%u/%u] '%*.*s'",\r\nlen, tmp, len, len, (const char *) xdr);\r\ndatalen -= tmp;\r\nxdr += tmp >> 2;\r\nif (datalen < 12)\r\ngoto not_xdr;\r\nntoken = ntohl(*xdr++);\r\ndatalen -= 4;\r\n_debug("ntoken: %x", ntoken);\r\nif (ntoken < 1 || ntoken > AFSTOKEN_MAX)\r\ngoto not_xdr;\r\ntoken = xdr;\r\nloop = ntoken;\r\ndo {\r\nif (datalen < 8)\r\ngoto not_xdr;\r\ntoklen = ntohl(*xdr++);\r\nsec_ix = ntohl(*xdr);\r\ndatalen -= 4;\r\n_debug("token: [%x/%zx] %x", toklen, datalen, sec_ix);\r\nif (toklen < 20 || toklen > datalen)\r\ngoto not_xdr;\r\ndatalen -= (toklen + 3) & ~3;\r\nxdr += (toklen + 3) >> 2;\r\n} while (--loop > 0);\r\n_debug("remainder: %zu", datalen);\r\nif (datalen != 0)\r\ngoto not_xdr;\r\ndo {\r\nxdr = token;\r\ntoklen = ntohl(*xdr++);\r\ntoken = xdr + ((toklen + 3) >> 2);\r\nsec_ix = ntohl(*xdr++);\r\ntoklen -= 4;\r\n_debug("TOKEN type=%u [%p-%p]", sec_ix, xdr, token);\r\nswitch (sec_ix) {\r\ncase RXRPC_SECURITY_RXKAD:\r\nret = rxrpc_instantiate_xdr_rxkad(key, xdr, toklen);\r\nif (ret != 0)\r\ngoto error;\r\nbreak;\r\ncase RXRPC_SECURITY_RXK5:\r\nret = rxrpc_instantiate_xdr_rxk5(key, xdr, toklen);\r\nif (ret != 0)\r\ngoto error;\r\nbreak;\r\ndefault:\r\nret = -EPROTONOSUPPORT;\r\ngoto error;\r\n}\r\n} while (--ntoken > 0);\r\n_leave(" = 0");\r\nreturn 0;\r\nnot_xdr:\r\n_leave(" = -EPROTO");\r\nreturn -EPROTO;\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_instantiate(struct key *key, const void *data, size_t datalen)\r\n{\r\nconst struct rxrpc_key_data_v1 *v1;\r\nstruct rxrpc_key_token *token, **pp;\r\nsize_t plen;\r\nu32 kver;\r\nint ret;\r\n_enter("{%x},,%zu", key_serial(key), datalen);\r\nif (!data && datalen == 0)\r\nreturn 0;\r\nif (datalen > 7 * 4) {\r\nret = rxrpc_instantiate_xdr(key, data, datalen);\r\nif (ret != -EPROTO)\r\nreturn ret;\r\n}\r\nret = -EINVAL;\r\nif (datalen <= 4 || !data)\r\ngoto error;\r\nmemcpy(&kver, data, sizeof(kver));\r\ndata += sizeof(kver);\r\ndatalen -= sizeof(kver);\r\n_debug("KEY I/F VERSION: %u", kver);\r\nret = -EKEYREJECTED;\r\nif (kver != 1)\r\ngoto error;\r\nret = -EINVAL;\r\nif (datalen < sizeof(*v1))\r\ngoto error;\r\nv1 = data;\r\nif (datalen != sizeof(*v1) + v1->ticket_length)\r\ngoto error;\r\n_debug("SCIX: %u", v1->security_index);\r\n_debug("TLEN: %u", v1->ticket_length);\r\n_debug("EXPY: %x", v1->expiry);\r\n_debug("KVNO: %u", v1->kvno);\r\n_debug("SKEY: %02x%02x%02x%02x%02x%02x%02x%02x",\r\nv1->session_key[0], v1->session_key[1],\r\nv1->session_key[2], v1->session_key[3],\r\nv1->session_key[4], v1->session_key[5],\r\nv1->session_key[6], v1->session_key[7]);\r\nif (v1->ticket_length >= 8)\r\n_debug("TCKT: %02x%02x%02x%02x%02x%02x%02x%02x",\r\nv1->ticket[0], v1->ticket[1],\r\nv1->ticket[2], v1->ticket[3],\r\nv1->ticket[4], v1->ticket[5],\r\nv1->ticket[6], v1->ticket[7]);\r\nret = -EPROTONOSUPPORT;\r\nif (v1->security_index != RXRPC_SECURITY_RXKAD)\r\ngoto error;\r\nplen = sizeof(*token->kad) + v1->ticket_length;\r\nret = key_payload_reserve(key, plen + sizeof(*token));\r\nif (ret < 0)\r\ngoto error;\r\nret = -ENOMEM;\r\ntoken = kzalloc(sizeof(*token), GFP_KERNEL);\r\nif (!token)\r\ngoto error;\r\ntoken->kad = kzalloc(plen, GFP_KERNEL);\r\nif (!token->kad)\r\ngoto error_free;\r\ntoken->security_index = RXRPC_SECURITY_RXKAD;\r\ntoken->kad->ticket_len = v1->ticket_length;\r\ntoken->kad->expiry = v1->expiry;\r\ntoken->kad->kvno = v1->kvno;\r\nmemcpy(&token->kad->session_key, &v1->session_key, 8);\r\nmemcpy(&token->kad->ticket, v1->ticket, v1->ticket_length);\r\nkey->type_data.x[0]++;\r\npp = (struct rxrpc_key_token **)&key->payload.data;\r\nwhile (*pp)\r\npp = &(*pp)->next;\r\n*pp = token;\r\nif (token->kad->expiry < key->expiry)\r\nkey->expiry = token->kad->expiry;\r\ntoken = NULL;\r\nret = 0;\r\nerror_free:\r\nkfree(token);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int rxrpc_instantiate_s(struct key *key, const void *data,\r\nsize_t datalen)\r\n{\r\nstruct crypto_blkcipher *ci;\r\n_enter("{%x},,%zu", key_serial(key), datalen);\r\nif (datalen != 8)\r\nreturn -EINVAL;\r\nmemcpy(&key->type_data, data, 8);\r\nci = crypto_alloc_blkcipher("pcbc(des)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(ci)) {\r\n_leave(" = %ld", PTR_ERR(ci));\r\nreturn PTR_ERR(ci);\r\n}\r\nif (crypto_blkcipher_setkey(ci, data, 8) < 0)\r\nBUG();\r\nkey->payload.data = ci;\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void rxrpc_destroy(struct key *key)\r\n{\r\nstruct rxrpc_key_token *token;\r\nwhile ((token = key->payload.data)) {\r\nkey->payload.data = token->next;\r\nswitch (token->security_index) {\r\ncase RXRPC_SECURITY_RXKAD:\r\nkfree(token->kad);\r\nbreak;\r\ncase RXRPC_SECURITY_RXK5:\r\nif (token->k5)\r\nrxrpc_rxk5_free(token->k5);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unknown token type %x on rxrpc key\n",\r\ntoken->security_index);\r\nBUG();\r\n}\r\nkfree(token);\r\n}\r\n}\r\nstatic void rxrpc_destroy_s(struct key *key)\r\n{\r\nif (key->payload.data) {\r\ncrypto_free_blkcipher(key->payload.data);\r\nkey->payload.data = NULL;\r\n}\r\n}\r\nstatic void rxrpc_describe(const struct key *key, struct seq_file *m)\r\n{\r\nseq_puts(m, key->description);\r\n}\r\nint rxrpc_request_key(struct rxrpc_sock *rx, char __user *optval, int optlen)\r\n{\r\nstruct key *key;\r\nchar *description;\r\n_enter("");\r\nif (optlen <= 0 || optlen > PAGE_SIZE - 1)\r\nreturn -EINVAL;\r\ndescription = kmalloc(optlen + 1, GFP_KERNEL);\r\nif (!description)\r\nreturn -ENOMEM;\r\nif (copy_from_user(description, optval, optlen)) {\r\nkfree(description);\r\nreturn -EFAULT;\r\n}\r\ndescription[optlen] = 0;\r\nkey = request_key(&key_type_rxrpc, description, NULL);\r\nif (IS_ERR(key)) {\r\nkfree(description);\r\n_leave(" = %ld", PTR_ERR(key));\r\nreturn PTR_ERR(key);\r\n}\r\nrx->key = key;\r\nkfree(description);\r\n_leave(" = 0 [key %x]", key->serial);\r\nreturn 0;\r\n}\r\nint rxrpc_server_keyring(struct rxrpc_sock *rx, char __user *optval,\r\nint optlen)\r\n{\r\nstruct key *key;\r\nchar *description;\r\n_enter("");\r\nif (optlen <= 0 || optlen > PAGE_SIZE - 1)\r\nreturn -EINVAL;\r\ndescription = kmalloc(optlen + 1, GFP_KERNEL);\r\nif (!description)\r\nreturn -ENOMEM;\r\nif (copy_from_user(description, optval, optlen)) {\r\nkfree(description);\r\nreturn -EFAULT;\r\n}\r\ndescription[optlen] = 0;\r\nkey = request_key(&key_type_keyring, description, NULL);\r\nif (IS_ERR(key)) {\r\nkfree(description);\r\n_leave(" = %ld", PTR_ERR(key));\r\nreturn PTR_ERR(key);\r\n}\r\nrx->securities = key;\r\nkfree(description);\r\n_leave(" = 0 [key %x]", key->serial);\r\nreturn 0;\r\n}\r\nint rxrpc_get_server_data_key(struct rxrpc_connection *conn,\r\nconst void *session_key,\r\ntime_t expiry,\r\nu32 kvno)\r\n{\r\nconst struct cred *cred = current_cred();\r\nstruct key *key;\r\nint ret;\r\nstruct {\r\nu32 kver;\r\nstruct rxrpc_key_data_v1 v1;\r\n} data;\r\n_enter("");\r\nkey = key_alloc(&key_type_rxrpc, "x", 0, 0, cred, 0,\r\nKEY_ALLOC_NOT_IN_QUOTA);\r\nif (IS_ERR(key)) {\r\n_leave(" = -ENOMEM [alloc %ld]", PTR_ERR(key));\r\nreturn -ENOMEM;\r\n}\r\n_debug("key %d", key_serial(key));\r\ndata.kver = 1;\r\ndata.v1.security_index = RXRPC_SECURITY_RXKAD;\r\ndata.v1.ticket_length = 0;\r\ndata.v1.expiry = expiry;\r\ndata.v1.kvno = 0;\r\nmemcpy(&data.v1.session_key, session_key, sizeof(data.v1.session_key));\r\nret = key_instantiate_and_link(key, &data, sizeof(data), NULL, NULL);\r\nif (ret < 0)\r\ngoto error;\r\nconn->key = key;\r\n_leave(" = 0 [%d]", key_serial(key));\r\nreturn 0;\r\nerror:\r\nkey_revoke(key);\r\nkey_put(key);\r\n_leave(" = -ENOMEM [ins %d]", ret);\r\nreturn -ENOMEM;\r\n}\r\nstruct key *rxrpc_get_null_key(const char *keyname)\r\n{\r\nconst struct cred *cred = current_cred();\r\nstruct key *key;\r\nint ret;\r\nkey = key_alloc(&key_type_rxrpc, keyname, 0, 0, cred,\r\nKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA);\r\nif (IS_ERR(key))\r\nreturn key;\r\nret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\r\nif (ret < 0) {\r\nkey_revoke(key);\r\nkey_put(key);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn key;\r\n}\r\nstatic long rxrpc_read(const struct key *key,\r\nchar __user *buffer, size_t buflen)\r\n{\r\nconst struct rxrpc_key_token *token;\r\nconst struct krb5_principal *princ;\r\nsize_t size;\r\n__be32 __user *xdr, *oldxdr;\r\nu32 cnlen, toksize, ntoks, tok, zero;\r\nu16 toksizes[AFSTOKEN_MAX];\r\nint loop;\r\n_enter("");\r\nif (memcmp(key->description, "afs@", 4) != 0)\r\nreturn -EOPNOTSUPP;\r\ncnlen = strlen(key->description + 4);\r\n#define RND(X) (((X) + 3) & ~3)\r\nsize = 2 * 4;\r\nsize += RND(cnlen);\r\nsize += 1 * 4;\r\nntoks = 0;\r\nfor (token = key->payload.data; token; token = token->next) {\r\ntoksize = 4;\r\nswitch (token->security_index) {\r\ncase RXRPC_SECURITY_RXKAD:\r\ntoksize += 8 * 4;\r\ntoksize += RND(token->kad->ticket_len);\r\nbreak;\r\ncase RXRPC_SECURITY_RXK5:\r\nprinc = &token->k5->client;\r\ntoksize += 4 + princ->n_name_parts * 4;\r\nfor (loop = 0; loop < princ->n_name_parts; loop++)\r\ntoksize += RND(strlen(princ->name_parts[loop]));\r\ntoksize += 4 + RND(strlen(princ->realm));\r\nprinc = &token->k5->server;\r\ntoksize += 4 + princ->n_name_parts * 4;\r\nfor (loop = 0; loop < princ->n_name_parts; loop++)\r\ntoksize += RND(strlen(princ->name_parts[loop]));\r\ntoksize += 4 + RND(strlen(princ->realm));\r\ntoksize += 8 + RND(token->k5->session.data_len);\r\ntoksize += 4 * 8 + 2 * 4;\r\ntoksize += 4 + token->k5->n_addresses * 8;\r\nfor (loop = 0; loop < token->k5->n_addresses; loop++)\r\ntoksize += RND(token->k5->addresses[loop].data_len);\r\ntoksize += 4 + RND(token->k5->ticket_len);\r\ntoksize += 4 + RND(token->k5->ticket2_len);\r\ntoksize += 4 + token->k5->n_authdata * 8;\r\nfor (loop = 0; loop < token->k5->n_authdata; loop++)\r\ntoksize += RND(token->k5->authdata[loop].data_len);\r\nbreak;\r\ndefault:\r\nBUG();\r\ncontinue;\r\n}\r\n_debug("token[%u]: toksize=%u", ntoks, toksize);\r\nASSERTCMP(toksize, <=, AFSTOKEN_LENGTH_MAX);\r\ntoksizes[ntoks++] = toksize;\r\nsize += toksize + 4;\r\n}\r\n#undef RND\r\nif (!buffer || buflen < size)\r\nreturn size;\r\nxdr = (__be32 __user *) buffer;\r\nzero = 0;\r\n#define ENCODE(x) \\r\ndo { \\r\n__be32 y = htonl(x); \\r\nif (put_user(y, xdr++) < 0) \\r\ngoto fault; \\r\n} while(0)\r\n#define ENCODE_DATA(l, s) \\r\ndo { \\r\nu32 _l = (l); \\r\nENCODE(l); \\r\nif (copy_to_user(xdr, (s), _l) != 0) \\r\ngoto fault; \\r\nif (_l & 3 && \\r\ncopy_to_user((u8 *)xdr + _l, &zero, 4 - (_l & 3)) != 0) \\r\ngoto fault; \\r\nxdr += (_l + 3) >> 2; \\r\n} while(0)\r\n#define ENCODE64(x) \\r\ndo { \\r\n__be64 y = cpu_to_be64(x); \\r\nif (copy_to_user(xdr, &y, 8) != 0) \\r\ngoto fault; \\r\nxdr += 8 >> 2; \\r\n} while(0)\r\n#define ENCODE_STR(s) \\r\ndo { \\r\nconst char *_s = (s); \\r\nENCODE_DATA(strlen(_s), _s); \\r\n} while(0)\r\nENCODE(0);\r\nENCODE_DATA(cnlen, key->description + 4);\r\nENCODE(ntoks);\r\ntok = 0;\r\nfor (token = key->payload.data; token; token = token->next) {\r\ntoksize = toksizes[tok++];\r\nENCODE(toksize);\r\noldxdr = xdr;\r\nENCODE(token->security_index);\r\nswitch (token->security_index) {\r\ncase RXRPC_SECURITY_RXKAD:\r\nENCODE(token->kad->vice_id);\r\nENCODE(token->kad->kvno);\r\nENCODE_DATA(8, token->kad->session_key);\r\nENCODE(token->kad->start);\r\nENCODE(token->kad->expiry);\r\nENCODE(token->kad->primary_flag);\r\nENCODE_DATA(token->kad->ticket_len, token->kad->ticket);\r\nbreak;\r\ncase RXRPC_SECURITY_RXK5:\r\nprinc = &token->k5->client;\r\nENCODE(princ->n_name_parts);\r\nfor (loop = 0; loop < princ->n_name_parts; loop++)\r\nENCODE_STR(princ->name_parts[loop]);\r\nENCODE_STR(princ->realm);\r\nprinc = &token->k5->server;\r\nENCODE(princ->n_name_parts);\r\nfor (loop = 0; loop < princ->n_name_parts; loop++)\r\nENCODE_STR(princ->name_parts[loop]);\r\nENCODE_STR(princ->realm);\r\nENCODE(token->k5->session.tag);\r\nENCODE_DATA(token->k5->session.data_len,\r\ntoken->k5->session.data);\r\nENCODE64(token->k5->authtime);\r\nENCODE64(token->k5->starttime);\r\nENCODE64(token->k5->endtime);\r\nENCODE64(token->k5->renew_till);\r\nENCODE(token->k5->is_skey);\r\nENCODE(token->k5->flags);\r\nENCODE(token->k5->n_addresses);\r\nfor (loop = 0; loop < token->k5->n_addresses; loop++) {\r\nENCODE(token->k5->addresses[loop].tag);\r\nENCODE_DATA(token->k5->addresses[loop].data_len,\r\ntoken->k5->addresses[loop].data);\r\n}\r\nENCODE_DATA(token->k5->ticket_len, token->k5->ticket);\r\nENCODE_DATA(token->k5->ticket2_len, token->k5->ticket2);\r\nENCODE(token->k5->n_authdata);\r\nfor (loop = 0; loop < token->k5->n_authdata; loop++) {\r\nENCODE(token->k5->authdata[loop].tag);\r\nENCODE_DATA(token->k5->authdata[loop].data_len,\r\ntoken->k5->authdata[loop].data);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nASSERTCMP((unsigned long)xdr - (unsigned long)oldxdr, ==,\r\ntoksize);\r\n}\r\n#undef ENCODE_STR\r\n#undef ENCODE_DATA\r\n#undef ENCODE64\r\n#undef ENCODE\r\nASSERTCMP(tok, ==, ntoks);\r\nASSERTCMP((char __user *) xdr - buffer, ==, size);\r\n_leave(" = %zu", size);\r\nreturn size;\r\nfault:\r\n_leave(" = -EFAULT");\r\nreturn -EFAULT;\r\n}
