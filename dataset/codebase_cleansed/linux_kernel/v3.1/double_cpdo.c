static float64 float64_rsf(struct roundingData *roundData, float64 rFn, float64 rFm)\r\n{\r\nreturn float64_sub(roundData, rFm, rFn);\r\n}\r\nstatic float64 float64_rdv(struct roundingData *roundData, float64 rFn, float64 rFm)\r\n{\r\nreturn float64_div(roundData, rFm, rFn);\r\n}\r\nstatic float64 float64_mvf(struct roundingData *roundData,float64 rFm)\r\n{\r\nreturn rFm;\r\n}\r\nstatic float64 float64_mnf(struct roundingData *roundData,float64 rFm)\r\n{\r\nunion float64_components u;\r\nu.f64 = rFm;\r\n#ifdef __ARMEB__\r\nu.i[0] ^= 0x80000000;\r\n#else\r\nu.i[1] ^= 0x80000000;\r\n#endif\r\nreturn u.f64;\r\n}\r\nstatic float64 float64_abs(struct roundingData *roundData,float64 rFm)\r\n{\r\nunion float64_components u;\r\nu.f64 = rFm;\r\n#ifdef __ARMEB__\r\nu.i[0] &= 0x7fffffff;\r\n#else\r\nu.i[1] &= 0x7fffffff;\r\n#endif\r\nreturn u.f64;\r\n}\r\nunsigned int DoubleCPDO(struct roundingData *roundData, const unsigned int opcode, FPREG * rFd)\r\n{\r\nFPA11 *fpa11 = GET_FPA11();\r\nfloat64 rFm;\r\nunsigned int Fm, opc_mask_shift;\r\nFm = getFm(opcode);\r\nif (CONSTANT_FM(opcode)) {\r\nrFm = getDoubleConstant(Fm);\r\n} else {\r\nswitch (fpa11->fType[Fm]) {\r\ncase typeSingle:\r\nrFm = float32_to_float64(fpa11->fpreg[Fm].fSingle);\r\nbreak;\r\ncase typeDouble:\r\nrFm = fpa11->fpreg[Fm].fDouble;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nopc_mask_shift = (opcode & MASK_ARITHMETIC_OPCODE) >> 20;\r\nif (!MONADIC_INSTRUCTION(opcode)) {\r\nunsigned int Fn = getFn(opcode);\r\nfloat64 rFn;\r\nswitch (fpa11->fType[Fn]) {\r\ncase typeSingle:\r\nrFn = float32_to_float64(fpa11->fpreg[Fn].fSingle);\r\nbreak;\r\ncase typeDouble:\r\nrFn = fpa11->fpreg[Fn].fDouble;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (dyadic_double[opc_mask_shift]) {\r\nrFd->fDouble = dyadic_double[opc_mask_shift](roundData, rFn, rFm);\r\n} else {\r\nreturn 0;\r\n}\r\n} else {\r\nif (monadic_double[opc_mask_shift]) {\r\nrFd->fDouble = monadic_double[opc_mask_shift](roundData, rFm);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}
