static void pg_init_units(void)\r\n{\r\nint unit;\r\npg_drive_count = 0;\r\nfor (unit = 0; unit < PG_UNITS; unit++) {\r\nint *parm = *drives[unit];\r\nstruct pg *dev = &devices[unit];\r\ndev->pi = &dev->pia;\r\nclear_bit(0, &dev->access);\r\ndev->busy = 0;\r\ndev->present = 0;\r\ndev->bufptr = NULL;\r\ndev->drive = parm[D_SLV];\r\nsnprintf(dev->name, PG_NAMELEN, "%s%c", name, 'a'+unit);\r\nif (parm[D_PRT])\r\npg_drive_count++;\r\n}\r\n}\r\nstatic inline int status_reg(struct pg *dev)\r\n{\r\nreturn pi_read_regr(dev->pi, 1, 6);\r\n}\r\nstatic inline int read_reg(struct pg *dev, int reg)\r\n{\r\nreturn pi_read_regr(dev->pi, 0, reg);\r\n}\r\nstatic inline void write_reg(struct pg *dev, int reg, int val)\r\n{\r\npi_write_regr(dev->pi, 0, reg, val);\r\n}\r\nstatic inline u8 DRIVE(struct pg *dev)\r\n{\r\nreturn 0xa0+0x10*dev->drive;\r\n}\r\nstatic void pg_sleep(int cs)\r\n{\r\nschedule_timeout_interruptible(cs);\r\n}\r\nstatic int pg_wait(struct pg *dev, int go, int stop, unsigned long tmo, char *msg)\r\n{\r\nint j, r, e, s, p, to;\r\ndev->status = 0;\r\nj = 0;\r\nwhile ((((r = status_reg(dev)) & go) || (stop && (!(r & stop))))\r\n&& time_before(jiffies, tmo)) {\r\nif (j++ < PG_SPIN)\r\nudelay(PG_SPIN_DEL);\r\nelse\r\npg_sleep(1);\r\n}\r\nto = time_after_eq(jiffies, tmo);\r\nif ((r & (STAT_ERR & stop)) || to) {\r\ns = read_reg(dev, 7);\r\ne = read_reg(dev, 1);\r\np = read_reg(dev, 2);\r\nif (verbose > 1)\r\nprintk("%s: %s: stat=0x%x err=0x%x phase=%d%s\n",\r\ndev->name, msg, s, e, p, to ? " timeout" : "");\r\nif (to)\r\ne |= 0x100;\r\ndev->status = (e >> 4) & 0xff;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pg_command(struct pg *dev, char *cmd, int dlen, unsigned long tmo)\r\n{\r\nint k;\r\npi_connect(dev->pi);\r\nwrite_reg(dev, 6, DRIVE(dev));\r\nif (pg_wait(dev, STAT_BUSY | STAT_DRQ, 0, tmo, "before command"))\r\ngoto fail;\r\nwrite_reg(dev, 4, dlen % 256);\r\nwrite_reg(dev, 5, dlen / 256);\r\nwrite_reg(dev, 7, 0xa0);\r\nif (pg_wait(dev, STAT_BUSY, STAT_DRQ, tmo, "command DRQ"))\r\ngoto fail;\r\nif (read_reg(dev, 2) != 1) {\r\nprintk("%s: command phase error\n", dev->name);\r\ngoto fail;\r\n}\r\npi_write_block(dev->pi, cmd, 12);\r\nif (verbose > 1) {\r\nprintk("%s: Command sent, dlen=%d packet= ", dev->name, dlen);\r\nfor (k = 0; k < 12; k++)\r\nprintk("%02x ", cmd[k] & 0xff);\r\nprintk("\n");\r\n}\r\nreturn 0;\r\nfail:\r\npi_disconnect(dev->pi);\r\nreturn -1;\r\n}\r\nstatic int pg_completion(struct pg *dev, char *buf, unsigned long tmo)\r\n{\r\nint r, d, n, p;\r\nr = pg_wait(dev, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,\r\ntmo, "completion");\r\ndev->dlen = 0;\r\nwhile (read_reg(dev, 7) & STAT_DRQ) {\r\nd = (read_reg(dev, 4) + 256 * read_reg(dev, 5));\r\nn = ((d + 3) & 0xfffc);\r\np = read_reg(dev, 2) & 3;\r\nif (p == 0)\r\npi_write_block(dev->pi, buf, n);\r\nif (p == 2)\r\npi_read_block(dev->pi, buf, n);\r\nif (verbose > 1)\r\nprintk("%s: %s %d bytes\n", dev->name,\r\np ? "Read" : "Write", n);\r\ndev->dlen += (1 - p) * d;\r\nbuf += d;\r\nr = pg_wait(dev, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,\r\ntmo, "completion");\r\n}\r\npi_disconnect(dev->pi);\r\nreturn r;\r\n}\r\nstatic int pg_reset(struct pg *dev)\r\n{\r\nint i, k, err;\r\nint expect[5] = { 1, 1, 1, 0x14, 0xeb };\r\nint got[5];\r\npi_connect(dev->pi);\r\nwrite_reg(dev, 6, DRIVE(dev));\r\nwrite_reg(dev, 7, 8);\r\npg_sleep(20 * HZ / 1000);\r\nk = 0;\r\nwhile ((k++ < PG_RESET_TMO) && (status_reg(dev) & STAT_BUSY))\r\npg_sleep(1);\r\nfor (i = 0; i < 5; i++)\r\ngot[i] = read_reg(dev, i + 1);\r\nerr = memcmp(expect, got, sizeof(got)) ? -1 : 0;\r\nif (verbose) {\r\nprintk("%s: Reset (%d) signature = ", dev->name, k);\r\nfor (i = 0; i < 5; i++)\r\nprintk("%3x", got[i]);\r\nif (err)\r\nprintk(" (incorrect)");\r\nprintk("\n");\r\n}\r\npi_disconnect(dev->pi);\r\nreturn err;\r\n}\r\nstatic void xs(char *buf, char *targ, int len)\r\n{\r\nchar l = '\0';\r\nint k;\r\nfor (k = 0; k < len; k++) {\r\nchar c = *buf++;\r\nif (c != ' ' && c != l)\r\nl = *targ++ = c;\r\n}\r\nif (l == ' ')\r\ntarg--;\r\n*targ = '\0';\r\n}\r\nstatic int pg_identify(struct pg *dev, int log)\r\n{\r\nint s;\r\nchar *ms[2] = { "master", "slave" };\r\nchar mf[10], id[18];\r\nchar id_cmd[12] = { ATAPI_IDENTIFY, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\r\nchar buf[36];\r\ns = pg_command(dev, id_cmd, 36, jiffies + PG_TMO);\r\nif (s)\r\nreturn -1;\r\ns = pg_completion(dev, buf, jiffies + PG_TMO);\r\nif (s)\r\nreturn -1;\r\nif (log) {\r\nxs(buf + 8, mf, 8);\r\nxs(buf + 16, id, 16);\r\nprintk("%s: %s %s, %s\n", dev->name, mf, id, ms[dev->drive]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pg_probe(struct pg *dev)\r\n{\r\nif (dev->drive == -1) {\r\nfor (dev->drive = 0; dev->drive <= 1; dev->drive++)\r\nif (!pg_reset(dev))\r\nreturn pg_identify(dev, 1);\r\n} else {\r\nif (!pg_reset(dev))\r\nreturn pg_identify(dev, 1);\r\n}\r\nreturn -1;\r\n}\r\nstatic int pg_detect(void)\r\n{\r\nstruct pg *dev = &devices[0];\r\nint k, unit;\r\nprintk("%s: %s version %s, major %d\n", name, name, PG_VERSION, major);\r\nk = 0;\r\nif (pg_drive_count == 0) {\r\nif (pi_init(dev->pi, 1, -1, -1, -1, -1, -1, pg_scratch,\r\nPI_PG, verbose, dev->name)) {\r\nif (!pg_probe(dev)) {\r\ndev->present = 1;\r\nk++;\r\n} else\r\npi_release(dev->pi);\r\n}\r\n} else\r\nfor (unit = 0; unit < PG_UNITS; unit++, dev++) {\r\nint *parm = *drives[unit];\r\nif (!parm[D_PRT])\r\ncontinue;\r\nif (pi_init(dev->pi, 0, parm[D_PRT], parm[D_MOD],\r\nparm[D_UNI], parm[D_PRO], parm[D_DLY],\r\npg_scratch, PI_PG, verbose, dev->name)) {\r\nif (!pg_probe(dev)) {\r\ndev->present = 1;\r\nk++;\r\n} else\r\npi_release(dev->pi);\r\n}\r\n}\r\nif (k)\r\nreturn 0;\r\nprintk("%s: No ATAPI device detected\n", name);\r\nreturn -1;\r\n}\r\nstatic int pg_open(struct inode *inode, struct file *file)\r\n{\r\nint unit = iminor(inode) & 0x7f;\r\nstruct pg *dev = &devices[unit];\r\nint ret = 0;\r\nmutex_lock(&pg_mutex);\r\nif ((unit >= PG_UNITS) || (!dev->present)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (test_and_set_bit(0, &dev->access)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (dev->busy) {\r\npg_reset(dev);\r\ndev->busy = 0;\r\n}\r\npg_identify(dev, (verbose > 1));\r\ndev->bufptr = kmalloc(PG_MAX_DATA, GFP_KERNEL);\r\nif (dev->bufptr == NULL) {\r\nclear_bit(0, &dev->access);\r\nprintk("%s: buffer allocation failed\n", dev->name);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfile->private_data = dev;\r\nout:\r\nmutex_unlock(&pg_mutex);\r\nreturn ret;\r\n}\r\nstatic int pg_release(struct inode *inode, struct file *file)\r\n{\r\nstruct pg *dev = file->private_data;\r\nkfree(dev->bufptr);\r\ndev->bufptr = NULL;\r\nclear_bit(0, &dev->access);\r\nreturn 0;\r\n}\r\nstatic ssize_t pg_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct pg *dev = filp->private_data;\r\nstruct pg_write_hdr hdr;\r\nint hs = sizeof (hdr);\r\nif (dev->busy)\r\nreturn -EBUSY;\r\nif (count < hs)\r\nreturn -EINVAL;\r\nif (copy_from_user(&hdr, buf, hs))\r\nreturn -EFAULT;\r\nif (hdr.magic != PG_MAGIC)\r\nreturn -EINVAL;\r\nif (hdr.dlen > PG_MAX_DATA)\r\nreturn -EINVAL;\r\nif ((count - hs) > PG_MAX_DATA)\r\nreturn -EINVAL;\r\nif (hdr.func == PG_RESET) {\r\nif (count != hs)\r\nreturn -EINVAL;\r\nif (pg_reset(dev))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nif (hdr.func != PG_COMMAND)\r\nreturn -EINVAL;\r\ndev->start = jiffies;\r\ndev->timeout = hdr.timeout * HZ + HZ / 2 + jiffies;\r\nif (pg_command(dev, hdr.packet, hdr.dlen, jiffies + PG_TMO)) {\r\nif (dev->status & 0x10)\r\nreturn -ETIME;\r\nreturn -EIO;\r\n}\r\ndev->busy = 1;\r\nif (copy_from_user(dev->bufptr, buf + hs, count - hs))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic ssize_t pg_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct pg *dev = filp->private_data;\r\nstruct pg_read_hdr hdr;\r\nint hs = sizeof (hdr);\r\nint copy;\r\nif (!dev->busy)\r\nreturn -EINVAL;\r\nif (count < hs)\r\nreturn -EINVAL;\r\ndev->busy = 0;\r\nif (pg_completion(dev, dev->bufptr, dev->timeout))\r\nif (dev->status & 0x10)\r\nreturn -ETIME;\r\nhdr.magic = PG_MAGIC;\r\nhdr.dlen = dev->dlen;\r\ncopy = 0;\r\nif (hdr.dlen < 0) {\r\nhdr.dlen = -1 * hdr.dlen;\r\ncopy = hdr.dlen;\r\nif (copy > (count - hs))\r\ncopy = count - hs;\r\n}\r\nhdr.duration = (jiffies - dev->start + HZ / 2) / HZ;\r\nhdr.scsi = dev->status & 0x0f;\r\nif (copy_to_user(buf, &hdr, hs))\r\nreturn -EFAULT;\r\nif (copy > 0)\r\nif (copy_to_user(buf + hs, dev->bufptr, copy))\r\nreturn -EFAULT;\r\nreturn copy + hs;\r\n}\r\nstatic int __init pg_init(void)\r\n{\r\nint unit;\r\nint err;\r\nif (disable){\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\npg_init_units();\r\nif (pg_detect()) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nerr = register_chrdev(major, name, &pg_fops);\r\nif (err < 0) {\r\nprintk("pg_init: unable to get major number %d\n", major);\r\nfor (unit = 0; unit < PG_UNITS; unit++) {\r\nstruct pg *dev = &devices[unit];\r\nif (dev->present)\r\npi_release(dev->pi);\r\n}\r\ngoto out;\r\n}\r\nmajor = err;\r\npg_class = class_create(THIS_MODULE, "pg");\r\nif (IS_ERR(pg_class)) {\r\nerr = PTR_ERR(pg_class);\r\ngoto out_chrdev;\r\n}\r\nfor (unit = 0; unit < PG_UNITS; unit++) {\r\nstruct pg *dev = &devices[unit];\r\nif (dev->present)\r\ndevice_create(pg_class, NULL, MKDEV(major, unit), NULL,\r\n"pg%u", unit);\r\n}\r\nerr = 0;\r\ngoto out;\r\nout_chrdev:\r\nunregister_chrdev(major, "pg");\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit pg_exit(void)\r\n{\r\nint unit;\r\nfor (unit = 0; unit < PG_UNITS; unit++) {\r\nstruct pg *dev = &devices[unit];\r\nif (dev->present)\r\ndevice_destroy(pg_class, MKDEV(major, unit));\r\n}\r\nclass_destroy(pg_class);\r\nunregister_chrdev(major, name);\r\nfor (unit = 0; unit < PG_UNITS; unit++) {\r\nstruct pg *dev = &devices[unit];\r\nif (dev->present)\r\npi_release(dev->pi);\r\n}\r\n}
