RT_STATUS cmpk_message_handle_tx(\r\nstruct r8192_priv *priv,\r\nu8* code_virtual_address,\r\nu32 packettype,\r\nu32 buffer_len)\r\n{\r\nRT_STATUS rt_status = RT_STATUS_SUCCESS;\r\nu16 frag_threshold;\r\nu16 frag_length = 0, frag_offset = 0;\r\nrt_firmware *pfirmware = priv->pFirmware;\r\nstruct sk_buff *skb;\r\nunsigned char *seg_ptr;\r\ncb_desc *tcb_desc;\r\nu8 bLastIniPkt;\r\nPTX_FWINFO_8190PCI pTxFwInfo = NULL;\r\nint i;\r\nRT_TRACE(COMP_CMDPKT,"%s(),buffer_len is %d\n",__FUNCTION__,buffer_len);\r\nfirmware_init_param(priv);\r\nfrag_threshold = pfirmware->cmdpacket_frag_thresold;\r\ndo {\r\nif((buffer_len - frag_offset) > frag_threshold) {\r\nfrag_length = frag_threshold ;\r\nbLastIniPkt = 0;\r\n} else {\r\nfrag_length =(u16)(buffer_len - frag_offset);\r\nbLastIniPkt = 1;\r\n}\r\nskb = dev_alloc_skb(frag_length + priv->ieee80211->tx_headroom + 4);\r\nif(skb == NULL) {\r\nrt_status = RT_STATUS_FAILURE;\r\ngoto Failed;\r\n}\r\ntcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->bCmdOrInit = packettype;\r\ntcb_desc->bLastIniPkt = bLastIniPkt;\r\ntcb_desc->pkt_size = frag_length;\r\nseg_ptr = skb_put(skb, priv->ieee80211->tx_headroom);\r\npTxFwInfo = (PTX_FWINFO_8190PCI)seg_ptr;\r\nmemset(pTxFwInfo,0,sizeof(TX_FWINFO_8190PCI));\r\nmemset(pTxFwInfo,0x12,8);\r\nseg_ptr +=sizeof(TX_FWINFO_8190PCI);\r\nseg_ptr = skb_tail_pointer(skb);\r\nfor(i=0 ; i < frag_length; i+=4) {\r\n*seg_ptr++ = ((i+0)<frag_length)?code_virtual_address[i+3]:0;\r\n*seg_ptr++ = ((i+1)<frag_length)?code_virtual_address[i+2]:0;\r\n*seg_ptr++ = ((i+2)<frag_length)?code_virtual_address[i+1]:0;\r\n*seg_ptr++ = ((i+3)<frag_length)?code_virtual_address[i+0]:0;\r\n}\r\nskb_put(skb, i);\r\npriv->ieee80211->softmac_hard_start_xmit(skb, priv->ieee80211);\r\ncode_virtual_address += frag_length;\r\nfrag_offset += frag_length;\r\n}while(frag_offset < buffer_len);\r\nFailed:\r\nreturn rt_status;\r\n}\r\nstatic void cmpk_count_txstatistic(struct r8192_priv *priv, cmpk_txfb_t *pstx_fb)\r\n{\r\n#ifdef ENABLE_PS\r\nRT_RF_POWER_STATE rtState;\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\n{\r\nreturn;\r\n}\r\n#endif\r\n#ifdef TODO\r\nif(pAdapter->bInHctTest)\r\nreturn;\r\n#endif\r\nif (pstx_fb->tok)\r\n{\r\npriv->stats.txoktotal++;\r\nif (pstx_fb->pkt_type != PACKET_MULTICAST &&\r\npstx_fb->pkt_type != PACKET_BROADCAST) {\r\npriv->stats.txbytesunicast += pstx_fb->pkt_length;\r\n}\r\n}\r\n}\r\nstatic void cmpk_handle_tx_feedback(struct r8192_priv *priv, u8 *pmsg)\r\n{\r\ncmpk_txfb_t rx_tx_fb;\r\npriv->stats.txfeedback++;\r\nmemcpy((u8*)&rx_tx_fb, pmsg, sizeof(cmpk_txfb_t));\r\ncmpk_count_txstatistic(priv, &rx_tx_fb);\r\n}\r\nstatic void cmpk_handle_interrupt_status(struct r8192_priv *priv, u8 *pmsg)\r\n{\r\ncmpk_intr_sta_t rx_intr_status;\r\nDMESG("---> cmpk_Handle_Interrupt_Status()\n");\r\nrx_intr_status.length = pmsg[1];\r\nif (rx_intr_status.length != (sizeof(cmpk_intr_sta_t) - 2))\r\n{\r\nDMESG("cmpk_Handle_Interrupt_Status: wrong length!\n");\r\nreturn;\r\n}\r\nif( priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\n{\r\nrx_intr_status.interrupt_status = *((u32 *)(pmsg + 4));\r\nDMESG("interrupt status = 0x%x\n", rx_intr_status.interrupt_status);\r\nif (rx_intr_status.interrupt_status & ISR_TxBcnOk)\r\n{\r\npriv->ieee80211->bibsscoordinator = true;\r\npriv->stats.txbeaconokint++;\r\n}\r\nelse if (rx_intr_status.interrupt_status & ISR_TxBcnErr)\r\n{\r\npriv->ieee80211->bibsscoordinator = false;\r\npriv->stats.txbeaconerr++;\r\n}\r\n}\r\nDMESG("<---- cmpk_handle_interrupt_status()\n");\r\n}\r\nstatic void cmpk_handle_query_config_rx(struct r8192_priv *priv, u8 *pmsg)\r\n{\r\ncmpk_query_cfg_t rx_query_cfg;\r\nrx_query_cfg.cfg_action = (pmsg[4] & 0x80000000)>>31;\r\nrx_query_cfg.cfg_type = (pmsg[4] & 0x60) >> 5;\r\nrx_query_cfg.cfg_size = (pmsg[4] & 0x18) >> 3;\r\nrx_query_cfg.cfg_page = (pmsg[6] & 0x0F) >> 0;\r\nrx_query_cfg.cfg_offset = pmsg[7];\r\nrx_query_cfg.value = (pmsg[8] << 24) | (pmsg[9] << 16) |\r\n(pmsg[10] << 8) | (pmsg[11] << 0);\r\nrx_query_cfg.mask = (pmsg[12] << 24) | (pmsg[13] << 16) |\r\n(pmsg[14] << 8) | (pmsg[15] << 0);\r\n}\r\nstatic void cmpk_count_tx_status(struct r8192_priv *priv, cmpk_tx_status_t *pstx_status)\r\n{\r\n#ifdef ENABLE_PS\r\nRT_RF_POWER_STATE rtstate;\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\n{\r\nreturn;\r\n}\r\n#endif\r\npriv->stats.txfeedbackok += pstx_status->txok;\r\npriv->stats.txoktotal += pstx_status->txok;\r\npriv->stats.txbytesunicast += pstx_status->txuclength;\r\n}\r\nstatic void cmpk_handle_tx_status(struct r8192_priv *priv, u8 *pmsg)\r\n{\r\ncmpk_tx_status_t rx_tx_sts;\r\nmemcpy((void*)&rx_tx_sts, (void*)pmsg, sizeof(cmpk_tx_status_t));\r\ncmpk_count_tx_status(priv, &rx_tx_sts);\r\n}\r\nstatic void cmpk_handle_tx_rate_history(struct r8192_priv *priv, u8 *pmsg)\r\n{\r\nu8 i;\r\nu16 length = sizeof(cmpk_tx_rahis_t);\r\nu32 *ptemp;\r\n#ifdef ENABLE_PS\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\n{\r\nreturn;\r\n}\r\n#endif\r\nptemp = (u32 *)pmsg;\r\nfor (i = 0; i < (length/4); i++)\r\n{\r\nu16 temp1, temp2;\r\ntemp1 = ptemp[i]&0x0000FFFF;\r\ntemp2 = ptemp[i]>>16;\r\nptemp[i] = (temp1<<16)|temp2;\r\n}\r\n}\r\nu32 cmpk_message_handle_rx(struct r8192_priv *priv, struct ieee80211_rx_stats *pstats)\r\n{\r\nint total_length;\r\nu8 cmd_length, exe_cnt = 0;\r\nu8 element_id;\r\nu8 *pcmd_buff;\r\nRT_TRACE(COMP_EVENTS, "---->cmpk_message_handle_rx()\n");\r\nif ((pstats== NULL))\r\n{\r\nreturn 0;\r\n}\r\ntotal_length = pstats->Length;\r\npcmd_buff = pstats->virtual_address;\r\nelement_id = pcmd_buff[0];\r\nwhile (total_length > 0 || exe_cnt++ >100)\r\n{\r\nelement_id = pcmd_buff[0];\r\nswitch(element_id)\r\n{\r\ncase RX_TX_FEEDBACK:\r\nRT_TRACE(COMP_EVENTS, "---->cmpk_message_handle_rx():RX_TX_FEEDBACK\n");\r\ncmpk_handle_tx_feedback(priv, pcmd_buff);\r\ncmd_length = CMPK_RX_TX_FB_SIZE;\r\nbreak;\r\ncase RX_INTERRUPT_STATUS:\r\nRT_TRACE(COMP_EVENTS, "---->cmpk_message_handle_rx():RX_INTERRUPT_STATUS\n");\r\ncmpk_handle_interrupt_status(priv, pcmd_buff);\r\ncmd_length = sizeof(cmpk_intr_sta_t);\r\nbreak;\r\ncase BOTH_QUERY_CONFIG:\r\nRT_TRACE(COMP_EVENTS, "---->cmpk_message_handle_rx():BOTH_QUERY_CONFIG\n");\r\ncmpk_handle_query_config_rx(priv, pcmd_buff);\r\ncmd_length = CMPK_BOTH_QUERY_CONFIG_SIZE;\r\nbreak;\r\ncase RX_TX_STATUS:\r\nRT_TRACE(COMP_EVENTS, "---->cmpk_message_handle_rx():RX_TX_STATUS\n");\r\ncmpk_handle_tx_status(priv, pcmd_buff);\r\ncmd_length = CMPK_RX_TX_STS_SIZE;\r\nbreak;\r\ncase RX_TX_PER_PKT_FEEDBACK:\r\nRT_TRACE(COMP_EVENTS, "---->cmpk_message_handle_rx():RX_TX_PER_PKT_FEEDBACK\n");\r\ncmd_length = CMPK_RX_TX_FB_SIZE;\r\nbreak;\r\ncase RX_TX_RATE_HISTORY:\r\nRT_TRACE(COMP_EVENTS, "---->cmpk_message_handle_rx():RX_TX_HISTORY\n");\r\ncmpk_handle_tx_rate_history(priv, pcmd_buff);\r\ncmd_length = CMPK_TX_RAHIS_SIZE;\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_EVENTS, "---->cmpk_message_handle_rx():unknown CMD Element\n");\r\nreturn 1;\r\n}\r\ntotal_length -= cmd_length;\r\npcmd_buff += cmd_length;\r\n}\r\nreturn 1;\r\nRT_TRACE(COMP_EVENTS, "<----cmpk_message_handle_rx()\n");\r\n}
