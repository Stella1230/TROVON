static int intel_sst_reset_dsp_mrst(void)\r\n{\r\nunion config_status_reg csr;\r\npr_debug("Resetting the DSP in mrst\n");\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.full |= 0x382;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.part.strb_cntr_rst = 0;\r\ncsr.part.run_stall = 0x1;\r\ncsr.part.bypass = 0x7;\r\ncsr.part.sst_reset = 0x1;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\nreturn 0;\r\n}\r\nstatic int intel_sst_reset_dsp_medfield(void)\r\n{\r\nunion config_status_reg csr;\r\npr_debug("Resetting the DSP in medfield\n");\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.full |= 0x382;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\nreturn 0;\r\n}\r\nstatic int sst_start_mrst(void)\r\n{\r\nunion config_status_reg csr;\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.part.bypass = 0;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.part.run_stall = 0;\r\ncsr.part.sst_reset = 0;\r\ncsr.part.strb_cntr_rst = 1;\r\npr_debug("Setting SST to execute_mrst 0x%x\n", csr.full);\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\nreturn 0;\r\n}\r\nstatic int sst_start_medfield(void)\r\n{\r\nunion config_status_reg csr;\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.part.bypass = 0;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.part.mfld_strb = 1;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.part.run_stall = 0;\r\ncsr.part.sst_reset = 0;\r\npr_debug("Starting the DSP_medfld %x\n", csr.full);\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\npr_debug("Starting the DSP_medfld\n");\r\nreturn 0;\r\n}\r\nstatic int sst_parse_module(struct fw_module_header *module)\r\n{\r\nstruct dma_block_info *block;\r\nu32 count;\r\nvoid __iomem *ram;\r\npr_debug("module sign %s size %x blocks %x type %x\n",\r\nmodule->signature, module->mod_size,\r\nmodule->blocks, module->type);\r\npr_debug("module entrypoint 0x%x\n", module->entry_point);\r\nblock = (void *)module + sizeof(*module);\r\nfor (count = 0; count < module->blocks; count++) {\r\nif (block->size <= 0) {\r\npr_err("block size invalid\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (block->type) {\r\ncase SST_IRAM:\r\nram = sst_drv_ctx->iram;\r\nbreak;\r\ncase SST_DRAM:\r\nram = sst_drv_ctx->dram;\r\nbreak;\r\ndefault:\r\npr_err("wrong ram type0x%x in block0x%x\n",\r\nblock->type, count);\r\nreturn -EINVAL;\r\n}\r\nmemcpy_toio(ram + block->ram_offset,\r\n(void *)block + sizeof(*block), block->size);\r\nblock = (void *)block + sizeof(*block) + block->size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_parse_fw_image(const struct firmware *sst_fw)\r\n{\r\nstruct fw_header *header;\r\nu32 count;\r\nint ret_val;\r\nstruct fw_module_header *module;\r\nBUG_ON(!sst_fw);\r\nheader = (struct fw_header *)sst_fw->data;\r\nif ((strncmp(header->signature, SST_FW_SIGN, 4) != 0) ||\r\n(sst_fw->size != header->file_size + sizeof(*header))) {\r\npr_err("Invalid FW sign/filesize mismatch\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("header sign=%s size=%x modules=%x fmt=%x size=%x\n",\r\nheader->signature, header->file_size, header->modules,\r\nheader->file_format, sizeof(*header));\r\nmodule = (void *)sst_fw->data + sizeof(*header);\r\nfor (count = 0; count < header->modules; count++) {\r\nret_val = sst_parse_module(module);\r\nif (ret_val)\r\nreturn ret_val;\r\nmodule = (void *)module + sizeof(*module) + module->mod_size ;\r\n}\r\nreturn 0;\r\n}\r\nint sst_load_fw(const struct firmware *fw, void *context)\r\n{\r\nint ret_val;\r\npr_debug("load_fw called\n");\r\nBUG_ON(!fw);\r\nif (sst_drv_ctx->pci_id == SST_MRST_PCI_ID)\r\nret_val = intel_sst_reset_dsp_mrst();\r\nelse if (sst_drv_ctx->pci_id == SST_MFLD_PCI_ID)\r\nret_val = intel_sst_reset_dsp_medfield();\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = sst_parse_fw_image(fw);\r\nif (ret_val)\r\nreturn ret_val;\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_drv_ctx->sst_state = SST_FW_LOADED;\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\nif (sst_drv_ctx->pci_id == SST_MRST_PCI_ID)\r\nret_val = sst_start_mrst();\r\nelse if (sst_drv_ctx->pci_id == SST_MFLD_PCI_ID)\r\nret_val = sst_start_medfield();\r\nif (ret_val)\r\nreturn ret_val;\r\npr_debug("fw loaded successful!!!\n");\r\nreturn ret_val;\r\n}\r\nstatic int sst_download_library(const struct firmware *fw_lib,\r\nstruct snd_sst_lib_download_info *lib)\r\n{\r\nint i;\r\nu8 pvt_id;\r\nstruct ipc_post *msg = NULL;\r\nunion config_status_reg csr;\r\nstruct snd_sst_str_type str_type = {0};\r\nint retval = 0;\r\nif (sst_create_large_msg(&msg))\r\nreturn -ENOMEM;\r\npvt_id = sst_assign_pvt_id(sst_drv_ctx);\r\ni = sst_get_block_stream(sst_drv_ctx);\r\npr_debug("alloc block allocated = %d, pvt_id %d\n", i, pvt_id);\r\nif (i < 0) {\r\nkfree(msg);\r\nreturn -ENOMEM;\r\n}\r\nsst_drv_ctx->alloc_block[i].sst_id = pvt_id;\r\nsst_fill_header(&msg->header, IPC_IA_PREP_LIB_DNLD, 1, pvt_id);\r\nmsg->header.part.data = sizeof(u32) + sizeof(str_type);\r\nstr_type.codec_type = lib->dload_lib.lib_info.lib_type;\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), &str_type, sizeof(str_type));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_timeout(sst_drv_ctx, &sst_drv_ctx->alloc_block[i]);\r\nif (retval) {\r\nsst_drv_ctx->alloc_block[i].sst_id = BLOCK_UNINIT;\r\npr_err("Prep codec downloaded failed %d\n",\r\nretval);\r\nreturn -EIO;\r\n}\r\npr_debug("FW responded, ready for download now...\n");\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_drv_ctx->sst_state = SST_FW_LOADED;\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\ncsr.full = readl(sst_drv_ctx->shim + SST_CSR);\r\ncsr.part.run_stall = 1;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.part.bypass = 0x7;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\nsst_parse_fw_image(fw_lib);\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.part.bypass = 0x0;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);\r\ncsr.part.run_stall = 0;\r\nsst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);\r\nif (sst_create_large_msg(&msg)) {\r\nsst_drv_ctx->alloc_block[i].sst_id = BLOCK_UNINIT;\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_LIB_DNLD_CMPLT, 1, pvt_id);\r\nsst_drv_ctx->alloc_block[i].sst_id = pvt_id;\r\nmsg->header.part.data = sizeof(u32) + sizeof(*lib);\r\nlib->pvt_id = pvt_id;\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), lib, sizeof(*lib));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\npr_debug("Waiting for FW response Download complete\n");\r\nsst_drv_ctx->alloc_block[i].ops_block.condition = false;\r\nretval = sst_wait_timeout(sst_drv_ctx, &sst_drv_ctx->alloc_block[i]);\r\nif (retval) {\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_drv_ctx->sst_state = SST_UN_INIT;\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\nsst_drv_ctx->alloc_block[i].sst_id = BLOCK_UNINIT;\r\nreturn -EIO;\r\n}\r\npr_debug("FW success on Download complete\n");\r\nsst_drv_ctx->alloc_block[i].sst_id = BLOCK_UNINIT;\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_drv_ctx->sst_state = SST_FW_RUNNING;\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\nreturn 0;\r\n}\r\nstatic int sst_validate_library(const struct firmware *fw_lib,\r\nstruct lib_slot_info *slot,\r\nu32 *entry_point)\r\n{\r\nstruct fw_header *header;\r\nstruct fw_module_header *module;\r\nstruct dma_block_info *block;\r\nunsigned int n_blk, isize = 0, dsize = 0;\r\nint err = 0;\r\nheader = (struct fw_header *)fw_lib->data;\r\nif (header->modules != 1) {\r\npr_err("Module no mismatch found\n");\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nmodule = (void *)fw_lib->data + sizeof(*header);\r\n*entry_point = module->entry_point;\r\npr_debug("Module entry point 0x%x\n", *entry_point);\r\npr_debug("Module Sign %s, Size 0x%x, Blocks 0x%x Type 0x%x\n",\r\nmodule->signature, module->mod_size,\r\nmodule->blocks, module->type);\r\nblock = (void *)module + sizeof(*module);\r\nfor (n_blk = 0; n_blk < module->blocks; n_blk++) {\r\nswitch (block->type) {\r\ncase SST_IRAM:\r\nisize += block->size;\r\nbreak;\r\ncase SST_DRAM:\r\ndsize += block->size;\r\nbreak;\r\ndefault:\r\npr_err("Invalid block type for 0x%x\n", n_blk);\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nblock = (void *)block + sizeof(*block) + block->size;\r\n}\r\nif (isize > slot->iram_size || dsize > slot->dram_size) {\r\npr_err("library exceeds size allocated\n");\r\nerr = -EINVAL;\r\ngoto exit;\r\n} else\r\npr_debug("Library is safe for download...\n");\r\npr_debug("iram 0x%x, dram 0x%x, iram 0x%x, dram 0x%x\n",\r\nisize, dsize, slot->iram_size, slot->dram_size);\r\nexit:\r\nreturn err;\r\n}\r\nint sst_load_library(struct snd_sst_lib_download *lib, u8 ops)\r\n{\r\nchar buf[20];\r\nconst char *type, *dir;\r\nint len = 0, error = 0;\r\nu32 entry_point;\r\nconst struct firmware *fw_lib;\r\nstruct snd_sst_lib_download_info dload_info = {{{0},},};\r\nmemset(buf, 0, sizeof(buf));\r\npr_debug("Lib Type 0x%x, Slot 0x%x, ops 0x%x\n",\r\nlib->lib_info.lib_type, lib->slot_info.slot_num, ops);\r\npr_debug("Version 0x%x, name %s, caps 0x%x media type 0x%x\n",\r\nlib->lib_info.lib_version, lib->lib_info.lib_name,\r\nlib->lib_info.lib_caps, lib->lib_info.media_type);\r\npr_debug("IRAM Size 0x%x, offset 0x%x\n",\r\nlib->slot_info.iram_size, lib->slot_info.iram_offset);\r\npr_debug("DRAM Size 0x%x, offset 0x%x\n",\r\nlib->slot_info.dram_size, lib->slot_info.dram_offset);\r\nswitch (lib->lib_info.lib_type) {\r\ncase SST_CODEC_TYPE_MP3:\r\ntype = "mp3_";\r\nbreak;\r\ncase SST_CODEC_TYPE_AAC:\r\ntype = "aac_";\r\nbreak;\r\ncase SST_CODEC_TYPE_AACP:\r\ntype = "aac_v1_";\r\nbreak;\r\ncase SST_CODEC_TYPE_eAACP:\r\ntype = "aac_v2_";\r\nbreak;\r\ncase SST_CODEC_TYPE_WMA9:\r\ntype = "wma9_";\r\nbreak;\r\ndefault:\r\npr_err("Invalid codec type\n");\r\nerror = -EINVAL;\r\ngoto wake;\r\n}\r\nif (ops == STREAM_OPS_CAPTURE)\r\ndir = "enc_";\r\nelse\r\ndir = "dec_";\r\nlen = strlen(type) + strlen(dir);\r\nstrncpy(buf, type, sizeof(buf)-1);\r\nstrncpy(buf + strlen(type), dir, sizeof(buf)-strlen(type)-1);\r\nlen += snprintf(buf + len, sizeof(buf) - len, "%d",\r\nlib->slot_info.slot_num);\r\nlen += snprintf(buf + len, sizeof(buf) - len, ".bin");\r\npr_debug("Requesting %s\n", buf);\r\nerror = request_firmware(&fw_lib, buf, &sst_drv_ctx->pci->dev);\r\nif (error) {\r\npr_err("library load failed %d\n", error);\r\ngoto wake;\r\n}\r\nerror = sst_validate_library(fw_lib, &lib->slot_info, &entry_point);\r\nif (error)\r\ngoto wake_free;\r\nlib->mod_entry_pt = entry_point;\r\nmemcpy(&dload_info.dload_lib, lib, sizeof(*lib));\r\nerror = sst_download_library(fw_lib, &dload_info);\r\nif (error)\r\ngoto wake_free;\r\npr_debug("Library is downloaded now...\n");\r\nwake_free:\r\nrelease_firmware(fw_lib);\r\nwake:\r\nreturn error;\r\n}
