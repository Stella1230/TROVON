static void mxs_i2c_reset(struct mxs_i2c_dev *i2c)\r\n{\r\nmxs_reset_block(i2c->regs);\r\nwritel(MXS_I2C_IRQ_MASK << 8, i2c->regs + MXS_I2C_CTRL1_SET);\r\nwritel(MXS_I2C_QUEUECTRL_PIO_QUEUE_MODE,\r\ni2c->regs + MXS_I2C_QUEUECTRL_SET);\r\n}\r\nstatic void mxs_i2c_pioq_setup_read(struct mxs_i2c_dev *i2c, u8 addr, int len,\r\nint flags)\r\n{\r\nu32 data;\r\nwritel(MXS_CMD_I2C_SELECT, i2c->regs + MXS_I2C_QUEUECMD);\r\ndata = (addr << 1) | I2C_SMBUS_READ;\r\nwritel(data, i2c->regs + MXS_I2C_DATA);\r\ndata = MXS_CMD_I2C_READ | MXS_I2C_CTRL0_XFER_COUNT(len) | flags;\r\nwritel(data, i2c->regs + MXS_I2C_QUEUECMD);\r\n}\r\nstatic void mxs_i2c_pioq_setup_write(struct mxs_i2c_dev *i2c,\r\nu8 addr, u8 *buf, int len, int flags)\r\n{\r\nu32 data;\r\nint i, shifts_left;\r\ndata = MXS_CMD_I2C_WRITE | MXS_I2C_CTRL0_XFER_COUNT(len + 1) | flags;\r\nwritel(data, i2c->regs + MXS_I2C_QUEUECMD);\r\ndata = ((addr << 1) | I2C_SMBUS_WRITE) << 24;\r\nfor (i = 0; i < len; i++) {\r\ndata >>= 8;\r\ndata |= buf[i] << 24;\r\nif ((i & 3) == 2)\r\nwritel(data, i2c->regs + MXS_I2C_DATA);\r\n}\r\nshifts_left = 24 - (i & 3) * 8;\r\nif (shifts_left)\r\nwritel(data >> shifts_left, i2c->regs + MXS_I2C_DATA);\r\n}\r\nstatic int mxs_i2c_wait_for_data(struct mxs_i2c_dev *i2c)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nwhile (readl(i2c->regs + MXS_I2C_QUEUESTAT)\r\n& MXS_I2C_QUEUESTAT_RD_QUEUE_EMPTY) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\ncond_resched();\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_i2c_finish_read(struct mxs_i2c_dev *i2c, u8 *buf, int len)\r\n{\r\nu32 data;\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nif ((i & 3) == 0) {\r\nif (mxs_i2c_wait_for_data(i2c))\r\nreturn -ETIMEDOUT;\r\ndata = readl(i2c->regs + MXS_I2C_QUEUEDATA);\r\n}\r\nbuf[i] = data & 0xff;\r\ndata >>= 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_i2c_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg,\r\nint stop)\r\n{\r\nstruct mxs_i2c_dev *i2c = i2c_get_adapdata(adap);\r\nint ret;\r\nint flags;\r\ninit_completion(&i2c->cmd_complete);\r\ndev_dbg(i2c->dev, "addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\n",\r\nmsg->addr, msg->len, msg->flags, stop);\r\nif (msg->len == 0)\r\nreturn -EINVAL;\r\nflags = stop ? MXS_I2C_CTRL0_POST_SEND_STOP : 0;\r\nif (msg->flags & I2C_M_RD)\r\nmxs_i2c_pioq_setup_read(i2c, msg->addr, msg->len, flags);\r\nelse\r\nmxs_i2c_pioq_setup_write(i2c, msg->addr, msg->buf, msg->len,\r\nflags);\r\nwritel(MXS_I2C_QUEUECTRL_QUEUE_RUN,\r\ni2c->regs + MXS_I2C_QUEUECTRL_SET);\r\nret = wait_for_completion_timeout(&i2c->cmd_complete,\r\nmsecs_to_jiffies(1000));\r\nif (ret == 0)\r\ngoto timeout;\r\nif ((!i2c->cmd_err) && (msg->flags & I2C_M_RD)) {\r\nret = mxs_i2c_finish_read(i2c, msg->buf, msg->len);\r\nif (ret)\r\ngoto timeout;\r\n}\r\nif (i2c->cmd_err == -ENXIO)\r\nmxs_i2c_reset(i2c);\r\ndev_dbg(i2c->dev, "Done with err=%d\n", i2c->cmd_err);\r\nreturn i2c->cmd_err;\r\ntimeout:\r\ndev_dbg(i2c->dev, "Timeout!\n");\r\nmxs_i2c_reset(i2c);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int mxs_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\r\nint num)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < num; i++) {\r\nerr = mxs_i2c_xfer_msg(adap, &msgs[i], i == (num - 1));\r\nif (err)\r\nreturn err;\r\n}\r\nreturn num;\r\n}\r\nstatic u32 mxs_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\r\n}\r\nstatic irqreturn_t mxs_i2c_isr(int this_irq, void *dev_id)\r\n{\r\nstruct mxs_i2c_dev *i2c = dev_id;\r\nu32 stat = readl(i2c->regs + MXS_I2C_CTRL1) & MXS_I2C_IRQ_MASK;\r\nif (!stat)\r\nreturn IRQ_NONE;\r\nif (stat & MXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ)\r\ni2c->cmd_err = -ENXIO;\r\nelse if (stat & (MXS_I2C_CTRL1_EARLY_TERM_IRQ |\r\nMXS_I2C_CTRL1_MASTER_LOSS_IRQ |\r\nMXS_I2C_CTRL1_SLAVE_STOP_IRQ | MXS_I2C_CTRL1_SLAVE_IRQ))\r\ni2c->cmd_err = -EIO;\r\nelse\r\ni2c->cmd_err = 0;\r\ncomplete(&i2c->cmd_complete);\r\nwritel(stat, i2c->regs + MXS_I2C_CTRL1_CLR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit mxs_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mxs_i2c_dev *i2c;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\nresource_size_t res_size;\r\nint err, irq;\r\ni2c = devm_kzalloc(dev, sizeof(struct mxs_i2c_dev), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENOENT;\r\nres_size = resource_size(res);\r\nif (!devm_request_mem_region(dev, res->start, res_size, res->name))\r\nreturn -EBUSY;\r\ni2c->regs = devm_ioremap_nocache(dev, res->start, res_size);\r\nif (!i2c->regs)\r\nreturn -EBUSY;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nerr = devm_request_irq(dev, irq, mxs_i2c_isr, 0, dev_name(dev), i2c);\r\nif (err)\r\nreturn err;\r\ni2c->dev = dev;\r\nplatform_set_drvdata(pdev, i2c);\r\nmxs_i2c_reset(i2c);\r\nadap = &i2c->adapter;\r\nstrlcpy(adap->name, "MXS I2C adapter", sizeof(adap->name));\r\nadap->owner = THIS_MODULE;\r\nadap->algo = &mxs_i2c_algo;\r\nadap->dev.parent = dev;\r\nadap->nr = pdev->id;\r\ni2c_set_adapdata(adap, i2c);\r\nerr = i2c_add_numbered_adapter(adap);\r\nif (err) {\r\ndev_err(dev, "Failed to add adapter (%d)\n", err);\r\nwritel(MXS_I2C_CTRL0_SFTRST,\r\ni2c->regs + MXS_I2C_CTRL0_SET);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit mxs_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct mxs_i2c_dev *i2c = platform_get_drvdata(pdev);\r\nint ret;\r\nret = i2c_del_adapter(&i2c->adapter);\r\nif (ret)\r\nreturn -EBUSY;\r\nwritel(MXS_I2C_QUEUECTRL_QUEUE_RUN,\r\ni2c->regs + MXS_I2C_QUEUECTRL_CLR);\r\nwritel(MXS_I2C_CTRL0_SFTRST, i2c->regs + MXS_I2C_CTRL0_SET);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init mxs_i2c_init(void)\r\n{\r\nreturn platform_driver_probe(&mxs_i2c_driver, mxs_i2c_probe);\r\n}\r\nstatic void __exit mxs_i2c_exit(void)\r\n{\r\nplatform_driver_unregister(&mxs_i2c_driver);\r\n}
