static struct pci_bus *dca_pci_rc_from_dev(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct pci_bus *bus = pdev->bus;\r\nwhile (bus->parent)\r\nbus = bus->parent;\r\nreturn bus;\r\n}\r\nstatic struct dca_domain *dca_allocate_domain(struct pci_bus *rc)\r\n{\r\nstruct dca_domain *domain;\r\ndomain = kzalloc(sizeof(*domain), GFP_NOWAIT);\r\nif (!domain)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&domain->dca_providers);\r\ndomain->pci_rc = rc;\r\nreturn domain;\r\n}\r\nstatic void dca_free_domain(struct dca_domain *domain)\r\n{\r\nlist_del(&domain->node);\r\nkfree(domain);\r\n}\r\nstatic int dca_provider_ioat_ver_3_0(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nreturn ((pdev->vendor == PCI_VENDOR_ID_INTEL) &&\r\n((pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG0) ||\r\n(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG1) ||\r\n(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG2) ||\r\n(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG3) ||\r\n(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG4) ||\r\n(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG5) ||\r\n(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG6) ||\r\n(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG7)));\r\n}\r\nstatic void unregister_dca_providers(void)\r\n{\r\nstruct dca_provider *dca, *_dca;\r\nstruct list_head unregistered_providers;\r\nstruct dca_domain *domain;\r\nunsigned long flags;\r\nblocking_notifier_call_chain(&dca_provider_chain,\r\nDCA_PROVIDER_REMOVE, NULL);\r\nINIT_LIST_HEAD(&unregistered_providers);\r\nspin_lock_irqsave(&dca_lock, flags);\r\nif (list_empty(&dca_domains)) {\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nreturn;\r\n}\r\ndomain = list_first_entry(&dca_domains, struct dca_domain, node);\r\nlist_for_each_entry_safe(dca, _dca, &domain->dca_providers, node)\r\nlist_move(&dca->node, &unregistered_providers);\r\ndca_free_domain(domain);\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nlist_for_each_entry_safe(dca, _dca, &unregistered_providers, node) {\r\ndca_sysfs_remove_provider(dca);\r\nlist_del(&dca->node);\r\n}\r\n}\r\nstatic struct dca_domain *dca_find_domain(struct pci_bus *rc)\r\n{\r\nstruct dca_domain *domain;\r\nlist_for_each_entry(domain, &dca_domains, node)\r\nif (domain->pci_rc == rc)\r\nreturn domain;\r\nreturn NULL;\r\n}\r\nstatic struct dca_domain *dca_get_domain(struct device *dev)\r\n{\r\nstruct pci_bus *rc;\r\nstruct dca_domain *domain;\r\nrc = dca_pci_rc_from_dev(dev);\r\ndomain = dca_find_domain(rc);\r\nif (!domain) {\r\nif (dca_provider_ioat_ver_3_0(dev) && !list_empty(&dca_domains)) {\r\ndca_providers_blocked = 1;\r\n} else {\r\ndomain = dca_allocate_domain(rc);\r\nif (domain)\r\nlist_add(&domain->node, &dca_domains);\r\n}\r\n}\r\nreturn domain;\r\n}\r\nstatic struct dca_provider *dca_find_provider_by_dev(struct device *dev)\r\n{\r\nstruct dca_provider *dca;\r\nstruct pci_bus *rc;\r\nstruct dca_domain *domain;\r\nif (dev) {\r\nrc = dca_pci_rc_from_dev(dev);\r\ndomain = dca_find_domain(rc);\r\nif (!domain)\r\nreturn NULL;\r\n} else {\r\nif (!list_empty(&dca_domains))\r\ndomain = list_first_entry(&dca_domains,\r\nstruct dca_domain,\r\nnode);\r\nelse\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(dca, &domain->dca_providers, node)\r\nif ((!dev) || (dca->ops->dev_managed(dca, dev)))\r\nreturn dca;\r\nreturn NULL;\r\n}\r\nint dca_add_requester(struct device *dev)\r\n{\r\nstruct dca_provider *dca;\r\nint err, slot = -ENODEV;\r\nunsigned long flags;\r\nstruct pci_bus *pci_rc;\r\nstruct dca_domain *domain;\r\nif (!dev)\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&dca_lock, flags);\r\ndca = dca_find_provider_by_dev(dev);\r\nif (dca) {\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nreturn -EEXIST;\r\n}\r\npci_rc = dca_pci_rc_from_dev(dev);\r\ndomain = dca_find_domain(pci_rc);\r\nif (!domain) {\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nreturn -ENODEV;\r\n}\r\nlist_for_each_entry(dca, &domain->dca_providers, node) {\r\nslot = dca->ops->add_requester(dca, dev);\r\nif (slot >= 0)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nif (slot < 0)\r\nreturn slot;\r\nerr = dca_sysfs_add_req(dca, dev, slot);\r\nif (err) {\r\nspin_lock_irqsave(&dca_lock, flags);\r\nif (dca == dca_find_provider_by_dev(dev))\r\ndca->ops->remove_requester(dca, dev);\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint dca_remove_requester(struct device *dev)\r\n{\r\nstruct dca_provider *dca;\r\nint slot;\r\nunsigned long flags;\r\nif (!dev)\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&dca_lock, flags);\r\ndca = dca_find_provider_by_dev(dev);\r\nif (!dca) {\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nreturn -ENODEV;\r\n}\r\nslot = dca->ops->remove_requester(dca, dev);\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nif (slot < 0)\r\nreturn slot;\r\ndca_sysfs_remove_req(dca, slot);\r\nreturn 0;\r\n}\r\nu8 dca_common_get_tag(struct device *dev, int cpu)\r\n{\r\nstruct dca_provider *dca;\r\nu8 tag;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dca_lock, flags);\r\ndca = dca_find_provider_by_dev(dev);\r\nif (!dca) {\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nreturn -ENODEV;\r\n}\r\ntag = dca->ops->get_tag(dca, dev, cpu);\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nreturn tag;\r\n}\r\nu8 dca3_get_tag(struct device *dev, int cpu)\r\n{\r\nif (!dev)\r\nreturn -EFAULT;\r\nreturn dca_common_get_tag(dev, cpu);\r\n}\r\nu8 dca_get_tag(int cpu)\r\n{\r\nstruct device *dev = NULL;\r\nreturn dca_common_get_tag(dev, cpu);\r\n}\r\nstruct dca_provider *alloc_dca_provider(struct dca_ops *ops, int priv_size)\r\n{\r\nstruct dca_provider *dca;\r\nint alloc_size;\r\nalloc_size = (sizeof(*dca) + priv_size);\r\ndca = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!dca)\r\nreturn NULL;\r\ndca->ops = ops;\r\nreturn dca;\r\n}\r\nvoid free_dca_provider(struct dca_provider *dca)\r\n{\r\nkfree(dca);\r\n}\r\nint register_dca_provider(struct dca_provider *dca, struct device *dev)\r\n{\r\nint err;\r\nunsigned long flags;\r\nstruct dca_domain *domain;\r\nspin_lock_irqsave(&dca_lock, flags);\r\nif (dca_providers_blocked) {\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nreturn -ENODEV;\r\n}\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nerr = dca_sysfs_add_provider(dca, dev);\r\nif (err)\r\nreturn err;\r\nspin_lock_irqsave(&dca_lock, flags);\r\ndomain = dca_get_domain(dev);\r\nif (!domain) {\r\nif (dca_providers_blocked) {\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\ndca_sysfs_remove_provider(dca);\r\nunregister_dca_providers();\r\n} else {\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\n}\r\nreturn -ENODEV;\r\n}\r\nlist_add(&dca->node, &domain->dca_providers);\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\nblocking_notifier_call_chain(&dca_provider_chain,\r\nDCA_PROVIDER_ADD, NULL);\r\nreturn 0;\r\n}\r\nvoid unregister_dca_provider(struct dca_provider *dca, struct device *dev)\r\n{\r\nunsigned long flags;\r\nstruct pci_bus *pci_rc;\r\nstruct dca_domain *domain;\r\nblocking_notifier_call_chain(&dca_provider_chain,\r\nDCA_PROVIDER_REMOVE, NULL);\r\nspin_lock_irqsave(&dca_lock, flags);\r\nlist_del(&dca->node);\r\npci_rc = dca_pci_rc_from_dev(dev);\r\ndomain = dca_find_domain(pci_rc);\r\nif (list_empty(&domain->dca_providers))\r\ndca_free_domain(domain);\r\nspin_unlock_irqrestore(&dca_lock, flags);\r\ndca_sysfs_remove_provider(dca);\r\n}\r\nvoid dca_register_notify(struct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_register(&dca_provider_chain, nb);\r\n}\r\nvoid dca_unregister_notify(struct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_unregister(&dca_provider_chain, nb);\r\n}\r\nstatic int __init dca_init(void)\r\n{\r\npr_info("dca service started, version %s\n", DCA_VERSION);\r\nreturn dca_sysfs_init();\r\n}\r\nstatic void __exit dca_exit(void)\r\n{\r\ndca_sysfs_exit();\r\n}
