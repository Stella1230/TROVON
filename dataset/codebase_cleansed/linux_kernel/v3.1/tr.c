static inline unsigned long rif_hash(const unsigned char *addr)\r\n{\r\nunsigned long x;\r\nx = addr[0];\r\nx = (x << 2) ^ addr[1];\r\nx = (x << 2) ^ addr[2];\r\nx = (x << 2) ^ addr[3];\r\nx = (x << 2) ^ addr[4];\r\nx = (x << 2) ^ addr[5];\r\nx ^= x >> 8;\r\nreturn x & (RIF_TABLE_SIZE - 1);\r\n}\r\nstatic int tr_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned len)\r\n{\r\nstruct trh_hdr *trh;\r\nint hdr_len;\r\nif (type == ETH_P_IP || type == ETH_P_IPV6 || type == ETH_P_ARP)\r\n{\r\nstruct trllc *trllc;\r\nhdr_len = sizeof(struct trh_hdr) + sizeof(struct trllc);\r\ntrh = (struct trh_hdr *)skb_push(skb, hdr_len);\r\ntrllc = (struct trllc *)(trh+1);\r\ntrllc->dsap = trllc->ssap = EXTENDED_SAP;\r\ntrllc->llc = UI_CMD;\r\ntrllc->protid[0] = trllc->protid[1] = trllc->protid[2] = 0x00;\r\ntrllc->ethertype = htons(type);\r\n}\r\nelse\r\n{\r\nhdr_len = sizeof(struct trh_hdr);\r\ntrh = (struct trh_hdr *)skb_push(skb, hdr_len);\r\n}\r\ntrh->ac=AC;\r\ntrh->fc=LLC_FRAME;\r\nif(saddr)\r\nmemcpy(trh->saddr,saddr,dev->addr_len);\r\nelse\r\nmemcpy(trh->saddr,dev->dev_addr,dev->addr_len);\r\nif(daddr)\r\n{\r\nmemcpy(trh->daddr,daddr,dev->addr_len);\r\ntr_source_route(skb, trh, dev);\r\nreturn hdr_len;\r\n}\r\nreturn -hdr_len;\r\n}\r\nstatic int tr_rebuild_header(struct sk_buff *skb)\r\n{\r\nstruct trh_hdr *trh=(struct trh_hdr *)skb->data;\r\nstruct trllc *trllc=(struct trllc *)(skb->data+sizeof(struct trh_hdr));\r\nstruct net_device *dev = skb->dev;\r\nif(trllc->ethertype != htons(ETH_P_IP)) {\r\nprintk("tr_rebuild_header: Don't know how to resolve type %04X addresses ?\n", ntohs(trllc->ethertype));\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_INET\r\nif(arp_find(trh->daddr, skb)) {\r\nreturn 1;\r\n}\r\nelse\r\n#endif\r\n{\r\ntr_source_route(skb,trh,dev);\r\nreturn 0;\r\n}\r\n}\r\n__be16 tr_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct trh_hdr *trh;\r\nstruct trllc *trllc;\r\nunsigned riflen=0;\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\ntrh = tr_hdr(skb);\r\nif(trh->saddr[0] & TR_RII)\r\nriflen = (ntohs(trh->rcf) & TR_RCF_LEN_MASK) >> 8;\r\ntrllc = (struct trllc *)(skb->data+sizeof(struct trh_hdr)-TR_MAXRIFLEN+riflen);\r\nskb_pull(skb,sizeof(struct trh_hdr)-TR_MAXRIFLEN+riflen);\r\nif(*trh->daddr & 0x80)\r\n{\r\nif(!memcmp(trh->daddr,dev->broadcast,TR_ALEN))\r\nskb->pkt_type=PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type=PACKET_MULTICAST;\r\n}\r\nelse if ( (trh->daddr[0] & 0x01) && (trh->daddr[1] & 0x00) && (trh->daddr[2] & 0x5E))\r\n{\r\nskb->pkt_type=PACKET_MULTICAST;\r\n}\r\nelse if(dev->flags & IFF_PROMISC)\r\n{\r\nif(memcmp(trh->daddr, dev->dev_addr, TR_ALEN))\r\nskb->pkt_type=PACKET_OTHERHOST;\r\n}\r\nif ((skb->pkt_type != PACKET_BROADCAST) &&\r\n(skb->pkt_type != PACKET_MULTICAST))\r\ntr_add_rif_info(trh,dev) ;\r\nif (trllc->dsap == EXTENDED_SAP &&\r\n(trllc->ethertype == htons(ETH_P_IP) ||\r\ntrllc->ethertype == htons(ETH_P_IPV6) ||\r\ntrllc->ethertype == htons(ETH_P_ARP)))\r\n{\r\nskb_pull(skb, sizeof(struct trllc));\r\nreturn trllc->ethertype;\r\n}\r\nreturn htons(ETH_P_TR_802_2);\r\n}\r\nvoid tr_source_route(struct sk_buff *skb,struct trh_hdr *trh,\r\nstruct net_device *dev)\r\n{\r\nint slack;\r\nunsigned int hash;\r\nstruct rif_cache *entry;\r\nunsigned char *olddata;\r\nunsigned long flags;\r\nstatic const unsigned char mcast_func_addr[]\r\n= {0xC0,0x00,0x00,0x04,0x00,0x00};\r\nspin_lock_irqsave(&rif_lock, flags);\r\nif( (!memcmp(&(trh->daddr[0]),&(dev->broadcast[0]),TR_ALEN)) ||\r\n(!memcmp(&(trh->daddr[0]),&(mcast_func_addr[0]), TR_ALEN)) )\r\n{\r\ntrh->rcf=htons((((sizeof(trh->rcf)) << 8) & TR_RCF_LEN_MASK)\r\n| TR_RCF_FRAME2K | TR_RCF_LIMITED_BROADCAST);\r\ntrh->saddr[0]|=TR_RII;\r\n}\r\nelse\r\n{\r\nhash = rif_hash(trh->daddr);\r\nfor(entry=rif_table[hash];entry && memcmp(&(entry->addr[0]),&(trh->daddr[0]),TR_ALEN);entry=entry->next);\r\nif(entry)\r\n{\r\n#if TR_SR_DEBUG\r\nprintk("source routing for %pM\n", trh->daddr);\r\n#endif\r\nif(!entry->local_ring && (ntohs(entry->rcf) & TR_RCF_LEN_MASK) >> 8)\r\n{\r\ntrh->rcf=entry->rcf;\r\nmemcpy(&trh->rseg[0],&entry->rseg[0],8*sizeof(unsigned short));\r\ntrh->rcf^=htons(TR_RCF_DIR_BIT);\r\ntrh->rcf&=htons(0x1fff);\r\ntrh->saddr[0]|=TR_RII;\r\n#if TR_SR_DEBUG\r\nprintk("entry found with rcf %04x\n", entry->rcf);\r\n}\r\nelse\r\n{\r\nprintk("entry found but without rcf length, local=%02x\n", entry->local_ring);\r\n#endif\r\n}\r\nentry->last_used=jiffies;\r\n}\r\nelse\r\n{\r\ntrh->rcf=htons((((sizeof(trh->rcf)) << 8) & TR_RCF_LEN_MASK)\r\n| TR_RCF_FRAME2K | TR_RCF_LIMITED_BROADCAST);\r\ntrh->saddr[0]|=TR_RII;\r\n#if TR_SR_DEBUG\r\nprintk("no entry in rif table found - broadcasting frame\n");\r\n#endif\r\n}\r\n}\r\nif (!(trh->saddr[0] & 0x80))\r\nslack = 18;\r\nelse\r\nslack = 18 - ((ntohs(trh->rcf) & TR_RCF_LEN_MASK)>>8);\r\nolddata = skb->data;\r\nspin_unlock_irqrestore(&rif_lock, flags);\r\nskb_pull(skb, slack);\r\nmemmove(skb->data, olddata, sizeof(struct trh_hdr) - slack);\r\n}\r\nstatic void tr_add_rif_info(struct trh_hdr *trh, struct net_device *dev)\r\n{\r\nunsigned int hash, rii_p = 0;\r\nunsigned long flags;\r\nstruct rif_cache *entry;\r\nunsigned char saddr0;\r\nspin_lock_irqsave(&rif_lock, flags);\r\nsaddr0 = trh->saddr[0];\r\nif(trh->saddr[0] & TR_RII)\r\n{\r\ntrh->saddr[0]&=0x7f;\r\nif (((ntohs(trh->rcf) & TR_RCF_LEN_MASK) >> 8) > 2)\r\n{\r\nrii_p = 1;\r\n}\r\n}\r\nhash = rif_hash(trh->saddr);\r\nfor(entry=rif_table[hash];entry && memcmp(&(entry->addr[0]),&(trh->saddr[0]),TR_ALEN);entry=entry->next);\r\nif(entry==NULL)\r\n{\r\n#if TR_SR_DEBUG\r\nprintk("adding rif_entry: addr:%pM rcf:%04X\n",\r\ntrh->saddr, ntohs(trh->rcf));\r\n#endif\r\nentry=kmalloc(sizeof(struct rif_cache),GFP_ATOMIC);\r\nif(!entry)\r\n{\r\nprintk(KERN_DEBUG "tr.c: Couldn't malloc rif cache entry !\n");\r\nspin_unlock_irqrestore(&rif_lock, flags);\r\nreturn;\r\n}\r\nmemcpy(&(entry->addr[0]),&(trh->saddr[0]),TR_ALEN);\r\nentry->iface = dev->ifindex;\r\nentry->next=rif_table[hash];\r\nentry->last_used=jiffies;\r\nrif_table[hash]=entry;\r\nif (rii_p)\r\n{\r\nentry->rcf = trh->rcf & htons((unsigned short)~TR_RCF_BROADCAST_MASK);\r\nmemcpy(&(entry->rseg[0]),&(trh->rseg[0]),8*sizeof(unsigned short));\r\nentry->local_ring = 0;\r\n}\r\nelse\r\n{\r\nentry->local_ring = 1;\r\n}\r\n}\r\nelse\r\n{\r\nif (!entry->local_ring)\r\nif (entry->rcf != (trh->rcf & htons((unsigned short)~TR_RCF_BROADCAST_MASK)) &&\r\n!(trh->rcf & htons(TR_RCF_BROADCAST_MASK)))\r\n{\r\n#if TR_SR_DEBUG\r\nprintk("updating rif_entry: addr:%pM rcf:%04X\n",\r\ntrh->saddr, ntohs(trh->rcf));\r\n#endif\r\nentry->rcf = trh->rcf & htons((unsigned short)~TR_RCF_BROADCAST_MASK);\r\nmemcpy(&(entry->rseg[0]),&(trh->rseg[0]),8*sizeof(unsigned short));\r\n}\r\nentry->last_used=jiffies;\r\n}\r\ntrh->saddr[0]=saddr0;\r\nspin_unlock_irqrestore(&rif_lock, flags);\r\n}\r\nstatic void rif_check_expire(unsigned long dummy)\r\n{\r\nint i;\r\nunsigned long flags, next_interval = jiffies + sysctl_tr_rif_timeout/2;\r\nspin_lock_irqsave(&rif_lock, flags);\r\nfor(i =0; i < RIF_TABLE_SIZE; i++) {\r\nstruct rif_cache *entry, **pentry;\r\npentry = rif_table+i;\r\nwhile((entry=*pentry) != NULL) {\r\nunsigned long expires\r\n= entry->last_used + sysctl_tr_rif_timeout;\r\nif (time_before_eq(expires, jiffies)) {\r\n*pentry = entry->next;\r\nkfree(entry);\r\n} else {\r\npentry = &entry->next;\r\nif (time_before(expires, next_interval))\r\nnext_interval = expires;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&rif_lock, flags);\r\nmod_timer(&rif_timer, next_interval);\r\n}\r\nstatic struct rif_cache *rif_get_idx(loff_t pos)\r\n{\r\nint i;\r\nstruct rif_cache *entry;\r\nloff_t off = 0;\r\nfor(i = 0; i < RIF_TABLE_SIZE; i++)\r\nfor(entry = rif_table[i]; entry; entry = entry->next) {\r\nif (off == pos)\r\nreturn entry;\r\n++off;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *rif_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(&rif_lock\r\nstatic void *rif_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nint i;\r\nstruct rif_cache *ent = v;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN) {\r\ni = -1;\r\ngoto scan;\r\n}\r\nif (ent->next)\r\nreturn ent->next;\r\ni = rif_hash(ent->addr);\r\nscan:\r\nwhile (++i < RIF_TABLE_SIZE) {\r\nif ((ent = rif_table[i]) != NULL)\r\nreturn ent;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void rif_seq_stop(struct seq_file *seq, void *v)\r\n__releases(&rif_lock\r\nstatic int rif_seq_show(struct seq_file *seq, void *v)\r\n{\r\nint j, rcf_len, segment, brdgnmb;\r\nstruct rif_cache *entry = v;\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"if TR address TTL rcf routing segments\n");\r\nelse {\r\nstruct net_device *dev = dev_get_by_index(&init_net, entry->iface);\r\nlong ttl = (long) (entry->last_used + sysctl_tr_rif_timeout)\r\n- (long) jiffies;\r\nseq_printf(seq, "%s %pM %7li ",\r\ndev?dev->name:"?",\r\nentry->addr,\r\nttl/HZ);\r\nif (entry->local_ring)\r\nseq_puts(seq, "local\n");\r\nelse {\r\nseq_printf(seq, "%04X", ntohs(entry->rcf));\r\nrcf_len = ((ntohs(entry->rcf) & TR_RCF_LEN_MASK)>>8)-2;\r\nif (rcf_len)\r\nrcf_len >>= 1;\r\nfor(j = 1; j < rcf_len; j++) {\r\nif(j==1) {\r\nsegment=ntohs(entry->rseg[j-1])>>4;\r\nseq_printf(seq," %03X",segment);\r\n}\r\nsegment=ntohs(entry->rseg[j])>>4;\r\nbrdgnmb=ntohs(entry->rseg[j-1])&0x00f;\r\nseq_printf(seq,"-%01X-%03X",brdgnmb,segment);\r\n}\r\nseq_putc(seq, '\n');\r\n}\r\nif (dev)\r\ndev_put(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rif_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &rif_seq_ops);\r\n}\r\nstatic void tr_setup(struct net_device *dev)\r\n{\r\ndev->header_ops = &tr_header_ops;\r\ndev->type = ARPHRD_IEEE802_TR;\r\ndev->hard_header_len = TR_HLEN;\r\ndev->mtu = 2000;\r\ndev->addr_len = TR_ALEN;\r\ndev->tx_queue_len = 100;\r\nmemset(dev->broadcast,0xFF, TR_ALEN);\r\ndev->flags = IFF_BROADCAST | IFF_MULTICAST ;\r\n}\r\nstruct net_device *alloc_trdev(int sizeof_priv)\r\n{\r\nreturn alloc_netdev(sizeof_priv, "tr%d", tr_setup);\r\n}\r\nstatic int __init rif_init(void)\r\n{\r\nrif_timer.expires = jiffies + sysctl_tr_rif_timeout;\r\nsetup_timer(&rif_timer, rif_check_expire, 0);\r\nadd_timer(&rif_timer);\r\n#ifdef CONFIG_SYSCTL\r\nregister_sysctl_paths(tr_path, tr_table);\r\n#endif\r\nproc_net_fops_create(&init_net, "tr_rif", S_IRUGO, &rif_seq_fops);\r\nreturn 0;\r\n}
