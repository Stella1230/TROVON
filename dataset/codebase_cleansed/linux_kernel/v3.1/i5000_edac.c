static void i5000_get_error_info(struct mem_ctl_info *mci,\r\nstruct i5000_error_info *info)\r\n{\r\nstruct i5000_pvt *pvt;\r\nu32 value;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->branchmap_werrors, FERR_FAT_FBD, &value);\r\nvalue &= (FERR_FAT_FBDCHAN | FERR_FAT_MASK);\r\nif (value & FERR_FAT_MASK) {\r\ninfo->ferr_fat_fbd = value;\r\npci_read_config_dword(pvt->branchmap_werrors,\r\nNERR_FAT_FBD, &info->nerr_fat_fbd);\r\npci_read_config_word(pvt->branchmap_werrors,\r\nNRECMEMA, &info->nrecmema);\r\npci_read_config_word(pvt->branchmap_werrors,\r\nNRECMEMB, &info->nrecmemb);\r\npci_write_config_dword(pvt->branchmap_werrors,\r\nFERR_FAT_FBD, value);\r\n} else {\r\ninfo->ferr_fat_fbd = 0;\r\ninfo->nerr_fat_fbd = 0;\r\ninfo->nrecmema = 0;\r\ninfo->nrecmemb = 0;\r\n}\r\npci_read_config_dword(pvt->branchmap_werrors, FERR_NF_FBD, &value);\r\nif (value & FERR_NF_MASK) {\r\ninfo->ferr_nf_fbd = value;\r\npci_read_config_dword(pvt->branchmap_werrors,\r\nNERR_NF_FBD, &info->nerr_nf_fbd);\r\npci_read_config_word(pvt->branchmap_werrors,\r\nRECMEMA, &info->recmema);\r\npci_read_config_dword(pvt->branchmap_werrors,\r\nRECMEMB, &info->recmemb);\r\npci_read_config_dword(pvt->branchmap_werrors,\r\nREDMEMB, &info->redmemb);\r\npci_write_config_dword(pvt->branchmap_werrors,\r\nFERR_NF_FBD, value);\r\n} else {\r\ninfo->ferr_nf_fbd = 0;\r\ninfo->nerr_nf_fbd = 0;\r\ninfo->recmema = 0;\r\ninfo->recmemb = 0;\r\ninfo->redmemb = 0;\r\n}\r\n}\r\nstatic void i5000_process_fatal_error_info(struct mem_ctl_info *mci,\r\nstruct i5000_error_info *info,\r\nint handle_errors)\r\n{\r\nchar msg[EDAC_MC_LABEL_LEN + 1 + 160];\r\nchar *specific = NULL;\r\nu32 allErrors;\r\nint branch;\r\nint channel;\r\nint bank;\r\nint rank;\r\nint rdwr;\r\nint ras, cas;\r\nallErrors = (info->ferr_fat_fbd & FERR_FAT_MASK);\r\nif (!allErrors)\r\nreturn;\r\nbranch = EXTRACT_FBDCHAN_INDX(info->ferr_fat_fbd);\r\nchannel = branch;\r\nbank = NREC_BANK(info->nrecmema);\r\nrank = NREC_RANK(info->nrecmema);\r\nrdwr = NREC_RDWR(info->nrecmema);\r\nras = NREC_RAS(info->nrecmemb);\r\ncas = NREC_CAS(info->nrecmemb);\r\ndebugf0("\t\tCSROW= %d Channels= %d,%d (Branch= %d "\r\n"DRAM Bank= %d rdwr= %s ras= %d cas= %d)\n",\r\nrank, channel, channel + 1, branch >> 1, bank,\r\nrdwr ? "Write" : "Read", ras, cas);\r\nswitch (allErrors) {\r\ncase FERR_FAT_M1ERR:\r\nspecific = "Alert on non-redundant retry or fast "\r\n"reset timeout";\r\nbreak;\r\ncase FERR_FAT_M2ERR:\r\nspecific = "Northbound CRC error on non-redundant "\r\n"retry";\r\nbreak;\r\ncase FERR_FAT_M3ERR:\r\n{\r\nstatic int done;\r\nif (done)\r\nreturn;\r\ndone++;\r\nspecific = ">Tmid Thermal event with intelligent "\r\n"throttling disabled";\r\n}\r\nbreak;\r\n}\r\nsnprintf(msg, sizeof(msg),\r\n"(Branch=%d DRAM-Bank=%d RDWR=%s RAS=%d CAS=%d "\r\n"FATAL Err=0x%x (%s))",\r\nbranch >> 1, bank, rdwr ? "Write" : "Read", ras, cas,\r\nallErrors, specific);\r\nedac_mc_handle_fbd_ue(mci, rank, channel, channel + 1, msg);\r\n}\r\nstatic void i5000_process_nonfatal_error_info(struct mem_ctl_info *mci,\r\nstruct i5000_error_info *info,\r\nint handle_errors)\r\n{\r\nchar msg[EDAC_MC_LABEL_LEN + 1 + 170];\r\nchar *specific = NULL;\r\nu32 allErrors;\r\nu32 ue_errors;\r\nu32 ce_errors;\r\nu32 misc_errors;\r\nint branch;\r\nint channel;\r\nint bank;\r\nint rank;\r\nint rdwr;\r\nint ras, cas;\r\nallErrors = (info->ferr_nf_fbd & FERR_NF_MASK);\r\nif (!allErrors)\r\nreturn;\r\nue_errors = allErrors & FERR_NF_UNCORRECTABLE;\r\nif (ue_errors) {\r\ndebugf0("\tUncorrected bits= 0x%x\n", ue_errors);\r\nbranch = EXTRACT_FBDCHAN_INDX(info->ferr_nf_fbd);\r\nchannel = branch & 2;\r\nbank = NREC_BANK(info->nrecmema);\r\nrank = NREC_RANK(info->nrecmema);\r\nrdwr = NREC_RDWR(info->nrecmema);\r\nras = NREC_RAS(info->nrecmemb);\r\ncas = NREC_CAS(info->nrecmemb);\r\ndebugf0\r\n("\t\tCSROW= %d Channels= %d,%d (Branch= %d "\r\n"DRAM Bank= %d rdwr= %s ras= %d cas= %d)\n",\r\nrank, channel, channel + 1, branch >> 1, bank,\r\nrdwr ? "Write" : "Read", ras, cas);\r\nswitch (ue_errors) {\r\ncase FERR_NF_M12ERR:\r\nspecific = "Non-Aliased Uncorrectable Patrol Data ECC";\r\nbreak;\r\ncase FERR_NF_M11ERR:\r\nspecific = "Non-Aliased Uncorrectable Spare-Copy "\r\n"Data ECC";\r\nbreak;\r\ncase FERR_NF_M10ERR:\r\nspecific = "Non-Aliased Uncorrectable Mirrored Demand "\r\n"Data ECC";\r\nbreak;\r\ncase FERR_NF_M9ERR:\r\nspecific = "Non-Aliased Uncorrectable Non-Mirrored "\r\n"Demand Data ECC";\r\nbreak;\r\ncase FERR_NF_M8ERR:\r\nspecific = "Aliased Uncorrectable Patrol Data ECC";\r\nbreak;\r\ncase FERR_NF_M7ERR:\r\nspecific = "Aliased Uncorrectable Spare-Copy Data ECC";\r\nbreak;\r\ncase FERR_NF_M6ERR:\r\nspecific = "Aliased Uncorrectable Mirrored Demand "\r\n"Data ECC";\r\nbreak;\r\ncase FERR_NF_M5ERR:\r\nspecific = "Aliased Uncorrectable Non-Mirrored Demand "\r\n"Data ECC";\r\nbreak;\r\ncase FERR_NF_M4ERR:\r\nspecific = "Uncorrectable Data ECC on Replay";\r\nbreak;\r\n}\r\nsnprintf(msg, sizeof(msg),\r\n"(Branch=%d DRAM-Bank=%d RDWR=%s RAS=%d "\r\n"CAS=%d, UE Err=0x%x (%s))",\r\nbranch >> 1, bank, rdwr ? "Write" : "Read", ras, cas,\r\nue_errors, specific);\r\nedac_mc_handle_fbd_ue(mci, rank, channel, channel + 1, msg);\r\n}\r\nce_errors = allErrors & FERR_NF_CORRECTABLE;\r\nif (ce_errors) {\r\ndebugf0("\tCorrected bits= 0x%x\n", ce_errors);\r\nbranch = EXTRACT_FBDCHAN_INDX(info->ferr_nf_fbd);\r\nchannel = 0;\r\nif (REC_ECC_LOCATOR_ODD(info->redmemb))\r\nchannel = 1;\r\nchannel += branch;\r\nbank = REC_BANK(info->recmema);\r\nrank = REC_RANK(info->recmema);\r\nrdwr = REC_RDWR(info->recmema);\r\nras = REC_RAS(info->recmemb);\r\ncas = REC_CAS(info->recmemb);\r\ndebugf0("\t\tCSROW= %d Channel= %d (Branch %d "\r\n"DRAM Bank= %d rdwr= %s ras= %d cas= %d)\n",\r\nrank, channel, branch >> 1, bank,\r\nrdwr ? "Write" : "Read", ras, cas);\r\nswitch (ce_errors) {\r\ncase FERR_NF_M17ERR:\r\nspecific = "Correctable Non-Mirrored Demand Data ECC";\r\nbreak;\r\ncase FERR_NF_M18ERR:\r\nspecific = "Correctable Mirrored Demand Data ECC";\r\nbreak;\r\ncase FERR_NF_M19ERR:\r\nspecific = "Correctable Spare-Copy Data ECC";\r\nbreak;\r\ncase FERR_NF_M20ERR:\r\nspecific = "Correctable Patrol Data ECC";\r\nbreak;\r\n}\r\nsnprintf(msg, sizeof(msg),\r\n"(Branch=%d DRAM-Bank=%d RDWR=%s RAS=%d "\r\n"CAS=%d, CE Err=0x%x (%s))", branch >> 1, bank,\r\nrdwr ? "Write" : "Read", ras, cas, ce_errors,\r\nspecific);\r\nedac_mc_handle_fbd_ce(mci, rank, channel, msg);\r\n}\r\nif (!misc_messages)\r\nreturn;\r\nmisc_errors = allErrors & (FERR_NF_NON_RETRY | FERR_NF_NORTH_CRC |\r\nFERR_NF_SPD_PROTOCOL | FERR_NF_DIMM_SPARE);\r\nif (misc_errors) {\r\nswitch (misc_errors) {\r\ncase FERR_NF_M13ERR:\r\nspecific = "Non-Retry or Redundant Retry FBD Memory "\r\n"Alert or Redundant Fast Reset Timeout";\r\nbreak;\r\ncase FERR_NF_M14ERR:\r\nspecific = "Non-Retry or Redundant Retry FBD "\r\n"Configuration Alert";\r\nbreak;\r\ncase FERR_NF_M15ERR:\r\nspecific = "Non-Retry or Redundant Retry FBD "\r\n"Northbound CRC error on read data";\r\nbreak;\r\ncase FERR_NF_M21ERR:\r\nspecific = "FBD Northbound CRC error on "\r\n"FBD Sync Status";\r\nbreak;\r\ncase FERR_NF_M22ERR:\r\nspecific = "SPD protocol error";\r\nbreak;\r\ncase FERR_NF_M27ERR:\r\nspecific = "DIMM-spare copy started";\r\nbreak;\r\ncase FERR_NF_M28ERR:\r\nspecific = "DIMM-spare copy completed";\r\nbreak;\r\n}\r\nbranch = EXTRACT_FBDCHAN_INDX(info->ferr_nf_fbd);\r\nsnprintf(msg, sizeof(msg),\r\n"(Branch=%d Err=%#x (%s))", branch >> 1,\r\nmisc_errors, specific);\r\nedac_mc_handle_fbd_ce(mci, 0, 0, msg);\r\n}\r\n}\r\nstatic void i5000_process_error_info(struct mem_ctl_info *mci,\r\nstruct i5000_error_info *info,\r\nint handle_errors)\r\n{\r\ni5000_process_fatal_error_info(mci, info, handle_errors);\r\ni5000_process_nonfatal_error_info(mci, info, handle_errors);\r\n}\r\nstatic void i5000_clear_error(struct mem_ctl_info *mci)\r\n{\r\nstruct i5000_error_info info;\r\ni5000_get_error_info(mci, &info);\r\n}\r\nstatic void i5000_check_error(struct mem_ctl_info *mci)\r\n{\r\nstruct i5000_error_info info;\r\ndebugf4("MC%d: %s: %s()\n", mci->mc_idx, __FILE__, __func__);\r\ni5000_get_error_info(mci, &info);\r\ni5000_process_error_info(mci, &info, 1);\r\n}\r\nstatic int i5000_get_devices(struct mem_ctl_info *mci, int dev_idx)\r\n{\r\nstruct i5000_pvt *pvt;\r\nstruct pci_dev *pdev;\r\npvt = mci->pvt_info;\r\npdev = NULL;\r\nwhile (1) {\r\npdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I5000_DEV16, pdev);\r\nif (pdev == NULL) {\r\ni5000_printk(KERN_ERR,\r\n"'system address,Process Bus' "\r\n"device not found:"\r\n"vendor 0x%x device 0x%x FUNC 1 "\r\n"(broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I5000_DEV16);\r\nreturn 1;\r\n}\r\nif (PCI_FUNC(pdev->devfn) == 1)\r\nbreak;\r\n}\r\npvt->branchmap_werrors = pdev;\r\npdev = NULL;\r\nwhile (1) {\r\npdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I5000_DEV16, pdev);\r\nif (pdev == NULL) {\r\ni5000_printk(KERN_ERR,\r\n"MC: 'branchmap,control,errors' "\r\n"device not found:"\r\n"vendor 0x%x device 0x%x Func 2 "\r\n"(broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I5000_DEV16);\r\npci_dev_put(pvt->branchmap_werrors);\r\nreturn 1;\r\n}\r\nif (PCI_FUNC(pdev->devfn) == 2)\r\nbreak;\r\n}\r\npvt->fsb_error_regs = pdev;\r\ndebugf1("System Address, processor bus- PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->system_address),\r\npvt->system_address->vendor, pvt->system_address->device);\r\ndebugf1("Branchmap, control and errors - PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->branchmap_werrors),\r\npvt->branchmap_werrors->vendor, pvt->branchmap_werrors->device);\r\ndebugf1("FSB Error Regs - PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->fsb_error_regs),\r\npvt->fsb_error_regs->vendor, pvt->fsb_error_regs->device);\r\npdev = NULL;\r\npdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_I5000_BRANCH_0, pdev);\r\nif (pdev == NULL) {\r\ni5000_printk(KERN_ERR,\r\n"MC: 'BRANCH 0' device not found:"\r\n"vendor 0x%x device 0x%x Func 0 (broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_I5000_BRANCH_0);\r\npci_dev_put(pvt->branchmap_werrors);\r\npci_dev_put(pvt->fsb_error_regs);\r\nreturn 1;\r\n}\r\npvt->branch_0 = pdev;\r\nif (pvt->maxch >= CHANNELS_PER_BRANCH) {\r\npdev = NULL;\r\npdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_I5000_BRANCH_1, pdev);\r\nif (pdev == NULL) {\r\ni5000_printk(KERN_ERR,\r\n"MC: 'BRANCH 1' device not found:"\r\n"vendor 0x%x device 0x%x Func 0 "\r\n"(broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_I5000_BRANCH_1);\r\npci_dev_put(pvt->branchmap_werrors);\r\npci_dev_put(pvt->fsb_error_regs);\r\npci_dev_put(pvt->branch_0);\r\nreturn 1;\r\n}\r\npvt->branch_1 = pdev;\r\n}\r\nreturn 0;\r\n}\r\nstatic void i5000_put_devices(struct mem_ctl_info *mci)\r\n{\r\nstruct i5000_pvt *pvt;\r\npvt = mci->pvt_info;\r\npci_dev_put(pvt->branchmap_werrors);\r\npci_dev_put(pvt->fsb_error_regs);\r\npci_dev_put(pvt->branch_0);\r\nif (pvt->maxch >= CHANNELS_PER_BRANCH)\r\npci_dev_put(pvt->branch_1);\r\n}\r\nstatic int determine_amb_present_reg(struct i5000_pvt *pvt, int channel)\r\n{\r\nint amb_present;\r\nif (channel < CHANNELS_PER_BRANCH) {\r\nif (channel & 0x1)\r\namb_present = pvt->b0_ambpresent1;\r\nelse\r\namb_present = pvt->b0_ambpresent0;\r\n} else {\r\nif (channel & 0x1)\r\namb_present = pvt->b1_ambpresent1;\r\nelse\r\namb_present = pvt->b1_ambpresent0;\r\n}\r\nreturn amb_present;\r\n}\r\nstatic int determine_mtr(struct i5000_pvt *pvt, int csrow, int channel)\r\n{\r\nint mtr;\r\nif (channel < CHANNELS_PER_BRANCH)\r\nmtr = pvt->b0_mtr[csrow >> 1];\r\nelse\r\nmtr = pvt->b1_mtr[csrow >> 1];\r\nreturn mtr;\r\n}\r\nstatic void decode_mtr(int slot_row, u16 mtr)\r\n{\r\nint ans;\r\nans = MTR_DIMMS_PRESENT(mtr);\r\ndebugf2("\tMTR%d=0x%x: DIMMs are %s\n", slot_row, mtr,\r\nans ? "Present" : "NOT Present");\r\nif (!ans)\r\nreturn;\r\ndebugf2("\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));\r\ndebugf2("\t\tNUMBANK: %d bank(s)\n", MTR_DRAM_BANKS(mtr));\r\ndebugf2("\t\tNUMRANK: %s\n", MTR_DIMM_RANK(mtr) ? "double" : "single");\r\ndebugf2("\t\tNUMROW: %s\n", numrow_toString[MTR_DIMM_ROWS(mtr)]);\r\ndebugf2("\t\tNUMCOL: %s\n", numcol_toString[MTR_DIMM_COLS(mtr)]);\r\n}\r\nstatic void handle_channel(struct i5000_pvt *pvt, int csrow, int channel,\r\nstruct i5000_dimm_info *dinfo)\r\n{\r\nint mtr;\r\nint amb_present_reg;\r\nint addrBits;\r\nmtr = determine_mtr(pvt, csrow, channel);\r\nif (MTR_DIMMS_PRESENT(mtr)) {\r\namb_present_reg = determine_amb_present_reg(pvt, channel);\r\nif (amb_present_reg & (1 << (csrow >> 1))) {\r\ndinfo->dual_rank = MTR_DIMM_RANK(mtr);\r\nif (!((dinfo->dual_rank == 0) &&\r\n((csrow & 0x1) == 0x1))) {\r\naddrBits = MTR_DRAM_BANKS_ADDR_BITS(mtr);\r\naddrBits += MTR_DIMM_ROWS_ADDR_BITS(mtr);\r\naddrBits += MTR_DIMM_COLS_ADDR_BITS(mtr);\r\naddrBits += 6;\r\naddrBits -= 20;\r\naddrBits -= 3;\r\ndinfo->megabytes = 1 << addrBits;\r\n}\r\n}\r\n}\r\n}\r\nstatic void calculate_dimm_size(struct i5000_pvt *pvt)\r\n{\r\nstruct i5000_dimm_info *dinfo;\r\nint csrow, max_csrows;\r\nchar *p, *mem_buffer;\r\nint space, n;\r\nint channel;\r\nspace = PAGE_SIZE;\r\nmem_buffer = p = kmalloc(space, GFP_KERNEL);\r\nif (p == NULL) {\r\ni5000_printk(KERN_ERR, "MC: %s:%s() kmalloc() failed\n",\r\n__FILE__, __func__);\r\nreturn;\r\n}\r\nn = snprintf(p, space, "\n");\r\np += n;\r\nspace -= n;\r\nmax_csrows = pvt->maxdimmperch * 2;\r\nfor (csrow = max_csrows - 1; csrow >= 0; csrow--) {\r\nif (csrow & 0x1) {\r\nn = snprintf(p, space, "---------------------------"\r\n"--------------------------------");\r\np += n;\r\nspace -= n;\r\ndebugf2("%s\n", mem_buffer);\r\np = mem_buffer;\r\nspace = PAGE_SIZE;\r\n}\r\nn = snprintf(p, space, "csrow %2d ", csrow);\r\np += n;\r\nspace -= n;\r\nfor (channel = 0; channel < pvt->maxch; channel++) {\r\ndinfo = &pvt->dimm_info[csrow][channel];\r\nhandle_channel(pvt, csrow, channel, dinfo);\r\nn = snprintf(p, space, "%4d MB | ", dinfo->megabytes);\r\np += n;\r\nspace -= n;\r\n}\r\nn = snprintf(p, space, "\n");\r\np += n;\r\nspace -= n;\r\n}\r\nn = snprintf(p, space, "---------------------------"\r\n"--------------------------------\n");\r\np += n;\r\nspace -= n;\r\nn = snprintf(p, space, " ");\r\np += n;\r\nspace -= n;\r\nfor (channel = 0; channel < pvt->maxch; channel++) {\r\nn = snprintf(p, space, "channel %d | ", channel);\r\np += n;\r\nspace -= n;\r\n}\r\nn = snprintf(p, space, "\n");\r\np += n;\r\nspace -= n;\r\ndebugf2("%s\n", mem_buffer);\r\nkfree(mem_buffer);\r\n}\r\nstatic void i5000_get_mc_regs(struct mem_ctl_info *mci)\r\n{\r\nstruct i5000_pvt *pvt;\r\nu32 actual_tolm;\r\nu16 limit;\r\nint slot_row;\r\nint maxch;\r\nint maxdimmperch;\r\nint way0, way1;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->system_address, AMBASE,\r\n(u32 *) & pvt->ambase);\r\npci_read_config_dword(pvt->system_address, AMBASE + sizeof(u32),\r\n((u32 *) & pvt->ambase) + sizeof(u32));\r\nmaxdimmperch = pvt->maxdimmperch;\r\nmaxch = pvt->maxch;\r\ndebugf2("AMBASE= 0x%lx MAXCH= %d MAX-DIMM-Per-CH= %d\n",\r\n(long unsigned int)pvt->ambase, pvt->maxch, pvt->maxdimmperch);\r\npci_read_config_word(pvt->branchmap_werrors, TOLM, &pvt->tolm);\r\npvt->tolm >>= 12;\r\ndebugf2("\nTOLM (number of 256M regions) =%u (0x%x)\n", pvt->tolm,\r\npvt->tolm);\r\nactual_tolm = pvt->tolm << 28;\r\ndebugf2("Actual TOLM byte addr=%u (0x%x)\n", actual_tolm, actual_tolm);\r\npci_read_config_word(pvt->branchmap_werrors, MIR0, &pvt->mir0);\r\npci_read_config_word(pvt->branchmap_werrors, MIR1, &pvt->mir1);\r\npci_read_config_word(pvt->branchmap_werrors, MIR2, &pvt->mir2);\r\nlimit = (pvt->mir0 >> 4) & 0x0FFF;\r\nway0 = pvt->mir0 & 0x1;\r\nway1 = pvt->mir0 & 0x2;\r\ndebugf2("MIR0: limit= 0x%x WAY1= %u WAY0= %x\n", limit, way1, way0);\r\nlimit = (pvt->mir1 >> 4) & 0x0FFF;\r\nway0 = pvt->mir1 & 0x1;\r\nway1 = pvt->mir1 & 0x2;\r\ndebugf2("MIR1: limit= 0x%x WAY1= %u WAY0= %x\n", limit, way1, way0);\r\nlimit = (pvt->mir2 >> 4) & 0x0FFF;\r\nway0 = pvt->mir2 & 0x1;\r\nway1 = pvt->mir2 & 0x2;\r\ndebugf2("MIR2: limit= 0x%x WAY1= %u WAY0= %x\n", limit, way1, way0);\r\nfor (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {\r\nint where = MTR0 + (slot_row * sizeof(u32));\r\npci_read_config_word(pvt->branch_0, where,\r\n&pvt->b0_mtr[slot_row]);\r\ndebugf2("MTR%d where=0x%x B0 value=0x%x\n", slot_row, where,\r\npvt->b0_mtr[slot_row]);\r\nif (pvt->maxch >= CHANNELS_PER_BRANCH) {\r\npci_read_config_word(pvt->branch_1, where,\r\n&pvt->b1_mtr[slot_row]);\r\ndebugf2("MTR%d where=0x%x B1 value=0x%x\n", slot_row,\r\nwhere, pvt->b1_mtr[slot_row]);\r\n} else {\r\npvt->b1_mtr[slot_row] = 0;\r\n}\r\n}\r\ndebugf2("\nMemory Technology Registers:\n");\r\ndebugf2(" Branch 0:\n");\r\nfor (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {\r\ndecode_mtr(slot_row, pvt->b0_mtr[slot_row]);\r\n}\r\npci_read_config_word(pvt->branch_0, AMB_PRESENT_0,\r\n&pvt->b0_ambpresent0);\r\ndebugf2("\t\tAMB-Branch 0-present0 0x%x:\n", pvt->b0_ambpresent0);\r\npci_read_config_word(pvt->branch_0, AMB_PRESENT_1,\r\n&pvt->b0_ambpresent1);\r\ndebugf2("\t\tAMB-Branch 0-present1 0x%x:\n", pvt->b0_ambpresent1);\r\nif (pvt->maxch < CHANNELS_PER_BRANCH) {\r\npvt->b1_ambpresent0 = 0;\r\npvt->b1_ambpresent1 = 0;\r\n} else {\r\ndebugf2(" Branch 1:\n");\r\nfor (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {\r\ndecode_mtr(slot_row, pvt->b1_mtr[slot_row]);\r\n}\r\npci_read_config_word(pvt->branch_1, AMB_PRESENT_0,\r\n&pvt->b1_ambpresent0);\r\ndebugf2("\t\tAMB-Branch 1-present0 0x%x:\n",\r\npvt->b1_ambpresent0);\r\npci_read_config_word(pvt->branch_1, AMB_PRESENT_1,\r\n&pvt->b1_ambpresent1);\r\ndebugf2("\t\tAMB-Branch 1-present1 0x%x:\n",\r\npvt->b1_ambpresent1);\r\n}\r\ncalculate_dimm_size(pvt);\r\n}\r\nstatic int i5000_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct i5000_pvt *pvt;\r\nstruct csrow_info *p_csrow;\r\nint empty, channel_count;\r\nint max_csrows;\r\nint mtr, mtr1;\r\nint csrow_megs;\r\nint channel;\r\nint csrow;\r\npvt = mci->pvt_info;\r\nchannel_count = pvt->maxch;\r\nmax_csrows = pvt->maxdimmperch * 2;\r\nempty = 1;\r\nfor (csrow = 0; csrow < max_csrows; csrow++) {\r\np_csrow = &mci->csrows[csrow];\r\np_csrow->csrow_idx = csrow;\r\nmtr = pvt->b0_mtr[csrow >> 1];\r\nmtr1 = pvt->b1_mtr[csrow >> 1];\r\nif (!MTR_DIMMS_PRESENT(mtr) && !MTR_DIMMS_PRESENT(mtr1))\r\ncontinue;\r\np_csrow->first_page = 0 + csrow * 20;\r\np_csrow->last_page = 9 + csrow * 20;\r\np_csrow->page_mask = 0xFFF;\r\np_csrow->grain = 8;\r\ncsrow_megs = 0;\r\nfor (channel = 0; channel < pvt->maxch; channel++) {\r\ncsrow_megs += pvt->dimm_info[csrow][channel].megabytes;\r\n}\r\np_csrow->nr_pages = csrow_megs << 8;\r\np_csrow->mtype = MEM_FB_DDR2;\r\nif (MTR_DRAM_WIDTH(mtr))\r\np_csrow->dtype = DEV_X8;\r\nelse\r\np_csrow->dtype = DEV_X4;\r\np_csrow->edac_mode = EDAC_S8ECD8ED;\r\nempty = 0;\r\n}\r\nreturn empty;\r\n}\r\nstatic void i5000_enable_error_reporting(struct mem_ctl_info *mci)\r\n{\r\nstruct i5000_pvt *pvt;\r\nu32 fbd_error_mask;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->branchmap_werrors, EMASK_FBD,\r\n&fbd_error_mask);\r\nfbd_error_mask &= ~(ENABLE_EMASK_ALL);\r\npci_write_config_dword(pvt->branchmap_werrors, EMASK_FBD,\r\nfbd_error_mask);\r\n}\r\nstatic void i5000_get_dimm_and_channel_counts(struct pci_dev *pdev,\r\nint *num_dimms_per_channel,\r\nint *num_channels)\r\n{\r\nu8 value;\r\npci_read_config_byte(pdev, MAXDIMMPERCH, &value);\r\n*num_dimms_per_channel = (int)value *2;\r\npci_read_config_byte(pdev, MAXCH, &value);\r\n*num_channels = (int)value;\r\n}\r\nstatic int i5000_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct i5000_pvt *pvt;\r\nint num_channels;\r\nint num_dimms_per_channel;\r\nint num_csrows;\r\ndebugf0("MC: %s: %s(), pdev bus %u dev=0x%x fn=0x%x\n",\r\n__FILE__, __func__,\r\npdev->bus->number,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\r\nif (PCI_FUNC(pdev->devfn) != 0)\r\nreturn -ENODEV;\r\ni5000_get_dimm_and_channel_counts(pdev, &num_dimms_per_channel,\r\n&num_channels);\r\nnum_csrows = num_dimms_per_channel * 2;\r\ndebugf0("MC: %s(): Number of - Channels= %d DIMMS= %d CSROWS= %d\n",\r\n__func__, num_channels, num_dimms_per_channel, num_csrows);\r\nmci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\nkobject_get(&mci->edac_mci_kobj);\r\ndebugf0("MC: %s: %s(): mci = %p\n", __FILE__, __func__, mci);\r\nmci->dev = &pdev->dev;\r\npvt = mci->pvt_info;\r\npvt->system_address = pdev;\r\npvt->maxch = num_channels;\r\npvt->maxdimmperch = num_dimms_per_channel;\r\nif (i5000_get_devices(mci, dev_idx))\r\ngoto fail0;\r\ni5000_get_mc_regs(mci);\r\nmci->mc_idx = 0;\r\nmci->mtype_cap = MEM_FLAG_FB_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE;\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\nmci->mod_name = "i5000_edac.c";\r\nmci->mod_ver = I5000_REVISION;\r\nmci->ctl_name = i5000_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->ctl_page_to_phys = NULL;\r\nmci->edac_check = i5000_check_error;\r\nif (i5000_init_csrows(mci)) {\r\ndebugf0("MC: Setting mci->edac_cap to EDAC_FLAG_NONE\n"\r\n" because i5000_init_csrows() returned nonzero "\r\n"value\n");\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\n} else {\r\ndebugf1("MC: Enable error reporting now\n");\r\ni5000_enable_error_reporting(mci);\r\n}\r\nif (edac_mc_add_mc(mci)) {\r\ndebugf0("MC: %s: %s(): failed edac_mc_add_mc()\n",\r\n__FILE__, __func__);\r\ngoto fail1;\r\n}\r\ni5000_clear_error(mci);\r\ni5000_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!i5000_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nreturn 0;\r\nfail1:\r\ni5000_put_devices(mci);\r\nfail0:\r\nkobject_put(&mci->edac_mci_kobj);\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit i5000_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint rc;\r\ndebugf0("MC: %s: %s()\n", __FILE__, __func__);\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nreturn i5000_probe1(pdev, id->driver_data);\r\n}\r\nstatic void __devexit i5000_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\ndebugf0("%s: %s()\n", __FILE__, __func__);\r\nif (i5000_pci)\r\nedac_pci_release_generic_ctl(i5000_pci);\r\nif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\r\nreturn;\r\ni5000_put_devices(mci);\r\nkobject_put(&mci->edac_mci_kobj);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i5000_init(void)\r\n{\r\nint pci_rc;\r\ndebugf2("MC: %s: %s()\n", __FILE__, __func__);\r\nopstate_init();\r\npci_rc = pci_register_driver(&i5000_driver);\r\nreturn (pci_rc < 0) ? pci_rc : 0;\r\n}\r\nstatic void __exit i5000_exit(void)\r\n{\r\ndebugf2("MC: %s: %s()\n", __FILE__, __func__);\r\npci_unregister_driver(&i5000_driver);\r\n}
