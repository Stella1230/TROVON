static int vicam_control_msg(struct gspca_dev *gspca_dev, u8 request,\r\nu16 value, u16 index, u8 *data, u16 len)\r\n{\r\nint ret;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nrequest,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, data, len, 1000);\r\nif (ret < 0)\r\nerr("control msg req %02X error %d", request, ret);\r\nreturn ret;\r\n}\r\nstatic int vicam_set_camera_power(struct gspca_dev *gspca_dev, int state)\r\n{\r\nint ret;\r\nret = vicam_control_msg(gspca_dev, 0x50, state, 0, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state)\r\nret = vicam_control_msg(gspca_dev, 0x55, 1, 0, NULL, 0);\r\nreturn ret;\r\n}\r\nstatic int vicam_read_frame(struct gspca_dev *gspca_dev, u8 *data, int size)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nint ret, unscaled_height, act_len = 0;\r\nu8 *req_data = gspca_dev->usb_buf;\r\nmemset(req_data, 0, 16);\r\nreq_data[0] = sd->ctrls[GAIN].val;\r\nif (gspca_dev->width == 256)\r\nreq_data[1] |= 0x01;\r\nif (gspca_dev->height <= 122) {\r\nreq_data[1] |= 0x10;\r\nunscaled_height = gspca_dev->height * 2;\r\n} else\r\nunscaled_height = gspca_dev->height;\r\nreq_data[2] = 0x90;\r\nif (unscaled_height <= 200)\r\nreq_data[3] = 0x06;\r\nelse if (unscaled_height <= 242)\r\nreq_data[3] = 0x07;\r\nelse\r\nreq_data[3] = 0x08;\r\nif (sd->ctrls[EXPOSURE].val < 256) {\r\nreq_data[4] = 255 - sd->ctrls[EXPOSURE].val;\r\nreq_data[5] = 0x00;\r\nreq_data[6] = 0x00;\r\nreq_data[7] = 0x01;\r\n} else {\r\nreq_data[4] = 0x00;\r\nreq_data[5] = 0x00;\r\nreq_data[6] = sd->ctrls[EXPOSURE].val & 0xFF;\r\nreq_data[7] = sd->ctrls[EXPOSURE].val >> 8;\r\n}\r\nreq_data[8] = ((244 - unscaled_height) / 2) & ~0x01;\r\nmutex_lock(&gspca_dev->usb_lock);\r\nret = vicam_control_msg(gspca_dev, 0x51, 0x80, 0, req_data, 16);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 0x81),\r\ndata, size, &act_len, 10000);\r\nif (ret < 0 || act_len != size) {\r\nerr("bulk read fail (%d) len %d/%d",\r\nret, act_len, size);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vicam_dostream(struct work_struct *work)\r\n{\r\nstruct sd *sd = container_of(work, struct sd, work_struct);\r\nstruct gspca_dev *gspca_dev = &sd->gspca_dev;\r\nint ret, frame_sz;\r\nu8 *buffer;\r\nframe_sz = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].sizeimage +\r\nHEADER_SIZE;\r\nbuffer = kmalloc(frame_sz, GFP_KERNEL | GFP_DMA);\r\nif (!buffer) {\r\nerr("Couldn't allocate USB buffer");\r\ngoto exit;\r\n}\r\nwhile (gspca_dev->present && gspca_dev->streaming) {\r\nret = vicam_read_frame(gspca_dev, buffer, frame_sz);\r\nif (ret < 0)\r\nbreak;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nbuffer + HEADER_SIZE,\r\nframe_sz - HEADER_SIZE);\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\n}\r\nexit:\r\nkfree(buffer);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct cam *cam = &gspca_dev->cam;\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ncam->bulk = 1;\r\ncam->bulk_size = 64;\r\ncam->cam_mode = vicam_mode;\r\ncam->nmodes = ARRAY_SIZE(vicam_mode);\r\ncam->ctrls = sd->ctrls;\r\nINIT_WORK(&sd->work_struct, vicam_dostream);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nint ret;\r\nconst struct ihex_binrec *rec;\r\nconst struct firmware *uninitialized_var(fw);\r\nu8 *firmware_buf;\r\nret = request_ihex_firmware(&fw, "vicam/firmware.fw",\r\n&gspca_dev->dev->dev);\r\nif (ret) {\r\nerr("Failed to load \"vicam/firmware.fw\": %d\n", ret);\r\nreturn ret;\r\n}\r\nfirmware_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!firmware_buf) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nfor (rec = (void *)fw->data; rec; rec = ihex_next_binrec(rec)) {\r\nmemcpy(firmware_buf, rec->data, be16_to_cpu(rec->len));\r\nret = vicam_control_msg(gspca_dev, 0xff, 0, 0, firmware_buf,\r\nbe16_to_cpu(rec->len));\r\nif (ret < 0)\r\nbreak;\r\n}\r\nkfree(firmware_buf);\r\nexit:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nint ret;\r\nret = vicam_set_camera_power(gspca_dev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nsd->work_thread = create_singlethread_workqueue(MODULE_NAME);\r\nqueue_work(sd->work_thread, &sd->work_struct);\r\nreturn 0;\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *dev = (struct sd *)gspca_dev;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\ndestroy_workqueue(dev->work_thread);\r\ndev->work_thread = NULL;\r\nmutex_lock(&gspca_dev->usb_lock);\r\nvicam_set_camera_power(gspca_dev, 0);\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id,\r\n&sd_desc,\r\nsizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int __init sd_mod_init(void)\r\n{\r\nreturn usb_register(&sd_driver);\r\n}\r\nstatic void __exit sd_mod_exit(void)\r\n{\r\nusb_deregister(&sd_driver);\r\n}
