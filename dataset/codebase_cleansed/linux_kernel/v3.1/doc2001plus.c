static void DoC_Delay(void __iomem * docptr, int cycles)\r\n{\r\nint i;\r\nfor (i = 0; (i < cycles); i++)\r\nWriteDOC(0, docptr, Mplus_NOP);\r\n}\r\nstatic int _DoC_WaitReady(void __iomem * docptr)\r\n{\r\nunsigned int c = 0xffff;\r\nDEBUG(MTD_DEBUG_LEVEL3,\r\n"_DoC_WaitReady called for out-of-line wait\n");\r\nwhile (((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK) && --c)\r\n;\r\nif (c == 0)\r\nDEBUG(MTD_DEBUG_LEVEL2, "_DoC_WaitReady timed out.\n");\r\nreturn (c == 0);\r\n}\r\nstatic inline int DoC_WaitReady(void __iomem * docptr)\r\n{\r\nint ret = 0;\r\nDoC_Delay(docptr, 4);\r\nif ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK)\r\nret = _DoC_WaitReady(docptr);\r\nreturn ret;\r\n}\r\nstatic inline void DoC_CheckASIC(void __iomem * docptr)\r\n{\r\nif ((ReadDOC(docptr, Mplus_DOCControl) & DOC_MODE_NORMAL) == 0) {\r\nWriteDOC((DOC_MODE_NORMAL | DOC_MODE_MDWREN), docptr, Mplus_DOCControl);\r\nWriteDOC(~(DOC_MODE_NORMAL | DOC_MODE_MDWREN), docptr, Mplus_CtrlConfirm);\r\n}\r\n}\r\nstatic void DoC_Command(void __iomem * docptr, unsigned char command,\r\nunsigned char xtraflags)\r\n{\r\nWriteDOC(command, docptr, Mplus_FlashCmd);\r\nWriteDOC(command, docptr, Mplus_WritePipeTerm);\r\nWriteDOC(command, docptr, Mplus_WritePipeTerm);\r\n}\r\nstatic inline void DoC_Address(struct DiskOnChip *doc, int numbytes,\r\nunsigned long ofs, unsigned char xtraflags1,\r\nunsigned char xtraflags2)\r\n{\r\nvoid __iomem * docptr = doc->virtadr;\r\nofs >>= doc->interleave;\r\nswitch (numbytes) {\r\ncase 1:\r\nWriteDOC(ofs & 0xff, docptr, Mplus_FlashAddress);\r\nbreak;\r\ncase 2:\r\nWriteDOC((ofs >> 9) & 0xff, docptr, Mplus_FlashAddress);\r\nWriteDOC((ofs >> 17) & 0xff, docptr, Mplus_FlashAddress);\r\nbreak;\r\ncase 3:\r\nWriteDOC(ofs & 0xff, docptr, Mplus_FlashAddress);\r\nWriteDOC((ofs >> 9) & 0xff, docptr, Mplus_FlashAddress);\r\nWriteDOC((ofs >> 17) & 0xff, docptr, Mplus_FlashAddress);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nWriteDOC(0x00, docptr, Mplus_WritePipeTerm);\r\nWriteDOC(0x00, docptr, Mplus_WritePipeTerm);\r\n}\r\nstatic int DoC_SelectChip(void __iomem * docptr, int chip)\r\n{\r\nreturn 0;\r\n}\r\nstatic int DoC_SelectFloor(void __iomem * docptr, int floor)\r\n{\r\nWriteDOC((floor & 0x3), docptr, Mplus_DeviceSelect);\r\nreturn 0;\r\n}\r\nstatic unsigned int DoC_GetDataOffset(struct mtd_info *mtd, loff_t *from)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nif (this->interleave) {\r\nunsigned int ofs = *from & 0x3ff;\r\nunsigned int cmd;\r\nif (ofs < 512) {\r\ncmd = NAND_CMD_READ0;\r\nofs &= 0x1ff;\r\n} else if (ofs < 1014) {\r\ncmd = NAND_CMD_READ1;\r\nofs = (ofs & 0x1ff) + 10;\r\n} else {\r\ncmd = NAND_CMD_READOOB;\r\nofs = ofs - 1014;\r\n}\r\n*from = (*from & ~0x3ff) | ofs;\r\nreturn cmd;\r\n} else {\r\nif ((*from) & 0x100)\r\nreturn NAND_CMD_READ1;\r\nreturn NAND_CMD_READ0;\r\n}\r\n}\r\nstatic unsigned int DoC_GetECCOffset(struct mtd_info *mtd, loff_t *from)\r\n{\r\nunsigned int ofs, cmd;\r\nif (*from & 0x200) {\r\ncmd = NAND_CMD_READOOB;\r\nofs = 10 + (*from & 0xf);\r\n} else {\r\ncmd = NAND_CMD_READ1;\r\nofs = (*from & 0xf);\r\n}\r\n*from = (*from & ~0x3ff) | ofs;\r\nreturn cmd;\r\n}\r\nstatic unsigned int DoC_GetFlagsOffset(struct mtd_info *mtd, loff_t *from)\r\n{\r\nunsigned int ofs, cmd;\r\ncmd = NAND_CMD_READ1;\r\nofs = (*from & 0x200) ? 8 : 6;\r\n*from = (*from & ~0x3ff) | ofs;\r\nreturn cmd;\r\n}\r\nstatic unsigned int DoC_GetHdrOffset(struct mtd_info *mtd, loff_t *from)\r\n{\r\nunsigned int ofs, cmd;\r\ncmd = NAND_CMD_READOOB;\r\nofs = (*from & 0x200) ? 24 : 16;\r\n*from = (*from & ~0x3ff) | ofs;\r\nreturn cmd;\r\n}\r\nstatic inline void MemReadDOC(void __iomem * docptr, unsigned char *buf, int len)\r\n{\r\n#ifndef USE_MEMCPY\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = ReadDOC(docptr, Mil_CDSN_IO + i);\r\n#else\r\nmemcpy_fromio(buf, docptr + DoC_Mil_CDSN_IO, len);\r\n#endif\r\n}\r\nstatic inline void MemWriteDOC(void __iomem * docptr, unsigned char *buf, int len)\r\n{\r\n#ifndef USE_MEMCPY\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nWriteDOC(buf[i], docptr, Mil_CDSN_IO + i);\r\n#else\r\nmemcpy_toio(docptr + DoC_Mil_CDSN_IO, buf, len);\r\n#endif\r\n}\r\nstatic int DoC_IdentChip(struct DiskOnChip *doc, int floor, int chip)\r\n{\r\nint mfr, id, i, j;\r\nvolatile char dummy;\r\nvoid __iomem * docptr = doc->virtadr;\r\nDoC_SelectFloor(docptr, floor);\r\nDoC_SelectChip(docptr, chip);\r\nWriteDOC((DOC_FLASH_CE | DOC_FLASH_WP), docptr, Mplus_FlashSelect);\r\nDoC_Command(docptr, NAND_CMD_RESET, 0);\r\nDoC_WaitReady(docptr);\r\nDoC_Command(docptr, NAND_CMD_READID, 0);\r\nDoC_Address(doc, 1, 0x00, 0, 0x00);\r\nWriteDOC(0, docptr, Mplus_FlashControl);\r\nDoC_WaitReady(docptr);\r\ndummy = ReadDOC(docptr, Mplus_ReadPipeInit);\r\ndummy = ReadDOC(docptr, Mplus_ReadPipeInit);\r\nmfr = ReadDOC(docptr, Mil_CDSN_IO);\r\nif (doc->interleave)\r\ndummy = ReadDOC(docptr, Mil_CDSN_IO);\r\nid = ReadDOC(docptr, Mil_CDSN_IO);\r\nif (doc->interleave)\r\ndummy = ReadDOC(docptr, Mil_CDSN_IO);\r\ndummy = ReadDOC(docptr, Mplus_LastDataRead);\r\ndummy = ReadDOC(docptr, Mplus_LastDataRead);\r\nWriteDOC(0, docptr, Mplus_FlashSelect);\r\nif (mfr == 0xff || mfr == 0)\r\nreturn 0;\r\nfor (i = 0; nand_flash_ids[i].name != NULL; i++) {\r\nif (id == nand_flash_ids[i].id) {\r\nfor (j = 0; nand_manuf_ids[j].id != 0x0; j++) {\r\nif (nand_manuf_ids[j].id == mfr)\r\nbreak;\r\n}\r\nprintk(KERN_INFO "Flash chip found: Manufacturer ID: %2.2X, "\r\n"Chip ID: %2.2X (%s:%s)\n", mfr, id,\r\nnand_manuf_ids[j].name, nand_flash_ids[i].name);\r\ndoc->mfr = mfr;\r\ndoc->id = id;\r\ndoc->chipshift = ffs((nand_flash_ids[i].chipsize << 20)) - 1;\r\ndoc->erasesize = nand_flash_ids[i].erasesize << doc->interleave;\r\nbreak;\r\n}\r\n}\r\nif (nand_flash_ids[i].name == NULL)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void DoC_ScanChips(struct DiskOnChip *this)\r\n{\r\nint floor, chip;\r\nint numchips[MAX_FLOORS_MPLUS];\r\nint ret;\r\nthis->numchips = 0;\r\nthis->mfr = 0;\r\nthis->id = 0;\r\nthis->interleave = 0;\r\nif (this->ChipID == DOC_ChipID_DocMilPlus32)\r\nthis->interleave = 1;\r\nif ( (this->interleave << 2) !=\r\n(ReadDOC(this->virtadr, Mplus_Configuration) & 4)) {\r\nu_char conf = ReadDOC(this->virtadr, Mplus_Configuration);\r\nprintk(KERN_NOTICE "Setting DiskOnChip Millennium Plus interleave to %s\n",\r\nthis->interleave?"on (16-bit)":"off (8-bit)");\r\nconf ^= 4;\r\nWriteDOC(conf, this->virtadr, Mplus_Configuration);\r\n}\r\nfor (floor = 0,ret = 1; floor < MAX_FLOORS_MPLUS; floor++) {\r\nnumchips[floor] = 0;\r\nfor (chip = 0; chip < MAX_CHIPS_MPLUS && ret != 0; chip++) {\r\nret = DoC_IdentChip(this, floor, chip);\r\nif (ret) {\r\nnumchips[floor]++;\r\nthis->numchips++;\r\n}\r\n}\r\n}\r\nif (!this->numchips) {\r\nprintk("No flash chips recognised.\n");\r\nreturn;\r\n}\r\nthis->chips = kmalloc(sizeof(struct Nand) * this->numchips, GFP_KERNEL);\r\nif (!this->chips){\r\nprintk("MTD: No memory for allocating chip info structures\n");\r\nreturn;\r\n}\r\nfor (floor = 0, ret = 0; floor < MAX_FLOORS_MPLUS; floor++) {\r\nfor (chip = 0 ; chip < numchips[floor] ; chip++) {\r\nthis->chips[ret].floor = floor;\r\nthis->chips[ret].chip = chip;\r\nthis->chips[ret].curadr = 0;\r\nthis->chips[ret].curmode = 0x50;\r\nret++;\r\n}\r\n}\r\nthis->totlen = this->numchips * (1 << this->chipshift);\r\nprintk(KERN_INFO "%d flash chips found. Total DiskOnChip size: %ld MiB\n",\r\nthis->numchips ,this->totlen >> 20);\r\n}\r\nstatic int DoCMilPlus_is_alias(struct DiskOnChip *doc1, struct DiskOnChip *doc2)\r\n{\r\nint tmp1, tmp2, retval;\r\nif (doc1->physadr == doc2->physadr)\r\nreturn 1;\r\ntmp1 = ReadDOC(doc1->virtadr, Mplus_AliasResolution);\r\ntmp2 = ReadDOC(doc2->virtadr, Mplus_AliasResolution);\r\nif (tmp1 != tmp2)\r\nreturn 0;\r\nWriteDOC((tmp1+1) % 0xff, doc1->virtadr, Mplus_AliasResolution);\r\ntmp2 = ReadDOC(doc2->virtadr, Mplus_AliasResolution);\r\nif (tmp2 == (tmp1+1) % 0xff)\r\nretval = 1;\r\nelse\r\nretval = 0;\r\nWriteDOC(tmp1, doc1->virtadr, Mplus_AliasResolution);\r\nreturn retval;\r\n}\r\nvoid DoCMilPlus_init(struct mtd_info *mtd)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nstruct DiskOnChip *old = NULL;\r\nif (docmilpluslist)\r\nold = docmilpluslist->priv;\r\nwhile (old) {\r\nif (DoCMilPlus_is_alias(this, old)) {\r\nprintk(KERN_NOTICE "Ignoring DiskOnChip Millennium "\r\n"Plus at 0x%lX - already configured\n",\r\nthis->physadr);\r\niounmap(this->virtadr);\r\nkfree(mtd);\r\nreturn;\r\n}\r\nif (old->nextdoc)\r\nold = old->nextdoc->priv;\r\nelse\r\nold = NULL;\r\n}\r\nmtd->name = "DiskOnChip Millennium Plus";\r\nprintk(KERN_NOTICE "DiskOnChip Millennium Plus found at "\r\n"address 0x%lX\n", this->physadr);\r\nmtd->type = MTD_NANDFLASH;\r\nmtd->flags = MTD_CAP_NANDFLASH;\r\nmtd->size = 0;\r\nmtd->erasesize = 0;\r\nmtd->writesize = 512;\r\nmtd->oobsize = 16;\r\nmtd->owner = THIS_MODULE;\r\nmtd->erase = doc_erase;\r\nmtd->point = NULL;\r\nmtd->unpoint = NULL;\r\nmtd->read = doc_read;\r\nmtd->write = doc_write;\r\nmtd->read_oob = doc_read_oob;\r\nmtd->write_oob = doc_write_oob;\r\nmtd->sync = NULL;\r\nthis->totlen = 0;\r\nthis->numchips = 0;\r\nthis->curfloor = -1;\r\nthis->curchip = -1;\r\nDoC_ScanChips(this);\r\nif (!this->totlen) {\r\nkfree(mtd);\r\niounmap(this->virtadr);\r\n} else {\r\nthis->nextdoc = docmilpluslist;\r\ndocmilpluslist = mtd;\r\nmtd->size = this->totlen;\r\nmtd->erasesize = this->erasesize;\r\nmtd_device_register(mtd, NULL, 0);\r\nreturn;\r\n}\r\n}\r\nstatic int doc_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nint ret, i;\r\nvolatile char dummy;\r\nloff_t fofs;\r\nunsigned char syndrome[6], eccbuf[6];\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem * docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[from >> (this->chipshift)];\r\nif (from >= this->totlen)\r\nreturn -EINVAL;\r\nif (from + len > ((from | 0x1ff) + 1))\r\nlen = ((from | 0x1ff) + 1) - from;\r\nDoC_CheckASIC(docptr);\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nWriteDOC((DOC_FLASH_CE | DOC_FLASH_WP), docptr, Mplus_FlashSelect);\r\nDoC_Command(docptr, NAND_CMD_RESET, 0);\r\nDoC_WaitReady(docptr);\r\nfofs = from;\r\nDoC_Command(docptr, DoC_GetDataOffset(mtd, &fofs), 0);\r\nDoC_Address(this, 3, fofs, 0, 0x00);\r\nWriteDOC(0, docptr, Mplus_FlashControl);\r\nDoC_WaitReady(docptr);\r\nWriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);\r\nWriteDOC(DOC_ECC_EN, docptr, Mplus_ECCConf);\r\n*retlen = len;\r\nret = 0;\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nMemReadDOC(docptr, buf, len);\r\nMemReadDOC(docptr, eccbuf, 4);\r\neccbuf[4] = ReadDOC(docptr, Mplus_LastDataRead);\r\neccbuf[5] = ReadDOC(docptr, Mplus_LastDataRead);\r\ndummy = ReadDOC(docptr, Mplus_ECCConf);\r\ndummy = ReadDOC(docptr, Mplus_ECCConf);\r\nif (ReadDOC(docptr, Mplus_ECCConf) & 0x80) {\r\nint nb_errors;\r\n#ifdef ECC_DEBUG\r\nprintk("DiskOnChip ECC Error: Read at %lx\n", (long)from);\r\n#endif\r\nfor (i = 0; i < 6; i++)\r\nsyndrome[i] = ReadDOC(docptr, Mplus_ECCSyndrome0 + i);\r\nnb_errors = doc_decode_ecc(buf, syndrome);\r\n#ifdef ECC_DEBUG\r\nprintk("ECC Errors corrected: %x\n", nb_errors);\r\n#endif\r\nif (nb_errors < 0) {\r\n#ifdef ECC_DEBUG\r\nprintk("%s(%d): Millennium Plus ECC error (from=0x%x:\n",\r\n__FILE__, __LINE__, (int)from);\r\nprintk(" syndrome= %02x:%02x:%02x:%02x:%02x:"\r\n"%02x\n",\r\nsyndrome[0], syndrome[1], syndrome[2],\r\nsyndrome[3], syndrome[4], syndrome[5]);\r\nprintk(" eccbuf= %02x:%02x:%02x:%02x:%02x:"\r\n"%02x\n",\r\neccbuf[0], eccbuf[1], eccbuf[2],\r\neccbuf[3], eccbuf[4], eccbuf[5]);\r\n#endif\r\nret = -EIO;\r\n}\r\n}\r\n#ifdef PSYCHO_DEBUG\r\nprintk("ECC DATA at %lx: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",\r\n(long)from, eccbuf[0], eccbuf[1], eccbuf[2], eccbuf[3],\r\neccbuf[4], eccbuf[5]);\r\n#endif\r\nWriteDOC(DOC_ECC_DIS, docptr , Mplus_ECCConf);\r\nWriteDOC(0, docptr, Mplus_FlashSelect);\r\nreturn ret;\r\n}\r\nstatic int doc_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nint i, before, ret = 0;\r\nloff_t fto;\r\nvolatile char dummy;\r\nchar eccbuf[6];\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem * docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[to >> (this->chipshift)];\r\nif (to >= this->totlen)\r\nreturn -EINVAL;\r\nif ((to & 0x1ff) || (len != 0x200))\r\nreturn -EINVAL;\r\nbefore = (this->interleave && (to & 0x200));\r\nDoC_CheckASIC(docptr);\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nWriteDOC(DOC_FLASH_CE, docptr, Mplus_FlashSelect);\r\nDoC_Command(docptr, NAND_CMD_RESET, 0);\r\nDoC_WaitReady(docptr);\r\nfto = to;\r\nWriteDOC(DoC_GetDataOffset(mtd, &fto), docptr, Mplus_FlashCmd);\r\nif (before)\r\nfto -= 2;\r\nDoC_Command(docptr, NAND_CMD_SEQIN, 0x00);\r\nDoC_Address(this, 3, fto, 0x00, 0x00);\r\nWriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);\r\nif (before) {\r\nWriteDOC(0x55, docptr, Mil_CDSN_IO);\r\nWriteDOC(0x55, docptr, Mil_CDSN_IO);\r\n}\r\nWriteDOC(DOC_ECC_EN | DOC_ECC_RW, docptr, Mplus_ECCConf);\r\nMemWriteDOC(docptr, (unsigned char *) buf, len);\r\nDoC_Delay(docptr, 3);\r\nfor (i = 0; i < 6; i++)\r\neccbuf[i] = ReadDOC(docptr, Mplus_ECCSyndrome0 + i);\r\nWriteDOC(DOC_ECC_DIS, docptr, Mplus_ECCConf);\r\nMemWriteDOC(docptr, eccbuf, 6);\r\nif (!before) {\r\nWriteDOC(0x55, docptr, Mil_CDSN_IO+6);\r\nWriteDOC(0x55, docptr, Mil_CDSN_IO+7);\r\n}\r\n#ifdef PSYCHO_DEBUG\r\nprintk("OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",\r\n(long) to, eccbuf[0], eccbuf[1], eccbuf[2], eccbuf[3],\r\neccbuf[4], eccbuf[5]);\r\n#endif\r\nWriteDOC(0x00, docptr, Mplus_WritePipeTerm);\r\nWriteDOC(0x00, docptr, Mplus_WritePipeTerm);\r\nDoC_Command(docptr, NAND_CMD_PAGEPROG, 0x00);\r\nDoC_WaitReady(docptr);\r\nDoC_Command(docptr, NAND_CMD_STATUS, 0);\r\ndummy = ReadDOC(docptr, Mplus_ReadPipeInit);\r\ndummy = ReadDOC(docptr, Mplus_ReadPipeInit);\r\nDoC_Delay(docptr, 2);\r\nif ((dummy = ReadDOC(docptr, Mplus_LastDataRead)) & 1) {\r\nprintk("MTD: Error 0x%x programming at 0x%x\n", dummy, (int)to);\r\n*retlen = 0;\r\nret = -EIO;\r\n}\r\ndummy = ReadDOC(docptr, Mplus_LastDataRead);\r\nWriteDOC(0, docptr, Mplus_FlashSelect);\r\n*retlen = len;\r\nreturn ret;\r\n}\r\nstatic int doc_read_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nloff_t fofs, base;\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem * docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[ofs >> this->chipshift];\r\nsize_t i, size, got, want;\r\nuint8_t *buf = ops->oobbuf;\r\nsize_t len = ops->len;\r\nBUG_ON(ops->mode != MTD_OOB_PLACE);\r\nofs += ops->ooboffs;\r\nDoC_CheckASIC(docptr);\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nWriteDOC((DOC_FLASH_CE | DOC_FLASH_WP), docptr, Mplus_FlashSelect);\r\nWriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);\r\nDoC_WaitReady(docptr);\r\nif (len > 16)\r\nlen = 16;\r\ngot = 0;\r\nwant = len;\r\nfor (i = 0; ((i < 3) && (want > 0)); i++) {\r\nfofs = ofs;\r\nbase = ofs & 0xf;\r\nif (!this->interleave) {\r\nDoC_Command(docptr, NAND_CMD_READOOB, 0);\r\nsize = 16 - base;\r\n} else if (base < 6) {\r\nDoC_Command(docptr, DoC_GetECCOffset(mtd, &fofs), 0);\r\nsize = 6 - base;\r\n} else if (base < 8) {\r\nDoC_Command(docptr, DoC_GetFlagsOffset(mtd, &fofs), 0);\r\nsize = 8 - base;\r\n} else {\r\nDoC_Command(docptr, DoC_GetHdrOffset(mtd, &fofs), 0);\r\nsize = 16 - base;\r\n}\r\nif (size > want)\r\nsize = want;\r\nDoC_Address(this, 3, fofs, 0, 0x00);\r\nWriteDOC(0, docptr, Mplus_FlashControl);\r\nDoC_WaitReady(docptr);\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nMemReadDOC(docptr, &buf[got], size - 2);\r\nbuf[got + size - 2] = ReadDOC(docptr, Mplus_LastDataRead);\r\nbuf[got + size - 1] = ReadDOC(docptr, Mplus_LastDataRead);\r\nofs += size;\r\ngot += size;\r\nwant -= size;\r\n}\r\nWriteDOC(0, docptr, Mplus_FlashSelect);\r\nops->retlen = len;\r\nreturn 0;\r\n}\r\nstatic int doc_write_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nvolatile char dummy;\r\nloff_t fofs, base;\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem * docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[ofs >> this->chipshift];\r\nsize_t i, size, got, want;\r\nint ret = 0;\r\nuint8_t *buf = ops->oobbuf;\r\nsize_t len = ops->len;\r\nBUG_ON(ops->mode != MTD_OOB_PLACE);\r\nofs += ops->ooboffs;\r\nDoC_CheckASIC(docptr);\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nWriteDOC(DOC_FLASH_CE, docptr, Mplus_FlashSelect);\r\nif (len > 16)\r\nlen = 16;\r\ngot = 0;\r\nwant = len;\r\nfor (i = 0; ((i < 3) && (want > 0)); i++) {\r\nDoC_Command(docptr, NAND_CMD_RESET, 0);\r\nDoC_WaitReady(docptr);\r\nfofs = ofs;\r\nbase = ofs & 0x0f;\r\nif (!this->interleave) {\r\nWriteDOC(NAND_CMD_READOOB, docptr, Mplus_FlashCmd);\r\nsize = 16 - base;\r\n} else if (base < 6) {\r\nWriteDOC(DoC_GetECCOffset(mtd, &fofs), docptr, Mplus_FlashCmd);\r\nsize = 6 - base;\r\n} else if (base < 8) {\r\nWriteDOC(DoC_GetFlagsOffset(mtd, &fofs), docptr, Mplus_FlashCmd);\r\nsize = 8 - base;\r\n} else {\r\nWriteDOC(DoC_GetHdrOffset(mtd, &fofs), docptr, Mplus_FlashCmd);\r\nsize = 16 - base;\r\n}\r\nif (size > want)\r\nsize = want;\r\nDoC_Command(docptr, NAND_CMD_SEQIN, 0x00);\r\nDoC_Address(this, 3, fofs, 0, 0x00);\r\nWriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);\r\nMemWriteDOC(docptr, (unsigned char *) &buf[got], size);\r\nWriteDOC(0x00, docptr, Mplus_WritePipeTerm);\r\nWriteDOC(0x00, docptr, Mplus_WritePipeTerm);\r\nDoC_Command(docptr, NAND_CMD_PAGEPROG, 0x00);\r\nDoC_WaitReady(docptr);\r\nDoC_Command(docptr, NAND_CMD_STATUS, 0x00);\r\ndummy = ReadDOC(docptr, Mplus_ReadPipeInit);\r\ndummy = ReadDOC(docptr, Mplus_ReadPipeInit);\r\nDoC_Delay(docptr, 2);\r\nif ((dummy = ReadDOC(docptr, Mplus_LastDataRead)) & 1) {\r\nprintk("MTD: Error 0x%x programming oob at 0x%x\n",\r\ndummy, (int)ofs);\r\nops->retlen = 0;\r\nret = -EIO;\r\n}\r\ndummy = ReadDOC(docptr, Mplus_LastDataRead);\r\nofs += size;\r\ngot += size;\r\nwant -= size;\r\n}\r\nWriteDOC(0, docptr, Mplus_FlashSelect);\r\nops->retlen = len;\r\nreturn ret;\r\n}\r\nint doc_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nvolatile char dummy;\r\nstruct DiskOnChip *this = mtd->priv;\r\n__u32 ofs = instr->addr;\r\n__u32 len = instr->len;\r\nvoid __iomem * docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[ofs >> this->chipshift];\r\nDoC_CheckASIC(docptr);\r\nif (len != mtd->erasesize)\r\nprintk(KERN_WARNING "MTD: Erase not right size (%x != %x)n",\r\nlen, mtd->erasesize);\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\ninstr->state = MTD_ERASE_PENDING;\r\nWriteDOC(DOC_FLASH_CE, docptr, Mplus_FlashSelect);\r\nDoC_Command(docptr, NAND_CMD_RESET, 0x00);\r\nDoC_WaitReady(docptr);\r\nDoC_Command(docptr, NAND_CMD_ERASE1, 0);\r\nDoC_Address(this, 2, ofs, 0, 0x00);\r\nDoC_Command(docptr, NAND_CMD_ERASE2, 0);\r\nDoC_WaitReady(docptr);\r\ninstr->state = MTD_ERASING;\r\nDoC_Command(docptr, NAND_CMD_STATUS, 0);\r\ndummy = ReadDOC(docptr, Mplus_ReadPipeInit);\r\ndummy = ReadDOC(docptr, Mplus_ReadPipeInit);\r\nif ((dummy = ReadDOC(docptr, Mplus_LastDataRead)) & 1) {\r\nprintk("MTD: Error 0x%x erasing at 0x%x\n", dummy, ofs);\r\ninstr->state = MTD_ERASE_FAILED;\r\n} else {\r\ninstr->state = MTD_ERASE_DONE;\r\n}\r\ndummy = ReadDOC(docptr, Mplus_LastDataRead);\r\nWriteDOC(0, docptr, Mplus_FlashSelect);\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_doc2001plus(void)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct DiskOnChip *this;\r\nwhile ((mtd=docmilpluslist)) {\r\nthis = mtd->priv;\r\ndocmilpluslist = this->nextdoc;\r\nmtd_device_unregister(mtd);\r\niounmap(this->virtadr);\r\nkfree(this->chips);\r\nkfree(mtd);\r\n}\r\n}
