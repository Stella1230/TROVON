struct tick_sched *tick_get_tick_sched(int cpu)\r\n{\r\nreturn &per_cpu(tick_cpu_sched, cpu);\r\n}\r\nstatic void tick_do_update_jiffies64(ktime_t now)\r\n{\r\nunsigned long ticks = 0;\r\nktime_t delta;\r\ndelta = ktime_sub(now, last_jiffies_update);\r\nif (delta.tv64 < tick_period.tv64)\r\nreturn;\r\nwrite_seqlock(&xtime_lock);\r\ndelta = ktime_sub(now, last_jiffies_update);\r\nif (delta.tv64 >= tick_period.tv64) {\r\ndelta = ktime_sub(delta, tick_period);\r\nlast_jiffies_update = ktime_add(last_jiffies_update,\r\ntick_period);\r\nif (unlikely(delta.tv64 >= tick_period.tv64)) {\r\ns64 incr = ktime_to_ns(tick_period);\r\nticks = ktime_divns(delta, incr);\r\nlast_jiffies_update = ktime_add_ns(last_jiffies_update,\r\nincr * ticks);\r\n}\r\ndo_timer(++ticks);\r\ntick_next_period = ktime_add(last_jiffies_update, tick_period);\r\n}\r\nwrite_sequnlock(&xtime_lock);\r\n}\r\nstatic ktime_t tick_init_jiffy_update(void)\r\n{\r\nktime_t period;\r\nwrite_seqlock(&xtime_lock);\r\nif (last_jiffies_update.tv64 == 0)\r\nlast_jiffies_update = tick_next_period;\r\nperiod = last_jiffies_update;\r\nwrite_sequnlock(&xtime_lock);\r\nreturn period;\r\n}\r\nstatic int __init setup_tick_nohz(char *str)\r\n{\r\nif (!strcmp(str, "off"))\r\ntick_nohz_enabled = 0;\r\nelse if (!strcmp(str, "on"))\r\ntick_nohz_enabled = 1;\r\nelse\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void tick_nohz_update_jiffies(ktime_t now)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\r\nunsigned long flags;\r\ncpumask_clear_cpu(cpu, nohz_cpu_mask);\r\nts->idle_waketime = now;\r\nlocal_irq_save(flags);\r\ntick_do_update_jiffies64(now);\r\nlocal_irq_restore(flags);\r\ntouch_softlockup_watchdog();\r\n}\r\nstatic void\r\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\r\n{\r\nktime_t delta;\r\nif (ts->idle_active) {\r\ndelta = ktime_sub(now, ts->idle_entrytime);\r\nts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\r\nif (nr_iowait_cpu(cpu) > 0)\r\nts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\r\nts->idle_entrytime = now;\r\n}\r\nif (last_update_time)\r\n*last_update_time = ktime_to_us(now);\r\n}\r\nstatic void tick_nohz_stop_idle(int cpu, ktime_t now)\r\n{\r\nstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\r\nupdate_ts_time_stats(cpu, ts, now, NULL);\r\nts->idle_active = 0;\r\nsched_clock_idle_wakeup_event(0);\r\n}\r\nstatic ktime_t tick_nohz_start_idle(int cpu, struct tick_sched *ts)\r\n{\r\nktime_t now;\r\nnow = ktime_get();\r\nupdate_ts_time_stats(cpu, ts, now, NULL);\r\nts->idle_entrytime = now;\r\nts->idle_active = 1;\r\nsched_clock_idle_sleep_event();\r\nreturn now;\r\n}\r\nu64 get_cpu_idle_time_us(int cpu, u64 *last_update_time)\r\n{\r\nstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\r\nif (!tick_nohz_enabled)\r\nreturn -1;\r\nupdate_ts_time_stats(cpu, ts, ktime_get(), last_update_time);\r\nreturn ktime_to_us(ts->idle_sleeptime);\r\n}\r\nu64 get_cpu_iowait_time_us(int cpu, u64 *last_update_time)\r\n{\r\nstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\r\nif (!tick_nohz_enabled)\r\nreturn -1;\r\nupdate_ts_time_stats(cpu, ts, ktime_get(), last_update_time);\r\nreturn ktime_to_us(ts->iowait_sleeptime);\r\n}\r\nvoid tick_nohz_stop_sched_tick(int inidle)\r\n{\r\nunsigned long seq, last_jiffies, next_jiffies, delta_jiffies, flags;\r\nstruct tick_sched *ts;\r\nktime_t last_update, expires, now;\r\nstruct clock_event_device *dev = __get_cpu_var(tick_cpu_device).evtdev;\r\nu64 time_delta;\r\nint cpu;\r\nlocal_irq_save(flags);\r\ncpu = smp_processor_id();\r\nts = &per_cpu(tick_cpu_sched, cpu);\r\nif (!inidle && !ts->inidle)\r\ngoto end;\r\nts->inidle = 1;\r\nnow = tick_nohz_start_idle(cpu, ts);\r\nif (unlikely(!cpu_online(cpu))) {\r\nif (cpu == tick_do_timer_cpu)\r\ntick_do_timer_cpu = TICK_DO_TIMER_NONE;\r\n}\r\nif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\r\ngoto end;\r\nif (need_resched())\r\ngoto end;\r\nif (unlikely(local_softirq_pending() && cpu_online(cpu))) {\r\nstatic int ratelimit;\r\nif (ratelimit < 10) {\r\nprintk(KERN_ERR "NOHZ: local_softirq_pending %02x\n",\r\n(unsigned int) local_softirq_pending());\r\nratelimit++;\r\n}\r\ngoto end;\r\n}\r\nts->idle_calls++;\r\ndo {\r\nseq = read_seqbegin(&xtime_lock);\r\nlast_update = last_jiffies_update;\r\nlast_jiffies = jiffies;\r\ntime_delta = timekeeping_max_deferment();\r\n} while (read_seqretry(&xtime_lock, seq));\r\nif (rcu_needs_cpu(cpu) || printk_needs_cpu(cpu) ||\r\narch_needs_cpu(cpu)) {\r\nnext_jiffies = last_jiffies + 1;\r\ndelta_jiffies = 1;\r\n} else {\r\nnext_jiffies = get_next_timer_interrupt(last_jiffies);\r\ndelta_jiffies = next_jiffies - last_jiffies;\r\n}\r\nif (!ts->tick_stopped && delta_jiffies == 1)\r\ngoto out;\r\nif ((long)delta_jiffies >= 1) {\r\nif (cpu == tick_do_timer_cpu) {\r\ntick_do_timer_cpu = TICK_DO_TIMER_NONE;\r\nts->do_timer_last = 1;\r\n} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\r\ntime_delta = KTIME_MAX;\r\nts->do_timer_last = 0;\r\n} else if (!ts->do_timer_last) {\r\ntime_delta = KTIME_MAX;\r\n}\r\nif (likely(delta_jiffies < NEXT_TIMER_MAX_DELTA)) {\r\ntime_delta = min_t(u64, time_delta,\r\ntick_period.tv64 * delta_jiffies);\r\n}\r\nif (time_delta < KTIME_MAX)\r\nexpires = ktime_add_ns(last_update, time_delta);\r\nelse\r\nexpires.tv64 = KTIME_MAX;\r\nif (delta_jiffies > 1)\r\ncpumask_set_cpu(cpu, nohz_cpu_mask);\r\nif (ts->tick_stopped && ktime_equal(expires, dev->next_event))\r\ngoto out;\r\nif (!ts->tick_stopped) {\r\nselect_nohz_load_balancer(1);\r\nts->idle_tick = hrtimer_get_expires(&ts->sched_timer);\r\nts->tick_stopped = 1;\r\nts->idle_jiffies = last_jiffies;\r\nrcu_enter_nohz();\r\n}\r\nts->idle_sleeps++;\r\nts->idle_expires = expires;\r\nif (unlikely(expires.tv64 == KTIME_MAX)) {\r\nif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\r\nhrtimer_cancel(&ts->sched_timer);\r\ngoto out;\r\n}\r\nif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\r\nhrtimer_start(&ts->sched_timer, expires,\r\nHRTIMER_MODE_ABS_PINNED);\r\nif (hrtimer_active(&ts->sched_timer))\r\ngoto out;\r\n} else if (!tick_program_event(expires, 0))\r\ngoto out;\r\ntick_do_update_jiffies64(ktime_get());\r\ncpumask_clear_cpu(cpu, nohz_cpu_mask);\r\n}\r\nraise_softirq_irqoff(TIMER_SOFTIRQ);\r\nout:\r\nts->next_jiffies = next_jiffies;\r\nts->last_jiffies = last_jiffies;\r\nts->sleep_length = ktime_sub(dev->next_event, now);\r\nend:\r\nlocal_irq_restore(flags);\r\n}\r\nktime_t tick_nohz_get_sleep_length(void)\r\n{\r\nstruct tick_sched *ts = &__get_cpu_var(tick_cpu_sched);\r\nreturn ts->sleep_length;\r\n}\r\nstatic void tick_nohz_restart(struct tick_sched *ts, ktime_t now)\r\n{\r\nhrtimer_cancel(&ts->sched_timer);\r\nhrtimer_set_expires(&ts->sched_timer, ts->idle_tick);\r\nwhile (1) {\r\nhrtimer_forward(&ts->sched_timer, now, tick_period);\r\nif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\r\nhrtimer_start_expires(&ts->sched_timer,\r\nHRTIMER_MODE_ABS_PINNED);\r\nif (hrtimer_active(&ts->sched_timer))\r\nbreak;\r\n} else {\r\nif (!tick_program_event(\r\nhrtimer_get_expires(&ts->sched_timer), 0))\r\nbreak;\r\n}\r\ntick_do_update_jiffies64(now);\r\nnow = ktime_get();\r\n}\r\n}\r\nvoid tick_nohz_restart_sched_tick(void)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\r\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING\r\nunsigned long ticks;\r\n#endif\r\nktime_t now;\r\nlocal_irq_disable();\r\nif (ts->idle_active || (ts->inidle && ts->tick_stopped))\r\nnow = ktime_get();\r\nif (ts->idle_active)\r\ntick_nohz_stop_idle(cpu, now);\r\nif (!ts->inidle || !ts->tick_stopped) {\r\nts->inidle = 0;\r\nlocal_irq_enable();\r\nreturn;\r\n}\r\nts->inidle = 0;\r\nrcu_exit_nohz();\r\nselect_nohz_load_balancer(0);\r\ntick_do_update_jiffies64(now);\r\ncpumask_clear_cpu(cpu, nohz_cpu_mask);\r\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING\r\nticks = jiffies - ts->idle_jiffies;\r\nif (ticks && ticks < LONG_MAX)\r\naccount_idle_ticks(ticks);\r\n#endif\r\ntouch_softlockup_watchdog();\r\nts->tick_stopped = 0;\r\nts->idle_exittime = now;\r\ntick_nohz_restart(ts, now);\r\nlocal_irq_enable();\r\n}\r\nstatic int tick_nohz_reprogram(struct tick_sched *ts, ktime_t now)\r\n{\r\nhrtimer_forward(&ts->sched_timer, now, tick_period);\r\nreturn tick_program_event(hrtimer_get_expires(&ts->sched_timer), 0);\r\n}\r\nstatic void tick_nohz_handler(struct clock_event_device *dev)\r\n{\r\nstruct tick_sched *ts = &__get_cpu_var(tick_cpu_sched);\r\nstruct pt_regs *regs = get_irq_regs();\r\nint cpu = smp_processor_id();\r\nktime_t now = ktime_get();\r\ndev->next_event.tv64 = KTIME_MAX;\r\nif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE))\r\ntick_do_timer_cpu = cpu;\r\nif (tick_do_timer_cpu == cpu)\r\ntick_do_update_jiffies64(now);\r\nif (ts->tick_stopped) {\r\ntouch_softlockup_watchdog();\r\nts->idle_jiffies++;\r\n}\r\nupdate_process_times(user_mode(regs));\r\nprofile_tick(CPU_PROFILING);\r\nwhile (tick_nohz_reprogram(ts, now)) {\r\nnow = ktime_get();\r\ntick_do_update_jiffies64(now);\r\n}\r\n}\r\nstatic void tick_nohz_switch_to_nohz(void)\r\n{\r\nstruct tick_sched *ts = &__get_cpu_var(tick_cpu_sched);\r\nktime_t next;\r\nif (!tick_nohz_enabled)\r\nreturn;\r\nlocal_irq_disable();\r\nif (tick_switch_to_oneshot(tick_nohz_handler)) {\r\nlocal_irq_enable();\r\nreturn;\r\n}\r\nts->nohz_mode = NOHZ_MODE_LOWRES;\r\nhrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nnext = tick_init_jiffy_update();\r\nfor (;;) {\r\nhrtimer_set_expires(&ts->sched_timer, next);\r\nif (!tick_program_event(next, 0))\r\nbreak;\r\nnext = ktime_add(next, tick_period);\r\n}\r\nlocal_irq_enable();\r\nprintk(KERN_INFO "Switched to NOHz mode on CPU #%d\n", smp_processor_id());\r\n}\r\nstatic void tick_nohz_kick_tick(int cpu, ktime_t now)\r\n{\r\n#if 0\r\nstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\r\nktime_t delta;\r\ndelta = ktime_sub(hrtimer_get_expires(&ts->sched_timer), now);\r\nif (delta.tv64 <= tick_period.tv64)\r\nreturn;\r\ntick_nohz_restart(ts, now);\r\n#endif\r\n}\r\nstatic inline void tick_check_nohz(int cpu)\r\n{\r\nstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\r\nktime_t now;\r\nif (!ts->idle_active && !ts->tick_stopped)\r\nreturn;\r\nnow = ktime_get();\r\nif (ts->idle_active)\r\ntick_nohz_stop_idle(cpu, now);\r\nif (ts->tick_stopped) {\r\ntick_nohz_update_jiffies(now);\r\ntick_nohz_kick_tick(cpu, now);\r\n}\r\n}\r\nstatic inline void tick_nohz_switch_to_nohz(void) { }\r\nstatic inline void tick_check_nohz(int cpu) { }\r\nvoid tick_check_idle(int cpu)\r\n{\r\ntick_check_oneshot_broadcast(cpu);\r\ntick_check_nohz(cpu);\r\n}\r\nstatic enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)\r\n{\r\nstruct tick_sched *ts =\r\ncontainer_of(timer, struct tick_sched, sched_timer);\r\nstruct pt_regs *regs = get_irq_regs();\r\nktime_t now = ktime_get();\r\nint cpu = smp_processor_id();\r\n#ifdef CONFIG_NO_HZ\r\nif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE))\r\ntick_do_timer_cpu = cpu;\r\n#endif\r\nif (tick_do_timer_cpu == cpu)\r\ntick_do_update_jiffies64(now);\r\nif (regs) {\r\nif (ts->tick_stopped) {\r\ntouch_softlockup_watchdog();\r\nts->idle_jiffies++;\r\n}\r\nupdate_process_times(user_mode(regs));\r\nprofile_tick(CPU_PROFILING);\r\n}\r\nhrtimer_forward(timer, now, tick_period);\r\nreturn HRTIMER_RESTART;\r\n}\r\nvoid tick_setup_sched_timer(void)\r\n{\r\nstruct tick_sched *ts = &__get_cpu_var(tick_cpu_sched);\r\nktime_t now = ktime_get();\r\nhrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nts->sched_timer.function = tick_sched_timer;\r\nhrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\r\nfor (;;) {\r\nhrtimer_forward(&ts->sched_timer, now, tick_period);\r\nhrtimer_start_expires(&ts->sched_timer,\r\nHRTIMER_MODE_ABS_PINNED);\r\nif (hrtimer_active(&ts->sched_timer))\r\nbreak;\r\nnow = ktime_get();\r\n}\r\n#ifdef CONFIG_NO_HZ\r\nif (tick_nohz_enabled) {\r\nts->nohz_mode = NOHZ_MODE_HIGHRES;\r\nprintk(KERN_INFO "Switched to NOHz mode on CPU #%d\n", smp_processor_id());\r\n}\r\n#endif\r\n}\r\nvoid tick_cancel_sched_timer(int cpu)\r\n{\r\nstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\r\n# ifdef CONFIG_HIGH_RES_TIMERS\r\nif (ts->sched_timer.base)\r\nhrtimer_cancel(&ts->sched_timer);\r\n# endif\r\nts->nohz_mode = NOHZ_MODE_INACTIVE;\r\n}\r\nvoid tick_clock_notify(void)\r\n{\r\nint cpu;\r\nfor_each_possible_cpu(cpu)\r\nset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\r\n}\r\nvoid tick_oneshot_notify(void)\r\n{\r\nstruct tick_sched *ts = &__get_cpu_var(tick_cpu_sched);\r\nset_bit(0, &ts->check_clocks);\r\n}\r\nint tick_check_oneshot_change(int allow_nohz)\r\n{\r\nstruct tick_sched *ts = &__get_cpu_var(tick_cpu_sched);\r\nif (!test_and_clear_bit(0, &ts->check_clocks))\r\nreturn 0;\r\nif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\r\nreturn 0;\r\nif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\r\nreturn 0;\r\nif (!allow_nohz)\r\nreturn 1;\r\ntick_nohz_switch_to_nohz();\r\nreturn 0;\r\n}
