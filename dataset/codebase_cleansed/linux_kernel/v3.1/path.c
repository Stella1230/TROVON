static int prepend(char **buffer, int buflen, const char *str, int namelen)\r\n{\r\nbuflen -= namelen;\r\nif (buflen < 0)\r\nreturn -ENAMETOOLONG;\r\n*buffer -= namelen;\r\nmemcpy(*buffer, str, namelen);\r\nreturn 0;\r\n}\r\nstatic int d_namespace_path(struct path *path, char *buf, int buflen,\r\nchar **name, int flags)\r\n{\r\nstruct path root, tmp;\r\nchar *res;\r\nint connected, error = 0;\r\nif (flags & PATH_CHROOT_REL) {\r\nget_fs_root(current->fs, &root);\r\n} else {\r\nroot.mnt = current->nsproxy->mnt_ns->root;\r\nroot.dentry = root.mnt->mnt_root;\r\npath_get(&root);\r\n}\r\ntmp = root;\r\nres = __d_path(path, &tmp, buf, buflen);\r\n*name = res;\r\nif (IS_ERR(res)) {\r\nerror = PTR_ERR(res);\r\n*name = buf;\r\ngoto out;\r\n}\r\nif (d_unlinked(path->dentry) && path->dentry->d_inode &&\r\n!(flags & PATH_MEDIATE_DELETED)) {\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nconnected = tmp.dentry == root.dentry && tmp.mnt == root.mnt;\r\nif (!connected) {\r\nif (tmp.dentry->d_sb->s_magic == PROC_SUPER_MAGIC &&\r\nstrncmp(*name, "/sys/", 5) == 0) {\r\nerror = prepend(name, *name - buf, "/proc", 5);\r\n} else if (!(flags & PATH_CONNECT_PATH) &&\r\n!(((flags & CHROOT_NSCONNECT) == CHROOT_NSCONNECT) &&\r\n(tmp.mnt == current->nsproxy->mnt_ns->root &&\r\ntmp.dentry == tmp.mnt->mnt_root))) {\r\nerror = -ESTALE;\r\nif (*res == '/')\r\n*name = res + 1;\r\n}\r\n}\r\nout:\r\npath_put(&root);\r\nreturn error;\r\n}\r\nstatic int get_name_to_buffer(struct path *path, int flags, char *buffer,\r\nint size, char **name)\r\n{\r\nint adjust = (flags & PATH_IS_DIR) ? 1 : 0;\r\nint error = d_namespace_path(path, buffer, size - adjust, name, flags);\r\nif (!error && (flags & PATH_IS_DIR) && (*name)[1] != '\0')\r\nstrcpy(&buffer[size - 2], "/");\r\nreturn error;\r\n}\r\nint aa_get_name(struct path *path, int flags, char **buffer, const char **name)\r\n{\r\nchar *buf, *str = NULL;\r\nint size = 256;\r\nint error;\r\n*name = NULL;\r\n*buffer = NULL;\r\nfor (;;) {\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nerror = get_name_to_buffer(path, flags, buf, size, &str);\r\nif (error != -ENAMETOOLONG)\r\nbreak;\r\nkfree(buf);\r\nsize <<= 1;\r\nif (size > aa_g_path_max)\r\nreturn -ENAMETOOLONG;\r\n}\r\n*buffer = buf;\r\n*name = str;\r\nreturn error;\r\n}
