static void snd_hda_generate_beep(struct work_struct *work)\r\n{\r\nstruct hda_beep *beep =\r\ncontainer_of(work, struct hda_beep, beep_work);\r\nstruct hda_codec *codec = beep->codec;\r\nif (!beep->enabled)\r\nreturn;\r\nsnd_hda_codec_write(codec, beep->nid, 0,\r\nAC_VERB_SET_BEEP_CONTROL, beep->tone);\r\n}\r\nstatic int beep_linear_tone(struct hda_beep *beep, int hz)\r\n{\r\nif (hz <= 0)\r\nreturn 0;\r\nhz *= 1000;\r\nhz = hz - DIGBEEP_HZ_MIN\r\n+ DIGBEEP_HZ_STEP / 2;\r\nif (hz < 0)\r\nhz = 0;\r\nelse if (hz >= (DIGBEEP_HZ_MAX - DIGBEEP_HZ_MIN))\r\nhz = 1;\r\nelse {\r\nhz /= DIGBEEP_HZ_STEP;\r\nhz = 255 - hz;\r\n}\r\nreturn hz;\r\n}\r\nstatic int beep_standard_tone(struct hda_beep *beep, int hz)\r\n{\r\nif (hz <= 0)\r\nreturn 0;\r\nhz = 12000 / hz;\r\nif (hz > 0xff)\r\nreturn 0xff;\r\nif (hz <= 0)\r\nreturn 1;\r\nreturn hz;\r\n}\r\nstatic int snd_hda_beep_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int hz)\r\n{\r\nstruct hda_beep *beep = input_get_drvdata(dev);\r\nswitch (code) {\r\ncase SND_BELL:\r\nif (hz)\r\nhz = 1000;\r\ncase SND_TONE:\r\nif (beep->linear_tone)\r\nbeep->tone = beep_linear_tone(beep, hz);\r\nelse\r\nbeep->tone = beep_standard_tone(beep, hz);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nschedule_work(&beep->beep_work);\r\nreturn 0;\r\n}\r\nstatic void snd_hda_do_detach(struct hda_beep *beep)\r\n{\r\ninput_unregister_device(beep->dev);\r\nbeep->dev = NULL;\r\ncancel_work_sync(&beep->beep_work);\r\nsnd_hda_codec_write(beep->codec, beep->nid, 0,\r\nAC_VERB_SET_BEEP_CONTROL, 0);\r\n}\r\nstatic int snd_hda_do_attach(struct hda_beep *beep)\r\n{\r\nstruct input_dev *input_dev;\r\nstruct hda_codec *codec = beep->codec;\r\nint err;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\nprintk(KERN_INFO "hda_beep: unable to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_dev->name = "HDA Digital PCBeep";\r\ninput_dev->phys = beep->phys;\r\ninput_dev->id.bustype = BUS_PCI;\r\ninput_dev->id.vendor = codec->vendor_id >> 16;\r\ninput_dev->id.product = codec->vendor_id & 0xffff;\r\ninput_dev->id.version = 0x01;\r\ninput_dev->evbit[0] = BIT_MASK(EV_SND);\r\ninput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\r\ninput_dev->event = snd_hda_beep_event;\r\ninput_dev->dev.parent = &codec->bus->pci->dev;\r\ninput_set_drvdata(input_dev, beep);\r\nerr = input_register_device(input_dev);\r\nif (err < 0) {\r\ninput_free_device(input_dev);\r\nprintk(KERN_INFO "hda_beep: unable to register input device\n");\r\nreturn err;\r\n}\r\nbeep->dev = input_dev;\r\nreturn 0;\r\n}\r\nstatic void snd_hda_do_register(struct work_struct *work)\r\n{\r\nstruct hda_beep *beep =\r\ncontainer_of(work, struct hda_beep, register_work);\r\nmutex_lock(&beep->mutex);\r\nif (beep->enabled && !beep->dev)\r\nsnd_hda_do_attach(beep);\r\nmutex_unlock(&beep->mutex);\r\n}\r\nstatic void snd_hda_do_unregister(struct work_struct *work)\r\n{\r\nstruct hda_beep *beep =\r\ncontainer_of(work, struct hda_beep, unregister_work.work);\r\nmutex_lock(&beep->mutex);\r\nif (!beep->enabled && beep->dev)\r\nsnd_hda_do_detach(beep);\r\nmutex_unlock(&beep->mutex);\r\n}\r\nint snd_hda_enable_beep_device(struct hda_codec *codec, int enable)\r\n{\r\nstruct hda_beep *beep = codec->beep;\r\nenable = !!enable;\r\nif (beep == NULL)\r\nreturn 0;\r\nif (beep->enabled != enable) {\r\nbeep->enabled = enable;\r\nif (!enable) {\r\nsnd_hda_codec_write(beep->codec, beep->nid, 0,\r\nAC_VERB_SET_BEEP_CONTROL, 0);\r\n}\r\nif (beep->mode == HDA_BEEP_MODE_SWREG) {\r\nif (enable) {\r\ncancel_delayed_work(&beep->unregister_work);\r\nschedule_work(&beep->register_work);\r\n} else {\r\nschedule_delayed_work(&beep->unregister_work,\r\nHZ);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_attach_beep_device(struct hda_codec *codec, int nid)\r\n{\r\nstruct hda_beep *beep;\r\nif (!snd_hda_get_bool_hint(codec, "beep"))\r\nreturn 0;\r\nif (codec->beep_mode == HDA_BEEP_MODE_OFF)\r\nreturn 0;\r\nbeep = kzalloc(sizeof(*beep), GFP_KERNEL);\r\nif (beep == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(beep->phys, sizeof(beep->phys),\r\n"card%d/codec#%d/beep0", codec->bus->card->number, codec->addr);\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_DIGI_CONVERT_2, 0x01);\r\nbeep->nid = nid;\r\nbeep->codec = codec;\r\nbeep->mode = codec->beep_mode;\r\ncodec->beep = beep;\r\nINIT_WORK(&beep->register_work, &snd_hda_do_register);\r\nINIT_DELAYED_WORK(&beep->unregister_work, &snd_hda_do_unregister);\r\nINIT_WORK(&beep->beep_work, &snd_hda_generate_beep);\r\nmutex_init(&beep->mutex);\r\nif (beep->mode == HDA_BEEP_MODE_ON) {\r\nint err = snd_hda_do_attach(beep);\r\nif (err < 0) {\r\nkfree(beep);\r\ncodec->beep = NULL;\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_hda_detach_beep_device(struct hda_codec *codec)\r\n{\r\nstruct hda_beep *beep = codec->beep;\r\nif (beep) {\r\ncancel_work_sync(&beep->register_work);\r\ncancel_delayed_work(&beep->unregister_work);\r\nif (beep->dev)\r\nsnd_hda_do_detach(beep);\r\ncodec->beep = NULL;\r\nkfree(beep);\r\n}\r\n}
