static int print_serial_number(struct seq_file *seq, u8 * serialno, int max_len)\r\n{\r\nint i;\r\nswitch (serialno[0]) {\r\ncase I2O_SNFORMAT_BINARY:\r\nseq_printf(seq, "0x");\r\nfor (i = 0; i < serialno[1]; i++) {\r\nseq_printf(seq, "%02X", serialno[2 + i]);\r\n}\r\nbreak;\r\ncase I2O_SNFORMAT_ASCII:\r\nif (serialno[1] < ' ') {\r\nmax_len =\r\n(max_len < serialno[1]) ? max_len : serialno[1];\r\nserialno[1 + max_len] = '\0';\r\nseq_printf(seq, "%s", &serialno[2]);\r\n} else {\r\nfor (i = 0; i < serialno[1]; i++) {\r\nseq_printf(seq, "%c", serialno[2 + i]);\r\n}\r\n}\r\nbreak;\r\ncase I2O_SNFORMAT_UNICODE:\r\nseq_printf(seq, "UNICODE Format. Can't Display\n");\r\nbreak;\r\ncase I2O_SNFORMAT_LAN48_MAC:\r\nseq_printf(seq, "LAN-48 MAC address @ %pM", &serialno[2]);\r\nbreak;\r\ncase I2O_SNFORMAT_WAN:\r\nseq_printf(seq, "WAN Access Address");\r\nbreak;\r\ncase I2O_SNFORMAT_LAN64_MAC:\r\nseq_printf(seq,\r\n"LAN-64 MAC address @ [?:%02X:%02X:?] %pM",\r\nserialno[8], serialno[9], &serialno[2]);\r\nbreak;\r\ncase I2O_SNFORMAT_DDM:\r\nseq_printf(seq,\r\n"DDM: Tid=%03Xh, Rsvd=%04Xh, OrgId=%04Xh",\r\n*(u16 *) & serialno[2],\r\n*(u16 *) & serialno[4], *(u16 *) & serialno[6]);\r\nbreak;\r\ncase I2O_SNFORMAT_IEEE_REG64:\r\ncase I2O_SNFORMAT_IEEE_REG128:\r\nseq_printf(seq,\r\n"IEEE NodeName(hi,lo)=(%08Xh:%08Xh), PortName(hi,lo)=(%08Xh:%08Xh)\n",\r\n*(u32 *) & serialno[2],\r\n*(u32 *) & serialno[6],\r\n*(u32 *) & serialno[10], *(u32 *) & serialno[14]);\r\nbreak;\r\ncase I2O_SNFORMAT_UNKNOWN:\r\ncase I2O_SNFORMAT_UNKNOWN2:\r\ndefault:\r\nseq_printf(seq, "Unknown data format (0x%02x)", serialno[0]);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *i2o_get_class_name(int class)\r\n{\r\nint idx = 16;\r\nstatic char *i2o_class_name[] = {\r\n"Executive",\r\n"Device Driver Module",\r\n"Block Device",\r\n"Tape Device",\r\n"LAN Interface",\r\n"WAN Interface",\r\n"Fibre Channel Port",\r\n"Fibre Channel Device",\r\n"SCSI Device",\r\n"ATE Port",\r\n"ATE Device",\r\n"Floppy Controller",\r\n"Floppy Device",\r\n"Secondary Bus Port",\r\n"Peer Transport Agent",\r\n"Peer Transport",\r\n"Unknown"\r\n};\r\nswitch (class & 0xfff) {\r\ncase I2O_CLASS_EXECUTIVE:\r\nidx = 0;\r\nbreak;\r\ncase I2O_CLASS_DDM:\r\nidx = 1;\r\nbreak;\r\ncase I2O_CLASS_RANDOM_BLOCK_STORAGE:\r\nidx = 2;\r\nbreak;\r\ncase I2O_CLASS_SEQUENTIAL_STORAGE:\r\nidx = 3;\r\nbreak;\r\ncase I2O_CLASS_LAN:\r\nidx = 4;\r\nbreak;\r\ncase I2O_CLASS_WAN:\r\nidx = 5;\r\nbreak;\r\ncase I2O_CLASS_FIBRE_CHANNEL_PORT:\r\nidx = 6;\r\nbreak;\r\ncase I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:\r\nidx = 7;\r\nbreak;\r\ncase I2O_CLASS_SCSI_PERIPHERAL:\r\nidx = 8;\r\nbreak;\r\ncase I2O_CLASS_ATE_PORT:\r\nidx = 9;\r\nbreak;\r\ncase I2O_CLASS_ATE_PERIPHERAL:\r\nidx = 10;\r\nbreak;\r\ncase I2O_CLASS_FLOPPY_CONTROLLER:\r\nidx = 11;\r\nbreak;\r\ncase I2O_CLASS_FLOPPY_DEVICE:\r\nidx = 12;\r\nbreak;\r\ncase I2O_CLASS_BUS_ADAPTER:\r\nidx = 13;\r\nbreak;\r\ncase I2O_CLASS_PEER_TRANSPORT_AGENT:\r\nidx = 14;\r\nbreak;\r\ncase I2O_CLASS_PEER_TRANSPORT:\r\nidx = 15;\r\nbreak;\r\n}\r\nreturn i2o_class_name[idx];\r\n}\r\nstatic char *chtostr(u8 * chars, int n)\r\n{\r\nchar tmp[256];\r\ntmp[0] = 0;\r\nreturn strncat(tmp, (char *)chars, n);\r\n}\r\nstatic int i2o_report_query_status(struct seq_file *seq, int block_status,\r\nchar *group)\r\n{\r\nswitch (block_status) {\r\ncase -ETIMEDOUT:\r\nreturn seq_printf(seq, "Timeout reading group %s.\n", group);\r\ncase -ENOMEM:\r\nreturn seq_printf(seq, "No free memory to read the table.\n");\r\ncase -I2O_PARAMS_STATUS_INVALID_GROUP_ID:\r\nreturn seq_printf(seq, "Group %s not supported.\n", group);\r\ndefault:\r\nreturn seq_printf(seq,\r\n"Error reading group %s. BlockStatus 0x%02X\n",\r\ngroup, -block_status);\r\n}\r\n}\r\nstatic int i2o_seq_show_hrt(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_controller *c = (struct i2o_controller *)seq->private;\r\ni2o_hrt *hrt = (i2o_hrt *) c->hrt.virt;\r\nu32 bus;\r\nint i;\r\nif (hrt->hrt_version) {\r\nseq_printf(seq,\r\n"HRT table for controller is too new a version.\n");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "HRT has %d entries of %d bytes each.\n",\r\nhrt->num_entries, hrt->entry_len << 2);\r\nfor (i = 0; i < hrt->num_entries; i++) {\r\nseq_printf(seq, "Entry %d:\n", i);\r\nseq_printf(seq, " Adapter ID: %0#10x\n",\r\nhrt->hrt_entry[i].adapter_id);\r\nseq_printf(seq, " Controlling tid: %0#6x\n",\r\nhrt->hrt_entry[i].parent_tid);\r\nif (hrt->hrt_entry[i].bus_type != 0x80) {\r\nbus = hrt->hrt_entry[i].bus_type;\r\nseq_printf(seq, " %s Information\n",\r\nbus_strings[bus]);\r\nswitch (bus) {\r\ncase I2O_BUS_LOCAL:\r\nseq_printf(seq, " IOBase: %0#6x,",\r\nhrt->hrt_entry[i].bus.local_bus.\r\nLbBaseIOPort);\r\nseq_printf(seq, " MemoryBase: %0#10x\n",\r\nhrt->hrt_entry[i].bus.local_bus.\r\nLbBaseMemoryAddress);\r\nbreak;\r\ncase I2O_BUS_ISA:\r\nseq_printf(seq, " IOBase: %0#6x,",\r\nhrt->hrt_entry[i].bus.isa_bus.\r\nIsaBaseIOPort);\r\nseq_printf(seq, " MemoryBase: %0#10x,",\r\nhrt->hrt_entry[i].bus.isa_bus.\r\nIsaBaseMemoryAddress);\r\nseq_printf(seq, " CSN: %0#4x,",\r\nhrt->hrt_entry[i].bus.isa_bus.CSN);\r\nbreak;\r\ncase I2O_BUS_EISA:\r\nseq_printf(seq, " IOBase: %0#6x,",\r\nhrt->hrt_entry[i].bus.eisa_bus.\r\nEisaBaseIOPort);\r\nseq_printf(seq, " MemoryBase: %0#10x,",\r\nhrt->hrt_entry[i].bus.eisa_bus.\r\nEisaBaseMemoryAddress);\r\nseq_printf(seq, " Slot: %0#4x,",\r\nhrt->hrt_entry[i].bus.eisa_bus.\r\nEisaSlotNumber);\r\nbreak;\r\ncase I2O_BUS_MCA:\r\nseq_printf(seq, " IOBase: %0#6x,",\r\nhrt->hrt_entry[i].bus.mca_bus.\r\nMcaBaseIOPort);\r\nseq_printf(seq, " MemoryBase: %0#10x,",\r\nhrt->hrt_entry[i].bus.mca_bus.\r\nMcaBaseMemoryAddress);\r\nseq_printf(seq, " Slot: %0#4x,",\r\nhrt->hrt_entry[i].bus.mca_bus.\r\nMcaSlotNumber);\r\nbreak;\r\ncase I2O_BUS_PCI:\r\nseq_printf(seq, " Bus: %0#4x",\r\nhrt->hrt_entry[i].bus.pci_bus.\r\nPciBusNumber);\r\nseq_printf(seq, " Dev: %0#4x",\r\nhrt->hrt_entry[i].bus.pci_bus.\r\nPciDeviceNumber);\r\nseq_printf(seq, " Func: %0#4x",\r\nhrt->hrt_entry[i].bus.pci_bus.\r\nPciFunctionNumber);\r\nseq_printf(seq, " Vendor: %0#6x",\r\nhrt->hrt_entry[i].bus.pci_bus.\r\nPciVendorID);\r\nseq_printf(seq, " Device: %0#6x\n",\r\nhrt->hrt_entry[i].bus.pci_bus.\r\nPciDeviceID);\r\nbreak;\r\ndefault:\r\nseq_printf(seq, " Unsupported Bus Type\n");\r\n}\r\n} else\r\nseq_printf(seq, " Unknown Bus Type\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_lct(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_controller *c = (struct i2o_controller *)seq->private;\r\ni2o_lct *lct = (i2o_lct *) c->lct;\r\nint entries;\r\nint i;\r\n#define BUS_TABLE_SIZE 3\r\nstatic char *bus_ports[] = {\r\n"Generic Bus",\r\n"SCSI Bus",\r\n"Fibre Channel Bus"\r\n};\r\nentries = (lct->table_size - 3) / 9;\r\nseq_printf(seq, "LCT contains %d %s\n", entries,\r\nentries == 1 ? "entry" : "entries");\r\nif (lct->boot_tid)\r\nseq_printf(seq, "Boot Device @ ID %d\n", lct->boot_tid);\r\nseq_printf(seq, "Current Change Indicator: %#10x\n", lct->change_ind);\r\nfor (i = 0; i < entries; i++) {\r\nseq_printf(seq, "Entry %d\n", i);\r\nseq_printf(seq, " Class, SubClass : %s",\r\ni2o_get_class_name(lct->lct_entry[i].class_id));\r\nswitch (lct->lct_entry[i].class_id & 0xFFF) {\r\ncase I2O_CLASS_RANDOM_BLOCK_STORAGE:\r\nswitch (lct->lct_entry[i].sub_class) {\r\ncase 0x00:\r\nseq_printf(seq, ", Direct-Access Read/Write");\r\nbreak;\r\ncase 0x04:\r\nseq_printf(seq, ", WORM Drive");\r\nbreak;\r\ncase 0x05:\r\nseq_printf(seq, ", CD-ROM Drive");\r\nbreak;\r\ncase 0x07:\r\nseq_printf(seq, ", Optical Memory Device");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, ", Unknown (0x%02x)",\r\nlct->lct_entry[i].sub_class);\r\nbreak;\r\n}\r\nbreak;\r\ncase I2O_CLASS_LAN:\r\nswitch (lct->lct_entry[i].sub_class & 0xFF) {\r\ncase 0x30:\r\nseq_printf(seq, ", Ethernet");\r\nbreak;\r\ncase 0x40:\r\nseq_printf(seq, ", 100base VG");\r\nbreak;\r\ncase 0x50:\r\nseq_printf(seq, ", IEEE 802.5/Token-Ring");\r\nbreak;\r\ncase 0x60:\r\nseq_printf(seq, ", ANSI X3T9.5 FDDI");\r\nbreak;\r\ncase 0x70:\r\nseq_printf(seq, ", Fibre Channel");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, ", Unknown Sub-Class (0x%02x)",\r\nlct->lct_entry[i].sub_class & 0xFF);\r\nbreak;\r\n}\r\nbreak;\r\ncase I2O_CLASS_SCSI_PERIPHERAL:\r\nif (lct->lct_entry[i].sub_class < SCSI_TABLE_SIZE)\r\nseq_printf(seq, ", %s",\r\nscsi_devices[lct->lct_entry[i].\r\nsub_class]);\r\nelse\r\nseq_printf(seq, ", Unknown Device Type");\r\nbreak;\r\ncase I2O_CLASS_BUS_ADAPTER:\r\nif (lct->lct_entry[i].sub_class < BUS_TABLE_SIZE)\r\nseq_printf(seq, ", %s",\r\nbus_ports[lct->lct_entry[i].\r\nsub_class]);\r\nelse\r\nseq_printf(seq, ", Unknown Bus Type");\r\nbreak;\r\n}\r\nseq_printf(seq, "\n");\r\nseq_printf(seq, " Local TID : 0x%03x\n",\r\nlct->lct_entry[i].tid);\r\nseq_printf(seq, " User TID : 0x%03x\n",\r\nlct->lct_entry[i].user_tid);\r\nseq_printf(seq, " Parent TID : 0x%03x\n",\r\nlct->lct_entry[i].parent_tid);\r\nseq_printf(seq, " Identity Tag : 0x%x%x%x%x%x%x%x%x\n",\r\nlct->lct_entry[i].identity_tag[0],\r\nlct->lct_entry[i].identity_tag[1],\r\nlct->lct_entry[i].identity_tag[2],\r\nlct->lct_entry[i].identity_tag[3],\r\nlct->lct_entry[i].identity_tag[4],\r\nlct->lct_entry[i].identity_tag[5],\r\nlct->lct_entry[i].identity_tag[6],\r\nlct->lct_entry[i].identity_tag[7]);\r\nseq_printf(seq, " Change Indicator : %0#10x\n",\r\nlct->lct_entry[i].change_ind);\r\nseq_printf(seq, " Event Capab Mask : %0#10x\n",\r\nlct->lct_entry[i].device_flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_status(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_controller *c = (struct i2o_controller *)seq->private;\r\nchar prodstr[25];\r\nint version;\r\ni2o_status_block *sb = c->status_block.virt;\r\ni2o_status_get(c);\r\nseq_printf(seq, "Organization ID : %0#6x\n", sb->org_id);\r\nversion = sb->i2o_version;\r\nseq_printf(seq, "IOP ID : %0#5x\n", sb->iop_id);\r\nseq_printf(seq, "Host Unit ID : %0#6x\n", sb->host_unit_id);\r\nseq_printf(seq, "Segment Number : %0#5x\n", sb->segment_number);\r\nseq_printf(seq, "I2O version : ");\r\nswitch (version) {\r\ncase 0x00:\r\nseq_printf(seq, "1.0\n");\r\nbreak;\r\ncase 0x01:\r\nseq_printf(seq, "1.5\n");\r\nbreak;\r\ncase 0x02:\r\nseq_printf(seq, "2.0\n");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, "Unknown version\n");\r\n}\r\nseq_printf(seq, "IOP State : ");\r\nswitch (sb->iop_state) {\r\ncase 0x01:\r\nseq_printf(seq, "INIT\n");\r\nbreak;\r\ncase 0x02:\r\nseq_printf(seq, "RESET\n");\r\nbreak;\r\ncase 0x04:\r\nseq_printf(seq, "HOLD\n");\r\nbreak;\r\ncase 0x05:\r\nseq_printf(seq, "READY\n");\r\nbreak;\r\ncase 0x08:\r\nseq_printf(seq, "OPERATIONAL\n");\r\nbreak;\r\ncase 0x10:\r\nseq_printf(seq, "FAILED\n");\r\nbreak;\r\ncase 0x11:\r\nseq_printf(seq, "FAULTED\n");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, "Unknown\n");\r\nbreak;\r\n}\r\nseq_printf(seq, "Messenger Type : ");\r\nswitch (sb->msg_type) {\r\ncase 0x00:\r\nseq_printf(seq, "Memory mapped\n");\r\nbreak;\r\ncase 0x01:\r\nseq_printf(seq, "Memory mapped only\n");\r\nbreak;\r\ncase 0x02:\r\nseq_printf(seq, "Remote only\n");\r\nbreak;\r\ncase 0x03:\r\nseq_printf(seq, "Memory mapped and remote\n");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, "Unknown\n");\r\n}\r\nseq_printf(seq, "Inbound Frame Size : %d bytes\n",\r\nsb->inbound_frame_size << 2);\r\nseq_printf(seq, "Max Inbound Frames : %d\n",\r\nsb->max_inbound_frames);\r\nseq_printf(seq, "Current Inbound Frames : %d\n",\r\nsb->cur_inbound_frames);\r\nseq_printf(seq, "Max Outbound Frames : %d\n",\r\nsb->max_outbound_frames);\r\nmemcpy(prodstr, sb->product_id, 24);\r\nprodstr[24] = '\0';\r\nseq_printf(seq, "Product ID : %s\n", prodstr);\r\nseq_printf(seq, "Expected LCT Size : %d bytes\n",\r\nsb->expected_lct_size);\r\nseq_printf(seq, "IOP Capabilities\n");\r\nseq_printf(seq, " Context Field Size Support : ");\r\nswitch (sb->iop_capabilities & 0x0000003) {\r\ncase 0:\r\nseq_printf(seq, "Supports only 32-bit context fields\n");\r\nbreak;\r\ncase 1:\r\nseq_printf(seq, "Supports only 64-bit context fields\n");\r\nbreak;\r\ncase 2:\r\nseq_printf(seq, "Supports 32-bit and 64-bit context fields, "\r\n"but not concurrently\n");\r\nbreak;\r\ncase 3:\r\nseq_printf(seq, "Supports 32-bit and 64-bit context fields "\r\n"concurrently\n");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, "0x%08x\n", sb->iop_capabilities);\r\n}\r\nseq_printf(seq, " Current Context Field Size : ");\r\nswitch (sb->iop_capabilities & 0x0000000C) {\r\ncase 0:\r\nseq_printf(seq, "not configured\n");\r\nbreak;\r\ncase 4:\r\nseq_printf(seq, "Supports only 32-bit context fields\n");\r\nbreak;\r\ncase 8:\r\nseq_printf(seq, "Supports only 64-bit context fields\n");\r\nbreak;\r\ncase 12:\r\nseq_printf(seq, "Supports both 32-bit or 64-bit context fields "\r\n"concurrently\n");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, "\n");\r\n}\r\nseq_printf(seq, " Inbound Peer Support : %s\n",\r\n(sb->\r\niop_capabilities & 0x00000010) ? "Supported" :\r\n"Not supported");\r\nseq_printf(seq, " Outbound Peer Support : %s\n",\r\n(sb->\r\niop_capabilities & 0x00000020) ? "Supported" :\r\n"Not supported");\r\nseq_printf(seq, " Peer to Peer Support : %s\n",\r\n(sb->\r\niop_capabilities & 0x00000040) ? "Supported" :\r\n"Not supported");\r\nseq_printf(seq, "Desired private memory size : %d kB\n",\r\nsb->desired_mem_size >> 10);\r\nseq_printf(seq, "Allocated private memory size : %d kB\n",\r\nsb->current_mem_size >> 10);\r\nseq_printf(seq, "Private memory base address : %0#10x\n",\r\nsb->current_mem_base);\r\nseq_printf(seq, "Desired private I/O size : %d kB\n",\r\nsb->desired_io_size >> 10);\r\nseq_printf(seq, "Allocated private I/O size : %d kB\n",\r\nsb->current_io_size >> 10);\r\nseq_printf(seq, "Private I/O base address : %0#10x\n",\r\nsb->current_io_base);\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_hw(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_controller *c = (struct i2o_controller *)seq->private;\r\nstatic u32 work32[5];\r\nstatic u8 *work8 = (u8 *) work32;\r\nstatic u16 *work16 = (u16 *) work32;\r\nint token;\r\nu32 hwcap;\r\nstatic char *cpu_table[] = {\r\n"Intel 80960 series",\r\n"AMD2900 series",\r\n"Motorola 68000 series",\r\n"ARM series",\r\n"MIPS series",\r\n"Sparc series",\r\n"PowerPC series",\r\n"Intel x86 series"\r\n};\r\ntoken =\r\ni2o_parm_field_get(c->exec, 0x0000, -1, &work32, sizeof(work32));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token, "0x0000 IOP Hardware");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "I2O Vendor ID : %0#6x\n", work16[0]);\r\nseq_printf(seq, "Product ID : %0#6x\n", work16[1]);\r\nseq_printf(seq, "CPU : ");\r\nif (work8[16] > 8)\r\nseq_printf(seq, "Unknown\n");\r\nelse\r\nseq_printf(seq, "%s\n", cpu_table[work8[16]]);\r\nseq_printf(seq, "RAM : %dkB\n", work32[1] >> 10);\r\nseq_printf(seq, "Non-Volatile Mem : %dkB\n", work32[2] >> 10);\r\nhwcap = work32[3];\r\nseq_printf(seq, "Capabilities : 0x%08x\n", hwcap);\r\nseq_printf(seq, " [%s] Self booting\n",\r\n(hwcap & 0x00000001) ? "+" : "-");\r\nseq_printf(seq, " [%s] Upgradable IRTOS\n",\r\n(hwcap & 0x00000002) ? "+" : "-");\r\nseq_printf(seq, " [%s] Supports downloading DDMs\n",\r\n(hwcap & 0x00000004) ? "+" : "-");\r\nseq_printf(seq, " [%s] Supports installing DDMs\n",\r\n(hwcap & 0x00000008) ? "+" : "-");\r\nseq_printf(seq, " [%s] Battery-backed RAM\n",\r\n(hwcap & 0x00000010) ? "+" : "-");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_ddm_table(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_controller *c = (struct i2o_controller *)seq->private;\r\nint token;\r\nint i;\r\ntypedef struct _i2o_exec_execute_ddm_table {\r\nu16 ddm_tid;\r\nu8 module_type;\r\nu8 reserved;\r\nu16 i2o_vendor_id;\r\nu16 module_id;\r\nu8 module_name_version[28];\r\nu32 data_size;\r\nu32 code_size;\r\n} i2o_exec_execute_ddm_table;\r\nstruct {\r\nu16 result_count;\r\nu16 pad;\r\nu16 block_size;\r\nu8 block_status;\r\nu8 error_info_size;\r\nu16 row_count;\r\nu16 more_flag;\r\ni2o_exec_execute_ddm_table ddm_table[I2O_MAX_MODULES];\r\n} *result;\r\ni2o_exec_execute_ddm_table ddm_table;\r\nresult = kmalloc(sizeof(*result), GFP_KERNEL);\r\nif (!result)\r\nreturn -ENOMEM;\r\ntoken = i2o_parm_table_get(c->exec, I2O_PARAMS_TABLE_GET, 0x0003, -1,\r\nNULL, 0, result, sizeof(*result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token,\r\n"0x0003 Executing DDM List");\r\ngoto out;\r\n}\r\nseq_printf(seq,\r\n"Tid Module_type Vendor Mod_id Module_name Vrs Data_size Code_size\n");\r\nddm_table = result->ddm_table[0];\r\nfor (i = 0; i < result->row_count; ddm_table = result->ddm_table[++i]) {\r\nseq_printf(seq, "0x%03x ", ddm_table.ddm_tid & 0xFFF);\r\nswitch (ddm_table.module_type) {\r\ncase 0x01:\r\nseq_printf(seq, "Downloaded DDM ");\r\nbreak;\r\ncase 0x22:\r\nseq_printf(seq, "Embedded DDM ");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, " ");\r\n}\r\nseq_printf(seq, "%-#7x", ddm_table.i2o_vendor_id);\r\nseq_printf(seq, "%-#8x", ddm_table.module_id);\r\nseq_printf(seq, "%-29s",\r\nchtostr(ddm_table.module_name_version, 28));\r\nseq_printf(seq, "%9d ", ddm_table.data_size);\r\nseq_printf(seq, "%8d", ddm_table.code_size);\r\nseq_printf(seq, "\n");\r\n}\r\nout:\r\nkfree(result);\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_driver_store(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_controller *c = (struct i2o_controller *)seq->private;\r\nu32 work32[8];\r\nint token;\r\ntoken =\r\ni2o_parm_field_get(c->exec, 0x0004, -1, &work32, sizeof(work32));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token, "0x0004 Driver Store");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "Module limit : %d\n"\r\n"Module count : %d\n"\r\n"Current space : %d kB\n"\r\n"Free space : %d kB\n",\r\nwork32[0], work32[1], work32[2] >> 10, work32[3] >> 10);\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_drivers_stored(struct seq_file *seq, void *v)\r\n{\r\ntypedef struct _i2o_driver_store {\r\nu16 stored_ddm_index;\r\nu8 module_type;\r\nu8 reserved;\r\nu16 i2o_vendor_id;\r\nu16 module_id;\r\nu8 module_name_version[28];\r\nu8 date[8];\r\nu32 module_size;\r\nu32 mpb_size;\r\nu32 module_flags;\r\n} i2o_driver_store_table;\r\nstruct i2o_controller *c = (struct i2o_controller *)seq->private;\r\nint token;\r\nint i;\r\ntypedef struct {\r\nu16 result_count;\r\nu16 pad;\r\nu16 block_size;\r\nu8 block_status;\r\nu8 error_info_size;\r\nu16 row_count;\r\nu16 more_flag;\r\ni2o_driver_store_table dst[I2O_MAX_MODULES];\r\n} i2o_driver_result_table;\r\ni2o_driver_result_table *result;\r\ni2o_driver_store_table *dst;\r\nresult = kmalloc(sizeof(i2o_driver_result_table), GFP_KERNEL);\r\nif (result == NULL)\r\nreturn -ENOMEM;\r\ntoken = i2o_parm_table_get(c->exec, I2O_PARAMS_TABLE_GET, 0x0005, -1,\r\nNULL, 0, result, sizeof(*result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token,\r\n"0x0005 DRIVER STORE TABLE");\r\nkfree(result);\r\nreturn 0;\r\n}\r\nseq_printf(seq,\r\n"# Module_type Vendor Mod_id Module_name Vrs"\r\n"Date Mod_size Par_size Flags\n");\r\nfor (i = 0, dst = &result->dst[0]; i < result->row_count;\r\ndst = &result->dst[++i]) {\r\nseq_printf(seq, "%-3d", dst->stored_ddm_index);\r\nswitch (dst->module_type) {\r\ncase 0x01:\r\nseq_printf(seq, "Downloaded DDM ");\r\nbreak;\r\ncase 0x22:\r\nseq_printf(seq, "Embedded DDM ");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, " ");\r\n}\r\nseq_printf(seq, "%-#7x", dst->i2o_vendor_id);\r\nseq_printf(seq, "%-#8x", dst->module_id);\r\nseq_printf(seq, "%-29s", chtostr(dst->module_name_version, 28));\r\nseq_printf(seq, "%-9s", chtostr(dst->date, 8));\r\nseq_printf(seq, "%8d ", dst->module_size);\r\nseq_printf(seq, "%8d ", dst->mpb_size);\r\nseq_printf(seq, "0x%04x", dst->module_flags);\r\nseq_printf(seq, "\n");\r\n}\r\nkfree(result);\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_groups(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nint i;\r\nu8 properties;\r\ntypedef struct _i2o_group_info {\r\nu16 group_number;\r\nu16 field_count;\r\nu16 row_count;\r\nu8 properties;\r\nu8 reserved;\r\n} i2o_group_info;\r\nstruct {\r\nu16 result_count;\r\nu16 pad;\r\nu16 block_size;\r\nu8 block_status;\r\nu8 error_info_size;\r\nu16 row_count;\r\nu16 more_flag;\r\ni2o_group_info group[256];\r\n} *result;\r\nresult = kmalloc(sizeof(*result), GFP_KERNEL);\r\nif (!result)\r\nreturn -ENOMEM;\r\ntoken = i2o_parm_table_get(d, I2O_PARAMS_TABLE_GET, 0xF000, -1, NULL, 0,\r\nresult, sizeof(*result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token, "0xF000 Params Descriptor");\r\ngoto out;\r\n}\r\nseq_printf(seq,\r\n"# Group FieldCount RowCount Type Add Del Clear\n");\r\nfor (i = 0; i < result->row_count; i++) {\r\nseq_printf(seq, "%-3d", i);\r\nseq_printf(seq, "0x%04X ", result->group[i].group_number);\r\nseq_printf(seq, "%10d ", result->group[i].field_count);\r\nseq_printf(seq, "%8d ", result->group[i].row_count);\r\nproperties = result->group[i].properties;\r\nif (properties & 0x1)\r\nseq_printf(seq, "Table ");\r\nelse\r\nseq_printf(seq, "Scalar ");\r\nif (properties & 0x2)\r\nseq_printf(seq, " + ");\r\nelse\r\nseq_printf(seq, " - ");\r\nif (properties & 0x4)\r\nseq_printf(seq, " + ");\r\nelse\r\nseq_printf(seq, " - ");\r\nif (properties & 0x8)\r\nseq_printf(seq, " + ");\r\nelse\r\nseq_printf(seq, " - ");\r\nseq_printf(seq, "\n");\r\n}\r\nif (result->more_flag)\r\nseq_printf(seq, "There is more...\n");\r\nout:\r\nkfree(result);\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_phys_device(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nint i;\r\nstruct {\r\nu16 result_count;\r\nu16 pad;\r\nu16 block_size;\r\nu8 block_status;\r\nu8 error_info_size;\r\nu16 row_count;\r\nu16 more_flag;\r\nu32 adapter_id[64];\r\n} result;\r\ntoken = i2o_parm_table_get(d, I2O_PARAMS_TABLE_GET, 0xF001, -1, NULL, 0,\r\n&result, sizeof(result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token,\r\n"0xF001 Physical Device Table");\r\nreturn 0;\r\n}\r\nif (result.row_count)\r\nseq_printf(seq, "# AdapterId\n");\r\nfor (i = 0; i < result.row_count; i++) {\r\nseq_printf(seq, "%-2d", i);\r\nseq_printf(seq, "%#7x\n", result.adapter_id[i]);\r\n}\r\nif (result.more_flag)\r\nseq_printf(seq, "There is more...\n");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_claimed(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nint i;\r\nstruct {\r\nu16 result_count;\r\nu16 pad;\r\nu16 block_size;\r\nu8 block_status;\r\nu8 error_info_size;\r\nu16 row_count;\r\nu16 more_flag;\r\nu16 claimed_tid[64];\r\n} result;\r\ntoken = i2o_parm_table_get(d, I2O_PARAMS_TABLE_GET, 0xF002, -1, NULL, 0,\r\n&result, sizeof(result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token, "0xF002 Claimed Table");\r\nreturn 0;\r\n}\r\nif (result.row_count)\r\nseq_printf(seq, "# ClaimedTid\n");\r\nfor (i = 0; i < result.row_count; i++) {\r\nseq_printf(seq, "%-2d", i);\r\nseq_printf(seq, "%#7x\n", result.claimed_tid[i]);\r\n}\r\nif (result.more_flag)\r\nseq_printf(seq, "There is more...\n");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_users(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nint i;\r\ntypedef struct _i2o_user_table {\r\nu16 instance;\r\nu16 user_tid;\r\nu8 claim_type;\r\nu8 reserved1;\r\nu16 reserved2;\r\n} i2o_user_table;\r\nstruct {\r\nu16 result_count;\r\nu16 pad;\r\nu16 block_size;\r\nu8 block_status;\r\nu8 error_info_size;\r\nu16 row_count;\r\nu16 more_flag;\r\ni2o_user_table user[64];\r\n} *result;\r\nresult = kmalloc(sizeof(*result), GFP_KERNEL);\r\nif (!result)\r\nreturn -ENOMEM;\r\ntoken = i2o_parm_table_get(d, I2O_PARAMS_TABLE_GET, 0xF003, -1, NULL, 0,\r\nresult, sizeof(*result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token, "0xF003 User Table");\r\ngoto out;\r\n}\r\nseq_printf(seq, "# Instance UserTid ClaimType\n");\r\nfor (i = 0; i < result->row_count; i++) {\r\nseq_printf(seq, "%-3d", i);\r\nseq_printf(seq, "%#8x ", result->user[i].instance);\r\nseq_printf(seq, "%#7x ", result->user[i].user_tid);\r\nseq_printf(seq, "%#9x\n", result->user[i].claim_type);\r\n}\r\nif (result->more_flag)\r\nseq_printf(seq, "There is more...\n");\r\nout:\r\nkfree(result);\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_priv_msgs(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nint i;\r\ntypedef struct _i2o_private {\r\nu16 ext_instance;\r\nu16 organization_id;\r\nu16 x_function_code;\r\n} i2o_private;\r\nstruct {\r\nu16 result_count;\r\nu16 pad;\r\nu16 block_size;\r\nu8 block_status;\r\nu8 error_info_size;\r\nu16 row_count;\r\nu16 more_flag;\r\ni2o_private extension[64];\r\n} result;\r\ntoken = i2o_parm_table_get(d, I2O_PARAMS_TABLE_GET, 0xF000, -1, NULL, 0,\r\n&result, sizeof(result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token,\r\n"0xF005 Private Message Extensions (optional)");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "Instance# OrgId FunctionCode\n");\r\nfor (i = 0; i < result.row_count; i++) {\r\nseq_printf(seq, "%0#9x ", result.extension[i].ext_instance);\r\nseq_printf(seq, "%0#6x ", result.extension[i].organization_id);\r\nseq_printf(seq, "%0#6x", result.extension[i].x_function_code);\r\nseq_printf(seq, "\n");\r\n}\r\nif (result.more_flag)\r\nseq_printf(seq, "There is more...\n");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_authorized_users(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nint i;\r\nstruct {\r\nu16 result_count;\r\nu16 pad;\r\nu16 block_size;\r\nu8 block_status;\r\nu8 error_info_size;\r\nu16 row_count;\r\nu16 more_flag;\r\nu32 alternate_tid[64];\r\n} result;\r\ntoken = i2o_parm_table_get(d, I2O_PARAMS_TABLE_GET, 0xF006, -1, NULL, 0,\r\n&result, sizeof(result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token,\r\n"0xF006 Autohorized User Table");\r\nreturn 0;\r\n}\r\nif (result.row_count)\r\nseq_printf(seq, "# AlternateTid\n");\r\nfor (i = 0; i < result.row_count; i++) {\r\nseq_printf(seq, "%-2d", i);\r\nseq_printf(seq, "%#7x ", result.alternate_tid[i]);\r\n}\r\nif (result.more_flag)\r\nseq_printf(seq, "There is more...\n");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_dev_identity(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nstatic u32 work32[128];\r\nstatic u16 *work16 = (u16 *) work32;\r\nint token;\r\ntoken = i2o_parm_field_get(d, 0xF100, -1, &work32, sizeof(work32));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token, "0xF100 Device Identity");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "Device Class : %s\n", i2o_get_class_name(work16[0]));\r\nseq_printf(seq, "Owner TID : %0#5x\n", work16[2]);\r\nseq_printf(seq, "Parent TID : %0#5x\n", work16[3]);\r\nseq_printf(seq, "Vendor info : %s\n",\r\nchtostr((u8 *) (work32 + 2), 16));\r\nseq_printf(seq, "Product info : %s\n",\r\nchtostr((u8 *) (work32 + 6), 16));\r\nseq_printf(seq, "Description : %s\n",\r\nchtostr((u8 *) (work32 + 10), 16));\r\nseq_printf(seq, "Product rev. : %s\n",\r\nchtostr((u8 *) (work32 + 14), 8));\r\nseq_printf(seq, "Serial number : ");\r\nprint_serial_number(seq, (u8 *) (work32 + 16),\r\nsizeof(work32) - (16 * sizeof(u32)) - 2);\r\nseq_printf(seq, "\n");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_dev_name(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nseq_printf(seq, "%s\n", dev_name(&d->device));\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_ddm_identity(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nstruct {\r\nu16 ddm_tid;\r\nu8 module_name[24];\r\nu8 module_rev[8];\r\nu8 sn_format;\r\nu8 serial_number[12];\r\nu8 pad[256];\r\n} result;\r\ntoken = i2o_parm_field_get(d, 0xF101, -1, &result, sizeof(result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token, "0xF101 DDM Identity");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "Registering DDM TID : 0x%03x\n", result.ddm_tid);\r\nseq_printf(seq, "Module name : %s\n",\r\nchtostr(result.module_name, 24));\r\nseq_printf(seq, "Module revision : %s\n",\r\nchtostr(result.module_rev, 8));\r\nseq_printf(seq, "Serial number : ");\r\nprint_serial_number(seq, result.serial_number, sizeof(result) - 36);\r\nseq_printf(seq, "\n");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_uinfo(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nstruct {\r\nu8 device_name[64];\r\nu8 service_name[64];\r\nu8 physical_location[64];\r\nu8 instance_number[4];\r\n} result;\r\ntoken = i2o_parm_field_get(d, 0xF102, -1, &result, sizeof(result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token, "0xF102 User Information");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "Device name : %s\n",\r\nchtostr(result.device_name, 64));\r\nseq_printf(seq, "Service name : %s\n",\r\nchtostr(result.service_name, 64));\r\nseq_printf(seq, "Physical name : %s\n",\r\nchtostr(result.physical_location, 64));\r\nseq_printf(seq, "Instance number : %s\n",\r\nchtostr(result.instance_number, 4));\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_sgl_limits(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nstatic u32 work32[12];\r\nstatic u16 *work16 = (u16 *) work32;\r\nstatic u8 *work8 = (u8 *) work32;\r\nint token;\r\ntoken = i2o_parm_field_get(d, 0xF103, -1, &work32, sizeof(work32));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token,\r\n"0xF103 SGL Operating Limits");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "SGL chain size : %d\n", work32[0]);\r\nseq_printf(seq, "Max SGL chain size : %d\n", work32[1]);\r\nseq_printf(seq, "SGL chain size target : %d\n", work32[2]);\r\nseq_printf(seq, "SGL frag count : %d\n", work16[6]);\r\nseq_printf(seq, "Max SGL frag count : %d\n", work16[7]);\r\nseq_printf(seq, "SGL frag count target : %d\n", work16[8]);\r\nseq_printf(seq, "SGL data alignment : %d\n", work16[8]);\r\nseq_printf(seq, "SGL addr limit : %d\n", work8[20]);\r\nseq_printf(seq, "SGL addr sizes supported : ");\r\nif (work8[21] & 0x01)\r\nseq_printf(seq, "32 bit ");\r\nif (work8[21] & 0x02)\r\nseq_printf(seq, "64 bit ");\r\nif (work8[21] & 0x04)\r\nseq_printf(seq, "96 bit ");\r\nif (work8[21] & 0x08)\r\nseq_printf(seq, "128 bit ");\r\nseq_printf(seq, "\n");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_show_sensors(struct seq_file *seq, void *v)\r\n{\r\nstruct i2o_device *d = (struct i2o_device *)seq->private;\r\nint token;\r\nstruct {\r\nu16 sensor_instance;\r\nu8 component;\r\nu16 component_instance;\r\nu8 sensor_class;\r\nu8 sensor_type;\r\nu8 scaling_exponent;\r\nu32 actual_reading;\r\nu32 minimum_reading;\r\nu32 low2lowcat_treshold;\r\nu32 lowcat2low_treshold;\r\nu32 lowwarn2low_treshold;\r\nu32 low2lowwarn_treshold;\r\nu32 norm2lowwarn_treshold;\r\nu32 lowwarn2norm_treshold;\r\nu32 nominal_reading;\r\nu32 hiwarn2norm_treshold;\r\nu32 norm2hiwarn_treshold;\r\nu32 high2hiwarn_treshold;\r\nu32 hiwarn2high_treshold;\r\nu32 hicat2high_treshold;\r\nu32 hi2hicat_treshold;\r\nu32 maximum_reading;\r\nu8 sensor_state;\r\nu16 event_enable;\r\n} result;\r\ntoken = i2o_parm_field_get(d, 0xF200, -1, &result, sizeof(result));\r\nif (token < 0) {\r\ni2o_report_query_status(seq, token,\r\n"0xF200 Sensors (optional)");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "Sensor instance : %d\n", result.sensor_instance);\r\nseq_printf(seq, "Component : %d = ", result.component);\r\nswitch (result.component) {\r\ncase 0:\r\nseq_printf(seq, "Other");\r\nbreak;\r\ncase 1:\r\nseq_printf(seq, "Planar logic Board");\r\nbreak;\r\ncase 2:\r\nseq_printf(seq, "CPU");\r\nbreak;\r\ncase 3:\r\nseq_printf(seq, "Chassis");\r\nbreak;\r\ncase 4:\r\nseq_printf(seq, "Power Supply");\r\nbreak;\r\ncase 5:\r\nseq_printf(seq, "Storage");\r\nbreak;\r\ncase 6:\r\nseq_printf(seq, "External");\r\nbreak;\r\n}\r\nseq_printf(seq, "\n");\r\nseq_printf(seq, "Component instance : %d\n",\r\nresult.component_instance);\r\nseq_printf(seq, "Sensor class : %s\n",\r\nresult.sensor_class ? "Analog" : "Digital");\r\nseq_printf(seq, "Sensor type : %d = ", result.sensor_type);\r\nswitch (result.sensor_type) {\r\ncase 0:\r\nseq_printf(seq, "Other\n");\r\nbreak;\r\ncase 1:\r\nseq_printf(seq, "Thermal\n");\r\nbreak;\r\ncase 2:\r\nseq_printf(seq, "DC voltage (DC volts)\n");\r\nbreak;\r\ncase 3:\r\nseq_printf(seq, "AC voltage (AC volts)\n");\r\nbreak;\r\ncase 4:\r\nseq_printf(seq, "DC current (DC amps)\n");\r\nbreak;\r\ncase 5:\r\nseq_printf(seq, "AC current (AC volts)\n");\r\nbreak;\r\ncase 6:\r\nseq_printf(seq, "Door open\n");\r\nbreak;\r\ncase 7:\r\nseq_printf(seq, "Fan operational\n");\r\nbreak;\r\n}\r\nseq_printf(seq, "Scaling exponent : %d\n",\r\nresult.scaling_exponent);\r\nseq_printf(seq, "Actual reading : %d\n", result.actual_reading);\r\nseq_printf(seq, "Minimum reading : %d\n", result.minimum_reading);\r\nseq_printf(seq, "Low2LowCat treshold : %d\n",\r\nresult.low2lowcat_treshold);\r\nseq_printf(seq, "LowCat2Low treshold : %d\n",\r\nresult.lowcat2low_treshold);\r\nseq_printf(seq, "LowWarn2Low treshold : %d\n",\r\nresult.lowwarn2low_treshold);\r\nseq_printf(seq, "Low2LowWarn treshold : %d\n",\r\nresult.low2lowwarn_treshold);\r\nseq_printf(seq, "Norm2LowWarn treshold : %d\n",\r\nresult.norm2lowwarn_treshold);\r\nseq_printf(seq, "LowWarn2Norm treshold : %d\n",\r\nresult.lowwarn2norm_treshold);\r\nseq_printf(seq, "Nominal reading : %d\n", result.nominal_reading);\r\nseq_printf(seq, "HiWarn2Norm treshold : %d\n",\r\nresult.hiwarn2norm_treshold);\r\nseq_printf(seq, "Norm2HiWarn treshold : %d\n",\r\nresult.norm2hiwarn_treshold);\r\nseq_printf(seq, "High2HiWarn treshold : %d\n",\r\nresult.high2hiwarn_treshold);\r\nseq_printf(seq, "HiWarn2High treshold : %d\n",\r\nresult.hiwarn2high_treshold);\r\nseq_printf(seq, "HiCat2High treshold : %d\n",\r\nresult.hicat2high_treshold);\r\nseq_printf(seq, "High2HiCat treshold : %d\n",\r\nresult.hi2hicat_treshold);\r\nseq_printf(seq, "Maximum reading : %d\n", result.maximum_reading);\r\nseq_printf(seq, "Sensor state : %d = ", result.sensor_state);\r\nswitch (result.sensor_state) {\r\ncase 0:\r\nseq_printf(seq, "Normal\n");\r\nbreak;\r\ncase 1:\r\nseq_printf(seq, "Abnormal\n");\r\nbreak;\r\ncase 2:\r\nseq_printf(seq, "Unknown\n");\r\nbreak;\r\ncase 3:\r\nseq_printf(seq, "Low Catastrophic (LoCat)\n");\r\nbreak;\r\ncase 4:\r\nseq_printf(seq, "Low (Low)\n");\r\nbreak;\r\ncase 5:\r\nseq_printf(seq, "Low Warning (LoWarn)\n");\r\nbreak;\r\ncase 6:\r\nseq_printf(seq, "High Warning (HiWarn)\n");\r\nbreak;\r\ncase 7:\r\nseq_printf(seq, "High (High)\n");\r\nbreak;\r\ncase 8:\r\nseq_printf(seq, "High Catastrophic (HiCat)\n");\r\nbreak;\r\n}\r\nseq_printf(seq, "Event_enable : 0x%02X\n", result.event_enable);\r\nseq_printf(seq, " [%s] Operational state change. \n",\r\n(result.event_enable & 0x01) ? "+" : "-");\r\nseq_printf(seq, " [%s] Low catastrophic. \n",\r\n(result.event_enable & 0x02) ? "+" : "-");\r\nseq_printf(seq, " [%s] Low reading. \n",\r\n(result.event_enable & 0x04) ? "+" : "-");\r\nseq_printf(seq, " [%s] Low warning. \n",\r\n(result.event_enable & 0x08) ? "+" : "-");\r\nseq_printf(seq,\r\n" [%s] Change back to normal from out of range state. \n",\r\n(result.event_enable & 0x10) ? "+" : "-");\r\nseq_printf(seq, " [%s] High warning. \n",\r\n(result.event_enable & 0x20) ? "+" : "-");\r\nseq_printf(seq, " [%s] High reading. \n",\r\n(result.event_enable & 0x40) ? "+" : "-");\r\nseq_printf(seq, " [%s] High catastrophic. \n",\r\n(result.event_enable & 0x80) ? "+" : "-");\r\nreturn 0;\r\n}\r\nstatic int i2o_seq_open_hrt(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_hrt, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_lct(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_lct, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_status(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_status, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_hw(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_hw, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_ddm_table(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_ddm_table, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_driver_store(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_driver_store, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_drivers_stored(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_drivers_stored, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_groups(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_groups, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_phys_device(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_phys_device, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_claimed(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_claimed, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_users(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_users, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_priv_msgs(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_priv_msgs, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_authorized_users(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_authorized_users,\r\nPDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_dev_identity(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_dev_identity, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_ddm_identity(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_ddm_identity, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_uinfo(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_uinfo, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_sgl_limits(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_sgl_limits, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_sensors(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_sensors, PDE(inode)->data);\r\n}\r\nstatic int i2o_seq_open_dev_name(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, i2o_seq_show_dev_name, PDE(inode)->data);\r\n}\r\nstatic int i2o_proc_create_entries(struct proc_dir_entry *dir,\r\ni2o_proc_entry * i2o_pe, void *data)\r\n{\r\nstruct proc_dir_entry *tmp;\r\nwhile (i2o_pe->name) {\r\ntmp = proc_create_data(i2o_pe->name, i2o_pe->mode, dir,\r\ni2o_pe->fops, data);\r\nif (!tmp)\r\nreturn -1;\r\ni2o_pe++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void i2o_proc_subdir_remove(struct proc_dir_entry *dir)\r\n{\r\nstruct proc_dir_entry *pe, *tmp;\r\npe = dir->subdir;\r\nwhile (pe) {\r\ntmp = pe->next;\r\ni2o_proc_subdir_remove(pe);\r\nremove_proc_entry(pe->name, dir);\r\npe = tmp;\r\n}\r\n}\r\nstatic void i2o_proc_device_add(struct proc_dir_entry *dir,\r\nstruct i2o_device *dev)\r\n{\r\nchar buff[10];\r\nstruct proc_dir_entry *devdir;\r\ni2o_proc_entry *i2o_pe = NULL;\r\nsprintf(buff, "%03x", dev->lct_data.tid);\r\nosm_debug("adding device /proc/i2o/%s/%s\n", dev->iop->name, buff);\r\ndevdir = proc_mkdir(buff, dir);\r\nif (!devdir) {\r\nosm_warn("Could not allocate procdir!\n");\r\nreturn;\r\n}\r\ndevdir->data = dev;\r\ni2o_proc_create_entries(devdir, generic_dev_entries, dev);\r\nswitch (dev->lct_data.class_id) {\r\ncase I2O_CLASS_SCSI_PERIPHERAL:\r\ncase I2O_CLASS_RANDOM_BLOCK_STORAGE:\r\ni2o_pe = rbs_dev_entries;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (i2o_pe)\r\ni2o_proc_create_entries(devdir, i2o_pe, dev);\r\n}\r\nstatic int i2o_proc_iop_add(struct proc_dir_entry *dir,\r\nstruct i2o_controller *c)\r\n{\r\nstruct proc_dir_entry *iopdir;\r\nstruct i2o_device *dev;\r\nosm_debug("adding IOP /proc/i2o/%s\n", c->name);\r\niopdir = proc_mkdir(c->name, dir);\r\nif (!iopdir)\r\nreturn -1;\r\niopdir->data = c;\r\ni2o_proc_create_entries(iopdir, i2o_proc_generic_iop_entries, c);\r\nlist_for_each_entry(dev, &c->devices, list)\r\ni2o_proc_device_add(iopdir, dev);\r\nreturn 0;\r\n}\r\nstatic void i2o_proc_iop_remove(struct proc_dir_entry *dir,\r\nstruct i2o_controller *c)\r\n{\r\nstruct proc_dir_entry *pe, *tmp;\r\npe = dir->subdir;\r\nwhile (pe) {\r\ntmp = pe->next;\r\nif (pe->data == c) {\r\ni2o_proc_subdir_remove(pe);\r\nremove_proc_entry(pe->name, dir);\r\n}\r\nosm_debug("removing IOP /proc/i2o/%s\n", c->name);\r\npe = tmp;\r\n}\r\n}\r\nstatic int __init i2o_proc_fs_create(void)\r\n{\r\nstruct i2o_controller *c;\r\ni2o_proc_dir_root = proc_mkdir("i2o", NULL);\r\nif (!i2o_proc_dir_root)\r\nreturn -1;\r\nlist_for_each_entry(c, &i2o_controllers, list)\r\ni2o_proc_iop_add(i2o_proc_dir_root, c);\r\nreturn 0;\r\n}\r\nstatic int __exit i2o_proc_fs_destroy(void)\r\n{\r\nstruct i2o_controller *c;\r\nlist_for_each_entry(c, &i2o_controllers, list)\r\ni2o_proc_iop_remove(i2o_proc_dir_root, c);\r\nremove_proc_entry("i2o", NULL);\r\nreturn 0;\r\n}\r\nstatic int __init i2o_proc_init(void)\r\n{\r\nint rc;\r\nprintk(KERN_INFO OSM_DESCRIPTION " v" OSM_VERSION "\n");\r\nrc = i2o_driver_register(&i2o_proc_driver);\r\nif (rc)\r\nreturn rc;\r\nrc = i2o_proc_fs_create();\r\nif (rc) {\r\ni2o_driver_unregister(&i2o_proc_driver);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit i2o_proc_exit(void)\r\n{\r\ni2o_driver_unregister(&i2o_proc_driver);\r\ni2o_proc_fs_destroy();\r\n}
