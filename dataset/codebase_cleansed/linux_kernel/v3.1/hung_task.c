static int __init hung_task_panic_setup(char *str)\r\n{\r\nsysctl_hung_task_panic = simple_strtoul(str, NULL, 0);\r\nreturn 1;\r\n}\r\nstatic int\r\nhung_task_panic(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\ndid_panic = 1;\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void check_hung_task(struct task_struct *t, unsigned long timeout)\r\n{\r\nunsigned long switch_count = t->nvcsw + t->nivcsw;\r\nif (unlikely(t->flags & PF_FROZEN || !switch_count))\r\nreturn;\r\nif (switch_count != t->last_switch_count) {\r\nt->last_switch_count = switch_count;\r\nreturn;\r\n}\r\nif (!sysctl_hung_task_warnings)\r\nreturn;\r\nsysctl_hung_task_warnings--;\r\nprintk(KERN_ERR "INFO: task %s:%d blocked for more than "\r\n"%ld seconds.\n", t->comm, t->pid, timeout);\r\nprintk(KERN_ERR "\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\""\r\n" disables this message.\n");\r\nsched_show_task(t);\r\ndebug_show_held_locks(t);\r\ntouch_nmi_watchdog();\r\nif (sysctl_hung_task_panic)\r\npanic("hung_task: blocked tasks");\r\n}\r\nstatic void rcu_lock_break(struct task_struct *g, struct task_struct *t)\r\n{\r\nget_task_struct(g);\r\nget_task_struct(t);\r\nrcu_read_unlock();\r\ncond_resched();\r\nrcu_read_lock();\r\nput_task_struct(t);\r\nput_task_struct(g);\r\n}\r\nstatic void check_hung_uninterruptible_tasks(unsigned long timeout)\r\n{\r\nint max_count = sysctl_hung_task_check_count;\r\nint batch_count = HUNG_TASK_BATCHING;\r\nstruct task_struct *g, *t;\r\nif (test_taint(TAINT_DIE) || did_panic)\r\nreturn;\r\nrcu_read_lock();\r\ndo_each_thread(g, t) {\r\nif (!max_count--)\r\ngoto unlock;\r\nif (!--batch_count) {\r\nbatch_count = HUNG_TASK_BATCHING;\r\nrcu_lock_break(g, t);\r\nif (t->state == TASK_DEAD || g->state == TASK_DEAD)\r\ngoto unlock;\r\n}\r\nif (t->state == TASK_UNINTERRUPTIBLE)\r\ncheck_hung_task(t, timeout);\r\n} while_each_thread(g, t);\r\nunlock:\r\nrcu_read_unlock();\r\n}\r\nstatic unsigned long timeout_jiffies(unsigned long timeout)\r\n{\r\nreturn timeout ? timeout * HZ : MAX_SCHEDULE_TIMEOUT;\r\n}\r\nint proc_dohung_task_timeout_secs(struct ctl_table *table, int write,\r\nvoid __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\nint ret;\r\nret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\r\nif (ret || !write)\r\ngoto out;\r\nwake_up_process(watchdog_task);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int watchdog(void *dummy)\r\n{\r\nset_user_nice(current, 0);\r\nfor ( ; ; ) {\r\nunsigned long timeout = sysctl_hung_task_timeout_secs;\r\nwhile (schedule_timeout_interruptible(timeout_jiffies(timeout)))\r\ntimeout = sysctl_hung_task_timeout_secs;\r\ncheck_hung_uninterruptible_tasks(timeout);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init hung_task_init(void)\r\n{\r\natomic_notifier_chain_register(&panic_notifier_list, &panic_block);\r\nwatchdog_task = kthread_run(watchdog, NULL, "khungtaskd");\r\nreturn 0;\r\n}
