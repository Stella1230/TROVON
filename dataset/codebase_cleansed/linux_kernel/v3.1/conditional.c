static int cond_evaluate_expr(struct policydb *p, struct cond_expr *expr)\r\n{\r\nstruct cond_expr *cur;\r\nint s[COND_EXPR_MAXDEPTH];\r\nint sp = -1;\r\nfor (cur = expr; cur; cur = cur->next) {\r\nswitch (cur->expr_type) {\r\ncase COND_BOOL:\r\nif (sp == (COND_EXPR_MAXDEPTH - 1))\r\nreturn -1;\r\nsp++;\r\ns[sp] = p->bool_val_to_struct[cur->bool - 1]->state;\r\nbreak;\r\ncase COND_NOT:\r\nif (sp < 0)\r\nreturn -1;\r\ns[sp] = !s[sp];\r\nbreak;\r\ncase COND_OR:\r\nif (sp < 1)\r\nreturn -1;\r\nsp--;\r\ns[sp] |= s[sp + 1];\r\nbreak;\r\ncase COND_AND:\r\nif (sp < 1)\r\nreturn -1;\r\nsp--;\r\ns[sp] &= s[sp + 1];\r\nbreak;\r\ncase COND_XOR:\r\nif (sp < 1)\r\nreturn -1;\r\nsp--;\r\ns[sp] ^= s[sp + 1];\r\nbreak;\r\ncase COND_EQ:\r\nif (sp < 1)\r\nreturn -1;\r\nsp--;\r\ns[sp] = (s[sp] == s[sp + 1]);\r\nbreak;\r\ncase COND_NEQ:\r\nif (sp < 1)\r\nreturn -1;\r\nsp--;\r\ns[sp] = (s[sp] != s[sp + 1]);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nreturn s[0];\r\n}\r\nint evaluate_cond_node(struct policydb *p, struct cond_node *node)\r\n{\r\nint new_state;\r\nstruct cond_av_list *cur;\r\nnew_state = cond_evaluate_expr(p, node->expr);\r\nif (new_state != node->cur_state) {\r\nnode->cur_state = new_state;\r\nif (new_state == -1)\r\nprintk(KERN_ERR "SELinux: expression result was undefined - disabling all rules.\n");\r\nfor (cur = node->true_list; cur; cur = cur->next) {\r\nif (new_state <= 0)\r\ncur->node->key.specified &= ~AVTAB_ENABLED;\r\nelse\r\ncur->node->key.specified |= AVTAB_ENABLED;\r\n}\r\nfor (cur = node->false_list; cur; cur = cur->next) {\r\nif (new_state)\r\ncur->node->key.specified &= ~AVTAB_ENABLED;\r\nelse\r\ncur->node->key.specified |= AVTAB_ENABLED;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cond_policydb_init(struct policydb *p)\r\n{\r\nint rc;\r\np->bool_val_to_struct = NULL;\r\np->cond_list = NULL;\r\nrc = avtab_init(&p->te_cond_avtab);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic void cond_av_list_destroy(struct cond_av_list *list)\r\n{\r\nstruct cond_av_list *cur, *next;\r\nfor (cur = list; cur; cur = next) {\r\nnext = cur->next;\r\nkfree(cur);\r\n}\r\n}\r\nstatic void cond_node_destroy(struct cond_node *node)\r\n{\r\nstruct cond_expr *cur_expr, *next_expr;\r\nfor (cur_expr = node->expr; cur_expr; cur_expr = next_expr) {\r\nnext_expr = cur_expr->next;\r\nkfree(cur_expr);\r\n}\r\ncond_av_list_destroy(node->true_list);\r\ncond_av_list_destroy(node->false_list);\r\nkfree(node);\r\n}\r\nstatic void cond_list_destroy(struct cond_node *list)\r\n{\r\nstruct cond_node *next, *cur;\r\nif (list == NULL)\r\nreturn;\r\nfor (cur = list; cur; cur = next) {\r\nnext = cur->next;\r\ncond_node_destroy(cur);\r\n}\r\n}\r\nvoid cond_policydb_destroy(struct policydb *p)\r\n{\r\nkfree(p->bool_val_to_struct);\r\navtab_destroy(&p->te_cond_avtab);\r\ncond_list_destroy(p->cond_list);\r\n}\r\nint cond_init_bool_indexes(struct policydb *p)\r\n{\r\nkfree(p->bool_val_to_struct);\r\np->bool_val_to_struct = (struct cond_bool_datum **)\r\nkmalloc(p->p_bools.nprim * sizeof(struct cond_bool_datum *), GFP_KERNEL);\r\nif (!p->bool_val_to_struct)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint cond_destroy_bool(void *key, void *datum, void *p)\r\n{\r\nkfree(key);\r\nkfree(datum);\r\nreturn 0;\r\n}\r\nint cond_index_bool(void *key, void *datum, void *datap)\r\n{\r\nstruct policydb *p;\r\nstruct cond_bool_datum *booldatum;\r\nstruct flex_array *fa;\r\nbooldatum = datum;\r\np = datap;\r\nif (!booldatum->value || booldatum->value > p->p_bools.nprim)\r\nreturn -EINVAL;\r\nfa = p->sym_val_to_name[SYM_BOOLS];\r\nif (flex_array_put_ptr(fa, booldatum->value - 1, key,\r\nGFP_KERNEL | __GFP_ZERO))\r\nBUG();\r\np->bool_val_to_struct[booldatum->value - 1] = booldatum;\r\nreturn 0;\r\n}\r\nstatic int bool_isvalid(struct cond_bool_datum *b)\r\n{\r\nif (!(b->state == 0 || b->state == 1))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint cond_read_bool(struct policydb *p, struct hashtab *h, void *fp)\r\n{\r\nchar *key = NULL;\r\nstruct cond_bool_datum *booldatum;\r\n__le32 buf[3];\r\nu32 len;\r\nint rc;\r\nbooldatum = kzalloc(sizeof(struct cond_bool_datum), GFP_KERNEL);\r\nif (!booldatum)\r\nreturn -ENOMEM;\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc)\r\ngoto err;\r\nbooldatum->value = le32_to_cpu(buf[0]);\r\nbooldatum->state = le32_to_cpu(buf[1]);\r\nrc = -EINVAL;\r\nif (!bool_isvalid(booldatum))\r\ngoto err;\r\nlen = le32_to_cpu(buf[2]);\r\nrc = -ENOMEM;\r\nkey = kmalloc(len + 1, GFP_KERNEL);\r\nif (!key)\r\ngoto err;\r\nrc = next_entry(key, fp, len);\r\nif (rc)\r\ngoto err;\r\nkey[len] = '\0';\r\nrc = hashtab_insert(h, key, booldatum);\r\nif (rc)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ncond_destroy_bool(key, booldatum, NULL);\r\nreturn rc;\r\n}\r\nstatic int cond_insertf(struct avtab *a, struct avtab_key *k, struct avtab_datum *d, void *ptr)\r\n{\r\nstruct cond_insertf_data *data = ptr;\r\nstruct policydb *p = data->p;\r\nstruct cond_av_list *other = data->other, *list, *cur;\r\nstruct avtab_node *node_ptr;\r\nu8 found;\r\nint rc = -EINVAL;\r\nif (k->specified & AVTAB_TYPE) {\r\nif (avtab_search(&p->te_avtab, k)) {\r\nprintk(KERN_ERR "SELinux: type rule already exists outside of a conditional.\n");\r\ngoto err;\r\n}\r\nif (other) {\r\nnode_ptr = avtab_search_node(&p->te_cond_avtab, k);\r\nif (node_ptr) {\r\nif (avtab_search_node_next(node_ptr, k->specified)) {\r\nprintk(KERN_ERR "SELinux: too many conflicting type rules.\n");\r\ngoto err;\r\n}\r\nfound = 0;\r\nfor (cur = other; cur; cur = cur->next) {\r\nif (cur->node == node_ptr) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nprintk(KERN_ERR "SELinux: conflicting type rules.\n");\r\ngoto err;\r\n}\r\n}\r\n} else {\r\nif (avtab_search(&p->te_cond_avtab, k)) {\r\nprintk(KERN_ERR "SELinux: conflicting type rules when adding type rule for true.\n");\r\ngoto err;\r\n}\r\n}\r\n}\r\nnode_ptr = avtab_insert_nonunique(&p->te_cond_avtab, k, d);\r\nif (!node_ptr) {\r\nprintk(KERN_ERR "SELinux: could not insert rule.\n");\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nlist = kzalloc(sizeof(struct cond_av_list), GFP_KERNEL);\r\nif (!list) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nlist->node = node_ptr;\r\nif (!data->head)\r\ndata->head = list;\r\nelse\r\ndata->tail->next = list;\r\ndata->tail = list;\r\nreturn 0;\r\nerr:\r\ncond_av_list_destroy(data->head);\r\ndata->head = NULL;\r\nreturn rc;\r\n}\r\nstatic int cond_read_av_list(struct policydb *p, void *fp, struct cond_av_list **ret_list, struct cond_av_list *other)\r\n{\r\nint i, rc;\r\n__le32 buf[1];\r\nu32 len;\r\nstruct cond_insertf_data data;\r\n*ret_list = NULL;\r\nlen = 0;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\nreturn rc;\r\nlen = le32_to_cpu(buf[0]);\r\nif (len == 0)\r\nreturn 0;\r\ndata.p = p;\r\ndata.other = other;\r\ndata.head = NULL;\r\ndata.tail = NULL;\r\nfor (i = 0; i < len; i++) {\r\nrc = avtab_read_item(&p->te_cond_avtab, fp, p, cond_insertf,\r\n&data);\r\nif (rc)\r\nreturn rc;\r\n}\r\n*ret_list = data.head;\r\nreturn 0;\r\n}\r\nstatic int expr_isvalid(struct policydb *p, struct cond_expr *expr)\r\n{\r\nif (expr->expr_type <= 0 || expr->expr_type > COND_LAST) {\r\nprintk(KERN_ERR "SELinux: conditional expressions uses unknown operator.\n");\r\nreturn 0;\r\n}\r\nif (expr->bool > p->p_bools.nprim) {\r\nprintk(KERN_ERR "SELinux: conditional expressions uses unknown bool.\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int cond_read_node(struct policydb *p, struct cond_node *node, void *fp)\r\n{\r\n__le32 buf[2];\r\nu32 len, i;\r\nint rc;\r\nstruct cond_expr *expr = NULL, *last = NULL;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\nreturn rc;\r\nnode->cur_state = le32_to_cpu(buf[0]);\r\nlen = 0;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc)\r\nreturn rc;\r\nlen = le32_to_cpu(buf[0]);\r\nfor (i = 0; i < len; i++) {\r\nrc = next_entry(buf, fp, sizeof(u32) * 2);\r\nif (rc)\r\ngoto err;\r\nrc = -ENOMEM;\r\nexpr = kzalloc(sizeof(struct cond_expr), GFP_KERNEL);\r\nif (!expr)\r\ngoto err;\r\nexpr->expr_type = le32_to_cpu(buf[0]);\r\nexpr->bool = le32_to_cpu(buf[1]);\r\nif (!expr_isvalid(p, expr)) {\r\nrc = -EINVAL;\r\nkfree(expr);\r\ngoto err;\r\n}\r\nif (i == 0)\r\nnode->expr = expr;\r\nelse\r\nlast->next = expr;\r\nlast = expr;\r\n}\r\nrc = cond_read_av_list(p, fp, &node->true_list, NULL);\r\nif (rc)\r\ngoto err;\r\nrc = cond_read_av_list(p, fp, &node->false_list, node->true_list);\r\nif (rc)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ncond_node_destroy(node);\r\nreturn rc;\r\n}\r\nint cond_read_list(struct policydb *p, void *fp)\r\n{\r\nstruct cond_node *node, *last = NULL;\r\n__le32 buf[1];\r\nu32 i, len;\r\nint rc;\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc)\r\nreturn rc;\r\nlen = le32_to_cpu(buf[0]);\r\nrc = avtab_alloc(&(p->te_cond_avtab), p->te_avtab.nel);\r\nif (rc)\r\ngoto err;\r\nfor (i = 0; i < len; i++) {\r\nrc = -ENOMEM;\r\nnode = kzalloc(sizeof(struct cond_node), GFP_KERNEL);\r\nif (!node)\r\ngoto err;\r\nrc = cond_read_node(p, node, fp);\r\nif (rc)\r\ngoto err;\r\nif (i == 0)\r\np->cond_list = node;\r\nelse\r\nlast->next = node;\r\nlast = node;\r\n}\r\nreturn 0;\r\nerr:\r\ncond_list_destroy(p->cond_list);\r\np->cond_list = NULL;\r\nreturn rc;\r\n}\r\nint cond_write_bool(void *vkey, void *datum, void *ptr)\r\n{\r\nchar *key = vkey;\r\nstruct cond_bool_datum *booldatum = datum;\r\nstruct policy_data *pd = ptr;\r\nvoid *fp = pd->fp;\r\n__le32 buf[3];\r\nu32 len;\r\nint rc;\r\nlen = strlen(key);\r\nbuf[0] = cpu_to_le32(booldatum->value);\r\nbuf[1] = cpu_to_le32(booldatum->state);\r\nbuf[2] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 3, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = put_entry(key, 1, len, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int cond_write_av_list(struct policydb *p,\r\nstruct cond_av_list *list, struct policy_file *fp)\r\n{\r\n__le32 buf[1];\r\nstruct cond_av_list *cur_list;\r\nu32 len;\r\nint rc;\r\nlen = 0;\r\nfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next)\r\nlen++;\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nif (len == 0)\r\nreturn 0;\r\nfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next) {\r\nrc = avtab_write_item(p, cur_list->node, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint cond_write_node(struct policydb *p, struct cond_node *node,\r\nstruct policy_file *fp)\r\n{\r\nstruct cond_expr *cur_expr;\r\n__le32 buf[2];\r\nint rc;\r\nu32 len = 0;\r\nbuf[0] = cpu_to_le32(node->cur_state);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next)\r\nlen++;\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next) {\r\nbuf[0] = cpu_to_le32(cur_expr->expr_type);\r\nbuf[1] = cpu_to_le32(cur_expr->bool);\r\nrc = put_entry(buf, sizeof(u32), 2, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = cond_write_av_list(p, node->true_list, fp);\r\nif (rc)\r\nreturn rc;\r\nrc = cond_write_av_list(p, node->false_list, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nint cond_write_list(struct policydb *p, struct cond_node *list, void *fp)\r\n{\r\nstruct cond_node *cur;\r\nu32 len;\r\n__le32 buf[1];\r\nint rc;\r\nlen = 0;\r\nfor (cur = list; cur != NULL; cur = cur->next)\r\nlen++;\r\nbuf[0] = cpu_to_le32(len);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (cur = list; cur != NULL; cur = cur->next) {\r\nrc = cond_write_node(p, cur, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid cond_compute_av(struct avtab *ctab, struct avtab_key *key, struct av_decision *avd)\r\n{\r\nstruct avtab_node *node;\r\nif (!ctab || !key || !avd)\r\nreturn;\r\nfor (node = avtab_search_node(ctab, key); node;\r\nnode = avtab_search_node_next(node, key->specified)) {\r\nif ((u16)(AVTAB_ALLOWED|AVTAB_ENABLED) ==\r\n(node->key.specified & (AVTAB_ALLOWED|AVTAB_ENABLED)))\r\navd->allowed |= node->datum.data;\r\nif ((u16)(AVTAB_AUDITDENY|AVTAB_ENABLED) ==\r\n(node->key.specified & (AVTAB_AUDITDENY|AVTAB_ENABLED)))\r\navd->auditdeny &= node->datum.data;\r\nif ((u16)(AVTAB_AUDITALLOW|AVTAB_ENABLED) ==\r\n(node->key.specified & (AVTAB_AUDITALLOW|AVTAB_ENABLED)))\r\navd->auditallow |= node->datum.data;\r\n}\r\nreturn;\r\n}
