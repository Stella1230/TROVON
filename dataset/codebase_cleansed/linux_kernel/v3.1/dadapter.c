static void no_printf (unsigned char * format, ...)\r\n{\r\n#ifdef EBUG\r\nva_list ap;\r\nva_start (ap, format);\r\ndebug((format, ap));\r\nva_end (ap);\r\n#endif\r\n}\r\nvoid diva_didd_load_time_init (void) {\r\nmemset (&HandleTable[0], 0x00, sizeof(HandleTable));\r\nmemset (&NotificationTable[0], 0x00, sizeof(NotificationTable));\r\ndiva_os_initialize_spin_lock (&didd_spin, "didd");\r\n}\r\nvoid diva_didd_load_time_finit (void) {\r\ndiva_os_destroy_spin_lock (&didd_spin, "didd");\r\n}\r\nstatic int diva_didd_add_descriptor (DESCRIPTOR* d) {\r\ndiva_os_spin_lock_magic_t irql;\r\nint i;\r\nif (d->type == IDI_DIMAINT) {\r\nif (d->request) {\r\nMAdapter.request = d->request;\r\ndprintf = (DIVA_DI_PRINTF)d->request;\r\ndiva_notify_adapter_change (&MAdapter, 0);\r\nDBG_TRC (("DIMAINT registered, dprintf=%08x", d->request))\r\n} else {\r\nDBG_TRC (("DIMAINT removed"))\r\ndiva_notify_adapter_change (&MAdapter, 1);\r\nMAdapter.request = (IDI_CALL)no_printf;\r\ndprintf = no_printf;\r\n}\r\nreturn (NEW_MAX_DESCRIPTORS);\r\n}\r\nfor (i = 0; i < NEW_MAX_DESCRIPTORS; i++) {\r\ndiva_os_enter_spin_lock (&didd_spin, &irql, "didd_add");\r\nif (HandleTable[i].type == 0) {\r\nmemcpy (&HandleTable[i], d, sizeof(*d));\r\nAdapters++;\r\ndiva_os_leave_spin_lock (&didd_spin, &irql, "didd_add");\r\ndiva_notify_adapter_change (d, 0);\r\nDBG_TRC (("Add adapter[%d], request=%08x", (i+1), d->request))\r\nreturn (i+1);\r\n}\r\ndiva_os_leave_spin_lock (&didd_spin, &irql, "didd_add");\r\n}\r\nDBG_ERR (("Can't add adapter, out of resources"))\r\nreturn (-1);\r\n}\r\nstatic int diva_didd_remove_descriptor (IDI_CALL request) {\r\ndiva_os_spin_lock_magic_t irql;\r\nint i;\r\nif (request == MAdapter.request) {\r\nDBG_TRC(("DIMAINT removed"))\r\ndprintf = no_printf;\r\ndiva_notify_adapter_change (&MAdapter, 1);\r\nMAdapter.request = (IDI_CALL)no_printf;\r\nreturn (0);\r\n}\r\nfor (i = 0; (Adapters && (i < NEW_MAX_DESCRIPTORS)); i++) {\r\nif (HandleTable[i].request == request) {\r\ndiva_notify_adapter_change (&HandleTable[i], 1);\r\ndiva_os_enter_spin_lock (&didd_spin, &irql, "didd_rm");\r\nmemset (&HandleTable[i], 0x00, sizeof(HandleTable[0]));\r\nAdapters--;\r\ndiva_os_leave_spin_lock (&didd_spin, &irql, "didd_rm");\r\nDBG_TRC (("Remove adapter[%d], request=%08x", (i+1), request))\r\nreturn (0);\r\n}\r\n}\r\nDBG_ERR (("Invalid request=%08x, can't remove adapter", request))\r\nreturn (-1);\r\n}\r\nstatic int diva_didd_read_adapter_array (DESCRIPTOR* buffer, int length) {\r\ndiva_os_spin_lock_magic_t irql;\r\nint src, dst;\r\nmemset (buffer, 0x00, length);\r\nlength /= sizeof(DESCRIPTOR);\r\nDBG_TRC (("DIDD_Read, space = %d, Adapters = %d", length, Adapters+2))\r\ndiva_os_enter_spin_lock (&didd_spin, &irql, "didd_read");\r\nfor (src = 0, dst = 0;\r\n(Adapters && (src < NEW_MAX_DESCRIPTORS) && (dst < length));\r\nsrc++) {\r\nif (HandleTable[src].type) {\r\nmemcpy (&buffer[dst], &HandleTable[src], sizeof(DESCRIPTOR));\r\ndst++;\r\n}\r\n}\r\ndiva_os_leave_spin_lock (&didd_spin, &irql, "didd_read");\r\nif (dst < length) {\r\nmemcpy (&buffer[dst], &MAdapter, sizeof(DESCRIPTOR));\r\ndst++;\r\n} else {\r\nDBG_ERR (("Can't write DIMAINT. Array too small"))\r\n}\r\nif (dst < length) {\r\nmemcpy (&buffer[dst], &DAdapter, sizeof(DESCRIPTOR));\r\ndst++;\r\n} else {\r\nDBG_ERR (("Can't write DADAPTER. Array too small"))\r\n}\r\nDBG_TRC (("Read %d adapters", dst))\r\nreturn (dst == length);\r\n}\r\nstatic void IDI_CALL_LINK_T diva_dadapter_request (\\r\nENTITY IDI_CALL_ENTITY_T *e) {\r\nIDI_SYNC_REQ *syncReq = (IDI_SYNC_REQ *)e ;\r\nif (e->Req) {\r\ne->Rc = OUT_OF_RESOURCES;\r\nDBG_ERR (("Can't process async request, Req=%02x", e->Req))\r\nreturn;\r\n}\r\nswitch (e->Rc) {\r\ncase IDI_SYNC_REQ_DIDD_REGISTER_ADAPTER_NOTIFY: {\r\ndiva_didd_adapter_notify_t* pinfo = &syncReq->didd_notify.info;\r\npinfo->handle = diva_register_adapter_callback (\\r\n(didd_adapter_change_callback_t)pinfo->callback,\r\n(void IDI_CALL_ENTITY_T *)pinfo->context);\r\ne->Rc = 0xff;\r\n} break;\r\ncase IDI_SYNC_REQ_DIDD_REMOVE_ADAPTER_NOTIFY: {\r\ndiva_didd_adapter_notify_t* pinfo = &syncReq->didd_notify.info;\r\ndiva_remove_adapter_callback (pinfo->handle);\r\ne->Rc = 0xff;\r\n} break;\r\ncase IDI_SYNC_REQ_DIDD_ADD_ADAPTER: {\r\ndiva_didd_add_adapter_t* pinfo = &syncReq->didd_add_adapter.info;\r\nif (diva_didd_add_descriptor ((DESCRIPTOR*)pinfo->descriptor) < 0) {\r\ne->Rc = OUT_OF_RESOURCES;\r\n} else {\r\ne->Rc = 0xff;\r\n}\r\n} break;\r\ncase IDI_SYNC_REQ_DIDD_REMOVE_ADAPTER: {\r\ndiva_didd_remove_adapter_t* pinfo = &syncReq->didd_remove_adapter.info;\r\nif (diva_didd_remove_descriptor ((IDI_CALL)pinfo->p_request) < 0) {\r\ne->Rc = OUT_OF_RESOURCES;\r\n} else {\r\ne->Rc = 0xff;\r\n}\r\n} break;\r\ncase IDI_SYNC_REQ_DIDD_READ_ADAPTER_ARRAY: {\r\ndiva_didd_read_adapter_array_t* pinfo =\\r\n&syncReq->didd_read_adapter_array.info;\r\nif (diva_didd_read_adapter_array ((DESCRIPTOR*)pinfo->buffer,\r\n(int)pinfo->length)) {\r\ne->Rc = OUT_OF_RESOURCES;\r\n} else {\r\ne->Rc = 0xff;\r\n}\r\n} break;\r\ndefault:\r\nDBG_ERR (("Can't process sync request, Req=%02x", e->Rc))\r\ne->Rc = OUT_OF_RESOURCES;\r\n}\r\n}\r\nstatic dword diva_register_adapter_callback (\\r\ndidd_adapter_change_callback_t callback,\r\nvoid IDI_CALL_ENTITY_T* context) {\r\ndiva_os_spin_lock_magic_t irql;\r\ndword i;\r\nfor (i = 0; i < DIVA_DIDD_MAX_NOTIFICATIONS; i++) {\r\ndiva_os_enter_spin_lock (&didd_spin, &irql, "didd_nfy_add");\r\nif (!NotificationTable[i].callback) {\r\nNotificationTable[i].callback = callback;\r\nNotificationTable[i].context = context;\r\ndiva_os_leave_spin_lock (&didd_spin, &irql, "didd_nfy_add");\r\nDBG_TRC(("Register adapter notification[%d]=%08x", i+1, callback))\r\nreturn (i+1);\r\n}\r\ndiva_os_leave_spin_lock (&didd_spin, &irql, "didd_nfy_add");\r\n}\r\nDBG_ERR (("Can't register adapter notification, overflow"))\r\nreturn (0);\r\n}\r\nstatic void diva_remove_adapter_callback (dword handle) {\r\ndiva_os_spin_lock_magic_t irql;\r\nif (handle && ((--handle) < DIVA_DIDD_MAX_NOTIFICATIONS)) {\r\ndiva_os_enter_spin_lock (&didd_spin, &irql, "didd_nfy_rm");\r\nNotificationTable[handle].callback = NULL;\r\nNotificationTable[handle].context = NULL;\r\ndiva_os_leave_spin_lock (&didd_spin, &irql, "didd_nfy_rm");\r\nDBG_TRC(("Remove adapter notification[%d]", (int)(handle+1)))\r\nreturn;\r\n}\r\nDBG_ERR(("Can't remove adapter notification, handle=%d", handle))\r\n}\r\nstatic void diva_notify_adapter_change (DESCRIPTOR* d, int removal) {\r\nint i, do_notify;\r\ndidd_adapter_change_notification_t nfy;\r\ndiva_os_spin_lock_magic_t irql;\r\nfor (i = 0; i < DIVA_DIDD_MAX_NOTIFICATIONS; i++) {\r\ndo_notify = 0;\r\ndiva_os_enter_spin_lock (&didd_spin, &irql, "didd_nfy");\r\nif (NotificationTable[i].callback) {\r\nmemcpy (&nfy, &NotificationTable[i], sizeof(nfy));\r\ndo_notify = 1;\r\n}\r\ndiva_os_leave_spin_lock (&didd_spin, &irql, "didd_nfy");\r\nif (do_notify) {\r\n(*(nfy.callback))(nfy.context, d, removal);\r\n}\r\n}\r\n}\r\nvoid IDI_CALL_LINK_T DIVA_DIDD_Read (void IDI_CALL_ENTITY_T * buffer,\r\nint length) {\r\ndiva_didd_read_adapter_array (buffer, length);\r\n}
