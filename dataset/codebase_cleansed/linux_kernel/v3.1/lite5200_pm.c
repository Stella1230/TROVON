static int lite5200_pm_valid(suspend_state_t state)\r\n{\r\nswitch (state) {\r\ncase PM_SUSPEND_STANDBY:\r\ncase PM_SUSPEND_MEM:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int lite5200_pm_begin(suspend_state_t state)\r\n{\r\nif (lite5200_pm_valid(state)) {\r\nlite5200_pm_target_state = state;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int lite5200_pm_prepare(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id immr_ids[] = {\r\n{ .compatible = "fsl,mpc5200-immr", },\r\n{ .compatible = "fsl,mpc5200b-immr", },\r\n{ .type = "soc", .compatible = "mpc5200", },\r\n{ .type = "builtin", .compatible = "mpc5200", },\r\n{}\r\n};\r\nu64 regaddr64 = 0;\r\nconst u32 *regaddr_p;\r\nif (lite5200_pm_target_state == PM_SUSPEND_STANDBY)\r\nreturn mpc52xx_pm_prepare();\r\nif (lite5200_pm_target_state != PM_SUSPEND_MEM)\r\nreturn -EINVAL;\r\nnp = of_find_matching_node(NULL, immr_ids);\r\nregaddr_p = of_get_address(np, 0, NULL, NULL);\r\nif (regaddr_p)\r\nregaddr64 = of_translate_address(np, regaddr_p);\r\nof_node_put(np);\r\nmbar = ioremap((u32) regaddr64, 0xC000);\r\nif (!mbar) {\r\nprintk(KERN_ERR "%s:%i Error mapping registers\n", __func__, __LINE__);\r\nreturn -ENOSYS;\r\n}\r\ncdm = mbar + 0x200;\r\npic = mbar + 0x500;\r\ngps = mbar + 0xb00;\r\ngpw = mbar + 0xc00;\r\npci = mbar + 0xd00;\r\nbes = mbar + 0x1200;\r\nxlb = mbar + 0x1f00;\r\nsram = mbar + 0x8000;\r\nreturn 0;\r\n}\r\nstatic void lite5200_save_regs(void)\r\n{\r\n_memcpy_fromio(&spic, pic, sizeof(*pic));\r\n_memcpy_fromio(&sbes, bes, sizeof(*bes));\r\n_memcpy_fromio(&scdm, cdm, sizeof(*cdm));\r\n_memcpy_fromio(&sxlb, xlb, sizeof(*xlb));\r\n_memcpy_fromio(&sgps, gps, sizeof(*gps));\r\n_memcpy_fromio(&sgpw, gpw, sizeof(*gpw));\r\n_memcpy_fromio(spci, pci, 0x200);\r\n_memcpy_fromio(saved_sram, sram, sram_size);\r\n}\r\nstatic void lite5200_restore_regs(void)\r\n{\r\nint i;\r\n_memcpy_toio(sram, saved_sram, sram_size);\r\n_memcpy_toio(pci, spci, 0x200);\r\n_memcpy_toio(gpw, &sgpw, sizeof(*gpw));\r\n_memcpy_toio(gps, &sgps, sizeof(*gps));\r\nout_be32(&xlb->snoop_window, sxlb.snoop_window);\r\nout_be32(&xlb->master_priority, sxlb.master_priority);\r\nout_be32(&xlb->master_pri_enable, sxlb.master_pri_enable);\r\nout_be32(&xlb->int_enable, sxlb.int_enable);\r\nout_be32(&xlb->config, sxlb.config);\r\nout_8(&cdm->ipb_clk_sel, scdm.ipb_clk_sel);\r\nout_8(&cdm->pci_clk_sel, scdm.pci_clk_sel);\r\nout_8(&cdm->ext_48mhz_en, scdm.ext_48mhz_en);\r\nout_8(&cdm->fd_enable, scdm.fd_enable);\r\nout_be16(&cdm->fd_counters, scdm.fd_counters);\r\nout_be32(&cdm->clk_enables, scdm.clk_enables);\r\nout_8(&cdm->osc_disable, scdm.osc_disable);\r\nout_be16(&cdm->mclken_div_psc1, scdm.mclken_div_psc1);\r\nout_be16(&cdm->mclken_div_psc2, scdm.mclken_div_psc2);\r\nout_be16(&cdm->mclken_div_psc3, scdm.mclken_div_psc3);\r\nout_be16(&cdm->mclken_div_psc6, scdm.mclken_div_psc6);\r\nout_be32(&bes->taskBar, sbes.taskBar);\r\nout_be32(&bes->currentPointer, sbes.currentPointer);\r\nout_be32(&bes->endPointer, sbes.endPointer);\r\nout_be32(&bes->variablePointer, sbes.variablePointer);\r\nout_8(&bes->IntVect1, sbes.IntVect1);\r\nout_8(&bes->IntVect2, sbes.IntVect2);\r\nout_be16(&bes->PtdCntrl, sbes.PtdCntrl);\r\nfor (i=0; i<32; i++)\r\nout_8(&bes->ipr[i], sbes.ipr[i]);\r\nout_be32(&bes->cReqSelect, sbes.cReqSelect);\r\nout_be32(&bes->task_size0, sbes.task_size0);\r\nout_be32(&bes->task_size1, sbes.task_size1);\r\nout_be32(&bes->MDEDebug, sbes.MDEDebug);\r\nout_be32(&bes->ADSDebug, sbes.ADSDebug);\r\nout_be32(&bes->Value1, sbes.Value1);\r\nout_be32(&bes->Value2, sbes.Value2);\r\nout_be32(&bes->Control, sbes.Control);\r\nout_be32(&bes->Status, sbes.Status);\r\nout_be32(&bes->PTDDebug, sbes.PTDDebug);\r\nfor (i=0; i<16; i++)\r\nout_be16(&bes->tcr[i], sbes.tcr[i]);\r\nout_be32(&bes->IntPend, sbes.IntPend);\r\nout_be32(&bes->IntMask, sbes.IntMask);\r\nout_be32(&pic->per_pri1, spic.per_pri1);\r\nout_be32(&pic->per_pri2, spic.per_pri2);\r\nout_be32(&pic->per_pri3, spic.per_pri3);\r\nout_be32(&pic->main_pri1, spic.main_pri1);\r\nout_be32(&pic->main_pri2, spic.main_pri2);\r\nout_be32(&pic->enc_status, spic.enc_status);\r\nout_be32(&pic->per_mask, spic.per_mask);\r\nout_be32(&pic->main_mask, spic.main_mask);\r\nout_be32(&pic->ctrl, spic.ctrl);\r\n}\r\nstatic int lite5200_pm_enter(suspend_state_t state)\r\n{\r\nif (state == PM_SUSPEND_STANDBY) {\r\nreturn mpc52xx_pm_enter(state);\r\n}\r\nlite5200_save_regs();\r\nenable_kernel_fp();\r\nlite5200_low_power(sram, mbar);\r\nlite5200_restore_regs();\r\niounmap(mbar);\r\nreturn 0;\r\n}\r\nstatic void lite5200_pm_finish(void)\r\n{\r\nif (lite5200_pm_target_state == PM_SUSPEND_STANDBY)\r\nmpc52xx_pm_finish();\r\n}\r\nstatic void lite5200_pm_end(void)\r\n{\r\nlite5200_pm_target_state = PM_SUSPEND_ON;\r\n}\r\nint __init lite5200_pm_init(void)\r\n{\r\nsuspend_set_ops(&lite5200_pm_ops);\r\nreturn 0;\r\n}
