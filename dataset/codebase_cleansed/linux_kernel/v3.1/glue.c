int register_acpi_bus_type(struct acpi_bus_type *type)\r\n{\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nif (type && type->bus && type->find_device) {\r\ndown_write(&bus_type_sem);\r\nlist_add_tail(&type->list, &bus_type_list);\r\nup_write(&bus_type_sem);\r\nprintk(KERN_INFO PREFIX "bus type %s registered\n",\r\ntype->bus->name);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint unregister_acpi_bus_type(struct acpi_bus_type *type)\r\n{\r\nif (acpi_disabled)\r\nreturn 0;\r\nif (type) {\r\ndown_write(&bus_type_sem);\r\nlist_del_init(&type->list);\r\nup_write(&bus_type_sem);\r\nprintk(KERN_INFO PREFIX "ACPI bus type %s unregistered\n",\r\ntype->bus->name);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic struct acpi_bus_type *acpi_get_bus_type(struct bus_type *type)\r\n{\r\nstruct acpi_bus_type *tmp, *ret = NULL;\r\ndown_read(&bus_type_sem);\r\nlist_for_each_entry(tmp, &bus_type_list, list) {\r\nif (tmp->bus == type) {\r\nret = tmp;\r\nbreak;\r\n}\r\n}\r\nup_read(&bus_type_sem);\r\nreturn ret;\r\n}\r\nstatic int acpi_find_bridge_device(struct device *dev, acpi_handle * handle)\r\n{\r\nstruct acpi_bus_type *tmp;\r\nint ret = -ENODEV;\r\ndown_read(&bus_type_sem);\r\nlist_for_each_entry(tmp, &bus_type_list, list) {\r\nif (tmp->find_bridge && !tmp->find_bridge(dev, handle)) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nup_read(&bus_type_sem);\r\nreturn ret;\r\n}\r\nstatic acpi_status\r\ndo_acpi_find_child(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nacpi_status status;\r\nstruct acpi_device_info *info;\r\nstruct acpi_find_child *find = context;\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (ACPI_SUCCESS(status)) {\r\nif ((info->address == find->address)\r\n&& (info->valid & ACPI_VALID_ADR))\r\nfind->handle = handle;\r\nkfree(info);\r\n}\r\nreturn AE_OK;\r\n}\r\nacpi_handle acpi_get_child(acpi_handle parent, u64 address)\r\n{\r\nstruct acpi_find_child find = { NULL, address };\r\nif (!parent)\r\nreturn NULL;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, parent,\r\n1, do_acpi_find_child, NULL, &find, NULL);\r\nreturn find.handle;\r\n}\r\nstatic void acpi_glue_data_handler(acpi_handle handle,\r\nvoid *context)\r\n{\r\n}\r\nstruct device *acpi_get_physical_device(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nstruct device *dev;\r\nstatus = acpi_get_data(handle, acpi_glue_data_handler, (void **)&dev);\r\nif (ACPI_SUCCESS(status))\r\nreturn get_device(dev);\r\nreturn NULL;\r\n}\r\nstatic int acpi_bind_one(struct device *dev, acpi_handle handle)\r\n{\r\nstruct acpi_device *acpi_dev;\r\nacpi_status status;\r\nif (dev->archdata.acpi_handle) {\r\ndev_warn(dev, "Drivers changed 'acpi_handle'\n");\r\nreturn -EINVAL;\r\n}\r\nget_device(dev);\r\nstatus = acpi_attach_data(handle, acpi_glue_data_handler, dev);\r\nif (ACPI_FAILURE(status)) {\r\nput_device(dev);\r\nreturn -EINVAL;\r\n}\r\ndev->archdata.acpi_handle = handle;\r\nstatus = acpi_bus_get_device(handle, &acpi_dev);\r\nif (!ACPI_FAILURE(status)) {\r\nint ret;\r\nret = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,\r\n"firmware_node");\r\nret = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,\r\n"physical_node");\r\nif (acpi_dev->wakeup.flags.valid)\r\ndevice_set_wakeup_capable(dev, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_unbind_one(struct device *dev)\r\n{\r\nif (!dev->archdata.acpi_handle)\r\nreturn 0;\r\nif (dev == acpi_get_physical_device(dev->archdata.acpi_handle)) {\r\nstruct acpi_device *acpi_dev;\r\nput_device(dev);\r\nif (!acpi_bus_get_device(dev->archdata.acpi_handle,\r\n&acpi_dev)) {\r\nsysfs_remove_link(&dev->kobj, "firmware_node");\r\nsysfs_remove_link(&acpi_dev->dev.kobj, "physical_node");\r\n}\r\nacpi_detach_data(dev->archdata.acpi_handle,\r\nacpi_glue_data_handler);\r\ndev->archdata.acpi_handle = NULL;\r\nput_device(dev);\r\n} else {\r\ndev_err(dev, "Oops, 'acpi_handle' corrupt\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_platform_notify(struct device *dev)\r\n{\r\nstruct acpi_bus_type *type;\r\nacpi_handle handle;\r\nint ret = -EINVAL;\r\nif (!dev->bus || !dev->parent) {\r\nret = acpi_find_bridge_device(dev, &handle);\r\ngoto end;\r\n}\r\ntype = acpi_get_bus_type(dev->bus);\r\nif (!type) {\r\nDBG("No ACPI bus support for %s\n", dev_name(dev));\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nif ((ret = type->find_device(dev, &handle)) != 0)\r\nDBG("Can't get handler for %s\n", dev_name(dev));\r\nend:\r\nif (!ret)\r\nacpi_bind_one(dev, handle);\r\n#if ACPI_GLUE_DEBUG\r\nif (!ret) {\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_get_name(dev->archdata.acpi_handle,\r\nACPI_FULL_PATHNAME, &buffer);\r\nDBG("Device %s -> %s\n", dev_name(dev), (char *)buffer.pointer);\r\nkfree(buffer.pointer);\r\n} else\r\nDBG("Device %s -> No ACPI support\n", dev_name(dev));\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int acpi_platform_notify_remove(struct device *dev)\r\n{\r\nacpi_unbind_one(dev);\r\nreturn 0;\r\n}\r\nint __init init_acpi_device_notify(void)\r\n{\r\nif (platform_notify || platform_notify_remove) {\r\nprintk(KERN_ERR PREFIX "Can't use platform_notify\n");\r\nreturn 0;\r\n}\r\nplatform_notify = acpi_platform_notify;\r\nplatform_notify_remove = acpi_platform_notify_remove;\r\nreturn 0;\r\n}
