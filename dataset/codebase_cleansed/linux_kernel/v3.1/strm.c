int strm_allocate_buffer(struct strm_res_object *strmres, u32 usize,\r\nu8 **ap_buffer, u32 num_bufs,\r\nstruct process_context *pr_ctxt)\r\n{\r\nint status = 0;\r\nu32 alloc_cnt = 0;\r\nu32 i;\r\nstruct strm_object *stream_obj = strmres->stream;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(ap_buffer != NULL);\r\nif (stream_obj) {\r\nif (usize == 0)\r\nstatus = -EINVAL;\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nif (status)\r\ngoto func_end;\r\nfor (i = 0; i < num_bufs; i++) {\r\nDBC_ASSERT(stream_obj->xlator != NULL);\r\n(void)cmm_xlator_alloc_buf(stream_obj->xlator, &ap_buffer[i],\r\nusize);\r\nif (ap_buffer[i] == NULL) {\r\nstatus = -ENOMEM;\r\nalloc_cnt = i;\r\nbreak;\r\n}\r\n}\r\nif (status)\r\nstrm_free_buffer(strmres, ap_buffer, alloc_cnt, pr_ctxt);\r\nif (status)\r\ngoto func_end;\r\ndrv_proc_update_strm_res(num_bufs, strmres);\r\nfunc_end:\r\nreturn status;\r\n}\r\nint strm_close(struct strm_res_object *strmres,\r\nstruct process_context *pr_ctxt)\r\n{\r\nstruct bridge_drv_interface *intf_fxns;\r\nstruct chnl_info chnl_info_obj;\r\nint status = 0;\r\nstruct strm_object *stream_obj = strmres->stream;\r\nDBC_REQUIRE(refs > 0);\r\nif (!stream_obj) {\r\nstatus = -EFAULT;\r\n} else {\r\nintf_fxns = stream_obj->strm_mgr_obj->intf_fxns;\r\nstatus =\r\n(*intf_fxns->chnl_get_info) (stream_obj->chnl_obj,\r\n&chnl_info_obj);\r\nDBC_ASSERT(!status);\r\nif (chnl_info_obj.cio_cs > 0 || chnl_info_obj.cio_reqs > 0)\r\nstatus = -EPIPE;\r\nelse\r\nstatus = delete_strm(stream_obj);\r\n}\r\nif (status)\r\ngoto func_end;\r\nidr_remove(pr_ctxt->stream_id, strmres->id);\r\nfunc_end:\r\nDBC_ENSURE(status == 0 || status == -EFAULT ||\r\nstatus == -EPIPE || status == -EPERM);\r\ndev_dbg(bridge, "%s: stream_obj: %p, status 0x%x\n", __func__,\r\nstream_obj, status);\r\nreturn status;\r\n}\r\nint strm_create(struct strm_mgr **strm_man,\r\nstruct dev_object *dev_obj)\r\n{\r\nstruct strm_mgr *strm_mgr_obj;\r\nint status = 0;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(strm_man != NULL);\r\nDBC_REQUIRE(dev_obj != NULL);\r\n*strm_man = NULL;\r\nstrm_mgr_obj = kzalloc(sizeof(struct strm_mgr), GFP_KERNEL);\r\nif (strm_mgr_obj == NULL)\r\nstatus = -ENOMEM;\r\nelse\r\nstrm_mgr_obj->dev_obj = dev_obj;\r\nif (!status) {\r\nstatus = dev_get_chnl_mgr(dev_obj, &(strm_mgr_obj->chnl_mgr));\r\nif (!status) {\r\n(void)dev_get_intf_fxns(dev_obj,\r\n&(strm_mgr_obj->intf_fxns));\r\nDBC_ASSERT(strm_mgr_obj->intf_fxns != NULL);\r\n}\r\n}\r\nif (!status)\r\n*strm_man = strm_mgr_obj;\r\nelse\r\nkfree(strm_mgr_obj);\r\nDBC_ENSURE((!status && *strm_man) || (status && *strm_man == NULL));\r\nreturn status;\r\n}\r\nvoid strm_delete(struct strm_mgr *strm_mgr_obj)\r\n{\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(strm_mgr_obj);\r\nkfree(strm_mgr_obj);\r\n}\r\nvoid strm_exit(void)\r\n{\r\nDBC_REQUIRE(refs > 0);\r\nrefs--;\r\nDBC_ENSURE(refs >= 0);\r\n}\r\nint strm_free_buffer(struct strm_res_object *strmres, u8 ** ap_buffer,\r\nu32 num_bufs, struct process_context *pr_ctxt)\r\n{\r\nint status = 0;\r\nu32 i = 0;\r\nstruct strm_object *stream_obj = strmres->stream;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(ap_buffer != NULL);\r\nif (!stream_obj)\r\nstatus = -EFAULT;\r\nif (!status) {\r\nfor (i = 0; i < num_bufs; i++) {\r\nDBC_ASSERT(stream_obj->xlator != NULL);\r\nstatus =\r\ncmm_xlator_free_buf(stream_obj->xlator,\r\nap_buffer[i]);\r\nif (status)\r\nbreak;\r\nap_buffer[i] = NULL;\r\n}\r\n}\r\ndrv_proc_update_strm_res(num_bufs - i, strmres);\r\nreturn status;\r\n}\r\nint strm_get_info(struct strm_object *stream_obj,\r\nstruct stream_info *stream_info,\r\nu32 stream_info_size)\r\n{\r\nstruct bridge_drv_interface *intf_fxns;\r\nstruct chnl_info chnl_info_obj;\r\nint status = 0;\r\nvoid *virt_base = NULL;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(stream_info != NULL);\r\nDBC_REQUIRE(stream_info_size >= sizeof(struct stream_info));\r\nif (!stream_obj) {\r\nstatus = -EFAULT;\r\n} else {\r\nif (stream_info_size < sizeof(struct stream_info)) {\r\nstatus = -EINVAL;\r\n}\r\n}\r\nif (status)\r\ngoto func_end;\r\nintf_fxns = stream_obj->strm_mgr_obj->intf_fxns;\r\nstatus =\r\n(*intf_fxns->chnl_get_info) (stream_obj->chnl_obj,\r\n&chnl_info_obj);\r\nif (status)\r\ngoto func_end;\r\nif (stream_obj->xlator) {\r\nDBC_ASSERT(stream_obj->segment_id > 0);\r\ncmm_xlator_info(stream_obj->xlator, (u8 **) &virt_base, 0,\r\nstream_obj->segment_id, false);\r\n}\r\nstream_info->segment_id = stream_obj->segment_id;\r\nstream_info->strm_mode = stream_obj->strm_mode;\r\nstream_info->virt_base = virt_base;\r\nstream_info->user_strm->number_bufs_allowed = stream_obj->num_bufs;\r\nstream_info->user_strm->number_bufs_in_stream = chnl_info_obj.cio_cs +\r\nchnl_info_obj.cio_reqs;\r\nstream_info->user_strm->number_bytes = chnl_info_obj.bytes_tx;\r\nstream_info->user_strm->sync_object_handle = chnl_info_obj.event_obj;\r\nif (chnl_info_obj.state & CHNL_STATEEOS) {\r\nstream_info->user_strm->ss_stream_state = STREAM_DONE;\r\n} else {\r\nif (chnl_info_obj.cio_cs > 0)\r\nstream_info->user_strm->ss_stream_state = STREAM_READY;\r\nelse if (chnl_info_obj.cio_reqs > 0)\r\nstream_info->user_strm->ss_stream_state =\r\nSTREAM_PENDING;\r\nelse\r\nstream_info->user_strm->ss_stream_state = STREAM_IDLE;\r\n}\r\nfunc_end:\r\nreturn status;\r\n}\r\nint strm_idle(struct strm_object *stream_obj, bool flush_data)\r\n{\r\nstruct bridge_drv_interface *intf_fxns;\r\nint status = 0;\r\nDBC_REQUIRE(refs > 0);\r\nif (!stream_obj) {\r\nstatus = -EFAULT;\r\n} else {\r\nintf_fxns = stream_obj->strm_mgr_obj->intf_fxns;\r\nstatus = (*intf_fxns->chnl_idle) (stream_obj->chnl_obj,\r\nstream_obj->timeout,\r\nflush_data);\r\n}\r\ndev_dbg(bridge, "%s: stream_obj: %p flush_data: 0x%x status: 0x%x\n",\r\n__func__, stream_obj, flush_data, status);\r\nreturn status;\r\n}\r\nbool strm_init(void)\r\n{\r\nbool ret = true;\r\nDBC_REQUIRE(refs >= 0);\r\nif (ret)\r\nrefs++;\r\nDBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));\r\nreturn ret;\r\n}\r\nint strm_issue(struct strm_object *stream_obj, u8 *pbuf, u32 ul_bytes,\r\nu32 ul_buf_size, u32 dw_arg)\r\n{\r\nstruct bridge_drv_interface *intf_fxns;\r\nint status = 0;\r\nvoid *tmp_buf = NULL;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(pbuf != NULL);\r\nif (!stream_obj) {\r\nstatus = -EFAULT;\r\n} else {\r\nintf_fxns = stream_obj->strm_mgr_obj->intf_fxns;\r\nif (stream_obj->segment_id != 0) {\r\ntmp_buf = cmm_xlator_translate(stream_obj->xlator,\r\n(void *)pbuf,\r\nCMM_VA2DSPPA);\r\nif (tmp_buf == NULL)\r\nstatus = -ESRCH;\r\n}\r\nif (!status) {\r\nstatus = (*intf_fxns->chnl_add_io_req)\r\n(stream_obj->chnl_obj, pbuf, ul_bytes, ul_buf_size,\r\n(u32) tmp_buf, dw_arg);\r\n}\r\nif (status == -EIO)\r\nstatus = -ENOSR;\r\n}\r\ndev_dbg(bridge, "%s: stream_obj: %p pbuf: %p ul_bytes: 0x%x dw_arg:"\r\n" 0x%x status: 0x%x\n", __func__, stream_obj, pbuf,\r\nul_bytes, dw_arg, status);\r\nreturn status;\r\n}\r\nint strm_open(struct node_object *hnode, u32 dir, u32 index,\r\nstruct strm_attr *pattr,\r\nstruct strm_res_object **strmres,\r\nstruct process_context *pr_ctxt)\r\n{\r\nstruct strm_mgr *strm_mgr_obj;\r\nstruct bridge_drv_interface *intf_fxns;\r\nu32 ul_chnl_id;\r\nstruct strm_object *strm_obj = NULL;\r\ns8 chnl_mode;\r\nstruct chnl_attr chnl_attr_obj;\r\nint status = 0;\r\nstruct cmm_object *hcmm_mgr = NULL;\r\nvoid *stream_res;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(strmres != NULL);\r\nDBC_REQUIRE(pattr != NULL);\r\n*strmres = NULL;\r\nif (dir != DSP_TONODE && dir != DSP_FROMNODE) {\r\nstatus = -EPERM;\r\n} else {\r\nstatus = node_get_channel_id(hnode, dir, index, &ul_chnl_id);\r\n}\r\nif (!status)\r\nstatus = node_get_strm_mgr(hnode, &strm_mgr_obj);\r\nif (!status) {\r\nstrm_obj = kzalloc(sizeof(struct strm_object), GFP_KERNEL);\r\nif (strm_obj == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nstrm_obj->strm_mgr_obj = strm_mgr_obj;\r\nstrm_obj->dir = dir;\r\nstrm_obj->strm_state = STREAM_IDLE;\r\nstrm_obj->user_event = pattr->user_event;\r\nif (pattr->stream_attr_in != NULL) {\r\nstrm_obj->timeout =\r\npattr->stream_attr_in->timeout;\r\nstrm_obj->num_bufs =\r\npattr->stream_attr_in->num_bufs;\r\nstrm_obj->strm_mode =\r\npattr->stream_attr_in->strm_mode;\r\nstrm_obj->segment_id =\r\npattr->stream_attr_in->segment_id;\r\nstrm_obj->buf_alignment =\r\npattr->stream_attr_in->buf_alignment;\r\nstrm_obj->dma_chnl_id =\r\npattr->stream_attr_in->dma_chnl_id;\r\nstrm_obj->dma_priority =\r\npattr->stream_attr_in->dma_priority;\r\nchnl_attr_obj.uio_reqs =\r\npattr->stream_attr_in->num_bufs;\r\n} else {\r\nstrm_obj->timeout = DEFAULTTIMEOUT;\r\nstrm_obj->num_bufs = DEFAULTNUMBUFS;\r\nstrm_obj->strm_mode = STRMMODE_PROCCOPY;\r\nstrm_obj->segment_id = 0;\r\nstrm_obj->buf_alignment = 0;\r\nstrm_obj->dma_chnl_id = 0;\r\nstrm_obj->dma_priority = 0;\r\nchnl_attr_obj.uio_reqs = DEFAULTNUMBUFS;\r\n}\r\nchnl_attr_obj.reserved1 = NULL;\r\nchnl_attr_obj.reserved2 = strm_obj->timeout;\r\nchnl_attr_obj.event_obj = NULL;\r\nif (pattr->user_event != NULL)\r\nchnl_attr_obj.event_obj = pattr->user_event;\r\n}\r\n}\r\nif (status)\r\ngoto func_cont;\r\nif ((pattr->virt_base == NULL) || !(pattr->virt_size > 0))\r\ngoto func_cont;\r\nDBC_ASSERT(strm_obj->strm_mode != STRMMODE_LDMA);\r\nstatus = dev_get_cmm_mgr(strm_mgr_obj->dev_obj, &hcmm_mgr);\r\nif (!status) {\r\nstatus = cmm_xlator_create(&strm_obj->xlator, hcmm_mgr, NULL);\r\nif (!status) {\r\nDBC_ASSERT(strm_obj->segment_id > 0);\r\nstatus = cmm_xlator_info(strm_obj->xlator,\r\n(u8 **) &pattr->virt_base,\r\npattr->virt_size,\r\nstrm_obj->segment_id, true);\r\n}\r\n}\r\nfunc_cont:\r\nif (!status) {\r\nchnl_mode = (dir == DSP_TONODE) ?\r\nCHNL_MODETODSP : CHNL_MODEFROMDSP;\r\nintf_fxns = strm_mgr_obj->intf_fxns;\r\nstatus = (*intf_fxns->chnl_open) (&(strm_obj->chnl_obj),\r\nstrm_mgr_obj->chnl_mgr,\r\nchnl_mode, ul_chnl_id,\r\n&chnl_attr_obj);\r\nif (status) {\r\nif (status != -ENOMEM && status !=\r\n-EINVAL && status != -EPERM) {\r\nDBC_ASSERT(status == -ENOSR ||\r\nstatus == -ECHRNG ||\r\nstatus == -EALREADY ||\r\nstatus == -EIO);\r\nstatus = -EPERM;\r\n}\r\n}\r\n}\r\nif (!status) {\r\nstatus = drv_proc_insert_strm_res_element(strm_obj,\r\n&stream_res, pr_ctxt);\r\nif (status)\r\ndelete_strm(strm_obj);\r\nelse\r\n*strmres = (struct strm_res_object *)stream_res;\r\n} else {\r\n(void)delete_strm(strm_obj);\r\n}\r\nDBC_ENSURE((!status && strm_obj) ||\r\n(*strmres == NULL && (status == -EFAULT ||\r\nstatus == -EPERM\r\n|| status == -EINVAL)));\r\ndev_dbg(bridge, "%s: hnode: %p dir: 0x%x index: 0x%x pattr: %p "\r\n"strmres: %p status: 0x%x\n", __func__,\r\nhnode, dir, index, pattr, strmres, status);\r\nreturn status;\r\n}\r\nint strm_reclaim(struct strm_object *stream_obj, u8 ** buf_ptr,\r\nu32 *nbytes, u32 *buff_size, u32 *pdw_arg)\r\n{\r\nstruct bridge_drv_interface *intf_fxns;\r\nstruct chnl_ioc chnl_ioc_obj;\r\nint status = 0;\r\nvoid *tmp_buf = NULL;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(buf_ptr != NULL);\r\nDBC_REQUIRE(nbytes != NULL);\r\nDBC_REQUIRE(pdw_arg != NULL);\r\nif (!stream_obj) {\r\nstatus = -EFAULT;\r\ngoto func_end;\r\n}\r\nintf_fxns = stream_obj->strm_mgr_obj->intf_fxns;\r\nstatus =\r\n(*intf_fxns->chnl_get_ioc) (stream_obj->chnl_obj,\r\nstream_obj->timeout,\r\n&chnl_ioc_obj);\r\nif (!status) {\r\n*nbytes = chnl_ioc_obj.byte_size;\r\nif (buff_size)\r\n*buff_size = chnl_ioc_obj.buf_size;\r\n*pdw_arg = chnl_ioc_obj.arg;\r\nif (!CHNL_IS_IO_COMPLETE(chnl_ioc_obj)) {\r\nif (CHNL_IS_TIMED_OUT(chnl_ioc_obj)) {\r\nstatus = -ETIME;\r\n} else {\r\nif (!CHNL_IS_IO_CANCELLED(chnl_ioc_obj))\r\nstatus = -EPERM;\r\n}\r\n}\r\nif (!status\r\n&& (!CHNL_IS_IO_CANCELLED(chnl_ioc_obj))\r\n&& (stream_obj->strm_mode == STRMMODE_ZEROCOPY)) {\r\ntmp_buf = cmm_xlator_translate(stream_obj->xlator,\r\nchnl_ioc_obj.buf,\r\nCMM_DSPPA2PA);\r\nif (tmp_buf != NULL) {\r\ntmp_buf = cmm_xlator_translate(stream_obj->\r\nxlator,\r\ntmp_buf,\r\nCMM_PA2VA);\r\n}\r\nif (tmp_buf == NULL)\r\nstatus = -ESRCH;\r\nchnl_ioc_obj.buf = tmp_buf;\r\n}\r\n*buf_ptr = chnl_ioc_obj.buf;\r\n}\r\nfunc_end:\r\nDBC_ENSURE(!status || status == -EFAULT ||\r\nstatus == -ETIME || status == -ESRCH ||\r\nstatus == -EPERM);\r\ndev_dbg(bridge, "%s: stream_obj: %p buf_ptr: %p nbytes: %p "\r\n"pdw_arg: %p status 0x%x\n", __func__, stream_obj,\r\nbuf_ptr, nbytes, pdw_arg, status);\r\nreturn status;\r\n}\r\nint strm_register_notify(struct strm_object *stream_obj, u32 event_mask,\r\nu32 notify_type, struct dsp_notification\r\n* hnotification)\r\n{\r\nstruct bridge_drv_interface *intf_fxns;\r\nint status = 0;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(hnotification != NULL);\r\nif (!stream_obj) {\r\nstatus = -EFAULT;\r\n} else if ((event_mask & ~((DSP_STREAMIOCOMPLETION) |\r\nDSP_STREAMDONE)) != 0) {\r\nstatus = -EINVAL;\r\n} else {\r\nif (notify_type != DSP_SIGNALEVENT)\r\nstatus = -ENOSYS;\r\n}\r\nif (!status) {\r\nintf_fxns = stream_obj->strm_mgr_obj->intf_fxns;\r\nstatus =\r\n(*intf_fxns->chnl_register_notify) (stream_obj->\r\nchnl_obj,\r\nevent_mask,\r\nnotify_type,\r\nhnotification);\r\n}\r\nDBC_ENSURE(!status || status == -EFAULT ||\r\nstatus == -ETIME || status == -ESRCH ||\r\nstatus == -ENOSYS || status == -EPERM);\r\nreturn status;\r\n}\r\nint strm_select(struct strm_object **strm_tab, u32 strms,\r\nu32 *pmask, u32 utimeout)\r\n{\r\nu32 index;\r\nstruct chnl_info chnl_info_obj;\r\nstruct bridge_drv_interface *intf_fxns;\r\nstruct sync_object **sync_events = NULL;\r\nu32 i;\r\nint status = 0;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(strm_tab != NULL);\r\nDBC_REQUIRE(pmask != NULL);\r\nDBC_REQUIRE(strms > 0);\r\n*pmask = 0;\r\nfor (i = 0; i < strms; i++) {\r\nif (!strm_tab[i]) {\r\nstatus = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nif (status)\r\ngoto func_end;\r\nfor (i = 0; i < strms; i++) {\r\nintf_fxns = strm_tab[i]->strm_mgr_obj->intf_fxns;\r\nstatus = (*intf_fxns->chnl_get_info) (strm_tab[i]->chnl_obj,\r\n&chnl_info_obj);\r\nif (status) {\r\nbreak;\r\n} else {\r\nif (chnl_info_obj.cio_cs > 0)\r\n*pmask |= (1 << i);\r\n}\r\n}\r\nif (!status && utimeout > 0 && *pmask == 0) {\r\nsync_events = kmalloc(strms * sizeof(struct sync_object *),\r\nGFP_KERNEL);\r\nif (sync_events == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nfor (i = 0; i < strms; i++) {\r\nintf_fxns =\r\nstrm_tab[i]->strm_mgr_obj->intf_fxns;\r\nstatus = (*intf_fxns->chnl_get_info)\r\n(strm_tab[i]->chnl_obj, &chnl_info_obj);\r\nif (status)\r\nbreak;\r\nelse\r\nsync_events[i] =\r\nchnl_info_obj.sync_event;\r\n}\r\n}\r\nif (!status) {\r\nstatus =\r\nsync_wait_on_multiple_events(sync_events, strms,\r\nutimeout, &index);\r\nif (!status) {\r\nsync_set_event(sync_events[index]);\r\n*pmask = 1 << index;\r\n}\r\n}\r\n}\r\nfunc_end:\r\nkfree(sync_events);\r\nDBC_ENSURE((!status && (*pmask != 0 || utimeout == 0)) ||\r\n(status && *pmask == 0));\r\nreturn status;\r\n}\r\nstatic int delete_strm(struct strm_object *stream_obj)\r\n{\r\nstruct bridge_drv_interface *intf_fxns;\r\nint status = 0;\r\nif (stream_obj) {\r\nif (stream_obj->chnl_obj) {\r\nintf_fxns = stream_obj->strm_mgr_obj->intf_fxns;\r\nstatus = (*intf_fxns->chnl_close)\r\n(stream_obj->chnl_obj);\r\n}\r\nkfree(stream_obj->xlator);\r\nkfree(stream_obj);\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}
