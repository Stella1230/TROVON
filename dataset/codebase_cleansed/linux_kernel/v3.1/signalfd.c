static int signalfd_release(struct inode *inode, struct file *file)\r\n{\r\nkfree(file->private_data);\r\nreturn 0;\r\n}\r\nstatic unsigned int signalfd_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct signalfd_ctx *ctx = file->private_data;\r\nunsigned int events = 0;\r\npoll_wait(file, &current->sighand->signalfd_wqh, wait);\r\nspin_lock_irq(&current->sighand->siglock);\r\nif (next_signal(&current->pending, &ctx->sigmask) ||\r\nnext_signal(&current->signal->shared_pending,\r\n&ctx->sigmask))\r\nevents |= POLLIN;\r\nspin_unlock_irq(&current->sighand->siglock);\r\nreturn events;\r\n}\r\nstatic int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\r\nsiginfo_t const *kinfo)\r\n{\r\nlong err;\r\nBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\r\nerr = __clear_user(uinfo, sizeof(*uinfo));\r\nerr |= __put_user(kinfo->si_signo, &uinfo->ssi_signo);\r\nerr |= __put_user(kinfo->si_errno, &uinfo->ssi_errno);\r\nerr |= __put_user((short) kinfo->si_code, &uinfo->ssi_code);\r\nswitch (kinfo->si_code & __SI_MASK) {\r\ncase __SI_KILL:\r\nerr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\r\nerr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\r\nbreak;\r\ncase __SI_TIMER:\r\nerr |= __put_user(kinfo->si_tid, &uinfo->ssi_tid);\r\nerr |= __put_user(kinfo->si_overrun, &uinfo->ssi_overrun);\r\nerr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\r\nerr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\r\nbreak;\r\ncase __SI_POLL:\r\nerr |= __put_user(kinfo->si_band, &uinfo->ssi_band);\r\nerr |= __put_user(kinfo->si_fd, &uinfo->ssi_fd);\r\nbreak;\r\ncase __SI_FAULT:\r\nerr |= __put_user((long) kinfo->si_addr, &uinfo->ssi_addr);\r\n#ifdef __ARCH_SI_TRAPNO\r\nerr |= __put_user(kinfo->si_trapno, &uinfo->ssi_trapno);\r\n#endif\r\n#ifdef BUS_MCEERR_AO\r\nif (kinfo->si_code == BUS_MCEERR_AR ||\r\nkinfo->si_code == BUS_MCEERR_AO)\r\nerr |= __put_user((short) kinfo->si_addr_lsb,\r\n&uinfo->ssi_addr_lsb);\r\n#endif\r\nbreak;\r\ncase __SI_CHLD:\r\nerr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\r\nerr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\r\nerr |= __put_user(kinfo->si_status, &uinfo->ssi_status);\r\nerr |= __put_user(kinfo->si_utime, &uinfo->ssi_utime);\r\nerr |= __put_user(kinfo->si_stime, &uinfo->ssi_stime);\r\nbreak;\r\ncase __SI_RT:\r\ncase __SI_MESGQ:\r\nerr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\r\nerr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\r\nerr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\r\nerr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\r\nbreak;\r\ndefault:\r\nerr |= __put_user(kinfo->si_pid, &uinfo->ssi_pid);\r\nerr |= __put_user(kinfo->si_uid, &uinfo->ssi_uid);\r\nerr |= __put_user((long) kinfo->si_ptr, &uinfo->ssi_ptr);\r\nerr |= __put_user(kinfo->si_int, &uinfo->ssi_int);\r\nbreak;\r\n}\r\nreturn err ? -EFAULT: sizeof(*uinfo);\r\n}\r\nstatic ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, siginfo_t *info,\r\nint nonblock)\r\n{\r\nssize_t ret;\r\nDECLARE_WAITQUEUE(wait, current);\r\nspin_lock_irq(&current->sighand->siglock);\r\nret = dequeue_signal(current, &ctx->sigmask, info);\r\nswitch (ret) {\r\ncase 0:\r\nif (!nonblock)\r\nbreak;\r\nret = -EAGAIN;\r\ndefault:\r\nspin_unlock_irq(&current->sighand->siglock);\r\nreturn ret;\r\n}\r\nadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nret = dequeue_signal(current, &ctx->sigmask, info);\r\nif (ret != 0)\r\nbreak;\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_unlock_irq(&current->sighand->siglock);\r\nschedule();\r\nspin_lock_irq(&current->sighand->siglock);\r\n}\r\nspin_unlock_irq(&current->sighand->siglock);\r\nremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\r\n__set_current_state(TASK_RUNNING);\r\nreturn ret;\r\n}\r\nstatic ssize_t signalfd_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct signalfd_ctx *ctx = file->private_data;\r\nstruct signalfd_siginfo __user *siginfo;\r\nint nonblock = file->f_flags & O_NONBLOCK;\r\nssize_t ret, total = 0;\r\nsiginfo_t info;\r\ncount /= sizeof(struct signalfd_siginfo);\r\nif (!count)\r\nreturn -EINVAL;\r\nsiginfo = (struct signalfd_siginfo __user *) buf;\r\ndo {\r\nret = signalfd_dequeue(ctx, &info, nonblock);\r\nif (unlikely(ret <= 0))\r\nbreak;\r\nret = signalfd_copyinfo(siginfo, &info);\r\nif (ret < 0)\r\nbreak;\r\nsiginfo++;\r\ntotal += ret;\r\nnonblock = 1;\r\n} while (--count);\r\nreturn total ? total: ret;\r\n}
