static struct per_pid *find_create_pid(int pid)\r\n{\r\nstruct per_pid *cursor = all_data;\r\nwhile (cursor) {\r\nif (cursor->pid == pid)\r\nreturn cursor;\r\ncursor = cursor->next;\r\n}\r\ncursor = malloc(sizeof(struct per_pid));\r\nassert(cursor != NULL);\r\nmemset(cursor, 0, sizeof(struct per_pid));\r\ncursor->pid = pid;\r\ncursor->next = all_data;\r\nall_data = cursor;\r\nreturn cursor;\r\n}\r\nstatic void pid_set_comm(int pid, char *comm)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\np = find_create_pid(pid);\r\nc = p->all;\r\nwhile (c) {\r\nif (c->comm && strcmp(c->comm, comm) == 0) {\r\np->current = c;\r\nreturn;\r\n}\r\nif (!c->comm) {\r\nc->comm = strdup(comm);\r\np->current = c;\r\nreturn;\r\n}\r\nc = c->next;\r\n}\r\nc = malloc(sizeof(struct per_pidcomm));\r\nassert(c != NULL);\r\nmemset(c, 0, sizeof(struct per_pidcomm));\r\nc->comm = strdup(comm);\r\np->current = c;\r\nc->next = p->all;\r\np->all = c;\r\n}\r\nstatic void pid_fork(int pid, int ppid, u64 timestamp)\r\n{\r\nstruct per_pid *p, *pp;\r\np = find_create_pid(pid);\r\npp = find_create_pid(ppid);\r\np->ppid = ppid;\r\nif (pp->current && pp->current->comm && !p->current)\r\npid_set_comm(pid, pp->current->comm);\r\np->start_time = timestamp;\r\nif (p->current) {\r\np->current->start_time = timestamp;\r\np->current->state_since = timestamp;\r\n}\r\n}\r\nstatic void pid_exit(int pid, u64 timestamp)\r\n{\r\nstruct per_pid *p;\r\np = find_create_pid(pid);\r\np->end_time = timestamp;\r\nif (p->current)\r\np->current->end_time = timestamp;\r\n}\r\nstatic void\r\npid_put_sample(int pid, int type, unsigned int cpu, u64 start, u64 end)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nstruct cpu_sample *sample;\r\np = find_create_pid(pid);\r\nc = p->current;\r\nif (!c) {\r\nc = malloc(sizeof(struct per_pidcomm));\r\nassert(c != NULL);\r\nmemset(c, 0, sizeof(struct per_pidcomm));\r\np->current = c;\r\nc->next = p->all;\r\np->all = c;\r\n}\r\nsample = malloc(sizeof(struct cpu_sample));\r\nassert(sample != NULL);\r\nmemset(sample, 0, sizeof(struct cpu_sample));\r\nsample->start_time = start;\r\nsample->end_time = end;\r\nsample->type = type;\r\nsample->next = c->samples;\r\nsample->cpu = cpu;\r\nc->samples = sample;\r\nif (sample->type == TYPE_RUNNING && end > start && start > 0) {\r\nc->total_time += (end-start);\r\np->total_time += (end-start);\r\n}\r\nif (c->start_time == 0 || c->start_time > start)\r\nc->start_time = start;\r\nif (p->start_time == 0 || p->start_time > start)\r\np->start_time = start;\r\n}\r\nstatic int process_comm_event(union perf_event *event,\r\nstruct perf_sample *sample __used,\r\nstruct perf_session *session __used)\r\n{\r\npid_set_comm(event->comm.tid, event->comm.comm);\r\nreturn 0;\r\n}\r\nstatic int process_fork_event(union perf_event *event,\r\nstruct perf_sample *sample __used,\r\nstruct perf_session *session __used)\r\n{\r\npid_fork(event->fork.pid, event->fork.ppid, event->fork.time);\r\nreturn 0;\r\n}\r\nstatic int process_exit_event(union perf_event *event,\r\nstruct perf_sample *sample __used,\r\nstruct perf_session *session __used)\r\n{\r\npid_exit(event->fork.pid, event->fork.time);\r\nreturn 0;\r\n}\r\nstatic void c_state_start(int cpu, u64 timestamp, int state)\r\n{\r\ncpus_cstate_start_times[cpu] = timestamp;\r\ncpus_cstate_state[cpu] = state;\r\n}\r\nstatic void c_state_end(int cpu, u64 timestamp)\r\n{\r\nstruct power_event *pwr;\r\npwr = malloc(sizeof(struct power_event));\r\nif (!pwr)\r\nreturn;\r\nmemset(pwr, 0, sizeof(struct power_event));\r\npwr->state = cpus_cstate_state[cpu];\r\npwr->start_time = cpus_cstate_start_times[cpu];\r\npwr->end_time = timestamp;\r\npwr->cpu = cpu;\r\npwr->type = CSTATE;\r\npwr->next = power_events;\r\npower_events = pwr;\r\n}\r\nstatic void p_state_change(int cpu, u64 timestamp, u64 new_freq)\r\n{\r\nstruct power_event *pwr;\r\npwr = malloc(sizeof(struct power_event));\r\nif (new_freq > 8000000)\r\nreturn;\r\nif (!pwr)\r\nreturn;\r\nmemset(pwr, 0, sizeof(struct power_event));\r\npwr->state = cpus_pstate_state[cpu];\r\npwr->start_time = cpus_pstate_start_times[cpu];\r\npwr->end_time = timestamp;\r\npwr->cpu = cpu;\r\npwr->type = PSTATE;\r\npwr->next = power_events;\r\nif (!pwr->start_time)\r\npwr->start_time = first_time;\r\npower_events = pwr;\r\ncpus_pstate_state[cpu] = new_freq;\r\ncpus_pstate_start_times[cpu] = timestamp;\r\nif ((u64)new_freq > max_freq)\r\nmax_freq = new_freq;\r\nif (new_freq < min_freq || min_freq == 0)\r\nmin_freq = new_freq;\r\nif (new_freq == max_freq - 1000)\r\nturbo_frequency = max_freq;\r\n}\r\nstatic void\r\nsched_wakeup(int cpu, u64 timestamp, int pid, struct trace_entry *te)\r\n{\r\nstruct wake_event *we;\r\nstruct per_pid *p;\r\nstruct wakeup_entry *wake = (void *)te;\r\nwe = malloc(sizeof(struct wake_event));\r\nif (!we)\r\nreturn;\r\nmemset(we, 0, sizeof(struct wake_event));\r\nwe->time = timestamp;\r\nwe->waker = pid;\r\nif ((te->flags & TRACE_FLAG_HARDIRQ) || (te->flags & TRACE_FLAG_SOFTIRQ))\r\nwe->waker = -1;\r\nwe->wakee = wake->pid;\r\nwe->next = wake_events;\r\nwake_events = we;\r\np = find_create_pid(we->wakee);\r\nif (p && p->current && p->current->state == TYPE_NONE) {\r\np->current->state_since = timestamp;\r\np->current->state = TYPE_WAITING;\r\n}\r\nif (p && p->current && p->current->state == TYPE_BLOCKED) {\r\npid_put_sample(p->pid, p->current->state, cpu, p->current->state_since, timestamp);\r\np->current->state_since = timestamp;\r\np->current->state = TYPE_WAITING;\r\n}\r\n}\r\nstatic void sched_switch(int cpu, u64 timestamp, struct trace_entry *te)\r\n{\r\nstruct per_pid *p = NULL, *prev_p;\r\nstruct sched_switch *sw = (void *)te;\r\nprev_p = find_create_pid(sw->prev_pid);\r\np = find_create_pid(sw->next_pid);\r\nif (prev_p->current && prev_p->current->state != TYPE_NONE)\r\npid_put_sample(sw->prev_pid, TYPE_RUNNING, cpu, prev_p->current->state_since, timestamp);\r\nif (p && p->current) {\r\nif (p->current->state != TYPE_NONE)\r\npid_put_sample(sw->next_pid, p->current->state, cpu, p->current->state_since, timestamp);\r\np->current->state_since = timestamp;\r\np->current->state = TYPE_RUNNING;\r\n}\r\nif (prev_p->current) {\r\nprev_p->current->state = TYPE_NONE;\r\nprev_p->current->state_since = timestamp;\r\nif (sw->prev_state & 2)\r\nprev_p->current->state = TYPE_BLOCKED;\r\nif (sw->prev_state == 0)\r\nprev_p->current->state = TYPE_WAITING;\r\n}\r\n}\r\nstatic int process_sample_event(union perf_event *event __used,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __used,\r\nstruct perf_session *session)\r\n{\r\nstruct trace_entry *te;\r\nif (session->sample_type & PERF_SAMPLE_TIME) {\r\nif (!first_time || first_time > sample->time)\r\nfirst_time = sample->time;\r\nif (last_time < sample->time)\r\nlast_time = sample->time;\r\n}\r\nte = (void *)sample->raw_data;\r\nif (session->sample_type & PERF_SAMPLE_RAW && sample->raw_size > 0) {\r\nchar *event_str;\r\n#ifdef SUPPORT_OLD_POWER_EVENTS\r\nstruct power_entry_old *peo;\r\npeo = (void *)te;\r\n#endif\r\nevent_str = perf_header__find_event(te->type);\r\nif (!event_str)\r\nreturn 0;\r\nif (sample->cpu > numcpus)\r\nnumcpus = sample->cpu;\r\nif (strcmp(event_str, "power:cpu_idle") == 0) {\r\nstruct power_processor_entry *ppe = (void *)te;\r\nif (ppe->state == (u32)PWR_EVENT_EXIT)\r\nc_state_end(ppe->cpu_id, sample->time);\r\nelse\r\nc_state_start(ppe->cpu_id, sample->time,\r\nppe->state);\r\n}\r\nelse if (strcmp(event_str, "power:cpu_frequency") == 0) {\r\nstruct power_processor_entry *ppe = (void *)te;\r\np_state_change(ppe->cpu_id, sample->time, ppe->state);\r\n}\r\nelse if (strcmp(event_str, "sched:sched_wakeup") == 0)\r\nsched_wakeup(sample->cpu, sample->time, sample->pid, te);\r\nelse if (strcmp(event_str, "sched:sched_switch") == 0)\r\nsched_switch(sample->cpu, sample->time, te);\r\n#ifdef SUPPORT_OLD_POWER_EVENTS\r\nif (use_old_power_events) {\r\nif (strcmp(event_str, "power:power_start") == 0)\r\nc_state_start(peo->cpu_id, sample->time,\r\npeo->value);\r\nelse if (strcmp(event_str, "power:power_end") == 0)\r\nc_state_end(sample->cpu, sample->time);\r\nelse if (strcmp(event_str,\r\n"power:power_frequency") == 0)\r\np_state_change(peo->cpu_id, sample->time,\r\npeo->value);\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void end_sample_processing(void)\r\n{\r\nu64 cpu;\r\nstruct power_event *pwr;\r\nfor (cpu = 0; cpu <= numcpus; cpu++) {\r\npwr = malloc(sizeof(struct power_event));\r\nif (!pwr)\r\nreturn;\r\nmemset(pwr, 0, sizeof(struct power_event));\r\n#if 0\r\npwr->state = cpus_cstate_state[cpu];\r\npwr->start_time = cpus_cstate_start_times[cpu];\r\npwr->end_time = last_time;\r\npwr->cpu = cpu;\r\npwr->type = CSTATE;\r\npwr->next = power_events;\r\npower_events = pwr;\r\n#endif\r\npwr = malloc(sizeof(struct power_event));\r\nif (!pwr)\r\nreturn;\r\nmemset(pwr, 0, sizeof(struct power_event));\r\npwr->state = cpus_pstate_state[cpu];\r\npwr->start_time = cpus_pstate_start_times[cpu];\r\npwr->end_time = last_time;\r\npwr->cpu = cpu;\r\npwr->type = PSTATE;\r\npwr->next = power_events;\r\nif (!pwr->start_time)\r\npwr->start_time = first_time;\r\nif (!pwr->state)\r\npwr->state = min_freq;\r\npower_events = pwr;\r\n}\r\n}\r\nstatic void sort_pids(void)\r\n{\r\nstruct per_pid *new_list, *p, *cursor, *prev;\r\nnew_list = NULL;\r\nwhile (all_data) {\r\np = all_data;\r\nall_data = p->next;\r\np->next = NULL;\r\nif (new_list == NULL) {\r\nnew_list = p;\r\np->next = NULL;\r\ncontinue;\r\n}\r\nprev = NULL;\r\ncursor = new_list;\r\nwhile (cursor) {\r\nif (cursor->ppid > p->ppid ||\r\n(cursor->ppid == p->ppid && cursor->pid > p->pid)) {\r\nif (prev) {\r\np->next = prev->next;\r\nprev->next = p;\r\ncursor = NULL;\r\ncontinue;\r\n} else {\r\np->next = new_list;\r\nnew_list = p;\r\ncursor = NULL;\r\ncontinue;\r\n}\r\n}\r\nprev = cursor;\r\ncursor = cursor->next;\r\nif (!cursor)\r\nprev->next = p;\r\n}\r\n}\r\nall_data = new_list;\r\n}\r\nstatic void draw_c_p_states(void)\r\n{\r\nstruct power_event *pwr;\r\npwr = power_events;\r\nwhile (pwr) {\r\nif (pwr->type == CSTATE)\r\nsvg_cstate(pwr->cpu, pwr->start_time, pwr->end_time, pwr->state);\r\npwr = pwr->next;\r\n}\r\npwr = power_events;\r\nwhile (pwr) {\r\nif (pwr->type == PSTATE) {\r\nif (!pwr->state)\r\npwr->state = min_freq;\r\nsvg_pstate(pwr->cpu, pwr->start_time, pwr->end_time, pwr->state);\r\n}\r\npwr = pwr->next;\r\n}\r\n}\r\nstatic void draw_wakeups(void)\r\n{\r\nstruct wake_event *we;\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nwe = wake_events;\r\nwhile (we) {\r\nint from = 0, to = 0;\r\nchar *task_from = NULL, *task_to = NULL;\r\np = all_data;\r\nwhile (p) {\r\nif (p->pid == we->waker || p->pid == we->wakee) {\r\nc = p->all;\r\nwhile (c) {\r\nif (c->Y && c->start_time <= we->time && c->end_time >= we->time) {\r\nif (p->pid == we->waker && !from) {\r\nfrom = c->Y;\r\ntask_from = strdup(c->comm);\r\n}\r\nif (p->pid == we->wakee && !to) {\r\nto = c->Y;\r\ntask_to = strdup(c->comm);\r\n}\r\n}\r\nc = c->next;\r\n}\r\nc = p->all;\r\nwhile (c) {\r\nif (p->pid == we->waker && !from) {\r\nfrom = c->Y;\r\ntask_from = strdup(c->comm);\r\n}\r\nif (p->pid == we->wakee && !to) {\r\nto = c->Y;\r\ntask_to = strdup(c->comm);\r\n}\r\nc = c->next;\r\n}\r\n}\r\np = p->next;\r\n}\r\nif (!task_from) {\r\ntask_from = malloc(40);\r\nsprintf(task_from, "[%i]", we->waker);\r\n}\r\nif (!task_to) {\r\ntask_to = malloc(40);\r\nsprintf(task_to, "[%i]", we->wakee);\r\n}\r\nif (we->waker == -1)\r\nsvg_interrupt(we->time, to);\r\nelse if (from && to && abs(from - to) == 1)\r\nsvg_wakeline(we->time, from, to);\r\nelse\r\nsvg_partial_wakeline(we->time, from, task_from, to, task_to);\r\nwe = we->next;\r\nfree(task_from);\r\nfree(task_to);\r\n}\r\n}\r\nstatic void draw_cpu_usage(void)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nstruct cpu_sample *sample;\r\np = all_data;\r\nwhile (p) {\r\nc = p->all;\r\nwhile (c) {\r\nsample = c->samples;\r\nwhile (sample) {\r\nif (sample->type == TYPE_RUNNING)\r\nsvg_process(sample->cpu, sample->start_time, sample->end_time, "sample", c->comm);\r\nsample = sample->next;\r\n}\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\n}\r\nstatic void draw_process_bars(void)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nstruct cpu_sample *sample;\r\nint Y = 0;\r\nY = 2 * numcpus + 2;\r\np = all_data;\r\nwhile (p) {\r\nc = p->all;\r\nwhile (c) {\r\nif (!c->display) {\r\nc->Y = 0;\r\nc = c->next;\r\ncontinue;\r\n}\r\nsvg_box(Y, c->start_time, c->end_time, "process");\r\nsample = c->samples;\r\nwhile (sample) {\r\nif (sample->type == TYPE_RUNNING)\r\nsvg_sample(Y, sample->cpu, sample->start_time, sample->end_time);\r\nif (sample->type == TYPE_BLOCKED)\r\nsvg_box(Y, sample->start_time, sample->end_time, "blocked");\r\nif (sample->type == TYPE_WAITING)\r\nsvg_waiting(Y, sample->start_time, sample->end_time);\r\nsample = sample->next;\r\n}\r\nif (c->comm) {\r\nchar comm[256];\r\nif (c->total_time > 5000000000)\r\nsprintf(comm, "%s:%i (%2.2fs)", c->comm, p->pid, c->total_time / 1000000000.0);\r\nelse\r\nsprintf(comm, "%s:%i (%3.1fms)", c->comm, p->pid, c->total_time / 1000000.0);\r\nsvg_text(Y, c->start_time, comm);\r\n}\r\nc->Y = Y;\r\nY++;\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\n}\r\nstatic void add_process_filter(const char *string)\r\n{\r\nstruct process_filter *filt;\r\nint pid;\r\npid = strtoull(string, NULL, 10);\r\nfilt = malloc(sizeof(struct process_filter));\r\nif (!filt)\r\nreturn;\r\nfilt->name = strdup(string);\r\nfilt->pid = pid;\r\nfilt->next = process_filter;\r\nprocess_filter = filt;\r\n}\r\nstatic int passes_filter(struct per_pid *p, struct per_pidcomm *c)\r\n{\r\nstruct process_filter *filt;\r\nif (!process_filter)\r\nreturn 1;\r\nfilt = process_filter;\r\nwhile (filt) {\r\nif (filt->pid && p->pid == filt->pid)\r\nreturn 1;\r\nif (strcmp(filt->name, c->comm) == 0)\r\nreturn 1;\r\nfilt = filt->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic int determine_display_tasks_filtered(void)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nint count = 0;\r\np = all_data;\r\nwhile (p) {\r\np->display = 0;\r\nif (p->start_time == 1)\r\np->start_time = first_time;\r\nif (p->end_time == 0)\r\np->end_time = last_time;\r\nc = p->all;\r\nwhile (c) {\r\nc->display = 0;\r\nif (c->start_time == 1)\r\nc->start_time = first_time;\r\nif (passes_filter(p, c)) {\r\nc->display = 1;\r\np->display = 1;\r\ncount++;\r\n}\r\nif (c->end_time == 0)\r\nc->end_time = last_time;\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\nreturn count;\r\n}\r\nstatic int determine_display_tasks(u64 threshold)\r\n{\r\nstruct per_pid *p;\r\nstruct per_pidcomm *c;\r\nint count = 0;\r\nif (process_filter)\r\nreturn determine_display_tasks_filtered();\r\np = all_data;\r\nwhile (p) {\r\np->display = 0;\r\nif (p->start_time == 1)\r\np->start_time = first_time;\r\nif (p->end_time == 0)\r\np->end_time = last_time;\r\nif (p->total_time >= threshold && !power_only)\r\np->display = 1;\r\nc = p->all;\r\nwhile (c) {\r\nc->display = 0;\r\nif (c->start_time == 1)\r\nc->start_time = first_time;\r\nif (c->total_time >= threshold && !power_only) {\r\nc->display = 1;\r\ncount++;\r\n}\r\nif (c->end_time == 0)\r\nc->end_time = last_time;\r\nc = c->next;\r\n}\r\np = p->next;\r\n}\r\nreturn count;\r\n}\r\nstatic void write_svg_file(const char *filename)\r\n{\r\nu64 i;\r\nint count;\r\nnumcpus++;\r\ncount = determine_display_tasks(TIME_THRESH);\r\nif (count < 15)\r\ncount = determine_display_tasks(TIME_THRESH / 10);\r\nopen_svg(filename, numcpus, count, first_time, last_time);\r\nsvg_time_grid();\r\nsvg_legenda();\r\nfor (i = 0; i < numcpus; i++)\r\nsvg_cpu_box(i, max_freq, turbo_frequency);\r\ndraw_cpu_usage();\r\ndraw_process_bars();\r\ndraw_c_p_states();\r\ndraw_wakeups();\r\nsvg_close();\r\n}\r\nstatic int __cmd_timechart(void)\r\n{\r\nstruct perf_session *session = perf_session__new(input_name, O_RDONLY,\r\n0, false, &event_ops);\r\nint ret = -EINVAL;\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\nif (!perf_session__has_traces(session, "timechart record"))\r\ngoto out_delete;\r\nret = perf_session__process_events(session, &event_ops);\r\nif (ret)\r\ngoto out_delete;\r\nend_sample_processing();\r\nsort_pids();\r\nwrite_svg_file(output_name);\r\npr_info("Written %2.1f seconds of trace to %s.\n",\r\n(last_time - first_time) / 1000000000.0, output_name);\r\nout_delete:\r\nperf_session__delete(session);\r\nreturn ret;\r\n}\r\nstatic int __cmd_record(int argc, const char **argv)\r\n{\r\nunsigned int rec_argc, i, j;\r\nconst char **rec_argv;\r\nconst char * const *record_args = record_new_args;\r\nunsigned int record_elems = ARRAY_SIZE(record_new_args);\r\n#ifdef SUPPORT_OLD_POWER_EVENTS\r\nif (!is_valid_tracepoint("power:cpu_idle") &&\r\nis_valid_tracepoint("power:power_start")) {\r\nuse_old_power_events = 1;\r\nrecord_args = record_old_args;\r\nrecord_elems = ARRAY_SIZE(record_old_args);\r\n}\r\n#endif\r\nrec_argc = record_elems + argc - 1;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (rec_argv == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < record_elems; i++)\r\nrec_argv[i] = strdup(record_args[i]);\r\nfor (j = 1; j < (unsigned int)argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nreturn cmd_record(i, rec_argv, NULL);\r\n}\r\nstatic int\r\nparse_process(const struct option *opt __used, const char *arg, int __used unset)\r\n{\r\nif (arg)\r\nadd_process_filter(arg);\r\nreturn 0;\r\n}\r\nint cmd_timechart(int argc, const char **argv, const char *prefix __used)\r\n{\r\nargc = parse_options(argc, argv, options, timechart_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nsymbol__init();\r\nif (argc && !strncmp(argv[0], "rec", 3))\r\nreturn __cmd_record(argc, argv);\r\nelse if (argc)\r\nusage_with_options(timechart_usage, options);\r\nsetup_pager();\r\nreturn __cmd_timechart();\r\n}
