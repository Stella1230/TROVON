static int ali_fetch_size(void)\r\n{\r\nint i;\r\nu32 temp;\r\nstruct aper_size_info_32 *values;\r\npci_read_config_dword(agp_bridge->dev, ALI_ATTBASE, &temp);\r\ntemp &= ~(0xfffffff0);\r\nvalues = A_SIZE_32(agp_bridge->driver->aperture_sizes);\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (temp == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ali_tlbflush(struct agp_memory *mem)\r\n{\r\nu32 temp;\r\npci_read_config_dword(agp_bridge->dev, ALI_TLBCTRL, &temp);\r\ntemp &= 0xfffffff0;\r\ntemp |= (1<<0 | 1<<1);\r\npci_write_config_dword(agp_bridge->dev, ALI_TAGCTRL, temp);\r\n}\r\nstatic void ali_cleanup(void)\r\n{\r\nstruct aper_size_info_32 *previous_size;\r\nu32 temp;\r\nprevious_size = A_SIZE_32(agp_bridge->previous_size);\r\npci_read_config_dword(agp_bridge->dev, ALI_TLBCTRL, &temp);\r\npci_write_config_dword(agp_bridge->dev, ALI_TAGCTRL,\r\n((temp & 0xffffff00) | 0x00000001|0x00000002));\r\npci_read_config_dword(agp_bridge->dev, ALI_ATTBASE, &temp);\r\npci_write_config_dword(agp_bridge->dev, ALI_ATTBASE,\r\n((temp & 0x00000ff0) | previous_size->size_value));\r\n}\r\nstatic int ali_configure(void)\r\n{\r\nu32 temp;\r\nstruct aper_size_info_32 *current_size;\r\ncurrent_size = A_SIZE_32(agp_bridge->current_size);\r\npci_read_config_dword(agp_bridge->dev, ALI_ATTBASE, &temp);\r\ntemp = (((temp & 0x00000ff0) | (agp_bridge->gatt_bus_addr & 0xfffff000))\r\n| (current_size->size_value & 0xf));\r\npci_write_config_dword(agp_bridge->dev, ALI_ATTBASE, temp);\r\npci_read_config_dword(agp_bridge->dev, ALI_TLBCTRL, &temp);\r\npci_write_config_dword(agp_bridge->dev, ALI_TLBCTRL, ((temp & 0xffffff00) | 0x00000010));\r\npci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);\r\nagp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\n#if 0\r\nif (agp_bridge->type == ALI_M1541) {\r\nu32 nlvm_addr = 0;\r\nswitch (current_size->size_value) {\r\ncase 0: break;\r\ncase 1: nlvm_addr = 0x100000;break;\r\ncase 2: nlvm_addr = 0x200000;break;\r\ncase 3: nlvm_addr = 0x400000;break;\r\ncase 4: nlvm_addr = 0x800000;break;\r\ncase 6: nlvm_addr = 0x1000000;break;\r\ncase 7: nlvm_addr = 0x2000000;break;\r\ncase 8: nlvm_addr = 0x4000000;break;\r\ncase 9: nlvm_addr = 0x8000000;break;\r\ncase 10: nlvm_addr = 0x10000000;break;\r\ndefault: break;\r\n}\r\nnlvm_addr--;\r\nnlvm_addr&=0xfff00000;\r\nnlvm_addr+= agp_bridge->gart_bus_addr;\r\nnlvm_addr|=(agp_bridge->gart_bus_addr>>12);\r\ndev_info(&agp_bridge->dev->dev, "nlvm top &base = %8x\n",\r\nnlvm_addr);\r\n}\r\n#endif\r\npci_read_config_dword(agp_bridge->dev, ALI_TLBCTRL, &temp);\r\ntemp &= 0xffffff7f;\r\npci_write_config_dword(agp_bridge->dev, ALI_TLBCTRL, temp);\r\nreturn 0;\r\n}\r\nstatic void m1541_cache_flush(void)\r\n{\r\nint i, page_count;\r\nu32 temp;\r\nglobal_cache_flush();\r\npage_count = 1 << A_SIZE_32(agp_bridge->current_size)->page_order;\r\nfor (i = 0; i < PAGE_SIZE * page_count; i += PAGE_SIZE) {\r\npci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,\r\n&temp);\r\npci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,\r\n(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |\r\n(agp_bridge->gatt_bus_addr + i)) |\r\nALI_CACHE_FLUSH_EN));\r\n}\r\n}\r\nstatic struct page *m1541_alloc_page(struct agp_bridge_data *bridge)\r\n{\r\nstruct page *page = agp_generic_alloc_page(agp_bridge);\r\nu32 temp;\r\nif (!page)\r\nreturn NULL;\r\npci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL, &temp);\r\npci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,\r\n(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |\r\npage_to_phys(page)) | ALI_CACHE_FLUSH_EN ));\r\nreturn page;\r\n}\r\nstatic void ali_destroy_page(struct page *page, int flags)\r\n{\r\nif (page) {\r\nif (flags & AGP_PAGE_DESTROY_UNMAP) {\r\nglobal_cache_flush();\r\nagp_generic_destroy_page(page, flags);\r\n} else\r\nagp_generic_destroy_page(page, flags);\r\n}\r\n}\r\nstatic void m1541_destroy_page(struct page *page, int flags)\r\n{\r\nu32 temp;\r\nif (page == NULL)\r\nreturn;\r\nif (flags & AGP_PAGE_DESTROY_UNMAP) {\r\nglobal_cache_flush();\r\npci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL, &temp);\r\npci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,\r\n(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |\r\npage_to_phys(page)) | ALI_CACHE_FLUSH_EN));\r\n}\r\nagp_generic_destroy_page(page, flags);\r\n}\r\nstatic int __devinit agp_ali_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_device_ids *devs = ali_agp_device_ids;\r\nstruct agp_bridge_data *bridge;\r\nu8 hidden_1621_id, cap_ptr;\r\nint j;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\nfor (j = 0; devs[j].chipset_name; j++) {\r\nif (pdev->device == devs[j].device_id)\r\ngoto found;\r\n}\r\ndev_err(&pdev->dev, "unsupported ALi chipset [%04x/%04x])\n",\r\npdev->vendor, pdev->device);\r\nreturn -ENODEV;\r\nfound:\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_AL_M1541:\r\nbridge->driver = &ali_m1541_bridge;\r\nbreak;\r\ncase PCI_DEVICE_ID_AL_M1621:\r\npci_read_config_byte(pdev, 0xFB, &hidden_1621_id);\r\nswitch (hidden_1621_id) {\r\ncase 0x31:\r\ndevs[j].chipset_name = "M1631";\r\nbreak;\r\ncase 0x32:\r\ndevs[j].chipset_name = "M1632";\r\nbreak;\r\ncase 0x41:\r\ndevs[j].chipset_name = "M1641";\r\nbreak;\r\ncase 0x43:\r\ndevs[j].chipset_name = "M1621";\r\nbreak;\r\ncase 0x47:\r\ndevs[j].chipset_name = "M1647";\r\nbreak;\r\ncase 0x51:\r\ndevs[j].chipset_name = "M1651";\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nbridge->driver = &ali_generic_bridge;\r\n}\r\ndev_info(&pdev->dev, "ALi %s chipset\n", devs[j].chipset_name);\r\npci_read_config_dword(pdev,\r\nbridge->capndx+PCI_AGP_STATUS,\r\n&bridge->mode);\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void __devexit agp_ali_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int __init agp_ali_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_ali_pci_driver);\r\n}\r\nstatic void __exit agp_ali_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_ali_pci_driver);\r\n}
