static void usb_stor_blocking_completion(struct urb *urb)\r\n{\r\nstruct completion *urb_done_ptr = urb->context;\r\ncomplete(urb_done_ptr);\r\n}\r\nstatic int usb_stor_msg_common(struct us_data *us, int timeout)\r\n{\r\nstruct completion urb_done;\r\nlong timeleft;\r\nint status;\r\nif (test_bit(US_FLIDX_ABORTING, &us->dflags))\r\nreturn -EIO;\r\ninit_completion(&urb_done);\r\nus->current_urb->context = &urb_done;\r\nus->current_urb->transfer_flags = 0;\r\nif (us->current_urb->transfer_buffer == us->iobuf)\r\nus->current_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nus->current_urb->transfer_dma = us->iobuf_dma;\r\nstatus = usb_submit_urb(us->current_urb, GFP_NOIO);\r\nif (status) {\r\nreturn status;\r\n}\r\nset_bit(US_FLIDX_URB_ACTIVE, &us->dflags);\r\nif (test_bit(US_FLIDX_ABORTING, &us->dflags)) {\r\nif (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &us->dflags)) {\r\nUS_DEBUGP("-- cancelling URB\n");\r\nusb_unlink_urb(us->current_urb);\r\n}\r\n}\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&urb_done, timeout ? : MAX_SCHEDULE_TIMEOUT);\r\nclear_bit(US_FLIDX_URB_ACTIVE, &us->dflags);\r\nif (timeleft <= 0) {\r\nUS_DEBUGP("%s -- cancelling URB\n",\r\ntimeleft == 0 ? "Timeout" : "Signal");\r\nusb_kill_urb(us->current_urb);\r\n}\r\nreturn us->current_urb->status;\r\n}\r\nint usb_stor_control_msg(struct us_data *us, unsigned int pipe,\r\nu8 request, u8 requesttype, u16 value, u16 index,\r\nvoid *data, u16 size, int timeout)\r\n{\r\nint status;\r\nUS_DEBUGP("%s: rq=%02x rqtype=%02x value=%04x index=%02x len=%u\n",\r\n__func__, request, requesttype,\r\nvalue, index, size);\r\nus->cr->bRequestType = requesttype;\r\nus->cr->bRequest = request;\r\nus->cr->wValue = cpu_to_le16(value);\r\nus->cr->wIndex = cpu_to_le16(index);\r\nus->cr->wLength = cpu_to_le16(size);\r\nusb_fill_control_urb(us->current_urb, us->pusb_dev, pipe,\r\n(unsigned char*) us->cr, data, size,\r\nusb_stor_blocking_completion, NULL);\r\nstatus = usb_stor_msg_common(us, timeout);\r\nif (status == 0)\r\nstatus = us->current_urb->actual_length;\r\nreturn status;\r\n}\r\nint usb_stor_clear_halt(struct us_data *us, unsigned int pipe)\r\n{\r\nint result;\r\nint endp = usb_pipeendpoint(pipe);\r\nif (usb_pipein (pipe))\r\nendp |= USB_DIR_IN;\r\nresult = usb_stor_control_msg(us, us->send_ctrl_pipe,\r\nUSB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,\r\nUSB_ENDPOINT_HALT, endp,\r\nNULL, 0, 3*HZ);\r\nif (result >= 0)\r\nusb_reset_endpoint(us->pusb_dev, endp);\r\nUS_DEBUGP("%s: result = %d\n", __func__, result);\r\nreturn result;\r\n}\r\nstatic int interpret_urb_result(struct us_data *us, unsigned int pipe,\r\nunsigned int length, int result, unsigned int partial)\r\n{\r\nUS_DEBUGP("Status code %d; transferred %u/%u\n",\r\nresult, partial, length);\r\nswitch (result) {\r\ncase 0:\r\nif (partial != length) {\r\nUS_DEBUGP("-- short transfer\n");\r\nreturn USB_STOR_XFER_SHORT;\r\n}\r\nUS_DEBUGP("-- transfer complete\n");\r\nreturn USB_STOR_XFER_GOOD;\r\ncase -EPIPE:\r\nif (usb_pipecontrol(pipe)) {\r\nUS_DEBUGP("-- stall on control pipe\n");\r\nreturn USB_STOR_XFER_STALLED;\r\n}\r\nUS_DEBUGP("clearing endpoint halt for pipe 0x%x\n", pipe);\r\nif (usb_stor_clear_halt(us, pipe) < 0)\r\nreturn USB_STOR_XFER_ERROR;\r\nreturn USB_STOR_XFER_STALLED;\r\ncase -EOVERFLOW:\r\nUS_DEBUGP("-- babble\n");\r\nreturn USB_STOR_XFER_LONG;\r\ncase -ECONNRESET:\r\nUS_DEBUGP("-- transfer cancelled\n");\r\nreturn USB_STOR_XFER_ERROR;\r\ncase -EREMOTEIO:\r\nUS_DEBUGP("-- short read transfer\n");\r\nreturn USB_STOR_XFER_SHORT;\r\ncase -EIO:\r\nUS_DEBUGP("-- abort or disconnect in progress\n");\r\nreturn USB_STOR_XFER_ERROR;\r\ndefault:\r\nUS_DEBUGP("-- unknown error\n");\r\nreturn USB_STOR_XFER_ERROR;\r\n}\r\n}\r\nint usb_stor_ctrl_transfer(struct us_data *us, unsigned int pipe,\r\nu8 request, u8 requesttype, u16 value, u16 index,\r\nvoid *data, u16 size)\r\n{\r\nint result;\r\nUS_DEBUGP("%s: rq=%02x rqtype=%02x value=%04x index=%02x len=%u\n",\r\n__func__, request, requesttype,\r\nvalue, index, size);\r\nus->cr->bRequestType = requesttype;\r\nus->cr->bRequest = request;\r\nus->cr->wValue = cpu_to_le16(value);\r\nus->cr->wIndex = cpu_to_le16(index);\r\nus->cr->wLength = cpu_to_le16(size);\r\nusb_fill_control_urb(us->current_urb, us->pusb_dev, pipe,\r\n(unsigned char*) us->cr, data, size,\r\nusb_stor_blocking_completion, NULL);\r\nresult = usb_stor_msg_common(us, 0);\r\nreturn interpret_urb_result(us, pipe, size, result,\r\nus->current_urb->actual_length);\r\n}\r\nstatic int usb_stor_intr_transfer(struct us_data *us, void *buf,\r\nunsigned int length)\r\n{\r\nint result;\r\nunsigned int pipe = us->recv_intr_pipe;\r\nunsigned int maxp;\r\nUS_DEBUGP("%s: xfer %u bytes\n", __func__, length);\r\nmaxp = usb_maxpacket(us->pusb_dev, pipe, usb_pipeout(pipe));\r\nif (maxp > length)\r\nmaxp = length;\r\nusb_fill_int_urb(us->current_urb, us->pusb_dev, pipe, buf,\r\nmaxp, usb_stor_blocking_completion, NULL,\r\nus->ep_bInterval);\r\nresult = usb_stor_msg_common(us, 0);\r\nreturn interpret_urb_result(us, pipe, length, result,\r\nus->current_urb->actual_length);\r\n}\r\nint usb_stor_bulk_transfer_buf(struct us_data *us, unsigned int pipe,\r\nvoid *buf, unsigned int length, unsigned int *act_len)\r\n{\r\nint result;\r\nUS_DEBUGP("%s: xfer %u bytes\n", __func__, length);\r\nusb_fill_bulk_urb(us->current_urb, us->pusb_dev, pipe, buf, length,\r\nusb_stor_blocking_completion, NULL);\r\nresult = usb_stor_msg_common(us, 0);\r\nif (act_len)\r\n*act_len = us->current_urb->actual_length;\r\nreturn interpret_urb_result(us, pipe, length, result,\r\nus->current_urb->actual_length);\r\n}\r\nstatic int usb_stor_bulk_transfer_sglist(struct us_data *us, unsigned int pipe,\r\nstruct scatterlist *sg, int num_sg, unsigned int length,\r\nunsigned int *act_len)\r\n{\r\nint result;\r\nif (test_bit(US_FLIDX_ABORTING, &us->dflags))\r\nreturn USB_STOR_XFER_ERROR;\r\nUS_DEBUGP("%s: xfer %u bytes, %d entries\n", __func__,\r\nlength, num_sg);\r\nresult = usb_sg_init(&us->current_sg, us->pusb_dev, pipe, 0,\r\nsg, num_sg, length, GFP_NOIO);\r\nif (result) {\r\nUS_DEBUGP("usb_sg_init returned %d\n", result);\r\nreturn USB_STOR_XFER_ERROR;\r\n}\r\nset_bit(US_FLIDX_SG_ACTIVE, &us->dflags);\r\nif (test_bit(US_FLIDX_ABORTING, &us->dflags)) {\r\nif (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &us->dflags)) {\r\nUS_DEBUGP("-- cancelling sg request\n");\r\nusb_sg_cancel(&us->current_sg);\r\n}\r\n}\r\nusb_sg_wait(&us->current_sg);\r\nclear_bit(US_FLIDX_SG_ACTIVE, &us->dflags);\r\nresult = us->current_sg.status;\r\nif (act_len)\r\n*act_len = us->current_sg.bytes;\r\nreturn interpret_urb_result(us, pipe, length, result,\r\nus->current_sg.bytes);\r\n}\r\nint usb_stor_bulk_srb(struct us_data* us, unsigned int pipe,\r\nstruct scsi_cmnd* srb)\r\n{\r\nunsigned int partial;\r\nint result = usb_stor_bulk_transfer_sglist(us, pipe, scsi_sglist(srb),\r\nscsi_sg_count(srb), scsi_bufflen(srb),\r\n&partial);\r\nscsi_set_resid(srb, scsi_bufflen(srb) - partial);\r\nreturn result;\r\n}\r\nint usb_stor_bulk_transfer_sg(struct us_data* us, unsigned int pipe,\r\nvoid *buf, unsigned int length_left, int use_sg, int *residual)\r\n{\r\nint result;\r\nunsigned int partial;\r\nif (use_sg) {\r\nresult = usb_stor_bulk_transfer_sglist(us, pipe,\r\n(struct scatterlist *) buf, use_sg,\r\nlength_left, &partial);\r\nlength_left -= partial;\r\n} else {\r\nresult = usb_stor_bulk_transfer_buf(us, pipe, buf,\r\nlength_left, &partial);\r\nlength_left -= partial;\r\n}\r\nif (residual)\r\n*residual = length_left;\r\nreturn result;\r\n}\r\nstatic void last_sector_hacks(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nstruct gendisk *disk;\r\nstruct scsi_disk *sdkp;\r\nu32 sector;\r\nstatic unsigned char record_not_found[18] = {\r\n[0] = 0x70,\r\n[2] = MEDIUM_ERROR,\r\n[7] = 0x0a,\r\n[12] = 0x14\r\n};\r\nif (!us->use_last_sector_hacks)\r\nreturn;\r\nif (srb->cmnd[0] != READ_10 && srb->cmnd[0] != WRITE_10)\r\ngoto done;\r\nsector = (srb->cmnd[2] << 24) | (srb->cmnd[3] << 16) |\r\n(srb->cmnd[4] << 8) | (srb->cmnd[5]);\r\ndisk = srb->request->rq_disk;\r\nif (!disk)\r\ngoto done;\r\nsdkp = scsi_disk(disk);\r\nif (!sdkp)\r\ngoto done;\r\nif (sector + 1 != sdkp->capacity)\r\ngoto done;\r\nif (srb->result == SAM_STAT_GOOD && scsi_get_resid(srb) == 0) {\r\nus->use_last_sector_hacks = 0;\r\n} else {\r\nif (++us->last_sector_retries < 3)\r\nreturn;\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nmemcpy(srb->sense_buffer, record_not_found,\r\nsizeof(record_not_found));\r\n}\r\ndone:\r\nif (srb->cmnd[0] != TEST_UNIT_READY)\r\nus->last_sector_retries = 0;\r\n}\r\nvoid usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nint need_auto_sense;\r\nint result;\r\nscsi_set_resid(srb, 0);\r\nresult = us->transport(srb, us);\r\nif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\r\nUS_DEBUGP("-- command was aborted\n");\r\nsrb->result = DID_ABORT << 16;\r\ngoto Handle_Errors;\r\n}\r\nif (result == USB_STOR_TRANSPORT_ERROR) {\r\nUS_DEBUGP("-- transport indicates error, resetting\n");\r\nsrb->result = DID_ERROR << 16;\r\ngoto Handle_Errors;\r\n}\r\nif (result == USB_STOR_TRANSPORT_NO_SENSE) {\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nlast_sector_hacks(us, srb);\r\nreturn;\r\n}\r\nsrb->result = SAM_STAT_GOOD;\r\nneed_auto_sense = 0;\r\nif ((us->protocol == USB_PR_CB || us->protocol == USB_PR_DPCM_USB) &&\r\nsrb->sc_data_direction != DMA_FROM_DEVICE) {\r\nUS_DEBUGP("-- CB transport device requiring auto-sense\n");\r\nneed_auto_sense = 1;\r\n}\r\nif (result == USB_STOR_TRANSPORT_FAILED) {\r\nUS_DEBUGP("-- transport indicates command failure\n");\r\nneed_auto_sense = 1;\r\n}\r\nif (unlikely((srb->cmnd[0] == ATA_16 || srb->cmnd[0] == ATA_12) &&\r\nresult == USB_STOR_TRANSPORT_GOOD &&\r\n!(us->fflags & US_FL_SANE_SENSE) &&\r\n!(us->fflags & US_FL_BAD_SENSE) &&\r\n!(srb->cmnd[2] & 0x20))) {\r\nUS_DEBUGP("-- SAT supported, increasing auto-sense\n");\r\nus->fflags |= US_FL_SANE_SENSE;\r\n}\r\nif ((scsi_get_resid(srb) > 0) &&\r\n!((srb->cmnd[0] == REQUEST_SENSE) ||\r\n(srb->cmnd[0] == INQUIRY) ||\r\n(srb->cmnd[0] == MODE_SENSE) ||\r\n(srb->cmnd[0] == LOG_SENSE) ||\r\n(srb->cmnd[0] == MODE_SENSE_10))) {\r\nUS_DEBUGP("-- unexpectedly short transfer\n");\r\n}\r\nif (need_auto_sense) {\r\nint temp_result;\r\nstruct scsi_eh_save ses;\r\nint sense_size = US_SENSE_SIZE;\r\nif (us->fflags & US_FL_SANE_SENSE)\r\nsense_size = ~0;\r\nRetry_Sense:\r\nUS_DEBUGP("Issuing auto-REQUEST_SENSE\n");\r\nscsi_eh_prep_cmnd(srb, &ses, NULL, 0, sense_size);\r\nif (us->subclass == USB_SC_RBC || us->subclass == USB_SC_SCSI ||\r\nus->subclass == USB_SC_CYP_ATACB)\r\nsrb->cmd_len = 6;\r\nelse\r\nsrb->cmd_len = 12;\r\nscsi_set_resid(srb, 0);\r\ntemp_result = us->transport(us->srb, us);\r\nscsi_eh_restore_cmnd(srb, &ses);\r\nif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\r\nUS_DEBUGP("-- auto-sense aborted\n");\r\nsrb->result = DID_ABORT << 16;\r\nif (sense_size != US_SENSE_SIZE) {\r\nus->fflags &= ~US_FL_SANE_SENSE;\r\nus->fflags |= US_FL_BAD_SENSE;\r\n}\r\ngoto Handle_Errors;\r\n}\r\nif (temp_result == USB_STOR_TRANSPORT_FAILED &&\r\nsense_size != US_SENSE_SIZE) {\r\nUS_DEBUGP("-- auto-sense failure, retry small sense\n");\r\nsense_size = US_SENSE_SIZE;\r\nus->fflags &= ~US_FL_SANE_SENSE;\r\nus->fflags |= US_FL_BAD_SENSE;\r\ngoto Retry_Sense;\r\n}\r\nif (temp_result != USB_STOR_TRANSPORT_GOOD) {\r\nUS_DEBUGP("-- auto-sense failure\n");\r\nsrb->result = DID_ERROR << 16;\r\nif (!(us->fflags & US_FL_SCM_MULT_TARG))\r\ngoto Handle_Errors;\r\nreturn;\r\n}\r\nif (srb->sense_buffer[7] > (US_SENSE_SIZE - 8) &&\r\n!(us->fflags & US_FL_SANE_SENSE) &&\r\n!(us->fflags & US_FL_BAD_SENSE) &&\r\n(srb->sense_buffer[0] & 0x7C) == 0x70) {\r\nUS_DEBUGP("-- SANE_SENSE support enabled\n");\r\nus->fflags |= US_FL_SANE_SENSE;\r\nUS_DEBUGP("-- Sense data truncated to %i from %i\n",\r\nUS_SENSE_SIZE,\r\nsrb->sense_buffer[7] + 8);\r\nsrb->sense_buffer[7] = (US_SENSE_SIZE - 8);\r\n}\r\nUS_DEBUGP("-- Result from auto-sense is %d\n", temp_result);\r\nUS_DEBUGP("-- code: 0x%x, key: 0x%x, ASC: 0x%x, ASCQ: 0x%x\n",\r\nsrb->sense_buffer[0],\r\nsrb->sense_buffer[2] & 0xf,\r\nsrb->sense_buffer[12],\r\nsrb->sense_buffer[13]);\r\n#ifdef CONFIG_USB_STORAGE_DEBUG\r\nusb_stor_show_sense(\r\nsrb->sense_buffer[2] & 0xf,\r\nsrb->sense_buffer[12],\r\nsrb->sense_buffer[13]);\r\n#endif\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nif (\r\n(srb->sense_buffer[2] & 0xaf) == 0 &&\r\nsrb->sense_buffer[12] == 0 &&\r\nsrb->sense_buffer[13] == 0) {\r\nif (result == USB_STOR_TRANSPORT_GOOD) {\r\nsrb->result = SAM_STAT_GOOD;\r\nsrb->sense_buffer[0] = 0x0;\r\n} else {\r\nsrb->result = DID_ERROR << 16;\r\nsrb->sense_buffer[2] = HARDWARE_ERROR;\r\n}\r\n}\r\n}\r\nif (unlikely((us->fflags & US_FL_INITIAL_READ10) &&\r\nsrb->cmnd[0] == READ_10)) {\r\nif (srb->result == SAM_STAT_GOOD) {\r\nset_bit(US_FLIDX_READ10_WORKED, &us->dflags);\r\n} else if (test_bit(US_FLIDX_READ10_WORKED, &us->dflags)) {\r\nclear_bit(US_FLIDX_READ10_WORKED, &us->dflags);\r\nset_bit(US_FLIDX_REDO_READ10, &us->dflags);\r\n}\r\nif (test_bit(US_FLIDX_REDO_READ10, &us->dflags)) {\r\nclear_bit(US_FLIDX_REDO_READ10, &us->dflags);\r\nsrb->result = DID_IMM_RETRY << 16;\r\nsrb->sense_buffer[0] = 0;\r\n}\r\n}\r\nif ((srb->result == SAM_STAT_GOOD || srb->sense_buffer[2] == 0) &&\r\nscsi_bufflen(srb) - scsi_get_resid(srb) < srb->underflow)\r\nsrb->result = DID_ERROR << 16;\r\nlast_sector_hacks(us, srb);\r\nreturn;\r\nHandle_Errors:\r\nscsi_lock(us_to_host(us));\r\nset_bit(US_FLIDX_RESETTING, &us->dflags);\r\nclear_bit(US_FLIDX_ABORTING, &us->dflags);\r\nscsi_unlock(us_to_host(us));\r\nmutex_unlock(&us->dev_mutex);\r\nresult = usb_stor_port_reset(us);\r\nmutex_lock(&us->dev_mutex);\r\nif (result < 0) {\r\nscsi_lock(us_to_host(us));\r\nusb_stor_report_device_reset(us);\r\nscsi_unlock(us_to_host(us));\r\nus->transport_reset(us);\r\n}\r\nclear_bit(US_FLIDX_RESETTING, &us->dflags);\r\nlast_sector_hacks(us, srb);\r\n}\r\nvoid usb_stor_stop_transport(struct us_data *us)\r\n{\r\nUS_DEBUGP("%s called\n", __func__);\r\nif (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &us->dflags)) {\r\nUS_DEBUGP("-- cancelling URB\n");\r\nusb_unlink_urb(us->current_urb);\r\n}\r\nif (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &us->dflags)) {\r\nUS_DEBUGP("-- cancelling sg request\n");\r\nusb_sg_cancel(&us->current_sg);\r\n}\r\n}\r\nint usb_stor_CB_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nunsigned int transfer_length = scsi_bufflen(srb);\r\nunsigned int pipe = 0;\r\nint result;\r\nresult = usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\r\nUS_CBI_ADSC,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE, 0,\r\nus->ifnum, srb->cmnd, srb->cmd_len);\r\nUS_DEBUGP("Call to usb_stor_ctrl_transfer() returned %d\n", result);\r\nif (result == USB_STOR_XFER_STALLED) {\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nif (result != USB_STOR_XFER_GOOD) {\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (transfer_length) {\r\npipe = srb->sc_data_direction == DMA_FROM_DEVICE ?\r\nus->recv_bulk_pipe : us->send_bulk_pipe;\r\nresult = usb_stor_bulk_srb(us, pipe, srb);\r\nUS_DEBUGP("CBI data stage result is 0x%x\n", result);\r\nif (result == USB_STOR_XFER_STALLED)\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\nif (result > USB_STOR_XFER_STALLED)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (us->protocol != USB_PR_CBI)\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nresult = usb_stor_intr_transfer(us, us->iobuf, 2);\r\nUS_DEBUGP("Got interrupt data (0x%x, 0x%x)\n",\r\nus->iobuf[0], us->iobuf[1]);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (us->subclass == USB_SC_UFI) {\r\nif (srb->cmnd[0] == REQUEST_SENSE ||\r\nsrb->cmnd[0] == INQUIRY)\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nif (us->iobuf[0])\r\ngoto Failed;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (us->iobuf[0]) {\r\nUS_DEBUGP("CBI IRQ data showed reserved bType 0x%x\n",\r\nus->iobuf[0]);\r\ngoto Failed;\r\n}\r\nswitch (us->iobuf[1] & 0x0F) {\r\ncase 0x00:\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\ncase 0x01:\r\ngoto Failed;\r\n}\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nFailed:\r\nif (pipe)\r\nusb_stor_clear_halt(us, pipe);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nint usb_stor_Bulk_max_lun(struct us_data *us)\r\n{\r\nint result;\r\nus->iobuf[0] = 0;\r\nresult = usb_stor_control_msg(us, us->recv_ctrl_pipe,\r\nUS_BULK_GET_MAX_LUN,\r\nUSB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE,\r\n0, us->ifnum, us->iobuf, 1, 10*HZ);\r\nUS_DEBUGP("GetMaxLUN command result is %d, data is %d\n",\r\nresult, us->iobuf[0]);\r\nif (result > 0)\r\nreturn us->iobuf[0];\r\nreturn 0;\r\n}\r\nint usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nstruct bulk_cs_wrap *bcs = (struct bulk_cs_wrap *) us->iobuf;\r\nunsigned int transfer_length = scsi_bufflen(srb);\r\nunsigned int residue;\r\nint result;\r\nint fake_sense = 0;\r\nunsigned int cswlen;\r\nunsigned int cbwlen = US_BULK_CB_WRAP_LEN;\r\nif (unlikely(us->fflags & US_FL_BULK32)) {\r\ncbwlen = 32;\r\nus->iobuf[31] = 0;\r\n}\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = cpu_to_le32(transfer_length);\r\nbcb->Flags = srb->sc_data_direction == DMA_FROM_DEVICE ? 1 << 7 : 0;\r\nbcb->Tag = ++us->tag;\r\nbcb->Lun = srb->device->lun;\r\nif (us->fflags & US_FL_SCM_MULT_TARG)\r\nbcb->Lun |= srb->device->id << 4;\r\nbcb->Length = srb->cmd_len;\r\nmemset(bcb->CDB, 0, sizeof(bcb->CDB));\r\nmemcpy(bcb->CDB, srb->cmnd, bcb->Length);\r\nUS_DEBUGP("Bulk Command S 0x%x T 0x%x L %d F %d Trg %d LUN %d CL %d\n",\r\nle32_to_cpu(bcb->Signature), bcb->Tag,\r\nle32_to_cpu(bcb->DataTransferLength), bcb->Flags,\r\n(bcb->Lun >> 4), (bcb->Lun & 0x0F),\r\nbcb->Length);\r\nresult = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\nbcb, cbwlen, NULL);\r\nUS_DEBUGP("Bulk command transfer result=%d\n", result);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (unlikely(us->fflags & US_FL_GO_SLOW))\r\nudelay(125);\r\nif (transfer_length) {\r\nunsigned int pipe = srb->sc_data_direction == DMA_FROM_DEVICE ?\r\nus->recv_bulk_pipe : us->send_bulk_pipe;\r\nresult = usb_stor_bulk_srb(us, pipe, srb);\r\nUS_DEBUGP("Bulk data transfer result 0x%x\n", result);\r\nif (result == USB_STOR_XFER_ERROR)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (result == USB_STOR_XFER_LONG)\r\nfake_sense = 1;\r\n}\r\nUS_DEBUGP("Attempting to get CSW...\n");\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\nbcs, US_BULK_CS_WRAP_LEN, &cswlen);\r\nif (result == USB_STOR_XFER_SHORT && cswlen == 0) {\r\nUS_DEBUGP("Received 0-length CSW; retrying...\n");\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\nbcs, US_BULK_CS_WRAP_LEN, &cswlen);\r\n}\r\nif (result == USB_STOR_XFER_STALLED) {\r\nUS_DEBUGP("Attempting to get CSW (2nd try)...\n");\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\nbcs, US_BULK_CS_WRAP_LEN, NULL);\r\n}\r\nUS_DEBUGP("Bulk status result = %d\n", result);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nresidue = le32_to_cpu(bcs->Residue);\r\nUS_DEBUGP("Bulk Status S 0x%x T 0x%x R %u Stat 0x%x\n",\r\nle32_to_cpu(bcs->Signature), bcs->Tag,\r\nresidue, bcs->Status);\r\nif (!(bcs->Tag == us->tag || (us->fflags & US_FL_BULK_IGNORE_TAG)) ||\r\nbcs->Status > US_BULK_STAT_PHASE) {\r\nUS_DEBUGP("Bulk logical error\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (!us->bcs_signature) {\r\nus->bcs_signature = bcs->Signature;\r\nif (us->bcs_signature != cpu_to_le32(US_BULK_CS_SIGN))\r\nUS_DEBUGP("Learnt BCS signature 0x%08X\n",\r\nle32_to_cpu(us->bcs_signature));\r\n} else if (bcs->Signature != us->bcs_signature) {\r\nUS_DEBUGP("Signature mismatch: got %08X, expecting %08X\n",\r\nle32_to_cpu(bcs->Signature),\r\nle32_to_cpu(us->bcs_signature));\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (residue && !(us->fflags & US_FL_IGNORE_RESIDUE)) {\r\nif (bcs->Status == US_BULK_STAT_OK &&\r\nscsi_get_resid(srb) == 0 &&\r\n((srb->cmnd[0] == INQUIRY &&\r\ntransfer_length == 36) ||\r\n(srb->cmnd[0] == READ_CAPACITY &&\r\ntransfer_length == 8))) {\r\nus->fflags |= US_FL_IGNORE_RESIDUE;\r\n} else {\r\nresidue = min(residue, transfer_length);\r\nscsi_set_resid(srb, max(scsi_get_resid(srb),\r\n(int) residue));\r\n}\r\n}\r\nswitch (bcs->Status) {\r\ncase US_BULK_STAT_OK:\r\nif (fake_sense) {\r\nmemcpy(srb->sense_buffer,\r\nusb_stor_sense_invalidCDB,\r\nsizeof(usb_stor_sense_invalidCDB));\r\nreturn USB_STOR_TRANSPORT_NO_SENSE;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\ncase US_BULK_STAT_FAIL:\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\ncase US_BULK_STAT_PHASE:\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nstatic int usb_stor_reset_common(struct us_data *us,\r\nu8 request, u8 requesttype,\r\nu16 value, u16 index, void *data, u16 size)\r\n{\r\nint result;\r\nint result2;\r\nif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\r\nUS_DEBUGP("No reset during disconnect\n");\r\nreturn -EIO;\r\n}\r\nresult = usb_stor_control_msg(us, us->send_ctrl_pipe,\r\nrequest, requesttype, value, index, data, size,\r\n5*HZ);\r\nif (result < 0) {\r\nUS_DEBUGP("Soft reset failed: %d\n", result);\r\nreturn result;\r\n}\r\nwait_event_interruptible_timeout(us->delay_wait,\r\ntest_bit(US_FLIDX_DISCONNECTING, &us->dflags),\r\nHZ*6);\r\nif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\r\nUS_DEBUGP("Reset interrupted by disconnect\n");\r\nreturn -EIO;\r\n}\r\nUS_DEBUGP("Soft reset: clearing bulk-in endpoint halt\n");\r\nresult = usb_stor_clear_halt(us, us->recv_bulk_pipe);\r\nUS_DEBUGP("Soft reset: clearing bulk-out endpoint halt\n");\r\nresult2 = usb_stor_clear_halt(us, us->send_bulk_pipe);\r\nif (result >= 0)\r\nresult = result2;\r\nif (result < 0)\r\nUS_DEBUGP("Soft reset failed\n");\r\nelse\r\nUS_DEBUGP("Soft reset done\n");\r\nreturn result;\r\n}\r\nint usb_stor_CB_reset(struct us_data *us)\r\n{\r\nUS_DEBUGP("%s called\n", __func__);\r\nmemset(us->iobuf, 0xFF, CB_RESET_CMD_SIZE);\r\nus->iobuf[0] = SEND_DIAGNOSTIC;\r\nus->iobuf[1] = 4;\r\nreturn usb_stor_reset_common(us, US_CBI_ADSC,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, us->ifnum, us->iobuf, CB_RESET_CMD_SIZE);\r\n}\r\nint usb_stor_Bulk_reset(struct us_data *us)\r\n{\r\nUS_DEBUGP("%s called\n", __func__);\r\nreturn usb_stor_reset_common(us, US_BULK_RESET_REQUEST,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, us->ifnum, NULL, 0);\r\n}\r\nint usb_stor_port_reset(struct us_data *us)\r\n{\r\nint result;\r\nif (us->pusb_dev->quirks & USB_QUIRK_RESET_MORPHS)\r\nreturn -EPERM;\r\nresult = usb_lock_device_for_reset(us->pusb_dev, us->pusb_intf);\r\nif (result < 0)\r\nUS_DEBUGP("unable to lock device for reset: %d\n", result);\r\nelse {\r\nif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\r\nresult = -EIO;\r\nUS_DEBUGP("No reset during disconnect\n");\r\n} else {\r\nresult = usb_reset_device(us->pusb_dev);\r\nUS_DEBUGP("usb_reset_device returns %d\n",\r\nresult);\r\n}\r\nusb_unlock_device(us->pusb_dev);\r\n}\r\nreturn result;\r\n}
