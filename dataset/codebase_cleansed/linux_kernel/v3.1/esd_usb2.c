static void esd_usb2_rx_event(struct esd_usb2_net_priv *priv,\r\nstruct esd_usb2_msg *msg)\r\n{\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 id = le32_to_cpu(msg->msg.rx.id) & ESD_IDMASK;\r\nif (id == ESD_EV_CAN_ERROR_EXT) {\r\nu8 state = msg->msg.rx.data[0];\r\nu8 ecc = msg->msg.rx.data[1];\r\nu8 txerr = msg->msg.rx.data[2];\r\nu8 rxerr = msg->msg.rx.data[3];\r\nskb = alloc_can_err_skb(priv->netdev, &cf);\r\nif (skb == NULL) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nif (state != priv->old_state) {\r\npriv->old_state = state;\r\nswitch (state & ESD_BUSSTATE_MASK) {\r\ncase ESD_BUSSTATE_BUSOFF:\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\ncan_bus_off(priv->netdev);\r\nbreak;\r\ncase ESD_BUSSTATE_WARN:\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\npriv->can.can_stats.error_warning++;\r\nbreak;\r\ncase ESD_BUSSTATE_ERRPASSIVE:\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\npriv->can.can_stats.error_passive++;\r\nbreak;\r\ndefault:\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nbreak;\r\n}\r\n} else {\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nswitch (ecc & SJA1000_ECC_MASK) {\r\ncase SJA1000_ECC_BIT:\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\nbreak;\r\ncase SJA1000_ECC_FORM:\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase SJA1000_ECC_STUFF:\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ndefault:\r\ncf->data[2] |= CAN_ERR_PROT_UNSPEC;\r\ncf->data[3] = ecc & SJA1000_ECC_SEG;\r\nbreak;\r\n}\r\nif (!(ecc & SJA1000_ECC_DIR))\r\ncf->data[2] |= CAN_ERR_PROT_TX;\r\nif (priv->can.state == CAN_STATE_ERROR_WARNING ||\r\npriv->can.state == CAN_STATE_ERROR_PASSIVE) {\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\nnetif_rx(skb);\r\npriv->bec.txerr = txerr;\r\npriv->bec.rxerr = rxerr;\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\n}\r\nstatic void esd_usb2_rx_can_msg(struct esd_usb2_net_priv *priv,\r\nstruct esd_usb2_msg *msg)\r\n{\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nint i;\r\nu32 id;\r\nif (!netif_device_present(priv->netdev))\r\nreturn;\r\nid = le32_to_cpu(msg->msg.rx.id);\r\nif (id & ESD_EVENT) {\r\nesd_usb2_rx_event(priv, msg);\r\n} else {\r\nskb = alloc_can_skb(priv->netdev, &cf);\r\nif (skb == NULL) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\ncf->can_id = id & ESD_IDMASK;\r\ncf->can_dlc = get_can_dlc(msg->msg.rx.dlc);\r\nif (id & ESD_EXTID)\r\ncf->can_id |= CAN_EFF_FLAG;\r\nif (msg->msg.rx.dlc & ESD_RTR) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nfor (i = 0; i < cf->can_dlc; i++)\r\ncf->data[i] = msg->msg.rx.data[i];\r\n}\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\nreturn;\r\n}\r\nstatic void esd_usb2_tx_done_msg(struct esd_usb2_net_priv *priv,\r\nstruct esd_usb2_msg *msg)\r\n{\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nstruct net_device *netdev = priv->netdev;\r\nstruct esd_tx_urb_context *context;\r\nif (!netif_device_present(netdev))\r\nreturn;\r\ncontext = &priv->tx_contexts[msg->msg.txdone.hnd & (MAX_TX_URBS - 1)];\r\nif (!msg->msg.txdone.status) {\r\nstats->tx_packets++;\r\nstats->tx_bytes += context->dlc;\r\ncan_get_echo_skb(netdev, context->echo_index);\r\n} else {\r\nstats->tx_errors++;\r\ncan_free_echo_skb(netdev, context->echo_index);\r\n}\r\ncontext->echo_index = MAX_TX_URBS;\r\natomic_dec(&priv->active_tx_jobs);\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic void esd_usb2_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct esd_usb2 *dev = urb->context;\r\nint retval;\r\nint pos = 0;\r\nint i;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_info(dev->udev->dev.parent,\r\n"Rx URB aborted (%d)\n", urb->status);\r\ngoto resubmit_urb;\r\n}\r\nwhile (pos < urb->actual_length) {\r\nstruct esd_usb2_msg *msg;\r\nmsg = (struct esd_usb2_msg *)(urb->transfer_buffer + pos);\r\nswitch (msg->msg.hdr.cmd) {\r\ncase CMD_CAN_RX:\r\nesd_usb2_rx_can_msg(dev->nets[msg->msg.rx.net], msg);\r\nbreak;\r\ncase CMD_CAN_TX:\r\nesd_usb2_tx_done_msg(dev->nets[msg->msg.txdone.net],\r\nmsg);\r\nbreak;\r\n}\r\npos += msg->msg.hdr.len << 2;\r\nif (pos > urb->actual_length) {\r\ndev_err(dev->udev->dev.parent, "format error\n");\r\nbreak;\r\n}\r\n}\r\nresubmit_urb:\r\nusb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\r\nurb->transfer_buffer, RX_BUFFER_SIZE,\r\nesd_usb2_read_bulk_callback, dev);\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval == -ENODEV) {\r\nfor (i = 0; i < dev->net_count; i++) {\r\nif (dev->nets[i])\r\nnetif_device_detach(dev->nets[i]->netdev);\r\n}\r\n} else if (retval) {\r\ndev_err(dev->udev->dev.parent,\r\n"failed resubmitting read bulk urb: %d\n", retval);\r\n}\r\nreturn;\r\n}\r\nstatic void esd_usb2_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct esd_tx_urb_context *context = urb->context;\r\nstruct esd_usb2_net_priv *priv;\r\nstruct esd_usb2 *dev;\r\nstruct net_device *netdev;\r\nsize_t size = sizeof(struct esd_usb2_msg);\r\nWARN_ON(!context);\r\npriv = context->priv;\r\nnetdev = priv->netdev;\r\ndev = priv->usb2;\r\nusb_free_coherent(urb->dev, size,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nif (urb->status)\r\ndev_info(netdev->dev.parent, "Tx URB aborted (%d)\n",\r\nurb->status);\r\nnetdev->trans_start = jiffies;\r\n}\r\nstatic ssize_t show_firmware(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(d);\r\nstruct esd_usb2 *dev = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%d.%d.%d\n",\r\n(dev->version >> 12) & 0xf,\r\n(dev->version >> 8) & 0xf,\r\ndev->version & 0xff);\r\n}\r\nstatic ssize_t show_hardware(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(d);\r\nstruct esd_usb2 *dev = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%d.%d.%d\n",\r\n(dev->version >> 28) & 0xf,\r\n(dev->version >> 24) & 0xf,\r\n(dev->version >> 16) & 0xff);\r\n}\r\nstatic ssize_t show_nets(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(d);\r\nstruct esd_usb2 *dev = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%d", dev->net_count);\r\n}\r\nstatic int esd_usb2_send_msg(struct esd_usb2 *dev, struct esd_usb2_msg *msg)\r\n{\r\nint actual_length;\r\nreturn usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev, 2),\r\nmsg,\r\nmsg->msg.hdr.len << 2,\r\n&actual_length,\r\n1000);\r\n}\r\nstatic int esd_usb2_wait_msg(struct esd_usb2 *dev,\r\nstruct esd_usb2_msg *msg)\r\n{\r\nint actual_length;\r\nreturn usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev, 1),\r\nmsg,\r\nsizeof(*msg),\r\n&actual_length,\r\n1000);\r\n}\r\nstatic int esd_usb2_setup_rx_urbs(struct esd_usb2 *dev)\r\n{\r\nint i, err = 0;\r\nif (dev->rxinitdone)\r\nreturn 0;\r\nfor (i = 0; i < MAX_RX_URBS; i++) {\r\nstruct urb *urb = NULL;\r\nu8 *buf = NULL;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_warn(dev->udev->dev.parent,\r\n"No memory left for URBs\n");\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev, RX_BUFFER_SIZE, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\ndev_warn(dev->udev->dev.parent,\r\n"No memory left for USB buffer\n");\r\nerr = -ENOMEM;\r\ngoto freeurb;\r\n}\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_rcvbulkpipe(dev->udev, 1),\r\nbuf, RX_BUFFER_SIZE,\r\nesd_usb2_read_bulk_callback, dev);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &dev->rx_submitted);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(dev->udev, RX_BUFFER_SIZE, buf,\r\nurb->transfer_dma);\r\n}\r\nfreeurb:\r\nusb_free_urb(urb);\r\nif (err)\r\nbreak;\r\n}\r\nif (i == 0) {\r\ndev_err(dev->udev->dev.parent, "couldn't setup read URBs\n");\r\nreturn err;\r\n}\r\nif (i < MAX_RX_URBS) {\r\ndev_warn(dev->udev->dev.parent,\r\n"rx performance may be slow\n");\r\n}\r\ndev->rxinitdone = 1;\r\nreturn 0;\r\n}\r\nstatic int esd_usb2_start(struct esd_usb2_net_priv *priv)\r\n{\r\nstruct esd_usb2 *dev = priv->usb2;\r\nstruct net_device *netdev = priv->netdev;\r\nstruct esd_usb2_msg msg;\r\nint err, i;\r\nmsg.msg.hdr.cmd = CMD_IDADD;\r\nmsg.msg.hdr.len = 2 + ESD_MAX_ID_SEGMENT;\r\nmsg.msg.filter.net = priv->index;\r\nmsg.msg.filter.option = ESD_ID_ENABLE;\r\nfor (i = 0; i < ESD_MAX_ID_SEGMENT; i++)\r\nmsg.msg.filter.mask[i] = cpu_to_le32(0xffffffff);\r\nmsg.msg.filter.mask[ESD_MAX_ID_SEGMENT] = cpu_to_le32(0x00000001);\r\nerr = esd_usb2_send_msg(dev, &msg);\r\nif (err)\r\ngoto failed;\r\nerr = esd_usb2_setup_rx_urbs(dev);\r\nif (err)\r\ngoto failed;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\nfailed:\r\nif (err == -ENODEV)\r\nnetif_device_detach(netdev);\r\ndev_err(netdev->dev.parent, "couldn't start device: %d\n", err);\r\nreturn err;\r\n}\r\nstatic void unlink_all_urbs(struct esd_usb2 *dev)\r\n{\r\nstruct esd_usb2_net_priv *priv;\r\nint i, j;\r\nusb_kill_anchored_urbs(&dev->rx_submitted);\r\nfor (i = 0; i < dev->net_count; i++) {\r\npriv = dev->nets[i];\r\nif (priv) {\r\nusb_kill_anchored_urbs(&priv->tx_submitted);\r\natomic_set(&priv->active_tx_jobs, 0);\r\nfor (j = 0; j < MAX_TX_URBS; j++)\r\npriv->tx_contexts[j].echo_index = MAX_TX_URBS;\r\n}\r\n}\r\n}\r\nstatic int esd_usb2_open(struct net_device *netdev)\r\n{\r\nstruct esd_usb2_net_priv *priv = netdev_priv(netdev);\r\nint err;\r\nerr = open_candev(netdev);\r\nif (err)\r\nreturn err;\r\nerr = esd_usb2_start(priv);\r\nif (err) {\r\ndev_warn(netdev->dev.parent,\r\n"couldn't start device: %d\n", err);\r\nclose_candev(netdev);\r\nreturn err;\r\n}\r\npriv->open_time = jiffies;\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t esd_usb2_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct esd_usb2_net_priv *priv = netdev_priv(netdev);\r\nstruct esd_usb2 *dev = priv->usb2;\r\nstruct esd_tx_urb_context *context = NULL;\r\nstruct net_device_stats *stats = &netdev->stats;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nstruct esd_usb2_msg *msg;\r\nstruct urb *urb;\r\nu8 *buf;\r\nint i, err;\r\nint ret = NETDEV_TX_OK;\r\nsize_t size = sizeof(struct esd_usb2_msg);\r\nif (can_dropped_invalid_skb(netdev, skb))\r\nreturn NETDEV_TX_OK;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\ndev_err(netdev->dev.parent, "No memory left for URBs\n");\r\nstats->tx_dropped++;\r\ndev_kfree_skb(skb);\r\ngoto nourbmem;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\ndev_err(netdev->dev.parent, "No memory left for USB buffer\n");\r\nstats->tx_dropped++;\r\ndev_kfree_skb(skb);\r\ngoto nobufmem;\r\n}\r\nmsg = (struct esd_usb2_msg *)buf;\r\nmsg->msg.hdr.len = 3;\r\nmsg->msg.hdr.cmd = CMD_CAN_TX;\r\nmsg->msg.tx.net = priv->index;\r\nmsg->msg.tx.dlc = cf->can_dlc;\r\nmsg->msg.tx.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nmsg->msg.tx.dlc |= ESD_RTR;\r\nif (cf->can_id & CAN_EFF_FLAG)\r\nmsg->msg.tx.id |= cpu_to_le32(ESD_EXTID);\r\nfor (i = 0; i < cf->can_dlc; i++)\r\nmsg->msg.tx.data[i] = cf->data[i];\r\nmsg->msg.hdr.len += (cf->can_dlc + 3) >> 2;\r\nfor (i = 0; i < MAX_TX_URBS; i++) {\r\nif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\r\ncontext = &priv->tx_contexts[i];\r\nbreak;\r\n}\r\n}\r\nif (!context) {\r\ndev_warn(netdev->dev.parent, "couldn't find free context\n");\r\nret = NETDEV_TX_BUSY;\r\ngoto releasebuf;\r\n}\r\ncontext->priv = priv;\r\ncontext->echo_index = i;\r\ncontext->dlc = cf->can_dlc;\r\nmsg->msg.tx.hnd = 0x80000000 | i;\r\nusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\r\nmsg->msg.hdr.len << 2,\r\nesd_usb2_write_bulk_callback, context);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &priv->tx_submitted);\r\ncan_put_echo_skb(skb, netdev, context->echo_index);\r\natomic_inc(&priv->active_tx_jobs);\r\nif (atomic_read(&priv->active_tx_jobs) >= MAX_TX_URBS)\r\nnetif_stop_queue(netdev);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\ncan_free_echo_skb(netdev, context->echo_index);\r\natomic_dec(&priv->active_tx_jobs);\r\nusb_unanchor_urb(urb);\r\nstats->tx_dropped++;\r\nif (err == -ENODEV)\r\nnetif_device_detach(netdev);\r\nelse\r\ndev_warn(netdev->dev.parent, "failed tx_urb %d\n", err);\r\ngoto releasebuf;\r\n}\r\nnetdev->trans_start = jiffies;\r\nusb_free_urb(urb);\r\nreturn NETDEV_TX_OK;\r\nreleasebuf:\r\nusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\r\nnobufmem:\r\nusb_free_urb(urb);\r\nnourbmem:\r\nreturn ret;\r\n}\r\nstatic int esd_usb2_close(struct net_device *netdev)\r\n{\r\nstruct esd_usb2_net_priv *priv = netdev_priv(netdev);\r\nstruct esd_usb2_msg msg;\r\nint i;\r\nmsg.msg.hdr.cmd = CMD_IDADD;\r\nmsg.msg.hdr.len = 2 + ESD_MAX_ID_SEGMENT;\r\nmsg.msg.filter.net = priv->index;\r\nmsg.msg.filter.option = ESD_ID_ENABLE;\r\nfor (i = 0; i <= ESD_MAX_ID_SEGMENT; i++)\r\nmsg.msg.filter.mask[i] = 0;\r\nif (esd_usb2_send_msg(priv->usb2, &msg) < 0)\r\ndev_err(netdev->dev.parent, "sending idadd message failed\n");\r\nmsg.msg.hdr.len = 2;\r\nmsg.msg.hdr.cmd = CMD_SETBAUD;\r\nmsg.msg.setbaud.net = priv->index;\r\nmsg.msg.setbaud.rsvd = 0;\r\nmsg.msg.setbaud.baud = cpu_to_le32(ESD_USB2_NO_BAUDRATE);\r\nif (esd_usb2_send_msg(priv->usb2, &msg) < 0)\r\ndev_err(netdev->dev.parent, "sending setbaud message failed\n");\r\npriv->can.state = CAN_STATE_STOPPED;\r\nnetif_stop_queue(netdev);\r\nclose_candev(netdev);\r\npriv->open_time = 0;\r\nreturn 0;\r\n}\r\nstatic int esd_usb2_set_bittiming(struct net_device *netdev)\r\n{\r\nstruct esd_usb2_net_priv *priv = netdev_priv(netdev);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nstruct esd_usb2_msg msg;\r\nu32 canbtr;\r\ncanbtr = ESD_USB2_UBR;\r\ncanbtr |= (bt->brp - 1) & (ESD_USB2_BRP_MAX - 1);\r\ncanbtr |= ((bt->sjw - 1) & (ESD_USB2_SJW_MAX - 1))\r\n<< ESD_USB2_SJW_SHIFT;\r\ncanbtr |= ((bt->prop_seg + bt->phase_seg1 - 1)\r\n& (ESD_USB2_TSEG1_MAX - 1))\r\n<< ESD_USB2_TSEG1_SHIFT;\r\ncanbtr |= ((bt->phase_seg2 - 1) & (ESD_USB2_TSEG2_MAX - 1))\r\n<< ESD_USB2_TSEG2_SHIFT;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\ncanbtr |= ESD_USB2_3_SAMPLES;\r\nmsg.msg.hdr.len = 2;\r\nmsg.msg.hdr.cmd = CMD_SETBAUD;\r\nmsg.msg.setbaud.net = priv->index;\r\nmsg.msg.setbaud.rsvd = 0;\r\nmsg.msg.setbaud.baud = cpu_to_le32(canbtr);\r\ndev_info(netdev->dev.parent, "setting BTR=%#x\n", canbtr);\r\nreturn esd_usb2_send_msg(priv->usb2, &msg);\r\n}\r\nstatic int esd_usb2_get_berr_counter(const struct net_device *netdev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct esd_usb2_net_priv *priv = netdev_priv(netdev);\r\nbec->txerr = priv->bec.txerr;\r\nbec->rxerr = priv->bec.rxerr;\r\nreturn 0;\r\n}\r\nstatic int esd_usb2_set_mode(struct net_device *netdev, enum can_mode mode)\r\n{\r\nstruct esd_usb2_net_priv *priv = netdev_priv(netdev);\r\nif (!priv->open_time)\r\nreturn -EINVAL;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nnetif_wake_queue(netdev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int esd_usb2_probe_one_net(struct usb_interface *intf, int index)\r\n{\r\nstruct esd_usb2 *dev = usb_get_intfdata(intf);\r\nstruct net_device *netdev;\r\nstruct esd_usb2_net_priv *priv;\r\nint err = 0;\r\nint i;\r\nnetdev = alloc_candev(sizeof(*priv), MAX_TX_URBS);\r\nif (!netdev) {\r\ndev_err(&intf->dev, "couldn't alloc candev\n");\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\npriv = netdev_priv(netdev);\r\ninit_usb_anchor(&priv->tx_submitted);\r\natomic_set(&priv->active_tx_jobs, 0);\r\nfor (i = 0; i < MAX_TX_URBS; i++)\r\npriv->tx_contexts[i].echo_index = MAX_TX_URBS;\r\npriv->usb2 = dev;\r\npriv->netdev = netdev;\r\npriv->index = index;\r\npriv->can.state = CAN_STATE_STOPPED;\r\npriv->can.clock.freq = ESD_USB2_CAN_CLOCK;\r\npriv->can.bittiming_const = &esd_usb2_bittiming_const;\r\npriv->can.do_set_bittiming = esd_usb2_set_bittiming;\r\npriv->can.do_set_mode = esd_usb2_set_mode;\r\npriv->can.do_get_berr_counter = esd_usb2_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\nnetdev->flags |= IFF_ECHO;\r\nnetdev->netdev_ops = &esd_usb2_netdev_ops;\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nerr = register_candev(netdev);\r\nif (err) {\r\ndev_err(&intf->dev,\r\n"couldn't register CAN device: %d\n", err);\r\nfree_candev(netdev);\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\ndev->nets[index] = priv;\r\ndev_info(netdev->dev.parent, "device %s registered\n", netdev->name);\r\ndone:\r\nreturn err;\r\n}\r\nstatic int esd_usb2_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct esd_usb2 *dev;\r\nstruct esd_usb2_msg msg;\r\nint i, err;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\ndev->udev = interface_to_usbdev(intf);\r\ninit_usb_anchor(&dev->rx_submitted);\r\nusb_set_intfdata(intf, dev);\r\nmsg.msg.hdr.cmd = CMD_VERSION;\r\nmsg.msg.hdr.len = 2;\r\nmsg.msg.version.rsvd = 0;\r\nmsg.msg.version.flags = 0;\r\nmsg.msg.version.drv_version = 0;\r\nerr = esd_usb2_send_msg(dev, &msg);\r\nif (err < 0) {\r\ndev_err(&intf->dev, "sending version message failed\n");\r\ngoto free_dev;\r\n}\r\nerr = esd_usb2_wait_msg(dev, &msg);\r\nif (err < 0) {\r\ndev_err(&intf->dev, "no version message answer\n");\r\ngoto free_dev;\r\n}\r\ndev->net_count = (int)msg.msg.version_reply.nets;\r\ndev->version = le32_to_cpu(msg.msg.version_reply.version);\r\nif (device_create_file(&intf->dev, &dev_attr_firmware))\r\ndev_err(&intf->dev,\r\n"Couldn't create device file for firmware\n");\r\nif (device_create_file(&intf->dev, &dev_attr_hardware))\r\ndev_err(&intf->dev,\r\n"Couldn't create device file for hardware\n");\r\nif (device_create_file(&intf->dev, &dev_attr_nets))\r\ndev_err(&intf->dev,\r\n"Couldn't create device file for nets\n");\r\nfor (i = 0; i < dev->net_count; i++)\r\nesd_usb2_probe_one_net(intf, i);\r\nreturn 0;\r\nfree_dev:\r\nkfree(dev);\r\ndone:\r\nreturn err;\r\n}\r\nstatic void esd_usb2_disconnect(struct usb_interface *intf)\r\n{\r\nstruct esd_usb2 *dev = usb_get_intfdata(intf);\r\nstruct net_device *netdev;\r\nint i;\r\ndevice_remove_file(&intf->dev, &dev_attr_firmware);\r\ndevice_remove_file(&intf->dev, &dev_attr_hardware);\r\ndevice_remove_file(&intf->dev, &dev_attr_nets);\r\nusb_set_intfdata(intf, NULL);\r\nif (dev) {\r\nfor (i = 0; i < dev->net_count; i++) {\r\nif (dev->nets[i]) {\r\nnetdev = dev->nets[i]->netdev;\r\nunregister_netdev(netdev);\r\nfree_candev(netdev);\r\n}\r\n}\r\nunlink_all_urbs(dev);\r\n}\r\n}\r\nstatic int __init esd_usb2_init(void)\r\n{\r\nint err;\r\nerr = usb_register(&esd_usb2_driver);\r\nif (err) {\r\nerr("usb_register failed. Error number %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit esd_usb2_exit(void)\r\n{\r\nusb_deregister(&esd_usb2_driver);\r\n}
