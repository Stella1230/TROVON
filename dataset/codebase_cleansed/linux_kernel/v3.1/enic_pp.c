static int enic_set_port_profile(struct enic *enic)\r\n{\r\nstruct net_device *netdev = enic->netdev;\r\nstruct vic_provinfo *vp;\r\nconst u8 oui[3] = VIC_PROVINFO_CISCO_OUI;\r\nconst u16 os_type = htons(VIC_GENERIC_PROV_OS_TYPE_LINUX);\r\nchar uuid_str[38];\r\nchar client_mac_str[18];\r\nu8 *client_mac;\r\nint err;\r\nif (!(enic->pp.set & ENIC_SET_NAME) || !strlen(enic->pp.name))\r\nreturn -EINVAL;\r\nvp = vic_provinfo_alloc(GFP_KERNEL, oui,\r\nVIC_PROVINFO_GENERIC_TYPE);\r\nif (!vp)\r\nreturn -ENOMEM;\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_PORT_PROFILE_NAME_STR,\r\nstrlen(enic->pp.name) + 1, enic->pp.name);\r\nif (!is_zero_ether_addr(enic->pp.mac_addr))\r\nclient_mac = enic->pp.mac_addr;\r\nelse\r\nclient_mac = netdev->dev_addr;\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_CLIENT_MAC_ADDR,\r\nETH_ALEN, client_mac);\r\nsnprintf(client_mac_str, sizeof(client_mac_str), "%pM", client_mac);\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_CLUSTER_PORT_UUID_STR,\r\nsizeof(client_mac_str), client_mac_str);\r\nif (enic->pp.set & ENIC_SET_INSTANCE) {\r\nsprintf(uuid_str, "%pUB", enic->pp.instance_uuid);\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_CLIENT_UUID_STR,\r\nsizeof(uuid_str), uuid_str);\r\n}\r\nif (enic->pp.set & ENIC_SET_HOST) {\r\nsprintf(uuid_str, "%pUB", enic->pp.host_uuid);\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_HOST_UUID_STR,\r\nsizeof(uuid_str), uuid_str);\r\n}\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_OS_TYPE,\r\nsizeof(os_type), &os_type);\r\nerr = enic_dev_status_to_errno(enic_dev_init_prov2(enic, vp));\r\nadd_tlv_failure:\r\nvic_provinfo_free(vp);\r\nreturn err;\r\n}\r\nstatic int enic_unset_port_profile(struct enic *enic)\r\n{\r\nint err;\r\nerr = enic_vnic_dev_deinit(enic);\r\nif (err)\r\nreturn enic_dev_status_to_errno(err);\r\nenic_reset_addr_lists(enic);\r\nreturn 0;\r\n}\r\nstatic int enic_are_pp_different(struct enic_port_profile *pp1,\r\nstruct enic_port_profile *pp2)\r\n{\r\nreturn strcmp(pp1->name, pp2->name) | !!memcmp(pp1->instance_uuid,\r\npp2->instance_uuid, PORT_UUID_MAX) |\r\n!!memcmp(pp1->host_uuid, pp2->host_uuid, PORT_UUID_MAX) |\r\n!!memcmp(pp1->mac_addr, pp2->mac_addr, ETH_ALEN);\r\n}\r\nstatic int enic_pp_preassociate(struct enic *enic,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int enic_pp_disassociate(struct enic *enic,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nreturn enic_unset_port_profile(enic);\r\n}\r\nstatic int enic_pp_preassociate_rr(struct enic *enic,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nint err;\r\nint active = 0;\r\nif (enic->pp.request != PORT_REQUEST_ASSOCIATE) {\r\nerr = enic_pp_handlers[PORT_REQUEST_DISASSOCIATE](enic,\r\nprev_pp, restore_pp);\r\nif (err)\r\nreturn err;\r\n*restore_pp = 0;\r\n}\r\n*restore_pp = 0;\r\nerr = enic_set_port_profile(enic);\r\nif (err)\r\nreturn err;\r\nif (enic->pp.request != PORT_REQUEST_ASSOCIATE)\r\nerr = enic_dev_status_to_errno(enic_dev_enable2(enic, active));\r\nreturn err;\r\n}\r\nstatic int enic_pp_associate(struct enic *enic,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nint err;\r\nint active = 1;\r\nif (prev_pp->request != PORT_REQUEST_PREASSOCIATE_RR ||\r\n(prev_pp->request == PORT_REQUEST_PREASSOCIATE_RR &&\r\nenic_are_pp_different(prev_pp, &enic->pp))) {\r\nerr = enic_pp_handlers[PORT_REQUEST_DISASSOCIATE](\r\nenic, prev_pp, restore_pp);\r\nif (err)\r\nreturn err;\r\n*restore_pp = 0;\r\n}\r\nerr = enic_pp_handlers[PORT_REQUEST_PREASSOCIATE_RR](\r\nenic, prev_pp, restore_pp);\r\nif (err)\r\nreturn err;\r\n*restore_pp = 0;\r\nreturn enic_dev_status_to_errno(enic_dev_enable2(enic, active));\r\n}\r\nint enic_process_set_pp_request(struct enic *enic,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nif (enic->pp.request < enic_pp_handlers_count\r\n&& enic_pp_handlers[enic->pp.request])\r\nreturn enic_pp_handlers[enic->pp.request](enic,\r\nprev_pp, restore_pp);\r\nelse\r\nreturn -EOPNOTSUPP;\r\n}\r\nint enic_process_get_pp_request(struct enic *enic, int request,\r\nu16 *response)\r\n{\r\nint err, status = ERR_SUCCESS;\r\nswitch (request) {\r\ncase PORT_REQUEST_PREASSOCIATE_RR:\r\ncase PORT_REQUEST_ASSOCIATE:\r\nerr = enic_dev_enable2_done(enic, &status);\r\nbreak;\r\ncase PORT_REQUEST_DISASSOCIATE:\r\nerr = enic_dev_deinit_done(enic, &status);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (err)\r\nstatus = err;\r\nswitch (status) {\r\ncase ERR_SUCCESS:\r\n*response = PORT_PROFILE_RESPONSE_SUCCESS;\r\nbreak;\r\ncase ERR_EINVAL:\r\n*response = PORT_PROFILE_RESPONSE_INVALID;\r\nbreak;\r\ncase ERR_EBADSTATE:\r\n*response = PORT_PROFILE_RESPONSE_BADSTATE;\r\nbreak;\r\ncase ERR_ENOMEM:\r\n*response = PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES;\r\nbreak;\r\ncase ERR_EINPROGRESS:\r\n*response = PORT_PROFILE_RESPONSE_INPROGRESS;\r\nbreak;\r\ndefault:\r\n*response = PORT_PROFILE_RESPONSE_ERROR;\r\nbreak;\r\n}\r\nreturn 0;\r\n}
