static int dm_read(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nvoid *buf;\r\nint err = -ENOMEM;\r\nnetdev_dbg(dev->net, "dm_read() reg=0x%02x length=%d\n", reg, length);\r\nbuf = kmalloc(length, GFP_KERNEL);\r\nif (!buf)\r\ngoto out;\r\nerr = usb_control_msg(dev->udev,\r\nusb_rcvctrlpipe(dev->udev, 0),\r\nDM_READ_REGS,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, reg, buf, length, USB_CTRL_SET_TIMEOUT);\r\nif (err == length)\r\nmemcpy(data, buf, length);\r\nelse if (err >= 0)\r\nerr = -EINVAL;\r\nkfree(buf);\r\nout:\r\nreturn err;\r\n}\r\nstatic int dm_read_reg(struct usbnet *dev, u8 reg, u8 *value)\r\n{\r\nreturn dm_read(dev, reg, 1, value);\r\n}\r\nstatic int dm_write(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nvoid *buf = NULL;\r\nint err = -ENOMEM;\r\nnetdev_dbg(dev->net, "dm_write() reg=0x%02x, length=%d\n", reg, length);\r\nif (data) {\r\nbuf = kmemdup(data, length, GFP_KERNEL);\r\nif (!buf)\r\ngoto out;\r\n}\r\nerr = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\nDM_WRITE_REGS,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |USB_RECIP_DEVICE,\r\n0, reg, buf, length, USB_CTRL_SET_TIMEOUT);\r\nkfree(buf);\r\nif (err >= 0 && err < length)\r\nerr = -EINVAL;\r\nout:\r\nreturn err;\r\n}\r\nstatic int dm_write_reg(struct usbnet *dev, u8 reg, u8 value)\r\n{\r\nnetdev_dbg(dev->net, "dm_write_reg() reg=0x%02x, value=0x%02x\n",\r\nreg, value);\r\nreturn usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\nDM_WRITE_REG,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |USB_RECIP_DEVICE,\r\nvalue, reg, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\n}\r\nstatic void dm_write_async_callback(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;\r\nint status = urb->status;\r\nif (status < 0)\r\nprintk(KERN_DEBUG "dm_write_async_callback() failed with %d\n",\r\nstatus);\r\nkfree(req);\r\nusb_free_urb(urb);\r\n}\r\nstatic void dm_write_async_helper(struct usbnet *dev, u8 reg, u8 value,\r\nu16 length, void *data)\r\n{\r\nstruct usb_ctrlrequest *req;\r\nstruct urb *urb;\r\nint status;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_err(dev->net, "Error allocating URB in dm_write_async_helper!\n");\r\nreturn;\r\n}\r\nreq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\r\nif (!req) {\r\nnetdev_err(dev->net, "Failed to allocate memory for control request\n");\r\nusb_free_urb(urb);\r\nreturn;\r\n}\r\nreq->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;\r\nreq->bRequest = length ? DM_WRITE_REGS : DM_WRITE_REG;\r\nreq->wValue = cpu_to_le16(value);\r\nreq->wIndex = cpu_to_le16(reg);\r\nreq->wLength = cpu_to_le16(length);\r\nusb_fill_control_urb(urb, dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n(void *)req, data, length,\r\ndm_write_async_callback, req);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status < 0) {\r\nnetdev_err(dev->net, "Error submitting the control message: status=%d\n",\r\nstatus);\r\nkfree(req);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nstatic void dm_write_async(struct usbnet *dev, u8 reg, u16 length, void *data)\r\n{\r\nnetdev_dbg(dev->net, "dm_write_async() reg=0x%02x length=%d\n", reg, length);\r\ndm_write_async_helper(dev, reg, 0, length, data);\r\n}\r\nstatic void dm_write_reg_async(struct usbnet *dev, u8 reg, u8 value)\r\n{\r\nnetdev_dbg(dev->net, "dm_write_reg_async() reg=0x%02x value=0x%02x\n",\r\nreg, value);\r\ndm_write_async_helper(dev, reg, value, 0, NULL);\r\n}\r\nstatic int dm_read_shared_word(struct usbnet *dev, int phy, u8 reg, __le16 *value)\r\n{\r\nint ret, i;\r\nmutex_lock(&dev->phy_mutex);\r\ndm_write_reg(dev, DM_SHARED_ADDR, phy ? (reg | 0x40) : reg);\r\ndm_write_reg(dev, DM_SHARED_CTRL, phy ? 0xc : 0x4);\r\nfor (i = 0; i < DM_TIMEOUT; i++) {\r\nu8 tmp;\r\nudelay(1);\r\nret = dm_read_reg(dev, DM_SHARED_CTRL, &tmp);\r\nif (ret < 0)\r\ngoto out;\r\nif ((tmp & 1) == 0)\r\nbreak;\r\n}\r\nif (i == DM_TIMEOUT) {\r\nnetdev_err(dev->net, "%s read timed out!\n", phy ? "phy" : "eeprom");\r\nret = -EIO;\r\ngoto out;\r\n}\r\ndm_write_reg(dev, DM_SHARED_CTRL, 0x0);\r\nret = dm_read(dev, DM_SHARED_DATA, 2, value);\r\nnetdev_dbg(dev->net, "read shared %d 0x%02x returned 0x%04x, %d\n",\r\nphy, reg, *value, ret);\r\nout:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int dm_write_shared_word(struct usbnet *dev, int phy, u8 reg, __le16 value)\r\n{\r\nint ret, i;\r\nmutex_lock(&dev->phy_mutex);\r\nret = dm_write(dev, DM_SHARED_DATA, 2, &value);\r\nif (ret < 0)\r\ngoto out;\r\ndm_write_reg(dev, DM_SHARED_ADDR, phy ? (reg | 0x40) : reg);\r\ndm_write_reg(dev, DM_SHARED_CTRL, phy ? 0x1a : 0x12);\r\nfor (i = 0; i < DM_TIMEOUT; i++) {\r\nu8 tmp;\r\nudelay(1);\r\nret = dm_read_reg(dev, DM_SHARED_CTRL, &tmp);\r\nif (ret < 0)\r\ngoto out;\r\nif ((tmp & 1) == 0)\r\nbreak;\r\n}\r\nif (i == DM_TIMEOUT) {\r\nnetdev_err(dev->net, "%s write timed out!\n", phy ? "phy" : "eeprom");\r\nret = -EIO;\r\ngoto out;\r\n}\r\ndm_write_reg(dev, DM_SHARED_CTRL, 0x0);\r\nout:\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int dm_read_eeprom_word(struct usbnet *dev, u8 offset, void *value)\r\n{\r\nreturn dm_read_shared_word(dev, 0, offset, value);\r\n}\r\nstatic int dm9601_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn DM_EEPROM_LEN;\r\n}\r\nstatic int dm9601_get_eeprom(struct net_device *net,\r\nstruct ethtool_eeprom *eeprom, u8 * data)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\n__le16 *ebuf = (__le16 *) data;\r\nint i;\r\nif ((eeprom->offset % 2) || (eeprom->len % 2))\r\nreturn -EINVAL;\r\nfor (i = 0; i < eeprom->len / 2; i++) {\r\nif (dm_read_eeprom_word(dev, eeprom->offset / 2 + i,\r\n&ebuf[i]) < 0)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dm9601_mdio_read(struct net_device *netdev, int phy_id, int loc)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 res;\r\nif (phy_id) {\r\nnetdev_dbg(dev->net, "Only internal phy supported\n");\r\nreturn 0;\r\n}\r\ndm_read_shared_word(dev, 1, loc, &res);\r\nnetdev_dbg(dev->net,\r\n"dm9601_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\n",\r\nphy_id, loc, le16_to_cpu(res));\r\nreturn le16_to_cpu(res);\r\n}\r\nstatic void dm9601_mdio_write(struct net_device *netdev, int phy_id, int loc,\r\nint val)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\n__le16 res = cpu_to_le16(val);\r\nif (phy_id) {\r\nnetdev_dbg(dev->net, "Only internal phy supported\n");\r\nreturn;\r\n}\r\nnetdev_dbg(dev->net, "dm9601_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\n",\r\nphy_id, loc, val);\r\ndm_write_shared_word(dev, 1, loc, res);\r\n}\r\nstatic void dm9601_get_drvinfo(struct net_device *net,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nusbnet_get_drvinfo(net, info);\r\ninfo->eedump_len = DM_EEPROM_LEN;\r\n}\r\nstatic u32 dm9601_get_link(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn mii_link_ok(&dev->mii);\r\n}\r\nstatic int dm9601_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic void dm9601_set_multicast(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu8 *hashes = (u8 *) & dev->data;\r\nu8 rx_ctl = 0x31;\r\nmemset(hashes, 0x00, DM_MCAST_SIZE);\r\nhashes[DM_MCAST_SIZE - 1] |= 0x80;\r\nif (net->flags & IFF_PROMISC) {\r\nrx_ctl |= 0x02;\r\n} else if (net->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(net) > DM_MAX_MCAST) {\r\nrx_ctl |= 0x04;\r\n} else if (!netdev_mc_empty(net)) {\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, net) {\r\nu32 crc = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nhashes[crc >> 3] |= 1 << (crc & 0x7);\r\n}\r\n}\r\ndm_write_async(dev, DM_MCAST_ADDR, DM_MCAST_SIZE, hashes);\r\ndm_write_reg_async(dev, DM_RX_CTRL, rx_ctl);\r\n}\r\nstatic void __dm9601_set_mac_address(struct usbnet *dev)\r\n{\r\ndm_write_async(dev, DM_PHY_ADDR, ETH_ALEN, dev->net->dev_addr);\r\n}\r\nstatic int dm9601_set_mac_address(struct net_device *net, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct usbnet *dev = netdev_priv(net);\r\nif (!is_valid_ether_addr(addr->sa_data)) {\r\ndev_err(&net->dev, "not setting invalid mac address %pM\n",\r\naddr->sa_data);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(net->dev_addr, addr->sa_data, net->addr_len);\r\n__dm9601_set_mac_address(dev);\r\nreturn 0;\r\n}\r\nstatic int dm9601_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret;\r\nu8 mac[ETH_ALEN];\r\nret = usbnet_get_endpoints(dev, intf);\r\nif (ret)\r\ngoto out;\r\ndev->net->netdev_ops = &dm9601_netdev_ops;\r\ndev->net->ethtool_ops = &dm9601_ethtool_ops;\r\ndev->net->hard_header_len += DM_TX_OVERHEAD;\r\ndev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\r\ndev->rx_urb_size = dev->net->mtu + ETH_HLEN + DM_RX_OVERHEAD;\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = dm9601_mdio_read;\r\ndev->mii.mdio_write = dm9601_mdio_write;\r\ndev->mii.phy_id_mask = 0x1f;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndm_write_reg(dev, DM_NET_CTRL, 1);\r\nudelay(20);\r\nif (dm_read(dev, DM_PHY_ADDR, ETH_ALEN, mac) < 0) {\r\nprintk(KERN_ERR "Error reading MAC address\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (is_valid_ether_addr(mac))\r\nmemcpy(dev->net->dev_addr, mac, ETH_ALEN);\r\nelse {\r\nprintk(KERN_WARNING\r\n"dm9601: No valid MAC address in EEPROM, using %pM\n",\r\ndev->net->dev_addr);\r\n__dm9601_set_mac_address(dev);\r\n}\r\ndm_write_reg(dev, DM_GPR_CTRL, 1);\r\ndm_write_reg(dev, DM_GPR_DATA, 0);\r\ndm9601_set_multicast(dev->net);\r\ndm9601_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\r\ndm9601_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\r\nADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\r\nmii_nway_restart(&dev->mii);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int dm9601_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nu8 status;\r\nint len;\r\nif (unlikely(skb->len < DM_RX_OVERHEAD)) {\r\ndev_err(&dev->udev->dev, "unexpected tiny rx frame\n");\r\nreturn 0;\r\n}\r\nstatus = skb->data[0];\r\nlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\r\nif (unlikely(status & 0xbf)) {\r\nif (status & 0x01) dev->net->stats.rx_fifo_errors++;\r\nif (status & 0x02) dev->net->stats.rx_crc_errors++;\r\nif (status & 0x04) dev->net->stats.rx_frame_errors++;\r\nif (status & 0x20) dev->net->stats.rx_missed_errors++;\r\nif (status & 0x90) dev->net->stats.rx_length_errors++;\r\nreturn 0;\r\n}\r\nskb_pull(skb, 3);\r\nskb_trim(skb, len);\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *dm9601_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\r\ngfp_t flags)\r\n{\r\nint len;\r\nlen = skb->len;\r\nif (skb_headroom(skb) < DM_TX_OVERHEAD) {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_copy_expand(skb, DM_TX_OVERHEAD, 0, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\n__skb_push(skb, DM_TX_OVERHEAD);\r\nif ((skb->len % dev->maxpacket) == 0)\r\nlen++;\r\nskb->data[0] = len;\r\nskb->data[1] = len >> 8;\r\nreturn skb;\r\n}\r\nstatic void dm9601_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nint link;\r\nu8 *buf;\r\nif (urb->actual_length < 8)\r\nreturn;\r\nbuf = urb->transfer_buffer;\r\nlink = !!(buf[0] & 0x40);\r\nif (netif_carrier_ok(dev->net) != link) {\r\nif (link) {\r\nnetif_carrier_on(dev->net);\r\nusbnet_defer_kevent (dev, EVENT_LINK_RESET);\r\n}\r\nelse\r\nnetif_carrier_off(dev->net);\r\nnetdev_dbg(dev->net, "Link Status is: %d\n", link);\r\n}\r\n}\r\nstatic int dm9601_link_reset(struct usbnet *dev)\r\n{\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nmii_check_media(&dev->mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nnetdev_dbg(dev->net, "link_reset() speed: %u duplex: %d\n",\r\nethtool_cmd_speed(&ecmd), ecmd.duplex);\r\nreturn 0;\r\n}\r\nstatic int __init dm9601_init(void)\r\n{\r\nreturn usb_register(&dm9601_driver);\r\n}\r\nstatic void __exit dm9601_exit(void)\r\n{\r\nusb_deregister(&dm9601_driver);\r\n}
