static bool tproxy_sk_is_transparent(struct sock *sk)\r\n{\r\nif (sk->sk_state != TCP_TIME_WAIT) {\r\nif (inet_sk(sk)->transparent)\r\nreturn true;\r\nsock_put(sk);\r\n} else {\r\nif (inet_twsk(sk)->tw_transparent)\r\nreturn true;\r\ninet_twsk_put(inet_twsk(sk));\r\n}\r\nreturn false;\r\n}\r\nstatic inline __be32\r\ntproxy_laddr4(struct sk_buff *skb, __be32 user_laddr, __be32 daddr)\r\n{\r\nstruct in_device *indev;\r\n__be32 laddr;\r\nif (user_laddr)\r\nreturn user_laddr;\r\nladdr = 0;\r\nrcu_read_lock();\r\nindev = __in_dev_get_rcu(skb->dev);\r\nfor_primary_ifa(indev) {\r\nladdr = ifa->ifa_local;\r\nbreak;\r\n} endfor_ifa(indev);\r\nrcu_read_unlock();\r\nreturn laddr ? laddr : daddr;\r\n}\r\nstatic struct sock *\r\ntproxy_handle_time_wait4(struct sk_buff *skb, __be32 laddr, __be16 lport,\r\nstruct sock *sk)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct tcphdr _hdr, *hp;\r\nhp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\ninet_twsk_put(inet_twsk(sk));\r\nreturn NULL;\r\n}\r\nif (hp->syn && !hp->rst && !hp->ack && !hp->fin) {\r\nstruct sock *sk2;\r\nsk2 = nf_tproxy_get_sock_v4(dev_net(skb->dev), iph->protocol,\r\niph->saddr, laddr ? laddr : iph->daddr,\r\nhp->source, lport ? lport : hp->dest,\r\nskb->dev, NFT_LOOKUP_LISTENER);\r\nif (sk2) {\r\ninet_twsk_deschedule(inet_twsk(sk), &tcp_death_row);\r\ninet_twsk_put(inet_twsk(sk));\r\nsk = sk2;\r\n}\r\n}\r\nreturn sk;\r\n}\r\nstatic unsigned int\r\ntproxy_tg4(struct sk_buff *skb, __be32 laddr, __be16 lport,\r\nu_int32_t mark_mask, u_int32_t mark_value)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct udphdr _hdr, *hp;\r\nstruct sock *sk;\r\nhp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn NF_DROP;\r\nsk = nf_tproxy_get_sock_v4(dev_net(skb->dev), iph->protocol,\r\niph->saddr, iph->daddr,\r\nhp->source, hp->dest,\r\nskb->dev, NFT_LOOKUP_ESTABLISHED);\r\nladdr = tproxy_laddr4(skb, laddr, iph->daddr);\r\nif (!lport)\r\nlport = hp->dest;\r\nif (sk && sk->sk_state == TCP_TIME_WAIT)\r\nsk = tproxy_handle_time_wait4(skb, laddr, lport, sk);\r\nelse if (!sk)\r\nsk = nf_tproxy_get_sock_v4(dev_net(skb->dev), iph->protocol,\r\niph->saddr, laddr,\r\nhp->source, lport,\r\nskb->dev, NFT_LOOKUP_LISTENER);\r\nif (sk && tproxy_sk_is_transparent(sk)) {\r\nskb->mark = (skb->mark & ~mark_mask) ^ mark_value;\r\npr_debug("redirecting: proto %hhu %pI4:%hu -> %pI4:%hu, mark: %x\n",\r\niph->protocol, &iph->daddr, ntohs(hp->dest),\r\n&laddr, ntohs(lport), skb->mark);\r\nnf_tproxy_assign_sock(skb, sk);\r\nreturn NF_ACCEPT;\r\n}\r\npr_debug("no socket, dropping: proto %hhu %pI4:%hu -> %pI4:%hu, mark: %x\n",\r\niph->protocol, &iph->saddr, ntohs(hp->source),\r\n&iph->daddr, ntohs(hp->dest), skb->mark);\r\nreturn NF_DROP;\r\n}\r\nstatic unsigned int\r\ntproxy_tg4_v0(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_tproxy_target_info *tgi = par->targinfo;\r\nreturn tproxy_tg4(skb, tgi->laddr, tgi->lport, tgi->mark_mask, tgi->mark_value);\r\n}\r\nstatic unsigned int\r\ntproxy_tg4_v1(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\r\nreturn tproxy_tg4(skb, tgi->laddr.ip, tgi->lport, tgi->mark_mask, tgi->mark_value);\r\n}\r\nstatic inline const struct in6_addr *\r\ntproxy_laddr6(struct sk_buff *skb, const struct in6_addr *user_laddr,\r\nconst struct in6_addr *daddr)\r\n{\r\nstruct inet6_dev *indev;\r\nstruct inet6_ifaddr *ifa;\r\nstruct in6_addr *laddr;\r\nif (!ipv6_addr_any(user_laddr))\r\nreturn user_laddr;\r\nladdr = NULL;\r\nrcu_read_lock();\r\nindev = __in6_dev_get(skb->dev);\r\nif (indev)\r\nlist_for_each_entry(ifa, &indev->addr_list, if_list) {\r\nif (ifa->flags & (IFA_F_TENTATIVE | IFA_F_DEPRECATED))\r\ncontinue;\r\nladdr = &ifa->addr;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn laddr ? laddr : daddr;\r\n}\r\nstatic struct sock *\r\ntproxy_handle_time_wait6(struct sk_buff *skb, int tproto, int thoff,\r\nconst struct xt_action_param *par,\r\nstruct sock *sk)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct tcphdr _hdr, *hp;\r\nconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\r\nhp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\ninet_twsk_put(inet_twsk(sk));\r\nreturn NULL;\r\n}\r\nif (hp->syn && !hp->rst && !hp->ack && !hp->fin) {\r\nstruct sock *sk2;\r\nsk2 = nf_tproxy_get_sock_v6(dev_net(skb->dev), tproto,\r\n&iph->saddr,\r\ntproxy_laddr6(skb, &tgi->laddr.in6, &iph->daddr),\r\nhp->source,\r\ntgi->lport ? tgi->lport : hp->dest,\r\nskb->dev, NFT_LOOKUP_LISTENER);\r\nif (sk2) {\r\ninet_twsk_deschedule(inet_twsk(sk), &tcp_death_row);\r\ninet_twsk_put(inet_twsk(sk));\r\nsk = sk2;\r\n}\r\n}\r\nreturn sk;\r\n}\r\nstatic unsigned int\r\ntproxy_tg6_v1(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\r\nstruct udphdr _hdr, *hp;\r\nstruct sock *sk;\r\nconst struct in6_addr *laddr;\r\n__be16 lport;\r\nint thoff;\r\nint tproto;\r\ntproto = ipv6_find_hdr(skb, &thoff, -1, NULL);\r\nif (tproto < 0) {\r\npr_debug("unable to find transport header in IPv6 packet, dropping\n");\r\nreturn NF_DROP;\r\n}\r\nhp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\npr_debug("unable to grab transport header contents in IPv6 packet, dropping\n");\r\nreturn NF_DROP;\r\n}\r\nsk = nf_tproxy_get_sock_v6(dev_net(skb->dev), tproto,\r\n&iph->saddr, &iph->daddr,\r\nhp->source, hp->dest,\r\npar->in, NFT_LOOKUP_ESTABLISHED);\r\nladdr = tproxy_laddr6(skb, &tgi->laddr.in6, &iph->daddr);\r\nlport = tgi->lport ? tgi->lport : hp->dest;\r\nif (sk && sk->sk_state == TCP_TIME_WAIT)\r\nsk = tproxy_handle_time_wait6(skb, tproto, thoff, par, sk);\r\nelse if (!sk)\r\nsk = nf_tproxy_get_sock_v6(dev_net(skb->dev), tproto,\r\n&iph->saddr, laddr,\r\nhp->source, lport,\r\npar->in, NFT_LOOKUP_LISTENER);\r\nif (sk && tproxy_sk_is_transparent(sk)) {\r\nskb->mark = (skb->mark & ~tgi->mark_mask) ^ tgi->mark_value;\r\npr_debug("redirecting: proto %hhu %pI6:%hu -> %pI6:%hu, mark: %x\n",\r\ntproto, &iph->saddr, ntohs(hp->source),\r\nladdr, ntohs(lport), skb->mark);\r\nnf_tproxy_assign_sock(skb, sk);\r\nreturn NF_ACCEPT;\r\n}\r\npr_debug("no socket, dropping: proto %hhu %pI6:%hu -> %pI6:%hu, mark: %x\n",\r\ntproto, &iph->saddr, ntohs(hp->source),\r\n&iph->daddr, ntohs(hp->dest), skb->mark);\r\nreturn NF_DROP;\r\n}\r\nstatic int tproxy_tg6_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ip6t_ip6 *i = par->entryinfo;\r\nif ((i->proto == IPPROTO_TCP || i->proto == IPPROTO_UDP)\r\n&& !(i->flags & IP6T_INV_PROTO))\r\nreturn 0;\r\npr_info("Can be used only in combination with "\r\n"either -p tcp or -p udp\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int tproxy_tg4_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ipt_ip *i = par->entryinfo;\r\nif ((i->proto == IPPROTO_TCP || i->proto == IPPROTO_UDP)\r\n&& !(i->invflags & IPT_INV_PROTO))\r\nreturn 0;\r\npr_info("Can be used only in combination with "\r\n"either -p tcp or -p udp\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int __init tproxy_tg_init(void)\r\n{\r\nnf_defrag_ipv4_enable();\r\n#ifdef XT_TPROXY_HAVE_IPV6\r\nnf_defrag_ipv6_enable();\r\n#endif\r\nreturn xt_register_targets(tproxy_tg_reg, ARRAY_SIZE(tproxy_tg_reg));\r\n}\r\nstatic void __exit tproxy_tg_exit(void)\r\n{\r\nxt_unregister_targets(tproxy_tg_reg, ARRAY_SIZE(tproxy_tg_reg));\r\n}
