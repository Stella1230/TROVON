static void mq_destroy(struct Qdisc *sch)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct mq_sched *priv = qdisc_priv(sch);\r\nunsigned int ntx;\r\nif (!priv->qdiscs)\r\nreturn;\r\nfor (ntx = 0; ntx < dev->num_tx_queues && priv->qdiscs[ntx]; ntx++)\r\nqdisc_destroy(priv->qdiscs[ntx]);\r\nkfree(priv->qdiscs);\r\n}\r\nstatic int mq_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct mq_sched *priv = qdisc_priv(sch);\r\nstruct netdev_queue *dev_queue;\r\nstruct Qdisc *qdisc;\r\nunsigned int ntx;\r\nif (sch->parent != TC_H_ROOT)\r\nreturn -EOPNOTSUPP;\r\nif (!netif_is_multiqueue(dev))\r\nreturn -EOPNOTSUPP;\r\npriv->qdiscs = kcalloc(dev->num_tx_queues, sizeof(priv->qdiscs[0]),\r\nGFP_KERNEL);\r\nif (priv->qdiscs == NULL)\r\nreturn -ENOMEM;\r\nfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\r\ndev_queue = netdev_get_tx_queue(dev, ntx);\r\nqdisc = qdisc_create_dflt(dev_queue, &pfifo_fast_ops,\r\nTC_H_MAKE(TC_H_MAJ(sch->handle),\r\nTC_H_MIN(ntx + 1)));\r\nif (qdisc == NULL)\r\ngoto err;\r\npriv->qdiscs[ntx] = qdisc;\r\n}\r\nsch->flags |= TCQ_F_MQROOT;\r\nreturn 0;\r\nerr:\r\nmq_destroy(sch);\r\nreturn -ENOMEM;\r\n}\r\nstatic void mq_attach(struct Qdisc *sch)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct mq_sched *priv = qdisc_priv(sch);\r\nstruct Qdisc *qdisc;\r\nunsigned int ntx;\r\nfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\r\nqdisc = priv->qdiscs[ntx];\r\nqdisc = dev_graft_qdisc(qdisc->dev_queue, qdisc);\r\nif (qdisc)\r\nqdisc_destroy(qdisc);\r\n}\r\nkfree(priv->qdiscs);\r\npriv->qdiscs = NULL;\r\n}\r\nstatic int mq_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct Qdisc *qdisc;\r\nunsigned int ntx;\r\nsch->q.qlen = 0;\r\nmemset(&sch->bstats, 0, sizeof(sch->bstats));\r\nmemset(&sch->qstats, 0, sizeof(sch->qstats));\r\nfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\r\nqdisc = netdev_get_tx_queue(dev, ntx)->qdisc_sleeping;\r\nspin_lock_bh(qdisc_lock(qdisc));\r\nsch->q.qlen += qdisc->q.qlen;\r\nsch->bstats.bytes += qdisc->bstats.bytes;\r\nsch->bstats.packets += qdisc->bstats.packets;\r\nsch->qstats.qlen += qdisc->qstats.qlen;\r\nsch->qstats.backlog += qdisc->qstats.backlog;\r\nsch->qstats.drops += qdisc->qstats.drops;\r\nsch->qstats.requeues += qdisc->qstats.requeues;\r\nsch->qstats.overlimits += qdisc->qstats.overlimits;\r\nspin_unlock_bh(qdisc_lock(qdisc));\r\n}\r\nreturn 0;\r\n}\r\nstatic struct netdev_queue *mq_queue_get(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nunsigned long ntx = cl - 1;\r\nif (ntx >= dev->num_tx_queues)\r\nreturn NULL;\r\nreturn netdev_get_tx_queue(dev, ntx);\r\n}\r\nstatic struct netdev_queue *mq_select_queue(struct Qdisc *sch,\r\nstruct tcmsg *tcm)\r\n{\r\nunsigned int ntx = TC_H_MIN(tcm->tcm_parent);\r\nstruct netdev_queue *dev_queue = mq_queue_get(sch, ntx);\r\nif (!dev_queue) {\r\nstruct net_device *dev = qdisc_dev(sch);\r\nreturn netdev_get_tx_queue(dev, 0);\r\n}\r\nreturn dev_queue;\r\n}\r\nstatic int mq_graft(struct Qdisc *sch, unsigned long cl, struct Qdisc *new,\r\nstruct Qdisc **old)\r\n{\r\nstruct netdev_queue *dev_queue = mq_queue_get(sch, cl);\r\nstruct net_device *dev = qdisc_dev(sch);\r\nif (dev->flags & IFF_UP)\r\ndev_deactivate(dev);\r\n*old = dev_graft_qdisc(dev_queue, new);\r\nif (dev->flags & IFF_UP)\r\ndev_activate(dev);\r\nreturn 0;\r\n}\r\nstatic struct Qdisc *mq_leaf(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct netdev_queue *dev_queue = mq_queue_get(sch, cl);\r\nreturn dev_queue->qdisc_sleeping;\r\n}\r\nstatic unsigned long mq_get(struct Qdisc *sch, u32 classid)\r\n{\r\nunsigned int ntx = TC_H_MIN(classid);\r\nif (!mq_queue_get(sch, ntx))\r\nreturn 0;\r\nreturn ntx;\r\n}\r\nstatic void mq_put(struct Qdisc *sch, unsigned long cl)\r\n{\r\n}\r\nstatic int mq_dump_class(struct Qdisc *sch, unsigned long cl,\r\nstruct sk_buff *skb, struct tcmsg *tcm)\r\n{\r\nstruct netdev_queue *dev_queue = mq_queue_get(sch, cl);\r\ntcm->tcm_parent = TC_H_ROOT;\r\ntcm->tcm_handle |= TC_H_MIN(cl);\r\ntcm->tcm_info = dev_queue->qdisc_sleeping->handle;\r\nreturn 0;\r\n}\r\nstatic int mq_dump_class_stats(struct Qdisc *sch, unsigned long cl,\r\nstruct gnet_dump *d)\r\n{\r\nstruct netdev_queue *dev_queue = mq_queue_get(sch, cl);\r\nsch = dev_queue->qdisc_sleeping;\r\nsch->qstats.qlen = sch->q.qlen;\r\nif (gnet_stats_copy_basic(d, &sch->bstats) < 0 ||\r\ngnet_stats_copy_queue(d, &sch->qstats) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void mq_walk(struct Qdisc *sch, struct qdisc_walker *arg)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nunsigned int ntx;\r\nif (arg->stop)\r\nreturn;\r\narg->count = arg->skip;\r\nfor (ntx = arg->skip; ntx < dev->num_tx_queues; ntx++) {\r\nif (arg->fn(sch, ntx + 1, arg) < 0) {\r\narg->stop = 1;\r\nbreak;\r\n}\r\narg->count++;\r\n}\r\n}
