static int __devinit me_driver_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, me_driver.driver_name);\r\n}\r\nstatic void __devexit me_driver_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init me_driver_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&me_driver);\r\nif (retval < 0)\r\nreturn retval;\r\nme_driver_pci_driver.name = (char *)me_driver.driver_name;\r\nreturn pci_register_driver(&me_driver_pci_driver);\r\n}\r\nstatic void __exit me_driver_cleanup_module(void)\r\n{\r\npci_unregister_driver(&me_driver_pci_driver);\r\ncomedi_driver_unregister(&me_driver);\r\n}\r\nstatic inline void sleep(unsigned sec)\r\n{\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule_timeout(sec * HZ);\r\n}\r\nstatic int me_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint bits;\r\nint mask = 1 << CR_CHAN(insn->chanspec);\r\nif (mask & 0x0000ffff) {\r\nbits = 0x0000ffff;\r\ndev_private->control_2 |= ENABLE_PORT_A;\r\nwritew(dev_private->control_2,\r\ndev_private->me_regbase + ME_CONTROL_2);\r\n} else {\r\nbits = 0xffff0000;\r\ndev_private->control_2 |= ENABLE_PORT_B;\r\nwritew(dev_private->control_2,\r\ndev_private->me_regbase + ME_CONTROL_2);\r\n}\r\nif (data[0]) {\r\ns->io_bits |= bits;\r\n} else {\r\ns->io_bits &= ~bits;\r\n}\r\nreturn 1;\r\n}\r\nstatic int me_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int mask = data[0];\r\ns->state &= ~mask;\r\ns->state |= (mask & data[1]);\r\nmask &= s->io_bits;\r\nif (mask & 0x0000ffff) {\r\nwritew((s->state & 0xffff),\r\ndev_private->me_regbase + ME_DIO_PORT_A);\r\n} else {\r\ndata[1] &= ~0x0000ffff;\r\ndata[1] |= readw(dev_private->me_regbase + ME_DIO_PORT_A);\r\n}\r\nif (mask & 0xffff0000) {\r\nwritew(((s->state >> 16) & 0xffff),\r\ndev_private->me_regbase + ME_DIO_PORT_B);\r\n} else {\r\ndata[1] &= ~0xffff0000;\r\ndata[1] |= readw(dev_private->me_regbase + ME_DIO_PORT_B) << 16;\r\n}\r\nreturn 2;\r\n}\r\nstatic int me_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdevice,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned short value;\r\nint chan = CR_CHAN((&insn->chanspec)[0]);\r\nint rang = CR_RANGE((&insn->chanspec)[0]);\r\nint aref = CR_AREF((&insn->chanspec)[0]);\r\nint i;\r\ndev_private->control_1 &= 0xFFFC;\r\nwritew(dev_private->control_1, dev_private->me_regbase + ME_CONTROL_1);\r\ndev_private->control_2 &= ~(ENABLE_ADFIFO | ENABLE_CHANLIST);\r\nwritew(dev_private->control_2, dev_private->me_regbase + ME_CONTROL_2);\r\nwritew(0x00, dev_private->me_regbase + ME_RESET_INTERRUPT);\r\ndev_private->control_2 |= (ENABLE_ADFIFO | ENABLE_CHANLIST);\r\nwritew(dev_private->control_2, dev_private->me_regbase + ME_CONTROL_2);\r\nvalue = chan & 0x0f;\r\nvalue |= (rang & 0x03) << 4;\r\nvalue |= (rang & 0x04) << 4;\r\nvalue |= ((aref & AREF_DIFF) ? 0x80 : 0);\r\nwritew(value & 0xff, dev_private->me_regbase + ME_CHANNEL_LIST);\r\ndev_private->control_1 |= SOFTWARE_TRIGGERED_ADC;\r\nwritew(dev_private->control_1, dev_private->me_regbase + ME_CONTROL_1);\r\nreadw(dev_private->me_regbase + ME_ADC_START);\r\nfor (i = 100000; i > 0; i--)\r\nif (!(readw(dev_private->me_regbase + ME_STATUS) & 0x0004))\r\nbreak;\r\nif (i) {\r\ndata[0] =\r\n(readw(dev_private->me_regbase +\r\nME_READ_AD_FIFO) ^ 0x800) & 0x0FFF;\r\n} else {\r\nprintk(KERN_ERR "comedi%d: Cannot get single value\n",\r\ndev->minor);\r\nreturn -EIO;\r\n}\r\ndev_private->control_1 &= 0xFFFC;\r\nwritew(dev_private->control_1, dev_private->me_regbase + ME_CONTROL_1);\r\nreturn 1;\r\n}\r\nstatic int me_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\ndev_private->control_1 &= 0xFFFC;\r\nwritew(dev_private->control_1, dev_private->me_regbase + ME_CONTROL_1);\r\nreturn 0;\r\n}\r\nstatic int me_ai_do_cmd_test(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int me_ai_do_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdevice)\r\n{\r\nreturn 0;\r\n}\r\nstatic int me_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan;\r\nint rang;\r\nint i;\r\ndev_private->control_2 |= ENABLE_DAC;\r\nwritew(dev_private->control_2, dev_private->me_regbase + ME_CONTROL_2);\r\ndev_private->control_2 |= BUFFERED_DAC;\r\nwritew(dev_private->control_2, dev_private->me_regbase + ME_CONTROL_2);\r\nfor (i = 0; i < insn->n; i++) {\r\nchan = CR_CHAN((&insn->chanspec)[i]);\r\nrang = CR_RANGE((&insn->chanspec)[i]);\r\ndev_private->dac_control &= ~(0x0880 >> chan);\r\nif (rang == 0)\r\ndev_private->dac_control |=\r\n((DAC_BIPOLAR_A | DAC_GAIN_1_A) >> chan);\r\nelse if (rang == 1)\r\ndev_private->dac_control |=\r\n((DAC_BIPOLAR_A | DAC_GAIN_0_A) >> chan);\r\n}\r\nwritew(dev_private->dac_control,\r\ndev_private->me_regbase + ME_DAC_CONTROL);\r\nreadw(dev_private->me_regbase + ME_DAC_CONTROL_UPDATE);\r\nfor (i = 0; i < insn->n; i++) {\r\nchan = CR_CHAN((&insn->chanspec)[i]);\r\nwritew((data[0] & s->maxdata),\r\ndev_private->me_regbase + ME_DAC_DATA_A + (chan << 1));\r\ndev_private->ao_readback[chan] = (data[0] & s->maxdata);\r\n}\r\nreadw(dev_private->me_regbase + ME_DAC_UPDATE);\r\nreturn i;\r\n}\r\nstatic int me_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\ndata[i] =\r\ndev_private->ao_readback[CR_CHAN((&insn->chanspec)[i])];\r\n}\r\nreturn 1;\r\n}\r\nstatic int me2600_xilinx_download(struct comedi_device *dev,\r\nunsigned char *me2600_firmware,\r\nunsigned int length)\r\n{\r\nunsigned int value;\r\nunsigned int file_length;\r\nunsigned int i;\r\nwritel(0x00, dev_private->plx_regbase + PLX_INTCSR);\r\nvalue = readw(dev_private->me_regbase + XILINX_DOWNLOAD_RESET);\r\nsleep(1);\r\nwriteb(0x00, dev_private->me_regbase + 0x0);\r\nsleep(1);\r\nif (length < 16)\r\nreturn -EINVAL;\r\nfile_length = (((unsigned int)me2600_firmware[0] & 0xff) << 24) +\r\n(((unsigned int)me2600_firmware[1] & 0xff) << 16) +\r\n(((unsigned int)me2600_firmware[2] & 0xff) << 8) +\r\n((unsigned int)me2600_firmware[3] & 0xff);\r\nfor (i = 0; i < file_length; i++)\r\nwriteb((me2600_firmware[16 + i] & 0xff),\r\ndev_private->me_regbase + 0x0);\r\nfor (i = 0; i < 5; i++)\r\nwriteb(0x00, dev_private->me_regbase + 0x0);\r\nvalue = readl(dev_private->plx_regbase + PLX_INTCSR);\r\nif (value & 0x20) {\r\nwritel(0x00, dev_private->plx_regbase + PLX_INTCSR);\r\nprintk(KERN_ERR "comedi%d: Xilinx download failed\n",\r\ndev->minor);\r\nreturn -EIO;\r\n}\r\nsleep(1);\r\nwritel(0x43, dev_private->plx_regbase + PLX_INTCSR);\r\nreturn 0;\r\n}\r\nstatic int me_reset(struct comedi_device *dev)\r\n{\r\nwritew(0x00, dev_private->me_regbase + ME_CONTROL_1);\r\nwritew(0x00, dev_private->me_regbase + ME_CONTROL_2);\r\nwritew(0x00, dev_private->me_regbase + ME_RESET_INTERRUPT);\r\nwritew(0x00, dev_private->me_regbase + ME_DAC_CONTROL);\r\ndev_private->dac_control = 0;\r\ndev_private->control_1 = 0;\r\ndev_private->control_2 = 0;\r\nreturn 0;\r\n}\r\nstatic int me_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct pci_dev *pci_device = NULL;\r\nstruct comedi_subdevice *subdevice;\r\nstruct me_board *board;\r\nresource_size_t plx_regbase_tmp;\r\nunsigned long plx_regbase_size_tmp;\r\nresource_size_t me_regbase_tmp;\r\nunsigned long me_regbase_size_tmp;\r\nresource_size_t swap_regbase_tmp;\r\nunsigned long swap_regbase_size_tmp;\r\nresource_size_t regbase_tmp;\r\nint result, error, i;\r\nif (alloc_private(dev, sizeof(struct me_private_data)) < 0)\r\nreturn -ENOMEM;\r\nfor_each_pci_dev(pci_device) {\r\nif (pci_device->vendor == PCI_VENDOR_ID_MEILHAUS) {\r\nfor (i = 0; i < me_board_nbr; i++) {\r\nif (me_boards[i].device_id ==\r\npci_device->device) {\r\nif ((it->options[0] != 0)\r\n|| (it->options[1] != 0)) {\r\nif (pci_device->bus->number !=\r\nit->options[0]\r\n||\r\nPCI_SLOT(pci_device->devfn)\r\n!= it->options[1]) {\r\ncontinue;\r\n}\r\n}\r\ndev->board_ptr = me_boards + i;\r\nboard =\r\n(struct me_board *)dev->board_ptr;\r\ndev_private->pci_device = pci_device;\r\ngoto found;\r\n}\r\n}\r\n}\r\n}\r\nprintk(KERN_ERR\r\n"comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",\r\ndev->minor, it->options[0], it->options[1]);\r\nreturn -EIO;\r\nfound:\r\nprintk(KERN_INFO "comedi%d: found %s at PCI bus %d, slot %d\n",\r\ndev->minor, me_boards[i].name,\r\npci_device->bus->number, PCI_SLOT(pci_device->devfn));\r\nif (comedi_pci_enable(pci_device, ME_DRIVER_NAME) < 0) {\r\nprintk(KERN_ERR "comedi%d: Failed to enable PCI device and "\r\n"request regions\n", dev->minor);\r\nreturn -EIO;\r\n}\r\ndev->board_name = board->name;\r\nplx_regbase_tmp = pci_resource_start(pci_device, 0);\r\nplx_regbase_size_tmp = pci_resource_len(pci_device, 0);\r\ndev_private->plx_regbase =\r\nioremap(plx_regbase_tmp, plx_regbase_size_tmp);\r\ndev_private->plx_regbase_size = plx_regbase_size_tmp;\r\nif (!dev_private->plx_regbase) {\r\nprintk("comedi%d: Failed to remap I/O memory\n", dev->minor);\r\nreturn -ENOMEM;\r\n}\r\nswap_regbase_tmp = pci_resource_start(pci_device, 5);\r\nswap_regbase_size_tmp = pci_resource_len(pci_device, 5);\r\nif (!swap_regbase_tmp)\r\nprintk(KERN_ERR "comedi%d: Swap not present\n", dev->minor);\r\nif (plx_regbase_tmp & 0x0080) {\r\nprintk(KERN_ERR "comedi%d: PLX-Bug detected\n", dev->minor);\r\nif (swap_regbase_tmp) {\r\nregbase_tmp = plx_regbase_tmp;\r\nplx_regbase_tmp = swap_regbase_tmp;\r\nswap_regbase_tmp = regbase_tmp;\r\nresult = pci_write_config_dword(pci_device,\r\nPCI_BASE_ADDRESS_0,\r\nplx_regbase_tmp);\r\nif (result != PCIBIOS_SUCCESSFUL)\r\nreturn -EIO;\r\nresult = pci_write_config_dword(pci_device,\r\nPCI_BASE_ADDRESS_5,\r\nswap_regbase_tmp);\r\nif (result != PCIBIOS_SUCCESSFUL)\r\nreturn -EIO;\r\n} else {\r\nplx_regbase_tmp -= 0x80;\r\nresult = pci_write_config_dword(pci_device,\r\nPCI_BASE_ADDRESS_0,\r\nplx_regbase_tmp);\r\nif (result != PCIBIOS_SUCCESSFUL)\r\nreturn -EIO;\r\n}\r\n}\r\nme_regbase_tmp = pci_resource_start(pci_device, 2);\r\nme_regbase_size_tmp = pci_resource_len(pci_device, 2);\r\ndev_private->me_regbase_size = me_regbase_size_tmp;\r\ndev_private->me_regbase = ioremap(me_regbase_tmp, me_regbase_size_tmp);\r\nif (!dev_private->me_regbase) {\r\nprintk(KERN_ERR "comedi%d: Failed to remap I/O memory\n",\r\ndev->minor);\r\nreturn -ENOMEM;\r\n}\r\nif (board->device_id == ME2600_DEVICE_ID) {\r\nunsigned char *aux_data;\r\nint aux_len;\r\naux_data = comedi_aux_data(it->options, 0);\r\naux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];\r\nif (!aux_data || aux_len < 1) {\r\ncomedi_error(dev, "You must provide me2600 firmware "\r\n"using the --init-data option of "\r\n"comedi_config");\r\nreturn -EINVAL;\r\n}\r\nme2600_xilinx_download(dev, aux_data, aux_len);\r\n}\r\nme_reset(dev);\r\nerror = alloc_subdevices(dev, 3);\r\nif (error < 0)\r\nreturn error;\r\nsubdevice = dev->subdevices + 0;\r\nsubdevice->type = COMEDI_SUBD_AI;\r\nsubdevice->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_CMD_READ;\r\nsubdevice->n_chan = board->ai_channel_nbr;\r\nsubdevice->maxdata = board->ai_resolution_mask;\r\nsubdevice->len_chanlist = board->ai_channel_nbr;\r\nsubdevice->range_table = board->ai_range_list;\r\nsubdevice->cancel = me_ai_cancel;\r\nsubdevice->insn_read = me_ai_insn_read;\r\nsubdevice->do_cmdtest = me_ai_do_cmd_test;\r\nsubdevice->do_cmd = me_ai_do_cmd;\r\nsubdevice = dev->subdevices + 1;\r\nsubdevice->type = COMEDI_SUBD_AO;\r\nsubdevice->subdev_flags = SDF_WRITEABLE | SDF_COMMON;\r\nsubdevice->n_chan = board->ao_channel_nbr;\r\nsubdevice->maxdata = board->ao_resolution_mask;\r\nsubdevice->len_chanlist = board->ao_channel_nbr;\r\nsubdevice->range_table = board->ao_range_list;\r\nsubdevice->insn_read = me_ao_insn_read;\r\nsubdevice->insn_write = me_ao_insn_write;\r\nsubdevice = dev->subdevices + 2;\r\nsubdevice->type = COMEDI_SUBD_DIO;\r\nsubdevice->subdev_flags = SDF_READABLE | SDF_WRITEABLE;\r\nsubdevice->n_chan = board->dio_channel_nbr;\r\nsubdevice->maxdata = 1;\r\nsubdevice->len_chanlist = board->dio_channel_nbr;\r\nsubdevice->range_table = &range_digital;\r\nsubdevice->insn_bits = me_dio_insn_bits;\r\nsubdevice->insn_config = me_dio_insn_config;\r\nsubdevice->io_bits = 0;\r\nprintk(KERN_INFO "comedi%d: " ME_DRIVER_NAME " attached.\n",\r\ndev->minor);\r\nreturn 0;\r\n}\r\nstatic int me_detach(struct comedi_device *dev)\r\n{\r\nif (dev_private) {\r\nif (dev_private->me_regbase) {\r\nme_reset(dev);\r\niounmap(dev_private->me_regbase);\r\n}\r\nif (dev_private->plx_regbase)\r\niounmap(dev_private->plx_regbase);\r\nif (dev_private->pci_device) {\r\nif (dev_private->plx_regbase_size)\r\ncomedi_pci_disable(dev_private->pci_device);\r\npci_dev_put(dev_private->pci_device);\r\n}\r\n}\r\nreturn 0;\r\n}
