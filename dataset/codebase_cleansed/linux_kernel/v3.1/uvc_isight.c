static int isight_decode(struct uvc_video_queue *queue, struct uvc_buffer *buf,\r\nconst __u8 *data, unsigned int len)\r\n{\r\nstatic const __u8 hdr[] = {\r\n0x11, 0x22, 0x33, 0x44,\r\n0xde, 0xad, 0xbe, 0xef,\r\n0xde, 0xad, 0xfa, 0xce\r\n};\r\nunsigned int maxlen, nbytes;\r\n__u8 *mem;\r\nint is_header = 0;\r\nif (buf == NULL)\r\nreturn 0;\r\nif ((len >= 14 && memcmp(&data[2], hdr, 12) == 0) ||\r\n(len >= 15 && memcmp(&data[3], hdr, 12) == 0)) {\r\nuvc_trace(UVC_TRACE_FRAME, "iSight header found\n");\r\nis_header = 1;\r\n}\r\nif (buf->state != UVC_BUF_STATE_ACTIVE) {\r\nif (!is_header) {\r\nuvc_trace(UVC_TRACE_FRAME, "Dropping packet (out of "\r\n"sync).\n");\r\nreturn 0;\r\n}\r\nbuf->state = UVC_BUF_STATE_ACTIVE;\r\n}\r\nif (is_header && buf->buf.bytesused != 0) {\r\nbuf->state = UVC_BUF_STATE_DONE;\r\nreturn -EAGAIN;\r\n}\r\nif (!is_header) {\r\nmaxlen = buf->buf.length - buf->buf.bytesused;\r\nmem = queue->mem + buf->buf.m.offset + buf->buf.bytesused;\r\nnbytes = min(len, maxlen);\r\nmemcpy(mem, data, nbytes);\r\nbuf->buf.bytesused += nbytes;\r\nif (len > maxlen || buf->buf.bytesused == buf->buf.length) {\r\nuvc_trace(UVC_TRACE_FRAME, "Frame complete "\r\n"(overflow).\n");\r\nbuf->state = UVC_BUF_STATE_DONE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid uvc_video_decode_isight(struct urb *urb, struct uvc_streaming *stream,\r\nstruct uvc_buffer *buf)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < urb->number_of_packets; ++i) {\r\nif (urb->iso_frame_desc[i].status < 0) {\r\nuvc_trace(UVC_TRACE_FRAME, "USB isochronous frame "\r\n"lost (%d).\n",\r\nurb->iso_frame_desc[i].status);\r\n}\r\ndo {\r\nret = isight_decode(&stream->queue, buf,\r\nurb->transfer_buffer +\r\nurb->iso_frame_desc[i].offset,\r\nurb->iso_frame_desc[i].actual_length);\r\nif (buf == NULL)\r\nbreak;\r\nif (buf->state == UVC_BUF_STATE_DONE ||\r\nbuf->state == UVC_BUF_STATE_ERROR)\r\nbuf = uvc_queue_next_buffer(&stream->queue,\r\nbuf);\r\n} while (ret == -EAGAIN);\r\n}\r\n}
