static uint8_t nybble(const uint8_t n)\r\n{\r\nif (n >= '0' && n <= '9') return n - '0';\r\nelse if (n >= 'A' && n <= 'F') return n - ('A' - 10);\r\nelse if (n >= 'a' && n <= 'f') return n - ('a' - 10);\r\nreturn 0;\r\n}\r\nstatic uint8_t hex(const uint8_t *data, uint8_t *crc)\r\n{\r\nuint8_t val = (nybble(data[0]) << 4) | nybble(data[1]);\r\n*crc += val;\r\nreturn val;\r\n}\r\nstatic int usage(void)\r\n{\r\nfprintf(stderr, "ihex2fw: Convert ihex files into binary "\r\n"representation for use by Linux kernel\n");\r\nfprintf(stderr, "usage: ihex2fw [<options>] <src.HEX> <dst.fw>\n");\r\nfprintf(stderr, " -w: wide records (16-bit length)\n");\r\nfprintf(stderr, " -s: sort records by address\n");\r\nfprintf(stderr, " -j: include records for CS:IP/EIP address\n");\r\nreturn 1;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nint infd, outfd;\r\nstruct stat st;\r\nuint8_t *data;\r\nint opt;\r\nwhile ((opt = getopt(argc, argv, "wsj")) != -1) {\r\nswitch (opt) {\r\ncase 'w':\r\nwide_records = 1;\r\nbreak;\r\ncase 's':\r\nsort_records = 1;\r\nbreak;\r\ncase 'j':\r\ninclude_jump = 1;\r\nbreak;\r\nreturn usage();\r\n}\r\n}\r\nif (optind + 2 != argc)\r\nreturn usage();\r\nif (!strcmp(argv[optind], "-"))\r\ninfd = 0;\r\nelse\r\ninfd = open(argv[optind], O_RDONLY);\r\nif (infd == -1) {\r\nfprintf(stderr, "Failed to open source file: %s",\r\nstrerror(errno));\r\nreturn usage();\r\n}\r\nif (fstat(infd, &st)) {\r\nperror("stat");\r\nreturn 1;\r\n}\r\ndata = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, infd, 0);\r\nif (data == MAP_FAILED) {\r\nperror("mmap");\r\nreturn 1;\r\n}\r\nif (!strcmp(argv[optind+1], "-"))\r\noutfd = 1;\r\nelse\r\noutfd = open(argv[optind+1], O_TRUNC|O_CREAT|O_WRONLY, 0644);\r\nif (outfd == -1) {\r\nfprintf(stderr, "Failed to open destination file: %s",\r\nstrerror(errno));\r\nreturn usage();\r\n}\r\nif (process_ihex(data, st.st_size))\r\nreturn 1;\r\nreturn output_records(outfd);\r\n}\r\nstatic int process_ihex(uint8_t *data, ssize_t size)\r\n{\r\nstruct ihex_binrec *record;\r\nuint32_t offset = 0;\r\nuint32_t data32;\r\nuint8_t type, crc = 0, crcbyte = 0;\r\nint i, j;\r\nint line = 1;\r\nint len;\r\ni = 0;\r\nnext_record:\r\nwhile (i < size) {\r\nif (data[i] == '\n') line++;\r\nif (data[i++] == ':') break;\r\n}\r\nif (i + 10 > size) {\r\nfprintf(stderr, "Can't find valid record at line %d\n", line);\r\nreturn -EINVAL;\r\n}\r\nlen = hex(data + i, &crc); i += 2;\r\nif (wide_records) {\r\nlen <<= 8;\r\nlen += hex(data + i, &crc); i += 2;\r\n}\r\nrecord = malloc((sizeof (*record) + len + 3) & ~3);\r\nif (!record) {\r\nfprintf(stderr, "out of memory for records\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(record, 0, (sizeof(*record) + len + 3) & ~3);\r\nrecord->len = len;\r\nif (i + 8 + (record->len * 2) > size) {\r\nfprintf(stderr, "Not enough data to read complete record at line %d\n",\r\nline);\r\nreturn -EINVAL;\r\n}\r\nrecord->addr = hex(data + i, &crc) << 8; i += 2;\r\nrecord->addr |= hex(data + i, &crc); i += 2;\r\ntype = hex(data + i, &crc); i += 2;\r\nfor (j = 0; j < record->len; j++, i += 2)\r\nrecord->data[j] = hex(data + i, &crc);\r\ncrcbyte = hex(data + i, &crc); i += 2;\r\nif (crc != 0) {\r\nfprintf(stderr, "CRC failure at line %d: got 0x%X, expected 0x%X\n",\r\nline, crcbyte, (unsigned char)(crcbyte-crc));\r\nreturn -EINVAL;\r\n}\r\nswitch (type) {\r\ncase 0:\r\nif (!record->len)\r\nbreak;\r\nrecord->addr += offset;\r\nfile_record(record);\r\ngoto next_record;\r\ncase 1:\r\nif (record->addr || record->len) {\r\nfprintf(stderr, "Bad EOF record (type 01) format at line %d",\r\nline);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 2:\r\ncase 4:\r\nif (record->addr || record->len != 2) {\r\nfprintf(stderr, "Bad HEX86/HEX386 record (type %02X) at line %d\n",\r\ntype, line);\r\nreturn -EINVAL;\r\n}\r\noffset = record->data[0] << 8 | record->data[1];\r\noffset <<= (type == 2 ? 4 : 16);\r\ngoto next_record;\r\ncase 3:\r\ncase 5:\r\nif (record->addr || record->len != 4) {\r\nfprintf(stderr, "Bad Start Address record (type %02X) at line %d\n",\r\ntype, line);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&data32, &record->data[0], sizeof(data32));\r\ndata32 = htonl(data32);\r\nmemcpy(&record->data[0], &data32, sizeof(data32));\r\nif (include_jump)\r\nfile_record(record);\r\ngoto next_record;\r\ndefault:\r\nfprintf(stderr, "Unknown record (type %02X)\n", type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void file_record(struct ihex_binrec *record)\r\n{\r\nstruct ihex_binrec **p = &records;\r\nwhile ((*p) && (!sort_records || (*p)->addr < record->addr))\r\np = &((*p)->next);\r\nrecord->next = *p;\r\n*p = record;\r\n}\r\nstatic int output_records(int outfd)\r\n{\r\nunsigned char zeroes[6] = {0, 0, 0, 0, 0, 0};\r\nstruct ihex_binrec *p = records;\r\nwhile (p) {\r\nuint16_t writelen = (p->len + 9) & ~3;\r\np->addr = htonl(p->addr);\r\np->len = htons(p->len);\r\nif (write(outfd, &p->addr, writelen) != writelen)\r\nreturn 1;\r\np = p->next;\r\n}\r\nif (write(outfd, zeroes, 6) != 6)\r\nreturn 1;\r\nreturn 0;\r\n}
