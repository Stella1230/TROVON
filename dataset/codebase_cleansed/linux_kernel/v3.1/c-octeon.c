static void octeon_flush_data_cache_page(unsigned long addr)\r\n{\r\n}\r\nstatic inline void octeon_local_flush_icache(void)\r\n{\r\nasm volatile ("synci 0($0)");\r\n}\r\nstatic void local_octeon_flush_icache_range(unsigned long start,\r\nunsigned long end)\r\n{\r\nocteon_local_flush_icache();\r\n}\r\nstatic void octeon_flush_icache_all_cores(struct vm_area_struct *vma)\r\n{\r\nextern void octeon_send_ipi_single(int cpu, unsigned int action);\r\n#ifdef CONFIG_SMP\r\nint cpu;\r\ncpumask_t mask;\r\n#endif\r\nmb();\r\nocteon_local_flush_icache();\r\n#ifdef CONFIG_SMP\r\npreempt_disable();\r\ncpu = smp_processor_id();\r\nif (vma)\r\nmask = *mm_cpumask(vma->vm_mm);\r\nelse\r\nmask = cpu_online_map;\r\ncpu_clear(cpu, mask);\r\nfor_each_cpu_mask(cpu, mask)\r\nocteon_send_ipi_single(cpu, SMP_ICACHE_FLUSH);\r\npreempt_enable();\r\n#endif\r\n}\r\nstatic void octeon_flush_icache_all(void)\r\n{\r\nocteon_flush_icache_all_cores(NULL);\r\n}\r\nstatic void octeon_flush_cache_mm(struct mm_struct *mm)\r\n{\r\n}\r\nstatic void octeon_flush_icache_range(unsigned long start, unsigned long end)\r\n{\r\nocteon_flush_icache_all_cores(NULL);\r\n}\r\nstatic void octeon_flush_cache_sigtramp(unsigned long addr)\r\n{\r\nstruct vm_area_struct *vma;\r\nvma = find_vma(current->mm, addr);\r\nocteon_flush_icache_all_cores(vma);\r\n}\r\nstatic void octeon_flush_cache_range(struct vm_area_struct *vma,\r\nunsigned long start, unsigned long end)\r\n{\r\nif (vma->vm_flags & VM_EXEC)\r\nocteon_flush_icache_all_cores(vma);\r\n}\r\nstatic void octeon_flush_cache_page(struct vm_area_struct *vma,\r\nunsigned long page, unsigned long pfn)\r\n{\r\nif (vma->vm_flags & VM_EXEC)\r\nocteon_flush_icache_all_cores(vma);\r\n}\r\nstatic void __cpuinit probe_octeon(void)\r\n{\r\nunsigned long icache_size;\r\nunsigned long dcache_size;\r\nunsigned int config1;\r\nstruct cpuinfo_mips *c = &current_cpu_data;\r\nconfig1 = read_c0_config1();\r\nswitch (c->cputype) {\r\ncase CPU_CAVIUM_OCTEON:\r\ncase CPU_CAVIUM_OCTEON_PLUS:\r\nc->icache.linesz = 2 << ((config1 >> 19) & 7);\r\nc->icache.sets = 64 << ((config1 >> 22) & 7);\r\nc->icache.ways = 1 + ((config1 >> 16) & 7);\r\nc->icache.flags |= MIPS_CACHE_VTAG;\r\nicache_size =\r\nc->icache.sets * c->icache.ways * c->icache.linesz;\r\nc->icache.waybit = ffs(icache_size / c->icache.ways) - 1;\r\nc->dcache.linesz = 128;\r\nif (c->cputype == CPU_CAVIUM_OCTEON_PLUS)\r\nc->dcache.sets = 2;\r\nelse\r\nc->dcache.sets = 1;\r\nc->dcache.ways = 64;\r\ndcache_size =\r\nc->dcache.sets * c->dcache.ways * c->dcache.linesz;\r\nc->dcache.waybit = ffs(dcache_size / c->dcache.ways) - 1;\r\nc->options |= MIPS_CPU_PREFETCH;\r\nbreak;\r\ncase CPU_CAVIUM_OCTEON2:\r\nc->icache.linesz = 2 << ((config1 >> 19) & 7);\r\nc->icache.sets = 8;\r\nc->icache.ways = 37;\r\nc->icache.flags |= MIPS_CACHE_VTAG;\r\nicache_size = c->icache.sets * c->icache.ways * c->icache.linesz;\r\nc->dcache.linesz = 128;\r\nc->dcache.ways = 32;\r\nc->dcache.sets = 8;\r\ndcache_size = c->dcache.sets * c->dcache.ways * c->dcache.linesz;\r\nc->options |= MIPS_CPU_PREFETCH;\r\nbreak;\r\ndefault:\r\npanic("Unsupported Cavium Networks CPU type\n");\r\nbreak;\r\n}\r\nc->icache.waysize = icache_size / c->icache.ways;\r\nc->dcache.waysize = dcache_size / c->dcache.ways;\r\nc->icache.sets = icache_size / (c->icache.linesz * c->icache.ways);\r\nc->dcache.sets = dcache_size / (c->dcache.linesz * c->dcache.ways);\r\nif (smp_processor_id() == 0) {\r\npr_notice("Primary instruction cache %ldkB, %s, %d way, "\r\n"%d sets, linesize %d bytes.\n",\r\nicache_size >> 10,\r\ncpu_has_vtag_icache ?\r\n"virtually tagged" : "physically tagged",\r\nc->icache.ways, c->icache.sets, c->icache.linesz);\r\npr_notice("Primary data cache %ldkB, %d-way, %d sets, "\r\n"linesize %d bytes.\n",\r\ndcache_size >> 10, c->dcache.ways,\r\nc->dcache.sets, c->dcache.linesz);\r\n}\r\n}\r\nvoid __cpuinit octeon_cache_init(void)\r\n{\r\nextern unsigned long ebase;\r\nextern char except_vec2_octeon;\r\nmemcpy((void *)(ebase + 0x100), &except_vec2_octeon, 0x80);\r\nocteon_flush_cache_sigtramp(ebase + 0x100);\r\nprobe_octeon();\r\nshm_align_mask = PAGE_SIZE - 1;\r\nflush_cache_all = octeon_flush_icache_all;\r\n__flush_cache_all = octeon_flush_icache_all;\r\nflush_cache_mm = octeon_flush_cache_mm;\r\nflush_cache_page = octeon_flush_cache_page;\r\nflush_cache_range = octeon_flush_cache_range;\r\nflush_cache_sigtramp = octeon_flush_cache_sigtramp;\r\nflush_icache_all = octeon_flush_icache_all;\r\nflush_data_cache_page = octeon_flush_data_cache_page;\r\nflush_icache_range = octeon_flush_icache_range;\r\nlocal_flush_icache_range = local_octeon_flush_icache_range;\r\nbuild_clear_page();\r\nbuild_copy_page();\r\n}\r\nstatic void cache_parity_error_octeon(int non_recoverable)\r\n{\r\nunsigned long coreid = cvmx_get_core_num();\r\nuint64_t icache_err = read_octeon_c0_icacheerr();\r\npr_err("Cache error exception:\n");\r\npr_err("cp0_errorepc == %lx\n", read_c0_errorepc());\r\nif (icache_err & 1) {\r\npr_err("CacheErr (Icache) == %llx\n",\r\n(unsigned long long)icache_err);\r\nwrite_octeon_c0_icacheerr(0);\r\n}\r\nif (cache_err_dcache[coreid] & 1) {\r\npr_err("CacheErr (Dcache) == %llx\n",\r\n(unsigned long long)cache_err_dcache[coreid]);\r\ncache_err_dcache[coreid] = 0;\r\n}\r\nif (non_recoverable)\r\npanic("Can't handle cache error: nested exception");\r\n}\r\nasmlinkage void cache_parity_error_octeon_recoverable(void)\r\n{\r\ncache_parity_error_octeon(0);\r\n}\r\nasmlinkage void cache_parity_error_octeon_non_recoverable(void)\r\n{\r\ncache_parity_error_octeon(1);\r\n}
