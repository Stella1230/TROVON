static void xlog(char *x, ...)\r\n{\r\n#ifndef DIVA_NO_DEBUGLIB\r\nva_list ap;\r\nif (myDriverDebugHandle.dbgMask & DL_XLOG) {\r\nva_start(ap, x);\r\nif (myDriverDebugHandle.dbg_irq) {\r\nmyDriverDebugHandle.dbg_irq(myDriverDebugHandle.id,\r\nDLI_XLOG, x, ap);\r\n} else if (myDriverDebugHandle.dbg_old) {\r\nmyDriverDebugHandle.dbg_old(myDriverDebugHandle.id,\r\nx, ap);\r\n}\r\nva_end(ap);\r\n}\r\n#endif\r\n}\r\nstatic char *diva_procinfo(struct capi_ctr *ctrl)\r\n{\r\nreturn (ctrl->serial);\r\n}\r\nstatic void stop_dbg(void)\r\n{\r\nDbgDeregister();\r\nmemset(&MAdapter, 0, sizeof(MAdapter));\r\ndprintf = no_printf;\r\n}\r\nstatic void no_printf(unsigned char *x, ...)\r\n{\r\n}\r\nbyte MapController(byte Controller)\r\n{\r\nbyte i;\r\nbyte MappedController = 0;\r\nbyte ctrl = Controller & 0x7f;\r\nfor (i = 1; i < max_adapter + 1; i++) {\r\nif (ctrl == ControllerMap[i]) {\r\nMappedController = (byte) i;\r\nbreak;\r\n}\r\n}\r\nif (i > max_adapter) {\r\nControllerMap[0] = ctrl;\r\nMappedController = 0;\r\n}\r\nreturn (MappedController | (Controller & 0x80));\r\n}\r\nbyte UnMapController(byte MappedController)\r\n{\r\nbyte Controller;\r\nbyte ctrl = MappedController & 0x7f;\r\nif (ctrl <= max_adapter) {\r\nController = ControllerMap[ctrl];\r\n} else {\r\nController = 0;\r\n}\r\nreturn (Controller | (MappedController & 0x80));\r\n}\r\nstatic int find_free_id(void)\r\n{\r\nint num = 0;\r\nDIVA_CAPI_ADAPTER *a;\r\nwhile (num < MAX_DESCRIPTORS) {\r\na = &adapter[num];\r\nif (!a->Id)\r\nbreak;\r\nnum++;\r\n}\r\nreturn(num + 1);\r\n}\r\nstatic diva_card *find_card_by_ctrl(word controller)\r\n{\r\nstruct list_head *tmp;\r\ndiva_card *card;\r\nlist_for_each(tmp, &cards) {\r\ncard = list_entry(tmp, diva_card, list);\r\nif (ControllerMap[card->Id] == controller) {\r\nif (card->remove_in_progress)\r\ncard = NULL;\r\nreturn(card);\r\n}\r\n}\r\nreturn (diva_card *) 0;\r\n}\r\nvoid *TransmitBufferSet(APPL * appl, dword ref)\r\n{\r\nappl->xbuffer_used[ref] = true;\r\nDBG_PRV1(("%d:xbuf_used(%d)", appl->Id, ref + 1))\r\nreturn (void *)(long)ref;\r\n}\r\nvoid *TransmitBufferGet(APPL * appl, void *p)\r\n{\r\nif (appl->xbuffer_internal[(dword)(long)p])\r\nreturn appl->xbuffer_internal[(dword)(long)p];\r\nreturn appl->xbuffer_ptr[(dword)(long)p];\r\n}\r\nvoid TransmitBufferFree(APPL * appl, void *p)\r\n{\r\nappl->xbuffer_used[(dword)(long)p] = false;\r\nDBG_PRV1(("%d:xbuf_free(%d)", appl->Id, ((dword)(long)p) + 1))\r\n}\r\nvoid *ReceiveBufferGet(APPL * appl, int Num)\r\n{\r\nreturn &appl->ReceiveBuffer[Num * appl->MaxDataLength];\r\n}\r\nvoid api_remove_complete(void)\r\n{\r\nDBG_PRV1(("api_remove_complete"))\r\n}\r\nvoid sendf(APPL * appl, word command, dword Id, word Number, byte * format, ...)\r\n{\r\nword i, j;\r\nword length = 12, dlength = 0;\r\nbyte *write;\r\nCAPI_MSG msg;\r\nbyte *string = NULL;\r\nva_list ap;\r\ndiva_os_message_buffer_s *dmb;\r\ndiva_card *card = NULL;\r\ndword tmp;\r\nif (!appl)\r\nreturn;\r\nDBG_PRV1(("sendf(a=%d,cmd=%x,format=%s)",\r\nappl->Id, command, (byte *) format))\r\nPUT_WORD(&msg.header.appl_id, appl->Id);\r\nPUT_WORD(&msg.header.command, command);\r\nif ((byte) (command >> 8) == 0x82)\r\nNumber = appl->Number++;\r\nPUT_WORD(&msg.header.number, Number);\r\nPUT_DWORD(&msg.header.controller, Id);\r\nwrite = (byte *) & msg;\r\nwrite += 12;\r\nva_start(ap, format);\r\nfor (i = 0; format[i]; i++) {\r\nswitch (format[i]) {\r\ncase 'b':\r\ntmp = va_arg(ap, dword);\r\n*(byte *) write = (byte) (tmp & 0xff);\r\nwrite += 1;\r\nlength += 1;\r\nbreak;\r\ncase 'w':\r\ntmp = va_arg(ap, dword);\r\nPUT_WORD(write, (tmp & 0xffff));\r\nwrite += 2;\r\nlength += 2;\r\nbreak;\r\ncase 'd':\r\ntmp = va_arg(ap, dword);\r\nPUT_DWORD(write, tmp);\r\nwrite += 4;\r\nlength += 4;\r\nbreak;\r\ncase 's':\r\ncase 'S':\r\nstring = va_arg(ap, byte *);\r\nlength += string[0] + 1;\r\nfor (j = 0; j <= string[0]; j++)\r\n*write++ = string[j];\r\nbreak;\r\n}\r\n}\r\nva_end(ap);\r\nPUT_WORD(&msg.header.length, length);\r\nmsg.header.controller = UnMapController(msg.header.controller);\r\nif (command == _DATA_B3_I)\r\ndlength = GET_WORD(\r\n((byte *) & msg.info.data_b3_ind.Data_Length));\r\nif (!(dmb = diva_os_alloc_message_buffer(length + dlength,\r\n(void **) &write))) {\r\nDBG_ERR(("sendf: alloc_message_buffer failed, incoming msg dropped."))\r\nreturn;\r\n}\r\nmemcpy(write, (byte *) & msg, length);\r\nif (command == _DATA_B3_I) {\r\ndword data = GET_DWORD(&msg.info.data_b3_ind.Data);\r\nmemcpy(write + length, (void *)(long)data, dlength);\r\n}\r\n#ifndef DIVA_NO_DEBUGLIB\r\nif (myDriverDebugHandle.dbgMask & DL_XLOG) {\r\nswitch (command) {\r\ndefault:\r\nxlog("\x00\x02", &msg, 0x81, length);\r\nbreak;\r\ncase _DATA_B3_R | CONFIRM:\r\nif (myDriverDebugHandle.dbgMask & DL_BLK)\r\nxlog("\x00\x02", &msg, 0x81, length);\r\nbreak;\r\ncase _DATA_B3_I:\r\nif (myDriverDebugHandle.dbgMask & DL_BLK) {\r\nxlog("\x00\x02", &msg, 0x81, length);\r\nfor (i = 0; i < dlength; i += 256) {\r\nDBG_BLK((((char *)(long)GET_DWORD(&msg.info.data_b3_ind.Data)) + i,\r\n((dlength - i) < 256) ? (dlength - i) : 256))\r\nif (!(myDriverDebugHandle.dbgMask & DL_PRV0))\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n#endif\r\nif (!(card = find_card_by_ctrl(write[8] & 0x7f))) {\r\nDBG_ERR(("sendf - controller %d not found, incoming msg dropped",\r\nwrite[8] & 0x7f))\r\ndiva_os_free_message_buffer(dmb);\r\nreturn;\r\n}\r\ncapi_ctr_handle_message(&card->capi_ctrl, appl->Id, dmb);\r\n}\r\nstatic void clean_adapter(int id, struct list_head *free_mem_q)\r\n{\r\nDIVA_CAPI_ADAPTER *a;\r\nint i, k;\r\na = &adapter[id];\r\nk = li_total_channels - a->li_channels;\r\nif (k == 0) {\r\nif (li_config_table) {\r\nlist_add((struct list_head *)li_config_table, free_mem_q);\r\nli_config_table = NULL;\r\n}\r\n} else {\r\nif (a->li_base < k) {\r\nmemmove(&li_config_table[a->li_base],\r\n&li_config_table[a->li_base + a->li_channels],\r\n(k - a->li_base) * sizeof(LI_CONFIG));\r\nfor (i = 0; i < k; i++) {\r\nmemmove(&li_config_table[i].flag_table[a->li_base],\r\n&li_config_table[i].flag_table[a->li_base + a->li_channels],\r\nk - a->li_base);\r\nmemmove(&li_config_table[i].\r\ncoef_table[a->li_base],\r\n&li_config_table[i].coef_table[a->li_base + a->li_channels],\r\nk - a->li_base);\r\n}\r\n}\r\n}\r\nli_total_channels = k;\r\nfor (i = id; i < max_adapter; i++) {\r\nif (adapter[i].request)\r\nadapter[i].li_base -= a->li_channels;\r\n}\r\nif (a->plci)\r\nlist_add((struct list_head *)a->plci, free_mem_q);\r\nmemset(a, 0x00, sizeof(DIVA_CAPI_ADAPTER));\r\nwhile ((max_adapter != 0) && !adapter[max_adapter - 1].request)\r\nmax_adapter--;\r\n}\r\nstatic void divacapi_remove_card(DESCRIPTOR * d)\r\n{\r\ndiva_card *card = NULL;\r\ndiva_os_spin_lock_magic_t old_irql;\r\nLIST_HEAD(free_mem_q);\r\nstruct list_head *link;\r\nstruct list_head *tmp;\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "remove card");\r\nlist_for_each(tmp, &cards) {\r\ncard = list_entry(tmp, diva_card, list);\r\nif (card->d.request == d->request) {\r\ncard->remove_in_progress = 1;\r\nlist_del(tmp);\r\nbreak;\r\n}\r\n}\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "remove card");\r\nif (card) {\r\ndetach_capi_ctr(&card->capi_ctrl);\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "remove card");\r\nclean_adapter(card->Id - 1, &free_mem_q);\r\nDBG_TRC(("DelAdapterMap (%d) -> (%d)",\r\nControllerMap[card->Id], card->Id))\r\nControllerMap[card->Id] = 0;\r\nDBG_TRC(("adapter remove, max_adapter=%d",\r\nmax_adapter));\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "remove card");\r\ndiva_os_free (0, card);\r\n}\r\nlist_for_each_safe(link, tmp, &free_mem_q) {\r\nlist_del(link);\r\ndiva_os_free(0, link);\r\n}\r\n}\r\nstatic void divacapi_remove_cards(void)\r\n{\r\nDESCRIPTOR d;\r\nstruct list_head *tmp;\r\ndiva_card *card;\r\ndiva_os_spin_lock_magic_t old_irql;\r\nrescan:\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "remove cards");\r\nlist_for_each(tmp, &cards) {\r\ncard = list_entry(tmp, diva_card, list);\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "remove cards");\r\nd.request = card->d.request;\r\ndivacapi_remove_card(&d);\r\ngoto rescan;\r\n}\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "remove cards");\r\n}\r\nstatic void sync_callback(ENTITY * e)\r\n{\r\ndiva_os_spin_lock_magic_t old_irql;\r\nDBG_TRC(("cb:Id=%x,Rc=%x,Ind=%x", e->Id, e->Rc, e->Ind))\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "sync_callback");\r\ncallback(e);\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "sync_callback");\r\n}\r\nstatic int diva_add_card(DESCRIPTOR * d)\r\n{\r\nint k = 0, i = 0;\r\ndiva_os_spin_lock_magic_t old_irql;\r\ndiva_card *card = NULL;\r\nstruct capi_ctr *ctrl = NULL;\r\nDIVA_CAPI_ADAPTER *a = NULL;\r\nIDI_SYNC_REQ sync_req;\r\nchar serial[16];\r\nvoid* mem_to_free;\r\nLI_CONFIG *new_li_config_table;\r\nint j;\r\nif (!(card = (diva_card *) diva_os_malloc(0, sizeof(diva_card)))) {\r\nDBG_ERR(("diva_add_card: failed to allocate card struct."))\r\nreturn (0);\r\n}\r\nmemset((char *) card, 0x00, sizeof(diva_card));\r\nmemcpy(&card->d, d, sizeof(DESCRIPTOR));\r\nsync_req.GetName.Req = 0;\r\nsync_req.GetName.Rc = IDI_SYNC_REQ_GET_NAME;\r\ncard->d.request((ENTITY *) & sync_req);\r\nstrlcpy(card->name, sync_req.GetName.name, sizeof(card->name));\r\nctrl = &card->capi_ctrl;\r\nstrcpy(ctrl->name, card->name);\r\nctrl->register_appl = diva_register_appl;\r\nctrl->release_appl = diva_release_appl;\r\nctrl->send_message = diva_send_message;\r\nctrl->procinfo = diva_procinfo;\r\nctrl->driverdata = card;\r\ndiva_os_set_controller_struct(ctrl);\r\nif (attach_capi_ctr(ctrl)) {\r\nDBG_ERR(("diva_add_card: failed to attach controller."))\r\ndiva_os_free(0, card);\r\nreturn (0);\r\n}\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "find id");\r\ncard->Id = find_free_id();\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "find id");\r\nstrlcpy(ctrl->manu, M_COMPANY, sizeof(ctrl->manu));\r\nctrl->version.majorversion = 2;\r\nctrl->version.minorversion = 0;\r\nctrl->version.majormanuversion = DRRELMAJOR;\r\nctrl->version.minormanuversion = DRRELMINOR;\r\nsync_req.GetSerial.Req = 0;\r\nsync_req.GetSerial.Rc = IDI_SYNC_REQ_GET_SERIAL;\r\nsync_req.GetSerial.serial = 0;\r\ncard->d.request((ENTITY *) & sync_req);\r\nif ((i = ((sync_req.GetSerial.serial & 0xff000000) >> 24))) {\r\nsprintf(serial, "%ld-%d",\r\nsync_req.GetSerial.serial & 0x00ffffff, i + 1);\r\n} else {\r\nsprintf(serial, "%ld", sync_req.GetSerial.serial);\r\n}\r\nserial[CAPI_SERIAL_LEN - 1] = 0;\r\nstrlcpy(ctrl->serial, serial, sizeof(ctrl->serial));\r\na = &adapter[card->Id - 1];\r\ncard->adapter = a;\r\na->os_card = card;\r\nControllerMap[card->Id] = (byte) (ctrl->cnr);\r\nDBG_TRC(("AddAdapterMap (%d) -> (%d)", ctrl->cnr, card->Id))\r\nsync_req.xdi_capi_prms.Req = 0;\r\nsync_req.xdi_capi_prms.Rc = IDI_SYNC_REQ_XDI_GET_CAPI_PARAMS;\r\nsync_req.xdi_capi_prms.info.structure_length =\r\nsizeof(diva_xdi_get_capi_parameters_t);\r\ncard->d.request((ENTITY *) & sync_req);\r\na->flag_dynamic_l1_down =\r\nsync_req.xdi_capi_prms.info.flag_dynamic_l1_down;\r\na->group_optimization_enabled =\r\nsync_req.xdi_capi_prms.info.group_optimization_enabled;\r\na->request = DIRequest;\r\na->max_plci = card->d.channels + 30;\r\na->max_listen = (card->d.channels > 2) ? 8 : 2;\r\nif (!\r\n(a->plci =\r\n(PLCI *) diva_os_malloc(0, sizeof(PLCI) * a->max_plci))) {\r\nDBG_ERR(("diva_add_card: failed alloc plci struct."))\r\nmemset(a, 0, sizeof(DIVA_CAPI_ADAPTER));\r\nreturn (0);\r\n}\r\nmemset(a->plci, 0, sizeof(PLCI) * a->max_plci);\r\nfor (k = 0; k < a->max_plci; k++) {\r\na->Id = (byte) card->Id;\r\na->plci[k].Sig.callback = sync_callback;\r\na->plci[k].Sig.XNum = 1;\r\na->plci[k].Sig.X = a->plci[k].XData;\r\na->plci[k].Sig.user[0] = (word) (card->Id - 1);\r\na->plci[k].Sig.user[1] = (word) k;\r\na->plci[k].NL.callback = sync_callback;\r\na->plci[k].NL.XNum = 1;\r\na->plci[k].NL.X = a->plci[k].XData;\r\na->plci[k].NL.user[0] = (word) ((card->Id - 1) | 0x8000);\r\na->plci[k].NL.user[1] = (word) k;\r\na->plci[k].adapter = a;\r\n}\r\na->profile.Number = card->Id;\r\na->profile.Channels = card->d.channels;\r\nif (card->d.features & DI_FAX3) {\r\na->profile.Global_Options = 0x71;\r\nif (card->d.features & DI_CODEC)\r\na->profile.Global_Options |= 0x6;\r\n#if IMPLEMENT_DTMF\r\na->profile.Global_Options |= 0x8;\r\n#endif\r\na->profile.Global_Options |= 0x80;\r\n#if IMPLEMENT_ECHO_CANCELLER\r\na->profile.Global_Options |= 0x100;\r\n#endif\r\na->profile.B1_Protocols = 0xdf;\r\na->profile.B2_Protocols = 0x1fdb;\r\na->profile.B3_Protocols = 0xb7;\r\na->manufacturer_features = MANUFACTURER_FEATURE_HARDDTMF;\r\n} else {\r\na->profile.Global_Options = 0x71;\r\nif (card->d.features & DI_CODEC)\r\na->profile.Global_Options |= 0x2;\r\na->profile.B1_Protocols = 0x43;\r\na->profile.B2_Protocols = 0x1f0f;\r\na->profile.B3_Protocols = 0x07;\r\na->manufacturer_features = 0;\r\n}\r\na->li_pri = (a->profile.Channels > 2);\r\na->li_channels = a->li_pri ? MIXER_CHANNELS_PRI : MIXER_CHANNELS_BRI;\r\na->li_base = 0;\r\nfor (i = 0; &adapter[i] != a; i++) {\r\nif (adapter[i].request)\r\na->li_base = adapter[i].li_base + adapter[i].li_channels;\r\n}\r\nk = li_total_channels + a->li_channels;\r\nnew_li_config_table =\r\n(LI_CONFIG *) diva_os_malloc(0, ((k * sizeof(LI_CONFIG) + 3) & ~3) + (2 * k) * ((k + 3) & ~3));\r\nif (new_li_config_table == NULL) {\r\nDBG_ERR(("diva_add_card: failed alloc li_config table."))\r\nmemset(a, 0, sizeof(DIVA_CAPI_ADAPTER));\r\nreturn (0);\r\n}\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "add card");\r\nj = 0;\r\nfor (i = 0; i < k; i++) {\r\nif ((i >= a->li_base) && (i < a->li_base + a->li_channels))\r\nmemset(&new_li_config_table[i], 0, sizeof(LI_CONFIG));\r\nelse\r\nmemcpy(&new_li_config_table[i], &li_config_table[j], sizeof(LI_CONFIG));\r\nnew_li_config_table[i].flag_table =\r\n((byte *) new_li_config_table) + (((k * sizeof(LI_CONFIG) + 3) & ~3) + (2 * i) * ((k + 3) & ~3));\r\nnew_li_config_table[i].coef_table =\r\n((byte *) new_li_config_table) + (((k * sizeof(LI_CONFIG) + 3) & ~3) + (2 * i + 1) * ((k + 3) & ~3));\r\nif ((i >= a->li_base) && (i < a->li_base + a->li_channels)) {\r\nnew_li_config_table[i].adapter = a;\r\nmemset(&new_li_config_table[i].flag_table[0], 0, k);\r\nmemset(&new_li_config_table[i].coef_table[0], 0, k);\r\n} else {\r\nif (a->li_base != 0) {\r\nmemcpy(&new_li_config_table[i].flag_table[0],\r\n&li_config_table[j].flag_table[0],\r\na->li_base);\r\nmemcpy(&new_li_config_table[i].coef_table[0],\r\n&li_config_table[j].coef_table[0],\r\na->li_base);\r\n}\r\nmemset(&new_li_config_table[i].flag_table[a->li_base], 0, a->li_channels);\r\nmemset(&new_li_config_table[i].coef_table[a->li_base], 0, a->li_channels);\r\nif (a->li_base + a->li_channels < k) {\r\nmemcpy(&new_li_config_table[i].flag_table[a->li_base +\r\na->li_channels],\r\n&li_config_table[j].flag_table[a->li_base],\r\nk - (a->li_base + a->li_channels));\r\nmemcpy(&new_li_config_table[i].coef_table[a->li_base +\r\na->li_channels],\r\n&li_config_table[j].coef_table[a->li_base],\r\nk - (a->li_base + a->li_channels));\r\n}\r\nj++;\r\n}\r\n}\r\nli_total_channels = k;\r\nmem_to_free = li_config_table;\r\nli_config_table = new_li_config_table;\r\nfor (i = card->Id; i < max_adapter; i++) {\r\nif (adapter[i].request)\r\nadapter[i].li_base += a->li_channels;\r\n}\r\nif (a == &adapter[max_adapter])\r\nmax_adapter++;\r\nlist_add(&(card->list), &cards);\r\nAutomaticLaw(a);\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "add card");\r\nif (mem_to_free) {\r\ndiva_os_free (0, mem_to_free);\r\n}\r\ni = 0;\r\nwhile (i++ < 30) {\r\nif (a->automatic_law > 3)\r\nbreak;\r\ndiva_os_sleep(10);\r\n}\r\nPUT_WORD(&ctrl->profile.nbchannel, card->d.channels);\r\nctrl->profile.goptions = a->profile.Global_Options;\r\nctrl->profile.support1 = a->profile.B1_Protocols;\r\nctrl->profile.support2 = a->profile.B2_Protocols;\r\nctrl->profile.support3 = a->profile.B3_Protocols;\r\nctrl->profile.manu[0] = a->man_profile.private_options;\r\nctrl->profile.manu[1] = a->man_profile.rtp_primary_payloads;\r\nctrl->profile.manu[2] = a->man_profile.rtp_additional_payloads;\r\nctrl->profile.manu[3] = 0;\r\nctrl->profile.manu[4] = 0;\r\ncapi_ctr_ready(ctrl);\r\nDBG_TRC(("adapter added, max_adapter=%d", max_adapter));\r\nreturn (1);\r\n}\r\nstatic void diva_register_appl(struct capi_ctr *ctrl, __u16 appl,\r\ncapi_register_params * rp)\r\n{\r\nAPPL *this;\r\nword bnum, xnum;\r\nint i = 0;\r\nunsigned char *p;\r\nvoid *DataNCCI, *DataFlags, *ReceiveBuffer, *xbuffer_used;\r\nvoid **xbuffer_ptr, **xbuffer_internal;\r\ndiva_os_spin_lock_magic_t old_irql;\r\nunsigned int mem_len;\r\nint nconn = rp->level3cnt;\r\nif (diva_os_in_irq()) {\r\nDBG_ERR(("CAPI_REGISTER - in irq context !"))\r\nreturn;\r\n}\r\nDBG_TRC(("application register Id=%d", appl))\r\nif (appl > MAX_APPL) {\r\nDBG_ERR(("CAPI_REGISTER - appl.Id exceeds MAX_APPL"))\r\nreturn;\r\n}\r\nif (nconn <= 0)\r\nnconn = ctrl->profile.nbchannel * -nconn;\r\nif (nconn == 0)\r\nnconn = ctrl->profile.nbchannel;\r\nDBG_LOG(("CAPI_REGISTER - Id = %d", appl))\r\nDBG_LOG((" MaxLogicalConnections = %d(%d)", nconn, rp->level3cnt))\r\nDBG_LOG((" MaxBDataBuffers = %d", rp->datablkcnt))\r\nDBG_LOG((" MaxBDataLength = %d", rp->datablklen))\r\nif (nconn < 1 ||\r\nnconn > 255 ||\r\nrp->datablklen < 80 ||\r\nrp->datablklen > 2150 || rp->datablkcnt > 255) {\r\nDBG_ERR(("CAPI_REGISTER - invalid parameters"))\r\nreturn;\r\n}\r\nif (application[appl - 1].Id == appl) {\r\nDBG_LOG(("CAPI_REGISTER - appl already registered"))\r\nreturn;\r\n}\r\nbnum = nconn * rp->datablkcnt;\r\nxnum = nconn * MAX_DATA_B3;\r\nmem_len = bnum * sizeof(word);\r\nmem_len += bnum * sizeof(word);\r\nmem_len += bnum * rp->datablklen;\r\nmem_len += xnum;\r\nmem_len += xnum * sizeof(void *);\r\nmem_len += xnum * sizeof(void *);\r\nmem_len += xnum * rp->datablklen;\r\nDBG_LOG((" Allocated Memory = %d", mem_len))\r\nif (!(p = diva_os_malloc(0, mem_len))) {\r\nDBG_ERR(("CAPI_REGISTER - memory allocation failed"))\r\nreturn;\r\n}\r\nmemset(p, 0, mem_len);\r\nDataNCCI = (void *)p;\r\np += bnum * sizeof(word);\r\nDataFlags = (void *)p;\r\np += bnum * sizeof(word);\r\nReceiveBuffer = (void *)p;\r\np += bnum * rp->datablklen;\r\nxbuffer_used = (void *)p;\r\np += xnum;\r\nxbuffer_ptr = (void **)p;\r\np += xnum * sizeof(void *);\r\nxbuffer_internal = (void **)p;\r\np += xnum * sizeof(void *);\r\nfor (i = 0; i < xnum; i++) {\r\nxbuffer_ptr[i] = (void *)p;\r\np += rp->datablklen;\r\n}\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "register_appl");\r\nthis = &application[appl - 1];\r\nmemset(this, 0, sizeof(APPL));\r\nthis->Id = appl;\r\nfor (i = 0; i < max_adapter; i++) {\r\nadapter[i].CIP_Mask[appl - 1] = 0;\r\n}\r\nthis->queue_size = 1000;\r\nthis->MaxNCCI = (byte) nconn;\r\nthis->MaxNCCIData = (byte) rp->datablkcnt;\r\nthis->MaxBuffer = bnum;\r\nthis->MaxDataLength = rp->datablklen;\r\nthis->DataNCCI = DataNCCI;\r\nthis->DataFlags = DataFlags;\r\nthis->ReceiveBuffer = ReceiveBuffer;\r\nthis->xbuffer_used = xbuffer_used;\r\nthis->xbuffer_ptr = xbuffer_ptr;\r\nthis->xbuffer_internal = xbuffer_internal;\r\nfor (i = 0; i < xnum; i++) {\r\nthis->xbuffer_ptr[i] = xbuffer_ptr[i];\r\n}\r\nCapiRegister(this->Id);\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "register_appl");\r\n}\r\nstatic void diva_release_appl(struct capi_ctr *ctrl, __u16 appl)\r\n{\r\ndiva_os_spin_lock_magic_t old_irql;\r\nAPPL *this = &application[appl - 1];\r\nvoid *mem_to_free = NULL;\r\nDBG_TRC(("application %d(%d) cleanup", this->Id, appl))\r\nif (diva_os_in_irq()) {\r\nDBG_ERR(("CAPI_RELEASE - in irq context !"))\r\nreturn;\r\n}\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "release_appl");\r\nif (this->Id) {\r\nCapiRelease(this->Id);\r\nmem_to_free = this->DataNCCI;\r\nthis->DataNCCI = NULL;\r\nthis->Id = 0;\r\n}\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "release_appl");\r\nif (mem_to_free)\r\ndiva_os_free(0, mem_to_free);\r\n}\r\nstatic u16 diva_send_message(struct capi_ctr *ctrl,\r\ndiva_os_message_buffer_s * dmb)\r\n{\r\nint i = 0;\r\nword ret = 0;\r\ndiva_os_spin_lock_magic_t old_irql;\r\nCAPI_MSG *msg = (CAPI_MSG *) DIVA_MESSAGE_BUFFER_DATA(dmb);\r\nAPPL *this = &application[GET_WORD(&msg->header.appl_id) - 1];\r\ndiva_card *card = ctrl->driverdata;\r\n__u32 length = DIVA_MESSAGE_BUFFER_LEN(dmb);\r\nword clength = GET_WORD(&msg->header.length);\r\nword command = GET_WORD(&msg->header.command);\r\nu16 retval = CAPI_NOERROR;\r\nif (diva_os_in_irq()) {\r\nDBG_ERR(("CAPI_SEND_MSG - in irq context !"))\r\nreturn CAPI_REGOSRESOURCEERR;\r\n}\r\nDBG_PRV1(("Write - appl = %d, cmd = 0x%x", this->Id, command))\r\nif (card->remove_in_progress) {\r\nDBG_ERR(("CAPI_SEND_MSG - remove in progress!"))\r\nreturn CAPI_REGOSRESOURCEERR;\r\n}\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "send message");\r\nif (!this->Id) {\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "send message");\r\nreturn CAPI_ILLAPPNR;\r\n}\r\nmsg->header.controller = ControllerMap[card->Id]\r\n| (msg->header.controller & 0x80);\r\nswitch (command) {\r\ndefault:\r\nxlog("\x00\x02", msg, 0x80, clength);\r\nbreak;\r\ncase _DATA_B3_I | RESPONSE:\r\n#ifndef DIVA_NO_DEBUGLIB\r\nif (myDriverDebugHandle.dbgMask & DL_BLK)\r\nxlog("\x00\x02", msg, 0x80, clength);\r\n#endif\r\nbreak;\r\ncase _DATA_B3_R:\r\n#ifndef DIVA_NO_DEBUGLIB\r\nif (myDriverDebugHandle.dbgMask & DL_BLK)\r\nxlog("\x00\x02", msg, 0x80, clength);\r\n#endif\r\nif (clength == 24)\r\nclength = 22;\r\nif (GET_WORD(&msg->info.data_b3_req.Data_Length) >\r\nthis->MaxDataLength\r\n|| GET_WORD(&msg->info.data_b3_req.Data_Length) >\r\n(length - clength)) {\r\nDBG_ERR(("Write - invalid message size"))\r\nretval = CAPI_ILLCMDORSUBCMDORMSGTOSMALL;\r\ngoto write_end;\r\n}\r\nfor (i = 0; i < (MAX_DATA_B3 * this->MaxNCCI)\r\n&& this->xbuffer_used[i]; i++);\r\nif (i == (MAX_DATA_B3 * this->MaxNCCI)) {\r\nDBG_ERR(("Write - too many data pending"))\r\nretval = CAPI_SENDQUEUEFULL;\r\ngoto write_end;\r\n}\r\nmsg->info.data_b3_req.Data = i;\r\nthis->xbuffer_internal[i] = NULL;\r\nmemcpy(this->xbuffer_ptr[i], &((__u8 *) msg)[clength],\r\nGET_WORD(&msg->info.data_b3_req.Data_Length));\r\n#ifndef DIVA_NO_DEBUGLIB\r\nif ((myDriverDebugHandle.dbgMask & DL_BLK)\r\n&& (myDriverDebugHandle.dbgMask & DL_XLOG)) {\r\nint j;\r\nfor (j = 0; j <\r\nGET_WORD(&msg->info.data_b3_req.Data_Length);\r\nj += 256) {\r\nDBG_BLK((((char *) this->xbuffer_ptr[i]) + j,\r\n((GET_WORD(&msg->info.data_b3_req.Data_Length) - j) <\r\n256) ? (GET_WORD(&msg->info.data_b3_req.Data_Length) - j) : 256))\r\nif (!(myDriverDebugHandle.dbgMask & DL_PRV0))\r\nbreak;\r\n}\r\n}\r\n#endif\r\nbreak;\r\n}\r\nmemcpy(mapped_msg, msg, (__u32) clength);\r\nmapped_msg->header.controller = MapController(mapped_msg->header.controller);\r\nmapped_msg->header.length = clength;\r\nmapped_msg->header.command = command;\r\nmapped_msg->header.number = GET_WORD(&msg->header.number);\r\nret = api_put(this, mapped_msg);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase _BAD_MSG:\r\nDBG_ERR(("Write - bad message"))\r\nretval = CAPI_ILLCMDORSUBCMDORMSGTOSMALL;\r\nbreak;\r\ncase _QUEUE_FULL:\r\nDBG_ERR(("Write - queue full"))\r\nretval = CAPI_SENDQUEUEFULL;\r\nbreak;\r\ndefault:\r\nDBG_ERR(("Write - api_put returned unknown error"))\r\nretval = CAPI_UNKNOWNNOTPAR;\r\nbreak;\r\n}\r\nwrite_end:\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "send message");\r\nif (retval == CAPI_NOERROR)\r\ndiva_os_free_message_buffer(dmb);\r\nreturn retval;\r\n}\r\nstatic void DIRequest(ENTITY * e)\r\n{\r\nDIVA_CAPI_ADAPTER *a = &(adapter[(byte) e->user[0]]);\r\ndiva_card *os_card = (diva_card *) a->os_card;\r\nif (e->Req && (a->FlowControlIdTable[e->ReqCh] == e->Id)) {\r\na->FlowControlSkipTable[e->ReqCh] = 1;\r\n}\r\n(*(os_card->d.request)) (e);\r\n}\r\nstatic void didd_callback(void *context, DESCRIPTOR * adapter, int removal)\r\n{\r\nif (adapter->type == IDI_DADAPTER) {\r\nDBG_ERR(("Notification about IDI_DADAPTER change ! Oops."));\r\nreturn;\r\n} else if (adapter->type == IDI_DIMAINT) {\r\nif (removal) {\r\nstop_dbg();\r\n} else {\r\nmemcpy(&MAdapter, adapter, sizeof(MAdapter));\r\ndprintf = (DIVA_DI_PRINTF) MAdapter.request;\r\nDbgRegister("CAPI20", DRIVERRELEASE_CAPI, DBG_DEFAULT);\r\n}\r\n} else if ((adapter->type > 0) && (adapter->type < 16)) {\r\nif (removal) {\r\ndivacapi_remove_card(adapter);\r\n} else {\r\ndiva_add_card(adapter);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int divacapi_connect_didd(void)\r\n{\r\nint x = 0;\r\nint dadapter = 0;\r\nIDI_SYNC_REQ req;\r\nDESCRIPTOR DIDD_Table[MAX_DESCRIPTORS];\r\nDIVA_DIDD_Read(DIDD_Table, sizeof(DIDD_Table));\r\nfor (x = 0; x < MAX_DESCRIPTORS; x++) {\r\nif (DIDD_Table[x].type == IDI_DIMAINT) {\r\nmemcpy(&MAdapter, &DIDD_Table[x], sizeof(DAdapter));\r\ndprintf = (DIVA_DI_PRINTF) MAdapter.request;\r\nDbgRegister("CAPI20", DRIVERRELEASE_CAPI, DBG_DEFAULT);\r\nbreak;\r\n}\r\n}\r\nfor (x = 0; x < MAX_DESCRIPTORS; x++) {\r\nif (DIDD_Table[x].type == IDI_DADAPTER) {\r\ndadapter = 1;\r\nmemcpy(&DAdapter, &DIDD_Table[x], sizeof(DAdapter));\r\nreq.didd_notify.e.Req = 0;\r\nreq.didd_notify.e.Rc =\r\nIDI_SYNC_REQ_DIDD_REGISTER_ADAPTER_NOTIFY;\r\nreq.didd_notify.info.callback = (void *)didd_callback;\r\nreq.didd_notify.info.context = NULL;\r\nDAdapter.request((ENTITY *) & req);\r\nif (req.didd_notify.e.Rc != 0xff) {\r\nstop_dbg();\r\nreturn (0);\r\n}\r\nnotify_handle = req.didd_notify.info.handle;\r\n}\r\nelse if ((DIDD_Table[x].type > 0) && (DIDD_Table[x].type < 16)) {\r\ndiva_add_card(&DIDD_Table[x]);\r\n}\r\n}\r\nif (!dadapter) {\r\nstop_dbg();\r\n}\r\nreturn (dadapter);\r\n}\r\nstatic void divacapi_disconnect_didd(void)\r\n{\r\nIDI_SYNC_REQ req;\r\nstop_dbg();\r\nreq.didd_notify.e.Req = 0;\r\nreq.didd_notify.e.Rc = IDI_SYNC_REQ_DIDD_REMOVE_ADAPTER_NOTIFY;\r\nreq.didd_notify.info.handle = notify_handle;\r\nDAdapter.request((ENTITY *) & req);\r\n}\r\nint fax_head_line_time(char *buffer)\r\n{\r\nreturn (0);\r\n}\r\nstatic int DIVA_INIT_FUNCTION init_main_structs(void)\r\n{\r\nif (!(mapped_msg = (CAPI_MSG *) diva_os_malloc(0, MAX_MSG_SIZE))) {\r\nDBG_ERR(("init: failed alloc mapped_msg."))\r\nreturn 0;\r\n}\r\nif (!(adapter = diva_os_malloc(0, sizeof(DIVA_CAPI_ADAPTER) * MAX_DESCRIPTORS))) {\r\nDBG_ERR(("init: failed alloc adapter struct."))\r\ndiva_os_free(0, mapped_msg);\r\nreturn 0;\r\n}\r\nmemset(adapter, 0, sizeof(DIVA_CAPI_ADAPTER) * MAX_DESCRIPTORS);\r\nif (!(application = diva_os_malloc(0, sizeof(APPL) * MAX_APPL))) {\r\nDBG_ERR(("init: failed alloc application struct."))\r\ndiva_os_free(0, mapped_msg);\r\ndiva_os_free(0, adapter);\r\nreturn 0;\r\n}\r\nmemset(application, 0, sizeof(APPL) * MAX_APPL);\r\nreturn (1);\r\n}\r\nstatic void remove_main_structs(void)\r\n{\r\nif (application)\r\ndiva_os_free(0, application);\r\nif (adapter)\r\ndiva_os_free(0, adapter);\r\nif (mapped_msg)\r\ndiva_os_free(0, mapped_msg);\r\n}\r\nstatic void do_api_remove_start(void)\r\n{\r\ndiva_os_spin_lock_magic_t old_irql;\r\nint ret = 1, count = 100;\r\ndo {\r\ndiva_os_enter_spin_lock(&api_lock, &old_irql, "api remove start");\r\nret = api_remove_start();\r\ndiva_os_leave_spin_lock(&api_lock, &old_irql, "api remove start");\r\ndiva_os_sleep(10);\r\n} while (ret && count--);\r\nif (ret)\r\nDBG_ERR(("could not remove signaling ID's"))\r\n}\r\nint DIVA_INIT_FUNCTION init_capifunc(void)\r\n{\r\ndiva_os_initialize_spin_lock(&api_lock, "capifunc");\r\nmemset(ControllerMap, 0, MAX_DESCRIPTORS + 1);\r\nmax_adapter = 0;\r\nif (!init_main_structs()) {\r\nDBG_ERR(("init: failed to init main structs."))\r\ndiva_os_destroy_spin_lock(&api_lock, "capifunc");\r\nreturn (0);\r\n}\r\nif (!divacapi_connect_didd()) {\r\nDBG_ERR(("init: failed to connect to DIDD."))\r\ndo_api_remove_start();\r\ndivacapi_remove_cards();\r\nremove_main_structs();\r\ndiva_os_destroy_spin_lock(&api_lock, "capifunc");\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nvoid DIVA_EXIT_FUNCTION finit_capifunc(void)\r\n{\r\ndo_api_remove_start();\r\ndivacapi_disconnect_didd();\r\ndivacapi_remove_cards();\r\nremove_main_structs();\r\ndiva_os_destroy_spin_lock(&api_lock, "capifunc");\r\n}
