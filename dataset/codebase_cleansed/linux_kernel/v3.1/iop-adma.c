static void iop_adma_free_slots(struct iop_adma_desc_slot *slot)\r\n{\r\nint stride = slot->slots_per_op;\r\nwhile (stride--) {\r\nslot->slots_per_op = 0;\r\nslot = list_entry(slot->slot_node.next,\r\nstruct iop_adma_desc_slot,\r\nslot_node);\r\n}\r\n}\r\nstatic void\r\niop_desc_unmap(struct iop_adma_chan *iop_chan, struct iop_adma_desc_slot *desc)\r\n{\r\nstruct dma_async_tx_descriptor *tx = &desc->async_tx;\r\nstruct iop_adma_desc_slot *unmap = desc->group_head;\r\nstruct device *dev = &iop_chan->device->pdev->dev;\r\nu32 len = unmap->unmap_len;\r\nenum dma_ctrl_flags flags = tx->flags;\r\nu32 src_cnt;\r\ndma_addr_t addr;\r\ndma_addr_t dest;\r\nsrc_cnt = unmap->unmap_src_cnt;\r\ndest = iop_desc_get_dest_addr(unmap, iop_chan);\r\nif (!(flags & DMA_COMPL_SKIP_DEST_UNMAP)) {\r\nenum dma_data_direction dir;\r\nif (src_cnt > 1)\r\ndir = DMA_BIDIRECTIONAL;\r\nelse\r\ndir = DMA_FROM_DEVICE;\r\ndma_unmap_page(dev, dest, len, dir);\r\n}\r\nif (!(flags & DMA_COMPL_SKIP_SRC_UNMAP)) {\r\nwhile (src_cnt--) {\r\naddr = iop_desc_get_src_addr(unmap, iop_chan, src_cnt);\r\nif (addr == dest)\r\ncontinue;\r\ndma_unmap_page(dev, addr, len, DMA_TO_DEVICE);\r\n}\r\n}\r\ndesc->group_head = NULL;\r\n}\r\nstatic void\r\niop_desc_unmap_pq(struct iop_adma_chan *iop_chan, struct iop_adma_desc_slot *desc)\r\n{\r\nstruct dma_async_tx_descriptor *tx = &desc->async_tx;\r\nstruct iop_adma_desc_slot *unmap = desc->group_head;\r\nstruct device *dev = &iop_chan->device->pdev->dev;\r\nu32 len = unmap->unmap_len;\r\nenum dma_ctrl_flags flags = tx->flags;\r\nu32 src_cnt = unmap->unmap_src_cnt;\r\ndma_addr_t pdest = iop_desc_get_dest_addr(unmap, iop_chan);\r\ndma_addr_t qdest = iop_desc_get_qdest_addr(unmap, iop_chan);\r\nint i;\r\nif (tx->flags & DMA_PREP_CONTINUE)\r\nsrc_cnt -= 3;\r\nif (!(flags & DMA_COMPL_SKIP_DEST_UNMAP) && !desc->pq_check_result) {\r\ndma_unmap_page(dev, pdest, len, DMA_BIDIRECTIONAL);\r\ndma_unmap_page(dev, qdest, len, DMA_BIDIRECTIONAL);\r\n}\r\nif (!(flags & DMA_COMPL_SKIP_SRC_UNMAP)) {\r\ndma_addr_t addr;\r\nfor (i = 0; i < src_cnt; i++) {\r\naddr = iop_desc_get_src_addr(unmap, iop_chan, i);\r\ndma_unmap_page(dev, addr, len, DMA_TO_DEVICE);\r\n}\r\nif (desc->pq_check_result) {\r\ndma_unmap_page(dev, pdest, len, DMA_TO_DEVICE);\r\ndma_unmap_page(dev, qdest, len, DMA_TO_DEVICE);\r\n}\r\n}\r\ndesc->group_head = NULL;\r\n}\r\nstatic dma_cookie_t\r\niop_adma_run_tx_complete_actions(struct iop_adma_desc_slot *desc,\r\nstruct iop_adma_chan *iop_chan, dma_cookie_t cookie)\r\n{\r\nstruct dma_async_tx_descriptor *tx = &desc->async_tx;\r\nBUG_ON(tx->cookie < 0);\r\nif (tx->cookie > 0) {\r\ncookie = tx->cookie;\r\ntx->cookie = 0;\r\nif (tx->callback)\r\ntx->callback(tx->callback_param);\r\nif (desc->group_head && desc->unmap_len) {\r\nif (iop_desc_is_pq(desc))\r\niop_desc_unmap_pq(iop_chan, desc);\r\nelse\r\niop_desc_unmap(iop_chan, desc);\r\n}\r\n}\r\ndma_run_dependencies(tx);\r\nreturn cookie;\r\n}\r\nstatic int\r\niop_adma_clean_slot(struct iop_adma_desc_slot *desc,\r\nstruct iop_adma_chan *iop_chan)\r\n{\r\nif (!async_tx_test_ack(&desc->async_tx))\r\nreturn 0;\r\nif (desc->chain_node.next == &iop_chan->chain)\r\nreturn 1;\r\ndev_dbg(iop_chan->device->common.dev,\r\n"\tfree slot: %d slots_per_op: %d\n",\r\ndesc->idx, desc->slots_per_op);\r\nlist_del(&desc->chain_node);\r\niop_adma_free_slots(desc);\r\nreturn 0;\r\n}\r\nstatic void __iop_adma_slot_cleanup(struct iop_adma_chan *iop_chan)\r\n{\r\nstruct iop_adma_desc_slot *iter, *_iter, *grp_start = NULL;\r\ndma_cookie_t cookie = 0;\r\nu32 current_desc = iop_chan_get_current_descriptor(iop_chan);\r\nint busy = iop_chan_is_busy(iop_chan);\r\nint seen_current = 0, slot_cnt = 0, slots_per_op = 0;\r\ndev_dbg(iop_chan->device->common.dev, "%s\n", __func__);\r\nlist_for_each_entry_safe(iter, _iter, &iop_chan->chain,\r\nchain_node) {\r\npr_debug("\tcookie: %d slot: %d busy: %d "\r\n"this_desc: %#x next_desc: %#x ack: %d\n",\r\niter->async_tx.cookie, iter->idx, busy,\r\niter->async_tx.phys, iop_desc_get_next_desc(iter),\r\nasync_tx_test_ack(&iter->async_tx));\r\nprefetch(_iter);\r\nprefetch(&_iter->async_tx);\r\nif (seen_current)\r\nbreak;\r\nif (iter->async_tx.phys == current_desc) {\r\nBUG_ON(seen_current++);\r\nif (busy || iop_desc_get_next_desc(iter))\r\nbreak;\r\n}\r\nif (!slot_cnt && !slots_per_op) {\r\nslot_cnt = iter->slot_cnt;\r\nslots_per_op = iter->slots_per_op;\r\nif (slot_cnt <= slots_per_op) {\r\nslot_cnt = 0;\r\nslots_per_op = 0;\r\n}\r\n}\r\nif (slot_cnt) {\r\npr_debug("\tgroup++\n");\r\nif (!grp_start)\r\ngrp_start = iter;\r\nslot_cnt -= slots_per_op;\r\n}\r\nif (slots_per_op != 0 && slot_cnt == 0) {\r\nstruct iop_adma_desc_slot *grp_iter, *_grp_iter;\r\nint end_of_chain = 0;\r\npr_debug("\tgroup end\n");\r\nif (grp_start->xor_check_result) {\r\nu32 zero_sum_result = 0;\r\nslot_cnt = grp_start->slot_cnt;\r\ngrp_iter = grp_start;\r\nlist_for_each_entry_from(grp_iter,\r\n&iop_chan->chain, chain_node) {\r\nzero_sum_result |=\r\niop_desc_get_zero_result(grp_iter);\r\npr_debug("\titer%d result: %d\n",\r\ngrp_iter->idx, zero_sum_result);\r\nslot_cnt -= slots_per_op;\r\nif (slot_cnt == 0)\r\nbreak;\r\n}\r\npr_debug("\tgrp_start->xor_check_result: %p\n",\r\ngrp_start->xor_check_result);\r\n*grp_start->xor_check_result = zero_sum_result;\r\n}\r\nslot_cnt = grp_start->slot_cnt;\r\ngrp_iter = grp_start;\r\nlist_for_each_entry_safe_from(grp_iter, _grp_iter,\r\n&iop_chan->chain, chain_node) {\r\ncookie = iop_adma_run_tx_complete_actions(\r\ngrp_iter, iop_chan, cookie);\r\nslot_cnt -= slots_per_op;\r\nend_of_chain = iop_adma_clean_slot(grp_iter,\r\niop_chan);\r\nif (slot_cnt == 0 || end_of_chain)\r\nbreak;\r\n}\r\nBUG_ON(slot_cnt);\r\nslots_per_op = 0;\r\ngrp_start = NULL;\r\nif (end_of_chain)\r\nbreak;\r\nelse\r\ncontinue;\r\n} else if (slots_per_op)\r\ncontinue;\r\nif (iter->xor_check_result && iter->async_tx.cookie)\r\n*iter->xor_check_result =\r\niop_desc_get_zero_result(iter);\r\ncookie = iop_adma_run_tx_complete_actions(\r\niter, iop_chan, cookie);\r\nif (iop_adma_clean_slot(iter, iop_chan))\r\nbreak;\r\n}\r\nif (cookie > 0) {\r\niop_chan->completed_cookie = cookie;\r\npr_debug("\tcompleted cookie %d\n", cookie);\r\n}\r\n}\r\nstatic void\r\niop_adma_slot_cleanup(struct iop_adma_chan *iop_chan)\r\n{\r\nspin_lock_bh(&iop_chan->lock);\r\n__iop_adma_slot_cleanup(iop_chan);\r\nspin_unlock_bh(&iop_chan->lock);\r\n}\r\nstatic void iop_adma_tasklet(unsigned long data)\r\n{\r\nstruct iop_adma_chan *iop_chan = (struct iop_adma_chan *) data;\r\nspin_lock_nested(&iop_chan->lock, SINGLE_DEPTH_NESTING);\r\n__iop_adma_slot_cleanup(iop_chan);\r\nspin_unlock(&iop_chan->lock);\r\n}\r\nstatic struct iop_adma_desc_slot *\r\niop_adma_alloc_slots(struct iop_adma_chan *iop_chan, int num_slots,\r\nint slots_per_op)\r\n{\r\nstruct iop_adma_desc_slot *iter, *_iter, *alloc_start = NULL;\r\nLIST_HEAD(chain);\r\nint slots_found, retry = 0;\r\nretry:\r\nslots_found = 0;\r\nif (retry == 0)\r\niter = iop_chan->last_used;\r\nelse\r\niter = list_entry(&iop_chan->all_slots,\r\nstruct iop_adma_desc_slot,\r\nslot_node);\r\nlist_for_each_entry_safe_continue(\r\niter, _iter, &iop_chan->all_slots, slot_node) {\r\nprefetch(_iter);\r\nprefetch(&_iter->async_tx);\r\nif (iter->slots_per_op) {\r\nif (retry)\r\nbreak;\r\nslots_found = 0;\r\ncontinue;\r\n}\r\nif (!slots_found++) {\r\nif (iop_desc_is_aligned(iter, slots_per_op))\r\nalloc_start = iter;\r\nelse {\r\nslots_found = 0;\r\ncontinue;\r\n}\r\n}\r\nif (slots_found == num_slots) {\r\nstruct iop_adma_desc_slot *alloc_tail = NULL;\r\nstruct iop_adma_desc_slot *last_used = NULL;\r\niter = alloc_start;\r\nwhile (num_slots) {\r\nint i;\r\ndev_dbg(iop_chan->device->common.dev,\r\n"allocated slot: %d "\r\n"(desc %p phys: %#x) slots_per_op %d\n",\r\niter->idx, iter->hw_desc,\r\niter->async_tx.phys, slots_per_op);\r\nif (num_slots != slots_per_op)\r\nasync_tx_ack(&iter->async_tx);\r\nlist_add_tail(&iter->chain_node, &chain);\r\nalloc_tail = iter;\r\niter->async_tx.cookie = 0;\r\niter->slot_cnt = num_slots;\r\niter->xor_check_result = NULL;\r\nfor (i = 0; i < slots_per_op; i++) {\r\niter->slots_per_op = slots_per_op - i;\r\nlast_used = iter;\r\niter = list_entry(iter->slot_node.next,\r\nstruct iop_adma_desc_slot,\r\nslot_node);\r\n}\r\nnum_slots -= slots_per_op;\r\n}\r\nalloc_tail->group_head = alloc_start;\r\nalloc_tail->async_tx.cookie = -EBUSY;\r\nlist_splice(&chain, &alloc_tail->tx_list);\r\niop_chan->last_used = last_used;\r\niop_desc_clear_next_desc(alloc_start);\r\niop_desc_clear_next_desc(alloc_tail);\r\nreturn alloc_tail;\r\n}\r\n}\r\nif (!retry++)\r\ngoto retry;\r\n__iop_adma_slot_cleanup(iop_chan);\r\nreturn NULL;\r\n}\r\nstatic dma_cookie_t\r\niop_desc_assign_cookie(struct iop_adma_chan *iop_chan,\r\nstruct iop_adma_desc_slot *desc)\r\n{\r\ndma_cookie_t cookie = iop_chan->common.cookie;\r\ncookie++;\r\nif (cookie < 0)\r\ncookie = 1;\r\niop_chan->common.cookie = desc->async_tx.cookie = cookie;\r\nreturn cookie;\r\n}\r\nstatic void iop_adma_check_threshold(struct iop_adma_chan *iop_chan)\r\n{\r\ndev_dbg(iop_chan->device->common.dev, "pending: %d\n",\r\niop_chan->pending);\r\nif (iop_chan->pending >= IOP_ADMA_THRESHOLD) {\r\niop_chan->pending = 0;\r\niop_chan_append(iop_chan);\r\n}\r\n}\r\nstatic dma_cookie_t\r\niop_adma_tx_submit(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct iop_adma_desc_slot *sw_desc = tx_to_iop_adma_slot(tx);\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(tx->chan);\r\nstruct iop_adma_desc_slot *grp_start, *old_chain_tail;\r\nint slot_cnt;\r\nint slots_per_op;\r\ndma_cookie_t cookie;\r\ndma_addr_t next_dma;\r\ngrp_start = sw_desc->group_head;\r\nslot_cnt = grp_start->slot_cnt;\r\nslots_per_op = grp_start->slots_per_op;\r\nspin_lock_bh(&iop_chan->lock);\r\ncookie = iop_desc_assign_cookie(iop_chan, sw_desc);\r\nold_chain_tail = list_entry(iop_chan->chain.prev,\r\nstruct iop_adma_desc_slot, chain_node);\r\nlist_splice_init(&sw_desc->tx_list,\r\n&old_chain_tail->chain_node);\r\nnext_dma = grp_start->async_tx.phys;\r\niop_desc_set_next_desc(old_chain_tail, next_dma);\r\nBUG_ON(iop_desc_get_next_desc(old_chain_tail) != next_dma);\r\niop_paranoia(iop_desc_get_next_desc(sw_desc));\r\niop_chan->pending += slot_cnt;\r\niop_adma_check_threshold(iop_chan);\r\nspin_unlock_bh(&iop_chan->lock);\r\ndev_dbg(iop_chan->device->common.dev, "%s cookie: %d slot: %d\n",\r\n__func__, sw_desc->async_tx.cookie, sw_desc->idx);\r\nreturn cookie;\r\n}\r\nstatic int iop_adma_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nchar *hw_desc;\r\nint idx;\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *slot = NULL;\r\nint init = iop_chan->slots_allocated ? 0 : 1;\r\nstruct iop_adma_platform_data *plat_data =\r\niop_chan->device->pdev->dev.platform_data;\r\nint num_descs_in_pool = plat_data->pool_size/IOP_ADMA_SLOT_SIZE;\r\ndo {\r\nidx = iop_chan->slots_allocated;\r\nif (idx == num_descs_in_pool)\r\nbreak;\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot) {\r\nprintk(KERN_INFO "IOP ADMA Channel only initialized"\r\n" %d descriptor slots", idx);\r\nbreak;\r\n}\r\nhw_desc = (char *) iop_chan->device->dma_desc_pool_virt;\r\nslot->hw_desc = (void *) &hw_desc[idx * IOP_ADMA_SLOT_SIZE];\r\ndma_async_tx_descriptor_init(&slot->async_tx, chan);\r\nslot->async_tx.tx_submit = iop_adma_tx_submit;\r\nINIT_LIST_HEAD(&slot->tx_list);\r\nINIT_LIST_HEAD(&slot->chain_node);\r\nINIT_LIST_HEAD(&slot->slot_node);\r\nhw_desc = (char *) iop_chan->device->dma_desc_pool;\r\nslot->async_tx.phys =\r\n(dma_addr_t) &hw_desc[idx * IOP_ADMA_SLOT_SIZE];\r\nslot->idx = idx;\r\nspin_lock_bh(&iop_chan->lock);\r\niop_chan->slots_allocated++;\r\nlist_add_tail(&slot->slot_node, &iop_chan->all_slots);\r\nspin_unlock_bh(&iop_chan->lock);\r\n} while (iop_chan->slots_allocated < num_descs_in_pool);\r\nif (idx && !iop_chan->last_used)\r\niop_chan->last_used = list_entry(iop_chan->all_slots.next,\r\nstruct iop_adma_desc_slot,\r\nslot_node);\r\ndev_dbg(iop_chan->device->common.dev,\r\n"allocated %d descriptor slots last_used: %p\n",\r\niop_chan->slots_allocated, iop_chan->last_used);\r\nif (init) {\r\nif (dma_has_cap(DMA_MEMCPY,\r\niop_chan->device->common.cap_mask))\r\niop_chan_start_null_memcpy(iop_chan);\r\nelse if (dma_has_cap(DMA_XOR,\r\niop_chan->device->common.cap_mask))\r\niop_chan_start_null_xor(iop_chan);\r\nelse\r\nBUG();\r\n}\r\nreturn (idx > 0) ? idx : -ENOMEM;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\niop_adma_prep_dma_interrupt(struct dma_chan *chan, unsigned long flags)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *sw_desc, *grp_start;\r\nint slot_cnt, slots_per_op;\r\ndev_dbg(iop_chan->device->common.dev, "%s\n", __func__);\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_interrupt_slot_count(&slots_per_op, iop_chan);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\ngrp_start = sw_desc->group_head;\r\niop_desc_init_interrupt(grp_start, iop_chan);\r\ngrp_start->unmap_len = 0;\r\nsw_desc->async_tx.flags = flags;\r\n}\r\nspin_unlock_bh(&iop_chan->lock);\r\nreturn sw_desc ? &sw_desc->async_tx : NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\niop_adma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dma_dest,\r\ndma_addr_t dma_src, size_t len, unsigned long flags)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *sw_desc, *grp_start;\r\nint slot_cnt, slots_per_op;\r\nif (unlikely(!len))\r\nreturn NULL;\r\nBUG_ON(len > IOP_ADMA_MAX_BYTE_COUNT);\r\ndev_dbg(iop_chan->device->common.dev, "%s len: %u\n",\r\n__func__, len);\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_memcpy_slot_count(len, &slots_per_op);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\ngrp_start = sw_desc->group_head;\r\niop_desc_init_memcpy(grp_start, flags);\r\niop_desc_set_byte_count(grp_start, iop_chan, len);\r\niop_desc_set_dest_addr(grp_start, iop_chan, dma_dest);\r\niop_desc_set_memcpy_src_addr(grp_start, dma_src);\r\nsw_desc->unmap_src_cnt = 1;\r\nsw_desc->unmap_len = len;\r\nsw_desc->async_tx.flags = flags;\r\n}\r\nspin_unlock_bh(&iop_chan->lock);\r\nreturn sw_desc ? &sw_desc->async_tx : NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\niop_adma_prep_dma_memset(struct dma_chan *chan, dma_addr_t dma_dest,\r\nint value, size_t len, unsigned long flags)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *sw_desc, *grp_start;\r\nint slot_cnt, slots_per_op;\r\nif (unlikely(!len))\r\nreturn NULL;\r\nBUG_ON(len > IOP_ADMA_MAX_BYTE_COUNT);\r\ndev_dbg(iop_chan->device->common.dev, "%s len: %u\n",\r\n__func__, len);\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_memset_slot_count(len, &slots_per_op);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\ngrp_start = sw_desc->group_head;\r\niop_desc_init_memset(grp_start, flags);\r\niop_desc_set_byte_count(grp_start, iop_chan, len);\r\niop_desc_set_block_fill_val(grp_start, value);\r\niop_desc_set_dest_addr(grp_start, iop_chan, dma_dest);\r\nsw_desc->unmap_src_cnt = 1;\r\nsw_desc->unmap_len = len;\r\nsw_desc->async_tx.flags = flags;\r\n}\r\nspin_unlock_bh(&iop_chan->lock);\r\nreturn sw_desc ? &sw_desc->async_tx : NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\niop_adma_prep_dma_xor(struct dma_chan *chan, dma_addr_t dma_dest,\r\ndma_addr_t *dma_src, unsigned int src_cnt, size_t len,\r\nunsigned long flags)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *sw_desc, *grp_start;\r\nint slot_cnt, slots_per_op;\r\nif (unlikely(!len))\r\nreturn NULL;\r\nBUG_ON(len > IOP_ADMA_XOR_MAX_BYTE_COUNT);\r\ndev_dbg(iop_chan->device->common.dev,\r\n"%s src_cnt: %d len: %u flags: %lx\n",\r\n__func__, src_cnt, len, flags);\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_xor_slot_count(len, src_cnt, &slots_per_op);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\ngrp_start = sw_desc->group_head;\r\niop_desc_init_xor(grp_start, src_cnt, flags);\r\niop_desc_set_byte_count(grp_start, iop_chan, len);\r\niop_desc_set_dest_addr(grp_start, iop_chan, dma_dest);\r\nsw_desc->unmap_src_cnt = src_cnt;\r\nsw_desc->unmap_len = len;\r\nsw_desc->async_tx.flags = flags;\r\nwhile (src_cnt--)\r\niop_desc_set_xor_src_addr(grp_start, src_cnt,\r\ndma_src[src_cnt]);\r\n}\r\nspin_unlock_bh(&iop_chan->lock);\r\nreturn sw_desc ? &sw_desc->async_tx : NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\niop_adma_prep_dma_xor_val(struct dma_chan *chan, dma_addr_t *dma_src,\r\nunsigned int src_cnt, size_t len, u32 *result,\r\nunsigned long flags)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *sw_desc, *grp_start;\r\nint slot_cnt, slots_per_op;\r\nif (unlikely(!len))\r\nreturn NULL;\r\ndev_dbg(iop_chan->device->common.dev, "%s src_cnt: %d len: %u\n",\r\n__func__, src_cnt, len);\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_zero_sum_slot_count(len, src_cnt, &slots_per_op);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\ngrp_start = sw_desc->group_head;\r\niop_desc_init_zero_sum(grp_start, src_cnt, flags);\r\niop_desc_set_zero_sum_byte_count(grp_start, len);\r\ngrp_start->xor_check_result = result;\r\npr_debug("\t%s: grp_start->xor_check_result: %p\n",\r\n__func__, grp_start->xor_check_result);\r\nsw_desc->unmap_src_cnt = src_cnt;\r\nsw_desc->unmap_len = len;\r\nsw_desc->async_tx.flags = flags;\r\nwhile (src_cnt--)\r\niop_desc_set_zero_sum_src_addr(grp_start, src_cnt,\r\ndma_src[src_cnt]);\r\n}\r\nspin_unlock_bh(&iop_chan->lock);\r\nreturn sw_desc ? &sw_desc->async_tx : NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\niop_adma_prep_dma_pq(struct dma_chan *chan, dma_addr_t *dst, dma_addr_t *src,\r\nunsigned int src_cnt, const unsigned char *scf, size_t len,\r\nunsigned long flags)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *sw_desc, *g;\r\nint slot_cnt, slots_per_op;\r\nint continue_srcs;\r\nif (unlikely(!len))\r\nreturn NULL;\r\nBUG_ON(len > IOP_ADMA_XOR_MAX_BYTE_COUNT);\r\ndev_dbg(iop_chan->device->common.dev,\r\n"%s src_cnt: %d len: %u flags: %lx\n",\r\n__func__, src_cnt, len, flags);\r\nif (dmaf_p_disabled_continue(flags))\r\ncontinue_srcs = 1+src_cnt;\r\nelse if (dmaf_continue(flags))\r\ncontinue_srcs = 3+src_cnt;\r\nelse\r\ncontinue_srcs = 0+src_cnt;\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_pq_slot_count(len, continue_srcs, &slots_per_op);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\nint i;\r\ng = sw_desc->group_head;\r\niop_desc_set_byte_count(g, iop_chan, len);\r\nif (flags & DMA_PREP_PQ_DISABLE_P)\r\ndst[0] = dst[1] & 0x7;\r\niop_desc_set_pq_addr(g, dst);\r\nsw_desc->unmap_src_cnt = src_cnt;\r\nsw_desc->unmap_len = len;\r\nsw_desc->async_tx.flags = flags;\r\nfor (i = 0; i < src_cnt; i++)\r\niop_desc_set_pq_src_addr(g, i, src[i], scf[i]);\r\nif (dmaf_p_disabled_continue(flags))\r\niop_desc_set_pq_src_addr(g, i++, dst[1], 1);\r\nelse if (dmaf_continue(flags)) {\r\niop_desc_set_pq_src_addr(g, i++, dst[0], 0);\r\niop_desc_set_pq_src_addr(g, i++, dst[1], 1);\r\niop_desc_set_pq_src_addr(g, i++, dst[1], 0);\r\n}\r\niop_desc_init_pq(g, i, flags);\r\n}\r\nspin_unlock_bh(&iop_chan->lock);\r\nreturn sw_desc ? &sw_desc->async_tx : NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\niop_adma_prep_dma_pq_val(struct dma_chan *chan, dma_addr_t *pq, dma_addr_t *src,\r\nunsigned int src_cnt, const unsigned char *scf,\r\nsize_t len, enum sum_check_flags *pqres,\r\nunsigned long flags)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *sw_desc, *g;\r\nint slot_cnt, slots_per_op;\r\nif (unlikely(!len))\r\nreturn NULL;\r\nBUG_ON(len > IOP_ADMA_XOR_MAX_BYTE_COUNT);\r\ndev_dbg(iop_chan->device->common.dev, "%s src_cnt: %d len: %u\n",\r\n__func__, src_cnt, len);\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_pq_zero_sum_slot_count(len, src_cnt + 2, &slots_per_op);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\nint pq_idx = src_cnt;\r\ng = sw_desc->group_head;\r\niop_desc_init_pq_zero_sum(g, src_cnt+2, flags);\r\niop_desc_set_pq_zero_sum_byte_count(g, len);\r\ng->pq_check_result = pqres;\r\npr_debug("\t%s: g->pq_check_result: %p\n",\r\n__func__, g->pq_check_result);\r\nsw_desc->unmap_src_cnt = src_cnt+2;\r\nsw_desc->unmap_len = len;\r\nsw_desc->async_tx.flags = flags;\r\nwhile (src_cnt--)\r\niop_desc_set_pq_zero_sum_src_addr(g, src_cnt,\r\nsrc[src_cnt],\r\nscf[src_cnt]);\r\niop_desc_set_pq_zero_sum_addr(g, pq_idx, src);\r\n}\r\nspin_unlock_bh(&iop_chan->lock);\r\nreturn sw_desc ? &sw_desc->async_tx : NULL;\r\n}\r\nstatic void iop_adma_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nstruct iop_adma_desc_slot *iter, *_iter;\r\nint in_use_descs = 0;\r\niop_adma_slot_cleanup(iop_chan);\r\nspin_lock_bh(&iop_chan->lock);\r\nlist_for_each_entry_safe(iter, _iter, &iop_chan->chain,\r\nchain_node) {\r\nin_use_descs++;\r\nlist_del(&iter->chain_node);\r\n}\r\nlist_for_each_entry_safe_reverse(\r\niter, _iter, &iop_chan->all_slots, slot_node) {\r\nlist_del(&iter->slot_node);\r\nkfree(iter);\r\niop_chan->slots_allocated--;\r\n}\r\niop_chan->last_used = NULL;\r\ndev_dbg(iop_chan->device->common.dev, "%s slots_allocated %d\n",\r\n__func__, iop_chan->slots_allocated);\r\nspin_unlock_bh(&iop_chan->lock);\r\nif (in_use_descs > 1)\r\nprintk(KERN_ERR "IOP: Freeing %d in use descriptors!\n",\r\nin_use_descs - 1);\r\n}\r\nstatic enum dma_status iop_adma_status(struct dma_chan *chan,\r\ndma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\ndma_cookie_t last_used;\r\ndma_cookie_t last_complete;\r\nenum dma_status ret;\r\nlast_used = chan->cookie;\r\nlast_complete = iop_chan->completed_cookie;\r\ndma_set_tx_state(txstate, last_complete, last_used, 0);\r\nret = dma_async_is_complete(cookie, last_complete, last_used);\r\nif (ret == DMA_SUCCESS)\r\nreturn ret;\r\niop_adma_slot_cleanup(iop_chan);\r\nlast_used = chan->cookie;\r\nlast_complete = iop_chan->completed_cookie;\r\ndma_set_tx_state(txstate, last_complete, last_used, 0);\r\nreturn dma_async_is_complete(cookie, last_complete, last_used);\r\n}\r\nstatic irqreturn_t iop_adma_eot_handler(int irq, void *data)\r\n{\r\nstruct iop_adma_chan *chan = data;\r\ndev_dbg(chan->device->common.dev, "%s\n", __func__);\r\ntasklet_schedule(&chan->irq_tasklet);\r\niop_adma_device_clear_eot_status(chan);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t iop_adma_eoc_handler(int irq, void *data)\r\n{\r\nstruct iop_adma_chan *chan = data;\r\ndev_dbg(chan->device->common.dev, "%s\n", __func__);\r\ntasklet_schedule(&chan->irq_tasklet);\r\niop_adma_device_clear_eoc_status(chan);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t iop_adma_err_handler(int irq, void *data)\r\n{\r\nstruct iop_adma_chan *chan = data;\r\nunsigned long status = iop_chan_get_status(chan);\r\ndev_printk(KERN_ERR, chan->device->common.dev,\r\n"error ( %s%s%s%s%s%s%s)\n",\r\niop_is_err_int_parity(status, chan) ? "int_parity " : "",\r\niop_is_err_mcu_abort(status, chan) ? "mcu_abort " : "",\r\niop_is_err_int_tabort(status, chan) ? "int_tabort " : "",\r\niop_is_err_int_mabort(status, chan) ? "int_mabort " : "",\r\niop_is_err_pci_tabort(status, chan) ? "pci_tabort " : "",\r\niop_is_err_pci_mabort(status, chan) ? "pci_mabort " : "",\r\niop_is_err_split_tx(status, chan) ? "split_tx " : "");\r\niop_adma_device_clear_err_status(chan);\r\nBUG();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void iop_adma_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct iop_adma_chan *iop_chan = to_iop_adma_chan(chan);\r\nif (iop_chan->pending) {\r\niop_chan->pending = 0;\r\niop_chan_append(iop_chan);\r\n}\r\n}\r\nstatic int __devinit iop_adma_memcpy_self_test(struct iop_adma_device *device)\r\n{\r\nint i;\r\nvoid *src, *dest;\r\ndma_addr_t src_dma, dest_dma;\r\nstruct dma_chan *dma_chan;\r\ndma_cookie_t cookie;\r\nstruct dma_async_tx_descriptor *tx;\r\nint err = 0;\r\nstruct iop_adma_chan *iop_chan;\r\ndev_dbg(device->common.dev, "%s\n", __func__);\r\nsrc = kmalloc(IOP_ADMA_TEST_SIZE, GFP_KERNEL);\r\nif (!src)\r\nreturn -ENOMEM;\r\ndest = kzalloc(IOP_ADMA_TEST_SIZE, GFP_KERNEL);\r\nif (!dest) {\r\nkfree(src);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < IOP_ADMA_TEST_SIZE; i++)\r\n((u8 *) src)[i] = (u8)i;\r\ndma_chan = container_of(device->common.channels.next,\r\nstruct dma_chan,\r\ndevice_node);\r\nif (iop_adma_alloc_chan_resources(dma_chan) < 1) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ndest_dma = dma_map_single(dma_chan->device->dev, dest,\r\nIOP_ADMA_TEST_SIZE, DMA_FROM_DEVICE);\r\nsrc_dma = dma_map_single(dma_chan->device->dev, src,\r\nIOP_ADMA_TEST_SIZE, DMA_TO_DEVICE);\r\ntx = iop_adma_prep_dma_memcpy(dma_chan, dest_dma, src_dma,\r\nIOP_ADMA_TEST_SIZE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\ncookie = iop_adma_tx_submit(tx);\r\niop_adma_issue_pending(dma_chan);\r\nmsleep(1);\r\nif (iop_adma_status(dma_chan, cookie, NULL) !=\r\nDMA_SUCCESS) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test copy timed out, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\niop_chan = to_iop_adma_chan(dma_chan);\r\ndma_sync_single_for_cpu(&iop_chan->device->pdev->dev, dest_dma,\r\nIOP_ADMA_TEST_SIZE, DMA_FROM_DEVICE);\r\nif (memcmp(src, dest, IOP_ADMA_TEST_SIZE)) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test copy failed compare, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nfree_resources:\r\niop_adma_free_chan_resources(dma_chan);\r\nout:\r\nkfree(src);\r\nkfree(dest);\r\nreturn err;\r\n}\r\nstatic int __devinit\r\niop_adma_xor_val_self_test(struct iop_adma_device *device)\r\n{\r\nint i, src_idx;\r\nstruct page *dest;\r\nstruct page *xor_srcs[IOP_ADMA_NUM_SRC_TEST];\r\nstruct page *zero_sum_srcs[IOP_ADMA_NUM_SRC_TEST + 1];\r\ndma_addr_t dma_srcs[IOP_ADMA_NUM_SRC_TEST + 1];\r\ndma_addr_t dma_addr, dest_dma;\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct dma_chan *dma_chan;\r\ndma_cookie_t cookie;\r\nu8 cmp_byte = 0;\r\nu32 cmp_word;\r\nu32 zero_sum_result;\r\nint err = 0;\r\nstruct iop_adma_chan *iop_chan;\r\ndev_dbg(device->common.dev, "%s\n", __func__);\r\nfor (src_idx = 0; src_idx < IOP_ADMA_NUM_SRC_TEST; src_idx++) {\r\nxor_srcs[src_idx] = alloc_page(GFP_KERNEL);\r\nif (!xor_srcs[src_idx]) {\r\nwhile (src_idx--)\r\n__free_page(xor_srcs[src_idx]);\r\nreturn -ENOMEM;\r\n}\r\n}\r\ndest = alloc_page(GFP_KERNEL);\r\nif (!dest) {\r\nwhile (src_idx--)\r\n__free_page(xor_srcs[src_idx]);\r\nreturn -ENOMEM;\r\n}\r\nfor (src_idx = 0; src_idx < IOP_ADMA_NUM_SRC_TEST; src_idx++) {\r\nu8 *ptr = page_address(xor_srcs[src_idx]);\r\nfor (i = 0; i < PAGE_SIZE; i++)\r\nptr[i] = (1 << src_idx);\r\n}\r\nfor (src_idx = 0; src_idx < IOP_ADMA_NUM_SRC_TEST; src_idx++)\r\ncmp_byte ^= (u8) (1 << src_idx);\r\ncmp_word = (cmp_byte << 24) | (cmp_byte << 16) |\r\n(cmp_byte << 8) | cmp_byte;\r\nmemset(page_address(dest), 0, PAGE_SIZE);\r\ndma_chan = container_of(device->common.channels.next,\r\nstruct dma_chan,\r\ndevice_node);\r\nif (iop_adma_alloc_chan_resources(dma_chan) < 1) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ndest_dma = dma_map_page(dma_chan->device->dev, dest, 0,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\nfor (i = 0; i < IOP_ADMA_NUM_SRC_TEST; i++)\r\ndma_srcs[i] = dma_map_page(dma_chan->device->dev, xor_srcs[i],\r\n0, PAGE_SIZE, DMA_TO_DEVICE);\r\ntx = iop_adma_prep_dma_xor(dma_chan, dest_dma, dma_srcs,\r\nIOP_ADMA_NUM_SRC_TEST, PAGE_SIZE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\ncookie = iop_adma_tx_submit(tx);\r\niop_adma_issue_pending(dma_chan);\r\nmsleep(8);\r\nif (iop_adma_status(dma_chan, cookie, NULL) !=\r\nDMA_SUCCESS) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test xor timed out, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\niop_chan = to_iop_adma_chan(dma_chan);\r\ndma_sync_single_for_cpu(&iop_chan->device->pdev->dev, dest_dma,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\nfor (i = 0; i < (PAGE_SIZE / sizeof(u32)); i++) {\r\nu32 *ptr = page_address(dest);\r\nif (ptr[i] != cmp_word) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test xor failed compare, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\n}\r\ndma_sync_single_for_device(&iop_chan->device->pdev->dev, dest_dma,\r\nPAGE_SIZE, DMA_TO_DEVICE);\r\nif (!dma_has_cap(DMA_XOR_VAL, dma_chan->device->cap_mask))\r\ngoto free_resources;\r\nfor (i = 0; i < IOP_ADMA_NUM_SRC_TEST; i++)\r\nzero_sum_srcs[i] = xor_srcs[i];\r\nzero_sum_srcs[i] = dest;\r\nzero_sum_result = 1;\r\nfor (i = 0; i < IOP_ADMA_NUM_SRC_TEST + 1; i++)\r\ndma_srcs[i] = dma_map_page(dma_chan->device->dev,\r\nzero_sum_srcs[i], 0, PAGE_SIZE,\r\nDMA_TO_DEVICE);\r\ntx = iop_adma_prep_dma_xor_val(dma_chan, dma_srcs,\r\nIOP_ADMA_NUM_SRC_TEST + 1, PAGE_SIZE,\r\n&zero_sum_result,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\ncookie = iop_adma_tx_submit(tx);\r\niop_adma_issue_pending(dma_chan);\r\nmsleep(8);\r\nif (iop_adma_status(dma_chan, cookie, NULL) != DMA_SUCCESS) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test zero sum timed out, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nif (zero_sum_result != 0) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test zero sum failed compare, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\ndma_addr = dma_map_page(dma_chan->device->dev, dest, 0,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\ntx = iop_adma_prep_dma_memset(dma_chan, dma_addr, 0, PAGE_SIZE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\ncookie = iop_adma_tx_submit(tx);\r\niop_adma_issue_pending(dma_chan);\r\nmsleep(8);\r\nif (iop_adma_status(dma_chan, cookie, NULL) != DMA_SUCCESS) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test memset timed out, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nfor (i = 0; i < PAGE_SIZE/sizeof(u32); i++) {\r\nu32 *ptr = page_address(dest);\r\nif (ptr[i]) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test memset failed compare, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\n}\r\nzero_sum_result = 0;\r\nfor (i = 0; i < IOP_ADMA_NUM_SRC_TEST + 1; i++)\r\ndma_srcs[i] = dma_map_page(dma_chan->device->dev,\r\nzero_sum_srcs[i], 0, PAGE_SIZE,\r\nDMA_TO_DEVICE);\r\ntx = iop_adma_prep_dma_xor_val(dma_chan, dma_srcs,\r\nIOP_ADMA_NUM_SRC_TEST + 1, PAGE_SIZE,\r\n&zero_sum_result,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\ncookie = iop_adma_tx_submit(tx);\r\niop_adma_issue_pending(dma_chan);\r\nmsleep(8);\r\nif (iop_adma_status(dma_chan, cookie, NULL) != DMA_SUCCESS) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test non-zero sum timed out, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nif (zero_sum_result != 1) {\r\ndev_printk(KERN_ERR, dma_chan->device->dev,\r\n"Self-test non-zero sum failed compare, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nfree_resources:\r\niop_adma_free_chan_resources(dma_chan);\r\nout:\r\nsrc_idx = IOP_ADMA_NUM_SRC_TEST;\r\nwhile (src_idx--)\r\n__free_page(xor_srcs[src_idx]);\r\n__free_page(dest);\r\nreturn err;\r\n}\r\nstatic int __devinit\r\niop_adma_pq_zero_sum_self_test(struct iop_adma_device *device)\r\n{\r\nstruct page *pq[IOP_ADMA_NUM_SRC_TEST+2+2];\r\nstruct page **pq_hw = &pq[IOP_ADMA_NUM_SRC_TEST+2];\r\nvoid *pq_sw[IOP_ADMA_NUM_SRC_TEST+2];\r\ndma_addr_t pq_src[IOP_ADMA_NUM_SRC_TEST];\r\ndma_addr_t pq_dest[2];\r\nint i;\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct dma_chan *dma_chan;\r\ndma_cookie_t cookie;\r\nu32 zero_sum_result;\r\nint err = 0;\r\nstruct device *dev;\r\ndev_dbg(device->common.dev, "%s\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(pq); i++) {\r\npq[i] = alloc_page(GFP_KERNEL);\r\nif (!pq[i]) {\r\nwhile (i--)\r\n__free_page(pq[i]);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < IOP_ADMA_NUM_SRC_TEST; i++) {\r\npq_sw[i] = page_address(pq[i]);\r\nmemset(pq_sw[i], 0x11111111 * (1<<i), PAGE_SIZE);\r\n}\r\npq_sw[i] = page_address(pq[i]);\r\npq_sw[i+1] = page_address(pq[i+1]);\r\ndma_chan = container_of(device->common.channels.next,\r\nstruct dma_chan,\r\ndevice_node);\r\nif (iop_adma_alloc_chan_resources(dma_chan) < 1) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ndev = dma_chan->device->dev;\r\nmemset(page_address(pq_hw[0]), 0 , PAGE_SIZE);\r\nmemset(page_address(pq_hw[1]), 0 , PAGE_SIZE);\r\npq_dest[0] = dma_map_page(dev, pq_hw[0], 0, PAGE_SIZE, DMA_FROM_DEVICE);\r\npq_dest[1] = dma_map_page(dev, pq_hw[1], 0, PAGE_SIZE, DMA_FROM_DEVICE);\r\nfor (i = 0; i < IOP_ADMA_NUM_SRC_TEST; i++)\r\npq_src[i] = dma_map_page(dev, pq[i], 0, PAGE_SIZE,\r\nDMA_TO_DEVICE);\r\ntx = iop_adma_prep_dma_pq(dma_chan, pq_dest, pq_src,\r\nIOP_ADMA_NUM_SRC_TEST, (u8 *)raid6_gfexp,\r\nPAGE_SIZE,\r\nDMA_PREP_INTERRUPT |\r\nDMA_CTRL_ACK);\r\ncookie = iop_adma_tx_submit(tx);\r\niop_adma_issue_pending(dma_chan);\r\nmsleep(8);\r\nif (iop_adma_status(dma_chan, cookie, NULL) !=\r\nDMA_SUCCESS) {\r\ndev_err(dev, "Self-test pq timed out, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nraid6_call.gen_syndrome(IOP_ADMA_NUM_SRC_TEST+2, PAGE_SIZE, pq_sw);\r\nif (memcmp(pq_sw[IOP_ADMA_NUM_SRC_TEST],\r\npage_address(pq_hw[0]), PAGE_SIZE) != 0) {\r\ndev_err(dev, "Self-test p failed compare, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nif (memcmp(pq_sw[IOP_ADMA_NUM_SRC_TEST+1],\r\npage_address(pq_hw[1]), PAGE_SIZE) != 0) {\r\ndev_err(dev, "Self-test q failed compare, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nfor (i = 0; i < IOP_ADMA_NUM_SRC_TEST + 2; i++)\r\npq_src[i] = dma_map_page(dev, pq[i], 0, PAGE_SIZE,\r\nDMA_TO_DEVICE);\r\nzero_sum_result = ~0;\r\ntx = iop_adma_prep_dma_pq_val(dma_chan, &pq_src[IOP_ADMA_NUM_SRC_TEST],\r\npq_src, IOP_ADMA_NUM_SRC_TEST,\r\nraid6_gfexp, PAGE_SIZE, &zero_sum_result,\r\nDMA_PREP_INTERRUPT|DMA_CTRL_ACK);\r\ncookie = iop_adma_tx_submit(tx);\r\niop_adma_issue_pending(dma_chan);\r\nmsleep(8);\r\nif (iop_adma_status(dma_chan, cookie, NULL) !=\r\nDMA_SUCCESS) {\r\ndev_err(dev, "Self-test pq-zero-sum timed out, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nif (zero_sum_result != 0) {\r\ndev_err(dev, "Self-test pq-zero-sum failed to validate: %x\n",\r\nzero_sum_result);\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\ni = IOP_ADMA_NUM_SRC_TEST;\r\nmemset(pq_sw[i] + 100, 0, 100);\r\nmemset(pq_sw[i+1] + 200, 0, 200);\r\nfor (i = 0; i < IOP_ADMA_NUM_SRC_TEST + 2; i++)\r\npq_src[i] = dma_map_page(dev, pq[i], 0, PAGE_SIZE,\r\nDMA_TO_DEVICE);\r\nzero_sum_result = 0;\r\ntx = iop_adma_prep_dma_pq_val(dma_chan, &pq_src[IOP_ADMA_NUM_SRC_TEST],\r\npq_src, IOP_ADMA_NUM_SRC_TEST,\r\nraid6_gfexp, PAGE_SIZE, &zero_sum_result,\r\nDMA_PREP_INTERRUPT|DMA_CTRL_ACK);\r\ncookie = iop_adma_tx_submit(tx);\r\niop_adma_issue_pending(dma_chan);\r\nmsleep(8);\r\nif (iop_adma_status(dma_chan, cookie, NULL) !=\r\nDMA_SUCCESS) {\r\ndev_err(dev, "Self-test !pq-zero-sum timed out, disabling\n");\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nif (zero_sum_result != (SUM_CHECK_P_RESULT | SUM_CHECK_Q_RESULT)) {\r\ndev_err(dev, "Self-test !pq-zero-sum failed to validate: %x\n",\r\nzero_sum_result);\r\nerr = -ENODEV;\r\ngoto free_resources;\r\n}\r\nfree_resources:\r\niop_adma_free_chan_resources(dma_chan);\r\nout:\r\ni = ARRAY_SIZE(pq);\r\nwhile (i--)\r\n__free_page(pq[i]);\r\nreturn err;\r\n}\r\nstatic int __devexit iop_adma_remove(struct platform_device *dev)\r\n{\r\nstruct iop_adma_device *device = platform_get_drvdata(dev);\r\nstruct dma_chan *chan, *_chan;\r\nstruct iop_adma_chan *iop_chan;\r\nstruct iop_adma_platform_data *plat_data = dev->dev.platform_data;\r\ndma_async_device_unregister(&device->common);\r\ndma_free_coherent(&dev->dev, plat_data->pool_size,\r\ndevice->dma_desc_pool_virt, device->dma_desc_pool);\r\nlist_for_each_entry_safe(chan, _chan, &device->common.channels,\r\ndevice_node) {\r\niop_chan = to_iop_adma_chan(chan);\r\nlist_del(&chan->device_node);\r\nkfree(iop_chan);\r\n}\r\nkfree(device);\r\nreturn 0;\r\n}\r\nstatic int __devinit iop_adma_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint ret = 0, i;\r\nstruct iop_adma_device *adev;\r\nstruct iop_adma_chan *iop_chan;\r\nstruct dma_device *dma_dev;\r\nstruct iop_adma_platform_data *plat_data = pdev->dev.platform_data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), pdev->name))\r\nreturn -EBUSY;\r\nadev = kzalloc(sizeof(*adev), GFP_KERNEL);\r\nif (!adev)\r\nreturn -ENOMEM;\r\ndma_dev = &adev->common;\r\nif ((adev->dma_desc_pool_virt = dma_alloc_writecombine(&pdev->dev,\r\nplat_data->pool_size,\r\n&adev->dma_desc_pool,\r\nGFP_KERNEL)) == NULL) {\r\nret = -ENOMEM;\r\ngoto err_free_adev;\r\n}\r\ndev_dbg(&pdev->dev, "%s: allocted descriptor pool virt %p phys %p\n",\r\n__func__, adev->dma_desc_pool_virt,\r\n(void *) adev->dma_desc_pool);\r\nadev->id = plat_data->hw_id;\r\ndma_dev->cap_mask = plat_data->cap_mask;\r\nadev->pdev = pdev;\r\nplatform_set_drvdata(pdev, adev);\r\nINIT_LIST_HEAD(&dma_dev->channels);\r\ndma_dev->device_alloc_chan_resources = iop_adma_alloc_chan_resources;\r\ndma_dev->device_free_chan_resources = iop_adma_free_chan_resources;\r\ndma_dev->device_tx_status = iop_adma_status;\r\ndma_dev->device_issue_pending = iop_adma_issue_pending;\r\ndma_dev->dev = &pdev->dev;\r\nif (dma_has_cap(DMA_MEMCPY, dma_dev->cap_mask))\r\ndma_dev->device_prep_dma_memcpy = iop_adma_prep_dma_memcpy;\r\nif (dma_has_cap(DMA_MEMSET, dma_dev->cap_mask))\r\ndma_dev->device_prep_dma_memset = iop_adma_prep_dma_memset;\r\nif (dma_has_cap(DMA_XOR, dma_dev->cap_mask)) {\r\ndma_dev->max_xor = iop_adma_get_max_xor();\r\ndma_dev->device_prep_dma_xor = iop_adma_prep_dma_xor;\r\n}\r\nif (dma_has_cap(DMA_XOR_VAL, dma_dev->cap_mask))\r\ndma_dev->device_prep_dma_xor_val =\r\niop_adma_prep_dma_xor_val;\r\nif (dma_has_cap(DMA_PQ, dma_dev->cap_mask)) {\r\ndma_set_maxpq(dma_dev, iop_adma_get_max_pq(), 0);\r\ndma_dev->device_prep_dma_pq = iop_adma_prep_dma_pq;\r\n}\r\nif (dma_has_cap(DMA_PQ_VAL, dma_dev->cap_mask))\r\ndma_dev->device_prep_dma_pq_val =\r\niop_adma_prep_dma_pq_val;\r\nif (dma_has_cap(DMA_INTERRUPT, dma_dev->cap_mask))\r\ndma_dev->device_prep_dma_interrupt =\r\niop_adma_prep_dma_interrupt;\r\niop_chan = kzalloc(sizeof(*iop_chan), GFP_KERNEL);\r\nif (!iop_chan) {\r\nret = -ENOMEM;\r\ngoto err_free_dma;\r\n}\r\niop_chan->device = adev;\r\niop_chan->mmr_base = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!iop_chan->mmr_base) {\r\nret = -ENOMEM;\r\ngoto err_free_iop_chan;\r\n}\r\ntasklet_init(&iop_chan->irq_tasklet, iop_adma_tasklet, (unsigned long)\r\niop_chan);\r\niop_adma_device_clear_err_status(iop_chan);\r\nfor (i = 0; i < 3; i++) {\r\nirq_handler_t handler[] = { iop_adma_eot_handler,\r\niop_adma_eoc_handler,\r\niop_adma_err_handler };\r\nint irq = platform_get_irq(pdev, i);\r\nif (irq < 0) {\r\nret = -ENXIO;\r\ngoto err_free_iop_chan;\r\n} else {\r\nret = devm_request_irq(&pdev->dev, irq,\r\nhandler[i], 0, pdev->name, iop_chan);\r\nif (ret)\r\ngoto err_free_iop_chan;\r\n}\r\n}\r\nspin_lock_init(&iop_chan->lock);\r\nINIT_LIST_HEAD(&iop_chan->chain);\r\nINIT_LIST_HEAD(&iop_chan->all_slots);\r\niop_chan->common.device = dma_dev;\r\nlist_add_tail(&iop_chan->common.device_node, &dma_dev->channels);\r\nif (dma_has_cap(DMA_MEMCPY, dma_dev->cap_mask)) {\r\nret = iop_adma_memcpy_self_test(adev);\r\ndev_dbg(&pdev->dev, "memcpy self test returned %d\n", ret);\r\nif (ret)\r\ngoto err_free_iop_chan;\r\n}\r\nif (dma_has_cap(DMA_XOR, dma_dev->cap_mask) ||\r\ndma_has_cap(DMA_MEMSET, dma_dev->cap_mask)) {\r\nret = iop_adma_xor_val_self_test(adev);\r\ndev_dbg(&pdev->dev, "xor self test returned %d\n", ret);\r\nif (ret)\r\ngoto err_free_iop_chan;\r\n}\r\nif (dma_has_cap(DMA_PQ, dma_dev->cap_mask) &&\r\ndma_has_cap(DMA_PQ_VAL, dma_dev->cap_mask)) {\r\n#ifdef CONFIG_RAID6_PQ\r\nret = iop_adma_pq_zero_sum_self_test(adev);\r\ndev_dbg(&pdev->dev, "pq self test returned %d\n", ret);\r\n#else\r\ndma_cap_clear(DMA_PQ, dma_dev->cap_mask);\r\ndma_cap_clear(DMA_PQ_VAL, dma_dev->cap_mask);\r\nret = 0;\r\n#endif\r\nif (ret)\r\ngoto err_free_iop_chan;\r\n}\r\ndev_printk(KERN_INFO, &pdev->dev, "Intel(R) IOP: "\r\n"( %s%s%s%s%s%s%s)\n",\r\ndma_has_cap(DMA_PQ, dma_dev->cap_mask) ? "pq " : "",\r\ndma_has_cap(DMA_PQ_VAL, dma_dev->cap_mask) ? "pq_val " : "",\r\ndma_has_cap(DMA_XOR, dma_dev->cap_mask) ? "xor " : "",\r\ndma_has_cap(DMA_XOR_VAL, dma_dev->cap_mask) ? "xor_val " : "",\r\ndma_has_cap(DMA_MEMSET, dma_dev->cap_mask) ? "fill " : "",\r\ndma_has_cap(DMA_MEMCPY, dma_dev->cap_mask) ? "cpy " : "",\r\ndma_has_cap(DMA_INTERRUPT, dma_dev->cap_mask) ? "intr " : "");\r\ndma_async_device_register(dma_dev);\r\ngoto out;\r\nerr_free_iop_chan:\r\nkfree(iop_chan);\r\nerr_free_dma:\r\ndma_free_coherent(&adev->pdev->dev, plat_data->pool_size,\r\nadev->dma_desc_pool_virt, adev->dma_desc_pool);\r\nerr_free_adev:\r\nkfree(adev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void iop_chan_start_null_memcpy(struct iop_adma_chan *iop_chan)\r\n{\r\nstruct iop_adma_desc_slot *sw_desc, *grp_start;\r\ndma_cookie_t cookie;\r\nint slot_cnt, slots_per_op;\r\ndev_dbg(iop_chan->device->common.dev, "%s\n", __func__);\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_memcpy_slot_count(0, &slots_per_op);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\ngrp_start = sw_desc->group_head;\r\nlist_splice_init(&sw_desc->tx_list, &iop_chan->chain);\r\nasync_tx_ack(&sw_desc->async_tx);\r\niop_desc_init_memcpy(grp_start, 0);\r\niop_desc_set_byte_count(grp_start, iop_chan, 0);\r\niop_desc_set_dest_addr(grp_start, iop_chan, 0);\r\niop_desc_set_memcpy_src_addr(grp_start, 0);\r\ncookie = iop_chan->common.cookie;\r\ncookie++;\r\nif (cookie <= 1)\r\ncookie = 2;\r\niop_chan->completed_cookie = cookie - 1;\r\niop_chan->common.cookie = sw_desc->async_tx.cookie = cookie;\r\nBUG_ON(iop_chan_is_busy(iop_chan));\r\niop_adma_device_clear_err_status(iop_chan);\r\niop_chan_disable(iop_chan);\r\niop_chan_set_next_descriptor(iop_chan, sw_desc->async_tx.phys);\r\nBUG_ON(iop_desc_get_next_desc(sw_desc));\r\niop_chan_enable(iop_chan);\r\n} else\r\ndev_printk(KERN_ERR, iop_chan->device->common.dev,\r\n"failed to allocate null descriptor\n");\r\nspin_unlock_bh(&iop_chan->lock);\r\n}\r\nstatic void iop_chan_start_null_xor(struct iop_adma_chan *iop_chan)\r\n{\r\nstruct iop_adma_desc_slot *sw_desc, *grp_start;\r\ndma_cookie_t cookie;\r\nint slot_cnt, slots_per_op;\r\ndev_dbg(iop_chan->device->common.dev, "%s\n", __func__);\r\nspin_lock_bh(&iop_chan->lock);\r\nslot_cnt = iop_chan_xor_slot_count(0, 2, &slots_per_op);\r\nsw_desc = iop_adma_alloc_slots(iop_chan, slot_cnt, slots_per_op);\r\nif (sw_desc) {\r\ngrp_start = sw_desc->group_head;\r\nlist_splice_init(&sw_desc->tx_list, &iop_chan->chain);\r\nasync_tx_ack(&sw_desc->async_tx);\r\niop_desc_init_null_xor(grp_start, 2, 0);\r\niop_desc_set_byte_count(grp_start, iop_chan, 0);\r\niop_desc_set_dest_addr(grp_start, iop_chan, 0);\r\niop_desc_set_xor_src_addr(grp_start, 0, 0);\r\niop_desc_set_xor_src_addr(grp_start, 1, 0);\r\ncookie = iop_chan->common.cookie;\r\ncookie++;\r\nif (cookie <= 1)\r\ncookie = 2;\r\niop_chan->completed_cookie = cookie - 1;\r\niop_chan->common.cookie = sw_desc->async_tx.cookie = cookie;\r\nBUG_ON(iop_chan_is_busy(iop_chan));\r\niop_adma_device_clear_err_status(iop_chan);\r\niop_chan_disable(iop_chan);\r\niop_chan_set_next_descriptor(iop_chan, sw_desc->async_tx.phys);\r\nBUG_ON(iop_desc_get_next_desc(sw_desc));\r\niop_chan_enable(iop_chan);\r\n} else\r\ndev_printk(KERN_ERR, iop_chan->device->common.dev,\r\n"failed to allocate null descriptor\n");\r\nspin_unlock_bh(&iop_chan->lock);\r\n}\r\nstatic int __init iop_adma_init (void)\r\n{\r\nreturn platform_driver_register(&iop_adma_driver);\r\n}\r\nstatic void __exit iop_adma_exit (void)\r\n{\r\nplatform_driver_unregister(&iop_adma_driver);\r\nreturn;\r\n}
