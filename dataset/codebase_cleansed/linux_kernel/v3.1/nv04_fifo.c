void\r\nnv04_fifo_disable(struct drm_device *dev)\r\n{\r\nuint32_t tmp;\r\ntmp = nv_rd32(dev, NV04_PFIFO_CACHE1_DMA_PUSH);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_PUSH, tmp & ~1);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0, 0);\r\ntmp = nv_rd32(dev, NV03_PFIFO_CACHE1_PULL1);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, tmp & ~1);\r\n}\r\nvoid\r\nnv04_fifo_enable(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0, 1);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, 1);\r\n}\r\nbool\r\nnv04_fifo_reassign(struct drm_device *dev, bool enable)\r\n{\r\nuint32_t reassign = nv_rd32(dev, NV03_PFIFO_CACHES);\r\nnv_wr32(dev, NV03_PFIFO_CACHES, enable ? 1 : 0);\r\nreturn (reassign == 1);\r\n}\r\nbool\r\nnv04_fifo_cache_pull(struct drm_device *dev, bool enable)\r\n{\r\nint pull = nv_mask(dev, NV04_PFIFO_CACHE1_PULL0, 1, enable);\r\nif (!enable) {\r\nif (!nv_wait(dev, NV04_PFIFO_CACHE1_PULL0,\r\nNV04_PFIFO_CACHE1_PULL0_HASH_BUSY, 0))\r\nNV_ERROR(dev, "Timeout idling the PFIFO puller.\n");\r\nif (nv_rd32(dev, NV04_PFIFO_CACHE1_PULL0) &\r\nNV04_PFIFO_CACHE1_PULL0_HASH_FAILED)\r\nnv_wr32(dev, NV03_PFIFO_INTR_0,\r\nNV_PFIFO_INTR_CACHE_ERROR);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_HASH, 0);\r\n}\r\nreturn pull & 1;\r\n}\r\nint\r\nnv04_fifo_channel_id(struct drm_device *dev)\r\n{\r\nreturn nv_rd32(dev, NV03_PFIFO_CACHE1_PUSH1) &\r\nNV03_PFIFO_CACHE1_PUSH1_CHID_MASK;\r\n}\r\nint\r\nnv04_fifo_create_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nunsigned long flags;\r\nint ret;\r\nret = nouveau_gpuobj_new_fake(dev, NV04_RAMFC(chan->id), ~0,\r\nNV04_RAMFC__SIZE,\r\nNVOBJ_FLAG_ZERO_ALLOC |\r\nNVOBJ_FLAG_ZERO_FREE,\r\n&chan->ramfc);\r\nif (ret)\r\nreturn ret;\r\nchan->user = ioremap(pci_resource_start(dev->pdev, 0) +\r\nNV03_USER(chan->id), PAGE_SIZE);\r\nif (!chan->user)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nRAMFC_WR(DMA_PUT, chan->pushbuf_base);\r\nRAMFC_WR(DMA_GET, chan->pushbuf_base);\r\nRAMFC_WR(DMA_INSTANCE, chan->pushbuf->pinst >> 4);\r\nRAMFC_WR(DMA_FETCH, (NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |\r\nNV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |\r\nNV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8 |\r\nDMA_FETCH_ENDIANNESS));\r\nnv_wr32(dev, NV04_PFIFO_MODE,\r\nnv_rd32(dev, NV04_PFIFO_MODE) | (1 << chan->id));\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_fifo_destroy_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\npfifo->reassign(dev, false);\r\nif (pfifo->channel_id(dev) == chan->id) {\r\npfifo->disable(dev);\r\npfifo->unload_context(dev);\r\npfifo->enable(dev);\r\n}\r\nnv_mask(dev, NV04_PFIFO_MODE, 1 << chan->id, 0);\r\npfifo->reassign(dev, true);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nif (chan->user) {\r\niounmap(chan->user);\r\nchan->user = NULL;\r\n}\r\nnouveau_gpuobj_ref(NULL, &chan->ramfc);\r\n}\r\nstatic void\r\nnv04_fifo_do_load_context(struct drm_device *dev, int chid)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nuint32_t fc = NV04_RAMFC(chid), tmp;\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_PUT, nv_ri32(dev, fc + 0));\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_GET, nv_ri32(dev, fc + 4));\r\ntmp = nv_ri32(dev, fc + 8);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_INSTANCE, tmp & 0xFFFF);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_DCOUNT, tmp >> 16);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_STATE, nv_ri32(dev, fc + 12));\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_FETCH, nv_ri32(dev, fc + 16));\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_ENGINE, nv_ri32(dev, fc + 20));\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL1, nv_ri32(dev, fc + 24));\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_GET, 0);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUT, 0);\r\n}\r\nint\r\nnv04_fifo_load_context(struct nouveau_channel *chan)\r\n{\r\nuint32_t tmp;\r\nnv_wr32(chan->dev, NV03_PFIFO_CACHE1_PUSH1,\r\nNV03_PFIFO_CACHE1_PUSH1_DMA | chan->id);\r\nnv04_fifo_do_load_context(chan->dev, chan->id);\r\nnv_wr32(chan->dev, NV04_PFIFO_CACHE1_DMA_PUSH, 1);\r\ntmp = nv_rd32(chan->dev, NV04_PFIFO_CACHE1_DMA_CTL) & ~(1 << 31);\r\nnv_wr32(chan->dev, NV04_PFIFO_CACHE1_DMA_CTL, tmp);\r\nreturn 0;\r\n}\r\nint\r\nnv04_fifo_unload_context(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nstruct nouveau_channel *chan = NULL;\r\nuint32_t tmp;\r\nint chid;\r\nchid = pfifo->channel_id(dev);\r\nif (chid < 0 || chid >= dev_priv->engine.fifo.channels)\r\nreturn 0;\r\nchan = dev_priv->channels.ptr[chid];\r\nif (!chan) {\r\nNV_ERROR(dev, "Inactive channel on PFIFO: %d\n", chid);\r\nreturn -EINVAL;\r\n}\r\nRAMFC_WR(DMA_PUT, nv_rd32(dev, NV04_PFIFO_CACHE1_DMA_PUT));\r\nRAMFC_WR(DMA_GET, nv_rd32(dev, NV04_PFIFO_CACHE1_DMA_GET));\r\ntmp = nv_rd32(dev, NV04_PFIFO_CACHE1_DMA_DCOUNT) << 16;\r\ntmp |= nv_rd32(dev, NV04_PFIFO_CACHE1_DMA_INSTANCE);\r\nRAMFC_WR(DMA_INSTANCE, tmp);\r\nRAMFC_WR(DMA_STATE, nv_rd32(dev, NV04_PFIFO_CACHE1_DMA_STATE));\r\nRAMFC_WR(DMA_FETCH, nv_rd32(dev, NV04_PFIFO_CACHE1_DMA_FETCH));\r\nRAMFC_WR(ENGINE, nv_rd32(dev, NV04_PFIFO_CACHE1_ENGINE));\r\nRAMFC_WR(PULL1_ENGINE, nv_rd32(dev, NV04_PFIFO_CACHE1_PULL1));\r\nnv04_fifo_do_load_context(dev, pfifo->channels - 1);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH1, pfifo->channels - 1);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv04_fifo_init_reset(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, NV03_PMC_ENABLE,\r\nnv_rd32(dev, NV03_PMC_ENABLE) & ~NV_PMC_ENABLE_PFIFO);\r\nnv_wr32(dev, NV03_PMC_ENABLE,\r\nnv_rd32(dev, NV03_PMC_ENABLE) | NV_PMC_ENABLE_PFIFO);\r\nnv_wr32(dev, 0x003224, 0x000f0078);\r\nnv_wr32(dev, 0x002044, 0x0101ffff);\r\nnv_wr32(dev, 0x002040, 0x000000ff);\r\nnv_wr32(dev, 0x002500, 0x00000000);\r\nnv_wr32(dev, 0x003000, 0x00000000);\r\nnv_wr32(dev, 0x003050, 0x00000000);\r\nnv_wr32(dev, 0x003200, 0x00000000);\r\nnv_wr32(dev, 0x003250, 0x00000000);\r\nnv_wr32(dev, 0x003220, 0x00000000);\r\nnv_wr32(dev, 0x003250, 0x00000000);\r\nnv_wr32(dev, 0x003270, 0x00000000);\r\nnv_wr32(dev, 0x003210, 0x00000000);\r\n}\r\nstatic void\r\nnv04_fifo_init_ramxx(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nnv_wr32(dev, NV03_PFIFO_RAMHT, (0x03 << 24) |\r\n((dev_priv->ramht->bits - 9) << 16) |\r\n(dev_priv->ramht->gpuobj->pinst >> 8));\r\nnv_wr32(dev, NV03_PFIFO_RAMRO, dev_priv->ramro->pinst >> 8);\r\nnv_wr32(dev, NV03_PFIFO_RAMFC, dev_priv->ramfc->pinst >> 8);\r\n}\r\nstatic void\r\nnv04_fifo_init_intr(struct drm_device *dev)\r\n{\r\nnouveau_irq_register(dev, 8, nv04_fifo_isr);\r\nnv_wr32(dev, 0x002100, 0xffffffff);\r\nnv_wr32(dev, 0x002140, 0xffffffff);\r\n}\r\nint\r\nnv04_fifo_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nint i;\r\nnv04_fifo_init_reset(dev);\r\nnv04_fifo_init_ramxx(dev);\r\nnv04_fifo_do_load_context(dev, pfifo->channels - 1);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH1, pfifo->channels - 1);\r\nnv04_fifo_init_intr(dev);\r\npfifo->enable(dev);\r\npfifo->reassign(dev, true);\r\nfor (i = 0; i < dev_priv->engine.fifo.channels; i++) {\r\nif (dev_priv->channels.ptr[i]) {\r\nuint32_t mode = nv_rd32(dev, NV04_PFIFO_MODE);\r\nnv_wr32(dev, NV04_PFIFO_MODE, mode | (1 << i));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_fifo_fini(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, 0x2140, 0x00000000);\r\nnouveau_irq_unregister(dev, 8);\r\n}\r\nstatic bool\r\nnouveau_fifo_swmthd(struct drm_device *dev, u32 chid, u32 addr, u32 data)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_channel *chan = NULL;\r\nstruct nouveau_gpuobj *obj;\r\nunsigned long flags;\r\nconst int subc = (addr >> 13) & 0x7;\r\nconst int mthd = addr & 0x1ffc;\r\nbool handled = false;\r\nu32 engine;\r\nspin_lock_irqsave(&dev_priv->channels.lock, flags);\r\nif (likely(chid >= 0 && chid < dev_priv->engine.fifo.channels))\r\nchan = dev_priv->channels.ptr[chid];\r\nif (unlikely(!chan))\r\ngoto out;\r\nswitch (mthd) {\r\ncase 0x0000:\r\nobj = nouveau_ramht_find(chan, data);\r\nif (unlikely(!obj || obj->engine != NVOBJ_ENGINE_SW))\r\nbreak;\r\nchan->sw_subchannel[subc] = obj->class;\r\nengine = 0x0000000f << (subc * 4);\r\nnv_mask(dev, NV04_PFIFO_CACHE1_ENGINE, engine, 0x00000000);\r\nhandled = true;\r\nbreak;\r\ndefault:\r\nengine = nv_rd32(dev, NV04_PFIFO_CACHE1_ENGINE);\r\nif (unlikely(((engine >> (subc * 4)) & 0xf) != 0))\r\nbreak;\r\nif (!nouveau_gpuobj_mthd_call(chan, chan->sw_subchannel[subc],\r\nmthd, data))\r\nhandled = true;\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&dev_priv->channels.lock, flags);\r\nreturn handled;\r\n}\r\nstatic const char *nv_dma_state_err(u32 state)\r\n{\r\nstatic const char * const desc[] = {\r\n"NONE", "CALL_SUBR_ACTIVE", "INVALID_MTHD", "RET_SUBR_INACTIVE",\r\n"INVALID_CMD", "IB_EMPTY", "MEM_FAULT", "UNK"\r\n};\r\nreturn desc[(state >> 29) & 0x7];\r\n}\r\nvoid\r\nnv04_fifo_isr(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_engine *engine = &dev_priv->engine;\r\nuint32_t status, reassign;\r\nint cnt = 0;\r\nreassign = nv_rd32(dev, NV03_PFIFO_CACHES) & 1;\r\nwhile ((status = nv_rd32(dev, NV03_PFIFO_INTR_0)) && (cnt++ < 100)) {\r\nuint32_t chid, get;\r\nnv_wr32(dev, NV03_PFIFO_CACHES, 0);\r\nchid = engine->fifo.channel_id(dev);\r\nget = nv_rd32(dev, NV03_PFIFO_CACHE1_GET);\r\nif (status & NV_PFIFO_INTR_CACHE_ERROR) {\r\nuint32_t mthd, data;\r\nint ptr;\r\nptr = (get & 0x7ff) >> 2;\r\nif (dev_priv->card_type < NV_40) {\r\nmthd = nv_rd32(dev,\r\nNV04_PFIFO_CACHE1_METHOD(ptr));\r\ndata = nv_rd32(dev,\r\nNV04_PFIFO_CACHE1_DATA(ptr));\r\n} else {\r\nmthd = nv_rd32(dev,\r\nNV40_PFIFO_CACHE1_METHOD(ptr));\r\ndata = nv_rd32(dev,\r\nNV40_PFIFO_CACHE1_DATA(ptr));\r\n}\r\nif (!nouveau_fifo_swmthd(dev, chid, mthd, data)) {\r\nNV_INFO(dev, "PFIFO_CACHE_ERROR - Ch %d/%d "\r\n"Mthd 0x%04x Data 0x%08x\n",\r\nchid, (mthd >> 13) & 7, mthd & 0x1ffc,\r\ndata);\r\n}\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_PUSH, 0);\r\nnv_wr32(dev, NV03_PFIFO_INTR_0,\r\nNV_PFIFO_INTR_CACHE_ERROR);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0,\r\nnv_rd32(dev, NV03_PFIFO_CACHE1_PUSH0) & ~1);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_GET, get + 4);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0,\r\nnv_rd32(dev, NV03_PFIFO_CACHE1_PUSH0) | 1);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_HASH, 0);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_PUSH,\r\nnv_rd32(dev, NV04_PFIFO_CACHE1_DMA_PUSH) | 1);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, 1);\r\nstatus &= ~NV_PFIFO_INTR_CACHE_ERROR;\r\n}\r\nif (status & NV_PFIFO_INTR_DMA_PUSHER) {\r\nu32 dma_get = nv_rd32(dev, 0x003244);\r\nu32 dma_put = nv_rd32(dev, 0x003240);\r\nu32 push = nv_rd32(dev, 0x003220);\r\nu32 state = nv_rd32(dev, 0x003228);\r\nif (dev_priv->card_type == NV_50) {\r\nu32 ho_get = nv_rd32(dev, 0x003328);\r\nu32 ho_put = nv_rd32(dev, 0x003320);\r\nu32 ib_get = nv_rd32(dev, 0x003334);\r\nu32 ib_put = nv_rd32(dev, 0x003330);\r\nif (nouveau_ratelimit())\r\nNV_INFO(dev, "PFIFO_DMA_PUSHER - Ch %d Get 0x%02x%08x "\r\n"Put 0x%02x%08x IbGet 0x%08x IbPut 0x%08x "\r\n"State 0x%08x (err: %s) Push 0x%08x\n",\r\nchid, ho_get, dma_get, ho_put,\r\ndma_put, ib_get, ib_put, state,\r\nnv_dma_state_err(state),\r\npush);\r\nnv_wr32(dev, 0x003364, 0x00000000);\r\nif (dma_get != dma_put || ho_get != ho_put) {\r\nnv_wr32(dev, 0x003244, dma_put);\r\nnv_wr32(dev, 0x003328, ho_put);\r\n} else\r\nif (ib_get != ib_put) {\r\nnv_wr32(dev, 0x003334, ib_put);\r\n}\r\n} else {\r\nNV_INFO(dev, "PFIFO_DMA_PUSHER - Ch %d Get 0x%08x "\r\n"Put 0x%08x State 0x%08x (err: %s) Push 0x%08x\n",\r\nchid, dma_get, dma_put, state,\r\nnv_dma_state_err(state), push);\r\nif (dma_get != dma_put)\r\nnv_wr32(dev, 0x003244, dma_put);\r\n}\r\nnv_wr32(dev, 0x003228, 0x00000000);\r\nnv_wr32(dev, 0x003220, 0x00000001);\r\nnv_wr32(dev, 0x002100, NV_PFIFO_INTR_DMA_PUSHER);\r\nstatus &= ~NV_PFIFO_INTR_DMA_PUSHER;\r\n}\r\nif (status & NV_PFIFO_INTR_SEMAPHORE) {\r\nuint32_t sem;\r\nstatus &= ~NV_PFIFO_INTR_SEMAPHORE;\r\nnv_wr32(dev, NV03_PFIFO_INTR_0,\r\nNV_PFIFO_INTR_SEMAPHORE);\r\nsem = nv_rd32(dev, NV10_PFIFO_CACHE1_SEMAPHORE);\r\nnv_wr32(dev, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_GET, get + 4);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, 1);\r\n}\r\nif (dev_priv->card_type == NV_50) {\r\nif (status & 0x00000010) {\r\nnv50_fb_vm_trap(dev, nouveau_ratelimit());\r\nstatus &= ~0x00000010;\r\nnv_wr32(dev, 0x002100, 0x00000010);\r\n}\r\n}\r\nif (status) {\r\nif (nouveau_ratelimit())\r\nNV_INFO(dev, "PFIFO_INTR 0x%08x - Ch %d\n",\r\nstatus, chid);\r\nnv_wr32(dev, NV03_PFIFO_INTR_0, status);\r\nstatus = 0;\r\n}\r\nnv_wr32(dev, NV03_PFIFO_CACHES, reassign);\r\n}\r\nif (status) {\r\nNV_INFO(dev, "PFIFO still angry after %d spins, halt\n", cnt);\r\nnv_wr32(dev, 0x2140, 0);\r\nnv_wr32(dev, 0x140, 0);\r\n}\r\nnv_wr32(dev, NV03_PMC_INTR_0, NV_PMC_INTR_0_PFIFO_PENDING);\r\n}
