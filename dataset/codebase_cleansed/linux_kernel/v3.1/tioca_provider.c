static int\r\ntioca_gart_init(struct tioca_kernel *tioca_kern)\r\n{\r\nu64 ap_reg;\r\nu64 offset;\r\nstruct page *tmp;\r\nstruct tioca_common *tioca_common;\r\nstruct tioca __iomem *ca_base;\r\ntioca_common = tioca_kern->ca_common;\r\nca_base = (struct tioca __iomem *)tioca_common->ca_common.bs_base;\r\nif (list_empty(tioca_kern->ca_devices))\r\nreturn 0;\r\nap_reg = 0;\r\nswitch (CA_APERATURE_SIZE >> 20) {\r\ncase 4:\r\nap_reg |= (0x3ff << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 8:\r\nap_reg |= (0x3fe << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 16:\r\nap_reg |= (0x3fc << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 32:\r\nap_reg |= (0x3f8 << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 64:\r\nap_reg |= (0x3f0 << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 128:\r\nap_reg |= (0x3e0 << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 256:\r\nap_reg |= (0x3c0 << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 512:\r\nap_reg |= (0x380 << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 1024:\r\nap_reg |= (0x300 << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 2048:\r\nap_reg |= (0x200 << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ncase 4096:\r\nap_reg |= (0x000 << CA_GART_AP_SIZE_SHFT);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: Invalid CA_APERATURE_SIZE "\r\n"0x%lx\n", __func__, (ulong) CA_APERATURE_SIZE);\r\nreturn -1;\r\n}\r\nif (PAGE_SIZE >= 16384) {\r\ntioca_kern->ca_ap_pagesize = 16384;\r\nap_reg |= CA_GART_PAGE_SIZE;\r\n} else {\r\ntioca_kern->ca_ap_pagesize = 4096;\r\n}\r\ntioca_kern->ca_ap_size = CA_APERATURE_SIZE;\r\ntioca_kern->ca_ap_bus_base = CA_APERATURE_BASE;\r\ntioca_kern->ca_gart_entries =\r\ntioca_kern->ca_ap_size / tioca_kern->ca_ap_pagesize;\r\nap_reg |= (CA_GART_AP_ENB_AGP | CA_GART_AP_ENB_PCI);\r\nap_reg |= tioca_kern->ca_ap_bus_base;\r\ntioca_kern->ca_gart_size = tioca_kern->ca_gart_entries * sizeof(u64);\r\ntmp =\r\nalloc_pages_node(tioca_kern->ca_closest_node,\r\nGFP_KERNEL | __GFP_ZERO,\r\nget_order(tioca_kern->ca_gart_size));\r\nif (!tmp) {\r\nprintk(KERN_ERR "%s: Could not allocate "\r\n"%llu bytes (order %d) for GART\n",\r\n__func__,\r\ntioca_kern->ca_gart_size,\r\nget_order(tioca_kern->ca_gart_size));\r\nreturn -ENOMEM;\r\n}\r\ntioca_kern->ca_gart = page_address(tmp);\r\ntioca_kern->ca_gart_coretalk_addr =\r\nPHYS_TO_TIODMA(virt_to_phys(tioca_kern->ca_gart));\r\noffset = CA_PCI32_MAPPED_BASE - CA_APERATURE_BASE;\r\ntioca_kern->ca_pciap_base = CA_PCI32_MAPPED_BASE;\r\ntioca_kern->ca_pciap_size = CA_PCI32_MAPPED_SIZE;\r\ntioca_kern->ca_pcigart_start = offset / tioca_kern->ca_ap_pagesize;\r\ntioca_kern->ca_pcigart_base =\r\ntioca_kern->ca_gart_coretalk_addr + offset;\r\ntioca_kern->ca_pcigart =\r\n&tioca_kern->ca_gart[tioca_kern->ca_pcigart_start];\r\ntioca_kern->ca_pcigart_entries =\r\ntioca_kern->ca_pciap_size / tioca_kern->ca_ap_pagesize;\r\ntioca_kern->ca_pcigart_pagemap =\r\nkzalloc(tioca_kern->ca_pcigart_entries / 8, GFP_KERNEL);\r\nif (!tioca_kern->ca_pcigart_pagemap) {\r\nfree_pages((unsigned long)tioca_kern->ca_gart,\r\nget_order(tioca_kern->ca_gart_size));\r\nreturn -1;\r\n}\r\noffset = CA_AGP_MAPPED_BASE - CA_APERATURE_BASE;\r\ntioca_kern->ca_gfxap_base = CA_AGP_MAPPED_BASE;\r\ntioca_kern->ca_gfxap_size = CA_AGP_MAPPED_SIZE;\r\ntioca_kern->ca_gfxgart_start = offset / tioca_kern->ca_ap_pagesize;\r\ntioca_kern->ca_gfxgart_base =\r\ntioca_kern->ca_gart_coretalk_addr + offset;\r\ntioca_kern->ca_gfxgart =\r\n&tioca_kern->ca_gart[tioca_kern->ca_gfxgart_start];\r\ntioca_kern->ca_gfxgart_entries =\r\ntioca_kern->ca_gfxap_size / tioca_kern->ca_ap_pagesize;\r\n__sn_setq_relaxed(&ca_base->ca_control1,\r\nCA_AGPDMA_OP_ENB_COMBDELAY);\r\n__sn_clrq_relaxed(&ca_base->ca_control2, CA_GART_MEM_PARAM);\r\n__sn_setq_relaxed(&ca_base->ca_control2,\r\n(0x2ull << CA_GART_MEM_PARAM_SHFT));\r\ntioca_kern->ca_gart_iscoherent = 1;\r\n__sn_clrq_relaxed(&ca_base->ca_control2,\r\n(CA_GART_WR_PREFETCH_ENB | CA_GART_RD_PREFETCH_ENB));\r\nwriteq(CA_GART_FETCH_ERR, &ca_base->ca_int_status_alias);\r\nwriteq(CA_GART_FETCH_ERR, &ca_base->ca_mult_error_alias);\r\n__sn_clrq_relaxed(&ca_base->ca_int_mask, CA_GART_FETCH_ERR);\r\nwriteq(ap_reg, &ca_base->ca_gart_aperature);\r\nwriteq(tioca_kern->ca_gart_coretalk_addr|1, &ca_base->ca_gart_ptr_table);\r\nreturn 0;\r\n}\r\nvoid\r\ntioca_fastwrite_enable(struct tioca_kernel *tioca_kern)\r\n{\r\nint cap_ptr;\r\nu32 reg;\r\nstruct tioca __iomem *tioca_base;\r\nstruct pci_dev *pdev;\r\nstruct tioca_common *common;\r\ncommon = tioca_kern->ca_common;\r\nlist_for_each_entry(pdev, tioca_kern->ca_devices, bus_list) {\r\nif (pdev->class != (PCI_CLASS_DISPLAY_VGA << 8))\r\ncontinue;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn;\r\npci_read_config_dword(pdev, cap_ptr + PCI_AGP_STATUS, &reg);\r\nif (!(reg & PCI_AGP_STATUS_FW))\r\nreturn;\r\n}\r\nlist_for_each_entry(pdev, tioca_kern->ca_devices, bus_list) {\r\nif (pdev->class != (PCI_CLASS_DISPLAY_VGA << 8))\r\ncontinue;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\npci_read_config_dword(pdev, cap_ptr + PCI_AGP_COMMAND, &reg);\r\nreg |= PCI_AGP_COMMAND_FW;\r\npci_write_config_dword(pdev, cap_ptr + PCI_AGP_COMMAND, reg);\r\n}\r\ntioca_base = (struct tioca __iomem*)common->ca_common.bs_base;\r\n__sn_setq_relaxed(&tioca_base->ca_control1, CA_AGP_FW_ENABLE);\r\n}\r\nstatic u64\r\ntioca_dma_d64(unsigned long paddr)\r\n{\r\ndma_addr_t bus_addr;\r\nbus_addr = PHYS_TO_TIODMA(paddr);\r\nBUG_ON(!bus_addr);\r\nBUG_ON(bus_addr >> 54);\r\nbus_addr |= (1UL << 60);\r\nreturn bus_addr;\r\n}\r\nstatic u64\r\ntioca_dma_d48(struct pci_dev *pdev, u64 paddr)\r\n{\r\nstruct tioca_common *tioca_common;\r\nstruct tioca __iomem *ca_base;\r\nu64 ct_addr;\r\ndma_addr_t bus_addr;\r\nu32 node_upper;\r\nu64 agp_dma_extn;\r\nstruct pcidev_info *pcidev_info = SN_PCIDEV_INFO(pdev);\r\ntioca_common = (struct tioca_common *)pcidev_info->pdi_pcibus_info;\r\nca_base = (struct tioca __iomem *)tioca_common->ca_common.bs_base;\r\nct_addr = PHYS_TO_TIODMA(paddr);\r\nif (!ct_addr)\r\nreturn 0;\r\nbus_addr = (dma_addr_t) (ct_addr & 0xffffffffffffUL);\r\nnode_upper = ct_addr >> 48;\r\nif (node_upper > 64) {\r\nprintk(KERN_ERR "%s: coretalk addr 0x%p node id out "\r\n"of range\n", __func__, (void *)ct_addr);\r\nreturn 0;\r\n}\r\nagp_dma_extn = __sn_readq_relaxed(&ca_base->ca_agp_dma_addr_extn);\r\nif (node_upper != (agp_dma_extn >> CA_AGP_DMA_NODE_ID_SHFT)) {\r\nprintk(KERN_ERR "%s: coretalk upper node (%u) "\r\n"mismatch with ca_agp_dma_addr_extn (%llu)\n",\r\n__func__,\r\nnode_upper, (agp_dma_extn >> CA_AGP_DMA_NODE_ID_SHFT));\r\nreturn 0;\r\n}\r\nreturn bus_addr;\r\n}\r\nstatic dma_addr_t\r\ntioca_dma_mapped(struct pci_dev *pdev, unsigned long paddr, size_t req_size)\r\n{\r\nint ps, ps_shift, entry, entries, mapsize;\r\nu64 xio_addr, end_xio_addr;\r\nstruct tioca_common *tioca_common;\r\nstruct tioca_kernel *tioca_kern;\r\ndma_addr_t bus_addr = 0;\r\nstruct tioca_dmamap *ca_dmamap;\r\nvoid *map;\r\nunsigned long flags;\r\nstruct pcidev_info *pcidev_info = SN_PCIDEV_INFO(pdev);\r\ntioca_common = (struct tioca_common *)pcidev_info->pdi_pcibus_info;\r\ntioca_kern = (struct tioca_kernel *)tioca_common->ca_kernel_private;\r\nxio_addr = PHYS_TO_TIODMA(paddr);\r\nif (!xio_addr)\r\nreturn 0;\r\nspin_lock_irqsave(&tioca_kern->ca_lock, flags);\r\nca_dmamap = kzalloc(sizeof(struct tioca_dmamap), GFP_ATOMIC);\r\nif (!ca_dmamap)\r\ngoto map_return;\r\nps = tioca_kern->ca_ap_pagesize;\r\nps_shift = ffs(ps) - 1;\r\nend_xio_addr = xio_addr + req_size - 1;\r\nentries = (end_xio_addr >> ps_shift) - (xio_addr >> ps_shift) + 1;\r\nmap = tioca_kern->ca_pcigart_pagemap;\r\nmapsize = tioca_kern->ca_pcigart_entries;\r\nentry = bitmap_find_next_zero_area(map, mapsize, 0, entries, 0);\r\nif (entry >= mapsize) {\r\nkfree(ca_dmamap);\r\ngoto map_return;\r\n}\r\nbitmap_set(map, entry, entries);\r\nbus_addr = tioca_kern->ca_pciap_base + (entry * ps);\r\nca_dmamap->cad_dma_addr = bus_addr;\r\nca_dmamap->cad_gart_size = entries;\r\nca_dmamap->cad_gart_entry = entry;\r\nlist_add(&ca_dmamap->cad_list, &tioca_kern->ca_dmamaps);\r\nif (xio_addr % ps) {\r\ntioca_kern->ca_pcigart[entry] = tioca_paddr_to_gart(xio_addr);\r\nbus_addr += xio_addr & (ps - 1);\r\nxio_addr &= ~(ps - 1);\r\nxio_addr += ps;\r\nentry++;\r\n}\r\nwhile (xio_addr < end_xio_addr) {\r\ntioca_kern->ca_pcigart[entry] = tioca_paddr_to_gart(xio_addr);\r\nxio_addr += ps;\r\nentry++;\r\n}\r\ntioca_tlbflush(tioca_kern);\r\nmap_return:\r\nspin_unlock_irqrestore(&tioca_kern->ca_lock, flags);\r\nreturn bus_addr;\r\n}\r\nstatic void\r\ntioca_dma_unmap(struct pci_dev *pdev, dma_addr_t bus_addr, int dir)\r\n{\r\nint i, entry;\r\nstruct tioca_common *tioca_common;\r\nstruct tioca_kernel *tioca_kern;\r\nstruct tioca_dmamap *map;\r\nstruct pcidev_info *pcidev_info = SN_PCIDEV_INFO(pdev);\r\nunsigned long flags;\r\ntioca_common = (struct tioca_common *)pcidev_info->pdi_pcibus_info;\r\ntioca_kern = (struct tioca_kernel *)tioca_common->ca_kernel_private;\r\nif (bus_addr < tioca_kern->ca_pciap_base ||\r\nbus_addr >= (tioca_kern->ca_pciap_base + tioca_kern->ca_pciap_size))\r\nreturn;\r\nspin_lock_irqsave(&tioca_kern->ca_lock, flags);\r\nlist_for_each_entry(map, &tioca_kern->ca_dmamaps, cad_list)\r\nif (map->cad_dma_addr == bus_addr)\r\nbreak;\r\nBUG_ON(map == NULL);\r\nentry = map->cad_gart_entry;\r\nfor (i = 0; i < map->cad_gart_size; i++, entry++) {\r\nclear_bit(entry, tioca_kern->ca_pcigart_pagemap);\r\ntioca_kern->ca_pcigart[entry] = 0;\r\n}\r\ntioca_tlbflush(tioca_kern);\r\nlist_del(&map->cad_list);\r\nspin_unlock_irqrestore(&tioca_kern->ca_lock, flags);\r\nkfree(map);\r\n}\r\nstatic u64\r\ntioca_dma_map(struct pci_dev *pdev, unsigned long paddr, size_t byte_count, int dma_flags)\r\n{\r\nu64 mapaddr;\r\nif (dma_flags & SN_DMA_MSI)\r\nreturn 0;\r\nif (pdev->dma_mask == ~0UL)\r\nmapaddr = tioca_dma_d64(paddr);\r\nelse if (pdev->dma_mask == 0xffffffffffffUL)\r\nmapaddr = tioca_dma_d48(pdev, paddr);\r\nelse\r\nmapaddr = 0;\r\nif (mapaddr == 0)\r\nmapaddr = tioca_dma_mapped(pdev, paddr, byte_count);\r\nreturn mapaddr;\r\n}\r\nstatic irqreturn_t\r\ntioca_error_intr_handler(int irq, void *arg)\r\n{\r\nstruct tioca_common *soft = arg;\r\nstruct ia64_sal_retval ret_stuff;\r\nu64 segment;\r\nu64 busnum;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nsegment = soft->ca_common.bs_persist_segment;\r\nbusnum = soft->ca_common.bs_persist_busnum;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_ERROR_INTERRUPT,\r\nsegment, busnum, 0, 0, 0, 0, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void *\r\ntioca_bus_fixup(struct pcibus_bussoft *prom_bussoft, struct pci_controller *controller)\r\n{\r\nstruct tioca_common *tioca_common;\r\nstruct tioca_kernel *tioca_kern;\r\nstruct pci_bus *bus;\r\nif (is_shub1() && sn_sal_rev() < 0x0406) {\r\nprintk\r\n(KERN_ERR "%s: SGI prom rev 4.06 or greater required "\r\n"for tioca support\n", __func__);\r\nreturn NULL;\r\n}\r\ntioca_common = kzalloc(sizeof(struct tioca_common), GFP_KERNEL);\r\nif (!tioca_common)\r\nreturn NULL;\r\nmemcpy(tioca_common, prom_bussoft, sizeof(struct tioca_common));\r\ntioca_common->ca_common.bs_base = (unsigned long)\r\nioremap(REGION_OFFSET(tioca_common->ca_common.bs_base),\r\nsizeof(struct tioca_common));\r\ntioca_kern = kzalloc(sizeof(struct tioca_kernel), GFP_KERNEL);\r\nif (!tioca_kern) {\r\nkfree(tioca_common);\r\nreturn NULL;\r\n}\r\ntioca_kern->ca_common = tioca_common;\r\nspin_lock_init(&tioca_kern->ca_lock);\r\nINIT_LIST_HEAD(&tioca_kern->ca_dmamaps);\r\ntioca_kern->ca_closest_node =\r\nnasid_to_cnodeid(tioca_common->ca_closest_nasid);\r\ntioca_common->ca_kernel_private = (u64) tioca_kern;\r\nbus = pci_find_bus(tioca_common->ca_common.bs_persist_segment,\r\ntioca_common->ca_common.bs_persist_busnum);\r\nBUG_ON(!bus);\r\ntioca_kern->ca_devices = &bus->devices;\r\nif (tioca_gart_init(tioca_kern) < 0) {\r\nkfree(tioca_kern);\r\nkfree(tioca_common);\r\nreturn NULL;\r\n}\r\ntioca_gart_found++;\r\nlist_add(&tioca_kern->ca_list, &tioca_list);\r\nif (request_irq(SGI_TIOCA_ERROR,\r\ntioca_error_intr_handler,\r\nIRQF_SHARED, "TIOCA error", (void *)tioca_common))\r\nprintk(KERN_WARNING\r\n"%s: Unable to get irq %d. "\r\n"Error interrupts won't be routed for TIOCA bus %d\n",\r\n__func__, SGI_TIOCA_ERROR,\r\n(int)tioca_common->ca_common.bs_persist_busnum);\r\nsn_set_err_irq_affinity(SGI_TIOCA_ERROR);\r\ncontroller->node = tioca_kern->ca_closest_node;\r\nreturn tioca_common;\r\n}\r\nint\r\ntioca_init_provider(void)\r\n{\r\nsn_pci_provider[PCIIO_ASIC_TYPE_TIOCA] = &tioca_pci_interfaces;\r\nreturn 0;\r\n}
