static int tda8083_writereg (struct tda8083_state* state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf [] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk ("%s: writereg error (reg %02x, ret == %i)\n",\r\n__func__, reg, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic int tda8083_readregs (struct tda8083_state* state, u8 reg1, u8 *b, u8 len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = &reg1, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b, .len = len } };\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\ndprintk ("%s: readreg error (reg %02x, ret == %i)\n",\r\n__func__, reg1, ret);\r\nreturn ret == 2 ? 0 : -1;\r\n}\r\nstatic inline u8 tda8083_readreg (struct tda8083_state* state, u8 reg)\r\n{\r\nu8 val;\r\ntda8083_readregs (state, reg, &val, 1);\r\nreturn val;\r\n}\r\nstatic int tda8083_set_inversion (struct tda8083_state* state, fe_spectral_inversion_t inversion)\r\n{\r\nif (inversion == INVERSION_AUTO)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int tda8083_set_fec (struct tda8083_state* state, fe_code_rate_t fec)\r\n{\r\nif (fec == FEC_AUTO)\r\nreturn tda8083_writereg (state, 0x07, 0xff);\r\nif (fec >= FEC_1_2 && fec <= FEC_8_9)\r\nreturn tda8083_writereg (state, 0x07, 1 << (FEC_8_9 - fec));\r\nreturn -EINVAL;\r\n}\r\nstatic fe_code_rate_t tda8083_get_fec (struct tda8083_state* state)\r\n{\r\nu8 index;\r\nstatic fe_code_rate_t fec_tab [] = { FEC_8_9, FEC_1_2, FEC_2_3, FEC_3_4,\r\nFEC_4_5, FEC_5_6, FEC_6_7, FEC_7_8 };\r\nindex = tda8083_readreg(state, 0x0e) & 0x07;\r\nreturn fec_tab [index];\r\n}\r\nstatic int tda8083_set_symbolrate (struct tda8083_state* state, u32 srate)\r\n{\r\nu32 ratio;\r\nu32 tmp;\r\nu8 filter;\r\nif (srate > 32000000)\r\nsrate = 32000000;\r\nif (srate < 500000)\r\nsrate = 500000;\r\nfilter = 0;\r\nif (srate < 24000000)\r\nfilter = 2;\r\nif (srate < 16000000)\r\nfilter = 3;\r\ntmp = 31250 << 16;\r\nratio = tmp / srate;\r\ntmp = (tmp % srate) << 8;\r\nratio = (ratio << 8) + tmp / srate;\r\ntmp = (tmp % srate) << 8;\r\nratio = (ratio << 8) + tmp / srate;\r\ndprintk("tda8083: ratio == %08x\n", (unsigned int) ratio);\r\ntda8083_writereg (state, 0x05, filter);\r\ntda8083_writereg (state, 0x02, (ratio >> 16) & 0xff);\r\ntda8083_writereg (state, 0x03, (ratio >> 8) & 0xff);\r\ntda8083_writereg (state, 0x04, (ratio ) & 0xff);\r\ntda8083_writereg (state, 0x00, 0x3c);\r\ntda8083_writereg (state, 0x00, 0x04);\r\nreturn 1;\r\n}\r\nstatic void tda8083_wait_diseqc_fifo (struct tda8083_state* state, int timeout)\r\n{\r\nunsigned long start = jiffies;\r\nwhile (jiffies - start < timeout &&\r\n!(tda8083_readreg(state, 0x02) & 0x80))\r\n{\r\nmsleep(50);\r\n};\r\n}\r\nstatic int tda8083_set_tone (struct tda8083_state* state, fe_sec_tone_mode_t tone)\r\n{\r\ntda8083_writereg (state, 0x26, 0xf1);\r\nswitch (tone) {\r\ncase SEC_TONE_OFF:\r\nreturn tda8083_writereg (state, 0x29, 0x00);\r\ncase SEC_TONE_ON:\r\nreturn tda8083_writereg (state, 0x29, 0x80);\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\n}\r\nstatic int tda8083_set_voltage (struct tda8083_state* state, fe_sec_voltage_t voltage)\r\n{\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\nreturn tda8083_writereg (state, 0x20, 0x00);\r\ncase SEC_VOLTAGE_18:\r\nreturn tda8083_writereg (state, 0x20, 0x11);\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\n}\r\nstatic int tda8083_send_diseqc_burst (struct tda8083_state* state, fe_sec_mini_cmd_t burst)\r\n{\r\nswitch (burst) {\r\ncase SEC_MINI_A:\r\ntda8083_writereg (state, 0x29, (5 << 2));\r\nbreak;\r\ncase SEC_MINI_B:\r\ntda8083_writereg (state, 0x29, (7 << 2));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\ntda8083_wait_diseqc_fifo (state, 100);\r\nreturn 0;\r\n}\r\nstatic int tda8083_send_diseqc_msg (struct dvb_frontend* fe,\r\nstruct dvb_diseqc_master_cmd *m)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\nint i;\r\ntda8083_writereg (state, 0x29, (m->msg_len - 3) | (1 << 2));\r\nfor (i=0; i<m->msg_len; i++)\r\ntda8083_writereg (state, 0x23 + i, m->msg[i]);\r\ntda8083_writereg (state, 0x29, (m->msg_len - 3) | (3 << 2));\r\ntda8083_wait_diseqc_fifo (state, 100);\r\nreturn 0;\r\n}\r\nstatic int tda8083_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\nu8 signal = ~tda8083_readreg (state, 0x01);\r\nu8 sync = tda8083_readreg (state, 0x02);\r\n*status = 0;\r\nif (signal > 10)\r\n*status |= FE_HAS_SIGNAL;\r\nif (sync & 0x01)\r\n*status |= FE_HAS_CARRIER;\r\nif (sync & 0x02)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 0x10)\r\n*status |= FE_HAS_SYNC;\r\nif (sync & 0x20)\r\n*status |= FE_TIMEDOUT;\r\nif ((sync & 0x1f) == 0x1f)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int tda8083_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[3];\r\nif ((ret = tda8083_readregs(state, 0x0b, buf, sizeof(buf))))\r\nreturn ret;\r\n*ber = ((buf[0] & 0x1f) << 16) | (buf[1] << 8) | buf[2];\r\nreturn 0;\r\n}\r\nstatic int tda8083_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\nu8 signal = ~tda8083_readreg (state, 0x01);\r\n*strength = (signal << 8) | signal;\r\nreturn 0;\r\n}\r\nstatic int tda8083_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\nu8 _snr = tda8083_readreg (state, 0x08);\r\n*snr = (_snr << 8) | _snr;\r\nreturn 0;\r\n}\r\nstatic int tda8083_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\n*ucblocks = tda8083_readreg(state, 0x0f);\r\nif (*ucblocks == 0xff)\r\n*ucblocks = 0xffffffff;\r\nreturn 0;\r\n}\r\nstatic int tda8083_set_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe, p);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ntda8083_set_inversion (state, p->inversion);\r\ntda8083_set_fec (state, p->u.qpsk.fec_inner);\r\ntda8083_set_symbolrate (state, p->u.qpsk.symbol_rate);\r\ntda8083_writereg (state, 0x00, 0x3c);\r\ntda8083_writereg (state, 0x00, 0x04);\r\nreturn 0;\r\n}\r\nstatic int tda8083_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\np->inversion = (tda8083_readreg (state, 0x0e) & 0x80) ?\r\nINVERSION_ON : INVERSION_OFF;\r\np->u.qpsk.fec_inner = tda8083_get_fec (state);\r\nreturn 0;\r\n}\r\nstatic int tda8083_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\ntda8083_writereg (state, 0x00, 0x02);\r\nreturn 0;\r\n}\r\nstatic int tda8083_init(struct dvb_frontend* fe)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\nint i;\r\nfor (i=0; i<44; i++)\r\ntda8083_writereg (state, i, tda8083_init_tab[i]);\r\ntda8083_writereg (state, 0x00, 0x3c);\r\ntda8083_writereg (state, 0x00, 0x04);\r\nreturn 0;\r\n}\r\nstatic int tda8083_diseqc_send_burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t burst)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\ntda8083_send_diseqc_burst (state, burst);\r\ntda8083_writereg (state, 0x00, 0x3c);\r\ntda8083_writereg (state, 0x00, 0x04);\r\nreturn 0;\r\n}\r\nstatic int tda8083_diseqc_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\ntda8083_set_tone (state, tone);\r\ntda8083_writereg (state, 0x00, 0x3c);\r\ntda8083_writereg (state, 0x00, 0x04);\r\nreturn 0;\r\n}\r\nstatic int tda8083_diseqc_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\ntda8083_set_voltage (state, voltage);\r\ntda8083_writereg (state, 0x00, 0x3c);\r\ntda8083_writereg (state, 0x00, 0x04);\r\nreturn 0;\r\n}\r\nstatic void tda8083_release(struct dvb_frontend* fe)\r\n{\r\nstruct tda8083_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* tda8083_attach(const struct tda8083_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct tda8083_state* state = NULL;\r\nstate = kzalloc(sizeof(struct tda8083_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nif ((tda8083_readreg(state, 0x00)) != 0x05) goto error;\r\nmemcpy(&state->frontend.ops, &tda8083_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
