static int r600_audio_chipset_supported(struct radeon_device *rdev)\r\n{\r\nreturn (rdev->family >= CHIP_R600 && rdev->family < CHIP_CEDAR)\r\n|| rdev->family == CHIP_RS600\r\n|| rdev->family == CHIP_RS690\r\n|| rdev->family == CHIP_RS740;\r\n}\r\nint r600_audio_channels(struct radeon_device *rdev)\r\n{\r\nreturn (RREG32(R600_AUDIO_RATE_BPS_CHANNEL) & 0x7) + 1;\r\n}\r\nint r600_audio_bits_per_sample(struct radeon_device *rdev)\r\n{\r\nuint32_t value = (RREG32(R600_AUDIO_RATE_BPS_CHANNEL) & 0xF0) >> 4;\r\nswitch (value) {\r\ncase 0x0: return 8;\r\ncase 0x1: return 16;\r\ncase 0x2: return 20;\r\ncase 0x3: return 24;\r\ncase 0x4: return 32;\r\n}\r\ndev_err(rdev->dev, "Unknown bits per sample 0x%x using 16 instead\n",\r\n(int)value);\r\nreturn 16;\r\n}\r\nint r600_audio_rate(struct radeon_device *rdev)\r\n{\r\nuint32_t value = RREG32(R600_AUDIO_RATE_BPS_CHANNEL);\r\nuint32_t result;\r\nif (value & 0x4000)\r\nresult = 44100;\r\nelse\r\nresult = 48000;\r\nresult *= ((value >> 11) & 0x7) + 1;\r\nresult /= ((value >> 8) & 0x7) + 1;\r\nreturn result;\r\n}\r\nuint8_t r600_audio_status_bits(struct radeon_device *rdev)\r\n{\r\nreturn RREG32(R600_AUDIO_STATUS_BITS) & 0xff;\r\n}\r\nuint8_t r600_audio_category_code(struct radeon_device *rdev)\r\n{\r\nreturn (RREG32(R600_AUDIO_STATUS_BITS) >> 8) & 0xff;\r\n}\r\nvoid r600_audio_schedule_polling(struct radeon_device *rdev)\r\n{\r\nmod_timer(&rdev->audio_timer,\r\njiffies + msecs_to_jiffies(AUDIO_TIMER_INTERVALL));\r\n}\r\nstatic void r600_audio_update_hdmi(unsigned long param)\r\n{\r\nstruct radeon_device *rdev = (struct radeon_device *)param;\r\nstruct drm_device *dev = rdev->ddev;\r\nint channels = r600_audio_channels(rdev);\r\nint rate = r600_audio_rate(rdev);\r\nint bps = r600_audio_bits_per_sample(rdev);\r\nuint8_t status_bits = r600_audio_status_bits(rdev);\r\nuint8_t category_code = r600_audio_category_code(rdev);\r\nstruct drm_encoder *encoder;\r\nint changes = 0, still_going = 0;\r\nchanges |= channels != rdev->audio_channels;\r\nchanges |= rate != rdev->audio_rate;\r\nchanges |= bps != rdev->audio_bits_per_sample;\r\nchanges |= status_bits != rdev->audio_status_bits;\r\nchanges |= category_code != rdev->audio_category_code;\r\nif (changes) {\r\nrdev->audio_channels = channels;\r\nrdev->audio_rate = rate;\r\nrdev->audio_bits_per_sample = bps;\r\nrdev->audio_status_bits = status_bits;\r\nrdev->audio_category_code = category_code;\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstill_going |= radeon_encoder->audio_polling_active;\r\nif (changes || r600_hdmi_buffer_status_changed(encoder))\r\nr600_hdmi_update_audio_settings(encoder);\r\n}\r\nif (still_going)\r\nr600_audio_schedule_polling(rdev);\r\n}\r\nstatic void r600_audio_engine_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nDRM_INFO("%s audio support\n", enable ? "Enabling" : "Disabling");\r\nWREG32_P(R600_AUDIO_ENABLE, enable ? 0x81000000 : 0x0, ~0x81000000);\r\nrdev->audio_enabled = enable;\r\n}\r\nint r600_audio_init(struct radeon_device *rdev)\r\n{\r\nif (!radeon_audio || !r600_audio_chipset_supported(rdev))\r\nreturn 0;\r\nr600_audio_engine_enable(rdev, true);\r\nrdev->audio_channels = -1;\r\nrdev->audio_rate = -1;\r\nrdev->audio_bits_per_sample = -1;\r\nrdev->audio_status_bits = 0;\r\nrdev->audio_category_code = 0;\r\nsetup_timer(\r\n&rdev->audio_timer,\r\nr600_audio_update_hdmi,\r\n(unsigned long)rdev);\r\nreturn 0;\r\n}\r\nvoid r600_audio_enable_polling(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nDRM_DEBUG("r600_audio_enable_polling: %d\n",\r\nradeon_encoder->audio_polling_active);\r\nif (radeon_encoder->audio_polling_active)\r\nreturn;\r\nradeon_encoder->audio_polling_active = 1;\r\nif (rdev->audio_enabled)\r\nmod_timer(&rdev->audio_timer, jiffies + 1);\r\n}\r\nvoid r600_audio_disable_polling(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nDRM_DEBUG("r600_audio_disable_polling: %d\n",\r\nradeon_encoder->audio_polling_active);\r\nradeon_encoder->audio_polling_active = 0;\r\n}\r\nvoid r600_audio_set_clock(struct drm_encoder *encoder, int clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nint base_rate = 48000;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nWREG32_P(R600_AUDIO_TIMING, 0, ~0x301);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\nWREG32_P(R600_AUDIO_TIMING, 0x100, ~0x301);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unsupported encoder type 0x%02X\n",\r\nradeon_encoder->encoder_id);\r\nreturn;\r\n}\r\nswitch (dig->dig_encoder) {\r\ncase 0:\r\nWREG32(R600_AUDIO_PLL1_MUL, base_rate * 50);\r\nWREG32(R600_AUDIO_PLL1_DIV, clock * 100);\r\nWREG32(R600_AUDIO_CLK_SRCSEL, 0);\r\nbreak;\r\ncase 1:\r\nWREG32(R600_AUDIO_PLL2_MUL, base_rate * 50);\r\nWREG32(R600_AUDIO_PLL2_DIV, clock * 100);\r\nWREG32(R600_AUDIO_CLK_SRCSEL, 1);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unsupported DIG on encoder 0x%02X\n",\r\nradeon_encoder->encoder_id);\r\nreturn;\r\n}\r\n}\r\nvoid r600_audio_fini(struct radeon_device *rdev)\r\n{\r\nif (!rdev->audio_enabled)\r\nreturn;\r\ndel_timer(&rdev->audio_timer);\r\nr600_audio_engine_enable(rdev, false);\r\n}
