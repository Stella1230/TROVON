static void ieee80211_offchannel_ps_enable(struct ieee80211_sub_if_data *sdata,\r\nbool tell_ap)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\r\nlocal->offchannel_ps_enabled = false;\r\ndel_timer_sync(&local->dynamic_ps_timer);\r\ndel_timer_sync(&ifmgd->bcn_mon_timer);\r\ndel_timer_sync(&ifmgd->conn_mon_timer);\r\ncancel_work_sync(&local->dynamic_ps_enable_work);\r\nif (local->hw.conf.flags & IEEE80211_CONF_PS) {\r\nlocal->offchannel_ps_enabled = true;\r\nlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\r\nieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\r\n}\r\nif (tell_ap && (!local->offchannel_ps_enabled ||\r\n!(local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK)))\r\nieee80211_send_nullfunc(local, sdata, 1);\r\n}\r\nstatic void ieee80211_offchannel_ps_disable(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nif (!local->ps_sdata)\r\nieee80211_send_nullfunc(local, sdata, 0);\r\nelse if (local->offchannel_ps_enabled) {\r\nlocal->hw.conf.flags |= IEEE80211_CONF_PS;\r\nieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\r\n} else if (local->hw.conf.dynamic_ps_timeout > 0) {\r\nieee80211_send_nullfunc(local, sdata, 0);\r\nmod_timer(&local->dynamic_ps_timer, jiffies +\r\nmsecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\r\n}\r\nieee80211_sta_reset_beacon_monitor(sdata);\r\nieee80211_sta_reset_conn_monitor(sdata);\r\n}\r\nvoid ieee80211_offchannel_stop_vifs(struct ieee80211_local *local,\r\nbool offchannel_ps_enable)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nmutex_lock(&local->iflist_mtx);\r\nlist_for_each_entry(sdata, &local->interfaces, list) {\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\r\nset_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\r\nif (sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_ADHOC ||\r\nsdata->vif.type == NL80211_IFTYPE_MESH_POINT)\r\nieee80211_bss_info_change_notify(\r\nsdata, BSS_CHANGED_BEACON_ENABLED);\r\nif (sdata->vif.type != NL80211_IFTYPE_MONITOR) {\r\nnetif_tx_stop_all_queues(sdata->dev);\r\nif (offchannel_ps_enable &&\r\n(sdata->vif.type == NL80211_IFTYPE_STATION) &&\r\nsdata->u.mgd.associated)\r\nieee80211_offchannel_ps_enable(sdata, true);\r\n}\r\n}\r\nmutex_unlock(&local->iflist_mtx);\r\n}\r\nvoid ieee80211_offchannel_enable_all_ps(struct ieee80211_local *local,\r\nbool tell_ap)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nmutex_lock(&local->iflist_mtx);\r\nlist_for_each_entry(sdata, &local->interfaces, list) {\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION &&\r\nsdata->u.mgd.associated)\r\nieee80211_offchannel_ps_enable(sdata, tell_ap);\r\n}\r\nmutex_unlock(&local->iflist_mtx);\r\n}\r\nvoid ieee80211_offchannel_return(struct ieee80211_local *local,\r\nbool enable_beaconing,\r\nbool offchannel_ps_disable)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nmutex_lock(&local->iflist_mtx);\r\nlist_for_each_entry(sdata, &local->interfaces, list) {\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif (offchannel_ps_disable &&\r\nsdata->vif.type == NL80211_IFTYPE_STATION) {\r\nif (sdata->u.mgd.associated)\r\nieee80211_offchannel_ps_disable(sdata);\r\n}\r\nif (sdata->vif.type != NL80211_IFTYPE_MONITOR) {\r\nclear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\r\nnetif_tx_wake_all_queues(sdata->dev);\r\n}\r\nif (enable_beaconing &&\r\n(sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_ADHOC ||\r\nsdata->vif.type == NL80211_IFTYPE_MESH_POINT))\r\nieee80211_bss_info_change_notify(\r\nsdata, BSS_CHANGED_BEACON_ENABLED);\r\n}\r\nmutex_unlock(&local->iflist_mtx);\r\n}\r\nstatic void ieee80211_hw_roc_start(struct work_struct *work)\r\n{\r\nstruct ieee80211_local *local =\r\ncontainer_of(work, struct ieee80211_local, hw_roc_start);\r\nstruct ieee80211_sub_if_data *sdata;\r\nmutex_lock(&local->mtx);\r\nif (!local->hw_roc_channel) {\r\nmutex_unlock(&local->mtx);\r\nreturn;\r\n}\r\nieee80211_recalc_idle(local);\r\nif (local->hw_roc_skb) {\r\nsdata = IEEE80211_DEV_TO_SUB_IF(local->hw_roc_dev);\r\nieee80211_tx_skb(sdata, local->hw_roc_skb);\r\nlocal->hw_roc_skb = NULL;\r\n} else {\r\ncfg80211_ready_on_channel(local->hw_roc_dev,\r\nlocal->hw_roc_cookie,\r\nlocal->hw_roc_channel,\r\nlocal->hw_roc_channel_type,\r\nlocal->hw_roc_duration,\r\nGFP_KERNEL);\r\n}\r\nmutex_unlock(&local->mtx);\r\n}\r\nvoid ieee80211_ready_on_channel(struct ieee80211_hw *hw)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\ntrace_api_ready_on_channel(local);\r\nieee80211_queue_work(hw, &local->hw_roc_start);\r\n}\r\nstatic void ieee80211_hw_roc_done(struct work_struct *work)\r\n{\r\nstruct ieee80211_local *local =\r\ncontainer_of(work, struct ieee80211_local, hw_roc_done);\r\nmutex_lock(&local->mtx);\r\nif (!local->hw_roc_channel) {\r\nmutex_unlock(&local->mtx);\r\nreturn;\r\n}\r\nif (!local->hw_roc_for_tx)\r\ncfg80211_remain_on_channel_expired(local->hw_roc_dev,\r\nlocal->hw_roc_cookie,\r\nlocal->hw_roc_channel,\r\nlocal->hw_roc_channel_type,\r\nGFP_KERNEL);\r\nlocal->hw_roc_channel = NULL;\r\nlocal->hw_roc_cookie = 0;\r\nieee80211_recalc_idle(local);\r\nmutex_unlock(&local->mtx);\r\n}\r\nvoid ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\ntrace_api_remain_on_channel_expired(local);\r\nieee80211_queue_work(hw, &local->hw_roc_done);\r\n}\r\nvoid ieee80211_hw_roc_setup(struct ieee80211_local *local)\r\n{\r\nINIT_WORK(&local->hw_roc_start, ieee80211_hw_roc_start);\r\nINIT_WORK(&local->hw_roc_done, ieee80211_hw_roc_done);\r\n}
