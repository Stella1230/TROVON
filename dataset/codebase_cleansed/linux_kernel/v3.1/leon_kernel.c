static inline unsigned int leon_eirq_get(int cpu)\r\n{\r\nreturn LEON3_BYPASS_LOAD_PA(&leon3_irqctrl_regs->intid[cpu]) & 0x1f;\r\n}\r\nstatic void leon_handle_ext_irq(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned int eirq;\r\nint cpu = sparc_leon3_cpuid();\r\neirq = leon_eirq_get(cpu);\r\nif ((eirq & 0x10) && irq_map[eirq]->irq)\r\ngeneric_handle_irq(irq_map[eirq]->irq);\r\n}\r\nvoid leon_eirq_setup(unsigned int eirq)\r\n{\r\nunsigned long mask, oldmask;\r\nunsigned int veirq;\r\nif (eirq < 1 || eirq > 0xf) {\r\nprintk(KERN_ERR "LEON EXT IRQ NUMBER BAD: %d\n", eirq);\r\nreturn;\r\n}\r\nveirq = leon_build_device_irq(eirq, leon_handle_ext_irq, "extirq", 0);\r\nirq_link(veirq);\r\nmask = 1 << eirq;\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(boot_cpu_id));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(boot_cpu_id), (oldmask | mask));\r\nsparc_leon_eirq = eirq;\r\n}\r\nstatic inline unsigned long get_irqmask(unsigned int irq)\r\n{\r\nunsigned long mask;\r\nif (!irq || ((irq > 0xf) && !sparc_leon_eirq)\r\n|| ((irq > 0x1f) && sparc_leon_eirq)) {\r\nprintk(KERN_ERR\r\n"leon_get_irqmask: false irq number: %d\n", irq);\r\nmask = 0;\r\n} else {\r\nmask = LEON_HARD_INT(irq);\r\n}\r\nreturn mask;\r\n}\r\nstatic int irq_choose_cpu(const struct cpumask *affinity)\r\n{\r\ncpumask_t mask;\r\ncpus_and(mask, cpu_online_map, *affinity);\r\nif (cpus_equal(mask, cpu_online_map) || cpus_empty(mask))\r\nreturn boot_cpu_id;\r\nelse\r\nreturn first_cpu(mask);\r\n}\r\nstatic int leon_set_affinity(struct irq_data *data, const struct cpumask *dest,\r\nbool force)\r\n{\r\nunsigned long mask, oldmask, flags;\r\nint oldcpu, newcpu;\r\nmask = (unsigned long)data->chip_data;\r\noldcpu = irq_choose_cpu(data->affinity);\r\nnewcpu = irq_choose_cpu(dest);\r\nif (oldcpu == newcpu)\r\ngoto out;\r\nspin_lock_irqsave(&leon_irq_lock, flags);\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(oldcpu));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(oldcpu), (oldmask & ~mask));\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(newcpu));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(newcpu), (oldmask | mask));\r\nspin_unlock_irqrestore(&leon_irq_lock, flags);\r\nout:\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic void leon_unmask_irq(struct irq_data *data)\r\n{\r\nunsigned long mask, oldmask, flags;\r\nint cpu;\r\nmask = (unsigned long)data->chip_data;\r\ncpu = irq_choose_cpu(data->affinity);\r\nspin_lock_irqsave(&leon_irq_lock, flags);\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(cpu));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(cpu), (oldmask | mask));\r\nspin_unlock_irqrestore(&leon_irq_lock, flags);\r\n}\r\nstatic void leon_mask_irq(struct irq_data *data)\r\n{\r\nunsigned long mask, oldmask, flags;\r\nint cpu;\r\nmask = (unsigned long)data->chip_data;\r\ncpu = irq_choose_cpu(data->affinity);\r\nspin_lock_irqsave(&leon_irq_lock, flags);\r\noldmask = LEON3_BYPASS_LOAD_PA(LEON_IMASK(cpu));\r\nLEON3_BYPASS_STORE_PA(LEON_IMASK(cpu), (oldmask & ~mask));\r\nspin_unlock_irqrestore(&leon_irq_lock, flags);\r\n}\r\nstatic unsigned int leon_startup_irq(struct irq_data *data)\r\n{\r\nirq_link(data->irq);\r\nleon_unmask_irq(data);\r\nreturn 0;\r\n}\r\nstatic void leon_shutdown_irq(struct irq_data *data)\r\n{\r\nleon_mask_irq(data);\r\nirq_unlink(data->irq);\r\n}\r\nstatic void leon_eoi_irq(struct irq_data *data)\r\n{\r\nunsigned long mask = (unsigned long)data->chip_data;\r\nif (mask & LEON_DO_ACK_HW)\r\nLEON3_BYPASS_STORE_PA(LEON_IACK, mask & ~LEON_DO_ACK_HW);\r\n}\r\nunsigned int leon_build_device_irq(unsigned int real_irq,\r\nirq_flow_handler_t flow_handler,\r\nconst char *name, int do_ack)\r\n{\r\nunsigned int irq;\r\nunsigned long mask;\r\nirq = 0;\r\nmask = get_irqmask(real_irq);\r\nif (mask == 0)\r\ngoto out;\r\nirq = irq_alloc(real_irq, real_irq);\r\nif (irq == 0)\r\ngoto out;\r\nif (do_ack)\r\nmask |= LEON_DO_ACK_HW;\r\nirq_set_chip_and_handler_name(irq, &leon_irq,\r\nflow_handler, name);\r\nirq_set_chip_data(irq, (void *)mask);\r\nout:\r\nreturn irq;\r\n}\r\nstatic unsigned int _leon_build_device_irq(struct platform_device *op,\r\nunsigned int real_irq)\r\n{\r\nreturn leon_build_device_irq(real_irq, handle_simple_irq, "edge", 0);\r\n}\r\nvoid leon_update_virq_handling(unsigned int virq,\r\nirq_flow_handler_t flow_handler,\r\nconst char *name, int do_ack)\r\n{\r\nunsigned long mask = (unsigned long)irq_get_chip_data(virq);\r\nmask &= ~LEON_DO_ACK_HW;\r\nif (do_ack)\r\nmask |= LEON_DO_ACK_HW;\r\nirq_set_chip_and_handler_name(virq, &leon_irq,\r\nflow_handler, name);\r\nirq_set_chip_data(virq, (void *)mask);\r\n}\r\nvoid __init leon_init_timers(irq_handler_t counter_fn)\r\n{\r\nint irq, eirq;\r\nstruct device_node *rootnp, *np, *nnp;\r\nstruct property *pp;\r\nint len;\r\nint icsel;\r\nint ampopts;\r\nint err;\r\nleondebug_irq_disable = 0;\r\nleon_debug_irqout = 0;\r\nmaster_l10_counter = (unsigned int *)&dummy_master_l10_counter;\r\ndummy_master_l10_counter = 0;\r\nrootnp = of_find_node_by_path("/ambapp0");\r\nif (!rootnp)\r\ngoto bad;\r\npp = of_find_property(rootnp, "systemid", &len);\r\nif (pp)\r\namba_system_id = *(unsigned long *)pp->value;\r\nnp = of_find_node_by_name(rootnp, "GAISLER_IRQMP");\r\nif (!np) {\r\nnp = of_find_node_by_name(rootnp, "01_00d");\r\nif (!np)\r\ngoto bad;\r\n}\r\npp = of_find_property(np, "reg", &len);\r\nif (!pp)\r\ngoto bad;\r\nleon3_irqctrl_regs = *(struct leon3_irqctrl_regs_map **)pp->value;\r\nnnp = rootnp;\r\ndo {\r\nnp = of_find_node_by_name(nnp, "GAISLER_GPTIMER");\r\nif (!np) {\r\nnp = of_find_node_by_name(nnp, "01_011");\r\nif (!np)\r\ngoto bad;\r\n}\r\nampopts = 0;\r\npp = of_find_property(np, "ampopts", &len);\r\nif (pp) {\r\nampopts = *(int *)pp->value;\r\nif (ampopts == 0) {\r\nnnp = np;\r\ncontinue;\r\n}\r\n}\r\nleon3_gptimer_idx = ampopts & 0x7;\r\npp = of_find_property(np, "reg", &len);\r\nif (pp)\r\nleon3_gptimer_regs = *(struct leon3_gptimer_regs_map **)\r\npp->value;\r\npp = of_find_property(np, "interrupts", &len);\r\nif (pp)\r\nleon3_gptimer_irq = *(unsigned int *)pp->value;\r\n} while (0);\r\nif (!(leon3_gptimer_regs && leon3_irqctrl_regs && leon3_gptimer_irq))\r\ngoto bad;\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].val, 0);\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].rld,\r\n(((1000000 / HZ) - 1)));\r\nLEON3_BYPASS_STORE_PA(\r\n&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl, 0);\r\n#ifdef CONFIG_SMP\r\nleon3_ticker_irq = leon3_gptimer_irq + 1 + leon3_gptimer_idx;\r\nif (!(LEON3_BYPASS_LOAD_PA(&leon3_gptimer_regs->config) &\r\n(1<<LEON3_GPTIMER_SEPIRQ))) {\r\nprintk(KERN_ERR "timer not configured with separate irqs\n");\r\nBUG();\r\n}\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx+1].val,\r\n0);\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx+1].rld,\r\n(((1000000/HZ) - 1)));\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx+1].ctrl,\r\n0);\r\n#endif\r\nicsel = LEON3_BYPASS_LOAD_PA(&leon3_irqctrl_regs->icsel[boot_cpu_id/8]);\r\nicsel = (icsel >> ((7 - (boot_cpu_id&0x7)) * 4)) & 0xf;\r\nleon3_irqctrl_regs += icsel;\r\nLEON3_BYPASS_STORE_PA(&leon3_irqctrl_regs->mask[boot_cpu_id], 0);\r\neirq = (LEON3_BYPASS_LOAD_PA(&leon3_irqctrl_regs->mpstatus)\r\n>> 16) & 0xf;\r\nif (eirq != 0)\r\nleon_eirq_setup(eirq);\r\nirq = _leon_build_device_irq(NULL, leon3_gptimer_irq+leon3_gptimer_idx);\r\nerr = request_irq(irq, counter_fn, IRQF_TIMER, "timer", NULL);\r\nif (err) {\r\nprintk(KERN_ERR "unable to attach timer IRQ%d\n", irq);\r\nprom_halt();\r\n}\r\n#ifdef CONFIG_SMP\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\npatchme_maybe_smp_msg[0] = 0x01000000;\r\nlocal_flush_cache_all();\r\nlocal_irq_restore(flags);\r\n}\r\n#endif\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx].ctrl,\r\nLEON3_GPTIMER_EN |\r\nLEON3_GPTIMER_RL |\r\nLEON3_GPTIMER_LD |\r\nLEON3_GPTIMER_IRQEN);\r\n#ifdef CONFIG_SMP\r\nirq = leon_build_device_irq(leon3_ticker_irq, handle_percpu_irq,\r\n"per-cpu", 0);\r\nerr = request_irq(irq, leon_percpu_timer_interrupt,\r\nIRQF_PERCPU | IRQF_TIMER, "ticker",\r\nNULL);\r\nif (err) {\r\nprintk(KERN_ERR "unable to attach ticker IRQ%d\n", irq);\r\nprom_halt();\r\n}\r\nLEON3_BYPASS_STORE_PA(&leon3_gptimer_regs->e[leon3_gptimer_idx+1].ctrl,\r\nLEON3_GPTIMER_EN |\r\nLEON3_GPTIMER_RL |\r\nLEON3_GPTIMER_LD |\r\nLEON3_GPTIMER_IRQEN);\r\n#endif\r\nreturn;\r\nbad:\r\nprintk(KERN_ERR "No Timer/irqctrl found\n");\r\nBUG();\r\nreturn;\r\n}\r\nvoid leon_clear_clock_irq(void)\r\n{\r\n}\r\nvoid leon_load_profile_irq(int cpu, unsigned int limit)\r\n{\r\nBUG();\r\n}\r\nvoid __init leon_trans_init(struct device_node *dp)\r\n{\r\nif (strcmp(dp->type, "cpu") == 0 && strcmp(dp->name, "<NULL>") == 0) {\r\nstruct property *p;\r\np = of_find_property(dp, "mid", (void *)0);\r\nif (p) {\r\nint mid;\r\ndp->name = prom_early_alloc(5 + 1);\r\nmemcpy(&mid, p->value, p->length);\r\nsprintf((char *)dp->name, "cpu%.2d", mid);\r\n}\r\n}\r\n}\r\nvoid __init leon_node_init(struct device_node *dp, struct device_node ***nextp)\r\n{\r\nif (prom_amba_init &&\r\nstrcmp(dp->type, "ambapp") == 0 &&\r\nstrcmp(dp->name, "ambapp0") == 0) {\r\nprom_amba_init(dp, nextp);\r\n}\r\n}\r\nvoid leon_set_cpu_int(int cpu, int level)\r\n{\r\nunsigned long mask;\r\nmask = get_irqmask(level);\r\nLEON3_BYPASS_STORE_PA(&leon3_irqctrl_regs->force[cpu], mask);\r\n}\r\nstatic void leon_clear_ipi(int cpu, int level)\r\n{\r\nunsigned long mask;\r\nmask = get_irqmask(level);\r\nLEON3_BYPASS_STORE_PA(&leon3_irqctrl_regs->force[cpu], mask<<16);\r\n}\r\nstatic void leon_set_udt(int cpu)\r\n{\r\n}\r\nvoid leon_clear_profile_irq(int cpu)\r\n{\r\n}\r\nvoid leon_enable_irq_cpu(unsigned int irq_nr, unsigned int cpu)\r\n{\r\nunsigned long mask, flags, *addr;\r\nmask = get_irqmask(irq_nr);\r\nspin_lock_irqsave(&leon_irq_lock, flags);\r\naddr = (unsigned long *)LEON_IMASK(cpu);\r\nLEON3_BYPASS_STORE_PA(addr, (LEON3_BYPASS_LOAD_PA(addr) | mask));\r\nspin_unlock_irqrestore(&leon_irq_lock, flags);\r\n}\r\nvoid __init leon_init_IRQ(void)\r\n{\r\nsparc_irq_config.init_timers = leon_init_timers;\r\nsparc_irq_config.build_device_irq = _leon_build_device_irq;\r\nBTFIXUPSET_CALL(clear_clock_irq, leon_clear_clock_irq,\r\nBTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(load_profile_irq, leon_load_profile_irq,\r\nBTFIXUPCALL_NOP);\r\n#ifdef CONFIG_SMP\r\nBTFIXUPSET_CALL(set_cpu_int, leon_set_cpu_int, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(clear_cpu_int, leon_clear_ipi, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(set_irq_udt, leon_set_udt, BTFIXUPCALL_NORM);\r\n#endif\r\n}\r\nvoid __init leon_init(void)\r\n{\r\nof_pdt_build_more = &leon_node_init;\r\n}
