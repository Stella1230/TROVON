static intc_enum __init intc_grp_id(struct intc_desc *desc,\r\nintc_enum enum_id)\r\n{\r\nstruct intc_group *g = desc->hw.groups;\r\nunsigned int i, j;\r\nfor (i = 0; g && enum_id && i < desc->hw.nr_groups; i++) {\r\ng = desc->hw.groups + i;\r\nfor (j = 0; g->enum_ids[j]; j++) {\r\nif (g->enum_ids[j] != enum_id)\r\ncontinue;\r\nreturn g->enum_id;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int __init _intc_mask_data(struct intc_desc *desc,\r\nstruct intc_desc_int *d,\r\nintc_enum enum_id,\r\nunsigned int *reg_idx,\r\nunsigned int *fld_idx)\r\n{\r\nstruct intc_mask_reg *mr = desc->hw.mask_regs;\r\nunsigned int fn, mode;\r\nunsigned long reg_e, reg_d;\r\nwhile (mr && enum_id && *reg_idx < desc->hw.nr_mask_regs) {\r\nmr = desc->hw.mask_regs + *reg_idx;\r\nfor (; *fld_idx < ARRAY_SIZE(mr->enum_ids); (*fld_idx)++) {\r\nif (mr->enum_ids[*fld_idx] != enum_id)\r\ncontinue;\r\nif (mr->set_reg && mr->clr_reg) {\r\nfn = REG_FN_WRITE_BASE;\r\nmode = MODE_DUAL_REG;\r\nreg_e = mr->clr_reg;\r\nreg_d = mr->set_reg;\r\n} else {\r\nfn = REG_FN_MODIFY_BASE;\r\nif (mr->set_reg) {\r\nmode = MODE_ENABLE_REG;\r\nreg_e = mr->set_reg;\r\nreg_d = mr->set_reg;\r\n} else {\r\nmode = MODE_MASK_REG;\r\nreg_e = mr->clr_reg;\r\nreg_d = mr->clr_reg;\r\n}\r\n}\r\nfn += (mr->reg_width >> 3) - 1;\r\nreturn _INTC_MK(fn, mode,\r\nintc_get_reg(d, reg_e),\r\nintc_get_reg(d, reg_d),\r\n1,\r\n(mr->reg_width - 1) - *fld_idx);\r\n}\r\n*fld_idx = 0;\r\n(*reg_idx)++;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int __init\r\nintc_get_mask_handle(struct intc_desc *desc, struct intc_desc_int *d,\r\nintc_enum enum_id, int do_grps)\r\n{\r\nunsigned int i = 0;\r\nunsigned int j = 0;\r\nunsigned int ret;\r\nret = _intc_mask_data(desc, d, enum_id, &i, &j);\r\nif (ret)\r\nreturn ret;\r\nif (do_grps)\r\nreturn intc_get_mask_handle(desc, d, intc_grp_id(desc, enum_id), 0);\r\nreturn 0;\r\n}\r\nstatic unsigned int __init _intc_prio_data(struct intc_desc *desc,\r\nstruct intc_desc_int *d,\r\nintc_enum enum_id,\r\nunsigned int *reg_idx,\r\nunsigned int *fld_idx)\r\n{\r\nstruct intc_prio_reg *pr = desc->hw.prio_regs;\r\nunsigned int fn, n, mode, bit;\r\nunsigned long reg_e, reg_d;\r\nwhile (pr && enum_id && *reg_idx < desc->hw.nr_prio_regs) {\r\npr = desc->hw.prio_regs + *reg_idx;\r\nfor (; *fld_idx < ARRAY_SIZE(pr->enum_ids); (*fld_idx)++) {\r\nif (pr->enum_ids[*fld_idx] != enum_id)\r\ncontinue;\r\nif (pr->set_reg && pr->clr_reg) {\r\nfn = REG_FN_WRITE_BASE;\r\nmode = MODE_PCLR_REG;\r\nreg_e = pr->set_reg;\r\nreg_d = pr->clr_reg;\r\n} else {\r\nfn = REG_FN_MODIFY_BASE;\r\nmode = MODE_PRIO_REG;\r\nif (!pr->set_reg)\r\nBUG();\r\nreg_e = pr->set_reg;\r\nreg_d = pr->set_reg;\r\n}\r\nfn += (pr->reg_width >> 3) - 1;\r\nn = *fld_idx + 1;\r\nBUG_ON(n * pr->field_width > pr->reg_width);\r\nbit = pr->reg_width - (n * pr->field_width);\r\nreturn _INTC_MK(fn, mode,\r\nintc_get_reg(d, reg_e),\r\nintc_get_reg(d, reg_d),\r\npr->field_width, bit);\r\n}\r\n*fld_idx = 0;\r\n(*reg_idx)++;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int __init\r\nintc_get_prio_handle(struct intc_desc *desc, struct intc_desc_int *d,\r\nintc_enum enum_id, int do_grps)\r\n{\r\nunsigned int i = 0;\r\nunsigned int j = 0;\r\nunsigned int ret;\r\nret = _intc_prio_data(desc, d, enum_id, &i, &j);\r\nif (ret)\r\nreturn ret;\r\nif (do_grps)\r\nreturn intc_get_prio_handle(desc, d, intc_grp_id(desc, enum_id), 0);\r\nreturn 0;\r\n}\r\nstatic unsigned int __init intc_ack_data(struct intc_desc *desc,\r\nstruct intc_desc_int *d,\r\nintc_enum enum_id)\r\n{\r\nstruct intc_mask_reg *mr = desc->hw.ack_regs;\r\nunsigned int i, j, fn, mode;\r\nunsigned long reg_e, reg_d;\r\nfor (i = 0; mr && enum_id && i < desc->hw.nr_ack_regs; i++) {\r\nmr = desc->hw.ack_regs + i;\r\nfor (j = 0; j < ARRAY_SIZE(mr->enum_ids); j++) {\r\nif (mr->enum_ids[j] != enum_id)\r\ncontinue;\r\nfn = REG_FN_MODIFY_BASE;\r\nmode = MODE_ENABLE_REG;\r\nreg_e = mr->set_reg;\r\nreg_d = mr->set_reg;\r\nfn += (mr->reg_width >> 3) - 1;\r\nreturn _INTC_MK(fn, mode,\r\nintc_get_reg(d, reg_e),\r\nintc_get_reg(d, reg_d),\r\n1,\r\n(mr->reg_width - 1) - j);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void intc_enable_disable(struct intc_desc_int *d,\r\nunsigned long handle, int do_enable)\r\n{\r\nunsigned long addr;\r\nunsigned int cpu;\r\nunsigned long (*fn)(unsigned long, unsigned long,\r\nunsigned long (*)(unsigned long, unsigned long,\r\nunsigned long),\r\nunsigned int);\r\nif (do_enable) {\r\nfor (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_E(handle)); cpu++) {\r\naddr = INTC_REG(d, _INTC_ADDR_E(handle), cpu);\r\nfn = intc_enable_noprio_fns[_INTC_MODE(handle)];\r\nfn(addr, handle, intc_reg_fns[_INTC_FN(handle)], 0);\r\n}\r\n} else {\r\nfor (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_D(handle)); cpu++) {\r\naddr = INTC_REG(d, _INTC_ADDR_D(handle), cpu);\r\nfn = intc_disable_fns[_INTC_MODE(handle)];\r\nfn(addr, handle, intc_reg_fns[_INTC_FN(handle)], 0);\r\n}\r\n}\r\n}\r\nvoid __init intc_enable_disable_enum(struct intc_desc *desc,\r\nstruct intc_desc_int *d,\r\nintc_enum enum_id, int enable)\r\n{\r\nunsigned int i, j, data;\r\ni = j = 0;\r\ndo {\r\ndata = _intc_mask_data(desc, d, enum_id, &i, &j);\r\nif (data)\r\nintc_enable_disable(d, data, enable);\r\nj++;\r\n} while (data);\r\ni = j = 0;\r\ndo {\r\ndata = _intc_prio_data(desc, d, enum_id, &i, &j);\r\nif (data)\r\nintc_enable_disable(d, data, enable);\r\nj++;\r\n} while (data);\r\n}\r\nunsigned int __init\r\nintc_get_sense_handle(struct intc_desc *desc, struct intc_desc_int *d,\r\nintc_enum enum_id)\r\n{\r\nstruct intc_sense_reg *sr = desc->hw.sense_regs;\r\nunsigned int i, j, fn, bit;\r\nfor (i = 0; sr && enum_id && i < desc->hw.nr_sense_regs; i++) {\r\nsr = desc->hw.sense_regs + i;\r\nfor (j = 0; j < ARRAY_SIZE(sr->enum_ids); j++) {\r\nif (sr->enum_ids[j] != enum_id)\r\ncontinue;\r\nfn = REG_FN_MODIFY_BASE;\r\nfn += (sr->reg_width >> 3) - 1;\r\nBUG_ON((j + 1) * sr->field_width > sr->reg_width);\r\nbit = sr->reg_width - ((j + 1) * sr->field_width);\r\nreturn _INTC_MK(fn, 0, intc_get_reg(d, sr->reg),\r\n0, sr->field_width, bit);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid intc_set_ack_handle(unsigned int irq, struct intc_desc *desc,\r\nstruct intc_desc_int *d, intc_enum id)\r\n{\r\nunsigned long flags;\r\nif (!desc->hw.ack_regs)\r\nreturn;\r\nraw_spin_lock_irqsave(&intc_big_lock, flags);\r\nack_handle[irq] = intc_ack_data(desc, d, id);\r\nraw_spin_unlock_irqrestore(&intc_big_lock, flags);\r\n}\r\nunsigned long intc_get_ack_handle(unsigned int irq)\r\n{\r\nreturn ack_handle[irq];\r\n}
