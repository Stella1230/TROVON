static int hostap_enable_hostapd(PSDevice pDevice, int rtnl_locked)\r\n{\r\nPSDevice apdev_priv;\r\nstruct net_device *dev = pDevice->dev;\r\nint ret;\r\nconst struct net_device_ops apdev_netdev_ops = {\r\n.ndo_start_xmit = pDevice->tx_80211,\r\n};\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "%s: Enabling hostapd mode\n", dev->name);\r\npDevice->apdev = kzalloc(sizeof(struct net_device), GFP_KERNEL);\r\nif (pDevice->apdev == NULL)\r\nreturn -ENOMEM;\r\napdev_priv = netdev_priv(pDevice->apdev);\r\n*apdev_priv = *pDevice;\r\nmemcpy(pDevice->apdev->dev_addr, dev->dev_addr, ETH_ALEN);\r\npDevice->apdev->netdev_ops = &apdev_netdev_ops;\r\npDevice->apdev->type = ARPHRD_IEEE80211;\r\npDevice->apdev->base_addr = dev->base_addr;\r\npDevice->apdev->irq = dev->irq;\r\npDevice->apdev->mem_start = dev->mem_start;\r\npDevice->apdev->mem_end = dev->mem_end;\r\nsprintf(pDevice->apdev->name, "%sap", dev->name);\r\nif (rtnl_locked)\r\nret = register_netdevice(pDevice->apdev);\r\nelse\r\nret = register_netdev(pDevice->apdev);\r\nif (ret) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "%s: register_netdevice(AP) failed!\n",\r\ndev->name);\r\nreturn -1;\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "%s: Registered netdevice %s for AP management\n",\r\ndev->name, pDevice->apdev->name);\r\nKeyvInitTable(&pDevice->sKey, pDevice->PortOffset);\r\nreturn 0;\r\n}\r\nstatic int hostap_disable_hostapd(PSDevice pDevice, int rtnl_locked)\r\n{\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "%s: disabling hostapd mode\n", pDevice->dev->name);\r\nif (pDevice->apdev && pDevice->apdev->name && pDevice->apdev->name[0]) {\r\nif (rtnl_locked)\r\nunregister_netdevice(pDevice->apdev);\r\nelse\r\nunregister_netdev(pDevice->apdev);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "%s: Netdevice %s unregistered\n",\r\npDevice->dev->name, pDevice->apdev->name);\r\n}\r\nkfree(pDevice->apdev);\r\npDevice->apdev = NULL;\r\npDevice->bEnable8021x = false;\r\npDevice->bEnableHostWEP = false;\r\npDevice->bEncryptionEnable = false;\r\npDevice->pMgmt->byCSSPK=KEY_CTL_NONE;\r\npDevice->pMgmt->byCSSGK=KEY_CTL_NONE;\r\nKeyvInitTable(&pDevice->sKey,pDevice->PortOffset);\r\nreturn 0;\r\n}\r\nint vt6655_hostap_set_hostapd(PSDevice pDevice, int val, int rtnl_locked)\r\n{\r\nif (val < 0 || val > 1)\r\nreturn -EINVAL;\r\nif (pDevice->bEnableHostapd == val)\r\nreturn 0;\r\npDevice->bEnableHostapd = val;\r\nif (val)\r\nreturn hostap_enable_hostapd(pDevice, rtnl_locked);\r\nelse\r\nreturn hostap_disable_hostapd(pDevice, rtnl_locked);\r\n}\r\nstatic int hostap_remove_sta(PSDevice pDevice,\r\nstruct viawget_hostapd_param *param)\r\n{\r\nunsigned int uNodeIndex;\r\nif (BSSDBbIsSTAInNodeDB(pDevice->pMgmt, param->sta_addr, &uNodeIndex)) {\r\nBSSvRemoveOneNode(pDevice, uNodeIndex);\r\n}\r\nelse {\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hostap_add_sta(PSDevice pDevice,\r\nstruct viawget_hostapd_param *param)\r\n{\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nunsigned int uNodeIndex;\r\nif (!BSSDBbIsSTAInNodeDB(pMgmt, param->sta_addr, &uNodeIndex)) {\r\nBSSvCreateOneNode((PSDevice)pDevice, &uNodeIndex);\r\n}\r\nmemcpy(pMgmt->sNodeDBTable[uNodeIndex].abyMACAddr, param->sta_addr, WLAN_ADDR_LEN);\r\npMgmt->sNodeDBTable[uNodeIndex].eNodeState = NODE_ASSOC;\r\npMgmt->sNodeDBTable[uNodeIndex].wCapInfo = param->u.add_sta.capability;\r\npMgmt->sNodeDBTable[uNodeIndex].bPSEnable = false;\r\npMgmt->sNodeDBTable[uNodeIndex].bySuppRate = param->u.add_sta.tx_supp_rates;\r\npMgmt->sNodeDBTable[uNodeIndex].wTxDataRate =\r\npMgmt->sNodeDBTable[uNodeIndex].wMaxSuppRate;\r\npMgmt->sNodeDBTable[uNodeIndex].wMaxBasicRate = RATE_2M;\r\npMgmt->sNodeDBTable[uNodeIndex].bShortPreamble =\r\nWLAN_GET_CAP_INFO_SHORTPREAMBLE(pMgmt->sNodeDBTable[uNodeIndex].wCapInfo);\r\npMgmt->sNodeDBTable[uNodeIndex].wAID = (unsigned short)param->u.add_sta.aid;\r\npMgmt->sNodeDBTable[uNodeIndex].ulLastRxJiffer = jiffies;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Add STA AID= %d \n", pMgmt->sNodeDBTable[uNodeIndex].wAID);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MAC=%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X \n",\r\nparam->sta_addr[0],\r\nparam->sta_addr[1],\r\nparam->sta_addr[2],\r\nparam->sta_addr[3],\r\nparam->sta_addr[4],\r\nparam->sta_addr[5]\r\n) ;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Max Support rate = %d \n",\r\npMgmt->sNodeDBTable[uNodeIndex].wMaxSuppRate);\r\nreturn 0;\r\n}\r\nstatic int hostap_get_info_sta(PSDevice pDevice,\r\nstruct viawget_hostapd_param *param)\r\n{\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nunsigned int uNodeIndex;\r\nif (BSSDBbIsSTAInNodeDB(pMgmt, param->sta_addr, &uNodeIndex)) {\r\nparam->u.get_info_sta.inactive_sec =\r\n(jiffies - pMgmt->sNodeDBTable[uNodeIndex].ulLastRxJiffer) / HZ;\r\n}\r\nelse {\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hostap_set_flags_sta(PSDevice pDevice,\r\nstruct viawget_hostapd_param *param)\r\n{\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nunsigned int uNodeIndex;\r\nif (BSSDBbIsSTAInNodeDB(pMgmt, param->sta_addr, &uNodeIndex)) {\r\npMgmt->sNodeDBTable[uNodeIndex].dwFlags |= param->u.set_flags_sta.flags_or;\r\npMgmt->sNodeDBTable[uNodeIndex].dwFlags &= param->u.set_flags_sta.flags_and;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " dwFlags = %x \n",\r\n(unsigned int)pMgmt->sNodeDBTable[uNodeIndex].dwFlags);\r\n}\r\nelse {\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hostap_set_generic_element(PSDevice pDevice,\r\nstruct viawget_hostapd_param *param)\r\n{\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nmemcpy( pMgmt->abyWPAIE,\r\nparam->u.generic_elem.data,\r\nparam->u.generic_elem.len\r\n);\r\npMgmt->wWPAIELen = param->u.generic_elem.len;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pMgmt->wWPAIELen = %d\n", pMgmt->wWPAIELen);\r\nif (pMgmt->wWPAIELen == 0) {\r\npMgmt->eAuthenMode = WMAC_AUTH_OPEN;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " No WPAIE, Disable WPA \n");\r\n} else {\r\nif ((pMgmt->abyWPAIE[0] == WLAN_EID_RSN_WPA) ||\r\n(pMgmt->abyWPAIE[0] == WLAN_EID_RSN)) {\r\npMgmt->eAuthenMode = WMAC_AUTH_WPANONE;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set WPAIE enable WPA\n");\r\n} else\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hostap_flush_sta(PSDevice pDevice)\r\n{\r\nBSSvClearNodeDBTable(pDevice, 1);\r\npDevice->uAssocCount = 0;\r\nreturn;\r\n}\r\nstatic int hostap_set_encryption(PSDevice pDevice,\r\nstruct viawget_hostapd_param *param,\r\nint param_len)\r\n{\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nunsigned long dwKeyIndex = 0;\r\nunsigned char abyKey[MAX_KEY_LEN];\r\nunsigned char abySeq[MAX_KEY_LEN];\r\nNDIS_802_11_KEY_RSC KeyRSC;\r\nunsigned char byKeyDecMode = KEY_CTL_WEP;\r\nint ret = 0;\r\nint iNodeIndex = -1;\r\nint ii;\r\nbool bKeyTableFull = false;\r\nunsigned short wKeyCtl = 0;\r\nparam->u.crypt.err = 0;\r\nif (param->u.crypt.alg > WPA_ALG_CCMP)\r\nreturn -EINVAL;\r\nif ((param->u.crypt.idx > 3) || (param->u.crypt.key_len > MAX_KEY_LEN)) {\r\nparam->u.crypt.err = HOSTAP_CRYPT_ERR_KEY_SET_FAILED;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " HOSTAP_CRYPT_ERR_KEY_SET_FAILED\n");\r\nreturn -EINVAL;\r\n}\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\r\nif (param->u.crypt.idx >= MAX_GROUP_KEY)\r\nreturn -EINVAL;\r\niNodeIndex = 0;\r\n} else {\r\nif (BSSDBbIsSTAInNodeDB(pMgmt, param->sta_addr, &iNodeIndex) == false) {\r\nparam->u.crypt.err = HOSTAP_CRYPT_ERR_UNKNOWN_ADDR;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " HOSTAP_CRYPT_ERR_UNKNOWN_ADDR\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " hostap_set_encryption: sta_index %d \n", iNodeIndex);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " hostap_set_encryption: alg %d \n", param->u.crypt.alg);\r\nif (param->u.crypt.alg == WPA_ALG_NONE) {\r\nif (pMgmt->sNodeDBTable[iNodeIndex].bOnFly == true) {\r\nif (KeybRemoveKey(&(pDevice->sKey),\r\nparam->sta_addr,\r\npMgmt->sNodeDBTable[iNodeIndex].dwKeyIndex,\r\npDevice->PortOffset) == false) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "KeybRemoveKey fail \n");\r\n}\r\npMgmt->sNodeDBTable[iNodeIndex].bOnFly = false;\r\n}\r\npMgmt->sNodeDBTable[iNodeIndex].byKeyIndex = 0;\r\npMgmt->sNodeDBTable[iNodeIndex].dwKeyIndex = 0;\r\npMgmt->sNodeDBTable[iNodeIndex].uWepKeyLength = 0;\r\npMgmt->sNodeDBTable[iNodeIndex].KeyRSC = 0;\r\npMgmt->sNodeDBTable[iNodeIndex].dwTSC47_16 = 0;\r\npMgmt->sNodeDBTable[iNodeIndex].wTSC15_0 = 0;\r\npMgmt->sNodeDBTable[iNodeIndex].byCipherSuite = 0;\r\nmemset(&pMgmt->sNodeDBTable[iNodeIndex].abyWepKey[0],\r\n0,\r\nMAX_KEY_LEN\r\n);\r\nreturn ret;\r\n}\r\nmemcpy(abyKey, param->u.crypt.key, param->u.crypt.key_len);\r\npMgmt->sNodeDBTable[iNodeIndex].byKeyIndex = param->u.crypt.idx;\r\npMgmt->sNodeDBTable[iNodeIndex].uWepKeyLength = param->u.crypt.key_len;\r\nmemcpy(&pMgmt->sNodeDBTable[iNodeIndex].abyWepKey[0],\r\nparam->u.crypt.key,\r\nparam->u.crypt.key_len\r\n);\r\ndwKeyIndex = (unsigned long)(param->u.crypt.idx);\r\nif (param->u.crypt.flags & HOSTAP_CRYPT_FLAG_SET_TX_KEY) {\r\npDevice->byKeyIndex = (unsigned char)dwKeyIndex;\r\npDevice->bTransmitKey = true;\r\ndwKeyIndex |= (1 << 31);\r\n}\r\nif (param->u.crypt.alg == WPA_ALG_WEP) {\r\nif ((pDevice->bEnable8021x == false) || (iNodeIndex == 0)) {\r\nKeybSetDefaultKey(&(pDevice->sKey),\r\ndwKeyIndex & ~(BIT30 | USE_KEYRSC),\r\nparam->u.crypt.key_len,\r\nNULL,\r\nabyKey,\r\nKEY_CTL_WEP,\r\npDevice->PortOffset,\r\npDevice->byLocalID);\r\n} else {\r\ndwKeyIndex |= (1 << 30);\r\nif (KeybSetKey(&(pDevice->sKey),\r\n&param->sta_addr[0],\r\ndwKeyIndex & ~(USE_KEYRSC),\r\nparam->u.crypt.key_len,\r\n(PQWORD) &(KeyRSC),\r\n(unsigned char *)abyKey,\r\nKEY_CTL_WEP,\r\npDevice->PortOffset,\r\npDevice->byLocalID) == true) {\r\npMgmt->sNodeDBTable[iNodeIndex].bOnFly = true;\r\n} else {\r\npMgmt->sNodeDBTable[iNodeIndex].bOnFly = false;\r\nbKeyTableFull = true;\r\n}\r\n}\r\npDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;\r\npDevice->bEncryptionEnable = true;\r\npMgmt->byCSSPK = KEY_CTL_WEP;\r\npMgmt->byCSSGK = KEY_CTL_WEP;\r\npMgmt->sNodeDBTable[iNodeIndex].byCipherSuite = KEY_CTL_WEP;\r\npMgmt->sNodeDBTable[iNodeIndex].dwKeyIndex = dwKeyIndex;\r\nreturn ret;\r\n}\r\nif (param->u.crypt.seq) {\r\nmemcpy(&abySeq, param->u.crypt.seq, 8);\r\nfor (ii = 0 ; ii < 8 ; ii++) {\r\nKeyRSC |= (abySeq[ii] << (ii * 8));\r\n}\r\ndwKeyIndex |= 1 << 29;\r\npMgmt->sNodeDBTable[iNodeIndex].KeyRSC = KeyRSC;\r\n}\r\nif (param->u.crypt.alg == WPA_ALG_TKIP) {\r\nif (param->u.crypt.key_len != MAX_KEY_LEN)\r\nreturn -EINVAL;\r\npDevice->eEncryptionStatus = Ndis802_11Encryption2Enabled;\r\nbyKeyDecMode = KEY_CTL_TKIP;\r\npMgmt->byCSSPK = KEY_CTL_TKIP;\r\npMgmt->byCSSGK = KEY_CTL_TKIP;\r\n}\r\nif (param->u.crypt.alg == WPA_ALG_CCMP) {\r\nif ((param->u.crypt.key_len != AES_KEY_LEN) ||\r\n(pDevice->byLocalID <= REV_ID_VT3253_A1))\r\nreturn -EINVAL;\r\npDevice->eEncryptionStatus = Ndis802_11Encryption3Enabled;\r\nbyKeyDecMode = KEY_CTL_CCMP;\r\npMgmt->byCSSPK = KEY_CTL_CCMP;\r\npMgmt->byCSSGK = KEY_CTL_CCMP;\r\n}\r\nif (iNodeIndex == 0) {\r\nKeybSetDefaultKey(&(pDevice->sKey),\r\ndwKeyIndex,\r\nparam->u.crypt.key_len,\r\n(PQWORD) &(KeyRSC),\r\nabyKey,\r\nbyKeyDecMode,\r\npDevice->PortOffset,\r\npDevice->byLocalID);\r\npMgmt->sNodeDBTable[iNodeIndex].bOnFly = true;\r\n} else {\r\ndwKeyIndex |= (1 << 30);\r\nif (KeybSetKey(&(pDevice->sKey),\r\n&param->sta_addr[0],\r\ndwKeyIndex,\r\nparam->u.crypt.key_len,\r\n(PQWORD) &(KeyRSC),\r\n(unsigned char *)abyKey,\r\nbyKeyDecMode,\r\npDevice->PortOffset,\r\npDevice->byLocalID) == true) {\r\npMgmt->sNodeDBTable[iNodeIndex].bOnFly = true;\r\n} else {\r\npMgmt->sNodeDBTable[iNodeIndex].bOnFly = false;\r\nbKeyTableFull = true;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Key Table Full\n");\r\n}\r\n}\r\nif (bKeyTableFull == true) {\r\nwKeyCtl &= 0x7F00;\r\nwKeyCtl |= (byKeyDecMode << 4);\r\nwKeyCtl |= (byKeyDecMode);\r\nwKeyCtl |= 0x0044;\r\nwKeyCtl |= 0x4000;\r\nMACvSetDefaultKeyCtl(pDevice->PortOffset, wKeyCtl, MAX_KEY_TABLE-1, pDevice->byLocalID);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Set key sta_index= %d \n", iNodeIndex);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " tx_index=%d len=%d \n", param->u.crypt.idx,\r\nparam->u.crypt.key_len );\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " key=%x-%x-%x-%x-%x-xxxxx \n",\r\npMgmt->sNodeDBTable[iNodeIndex].abyWepKey[0],\r\npMgmt->sNodeDBTable[iNodeIndex].abyWepKey[1],\r\npMgmt->sNodeDBTable[iNodeIndex].abyWepKey[2],\r\npMgmt->sNodeDBTable[iNodeIndex].abyWepKey[3],\r\npMgmt->sNodeDBTable[iNodeIndex].abyWepKey[4]\r\n);\r\npDevice->bEncryptionEnable = true;\r\npMgmt->sNodeDBTable[iNodeIndex].byCipherSuite = byKeyDecMode;\r\npMgmt->sNodeDBTable[iNodeIndex].dwKeyIndex = dwKeyIndex;\r\npMgmt->sNodeDBTable[iNodeIndex].dwTSC47_16 = 0;\r\npMgmt->sNodeDBTable[iNodeIndex].wTSC15_0 = 0;\r\nreturn ret;\r\n}\r\nstatic int hostap_get_encryption(PSDevice pDevice,\r\nstruct viawget_hostapd_param *param,\r\nint param_len)\r\n{\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nint ret = 0;\r\nint ii;\r\nint iNodeIndex =0;\r\nparam->u.crypt.err = 0;\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\r\niNodeIndex = 0;\r\n} else {\r\nif (BSSDBbIsSTAInNodeDB(pMgmt, param->sta_addr, &iNodeIndex) == false) {\r\nparam->u.crypt.err = HOSTAP_CRYPT_ERR_UNKNOWN_ADDR;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "hostap_get_encryption: HOSTAP_CRYPT_ERR_UNKNOWN_ADDR\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "hostap_get_encryption: %d\n", iNodeIndex);\r\nmemset(param->u.crypt.seq, 0, 8);\r\nfor (ii = 0 ; ii < 8 ; ii++) {\r\nparam->u.crypt.seq[ii] = (unsigned char)pMgmt->sNodeDBTable[iNodeIndex].KeyRSC >> (ii * 8);\r\n}\r\nreturn ret;\r\n}\r\nint vt6655_hostap_ioctl(PSDevice pDevice, struct iw_point *p)\r\n{\r\nstruct viawget_hostapd_param *param;\r\nint ret = 0;\r\nint ap_ioctl = 0;\r\nif (p->length < sizeof(struct viawget_hostapd_param) ||\r\np->length > VIAWGET_HOSTAPD_MAX_BUF_SIZE || !p->pointer)\r\nreturn -EINVAL;\r\nparam = kmalloc((int)p->length, (int)GFP_KERNEL);\r\nif (param == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(param, p->pointer, p->length)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nswitch (param->cmd) {\r\ncase VIAWGET_HOSTAPD_SET_ENCRYPTION:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_SET_ENCRYPTION \n");\r\nspin_lock_irq(&pDevice->lock);\r\nret = hostap_set_encryption(pDevice, param, p->length);\r\nspin_unlock_irq(&pDevice->lock);\r\nbreak;\r\ncase VIAWGET_HOSTAPD_GET_ENCRYPTION:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_GET_ENCRYPTION \n");\r\nspin_lock_irq(&pDevice->lock);\r\nret = hostap_get_encryption(pDevice, param, p->length);\r\nspin_unlock_irq(&pDevice->lock);\r\nbreak;\r\ncase VIAWGET_HOSTAPD_SET_ASSOC_AP_ADDR:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_SET_ASSOC_AP_ADDR \n");\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\ncase VIAWGET_HOSTAPD_FLUSH:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_FLUSH \n");\r\nspin_lock_irq(&pDevice->lock);\r\nhostap_flush_sta(pDevice);\r\nspin_unlock_irq(&pDevice->lock);\r\nbreak;\r\ncase VIAWGET_HOSTAPD_ADD_STA:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_ADD_STA \n");\r\nspin_lock_irq(&pDevice->lock);\r\nret = hostap_add_sta(pDevice, param);\r\nspin_unlock_irq(&pDevice->lock);\r\nbreak;\r\ncase VIAWGET_HOSTAPD_REMOVE_STA:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_REMOVE_STA \n");\r\nspin_lock_irq(&pDevice->lock);\r\nret = hostap_remove_sta(pDevice, param);\r\nspin_unlock_irq(&pDevice->lock);\r\nbreak;\r\ncase VIAWGET_HOSTAPD_GET_INFO_STA:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_GET_INFO_STA \n");\r\nret = hostap_get_info_sta(pDevice, param);\r\nap_ioctl = 1;\r\nbreak;\r\ncase VIAWGET_HOSTAPD_SET_FLAGS_STA:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_SET_FLAGS_STA \n");\r\nret = hostap_set_flags_sta(pDevice, param);\r\nbreak;\r\ncase VIAWGET_HOSTAPD_MLME:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_MLME \n");\r\nreturn -EOPNOTSUPP;\r\ncase VIAWGET_HOSTAPD_SET_GENERIC_ELEMENT:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_SET_GENERIC_ELEMENT \n");\r\nret = hostap_set_generic_element(pDevice, param);\r\nbreak;\r\ncase VIAWGET_HOSTAPD_SCAN_REQ:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_SCAN_REQ \n");\r\nreturn -EOPNOTSUPP;\r\ncase VIAWGET_HOSTAPD_STA_CLEAR_STATS:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "VIAWGET_HOSTAPD_STA_CLEAR_STATS \n");\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "vt6655_hostap_ioctl: unknown cmd=%d\n",\r\n(int)param->cmd);\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif ((ret == 0) && ap_ioctl) {\r\nif (copy_to_user(p->pointer, param, p->length)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nkfree(param);\r\nreturn ret;\r\n}
