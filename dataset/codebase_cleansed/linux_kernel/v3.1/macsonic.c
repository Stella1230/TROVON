static inline void bit_reverse_addr(unsigned char addr[6])\r\n{\r\nint i;\r\nfor(i = 0; i < 6; i++)\r\naddr[i] = bitrev8(addr[i]);\r\n}\r\nstatic irqreturn_t macsonic_interrupt(int irq, void *dev_id)\r\n{\r\nirqreturn_t result;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nresult = sonic_interrupt(irq, dev_id);\r\nlocal_irq_restore(flags);\r\nreturn result;\r\n}\r\nstatic int macsonic_open(struct net_device* dev)\r\n{\r\nint retval;\r\nretval = request_irq(dev->irq, sonic_interrupt, IRQ_FLG_FAST,\r\n"sonic", dev);\r\nif (retval) {\r\nprintk(KERN_ERR "%s: unable to get IRQ %d.\n",\r\ndev->name, dev->irq);\r\ngoto err;\r\n}\r\nif (dev->irq == IRQ_AUTO_3) {\r\nretval = request_irq(IRQ_NUBUS_9, macsonic_interrupt,\r\nIRQ_FLG_FAST, "sonic", dev);\r\nif (retval) {\r\nprintk(KERN_ERR "%s: unable to get IRQ %d.\n",\r\ndev->name, IRQ_NUBUS_9);\r\ngoto err_irq;\r\n}\r\n}\r\nretval = sonic_open(dev);\r\nif (retval)\r\ngoto err_irq_nubus;\r\nreturn 0;\r\nerr_irq_nubus:\r\nif (dev->irq == IRQ_AUTO_3)\r\nfree_irq(IRQ_NUBUS_9, dev);\r\nerr_irq:\r\nfree_irq(dev->irq, dev);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int macsonic_close(struct net_device* dev)\r\n{\r\nint err;\r\nerr = sonic_close(dev);\r\nfree_irq(dev->irq, dev);\r\nif (dev->irq == IRQ_AUTO_3)\r\nfree_irq(IRQ_NUBUS_9, dev);\r\nreturn err;\r\n}\r\nstatic int __devinit macsonic_init(struct net_device *dev)\r\n{\r\nstruct sonic_local* lp = netdev_priv(dev);\r\nif ((lp->descriptors = dma_alloc_coherent(lp->device,\r\nSIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\r\n&lp->descriptors_laddr, GFP_KERNEL)) == NULL) {\r\nprintk(KERN_ERR "%s: couldn't alloc DMA memory for descriptors.\n",\r\ndev_name(lp->device));\r\nreturn -ENOMEM;\r\n}\r\nlp->cda = lp->descriptors;\r\nlp->tda = lp->cda + (SIZEOF_SONIC_CDA\r\n* SONIC_BUS_SCALE(lp->dma_bitmode));\r\nlp->rda = lp->tda + (SIZEOF_SONIC_TD * SONIC_NUM_TDS\r\n* SONIC_BUS_SCALE(lp->dma_bitmode));\r\nlp->rra = lp->rda + (SIZEOF_SONIC_RD * SONIC_NUM_RDS\r\n* SONIC_BUS_SCALE(lp->dma_bitmode));\r\nlp->cda_laddr = lp->descriptors_laddr;\r\nlp->tda_laddr = lp->cda_laddr + (SIZEOF_SONIC_CDA\r\n* SONIC_BUS_SCALE(lp->dma_bitmode));\r\nlp->rda_laddr = lp->tda_laddr + (SIZEOF_SONIC_TD * SONIC_NUM_TDS\r\n* SONIC_BUS_SCALE(lp->dma_bitmode));\r\nlp->rra_laddr = lp->rda_laddr + (SIZEOF_SONIC_RD * SONIC_NUM_RDS\r\n* SONIC_BUS_SCALE(lp->dma_bitmode));\r\ndev->netdev_ops = &macsonic_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nSONIC_WRITE(SONIC_CRCT, 0xffff);\r\nSONIC_WRITE(SONIC_FAET, 0xffff);\r\nSONIC_WRITE(SONIC_MPT, 0xffff);\r\nreturn 0;\r\n}\r\nstatic void __devinit mac_onboard_sonic_ethernet_addr(struct net_device *dev)\r\n{\r\nstruct sonic_local *lp = netdev_priv(dev);\r\nconst int prom_addr = ONBOARD_SONIC_PROM_BASE;\r\nunsigned short val;\r\nif (hwreg_present((void *)prom_addr)) {\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = SONIC_READ_PROM(i);\r\nif (!INVALID_MAC(dev->dev_addr))\r\nreturn;\r\nbit_reverse_addr(dev->dev_addr);\r\nif (!INVALID_MAC(dev->dev_addr))\r\nreturn;\r\nprintk(KERN_WARNING "macsonic: MAC address in PROM seems "\r\n"to be invalid, trying CAM\n");\r\n} else {\r\nprintk(KERN_WARNING "macsonic: cannot read MAC address from "\r\n"PROM, trying CAM\n");\r\n}\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\r\nSONIC_WRITE(SONIC_CEP, 15);\r\nval = SONIC_READ(SONIC_CAP2);\r\ndev->dev_addr[5] = val >> 8;\r\ndev->dev_addr[4] = val & 0xff;\r\nval = SONIC_READ(SONIC_CAP1);\r\ndev->dev_addr[3] = val >> 8;\r\ndev->dev_addr[2] = val & 0xff;\r\nval = SONIC_READ(SONIC_CAP0);\r\ndev->dev_addr[1] = val >> 8;\r\ndev->dev_addr[0] = val & 0xff;\r\nif (!INVALID_MAC(dev->dev_addr))\r\nreturn;\r\nprintk(KERN_WARNING "macsonic: MAC address in CAM entry 15 "\r\n"seems invalid, will use a random MAC\n");\r\nrandom_ether_addr(dev->dev_addr);\r\n}\r\nstatic int __devinit mac_onboard_sonic_probe(struct net_device *dev)\r\n{\r\nstatic int once_is_more_than_enough;\r\nstruct sonic_local* lp = netdev_priv(dev);\r\nint sr;\r\nint commslot = 0;\r\nif (once_is_more_than_enough)\r\nreturn -ENODEV;\r\nonce_is_more_than_enough = 1;\r\nif (!MACH_IS_MAC)\r\nreturn -ENODEV;\r\nif (macintosh_config->ether_type != MAC_ETHER_SONIC)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "Checking for internal Macintosh ethernet (SONIC).. ");\r\nif (macintosh_config->ident == MAC_MODEL_Q630 ||\r\nmacintosh_config->ident == MAC_MODEL_P588 ||\r\nmacintosh_config->ident == MAC_MODEL_P575 ||\r\nmacintosh_config->ident == MAC_MODEL_C610) {\r\nunsigned long flags;\r\nint card_present;\r\nlocal_irq_save(flags);\r\ncard_present = hwreg_present((void*)ONBOARD_SONIC_REGISTERS);\r\nlocal_irq_restore(flags);\r\nif (!card_present) {\r\nprintk("none.\n");\r\nreturn -ENODEV;\r\n}\r\ncommslot = 1;\r\n}\r\nprintk("yes\n");\r\ndev->base_addr = ONBOARD_SONIC_REGISTERS;\r\nif (via_alt_mapping)\r\ndev->irq = IRQ_AUTO_3;\r\nelse\r\ndev->irq = IRQ_NUBUS_9;\r\nif (!sonic_version_printed) {\r\nprintk(KERN_INFO "%s", version);\r\nsonic_version_printed = 1;\r\n}\r\nprintk(KERN_INFO "%s: onboard / comm-slot SONIC at 0x%08lx\n",\r\ndev_name(lp->device), dev->base_addr);\r\nif (macintosh_config->ident == MAC_MODEL_PB520) {\r\nlp->reg_offset = 0;\r\nlp->dma_bitmode = SONIC_BITMODE16;\r\nsr = SONIC_READ(SONIC_SR);\r\n} else if (commslot) {\r\nlp->reg_offset = 2;\r\nlp->dma_bitmode = SONIC_BITMODE16;\r\nsr = SONIC_READ(SONIC_SR);\r\nif (sr == 0x0004 || sr == 0x0006 || sr == 0x0100 || sr == 0x0101)\r\nlp->dma_bitmode = SONIC_BITMODE32;\r\nelse {\r\nlp->dma_bitmode = SONIC_BITMODE16;\r\nlp->reg_offset = 0;\r\nsr = SONIC_READ(SONIC_SR);\r\n}\r\n} else {\r\nlp->reg_offset = 2;\r\nlp->dma_bitmode = SONIC_BITMODE32;\r\nsr = SONIC_READ(SONIC_SR);\r\n}\r\nprintk(KERN_INFO\r\n"%s: revision 0x%04x, using %d bit DMA and register offset %d\n",\r\ndev_name(lp->device), sr, lp->dma_bitmode?32:16, lp->reg_offset);\r\n#if 0\r\nprintk(KERN_INFO "%s: DCR: 0x%04x, DCR2: 0x%04x\n", dev_name(lp->device),\r\nSONIC_READ(SONIC_DCR) & 0xffff, SONIC_READ(SONIC_DCR2) & 0xffff);\r\n#endif\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\r\nSONIC_WRITE(SONIC_DCR, SONIC_DCR_EXBUS | SONIC_DCR_BMS |\r\nSONIC_DCR_RFT1 | SONIC_DCR_TFT0 |\r\n(lp->dma_bitmode ? SONIC_DCR_DW : 0));\r\nSONIC_WRITE(SONIC_DCR2, 0);\r\nSONIC_WRITE(SONIC_IMR, 0);\r\nSONIC_WRITE(SONIC_ISR, 0x7fff);\r\nmac_onboard_sonic_ethernet_addr(dev);\r\nreturn macsonic_init(dev);\r\n}\r\nstatic int __devinit mac_nubus_sonic_ethernet_addr(struct net_device *dev,\r\nunsigned long prom_addr,\r\nint id)\r\n{\r\nint i;\r\nfor(i = 0; i < 6; i++)\r\ndev->dev_addr[i] = SONIC_READ_PROM(i);\r\nif (id != MACSONIC_DAYNA)\r\nbit_reverse_addr(dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int __devinit macsonic_ident(struct nubus_dev *ndev)\r\n{\r\nif (ndev->dr_hw == NUBUS_DRHW_ASANTE_LC &&\r\nndev->dr_sw == NUBUS_DRSW_SONIC_LC)\r\nreturn MACSONIC_DAYNALINK;\r\nif (ndev->dr_hw == NUBUS_DRHW_SONIC &&\r\nndev->dr_sw == NUBUS_DRSW_APPLE) {\r\nif (strstr(ndev->board->name, "DuoDock"))\r\nreturn MACSONIC_DUODOCK;\r\nelse\r\nreturn MACSONIC_APPLE;\r\n}\r\nif (ndev->dr_hw == NUBUS_DRHW_SMC9194 &&\r\nndev->dr_sw == NUBUS_DRSW_DAYNA)\r\nreturn MACSONIC_DAYNA;\r\nif (ndev->dr_hw == NUBUS_DRHW_APPLE_SONIC_LC &&\r\nndev->dr_sw == 0) {\r\nreturn MACSONIC_APPLE16;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __devinit mac_nubus_sonic_probe(struct net_device *dev)\r\n{\r\nstatic int slots;\r\nstruct nubus_dev* ndev = NULL;\r\nstruct sonic_local* lp = netdev_priv(dev);\r\nunsigned long base_addr, prom_addr;\r\nu16 sonic_dcr;\r\nint id = -1;\r\nint reg_offset, dma_bitmode;\r\nwhile ((ndev = nubus_find_type(NUBUS_CAT_NETWORK,\r\nNUBUS_TYPE_ETHERNET, ndev)) != NULL)\r\n{\r\nif (slots & (1<<ndev->board->slot))\r\ncontinue;\r\nslots |= 1<<ndev->board->slot;\r\nif ((id = macsonic_ident(ndev)) != -1)\r\nbreak;\r\n}\r\nif (ndev == NULL)\r\nreturn -ENODEV;\r\nswitch (id) {\r\ncase MACSONIC_DUODOCK:\r\nbase_addr = ndev->board->slot_addr + DUODOCK_SONIC_REGISTERS;\r\nprom_addr = ndev->board->slot_addr + DUODOCK_SONIC_PROM_BASE;\r\nsonic_dcr = SONIC_DCR_EXBUS | SONIC_DCR_RFT0 | SONIC_DCR_RFT1 |\r\nSONIC_DCR_TFT0;\r\nreg_offset = 2;\r\ndma_bitmode = SONIC_BITMODE32;\r\nbreak;\r\ncase MACSONIC_APPLE:\r\nbase_addr = ndev->board->slot_addr + APPLE_SONIC_REGISTERS;\r\nprom_addr = ndev->board->slot_addr + APPLE_SONIC_PROM_BASE;\r\nsonic_dcr = SONIC_DCR_BMS | SONIC_DCR_RFT1 | SONIC_DCR_TFT0;\r\nreg_offset = 0;\r\ndma_bitmode = SONIC_BITMODE32;\r\nbreak;\r\ncase MACSONIC_APPLE16:\r\nbase_addr = ndev->board->slot_addr + APPLE_SONIC_REGISTERS;\r\nprom_addr = ndev->board->slot_addr + APPLE_SONIC_PROM_BASE;\r\nsonic_dcr = SONIC_DCR_EXBUS | SONIC_DCR_RFT1 | SONIC_DCR_TFT0 |\r\nSONIC_DCR_PO1 | SONIC_DCR_BMS;\r\nreg_offset = 0;\r\ndma_bitmode = SONIC_BITMODE16;\r\nbreak;\r\ncase MACSONIC_DAYNALINK:\r\nbase_addr = ndev->board->slot_addr + APPLE_SONIC_REGISTERS;\r\nprom_addr = ndev->board->slot_addr + DAYNALINK_PROM_BASE;\r\nsonic_dcr = SONIC_DCR_RFT1 | SONIC_DCR_TFT0 |\r\nSONIC_DCR_PO1 | SONIC_DCR_BMS;\r\nreg_offset = 0;\r\ndma_bitmode = SONIC_BITMODE16;\r\nbreak;\r\ncase MACSONIC_DAYNA:\r\nbase_addr = ndev->board->slot_addr + DAYNA_SONIC_REGISTERS;\r\nprom_addr = ndev->board->slot_addr + DAYNA_SONIC_MAC_ADDR;\r\nsonic_dcr = SONIC_DCR_BMS |\r\nSONIC_DCR_RFT1 | SONIC_DCR_TFT0 | SONIC_DCR_PO1;\r\nreg_offset = 0;\r\ndma_bitmode = SONIC_BITMODE16;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "macsonic: WTF, id is %d\n", id);\r\nreturn -ENODEV;\r\n}\r\ndev->base_addr = base_addr;\r\nlp->reg_offset = reg_offset;\r\nlp->dma_bitmode = dma_bitmode;\r\ndev->irq = SLOT2IRQ(ndev->board->slot);\r\nif (!sonic_version_printed) {\r\nprintk(KERN_INFO "%s", version);\r\nsonic_version_printed = 1;\r\n}\r\nprintk(KERN_INFO "%s: %s in slot %X\n",\r\ndev_name(lp->device), ndev->board->name, ndev->board->slot);\r\nprintk(KERN_INFO "%s: revision 0x%04x, using %d bit DMA and register offset %d\n",\r\ndev_name(lp->device), SONIC_READ(SONIC_SR), dma_bitmode?32:16, reg_offset);\r\n#if 0\r\nprintk(KERN_INFO "%s: DCR: 0x%04x, DCR2: 0x%04x\n", dev_name(lp->device),\r\nSONIC_READ(SONIC_DCR) & 0xffff, SONIC_READ(SONIC_DCR2) & 0xffff);\r\n#endif\r\nSONIC_WRITE(SONIC_CMD, SONIC_CR_RST);\r\nSONIC_WRITE(SONIC_DCR, sonic_dcr | (dma_bitmode ? SONIC_DCR_DW : 0));\r\nSONIC_WRITE(SONIC_DCR2, 0);\r\nSONIC_WRITE(SONIC_IMR, 0);\r\nSONIC_WRITE(SONIC_ISR, 0x7fff);\r\nif (mac_nubus_sonic_ethernet_addr(dev, prom_addr, id) != 0)\r\nreturn -ENODEV;\r\nreturn macsonic_init(dev);\r\n}\r\nstatic int __devinit mac_sonic_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct sonic_local *lp;\r\nint err;\r\ndev = alloc_etherdev(sizeof(struct sonic_local));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nlp->device = &pdev->dev;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nplatform_set_drvdata(pdev, dev);\r\nerr = mac_onboard_sonic_probe(dev);\r\nif (err == 0)\r\ngoto found;\r\nif (err != -ENODEV)\r\ngoto out;\r\nerr = mac_nubus_sonic_probe(dev);\r\nif (err)\r\ngoto out;\r\nfound:\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out;\r\nprintk("%s: MAC %pM IRQ %d\n", dev->name, dev->dev_addr, dev->irq);\r\nreturn 0;\r\nout:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int __devexit mac_sonic_device_remove (struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct sonic_local* lp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\ndma_free_coherent(lp->device, SIZEOF_SONIC_DESC * SONIC_BUS_SCALE(lp->dma_bitmode),\r\nlp->descriptors, lp->descriptors_laddr);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\nstatic int __init mac_sonic_init_module(void)\r\n{\r\nreturn platform_driver_register(&mac_sonic_driver);\r\n}\r\nstatic void __exit mac_sonic_cleanup_module(void)\r\n{\r\nplatform_driver_unregister(&mac_sonic_driver);\r\n}
