uint r8712_usb_init_intf_priv(struct intf_priv *pintfpriv)\r\n{\r\npintfpriv->piorw_urb = _usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!pintfpriv->piorw_urb)\r\nreturn _FAIL;\r\nsema_init(&(pintfpriv->io_retevt), 0);\r\nreturn _SUCCESS;\r\n}\r\nvoid r8712_usb_unload_intf_priv(struct intf_priv *pintfpriv)\r\n{\r\nif (pintfpriv->piorw_urb) {\r\nusb_kill_urb(pintfpriv->piorw_urb);\r\nusb_free_urb(pintfpriv->piorw_urb);\r\n}\r\n}\r\nstatic unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)\r\n{\r\nunsigned int pipe = 0;\r\nstruct usb_device *pusbd = pdvobj->pusbdev;\r\nif (pdvobj->nr_endpoint == 11) {\r\nswitch (addr) {\r\ncase RTL8712_DMA_BKQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x07);\r\nbreak;\r\ncase RTL8712_DMA_BEQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x06);\r\nbreak;\r\ncase RTL8712_DMA_VIQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x05);\r\nbreak;\r\ncase RTL8712_DMA_VOQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x04);\r\nbreak;\r\ncase RTL8712_DMA_BCNQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x0a);\r\nbreak;\r\ncase RTL8712_DMA_BMCQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x0b);\r\nbreak;\r\ncase RTL8712_DMA_MGTQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x0c);\r\nbreak;\r\ncase RTL8712_DMA_RX0FF:\r\npipe = usb_rcvbulkpipe(pusbd, 0x03);\r\nbreak;\r\ncase RTL8712_DMA_C2HCMD:\r\npipe = usb_rcvbulkpipe(pusbd, 0x09);\r\nbreak;\r\ncase RTL8712_DMA_H2CCMD:\r\npipe = usb_sndbulkpipe(pusbd, 0x0d);\r\nbreak;\r\n}\r\n} else if (pdvobj->nr_endpoint == 6) {\r\nswitch (addr) {\r\ncase RTL8712_DMA_BKQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x07);\r\nbreak;\r\ncase RTL8712_DMA_BEQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x06);\r\nbreak;\r\ncase RTL8712_DMA_VIQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x05);\r\nbreak;\r\ncase RTL8712_DMA_VOQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x04);\r\nbreak;\r\ncase RTL8712_DMA_RX0FF:\r\ncase RTL8712_DMA_C2HCMD:\r\npipe = usb_rcvbulkpipe(pusbd, 0x03);\r\nbreak;\r\ncase RTL8712_DMA_H2CCMD:\r\ncase RTL8712_DMA_BCNQ:\r\ncase RTL8712_DMA_BMCQ:\r\ncase RTL8712_DMA_MGTQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x0d);\r\nbreak;\r\n}\r\n} else if (pdvobj->nr_endpoint == 4) {\r\nswitch (addr) {\r\ncase RTL8712_DMA_BEQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x06);\r\nbreak;\r\ncase RTL8712_DMA_VOQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x04);\r\nbreak;\r\ncase RTL8712_DMA_RX0FF:\r\ncase RTL8712_DMA_C2HCMD:\r\npipe = usb_rcvbulkpipe(pusbd, 0x03);\r\nbreak;\r\ncase RTL8712_DMA_H2CCMD:\r\ncase RTL8712_DMA_BCNQ:\r\ncase RTL8712_DMA_BMCQ:\r\ncase RTL8712_DMA_MGTQ:\r\npipe = usb_sndbulkpipe(pusbd, 0x0d);\r\nbreak;\r\n}\r\n} else\r\npipe = 0;\r\nreturn pipe;\r\n}\r\nstatic void usb_write_mem_complete(struct urb *purb)\r\n{\r\nstruct io_queue *pio_q = (struct io_queue *)purb->context;\r\nstruct intf_hdl *pintf = &(pio_q->intf);\r\nstruct intf_priv *pintfpriv = pintf->pintfpriv;\r\nstruct _adapter *padapter = (struct _adapter *)pintf->adapter;\r\nif (purb->status != 0) {\r\nif (purb->status == (-ESHUTDOWN))\r\npadapter->bDriverStopped = true;\r\nelse\r\npadapter->bSurpriseRemoved = true;\r\n}\r\nup(&pintfpriv->io_retevt);\r\n}\r\nvoid r8712_usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)\r\n{\r\nunsigned int pipe;\r\nint status;\r\nstruct _adapter *padapter = (struct _adapter *)pintfhdl->adapter;\r\nstruct intf_priv *pintfpriv = pintfhdl->pintfpriv;\r\nstruct io_queue *pio_queue = (struct io_queue *)padapter->pio_queue;\r\nstruct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;\r\nstruct usb_device *pusbd = pdvobj->pusbdev;\r\nstruct urb *piorw_urb = pintfpriv->piorw_urb;\r\nif ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||\r\n(padapter->pwrctrlpriv.pnp_bstop_trx))\r\nreturn;\r\npipe = ffaddr2pipehdl(pdvobj, addr);\r\nif (pipe == 0)\r\nreturn;\r\nusb_fill_bulk_urb(piorw_urb, pusbd, pipe,\r\nwmem, cnt, usb_write_mem_complete,\r\npio_queue);\r\nstatus = _usb_submit_urb(piorw_urb, GFP_ATOMIC);\r\n_down_sema(&pintfpriv->io_retevt);\r\n}\r\nstatic void r8712_usb_read_port_complete(struct urb *purb)\r\n{\r\nuint isevt, *pbuf;\r\nstruct recv_buf *precvbuf = (struct recv_buf *)purb->context;\r\nstruct _adapter *padapter = (struct _adapter *)precvbuf->adapter;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nif (padapter->bSurpriseRemoved || padapter->bDriverStopped)\r\nreturn;\r\nif (purb->status == 0) {\r\nif ((purb->actual_length > (MAX_RECVBUF_SZ)) ||\r\n(purb->actual_length < RXDESC_SIZE)) {\r\nprecvbuf->reuse = true;\r\nr8712_read_port(padapter, precvpriv->ff_hwaddr, 0,\r\n(unsigned char *)precvbuf);\r\n} else {\r\nprecvbuf->transfer_len = purb->actual_length;\r\npbuf = (uint *)precvbuf->pbuf;\r\nisevt = le32_to_cpu(*(pbuf + 1)) & 0x1ff;\r\nif ((isevt & 0x1ff) == 0x1ff) {\r\nr8712_rxcmd_event_hdl(padapter, pbuf);\r\nprecvbuf->reuse = true;\r\nr8712_read_port(padapter, precvpriv->ff_hwaddr,\r\n0, (unsigned char *)precvbuf);\r\n} else {\r\n_pkt *pskb = precvbuf->pskb;\r\nskb_put(pskb, purb->actual_length);\r\nskb_queue_tail(&precvpriv->rx_skb_queue, pskb);\r\ntasklet_hi_schedule(&precvpriv->recv_tasklet);\r\nprecvbuf->pskb = NULL;\r\nprecvbuf->reuse = false;\r\nr8712_read_port(padapter, precvpriv->ff_hwaddr,\r\n0, (unsigned char *)precvbuf);\r\n}\r\n}\r\n} else {\r\nswitch (purb->status) {\r\ncase -EINVAL:\r\ncase -EPIPE:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ncase -ENOENT:\r\npadapter->bDriverStopped = true;\r\nbreak;\r\ncase -EPROTO:\r\nprecvbuf->reuse = true;\r\nr8712_read_port(padapter, precvpriv->ff_hwaddr, 0,\r\n(unsigned char *)precvbuf);\r\nbreak;\r\ncase -EINPROGRESS:\r\nprintk(KERN_ERR "r8712u: ERROR: URB IS IN"\r\n" PROGRESS!/n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nu32 r8712_usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)\r\n{\r\nunsigned int pipe;\r\nint err;\r\nu32 tmpaddr = 0;\r\nint alignment = 0;\r\nu32 ret = _SUCCESS;\r\nstruct urb *purb = NULL;\r\nstruct recv_buf *precvbuf = (struct recv_buf *)rmem;\r\nstruct intf_priv *pintfpriv = pintfhdl->pintfpriv;\r\nstruct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;\r\nstruct _adapter *adapter = (struct _adapter *)pdvobj->padapter;\r\nstruct recv_priv *precvpriv = &adapter->recvpriv;\r\nstruct usb_device *pusbd = pdvobj->pusbdev;\r\nif (adapter->bDriverStopped || adapter->bSurpriseRemoved ||\r\nadapter->pwrctrlpriv.pnp_bstop_trx)\r\nreturn _FAIL;\r\nif ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {\r\nprecvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue);\r\nif (NULL != precvbuf->pskb)\r\nprecvbuf->reuse = true;\r\n}\r\nif (precvbuf != NULL) {\r\nr8712_init_recvbuf(adapter, precvbuf);\r\nif ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {\r\nprecvbuf->pskb = netdev_alloc_skb(adapter->pnetdev,\r\nMAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);\r\nif (precvbuf->pskb == NULL)\r\nreturn _FAIL;\r\ntmpaddr = (addr_t)precvbuf->pskb->data;\r\nalignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);\r\nskb_reserve(precvbuf->pskb,\r\n(RECVBUFF_ALIGN_SZ - alignment));\r\nprecvbuf->phead = precvbuf->pskb->head;\r\nprecvbuf->pdata = precvbuf->pskb->data;\r\nprecvbuf->ptail = skb_tail_pointer(precvbuf->pskb);\r\nprecvbuf->pend = skb_end_pointer(precvbuf->pskb);\r\nprecvbuf->pbuf = precvbuf->pskb->data;\r\n} else {\r\nprecvbuf->phead = precvbuf->pskb->head;\r\nprecvbuf->pdata = precvbuf->pskb->data;\r\nprecvbuf->ptail = skb_tail_pointer(precvbuf->pskb);\r\nprecvbuf->pend = skb_end_pointer(precvbuf->pskb);\r\nprecvbuf->pbuf = precvbuf->pskb->data;\r\nprecvbuf->reuse = false;\r\n}\r\npurb = precvbuf->purb;\r\npipe = ffaddr2pipehdl(pdvobj, addr);\r\nusb_fill_bulk_urb(purb, pusbd, pipe,\r\nprecvbuf->pbuf, MAX_RECVBUF_SZ,\r\nr8712_usb_read_port_complete,\r\nprecvbuf);\r\nerr = _usb_submit_urb(purb, GFP_ATOMIC);\r\nif ((err) && (err != (-EPERM)))\r\nret = _FAIL;\r\n} else\r\nret = _FAIL;\r\nreturn ret;\r\n}\r\nvoid r8712_usb_read_port_cancel(struct _adapter *padapter)\r\n{\r\nint i;\r\nstruct recv_buf *precvbuf;\r\nprecvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;\r\nfor (i = 0; i < NR_RECVBUFF; i++) {\r\nif (precvbuf->purb)\r\nusb_kill_urb(precvbuf->purb);\r\nprecvbuf++;\r\n}\r\n}\r\nvoid r8712_xmit_bh(void *priv)\r\n{\r\nint ret = false;\r\nstruct _adapter *padapter = (struct _adapter *)priv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nwhile (1) {\r\nif ((padapter->bDriverStopped == true) ||\r\n(padapter->bSurpriseRemoved == true)) {\r\nprintk(KERN_ERR "r8712u: xmit_bh => bDriverStopped"\r\n" or bSurpriseRemoved\n");\r\nbreak;\r\n}\r\nret = r8712_xmitframe_complete(padapter, pxmitpriv, NULL);\r\nif (ret == false)\r\nbreak;\r\n}\r\n}\r\nstatic void usb_write_port_complete(struct urb *purb)\r\n{\r\nint i;\r\nstruct xmit_frame *pxmitframe = (struct xmit_frame *)purb->context;\r\nstruct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;\r\nstruct _adapter *padapter = pxmitframe->padapter;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nswitch (pattrib->priority) {\r\ncase 1:\r\ncase 2:\r\npxmitpriv->bkq_cnt--;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\npxmitpriv->viq_cnt--;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\npxmitpriv->voq_cnt--;\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\npxmitpriv->beq_cnt--;\r\nbreak;\r\n}\r\npxmitpriv->txirp_cnt--;\r\nfor (i = 0; i < 8; i++) {\r\nif (purb == pxmitframe->pxmit_urb[i]) {\r\npxmitframe->bpending[i] = false;\r\nbreak;\r\n}\r\n}\r\nif (padapter->bSurpriseRemoved)\r\nreturn;\r\nswitch (purb->status) {\r\ncase 0:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "r8712u: pipe error: (%d)\n", purb->status);\r\nbreak;\r\n}\r\nr8712_free_xmitframe_ex(pxmitpriv, pxmitframe);\r\nr8712_free_xmitbuf(pxmitpriv, pxmitbuf);\r\ntasklet_hi_schedule(&pxmitpriv->xmit_tasklet);\r\n}\r\nu32 r8712_usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)\r\n{\r\nunsigned long irqL;\r\nint i, status;\r\nunsigned int pipe;\r\nu32 ret, bwritezero;\r\nstruct urb *purb = NULL;\r\nstruct _adapter *padapter = (struct _adapter *)pintfhdl->adapter;\r\nstruct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct xmit_frame *pxmitframe = (struct xmit_frame *)wmem;\r\nstruct usb_device *pusbd = pdvobj->pusbdev;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nif ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||\r\n(padapter->pwrctrlpriv.pnp_bstop_trx))\r\nreturn _FAIL;\r\nfor (i = 0; i < 8; i++) {\r\nif (pxmitframe->bpending[i] == false) {\r\nspin_lock_irqsave(&pxmitpriv->lock, irqL);\r\npxmitpriv->txirp_cnt++;\r\npxmitframe->bpending[i] = true;\r\nswitch (pattrib->priority) {\r\ncase 1:\r\ncase 2:\r\npxmitpriv->bkq_cnt++;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\npxmitpriv->viq_cnt++;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\npxmitpriv->voq_cnt++;\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\npxmitpriv->beq_cnt++;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&pxmitpriv->lock, irqL);\r\npxmitframe->sz[i] = (u16)cnt;\r\npurb = pxmitframe->pxmit_urb[i];\r\nbreak;\r\n}\r\n}\r\nbwritezero = false;\r\nif (pdvobj->ishighspeed) {\r\nif (cnt > 0 && cnt % 512 == 0)\r\nbwritezero = true;\r\n} else {\r\nif (cnt > 0 && cnt % 64 == 0)\r\nbwritezero = true;\r\n}\r\npipe = ffaddr2pipehdl(pdvobj, addr);\r\nif (pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0)\r\npurb->transfer_flags &= (~URB_NO_INTERRUPT);\r\nelse\r\npurb->transfer_flags |= URB_NO_INTERRUPT;\r\nif (bwritezero)\r\ncnt += 8;\r\nusb_fill_bulk_urb(purb, pusbd, pipe,\r\npxmitframe->mem_addr,\r\ncnt, usb_write_port_complete,\r\npxmitframe);\r\nstatus = _usb_submit_urb(purb, GFP_ATOMIC);\r\nif (!status)\r\nret = _SUCCESS;\r\nelse\r\nret = _FAIL;\r\nreturn ret;\r\n}\r\nvoid r8712_usb_write_port_cancel(struct _adapter *padapter)\r\n{\r\nint i, j;\r\nstruct xmit_buf *pxmitbuf = (struct xmit_buf *)\r\npadapter->xmitpriv.pxmitbuf;\r\nfor (i = 0; i < NR_XMITBUFF; i++) {\r\nfor (j = 0; j < 8; j++) {\r\nif (pxmitbuf->pxmit_urb[j])\r\nusb_kill_urb(pxmitbuf->pxmit_urb[j]);\r\n}\r\npxmitbuf++;\r\n}\r\n}\r\nint r8712_usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value,\r\nu16 index, void *pdata, u16 len, u8 requesttype)\r\n{\r\nunsigned int pipe;\r\nint status;\r\nu8 reqtype;\r\nstruct dvobj_priv *pdvobjpriv = (struct dvobj_priv *)\r\npintfpriv->intf_dev;\r\nstruct usb_device *udev = pdvobjpriv->pusbdev;\r\nu8 *palloc_buf, *pIo_buf;\r\npalloc_buf = _malloc((u32) len + 16);\r\nif (palloc_buf == NULL) {\r\nprintk(KERN_ERR "r8712u: [%s] Can't alloc memory for vendor"\r\n" request\n", __func__);\r\nreturn -1;\r\n}\r\npIo_buf = palloc_buf + 16 - ((addr_t)(palloc_buf) & 0x0f);\r\nif (requesttype == 0x01) {\r\npipe = usb_rcvctrlpipe(udev, 0);\r\nreqtype = RTL871X_VENQT_READ;\r\n} else {\r\npipe = usb_sndctrlpipe(udev, 0);\r\nreqtype = RTL871X_VENQT_WRITE;\r\nmemcpy(pIo_buf, pdata, len);\r\n}\r\nstatus = usb_control_msg(udev, pipe, request, reqtype, value, index,\r\npIo_buf, len, HZ / 2);\r\nif (status > 0) {\r\nif (requesttype == 0x01) {\r\nmemcpy(pdata, pIo_buf, status);\r\n}\r\n}\r\nkfree(palloc_buf);\r\nreturn status;\r\n}
