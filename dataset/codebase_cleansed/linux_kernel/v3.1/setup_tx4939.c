static void __init tx4939_wdr_init(void)\r\n{\r\nif (____raw_readq(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_WDRST)\r\npr_warning("Watchdog reset detected at 0x%lx\n",\r\nread_c0_errorepc());\r\ntx4939_ccfg_set(TX4939_CCFG_WDRST);\r\ntx4939_ccfg_set(TX4939_CCFG_WR);\r\n}\r\nvoid __init tx4939_wdt_init(void)\r\n{\r\ntxx9_wdt_init(TX4939_TMR_REG(2) & 0xfffffffffULL);\r\n}\r\nstatic void tx4939_machine_restart(char *command)\r\n{\r\nlocal_irq_disable();\r\npr_emerg("Rebooting (with %s watchdog reset)...\n",\r\n(____raw_readq(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_WDREXEN) ?\r\n"external" : "internal");\r\ntx4939_ccfg_set(TX4939_CCFG_WDRST);\r\ntxx9_wdt_now(TX4939_TMR_REG(2) & 0xfffffffffULL);\r\nwhile (!(____raw_readq(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_WDRST))\r\n;\r\nmdelay(10);\r\nif (____raw_readq(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_WDREXEN) {\r\npr_emerg("Rebooting (with internal watchdog reset)...\n");\r\ntx4939_ccfg_clear(TX4939_CCFG_WDREXEN);\r\n}\r\n(*_machine_halt)();\r\n}\r\nstatic int tx4939_be_handler(struct pt_regs *regs, int is_fixup)\r\n{\r\nint data = regs->cp0_cause & 4;\r\nconsole_verbose();\r\npr_err("%cBE exception at %#lx\n",\r\ndata ? 'D' : 'I', regs->cp0_epc);\r\npr_err("ccfg:%llx, toea:%llx\n",\r\n(unsigned long long)____raw_readq(&tx4939_ccfgptr->ccfg),\r\n(unsigned long long)____raw_readq(&tx4939_ccfgptr->toea));\r\n#ifdef CONFIG_PCI\r\ntx4927_report_pcic_status();\r\n#endif\r\nshow_registers(regs);\r\npanic("BusError!");\r\n}\r\nstatic void __init tx4939_be_init(void)\r\n{\r\nboard_be_handler = tx4939_be_handler;\r\n}\r\nvoid __init tx4939_add_memory_regions(void)\r\n{\r\nint i;\r\nunsigned long start, size;\r\nu64 win;\r\nfor (i = 0; i < 4; i++) {\r\nif (!((__u32)____raw_readq(&tx4939_ddrcptr->winen) & (1 << i)))\r\ncontinue;\r\nwin = ____raw_readq(&tx4939_ddrcptr->win[i]);\r\nstart = (unsigned long)(win >> 48);\r\nsize = (((unsigned long)(win >> 32) & 0xffff) + 1) - start;\r\nadd_memory_region(start << 20, size << 20, BOOT_MEM_RAM);\r\n}\r\n}\r\nvoid __init tx4939_setup(void)\r\n{\r\nint i;\r\n__u32 divmode;\r\n__u64 pcfg;\r\nunsigned int cpuclk = 0;\r\ntxx9_reg_res_init(TX4939_REV_PCODE(), TX4939_REG_BASE,\r\nTX4939_REG_SIZE);\r\nset_c0_config(TX49_CONF_CWFON);\r\nfor (i = 0; i < 4; i++) {\r\nif (!(TX4939_EBUSC_CR(i) & 0x8))\r\ncontinue;\r\ntxx9_ce_res[i].start = (unsigned long)TX4939_EBUSC_BA(i);\r\ntxx9_ce_res[i].end =\r\ntxx9_ce_res[i].start + TX4939_EBUSC_SIZE(i) - 1;\r\nrequest_resource(&iomem_resource, &txx9_ce_res[i]);\r\n}\r\nif (txx9_master_clock) {\r\ndivmode = (__u32)____raw_readq(&tx4939_ccfgptr->ccfg) &\r\nTX4939_CCFG_MULCLK_MASK;\r\ncpuclk = txx9_master_clock * 20 / 2;\r\nswitch (divmode) {\r\ncase TX4939_CCFG_MULCLK_8:\r\ncpuclk = cpuclk / 3 * 4 ; break;\r\ncase TX4939_CCFG_MULCLK_9:\r\ncpuclk = cpuclk / 2 * 3 ; break;\r\ncase TX4939_CCFG_MULCLK_10:\r\ncpuclk = cpuclk / 3 * 5 ; break;\r\ncase TX4939_CCFG_MULCLK_11:\r\ncpuclk = cpuclk / 6 * 11; break;\r\ncase TX4939_CCFG_MULCLK_12:\r\ncpuclk = cpuclk * 2 ; break;\r\ncase TX4939_CCFG_MULCLK_13:\r\ncpuclk = cpuclk / 6 * 13; break;\r\ncase TX4939_CCFG_MULCLK_14:\r\ncpuclk = cpuclk / 3 * 7 ; break;\r\ncase TX4939_CCFG_MULCLK_15:\r\ncpuclk = cpuclk / 2 * 5 ; break;\r\n}\r\ntxx9_cpu_clock = cpuclk;\r\n} else {\r\nif (txx9_cpu_clock == 0)\r\ntxx9_cpu_clock = 400000000;\r\ncpuclk = txx9_cpu_clock;\r\ndivmode = (__u32)____raw_readq(&tx4939_ccfgptr->ccfg) &\r\nTX4939_CCFG_MULCLK_MASK;\r\nswitch (divmode) {\r\ncase TX4939_CCFG_MULCLK_8:\r\ntxx9_master_clock = cpuclk * 6 / 8; break;\r\ncase TX4939_CCFG_MULCLK_9:\r\ntxx9_master_clock = cpuclk * 6 / 9; break;\r\ncase TX4939_CCFG_MULCLK_10:\r\ntxx9_master_clock = cpuclk * 6 / 10; break;\r\ncase TX4939_CCFG_MULCLK_11:\r\ntxx9_master_clock = cpuclk * 6 / 11; break;\r\ncase TX4939_CCFG_MULCLK_12:\r\ntxx9_master_clock = cpuclk * 6 / 12; break;\r\ncase TX4939_CCFG_MULCLK_13:\r\ntxx9_master_clock = cpuclk * 6 / 13; break;\r\ncase TX4939_CCFG_MULCLK_14:\r\ntxx9_master_clock = cpuclk * 6 / 14; break;\r\ncase TX4939_CCFG_MULCLK_15:\r\ntxx9_master_clock = cpuclk * 6 / 15; break;\r\n}\r\ntxx9_master_clock /= 10;\r\n}\r\ndivmode = (__u32)____raw_readq(&tx4939_ccfgptr->ccfg) &\r\nTX4939_CCFG_YDIVMODE_MASK;\r\ntxx9_gbus_clock = txx9_cpu_clock;\r\nswitch (divmode) {\r\ncase TX4939_CCFG_YDIVMODE_2:\r\ntxx9_gbus_clock /= 2; break;\r\ncase TX4939_CCFG_YDIVMODE_3:\r\ntxx9_gbus_clock /= 3; break;\r\ncase TX4939_CCFG_YDIVMODE_5:\r\ntxx9_gbus_clock /= 5; break;\r\ncase TX4939_CCFG_YDIVMODE_6:\r\ntxx9_gbus_clock /= 6; break;\r\n}\r\nloops_per_jiffy = txx9_cpu_clock / HZ / 2;\r\ntx4939_wdr_init();\r\ntx4939_ccfg_set(TX4939_CCFG_WDRST | TX4939_CCFG_BEOW);\r\nif (txx9_ccfg_toeon)\r\ntx4939_ccfg_set(TX4939_CCFG_TOE);\r\ntxx9_clear64(&tx4939_ccfgptr->pcfg, TX4939_PCFG_DMASEL_ALL);\r\nif (!(____raw_readq(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_PCIARB))\r\ntxx9_clear64(&tx4939_ccfgptr->pcfg, TX4939_PCFG_PCICLKEN_ALL);\r\npr_info("%s -- %dMHz(M%dMHz,G%dMHz) CRIR:%08x CCFG:%llx PCFG:%llx\n",\r\ntxx9_pcode_str,\r\n(cpuclk + 500000) / 1000000,\r\n(txx9_master_clock + 500000) / 1000000,\r\n(txx9_gbus_clock + 500000) / 1000000,\r\n(__u32)____raw_readq(&tx4939_ccfgptr->crir),\r\n(unsigned long long)____raw_readq(&tx4939_ccfgptr->ccfg),\r\n(unsigned long long)____raw_readq(&tx4939_ccfgptr->pcfg));\r\npr_info("%s DDRC -- EN:%08x", txx9_pcode_str,\r\n(__u32)____raw_readq(&tx4939_ddrcptr->winen));\r\nfor (i = 0; i < 4; i++) {\r\n__u64 win = ____raw_readq(&tx4939_ddrcptr->win[i]);\r\nif (!((__u32)____raw_readq(&tx4939_ddrcptr->winen) & (1 << i)))\r\ncontinue;\r\nprintk(KERN_CONT " #%d:%016llx", i, (unsigned long long)win);\r\ntx4939_sdram_resource[i].name = "DDR SDRAM";\r\ntx4939_sdram_resource[i].start =\r\n(unsigned long)(win >> 48) << 20;\r\ntx4939_sdram_resource[i].end =\r\n((((unsigned long)(win >> 32) & 0xffff) + 1) <<\r\n20) - 1;\r\ntx4939_sdram_resource[i].flags = IORESOURCE_MEM;\r\nrequest_resource(&iomem_resource, &tx4939_sdram_resource[i]);\r\n}\r\nprintk(KERN_CONT "\n");\r\nif (____raw_readq(&tx4939_sramcptr->cr) & 1) {\r\nunsigned int size = TX4939_SRAM_SIZE;\r\ntx4939_sram_resource.name = "SRAM";\r\ntx4939_sram_resource.start =\r\n(____raw_readq(&tx4939_sramcptr->cr) >> (39-11))\r\n& ~(size - 1);\r\ntx4939_sram_resource.end =\r\ntx4939_sram_resource.start + TX4939_SRAM_SIZE - 1;\r\ntx4939_sram_resource.flags = IORESOURCE_MEM;\r\nrequest_resource(&iomem_resource, &tx4939_sram_resource);\r\n}\r\nfor (i = 0; i < TX4939_NR_TMR; i++)\r\ntxx9_tmr_init(TX4939_TMR_REG(i) & 0xfffffffffULL);\r\ntxx9_set64(&tx4939_ccfgptr->clkctr, TX4939_CLKCTR_PCI1RST);\r\npcfg = ____raw_readq(&tx4939_ccfgptr->pcfg);\r\nif (pcfg & (TX4939_PCFG_ET0MODE | TX4939_PCFG_ET1MODE)) {\r\nmdelay(1);\r\ntxx9_clear64(&tx4939_ccfgptr->clkctr, TX4939_CLKCTR_PCI1RST);\r\n} else {\r\npr_info("%s: stop PCIC1\n", txx9_pcode_str);\r\ntxx9_set64(&tx4939_ccfgptr->clkctr, TX4939_CLKCTR_PCI1CKD);\r\n}\r\nif (!(pcfg & TX4939_PCFG_ET0MODE)) {\r\npr_info("%s: stop ETH0\n", txx9_pcode_str);\r\ntxx9_set64(&tx4939_ccfgptr->clkctr, TX4939_CLKCTR_ETH0RST);\r\ntxx9_set64(&tx4939_ccfgptr->clkctr, TX4939_CLKCTR_ETH0CKD);\r\n}\r\nif (!(pcfg & TX4939_PCFG_ET1MODE)) {\r\npr_info("%s: stop ETH1\n", txx9_pcode_str);\r\ntxx9_set64(&tx4939_ccfgptr->clkctr, TX4939_CLKCTR_ETH1RST);\r\ntxx9_set64(&tx4939_ccfgptr->clkctr, TX4939_CLKCTR_ETH1CKD);\r\n}\r\n_machine_restart = tx4939_machine_restart;\r\nboard_be_init = tx4939_be_init;\r\n}\r\nvoid __init tx4939_time_init(unsigned int tmrnr)\r\n{\r\nif (____raw_readq(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_TINTDIS)\r\ntxx9_clockevent_init(TX4939_TMR_REG(tmrnr) & 0xfffffffffULL,\r\nTXX9_IRQ_BASE + TX4939_IR_TMR(tmrnr),\r\nTXX9_IMCLK);\r\n}\r\nvoid __init tx4939_sio_init(unsigned int sclk, unsigned int cts_mask)\r\n{\r\nint i;\r\nunsigned int ch_mask = 0;\r\n__u64 pcfg = __raw_readq(&tx4939_ccfgptr->pcfg);\r\ncts_mask |= ~1;\r\nif ((pcfg & TX4939_PCFG_SIO2MODE_MASK) != TX4939_PCFG_SIO2MODE_SIO0)\r\ncts_mask |= 1 << 0;\r\nif ((pcfg & TX4939_PCFG_SIO2MODE_MASK) != TX4939_PCFG_SIO2MODE_SIO2)\r\nch_mask |= 1 << 2;\r\nif (pcfg & TX4939_PCFG_SIO3MODE)\r\nch_mask |= 1 << 3;\r\nfor (i = 0; i < 4; i++) {\r\nif ((1 << i) & ch_mask)\r\ncontinue;\r\ntxx9_sio_init(TX4939_SIO_REG(i) & 0xfffffffffULL,\r\nTXX9_IRQ_BASE + TX4939_IR_SIO(i),\r\ni, sclk, (1 << i) & cts_mask);\r\n}\r\n}\r\nstatic u32 tx4939_get_eth_speed(struct net_device *dev)\r\n{\r\nstruct ethtool_cmd cmd;\r\nif (dev_ethtool_get_settings(dev, &cmd))\r\nreturn 100;\r\nreturn ethtool_cmd_speed(&cmd);\r\n}\r\nstatic int tx4939_netdev_event(struct notifier_block *this,\r\nunsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nif (event == NETDEV_CHANGE && netif_carrier_ok(dev)) {\r\n__u64 bit = 0;\r\nif (dev->irq == TXX9_IRQ_BASE + TX4939_IR_ETH(0))\r\nbit = TX4939_PCFG_SPEED0;\r\nelse if (dev->irq == TXX9_IRQ_BASE + TX4939_IR_ETH(1))\r\nbit = TX4939_PCFG_SPEED1;\r\nif (bit) {\r\nif (tx4939_get_eth_speed(dev) == 100)\r\ntxx9_set64(&tx4939_ccfgptr->pcfg, bit);\r\nelse\r\ntxx9_clear64(&tx4939_ccfgptr->pcfg, bit);\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid __init tx4939_ethaddr_init(unsigned char *addr0, unsigned char *addr1)\r\n{\r\nu64 pcfg = __raw_readq(&tx4939_ccfgptr->pcfg);\r\nif (addr0 && (pcfg & TX4939_PCFG_ET0MODE))\r\ntxx9_ethaddr_init(TXX9_IRQ_BASE + TX4939_IR_ETH(0), addr0);\r\nif (addr1 && (pcfg & TX4939_PCFG_ET1MODE))\r\ntxx9_ethaddr_init(TXX9_IRQ_BASE + TX4939_IR_ETH(1), addr1);\r\nregister_netdevice_notifier(&tx4939_netdev_notifier);\r\n}\r\nvoid __init tx4939_ethaddr_init(unsigned char *addr0, unsigned char *addr1)\r\n{\r\n}\r\nvoid __init tx4939_mtd_init(int ch)\r\n{\r\nstruct physmap_flash_data pdata = {\r\n.width = TX4939_EBUSC_WIDTH(ch) / 8,\r\n};\r\nunsigned long start = txx9_ce_res[ch].start;\r\nunsigned long size = txx9_ce_res[ch].end - start + 1;\r\nif (!(TX4939_EBUSC_CR(ch) & 0x8))\r\nreturn;\r\ntxx9_physmap_flash_init(ch, start, size, &pdata);\r\n}\r\nvoid __init tx4939_ata_init(void)\r\n{\r\nstatic struct resource ata0_res[] = {\r\n{\r\n.start = TX4939_ATA_REG_PHYS(0),\r\n.end = TX4939_ATA_REG_PHYS(0) + 0x1000 - 1,\r\n.flags = IORESOURCE_MEM,\r\n}, {\r\n.start = TXX9_IRQ_BASE + TX4939_IR_ATA(0),\r\n.flags = IORESOURCE_IRQ,\r\n},\r\n};\r\nstatic struct resource ata1_res[] = {\r\n{\r\n.start = TX4939_ATA_REG_PHYS(1),\r\n.end = TX4939_ATA_REG_PHYS(1) + 0x1000 - 1,\r\n.flags = IORESOURCE_MEM,\r\n}, {\r\n.start = TXX9_IRQ_BASE + TX4939_IR_ATA(1),\r\n.flags = IORESOURCE_IRQ,\r\n},\r\n};\r\nstatic struct platform_device ata0_dev = {\r\n.name = "tx4939ide",\r\n.id = 0,\r\n.num_resources = ARRAY_SIZE(ata0_res),\r\n.resource = ata0_res,\r\n};\r\nstatic struct platform_device ata1_dev = {\r\n.name = "tx4939ide",\r\n.id = 1,\r\n.num_resources = ARRAY_SIZE(ata1_res),\r\n.resource = ata1_res,\r\n};\r\n__u64 pcfg = __raw_readq(&tx4939_ccfgptr->pcfg);\r\nif (pcfg & TX4939_PCFG_ATA0MODE)\r\nplatform_device_register(&ata0_dev);\r\nif ((pcfg & (TX4939_PCFG_ATA1MODE |\r\nTX4939_PCFG_ET1MODE |\r\nTX4939_PCFG_ET0MODE)) == TX4939_PCFG_ATA1MODE)\r\nplatform_device_register(&ata1_dev);\r\n}\r\nvoid __init tx4939_rtc_init(void)\r\n{\r\nstatic struct resource res[] = {\r\n{\r\n.start = TX4939_RTC_REG & 0xfffffffffULL,\r\n.end = (TX4939_RTC_REG & 0xfffffffffULL) + 0x100 - 1,\r\n.flags = IORESOURCE_MEM,\r\n}, {\r\n.start = TXX9_IRQ_BASE + TX4939_IR_RTC,\r\n.flags = IORESOURCE_IRQ,\r\n},\r\n};\r\nstatic struct platform_device rtc_dev = {\r\n.name = "tx4939rtc",\r\n.id = -1,\r\n.num_resources = ARRAY_SIZE(res),\r\n.resource = res,\r\n};\r\nplatform_device_register(&rtc_dev);\r\n}\r\nvoid __init tx4939_ndfmc_init(unsigned int hold, unsigned int spw,\r\nunsigned char ch_mask, unsigned char wide_mask)\r\n{\r\nstruct txx9ndfmc_platform_data plat_data = {\r\n.shift = 1,\r\n.gbus_clock = txx9_gbus_clock,\r\n.hold = hold,\r\n.spw = spw,\r\n.flags = NDFMC_PLAT_FLAG_NO_RSTR | NDFMC_PLAT_FLAG_HOLDADD |\r\nNDFMC_PLAT_FLAG_DUMMYWRITE,\r\n.ch_mask = ch_mask,\r\n.wide_mask = wide_mask,\r\n};\r\ntxx9_ndfmc_init(TX4939_NDFMC_REG & 0xfffffffffULL, &plat_data);\r\n}\r\nvoid __init tx4939_dmac_init(int memcpy_chan0, int memcpy_chan1)\r\n{\r\nstruct txx9dmac_platform_data plat_data = {\r\n.have_64bit_regs = true,\r\n};\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nplat_data.memcpy_chan = i ? memcpy_chan1 : memcpy_chan0;\r\ntxx9_dmac_init(i, TX4939_DMA_REG(i) & 0xfffffffffULL,\r\nTXX9_IRQ_BASE + TX4939_IR_DMA(i, 0),\r\n&plat_data);\r\n}\r\n}\r\nvoid __init tx4939_aclc_init(void)\r\n{\r\nu64 pcfg = __raw_readq(&tx4939_ccfgptr->pcfg);\r\nif ((pcfg & TX4939_PCFG_I2SMODE_MASK) == TX4939_PCFG_I2SMODE_ACLC)\r\ntxx9_aclc_init(TX4939_ACLC_REG & 0xfffffffffULL,\r\nTXX9_IRQ_BASE + TX4939_IR_ACLC, 1, 0, 1);\r\n}\r\nvoid __init tx4939_sramc_init(void)\r\n{\r\nif (tx4939_sram_resource.start)\r\ntxx9_sramc_init(&tx4939_sram_resource);\r\n}\r\nvoid __init tx4939_rng_init(void)\r\n{\r\nstatic struct resource res = {\r\n.start = TX4939_RNG_REG & 0xfffffffffULL,\r\n.end = (TX4939_RNG_REG & 0xfffffffffULL) + 0x30 - 1,\r\n.flags = IORESOURCE_MEM,\r\n};\r\nstatic struct platform_device pdev = {\r\n.name = "tx4939-rng",\r\n.id = -1,\r\n.num_resources = 1,\r\n.resource = &res,\r\n};\r\nplatform_device_register(&pdev);\r\n}\r\nstatic void __init tx4939_stop_unused_modules(void)\r\n{\r\n__u64 pcfg, rst = 0, ckd = 0;\r\nchar buf[128];\r\nbuf[0] = '\0';\r\nlocal_irq_disable();\r\npcfg = ____raw_readq(&tx4939_ccfgptr->pcfg);\r\nif ((pcfg & TX4939_PCFG_I2SMODE_MASK) !=\r\nTX4939_PCFG_I2SMODE_ACLC) {\r\nrst |= TX4939_CLKCTR_ACLRST;\r\nckd |= TX4939_CLKCTR_ACLCKD;\r\nstrcat(buf, " ACLC");\r\n}\r\nif ((pcfg & TX4939_PCFG_I2SMODE_MASK) !=\r\nTX4939_PCFG_I2SMODE_I2S &&\r\n(pcfg & TX4939_PCFG_I2SMODE_MASK) !=\r\nTX4939_PCFG_I2SMODE_I2S_ALT) {\r\nrst |= TX4939_CLKCTR_I2SRST;\r\nckd |= TX4939_CLKCTR_I2SCKD;\r\nstrcat(buf, " I2S");\r\n}\r\nif (!(pcfg & TX4939_PCFG_ATA0MODE)) {\r\nrst |= TX4939_CLKCTR_ATA0RST;\r\nckd |= TX4939_CLKCTR_ATA0CKD;\r\nstrcat(buf, " ATA0");\r\n}\r\nif (!(pcfg & TX4939_PCFG_ATA1MODE)) {\r\nrst |= TX4939_CLKCTR_ATA1RST;\r\nckd |= TX4939_CLKCTR_ATA1CKD;\r\nstrcat(buf, " ATA1");\r\n}\r\nif (pcfg & TX4939_PCFG_SPIMODE) {\r\nrst |= TX4939_CLKCTR_SPIRST;\r\nckd |= TX4939_CLKCTR_SPICKD;\r\nstrcat(buf, " SPI");\r\n}\r\nif (!(pcfg & (TX4939_PCFG_VSSMODE | TX4939_PCFG_VPSMODE))) {\r\nrst |= TX4939_CLKCTR_VPCRST;\r\nckd |= TX4939_CLKCTR_VPCCKD;\r\nstrcat(buf, " VPC");\r\n}\r\nif ((pcfg & TX4939_PCFG_SIO2MODE_MASK) != TX4939_PCFG_SIO2MODE_SIO2) {\r\nrst |= TX4939_CLKCTR_SIO2RST;\r\nckd |= TX4939_CLKCTR_SIO2CKD;\r\nstrcat(buf, " SIO2");\r\n}\r\nif (pcfg & TX4939_PCFG_SIO3MODE) {\r\nrst |= TX4939_CLKCTR_SIO3RST;\r\nckd |= TX4939_CLKCTR_SIO3CKD;\r\nstrcat(buf, " SIO3");\r\n}\r\nif (rst | ckd) {\r\ntxx9_set64(&tx4939_ccfgptr->clkctr, rst);\r\ntxx9_set64(&tx4939_ccfgptr->clkctr, ckd);\r\n}\r\nlocal_irq_enable();\r\nif (buf[0])\r\npr_info("%s: stop%s\n", txx9_pcode_str, buf);\r\n}\r\nstatic int __init tx4939_late_init(void)\r\n{\r\nif (txx9_pcode != 0x4939)\r\nreturn -ENODEV;\r\ntx4939_stop_unused_modules();\r\nreturn 0;\r\n}
