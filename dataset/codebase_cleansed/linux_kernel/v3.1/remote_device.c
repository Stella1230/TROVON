static void isci_remote_device_not_ready(struct isci_host *ihost,\r\nstruct isci_remote_device *idev, u32 reason)\r\n{\r\nstruct isci_request *ireq;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p\n", __func__, idev);\r\nswitch (reason) {\r\ncase SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED:\r\nset_bit(IDEV_GONE, &idev->flags);\r\nbreak;\r\ncase SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED:\r\nset_bit(IDEV_IO_NCQERROR, &idev->flags);\r\nlist_for_each_entry(ireq, &idev->reqs_in_process, dev_node) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p request = %p\n",\r\n__func__, idev, ireq);\r\nsci_controller_terminate_request(ihost,\r\nidev,\r\nireq);\r\n}\r\ndefault:\r\nclear_bit(IDEV_IO_READY, &idev->flags);\r\nbreak;\r\n}\r\n}\r\nstatic void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote_device *idev)\r\n{\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev = %p\n", __func__, idev);\r\nclear_bit(IDEV_IO_NCQERROR, &idev->flags);\r\nset_bit(IDEV_IO_READY, &idev->flags);\r\nif (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))\r\nwake_up(&ihost->eventq);\r\n}\r\nstatic void rnc_destruct_done(void *_dev)\r\n{\r\nstruct isci_remote_device *idev = _dev;\r\nBUG_ON(idev->started_request_count != 0);\r\nsci_change_state(&idev->sm, SCI_DEV_STOPPED);\r\n}\r\nstatic enum sci_status sci_remote_device_terminate_requests(struct isci_remote_device *idev)\r\n{\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nenum sci_status status = SCI_SUCCESS;\r\nu32 i;\r\nfor (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {\r\nstruct isci_request *ireq = ihost->reqs[i];\r\nenum sci_status s;\r\nif (!test_bit(IREQ_ACTIVE, &ireq->flags) ||\r\nireq->target_device != idev)\r\ncontinue;\r\ns = sci_controller_terminate_request(ihost, idev, ireq);\r\nif (s != SCI_SUCCESS)\r\nstatus = s;\r\n}\r\nreturn status;\r\n}\r\nenum sci_status sci_remote_device_stop(struct isci_remote_device *idev,\r\nu32 timeout)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_STOPPED:\r\nreturn SCI_SUCCESS;\r\ncase SCI_DEV_STARTING:\r\nBUG_ON(idev->started_request_count != 0);\r\nsci_remote_node_context_destruct(&idev->rnc,\r\nrnc_destruct_done, idev);\r\nsci_change_state(sm, SCI_DEV_STOPPING);\r\nreturn SCI_SUCCESS;\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_SMP_DEV_CMD:\r\nsci_change_state(sm, SCI_DEV_STOPPING);\r\nif (idev->started_request_count == 0) {\r\nsci_remote_node_context_destruct(&idev->rnc,\r\nrnc_destruct_done, idev);\r\nreturn SCI_SUCCESS;\r\n} else\r\nreturn sci_remote_device_terminate_requests(idev);\r\nbreak;\r\ncase SCI_DEV_STOPPING:\r\nreturn sci_remote_device_terminate_requests(idev);\r\ncase SCI_DEV_RESETTING:\r\nsci_change_state(sm, SCI_DEV_STOPPING);\r\nreturn SCI_SUCCESS;\r\n}\r\n}\r\nenum sci_status sci_remote_device_reset(struct isci_remote_device *idev)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_SMP_DEV_CMD:\r\ncase SCI_DEV_STOPPING:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_RESETTING:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\nsci_change_state(sm, SCI_DEV_RESETTING);\r\nreturn SCI_SUCCESS;\r\n}\r\n}\r\nenum sci_status sci_remote_device_reset_complete(struct isci_remote_device *idev)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nif (state != SCI_DEV_RESETTING) {\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nsci_change_state(sm, SCI_DEV_READY);\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,\r\nu32 suspend_type)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nif (state != SCI_STP_DEV_CMD) {\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nreturn sci_remote_node_context_suspend(&idev->rnc,\r\nsuspend_type, NULL, NULL);\r\n}\r\nenum sci_status sci_remote_device_frame_handler(struct isci_remote_device *idev,\r\nu32 frame_index)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nenum sci_status status;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\ncase SCI_DEV_STOPPING:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_RESETTING: {\r\nstruct isci_request *ireq;\r\nstruct ssp_frame_hdr hdr;\r\nvoid *frame_header;\r\nssize_t word_cnt;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n&frame_header);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nword_cnt = sizeof(hdr) / sizeof(u32);\r\nsci_swab32_cpy(&hdr, frame_header, word_cnt);\r\nireq = sci_request_by_tag(ihost, be16_to_cpu(hdr.tag));\r\nif (ireq && ireq->target_device == idev) {\r\nstatus = sci_io_request_frame_handler(ireq, frame_index);\r\n} else {\r\nsci_controller_release_frame(ihost, frame_index);\r\n}\r\nbreak;\r\n}\r\ncase SCI_STP_DEV_NCQ: {\r\nstruct dev_to_host_fis *hdr;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&hdr);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nif (hdr->fis_type == FIS_SETDEVBITS &&\r\n(hdr->status & ATA_ERR)) {\r\nidev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;\r\nsci_change_state(sm, SCI_STP_DEV_NCQ_ERROR);\r\n} else if (hdr->fis_type == FIS_REGD2H &&\r\n(hdr->status & ATA_ERR)) {\r\nidev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;\r\nsci_change_state(&idev->sm, SCI_STP_DEV_NCQ_ERROR);\r\n} else\r\nstatus = SCI_FAILURE;\r\nsci_controller_release_frame(ihost, frame_index);\r\nbreak;\r\n}\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_SMP_DEV_CMD:\r\nstatus = sci_io_request_frame_handler(idev->working_request, frame_index);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic bool is_remote_device_ready(struct isci_remote_device *idev)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nswitch (state) {\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_SMP_DEV_CMD:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nenum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,\r\nu32 event_code)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nenum sci_status status;\r\nswitch (scu_get_event_type(event_code)) {\r\ncase SCU_EVENT_TYPE_RNC_OPS_MISC:\r\ncase SCU_EVENT_TYPE_RNC_SUSPEND_TX:\r\ncase SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:\r\nstatus = sci_remote_node_context_event_handler(&idev->rnc, event_code);\r\nbreak;\r\ncase SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:\r\nif (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {\r\nstatus = SCI_SUCCESS;\r\nsci_remote_node_context_suspend(&idev->rnc,\r\nSCI_SOFTWARE_SUSPENSION,\r\nNULL, NULL);\r\ndev_dbg(scirdev_to_dev(idev),\r\n"%s: device: %p event code: %x: %s\n",\r\n__func__, idev, event_code,\r\nis_remote_device_ready(idev)\r\n? "I_T_Nexus_Timeout event"\r\n: "I_T_Nexus_Timeout event in wrong state");\r\nbreak;\r\n}\r\ndefault:\r\ndev_dbg(scirdev_to_dev(idev),\r\n"%s: device: %p event code: %x: %s\n",\r\n__func__, idev, event_code,\r\nis_remote_device_ready(idev)\r\n? "unexpected event"\r\n: "unexpected event in wrong state");\r\nstatus = SCI_FAILURE_INVALID_STATE;\r\nbreak;\r\n}\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nif (state == SCI_STP_DEV_IDLE) {\r\nif (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||\r\nscu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)\r\nstatus = sci_remote_node_context_resume(&idev->rnc, NULL, NULL);\r\n}\r\nreturn status;\r\n}\r\nstatic void sci_remote_device_start_request(struct isci_remote_device *idev,\r\nstruct isci_request *ireq,\r\nenum sci_status status)\r\n{\r\nstruct isci_port *iport = idev->owning_port;\r\nif (status != SCI_SUCCESS)\r\nsci_port_complete_io(iport, idev, ireq);\r\nelse {\r\nkref_get(&idev->kref);\r\nidev->started_request_count++;\r\n}\r\n}\r\nenum sci_status sci_remote_device_start_io(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_port *iport = idev->owning_port;\r\nenum sci_status status;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_DEV_STOPPING:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_RESETTING:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_READY:\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\nbreak;\r\ncase SCI_STP_DEV_IDLE: {\r\nenum sci_remote_device_states new_state;\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nif (task->ata_task.use_ncq)\r\nnew_state = SCI_STP_DEV_NCQ;\r\nelse {\r\nidev->working_request = ireq;\r\nnew_state = SCI_STP_DEV_CMD;\r\n}\r\nsci_change_state(sm, new_state);\r\nbreak;\r\n}\r\ncase SCI_STP_DEV_NCQ: {\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nif (task->ata_task.use_ncq) {\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\n} else\r\nreturn SCI_FAILURE_INVALID_STATE;\r\nbreak;\r\n}\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\nreturn SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;\r\ncase SCI_SMP_DEV_IDLE:\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nidev->working_request = ireq;\r\nsci_change_state(&idev->sm, SCI_SMP_DEV_CMD);\r\nbreak;\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_SMP_DEV_CMD:\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nsci_remote_device_start_request(idev, ireq, status);\r\nreturn status;\r\n}\r\nstatic enum sci_status common_complete_io(struct isci_port *iport,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nenum sci_status status;\r\nstatus = sci_request_complete(ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_port_complete_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nsci_remote_device_decrement_request_count(idev);\r\nreturn status;\r\n}\r\nenum sci_status sci_remote_device_complete_io(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_port *iport = idev->owning_port;\r\nenum sci_status status;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\ncase SCI_DEV_RESETTING:\r\nstatus = common_complete_io(iport, idev, ireq);\r\nbreak;\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\nstatus = common_complete_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nif (ireq->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {\r\nsci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);\r\n} else if (idev->started_request_count == 0)\r\nsci_change_state(sm, SCI_STP_DEV_IDLE);\r\nbreak;\r\ncase SCI_SMP_DEV_CMD:\r\nstatus = common_complete_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nsci_change_state(sm, SCI_SMP_DEV_IDLE);\r\nbreak;\r\ncase SCI_DEV_STOPPING:\r\nstatus = common_complete_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nif (idev->started_request_count == 0)\r\nsci_remote_node_context_destruct(&idev->rnc,\r\nrnc_destruct_done,\r\nidev);\r\nbreak;\r\n}\r\nif (status != SCI_SUCCESS)\r\ndev_err(scirdev_to_dev(idev),\r\n"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "\r\n"could not complete\n", __func__, iport,\r\nidev, ireq, status);\r\nelse\r\nisci_put_device(idev);\r\nreturn status;\r\n}\r\nstatic void sci_remote_device_continue_request(void *dev)\r\n{\r\nstruct isci_remote_device *idev = dev;\r\nif (idev->working_request)\r\nsci_controller_continue_io(idev->working_request);\r\n}\r\nenum sci_status sci_remote_device_start_task(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_port *iport = idev->owning_port;\r\nenum sci_status status;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_SMP_DEV_CMD:\r\ncase SCI_DEV_STOPPING:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_RESETTING:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_task(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\ngoto out;\r\nstatus = sci_request_start(ireq);\r\nif (status != SCI_SUCCESS)\r\ngoto out;\r\nidev->working_request = ireq;\r\nsci_change_state(sm, SCI_STP_DEV_CMD);\r\nsci_remote_node_context_suspend(&idev->rnc,\r\nSCI_SOFTWARE_SUSPENSION, NULL, NULL);\r\nsci_remote_node_context_resume(&idev->rnc,\r\nsci_remote_device_continue_request,\r\nidev);\r\nout:\r\nsci_remote_device_start_request(idev, ireq, status);\r\nreturn SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;\r\ncase SCI_DEV_READY:\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_task(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\nbreak;\r\n}\r\nsci_remote_device_start_request(idev, ireq, status);\r\nreturn status;\r\n}\r\nvoid sci_remote_device_post_request(struct isci_remote_device *idev, u32 request)\r\n{\r\nstruct isci_port *iport = idev->owning_port;\r\nu32 context;\r\ncontext = request |\r\n(ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\r\n(iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\r\nidev->rnc.remote_node_index;\r\nsci_controller_post_request(iport->owning_controller, context);\r\n}\r\nstatic void remote_device_resume_done(void *_dev)\r\n{\r\nstruct isci_remote_device *idev = _dev;\r\nif (is_remote_device_ready(idev))\r\nreturn;\r\nsci_change_state(&idev->sm, SCI_DEV_READY);\r\n}\r\nstatic void sci_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)\r\n{\r\nstruct isci_remote_device *idev = _dev;\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nif (idev->sm.previous_state_id != SCI_STP_DEV_NCQ)\r\nisci_remote_device_ready(ihost, idev);\r\n}\r\nstatic void sci_remote_device_initial_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nsci_change_state(&idev->sm, SCI_DEV_STOPPED);\r\n}\r\nstatic enum sci_status sci_remote_device_destruct(struct isci_remote_device *idev)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_host *ihost;\r\nif (state != SCI_DEV_STOPPED) {\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nihost = idev->owning_port->owning_controller;\r\nsci_controller_free_remote_node_context(ihost, idev,\r\nidev->rnc.remote_node_index);\r\nidev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;\r\nsci_change_state(sm, SCI_DEV_FINAL);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_remote_device *idev)\r\n{\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p\n", __func__, idev);\r\nBUG_ON(!list_empty(&idev->reqs_in_process));\r\nsci_remote_device_destruct(idev);\r\nlist_del_init(&idev->node);\r\nisci_put_device(idev);\r\n}\r\nstatic void sci_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nu32 prev_state;\r\nprev_state = idev->sm.previous_state_id;\r\nif (prev_state == SCI_DEV_STOPPING)\r\nisci_remote_device_deconstruct(ihost, idev);\r\nsci_controller_remote_device_stopped(ihost, idev);\r\n}\r\nstatic void sci_remote_device_starting_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nisci_remote_device_not_ready(ihost, idev,\r\nSCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);\r\n}\r\nstatic void sci_remote_device_ready_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nstruct domain_device *dev = idev->domain_dev;\r\nif (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {\r\nsci_change_state(&idev->sm, SCI_STP_DEV_IDLE);\r\n} else if (dev_is_expander(dev)) {\r\nsci_change_state(&idev->sm, SCI_SMP_DEV_IDLE);\r\n} else\r\nisci_remote_device_ready(ihost, idev);\r\n}\r\nstatic void sci_remote_device_ready_state_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct domain_device *dev = idev->domain_dev;\r\nif (dev->dev_type == SAS_END_DEV) {\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nisci_remote_device_not_ready(ihost, idev,\r\nSCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);\r\n}\r\n}\r\nstatic void sci_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nsci_remote_node_context_suspend(\r\n&idev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);\r\n}\r\nstatic void sci_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nsci_remote_node_context_resume(&idev->rnc, NULL, NULL);\r\n}\r\nstatic void sci_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nidev->working_request = NULL;\r\nif (sci_remote_node_context_is_ready(&idev->rnc)) {\r\nsci_stp_remote_device_ready_idle_substate_resume_complete_handler(idev);\r\n} else {\r\nsci_remote_node_context_resume(&idev->rnc,\r\nsci_stp_remote_device_ready_idle_substate_resume_complete_handler,\r\nidev);\r\n}\r\n}\r\nstatic void sci_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nBUG_ON(idev->working_request == NULL);\r\nisci_remote_device_not_ready(ihost, idev,\r\nSCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);\r\n}\r\nstatic void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nif (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)\r\nisci_remote_device_not_ready(ihost, idev,\r\nidev->not_ready_reason);\r\n}\r\nstatic void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nisci_remote_device_ready(ihost, idev);\r\n}\r\nstatic void sci_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nBUG_ON(idev->working_request == NULL);\r\nisci_remote_device_not_ready(ihost, idev,\r\nSCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);\r\n}\r\nstatic void sci_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nidev->working_request = NULL;\r\n}\r\nstatic void sci_remote_device_construct(struct isci_port *iport,\r\nstruct isci_remote_device *idev)\r\n{\r\nidev->owning_port = iport;\r\nidev->started_request_count = 0;\r\nsci_init_sm(&idev->sm, sci_remote_device_state_table, SCI_DEV_INITIAL);\r\nsci_remote_node_context_construct(&idev->rnc,\r\nSCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);\r\n}\r\nstatic enum sci_status sci_remote_device_da_construct(struct isci_port *iport,\r\nstruct isci_remote_device *idev)\r\n{\r\nenum sci_status status;\r\nstruct domain_device *dev = idev->domain_dev;\r\nsci_remote_device_construct(iport, idev);\r\nidev->is_direct_attached = true;\r\nstatus = sci_controller_allocate_remote_node_context(iport->owning_controller,\r\nidev,\r\n&idev->rnc.remote_node_index);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nif (dev->dev_type == SAS_END_DEV || dev->dev_type == SATA_DEV ||\r\n(dev->tproto & SAS_PROTOCOL_STP) || dev_is_expander(dev))\r\n;\r\nelse\r\nreturn SCI_FAILURE_UNSUPPORTED_PROTOCOL;\r\nidev->connection_rate = sci_port_get_max_allowed_speed(iport);\r\nidev->device_port_width = 1;\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status sci_remote_device_ea_construct(struct isci_port *iport,\r\nstruct isci_remote_device *idev)\r\n{\r\nstruct domain_device *dev = idev->domain_dev;\r\nenum sci_status status;\r\nsci_remote_device_construct(iport, idev);\r\nstatus = sci_controller_allocate_remote_node_context(iport->owning_controller,\r\nidev,\r\n&idev->rnc.remote_node_index);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nif (dev->dev_type == SAS_END_DEV || dev->dev_type == SATA_DEV ||\r\n(dev->tproto & SAS_PROTOCOL_STP) || dev_is_expander(dev))\r\n;\r\nelse\r\nreturn SCI_FAILURE_UNSUPPORTED_PROTOCOL;\r\nidev->connection_rate = min_t(u16, sci_port_get_max_allowed_speed(iport),\r\ndev->linkrate);\r\nidev->device_port_width = 1;\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status sci_remote_device_start(struct isci_remote_device *idev,\r\nu32 timeout)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nenum sci_status status;\r\nif (state != SCI_DEV_STOPPED) {\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",\r\n__func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nstatus = sci_remote_node_context_resume(&idev->rnc,\r\nremote_device_resume_done,\r\nidev);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nsci_change_state(sm, SCI_DEV_STARTING);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status isci_remote_device_construct(struct isci_port *iport,\r\nstruct isci_remote_device *idev)\r\n{\r\nstruct isci_host *ihost = iport->isci_host;\r\nstruct domain_device *dev = idev->domain_dev;\r\nenum sci_status status;\r\nif (dev->parent && dev_is_expander(dev->parent))\r\nstatus = sci_remote_device_ea_construct(iport, idev);\r\nelse\r\nstatus = sci_remote_device_da_construct(iport, idev);\r\nif (status != SCI_SUCCESS) {\r\ndev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatus = sci_remote_device_start(idev, ISCI_REMOTE_DEVICE_START_TIMEOUT);\r\nif (status != SCI_SUCCESS)\r\ndev_warn(&ihost->pdev->dev, "remote device start failed: %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nvoid isci_remote_device_nuke_requests(struct isci_host *ihost, struct isci_remote_device *idev)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(aborted_task_completion);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev = %p\n", __func__, idev);\r\nisci_terminate_pending_requests(ihost, idev);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev = %p, done\n", __func__, idev);\r\n}\r\nstatic struct isci_remote_device *\r\nisci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)\r\n{\r\nstruct isci_remote_device *idev;\r\nint i;\r\nfor (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {\r\nidev = &ihost->devices[i];\r\nif (!test_and_set_bit(IDEV_ALLOCATED, &idev->flags))\r\nbreak;\r\n}\r\nif (i >= SCI_MAX_REMOTE_DEVICES) {\r\ndev_warn(&ihost->pdev->dev, "%s: failed\n", __func__);\r\nreturn NULL;\r\n}\r\nif (WARN_ONCE(!list_empty(&idev->reqs_in_process), "found requests in process\n"))\r\nreturn NULL;\r\nif (WARN_ONCE(!list_empty(&idev->node), "found non-idle remote device\n"))\r\nreturn NULL;\r\nreturn idev;\r\n}\r\nvoid isci_remote_device_release(struct kref *kref)\r\n{\r\nstruct isci_remote_device *idev = container_of(kref, typeof(*idev), kref);\r\nstruct isci_host *ihost = idev->isci_port->isci_host;\r\nidev->domain_dev = NULL;\r\nidev->isci_port = NULL;\r\nclear_bit(IDEV_START_PENDING, &idev->flags);\r\nclear_bit(IDEV_STOP_PENDING, &idev->flags);\r\nclear_bit(IDEV_IO_READY, &idev->flags);\r\nclear_bit(IDEV_GONE, &idev->flags);\r\nclear_bit(IDEV_EH, &idev->flags);\r\nsmp_mb__before_clear_bit();\r\nclear_bit(IDEV_ALLOCATED, &idev->flags);\r\nwake_up(&ihost->eventq);\r\n}\r\nenum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_remote_device *idev)\r\n{\r\nenum sci_status status;\r\nunsigned long flags;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p\n", __func__, idev);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nidev->domain_dev->lldd_dev = NULL;\r\nset_bit(IDEV_GONE, &idev->flags);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nisci_remote_device_nuke_requests(ihost, idev);\r\nset_bit(IDEV_STOP_PENDING, &idev->flags);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nstatus = sci_remote_device_stop(idev, 50);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (WARN_ONCE(status != SCI_SUCCESS, "failed to stop device\n"))\r\n;\r\nelse\r\nwait_for_device_stop(ihost, idev);\r\nreturn status;\r\n}\r\nvoid isci_remote_device_gone(struct domain_device *dev)\r\n{\r\nstruct isci_host *ihost = dev_to_ihost(dev);\r\nstruct isci_remote_device *idev = dev->lldd_dev;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: domain_device = %p, isci_device = %p, isci_port = %p\n",\r\n__func__, dev, idev, idev->isci_port);\r\nisci_remote_device_stop(ihost, idev);\r\n}\r\nint isci_remote_device_found(struct domain_device *domain_dev)\r\n{\r\nstruct isci_host *isci_host = dev_to_ihost(domain_dev);\r\nstruct isci_port *isci_port;\r\nstruct isci_phy *isci_phy;\r\nstruct asd_sas_port *sas_port;\r\nstruct asd_sas_phy *sas_phy;\r\nstruct isci_remote_device *isci_device;\r\nenum sci_status status;\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: domain_device = %p\n", __func__, domain_dev);\r\nwait_for_start(isci_host);\r\nsas_port = domain_dev->port;\r\nsas_phy = list_first_entry(&sas_port->phy_list, struct asd_sas_phy,\r\nport_phy_el);\r\nisci_phy = to_iphy(sas_phy);\r\nisci_port = isci_phy->isci_port;\r\nwait_for_completion(&isci_port->start_complete);\r\nif ((isci_stopping == isci_port_get_state(isci_port)) ||\r\n(isci_stopped == isci_port_get_state(isci_port)))\r\nreturn -ENODEV;\r\nisci_device = isci_remote_device_alloc(isci_host, isci_port);\r\nif (!isci_device)\r\nreturn -ENODEV;\r\nkref_init(&isci_device->kref);\r\nINIT_LIST_HEAD(&isci_device->node);\r\nspin_lock_irq(&isci_host->scic_lock);\r\nisci_device->domain_dev = domain_dev;\r\nisci_device->isci_port = isci_port;\r\nlist_add_tail(&isci_device->node, &isci_port->remote_dev_list);\r\nset_bit(IDEV_START_PENDING, &isci_device->flags);\r\nstatus = isci_remote_device_construct(isci_port, isci_device);\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: isci_device = %p\n",\r\n__func__, isci_device);\r\nif (status == SCI_SUCCESS) {\r\ndomain_dev->lldd_dev = isci_device;\r\n} else\r\nisci_put_device(isci_device);\r\nspin_unlock_irq(&isci_host->scic_lock);\r\nwait_for_device_start(isci_host, isci_device);\r\nreturn status == SCI_SUCCESS ? 0 : -ENODEV;\r\n}\r\nbool isci_device_is_reset_pending(\r\nstruct isci_host *isci_host,\r\nstruct isci_remote_device *isci_device)\r\n{\r\nstruct isci_request *isci_request;\r\nstruct isci_request *tmp_req;\r\nbool reset_is_pending = false;\r\nunsigned long flags;\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: isci_device = %p\n", __func__, isci_device);\r\nspin_lock_irqsave(&isci_host->scic_lock, flags);\r\nlist_for_each_entry_safe(isci_request, tmp_req,\r\n&isci_device->reqs_in_process, dev_node) {\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: isci_device = %p request = %p\n",\r\n__func__, isci_device, isci_request);\r\nif (isci_request->ttype == io_task) {\r\nstruct sas_task *task = isci_request_access_task(\r\nisci_request);\r\nspin_lock(&task->task_state_lock);\r\nif (task->task_state_flags & SAS_TASK_NEED_DEV_RESET)\r\nreset_is_pending = true;\r\nspin_unlock(&task->task_state_lock);\r\n}\r\n}\r\nspin_unlock_irqrestore(&isci_host->scic_lock, flags);\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: isci_device = %p reset_is_pending = %d\n",\r\n__func__, isci_device, reset_is_pending);\r\nreturn reset_is_pending;\r\n}\r\nvoid isci_device_clear_reset_pending(struct isci_host *ihost, struct isci_remote_device *idev)\r\n{\r\nstruct isci_request *isci_request;\r\nstruct isci_request *tmp_req;\r\nunsigned long flags = 0;\r\ndev_dbg(&ihost->pdev->dev, "%s: idev=%p, ihost=%p\n",\r\n__func__, idev, ihost);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nlist_for_each_entry_safe(isci_request, tmp_req,\r\n&idev->reqs_in_process, dev_node) {\r\ndev_dbg(&ihost->pdev->dev, "%s: idev = %p request = %p\n",\r\n__func__, idev, isci_request);\r\nif (isci_request->ttype == io_task) {\r\nunsigned long flags2;\r\nstruct sas_task *task = isci_request_access_task(\r\nisci_request);\r\nspin_lock_irqsave(&task->task_state_lock, flags2);\r\ntask->task_state_flags &= ~SAS_TASK_NEED_DEV_RESET;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags2);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\n}
