static u8 reg_r_i(struct gspca_dev *gspca_dev,\r\nu16 index)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn 0;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0xa1,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x01,\r\nindex, gspca_dev->usb_buf, 1,\r\n500);\r\nif (ret < 0) {\r\nerr("reg_r_i err %d", ret);\r\ngspca_dev->usb_err = ret;\r\nreturn 0;\r\n}\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic u8 reg_r(struct gspca_dev *gspca_dev,\r\nu16 index)\r\n{\r\nu8 ret;\r\nret = reg_r_i(gspca_dev, index);\r\nPDEBUG(D_USBI, "reg r [%04x] -> %02x", index, ret);\r\nreturn ret;\r\n}\r\nstatic void reg_w_i(struct gspca_dev *gspca_dev,\r\nu8 value,\r\nu16 index)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0xa0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, NULL, 0,\r\n500);\r\nif (ret < 0) {\r\nerr("reg_w_i err %d", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\nu8 value,\r\nu16 index)\r\n{\r\nPDEBUG(D_USBO, "reg w [%04x] = %02x", index, value);\r\nreg_w_i(gspca_dev, value, index);\r\n}\r\nstatic u16 i2c_read(struct gspca_dev *gspca_dev,\r\nu8 reg)\r\n{\r\nu8 retbyte;\r\nu16 retval;\r\nif (gspca_dev->usb_err < 0)\r\nreturn 0;\r\nreg_w_i(gspca_dev, reg, 0x0092);\r\nreg_w_i(gspca_dev, 0x02, 0x0090);\r\nmsleep(20);\r\nretbyte = reg_r_i(gspca_dev, 0x0091);\r\nif (retbyte != 0x00)\r\nerr("i2c_r status error %02x", retbyte);\r\nretval = reg_r_i(gspca_dev, 0x0095);\r\nretval |= reg_r_i(gspca_dev, 0x0096) << 8;\r\nPDEBUG(D_USBI, "i2c r [%02x] -> %04x (%02x)",\r\nreg, retval, retbyte);\r\nreturn retval;\r\n}\r\nstatic u8 i2c_write(struct gspca_dev *gspca_dev,\r\nu8 reg,\r\nu8 valL,\r\nu8 valH)\r\n{\r\nu8 retbyte;\r\nif (gspca_dev->usb_err < 0)\r\nreturn 0;\r\nreg_w_i(gspca_dev, reg, 0x92);\r\nreg_w_i(gspca_dev, valL, 0x93);\r\nreg_w_i(gspca_dev, valH, 0x94);\r\nreg_w_i(gspca_dev, 0x01, 0x90);\r\nmsleep(1);\r\nretbyte = reg_r_i(gspca_dev, 0x0091);\r\nif (retbyte != 0x00)\r\nerr("i2c_w status error %02x", retbyte);\r\nPDEBUG(D_USBO, "i2c w [%02x] = %02x%02x (%02x)",\r\nreg, valH, valL, retbyte);\r\nreturn retbyte;\r\n}\r\nstatic void usb_exchange(struct gspca_dev *gspca_dev,\r\nconst struct usb_action *action)\r\n{\r\nwhile (action->req) {\r\nswitch (action->req) {\r\ncase 0xa0:\r\nreg_w(gspca_dev, action->val, action->idx);\r\nbreak;\r\ncase 0xa1:\r\nreg_r(gspca_dev, action->idx);\r\nbreak;\r\ncase 0xaa:\r\ni2c_write(gspca_dev,\r\naction->val,\r\naction->idx & 0xff,\r\naction->idx >> 8);\r\nbreak;\r\ncase 0xbb:\r\ni2c_write(gspca_dev,\r\naction->idx >> 8,\r\naction->idx & 0xff,\r\naction->val);\r\nbreak;\r\ndefault:\r\nmsleep(action->idx);\r\nbreak;\r\n}\r\naction++;\r\nmsleep(1);\r\n}\r\n}\r\nstatic void setmatrix(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nconst u8 *matrix;\r\nstatic const u8 adcm2700_matrix[9] =\r\n{0x74, 0xed, 0xed, 0xed, 0x74, 0xed, 0xed, 0xed, 0x74};\r\nstatic const u8 gc0305_matrix[9] =\r\n{0x50, 0xf8, 0xf8, 0xf8, 0x50, 0xf8, 0xf8, 0xf8, 0x50};\r\nstatic const u8 ov7620_matrix[9] =\r\n{0x58, 0xf4, 0xf4, 0xf4, 0x58, 0xf4, 0xf4, 0xf4, 0x58};\r\nstatic const u8 pas202b_matrix[9] =\r\n{0x4c, 0xf5, 0xff, 0xf9, 0x51, 0xf5, 0xfb, 0xed, 0x5f};\r\nstatic const u8 po2030_matrix[9] =\r\n{0x60, 0xf0, 0xf0, 0xf0, 0x60, 0xf0, 0xf0, 0xf0, 0x60};\r\nstatic const u8 tas5130c_matrix[9] =\r\n{0x68, 0xec, 0xec, 0xec, 0x68, 0xec, 0xec, 0xec, 0x68};\r\nstatic const u8 gc0303_matrix[9] =\r\n{0x7b, 0xea, 0xea, 0xea, 0x7b, 0xea, 0xea, 0xea, 0x7b};\r\nstatic const u8 *matrix_tb[SENSOR_MAX] = {\r\n[SENSOR_ADCM2700] = adcm2700_matrix,\r\n[SENSOR_CS2102] = ov7620_matrix,\r\n[SENSOR_CS2102K] = NULL,\r\n[SENSOR_GC0303] = gc0303_matrix,\r\n[SENSOR_GC0305] = gc0305_matrix,\r\n[SENSOR_HDCS2020] = NULL,\r\n[SENSOR_HV7131B] = NULL,\r\n[SENSOR_HV7131R] = po2030_matrix,\r\n[SENSOR_ICM105A] = po2030_matrix,\r\n[SENSOR_MC501CB] = NULL,\r\n[SENSOR_MT9V111_1] = gc0305_matrix,\r\n[SENSOR_MT9V111_3] = gc0305_matrix,\r\n[SENSOR_OV7620] = ov7620_matrix,\r\n[SENSOR_OV7630C] = NULL,\r\n[SENSOR_PAS106] = NULL,\r\n[SENSOR_PAS202B] = pas202b_matrix,\r\n[SENSOR_PB0330] = gc0305_matrix,\r\n[SENSOR_PO2030] = po2030_matrix,\r\n[SENSOR_TAS5130C] = tas5130c_matrix,\r\n};\r\nmatrix = matrix_tb[sd->sensor];\r\nif (matrix == NULL)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(ov7620_matrix); i++)\r\nreg_w(gspca_dev, matrix[i], 0x010a + i);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint sharpness;\r\nstatic const u8 sharpness_tb[][2] = {\r\n{0x02, 0x03},\r\n{0x04, 0x07},\r\n{0x08, 0x0f},\r\n{0x10, 0x1e}\r\n};\r\nsharpness = sd->ctrls[SHARPNESS].val;\r\nreg_w(gspca_dev, sharpness_tb[sharpness][0], 0x01c6);\r\nreg_r(gspca_dev, 0x01c8);\r\nreg_r(gspca_dev, 0x01c9);\r\nreg_r(gspca_dev, 0x01ca);\r\nreg_w(gspca_dev, sharpness_tb[sharpness][1], 0x01cb);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst u8 *Tgamma;\r\nint g, i, brightness, contrast, adj, gp1, gp2;\r\nu8 gr[16];\r\nstatic const u8 delta_b[16] =\r\n{0x50, 0x38, 0x2d, 0x28, 0x24, 0x21, 0x1e, 0x1d,\r\n0x1d, 0x1b, 0x1b, 0x1b, 0x19, 0x18, 0x18, 0x18};\r\nstatic const u8 delta_c[16] =\r\n{0x2c, 0x1a, 0x12, 0x0c, 0x0a, 0x06, 0x06, 0x06,\r\n0x04, 0x06, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02};\r\nstatic const u8 gamma_tb[6][16] = {\r\n{0x00, 0x00, 0x03, 0x0d, 0x1b, 0x2e, 0x45, 0x5f,\r\n0x79, 0x93, 0xab, 0xc1, 0xd4, 0xe5, 0xf3, 0xff},\r\n{0x01, 0x0c, 0x1f, 0x3a, 0x53, 0x6d, 0x85, 0x9c,\r\n0xb0, 0xc2, 0xd1, 0xde, 0xe9, 0xf2, 0xf9, 0xff},\r\n{0x04, 0x16, 0x30, 0x4e, 0x68, 0x81, 0x98, 0xac,\r\n0xbe, 0xcd, 0xda, 0xe4, 0xed, 0xf5, 0xfb, 0xff},\r\n{0x13, 0x38, 0x59, 0x79, 0x92, 0xa7, 0xb9, 0xc8,\r\n0xd4, 0xdf, 0xe7, 0xee, 0xf4, 0xf9, 0xfc, 0xff},\r\n{0x20, 0x4b, 0x6e, 0x8d, 0xa3, 0xb5, 0xc5, 0xd2,\r\n0xdc, 0xe5, 0xec, 0xf2, 0xf6, 0xfa, 0xfd, 0xff},\r\n{0x24, 0x44, 0x64, 0x84, 0x9d, 0xb2, 0xc4, 0xd3,\r\n0xe0, 0xeb, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff},\r\n};\r\nTgamma = gamma_tb[sd->ctrls[GAMMA].val - 1];\r\ncontrast = ((int) sd->ctrls[CONTRAST].val - 128);\r\nbrightness = ((int) sd->ctrls[BRIGHTNESS].val - 128);\r\nadj = 0;\r\ngp1 = gp2 = 0;\r\nfor (i = 0; i < 16; i++) {\r\ng = Tgamma[i] + delta_b[i] * brightness / 256\r\n- delta_c[i] * contrast / 256 - adj / 2;\r\nif (g > 0xff)\r\ng = 0xff;\r\nelse if (g < 0)\r\ng = 0;\r\nreg_w(gspca_dev, g, 0x0120 + i);\r\nif (contrast > 0)\r\nadj--;\r\nelse if (contrast < 0)\r\nadj++;\r\nif (i > 1)\r\ngr[i - 1] = (g - gp2) / 2;\r\nelse if (i != 0)\r\ngr[0] = gp1 == 0 ? 0 : (g - gp1);\r\ngp2 = gp1;\r\ngp1 = g;\r\n}\r\ngr[15] = (0xff - gp2) / 2;\r\nfor (i = 0; i < 16; i++)\r\nreg_w(gspca_dev, gr[i], 0x0130 + i);\r\n}\r\nstatic void getexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->ctrls[EXPOSURE].val = (i2c_read(gspca_dev, 0x25) << 9)\r\n| (i2c_read(gspca_dev, 0x26) << 1)\r\n| (i2c_read(gspca_dev, 0x27) >> 7);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint val;\r\nval = sd->ctrls[EXPOSURE].val;\r\ni2c_write(gspca_dev, 0x25, val >> 9, 0x00);\r\ni2c_write(gspca_dev, 0x26, val >> 1, 0x00);\r\ni2c_write(gspca_dev, 0x27, val << 7, 0x00);\r\n}\r\nstatic void setquality(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 frxt;\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM2700:\r\ncase SENSOR_GC0305:\r\ncase SENSOR_HV7131B:\r\ncase SENSOR_HV7131R:\r\ncase SENSOR_OV7620:\r\ncase SENSOR_PAS202B:\r\ncase SENSOR_PO2030:\r\nreturn;\r\n}\r\nreg_w(gspca_dev, QUANT_VAL, 0x0008);\r\nfrxt = 0x30;\r\nreg_w(gspca_dev, frxt, 0x0007);\r\n#if QUANT_VAL == 0 || QUANT_VAL == 1 || QUANT_VAL == 2\r\nfrxt = 0xff;\r\n#elif QUANT_VAL == 3\r\nfrxt = 0xf0;\r\n#elif QUANT_VAL == 4\r\nfrxt = 0xe0;\r\n#else\r\nfrxt = 0x20;\r\n#endif\r\nreg_w(gspca_dev, frxt, 0x0018);\r\n}\r\nstatic void setlightfreq(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, mode;\r\nconst struct usb_action *zc3_freq;\r\nstatic const struct usb_action *freq_tb[SENSOR_MAX][6] = {\r\n[SENSOR_ADCM2700] =\r\n{adcm2700_NoFliker, adcm2700_NoFliker,\r\nadcm2700_50HZ, adcm2700_50HZ,\r\nadcm2700_60HZ, adcm2700_60HZ},\r\n[SENSOR_CS2102] =\r\n{cs2102_NoFliker, cs2102_NoFlikerScale,\r\ncs2102_50HZ, cs2102_50HZScale,\r\ncs2102_60HZ, cs2102_60HZScale},\r\n[SENSOR_CS2102K] =\r\n{cs2102_NoFliker, cs2102_NoFlikerScale,\r\nNULL, NULL,\r\nNULL, NULL},\r\n[SENSOR_GC0303] =\r\n{gc0303_NoFliker, gc0303_NoFlikerScale,\r\ngc0303_50HZ, gc0303_50HZScale,\r\ngc0303_60HZ, gc0303_60HZScale},\r\n[SENSOR_GC0305] =\r\n{gc0305_NoFliker, gc0305_NoFliker,\r\ngc0305_50HZ, gc0305_50HZ,\r\ngc0305_60HZ, gc0305_60HZ},\r\n[SENSOR_HDCS2020] =\r\n{hdcs2020_NoFliker, hdcs2020_NoFliker,\r\nhdcs2020_50HZ, hdcs2020_50HZ,\r\nhdcs2020_60HZ, hdcs2020_60HZ},\r\n[SENSOR_HV7131B] =\r\n{hv7131b_NoFliker, hv7131b_NoFlikerScale,\r\nhv7131b_50HZ, hv7131b_50HZScale,\r\nhv7131b_60HZ, hv7131b_60HZScale},\r\n[SENSOR_HV7131R] =\r\n{hv7131r_NoFliker, hv7131r_NoFlikerScale,\r\nhv7131r_50HZ, hv7131r_50HZScale,\r\nhv7131r_60HZ, hv7131r_60HZScale},\r\n[SENSOR_ICM105A] =\r\n{icm105a_NoFliker, icm105a_NoFlikerScale,\r\nicm105a_50HZ, icm105a_50HZScale,\r\nicm105a_60HZ, icm105a_60HZScale},\r\n[SENSOR_MC501CB] =\r\n{mc501cb_NoFliker, mc501cb_NoFlikerScale,\r\nmc501cb_50HZ, mc501cb_50HZScale,\r\nmc501cb_60HZ, mc501cb_60HZScale},\r\n[SENSOR_MT9V111_1] =\r\n{mt9v111_1_AENoFliker, mt9v111_1_AENoFlikerScale,\r\nmt9v111_1_AE50HZ, mt9v111_1_AE50HZScale,\r\nmt9v111_1_AE60HZ, mt9v111_1_AE60HZScale},\r\n[SENSOR_MT9V111_3] =\r\n{mt9v111_3_AENoFliker, mt9v111_3_AENoFlikerScale,\r\nmt9v111_3_AE50HZ, mt9v111_3_AE50HZScale,\r\nmt9v111_3_AE60HZ, mt9v111_3_AE60HZScale},\r\n[SENSOR_OV7620] =\r\n{ov7620_NoFliker, ov7620_NoFliker,\r\nov7620_50HZ, ov7620_50HZ,\r\nov7620_60HZ, ov7620_60HZ},\r\n[SENSOR_OV7630C] =\r\n{NULL, NULL,\r\nNULL, NULL,\r\nNULL, NULL},\r\n[SENSOR_PAS106] =\r\n{pas106b_NoFliker, pas106b_NoFliker,\r\npas106b_50HZ, pas106b_50HZ,\r\npas106b_60HZ, pas106b_60HZ},\r\n[SENSOR_PAS202B] =\r\n{pas202b_NoFliker, pas202b_NoFlikerScale,\r\npas202b_50HZ, pas202b_50HZScale,\r\npas202b_60HZ, pas202b_60HZScale},\r\n[SENSOR_PB0330] =\r\n{pb0330_NoFliker, pb0330_NoFlikerScale,\r\npb0330_50HZ, pb0330_50HZScale,\r\npb0330_60HZ, pb0330_60HZScale},\r\n[SENSOR_PO2030] =\r\n{po2030_NoFliker, po2030_NoFliker,\r\npo2030_50HZ, po2030_50HZ,\r\npo2030_60HZ, po2030_60HZ},\r\n[SENSOR_TAS5130C] =\r\n{tas5130c_NoFliker, tas5130c_NoFlikerScale,\r\ntas5130c_50HZ, tas5130c_50HZScale,\r\ntas5130c_60HZ, tas5130c_60HZScale},\r\n};\r\ni = sd->ctrls[LIGHTFREQ].val * 2;\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nif (mode)\r\ni++;\r\nzc3_freq = freq_tb[sd->sensor][i];\r\nif (zc3_freq == NULL)\r\nreturn;\r\nusb_exchange(gspca_dev, zc3_freq);\r\nswitch (sd->sensor) {\r\ncase SENSOR_GC0305:\r\nif (mode\r\n&& sd->ctrls[LIGHTFREQ].val == 1)\r\nreg_w(gspca_dev, 0x85, 0x018d);\r\nbreak;\r\ncase SENSOR_OV7620:\r\nif (!mode) {\r\nif (sd->ctrls[LIGHTFREQ].val != 0)\r\nreg_w(gspca_dev, 0x40, 0x0002);\r\nelse\r\nreg_w(gspca_dev, 0x44, 0x0002);\r\n}\r\nbreak;\r\ncase SENSOR_PAS202B:\r\nreg_w(gspca_dev, 0x00, 0x01a7);\r\nbreak;\r\n}\r\n}\r\nstatic void setautogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 autoval;\r\nif (sd->ctrls[AUTOGAIN].val)\r\nautoval = 0x42;\r\nelse\r\nautoval = 0x02;\r\nreg_w(gspca_dev, autoval, 0x0180);\r\n}\r\nstatic void send_unknown(struct gspca_dev *gspca_dev, int sensor)\r\n{\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nswitch (sensor) {\r\ncase SENSOR_PAS106:\r\nreg_w(gspca_dev, 0x03, 0x003a);\r\nreg_w(gspca_dev, 0x0c, 0x003b);\r\nreg_w(gspca_dev, 0x08, 0x0038);\r\nbreak;\r\ncase SENSOR_ADCM2700:\r\ncase SENSOR_GC0305:\r\ncase SENSOR_OV7620:\r\ncase SENSOR_MT9V111_1:\r\ncase SENSOR_MT9V111_3:\r\ncase SENSOR_PB0330:\r\ncase SENSOR_PO2030:\r\nreg_w(gspca_dev, 0x0d, 0x003a);\r\nreg_w(gspca_dev, 0x02, 0x003b);\r\nreg_w(gspca_dev, 0x00, 0x0038);\r\nbreak;\r\ncase SENSOR_HV7131R:\r\ncase SENSOR_PAS202B:\r\nreg_w(gspca_dev, 0x03, 0x003b);\r\nreg_w(gspca_dev, 0x0c, 0x003a);\r\nreg_w(gspca_dev, 0x0b, 0x0039);\r\nif (sensor == SENSOR_PAS202B)\r\nreg_w(gspca_dev, 0x0b, 0x0038);\r\nbreak;\r\n}\r\n}\r\nstatic void start_2wr_probe(struct gspca_dev *gspca_dev, int sensor)\r\n{\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreg_w(gspca_dev, sensor, 0x0010);\r\nreg_w(gspca_dev, 0x01, 0x0001);\r\nreg_w(gspca_dev, 0x03, 0x0012);\r\nreg_w(gspca_dev, 0x01, 0x0012);\r\n}\r\nstatic int sif_probe(struct gspca_dev *gspca_dev)\r\n{\r\nu16 checkword;\r\nstart_2wr_probe(gspca_dev, 0x0f);\r\nreg_w(gspca_dev, 0x08, 0x008d);\r\nmsleep(150);\r\ncheckword = ((i2c_read(gspca_dev, 0x00) & 0x0f) << 4)\r\n| ((i2c_read(gspca_dev, 0x01) & 0xf0) >> 4);\r\nPDEBUG(D_PROBE, "probe sif 0x%04x", checkword);\r\nif (checkword == 0x0007) {\r\nsend_unknown(gspca_dev, SENSOR_PAS106);\r\nreturn 0x0f;\r\n}\r\nreturn -1;\r\n}\r\nstatic int vga_2wr_probe(struct gspca_dev *gspca_dev)\r\n{\r\nu16 retword;\r\nstart_2wr_probe(gspca_dev, 0x00);\r\ni2c_write(gspca_dev, 0x01, 0xaa, 0x00);\r\nretword = i2c_read(gspca_dev, 0x01);\r\nif (retword != 0)\r\nreturn 0x00;\r\nstart_2wr_probe(gspca_dev, 0x04);\r\ni2c_write(gspca_dev, 0x01, 0xaa, 0x00);\r\nretword = i2c_read(gspca_dev, 0x01);\r\nif (retword != 0)\r\nreturn 0x04;\r\nstart_2wr_probe(gspca_dev, 0x06);\r\nreg_w(gspca_dev, 0x08, 0x008d);\r\ni2c_write(gspca_dev, 0x11, 0xaa, 0x00);\r\nretword = i2c_read(gspca_dev, 0x11);\r\nif (retword != 0) {\r\ngoto ov_check;\r\n}\r\nstart_2wr_probe(gspca_dev, 0x08);\r\ni2c_write(gspca_dev, 0x1c, 0x00, 0x00);\r\ni2c_write(gspca_dev, 0x15, 0xaa, 0x00);\r\nretword = i2c_read(gspca_dev, 0x15);\r\nif (retword != 0)\r\nreturn 0x08;\r\nstart_2wr_probe(gspca_dev, 0x0a);\r\ni2c_write(gspca_dev, 0x07, 0xaa, 0xaa);\r\nretword = i2c_read(gspca_dev, 0x07);\r\nif (retword != 0)\r\nreturn 0x0a;\r\nretword = i2c_read(gspca_dev, 0x03);\r\nif (retword != 0)\r\nreturn 0x0a;\r\nretword = i2c_read(gspca_dev, 0x04);\r\nif (retword != 0)\r\nreturn 0x0a;\r\nstart_2wr_probe(gspca_dev, 0x0c);\r\ni2c_write(gspca_dev, 0x01, 0x11, 0x00);\r\nretword = i2c_read(gspca_dev, 0x01);\r\nif (retword != 0)\r\nreturn 0x0c;\r\nstart_2wr_probe(gspca_dev, 0x0e);\r\nreg_w(gspca_dev, 0x08, 0x008d);\r\ni2c_write(gspca_dev, 0x03, 0xaa, 0x00);\r\nmsleep(50);\r\nretword = i2c_read(gspca_dev, 0x03);\r\nif (retword != 0) {\r\nsend_unknown(gspca_dev, SENSOR_PAS202B);\r\nreturn 0x0e;\r\n}\r\nstart_2wr_probe(gspca_dev, 0x02);\r\ni2c_write(gspca_dev, 0x01, 0xaa, 0x00);\r\nretword = i2c_read(gspca_dev, 0x01);\r\nif (retword != 0)\r\nreturn 0x02;\r\nov_check:\r\nreg_r(gspca_dev, 0x0010);\r\nreg_r(gspca_dev, 0x0010);\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreg_w(gspca_dev, 0x01, 0x0001);\r\nreg_w(gspca_dev, 0x06, 0x0010);\r\nreg_w(gspca_dev, 0xa1, 0x008b);\r\nreg_w(gspca_dev, 0x08, 0x008d);\r\nmsleep(500);\r\nreg_w(gspca_dev, 0x01, 0x0012);\r\ni2c_write(gspca_dev, 0x12, 0x80, 0x00);\r\nretword = i2c_read(gspca_dev, 0x0a) << 8;\r\nretword |= i2c_read(gspca_dev, 0x0b);\r\nPDEBUG(D_PROBE, "probe 2wr ov vga 0x%04x", retword);\r\nswitch (retword) {\r\ncase 0x7631:\r\nreg_w(gspca_dev, 0x06, 0x0010);\r\nbreak;\r\ncase 0x7620:\r\ncase 0x7648:\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn retword;\r\n}\r\nstatic int vga_3wr_probe(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nu16 retword;\r\nreg_w(gspca_dev, 0x02, 0x0010);\r\nreg_r(gspca_dev, 0x0010);\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreg_w(gspca_dev, 0x00, 0x0010);\r\nreg_w(gspca_dev, 0x01, 0x0001);\r\nreg_w(gspca_dev, 0x91, 0x008b);\r\nreg_w(gspca_dev, 0x03, 0x0012);\r\nreg_w(gspca_dev, 0x01, 0x0012);\r\nreg_w(gspca_dev, 0x05, 0x0012);\r\nretword = i2c_read(gspca_dev, 0x14);\r\nif (retword != 0)\r\nreturn 0x11;\r\nretword = i2c_read(gspca_dev, 0x15);\r\nif (retword != 0)\r\nreturn 0x11;\r\nretword = i2c_read(gspca_dev, 0x16);\r\nif (retword != 0)\r\nreturn 0x11;\r\nreg_w(gspca_dev, 0x02, 0x0010);\r\nretword = reg_r(gspca_dev, 0x000b) << 8;\r\nretword |= reg_r(gspca_dev, 0x000a);\r\nPDEBUG(D_PROBE, "probe 3wr vga 1 0x%04x", retword);\r\nreg_r(gspca_dev, 0x0010);\r\nif ((retword & 0xff00) == 0x6400)\r\nreturn 0x02;\r\nfor (i = 0; i < ARRAY_SIZE(chipset_revision_sensor); i++) {\r\nif (chipset_revision_sensor[i].revision == retword) {\r\nsd->chip_revision = retword;\r\nsend_unknown(gspca_dev, SENSOR_PB0330);\r\nreturn chipset_revision_sensor[i].internal_sensor_id;\r\n}\r\n}\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreg_w(gspca_dev, 0x01, 0x0001);\r\nreg_w(gspca_dev, 0xdd, 0x008b);\r\nreg_w(gspca_dev, 0x0a, 0x0010);\r\nreg_w(gspca_dev, 0x03, 0x0012);\r\nreg_w(gspca_dev, 0x01, 0x0012);\r\nretword = i2c_read(gspca_dev, 0x00);\r\nif (retword != 0) {\r\nPDEBUG(D_PROBE, "probe 3wr vga type 0a");\r\nreturn 0x0a;\r\n}\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreg_w(gspca_dev, 0x01, 0x0001);\r\nreg_w(gspca_dev, 0x98, 0x008b);\r\nreg_w(gspca_dev, 0x01, 0x0010);\r\nreg_w(gspca_dev, 0x03, 0x0012);\r\nmsleep(2);\r\nreg_w(gspca_dev, 0x01, 0x0012);\r\nretword = i2c_read(gspca_dev, 0x00);\r\nif (retword != 0) {\r\nPDEBUG(D_PROBE, "probe 3wr vga type %02x", retword);\r\nif (retword == 0x0011)\r\nreturn 0x0303;\r\nif (retword == 0x0029)\r\nsend_unknown(gspca_dev, SENSOR_GC0305);\r\nreturn retword;\r\n}\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreg_w(gspca_dev, 0x01, 0x0001);\r\nreg_w(gspca_dev, 0xa1, 0x008b);\r\nreg_w(gspca_dev, 0x08, 0x008d);\r\nreg_w(gspca_dev, 0x06, 0x0010);\r\nreg_w(gspca_dev, 0x01, 0x0012);\r\nreg_w(gspca_dev, 0x05, 0x0012);\r\nif (i2c_read(gspca_dev, 0x1c) == 0x007f\r\n&& i2c_read(gspca_dev, 0x1d) == 0x00a2) {\r\nsend_unknown(gspca_dev, SENSOR_OV7620);\r\nreturn 0x06;\r\n}\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreg_w(gspca_dev, 0x00, 0x0002);\r\nreg_w(gspca_dev, 0x01, 0x0010);\r\nreg_w(gspca_dev, 0x01, 0x0001);\r\nreg_w(gspca_dev, 0xee, 0x008b);\r\nreg_w(gspca_dev, 0x03, 0x0012);\r\nreg_w(gspca_dev, 0x01, 0x0012);\r\nreg_w(gspca_dev, 0x05, 0x0012);\r\nretword = i2c_read(gspca_dev, 0x00) << 8;\r\nretword |= i2c_read(gspca_dev, 0x01);\r\nPDEBUG(D_PROBE, "probe 3wr vga 2 0x%04x", retword);\r\nif (retword == 0x2030) {\r\n#ifdef GSPCA_DEBUG\r\nu8 retbyte;\r\nretbyte = i2c_read(gspca_dev, 0x02);\r\nPDEBUG(D_PROBE, "sensor PO2030 rev 0x%02x", retbyte);\r\n#endif\r\nsend_unknown(gspca_dev, SENSOR_PO2030);\r\nreturn retword;\r\n}\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreg_w(gspca_dev, 0x0a, 0x0010);\r\nreg_w(gspca_dev, 0xd3, 0x008b);\r\nreg_w(gspca_dev, 0x01, 0x0001);\r\nreg_w(gspca_dev, 0x03, 0x0012);\r\nreg_w(gspca_dev, 0x01, 0x0012);\r\nreg_w(gspca_dev, 0x05, 0x0012);\r\nreg_w(gspca_dev, 0xd3, 0x008b);\r\nretword = i2c_read(gspca_dev, 0x01);\r\nif (retword != 0) {\r\nPDEBUG(D_PROBE, "probe 3wr vga type 0a ? ret: %04x", retword);\r\nreturn 0x16;\r\n}\r\nreturn -1;\r\n}\r\nstatic int zcxx_probeSensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint sensor;\r\nswitch (sd->sensor) {\r\ncase SENSOR_MC501CB:\r\nreturn -1;\r\ncase SENSOR_GC0303:\r\nreturn -1;\r\ncase SENSOR_PAS106:\r\nsensor = sif_probe(gspca_dev);\r\nif (sensor >= 0)\r\nreturn sensor;\r\nbreak;\r\n}\r\nsensor = vga_2wr_probe(gspca_dev);\r\nif (sensor >= 0)\r\nreturn sensor;\r\nreturn vga_3wr_probe(gspca_dev);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (id->idProduct == 0x301b)\r\nsd->bridge = BRIDGE_ZC301;\r\nelse\r\nsd->bridge = BRIDGE_ZC303;\r\nsd->sensor = id->driver_info;\r\ngspca_dev->cam.ctrls = sd->ctrls;\r\nsd->quality = QUALITY_DEF;\r\nif (gspca_dev->audio && gspca_dev->dev->speed < USB_SPEED_HIGH)\r\ngspca_dev->nbalt--;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nint sensor;\r\nstatic const u8 gamma[SENSOR_MAX] = {\r\n[SENSOR_ADCM2700] = 4,\r\n[SENSOR_CS2102] = 4,\r\n[SENSOR_CS2102K] = 5,\r\n[SENSOR_GC0303] = 3,\r\n[SENSOR_GC0305] = 4,\r\n[SENSOR_HDCS2020] = 4,\r\n[SENSOR_HV7131B] = 4,\r\n[SENSOR_HV7131R] = 4,\r\n[SENSOR_ICM105A] = 4,\r\n[SENSOR_MC501CB] = 4,\r\n[SENSOR_MT9V111_1] = 4,\r\n[SENSOR_MT9V111_3] = 4,\r\n[SENSOR_OV7620] = 3,\r\n[SENSOR_OV7630C] = 4,\r\n[SENSOR_PAS106] = 4,\r\n[SENSOR_PAS202B] = 4,\r\n[SENSOR_PB0330] = 4,\r\n[SENSOR_PO2030] = 4,\r\n[SENSOR_TAS5130C] = 3,\r\n};\r\nstatic const u8 mode_tb[SENSOR_MAX] = {\r\n[SENSOR_ADCM2700] = 2,\r\n[SENSOR_CS2102] = 1,\r\n[SENSOR_CS2102K] = 1,\r\n[SENSOR_GC0303] = 1,\r\n[SENSOR_GC0305] = 1,\r\n[SENSOR_HDCS2020] = 1,\r\n[SENSOR_HV7131B] = 1,\r\n[SENSOR_HV7131R] = 1,\r\n[SENSOR_ICM105A] = 1,\r\n[SENSOR_MC501CB] = 2,\r\n[SENSOR_MT9V111_1] = 1,\r\n[SENSOR_MT9V111_3] = 1,\r\n[SENSOR_OV7620] = 2,\r\n[SENSOR_OV7630C] = 1,\r\n[SENSOR_PAS106] = 0,\r\n[SENSOR_PAS202B] = 1,\r\n[SENSOR_PB0330] = 1,\r\n[SENSOR_PO2030] = 1,\r\n[SENSOR_TAS5130C] = 1,\r\n};\r\nsensor = zcxx_probeSensor(gspca_dev);\r\nif (sensor >= 0)\r\nPDEBUG(D_PROBE, "probe sensor -> %04x", sensor);\r\nif ((unsigned) force_sensor < SENSOR_MAX) {\r\nsd->sensor = force_sensor;\r\nPDEBUG(D_PROBE, "sensor forced to %d", force_sensor);\r\n} else {\r\nswitch (sensor) {\r\ncase -1:\r\nswitch (sd->sensor) {\r\ncase SENSOR_MC501CB:\r\nPDEBUG(D_PROBE, "Sensor MC501CB");\r\nbreak;\r\ncase SENSOR_GC0303:\r\nPDEBUG(D_PROBE, "Sensor GC0303");\r\nbreak;\r\ndefault:\r\nwarn("Unknown sensor - set to TAS5130C");\r\nsd->sensor = SENSOR_TAS5130C;\r\n}\r\nbreak;\r\ncase 0:\r\nsensor = i2c_read(gspca_dev, 0x00);\r\nPDEBUG(D_PROBE, "Sensor hv7131 type %d", sensor);\r\nswitch (sensor) {\r\ncase 0:\r\ncase 1:\r\nPDEBUG(D_PROBE, "Find Sensor HV7131B");\r\nsd->sensor = SENSOR_HV7131B;\r\nbreak;\r\ndefault:\r\nPDEBUG(D_PROBE, "Find Sensor HV7131R");\r\nsd->sensor = SENSOR_HV7131R;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x02:\r\nPDEBUG(D_PROBE, "Sensor TAS5130C");\r\nsd->sensor = SENSOR_TAS5130C;\r\nbreak;\r\ncase 0x04:\r\nPDEBUG(D_PROBE, "Find Sensor CS2102");\r\nsd->sensor = SENSOR_CS2102;\r\nbreak;\r\ncase 0x08:\r\nPDEBUG(D_PROBE, "Find Sensor HDCS2020");\r\nsd->sensor = SENSOR_HDCS2020;\r\nbreak;\r\ncase 0x0a:\r\nPDEBUG(D_PROBE,\r\n"Find Sensor PB0330. Chip revision %x",\r\nsd->chip_revision);\r\nsd->sensor = SENSOR_PB0330;\r\nbreak;\r\ncase 0x0c:\r\nPDEBUG(D_PROBE, "Find Sensor ICM105A");\r\nsd->sensor = SENSOR_ICM105A;\r\nbreak;\r\ncase 0x0e:\r\nPDEBUG(D_PROBE, "Find Sensor PAS202B");\r\nsd->sensor = SENSOR_PAS202B;\r\nbreak;\r\ncase 0x0f:\r\nPDEBUG(D_PROBE, "Find Sensor PAS106");\r\nsd->sensor = SENSOR_PAS106;\r\nbreak;\r\ncase 0x10:\r\ncase 0x12:\r\nPDEBUG(D_PROBE, "Find Sensor TAS5130C");\r\nsd->sensor = SENSOR_TAS5130C;\r\nbreak;\r\ncase 0x11:\r\nPDEBUG(D_PROBE, "Find Sensor HV7131R");\r\nsd->sensor = SENSOR_HV7131R;\r\nbreak;\r\ncase 0x13:\r\ncase 0x15:\r\nPDEBUG(D_PROBE,\r\n"Sensor MT9V111. Chip revision %04x",\r\nsd->chip_revision);\r\nsd->sensor = sd->bridge == BRIDGE_ZC301\r\n? SENSOR_MT9V111_1\r\n: SENSOR_MT9V111_3;\r\nbreak;\r\ncase 0x14:\r\nPDEBUG(D_PROBE,\r\n"Find Sensor CS2102K?. Chip revision %x",\r\nsd->chip_revision);\r\nsd->sensor = SENSOR_CS2102K;\r\nbreak;\r\ncase 0x16:\r\nPDEBUG(D_PROBE, "Find Sensor ADCM2700");\r\nsd->sensor = SENSOR_ADCM2700;\r\nbreak;\r\ncase 0x29:\r\nPDEBUG(D_PROBE, "Find Sensor GC0305");\r\nsd->sensor = SENSOR_GC0305;\r\nbreak;\r\ncase 0x0303:\r\nPDEBUG(D_PROBE, "Sensor GC0303");\r\nsd->sensor = SENSOR_GC0303;\r\nbreak;\r\ncase 0x2030:\r\nPDEBUG(D_PROBE, "Find Sensor PO2030");\r\nsd->sensor = SENSOR_PO2030;\r\nsd->ctrls[SHARPNESS].def = 0;\r\nbreak;\r\ncase 0x7620:\r\nPDEBUG(D_PROBE, "Find Sensor OV7620");\r\nsd->sensor = SENSOR_OV7620;\r\nbreak;\r\ncase 0x7631:\r\nPDEBUG(D_PROBE, "Find Sensor OV7630C");\r\nsd->sensor = SENSOR_OV7630C;\r\nbreak;\r\ncase 0x7648:\r\nPDEBUG(D_PROBE, "Find Sensor OV7648");\r\nsd->sensor = SENSOR_OV7620;\r\nbreak;\r\ndefault:\r\nerr("Unknown sensor %04x", sensor);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (sensor < 0x20) {\r\nif (sensor == -1 || sensor == 0x10 || sensor == 0x12)\r\nreg_w(gspca_dev, 0x02, 0x0010);\r\nreg_r(gspca_dev, 0x0010);\r\n}\r\ncam = &gspca_dev->cam;\r\nswitch (mode_tb[sd->sensor]) {\r\ncase 0:\r\ncam->cam_mode = sif_mode;\r\ncam->nmodes = ARRAY_SIZE(sif_mode);\r\nbreak;\r\ncase 1:\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nbreak;\r\ndefault:\r\ncam->cam_mode = broken_vga_mode;\r\ncam->nmodes = ARRAY_SIZE(broken_vga_mode);\r\nbreak;\r\n}\r\nsd->ctrls[GAMMA].def = gamma[sd->sensor];\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131R:\r\nbreak;\r\ncase SENSOR_OV7630C:\r\ngspca_dev->ctrl_dis = (1 << LIGHTFREQ) | (1 << EXPOSURE);\r\nbreak;\r\ndefault:\r\ngspca_dev->ctrl_dis = (1 << EXPOSURE);\r\nbreak;\r\n}\r\n#if AUTOGAIN_DEF\r\nif (sd->ctrls[AUTOGAIN].val)\r\ngspca_dev->ctrl_inac = (1 << EXPOSURE);\r\n#endif\r\nreg_w(gspca_dev, 0x01, 0x0000);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint mode;\r\nstatic const struct usb_action *init_tb[SENSOR_MAX][2] = {\r\n[SENSOR_ADCM2700] =\r\n{adcm2700_Initial, adcm2700_InitialScale},\r\n[SENSOR_CS2102] =\r\n{cs2102_Initial, cs2102_InitialScale},\r\n[SENSOR_CS2102K] =\r\n{cs2102K_Initial, cs2102K_InitialScale},\r\n[SENSOR_GC0303] =\r\n{gc0303_Initial, gc0303_InitialScale},\r\n[SENSOR_GC0305] =\r\n{gc0305_Initial, gc0305_InitialScale},\r\n[SENSOR_HDCS2020] =\r\n{hdcs2020_Initial, hdcs2020_InitialScale},\r\n[SENSOR_HV7131B] =\r\n{hv7131b_Initial, hv7131b_InitialScale},\r\n[SENSOR_HV7131R] =\r\n{hv7131r_Initial, hv7131r_InitialScale},\r\n[SENSOR_ICM105A] =\r\n{icm105a_Initial, icm105a_InitialScale},\r\n[SENSOR_MC501CB] =\r\n{mc501cb_Initial, mc501cb_InitialScale},\r\n[SENSOR_MT9V111_1] =\r\n{mt9v111_1_Initial, mt9v111_1_InitialScale},\r\n[SENSOR_MT9V111_3] =\r\n{mt9v111_3_Initial, mt9v111_3_InitialScale},\r\n[SENSOR_OV7620] =\r\n{ov7620_Initial, ov7620_InitialScale},\r\n[SENSOR_OV7630C] =\r\n{ov7630c_Initial, ov7630c_InitialScale},\r\n[SENSOR_PAS106] =\r\n{pas106b_Initial, pas106b_InitialScale},\r\n[SENSOR_PAS202B] =\r\n{pas202b_Initial, pas202b_InitialScale},\r\n[SENSOR_PB0330] =\r\n{pb0330_Initial, pb0330_InitialScale},\r\n[SENSOR_PO2030] =\r\n{po2030_Initial, po2030_InitialScale},\r\n[SENSOR_TAS5130C] =\r\n{tas5130c_Initial, tas5130c_InitialScale},\r\n};\r\njpeg_define(sd->jpeg_hdr, gspca_dev->height, gspca_dev->width,\r\n0x21);\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131R:\r\nzcxx_probeSensor(gspca_dev);\r\nbreak;\r\ncase SENSOR_PAS106:\r\nusb_exchange(gspca_dev, pas106b_Initial_com);\r\nbreak;\r\n}\r\nusb_exchange(gspca_dev, init_tb[sd->sensor][mode]);\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM2700:\r\ncase SENSOR_GC0305:\r\ncase SENSOR_OV7620:\r\ncase SENSOR_PO2030:\r\ncase SENSOR_TAS5130C:\r\ncase SENSOR_GC0303:\r\nreg_r(gspca_dev, 0x0002);\r\nreg_w(gspca_dev, 0x09, 0x01ad);\r\nreg_w(gspca_dev, 0x15, 0x01ae);\r\nif (sd->sensor == SENSOR_TAS5130C)\r\nbreak;\r\nreg_w(gspca_dev, 0x0d, 0x003a);\r\nreg_w(gspca_dev, 0x02, 0x003b);\r\nreg_w(gspca_dev, 0x00, 0x0038);\r\nbreak;\r\ncase SENSOR_HV7131R:\r\ncase SENSOR_PAS202B:\r\nreg_w(gspca_dev, 0x03, 0x003b);\r\nreg_w(gspca_dev, 0x0c, 0x003a);\r\nreg_w(gspca_dev, 0x0b, 0x0039);\r\nif (sd->sensor == SENSOR_HV7131R)\r\nreg_w(gspca_dev, 0x50, ZC3XX_R11D_GLOBALGAIN);\r\nbreak;\r\n}\r\nsetmatrix(gspca_dev);\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM2700:\r\ncase SENSOR_OV7620:\r\nreg_r(gspca_dev, 0x0008);\r\nreg_w(gspca_dev, 0x00, 0x0008);\r\nbreak;\r\ncase SENSOR_PAS202B:\r\ncase SENSOR_GC0305:\r\ncase SENSOR_HV7131R:\r\ncase SENSOR_TAS5130C:\r\nreg_r(gspca_dev, 0x0008);\r\ncase SENSOR_PO2030:\r\nreg_w(gspca_dev, 0x03, 0x0008);\r\nbreak;\r\n}\r\nsetsharpness(gspca_dev);\r\nswitch (sd->sensor) {\r\ncase SENSOR_CS2102K:\r\ncase SENSOR_HDCS2020:\r\ncase SENSOR_OV7630C:\r\nbreak;\r\ndefault:\r\nsetcontrast(gspca_dev);\r\nbreak;\r\n}\r\nsetmatrix(gspca_dev);\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7620:\r\ncase SENSOR_PAS202B:\r\nreg_r(gspca_dev, 0x0180);\r\nreg_w(gspca_dev, 0x00, 0x0180);\r\nbreak;\r\ndefault:\r\nsetquality(gspca_dev);\r\nbreak;\r\n}\r\nsetlightfreq(gspca_dev);\r\nswitch (sd->sensor) {\r\ncase SENSOR_ADCM2700:\r\nreg_w(gspca_dev, 0x09, 0x01ad);\r\nreg_w(gspca_dev, 0x15, 0x01ae);\r\nreg_w(gspca_dev, 0x02, 0x0180);\r\nreg_w(gspca_dev, 0x40, 0x0117);\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nif (!sd->ctrls[AUTOGAIN].val)\r\nsetexposure(gspca_dev);\r\nreg_w(gspca_dev, 0x00, ZC3XX_R1A7_CALCGLOBALMEAN);\r\nbreak;\r\ncase SENSOR_GC0305:\r\ncase SENSOR_TAS5130C:\r\nreg_w(gspca_dev, 0x09, 0x01ad);\r\nreg_w(gspca_dev, 0x15, 0x01ae);\r\ncase SENSOR_PAS202B:\r\ncase SENSOR_PO2030:\r\nreg_r(gspca_dev, 0x0180);\r\nbreak;\r\ncase SENSOR_OV7620:\r\nreg_w(gspca_dev, 0x09, 0x01ad);\r\nreg_w(gspca_dev, 0x15, 0x01ae);\r\ni2c_read(gspca_dev, 0x13);\r\ni2c_write(gspca_dev, 0x13, 0xa3, 0x00);\r\nreg_w(gspca_dev, 0x40, 0x0117);\r\nreg_r(gspca_dev, 0x0180);\r\nbreak;\r\n}\r\nsetautogain(gspca_dev);\r\nswitch (sd->sensor) {\r\ncase SENSOR_PO2030:\r\nmsleep(50);\r\nreg_w(gspca_dev, 0x00, 0x0007);\r\nreg_w(gspca_dev, 0x02, ZC3XX_R008_CLOCKSETTING);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!gspca_dev->present)\r\nreturn;\r\nsend_unknown(gspca_dev, sd->sensor);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (len >= 3\r\n&& data[len - 3] == 0xff && data[len - 2] == 0xd9) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata, len - 1);\r\nreturn;\r\n}\r\nif (data[0] == 0xff && data[1] == 0xd8) {\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ndata += 18;\r\nlen -= 18;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_setautogain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->ctrls[AUTOGAIN].val = val;\r\nif (val) {\r\ngspca_dev->ctrl_inac |= (1 << EXPOSURE);\r\n} else {\r\ngspca_dev->ctrl_inac &= ~(1 << EXPOSURE);\r\nif (gspca_dev->streaming)\r\ngetexposure(gspca_dev);\r\n}\r\nif (gspca_dev->streaming)\r\nsetautogain(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_querymenu(struct gspca_dev *gspca_dev,\r\nstruct v4l2_querymenu *menu)\r\n{\r\nswitch (menu->id) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nswitch (menu->index) {\r\ncase 0:\r\nstrcpy((char *) menu->name, "NoFliker");\r\nreturn 0;\r\ncase 1:\r\nstrcpy((char *) menu->name, "50 Hz");\r\nreturn 0;\r\ncase 2:\r\nstrcpy((char *) menu->name, "60 Hz");\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (jcomp->quality < QUALITY_MIN)\r\nsd->quality = QUALITY_MIN;\r\nelse if (jcomp->quality > QUALITY_MAX)\r\nsd->quality = QUALITY_MAX;\r\nelse\r\nsd->quality = jcomp->quality;\r\nif (gspca_dev->streaming)\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nmemset(jcomp, 0, sizeof *jcomp);\r\njcomp->quality = sd->quality;\r\njcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT\r\n| V4L2_JPEG_MARKER_DQT;\r\nreturn 0;\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nif (len == 8 && data[4] == 1) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int __init sd_mod_init(void)\r\n{\r\nreturn usb_register(&sd_driver);\r\n}\r\nstatic void __exit sd_mod_exit(void)\r\n{\r\nusb_deregister(&sd_driver);\r\n}
