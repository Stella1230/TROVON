void btmrvl_interrupt(struct btmrvl_private *priv)\r\n{\r\npriv->adapter->ps_state = PS_AWAKE;\r\npriv->adapter->wakeup_tries = 0;\r\npriv->adapter->int_count++;\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\n}\r\nvoid btmrvl_check_evtpkt(struct btmrvl_private *priv, struct sk_buff *skb)\r\n{\r\nstruct hci_event_hdr *hdr = (void *) skb->data;\r\nstruct hci_ev_cmd_complete *ec;\r\nu16 opcode, ocf;\r\nif (hdr->evt == HCI_EV_CMD_COMPLETE) {\r\nec = (void *) (skb->data + HCI_EVENT_HDR_SIZE);\r\nopcode = __le16_to_cpu(ec->opcode);\r\nocf = hci_opcode_ocf(opcode);\r\nif (ocf == BT_CMD_MODULE_CFG_REQ &&\r\npriv->btmrvl_dev.sendcmdflag) {\r\npriv->btmrvl_dev.sendcmdflag = false;\r\npriv->adapter->cmd_complete = true;\r\nwake_up_interruptible(&priv->adapter->cmd_wait_q);\r\n}\r\n}\r\n}\r\nint btmrvl_process_event(struct btmrvl_private *priv, struct sk_buff *skb)\r\n{\r\nstruct btmrvl_adapter *adapter = priv->adapter;\r\nstruct btmrvl_event *event;\r\nint ret = 0;\r\nevent = (struct btmrvl_event *) skb->data;\r\nif (event->ec != 0xff) {\r\nBT_DBG("Not Marvell Event=%x", event->ec);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nswitch (event->data[0]) {\r\ncase BT_CMD_AUTO_SLEEP_MODE:\r\nif (!event->data[2]) {\r\nif (event->data[1] == BT_PS_ENABLE)\r\nadapter->psmode = 1;\r\nelse\r\nadapter->psmode = 0;\r\nBT_DBG("PS Mode:%s",\r\n(adapter->psmode) ? "Enable" : "Disable");\r\n} else {\r\nBT_DBG("PS Mode command failed");\r\n}\r\nbreak;\r\ncase BT_CMD_HOST_SLEEP_CONFIG:\r\nif (!event->data[3])\r\nBT_DBG("gpio=%x, gap=%x", event->data[1],\r\nevent->data[2]);\r\nelse\r\nBT_DBG("HSCFG command failed");\r\nbreak;\r\ncase BT_CMD_HOST_SLEEP_ENABLE:\r\nif (!event->data[1]) {\r\nadapter->hs_state = HS_ACTIVATED;\r\nif (adapter->psmode)\r\nadapter->ps_state = PS_SLEEP;\r\nwake_up_interruptible(&adapter->cmd_wait_q);\r\nBT_DBG("HS ACTIVATED!");\r\n} else {\r\nBT_DBG("HS Enable failed");\r\n}\r\nbreak;\r\ncase BT_CMD_MODULE_CFG_REQ:\r\nif (priv->btmrvl_dev.sendcmdflag &&\r\nevent->data[1] == MODULE_BRINGUP_REQ) {\r\nBT_DBG("EVENT:%s",\r\n((event->data[2] == MODULE_BROUGHT_UP) ||\r\n(event->data[2] == MODULE_ALREADY_UP)) ?\r\n"Bring-up succeed" : "Bring-up failed");\r\nif (event->length > 3 && event->data[3])\r\npriv->btmrvl_dev.dev_type = HCI_AMP;\r\nelse\r\npriv->btmrvl_dev.dev_type = HCI_BREDR;\r\nBT_DBG("dev_type: %d", priv->btmrvl_dev.dev_type);\r\n} else if (priv->btmrvl_dev.sendcmdflag &&\r\nevent->data[1] == MODULE_SHUTDOWN_REQ) {\r\nBT_DBG("EVENT:%s", (event->data[2]) ?\r\n"Shutdown failed" : "Shutdown succeed");\r\n} else {\r\nBT_DBG("BT_CMD_MODULE_CFG_REQ resp for APP");\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase BT_EVENT_POWER_STATE:\r\nif (event->data[1] == BT_PS_SLEEP)\r\nadapter->ps_state = PS_SLEEP;\r\nBT_DBG("EVENT:%s",\r\n(adapter->ps_state) ? "PS_SLEEP" : "PS_AWAKE");\r\nbreak;\r\ndefault:\r\nBT_DBG("Unknown Event=%d", event->data[0]);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nexit:\r\nif (!ret)\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nint btmrvl_send_module_cfg_cmd(struct btmrvl_private *priv, int subcmd)\r\n{\r\nstruct sk_buff *skb;\r\nstruct btmrvl_cmd *cmd;\r\nint ret = 0;\r\nskb = bt_skb_alloc(sizeof(*cmd), GFP_ATOMIC);\r\nif (skb == NULL) {\r\nBT_ERR("No free skb");\r\nreturn -ENOMEM;\r\n}\r\ncmd = (struct btmrvl_cmd *) skb_put(skb, sizeof(*cmd));\r\ncmd->ocf_ogf = cpu_to_le16(hci_opcode_pack(OGF, BT_CMD_MODULE_CFG_REQ));\r\ncmd->length = 1;\r\ncmd->data[0] = subcmd;\r\nbt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;\r\nskb->dev = (void *) priv->btmrvl_dev.hcidev;\r\nskb_queue_head(&priv->adapter->tx_queue, skb);\r\npriv->btmrvl_dev.sendcmdflag = true;\r\npriv->adapter->cmd_complete = false;\r\nBT_DBG("Queue module cfg Command");\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\nif (!wait_event_interruptible_timeout(priv->adapter->cmd_wait_q,\r\npriv->adapter->cmd_complete,\r\nmsecs_to_jiffies(WAIT_UNTIL_CMD_RESP))) {\r\nret = -ETIMEDOUT;\r\nBT_ERR("module_cfg_cmd(%x): timeout: %d",\r\nsubcmd, priv->btmrvl_dev.sendcmdflag);\r\n}\r\nBT_DBG("module cfg Command done");\r\nreturn ret;\r\n}\r\nint btmrvl_enable_ps(struct btmrvl_private *priv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct btmrvl_cmd *cmd;\r\nskb = bt_skb_alloc(sizeof(*cmd), GFP_ATOMIC);\r\nif (skb == NULL) {\r\nBT_ERR("No free skb");\r\nreturn -ENOMEM;\r\n}\r\ncmd = (struct btmrvl_cmd *) skb_put(skb, sizeof(*cmd));\r\ncmd->ocf_ogf = cpu_to_le16(hci_opcode_pack(OGF,\r\nBT_CMD_AUTO_SLEEP_MODE));\r\ncmd->length = 1;\r\nif (priv->btmrvl_dev.psmode)\r\ncmd->data[0] = BT_PS_ENABLE;\r\nelse\r\ncmd->data[0] = BT_PS_DISABLE;\r\nbt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;\r\nskb->dev = (void *) priv->btmrvl_dev.hcidev;\r\nskb_queue_head(&priv->adapter->tx_queue, skb);\r\nBT_DBG("Queue PSMODE Command:%d", cmd->data[0]);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_enable_hs(struct btmrvl_private *priv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct btmrvl_cmd *cmd;\r\nint ret = 0;\r\nskb = bt_skb_alloc(sizeof(*cmd), GFP_ATOMIC);\r\nif (skb == NULL) {\r\nBT_ERR("No free skb");\r\nreturn -ENOMEM;\r\n}\r\ncmd = (struct btmrvl_cmd *) skb_put(skb, sizeof(*cmd));\r\ncmd->ocf_ogf = cpu_to_le16(hci_opcode_pack(OGF, BT_CMD_HOST_SLEEP_ENABLE));\r\ncmd->length = 0;\r\nbt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;\r\nskb->dev = (void *) priv->btmrvl_dev.hcidev;\r\nskb_queue_head(&priv->adapter->tx_queue, skb);\r\nBT_DBG("Queue hs enable Command");\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\nif (!wait_event_interruptible_timeout(priv->adapter->cmd_wait_q,\r\npriv->adapter->hs_state,\r\nmsecs_to_jiffies(WAIT_UNTIL_HS_STATE_CHANGED))) {\r\nret = -ETIMEDOUT;\r\nBT_ERR("timeout: %d, %d,%d", priv->adapter->hs_state,\r\npriv->adapter->ps_state,\r\npriv->adapter->wakeup_tries);\r\n}\r\nreturn ret;\r\n}\r\nint btmrvl_prepare_command(struct btmrvl_private *priv)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct btmrvl_cmd *cmd;\r\nint ret = 0;\r\nif (priv->btmrvl_dev.hscfgcmd) {\r\npriv->btmrvl_dev.hscfgcmd = 0;\r\nskb = bt_skb_alloc(sizeof(*cmd), GFP_ATOMIC);\r\nif (skb == NULL) {\r\nBT_ERR("No free skb");\r\nreturn -ENOMEM;\r\n}\r\ncmd = (struct btmrvl_cmd *) skb_put(skb, sizeof(*cmd));\r\ncmd->ocf_ogf = cpu_to_le16(hci_opcode_pack(OGF, BT_CMD_HOST_SLEEP_CONFIG));\r\ncmd->length = 2;\r\ncmd->data[0] = (priv->btmrvl_dev.gpio_gap & 0xff00) >> 8;\r\ncmd->data[1] = (u8) (priv->btmrvl_dev.gpio_gap & 0x00ff);\r\nbt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;\r\nskb->dev = (void *) priv->btmrvl_dev.hcidev;\r\nskb_queue_head(&priv->adapter->tx_queue, skb);\r\nBT_DBG("Queue HSCFG Command, gpio=0x%x, gap=0x%x",\r\ncmd->data[0], cmd->data[1]);\r\n}\r\nif (priv->btmrvl_dev.pscmd) {\r\npriv->btmrvl_dev.pscmd = 0;\r\nbtmrvl_enable_ps(priv);\r\n}\r\nif (priv->btmrvl_dev.hscmd) {\r\npriv->btmrvl_dev.hscmd = 0;\r\nif (priv->btmrvl_dev.hsmode) {\r\nret = btmrvl_enable_hs(priv);\r\n} else {\r\nret = priv->hw_wakeup_firmware(priv);\r\npriv->adapter->hs_state = HS_DEACTIVATED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int btmrvl_tx_pkt(struct btmrvl_private *priv, struct sk_buff *skb)\r\n{\r\nint ret = 0;\r\nif (!skb || !skb->data)\r\nreturn -EINVAL;\r\nif (!skb->len || ((skb->len + BTM_HEADER_LEN) > BTM_UPLD_SIZE)) {\r\nBT_ERR("Tx Error: Bad skb length %d : %d",\r\nskb->len, BTM_UPLD_SIZE);\r\nreturn -EINVAL;\r\n}\r\nif (skb_headroom(skb) < BTM_HEADER_LEN) {\r\nstruct sk_buff *tmp = skb;\r\nskb = skb_realloc_headroom(skb, BTM_HEADER_LEN);\r\nif (!skb) {\r\nBT_ERR("Tx Error: realloc_headroom failed %d",\r\nBTM_HEADER_LEN);\r\nskb = tmp;\r\nreturn -EINVAL;\r\n}\r\nkfree_skb(tmp);\r\n}\r\nskb_push(skb, BTM_HEADER_LEN);\r\nskb->data[0] = (skb->len & 0x0000ff);\r\nskb->data[1] = (skb->len & 0x00ff00) >> 8;\r\nskb->data[2] = (skb->len & 0xff0000) >> 16;\r\nskb->data[3] = bt_cb(skb)->pkt_type;\r\nif (priv->hw_host_to_card)\r\nret = priv->hw_host_to_card(priv, skb->data, skb->len);\r\nreturn ret;\r\n}\r\nstatic void btmrvl_init_adapter(struct btmrvl_private *priv)\r\n{\r\nskb_queue_head_init(&priv->adapter->tx_queue);\r\npriv->adapter->ps_state = PS_AWAKE;\r\ninit_waitqueue_head(&priv->adapter->cmd_wait_q);\r\n}\r\nstatic void btmrvl_free_adapter(struct btmrvl_private *priv)\r\n{\r\nskb_queue_purge(&priv->adapter->tx_queue);\r\nkfree(priv->adapter);\r\npriv->adapter = NULL;\r\n}\r\nstatic int btmrvl_ioctl(struct hci_dev *hdev,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void btmrvl_destruct(struct hci_dev *hdev)\r\n{\r\n}\r\nstatic int btmrvl_send_frame(struct sk_buff *skb)\r\n{\r\nstruct hci_dev *hdev = (struct hci_dev *) skb->dev;\r\nstruct btmrvl_private *priv = NULL;\r\nBT_DBG("type=%d, len=%d", skb->pkt_type, skb->len);\r\nif (!hdev || !hdev->driver_data) {\r\nBT_ERR("Frame for unknown HCI device");\r\nreturn -ENODEV;\r\n}\r\npriv = (struct btmrvl_private *) hdev->driver_data;\r\nif (!test_bit(HCI_RUNNING, &hdev->flags)) {\r\nBT_ERR("Failed testing HCI_RUNING, flags=%lx", hdev->flags);\r\nprint_hex_dump_bytes("data: ", DUMP_PREFIX_OFFSET,\r\nskb->data, skb->len);\r\nreturn -EBUSY;\r\n}\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n}\r\nskb_queue_tail(&priv->adapter->tx_queue, skb);\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_flush(struct hci_dev *hdev)\r\n{\r\nstruct btmrvl_private *priv = hdev->driver_data;\r\nskb_queue_purge(&priv->adapter->tx_queue);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_close(struct hci_dev *hdev)\r\n{\r\nstruct btmrvl_private *priv = hdev->driver_data;\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nskb_queue_purge(&priv->adapter->tx_queue);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_open(struct hci_dev *hdev)\r\n{\r\nset_bit(HCI_RUNNING, &hdev->flags);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_service_main_thread(void *data)\r\n{\r\nstruct btmrvl_thread *thread = data;\r\nstruct btmrvl_private *priv = thread->priv;\r\nstruct btmrvl_adapter *adapter = priv->adapter;\r\nwait_queue_t wait;\r\nstruct sk_buff *skb;\r\nulong flags;\r\ninit_waitqueue_entry(&wait, current);\r\ncurrent->flags |= PF_NOFREEZE;\r\nfor (;;) {\r\nadd_wait_queue(&thread->wait_q, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (adapter->wakeup_tries ||\r\n((!adapter->int_count) &&\r\n(!priv->btmrvl_dev.tx_dnld_rdy ||\r\nskb_queue_empty(&adapter->tx_queue)))) {\r\nBT_DBG("main_thread is sleeping...");\r\nschedule();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&thread->wait_q, &wait);\r\nBT_DBG("main_thread woke up");\r\nif (kthread_should_stop()) {\r\nBT_DBG("main_thread: break from main thread");\r\nbreak;\r\n}\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\nif (adapter->int_count) {\r\nadapter->int_count = 0;\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\npriv->hw_process_int_status(priv);\r\n} else if (adapter->ps_state == PS_SLEEP &&\r\n!skb_queue_empty(&adapter->tx_queue)) {\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\nadapter->wakeup_tries++;\r\npriv->hw_wakeup_firmware(priv);\r\ncontinue;\r\n} else {\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\n}\r\nif (adapter->ps_state == PS_SLEEP)\r\ncontinue;\r\nif (!priv->btmrvl_dev.tx_dnld_rdy)\r\ncontinue;\r\nskb = skb_dequeue(&adapter->tx_queue);\r\nif (skb) {\r\nif (btmrvl_tx_pkt(priv, skb))\r\npriv->btmrvl_dev.hcidev->stat.err_tx++;\r\nelse\r\npriv->btmrvl_dev.hcidev->stat.byte_tx += skb->len;\r\nkfree_skb(skb);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint btmrvl_register_hdev(struct btmrvl_private *priv)\r\n{\r\nstruct hci_dev *hdev = NULL;\r\nint ret;\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can not allocate HCI device");\r\ngoto err_hdev;\r\n}\r\npriv->btmrvl_dev.hcidev = hdev;\r\nhdev->driver_data = priv;\r\nhdev->bus = HCI_SDIO;\r\nhdev->open = btmrvl_open;\r\nhdev->close = btmrvl_close;\r\nhdev->flush = btmrvl_flush;\r\nhdev->send = btmrvl_send_frame;\r\nhdev->destruct = btmrvl_destruct;\r\nhdev->ioctl = btmrvl_ioctl;\r\nhdev->owner = THIS_MODULE;\r\nbtmrvl_send_module_cfg_cmd(priv, MODULE_BRINGUP_REQ);\r\nhdev->dev_type = priv->btmrvl_dev.dev_type;\r\nret = hci_register_dev(hdev);\r\nif (ret < 0) {\r\nBT_ERR("Can not register HCI device");\r\ngoto err_hci_register_dev;\r\n}\r\n#ifdef CONFIG_DEBUG_FS\r\nbtmrvl_debugfs_init(hdev);\r\n#endif\r\nreturn 0;\r\nerr_hci_register_dev:\r\nhci_free_dev(hdev);\r\nerr_hdev:\r\nkthread_stop(priv->main_thread.task);\r\nbtmrvl_free_adapter(priv);\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\nstruct btmrvl_private *btmrvl_add_card(void *card)\r\n{\r\nstruct btmrvl_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nBT_ERR("Can not allocate priv");\r\ngoto err_priv;\r\n}\r\npriv->adapter = kzalloc(sizeof(*priv->adapter), GFP_KERNEL);\r\nif (!priv->adapter) {\r\nBT_ERR("Allocate buffer for btmrvl_adapter failed!");\r\ngoto err_adapter;\r\n}\r\nbtmrvl_init_adapter(priv);\r\nBT_DBG("Starting kthread...");\r\npriv->main_thread.priv = priv;\r\nspin_lock_init(&priv->driver_lock);\r\ninit_waitqueue_head(&priv->main_thread.wait_q);\r\npriv->main_thread.task = kthread_run(btmrvl_service_main_thread,\r\n&priv->main_thread, "btmrvl_main_service");\r\npriv->btmrvl_dev.card = card;\r\npriv->btmrvl_dev.tx_dnld_rdy = true;\r\nreturn priv;\r\nerr_adapter:\r\nkfree(priv);\r\nerr_priv:\r\nreturn NULL;\r\n}\r\nint btmrvl_remove_card(struct btmrvl_private *priv)\r\n{\r\nstruct hci_dev *hdev;\r\nhdev = priv->btmrvl_dev.hcidev;\r\nwake_up_interruptible(&priv->adapter->cmd_wait_q);\r\nkthread_stop(priv->main_thread.task);\r\n#ifdef CONFIG_DEBUG_FS\r\nbtmrvl_debugfs_remove(hdev);\r\n#endif\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\npriv->btmrvl_dev.hcidev = NULL;\r\nbtmrvl_free_adapter(priv);\r\nkfree(priv);\r\nreturn 0;\r\n}
