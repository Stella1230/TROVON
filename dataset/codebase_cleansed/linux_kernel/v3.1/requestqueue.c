void dlm_add_requestqueue(struct dlm_ls *ls, int nodeid, struct dlm_message *ms)\r\n{\r\nstruct rq_entry *e;\r\nint length = ms->m_header.h_length - sizeof(struct dlm_message);\r\ne = kmalloc(sizeof(struct rq_entry) + length, GFP_NOFS);\r\nif (!e) {\r\nlog_print("dlm_add_requestqueue: out of memory len %d", length);\r\nreturn;\r\n}\r\ne->nodeid = nodeid;\r\nmemcpy(&e->request, ms, ms->m_header.h_length);\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nlist_add_tail(&e->list, &ls->ls_requestqueue);\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\n}\r\nint dlm_process_requestqueue(struct dlm_ls *ls)\r\n{\r\nstruct rq_entry *e;\r\nint error = 0;\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nfor (;;) {\r\nif (list_empty(&ls->ls_requestqueue)) {\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\nerror = 0;\r\nbreak;\r\n}\r\ne = list_entry(ls->ls_requestqueue.next, struct rq_entry, list);\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\ndlm_receive_message_saved(ls, &e->request);\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nlist_del(&e->list);\r\nkfree(e);\r\nif (dlm_locking_stopped(ls)) {\r\nlog_debug(ls, "process_requestqueue abort running");\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\nerror = -EINTR;\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nreturn error;\r\n}\r\nvoid dlm_wait_requestqueue(struct dlm_ls *ls)\r\n{\r\nfor (;;) {\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nif (list_empty(&ls->ls_requestqueue))\r\nbreak;\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\nschedule();\r\n}\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\n}\r\nstatic int purge_request(struct dlm_ls *ls, struct dlm_message *ms, int nodeid)\r\n{\r\nuint32_t type = ms->m_type;\r\nif (!ls->ls_count)\r\nreturn 1;\r\nif (dlm_is_removed(ls, nodeid))\r\nreturn 1;\r\nif (type == DLM_MSG_REMOVE ||\r\ntype == DLM_MSG_LOOKUP ||\r\ntype == DLM_MSG_LOOKUP_REPLY)\r\nreturn 1;\r\nif (!dlm_no_directory(ls))\r\nreturn 0;\r\nswitch (type) {\r\ncase DLM_MSG_REQUEST:\r\ncase DLM_MSG_CONVERT:\r\ncase DLM_MSG_UNLOCK:\r\ncase DLM_MSG_CANCEL:\r\nif (dlm_hash2nodeid(ls, ms->m_hash) != dlm_our_nodeid())\r\nreturn 1;\r\nbreak;\r\ncase DLM_MSG_REQUEST_REPLY:\r\ncase DLM_MSG_CONVERT_REPLY:\r\ncase DLM_MSG_UNLOCK_REPLY:\r\ncase DLM_MSG_CANCEL_REPLY:\r\ncase DLM_MSG_GRANT:\r\nif (dlm_hash2nodeid(ls, ms->m_hash) != nodeid)\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid dlm_purge_requestqueue(struct dlm_ls *ls)\r\n{\r\nstruct dlm_message *ms;\r\nstruct rq_entry *e, *safe;\r\nmutex_lock(&ls->ls_requestqueue_mutex);\r\nlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\r\nms = &e->request;\r\nif (purge_request(ls, ms, e->nodeid)) {\r\nlist_del(&e->list);\r\nkfree(e);\r\n}\r\n}\r\nmutex_unlock(&ls->ls_requestqueue_mutex);\r\n}
