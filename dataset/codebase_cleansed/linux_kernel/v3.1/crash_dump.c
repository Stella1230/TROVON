void __init reserve_kdump_trampoline(void)\r\n{\r\nmemblock_reserve(0, KDUMP_RESERVE_LIMIT);\r\n}\r\nstatic void __init create_trampoline(unsigned long addr)\r\n{\r\nunsigned int *p = (unsigned int *)addr;\r\npatch_instruction(p, PPC_INST_NOP);\r\npatch_branch(++p, addr + PHYSICAL_START, 0);\r\n}\r\nvoid __init setup_kdump_trampoline(void)\r\n{\r\nunsigned long i;\r\nDBG(" -> setup_kdump_trampoline()\n");\r\nfor (i = KDUMP_TRAMPOLINE_START; i < KDUMP_TRAMPOLINE_END; i += 8) {\r\ncreate_trampoline(i);\r\n}\r\n#ifdef CONFIG_PPC_PSERIES\r\ncreate_trampoline(__pa(system_reset_fwnmi) - PHYSICAL_START);\r\ncreate_trampoline(__pa(machine_check_fwnmi) - PHYSICAL_START);\r\n#endif\r\nDBG(" <- setup_kdump_trampoline()\n");\r\n}\r\nstatic int __init parse_savemaxmem(char *p)\r\n{\r\nif (p)\r\nsaved_max_pfn = (memparse(p, &p) >> PAGE_SHIFT) - 1;\r\nreturn 1;\r\n}\r\nstatic size_t copy_oldmem_vaddr(void *vaddr, char *buf, size_t csize,\r\nunsigned long offset, int userbuf)\r\n{\r\nif (userbuf) {\r\nif (copy_to_user((char __user *)buf, (vaddr + offset), csize))\r\nreturn -EFAULT;\r\n} else\r\nmemcpy(buf, (vaddr + offset), csize);\r\nreturn csize;\r\n}\r\nssize_t copy_oldmem_page(unsigned long pfn, char *buf,\r\nsize_t csize, unsigned long offset, int userbuf)\r\n{\r\nvoid *vaddr;\r\nif (!csize)\r\nreturn 0;\r\ncsize = min_t(size_t, csize, PAGE_SIZE);\r\nif ((min_low_pfn < pfn) && (pfn < max_pfn)) {\r\nvaddr = __va(pfn << PAGE_SHIFT);\r\ncsize = copy_oldmem_vaddr(vaddr, buf, csize, offset, userbuf);\r\n} else {\r\nvaddr = __ioremap(pfn << PAGE_SHIFT, PAGE_SIZE, 0);\r\ncsize = copy_oldmem_vaddr(vaddr, buf, csize, offset, userbuf);\r\niounmap(vaddr);\r\n}\r\nreturn csize;\r\n}\r\nvoid crash_free_reserved_phys_range(unsigned long begin, unsigned long end)\r\n{\r\nunsigned long addr;\r\nconst u32 *basep, *sizep;\r\nunsigned int rtas_start = 0, rtas_end = 0;\r\nbasep = of_get_property(rtas.dev, "linux,rtas-base", NULL);\r\nsizep = of_get_property(rtas.dev, "rtas-size", NULL);\r\nif (basep && sizep) {\r\nrtas_start = *basep;\r\nrtas_end = *basep + *sizep;\r\n}\r\nfor (addr = begin; addr < end; addr += PAGE_SIZE) {\r\nif (addr <= rtas_end && ((addr + PAGE_SIZE) > rtas_start))\r\ncontinue;\r\nClearPageReserved(pfn_to_page(addr >> PAGE_SHIFT));\r\ninit_page_count(pfn_to_page(addr >> PAGE_SHIFT));\r\nfree_page((unsigned long)__va(addr));\r\ntotalram_pages++;\r\n}\r\n}
