static void __asr_toggle(void)\r\n{\r\nunsigned char reg;\r\nreg = inb(asr_read_addr);\r\noutb(reg & ~asr_toggle_mask, asr_write_addr);\r\nreg = inb(asr_read_addr);\r\noutb(reg | asr_toggle_mask, asr_write_addr);\r\nreg = inb(asr_read_addr);\r\noutb(reg & ~asr_toggle_mask, asr_write_addr);\r\nreg = inb(asr_read_addr);\r\n}\r\nstatic void asr_toggle(void)\r\n{\r\nspin_lock(&asr_lock);\r\n__asr_toggle();\r\nspin_unlock(&asr_lock);\r\n}\r\nstatic void asr_enable(void)\r\n{\r\nunsigned char reg;\r\nspin_lock(&asr_lock);\r\nif (asr_type == ASMTYPE_TOPAZ) {\r\nreg = inb(asr_read_addr);\r\noutb(reg & ~(TOPAZ_ASR_TOGGLE | TOPAZ_ASR_DISABLE),\r\nasr_read_addr);\r\n} else {\r\n__asr_toggle();\r\nreg = inb(asr_read_addr);\r\noutb(reg & ~asr_disable_mask, asr_write_addr);\r\n}\r\nreg = inb(asr_read_addr);\r\nspin_unlock(&asr_lock);\r\n}\r\nstatic void asr_disable(void)\r\n{\r\nunsigned char reg;\r\nspin_lock(&asr_lock);\r\nreg = inb(asr_read_addr);\r\nif (asr_type == ASMTYPE_TOPAZ)\r\noutb(reg | TOPAZ_ASR_TOGGLE | TOPAZ_ASR_DISABLE,\r\nasr_read_addr);\r\nelse {\r\noutb(reg | asr_toggle_mask, asr_write_addr);\r\nreg = inb(asr_read_addr);\r\noutb(reg | asr_disable_mask, asr_write_addr);\r\n}\r\nreg = inb(asr_read_addr);\r\nspin_unlock(&asr_lock);\r\n}\r\nstatic int __init asr_get_base_address(void)\r\n{\r\nunsigned char low, high;\r\nconst char *type = "";\r\nasr_length = 1;\r\nswitch (asr_type) {\r\ncase ASMTYPE_TOPAZ:\r\noutb(0x07, 0x2e);\r\noutb(0x07, 0x2f);\r\noutb(0x60, 0x2e);\r\nhigh = inb(0x2f);\r\noutb(0x61, 0x2e);\r\nlow = inb(0x2f);\r\nasr_base = (high << 16) | low;\r\nasr_read_addr = asr_write_addr =\r\nasr_base + TOPAZ_ASR_REG_OFFSET;\r\nasr_length = 5;\r\nbreak;\r\ncase ASMTYPE_JASPER:\r\ntype = "Jaspers ";\r\n#if 0\r\nu32 r;\r\npdev = pci_get_bus_and_slot(0, DEVFN(0x1f, 0));\r\nif (pdev == NULL)\r\nreturn -ENODEV;\r\npci_read_config_dword(pdev, 0x58, &r);\r\nasr_base = r & 0xFFFE;\r\npci_dev_put(pdev);\r\n#else\r\noutl(0x8000f858, 0xcf8);\r\nasr_base = inl(0xcfc) & 0xfffe;\r\n#endif\r\nasr_read_addr = asr_write_addr =\r\nasr_base + JASPER_ASR_REG_OFFSET;\r\nasr_toggle_mask = JASPER_ASR_TOGGLE_MASK;\r\nasr_disable_mask = JASPER_ASR_DISABLE_MASK;\r\nasr_length = JASPER_ASR_REG_OFFSET + 1;\r\nbreak;\r\ncase ASMTYPE_PEARL:\r\ntype = "Pearls ";\r\nasr_base = PEARL_BASE;\r\nasr_read_addr = PEARL_READ;\r\nasr_write_addr = PEARL_WRITE;\r\nasr_toggle_mask = PEARL_ASR_TOGGLE_MASK;\r\nasr_disable_mask = PEARL_ASR_DISABLE_MASK;\r\nasr_length = 4;\r\nbreak;\r\ncase ASMTYPE_JUNIPER:\r\ntype = "Junipers ";\r\nasr_base = JUNIPER_BASE_ADDRESS;\r\nasr_read_addr = asr_write_addr = asr_base;\r\nasr_toggle_mask = JUNIPER_ASR_TOGGLE_MASK;\r\nasr_disable_mask = JUNIPER_ASR_DISABLE_MASK;\r\nbreak;\r\ncase ASMTYPE_SPRUCE:\r\ntype = "Spruce's ";\r\nasr_base = SPRUCE_BASE_ADDRESS;\r\nasr_read_addr = asr_write_addr = asr_base;\r\nasr_toggle_mask = SPRUCE_ASR_TOGGLE_MASK;\r\nasr_disable_mask = SPRUCE_ASR_DISABLE_MASK;\r\nbreak;\r\n}\r\nif (!request_region(asr_base, asr_length, "ibmasr")) {\r\nprintk(KERN_ERR PFX "address %#x already in use\n",\r\nasr_base);\r\nreturn -EBUSY;\r\n}\r\nprintk(KERN_INFO PFX "found %sASR @ addr %#x\n", type, asr_base);\r\nreturn 0;\r\n}\r\nstatic ssize_t asr_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nasr_expect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nasr_expect_close = 42;\r\n}\r\n}\r\nasr_toggle();\r\n}\r\nreturn count;\r\n}\r\nstatic long asr_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING |\r\nWDIOF_MAGICCLOSE,\r\n.identity = "IBM ASR",\r\n};\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint heartbeat;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint new_options, retval = -EINVAL;\r\nif (get_user(new_options, p))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD) {\r\nasr_disable();\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_ENABLECARD) {\r\nasr_enable();\r\nasr_toggle();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nasr_toggle();\r\nreturn 0;\r\ncase WDIOC_GETTIMEOUT:\r\nheartbeat = 256;\r\nreturn put_user(heartbeat, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int asr_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &asr_is_open))\r\nreturn -EBUSY;\r\nasr_toggle();\r\nasr_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int asr_release(struct inode *inode, struct file *file)\r\n{\r\nif (asr_expect_close == 42)\r\nasr_disable();\r\nelse {\r\nprintk(KERN_CRIT PFX\r\n"unexpected close, not stopping watchdog!\n");\r\nasr_toggle();\r\n}\r\nclear_bit(0, &asr_is_open);\r\nasr_expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int __init ibmasr_init(void)\r\n{\r\nstruct ibmasr_id *id;\r\nint rc;\r\nfor (id = ibmasr_id_table; id->desc; id++) {\r\nif (dmi_find_device(DMI_DEV_TYPE_OTHER, id->desc, NULL)) {\r\nasr_type = id->type;\r\nbreak;\r\n}\r\n}\r\nif (!asr_type)\r\nreturn -ENODEV;\r\nspin_lock_init(&asr_lock);\r\nrc = asr_get_base_address();\r\nif (rc)\r\nreturn rc;\r\nrc = misc_register(&asr_miscdev);\r\nif (rc < 0) {\r\nrelease_region(asr_base, asr_length);\r\nprintk(KERN_ERR PFX "failed to register misc device\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit ibmasr_exit(void)\r\n{\r\nif (!nowayout)\r\nasr_disable();\r\nmisc_deregister(&asr_miscdev);\r\nrelease_region(asr_base, asr_length);\r\n}
