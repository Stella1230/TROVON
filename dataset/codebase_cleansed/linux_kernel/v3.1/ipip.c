static struct net_device_stats *ipip_get_stats(struct net_device *dev)\r\n{\r\nstruct pcpu_tstats sum = { 0 };\r\nint i;\r\nfor_each_possible_cpu(i) {\r\nconst struct pcpu_tstats *tstats = per_cpu_ptr(dev->tstats, i);\r\nsum.rx_packets += tstats->rx_packets;\r\nsum.rx_bytes += tstats->rx_bytes;\r\nsum.tx_packets += tstats->tx_packets;\r\nsum.tx_bytes += tstats->tx_bytes;\r\n}\r\ndev->stats.rx_packets = sum.rx_packets;\r\ndev->stats.rx_bytes = sum.rx_bytes;\r\ndev->stats.tx_packets = sum.tx_packets;\r\ndev->stats.tx_bytes = sum.tx_bytes;\r\nreturn &dev->stats;\r\n}\r\nstatic struct ip_tunnel * ipip_tunnel_lookup(struct net *net,\r\n__be32 remote, __be32 local)\r\n{\r\nunsigned int h0 = HASH(remote);\r\nunsigned int h1 = HASH(local);\r\nstruct ip_tunnel *t;\r\nstruct ipip_net *ipn = net_generic(net, ipip_net_id);\r\nfor_each_ip_tunnel_rcu(ipn->tunnels_r_l[h0 ^ h1])\r\nif (local == t->parms.iph.saddr &&\r\nremote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\r\nreturn t;\r\nfor_each_ip_tunnel_rcu(ipn->tunnels_r[h0])\r\nif (remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\r\nreturn t;\r\nfor_each_ip_tunnel_rcu(ipn->tunnels_l[h1])\r\nif (local == t->parms.iph.saddr && (t->dev->flags&IFF_UP))\r\nreturn t;\r\nt = rcu_dereference(ipn->tunnels_wc[0]);\r\nif (t && (t->dev->flags&IFF_UP))\r\nreturn t;\r\nreturn NULL;\r\n}\r\nstatic struct ip_tunnel __rcu **__ipip_bucket(struct ipip_net *ipn,\r\nstruct ip_tunnel_parm *parms)\r\n{\r\n__be32 remote = parms->iph.daddr;\r\n__be32 local = parms->iph.saddr;\r\nunsigned int h = 0;\r\nint prio = 0;\r\nif (remote) {\r\nprio |= 2;\r\nh ^= HASH(remote);\r\n}\r\nif (local) {\r\nprio |= 1;\r\nh ^= HASH(local);\r\n}\r\nreturn &ipn->tunnels[prio][h];\r\n}\r\nstatic inline struct ip_tunnel __rcu **ipip_bucket(struct ipip_net *ipn,\r\nstruct ip_tunnel *t)\r\n{\r\nreturn __ipip_bucket(ipn, &t->parms);\r\n}\r\nstatic void ipip_tunnel_unlink(struct ipip_net *ipn, struct ip_tunnel *t)\r\n{\r\nstruct ip_tunnel __rcu **tp;\r\nstruct ip_tunnel *iter;\r\nfor (tp = ipip_bucket(ipn, t);\r\n(iter = rtnl_dereference(*tp)) != NULL;\r\ntp = &iter->next) {\r\nif (t == iter) {\r\nrcu_assign_pointer(*tp, t->next);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ipip_tunnel_link(struct ipip_net *ipn, struct ip_tunnel *t)\r\n{\r\nstruct ip_tunnel __rcu **tp = ipip_bucket(ipn, t);\r\nrcu_assign_pointer(t->next, rtnl_dereference(*tp));\r\nrcu_assign_pointer(*tp, t);\r\n}\r\nstatic struct ip_tunnel * ipip_tunnel_locate(struct net *net,\r\nstruct ip_tunnel_parm *parms, int create)\r\n{\r\n__be32 remote = parms->iph.daddr;\r\n__be32 local = parms->iph.saddr;\r\nstruct ip_tunnel *t, *nt;\r\nstruct ip_tunnel __rcu **tp;\r\nstruct net_device *dev;\r\nchar name[IFNAMSIZ];\r\nstruct ipip_net *ipn = net_generic(net, ipip_net_id);\r\nfor (tp = __ipip_bucket(ipn, parms);\r\n(t = rtnl_dereference(*tp)) != NULL;\r\ntp = &t->next) {\r\nif (local == t->parms.iph.saddr && remote == t->parms.iph.daddr)\r\nreturn t;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nif (parms->name[0])\r\nstrlcpy(name, parms->name, IFNAMSIZ);\r\nelse\r\nstrcpy(name, "tunl%d");\r\ndev = alloc_netdev(sizeof(*t), name, ipip_tunnel_setup);\r\nif (dev == NULL)\r\nreturn NULL;\r\ndev_net_set(dev, net);\r\nnt = netdev_priv(dev);\r\nnt->parms = *parms;\r\nif (ipip_tunnel_init(dev) < 0)\r\ngoto failed_free;\r\nif (register_netdevice(dev) < 0)\r\ngoto failed_free;\r\ndev_hold(dev);\r\nipip_tunnel_link(ipn, nt);\r\nreturn nt;\r\nfailed_free:\r\nipip_dev_free(dev);\r\nreturn NULL;\r\n}\r\nstatic void ipip_tunnel_uninit(struct net_device *dev)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct ipip_net *ipn = net_generic(net, ipip_net_id);\r\nif (dev == ipn->fb_tunnel_dev)\r\nrcu_assign_pointer(ipn->tunnels_wc[0], NULL);\r\nelse\r\nipip_tunnel_unlink(ipn, netdev_priv(dev));\r\ndev_put(dev);\r\n}\r\nstatic int ipip_err(struct sk_buff *skb, u32 info)\r\n{\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nstruct ip_tunnel *t;\r\nint err;\r\nswitch (type) {\r\ndefault:\r\ncase ICMP_PARAMETERPROB:\r\nreturn 0;\r\ncase ICMP_DEST_UNREACH:\r\nswitch (code) {\r\ncase ICMP_SR_FAILED:\r\ncase ICMP_PORT_UNREACH:\r\nreturn 0;\r\ncase ICMP_FRAG_NEEDED:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase ICMP_TIME_EXCEEDED:\r\nif (code != ICMP_EXC_TTL)\r\nreturn 0;\r\nbreak;\r\n}\r\nerr = -ENOENT;\r\nrcu_read_lock();\r\nt = ipip_tunnel_lookup(dev_net(skb->dev), iph->daddr, iph->saddr);\r\nif (t == NULL || t->parms.iph.daddr == 0)\r\ngoto out;\r\nerr = 0;\r\nif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\r\ngoto out;\r\nif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\r\nt->err_count++;\r\nelse\r\nt->err_count = 1;\r\nt->err_time = jiffies;\r\nout:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic inline void ipip_ecn_decapsulate(const struct iphdr *outer_iph,\r\nstruct sk_buff *skb)\r\n{\r\nstruct iphdr *inner_iph = ip_hdr(skb);\r\nif (INET_ECN_is_ce(outer_iph->tos))\r\nIP_ECN_set_ce(inner_iph);\r\n}\r\nstatic int ipip_rcv(struct sk_buff *skb)\r\n{\r\nstruct ip_tunnel *tunnel;\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nrcu_read_lock();\r\ntunnel = ipip_tunnel_lookup(dev_net(skb->dev), iph->saddr, iph->daddr);\r\nif (tunnel != NULL) {\r\nstruct pcpu_tstats *tstats;\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nsecpath_reset(skb);\r\nskb->mac_header = skb->network_header;\r\nskb_reset_network_header(skb);\r\nskb->protocol = htons(ETH_P_IP);\r\nskb->pkt_type = PACKET_HOST;\r\ntstats = this_cpu_ptr(tunnel->dev->tstats);\r\ntstats->rx_packets++;\r\ntstats->rx_bytes += skb->len;\r\n__skb_tunnel_rx(skb, tunnel->dev);\r\nipip_ecn_decapsulate(iph, skb);\r\nnetif_rx(skb);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nrcu_read_unlock();\r\nreturn -1;\r\n}\r\nstatic netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct pcpu_tstats *tstats;\r\nconst struct iphdr *tiph = &tunnel->parms.iph;\r\nu8 tos = tunnel->parms.iph.tos;\r\n__be16 df = tiph->frag_off;\r\nstruct rtable *rt;\r\nstruct net_device *tdev;\r\nconst struct iphdr *old_iph = ip_hdr(skb);\r\nstruct iphdr *iph;\r\nunsigned int max_headroom;\r\n__be32 dst = tiph->daddr;\r\nstruct flowi4 fl4;\r\nint mtu;\r\nif (skb->protocol != htons(ETH_P_IP))\r\ngoto tx_error;\r\nif (tos & 1)\r\ntos = old_iph->tos;\r\nif (!dst) {\r\nif ((rt = skb_rtable(skb)) == NULL) {\r\ndev->stats.tx_fifo_errors++;\r\ngoto tx_error;\r\n}\r\nif ((dst = rt->rt_gateway) == 0)\r\ngoto tx_error_icmp;\r\n}\r\nrt = ip_route_output_ports(dev_net(dev), &fl4, NULL,\r\ndst, tiph->saddr,\r\n0, 0,\r\nIPPROTO_IPIP, RT_TOS(tos),\r\ntunnel->parms.link);\r\nif (IS_ERR(rt)) {\r\ndev->stats.tx_carrier_errors++;\r\ngoto tx_error_icmp;\r\n}\r\ntdev = rt->dst.dev;\r\nif (tdev == dev) {\r\nip_rt_put(rt);\r\ndev->stats.collisions++;\r\ngoto tx_error;\r\n}\r\ndf |= old_iph->frag_off & htons(IP_DF);\r\nif (df) {\r\nmtu = dst_mtu(&rt->dst) - sizeof(struct iphdr);\r\nif (mtu < 68) {\r\ndev->stats.collisions++;\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\nif (skb_dst(skb))\r\nskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\r\nif ((old_iph->frag_off & htons(IP_DF)) &&\r\nmtu < ntohs(old_iph->tot_len)) {\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\r\nhtonl(mtu));\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\n}\r\nif (tunnel->err_count > 0) {\r\nif (time_before(jiffies,\r\ntunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\r\ntunnel->err_count--;\r\ndst_link_failure(skb);\r\n} else\r\ntunnel->err_count = 0;\r\n}\r\nmax_headroom = (LL_RESERVED_SPACE(tdev)+sizeof(struct iphdr));\r\nif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\r\n(skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\r\nstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\r\nif (!new_skb) {\r\nip_rt_put(rt);\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb->sk)\r\nskb_set_owner_w(new_skb, skb->sk);\r\ndev_kfree_skb(skb);\r\nskb = new_skb;\r\nold_iph = ip_hdr(skb);\r\n}\r\nskb->transport_header = skb->network_header;\r\nskb_push(skb, sizeof(struct iphdr));\r\nskb_reset_network_header(skb);\r\nmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\r\nIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |\r\nIPSKB_REROUTED);\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\niph = ip_hdr(skb);\r\niph->version = 4;\r\niph->ihl = sizeof(struct iphdr)>>2;\r\niph->frag_off = df;\r\niph->protocol = IPPROTO_IPIP;\r\niph->tos = INET_ECN_encapsulate(tos, old_iph->tos);\r\niph->daddr = fl4.daddr;\r\niph->saddr = fl4.saddr;\r\nif ((iph->ttl = tiph->ttl) == 0)\r\niph->ttl = old_iph->ttl;\r\nnf_reset(skb);\r\ntstats = this_cpu_ptr(dev->tstats);\r\n__IPTUNNEL_XMIT(tstats, &dev->stats);\r\nreturn NETDEV_TX_OK;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\ndev->stats.tx_errors++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ipip_tunnel_bind_dev(struct net_device *dev)\r\n{\r\nstruct net_device *tdev = NULL;\r\nstruct ip_tunnel *tunnel;\r\nconst struct iphdr *iph;\r\ntunnel = netdev_priv(dev);\r\niph = &tunnel->parms.iph;\r\nif (iph->daddr) {\r\nstruct rtable *rt;\r\nstruct flowi4 fl4;\r\nrt = ip_route_output_ports(dev_net(dev), &fl4, NULL,\r\niph->daddr, iph->saddr,\r\n0, 0,\r\nIPPROTO_IPIP,\r\nRT_TOS(iph->tos),\r\ntunnel->parms.link);\r\nif (!IS_ERR(rt)) {\r\ntdev = rt->dst.dev;\r\nip_rt_put(rt);\r\n}\r\ndev->flags |= IFF_POINTOPOINT;\r\n}\r\nif (!tdev && tunnel->parms.link)\r\ntdev = __dev_get_by_index(dev_net(dev), tunnel->parms.link);\r\nif (tdev) {\r\ndev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);\r\ndev->mtu = tdev->mtu - sizeof(struct iphdr);\r\n}\r\ndev->iflink = tunnel->parms.link;\r\n}\r\nstatic int\r\nipip_tunnel_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip_tunnel_parm p;\r\nstruct ip_tunnel *t;\r\nstruct net *net = dev_net(dev);\r\nstruct ipip_net *ipn = net_generic(net, ipip_net_id);\r\nswitch (cmd) {\r\ncase SIOCGETTUNNEL:\r\nt = NULL;\r\nif (dev == ipn->fb_tunnel_dev) {\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nt = ipip_tunnel_locate(net, &p, 0);\r\n}\r\nif (t == NULL)\r\nt = netdev_priv(dev);\r\nmemcpy(&p, &t->parms, sizeof(p));\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase SIOCADDTUNNEL:\r\ncase SIOCCHGTUNNEL:\r\nerr = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\ngoto done;\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\ngoto done;\r\nerr = -EINVAL;\r\nif (p.iph.version != 4 || p.iph.protocol != IPPROTO_IPIP ||\r\np.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)))\r\ngoto done;\r\nif (p.iph.ttl)\r\np.iph.frag_off |= htons(IP_DF);\r\nt = ipip_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\r\nif (dev != ipn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\r\nif (t != NULL) {\r\nif (t->dev != dev) {\r\nerr = -EEXIST;\r\nbreak;\r\n}\r\n} else {\r\nif (((dev->flags&IFF_POINTOPOINT) && !p.iph.daddr) ||\r\n(!(dev->flags&IFF_POINTOPOINT) && p.iph.daddr)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nt = netdev_priv(dev);\r\nipip_tunnel_unlink(ipn, t);\r\nsynchronize_net();\r\nt->parms.iph.saddr = p.iph.saddr;\r\nt->parms.iph.daddr = p.iph.daddr;\r\nmemcpy(dev->dev_addr, &p.iph.saddr, 4);\r\nmemcpy(dev->broadcast, &p.iph.daddr, 4);\r\nipip_tunnel_link(ipn, t);\r\nnetdev_state_change(dev);\r\n}\r\n}\r\nif (t) {\r\nerr = 0;\r\nif (cmd == SIOCCHGTUNNEL) {\r\nt->parms.iph.ttl = p.iph.ttl;\r\nt->parms.iph.tos = p.iph.tos;\r\nt->parms.iph.frag_off = p.iph.frag_off;\r\nif (t->parms.link != p.link) {\r\nt->parms.link = p.link;\r\nipip_tunnel_bind_dev(dev);\r\nnetdev_state_change(dev);\r\n}\r\n}\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))\r\nerr = -EFAULT;\r\n} else\r\nerr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\r\nbreak;\r\ncase SIOCDELTUNNEL:\r\nerr = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\ngoto done;\r\nif (dev == ipn->fb_tunnel_dev) {\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\ngoto done;\r\nerr = -ENOENT;\r\nif ((t = ipip_tunnel_locate(net, &p, 0)) == NULL)\r\ngoto done;\r\nerr = -EPERM;\r\nif (t->dev == ipn->fb_tunnel_dev)\r\ngoto done;\r\ndev = t->dev;\r\n}\r\nunregister_netdevice(dev);\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\ndone:\r\nreturn err;\r\n}\r\nstatic int ipip_tunnel_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < 68 || new_mtu > 0xFFF8 - sizeof(struct iphdr))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void ipip_dev_free(struct net_device *dev)\r\n{\r\nfree_percpu(dev->tstats);\r\nfree_netdev(dev);\r\n}\r\nstatic void ipip_tunnel_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &ipip_netdev_ops;\r\ndev->destructor = ipip_dev_free;\r\ndev->type = ARPHRD_TUNNEL;\r\ndev->hard_header_len = LL_MAX_HEADER + sizeof(struct iphdr);\r\ndev->mtu = ETH_DATA_LEN - sizeof(struct iphdr);\r\ndev->flags = IFF_NOARP;\r\ndev->iflink = 0;\r\ndev->addr_len = 4;\r\ndev->features |= NETIF_F_NETNS_LOCAL;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\r\n}\r\nstatic int ipip_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\ntunnel->dev = dev;\r\nstrcpy(tunnel->parms.name, dev->name);\r\nmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\r\nmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\r\nipip_tunnel_bind_dev(dev);\r\ndev->tstats = alloc_percpu(struct pcpu_tstats);\r\nif (!dev->tstats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int __net_init ipip_fb_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct iphdr *iph = &tunnel->parms.iph;\r\nstruct ipip_net *ipn = net_generic(dev_net(dev), ipip_net_id);\r\ntunnel->dev = dev;\r\nstrcpy(tunnel->parms.name, dev->name);\r\niph->version = 4;\r\niph->protocol = IPPROTO_IPIP;\r\niph->ihl = 5;\r\ndev->tstats = alloc_percpu(struct pcpu_tstats);\r\nif (!dev->tstats)\r\nreturn -ENOMEM;\r\ndev_hold(dev);\r\nrcu_assign_pointer(ipn->tunnels_wc[0], tunnel);\r\nreturn 0;\r\n}\r\nstatic void ipip_destroy_tunnels(struct ipip_net *ipn, struct list_head *head)\r\n{\r\nint prio;\r\nfor (prio = 1; prio < 4; prio++) {\r\nint h;\r\nfor (h = 0; h < HASH_SIZE; h++) {\r\nstruct ip_tunnel *t;\r\nt = rtnl_dereference(ipn->tunnels[prio][h]);\r\nwhile (t != NULL) {\r\nunregister_netdevice_queue(t->dev, head);\r\nt = rtnl_dereference(t->next);\r\n}\r\n}\r\n}\r\n}\r\nstatic int __net_init ipip_init_net(struct net *net)\r\n{\r\nstruct ipip_net *ipn = net_generic(net, ipip_net_id);\r\nint err;\r\nipn->tunnels[0] = ipn->tunnels_wc;\r\nipn->tunnels[1] = ipn->tunnels_l;\r\nipn->tunnels[2] = ipn->tunnels_r;\r\nipn->tunnels[3] = ipn->tunnels_r_l;\r\nipn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel),\r\n"tunl0",\r\nipip_tunnel_setup);\r\nif (!ipn->fb_tunnel_dev) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_dev;\r\n}\r\ndev_net_set(ipn->fb_tunnel_dev, net);\r\nerr = ipip_fb_tunnel_init(ipn->fb_tunnel_dev);\r\nif (err)\r\ngoto err_reg_dev;\r\nif ((err = register_netdev(ipn->fb_tunnel_dev)))\r\ngoto err_reg_dev;\r\nreturn 0;\r\nerr_reg_dev:\r\nipip_dev_free(ipn->fb_tunnel_dev);\r\nerr_alloc_dev:\r\nreturn err;\r\n}\r\nstatic void __net_exit ipip_exit_net(struct net *net)\r\n{\r\nstruct ipip_net *ipn = net_generic(net, ipip_net_id);\r\nLIST_HEAD(list);\r\nrtnl_lock();\r\nipip_destroy_tunnels(ipn, &list);\r\nunregister_netdevice_queue(ipn->fb_tunnel_dev, &list);\r\nunregister_netdevice_many(&list);\r\nrtnl_unlock();\r\n}\r\nstatic int __init ipip_init(void)\r\n{\r\nint err;\r\nprintk(banner);\r\nerr = register_pernet_device(&ipip_net_ops);\r\nif (err < 0)\r\nreturn err;\r\nerr = xfrm4_tunnel_register(&ipip_handler, AF_INET);\r\nif (err < 0) {\r\nunregister_pernet_device(&ipip_net_ops);\r\nprintk(KERN_INFO "ipip init: can't register tunnel\n");\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit ipip_fini(void)\r\n{\r\nif (xfrm4_tunnel_deregister(&ipip_handler, AF_INET))\r\nprintk(KERN_INFO "ipip close: can't deregister tunnel\n");\r\nunregister_pernet_device(&ipip_net_ops);\r\n}
