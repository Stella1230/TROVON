static int pem_read_block(struct i2c_client *client, u8 command, u8 *data,\r\nint data_len)\r\n{\r\nu8 block_buffer[I2C_SMBUS_BLOCK_MAX];\r\nint result;\r\nresult = i2c_smbus_read_block_data(client, command, block_buffer);\r\nif (unlikely(result < 0))\r\ngoto abort;\r\nif (unlikely(result == 0xff || result != data_len)) {\r\nresult = -EIO;\r\ngoto abort;\r\n}\r\nmemcpy(data, block_buffer, data_len);\r\nresult = 0;\r\nabort:\r\nreturn result;\r\n}\r\nstatic struct pem_data *pem_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pem_data *data = i2c_get_clientdata(client);\r\nstruct pem_data *ret = data;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nint result;\r\nresult = pem_read_block(client, PEM_READ_DATA_STRING,\r\ndata->data_string,\r\nsizeof(data->data_string));\r\nif (unlikely(result < 0)) {\r\nret = ERR_PTR(result);\r\ngoto abort;\r\n}\r\nif (data->input_length) {\r\nresult = pem_read_block(client, PEM_READ_INPUT_STRING,\r\ndata->input_string,\r\ndata->input_length);\r\nif (unlikely(result < 0)) {\r\nret = ERR_PTR(result);\r\ngoto abort;\r\n}\r\n}\r\nif (data->fans_supported) {\r\nresult = pem_read_block(client, PEM_READ_FAN_SPEED,\r\ndata->fan_speed,\r\nsizeof(data->fan_speed));\r\nif (unlikely(result < 0)) {\r\nret = ERR_PTR(result);\r\ngoto abort;\r\n}\r\n}\r\ni2c_smbus_write_byte(client, PEM_CLEAR_INFO_FLAGS);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nabort:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic long pem_get_data(u8 *data, int len, int index)\r\n{\r\nlong val;\r\nswitch (index) {\r\ncase PEM_DATA_VOUT_LSB:\r\nval = (data[index] + (data[index+1] << 8)) * 5 / 2;\r\nbreak;\r\ncase PEM_DATA_CURRENT:\r\nval = data[index] * 200;\r\nbreak;\r\ncase PEM_DATA_TEMP:\r\nval = data[index] * 1000;\r\nbreak;\r\ncase PEM_DATA_TEMP_MAX:\r\nval = 97 * 1000;\r\nbreak;\r\ncase PEM_DATA_TEMP_CRIT:\r\nval = 107 * 1000;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nval = 0;\r\n}\r\nreturn val;\r\n}\r\nstatic long pem_get_input(u8 *data, int len, int index)\r\n{\r\nlong val;\r\nswitch (index) {\r\ncase PEM_INPUT_VOLTAGE:\r\nif (len == INPUT_STRING_LEN)\r\nval = (data[index] + (data[index+1] << 8) - 75) * 1000;\r\nelse\r\nval = (data[index] - 75) * 1000;\r\nbreak;\r\ncase PEM_INPUT_POWER_LSB:\r\nif (len == INPUT_STRING_LEN)\r\nindex++;\r\nval = (data[index] + (data[index+1] << 8)) * 1000000L;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nval = 0;\r\n}\r\nreturn val;\r\n}\r\nstatic long pem_get_fan(u8 *data, int len, int index)\r\n{\r\nlong val;\r\nswitch (index) {\r\ncase PEM_FAN_FAN1:\r\ncase PEM_FAN_FAN2:\r\ncase PEM_FAN_FAN3:\r\nval = data[index] * 100;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nval = 0;\r\n}\r\nreturn val;\r\n}\r\nstatic ssize_t pem_show_bool(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(da);\r\nstruct pem_data *data = pem_update_device(dev);\r\nu8 status;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nstatus = data->data_string[attr->nr] & attr->index;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", !!status);\r\n}\r\nstatic ssize_t pem_show_data(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct pem_data *data = pem_update_device(dev);\r\nlong value;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nvalue = pem_get_data(data->data_string, sizeof(data->data_string),\r\nattr->index);\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", value);\r\n}\r\nstatic ssize_t pem_show_input(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct pem_data *data = pem_update_device(dev);\r\nlong value;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nvalue = pem_get_input(data->input_string, sizeof(data->input_string),\r\nattr->index);\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", value);\r\n}\r\nstatic ssize_t pem_show_fan(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct pem_data *data = pem_update_device(dev);\r\nlong value;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nvalue = pem_get_fan(data->fan_speed, sizeof(data->fan_speed),\r\nattr->index);\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", value);\r\n}\r\nstatic int pem_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct pem_data *data;\r\nint ret;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BLOCK_DATA\r\n| I2C_FUNC_SMBUS_WRITE_BYTE))\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nret = pem_read_block(client, PEM_READ_FIRMWARE_REV,\r\ndata->firmware_rev, sizeof(data->firmware_rev));\r\nif (ret < 0)\r\ngoto out_kfree;\r\nret = i2c_smbus_write_byte(client, PEM_CLEAR_INFO_FLAGS);\r\nif (ret < 0)\r\ngoto out_kfree;\r\ndev_info(&client->dev, "Firmware revision %d.%d.%d\n",\r\ndata->firmware_rev[0], data->firmware_rev[1],\r\ndata->firmware_rev[2]);\r\nret = sysfs_create_group(&client->dev.kobj, &pem_group);\r\nif (ret)\r\ngoto out_kfree;\r\nret = pem_read_block(client, PEM_READ_INPUT_STRING,\r\ndata->input_string,\r\nsizeof(data->input_string) - 1);\r\nif (!ret && (data->input_string[0] || data->input_string[1] ||\r\ndata->input_string[2]))\r\ndata->input_length = sizeof(data->input_string) - 1;\r\nelse if (ret < 0) {\r\nret = pem_read_block(client, PEM_READ_INPUT_STRING,\r\ndata->input_string,\r\nsizeof(data->input_string));\r\nif (!ret && (data->input_string[0] || data->input_string[1] ||\r\ndata->input_string[2] || data->input_string[3]))\r\ndata->input_length = sizeof(data->input_string);\r\n}\r\nret = 0;\r\nif (data->input_length) {\r\nret = sysfs_create_group(&client->dev.kobj, &pem_input_group);\r\nif (ret)\r\ngoto out_remove_groups;\r\n}\r\nret = pem_read_block(client, PEM_READ_FAN_SPEED,\r\ndata->fan_speed,\r\nsizeof(data->fan_speed));\r\nif (!ret && (data->fan_speed[0] || data->fan_speed[1] ||\r\ndata->fan_speed[2] || data->fan_speed[3])) {\r\ndata->fans_supported = true;\r\nret = sysfs_create_group(&client->dev.kobj, &pem_fan_group);\r\nif (ret)\r\ngoto out_remove_groups;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto out_remove_groups;\r\n}\r\nreturn 0;\r\nout_remove_groups:\r\nsysfs_remove_group(&client->dev.kobj, &pem_input_group);\r\nsysfs_remove_group(&client->dev.kobj, &pem_fan_group);\r\nsysfs_remove_group(&client->dev.kobj, &pem_group);\r\nout_kfree:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int pem_remove(struct i2c_client *client)\r\n{\r\nstruct pem_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &pem_input_group);\r\nsysfs_remove_group(&client->dev.kobj, &pem_fan_group);\r\nsysfs_remove_group(&client->dev.kobj, &pem_group);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init pem_init(void)\r\n{\r\nreturn i2c_add_driver(&pem_driver);\r\n}\r\nstatic void __exit pem_exit(void)\r\n{\r\ni2c_del_driver(&pem_driver);\r\n}
