void ip_options_build(struct sk_buff *skb, struct ip_options *opt,\r\n__be32 daddr, struct rtable *rt, int is_frag)\r\n{\r\nunsigned char *iph = skb_network_header(skb);\r\nmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\r\nmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\r\nopt = &(IPCB(skb)->opt);\r\nif (opt->srr)\r\nmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\r\nif (!is_frag) {\r\nif (opt->rr_needaddr)\r\nip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, skb, rt);\r\nif (opt->ts_needaddr)\r\nip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, skb, rt);\r\nif (opt->ts_needtime) {\r\nstruct timespec tv;\r\n__be32 midtime;\r\ngetnstimeofday(&tv);\r\nmidtime = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC);\r\nmemcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);\r\n}\r\nreturn;\r\n}\r\nif (opt->rr) {\r\nmemset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);\r\nopt->rr = 0;\r\nopt->rr_needaddr = 0;\r\n}\r\nif (opt->ts) {\r\nmemset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);\r\nopt->ts = 0;\r\nopt->ts_needaddr = opt->ts_needtime = 0;\r\n}\r\n}\r\nint ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)\r\n{\r\nconst struct ip_options *sopt;\r\nunsigned char *sptr, *dptr;\r\nint soffset, doffset;\r\nint optlen;\r\n__be32 daddr;\r\nmemset(dopt, 0, sizeof(struct ip_options));\r\nsopt = &(IPCB(skb)->opt);\r\nif (sopt->optlen == 0)\r\nreturn 0;\r\nsptr = skb_network_header(skb);\r\ndptr = dopt->__data;\r\ndaddr = skb_rtable(skb)->rt_spec_dst;\r\nif (sopt->rr) {\r\noptlen = sptr[sopt->rr+1];\r\nsoffset = sptr[sopt->rr+2];\r\ndopt->rr = dopt->optlen + sizeof(struct iphdr);\r\nmemcpy(dptr, sptr+sopt->rr, optlen);\r\nif (sopt->rr_needaddr && soffset <= optlen) {\r\nif (soffset + 3 > optlen)\r\nreturn -EINVAL;\r\ndptr[2] = soffset + 4;\r\ndopt->rr_needaddr = 1;\r\n}\r\ndptr += optlen;\r\ndopt->optlen += optlen;\r\n}\r\nif (sopt->ts) {\r\noptlen = sptr[sopt->ts+1];\r\nsoffset = sptr[sopt->ts+2];\r\ndopt->ts = dopt->optlen + sizeof(struct iphdr);\r\nmemcpy(dptr, sptr+sopt->ts, optlen);\r\nif (soffset <= optlen) {\r\nif (sopt->ts_needaddr) {\r\nif (soffset + 3 > optlen)\r\nreturn -EINVAL;\r\ndopt->ts_needaddr = 1;\r\nsoffset += 4;\r\n}\r\nif (sopt->ts_needtime) {\r\nif (soffset + 3 > optlen)\r\nreturn -EINVAL;\r\nif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\r\ndopt->ts_needtime = 1;\r\nsoffset += 4;\r\n} else {\r\ndopt->ts_needtime = 0;\r\nif (soffset + 7 <= optlen) {\r\n__be32 addr;\r\nmemcpy(&addr, dptr+soffset-1, 4);\r\nif (inet_addr_type(dev_net(skb_dst(skb)->dev), addr) != RTN_UNICAST) {\r\ndopt->ts_needtime = 1;\r\nsoffset += 8;\r\n}\r\n}\r\n}\r\n}\r\ndptr[2] = soffset;\r\n}\r\ndptr += optlen;\r\ndopt->optlen += optlen;\r\n}\r\nif (sopt->srr) {\r\nunsigned char *start = sptr+sopt->srr;\r\n__be32 faddr;\r\noptlen = start[1];\r\nsoffset = start[2];\r\ndoffset = 0;\r\nif (soffset > optlen)\r\nsoffset = optlen + 1;\r\nsoffset -= 4;\r\nif (soffset > 3) {\r\nmemcpy(&faddr, &start[soffset-1], 4);\r\nfor (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)\r\nmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\r\nif (memcmp(&ip_hdr(skb)->saddr,\r\n&start[soffset + 3], 4) == 0)\r\ndoffset -= 4;\r\n}\r\nif (doffset > 3) {\r\nmemcpy(&start[doffset-1], &daddr, 4);\r\ndopt->faddr = faddr;\r\ndptr[0] = start[0];\r\ndptr[1] = doffset+3;\r\ndptr[2] = 4;\r\ndptr += doffset+3;\r\ndopt->srr = dopt->optlen + sizeof(struct iphdr);\r\ndopt->optlen += doffset+3;\r\ndopt->is_strictroute = sopt->is_strictroute;\r\n}\r\n}\r\nif (sopt->cipso) {\r\noptlen = sptr[sopt->cipso+1];\r\ndopt->cipso = dopt->optlen+sizeof(struct iphdr);\r\nmemcpy(dptr, sptr+sopt->cipso, optlen);\r\ndptr += optlen;\r\ndopt->optlen += optlen;\r\n}\r\nwhile (dopt->optlen & 3) {\r\n*dptr++ = IPOPT_END;\r\ndopt->optlen++;\r\n}\r\nreturn 0;\r\n}\r\nvoid ip_options_fragment(struct sk_buff * skb)\r\n{\r\nunsigned char *optptr = skb_network_header(skb) + sizeof(struct iphdr);\r\nstruct ip_options * opt = &(IPCB(skb)->opt);\r\nint l = opt->optlen;\r\nint optlen;\r\nwhile (l > 0) {\r\nswitch (*optptr) {\r\ncase IPOPT_END:\r\nreturn;\r\ncase IPOPT_NOOP:\r\nl--;\r\noptptr++;\r\ncontinue;\r\n}\r\noptlen = optptr[1];\r\nif (optlen<2 || optlen>l)\r\nreturn;\r\nif (!IPOPT_COPIED(*optptr))\r\nmemset(optptr, IPOPT_NOOP, optlen);\r\nl -= optlen;\r\noptptr += optlen;\r\n}\r\nopt->ts = 0;\r\nopt->rr = 0;\r\nopt->rr_needaddr = 0;\r\nopt->ts_needaddr = 0;\r\nopt->ts_needtime = 0;\r\n}\r\nint ip_options_compile(struct net *net,\r\nstruct ip_options * opt, struct sk_buff * skb)\r\n{\r\nint l;\r\nunsigned char * iph;\r\nunsigned char * optptr;\r\nint optlen;\r\nunsigned char * pp_ptr = NULL;\r\nstruct rtable *rt = NULL;\r\nif (skb != NULL) {\r\nrt = skb_rtable(skb);\r\noptptr = (unsigned char *)&(ip_hdr(skb)[1]);\r\n} else\r\noptptr = opt->__data;\r\niph = optptr - sizeof(struct iphdr);\r\nfor (l = opt->optlen; l > 0; ) {\r\nswitch (*optptr) {\r\ncase IPOPT_END:\r\nfor (optptr++, l--; l>0; optptr++, l--) {\r\nif (*optptr != IPOPT_END) {\r\n*optptr = IPOPT_END;\r\nopt->is_changed = 1;\r\n}\r\n}\r\ngoto eol;\r\ncase IPOPT_NOOP:\r\nl--;\r\noptptr++;\r\ncontinue;\r\n}\r\noptlen = optptr[1];\r\nif (optlen<2 || optlen>l) {\r\npp_ptr = optptr;\r\ngoto error;\r\n}\r\nswitch (*optptr) {\r\ncase IPOPT_SSRR:\r\ncase IPOPT_LSRR:\r\nif (optlen < 3) {\r\npp_ptr = optptr + 1;\r\ngoto error;\r\n}\r\nif (optptr[2] < 4) {\r\npp_ptr = optptr + 2;\r\ngoto error;\r\n}\r\nif (opt->srr) {\r\npp_ptr = optptr;\r\ngoto error;\r\n}\r\nif (!skb) {\r\nif (optptr[2] != 4 || optlen < 7 || ((optlen-3) & 3)) {\r\npp_ptr = optptr + 1;\r\ngoto error;\r\n}\r\nmemcpy(&opt->faddr, &optptr[3], 4);\r\nif (optlen > 7)\r\nmemmove(&optptr[3], &optptr[7], optlen-7);\r\n}\r\nopt->is_strictroute = (optptr[0] == IPOPT_SSRR);\r\nopt->srr = optptr - iph;\r\nbreak;\r\ncase IPOPT_RR:\r\nif (opt->rr) {\r\npp_ptr = optptr;\r\ngoto error;\r\n}\r\nif (optlen < 3) {\r\npp_ptr = optptr + 1;\r\ngoto error;\r\n}\r\nif (optptr[2] < 4) {\r\npp_ptr = optptr + 2;\r\ngoto error;\r\n}\r\nif (optptr[2] <= optlen) {\r\nif (optptr[2]+3 > optlen) {\r\npp_ptr = optptr + 2;\r\ngoto error;\r\n}\r\nif (rt) {\r\nmemcpy(&optptr[optptr[2]-1], &rt->rt_spec_dst, 4);\r\nopt->is_changed = 1;\r\n}\r\noptptr[2] += 4;\r\nopt->rr_needaddr = 1;\r\n}\r\nopt->rr = optptr - iph;\r\nbreak;\r\ncase IPOPT_TIMESTAMP:\r\nif (opt->ts) {\r\npp_ptr = optptr;\r\ngoto error;\r\n}\r\nif (optlen < 4) {\r\npp_ptr = optptr + 1;\r\ngoto error;\r\n}\r\nif (optptr[2] < 5) {\r\npp_ptr = optptr + 2;\r\ngoto error;\r\n}\r\nif (optptr[2] <= optlen) {\r\nunsigned char *timeptr = NULL;\r\nif (optptr[2]+3 > optptr[1]) {\r\npp_ptr = optptr + 2;\r\ngoto error;\r\n}\r\nswitch (optptr[3]&0xF) {\r\ncase IPOPT_TS_TSONLY:\r\nopt->ts = optptr - iph;\r\nif (skb)\r\ntimeptr = &optptr[optptr[2]-1];\r\nopt->ts_needtime = 1;\r\noptptr[2] += 4;\r\nbreak;\r\ncase IPOPT_TS_TSANDADDR:\r\nif (optptr[2]+7 > optptr[1]) {\r\npp_ptr = optptr + 2;\r\ngoto error;\r\n}\r\nopt->ts = optptr - iph;\r\nif (rt) {\r\nmemcpy(&optptr[optptr[2]-1], &rt->rt_spec_dst, 4);\r\ntimeptr = &optptr[optptr[2]+3];\r\n}\r\nopt->ts_needaddr = 1;\r\nopt->ts_needtime = 1;\r\noptptr[2] += 8;\r\nbreak;\r\ncase IPOPT_TS_PRESPEC:\r\nif (optptr[2]+7 > optptr[1]) {\r\npp_ptr = optptr + 2;\r\ngoto error;\r\n}\r\nopt->ts = optptr - iph;\r\n{\r\n__be32 addr;\r\nmemcpy(&addr, &optptr[optptr[2]-1], 4);\r\nif (inet_addr_type(net, addr) == RTN_UNICAST)\r\nbreak;\r\nif (skb)\r\ntimeptr = &optptr[optptr[2]+3];\r\n}\r\nopt->ts_needtime = 1;\r\noptptr[2] += 8;\r\nbreak;\r\ndefault:\r\nif (!skb && !capable(CAP_NET_RAW)) {\r\npp_ptr = optptr + 3;\r\ngoto error;\r\n}\r\nbreak;\r\n}\r\nif (timeptr) {\r\nstruct timespec tv;\r\nu32 midtime;\r\ngetnstimeofday(&tv);\r\nmidtime = (tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC;\r\nput_unaligned_be32(midtime, timeptr);\r\nopt->is_changed = 1;\r\n}\r\n} else {\r\nunsigned overflow = optptr[3]>>4;\r\nif (overflow == 15) {\r\npp_ptr = optptr + 3;\r\ngoto error;\r\n}\r\nopt->ts = optptr - iph;\r\nif (skb) {\r\noptptr[3] = (optptr[3]&0xF)|((overflow+1)<<4);\r\nopt->is_changed = 1;\r\n}\r\n}\r\nbreak;\r\ncase IPOPT_RA:\r\nif (optlen < 4) {\r\npp_ptr = optptr + 1;\r\ngoto error;\r\n}\r\nif (optptr[2] == 0 && optptr[3] == 0)\r\nopt->router_alert = optptr - iph;\r\nbreak;\r\ncase IPOPT_CIPSO:\r\nif ((!skb && !capable(CAP_NET_RAW)) || opt->cipso) {\r\npp_ptr = optptr;\r\ngoto error;\r\n}\r\nopt->cipso = optptr - iph;\r\nif (cipso_v4_validate(skb, &optptr)) {\r\npp_ptr = optptr;\r\ngoto error;\r\n}\r\nbreak;\r\ncase IPOPT_SEC:\r\ncase IPOPT_SID:\r\ndefault:\r\nif (!skb && !capable(CAP_NET_RAW)) {\r\npp_ptr = optptr;\r\ngoto error;\r\n}\r\nbreak;\r\n}\r\nl -= optlen;\r\noptptr += optlen;\r\n}\r\neol:\r\nif (!pp_ptr)\r\nreturn 0;\r\nerror:\r\nif (skb) {\r\nicmp_send(skb, ICMP_PARAMETERPROB, 0, htonl((pp_ptr-iph)<<24));\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid ip_options_undo(struct ip_options * opt)\r\n{\r\nif (opt->srr) {\r\nunsigned char * optptr = opt->__data+opt->srr-sizeof(struct iphdr);\r\nmemmove(optptr+7, optptr+3, optptr[1]-7);\r\nmemcpy(optptr+3, &opt->faddr, 4);\r\n}\r\nif (opt->rr_needaddr) {\r\nunsigned char * optptr = opt->__data+opt->rr-sizeof(struct iphdr);\r\noptptr[2] -= 4;\r\nmemset(&optptr[optptr[2]-1], 0, 4);\r\n}\r\nif (opt->ts) {\r\nunsigned char * optptr = opt->__data+opt->ts-sizeof(struct iphdr);\r\nif (opt->ts_needtime) {\r\noptptr[2] -= 4;\r\nmemset(&optptr[optptr[2]-1], 0, 4);\r\nif ((optptr[3]&0xF) == IPOPT_TS_PRESPEC)\r\noptptr[2] -= 4;\r\n}\r\nif (opt->ts_needaddr) {\r\noptptr[2] -= 4;\r\nmemset(&optptr[optptr[2]-1], 0, 4);\r\n}\r\n}\r\n}\r\nstatic struct ip_options_rcu *ip_options_get_alloc(const int optlen)\r\n{\r\nreturn kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),\r\nGFP_KERNEL);\r\n}\r\nstatic int ip_options_get_finish(struct net *net, struct ip_options_rcu **optp,\r\nstruct ip_options_rcu *opt, int optlen)\r\n{\r\nwhile (optlen & 3)\r\nopt->opt.__data[optlen++] = IPOPT_END;\r\nopt->opt.optlen = optlen;\r\nif (optlen && ip_options_compile(net, &opt->opt, NULL)) {\r\nkfree(opt);\r\nreturn -EINVAL;\r\n}\r\nkfree(*optp);\r\n*optp = opt;\r\nreturn 0;\r\n}\r\nint ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,\r\nunsigned char __user *data, int optlen)\r\n{\r\nstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\r\nif (!opt)\r\nreturn -ENOMEM;\r\nif (optlen && copy_from_user(opt->opt.__data, data, optlen)) {\r\nkfree(opt);\r\nreturn -EFAULT;\r\n}\r\nreturn ip_options_get_finish(net, optp, opt, optlen);\r\n}\r\nint ip_options_get(struct net *net, struct ip_options_rcu **optp,\r\nunsigned char *data, int optlen)\r\n{\r\nstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\r\nif (!opt)\r\nreturn -ENOMEM;\r\nif (optlen)\r\nmemcpy(opt->opt.__data, data, optlen);\r\nreturn ip_options_get_finish(net, optp, opt, optlen);\r\n}\r\nvoid ip_forward_options(struct sk_buff *skb)\r\n{\r\nstruct ip_options * opt = &(IPCB(skb)->opt);\r\nunsigned char * optptr;\r\nstruct rtable *rt = skb_rtable(skb);\r\nunsigned char *raw = skb_network_header(skb);\r\nif (opt->rr_needaddr) {\r\noptptr = (unsigned char *)raw + opt->rr;\r\nip_rt_get_source(&optptr[optptr[2]-5], skb, rt);\r\nopt->is_changed = 1;\r\n}\r\nif (opt->srr_is_hit) {\r\nint srrptr, srrspace;\r\noptptr = raw + opt->srr;\r\nfor ( srrptr=optptr[2], srrspace = optptr[1];\r\nsrrptr <= srrspace;\r\nsrrptr += 4\r\n) {\r\nif (srrptr + 3 > srrspace)\r\nbreak;\r\nif (memcmp(&ip_hdr(skb)->daddr, &optptr[srrptr-1], 4) == 0)\r\nbreak;\r\n}\r\nif (srrptr + 3 <= srrspace) {\r\nopt->is_changed = 1;\r\nip_rt_get_source(&optptr[srrptr-1], skb, rt);\r\noptptr[2] = srrptr+4;\r\n} else if (net_ratelimit())\r\nprintk(KERN_CRIT "ip_forward(): Argh! Destination lost!\n");\r\nif (opt->ts_needaddr) {\r\noptptr = raw + opt->ts;\r\nip_rt_get_source(&optptr[optptr[2]-9], skb, rt);\r\nopt->is_changed = 1;\r\n}\r\n}\r\nif (opt->is_changed) {\r\nopt->is_changed = 0;\r\nip_send_check(ip_hdr(skb));\r\n}\r\n}\r\nint ip_options_rcv_srr(struct sk_buff *skb)\r\n{\r\nstruct ip_options *opt = &(IPCB(skb)->opt);\r\nint srrspace, srrptr;\r\n__be32 nexthop;\r\nstruct iphdr *iph = ip_hdr(skb);\r\nunsigned char *optptr = skb_network_header(skb) + opt->srr;\r\nstruct rtable *rt = skb_rtable(skb);\r\nstruct rtable *rt2;\r\nunsigned long orefdst;\r\nint err;\r\nif (!rt)\r\nreturn 0;\r\nif (skb->pkt_type != PACKET_HOST)\r\nreturn -EINVAL;\r\nif (rt->rt_type == RTN_UNICAST) {\r\nif (!opt->is_strictroute)\r\nreturn 0;\r\nicmp_send(skb, ICMP_PARAMETERPROB, 0, htonl(16<<24));\r\nreturn -EINVAL;\r\n}\r\nif (rt->rt_type != RTN_LOCAL)\r\nreturn -EINVAL;\r\nfor (srrptr=optptr[2], srrspace = optptr[1]; srrptr <= srrspace; srrptr += 4) {\r\nif (srrptr + 3 > srrspace) {\r\nicmp_send(skb, ICMP_PARAMETERPROB, 0, htonl((opt->srr+2)<<24));\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&nexthop, &optptr[srrptr-1], 4);\r\norefdst = skb->_skb_refdst;\r\nskb_dst_set(skb, NULL);\r\nerr = ip_route_input(skb, nexthop, iph->saddr, iph->tos, skb->dev);\r\nrt2 = skb_rtable(skb);\r\nif (err || (rt2->rt_type != RTN_UNICAST && rt2->rt_type != RTN_LOCAL)) {\r\nskb_dst_drop(skb);\r\nskb->_skb_refdst = orefdst;\r\nreturn -EINVAL;\r\n}\r\nrefdst_drop(orefdst);\r\nif (rt2->rt_type != RTN_LOCAL)\r\nbreak;\r\niph->daddr = nexthop;\r\nopt->is_changed = 1;\r\n}\r\nif (srrptr <= srrspace) {\r\nopt->srr_is_hit = 1;\r\nopt->is_changed = 1;\r\n}\r\nreturn 0;\r\n}
