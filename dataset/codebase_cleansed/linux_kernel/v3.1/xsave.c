void __sanitize_i387_state(struct task_struct *tsk)\r\n{\r\nu64 xstate_bv;\r\nint feature_bit = 0x2;\r\nstruct i387_fxsave_struct *fx = &tsk->thread.fpu.state->fxsave;\r\nif (!fx)\r\nreturn;\r\nBUG_ON(task_thread_info(tsk)->status & TS_USEDFPU);\r\nxstate_bv = tsk->thread.fpu.state->xsave.xsave_hdr.xstate_bv;\r\nif ((xstate_bv & pcntxt_mask) == pcntxt_mask)\r\nreturn;\r\nif (!(xstate_bv & XSTATE_FP)) {\r\nfx->cwd = 0x37f;\r\nfx->swd = 0;\r\nfx->twd = 0;\r\nfx->fop = 0;\r\nfx->rip = 0;\r\nfx->rdp = 0;\r\nmemset(&fx->st_space[0], 0, 128);\r\n}\r\nif (!(xstate_bv & XSTATE_SSE))\r\nmemset(&fx->xmm_space[0], 0, 256);\r\nxstate_bv = (pcntxt_mask & ~xstate_bv) >> 2;\r\nwhile (xstate_bv) {\r\nif (xstate_bv & 0x1) {\r\nint offset = xstate_offsets[feature_bit];\r\nint size = xstate_sizes[feature_bit];\r\nmemcpy(((void *) fx) + offset,\r\n((void *) init_xstate_buf) + offset,\r\nsize);\r\n}\r\nxstate_bv >>= 1;\r\nfeature_bit++;\r\n}\r\n}\r\nint check_for_xstate(struct i387_fxsave_struct __user *buf,\r\nvoid __user *fpstate,\r\nstruct _fpx_sw_bytes *fx_sw_user)\r\n{\r\nint min_xstate_size = sizeof(struct i387_fxsave_struct) +\r\nsizeof(struct xsave_hdr_struct);\r\nunsigned int magic2;\r\nint err;\r\nerr = __copy_from_user(fx_sw_user, &buf->sw_reserved[0],\r\nsizeof(struct _fpx_sw_bytes));\r\nif (err)\r\nreturn -EFAULT;\r\nif (fx_sw_user->magic1 != FP_XSTATE_MAGIC1)\r\nreturn -EINVAL;\r\nif (fx_sw_user->xstate_size < min_xstate_size ||\r\nfx_sw_user->xstate_size > xstate_size ||\r\nfx_sw_user->xstate_size > fx_sw_user->extended_size)\r\nreturn -EINVAL;\r\nerr = __get_user(magic2, (__u32 *) (((void *)fpstate) +\r\nfx_sw_user->extended_size -\r\nFP_XSTATE_MAGIC2_SIZE));\r\nif (err)\r\nreturn err;\r\nif (magic2 != FP_XSTATE_MAGIC2)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint save_i387_xstate(void __user *buf)\r\n{\r\nstruct task_struct *tsk = current;\r\nint err = 0;\r\nif (!access_ok(VERIFY_WRITE, buf, sig_xstate_size))\r\nreturn -EACCES;\r\nBUG_ON(sig_xstate_size < xstate_size);\r\nif ((unsigned long)buf % 64)\r\nprintk("save_i387_xstate: bad fpstate %p\n", buf);\r\nif (!used_math())\r\nreturn 0;\r\nif (task_thread_info(tsk)->status & TS_USEDFPU) {\r\nif (use_xsave())\r\nerr = xsave_user(buf);\r\nelse\r\nerr = fxsave_user(buf);\r\nif (err)\r\nreturn err;\r\ntask_thread_info(tsk)->status &= ~TS_USEDFPU;\r\nstts();\r\n} else {\r\nsanitize_i387_state(tsk);\r\nif (__copy_to_user(buf, &tsk->thread.fpu.state->fxsave,\r\nxstate_size))\r\nreturn -1;\r\n}\r\nclear_used_math();\r\nif (use_xsave()) {\r\nstruct _fpstate __user *fx = buf;\r\nstruct _xstate __user *x = buf;\r\nu64 xstate_bv;\r\nerr = __copy_to_user(&fx->sw_reserved, &fx_sw_reserved,\r\nsizeof(struct _fpx_sw_bytes));\r\nerr |= __put_user(FP_XSTATE_MAGIC2,\r\n(__u32 __user *) (buf + sig_xstate_size\r\n- FP_XSTATE_MAGIC2_SIZE));\r\nerr |= __get_user(xstate_bv, &x->xstate_hdr.xstate_bv);\r\nxstate_bv |= XSTATE_FPSSE;\r\nerr |= __put_user(xstate_bv, &x->xstate_hdr.xstate_bv);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 1;\r\n}\r\nstatic int restore_user_xstate(void __user *buf)\r\n{\r\nstruct _fpx_sw_bytes fx_sw_user;\r\nu64 mask;\r\nint err;\r\nif (((unsigned long)buf % 64) ||\r\ncheck_for_xstate(buf, buf, &fx_sw_user))\r\ngoto fx_only;\r\nmask = fx_sw_user.xstate_bv;\r\nerr = xrestore_user(buf, mask);\r\nif (err)\r\nreturn err;\r\nmask = pcntxt_mask & ~mask;\r\nif (unlikely(mask))\r\nxrstor_state(init_xstate_buf, mask);\r\nreturn 0;\r\nfx_only:\r\nxrstor_state(init_xstate_buf, pcntxt_mask & ~XSTATE_FPSSE);\r\nreturn fxrstor_checking((__force struct i387_fxsave_struct *)buf);\r\n}\r\nint restore_i387_xstate(void __user *buf)\r\n{\r\nstruct task_struct *tsk = current;\r\nint err = 0;\r\nif (!buf) {\r\nif (used_math())\r\ngoto clear;\r\nreturn 0;\r\n} else\r\nif (!access_ok(VERIFY_READ, buf, sig_xstate_size))\r\nreturn -EACCES;\r\nif (!used_math()) {\r\nerr = init_fpu(tsk);\r\nif (err)\r\nreturn err;\r\n}\r\nif (!(task_thread_info(current)->status & TS_USEDFPU)) {\r\nclts();\r\ntask_thread_info(current)->status |= TS_USEDFPU;\r\n}\r\nif (use_xsave())\r\nerr = restore_user_xstate(buf);\r\nelse\r\nerr = fxrstor_checking((__force struct i387_fxsave_struct *)\r\nbuf);\r\nif (unlikely(err)) {\r\nclear:\r\nclear_fpu(tsk);\r\nclear_used_math();\r\n}\r\nreturn err;\r\n}\r\nstatic void prepare_fx_sw_frame(void)\r\n{\r\nint size_extended = (xstate_size - sizeof(struct i387_fxsave_struct)) +\r\nFP_XSTATE_MAGIC2_SIZE;\r\nsig_xstate_size = sizeof(struct _fpstate) + size_extended;\r\n#ifdef CONFIG_IA32_EMULATION\r\nsig_xstate_ia32_size = sizeof(struct _fpstate_ia32) + size_extended;\r\n#endif\r\nmemset(&fx_sw_reserved, 0, sizeof(fx_sw_reserved));\r\nfx_sw_reserved.magic1 = FP_XSTATE_MAGIC1;\r\nfx_sw_reserved.extended_size = sig_xstate_size;\r\nfx_sw_reserved.xstate_bv = pcntxt_mask;\r\nfx_sw_reserved.xstate_size = xstate_size;\r\n#ifdef CONFIG_IA32_EMULATION\r\nmemcpy(&fx_sw_reserved_ia32, &fx_sw_reserved,\r\nsizeof(struct _fpx_sw_bytes));\r\nfx_sw_reserved_ia32.extended_size = sig_xstate_ia32_size;\r\n#endif\r\n}\r\nstatic inline void xstate_enable(void)\r\n{\r\nset_in_cr4(X86_CR4_OSXSAVE);\r\nxsetbv(XCR_XFEATURE_ENABLED_MASK, pcntxt_mask);\r\n}\r\nstatic void __init setup_xstate_features(void)\r\n{\r\nint eax, ebx, ecx, edx, leaf = 0x2;\r\nxstate_features = fls64(pcntxt_mask);\r\nxstate_offsets = alloc_bootmem(xstate_features * sizeof(int));\r\nxstate_sizes = alloc_bootmem(xstate_features * sizeof(int));\r\ndo {\r\ncpuid_count(XSTATE_CPUID, leaf, &eax, &ebx, &ecx, &edx);\r\nif (eax == 0)\r\nbreak;\r\nxstate_offsets[leaf] = ebx;\r\nxstate_sizes[leaf] = eax;\r\nleaf++;\r\n} while (1);\r\n}\r\nstatic void __init setup_xstate_init(void)\r\n{\r\nsetup_xstate_features();\r\ninit_xstate_buf = alloc_bootmem_align(xstate_size,\r\n__alignof__(struct xsave_struct));\r\ninit_xstate_buf->i387.mxcsr = MXCSR_DEFAULT;\r\nclts();\r\nxrstor_state(init_xstate_buf, -1);\r\nxsave_state(init_xstate_buf, -1);\r\nstts();\r\n}\r\nstatic void __init xstate_enable_boot_cpu(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx;\r\nif (boot_cpu_data.cpuid_level < XSTATE_CPUID) {\r\nWARN(1, KERN_ERR "XSTATE_CPUID missing\n");\r\nreturn;\r\n}\r\ncpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);\r\npcntxt_mask = eax + ((u64)edx << 32);\r\nif ((pcntxt_mask & XSTATE_FPSSE) != XSTATE_FPSSE) {\r\nprintk(KERN_ERR "FP/SSE not shown under xsave features 0x%llx\n",\r\npcntxt_mask);\r\nBUG();\r\n}\r\npcntxt_mask = pcntxt_mask & XCNTXT_MASK;\r\nxstate_enable();\r\ncpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);\r\nxstate_size = ebx;\r\nupdate_regset_xstate_info(xstate_size, pcntxt_mask);\r\nprepare_fx_sw_frame();\r\nsetup_xstate_init();\r\nprintk(KERN_INFO "xsave/xrstor: enabled xstate_bv 0x%llx, "\r\n"cntxt size 0x%x\n",\r\npcntxt_mask, xstate_size);\r\n}\r\nvoid __cpuinit xsave_init(void)\r\n{\r\nstatic __refdata void (*next_func)(void) = xstate_enable_boot_cpu;\r\nvoid (*this_func)(void);\r\nif (!cpu_has_xsave)\r\nreturn;\r\nthis_func = next_func;\r\nnext_func = xstate_enable;\r\nthis_func();\r\n}
