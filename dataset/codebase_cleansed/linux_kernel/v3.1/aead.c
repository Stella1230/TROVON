static int setkey_unaligned(struct crypto_aead *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct aead_alg *aead = crypto_aead_alg(tfm);\r\nunsigned long alignmask = crypto_aead_alignmask(tfm);\r\nint ret;\r\nu8 *buffer, *alignbuffer;\r\nunsigned long absize;\r\nabsize = keylen + alignmask;\r\nbuffer = kmalloc(absize, GFP_ATOMIC);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nalignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\r\nmemcpy(alignbuffer, key, keylen);\r\nret = aead->setkey(tfm, alignbuffer, keylen);\r\nmemset(alignbuffer, 0, keylen);\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic int setkey(struct crypto_aead *tfm, const u8 *key, unsigned int keylen)\r\n{\r\nstruct aead_alg *aead = crypto_aead_alg(tfm);\r\nunsigned long alignmask = crypto_aead_alignmask(tfm);\r\nif ((unsigned long)key & alignmask)\r\nreturn setkey_unaligned(tfm, key, keylen);\r\nreturn aead->setkey(tfm, key, keylen);\r\n}\r\nint crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)\r\n{\r\nstruct aead_tfm *crt = crypto_aead_crt(tfm);\r\nint err;\r\nif (authsize > crypto_aead_alg(tfm)->maxauthsize)\r\nreturn -EINVAL;\r\nif (crypto_aead_alg(tfm)->setauthsize) {\r\nerr = crypto_aead_alg(tfm)->setauthsize(crt->base, authsize);\r\nif (err)\r\nreturn err;\r\n}\r\ncrypto_aead_crt(crt->base)->authsize = authsize;\r\ncrt->authsize = authsize;\r\nreturn 0;\r\n}\r\nstatic unsigned int crypto_aead_ctxsize(struct crypto_alg *alg, u32 type,\r\nu32 mask)\r\n{\r\nreturn alg->cra_ctxsize;\r\n}\r\nstatic int no_givcrypt(struct aead_givcrypt_request *req)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int crypto_init_aead_ops(struct crypto_tfm *tfm, u32 type, u32 mask)\r\n{\r\nstruct aead_alg *alg = &tfm->__crt_alg->cra_aead;\r\nstruct aead_tfm *crt = &tfm->crt_aead;\r\nif (max(alg->maxauthsize, alg->ivsize) > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\ncrt->setkey = tfm->__crt_alg->cra_flags & CRYPTO_ALG_GENIV ?\r\nalg->setkey : setkey;\r\ncrt->encrypt = alg->encrypt;\r\ncrt->decrypt = alg->decrypt;\r\ncrt->givencrypt = alg->givencrypt ?: no_givcrypt;\r\ncrt->givdecrypt = alg->givdecrypt ?: no_givcrypt;\r\ncrt->base = __crypto_aead_cast(tfm);\r\ncrt->ivsize = alg->ivsize;\r\ncrt->authsize = alg->maxauthsize;\r\nreturn 0;\r\n}\r\nstatic void crypto_aead_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct aead_alg *aead = &alg->cra_aead;\r\nseq_printf(m, "type : aead\n");\r\nseq_printf(m, "async : %s\n", alg->cra_flags & CRYPTO_ALG_ASYNC ?\r\n"yes" : "no");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "ivsize : %u\n", aead->ivsize);\r\nseq_printf(m, "maxauthsize : %u\n", aead->maxauthsize);\r\nseq_printf(m, "geniv : %s\n", aead->geniv ?: "<built-in>");\r\n}\r\nstatic int aead_null_givencrypt(struct aead_givcrypt_request *req)\r\n{\r\nreturn crypto_aead_encrypt(&req->areq);\r\n}\r\nstatic int aead_null_givdecrypt(struct aead_givcrypt_request *req)\r\n{\r\nreturn crypto_aead_decrypt(&req->areq);\r\n}\r\nstatic int crypto_init_nivaead_ops(struct crypto_tfm *tfm, u32 type, u32 mask)\r\n{\r\nstruct aead_alg *alg = &tfm->__crt_alg->cra_aead;\r\nstruct aead_tfm *crt = &tfm->crt_aead;\r\nif (max(alg->maxauthsize, alg->ivsize) > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\ncrt->setkey = setkey;\r\ncrt->encrypt = alg->encrypt;\r\ncrt->decrypt = alg->decrypt;\r\nif (!alg->ivsize) {\r\ncrt->givencrypt = aead_null_givencrypt;\r\ncrt->givdecrypt = aead_null_givdecrypt;\r\n}\r\ncrt->base = __crypto_aead_cast(tfm);\r\ncrt->ivsize = alg->ivsize;\r\ncrt->authsize = alg->maxauthsize;\r\nreturn 0;\r\n}\r\nstatic void crypto_nivaead_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct aead_alg *aead = &alg->cra_aead;\r\nseq_printf(m, "type : nivaead\n");\r\nseq_printf(m, "async : %s\n", alg->cra_flags & CRYPTO_ALG_ASYNC ?\r\n"yes" : "no");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "ivsize : %u\n", aead->ivsize);\r\nseq_printf(m, "maxauthsize : %u\n", aead->maxauthsize);\r\nseq_printf(m, "geniv : %s\n", aead->geniv);\r\n}\r\nstatic int crypto_grab_nivaead(struct crypto_aead_spawn *spawn,\r\nconst char *name, u32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nint err;\r\ntype &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\r\ntype |= CRYPTO_ALG_TYPE_AEAD;\r\nmask |= CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV;\r\nalg = crypto_alg_mod_lookup(name, type, mask);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\nerr = crypto_init_spawn(&spawn->base, alg, spawn->base.inst, mask);\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstruct crypto_instance *aead_geniv_alloc(struct crypto_template *tmpl,\r\nstruct rtattr **tb, u32 type,\r\nu32 mask)\r\n{\r\nconst char *name;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nerr = PTR_ERR(algt);\r\nif (IS_ERR(algt))\r\nreturn ERR_PTR(err);\r\nif ((algt->type ^ (CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_GENIV)) &\r\nalgt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\nname = crypto_attr_alg_name(tb[1]);\r\nerr = PTR_ERR(name);\r\nif (IS_ERR(name))\r\nreturn ERR_PTR(err);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn ERR_PTR(-ENOMEM);\r\nspawn = crypto_instance_ctx(inst);\r\nmask |= crypto_requires_sync(algt->type, algt->mask);\r\ncrypto_set_aead_spawn(spawn, inst);\r\nerr = crypto_grab_nivaead(spawn, name, type, mask);\r\nif (err)\r\ngoto err_free_inst;\r\nalg = crypto_aead_spawn_alg(spawn);\r\nerr = -EINVAL;\r\nif (!alg->cra_aead.ivsize)\r\ngoto err_drop_alg;\r\nif (algt->mask & CRYPTO_ALG_GENIV) {\r\nif (strcmp(tmpl->name, alg->cra_aead.geniv))\r\ngoto err_drop_alg;\r\nmemcpy(inst->alg.cra_name, alg->cra_name, CRYPTO_MAX_ALG_NAME);\r\nmemcpy(inst->alg.cra_driver_name, alg->cra_driver_name,\r\nCRYPTO_MAX_ALG_NAME);\r\n} else {\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"%s(%s)", tmpl->name, alg->cra_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_alg;\r\nif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"%s(%s)", tmpl->name, alg->cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_alg;\r\n}\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_GENIV;\r\ninst->alg.cra_flags |= alg->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.cra_type = &crypto_aead_type;\r\ninst->alg.cra_aead.ivsize = alg->cra_aead.ivsize;\r\ninst->alg.cra_aead.maxauthsize = alg->cra_aead.maxauthsize;\r\ninst->alg.cra_aead.geniv = alg->cra_aead.geniv;\r\ninst->alg.cra_aead.setkey = alg->cra_aead.setkey;\r\ninst->alg.cra_aead.setauthsize = alg->cra_aead.setauthsize;\r\ninst->alg.cra_aead.encrypt = alg->cra_aead.encrypt;\r\ninst->alg.cra_aead.decrypt = alg->cra_aead.decrypt;\r\nout:\r\nreturn inst;\r\nerr_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nerr_free_inst:\r\nkfree(inst);\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nvoid aead_geniv_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_aead(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nint aead_geniv_init(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_aead *aead;\r\naead = crypto_spawn_aead(crypto_instance_ctx(inst));\r\nif (IS_ERR(aead))\r\nreturn PTR_ERR(aead);\r\ntfm->crt_aead.base = aead;\r\ntfm->crt_aead.reqsize += crypto_aead_reqsize(aead);\r\nreturn 0;\r\n}\r\nvoid aead_geniv_exit(struct crypto_tfm *tfm)\r\n{\r\ncrypto_free_aead(tfm->crt_aead.base);\r\n}\r\nstatic int crypto_nivaead_default(struct crypto_alg *alg, u32 type, u32 mask)\r\n{\r\nstruct rtattr *tb[3];\r\nstruct {\r\nstruct rtattr attr;\r\nstruct crypto_attr_type data;\r\n} ptype;\r\nstruct {\r\nstruct rtattr attr;\r\nstruct crypto_attr_alg data;\r\n} palg;\r\nstruct crypto_template *tmpl;\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *larval;\r\nconst char *geniv;\r\nint err;\r\nlarval = crypto_larval_lookup(alg->cra_driver_name,\r\nCRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_GENIV,\r\nCRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\r\nerr = PTR_ERR(larval);\r\nif (IS_ERR(larval))\r\ngoto out;\r\nerr = -EAGAIN;\r\nif (!crypto_is_larval(larval))\r\ngoto drop_larval;\r\nptype.attr.rta_len = sizeof(ptype);\r\nptype.attr.rta_type = CRYPTOA_TYPE;\r\nptype.data.type = type | CRYPTO_ALG_GENIV;\r\nptype.data.mask = mask | CRYPTO_ALG_GENIV;\r\ntb[0] = &ptype.attr;\r\npalg.attr.rta_len = sizeof(palg);\r\npalg.attr.rta_type = CRYPTOA_ALG;\r\nmemcpy(palg.data.name, alg->cra_driver_name, CRYPTO_MAX_ALG_NAME);\r\ntb[1] = &palg.attr;\r\ntb[2] = NULL;\r\ngeniv = alg->cra_aead.geniv;\r\ntmpl = crypto_lookup_template(geniv);\r\nerr = -ENOENT;\r\nif (!tmpl)\r\ngoto kill_larval;\r\ninst = tmpl->alloc(tb);\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto put_tmpl;\r\nif ((err = crypto_register_instance(tmpl, inst))) {\r\ntmpl->free(inst);\r\ngoto put_tmpl;\r\n}\r\nerr = -EAGAIN;\r\nput_tmpl:\r\ncrypto_tmpl_put(tmpl);\r\nkill_larval:\r\ncrypto_larval_kill(larval);\r\ndrop_larval:\r\ncrypto_mod_put(larval);\r\nout:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic struct crypto_alg *crypto_lookup_aead(const char *name, u32 type,\r\nu32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nalg = crypto_alg_mod_lookup(name, type, mask);\r\nif (IS_ERR(alg))\r\nreturn alg;\r\nif (alg->cra_type == &crypto_aead_type)\r\nreturn alg;\r\nif (!alg->cra_aead.ivsize)\r\nreturn alg;\r\ncrypto_mod_put(alg);\r\nalg = crypto_alg_mod_lookup(name, type | CRYPTO_ALG_TESTED,\r\nmask & ~CRYPTO_ALG_TESTED);\r\nif (IS_ERR(alg))\r\nreturn alg;\r\nif (alg->cra_type == &crypto_aead_type) {\r\nif ((alg->cra_flags ^ type ^ ~mask) & CRYPTO_ALG_TESTED) {\r\ncrypto_mod_put(alg);\r\nalg = ERR_PTR(-ENOENT);\r\n}\r\nreturn alg;\r\n}\r\nBUG_ON(!alg->cra_aead.ivsize);\r\nreturn ERR_PTR(crypto_nivaead_default(alg, type, mask));\r\n}\r\nint crypto_grab_aead(struct crypto_aead_spawn *spawn, const char *name,\r\nu32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nint err;\r\ntype &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\r\ntype |= CRYPTO_ALG_TYPE_AEAD;\r\nmask &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\r\nmask |= CRYPTO_ALG_TYPE_MASK;\r\nalg = crypto_lookup_aead(name, type, mask);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\nerr = crypto_init_spawn(&spawn->base, alg, spawn->base.inst, mask);\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstruct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask)\r\n{\r\nstruct crypto_tfm *tfm;\r\nint err;\r\ntype &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\r\ntype |= CRYPTO_ALG_TYPE_AEAD;\r\nmask &= ~(CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_GENIV);\r\nmask |= CRYPTO_ALG_TYPE_MASK;\r\nfor (;;) {\r\nstruct crypto_alg *alg;\r\nalg = crypto_lookup_aead(alg_name, type, mask);\r\nif (IS_ERR(alg)) {\r\nerr = PTR_ERR(alg);\r\ngoto err;\r\n}\r\ntfm = __crypto_alloc_tfm(alg, type, mask);\r\nif (!IS_ERR(tfm))\r\nreturn __crypto_aead_cast(tfm);\r\ncrypto_mod_put(alg);\r\nerr = PTR_ERR(tfm);\r\nerr:\r\nif (err != -EAGAIN)\r\nbreak;\r\nif (signal_pending(current)) {\r\nerr = -EINTR;\r\nbreak;\r\n}\r\n}\r\nreturn ERR_PTR(err);\r\n}
