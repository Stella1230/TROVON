static int doc_ecc_decode(struct rs_control *rs, uint8_t *data, uint8_t *ecc)\r\n{\r\nint i, j, nerr, errpos[8];\r\nuint8_t parity;\r\nuint16_t ds[4], s[5], tmp, errval[8], syn[4];\r\nmemset(syn, 0, sizeof(syn));\r\nds[0] = ((ecc[4] & 0xff) >> 0) | ((ecc[5] & 0x03) << 8);\r\nds[1] = ((ecc[5] & 0xfc) >> 2) | ((ecc[2] & 0x0f) << 6);\r\nds[2] = ((ecc[2] & 0xf0) >> 4) | ((ecc[3] & 0x3f) << 4);\r\nds[3] = ((ecc[3] & 0xc0) >> 6) | ((ecc[0] & 0xff) << 2);\r\nparity = ecc[1];\r\nfor (i = 0; i < NROOTS; i++)\r\ns[i] = ds[0];\r\nfor (j = 1; j < NROOTS; j++) {\r\nif (ds[j] == 0)\r\ncontinue;\r\ntmp = rs->index_of[ds[j]];\r\nfor (i = 0; i < NROOTS; i++)\r\ns[i] ^= rs->alpha_to[rs_modnn(rs, tmp + (FCR + i) * j)];\r\n}\r\nfor (i = 0; i < NROOTS; i++) {\r\nif (s[i])\r\nsyn[i] = rs_modnn(rs, rs->index_of[s[i]] + (NN - FCR - i));\r\n}\r\nnerr = decode_rs16(rs, NULL, NULL, 1019, syn, 0, errpos, 0, errval);\r\nif (nerr < 0)\r\nreturn nerr;\r\nfor (i = 0; i < nerr; i++) {\r\nint index, bitpos, pos = 1015 - errpos[i];\r\nuint8_t val;\r\nif (pos >= NB_DATA && pos < 1019)\r\ncontinue;\r\nif (pos < NB_DATA) {\r\npos = 10 * (NB_DATA - 1 - pos) - 6;\r\nindex = (pos >> 3) ^ 1;\r\nbitpos = pos & 7;\r\nif ((index >= 0 && index < SECTOR_SIZE) || index == (SECTOR_SIZE + 1)) {\r\nval = (uint8_t) (errval[i] >> (2 + bitpos));\r\nparity ^= val;\r\nif (index < SECTOR_SIZE)\r\ndata[index] ^= val;\r\n}\r\nindex = ((pos >> 3) + 1) ^ 1;\r\nbitpos = (bitpos + 10) & 7;\r\nif (bitpos == 0)\r\nbitpos = 8;\r\nif ((index >= 0 && index < SECTOR_SIZE) || index == (SECTOR_SIZE + 1)) {\r\nval = (uint8_t) (errval[i] << (8 - bitpos));\r\nparity ^= val;\r\nif (index < SECTOR_SIZE)\r\ndata[index] ^= val;\r\n}\r\n}\r\n}\r\nreturn parity ? -EBADMSG : nerr;\r\n}\r\nstatic void DoC_Delay(struct doc_priv *doc, unsigned short cycles)\r\n{\r\nvolatile char dummy;\r\nint i;\r\nfor (i = 0; i < cycles; i++) {\r\nif (DoC_is_Millennium(doc))\r\ndummy = ReadDOC(doc->virtadr, NOP);\r\nelse if (DoC_is_MillenniumPlus(doc))\r\ndummy = ReadDOC(doc->virtadr, Mplus_NOP);\r\nelse\r\ndummy = ReadDOC(doc->virtadr, DOCStatus);\r\n}\r\n}\r\nstatic int _DoC_WaitReady(struct doc_priv *doc)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nunsigned long timeo = jiffies + (HZ * 10);\r\nif (debug)\r\nprintk("_DoC_WaitReady...\n");\r\nif (DoC_is_MillenniumPlus(doc)) {\r\nwhile ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK) {\r\nif (time_after(jiffies, timeo)) {\r\nprintk("_DoC_WaitReady timed out.\n");\r\nreturn -EIO;\r\n}\r\nudelay(1);\r\ncond_resched();\r\n}\r\n} else {\r\nwhile (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {\r\nif (time_after(jiffies, timeo)) {\r\nprintk("_DoC_WaitReady timed out.\n");\r\nreturn -EIO;\r\n}\r\nudelay(1);\r\ncond_resched();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int DoC_WaitReady(struct doc_priv *doc)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nint ret = 0;\r\nif (DoC_is_MillenniumPlus(doc)) {\r\nDoC_Delay(doc, 4);\r\nif ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK)\r\nret = _DoC_WaitReady(doc);\r\n} else {\r\nDoC_Delay(doc, 4);\r\nif (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B))\r\nret = _DoC_WaitReady(doc);\r\nDoC_Delay(doc, 2);\r\n}\r\nif (debug)\r\nprintk("DoC_WaitReady OK\n");\r\nreturn ret;\r\n}\r\nstatic void doc2000_write_byte(struct mtd_info *mtd, u_char datum)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nif (debug)\r\nprintk("write_byte %02x\n", datum);\r\nWriteDOC(datum, docptr, CDSNSlowIO);\r\nWriteDOC(datum, docptr, 2k_CDSN_IO);\r\n}\r\nstatic u_char doc2000_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nu_char ret;\r\nReadDOC(docptr, CDSNSlowIO);\r\nDoC_Delay(doc, 2);\r\nret = ReadDOC(docptr, 2k_CDSN_IO);\r\nif (debug)\r\nprintk("read_byte returns %02x\n", ret);\r\nreturn ret;\r\n}\r\nstatic void doc2000_writebuf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nif (debug)\r\nprintk("writebuf of %d bytes: ", len);\r\nfor (i = 0; i < len; i++) {\r\nWriteDOC_(buf[i], docptr, DoC_2k_CDSN_IO + i);\r\nif (debug && i < 16)\r\nprintk("%02x ", buf[i]);\r\n}\r\nif (debug)\r\nprintk("\n");\r\n}\r\nstatic void doc2000_readbuf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nif (debug)\r\nprintk("readbuf of %d bytes: ", len);\r\nfor (i = 0; i < len; i++) {\r\nbuf[i] = ReadDOC(docptr, 2k_CDSN_IO + i);\r\n}\r\n}\r\nstatic void doc2000_readbuf_dword(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nif (debug)\r\nprintk("readbuf_dword of %d bytes: ", len);\r\nif (unlikely((((unsigned long)buf) | len) & 3)) {\r\nfor (i = 0; i < len; i++) {\r\n*(uint8_t *) (&buf[i]) = ReadDOC(docptr, 2k_CDSN_IO + i);\r\n}\r\n} else {\r\nfor (i = 0; i < len; i += 4) {\r\n*(uint32_t *) (&buf[i]) = readl(docptr + DoC_2k_CDSN_IO + i);\r\n}\r\n}\r\n}\r\nstatic int doc2000_verifybuf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (buf[i] != ReadDOC(docptr, 2k_CDSN_IO))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic uint16_t __init doc200x_ident_chip(struct mtd_info *mtd, int nr)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nuint16_t ret;\r\ndoc200x_select_chip(mtd, nr);\r\ndoc200x_hwcontrol(mtd, NAND_CMD_READID,\r\nNAND_CTRL_CLE | NAND_CTRL_CHANGE);\r\ndoc200x_hwcontrol(mtd, 0, NAND_CTRL_ALE | NAND_CTRL_CHANGE);\r\ndoc200x_hwcontrol(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);\r\nudelay(50);\r\nret = this->read_byte(mtd) << 8;\r\nret |= this->read_byte(mtd);\r\nif (doc->ChipID == DOC_ChipID_Doc2k && try_dword && !nr) {\r\nunion {\r\nuint32_t dword;\r\nuint8_t byte[4];\r\n} ident;\r\nvoid __iomem *docptr = doc->virtadr;\r\ndoc200x_hwcontrol(mtd, NAND_CMD_READID,\r\nNAND_CTRL_CLE | NAND_CTRL_CHANGE);\r\ndoc200x_hwcontrol(mtd, 0, NAND_CTRL_ALE | NAND_CTRL_CHANGE);\r\ndoc200x_hwcontrol(mtd, NAND_CMD_NONE,\r\nNAND_NCE | NAND_CTRL_CHANGE);\r\nudelay(50);\r\nident.dword = readl(docptr + DoC_2k_CDSN_IO);\r\nif (((ident.byte[0] << 8) | ident.byte[1]) == ret) {\r\nprintk(KERN_INFO "DiskOnChip 2000 responds to DWORD access\n");\r\nthis->read_buf = &doc2000_readbuf_dword;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __init doc2000_count_chips(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nuint16_t mfrid;\r\nint i;\r\ndoc->chips_per_floor = 4;\r\nmfrid = doc200x_ident_chip(mtd, 0);\r\nfor (i = 1; i < 4; i++) {\r\nif (doc200x_ident_chip(mtd, i) != mfrid)\r\nbreak;\r\n}\r\ndoc->chips_per_floor = i;\r\nprintk(KERN_DEBUG "Detected %d chips per floor.\n", i);\r\n}\r\nstatic int doc200x_wait(struct mtd_info *mtd, struct nand_chip *this)\r\n{\r\nstruct doc_priv *doc = this->priv;\r\nint status;\r\nDoC_WaitReady(doc);\r\nthis->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);\r\nDoC_WaitReady(doc);\r\nstatus = (int)this->read_byte(mtd);\r\nreturn status;\r\n}\r\nstatic void doc2001_write_byte(struct mtd_info *mtd, u_char datum)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nWriteDOC(datum, docptr, CDSNSlowIO);\r\nWriteDOC(datum, docptr, Mil_CDSN_IO);\r\nWriteDOC(datum, docptr, WritePipeTerm);\r\n}\r\nstatic u_char doc2001_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nDoC_Delay(doc, 2);\r\nReadDOC(docptr, ReadPipeInit);\r\nreturn ReadDOC(docptr, LastDataRead);\r\n}\r\nstatic void doc2001_writebuf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nWriteDOC_(buf[i], docptr, DoC_Mil_CDSN_IO + i);\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\n}\r\nstatic void doc2001_readbuf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nReadDOC(docptr, ReadPipeInit);\r\nfor (i = 0; i < len - 1; i++)\r\nbuf[i] = ReadDOC(docptr, Mil_CDSN_IO + (i & 0xff));\r\nbuf[i] = ReadDOC(docptr, LastDataRead);\r\n}\r\nstatic int doc2001_verifybuf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nReadDOC(docptr, ReadPipeInit);\r\nfor (i = 0; i < len - 1; i++)\r\nif (buf[i] != ReadDOC(docptr, Mil_CDSN_IO)) {\r\nReadDOC(docptr, LastDataRead);\r\nreturn i;\r\n}\r\nif (buf[i] != ReadDOC(docptr, LastDataRead))\r\nreturn i;\r\nreturn 0;\r\n}\r\nstatic u_char doc2001plus_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nu_char ret;\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nret = ReadDOC(docptr, Mplus_LastDataRead);\r\nif (debug)\r\nprintk("read_byte returns %02x\n", ret);\r\nreturn ret;\r\n}\r\nstatic void doc2001plus_writebuf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nif (debug)\r\nprintk("writebuf of %d bytes: ", len);\r\nfor (i = 0; i < len; i++) {\r\nWriteDOC_(buf[i], docptr, DoC_Mil_CDSN_IO + i);\r\nif (debug && i < 16)\r\nprintk("%02x ", buf[i]);\r\n}\r\nif (debug)\r\nprintk("\n");\r\n}\r\nstatic void doc2001plus_readbuf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nif (debug)\r\nprintk("readbuf of %d bytes: ", len);\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nfor (i = 0; i < len - 2; i++) {\r\nbuf[i] = ReadDOC(docptr, Mil_CDSN_IO);\r\nif (debug && i < 16)\r\nprintk("%02x ", buf[i]);\r\n}\r\nbuf[len - 2] = ReadDOC(docptr, Mplus_LastDataRead);\r\nif (debug && i < 16)\r\nprintk("%02x ", buf[len - 2]);\r\nbuf[len - 1] = ReadDOC(docptr, Mplus_LastDataRead);\r\nif (debug && i < 16)\r\nprintk("%02x ", buf[len - 1]);\r\nif (debug)\r\nprintk("\n");\r\n}\r\nstatic int doc2001plus_verifybuf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nif (debug)\r\nprintk("verifybuf of %d bytes: ", len);\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nReadDOC(docptr, Mplus_ReadPipeInit);\r\nfor (i = 0; i < len - 2; i++)\r\nif (buf[i] != ReadDOC(docptr, Mil_CDSN_IO)) {\r\nReadDOC(docptr, Mplus_LastDataRead);\r\nReadDOC(docptr, Mplus_LastDataRead);\r\nreturn i;\r\n}\r\nif (buf[len - 2] != ReadDOC(docptr, Mplus_LastDataRead))\r\nreturn len - 2;\r\nif (buf[len - 1] != ReadDOC(docptr, Mplus_LastDataRead))\r\nreturn len - 1;\r\nreturn 0;\r\n}\r\nstatic void doc2001plus_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint floor = 0;\r\nif (debug)\r\nprintk("select chip (%d)\n", chip);\r\nif (chip == -1) {\r\nWriteDOC(0, docptr, Mplus_FlashSelect);\r\nreturn;\r\n}\r\nfloor = chip / doc->chips_per_floor;\r\nchip -= (floor * doc->chips_per_floor);\r\nWriteDOC((DOC_FLASH_CE), docptr, Mplus_FlashSelect);\r\nthis->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\ndoc->curchip = chip;\r\ndoc->curfloor = floor;\r\n}\r\nstatic void doc200x_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint floor = 0;\r\nif (debug)\r\nprintk("select chip (%d)\n", chip);\r\nif (chip == -1)\r\nreturn;\r\nfloor = chip / doc->chips_per_floor;\r\nchip -= (floor * doc->chips_per_floor);\r\ndoc200x_hwcontrol(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);\r\nWriteDOC(floor, docptr, FloorSelect);\r\nWriteDOC(chip, docptr, CDSNDeviceSelect);\r\ndoc200x_hwcontrol(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);\r\ndoc->curchip = chip;\r\ndoc->curfloor = floor;\r\n}\r\nstatic void doc200x_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\ndoc->CDSNControl &= ~CDSN_CTRL_MSK;\r\ndoc->CDSNControl |= ctrl & CDSN_CTRL_MSK;\r\nif (debug)\r\nprintk("hwcontrol(%d): %02x\n", cmd, doc->CDSNControl);\r\nWriteDOC(doc->CDSNControl, docptr, CDSNControl);\r\nDoC_Delay(doc, 4);\r\n}\r\nif (cmd != NAND_CMD_NONE) {\r\nif (DoC_is_2000(doc))\r\ndoc2000_write_byte(mtd, cmd);\r\nelse\r\ndoc2001_write_byte(mtd, cmd);\r\n}\r\n}\r\nstatic void doc2001plus_command(struct mtd_info *mtd, unsigned command, int column, int page_addr)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nif (command == NAND_CMD_PAGEPROG) {\r\nWriteDOC(0x00, docptr, Mplus_WritePipeTerm);\r\nWriteDOC(0x00, docptr, Mplus_WritePipeTerm);\r\n}\r\nif (command == NAND_CMD_SEQIN) {\r\nint readcmd;\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nreadcmd = NAND_CMD_READOOB;\r\n} else if (column < 256) {\r\nreadcmd = NAND_CMD_READ0;\r\n} else {\r\ncolumn -= 256;\r\nreadcmd = NAND_CMD_READ1;\r\n}\r\nWriteDOC(readcmd, docptr, Mplus_FlashCmd);\r\n}\r\nWriteDOC(command, docptr, Mplus_FlashCmd);\r\nWriteDOC(0, docptr, Mplus_WritePipeTerm);\r\nWriteDOC(0, docptr, Mplus_WritePipeTerm);\r\nif (column != -1 || page_addr != -1) {\r\nif (column != -1) {\r\nif (this->options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nWriteDOC(column, docptr, Mplus_FlashAddress);\r\n}\r\nif (page_addr != -1) {\r\nWriteDOC((unsigned char)(page_addr & 0xff), docptr, Mplus_FlashAddress);\r\nWriteDOC((unsigned char)((page_addr >> 8) & 0xff), docptr, Mplus_FlashAddress);\r\nif (this->chipsize & 0x0c000000) {\r\nWriteDOC((unsigned char)((page_addr >> 16) & 0x0f), docptr, Mplus_FlashAddress);\r\nprintk("high density\n");\r\n}\r\n}\r\nWriteDOC(0, docptr, Mplus_WritePipeTerm);\r\nWriteDOC(0, docptr, Mplus_WritePipeTerm);\r\nif (command == NAND_CMD_READ0 || command == NAND_CMD_READ1 ||\r\ncommand == NAND_CMD_READOOB || command == NAND_CMD_READID)\r\nWriteDOC(0, docptr, Mplus_FlashControl);\r\n}\r\nswitch (command) {\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_STATUS:\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nif (this->dev_ready)\r\nbreak;\r\nudelay(this->chip_delay);\r\nWriteDOC(NAND_CMD_STATUS, docptr, Mplus_FlashCmd);\r\nWriteDOC(0, docptr, Mplus_WritePipeTerm);\r\nWriteDOC(0, docptr, Mplus_WritePipeTerm);\r\nwhile (!(this->read_byte(mtd) & 0x40)) ;\r\nreturn;\r\ndefault:\r\nif (!this->dev_ready) {\r\nudelay(this->chip_delay);\r\nreturn;\r\n}\r\n}\r\nndelay(100);\r\nwhile (!this->dev_ready(mtd)) ;\r\n}\r\nstatic int doc200x_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nif (DoC_is_MillenniumPlus(doc)) {\r\nDoC_Delay(doc, 4);\r\nif ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK) {\r\nif (debug)\r\nprintk("not ready\n");\r\nreturn 0;\r\n}\r\nif (debug)\r\nprintk("was ready\n");\r\nreturn 1;\r\n} else {\r\nDoC_Delay(doc, 4);\r\nif (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {\r\nif (debug)\r\nprintk("not ready\n");\r\nreturn 0;\r\n}\r\nDoC_Delay(doc, 2);\r\nif (debug)\r\nprintk("was ready\n");\r\nreturn 1;\r\n}\r\n}\r\nstatic int doc200x_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)\r\n{\r\nreturn 0;\r\n}\r\nstatic void doc200x_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nswitch (mode) {\r\ncase NAND_ECC_READ:\r\nWriteDOC(DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC(DOC_ECC_EN, docptr, ECCConf);\r\nbreak;\r\ncase NAND_ECC_WRITE:\r\nWriteDOC(DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC(DOC_ECC_EN | DOC_ECC_RW, docptr, ECCConf);\r\nbreak;\r\n}\r\n}\r\nstatic void doc2001plus_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nswitch (mode) {\r\ncase NAND_ECC_READ:\r\nWriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);\r\nWriteDOC(DOC_ECC_EN, docptr, Mplus_ECCConf);\r\nbreak;\r\ncase NAND_ECC_WRITE:\r\nWriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);\r\nWriteDOC(DOC_ECC_EN | DOC_ECC_RW, docptr, Mplus_ECCConf);\r\nbreak;\r\n}\r\n}\r\nstatic int doc200x_calculate_ecc(struct mtd_info *mtd, const u_char *dat, unsigned char *ecc_code)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nint emptymatch = 1;\r\nif (DoC_is_2000(doc)) {\r\nWriteDOC(doc->CDSNControl & ~CDSN_CTRL_FLASH_IO, docptr, CDSNControl);\r\nWriteDOC(0, docptr, 2k_CDSN_IO);\r\nWriteDOC(0, docptr, 2k_CDSN_IO);\r\nWriteDOC(0, docptr, 2k_CDSN_IO);\r\nWriteDOC(doc->CDSNControl, docptr, CDSNControl);\r\n} else if (DoC_is_MillenniumPlus(doc)) {\r\nWriteDOC(0, docptr, Mplus_NOP);\r\nWriteDOC(0, docptr, Mplus_NOP);\r\nWriteDOC(0, docptr, Mplus_NOP);\r\n} else {\r\nWriteDOC(0, docptr, NOP);\r\nWriteDOC(0, docptr, NOP);\r\nWriteDOC(0, docptr, NOP);\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nif (DoC_is_MillenniumPlus(doc))\r\necc_code[i] = ReadDOC_(docptr, DoC_Mplus_ECCSyndrome0 + i);\r\nelse\r\necc_code[i] = ReadDOC_(docptr, DoC_ECCSyndrome0 + i);\r\nif (ecc_code[i] != empty_write_ecc[i])\r\nemptymatch = 0;\r\n}\r\nif (DoC_is_MillenniumPlus(doc))\r\nWriteDOC(DOC_ECC_DIS, docptr, Mplus_ECCConf);\r\nelse\r\nWriteDOC(DOC_ECC_DIS, docptr, ECCConf);\r\n#if 0\r\nif (emptymatch) {\r\nfor (i = 0; i < 512; i++) {\r\nif (dat[i] == 0xff)\r\ncontinue;\r\nemptymatch = 0;\r\nbreak;\r\n}\r\n}\r\nif (emptymatch)\r\nmemset(ecc_code, 0xff, 6);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int doc200x_correct_data(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *isnull)\r\n{\r\nint i, ret = 0;\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nuint8_t calc_ecc[6];\r\nvolatile u_char dummy;\r\nint emptymatch = 1;\r\nif (DoC_is_2000(doc)) {\r\ndummy = ReadDOC(docptr, 2k_ECCStatus);\r\ndummy = ReadDOC(docptr, 2k_ECCStatus);\r\ndummy = ReadDOC(docptr, 2k_ECCStatus);\r\n} else if (DoC_is_MillenniumPlus(doc)) {\r\ndummy = ReadDOC(docptr, Mplus_ECCConf);\r\ndummy = ReadDOC(docptr, Mplus_ECCConf);\r\ndummy = ReadDOC(docptr, Mplus_ECCConf);\r\n} else {\r\ndummy = ReadDOC(docptr, ECCConf);\r\ndummy = ReadDOC(docptr, ECCConf);\r\ndummy = ReadDOC(docptr, ECCConf);\r\n}\r\nif (dummy & 0x80) {\r\nfor (i = 0; i < 6; i++) {\r\nif (DoC_is_MillenniumPlus(doc))\r\ncalc_ecc[i] = ReadDOC_(docptr, DoC_Mplus_ECCSyndrome0 + i);\r\nelse\r\ncalc_ecc[i] = ReadDOC_(docptr, DoC_ECCSyndrome0 + i);\r\nif (calc_ecc[i] != empty_read_syndrome[i])\r\nemptymatch = 0;\r\n}\r\nif (emptymatch) {\r\nfor (i = 0; i < 6; i++) {\r\nif (read_ecc[i] == 0xff)\r\ncontinue;\r\nemptymatch = 0;\r\nbreak;\r\n}\r\n}\r\nif (emptymatch) {\r\nfor (i = 0; i < 512; i++) {\r\nif (dat[i] == 0xff)\r\ncontinue;\r\nemptymatch = 0;\r\nbreak;\r\n}\r\n}\r\nif (!emptymatch)\r\nret = doc_ecc_decode(rs_decoder, dat, calc_ecc);\r\nif (ret > 0)\r\nprintk(KERN_ERR "doc200x_correct_data corrected %d errors\n", ret);\r\n}\r\nif (DoC_is_MillenniumPlus(doc))\r\nWriteDOC(DOC_ECC_DIS, docptr, Mplus_ECCConf);\r\nelse\r\nWriteDOC(DOC_ECC_DIS, docptr, ECCConf);\r\nif (no_ecc_failures && (ret == -EBADMSG)) {\r\nprintk(KERN_ERR "suppressing ECC failure\n");\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init find_media_headers(struct mtd_info *mtd, u_char *buf, const char *id, int findmirror)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nunsigned offs;\r\nint ret;\r\nsize_t retlen;\r\nfor (offs = 0; offs < mtd->size; offs += mtd->erasesize) {\r\nret = mtd->read(mtd, offs, mtd->writesize, &retlen, buf);\r\nif (retlen != mtd->writesize)\r\ncontinue;\r\nif (ret) {\r\nprintk(KERN_WARNING "ECC error scanning DOC at 0x%x\n", offs);\r\n}\r\nif (memcmp(buf, id, 6))\r\ncontinue;\r\nprintk(KERN_INFO "Found DiskOnChip %s Media Header at 0x%x\n", id, offs);\r\nif (doc->mh0_page == -1) {\r\ndoc->mh0_page = offs >> this->page_shift;\r\nif (!findmirror)\r\nreturn 1;\r\ncontinue;\r\n}\r\ndoc->mh1_page = offs >> this->page_shift;\r\nreturn 2;\r\n}\r\nif (doc->mh0_page == -1) {\r\nprintk(KERN_WARNING "DiskOnChip %s Media Header not found.\n", id);\r\nreturn 0;\r\n}\r\noffs = doc->mh0_page << this->page_shift;\r\nret = mtd->read(mtd, offs, mtd->writesize, &retlen, buf);\r\nif (retlen != mtd->writesize) {\r\nprintk(KERN_ERR "Read DiskOnChip Media Header once, but can't reread it???\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline int __init nftl_partscan(struct mtd_info *mtd, struct mtd_partition *parts)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nint ret = 0;\r\nu_char *buf;\r\nstruct NFTLMediaHeader *mh;\r\nconst unsigned psize = 1 << this->page_shift;\r\nint numparts = 0;\r\nunsigned blocks, maxblocks;\r\nint offs, numheaders;\r\nbuf = kmalloc(mtd->writesize, GFP_KERNEL);\r\nif (!buf) {\r\nprintk(KERN_ERR "DiskOnChip mediaheader kmalloc failed!\n");\r\nreturn 0;\r\n}\r\nif (!(numheaders = find_media_headers(mtd, buf, "ANAND", 1)))\r\ngoto out;\r\nmh = (struct NFTLMediaHeader *)buf;\r\nle16_to_cpus(&mh->NumEraseUnits);\r\nle16_to_cpus(&mh->FirstPhysicalEUN);\r\nle32_to_cpus(&mh->FormattedSize);\r\nprintk(KERN_INFO " DataOrgID = %s\n"\r\n" NumEraseUnits = %d\n"\r\n" FirstPhysicalEUN = %d\n"\r\n" FormattedSize = %d\n"\r\n" UnitSizeFactor = %d\n",\r\nmh->DataOrgID, mh->NumEraseUnits,\r\nmh->FirstPhysicalEUN, mh->FormattedSize,\r\nmh->UnitSizeFactor);\r\nblocks = mtd->size >> this->phys_erase_shift;\r\nmaxblocks = min(32768U, mtd->erasesize - psize);\r\nif (mh->UnitSizeFactor == 0x00) {\r\nmh->UnitSizeFactor = 0xff;\r\nwhile (blocks > maxblocks) {\r\nblocks >>= 1;\r\nmaxblocks = min(32768U, (maxblocks << 1) + psize);\r\nmh->UnitSizeFactor--;\r\n}\r\nprintk(KERN_WARNING "UnitSizeFactor=0x00 detected. Correct value is assumed to be 0x%02x.\n", mh->UnitSizeFactor);\r\n}\r\nif (mh->UnitSizeFactor != 0xff) {\r\nthis->bbt_erase_shift += (0xff - mh->UnitSizeFactor);\r\nmtd->erasesize <<= (0xff - mh->UnitSizeFactor);\r\nprintk(KERN_INFO "Setting virtual erase size to %d\n", mtd->erasesize);\r\nblocks = mtd->size >> this->bbt_erase_shift;\r\nmaxblocks = min(32768U, mtd->erasesize - psize);\r\n}\r\nif (blocks > maxblocks) {\r\nprintk(KERN_ERR "UnitSizeFactor of 0x%02x is inconsistent with device size. Aborting.\n", mh->UnitSizeFactor);\r\ngoto out;\r\n}\r\noffs = max(doc->mh0_page, doc->mh1_page);\r\noffs <<= this->page_shift;\r\noffs += mtd->erasesize;\r\nif (show_firmware_partition == 1) {\r\nparts[0].name = " DiskOnChip Firmware / Media Header partition";\r\nparts[0].offset = 0;\r\nparts[0].size = offs;\r\nnumparts = 1;\r\n}\r\nparts[numparts].name = " DiskOnChip BDTL partition";\r\nparts[numparts].offset = offs;\r\nparts[numparts].size = (mh->NumEraseUnits - numheaders) << this->bbt_erase_shift;\r\noffs += parts[numparts].size;\r\nnumparts++;\r\nif (offs < mtd->size) {\r\nparts[numparts].name = " DiskOnChip Remainder partition";\r\nparts[numparts].offset = offs;\r\nparts[numparts].size = mtd->size - offs;\r\nnumparts++;\r\n}\r\nret = numparts;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic inline int __init inftl_partscan(struct mtd_info *mtd, struct mtd_partition *parts)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nint ret = 0;\r\nu_char *buf;\r\nstruct INFTLMediaHeader *mh;\r\nstruct INFTLPartition *ip;\r\nint numparts = 0;\r\nint blocks;\r\nint vshift, lastvunit = 0;\r\nint i;\r\nint end = mtd->size;\r\nif (inftl_bbt_write)\r\nend -= (INFTL_BBT_RESERVED_BLOCKS << this->phys_erase_shift);\r\nbuf = kmalloc(mtd->writesize, GFP_KERNEL);\r\nif (!buf) {\r\nprintk(KERN_ERR "DiskOnChip mediaheader kmalloc failed!\n");\r\nreturn 0;\r\n}\r\nif (!find_media_headers(mtd, buf, "BNAND", 0))\r\ngoto out;\r\ndoc->mh1_page = doc->mh0_page + (4096 >> this->page_shift);\r\nmh = (struct INFTLMediaHeader *)buf;\r\nle32_to_cpus(&mh->NoOfBootImageBlocks);\r\nle32_to_cpus(&mh->NoOfBinaryPartitions);\r\nle32_to_cpus(&mh->NoOfBDTLPartitions);\r\nle32_to_cpus(&mh->BlockMultiplierBits);\r\nle32_to_cpus(&mh->FormatFlags);\r\nle32_to_cpus(&mh->PercentUsed);\r\nprintk(KERN_INFO " bootRecordID = %s\n"\r\n" NoOfBootImageBlocks = %d\n"\r\n" NoOfBinaryPartitions = %d\n"\r\n" NoOfBDTLPartitions = %d\n"\r\n" BlockMultiplerBits = %d\n"\r\n" FormatFlgs = %d\n"\r\n" OsakVersion = %d.%d.%d.%d\n"\r\n" PercentUsed = %d\n",\r\nmh->bootRecordID, mh->NoOfBootImageBlocks,\r\nmh->NoOfBinaryPartitions,\r\nmh->NoOfBDTLPartitions,\r\nmh->BlockMultiplierBits, mh->FormatFlags,\r\n((unsigned char *) &mh->OsakVersion)[0] & 0xf,\r\n((unsigned char *) &mh->OsakVersion)[1] & 0xf,\r\n((unsigned char *) &mh->OsakVersion)[2] & 0xf,\r\n((unsigned char *) &mh->OsakVersion)[3] & 0xf,\r\nmh->PercentUsed);\r\nvshift = this->phys_erase_shift + mh->BlockMultiplierBits;\r\nblocks = mtd->size >> vshift;\r\nif (blocks > 32768) {\r\nprintk(KERN_ERR "BlockMultiplierBits=%d is inconsistent with device size. Aborting.\n", mh->BlockMultiplierBits);\r\ngoto out;\r\n}\r\nblocks = doc->chips_per_floor << (this->chip_shift - this->phys_erase_shift);\r\nif (inftl_bbt_write && (blocks > mtd->erasesize)) {\r\nprintk(KERN_ERR "Writeable BBTs spanning more than one erase block are not yet supported. FIX ME!\n");\r\ngoto out;\r\n}\r\nfor (i = 0; (i < 4); i++) {\r\nip = &(mh->Partitions[i]);\r\nle32_to_cpus(&ip->virtualUnits);\r\nle32_to_cpus(&ip->firstUnit);\r\nle32_to_cpus(&ip->lastUnit);\r\nle32_to_cpus(&ip->flags);\r\nle32_to_cpus(&ip->spareUnits);\r\nle32_to_cpus(&ip->Reserved0);\r\nprintk(KERN_INFO " PARTITION[%d] ->\n"\r\n" virtualUnits = %d\n"\r\n" firstUnit = %d\n"\r\n" lastUnit = %d\n"\r\n" flags = 0x%x\n"\r\n" spareUnits = %d\n",\r\ni, ip->virtualUnits, ip->firstUnit,\r\nip->lastUnit, ip->flags,\r\nip->spareUnits);\r\nif ((show_firmware_partition == 1) &&\r\n(i == 0) && (ip->firstUnit > 0)) {\r\nparts[0].name = " DiskOnChip IPL / Media Header partition";\r\nparts[0].offset = 0;\r\nparts[0].size = mtd->erasesize * ip->firstUnit;\r\nnumparts = 1;\r\n}\r\nif (ip->flags & INFTL_BINARY)\r\nparts[numparts].name = " DiskOnChip BDK partition";\r\nelse\r\nparts[numparts].name = " DiskOnChip BDTL partition";\r\nparts[numparts].offset = ip->firstUnit << vshift;\r\nparts[numparts].size = (1 + ip->lastUnit - ip->firstUnit) << vshift;\r\nnumparts++;\r\nif (ip->lastUnit > lastvunit)\r\nlastvunit = ip->lastUnit;\r\nif (ip->flags & INFTL_LAST)\r\nbreak;\r\n}\r\nlastvunit++;\r\nif ((lastvunit << vshift) < end) {\r\nparts[numparts].name = " DiskOnChip Remainder partition";\r\nparts[numparts].offset = lastvunit << vshift;\r\nparts[numparts].size = end - parts[numparts].offset;\r\nnumparts++;\r\n}\r\nret = numparts;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int __init nftl_scan_bbt(struct mtd_info *mtd)\r\n{\r\nint ret, numparts;\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nstruct mtd_partition parts[2];\r\nmemset((char *)parts, 0, sizeof(parts));\r\nnumparts = nftl_partscan(mtd, parts);\r\nif (!numparts)\r\nreturn -EIO;\r\nthis->bbt_td->options = NAND_BBT_ABSPAGE | NAND_BBT_8BIT |\r\nNAND_BBT_SAVECONTENT | NAND_BBT_WRITE |\r\nNAND_BBT_VERSION;\r\nthis->bbt_td->veroffs = 7;\r\nthis->bbt_td->pages[0] = doc->mh0_page + 1;\r\nif (doc->mh1_page != -1) {\r\nthis->bbt_md->options = NAND_BBT_ABSPAGE | NAND_BBT_8BIT |\r\nNAND_BBT_SAVECONTENT | NAND_BBT_WRITE |\r\nNAND_BBT_VERSION;\r\nthis->bbt_md->veroffs = 7;\r\nthis->bbt_md->pages[0] = doc->mh1_page + 1;\r\n} else {\r\nthis->bbt_md = NULL;\r\n}\r\nif ((ret = nand_scan_bbt(mtd, NULL)))\r\nreturn ret;\r\nmtd_device_register(mtd, NULL, 0);\r\nif (!no_autopart)\r\nmtd_device_register(mtd, parts, numparts);\r\nreturn 0;\r\n}\r\nstatic int __init inftl_scan_bbt(struct mtd_info *mtd)\r\n{\r\nint ret, numparts;\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nstruct mtd_partition parts[5];\r\nif (this->numchips > doc->chips_per_floor) {\r\nprintk(KERN_ERR "Multi-floor INFTL devices not yet supported.\n");\r\nreturn -EIO;\r\n}\r\nif (DoC_is_MillenniumPlus(doc)) {\r\nthis->bbt_td->options = NAND_BBT_2BIT | NAND_BBT_ABSPAGE;\r\nif (inftl_bbt_write)\r\nthis->bbt_td->options |= NAND_BBT_WRITE;\r\nthis->bbt_td->pages[0] = 2;\r\nthis->bbt_md = NULL;\r\n} else {\r\nthis->bbt_td->options = NAND_BBT_LASTBLOCK | NAND_BBT_8BIT | NAND_BBT_VERSION;\r\nif (inftl_bbt_write)\r\nthis->bbt_td->options |= NAND_BBT_WRITE;\r\nthis->bbt_td->offs = 8;\r\nthis->bbt_td->len = 8;\r\nthis->bbt_td->veroffs = 7;\r\nthis->bbt_td->maxblocks = INFTL_BBT_RESERVED_BLOCKS;\r\nthis->bbt_td->reserved_block_code = 0x01;\r\nthis->bbt_td->pattern = "MSYS_BBT";\r\nthis->bbt_md->options = NAND_BBT_LASTBLOCK | NAND_BBT_8BIT | NAND_BBT_VERSION;\r\nif (inftl_bbt_write)\r\nthis->bbt_md->options |= NAND_BBT_WRITE;\r\nthis->bbt_md->offs = 8;\r\nthis->bbt_md->len = 8;\r\nthis->bbt_md->veroffs = 7;\r\nthis->bbt_md->maxblocks = INFTL_BBT_RESERVED_BLOCKS;\r\nthis->bbt_md->reserved_block_code = 0x01;\r\nthis->bbt_md->pattern = "TBB_SYSM";\r\n}\r\nif ((ret = nand_scan_bbt(mtd, NULL)))\r\nreturn ret;\r\nmemset((char *)parts, 0, sizeof(parts));\r\nnumparts = inftl_partscan(mtd, parts);\r\nif (!numparts)\r\nreturn -EIO;\r\nmtd_device_register(mtd, NULL, 0);\r\nif (!no_autopart)\r\nmtd_device_register(mtd, parts, numparts);\r\nreturn 0;\r\n}\r\nstatic inline int __init doc2000_init(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nthis->read_byte = doc2000_read_byte;\r\nthis->write_buf = doc2000_writebuf;\r\nthis->read_buf = doc2000_readbuf;\r\nthis->verify_buf = doc2000_verifybuf;\r\nthis->scan_bbt = nftl_scan_bbt;\r\ndoc->CDSNControl = CDSN_CTRL_FLASH_IO | CDSN_CTRL_ECC_IO;\r\ndoc2000_count_chips(mtd);\r\nmtd->name = "DiskOnChip 2000 (NFTL Model)";\r\nreturn (4 * doc->chips_per_floor);\r\n}\r\nstatic inline int __init doc2001_init(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nthis->read_byte = doc2001_read_byte;\r\nthis->write_buf = doc2001_writebuf;\r\nthis->read_buf = doc2001_readbuf;\r\nthis->verify_buf = doc2001_verifybuf;\r\nReadDOC(doc->virtadr, ChipID);\r\nReadDOC(doc->virtadr, ChipID);\r\nReadDOC(doc->virtadr, ChipID);\r\nif (ReadDOC(doc->virtadr, ChipID) != DOC_ChipID_DocMil) {\r\ndoc2000_count_chips(mtd);\r\nmtd->name = "DiskOnChip 2000 (INFTL Model)";\r\nthis->scan_bbt = inftl_scan_bbt;\r\nreturn (4 * doc->chips_per_floor);\r\n} else {\r\ndoc->chips_per_floor = 1;\r\nmtd->name = "DiskOnChip Millennium";\r\nthis->scan_bbt = nftl_scan_bbt;\r\nreturn 1;\r\n}\r\n}\r\nstatic inline int __init doc2001plus_init(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct doc_priv *doc = this->priv;\r\nthis->read_byte = doc2001plus_read_byte;\r\nthis->write_buf = doc2001plus_writebuf;\r\nthis->read_buf = doc2001plus_readbuf;\r\nthis->verify_buf = doc2001plus_verifybuf;\r\nthis->scan_bbt = inftl_scan_bbt;\r\nthis->cmd_ctrl = NULL;\r\nthis->select_chip = doc2001plus_select_chip;\r\nthis->cmdfunc = doc2001plus_command;\r\nthis->ecc.hwctl = doc2001plus_enable_hwecc;\r\ndoc->chips_per_floor = 1;\r\nmtd->name = "DiskOnChip Millennium Plus";\r\nreturn 1;\r\n}\r\nstatic int __init doc_probe(unsigned long physadr)\r\n{\r\nunsigned char ChipID;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand;\r\nstruct doc_priv *doc;\r\nvoid __iomem *virtadr;\r\nunsigned char save_control;\r\nunsigned char tmp, tmpb, tmpc;\r\nint reg, len, numchips;\r\nint ret = 0;\r\nvirtadr = ioremap(physadr, DOC_IOREMAP_LEN);\r\nif (!virtadr) {\r\nprintk(KERN_ERR "Diskonchip ioremap failed: 0x%x bytes at 0x%lx\n", DOC_IOREMAP_LEN, physadr);\r\nreturn -EIO;\r\n}\r\nsave_control = ReadDOC(virtadr, DOCControl);\r\nWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET, virtadr, DOCControl);\r\nWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET, virtadr, DOCControl);\r\nWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL, virtadr, DOCControl);\r\nWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL, virtadr, DOCControl);\r\nChipID = ReadDOC(virtadr, ChipID);\r\nswitch (ChipID) {\r\ncase DOC_ChipID_Doc2k:\r\nreg = DoC_2k_ECCStatus;\r\nbreak;\r\ncase DOC_ChipID_DocMil:\r\nreg = DoC_ECCConf;\r\nbreak;\r\ncase DOC_ChipID_DocMilPlus16:\r\ncase DOC_ChipID_DocMilPlus32:\r\ncase 0:\r\nfor (tmp = 0; (tmp < 4); tmp++)\r\nReadDOC(virtadr, Mplus_Power);\r\ntmp = DOC_MODE_RESET | DOC_MODE_MDWREN | DOC_MODE_RST_LAT | DOC_MODE_BDECT;\r\nWriteDOC(tmp, virtadr, Mplus_DOCControl);\r\nWriteDOC(~tmp, virtadr, Mplus_CtrlConfirm);\r\nmdelay(1);\r\ntmp = DOC_MODE_NORMAL | DOC_MODE_MDWREN | DOC_MODE_RST_LAT | DOC_MODE_BDECT;\r\nWriteDOC(tmp, virtadr, Mplus_DOCControl);\r\nWriteDOC(~tmp, virtadr, Mplus_CtrlConfirm);\r\nmdelay(1);\r\nChipID = ReadDOC(virtadr, ChipID);\r\nswitch (ChipID) {\r\ncase DOC_ChipID_DocMilPlus16:\r\nreg = DoC_Mplus_Toggle;\r\nbreak;\r\ncase DOC_ChipID_DocMilPlus32:\r\nprintk(KERN_ERR "DiskOnChip Millennium Plus 32MB is not supported, ignoring.\n");\r\ndefault:\r\nret = -ENODEV;\r\ngoto notfound;\r\n}\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\ngoto notfound;\r\n}\r\ntmp = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;\r\ntmpb = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;\r\ntmpc = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;\r\nif ((tmp == tmpb) || (tmp != tmpc)) {\r\nprintk(KERN_WARNING "Possible DiskOnChip at 0x%lx failed TOGGLE test, dropping.\n", physadr);\r\nret = -ENODEV;\r\ngoto notfound;\r\n}\r\nfor (mtd = doclist; mtd; mtd = doc->nextdoc) {\r\nunsigned char oldval;\r\nunsigned char newval;\r\nnand = mtd->priv;\r\ndoc = nand->priv;\r\nif (ChipID == DOC_ChipID_DocMilPlus16) {\r\noldval = ReadDOC(doc->virtadr, Mplus_AliasResolution);\r\nnewval = ReadDOC(virtadr, Mplus_AliasResolution);\r\n} else {\r\noldval = ReadDOC(doc->virtadr, AliasResolution);\r\nnewval = ReadDOC(virtadr, AliasResolution);\r\n}\r\nif (oldval != newval)\r\ncontinue;\r\nif (ChipID == DOC_ChipID_DocMilPlus16) {\r\nWriteDOC(~newval, virtadr, Mplus_AliasResolution);\r\noldval = ReadDOC(doc->virtadr, Mplus_AliasResolution);\r\nWriteDOC(newval, virtadr, Mplus_AliasResolution);\r\n} else {\r\nWriteDOC(~newval, virtadr, AliasResolution);\r\noldval = ReadDOC(doc->virtadr, AliasResolution);\r\nWriteDOC(newval, virtadr, AliasResolution);\r\n}\r\nnewval = ~newval;\r\nif (oldval == newval) {\r\nprintk(KERN_DEBUG "Found alias of DOC at 0x%lx to 0x%lx\n", doc->physadr, physadr);\r\ngoto notfound;\r\n}\r\n}\r\nprintk(KERN_NOTICE "DiskOnChip found at 0x%lx\n", physadr);\r\nlen = sizeof(struct mtd_info) +\r\nsizeof(struct nand_chip) + sizeof(struct doc_priv) + (2 * sizeof(struct nand_bbt_descr));\r\nmtd = kzalloc(len, GFP_KERNEL);\r\nif (!mtd) {\r\nprintk(KERN_ERR "DiskOnChip kmalloc (%d bytes) failed!\n", len);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nnand = (struct nand_chip *) (mtd + 1);\r\ndoc = (struct doc_priv *) (nand + 1);\r\nnand->bbt_td = (struct nand_bbt_descr *) (doc + 1);\r\nnand->bbt_md = nand->bbt_td + 1;\r\nmtd->priv = nand;\r\nmtd->owner = THIS_MODULE;\r\nnand->priv = doc;\r\nnand->select_chip = doc200x_select_chip;\r\nnand->cmd_ctrl = doc200x_hwcontrol;\r\nnand->dev_ready = doc200x_dev_ready;\r\nnand->waitfunc = doc200x_wait;\r\nnand->block_bad = doc200x_block_bad;\r\nnand->ecc.hwctl = doc200x_enable_hwecc;\r\nnand->ecc.calculate = doc200x_calculate_ecc;\r\nnand->ecc.correct = doc200x_correct_data;\r\nnand->ecc.layout = &doc200x_oobinfo;\r\nnand->ecc.mode = NAND_ECC_HW_SYNDROME;\r\nnand->ecc.size = 512;\r\nnand->ecc.bytes = 6;\r\nnand->options = NAND_USE_FLASH_BBT;\r\ndoc->physadr = physadr;\r\ndoc->virtadr = virtadr;\r\ndoc->ChipID = ChipID;\r\ndoc->curfloor = -1;\r\ndoc->curchip = -1;\r\ndoc->mh0_page = -1;\r\ndoc->mh1_page = -1;\r\ndoc->nextdoc = doclist;\r\nif (ChipID == DOC_ChipID_Doc2k)\r\nnumchips = doc2000_init(mtd);\r\nelse if (ChipID == DOC_ChipID_DocMilPlus16)\r\nnumchips = doc2001plus_init(mtd);\r\nelse\r\nnumchips = doc2001_init(mtd);\r\nif ((ret = nand_scan(mtd, numchips))) {\r\nnand_release(mtd);\r\nkfree(mtd);\r\ngoto fail;\r\n}\r\ndoclist = mtd;\r\nreturn 0;\r\nnotfound:\r\nWriteDOC(save_control, virtadr, DOCControl);\r\nfail:\r\niounmap(virtadr);\r\nreturn ret;\r\n}\r\nstatic void release_nanddoc(void)\r\n{\r\nstruct mtd_info *mtd, *nextmtd;\r\nstruct nand_chip *nand;\r\nstruct doc_priv *doc;\r\nfor (mtd = doclist; mtd; mtd = nextmtd) {\r\nnand = mtd->priv;\r\ndoc = nand->priv;\r\nnextmtd = doc->nextdoc;\r\nnand_release(mtd);\r\niounmap(doc->virtadr);\r\nkfree(mtd);\r\n}\r\n}\r\nstatic int __init init_nanddoc(void)\r\n{\r\nint i, ret = 0;\r\nrs_decoder = init_rs(10, 0x409, FCR, 1, NROOTS);\r\nif (!rs_decoder) {\r\nprintk(KERN_ERR "DiskOnChip: Could not create a RS decoder\n");\r\nreturn -ENOMEM;\r\n}\r\nif (doc_config_location) {\r\nprintk(KERN_INFO "Using configured DiskOnChip probe address 0x%lx\n", doc_config_location);\r\nret = doc_probe(doc_config_location);\r\nif (ret < 0)\r\ngoto outerr;\r\n} else {\r\nfor (i = 0; (doc_locations[i] != 0xffffffff); i++) {\r\ndoc_probe(doc_locations[i]);\r\n}\r\n}\r\nif (!doclist) {\r\nprintk(KERN_INFO "No valid DiskOnChip devices found\n");\r\nret = -ENODEV;\r\ngoto outerr;\r\n}\r\nreturn 0;\r\nouterr:\r\nfree_rs(rs_decoder);\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_nanddoc(void)\r\n{\r\nrelease_nanddoc();\r\nif (rs_decoder) {\r\nfree_rs(rs_decoder);\r\n}\r\n}
