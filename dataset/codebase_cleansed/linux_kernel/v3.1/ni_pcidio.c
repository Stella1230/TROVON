static inline unsigned primary_DMAChannel_bits(unsigned channel)\r\n{\r\nreturn channel & 0x3;\r\n}\r\nstatic inline unsigned secondary_DMAChannel_bits(unsigned channel)\r\n{\r\nreturn (channel << 2) & 0xc;\r\n}\r\nstatic int ni_pcidio_request_di_mite_channel(struct comedi_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nBUG_ON(devpriv->di_mite_chan);\r\ndevpriv->di_mite_chan =\r\nmite_request_channel_in_range(devpriv->mite,\r\ndevpriv->di_mite_ring, 1, 2);\r\nif (devpriv->di_mite_chan == NULL) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ncomedi_error(dev, "failed to reserve mite dma channel.");\r\nreturn -EBUSY;\r\n}\r\nwriteb(primary_DMAChannel_bits(devpriv->di_mite_chan->channel) |\r\nsecondary_DMAChannel_bits(devpriv->di_mite_chan->channel),\r\ndevpriv->mite->daq_io_addr + DMA_Line_Control_Group1);\r\nmmiowb();\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ni_pcidio_release_di_mite_channel(struct comedi_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->di_mite_chan) {\r\nmite_dma_disarm(devpriv->di_mite_chan);\r\nmite_dma_reset(devpriv->di_mite_chan);\r\nmite_release_channel(devpriv->di_mite_chan);\r\ndevpriv->di_mite_chan = NULL;\r\nwriteb(primary_DMAChannel_bits(0) |\r\nsecondary_DMAChannel_bits(0),\r\ndevpriv->mite->daq_io_addr + DMA_Line_Control_Group1);\r\nmmiowb();\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n}\r\nstatic int nidio96_8255_cb(int dir, int port, int data, unsigned long iobase)\r\n{\r\nif (dir) {\r\nwriteb(data, (void *)(iobase + port));\r\nreturn 0;\r\n} else {\r\nreturn readb((void *)(iobase + port));\r\n}\r\n}\r\nvoid ni_pcidio_event(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nif (s->\r\nasync->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |\r\nCOMEDI_CB_OVERFLOW)) {\r\nni_pcidio_cancel(dev, s);\r\n}\r\ncomedi_event(dev, s);\r\n}\r\nstatic irqreturn_t nidio_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->subdevices;\r\nstruct comedi_async *async = s->async;\r\nstruct mite_struct *mite = devpriv->mite;\r\nlong int AuxData = 0;\r\nshort data1 = 0;\r\nshort data2 = 0;\r\nint flags;\r\nint status;\r\nint work = 0;\r\nunsigned int m_status = 0;\r\nunsigned long irq_flags;\r\nif (dev->attached == 0) {\r\nreturn IRQ_NONE;\r\n}\r\nstatus = readb(devpriv->mite->daq_io_addr +\r\nInterrupt_And_Window_Status);\r\nflags = readb(devpriv->mite->daq_io_addr + Group_1_Flags);\r\nDPRINTK("ni_pcidio_interrupt: status=0x%02x,flags=0x%02x\n",\r\nstatus, flags);\r\nni_pcidio_print_flags(flags);\r\nni_pcidio_print_status(status);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, irq_flags);\r\nif (devpriv->di_mite_chan)\r\nm_status = mite_get_status(devpriv->di_mite_chan);\r\n#ifdef MITE_DEBUG\r\nmite_print_chsr(m_status);\r\n#endif\r\nif (m_status & CHSR_INT) {\r\nif (m_status & CHSR_LINKC) {\r\nwritel(CHOR_CLRLC,\r\nmite->mite_io_addr +\r\nMITE_CHOR(devpriv->di_mite_chan->channel));\r\nmite_sync_input_dma(devpriv->di_mite_chan, s->async);\r\n}\r\nif (m_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_DRDY |\r\nCHSR_DRQ1 | CHSR_MRDY)) {\r\nDPRINTK("unknown mite interrupt, disabling IRQ\n");\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ndisable_irq(dev->irq);\r\n}\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, irq_flags);\r\nwhile (status & DataLeft) {\r\nwork++;\r\nif (work > 20) {\r\nDPRINTK("too much work in interrupt\n");\r\nwriteb(0x00,\r\ndevpriv->mite->daq_io_addr +\r\nMaster_DMA_And_Interrupt_Control);\r\nbreak;\r\n}\r\nflags &= IntEn;\r\nif (flags & TransferReady) {\r\nwhile (flags & TransferReady) {\r\nwork++;\r\nif (work > 100) {\r\nDPRINTK("too much work in interrupt\n");\r\nwriteb(0x00,\r\ndevpriv->mite->daq_io_addr +\r\nMaster_DMA_And_Interrupt_Control\r\n);\r\ngoto out;\r\n}\r\nAuxData =\r\nreadl(devpriv->mite->daq_io_addr +\r\nGroup_1_FIFO);\r\ndata1 = AuxData & 0xffff;\r\ndata2 = (AuxData & 0xffff0000) >> 16;\r\ncomedi_buf_put(async, data1);\r\ncomedi_buf_put(async, data2);\r\nflags = readb(devpriv->mite->daq_io_addr +\r\nGroup_1_Flags);\r\n}\r\nasync->events |= COMEDI_CB_BLOCK;\r\n}\r\nif (flags & CountExpired) {\r\nDPRINTK("CountExpired\n");\r\nwriteb(ClearExpired,\r\ndevpriv->mite->daq_io_addr +\r\nGroup_1_Second_Clear);\r\nasync->events |= COMEDI_CB_EOA;\r\nwriteb(0x00, devpriv->mite->daq_io_addr + OpMode);\r\nbreak;\r\n} else if (flags & Waited) {\r\nDPRINTK("Waited\n");\r\nwriteb(ClearWaited,\r\ndevpriv->mite->daq_io_addr +\r\nGroup_1_First_Clear);\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\nbreak;\r\n} else if (flags & PrimaryTC) {\r\nDPRINTK("PrimaryTC\n");\r\nwriteb(ClearPrimaryTC,\r\ndevpriv->mite->daq_io_addr +\r\nGroup_1_First_Clear);\r\nasync->events |= COMEDI_CB_EOA;\r\n} else if (flags & SecondaryTC) {\r\nDPRINTK("SecondaryTC\n");\r\nwriteb(ClearSecondaryTC,\r\ndevpriv->mite->daq_io_addr +\r\nGroup_1_First_Clear);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n#if 0\r\nelse {\r\nprintk("ni_pcidio: unknown interrupt\n");\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\nwriteb(0x00,\r\ndevpriv->mite->daq_io_addr +\r\nMaster_DMA_And_Interrupt_Control);\r\n}\r\n#endif\r\nflags = readb(devpriv->mite->daq_io_addr + Group_1_Flags);\r\nstatus = readb(devpriv->mite->daq_io_addr +\r\nInterrupt_And_Window_Status);\r\n}\r\nout:\r\nni_pcidio_event(dev, s);\r\n#if 0\r\nif (!tag) {\r\nwriteb(0x03,\r\ndevpriv->mite->daq_io_addr +\r\nMaster_DMA_And_Interrupt_Control);\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ni_pcidio_print_flags(unsigned int flags)\r\n{\r\nint i;\r\nprintk(KERN_INFO "group_1_flags:");\r\nfor (i = 7; i >= 0; i--) {\r\nif (flags & (1 << i))\r\nprintk(" %s", flags_strings[i]);\r\n}\r\nprintk("\n");\r\n}\r\nstatic void ni_pcidio_print_status(unsigned int flags)\r\n{\r\nint i;\r\nprintk(KERN_INFO "group_status:");\r\nfor (i = 7; i >= 0; i--) {\r\nif (flags & (1 << i))\r\nprintk(" %s", status_strings[i]);\r\n}\r\nprintk("\n");\r\n}\r\nstatic void debug_int(struct comedi_device *dev)\r\n{\r\nint a, b;\r\nstatic int n_int = 0;\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\na = readb(devpriv->mite->daq_io_addr + Group_Status);\r\nb = readb(devpriv->mite->daq_io_addr + Group_1_Flags);\r\nif (n_int < 10) {\r\nDPRINTK("status 0x%02x flags 0x%02x time %06d\n", a, b,\r\n(int)tv.tv_usec);\r\n}\r\nwhile (b & 1) {\r\nwritew(0xff, devpriv->mite->daq_io_addr + Group_1_FIFO);\r\nb = readb(devpriv->mite->daq_io_addr + Group_1_Flags);\r\n}\r\nb = readb(devpriv->mite->daq_io_addr + Group_1_Flags);\r\nif (n_int < 10) {\r\nDPRINTK("new status 0x%02x\n", b);\r\nn_int++;\r\n}\r\n}\r\nstatic int ni_pcidio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (insn->n != 1)\r\nreturn -EINVAL;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= 1 << CR_CHAN(insn->chanspec);\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits &= ~(1 << CR_CHAN(insn->chanspec));\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->\r\nio_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :\r\nCOMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(s->io_bits, devpriv->mite->daq_io_addr + Port_Pin_Directions(0));\r\nreturn 1;\r\n}\r\nstatic int ni_pcidio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nwritel(s->state, devpriv->mite->daq_io_addr + Port_IO(0));\r\n}\r\ndata[1] = readl(devpriv->mite->daq_io_addr + Port_IO(0));\r\nreturn 2;\r\n}\r\nstatic int ni_pcidio_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_INT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_INT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\n#define MAX_SPEED (TIMER_BASE)\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg < MAX_SPEED) {\r\ncmd->scan_begin_arg = MAX_SPEED;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_arg != 0) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\nni_pcidio_ns_to_timer(&cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int ni_pcidio_ns_to_timer(int *nanosec, int round_mode)\r\n{\r\nint divider, base;\r\nbase = TIMER_BASE;\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\ndivider = (*nanosec + base / 2) / base;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndivider = (*nanosec + base - 1) / base;\r\nbreak;\r\n}\r\n*nanosec = base * divider;\r\nreturn divider;\r\n}\r\nstatic int ni_pcidio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nwritel(0x0000, devpriv->mite->daq_io_addr + Port_Pin_Directions(0));\r\nif (1) {\r\nwriteb(0x0f, devpriv->mite->daq_io_addr + Data_Path);\r\nwriteb(TransferWidth(0) | TransferLength(0),\r\ndevpriv->mite->daq_io_addr + Transfer_Size_Control);\r\n} else {\r\nwriteb(0x03, devpriv->mite->daq_io_addr + Data_Path);\r\nwriteb(TransferWidth(3) | TransferLength(0),\r\ndevpriv->mite->daq_io_addr + Transfer_Size_Control);\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nwriteb(0, devpriv->mite->daq_io_addr + OpMode);\r\nwriteb(0x00, devpriv->mite->daq_io_addr + ClockReg);\r\nwriteb(1, devpriv->mite->daq_io_addr + Sequence);\r\nwriteb(0x04, devpriv->mite->daq_io_addr + ReqReg);\r\nwriteb(4, devpriv->mite->daq_io_addr + BlockMode);\r\nwriteb(3, devpriv->mite->daq_io_addr + LinePolarities);\r\nwriteb(0xc0, devpriv->mite->daq_io_addr + AckSer);\r\nwritel(ni_pcidio_ns_to_timer(&cmd->scan_begin_arg,\r\nTRIG_ROUND_NEAREST),\r\ndevpriv->mite->daq_io_addr + StartDelay);\r\nwriteb(1, devpriv->mite->daq_io_addr + ReqDelay);\r\nwriteb(1, devpriv->mite->daq_io_addr + ReqNotDelay);\r\nwriteb(1, devpriv->mite->daq_io_addr + AckDelay);\r\nwriteb(0x0b, devpriv->mite->daq_io_addr + AckNotDelay);\r\nwriteb(0x01, devpriv->mite->daq_io_addr + Data1Delay);\r\nwritew(0, devpriv->mite->daq_io_addr + ClockSpeed);\r\nwriteb(0, devpriv->mite->daq_io_addr + DAQOptions);\r\n} else {\r\nwriteb(0, devpriv->mite->daq_io_addr + OpMode);\r\nwriteb(0x00, devpriv->mite->daq_io_addr + ClockReg);\r\nwriteb(0, devpriv->mite->daq_io_addr + Sequence);\r\nwriteb(0x00, devpriv->mite->daq_io_addr + ReqReg);\r\nwriteb(4, devpriv->mite->daq_io_addr + BlockMode);\r\nwriteb(0, devpriv->mite->daq_io_addr + LinePolarities);\r\nwriteb(0x00, devpriv->mite->daq_io_addr + AckSer);\r\nwritel(1, devpriv->mite->daq_io_addr + StartDelay);\r\nwriteb(1, devpriv->mite->daq_io_addr + ReqDelay);\r\nwriteb(1, devpriv->mite->daq_io_addr + ReqNotDelay);\r\nwriteb(1, devpriv->mite->daq_io_addr + AckDelay);\r\nwriteb(0x0C, devpriv->mite->daq_io_addr + AckNotDelay);\r\nwriteb(0x10, devpriv->mite->daq_io_addr + Data1Delay);\r\nwritew(0, devpriv->mite->daq_io_addr + ClockSpeed);\r\nwriteb(0x60, devpriv->mite->daq_io_addr + DAQOptions);\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nwritel(cmd->stop_arg,\r\ndevpriv->mite->daq_io_addr + Transfer_Count);\r\n} else {\r\n}\r\n#ifdef USE_DMA\r\nwriteb(ClearPrimaryTC | ClearSecondaryTC,\r\ndevpriv->mite->daq_io_addr + Group_1_First_Clear);\r\n{\r\nint retval = setup_mite_dma(dev, s);\r\nif (retval)\r\nreturn retval;\r\n}\r\n#else\r\nwriteb(0x00, devpriv->mite->daq_io_addr + DMA_Line_Control_Group1);\r\n#endif\r\nwriteb(0x00, devpriv->mite->daq_io_addr + DMA_Line_Control_Group2);\r\nwriteb(0xff, devpriv->mite->daq_io_addr + Group_1_First_Clear);\r\nwriteb(IntEn, devpriv->mite->daq_io_addr + Interrupt_Control);\r\nwriteb(0x03,\r\ndevpriv->mite->daq_io_addr + Master_DMA_And_Interrupt_Control);\r\nif (cmd->stop_src == TRIG_NONE) {\r\ndevpriv->OpModeBits = DataLatching(0) | RunMode(7);\r\n} else {\r\ndevpriv->OpModeBits = Numbered | RunMode(7);\r\n}\r\nif (cmd->start_src == TRIG_NOW) {\r\nwriteb(devpriv->OpModeBits,\r\ndevpriv->mite->daq_io_addr + OpMode);\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = ni_pcidio_inttrig;\r\n}\r\nDPRINTK("ni_pcidio: command started\n");\r\nreturn 0;\r\n}\r\nstatic int setup_mite_dma(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint retval;\r\nretval = ni_pcidio_request_di_mite_channel(dev);\r\nif (retval)\r\nreturn retval;\r\ndevpriv->di_mite_chan->dir = COMEDI_INPUT;\r\nmite_prep_dma(devpriv->di_mite_chan, 32, 32);\r\nmite_dma_arm(devpriv->di_mite_chan);\r\nreturn 0;\r\n}\r\nstatic int ni_pcidio_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int trignum)\r\n{\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\nwriteb(devpriv->OpModeBits, devpriv->mite->daq_io_addr + OpMode);\r\ns->async->inttrig = NULL;\r\nreturn 1;\r\n}\r\nstatic int ni_pcidio_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nwriteb(0x00,\r\ndevpriv->mite->daq_io_addr + Master_DMA_And_Interrupt_Control);\r\nni_pcidio_release_di_mite_channel(dev);\r\nreturn 0;\r\n}\r\nstatic int ni_pcidio_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned long new_size)\r\n{\r\nint ret;\r\nret = mite_buf_change(devpriv->di_mite_ring, s->async);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(s->async->prealloc_buf, 0xaa, s->async->prealloc_bufsz);\r\nreturn 0;\r\n}\r\nstatic int pci_6534_load_fpga(struct comedi_device *dev, int fpga_index,\r\nu8 *data, int data_len)\r\n{\r\nstatic const int timeout = 1000;\r\nint i, j;\r\nwritew(0x80 | fpga_index,\r\ndevpriv->mite->daq_io_addr + Firmware_Control_Register);\r\nwritew(0xc0 | fpga_index,\r\ndevpriv->mite->daq_io_addr + Firmware_Control_Register);\r\nfor (i = 0;\r\n(readw(devpriv->mite->daq_io_addr +\r\nFirmware_Status_Register) & 0x2) == 0 && i < timeout; ++i) {\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\nprintk(KERN_WARNING "ni_pcidio: failed to load fpga %i, "\r\n"waiting for status 0x2\n", fpga_index);\r\nreturn -EIO;\r\n}\r\nwritew(0x80 | fpga_index,\r\ndevpriv->mite->daq_io_addr + Firmware_Control_Register);\r\nfor (i = 0;\r\nreadw(devpriv->mite->daq_io_addr + Firmware_Status_Register) !=\r\n0x3 && i < timeout; ++i) {\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\nprintk(KERN_WARNING "ni_pcidio: failed to load fpga %i, "\r\n"waiting for status 0x3\n", fpga_index);\r\nreturn -EIO;\r\n}\r\nfor (j = 0; j + 1 < data_len;) {\r\nunsigned int value = data[j++];\r\nvalue |= data[j++] << 8;\r\nwritew(value,\r\ndevpriv->mite->daq_io_addr + Firmware_Data_Register);\r\nfor (i = 0;\r\n(readw(devpriv->mite->daq_io_addr +\r\nFirmware_Status_Register) & 0x2) == 0\r\n&& i < timeout; ++i) {\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\nprintk("ni_pcidio: failed to load word into fpga %i\n",\r\nfpga_index);\r\nreturn -EIO;\r\n}\r\nif (need_resched())\r\nschedule();\r\n}\r\nwritew(0x0, devpriv->mite->daq_io_addr + Firmware_Control_Register);\r\nreturn 0;\r\n}\r\nstatic int pci_6534_reset_fpga(struct comedi_device *dev, int fpga_index)\r\n{\r\nreturn pci_6534_load_fpga(dev, fpga_index, NULL, 0);\r\n}\r\nstatic int pci_6534_reset_fpgas(struct comedi_device *dev)\r\n{\r\nint ret;\r\nint i;\r\nwritew(0x0, devpriv->mite->daq_io_addr + Firmware_Control_Register);\r\nfor (i = 0; i < 3; ++i) {\r\nret = pci_6534_reset_fpga(dev, i);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nwritew(0x0, devpriv->mite->daq_io_addr + Firmware_Mask_Register);\r\nreturn ret;\r\n}\r\nstatic void pci_6534_init_main_fpga(struct comedi_device *dev)\r\n{\r\nwritel(0, devpriv->mite->daq_io_addr + FPGA_Control1_Register);\r\nwritel(0, devpriv->mite->daq_io_addr + FPGA_Control2_Register);\r\nwritel(0, devpriv->mite->daq_io_addr + FPGA_SCALS_Counter_Register);\r\nwritel(0, devpriv->mite->daq_io_addr + FPGA_SCAMS_Counter_Register);\r\nwritel(0, devpriv->mite->daq_io_addr + FPGA_SCBLS_Counter_Register);\r\nwritel(0, devpriv->mite->daq_io_addr + FPGA_SCBMS_Counter_Register);\r\n}\r\nstatic int pci_6534_upload_firmware(struct comedi_device *dev, int options[])\r\n{\r\nint ret;\r\nvoid *main_fpga_data, *scarab_a_data, *scarab_b_data;\r\nint main_fpga_data_len, scarab_a_data_len, scarab_b_data_len;\r\nif (options[COMEDI_DEVCONF_AUX_DATA_LENGTH] == 0)\r\nreturn 0;\r\nret = pci_6534_reset_fpgas(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nmain_fpga_data = comedi_aux_data(options, 0);\r\nmain_fpga_data_len = options[COMEDI_DEVCONF_AUX_DATA0_LENGTH];\r\nret = pci_6534_load_fpga(dev, 2, main_fpga_data, main_fpga_data_len);\r\nif (ret < 0)\r\nreturn ret;\r\npci_6534_init_main_fpga(dev);\r\nscarab_a_data = comedi_aux_data(options, 1);\r\nscarab_a_data_len = options[COMEDI_DEVCONF_AUX_DATA1_LENGTH];\r\nret = pci_6534_load_fpga(dev, 0, scarab_a_data, scarab_a_data_len);\r\nif (ret < 0)\r\nreturn ret;\r\nscarab_b_data = comedi_aux_data(options, 2);\r\nscarab_b_data_len = options[COMEDI_DEVCONF_AUX_DATA2_LENGTH];\r\nret = pci_6534_load_fpga(dev, 1, scarab_b_data, scarab_b_data_len);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int nidio_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint i;\r\nint ret;\r\nint n_subdevices;\r\nunsigned int irq;\r\nprintk(KERN_INFO "comedi%d: nidio:", dev->minor);\r\nret = alloc_private(dev, sizeof(struct nidio96_private));\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_init(&devpriv->mite_channel_lock);\r\nret = nidio_find_device(dev, it->options[0], it->options[1]);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mite_setup(devpriv->mite);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "error setting up mite\n");\r\nreturn ret;\r\n}\r\ncomedi_set_hw_dev(dev, &devpriv->mite->pcidev->dev);\r\ndevpriv->di_mite_ring = mite_alloc_ring(devpriv->mite);\r\nif (devpriv->di_mite_ring == NULL)\r\nreturn -ENOMEM;\r\ndev->board_name = this_board->name;\r\nirq = mite_irq(devpriv->mite);\r\nprintk(KERN_INFO " %s", dev->board_name);\r\nif (this_board->uses_firmware) {\r\nret = pci_6534_upload_firmware(dev, it->options);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!this_board->is_diodaq)\r\nn_subdevices = this_board->n_8255;\r\nelse\r\nn_subdevices = 1;\r\nret = alloc_subdevices(dev, n_subdevices);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!this_board->is_diodaq) {\r\nfor (i = 0; i < this_board->n_8255; i++) {\r\nsubdev_8255_init(dev, dev->subdevices + i,\r\nnidio96_8255_cb,\r\n(unsigned long)(devpriv->mite->\r\ndaq_io_addr +\r\nNIDIO_8255_BASE(i)));\r\n}\r\n} else {\r\nprintk(KERN_INFO " rev=%d",\r\nreadb(devpriv->mite->daq_io_addr + Chip_Version));\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags =\r\nSDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_PACKED |\r\nSDF_CMD_READ;\r\ns->n_chan = 32;\r\ns->range_table = &range_digital;\r\ns->maxdata = 1;\r\ns->insn_config = &ni_pcidio_insn_config;\r\ns->insn_bits = &ni_pcidio_insn_bits;\r\ns->do_cmd = &ni_pcidio_cmd;\r\ns->do_cmdtest = &ni_pcidio_cmdtest;\r\ns->cancel = &ni_pcidio_cancel;\r\ns->len_chanlist = 32;\r\ns->buf_change = &ni_pcidio_change;\r\ns->async_dma_dir = DMA_BIDIRECTIONAL;\r\nwritel(0, devpriv->mite->daq_io_addr + Port_IO(0));\r\nwritel(0, devpriv->mite->daq_io_addr + Port_Pin_Directions(0));\r\nwritel(0, devpriv->mite->daq_io_addr + Port_Pin_Mask(0));\r\nwriteb(0x00,\r\ndevpriv->mite->daq_io_addr +\r\nMaster_DMA_And_Interrupt_Control);\r\nret = request_irq(irq, nidio_interrupt, IRQF_SHARED,\r\n"ni_pcidio", dev);\r\nif (ret < 0)\r\nprintk(KERN_WARNING " irq not available");\r\ndev->irq = irq;\r\n}\r\nprintk("\n");\r\nreturn 0;\r\n}\r\nstatic int nidio_detach(struct comedi_device *dev)\r\n{\r\nint i;\r\nif (this_board && !this_board->is_diodaq) {\r\nfor (i = 0; i < this_board->n_8255; i++)\r\nsubdev_8255_cleanup(dev, dev->subdevices + i);\r\n}\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->di_mite_ring) {\r\nmite_free_ring(devpriv->di_mite_ring);\r\ndevpriv->di_mite_ring = NULL;\r\n}\r\nif (devpriv->mite)\r\nmite_unsetup(devpriv->mite);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nidio_find_device(struct comedi_device *dev, int bus, int slot)\r\n{\r\nstruct mite_struct *mite;\r\nint i;\r\nfor (mite = mite_devices; mite; mite = mite->next) {\r\nif (mite->used)\r\ncontinue;\r\nif (bus || slot) {\r\nif (bus != mite->pcidev->bus->number ||\r\nslot != PCI_SLOT(mite->pcidev->devfn))\r\ncontinue;\r\n}\r\nfor (i = 0; i < n_nidio_boards; i++) {\r\nif (mite_device_id(mite) == nidio_boards[i].dev_id) {\r\ndev->board_ptr = nidio_boards + i;\r\ndevpriv->mite = mite;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nprintk(KERN_WARNING "no device found\n");\r\nmite_list_devices();\r\nreturn -EIO;\r\n}\r\nstatic int __devinit driver_pcidio_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_pcidio.driver_name);\r\n}\r\nstatic void __devexit driver_pcidio_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_pcidio_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_pcidio);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_pcidio_pci_driver.name = (char *)driver_pcidio.driver_name;\r\nreturn pci_register_driver(&driver_pcidio_pci_driver);\r\n}\r\nstatic void __exit driver_pcidio_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_pcidio_pci_driver);\r\ncomedi_driver_unregister(&driver_pcidio);\r\n}
