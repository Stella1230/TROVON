static void init_uobj(struct ib_uobject *uobj, u64 user_handle,\r\nstruct ib_ucontext *context, struct lock_class_key *key)\r\n{\r\nuobj->user_handle = user_handle;\r\nuobj->context = context;\r\nkref_init(&uobj->ref);\r\ninit_rwsem(&uobj->mutex);\r\nlockdep_set_class(&uobj->mutex, key);\r\nuobj->live = 0;\r\n}\r\nstatic void release_uobj(struct kref *kref)\r\n{\r\nkfree(container_of(kref, struct ib_uobject, ref));\r\n}\r\nstatic void put_uobj(struct ib_uobject *uobj)\r\n{\r\nkref_put(&uobj->ref, release_uobj);\r\n}\r\nstatic void put_uobj_read(struct ib_uobject *uobj)\r\n{\r\nup_read(&uobj->mutex);\r\nput_uobj(uobj);\r\n}\r\nstatic void put_uobj_write(struct ib_uobject *uobj)\r\n{\r\nup_write(&uobj->mutex);\r\nput_uobj(uobj);\r\n}\r\nstatic int idr_add_uobj(struct idr *idr, struct ib_uobject *uobj)\r\n{\r\nint ret;\r\nretry:\r\nif (!idr_pre_get(idr, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nspin_lock(&ib_uverbs_idr_lock);\r\nret = idr_get_new(idr, uobj, &uobj->id);\r\nspin_unlock(&ib_uverbs_idr_lock);\r\nif (ret == -EAGAIN)\r\ngoto retry;\r\nreturn ret;\r\n}\r\nvoid idr_remove_uobj(struct idr *idr, struct ib_uobject *uobj)\r\n{\r\nspin_lock(&ib_uverbs_idr_lock);\r\nidr_remove(idr, uobj->id);\r\nspin_unlock(&ib_uverbs_idr_lock);\r\n}\r\nstatic struct ib_uobject *__idr_get_uobj(struct idr *idr, int id,\r\nstruct ib_ucontext *context)\r\n{\r\nstruct ib_uobject *uobj;\r\nspin_lock(&ib_uverbs_idr_lock);\r\nuobj = idr_find(idr, id);\r\nif (uobj) {\r\nif (uobj->context == context)\r\nkref_get(&uobj->ref);\r\nelse\r\nuobj = NULL;\r\n}\r\nspin_unlock(&ib_uverbs_idr_lock);\r\nreturn uobj;\r\n}\r\nstatic struct ib_uobject *idr_read_uobj(struct idr *idr, int id,\r\nstruct ib_ucontext *context, int nested)\r\n{\r\nstruct ib_uobject *uobj;\r\nuobj = __idr_get_uobj(idr, id, context);\r\nif (!uobj)\r\nreturn NULL;\r\nif (nested)\r\ndown_read_nested(&uobj->mutex, SINGLE_DEPTH_NESTING);\r\nelse\r\ndown_read(&uobj->mutex);\r\nif (!uobj->live) {\r\nput_uobj_read(uobj);\r\nreturn NULL;\r\n}\r\nreturn uobj;\r\n}\r\nstatic struct ib_uobject *idr_write_uobj(struct idr *idr, int id,\r\nstruct ib_ucontext *context)\r\n{\r\nstruct ib_uobject *uobj;\r\nuobj = __idr_get_uobj(idr, id, context);\r\nif (!uobj)\r\nreturn NULL;\r\ndown_write(&uobj->mutex);\r\nif (!uobj->live) {\r\nput_uobj_write(uobj);\r\nreturn NULL;\r\n}\r\nreturn uobj;\r\n}\r\nstatic void *idr_read_obj(struct idr *idr, int id, struct ib_ucontext *context,\r\nint nested)\r\n{\r\nstruct ib_uobject *uobj;\r\nuobj = idr_read_uobj(idr, id, context, nested);\r\nreturn uobj ? uobj->object : NULL;\r\n}\r\nstatic struct ib_pd *idr_read_pd(int pd_handle, struct ib_ucontext *context)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_pd_idr, pd_handle, context, 0);\r\n}\r\nstatic void put_pd_read(struct ib_pd *pd)\r\n{\r\nput_uobj_read(pd->uobject);\r\n}\r\nstatic struct ib_cq *idr_read_cq(int cq_handle, struct ib_ucontext *context, int nested)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_cq_idr, cq_handle, context, nested);\r\n}\r\nstatic void put_cq_read(struct ib_cq *cq)\r\n{\r\nput_uobj_read(cq->uobject);\r\n}\r\nstatic struct ib_ah *idr_read_ah(int ah_handle, struct ib_ucontext *context)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_ah_idr, ah_handle, context, 0);\r\n}\r\nstatic void put_ah_read(struct ib_ah *ah)\r\n{\r\nput_uobj_read(ah->uobject);\r\n}\r\nstatic struct ib_qp *idr_read_qp(int qp_handle, struct ib_ucontext *context)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_qp_idr, qp_handle, context, 0);\r\n}\r\nstatic void put_qp_read(struct ib_qp *qp)\r\n{\r\nput_uobj_read(qp->uobject);\r\n}\r\nstatic struct ib_srq *idr_read_srq(int srq_handle, struct ib_ucontext *context)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_srq_idr, srq_handle, context, 0);\r\n}\r\nstatic void put_srq_read(struct ib_srq *srq)\r\n{\r\nput_uobj_read(srq->uobject);\r\n}\r\nssize_t ib_uverbs_get_context(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_get_context cmd;\r\nstruct ib_uverbs_get_context_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_device *ibdev = file->device->ib_dev;\r\nstruct ib_ucontext *ucontext;\r\nstruct file *filp;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nmutex_lock(&file->mutex);\r\nif (file->ucontext) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nucontext = ibdev->alloc_ucontext(ibdev, &udata);\r\nif (IS_ERR(ucontext)) {\r\nret = PTR_ERR(ucontext);\r\ngoto err;\r\n}\r\nucontext->device = ibdev;\r\nINIT_LIST_HEAD(&ucontext->pd_list);\r\nINIT_LIST_HEAD(&ucontext->mr_list);\r\nINIT_LIST_HEAD(&ucontext->mw_list);\r\nINIT_LIST_HEAD(&ucontext->cq_list);\r\nINIT_LIST_HEAD(&ucontext->qp_list);\r\nINIT_LIST_HEAD(&ucontext->srq_list);\r\nINIT_LIST_HEAD(&ucontext->ah_list);\r\nucontext->closing = 0;\r\nresp.num_comp_vectors = file->device->num_comp_vectors;\r\nret = get_unused_fd();\r\nif (ret < 0)\r\ngoto err_free;\r\nresp.async_fd = ret;\r\nfilp = ib_uverbs_alloc_event_file(file, 1);\r\nif (IS_ERR(filp)) {\r\nret = PTR_ERR(filp);\r\ngoto err_fd;\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_file;\r\n}\r\nfile->async_file = filp->private_data;\r\nINIT_IB_EVENT_HANDLER(&file->event_handler, file->device->ib_dev,\r\nib_uverbs_event_handler);\r\nret = ib_register_event_handler(&file->event_handler);\r\nif (ret)\r\ngoto err_file;\r\nkref_get(&file->async_file->ref);\r\nkref_get(&file->ref);\r\nfile->ucontext = ucontext;\r\nfd_install(resp.async_fd, filp);\r\nmutex_unlock(&file->mutex);\r\nreturn in_len;\r\nerr_file:\r\nfput(filp);\r\nerr_fd:\r\nput_unused_fd(resp.async_fd);\r\nerr_free:\r\nibdev->dealloc_ucontext(ucontext);\r\nerr:\r\nmutex_unlock(&file->mutex);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_query_device(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_query_device cmd;\r\nstruct ib_uverbs_query_device_resp resp;\r\nstruct ib_device_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nret = ib_query_device(file->device->ib_dev, &attr);\r\nif (ret)\r\nreturn ret;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.fw_ver = attr.fw_ver;\r\nresp.node_guid = file->device->ib_dev->node_guid;\r\nresp.sys_image_guid = attr.sys_image_guid;\r\nresp.max_mr_size = attr.max_mr_size;\r\nresp.page_size_cap = attr.page_size_cap;\r\nresp.vendor_id = attr.vendor_id;\r\nresp.vendor_part_id = attr.vendor_part_id;\r\nresp.hw_ver = attr.hw_ver;\r\nresp.max_qp = attr.max_qp;\r\nresp.max_qp_wr = attr.max_qp_wr;\r\nresp.device_cap_flags = attr.device_cap_flags;\r\nresp.max_sge = attr.max_sge;\r\nresp.max_sge_rd = attr.max_sge_rd;\r\nresp.max_cq = attr.max_cq;\r\nresp.max_cqe = attr.max_cqe;\r\nresp.max_mr = attr.max_mr;\r\nresp.max_pd = attr.max_pd;\r\nresp.max_qp_rd_atom = attr.max_qp_rd_atom;\r\nresp.max_ee_rd_atom = attr.max_ee_rd_atom;\r\nresp.max_res_rd_atom = attr.max_res_rd_atom;\r\nresp.max_qp_init_rd_atom = attr.max_qp_init_rd_atom;\r\nresp.max_ee_init_rd_atom = attr.max_ee_init_rd_atom;\r\nresp.atomic_cap = attr.atomic_cap;\r\nresp.max_ee = attr.max_ee;\r\nresp.max_rdd = attr.max_rdd;\r\nresp.max_mw = attr.max_mw;\r\nresp.max_raw_ipv6_qp = attr.max_raw_ipv6_qp;\r\nresp.max_raw_ethy_qp = attr.max_raw_ethy_qp;\r\nresp.max_mcast_grp = attr.max_mcast_grp;\r\nresp.max_mcast_qp_attach = attr.max_mcast_qp_attach;\r\nresp.max_total_mcast_qp_attach = attr.max_total_mcast_qp_attach;\r\nresp.max_ah = attr.max_ah;\r\nresp.max_fmr = attr.max_fmr;\r\nresp.max_map_per_fmr = attr.max_map_per_fmr;\r\nresp.max_srq = attr.max_srq;\r\nresp.max_srq_wr = attr.max_srq_wr;\r\nresp.max_srq_sge = attr.max_srq_sge;\r\nresp.max_pkeys = attr.max_pkeys;\r\nresp.local_ca_ack_delay = attr.local_ca_ack_delay;\r\nresp.phys_port_cnt = file->device->ib_dev->phys_port_cnt;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_query_port(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_query_port cmd;\r\nstruct ib_uverbs_query_port_resp resp;\r\nstruct ib_port_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nret = ib_query_port(file->device->ib_dev, cmd.port_num, &attr);\r\nif (ret)\r\nreturn ret;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.state = attr.state;\r\nresp.max_mtu = attr.max_mtu;\r\nresp.active_mtu = attr.active_mtu;\r\nresp.gid_tbl_len = attr.gid_tbl_len;\r\nresp.port_cap_flags = attr.port_cap_flags;\r\nresp.max_msg_sz = attr.max_msg_sz;\r\nresp.bad_pkey_cntr = attr.bad_pkey_cntr;\r\nresp.qkey_viol_cntr = attr.qkey_viol_cntr;\r\nresp.pkey_tbl_len = attr.pkey_tbl_len;\r\nresp.lid = attr.lid;\r\nresp.sm_lid = attr.sm_lid;\r\nresp.lmc = attr.lmc;\r\nresp.max_vl_num = attr.max_vl_num;\r\nresp.sm_sl = attr.sm_sl;\r\nresp.subnet_timeout = attr.subnet_timeout;\r\nresp.init_type_reply = attr.init_type_reply;\r\nresp.active_width = attr.active_width;\r\nresp.active_speed = attr.active_speed;\r\nresp.phys_state = attr.phys_state;\r\nresp.link_layer = rdma_port_get_link_layer(file->device->ib_dev,\r\ncmd.port_num);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_alloc_pd(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_alloc_pd cmd;\r\nstruct ib_uverbs_alloc_pd_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uobject *uobj;\r\nstruct ib_pd *pd;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nuobj = kmalloc(sizeof *uobj, GFP_KERNEL);\r\nif (!uobj)\r\nreturn -ENOMEM;\r\ninit_uobj(uobj, 0, file->ucontext, &pd_lock_key);\r\ndown_write(&uobj->mutex);\r\npd = file->device->ib_dev->alloc_pd(file->device->ib_dev,\r\nfile->ucontext, &udata);\r\nif (IS_ERR(pd)) {\r\nret = PTR_ERR(pd);\r\ngoto err;\r\n}\r\npd->device = file->device->ib_dev;\r\npd->uobject = uobj;\r\natomic_set(&pd->usecnt, 0);\r\nuobj->object = pd;\r\nret = idr_add_uobj(&ib_uverbs_pd_idr, uobj);\r\nif (ret)\r\ngoto err_idr;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.pd_handle = uobj->id;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&uobj->list, &file->ucontext->pd_list);\r\nmutex_unlock(&file->mutex);\r\nuobj->live = 1;\r\nup_write(&uobj->mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_pd_idr, uobj);\r\nerr_idr:\r\nib_dealloc_pd(pd);\r\nerr:\r\nput_uobj_write(uobj);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_dealloc_pd(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_dealloc_pd cmd;\r\nstruct ib_uobject *uobj;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_pd_idr, cmd.pd_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nret = ib_dealloc_pd(uobj->object);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_pd_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_reg_mr(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_reg_mr cmd;\r\nstruct ib_uverbs_reg_mr_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uobject *uobj;\r\nstruct ib_pd *pd;\r\nstruct ib_mr *mr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nif ((cmd.start & ~PAGE_MASK) != (cmd.hca_va & ~PAGE_MASK))\r\nreturn -EINVAL;\r\nif (cmd.access_flags & (IB_ACCESS_REMOTE_ATOMIC | IB_ACCESS_REMOTE_WRITE) &&\r\n!(cmd.access_flags & IB_ACCESS_LOCAL_WRITE))\r\nreturn -EINVAL;\r\nuobj = kmalloc(sizeof *uobj, GFP_KERNEL);\r\nif (!uobj)\r\nreturn -ENOMEM;\r\ninit_uobj(uobj, 0, file->ucontext, &mr_lock_key);\r\ndown_write(&uobj->mutex);\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nmr = pd->device->reg_user_mr(pd, cmd.start, cmd.length, cmd.hca_va,\r\ncmd.access_flags, &udata);\r\nif (IS_ERR(mr)) {\r\nret = PTR_ERR(mr);\r\ngoto err_put;\r\n}\r\nmr->device = pd->device;\r\nmr->pd = pd;\r\nmr->uobject = uobj;\r\natomic_inc(&pd->usecnt);\r\natomic_set(&mr->usecnt, 0);\r\nuobj->object = mr;\r\nret = idr_add_uobj(&ib_uverbs_mr_idr, uobj);\r\nif (ret)\r\ngoto err_unreg;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.lkey = mr->lkey;\r\nresp.rkey = mr->rkey;\r\nresp.mr_handle = uobj->id;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nput_pd_read(pd);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&uobj->list, &file->ucontext->mr_list);\r\nmutex_unlock(&file->mutex);\r\nuobj->live = 1;\r\nup_write(&uobj->mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_mr_idr, uobj);\r\nerr_unreg:\r\nib_dereg_mr(mr);\r\nerr_put:\r\nput_pd_read(pd);\r\nerr_free:\r\nput_uobj_write(uobj);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_dereg_mr(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_dereg_mr cmd;\r\nstruct ib_mr *mr;\r\nstruct ib_uobject *uobj;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_mr_idr, cmd.mr_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nmr = uobj->object;\r\nret = ib_dereg_mr(mr);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_mr_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_create_comp_channel(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_comp_channel cmd;\r\nstruct ib_uverbs_create_comp_channel_resp resp;\r\nstruct file *filp;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nret = get_unused_fd();\r\nif (ret < 0)\r\nreturn ret;\r\nresp.fd = ret;\r\nfilp = ib_uverbs_alloc_event_file(file, 0);\r\nif (IS_ERR(filp)) {\r\nput_unused_fd(resp.fd);\r\nreturn PTR_ERR(filp);\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nput_unused_fd(resp.fd);\r\nfput(filp);\r\nreturn -EFAULT;\r\n}\r\nfd_install(resp.fd, filp);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_create_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_cq cmd;\r\nstruct ib_uverbs_create_cq_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_ucq_object *obj;\r\nstruct ib_uverbs_event_file *ev_file = NULL;\r\nstruct ib_cq *cq;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nif (cmd.comp_vector >= file->device->num_comp_vectors)\r\nreturn -EINVAL;\r\nobj = kmalloc(sizeof *obj, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\ninit_uobj(&obj->uobject, cmd.user_handle, file->ucontext, &cq_lock_key);\r\ndown_write(&obj->uobject.mutex);\r\nif (cmd.comp_channel >= 0) {\r\nev_file = ib_uverbs_lookup_comp_file(cmd.comp_channel);\r\nif (!ev_file) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nobj->uverbs_file = file;\r\nobj->comp_events_reported = 0;\r\nobj->async_events_reported = 0;\r\nINIT_LIST_HEAD(&obj->comp_list);\r\nINIT_LIST_HEAD(&obj->async_list);\r\ncq = file->device->ib_dev->create_cq(file->device->ib_dev, cmd.cqe,\r\ncmd.comp_vector,\r\nfile->ucontext, &udata);\r\nif (IS_ERR(cq)) {\r\nret = PTR_ERR(cq);\r\ngoto err_file;\r\n}\r\ncq->device = file->device->ib_dev;\r\ncq->uobject = &obj->uobject;\r\ncq->comp_handler = ib_uverbs_comp_handler;\r\ncq->event_handler = ib_uverbs_cq_event_handler;\r\ncq->cq_context = ev_file;\r\natomic_set(&cq->usecnt, 0);\r\nobj->uobject.object = cq;\r\nret = idr_add_uobj(&ib_uverbs_cq_idr, &obj->uobject);\r\nif (ret)\r\ngoto err_free;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.cq_handle = obj->uobject.id;\r\nresp.cqe = cq->cqe;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&obj->uobject.list, &file->ucontext->cq_list);\r\nmutex_unlock(&file->mutex);\r\nobj->uobject.live = 1;\r\nup_write(&obj->uobject.mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_cq_idr, &obj->uobject);\r\nerr_free:\r\nib_destroy_cq(cq);\r\nerr_file:\r\nif (ev_file)\r\nib_uverbs_release_ucq(file, ev_file, obj);\r\nerr:\r\nput_uobj_write(&obj->uobject);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_resize_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_resize_cq cmd;\r\nstruct ib_uverbs_resize_cq_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_cq *cq;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\ncq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\r\nif (!cq)\r\nreturn -EINVAL;\r\nret = cq->device->resize_cq(cq, cmd.cqe, &udata);\r\nif (ret)\r\ngoto out;\r\nresp.cqe = cq->cqe;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp.cqe))\r\nret = -EFAULT;\r\nout:\r\nput_cq_read(cq);\r\nreturn ret ? ret : in_len;\r\n}\r\nstatic int copy_wc_to_user(void __user *dest, struct ib_wc *wc)\r\n{\r\nstruct ib_uverbs_wc tmp;\r\ntmp.wr_id = wc->wr_id;\r\ntmp.status = wc->status;\r\ntmp.opcode = wc->opcode;\r\ntmp.vendor_err = wc->vendor_err;\r\ntmp.byte_len = wc->byte_len;\r\ntmp.ex.imm_data = (__u32 __force) wc->ex.imm_data;\r\ntmp.qp_num = wc->qp->qp_num;\r\ntmp.src_qp = wc->src_qp;\r\ntmp.wc_flags = wc->wc_flags;\r\ntmp.pkey_index = wc->pkey_index;\r\ntmp.slid = wc->slid;\r\ntmp.sl = wc->sl;\r\ntmp.dlid_path_bits = wc->dlid_path_bits;\r\ntmp.port_num = wc->port_num;\r\ntmp.reserved = 0;\r\nif (copy_to_user(dest, &tmp, sizeof tmp))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_poll_cq cmd;\r\nstruct ib_uverbs_poll_cq_resp resp;\r\nu8 __user *header_ptr;\r\nu8 __user *data_ptr;\r\nstruct ib_cq *cq;\r\nstruct ib_wc wc;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\ncq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\r\nif (!cq)\r\nreturn -EINVAL;\r\nheader_ptr = (void __user *)(unsigned long) cmd.response;\r\ndata_ptr = header_ptr + sizeof resp;\r\nmemset(&resp, 0, sizeof resp);\r\nwhile (resp.count < cmd.ne) {\r\nret = ib_poll_cq(cq, 1, &wc);\r\nif (ret < 0)\r\ngoto out_put;\r\nif (!ret)\r\nbreak;\r\nret = copy_wc_to_user(data_ptr, &wc);\r\nif (ret)\r\ngoto out_put;\r\ndata_ptr += sizeof(struct ib_uverbs_wc);\r\n++resp.count;\r\n}\r\nif (copy_to_user(header_ptr, &resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto out_put;\r\n}\r\nret = in_len;\r\nout_put:\r\nput_cq_read(cq);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_req_notify_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_req_notify_cq cmd;\r\nstruct ib_cq *cq;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\ncq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\r\nif (!cq)\r\nreturn -EINVAL;\r\nib_req_notify_cq(cq, cmd.solicited_only ?\r\nIB_CQ_SOLICITED : IB_CQ_NEXT_COMP);\r\nput_cq_read(cq);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_destroy_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_destroy_cq cmd;\r\nstruct ib_uverbs_destroy_cq_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_cq *cq;\r\nstruct ib_ucq_object *obj;\r\nstruct ib_uverbs_event_file *ev_file;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_cq_idr, cmd.cq_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\ncq = uobj->object;\r\nev_file = cq->cq_context;\r\nobj = container_of(cq->uobject, struct ib_ucq_object, uobject);\r\nret = ib_destroy_cq(cq);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_cq_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nib_uverbs_release_ucq(file, ev_file, obj);\r\nmemset(&resp, 0, sizeof resp);\r\nresp.comp_events_reported = obj->comp_events_reported;\r\nresp.async_events_reported = obj->async_events_reported;\r\nput_uobj(uobj);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_create_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_qp cmd;\r\nstruct ib_uverbs_create_qp_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uqp_object *obj;\r\nstruct ib_pd *pd;\r\nstruct ib_cq *scq, *rcq;\r\nstruct ib_srq *srq;\r\nstruct ib_qp *qp;\r\nstruct ib_qp_init_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nobj = kmalloc(sizeof *obj, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\ninit_uobj(&obj->uevent.uobject, cmd.user_handle, file->ucontext, &qp_lock_key);\r\ndown_write(&obj->uevent.uobject.mutex);\r\nsrq = cmd.is_srq ? idr_read_srq(cmd.srq_handle, file->ucontext) : NULL;\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nscq = idr_read_cq(cmd.send_cq_handle, file->ucontext, 0);\r\nrcq = cmd.recv_cq_handle == cmd.send_cq_handle ?\r\nscq : idr_read_cq(cmd.recv_cq_handle, file->ucontext, 1);\r\nif (!pd || !scq || !rcq || (cmd.is_srq && !srq)) {\r\nret = -EINVAL;\r\ngoto err_put;\r\n}\r\nattr.event_handler = ib_uverbs_qp_event_handler;\r\nattr.qp_context = file;\r\nattr.send_cq = scq;\r\nattr.recv_cq = rcq;\r\nattr.srq = srq;\r\nattr.sq_sig_type = cmd.sq_sig_all ? IB_SIGNAL_ALL_WR : IB_SIGNAL_REQ_WR;\r\nattr.qp_type = cmd.qp_type;\r\nattr.create_flags = 0;\r\nattr.cap.max_send_wr = cmd.max_send_wr;\r\nattr.cap.max_recv_wr = cmd.max_recv_wr;\r\nattr.cap.max_send_sge = cmd.max_send_sge;\r\nattr.cap.max_recv_sge = cmd.max_recv_sge;\r\nattr.cap.max_inline_data = cmd.max_inline_data;\r\nobj->uevent.events_reported = 0;\r\nINIT_LIST_HEAD(&obj->uevent.event_list);\r\nINIT_LIST_HEAD(&obj->mcast_list);\r\nqp = pd->device->create_qp(pd, &attr, &udata);\r\nif (IS_ERR(qp)) {\r\nret = PTR_ERR(qp);\r\ngoto err_put;\r\n}\r\nqp->device = pd->device;\r\nqp->pd = pd;\r\nqp->send_cq = attr.send_cq;\r\nqp->recv_cq = attr.recv_cq;\r\nqp->srq = attr.srq;\r\nqp->uobject = &obj->uevent.uobject;\r\nqp->event_handler = attr.event_handler;\r\nqp->qp_context = attr.qp_context;\r\nqp->qp_type = attr.qp_type;\r\natomic_inc(&pd->usecnt);\r\natomic_inc(&attr.send_cq->usecnt);\r\natomic_inc(&attr.recv_cq->usecnt);\r\nif (attr.srq)\r\natomic_inc(&attr.srq->usecnt);\r\nobj->uevent.uobject.object = qp;\r\nret = idr_add_uobj(&ib_uverbs_qp_idr, &obj->uevent.uobject);\r\nif (ret)\r\ngoto err_destroy;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.qpn = qp->qp_num;\r\nresp.qp_handle = obj->uevent.uobject.id;\r\nresp.max_recv_sge = attr.cap.max_recv_sge;\r\nresp.max_send_sge = attr.cap.max_send_sge;\r\nresp.max_recv_wr = attr.cap.max_recv_wr;\r\nresp.max_send_wr = attr.cap.max_send_wr;\r\nresp.max_inline_data = attr.cap.max_inline_data;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nput_pd_read(pd);\r\nput_cq_read(scq);\r\nif (rcq != scq)\r\nput_cq_read(rcq);\r\nif (srq)\r\nput_srq_read(srq);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&obj->uevent.uobject.list, &file->ucontext->qp_list);\r\nmutex_unlock(&file->mutex);\r\nobj->uevent.uobject.live = 1;\r\nup_write(&obj->uevent.uobject.mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_qp_idr, &obj->uevent.uobject);\r\nerr_destroy:\r\nib_destroy_qp(qp);\r\nerr_put:\r\nif (pd)\r\nput_pd_read(pd);\r\nif (scq)\r\nput_cq_read(scq);\r\nif (rcq && rcq != scq)\r\nput_cq_read(rcq);\r\nif (srq)\r\nput_srq_read(srq);\r\nput_uobj_write(&obj->uevent.uobject);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_query_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_query_qp cmd;\r\nstruct ib_uverbs_query_qp_resp resp;\r\nstruct ib_qp *qp;\r\nstruct ib_qp_attr *attr;\r\nstruct ib_qp_init_attr *init_attr;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nattr = kmalloc(sizeof *attr, GFP_KERNEL);\r\ninit_attr = kmalloc(sizeof *init_attr, GFP_KERNEL);\r\nif (!attr || !init_attr) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = ib_query_qp(qp, attr, cmd.attr_mask, init_attr);\r\nput_qp_read(qp);\r\nif (ret)\r\ngoto out;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.qp_state = attr->qp_state;\r\nresp.cur_qp_state = attr->cur_qp_state;\r\nresp.path_mtu = attr->path_mtu;\r\nresp.path_mig_state = attr->path_mig_state;\r\nresp.qkey = attr->qkey;\r\nresp.rq_psn = attr->rq_psn;\r\nresp.sq_psn = attr->sq_psn;\r\nresp.dest_qp_num = attr->dest_qp_num;\r\nresp.qp_access_flags = attr->qp_access_flags;\r\nresp.pkey_index = attr->pkey_index;\r\nresp.alt_pkey_index = attr->alt_pkey_index;\r\nresp.sq_draining = attr->sq_draining;\r\nresp.max_rd_atomic = attr->max_rd_atomic;\r\nresp.max_dest_rd_atomic = attr->max_dest_rd_atomic;\r\nresp.min_rnr_timer = attr->min_rnr_timer;\r\nresp.port_num = attr->port_num;\r\nresp.timeout = attr->timeout;\r\nresp.retry_cnt = attr->retry_cnt;\r\nresp.rnr_retry = attr->rnr_retry;\r\nresp.alt_port_num = attr->alt_port_num;\r\nresp.alt_timeout = attr->alt_timeout;\r\nmemcpy(resp.dest.dgid, attr->ah_attr.grh.dgid.raw, 16);\r\nresp.dest.flow_label = attr->ah_attr.grh.flow_label;\r\nresp.dest.sgid_index = attr->ah_attr.grh.sgid_index;\r\nresp.dest.hop_limit = attr->ah_attr.grh.hop_limit;\r\nresp.dest.traffic_class = attr->ah_attr.grh.traffic_class;\r\nresp.dest.dlid = attr->ah_attr.dlid;\r\nresp.dest.sl = attr->ah_attr.sl;\r\nresp.dest.src_path_bits = attr->ah_attr.src_path_bits;\r\nresp.dest.static_rate = attr->ah_attr.static_rate;\r\nresp.dest.is_global = !!(attr->ah_attr.ah_flags & IB_AH_GRH);\r\nresp.dest.port_num = attr->ah_attr.port_num;\r\nmemcpy(resp.alt_dest.dgid, attr->alt_ah_attr.grh.dgid.raw, 16);\r\nresp.alt_dest.flow_label = attr->alt_ah_attr.grh.flow_label;\r\nresp.alt_dest.sgid_index = attr->alt_ah_attr.grh.sgid_index;\r\nresp.alt_dest.hop_limit = attr->alt_ah_attr.grh.hop_limit;\r\nresp.alt_dest.traffic_class = attr->alt_ah_attr.grh.traffic_class;\r\nresp.alt_dest.dlid = attr->alt_ah_attr.dlid;\r\nresp.alt_dest.sl = attr->alt_ah_attr.sl;\r\nresp.alt_dest.src_path_bits = attr->alt_ah_attr.src_path_bits;\r\nresp.alt_dest.static_rate = attr->alt_ah_attr.static_rate;\r\nresp.alt_dest.is_global = !!(attr->alt_ah_attr.ah_flags & IB_AH_GRH);\r\nresp.alt_dest.port_num = attr->alt_ah_attr.port_num;\r\nresp.max_send_wr = init_attr->cap.max_send_wr;\r\nresp.max_recv_wr = init_attr->cap.max_recv_wr;\r\nresp.max_send_sge = init_attr->cap.max_send_sge;\r\nresp.max_recv_sge = init_attr->cap.max_recv_sge;\r\nresp.max_inline_data = init_attr->cap.max_inline_data;\r\nresp.sq_sig_all = init_attr->sq_sig_type == IB_SIGNAL_ALL_WR;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nout:\r\nkfree(attr);\r\nkfree(init_attr);\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_modify_qp cmd;\r\nstruct ib_udata udata;\r\nstruct ib_qp *qp;\r\nstruct ib_qp_attr *attr;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd, NULL, in_len - sizeof cmd,\r\nout_len);\r\nattr = kmalloc(sizeof *attr, GFP_KERNEL);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nattr->qp_state = cmd.qp_state;\r\nattr->cur_qp_state = cmd.cur_qp_state;\r\nattr->path_mtu = cmd.path_mtu;\r\nattr->path_mig_state = cmd.path_mig_state;\r\nattr->qkey = cmd.qkey;\r\nattr->rq_psn = cmd.rq_psn;\r\nattr->sq_psn = cmd.sq_psn;\r\nattr->dest_qp_num = cmd.dest_qp_num;\r\nattr->qp_access_flags = cmd.qp_access_flags;\r\nattr->pkey_index = cmd.pkey_index;\r\nattr->alt_pkey_index = cmd.alt_pkey_index;\r\nattr->en_sqd_async_notify = cmd.en_sqd_async_notify;\r\nattr->max_rd_atomic = cmd.max_rd_atomic;\r\nattr->max_dest_rd_atomic = cmd.max_dest_rd_atomic;\r\nattr->min_rnr_timer = cmd.min_rnr_timer;\r\nattr->port_num = cmd.port_num;\r\nattr->timeout = cmd.timeout;\r\nattr->retry_cnt = cmd.retry_cnt;\r\nattr->rnr_retry = cmd.rnr_retry;\r\nattr->alt_port_num = cmd.alt_port_num;\r\nattr->alt_timeout = cmd.alt_timeout;\r\nmemcpy(attr->ah_attr.grh.dgid.raw, cmd.dest.dgid, 16);\r\nattr->ah_attr.grh.flow_label = cmd.dest.flow_label;\r\nattr->ah_attr.grh.sgid_index = cmd.dest.sgid_index;\r\nattr->ah_attr.grh.hop_limit = cmd.dest.hop_limit;\r\nattr->ah_attr.grh.traffic_class = cmd.dest.traffic_class;\r\nattr->ah_attr.dlid = cmd.dest.dlid;\r\nattr->ah_attr.sl = cmd.dest.sl;\r\nattr->ah_attr.src_path_bits = cmd.dest.src_path_bits;\r\nattr->ah_attr.static_rate = cmd.dest.static_rate;\r\nattr->ah_attr.ah_flags = cmd.dest.is_global ? IB_AH_GRH : 0;\r\nattr->ah_attr.port_num = cmd.dest.port_num;\r\nmemcpy(attr->alt_ah_attr.grh.dgid.raw, cmd.alt_dest.dgid, 16);\r\nattr->alt_ah_attr.grh.flow_label = cmd.alt_dest.flow_label;\r\nattr->alt_ah_attr.grh.sgid_index = cmd.alt_dest.sgid_index;\r\nattr->alt_ah_attr.grh.hop_limit = cmd.alt_dest.hop_limit;\r\nattr->alt_ah_attr.grh.traffic_class = cmd.alt_dest.traffic_class;\r\nattr->alt_ah_attr.dlid = cmd.alt_dest.dlid;\r\nattr->alt_ah_attr.sl = cmd.alt_dest.sl;\r\nattr->alt_ah_attr.src_path_bits = cmd.alt_dest.src_path_bits;\r\nattr->alt_ah_attr.static_rate = cmd.alt_dest.static_rate;\r\nattr->alt_ah_attr.ah_flags = cmd.alt_dest.is_global ? IB_AH_GRH : 0;\r\nattr->alt_ah_attr.port_num = cmd.alt_dest.port_num;\r\nret = qp->device->modify_qp(qp, attr, cmd.attr_mask, &udata);\r\nput_qp_read(qp);\r\nif (ret)\r\ngoto out;\r\nret = in_len;\r\nout:\r\nkfree(attr);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_destroy_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_destroy_qp cmd;\r\nstruct ib_uverbs_destroy_qp_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_qp *qp;\r\nstruct ib_uqp_object *obj;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nmemset(&resp, 0, sizeof resp);\r\nuobj = idr_write_uobj(&ib_uverbs_qp_idr, cmd.qp_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nqp = uobj->object;\r\nobj = container_of(uobj, struct ib_uqp_object, uevent.uobject);\r\nif (!list_empty(&obj->mcast_list)) {\r\nput_uobj_write(uobj);\r\nreturn -EBUSY;\r\n}\r\nret = ib_destroy_qp(qp);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_qp_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nib_uverbs_release_uevent(file, &obj->uevent);\r\nresp.events_reported = obj->uevent.events_reported;\r\nput_uobj(uobj);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_post_send cmd;\r\nstruct ib_uverbs_post_send_resp resp;\r\nstruct ib_uverbs_send_wr *user_wr;\r\nstruct ib_send_wr *wr = NULL, *last, *next, *bad_wr;\r\nstruct ib_qp *qp;\r\nint i, sg_ind;\r\nint is_ud;\r\nssize_t ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nif (in_len < sizeof cmd + cmd.wqe_size * cmd.wr_count +\r\ncmd.sge_count * sizeof (struct ib_uverbs_sge))\r\nreturn -EINVAL;\r\nif (cmd.wqe_size < sizeof (struct ib_uverbs_send_wr))\r\nreturn -EINVAL;\r\nuser_wr = kmalloc(cmd.wqe_size, GFP_KERNEL);\r\nif (!user_wr)\r\nreturn -ENOMEM;\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp)\r\ngoto out;\r\nis_ud = qp->qp_type == IB_QPT_UD;\r\nsg_ind = 0;\r\nlast = NULL;\r\nfor (i = 0; i < cmd.wr_count; ++i) {\r\nif (copy_from_user(user_wr,\r\nbuf + sizeof cmd + i * cmd.wqe_size,\r\ncmd.wqe_size)) {\r\nret = -EFAULT;\r\ngoto out_put;\r\n}\r\nif (user_wr->num_sge + sg_ind > cmd.sge_count) {\r\nret = -EINVAL;\r\ngoto out_put;\r\n}\r\nnext = kmalloc(ALIGN(sizeof *next, sizeof (struct ib_sge)) +\r\nuser_wr->num_sge * sizeof (struct ib_sge),\r\nGFP_KERNEL);\r\nif (!next) {\r\nret = -ENOMEM;\r\ngoto out_put;\r\n}\r\nif (!last)\r\nwr = next;\r\nelse\r\nlast->next = next;\r\nlast = next;\r\nnext->next = NULL;\r\nnext->wr_id = user_wr->wr_id;\r\nnext->num_sge = user_wr->num_sge;\r\nnext->opcode = user_wr->opcode;\r\nnext->send_flags = user_wr->send_flags;\r\nif (is_ud) {\r\nnext->wr.ud.ah = idr_read_ah(user_wr->wr.ud.ah,\r\nfile->ucontext);\r\nif (!next->wr.ud.ah) {\r\nret = -EINVAL;\r\ngoto out_put;\r\n}\r\nnext->wr.ud.remote_qpn = user_wr->wr.ud.remote_qpn;\r\nnext->wr.ud.remote_qkey = user_wr->wr.ud.remote_qkey;\r\n} else {\r\nswitch (next->opcode) {\r\ncase IB_WR_RDMA_WRITE_WITH_IMM:\r\nnext->ex.imm_data =\r\n(__be32 __force) user_wr->ex.imm_data;\r\ncase IB_WR_RDMA_WRITE:\r\ncase IB_WR_RDMA_READ:\r\nnext->wr.rdma.remote_addr =\r\nuser_wr->wr.rdma.remote_addr;\r\nnext->wr.rdma.rkey =\r\nuser_wr->wr.rdma.rkey;\r\nbreak;\r\ncase IB_WR_SEND_WITH_IMM:\r\nnext->ex.imm_data =\r\n(__be32 __force) user_wr->ex.imm_data;\r\nbreak;\r\ncase IB_WR_SEND_WITH_INV:\r\nnext->ex.invalidate_rkey =\r\nuser_wr->ex.invalidate_rkey;\r\nbreak;\r\ncase IB_WR_ATOMIC_CMP_AND_SWP:\r\ncase IB_WR_ATOMIC_FETCH_AND_ADD:\r\nnext->wr.atomic.remote_addr =\r\nuser_wr->wr.atomic.remote_addr;\r\nnext->wr.atomic.compare_add =\r\nuser_wr->wr.atomic.compare_add;\r\nnext->wr.atomic.swap = user_wr->wr.atomic.swap;\r\nnext->wr.atomic.rkey = user_wr->wr.atomic.rkey;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (next->num_sge) {\r\nnext->sg_list = (void *) next +\r\nALIGN(sizeof *next, sizeof (struct ib_sge));\r\nif (copy_from_user(next->sg_list,\r\nbuf + sizeof cmd +\r\ncmd.wr_count * cmd.wqe_size +\r\nsg_ind * sizeof (struct ib_sge),\r\nnext->num_sge * sizeof (struct ib_sge))) {\r\nret = -EFAULT;\r\ngoto out_put;\r\n}\r\nsg_ind += next->num_sge;\r\n} else\r\nnext->sg_list = NULL;\r\n}\r\nresp.bad_wr = 0;\r\nret = qp->device->post_send(qp, wr, &bad_wr);\r\nif (ret)\r\nfor (next = wr; next; next = next->next) {\r\n++resp.bad_wr;\r\nif (next == bad_wr)\r\nbreak;\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nout_put:\r\nput_qp_read(qp);\r\nwhile (wr) {\r\nif (is_ud && wr->wr.ud.ah)\r\nput_ah_read(wr->wr.ud.ah);\r\nnext = wr->next;\r\nkfree(wr);\r\nwr = next;\r\n}\r\nout:\r\nkfree(user_wr);\r\nreturn ret ? ret : in_len;\r\n}\r\nstatic struct ib_recv_wr *ib_uverbs_unmarshall_recv(const char __user *buf,\r\nint in_len,\r\nu32 wr_count,\r\nu32 sge_count,\r\nu32 wqe_size)\r\n{\r\nstruct ib_uverbs_recv_wr *user_wr;\r\nstruct ib_recv_wr *wr = NULL, *last, *next;\r\nint sg_ind;\r\nint i;\r\nint ret;\r\nif (in_len < wqe_size * wr_count +\r\nsge_count * sizeof (struct ib_uverbs_sge))\r\nreturn ERR_PTR(-EINVAL);\r\nif (wqe_size < sizeof (struct ib_uverbs_recv_wr))\r\nreturn ERR_PTR(-EINVAL);\r\nuser_wr = kmalloc(wqe_size, GFP_KERNEL);\r\nif (!user_wr)\r\nreturn ERR_PTR(-ENOMEM);\r\nsg_ind = 0;\r\nlast = NULL;\r\nfor (i = 0; i < wr_count; ++i) {\r\nif (copy_from_user(user_wr, buf + i * wqe_size,\r\nwqe_size)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nif (user_wr->num_sge + sg_ind > sge_count) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nnext = kmalloc(ALIGN(sizeof *next, sizeof (struct ib_sge)) +\r\nuser_wr->num_sge * sizeof (struct ib_sge),\r\nGFP_KERNEL);\r\nif (!next) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (!last)\r\nwr = next;\r\nelse\r\nlast->next = next;\r\nlast = next;\r\nnext->next = NULL;\r\nnext->wr_id = user_wr->wr_id;\r\nnext->num_sge = user_wr->num_sge;\r\nif (next->num_sge) {\r\nnext->sg_list = (void *) next +\r\nALIGN(sizeof *next, sizeof (struct ib_sge));\r\nif (copy_from_user(next->sg_list,\r\nbuf + wr_count * wqe_size +\r\nsg_ind * sizeof (struct ib_sge),\r\nnext->num_sge * sizeof (struct ib_sge))) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nsg_ind += next->num_sge;\r\n} else\r\nnext->sg_list = NULL;\r\n}\r\nkfree(user_wr);\r\nreturn wr;\r\nerr:\r\nkfree(user_wr);\r\nwhile (wr) {\r\nnext = wr->next;\r\nkfree(wr);\r\nwr = next;\r\n}\r\nreturn ERR_PTR(ret);\r\n}\r\nssize_t ib_uverbs_post_recv(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_post_recv cmd;\r\nstruct ib_uverbs_post_recv_resp resp;\r\nstruct ib_recv_wr *wr, *next, *bad_wr;\r\nstruct ib_qp *qp;\r\nssize_t ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nwr = ib_uverbs_unmarshall_recv(buf + sizeof cmd,\r\nin_len - sizeof cmd, cmd.wr_count,\r\ncmd.sge_count, cmd.wqe_size);\r\nif (IS_ERR(wr))\r\nreturn PTR_ERR(wr);\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp)\r\ngoto out;\r\nresp.bad_wr = 0;\r\nret = qp->device->post_recv(qp, wr, &bad_wr);\r\nput_qp_read(qp);\r\nif (ret)\r\nfor (next = wr; next; next = next->next) {\r\n++resp.bad_wr;\r\nif (next == bad_wr)\r\nbreak;\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nout:\r\nwhile (wr) {\r\nnext = wr->next;\r\nkfree(wr);\r\nwr = next;\r\n}\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_post_srq_recv(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_post_srq_recv cmd;\r\nstruct ib_uverbs_post_srq_recv_resp resp;\r\nstruct ib_recv_wr *wr, *next, *bad_wr;\r\nstruct ib_srq *srq;\r\nssize_t ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nwr = ib_uverbs_unmarshall_recv(buf + sizeof cmd,\r\nin_len - sizeof cmd, cmd.wr_count,\r\ncmd.sge_count, cmd.wqe_size);\r\nif (IS_ERR(wr))\r\nreturn PTR_ERR(wr);\r\nsrq = idr_read_srq(cmd.srq_handle, file->ucontext);\r\nif (!srq)\r\ngoto out;\r\nresp.bad_wr = 0;\r\nret = srq->device->post_srq_recv(srq, wr, &bad_wr);\r\nput_srq_read(srq);\r\nif (ret)\r\nfor (next = wr; next; next = next->next) {\r\n++resp.bad_wr;\r\nif (next == bad_wr)\r\nbreak;\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nout:\r\nwhile (wr) {\r\nnext = wr->next;\r\nkfree(wr);\r\nwr = next;\r\n}\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_create_ah(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_ah cmd;\r\nstruct ib_uverbs_create_ah_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_pd *pd;\r\nstruct ib_ah *ah;\r\nstruct ib_ah_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = kmalloc(sizeof *uobj, GFP_KERNEL);\r\nif (!uobj)\r\nreturn -ENOMEM;\r\ninit_uobj(uobj, cmd.user_handle, file->ucontext, &ah_lock_key);\r\ndown_write(&uobj->mutex);\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nattr.dlid = cmd.attr.dlid;\r\nattr.sl = cmd.attr.sl;\r\nattr.src_path_bits = cmd.attr.src_path_bits;\r\nattr.static_rate = cmd.attr.static_rate;\r\nattr.ah_flags = cmd.attr.is_global ? IB_AH_GRH : 0;\r\nattr.port_num = cmd.attr.port_num;\r\nattr.grh.flow_label = cmd.attr.grh.flow_label;\r\nattr.grh.sgid_index = cmd.attr.grh.sgid_index;\r\nattr.grh.hop_limit = cmd.attr.grh.hop_limit;\r\nattr.grh.traffic_class = cmd.attr.grh.traffic_class;\r\nmemcpy(attr.grh.dgid.raw, cmd.attr.grh.dgid, 16);\r\nah = ib_create_ah(pd, &attr);\r\nif (IS_ERR(ah)) {\r\nret = PTR_ERR(ah);\r\ngoto err_put;\r\n}\r\nah->uobject = uobj;\r\nuobj->object = ah;\r\nret = idr_add_uobj(&ib_uverbs_ah_idr, uobj);\r\nif (ret)\r\ngoto err_destroy;\r\nresp.ah_handle = uobj->id;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nput_pd_read(pd);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&uobj->list, &file->ucontext->ah_list);\r\nmutex_unlock(&file->mutex);\r\nuobj->live = 1;\r\nup_write(&uobj->mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_ah_idr, uobj);\r\nerr_destroy:\r\nib_destroy_ah(ah);\r\nerr_put:\r\nput_pd_read(pd);\r\nerr:\r\nput_uobj_write(uobj);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_destroy_ah(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len, int out_len)\r\n{\r\nstruct ib_uverbs_destroy_ah cmd;\r\nstruct ib_ah *ah;\r\nstruct ib_uobject *uobj;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_ah_idr, cmd.ah_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nah = uobj->object;\r\nret = ib_destroy_ah(ah);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_ah_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_attach_mcast(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_attach_mcast cmd;\r\nstruct ib_qp *qp;\r\nstruct ib_uqp_object *obj;\r\nstruct ib_uverbs_mcast_entry *mcast;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp)\r\nreturn -EINVAL;\r\nobj = container_of(qp->uobject, struct ib_uqp_object, uevent.uobject);\r\nlist_for_each_entry(mcast, &obj->mcast_list, list)\r\nif (cmd.mlid == mcast->lid &&\r\n!memcmp(cmd.gid, mcast->gid.raw, sizeof mcast->gid.raw)) {\r\nret = 0;\r\ngoto out_put;\r\n}\r\nmcast = kmalloc(sizeof *mcast, GFP_KERNEL);\r\nif (!mcast) {\r\nret = -ENOMEM;\r\ngoto out_put;\r\n}\r\nmcast->lid = cmd.mlid;\r\nmemcpy(mcast->gid.raw, cmd.gid, sizeof mcast->gid.raw);\r\nret = ib_attach_mcast(qp, &mcast->gid, cmd.mlid);\r\nif (!ret)\r\nlist_add_tail(&mcast->list, &obj->mcast_list);\r\nelse\r\nkfree(mcast);\r\nout_put:\r\nput_qp_read(qp);\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_detach_mcast(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_detach_mcast cmd;\r\nstruct ib_uqp_object *obj;\r\nstruct ib_qp *qp;\r\nstruct ib_uverbs_mcast_entry *mcast;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp)\r\nreturn -EINVAL;\r\nret = ib_detach_mcast(qp, (union ib_gid *) cmd.gid, cmd.mlid);\r\nif (ret)\r\ngoto out_put;\r\nobj = container_of(qp->uobject, struct ib_uqp_object, uevent.uobject);\r\nlist_for_each_entry(mcast, &obj->mcast_list, list)\r\nif (cmd.mlid == mcast->lid &&\r\n!memcmp(cmd.gid, mcast->gid.raw, sizeof mcast->gid.raw)) {\r\nlist_del(&mcast->list);\r\nkfree(mcast);\r\nbreak;\r\n}\r\nout_put:\r\nput_qp_read(qp);\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_create_srq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_srq cmd;\r\nstruct ib_uverbs_create_srq_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uevent_object *obj;\r\nstruct ib_pd *pd;\r\nstruct ib_srq *srq;\r\nstruct ib_srq_init_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nobj = kmalloc(sizeof *obj, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\ninit_uobj(&obj->uobject, cmd.user_handle, file->ucontext, &srq_lock_key);\r\ndown_write(&obj->uobject.mutex);\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nattr.event_handler = ib_uverbs_srq_event_handler;\r\nattr.srq_context = file;\r\nattr.attr.max_wr = cmd.max_wr;\r\nattr.attr.max_sge = cmd.max_sge;\r\nattr.attr.srq_limit = cmd.srq_limit;\r\nobj->events_reported = 0;\r\nINIT_LIST_HEAD(&obj->event_list);\r\nsrq = pd->device->create_srq(pd, &attr, &udata);\r\nif (IS_ERR(srq)) {\r\nret = PTR_ERR(srq);\r\ngoto err_put;\r\n}\r\nsrq->device = pd->device;\r\nsrq->pd = pd;\r\nsrq->uobject = &obj->uobject;\r\nsrq->event_handler = attr.event_handler;\r\nsrq->srq_context = attr.srq_context;\r\natomic_inc(&pd->usecnt);\r\natomic_set(&srq->usecnt, 0);\r\nobj->uobject.object = srq;\r\nret = idr_add_uobj(&ib_uverbs_srq_idr, &obj->uobject);\r\nif (ret)\r\ngoto err_destroy;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.srq_handle = obj->uobject.id;\r\nresp.max_wr = attr.attr.max_wr;\r\nresp.max_sge = attr.attr.max_sge;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nput_pd_read(pd);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&obj->uobject.list, &file->ucontext->srq_list);\r\nmutex_unlock(&file->mutex);\r\nobj->uobject.live = 1;\r\nup_write(&obj->uobject.mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_srq_idr, &obj->uobject);\r\nerr_destroy:\r\nib_destroy_srq(srq);\r\nerr_put:\r\nput_pd_read(pd);\r\nerr:\r\nput_uobj_write(&obj->uobject);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_modify_srq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_modify_srq cmd;\r\nstruct ib_udata udata;\r\nstruct ib_srq *srq;\r\nstruct ib_srq_attr attr;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd, NULL, in_len - sizeof cmd,\r\nout_len);\r\nsrq = idr_read_srq(cmd.srq_handle, file->ucontext);\r\nif (!srq)\r\nreturn -EINVAL;\r\nattr.max_wr = cmd.max_wr;\r\nattr.srq_limit = cmd.srq_limit;\r\nret = srq->device->modify_srq(srq, &attr, cmd.attr_mask, &udata);\r\nput_srq_read(srq);\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_query_srq(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_query_srq cmd;\r\nstruct ib_uverbs_query_srq_resp resp;\r\nstruct ib_srq_attr attr;\r\nstruct ib_srq *srq;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nsrq = idr_read_srq(cmd.srq_handle, file->ucontext);\r\nif (!srq)\r\nreturn -EINVAL;\r\nret = ib_query_srq(srq, &attr);\r\nput_srq_read(srq);\r\nif (ret)\r\nreturn ret;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.max_wr = attr.max_wr;\r\nresp.max_sge = attr.max_sge;\r\nresp.srq_limit = attr.srq_limit;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_destroy_srq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_destroy_srq cmd;\r\nstruct ib_uverbs_destroy_srq_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_srq *srq;\r\nstruct ib_uevent_object *obj;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_srq_idr, cmd.srq_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nsrq = uobj->object;\r\nobj = container_of(uobj, struct ib_uevent_object, uobject);\r\nret = ib_destroy_srq(srq);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_srq_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nib_uverbs_release_uevent(file, obj);\r\nmemset(&resp, 0, sizeof resp);\r\nresp.events_reported = obj->events_reported;\r\nput_uobj(uobj);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nreturn ret ? ret : in_len;\r\n}
