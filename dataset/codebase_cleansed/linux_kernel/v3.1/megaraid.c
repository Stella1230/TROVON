static int\r\nmega_setup_mailbox(adapter_t *adapter)\r\n{\r\nunsigned long align;\r\nadapter->una_mbox64 = pci_alloc_consistent(adapter->dev,\r\nsizeof(mbox64_t), &adapter->una_mbox64_dma);\r\nif( !adapter->una_mbox64 ) return -1;\r\nadapter->mbox = &adapter->una_mbox64->mbox;\r\nadapter->mbox = (mbox_t *)((((unsigned long) adapter->mbox) + 15) &\r\n(~0UL ^ 0xFUL));\r\nadapter->mbox64 = (mbox64_t *)(((unsigned long)adapter->mbox) - 8);\r\nalign = ((void *)adapter->mbox) - ((void *)&adapter->una_mbox64->mbox);\r\nadapter->mbox_dma = adapter->una_mbox64_dma + 8 + align;\r\nif( adapter->flag & BOARD_IOMAP ) {\r\noutb(adapter->mbox_dma & 0xFF,\r\nadapter->host->io_port + MBOX_PORT0);\r\noutb((adapter->mbox_dma >> 8) & 0xFF,\r\nadapter->host->io_port + MBOX_PORT1);\r\noutb((adapter->mbox_dma >> 16) & 0xFF,\r\nadapter->host->io_port + MBOX_PORT2);\r\noutb((adapter->mbox_dma >> 24) & 0xFF,\r\nadapter->host->io_port + MBOX_PORT3);\r\noutb(ENABLE_MBOX_BYTE,\r\nadapter->host->io_port + ENABLE_MBOX_REGION);\r\nirq_ack(adapter);\r\nirq_enable(adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmega_query_adapter(adapter_t *adapter)\r\n{\r\ndma_addr_t prod_info_dma_handle;\r\nmega_inquiry3 *inquiry3;\r\nu8 raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox;\r\nint retval;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\r\nmemset(&mbox->m_out, 0, sizeof(raw_mbox));\r\nmbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;\r\ninquiry3 = (mega_inquiry3 *)adapter->mega_buffer;\r\nraw_mbox[0] = FC_NEW_CONFIG;\r\nraw_mbox[2] = NC_SUBOP_ENQUIRY3;\r\nraw_mbox[3] = ENQ3_GET_SOLICITED_FULL;\r\nif ((retval = issue_scb_block(adapter, raw_mbox))) {\r\nmraid_ext_inquiry *ext_inq;\r\nmraid_inquiry *inq;\r\ndma_addr_t dma_handle;\r\next_inq = pci_alloc_consistent(adapter->dev,\r\nsizeof(mraid_ext_inquiry), &dma_handle);\r\nif( ext_inq == NULL ) return -1;\r\ninq = &ext_inq->raid_inq;\r\nmbox->m_out.xferaddr = (u32)dma_handle;\r\nmbox->m_out.cmd = MEGA_MBOXCMD_ADPEXTINQ;\r\nissue_scb_block(adapter, raw_mbox);\r\nmega_8_to_40ld(inq, inquiry3,\r\n(mega_product_info *)&adapter->product_info);\r\npci_free_consistent(adapter->dev, sizeof(mraid_ext_inquiry),\r\next_inq, dma_handle);\r\n} else {\r\nadapter->flag |= BOARD_40LD;\r\nprod_info_dma_handle = pci_map_single(adapter->dev, (void *)\r\n&adapter->product_info,\r\nsizeof(mega_product_info), PCI_DMA_FROMDEVICE);\r\nmbox->m_out.xferaddr = prod_info_dma_handle;\r\nraw_mbox[0] = FC_NEW_CONFIG;\r\nraw_mbox[2] = NC_SUBOP_PRODUCT_INFO;\r\nif ((retval = issue_scb_block(adapter, raw_mbox)))\r\nprintk(KERN_WARNING\r\n"megaraid: Product_info cmd failed with error: %d\n",\r\nretval);\r\npci_unmap_single(adapter->dev, prod_info_dma_handle,\r\nsizeof(mega_product_info), PCI_DMA_FROMDEVICE);\r\n}\r\nadapter->host->max_channel =\r\nadapter->product_info.nchannels + NVIRT_CHAN -1;\r\nadapter->host->max_id = 16;\r\nadapter->host->max_lun = 7;\r\nadapter->host->cmd_per_lun = max_cmd_per_lun;\r\nadapter->numldrv = inquiry3->num_ldrv;\r\nadapter->max_cmds = adapter->product_info.max_commands;\r\nif(adapter->max_cmds > MAX_COMMANDS)\r\nadapter->max_cmds = MAX_COMMANDS;\r\nadapter->host->can_queue = adapter->max_cmds - 1;\r\nmega_get_max_sgl(adapter);\r\nadapter->host->sg_tablesize = adapter->sglen;\r\nif (adapter->product_info.subsysvid == HP_SUBSYS_VID) {\r\nsprintf (adapter->fw_version, "%c%d%d.%d%d",\r\nadapter->product_info.fw_version[2],\r\nadapter->product_info.fw_version[1] >> 8,\r\nadapter->product_info.fw_version[1] & 0x0f,\r\nadapter->product_info.fw_version[0] >> 8,\r\nadapter->product_info.fw_version[0] & 0x0f);\r\nsprintf (adapter->bios_version, "%c%d%d.%d%d",\r\nadapter->product_info.bios_version[2],\r\nadapter->product_info.bios_version[1] >> 8,\r\nadapter->product_info.bios_version[1] & 0x0f,\r\nadapter->product_info.bios_version[0] >> 8,\r\nadapter->product_info.bios_version[0] & 0x0f);\r\n} else {\r\nmemcpy(adapter->fw_version,\r\n(char *)adapter->product_info.fw_version, 4);\r\nadapter->fw_version[4] = 0;\r\nmemcpy(adapter->bios_version,\r\n(char *)adapter->product_info.bios_version, 4);\r\nadapter->bios_version[4] = 0;\r\n}\r\nprintk(KERN_NOTICE "megaraid: [%s:%s] detected %d logical drives.\n",\r\nadapter->fw_version, adapter->bios_version, adapter->numldrv);\r\nadapter->support_ext_cdb = mega_support_ext_cdb(adapter);\r\nif (adapter->support_ext_cdb)\r\nprintk(KERN_NOTICE "megaraid: supports extended CDBs.\n");\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmega_runpendq(adapter_t *adapter)\r\n{\r\nif(!list_empty(&adapter->pending_list))\r\n__mega_runpendq(adapter);\r\n}\r\nstatic int\r\nmegaraid_queue_lck(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))\r\n{\r\nadapter_t *adapter;\r\nscb_t *scb;\r\nint busy=0;\r\nunsigned long flags;\r\nadapter = (adapter_t *)scmd->device->host->hostdata;\r\nscmd->scsi_done = done;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nscb = mega_build_cmd(adapter, scmd, &busy);\r\nif (!scb)\r\ngoto out;\r\nscb->state |= SCB_PENDQ;\r\nlist_add_tail(&scb->list, &adapter->pending_list);\r\nif (atomic_read(&adapter->quiescent) == 0)\r\nmega_runpendq(adapter);\r\nbusy = 0;\r\nout:\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nreturn busy;\r\n}\r\ninline int\r\nmega_get_ldrv_num(adapter_t *adapter, Scsi_Cmnd *cmd, int channel)\r\n{\r\nint tgt;\r\nint ldrv_num;\r\ntgt = cmd->device->id;\r\nif ( tgt > adapter->this_id )\r\ntgt--;\r\nldrv_num = (channel * 15) + tgt;\r\nif( adapter->boot_ldrv_enabled ) {\r\nif( ldrv_num == 0 ) {\r\nldrv_num = adapter->boot_ldrv;\r\n}\r\nelse {\r\nif( ldrv_num <= adapter->boot_ldrv ) {\r\nldrv_num--;\r\n}\r\n}\r\n}\r\nif (adapter->support_random_del && adapter->read_ldidmap )\r\nswitch (cmd->cmnd[0]) {\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase READ_10:\r\ncase WRITE_10:\r\nldrv_num += 0x80;\r\n}\r\nreturn ldrv_num;\r\n}\r\nstatic scb_t *\r\nmega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)\r\n{\r\nmega_ext_passthru *epthru;\r\nmega_passthru *pthru;\r\nscb_t *scb;\r\nmbox_t *mbox;\r\nlong seg;\r\nchar islogical;\r\nint max_ldrv_num;\r\nint channel = 0;\r\nint target = 0;\r\nint ldrv_num = 0;\r\nif((cmd->cmnd[0] == MEGA_INTERNAL_CMD))\r\nreturn (scb_t *)cmd->host_scribble;\r\nislogical = adapter->logdrv_chan[cmd->device->channel];\r\nif( adapter->boot_pdrv_enabled ) {\r\nif( islogical ) {\r\nchannel = cmd->device->channel -\r\nadapter->product_info.nchannels;\r\n}\r\nelse {\r\nchannel = cmd->device->channel;\r\ntarget = cmd->device->id;\r\nif( target == 0 ) {\r\ntarget = adapter->boot_pdrv_tgt;\r\n}\r\nelse if( target == adapter->boot_pdrv_tgt ) {\r\ntarget = 0;\r\n}\r\n}\r\n}\r\nelse {\r\nif( islogical ) {\r\nchannel = cmd->device->channel;\r\n}\r\nelse {\r\nchannel = cmd->device->channel - NVIRT_CHAN;\r\ntarget = cmd->device->id;\r\n}\r\n}\r\nif(islogical) {\r\nif (cmd->device->lun) {\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\nreturn NULL;\r\n}\r\nldrv_num = mega_get_ldrv_num(adapter, cmd, channel);\r\nmax_ldrv_num = (adapter->flag & BOARD_40LD) ?\r\nMAX_LOGICAL_DRIVES_40LD : MAX_LOGICAL_DRIVES_8LD;\r\nif(adapter->read_ldidmap)\r\nmax_ldrv_num += 0x80;\r\nif(ldrv_num > max_ldrv_num ) {\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\nreturn NULL;\r\n}\r\n}\r\nelse {\r\nif( cmd->device->lun > 7) {\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\nreturn NULL;\r\n}\r\n}\r\nif(islogical) {\r\nswitch (cmd->cmnd[0]) {\r\ncase TEST_UNIT_READY:\r\n#if MEGA_HAVE_CLUSTERING\r\nif( !adapter->has_cluster ) {\r\ncmd->result = (DID_OK << 16);\r\ncmd->scsi_done(cmd);\r\nreturn NULL;\r\n}\r\nif(!(scb = mega_allocate_scb(adapter, cmd))) {\r\n*busy = 1;\r\nreturn NULL;\r\n}\r\nscb->raw_mbox[0] = MEGA_CLUSTER_CMD;\r\nscb->raw_mbox[2] = MEGA_RESERVATION_STATUS;\r\nscb->raw_mbox[3] = ldrv_num;\r\nscb->dma_direction = PCI_DMA_NONE;\r\nreturn scb;\r\n#else\r\ncmd->result = (DID_OK << 16);\r\ncmd->scsi_done(cmd);\r\nreturn NULL;\r\n#endif\r\ncase MODE_SENSE: {\r\nchar *buf;\r\nstruct scatterlist *sg;\r\nsg = scsi_sglist(cmd);\r\nbuf = kmap_atomic(sg_page(sg), KM_IRQ0) + sg->offset;\r\nmemset(buf, 0, cmd->cmnd[4]);\r\nkunmap_atomic(buf - sg->offset, KM_IRQ0);\r\ncmd->result = (DID_OK << 16);\r\ncmd->scsi_done(cmd);\r\nreturn NULL;\r\n}\r\ncase READ_CAPACITY:\r\ncase INQUIRY:\r\nif(!(adapter->flag & (1L << cmd->device->channel))) {\r\nprintk(KERN_NOTICE\r\n"scsi%d: scanning scsi channel %d ",\r\nadapter->host->host_no,\r\ncmd->device->channel);\r\nprintk("for logical drives.\n");\r\nadapter->flag |= (1L << cmd->device->channel);\r\n}\r\nif(!(scb = mega_allocate_scb(adapter, cmd))) {\r\n*busy = 1;\r\nreturn NULL;\r\n}\r\npthru = scb->pthru;\r\nmbox = (mbox_t *)scb->raw_mbox;\r\nmemset(mbox, 0, sizeof(scb->raw_mbox));\r\nmemset(pthru, 0, sizeof(mega_passthru));\r\npthru->timeout = 0;\r\npthru->ars = 1;\r\npthru->reqsenselen = 14;\r\npthru->islogical = 1;\r\npthru->logdrv = ldrv_num;\r\npthru->cdblen = cmd->cmd_len;\r\nmemcpy(pthru->cdb, cmd->cmnd, cmd->cmd_len);\r\nif( adapter->has_64bit_addr ) {\r\nmbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU64;\r\n}\r\nelse {\r\nmbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU;\r\n}\r\nscb->dma_direction = PCI_DMA_FROMDEVICE;\r\npthru->numsgelements = mega_build_sglist(adapter, scb,\r\n&pthru->dataxferaddr, &pthru->dataxferlen);\r\nmbox->m_out.xferaddr = scb->pthru_dma_addr;\r\nreturn scb;\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase READ_12:\r\ncase WRITE_12:\r\nif(!(scb = mega_allocate_scb(adapter, cmd))) {\r\n*busy = 1;\r\nreturn NULL;\r\n}\r\nmbox = (mbox_t *)scb->raw_mbox;\r\nmemset(mbox, 0, sizeof(scb->raw_mbox));\r\nmbox->m_out.logdrv = ldrv_num;\r\nif( adapter->has_64bit_addr ) {\r\nmbox->m_out.cmd = (*cmd->cmnd & 0x02) ?\r\nMEGA_MBOXCMD_LWRITE64:\r\nMEGA_MBOXCMD_LREAD64 ;\r\n}\r\nelse {\r\nmbox->m_out.cmd = (*cmd->cmnd & 0x02) ?\r\nMEGA_MBOXCMD_LWRITE:\r\nMEGA_MBOXCMD_LREAD ;\r\n}\r\nif( cmd->cmd_len == 6 ) {\r\nmbox->m_out.numsectors = (u32) cmd->cmnd[4];\r\nmbox->m_out.lba =\r\n((u32)cmd->cmnd[1] << 16) |\r\n((u32)cmd->cmnd[2] << 8) |\r\n(u32)cmd->cmnd[3];\r\nmbox->m_out.lba &= 0x1FFFFF;\r\n#if MEGA_HAVE_STATS\r\nif (*cmd->cmnd == READ_6) {\r\nadapter->nreads[ldrv_num%0x80]++;\r\nadapter->nreadblocks[ldrv_num%0x80] +=\r\nmbox->m_out.numsectors;\r\n} else {\r\nadapter->nwrites[ldrv_num%0x80]++;\r\nadapter->nwriteblocks[ldrv_num%0x80] +=\r\nmbox->m_out.numsectors;\r\n}\r\n#endif\r\n}\r\nif( cmd->cmd_len == 10 ) {\r\nmbox->m_out.numsectors =\r\n(u32)cmd->cmnd[8] |\r\n((u32)cmd->cmnd[7] << 8);\r\nmbox->m_out.lba =\r\n((u32)cmd->cmnd[2] << 24) |\r\n((u32)cmd->cmnd[3] << 16) |\r\n((u32)cmd->cmnd[4] << 8) |\r\n(u32)cmd->cmnd[5];\r\n#if MEGA_HAVE_STATS\r\nif (*cmd->cmnd == READ_10) {\r\nadapter->nreads[ldrv_num%0x80]++;\r\nadapter->nreadblocks[ldrv_num%0x80] +=\r\nmbox->m_out.numsectors;\r\n} else {\r\nadapter->nwrites[ldrv_num%0x80]++;\r\nadapter->nwriteblocks[ldrv_num%0x80] +=\r\nmbox->m_out.numsectors;\r\n}\r\n#endif\r\n}\r\nif( cmd->cmd_len == 12 ) {\r\nmbox->m_out.lba =\r\n((u32)cmd->cmnd[2] << 24) |\r\n((u32)cmd->cmnd[3] << 16) |\r\n((u32)cmd->cmnd[4] << 8) |\r\n(u32)cmd->cmnd[5];\r\nmbox->m_out.numsectors =\r\n((u32)cmd->cmnd[6] << 24) |\r\n((u32)cmd->cmnd[7] << 16) |\r\n((u32)cmd->cmnd[8] << 8) |\r\n(u32)cmd->cmnd[9];\r\n#if MEGA_HAVE_STATS\r\nif (*cmd->cmnd == READ_12) {\r\nadapter->nreads[ldrv_num%0x80]++;\r\nadapter->nreadblocks[ldrv_num%0x80] +=\r\nmbox->m_out.numsectors;\r\n} else {\r\nadapter->nwrites[ldrv_num%0x80]++;\r\nadapter->nwriteblocks[ldrv_num%0x80] +=\r\nmbox->m_out.numsectors;\r\n}\r\n#endif\r\n}\r\nif( (*cmd->cmnd & 0x0F) == 0x08 ) {\r\nscb->dma_direction = PCI_DMA_FROMDEVICE;\r\n}\r\nelse {\r\nscb->dma_direction = PCI_DMA_TODEVICE;\r\n}\r\nmbox->m_out.numsgelements = mega_build_sglist(adapter, scb,\r\n(u32 *)&mbox->m_out.xferaddr, (u32 *)&seg);\r\nreturn scb;\r\n#if MEGA_HAVE_CLUSTERING\r\ncase RESERVE:\r\ncase RELEASE:\r\nif( ! adapter->has_cluster ) {\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\nreturn NULL;\r\n}\r\nif(!(scb = mega_allocate_scb(adapter, cmd))) {\r\n*busy = 1;\r\nreturn NULL;\r\n}\r\nscb->raw_mbox[0] = MEGA_CLUSTER_CMD;\r\nscb->raw_mbox[2] = ( *cmd->cmnd == RESERVE ) ?\r\nMEGA_RESERVE_LD : MEGA_RELEASE_LD;\r\nscb->raw_mbox[3] = ldrv_num;\r\nscb->dma_direction = PCI_DMA_NONE;\r\nreturn scb;\r\n#endif\r\ndefault:\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\nreturn NULL;\r\n}\r\n}\r\nelse {\r\nif(!(scb = mega_allocate_scb(adapter, cmd))) {\r\n*busy = 1;\r\nreturn NULL;\r\n}\r\nmbox = (mbox_t *)scb->raw_mbox;\r\nmemset(mbox, 0, sizeof(scb->raw_mbox));\r\nif( adapter->support_ext_cdb ) {\r\nepthru = mega_prepare_extpassthru(adapter, scb, cmd,\r\nchannel, target);\r\nmbox->m_out.cmd = MEGA_MBOXCMD_EXTPTHRU;\r\nmbox->m_out.xferaddr = scb->epthru_dma_addr;\r\n}\r\nelse {\r\npthru = mega_prepare_passthru(adapter, scb, cmd,\r\nchannel, target);\r\nif( adapter->has_64bit_addr ) {\r\nmbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU64;\r\n}\r\nelse {\r\nmbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU;\r\n}\r\nmbox->m_out.xferaddr = scb->pthru_dma_addr;\r\n}\r\nreturn scb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic mega_passthru *\r\nmega_prepare_passthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,\r\nint channel, int target)\r\n{\r\nmega_passthru *pthru;\r\npthru = scb->pthru;\r\nmemset(pthru, 0, sizeof (mega_passthru));\r\npthru->timeout = 2;\r\npthru->ars = 1;\r\npthru->reqsenselen = 14;\r\npthru->islogical = 0;\r\npthru->channel = (adapter->flag & BOARD_40LD) ? 0 : channel;\r\npthru->target = (adapter->flag & BOARD_40LD) ?\r\n(channel << 4) | target : target;\r\npthru->cdblen = cmd->cmd_len;\r\npthru->logdrv = cmd->device->lun;\r\nmemcpy(pthru->cdb, cmd->cmnd, cmd->cmd_len);\r\nscb->dma_direction = PCI_DMA_BIDIRECTIONAL;\r\nswitch (cmd->cmnd[0]) {\r\ncase INQUIRY:\r\ncase READ_CAPACITY:\r\nif(!(adapter->flag & (1L << cmd->device->channel))) {\r\nprintk(KERN_NOTICE\r\n"scsi%d: scanning scsi channel %d [P%d] ",\r\nadapter->host->host_no,\r\ncmd->device->channel, channel);\r\nprintk("for physical devices.\n");\r\nadapter->flag |= (1L << cmd->device->channel);\r\n}\r\ndefault:\r\npthru->numsgelements = mega_build_sglist(adapter, scb,\r\n&pthru->dataxferaddr, &pthru->dataxferlen);\r\nbreak;\r\n}\r\nreturn pthru;\r\n}\r\nstatic mega_ext_passthru *\r\nmega_prepare_extpassthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,\r\nint channel, int target)\r\n{\r\nmega_ext_passthru *epthru;\r\nepthru = scb->epthru;\r\nmemset(epthru, 0, sizeof(mega_ext_passthru));\r\nepthru->timeout = 2;\r\nepthru->ars = 1;\r\nepthru->reqsenselen = 14;\r\nepthru->islogical = 0;\r\nepthru->channel = (adapter->flag & BOARD_40LD) ? 0 : channel;\r\nepthru->target = (adapter->flag & BOARD_40LD) ?\r\n(channel << 4) | target : target;\r\nepthru->cdblen = cmd->cmd_len;\r\nepthru->logdrv = cmd->device->lun;\r\nmemcpy(epthru->cdb, cmd->cmnd, cmd->cmd_len);\r\nscb->dma_direction = PCI_DMA_BIDIRECTIONAL;\r\nswitch(cmd->cmnd[0]) {\r\ncase INQUIRY:\r\ncase READ_CAPACITY:\r\nif(!(adapter->flag & (1L << cmd->device->channel))) {\r\nprintk(KERN_NOTICE\r\n"scsi%d: scanning scsi channel %d [P%d] ",\r\nadapter->host->host_no,\r\ncmd->device->channel, channel);\r\nprintk("for physical devices.\n");\r\nadapter->flag |= (1L << cmd->device->channel);\r\n}\r\ndefault:\r\nepthru->numsgelements = mega_build_sglist(adapter, scb,\r\n&epthru->dataxferaddr, &epthru->dataxferlen);\r\nbreak;\r\n}\r\nreturn epthru;\r\n}\r\nstatic void\r\n__mega_runpendq(adapter_t *adapter)\r\n{\r\nscb_t *scb;\r\nstruct list_head *pos, *next;\r\nlist_for_each_safe(pos, next, &adapter->pending_list) {\r\nscb = list_entry(pos, scb_t, list);\r\nif( !(scb->state & SCB_ISSUED) ) {\r\nif( issue_scb(adapter, scb) != 0 )\r\nreturn;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nissue_scb(adapter_t *adapter, scb_t *scb)\r\n{\r\nvolatile mbox64_t *mbox64 = adapter->mbox64;\r\nvolatile mbox_t *mbox = adapter->mbox;\r\nunsigned int i = 0;\r\nif(unlikely(mbox->m_in.busy)) {\r\ndo {\r\nudelay(1);\r\ni++;\r\n} while( mbox->m_in.busy && (i < max_mbox_busy_wait) );\r\nif(mbox->m_in.busy) return -1;\r\n}\r\nmemcpy((char *)&mbox->m_out, (char *)scb->raw_mbox,\r\nsizeof(struct mbox_out));\r\nmbox->m_out.cmdid = scb->idx;\r\nmbox->m_in.busy = 1;\r\natomic_inc(&adapter->pend_cmds);\r\nswitch (mbox->m_out.cmd) {\r\ncase MEGA_MBOXCMD_LREAD64:\r\ncase MEGA_MBOXCMD_LWRITE64:\r\ncase MEGA_MBOXCMD_PASSTHRU64:\r\ncase MEGA_MBOXCMD_EXTPTHRU:\r\nmbox64->xfer_segment_lo = mbox->m_out.xferaddr;\r\nmbox64->xfer_segment_hi = 0;\r\nmbox->m_out.xferaddr = 0xFFFFFFFF;\r\nbreak;\r\ndefault:\r\nmbox64->xfer_segment_lo = 0;\r\nmbox64->xfer_segment_hi = 0;\r\n}\r\nscb->state |= SCB_ISSUED;\r\nif( likely(adapter->flag & BOARD_MEMMAP) ) {\r\nmbox->m_in.poll = 0;\r\nmbox->m_in.ack = 0;\r\nWRINDOOR(adapter, adapter->mbox_dma | 0x1);\r\n}\r\nelse {\r\nirq_enable(adapter);\r\nissue_command(adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\nmega_busywait_mbox (adapter_t *adapter)\r\n{\r\nif (adapter->mbox->m_in.busy)\r\nreturn __mega_busywait_mbox(adapter);\r\nreturn 0;\r\n}\r\nstatic int\r\nissue_scb_block(adapter_t *adapter, u_char *raw_mbox)\r\n{\r\nvolatile mbox64_t *mbox64 = adapter->mbox64;\r\nvolatile mbox_t *mbox = adapter->mbox;\r\nu8 byte;\r\nif(mega_busywait_mbox (adapter))\r\ngoto bug_blocked_mailbox;\r\nmemcpy((char *) mbox, raw_mbox, sizeof(struct mbox_out));\r\nmbox->m_out.cmdid = 0xFE;\r\nmbox->m_in.busy = 1;\r\nswitch (raw_mbox[0]) {\r\ncase MEGA_MBOXCMD_LREAD64:\r\ncase MEGA_MBOXCMD_LWRITE64:\r\ncase MEGA_MBOXCMD_PASSTHRU64:\r\ncase MEGA_MBOXCMD_EXTPTHRU:\r\nmbox64->xfer_segment_lo = mbox->m_out.xferaddr;\r\nmbox64->xfer_segment_hi = 0;\r\nmbox->m_out.xferaddr = 0xFFFFFFFF;\r\nbreak;\r\ndefault:\r\nmbox64->xfer_segment_lo = 0;\r\nmbox64->xfer_segment_hi = 0;\r\n}\r\nif( likely(adapter->flag & BOARD_MEMMAP) ) {\r\nmbox->m_in.poll = 0;\r\nmbox->m_in.ack = 0;\r\nmbox->m_in.numstatus = 0xFF;\r\nmbox->m_in.status = 0xFF;\r\nWRINDOOR(adapter, adapter->mbox_dma | 0x1);\r\nwhile((volatile u8)mbox->m_in.numstatus == 0xFF)\r\ncpu_relax();\r\nmbox->m_in.numstatus = 0xFF;\r\nwhile( (volatile u8)mbox->m_in.poll != 0x77 )\r\ncpu_relax();\r\nmbox->m_in.poll = 0;\r\nmbox->m_in.ack = 0x77;\r\nWRINDOOR(adapter, adapter->mbox_dma | 0x2);\r\nwhile(RDINDOOR(adapter) & 0x2)\r\ncpu_relax();\r\n}\r\nelse {\r\nirq_disable(adapter);\r\nissue_command(adapter);\r\nwhile (!((byte = irq_state(adapter)) & INTR_VALID))\r\ncpu_relax();\r\nset_irq_state(adapter, byte);\r\nirq_enable(adapter);\r\nirq_ack(adapter);\r\n}\r\nreturn mbox->m_in.status;\r\nbug_blocked_mailbox:\r\nprintk(KERN_WARNING "megaraid: Blocked mailbox......!!\n");\r\nudelay (1000);\r\nreturn -1;\r\n}\r\nstatic irqreturn_t\r\nmegaraid_isr_iomapped(int irq, void *devp)\r\n{\r\nadapter_t *adapter = devp;\r\nunsigned long flags;\r\nu8 status;\r\nu8 nstatus;\r\nu8 completed[MAX_FIRMWARE_STATUS];\r\nu8 byte;\r\nint handled = 0;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\ndo {\r\nbyte = irq_state(adapter);\r\nif( (byte & VALID_INTR_BYTE) == 0 ) {\r\ngoto out_unlock;\r\n}\r\nset_irq_state(adapter, byte);\r\nwhile((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)\r\n== 0xFF)\r\ncpu_relax();\r\nadapter->mbox->m_in.numstatus = 0xFF;\r\nstatus = adapter->mbox->m_in.status;\r\natomic_sub(nstatus, &adapter->pend_cmds);\r\nmemcpy(completed, (void *)adapter->mbox->m_in.completed,\r\nnstatus);\r\nirq_ack(adapter);\r\nmega_cmd_done(adapter, completed, nstatus, status);\r\nmega_rundoneq(adapter);\r\nhandled = 1;\r\nif(atomic_read(&adapter->quiescent) == 0) {\r\nmega_runpendq(adapter);\r\n}\r\n} while(1);\r\nout_unlock:\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic irqreturn_t\r\nmegaraid_isr_memmapped(int irq, void *devp)\r\n{\r\nadapter_t *adapter = devp;\r\nunsigned long flags;\r\nu8 status;\r\nu32 dword = 0;\r\nu8 nstatus;\r\nu8 completed[MAX_FIRMWARE_STATUS];\r\nint handled = 0;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\ndo {\r\ndword = RDOUTDOOR(adapter);\r\nif(dword != 0x10001234) {\r\ngoto out_unlock;\r\n}\r\nWROUTDOOR(adapter, 0x10001234);\r\nwhile((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)\r\n== 0xFF) {\r\ncpu_relax();\r\n}\r\nadapter->mbox->m_in.numstatus = 0xFF;\r\nstatus = adapter->mbox->m_in.status;\r\natomic_sub(nstatus, &adapter->pend_cmds);\r\nmemcpy(completed, (void *)adapter->mbox->m_in.completed,\r\nnstatus);\r\nWRINDOOR(adapter, 0x2);\r\nhandled = 1;\r\nwhile( RDINDOOR(adapter) & 0x02 )\r\ncpu_relax();\r\nmega_cmd_done(adapter, completed, nstatus, status);\r\nmega_rundoneq(adapter);\r\nif(atomic_read(&adapter->quiescent) == 0) {\r\nmega_runpendq(adapter);\r\n}\r\n} while(1);\r\nout_unlock:\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void\r\nmega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)\r\n{\r\nmega_ext_passthru *epthru = NULL;\r\nstruct scatterlist *sgl;\r\nScsi_Cmnd *cmd = NULL;\r\nmega_passthru *pthru = NULL;\r\nmbox_t *mbox = NULL;\r\nu8 c;\r\nscb_t *scb;\r\nint islogical;\r\nint cmdid;\r\nint i;\r\nfor( i = 0; i < nstatus; i++ ) {\r\ncmdid = completed[i];\r\nif( cmdid == CMDID_INT_CMDS ) {\r\nscb = &adapter->int_scb;\r\ncmd = scb->cmd;\r\nmbox = (mbox_t *)scb->raw_mbox;\r\npthru = scb->pthru;\r\n}\r\nelse {\r\nscb = &adapter->scb_list[cmdid];\r\nif( !(scb->state & SCB_ISSUED) || scb->cmd == NULL ) {\r\nprintk(KERN_CRIT\r\n"megaraid: invalid command ");\r\nprintk("Id %d, scb->state:%x, scsi cmd:%p\n",\r\ncmdid, scb->state, scb->cmd);\r\ncontinue;\r\n}\r\nif( scb->state & SCB_ABORT ) {\r\nprintk(KERN_WARNING\r\n"megaraid: aborted cmd [%x] complete.\n",\r\nscb->idx);\r\nscb->cmd->result = (DID_ABORT << 16);\r\nlist_add_tail(SCSI_LIST(scb->cmd),\r\n&adapter->completed_list);\r\nmega_free_scb(adapter, scb);\r\ncontinue;\r\n}\r\nif( scb->state & SCB_RESET ) {\r\nprintk(KERN_WARNING\r\n"megaraid: reset cmd [%x] complete.\n",\r\nscb->idx);\r\nscb->cmd->result = (DID_RESET << 16);\r\nlist_add_tail(SCSI_LIST(scb->cmd),\r\n&adapter->completed_list);\r\nmega_free_scb (adapter, scb);\r\ncontinue;\r\n}\r\ncmd = scb->cmd;\r\npthru = scb->pthru;\r\nepthru = scb->epthru;\r\nmbox = (mbox_t *)scb->raw_mbox;\r\n#if MEGA_HAVE_STATS\r\n{\r\nint logdrv = mbox->m_out.logdrv;\r\nislogical = adapter->logdrv_chan[cmd->channel];\r\nif( status && islogical && (cmd->cmnd[0] == READ_6 ||\r\ncmd->cmnd[0] == READ_10 ||\r\ncmd->cmnd[0] == READ_12)) {\r\nadapter->rd_errors[logdrv%0x80]++;\r\n}\r\nif( status && islogical && (cmd->cmnd[0] == WRITE_6 ||\r\ncmd->cmnd[0] == WRITE_10 ||\r\ncmd->cmnd[0] == WRITE_12)) {\r\nadapter->wr_errors[logdrv%0x80]++;\r\n}\r\n}\r\n#endif\r\n}\r\nislogical = adapter->logdrv_chan[cmd->device->channel];\r\nif( cmd->cmnd[0] == INQUIRY && !islogical ) {\r\nsgl = scsi_sglist(cmd);\r\nif( sg_page(sgl) ) {\r\nc = *(unsigned char *) sg_virt(&sgl[0]);\r\n} else {\r\nprintk(KERN_WARNING\r\n"megaraid: invalid sg.\n");\r\nc = 0;\r\n}\r\nif(IS_RAID_CH(adapter, cmd->device->channel) &&\r\n((c & 0x1F ) == TYPE_DISK)) {\r\nstatus = 0xF0;\r\n}\r\n}\r\ncmd->result = 0;\r\nswitch (status) {\r\ncase 0x00:\r\ncmd->result |= (DID_OK << 16);\r\nbreak;\r\ncase 0x02:\r\nif( mbox->m_out.cmd == MEGA_MBOXCMD_PASSTHRU ||\r\nmbox->m_out.cmd == MEGA_MBOXCMD_PASSTHRU64 ) {\r\nmemcpy(cmd->sense_buffer, pthru->reqsensearea,\r\n14);\r\ncmd->result = (DRIVER_SENSE << 24) |\r\n(DID_OK << 16) |\r\n(CHECK_CONDITION << 1);\r\n}\r\nelse {\r\nif (mbox->m_out.cmd == MEGA_MBOXCMD_EXTPTHRU) {\r\nmemcpy(cmd->sense_buffer,\r\nepthru->reqsensearea, 14);\r\ncmd->result = (DRIVER_SENSE << 24) |\r\n(DID_OK << 16) |\r\n(CHECK_CONDITION << 1);\r\n} else {\r\ncmd->sense_buffer[0] = 0x70;\r\ncmd->sense_buffer[2] = ABORTED_COMMAND;\r\ncmd->result |= (CHECK_CONDITION << 1);\r\n}\r\n}\r\nbreak;\r\ncase 0x08:\r\ncmd->result |= (DID_BUS_BUSY << 16) | status;\r\nbreak;\r\ndefault:\r\n#if MEGA_HAVE_CLUSTERING\r\nif( cmd->cmnd[0] == TEST_UNIT_READY ) {\r\ncmd->result |= (DID_ERROR << 16) |\r\n(RESERVATION_CONFLICT << 1);\r\n}\r\nelse\r\nif( status == 1 &&\r\n(cmd->cmnd[0] == RESERVE ||\r\ncmd->cmnd[0] == RELEASE) ) {\r\ncmd->result |= (DID_ERROR << 16) |\r\n(RESERVATION_CONFLICT << 1);\r\n}\r\nelse\r\n#endif\r\ncmd->result |= (DID_BAD_TARGET << 16)|status;\r\n}\r\nif( cmdid == CMDID_INT_CMDS ) {\r\ncmd->result = status;\r\nlist_del_init(&scb->list);\r\nscb->state = SCB_FREE;\r\n}\r\nelse {\r\nmega_free_scb(adapter, scb);\r\n}\r\nlist_add_tail(SCSI_LIST(cmd), &adapter->completed_list);\r\n}\r\n}\r\nstatic void\r\nmega_rundoneq (adapter_t *adapter)\r\n{\r\nScsi_Cmnd *cmd;\r\nstruct list_head *pos;\r\nlist_for_each(pos, &adapter->completed_list) {\r\nstruct scsi_pointer* spos = (struct scsi_pointer *)pos;\r\ncmd = list_entry(spos, Scsi_Cmnd, SCp);\r\ncmd->scsi_done(cmd);\r\n}\r\nINIT_LIST_HEAD(&adapter->completed_list);\r\n}\r\nstatic void\r\nmega_free_scb(adapter_t *adapter, scb_t *scb)\r\n{\r\nswitch( scb->dma_type ) {\r\ncase MEGA_DMA_TYPE_NONE:\r\nbreak;\r\ncase MEGA_SGLIST:\r\nscsi_dma_unmap(scb->cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlist_del_init(&scb->list);\r\nscb->state = SCB_FREE;\r\nscb->cmd = NULL;\r\nlist_add(&scb->list, &adapter->free_list);\r\n}\r\nstatic int\r\n__mega_busywait_mbox (adapter_t *adapter)\r\n{\r\nvolatile mbox_t *mbox = adapter->mbox;\r\nlong counter;\r\nfor (counter = 0; counter < 10000; counter++) {\r\nif (!mbox->m_in.busy)\r\nreturn 0;\r\nudelay(100);\r\ncond_resched();\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\nmega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)\r\n{\r\nstruct scatterlist *sg;\r\nScsi_Cmnd *cmd;\r\nint sgcnt;\r\nint idx;\r\ncmd = scb->cmd;\r\nsgcnt = scsi_dma_map(cmd);\r\nscb->dma_type = MEGA_SGLIST;\r\nBUG_ON(sgcnt > adapter->sglen || sgcnt < 0);\r\n*len = 0;\r\nif (scsi_sg_count(cmd) == 1 && !adapter->has_64bit_addr) {\r\nsg = scsi_sglist(cmd);\r\nscb->dma_h_bulkdata = sg_dma_address(sg);\r\n*buf = (u32)scb->dma_h_bulkdata;\r\n*len = sg_dma_len(sg);\r\nreturn 0;\r\n}\r\nscsi_for_each_sg(cmd, sg, sgcnt, idx) {\r\nif (adapter->has_64bit_addr) {\r\nscb->sgl64[idx].address = sg_dma_address(sg);\r\n*len += scb->sgl64[idx].length = sg_dma_len(sg);\r\n} else {\r\nscb->sgl[idx].address = sg_dma_address(sg);\r\n*len += scb->sgl[idx].length = sg_dma_len(sg);\r\n}\r\n}\r\n*buf = scb->sgl_dma_addr;\r\nreturn sgcnt;\r\n}\r\nstatic void\r\nmega_8_to_40ld(mraid_inquiry *inquiry, mega_inquiry3 *enquiry3,\r\nmega_product_info *product_info)\r\n{\r\nint i;\r\nproduct_info->max_commands = inquiry->adapter_info.max_commands;\r\nenquiry3->rebuild_rate = inquiry->adapter_info.rebuild_rate;\r\nproduct_info->nchannels = inquiry->adapter_info.nchannels;\r\nfor (i = 0; i < 4; i++) {\r\nproduct_info->fw_version[i] =\r\ninquiry->adapter_info.fw_version[i];\r\nproduct_info->bios_version[i] =\r\ninquiry->adapter_info.bios_version[i];\r\n}\r\nenquiry3->cache_flush_interval =\r\ninquiry->adapter_info.cache_flush_interval;\r\nproduct_info->dram_size = inquiry->adapter_info.dram_size;\r\nenquiry3->num_ldrv = inquiry->logdrv_info.num_ldrv;\r\nfor (i = 0; i < MAX_LOGICAL_DRIVES_8LD; i++) {\r\nenquiry3->ldrv_size[i] = inquiry->logdrv_info.ldrv_size[i];\r\nenquiry3->ldrv_prop[i] = inquiry->logdrv_info.ldrv_prop[i];\r\nenquiry3->ldrv_state[i] = inquiry->logdrv_info.ldrv_state[i];\r\n}\r\nfor (i = 0; i < (MAX_PHYSICAL_DRIVES); i++)\r\nenquiry3->pdrv_state[i] = inquiry->pdrv_info.pdrv_state[i];\r\n}\r\nstatic inline void\r\nmega_free_sgl(adapter_t *adapter)\r\n{\r\nscb_t *scb;\r\nint i;\r\nfor(i = 0; i < adapter->max_cmds; i++) {\r\nscb = &adapter->scb_list[i];\r\nif( scb->sgl64 ) {\r\npci_free_consistent(adapter->dev,\r\nsizeof(mega_sgl64) * adapter->sglen,\r\nscb->sgl64,\r\nscb->sgl_dma_addr);\r\nscb->sgl64 = NULL;\r\n}\r\nif( scb->pthru ) {\r\npci_free_consistent(adapter->dev, sizeof(mega_passthru),\r\nscb->pthru, scb->pthru_dma_addr);\r\nscb->pthru = NULL;\r\n}\r\nif( scb->epthru ) {\r\npci_free_consistent(adapter->dev,\r\nsizeof(mega_ext_passthru),\r\nscb->epthru, scb->epthru_dma_addr);\r\nscb->epthru = NULL;\r\n}\r\n}\r\n}\r\nconst char *\r\nmegaraid_info(struct Scsi_Host *host)\r\n{\r\nstatic char buffer[512];\r\nadapter_t *adapter;\r\nadapter = (adapter_t *)host->hostdata;\r\nsprintf (buffer,\r\n"LSI Logic MegaRAID %s %d commands %d targs %d chans %d luns",\r\nadapter->fw_version, adapter->product_info.max_commands,\r\nadapter->host->max_id, adapter->host->max_channel,\r\nadapter->host->max_lun);\r\nreturn buffer;\r\n}\r\nstatic int\r\nmegaraid_abort(Scsi_Cmnd *cmd)\r\n{\r\nadapter_t *adapter;\r\nint rval;\r\nadapter = (adapter_t *)cmd->device->host->hostdata;\r\nrval = megaraid_abort_and_reset(adapter, cmd, SCB_ABORT);\r\nmega_rundoneq(adapter);\r\nreturn rval;\r\n}\r\nstatic int\r\nmegaraid_reset(struct scsi_cmnd *cmd)\r\n{\r\nadapter_t *adapter;\r\nmegacmd_t mc;\r\nint rval;\r\nadapter = (adapter_t *)cmd->device->host->hostdata;\r\n#if MEGA_HAVE_CLUSTERING\r\nmc.cmd = MEGA_CLUSTER_CMD;\r\nmc.opcode = MEGA_RESET_RESERVATIONS;\r\nif( mega_internal_command(adapter, &mc, NULL) != 0 ) {\r\nprintk(KERN_WARNING\r\n"megaraid: reservation reset failed.\n");\r\n}\r\nelse {\r\nprintk(KERN_INFO "megaraid: reservation reset.\n");\r\n}\r\n#endif\r\nspin_lock_irq(&adapter->lock);\r\nrval = megaraid_abort_and_reset(adapter, cmd, SCB_RESET);\r\nmega_rundoneq(adapter);\r\nspin_unlock_irq(&adapter->lock);\r\nreturn rval;\r\n}\r\nstatic int\r\nmegaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)\r\n{\r\nstruct list_head *pos, *next;\r\nscb_t *scb;\r\nprintk(KERN_WARNING "megaraid: %s cmd=%x <c=%d t=%d l=%d>\n",\r\n(aor == SCB_ABORT)? "ABORTING":"RESET",\r\ncmd->cmnd[0], cmd->device->channel,\r\ncmd->device->id, cmd->device->lun);\r\nif(list_empty(&adapter->pending_list))\r\nreturn FALSE;\r\nlist_for_each_safe(pos, next, &adapter->pending_list) {\r\nscb = list_entry(pos, scb_t, list);\r\nif (scb->cmd == cmd) {\r\nscb->state |= aor;\r\nif( scb->state & SCB_ISSUED ) {\r\nprintk(KERN_WARNING\r\n"megaraid: %s[%x], fw owner.\n",\r\n(aor==SCB_ABORT) ? "ABORTING":"RESET",\r\nscb->idx);\r\nreturn FALSE;\r\n}\r\nelse {\r\nprintk(KERN_WARNING\r\n"megaraid: %s-[%x], driver owner.\n",\r\n(aor==SCB_ABORT) ? "ABORTING":"RESET",\r\nscb->idx);\r\nmega_free_scb(adapter, scb);\r\nif( aor == SCB_ABORT ) {\r\ncmd->result = (DID_ABORT << 16);\r\n}\r\nelse {\r\ncmd->result = (DID_RESET << 16);\r\n}\r\nlist_add_tail(SCSI_LIST(cmd),\r\n&adapter->completed_list);\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic inline int\r\nmake_local_pdev(adapter_t *adapter, struct pci_dev **pdev)\r\n{\r\n*pdev = alloc_pci_dev();\r\nif( *pdev == NULL ) return -1;\r\nmemcpy(*pdev, adapter->dev, sizeof(struct pci_dev));\r\nif( pci_set_dma_mask(*pdev, DMA_BIT_MASK(32)) != 0 ) {\r\nkfree(*pdev);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nfree_local_pdev(struct pci_dev *pdev)\r\n{\r\nkfree(pdev);\r\n}\r\nstatic inline void *\r\nmega_allocate_inquiry(dma_addr_t *dma_handle, struct pci_dev *pdev)\r\n{\r\nreturn pci_alloc_consistent(pdev, sizeof(mega_inquiry3), dma_handle);\r\n}\r\nstatic inline void\r\nmega_free_inquiry(void *inquiry, dma_addr_t dma_handle, struct pci_dev *pdev)\r\n{\r\npci_free_consistent(pdev, sizeof(mega_inquiry3), inquiry, dma_handle);\r\n}\r\nstatic void\r\nmega_create_proc_entry(int index, struct proc_dir_entry *parent)\r\n{\r\nstruct proc_dir_entry *controller_proc_dir_entry = NULL;\r\nu8 string[64] = { 0 };\r\nadapter_t *adapter = hba_soft_state[index];\r\nsprintf(string, "hba%d", adapter->host->host_no);\r\ncontroller_proc_dir_entry =\r\nadapter->controller_proc_dir_entry = proc_mkdir(string, parent);\r\nif(!controller_proc_dir_entry) {\r\nprintk(KERN_WARNING "\nmegaraid: proc_mkdir failed\n");\r\nreturn;\r\n}\r\nadapter->proc_read = CREATE_READ_PROC("config", proc_read_config);\r\nadapter->proc_stat = CREATE_READ_PROC("stat", proc_read_stat);\r\nadapter->proc_mbox = CREATE_READ_PROC("mailbox", proc_read_mbox);\r\n#if MEGA_HAVE_ENH_PROC\r\nadapter->proc_rr = CREATE_READ_PROC("rebuild-rate", proc_rebuild_rate);\r\nadapter->proc_battery = CREATE_READ_PROC("battery-status",\r\nproc_battery);\r\nadapter->proc_pdrvstat[0] = CREATE_READ_PROC("diskdrives-ch0",\r\nproc_pdrv_ch0);\r\nadapter->proc_pdrvstat[1] = CREATE_READ_PROC("diskdrives-ch1",\r\nproc_pdrv_ch1);\r\nadapter->proc_pdrvstat[2] = CREATE_READ_PROC("diskdrives-ch2",\r\nproc_pdrv_ch2);\r\nadapter->proc_pdrvstat[3] = CREATE_READ_PROC("diskdrives-ch3",\r\nproc_pdrv_ch3);\r\nadapter->proc_rdrvstat[0] = CREATE_READ_PROC("raiddrives-0-9",\r\nproc_rdrv_10);\r\nadapter->proc_rdrvstat[1] = CREATE_READ_PROC("raiddrives-10-19",\r\nproc_rdrv_20);\r\nadapter->proc_rdrvstat[2] = CREATE_READ_PROC("raiddrives-20-29",\r\nproc_rdrv_30);\r\nadapter->proc_rdrvstat[3] = CREATE_READ_PROC("raiddrives-30-39",\r\nproc_rdrv_40);\r\n#endif\r\n}\r\nstatic int\r\nproc_read_config(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\nint len = 0;\r\nlen += sprintf(page+len, "%s", MEGARAID_VERSION);\r\nif(adapter->product_info.product_name[0])\r\nlen += sprintf(page+len, "%s\n",\r\nadapter->product_info.product_name);\r\nlen += sprintf(page+len, "Controller Type: ");\r\nif( adapter->flag & BOARD_MEMMAP ) {\r\nlen += sprintf(page+len,\r\n"438/466/467/471/493/518/520/531/532\n");\r\n}\r\nelse {\r\nlen += sprintf(page+len,\r\n"418/428/434\n");\r\n}\r\nif(adapter->flag & BOARD_40LD) {\r\nlen += sprintf(page+len,\r\n"Controller Supports 40 Logical Drives\n");\r\n}\r\nif(adapter->flag & BOARD_64BIT) {\r\nlen += sprintf(page+len,\r\n"Controller capable of 64-bit memory addressing\n");\r\n}\r\nif( adapter->has_64bit_addr ) {\r\nlen += sprintf(page+len,\r\n"Controller using 64-bit memory addressing\n");\r\n}\r\nelse {\r\nlen += sprintf(page+len,\r\n"Controller is not using 64-bit memory addressing\n");\r\n}\r\nlen += sprintf(page+len, "Base = %08lx, Irq = %d, ", adapter->base,\r\nadapter->host->irq);\r\nlen += sprintf(page+len, "Logical Drives = %d, Channels = %d\n",\r\nadapter->numldrv, adapter->product_info.nchannels);\r\nlen += sprintf(page+len, "Version =%s:%s, DRAM = %dMb\n",\r\nadapter->fw_version, adapter->bios_version,\r\nadapter->product_info.dram_size);\r\nlen += sprintf(page+len,\r\n"Controller Queue Depth = %d, Driver Queue Depth = %d\n",\r\nadapter->product_info.max_commands, adapter->max_cmds);\r\nlen += sprintf(page+len, "support_ext_cdb = %d\n",\r\nadapter->support_ext_cdb);\r\nlen += sprintf(page+len, "support_random_del = %d\n",\r\nadapter->support_random_del);\r\nlen += sprintf(page+len, "boot_ldrv_enabled = %d\n",\r\nadapter->boot_ldrv_enabled);\r\nlen += sprintf(page+len, "boot_ldrv = %d\n",\r\nadapter->boot_ldrv);\r\nlen += sprintf(page+len, "boot_pdrv_enabled = %d\n",\r\nadapter->boot_pdrv_enabled);\r\nlen += sprintf(page+len, "boot_pdrv_ch = %d\n",\r\nadapter->boot_pdrv_ch);\r\nlen += sprintf(page+len, "boot_pdrv_tgt = %d\n",\r\nadapter->boot_pdrv_tgt);\r\nlen += sprintf(page+len, "quiescent = %d\n",\r\natomic_read(&adapter->quiescent));\r\nlen += sprintf(page+len, "has_cluster = %d\n",\r\nadapter->has_cluster);\r\nlen += sprintf(page+len, "\nModule Parameters:\n");\r\nlen += sprintf(page+len, "max_cmd_per_lun = %d\n",\r\nmax_cmd_per_lun);\r\nlen += sprintf(page+len, "max_sectors_per_io = %d\n",\r\nmax_sectors_per_io);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nstatic int\r\nproc_read_stat(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter;\r\nint len;\r\nint i;\r\ni = 0;\r\nlen = 0;\r\nadapter = (adapter_t *)data;\r\nlen = sprintf(page, "Statistical Information for this controller\n");\r\nlen += sprintf(page+len, "pend_cmds = %d\n",\r\natomic_read(&adapter->pend_cmds));\r\n#if MEGA_HAVE_STATS\r\nfor(i = 0; i < adapter->numldrv; i++) {\r\nlen += sprintf(page+len, "Logical Drive %d:\n", i);\r\nlen += sprintf(page+len,\r\n"\tReads Issued = %lu, Writes Issued = %lu\n",\r\nadapter->nreads[i], adapter->nwrites[i]);\r\nlen += sprintf(page+len,\r\n"\tSectors Read = %lu, Sectors Written = %lu\n",\r\nadapter->nreadblocks[i], adapter->nwriteblocks[i]);\r\nlen += sprintf(page+len,\r\n"\tRead errors = %lu, Write errors = %lu\n\n",\r\nadapter->rd_errors[i], adapter->wr_errors[i]);\r\n}\r\n#else\r\nlen += sprintf(page+len,\r\n"IO and error counters not compiled in driver.\n");\r\n#endif\r\n*eof = 1;\r\nreturn len;\r\n}\r\nstatic int\r\nproc_read_mbox(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\nvolatile mbox_t *mbox = adapter->mbox;\r\nint len = 0;\r\nlen = sprintf(page, "Contents of Mail Box Structure\n");\r\nlen += sprintf(page+len, " Fw Command = 0x%02x\n",\r\nmbox->m_out.cmd);\r\nlen += sprintf(page+len, " Cmd Sequence = 0x%02x\n",\r\nmbox->m_out.cmdid);\r\nlen += sprintf(page+len, " No of Sectors= %04d\n",\r\nmbox->m_out.numsectors);\r\nlen += sprintf(page+len, " LBA = 0x%02x\n",\r\nmbox->m_out.lba);\r\nlen += sprintf(page+len, " DTA = 0x%08x\n",\r\nmbox->m_out.xferaddr);\r\nlen += sprintf(page+len, " Logical Drive= 0x%02x\n",\r\nmbox->m_out.logdrv);\r\nlen += sprintf(page+len, " No of SG Elmt= 0x%02x\n",\r\nmbox->m_out.numsgelements);\r\nlen += sprintf(page+len, " Busy = %01x\n",\r\nmbox->m_in.busy);\r\nlen += sprintf(page+len, " Status = 0x%02x\n",\r\nmbox->m_in.status);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nstatic int\r\nproc_rebuild_rate(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\ndma_addr_t dma_handle;\r\ncaddr_t inquiry;\r\nstruct pci_dev *pdev;\r\nint len = 0;\r\nif( make_local_pdev(adapter, &pdev) != 0 ) {\r\n*eof = 1;\r\nreturn len;\r\n}\r\nif( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {\r\nfree_local_pdev(pdev);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nif( mega_adapinq(adapter, dma_handle) != 0 ) {\r\nlen = sprintf(page, "Adapter inquiry failed.\n");\r\nprintk(KERN_WARNING "megaraid: inquiry failed.\n");\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\nfree_local_pdev(pdev);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nif( adapter->flag & BOARD_40LD ) {\r\nlen = sprintf(page, "Rebuild Rate: [%d%%]\n",\r\n((mega_inquiry3 *)inquiry)->rebuild_rate);\r\n}\r\nelse {\r\nlen = sprintf(page, "Rebuild Rate: [%d%%]\n",\r\n((mraid_ext_inquiry *)\r\ninquiry)->raid_inq.adapter_info.rebuild_rate);\r\n}\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\nfree_local_pdev(pdev);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nstatic int\r\nproc_battery(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\ndma_addr_t dma_handle;\r\ncaddr_t inquiry;\r\nstruct pci_dev *pdev;\r\nu8 battery_status = 0;\r\nchar str[256];\r\nint len = 0;\r\nif( make_local_pdev(adapter, &pdev) != 0 ) {\r\n*eof = 1;\r\nreturn len;\r\n}\r\nif( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {\r\nfree_local_pdev(pdev);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nif( mega_adapinq(adapter, dma_handle) != 0 ) {\r\nlen = sprintf(page, "Adapter inquiry failed.\n");\r\nprintk(KERN_WARNING "megaraid: inquiry failed.\n");\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\nfree_local_pdev(pdev);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nif( adapter->flag & BOARD_40LD ) {\r\nbattery_status = ((mega_inquiry3 *)inquiry)->battery_status;\r\n}\r\nelse {\r\nbattery_status = ((mraid_ext_inquiry *)inquiry)->\r\nraid_inq.adapter_info.battery_status;\r\n}\r\nsprintf(str, "Battery Status:[%d]", battery_status);\r\nif(battery_status == MEGA_BATT_CHARGE_DONE)\r\nstrcat(str, " Charge Done");\r\nif(battery_status & MEGA_BATT_MODULE_MISSING)\r\nstrcat(str, " Module Missing");\r\nif(battery_status & MEGA_BATT_LOW_VOLTAGE)\r\nstrcat(str, " Low Voltage");\r\nif(battery_status & MEGA_BATT_TEMP_HIGH)\r\nstrcat(str, " Temperature High");\r\nif(battery_status & MEGA_BATT_PACK_MISSING)\r\nstrcat(str, " Pack Missing");\r\nif(battery_status & MEGA_BATT_CHARGE_INPROG)\r\nstrcat(str, " Charge In-progress");\r\nif(battery_status & MEGA_BATT_CHARGE_FAIL)\r\nstrcat(str, " Charge Fail");\r\nif(battery_status & MEGA_BATT_CYCLES_EXCEEDED)\r\nstrcat(str, " Cycles Exceeded");\r\nlen = sprintf(page, "%s\n", str);\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\nfree_local_pdev(pdev);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nstatic int\r\nproc_pdrv_ch0(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\n*eof = 1;\r\nreturn (proc_pdrv(adapter, page, 0));\r\n}\r\nstatic int\r\nproc_pdrv_ch1(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\n*eof = 1;\r\nreturn (proc_pdrv(adapter, page, 1));\r\n}\r\nstatic int\r\nproc_pdrv_ch2(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\n*eof = 1;\r\nreturn (proc_pdrv(adapter, page, 2));\r\n}\r\nstatic int\r\nproc_pdrv_ch3(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\n*eof = 1;\r\nreturn (proc_pdrv(adapter, page, 3));\r\n}\r\nstatic int\r\nproc_pdrv(adapter_t *adapter, char *page, int channel)\r\n{\r\ndma_addr_t dma_handle;\r\nchar *scsi_inq;\r\ndma_addr_t scsi_inq_dma_handle;\r\ncaddr_t inquiry;\r\nstruct pci_dev *pdev;\r\nu8 *pdrv_state;\r\nu8 state;\r\nint tgt;\r\nint max_channels;\r\nint len = 0;\r\nchar str[80];\r\nint i;\r\nif( make_local_pdev(adapter, &pdev) != 0 ) {\r\nreturn len;\r\n}\r\nif( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {\r\ngoto free_pdev;\r\n}\r\nif( mega_adapinq(adapter, dma_handle) != 0 ) {\r\nlen = sprintf(page, "Adapter inquiry failed.\n");\r\nprintk(KERN_WARNING "megaraid: inquiry failed.\n");\r\ngoto free_inquiry;\r\n}\r\nscsi_inq = pci_alloc_consistent(pdev, 256, &scsi_inq_dma_handle);\r\nif( scsi_inq == NULL ) {\r\nlen = sprintf(page, "memory not available for scsi inq.\n");\r\ngoto free_inquiry;\r\n}\r\nif( adapter->flag & BOARD_40LD ) {\r\npdrv_state = ((mega_inquiry3 *)inquiry)->pdrv_state;\r\n}\r\nelse {\r\npdrv_state = ((mraid_ext_inquiry *)inquiry)->\r\nraid_inq.pdrv_info.pdrv_state;\r\n}\r\nmax_channels = adapter->product_info.nchannels;\r\nif( channel >= max_channels ) {\r\ngoto free_pci;\r\n}\r\nfor( tgt = 0; tgt <= MAX_TARGET; tgt++ ) {\r\ni = channel*16 + tgt;\r\nstate = *(pdrv_state + i);\r\nswitch( state & 0x0F ) {\r\ncase PDRV_ONLINE:\r\nsprintf(str,\r\n"Channel:%2d Id:%2d State: Online",\r\nchannel, tgt);\r\nbreak;\r\ncase PDRV_FAILED:\r\nsprintf(str,\r\n"Channel:%2d Id:%2d State: Failed",\r\nchannel, tgt);\r\nbreak;\r\ncase PDRV_RBLD:\r\nsprintf(str,\r\n"Channel:%2d Id:%2d State: Rebuild",\r\nchannel, tgt);\r\nbreak;\r\ncase PDRV_HOTSPARE:\r\nsprintf(str,\r\n"Channel:%2d Id:%2d State: Hot spare",\r\nchannel, tgt);\r\nbreak;\r\ndefault:\r\nsprintf(str,\r\n"Channel:%2d Id:%2d State: Un-configured",\r\nchannel, tgt);\r\nbreak;\r\n}\r\nmemset(scsi_inq, 0, 256);\r\nif( mega_internal_dev_inquiry(adapter, channel, tgt,\r\nscsi_inq_dma_handle) ||\r\n(scsi_inq[0] & 0x1F) != TYPE_DISK ) {\r\ncontinue;\r\n}\r\nif( (len + 240) >= PAGE_SIZE ) break;\r\nlen += sprintf(page+len, "%s.\n", str);\r\nlen += mega_print_inquiry(page+len, scsi_inq);\r\n}\r\nfree_pci:\r\npci_free_consistent(pdev, 256, scsi_inq, scsi_inq_dma_handle);\r\nfree_inquiry:\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\nfree_pdev:\r\nfree_local_pdev(pdev);\r\nreturn len;\r\n}\r\nstatic int\r\nmega_print_inquiry(char *page, char *scsi_inq)\r\n{\r\nint len = 0;\r\nint i;\r\nlen = sprintf(page, " Vendor: ");\r\nfor( i = 8; i < 16; i++ ) {\r\nlen += sprintf(page+len, "%c", scsi_inq[i]);\r\n}\r\nlen += sprintf(page+len, " Model: ");\r\nfor( i = 16; i < 32; i++ ) {\r\nlen += sprintf(page+len, "%c", scsi_inq[i]);\r\n}\r\nlen += sprintf(page+len, " Rev: ");\r\nfor( i = 32; i < 36; i++ ) {\r\nlen += sprintf(page+len, "%c", scsi_inq[i]);\r\n}\r\nlen += sprintf(page+len, "\n");\r\ni = scsi_inq[0] & 0x1f;\r\nlen += sprintf(page+len, " Type: %s ", scsi_device_type(i));\r\nlen += sprintf(page+len,\r\n" ANSI SCSI revision: %02x", scsi_inq[2] & 0x07);\r\nif( (scsi_inq[2] & 0x07) == 1 && (scsi_inq[3] & 0x0f) == 1 )\r\nlen += sprintf(page+len, " CCS\n");\r\nelse\r\nlen += sprintf(page+len, "\n");\r\nreturn len;\r\n}\r\nstatic int\r\nproc_rdrv_10(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\n*eof = 1;\r\nreturn (proc_rdrv(adapter, page, 0, 9));\r\n}\r\nstatic int\r\nproc_rdrv_20(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\n*eof = 1;\r\nreturn (proc_rdrv(adapter, page, 10, 19));\r\n}\r\nstatic int\r\nproc_rdrv_30(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\n*eof = 1;\r\nreturn (proc_rdrv(adapter, page, 20, 29));\r\n}\r\nstatic int\r\nproc_rdrv_40(char *page, char **start, off_t offset, int count, int *eof,\r\nvoid *data)\r\n{\r\nadapter_t *adapter = (adapter_t *)data;\r\n*eof = 1;\r\nreturn (proc_rdrv(adapter, page, 30, 39));\r\n}\r\nstatic int\r\nproc_rdrv(adapter_t *adapter, char *page, int start, int end )\r\n{\r\ndma_addr_t dma_handle;\r\nlogdrv_param *lparam;\r\nmegacmd_t mc;\r\nchar *disk_array;\r\ndma_addr_t disk_array_dma_handle;\r\ncaddr_t inquiry;\r\nstruct pci_dev *pdev;\r\nu8 *rdrv_state;\r\nint num_ldrv;\r\nu32 array_sz;\r\nint len = 0;\r\nint i;\r\nif( make_local_pdev(adapter, &pdev) != 0 ) {\r\nreturn len;\r\n}\r\nif( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {\r\nfree_local_pdev(pdev);\r\nreturn len;\r\n}\r\nif( mega_adapinq(adapter, dma_handle) != 0 ) {\r\nlen = sprintf(page, "Adapter inquiry failed.\n");\r\nprintk(KERN_WARNING "megaraid: inquiry failed.\n");\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\nfree_local_pdev(pdev);\r\nreturn len;\r\n}\r\nmemset(&mc, 0, sizeof(megacmd_t));\r\nif( adapter->flag & BOARD_40LD ) {\r\narray_sz = sizeof(disk_array_40ld);\r\nrdrv_state = ((mega_inquiry3 *)inquiry)->ldrv_state;\r\nnum_ldrv = ((mega_inquiry3 *)inquiry)->num_ldrv;\r\n}\r\nelse {\r\narray_sz = sizeof(disk_array_8ld);\r\nrdrv_state = ((mraid_ext_inquiry *)inquiry)->\r\nraid_inq.logdrv_info.ldrv_state;\r\nnum_ldrv = ((mraid_ext_inquiry *)inquiry)->\r\nraid_inq.logdrv_info.num_ldrv;\r\n}\r\ndisk_array = pci_alloc_consistent(pdev, array_sz,\r\n&disk_array_dma_handle);\r\nif( disk_array == NULL ) {\r\nlen = sprintf(page, "memory not available.\n");\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\nfree_local_pdev(pdev);\r\nreturn len;\r\n}\r\nmc.xferaddr = (u32)disk_array_dma_handle;\r\nif( adapter->flag & BOARD_40LD ) {\r\nmc.cmd = FC_NEW_CONFIG;\r\nmc.opcode = OP_DCMD_READ_CONFIG;\r\nif( mega_internal_command(adapter, &mc, NULL) ) {\r\nlen = sprintf(page, "40LD read config failed.\n");\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\npci_free_consistent(pdev, array_sz, disk_array,\r\ndisk_array_dma_handle);\r\nfree_local_pdev(pdev);\r\nreturn len;\r\n}\r\n}\r\nelse {\r\nmc.cmd = NEW_READ_CONFIG_8LD;\r\nif( mega_internal_command(adapter, &mc, NULL) ) {\r\nmc.cmd = READ_CONFIG_8LD;\r\nif( mega_internal_command(adapter, &mc,\r\nNULL) ){\r\nlen = sprintf(page,\r\n"8LD read config failed.\n");\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\npci_free_consistent(pdev, array_sz,\r\ndisk_array,\r\ndisk_array_dma_handle);\r\nfree_local_pdev(pdev);\r\nreturn len;\r\n}\r\n}\r\n}\r\nfor( i = start; i < ( (end+1 < num_ldrv) ? end+1 : num_ldrv ); i++ ) {\r\nif( adapter->flag & BOARD_40LD ) {\r\nlparam =\r\n&((disk_array_40ld *)disk_array)->ldrv[i].lparam;\r\n}\r\nelse {\r\nlparam =\r\n&((disk_array_8ld *)disk_array)->ldrv[i].lparam;\r\n}\r\nif( (len + 240) >= PAGE_SIZE ) break;\r\nlen += sprintf(page+len, "Logical drive:%2d:, ", i);\r\nswitch( rdrv_state[i] & 0x0F ) {\r\ncase RDRV_OFFLINE:\r\nlen += sprintf(page+len, "state: offline");\r\nbreak;\r\ncase RDRV_DEGRADED:\r\nlen += sprintf(page+len, "state: degraded");\r\nbreak;\r\ncase RDRV_OPTIMAL:\r\nlen += sprintf(page+len, "state: optimal");\r\nbreak;\r\ncase RDRV_DELETED:\r\nlen += sprintf(page+len, "state: deleted");\r\nbreak;\r\ndefault:\r\nlen += sprintf(page+len, "state: unknown");\r\nbreak;\r\n}\r\nif( (rdrv_state[i] & 0xF0) == 0x20 ) {\r\nlen += sprintf(page+len,\r\n", check-consistency in progress");\r\n}\r\nelse if( (rdrv_state[i] & 0xF0) == 0x10 ) {\r\nlen += sprintf(page+len,\r\n", initialization in progress");\r\n}\r\nlen += sprintf(page+len, "\n");\r\nlen += sprintf(page+len, "Span depth:%3d, ",\r\nlparam->span_depth);\r\nlen += sprintf(page+len, "RAID level:%3d, ",\r\nlparam->level);\r\nlen += sprintf(page+len, "Stripe size:%3d, ",\r\nlparam->stripe_sz ? lparam->stripe_sz/2: 128);\r\nlen += sprintf(page+len, "Row size:%3d\n",\r\nlparam->row_size);\r\nlen += sprintf(page+len, "Read Policy: ");\r\nswitch(lparam->read_ahead) {\r\ncase NO_READ_AHEAD:\r\nlen += sprintf(page+len, "No read ahead, ");\r\nbreak;\r\ncase READ_AHEAD:\r\nlen += sprintf(page+len, "Read ahead, ");\r\nbreak;\r\ncase ADAP_READ_AHEAD:\r\nlen += sprintf(page+len, "Adaptive, ");\r\nbreak;\r\n}\r\nlen += sprintf(page+len, "Write Policy: ");\r\nswitch(lparam->write_mode) {\r\ncase WRMODE_WRITE_THRU:\r\nlen += sprintf(page+len, "Write thru, ");\r\nbreak;\r\ncase WRMODE_WRITE_BACK:\r\nlen += sprintf(page+len, "Write back, ");\r\nbreak;\r\n}\r\nlen += sprintf(page+len, "Cache Policy: ");\r\nswitch(lparam->direct_io) {\r\ncase CACHED_IO:\r\nlen += sprintf(page+len, "Cached IO\n\n");\r\nbreak;\r\ncase DIRECT_IO:\r\nlen += sprintf(page+len, "Direct IO\n\n");\r\nbreak;\r\n}\r\n}\r\nmega_free_inquiry(inquiry, dma_handle, pdev);\r\npci_free_consistent(pdev, array_sz, disk_array,\r\ndisk_array_dma_handle);\r\nfree_local_pdev(pdev);\r\nreturn len;\r\n}\r\nstatic inline void mega_create_proc_entry(int index, struct proc_dir_entry *parent)\r\n{\r\n}\r\nstatic int\r\nmegaraid_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nadapter_t *adapter;\r\nunsigned char *bh;\r\nint heads;\r\nint sectors;\r\nint cylinders;\r\nint rval;\r\nadapter = (adapter_t *)sdev->host->hostdata;\r\nif (IS_RAID_CH(adapter, sdev->channel)) {\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = (ulong)capacity / (heads * sectors);\r\nif ((ulong)capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = (ulong)capacity / (heads * sectors);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\n}\r\nelse {\r\nbh = scsi_bios_ptable(bdev);\r\nif( bh ) {\r\nrval = scsi_partsize(bh, capacity,\r\n&geom[2], &geom[0], &geom[1]);\r\nkfree(bh);\r\nif( rval != -1 )\r\nreturn rval;\r\n}\r\nprintk(KERN_INFO\r\n"megaraid: invalid partition on this disk on channel %d\n",\r\nsdev->channel);\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = (ulong)capacity / (heads * sectors);\r\nif ((ulong)capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = (ulong)capacity / (heads * sectors);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmega_init_scb(adapter_t *adapter)\r\n{\r\nscb_t *scb;\r\nint i;\r\nfor( i = 0; i < adapter->max_cmds; i++ ) {\r\nscb = &adapter->scb_list[i];\r\nscb->sgl64 = NULL;\r\nscb->sgl = NULL;\r\nscb->pthru = NULL;\r\nscb->epthru = NULL;\r\n}\r\nfor( i = 0; i < adapter->max_cmds; i++ ) {\r\nscb = &adapter->scb_list[i];\r\nscb->idx = i;\r\nscb->sgl64 = pci_alloc_consistent(adapter->dev,\r\nsizeof(mega_sgl64) * adapter->sglen,\r\n&scb->sgl_dma_addr);\r\nscb->sgl = (mega_sglist *)scb->sgl64;\r\nif( !scb->sgl ) {\r\nprintk(KERN_WARNING "RAID: Can't allocate sglist.\n");\r\nmega_free_sgl(adapter);\r\nreturn -1;\r\n}\r\nscb->pthru = pci_alloc_consistent(adapter->dev,\r\nsizeof(mega_passthru),\r\n&scb->pthru_dma_addr);\r\nif( !scb->pthru ) {\r\nprintk(KERN_WARNING "RAID: Can't allocate passthru.\n");\r\nmega_free_sgl(adapter);\r\nreturn -1;\r\n}\r\nscb->epthru = pci_alloc_consistent(adapter->dev,\r\nsizeof(mega_ext_passthru),\r\n&scb->epthru_dma_addr);\r\nif( !scb->epthru ) {\r\nprintk(KERN_WARNING\r\n"Can't allocate extended passthru.\n");\r\nmega_free_sgl(adapter);\r\nreturn -1;\r\n}\r\nscb->dma_type = MEGA_DMA_TYPE_NONE;\r\nscb->state = SCB_FREE;\r\nscb->cmd = NULL;\r\nlist_add(&scb->list, &adapter->free_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegadev_open (struct inode *inode, struct file *filep)\r\n{\r\nif( !capable(CAP_SYS_ADMIN) ) return -EACCES;\r\nreturn 0;\r\n}\r\nstatic int\r\nmegadev_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nadapter_t *adapter;\r\nnitioctl_t uioc;\r\nint adapno;\r\nint rval;\r\nmega_passthru __user *upthru;\r\nmega_passthru *pthru;\r\ndma_addr_t pthru_dma_hndl;\r\nvoid *data = NULL;\r\ndma_addr_t data_dma_hndl;\r\nmegacmd_t mc;\r\nmegastat_t __user *ustats;\r\nint num_ldrv;\r\nu32 uxferaddr = 0;\r\nstruct pci_dev *pdev;\r\nustats = NULL;\r\nnum_ldrv = 0;\r\nif( (_IOC_TYPE(cmd) != MEGAIOC_MAGIC) && (cmd != USCSICMD) ) {\r\nreturn -EINVAL;\r\n}\r\nmemset(&uioc, 0, sizeof(nitioctl_t));\r\nif( (rval = mega_m_to_n( (void __user *)arg, &uioc)) != 0 )\r\nreturn rval;\r\nswitch( uioc.opcode ) {\r\ncase GET_DRIVER_VER:\r\nif( put_user(driver_ver, (u32 __user *)uioc.uioc_uaddr) )\r\nreturn (-EFAULT);\r\nbreak;\r\ncase GET_N_ADAP:\r\nif( put_user(hba_count, (u32 __user *)uioc.uioc_uaddr) )\r\nreturn (-EFAULT);\r\nreturn hba_count;\r\ncase GET_ADAP_INFO:\r\nif( (adapno = GETADAP(uioc.adapno)) >= hba_count )\r\nreturn (-ENODEV);\r\nif( copy_to_user(uioc.uioc_uaddr, mcontroller+adapno,\r\nsizeof(struct mcontroller)) )\r\nreturn (-EFAULT);\r\nbreak;\r\n#if MEGA_HAVE_STATS\r\ncase GET_STATS:\r\nif( (adapno = GETADAP(uioc.adapno)) >= hba_count )\r\nreturn (-ENODEV);\r\nadapter = hba_soft_state[adapno];\r\nustats = uioc.uioc_uaddr;\r\nif( copy_from_user(&num_ldrv, &ustats->num_ldrv, sizeof(int)) )\r\nreturn (-EFAULT);\r\nif( num_ldrv >= MAX_LOGICAL_DRIVES_40LD ) return -EINVAL;\r\nif( copy_to_user(ustats->nreads, adapter->nreads,\r\nnum_ldrv*sizeof(u32)) )\r\nreturn -EFAULT;\r\nif( copy_to_user(ustats->nreadblocks, adapter->nreadblocks,\r\nnum_ldrv*sizeof(u32)) )\r\nreturn -EFAULT;\r\nif( copy_to_user(ustats->nwrites, adapter->nwrites,\r\nnum_ldrv*sizeof(u32)) )\r\nreturn -EFAULT;\r\nif( copy_to_user(ustats->nwriteblocks, adapter->nwriteblocks,\r\nnum_ldrv*sizeof(u32)) )\r\nreturn -EFAULT;\r\nif( copy_to_user(ustats->rd_errors, adapter->rd_errors,\r\nnum_ldrv*sizeof(u32)) )\r\nreturn -EFAULT;\r\nif( copy_to_user(ustats->wr_errors, adapter->wr_errors,\r\nnum_ldrv*sizeof(u32)) )\r\nreturn -EFAULT;\r\nreturn 0;\r\n#endif\r\ncase MBOX_CMD:\r\nif( (adapno = GETADAP(uioc.adapno)) >= hba_count )\r\nreturn (-ENODEV);\r\nadapter = hba_soft_state[adapno];\r\nif( uioc.uioc_rmbox[0] == FC_DEL_LOGDRV &&\r\nuioc.uioc_rmbox[2] == OP_DEL_LOGDRV ) {\r\nif( !adapter->support_random_del ) {\r\nprintk(KERN_WARNING "megaraid: logdrv ");\r\nprintk("delete on non-supporting F/W.\n");\r\nreturn (-EINVAL);\r\n}\r\nrval = mega_del_logdrv( adapter, uioc.uioc_rmbox[3] );\r\nif( rval == 0 ) {\r\nmemset(&mc, 0, sizeof(megacmd_t));\r\nmc.status = rval;\r\nrval = mega_n_to_m((void __user *)arg, &mc);\r\n}\r\nreturn rval;\r\n}\r\nif( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU64 ||\r\nuioc.uioc_rmbox[0] == MEGA_MBOXCMD_EXTPTHRU ) {\r\nprintk(KERN_WARNING "megaraid: rejected passthru.\n");\r\nreturn (-EINVAL);\r\n}\r\nif( make_local_pdev(adapter, &pdev) != 0 )\r\nreturn -EIO;\r\nif( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU ) {\r\npthru = pci_alloc_consistent(pdev,\r\nsizeof(mega_passthru),\r\n&pthru_dma_hndl);\r\nif( pthru == NULL ) {\r\nfree_local_pdev(pdev);\r\nreturn (-ENOMEM);\r\n}\r\nupthru = (mega_passthru __user *)(unsigned long)MBOX(uioc)->xferaddr;\r\nif( copy_from_user(pthru, upthru,\r\nsizeof(mega_passthru)) ) {\r\npci_free_consistent(pdev,\r\nsizeof(mega_passthru), pthru,\r\npthru_dma_hndl);\r\nfree_local_pdev(pdev);\r\nreturn (-EFAULT);\r\n}\r\nif( pthru->dataxferlen ) {\r\ndata = pci_alloc_consistent(pdev,\r\npthru->dataxferlen,\r\n&data_dma_hndl);\r\nif( data == NULL ) {\r\npci_free_consistent(pdev,\r\nsizeof(mega_passthru),\r\npthru,\r\npthru_dma_hndl);\r\nfree_local_pdev(pdev);\r\nreturn (-ENOMEM);\r\n}\r\nuxferaddr = pthru->dataxferaddr;\r\npthru->dataxferaddr = data_dma_hndl;\r\n}\r\nif( pthru->dataxferlen && (uioc.flags & UIOC_WR) ) {\r\nif( copy_from_user(data, (char __user *)(unsigned long) uxferaddr,\r\npthru->dataxferlen) ) {\r\nrval = (-EFAULT);\r\ngoto freemem_and_return;\r\n}\r\n}\r\nmemset(&mc, 0, sizeof(megacmd_t));\r\nmc.cmd = MEGA_MBOXCMD_PASSTHRU;\r\nmc.xferaddr = (u32)pthru_dma_hndl;\r\nmega_internal_command(adapter, &mc, pthru);\r\nrval = mega_n_to_m((void __user *)arg, &mc);\r\nif( rval ) goto freemem_and_return;\r\nif( pthru->dataxferlen && (uioc.flags & UIOC_RD) ) {\r\nif( copy_to_user((char __user *)(unsigned long) uxferaddr, data,\r\npthru->dataxferlen) ) {\r\nrval = (-EFAULT);\r\n}\r\n}\r\nif (copy_to_user(upthru->reqsensearea,\r\npthru->reqsensearea, 14))\r\nrval = -EFAULT;\r\nfreemem_and_return:\r\nif( pthru->dataxferlen ) {\r\npci_free_consistent(pdev,\r\npthru->dataxferlen, data,\r\ndata_dma_hndl);\r\n}\r\npci_free_consistent(pdev, sizeof(mega_passthru),\r\npthru, pthru_dma_hndl);\r\nfree_local_pdev(pdev);\r\nreturn rval;\r\n}\r\nelse {\r\nif( uioc.xferlen ) {\r\ndata = pci_alloc_consistent(pdev,\r\nuioc.xferlen, &data_dma_hndl);\r\nif( data == NULL ) {\r\nfree_local_pdev(pdev);\r\nreturn (-ENOMEM);\r\n}\r\nuxferaddr = MBOX(uioc)->xferaddr;\r\n}\r\nif( uioc.xferlen && (uioc.flags & UIOC_WR) ) {\r\nif( copy_from_user(data, (char __user *)(unsigned long) uxferaddr,\r\nuioc.xferlen) ) {\r\npci_free_consistent(pdev,\r\nuioc.xferlen,\r\ndata, data_dma_hndl);\r\nfree_local_pdev(pdev);\r\nreturn (-EFAULT);\r\n}\r\n}\r\nmemcpy(&mc, MBOX(uioc), sizeof(megacmd_t));\r\nmc.xferaddr = (u32)data_dma_hndl;\r\nmega_internal_command(adapter, &mc, NULL);\r\nrval = mega_n_to_m((void __user *)arg, &mc);\r\nif( rval ) {\r\nif( uioc.xferlen ) {\r\npci_free_consistent(pdev,\r\nuioc.xferlen, data,\r\ndata_dma_hndl);\r\n}\r\nfree_local_pdev(pdev);\r\nreturn rval;\r\n}\r\nif( uioc.xferlen && (uioc.flags & UIOC_RD) ) {\r\nif( copy_to_user((char __user *)(unsigned long) uxferaddr, data,\r\nuioc.xferlen) ) {\r\nrval = (-EFAULT);\r\n}\r\n}\r\nif( uioc.xferlen ) {\r\npci_free_consistent(pdev,\r\nuioc.xferlen, data,\r\ndata_dma_hndl);\r\n}\r\nfree_local_pdev(pdev);\r\nreturn rval;\r\n}\r\ndefault:\r\nreturn (-EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\nmegadev_unlocked_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&megadev_mutex);\r\nret = megadev_ioctl(filep, cmd, arg);\r\nmutex_unlock(&megadev_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nmega_m_to_n(void __user *arg, nitioctl_t *uioc)\r\n{\r\nstruct uioctl_t uioc_mimd;\r\nchar signature[8] = {0};\r\nu8 opcode;\r\nu8 subopcode;\r\nif( copy_from_user(signature, arg, 7) )\r\nreturn (-EFAULT);\r\nif( memcmp(signature, "MEGANIT", 7) == 0 ) {\r\nreturn -EINVAL;\r\n#if 0\r\nif( copy_from_user(uioc, arg, sizeof(nitioctl_t)) )\r\nreturn (-EFAULT);\r\nreturn 0;\r\n#endif\r\n}\r\nif( copy_from_user(&uioc_mimd, arg, sizeof(struct uioctl_t)) )\r\nreturn (-EFAULT);\r\nopcode = uioc_mimd.ui.fcs.opcode;\r\nsubopcode = uioc_mimd.ui.fcs.subopcode;\r\nswitch (opcode) {\r\ncase 0x82:\r\nswitch (subopcode) {\r\ncase MEGAIOC_QDRVRVER:\r\nuioc->opcode = GET_DRIVER_VER;\r\nuioc->uioc_uaddr = uioc_mimd.data;\r\nbreak;\r\ncase MEGAIOC_QNADAP:\r\nuioc->opcode = GET_N_ADAP;\r\nuioc->uioc_uaddr = uioc_mimd.data;\r\nbreak;\r\ncase MEGAIOC_QADAPINFO:\r\nuioc->opcode = GET_ADAP_INFO;\r\nuioc->adapno = uioc_mimd.ui.fcs.adapno;\r\nuioc->uioc_uaddr = uioc_mimd.data;\r\nbreak;\r\ndefault:\r\nreturn(-EINVAL);\r\n}\r\nbreak;\r\ncase 0x81:\r\nuioc->opcode = MBOX_CMD;\r\nuioc->adapno = uioc_mimd.ui.fcs.adapno;\r\nmemcpy(uioc->uioc_rmbox, uioc_mimd.mbox, 18);\r\nuioc->xferlen = uioc_mimd.ui.fcs.length;\r\nif( uioc_mimd.outlen ) uioc->flags = UIOC_RD;\r\nif( uioc_mimd.inlen ) uioc->flags |= UIOC_WR;\r\nbreak;\r\ncase 0x80:\r\nuioc->opcode = MBOX_CMD;\r\nuioc->adapno = uioc_mimd.ui.fcs.adapno;\r\nmemcpy(uioc->uioc_rmbox, uioc_mimd.mbox, 18);\r\nuioc->xferlen = uioc_mimd.outlen > uioc_mimd.inlen ?\r\nuioc_mimd.outlen : uioc_mimd.inlen;\r\nif( uioc_mimd.outlen ) uioc->flags = UIOC_RD;\r\nif( uioc_mimd.inlen ) uioc->flags |= UIOC_WR;\r\nbreak;\r\ndefault:\r\nreturn (-EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmega_n_to_m(void __user *arg, megacmd_t *mc)\r\n{\r\nnitioctl_t __user *uiocp;\r\nmegacmd_t __user *umc;\r\nmega_passthru __user *upthru;\r\nstruct uioctl_t __user *uioc_mimd;\r\nchar signature[8] = {0};\r\nif( copy_from_user(signature, arg, 7) )\r\nreturn -EFAULT;\r\nif( memcmp(signature, "MEGANIT", 7) == 0 ) {\r\nuiocp = arg;\r\nif( put_user(mc->status, (u8 __user *)&MBOX_P(uiocp)->status) )\r\nreturn (-EFAULT);\r\nif( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {\r\numc = MBOX_P(uiocp);\r\nif (get_user(upthru, (mega_passthru __user * __user *)&umc->xferaddr))\r\nreturn -EFAULT;\r\nif( put_user(mc->status, (u8 __user *)&upthru->scsistatus))\r\nreturn (-EFAULT);\r\n}\r\n}\r\nelse {\r\nuioc_mimd = arg;\r\nif( put_user(mc->status, (u8 __user *)&uioc_mimd->mbox[17]) )\r\nreturn (-EFAULT);\r\nif( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {\r\numc = (megacmd_t __user *)uioc_mimd->mbox;\r\nif (get_user(upthru, (mega_passthru __user * __user *)&umc->xferaddr))\r\nreturn (-EFAULT);\r\nif( put_user(mc->status, (u8 __user *)&upthru->scsistatus) )\r\nreturn (-EFAULT);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmega_is_bios_enabled(adapter_t *adapter)\r\n{\r\nunsigned char raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox;\r\nint ret;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset(&mbox->m_out, 0, sizeof(raw_mbox));\r\nmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\r\nmbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;\r\nraw_mbox[0] = IS_BIOS_ENABLED;\r\nraw_mbox[2] = GET_BIOS;\r\nret = issue_scb_block(adapter, raw_mbox);\r\nreturn *(char *)adapter->mega_buffer;\r\n}\r\nstatic void\r\nmega_enum_raid_scsi(adapter_t *adapter)\r\n{\r\nunsigned char raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox;\r\nint i;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset(&mbox->m_out, 0, sizeof(raw_mbox));\r\nraw_mbox[0] = CHNL_CLASS;\r\nraw_mbox[2] = GET_CHNL_CLASS;\r\nmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\r\nmbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;\r\nadapter->mega_ch_class = 0xFF;\r\nif(!issue_scb_block(adapter, raw_mbox)) {\r\nadapter->mega_ch_class = *((char *)adapter->mega_buffer);\r\n}\r\nfor( i = 0; i < adapter->product_info.nchannels; i++ ) {\r\nif( (adapter->mega_ch_class >> i) & 0x01 ) {\r\nprintk(KERN_INFO "megaraid: channel[%d] is raid.\n",\r\ni);\r\n}\r\nelse {\r\nprintk(KERN_INFO "megaraid: channel[%d] is scsi.\n",\r\ni);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nmega_get_boot_drv(adapter_t *adapter)\r\n{\r\nstruct private_bios_data *prv_bios_data;\r\nunsigned char raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox;\r\nu16 cksum = 0;\r\nu8 *cksum_p;\r\nu8 boot_pdrv;\r\nint i;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset(&mbox->m_out, 0, sizeof(raw_mbox));\r\nraw_mbox[0] = BIOS_PVT_DATA;\r\nraw_mbox[2] = GET_BIOS_PVT_DATA;\r\nmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\r\nmbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;\r\nadapter->boot_ldrv_enabled = 0;\r\nadapter->boot_ldrv = 0;\r\nadapter->boot_pdrv_enabled = 0;\r\nadapter->boot_pdrv_ch = 0;\r\nadapter->boot_pdrv_tgt = 0;\r\nif(issue_scb_block(adapter, raw_mbox) == 0) {\r\nprv_bios_data =\r\n(struct private_bios_data *)adapter->mega_buffer;\r\ncksum = 0;\r\ncksum_p = (char *)prv_bios_data;\r\nfor (i = 0; i < 14; i++ ) {\r\ncksum += (u16)(*cksum_p++);\r\n}\r\nif (prv_bios_data->cksum == (u16)(0-cksum) ) {\r\nif( prv_bios_data->boot_drv & 0x80 ) {\r\nadapter->boot_pdrv_enabled = 1;\r\nboot_pdrv = prv_bios_data->boot_drv & 0x7F;\r\nadapter->boot_pdrv_ch = boot_pdrv / 16;\r\nadapter->boot_pdrv_tgt = boot_pdrv % 16;\r\n}\r\nelse {\r\nadapter->boot_ldrv_enabled = 1;\r\nadapter->boot_ldrv = prv_bios_data->boot_drv;\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\nmega_support_random_del(adapter_t *adapter)\r\n{\r\nunsigned char raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox;\r\nint rval;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset(&mbox->m_out, 0, sizeof(raw_mbox));\r\nraw_mbox[0] = FC_DEL_LOGDRV;\r\nraw_mbox[2] = OP_SUP_DEL_LOGDRV;\r\nrval = issue_scb_block(adapter, raw_mbox);\r\nreturn !rval;\r\n}\r\nstatic int\r\nmega_support_ext_cdb(adapter_t *adapter)\r\n{\r\nunsigned char raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox;\r\nint rval;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset(&mbox->m_out, 0, sizeof(raw_mbox));\r\nraw_mbox[0] = 0xA4;\r\nraw_mbox[2] = 0x16;\r\nrval = issue_scb_block(adapter, raw_mbox);\r\nreturn !rval;\r\n}\r\nstatic int\r\nmega_del_logdrv(adapter_t *adapter, int logdrv)\r\n{\r\nunsigned long flags;\r\nscb_t *scb;\r\nint rval;\r\natomic_set(&adapter->quiescent, 1);\r\nwhile (atomic_read(&adapter->pend_cmds) > 0 ||\r\n!list_empty(&adapter->pending_list))\r\nmsleep(1000);\r\nrval = mega_do_del_logdrv(adapter, logdrv);\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nif (adapter->read_ldidmap) {\r\nstruct list_head *pos;\r\nlist_for_each(pos, &adapter->pending_list) {\r\nscb = list_entry(pos, scb_t, list);\r\nif (scb->pthru->logdrv < 0x80 )\r\nscb->pthru->logdrv += 0x80;\r\n}\r\n}\r\natomic_set(&adapter->quiescent, 0);\r\nmega_runpendq(adapter);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nreturn rval;\r\n}\r\nstatic int\r\nmega_do_del_logdrv(adapter_t *adapter, int logdrv)\r\n{\r\nmegacmd_t mc;\r\nint rval;\r\nmemset( &mc, 0, sizeof(megacmd_t));\r\nmc.cmd = FC_DEL_LOGDRV;\r\nmc.opcode = OP_DEL_LOGDRV;\r\nmc.subopcode = logdrv;\r\nrval = mega_internal_command(adapter, &mc, NULL);\r\nif(rval) {\r\nprintk(KERN_WARNING "megaraid: Delete LD-%d failed.", logdrv);\r\nreturn rval;\r\n}\r\nadapter->read_ldidmap = 1;\r\nreturn rval;\r\n}\r\nstatic void\r\nmega_get_max_sgl(adapter_t *adapter)\r\n{\r\nunsigned char raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset(mbox, 0, sizeof(raw_mbox));\r\nmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\r\nmbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;\r\nraw_mbox[0] = MAIN_MISC_OPCODE;\r\nraw_mbox[2] = GET_MAX_SG_SUPPORT;\r\nif( issue_scb_block(adapter, raw_mbox) ) {\r\nadapter->sglen = MIN_SGLIST;\r\n}\r\nelse {\r\nadapter->sglen = *((char *)adapter->mega_buffer);\r\nif ( adapter->sglen > MAX_SGLIST )\r\nadapter->sglen = MAX_SGLIST;\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nmega_support_cluster(adapter_t *adapter)\r\n{\r\nunsigned char raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset(mbox, 0, sizeof(raw_mbox));\r\nmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\r\nmbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;\r\nraw_mbox[0] = MEGA_GET_TARGET_ID;\r\nif( issue_scb_block(adapter, raw_mbox) == 0 ) {\r\nadapter->this_id = *(u32 *)adapter->mega_buffer;\r\nadapter->host->this_id = adapter->this_id;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmega_adapinq(adapter_t *adapter, dma_addr_t dma_handle)\r\n{\r\nmegacmd_t mc;\r\nmemset(&mc, 0, sizeof(megacmd_t));\r\nif( adapter->flag & BOARD_40LD ) {\r\nmc.cmd = FC_NEW_CONFIG;\r\nmc.opcode = NC_SUBOP_ENQUIRY3;\r\nmc.subopcode = ENQ3_GET_SOLICITED_FULL;\r\n}\r\nelse {\r\nmc.cmd = MEGA_MBOXCMD_ADPEXTINQ;\r\n}\r\nmc.xferaddr = (u32)dma_handle;\r\nif ( mega_internal_command(adapter, &mc, NULL) != 0 ) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,\r\ndma_addr_t buf_dma_handle)\r\n{\r\nmega_passthru *pthru;\r\ndma_addr_t pthru_dma_handle;\r\nmegacmd_t mc;\r\nint rval;\r\nstruct pci_dev *pdev;\r\nif( make_local_pdev(adapter, &pdev) != 0 ) return -1;\r\npthru = pci_alloc_consistent(pdev, sizeof(mega_passthru),\r\n&pthru_dma_handle);\r\nif( pthru == NULL ) {\r\nfree_local_pdev(pdev);\r\nreturn -1;\r\n}\r\npthru->timeout = 2;\r\npthru->ars = 1;\r\npthru->reqsenselen = 14;\r\npthru->islogical = 0;\r\npthru->channel = (adapter->flag & BOARD_40LD) ? 0 : ch;\r\npthru->target = (adapter->flag & BOARD_40LD) ? (ch << 4)|tgt : tgt;\r\npthru->cdblen = 6;\r\npthru->cdb[0] = INQUIRY;\r\npthru->cdb[1] = 0;\r\npthru->cdb[2] = 0;\r\npthru->cdb[3] = 0;\r\npthru->cdb[4] = 255;\r\npthru->cdb[5] = 0;\r\npthru->dataxferaddr = (u32)buf_dma_handle;\r\npthru->dataxferlen = 256;\r\nmemset(&mc, 0, sizeof(megacmd_t));\r\nmc.cmd = MEGA_MBOXCMD_PASSTHRU;\r\nmc.xferaddr = (u32)pthru_dma_handle;\r\nrval = mega_internal_command(adapter, &mc, pthru);\r\npci_free_consistent(pdev, sizeof(mega_passthru), pthru,\r\npthru_dma_handle);\r\nfree_local_pdev(pdev);\r\nreturn rval;\r\n}\r\nstatic int\r\nmega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)\r\n{\r\nScsi_Cmnd *scmd;\r\nstruct scsi_device *sdev;\r\nscb_t *scb;\r\nint rval;\r\nscmd = scsi_allocate_command(GFP_KERNEL);\r\nif (!scmd)\r\nreturn -ENOMEM;\r\nmutex_lock(&adapter->int_mtx);\r\nscb = &adapter->int_scb;\r\nmemset(scb, 0, sizeof(scb_t));\r\nsdev = kzalloc(sizeof(struct scsi_device), GFP_KERNEL);\r\nscmd->device = sdev;\r\nmemset(adapter->int_cdb, 0, sizeof(adapter->int_cdb));\r\nscmd->cmnd = adapter->int_cdb;\r\nscmd->device->host = adapter->host;\r\nscmd->host_scribble = (void *)scb;\r\nscmd->cmnd[0] = MEGA_INTERNAL_CMD;\r\nscb->state |= SCB_ACTIVE;\r\nscb->cmd = scmd;\r\nmemcpy(scb->raw_mbox, mc, sizeof(megacmd_t));\r\nif( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {\r\nscb->pthru = pthru;\r\n}\r\nscb->idx = CMDID_INT_CMDS;\r\nmegaraid_queue_lck(scmd, mega_internal_done);\r\nwait_for_completion(&adapter->int_waitq);\r\nrval = scmd->result;\r\nmc->status = scmd->result;\r\nkfree(sdev);\r\nif( scmd->result && trace_level ) {\r\nprintk("megaraid: cmd [%x, %x, %x] status:[%x]\n",\r\nmc->cmd, mc->opcode, mc->subopcode, scmd->result);\r\n}\r\nmutex_unlock(&adapter->int_mtx);\r\nscsi_free_command(GFP_KERNEL, scmd);\r\nreturn rval;\r\n}\r\nstatic void\r\nmega_internal_done(Scsi_Cmnd *scmd)\r\n{\r\nadapter_t *adapter;\r\nadapter = (adapter_t *)scmd->device->host->hostdata;\r\ncomplete(&adapter->int_waitq);\r\n}\r\nstatic int __devinit\r\nmegaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nadapter_t *adapter;\r\nunsigned long mega_baseport, tbase, flag = 0;\r\nu16 subsysid, subsysvid;\r\nu8 pci_bus, pci_dev_func;\r\nint irq, i, j;\r\nint error = -ENODEV;\r\nif (pci_enable_device(pdev))\r\ngoto out;\r\npci_set_master(pdev);\r\npci_bus = pdev->bus->number;\r\npci_dev_func = pdev->devfn;\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL) {\r\nu16 magic;\r\nif (pdev->subsystem_vendor == PCI_VENDOR_ID_COMPAQ &&\r\npdev->subsystem_device == 0xC000)\r\nreturn -ENODEV;\r\npci_read_config_word(pdev, PCI_CONF_AMISIG, &magic);\r\nif (magic != HBA_SIGNATURE_471 && magic != HBA_SIGNATURE)\r\nreturn -ENODEV;\r\n}\r\nif (id->driver_data & BOARD_64BIT)\r\nflag |= BOARD_64BIT;\r\nelse {\r\nu32 magic64;\r\npci_read_config_dword(pdev, PCI_CONF_AMISIG64, &magic64);\r\nif (magic64 == HBA_SIGNATURE_64BIT)\r\nflag |= BOARD_64BIT;\r\n}\r\nsubsysvid = pdev->subsystem_vendor;\r\nsubsysid = pdev->subsystem_device;\r\nprintk(KERN_NOTICE "megaraid: found 0x%4.04x:0x%4.04x:bus %d:",\r\nid->vendor, id->device, pci_bus);\r\nprintk("slot %d:func %d\n",\r\nPCI_SLOT(pci_dev_func), PCI_FUNC(pci_dev_func));\r\nmega_baseport = pci_resource_start(pdev, 0);\r\nirq = pdev->irq;\r\ntbase = mega_baseport;\r\nif (pci_resource_flags(pdev, 0) & IORESOURCE_MEM) {\r\nflag |= BOARD_MEMMAP;\r\nif (!request_mem_region(mega_baseport, 128, "megaraid")) {\r\nprintk(KERN_WARNING "megaraid: mem region busy!\n");\r\ngoto out_disable_device;\r\n}\r\nmega_baseport = (unsigned long)ioremap(mega_baseport, 128);\r\nif (!mega_baseport) {\r\nprintk(KERN_WARNING\r\n"megaraid: could not map hba memory\n");\r\ngoto out_release_region;\r\n}\r\n} else {\r\nflag |= BOARD_IOMAP;\r\nmega_baseport += 0x10;\r\nif (!request_region(mega_baseport, 16, "megaraid"))\r\ngoto out_disable_device;\r\n}\r\nhost = scsi_host_alloc(&megaraid_template, sizeof(adapter_t));\r\nif (!host)\r\ngoto out_iounmap;\r\nadapter = (adapter_t *)host->hostdata;\r\nmemset(adapter, 0, sizeof(adapter_t));\r\nprintk(KERN_NOTICE\r\n"scsi%d:Found MegaRAID controller at 0x%lx, IRQ:%d\n",\r\nhost->host_no, mega_baseport, irq);\r\nadapter->base = mega_baseport;\r\nif (flag & BOARD_MEMMAP)\r\nadapter->mmio_base = (void __iomem *) mega_baseport;\r\nINIT_LIST_HEAD(&adapter->free_list);\r\nINIT_LIST_HEAD(&adapter->pending_list);\r\nINIT_LIST_HEAD(&adapter->completed_list);\r\nadapter->flag = flag;\r\nspin_lock_init(&adapter->lock);\r\nhost->cmd_per_lun = max_cmd_per_lun;\r\nhost->max_sectors = max_sectors_per_io;\r\nadapter->dev = pdev;\r\nadapter->host = host;\r\nadapter->host->irq = irq;\r\nif (flag & BOARD_MEMMAP)\r\nadapter->host->base = tbase;\r\nelse {\r\nadapter->host->io_port = tbase;\r\nadapter->host->n_io_port = 16;\r\n}\r\nadapter->host->unique_id = (pci_bus << 8) | pci_dev_func;\r\nadapter->mega_buffer = pci_alloc_consistent(adapter->dev,\r\nMEGA_BUFFER_SIZE, &adapter->buf_dma_handle);\r\nif (!adapter->mega_buffer) {\r\nprintk(KERN_WARNING "megaraid: out of RAM.\n");\r\ngoto out_host_put;\r\n}\r\nadapter->scb_list = kmalloc(sizeof(scb_t) * MAX_COMMANDS, GFP_KERNEL);\r\nif (!adapter->scb_list) {\r\nprintk(KERN_WARNING "megaraid: out of RAM.\n");\r\ngoto out_free_cmd_buffer;\r\n}\r\nif (request_irq(irq, (adapter->flag & BOARD_MEMMAP) ?\r\nmegaraid_isr_memmapped : megaraid_isr_iomapped,\r\nIRQF_SHARED, "megaraid", adapter)) {\r\nprintk(KERN_WARNING\r\n"megaraid: Couldn't register IRQ %d!\n", irq);\r\ngoto out_free_scb_list;\r\n}\r\nif (mega_setup_mailbox(adapter))\r\ngoto out_free_irq;\r\nif (mega_query_adapter(adapter))\r\ngoto out_free_mbox;\r\nif ((subsysid == 0x1111) && (subsysvid == 0x1111)) {\r\nif (!strcmp(adapter->fw_version, "3.00") ||\r\n!strcmp(adapter->fw_version, "3.01")) {\r\nprintk( KERN_WARNING\r\n"megaraid: Your card is a Dell PERC "\r\n"2/SC RAID controller with "\r\n"firmware\nmegaraid: 3.00 or 3.01. "\r\n"This driver is known to have "\r\n"corruption issues\nmegaraid: with "\r\n"those firmware versions on this "\r\n"specific card. In order\nmegaraid: "\r\n"to protect your data, please upgrade "\r\n"your firmware to version\nmegaraid: "\r\n"3.10 or later, available from the "\r\n"Dell Technical Support web\n"\r\n"megaraid: site at\nhttp://support."\r\n"dell.com/us/en/filelib/download/"\r\n"index.asp?fileid=2940\n"\r\n);\r\n}\r\n}\r\nif ((subsysvid == HP_SUBSYS_VID) &&\r\n((subsysid == 0x60E7) || (subsysid == 0x60E8))) {\r\nif (!strcmp(adapter->fw_version, "H01.07") ||\r\n!strcmp(adapter->fw_version, "H01.08") ||\r\n!strcmp(adapter->fw_version, "H01.09") ) {\r\nprintk(KERN_WARNING\r\n"megaraid: Firmware H.01.07, "\r\n"H.01.08, and H.01.09 on 1M/2M "\r\n"controllers\n"\r\n"megaraid: do not support 64 bit "\r\n"addressing.\nmegaraid: DISABLING "\r\n"64 bit support.\n");\r\nadapter->flag &= ~BOARD_64BIT;\r\n}\r\n}\r\nif (mega_is_bios_enabled(adapter))\r\nmega_hbas[hba_count].is_bios_enabled = 1;\r\nmega_hbas[hba_count].hostdata_addr = adapter;\r\nmega_enum_raid_scsi(adapter);\r\nmega_get_boot_drv(adapter);\r\nif (adapter->boot_pdrv_enabled) {\r\nj = adapter->product_info.nchannels;\r\nfor( i = 0; i < j; i++ )\r\nadapter->logdrv_chan[i] = 0;\r\nfor( i = j; i < NVIRT_CHAN + j; i++ )\r\nadapter->logdrv_chan[i] = 1;\r\n} else {\r\nfor (i = 0; i < NVIRT_CHAN; i++)\r\nadapter->logdrv_chan[i] = 1;\r\nfor (i = NVIRT_CHAN; i < MAX_CHANNELS+NVIRT_CHAN; i++)\r\nadapter->logdrv_chan[i] = 0;\r\nadapter->mega_ch_class <<= NVIRT_CHAN;\r\n}\r\nadapter->read_ldidmap = 0;\r\nadapter->support_random_del = mega_support_random_del(adapter);\r\nif (mega_init_scb(adapter))\r\ngoto out_free_mbox;\r\natomic_set(&adapter->pend_cmds, 0);\r\natomic_set(&adapter->quiescent, 0);\r\nhba_soft_state[hba_count] = adapter;\r\ni = hba_count;\r\nmcontroller[i].base = mega_baseport;\r\nmcontroller[i].irq = irq;\r\nmcontroller[i].numldrv = adapter->numldrv;\r\nmcontroller[i].pcibus = pci_bus;\r\nmcontroller[i].pcidev = id->device;\r\nmcontroller[i].pcifun = PCI_FUNC (pci_dev_func);\r\nmcontroller[i].pciid = -1;\r\nmcontroller[i].pcivendor = id->vendor;\r\nmcontroller[i].pcislot = PCI_SLOT(pci_dev_func);\r\nmcontroller[i].uid = (pci_bus << 8) | pci_dev_func;\r\nif ((adapter->flag & BOARD_64BIT) && (sizeof(dma_addr_t) == 8)) {\r\npci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nadapter->has_64bit_addr = 1;\r\n} else {\r\npci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nadapter->has_64bit_addr = 0;\r\n}\r\nmutex_init(&adapter->int_mtx);\r\ninit_completion(&adapter->int_waitq);\r\nadapter->this_id = DEFAULT_INITIATOR_ID;\r\nadapter->host->this_id = DEFAULT_INITIATOR_ID;\r\n#if MEGA_HAVE_CLUSTERING\r\nadapter->has_cluster = mega_support_cluster(adapter);\r\nif (adapter->has_cluster) {\r\nprintk(KERN_NOTICE\r\n"megaraid: Cluster driver, initiator id:%d\n",\r\nadapter->this_id);\r\n}\r\n#endif\r\npci_set_drvdata(pdev, host);\r\nmega_create_proc_entry(hba_count, mega_proc_dir_entry);\r\nerror = scsi_add_host(host, &pdev->dev);\r\nif (error)\r\ngoto out_free_mbox;\r\nscsi_scan_host(host);\r\nhba_count++;\r\nreturn 0;\r\nout_free_mbox:\r\npci_free_consistent(adapter->dev, sizeof(mbox64_t),\r\nadapter->una_mbox64, adapter->una_mbox64_dma);\r\nout_free_irq:\r\nfree_irq(adapter->host->irq, adapter);\r\nout_free_scb_list:\r\nkfree(adapter->scb_list);\r\nout_free_cmd_buffer:\r\npci_free_consistent(adapter->dev, MEGA_BUFFER_SIZE,\r\nadapter->mega_buffer, adapter->buf_dma_handle);\r\nout_host_put:\r\nscsi_host_put(host);\r\nout_iounmap:\r\nif (flag & BOARD_MEMMAP)\r\niounmap((void *)mega_baseport);\r\nout_release_region:\r\nif (flag & BOARD_MEMMAP)\r\nrelease_mem_region(tbase, 128);\r\nelse\r\nrelease_region(mega_baseport, 16);\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nout:\r\nreturn error;\r\n}\r\nstatic void\r\n__megaraid_shutdown(adapter_t *adapter)\r\n{\r\nu_char raw_mbox[sizeof(struct mbox_out)];\r\nmbox_t *mbox = (mbox_t *)raw_mbox;\r\nint i;\r\nmemset(&mbox->m_out, 0, sizeof(raw_mbox));\r\nraw_mbox[0] = FLUSH_ADAPTER;\r\nfree_irq(adapter->host->irq, adapter);\r\nissue_scb_block(adapter, raw_mbox);\r\nmemset(&mbox->m_out, 0, sizeof(raw_mbox));\r\nraw_mbox[0] = FLUSH_SYSTEM;\r\nissue_scb_block(adapter, raw_mbox);\r\nif (atomic_read(&adapter->pend_cmds) > 0)\r\nprintk(KERN_WARNING "megaraid: pending commands!!\n");\r\nfor (i = 0; i <= 10; i++)\r\nmdelay(1000);\r\n}\r\nstatic void __devexit\r\nmegaraid_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nadapter_t *adapter = (adapter_t *)host->hostdata;\r\nscsi_remove_host(host);\r\n__megaraid_shutdown(adapter);\r\nif (adapter->flag & BOARD_MEMMAP) {\r\niounmap((void *)adapter->base);\r\nrelease_mem_region(adapter->host->base, 128);\r\n} else\r\nrelease_region(adapter->base, 16);\r\nmega_free_sgl(adapter);\r\n#ifdef CONFIG_PROC_FS\r\nif (adapter->controller_proc_dir_entry) {\r\nremove_proc_entry("stat", adapter->controller_proc_dir_entry);\r\nremove_proc_entry("config",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("mailbox",\r\nadapter->controller_proc_dir_entry);\r\n#if MEGA_HAVE_ENH_PROC\r\nremove_proc_entry("rebuild-rate",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("battery-status",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("diskdrives-ch0",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("diskdrives-ch1",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("diskdrives-ch2",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("diskdrives-ch3",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("raiddrives-0-9",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("raiddrives-10-19",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("raiddrives-20-29",\r\nadapter->controller_proc_dir_entry);\r\nremove_proc_entry("raiddrives-30-39",\r\nadapter->controller_proc_dir_entry);\r\n#endif\r\n{\r\nchar buf[12] = { 0 };\r\nsprintf(buf, "hba%d", adapter->host->host_no);\r\nremove_proc_entry(buf, mega_proc_dir_entry);\r\n}\r\n}\r\n#endif\r\npci_free_consistent(adapter->dev, MEGA_BUFFER_SIZE,\r\nadapter->mega_buffer, adapter->buf_dma_handle);\r\nkfree(adapter->scb_list);\r\npci_free_consistent(adapter->dev, sizeof(mbox64_t),\r\nadapter->una_mbox64, adapter->una_mbox64_dma);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\nhba_count--;\r\n}\r\nstatic void\r\nmegaraid_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nadapter_t *adapter = (adapter_t *)host->hostdata;\r\n__megaraid_shutdown(adapter);\r\n}\r\nstatic int __init megaraid_init(void)\r\n{\r\nint error;\r\nif ((max_cmd_per_lun <= 0) || (max_cmd_per_lun > MAX_CMD_PER_LUN))\r\nmax_cmd_per_lun = MAX_CMD_PER_LUN;\r\nif (max_mbox_busy_wait > MBOX_BUSY_WAIT)\r\nmax_mbox_busy_wait = MBOX_BUSY_WAIT;\r\n#ifdef CONFIG_PROC_FS\r\nmega_proc_dir_entry = proc_mkdir("megaraid", NULL);\r\nif (!mega_proc_dir_entry) {\r\nprintk(KERN_WARNING\r\n"megaraid: failed to create megaraid root\n");\r\n}\r\n#endif\r\nerror = pci_register_driver(&megaraid_pci_driver);\r\nif (error) {\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("megaraid", NULL);\r\n#endif\r\nreturn error;\r\n}\r\nmajor = register_chrdev(0, "megadev_legacy", &megadev_fops);\r\nif (!major) {\r\nprintk(KERN_WARNING\r\n"megaraid: failed to register char device\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit megaraid_exit(void)\r\n{\r\nunregister_chrdev(major, "megadev_legacy");\r\npci_unregister_driver(&megaraid_pci_driver);\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("megaraid", NULL);\r\n#endif\r\n}
