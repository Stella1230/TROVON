static void timbuart_stop_rx(struct uart_port *port)\r\n{\r\nu32 ier = ioread32(port->membase + TIMBUART_IER) & ~RXFLAGS;\r\niowrite32(ier, port->membase + TIMBUART_IER);\r\n}\r\nstatic void timbuart_stop_tx(struct uart_port *port)\r\n{\r\nu32 ier = ioread32(port->membase + TIMBUART_IER) & ~TXBAE;\r\niowrite32(ier, port->membase + TIMBUART_IER);\r\n}\r\nstatic void timbuart_start_tx(struct uart_port *port)\r\n{\r\nstruct timbuart_port *uart =\r\ncontainer_of(port, struct timbuart_port, port);\r\ntasklet_schedule(&uart->tasklet);\r\n}\r\nstatic unsigned int timbuart_tx_empty(struct uart_port *port)\r\n{\r\nu32 isr = ioread32(port->membase + TIMBUART_ISR);\r\nreturn (isr & TXBE) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void timbuart_flush_buffer(struct uart_port *port)\r\n{\r\nif (!timbuart_tx_empty(port)) {\r\nu8 ctl = ioread8(port->membase + TIMBUART_CTRL) |\r\nTIMBUART_CTRL_FLSHTX;\r\niowrite8(ctl, port->membase + TIMBUART_CTRL);\r\niowrite32(TXBF, port->membase + TIMBUART_ISR);\r\n}\r\n}\r\nstatic void timbuart_rx_chars(struct uart_port *port)\r\n{\r\nstruct tty_struct *tty = port->state->port.tty;\r\nwhile (ioread32(port->membase + TIMBUART_ISR) & RXDP) {\r\nu8 ch = ioread8(port->membase + TIMBUART_RXFIFO);\r\nport->icount.rx++;\r\ntty_insert_flip_char(tty, ch, TTY_NORMAL);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(port->state->port.tty);\r\nspin_lock(&port->lock);\r\ndev_dbg(port->dev, "%s - total read %d bytes\n",\r\n__func__, port->icount.rx);\r\n}\r\nstatic void timbuart_tx_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nwhile (!(ioread32(port->membase + TIMBUART_ISR) & TXBF) &&\r\n!uart_circ_empty(xmit)) {\r\niowrite8(xmit->buf[xmit->tail],\r\nport->membase + TIMBUART_TXFIFO);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\ndev_dbg(port->dev,\r\n"%s - total written %d bytes, CTL: %x, RTS: %x, baud: %x\n",\r\n__func__,\r\nport->icount.tx,\r\nioread8(port->membase + TIMBUART_CTRL),\r\nport->mctrl & TIOCM_RTS,\r\nioread8(port->membase + TIMBUART_BAUDRATE));\r\n}\r\nstatic void timbuart_handle_tx_port(struct uart_port *port, u32 isr, u32 *ier)\r\n{\r\nstruct timbuart_port *uart =\r\ncontainer_of(port, struct timbuart_port, port);\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nreturn;\r\nif (port->x_char)\r\nreturn;\r\nif (isr & TXFLAGS) {\r\ntimbuart_tx_chars(port);\r\niowrite32(TXFLAGS, port->membase + TIMBUART_ISR);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n} else\r\n*ier |= uart->last_ier & TXFLAGS;\r\nif (!uart_circ_empty(xmit))\r\n*ier |= TXBAE;\r\ndev_dbg(port->dev, "%s - leaving\n", __func__);\r\n}\r\nvoid timbuart_handle_rx_port(struct uart_port *port, u32 isr, u32 *ier)\r\n{\r\nif (isr & RXFLAGS) {\r\nif (isr & RXBF) {\r\nu8 ctl = ioread8(port->membase + TIMBUART_CTRL) |\r\nTIMBUART_CTRL_FLSHRX;\r\niowrite8(ctl, port->membase + TIMBUART_CTRL);\r\nport->icount.overrun++;\r\n} else if (isr & (RXDP))\r\ntimbuart_rx_chars(port);\r\niowrite32(RXFLAGS, port->membase + TIMBUART_ISR);\r\n}\r\n*ier |= RXBAF | RXBF | RXTT;\r\ndev_dbg(port->dev, "%s - leaving\n", __func__);\r\n}\r\nvoid timbuart_tasklet(unsigned long arg)\r\n{\r\nstruct timbuart_port *uart = (struct timbuart_port *)arg;\r\nu32 isr, ier = 0;\r\nspin_lock(&uart->port.lock);\r\nisr = ioread32(uart->port.membase + TIMBUART_ISR);\r\ndev_dbg(uart->port.dev, "%s ISR: %x\n", __func__, isr);\r\nif (!uart->usedma)\r\ntimbuart_handle_tx_port(&uart->port, isr, &ier);\r\ntimbuart_mctrl_check(&uart->port, isr, &ier);\r\nif (!uart->usedma)\r\ntimbuart_handle_rx_port(&uart->port, isr, &ier);\r\niowrite32(ier, uart->port.membase + TIMBUART_IER);\r\nspin_unlock(&uart->port.lock);\r\ndev_dbg(uart->port.dev, "%s leaving\n", __func__);\r\n}\r\nstatic unsigned int timbuart_get_mctrl(struct uart_port *port)\r\n{\r\nu8 cts = ioread8(port->membase + TIMBUART_CTRL);\r\ndev_dbg(port->dev, "%s - cts %x\n", __func__, cts);\r\nif (cts & TIMBUART_CTRL_CTS)\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\nelse\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void timbuart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\ndev_dbg(port->dev, "%s - %x\n", __func__, mctrl);\r\nif (mctrl & TIOCM_RTS)\r\niowrite8(TIMBUART_CTRL_RTS, port->membase + TIMBUART_CTRL);\r\nelse\r\niowrite8(0, port->membase + TIMBUART_CTRL);\r\n}\r\nstatic void timbuart_mctrl_check(struct uart_port *port, u32 isr, u32 *ier)\r\n{\r\nunsigned int cts;\r\nif (isr & CTS_DELTA) {\r\niowrite32(CTS_DELTA, port->membase + TIMBUART_ISR);\r\ncts = timbuart_get_mctrl(port);\r\nuart_handle_cts_change(port, cts & TIOCM_CTS);\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\n}\r\n*ier |= CTS_DELTA;\r\n}\r\nstatic void timbuart_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void timbuart_break_ctl(struct uart_port *port, int ctl)\r\n{\r\n}\r\nstatic int timbuart_startup(struct uart_port *port)\r\n{\r\nstruct timbuart_port *uart =\r\ncontainer_of(port, struct timbuart_port, port);\r\ndev_dbg(port->dev, "%s\n", __func__);\r\niowrite8(TIMBUART_CTRL_FLSHRX, port->membase + TIMBUART_CTRL);\r\niowrite32(0x1ff, port->membase + TIMBUART_ISR);\r\niowrite32(RXBAF | RXBF | RXTT | CTS_DELTA,\r\nport->membase + TIMBUART_IER);\r\nreturn request_irq(port->irq, timbuart_handleinterrupt, IRQF_SHARED,\r\n"timb-uart", uart);\r\n}\r\nstatic void timbuart_shutdown(struct uart_port *port)\r\n{\r\nstruct timbuart_port *uart =\r\ncontainer_of(port, struct timbuart_port, port);\r\ndev_dbg(port->dev, "%s\n", __func__);\r\nfree_irq(port->irq, uart);\r\niowrite32(0, port->membase + TIMBUART_IER);\r\n}\r\nstatic int get_bindex(int baud)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(baudrates); i++)\r\nif (baud <= baudrates[i])\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic void timbuart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud;\r\nshort bindex;\r\nunsigned long flags;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\r\nbindex = get_bindex(baud);\r\ndev_dbg(port->dev, "%s - bindex %d\n", __func__, bindex);\r\nif (bindex < 0)\r\nbindex = 0;\r\nbaud = baudrates[bindex];\r\nif (old)\r\ntty_termios_copy_hw(termios, old);\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nspin_lock_irqsave(&port->lock, flags);\r\niowrite8((u8)bindex, port->membase + TIMBUART_BAUDRATE);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *timbuart_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_UNKNOWN ? "timbuart" : NULL;\r\n}\r\nstatic void timbuart_release_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nint size =\r\nresource_size(platform_get_resource(pdev, IORESOURCE_MEM, 0));\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nrelease_mem_region(port->mapbase, size);\r\n}\r\nstatic int timbuart_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nint size =\r\nresource_size(platform_get_resource(pdev, IORESOURCE_MEM, 0));\r\nif (!request_mem_region(port->mapbase, size, "timb-uart"))\r\nreturn -EBUSY;\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = ioremap(port->mapbase, size);\r\nif (port->membase == NULL) {\r\nrelease_mem_region(port->mapbase, size);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t timbuart_handleinterrupt(int irq, void *devid)\r\n{\r\nstruct timbuart_port *uart = (struct timbuart_port *)devid;\r\nif (ioread8(uart->port.membase + TIMBUART_IPR)) {\r\nuart->last_ier = ioread32(uart->port.membase + TIMBUART_IER);\r\niowrite32(0, uart->port.membase + TIMBUART_IER);\r\ntasklet_schedule(&uart->tasklet);\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nstatic void timbuart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_TIMBUART;\r\ntimbuart_request_port(port);\r\n}\r\n}\r\nstatic int timbuart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int __devinit timbuart_probe(struct platform_device *dev)\r\n{\r\nint err, irq;\r\nstruct timbuart_port *uart;\r\nstruct resource *iomem;\r\ndev_dbg(&dev->dev, "%s\n", __func__);\r\nuart = kzalloc(sizeof(*uart), GFP_KERNEL);\r\nif (!uart) {\r\nerr = -EINVAL;\r\ngoto err_mem;\r\n}\r\nuart->usedma = 0;\r\nuart->port.uartclk = 3250000 * 16;\r\nuart->port.fifosize = TIMBUART_FIFO_SIZE;\r\nuart->port.regshift = 2;\r\nuart->port.iotype = UPIO_MEM;\r\nuart->port.ops = &timbuart_ops;\r\nuart->port.irq = 0;\r\nuart->port.flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP;\r\nuart->port.line = 0;\r\nuart->port.dev = &dev->dev;\r\niomem = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!iomem) {\r\nerr = -ENOMEM;\r\ngoto err_register;\r\n}\r\nuart->port.mapbase = iomem->start;\r\nuart->port.membase = NULL;\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0) {\r\nerr = -EINVAL;\r\ngoto err_register;\r\n}\r\nuart->port.irq = irq;\r\ntasklet_init(&uart->tasklet, timbuart_tasklet, (unsigned long)uart);\r\nerr = uart_register_driver(&timbuart_driver);\r\nif (err)\r\ngoto err_register;\r\nerr = uart_add_one_port(&timbuart_driver, &uart->port);\r\nif (err)\r\ngoto err_add_port;\r\nplatform_set_drvdata(dev, uart);\r\nreturn 0;\r\nerr_add_port:\r\nuart_unregister_driver(&timbuart_driver);\r\nerr_register:\r\nkfree(uart);\r\nerr_mem:\r\nprintk(KERN_ERR "timberdale: Failed to register Timberdale UART: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nstatic int __devexit timbuart_remove(struct platform_device *dev)\r\n{\r\nstruct timbuart_port *uart = platform_get_drvdata(dev);\r\ntasklet_kill(&uart->tasklet);\r\nuart_remove_one_port(&timbuart_driver, &uart->port);\r\nuart_unregister_driver(&timbuart_driver);\r\nkfree(uart);\r\nreturn 0;\r\n}\r\nstatic int __init timbuart_init(void)\r\n{\r\nreturn platform_driver_register(&timbuart_platform_driver);\r\n}\r\nstatic void __exit timbuart_exit(void)\r\n{\r\nplatform_driver_unregister(&timbuart_platform_driver);\r\n}
