static inline struct alua_dh_data *get_alua_data(struct scsi_device *sdev)\r\n{\r\nstruct scsi_dh_data *scsi_dh_data = sdev->scsi_dh_data;\r\nBUG_ON(scsi_dh_data == NULL);\r\nreturn ((struct alua_dh_data *) scsi_dh_data->buf);\r\n}\r\nstatic int realloc_buffer(struct alua_dh_data *h, unsigned len)\r\n{\r\nif (h->buff && h->buff != h->inq)\r\nkfree(h->buff);\r\nh->buff = kmalloc(len, GFP_NOIO);\r\nif (!h->buff) {\r\nh->buff = h->inq;\r\nh->bufflen = ALUA_INQUIRY_SIZE;\r\nreturn 1;\r\n}\r\nh->bufflen = len;\r\nreturn 0;\r\n}\r\nstatic struct request *get_alua_req(struct scsi_device *sdev,\r\nvoid *buffer, unsigned buflen, int rw)\r\n{\r\nstruct request *rq;\r\nstruct request_queue *q = sdev->request_queue;\r\nrq = blk_get_request(q, rw, GFP_NOIO);\r\nif (!rq) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: blk_get_request failed\n", __func__);\r\nreturn NULL;\r\n}\r\nif (buflen && blk_rq_map_kern(q, rq, buffer, buflen, GFP_NOIO)) {\r\nblk_put_request(rq);\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: blk_rq_map_kern failed\n", __func__);\r\nreturn NULL;\r\n}\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nrq->cmd_flags |= REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER;\r\nrq->retries = ALUA_FAILOVER_RETRIES;\r\nrq->timeout = ALUA_FAILOVER_TIMEOUT;\r\nreturn rq;\r\n}\r\nstatic int submit_std_inquiry(struct scsi_device *sdev, struct alua_dh_data *h)\r\n{\r\nstruct request *rq;\r\nint err = SCSI_DH_RES_TEMP_UNAVAIL;\r\nrq = get_alua_req(sdev, h->inq, ALUA_INQUIRY_SIZE, READ);\r\nif (!rq)\r\ngoto done;\r\nrq->cmd[0] = INQUIRY;\r\nrq->cmd[1] = 0;\r\nrq->cmd[2] = 0;\r\nrq->cmd[4] = ALUA_INQUIRY_SIZE;\r\nrq->cmd_len = COMMAND_SIZE(INQUIRY);\r\nrq->sense = h->sense;\r\nmemset(rq->sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nrq->sense_len = h->senselen = 0;\r\nerr = blk_execute_rq(rq->q, NULL, rq, 1);\r\nif (err == -EIO) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: std inquiry failed with %x\n",\r\nALUA_DH_NAME, rq->errors);\r\nh->senselen = rq->sense_len;\r\nerr = SCSI_DH_IO;\r\n}\r\nblk_put_request(rq);\r\ndone:\r\nreturn err;\r\n}\r\nstatic int submit_vpd_inquiry(struct scsi_device *sdev, struct alua_dh_data *h)\r\n{\r\nstruct request *rq;\r\nint err = SCSI_DH_RES_TEMP_UNAVAIL;\r\nrq = get_alua_req(sdev, h->buff, h->bufflen, READ);\r\nif (!rq)\r\ngoto done;\r\nrq->cmd[0] = INQUIRY;\r\nrq->cmd[1] = 1;\r\nrq->cmd[2] = 0x83;\r\nrq->cmd[4] = h->bufflen;\r\nrq->cmd_len = COMMAND_SIZE(INQUIRY);\r\nrq->sense = h->sense;\r\nmemset(rq->sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nrq->sense_len = h->senselen = 0;\r\nerr = blk_execute_rq(rq->q, NULL, rq, 1);\r\nif (err == -EIO) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: evpd inquiry failed with %x\n",\r\nALUA_DH_NAME, rq->errors);\r\nh->senselen = rq->sense_len;\r\nerr = SCSI_DH_IO;\r\n}\r\nblk_put_request(rq);\r\ndone:\r\nreturn err;\r\n}\r\nstatic unsigned submit_rtpg(struct scsi_device *sdev, struct alua_dh_data *h)\r\n{\r\nstruct request *rq;\r\nint err = SCSI_DH_RES_TEMP_UNAVAIL;\r\nrq = get_alua_req(sdev, h->buff, h->bufflen, READ);\r\nif (!rq)\r\ngoto done;\r\nrq->cmd[0] = MAINTENANCE_IN;\r\nrq->cmd[1] = MI_REPORT_TARGET_PGS;\r\nrq->cmd[6] = (h->bufflen >> 24) & 0xff;\r\nrq->cmd[7] = (h->bufflen >> 16) & 0xff;\r\nrq->cmd[8] = (h->bufflen >> 8) & 0xff;\r\nrq->cmd[9] = h->bufflen & 0xff;\r\nrq->cmd_len = COMMAND_SIZE(MAINTENANCE_IN);\r\nrq->sense = h->sense;\r\nmemset(rq->sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nrq->sense_len = h->senselen = 0;\r\nerr = blk_execute_rq(rq->q, NULL, rq, 1);\r\nif (err == -EIO) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: rtpg failed with %x\n",\r\nALUA_DH_NAME, rq->errors);\r\nh->senselen = rq->sense_len;\r\nerr = SCSI_DH_IO;\r\n}\r\nblk_put_request(rq);\r\ndone:\r\nreturn err;\r\n}\r\nstatic void stpg_endio(struct request *req, int error)\r\n{\r\nstruct alua_dh_data *h = req->end_io_data;\r\nstruct scsi_sense_hdr sense_hdr;\r\nunsigned err = SCSI_DH_OK;\r\nif (error || host_byte(req->errors) != DID_OK ||\r\nmsg_byte(req->errors) != COMMAND_COMPLETE) {\r\nerr = SCSI_DH_IO;\r\ngoto done;\r\n}\r\nif (h->senselen > 0) {\r\nerr = scsi_normalize_sense(h->sense, SCSI_SENSE_BUFFERSIZE,\r\n&sense_hdr);\r\nif (!err) {\r\nerr = SCSI_DH_IO;\r\ngoto done;\r\n}\r\nerr = alua_check_sense(h->sdev, &sense_hdr);\r\nif (err == ADD_TO_MLQUEUE) {\r\nerr = SCSI_DH_RETRY;\r\ngoto done;\r\n}\r\nsdev_printk(KERN_INFO, h->sdev,\r\n"%s: stpg sense code: %02x/%02x/%02x\n",\r\nALUA_DH_NAME, sense_hdr.sense_key,\r\nsense_hdr.asc, sense_hdr.ascq);\r\nerr = SCSI_DH_IO;\r\n}\r\nif (err == SCSI_DH_OK) {\r\nh->state = TPGS_STATE_OPTIMIZED;\r\nsdev_printk(KERN_INFO, h->sdev,\r\n"%s: port group %02x switched to state %c\n",\r\nALUA_DH_NAME, h->group_id,\r\nprint_alua_state(h->state));\r\n}\r\ndone:\r\nreq->end_io_data = NULL;\r\n__blk_put_request(req->q, req);\r\nif (h->callback_fn) {\r\nh->callback_fn(h->callback_data, err);\r\nh->callback_fn = h->callback_data = NULL;\r\n}\r\nreturn;\r\n}\r\nstatic unsigned submit_stpg(struct alua_dh_data *h)\r\n{\r\nstruct request *rq;\r\nint stpg_len = 8;\r\nstruct scsi_device *sdev = h->sdev;\r\nmemset(h->buff, 0, stpg_len);\r\nh->buff[4] = TPGS_STATE_OPTIMIZED & 0x0f;\r\nh->buff[6] = (h->group_id >> 8) & 0xff;\r\nh->buff[7] = h->group_id & 0xff;\r\nrq = get_alua_req(sdev, h->buff, stpg_len, WRITE);\r\nif (!rq)\r\nreturn SCSI_DH_RES_TEMP_UNAVAIL;\r\nrq->cmd[0] = MAINTENANCE_OUT;\r\nrq->cmd[1] = MO_SET_TARGET_PGS;\r\nrq->cmd[6] = (stpg_len >> 24) & 0xff;\r\nrq->cmd[7] = (stpg_len >> 16) & 0xff;\r\nrq->cmd[8] = (stpg_len >> 8) & 0xff;\r\nrq->cmd[9] = stpg_len & 0xff;\r\nrq->cmd_len = COMMAND_SIZE(MAINTENANCE_OUT);\r\nrq->sense = h->sense;\r\nmemset(rq->sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nrq->sense_len = h->senselen = 0;\r\nrq->end_io_data = h;\r\nblk_execute_rq_nowait(rq->q, NULL, rq, 1, stpg_endio);\r\nreturn SCSI_DH_OK;\r\n}\r\nstatic int alua_std_inquiry(struct scsi_device *sdev, struct alua_dh_data *h)\r\n{\r\nint err;\r\nerr = submit_std_inquiry(sdev, h);\r\nif (err != SCSI_DH_OK)\r\nreturn err;\r\nh->tpgs = (h->inq[5] >> 4) & 0x3;\r\nswitch (h->tpgs) {\r\ncase TPGS_MODE_EXPLICIT|TPGS_MODE_IMPLICIT:\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: supports implicit and explicit TPGS\n",\r\nALUA_DH_NAME);\r\nbreak;\r\ncase TPGS_MODE_EXPLICIT:\r\nsdev_printk(KERN_INFO, sdev, "%s: supports explicit TPGS\n",\r\nALUA_DH_NAME);\r\nbreak;\r\ncase TPGS_MODE_IMPLICIT:\r\nsdev_printk(KERN_INFO, sdev, "%s: supports implicit TPGS\n",\r\nALUA_DH_NAME);\r\nbreak;\r\ndefault:\r\nh->tpgs = TPGS_MODE_NONE;\r\nsdev_printk(KERN_INFO, sdev, "%s: not supported\n",\r\nALUA_DH_NAME);\r\nerr = SCSI_DH_DEV_UNSUPP;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int alua_vpd_inquiry(struct scsi_device *sdev, struct alua_dh_data *h)\r\n{\r\nint len;\r\nunsigned err;\r\nunsigned char *d;\r\nretry:\r\nerr = submit_vpd_inquiry(sdev, h);\r\nif (err != SCSI_DH_OK)\r\nreturn err;\r\nlen = (h->buff[2] << 8) + h->buff[3] + 4;\r\nif (len > h->bufflen) {\r\nif (realloc_buffer(h, len)) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: kmalloc buffer failed\n",\r\nALUA_DH_NAME);\r\nreturn SCSI_DH_DEV_TEMP_BUSY;\r\n}\r\ngoto retry;\r\n}\r\nd = h->buff + 4;\r\nwhile (d < h->buff + len) {\r\nswitch (d[1] & 0xf) {\r\ncase 0x4:\r\nh->rel_port = (d[6] << 8) + d[7];\r\nbreak;\r\ncase 0x5:\r\nh->group_id = (d[6] << 8) + d[7];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nd += d[3] + 4;\r\n}\r\nif (h->group_id == -1) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: No target port descriptors found\n",\r\nALUA_DH_NAME);\r\nh->state = TPGS_STATE_OPTIMIZED;\r\nh->tpgs = TPGS_MODE_NONE;\r\nerr = SCSI_DH_DEV_UNSUPP;\r\n} else {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: port group %02x rel port %02x\n",\r\nALUA_DH_NAME, h->group_id, h->rel_port);\r\n}\r\nreturn err;\r\n}\r\nstatic char print_alua_state(int state)\r\n{\r\nswitch (state) {\r\ncase TPGS_STATE_OPTIMIZED:\r\nreturn 'A';\r\ncase TPGS_STATE_NONOPTIMIZED:\r\nreturn 'N';\r\ncase TPGS_STATE_STANDBY:\r\nreturn 'S';\r\ncase TPGS_STATE_UNAVAILABLE:\r\nreturn 'U';\r\ncase TPGS_STATE_LBA_DEPENDENT:\r\nreturn 'L';\r\ncase TPGS_STATE_OFFLINE:\r\nreturn 'O';\r\ncase TPGS_STATE_TRANSITIONING:\r\nreturn 'T';\r\ndefault:\r\nreturn 'X';\r\n}\r\n}\r\nstatic int alua_check_sense(struct scsi_device *sdev,\r\nstruct scsi_sense_hdr *sense_hdr)\r\n{\r\nswitch (sense_hdr->sense_key) {\r\ncase NOT_READY:\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x0a)\r\nreturn ADD_TO_MLQUEUE;\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x0b)\r\nreturn SUCCESS;\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x0c)\r\nreturn SUCCESS;\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x12)\r\nreturn SUCCESS;\r\nbreak;\r\ncase UNIT_ATTENTION:\r\nif (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x00)\r\nreturn ADD_TO_MLQUEUE;\r\nif (sense_hdr->asc == 0x2a && sense_hdr->ascq == 0x06) {\r\nreturn ADD_TO_MLQUEUE;\r\n}\r\nif (sense_hdr->asc == 0x2a && sense_hdr->ascq == 0x07) {\r\nreturn ADD_TO_MLQUEUE;\r\n}\r\nif (sense_hdr->asc == 0x3f && sense_hdr->ascq == 0x0e) {\r\nreturn ADD_TO_MLQUEUE;\r\n}\r\nbreak;\r\n}\r\nreturn SCSI_RETURN_NOT_HANDLED;\r\n}\r\nstatic int alua_rtpg(struct scsi_device *sdev, struct alua_dh_data *h)\r\n{\r\nstruct scsi_sense_hdr sense_hdr;\r\nint len, k, off, valid_states = 0;\r\nchar *ucp;\r\nunsigned err;\r\nunsigned long expiry, interval = 10;\r\nexpiry = round_jiffies_up(jiffies + ALUA_FAILOVER_TIMEOUT);\r\nretry:\r\nerr = submit_rtpg(sdev, h);\r\nif (err == SCSI_DH_IO && h->senselen > 0) {\r\nerr = scsi_normalize_sense(h->sense, SCSI_SENSE_BUFFERSIZE,\r\n&sense_hdr);\r\nif (!err)\r\nreturn SCSI_DH_IO;\r\nerr = alua_check_sense(sdev, &sense_hdr);\r\nif (err == ADD_TO_MLQUEUE && time_before(jiffies, expiry))\r\ngoto retry;\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: rtpg sense code %02x/%02x/%02x\n",\r\nALUA_DH_NAME, sense_hdr.sense_key,\r\nsense_hdr.asc, sense_hdr.ascq);\r\nerr = SCSI_DH_IO;\r\n}\r\nif (err != SCSI_DH_OK)\r\nreturn err;\r\nlen = (h->buff[0] << 24) + (h->buff[1] << 16) +\r\n(h->buff[2] << 8) + h->buff[3] + 4;\r\nif (len > h->bufflen) {\r\nif (realloc_buffer(h, len)) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: kmalloc buffer failed\n",__func__);\r\nreturn SCSI_DH_DEV_TEMP_BUSY;\r\n}\r\ngoto retry;\r\n}\r\nfor (k = 4, ucp = h->buff + 4; k < len; k += off, ucp += off) {\r\nif (h->group_id == (ucp[2] << 8) + ucp[3]) {\r\nh->state = ucp[0] & 0x0f;\r\nvalid_states = ucp[1];\r\n}\r\noff = 8 + (ucp[7] * 4);\r\n}\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: port group %02x state %c supports %c%c%c%c%c%c%c\n",\r\nALUA_DH_NAME, h->group_id, print_alua_state(h->state),\r\nvalid_states&TPGS_SUPPORT_TRANSITION?'T':'t',\r\nvalid_states&TPGS_SUPPORT_OFFLINE?'O':'o',\r\nvalid_states&TPGS_SUPPORT_LBA_DEPENDENT?'L':'l',\r\nvalid_states&TPGS_SUPPORT_UNAVAILABLE?'U':'u',\r\nvalid_states&TPGS_SUPPORT_STANDBY?'S':'s',\r\nvalid_states&TPGS_SUPPORT_NONOPTIMIZED?'N':'n',\r\nvalid_states&TPGS_SUPPORT_OPTIMIZED?'A':'a');\r\nswitch (h->state) {\r\ncase TPGS_STATE_TRANSITIONING:\r\nif (time_before(jiffies, expiry)) {\r\ninterval *= 10;\r\nmsleep(interval);\r\ngoto retry;\r\n}\r\nerr = SCSI_DH_RETRY;\r\nh->state = TPGS_STATE_STANDBY;\r\nbreak;\r\ncase TPGS_STATE_OFFLINE:\r\ncase TPGS_STATE_UNAVAILABLE:\r\nerr = SCSI_DH_DEV_OFFLINED;\r\nbreak;\r\ndefault:\r\nerr = SCSI_DH_OK;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int alua_initialize(struct scsi_device *sdev, struct alua_dh_data *h)\r\n{\r\nint err;\r\nerr = alua_std_inquiry(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto out;\r\nerr = alua_vpd_inquiry(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto out;\r\nerr = alua_rtpg(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto out;\r\nout:\r\nreturn err;\r\n}\r\nstatic int alua_activate(struct scsi_device *sdev,\r\nactivate_complete fn, void *data)\r\n{\r\nstruct alua_dh_data *h = get_alua_data(sdev);\r\nint err = SCSI_DH_OK;\r\nif (h->group_id != -1) {\r\nerr = alua_rtpg(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto out;\r\n}\r\nif (h->tpgs & TPGS_MODE_EXPLICIT &&\r\nh->state != TPGS_STATE_OPTIMIZED &&\r\nh->state != TPGS_STATE_LBA_DEPENDENT) {\r\nh->callback_fn = fn;\r\nh->callback_data = data;\r\nerr = submit_stpg(h);\r\nif (err == SCSI_DH_OK)\r\nreturn 0;\r\nh->callback_fn = h->callback_data = NULL;\r\n}\r\nout:\r\nif (fn)\r\nfn(data, err);\r\nreturn 0;\r\n}\r\nstatic int alua_prep_fn(struct scsi_device *sdev, struct request *req)\r\n{\r\nstruct alua_dh_data *h = get_alua_data(sdev);\r\nint ret = BLKPREP_OK;\r\nif (h->state == TPGS_STATE_TRANSITIONING)\r\nret = BLKPREP_DEFER;\r\nelse if (h->state != TPGS_STATE_OPTIMIZED &&\r\nh->state != TPGS_STATE_NONOPTIMIZED &&\r\nh->state != TPGS_STATE_LBA_DEPENDENT) {\r\nret = BLKPREP_KILL;\r\nreq->cmd_flags |= REQ_QUIET;\r\n}\r\nreturn ret;\r\n}\r\nstatic int alua_bus_attach(struct scsi_device *sdev)\r\n{\r\nstruct scsi_dh_data *scsi_dh_data;\r\nstruct alua_dh_data *h;\r\nunsigned long flags;\r\nint err = SCSI_DH_OK;\r\nscsi_dh_data = kzalloc(sizeof(*scsi_dh_data)\r\n+ sizeof(*h) , GFP_KERNEL);\r\nif (!scsi_dh_data) {\r\nsdev_printk(KERN_ERR, sdev, "%s: Attach failed\n",\r\nALUA_DH_NAME);\r\nreturn -ENOMEM;\r\n}\r\nscsi_dh_data->scsi_dh = &alua_dh;\r\nh = (struct alua_dh_data *) scsi_dh_data->buf;\r\nh->tpgs = TPGS_MODE_UNINITIALIZED;\r\nh->state = TPGS_STATE_OPTIMIZED;\r\nh->group_id = -1;\r\nh->rel_port = -1;\r\nh->buff = h->inq;\r\nh->bufflen = ALUA_INQUIRY_SIZE;\r\nh->sdev = sdev;\r\nerr = alua_initialize(sdev, h);\r\nif ((err != SCSI_DH_OK) && (err != SCSI_DH_DEV_OFFLINED))\r\ngoto failed;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto failed;\r\nspin_lock_irqsave(sdev->request_queue->queue_lock, flags);\r\nsdev->scsi_dh_data = scsi_dh_data;\r\nspin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);\r\nreturn 0;\r\nfailed:\r\nkfree(scsi_dh_data);\r\nsdev_printk(KERN_ERR, sdev, "%s: not attached\n", ALUA_DH_NAME);\r\nreturn -EINVAL;\r\n}\r\nstatic void alua_bus_detach(struct scsi_device *sdev)\r\n{\r\nstruct scsi_dh_data *scsi_dh_data;\r\nstruct alua_dh_data *h;\r\nunsigned long flags;\r\nspin_lock_irqsave(sdev->request_queue->queue_lock, flags);\r\nscsi_dh_data = sdev->scsi_dh_data;\r\nsdev->scsi_dh_data = NULL;\r\nspin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);\r\nh = (struct alua_dh_data *) scsi_dh_data->buf;\r\nif (h->buff && h->inq != h->buff)\r\nkfree(h->buff);\r\nkfree(scsi_dh_data);\r\nmodule_put(THIS_MODULE);\r\nsdev_printk(KERN_NOTICE, sdev, "%s: Detached\n", ALUA_DH_NAME);\r\n}\r\nstatic int __init alua_init(void)\r\n{\r\nint r;\r\nr = scsi_register_device_handler(&alua_dh);\r\nif (r != 0)\r\nprintk(KERN_ERR "%s: Failed to register scsi device handler",\r\nALUA_DH_NAME);\r\nreturn r;\r\n}\r\nstatic void __exit alua_exit(void)\r\n{\r\nscsi_unregister_device_handler(&alua_dh);\r\n}
