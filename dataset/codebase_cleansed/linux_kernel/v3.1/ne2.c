static void __init dlink_put_eeprom(unsigned char value, unsigned int addr)\r\n{\r\nint z;\r\nunsigned char v1, v2;\r\noutb(value, addr + 0x1e);\r\nfor (z = 0; z < 2; z++) {\r\ndo {\r\nv1 = inb(addr + 0x1e);\r\nv2 = inb(addr + 0x1e);\r\n}\r\nwhile (!((v1 ^ v2) & 0x80));\r\n}\r\n}\r\nstatic void __init dlink_send_eeprom_bit(unsigned int bit, unsigned int addr)\r\n{\r\nbit = bit << 1;\r\ndlink_put_eeprom(0x09 | bit, addr);\r\ndlink_put_eeprom(0x0d | bit, addr);\r\ndlink_put_eeprom(0x0d | bit, addr);\r\ndlink_put_eeprom(0x09 | bit, addr);\r\n}\r\nstatic void __init dlink_send_eeprom_word(unsigned int value, unsigned int len, unsigned int addr)\r\n{\r\nint z;\r\nvalue = value << (16 - len);\r\nfor (z = 0; z < len; z++) {\r\ndlink_send_eeprom_bit((value & 0x8000) >> 15, addr);\r\nvalue = value << 1;\r\n}\r\n}\r\nstatic unsigned int __init dlink_get_eeprom(unsigned int eeaddr, unsigned int addr)\r\n{\r\nint z;\r\nunsigned int value = 0;\r\ndlink_put_eeprom(0x01, addr);\r\ndlink_put_eeprom(0x09, addr);\r\ndlink_send_eeprom_word(0x0180 | (eeaddr & 0x3f), 9, addr);\r\nfor (z = 0; z < 16; z++) {\r\ndlink_send_eeprom_bit(0, addr);\r\nvalue = (value << 1) | (inb(addr + 0x1e) & 0x01);\r\n}\r\nreturn value;\r\n}\r\nstatic int __init do_ne2_probe(struct net_device *dev)\r\n{\r\nstatic int current_mca_slot = -1;\r\nint i;\r\nint adapter_found = 0;\r\nfor(i = 0; (ne2_adapters[i].name != NULL) && !adapter_found; i++) {\r\ncurrent_mca_slot =\r\nmca_find_unused_adapter(ne2_adapters[i].id, 0);\r\nif((current_mca_slot != MCA_NOTFOUND) && !adapter_found) {\r\nint res;\r\nmca_set_adapter_name(current_mca_slot,\r\nne2_adapters[i].name);\r\nmca_mark_as_used(current_mca_slot);\r\nres = ne2_probe1(dev, current_mca_slot);\r\nif (res)\r\nmca_mark_as_unused(current_mca_slot);\r\nreturn res;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init ne2_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_eip_netdev();\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_ne2_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int ne2_procinfo(char *buf, int slot, struct net_device *dev)\r\n{\r\nint len=0;\r\nlen += sprintf(buf+len, "The NE/2 Ethernet Adapter\n" );\r\nlen += sprintf(buf+len, "Driver written by Wim Dumon ");\r\nlen += sprintf(buf+len, "<wimpie@kotnet.org>\n");\r\nlen += sprintf(buf+len, "Modified by ");\r\nlen += sprintf(buf+len, "David Weinehall <tao@acc.umu.se>\n");\r\nlen += sprintf(buf+len, "and by Magnus Jonsson <bigfoot@acc.umu.se>\n");\r\nlen += sprintf(buf+len, "Based on the original NE2000 drivers\n" );\r\nlen += sprintf(buf+len, "Base IO: %#x\n", (unsigned int)dev->base_addr);\r\nlen += sprintf(buf+len, "IRQ : %d\n", dev->irq);\r\nlen += sprintf(buf+len, "HW addr : %pM\n", dev->dev_addr);\r\nreturn len;\r\n}\r\nstatic int __init ne2_probe1(struct net_device *dev, int slot)\r\n{\r\nint i, base_addr, irq, retval;\r\nunsigned char POS;\r\nunsigned char SA_prom[32];\r\nconst char *name = "NE/2";\r\nint start_page, stop_page;\r\nstatic unsigned version_printed;\r\nif (ei_debug && version_printed++ == 0)\r\nprintk(version);\r\nprintk("NE/2 ethercard found in slot %d:", slot);\r\nPOS = mca_read_stored_pos(slot, 2);\r\nif(!(POS % 2)) {\r\nprintk(" disabled.\n");\r\nreturn -ENODEV;\r\n}\r\nif (mca_read_stored_pos(slot, 0) == 0xea) {\r\nbase_addr = dlink_addresses[(POS >> 5) & 0x03];\r\nirq = dlink_irqs[(POS >> 2) & 0x07];\r\n}\r\nelse {\r\ni = (POS & 0xE)>>1;\r\nbase_addr = addresses[i - 1];\r\nirq = irqs[(POS & 0x60)>>5];\r\n}\r\nif (!request_region(base_addr, NE_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\n#ifdef DEBUG\r\nprintk("POS info : pos 2 = %#x ; base = %#x ; irq = %ld\n", POS,\r\nbase_addr, irq);\r\n#endif\r\n#ifndef CRYNWR_WAY\r\nfor (i=0; i<8; i++)\r\noutb(0x0, base_addr + NE_RESET);\r\ninb(base_addr + NE_RESET);\r\noutb(0x21, base_addr + NE_CMD);\r\nif (inb(base_addr + NE_CMD) != 0x21) {\r\nprintk("NE/2 adapter not responding\n");\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\n#else\r\n{\r\nunsigned long reset_start_time = jiffies;\r\noutb(inb(base_addr + NE_RESET), base_addr + NE_RESET);\r\nwhile ((inb_p(base_addr + EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\r\nprintk(" not found (no reset ack).\n");\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\noutb_p(0xff, base_addr + EN0_ISR);\r\n}\r\n#endif\r\n{\r\nstruct {\r\nunsigned char value, offset;\r\n} program_seq[] = {\r\n{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},\r\n{0x49, EN0_DCFG},\r\n{0x00, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_IMR},\r\n{0xFF, EN0_ISR},\r\n{E8390_RXOFF, EN0_RXCR},\r\n{E8390_TXOFF, EN0_TXCR},\r\n{32, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_RSARLO},\r\n{0x00, EN0_RSARHI},\r\n{E8390_RREAD+E8390_START, E8390_CMD},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\r\noutb_p(program_seq[i].value, base_addr +\r\nprogram_seq[i].offset);\r\n}\r\nfor(i = 0; i < 6 ; i+=1) {\r\nSA_prom[i] = inb(base_addr + NE_DATAPORT);\r\n}\r\nif (mca_read_stored_pos(slot, 0) == 0xea) {\r\nunsigned int v;\r\nfor (i = 0; i < 3; i++) {\r\nv = dlink_get_eeprom(i, base_addr);\r\nSA_prom[(i << 1) ] = v & 0xff;\r\nSA_prom[(i << 1) + 1] = (v >> 8) & 0xff;\r\n}\r\n}\r\nstart_page = NESM_START_PG;\r\nstop_page = NESM_STOP_PG;\r\ndev->irq=irq;\r\nretval = request_irq(dev->irq, eip_interrupt, 0, DRV_NAME, dev);\r\nif (retval) {\r\nprintk (" unable to get IRQ %d (irqval=%d).\n",\r\ndev->irq, retval);\r\ngoto out;\r\n}\r\ndev->base_addr = base_addr;\r\nfor(i = 0; i < ETHER_ADDR_LEN; i++)\r\ndev->dev_addr[i] = SA_prom[i];\r\nprintk(" %pM\n", dev->dev_addr);\r\nprintk("%s: %s found at %#x, using IRQ %d.\n",\r\ndev->name, name, base_addr, dev->irq);\r\nmca_set_adapter_procfn(slot, (MCA_ProcFn) ne2_procinfo, dev);\r\nei_status.name = name;\r\nei_status.tx_start_page = start_page;\r\nei_status.stop_page = stop_page;\r\nei_status.word16 = (2 == 2);\r\nei_status.rx_start_page = start_page + TX_PAGES;\r\n#ifdef PACKETBUF_MEMSIZE\r\nei_status.stop_page = ei_status.tx_start_page + PACKETBUF_MEMSIZE;\r\n#endif\r\nei_status.reset_8390 = &ne_reset_8390;\r\nei_status.block_input = &ne_block_input;\r\nei_status.block_output = &ne_block_output;\r\nei_status.get_8390_hdr = &ne_get_8390_hdr;\r\nei_status.priv = slot;\r\ndev->netdev_ops = &eip_netdev_ops;\r\nNS8390p_init(dev, 0);\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out1;\r\nreturn 0;\r\nout1:\r\nmca_set_adapter_procfn( ei_status.priv, NULL, NULL);\r\nfree_irq(dev->irq, dev);\r\nout:\r\nrelease_region(base_addr, NE_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic void ne_reset_8390(struct net_device *dev)\r\n{\r\nunsigned long reset_start_time = jiffies;\r\nif (ei_debug > 1)\r\nprintk("resetting the 8390 t=%ld...", jiffies);\r\noutb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\r\nei_status.txing = 0;\r\nei_status.dmaing = 0;\r\nwhile ((inb_p(NE_BASE+EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\r\nprintk("%s: ne_reset_8390() did not complete.\n",\r\ndev->name);\r\nbreak;\r\n}\r\noutb_p(ENISR_RESET, NE_BASE + EN0_ISR);\r\n}\r\nstatic void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\r\nint ring_page)\r\n{\r\nint nic_base = dev->base_addr;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne_get_8390_hdr "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\r\noutb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\r\noutb_p(0, nic_base + EN0_RCNTHI);\r\noutb_p(0, nic_base + EN0_RSARLO);\r\noutb_p(ring_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16)\r\ninsw(NE_BASE + NE_DATAPORT, hdr,\r\nsizeof(struct e8390_pkt_hdr)>>1);\r\nelse\r\ninsb(NE_BASE + NE_DATAPORT, hdr,\r\nsizeof(struct e8390_pkt_hdr));\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void ne_block_input(struct net_device *dev, int count, struct sk_buff *skb,\r\nint ring_offset)\r\n{\r\n#ifdef NE_SANITY_CHECK\r\nint xfer_count = count;\r\n#endif\r\nint nic_base = dev->base_addr;\r\nchar *buf = skb->data;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne_block_input "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\r\noutb_p(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb_p(count >> 8, nic_base + EN0_RCNTHI);\r\noutb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);\r\noutb_p(ring_offset >> 8, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16) {\r\ninsw(NE_BASE + NE_DATAPORT,buf,count>>1);\r\nif (count & 0x01) {\r\nbuf[count-1] = inb(NE_BASE + NE_DATAPORT);\r\n#ifdef NE_SANITY_CHECK\r\nxfer_count++;\r\n#endif\r\n}\r\n} else {\r\ninsb(NE_BASE + NE_DATAPORT, buf, count);\r\n}\r\n#ifdef NE_SANITY_CHECK\r\nif (ei_debug > 1) {\r\nint addr, tries = 20;\r\ndo {\r\nint high = inb_p(nic_base + EN0_RSARHI);\r\nint low = inb_p(nic_base + EN0_RSARLO);\r\naddr = (high << 8) + low;\r\nif (((ring_offset + xfer_count) & 0xff) == low)\r\nbreak;\r\n} while (--tries > 0);\r\nif (tries <= 0)\r\nprintk("%s: RX transfer address mismatch,"\r\n"%#4.4x (expected) vs. %#4.4x (actual).\n",\r\ndev->name, ring_offset + xfer_count, addr);\r\n}\r\n#endif\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void ne_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, const int start_page)\r\n{\r\nint nic_base = NE_BASE;\r\nunsigned long dma_start;\r\n#ifdef NE_SANITY_CHECK\r\nint retries = 0;\r\n#endif\r\nif (ei_status.word16 && (count & 0x01))\r\ncount++;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne_block_output."\r\n"[DMAstat:%d][irqlock:%d]\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\r\n#ifdef NE_SANITY_CHECK\r\nretry:\r\n#endif\r\n#ifdef NE8390_RW_BUGFIX\r\noutb_p(0x42, nic_base + EN0_RCNTLO);\r\noutb_p(0x00, nic_base + EN0_RCNTHI);\r\noutb_p(0x42, nic_base + EN0_RSARLO);\r\noutb_p(0x00, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nSLOW_DOWN_IO;\r\nSLOW_DOWN_IO;\r\nSLOW_DOWN_IO;\r\n#endif\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\noutb_p(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb_p(count >> 8, nic_base + EN0_RCNTHI);\r\noutb_p(0x00, nic_base + EN0_RSARLO);\r\noutb_p(start_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16) {\r\noutsw(NE_BASE + NE_DATAPORT, buf, count>>1);\r\n} else {\r\noutsb(NE_BASE + NE_DATAPORT, buf, count);\r\n}\r\ndma_start = jiffies;\r\n#ifdef NE_SANITY_CHECK\r\nif (ei_debug > 1) {\r\nint addr, tries = 20;\r\ndo {\r\nint high = inb_p(nic_base + EN0_RSARHI);\r\nint low = inb_p(nic_base + EN0_RSARLO);\r\naddr = (high << 8) + low;\r\nif ((start_page << 8) + count == addr)\r\nbreak;\r\n} while (--tries > 0);\r\nif (tries <= 0) {\r\nprintk("%s: Tx packet transfer address mismatch,"\r\n"%#4.4x (expected) vs. %#4.4x (actual).\n",\r\ndev->name, (start_page << 8) + count, addr);\r\nif (retries++ == 0)\r\ngoto retry;\r\n}\r\n}\r\n#endif\r\nwhile ((inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)\r\nif (time_after(jiffies, dma_start + 2*HZ/100)) {\r\nprintk("%s: timeout waiting for Tx RDC.\n", dev->name);\r\nne_reset_8390(dev);\r\nNS8390p_init(dev, 1);\r\nbreak;\r\n}\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nint __init init_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\r\ndev = alloc_eip_netdev();\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->mem_end = bad[this_dev];\r\ndev->base_addr = io[this_dev];\r\nif (do_ne2_probe(dev) == 0) {\r\ndev_ne[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nprintk(KERN_WARNING "ne2.c: No NE/2 card found\n");\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nmca_mark_as_unused(ei_status.priv);\r\nmca_set_adapter_procfn( ei_status.priv, NULL, NULL);\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, NE_IO_EXTENT);\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_ne[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
