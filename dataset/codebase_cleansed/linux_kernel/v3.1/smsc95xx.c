static int smsc95xx_read_reg(struct usbnet *dev, u32 index, u32 *data)\r\n{\r\nu32 *buf = kmalloc(4, GFP_KERNEL);\r\nint ret;\r\nBUG_ON(!dev);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\r\nUSB_VENDOR_REQUEST_READ_REGISTER,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n00, index, buf, 4, USB_CTRL_GET_TIMEOUT);\r\nif (unlikely(ret < 0))\r\nnetdev_warn(dev->net, "Failed to read register index 0x%08x\n", index);\r\nle32_to_cpus(buf);\r\n*data = *buf;\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int smsc95xx_write_reg(struct usbnet *dev, u32 index, u32 data)\r\n{\r\nu32 *buf = kmalloc(4, GFP_KERNEL);\r\nint ret;\r\nBUG_ON(!dev);\r\nif (!buf)\r\nreturn -ENOMEM;\r\n*buf = data;\r\ncpu_to_le32s(buf);\r\nret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\nUSB_VENDOR_REQUEST_WRITE_REGISTER,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n00, index, buf, 4, USB_CTRL_SET_TIMEOUT);\r\nif (unlikely(ret < 0))\r\nnetdev_warn(dev->net, "Failed to write register index 0x%08x\n", index);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int smsc95xx_phy_wait_not_busy(struct usbnet *dev)\r\n{\r\nunsigned long start_time = jiffies;\r\nu32 val;\r\ndo {\r\nsmsc95xx_read_reg(dev, MII_ADDR, &val);\r\nif (!(val & MII_BUSY_))\r\nreturn 0;\r\n} while (!time_after(jiffies, start_time + HZ));\r\nreturn -EIO;\r\n}\r\nstatic int smsc95xx_mdio_read(struct net_device *netdev, int phy_id, int idx)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu32 val, addr;\r\nmutex_lock(&dev->phy_mutex);\r\nif (smsc95xx_phy_wait_not_busy(dev)) {\r\nnetdev_warn(dev->net, "MII is busy in smsc95xx_mdio_read\n");\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn -EIO;\r\n}\r\nphy_id &= dev->mii.phy_id_mask;\r\nidx &= dev->mii.reg_num_mask;\r\naddr = (phy_id << 11) | (idx << 6) | MII_READ_;\r\nsmsc95xx_write_reg(dev, MII_ADDR, addr);\r\nif (smsc95xx_phy_wait_not_busy(dev)) {\r\nnetdev_warn(dev->net, "Timed out reading MII reg %02X\n", idx);\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn -EIO;\r\n}\r\nsmsc95xx_read_reg(dev, MII_DATA, &val);\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn (u16)(val & 0xFFFF);\r\n}\r\nstatic void smsc95xx_mdio_write(struct net_device *netdev, int phy_id, int idx,\r\nint regval)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu32 val, addr;\r\nmutex_lock(&dev->phy_mutex);\r\nif (smsc95xx_phy_wait_not_busy(dev)) {\r\nnetdev_warn(dev->net, "MII is busy in smsc95xx_mdio_write\n");\r\nmutex_unlock(&dev->phy_mutex);\r\nreturn;\r\n}\r\nval = regval;\r\nsmsc95xx_write_reg(dev, MII_DATA, val);\r\nphy_id &= dev->mii.phy_id_mask;\r\nidx &= dev->mii.reg_num_mask;\r\naddr = (phy_id << 11) | (idx << 6) | MII_WRITE_;\r\nsmsc95xx_write_reg(dev, MII_ADDR, addr);\r\nif (smsc95xx_phy_wait_not_busy(dev))\r\nnetdev_warn(dev->net, "Timed out writing MII reg %02X\n", idx);\r\nmutex_unlock(&dev->phy_mutex);\r\n}\r\nstatic int smsc95xx_wait_eeprom(struct usbnet *dev)\r\n{\r\nunsigned long start_time = jiffies;\r\nu32 val;\r\ndo {\r\nsmsc95xx_read_reg(dev, E2P_CMD, &val);\r\nif (!(val & E2P_CMD_BUSY_) || (val & E2P_CMD_TIMEOUT_))\r\nbreak;\r\nudelay(40);\r\n} while (!time_after(jiffies, start_time + HZ));\r\nif (val & (E2P_CMD_TIMEOUT_ | E2P_CMD_BUSY_)) {\r\nnetdev_warn(dev->net, "EEPROM read operation timeout\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc95xx_eeprom_confirm_not_busy(struct usbnet *dev)\r\n{\r\nunsigned long start_time = jiffies;\r\nu32 val;\r\ndo {\r\nsmsc95xx_read_reg(dev, E2P_CMD, &val);\r\nif (!(val & E2P_CMD_BUSY_))\r\nreturn 0;\r\nudelay(40);\r\n} while (!time_after(jiffies, start_time + HZ));\r\nnetdev_warn(dev->net, "EEPROM is busy\n");\r\nreturn -EIO;\r\n}\r\nstatic int smsc95xx_read_eeprom(struct usbnet *dev, u32 offset, u32 length,\r\nu8 *data)\r\n{\r\nu32 val;\r\nint i, ret;\r\nBUG_ON(!dev);\r\nBUG_ON(!data);\r\nret = smsc95xx_eeprom_confirm_not_busy(dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < length; i++) {\r\nval = E2P_CMD_BUSY_ | E2P_CMD_READ_ | (offset & E2P_CMD_ADDR_);\r\nsmsc95xx_write_reg(dev, E2P_CMD, val);\r\nret = smsc95xx_wait_eeprom(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nsmsc95xx_read_reg(dev, E2P_DATA, &val);\r\ndata[i] = val & 0xFF;\r\noffset++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc95xx_write_eeprom(struct usbnet *dev, u32 offset, u32 length,\r\nu8 *data)\r\n{\r\nu32 val;\r\nint i, ret;\r\nBUG_ON(!dev);\r\nBUG_ON(!data);\r\nret = smsc95xx_eeprom_confirm_not_busy(dev);\r\nif (ret)\r\nreturn ret;\r\nval = E2P_CMD_BUSY_ | E2P_CMD_EWEN_;\r\nsmsc95xx_write_reg(dev, E2P_CMD, val);\r\nret = smsc95xx_wait_eeprom(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < length; i++) {\r\nval = data[i];\r\nsmsc95xx_write_reg(dev, E2P_DATA, val);\r\nval = E2P_CMD_BUSY_ | E2P_CMD_WRITE_ | (offset & E2P_CMD_ADDR_);\r\nsmsc95xx_write_reg(dev, E2P_CMD, val);\r\nret = smsc95xx_wait_eeprom(dev);\r\nif (ret < 0)\r\nreturn ret;\r\noffset++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void smsc95xx_async_cmd_callback(struct urb *urb)\r\n{\r\nstruct usb_context *usb_context = urb->context;\r\nstruct usbnet *dev = usb_context->dev;\r\nint status = urb->status;\r\nif (status < 0)\r\nnetdev_warn(dev->net, "async callback failed with %d\n", status);\r\nkfree(usb_context);\r\nusb_free_urb(urb);\r\n}\r\nstatic int smsc95xx_write_reg_async(struct usbnet *dev, u16 index, u32 *data)\r\n{\r\nstruct usb_context *usb_context;\r\nint status;\r\nstruct urb *urb;\r\nconst u16 size = 4;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_warn(dev->net, "Error allocating URB\n");\r\nreturn -ENOMEM;\r\n}\r\nusb_context = kmalloc(sizeof(struct usb_context), GFP_ATOMIC);\r\nif (usb_context == NULL) {\r\nnetdev_warn(dev->net, "Error allocating control msg\n");\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nusb_context->req.bRequestType =\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;\r\nusb_context->req.bRequest = USB_VENDOR_REQUEST_WRITE_REGISTER;\r\nusb_context->req.wValue = 00;\r\nusb_context->req.wIndex = cpu_to_le16(index);\r\nusb_context->req.wLength = cpu_to_le16(size);\r\nusb_fill_control_urb(urb, dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\n(void *)&usb_context->req, data, size,\r\nsmsc95xx_async_cmd_callback,\r\n(void *)usb_context);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status < 0) {\r\nnetdev_warn(dev->net, "Error submitting control msg, sts=%d\n",\r\nstatus);\r\nkfree(usb_context);\r\nusb_free_urb(urb);\r\n}\r\nreturn status;\r\n}\r\nstatic unsigned int smsc95xx_hash(char addr[ETH_ALEN])\r\n{\r\nreturn (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;\r\n}\r\nstatic void smsc95xx_set_multicast(struct net_device *netdev)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct smsc95xx_priv *pdata = (struct smsc95xx_priv *)(dev->data[0]);\r\nunsigned long flags;\r\npdata->hash_hi = 0;\r\npdata->hash_lo = 0;\r\nspin_lock_irqsave(&pdata->mac_cr_lock, flags);\r\nif (dev->net->flags & IFF_PROMISC) {\r\nnetif_dbg(dev, drv, dev->net, "promiscuous mode enabled\n");\r\npdata->mac_cr |= MAC_CR_PRMS_;\r\npdata->mac_cr &= ~(MAC_CR_MCPAS_ | MAC_CR_HPFILT_);\r\n} else if (dev->net->flags & IFF_ALLMULTI) {\r\nnetif_dbg(dev, drv, dev->net, "receive all multicast enabled\n");\r\npdata->mac_cr |= MAC_CR_MCPAS_;\r\npdata->mac_cr &= ~(MAC_CR_PRMS_ | MAC_CR_HPFILT_);\r\n} else if (!netdev_mc_empty(dev->net)) {\r\nstruct netdev_hw_addr *ha;\r\npdata->mac_cr |= MAC_CR_HPFILT_;\r\npdata->mac_cr &= ~(MAC_CR_PRMS_ | MAC_CR_MCPAS_);\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nu32 bitnum = smsc95xx_hash(ha->addr);\r\nu32 mask = 0x01 << (bitnum & 0x1F);\r\nif (bitnum & 0x20)\r\npdata->hash_hi |= mask;\r\nelse\r\npdata->hash_lo |= mask;\r\n}\r\nnetif_dbg(dev, drv, dev->net, "HASHH=0x%08X, HASHL=0x%08X\n",\r\npdata->hash_hi, pdata->hash_lo);\r\n} else {\r\nnetif_dbg(dev, drv, dev->net, "receive own packets only\n");\r\npdata->mac_cr &=\r\n~(MAC_CR_PRMS_ | MAC_CR_MCPAS_ | MAC_CR_HPFILT_);\r\n}\r\nspin_unlock_irqrestore(&pdata->mac_cr_lock, flags);\r\nsmsc95xx_write_reg_async(dev, HASHH, &pdata->hash_hi);\r\nsmsc95xx_write_reg_async(dev, HASHL, &pdata->hash_lo);\r\nsmsc95xx_write_reg_async(dev, MAC_CR, &pdata->mac_cr);\r\n}\r\nstatic void smsc95xx_phy_update_flowcontrol(struct usbnet *dev, u8 duplex,\r\nu16 lcladv, u16 rmtadv)\r\n{\r\nu32 flow, afc_cfg = 0;\r\nint ret = smsc95xx_read_reg(dev, AFC_CFG, &afc_cfg);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "error reading AFC_CFG\n");\r\nreturn;\r\n}\r\nif (duplex == DUPLEX_FULL) {\r\nu8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\r\nif (cap & FLOW_CTRL_RX)\r\nflow = 0xFFFF0002;\r\nelse\r\nflow = 0;\r\nif (cap & FLOW_CTRL_TX)\r\nafc_cfg |= 0xF;\r\nelse\r\nafc_cfg &= ~0xF;\r\nnetif_dbg(dev, link, dev->net, "rx pause %s, tx pause %s\n",\r\ncap & FLOW_CTRL_RX ? "enabled" : "disabled",\r\ncap & FLOW_CTRL_TX ? "enabled" : "disabled");\r\n} else {\r\nnetif_dbg(dev, link, dev->net, "half duplex\n");\r\nflow = 0;\r\nafc_cfg |= 0xF;\r\n}\r\nsmsc95xx_write_reg(dev, FLOW, flow);\r\nsmsc95xx_write_reg(dev, AFC_CFG, afc_cfg);\r\n}\r\nstatic int smsc95xx_link_reset(struct usbnet *dev)\r\n{\r\nstruct smsc95xx_priv *pdata = (struct smsc95xx_priv *)(dev->data[0]);\r\nstruct mii_if_info *mii = &dev->mii;\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nunsigned long flags;\r\nu16 lcladv, rmtadv;\r\nu32 intdata;\r\nsmsc95xx_mdio_read(dev->net, mii->phy_id, PHY_INT_SRC);\r\nintdata = 0xFFFFFFFF;\r\nsmsc95xx_write_reg(dev, INT_STS, intdata);\r\nmii_check_media(mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nlcladv = smsc95xx_mdio_read(dev->net, mii->phy_id, MII_ADVERTISE);\r\nrmtadv = smsc95xx_mdio_read(dev->net, mii->phy_id, MII_LPA);\r\nnetif_dbg(dev, link, dev->net,\r\n"speed: %u duplex: %d lcladv: %04x rmtadv: %04x\n",\r\nethtool_cmd_speed(&ecmd), ecmd.duplex, lcladv, rmtadv);\r\nspin_lock_irqsave(&pdata->mac_cr_lock, flags);\r\nif (ecmd.duplex != DUPLEX_FULL) {\r\npdata->mac_cr &= ~MAC_CR_FDPX_;\r\npdata->mac_cr |= MAC_CR_RCVOWN_;\r\n} else {\r\npdata->mac_cr &= ~MAC_CR_RCVOWN_;\r\npdata->mac_cr |= MAC_CR_FDPX_;\r\n}\r\nspin_unlock_irqrestore(&pdata->mac_cr_lock, flags);\r\nsmsc95xx_write_reg(dev, MAC_CR, pdata->mac_cr);\r\nsmsc95xx_phy_update_flowcontrol(dev, ecmd.duplex, lcladv, rmtadv);\r\nreturn 0;\r\n}\r\nstatic void smsc95xx_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nu32 intdata;\r\nif (urb->actual_length != 4) {\r\nnetdev_warn(dev->net, "unexpected urb length %d\n",\r\nurb->actual_length);\r\nreturn;\r\n}\r\nmemcpy(&intdata, urb->transfer_buffer, 4);\r\nle32_to_cpus(&intdata);\r\nnetif_dbg(dev, link, dev->net, "intdata: 0x%08X\n", intdata);\r\nif (intdata & INT_ENP_PHY_INT_)\r\nusbnet_defer_kevent(dev, EVENT_LINK_RESET);\r\nelse\r\nnetdev_warn(dev->net, "unexpected interrupt, intdata=0x%08X\n",\r\nintdata);\r\n}\r\nstatic int smsc95xx_set_features(struct net_device *netdev, u32 features)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu32 read_buf;\r\nint ret;\r\nret = smsc95xx_read_reg(dev, COE_CR, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read COE_CR: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (features & NETIF_F_HW_CSUM)\r\nread_buf |= Tx_COE_EN_;\r\nelse\r\nread_buf &= ~Tx_COE_EN_;\r\nif (features & NETIF_F_RXCSUM)\r\nread_buf |= Rx_COE_EN_;\r\nelse\r\nread_buf &= ~Rx_COE_EN_;\r\nret = smsc95xx_write_reg(dev, COE_CR, read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write COE_CR: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, hw, dev->net, "COE_CR = 0x%08x\n", read_buf);\r\nreturn 0;\r\n}\r\nstatic int smsc95xx_ethtool_get_eeprom_len(struct net_device *net)\r\n{\r\nreturn MAX_EEPROM_SIZE;\r\n}\r\nstatic int smsc95xx_ethtool_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nee->magic = LAN95XX_EEPROM_MAGIC;\r\nreturn smsc95xx_read_eeprom(dev, ee->offset, ee->len, data);\r\n}\r\nstatic int smsc95xx_ethtool_set_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nif (ee->magic != LAN95XX_EEPROM_MAGIC) {\r\nnetdev_warn(dev->net, "EEPROM: magic value mismatch, magic = 0x%x\n",\r\nee->magic);\r\nreturn -EINVAL;\r\n}\r\nreturn smsc95xx_write_eeprom(dev, ee->offset, ee->len, data);\r\n}\r\nstatic int smsc95xx_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nif (!netif_running(netdev))\r\nreturn -EINVAL;\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic void smsc95xx_init_mac_address(struct usbnet *dev)\r\n{\r\nif (smsc95xx_read_eeprom(dev, EEPROM_MAC_OFFSET, ETH_ALEN,\r\ndev->net->dev_addr) == 0) {\r\nif (is_valid_ether_addr(dev->net->dev_addr)) {\r\nnetif_dbg(dev, ifup, dev->net, "MAC address read from EEPROM\n");\r\nreturn;\r\n}\r\n}\r\nrandom_ether_addr(dev->net->dev_addr);\r\nnetif_dbg(dev, ifup, dev->net, "MAC address set to random_ether_addr\n");\r\n}\r\nstatic int smsc95xx_set_mac_address(struct usbnet *dev)\r\n{\r\nu32 addr_lo = dev->net->dev_addr[0] | dev->net->dev_addr[1] << 8 |\r\ndev->net->dev_addr[2] << 16 | dev->net->dev_addr[3] << 24;\r\nu32 addr_hi = dev->net->dev_addr[4] | dev->net->dev_addr[5] << 8;\r\nint ret;\r\nret = smsc95xx_write_reg(dev, ADDRL, addr_lo);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write ADDRL: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc95xx_write_reg(dev, ADDRH, addr_hi);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write ADDRH: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void smsc95xx_start_tx_path(struct usbnet *dev)\r\n{\r\nstruct smsc95xx_priv *pdata = (struct smsc95xx_priv *)(dev->data[0]);\r\nunsigned long flags;\r\nu32 reg_val;\r\nspin_lock_irqsave(&pdata->mac_cr_lock, flags);\r\npdata->mac_cr |= MAC_CR_TXEN_;\r\nspin_unlock_irqrestore(&pdata->mac_cr_lock, flags);\r\nsmsc95xx_write_reg(dev, MAC_CR, pdata->mac_cr);\r\nreg_val = TX_CFG_ON_;\r\nsmsc95xx_write_reg(dev, TX_CFG, reg_val);\r\n}\r\nstatic void smsc95xx_start_rx_path(struct usbnet *dev)\r\n{\r\nstruct smsc95xx_priv *pdata = (struct smsc95xx_priv *)(dev->data[0]);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->mac_cr_lock, flags);\r\npdata->mac_cr |= MAC_CR_RXEN_;\r\nspin_unlock_irqrestore(&pdata->mac_cr_lock, flags);\r\nsmsc95xx_write_reg(dev, MAC_CR, pdata->mac_cr);\r\n}\r\nstatic int smsc95xx_phy_initialize(struct usbnet *dev)\r\n{\r\nint bmcr, timeout = 0;\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = smsc95xx_mdio_read;\r\ndev->mii.mdio_write = smsc95xx_mdio_write;\r\ndev->mii.phy_id_mask = 0x1f;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndev->mii.phy_id = SMSC95XX_INTERNAL_PHY_ID;\r\nsmsc95xx_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\r\ndo {\r\nmsleep(10);\r\nbmcr = smsc95xx_mdio_read(dev->net, dev->mii.phy_id, MII_BMCR);\r\ntimeout++;\r\n} while ((bmcr & BMCR_RESET) && (timeout < 100));\r\nif (timeout >= 100) {\r\nnetdev_warn(dev->net, "timeout on PHY Reset");\r\nreturn -EIO;\r\n}\r\nsmsc95xx_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\r\nADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP |\r\nADVERTISE_PAUSE_ASYM);\r\nsmsc95xx_mdio_read(dev->net, dev->mii.phy_id, PHY_INT_SRC);\r\nsmsc95xx_mdio_write(dev->net, dev->mii.phy_id, PHY_INT_MASK,\r\nPHY_INT_MASK_DEFAULT_);\r\nmii_nway_restart(&dev->mii);\r\nnetif_dbg(dev, ifup, dev->net, "phy initialised successfully\n");\r\nreturn 0;\r\n}\r\nstatic int smsc95xx_reset(struct usbnet *dev)\r\n{\r\nstruct smsc95xx_priv *pdata = (struct smsc95xx_priv *)(dev->data[0]);\r\nu32 read_buf, write_buf, burst_cap;\r\nint ret = 0, timeout;\r\nnetif_dbg(dev, ifup, dev->net, "entering smsc95xx_reset\n");\r\nwrite_buf = HW_CFG_LRST_;\r\nret = smsc95xx_write_reg(dev, HW_CFG, write_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write HW_CFG_LRST_ bit in HW_CFG register, ret = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ntimeout = 0;\r\ndo {\r\nret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(10);\r\ntimeout++;\r\n} while ((read_buf & HW_CFG_LRST_) && (timeout < 100));\r\nif (timeout >= 100) {\r\nnetdev_warn(dev->net, "timeout waiting for completion of Lite Reset\n");\r\nreturn ret;\r\n}\r\nwrite_buf = PM_CTL_PHY_RST_;\r\nret = smsc95xx_write_reg(dev, PM_CTRL, write_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write PM_CTRL: %d\n", ret);\r\nreturn ret;\r\n}\r\ntimeout = 0;\r\ndo {\r\nret = smsc95xx_read_reg(dev, PM_CTRL, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read PM_CTRL: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(10);\r\ntimeout++;\r\n} while ((read_buf & PM_CTL_PHY_RST_) && (timeout < 100));\r\nif (timeout >= 100) {\r\nnetdev_warn(dev->net, "timeout waiting for PHY Reset\n");\r\nreturn ret;\r\n}\r\nret = smsc95xx_set_mac_address(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nnetif_dbg(dev, ifup, dev->net,\r\n"MAC Address: %pM\n", dev->net->dev_addr);\r\nret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"Read Value from HW_CFG : 0x%08x\n", read_buf);\r\nread_buf |= HW_CFG_BIR_;\r\nret = smsc95xx_write_reg(dev, HW_CFG, read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write HW_CFG_BIR_ bit in HW_CFG register, ret = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"Read Value from HW_CFG after writing HW_CFG_BIR_: 0x%08x\n",\r\nread_buf);\r\nif (!turbo_mode) {\r\nburst_cap = 0;\r\ndev->rx_urb_size = MAX_SINGLE_PACKET_SIZE;\r\n} else if (dev->udev->speed == USB_SPEED_HIGH) {\r\nburst_cap = DEFAULT_HS_BURST_CAP_SIZE / HS_USB_PKT_SIZE;\r\ndev->rx_urb_size = DEFAULT_HS_BURST_CAP_SIZE;\r\n} else {\r\nburst_cap = DEFAULT_FS_BURST_CAP_SIZE / FS_USB_PKT_SIZE;\r\ndev->rx_urb_size = DEFAULT_FS_BURST_CAP_SIZE;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"rx_urb_size=%ld\n", (ulong)dev->rx_urb_size);\r\nret = smsc95xx_write_reg(dev, BURST_CAP, burst_cap);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write BURST_CAP: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc95xx_read_reg(dev, BURST_CAP, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read BURST_CAP: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"Read Value from BURST_CAP after writing: 0x%08x\n",\r\nread_buf);\r\nread_buf = DEFAULT_BULK_IN_DELAY;\r\nret = smsc95xx_write_reg(dev, BULK_IN_DLY, read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc95xx_read_reg(dev, BULK_IN_DLY, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read BULK_IN_DLY: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"Read Value from BULK_IN_DLY after writing: 0x%08x\n",\r\nread_buf);\r\nret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"Read Value from HW_CFG: 0x%08x\n", read_buf);\r\nif (turbo_mode)\r\nread_buf |= (HW_CFG_MEF_ | HW_CFG_BCE_);\r\nread_buf &= ~HW_CFG_RXDOFF_;\r\nread_buf |= NET_IP_ALIGN << 9;\r\nret = smsc95xx_write_reg(dev, HW_CFG, read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write HW_CFG register, ret=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read HW_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net,\r\n"Read Value from HW_CFG after writing: 0x%08x\n", read_buf);\r\nwrite_buf = 0xFFFFFFFF;\r\nret = smsc95xx_write_reg(dev, INT_STS, write_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write INT_STS register, ret=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = smsc95xx_read_reg(dev, ID_REV, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read ID_REV: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetif_dbg(dev, ifup, dev->net, "ID_REV = 0x%08x\n", read_buf);\r\nwrite_buf = LED_GPIO_CFG_SPD_LED | LED_GPIO_CFG_LNK_LED |\r\nLED_GPIO_CFG_FDX_LED;\r\nret = smsc95xx_write_reg(dev, LED_GPIO_CFG, write_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write LED_GPIO_CFG register, ret=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nwrite_buf = 0;\r\nret = smsc95xx_write_reg(dev, FLOW, write_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write FLOW: %d\n", ret);\r\nreturn ret;\r\n}\r\nread_buf = AFC_CFG_DEFAULT;\r\nret = smsc95xx_write_reg(dev, AFC_CFG, read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write AFC_CFG: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = smsc95xx_read_reg(dev, MAC_CR, &pdata->mac_cr);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read MAC_CR: %d\n", ret);\r\nreturn ret;\r\n}\r\nwrite_buf = (u32)ETH_P_8021Q;\r\nret = smsc95xx_write_reg(dev, VLAN1, write_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write VAN1: %d\n", ret);\r\nreturn ret;\r\n}\r\nsmsc95xx_set_features(dev->net, dev->net->features);\r\nsmsc95xx_set_multicast(dev->net);\r\nif (smsc95xx_phy_initialize(dev) < 0)\r\nreturn -EIO;\r\nret = smsc95xx_read_reg(dev, INT_EP_CTL, &read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to read INT_EP_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nread_buf |= INT_EP_CTL_PHY_INT_;\r\nret = smsc95xx_write_reg(dev, INT_EP_CTL, read_buf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "Failed to write INT_EP_CTL: %d\n", ret);\r\nreturn ret;\r\n}\r\nsmsc95xx_start_tx_path(dev);\r\nsmsc95xx_start_rx_path(dev);\r\nnetif_dbg(dev, ifup, dev->net, "smsc95xx_reset, return 0\n");\r\nreturn 0;\r\n}\r\nstatic int smsc95xx_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct smsc95xx_priv *pdata = NULL;\r\nint ret;\r\nprintk(KERN_INFO SMSC_CHIPNAME " v" SMSC_DRIVER_VERSION "\n");\r\nret = usbnet_get_endpoints(dev, intf);\r\nif (ret < 0) {\r\nnetdev_warn(dev->net, "usbnet_get_endpoints failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev->data[0] = (unsigned long)kzalloc(sizeof(struct smsc95xx_priv),\r\nGFP_KERNEL);\r\npdata = (struct smsc95xx_priv *)(dev->data[0]);\r\nif (!pdata) {\r\nnetdev_warn(dev->net, "Unable to allocate struct smsc95xx_priv\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&pdata->mac_cr_lock);\r\nif (DEFAULT_TX_CSUM_ENABLE)\r\ndev->net->features |= NETIF_F_HW_CSUM;\r\nif (DEFAULT_RX_CSUM_ENABLE)\r\ndev->net->features |= NETIF_F_RXCSUM;\r\ndev->net->hw_features = NETIF_F_HW_CSUM | NETIF_F_RXCSUM;\r\nsmsc95xx_init_mac_address(dev);\r\nret = smsc95xx_reset(dev);\r\ndev->net->netdev_ops = &smsc95xx_netdev_ops;\r\ndev->net->ethtool_ops = &smsc95xx_ethtool_ops;\r\ndev->net->flags |= IFF_MULTICAST;\r\ndev->net->hard_header_len += SMSC95XX_TX_OVERHEAD_CSUM;\r\nreturn 0;\r\n}\r\nstatic void smsc95xx_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct smsc95xx_priv *pdata = (struct smsc95xx_priv *)(dev->data[0]);\r\nif (pdata) {\r\nnetif_dbg(dev, ifdown, dev->net, "free pdata\n");\r\nkfree(pdata);\r\npdata = NULL;\r\ndev->data[0] = 0;\r\n}\r\n}\r\nstatic void smsc95xx_rx_csum_offload(struct sk_buff *skb)\r\n{\r\nskb->csum = *(u16 *)(skb_tail_pointer(skb) - 2);\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\nskb_trim(skb, skb->len - 2);\r\n}\r\nstatic int smsc95xx_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nwhile (skb->len > 0) {\r\nu32 header, align_count;\r\nstruct sk_buff *ax_skb;\r\nunsigned char *packet;\r\nu16 size;\r\nmemcpy(&header, skb->data, sizeof(header));\r\nle32_to_cpus(&header);\r\nskb_pull(skb, 4 + NET_IP_ALIGN);\r\npacket = skb->data;\r\nsize = (u16)((header & RX_STS_FL_) >> 16);\r\nalign_count = (4 - ((size + NET_IP_ALIGN) % 4)) % 4;\r\nif (unlikely(header & RX_STS_ES_)) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"Error header=0x%08x\n", header);\r\ndev->net->stats.rx_errors++;\r\ndev->net->stats.rx_dropped++;\r\nif (header & RX_STS_CRC_) {\r\ndev->net->stats.rx_crc_errors++;\r\n} else {\r\nif (header & (RX_STS_TL_ | RX_STS_RF_))\r\ndev->net->stats.rx_frame_errors++;\r\nif ((header & RX_STS_LE_) &&\r\n(!(header & RX_STS_FT_)))\r\ndev->net->stats.rx_length_errors++;\r\n}\r\n} else {\r\nif (unlikely(size > (ETH_FRAME_LEN + 12))) {\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"size err header=0x%08x\n", header);\r\nreturn 0;\r\n}\r\nif (skb->len == size) {\r\nif (dev->net->features & NETIF_F_RXCSUM)\r\nsmsc95xx_rx_csum_offload(skb);\r\nskb_trim(skb, skb->len - 4);\r\nskb->truesize = size + sizeof(struct sk_buff);\r\nreturn 1;\r\n}\r\nax_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!ax_skb)) {\r\nnetdev_warn(dev->net, "Error allocating skb\n");\r\nreturn 0;\r\n}\r\nax_skb->len = size;\r\nax_skb->data = packet;\r\nskb_set_tail_pointer(ax_skb, size);\r\nif (dev->net->features & NETIF_F_RXCSUM)\r\nsmsc95xx_rx_csum_offload(ax_skb);\r\nskb_trim(ax_skb, ax_skb->len - 4);\r\nax_skb->truesize = size + sizeof(struct sk_buff);\r\nusbnet_skb_return(dev, ax_skb);\r\n}\r\nskb_pull(skb, size);\r\nif (skb->len)\r\nskb_pull(skb, align_count);\r\n}\r\nif (unlikely(skb->len < 0)) {\r\nnetdev_warn(dev->net, "invalid rx length<0 %d\n", skb->len);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic u32 smsc95xx_calc_csum_preamble(struct sk_buff *skb)\r\n{\r\nu16 low_16 = (u16)skb_checksum_start_offset(skb);\r\nu16 high_16 = low_16 + skb->csum_offset;\r\nreturn (high_16 << 16) | low_16;\r\n}\r\nstatic struct sk_buff *smsc95xx_tx_fixup(struct usbnet *dev,\r\nstruct sk_buff *skb, gfp_t flags)\r\n{\r\nbool csum = skb->ip_summed == CHECKSUM_PARTIAL;\r\nint overhead = csum ? SMSC95XX_TX_OVERHEAD_CSUM : SMSC95XX_TX_OVERHEAD;\r\nu32 tx_cmd_a, tx_cmd_b;\r\nBUG_ON(skb_shinfo(skb)->nr_frags);\r\nif (skb_headroom(skb) < overhead) {\r\nstruct sk_buff *skb2 = skb_copy_expand(skb,\r\noverhead, 0, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\nif (csum) {\r\nif (skb->len <= 45) {\r\nlong csstart = skb_checksum_start_offset(skb);\r\n__wsum calc = csum_partial(skb->data + csstart,\r\nskb->len - csstart, 0);\r\n*((__sum16 *)(skb->data + csstart\r\n+ skb->csum_offset)) = csum_fold(calc);\r\ncsum = false;\r\n} else {\r\nu32 csum_preamble = smsc95xx_calc_csum_preamble(skb);\r\nskb_push(skb, 4);\r\nmemcpy(skb->data, &csum_preamble, 4);\r\n}\r\n}\r\nskb_push(skb, 4);\r\ntx_cmd_b = (u32)(skb->len - 4);\r\nif (csum)\r\ntx_cmd_b |= TX_CMD_B_CSUM_ENABLE;\r\ncpu_to_le32s(&tx_cmd_b);\r\nmemcpy(skb->data, &tx_cmd_b, 4);\r\nskb_push(skb, 4);\r\ntx_cmd_a = (u32)(skb->len - 8) | TX_CMD_A_FIRST_SEG_ |\r\nTX_CMD_A_LAST_SEG_;\r\ncpu_to_le32s(&tx_cmd_a);\r\nmemcpy(skb->data, &tx_cmd_a, 4);\r\nreturn skb;\r\n}\r\nstatic int __init smsc95xx_init(void)\r\n{\r\nreturn usb_register(&smsc95xx_driver);\r\n}\r\nstatic void __exit smsc95xx_exit(void)\r\n{\r\nusb_deregister(&smsc95xx_driver);\r\n}
