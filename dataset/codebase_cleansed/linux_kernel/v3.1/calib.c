static int16_t ath9k_hw_get_nf_hist_mid(int16_t *nfCalBuffer)\r\n{\r\nint16_t nfval;\r\nint16_t sort[ATH9K_NF_CAL_HIST_MAX];\r\nint i, j;\r\nfor (i = 0; i < ATH9K_NF_CAL_HIST_MAX; i++)\r\nsort[i] = nfCalBuffer[i];\r\nfor (i = 0; i < ATH9K_NF_CAL_HIST_MAX - 1; i++) {\r\nfor (j = 1; j < ATH9K_NF_CAL_HIST_MAX - i; j++) {\r\nif (sort[j] > sort[j - 1]) {\r\nnfval = sort[j];\r\nsort[j] = sort[j - 1];\r\nsort[j - 1] = nfval;\r\n}\r\n}\r\n}\r\nnfval = sort[(ATH9K_NF_CAL_HIST_MAX - 1) >> 1];\r\nreturn nfval;\r\n}\r\nstatic struct ath_nf_limits *ath9k_hw_get_nf_limits(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct ath_nf_limits *limit;\r\nif (!chan || IS_CHAN_2GHZ(chan))\r\nlimit = &ah->nf_2g;\r\nelse\r\nlimit = &ah->nf_5g;\r\nreturn limit;\r\n}\r\nstatic s16 ath9k_hw_get_default_nf(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nreturn ath9k_hw_get_nf_limits(ah, chan)->nominal;\r\n}\r\nstatic void ath9k_hw_update_nfcal_hist_buffer(struct ath_hw *ah,\r\nstruct ath9k_hw_cal_data *cal,\r\nint16_t *nfarray)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_conf *conf = &common->hw->conf;\r\nstruct ath_nf_limits *limit;\r\nstruct ath9k_nfcal_hist *h;\r\nbool high_nf_mid = false;\r\nu8 chainmask = (ah->rxchainmask << 3) | ah->rxchainmask;\r\nint i;\r\nh = cal->nfCalHist;\r\nlimit = ath9k_hw_get_nf_limits(ah, ah->curchan);\r\nfor (i = 0; i < NUM_NF_READINGS; i++) {\r\nif (!(chainmask & (1 << i)) ||\r\n((i >= AR5416_MAX_CHAINS) && !conf_is_ht40(conf)))\r\ncontinue;\r\nh[i].nfCalBuffer[h[i].currIndex] = nfarray[i];\r\nif (++h[i].currIndex >= ATH9K_NF_CAL_HIST_MAX)\r\nh[i].currIndex = 0;\r\nif (h[i].invalidNFcount > 0) {\r\nh[i].invalidNFcount--;\r\nh[i].privNF = nfarray[i];\r\n} else {\r\nh[i].privNF =\r\nath9k_hw_get_nf_hist_mid(h[i].nfCalBuffer);\r\n}\r\nif (!h[i].privNF)\r\ncontinue;\r\nif (h[i].privNF > limit->max) {\r\nhigh_nf_mid = true;\r\nath_dbg(common, ATH_DBG_CALIBRATE,\r\n"NFmid[%d] (%d) > MAX (%d), %s\n",\r\ni, h[i].privNF, limit->max,\r\n(cal->nfcal_interference ?\r\n"not corrected (due to interference)" :\r\n"correcting to MAX"));\r\nif (!cal->nfcal_interference)\r\nh[i].privNF = limit->max;\r\n}\r\n}\r\nif (!high_nf_mid)\r\ncal->nfcal_interference = false;\r\n}\r\nstatic bool ath9k_hw_get_nf_thresh(struct ath_hw *ah,\r\nenum ieee80211_band band,\r\nint16_t *nft)\r\n{\r\nswitch (band) {\r\ncase IEEE80211_BAND_5GHZ:\r\n*nft = (int8_t)ah->eep_ops->get_eeprom(ah, EEP_NFTHRESH_5);\r\nbreak;\r\ncase IEEE80211_BAND_2GHZ:\r\n*nft = (int8_t)ah->eep_ops->get_eeprom(ah, EEP_NFTHRESH_2);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid ath9k_hw_reset_calibration(struct ath_hw *ah,\r\nstruct ath9k_cal_list *currCal)\r\n{\r\nint i;\r\nath9k_hw_setup_calibration(ah, currCal);\r\ncurrCal->calState = CAL_RUNNING;\r\nfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\r\nah->meas0.sign[i] = 0;\r\nah->meas1.sign[i] = 0;\r\nah->meas2.sign[i] = 0;\r\nah->meas3.sign[i] = 0;\r\n}\r\nah->cal_samples = 0;\r\n}\r\nbool ath9k_hw_reset_calvalid(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_conf *conf = &common->hw->conf;\r\nstruct ath9k_cal_list *currCal = ah->cal_list_curr;\r\nif (!ah->caldata)\r\nreturn true;\r\nif (!AR_SREV_9100(ah) && !AR_SREV_9160_10_OR_LATER(ah))\r\nreturn true;\r\nif (currCal == NULL)\r\nreturn true;\r\nif (currCal->calState != CAL_DONE) {\r\nath_dbg(common, ATH_DBG_CALIBRATE,\r\n"Calibration state incorrect, %d\n",\r\ncurrCal->calState);\r\nreturn true;\r\n}\r\nif (!(ah->supp_cals & currCal->calData->calType))\r\nreturn true;\r\nath_dbg(common, ATH_DBG_CALIBRATE,\r\n"Resetting Cal %d state for channel %u\n",\r\ncurrCal->calData->calType, conf->channel->center_freq);\r\nah->caldata->CalValid &= ~currCal->calData->calType;\r\ncurrCal->calState = CAL_WAITING;\r\nreturn false;\r\n}\r\nvoid ath9k_hw_start_nfcal(struct ath_hw *ah, bool update)\r\n{\r\nif (ah->caldata)\r\nah->caldata->nfcal_pending = true;\r\nREG_SET_BIT(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_ENABLE_NF);\r\nif (update)\r\nREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_NO_UPDATE_NF);\r\nelse\r\nREG_SET_BIT(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_NO_UPDATE_NF);\r\nREG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);\r\n}\r\nvoid ath9k_hw_loadnf(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nstruct ath9k_nfcal_hist *h = NULL;\r\nunsigned i, j;\r\nint32_t val;\r\nu8 chainmask = (ah->rxchainmask << 3) | ah->rxchainmask;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_conf *conf = &common->hw->conf;\r\ns16 default_nf = ath9k_hw_get_default_nf(ah, chan);\r\nif (ah->caldata)\r\nh = ah->caldata->nfCalHist;\r\nfor (i = 0; i < NUM_NF_READINGS; i++) {\r\nif (chainmask & (1 << i)) {\r\ns16 nfval;\r\nif ((i >= AR5416_MAX_CHAINS) && !conf_is_ht40(conf))\r\ncontinue;\r\nif (h)\r\nnfval = h[i].privNF;\r\nelse\r\nnfval = default_nf;\r\nval = REG_READ(ah, ah->nf_regs[i]);\r\nval &= 0xFFFFFE00;\r\nval |= (((u32) nfval << 1) & 0x1ff);\r\nREG_WRITE(ah, ah->nf_regs[i], val);\r\n}\r\n}\r\nREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_ENABLE_NF);\r\nREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_NO_UPDATE_NF);\r\nREG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);\r\nfor (j = 0; j < 10000; j++) {\r\nif ((REG_READ(ah, AR_PHY_AGC_CONTROL) &\r\nAR_PHY_AGC_CONTROL_NF) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (j == 10000) {\r\nath_dbg(common, ATH_DBG_ANY,\r\n"Timeout while waiting for nf to load: AR_PHY_AGC_CONTROL=0x%x\n",\r\nREG_READ(ah, AR_PHY_AGC_CONTROL));\r\nreturn;\r\n}\r\nENABLE_REGWRITE_BUFFER(ah);\r\nfor (i = 0; i < NUM_NF_READINGS; i++) {\r\nif (chainmask & (1 << i)) {\r\nif ((i >= AR5416_MAX_CHAINS) && !conf_is_ht40(conf))\r\ncontinue;\r\nval = REG_READ(ah, ah->nf_regs[i]);\r\nval &= 0xFFFFFE00;\r\nval |= (((u32) (-50) << 1) & 0x1ff);\r\nREG_WRITE(ah, ah->nf_regs[i], val);\r\n}\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nstatic void ath9k_hw_nf_sanitize(struct ath_hw *ah, s16 *nf)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath_nf_limits *limit;\r\nint i;\r\nif (IS_CHAN_2GHZ(ah->curchan))\r\nlimit = &ah->nf_2g;\r\nelse\r\nlimit = &ah->nf_5g;\r\nfor (i = 0; i < NUM_NF_READINGS; i++) {\r\nif (!nf[i])\r\ncontinue;\r\nath_dbg(common, ATH_DBG_CALIBRATE,\r\n"NF calibrated [%s] [chain %d] is %d\n",\r\n(i >= 3 ? "ext" : "ctl"), i % 3, nf[i]);\r\nif (nf[i] > ATH9K_NF_TOO_HIGH) {\r\nath_dbg(common, ATH_DBG_CALIBRATE,\r\n"NF[%d] (%d) > MAX (%d), correcting to MAX\n",\r\ni, nf[i], ATH9K_NF_TOO_HIGH);\r\nnf[i] = limit->max;\r\n} else if (nf[i] < limit->min) {\r\nath_dbg(common, ATH_DBG_CALIBRATE,\r\n"NF[%d] (%d) < MIN (%d), correcting to NOM\n",\r\ni, nf[i], limit->min);\r\nnf[i] = limit->nominal;\r\n}\r\n}\r\n}\r\nbool ath9k_hw_getnf(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint16_t nf, nfThresh;\r\nint16_t nfarray[NUM_NF_READINGS] = { 0 };\r\nstruct ath9k_nfcal_hist *h;\r\nstruct ieee80211_channel *c = chan->chan;\r\nstruct ath9k_hw_cal_data *caldata = ah->caldata;\r\nchan->channelFlags &= (~CHANNEL_CW_INT);\r\nif (REG_READ(ah, AR_PHY_AGC_CONTROL) & AR_PHY_AGC_CONTROL_NF) {\r\nath_dbg(common, ATH_DBG_CALIBRATE,\r\n"NF did not complete in calibration window\n");\r\nreturn false;\r\n}\r\nath9k_hw_do_getnf(ah, nfarray);\r\nath9k_hw_nf_sanitize(ah, nfarray);\r\nnf = nfarray[0];\r\nif (ath9k_hw_get_nf_thresh(ah, c->band, &nfThresh)\r\n&& nf > nfThresh) {\r\nath_dbg(common, ATH_DBG_CALIBRATE,\r\n"noise floor failed detected; detected %d, threshold %d\n",\r\nnf, nfThresh);\r\nchan->channelFlags |= CHANNEL_CW_INT;\r\n}\r\nif (!caldata) {\r\nchan->noisefloor = nf;\r\nreturn false;\r\n}\r\nh = caldata->nfCalHist;\r\ncaldata->nfcal_pending = false;\r\nath9k_hw_update_nfcal_hist_buffer(ah, caldata, nfarray);\r\nchan->noisefloor = h[0].privNF;\r\nreturn true;\r\n}\r\nvoid ath9k_init_nfcal_hist_buffer(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct ath9k_nfcal_hist *h;\r\ns16 default_nf;\r\nint i, j;\r\nah->caldata->channel = chan->channel;\r\nah->caldata->channelFlags = chan->channelFlags & ~CHANNEL_CW_INT;\r\nh = ah->caldata->nfCalHist;\r\ndefault_nf = ath9k_hw_get_default_nf(ah, chan);\r\nfor (i = 0; i < NUM_NF_READINGS; i++) {\r\nh[i].currIndex = 0;\r\nh[i].privNF = default_nf;\r\nh[i].invalidNFcount = AR_PHY_CCA_FILTERWINDOW_LENGTH;\r\nfor (j = 0; j < ATH9K_NF_CAL_HIST_MAX; j++) {\r\nh[i].nfCalBuffer[j] = default_nf;\r\n}\r\n}\r\n}\r\nvoid ath9k_hw_bstuck_nfcal(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_cal_data *caldata = ah->caldata;\r\nif (unlikely(!caldata))\r\nreturn;\r\nif (!caldata->nfcal_pending)\r\nath9k_hw_start_nfcal(ah, true);\r\nelse if (!(REG_READ(ah, AR_PHY_AGC_CONTROL) & AR_PHY_AGC_CONTROL_NF))\r\nath9k_hw_getnf(ah, ah->curchan);\r\ncaldata->nfcal_interference = true;\r\n}
