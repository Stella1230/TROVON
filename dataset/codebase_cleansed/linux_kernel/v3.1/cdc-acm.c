static int acm_ctrl_msg(struct acm *acm, int request, int value,\r\nvoid *buf, int len)\r\n{\r\nint retval = usb_control_msg(acm->dev, usb_sndctrlpipe(acm->dev, 0),\r\nrequest, USB_RT_ACM, value,\r\nacm->control->altsetting[0].desc.bInterfaceNumber,\r\nbuf, len, 5000);\r\ndev_dbg(&acm->control->dev,\r\n"%s - rq 0x%02x, val %#x, len %#x, result %d\n",\r\n__func__, request, value, len, retval);\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nstatic int acm_wb_alloc(struct acm *acm)\r\n{\r\nint i, wbn;\r\nstruct acm_wb *wb;\r\nwbn = 0;\r\ni = 0;\r\nfor (;;) {\r\nwb = &acm->wb[wbn];\r\nif (!wb->use) {\r\nwb->use = 1;\r\nreturn wbn;\r\n}\r\nwbn = (wbn + 1) % ACM_NW;\r\nif (++i >= ACM_NW)\r\nreturn -1;\r\n}\r\n}\r\nstatic int acm_wb_is_avail(struct acm *acm)\r\n{\r\nint i, n;\r\nunsigned long flags;\r\nn = ACM_NW;\r\nspin_lock_irqsave(&acm->write_lock, flags);\r\nfor (i = 0; i < ACM_NW; i++)\r\nn -= acm->wb[i].use;\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn n;\r\n}\r\nstatic void acm_write_done(struct acm *acm, struct acm_wb *wb)\r\n{\r\nwb->use = 0;\r\nacm->transmitting--;\r\nusb_autopm_put_interface_async(acm->control);\r\n}\r\nstatic int acm_start_wb(struct acm *acm, struct acm_wb *wb)\r\n{\r\nint rc;\r\nacm->transmitting++;\r\nwb->urb->transfer_buffer = wb->buf;\r\nwb->urb->transfer_dma = wb->dmah;\r\nwb->urb->transfer_buffer_length = wb->len;\r\nwb->urb->dev = acm->dev;\r\nrc = usb_submit_urb(wb->urb, GFP_ATOMIC);\r\nif (rc < 0) {\r\ndev_err(&acm->data->dev,\r\n"%s - usb_submit_urb(write bulk) failed: %d\n",\r\n__func__, rc);\r\nacm_write_done(acm, wb);\r\n}\r\nreturn rc;\r\n}\r\nstatic int acm_write_start(struct acm *acm, int wbn)\r\n{\r\nunsigned long flags;\r\nstruct acm_wb *wb = &acm->wb[wbn];\r\nint rc;\r\nspin_lock_irqsave(&acm->write_lock, flags);\r\nif (!acm->dev) {\r\nwb->use = 0;\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn -ENODEV;\r\n}\r\ndev_vdbg(&acm->data->dev, "%s - susp_count %d\n", __func__,\r\nacm->susp_count);\r\nusb_autopm_get_interface_async(acm->control);\r\nif (acm->susp_count) {\r\nif (!acm->delayed_wb)\r\nacm->delayed_wb = wb;\r\nelse\r\nusb_autopm_put_interface_async(acm->control);\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn 0;\r\n}\r\nusb_mark_last_busy(acm->dev);\r\nrc = acm_start_wb(acm, wb);\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn rc;\r\n}\r\nstatic ssize_t show_caps\r\n(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%d", acm->ctrl_caps);\r\n}\r\nstatic ssize_t show_country_codes\r\n(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nmemcpy(buf, acm->country_codes, acm->country_code_size);\r\nreturn acm->country_code_size;\r\n}\r\nstatic ssize_t show_country_rel_date\r\n(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%d", acm->country_rel_date);\r\n}\r\nstatic void acm_ctrl_irq(struct urb *urb)\r\n{\r\nstruct acm *acm = urb->context;\r\nstruct usb_cdc_notification *dr = urb->transfer_buffer;\r\nstruct tty_struct *tty;\r\nunsigned char *data;\r\nint newctrl;\r\nint retval;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&acm->control->dev,\r\n"%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&acm->control->dev,\r\n"%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nif (!ACM_READY(acm))\r\ngoto exit;\r\nusb_mark_last_busy(acm->dev);\r\ndata = (unsigned char *)(dr + 1);\r\nswitch (dr->bNotificationType) {\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\ndev_dbg(&acm->control->dev, "%s - network connection: %d\n",\r\n__func__, dr->wValue);\r\nbreak;\r\ncase USB_CDC_NOTIFY_SERIAL_STATE:\r\ntty = tty_port_tty_get(&acm->port);\r\nnewctrl = get_unaligned_le16(data);\r\nif (tty) {\r\nif (!acm->clocal &&\r\n(acm->ctrlin & ~newctrl & ACM_CTRL_DCD)) {\r\ndev_dbg(&acm->control->dev,\r\n"%s - calling hangup\n", __func__);\r\ntty_hangup(tty);\r\n}\r\ntty_kref_put(tty);\r\n}\r\nacm->ctrlin = newctrl;\r\ndev_dbg(&acm->control->dev,\r\n"%s - input control lines: dcd%c dsr%c break%c "\r\n"ring%c framing%c parity%c overrun%c\n",\r\n__func__,\r\nacm->ctrlin & ACM_CTRL_DCD ? '+' : '-',\r\nacm->ctrlin & ACM_CTRL_DSR ? '+' : '-',\r\nacm->ctrlin & ACM_CTRL_BRK ? '+' : '-',\r\nacm->ctrlin & ACM_CTRL_RI ? '+' : '-',\r\nacm->ctrlin & ACM_CTRL_FRAMING ? '+' : '-',\r\nacm->ctrlin & ACM_CTRL_PARITY ? '+' : '-',\r\nacm->ctrlin & ACM_CTRL_OVERRUN ? '+' : '-');\r\nbreak;\r\ndefault:\r\ndev_dbg(&acm->control->dev,\r\n"%s - unknown notification %d received: index %d "\r\n"len %d data0 %d data1 %d\n",\r\n__func__,\r\ndr->bNotificationType, dr->wIndex,\r\ndr->wLength, data[0], data[1]);\r\nbreak;\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&acm->control->dev, "%s - usb_submit_urb failed: %d\n",\r\n__func__, retval);\r\n}\r\nstatic int acm_submit_read_urb(struct acm *acm, int index, gfp_t mem_flags)\r\n{\r\nint res;\r\nif (!test_and_clear_bit(index, &acm->read_urbs_free))\r\nreturn 0;\r\ndev_vdbg(&acm->data->dev, "%s - urb %d\n", __func__, index);\r\nres = usb_submit_urb(acm->read_urbs[index], mem_flags);\r\nif (res) {\r\nif (res != -EPERM) {\r\ndev_err(&acm->data->dev,\r\n"%s - usb_submit_urb failed: %d\n",\r\n__func__, res);\r\n}\r\nset_bit(index, &acm->read_urbs_free);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acm_submit_read_urbs(struct acm *acm, gfp_t mem_flags)\r\n{\r\nint res;\r\nint i;\r\nfor (i = 0; i < acm->rx_buflimit; ++i) {\r\nres = acm_submit_read_urb(acm, i, mem_flags);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acm_process_read_urb(struct acm *acm, struct urb *urb)\r\n{\r\nstruct tty_struct *tty;\r\nif (!urb->actual_length)\r\nreturn;\r\ntty = tty_port_tty_get(&acm->port);\r\nif (!tty)\r\nreturn;\r\ntty_insert_flip_string(tty, urb->transfer_buffer, urb->actual_length);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic void acm_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct acm_rb *rb = urb->context;\r\nstruct acm *acm = rb->instance;\r\nunsigned long flags;\r\ndev_vdbg(&acm->data->dev, "%s - urb %d, len %d\n", __func__,\r\nrb->index, urb->actual_length);\r\nset_bit(rb->index, &acm->read_urbs_free);\r\nif (!acm->dev) {\r\ndev_dbg(&acm->data->dev, "%s - disconnected\n", __func__);\r\nreturn;\r\n}\r\nusb_mark_last_busy(acm->dev);\r\nif (urb->status) {\r\ndev_dbg(&acm->data->dev, "%s - non-zero urb status: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\nacm_process_read_urb(acm, urb);\r\nspin_lock_irqsave(&acm->read_lock, flags);\r\nacm->throttled = acm->throttle_req;\r\nif (!acm->throttled && !acm->susp_count) {\r\nspin_unlock_irqrestore(&acm->read_lock, flags);\r\nacm_submit_read_urb(acm, rb->index, GFP_ATOMIC);\r\n} else {\r\nspin_unlock_irqrestore(&acm->read_lock, flags);\r\n}\r\n}\r\nstatic void acm_write_bulk(struct urb *urb)\r\n{\r\nstruct acm_wb *wb = urb->context;\r\nstruct acm *acm = wb->instance;\r\nunsigned long flags;\r\nif (urb->status || (urb->actual_length != urb->transfer_buffer_length))\r\ndev_vdbg(&acm->data->dev, "%s - len %d/%d, status %d\n",\r\n__func__,\r\nurb->actual_length,\r\nurb->transfer_buffer_length,\r\nurb->status);\r\nspin_lock_irqsave(&acm->write_lock, flags);\r\nacm_write_done(acm, wb);\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nif (ACM_READY(acm))\r\nschedule_work(&acm->work);\r\n}\r\nstatic void acm_softint(struct work_struct *work)\r\n{\r\nstruct acm *acm = container_of(work, struct acm, work);\r\nstruct tty_struct *tty;\r\ndev_vdbg(&acm->data->dev, "%s\n", __func__);\r\nif (!ACM_READY(acm))\r\nreturn;\r\ntty = tty_port_tty_get(&acm->port);\r\nif (!tty)\r\nreturn;\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int acm_tty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct acm *acm;\r\nint rv = -ENODEV;\r\nmutex_lock(&open_mutex);\r\nacm = acm_table[tty->index];\r\nif (!acm || !acm->dev)\r\ngoto out;\r\nelse\r\nrv = 0;\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\nset_bit(TTY_NO_WRITE_SPLIT, &tty->flags);\r\ntty->driver_data = acm;\r\ntty_port_tty_set(&acm->port, tty);\r\nif (usb_autopm_get_interface(acm->control) < 0)\r\ngoto early_bail;\r\nelse\r\nacm->control->needs_remote_wakeup = 1;\r\nmutex_lock(&acm->mutex);\r\nif (acm->port.count++) {\r\nmutex_unlock(&acm->mutex);\r\nusb_autopm_put_interface(acm->control);\r\ngoto out;\r\n}\r\nacm->ctrlurb->dev = acm->dev;\r\nif (usb_submit_urb(acm->ctrlurb, GFP_KERNEL)) {\r\ndev_err(&acm->control->dev,\r\n"%s - usb_submit_urb(ctrl irq) failed\n", __func__);\r\ngoto bail_out;\r\n}\r\nif (0 > acm_set_control(acm, acm->ctrlout = ACM_CTRL_DTR | ACM_CTRL_RTS) &&\r\n(acm->ctrl_caps & USB_CDC_CAP_LINE))\r\ngoto bail_out;\r\nusb_autopm_put_interface(acm->control);\r\nif (acm_submit_read_urbs(acm, GFP_KERNEL))\r\ngoto bail_out;\r\nset_bit(ASYNCB_INITIALIZED, &acm->port.flags);\r\nrv = tty_port_block_til_ready(&acm->port, tty, filp);\r\nmutex_unlock(&acm->mutex);\r\nout:\r\nmutex_unlock(&open_mutex);\r\nreturn rv;\r\nbail_out:\r\nacm->port.count--;\r\nmutex_unlock(&acm->mutex);\r\nusb_autopm_put_interface(acm->control);\r\nearly_bail:\r\nmutex_unlock(&open_mutex);\r\ntty_port_tty_set(&acm->port, NULL);\r\nreturn -EIO;\r\n}\r\nstatic void acm_tty_unregister(struct acm *acm)\r\n{\r\nint i;\r\ntty_unregister_device(acm_tty_driver, acm->minor);\r\nusb_put_intf(acm->control);\r\nacm_table[acm->minor] = NULL;\r\nusb_free_urb(acm->ctrlurb);\r\nfor (i = 0; i < ACM_NW; i++)\r\nusb_free_urb(acm->wb[i].urb);\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_free_urb(acm->read_urbs[i]);\r\nkfree(acm->country_codes);\r\nkfree(acm);\r\n}\r\nstatic void acm_port_down(struct acm *acm)\r\n{\r\nint i;\r\nmutex_lock(&open_mutex);\r\nif (acm->dev) {\r\nusb_autopm_get_interface(acm->control);\r\nacm_set_control(acm, acm->ctrlout = 0);\r\nusb_kill_urb(acm->ctrlurb);\r\nfor (i = 0; i < ACM_NW; i++)\r\nusb_kill_urb(acm->wb[i].urb);\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_kill_urb(acm->read_urbs[i]);\r\nacm->control->needs_remote_wakeup = 0;\r\nusb_autopm_put_interface(acm->control);\r\n}\r\nmutex_unlock(&open_mutex);\r\n}\r\nstatic void acm_tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\ntty_port_hangup(&acm->port);\r\nacm_port_down(acm);\r\n}\r\nstatic void acm_tty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nif (!acm)\r\nreturn;\r\nif (tty_port_close_start(&acm->port, tty, filp) == 0) {\r\nmutex_lock(&open_mutex);\r\nif (!acm->dev) {\r\ntty_port_tty_set(&acm->port, NULL);\r\nacm_tty_unregister(acm);\r\ntty->driver_data = NULL;\r\n}\r\nmutex_unlock(&open_mutex);\r\nreturn;\r\n}\r\nacm_port_down(acm);\r\ntty_port_close_end(&acm->port, tty);\r\ntty_port_tty_set(&acm->port, NULL);\r\n}\r\nstatic int acm_tty_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nint stat;\r\nunsigned long flags;\r\nint wbn;\r\nstruct acm_wb *wb;\r\nif (!ACM_READY(acm))\r\nreturn -EINVAL;\r\nif (!count)\r\nreturn 0;\r\ndev_vdbg(&acm->data->dev, "%s - count %d\n", __func__, count);\r\nspin_lock_irqsave(&acm->write_lock, flags);\r\nwbn = acm_wb_alloc(acm);\r\nif (wbn < 0) {\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn 0;\r\n}\r\nwb = &acm->wb[wbn];\r\ncount = (count > acm->writesize) ? acm->writesize : count;\r\ndev_vdbg(&acm->data->dev, "%s - write %d\n", __func__, count);\r\nmemcpy(wb->buf, buf, count);\r\nwb->len = count;\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nstat = acm_write_start(acm, wbn);\r\nif (stat < 0)\r\nreturn stat;\r\nreturn count;\r\n}\r\nstatic int acm_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nif (!ACM_READY(acm))\r\nreturn -EINVAL;\r\nreturn acm_wb_is_avail(acm) ? acm->writesize : 0;\r\n}\r\nstatic int acm_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nif (!ACM_READY(acm))\r\nreturn 0;\r\nreturn (ACM_NW - acm_wb_is_avail(acm)) * acm->writesize;\r\n}\r\nstatic void acm_tty_throttle(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nif (!ACM_READY(acm))\r\nreturn;\r\nspin_lock_irq(&acm->read_lock);\r\nacm->throttle_req = 1;\r\nspin_unlock_irq(&acm->read_lock);\r\n}\r\nstatic void acm_tty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nunsigned int was_throttled;\r\nif (!ACM_READY(acm))\r\nreturn;\r\nspin_lock_irq(&acm->read_lock);\r\nwas_throttled = acm->throttled;\r\nacm->throttled = 0;\r\nacm->throttle_req = 0;\r\nspin_unlock_irq(&acm->read_lock);\r\nif (was_throttled)\r\nacm_submit_read_urbs(acm, GFP_KERNEL);\r\n}\r\nstatic int acm_tty_break_ctl(struct tty_struct *tty, int state)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nint retval;\r\nif (!ACM_READY(acm))\r\nreturn -EINVAL;\r\nretval = acm_send_break(acm, state ? 0xffff : 0);\r\nif (retval < 0)\r\ndev_dbg(&acm->control->dev, "%s - send break failed\n",\r\n__func__);\r\nreturn retval;\r\n}\r\nstatic int acm_tty_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nif (!ACM_READY(acm))\r\nreturn -EINVAL;\r\nreturn (acm->ctrlout & ACM_CTRL_DTR ? TIOCM_DTR : 0) |\r\n(acm->ctrlout & ACM_CTRL_RTS ? TIOCM_RTS : 0) |\r\n(acm->ctrlin & ACM_CTRL_DSR ? TIOCM_DSR : 0) |\r\n(acm->ctrlin & ACM_CTRL_RI ? TIOCM_RI : 0) |\r\n(acm->ctrlin & ACM_CTRL_DCD ? TIOCM_CD : 0) |\r\nTIOCM_CTS;\r\n}\r\nstatic int acm_tty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nunsigned int newctrl;\r\nif (!ACM_READY(acm))\r\nreturn -EINVAL;\r\nnewctrl = acm->ctrlout;\r\nset = (set & TIOCM_DTR ? ACM_CTRL_DTR : 0) |\r\n(set & TIOCM_RTS ? ACM_CTRL_RTS : 0);\r\nclear = (clear & TIOCM_DTR ? ACM_CTRL_DTR : 0) |\r\n(clear & TIOCM_RTS ? ACM_CTRL_RTS : 0);\r\nnewctrl = (newctrl & ~clear) | set;\r\nif (acm->ctrlout == newctrl)\r\nreturn 0;\r\nreturn acm_set_control(acm, acm->ctrlout = newctrl);\r\n}\r\nstatic int acm_tty_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nif (!ACM_READY(acm))\r\nreturn -EINVAL;\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void acm_tty_set_termios(struct tty_struct *tty,\r\nstruct ktermios *termios_old)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nstruct ktermios *termios = tty->termios;\r\nstruct usb_cdc_line_coding newline;\r\nint newctrl = acm->ctrlout;\r\nif (!ACM_READY(acm))\r\nreturn;\r\nnewline.dwDTERate = cpu_to_le32(tty_get_baud_rate(tty));\r\nnewline.bCharFormat = termios->c_cflag & CSTOPB ? 2 : 0;\r\nnewline.bParityType = termios->c_cflag & PARENB ?\r\n(termios->c_cflag & PARODD ? 1 : 2) +\r\n(termios->c_cflag & CMSPAR ? 2 : 0) : 0;\r\nnewline.bDataBits = acm_tty_size[(termios->c_cflag & CSIZE) >> 4];\r\nacm->clocal = ((termios->c_cflag & CLOCAL) != 0);\r\nif (!newline.dwDTERate) {\r\nnewline.dwDTERate = acm->line.dwDTERate;\r\nnewctrl &= ~ACM_CTRL_DTR;\r\n} else\r\nnewctrl |= ACM_CTRL_DTR;\r\nif (newctrl != acm->ctrlout)\r\nacm_set_control(acm, acm->ctrlout = newctrl);\r\nif (memcmp(&acm->line, &newline, sizeof newline)) {\r\nmemcpy(&acm->line, &newline, sizeof newline);\r\ndev_dbg(&acm->control->dev, "%s - set line: %d %d %d %d\n",\r\n__func__,\r\nle32_to_cpu(newline.dwDTERate),\r\nnewline.bCharFormat, newline.bParityType,\r\nnewline.bDataBits);\r\nacm_set_line(acm, &acm->line);\r\n}\r\n}\r\nstatic void acm_write_buffers_free(struct acm *acm)\r\n{\r\nint i;\r\nstruct acm_wb *wb;\r\nstruct usb_device *usb_dev = interface_to_usbdev(acm->control);\r\nfor (wb = &acm->wb[0], i = 0; i < ACM_NW; i++, wb++)\r\nusb_free_coherent(usb_dev, acm->writesize, wb->buf, wb->dmah);\r\n}\r\nstatic void acm_read_buffers_free(struct acm *acm)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(acm->control);\r\nint i;\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_free_coherent(usb_dev, acm->readsize,\r\nacm->read_buffers[i].base, acm->read_buffers[i].dma);\r\n}\r\nstatic int acm_write_buffers_alloc(struct acm *acm)\r\n{\r\nint i;\r\nstruct acm_wb *wb;\r\nfor (wb = &acm->wb[0], i = 0; i < ACM_NW; i++, wb++) {\r\nwb->buf = usb_alloc_coherent(acm->dev, acm->writesize, GFP_KERNEL,\r\n&wb->dmah);\r\nif (!wb->buf) {\r\nwhile (i != 0) {\r\n--i;\r\n--wb;\r\nusb_free_coherent(acm->dev, acm->writesize,\r\nwb->buf, wb->dmah);\r\n}\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acm_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_cdc_union_desc *union_header = NULL;\r\nstruct usb_cdc_country_functional_desc *cfd = NULL;\r\nunsigned char *buffer = intf->altsetting->extra;\r\nint buflen = intf->altsetting->extralen;\r\nstruct usb_interface *control_interface;\r\nstruct usb_interface *data_interface;\r\nstruct usb_endpoint_descriptor *epctrl = NULL;\r\nstruct usb_endpoint_descriptor *epread = NULL;\r\nstruct usb_endpoint_descriptor *epwrite = NULL;\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct acm *acm;\r\nint minor;\r\nint ctrlsize, readsize;\r\nu8 *buf;\r\nu8 ac_management_function = 0;\r\nu8 call_management_function = 0;\r\nint call_interface_num = -1;\r\nint data_interface_num = -1;\r\nunsigned long quirks;\r\nint num_rx_buf;\r\nint i;\r\nint combined_interfaces = 0;\r\nquirks = (unsigned long)id->driver_info;\r\nnum_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;\r\nif (quirks == NO_UNION_NORMAL) {\r\ndata_interface = usb_ifnum_to_if(usb_dev, 1);\r\ncontrol_interface = usb_ifnum_to_if(usb_dev, 0);\r\ngoto skip_normal_probe;\r\n}\r\nif (!buffer) {\r\ndev_err(&intf->dev, "Weird descriptor references\n");\r\nreturn -EINVAL;\r\n}\r\nif (!buflen) {\r\nif (intf->cur_altsetting->endpoint &&\r\nintf->cur_altsetting->endpoint->extralen &&\r\nintf->cur_altsetting->endpoint->extra) {\r\ndev_dbg(&intf->dev,\r\n"Seeking extra descriptors on endpoint\n");\r\nbuflen = intf->cur_altsetting->endpoint->extralen;\r\nbuffer = intf->cur_altsetting->endpoint->extra;\r\n} else {\r\ndev_err(&intf->dev,\r\n"Zero length descriptor references\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nwhile (buflen > 0) {\r\nif (buffer[1] != USB_DT_CS_INTERFACE) {\r\ndev_err(&intf->dev, "skipping garbage\n");\r\ngoto next_desc;\r\n}\r\nswitch (buffer[2]) {\r\ncase USB_CDC_UNION_TYPE:\r\nif (union_header) {\r\ndev_err(&intf->dev, "More than one "\r\n"union descriptor, skipping ...\n");\r\ngoto next_desc;\r\n}\r\nunion_header = (struct usb_cdc_union_desc *)buffer;\r\nbreak;\r\ncase USB_CDC_COUNTRY_TYPE:\r\ncfd = (struct usb_cdc_country_functional_desc *)buffer;\r\nbreak;\r\ncase USB_CDC_HEADER_TYPE:\r\nbreak;\r\ncase USB_CDC_ACM_TYPE:\r\nac_management_function = buffer[3];\r\nbreak;\r\ncase USB_CDC_CALL_MANAGEMENT_TYPE:\r\ncall_management_function = buffer[3];\r\ncall_interface_num = buffer[4];\r\nif ( (quirks & NOT_A_MODEM) == 0 && (call_management_function & 3) != 3)\r\ndev_err(&intf->dev, "This device cannot do calls on its own. It is not a modem.\n");\r\nbreak;\r\ndefault:\r\ndev_dbg(&intf->dev, "Ignoring descriptor: "\r\n"type %02x, length %d\n",\r\nbuffer[2], buffer[0]);\r\nbreak;\r\n}\r\nnext_desc:\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nif (!union_header) {\r\nif (call_interface_num > 0) {\r\ndev_dbg(&intf->dev, "No union descriptor, using call management descriptor\n");\r\nif (quirks & NO_DATA_INTERFACE)\r\ndata_interface = usb_ifnum_to_if(usb_dev, 0);\r\nelse\r\ndata_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = call_interface_num));\r\ncontrol_interface = intf;\r\n} else {\r\nif (intf->cur_altsetting->desc.bNumEndpoints != 3) {\r\ndev_dbg(&intf->dev,"No union descriptor, giving up\n");\r\nreturn -ENODEV;\r\n} else {\r\ndev_warn(&intf->dev,"No union descriptor, testing for castrated device\n");\r\ncombined_interfaces = 1;\r\ncontrol_interface = data_interface = intf;\r\ngoto look_for_collapsed_interface;\r\n}\r\n}\r\n} else {\r\ncontrol_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);\r\ndata_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = union_header->bSlaveInterface0));\r\nif (!control_interface || !data_interface) {\r\ndev_dbg(&intf->dev, "no interfaces\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (data_interface_num != call_interface_num)\r\ndev_dbg(&intf->dev, "Separate call control interface. That is not fully supported.\n");\r\nif (control_interface == data_interface) {\r\ndev_warn(&intf->dev,"Control and data interfaces are not separated!\n");\r\ncombined_interfaces = 1;\r\nquirks |= NO_CAP_LINE;\r\nif (data_interface->cur_altsetting->desc.bNumEndpoints != 3) {\r\ndev_err(&intf->dev, "This needs exactly 3 endpoints\n");\r\nreturn -EINVAL;\r\n}\r\nlook_for_collapsed_interface:\r\nfor (i = 0; i < 3; i++) {\r\nstruct usb_endpoint_descriptor *ep;\r\nep = &data_interface->cur_altsetting->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(ep))\r\nepctrl = ep;\r\nelse if (usb_endpoint_is_bulk_out(ep))\r\nepwrite = ep;\r\nelse if (usb_endpoint_is_bulk_in(ep))\r\nepread = ep;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (!epctrl || !epread || !epwrite)\r\nreturn -ENODEV;\r\nelse\r\ngoto made_compressed_probe;\r\n}\r\nskip_normal_probe:\r\nif (data_interface->cur_altsetting->desc.bInterfaceClass\r\n!= CDC_DATA_INTERFACE_TYPE) {\r\nif (control_interface->cur_altsetting->desc.bInterfaceClass\r\n== CDC_DATA_INTERFACE_TYPE) {\r\nstruct usb_interface *t;\r\ndev_dbg(&intf->dev,\r\n"Your device has switched interfaces.\n");\r\nt = control_interface;\r\ncontrol_interface = data_interface;\r\ndata_interface = t;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!combined_interfaces && intf != control_interface)\r\nreturn -ENODEV;\r\nif (!combined_interfaces && usb_interface_claimed(data_interface)) {\r\ndev_dbg(&intf->dev, "The data interface isn't available\n");\r\nreturn -EBUSY;\r\n}\r\nif (data_interface->cur_altsetting->desc.bNumEndpoints < 2)\r\nreturn -EINVAL;\r\nepctrl = &control_interface->cur_altsetting->endpoint[0].desc;\r\nepread = &data_interface->cur_altsetting->endpoint[0].desc;\r\nepwrite = &data_interface->cur_altsetting->endpoint[1].desc;\r\nif (!usb_endpoint_dir_in(epread)) {\r\nstruct usb_endpoint_descriptor *t;\r\ndev_dbg(&intf->dev,\r\n"The data interface has switched endpoints\n");\r\nt = epread;\r\nepread = epwrite;\r\nepwrite = t;\r\n}\r\nmade_compressed_probe:\r\ndev_dbg(&intf->dev, "interfaces are valid\n");\r\nfor (minor = 0; minor < ACM_TTY_MINORS && acm_table[minor]; minor++);\r\nif (minor == ACM_TTY_MINORS) {\r\ndev_err(&intf->dev, "no more free acm devices\n");\r\nreturn -ENODEV;\r\n}\r\nacm = kzalloc(sizeof(struct acm), GFP_KERNEL);\r\nif (acm == NULL) {\r\ndev_err(&intf->dev, "out of memory (acm kzalloc)\n");\r\ngoto alloc_fail;\r\n}\r\nctrlsize = le16_to_cpu(epctrl->wMaxPacketSize);\r\nreadsize = le16_to_cpu(epread->wMaxPacketSize) *\r\n(quirks == SINGLE_RX_URB ? 1 : 2);\r\nacm->combined_interfaces = combined_interfaces;\r\nacm->writesize = le16_to_cpu(epwrite->wMaxPacketSize) * 20;\r\nacm->control = control_interface;\r\nacm->data = data_interface;\r\nacm->minor = minor;\r\nacm->dev = usb_dev;\r\nacm->ctrl_caps = ac_management_function;\r\nif (quirks & NO_CAP_LINE)\r\nacm->ctrl_caps &= ~USB_CDC_CAP_LINE;\r\nacm->ctrlsize = ctrlsize;\r\nacm->readsize = readsize;\r\nacm->rx_buflimit = num_rx_buf;\r\nINIT_WORK(&acm->work, acm_softint);\r\nspin_lock_init(&acm->write_lock);\r\nspin_lock_init(&acm->read_lock);\r\nmutex_init(&acm->mutex);\r\nacm->rx_endpoint = usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress);\r\nacm->is_int_ep = usb_endpoint_xfer_int(epread);\r\nif (acm->is_int_ep)\r\nacm->bInterval = epread->bInterval;\r\ntty_port_init(&acm->port);\r\nacm->port.ops = &acm_port_ops;\r\nbuf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);\r\nif (!buf) {\r\ndev_err(&intf->dev, "out of memory (ctrl buffer alloc)\n");\r\ngoto alloc_fail2;\r\n}\r\nacm->ctrl_buffer = buf;\r\nif (acm_write_buffers_alloc(acm) < 0) {\r\ndev_err(&intf->dev, "out of memory (write buffer alloc)\n");\r\ngoto alloc_fail4;\r\n}\r\nacm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!acm->ctrlurb) {\r\ndev_err(&intf->dev, "out of memory (ctrlurb kmalloc)\n");\r\ngoto alloc_fail5;\r\n}\r\nfor (i = 0; i < num_rx_buf; i++) {\r\nstruct acm_rb *rb = &(acm->read_buffers[i]);\r\nstruct urb *urb;\r\nrb->base = usb_alloc_coherent(acm->dev, readsize, GFP_KERNEL,\r\n&rb->dma);\r\nif (!rb->base) {\r\ndev_err(&intf->dev, "out of memory "\r\n"(read bufs usb_alloc_coherent)\n");\r\ngoto alloc_fail6;\r\n}\r\nrb->index = i;\r\nrb->instance = acm;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(&intf->dev,\r\n"out of memory (read urbs usb_alloc_urb)\n");\r\ngoto alloc_fail6;\r\n}\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nurb->transfer_dma = rb->dma;\r\nif (acm->is_int_ep) {\r\nusb_fill_int_urb(urb, acm->dev,\r\nacm->rx_endpoint,\r\nrb->base,\r\nacm->readsize,\r\nacm_read_bulk_callback, rb,\r\nacm->bInterval);\r\n} else {\r\nusb_fill_bulk_urb(urb, acm->dev,\r\nacm->rx_endpoint,\r\nrb->base,\r\nacm->readsize,\r\nacm_read_bulk_callback, rb);\r\n}\r\nacm->read_urbs[i] = urb;\r\n__set_bit(i, &acm->read_urbs_free);\r\n}\r\nfor (i = 0; i < ACM_NW; i++) {\r\nstruct acm_wb *snd = &(acm->wb[i]);\r\nsnd->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (snd->urb == NULL) {\r\ndev_err(&intf->dev,\r\n"out of memory (write urbs usb_alloc_urb)\n");\r\ngoto alloc_fail7;\r\n}\r\nif (usb_endpoint_xfer_int(epwrite))\r\nusb_fill_int_urb(snd->urb, usb_dev,\r\nusb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress),\r\nNULL, acm->writesize, acm_write_bulk, snd, epwrite->bInterval);\r\nelse\r\nusb_fill_bulk_urb(snd->urb, usb_dev,\r\nusb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress),\r\nNULL, acm->writesize, acm_write_bulk, snd);\r\nsnd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nsnd->instance = acm;\r\n}\r\nusb_set_intfdata(intf, acm);\r\ni = device_create_file(&intf->dev, &dev_attr_bmCapabilities);\r\nif (i < 0)\r\ngoto alloc_fail7;\r\nif (cfd) {\r\nacm->country_codes = kmalloc(cfd->bLength - 4, GFP_KERNEL);\r\nif (!acm->country_codes)\r\ngoto skip_countries;\r\nacm->country_code_size = cfd->bLength - 4;\r\nmemcpy(acm->country_codes, (u8 *)&cfd->wCountyCode0,\r\ncfd->bLength - 4);\r\nacm->country_rel_date = cfd->iCountryCodeRelDate;\r\ni = device_create_file(&intf->dev, &dev_attr_wCountryCodes);\r\nif (i < 0) {\r\nkfree(acm->country_codes);\r\ngoto skip_countries;\r\n}\r\ni = device_create_file(&intf->dev,\r\n&dev_attr_iCountryCodeRelDate);\r\nif (i < 0) {\r\ndevice_remove_file(&intf->dev, &dev_attr_wCountryCodes);\r\nkfree(acm->country_codes);\r\ngoto skip_countries;\r\n}\r\n}\r\nskip_countries:\r\nusb_fill_int_urb(acm->ctrlurb, usb_dev,\r\nusb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),\r\nacm->ctrl_buffer, ctrlsize, acm_ctrl_irq, acm,\r\nepctrl->bInterval ? epctrl->bInterval : 0xff);\r\nacm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nacm->ctrlurb->transfer_dma = acm->ctrl_dma;\r\ndev_info(&intf->dev, "ttyACM%d: USB ACM device\n", minor);\r\nacm_set_control(acm, acm->ctrlout);\r\nacm->line.dwDTERate = cpu_to_le32(9600);\r\nacm->line.bDataBits = 8;\r\nacm_set_line(acm, &acm->line);\r\nusb_driver_claim_interface(&acm_driver, data_interface, acm);\r\nusb_set_intfdata(data_interface, acm);\r\nusb_get_intf(control_interface);\r\ntty_register_device(acm_tty_driver, minor, &control_interface->dev);\r\nacm_table[minor] = acm;\r\nreturn 0;\r\nalloc_fail7:\r\nfor (i = 0; i < ACM_NW; i++)\r\nusb_free_urb(acm->wb[i].urb);\r\nalloc_fail6:\r\nfor (i = 0; i < num_rx_buf; i++)\r\nusb_free_urb(acm->read_urbs[i]);\r\nacm_read_buffers_free(acm);\r\nusb_free_urb(acm->ctrlurb);\r\nalloc_fail5:\r\nacm_write_buffers_free(acm);\r\nalloc_fail4:\r\nusb_free_coherent(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\r\nalloc_fail2:\r\nkfree(acm);\r\nalloc_fail:\r\nreturn -ENOMEM;\r\n}\r\nstatic void stop_data_traffic(struct acm *acm)\r\n{\r\nint i;\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\nusb_kill_urb(acm->ctrlurb);\r\nfor (i = 0; i < ACM_NW; i++)\r\nusb_kill_urb(acm->wb[i].urb);\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_kill_urb(acm->read_urbs[i]);\r\ncancel_work_sync(&acm->work);\r\n}\r\nstatic void acm_disconnect(struct usb_interface *intf)\r\n{\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct tty_struct *tty;\r\nif (!acm)\r\nreturn;\r\nmutex_lock(&open_mutex);\r\nif (acm->country_codes) {\r\ndevice_remove_file(&acm->control->dev,\r\n&dev_attr_wCountryCodes);\r\ndevice_remove_file(&acm->control->dev,\r\n&dev_attr_iCountryCodeRelDate);\r\n}\r\ndevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\r\nacm->dev = NULL;\r\nusb_set_intfdata(acm->control, NULL);\r\nusb_set_intfdata(acm->data, NULL);\r\nstop_data_traffic(acm);\r\nacm_write_buffers_free(acm);\r\nusb_free_coherent(usb_dev, acm->ctrlsize, acm->ctrl_buffer,\r\nacm->ctrl_dma);\r\nacm_read_buffers_free(acm);\r\nif (!acm->combined_interfaces)\r\nusb_driver_release_interface(&acm_driver, intf == acm->control ?\r\nacm->data : acm->control);\r\nif (acm->port.count == 0) {\r\nacm_tty_unregister(acm);\r\nmutex_unlock(&open_mutex);\r\nreturn;\r\n}\r\nmutex_unlock(&open_mutex);\r\ntty = tty_port_tty_get(&acm->port);\r\nif (tty) {\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic int acm_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nint cnt;\r\nif (message.event & PM_EVENT_AUTO) {\r\nint b;\r\nspin_lock_irq(&acm->write_lock);\r\nb = acm->transmitting;\r\nspin_unlock_irq(&acm->write_lock);\r\nif (b)\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irq(&acm->read_lock);\r\nspin_lock(&acm->write_lock);\r\ncnt = acm->susp_count++;\r\nspin_unlock(&acm->write_lock);\r\nspin_unlock_irq(&acm->read_lock);\r\nif (cnt)\r\nreturn 0;\r\nmutex_lock(&acm->mutex);\r\nif (acm->port.count)\r\nstop_data_traffic(acm);\r\nmutex_unlock(&acm->mutex);\r\nreturn 0;\r\n}\r\nstatic int acm_resume(struct usb_interface *intf)\r\n{\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nstruct acm_wb *wb;\r\nint rv = 0;\r\nint cnt;\r\nspin_lock_irq(&acm->read_lock);\r\nacm->susp_count -= 1;\r\ncnt = acm->susp_count;\r\nspin_unlock_irq(&acm->read_lock);\r\nif (cnt)\r\nreturn 0;\r\nmutex_lock(&acm->mutex);\r\nif (acm->port.count) {\r\nrv = usb_submit_urb(acm->ctrlurb, GFP_NOIO);\r\nspin_lock_irq(&acm->write_lock);\r\nif (acm->delayed_wb) {\r\nwb = acm->delayed_wb;\r\nacm->delayed_wb = NULL;\r\nspin_unlock_irq(&acm->write_lock);\r\nacm_start_wb(acm, wb);\r\n} else {\r\nspin_unlock_irq(&acm->write_lock);\r\n}\r\nif (rv < 0)\r\ngoto err_out;\r\nrv = acm_submit_read_urbs(acm, GFP_NOIO);\r\n}\r\nerr_out:\r\nmutex_unlock(&acm->mutex);\r\nreturn rv;\r\n}\r\nstatic int acm_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nstruct tty_struct *tty;\r\nmutex_lock(&acm->mutex);\r\nif (acm->port.count) {\r\ntty = tty_port_tty_get(&acm->port);\r\nif (tty) {\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nmutex_unlock(&acm->mutex);\r\nreturn acm_resume(intf);\r\n}\r\nstatic int __init acm_init(void)\r\n{\r\nint retval;\r\nacm_tty_driver = alloc_tty_driver(ACM_TTY_MINORS);\r\nif (!acm_tty_driver)\r\nreturn -ENOMEM;\r\nacm_tty_driver->owner = THIS_MODULE,\r\nacm_tty_driver->driver_name = "acm",\r\nacm_tty_driver->name = "ttyACM",\r\nacm_tty_driver->major = ACM_TTY_MAJOR,\r\nacm_tty_driver->minor_start = 0,\r\nacm_tty_driver->type = TTY_DRIVER_TYPE_SERIAL,\r\nacm_tty_driver->subtype = SERIAL_TYPE_NORMAL,\r\nacm_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\nacm_tty_driver->init_termios = tty_std_termios;\r\nacm_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD |\r\nHUPCL | CLOCAL;\r\ntty_set_operations(acm_tty_driver, &acm_ops);\r\nretval = tty_register_driver(acm_tty_driver);\r\nif (retval) {\r\nput_tty_driver(acm_tty_driver);\r\nreturn retval;\r\n}\r\nretval = usb_register(&acm_driver);\r\nif (retval) {\r\ntty_unregister_driver(acm_tty_driver);\r\nput_tty_driver(acm_tty_driver);\r\nreturn retval;\r\n}\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");\r\nreturn 0;\r\n}\r\nstatic void __exit acm_exit(void)\r\n{\r\nusb_deregister(&acm_driver);\r\ntty_unregister_driver(acm_tty_driver);\r\nput_tty_driver(acm_tty_driver);\r\n}
