static inline void ub_init_completion(struct ub_completion *x)\r\n{\r\nx->done = 0;\r\nspin_lock_init(&x->lock);\r\n}\r\nstatic void ub_complete(struct ub_completion *x)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&x->lock, flags);\r\nx->done++;\r\nspin_unlock_irqrestore(&x->lock, flags);\r\n}\r\nstatic int ub_is_completed(struct ub_completion *x)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&x->lock, flags);\r\nret = x->done;\r\nspin_unlock_irqrestore(&x->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ub_id_get(void)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&ub_lock, flags);\r\nfor (i = 0; i < UB_MAX_HOSTS; i++) {\r\nif (ub_hostv[i] == 0) {\r\nub_hostv[i] = 1;\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\nreturn i;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\nreturn -1;\r\n}\r\nstatic void ub_id_put(int id)\r\n{\r\nunsigned long flags;\r\nif (id < 0 || id >= UB_MAX_HOSTS) {\r\nprintk(KERN_ERR DRV_NAME ": bad host ID %d\n", id);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ub_lock, flags);\r\nif (ub_hostv[id] == 0) {\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\nprintk(KERN_ERR DRV_NAME ": freeing free host ID %d\n", id);\r\nreturn;\r\n}\r\nub_hostv[id] = 0;\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\n}\r\nstatic spinlock_t *ub_next_lock(void)\r\n{\r\nunsigned long flags;\r\nspinlock_t *ret;\r\nspin_lock_irqsave(&ub_lock, flags);\r\nret = &ub_qlockv[ub_qlock_next];\r\nub_qlock_next = (ub_qlock_next + 1) % UB_QLOCK_NUM;\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void ub_put(struct ub_dev *sc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ub_lock, flags);\r\n--sc->openc;\r\nif (sc->openc == 0 && atomic_read(&sc->poison)) {\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\nub_cleanup(sc);\r\n} else {\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\n}\r\n}\r\nstatic void ub_cleanup(struct ub_dev *sc)\r\n{\r\nstruct list_head *p;\r\nstruct ub_lun *lun;\r\nstruct request_queue *q;\r\nwhile (!list_empty(&sc->luns)) {\r\np = sc->luns.next;\r\nlun = list_entry(p, struct ub_lun, link);\r\nlist_del(p);\r\nif ((q = lun->disk->queue) != NULL)\r\nblk_cleanup_queue(q);\r\nput_disk(lun->disk);\r\nlun->disk = NULL;\r\nub_id_put(lun->id);\r\nkfree(lun);\r\n}\r\nusb_set_intfdata(sc->intf, NULL);\r\nusb_put_intf(sc->intf);\r\nusb_put_dev(sc->dev);\r\nkfree(sc);\r\n}\r\nstatic struct ub_scsi_cmd *ub_get_cmd(struct ub_lun *lun)\r\n{\r\nstruct ub_scsi_cmd *ret;\r\nif (lun->cmda[0])\r\nreturn NULL;\r\nret = &lun->cmdv[0];\r\nlun->cmda[0] = 1;\r\nreturn ret;\r\n}\r\nstatic void ub_put_cmd(struct ub_lun *lun, struct ub_scsi_cmd *cmd)\r\n{\r\nif (cmd != &lun->cmdv[0]) {\r\nprintk(KERN_WARNING "%s: releasing a foreign cmd %p\n",\r\nlun->name, cmd);\r\nreturn;\r\n}\r\nif (!lun->cmda[0]) {\r\nprintk(KERN_WARNING "%s: releasing a free cmd\n", lun->name);\r\nreturn;\r\n}\r\nlun->cmda[0] = 0;\r\n}\r\nstatic void ub_cmdq_add(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nstruct ub_scsi_cmd_queue *t = &sc->cmd_queue;\r\nif (t->qlen++ == 0) {\r\nt->head = cmd;\r\nt->tail = cmd;\r\n} else {\r\nt->tail->next = cmd;\r\nt->tail = cmd;\r\n}\r\nif (t->qlen > t->qmax)\r\nt->qmax = t->qlen;\r\n}\r\nstatic void ub_cmdq_insert(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nstruct ub_scsi_cmd_queue *t = &sc->cmd_queue;\r\nif (t->qlen++ == 0) {\r\nt->head = cmd;\r\nt->tail = cmd;\r\n} else {\r\ncmd->next = t->head;\r\nt->head = cmd;\r\n}\r\nif (t->qlen > t->qmax)\r\nt->qmax = t->qlen;\r\n}\r\nstatic struct ub_scsi_cmd *ub_cmdq_pop(struct ub_dev *sc)\r\n{\r\nstruct ub_scsi_cmd_queue *t = &sc->cmd_queue;\r\nstruct ub_scsi_cmd *cmd;\r\nif (t->qlen == 0)\r\nreturn NULL;\r\nif (--t->qlen == 0)\r\nt->tail = NULL;\r\ncmd = t->head;\r\nt->head = cmd->next;\r\ncmd->next = NULL;\r\nreturn cmd;\r\n}\r\nstatic void ub_request_fn(struct request_queue *q)\r\n{\r\nstruct ub_lun *lun = q->queuedata;\r\nstruct request *rq;\r\nwhile ((rq = blk_peek_request(q)) != NULL) {\r\nif (ub_request_fn_1(lun, rq) != 0) {\r\nblk_stop_queue(q);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int ub_request_fn_1(struct ub_lun *lun, struct request *rq)\r\n{\r\nstruct ub_dev *sc = lun->udev;\r\nstruct ub_scsi_cmd *cmd;\r\nstruct ub_request *urq;\r\nint n_elem;\r\nif (atomic_read(&sc->poison)) {\r\nblk_start_request(rq);\r\nub_end_rq(rq, DID_NO_CONNECT << 16);\r\nreturn 0;\r\n}\r\nif (lun->changed && rq->cmd_type != REQ_TYPE_BLOCK_PC) {\r\nblk_start_request(rq);\r\nub_end_rq(rq, SAM_STAT_CHECK_CONDITION);\r\nreturn 0;\r\n}\r\nif (lun->urq.rq != NULL)\r\nreturn -1;\r\nif ((cmd = ub_get_cmd(lun)) == NULL)\r\nreturn -1;\r\nmemset(cmd, 0, sizeof(struct ub_scsi_cmd));\r\nblk_start_request(rq);\r\nurq = &lun->urq;\r\nmemset(urq, 0, sizeof(struct ub_request));\r\nurq->rq = rq;\r\nsg_init_table(&urq->sgv[0], UB_MAX_REQ_SG);\r\nn_elem = blk_rq_map_sg(lun->disk->queue, rq, &urq->sgv[0]);\r\nif (n_elem < 0) {\r\nprintk(KERN_INFO "%s: failed request map (%d)\n",\r\nlun->name, n_elem);\r\ngoto drop;\r\n}\r\nif (n_elem > UB_MAX_REQ_SG) {\r\nprintk(KERN_WARNING "%s: request with %d segments\n",\r\nlun->name, n_elem);\r\ngoto drop;\r\n}\r\nurq->nsg = n_elem;\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC) {\r\nub_cmd_build_packet(sc, lun, cmd, urq);\r\n} else {\r\nub_cmd_build_block(sc, lun, cmd, urq);\r\n}\r\ncmd->state = UB_CMDST_INIT;\r\ncmd->lun = lun;\r\ncmd->done = ub_rw_cmd_done;\r\ncmd->back = urq;\r\ncmd->tag = sc->tagcnt++;\r\nif (ub_submit_scsi(sc, cmd) != 0)\r\ngoto drop;\r\nreturn 0;\r\ndrop:\r\nub_put_cmd(lun, cmd);\r\nub_end_rq(rq, DID_ERROR << 16);\r\nreturn 0;\r\n}\r\nstatic void ub_cmd_build_block(struct ub_dev *sc, struct ub_lun *lun,\r\nstruct ub_scsi_cmd *cmd, struct ub_request *urq)\r\n{\r\nstruct request *rq = urq->rq;\r\nunsigned int block, nblks;\r\nif (rq_data_dir(rq) == WRITE)\r\ncmd->dir = UB_DIR_WRITE;\r\nelse\r\ncmd->dir = UB_DIR_READ;\r\ncmd->nsg = urq->nsg;\r\nmemcpy(cmd->sgv, urq->sgv, sizeof(struct scatterlist) * cmd->nsg);\r\nblock = blk_rq_pos(rq) >> lun->capacity.bshift;\r\nnblks = blk_rq_sectors(rq) >> lun->capacity.bshift;\r\ncmd->cdb[0] = (cmd->dir == UB_DIR_READ)? READ_10: WRITE_10;\r\ncmd->cdb[2] = block >> 24;\r\ncmd->cdb[3] = block >> 16;\r\ncmd->cdb[4] = block >> 8;\r\ncmd->cdb[5] = block;\r\ncmd->cdb[7] = nblks >> 8;\r\ncmd->cdb[8] = nblks;\r\ncmd->cdb_len = 10;\r\ncmd->len = blk_rq_bytes(rq);\r\n}\r\nstatic void ub_cmd_build_packet(struct ub_dev *sc, struct ub_lun *lun,\r\nstruct ub_scsi_cmd *cmd, struct ub_request *urq)\r\n{\r\nstruct request *rq = urq->rq;\r\nif (blk_rq_bytes(rq) == 0) {\r\ncmd->dir = UB_DIR_NONE;\r\n} else {\r\nif (rq_data_dir(rq) == WRITE)\r\ncmd->dir = UB_DIR_WRITE;\r\nelse\r\ncmd->dir = UB_DIR_READ;\r\n}\r\ncmd->nsg = urq->nsg;\r\nmemcpy(cmd->sgv, urq->sgv, sizeof(struct scatterlist) * cmd->nsg);\r\nmemcpy(&cmd->cdb, rq->cmd, rq->cmd_len);\r\ncmd->cdb_len = rq->cmd_len;\r\ncmd->len = blk_rq_bytes(rq);\r\ncmd->timeo = rq->timeout;\r\n}\r\nstatic void ub_rw_cmd_done(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nstruct ub_lun *lun = cmd->lun;\r\nstruct ub_request *urq = cmd->back;\r\nstruct request *rq;\r\nunsigned int scsi_status;\r\nrq = urq->rq;\r\nif (cmd->error == 0) {\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC) {\r\nif (cmd->act_len >= rq->resid_len)\r\nrq->resid_len = 0;\r\nelse\r\nrq->resid_len -= cmd->act_len;\r\nscsi_status = 0;\r\n} else {\r\nif (cmd->act_len != cmd->len) {\r\nscsi_status = SAM_STAT_CHECK_CONDITION;\r\n} else {\r\nscsi_status = 0;\r\n}\r\n}\r\n} else {\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC) {\r\nmemcpy(rq->sense, sc->top_sense, UB_SENSE_SIZE);\r\nrq->sense_len = UB_SENSE_SIZE;\r\nif (sc->top_sense[0] != 0)\r\nscsi_status = SAM_STAT_CHECK_CONDITION;\r\nelse\r\nscsi_status = DID_ERROR << 16;\r\n} else {\r\nif (cmd->error == -EIO &&\r\n(cmd->key == 0 ||\r\ncmd->key == MEDIUM_ERROR ||\r\ncmd->key == UNIT_ATTENTION)) {\r\nif (ub_rw_cmd_retry(sc, lun, urq, cmd) == 0)\r\nreturn;\r\n}\r\nscsi_status = SAM_STAT_CHECK_CONDITION;\r\n}\r\n}\r\nurq->rq = NULL;\r\nub_put_cmd(lun, cmd);\r\nub_end_rq(rq, scsi_status);\r\nblk_start_queue(lun->disk->queue);\r\n}\r\nstatic void ub_end_rq(struct request *rq, unsigned int scsi_status)\r\n{\r\nint error;\r\nif (scsi_status == 0) {\r\nerror = 0;\r\n} else {\r\nerror = -EIO;\r\nrq->errors = scsi_status;\r\n}\r\n__blk_end_request_all(rq, error);\r\n}\r\nstatic int ub_rw_cmd_retry(struct ub_dev *sc, struct ub_lun *lun,\r\nstruct ub_request *urq, struct ub_scsi_cmd *cmd)\r\n{\r\nif (atomic_read(&sc->poison))\r\nreturn -ENXIO;\r\nub_reset_enter(sc, urq->current_try);\r\nif (urq->current_try >= 3)\r\nreturn -EIO;\r\nurq->current_try++;\r\nprintk(KERN_DEBUG "%s: dir %c len/act %d/%d "\r\n"[sense %x %02x %02x] retry %d\n",\r\nsc->name, UB_DIR_CHAR(cmd->dir), cmd->len, cmd->act_len,\r\ncmd->key, cmd->asc, cmd->ascq, urq->current_try);\r\nmemset(cmd, 0, sizeof(struct ub_scsi_cmd));\r\nub_cmd_build_block(sc, lun, cmd, urq);\r\ncmd->state = UB_CMDST_INIT;\r\ncmd->lun = lun;\r\ncmd->done = ub_rw_cmd_done;\r\ncmd->back = urq;\r\ncmd->tag = sc->tagcnt++;\r\n#if 0\r\nreturn ub_submit_scsi(sc, cmd);\r\n#else\r\nub_cmdq_add(sc, cmd);\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int ub_submit_scsi(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nif (cmd->state != UB_CMDST_INIT ||\r\n(cmd->dir != UB_DIR_NONE && cmd->len == 0)) {\r\nreturn -EINVAL;\r\n}\r\nub_cmdq_add(sc, cmd);\r\ntasklet_schedule(&sc->tasklet);\r\nreturn 0;\r\n}\r\nstatic int ub_scsi_cmd_start(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nstruct bulk_cb_wrap *bcb;\r\nint rc;\r\nbcb = &sc->work_bcb;\r\nmemset(&sc->top_sense, 0, UB_SENSE_SIZE);\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->Tag = cmd->tag;\r\nbcb->DataTransferLength = cpu_to_le32(cmd->len);\r\nbcb->Flags = (cmd->dir == UB_DIR_READ) ? 0x80 : 0;\r\nbcb->Lun = (cmd->lun != NULL) ? cmd->lun->num : 0;\r\nbcb->Length = cmd->cdb_len;\r\nmemcpy(bcb->CDB, cmd->cdb, UB_MAX_CDB_SIZE);\r\nUB_INIT_COMPLETION(sc->work_done);\r\nsc->last_pipe = sc->send_bulk_pipe;\r\nusb_fill_bulk_urb(&sc->work_urb, sc->dev, sc->send_bulk_pipe,\r\nbcb, US_BULK_CB_WRAP_LEN, ub_urb_complete, sc);\r\nif ((rc = usb_submit_urb(&sc->work_urb, GFP_ATOMIC)) != 0) {\r\nub_complete(&sc->work_done);\r\nreturn rc;\r\n}\r\nsc->work_timer.expires = jiffies + UB_URB_TIMEOUT;\r\nadd_timer(&sc->work_timer);\r\ncmd->state = UB_CMDST_CMD;\r\nreturn 0;\r\n}\r\nstatic void ub_urb_timeout(unsigned long arg)\r\n{\r\nstruct ub_dev *sc = (struct ub_dev *) arg;\r\nunsigned long flags;\r\nspin_lock_irqsave(sc->lock, flags);\r\nif (!ub_is_completed(&sc->work_done))\r\nusb_unlink_urb(&sc->work_urb);\r\nspin_unlock_irqrestore(sc->lock, flags);\r\n}\r\nstatic void ub_urb_complete(struct urb *urb)\r\n{\r\nstruct ub_dev *sc = urb->context;\r\nub_complete(&sc->work_done);\r\ntasklet_schedule(&sc->tasklet);\r\n}\r\nstatic void ub_scsi_action(unsigned long _dev)\r\n{\r\nstruct ub_dev *sc = (struct ub_dev *) _dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(sc->lock, flags);\r\nub_scsi_dispatch(sc);\r\nspin_unlock_irqrestore(sc->lock, flags);\r\n}\r\nstatic void ub_scsi_dispatch(struct ub_dev *sc)\r\n{\r\nstruct ub_scsi_cmd *cmd;\r\nint rc;\r\nwhile (!sc->reset && (cmd = ub_cmdq_peek(sc)) != NULL) {\r\nif (cmd->state == UB_CMDST_DONE) {\r\nub_cmdq_pop(sc);\r\n(*cmd->done)(sc, cmd);\r\n} else if (cmd->state == UB_CMDST_INIT) {\r\nif ((rc = ub_scsi_cmd_start(sc, cmd)) == 0)\r\nbreak;\r\ncmd->error = rc;\r\ncmd->state = UB_CMDST_DONE;\r\n} else {\r\nif (!ub_is_completed(&sc->work_done))\r\nbreak;\r\ndel_timer(&sc->work_timer);\r\nub_scsi_urb_compl(sc, cmd);\r\n}\r\n}\r\n}\r\nstatic void ub_scsi_urb_compl(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nstruct urb *urb = &sc->work_urb;\r\nstruct bulk_cs_wrap *bcs;\r\nint endp;\r\nint len;\r\nint rc;\r\nif (atomic_read(&sc->poison)) {\r\nub_state_done(sc, cmd, -ENODEV);\r\nreturn;\r\n}\r\nendp = usb_pipeendpoint(sc->last_pipe);\r\nif (usb_pipein(sc->last_pipe))\r\nendp |= USB_DIR_IN;\r\nif (cmd->state == UB_CMDST_CLEAR) {\r\nif (urb->status == -EPIPE) {\r\nprintk(KERN_NOTICE "%s: stall on control pipe\n",\r\nsc->name);\r\ngoto Bad_End;\r\n}\r\nusb_reset_endpoint(sc->dev, endp);\r\nub_state_sense(sc, cmd);\r\n} else if (cmd->state == UB_CMDST_CLR2STS) {\r\nif (urb->status == -EPIPE) {\r\nprintk(KERN_NOTICE "%s: stall on control pipe\n",\r\nsc->name);\r\ngoto Bad_End;\r\n}\r\nusb_reset_endpoint(sc->dev, endp);\r\nub_state_stat(sc, cmd);\r\n} else if (cmd->state == UB_CMDST_CLRRS) {\r\nif (urb->status == -EPIPE) {\r\nprintk(KERN_NOTICE "%s: stall on control pipe\n",\r\nsc->name);\r\ngoto Bad_End;\r\n}\r\nusb_reset_endpoint(sc->dev, endp);\r\nub_state_stat_counted(sc, cmd);\r\n} else if (cmd->state == UB_CMDST_CMD) {\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -EOVERFLOW:\r\ngoto Bad_End;\r\ncase -EPIPE:\r\nrc = ub_submit_clear_stall(sc, cmd, sc->last_pipe);\r\nif (rc != 0) {\r\nprintk(KERN_NOTICE "%s: "\r\n"unable to submit clear (%d)\n",\r\nsc->name, rc);\r\nub_state_done(sc, cmd, rc);\r\nreturn;\r\n}\r\ncmd->state = UB_CMDST_CLEAR;\r\nreturn;\r\ncase -ESHUTDOWN:\r\ncase -EILSEQ:\r\nub_state_done(sc, cmd, -ENODEV);\r\nreturn;\r\ndefault:\r\ngoto Bad_End;\r\n}\r\nif (urb->actual_length != US_BULK_CB_WRAP_LEN) {\r\ngoto Bad_End;\r\n}\r\nif (cmd->dir == UB_DIR_NONE || cmd->nsg < 1) {\r\nub_state_stat(sc, cmd);\r\nreturn;\r\n}\r\nub_data_start(sc, cmd);\r\n} else if (cmd->state == UB_CMDST_DATA) {\r\nif (urb->status == -EPIPE) {\r\nrc = ub_submit_clear_stall(sc, cmd, sc->last_pipe);\r\nif (rc != 0) {\r\nprintk(KERN_NOTICE "%s: "\r\n"unable to submit clear (%d)\n",\r\nsc->name, rc);\r\nub_state_done(sc, cmd, rc);\r\nreturn;\r\n}\r\ncmd->state = UB_CMDST_CLR2STS;\r\nreturn;\r\n}\r\nif (urb->status == -EOVERFLOW) {\r\ncmd->error = -EOVERFLOW;\r\nub_state_stat(sc, cmd);\r\nreturn;\r\n}\r\nif (cmd->dir == UB_DIR_WRITE) {\r\nlen = urb->actual_length;\r\nif (urb->status != 0 ||\r\nlen != cmd->sgv[cmd->current_sg].length) {\r\ncmd->act_len += len;\r\ncmd->error = -EIO;\r\nub_state_stat(sc, cmd);\r\nreturn;\r\n}\r\n} else {\r\nif (urb->status != 0)\r\ncmd->error = -EIO;\r\nlen = urb->actual_length;\r\nif (urb->status != 0 ||\r\nlen != cmd->sgv[cmd->current_sg].length) {\r\nif ((len & 0x1FF) == US_BULK_CS_WRAP_LEN)\r\ngoto Bad_End;\r\n}\r\n}\r\ncmd->act_len += urb->actual_length;\r\nif (++cmd->current_sg < cmd->nsg) {\r\nub_data_start(sc, cmd);\r\nreturn;\r\n}\r\nub_state_stat(sc, cmd);\r\n} else if (cmd->state == UB_CMDST_STAT) {\r\nif (urb->status == -EPIPE) {\r\nrc = ub_submit_clear_stall(sc, cmd, sc->last_pipe);\r\nif (rc != 0) {\r\nprintk(KERN_NOTICE "%s: "\r\n"unable to submit clear (%d)\n",\r\nsc->name, rc);\r\nub_state_done(sc, cmd, rc);\r\nreturn;\r\n}\r\ncmd->error = -EIO;\r\ncmd->state = UB_CMDST_CLRRS;\r\nreturn;\r\n}\r\nif (urb->status != 0)\r\ngoto Bad_End;\r\nif (urb->actual_length == 0) {\r\nub_state_stat_counted(sc, cmd);\r\nreturn;\r\n}\r\nbcs = &sc->work_bcs;\r\nif (sc->signature == cpu_to_le32(0)) {\r\nsc->signature = bcs->Signature;\r\nif (sc->signature == cpu_to_le32(0)) {\r\nub_state_stat_counted(sc, cmd);\r\nreturn;\r\n}\r\n} else {\r\nif (bcs->Signature != sc->signature) {\r\nub_state_stat_counted(sc, cmd);\r\nreturn;\r\n}\r\n}\r\nif (bcs->Tag != cmd->tag) {\r\nub_state_stat_counted(sc, cmd);\r\nreturn;\r\n}\r\nif (!sc->bad_resid) {\r\nlen = le32_to_cpu(bcs->Residue);\r\nif (len != cmd->len - cmd->act_len) {\r\nif (cmd->len == cmd->act_len) {\r\nprintk(KERN_NOTICE "%s: "\r\n"bad residual %d of %d, ignoring\n",\r\nsc->name, len, cmd->len);\r\nsc->bad_resid = 1;\r\n}\r\n}\r\n}\r\nswitch (bcs->Status) {\r\ncase US_BULK_STAT_OK:\r\nbreak;\r\ncase US_BULK_STAT_FAIL:\r\nub_state_sense(sc, cmd);\r\nreturn;\r\ncase US_BULK_STAT_PHASE:\r\ngoto Bad_End;\r\ndefault:\r\nprintk(KERN_INFO "%s: unknown CSW status 0x%x\n",\r\nsc->name, bcs->Status);\r\nub_state_done(sc, cmd, -EINVAL);\r\nreturn;\r\n}\r\nif (cmd->error != 0) {\r\nub_state_sense(sc, cmd);\r\nreturn;\r\n}\r\ncmd->state = UB_CMDST_DONE;\r\nub_cmdq_pop(sc);\r\n(*cmd->done)(sc, cmd);\r\n} else if (cmd->state == UB_CMDST_SENSE) {\r\nub_state_done(sc, cmd, -EIO);\r\n} else {\r\nprintk(KERN_WARNING "%s: wrong command state %d\n",\r\nsc->name, cmd->state);\r\nub_state_done(sc, cmd, -EINVAL);\r\nreturn;\r\n}\r\nreturn;\r\nBad_End:\r\nub_state_done(sc, cmd, -EIO);\r\n}\r\nstatic void ub_data_start(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nstruct scatterlist *sg = &cmd->sgv[cmd->current_sg];\r\nint pipe;\r\nint rc;\r\nUB_INIT_COMPLETION(sc->work_done);\r\nif (cmd->dir == UB_DIR_READ)\r\npipe = sc->recv_bulk_pipe;\r\nelse\r\npipe = sc->send_bulk_pipe;\r\nsc->last_pipe = pipe;\r\nusb_fill_bulk_urb(&sc->work_urb, sc->dev, pipe, sg_virt(sg),\r\nsg->length, ub_urb_complete, sc);\r\nif ((rc = usb_submit_urb(&sc->work_urb, GFP_ATOMIC)) != 0) {\r\nub_complete(&sc->work_done);\r\nub_state_done(sc, cmd, rc);\r\nreturn;\r\n}\r\nif (cmd->timeo)\r\nsc->work_timer.expires = jiffies + cmd->timeo;\r\nelse\r\nsc->work_timer.expires = jiffies + UB_DATA_TIMEOUT;\r\nadd_timer(&sc->work_timer);\r\ncmd->state = UB_CMDST_DATA;\r\n}\r\nstatic void ub_state_done(struct ub_dev *sc, struct ub_scsi_cmd *cmd, int rc)\r\n{\r\ncmd->error = rc;\r\ncmd->state = UB_CMDST_DONE;\r\nub_cmdq_pop(sc);\r\n(*cmd->done)(sc, cmd);\r\n}\r\nstatic int __ub_state_stat(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nint rc;\r\nUB_INIT_COMPLETION(sc->work_done);\r\nsc->last_pipe = sc->recv_bulk_pipe;\r\nusb_fill_bulk_urb(&sc->work_urb, sc->dev, sc->recv_bulk_pipe,\r\n&sc->work_bcs, US_BULK_CS_WRAP_LEN, ub_urb_complete, sc);\r\nif ((rc = usb_submit_urb(&sc->work_urb, GFP_ATOMIC)) != 0) {\r\nub_complete(&sc->work_done);\r\nub_state_done(sc, cmd, rc);\r\nreturn -1;\r\n}\r\nif (cmd->timeo)\r\nsc->work_timer.expires = jiffies + cmd->timeo;\r\nelse\r\nsc->work_timer.expires = jiffies + UB_STAT_TIMEOUT;\r\nadd_timer(&sc->work_timer);\r\nreturn 0;\r\n}\r\nstatic void ub_state_stat(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nif (__ub_state_stat(sc, cmd) != 0)\r\nreturn;\r\ncmd->stat_count = 0;\r\ncmd->state = UB_CMDST_STAT;\r\n}\r\nstatic void ub_state_stat_counted(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nif (++cmd->stat_count >= 4) {\r\nub_state_sense(sc, cmd);\r\nreturn;\r\n}\r\nif (__ub_state_stat(sc, cmd) != 0)\r\nreturn;\r\ncmd->state = UB_CMDST_STAT;\r\n}\r\nstatic void ub_state_sense(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nstruct ub_scsi_cmd *scmd;\r\nstruct scatterlist *sg;\r\nint rc;\r\nif (cmd->cdb[0] == REQUEST_SENSE) {\r\nrc = -EPIPE;\r\ngoto error;\r\n}\r\nscmd = &sc->top_rqs_cmd;\r\nmemset(scmd, 0, sizeof(struct ub_scsi_cmd));\r\nscmd->cdb[0] = REQUEST_SENSE;\r\nscmd->cdb[4] = UB_SENSE_SIZE;\r\nscmd->cdb_len = 6;\r\nscmd->dir = UB_DIR_READ;\r\nscmd->state = UB_CMDST_INIT;\r\nscmd->nsg = 1;\r\nsg = &scmd->sgv[0];\r\nsg_init_table(sg, UB_MAX_REQ_SG);\r\nsg_set_page(sg, virt_to_page(sc->top_sense), UB_SENSE_SIZE,\r\n(unsigned long)sc->top_sense & (PAGE_SIZE-1));\r\nscmd->len = UB_SENSE_SIZE;\r\nscmd->lun = cmd->lun;\r\nscmd->done = ub_top_sense_done;\r\nscmd->back = cmd;\r\nscmd->tag = sc->tagcnt++;\r\ncmd->state = UB_CMDST_SENSE;\r\nub_cmdq_insert(sc, scmd);\r\nreturn;\r\nerror:\r\nub_state_done(sc, cmd, rc);\r\n}\r\nstatic int ub_submit_clear_stall(struct ub_dev *sc, struct ub_scsi_cmd *cmd,\r\nint stalled_pipe)\r\n{\r\nint endp;\r\nstruct usb_ctrlrequest *cr;\r\nint rc;\r\nendp = usb_pipeendpoint(stalled_pipe);\r\nif (usb_pipein (stalled_pipe))\r\nendp |= USB_DIR_IN;\r\ncr = &sc->work_cr;\r\ncr->bRequestType = USB_RECIP_ENDPOINT;\r\ncr->bRequest = USB_REQ_CLEAR_FEATURE;\r\ncr->wValue = cpu_to_le16(USB_ENDPOINT_HALT);\r\ncr->wIndex = cpu_to_le16(endp);\r\ncr->wLength = cpu_to_le16(0);\r\nUB_INIT_COMPLETION(sc->work_done);\r\nusb_fill_control_urb(&sc->work_urb, sc->dev, sc->send_ctrl_pipe,\r\n(unsigned char*) cr, NULL, 0, ub_urb_complete, sc);\r\nif ((rc = usb_submit_urb(&sc->work_urb, GFP_ATOMIC)) != 0) {\r\nub_complete(&sc->work_done);\r\nreturn rc;\r\n}\r\nsc->work_timer.expires = jiffies + UB_CTRL_TIMEOUT;\r\nadd_timer(&sc->work_timer);\r\nreturn 0;\r\n}\r\nstatic void ub_top_sense_done(struct ub_dev *sc, struct ub_scsi_cmd *scmd)\r\n{\r\nunsigned char *sense = sc->top_sense;\r\nstruct ub_scsi_cmd *cmd;\r\nif ((cmd = ub_cmdq_peek(sc)) == NULL) {\r\nprintk(KERN_WARNING "%s: sense done while idle\n", sc->name);\r\nreturn;\r\n}\r\nif (cmd != scmd->back) {\r\nprintk(KERN_WARNING "%s: "\r\n"sense done for wrong command 0x%x\n",\r\nsc->name, cmd->tag);\r\nreturn;\r\n}\r\nif (cmd->state != UB_CMDST_SENSE) {\r\nprintk(KERN_WARNING "%s: sense done with bad cmd state %d\n",\r\nsc->name, cmd->state);\r\nreturn;\r\n}\r\ncmd->key = sense[2] & 0x0F;\r\ncmd->asc = sense[12];\r\ncmd->ascq = sense[13];\r\nub_scsi_urb_compl(sc, cmd);\r\n}\r\nstatic void ub_reset_enter(struct ub_dev *sc, int try)\r\n{\r\nif (sc->reset) {\r\nreturn;\r\n}\r\nsc->reset = try + 1;\r\n#if 0\r\nunsigned long flags;\r\nspin_lock_irqsave(&ub_lock, flags);\r\nsc->openc++;\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\n#endif\r\n#if 0\r\nstruct ub_lun *lun;\r\nlist_for_each_entry(lun, &sc->luns, link) {\r\nblk_stop_queue(lun->disk->queue);\r\n}\r\n#endif\r\nschedule_work(&sc->reset_work);\r\n}\r\nstatic void ub_reset_task(struct work_struct *work)\r\n{\r\nstruct ub_dev *sc = container_of(work, struct ub_dev, reset_work);\r\nunsigned long flags;\r\nstruct ub_lun *lun;\r\nint rc;\r\nif (!sc->reset) {\r\nprintk(KERN_WARNING "%s: Running reset unrequested\n",\r\nsc->name);\r\nreturn;\r\n}\r\nif (atomic_read(&sc->poison)) {\r\n;\r\n} else if ((sc->reset & 1) == 0) {\r\nub_sync_reset(sc);\r\nmsleep(700);\r\nub_probe_clear_stall(sc, sc->recv_bulk_pipe);\r\nub_probe_clear_stall(sc, sc->send_bulk_pipe);\r\n} else if (sc->dev->actconfig->desc.bNumInterfaces != 1) {\r\n;\r\n} else {\r\nrc = usb_lock_device_for_reset(sc->dev, sc->intf);\r\nif (rc < 0) {\r\nprintk(KERN_NOTICE\r\n"%s: usb_lock_device_for_reset failed (%d)\n",\r\nsc->name, rc);\r\n} else {\r\nrc = usb_reset_device(sc->dev);\r\nif (rc < 0) {\r\nprintk(KERN_NOTICE "%s: "\r\n"usb_lock_device_for_reset failed (%d)\n",\r\nsc->name, rc);\r\n}\r\nusb_unlock_device(sc->dev);\r\n}\r\n}\r\nspin_lock_irqsave(sc->lock, flags);\r\nsc->reset = 0;\r\ntasklet_schedule(&sc->tasklet);\r\nlist_for_each_entry(lun, &sc->luns, link) {\r\nblk_start_queue(lun->disk->queue);\r\n}\r\nwake_up(&sc->reset_wait);\r\nspin_unlock_irqrestore(sc->lock, flags);\r\n}\r\nstatic int ub_pre_reset(struct usb_interface *iface) {\r\nreturn 0;\r\n}\r\nstatic int ub_post_reset(struct usb_interface *iface) {\r\nreturn 0;\r\n}\r\nstatic void ub_revalidate(struct ub_dev *sc, struct ub_lun *lun)\r\n{\r\nlun->readonly = 0;\r\nlun->capacity.nsec = 0;\r\nlun->capacity.bsize = 512;\r\nlun->capacity.bshift = 0;\r\nif (ub_sync_tur(sc, lun) != 0)\r\nreturn;\r\nlun->changed = 0;\r\nif (ub_sync_read_cap(sc, lun, &lun->capacity) != 0) {\r\nif (ub_sync_read_cap(sc, lun, &lun->capacity) != 0) {\r\nlun->capacity.nsec = 0;\r\nlun->capacity.bsize = 512;\r\nlun->capacity.bshift = 0;\r\n}\r\n}\r\n}\r\nstatic int ub_bd_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct ub_lun *lun = bdev->bd_disk->private_data;\r\nstruct ub_dev *sc = lun->udev;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&ub_lock, flags);\r\nif (atomic_read(&sc->poison)) {\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\nreturn -ENXIO;\r\n}\r\nsc->openc++;\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\nif (lun->removable || lun->readonly)\r\ncheck_disk_change(bdev);\r\nif (lun->removable && lun->changed && !(mode & FMODE_NDELAY)) {\r\nrc = -ENOMEDIUM;\r\ngoto err_open;\r\n}\r\nif (lun->readonly && (mode & FMODE_WRITE)) {\r\nrc = -EROFS;\r\ngoto err_open;\r\n}\r\nreturn 0;\r\nerr_open:\r\nub_put(sc);\r\nreturn rc;\r\n}\r\nstatic int ub_bd_unlocked_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&ub_mutex);\r\nret = ub_bd_open(bdev, mode);\r\nmutex_unlock(&ub_mutex);\r\nreturn ret;\r\n}\r\nstatic int ub_bd_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct ub_lun *lun = disk->private_data;\r\nstruct ub_dev *sc = lun->udev;\r\nmutex_lock(&ub_mutex);\r\nub_put(sc);\r\nmutex_unlock(&ub_mutex);\r\nreturn 0;\r\n}\r\nstatic int ub_bd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nvoid __user *usermem = (void __user *) arg;\r\nint ret;\r\nmutex_lock(&ub_mutex);\r\nret = scsi_cmd_ioctl(disk->queue, disk, mode, cmd, usermem);\r\nmutex_unlock(&ub_mutex);\r\nreturn ret;\r\n}\r\nstatic int ub_bd_revalidate(struct gendisk *disk)\r\n{\r\nstruct ub_lun *lun = disk->private_data;\r\nub_revalidate(lun->udev, lun);\r\nblk_queue_logical_block_size(disk->queue, lun->capacity.bsize);\r\nset_capacity(disk, lun->capacity.nsec);\r\nreturn 0;\r\n}\r\nstatic unsigned int ub_bd_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct ub_lun *lun = disk->private_data;\r\nif (!lun->removable)\r\nreturn 0;\r\nif (ub_sync_tur(lun->udev, lun) != 0) {\r\nlun->changed = 1;\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\n}\r\nreturn lun->changed ? DISK_EVENT_MEDIA_CHANGE : 0;\r\n}\r\nstatic void ub_probe_done(struct ub_dev *sc, struct ub_scsi_cmd *cmd)\r\n{\r\nstruct completion *cop = cmd->back;\r\ncomplete(cop);\r\n}\r\nstatic int ub_sync_tur(struct ub_dev *sc, struct ub_lun *lun)\r\n{\r\nstruct ub_scsi_cmd *cmd;\r\nenum { ALLOC_SIZE = sizeof(struct ub_scsi_cmd) };\r\nunsigned long flags;\r\nstruct completion compl;\r\nint rc;\r\ninit_completion(&compl);\r\nrc = -ENOMEM;\r\nif ((cmd = kzalloc(ALLOC_SIZE, GFP_KERNEL)) == NULL)\r\ngoto err_alloc;\r\ncmd->cdb[0] = TEST_UNIT_READY;\r\ncmd->cdb_len = 6;\r\ncmd->dir = UB_DIR_NONE;\r\ncmd->state = UB_CMDST_INIT;\r\ncmd->lun = lun;\r\ncmd->done = ub_probe_done;\r\ncmd->back = &compl;\r\nspin_lock_irqsave(sc->lock, flags);\r\ncmd->tag = sc->tagcnt++;\r\nrc = ub_submit_scsi(sc, cmd);\r\nspin_unlock_irqrestore(sc->lock, flags);\r\nif (rc != 0)\r\ngoto err_submit;\r\nwait_for_completion(&compl);\r\nrc = cmd->error;\r\nif (rc == -EIO && cmd->key != 0)\r\nrc = cmd->key;\r\nerr_submit:\r\nkfree(cmd);\r\nerr_alloc:\r\nreturn rc;\r\n}\r\nstatic int ub_sync_read_cap(struct ub_dev *sc, struct ub_lun *lun,\r\nstruct ub_capacity *ret)\r\n{\r\nstruct ub_scsi_cmd *cmd;\r\nstruct scatterlist *sg;\r\nchar *p;\r\nenum { ALLOC_SIZE = sizeof(struct ub_scsi_cmd) + 8 };\r\nunsigned long flags;\r\nunsigned int bsize, shift;\r\nunsigned long nsec;\r\nstruct completion compl;\r\nint rc;\r\ninit_completion(&compl);\r\nrc = -ENOMEM;\r\nif ((cmd = kzalloc(ALLOC_SIZE, GFP_KERNEL)) == NULL)\r\ngoto err_alloc;\r\np = (char *)cmd + sizeof(struct ub_scsi_cmd);\r\ncmd->cdb[0] = 0x25;\r\ncmd->cdb_len = 10;\r\ncmd->dir = UB_DIR_READ;\r\ncmd->state = UB_CMDST_INIT;\r\ncmd->nsg = 1;\r\nsg = &cmd->sgv[0];\r\nsg_init_table(sg, UB_MAX_REQ_SG);\r\nsg_set_page(sg, virt_to_page(p), 8, (unsigned long)p & (PAGE_SIZE-1));\r\ncmd->len = 8;\r\ncmd->lun = lun;\r\ncmd->done = ub_probe_done;\r\ncmd->back = &compl;\r\nspin_lock_irqsave(sc->lock, flags);\r\ncmd->tag = sc->tagcnt++;\r\nrc = ub_submit_scsi(sc, cmd);\r\nspin_unlock_irqrestore(sc->lock, flags);\r\nif (rc != 0)\r\ngoto err_submit;\r\nwait_for_completion(&compl);\r\nif (cmd->error != 0) {\r\nrc = -EIO;\r\ngoto err_read;\r\n}\r\nif (cmd->act_len != 8) {\r\nrc = -EIO;\r\ngoto err_read;\r\n}\r\nnsec = be32_to_cpu(*(__be32 *)p) + 1;\r\nbsize = be32_to_cpu(*(__be32 *)(p + 4));\r\nswitch (bsize) {\r\ncase 512: shift = 0; break;\r\ncase 1024: shift = 1; break;\r\ncase 2048: shift = 2; break;\r\ncase 4096: shift = 3; break;\r\ndefault:\r\nrc = -EDOM;\r\ngoto err_inv_bsize;\r\n}\r\nret->bsize = bsize;\r\nret->bshift = shift;\r\nret->nsec = nsec << shift;\r\nrc = 0;\r\nerr_inv_bsize:\r\nerr_read:\r\nerr_submit:\r\nkfree(cmd);\r\nerr_alloc:\r\nreturn rc;\r\n}\r\nstatic void ub_probe_urb_complete(struct urb *urb)\r\n{\r\nstruct completion *cop = urb->context;\r\ncomplete(cop);\r\n}\r\nstatic void ub_probe_timeout(unsigned long arg)\r\n{\r\nstruct completion *cop = (struct completion *) arg;\r\ncomplete(cop);\r\n}\r\nstatic int ub_sync_reset(struct ub_dev *sc)\r\n{\r\nint ifnum = sc->intf->cur_altsetting->desc.bInterfaceNumber;\r\nstruct usb_ctrlrequest *cr;\r\nstruct completion compl;\r\nstruct timer_list timer;\r\nint rc;\r\ninit_completion(&compl);\r\ncr = &sc->work_cr;\r\ncr->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE;\r\ncr->bRequest = US_BULK_RESET_REQUEST;\r\ncr->wValue = cpu_to_le16(0);\r\ncr->wIndex = cpu_to_le16(ifnum);\r\ncr->wLength = cpu_to_le16(0);\r\nusb_fill_control_urb(&sc->work_urb, sc->dev, sc->send_ctrl_pipe,\r\n(unsigned char*) cr, NULL, 0, ub_probe_urb_complete, &compl);\r\nif ((rc = usb_submit_urb(&sc->work_urb, GFP_KERNEL)) != 0) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to submit a bulk reset (%d)\n", sc->name, rc);\r\nreturn rc;\r\n}\r\ninit_timer(&timer);\r\ntimer.function = ub_probe_timeout;\r\ntimer.data = (unsigned long) &compl;\r\ntimer.expires = jiffies + UB_CTRL_TIMEOUT;\r\nadd_timer(&timer);\r\nwait_for_completion(&compl);\r\ndel_timer_sync(&timer);\r\nusb_kill_urb(&sc->work_urb);\r\nreturn sc->work_urb.status;\r\n}\r\nstatic int ub_sync_getmaxlun(struct ub_dev *sc)\r\n{\r\nint ifnum = sc->intf->cur_altsetting->desc.bInterfaceNumber;\r\nunsigned char *p;\r\nenum { ALLOC_SIZE = 1 };\r\nstruct usb_ctrlrequest *cr;\r\nstruct completion compl;\r\nstruct timer_list timer;\r\nint nluns;\r\nint rc;\r\ninit_completion(&compl);\r\nrc = -ENOMEM;\r\nif ((p = kmalloc(ALLOC_SIZE, GFP_KERNEL)) == NULL)\r\ngoto err_alloc;\r\n*p = 55;\r\ncr = &sc->work_cr;\r\ncr->bRequestType = USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;\r\ncr->bRequest = US_BULK_GET_MAX_LUN;\r\ncr->wValue = cpu_to_le16(0);\r\ncr->wIndex = cpu_to_le16(ifnum);\r\ncr->wLength = cpu_to_le16(1);\r\nusb_fill_control_urb(&sc->work_urb, sc->dev, sc->recv_ctrl_pipe,\r\n(unsigned char*) cr, p, 1, ub_probe_urb_complete, &compl);\r\nif ((rc = usb_submit_urb(&sc->work_urb, GFP_KERNEL)) != 0)\r\ngoto err_submit;\r\ninit_timer(&timer);\r\ntimer.function = ub_probe_timeout;\r\ntimer.data = (unsigned long) &compl;\r\ntimer.expires = jiffies + UB_CTRL_TIMEOUT;\r\nadd_timer(&timer);\r\nwait_for_completion(&compl);\r\ndel_timer_sync(&timer);\r\nusb_kill_urb(&sc->work_urb);\r\nif ((rc = sc->work_urb.status) < 0)\r\ngoto err_io;\r\nif (sc->work_urb.actual_length != 1) {\r\nnluns = 0;\r\n} else {\r\nif ((nluns = *p) == 55) {\r\nnluns = 0;\r\n} else {\r\nnluns += 1;\r\nif (nluns > UB_MAX_LUNS)\r\nnluns = UB_MAX_LUNS;\r\n}\r\n}\r\nkfree(p);\r\nreturn nluns;\r\nerr_io:\r\nerr_submit:\r\nkfree(p);\r\nerr_alloc:\r\nreturn rc;\r\n}\r\nstatic int ub_probe_clear_stall(struct ub_dev *sc, int stalled_pipe)\r\n{\r\nint endp;\r\nstruct usb_ctrlrequest *cr;\r\nstruct completion compl;\r\nstruct timer_list timer;\r\nint rc;\r\ninit_completion(&compl);\r\nendp = usb_pipeendpoint(stalled_pipe);\r\nif (usb_pipein (stalled_pipe))\r\nendp |= USB_DIR_IN;\r\ncr = &sc->work_cr;\r\ncr->bRequestType = USB_RECIP_ENDPOINT;\r\ncr->bRequest = USB_REQ_CLEAR_FEATURE;\r\ncr->wValue = cpu_to_le16(USB_ENDPOINT_HALT);\r\ncr->wIndex = cpu_to_le16(endp);\r\ncr->wLength = cpu_to_le16(0);\r\nusb_fill_control_urb(&sc->work_urb, sc->dev, sc->send_ctrl_pipe,\r\n(unsigned char*) cr, NULL, 0, ub_probe_urb_complete, &compl);\r\nif ((rc = usb_submit_urb(&sc->work_urb, GFP_KERNEL)) != 0) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to submit a probe clear (%d)\n", sc->name, rc);\r\nreturn rc;\r\n}\r\ninit_timer(&timer);\r\ntimer.function = ub_probe_timeout;\r\ntimer.data = (unsigned long) &compl;\r\ntimer.expires = jiffies + UB_CTRL_TIMEOUT;\r\nadd_timer(&timer);\r\nwait_for_completion(&compl);\r\ndel_timer_sync(&timer);\r\nusb_kill_urb(&sc->work_urb);\r\nusb_reset_endpoint(sc->dev, endp);\r\nreturn 0;\r\n}\r\nstatic int ub_get_pipes(struct ub_dev *sc, struct usb_device *dev,\r\nstruct usb_interface *intf)\r\n{\r\nstruct usb_host_interface *altsetting = intf->cur_altsetting;\r\nstruct usb_endpoint_descriptor *ep_in = NULL;\r\nstruct usb_endpoint_descriptor *ep_out = NULL;\r\nstruct usb_endpoint_descriptor *ep;\r\nint i;\r\nfor (i = 0; i < altsetting->desc.bNumEndpoints; i++) {\r\nep = &altsetting->endpoint[i].desc;\r\nif (usb_endpoint_xfer_bulk(ep)) {\r\nif (usb_endpoint_dir_in(ep)) {\r\nif (ep_in == NULL)\r\nep_in = ep;\r\n} else {\r\nif (ep_out == NULL)\r\nep_out = ep;\r\n}\r\n}\r\n}\r\nif (ep_in == NULL || ep_out == NULL) {\r\nprintk(KERN_NOTICE "%s: failed endpoint check\n", sc->name);\r\nreturn -ENODEV;\r\n}\r\nsc->send_ctrl_pipe = usb_sndctrlpipe(dev, 0);\r\nsc->recv_ctrl_pipe = usb_rcvctrlpipe(dev, 0);\r\nsc->send_bulk_pipe = usb_sndbulkpipe(dev,\r\nusb_endpoint_num(ep_out));\r\nsc->recv_bulk_pipe = usb_rcvbulkpipe(dev,\r\nusb_endpoint_num(ep_in));\r\nreturn 0;\r\n}\r\nstatic int ub_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *dev_id)\r\n{\r\nstruct ub_dev *sc;\r\nint nluns;\r\nint rc;\r\nint i;\r\nif (usb_usual_check_type(dev_id, USB_US_TYPE_UB))\r\nreturn -ENXIO;\r\nrc = -ENOMEM;\r\nif ((sc = kzalloc(sizeof(struct ub_dev), GFP_KERNEL)) == NULL)\r\ngoto err_core;\r\nsc->lock = ub_next_lock();\r\nINIT_LIST_HEAD(&sc->luns);\r\nusb_init_urb(&sc->work_urb);\r\ntasklet_init(&sc->tasklet, ub_scsi_action, (unsigned long)sc);\r\natomic_set(&sc->poison, 0);\r\nINIT_WORK(&sc->reset_work, ub_reset_task);\r\ninit_waitqueue_head(&sc->reset_wait);\r\ninit_timer(&sc->work_timer);\r\nsc->work_timer.data = (unsigned long) sc;\r\nsc->work_timer.function = ub_urb_timeout;\r\nub_init_completion(&sc->work_done);\r\nsc->work_done.done = 1;\r\nsc->dev = interface_to_usbdev(intf);\r\nsc->intf = intf;\r\nusb_set_intfdata(intf, sc);\r\nusb_get_dev(sc->dev);\r\nusb_get_intf(sc->intf);\r\nsnprintf(sc->name, 12, DRV_NAME "(%d.%d)",\r\nsc->dev->bus->busnum, sc->dev->devnum);\r\nif (ub_get_pipes(sc, sc->dev, intf) != 0)\r\ngoto err_dev_desc;\r\n#if 0\r\nub_probe_clear_stall(sc, sc->recv_bulk_pipe);\r\nub_probe_clear_stall(sc, sc->send_bulk_pipe);\r\n#endif\r\nfor (i = 0; i < 3; i++) {\r\nif ((rc = ub_sync_tur(sc, NULL)) <= 0) break;\r\nif (rc != 0x6) break;\r\nmsleep(10);\r\n}\r\nnluns = 1;\r\nfor (i = 0; i < 3; i++) {\r\nif ((rc = ub_sync_getmaxlun(sc)) < 0)\r\nbreak;\r\nif (rc != 0) {\r\nnluns = rc;\r\nbreak;\r\n}\r\nmsleep(100);\r\n}\r\nfor (i = 0; i < nluns; i++) {\r\nub_probe_lun(sc, i);\r\n}\r\nreturn 0;\r\nerr_dev_desc:\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_intf(sc->intf);\r\nusb_put_dev(sc->dev);\r\nkfree(sc);\r\nerr_core:\r\nreturn rc;\r\n}\r\nstatic int ub_probe_lun(struct ub_dev *sc, int lnum)\r\n{\r\nstruct ub_lun *lun;\r\nstruct request_queue *q;\r\nstruct gendisk *disk;\r\nint rc;\r\nrc = -ENOMEM;\r\nif ((lun = kzalloc(sizeof(struct ub_lun), GFP_KERNEL)) == NULL)\r\ngoto err_alloc;\r\nlun->num = lnum;\r\nrc = -ENOSR;\r\nif ((lun->id = ub_id_get()) == -1)\r\ngoto err_id;\r\nlun->udev = sc;\r\nsnprintf(lun->name, 16, DRV_NAME "%c(%d.%d.%d)",\r\nlun->id + 'a', sc->dev->bus->busnum, sc->dev->devnum, lun->num);\r\nlun->removable = 1;\r\nlun->changed = 1;\r\nub_revalidate(sc, lun);\r\nrc = -ENOMEM;\r\nif ((disk = alloc_disk(UB_PARTS_PER_LUN)) == NULL)\r\ngoto err_diskalloc;\r\nsprintf(disk->disk_name, DRV_NAME "%c", lun->id + 'a');\r\ndisk->major = UB_MAJOR;\r\ndisk->first_minor = lun->id * UB_PARTS_PER_LUN;\r\ndisk->fops = &ub_bd_fops;\r\ndisk->private_data = lun;\r\ndisk->driverfs_dev = &sc->intf->dev;\r\nrc = -ENOMEM;\r\nif ((q = blk_init_queue(ub_request_fn, sc->lock)) == NULL)\r\ngoto err_blkqinit;\r\ndisk->queue = q;\r\nblk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);\r\nblk_queue_max_segments(q, UB_MAX_REQ_SG);\r\nblk_queue_segment_boundary(q, 0xffffffff);\r\nblk_queue_max_hw_sectors(q, UB_MAX_SECTORS);\r\nblk_queue_logical_block_size(q, lun->capacity.bsize);\r\nlun->disk = disk;\r\nq->queuedata = lun;\r\nlist_add(&lun->link, &sc->luns);\r\nset_capacity(disk, lun->capacity.nsec);\r\nif (lun->removable)\r\ndisk->flags |= GENHD_FL_REMOVABLE;\r\nadd_disk(disk);\r\nreturn 0;\r\nerr_blkqinit:\r\nput_disk(disk);\r\nerr_diskalloc:\r\nub_id_put(lun->id);\r\nerr_id:\r\nkfree(lun);\r\nerr_alloc:\r\nreturn rc;\r\n}\r\nstatic void ub_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ub_dev *sc = usb_get_intfdata(intf);\r\nstruct ub_lun *lun;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ub_lock, flags);\r\nsc->openc++;\r\nspin_unlock_irqrestore(&ub_lock, flags);\r\natomic_set(&sc->poison, 1);\r\nwait_event(sc->reset_wait, !sc->reset);\r\nspin_lock_irqsave(sc->lock, flags);\r\n{\r\nstruct ub_scsi_cmd *cmd;\r\nint cnt = 0;\r\nwhile ((cmd = ub_cmdq_peek(sc)) != NULL) {\r\ncmd->error = -ENOTCONN;\r\ncmd->state = UB_CMDST_DONE;\r\nub_cmdq_pop(sc);\r\n(*cmd->done)(sc, cmd);\r\ncnt++;\r\n}\r\nif (cnt != 0) {\r\nprintk(KERN_WARNING "%s: "\r\n"%d was queued after shutdown\n", sc->name, cnt);\r\n}\r\n}\r\nspin_unlock_irqrestore(sc->lock, flags);\r\nlist_for_each_entry(lun, &sc->luns, link) {\r\ndel_gendisk(lun->disk);\r\n}\r\nspin_lock_irqsave(sc->lock, flags);\r\nif (sc->work_urb.status == -EINPROGRESS) {\r\nprintk(KERN_WARNING "%s: "\r\n"URB is active after disconnect\n", sc->name);\r\n}\r\nspin_unlock_irqrestore(sc->lock, flags);\r\ndel_timer_sync(&sc->work_timer);\r\nub_put(sc);\r\n}\r\nstatic int __init ub_init(void)\r\n{\r\nint rc;\r\nint i;\r\nfor (i = 0; i < UB_QLOCK_NUM; i++)\r\nspin_lock_init(&ub_qlockv[i]);\r\nif ((rc = register_blkdev(UB_MAJOR, DRV_NAME)) != 0)\r\ngoto err_regblkdev;\r\nif ((rc = usb_register(&ub_driver)) != 0)\r\ngoto err_register;\r\nusb_usual_set_present(USB_US_TYPE_UB);\r\nreturn 0;\r\nerr_register:\r\nunregister_blkdev(UB_MAJOR, DRV_NAME);\r\nerr_regblkdev:\r\nreturn rc;\r\n}\r\nstatic void __exit ub_exit(void)\r\n{\r\nusb_deregister(&ub_driver);\r\nunregister_blkdev(UB_MAJOR, DRV_NAME);\r\nusb_usual_clear_present(USB_US_TYPE_UB);\r\n}
