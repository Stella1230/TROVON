static irqreturn_t pmi_irq_handler(int irq, void *dev_id)\r\n{\r\nu8 type;\r\nint rc;\r\nspin_lock(&data->pmi_spinlock);\r\ntype = ioread8(data->pmi_reg + PMI_READ_TYPE);\r\npr_debug("pmi: got message of type %d\n", type);\r\nif (type & PMI_ACK && !data->completion) {\r\nprintk(KERN_WARNING "pmi: got unexpected ACK message.\n");\r\nrc = -EIO;\r\ngoto unlock;\r\n}\r\nif (data->completion && !(type & PMI_ACK)) {\r\nprintk(KERN_WARNING "pmi: expected ACK, but got %d\n", type);\r\nrc = -EIO;\r\ngoto unlock;\r\n}\r\ndata->msg.type = type;\r\ndata->msg.data0 = ioread8(data->pmi_reg + PMI_READ_DATA0);\r\ndata->msg.data1 = ioread8(data->pmi_reg + PMI_READ_DATA1);\r\ndata->msg.data2 = ioread8(data->pmi_reg + PMI_READ_DATA2);\r\nrc = 0;\r\nunlock:\r\nspin_unlock(&data->pmi_spinlock);\r\nif (rc == -EIO) {\r\nrc = IRQ_HANDLED;\r\ngoto out;\r\n}\r\nif (data->msg.type & PMI_ACK) {\r\ncomplete(data->completion);\r\nrc = IRQ_HANDLED;\r\ngoto out;\r\n}\r\nschedule_work(&data->work);\r\nrc = IRQ_HANDLED;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void pmi_notify_handlers(struct work_struct *work)\r\n{\r\nstruct pmi_handler *handler;\r\nspin_lock(&data->handler_spinlock);\r\nlist_for_each_entry(handler, &data->handler, node) {\r\npr_debug("pmi: notifying handler %p\n", handler);\r\nif (handler->type == data->msg.type)\r\nhandler->handle_pmi_message(data->msg);\r\n}\r\nspin_unlock(&data->handler_spinlock);\r\n}\r\nstatic int pmi_of_probe(struct platform_device *dev)\r\n{\r\nstruct device_node *np = dev->dev.of_node;\r\nint rc;\r\nif (data) {\r\nprintk(KERN_ERR "pmi: driver has already been initialized.\n");\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\ndata = kzalloc(sizeof(struct pmi_data), GFP_KERNEL);\r\nif (!data) {\r\nprintk(KERN_ERR "pmi: could not allocate memory.\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ndata->pmi_reg = of_iomap(np, 0);\r\nif (!data->pmi_reg) {\r\nprintk(KERN_ERR "pmi: invalid register address.\n");\r\nrc = -EFAULT;\r\ngoto error_cleanup_data;\r\n}\r\nINIT_LIST_HEAD(&data->handler);\r\nmutex_init(&data->msg_mutex);\r\nspin_lock_init(&data->pmi_spinlock);\r\nspin_lock_init(&data->handler_spinlock);\r\nINIT_WORK(&data->work, pmi_notify_handlers);\r\ndata->dev = dev;\r\ndata->irq = irq_of_parse_and_map(np, 0);\r\nif (data->irq == NO_IRQ) {\r\nprintk(KERN_ERR "pmi: invalid interrupt.\n");\r\nrc = -EFAULT;\r\ngoto error_cleanup_iomap;\r\n}\r\nrc = request_irq(data->irq, pmi_irq_handler, 0, "pmi", NULL);\r\nif (rc) {\r\nprintk(KERN_ERR "pmi: can't request IRQ %d: returned %d\n",\r\ndata->irq, rc);\r\ngoto error_cleanup_iomap;\r\n}\r\nprintk(KERN_INFO "pmi: found pmi device at addr %p.\n", data->pmi_reg);\r\ngoto out;\r\nerror_cleanup_iomap:\r\niounmap(data->pmi_reg);\r\nerror_cleanup_data:\r\nkfree(data);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int pmi_of_remove(struct platform_device *dev)\r\n{\r\nstruct pmi_handler *handler, *tmp;\r\nfree_irq(data->irq, NULL);\r\niounmap(data->pmi_reg);\r\nspin_lock(&data->handler_spinlock);\r\nlist_for_each_entry_safe(handler, tmp, &data->handler, node)\r\nlist_del(&handler->node);\r\nspin_unlock(&data->handler_spinlock);\r\nkfree(data);\r\ndata = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init pmi_module_init(void)\r\n{\r\nreturn platform_driver_register(&pmi_of_platform_driver);\r\n}\r\nstatic void __exit pmi_module_exit(void)\r\n{\r\nplatform_driver_unregister(&pmi_of_platform_driver);\r\n}\r\nint pmi_send_message(pmi_message_t msg)\r\n{\r\nunsigned long flags;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nif (!data)\r\nreturn -ENODEV;\r\nmutex_lock(&data->msg_mutex);\r\ndata->msg = msg;\r\npr_debug("pmi_send_message: msg is %08x\n", *(u32*)&msg);\r\ndata->completion = &completion;\r\nspin_lock_irqsave(&data->pmi_spinlock, flags);\r\niowrite8(msg.data0, data->pmi_reg + PMI_WRITE_DATA0);\r\niowrite8(msg.data1, data->pmi_reg + PMI_WRITE_DATA1);\r\niowrite8(msg.data2, data->pmi_reg + PMI_WRITE_DATA2);\r\niowrite8(msg.type, data->pmi_reg + PMI_WRITE_TYPE);\r\nspin_unlock_irqrestore(&data->pmi_spinlock, flags);\r\npr_debug("pmi_send_message: wait for completion\n");\r\nwait_for_completion_interruptible_timeout(data->completion,\r\nPMI_TIMEOUT);\r\ndata->completion = NULL;\r\nmutex_unlock(&data->msg_mutex);\r\nreturn 0;\r\n}\r\nint pmi_register_handler(struct pmi_handler *handler)\r\n{\r\nif (!data)\r\nreturn -ENODEV;\r\nspin_lock(&data->handler_spinlock);\r\nlist_add_tail(&handler->node, &data->handler);\r\nspin_unlock(&data->handler_spinlock);\r\nreturn 0;\r\n}\r\nvoid pmi_unregister_handler(struct pmi_handler *handler)\r\n{\r\nif (!data)\r\nreturn;\r\npr_debug("pmi: unregistering handler %p\n", handler);\r\nspin_lock(&data->handler_spinlock);\r\nlist_del(&handler->node);\r\nspin_unlock(&data->handler_spinlock);\r\n}
