static int find_boot_record(struct INFTLrecord *inftl)\r\n{\r\nstruct inftl_unittail h1;\r\nunsigned int i, block;\r\nu8 buf[SECTORSIZE];\r\nstruct INFTLMediaHeader *mh = &inftl->MediaHdr;\r\nstruct mtd_info *mtd = inftl->mbd.mtd;\r\nstruct INFTLPartition *ip;\r\nsize_t retlen;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: find_boot_record(inftl=%p)\n", inftl);\r\ninftl->EraseSize = inftl->mbd.mtd->erasesize;\r\ninftl->nb_blocks = (u32)inftl->mbd.mtd->size / inftl->EraseSize;\r\ninftl->MediaUnit = BLOCK_NIL;\r\nfor (block = 0; block < inftl->nb_blocks; block++) {\r\nint ret;\r\nret = mtd->read(mtd, block * inftl->EraseSize,\r\nSECTORSIZE, &retlen, buf);\r\nif (retlen != SECTORSIZE) {\r\nstatic int warncount = 5;\r\nif (warncount) {\r\nprintk(KERN_WARNING "INFTL: block read at 0x%x "\r\n"of mtd%d failed: %d\n",\r\nblock * inftl->EraseSize,\r\ninftl->mbd.mtd->index, ret);\r\nif (!--warncount)\r\nprintk(KERN_WARNING "INFTL: further "\r\n"failures for this block will "\r\n"not be printed\n");\r\n}\r\ncontinue;\r\n}\r\nif (retlen < 6 || memcmp(buf, "BNAND", 6)) {\r\ncontinue;\r\n}\r\nret = inftl_read_oob(mtd,\r\nblock * inftl->EraseSize + SECTORSIZE + 8,\r\n8, &retlen,(char *)&h1);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "INFTL: ANAND header found at "\r\n"0x%x in mtd%d, but OOB data read failed "\r\n"(err %d)\n", block * inftl->EraseSize,\r\ninftl->mbd.mtd->index, ret);\r\ncontinue;\r\n}\r\nmemcpy(mh, buf, sizeof(struct INFTLMediaHeader));\r\nmtd->read(mtd, block * inftl->EraseSize + 4096,\r\nSECTORSIZE, &retlen, buf);\r\nif (retlen != SECTORSIZE) {\r\nprintk(KERN_WARNING "INFTL: Unable to read spare "\r\n"Media Header\n");\r\nreturn -1;\r\n}\r\nif (memcmp(mh, buf, sizeof(struct INFTLMediaHeader))) {\r\nprintk(KERN_WARNING "INFTL: Primary and spare Media "\r\n"Headers disagree.\n");\r\nreturn -1;\r\n}\r\nmh->NoOfBootImageBlocks = le32_to_cpu(mh->NoOfBootImageBlocks);\r\nmh->NoOfBinaryPartitions = le32_to_cpu(mh->NoOfBinaryPartitions);\r\nmh->NoOfBDTLPartitions = le32_to_cpu(mh->NoOfBDTLPartitions);\r\nmh->BlockMultiplierBits = le32_to_cpu(mh->BlockMultiplierBits);\r\nmh->FormatFlags = le32_to_cpu(mh->FormatFlags);\r\nmh->PercentUsed = le32_to_cpu(mh->PercentUsed);\r\n#ifdef CONFIG_MTD_DEBUG_VERBOSE\r\nif (CONFIG_MTD_DEBUG_VERBOSE >= 2) {\r\nprintk("INFTL: Media Header ->\n"\r\n" bootRecordID = %s\n"\r\n" NoOfBootImageBlocks = %d\n"\r\n" NoOfBinaryPartitions = %d\n"\r\n" NoOfBDTLPartitions = %d\n"\r\n" BlockMultiplerBits = %d\n"\r\n" FormatFlgs = %d\n"\r\n" OsakVersion = 0x%x\n"\r\n" PercentUsed = %d\n",\r\nmh->bootRecordID, mh->NoOfBootImageBlocks,\r\nmh->NoOfBinaryPartitions,\r\nmh->NoOfBDTLPartitions,\r\nmh->BlockMultiplierBits, mh->FormatFlags,\r\nmh->OsakVersion, mh->PercentUsed);\r\n}\r\n#endif\r\nif (mh->NoOfBDTLPartitions == 0) {\r\nprintk(KERN_WARNING "INFTL: Media Header sanity check "\r\n"failed: NoOfBDTLPartitions (%d) == 0, "\r\n"must be at least 1\n", mh->NoOfBDTLPartitions);\r\nreturn -1;\r\n}\r\nif ((mh->NoOfBDTLPartitions + mh->NoOfBinaryPartitions) > 4) {\r\nprintk(KERN_WARNING "INFTL: Media Header sanity check "\r\n"failed: Total Partitions (%d) > 4, "\r\n"BDTL=%d Binary=%d\n", mh->NoOfBDTLPartitions +\r\nmh->NoOfBinaryPartitions,\r\nmh->NoOfBDTLPartitions,\r\nmh->NoOfBinaryPartitions);\r\nreturn -1;\r\n}\r\nif (mh->BlockMultiplierBits > 1) {\r\nprintk(KERN_WARNING "INFTL: sorry, we don't support "\r\n"UnitSizeFactor 0x%02x\n",\r\nmh->BlockMultiplierBits);\r\nreturn -1;\r\n} else if (mh->BlockMultiplierBits == 1) {\r\nprintk(KERN_WARNING "INFTL: support for INFTL with "\r\n"UnitSizeFactor 0x%02x is experimental\n",\r\nmh->BlockMultiplierBits);\r\ninftl->EraseSize = inftl->mbd.mtd->erasesize <<\r\nmh->BlockMultiplierBits;\r\ninftl->nb_blocks = (u32)inftl->mbd.mtd->size / inftl->EraseSize;\r\nblock >>= mh->BlockMultiplierBits;\r\n}\r\nfor (i = 0; (i < 4); i++) {\r\nip = &mh->Partitions[i];\r\nip->virtualUnits = le32_to_cpu(ip->virtualUnits);\r\nip->firstUnit = le32_to_cpu(ip->firstUnit);\r\nip->lastUnit = le32_to_cpu(ip->lastUnit);\r\nip->flags = le32_to_cpu(ip->flags);\r\nip->spareUnits = le32_to_cpu(ip->spareUnits);\r\nip->Reserved0 = le32_to_cpu(ip->Reserved0);\r\n#ifdef CONFIG_MTD_DEBUG_VERBOSE\r\nif (CONFIG_MTD_DEBUG_VERBOSE >= 2) {\r\nprintk(" PARTITION[%d] ->\n"\r\n" virtualUnits = %d\n"\r\n" firstUnit = %d\n"\r\n" lastUnit = %d\n"\r\n" flags = 0x%x\n"\r\n" spareUnits = %d\n",\r\ni, ip->virtualUnits, ip->firstUnit,\r\nip->lastUnit, ip->flags,\r\nip->spareUnits);\r\n}\r\n#endif\r\nif (ip->Reserved0 != ip->firstUnit) {\r\nstruct erase_info *instr = &inftl->instr;\r\ninstr->mtd = inftl->mbd.mtd;\r\ninstr->addr = ip->Reserved0 * inftl->EraseSize;\r\ninstr->len = inftl->EraseSize;\r\nmtd->erase(mtd, instr);\r\n}\r\nif ((ip->lastUnit - ip->firstUnit + 1) < ip->virtualUnits) {\r\nprintk(KERN_WARNING "INFTL: Media Header "\r\n"Partition %d sanity check failed\n"\r\n" firstUnit %d : lastUnit %d > "\r\n"virtualUnits %d\n", i, ip->lastUnit,\r\nip->firstUnit, ip->Reserved0);\r\nreturn -1;\r\n}\r\nif (ip->Reserved1 != 0) {\r\nprintk(KERN_WARNING "INFTL: Media Header "\r\n"Partition %d sanity check failed: "\r\n"Reserved1 %d != 0\n",\r\ni, ip->Reserved1);\r\nreturn -1;\r\n}\r\nif (ip->flags & INFTL_BDTL)\r\nbreak;\r\n}\r\nif (i >= 4) {\r\nprintk(KERN_WARNING "INFTL: Media Header Partition "\r\n"sanity check failed:\n No partition "\r\n"marked as Disk Partition\n");\r\nreturn -1;\r\n}\r\ninftl->nb_boot_blocks = ip->firstUnit;\r\ninftl->numvunits = ip->virtualUnits;\r\nif (inftl->numvunits > (inftl->nb_blocks -\r\ninftl->nb_boot_blocks - 2)) {\r\nprintk(KERN_WARNING "INFTL: Media Header sanity check "\r\n"failed:\n numvunits (%d) > nb_blocks "\r\n"(%d) - nb_boot_blocks(%d) - 2\n",\r\ninftl->numvunits, inftl->nb_blocks,\r\ninftl->nb_boot_blocks);\r\nreturn -1;\r\n}\r\ninftl->mbd.size = inftl->numvunits *\r\n(inftl->EraseSize / SECTORSIZE);\r\ninftl->firstEUN = ip->firstUnit;\r\ninftl->lastEUN = ip->lastUnit;\r\ninftl->nb_blocks = ip->lastUnit + 1;\r\ninftl->PUtable = kmalloc(inftl->nb_blocks * sizeof(u16), GFP_KERNEL);\r\nif (!inftl->PUtable) {\r\nprintk(KERN_WARNING "INFTL: allocation of PUtable "\r\n"failed (%zd bytes)\n",\r\ninftl->nb_blocks * sizeof(u16));\r\nreturn -ENOMEM;\r\n}\r\ninftl->VUtable = kmalloc(inftl->nb_blocks * sizeof(u16), GFP_KERNEL);\r\nif (!inftl->VUtable) {\r\nkfree(inftl->PUtable);\r\nprintk(KERN_WARNING "INFTL: allocation of VUtable "\r\n"failed (%zd bytes)\n",\r\ninftl->nb_blocks * sizeof(u16));\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < inftl->nb_boot_blocks; i++)\r\ninftl->PUtable[i] = BLOCK_RESERVED;\r\nfor (; i < inftl->nb_blocks; i++)\r\ninftl->PUtable[i] = BLOCK_NOTEXPLORED;\r\ninftl->PUtable[block] = BLOCK_RESERVED;\r\nfor (i = 0; i < inftl->nb_blocks; i++) {\r\nint physblock;\r\nfor (physblock = 0; physblock < inftl->EraseSize; physblock += inftl->mbd.mtd->erasesize) {\r\nif (inftl->mbd.mtd->block_isbad(inftl->mbd.mtd, i * inftl->EraseSize + physblock))\r\ninftl->PUtable[i] = BLOCK_RESERVED;\r\n}\r\n}\r\ninftl->MediaUnit = block;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int memcmpb(void *a, int c, int n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++) {\r\nif (c != ((unsigned char *)a)[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_free_sectors(struct INFTLrecord *inftl, unsigned int address,\r\nint len, int check_oob)\r\n{\r\nu8 buf[SECTORSIZE + inftl->mbd.mtd->oobsize];\r\nstruct mtd_info *mtd = inftl->mbd.mtd;\r\nsize_t retlen;\r\nint i;\r\nfor (i = 0; i < len; i += SECTORSIZE) {\r\nif (mtd->read(mtd, address, SECTORSIZE, &retlen, buf))\r\nreturn -1;\r\nif (memcmpb(buf, 0xff, SECTORSIZE) != 0)\r\nreturn -1;\r\nif (check_oob) {\r\nif(inftl_read_oob(mtd, address, mtd->oobsize,\r\n&retlen, &buf[SECTORSIZE]) < 0)\r\nreturn -1;\r\nif (memcmpb(buf + SECTORSIZE, 0xff, mtd->oobsize) != 0)\r\nreturn -1;\r\n}\r\naddress += SECTORSIZE;\r\n}\r\nreturn 0;\r\n}\r\nint INFTL_formatblock(struct INFTLrecord *inftl, int block)\r\n{\r\nsize_t retlen;\r\nstruct inftl_unittail uci;\r\nstruct erase_info *instr = &inftl->instr;\r\nstruct mtd_info *mtd = inftl->mbd.mtd;\r\nint physblock;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_formatblock(inftl=%p,"\r\n"block=%d)\n", inftl, block);\r\nmemset(instr, 0, sizeof(struct erase_info));\r\ninstr->mtd = inftl->mbd.mtd;\r\ninstr->addr = block * inftl->EraseSize;\r\ninstr->len = inftl->mbd.mtd->erasesize;\r\nfor (physblock = 0; physblock < inftl->EraseSize;\r\nphysblock += instr->len, instr->addr += instr->len) {\r\nmtd->erase(inftl->mbd.mtd, instr);\r\nif (instr->state == MTD_ERASE_FAILED) {\r\nprintk(KERN_WARNING "INFTL: error while formatting block %d\n",\r\nblock);\r\ngoto fail;\r\n}\r\nif (check_free_sectors(inftl, instr->addr, instr->len, 1) != 0)\r\ngoto fail;\r\n}\r\nuci.EraseMark = cpu_to_le16(ERASE_MARK);\r\nuci.EraseMark1 = cpu_to_le16(ERASE_MARK);\r\nuci.Reserved[0] = 0;\r\nuci.Reserved[1] = 0;\r\nuci.Reserved[2] = 0;\r\nuci.Reserved[3] = 0;\r\ninstr->addr = block * inftl->EraseSize + SECTORSIZE * 2;\r\nif (inftl_write_oob(mtd, instr->addr + 8, 8, &retlen, (char *)&uci) < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\ninftl->mbd.mtd->block_markbad(inftl->mbd.mtd, instr->addr);\r\nreturn -1;\r\n}\r\nstatic void format_chain(struct INFTLrecord *inftl, unsigned int first_block)\r\n{\r\nunsigned int block = first_block, block1;\r\nprintk(KERN_WARNING "INFTL: formatting chain at block %d\n",\r\nfirst_block);\r\nfor (;;) {\r\nblock1 = inftl->PUtable[block];\r\nprintk(KERN_WARNING "INFTL: formatting block %d\n", block);\r\nif (INFTL_formatblock(inftl, block) < 0) {\r\ninftl->PUtable[block] = BLOCK_RESERVED;\r\n} else {\r\ninftl->PUtable[block] = BLOCK_FREE;\r\n}\r\nblock = block1;\r\nif (block == BLOCK_NIL || block >= inftl->lastEUN)\r\nbreak;\r\n}\r\n}\r\nvoid INFTL_dumptables(struct INFTLrecord *s)\r\n{\r\nint i;\r\nprintk("-------------------------------------------"\r\n"----------------------------------\n");\r\nprintk("VUtable[%d] ->", s->nb_blocks);\r\nfor (i = 0; i < s->nb_blocks; i++) {\r\nif ((i % 8) == 0)\r\nprintk("\n%04x: ", i);\r\nprintk("%04x ", s->VUtable[i]);\r\n}\r\nprintk("\n-------------------------------------------"\r\n"----------------------------------\n");\r\nprintk("PUtable[%d-%d=%d] ->", s->firstEUN, s->lastEUN, s->nb_blocks);\r\nfor (i = 0; i <= s->lastEUN; i++) {\r\nif ((i % 8) == 0)\r\nprintk("\n%04x: ", i);\r\nprintk("%04x ", s->PUtable[i]);\r\n}\r\nprintk("\n-------------------------------------------"\r\n"----------------------------------\n");\r\nprintk("INFTL ->\n"\r\n" EraseSize = %d\n"\r\n" h/s/c = %d/%d/%d\n"\r\n" numvunits = %d\n"\r\n" firstEUN = %d\n"\r\n" lastEUN = %d\n"\r\n" numfreeEUNs = %d\n"\r\n" LastFreeEUN = %d\n"\r\n" nb_blocks = %d\n"\r\n" nb_boot_blocks = %d",\r\ns->EraseSize, s->heads, s->sectors, s->cylinders,\r\ns->numvunits, s->firstEUN, s->lastEUN, s->numfreeEUNs,\r\ns->LastFreeEUN, s->nb_blocks, s->nb_boot_blocks);\r\nprintk("\n-------------------------------------------"\r\n"----------------------------------\n");\r\n}\r\nvoid INFTL_dumpVUchains(struct INFTLrecord *s)\r\n{\r\nint logical, block, i;\r\nprintk("-------------------------------------------"\r\n"----------------------------------\n");\r\nprintk("INFTL Virtual Unit Chains:\n");\r\nfor (logical = 0; logical < s->nb_blocks; logical++) {\r\nblock = s->VUtable[logical];\r\nif (block > s->nb_blocks)\r\ncontinue;\r\nprintk(" LOGICAL %d --> %d ", logical, block);\r\nfor (i = 0; i < s->nb_blocks; i++) {\r\nif (s->PUtable[block] == BLOCK_NIL)\r\nbreak;\r\nblock = s->PUtable[block];\r\nprintk("%d ", block);\r\n}\r\nprintk("\n");\r\n}\r\nprintk("-------------------------------------------"\r\n"----------------------------------\n");\r\n}\r\nint INFTL_mount(struct INFTLrecord *s)\r\n{\r\nstruct mtd_info *mtd = s->mbd.mtd;\r\nunsigned int block, first_block, prev_block, last_block;\r\nunsigned int first_logical_block, logical_block, erase_mark;\r\nint chain_length, do_format_chain;\r\nstruct inftl_unithead1 h0;\r\nstruct inftl_unittail h1;\r\nsize_t retlen;\r\nint i;\r\nu8 *ANACtable, ANAC;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: INFTL_mount(inftl=%p)\n", s);\r\nif (find_boot_record(s) < 0) {\r\nprintk(KERN_WARNING "INFTL: could not find valid boot record?\n");\r\nreturn -ENXIO;\r\n}\r\nfor (i = 0; i < s->nb_blocks; i++)\r\ns->VUtable[i] = BLOCK_NIL;\r\nlogical_block = block = BLOCK_NIL;\r\nANACtable = kcalloc(s->nb_blocks, sizeof(u8), GFP_KERNEL);\r\nif (!ANACtable) {\r\nprintk(KERN_WARNING "INFTL: allocation of ANACtable "\r\n"failed (%zd bytes)\n",\r\ns->nb_blocks * sizeof(u8));\r\nreturn -ENOMEM;\r\n}\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: pass 1, explore each unit\n");\r\nfor (first_block = s->firstEUN; first_block <= s->lastEUN; first_block++) {\r\nif (s->PUtable[first_block] != BLOCK_NOTEXPLORED)\r\ncontinue;\r\ndo_format_chain = 0;\r\nfirst_logical_block = BLOCK_NIL;\r\nlast_block = BLOCK_NIL;\r\nblock = first_block;\r\nfor (chain_length = 0; ; chain_length++) {\r\nif ((chain_length == 0) &&\r\n(s->PUtable[block] != BLOCK_NOTEXPLORED)) {\r\nbreak;\r\n}\r\nif (inftl_read_oob(mtd, block * s->EraseSize + 8,\r\n8, &retlen, (char *)&h0) < 0 ||\r\ninftl_read_oob(mtd, block * s->EraseSize +\r\n2 * SECTORSIZE + 8, 8, &retlen,\r\n(char *)&h1) < 0) {\r\ndo_format_chain++;\r\nbreak;\r\n}\r\nlogical_block = le16_to_cpu(h0.virtualUnitNo);\r\nprev_block = le16_to_cpu(h0.prevUnitNo);\r\nerase_mark = le16_to_cpu((h1.EraseMark | h1.EraseMark1));\r\nANACtable[block] = h0.ANAC;\r\nif (prev_block < s->nb_blocks)\r\nprev_block += s->firstEUN;\r\nif (s->PUtable[block] != BLOCK_NOTEXPLORED) {\r\nif (logical_block == first_logical_block) {\r\nif (last_block != BLOCK_NIL)\r\ns->PUtable[last_block] = block;\r\n}\r\nbreak;\r\n}\r\nif (erase_mark != ERASE_MARK) {\r\nprintk(KERN_WARNING "INFTL: corrupt block %d "\r\n"in chain %d, chain length %d, erase "\r\n"mark 0x%x?\n", block, first_block,\r\nchain_length, erase_mark);\r\nif (chain_length == 0)\r\ndo_format_chain++;\r\nbreak;\r\n}\r\nif ((logical_block == BLOCK_FREE) ||\r\n(logical_block == BLOCK_NIL)) {\r\ns->PUtable[block] = BLOCK_FREE;\r\nbreak;\r\n}\r\nif ((logical_block >= s->nb_blocks) ||\r\n((prev_block >= s->nb_blocks) &&\r\n(prev_block != BLOCK_NIL))) {\r\nif (chain_length > 0) {\r\nprintk(KERN_WARNING "INFTL: corrupt "\r\n"block %d in chain %d?\n",\r\nblock, first_block);\r\ndo_format_chain++;\r\n}\r\nbreak;\r\n}\r\nif (first_logical_block == BLOCK_NIL) {\r\nfirst_logical_block = logical_block;\r\n} else {\r\nif (first_logical_block != logical_block) {\r\nbreak;\r\n}\r\n}\r\ns->PUtable[block] = BLOCK_NIL;\r\nif (last_block != BLOCK_NIL)\r\ns->PUtable[last_block] = block;\r\nlast_block = block;\r\nblock = prev_block;\r\nif (block == BLOCK_NIL)\r\nbreak;\r\nif (block > s->lastEUN) {\r\nprintk(KERN_WARNING "INFTL: invalid previous "\r\n"block %d in chain %d?\n", block,\r\nfirst_block);\r\ndo_format_chain++;\r\nbreak;\r\n}\r\n}\r\nif (do_format_chain) {\r\nformat_chain(s, first_block);\r\ncontinue;\r\n}\r\ns->VUtable[first_logical_block] = first_block;\r\nlogical_block = BLOCK_NIL;\r\n}\r\n#ifdef CONFIG_MTD_DEBUG_VERBOSE\r\nif (CONFIG_MTD_DEBUG_VERBOSE >= 2)\r\nINFTL_dumptables(s);\r\n#endif\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: pass 2, validate virtual chains\n");\r\nfor (logical_block = 0; logical_block < s->numvunits; logical_block++) {\r\nblock = s->VUtable[logical_block];\r\nlast_block = BLOCK_NIL;\r\nif (block >= BLOCK_RESERVED)\r\ncontinue;\r\nANAC = ANACtable[block];\r\nfor (i = 0; i < s->numvunits; i++) {\r\nif (s->PUtable[block] == BLOCK_NIL)\r\nbreak;\r\nif (s->PUtable[block] > s->lastEUN) {\r\nprintk(KERN_WARNING "INFTL: invalid prev %d, "\r\n"in virtual chain %d\n",\r\ns->PUtable[block], logical_block);\r\ns->PUtable[block] = BLOCK_NIL;\r\n}\r\nif (ANACtable[block] != ANAC) {\r\ns->VUtable[logical_block] = block;\r\ns->PUtable[last_block] = BLOCK_NIL;\r\nbreak;\r\n}\r\nANAC--;\r\nlast_block = block;\r\nblock = s->PUtable[block];\r\n}\r\nif (i >= s->nb_blocks) {\r\nformat_chain(s, first_block);\r\n}\r\n}\r\n#ifdef CONFIG_MTD_DEBUG_VERBOSE\r\nif (CONFIG_MTD_DEBUG_VERBOSE >= 2)\r\nINFTL_dumptables(s);\r\nif (CONFIG_MTD_DEBUG_VERBOSE >= 2)\r\nINFTL_dumpVUchains(s);\r\n#endif\r\ns->numfreeEUNs = 0;\r\ns->LastFreeEUN = BLOCK_NIL;\r\nDEBUG(MTD_DEBUG_LEVEL3, "INFTL: pass 3, format unused blocks\n");\r\nfor (block = s->firstEUN; block <= s->lastEUN; block++) {\r\nif (s->PUtable[block] == BLOCK_NOTEXPLORED) {\r\nprintk("INFTL: unreferenced block %d, formatting it\n",\r\nblock);\r\nif (INFTL_formatblock(s, block) < 0)\r\ns->PUtable[block] = BLOCK_RESERVED;\r\nelse\r\ns->PUtable[block] = BLOCK_FREE;\r\n}\r\nif (s->PUtable[block] == BLOCK_FREE) {\r\ns->numfreeEUNs++;\r\nif (s->LastFreeEUN == BLOCK_NIL)\r\ns->LastFreeEUN = block;\r\n}\r\n}\r\nkfree(ANACtable);\r\nreturn 0;\r\n}
