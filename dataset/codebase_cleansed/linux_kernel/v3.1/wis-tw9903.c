static int write_reg(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int write_regs(struct i2c_client *client, u8 *regs)\r\n{\r\nint i;\r\nfor (i = 0; regs[i] != 0x00; i += 2)\r\nif (i2c_smbus_write_byte_data(client, regs[i], regs[i + 1]) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int wis_tw9903_command(struct i2c_client *client,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct wis_tw9903 *dec = i2c_get_clientdata(client);\r\nswitch (cmd) {\r\ncase VIDIOC_S_INPUT:\r\n{\r\nint *input = arg;\r\ni2c_smbus_write_byte_data(client, 0x02, 0x40 | (*input << 1));\r\nbreak;\r\n}\r\n#if 0\r\ncase DECODER_SET_RESOLUTION:\r\n{\r\nstruct video_decoder_resolution *res = arg;\r\nint hscale = 256 * 720 / (res->width - (res->width > 704 ? 0 : 8));\r\nint vscale = 256 * (dec->norm & V4L2_STD_NTSC ? 240 : 288)\r\n/ res->height;\r\nu8 regs[] = {\r\n0x0d, vscale & 0xff,\r\n0x0f, hscale & 0xff,\r\n0x0e, ((vscale & 0xf00) >> 4) | ((hscale & 0xf00) >> 8),\r\n0x06, 0xc0,\r\n0, 0,\r\n};\r\nprintk(KERN_DEBUG "vscale is %04x, hscale is %04x\n",\r\nvscale, hscale);\r\nbreak;\r\n}\r\n#endif\r\ncase VIDIOC_S_STD:\r\n{\r\nv4l2_std_id *input = arg;\r\nu8 regs[] = {\r\n0x05, *input & V4L2_STD_NTSC ? 0x80 : 0x00,\r\n0x07, *input & V4L2_STD_NTSC ? 0x02 : 0x12,\r\n0x08, *input & V4L2_STD_NTSC ? 0x14 : 0x18,\r\n0x09, *input & V4L2_STD_NTSC ? 0xf0 : 0x20,\r\n0, 0,\r\n};\r\nwrite_regs(client, regs);\r\ndec->norm = *input;\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYCTRL:\r\n{\r\nstruct v4l2_queryctrl *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Brightness", sizeof(ctrl->name));\r\nctrl->minimum = -128;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 0x00;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Contrast", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 255;\r\nctrl->step = 1;\r\nctrl->default_value = 0x60;\r\nctrl->flags = 0;\r\nbreak;\r\n#if 0\r\ncase V4L2_CID_SATURATION:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Saturation", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 64;\r\nctrl->flags = 0;\r\nbreak;\r\n#endif\r\ncase V4L2_CID_HUE:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Hue", sizeof(ctrl->name));\r\nctrl->minimum = -128;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 0;\r\nctrl->flags = 0;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nif (ctrl->value > 127)\r\ndec->brightness = 127;\r\nelse if (ctrl->value < -128)\r\ndec->brightness = -128;\r\nelse\r\ndec->brightness = ctrl->value;\r\nwrite_reg(client, 0x10, dec->brightness);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nif (ctrl->value > 255)\r\ndec->contrast = 255;\r\nelse if (ctrl->value < 0)\r\ndec->contrast = 0;\r\nelse\r\ndec->contrast = ctrl->value;\r\nwrite_reg(client, 0x11, dec->contrast);\r\nbreak;\r\n#if 0\r\ncase V4L2_CID_SATURATION:\r\nif (ctrl->value > 127)\r\ndec->saturation = 127;\r\nelse if (ctrl->value < 0)\r\ndec->saturation = 0;\r\nelse\r\ndec->saturation = ctrl->value;\r\nbreak;\r\n#endif\r\ncase V4L2_CID_HUE:\r\nif (ctrl->value > 127)\r\ndec->hue = 127;\r\nelse if (ctrl->value < -128)\r\ndec->hue = -128;\r\nelse\r\ndec->hue = ctrl->value;\r\nwrite_reg(client, 0x15, dec->hue);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->value = dec->brightness;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->value = dec->contrast;\r\nbreak;\r\n#if 0\r\ncase V4L2_CID_SATURATION:\r\nctrl->value = dec->saturation;\r\nbreak;\r\n#endif\r\ncase V4L2_CID_HUE:\r\nctrl->value = dec->hue;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wis_tw9903_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct wis_tw9903 *dec;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ndec = kmalloc(sizeof(struct wis_tw9903), GFP_KERNEL);\r\nif (dec == NULL)\r\nreturn -ENOMEM;\r\ndec->norm = V4L2_STD_NTSC;\r\ndec->brightness = 0;\r\ndec->contrast = 0x60;\r\ndec->hue = 0;\r\ni2c_set_clientdata(client, dec);\r\nprintk(KERN_DEBUG\r\n"wis-tw9903: initializing TW9903 at address %d on %s\n",\r\nclient->addr, adapter->name);\r\nif (write_regs(client, initial_registers) < 0) {\r\nprintk(KERN_ERR "wis-tw9903: error initializing TW9903\n");\r\nkfree(dec);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wis_tw9903_remove(struct i2c_client *client)\r\n{\r\nstruct wis_tw9903 *dec = i2c_get_clientdata(client);\r\nkfree(dec);\r\nreturn 0;\r\n}\r\nstatic int __init wis_tw9903_init(void)\r\n{\r\nreturn i2c_add_driver(&wis_tw9903_driver);\r\n}\r\nstatic void __exit wis_tw9903_cleanup(void)\r\n{\r\ni2c_del_driver(&wis_tw9903_driver);\r\n}
