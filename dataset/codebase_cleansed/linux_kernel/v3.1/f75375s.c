static inline int f75375_read8(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic inline u16 f75375_read16(struct i2c_client *client, u8 reg)\r\n{\r\nreturn ((i2c_smbus_read_byte_data(client, reg) << 8)\r\n| i2c_smbus_read_byte_data(client, reg + 1));\r\n}\r\nstatic inline void f75375_write8(struct i2c_client *client, u8 reg,\r\nu8 value)\r\n{\r\ni2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic inline void f75375_write16(struct i2c_client *client, u8 reg,\r\nu16 value)\r\n{\r\nint err = i2c_smbus_write_byte_data(client, reg, (value << 8));\r\nif (err)\r\nreturn;\r\ni2c_smbus_write_byte_data(client, reg + 1, (value & 0xFF));\r\n}\r\nstatic struct f75375_data *f75375_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint nr;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_limits + 60 * HZ)\r\n|| !data->valid) {\r\nfor (nr = 0; nr < 2; nr++) {\r\ndata->temp_high[nr] =\r\nf75375_read8(client, F75375_REG_TEMP_HIGH(nr));\r\ndata->temp_max_hyst[nr] =\r\nf75375_read8(client, F75375_REG_TEMP_HYST(nr));\r\ndata->fan_full[nr] =\r\nf75375_read16(client, F75375_REG_FAN_FULL(nr));\r\ndata->fan_min[nr] =\r\nf75375_read16(client, F75375_REG_FAN_MIN(nr));\r\ndata->fan_exp[nr] =\r\nf75375_read16(client, F75375_REG_FAN_EXP(nr));\r\ndata->pwm[nr] = f75375_read8(client,\r\nF75375_REG_FAN_PWM_DUTY(nr));\r\n}\r\nfor (nr = 0; nr < 4; nr++) {\r\ndata->in_max[nr] =\r\nf75375_read8(client, F75375_REG_VOLT_HIGH(nr));\r\ndata->in_min[nr] =\r\nf75375_read8(client, F75375_REG_VOLT_LOW(nr));\r\n}\r\ndata->fan_timer = f75375_read8(client, F75375_REG_FAN_TIMER);\r\ndata->last_limits = jiffies;\r\n}\r\nif (time_after(jiffies, data->last_updated + 2 * HZ)\r\n|| !data->valid) {\r\nfor (nr = 0; nr < 2; nr++) {\r\ndata->temp[nr] =\r\nf75375_read8(client, F75375_REG_TEMP(nr));\r\ndata->fan[nr] =\r\nf75375_read16(client, F75375_REG_FAN(nr));\r\n}\r\nfor (nr = 0; nr < 4; nr++)\r\ndata->in[nr] =\r\nf75375_read8(client, F75375_REG_VOLT(nr));\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic inline u16 rpm_from_reg(u16 reg)\r\n{\r\nif (reg == 0 || reg == 0xffff)\r\nreturn 0;\r\nreturn (1500000 / reg);\r\n}\r\nstatic inline u16 rpm_to_reg(int rpm)\r\n{\r\nif (rpm < 367 || rpm > 0xffff)\r\nreturn 0xffff;\r\nreturn (1500000 / rpm);\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = rpm_to_reg(val);\r\nf75375_write16(client, F75375_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_fan_exp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_exp[nr] = rpm_to_reg(val);\r\nf75375_write16(client, F75375_REG_FAN_EXP(nr), data->fan_exp[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = SENSORS_LIMIT(val, 0, 255);\r\nf75375_write8(client, F75375_REG_FAN_PWM_DUTY(nr), data->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev, struct device_attribute\r\n*attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_enable[nr]);\r\n}\r\nstatic int set_pwm_enable_direct(struct i2c_client *client, int nr, int val)\r\n{\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nu8 fanmode;\r\nif (val < 0 || val > 4)\r\nreturn -EINVAL;\r\nfanmode = f75375_read8(client, F75375_REG_FAN_TIMER);\r\nfanmode &= ~(3 << FAN_CTRL_MODE(nr));\r\nswitch (val) {\r\ncase 0:\r\nfanmode |= (3 << FAN_CTRL_MODE(nr));\r\ndata->pwm[nr] = 255;\r\nf75375_write8(client, F75375_REG_FAN_PWM_DUTY(nr),\r\ndata->pwm[nr]);\r\nbreak;\r\ncase 1:\r\nfanmode |= (3 << FAN_CTRL_MODE(nr));\r\nbreak;\r\ncase 2:\r\nfanmode |= (2 << FAN_CTRL_MODE(nr));\r\nbreak;\r\ncase 3:\r\nbreak;\r\n}\r\nf75375_write8(client, F75375_REG_FAN_TIMER, fanmode);\r\ndata->pwm_enable[nr] = val;\r\nreturn 0;\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtoul(buf, NULL, 10);\r\nint err = 0;\r\nmutex_lock(&data->update_lock);\r\nerr = set_pwm_enable_direct(client, nr, val);\r\nmutex_unlock(&data->update_lock);\r\nreturn err ? err : count;\r\n}\r\nstatic ssize_t set_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtoul(buf, NULL, 10);\r\nu8 conf = 0;\r\nif (!(val == 0 || val == 1))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nconf = f75375_read8(client, F75375_REG_CONFIG1);\r\nconf &= ~(1 << FAN_CTRL_LINEAR(nr));\r\nif (val == 0)\r\nconf |= (1 << FAN_CTRL_LINEAR(nr)) ;\r\nf75375_write8(client, F75375_REG_CONFIG1, conf);\r\ndata->pwm_mode[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute\r\n*attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm[nr]);\r\n}\r\nstatic ssize_t show_pwm_mode(struct device *dev, struct device_attribute\r\n*attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_mode[nr]);\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", VOLT_FROM_REG(data->in[nr]));\r\n}\r\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", VOLT_FROM_REG(data->in_max[nr]));\r\n}\r\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", VOLT_FROM_REG(data->in_min[nr]));\r\n}\r\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtoul(buf, NULL, 10);\r\nval = SENSORS_LIMIT(VOLT_TO_REG(val), 0, 0xff);\r\nmutex_lock(&data->update_lock);\r\ndata->in_max[nr] = val;\r\nf75375_write8(client, F75375_REG_VOLT_HIGH(nr), data->in_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtoul(buf, NULL, 10);\r\nval = SENSORS_LIMIT(VOLT_TO_REG(val), 0, 0xff);\r\nmutex_lock(&data->update_lock);\r\ndata->in_min[nr] = val;\r\nf75375_write8(client, F75375_REG_VOLT_LOW(nr), data->in_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp[nr]));\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_high[nr]));\r\n}\r\nstatic ssize_t show_temp_max_hyst(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_max_hyst[nr]));\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtol(buf, NULL, 10);\r\nval = SENSORS_LIMIT(TEMP_TO_REG(val), 0, 127);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_high[nr] = val;\r\nf75375_write8(client, F75375_REG_TEMP_HIGH(nr), data->temp_high[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_temp_max_hyst(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint val = simple_strtol(buf, NULL, 10);\r\nval = SENSORS_LIMIT(TEMP_TO_REG(val), 0, 127);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max_hyst[nr] = val;\r\nf75375_write8(client, F75375_REG_TEMP_HYST(nr),\r\ndata->temp_max_hyst[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic void f75375_init(struct i2c_client *client, struct f75375_data *data,\r\nstruct f75375s_platform_data *f75375s_pdata)\r\n{\r\nint nr;\r\nset_pwm_enable_direct(client, 0, f75375s_pdata->pwm_enable[0]);\r\nset_pwm_enable_direct(client, 1, f75375s_pdata->pwm_enable[1]);\r\nfor (nr = 0; nr < 2; nr++) {\r\ndata->pwm[nr] = SENSORS_LIMIT(f75375s_pdata->pwm[nr], 0, 255);\r\nf75375_write8(client, F75375_REG_FAN_PWM_DUTY(nr),\r\ndata->pwm[nr]);\r\n}\r\n}\r\nstatic int f75375_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct f75375_data *data;\r\nstruct f75375s_platform_data *f75375s_pdata = client->dev.platform_data;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nif (!(data = kzalloc(sizeof(struct f75375_data), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->kind = id->driver_data;\r\nif ((err = sysfs_create_group(&client->dev.kobj, &f75375_group)))\r\ngoto exit_free;\r\nif (data->kind == f75375) {\r\nerr = sysfs_chmod_file(&client->dev.kobj,\r\n&sensor_dev_attr_pwm1_mode.dev_attr.attr,\r\nS_IRUGO | S_IWUSR);\r\nif (err)\r\ngoto exit_remove;\r\nerr = sysfs_chmod_file(&client->dev.kobj,\r\n&sensor_dev_attr_pwm2_mode.dev_attr.attr,\r\nS_IRUGO | S_IWUSR);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nif (f75375s_pdata != NULL)\r\nf75375_init(client, data, f75375s_pdata);\r\nreturn 0;\r\nexit_remove:\r\nsysfs_remove_group(&client->dev.kobj, &f75375_group);\r\nexit_free:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int f75375_remove(struct i2c_client *client)\r\n{\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &f75375_group);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int f75375_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nu16 vendid, chipid;\r\nu8 version;\r\nconst char *name;\r\nvendid = f75375_read16(client, F75375_REG_VENDOR);\r\nchipid = f75375_read16(client, F75375_CHIP_ID);\r\nif (chipid == 0x0306 && vendid == 0x1934)\r\nname = "f75375";\r\nelse if (chipid == 0x0204 && vendid == 0x1934)\r\nname = "f75373";\r\nelse\r\nreturn -ENODEV;\r\nversion = f75375_read8(client, F75375_REG_VERSION);\r\ndev_info(&adapter->dev, "found %s version: %02X\n", name, version);\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int __init sensors_f75375_init(void)\r\n{\r\nreturn i2c_add_driver(&f75375_driver);\r\n}\r\nstatic void __exit sensors_f75375_exit(void)\r\n{\r\ni2c_del_driver(&f75375_driver);\r\n}
