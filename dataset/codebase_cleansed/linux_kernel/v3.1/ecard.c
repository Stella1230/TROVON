static inline unsigned short ecard_getu16(unsigned char *v)\r\n{\r\nreturn v[0] | v[1] << 8;\r\n}\r\nstatic inline signed long ecard_gets24(unsigned char *v)\r\n{\r\nreturn v[0] | v[1] << 8 | v[2] << 16 | ((v[2] & 0x80) ? 0xff000000 : 0);\r\n}\r\nstatic inline ecard_t *slot_to_ecard(unsigned int slot)\r\n{\r\nreturn slot < MAX_ECARDS ? slot_to_expcard[slot] : NULL;\r\n}\r\nstatic void ecard_task_reset(struct ecard_request *req)\r\n{\r\nstruct expansion_card *ec = req->ec;\r\nstruct resource *res;\r\nres = ec->slot_no == 8\r\n? &ec->resource[ECARD_RES_MEMC]\r\n: ec->easi\r\n? &ec->resource[ECARD_RES_EASI]\r\n: &ec->resource[ECARD_RES_IOCSYNC];\r\necard_loader_reset(res->start, ec->loader);\r\n}\r\nstatic void ecard_task_readbytes(struct ecard_request *req)\r\n{\r\nstruct expansion_card *ec = req->ec;\r\nunsigned char *buf = req->buffer;\r\nunsigned int len = req->length;\r\nunsigned int off = req->address;\r\nif (ec->slot_no == 8) {\r\nvoid __iomem *base = (void __iomem *)\r\nec->resource[ECARD_RES_MEMC].start;\r\nstatic unsigned int index;\r\nunsigned int page;\r\npage = (off >> 12) * 4;\r\nif (page > 256 * 4)\r\nreturn;\r\noff &= 4095;\r\nif (off == 0 || index > off) {\r\nwriteb(0, base);\r\nindex = 0;\r\n}\r\nwhile (index < off) {\r\nreadb(base + page);\r\nindex += 1;\r\n}\r\nwhile (len--) {\r\n*buf++ = readb(base + page);\r\nindex += 1;\r\n}\r\n} else {\r\nunsigned long base = (ec->easi\r\n? &ec->resource[ECARD_RES_EASI]\r\n: &ec->resource[ECARD_RES_IOCSYNC])->start;\r\nvoid __iomem *pbase = (void __iomem *)base;\r\nif (!req->use_loader || !ec->loader) {\r\noff *= 4;\r\nwhile (len--) {\r\n*buf++ = readb(pbase + off);\r\noff += 4;\r\n}\r\n} else {\r\nwhile(len--) {\r\n*(unsigned long *)0x108 = 0;\r\n*buf++ = ecard_loader_read(off++, base,\r\nec->loader);\r\n}\r\n}\r\n}\r\n}\r\nstatic void ecard_init_pgtables(struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct vma;\r\npgd_t *src_pgd, *dst_pgd;\r\nsrc_pgd = pgd_offset(mm, (unsigned long)IO_BASE);\r\ndst_pgd = pgd_offset(mm, IO_START);\r\nmemcpy(dst_pgd, src_pgd, sizeof(pgd_t) * (IO_SIZE / PGDIR_SIZE));\r\nsrc_pgd = pgd_offset(mm, EASI_BASE);\r\ndst_pgd = pgd_offset(mm, EASI_START);\r\nmemcpy(dst_pgd, src_pgd, sizeof(pgd_t) * (EASI_SIZE / PGDIR_SIZE));\r\nvma.vm_mm = mm;\r\nflush_tlb_range(&vma, IO_START, IO_START + IO_SIZE);\r\nflush_tlb_range(&vma, EASI_START, EASI_START + EASI_SIZE);\r\n}\r\nstatic int ecard_init_mm(void)\r\n{\r\nstruct mm_struct * mm = mm_alloc();\r\nstruct mm_struct *active_mm = current->active_mm;\r\nif (!mm)\r\nreturn -ENOMEM;\r\ncurrent->mm = mm;\r\ncurrent->active_mm = mm;\r\nactivate_mm(active_mm, mm);\r\nmmdrop(active_mm);\r\necard_init_pgtables(mm);\r\nreturn 0;\r\n}\r\nstatic int\r\necard_task(void * unused)\r\n{\r\nif (ecard_init_mm())\r\npanic("kecardd: unable to alloc mm\n");\r\nwhile (1) {\r\nstruct ecard_request *req;\r\nwait_event_interruptible(ecard_wait, ecard_req != NULL);\r\nreq = xchg(&ecard_req, NULL);\r\nif (req != NULL) {\r\nreq->fn(req);\r\ncomplete(req->complete);\r\n}\r\n}\r\n}\r\nstatic void ecard_call(struct ecard_request *req)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nreq->complete = &completion;\r\nmutex_lock(&ecard_mutex);\r\necard_req = req;\r\nwake_up(&ecard_wait);\r\nwait_for_completion(&completion);\r\nmutex_unlock(&ecard_mutex);\r\n}\r\nstatic void\r\necard_readbytes(void *addr, ecard_t *ec, int off, int len, int useld)\r\n{\r\nstruct ecard_request req;\r\nreq.fn = ecard_task_readbytes;\r\nreq.ec = ec;\r\nreq.address = off;\r\nreq.length = len;\r\nreq.use_loader = useld;\r\nreq.buffer = addr;\r\necard_call(&req);\r\n}\r\nint ecard_readchunk(struct in_chunk_dir *cd, ecard_t *ec, int id, int num)\r\n{\r\nstruct ex_chunk_dir excd;\r\nint index = 16;\r\nint useld = 0;\r\nif (!ec->cid.cd)\r\nreturn 0;\r\nwhile(1) {\r\necard_readbytes(&excd, ec, index, 8, useld);\r\nindex += 8;\r\nif (c_id(&excd) == 0) {\r\nif (!useld && ec->loader) {\r\nuseld = 1;\r\nindex = 0;\r\ncontinue;\r\n}\r\nreturn 0;\r\n}\r\nif (c_id(&excd) == 0xf0) {\r\nindex = c_start(&excd);\r\ncontinue;\r\n}\r\nif (c_id(&excd) == 0x80) {\r\nif (!ec->loader) {\r\nec->loader = kmalloc(c_len(&excd),\r\nGFP_KERNEL);\r\nif (ec->loader)\r\necard_readbytes(ec->loader, ec,\r\n(int)c_start(&excd),\r\nc_len(&excd), useld);\r\nelse\r\nreturn 0;\r\n}\r\ncontinue;\r\n}\r\nif (c_id(&excd) == id && num-- == 0)\r\nbreak;\r\n}\r\nif (c_id(&excd) & 0x80) {\r\nswitch (c_id(&excd) & 0x70) {\r\ncase 0x70:\r\necard_readbytes((unsigned char *)excd.d.string, ec,\r\n(int)c_start(&excd), c_len(&excd),\r\nuseld);\r\nbreak;\r\ncase 0x00:\r\nbreak;\r\n}\r\n}\r\ncd->start_offset = c_start(&excd);\r\nmemcpy(cd->d.string, excd.d.string, 256);\r\nreturn 1;\r\n}\r\nstatic void ecard_def_irq_enable(ecard_t *ec, int irqnr)\r\n{\r\n#ifdef HAS_EXPMASK\r\nif (irqnr < 4 && have_expmask) {\r\nhave_expmask |= 1 << irqnr;\r\n__raw_writeb(have_expmask, EXPMASK_ENABLE);\r\n}\r\n#endif\r\n}\r\nstatic void ecard_def_irq_disable(ecard_t *ec, int irqnr)\r\n{\r\n#ifdef HAS_EXPMASK\r\nif (irqnr < 4 && have_expmask) {\r\nhave_expmask &= ~(1 << irqnr);\r\n__raw_writeb(have_expmask, EXPMASK_ENABLE);\r\n}\r\n#endif\r\n}\r\nstatic int ecard_def_irq_pending(ecard_t *ec)\r\n{\r\nreturn !ec->irqmask || readb(ec->irqaddr) & ec->irqmask;\r\n}\r\nstatic void ecard_def_fiq_enable(ecard_t *ec, int fiqnr)\r\n{\r\npanic("ecard_def_fiq_enable called - impossible");\r\n}\r\nstatic void ecard_def_fiq_disable(ecard_t *ec, int fiqnr)\r\n{\r\npanic("ecard_def_fiq_disable called - impossible");\r\n}\r\nstatic int ecard_def_fiq_pending(ecard_t *ec)\r\n{\r\nreturn !ec->fiqmask || readb(ec->fiqaddr) & ec->fiqmask;\r\n}\r\nstatic void ecard_irq_unmask(struct irq_data *d)\r\n{\r\necard_t *ec = slot_to_ecard(d->irq - 32);\r\nif (ec) {\r\nif (!ec->ops)\r\nec->ops = &ecard_default_ops;\r\nif (ec->claimed && ec->ops->irqenable)\r\nec->ops->irqenable(ec, d->irq);\r\nelse\r\nprintk(KERN_ERR "ecard: rejecting request to "\r\n"enable IRQs for %d\n", d->irq);\r\n}\r\n}\r\nstatic void ecard_irq_mask(struct irq_data *d)\r\n{\r\necard_t *ec = slot_to_ecard(d->irq - 32);\r\nif (ec) {\r\nif (!ec->ops)\r\nec->ops = &ecard_default_ops;\r\nif (ec->ops && ec->ops->irqdisable)\r\nec->ops->irqdisable(ec, d->irq);\r\n}\r\n}\r\nvoid ecard_enablefiq(unsigned int fiqnr)\r\n{\r\necard_t *ec = slot_to_ecard(fiqnr);\r\nif (ec) {\r\nif (!ec->ops)\r\nec->ops = &ecard_default_ops;\r\nif (ec->claimed && ec->ops->fiqenable)\r\nec->ops->fiqenable(ec, fiqnr);\r\nelse\r\nprintk(KERN_ERR "ecard: rejecting request to "\r\n"enable FIQs for %d\n", fiqnr);\r\n}\r\n}\r\nvoid ecard_disablefiq(unsigned int fiqnr)\r\n{\r\necard_t *ec = slot_to_ecard(fiqnr);\r\nif (ec) {\r\nif (!ec->ops)\r\nec->ops = &ecard_default_ops;\r\nif (ec->ops->fiqdisable)\r\nec->ops->fiqdisable(ec, fiqnr);\r\n}\r\n}\r\nstatic void ecard_dump_irq_state(void)\r\n{\r\necard_t *ec;\r\nprintk("Expansion card IRQ state:\n");\r\nfor (ec = cards; ec; ec = ec->next) {\r\nif (ec->slot_no == 8)\r\ncontinue;\r\nprintk(" %d: %sclaimed, ",\r\nec->slot_no, ec->claimed ? "" : "not ");\r\nif (ec->ops && ec->ops->irqpending &&\r\nec->ops != &ecard_default_ops)\r\nprintk("irq %spending\n",\r\nec->ops->irqpending(ec) ? "" : "not ");\r\nelse\r\nprintk("irqaddr %p, mask = %02X, status = %02X\n",\r\nec->irqaddr, ec->irqmask, readb(ec->irqaddr));\r\n}\r\n}\r\nstatic void ecard_check_lockup(struct irq_desc *desc)\r\n{\r\nstatic unsigned long last;\r\nstatic int lockup;\r\nif (last == jiffies) {\r\nlockup += 1;\r\nif (lockup > 1000000) {\r\nprintk(KERN_ERR "\nInterrupt lockup detected - "\r\n"disabling all expansion card interrupts\n");\r\ndesc->irq_data.chip->irq_mask(&desc->irq_data);\r\necard_dump_irq_state();\r\n}\r\n} else\r\nlockup = 0;\r\nif (!last || time_after(jiffies, last + 5*HZ)) {\r\nlast = jiffies;\r\nprintk(KERN_WARNING "Unrecognised interrupt from backplane\n");\r\necard_dump_irq_state();\r\n}\r\n}\r\nstatic void\r\necard_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\necard_t *ec;\r\nint called = 0;\r\ndesc->irq_data.chip->irq_mask(&desc->irq_data);\r\nfor (ec = cards; ec; ec = ec->next) {\r\nint pending;\r\nif (!ec->claimed || ec->irq == NO_IRQ || ec->slot_no == 8)\r\ncontinue;\r\nif (ec->ops && ec->ops->irqpending)\r\npending = ec->ops->irqpending(ec);\r\nelse\r\npending = ecard_default_ops.irqpending(ec);\r\nif (pending) {\r\ngeneric_handle_irq(ec->irq);\r\ncalled ++;\r\n}\r\n}\r\ndesc->irq_data.chip->irq_unmask(&desc->irq_data);\r\nif (called == 0)\r\necard_check_lockup(desc);\r\n}\r\nstatic void\r\necard_irqexp_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nconst unsigned int statusmask = 15;\r\nunsigned int status;\r\nstatus = __raw_readb(EXPMASK_STATUS) & statusmask;\r\nif (status) {\r\nunsigned int slot = first_set[status];\r\necard_t *ec = slot_to_ecard(slot);\r\nif (ec->claimed) {\r\ngeneric_handle_irq(ec->irq);\r\n} else {\r\nprintk(KERN_WARNING "card%d: interrupt from unclaimed "\r\n"card???\n", slot);\r\nhave_expmask &= ~(1 << slot);\r\n__raw_writeb(have_expmask, EXPMASK_ENABLE);\r\n}\r\n} else\r\nprintk(KERN_WARNING "Wild interrupt from backplane (masks)\n");\r\n}\r\nstatic int __init ecard_probeirqhw(void)\r\n{\r\necard_t *ec;\r\nint found;\r\n__raw_writeb(0x00, EXPMASK_ENABLE);\r\n__raw_writeb(0xff, EXPMASK_STATUS);\r\nfound = (__raw_readb(EXPMASK_STATUS) & 15) == 0;\r\n__raw_writeb(0xff, EXPMASK_ENABLE);\r\nif (found) {\r\nprintk(KERN_DEBUG "Expansion card interrupt "\r\n"management hardware found\n");\r\nhave_expmask = 0x80000000;\r\nfor (ec = cards; ec; ec = ec->next)\r\nhave_expmask |= 1 << ec->slot_no;\r\n__raw_writeb(have_expmask, EXPMASK_ENABLE);\r\n}\r\nreturn found;\r\n}\r\nstatic unsigned int __ecard_address(ecard_t *ec, card_type_t type, card_speed_t speed)\r\n{\r\nunsigned long address = 0;\r\nint slot = ec->slot_no;\r\nif (ec->slot_no == 8)\r\nreturn IO_EC_MEMC8_BASE;\r\nectcr &= ~(1 << slot);\r\nswitch (type) {\r\ncase ECARD_MEMC:\r\nif (slot < 4)\r\naddress = IO_EC_MEMC_BASE + (slot << 12);\r\nbreak;\r\ncase ECARD_IOC:\r\nif (slot < 4)\r\naddress = IO_EC_IOC_BASE + (slot << 12);\r\n#ifdef IO_EC_IOC4_BASE\r\nelse\r\naddress = IO_EC_IOC4_BASE + ((slot - 4) << 12);\r\n#endif\r\nif (address)\r\naddress += speed << 17;\r\nbreak;\r\n#ifdef IO_EC_EASI_BASE\r\ncase ECARD_EASI:\r\naddress = IO_EC_EASI_BASE + (slot << 22);\r\nif (speed == ECARD_FAST)\r\nectcr |= 1 << slot;\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\n#ifdef IOMD_ECTCR\r\niomd_writeb(ectcr, IOMD_ECTCR);\r\n#endif\r\nreturn address;\r\n}\r\nstatic int ecard_prints(struct seq_file *m, ecard_t *ec)\r\n{\r\nseq_printf(m, " %d: %s ", ec->slot_no, ec->easi ? "EASI" : " ");\r\nif (ec->cid.id == 0) {\r\nstruct in_chunk_dir incd;\r\nseq_printf(m, "[%04X:%04X] ",\r\nec->cid.manufacturer, ec->cid.product);\r\nif (!ec->card_desc && ec->cid.cd &&\r\necard_readchunk(&incd, ec, 0xf5, 0)) {\r\nec->card_desc = kmalloc(strlen(incd.d.string)+1, GFP_KERNEL);\r\nif (ec->card_desc)\r\nstrcpy((char *)ec->card_desc, incd.d.string);\r\n}\r\nseq_printf(m, "%s\n", ec->card_desc ? ec->card_desc : "*unknown*");\r\n} else\r\nseq_printf(m, "Simple card %d\n", ec->cid.id);\r\nreturn 0;\r\n}\r\nstatic int ecard_devices_proc_show(struct seq_file *m, void *v)\r\n{\r\necard_t *ec = cards;\r\nwhile (ec) {\r\necard_prints(m, ec);\r\nec = ec->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ecard_devices_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ecard_devices_proc_show, NULL);\r\n}\r\nstatic void ecard_proc_init(void)\r\n{\r\nproc_bus_ecard_dir = proc_mkdir("bus/ecard", NULL);\r\nproc_create("devices", 0, proc_bus_ecard_dir, &bus_ecard_proc_fops);\r\n}\r\nstatic void __init ecard_free_card(struct expansion_card *ec)\r\n{\r\nint i;\r\nfor (i = 0; i < ECARD_NUM_RESOURCES; i++)\r\nif (ec->resource[i].flags)\r\nrelease_resource(&ec->resource[i]);\r\nkfree(ec);\r\n}\r\nstatic struct expansion_card *__init ecard_alloc_card(int type, int slot)\r\n{\r\nstruct expansion_card *ec;\r\nunsigned long base;\r\nint i;\r\nec = kzalloc(sizeof(ecard_t), GFP_KERNEL);\r\nif (!ec) {\r\nec = ERR_PTR(-ENOMEM);\r\ngoto nomem;\r\n}\r\nec->slot_no = slot;\r\nec->easi = type == ECARD_EASI;\r\nec->irq = NO_IRQ;\r\nec->fiq = NO_IRQ;\r\nec->dma = NO_DMA;\r\nec->ops = &ecard_default_ops;\r\ndev_set_name(&ec->dev, "ecard%d", slot);\r\nec->dev.parent = NULL;\r\nec->dev.bus = &ecard_bus_type;\r\nec->dev.dma_mask = &ec->dma_mask;\r\nec->dma_mask = (u64)0xffffffff;\r\nec->dev.coherent_dma_mask = ec->dma_mask;\r\nif (slot < 4) {\r\nec_set_resource(ec, ECARD_RES_MEMC,\r\nPODSLOT_MEMC_BASE + (slot << 14),\r\nPODSLOT_MEMC_SIZE);\r\nbase = PODSLOT_IOC0_BASE + (slot << 14);\r\n} else\r\nbase = PODSLOT_IOC4_BASE + ((slot - 4) << 14);\r\n#ifdef CONFIG_ARCH_RPC\r\nif (slot < 8) {\r\nec_set_resource(ec, ECARD_RES_EASI,\r\nPODSLOT_EASI_BASE + (slot << 24),\r\nPODSLOT_EASI_SIZE);\r\n}\r\nif (slot == 8) {\r\nec_set_resource(ec, ECARD_RES_MEMC, NETSLOT_BASE, NETSLOT_SIZE);\r\n} else\r\n#endif\r\nfor (i = 0; i <= ECARD_RES_IOCSYNC - ECARD_RES_IOCSLOW; i++)\r\nec_set_resource(ec, i + ECARD_RES_IOCSLOW,\r\nbase + (i << 19), PODSLOT_IOC_SIZE);\r\nfor (i = 0; i < ECARD_NUM_RESOURCES; i++) {\r\nif (ec->resource[i].flags &&\r\nrequest_resource(&iomem_resource, &ec->resource[i])) {\r\ndev_err(&ec->dev, "resource(s) not available\n");\r\nec->resource[i].end -= ec->resource[i].start;\r\nec->resource[i].start = 0;\r\nec->resource[i].flags = 0;\r\n}\r\n}\r\nnomem:\r\nreturn ec;\r\n}\r\nstatic ssize_t ecard_show_irq(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nreturn sprintf(buf, "%u\n", ec->irq);\r\n}\r\nstatic ssize_t ecard_show_dma(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nreturn sprintf(buf, "%u\n", ec->dma);\r\n}\r\nstatic ssize_t ecard_show_resources(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nchar *str = buf;\r\nint i;\r\nfor (i = 0; i < ECARD_NUM_RESOURCES; i++)\r\nstr += sprintf(str, "%08x %08x %08lx\n",\r\nec->resource[i].start,\r\nec->resource[i].end,\r\nec->resource[i].flags);\r\nreturn str - buf;\r\n}\r\nstatic ssize_t ecard_show_vendor(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nreturn sprintf(buf, "%u\n", ec->cid.manufacturer);\r\n}\r\nstatic ssize_t ecard_show_device(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nreturn sprintf(buf, "%u\n", ec->cid.product);\r\n}\r\nstatic ssize_t ecard_show_type(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nreturn sprintf(buf, "%s\n", ec->easi ? "EASI" : "IOC");\r\n}\r\nint ecard_request_resources(struct expansion_card *ec)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < ECARD_NUM_RESOURCES; i++) {\r\nif (ecard_resource_end(ec, i) &&\r\n!request_mem_region(ecard_resource_start(ec, i),\r\necard_resource_len(ec, i),\r\nec->dev.driver->name)) {\r\nerr = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nif (err) {\r\nwhile (i--)\r\nif (ecard_resource_end(ec, i))\r\nrelease_mem_region(ecard_resource_start(ec, i),\r\necard_resource_len(ec, i));\r\n}\r\nreturn err;\r\n}\r\nvoid ecard_release_resources(struct expansion_card *ec)\r\n{\r\nint i;\r\nfor (i = 0; i < ECARD_NUM_RESOURCES; i++)\r\nif (ecard_resource_end(ec, i))\r\nrelease_mem_region(ecard_resource_start(ec, i),\r\necard_resource_len(ec, i));\r\n}\r\nvoid ecard_setirq(struct expansion_card *ec, const struct expansion_card_ops *ops, void *irq_data)\r\n{\r\nec->irq_data = irq_data;\r\nbarrier();\r\nec->ops = ops;\r\n}\r\nvoid __iomem *ecardm_iomap(struct expansion_card *ec, unsigned int res,\r\nunsigned long offset, unsigned long maxsize)\r\n{\r\nunsigned long start = ecard_resource_start(ec, res);\r\nunsigned long end = ecard_resource_end(ec, res);\r\nif (offset > (end - start))\r\nreturn NULL;\r\nstart += offset;\r\nif (maxsize && end - start > maxsize)\r\nend = start + maxsize;\r\nreturn devm_ioremap(&ec->dev, start, end - start);\r\n}\r\nstatic int __init\r\necard_probe(int slot, card_type_t type)\r\n{\r\necard_t **ecp;\r\necard_t *ec;\r\nstruct ex_ecid cid;\r\nint i, rc;\r\nec = ecard_alloc_card(type, slot);\r\nif (IS_ERR(ec)) {\r\nrc = PTR_ERR(ec);\r\ngoto nomem;\r\n}\r\nrc = -ENODEV;\r\nif ((ec->podaddr = __ecard_address(ec, type, ECARD_SYNC)) == 0)\r\ngoto nodev;\r\ncid.r_zero = 1;\r\necard_readbytes(&cid, ec, 0, 16, 0);\r\nif (cid.r_zero)\r\ngoto nodev;\r\nec->cid.id = cid.r_id;\r\nec->cid.cd = cid.r_cd;\r\nec->cid.is = cid.r_is;\r\nec->cid.w = cid.r_w;\r\nec->cid.manufacturer = ecard_getu16(cid.r_manu);\r\nec->cid.product = ecard_getu16(cid.r_prod);\r\nec->cid.country = cid.r_country;\r\nec->cid.irqmask = cid.r_irqmask;\r\nec->cid.irqoff = ecard_gets24(cid.r_irqoff);\r\nec->cid.fiqmask = cid.r_fiqmask;\r\nec->cid.fiqoff = ecard_gets24(cid.r_fiqoff);\r\nec->fiqaddr =\r\nec->irqaddr = (void __iomem *)ioaddr(ec->podaddr);\r\nif (ec->cid.is) {\r\nec->irqmask = ec->cid.irqmask;\r\nec->irqaddr += ec->cid.irqoff;\r\nec->fiqmask = ec->cid.fiqmask;\r\nec->fiqaddr += ec->cid.fiqoff;\r\n} else {\r\nec->irqmask = 1;\r\nec->fiqmask = 4;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(blacklist); i++)\r\nif (blacklist[i].manufacturer == ec->cid.manufacturer &&\r\nblacklist[i].product == ec->cid.product) {\r\nec->card_desc = blacklist[i].type;\r\nbreak;\r\n}\r\nif (slot < 8) {\r\nec->irq = 32 + slot;\r\nirq_set_chip_and_handler(ec->irq, &ecard_chip,\r\nhandle_level_irq);\r\nset_irq_flags(ec->irq, IRQF_VALID);\r\n}\r\n#ifdef IO_EC_MEMC8_BASE\r\nif (slot == 8)\r\nec->irq = 11;\r\n#endif\r\n#ifdef CONFIG_ARCH_RPC\r\nif (slot < 2)\r\nec->dma = 2 + slot;\r\n#endif\r\nfor (ecp = &cards; *ecp; ecp = &(*ecp)->next);\r\n*ecp = ec;\r\nslot_to_expcard[slot] = ec;\r\ndevice_register(&ec->dev);\r\nreturn 0;\r\nnodev:\r\necard_free_card(ec);\r\nnomem:\r\nreturn rc;\r\n}\r\nstatic int __init ecard_init(void)\r\n{\r\nstruct task_struct *task;\r\nint slot, irqhw;\r\ntask = kthread_run(ecard_task, NULL, "kecardd");\r\nif (IS_ERR(task)) {\r\nprintk(KERN_ERR "Ecard: unable to create kernel thread: %ld\n",\r\nPTR_ERR(task));\r\nreturn PTR_ERR(task);\r\n}\r\nprintk("Probing expansion cards\n");\r\nfor (slot = 0; slot < 8; slot ++) {\r\nif (ecard_probe(slot, ECARD_EASI) == -ENODEV)\r\necard_probe(slot, ECARD_IOC);\r\n}\r\n#ifdef IO_EC_MEMC8_BASE\r\necard_probe(8, ECARD_IOC);\r\n#endif\r\nirqhw = ecard_probeirqhw();\r\nirq_set_chained_handler(IRQ_EXPANSIONCARD,\r\nirqhw ? ecard_irqexp_handler : ecard_irq_handler);\r\necard_proc_init();\r\nreturn 0;\r\n}\r\nstatic const struct ecard_id *\r\necard_match_device(const struct ecard_id *ids, struct expansion_card *ec)\r\n{\r\nint i;\r\nfor (i = 0; ids[i].manufacturer != 65535; i++)\r\nif (ec->cid.manufacturer == ids[i].manufacturer &&\r\nec->cid.product == ids[i].product)\r\nreturn ids + i;\r\nreturn NULL;\r\n}\r\nstatic int ecard_drv_probe(struct device *dev)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nstruct ecard_driver *drv = ECARD_DRV(dev->driver);\r\nconst struct ecard_id *id;\r\nint ret;\r\nid = ecard_match_device(drv->id_table, ec);\r\nec->claimed = 1;\r\nret = drv->probe(ec, id);\r\nif (ret)\r\nec->claimed = 0;\r\nreturn ret;\r\n}\r\nstatic int ecard_drv_remove(struct device *dev)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nstruct ecard_driver *drv = ECARD_DRV(dev->driver);\r\ndrv->remove(ec);\r\nec->claimed = 0;\r\nec->ops = &ecard_default_ops;\r\nbarrier();\r\nec->irq_data = NULL;\r\nreturn 0;\r\n}\r\nstatic void ecard_drv_shutdown(struct device *dev)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nstruct ecard_driver *drv = ECARD_DRV(dev->driver);\r\nstruct ecard_request req;\r\nif (dev->driver) {\r\nif (drv->shutdown)\r\ndrv->shutdown(ec);\r\nec->claimed = 0;\r\n}\r\nif (ec->loader) {\r\nreq.fn = ecard_task_reset;\r\nreq.ec = ec;\r\necard_call(&req);\r\n}\r\n}\r\nint ecard_register_driver(struct ecard_driver *drv)\r\n{\r\ndrv->drv.bus = &ecard_bus_type;\r\nreturn driver_register(&drv->drv);\r\n}\r\nvoid ecard_remove_driver(struct ecard_driver *drv)\r\n{\r\ndriver_unregister(&drv->drv);\r\n}\r\nstatic int ecard_match(struct device *_dev, struct device_driver *_drv)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(_dev);\r\nstruct ecard_driver *drv = ECARD_DRV(_drv);\r\nint ret;\r\nif (drv->id_table) {\r\nret = ecard_match_device(drv->id_table, ec) != NULL;\r\n} else {\r\nret = ec->cid.id == drv->id;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ecard_bus_init(void)\r\n{\r\nreturn bus_register(&ecard_bus_type);\r\n}
