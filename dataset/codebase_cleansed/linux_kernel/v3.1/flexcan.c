static void flexcan_transceiver_switch(const struct flexcan_priv *priv, int on)\r\n{\r\nif (priv->pdata && priv->pdata->transceiver_switch)\r\npriv->pdata->transceiver_switch(on);\r\n}\r\nstatic inline int flexcan_has_and_handle_berr(const struct flexcan_priv *priv,\r\nu32 reg_esr)\r\n{\r\nreturn (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&\r\n(reg_esr & FLEXCAN_ESR_ERR_BUS);\r\n}\r\nstatic inline void flexcan_chip_enable(struct flexcan_priv *priv)\r\n{\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nu32 reg;\r\nreg = readl(&regs->mcr);\r\nreg &= ~FLEXCAN_MCR_MDIS;\r\nwritel(reg, &regs->mcr);\r\nudelay(10);\r\n}\r\nstatic inline void flexcan_chip_disable(struct flexcan_priv *priv)\r\n{\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nu32 reg;\r\nreg = readl(&regs->mcr);\r\nreg |= FLEXCAN_MCR_MDIS;\r\nwritel(reg, &regs->mcr);\r\n}\r\nstatic int flexcan_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nu32 reg = readl(&regs->ecr);\r\nbec->txerr = (reg >> 0) & 0xff;\r\nbec->rxerr = (reg >> 8) & 0xff;\r\nreturn 0;\r\n}\r\nstatic int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu32 can_id;\r\nu32 ctrl = FLEXCAN_MB_CNT_CODE(0xc) | (cf->can_dlc << 16);\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(dev);\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\ncan_id = cf->can_id & CAN_EFF_MASK;\r\nctrl |= FLEXCAN_MB_CNT_IDE | FLEXCAN_MB_CNT_SRR;\r\n} else {\r\ncan_id = (cf->can_id & CAN_SFF_MASK) << 18;\r\n}\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nctrl |= FLEXCAN_MB_CNT_RTR;\r\nif (cf->can_dlc > 0) {\r\nu32 data = be32_to_cpup((__be32 *)&cf->data[0]);\r\nwritel(data, &regs->cantxfg[FLEXCAN_TX_BUF_ID].data[0]);\r\n}\r\nif (cf->can_dlc > 3) {\r\nu32 data = be32_to_cpup((__be32 *)&cf->data[4]);\r\nwritel(data, &regs->cantxfg[FLEXCAN_TX_BUF_ID].data[1]);\r\n}\r\nwritel(can_id, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_id);\r\nwritel(ctrl, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_ctrl);\r\nkfree_skb(skb);\r\nstats->tx_bytes += cf->can_dlc;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void do_bus_err(struct net_device *dev,\r\nstruct can_frame *cf, u32 reg_esr)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nint rx_errors = 0, tx_errors = 0;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nif (reg_esr & FLEXCAN_ESR_BIT1_ERR) {\r\ndev_dbg(dev->dev.parent, "BIT1_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\ntx_errors = 1;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_BIT0_ERR) {\r\ndev_dbg(dev->dev.parent, "BIT0_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\ntx_errors = 1;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_ACK_ERR) {\r\ndev_dbg(dev->dev.parent, "ACK_ERR irq\n");\r\ncf->can_id |= CAN_ERR_ACK;\r\ncf->data[3] |= CAN_ERR_PROT_LOC_ACK;\r\ntx_errors = 1;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_CRC_ERR) {\r\ndev_dbg(dev->dev.parent, "CRC_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\ncf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;\r\nrx_errors = 1;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_FRM_ERR) {\r\ndev_dbg(dev->dev.parent, "FRM_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nrx_errors = 1;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_STF_ERR) {\r\ndev_dbg(dev->dev.parent, "STF_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nrx_errors = 1;\r\n}\r\npriv->can.can_stats.bus_error++;\r\nif (rx_errors)\r\ndev->stats.rx_errors++;\r\nif (tx_errors)\r\ndev->stats.tx_errors++;\r\n}\r\nstatic int flexcan_poll_bus_err(struct net_device *dev, u32 reg_esr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\ndo_bus_err(dev, cf, reg_esr);\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += cf->can_dlc;\r\nreturn 1;\r\n}\r\nstatic void do_state(struct net_device *dev,\r\nstruct can_frame *cf, enum can_state new_state)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct can_berr_counter bec;\r\nflexcan_get_berr_counter(dev, &bec);\r\nswitch (priv->can.state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\nif (new_state >= CAN_STATE_ERROR_WARNING &&\r\nnew_state <= CAN_STATE_BUS_OFF) {\r\ndev_dbg(dev->dev.parent, "Error Warning IRQ\n");\r\npriv->can.can_stats.error_warning++;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\n}\r\ncase CAN_STATE_ERROR_WARNING:\r\nif (new_state >= CAN_STATE_ERROR_PASSIVE &&\r\nnew_state <= CAN_STATE_BUS_OFF) {\r\ndev_dbg(dev->dev.parent, "Error Passive IRQ\n");\r\npriv->can.can_stats.error_passive++;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\ndev_err(dev->dev.parent,\r\n"BUG! hardware recovered automatically from BUS_OFF\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (new_state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\ndev_dbg(dev->dev.parent, "Error Active\n");\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_ACTIVE;\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\ncan_bus_off(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int flexcan_poll_state(struct net_device *dev, u32 reg_esr)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nenum can_state new_state;\r\nint flt;\r\nflt = reg_esr & FLEXCAN_ESR_FLT_CONF_MASK;\r\nif (likely(flt == FLEXCAN_ESR_FLT_CONF_ACTIVE)) {\r\nif (likely(!(reg_esr & (FLEXCAN_ESR_TX_WRN |\r\nFLEXCAN_ESR_RX_WRN))))\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\nelse\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\n} else if (unlikely(flt == FLEXCAN_ESR_FLT_CONF_PASSIVE))\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\nelse\r\nnew_state = CAN_STATE_BUS_OFF;\r\nif (likely(new_state == priv->can.state))\r\nreturn 0;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\ndo_state(dev, cf, new_state);\r\npriv->can.state = new_state;\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += cf->can_dlc;\r\nreturn 1;\r\n}\r\nstatic void flexcan_read_fifo(const struct net_device *dev,\r\nstruct can_frame *cf)\r\n{\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nstruct flexcan_mb __iomem *mb = &regs->cantxfg[0];\r\nu32 reg_ctrl, reg_id;\r\nreg_ctrl = readl(&mb->can_ctrl);\r\nreg_id = readl(&mb->can_id);\r\nif (reg_ctrl & FLEXCAN_MB_CNT_IDE)\r\ncf->can_id = ((reg_id >> 0) & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id = (reg_id >> 18) & CAN_SFF_MASK;\r\nif (reg_ctrl & FLEXCAN_MB_CNT_RTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\ncf->can_dlc = get_can_dlc((reg_ctrl >> 16) & 0xf);\r\n*(__be32 *)(cf->data + 0) = cpu_to_be32(readl(&mb->data[0]));\r\n*(__be32 *)(cf->data + 4) = cpu_to_be32(readl(&mb->data[1]));\r\nwritel(FLEXCAN_IFLAG_RX_FIFO_AVAILABLE, &regs->iflag1);\r\nreadl(&regs->timer);\r\n}\r\nstatic int flexcan_read_frame(struct net_device *dev)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nskb = alloc_can_skb(dev, &cf);\r\nif (unlikely(!skb)) {\r\nstats->rx_dropped++;\r\nreturn 0;\r\n}\r\nflexcan_read_fifo(dev, cf);\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nreturn 1;\r\n}\r\nstatic int flexcan_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *dev = napi->dev;\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nu32 reg_iflag1, reg_esr;\r\nint work_done = 0;\r\nreg_esr = readl(&regs->esr) | priv->reg_esr;\r\nwork_done += flexcan_poll_state(dev, reg_esr);\r\nreg_iflag1 = readl(&regs->iflag1);\r\nwhile (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE &&\r\nwork_done < quota) {\r\nwork_done += flexcan_read_frame(dev);\r\nreg_iflag1 = readl(&regs->iflag1);\r\n}\r\nif (flexcan_has_and_handle_berr(priv, reg_esr) && work_done < quota)\r\nwork_done += flexcan_poll_bus_err(dev, reg_esr);\r\nif (work_done < quota) {\r\nnapi_complete(napi);\r\nwritel(FLEXCAN_IFLAG_DEFAULT, &regs->imask1);\r\nwritel(priv->reg_ctrl_default, &regs->ctrl);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t flexcan_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nu32 reg_iflag1, reg_esr;\r\nreg_iflag1 = readl(&regs->iflag1);\r\nreg_esr = readl(&regs->esr);\r\nwritel(FLEXCAN_ESR_ERR_INT, &regs->esr);\r\nif ((reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE) ||\r\n(reg_esr & FLEXCAN_ESR_ERR_STATE) ||\r\nflexcan_has_and_handle_berr(priv, reg_esr)) {\r\npriv->reg_esr = reg_esr & FLEXCAN_ESR_ERR_BUS;\r\nwritel(FLEXCAN_IFLAG_DEFAULT & ~FLEXCAN_IFLAG_RX_FIFO_AVAILABLE,\r\n&regs->imask1);\r\nwritel(priv->reg_ctrl_default & ~FLEXCAN_CTRL_ERR_ALL,\r\n&regs->ctrl);\r\nnapi_schedule(&priv->napi);\r\n}\r\nif (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_OVERFLOW) {\r\nwritel(FLEXCAN_IFLAG_RX_FIFO_OVERFLOW, &regs->iflag1);\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_errors++;\r\n}\r\nif (reg_iflag1 & (1 << FLEXCAN_TX_BUF_ID)) {\r\nstats->tx_packets++;\r\nwritel((1 << FLEXCAN_TX_BUF_ID), &regs->iflag1);\r\nnetif_wake_queue(dev);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void flexcan_set_bittiming(struct net_device *dev)\r\n{\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nu32 reg;\r\nreg = readl(&regs->ctrl);\r\nreg &= ~(FLEXCAN_CTRL_PRESDIV(0xff) |\r\nFLEXCAN_CTRL_RJW(0x3) |\r\nFLEXCAN_CTRL_PSEG1(0x7) |\r\nFLEXCAN_CTRL_PSEG2(0x7) |\r\nFLEXCAN_CTRL_PROPSEG(0x7) |\r\nFLEXCAN_CTRL_LPB |\r\nFLEXCAN_CTRL_SMP |\r\nFLEXCAN_CTRL_LOM);\r\nreg |= FLEXCAN_CTRL_PRESDIV(bt->brp - 1) |\r\nFLEXCAN_CTRL_PSEG1(bt->phase_seg1 - 1) |\r\nFLEXCAN_CTRL_PSEG2(bt->phase_seg2 - 1) |\r\nFLEXCAN_CTRL_RJW(bt->sjw - 1) |\r\nFLEXCAN_CTRL_PROPSEG(bt->prop_seg - 1);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\nreg |= FLEXCAN_CTRL_LPB;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nreg |= FLEXCAN_CTRL_LOM;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nreg |= FLEXCAN_CTRL_SMP;\r\ndev_info(dev->dev.parent, "writing ctrl=0x%08x\n", reg);\r\nwritel(reg, &regs->ctrl);\r\ndev_dbg(dev->dev.parent, "%s: mcr=0x%08x ctrl=0x%08x\n", __func__,\r\nreadl(&regs->mcr), readl(&regs->ctrl));\r\n}\r\nstatic int flexcan_chip_start(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nunsigned int i;\r\nint err;\r\nu32 reg_mcr, reg_ctrl;\r\nflexcan_chip_enable(priv);\r\nwritel(FLEXCAN_MCR_SOFTRST, &regs->mcr);\r\nudelay(10);\r\nreg_mcr = readl(&regs->mcr);\r\nif (reg_mcr & FLEXCAN_MCR_SOFTRST) {\r\ndev_err(dev->dev.parent,\r\n"Failed to softreset can module (mcr=0x%08x)\n",\r\nreg_mcr);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nflexcan_set_bittiming(dev);\r\nreg_mcr = readl(&regs->mcr);\r\nreg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_FEN | FLEXCAN_MCR_HALT |\r\nFLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN |\r\nFLEXCAN_MCR_IDAM_C;\r\ndev_dbg(dev->dev.parent, "%s: writing mcr=0x%08x", __func__, reg_mcr);\r\nwritel(reg_mcr, &regs->mcr);\r\nreg_ctrl = readl(&regs->ctrl);\r\nreg_ctrl &= ~FLEXCAN_CTRL_TSYN;\r\nreg_ctrl |= FLEXCAN_CTRL_BOFF_REC | FLEXCAN_CTRL_LBUF |\r\nFLEXCAN_CTRL_ERR_STATE | FLEXCAN_CTRL_ERR_MSK;\r\npriv->reg_ctrl_default = reg_ctrl;\r\ndev_dbg(dev->dev.parent, "%s: writing ctrl=0x%08x", __func__, reg_ctrl);\r\nwritel(reg_ctrl, &regs->ctrl);\r\nfor (i = 0; i < ARRAY_SIZE(regs->cantxfg); i++) {\r\nwritel(0, &regs->cantxfg[i].can_ctrl);\r\nwritel(0, &regs->cantxfg[i].can_id);\r\nwritel(0, &regs->cantxfg[i].data[0]);\r\nwritel(0, &regs->cantxfg[i].data[1]);\r\nwritel(FLEXCAN_MB_CNT_CODE(0x4), &regs->cantxfg[i].can_ctrl);\r\n}\r\nwritel(0x0, &regs->rxgmask);\r\nwritel(0x0, &regs->rx14mask);\r\nwritel(0x0, &regs->rx15mask);\r\nflexcan_transceiver_switch(priv, 1);\r\nreg_mcr = readl(&regs->mcr);\r\nreg_mcr &= ~FLEXCAN_MCR_HALT;\r\nwritel(reg_mcr, &regs->mcr);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nwritel(FLEXCAN_IFLAG_DEFAULT, &regs->imask1);\r\ndev_dbg(dev->dev.parent, "%s: reading mcr=0x%08x ctrl=0x%08x\n",\r\n__func__, readl(&regs->mcr), readl(&regs->ctrl));\r\nreturn 0;\r\nout:\r\nflexcan_chip_disable(priv);\r\nreturn err;\r\n}\r\nstatic void flexcan_chip_stop(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nu32 reg;\r\nwritel(0, &regs->imask1);\r\nreg = readl(&regs->mcr);\r\nreg |= FLEXCAN_MCR_MDIS | FLEXCAN_MCR_HALT;\r\nwritel(reg, &regs->mcr);\r\nflexcan_transceiver_switch(priv, 0);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nreturn;\r\n}\r\nstatic int flexcan_open(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nint err;\r\nclk_enable(priv->clk);\r\nerr = open_candev(dev);\r\nif (err)\r\ngoto out;\r\nerr = request_irq(dev->irq, flexcan_irq, IRQF_SHARED, dev->name, dev);\r\nif (err)\r\ngoto out_close;\r\nerr = flexcan_chip_start(dev);\r\nif (err)\r\ngoto out_close;\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_close:\r\nclose_candev(dev);\r\nout:\r\nclk_disable(priv->clk);\r\nreturn err;\r\n}\r\nstatic int flexcan_close(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nflexcan_chip_stop(dev);\r\nfree_irq(dev->irq, dev);\r\nclk_disable(priv->clk);\r\nclose_candev(dev);\r\nreturn 0;\r\n}\r\nstatic int flexcan_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nint err;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nerr = flexcan_chip_start(dev);\r\nif (err)\r\nreturn err;\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit register_flexcandev(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->base;\r\nu32 reg, err;\r\nclk_enable(priv->clk);\r\nflexcan_chip_disable(priv);\r\nreg = readl(&regs->ctrl);\r\nreg |= FLEXCAN_CTRL_CLK_SRC;\r\nwritel(reg, &regs->ctrl);\r\nflexcan_chip_enable(priv);\r\nreg = readl(&regs->mcr);\r\nreg |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT |\r\nFLEXCAN_MCR_FEN | FLEXCAN_MCR_SUPV;\r\nwritel(reg, &regs->mcr);\r\nreg = readl(&regs->mcr);\r\nif (!(reg & FLEXCAN_MCR_FEN)) {\r\ndev_err(dev->dev.parent,\r\n"Could not enable RX FIFO, unsupported core\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nerr = register_candev(dev);\r\nout:\r\nflexcan_chip_disable(priv);\r\nclk_disable(priv->clk);\r\nreturn err;\r\n}\r\nstatic void __devexit unregister_flexcandev(struct net_device *dev)\r\n{\r\nunregister_candev(dev);\r\n}\r\nstatic int __devinit flexcan_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct flexcan_priv *priv;\r\nstruct resource *mem;\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nresource_size_t mem_size;\r\nint err, irq;\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "no clock defined\n");\r\nerr = PTR_ERR(clk);\r\ngoto failed_clock;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!mem || irq <= 0) {\r\nerr = -ENODEV;\r\ngoto failed_get;\r\n}\r\nmem_size = resource_size(mem);\r\nif (!request_mem_region(mem->start, mem_size, pdev->name)) {\r\nerr = -EBUSY;\r\ngoto failed_get;\r\n}\r\nbase = ioremap(mem->start, mem_size);\r\nif (!base) {\r\nerr = -ENOMEM;\r\ngoto failed_map;\r\n}\r\ndev = alloc_candev(sizeof(struct flexcan_priv), 0);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto failed_alloc;\r\n}\r\ndev->netdev_ops = &flexcan_netdev_ops;\r\ndev->irq = irq;\r\ndev->flags |= IFF_ECHO;\r\npriv = netdev_priv(dev);\r\npriv->can.clock.freq = clk_get_rate(clk);\r\npriv->can.bittiming_const = &flexcan_bittiming_const;\r\npriv->can.do_set_mode = flexcan_set_mode;\r\npriv->can.do_get_berr_counter = flexcan_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_3_SAMPLES |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\npriv->base = base;\r\npriv->dev = dev;\r\npriv->clk = clk;\r\npriv->pdata = pdev->dev.platform_data;\r\nnetif_napi_add(dev, &priv->napi, flexcan_poll, FLEXCAN_NAPI_WEIGHT);\r\ndev_set_drvdata(&pdev->dev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = register_flexcandev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering netdev failed\n");\r\ngoto failed_register;\r\n}\r\ndev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",\r\npriv->base, dev->irq);\r\nreturn 0;\r\nfailed_register:\r\nfree_candev(dev);\r\nfailed_alloc:\r\niounmap(base);\r\nfailed_map:\r\nrelease_mem_region(mem->start, mem_size);\r\nfailed_get:\r\nclk_put(clk);\r\nfailed_clock:\r\nreturn err;\r\n}\r\nstatic int __devexit flexcan_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct resource *mem;\r\nunregister_flexcandev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(priv->base);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nclk_put(priv->clk);\r\nfree_candev(dev);\r\nreturn 0;\r\n}\r\nstatic int __init flexcan_init(void)\r\n{\r\npr_info("%s netdevice driver\n", DRV_NAME);\r\nreturn platform_driver_register(&flexcan_driver);\r\n}\r\nstatic void __exit flexcan_exit(void)\r\n{\r\nplatform_driver_unregister(&flexcan_driver);\r\npr_info("%s: driver removed\n", DRV_NAME);\r\n}
