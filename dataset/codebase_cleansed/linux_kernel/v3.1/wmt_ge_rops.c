void wmt_ge_fillrect(struct fb_info *p, const struct fb_fillrect *rect)\r\n{\r\nunsigned long fg, pat;\r\nif (p->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (p->fix.visual == FB_VISUAL_TRUECOLOR ||\r\np->fix.visual == FB_VISUAL_DIRECTCOLOR)\r\nfg = ((u32 *) (p->pseudo_palette))[rect->color];\r\nelse\r\nfg = rect->color;\r\npat = pixel_to_pat(p->var.bits_per_pixel, fg);\r\nif (p->fbops->fb_sync)\r\np->fbops->fb_sync(p);\r\nwritel(p->var.bits_per_pixel == 32 ? 3 :\r\n(p->var.bits_per_pixel == 8 ? 0 : 1), regbase + GE_DEPTH_OFF);\r\nwritel(p->var.bits_per_pixel == 15 ? 1 : 0, regbase + GE_HIGHCOLOR_OFF);\r\nwritel(p->fix.smem_start, regbase + GE_DESTBASE_OFF);\r\nwritel(p->var.xres_virtual - 1, regbase + GE_DESTDISPW_OFF);\r\nwritel(p->var.yres_virtual - 1, regbase + GE_DESTDISPH_OFF);\r\nwritel(rect->dx, regbase + GE_DESTAREAX_OFF);\r\nwritel(rect->dy, regbase + GE_DESTAREAY_OFF);\r\nwritel(rect->width - 1, regbase + GE_DESTAREAW_OFF);\r\nwritel(rect->height - 1, regbase + GE_DESTAREAH_OFF);\r\nwritel(pat, regbase + GE_PAT0C_OFF);\r\nwritel(1, regbase + GE_COMMAND_OFF);\r\nwritel(rect->rop == ROP_XOR ? 0x5a : 0xf0, regbase + GE_ROPCODE_OFF);\r\nwritel(1, regbase + GE_FIRE_OFF);\r\n}\r\nvoid wmt_ge_copyarea(struct fb_info *p, const struct fb_copyarea *area)\r\n{\r\nif (p->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (p->fbops->fb_sync)\r\np->fbops->fb_sync(p);\r\nwritel(p->var.bits_per_pixel > 16 ? 3 :\r\n(p->var.bits_per_pixel > 8 ? 1 : 0), regbase + GE_DEPTH_OFF);\r\nwritel(p->fix.smem_start, regbase + GE_SRCBASE_OFF);\r\nwritel(p->var.xres_virtual - 1, regbase + GE_SRCDISPW_OFF);\r\nwritel(p->var.yres_virtual - 1, regbase + GE_SRCDISPH_OFF);\r\nwritel(area->sx, regbase + GE_SRCAREAX_OFF);\r\nwritel(area->sy, regbase + GE_SRCAREAY_OFF);\r\nwritel(area->width - 1, regbase + GE_SRCAREAW_OFF);\r\nwritel(area->height - 1, regbase + GE_SRCAREAH_OFF);\r\nwritel(p->fix.smem_start, regbase + GE_DESTBASE_OFF);\r\nwritel(p->var.xres_virtual - 1, regbase + GE_DESTDISPW_OFF);\r\nwritel(p->var.yres_virtual - 1, regbase + GE_DESTDISPH_OFF);\r\nwritel(area->dx, regbase + GE_DESTAREAX_OFF);\r\nwritel(area->dy, regbase + GE_DESTAREAY_OFF);\r\nwritel(area->width - 1, regbase + GE_DESTAREAW_OFF);\r\nwritel(area->height - 1, regbase + GE_DESTAREAH_OFF);\r\nwritel(0xcc, regbase + GE_ROPCODE_OFF);\r\nwritel(1, regbase + GE_COMMAND_OFF);\r\nwritel(1, regbase + GE_FIRE_OFF);\r\n}\r\nint wmt_ge_sync(struct fb_info *p)\r\n{\r\nint loops = 5000000;\r\nwhile ((readl(regbase + GE_STATUS_OFF) & 4) && --loops)\r\ncpu_relax();\r\nreturn loops > 0 ? 0 : -EBUSY;\r\n}\r\nstatic int __devinit wmt_ge_rops_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no I/O memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\nif (unlikely(regbase)) {\r\nWARN_ON(1);\r\nreturn -EBUSY;\r\n}\r\nregbase = ioremap(res->start, resource_size(res));\r\nif (regbase == NULL) {\r\ndev_err(&pdev->dev, "failed to map I/O memory\n");\r\nreturn -EBUSY;\r\n}\r\nwritel(1, regbase + GE_ENABLE_OFF);\r\nprintk(KERN_INFO "Enabled support for WMT GE raster acceleration\n");\r\nreturn 0;\r\n}\r\nstatic int __devexit wmt_ge_rops_remove(struct platform_device *pdev)\r\n{\r\niounmap(regbase);\r\nreturn 0;\r\n}\r\nstatic int __init wmt_ge_rops_init(void)\r\n{\r\nreturn platform_driver_register(&wmt_ge_rops_driver);\r\n}\r\nstatic void __exit wmt_ge_rops_exit(void)\r\n{\r\nplatform_driver_unregister(&wmt_ge_rops_driver);\r\n}
