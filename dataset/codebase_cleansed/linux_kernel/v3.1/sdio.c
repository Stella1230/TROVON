static int sdio_read_fbr(struct sdio_func *func)\r\n{\r\nint ret;\r\nunsigned char data;\r\nif (mmc_card_nonstd_func_interface(func->card)) {\r\nfunc->class = SDIO_CLASS_NONE;\r\nreturn 0;\r\n}\r\nret = mmc_io_rw_direct(func->card, 0, 0,\r\nSDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF, 0, &data);\r\nif (ret)\r\ngoto out;\r\ndata &= 0x0f;\r\nif (data == 0x0f) {\r\nret = mmc_io_rw_direct(func->card, 0, 0,\r\nSDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF_EXT, 0, &data);\r\nif (ret)\r\ngoto out;\r\n}\r\nfunc->class = data;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sdio_init_func(struct mmc_card *card, unsigned int fn)\r\n{\r\nint ret;\r\nstruct sdio_func *func;\r\nBUG_ON(fn > SDIO_MAX_FUNCS);\r\nfunc = sdio_alloc_func(card);\r\nif (IS_ERR(func))\r\nreturn PTR_ERR(func);\r\nfunc->num = fn;\r\nif (!(card->quirks & MMC_QUIRK_NONSTD_SDIO)) {\r\nret = sdio_read_fbr(func);\r\nif (ret)\r\ngoto fail;\r\nret = sdio_read_func_cis(func);\r\nif (ret)\r\ngoto fail;\r\n} else {\r\nfunc->vendor = func->card->cis.vendor;\r\nfunc->device = func->card->cis.device;\r\nfunc->max_blksize = func->card->cis.blksize;\r\n}\r\ncard->sdio_func[fn - 1] = func;\r\nreturn 0;\r\nfail:\r\nsdio_remove_func(func);\r\nreturn ret;\r\n}\r\nstatic int sdio_read_cccr(struct mmc_card *card)\r\n{\r\nint ret;\r\nint cccr_vsn;\r\nunsigned char data;\r\nmemset(&card->cccr, 0, sizeof(struct sdio_cccr));\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CCCR, 0, &data);\r\nif (ret)\r\ngoto out;\r\ncccr_vsn = data & 0x0f;\r\nif (cccr_vsn > SDIO_CCCR_REV_1_20) {\r\nprintk(KERN_ERR "%s: unrecognised CCCR structure version %d\n",\r\nmmc_hostname(card->host), cccr_vsn);\r\nreturn -EINVAL;\r\n}\r\ncard->cccr.sdio_vsn = (data & 0xf0) >> 4;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CAPS, 0, &data);\r\nif (ret)\r\ngoto out;\r\nif (data & SDIO_CCCR_CAP_SMB)\r\ncard->cccr.multi_block = 1;\r\nif (data & SDIO_CCCR_CAP_LSC)\r\ncard->cccr.low_speed = 1;\r\nif (data & SDIO_CCCR_CAP_4BLS)\r\ncard->cccr.wide_bus = 1;\r\nif (cccr_vsn >= SDIO_CCCR_REV_1_10) {\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_POWER, 0, &data);\r\nif (ret)\r\ngoto out;\r\nif (data & SDIO_POWER_SMPC)\r\ncard->cccr.high_power = 1;\r\n}\r\nif (cccr_vsn >= SDIO_CCCR_REV_1_20) {\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &data);\r\nif (ret)\r\ngoto out;\r\nif (data & SDIO_SPEED_SHS)\r\ncard->cccr.high_speed = 1;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sdio_enable_wide(struct mmc_card *card)\r\n{\r\nint ret;\r\nu8 ctrl;\r\nif (!(card->host->caps & MMC_CAP_4_BIT_DATA))\r\nreturn 0;\r\nif (card->cccr.low_speed && !card->cccr.wide_bus)\r\nreturn 0;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nctrl |= SDIO_BUS_WIDTH_4BIT;\r\nret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn 1;\r\n}\r\nstatic int sdio_disable_cd(struct mmc_card *card)\r\n{\r\nint ret;\r\nu8 ctrl;\r\nif (!mmc_card_disable_cd(card))\r\nreturn 0;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nctrl |= SDIO_BUS_CD_DISABLE;\r\nreturn mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\r\n}\r\nstatic int sdio_disable_wide(struct mmc_card *card)\r\n{\r\nint ret;\r\nu8 ctrl;\r\nif (!(card->host->caps & MMC_CAP_4_BIT_DATA))\r\nreturn 0;\r\nif (card->cccr.low_speed && !card->cccr.wide_bus)\r\nreturn 0;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nif (!(ctrl & SDIO_BUS_WIDTH_4BIT))\r\nreturn 0;\r\nctrl &= ~SDIO_BUS_WIDTH_4BIT;\r\nctrl |= SDIO_BUS_ASYNC_INT;\r\nret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\r\nif (ret)\r\nreturn ret;\r\nmmc_set_bus_width(card->host, MMC_BUS_WIDTH_1);\r\nreturn 0;\r\n}\r\nstatic int sdio_enable_4bit_bus(struct mmc_card *card)\r\n{\r\nint err;\r\nif (card->type == MMC_TYPE_SDIO)\r\nreturn sdio_enable_wide(card);\r\nif ((card->host->caps & MMC_CAP_4_BIT_DATA) &&\r\n(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {\r\nerr = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);\r\nif (err)\r\nreturn err;\r\n} else\r\nreturn 0;\r\nerr = sdio_enable_wide(card);\r\nif (err <= 0)\r\nmmc_app_set_bus_width(card, MMC_BUS_WIDTH_1);\r\nreturn err;\r\n}\r\nstatic int mmc_sdio_switch_hs(struct mmc_card *card, int enable)\r\n{\r\nint ret;\r\nu8 speed;\r\nif (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))\r\nreturn 0;\r\nif (!card->cccr.high_speed)\r\nreturn 0;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\r\nif (ret)\r\nreturn ret;\r\nif (enable)\r\nspeed |= SDIO_SPEED_EHS;\r\nelse\r\nspeed &= ~SDIO_SPEED_EHS;\r\nret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn 1;\r\n}\r\nstatic int sdio_enable_hs(struct mmc_card *card)\r\n{\r\nint ret;\r\nret = mmc_sdio_switch_hs(card, true);\r\nif (ret <= 0 || card->type == MMC_TYPE_SDIO)\r\nreturn ret;\r\nret = mmc_sd_switch_hs(card);\r\nif (ret <= 0)\r\nmmc_sdio_switch_hs(card, false);\r\nreturn ret;\r\n}\r\nstatic unsigned mmc_sdio_get_max_clock(struct mmc_card *card)\r\n{\r\nunsigned max_dtr;\r\nif (mmc_card_highspeed(card)) {\r\nmax_dtr = 50000000;\r\n} else {\r\nmax_dtr = card->cis.max_dtr;\r\n}\r\nif (card->type == MMC_TYPE_SD_COMBO)\r\nmax_dtr = min(max_dtr, mmc_sd_get_max_clock(card));\r\nreturn max_dtr;\r\n}\r\nstatic int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,\r\nstruct mmc_card *oldcard, int powered_resume)\r\n{\r\nstruct mmc_card *card;\r\nint err;\r\nBUG_ON(!host);\r\nWARN_ON(!host->claimed);\r\nif (!powered_resume) {\r\nerr = mmc_send_io_op_cond(host, host->ocr, &ocr);\r\nif (err)\r\ngoto err;\r\n}\r\nif (mmc_host_is_spi(host)) {\r\nerr = mmc_spi_set_crc(host, use_spi_crc);\r\nif (err)\r\ngoto err;\r\n}\r\ncard = mmc_alloc_card(host, NULL);\r\nif (IS_ERR(card)) {\r\nerr = PTR_ERR(card);\r\ngoto err;\r\n}\r\nif ((ocr & R4_MEMORY_PRESENT) &&\r\nmmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid, NULL) == 0) {\r\ncard->type = MMC_TYPE_SD_COMBO;\r\nif (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||\r\nmemcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {\r\nmmc_remove_card(card);\r\nreturn -ENOENT;\r\n}\r\n} else {\r\ncard->type = MMC_TYPE_SDIO;\r\nif (oldcard && oldcard->type != MMC_TYPE_SDIO) {\r\nmmc_remove_card(card);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (host->ops->init_card)\r\nhost->ops->init_card(host, card);\r\nif (!powered_resume && !mmc_host_is_spi(host)) {\r\nerr = mmc_send_relative_addr(host, &card->rca);\r\nif (err)\r\ngoto remove;\r\nif (oldcard)\r\noldcard->rca = card->rca;\r\nmmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);\r\n}\r\nif (!oldcard && card->type == MMC_TYPE_SD_COMBO) {\r\nerr = mmc_sd_get_csd(host, card);\r\nif (err)\r\nreturn err;\r\nmmc_decode_cid(card);\r\n}\r\nif (!powered_resume && !mmc_host_is_spi(host)) {\r\nerr = mmc_select_card(card);\r\nif (err)\r\ngoto remove;\r\n}\r\nif (card->quirks & MMC_QUIRK_NONSTD_SDIO) {\r\nmmc_set_clock(host, card->cis.max_dtr);\r\nif (card->cccr.high_speed) {\r\nmmc_card_set_highspeed(card);\r\nmmc_set_timing(card->host, MMC_TIMING_SD_HS);\r\n}\r\ngoto finish;\r\n}\r\nerr = sdio_read_cccr(card);\r\nif (err)\r\ngoto remove;\r\nerr = sdio_read_common_cis(card);\r\nif (err)\r\ngoto remove;\r\nif (oldcard) {\r\nint same = (card->cis.vendor == oldcard->cis.vendor &&\r\ncard->cis.device == oldcard->cis.device);\r\nmmc_remove_card(card);\r\nif (!same)\r\nreturn -ENOENT;\r\ncard = oldcard;\r\n}\r\nmmc_fixup_device(card, NULL);\r\nif (card->type == MMC_TYPE_SD_COMBO) {\r\nerr = mmc_sd_setup_card(host, card, oldcard != NULL);\r\nif (err) {\r\nmmc_go_idle(host);\r\nif (mmc_host_is_spi(host))\r\nmmc_spi_set_crc(host, use_spi_crc);\r\ncard->type = MMC_TYPE_SDIO;\r\n} else\r\ncard->dev.type = &sd_type;\r\n}\r\nerr = sdio_disable_cd(card);\r\nif (err)\r\ngoto remove;\r\nerr = sdio_enable_hs(card);\r\nif (err > 0)\r\nmmc_sd_go_highspeed(card);\r\nelse if (err)\r\ngoto remove;\r\nmmc_set_clock(host, mmc_sdio_get_max_clock(card));\r\nerr = sdio_enable_4bit_bus(card);\r\nif (err > 0)\r\nmmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);\r\nelse if (err)\r\ngoto remove;\r\nfinish:\r\nif (!oldcard)\r\nhost->card = card;\r\nreturn 0;\r\nremove:\r\nif (!oldcard)\r\nmmc_remove_card(card);\r\nerr:\r\nreturn err;\r\n}\r\nstatic void mmc_sdio_remove(struct mmc_host *host)\r\n{\r\nint i;\r\nBUG_ON(!host);\r\nBUG_ON(!host->card);\r\nfor (i = 0;i < host->card->sdio_funcs;i++) {\r\nif (host->card->sdio_func[i]) {\r\nsdio_remove_func(host->card->sdio_func[i]);\r\nhost->card->sdio_func[i] = NULL;\r\n}\r\n}\r\nmmc_remove_card(host->card);\r\nhost->card = NULL;\r\n}\r\nstatic void mmc_sdio_detect(struct mmc_host *host)\r\n{\r\nint err;\r\nBUG_ON(!host);\r\nBUG_ON(!host->card);\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD) {\r\nerr = pm_runtime_get_sync(&host->card->dev);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nmmc_claim_host(host);\r\nerr = mmc_select_card(host->card);\r\nmmc_release_host(host);\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD)\r\npm_runtime_put_sync(&host->card->dev);\r\nout:\r\nif (err) {\r\nmmc_sdio_remove(host);\r\nmmc_claim_host(host);\r\nmmc_detach_bus(host);\r\nmmc_release_host(host);\r\n}\r\n}\r\nstatic int mmc_sdio_suspend(struct mmc_host *host)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < host->card->sdio_funcs; i++) {\r\nstruct sdio_func *func = host->card->sdio_func[i];\r\nif (func && sdio_func_present(func) && func->dev.driver) {\r\nconst struct dev_pm_ops *pmops = func->dev.driver->pm;\r\nif (!pmops || !pmops->suspend || !pmops->resume) {\r\nerr = -ENOSYS;\r\n} else\r\nerr = pmops->suspend(&func->dev);\r\nif (err)\r\nbreak;\r\n}\r\n}\r\nwhile (err && --i >= 0) {\r\nstruct sdio_func *func = host->card->sdio_func[i];\r\nif (func && sdio_func_present(func) && func->dev.driver) {\r\nconst struct dev_pm_ops *pmops = func->dev.driver->pm;\r\npmops->resume(&func->dev);\r\n}\r\n}\r\nif (!err && mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {\r\nmmc_claim_host(host);\r\nsdio_disable_wide(host->card);\r\nmmc_release_host(host);\r\n}\r\nreturn err;\r\n}\r\nstatic int mmc_sdio_resume(struct mmc_host *host)\r\n{\r\nint i, err = 0;\r\nBUG_ON(!host);\r\nBUG_ON(!host->card);\r\nmmc_claim_host(host);\r\nif (mmc_card_is_removable(host) || !mmc_card_keep_power(host))\r\nerr = mmc_sdio_init_card(host, host->ocr, host->card,\r\nmmc_card_keep_power(host));\r\nelse if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {\r\nerr = sdio_enable_4bit_bus(host->card);\r\nif (err > 0) {\r\nmmc_set_bus_width(host, MMC_BUS_WIDTH_4);\r\nerr = 0;\r\n}\r\n}\r\nif (!err && host->sdio_irqs)\r\nmmc_signal_sdio_irq(host);\r\nmmc_release_host(host);\r\nfor (i = 0; !err && i < host->card->sdio_funcs; i++) {\r\nstruct sdio_func *func = host->card->sdio_func[i];\r\nif (func && sdio_func_present(func) && func->dev.driver) {\r\nconst struct dev_pm_ops *pmops = func->dev.driver->pm;\r\nerr = pmops->resume(&func->dev);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int mmc_sdio_power_restore(struct mmc_host *host)\r\n{\r\nint ret;\r\nu32 ocr;\r\nBUG_ON(!host);\r\nBUG_ON(!host->card);\r\nmmc_claim_host(host);\r\nsdio_reset(host);\r\nmmc_go_idle(host);\r\nmmc_send_if_cond(host, host->ocr_avail);\r\nret = mmc_send_io_op_cond(host, 0, &ocr);\r\nif (ret)\r\ngoto out;\r\nif (host->ocr_avail_sdio)\r\nhost->ocr_avail = host->ocr_avail_sdio;\r\nhost->ocr = mmc_select_voltage(host, ocr & ~0x7F);\r\nif (!host->ocr) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = mmc_sdio_init_card(host, host->ocr, host->card,\r\nmmc_card_keep_power(host));\r\nif (!ret && host->sdio_irqs)\r\nmmc_signal_sdio_irq(host);\r\nout:\r\nmmc_release_host(host);\r\nreturn ret;\r\n}\r\nint mmc_attach_sdio(struct mmc_host *host)\r\n{\r\nint err, i, funcs;\r\nu32 ocr;\r\nstruct mmc_card *card;\r\nBUG_ON(!host);\r\nWARN_ON(!host->claimed);\r\nerr = mmc_send_io_op_cond(host, 0, &ocr);\r\nif (err)\r\nreturn err;\r\nmmc_attach_bus(host, &mmc_sdio_ops);\r\nif (host->ocr_avail_sdio)\r\nhost->ocr_avail = host->ocr_avail_sdio;\r\nif (ocr & 0x7F) {\r\nprintk(KERN_WARNING "%s: card claims to support voltages "\r\n"below the defined range. These will be ignored.\n",\r\nmmc_hostname(host));\r\nocr &= ~0x7F;\r\n}\r\nhost->ocr = mmc_select_voltage(host, ocr);\r\nif (!host->ocr) {\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nerr = mmc_sdio_init_card(host, host->ocr, NULL, 0);\r\nif (err)\r\ngoto err;\r\ncard = host->card;\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD) {\r\nerr = pm_runtime_set_active(&card->dev);\r\nif (err)\r\ngoto remove;\r\npm_runtime_enable(&card->dev);\r\n}\r\nfuncs = (ocr & 0x70000000) >> 28;\r\ncard->sdio_funcs = 0;\r\nfor (i = 0; i < funcs; i++, card->sdio_funcs++) {\r\nerr = sdio_init_func(host->card, i + 1);\r\nif (err)\r\ngoto remove;\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD)\r\npm_runtime_enable(&card->sdio_func[i]->dev);\r\n}\r\nmmc_release_host(host);\r\nerr = mmc_add_card(host->card);\r\nif (err)\r\ngoto remove_added;\r\nfor (i = 0;i < funcs;i++) {\r\nerr = sdio_add_func(host->card->sdio_func[i]);\r\nif (err)\r\ngoto remove_added;\r\n}\r\nmmc_claim_host(host);\r\nreturn 0;\r\nremove_added:\r\nmmc_sdio_remove(host);\r\nmmc_claim_host(host);\r\nremove:\r\nmmc_release_host(host);\r\nif (host->card)\r\nmmc_sdio_remove(host);\r\nmmc_claim_host(host);\r\nerr:\r\nmmc_detach_bus(host);\r\nprintk(KERN_ERR "%s: error %d whilst initialising SDIO card\n",\r\nmmc_hostname(host), err);\r\nreturn err;\r\n}
