struct usb_host_interface *usb_find_alt_setting(\r\nstruct usb_host_config *config,\r\nunsigned int iface_num,\r\nunsigned int alt_num)\r\n{\r\nstruct usb_interface_cache *intf_cache = NULL;\r\nint i;\r\nfor (i = 0; i < config->desc.bNumInterfaces; i++) {\r\nif (config->intf_cache[i]->altsetting[0].desc.bInterfaceNumber\r\n== iface_num) {\r\nintf_cache = config->intf_cache[i];\r\nbreak;\r\n}\r\n}\r\nif (!intf_cache)\r\nreturn NULL;\r\nfor (i = 0; i < intf_cache->num_altsetting; i++)\r\nif (intf_cache->altsetting[i].desc.bAlternateSetting == alt_num)\r\nreturn &intf_cache->altsetting[i];\r\nprintk(KERN_DEBUG "Did not find alt setting %u for intf %u, "\r\n"config %u\n", alt_num, iface_num,\r\nconfig->desc.bConfigurationValue);\r\nreturn NULL;\r\n}\r\nstruct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,\r\nunsigned ifnum)\r\n{\r\nstruct usb_host_config *config = dev->actconfig;\r\nint i;\r\nif (!config)\r\nreturn NULL;\r\nfor (i = 0; i < config->desc.bNumInterfaces; i++)\r\nif (config->interface[i]->altsetting[0]\r\n.desc.bInterfaceNumber == ifnum)\r\nreturn config->interface[i];\r\nreturn NULL;\r\n}\r\nstruct usb_host_interface *usb_altnum_to_altsetting(\r\nconst struct usb_interface *intf,\r\nunsigned int altnum)\r\n{\r\nint i;\r\nfor (i = 0; i < intf->num_altsetting; i++) {\r\nif (intf->altsetting[i].desc.bAlternateSetting == altnum)\r\nreturn &intf->altsetting[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __find_interface(struct device *dev, void *data)\r\n{\r\nstruct find_interface_arg *arg = data;\r\nstruct usb_interface *intf;\r\nif (!is_usb_interface(dev))\r\nreturn 0;\r\nif (dev->driver != arg->drv)\r\nreturn 0;\r\nintf = to_usb_interface(dev);\r\nreturn intf->minor == arg->minor;\r\n}\r\nstruct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)\r\n{\r\nstruct find_interface_arg argb;\r\nstruct device *dev;\r\nargb.minor = minor;\r\nargb.drv = &drv->drvwrap.driver;\r\ndev = bus_find_device(&usb_bus_type, NULL, &argb, __find_interface);\r\nput_device(dev);\r\nreturn dev ? to_usb_interface(dev) : NULL;\r\n}\r\nstatic void usb_release_dev(struct device *dev)\r\n{\r\nstruct usb_device *udev;\r\nstruct usb_hcd *hcd;\r\nudev = to_usb_device(dev);\r\nhcd = bus_to_hcd(udev->bus);\r\nusb_destroy_configuration(udev);\r\nusb_put_hcd(hcd);\r\nkfree(udev->product);\r\nkfree(udev->manufacturer);\r\nkfree(udev->serial);\r\nkfree(udev);\r\n}\r\nstatic int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct usb_device *usb_dev;\r\nusb_dev = to_usb_device(dev);\r\nif (add_uevent_var(env, "BUSNUM=%03d", usb_dev->bus->busnum))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "DEVNUM=%03d", usb_dev->devnum))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int usb_dev_prepare(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void usb_dev_complete(struct device *dev)\r\n{\r\nusb_resume(dev, PMSG_ON);\r\n}\r\nstatic int usb_dev_suspend(struct device *dev)\r\n{\r\nreturn usb_suspend(dev, PMSG_SUSPEND);\r\n}\r\nstatic int usb_dev_resume(struct device *dev)\r\n{\r\nreturn usb_resume(dev, PMSG_RESUME);\r\n}\r\nstatic int usb_dev_freeze(struct device *dev)\r\n{\r\nreturn usb_suspend(dev, PMSG_FREEZE);\r\n}\r\nstatic int usb_dev_thaw(struct device *dev)\r\n{\r\nreturn usb_resume(dev, PMSG_THAW);\r\n}\r\nstatic int usb_dev_poweroff(struct device *dev)\r\n{\r\nreturn usb_suspend(dev, PMSG_HIBERNATE);\r\n}\r\nstatic int usb_dev_restore(struct device *dev)\r\n{\r\nreturn usb_resume(dev, PMSG_RESTORE);\r\n}\r\nstatic char *usb_devnode(struct device *dev, mode_t *mode)\r\n{\r\nstruct usb_device *usb_dev;\r\nusb_dev = to_usb_device(dev);\r\nreturn kasprintf(GFP_KERNEL, "bus/usb/%03d/%03d",\r\nusb_dev->bus->busnum, usb_dev->devnum);\r\n}\r\nstatic unsigned usb_bus_is_wusb(struct usb_bus *bus)\r\n{\r\nstruct usb_hcd *hcd = container_of(bus, struct usb_hcd, self);\r\nreturn hcd->wireless;\r\n}\r\nstruct usb_device *usb_alloc_dev(struct usb_device *parent,\r\nstruct usb_bus *bus, unsigned port1)\r\n{\r\nstruct usb_device *dev;\r\nstruct usb_hcd *usb_hcd = container_of(bus, struct usb_hcd, self);\r\nunsigned root_hub = 0;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nif (!usb_get_hcd(bus_to_hcd(bus))) {\r\nkfree(dev);\r\nreturn NULL;\r\n}\r\nif (usb_hcd->driver->alloc_dev && parent &&\r\n!usb_hcd->driver->alloc_dev(usb_hcd, dev)) {\r\nusb_put_hcd(bus_to_hcd(bus));\r\nkfree(dev);\r\nreturn NULL;\r\n}\r\ndevice_initialize(&dev->dev);\r\ndev->dev.bus = &usb_bus_type;\r\ndev->dev.type = &usb_device_type;\r\ndev->dev.groups = usb_device_groups;\r\ndev->dev.dma_mask = bus->controller->dma_mask;\r\nset_dev_node(&dev->dev, dev_to_node(bus->controller));\r\ndev->state = USB_STATE_ATTACHED;\r\natomic_set(&dev->urbnum, 0);\r\nINIT_LIST_HEAD(&dev->ep0.urb_list);\r\ndev->ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;\r\ndev->ep0.desc.bDescriptorType = USB_DT_ENDPOINT;\r\nusb_enable_endpoint(dev, &dev->ep0, false);\r\ndev->can_submit = 1;\r\nif (unlikely(!parent)) {\r\ndev->devpath[0] = '0';\r\ndev->route = 0;\r\ndev->dev.parent = bus->controller;\r\ndev_set_name(&dev->dev, "usb%d", bus->busnum);\r\nroot_hub = 1;\r\n} else {\r\nif (parent->devpath[0] == '0') {\r\nsnprintf(dev->devpath, sizeof dev->devpath,\r\n"%d", port1);\r\ndev->route = 0;\r\n} else {\r\nsnprintf(dev->devpath, sizeof dev->devpath,\r\n"%s.%d", parent->devpath, port1);\r\nif (port1 < 15)\r\ndev->route = parent->route +\r\n(port1 << ((parent->level - 1)*4));\r\nelse\r\ndev->route = parent->route +\r\n(15 << ((parent->level - 1)*4));\r\n}\r\ndev->dev.parent = &parent->dev;\r\ndev_set_name(&dev->dev, "%d-%s", bus->busnum, dev->devpath);\r\n}\r\ndev->portnum = port1;\r\ndev->bus = bus;\r\ndev->parent = parent;\r\nINIT_LIST_HEAD(&dev->filelist);\r\n#ifdef CONFIG_PM\r\npm_runtime_set_autosuspend_delay(&dev->dev,\r\nusb_autosuspend_delay * 1000);\r\ndev->connect_time = jiffies;\r\ndev->active_duration = -jiffies;\r\n#endif\r\nif (root_hub)\r\ndev->authorized = 1;\r\nelse {\r\ndev->authorized = usb_hcd->authorized_default;\r\ndev->wusb = usb_bus_is_wusb(bus)? 1 : 0;\r\n}\r\nreturn dev;\r\n}\r\nstruct usb_device *usb_get_dev(struct usb_device *dev)\r\n{\r\nif (dev)\r\nget_device(&dev->dev);\r\nreturn dev;\r\n}\r\nvoid usb_put_dev(struct usb_device *dev)\r\n{\r\nif (dev)\r\nput_device(&dev->dev);\r\n}\r\nstruct usb_interface *usb_get_intf(struct usb_interface *intf)\r\n{\r\nif (intf)\r\nget_device(&intf->dev);\r\nreturn intf;\r\n}\r\nvoid usb_put_intf(struct usb_interface *intf)\r\n{\r\nif (intf)\r\nput_device(&intf->dev);\r\n}\r\nint usb_lock_device_for_reset(struct usb_device *udev,\r\nconst struct usb_interface *iface)\r\n{\r\nunsigned long jiffies_expire = jiffies + HZ;\r\nif (udev->state == USB_STATE_NOTATTACHED)\r\nreturn -ENODEV;\r\nif (udev->state == USB_STATE_SUSPENDED)\r\nreturn -EHOSTUNREACH;\r\nif (iface && (iface->condition == USB_INTERFACE_UNBINDING ||\r\niface->condition == USB_INTERFACE_UNBOUND))\r\nreturn -EINTR;\r\nwhile (!usb_trylock_device(udev)) {\r\nif (time_after(jiffies, jiffies_expire))\r\nreturn -EBUSY;\r\nmsleep(15);\r\nif (udev->state == USB_STATE_NOTATTACHED)\r\nreturn -ENODEV;\r\nif (udev->state == USB_STATE_SUSPENDED)\r\nreturn -EHOSTUNREACH;\r\nif (iface && (iface->condition == USB_INTERFACE_UNBINDING ||\r\niface->condition == USB_INTERFACE_UNBOUND))\r\nreturn -EINTR;\r\n}\r\nreturn 0;\r\n}\r\nint usb_get_current_frame_number(struct usb_device *dev)\r\n{\r\nreturn usb_hcd_get_frame_number(dev);\r\n}\r\nint __usb_get_extra_descriptor(char *buffer, unsigned size,\r\nunsigned char type, void **ptr)\r\n{\r\nstruct usb_descriptor_header *header;\r\nwhile (size >= sizeof(struct usb_descriptor_header)) {\r\nheader = (struct usb_descriptor_header *)buffer;\r\nif (header->bLength < 2) {\r\nprintk(KERN_ERR\r\n"%s: bogus descriptor, type %d length %d\n",\r\nusbcore_name,\r\nheader->bDescriptorType,\r\nheader->bLength);\r\nreturn -1;\r\n}\r\nif (header->bDescriptorType == type) {\r\n*ptr = header;\r\nreturn 0;\r\n}\r\nbuffer += header->bLength;\r\nsize -= header->bLength;\r\n}\r\nreturn -1;\r\n}\r\nvoid *usb_alloc_coherent(struct usb_device *dev, size_t size, gfp_t mem_flags,\r\ndma_addr_t *dma)\r\n{\r\nif (!dev || !dev->bus)\r\nreturn NULL;\r\nreturn hcd_buffer_alloc(dev->bus, size, mem_flags, dma);\r\n}\r\nvoid usb_free_coherent(struct usb_device *dev, size_t size, void *addr,\r\ndma_addr_t dma)\r\n{\r\nif (!dev || !dev->bus)\r\nreturn;\r\nif (!addr)\r\nreturn;\r\nhcd_buffer_free(dev->bus, size, addr, dma);\r\n}\r\nint usb_disabled(void)\r\n{\r\nreturn nousb;\r\n}\r\nstatic int usb_bus_notify(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct device *dev = data;\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nif (dev->type == &usb_device_type)\r\n(void) usb_create_sysfs_dev_files(to_usb_device(dev));\r\nelse if (dev->type == &usb_if_device_type)\r\nusb_create_sysfs_intf_files(to_usb_interface(dev));\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nif (dev->type == &usb_device_type)\r\nusb_remove_sysfs_dev_files(to_usb_device(dev));\r\nelse if (dev->type == &usb_if_device_type)\r\nusb_remove_sysfs_intf_files(to_usb_interface(dev));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_debugfs_init(void)\r\n{\r\nusb_debug_root = debugfs_create_dir("usb", NULL);\r\nif (!usb_debug_root)\r\nreturn -ENOENT;\r\nusb_debug_devices = debugfs_create_file("devices", 0444,\r\nusb_debug_root, NULL,\r\n&usbfs_devices_fops);\r\nif (!usb_debug_devices) {\r\ndebugfs_remove(usb_debug_root);\r\nusb_debug_root = NULL;\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void usb_debugfs_cleanup(void)\r\n{\r\ndebugfs_remove(usb_debug_devices);\r\ndebugfs_remove(usb_debug_root);\r\n}\r\nstatic int __init usb_init(void)\r\n{\r\nint retval;\r\nif (nousb) {\r\npr_info("%s: USB support disabled\n", usbcore_name);\r\nreturn 0;\r\n}\r\nretval = usb_debugfs_init();\r\nif (retval)\r\ngoto out;\r\nretval = bus_register(&usb_bus_type);\r\nif (retval)\r\ngoto bus_register_failed;\r\nretval = bus_register_notifier(&usb_bus_type, &usb_bus_nb);\r\nif (retval)\r\ngoto bus_notifier_failed;\r\nretval = usb_major_init();\r\nif (retval)\r\ngoto major_init_failed;\r\nretval = usb_register(&usbfs_driver);\r\nif (retval)\r\ngoto driver_register_failed;\r\nretval = usb_devio_init();\r\nif (retval)\r\ngoto usb_devio_init_failed;\r\nretval = usbfs_init();\r\nif (retval)\r\ngoto fs_init_failed;\r\nretval = usb_hub_init();\r\nif (retval)\r\ngoto hub_init_failed;\r\nretval = usb_register_device_driver(&usb_generic_driver, THIS_MODULE);\r\nif (!retval)\r\ngoto out;\r\nusb_hub_cleanup();\r\nhub_init_failed:\r\nusbfs_cleanup();\r\nfs_init_failed:\r\nusb_devio_cleanup();\r\nusb_devio_init_failed:\r\nusb_deregister(&usbfs_driver);\r\ndriver_register_failed:\r\nusb_major_cleanup();\r\nmajor_init_failed:\r\nbus_unregister_notifier(&usb_bus_type, &usb_bus_nb);\r\nbus_notifier_failed:\r\nbus_unregister(&usb_bus_type);\r\nbus_register_failed:\r\nusb_debugfs_cleanup();\r\nout:\r\nreturn retval;\r\n}\r\nstatic void __exit usb_exit(void)\r\n{\r\nif (nousb)\r\nreturn;\r\nusb_deregister_device_driver(&usb_generic_driver);\r\nusb_major_cleanup();\r\nusbfs_cleanup();\r\nusb_deregister(&usbfs_driver);\r\nusb_devio_cleanup();\r\nusb_hub_cleanup();\r\nbus_unregister_notifier(&usb_bus_type, &usb_bus_nb);\r\nbus_unregister(&usb_bus_type);\r\nusb_debugfs_cleanup();\r\n}
