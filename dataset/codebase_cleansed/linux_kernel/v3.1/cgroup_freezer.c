static inline struct freezer *cgroup_freezer(\r\nstruct cgroup *cgroup)\r\n{\r\nreturn container_of(\r\ncgroup_subsys_state(cgroup, freezer_subsys_id),\r\nstruct freezer, css);\r\n}\r\nstatic inline struct freezer *task_freezer(struct task_struct *task)\r\n{\r\nreturn container_of(task_subsys_state(task, freezer_subsys_id),\r\nstruct freezer, css);\r\n}\r\nstatic inline int __cgroup_freezing_or_frozen(struct task_struct *task)\r\n{\r\nenum freezer_state state = task_freezer(task)->state;\r\nreturn (state == CGROUP_FREEZING) || (state == CGROUP_FROZEN);\r\n}\r\nint cgroup_freezing_or_frozen(struct task_struct *task)\r\n{\r\nint result;\r\ntask_lock(task);\r\nresult = __cgroup_freezing_or_frozen(task);\r\ntask_unlock(task);\r\nreturn result;\r\n}\r\nstatic struct cgroup_subsys_state *freezer_create(struct cgroup_subsys *ss,\r\nstruct cgroup *cgroup)\r\n{\r\nstruct freezer *freezer;\r\nfreezer = kzalloc(sizeof(struct freezer), GFP_KERNEL);\r\nif (!freezer)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&freezer->lock);\r\nfreezer->state = CGROUP_THAWED;\r\nreturn &freezer->css;\r\n}\r\nstatic void freezer_destroy(struct cgroup_subsys *ss,\r\nstruct cgroup *cgroup)\r\n{\r\nkfree(cgroup_freezer(cgroup));\r\n}\r\nstatic int freezer_can_attach(struct cgroup_subsys *ss,\r\nstruct cgroup *new_cgroup,\r\nstruct task_struct *task)\r\n{\r\nstruct freezer *freezer;\r\nfreezer = cgroup_freezer(new_cgroup);\r\nif (freezer->state != CGROUP_THAWED)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int freezer_can_attach_task(struct cgroup *cgrp, struct task_struct *tsk)\r\n{\r\nrcu_read_lock();\r\nif (__cgroup_freezing_or_frozen(tsk)) {\r\nrcu_read_unlock();\r\nreturn -EBUSY;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic void freezer_fork(struct cgroup_subsys *ss, struct task_struct *task)\r\n{\r\nstruct freezer *freezer;\r\nrcu_read_lock();\r\nfreezer = task_freezer(task);\r\nrcu_read_unlock();\r\nif (!freezer->css.cgroup->parent)\r\nreturn;\r\nspin_lock_irq(&freezer->lock);\r\nBUG_ON(freezer->state == CGROUP_FROZEN);\r\nif (freezer->state == CGROUP_FREEZING)\r\nfreeze_task(task, true);\r\nspin_unlock_irq(&freezer->lock);\r\n}\r\nstatic void update_if_frozen(struct cgroup *cgroup,\r\nstruct freezer *freezer)\r\n{\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\nunsigned int nfrozen = 0, ntotal = 0;\r\nenum freezer_state old_state = freezer->state;\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it))) {\r\nntotal++;\r\nif (frozen(task))\r\nnfrozen++;\r\n}\r\nif (old_state == CGROUP_THAWED) {\r\nBUG_ON(nfrozen > 0);\r\n} else if (old_state == CGROUP_FREEZING) {\r\nif (nfrozen == ntotal)\r\nfreezer->state = CGROUP_FROZEN;\r\n} else {\r\nBUG_ON(nfrozen != ntotal);\r\n}\r\ncgroup_iter_end(cgroup, &it);\r\n}\r\nstatic int freezer_read(struct cgroup *cgroup, struct cftype *cft,\r\nstruct seq_file *m)\r\n{\r\nstruct freezer *freezer;\r\nenum freezer_state state;\r\nif (!cgroup_lock_live_group(cgroup))\r\nreturn -ENODEV;\r\nfreezer = cgroup_freezer(cgroup);\r\nspin_lock_irq(&freezer->lock);\r\nstate = freezer->state;\r\nif (state == CGROUP_FREEZING) {\r\nupdate_if_frozen(cgroup, freezer);\r\nstate = freezer->state;\r\n}\r\nspin_unlock_irq(&freezer->lock);\r\ncgroup_unlock();\r\nseq_puts(m, freezer_state_strs[state]);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int try_to_freeze_cgroup(struct cgroup *cgroup, struct freezer *freezer)\r\n{\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\nunsigned int num_cant_freeze_now = 0;\r\nfreezer->state = CGROUP_FREEZING;\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it))) {\r\nif (!freeze_task(task, true))\r\ncontinue;\r\nif (frozen(task))\r\ncontinue;\r\nif (!freezing(task) && !freezer_should_skip(task))\r\nnum_cant_freeze_now++;\r\n}\r\ncgroup_iter_end(cgroup, &it);\r\nreturn num_cant_freeze_now ? -EBUSY : 0;\r\n}\r\nstatic void unfreeze_cgroup(struct cgroup *cgroup, struct freezer *freezer)\r\n{\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it))) {\r\nthaw_process(task);\r\n}\r\ncgroup_iter_end(cgroup, &it);\r\nfreezer->state = CGROUP_THAWED;\r\n}\r\nstatic int freezer_change_state(struct cgroup *cgroup,\r\nenum freezer_state goal_state)\r\n{\r\nstruct freezer *freezer;\r\nint retval = 0;\r\nfreezer = cgroup_freezer(cgroup);\r\nspin_lock_irq(&freezer->lock);\r\nupdate_if_frozen(cgroup, freezer);\r\nif (goal_state == freezer->state)\r\ngoto out;\r\nswitch (goal_state) {\r\ncase CGROUP_THAWED:\r\nunfreeze_cgroup(cgroup, freezer);\r\nbreak;\r\ncase CGROUP_FROZEN:\r\nretval = try_to_freeze_cgroup(cgroup, freezer);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nout:\r\nspin_unlock_irq(&freezer->lock);\r\nreturn retval;\r\n}\r\nstatic int freezer_write(struct cgroup *cgroup,\r\nstruct cftype *cft,\r\nconst char *buffer)\r\n{\r\nint retval;\r\nenum freezer_state goal_state;\r\nif (strcmp(buffer, freezer_state_strs[CGROUP_THAWED]) == 0)\r\ngoal_state = CGROUP_THAWED;\r\nelse if (strcmp(buffer, freezer_state_strs[CGROUP_FROZEN]) == 0)\r\ngoal_state = CGROUP_FROZEN;\r\nelse\r\nreturn -EINVAL;\r\nif (!cgroup_lock_live_group(cgroup))\r\nreturn -ENODEV;\r\nretval = freezer_change_state(cgroup, goal_state);\r\ncgroup_unlock();\r\nreturn retval;\r\n}\r\nstatic int freezer_populate(struct cgroup_subsys *ss, struct cgroup *cgroup)\r\n{\r\nif (!cgroup->parent)\r\nreturn 0;\r\nreturn cgroup_add_files(cgroup, ss, files, ARRAY_SIZE(files));\r\n}
