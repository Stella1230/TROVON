static void ssu100_release(struct usb_serial *serial)\r\n{\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(*serial->port);\r\ndbg("%s", __func__);\r\nkfree(priv);\r\n}\r\nstatic inline int ssu100_control_msg(struct usb_device *dev,\r\nu8 request, u16 data, u16 index)\r\n{\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nrequest, 0x40, data, index,\r\nNULL, 0, 300);\r\n}\r\nstatic inline int ssu100_setdevice(struct usb_device *dev, u8 *data)\r\n{\r\nu16 x = ((u16)(data[1] << 8) | (u16)(data[0]));\r\nreturn ssu100_control_msg(dev, QT_SET_GET_DEVICE, x, 0);\r\n}\r\nstatic inline int ssu100_getdevice(struct usb_device *dev, u8 *data)\r\n{\r\nreturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nQT_SET_GET_DEVICE, 0xc0, 0, 0,\r\ndata, 3, 300);\r\n}\r\nstatic inline int ssu100_getregister(struct usb_device *dev,\r\nunsigned short uart,\r\nunsigned short reg,\r\nu8 *data)\r\n{\r\nreturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nQT_SET_GET_REGISTER, 0xc0, reg,\r\nuart, data, sizeof(*data), 300);\r\n}\r\nstatic inline int ssu100_setregister(struct usb_device *dev,\r\nunsigned short uart,\r\nunsigned short reg,\r\nu16 data)\r\n{\r\nu16 value = (data << 8) | reg;\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nQT_SET_GET_REGISTER, 0x40, value, uart,\r\nNULL, 0, 300);\r\n}\r\nstatic inline int update_mctrl(struct usb_device *dev, unsigned int set,\r\nunsigned int clear)\r\n{\r\nunsigned urb_value;\r\nint result;\r\nif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {\r\ndbg("%s - DTR|RTS not being set|cleared", __func__);\r\nreturn 0;\r\n}\r\nclear &= ~set;\r\nurb_value = 0;\r\nif (set & TIOCM_DTR)\r\nurb_value |= UART_MCR_DTR;\r\nif (set & TIOCM_RTS)\r\nurb_value |= UART_MCR_RTS;\r\nresult = ssu100_setregister(dev, 0, UART_MCR, urb_value);\r\nif (result < 0)\r\ndbg("%s Error from MODEM_CTRL urb", __func__);\r\nreturn result;\r\n}\r\nstatic int ssu100_initdevice(struct usb_device *dev)\r\n{\r\nu8 *data;\r\nint result = 0;\r\ndbg("%s", __func__);\r\ndata = kzalloc(3, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nresult = ssu100_getdevice(dev, data);\r\nif (result < 0) {\r\ndbg("%s - get_device failed %i", __func__, result);\r\ngoto out;\r\n}\r\ndata[1] &= ~FULLPWRBIT;\r\nresult = ssu100_setdevice(dev, data);\r\nif (result < 0) {\r\ndbg("%s - setdevice failed %i", __func__, result);\r\ngoto out;\r\n}\r\nresult = ssu100_control_msg(dev, QT_GET_SET_PREBUF_TRIG_LVL, 128, 0);\r\nif (result < 0) {\r\ndbg("%s - set prebuffer level failed %i", __func__, result);\r\ngoto out;\r\n}\r\nresult = ssu100_control_msg(dev, QT_SET_ATF, ATC_DISABLED, 0);\r\nif (result < 0) {\r\ndbg("%s - set ATFprebuffer level failed %i", __func__, result);\r\ngoto out;\r\n}\r\nresult = ssu100_getdevice(dev, data);\r\nif (result < 0) {\r\ndbg("%s - get_device failed %i", __func__, result);\r\ngoto out;\r\n}\r\ndata[0] &= ~(RR_BITS | DUPMODE_BITS);\r\ndata[0] |= CLKS_X4;\r\ndata[1] &= ~(LOOPMODE_BITS);\r\ndata[1] |= RS232_MODE;\r\nresult = ssu100_setdevice(dev, data);\r\nif (result < 0) {\r\ndbg("%s - setdevice failed %i", __func__, result);\r\ngoto out;\r\n}\r\nout: kfree(data);\r\nreturn result;\r\n}\r\nstatic void ssu100_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct ktermios *termios = tty->termios;\r\nu16 baud, divisor, remainder;\r\nunsigned int cflag = termios->c_cflag;\r\nu16 urb_value = 0;\r\nint result;\r\ndbg("%s", __func__);\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\nurb_value |= UART_LCR_PARITY;\r\nelse\r\nurb_value |= SERIAL_EVEN_PARITY;\r\n}\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nurb_value |= UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nurb_value |= UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nurb_value |= UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nurb_value |= UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\ndbg("%s - got baud = %d\n", __func__, baud);\r\ndivisor = MAX_BAUD_RATE / baud;\r\nremainder = MAX_BAUD_RATE % baud;\r\nif (((remainder * 2) >= baud) && (baud != 110))\r\ndivisor++;\r\nurb_value = urb_value << 8;\r\nresult = ssu100_control_msg(dev, QT_GET_SET_UART, divisor, urb_value);\r\nif (result < 0)\r\ndbg("%s - set uart failed", __func__);\r\nif (cflag & CRTSCTS)\r\nresult = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\r\nSERIAL_CRTSCTS, 0);\r\nelse\r\nresult = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\r\n0, 0);\r\nif (result < 0)\r\ndbg("%s - set HW flow control failed", __func__);\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nu16 x = ((u16)(START_CHAR(tty) << 8) | (u16)(STOP_CHAR(tty)));\r\nresult = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\r\nx, 0);\r\n} else\r\nresult = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\r\n0, 0);\r\nif (result < 0)\r\ndbg("%s - set SW flow control failed", __func__);\r\n}\r\nstatic int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\r\nu8 *data;\r\nint result;\r\nunsigned long flags;\r\ndbg("%s - port %d", __func__, port->number);\r\ndata = kzalloc(2, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nQT_OPEN_CLOSE_CHANNEL,\r\nQT_TRANSFER_IN, 0x01,\r\n0, data, 2, 300);\r\nif (result < 0) {\r\ndbg("%s - open failed %i", __func__, result);\r\nkfree(data);\r\nreturn result;\r\n}\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\npriv->shadowLSR = data[0];\r\npriv->shadowMSR = data[1];\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nkfree(data);\r\nresult = ssu100_control_msg(dev, QT_GET_SET_UART, 0x30, 0x0300);\r\nif (result < 0)\r\ndbg("%s - set uart failed", __func__);\r\nif (tty)\r\nssu100_set_termios(tty, port, tty->termios);\r\nreturn usb_serial_generic_open(tty, port);\r\n}\r\nstatic void ssu100_close(struct usb_serial_port *port)\r\n{\r\ndbg("%s", __func__);\r\nusb_serial_generic_close(port);\r\n}\r\nstatic int get_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.line = port->serial->minor;\r\ntmp.port = 0;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = port->bulk_out_size;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = 30*HZ;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int wait_modem_info(struct usb_serial_port *port, unsigned int arg)\r\n{\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\r\nstruct async_icount prev, cur;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\nprev = priv->icount;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nwhile (1) {\r\nwait_event_interruptible(priv->delta_msr_wait,\r\n((priv->icount.rng != prev.rng) ||\r\n(priv->icount.dsr != prev.dsr) ||\r\n(priv->icount.dcd != prev.dcd) ||\r\n(priv->icount.cts != prev.cts)));\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\ncur = priv->icount;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nif ((prev.rng == cur.rng) &&\r\n(prev.dsr == cur.dsr) &&\r\n(prev.dcd == cur.dcd) &&\r\n(prev.cts == cur.cts))\r\nreturn -EIO;\r\nif ((arg & TIOCM_RNG && (prev.rng != cur.rng)) ||\r\n(arg & TIOCM_DSR && (prev.dsr != cur.dsr)) ||\r\n(arg & TIOCM_CD && (prev.dcd != cur.dcd)) ||\r\n(arg & TIOCM_CTS && (prev.cts != cur.cts)))\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssu100_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\r\nstruct async_icount cnow = priv->icount;\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int ssu100_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndbg("%s cmd 0x%04x", __func__, cmd);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(port,\r\n(struct serial_struct __user *) arg);\r\ncase TIOCMIWAIT:\r\nreturn wait_modem_info(port, arg);\r\ndefault:\r\nbreak;\r\n}\r\ndbg("%s arg not supported", __func__);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int ssu100_attach(struct usb_serial *serial)\r\n{\r\nstruct ssu100_port_private *priv;\r\nstruct usb_serial_port *port = *serial->port;\r\ndbg("%s", __func__);\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&port->dev, "%s- kmalloc(%Zd) failed.\n", __func__,\r\nsizeof(*priv));\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&priv->status_lock);\r\ninit_waitqueue_head(&priv->delta_msr_wait);\r\nusb_set_serial_port_data(port, priv);\r\nreturn ssu100_initdevice(serial->dev);\r\n}\r\nstatic int ssu100_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_device *dev = port->serial->dev;\r\nu8 *d;\r\nint r;\r\ndbg("%s\n", __func__);\r\nd = kzalloc(2, GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nr = ssu100_getregister(dev, 0, UART_MCR, d);\r\nif (r < 0)\r\ngoto mget_out;\r\nr = ssu100_getregister(dev, 0, UART_MSR, d+1);\r\nif (r < 0)\r\ngoto mget_out;\r\nr = (d[0] & UART_MCR_DTR ? TIOCM_DTR : 0) |\r\n(d[0] & UART_MCR_RTS ? TIOCM_RTS : 0) |\r\n(d[1] & UART_MSR_CTS ? TIOCM_CTS : 0) |\r\n(d[1] & UART_MSR_DCD ? TIOCM_CAR : 0) |\r\n(d[1] & UART_MSR_RI ? TIOCM_RI : 0) |\r\n(d[1] & UART_MSR_DSR ? TIOCM_DSR : 0);\r\nmget_out:\r\nkfree(d);\r\nreturn r;\r\n}\r\nstatic int ssu100_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_device *dev = port->serial->dev;\r\ndbg("%s\n", __func__);\r\nreturn update_mctrl(dev, set, clear);\r\n}\r\nstatic void ssu100_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\ndbg("%s\n", __func__);\r\nmutex_lock(&port->serial->disc_mutex);\r\nif (!port->serial->disconnected) {\r\nif (!on &&\r\nssu100_setregister(dev, 0, UART_MCR, 0) < 0)\r\ndev_err(&port->dev, "error from flowcontrol urb\n");\r\nif (on)\r\nset_mctrl(dev, TIOCM_DTR | TIOCM_RTS);\r\nelse\r\nclear_mctrl(dev, TIOCM_DTR | TIOCM_RTS);\r\n}\r\nmutex_unlock(&port->serial->disc_mutex);\r\n}\r\nstatic void ssu100_update_msr(struct usb_serial_port *port, u8 msr)\r\n{\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\npriv->shadowMSR = msr;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nif (msr & UART_MSR_ANY_DELTA) {\r\nif (msr & UART_MSR_DCTS)\r\npriv->icount.cts++;\r\nif (msr & UART_MSR_DDSR)\r\npriv->icount.dsr++;\r\nif (msr & UART_MSR_DDCD)\r\npriv->icount.dcd++;\r\nif (msr & UART_MSR_TERI)\r\npriv->icount.rng++;\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\n}\r\n}\r\nstatic void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,\r\nchar *tty_flag)\r\n{\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\npriv->shadowLSR = lsr;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\n*tty_flag = TTY_NORMAL;\r\nif (lsr & UART_LSR_BRK_ERROR_BITS) {\r\nif (lsr & UART_LSR_BI) {\r\npriv->icount.brk++;\r\n*tty_flag = TTY_BREAK;\r\nusb_serial_handle_break(port);\r\n}\r\nif (lsr & UART_LSR_PE) {\r\npriv->icount.parity++;\r\nif (*tty_flag == TTY_NORMAL)\r\n*tty_flag = TTY_PARITY;\r\n}\r\nif (lsr & UART_LSR_FE) {\r\npriv->icount.frame++;\r\nif (*tty_flag == TTY_NORMAL)\r\n*tty_flag = TTY_FRAME;\r\n}\r\nif (lsr & UART_LSR_OE){\r\npriv->icount.overrun++;\r\nif (*tty_flag == TTY_NORMAL)\r\n*tty_flag = TTY_OVERRUN;\r\n}\r\n}\r\n}\r\nstatic int ssu100_process_packet(struct urb *urb,\r\nstruct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nchar *packet = (char *)urb->transfer_buffer;\r\nchar flag = TTY_NORMAL;\r\nu32 len = urb->actual_length;\r\nint i;\r\nchar *ch;\r\ndbg("%s - port %d", __func__, port->number);\r\nif ((len >= 4) &&\r\n(packet[0] == 0x1b) && (packet[1] == 0x1b) &&\r\n((packet[2] == 0x00) || (packet[2] == 0x01))) {\r\nif (packet[2] == 0x00) {\r\nssu100_update_lsr(port, packet[3], &flag);\r\nif (flag == TTY_OVERRUN)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\n}\r\nif (packet[2] == 0x01)\r\nssu100_update_msr(port, packet[3]);\r\nlen -= 4;\r\nch = packet + 4;\r\n} else\r\nch = packet;\r\nif (!len)\r\nreturn 0;\r\nif (port->port.console && port->sysrq) {\r\nfor (i = 0; i < len; i++, ch++) {\r\nif (!usb_serial_handle_sysrq_char(port, *ch))\r\ntty_insert_flip_char(tty, *ch, flag);\r\n}\r\n} else\r\ntty_insert_flip_string_fixed_flag(tty, ch, flag, len);\r\nreturn len;\r\n}\r\nstatic void ssu100_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct tty_struct *tty;\r\nint count;\r\ndbg("%s", __func__);\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn;\r\ncount = ssu100_process_packet(urb, tty);\r\nif (count)\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int __init ssu100_init(void)\r\n{\r\nint retval;\r\ndbg("%s", __func__);\r\nretval = usb_serial_register(&ssu100_device);\r\nif (retval)\r\ngoto failed_usb_sio_register;\r\nretval = usb_register(&ssu100_driver);\r\nif (retval)\r\ngoto failed_usb_register;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nreturn 0;\r\nfailed_usb_register:\r\nusb_serial_deregister(&ssu100_device);\r\nfailed_usb_sio_register:\r\nreturn retval;\r\n}\r\nstatic void __exit ssu100_exit(void)\r\n{\r\nusb_deregister(&ssu100_driver);\r\nusb_serial_deregister(&ssu100_device);\r\n}
