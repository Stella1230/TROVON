static inline unsigned int ak4535_read_reg_cache(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg >= AK4535_CACHEREGNUM)\r\nreturn -1;\r\nreturn cache[reg];\r\n}\r\nstatic inline void ak4535_write_reg_cache(struct snd_soc_codec *codec,\r\nu16 reg, unsigned int value)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg >= AK4535_CACHEREGNUM)\r\nreturn;\r\ncache[reg] = value;\r\n}\r\nstatic int ak4535_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nu8 data[2];\r\ndata[0] = reg & 0xff;\r\ndata[1] = value & 0xff;\r\nak4535_write_reg_cache(codec, reg, value);\r\nif (codec->hw_write(codec->control_data, data, 2) == 2)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int ak4535_sync(struct snd_soc_codec *codec)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nint i, r = 0;\r\nfor (i = 0; i < AK4535_CACHEREGNUM; i++)\r\nr |= ak4535_write(codec, i, cache[i]);\r\nreturn r;\r\n}\r\nstatic int ak4535_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct ak4535_priv *ak4535 = snd_soc_codec_get_drvdata(codec);\r\nak4535->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int ak4535_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nstruct ak4535_priv *ak4535 = snd_soc_codec_get_drvdata(codec);\r\nu8 mode2 = ak4535_read_reg_cache(codec, AK4535_MODE2) & ~(0x3 << 5);\r\nint rate = params_rate(params), fs = 256;\r\nif (rate)\r\nfs = ak4535->sysclk / rate;\r\nswitch (fs) {\r\ncase 1024:\r\nmode2 |= (0x2 << 5);\r\nbreak;\r\ncase 512:\r\nmode2 |= (0x1 << 5);\r\nbreak;\r\ncase 256:\r\nbreak;\r\n}\r\nak4535_write(codec, AK4535_MODE2, mode2);\r\nreturn 0;\r\n}\r\nstatic int ak4535_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 mode1 = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nmode1 = 0x0002;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nmode1 = 0x0001;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmode1 |= 0x4;\r\nak4535_write(codec, AK4535_MODE1, mode1);\r\nreturn 0;\r\n}\r\nstatic int ak4535_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 mute_reg = ak4535_read_reg_cache(codec, AK4535_DAC);\r\nif (!mute)\r\nak4535_write(codec, AK4535_DAC, mute_reg & ~0x20);\r\nelse\r\nak4535_write(codec, AK4535_DAC, mute_reg | 0x20);\r\nreturn 0;\r\n}\r\nstatic int ak4535_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 i, mute_reg;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nmute_reg = ak4535_read_reg_cache(codec, AK4535_DAC);\r\nak4535_write(codec, AK4535_DAC, mute_reg & ~0x20);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nmute_reg = ak4535_read_reg_cache(codec, AK4535_DAC);\r\nak4535_write(codec, AK4535_DAC, mute_reg | 0x20);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\ni = ak4535_read_reg_cache(codec, AK4535_PM1);\r\nak4535_write(codec, AK4535_PM1, i | 0x80);\r\ni = ak4535_read_reg_cache(codec, AK4535_PM2);\r\nak4535_write(codec, AK4535_PM2, i & (~0x80));\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\ni = ak4535_read_reg_cache(codec, AK4535_PM1);\r\nak4535_write(codec, AK4535_PM1, i & (~0x80));\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int ak4535_suspend(struct snd_soc_codec *codec, pm_message_t state)\r\n{\r\nak4535_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int ak4535_resume(struct snd_soc_codec *codec)\r\n{\r\nak4535_sync(codec);\r\nak4535_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int ak4535_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4535_priv *ak4535 = snd_soc_codec_get_drvdata(codec);\r\nprintk(KERN_INFO "AK4535 Audio Codec %s", AK4535_VERSION);\r\ncodec->control_data = ak4535->control_data;\r\nak4535_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_add_controls(codec, ak4535_snd_controls,\r\nARRAY_SIZE(ak4535_snd_controls));\r\nreturn 0;\r\n}\r\nstatic int ak4535_remove(struct snd_soc_codec *codec)\r\n{\r\nak4535_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic __devinit int ak4535_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ak4535_priv *ak4535;\r\nint ret;\r\nak4535 = kzalloc(sizeof(struct ak4535_priv), GFP_KERNEL);\r\nif (ak4535 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, ak4535);\r\nak4535->control_data = i2c;\r\nak4535->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_ak4535, &ak4535_dai, 1);\r\nif (ret < 0)\r\nkfree(ak4535);\r\nreturn ret;\r\n}\r\nstatic __devexit int ak4535_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int __init ak4535_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&ak4535_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register AK4535 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit ak4535_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&ak4535_i2c_driver);\r\n#endif\r\n}
