static void pps_add_offset(struct pps_ktime *ts, struct pps_ktime *offset)\r\n{\r\nts->nsec += offset->nsec;\r\nwhile (ts->nsec >= NSEC_PER_SEC) {\r\nts->nsec -= NSEC_PER_SEC;\r\nts->sec++;\r\n}\r\nwhile (ts->nsec < 0) {\r\nts->nsec += NSEC_PER_SEC;\r\nts->sec--;\r\n}\r\nts->sec += offset->sec;\r\n}\r\nstruct pps_device *pps_register_source(struct pps_source_info *info,\r\nint default_params)\r\n{\r\nstruct pps_device *pps;\r\nint err;\r\nif ((info->mode & default_params) != default_params) {\r\npr_err("%s: unsupported default parameters\n",\r\ninfo->name);\r\nerr = -EINVAL;\r\ngoto pps_register_source_exit;\r\n}\r\nif ((info->mode & (PPS_ECHOASSERT | PPS_ECHOCLEAR)) != 0 &&\r\ninfo->echo == NULL) {\r\npr_err("%s: echo function is not defined\n",\r\ninfo->name);\r\nerr = -EINVAL;\r\ngoto pps_register_source_exit;\r\n}\r\nif ((info->mode & (PPS_TSFMT_TSPEC | PPS_TSFMT_NTPFP)) == 0) {\r\npr_err("%s: unspecified time format\n",\r\ninfo->name);\r\nerr = -EINVAL;\r\ngoto pps_register_source_exit;\r\n}\r\npps = kzalloc(sizeof(struct pps_device), GFP_KERNEL);\r\nif (pps == NULL) {\r\nerr = -ENOMEM;\r\ngoto pps_register_source_exit;\r\n}\r\npps->params.api_version = PPS_API_VERS;\r\npps->params.mode = default_params;\r\npps->info = *info;\r\ninit_waitqueue_head(&pps->queue);\r\nspin_lock_init(&pps->lock);\r\nerr = pps_register_cdev(pps);\r\nif (err < 0) {\r\npr_err("%s: unable to create char device\n",\r\ninfo->name);\r\ngoto kfree_pps;\r\n}\r\ndev_info(pps->dev, "new PPS source %s\n", info->name);\r\nreturn pps;\r\nkfree_pps:\r\nkfree(pps);\r\npps_register_source_exit:\r\npr_err("%s: unable to register source\n", info->name);\r\nreturn NULL;\r\n}\r\nvoid pps_unregister_source(struct pps_device *pps)\r\n{\r\npps_kc_remove(pps);\r\npps_unregister_cdev(pps);\r\n}\r\nvoid pps_event(struct pps_device *pps, struct pps_event_time *ts, int event,\r\nvoid *data)\r\n{\r\nunsigned long flags;\r\nint captured = 0;\r\nstruct pps_ktime ts_real = { .sec = 0, .nsec = 0, .flags = 0 };\r\nBUG_ON((event & (PPS_CAPTUREASSERT | PPS_CAPTURECLEAR)) == 0);\r\ndev_dbg(pps->dev, "PPS event at %ld.%09ld\n",\r\nts->ts_real.tv_sec, ts->ts_real.tv_nsec);\r\ntimespec_to_pps_ktime(&ts_real, ts->ts_real);\r\nspin_lock_irqsave(&pps->lock, flags);\r\nif ((pps->params.mode & (PPS_ECHOASSERT | PPS_ECHOCLEAR)))\r\npps->info.echo(pps, event, data);\r\npps->current_mode = pps->params.mode;\r\nif (event & pps->params.mode & PPS_CAPTUREASSERT) {\r\nif (pps->params.mode & PPS_OFFSETASSERT)\r\npps_add_offset(&ts_real,\r\n&pps->params.assert_off_tu);\r\npps->assert_tu = ts_real;\r\npps->assert_sequence++;\r\ndev_dbg(pps->dev, "capture assert seq #%u\n",\r\npps->assert_sequence);\r\ncaptured = ~0;\r\n}\r\nif (event & pps->params.mode & PPS_CAPTURECLEAR) {\r\nif (pps->params.mode & PPS_OFFSETCLEAR)\r\npps_add_offset(&ts_real,\r\n&pps->params.clear_off_tu);\r\npps->clear_tu = ts_real;\r\npps->clear_sequence++;\r\ndev_dbg(pps->dev, "capture clear seq #%u\n",\r\npps->clear_sequence);\r\ncaptured = ~0;\r\n}\r\npps_kc_event(pps, ts, event);\r\nif (captured) {\r\npps->last_ev++;\r\nwake_up_interruptible_all(&pps->queue);\r\nkill_fasync(&pps->async_queue, SIGIO, POLL_IN);\r\n}\r\nspin_unlock_irqrestore(&pps->lock, flags);\r\n}
