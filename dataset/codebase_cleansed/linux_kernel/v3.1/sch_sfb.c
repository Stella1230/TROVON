static inline struct sfb_skb_cb *sfb_skb_cb(const struct sk_buff *skb)\r\n{\r\nBUILD_BUG_ON(sizeof(skb->cb) <\r\nsizeof(struct qdisc_skb_cb) + sizeof(struct sfb_skb_cb));\r\nreturn (struct sfb_skb_cb *)qdisc_skb_cb(skb)->data;\r\n}\r\nstatic u32 sfb_hash(const struct sk_buff *skb, u32 slot)\r\n{\r\nreturn sfb_skb_cb(skb)->hashes[slot];\r\n}\r\nstatic u32 prob_plus(u32 p1, u32 p2)\r\n{\r\nu32 res = p1 + p2;\r\nreturn min_t(u32, res, SFB_MAX_PROB);\r\n}\r\nstatic u32 prob_minus(u32 p1, u32 p2)\r\n{\r\nreturn p1 > p2 ? p1 - p2 : 0;\r\n}\r\nstatic void increment_one_qlen(u32 sfbhash, u32 slot, struct sfb_sched_data *q)\r\n{\r\nint i;\r\nstruct sfb_bucket *b = &q->bins[slot].bins[0][0];\r\nfor (i = 0; i < SFB_LEVELS; i++) {\r\nu32 hash = sfbhash & SFB_BUCKET_MASK;\r\nsfbhash >>= SFB_BUCKET_SHIFT;\r\nif (b[hash].qlen < 0xFFFF)\r\nb[hash].qlen++;\r\nb += SFB_NUMBUCKETS;\r\n}\r\n}\r\nstatic void increment_qlen(const struct sk_buff *skb, struct sfb_sched_data *q)\r\n{\r\nu32 sfbhash;\r\nsfbhash = sfb_hash(skb, 0);\r\nif (sfbhash)\r\nincrement_one_qlen(sfbhash, 0, q);\r\nsfbhash = sfb_hash(skb, 1);\r\nif (sfbhash)\r\nincrement_one_qlen(sfbhash, 1, q);\r\n}\r\nstatic void decrement_one_qlen(u32 sfbhash, u32 slot,\r\nstruct sfb_sched_data *q)\r\n{\r\nint i;\r\nstruct sfb_bucket *b = &q->bins[slot].bins[0][0];\r\nfor (i = 0; i < SFB_LEVELS; i++) {\r\nu32 hash = sfbhash & SFB_BUCKET_MASK;\r\nsfbhash >>= SFB_BUCKET_SHIFT;\r\nif (b[hash].qlen > 0)\r\nb[hash].qlen--;\r\nb += SFB_NUMBUCKETS;\r\n}\r\n}\r\nstatic void decrement_qlen(const struct sk_buff *skb, struct sfb_sched_data *q)\r\n{\r\nu32 sfbhash;\r\nsfbhash = sfb_hash(skb, 0);\r\nif (sfbhash)\r\ndecrement_one_qlen(sfbhash, 0, q);\r\nsfbhash = sfb_hash(skb, 1);\r\nif (sfbhash)\r\ndecrement_one_qlen(sfbhash, 1, q);\r\n}\r\nstatic void decrement_prob(struct sfb_bucket *b, struct sfb_sched_data *q)\r\n{\r\nb->p_mark = prob_minus(b->p_mark, q->decrement);\r\n}\r\nstatic void increment_prob(struct sfb_bucket *b, struct sfb_sched_data *q)\r\n{\r\nb->p_mark = prob_plus(b->p_mark, q->increment);\r\n}\r\nstatic void sfb_zero_all_buckets(struct sfb_sched_data *q)\r\n{\r\nmemset(&q->bins, 0, sizeof(q->bins));\r\n}\r\nstatic u32 sfb_compute_qlen(u32 *prob_r, u32 *avgpm_r, const struct sfb_sched_data *q)\r\n{\r\nint i;\r\nu32 qlen = 0, prob = 0, totalpm = 0;\r\nconst struct sfb_bucket *b = &q->bins[q->slot].bins[0][0];\r\nfor (i = 0; i < SFB_LEVELS * SFB_NUMBUCKETS; i++) {\r\nif (qlen < b->qlen)\r\nqlen = b->qlen;\r\ntotalpm += b->p_mark;\r\nif (prob < b->p_mark)\r\nprob = b->p_mark;\r\nb++;\r\n}\r\n*prob_r = prob;\r\n*avgpm_r = totalpm / (SFB_LEVELS * SFB_NUMBUCKETS);\r\nreturn qlen;\r\n}\r\nstatic void sfb_init_perturbation(u32 slot, struct sfb_sched_data *q)\r\n{\r\nq->bins[slot].perturbation = net_random();\r\n}\r\nstatic void sfb_swap_slot(struct sfb_sched_data *q)\r\n{\r\nsfb_init_perturbation(q->slot, q);\r\nq->slot ^= 1;\r\nq->double_buffering = false;\r\n}\r\nstatic bool sfb_rate_limit(struct sk_buff *skb, struct sfb_sched_data *q)\r\n{\r\nif (q->penalty_rate == 0 || q->penalty_burst == 0)\r\nreturn true;\r\nif (q->tokens_avail < 1) {\r\nunsigned long age = min(10UL * HZ, jiffies - q->token_time);\r\nq->tokens_avail = (age * q->penalty_rate) / HZ;\r\nif (q->tokens_avail > q->penalty_burst)\r\nq->tokens_avail = q->penalty_burst;\r\nq->token_time = jiffies;\r\nif (q->tokens_avail < 1)\r\nreturn true;\r\n}\r\nq->tokens_avail--;\r\nreturn false;\r\n}\r\nstatic bool sfb_classify(struct sk_buff *skb, struct sfb_sched_data *q,\r\nint *qerr, u32 *salt)\r\n{\r\nstruct tcf_result res;\r\nint result;\r\nresult = tc_classify(skb, q->filter_list, &res);\r\nif (result >= 0) {\r\n#ifdef CONFIG_NET_CLS_ACT\r\nswitch (result) {\r\ncase TC_ACT_STOLEN:\r\ncase TC_ACT_QUEUED:\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\r\ncase TC_ACT_SHOT:\r\nreturn false;\r\n}\r\n#endif\r\n*salt = TC_H_MIN(res.classid);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *child = q->qdisc;\r\nint i;\r\nu32 p_min = ~0;\r\nu32 minqlen = ~0;\r\nu32 r, slot, salt, sfbhash;\r\nint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\r\nif (q->rehash_interval > 0) {\r\nunsigned long limit = q->rehash_time + q->rehash_interval;\r\nif (unlikely(time_after(jiffies, limit))) {\r\nsfb_swap_slot(q);\r\nq->rehash_time = jiffies;\r\n} else if (unlikely(!q->double_buffering && q->warmup_time > 0 &&\r\ntime_after(jiffies, limit - q->warmup_time))) {\r\nq->double_buffering = true;\r\n}\r\n}\r\nif (q->filter_list) {\r\nif (!sfb_classify(skb, q, &ret, &salt))\r\ngoto other_drop;\r\n} else {\r\nsalt = skb_get_rxhash(skb);\r\n}\r\nslot = q->slot;\r\nsfbhash = jhash_1word(salt, q->bins[slot].perturbation);\r\nif (!sfbhash)\r\nsfbhash = 1;\r\nsfb_skb_cb(skb)->hashes[slot] = sfbhash;\r\nfor (i = 0; i < SFB_LEVELS; i++) {\r\nu32 hash = sfbhash & SFB_BUCKET_MASK;\r\nstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\r\nsfbhash >>= SFB_BUCKET_SHIFT;\r\nif (b->qlen == 0)\r\ndecrement_prob(b, q);\r\nelse if (b->qlen >= q->bin_size)\r\nincrement_prob(b, q);\r\nif (minqlen > b->qlen)\r\nminqlen = b->qlen;\r\nif (p_min > b->p_mark)\r\np_min = b->p_mark;\r\n}\r\nslot ^= 1;\r\nsfb_skb_cb(skb)->hashes[slot] = 0;\r\nif (unlikely(minqlen >= q->max || sch->q.qlen >= q->limit)) {\r\nsch->qstats.overlimits++;\r\nif (minqlen >= q->max)\r\nq->stats.bucketdrop++;\r\nelse\r\nq->stats.queuedrop++;\r\ngoto drop;\r\n}\r\nif (unlikely(p_min >= SFB_MAX_PROB)) {\r\nif (q->double_buffering) {\r\nsfbhash = jhash_1word(salt, q->bins[slot].perturbation);\r\nif (!sfbhash)\r\nsfbhash = 1;\r\nsfb_skb_cb(skb)->hashes[slot] = sfbhash;\r\nfor (i = 0; i < SFB_LEVELS; i++) {\r\nu32 hash = sfbhash & SFB_BUCKET_MASK;\r\nstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\r\nsfbhash >>= SFB_BUCKET_SHIFT;\r\nif (b->qlen == 0)\r\ndecrement_prob(b, q);\r\nelse if (b->qlen >= q->bin_size)\r\nincrement_prob(b, q);\r\n}\r\n}\r\nif (sfb_rate_limit(skb, q)) {\r\nsch->qstats.overlimits++;\r\nq->stats.penaltydrop++;\r\ngoto drop;\r\n}\r\ngoto enqueue;\r\n}\r\nr = net_random() & SFB_MAX_PROB;\r\nif (unlikely(r < p_min)) {\r\nif (unlikely(p_min > SFB_MAX_PROB / 2)) {\r\nif (r < (p_min - SFB_MAX_PROB / 2) * 2) {\r\nq->stats.earlydrop++;\r\ngoto drop;\r\n}\r\n}\r\nif (INET_ECN_set_ce(skb)) {\r\nq->stats.marked++;\r\n} else {\r\nq->stats.earlydrop++;\r\ngoto drop;\r\n}\r\n}\r\nenqueue:\r\nret = qdisc_enqueue(skb, child);\r\nif (likely(ret == NET_XMIT_SUCCESS)) {\r\nsch->q.qlen++;\r\nincrement_qlen(skb, q);\r\n} else if (net_xmit_drop_count(ret)) {\r\nq->stats.childdrop++;\r\nsch->qstats.drops++;\r\n}\r\nreturn ret;\r\ndrop:\r\nqdisc_drop(skb, sch);\r\nreturn NET_XMIT_CN;\r\nother_drop:\r\nif (ret & __NET_XMIT_BYPASS)\r\nsch->qstats.drops++;\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic struct sk_buff *sfb_dequeue(struct Qdisc *sch)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *child = q->qdisc;\r\nstruct sk_buff *skb;\r\nskb = child->dequeue(q->qdisc);\r\nif (skb) {\r\nqdisc_bstats_update(sch, skb);\r\nsch->q.qlen--;\r\ndecrement_qlen(skb, q);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *sfb_peek(struct Qdisc *sch)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *child = q->qdisc;\r\nreturn child->ops->peek(child);\r\n}\r\nstatic void sfb_reset(struct Qdisc *sch)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nqdisc_reset(q->qdisc);\r\nsch->q.qlen = 0;\r\nq->slot = 0;\r\nq->double_buffering = false;\r\nsfb_zero_all_buckets(q);\r\nsfb_init_perturbation(0, q);\r\n}\r\nstatic void sfb_destroy(struct Qdisc *sch)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\ntcf_destroy_chain(&q->filter_list);\r\nqdisc_destroy(q->qdisc);\r\n}\r\nstatic int sfb_change(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *child;\r\nstruct nlattr *tb[TCA_SFB_MAX + 1];\r\nconst struct tc_sfb_qopt *ctl = &sfb_default_ops;\r\nu32 limit;\r\nint err;\r\nif (opt) {\r\nerr = nla_parse_nested(tb, TCA_SFB_MAX, opt, sfb_policy);\r\nif (err < 0)\r\nreturn -EINVAL;\r\nif (tb[TCA_SFB_PARMS] == NULL)\r\nreturn -EINVAL;\r\nctl = nla_data(tb[TCA_SFB_PARMS]);\r\n}\r\nlimit = ctl->limit;\r\nif (limit == 0)\r\nlimit = max_t(u32, qdisc_dev(sch)->tx_queue_len, 1);\r\nchild = fifo_create_dflt(sch, &pfifo_qdisc_ops, limit);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nsch_tree_lock(sch);\r\nqdisc_tree_decrease_qlen(q->qdisc, q->qdisc->q.qlen);\r\nqdisc_destroy(q->qdisc);\r\nq->qdisc = child;\r\nq->rehash_interval = msecs_to_jiffies(ctl->rehash_interval);\r\nq->warmup_time = msecs_to_jiffies(ctl->warmup_time);\r\nq->rehash_time = jiffies;\r\nq->limit = limit;\r\nq->increment = ctl->increment;\r\nq->decrement = ctl->decrement;\r\nq->max = ctl->max;\r\nq->bin_size = ctl->bin_size;\r\nq->penalty_rate = ctl->penalty_rate;\r\nq->penalty_burst = ctl->penalty_burst;\r\nq->tokens_avail = ctl->penalty_burst;\r\nq->token_time = jiffies;\r\nq->slot = 0;\r\nq->double_buffering = false;\r\nsfb_zero_all_buckets(q);\r\nsfb_init_perturbation(0, q);\r\nsfb_init_perturbation(1, q);\r\nsch_tree_unlock(sch);\r\nreturn 0;\r\n}\r\nstatic int sfb_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nq->qdisc = &noop_qdisc;\r\nreturn sfb_change(sch, opt);\r\n}\r\nstatic int sfb_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nstruct nlattr *opts;\r\nstruct tc_sfb_qopt opt = {\r\n.rehash_interval = jiffies_to_msecs(q->rehash_interval),\r\n.warmup_time = jiffies_to_msecs(q->warmup_time),\r\n.limit = q->limit,\r\n.max = q->max,\r\n.bin_size = q->bin_size,\r\n.increment = q->increment,\r\n.decrement = q->decrement,\r\n.penalty_rate = q->penalty_rate,\r\n.penalty_burst = q->penalty_burst,\r\n};\r\nsch->qstats.backlog = q->qdisc->qstats.backlog;\r\nopts = nla_nest_start(skb, TCA_OPTIONS);\r\nNLA_PUT(skb, TCA_SFB_PARMS, sizeof(opt), &opt);\r\nreturn nla_nest_end(skb, opts);\r\nnla_put_failure:\r\nnla_nest_cancel(skb, opts);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int sfb_dump_stats(struct Qdisc *sch, struct gnet_dump *d)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nstruct tc_sfb_xstats st = {\r\n.earlydrop = q->stats.earlydrop,\r\n.penaltydrop = q->stats.penaltydrop,\r\n.bucketdrop = q->stats.bucketdrop,\r\n.queuedrop = q->stats.queuedrop,\r\n.childdrop = q->stats.childdrop,\r\n.marked = q->stats.marked,\r\n};\r\nst.maxqlen = sfb_compute_qlen(&st.maxprob, &st.avgprob, q);\r\nreturn gnet_stats_copy_app(d, &st, sizeof(st));\r\n}\r\nstatic int sfb_dump_class(struct Qdisc *sch, unsigned long cl,\r\nstruct sk_buff *skb, struct tcmsg *tcm)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int sfb_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\r\nstruct Qdisc **old)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nif (new == NULL)\r\nnew = &noop_qdisc;\r\nsch_tree_lock(sch);\r\n*old = q->qdisc;\r\nq->qdisc = new;\r\nqdisc_tree_decrease_qlen(*old, (*old)->q.qlen);\r\nqdisc_reset(*old);\r\nsch_tree_unlock(sch);\r\nreturn 0;\r\n}\r\nstatic struct Qdisc *sfb_leaf(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nreturn q->qdisc;\r\n}\r\nstatic unsigned long sfb_get(struct Qdisc *sch, u32 classid)\r\n{\r\nreturn 1;\r\n}\r\nstatic void sfb_put(struct Qdisc *sch, unsigned long arg)\r\n{\r\n}\r\nstatic int sfb_change_class(struct Qdisc *sch, u32 classid, u32 parentid,\r\nstruct nlattr **tca, unsigned long *arg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int sfb_delete(struct Qdisc *sch, unsigned long cl)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void sfb_walk(struct Qdisc *sch, struct qdisc_walker *walker)\r\n{\r\nif (!walker->stop) {\r\nif (walker->count >= walker->skip)\r\nif (walker->fn(sch, 1, walker) < 0) {\r\nwalker->stop = 1;\r\nreturn;\r\n}\r\nwalker->count++;\r\n}\r\n}\r\nstatic struct tcf_proto **sfb_find_tcf(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct sfb_sched_data *q = qdisc_priv(sch);\r\nif (cl)\r\nreturn NULL;\r\nreturn &q->filter_list;\r\n}\r\nstatic unsigned long sfb_bind(struct Qdisc *sch, unsigned long parent,\r\nu32 classid)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init sfb_module_init(void)\r\n{\r\nreturn register_qdisc(&sfb_qdisc_ops);\r\n}\r\nstatic void __exit sfb_module_exit(void)\r\n{\r\nunregister_qdisc(&sfb_qdisc_ops);\r\n}
