static int tpa6130a2_i2c_read(int reg)\r\n{\r\nstruct tpa6130a2_data *data;\r\nint val;\r\nBUG_ON(tpa6130a2_client == NULL);\r\ndata = i2c_get_clientdata(tpa6130a2_client);\r\nif (data->power_state) {\r\nval = i2c_smbus_read_byte_data(tpa6130a2_client, reg);\r\nif (val < 0)\r\ndev_err(&tpa6130a2_client->dev, "Read failed\n");\r\nelse\r\ndata->regs[reg] = val;\r\n} else {\r\nval = data->regs[reg];\r\n}\r\nreturn val;\r\n}\r\nstatic int tpa6130a2_i2c_write(int reg, u8 value)\r\n{\r\nstruct tpa6130a2_data *data;\r\nint val = 0;\r\nBUG_ON(tpa6130a2_client == NULL);\r\ndata = i2c_get_clientdata(tpa6130a2_client);\r\nif (data->power_state) {\r\nval = i2c_smbus_write_byte_data(tpa6130a2_client, reg, value);\r\nif (val < 0) {\r\ndev_err(&tpa6130a2_client->dev, "Write failed\n");\r\nreturn val;\r\n}\r\n}\r\ndata->regs[reg] = value;\r\nreturn val;\r\n}\r\nstatic u8 tpa6130a2_read(int reg)\r\n{\r\nstruct tpa6130a2_data *data;\r\nBUG_ON(tpa6130a2_client == NULL);\r\ndata = i2c_get_clientdata(tpa6130a2_client);\r\nreturn data->regs[reg];\r\n}\r\nstatic int tpa6130a2_initialize(void)\r\n{\r\nstruct tpa6130a2_data *data;\r\nint i, ret = 0;\r\nBUG_ON(tpa6130a2_client == NULL);\r\ndata = i2c_get_clientdata(tpa6130a2_client);\r\nfor (i = 1; i < TPA6130A2_REG_VERSION; i++) {\r\nret = tpa6130a2_i2c_write(i, data->regs[i]);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tpa6130a2_power(u8 power)\r\n{\r\nstruct tpa6130a2_data *data;\r\nu8 val;\r\nint ret = 0;\r\nBUG_ON(tpa6130a2_client == NULL);\r\ndata = i2c_get_clientdata(tpa6130a2_client);\r\nmutex_lock(&data->mutex);\r\nif (power == data->power_state)\r\ngoto exit;\r\nif (power) {\r\nret = regulator_enable(data->supply);\r\nif (ret != 0) {\r\ndev_err(&tpa6130a2_client->dev,\r\n"Failed to enable supply: %d\n", ret);\r\ngoto exit;\r\n}\r\nif (data->power_gpio >= 0)\r\ngpio_set_value(data->power_gpio, 1);\r\ndata->power_state = 1;\r\nret = tpa6130a2_initialize();\r\nif (ret < 0) {\r\ndev_err(&tpa6130a2_client->dev,\r\n"Failed to initialize chip\n");\r\nif (data->power_gpio >= 0)\r\ngpio_set_value(data->power_gpio, 0);\r\nregulator_disable(data->supply);\r\ndata->power_state = 0;\r\ngoto exit;\r\n}\r\n} else {\r\nval = tpa6130a2_read(TPA6130A2_REG_CONTROL);\r\nval |= TPA6130A2_SWS;\r\ntpa6130a2_i2c_write(TPA6130A2_REG_CONTROL, val);\r\nif (data->power_gpio >= 0)\r\ngpio_set_value(data->power_gpio, 0);\r\nret = regulator_disable(data->supply);\r\nif (ret != 0) {\r\ndev_err(&tpa6130a2_client->dev,\r\n"Failed to disable supply: %d\n", ret);\r\ngoto exit;\r\n}\r\ndata->power_state = 0;\r\n}\r\nexit:\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int tpa6130a2_get_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct tpa6130a2_data *data;\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nBUG_ON(tpa6130a2_client == NULL);\r\ndata = i2c_get_clientdata(tpa6130a2_client);\r\nmutex_lock(&data->mutex);\r\nucontrol->value.integer.value[0] =\r\n(tpa6130a2_read(reg) >> shift) & mask;\r\nif (invert)\r\nucontrol->value.integer.value[0] =\r\nmax - ucontrol->value.integer.value[0];\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int tpa6130a2_put_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct tpa6130a2_data *data;\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nunsigned int val = (ucontrol->value.integer.value[0] & mask);\r\nunsigned int val_reg;\r\nBUG_ON(tpa6130a2_client == NULL);\r\ndata = i2c_get_clientdata(tpa6130a2_client);\r\nif (invert)\r\nval = max - val;\r\nmutex_lock(&data->mutex);\r\nval_reg = tpa6130a2_read(reg);\r\nif (((val_reg >> shift) & mask) == val) {\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nval_reg &= ~(mask << shift);\r\nval_reg |= val << shift;\r\ntpa6130a2_i2c_write(reg, val_reg);\r\nmutex_unlock(&data->mutex);\r\nreturn 1;\r\n}\r\nstatic void tpa6130a2_channel_enable(u8 channel, int enable)\r\n{\r\nu8 val;\r\nif (enable) {\r\nval = tpa6130a2_read(TPA6130A2_REG_CONTROL);\r\nval |= channel;\r\nval &= ~TPA6130A2_SWS;\r\ntpa6130a2_i2c_write(TPA6130A2_REG_CONTROL, val);\r\nval = tpa6130a2_read(TPA6130A2_REG_VOL_MUTE);\r\nval &= ~channel;\r\ntpa6130a2_i2c_write(TPA6130A2_REG_VOL_MUTE, val);\r\n} else {\r\nval = tpa6130a2_read(TPA6130A2_REG_VOL_MUTE);\r\nval |= channel;\r\ntpa6130a2_i2c_write(TPA6130A2_REG_VOL_MUTE, val);\r\nval = tpa6130a2_read(TPA6130A2_REG_CONTROL);\r\nval &= ~channel;\r\ntpa6130a2_i2c_write(TPA6130A2_REG_CONTROL, val);\r\n}\r\n}\r\nint tpa6130a2_stereo_enable(struct snd_soc_codec *codec, int enable)\r\n{\r\nint ret = 0;\r\nif (enable) {\r\nret = tpa6130a2_power(1);\r\nif (ret < 0)\r\nreturn ret;\r\ntpa6130a2_channel_enable(TPA6130A2_HP_EN_R | TPA6130A2_HP_EN_L,\r\n1);\r\n} else {\r\ntpa6130a2_channel_enable(TPA6130A2_HP_EN_R | TPA6130A2_HP_EN_L,\r\n0);\r\nret = tpa6130a2_power(0);\r\n}\r\nreturn ret;\r\n}\r\nint tpa6130a2_add_controls(struct snd_soc_codec *codec)\r\n{\r\nstruct tpa6130a2_data *data;\r\nif (tpa6130a2_client == NULL)\r\nreturn -ENODEV;\r\ndata = i2c_get_clientdata(tpa6130a2_client);\r\nif (data->id == TPA6140A2)\r\nreturn snd_soc_add_controls(codec, tpa6140a2_controls,\r\nARRAY_SIZE(tpa6140a2_controls));\r\nelse\r\nreturn snd_soc_add_controls(codec, tpa6130a2_controls,\r\nARRAY_SIZE(tpa6130a2_controls));\r\n}\r\nstatic int __devinit tpa6130a2_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev;\r\nstruct tpa6130a2_data *data;\r\nstruct tpa6130a2_platform_data *pdata;\r\nconst char *regulator;\r\nint ret;\r\ndev = &client->dev;\r\nif (client->dev.platform_data == NULL) {\r\ndev_err(dev, "Platform data not set\n");\r\ndump_stack();\r\nreturn -ENODEV;\r\n}\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL) {\r\ndev_err(dev, "Can not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ntpa6130a2_client = client;\r\ni2c_set_clientdata(tpa6130a2_client, data);\r\npdata = client->dev.platform_data;\r\ndata->power_gpio = pdata->power_gpio;\r\ndata->id = pdata->id;\r\nmutex_init(&data->mutex);\r\ndata->regs[TPA6130A2_REG_CONTROL] = TPA6130A2_SWS;\r\ndata->regs[TPA6130A2_REG_VOL_MUTE] = TPA6130A2_MUTE_R |\r\nTPA6130A2_MUTE_L;\r\nif (data->power_gpio >= 0) {\r\nret = gpio_request(data->power_gpio, "tpa6130a2 enable");\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to request power GPIO (%d)\n",\r\ndata->power_gpio);\r\ngoto err_gpio;\r\n}\r\ngpio_direction_output(data->power_gpio, 0);\r\n}\r\nswitch (data->id) {\r\ndefault:\r\ndev_warn(dev, "Unknown TPA model (%d). Assuming 6130A2\n",\r\npdata->id);\r\ncase TPA6130A2:\r\nregulator = "Vdd";\r\nbreak;\r\ncase TPA6140A2:\r\nregulator = "AVdd";\r\nbreak;\r\n}\r\ndata->supply = regulator_get(dev, regulator);\r\nif (IS_ERR(data->supply)) {\r\nret = PTR_ERR(data->supply);\r\ndev_err(dev, "Failed to request supply: %d\n", ret);\r\ngoto err_regulator;\r\n}\r\nret = tpa6130a2_power(1);\r\nif (ret != 0)\r\ngoto err_power;\r\nret = tpa6130a2_i2c_read(TPA6130A2_REG_VERSION) &\r\nTPA6130A2_VERSION_MASK;\r\nif ((ret != 1) && (ret != 2))\r\ndev_warn(dev, "UNTESTED version detected (%d)\n", ret);\r\nret = tpa6130a2_power(0);\r\nif (ret != 0)\r\ngoto err_power;\r\nreturn 0;\r\nerr_power:\r\nregulator_put(data->supply);\r\nerr_regulator:\r\nif (data->power_gpio >= 0)\r\ngpio_free(data->power_gpio);\r\nerr_gpio:\r\nkfree(data);\r\ni2c_set_clientdata(tpa6130a2_client, NULL);\r\ntpa6130a2_client = NULL;\r\nreturn ret;\r\n}\r\nstatic int __devexit tpa6130a2_remove(struct i2c_client *client)\r\n{\r\nstruct tpa6130a2_data *data = i2c_get_clientdata(client);\r\ntpa6130a2_power(0);\r\nif (data->power_gpio >= 0)\r\ngpio_free(data->power_gpio);\r\nregulator_put(data->supply);\r\nkfree(data);\r\ntpa6130a2_client = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init tpa6130a2_init(void)\r\n{\r\nreturn i2c_add_driver(&tpa6130a2_i2c_driver);\r\n}\r\nstatic void __exit tpa6130a2_exit(void)\r\n{\r\ni2c_del_driver(&tpa6130a2_i2c_driver);\r\n}
