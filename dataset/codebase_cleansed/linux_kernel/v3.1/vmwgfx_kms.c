void vmw_display_unit_cleanup(struct vmw_display_unit *du)\r\n{\r\nif (du->cursor_surface)\r\nvmw_surface_unreference(&du->cursor_surface);\r\nif (du->cursor_dmabuf)\r\nvmw_dmabuf_unreference(&du->cursor_dmabuf);\r\ndrm_crtc_cleanup(&du->crtc);\r\ndrm_encoder_cleanup(&du->encoder);\r\ndrm_connector_cleanup(&du->connector);\r\n}\r\nint vmw_cursor_update_image(struct vmw_private *dev_priv,\r\nu32 *image, u32 width, u32 height,\r\nu32 hotspotX, u32 hotspotY)\r\n{\r\nstruct {\r\nu32 cmd;\r\nSVGAFifoCmdDefineAlphaCursor cursor;\r\n} *cmd;\r\nu32 image_size = width * height * 4;\r\nu32 cmd_size = sizeof(*cmd) + image_size;\r\nif (!image)\r\nreturn -EINVAL;\r\ncmd = vmw_fifo_reserve(dev_priv, cmd_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\nmemcpy(&cmd[1], image, image_size);\r\ncmd->cmd = cpu_to_le32(SVGA_CMD_DEFINE_ALPHA_CURSOR);\r\ncmd->cursor.id = cpu_to_le32(0);\r\ncmd->cursor.width = cpu_to_le32(width);\r\ncmd->cursor.height = cpu_to_le32(height);\r\ncmd->cursor.hotspotX = cpu_to_le32(hotspotX);\r\ncmd->cursor.hotspotY = cpu_to_le32(hotspotY);\r\nvmw_fifo_commit(dev_priv, cmd_size);\r\nreturn 0;\r\n}\r\nvoid vmw_cursor_update_position(struct vmw_private *dev_priv,\r\nbool show, int x, int y)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t count;\r\niowrite32(show ? 1 : 0, fifo_mem + SVGA_FIFO_CURSOR_ON);\r\niowrite32(x, fifo_mem + SVGA_FIFO_CURSOR_X);\r\niowrite32(y, fifo_mem + SVGA_FIFO_CURSOR_Y);\r\ncount = ioread32(fifo_mem + SVGA_FIFO_CURSOR_COUNT);\r\niowrite32(++count, fifo_mem + SVGA_FIFO_CURSOR_COUNT);\r\n}\r\nint vmw_du_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,\r\nuint32_t handle, uint32_t width, uint32_t height)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\r\nstruct vmw_surface *surface = NULL;\r\nstruct vmw_dma_buffer *dmabuf = NULL;\r\nint ret;\r\nif (handle) {\r\nret = vmw_user_surface_lookup_handle(dev_priv, tfile,\r\nhandle, &surface);\r\nif (!ret) {\r\nif (!surface->snooper.image) {\r\nDRM_ERROR("surface not suitable for cursor\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nret = vmw_user_dmabuf_lookup(tfile,\r\nhandle, &dmabuf);\r\nif (ret) {\r\nDRM_ERROR("failed to find surface or dmabuf: %i\n", ret);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif (du->cursor_surface) {\r\ndu->cursor_surface->snooper.crtc = NULL;\r\nvmw_surface_unreference(&du->cursor_surface);\r\n}\r\nif (du->cursor_dmabuf)\r\nvmw_dmabuf_unreference(&du->cursor_dmabuf);\r\nif (surface) {\r\ndu->cursor_surface = surface;\r\ndu->cursor_surface->snooper.crtc = crtc;\r\ndu->cursor_age = du->cursor_surface->snooper.age;\r\nvmw_cursor_update_image(dev_priv, surface->snooper.image,\r\n64, 64, du->hotspot_x, du->hotspot_y);\r\n} else if (dmabuf) {\r\nstruct ttm_bo_kmap_obj map;\r\nunsigned long kmap_offset;\r\nunsigned long kmap_num;\r\nvoid *virtual;\r\nbool dummy;\r\ndu->cursor_dmabuf = dmabuf;\r\nkmap_offset = 0;\r\nkmap_num = (64*64*4) >> PAGE_SHIFT;\r\nret = ttm_bo_reserve(&dmabuf->base, true, false, false, 0);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("reserve failed\n");\r\nreturn -EINVAL;\r\n}\r\nret = ttm_bo_kmap(&dmabuf->base, kmap_offset, kmap_num, &map);\r\nif (unlikely(ret != 0))\r\ngoto err_unreserve;\r\nvirtual = ttm_kmap_obj_virtual(&map, &dummy);\r\nvmw_cursor_update_image(dev_priv, virtual, 64, 64,\r\ndu->hotspot_x, du->hotspot_y);\r\nttm_bo_kunmap(&map);\r\nerr_unreserve:\r\nttm_bo_unreserve(&dmabuf->base);\r\n} else {\r\nvmw_cursor_update_position(dev_priv, false, 0, 0);\r\nreturn 0;\r\n}\r\nvmw_cursor_update_position(dev_priv, true, du->cursor_x, du->cursor_y);\r\nreturn 0;\r\n}\r\nint vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\r\nbool shown = du->cursor_surface || du->cursor_dmabuf ? true : false;\r\ndu->cursor_x = x + crtc->x;\r\ndu->cursor_y = y + crtc->y;\r\nvmw_cursor_update_position(dev_priv, shown,\r\ndu->cursor_x, du->cursor_y);\r\nreturn 0;\r\n}\r\nvoid vmw_kms_cursor_snoop(struct vmw_surface *srf,\r\nstruct ttm_object_file *tfile,\r\nstruct ttm_buffer_object *bo,\r\nSVGA3dCmdHeader *header)\r\n{\r\nstruct ttm_bo_kmap_obj map;\r\nunsigned long kmap_offset;\r\nunsigned long kmap_num;\r\nSVGA3dCopyBox *box;\r\nunsigned box_count;\r\nvoid *virtual;\r\nbool dummy;\r\nstruct vmw_dma_cmd {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSurfaceDMA dma;\r\n} *cmd;\r\nint ret;\r\ncmd = container_of(header, struct vmw_dma_cmd, header);\r\nif (!srf->snooper.image)\r\nreturn;\r\nif (cmd->dma.host.face != 0 || cmd->dma.host.mipmap != 0) {\r\nDRM_ERROR("face and mipmap for cursors should never != 0\n");\r\nreturn;\r\n}\r\nif (cmd->header.size < 64) {\r\nDRM_ERROR("at least one full copy box must be given\n");\r\nreturn;\r\n}\r\nbox = (SVGA3dCopyBox *)&cmd[1];\r\nbox_count = (cmd->header.size - sizeof(SVGA3dCmdSurfaceDMA)) /\r\nsizeof(SVGA3dCopyBox);\r\nif (cmd->dma.guest.pitch != (64 * 4) ||\r\ncmd->dma.guest.ptr.offset % PAGE_SIZE ||\r\nbox->x != 0 || box->y != 0 || box->z != 0 ||\r\nbox->srcx != 0 || box->srcy != 0 || box->srcz != 0 ||\r\nbox->w != 64 || box->h != 64 || box->d != 1 ||\r\nbox_count != 1) {\r\nDRM_ERROR("lazy programmer, can't handle weird stuff\n");\r\nreturn;\r\n}\r\nkmap_offset = cmd->dma.guest.ptr.offset >> PAGE_SHIFT;\r\nkmap_num = (64*64*4) >> PAGE_SHIFT;\r\nret = ttm_bo_reserve(bo, true, false, false, 0);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("reserve failed\n");\r\nreturn;\r\n}\r\nret = ttm_bo_kmap(bo, kmap_offset, kmap_num, &map);\r\nif (unlikely(ret != 0))\r\ngoto err_unreserve;\r\nvirtual = ttm_kmap_obj_virtual(&map, &dummy);\r\nmemcpy(srf->snooper.image, virtual, 64*64*4);\r\nsrf->snooper.age++;\r\nttm_bo_kunmap(&map);\r\nerr_unreserve:\r\nttm_bo_unreserve(bo);\r\n}\r\nvoid vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_display_unit *du;\r\nstruct drm_crtc *crtc;\r\nmutex_lock(&dev->mode_config.mutex);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\ndu = vmw_crtc_to_du(crtc);\r\nif (!du->cursor_surface ||\r\ndu->cursor_age == du->cursor_surface->snooper.age)\r\ncontinue;\r\ndu->cursor_age = du->cursor_surface->snooper.age;\r\nvmw_cursor_update_image(dev_priv,\r\ndu->cursor_surface->snooper.image,\r\n64, 64, du->hotspot_x, du->hotspot_y);\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}\r\nint vmw_framebuffer_create_handle(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nif (handle)\r\nhandle = 0;\r\nreturn 0;\r\n}\r\nvoid vmw_kms_idle_workqueues(struct vmw_master *vmaster)\r\n{\r\nstruct vmw_framebuffer_surface *entry;\r\nmutex_lock(&vmaster->fb_surf_mutex);\r\nlist_for_each_entry(entry, &vmaster->fb_surf, head) {\r\nif (cancel_delayed_work_sync(&entry->d_work))\r\n(void) entry->d_work.work.func(&entry->d_work.work);\r\n(void) cancel_delayed_work_sync(&entry->d_work);\r\n}\r\nmutex_unlock(&vmaster->fb_surf_mutex);\r\n}\r\nvoid vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct vmw_framebuffer_surface *vfbs =\r\nvmw_framebuffer_to_vfbs(framebuffer);\r\nstruct vmw_master *vmaster = vmw_master(vfbs->master);\r\nmutex_lock(&vmaster->fb_surf_mutex);\r\nlist_del(&vfbs->head);\r\nmutex_unlock(&vmaster->fb_surf_mutex);\r\ncancel_delayed_work_sync(&vfbs->d_work);\r\ndrm_master_put(&vfbs->master);\r\ndrm_framebuffer_cleanup(framebuffer);\r\nvmw_surface_unreference(&vfbs->surface);\r\nkfree(vfbs);\r\n}\r\nstatic void vmw_framebuffer_present_fs_callback(struct work_struct *work)\r\n{\r\nstruct delayed_work *d_work =\r\ncontainer_of(work, struct delayed_work, work);\r\nstruct vmw_framebuffer_surface *vfbs =\r\ncontainer_of(d_work, struct vmw_framebuffer_surface, d_work);\r\nstruct vmw_surface *surf = vfbs->surface;\r\nstruct drm_framebuffer *framebuffer = &vfbs->base.base;\r\nstruct vmw_private *dev_priv = vmw_priv(framebuffer->dev);\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdPresent body;\r\nSVGA3dCopyRect cr;\r\n} *cmd;\r\nmutex_lock(&vfbs->work_lock);\r\nif (!vfbs->present_fs)\r\ngoto out_unlock;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL))\r\ngoto out_resched;\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_PRESENT);\r\ncmd->header.size = cpu_to_le32(sizeof(cmd->body) + sizeof(cmd->cr));\r\ncmd->body.sid = cpu_to_le32(surf->res.id);\r\ncmd->cr.x = cpu_to_le32(0);\r\ncmd->cr.y = cpu_to_le32(0);\r\ncmd->cr.srcx = cmd->cr.x;\r\ncmd->cr.srcy = cmd->cr.y;\r\ncmd->cr.w = cpu_to_le32(framebuffer->width);\r\ncmd->cr.h = cpu_to_le32(framebuffer->height);\r\nvfbs->present_fs = false;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nout_resched:\r\nschedule_delayed_work(&vfbs->d_work, VMWGFX_PRESENT_RATE);\r\nout_unlock:\r\nmutex_unlock(&vfbs->work_lock);\r\n}\r\nint vmw_framebuffer_surface_dirty(struct drm_framebuffer *framebuffer,\r\nstruct drm_file *file_priv,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(framebuffer->dev);\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nstruct vmw_framebuffer_surface *vfbs =\r\nvmw_framebuffer_to_vfbs(framebuffer);\r\nstruct vmw_surface *surf = vfbs->surface;\r\nstruct drm_clip_rect norect;\r\nSVGA3dCopyRect *cr;\r\nint i, inc = 1;\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdPresent body;\r\nSVGA3dCopyRect cr;\r\n} *cmd;\r\nif (unlikely(vfbs->master != file_priv->master))\r\nreturn -EINVAL;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (!num_clips ||\r\n!(dev_priv->fifo.capabilities &\r\nSVGA_FIFO_CAP_SCREEN_OBJECT)) {\r\nint ret;\r\nmutex_lock(&vfbs->work_lock);\r\nvfbs->present_fs = true;\r\nret = schedule_delayed_work(&vfbs->d_work, VMWGFX_PRESENT_RATE);\r\nmutex_unlock(&vfbs->work_lock);\r\nif (ret) {\r\nvmw_framebuffer_present_fs_callback(&vfbs->d_work.work);\r\n}\r\nttm_read_unlock(&vmaster->lock);\r\nreturn 0;\r\n}\r\nif (!num_clips) {\r\nnum_clips = 1;\r\nclips = &norect;\r\nnorect.x1 = norect.y1 = 0;\r\nnorect.x2 = framebuffer->width;\r\nnorect.y2 = framebuffer->height;\r\n} else if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\r\nnum_clips /= 2;\r\ninc = 2;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd) + (num_clips - 1) * sizeof(cmd->cr));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nttm_read_unlock(&vmaster->lock);\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_PRESENT);\r\ncmd->header.size = cpu_to_le32(sizeof(cmd->body) + num_clips * sizeof(cmd->cr));\r\ncmd->body.sid = cpu_to_le32(surf->res.id);\r\nfor (i = 0, cr = &cmd->cr; i < num_clips; i++, cr++, clips += inc) {\r\ncr->x = cpu_to_le16(clips->x1);\r\ncr->y = cpu_to_le16(clips->y1);\r\ncr->srcx = cr->x;\r\ncr->srcy = cr->y;\r\ncr->w = cpu_to_le16(clips->x2 - clips->x1);\r\ncr->h = cpu_to_le16(clips->y2 - clips->y1);\r\n}\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd) + (num_clips - 1) * sizeof(cmd->cr));\r\nttm_read_unlock(&vmaster->lock);\r\nreturn 0;\r\n}\r\nstatic int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_surface *surface,\r\nstruct vmw_framebuffer **out,\r\nconst struct drm_mode_fb_cmd\r\n*mode_cmd)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_framebuffer_surface *vfbs;\r\nenum SVGA3dSurfaceFormat format;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nint ret;\r\nif (unlikely(surface->mip_levels[0] != 1 ||\r\nsurface->num_sizes != 1 ||\r\nsurface->sizes[0].width < mode_cmd->width ||\r\nsurface->sizes[0].height < mode_cmd->height ||\r\nsurface->sizes[0].depth != 1)) {\r\nDRM_ERROR("Incompatible surface dimensions "\r\n"for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (mode_cmd->depth) {\r\ncase 32:\r\nformat = SVGA3D_A8R8G8B8;\r\nbreak;\r\ncase 24:\r\nformat = SVGA3D_X8R8G8B8;\r\nbreak;\r\ncase 16:\r\nformat = SVGA3D_R5G6B5;\r\nbreak;\r\ncase 15:\r\nformat = SVGA3D_A1R5G5B5;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid color depth: %d\n", mode_cmd->depth);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(format != surface->format)) {\r\nDRM_ERROR("Invalid surface format for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nvfbs = kzalloc(sizeof(*vfbs), GFP_KERNEL);\r\nif (!vfbs) {\r\nret = -ENOMEM;\r\ngoto out_err1;\r\n}\r\nret = drm_framebuffer_init(dev, &vfbs->base.base,\r\n&vmw_framebuffer_surface_funcs);\r\nif (ret)\r\ngoto out_err2;\r\nif (!vmw_surface_reference(surface)) {\r\nDRM_ERROR("failed to reference surface %p\n", surface);\r\ngoto out_err3;\r\n}\r\nvfbs->base.base.bits_per_pixel = mode_cmd->bpp;\r\nvfbs->base.base.pitch = mode_cmd->pitch;\r\nvfbs->base.base.depth = mode_cmd->depth;\r\nvfbs->base.base.width = mode_cmd->width;\r\nvfbs->base.base.height = mode_cmd->height;\r\nvfbs->base.pin = &vmw_surface_dmabuf_pin;\r\nvfbs->base.unpin = &vmw_surface_dmabuf_unpin;\r\nvfbs->surface = surface;\r\nvfbs->master = drm_master_get(file_priv->master);\r\nmutex_init(&vfbs->work_lock);\r\nmutex_lock(&vmaster->fb_surf_mutex);\r\nINIT_DELAYED_WORK(&vfbs->d_work, &vmw_framebuffer_present_fs_callback);\r\nlist_add_tail(&vfbs->head, &vmaster->fb_surf);\r\nmutex_unlock(&vmaster->fb_surf_mutex);\r\n*out = &vfbs->base;\r\nreturn 0;\r\nout_err3:\r\ndrm_framebuffer_cleanup(&vfbs->base.base);\r\nout_err2:\r\nkfree(vfbs);\r\nout_err1:\r\nreturn ret;\r\n}\r\nvoid vmw_framebuffer_dmabuf_destroy(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(framebuffer);\r\ndrm_framebuffer_cleanup(framebuffer);\r\nvmw_dmabuf_unreference(&vfbd->buffer);\r\nkfree(vfbd);\r\n}\r\nint vmw_framebuffer_dmabuf_dirty(struct drm_framebuffer *framebuffer,\r\nstruct drm_file *file_priv,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(framebuffer->dev);\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nstruct drm_clip_rect norect;\r\nint ret;\r\nstruct {\r\nuint32_t header;\r\nSVGAFifoCmdUpdate body;\r\n} *cmd;\r\nint i, increment = 1;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (!num_clips) {\r\nnum_clips = 1;\r\nclips = &norect;\r\nnorect.x1 = norect.y1 = 0;\r\nnorect.x2 = framebuffer->width;\r\nnorect.y2 = framebuffer->height;\r\n} else if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\r\nnum_clips /= 2;\r\nincrement = 2;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd) * num_clips);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nttm_read_unlock(&vmaster->lock);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < num_clips; i++, clips += increment) {\r\ncmd[i].header = cpu_to_le32(SVGA_CMD_UPDATE);\r\ncmd[i].body.x = cpu_to_le32(clips->x1);\r\ncmd[i].body.y = cpu_to_le32(clips->y1);\r\ncmd[i].body.width = cpu_to_le32(clips->x2 - clips->x1);\r\ncmd[i].body.height = cpu_to_le32(clips->y2 - clips->y1);\r\n}\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd) * num_clips);\r\nttm_read_unlock(&vmaster->lock);\r\nreturn 0;\r\n}\r\nstatic int vmw_surface_dmabuf_pin(struct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\r\nstruct vmw_framebuffer_surface *vfbs =\r\nvmw_framebuffer_to_vfbs(&vfb->base);\r\nunsigned long size = vfbs->base.base.pitch * vfbs->base.base.height;\r\nint ret;\r\nvfbs->buffer = kzalloc(sizeof(*vfbs->buffer), GFP_KERNEL);\r\nif (unlikely(vfbs->buffer == NULL))\r\nreturn -ENOMEM;\r\nvmw_overlay_pause_all(dev_priv);\r\nret = vmw_dmabuf_init(dev_priv, vfbs->buffer, size,\r\n&vmw_vram_ne_placement,\r\nfalse, &vmw_dmabuf_bo_free);\r\nvmw_overlay_resume_all(dev_priv);\r\nif (unlikely(ret != 0))\r\nvfbs->buffer = NULL;\r\nreturn ret;\r\n}\r\nstatic int vmw_surface_dmabuf_unpin(struct vmw_framebuffer *vfb)\r\n{\r\nstruct ttm_buffer_object *bo;\r\nstruct vmw_framebuffer_surface *vfbs =\r\nvmw_framebuffer_to_vfbs(&vfb->base);\r\nif (unlikely(vfbs->buffer == NULL))\r\nreturn 0;\r\nbo = &vfbs->buffer->base;\r\nttm_bo_unref(&bo);\r\nvfbs->buffer = NULL;\r\nreturn 0;\r\n}\r\nstatic int vmw_framebuffer_dmabuf_pin(struct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(&vfb->base);\r\nint ret;\r\nvmw_overlay_pause_all(dev_priv);\r\nret = vmw_dmabuf_to_start_of_vram(dev_priv, vfbd->buffer);\r\nvmw_overlay_resume_all(dev_priv);\r\nWARN_ON(ret != 0);\r\nreturn 0;\r\n}\r\nstatic int vmw_framebuffer_dmabuf_unpin(struct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(&vfb->base);\r\nif (!vfbd->buffer) {\r\nWARN_ON(!vfbd->buffer);\r\nreturn 0;\r\n}\r\nreturn vmw_dmabuf_from_vram(dev_priv, vfbd->buffer);\r\n}\r\nstatic int vmw_kms_new_framebuffer_dmabuf(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *dmabuf,\r\nstruct vmw_framebuffer **out,\r\nconst struct drm_mode_fb_cmd\r\n*mode_cmd)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_framebuffer_dmabuf *vfbd;\r\nunsigned int requested_size;\r\nint ret;\r\nrequested_size = mode_cmd->height * mode_cmd->pitch;\r\nif (unlikely(requested_size > dmabuf->base.num_pages * PAGE_SIZE)) {\r\nDRM_ERROR("Screen buffer object size is too small "\r\n"for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nvfbd = kzalloc(sizeof(*vfbd), GFP_KERNEL);\r\nif (!vfbd) {\r\nret = -ENOMEM;\r\ngoto out_err1;\r\n}\r\nret = drm_framebuffer_init(dev, &vfbd->base.base,\r\n&vmw_framebuffer_dmabuf_funcs);\r\nif (ret)\r\ngoto out_err2;\r\nif (!vmw_dmabuf_reference(dmabuf)) {\r\nDRM_ERROR("failed to reference dmabuf %p\n", dmabuf);\r\ngoto out_err3;\r\n}\r\nvfbd->base.base.bits_per_pixel = mode_cmd->bpp;\r\nvfbd->base.base.pitch = mode_cmd->pitch;\r\nvfbd->base.base.depth = mode_cmd->depth;\r\nvfbd->base.base.width = mode_cmd->width;\r\nvfbd->base.base.height = mode_cmd->height;\r\nvfbd->base.pin = vmw_framebuffer_dmabuf_pin;\r\nvfbd->base.unpin = vmw_framebuffer_dmabuf_unpin;\r\nvfbd->buffer = dmabuf;\r\n*out = &vfbd->base;\r\nreturn 0;\r\nout_err3:\r\ndrm_framebuffer_cleanup(&vfbd->base.base);\r\nout_err2:\r\nkfree(vfbd);\r\nout_err1:\r\nreturn ret;\r\n}\r\nstatic struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_mode_fb_cmd *mode_cmd)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_framebuffer *vfb = NULL;\r\nstruct vmw_surface *surface = NULL;\r\nstruct vmw_dma_buffer *bo = NULL;\r\nu64 required_size;\r\nint ret;\r\nrequired_size = mode_cmd->pitch * mode_cmd->height;\r\nif (unlikely(required_size > (u64) dev_priv->vram_size)) {\r\nDRM_ERROR("VRAM size is too small for requested mode.\n");\r\nreturn NULL;\r\n}\r\nret = vmw_user_surface_lookup_handle(dev_priv, tfile,\r\nmode_cmd->handle, &surface);\r\nif (ret)\r\ngoto try_dmabuf;\r\nif (!surface->scanout)\r\ngoto err_not_scanout;\r\nret = vmw_kms_new_framebuffer_surface(dev_priv, file_priv, surface,\r\n&vfb, mode_cmd);\r\nvmw_surface_unreference(&surface);\r\nif (ret) {\r\nDRM_ERROR("failed to create vmw_framebuffer: %i\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &vfb->base;\r\ntry_dmabuf:\r\nDRM_INFO("%s: trying buffer\n", __func__);\r\nret = vmw_user_dmabuf_lookup(tfile, mode_cmd->handle, &bo);\r\nif (ret) {\r\nDRM_ERROR("failed to find buffer: %i\n", ret);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nret = vmw_kms_new_framebuffer_dmabuf(dev_priv, bo, &vfb,\r\nmode_cmd);\r\nvmw_dmabuf_unreference(&bo);\r\nif (ret) {\r\nDRM_ERROR("failed to create vmw_framebuffer: %i\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &vfb->base;\r\nerr_not_scanout:\r\nDRM_ERROR("surface not marked as scanout\n");\r\nvmw_surface_unreference(&surface);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nint vmw_kms_init(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nint ret;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.funcs = &vmw_kms_funcs;\r\ndev->mode_config.min_width = 1;\r\ndev->mode_config.min_height = 1;\r\ndev->mode_config.max_width = 8192;\r\ndev->mode_config.max_height = 8192;\r\nret = vmw_kms_init_legacy_display_system(dev_priv);\r\nreturn 0;\r\n}\r\nint vmw_kms_close(struct vmw_private *dev_priv)\r\n{\r\ndrm_mode_config_cleanup(dev_priv->dev);\r\nvmw_kms_close_legacy_display_system(dev_priv);\r\nreturn 0;\r\n}\r\nint vmw_kms_cursor_bypass_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_cursor_bypass_arg *arg = data;\r\nstruct vmw_display_unit *du;\r\nstruct drm_mode_object *obj;\r\nstruct drm_crtc *crtc;\r\nint ret = 0;\r\nmutex_lock(&dev->mode_config.mutex);\r\nif (arg->flags & DRM_VMW_CURSOR_BYPASS_ALL) {\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\ndu = vmw_crtc_to_du(crtc);\r\ndu->hotspot_x = arg->xhot;\r\ndu->hotspot_y = arg->yhot;\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn 0;\r\n}\r\nobj = drm_mode_object_find(dev, arg->crtc_id, DRM_MODE_OBJECT_CRTC);\r\nif (!obj) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncrtc = obj_to_crtc(obj);\r\ndu = vmw_crtc_to_du(crtc);\r\ndu->hotspot_x = arg->xhot;\r\ndu->hotspot_y = arg->yhot;\r\nout:\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn ret;\r\n}\r\nvoid vmw_kms_write_svga(struct vmw_private *vmw_priv,\r\nunsigned width, unsigned height, unsigned pitch,\r\nunsigned bbp, unsigned depth)\r\n{\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_write(vmw_priv, SVGA_REG_PITCHLOCK, pitch);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\niowrite32(pitch, vmw_priv->mmio_virt + SVGA_FIFO_PITCHLOCK);\r\nvmw_write(vmw_priv, SVGA_REG_WIDTH, width);\r\nvmw_write(vmw_priv, SVGA_REG_HEIGHT, height);\r\nvmw_write(vmw_priv, SVGA_REG_BITS_PER_PIXEL, bbp);\r\nvmw_write(vmw_priv, SVGA_REG_DEPTH, depth);\r\nvmw_write(vmw_priv, SVGA_REG_RED_MASK, 0x00ff0000);\r\nvmw_write(vmw_priv, SVGA_REG_GREEN_MASK, 0x0000ff00);\r\nvmw_write(vmw_priv, SVGA_REG_BLUE_MASK, 0x000000ff);\r\n}\r\nint vmw_kms_save_vga(struct vmw_private *vmw_priv)\r\n{\r\nstruct vmw_vga_topology_state *save;\r\nuint32_t i;\r\nvmw_priv->vga_width = vmw_read(vmw_priv, SVGA_REG_WIDTH);\r\nvmw_priv->vga_height = vmw_read(vmw_priv, SVGA_REG_HEIGHT);\r\nvmw_priv->vga_depth = vmw_read(vmw_priv, SVGA_REG_DEPTH);\r\nvmw_priv->vga_bpp = vmw_read(vmw_priv, SVGA_REG_BITS_PER_PIXEL);\r\nvmw_priv->vga_pseudo = vmw_read(vmw_priv, SVGA_REG_PSEUDOCOLOR);\r\nvmw_priv->vga_red_mask = vmw_read(vmw_priv, SVGA_REG_RED_MASK);\r\nvmw_priv->vga_blue_mask = vmw_read(vmw_priv, SVGA_REG_BLUE_MASK);\r\nvmw_priv->vga_green_mask = vmw_read(vmw_priv, SVGA_REG_GREEN_MASK);\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_priv->vga_pitchlock =\r\nvmw_read(vmw_priv, SVGA_REG_PITCHLOCK);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\nvmw_priv->vga_pitchlock = ioread32(vmw_priv->mmio_virt +\r\nSVGA_FIFO_PITCHLOCK);\r\nif (!(vmw_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY))\r\nreturn 0;\r\nvmw_priv->num_displays = vmw_read(vmw_priv,\r\nSVGA_REG_NUM_GUEST_DISPLAYS);\r\nif (vmw_priv->num_displays == 0)\r\nvmw_priv->num_displays = 1;\r\nfor (i = 0; i < vmw_priv->num_displays; ++i) {\r\nsave = &vmw_priv->vga_save[i];\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, i);\r\nsave->primary = vmw_read(vmw_priv, SVGA_REG_DISPLAY_IS_PRIMARY);\r\nsave->pos_x = vmw_read(vmw_priv, SVGA_REG_DISPLAY_POSITION_X);\r\nsave->pos_y = vmw_read(vmw_priv, SVGA_REG_DISPLAY_POSITION_Y);\r\nsave->width = vmw_read(vmw_priv, SVGA_REG_DISPLAY_WIDTH);\r\nsave->height = vmw_read(vmw_priv, SVGA_REG_DISPLAY_HEIGHT);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\nif (i == 0 && vmw_priv->num_displays == 1 &&\r\nsave->width == 0 && save->height == 0) {\r\nsave->width = vmw_priv->vga_width - save->pos_x;\r\nsave->height = vmw_priv->vga_height - save->pos_y;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint vmw_kms_restore_vga(struct vmw_private *vmw_priv)\r\n{\r\nstruct vmw_vga_topology_state *save;\r\nuint32_t i;\r\nvmw_write(vmw_priv, SVGA_REG_WIDTH, vmw_priv->vga_width);\r\nvmw_write(vmw_priv, SVGA_REG_HEIGHT, vmw_priv->vga_height);\r\nvmw_write(vmw_priv, SVGA_REG_DEPTH, vmw_priv->vga_depth);\r\nvmw_write(vmw_priv, SVGA_REG_BITS_PER_PIXEL, vmw_priv->vga_bpp);\r\nvmw_write(vmw_priv, SVGA_REG_PSEUDOCOLOR, vmw_priv->vga_pseudo);\r\nvmw_write(vmw_priv, SVGA_REG_RED_MASK, vmw_priv->vga_red_mask);\r\nvmw_write(vmw_priv, SVGA_REG_GREEN_MASK, vmw_priv->vga_green_mask);\r\nvmw_write(vmw_priv, SVGA_REG_BLUE_MASK, vmw_priv->vga_blue_mask);\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_write(vmw_priv, SVGA_REG_PITCHLOCK,\r\nvmw_priv->vga_pitchlock);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\niowrite32(vmw_priv->vga_pitchlock,\r\nvmw_priv->mmio_virt + SVGA_FIFO_PITCHLOCK);\r\nif (!(vmw_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY))\r\nreturn 0;\r\nfor (i = 0; i < vmw_priv->num_displays; ++i) {\r\nsave = &vmw_priv->vga_save[i];\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, i);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_IS_PRIMARY, save->primary);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_POSITION_X, save->pos_x);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_POSITION_Y, save->pos_y);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_WIDTH, save->width);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_HEIGHT, save->height);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\n}\r\nreturn 0;\r\n}\r\nint vmw_kms_update_layout_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_update_layout_arg *arg =\r\n(struct drm_vmw_update_layout_arg *)data;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nvoid __user *user_rects;\r\nstruct drm_vmw_rect *rects;\r\nunsigned rects_size;\r\nint ret;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (!arg->num_outputs) {\r\nstruct drm_vmw_rect def_rect = {0, 0, 800, 600};\r\nvmw_kms_ldu_update_layout(dev_priv, 1, &def_rect);\r\ngoto out_unlock;\r\n}\r\nrects_size = arg->num_outputs * sizeof(struct drm_vmw_rect);\r\nrects = kzalloc(rects_size, GFP_KERNEL);\r\nif (unlikely(!rects)) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nuser_rects = (void __user *)(unsigned long)arg->rects;\r\nret = copy_from_user(rects, user_rects, rects_size);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to get rects.\n");\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nvmw_kms_ldu_update_layout(dev_priv, arg->num_outputs, rects);\r\nout_free:\r\nkfree(rects);\r\nout_unlock:\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}\r\nbool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv,\r\nuint32_t pitch,\r\nuint32_t height)\r\n{\r\nreturn ((u64) pitch * (u64) height) < (u64) dev_priv->vram_size;\r\n}\r\nu32 vmw_get_vblank_counter(struct drm_device *dev, int crtc)\r\n{\r\nreturn 0;\r\n}
