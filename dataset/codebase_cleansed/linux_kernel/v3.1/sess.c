static bool is_first_ses_reconnect(struct cifs_ses *ses)\r\n{\r\nstruct list_head *tmp;\r\nstruct cifs_ses *tmp_ses;\r\nlist_for_each(tmp, &ses->server->smb_ses_list) {\r\ntmp_ses = list_entry(tmp, struct cifs_ses,\r\nsmb_ses_list);\r\nif (tmp_ses->need_reconnect == false)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic __le16 get_next_vcnum(struct cifs_ses *ses)\r\n{\r\n__u16 vcnum = 0;\r\nstruct list_head *tmp;\r\nstruct cifs_ses *tmp_ses;\r\n__u16 max_vcs = ses->server->max_vcs;\r\n__u16 i;\r\nint free_vc_found = 0;\r\nif (max_vcs < 2)\r\nmax_vcs = 0xFFFF;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nif ((ses->need_reconnect) && is_first_ses_reconnect(ses))\r\ngoto get_vc_num_exit;\r\nfor (i = ses->server->srv_count - 1; i < max_vcs; i++) {\r\nif (i == 0)\r\nbreak;\r\nfree_vc_found = 1;\r\nlist_for_each(tmp, &ses->server->smb_ses_list) {\r\ntmp_ses = list_entry(tmp, struct cifs_ses,\r\nsmb_ses_list);\r\nif (tmp_ses->vcnum == i) {\r\nfree_vc_found = 0;\r\nbreak;\r\n}\r\n}\r\nif (free_vc_found)\r\nbreak;\r\n}\r\nif (i == 0)\r\nvcnum = 0;\r\nelse if (free_vc_found == 0)\r\nvcnum = 1;\r\nelse\r\nvcnum = i;\r\nses->vcnum = vcnum;\r\nget_vc_num_exit:\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn cpu_to_le16(vcnum);\r\n}\r\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\r\n{\r\n__u32 capabilities = 0;\r\npSMB->req.AndXCommand = 0xFF;\r\npSMB->req.MaxBufferSize = cpu_to_le16(ses->server->maxBuf);\r\npSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\r\npSMB->req.VcNumber = get_next_vcnum(ses);\r\ncapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\r\nCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\r\nif (ses->server->sec_mode &\r\n(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\r\npSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\r\nif (ses->capabilities & CAP_UNICODE) {\r\npSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\r\ncapabilities |= CAP_UNICODE;\r\n}\r\nif (ses->capabilities & CAP_STATUS32) {\r\npSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\r\ncapabilities |= CAP_STATUS32;\r\n}\r\nif (ses->capabilities & CAP_DFS) {\r\npSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\r\ncapabilities |= CAP_DFS;\r\n}\r\nif (ses->capabilities & CAP_UNIX)\r\ncapabilities |= CAP_UNIX;\r\nreturn capabilities;\r\n}\r\nstatic void\r\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\r\n{\r\nchar *bcc_ptr = *pbcc_area;\r\nint bytes_ret = 0;\r\nbytes_ret = cifs_strtoUCS((__le16 *)bcc_ptr, "Linux version ", 32,\r\nnls_cp);\r\nbcc_ptr += 2 * bytes_ret;\r\nbytes_ret = cifs_strtoUCS((__le16 *) bcc_ptr, init_utsname()->release,\r\n32, nls_cp);\r\nbcc_ptr += 2 * bytes_ret;\r\nbcc_ptr += 2;\r\nbytes_ret = cifs_strtoUCS((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\r\n32, nls_cp);\r\nbcc_ptr += 2 * bytes_ret;\r\nbcc_ptr += 2;\r\n*pbcc_area = bcc_ptr;\r\n}\r\nstatic void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nchar *bcc_ptr = *pbcc_area;\r\nint bytes_ret = 0;\r\nif (ses->domainName == NULL) {\r\n*bcc_ptr = 0;\r\n*(bcc_ptr+1) = 0;\r\nbytes_ret = 0;\r\n} else\r\nbytes_ret = cifs_strtoUCS((__le16 *) bcc_ptr, ses->domainName,\r\n256, nls_cp);\r\nbcc_ptr += 2 * bytes_ret;\r\nbcc_ptr += 2;\r\n*pbcc_area = bcc_ptr;\r\n}\r\nstatic void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nchar *bcc_ptr = *pbcc_area;\r\nint bytes_ret = 0;\r\nif (ses->user_name == NULL) {\r\n*bcc_ptr = 0;\r\n*(bcc_ptr+1) = 0;\r\n} else {\r\nbytes_ret = cifs_strtoUCS((__le16 *) bcc_ptr, ses->user_name,\r\nMAX_USERNAME_SIZE, nls_cp);\r\n}\r\nbcc_ptr += 2 * bytes_ret;\r\nbcc_ptr += 2;\r\nunicode_domain_string(&bcc_ptr, ses, nls_cp);\r\nunicode_oslm_strings(&bcc_ptr, nls_cp);\r\n*pbcc_area = bcc_ptr;\r\n}\r\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nchar *bcc_ptr = *pbcc_area;\r\nif (ses->user_name != NULL)\r\nstrncpy(bcc_ptr, ses->user_name, MAX_USERNAME_SIZE);\r\nbcc_ptr += strnlen(ses->user_name, MAX_USERNAME_SIZE);\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\nif (ses->domainName != NULL) {\r\nstrncpy(bcc_ptr, ses->domainName, 256);\r\nbcc_ptr += strnlen(ses->domainName, 256);\r\n}\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\nstrcpy(bcc_ptr, "Linux version ");\r\nbcc_ptr += strlen("Linux version ");\r\nstrcpy(bcc_ptr, init_utsname()->release);\r\nbcc_ptr += strlen(init_utsname()->release) + 1;\r\nstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\r\nbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\r\n*pbcc_area = bcc_ptr;\r\n}\r\nstatic void\r\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint len;\r\nchar *data = *pbcc_area;\r\ncFYI(1, "bleft %d", bleft);\r\nkfree(ses->serverOS);\r\nses->serverOS = cifs_strndup_from_ucs(data, bleft, true, nls_cp);\r\ncFYI(1, "serverOS=%s", ses->serverOS);\r\nlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\r\ndata += len;\r\nbleft -= len;\r\nif (bleft <= 0)\r\nreturn;\r\nkfree(ses->serverNOS);\r\nses->serverNOS = cifs_strndup_from_ucs(data, bleft, true, nls_cp);\r\ncFYI(1, "serverNOS=%s", ses->serverNOS);\r\nlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\r\ndata += len;\r\nbleft -= len;\r\nif (bleft <= 0)\r\nreturn;\r\nkfree(ses->serverDomain);\r\nses->serverDomain = cifs_strndup_from_ucs(data, bleft, true, nls_cp);\r\ncFYI(1, "serverDomain=%s", ses->serverDomain);\r\nreturn;\r\n}\r\nstatic int decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\r\nstruct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint rc = 0;\r\nint len;\r\nchar *bcc_ptr = *pbcc_area;\r\ncFYI(1, "decode sessetup ascii. bleft %d", bleft);\r\nlen = strnlen(bcc_ptr, bleft);\r\nif (len >= bleft)\r\nreturn rc;\r\nkfree(ses->serverOS);\r\nses->serverOS = kzalloc(len + 1, GFP_KERNEL);\r\nif (ses->serverOS)\r\nstrncpy(ses->serverOS, bcc_ptr, len);\r\nif (strncmp(ses->serverOS, "OS/2", 4) == 0) {\r\ncFYI(1, "OS/2 server");\r\nses->flags |= CIFS_SES_OS2;\r\n}\r\nbcc_ptr += len + 1;\r\nbleft -= len + 1;\r\nlen = strnlen(bcc_ptr, bleft);\r\nif (len >= bleft)\r\nreturn rc;\r\nkfree(ses->serverNOS);\r\nses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\r\nif (ses->serverNOS)\r\nstrncpy(ses->serverNOS, bcc_ptr, len);\r\nbcc_ptr += len + 1;\r\nbleft -= len + 1;\r\nlen = strnlen(bcc_ptr, bleft);\r\nif (len > bleft)\r\nreturn rc;\r\ncFYI(1, "ascii: bytes left %d", bleft);\r\nreturn rc;\r\n}\r\nstatic int decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\r\nstruct cifs_ses *ses)\r\n{\r\nunsigned int tioffset;\r\nunsigned int tilen;\r\nCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\r\nif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\r\ncERROR(1, "challenge blob len %d too small", blob_len);\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(pblob->Signature, "NTLMSSP", 8)) {\r\ncERROR(1, "blob signature incorrect %s", pblob->Signature);\r\nreturn -EINVAL;\r\n}\r\nif (pblob->MessageType != NtLmChallenge) {\r\ncERROR(1, "Incorrect message type %d", pblob->MessageType);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\r\nses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\r\ntioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\r\ntilen = le16_to_cpu(pblob->TargetInfoArray.Length);\r\nif (tilen) {\r\nses->auth_key.response = kmalloc(tilen, GFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\ncERROR(1, "Challenge target info allocation failure");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(ses->auth_key.response, bcc_ptr + tioffset, tilen);\r\nses->auth_key.len = tilen;\r\n}\r\nreturn 0;\r\n}\r\nstatic void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\r\nstruct cifs_ses *ses)\r\n{\r\nNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\r\n__u32 flags;\r\nmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\r\nmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\r\nsec_blob->MessageType = NtLmNegotiate;\r\nflags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET |\r\nNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\r\nNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\r\nif (ses->server->sec_mode &\r\n(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED)) {\r\nflags |= NTLMSSP_NEGOTIATE_SIGN;\r\nif (!ses->server->session_estab)\r\nflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\r\n}\r\nsec_blob->NegotiateFlags = cpu_to_le32(flags);\r\nsec_blob->WorkstationName.BufferOffset = 0;\r\nsec_blob->WorkstationName.Length = 0;\r\nsec_blob->WorkstationName.MaximumLength = 0;\r\nsec_blob->DomainName.BufferOffset = 0;\r\nsec_blob->DomainName.Length = 0;\r\nsec_blob->DomainName.MaximumLength = 0;\r\n}\r\nstatic int build_ntlmssp_auth_blob(unsigned char *pbuffer,\r\nu16 *buflen,\r\nstruct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint rc;\r\nAUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;\r\n__u32 flags;\r\nunsigned char *tmp;\r\nmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\r\nsec_blob->MessageType = NtLmAuthenticate;\r\nflags = NTLMSSP_NEGOTIATE_56 |\r\nNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\r\nNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\r\nNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\r\nif (ses->server->sec_mode &\r\n(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED)) {\r\nflags |= NTLMSSP_NEGOTIATE_SIGN;\r\nif (!ses->server->session_estab)\r\nflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\r\n}\r\ntmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);\r\nsec_blob->NegotiateFlags = cpu_to_le32(flags);\r\nsec_blob->LmChallengeResponse.BufferOffset =\r\ncpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\r\nsec_blob->LmChallengeResponse.Length = 0;\r\nsec_blob->LmChallengeResponse.MaximumLength = 0;\r\nsec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nrc = setup_ntlmv2_rsp(ses, nls_cp);\r\nif (rc) {\r\ncERROR(1, "Error %d during NTLMSSP authentication", rc);\r\ngoto setup_ntlmv2_ret;\r\n}\r\nmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\ntmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\r\nsec_blob->NtChallengeResponse.Length =\r\ncpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\nsec_blob->NtChallengeResponse.MaximumLength =\r\ncpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\nif (ses->domainName == NULL) {\r\nsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->DomainName.Length = 0;\r\nsec_blob->DomainName.MaximumLength = 0;\r\ntmp += 2;\r\n} else {\r\nint len;\r\nlen = cifs_strtoUCS((__le16 *)tmp, ses->domainName,\r\nMAX_USERNAME_SIZE, nls_cp);\r\nlen *= 2;\r\nsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->DomainName.Length = cpu_to_le16(len);\r\nsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\r\ntmp += len;\r\n}\r\nif (ses->user_name == NULL) {\r\nsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->UserName.Length = 0;\r\nsec_blob->UserName.MaximumLength = 0;\r\ntmp += 2;\r\n} else {\r\nint len;\r\nlen = cifs_strtoUCS((__le16 *)tmp, ses->user_name,\r\nMAX_USERNAME_SIZE, nls_cp);\r\nlen *= 2;\r\nsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->UserName.Length = cpu_to_le16(len);\r\nsec_blob->UserName.MaximumLength = cpu_to_le16(len);\r\ntmp += len;\r\n}\r\nsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->WorkstationName.Length = 0;\r\nsec_blob->WorkstationName.MaximumLength = 0;\r\ntmp += 2;\r\nif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\r\n(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\r\n&& !calc_seckey(ses)) {\r\nmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\r\nsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\r\nsec_blob->SessionKey.MaximumLength =\r\ncpu_to_le16(CIFS_CPHTXT_SIZE);\r\ntmp += CIFS_CPHTXT_SIZE;\r\n} else {\r\nsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);\r\nsec_blob->SessionKey.Length = 0;\r\nsec_blob->SessionKey.MaximumLength = 0;\r\n}\r\nsetup_ntlmv2_ret:\r\n*buflen = tmp - pbuffer;\r\nreturn rc;\r\n}\r\nint\r\nCIFS_SessSetup(unsigned int xid, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint rc = 0;\r\nint wct;\r\nstruct smb_hdr *smb_buf;\r\nchar *bcc_ptr;\r\nchar *str_area;\r\nSESSION_SETUP_ANDX *pSMB;\r\n__u32 capabilities;\r\n__u16 count;\r\nint resp_buf_type;\r\nstruct kvec iov[3];\r\nenum securityEnum type;\r\n__u16 action, bytes_remaining;\r\nstruct key *spnego_key = NULL;\r\n__le32 phase = NtLmNegotiate;\r\nu16 blob_len;\r\nchar *ntlmsspblob = NULL;\r\nif (ses == NULL)\r\nreturn -EINVAL;\r\ntype = ses->server->secType;\r\ncFYI(1, "sess setup type %d", type);\r\nif (type == RawNTLMSSP) {\r\nses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\r\nif (!ses->ntlmssp)\r\nreturn -ENOMEM;\r\n}\r\nssetup_ntlmssp_authenticate:\r\nif (phase == NtLmChallenge)\r\nphase = NtLmAuthenticate;\r\nif (type == LANMAN) {\r\n#ifndef CONFIG_CIFS_WEAK_PW_HASH\r\nreturn -EOPNOTSUPP;\r\n#endif\r\nwct = 10;\r\n} else if ((type == NTLM) || (type == NTLMv2)) {\r\nwct = 13;\r\n} else\r\nwct = 12;\r\nrc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\r\n(void **)&smb_buf);\r\nif (rc)\r\nreturn rc;\r\npSMB = (SESSION_SETUP_ANDX *)smb_buf;\r\ncapabilities = cifs_ssetup_hdr(ses, pSMB);\r\niov[0].iov_base = (char *)pSMB;\r\niov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\r\nresp_buf_type = CIFS_SMALL_BUFFER;\r\nstr_area = kmalloc(2000, GFP_KERNEL);\r\nif (str_area == NULL) {\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nbcc_ptr = str_area;\r\nses->flags &= ~CIFS_SES_LANMAN;\r\niov[1].iov_base = NULL;\r\niov[1].iov_len = 0;\r\nif (type == LANMAN) {\r\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\r\nchar lnm_session_key[CIFS_AUTH_RESP_SIZE];\r\npSMB->req.hdr.Flags2 &= ~SMBFLG2_UNICODE;\r\npSMB->old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\r\nrc = calc_lanman_hash(ses->password, ses->server->cryptkey,\r\nses->server->sec_mode & SECMODE_PW_ENCRYPT ?\r\ntrue : false, lnm_session_key);\r\nses->flags |= CIFS_SES_LANMAN;\r\nmemcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);\r\nbcc_ptr += CIFS_AUTH_RESP_SIZE;\r\ncFYI(1, "Negotiating LANMAN setting up strings");\r\nascii_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n#endif\r\n} else if (type == NTLM) {\r\npSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\r\npSMB->req_no_secext.CaseInsensitivePasswordLength =\r\ncpu_to_le16(CIFS_AUTH_RESP_SIZE);\r\npSMB->req_no_secext.CaseSensitivePasswordLength =\r\ncpu_to_le16(CIFS_AUTH_RESP_SIZE);\r\nrc = setup_ntlm_response(ses);\r\nif (rc) {\r\ncERROR(1, "Error %d during NTLM authentication", rc);\r\ngoto ssetup_exit;\r\n}\r\nmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nCIFS_AUTH_RESP_SIZE);\r\nbcc_ptr += CIFS_AUTH_RESP_SIZE;\r\nmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nCIFS_AUTH_RESP_SIZE);\r\nbcc_ptr += CIFS_AUTH_RESP_SIZE;\r\nif (ses->capabilities & CAP_UNICODE) {\r\nif (iov[0].iov_len % 2) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\nunicode_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n} else\r\nascii_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n} else if (type == NTLMv2) {\r\npSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\r\npSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\r\nrc = setup_ntlmv2_rsp(ses, nls_cp);\r\nif (rc) {\r\ncERROR(1, "Error %d during NTLMv2 authentication", rc);\r\ngoto ssetup_exit;\r\n}\r\nmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\nbcc_ptr += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\r\npSMB->req_no_secext.CaseSensitivePasswordLength =\r\ncpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\r\nif (ses->capabilities & CAP_UNICODE) {\r\nif (iov[0].iov_len % 2) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\nunicode_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n} else\r\nascii_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n} else if (type == Kerberos) {\r\n#ifdef CONFIG_CIFS_UPCALL\r\nstruct cifs_spnego_msg *msg;\r\nspnego_key = cifs_get_spnego_key(ses);\r\nif (IS_ERR(spnego_key)) {\r\nrc = PTR_ERR(spnego_key);\r\nspnego_key = NULL;\r\ngoto ssetup_exit;\r\n}\r\nmsg = spnego_key->payload.data;\r\nif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\r\ncERROR(1, "incorrect version of cifs.upcall (expected"\r\n" %d but got %d)",\r\nCIFS_SPNEGO_UPCALL_VERSION, msg->version);\r\nrc = -EKEYREJECTED;\r\ngoto ssetup_exit;\r\n}\r\nses->auth_key.response = kmalloc(msg->sesskey_len, GFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\ncERROR(1, "Kerberos can't allocate (%u bytes) memory",\r\nmsg->sesskey_len);\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nmemcpy(ses->auth_key.response, msg->data, msg->sesskey_len);\r\nses->auth_key.len = msg->sesskey_len;\r\npSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\r\ncapabilities |= CAP_EXTENDED_SECURITY;\r\npSMB->req.Capabilities = cpu_to_le32(capabilities);\r\niov[1].iov_base = msg->data + msg->sesskey_len;\r\niov[1].iov_len = msg->secblob_len;\r\npSMB->req.SecurityBlobLength = cpu_to_le16(iov[1].iov_len);\r\nif (ses->capabilities & CAP_UNICODE) {\r\nif ((iov[0].iov_len + iov[1].iov_len) % 2) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\nunicode_oslm_strings(&bcc_ptr, nls_cp);\r\nunicode_domain_string(&bcc_ptr, ses, nls_cp);\r\n} else\r\nascii_ssetup_strings(&bcc_ptr, ses, nls_cp);\r\n#else\r\ncERROR(1, "Kerberos negotiated but upcall support disabled!");\r\nrc = -ENOSYS;\r\ngoto ssetup_exit;\r\n#endif\r\n} else if (type == RawNTLMSSP) {\r\nif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\r\ncERROR(1, "NTLMSSP requires Unicode support");\r\nrc = -ENOSYS;\r\ngoto ssetup_exit;\r\n}\r\ncFYI(1, "ntlmssp session setup phase %d", phase);\r\npSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\r\ncapabilities |= CAP_EXTENDED_SECURITY;\r\npSMB->req.Capabilities |= cpu_to_le32(capabilities);\r\nswitch(phase) {\r\ncase NtLmNegotiate:\r\nbuild_ntlmssp_negotiate_blob(\r\npSMB->req.SecurityBlob, ses);\r\niov[1].iov_len = sizeof(NEGOTIATE_MESSAGE);\r\niov[1].iov_base = pSMB->req.SecurityBlob;\r\npSMB->req.SecurityBlobLength =\r\ncpu_to_le16(sizeof(NEGOTIATE_MESSAGE));\r\nbreak;\r\ncase NtLmAuthenticate:\r\nntlmsspblob = kzalloc(\r\n5*sizeof(struct _AUTHENTICATE_MESSAGE),\r\nGFP_KERNEL);\r\nif (!ntlmsspblob) {\r\ncERROR(1, "Can't allocate NTLMSSP blob");\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nrc = build_ntlmssp_auth_blob(ntlmsspblob,\r\n&blob_len, ses, nls_cp);\r\nif (rc)\r\ngoto ssetup_exit;\r\niov[1].iov_len = blob_len;\r\niov[1].iov_base = ntlmsspblob;\r\npSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\r\nsmb_buf->Uid = ses->Suid;\r\nbreak;\r\ndefault:\r\ncERROR(1, "invalid phase %d", phase);\r\nrc = -ENOSYS;\r\ngoto ssetup_exit;\r\n}\r\nif ((iov[0].iov_len + iov[1].iov_len) % 2) {\r\n*bcc_ptr = 0;\r\nbcc_ptr++;\r\n}\r\nunicode_oslm_strings(&bcc_ptr, nls_cp);\r\n} else {\r\ncERROR(1, "secType %d not supported!", type);\r\nrc = -ENOSYS;\r\ngoto ssetup_exit;\r\n}\r\niov[2].iov_base = str_area;\r\niov[2].iov_len = (long) bcc_ptr - (long) str_area;\r\ncount = iov[1].iov_len + iov[2].iov_len;\r\nsmb_buf->smb_buf_length =\r\ncpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\r\nput_bcc(count, smb_buf);\r\nrc = SendReceive2(xid, ses, iov, 3 , &resp_buf_type,\r\nCIFS_LOG_ERROR);\r\npSMB = (SESSION_SETUP_ANDX *)iov[0].iov_base;\r\nsmb_buf = (struct smb_hdr *)iov[0].iov_base;\r\nif ((type == RawNTLMSSP) && (smb_buf->Status.CifsError ==\r\ncpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))) {\r\nif (phase != NtLmNegotiate) {\r\ncERROR(1, "Unexpected more processing error");\r\ngoto ssetup_exit;\r\n}\r\nphase = NtLmChallenge;\r\nrc = 0;\r\n}\r\nif (rc)\r\ngoto ssetup_exit;\r\nif ((smb_buf->WordCount != 3) && (smb_buf->WordCount != 4)) {\r\nrc = -EIO;\r\ncERROR(1, "bad word count %d", smb_buf->WordCount);\r\ngoto ssetup_exit;\r\n}\r\naction = le16_to_cpu(pSMB->resp.Action);\r\nif (action & GUEST_LOGIN)\r\ncFYI(1, "Guest login");\r\nses->Suid = smb_buf->Uid;\r\ncFYI(1, "UID = %d ", ses->Suid);\r\nbytes_remaining = get_bcc(smb_buf);\r\nbcc_ptr = pByteArea(smb_buf);\r\nif (smb_buf->WordCount == 4) {\r\nblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\r\nif (blob_len > bytes_remaining) {\r\ncERROR(1, "bad security blob length %d", blob_len);\r\nrc = -EINVAL;\r\ngoto ssetup_exit;\r\n}\r\nif (phase == NtLmChallenge) {\r\nrc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\r\nif (rc)\r\ngoto ssetup_exit;\r\n}\r\nbcc_ptr += blob_len;\r\nbytes_remaining -= blob_len;\r\n}\r\nif (bytes_remaining == 0) {\r\n} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\r\nif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\r\n++bcc_ptr;\r\n--bytes_remaining;\r\n}\r\ndecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses, nls_cp);\r\n} else {\r\nrc = decode_ascii_ssetup(&bcc_ptr, bytes_remaining,\r\nses, nls_cp);\r\n}\r\nssetup_exit:\r\nif (spnego_key) {\r\nkey_revoke(spnego_key);\r\nkey_put(spnego_key);\r\n}\r\nkfree(str_area);\r\nkfree(ntlmsspblob);\r\nntlmsspblob = NULL;\r\nif (resp_buf_type == CIFS_SMALL_BUFFER) {\r\ncFYI(1, "ssetup freeing small buf %p", iov[0].iov_base);\r\ncifs_small_buf_release(iov[0].iov_base);\r\n} else if (resp_buf_type == CIFS_LARGE_BUFFER)\r\ncifs_buf_release(iov[0].iov_base);\r\nif ((phase == NtLmChallenge) && (rc == 0))\r\ngoto ssetup_ntlmssp_authenticate;\r\nreturn rc;\r\n}
