void mod_wired_entry(int entry, unsigned long entrylo0,\r\nunsigned long entrylo1, unsigned long entryhi,\r\nunsigned long pagemask)\r\n{\r\nunsigned long old_pagemask;\r\nunsigned long old_ctx;\r\nold_ctx = read_c0_entryhi() & 0xff;\r\nold_pagemask = read_c0_pagemask();\r\nwrite_c0_index(entry);\r\nwrite_c0_pagemask(pagemask);\r\nwrite_c0_entryhi(entryhi);\r\nwrite_c0_entrylo0(entrylo0);\r\nwrite_c0_entrylo1(entrylo1);\r\ntlb_write_indexed();\r\nwrite_c0_entryhi(old_ctx);\r\nwrite_c0_pagemask(old_pagemask);\r\n}\r\nvoid __init au1x_pci_cfg_init(void)\r\n{\r\npci_cfg_vm = get_vm_area(0x2000, VM_IOREMAP);\r\nif (!pci_cfg_vm)\r\npanic(KERN_ERR "PCI unable to get vm area\n");\r\npci_cfg_wired_entry = read_c0_wired();\r\nadd_wired_entry(0, 0, (unsigned long)pci_cfg_vm->addr, PM_4K);\r\nlast_entryLo0 = last_entryLo1 = 0xffffffff;\r\n}\r\nstatic int config_access(unsigned char access_type, struct pci_bus *bus,\r\nunsigned int dev_fn, unsigned char where, u32 *data)\r\n{\r\n#if defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)\r\nunsigned int device = PCI_SLOT(dev_fn);\r\nunsigned int function = PCI_FUNC(dev_fn);\r\nunsigned long offset, status;\r\nunsigned long cfg_base;\r\nunsigned long flags;\r\nint error = PCIBIOS_SUCCESSFUL;\r\nunsigned long entryLo0, entryLo1;\r\nif (device > 19) {\r\n*data = 0xffffffff;\r\nreturn -1;\r\n}\r\nlocal_irq_save(flags);\r\nau_writel(((0x2000 << 16) | (au_readl(Au1500_PCI_STATCMD) & 0xffff)),\r\nAu1500_PCI_STATCMD);\r\nau_sync_udelay(1);\r\nif (board_pci_idsel && board_pci_idsel(device, 1) == 0) {\r\n*data = 0xffffffff;\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\nif (bus->number == 0)\r\ncfg_base = (1 << device) << 11;\r\nelse\r\ncfg_base = 0x80000000 | (bus->number << 16) | (device << 11);\r\noffset = (function << 8) | (where & ~0x3);\r\noffset |= cfg_base & ~PAGE_MASK;\r\ncfg_base = cfg_base & PAGE_MASK;\r\nentryLo0 = (6 << 26) | (cfg_base >> 6) | (2 << 3) | 7;\r\nentryLo1 = (6 << 26) | (cfg_base >> 6) | (0x1000 >> 6) | (2 << 3) | 7;\r\nif ((entryLo0 != last_entryLo0) || (entryLo1 != last_entryLo1)) {\r\nmod_wired_entry(pci_cfg_wired_entry, entryLo0, entryLo1,\r\n(unsigned long)pci_cfg_vm->addr, PM_4K);\r\nlast_entryLo0 = entryLo0;\r\nlast_entryLo1 = entryLo1;\r\n}\r\nif (access_type == PCI_ACCESS_WRITE)\r\nau_writel(*data, (int)(pci_cfg_vm->addr + offset));\r\nelse\r\n*data = au_readl((int)(pci_cfg_vm->addr + offset));\r\nau_sync_udelay(2);\r\nDBG("cfg_access %d bus->number %u dev %u at %x *data %x conf %lx\n",\r\naccess_type, bus->number, device, where, *data, offset);\r\nstatus = au_readl(Au1500_PCI_STATCMD);\r\nif (status & (1 << 29)) {\r\n*data = 0xffffffff;\r\nerror = -1;\r\nDBG("Au1x Master Abort\n");\r\n} else if ((status >> 28) & 0xf) {\r\nDBG("PCI ERR detected: device %u, status %lx\n",\r\ndevice, (status >> 28) & 0xf);\r\nau_writel(status & 0xf000ffff, Au1500_PCI_STATCMD);\r\n*data = 0xffffffff;\r\nerror = -1;\r\n}\r\nif (board_pci_idsel)\r\n(void)board_pci_idsel(device, 0);\r\nlocal_irq_restore(flags);\r\nreturn error;\r\n#endif\r\n}\r\nstatic int read_config_byte(struct pci_bus *bus, unsigned int devfn,\r\nint where, u8 *val)\r\n{\r\nu32 data;\r\nint ret;\r\nret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);\r\nif (where & 1)\r\ndata >>= 8;\r\nif (where & 2)\r\ndata >>= 16;\r\n*val = data & 0xff;\r\nreturn ret;\r\n}\r\nstatic int read_config_word(struct pci_bus *bus, unsigned int devfn,\r\nint where, u16 *val)\r\n{\r\nu32 data;\r\nint ret;\r\nret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);\r\nif (where & 2)\r\ndata >>= 16;\r\n*val = data & 0xffff;\r\nreturn ret;\r\n}\r\nstatic int read_config_dword(struct pci_bus *bus, unsigned int devfn,\r\nint where, u32 *val)\r\n{\r\nint ret;\r\nret = config_access(PCI_ACCESS_READ, bus, devfn, where, val);\r\nreturn ret;\r\n}\r\nstatic int write_config_byte(struct pci_bus *bus, unsigned int devfn,\r\nint where, u8 val)\r\n{\r\nu32 data = 0;\r\nif (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))\r\nreturn -1;\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nif (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))\r\nreturn -1;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int write_config_word(struct pci_bus *bus, unsigned int devfn,\r\nint where, u16 val)\r\n{\r\nu32 data = 0;\r\nif (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))\r\nreturn -1;\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nif (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))\r\nreturn -1;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int write_config_dword(struct pci_bus *bus, unsigned int devfn,\r\nint where, u32 val)\r\n{\r\nif (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))\r\nreturn -1;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int config_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nswitch (size) {\r\ncase 1: {\r\nu8 _val;\r\nint rc = read_config_byte(bus, devfn, where, &_val);\r\n*val = _val;\r\nreturn rc;\r\n}\r\ncase 2: {\r\nu16 _val;\r\nint rc = read_config_word(bus, devfn, where, &_val);\r\n*val = _val;\r\nreturn rc;\r\n}\r\ndefault:\r\nreturn read_config_dword(bus, devfn, where, val);\r\n}\r\n}\r\nstatic int config_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nswitch (size) {\r\ncase 1:\r\nreturn write_config_byte(bus, devfn, where, (u8) val);\r\ncase 2:\r\nreturn write_config_word(bus, devfn, where, (u16) val);\r\ndefault:\r\nreturn write_config_dword(bus, devfn, where, val);\r\n}\r\n}
