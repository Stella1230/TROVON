static inline u8 button_status(void)\r\n{\r\nu8 status;\r\nstatus = readb(&sgioc->panel) ^ 0xa0;\r\nreturn ((status & 0x80) >> 6) | ((status & 0x20) >> 5);\r\n}\r\nstatic inline u8 button_status(void)\r\n{\r\nu64 status;\r\nstatus = readq(&mace->perif.audio.control);\r\nwriteq(status & ~(3U << 23), &mace->perif.audio.control);\r\nreturn (status >> 23) & 3;\r\n}\r\nstatic void handle_buttons(struct input_polled_dev *dev)\r\n{\r\nstruct buttons_dev *bdev = dev->private;\r\nstruct input_dev *input = dev->input;\r\nu8 status;\r\nint i;\r\nstatus = button_status();\r\nfor (i = 0; i < ARRAY_SIZE(bdev->keymap); i++) {\r\nif (status & (1U << i)) {\r\nif (++bdev->count[i] == BUTTONS_COUNT_THRESHOLD) {\r\ninput_event(input, EV_MSC, MSC_SCAN, i);\r\ninput_report_key(input, bdev->keymap[i], 1);\r\ninput_sync(input);\r\n}\r\n} else {\r\nif (bdev->count[i] >= BUTTONS_COUNT_THRESHOLD) {\r\ninput_event(input, EV_MSC, MSC_SCAN, i);\r\ninput_report_key(input, bdev->keymap[i], 0);\r\ninput_sync(input);\r\n}\r\nbdev->count[i] = 0;\r\n}\r\n}\r\n}\r\nstatic int __devinit sgi_buttons_probe(struct platform_device *pdev)\r\n{\r\nstruct buttons_dev *bdev;\r\nstruct input_polled_dev *poll_dev;\r\nstruct input_dev *input;\r\nint error, i;\r\nbdev = kzalloc(sizeof(struct buttons_dev), GFP_KERNEL);\r\npoll_dev = input_allocate_polled_device();\r\nif (!bdev || !poll_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nmemcpy(bdev->keymap, sgi_map, sizeof(bdev->keymap));\r\npoll_dev->private = bdev;\r\npoll_dev->poll = handle_buttons;\r\npoll_dev->poll_interval = BUTTONS_POLL_INTERVAL;\r\ninput = poll_dev->input;\r\ninput->name = "SGI buttons";\r\ninput->phys = "sgi/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &pdev->dev;\r\ninput->keycode = bdev->keymap;\r\ninput->keycodemax = ARRAY_SIZE(bdev->keymap);\r\ninput->keycodesize = sizeof(unsigned short);\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\n__set_bit(EV_KEY, input->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(sgi_map); i++)\r\n__set_bit(bdev->keymap[i], input->keybit);\r\n__clear_bit(KEY_RESERVED, input->keybit);\r\nbdev->poll_dev = poll_dev;\r\ndev_set_drvdata(&pdev->dev, bdev);\r\nerror = input_register_polled_device(poll_dev);\r\nif (error)\r\ngoto err_free_mem;\r\nreturn 0;\r\nerr_free_mem:\r\ninput_free_polled_device(poll_dev);\r\nkfree(bdev);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nreturn error;\r\n}\r\nstatic int __devexit sgi_buttons_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct buttons_dev *bdev = dev_get_drvdata(dev);\r\ninput_unregister_polled_device(bdev->poll_dev);\r\ninput_free_polled_device(bdev->poll_dev);\r\nkfree(bdev);\r\ndev_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init sgi_buttons_init(void)\r\n{\r\nreturn platform_driver_register(&sgi_buttons_driver);\r\n}\r\nstatic void __exit sgi_buttons_exit(void)\r\n{\r\nplatform_driver_unregister(&sgi_buttons_driver);\r\n}
