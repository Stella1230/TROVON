static int __init init_reg_offset(struct net_device *dev,unsigned long base_addr)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint i;\r\nunsigned char bus_width;\r\nbus_width = *(volatile unsigned char *)ABWCR;\r\nbus_width &= 1 << ((base_addr >> 21) & 7);\r\nfor (i = 0; i < ARRAY_SIZE(reg_offset); i++)\r\nif (bus_width == 0)\r\nreg_offset[i] = i * 2 + 1;\r\nelse\r\nreg_offset[i] = i;\r\nei_local->reg_offset = reg_offset;\r\nreturn 0;\r\n}\r\nstatic inline int init_dev(struct net_device *dev)\r\n{\r\nif (h8300_ne_count < ARRAY_SIZE(h8300_ne_base)) {\r\ndev->base_addr = h8300_ne_base[h8300_ne_count];\r\ndev->irq = h8300_ne_irq[h8300_ne_count];\r\nh8300_ne_count++;\r\nreturn 0;\r\n} else\r\nreturn -ENODEV;\r\n}\r\nstatic int __init do_ne_probe(struct net_device *dev)\r\n{\r\nunsigned int base_addr = dev->base_addr;\r\nif (base_addr > 0x1ff)\r\nreturn ne_probe1(dev, base_addr);\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\nreturn -ENODEV;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, NE_IO_EXTENT);\r\n}\r\nstruct net_device * __init ne_probe(int unit)\r\n{\r\nstruct net_device *dev = ____alloc_ei_netdev(0);\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (init_dev(dev))\r\nreturn ERR_PTR(-ENODEV);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = init_reg_offset(dev, dev->base_addr);\r\nif (err)\r\ngoto out;\r\nerr = do_ne_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init ne_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i;\r\nunsigned char SA_prom[16];\r\nint wordlength = 2;\r\nconst char *name = NULL;\r\nint start_page, stop_page;\r\nint reg0, ret;\r\nstatic unsigned version_printed;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned char bus_width;\r\nif (!request_region(ioaddr, NE_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\nreg0 = inb_p(ioaddr);\r\nif (reg0 == 0xFF) {\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\n{\r\nint regd;\r\noutb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);\r\nregd = inb_p(ioaddr + EI_SHIFT(0x0d));\r\noutb_p(0xff, ioaddr + EI_SHIFT(0x0d));\r\noutb_p(E8390_NODMA+E8390_PAGE0, ioaddr + E8390_CMD);\r\ninb_p(ioaddr + EN0_COUNTER0);\r\nif (inb_p(ioaddr + EN0_COUNTER0) != 0) {\r\noutb_p(reg0, ioaddr + EI_SHIFT(0));\r\noutb_p(regd, ioaddr + EI_SHIFT(0x0d));\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\n}\r\nif (ei_debug && version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version1);\r\nprintk(KERN_INFO "NE*000 ethercard probe at %08x:", ioaddr);\r\n{\r\nstruct {unsigned char value, offset; } program_seq[] =\r\n{\r\n{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},\r\n{0x48, EN0_DCFG},\r\n{0x00, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_IMR},\r\n{0xFF, EN0_ISR},\r\n{E8390_RXOFF, EN0_RXCR},\r\n{E8390_TXOFF, EN0_TXCR},\r\n{32, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_RSARLO},\r\n{0x00, EN0_RSARHI},\r\n{E8390_RREAD+E8390_START, E8390_CMD},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\r\noutb_p(program_seq[i].value, ioaddr + program_seq[i].offset);\r\n}\r\nbus_width = *(volatile unsigned char *)ABWCR;\r\nbus_width &= 1 << ((ioaddr >> 21) & 7);\r\nei_status.word16 = (bus_width == 0);\r\nfor(i = 0; i < 16 ; i++) {\r\nSA_prom[i] = inb_p(ioaddr + NE_DATAPORT);\r\ninb_p(ioaddr + NE_DATAPORT);\r\n}\r\nstart_page = NESM_START_PG;\r\nstop_page = NESM_STOP_PG;\r\nif (bus_width)\r\nwordlength = 1;\r\nelse\r\noutb_p(0x49, ioaddr + EN0_DCFG);\r\nname = (wordlength == 2) ? "NE2000" : "NE1000";\r\nif (! dev->irq) {\r\nprintk(" failed to detect IRQ line.\n");\r\nret = -EAGAIN;\r\ngoto err_out;\r\n}\r\nret = request_irq(dev->irq, __ei_interrupt, 0, name, dev);\r\nif (ret) {\r\nprintk (" unable to get IRQ %d (errno=%d).\n", dev->irq, ret);\r\ngoto err_out;\r\n}\r\ndev->base_addr = ioaddr;\r\nfor(i = 0; i < ETHER_ADDR_LEN; i++)\r\ndev->dev_addr[i] = SA_prom[i];\r\nprintk(" %pM\n", dev->dev_addr);\r\nprintk("%s: %s found at %#x, using IRQ %d.\n",\r\ndev->name, name, ioaddr, dev->irq);\r\nei_status.name = name;\r\nei_status.tx_start_page = start_page;\r\nei_status.stop_page = stop_page;\r\nei_status.word16 = (wordlength == 2);\r\nei_status.rx_start_page = start_page + TX_PAGES;\r\n#ifdef PACKETBUF_MEMSIZE\r\nei_status.stop_page = ei_status.tx_start_page + PACKETBUF_MEMSIZE;\r\n#endif\r\nei_status.reset_8390 = &ne_reset_8390;\r\nei_status.block_input = &ne_block_input;\r\nei_status.block_output = &ne_block_output;\r\nei_status.get_8390_hdr = &ne_get_8390_hdr;\r\nei_status.priv = 0;\r\ndev->netdev_ops = &ne_netdev_ops;\r\n__NS8390_init(dev, 0);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto out_irq;\r\nreturn 0;\r\nout_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_out:\r\nrelease_region(ioaddr, NE_IO_EXTENT);\r\nreturn ret;\r\n}\r\nstatic int ne_open(struct net_device *dev)\r\n{\r\n__ei_open(dev);\r\nreturn 0;\r\n}\r\nstatic int ne_close(struct net_device *dev)\r\n{\r\nif (ei_debug > 1)\r\nprintk(KERN_DEBUG "%s: Shutting down ethercard.\n", dev->name);\r\n__ei_close(dev);\r\nreturn 0;\r\n}\r\nstatic void ne_reset_8390(struct net_device *dev)\r\n{\r\nunsigned long reset_start_time = jiffies;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nif (ei_debug > 1)\r\nprintk(KERN_DEBUG "resetting the 8390 t=%ld...", jiffies);\r\noutb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\r\nei_status.txing = 0;\r\nei_status.dmaing = 0;\r\nwhile ((inb_p(NE_BASE+EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\r\nprintk(KERN_WARNING "%s: ne_reset_8390() did not complete.\n", dev->name);\r\nbreak;\r\n}\r\noutb_p(ENISR_RESET, NE_BASE + EN0_ISR);\r\n}\r\nstatic void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nif (ei_status.dmaing)\r\n{\r\nprintk(KERN_EMERG "%s: DMAing conflict in ne_get_8390_hdr "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, NE_BASE + NE_CMD);\r\noutb_p(sizeof(struct e8390_pkt_hdr), NE_BASE + EN0_RCNTLO);\r\noutb_p(0, NE_BASE + EN0_RCNTHI);\r\noutb_p(0, NE_BASE + EN0_RSARLO);\r\noutb_p(ring_page, NE_BASE + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, NE_BASE + NE_CMD);\r\nif (ei_status.word16) {\r\nint len;\r\nunsigned short *p = (unsigned short *)hdr;\r\nfor (len = sizeof(struct e8390_pkt_hdr)>>1; len > 0; len--)\r\n*p++ = inw(NE_BASE + NE_DATAPORT);\r\n} else\r\ninsb(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr));\r\noutb_p(ENISR_RDC, NE_BASE + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\nle16_to_cpus(&hdr->count);\r\n}\r\nstatic void ne_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\n#ifdef NE_SANITY_CHECK\r\nint xfer_count = count;\r\n#endif\r\nchar *buf = skb->data;\r\nif (ei_status.dmaing)\r\n{\r\nprintk(KERN_EMERG "%s: DMAing conflict in ne_block_input "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, NE_BASE + NE_CMD);\r\noutb_p(count & 0xff, NE_BASE + EN0_RCNTLO);\r\noutb_p(count >> 8, NE_BASE + EN0_RCNTHI);\r\noutb_p(ring_offset & 0xff, NE_BASE + EN0_RSARLO);\r\noutb_p(ring_offset >> 8, NE_BASE + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, NE_BASE + NE_CMD);\r\nif (ei_status.word16)\r\n{\r\nint len;\r\nunsigned short *p = (unsigned short *)buf;\r\nfor (len = count>>1; len > 0; len--)\r\n*p++ = inw(NE_BASE + NE_DATAPORT);\r\nif (count & 0x01)\r\n{\r\nbuf[count-1] = inb(NE_BASE + NE_DATAPORT);\r\n#ifdef NE_SANITY_CHECK\r\nxfer_count++;\r\n#endif\r\n}\r\n} else {\r\ninsb(NE_BASE + NE_DATAPORT, buf, count);\r\n}\r\n#ifdef NE_SANITY_CHECK\r\nif (ei_debug > 1)\r\n{\r\nint addr, tries = 20;\r\ndo {\r\nint high = inb_p(NE_BASE + EN0_RSARHI);\r\nint low = inb_p(NE_BASE + EN0_RSARLO);\r\naddr = (high << 8) + low;\r\nif (((ring_offset + xfer_count) & 0xff) == low)\r\nbreak;\r\n} while (--tries > 0);\r\nif (tries <= 0)\r\nprintk(KERN_WARNING "%s: RX transfer address mismatch,"\r\n"%#4.4x (expected) vs. %#4.4x (actual).\n",\r\ndev->name, ring_offset + xfer_count, addr);\r\n}\r\n#endif\r\noutb_p(ENISR_RDC, NE_BASE + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void ne_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, const int start_page)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned long dma_start;\r\n#ifdef NE_SANITY_CHECK\r\nint retries = 0;\r\n#endif\r\nif (ei_status.word16 && (count & 0x01))\r\ncount++;\r\nif (ei_status.dmaing)\r\n{\r\nprintk(KERN_EMERG "%s: DMAing conflict in ne_block_output."\r\n"[DMAstat:%d][irqlock:%d]\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_PAGE0+E8390_START+E8390_NODMA, NE_BASE + NE_CMD);\r\n#ifdef NE_SANITY_CHECK\r\nretry:\r\n#endif\r\n#ifdef NE8390_RW_BUGFIX\r\noutb_p(0x42, NE_BASE + EN0_RCNTLO);\r\noutb_p(0x00, NE_BASE + EN0_RCNTHI);\r\noutb_p(0x42, NE_BASE + EN0_RSARLO);\r\noutb_p(0x00, NE_BASE + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, NE_BASE + NE_CMD);\r\nudelay(6);\r\n#endif\r\noutb_p(ENISR_RDC, NE_BASE + EN0_ISR);\r\noutb_p(count & 0xff, NE_BASE + EN0_RCNTLO);\r\noutb_p(count >> 8, NE_BASE + EN0_RCNTHI);\r\noutb_p(0x00, NE_BASE + EN0_RSARLO);\r\noutb_p(start_page, NE_BASE + EN0_RSARHI);\r\noutb_p(E8390_RWRITE+E8390_START, NE_BASE + NE_CMD);\r\nif (ei_status.word16) {\r\nint len;\r\nunsigned short *p = (unsigned short *)buf;\r\nfor (len = count>>1; len > 0; len--)\r\noutw(*p++, NE_BASE + NE_DATAPORT);\r\n} else {\r\noutsb(NE_BASE + NE_DATAPORT, buf, count);\r\n}\r\ndma_start = jiffies;\r\n#ifdef NE_SANITY_CHECK\r\nif (ei_debug > 1)\r\n{\r\nint addr, tries = 20;\r\ndo {\r\nint high = inb_p(NE_BASE + EN0_RSARHI);\r\nint low = inb_p(NE_BASE + EN0_RSARLO);\r\naddr = (high << 8) + low;\r\nif ((start_page << 8) + count == addr)\r\nbreak;\r\n} while (--tries > 0);\r\nif (tries <= 0)\r\n{\r\nprintk(KERN_WARNING "%s: Tx packet transfer address mismatch,"\r\n"%#4.4x (expected) vs. %#4.4x (actual).\n",\r\ndev->name, (start_page << 8) + count, addr);\r\nif (retries++ == 0)\r\ngoto retry;\r\n}\r\n}\r\n#endif\r\nwhile ((inb_p(NE_BASE + EN0_ISR) & ENISR_RDC) == 0)\r\nif (time_after(jiffies, dma_start + 2*HZ/100)) {\r\nprintk(KERN_WARNING "%s: timeout waiting for Tx RDC.\n", dev->name);\r\nne_reset_8390(dev);\r\n__NS8390_init(dev,1);\r\nbreak;\r\n}\r\noutb_p(ENISR_RDC, NE_BASE + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nint init_module(void)\r\n{\r\nint this_dev, found = 0;\r\nint err;\r\nfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\r\nstruct net_device *dev = ____alloc_ei_netdev(0);\r\nif (!dev)\r\nbreak;\r\nif (io[this_dev]) {\r\ndev->irq = irq[this_dev];\r\ndev->mem_end = bad[this_dev];\r\ndev->base_addr = io[this_dev];\r\n} else {\r\ndev->base_addr = h8300_ne_base[this_dev];\r\ndev->irq = h8300_ne_irq[this_dev];\r\n}\r\nerr = init_reg_offset(dev, dev->base_addr);\r\nif (!err) {\r\nif (do_ne_probe(dev) == 0) {\r\ndev_ne[found++] = dev;\r\ncontinue;\r\n}\r\n}\r\nfree_netdev(dev);\r\nif (found)\r\nbreak;\r\nif (io[this_dev] != 0)\r\nprintk(KERN_WARNING "ne.c: No NE*000 card found at i/o = %#x\n", dev->base_addr);\r\nelse\r\nprintk(KERN_NOTICE "ne.c: You must supply \"io=0xNNN\" value(s) for ISA cards.\n");\r\nreturn -ENXIO;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nvoid cleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_ne[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
