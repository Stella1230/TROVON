static int port_paranoia_check(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port) {\r\ndbg("%s - port == NULL", function);\r\nreturn -1;\r\n}\r\nif (!port->serial) {\r\ndbg("%s - port->serial == NULL\n", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial_paranoia_check(struct usb_serial *serial,\r\nconst char *function)\r\n{\r\nif (!serial) {\r\ndbg("%s - serial == NULL\n", function);\r\nreturn -1;\r\n}\r\nif (!serial->type) {\r\ndbg("%s - serial->type == NULL!", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct quatech_port *qt_get_port_private(struct usb_serial_port\r\n*port)\r\n{\r\nreturn (struct quatech_port *)usb_get_serial_port_data(port);\r\n}\r\nstatic inline void qt_set_port_private(struct usb_serial_port *port,\r\nstruct quatech_port *data)\r\n{\r\nusb_set_serial_port_data(port, (void *)data);\r\n}\r\nstatic struct usb_serial *get_usb_serial(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port ||\r\nport_paranoia_check(port, function) ||\r\nserial_paranoia_check(port->serial, function)) {\r\nreturn NULL;\r\n}\r\nreturn port->serial;\r\n}\r\nstatic void ProcessLineStatus(struct quatech_port *qt_port,\r\nunsigned char line_status)\r\n{\r\nqt_port->shadowLSR =\r\nline_status & (SERIAL_LSR_OE | SERIAL_LSR_PE | SERIAL_LSR_FE |\r\nSERIAL_LSR_BI);\r\nreturn;\r\n}\r\nstatic void ProcessModemStatus(struct quatech_port *qt_port,\r\nunsigned char modem_status)\r\n{\r\nqt_port->shadowMSR = modem_status;\r\nwake_up_interruptible(&qt_port->wait);\r\nreturn;\r\n}\r\nstatic void ProcessRxChar(struct tty_struct *tty, struct usb_serial_port *port,\r\nunsigned char data)\r\n{\r\nstruct urb *urb = port->read_urb;\r\nif (urb->actual_length)\r\ntty_insert_flip_char(tty, data, TTY_NORMAL);\r\n}\r\nstatic void qt_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct tty_struct *tty;\r\nint status;\r\nstruct quatech_port *quatech_port;\r\nstatus = urb->status;\r\nif (status) {\r\ndbg("nonzero write bulk status received:%d\n", status);\r\nreturn;\r\n}\r\nquatech_port = urb->context;\r\ndbg("%s - port %d\n", __func__, quatech_port->port_num);\r\ntty = tty_port_tty_get(&quatech_port->port->port);\r\nif (tty)\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic void qt_interrupt_callback(struct urb *urb)\r\n{\r\n}\r\nstatic void qt_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port = qt_get_port_private(port);\r\nunsigned char *data;\r\nstruct tty_struct *tty;\r\nunsigned int index;\r\nunsigned int RxCount;\r\nint i, result;\r\nint flag, flag_data;\r\nif (urb->status) {\r\nqt_port->ReadBulkStopped = 1;\r\ndbg("%s - nonzero write bulk status received: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty) {\r\ndbg("%s - bad tty pointer - exiting", __func__);\r\nreturn;\r\n}\r\ndata = urb->transfer_buffer;\r\nRxCount = urb->actual_length;\r\nindex = tty->index - serial->minor;\r\ndbg("%s - port %d\n", __func__, port->number);\r\ndbg("%s - port->RxHolding = %d\n", __func__, qt_port->RxHolding);\r\nif (port_paranoia_check(port, __func__) != 0) {\r\ndbg("%s - port_paranoia_check, exiting\n", __func__);\r\nqt_port->ReadBulkStopped = 1;\r\ngoto exit;\r\n}\r\nif (!serial) {\r\ndbg("%s - bad serial pointer, exiting\n", __func__);\r\ngoto exit;\r\n}\r\nif (qt_port->closePending == 1) {\r\ndbg("%s - (qt_port->closepending == 1\n", __func__);\r\nqt_port->ReadBulkStopped = 1;\r\ngoto exit;\r\n}\r\nif (qt_port->RxHolding == 1) {\r\nqt_port->ReadBulkStopped = 1;\r\ngoto exit;\r\n}\r\nif (urb->status) {\r\nqt_port->ReadBulkStopped = 1;\r\ndbg("%s - nonzero read bulk status received: %d\n",\r\n__func__, urb->status);\r\ngoto exit;\r\n}\r\nif (tty && RxCount) {\r\nflag_data = 0;\r\nfor (i = 0; i < RxCount; ++i) {\r\nif ((i <= (RxCount - 3)) && (data[i] == 0x1b)\r\n&& (data[i + 1] == 0x1b)) {\r\nflag = 0;\r\nswitch (data[i + 2]) {\r\ncase 0x00:\r\nif (i > (RxCount - 4)) {\r\ndbg("Illegal escape seuences in received data\n");\r\nbreak;\r\n}\r\nProcessLineStatus(qt_port, data[i + 3]);\r\ni += 3;\r\nflag = 1;\r\nbreak;\r\ncase 0x01:\r\ndbg("Modem status status.\n");\r\nif (i > (RxCount - 4)) {\r\ndbg("Illegal escape sequences in received data\n");\r\nbreak;\r\n}\r\nProcessModemStatus(qt_port,\r\ndata[i + 3]);\r\ni += 3;\r\nflag = 1;\r\nbreak;\r\ncase 0xff:\r\ndbg("No status sequence.\n");\r\nif (tty) {\r\nProcessRxChar(tty, port, data[i]);\r\nProcessRxChar(tty, port, data[i + 1]);\r\n}\r\ni += 2;\r\nbreak;\r\n}\r\nif (flag == 1)\r\ncontinue;\r\n}\r\nif (tty && urb->actual_length)\r\ntty_insert_flip_char(tty, data[i], TTY_NORMAL);\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\nusb_fill_bulk_urb(port->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->read_urb->transfer_buffer,\r\nport->read_urb->transfer_buffer_length,\r\nqt_read_bulk_callback, port);\r\nresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (result)\r\ndbg("%s - failed resubmitting read urb, error %d",\r\n__func__, result);\r\nelse {\r\nif (tty && RxCount) {\r\ntty_flip_buffer_push(tty);\r\ntty_schedule_flip(tty);\r\n}\r\n}\r\nschedule_work(&port->work);\r\nexit:\r\ntty_kref_put(tty);\r\n}\r\nstatic int qt_get_device(struct usb_serial *serial,\r\nstruct qt_get_device_data *device_data)\r\n{\r\nint result;\r\nunsigned char *transfer_buffer;\r\ntransfer_buffer =\r\nkmalloc(sizeof(struct qt_get_device_data), GFP_KERNEL);\r\nif (!transfer_buffer)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT_SET_GET_DEVICE, 0xc0, 0, 0,\r\ntransfer_buffer,\r\nsizeof(struct qt_get_device_data), 300);\r\nif (result > 0)\r\nmemcpy(device_data, transfer_buffer,\r\nsizeof(struct qt_get_device_data));\r\nkfree(transfer_buffer);\r\nreturn result;\r\n}\r\nstatic int BoxSetPrebufferLevel(struct usb_serial *serial)\r\n{\r\nint result;\r\n__u16 buffer_length;\r\nbuffer_length = PREFUFF_LEVEL_CONSERVATIVE;\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_GET_SET_PREBUF_TRIG_LVL, 0x40,\r\nbuffer_length, 0, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int BoxSetATC(struct usb_serial *serial, __u16 n_Mode)\r\n{\r\nint result;\r\n__u16 buffer_length;\r\nbuffer_length = PREFUFF_LEVEL_CONSERVATIVE;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_SET_ATF, 0x40, n_Mode, 0, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt_set_device(struct usb_serial *serial,\r\nstruct qt_get_device_data *device_data)\r\n{\r\nint result;\r\n__u16 length;\r\n__u16 PortSettings;\r\nPortSettings = ((__u16) (device_data->portb));\r\nPortSettings = (PortSettings << 8);\r\nPortSettings += ((__u16) (device_data->porta));\r\nlength = sizeof(struct qt_get_device_data);\r\ndbg("%s - PortSettings = 0x%x\n", __func__, PortSettings);\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_SET_GET_DEVICE, 0x40, PortSettings,\r\n0, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt_open_channel(struct usb_serial *serial, __u16 Uart_Number,\r\nstruct qt_open_channel_data *pDeviceData)\r\n{\r\nint result;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT_OPEN_CLOSE_CHANNEL,\r\nUSBD_TRANSFER_DIRECTION_IN, 1, Uart_Number,\r\npDeviceData,\r\nsizeof(struct qt_open_channel_data), 300);\r\nreturn result;\r\n}\r\nstatic int qt_close_channel(struct usb_serial *serial, __u16 Uart_Number)\r\n{\r\nint result;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT_OPEN_CLOSE_CHANNEL,\r\nUSBD_TRANSFER_DIRECTION_OUT, 0, Uart_Number,\r\nNULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int BoxGetRegister(struct usb_serial *serial, unsigned short Uart_Number,\r\nunsigned short Register_Num, __u8 *pValue)\r\n{\r\nint result;\r\n__u16 current_length;\r\ncurrent_length = sizeof(struct qt_get_device_data);\r\nresult =\r\nusb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nQT_GET_SET_REGISTER, 0xC0, Register_Num,\r\nUart_Number, (void *)pValue, sizeof(*pValue), 300);\r\nreturn result;\r\n}\r\nstatic int BoxSetRegister(struct usb_serial *serial, unsigned short Uart_Number,\r\nunsigned short Register_Num, unsigned short Value)\r\n{\r\nint result;\r\nunsigned short RegAndByte;\r\nRegAndByte = Value;\r\nRegAndByte = RegAndByte << 8;\r\nRegAndByte = RegAndByte + Register_Num;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_GET_SET_REGISTER, 0x40, RegAndByte, Uart_Number,\r\nNULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt_setuart(struct usb_serial *serial, unsigned short Uart_Number,\r\nunsigned short default_divisor, unsigned char default_LCR)\r\n{\r\nint result;\r\nunsigned short UartNumandLCR;\r\nUartNumandLCR = (default_LCR << 8) + Uart_Number;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_GET_SET_UART, 0x40, default_divisor,\r\nUartNumandLCR, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int BoxSetHW_FlowCtrl(struct usb_serial *serial, unsigned int index,\r\nint bSet)\r\n{\r\n__u8 mcr = 0;\r\n__u8 msr = 0, MOUT_Value = 0;\r\nunsigned int status;\r\nif (bSet == 1) {\r\nmcr = SERIAL_MCR_RTS;\r\n}\r\nelse {\r\nmcr = 0;\r\n}\r\nMOUT_Value = mcr << 8;\r\nif (bSet == 1) {\r\nmsr = SERIAL_MSR_CTS;\r\n} else {\r\nmsr = 0;\r\n}\r\nMOUT_Value |= msr;\r\nstatus =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_HW_FLOW_CONTROL_MASK, 0x40, MOUT_Value,\r\nindex, NULL, 0, 300);\r\nreturn status;\r\n}\r\nstatic int BoxSetSW_FlowCtrl(struct usb_serial *serial, __u16 index,\r\nunsigned char stop_char, unsigned char start_char)\r\n{\r\n__u16 nSWflowout;\r\nint result;\r\nnSWflowout = start_char << 8;\r\nnSWflowout = (unsigned short)stop_char;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_SW_FLOW_CONTROL_MASK, 0x40, nSWflowout,\r\nindex, NULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int BoxDisable_SW_FlowCtrl(struct usb_serial *serial, __u16 index)\r\n{\r\nint result;\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_SW_FLOW_CONTROL_DISABLE, 0x40, 0, index,\r\nNULL, 0, 300);\r\nreturn result;\r\n}\r\nstatic int qt_startup(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct quatech_port *qt_port;\r\nstruct qt_get_device_data DeviceData;\r\nint i;\r\nint status;\r\ndbg("enterting %s", __func__);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nqt_port = kzalloc(sizeof(*qt_port), GFP_KERNEL);\r\nif (!qt_port) {\r\ndbg("%s: kmalloc for quatech_port (%d) failed!.",\r\n__func__, i);\r\nfor (--i; i >= 0; i--) {\r\nport = serial->port[i];\r\nkfree(usb_get_serial_port_data(port));\r\nusb_set_serial_port_data(port, NULL);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&qt_port->lock);\r\nusb_set_serial_port_data(port, qt_port);\r\n}\r\nstatus = qt_get_device(serial, &DeviceData);\r\nif (status < 0) {\r\ndbg(__FILE__ "box_get_device failed");\r\ngoto startup_error;\r\n}\r\ndbg(__FILE__ "DeviceData.portb = 0x%x", DeviceData.portb);\r\nDeviceData.portb &= ~FULLPWRBIT;\r\ndbg(__FILE__ "Changing DeviceData.portb to 0x%x", DeviceData.portb);\r\nstatus = qt_set_device(serial, &DeviceData);\r\nif (status < 0) {\r\ndbg(__FILE__ "qt_set_device failed\n");\r\ngoto startup_error;\r\n}\r\nstatus = qt_get_device(serial, &DeviceData);\r\nif (status < 0) {\r\ndbg(__FILE__ "qt_get_device failed");\r\ngoto startup_error;\r\n}\r\nswitch (serial->dev->descriptor.idProduct) {\r\ncase QUATECH_SSU100:\r\ncase QUATECH_DSU100:\r\ncase QUATECH_QSU100:\r\ncase QUATECH_ESU100A:\r\ncase QUATECH_ESU100B:\r\ncase QUATECH_HSU100A:\r\ncase QUATECH_HSU100B:\r\ncase QUATECH_HSU100C:\r\ncase QUATECH_HSU100D:\r\nDeviceData.porta &= ~(RR_BITS | DUPMODE_BITS);\r\nDeviceData.porta |= CLKS_X4;\r\nDeviceData.portb &= ~(LOOPMODE_BITS);\r\nDeviceData.portb |= RS232_MODE;\r\nbreak;\r\ncase QUATECH_SSU200:\r\ncase QUATECH_DSU200:\r\ncase QUATECH_QSU200:\r\ncase QUATECH_ESU200A:\r\ncase QUATECH_ESU200B:\r\ncase QUATECH_HSU200A:\r\ncase QUATECH_HSU200B:\r\ncase QUATECH_HSU200C:\r\ncase QUATECH_HSU200D:\r\nDeviceData.porta &= ~(RR_BITS | DUPMODE_BITS);\r\nDeviceData.porta |= CLKS_X4;\r\nDeviceData.portb &= ~(LOOPMODE_BITS);\r\nDeviceData.portb |= ALL_LOOPBACK;\r\nbreak;\r\ndefault:\r\nDeviceData.porta &= ~(RR_BITS | DUPMODE_BITS);\r\nDeviceData.porta |= CLKS_X4;\r\nDeviceData.portb &= ~(LOOPMODE_BITS);\r\nDeviceData.portb |= RS232_MODE;\r\nbreak;\r\n}\r\nstatus = BoxSetPrebufferLevel(serial);\r\nif (status < 0) {\r\ndbg(__FILE__ "BoxSetPrebufferLevel failed\n");\r\ngoto startup_error;\r\n}\r\nstatus = BoxSetATC(serial, ATC_DISABLED);\r\nif (status < 0) {\r\ndbg(__FILE__ "BoxSetATC failed\n");\r\ngoto startup_error;\r\n}\r\ndbg(__FILE__ "DeviceData.portb = 0x%x", DeviceData.portb);\r\nDeviceData.portb |= NEXT_BOARD_POWER_BIT;\r\ndbg(__FILE__ "Changing DeviceData.portb to 0x%x", DeviceData.portb);\r\nstatus = qt_set_device(serial, &DeviceData);\r\nif (status < 0) {\r\ndbg(__FILE__ "qt_set_device failed\n");\r\ngoto startup_error;\r\n}\r\ndbg("Exit Success %s\n", __func__);\r\nreturn 0;\r\nstartup_error:\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nqt_port = qt_get_port_private(port);\r\nkfree(qt_port);\r\nusb_set_serial_port_data(port, NULL);\r\n}\r\ndbg("Exit fail %s\n", __func__);\r\nreturn -EIO;\r\n}\r\nstatic void qt_release(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct quatech_port *qt_port;\r\nint i;\r\ndbg("enterting %s", __func__);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nif (!port)\r\ncontinue;\r\nqt_port = usb_get_serial_port_data(port);\r\nkfree(qt_port);\r\nusb_set_serial_port_data(port, NULL);\r\n}\r\n}\r\nstatic int qt_open(struct tty_struct *tty,\r\nstruct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct quatech_port *quatech_port;\r\nstruct quatech_port *port0;\r\nstruct qt_open_channel_data ChannelData;\r\nint result;\r\nif (port_paranoia_check(port, __func__))\r\nreturn -ENODEV;\r\ndbg("%s - port %d\n", __func__, port->number);\r\nserial = port->serial;\r\nif (serial_paranoia_check(serial, __func__))\r\nreturn -ENODEV;\r\nquatech_port = qt_get_port_private(port);\r\nport0 = qt_get_port_private(serial->port[0]);\r\nif (quatech_port == NULL || port0 == NULL)\r\nreturn -ENODEV;\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nport0->open_ports++;\r\nresult = qt_get_device(serial, &port0->DeviceData);\r\nresult = qt_open_channel(serial, port->number, &ChannelData);\r\nif (result < 0) {\r\ndbg(__FILE__ "qt_open_channel failed\n");\r\nreturn result;\r\n}\r\ndbg(__FILE__ "qt_open_channel completed.\n");\r\nquatech_port->shadowLSR = ChannelData.line_status &\r\n(SERIAL_LSR_OE | SERIAL_LSR_PE | SERIAL_LSR_FE | SERIAL_LSR_BI);\r\nquatech_port->shadowMSR = ChannelData.modem_status &\r\n(SERIAL_MSR_CTS | SERIAL_MSR_DSR | SERIAL_MSR_RI | SERIAL_MSR_CD);\r\nresult = qt_setuart(serial, port->number, DEFAULT_DIVISOR, DEFAULT_LCR);\r\nif (result < 0) {\r\ndbg(__FILE__ "qt_setuart failed\n");\r\nreturn result;\r\n}\r\ndbg(__FILE__ "qt_setuart completed.\n");\r\nif (port0->open_ports == 1) {\r\nif (serial->port[0]->interrupt_in_buffer == NULL) {\r\nusb_fill_int_urb(serial->port[0]->interrupt_in_urb,\r\nserial->dev,\r\nusb_rcvintpipe(serial->dev,\r\nserial->port[0]->interrupt_in_endpointAddress),\r\nserial->port[0]->interrupt_in_buffer,\r\nserial->port[0]->\r\ninterrupt_in_urb->transfer_buffer_length,\r\nqt_interrupt_callback, serial,\r\nserial->port[0]->\r\ninterrupt_in_urb->interval);\r\nresult =\r\nusb_submit_urb(serial->port[0]->interrupt_in_urb,\r\nGFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - Error %d submitting "\r\n"interrupt urb\n", __func__, result);\r\n}\r\n}\r\n}\r\ndbg("port number is %d\n", port->number);\r\ndbg("serial number is %d\n", port->serial->minor);\r\ndbg("Bulkin endpoint is %d\n", port->bulk_in_endpointAddress);\r\ndbg("BulkOut endpoint is %d\n", port->bulk_out_endpointAddress);\r\ndbg("Interrupt endpoint is %d\n", port->interrupt_in_endpointAddress);\r\ndbg("port's number in the device is %d\n", quatech_port->port_num);\r\nquatech_port->read_urb = port->read_urb;\r\nusb_fill_bulk_urb(quatech_port->read_urb,\r\nserial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->bulk_in_buffer,\r\nquatech_port->read_urb->transfer_buffer_length,\r\nqt_read_bulk_callback, quatech_port);\r\ndbg("qt_open: bulkin endpoint is %d\n", port->bulk_in_endpointAddress);\r\nquatech_port->read_urb_busy = true;\r\nresult = usb_submit_urb(quatech_port->read_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, result);\r\nquatech_port->read_urb_busy = false;\r\n}\r\ninit_waitqueue_head(&quatech_port->wait);\r\ninit_waitqueue_head(&quatech_port->msr_wait);\r\nmemset(&(quatech_port->icount), 0x00, sizeof(quatech_port->icount));\r\nreturn 0;\r\n}\r\nstatic int qt_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial;\r\nint chars = 0;\r\nserial = get_usb_serial(port, __func__);\r\ndbg("%s - port %d\n", __func__, port->number);\r\nif (serial->num_bulk_out) {\r\nif (port->write_urb->status == -EINPROGRESS)\r\nchars = port->write_urb->transfer_buffer_length;\r\n}\r\ndbg("%s - returns %d\n", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic void qt_block_until_empty(struct tty_struct *tty,\r\nstruct quatech_port *qt_port)\r\n{\r\nint timeout = HZ / 10;\r\nint wait = 30;\r\nint count;\r\nwhile (1) {\r\ncount = qt_chars_in_buffer(tty);\r\nif (count <= 0)\r\nreturn;\r\ninterruptible_sleep_on_timeout(&qt_port->wait, timeout);\r\nwait--;\r\nif (wait == 0) {\r\ndbg("%s - TIMEOUT", __func__);\r\nreturn;\r\n} else {\r\nwait = 30;\r\n}\r\n}\r\n}\r\nstatic void qt_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct quatech_port *qt_port;\r\nstruct quatech_port *port0;\r\nstruct tty_struct *tty;\r\nint status;\r\nunsigned int index;\r\nstatus = 0;\r\ndbg("%s - port %d\n", __func__, port->number);\r\ntty = tty_port_tty_get(&port->port);\r\nindex = tty->index - serial->minor;\r\nqt_port = qt_get_port_private(port);\r\nport0 = qt_get_port_private(serial->port[0]);\r\nif (serial->num_bulk_out)\r\nusb_unlink_urb(port->write_urb);\r\nif (serial->num_bulk_in)\r\nusb_unlink_urb(port->read_urb);\r\nif (serial->dev)\r\nqt_block_until_empty(tty, qt_port);\r\ntty_kref_put(tty);\r\nstatus = qt_close_channel(serial, index);\r\nif (status < 0)\r\ndbg("%s - port %d qt_close_channel failed.\n",\r\n__func__, port->number);\r\nport0->open_ports--;\r\ndbg("qt_num_open_ports in close%d:in port%d\n",\r\nport0->open_ports, port->number);\r\nif (port0->open_ports == 0) {\r\nif (serial->port[0]->interrupt_in_urb) {\r\ndbg("%s", "Shutdown interrupt_in_urb\n");\r\nusb_kill_urb(serial->port[0]->interrupt_in_urb);\r\n}\r\n}\r\nif (qt_port->write_urb) {\r\nkfree(qt_port->write_urb->transfer_buffer);\r\nusb_free_urb(qt_port->write_urb);\r\n}\r\n}\r\nstatic int qt_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nint result;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nif (serial == NULL)\r\nreturn -ENODEV;\r\ndbg("%s - port %d\n", __func__, port->number);\r\nif (count == 0) {\r\ndbg("%s - write request of 0 bytes\n", __func__);\r\nreturn 0;\r\n}\r\nif (serial->num_bulk_out) {\r\nif (port->write_urb->status == -EINPROGRESS) {\r\ndbg("%s - already writing\n", __func__);\r\nreturn 0;\r\n}\r\ncount =\r\n(count > port->bulk_out_size) ? port->bulk_out_size : count;\r\nmemcpy(port->write_urb->transfer_buffer, buf, count);\r\nusb_fill_bulk_urb(port->write_urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->\r\nbulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, count,\r\nqt_write_bulk_callback, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (result)\r\ndbg("%s - failed submitting write urb, error %d\n",\r\n__func__, result);\r\nelse\r\nresult = count;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qt_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial;\r\nstruct quatech_port *qt_port;\r\nunsigned long flags;\r\nint retval = -EINVAL;\r\nif (port_paranoia_check(port, __func__)) {\r\ndbg("%s", "Invalid port\n");\r\nreturn -1;\r\n}\r\nserial = get_usb_serial(port, __func__);\r\nif (!serial)\r\nreturn -ENODEV;\r\nqt_port = qt_get_port_private(port);\r\nspin_lock_irqsave(&qt_port->lock, flags);\r\ndbg("%s - port %d\n", __func__, port->number);\r\nif (serial->num_bulk_out) {\r\nif (port->write_urb->status != -EINPROGRESS)\r\nretval = port->bulk_out_size;\r\n}\r\nspin_unlock_irqrestore(&qt_port->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int qt_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct quatech_port *qt_port = qt_get_port_private(port);\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nunsigned int index;\r\ndbg("%s cmd 0x%04x", __func__, cmd);\r\nindex = tty->index - serial->minor;\r\nif (cmd == TIOCMIWAIT) {\r\nwhile (qt_port != NULL) {\r\ninterruptible_sleep_on(&qt_port->msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nelse {\r\nchar diff = qt_port->diff_status;\r\nif (diff == 0)\r\nreturn -EIO;\r\nqt_port->diff_status = 0;\r\nif (((arg & TIOCM_RNG)\r\n&& (diff & SERIAL_MSR_RI))\r\n|| ((arg & TIOCM_DSR)\r\n&& (diff & SERIAL_MSR_DSR))\r\n|| ((arg & TIOCM_CD)\r\n&& (diff & SERIAL_MSR_CD))\r\n|| ((arg & TIOCM_CTS)\r\n&& (diff & SERIAL_MSR_CTS))) {\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\ndbg("%s -No ioctl for that one. port = %d\n", __func__, port->number);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void qt_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct ktermios *termios = tty->termios;\r\nunsigned char new_LCR = 0;\r\nunsigned int cflag = termios->c_cflag;\r\nunsigned int index;\r\nint baud, divisor, remainder;\r\nint status;\r\ndbg("%s", __func__);\r\nindex = tty->index - port->serial->minor;\r\nswitch (cflag) {\r\ncase CS5:\r\nnew_LCR |= SERIAL_5_DATA;\r\nbreak;\r\ncase CS6:\r\nnew_LCR |= SERIAL_6_DATA;\r\nbreak;\r\ncase CS7:\r\nnew_LCR |= SERIAL_7_DATA;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nnew_LCR |= SERIAL_8_DATA;\r\nbreak;\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\nnew_LCR |= SERIAL_ODD_PARITY;\r\nelse\r\nnew_LCR |= SERIAL_EVEN_PARITY;\r\n}\r\nif (cflag & CSTOPB)\r\nnew_LCR |= SERIAL_TWO_STOPB;\r\nelse\r\nnew_LCR |= SERIAL_ONE_STOPB;\r\ndbg("%s - 4\n", __func__);\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\ndbg("%s - got baud = %d\n", __func__, baud);\r\ndivisor = MAX_BAUD_RATE / baud;\r\nremainder = MAX_BAUD_RATE % baud;\r\nif (((remainder * 2) >= baud) && (baud != 110))\r\ndivisor++;\r\nstatus =\r\nqt_setuart(port->serial, index, (unsigned short)divisor, new_LCR);\r\nif (status < 0) {\r\ndbg(__FILE__ "qt_setuart failed\n");\r\nreturn;\r\n}\r\nif (cflag & CRTSCTS) {\r\ndbg("%s - Enabling HW flow control port %d\n", __func__,\r\nport->number);\r\nstatus = BoxSetHW_FlowCtrl(port->serial, index, 1);\r\nif (status < 0) {\r\ndbg(__FILE__ "BoxSetHW_FlowCtrl failed\n");\r\nreturn;\r\n}\r\n} else {\r\ndbg("%s - disabling HW flow control port %d\n", __func__,\r\nport->number);\r\nstatus = BoxSetHW_FlowCtrl(port->serial, index, 0);\r\nif (status < 0) {\r\ndbg(__FILE__ "BoxSetHW_FlowCtrl failed\n");\r\nreturn;\r\n}\r\n}\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus =\r\nBoxSetSW_FlowCtrl(port->serial, index, stop_char,\r\nstart_char);\r\nif (status < 0)\r\ndbg(__FILE__ "BoxSetSW_FlowCtrl (enabled) failed\n");\r\n} else {\r\nstatus = BoxDisable_SW_FlowCtrl(port->serial, index);\r\nif (status < 0)\r\ndbg(__FILE__ "BoxSetSW_FlowCtrl (diabling) failed\n");\r\n}\r\ntty->termios->c_cflag &= ~CMSPAR;\r\n}\r\nstatic void qt_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port;\r\nu16 index, onoff;\r\nunsigned int result;\r\nunsigned long flags;\r\nindex = tty->index - serial->minor;\r\nqt_port = qt_get_port_private(port);\r\nif (break_state == -1)\r\nonoff = 1;\r\nelse\r\nonoff = 0;\r\nspin_lock_irqsave(&qt_port->lock, flags);\r\ndbg("%s - port %d\n", __func__, port->number);\r\nresult =\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nQT_BREAK_CONTROL, 0x40, onoff, index, NULL, 0, 300);\r\nspin_unlock_irqrestore(&qt_port->lock, flags);\r\n}\r\nstatic inline int qt_real_tiocmget(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct usb_serial *serial)\r\n{\r\nu8 mcr;\r\nu8 msr;\r\nunsigned int result = 0;\r\nint status;\r\nunsigned int index;\r\ndbg("%s - port %d, tty =0x%p\n", __func__, port->number, tty);\r\nindex = tty->index - serial->minor;\r\nstatus =\r\nBoxGetRegister(port->serial, index, MODEM_CONTROL_REGISTER, &mcr);\r\nif (status >= 0) {\r\nstatus =\r\nBoxGetRegister(port->serial, index,\r\nMODEM_STATUS_REGISTER, &msr);\r\n}\r\nif (status >= 0) {\r\nresult = ((mcr & SERIAL_MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & SERIAL_MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((msr & SERIAL_MSR_CTS) ? TIOCM_CTS : 0)\r\n| ((msr & SERIAL_MSR_CD) ? TIOCM_CAR : 0)\r\n| ((msr & SERIAL_MSR_RI) ? TIOCM_RI : 0)\r\n| ((msr & SERIAL_MSR_DSR) ? TIOCM_DSR : 0);\r\nreturn result;\r\n} else\r\nreturn -ESPIPE;\r\n}\r\nstatic inline int qt_real_tiocmset(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct usb_serial *serial,\r\nunsigned int value)\r\n{\r\nu8 mcr;\r\nint status;\r\nunsigned int index;\r\ndbg("%s - port %d\n", __func__, port->number);\r\nindex = tty->index - serial->minor;\r\nstatus =\r\nBoxGetRegister(port->serial, index, MODEM_CONTROL_REGISTER, &mcr);\r\nif (status < 0)\r\nreturn -ESPIPE;\r\nmcr &= ~(SERIAL_MCR_RTS | SERIAL_MCR_DTR | SERIAL_MCR_LOOP);\r\nif (value & TIOCM_RTS)\r\nmcr |= SERIAL_MCR_RTS;\r\nif (value & TIOCM_DTR)\r\nmcr |= SERIAL_MCR_DTR;\r\nif (value & TIOCM_LOOP)\r\nmcr |= SERIAL_MCR_LOOP;\r\nstatus =\r\nBoxSetRegister(port->serial, index, MODEM_CONTROL_REGISTER, mcr);\r\nif (status < 0)\r\nreturn -ESPIPE;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int qt_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port = qt_get_port_private(port);\r\nint retval = -ENODEV;\r\nunsigned long flags;\r\ndbg("In %s\n", __func__);\r\nif (!serial)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&qt_port->lock, flags);\r\ndbg("%s - port %d\n", __func__, port->number);\r\ndbg("%s - port->RxHolding = %d\n", __func__, qt_port->RxHolding);\r\nretval = qt_real_tiocmget(tty, port, serial);\r\nspin_unlock_irqrestore(&qt_port->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int qt_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port = qt_get_port_private(port);\r\nunsigned long flags;\r\nint retval = -ENODEV;\r\ndbg("In %s\n", __func__);\r\nif (!serial)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&qt_port->lock, flags);\r\ndbg("%s - port %d\n", __func__, port->number);\r\ndbg("%s - qt_port->RxHolding = %d\n", __func__, qt_port->RxHolding);\r\nretval = qt_real_tiocmset(tty, port, serial, set);\r\nspin_unlock_irqrestore(&qt_port->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void qt_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port;\r\nunsigned long flags;\r\ndbg("%s - port %d\n", __func__, port->number);\r\nif (!serial)\r\nreturn;\r\nqt_port = qt_get_port_private(port);\r\nspin_lock_irqsave(&qt_port->lock, flags);\r\nqt_port->RxHolding = 1;\r\ndbg("%s - port->RxHolding = 1\n", __func__);\r\nspin_unlock_irqrestore(&qt_port->lock, flags);\r\nreturn;\r\n}\r\nstatic void qt_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = get_usb_serial(port, __func__);\r\nstruct quatech_port *qt_port;\r\nunsigned long flags;\r\nunsigned int result;\r\nif (!serial)\r\nreturn;\r\nqt_port = qt_get_port_private(port);\r\nspin_lock_irqsave(&qt_port->lock, flags);\r\ndbg("%s - port %d\n", __func__, port->number);\r\nif (qt_port->RxHolding == 1) {\r\ndbg("%s -qt_port->RxHolding == 1\n", __func__);\r\nqt_port->RxHolding = 0;\r\ndbg("%s - qt_port->RxHolding = 0\n", __func__);\r\nif ((serial->num_bulk_in) && (qt_port->ReadBulkStopped == 1)) {\r\nusb_fill_bulk_urb(port->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->read_urb->transfer_buffer,\r\nport->read_urb->\r\ntransfer_buffer_length,\r\nqt_read_bulk_callback, port);\r\nresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (result)\r\nerr("%s - failed restarting read urb, error %d",\r\n__func__, result);\r\n}\r\n}\r\nspin_unlock_irqrestore(&qt_port->lock, flags);\r\nreturn;\r\n}\r\nstatic int qt_calc_num_ports(struct usb_serial *serial)\r\n{\r\nint num_ports;\r\ndbg("numberofendpoints: %d\n",\r\n(int)serial->interface->cur_altsetting->desc.bNumEndpoints);\r\ndbg("numberofendpoints: %d\n",\r\n(int)serial->interface->altsetting->desc.bNumEndpoints);\r\nnum_ports =\r\n(serial->interface->cur_altsetting->desc.bNumEndpoints - 1) / 2;\r\nreturn num_ports;\r\n}\r\nstatic int __init serqt_usb_init(void)\r\n{\r\nint retval;\r\ndbg("%s\n", __func__);\r\nretval = usb_serial_register(&quatech_device);\r\nif (retval)\r\ngoto failed_usb_serial_register;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nretval = usb_register(&serqt_usb_driver);\r\nif (retval == 0)\r\nreturn 0;\r\nusb_serial_deregister(&quatech_device);\r\nfailed_usb_serial_register:\r\nreturn retval;\r\n}\r\nstatic void __exit serqt_usb_exit(void)\r\n{\r\nusb_deregister(&serqt_usb_driver);\r\nusb_serial_deregister(&quatech_device);\r\n}
