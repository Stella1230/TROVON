static void hist_browser__refresh_dimensions(struct hist_browser *self)\r\n{\r\nself->b.width = 3 + (hists__sort_list_width(self->hists) +\r\nsizeof("[k]"));\r\n}\r\nstatic void hist_browser__reset(struct hist_browser *self)\r\n{\r\nself->b.nr_entries = self->hists->nr_entries;\r\nhist_browser__refresh_dimensions(self);\r\nui_browser__reset_index(&self->b);\r\n}\r\nstatic char tree__folded_sign(bool unfolded)\r\n{\r\nreturn unfolded ? '-' : '+';\r\n}\r\nstatic char map_symbol__folded(const struct map_symbol *self)\r\n{\r\nreturn self->has_children ? tree__folded_sign(self->unfolded) : ' ';\r\n}\r\nstatic char hist_entry__folded(const struct hist_entry *self)\r\n{\r\nreturn map_symbol__folded(&self->ms);\r\n}\r\nstatic char callchain_list__folded(const struct callchain_list *self)\r\n{\r\nreturn map_symbol__folded(&self->ms);\r\n}\r\nstatic void map_symbol__set_folding(struct map_symbol *self, bool unfold)\r\n{\r\nself->unfolded = unfold ? self->has_children : false;\r\n}\r\nstatic int callchain_node__count_rows_rb_tree(struct callchain_node *self)\r\n{\r\nint n = 0;\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&self->rb_root); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\r\nstruct callchain_list *chain;\r\nchar folded_sign = ' ';\r\nlist_for_each_entry(chain, &child->val, list) {\r\n++n;\r\nfolded_sign = callchain_list__folded(chain);\r\nif (folded_sign == '+')\r\nbreak;\r\n}\r\nif (folded_sign == '-')\r\nn += callchain_node__count_rows_rb_tree(child);\r\n}\r\nreturn n;\r\n}\r\nstatic int callchain_node__count_rows(struct callchain_node *node)\r\n{\r\nstruct callchain_list *chain;\r\nbool unfolded = false;\r\nint n = 0;\r\nlist_for_each_entry(chain, &node->val, list) {\r\n++n;\r\nunfolded = chain->ms.unfolded;\r\n}\r\nif (unfolded)\r\nn += callchain_node__count_rows_rb_tree(node);\r\nreturn n;\r\n}\r\nstatic int callchain__count_rows(struct rb_root *chain)\r\n{\r\nstruct rb_node *nd;\r\nint n = 0;\r\nfor (nd = rb_first(chain); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\r\nn += callchain_node__count_rows(node);\r\n}\r\nreturn n;\r\n}\r\nstatic bool map_symbol__toggle_fold(struct map_symbol *self)\r\n{\r\nif (!self->has_children)\r\nreturn false;\r\nself->unfolded = !self->unfolded;\r\nreturn true;\r\n}\r\nstatic void callchain_node__init_have_children_rb_tree(struct callchain_node *self)\r\n{\r\nstruct rb_node *nd = rb_first(&self->rb_root);\r\nfor (nd = rb_first(&self->rb_root); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\r\nstruct callchain_list *chain;\r\nbool first = true;\r\nlist_for_each_entry(chain, &child->val, list) {\r\nif (first) {\r\nfirst = false;\r\nchain->ms.has_children = chain->list.next != &child->val ||\r\n!RB_EMPTY_ROOT(&child->rb_root);\r\n} else\r\nchain->ms.has_children = chain->list.next == &child->val &&\r\n!RB_EMPTY_ROOT(&child->rb_root);\r\n}\r\ncallchain_node__init_have_children_rb_tree(child);\r\n}\r\n}\r\nstatic void callchain_node__init_have_children(struct callchain_node *self)\r\n{\r\nstruct callchain_list *chain;\r\nlist_for_each_entry(chain, &self->val, list)\r\nchain->ms.has_children = !RB_EMPTY_ROOT(&self->rb_root);\r\ncallchain_node__init_have_children_rb_tree(self);\r\n}\r\nstatic void callchain__init_have_children(struct rb_root *self)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(self); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\r\ncallchain_node__init_have_children(node);\r\n}\r\n}\r\nstatic void hist_entry__init_have_children(struct hist_entry *self)\r\n{\r\nif (!self->init_have_children) {\r\nself->ms.has_children = !RB_EMPTY_ROOT(&self->sorted_chain);\r\ncallchain__init_have_children(&self->sorted_chain);\r\nself->init_have_children = true;\r\n}\r\n}\r\nstatic bool hist_browser__toggle_fold(struct hist_browser *self)\r\n{\r\nif (map_symbol__toggle_fold(self->selection)) {\r\nstruct hist_entry *he = self->he_selection;\r\nhist_entry__init_have_children(he);\r\nself->hists->nr_entries -= he->nr_rows;\r\nif (he->ms.unfolded)\r\nhe->nr_rows = callchain__count_rows(&he->sorted_chain);\r\nelse\r\nhe->nr_rows = 0;\r\nself->hists->nr_entries += he->nr_rows;\r\nself->b.nr_entries = self->hists->nr_entries;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int callchain_node__set_folding_rb_tree(struct callchain_node *self, bool unfold)\r\n{\r\nint n = 0;\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&self->rb_root); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\r\nstruct callchain_list *chain;\r\nbool has_children = false;\r\nlist_for_each_entry(chain, &child->val, list) {\r\n++n;\r\nmap_symbol__set_folding(&chain->ms, unfold);\r\nhas_children = chain->ms.has_children;\r\n}\r\nif (has_children)\r\nn += callchain_node__set_folding_rb_tree(child, unfold);\r\n}\r\nreturn n;\r\n}\r\nstatic int callchain_node__set_folding(struct callchain_node *node, bool unfold)\r\n{\r\nstruct callchain_list *chain;\r\nbool has_children = false;\r\nint n = 0;\r\nlist_for_each_entry(chain, &node->val, list) {\r\n++n;\r\nmap_symbol__set_folding(&chain->ms, unfold);\r\nhas_children = chain->ms.has_children;\r\n}\r\nif (has_children)\r\nn += callchain_node__set_folding_rb_tree(node, unfold);\r\nreturn n;\r\n}\r\nstatic int callchain__set_folding(struct rb_root *chain, bool unfold)\r\n{\r\nstruct rb_node *nd;\r\nint n = 0;\r\nfor (nd = rb_first(chain); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\r\nn += callchain_node__set_folding(node, unfold);\r\n}\r\nreturn n;\r\n}\r\nstatic void hist_entry__set_folding(struct hist_entry *self, bool unfold)\r\n{\r\nhist_entry__init_have_children(self);\r\nmap_symbol__set_folding(&self->ms, unfold);\r\nif (self->ms.has_children) {\r\nint n = callchain__set_folding(&self->sorted_chain, unfold);\r\nself->nr_rows = unfold ? n : 0;\r\n} else\r\nself->nr_rows = 0;\r\n}\r\nstatic void hists__set_folding(struct hists *self, bool unfold)\r\n{\r\nstruct rb_node *nd;\r\nself->nr_entries = 0;\r\nfor (nd = rb_first(&self->entries); nd; nd = rb_next(nd)) {\r\nstruct hist_entry *he = rb_entry(nd, struct hist_entry, rb_node);\r\nhist_entry__set_folding(he, unfold);\r\nself->nr_entries += 1 + he->nr_rows;\r\n}\r\n}\r\nstatic void hist_browser__set_folding(struct hist_browser *self, bool unfold)\r\n{\r\nhists__set_folding(self->hists, unfold);\r\nself->b.nr_entries = self->hists->nr_entries;\r\nui_browser__reset_index(&self->b);\r\n}\r\nstatic int hist_browser__run(struct hist_browser *self, const char *title)\r\n{\r\nint key;\r\nint exit_keys[] = { 'a', '?', 'h', 'C', 'd', 'D', 'E', 't',\r\nNEWT_KEY_ENTER, NEWT_KEY_RIGHT, NEWT_KEY_LEFT,\r\nNEWT_KEY_TAB, NEWT_KEY_UNTAB, 0, };\r\nself->b.entries = &self->hists->entries;\r\nself->b.nr_entries = self->hists->nr_entries;\r\nhist_browser__refresh_dimensions(self);\r\nif (ui_browser__show(&self->b, title,\r\n"Press '?' for help on key bindings") < 0)\r\nreturn -1;\r\nui_browser__add_exit_keys(&self->b, exit_keys);\r\nwhile (1) {\r\nkey = ui_browser__run(&self->b);\r\nswitch (key) {\r\ncase 'D': {\r\nstatic int seq;\r\nstruct hist_entry *h = rb_entry(self->b.top,\r\nstruct hist_entry, rb_node);\r\nui_helpline__pop();\r\nui_helpline__fpush("%d: nr_ent=(%d,%d), height=%d, idx=%d, fve: idx=%d, row_off=%d, nrows=%d",\r\nseq++, self->b.nr_entries,\r\nself->hists->nr_entries,\r\nself->b.height,\r\nself->b.index,\r\nself->b.top_idx,\r\nh->row_offset, h->nr_rows);\r\n}\r\nbreak;\r\ncase 'C':\r\nhist_browser__set_folding(self, false);\r\nbreak;\r\ncase 'E':\r\nhist_browser__set_folding(self, true);\r\nbreak;\r\ncase NEWT_KEY_ENTER:\r\nif (hist_browser__toggle_fold(self))\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\n}\r\nout:\r\nui_browser__hide(&self->b);\r\nreturn key;\r\n}\r\nstatic char *callchain_list__sym_name(struct callchain_list *self,\r\nchar *bf, size_t bfsize)\r\n{\r\nif (self->ms.sym)\r\nreturn self->ms.sym->name;\r\nsnprintf(bf, bfsize, "%#" PRIx64, self->ip);\r\nreturn bf;\r\n}\r\nstatic int hist_browser__show_callchain_node_rb_tree(struct hist_browser *self,\r\nstruct callchain_node *chain_node,\r\nu64 total, int level,\r\nunsigned short row,\r\noff_t *row_offset,\r\nbool *is_current_entry)\r\n{\r\nstruct rb_node *node;\r\nint first_row = row, width, offset = level * LEVEL_OFFSET_STEP;\r\nu64 new_total, remaining;\r\nif (callchain_param.mode == CHAIN_GRAPH_REL)\r\nnew_total = chain_node->children_hit;\r\nelse\r\nnew_total = total;\r\nremaining = new_total;\r\nnode = rb_first(&chain_node->rb_root);\r\nwhile (node) {\r\nstruct callchain_node *child = rb_entry(node, struct callchain_node, rb_node);\r\nstruct rb_node *next = rb_next(node);\r\nu64 cumul = callchain_cumul_hits(child);\r\nstruct callchain_list *chain;\r\nchar folded_sign = ' ';\r\nint first = true;\r\nint extra_offset = 0;\r\nremaining -= cumul;\r\nlist_for_each_entry(chain, &child->val, list) {\r\nchar ipstr[BITS_PER_LONG / 4 + 1], *alloc_str;\r\nconst char *str;\r\nint color;\r\nbool was_first = first;\r\nif (first)\r\nfirst = false;\r\nelse\r\nextra_offset = LEVEL_OFFSET_STEP;\r\nfolded_sign = callchain_list__folded(chain);\r\nif (*row_offset != 0) {\r\n--*row_offset;\r\ngoto do_next;\r\n}\r\nalloc_str = NULL;\r\nstr = callchain_list__sym_name(chain, ipstr, sizeof(ipstr));\r\nif (was_first) {\r\ndouble percent = cumul * 100.0 / new_total;\r\nif (asprintf(&alloc_str, "%2.2f%% %s", percent, str) < 0)\r\nstr = "Not enough memory!";\r\nelse\r\nstr = alloc_str;\r\n}\r\ncolor = HE_COLORSET_NORMAL;\r\nwidth = self->b.width - (offset + extra_offset + 2);\r\nif (ui_browser__is_current_entry(&self->b, row)) {\r\nself->selection = &chain->ms;\r\ncolor = HE_COLORSET_SELECTED;\r\n*is_current_entry = true;\r\n}\r\nui_browser__set_color(&self->b, color);\r\nui_browser__gotorc(&self->b, row, 0);\r\nslsmg_write_nstring(" ", offset + extra_offset);\r\nslsmg_printf("%c ", folded_sign);\r\nslsmg_write_nstring(str, width);\r\nfree(alloc_str);\r\nif (++row == self->b.height)\r\ngoto out;\r\ndo_next:\r\nif (folded_sign == '+')\r\nbreak;\r\n}\r\nif (folded_sign == '-') {\r\nconst int new_level = level + (extra_offset ? 2 : 1);\r\nrow += hist_browser__show_callchain_node_rb_tree(self, child, new_total,\r\nnew_level, row, row_offset,\r\nis_current_entry);\r\n}\r\nif (row == self->b.height)\r\ngoto out;\r\nnode = next;\r\n}\r\nout:\r\nreturn row - first_row;\r\n}\r\nstatic int hist_browser__show_callchain_node(struct hist_browser *self,\r\nstruct callchain_node *node,\r\nint level, unsigned short row,\r\noff_t *row_offset,\r\nbool *is_current_entry)\r\n{\r\nstruct callchain_list *chain;\r\nint first_row = row,\r\noffset = level * LEVEL_OFFSET_STEP,\r\nwidth = self->b.width - offset;\r\nchar folded_sign = ' ';\r\nlist_for_each_entry(chain, &node->val, list) {\r\nchar ipstr[BITS_PER_LONG / 4 + 1], *s;\r\nint color;\r\nfolded_sign = callchain_list__folded(chain);\r\nif (*row_offset != 0) {\r\n--*row_offset;\r\ncontinue;\r\n}\r\ncolor = HE_COLORSET_NORMAL;\r\nif (ui_browser__is_current_entry(&self->b, row)) {\r\nself->selection = &chain->ms;\r\ncolor = HE_COLORSET_SELECTED;\r\n*is_current_entry = true;\r\n}\r\ns = callchain_list__sym_name(chain, ipstr, sizeof(ipstr));\r\nui_browser__gotorc(&self->b, row, 0);\r\nui_browser__set_color(&self->b, color);\r\nslsmg_write_nstring(" ", offset);\r\nslsmg_printf("%c ", folded_sign);\r\nslsmg_write_nstring(s, width - 2);\r\nif (++row == self->b.height)\r\ngoto out;\r\n}\r\nif (folded_sign == '-')\r\nrow += hist_browser__show_callchain_node_rb_tree(self, node,\r\nself->hists->stats.total_period,\r\nlevel + 1, row,\r\nrow_offset,\r\nis_current_entry);\r\nout:\r\nreturn row - first_row;\r\n}\r\nstatic int hist_browser__show_callchain(struct hist_browser *self,\r\nstruct rb_root *chain,\r\nint level, unsigned short row,\r\noff_t *row_offset,\r\nbool *is_current_entry)\r\n{\r\nstruct rb_node *nd;\r\nint first_row = row;\r\nfor (nd = rb_first(chain); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\r\nrow += hist_browser__show_callchain_node(self, node, level,\r\nrow, row_offset,\r\nis_current_entry);\r\nif (row == self->b.height)\r\nbreak;\r\n}\r\nreturn row - first_row;\r\n}\r\nstatic int hist_browser__show_entry(struct hist_browser *self,\r\nstruct hist_entry *entry,\r\nunsigned short row)\r\n{\r\nchar s[256];\r\ndouble percent;\r\nint printed = 0;\r\nint color, width = self->b.width;\r\nchar folded_sign = ' ';\r\nbool current_entry = ui_browser__is_current_entry(&self->b, row);\r\noff_t row_offset = entry->row_offset;\r\nif (current_entry) {\r\nself->he_selection = entry;\r\nself->selection = &entry->ms;\r\n}\r\nif (symbol_conf.use_callchain) {\r\nhist_entry__init_have_children(entry);\r\nfolded_sign = hist_entry__folded(entry);\r\n}\r\nif (row_offset == 0) {\r\nhist_entry__snprintf(entry, s, sizeof(s), self->hists, NULL, false,\r\n0, false, self->hists->stats.total_period);\r\npercent = (entry->period * 100.0) / self->hists->stats.total_period;\r\ncolor = HE_COLORSET_SELECTED;\r\nif (!current_entry) {\r\nif (percent >= MIN_RED)\r\ncolor = HE_COLORSET_TOP;\r\nelse if (percent >= MIN_GREEN)\r\ncolor = HE_COLORSET_MEDIUM;\r\nelse\r\ncolor = HE_COLORSET_NORMAL;\r\n}\r\nui_browser__set_color(&self->b, color);\r\nui_browser__gotorc(&self->b, row, 0);\r\nif (symbol_conf.use_callchain) {\r\nslsmg_printf("%c ", folded_sign);\r\nwidth -= 2;\r\n}\r\nslsmg_write_nstring(s, width);\r\n++row;\r\n++printed;\r\n} else\r\n--row_offset;\r\nif (folded_sign == '-' && row != self->b.height) {\r\nprinted += hist_browser__show_callchain(self, &entry->sorted_chain,\r\n1, row, &row_offset,\r\n&current_entry);\r\nif (current_entry)\r\nself->he_selection = entry;\r\n}\r\nreturn printed;\r\n}\r\nstatic unsigned int hist_browser__refresh(struct ui_browser *self)\r\n{\r\nunsigned row = 0;\r\nstruct rb_node *nd;\r\nstruct hist_browser *hb = container_of(self, struct hist_browser, b);\r\nif (self->top == NULL)\r\nself->top = rb_first(&hb->hists->entries);\r\nfor (nd = self->top; nd; nd = rb_next(nd)) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nif (h->filtered)\r\ncontinue;\r\nrow += hist_browser__show_entry(hb, h, row);\r\nif (row == self->height)\r\nbreak;\r\n}\r\nreturn row;\r\n}\r\nstatic struct rb_node *hists__filter_entries(struct rb_node *nd)\r\n{\r\nwhile (nd != NULL) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nif (!h->filtered)\r\nreturn nd;\r\nnd = rb_next(nd);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct rb_node *hists__filter_prev_entries(struct rb_node *nd)\r\n{\r\nwhile (nd != NULL) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nif (!h->filtered)\r\nreturn nd;\r\nnd = rb_prev(nd);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ui_browser__hists_seek(struct ui_browser *self,\r\noff_t offset, int whence)\r\n{\r\nstruct hist_entry *h;\r\nstruct rb_node *nd;\r\nbool first = true;\r\nif (self->nr_entries == 0)\r\nreturn;\r\nswitch (whence) {\r\ncase SEEK_SET:\r\nnd = hists__filter_entries(rb_first(self->entries));\r\nbreak;\r\ncase SEEK_CUR:\r\nnd = self->top;\r\ngoto do_offset;\r\ncase SEEK_END:\r\nnd = hists__filter_prev_entries(rb_last(self->entries));\r\nfirst = false;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nh = rb_entry(self->top, struct hist_entry, rb_node);\r\nh->row_offset = 0;\r\ndo_offset:\r\nif (offset > 0) {\r\ndo {\r\nh = rb_entry(nd, struct hist_entry, rb_node);\r\nif (h->ms.unfolded) {\r\nu16 remaining = h->nr_rows - h->row_offset;\r\nif (offset > remaining) {\r\noffset -= remaining;\r\nh->row_offset = 0;\r\n} else {\r\nh->row_offset += offset;\r\noffset = 0;\r\nself->top = nd;\r\nbreak;\r\n}\r\n}\r\nnd = hists__filter_entries(rb_next(nd));\r\nif (nd == NULL)\r\nbreak;\r\n--offset;\r\nself->top = nd;\r\n} while (offset != 0);\r\n} else if (offset < 0) {\r\nwhile (1) {\r\nh = rb_entry(nd, struct hist_entry, rb_node);\r\nif (h->ms.unfolded) {\r\nif (first) {\r\nif (-offset > h->row_offset) {\r\noffset += h->row_offset;\r\nh->row_offset = 0;\r\n} else {\r\nh->row_offset += offset;\r\noffset = 0;\r\nself->top = nd;\r\nbreak;\r\n}\r\n} else {\r\nif (-offset > h->nr_rows) {\r\noffset += h->nr_rows;\r\nh->row_offset = 0;\r\n} else {\r\nh->row_offset = h->nr_rows + offset;\r\noffset = 0;\r\nself->top = nd;\r\nbreak;\r\n}\r\n}\r\n}\r\nnd = hists__filter_prev_entries(rb_prev(nd));\r\nif (nd == NULL)\r\nbreak;\r\n++offset;\r\nself->top = nd;\r\nif (offset == 0) {\r\nh = rb_entry(nd, struct hist_entry, rb_node);\r\nif (h->ms.unfolded)\r\nh->row_offset = h->nr_rows;\r\nbreak;\r\n}\r\nfirst = false;\r\n}\r\n} else {\r\nself->top = nd;\r\nh = rb_entry(nd, struct hist_entry, rb_node);\r\nh->row_offset = 0;\r\n}\r\n}\r\nstatic struct hist_browser *hist_browser__new(struct hists *hists)\r\n{\r\nstruct hist_browser *self = zalloc(sizeof(*self));\r\nif (self) {\r\nself->hists = hists;\r\nself->b.refresh = hist_browser__refresh;\r\nself->b.seek = ui_browser__hists_seek;\r\n}\r\nreturn self;\r\n}\r\nstatic void hist_browser__delete(struct hist_browser *self)\r\n{\r\nfree(self);\r\n}\r\nstatic struct hist_entry *hist_browser__selected_entry(struct hist_browser *self)\r\n{\r\nreturn self->he_selection;\r\n}\r\nstatic struct thread *hist_browser__selected_thread(struct hist_browser *self)\r\n{\r\nreturn self->he_selection->thread;\r\n}\r\nstatic int hists__browser_title(struct hists *self, char *bf, size_t size,\r\nconst char *ev_name, const struct dso *dso,\r\nconst struct thread *thread)\r\n{\r\nchar unit;\r\nint printed;\r\nunsigned long nr_events = self->stats.nr_events[PERF_RECORD_SAMPLE];\r\nnr_events = convert_unit(nr_events, &unit);\r\nprinted = snprintf(bf, size, "Events: %lu%c %s", nr_events, unit, ev_name);\r\nif (thread)\r\nprinted += snprintf(bf + printed, size - printed,\r\n", Thread: %s(%d)",\r\n(thread->comm_set ? thread->comm : ""),\r\nthread->pid);\r\nif (dso)\r\nprinted += snprintf(bf + printed, size - printed,\r\n", DSO: %s", dso->short_name);\r\nreturn printed;\r\n}\r\nstatic int perf_evsel__hists_browse(struct perf_evsel *evsel,\r\nconst char *helpline, const char *ev_name,\r\nbool left_exits)\r\n{\r\nstruct hists *self = &evsel->hists;\r\nstruct hist_browser *browser = hist_browser__new(self);\r\nstruct pstack *fstack;\r\nconst struct thread *thread_filter = NULL;\r\nconst struct dso *dso_filter = NULL;\r\nchar msg[160];\r\nint key = -1;\r\nif (browser == NULL)\r\nreturn -1;\r\nfstack = pstack__new(2);\r\nif (fstack == NULL)\r\ngoto out;\r\nui_helpline__push(helpline);\r\nhists__browser_title(self, msg, sizeof(msg), ev_name,\r\ndso_filter, thread_filter);\r\nwhile (1) {\r\nconst struct thread *thread = NULL;\r\nconst struct dso *dso = NULL;\r\nchar *options[16];\r\nint nr_options = 0, choice = 0, i,\r\nannotate = -2, zoom_dso = -2, zoom_thread = -2,\r\nbrowse_map = -2;\r\nkey = hist_browser__run(browser, msg);\r\nif (browser->he_selection != NULL) {\r\nthread = hist_browser__selected_thread(browser);\r\ndso = browser->selection->map ? browser->selection->map->dso : NULL;\r\n}\r\nswitch (key) {\r\ncase NEWT_KEY_TAB:\r\ncase NEWT_KEY_UNTAB:\r\ngoto out_free_stack;\r\ncase 'a':\r\nif (browser->selection == NULL ||\r\nbrowser->selection->sym == NULL ||\r\nbrowser->selection->map->dso->annotate_warned)\r\ncontinue;\r\ngoto do_annotate;\r\ncase 'd':\r\ngoto zoom_dso;\r\ncase 't':\r\ngoto zoom_thread;\r\ncase NEWT_KEY_F1:\r\ncase 'h':\r\ncase '?':\r\nui__help_window("-> Zoom into DSO/Threads & Annotate current symbol\n"\r\n"<- Zoom out\n"\r\n"a Annotate current symbol\n"\r\n"h/?/F1 Show this window\n"\r\n"C Collapse all callchains\n"\r\n"E Expand all callchains\n"\r\n"d Zoom into current DSO\n"\r\n"t Zoom into current Thread\n"\r\n"TAB/UNTAB Switch events\n"\r\n"q/CTRL+C Exit browser");\r\ncontinue;\r\ncase NEWT_KEY_ENTER:\r\ncase NEWT_KEY_RIGHT:\r\nbreak;\r\ncase NEWT_KEY_LEFT: {\r\nconst void *top;\r\nif (pstack__empty(fstack)) {\r\nif (left_exits)\r\ngoto out_free_stack;\r\ncontinue;\r\n}\r\ntop = pstack__pop(fstack);\r\nif (top == &dso_filter)\r\ngoto zoom_out_dso;\r\nif (top == &thread_filter)\r\ngoto zoom_out_thread;\r\ncontinue;\r\n}\r\ncase NEWT_KEY_ESCAPE:\r\nif (!left_exits &&\r\n!ui__dialog_yesno("Do you really want to exit?"))\r\ncontinue;\r\ndefault:\r\ngoto out_free_stack;\r\n}\r\nif (browser->selection != NULL &&\r\nbrowser->selection->sym != NULL &&\r\n!browser->selection->map->dso->annotate_warned &&\r\nasprintf(&options[nr_options], "Annotate %s",\r\nbrowser->selection->sym->name) > 0)\r\nannotate = nr_options++;\r\nif (thread != NULL &&\r\nasprintf(&options[nr_options], "Zoom %s %s(%d) thread",\r\n(thread_filter ? "out of" : "into"),\r\n(thread->comm_set ? thread->comm : ""),\r\nthread->pid) > 0)\r\nzoom_thread = nr_options++;\r\nif (dso != NULL &&\r\nasprintf(&options[nr_options], "Zoom %s %s DSO",\r\n(dso_filter ? "out of" : "into"),\r\n(dso->kernel ? "the Kernel" : dso->short_name)) > 0)\r\nzoom_dso = nr_options++;\r\nif (browser->selection != NULL &&\r\nbrowser->selection->map != NULL &&\r\nasprintf(&options[nr_options], "Browse map details") > 0)\r\nbrowse_map = nr_options++;\r\noptions[nr_options++] = (char *)"Exit";\r\nchoice = ui__popup_menu(nr_options, options);\r\nfor (i = 0; i < nr_options - 1; ++i)\r\nfree(options[i]);\r\nif (choice == nr_options - 1)\r\nbreak;\r\nif (choice == -1)\r\ncontinue;\r\nif (choice == annotate) {\r\nstruct hist_entry *he;\r\ndo_annotate:\r\nhe = hist_browser__selected_entry(browser);\r\nif (he == NULL)\r\ncontinue;\r\nhist_entry__tui_annotate(he, evsel->idx);\r\n} else if (choice == browse_map)\r\nmap__browse(browser->selection->map);\r\nelse if (choice == zoom_dso) {\r\nzoom_dso:\r\nif (dso_filter) {\r\npstack__remove(fstack, &dso_filter);\r\nzoom_out_dso:\r\nui_helpline__pop();\r\ndso_filter = NULL;\r\n} else {\r\nif (dso == NULL)\r\ncontinue;\r\nui_helpline__fpush("To zoom out press <- or -> + \"Zoom out of %s DSO\"",\r\ndso->kernel ? "the Kernel" : dso->short_name);\r\ndso_filter = dso;\r\npstack__push(fstack, &dso_filter);\r\n}\r\nhists__filter_by_dso(self, dso_filter);\r\nhists__browser_title(self, msg, sizeof(msg), ev_name,\r\ndso_filter, thread_filter);\r\nhist_browser__reset(browser);\r\n} else if (choice == zoom_thread) {\r\nzoom_thread:\r\nif (thread_filter) {\r\npstack__remove(fstack, &thread_filter);\r\nzoom_out_thread:\r\nui_helpline__pop();\r\nthread_filter = NULL;\r\n} else {\r\nui_helpline__fpush("To zoom out press <- or -> + \"Zoom out of %s(%d) thread\"",\r\nthread->comm_set ? thread->comm : "",\r\nthread->pid);\r\nthread_filter = thread;\r\npstack__push(fstack, &thread_filter);\r\n}\r\nhists__filter_by_thread(self, thread_filter);\r\nhists__browser_title(self, msg, sizeof(msg), ev_name,\r\ndso_filter, thread_filter);\r\nhist_browser__reset(browser);\r\n}\r\n}\r\nout_free_stack:\r\npstack__delete(fstack);\r\nout:\r\nhist_browser__delete(browser);\r\nreturn key;\r\n}\r\nstatic void perf_evsel_menu__write(struct ui_browser *browser,\r\nvoid *entry, int row)\r\n{\r\nstruct perf_evsel_menu *menu = container_of(browser,\r\nstruct perf_evsel_menu, b);\r\nstruct perf_evsel *evsel = list_entry(entry, struct perf_evsel, node);\r\nbool current_entry = ui_browser__is_current_entry(browser, row);\r\nunsigned long nr_events = evsel->hists.stats.nr_events[PERF_RECORD_SAMPLE];\r\nconst char *ev_name = event_name(evsel);\r\nchar bf[256], unit;\r\nui_browser__set_color(browser, current_entry ? HE_COLORSET_SELECTED :\r\nHE_COLORSET_NORMAL);\r\nnr_events = convert_unit(nr_events, &unit);\r\nsnprintf(bf, sizeof(bf), "%lu%c%s%s", nr_events,\r\nunit, unit == ' ' ? "" : " ", ev_name);\r\nslsmg_write_nstring(bf, browser->width);\r\nif (current_entry)\r\nmenu->selection = evsel;\r\n}\r\nstatic int perf_evsel_menu__run(struct perf_evsel_menu *menu, const char *help)\r\n{\r\nint exit_keys[] = { NEWT_KEY_ENTER, NEWT_KEY_RIGHT, 0, };\r\nstruct perf_evlist *evlist = menu->b.priv;\r\nstruct perf_evsel *pos;\r\nconst char *ev_name, *title = "Available samples";\r\nint key;\r\nif (ui_browser__show(&menu->b, title,\r\n"ESC: exit, ENTER|->: Browse histograms") < 0)\r\nreturn -1;\r\nui_browser__add_exit_keys(&menu->b, exit_keys);\r\nwhile (1) {\r\nkey = ui_browser__run(&menu->b);\r\nswitch (key) {\r\ncase NEWT_KEY_RIGHT:\r\ncase NEWT_KEY_ENTER:\r\nif (!menu->selection)\r\ncontinue;\r\npos = menu->selection;\r\nbrowse_hists:\r\nev_name = event_name(pos);\r\nkey = perf_evsel__hists_browse(pos, help, ev_name, true);\r\nui_browser__show_title(&menu->b, title);\r\nbreak;\r\ncase NEWT_KEY_LEFT:\r\ncontinue;\r\ncase NEWT_KEY_ESCAPE:\r\nif (!ui__dialog_yesno("Do you really want to exit?"))\r\ncontinue;\r\ndefault:\r\ngoto out;\r\n}\r\nswitch (key) {\r\ncase NEWT_KEY_TAB:\r\nif (pos->node.next == &evlist->entries)\r\npos = list_entry(evlist->entries.next, struct perf_evsel, node);\r\nelse\r\npos = list_entry(pos->node.next, struct perf_evsel, node);\r\ngoto browse_hists;\r\ncase NEWT_KEY_UNTAB:\r\nif (pos->node.prev == &evlist->entries)\r\npos = list_entry(evlist->entries.prev, struct perf_evsel, node);\r\nelse\r\npos = list_entry(pos->node.prev, struct perf_evsel, node);\r\ngoto browse_hists;\r\ncase 'q':\r\ncase CTRL('c'):\r\ngoto out;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nout:\r\nui_browser__hide(&menu->b);\r\nreturn key;\r\n}\r\nstatic int __perf_evlist__tui_browse_hists(struct perf_evlist *evlist,\r\nconst char *help)\r\n{\r\nstruct perf_evsel *pos;\r\nstruct perf_evsel_menu menu = {\r\n.b = {\r\n.entries = &evlist->entries,\r\n.refresh = ui_browser__list_head_refresh,\r\n.seek = ui_browser__list_head_seek,\r\n.write = perf_evsel_menu__write,\r\n.nr_entries = evlist->nr_entries,\r\n.priv = evlist,\r\n},\r\n};\r\nui_helpline__push("Press ESC to exit");\r\nlist_for_each_entry(pos, &evlist->entries, node) {\r\nconst char *ev_name = event_name(pos);\r\nsize_t line_len = strlen(ev_name) + 7;\r\nif (menu.b.width < line_len)\r\nmenu.b.width = line_len;\r\nif (pos->name == NULL)\r\npos->name = strdup(ev_name);\r\n}\r\nreturn perf_evsel_menu__run(&menu, help);\r\n}\r\nint perf_evlist__tui_browse_hists(struct perf_evlist *evlist, const char *help)\r\n{\r\nif (evlist->nr_entries == 1) {\r\nstruct perf_evsel *first = list_entry(evlist->entries.next,\r\nstruct perf_evsel, node);\r\nconst char *ev_name = event_name(first);\r\nreturn perf_evsel__hists_browse(first, help, ev_name, false);\r\n}\r\nreturn __perf_evlist__tui_browse_hists(evlist, help);\r\n}
