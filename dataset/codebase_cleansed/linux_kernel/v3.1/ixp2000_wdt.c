static void wdt_enable(void)\r\n{\r\nspin_lock(&wdt_lock);\r\nixp2000_reg_write(IXP2000_RESET0, *(IXP2000_RESET0) | WDT_RESET_ENABLE);\r\nixp2000_reg_write(IXP2000_TWDE, WDT_ENABLE);\r\nixp2000_reg_write(IXP2000_T4_CLD, heartbeat * wdt_tick_rate);\r\nixp2000_reg_write(IXP2000_T4_CTL, TIMER_DIVIDER_256 | TIMER_ENABLE);\r\nspin_unlock(&wdt_lock);\r\n}\r\nstatic void wdt_disable(void)\r\n{\r\nspin_lock(&wdt_lock);\r\nixp2000_reg_write(IXP2000_T4_CTL, 0);\r\nspin_unlock(&wdt_lock);\r\n}\r\nstatic void wdt_keepalive(void)\r\n{\r\nspin_lock(&wdt_lock);\r\nixp2000_reg_write(IXP2000_T4_CLD, heartbeat * wdt_tick_rate);\r\nspin_unlock(&wdt_lock);\r\n}\r\nstatic int ixp2000_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(WDT_IN_USE, &wdt_status))\r\nreturn -EBUSY;\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nwdt_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t ixp2000_wdt_write(struct file *file, const char *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\n}\r\n}\r\nwdt_keepalive();\r\n}\r\nreturn len;\r\n}\r\nstatic long ixp2000_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret = -ENOTTY;\r\nint time;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nret = copy_to_user((struct watchdog_info *)arg, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nret = put_user(0, (int *)arg);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(0, (int *)arg);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nwdt_enable();\r\nret = 0;\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nret = get_user(time, (int *)arg);\r\nif (ret)\r\nbreak;\r\nif (time <= 0 || time > 60) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nheartbeat = time;\r\nwdt_keepalive();\r\ncase WDIOC_GETTIMEOUT:\r\nret = put_user(heartbeat, (int *)arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ixp2000_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (test_bit(WDT_OK_TO_CLOSE, &wdt_status))\r\nwdt_disable();\r\nelse\r\nprintk(KERN_CRIT "WATCHDOG: Device closed unexpectedly - "\r\n"timer will not stop\n");\r\nclear_bit(WDT_IN_USE, &wdt_status);\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nreturn 0;\r\n}\r\nstatic int __init ixp2000_wdt_init(void)\r\n{\r\nif ((*IXP2000_PRODUCT_ID & 0x001ffef0) == 0x00000000) {\r\nprintk(KERN_INFO "Unable to use IXP2000 watchdog due to IXP2800 erratum #25.\n");\r\nreturn -EIO;\r\n}\r\nwdt_tick_rate = (*IXP2000_T1_CLD * HZ) / 256;\r\nspin_lock_init(&wdt_lock);\r\nreturn misc_register(&ixp2000_wdt_miscdev);\r\n}\r\nstatic void __exit ixp2000_wdt_exit(void)\r\n{\r\nmisc_deregister(&ixp2000_wdt_miscdev);\r\n}
