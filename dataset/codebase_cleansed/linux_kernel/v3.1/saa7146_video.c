struct saa7146_format* saa7146_format_by_fourcc(struct saa7146_dev *dev, int fourcc)\r\n{\r\nint i, j = NUM_FORMATS;\r\nfor (i = 0; i < j; i++) {\r\nif (formats[i].pixelformat == fourcc) {\r\nreturn formats+i;\r\n}\r\n}\r\nDEB_D(("unknown pixelformat:'%4.4s'\n",(char *)&fourcc));\r\nreturn NULL;\r\n}\r\nint saa7146_start_preview(struct saa7146_fh *fh)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct v4l2_format fmt;\r\nint ret = 0, err = 0;\r\nDEB_EE(("dev:%p, fh:%p\n",dev,fh));\r\nif( NULL == fh->ov.fh ) {\r\nDEB_D(("no overlay data available. try S_FMT first.\n"));\r\nreturn -EAGAIN;\r\n}\r\nif (IS_CAPTURE_ACTIVE(fh) != 0) {\r\nDEB_D(("streaming capture is active.\n"));\r\nreturn -EBUSY;\r\n}\r\nif (IS_OVERLAY_ACTIVE(fh) != 0) {\r\nif (vv->video_fh == fh) {\r\nDEB_D(("overlay is already active.\n"));\r\nreturn 0;\r\n}\r\nDEB_D(("overlay is already active in another open.\n"));\r\nreturn -EBUSY;\r\n}\r\nif (0 == saa7146_res_get(fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP)) {\r\nDEB_D(("cannot get necessary overlay resources\n"));\r\nreturn -EBUSY;\r\n}\r\nfmt.fmt.win = fh->ov.win;\r\nerr = vidioc_try_fmt_vid_overlay(NULL, fh, &fmt);\r\nif (0 != err) {\r\nsaa7146_res_free(vv->video_fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);\r\nreturn -EBUSY;\r\n}\r\nfh->ov.win = fmt.fmt.win;\r\nvv->ov_data = &fh->ov;\r\nDEB_D(("%dx%d+%d+%d %s field=%s\n",\r\nfh->ov.win.w.width,fh->ov.win.w.height,\r\nfh->ov.win.w.left,fh->ov.win.w.top,\r\nvv->ov_fmt->name,v4l2_field_names[fh->ov.win.field]));\r\nif (0 != (ret = saa7146_enable_overlay(fh))) {\r\nDEB_D(("enabling overlay failed: %d\n",ret));\r\nsaa7146_res_free(vv->video_fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);\r\nreturn ret;\r\n}\r\nvv->video_status = STATUS_OVERLAY;\r\nvv->video_fh = fh;\r\nreturn 0;\r\n}\r\nint saa7146_stop_preview(struct saa7146_fh *fh)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nDEB_EE(("dev:%p, fh:%p\n",dev,fh));\r\nif (IS_CAPTURE_ACTIVE(fh) != 0) {\r\nDEB_D(("streaming capture is active.\n"));\r\nreturn -EBUSY;\r\n}\r\nif ((vv->video_status & STATUS_OVERLAY) == 0) {\r\nDEB_D(("no active overlay.\n"));\r\nreturn 0;\r\n}\r\nif (vv->video_fh != fh) {\r\nDEB_D(("overlay is active, but in another open.\n"));\r\nreturn -EBUSY;\r\n}\r\nvv->video_status = 0;\r\nvv->video_fh = NULL;\r\nsaa7146_disable_overlay(fh);\r\nsaa7146_res_free(fh, RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP);\r\nreturn 0;\r\n}\r\nstatic struct v4l2_queryctrl* ctrl_by_id(int id)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_CONTROLS; i++)\r\nif (controls[i].id == id)\r\nreturn controls+i;\r\nreturn NULL;\r\n}\r\nstatic int saa7146_pgtable_build(struct saa7146_dev *dev, struct saa7146_buf *buf)\r\n{\r\nstruct pci_dev *pci = dev->pci;\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\nstruct scatterlist *list = dma->sglist;\r\nint length = dma->sglen;\r\nstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);\r\nDEB_EE(("dev:%p, buf:%p, sg_len:%d\n",dev,buf,length));\r\nif( 0 != IS_PLANAR(sfmt->trans)) {\r\nstruct saa7146_pgtable *pt1 = &buf->pt[0];\r\nstruct saa7146_pgtable *pt2 = &buf->pt[1];\r\nstruct saa7146_pgtable *pt3 = &buf->pt[2];\r\n__le32 *ptr1, *ptr2, *ptr3;\r\n__le32 fill;\r\nint size = buf->fmt->width*buf->fmt->height;\r\nint i,p,m1,m2,m3,o1,o2;\r\nswitch( sfmt->depth ) {\r\ncase 12: {\r\nm1 = ((size+PAGE_SIZE)/PAGE_SIZE)-1;\r\nm2 = ((size+(size/4)+PAGE_SIZE)/PAGE_SIZE)-1;\r\nm3 = ((size+(size/2)+PAGE_SIZE)/PAGE_SIZE)-1;\r\no1 = size%PAGE_SIZE;\r\no2 = (size+(size/4))%PAGE_SIZE;\r\nDEB_CAP(("size:%d, m1:%d, m2:%d, m3:%d, o1:%d, o2:%d\n",size,m1,m2,m3,o1,o2));\r\nbreak;\r\n}\r\ncase 16: {\r\nm1 = ((size+PAGE_SIZE)/PAGE_SIZE)-1;\r\nm2 = ((size+(size/2)+PAGE_SIZE)/PAGE_SIZE)-1;\r\nm3 = ((2*size+PAGE_SIZE)/PAGE_SIZE)-1;\r\no1 = size%PAGE_SIZE;\r\no2 = (size+(size/2))%PAGE_SIZE;\r\nDEB_CAP(("size:%d, m1:%d, m2:%d, m3:%d, o1:%d, o2:%d\n",size,m1,m2,m3,o1,o2));\r\nbreak;\r\n}\r\ndefault: {\r\nreturn -1;\r\n}\r\n}\r\nptr1 = pt1->cpu;\r\nptr2 = pt2->cpu;\r\nptr3 = pt3->cpu;\r\nfor (i = 0; i < length; i++, list++) {\r\nfor (p = 0; p * 4096 < list->length; p++, ptr1++) {\r\n*ptr1 = cpu_to_le32(sg_dma_address(list) - list->offset);\r\n}\r\n}\r\npt1->offset = dma->sglist->offset;\r\npt2->offset = pt1->offset+o1;\r\npt3->offset = pt1->offset+o2;\r\nptr1 = pt1->cpu;\r\nfor(i = m1; i <= m2 ; i++, ptr2++) {\r\n*ptr2 = ptr1[i];\r\n}\r\nfill = *(ptr2-1);\r\nfor(;i<1024;i++,ptr2++) {\r\n*ptr2 = fill;\r\n}\r\nptr1 = pt1->cpu;\r\nfor(i = m2; i <= m3; i++,ptr3++) {\r\n*ptr3 = ptr1[i];\r\n}\r\nfill = *(ptr3-1);\r\nfor(;i<1024;i++,ptr3++) {\r\n*ptr3 = fill;\r\n}\r\nptr1 = pt1->cpu+m1;\r\nfill = pt1->cpu[m1];\r\nfor(i=m1;i<1024;i++,ptr1++) {\r\n*ptr1 = fill;\r\n}\r\n} else {\r\nstruct saa7146_pgtable *pt = &buf->pt[0];\r\nreturn saa7146_pgtable_build_single(pci, pt, list, length);\r\n}\r\nreturn 0;\r\n}\r\nstatic int video_begin(struct saa7146_fh *fh)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_format *fmt = NULL;\r\nunsigned int resource;\r\nint ret = 0, err = 0;\r\nDEB_EE(("dev:%p, fh:%p\n",dev,fh));\r\nif ((vv->video_status & STATUS_CAPTURE) != 0) {\r\nif (vv->video_fh == fh) {\r\nDEB_S(("already capturing.\n"));\r\nreturn 0;\r\n}\r\nDEB_S(("already capturing in another open.\n"));\r\nreturn -EBUSY;\r\n}\r\nif ((vv->video_status & STATUS_OVERLAY) != 0) {\r\nDEB_S(("warning: suspending overlay video for streaming capture.\n"));\r\nvv->ov_suspend = vv->video_fh;\r\nerr = saa7146_stop_preview(vv->video_fh);\r\nif (0 != err) {\r\nDEB_D(("suspending video failed. aborting\n"));\r\nreturn err;\r\n}\r\n}\r\nfmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);\r\nBUG_ON(NULL == fmt);\r\nif (0 != (fmt->flags & FORMAT_IS_PLANAR)) {\r\nresource = RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP|RESOURCE_DMA3_BRS;\r\n} else {\r\nresource = RESOURCE_DMA1_HPS;\r\n}\r\nret = saa7146_res_get(fh, resource);\r\nif (0 == ret) {\r\nDEB_S(("cannot get capture resource %d\n",resource));\r\nif (vv->ov_suspend != NULL) {\r\nsaa7146_start_preview(vv->ov_suspend);\r\nvv->ov_suspend = NULL;\r\n}\r\nreturn -EBUSY;\r\n}\r\nsaa7146_write(dev, MC2, MASK_27 );\r\nSAA7146_IER_ENABLE(dev, MASK_27);\r\nvv->video_fh = fh;\r\nvv->video_status = STATUS_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int video_end(struct saa7146_fh *fh, struct file *file)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_format *fmt = NULL;\r\nunsigned long flags;\r\nunsigned int resource;\r\nu32 dmas = 0;\r\nDEB_EE(("dev:%p, fh:%p\n",dev,fh));\r\nif ((vv->video_status & STATUS_CAPTURE) != STATUS_CAPTURE) {\r\nDEB_S(("not capturing.\n"));\r\nreturn 0;\r\n}\r\nif (vv->video_fh != fh) {\r\nDEB_S(("capturing, but in another open.\n"));\r\nreturn -EBUSY;\r\n}\r\nfmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);\r\nBUG_ON(NULL == fmt);\r\nif (0 != (fmt->flags & FORMAT_IS_PLANAR)) {\r\nresource = RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP|RESOURCE_DMA3_BRS;\r\ndmas = MASK_22 | MASK_21 | MASK_20;\r\n} else {\r\nresource = RESOURCE_DMA1_HPS;\r\ndmas = MASK_22;\r\n}\r\nspin_lock_irqsave(&dev->slock,flags);\r\nsaa7146_write(dev, MC1, MASK_28);\r\nSAA7146_IER_DISABLE(dev, MASK_27);\r\nsaa7146_write(dev, MC1, dmas);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nvv->video_fh = NULL;\r\nvv->video_status = 0;\r\nsaa7146_res_free(fh, resource);\r\nif (vv->ov_suspend != NULL) {\r\nsaa7146_start_preview(vv->ov_suspend);\r\nvv->ov_suspend = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstrcpy((char *)cap->driver, "saa7146 v4l2");\r\nstrlcpy((char *)cap->card, dev->ext->name, sizeof(cap->card));\r\nsprintf((char *)cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncap->version = SAA7146_VERSION_CODE;\r\ncap->capabilities =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_VIDEO_OVERLAY |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\ncap->capabilities |= dev->ext_vv_data->capabilities;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *fb)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\n*fb = vv->ov_fb;\r\nfb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *fb)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_format *fmt;\r\nDEB_EE(("VIDIOC_S_FBUF\n"));\r\nif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nfmt = saa7146_format_by_fourcc(dev, fb->fmt.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nif (fmt->flags & FORMAT_IS_PLANAR)\r\nDEB_S(("planar pixelformat '%4.4s' not allowed for overlay\n",\r\n(char *)&fmt->pixelformat));\r\nif (IS_OVERLAY_ACTIVE(fh) != 0) {\r\nif (vv->video_fh != fh) {\r\nDEB_D(("refusing to change framebuffer informations while overlay is active in another open.\n"));\r\nreturn -EBUSY;\r\n}\r\n}\r\nvv->ov_fb = *fb;\r\nvv->ov_fmt = fmt;\r\nif (vv->ov_fb.fmt.bytesperline < vv->ov_fb.fmt.width) {\r\nvv->ov_fb.fmt.bytesperline = vv->ov_fb.fmt.width * fmt->depth / 8;\r\nDEB_D(("setting bytesperline to %d\n", vv->ov_fb.fmt.bytesperline));\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= NUM_FORMATS)\r\nreturn -EINVAL;\r\nstrlcpy((char *)f->description, formats[f->index].name,\r\nsizeof(f->description));\r\nf->pixelformat = formats[f->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *fh, struct v4l2_queryctrl *c)\r\n{\r\nconst struct v4l2_queryctrl *ctrl;\r\nif ((c->id < V4L2_CID_BASE ||\r\nc->id >= V4L2_CID_LASTP1) &&\r\n(c->id < V4L2_CID_PRIVATE_BASE ||\r\nc->id >= V4L2_CID_PRIVATE_LASTP1))\r\nreturn -EINVAL;\r\nctrl = ctrl_by_id(c->id);\r\nif (ctrl == NULL)\r\nreturn -EINVAL;\r\nDEB_EE(("VIDIOC_QUERYCTRL: id:%d\n", c->id));\r\n*c = *ctrl;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *c)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nconst struct v4l2_queryctrl *ctrl;\r\nu32 value = 0;\r\nctrl = ctrl_by_id(c->id);\r\nif (NULL == ctrl)\r\nreturn -EINVAL;\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nvalue = saa7146_read(dev, BCS_CTRL);\r\nc->value = 0xff & (value >> 24);\r\nDEB_D(("V4L2_CID_BRIGHTNESS: %d\n", c->value));\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nvalue = saa7146_read(dev, BCS_CTRL);\r\nc->value = 0x7f & (value >> 16);\r\nDEB_D(("V4L2_CID_CONTRAST: %d\n", c->value));\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nvalue = saa7146_read(dev, BCS_CTRL);\r\nc->value = 0x7f & (value >> 0);\r\nDEB_D(("V4L2_CID_SATURATION: %d\n", c->value));\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nc->value = vv->vflip;\r\nDEB_D(("V4L2_CID_VFLIP: %d\n", c->value));\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nc->value = vv->hflip;\r\nDEB_D(("V4L2_CID_HFLIP: %d\n", c->value));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nconst struct v4l2_queryctrl *ctrl;\r\nctrl = ctrl_by_id(c->id);\r\nif (NULL == ctrl) {\r\nDEB_D(("unknown control %d\n", c->id));\r\nreturn -EINVAL;\r\n}\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\nif (c->value < ctrl->minimum)\r\nc->value = ctrl->minimum;\r\nif (c->value > ctrl->maximum)\r\nc->value = ctrl->maximum;\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS: {\r\nu32 value = saa7146_read(dev, BCS_CTRL);\r\nvalue &= 0x00ffffff;\r\nvalue |= (c->value << 24);\r\nsaa7146_write(dev, BCS_CTRL, value);\r\nsaa7146_write(dev, MC2, MASK_22 | MASK_06);\r\nbreak;\r\n}\r\ncase V4L2_CID_CONTRAST: {\r\nu32 value = saa7146_read(dev, BCS_CTRL);\r\nvalue &= 0xff00ffff;\r\nvalue |= (c->value << 16);\r\nsaa7146_write(dev, BCS_CTRL, value);\r\nsaa7146_write(dev, MC2, MASK_22 | MASK_06);\r\nbreak;\r\n}\r\ncase V4L2_CID_SATURATION: {\r\nu32 value = saa7146_read(dev, BCS_CTRL);\r\nvalue &= 0xffffff00;\r\nvalue |= (c->value << 0);\r\nsaa7146_write(dev, BCS_CTRL, value);\r\nsaa7146_write(dev, MC2, MASK_22 | MASK_06);\r\nbreak;\r\n}\r\ncase V4L2_CID_HFLIP:\r\nif (IS_CAPTURE_ACTIVE(fh) != 0) {\r\nDEB_D(("V4L2_CID_HFLIP while active capture.\n"));\r\nreturn -EBUSY;\r\n}\r\nvv->hflip = c->value;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nif (IS_CAPTURE_ACTIVE(fh) != 0) {\r\nDEB_D(("V4L2_CID_VFLIP while active capture.\n"));\r\nreturn -EBUSY;\r\n}\r\nvv->vflip = c->value;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (IS_OVERLAY_ACTIVE(fh) != 0) {\r\nsaa7146_stop_preview(fh);\r\nsaa7146_start_preview(fh);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nparm->parm.capture.readbuffers = 1;\r\nv4l2_video_std_frame_period(vv->standard->id,\r\n&parm->parm.capture.timeperframe);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nf->fmt.pix = ((struct saa7146_fh *)fh)->video_fmt;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nf->fmt.win = ((struct saa7146_fh *)fh)->ov.win;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nf->fmt.vbi = ((struct saa7146_fh *)fh)->vbi_fmt;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_format *fmt;\r\nenum v4l2_field field;\r\nint maxw, maxh;\r\nint calc_bpl;\r\nDEB_EE(("V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p, fh:%p\n", dev, fh));\r\nfmt = saa7146_format_by_fourcc(dev, f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nmaxw = vv->standard->h_max_out;\r\nmaxh = vv->standard->v_max_out;\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (f->fmt.pix.height > maxh / 2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_ALTERNATE:\r\nvv->last_field = V4L2_FIELD_TOP;\r\nmaxh = maxh / 2;\r\nbreak;\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nvv->last_field = V4L2_FIELD_INTERLACED;\r\nmaxh = maxh / 2;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nvv->last_field = V4L2_FIELD_INTERLACED;\r\nbreak;\r\ndefault:\r\nDEB_D(("no known field mode '%d'.\n", field));\r\nreturn -EINVAL;\r\n}\r\nf->fmt.pix.field = field;\r\nif (f->fmt.pix.width > maxw)\r\nf->fmt.pix.width = maxw;\r\nif (f->fmt.pix.height > maxh)\r\nf->fmt.pix.height = maxh;\r\ncalc_bpl = (f->fmt.pix.width * fmt->depth) / 8;\r\nif (f->fmt.pix.bytesperline < calc_bpl)\r\nf->fmt.pix.bytesperline = calc_bpl;\r\nif (f->fmt.pix.bytesperline > (2 * PAGE_SIZE * fmt->depth) / 8)\r\nf->fmt.pix.bytesperline = calc_bpl;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;\r\nDEB_D(("w:%d, h:%d, bytesperline:%d, sizeimage:%d\n", f->fmt.pix.width,\r\nf->fmt.pix.height, f->fmt.pix.bytesperline, f->fmt.pix.sizeimage));\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct v4l2_window *win = &f->fmt.win;\r\nenum v4l2_field field;\r\nint maxw, maxh;\r\nDEB_EE(("dev:%p\n", dev));\r\nif (NULL == vv->ov_fb.base) {\r\nDEB_D(("no fb base set.\n"));\r\nreturn -EINVAL;\r\n}\r\nif (NULL == vv->ov_fmt) {\r\nDEB_D(("no fb fmt set.\n"));\r\nreturn -EINVAL;\r\n}\r\nif (win->w.width < 48 || win->w.height < 32) {\r\nDEB_D(("min width/height. (%d,%d)\n", win->w.width, win->w.height));\r\nreturn -EINVAL;\r\n}\r\nif (win->clipcount > 16) {\r\nDEB_D(("clipcount too big.\n"));\r\nreturn -EINVAL;\r\n}\r\nfield = win->field;\r\nmaxw = vv->standard->h_max_out;\r\nmaxh = vv->standard->v_max_out;\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (win->w.height > maxh / 2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_TOP;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_ALTERNATE:\r\nmaxh = maxh / 2;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\nDEB_D(("no known field mode '%d'.\n", field));\r\nreturn -EINVAL;\r\n}\r\nwin->field = field;\r\nif (win->w.width > maxw)\r\nwin->w.width = maxw;\r\nif (win->w.height > maxh)\r\nwin->w.height = maxh;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *__fh, struct v4l2_format *f)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nint err;\r\nDEB_EE(("V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p, fh:%p\n", dev, fh));\r\nif (IS_CAPTURE_ACTIVE(fh) != 0) {\r\nDEB_EE(("streaming capture is active\n"));\r\nreturn -EBUSY;\r\n}\r\nerr = vidioc_try_fmt_vid_cap(file, fh, f);\r\nif (0 != err)\r\nreturn err;\r\nfh->video_fmt = f->fmt.pix;\r\nDEB_EE(("set to pixelformat '%4.4s'\n", (char *)&fh->video_fmt.pixelformat));\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_overlay(struct file *file, void *__fh, struct v4l2_format *f)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nint err;\r\nDEB_EE(("V4L2_BUF_TYPE_VIDEO_OVERLAY: dev:%p, fh:%p\n", dev, fh));\r\nerr = vidioc_try_fmt_vid_overlay(file, fh, f);\r\nif (0 != err)\r\nreturn err;\r\nfh->ov.win = f->fmt.win;\r\nfh->ov.nclips = f->fmt.win.clipcount;\r\nif (fh->ov.nclips > 16)\r\nfh->ov.nclips = 16;\r\nif (copy_from_user(fh->ov.clips, f->fmt.win.clips,\r\nsizeof(struct v4l2_clip) * fh->ov.nclips)) {\r\nreturn -EFAULT;\r\n}\r\nfh->ov.fh = fh;\r\nif (IS_OVERLAY_ACTIVE(fh) != 0) {\r\nsaa7146_stop_preview(fh);\r\nsaa7146_start_preview(fh);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *fh, v4l2_std_id *norm)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\n*norm = vv->standard->id;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *id)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nint found = 0;\r\nint err, i;\r\nDEB_EE(("VIDIOC_S_STD\n"));\r\nif ((vv->video_status & STATUS_CAPTURE) == STATUS_CAPTURE) {\r\nDEB_D(("cannot change video standard while streaming capture is active\n"));\r\nreturn -EBUSY;\r\n}\r\nif ((vv->video_status & STATUS_OVERLAY) != 0) {\r\nvv->ov_suspend = vv->video_fh;\r\nerr = saa7146_stop_preview(vv->video_fh);\r\nif (0 != err) {\r\nDEB_D(("suspending video failed. aborting\n"));\r\nreturn err;\r\n}\r\n}\r\nfor (i = 0; i < dev->ext_vv_data->num_stds; i++)\r\nif (*id & dev->ext_vv_data->stds[i].id)\r\nbreak;\r\nif (i != dev->ext_vv_data->num_stds) {\r\nvv->standard = &dev->ext_vv_data->stds[i];\r\nif (NULL != dev->ext_vv_data->std_callback)\r\ndev->ext_vv_data->std_callback(dev, vv->standard);\r\nfound = 1;\r\n}\r\nif (vv->ov_suspend != NULL) {\r\nsaa7146_start_preview(vv->ov_suspend);\r\nvv->ov_suspend = NULL;\r\n}\r\nif (!found) {\r\nDEB_EE(("VIDIOC_S_STD: standard not found.\n"));\r\nreturn -EINVAL;\r\n}\r\nDEB_EE(("VIDIOC_S_STD: set to standard to '%s'\n", vv->standard->name));\r\nreturn 0;\r\n}\r\nstatic int vidioc_overlay(struct file *file, void *fh, unsigned int on)\r\n{\r\nint err;\r\nDEB_D(("VIDIOC_OVERLAY on:%d\n", on));\r\nif (on)\r\nerr = saa7146_start_preview(fh);\r\nelse\r\nerr = saa7146_stop_preview(fh);\r\nreturn err;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *__fh, struct v4l2_requestbuffers *b)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nif (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_reqbufs(&fh->video_q, b);\r\nif (b->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nreturn videobuf_reqbufs(&fh->vbi_q, b);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *__fh, struct v4l2_buffer *buf)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_querybuf(&fh->video_q, buf);\r\nif (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nreturn videobuf_querybuf(&fh->vbi_q, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *__fh, struct v4l2_buffer *buf)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_qbuf(&fh->video_q, buf);\r\nif (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nreturn videobuf_qbuf(&fh->vbi_q, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *__fh, struct v4l2_buffer *buf)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_dqbuf(&fh->video_q, buf, file->f_flags & O_NONBLOCK);\r\nif (buf->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nreturn videobuf_dqbuf(&fh->vbi_q, buf, file->f_flags & O_NONBLOCK);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *__fh, enum v4l2_buf_type type)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nint err;\r\nDEB_D(("VIDIOC_STREAMON, type:%d\n", type));\r\nerr = video_begin(fh);\r\nif (err)\r\nreturn err;\r\nif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_streamon(&fh->video_q);\r\nif (type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nreturn videobuf_streamon(&fh->vbi_q);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *__fh, enum v4l2_buf_type type)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nint err;\r\nDEB_D(("VIDIOC_STREAMOFF, type:%d\n", type));\r\nif ((vv->video_status & STATUS_CAPTURE) != STATUS_CAPTURE) {\r\nDEB_S(("not capturing.\n"));\r\nreturn 0;\r\n}\r\nif (vv->video_fh != fh) {\r\nDEB_S(("capturing, but in another open.\n"));\r\nreturn -EBUSY;\r\n}\r\nerr = -EINVAL;\r\nif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nerr = videobuf_streamoff(&fh->video_q);\r\nelse if (type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nerr = videobuf_streamoff(&fh->vbi_q);\r\nif (0 != err) {\r\nDEB_D(("warning: videobuf_streamoff() failed.\n"));\r\nvideo_end(fh, file);\r\n} else {\r\nerr = video_end(fh, file);\r\n}\r\nreturn err;\r\n}\r\nstatic int vidioc_g_chip_ident(struct file *file, void *__fh,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct saa7146_fh *fh = __fh;\r\nstruct saa7146_dev *dev = fh->dev;\r\nchip->ident = V4L2_IDENT_NONE;\r\nchip->revision = 0;\r\nif (chip->match.type == V4L2_CHIP_MATCH_HOST && !chip->match.addr) {\r\nchip->ident = V4L2_IDENT_SAA7146;\r\nreturn 0;\r\n}\r\nreturn v4l2_device_call_until_err(&dev->v4l2_dev, 0,\r\ncore, g_chip_ident, chip);\r\n}\r\nstatic int buffer_activate (struct saa7146_dev *dev,\r\nstruct saa7146_buf *buf,\r\nstruct saa7146_buf *next)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nsaa7146_set_capture(dev,buf,next);\r\nmod_timer(&vv->video_q.timeout, jiffies+BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nstatic void release_all_pagetables(struct saa7146_dev *dev, struct saa7146_buf *buf)\r\n{\r\nsaa7146_pgtable_free(dev->pci, &buf->pt[0]);\r\nsaa7146_pgtable_free(dev->pci, &buf->pt[1]);\r\nsaa7146_pgtable_free(dev->pci, &buf->pt[2]);\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct file *file = q->priv_data;\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_buf *buf = (struct saa7146_buf *)vb;\r\nint size,err = 0;\r\nDEB_CAP(("vbuf:%p\n",vb));\r\nif (fh->video_fmt.width < 48 ||\r\nfh->video_fmt.height < 32 ||\r\nfh->video_fmt.width > vv->standard->h_max_out ||\r\nfh->video_fmt.height > vv->standard->v_max_out) {\r\nDEB_D(("w (%d) / h (%d) out of bounds.\n",fh->video_fmt.width,fh->video_fmt.height));\r\nreturn -EINVAL;\r\n}\r\nsize = fh->video_fmt.sizeimage;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < size) {\r\nDEB_D(("size mismatch.\n"));\r\nreturn -EINVAL;\r\n}\r\nDEB_CAP(("buffer_prepare [size=%dx%d,bytes=%d,fields=%s]\n",\r\nfh->video_fmt.width,fh->video_fmt.height,size,v4l2_field_names[fh->video_fmt.field]));\r\nif (buf->vb.width != fh->video_fmt.width ||\r\nbuf->vb.bytesperline != fh->video_fmt.bytesperline ||\r\nbuf->vb.height != fh->video_fmt.height ||\r\nbuf->vb.size != size ||\r\nbuf->vb.field != field ||\r\nbuf->vb.field != fh->video_fmt.field ||\r\nbuf->fmt != &fh->video_fmt) {\r\nsaa7146_dma_free(dev,q,buf);\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nstruct saa7146_format *sfmt;\r\nbuf->vb.bytesperline = fh->video_fmt.bytesperline;\r\nbuf->vb.width = fh->video_fmt.width;\r\nbuf->vb.height = fh->video_fmt.height;\r\nbuf->vb.size = size;\r\nbuf->vb.field = field;\r\nbuf->fmt = &fh->video_fmt;\r\nbuf->vb.field = fh->video_fmt.field;\r\nsfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);\r\nrelease_all_pagetables(dev, buf);\r\nif( 0 != IS_PLANAR(sfmt->trans)) {\r\nsaa7146_pgtable_alloc(dev->pci, &buf->pt[0]);\r\nsaa7146_pgtable_alloc(dev->pci, &buf->pt[1]);\r\nsaa7146_pgtable_alloc(dev->pci, &buf->pt[2]);\r\n} else {\r\nsaa7146_pgtable_alloc(dev->pci, &buf->pt[0]);\r\n}\r\nerr = videobuf_iolock(q,&buf->vb, &vv->ov_fb);\r\nif (err)\r\ngoto oops;\r\nerr = saa7146_pgtable_build(dev,buf);\r\nif (err)\r\ngoto oops;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nbuf->activate = buffer_activate;\r\nreturn 0;\r\noops:\r\nDEB_D(("error out.\n"));\r\nsaa7146_dma_free(dev,q,buf);\r\nreturn err;\r\n}\r\nstatic int buffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)\r\n{\r\nstruct file *file = q->priv_data;\r\nstruct saa7146_fh *fh = file->private_data;\r\nif (0 == *count || *count > MAX_SAA7146_CAPTURE_BUFFERS)\r\n*count = MAX_SAA7146_CAPTURE_BUFFERS;\r\n*size = fh->video_fmt.sizeimage;\r\nif( (*count * *size) > (max_memory*1048576) ) {\r\n*count = (max_memory*1048576) / *size;\r\n}\r\nDEB_CAP(("%d buffers, %d bytes each.\n",*count,*size));\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct file *file = q->priv_data;\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_buf *buf = (struct saa7146_buf *)vb;\r\nDEB_CAP(("vbuf:%p\n",vb));\r\nsaa7146_buffer_queue(fh->dev,&vv->video_q,buf);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct file *file = q->priv_data;\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_buf *buf = (struct saa7146_buf *)vb;\r\nDEB_CAP(("vbuf:%p\n",vb));\r\nsaa7146_dma_free(dev,q,buf);\r\nrelease_all_pagetables(dev, buf);\r\n}\r\nstatic void video_init(struct saa7146_dev *dev, struct saa7146_vv *vv)\r\n{\r\nINIT_LIST_HEAD(&vv->video_q.queue);\r\ninit_timer(&vv->video_q.timeout);\r\nvv->video_q.timeout.function = saa7146_buffer_timeout;\r\nvv->video_q.timeout.data = (unsigned long)(&vv->video_q);\r\nvv->video_q.dev = dev;\r\nvv->standard = &dev->ext_vv_data->stds[0];\r\nvv->current_hps_source = SAA7146_HPS_SOURCE_PORT_A;\r\nvv->current_hps_sync = SAA7146_HPS_SYNC_PORT_A;\r\n}\r\nstatic int video_open(struct saa7146_dev *dev, struct file *file)\r\n{\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_format *sfmt;\r\nfh->video_fmt.width = 384;\r\nfh->video_fmt.height = 288;\r\nfh->video_fmt.pixelformat = V4L2_PIX_FMT_BGR24;\r\nfh->video_fmt.bytesperline = 0;\r\nfh->video_fmt.field = V4L2_FIELD_ANY;\r\nsfmt = saa7146_format_by_fourcc(dev,fh->video_fmt.pixelformat);\r\nfh->video_fmt.sizeimage = (fh->video_fmt.width * fh->video_fmt.height * sfmt->depth)/8;\r\nvideobuf_queue_sg_init(&fh->video_q, &video_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct saa7146_buf),\r\nfile, &dev->v4l2_lock);\r\nreturn 0;\r\n}\r\nstatic void video_close(struct saa7146_dev *dev, struct file *file)\r\n{\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct videobuf_queue *q = &fh->video_q;\r\nint err;\r\nif (IS_CAPTURE_ACTIVE(fh) != 0) {\r\nerr = video_end(fh, file);\r\n} else if (IS_OVERLAY_ACTIVE(fh) != 0) {\r\nerr = saa7146_stop_preview(fh);\r\n}\r\nvideobuf_stop(q);\r\n}\r\nstatic void video_irq_done(struct saa7146_dev *dev, unsigned long st)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_dmaqueue *q = &vv->video_q;\r\nspin_lock(&dev->slock);\r\nDEB_CAP(("called.\n"));\r\nif( NULL != q->curr ) {\r\nsaa7146_buffer_finish(dev,q,VIDEOBUF_DONE);\r\n}\r\nsaa7146_buffer_next(dev,q,0);\r\nspin_unlock(&dev->slock);\r\n}\r\nstatic ssize_t video_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nssize_t ret = 0;\r\nDEB_EE(("called.\n"));\r\nif ((vv->video_status & STATUS_CAPTURE) != 0) {\r\nif (vv->video_fh == fh) {\r\nDEB_S(("already capturing.\n"));\r\nreturn -EBUSY;\r\n}\r\nDEB_S(("already capturing in another open.\n"));\r\nreturn -EBUSY;\r\n}\r\nret = video_begin(fh);\r\nif( 0 != ret) {\r\ngoto out;\r\n}\r\nret = videobuf_read_one(&fh->video_q , data, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\nif (ret != 0) {\r\nvideo_end(fh, file);\r\n} else {\r\nret = video_end(fh, file);\r\n}\r\nout:\r\nif (vv->ov_suspend != NULL) {\r\nsaa7146_start_preview(vv->ov_suspend);\r\nvv->ov_suspend = NULL;\r\n}\r\nreturn ret;\r\n}
