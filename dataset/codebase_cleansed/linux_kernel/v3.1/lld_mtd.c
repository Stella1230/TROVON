u16 mtd_Flash_Init(void)\r\n{\r\nif (mtddev == -1) {\r\nprintk(KERN_ERR "No MTD device specified. Give mtddev parameter\n");\r\nreturn FAIL;\r\n}\r\nspectra_mtd = get_mtd_device(NULL, mtddev);\r\nif (!spectra_mtd) {\r\nprintk(KERN_ERR "Failed to obtain MTD device #%d\n", mtddev);\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn PASS;\r\n}\r\nint mtd_Flash_Release(void)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (!spectra_mtd)\r\nreturn PASS;\r\nput_mtd_device(spectra_mtd);\r\nspectra_mtd = NULL;\r\nreturn PASS;\r\n}\r\nu16 mtd_Read_Device_ID(void)\r\n{\r\nuint64_t tmp;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (!spectra_mtd)\r\nreturn FAIL;\r\nDeviceInfo.wDeviceMaker = 0;\r\nDeviceInfo.wDeviceType = 8;\r\nDeviceInfo.wSpectraStartBlock = SPECTRA_START_BLOCK;\r\ntmp = spectra_mtd->size;\r\ndo_div(tmp, spectra_mtd->erasesize);\r\nDeviceInfo.wTotalBlocks = tmp;\r\nDeviceInfo.wSpectraEndBlock = DeviceInfo.wTotalBlocks - 1;\r\nDeviceInfo.wPagesPerBlock = spectra_mtd->erasesize / spectra_mtd->writesize;\r\nDeviceInfo.wPageSize = spectra_mtd->writesize + spectra_mtd->oobsize;\r\nDeviceInfo.wPageDataSize = spectra_mtd->writesize;\r\nDeviceInfo.wPageSpareSize = spectra_mtd->oobsize;\r\nDeviceInfo.wBlockSize = DeviceInfo.wPageSize * DeviceInfo.wPagesPerBlock;\r\nDeviceInfo.wBlockDataSize = DeviceInfo.wPageDataSize * DeviceInfo.wPagesPerBlock;\r\nDeviceInfo.wDataBlockNum = (u32) (DeviceInfo.wSpectraEndBlock -\r\nDeviceInfo.wSpectraStartBlock\r\n+ 1);\r\nDeviceInfo.MLCDevice = 0;\r\nDeviceInfo.nBitsInPageNumber =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wPagesPerBlock);\r\nDeviceInfo.nBitsInPageDataSize =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wPageDataSize);\r\nDeviceInfo.nBitsInBlockDataSize =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wBlockDataSize);\r\n#if CMD_DMA\r\ntotalUsedBanks = 4;\r\nvalid_banks[0] = 1;\r\nvalid_banks[1] = 1;\r\nvalid_banks[2] = 1;\r\nvalid_banks[3] = 1;\r\n#endif\r\nreturn PASS;\r\n}\r\nu16 mtd_Flash_Reset(void)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn PASS;\r\n}\r\nvoid erase_callback(struct erase_info *e)\r\n{\r\ncomplete((void *)e->priv);\r\n}\r\nu16 mtd_Erase_Block(u32 block_add)\r\n{\r\nstruct erase_info erase;\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nint ret;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (block_add >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "mtd_Erase_Block error! "\r\n"Too big block address: %d\n", block_add);\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Erasing block %d\n",\r\n(int)block_add);\r\nerase.mtd = spectra_mtd;\r\nerase.callback = erase_callback;\r\nerase.addr = block_add * spectra_mtd->erasesize;\r\nerase.len = spectra_mtd->erasesize;\r\nerase.priv = (unsigned long)&comp;\r\nret = spectra_mtd->erase(spectra_mtd, &erase);\r\nif (!ret) {\r\nwait_for_completion(&comp);\r\nif (erase.state != MTD_ERASE_DONE)\r\nret = -EIO;\r\n}\r\nif (ret) {\r\nprintk(KERN_WARNING "mtd_Erase_Block error! "\r\n"erase of region [0x%llx, 0x%llx] failed\n",\r\nerase.addr, erase.len);\r\nreturn FAIL;\r\n}\r\nreturn PASS;\r\n}\r\nu16 mtd_Write_Page_Main(u8 *write_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nsize_t retlen;\r\nint ret = 0;\r\nif (Block >= DeviceInfo.wTotalBlocks)\r\nreturn FAIL;\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock)\r\nreturn FAIL;\r\nnand_dbg_print(NAND_DBG_DEBUG, "mtd_Write_Page_Main: "\r\n"lba %u Page %u PageCount %u\n",\r\n(unsigned int)Block,\r\n(unsigned int)Page, (unsigned int)PageCount);\r\nwhile (PageCount) {\r\nret = spectra_mtd->write(spectra_mtd,\r\n(Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),\r\nDeviceInfo.wPageDataSize, &retlen, write_data);\r\nif (ret) {\r\nprintk(KERN_ERR "%s failed %d\n", __func__, ret);\r\nreturn FAIL;\r\n}\r\nwrite_data += DeviceInfo.wPageDataSize;\r\nPage++;\r\nPageCount--;\r\n}\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn PASS;\r\n}\r\nu16 mtd_Read_Page_Main(u8 *read_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nsize_t retlen;\r\nint ret = 0;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks)\r\nreturn FAIL;\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock)\r\nreturn FAIL;\r\nnand_dbg_print(NAND_DBG_DEBUG, "mtd_Read_Page_Main: "\r\n"lba %u Page %u PageCount %u\n",\r\n(unsigned int)Block,\r\n(unsigned int)Page, (unsigned int)PageCount);\r\nwhile (PageCount) {\r\nret = spectra_mtd->read(spectra_mtd,\r\n(Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),\r\nDeviceInfo.wPageDataSize, &retlen, read_data);\r\nif (ret) {\r\nprintk(KERN_ERR "%s failed %d\n", __func__, ret);\r\nreturn FAIL;\r\n}\r\nread_data += DeviceInfo.wPageDataSize;\r\nPage++;\r\nPageCount--;\r\n}\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn PASS;\r\n}\r\nu16 mtd_Read_Page_Main_Spare(u8 *read_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "Read Page Main+Spare "\r\n"Error: Block Address too big\n");\r\nreturn FAIL;\r\n}\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock) {\r\nprintk(KERN_ERR "Read Page Main+Spare "\r\n"Error: Page number %d+%d too big in block %d\n",\r\nPage, PageCount, Block);\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Read Page Main + Spare - "\r\n"No. of pages %u block %u start page %u\n",\r\n(unsigned int)PageCount,\r\n(unsigned int)Block, (unsigned int)Page);\r\nwhile (PageCount) {\r\nstruct mtd_oob_ops ops;\r\nint ret;\r\nops.mode = MTD_OOB_AUTO;\r\nops.datbuf = read_data;\r\nops.len = DeviceInfo.wPageDataSize;\r\nops.oobbuf = read_data + DeviceInfo.wPageDataSize + BTSIG_OFFSET;\r\nops.ooblen = BTSIG_BYTES;\r\nops.ooboffs = 0;\r\nret = spectra_mtd->read_oob(spectra_mtd,\r\n(Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),\r\n&ops);\r\nif (ret) {\r\nprintk(KERN_ERR "%s failed %d\n", __func__, ret);\r\nreturn FAIL;\r\n}\r\nread_data += DeviceInfo.wPageSize;\r\nPage++;\r\nPageCount--;\r\n}\r\nreturn PASS;\r\n}\r\nu16 mtd_Write_Page_Main_Spare(u8 *write_data, u32 Block,\r\nu16 Page, u16 page_count)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "Write Page Main + Spare "\r\n"Error: Block Address too big\n");\r\nreturn FAIL;\r\n}\r\nif (Page + page_count > DeviceInfo.wPagesPerBlock) {\r\nprintk(KERN_ERR "Write Page Main + Spare "\r\n"Error: Page number %d+%d too big in block %d\n",\r\nPage, page_count, Block);\r\nWARN_ON(1);\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Write Page Main+Spare - "\r\n"No. of pages %u block %u start page %u\n",\r\n(unsigned int)page_count,\r\n(unsigned int)Block, (unsigned int)Page);\r\nwhile (page_count) {\r\nstruct mtd_oob_ops ops;\r\nint ret;\r\nops.mode = MTD_OOB_AUTO;\r\nops.datbuf = write_data;\r\nops.len = DeviceInfo.wPageDataSize;\r\nops.oobbuf = write_data + DeviceInfo.wPageDataSize + BTSIG_OFFSET;\r\nops.ooblen = BTSIG_BYTES;\r\nops.ooboffs = 0;\r\nret = spectra_mtd->write_oob(spectra_mtd,\r\n(Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),\r\n&ops);\r\nif (ret) {\r\nprintk(KERN_ERR "%s failed %d\n", __func__, ret);\r\nreturn FAIL;\r\n}\r\nwrite_data += DeviceInfo.wPageSize;\r\nPage++;\r\npage_count--;\r\n}\r\nreturn PASS;\r\n}\r\nu16 mtd_Write_Page_Spare(u8 *write_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nWARN_ON(1);\r\nreturn FAIL;\r\n}\r\nu16 mtd_Read_Page_Spare(u8 *read_data, u32 Block,\r\nu16 Page, u16 PageCount)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (Block >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "Read Page Spare "\r\n"Error: Block Address too big\n");\r\nreturn FAIL;\r\n}\r\nif (Page + PageCount > DeviceInfo.wPagesPerBlock) {\r\nprintk(KERN_ERR "Read Page Spare "\r\n"Error: Page number too big\n");\r\nreturn FAIL;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Read Page Spare- "\r\n"block %u page %u (%u pages)\n",\r\n(unsigned int)Block, (unsigned int)Page, PageCount);\r\nwhile (PageCount) {\r\nstruct mtd_oob_ops ops;\r\nint ret;\r\nops.mode = MTD_OOB_AUTO;\r\nops.datbuf = NULL;\r\nops.len = 0;\r\nops.oobbuf = read_data;\r\nops.ooblen = BTSIG_BYTES;\r\nops.ooboffs = 0;\r\nret = spectra_mtd->read_oob(spectra_mtd,\r\n(Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),\r\n&ops);\r\nif (ret) {\r\nprintk(KERN_ERR "%s failed %d\n", __func__, ret);\r\nreturn FAIL;\r\n}\r\nread_data += DeviceInfo.wPageSize;\r\nPage++;\r\nPageCount--;\r\n}\r\nreturn PASS;\r\n}\r\nvoid mtd_Enable_Disable_Interrupts(u16 INT_ENABLE)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\n}\r\nu16 mtd_Get_Bad_Block(u32 block)\r\n{\r\nreturn 0;\r\n}\r\nu16 mtd_CDMA_Flash_Init(void)\r\n{\r\nu16 i;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nfor (i = 0; i < MAX_DESCS + MAX_CHANS; i++) {\r\nPendingCMD[i].CMD = 0;\r\nPendingCMD[i].Tag = 0;\r\nPendingCMD[i].DataAddr = 0;\r\nPendingCMD[i].Block = 0;\r\nPendingCMD[i].Page = 0;\r\nPendingCMD[i].PageCount = 0;\r\nPendingCMD[i].DataDestAddr = 0;\r\nPendingCMD[i].DataSrcAddr = 0;\r\nPendingCMD[i].MemCopyByteCnt = 0;\r\nPendingCMD[i].ChanSync[0] = 0;\r\nPendingCMD[i].ChanSync[1] = 0;\r\nPendingCMD[i].ChanSync[2] = 0;\r\nPendingCMD[i].ChanSync[3] = 0;\r\nPendingCMD[i].ChanSync[4] = 0;\r\nPendingCMD[i].Status = 3;\r\n}\r\nreturn PASS;\r\n}\r\nstatic void mtd_isr(int irq, void *dev_id)\r\n{\r\n}\r\nu16 mtd_CDMA_Execute_CMDs(u16 tag_count)\r\n{\r\nu16 i, j;\r\nu8 CMD;\r\nu8 *data;\r\nu32 block;\r\nu16 page;\r\nu16 count;\r\nu16 status = PASS;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nnand_dbg_print(NAND_DBG_TRACE, "At start of Execute CMDs: "\r\n"Tag Count %u\n", tag_count);\r\nfor (i = 0; i < totalUsedBanks; i++) {\r\nPendingCMD[i].CMD = DUMMY_CMD;\r\nPendingCMD[i].Tag = 0xFF;\r\nPendingCMD[i].Block =\r\n(DeviceInfo.wTotalBlocks / totalUsedBanks) * i;\r\nfor (j = 0; j <= MAX_CHANS; j++)\r\nPendingCMD[i].ChanSync[j] = 0;\r\n}\r\nCDMA_Execute_CMDs(tag_count);\r\n#ifdef VERBOSE\r\nprint_pending_cmds(tag_count);\r\n#endif\r\n#if DEBUG_SYNC\r\n}
