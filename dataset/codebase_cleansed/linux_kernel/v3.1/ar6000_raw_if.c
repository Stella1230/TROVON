static int ar6000_connect_raw_service(struct ar6_softc *ar,\r\nHTC_RAW_STREAM_ID StreamID)\r\n{\r\nint status;\r\nstruct htc_service_connect_resp response;\r\nu8 streamNo;\r\nstruct htc_service_connect_req connect;\r\ndo {\r\nA_MEMZERO(&connect,sizeof(connect));\r\nstreamNo = (u8)StreamID;\r\nconnect.pMetaData = &streamNo;\r\nconnect.MetaDataLength = sizeof(u8);\r\nconnect.EpCallbacks.pContext = ar;\r\nconnect.EpCallbacks.EpTxComplete = ar6000_htc_raw_write_cb;\r\nconnect.EpCallbacks.EpRecv = ar6000_htc_raw_read_cb;\r\nconnect.EpCallbacks.EpRecvRefill = NULL;\r\nconnect.EpCallbacks.EpSendFull = NULL;\r\nconnect.MaxSendQueueDepth = RAW_HTC_WRITE_BUFFERS_NUM;\r\nconnect.ServiceID = HTC_RAW_STREAMS_SVC;\r\nA_MEMZERO(&response,sizeof(response));\r\nstatus = HTCConnectService(ar->arHtcTarget,\r\n&connect,\r\n&response);\r\nif (status) {\r\nif (response.ConnectRespCode == HTC_SERVICE_NO_MORE_EP) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("HTC RAW , No more streams allowed \n"));\r\nstatus = 0;\r\n}\r\nbreak;\r\n}\r\narSetRawStream2EndpointIDMap(ar,StreamID,response.Endpoint);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HTC_RAW,("HTC RAW : stream ID: %d, endpoint: %d\n",\r\nStreamID, arRawStream2EndpointID(ar,StreamID)));\r\n} while (false);\r\nreturn status;\r\n}\r\nint ar6000_htc_raw_open(struct ar6_softc *ar)\r\n{\r\nint status;\r\nint streamID, endPt, count2;\r\nraw_htc_buffer *buffer;\r\nHTC_SERVICE_ID servicepriority;\r\nAR_RAW_HTC_T *arRaw = ar->arRawHtc;\r\nif (!arRaw) {\r\narRaw = ar->arRawHtc = A_MALLOC(sizeof(AR_RAW_HTC_T));\r\nif (arRaw) {\r\nA_MEMZERO(arRaw, sizeof(AR_RAW_HTC_T));\r\n}\r\n}\r\nA_ASSERT(ar->arHtcTarget != NULL);\r\nif (!arRaw) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Faile to allocate memory for HTC RAW interface\n"));\r\nreturn -ENOMEM;\r\n}\r\nstatus = HTCWaitTarget(ar->arHtcTarget);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("HTCWaitTarget failed (%d)\n", status));\r\nreturn -ENODEV;\r\n}\r\nfor (endPt = 0; endPt < ENDPOINT_MAX; endPt++) {\r\narRaw->arEp2RawMapping[endPt] = HTC_RAW_STREAM_NOT_MAPPED;\r\n}\r\nfor (streamID = HTC_RAW_STREAM_0; streamID < HTC_RAW_STREAM_NUM_MAX; streamID++) {\r\nsema_init(&arRaw->raw_htc_read_sem[streamID], 1);\r\nsema_init(&arRaw->raw_htc_write_sem[streamID], 1);\r\ninit_waitqueue_head(&arRaw->raw_htc_read_queue[streamID]);\r\ninit_waitqueue_head(&arRaw->raw_htc_write_queue[streamID]);\r\nstatus = ar6000_connect_raw_service(ar,streamID);\r\nif (status) {\r\nbreak;\r\n}\r\nif (arRawStream2EndpointID(ar,streamID) == 0) {\r\nbreak;\r\n}\r\nfor (count2 = 0; count2 < RAW_HTC_READ_BUFFERS_NUM; count2 ++) {\r\nbuffer = &arRaw->raw_htc_write_buffer[streamID][count2];\r\nmemset(buffer, 0, sizeof(raw_htc_buffer));\r\nbuffer = &arRaw->raw_htc_read_buffer[streamID][count2];\r\nmemset(buffer, 0, sizeof(raw_htc_buffer));\r\nSET_HTC_PACKET_INFO_RX_REFILL(&buffer->HTCPacket,\r\nbuffer,\r\nbuffer->data,\r\nHTC_RAW_BUFFER_SIZE,\r\narRawStream2EndpointID(ar,streamID));\r\nif ((status = HTCAddReceivePkt(ar->arHtcTarget, &buffer->HTCPacket)) != 0)\r\n{\r\nBMIInit();\r\nreturn -EIO;\r\n}\r\n}\r\nfor (count2 = 0; count2 < RAW_HTC_WRITE_BUFFERS_NUM; count2 ++) {\r\nbuffer = &arRaw->raw_htc_write_buffer[streamID][count2];\r\nmemset(buffer, 0, sizeof(raw_htc_buffer));\r\n}\r\narRaw->read_buffer_available[streamID] = false;\r\narRaw->write_buffer_available[streamID] = true;\r\n}\r\nif (status) {\r\nreturn -EIO;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_INFO,("HTC RAW, number of streams the target supports: %d \n", streamID));\r\nservicepriority = HTC_RAW_STREAMS_SVC;\r\nHTCSetCreditDistribution(ar->arHtcTarget,\r\nar,\r\nNULL,\r\nNULL,\r\n&servicepriority,\r\n1);\r\nif ((status = HTCStart(ar->arHtcTarget)) != 0) {\r\nBMIInit();\r\nreturn -EIO;\r\n}\r\n(ar)->arRawIfInit = true;\r\nreturn 0;\r\n}\r\nint ar6000_htc_raw_close(struct ar6_softc *ar)\r\n{\r\nA_PRINTF("ar6000_htc_raw_close called \n");\r\nHTCStop(ar->arHtcTarget);\r\nar6000_reset_device(ar->arHifDevice, ar->arTargetType, true, false);\r\nBMIInit();\r\nreturn 0;\r\n}\r\nraw_htc_buffer *\r\nget_filled_buffer(struct ar6_softc *ar, HTC_RAW_STREAM_ID StreamID)\r\n{\r\nint count;\r\nraw_htc_buffer *busy;\r\nAR_RAW_HTC_T *arRaw = ar->arRawHtc;\r\nfor (count = 0; count < RAW_HTC_READ_BUFFERS_NUM; count ++) {\r\nbusy = &arRaw->raw_htc_read_buffer[StreamID][count];\r\nif (busy->length) {\r\nbreak;\r\n}\r\n}\r\nif (busy->length) {\r\narRaw->read_buffer_available[StreamID] = true;\r\n} else {\r\narRaw->read_buffer_available[StreamID] = false;\r\n}\r\nreturn busy;\r\n}\r\nssize_t ar6000_htc_raw_read(struct ar6_softc *ar, HTC_RAW_STREAM_ID StreamID,\r\nchar __user *buffer, size_t length)\r\n{\r\nint readPtr;\r\nraw_htc_buffer *busy;\r\nAR_RAW_HTC_T *arRaw = ar->arRawHtc;\r\nif (arRawStream2EndpointID(ar,StreamID) == 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("StreamID(%d) not connected! \n", StreamID));\r\nreturn -EFAULT;\r\n}\r\nif (down_interruptible(&arRaw->raw_htc_read_sem[StreamID])) {\r\nreturn -ERESTARTSYS;\r\n}\r\nbusy = get_filled_buffer(ar,StreamID);\r\nwhile (!arRaw->read_buffer_available[StreamID]) {\r\nup(&arRaw->raw_htc_read_sem[StreamID]);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HTC_RAW,("Sleeping StreamID(%d) read process\n", StreamID));\r\nif (wait_event_interruptible(arRaw->raw_htc_read_queue[StreamID],\r\narRaw->read_buffer_available[StreamID]))\r\n{\r\nreturn -EINTR;\r\n}\r\nif (down_interruptible(&arRaw->raw_htc_read_sem[StreamID])) {\r\nreturn -ERESTARTSYS;\r\n}\r\nbusy = get_filled_buffer(ar,StreamID);\r\n}\r\nreadPtr = busy->currPtr;\r\nif (length > busy->length - HTC_HEADER_LEN) {\r\nlength = busy->length - HTC_HEADER_LEN;\r\n}\r\nif (copy_to_user(buffer, &busy->data[readPtr], length)) {\r\nup(&arRaw->raw_htc_read_sem[StreamID]);\r\nreturn -EFAULT;\r\n}\r\nbusy->currPtr += length;\r\nif (busy->currPtr == busy->length)\r\n{\r\nbusy->currPtr = 0;\r\nbusy->length = 0;\r\nHTC_PACKET_RESET_RX(&busy->HTCPacket);\r\nHTCAddReceivePkt(ar->arHtcTarget, &busy->HTCPacket);\r\n}\r\narRaw->read_buffer_available[StreamID] = false;\r\nup(&arRaw->raw_htc_read_sem[StreamID]);\r\nreturn length;\r\n}\r\nstatic raw_htc_buffer *\r\nget_free_buffer(struct ar6_softc *ar, HTC_ENDPOINT_ID StreamID)\r\n{\r\nint count;\r\nraw_htc_buffer *free;\r\nAR_RAW_HTC_T *arRaw = ar->arRawHtc;\r\nfree = NULL;\r\nfor (count = 0; count < RAW_HTC_WRITE_BUFFERS_NUM; count ++) {\r\nfree = &arRaw->raw_htc_write_buffer[StreamID][count];\r\nif (free->length == 0) {\r\nbreak;\r\n}\r\n}\r\nif (!free->length) {\r\narRaw->write_buffer_available[StreamID] = true;\r\n} else {\r\narRaw->write_buffer_available[StreamID] = false;\r\n}\r\nreturn free;\r\n}\r\nssize_t ar6000_htc_raw_write(struct ar6_softc *ar, HTC_RAW_STREAM_ID StreamID,\r\nchar __user *buffer, size_t length)\r\n{\r\nint writePtr;\r\nraw_htc_buffer *free;\r\nAR_RAW_HTC_T *arRaw = ar->arRawHtc;\r\nif (arRawStream2EndpointID(ar,StreamID) == 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("StreamID(%d) not connected! \n", StreamID));\r\nreturn -EFAULT;\r\n}\r\nif (down_interruptible(&arRaw->raw_htc_write_sem[StreamID])) {\r\nreturn -ERESTARTSYS;\r\n}\r\nfree = get_free_buffer(ar,StreamID);\r\nwhile (!arRaw->write_buffer_available[StreamID]) {\r\nup(&arRaw->raw_htc_write_sem[StreamID]);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HTC_RAW,("Sleeping StreamID(%d) write process\n", StreamID));\r\nif (wait_event_interruptible(arRaw->raw_htc_write_queue[StreamID],\r\narRaw->write_buffer_available[StreamID]))\r\n{\r\nreturn -EINTR;\r\n}\r\nif (down_interruptible(&arRaw->raw_htc_write_sem[StreamID])) {\r\nreturn -ERESTARTSYS;\r\n}\r\nfree = get_free_buffer(ar,StreamID);\r\n}\r\nwritePtr = HTC_HEADER_LEN;\r\nif (length > (HTC_RAW_BUFFER_SIZE - HTC_HEADER_LEN)) {\r\nlength = HTC_RAW_BUFFER_SIZE - HTC_HEADER_LEN;\r\n}\r\nif (copy_from_user(&free->data[writePtr], buffer, length)) {\r\nup(&arRaw->raw_htc_read_sem[StreamID]);\r\nreturn -EFAULT;\r\n}\r\nfree->length = length;\r\nSET_HTC_PACKET_INFO_TX(&free->HTCPacket,\r\nfree,\r\n&free->data[writePtr],\r\nlength,\r\narRawStream2EndpointID(ar,StreamID),\r\nAR6K_DATA_PKT_TAG);\r\nHTCSendPkt(ar->arHtcTarget,&free->HTCPacket);\r\narRaw->write_buffer_available[StreamID] = false;\r\nup(&arRaw->raw_htc_write_sem[StreamID]);\r\nreturn length;\r\n}
