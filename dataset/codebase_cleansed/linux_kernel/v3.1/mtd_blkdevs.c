static void blktrans_dev_release(struct kref *kref)\r\n{\r\nstruct mtd_blktrans_dev *dev =\r\ncontainer_of(kref, struct mtd_blktrans_dev, ref);\r\ndev->disk->private_data = NULL;\r\nblk_cleanup_queue(dev->rq);\r\nput_disk(dev->disk);\r\nlist_del(&dev->list);\r\nkfree(dev);\r\n}\r\nstatic struct mtd_blktrans_dev *blktrans_dev_get(struct gendisk *disk)\r\n{\r\nstruct mtd_blktrans_dev *dev;\r\nmutex_lock(&blktrans_ref_mutex);\r\ndev = disk->private_data;\r\nif (!dev)\r\ngoto unlock;\r\nkref_get(&dev->ref);\r\nunlock:\r\nmutex_unlock(&blktrans_ref_mutex);\r\nreturn dev;\r\n}\r\nstatic void blktrans_dev_put(struct mtd_blktrans_dev *dev)\r\n{\r\nmutex_lock(&blktrans_ref_mutex);\r\nkref_put(&dev->ref, blktrans_dev_release);\r\nmutex_unlock(&blktrans_ref_mutex);\r\n}\r\nstatic int do_blktrans_request(struct mtd_blktrans_ops *tr,\r\nstruct mtd_blktrans_dev *dev,\r\nstruct request *req)\r\n{\r\nunsigned long block, nsect;\r\nchar *buf;\r\nblock = blk_rq_pos(req) << 9 >> tr->blkshift;\r\nnsect = blk_rq_cur_bytes(req) >> tr->blkshift;\r\nbuf = req->buffer;\r\nif (req->cmd_type != REQ_TYPE_FS)\r\nreturn -EIO;\r\nif (blk_rq_pos(req) + blk_rq_cur_sectors(req) >\r\nget_capacity(req->rq_disk))\r\nreturn -EIO;\r\nif (req->cmd_flags & REQ_DISCARD)\r\nreturn tr->discard(dev, block, nsect);\r\nswitch(rq_data_dir(req)) {\r\ncase READ:\r\nfor (; nsect > 0; nsect--, block++, buf += tr->blksize)\r\nif (tr->readsect(dev, block, buf))\r\nreturn -EIO;\r\nrq_flush_dcache_pages(req);\r\nreturn 0;\r\ncase WRITE:\r\nif (!tr->writesect)\r\nreturn -EIO;\r\nrq_flush_dcache_pages(req);\r\nfor (; nsect > 0; nsect--, block++, buf += tr->blksize)\r\nif (tr->writesect(dev, block, buf))\r\nreturn -EIO;\r\nreturn 0;\r\ndefault:\r\nprintk(KERN_NOTICE "Unknown request %u\n", rq_data_dir(req));\r\nreturn -EIO;\r\n}\r\n}\r\nint mtd_blktrans_cease_background(struct mtd_blktrans_dev *dev)\r\n{\r\nif (kthread_should_stop())\r\nreturn 1;\r\nreturn dev->bg_stop;\r\n}\r\nstatic int mtd_blktrans_thread(void *arg)\r\n{\r\nstruct mtd_blktrans_dev *dev = arg;\r\nstruct mtd_blktrans_ops *tr = dev->tr;\r\nstruct request_queue *rq = dev->rq;\r\nstruct request *req = NULL;\r\nint background_done = 0;\r\nspin_lock_irq(rq->queue_lock);\r\nwhile (!kthread_should_stop()) {\r\nint res;\r\ndev->bg_stop = false;\r\nif (!req && !(req = blk_fetch_request(rq))) {\r\nif (tr->background && !background_done) {\r\nspin_unlock_irq(rq->queue_lock);\r\nmutex_lock(&dev->lock);\r\ntr->background(dev);\r\nmutex_unlock(&dev->lock);\r\nspin_lock_irq(rq->queue_lock);\r\nbackground_done = !dev->bg_stop;\r\ncontinue;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (kthread_should_stop())\r\nset_current_state(TASK_RUNNING);\r\nspin_unlock_irq(rq->queue_lock);\r\nschedule();\r\nspin_lock_irq(rq->queue_lock);\r\ncontinue;\r\n}\r\nspin_unlock_irq(rq->queue_lock);\r\nmutex_lock(&dev->lock);\r\nres = do_blktrans_request(dev->tr, dev, req);\r\nmutex_unlock(&dev->lock);\r\nspin_lock_irq(rq->queue_lock);\r\nif (!__blk_end_request_cur(req, res))\r\nreq = NULL;\r\nbackground_done = 0;\r\n}\r\nif (req)\r\n__blk_end_request_all(req, -EIO);\r\nspin_unlock_irq(rq->queue_lock);\r\nreturn 0;\r\n}\r\nstatic void mtd_blktrans_request(struct request_queue *rq)\r\n{\r\nstruct mtd_blktrans_dev *dev;\r\nstruct request *req = NULL;\r\ndev = rq->queuedata;\r\nif (!dev)\r\nwhile ((req = blk_fetch_request(rq)) != NULL)\r\n__blk_end_request_all(req, -ENODEV);\r\nelse {\r\ndev->bg_stop = true;\r\nwake_up_process(dev->thread);\r\n}\r\n}\r\nstatic int blktrans_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct mtd_blktrans_dev *dev = blktrans_dev_get(bdev->bd_disk);\r\nint ret = 0;\r\nif (!dev)\r\nreturn -ERESTARTSYS;\r\nmutex_lock(&dev->lock);\r\nif (dev->open++)\r\ngoto unlock;\r\nkref_get(&dev->ref);\r\n__module_get(dev->tr->owner);\r\nif (!dev->mtd)\r\ngoto unlock;\r\nif (dev->tr->open) {\r\nret = dev->tr->open(dev);\r\nif (ret)\r\ngoto error_put;\r\n}\r\nret = __get_mtd_device(dev->mtd);\r\nif (ret)\r\ngoto error_release;\r\nunlock:\r\nmutex_unlock(&dev->lock);\r\nblktrans_dev_put(dev);\r\nreturn ret;\r\nerror_release:\r\nif (dev->tr->release)\r\ndev->tr->release(dev);\r\nerror_put:\r\nmodule_put(dev->tr->owner);\r\nkref_put(&dev->ref, blktrans_dev_release);\r\nmutex_unlock(&dev->lock);\r\nblktrans_dev_put(dev);\r\nreturn ret;\r\n}\r\nstatic int blktrans_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct mtd_blktrans_dev *dev = blktrans_dev_get(disk);\r\nint ret = 0;\r\nif (!dev)\r\nreturn ret;\r\nmutex_lock(&dev->lock);\r\nif (--dev->open)\r\ngoto unlock;\r\nkref_put(&dev->ref, blktrans_dev_release);\r\nmodule_put(dev->tr->owner);\r\nif (dev->mtd) {\r\nret = dev->tr->release ? dev->tr->release(dev) : 0;\r\n__put_mtd_device(dev->mtd);\r\n}\r\nunlock:\r\nmutex_unlock(&dev->lock);\r\nblktrans_dev_put(dev);\r\nreturn ret;\r\n}\r\nstatic int blktrans_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct mtd_blktrans_dev *dev = blktrans_dev_get(bdev->bd_disk);\r\nint ret = -ENXIO;\r\nif (!dev)\r\nreturn ret;\r\nmutex_lock(&dev->lock);\r\nif (!dev->mtd)\r\ngoto unlock;\r\nret = dev->tr->getgeo ? dev->tr->getgeo(dev, geo) : 0;\r\nunlock:\r\nmutex_unlock(&dev->lock);\r\nblktrans_dev_put(dev);\r\nreturn ret;\r\n}\r\nstatic int blktrans_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct mtd_blktrans_dev *dev = blktrans_dev_get(bdev->bd_disk);\r\nint ret = -ENXIO;\r\nif (!dev)\r\nreturn ret;\r\nmutex_lock(&dev->lock);\r\nif (!dev->mtd)\r\ngoto unlock;\r\nswitch (cmd) {\r\ncase BLKFLSBUF:\r\nret = dev->tr->flush ? dev->tr->flush(dev) : 0;\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\n}\r\nunlock:\r\nmutex_unlock(&dev->lock);\r\nblktrans_dev_put(dev);\r\nreturn ret;\r\n}\r\nint add_mtd_blktrans_dev(struct mtd_blktrans_dev *new)\r\n{\r\nstruct mtd_blktrans_ops *tr = new->tr;\r\nstruct mtd_blktrans_dev *d;\r\nint last_devnum = -1;\r\nstruct gendisk *gd;\r\nint ret;\r\nif (mutex_trylock(&mtd_table_mutex)) {\r\nmutex_unlock(&mtd_table_mutex);\r\nBUG();\r\n}\r\nmutex_lock(&blktrans_ref_mutex);\r\nlist_for_each_entry(d, &tr->devs, list) {\r\nif (new->devnum == -1) {\r\nif (d->devnum != last_devnum+1) {\r\nnew->devnum = last_devnum+1;\r\nlist_add_tail(&new->list, &d->list);\r\ngoto added;\r\n}\r\n} else if (d->devnum == new->devnum) {\r\nmutex_unlock(&blktrans_ref_mutex);\r\nreturn -EBUSY;\r\n} else if (d->devnum > new->devnum) {\r\nlist_add_tail(&new->list, &d->list);\r\ngoto added;\r\n}\r\nlast_devnum = d->devnum;\r\n}\r\nret = -EBUSY;\r\nif (new->devnum == -1)\r\nnew->devnum = last_devnum+1;\r\nif (new->devnum > (MINORMASK >> tr->part_bits) ||\r\n(tr->part_bits && new->devnum >= 27 * 26)) {\r\nmutex_unlock(&blktrans_ref_mutex);\r\ngoto error1;\r\n}\r\nlist_add_tail(&new->list, &tr->devs);\r\nadded:\r\nmutex_unlock(&blktrans_ref_mutex);\r\nmutex_init(&new->lock);\r\nkref_init(&new->ref);\r\nif (!tr->writesect)\r\nnew->readonly = 1;\r\nret = -ENOMEM;\r\ngd = alloc_disk(1 << tr->part_bits);\r\nif (!gd)\r\ngoto error2;\r\nnew->disk = gd;\r\ngd->private_data = new;\r\ngd->major = tr->major;\r\ngd->first_minor = (new->devnum) << tr->part_bits;\r\ngd->fops = &mtd_blktrans_ops;\r\nif (tr->part_bits)\r\nif (new->devnum < 26)\r\nsnprintf(gd->disk_name, sizeof(gd->disk_name),\r\n"%s%c", tr->name, 'a' + new->devnum);\r\nelse\r\nsnprintf(gd->disk_name, sizeof(gd->disk_name),\r\n"%s%c%c", tr->name,\r\n'a' - 1 + new->devnum / 26,\r\n'a' + new->devnum % 26);\r\nelse\r\nsnprintf(gd->disk_name, sizeof(gd->disk_name),\r\n"%s%d", tr->name, new->devnum);\r\nset_capacity(gd, (new->size * tr->blksize) >> 9);\r\nspin_lock_init(&new->queue_lock);\r\nnew->rq = blk_init_queue(mtd_blktrans_request, &new->queue_lock);\r\nif (!new->rq)\r\ngoto error3;\r\nnew->rq->queuedata = new;\r\nblk_queue_logical_block_size(new->rq, tr->blksize);\r\nif (tr->discard) {\r\nqueue_flag_set_unlocked(QUEUE_FLAG_DISCARD, new->rq);\r\nnew->rq->limits.max_discard_sectors = UINT_MAX;\r\n}\r\ngd->queue = new->rq;\r\nnew->thread = kthread_run(mtd_blktrans_thread, new,\r\n"%s%d", tr->name, new->mtd->index);\r\nif (IS_ERR(new->thread)) {\r\nret = PTR_ERR(new->thread);\r\ngoto error4;\r\n}\r\ngd->driverfs_dev = &new->mtd->dev;\r\nif (new->readonly)\r\nset_disk_ro(gd, 1);\r\nadd_disk(gd);\r\nif (new->disk_attributes) {\r\nret = sysfs_create_group(&disk_to_dev(gd)->kobj,\r\nnew->disk_attributes);\r\nWARN_ON(ret);\r\n}\r\nreturn 0;\r\nerror4:\r\nblk_cleanup_queue(new->rq);\r\nerror3:\r\nput_disk(new->disk);\r\nerror2:\r\nlist_del(&new->list);\r\nerror1:\r\nreturn ret;\r\n}\r\nint del_mtd_blktrans_dev(struct mtd_blktrans_dev *old)\r\n{\r\nunsigned long flags;\r\nif (mutex_trylock(&mtd_table_mutex)) {\r\nmutex_unlock(&mtd_table_mutex);\r\nBUG();\r\n}\r\nif (old->disk_attributes)\r\nsysfs_remove_group(&disk_to_dev(old->disk)->kobj,\r\nold->disk_attributes);\r\ndel_gendisk(old->disk);\r\nkthread_stop(old->thread);\r\nspin_lock_irqsave(&old->queue_lock, flags);\r\nold->rq->queuedata = NULL;\r\nblk_start_queue(old->rq);\r\nspin_unlock_irqrestore(&old->queue_lock, flags);\r\nmutex_lock(&old->lock);\r\nif (old->open) {\r\nif (old->tr->release)\r\nold->tr->release(old);\r\n__put_mtd_device(old->mtd);\r\n}\r\nold->mtd = NULL;\r\nmutex_unlock(&old->lock);\r\nblktrans_dev_put(old);\r\nreturn 0;\r\n}\r\nstatic void blktrans_notify_remove(struct mtd_info *mtd)\r\n{\r\nstruct mtd_blktrans_ops *tr;\r\nstruct mtd_blktrans_dev *dev, *next;\r\nlist_for_each_entry(tr, &blktrans_majors, list)\r\nlist_for_each_entry_safe(dev, next, &tr->devs, list)\r\nif (dev->mtd == mtd)\r\ntr->remove_dev(dev);\r\n}\r\nstatic void blktrans_notify_add(struct mtd_info *mtd)\r\n{\r\nstruct mtd_blktrans_ops *tr;\r\nif (mtd->type == MTD_ABSENT)\r\nreturn;\r\nlist_for_each_entry(tr, &blktrans_majors, list)\r\ntr->add_mtd(tr, mtd);\r\n}\r\nint register_mtd_blktrans(struct mtd_blktrans_ops *tr)\r\n{\r\nstruct mtd_info *mtd;\r\nint ret;\r\nif (!blktrans_notifier.list.next)\r\nregister_mtd_user(&blktrans_notifier);\r\nmutex_lock(&mtd_table_mutex);\r\nret = register_blkdev(tr->major, tr->name);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "Unable to register %s block device on major %d: %d\n",\r\ntr->name, tr->major, ret);\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn ret;\r\n}\r\nif (ret)\r\ntr->major = ret;\r\ntr->blkshift = ffs(tr->blksize) - 1;\r\nINIT_LIST_HEAD(&tr->devs);\r\nlist_add(&tr->list, &blktrans_majors);\r\nmtd_for_each_device(mtd)\r\nif (mtd->type != MTD_ABSENT)\r\ntr->add_mtd(tr, mtd);\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn 0;\r\n}\r\nint deregister_mtd_blktrans(struct mtd_blktrans_ops *tr)\r\n{\r\nstruct mtd_blktrans_dev *dev, *next;\r\nmutex_lock(&mtd_table_mutex);\r\nlist_del(&tr->list);\r\nlist_for_each_entry_safe(dev, next, &tr->devs, list)\r\ntr->remove_dev(dev);\r\nunregister_blkdev(tr->major, tr->name);\r\nmutex_unlock(&mtd_table_mutex);\r\nBUG_ON(!list_empty(&tr->devs));\r\nreturn 0;\r\n}\r\nstatic void __exit mtd_blktrans_exit(void)\r\n{\r\nif (blktrans_notifier.list.next)\r\nunregister_mtd_user(&blktrans_notifier);\r\n}
