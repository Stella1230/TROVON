int mt9m111_probe(struct sd *sd)\r\n{\r\nu8 data[2] = {0x00, 0x00};\r\nint i;\r\ns32 *sensor_settings;\r\nif (force_sensor) {\r\nif (force_sensor == MT9M111_SENSOR) {\r\ninfo("Forcing a %s sensor", mt9m111.name);\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\n}\r\nPDEBUG(D_PROBE, "Probing for a mt9m111 sensor");\r\nfor (i = 0; i < ARRAY_SIZE(preinit_mt9m111); i++) {\r\nif (preinit_mt9m111[i][0] == BRIDGE) {\r\nm5602_write_bridge(sd,\r\npreinit_mt9m111[i][1],\r\npreinit_mt9m111[i][2]);\r\n} else {\r\ndata[0] = preinit_mt9m111[i][2];\r\ndata[1] = preinit_mt9m111[i][3];\r\nm5602_write_sensor(sd,\r\npreinit_mt9m111[i][1], data, 2);\r\n}\r\n}\r\nif (m5602_read_sensor(sd, MT9M111_SC_CHIPVER, data, 2))\r\nreturn -ENODEV;\r\nif ((data[0] == 0x14) && (data[1] == 0x3a)) {\r\ninfo("Detected a mt9m111 sensor");\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\nsensor_found:\r\nsensor_settings = kmalloc(ARRAY_SIZE(mt9m111_ctrls) * sizeof(s32),\r\nGFP_KERNEL);\r\nif (!sensor_settings)\r\nreturn -ENOMEM;\r\nsd->gspca_dev.cam.cam_mode = mt9m111_modes;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(mt9m111_modes);\r\nsd->desc->ctrls = mt9m111_ctrls;\r\nsd->desc->nctrls = ARRAY_SIZE(mt9m111_ctrls);\r\nfor (i = 0; i < ARRAY_SIZE(mt9m111_ctrls); i++)\r\nsensor_settings[i] = mt9m111_ctrls[i].qctrl.default_value;\r\nsd->sensor_priv = sensor_settings;\r\nreturn 0;\r\n}\r\nint mt9m111_init(struct sd *sd)\r\n{\r\nint i, err = 0;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nfor (i = 0; i < ARRAY_SIZE(init_mt9m111) && !err; i++) {\r\nu8 data[2];\r\nif (init_mt9m111[i][0] == BRIDGE) {\r\nerr = m5602_write_bridge(sd,\r\ninit_mt9m111[i][1],\r\ninit_mt9m111[i][2]);\r\n} else {\r\ndata[0] = init_mt9m111[i][2];\r\ndata[1] = init_mt9m111[i][3];\r\nerr = m5602_write_sensor(sd,\r\ninit_mt9m111[i][1], data, 2);\r\n}\r\n}\r\nif (dump_sensor)\r\nmt9m111_dump_registers(sd);\r\nerr = mt9m111_set_vflip(&sd->gspca_dev, sensor_settings[VFLIP_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = mt9m111_set_hflip(&sd->gspca_dev, sensor_settings[HFLIP_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = mt9m111_set_green_balance(&sd->gspca_dev,\r\nsensor_settings[GREEN_BALANCE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = mt9m111_set_blue_balance(&sd->gspca_dev,\r\nsensor_settings[BLUE_BALANCE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = mt9m111_set_red_balance(&sd->gspca_dev,\r\nsensor_settings[RED_BALANCE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nreturn mt9m111_set_gain(&sd->gspca_dev, sensor_settings[GAIN_IDX]);\r\n}\r\nint mt9m111_start(struct sd *sd)\r\n{\r\nint i, err = 0;\r\nu8 data[2];\r\nstruct cam *cam = &sd->gspca_dev.cam;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nint width = cam->cam_mode[sd->gspca_dev.curr_mode].width - 1;\r\nint height = cam->cam_mode[sd->gspca_dev.curr_mode].height;\r\nfor (i = 0; i < ARRAY_SIZE(start_mt9m111) && !err; i++) {\r\nif (start_mt9m111[i][0] == BRIDGE) {\r\nerr = m5602_write_bridge(sd,\r\nstart_mt9m111[i][1],\r\nstart_mt9m111[i][2]);\r\n} else {\r\ndata[0] = start_mt9m111[i][2];\r\ndata[1] = start_mt9m111[i][3];\r\nerr = m5602_write_sensor(sd,\r\nstart_mt9m111[i][1], data, 2);\r\n}\r\n}\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height >> 8) & 0xff);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height & 0xff));\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 2 && !err; i++)\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 2);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 2 && !err; i++)\r\nerr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA,\r\n(width >> 8) & 0xff);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, width & 0xff);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\r\nif (err < 0)\r\nreturn err;\r\nswitch (width) {\r\ncase 640:\r\nPDEBUG(D_V4L2, "Configuring camera for VGA mode");\r\ndata[0] = MT9M111_RMB_OVER_SIZED;\r\ndata[1] = MT9M111_RMB_ROW_SKIP_2X |\r\nMT9M111_RMB_COLUMN_SKIP_2X |\r\n(sensor_settings[VFLIP_IDX] << 0) |\r\n(sensor_settings[HFLIP_IDX] << 1);\r\nerr = m5602_write_sensor(sd,\r\nMT9M111_SC_R_MODE_CONTEXT_B, data, 2);\r\nbreak;\r\ncase 320:\r\nPDEBUG(D_V4L2, "Configuring camera for QVGA mode");\r\ndata[0] = MT9M111_RMB_OVER_SIZED;\r\ndata[1] = MT9M111_RMB_ROW_SKIP_4X |\r\nMT9M111_RMB_COLUMN_SKIP_4X |\r\n(sensor_settings[VFLIP_IDX] << 0) |\r\n(sensor_settings[HFLIP_IDX] << 1);\r\nerr = m5602_write_sensor(sd,\r\nMT9M111_SC_R_MODE_CONTEXT_B, data, 2);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nvoid mt9m111_disconnect(struct sd *sd)\r\n{\r\nsd->sensor = NULL;\r\nkfree(sd->sensor_priv);\r\n}\r\nstatic int mt9m111_get_vflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[VFLIP_IDX];\r\nPDEBUG(D_V4L2, "Read vertical flip %d", *val);\r\nreturn 0;\r\n}\r\nstatic int mt9m111_set_vflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[2] = {0x00, 0x00};\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set vertical flip to %d", val);\r\nsensor_settings[VFLIP_IDX] = val;\r\nval = !val;\r\nerr = m5602_write_sensor(sd, MT9M111_PAGE_MAP, data, 2);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_read_sensor(sd, MT9M111_SC_R_MODE_CONTEXT_B, data, 2);\r\nif (err < 0)\r\nreturn err;\r\ndata[1] = (data[1] & 0xfe) | val;\r\nerr = m5602_write_sensor(sd, MT9M111_SC_R_MODE_CONTEXT_B,\r\ndata, 2);\r\nreturn err;\r\n}\r\nstatic int mt9m111_get_hflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[HFLIP_IDX];\r\nPDEBUG(D_V4L2, "Read horizontal flip %d", *val);\r\nreturn 0;\r\n}\r\nstatic int mt9m111_set_hflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[2] = {0x00, 0x00};\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set horizontal flip to %d", val);\r\nsensor_settings[HFLIP_IDX] = val;\r\nval = !val;\r\nerr = m5602_write_sensor(sd, MT9M111_PAGE_MAP, data, 2);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_read_sensor(sd, MT9M111_SC_R_MODE_CONTEXT_B, data, 2);\r\nif (err < 0)\r\nreturn err;\r\ndata[1] = (data[1] & 0xfd) | ((val << 1) & 0x02);\r\nerr = m5602_write_sensor(sd, MT9M111_SC_R_MODE_CONTEXT_B,\r\ndata, 2);\r\nreturn err;\r\n}\r\nstatic int mt9m111_get_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[GAIN_IDX];\r\nPDEBUG(D_V4L2, "Read gain %d", *val);\r\nreturn 0;\r\n}\r\nstatic int mt9m111_set_auto_white_balance(struct gspca_dev *gspca_dev,\r\n__s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nint err;\r\nu8 data[2];\r\nerr = m5602_read_sensor(sd, MT9M111_CP_OPERATING_MODE_CTL, data, 2);\r\nif (err < 0)\r\nreturn err;\r\nsensor_settings[AUTO_WHITE_BALANCE_IDX] = val & 0x01;\r\ndata[1] = ((data[1] & 0xfd) | ((val & 0x01) << 1));\r\nerr = m5602_write_sensor(sd, MT9M111_CP_OPERATING_MODE_CTL, data, 2);\r\nPDEBUG(D_V4L2, "Set auto white balance %d", val);\r\nreturn err;\r\n}\r\nstatic int mt9m111_get_auto_white_balance(struct gspca_dev *gspca_dev,\r\n__s32 *val) {\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[AUTO_WHITE_BALANCE_IDX];\r\nPDEBUG(D_V4L2, "Read auto white balance %d", *val);\r\nreturn 0;\r\n}\r\nstatic int mt9m111_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err, tmp;\r\nu8 data[2] = {0x00, 0x00};\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[GAIN_IDX] = val;\r\nerr = m5602_write_sensor(sd, MT9M111_PAGE_MAP, data, 2);\r\nif (err < 0)\r\nreturn err;\r\nif (val >= INITIAL_MAX_GAIN * 2 * 2 * 2)\r\nreturn -EINVAL;\r\nif ((val >= INITIAL_MAX_GAIN * 2 * 2) &&\r\n(val < (INITIAL_MAX_GAIN - 1) * 2 * 2 * 2))\r\ntmp = (1 << 10) | (val << 9) |\r\n(val << 8) | (val / 8);\r\nelse if ((val >= INITIAL_MAX_GAIN * 2) &&\r\n(val < INITIAL_MAX_GAIN * 2 * 2))\r\ntmp = (1 << 9) | (1 << 8) | (val / 4);\r\nelse if ((val >= INITIAL_MAX_GAIN) &&\r\n(val < INITIAL_MAX_GAIN * 2))\r\ntmp = (1 << 8) | (val / 2);\r\nelse\r\ntmp = val;\r\ndata[1] = (tmp & 0xff);\r\ndata[0] = (tmp & 0xff00) >> 8;\r\nPDEBUG(D_V4L2, "tmp=%d, data[1]=%d, data[0]=%d", tmp,\r\ndata[1], data[0]);\r\nerr = m5602_write_sensor(sd, MT9M111_SC_GLOBAL_GAIN,\r\ndata, 2);\r\nreturn err;\r\n}\r\nstatic int mt9m111_set_green_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[2];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[GREEN_BALANCE_IDX] = val;\r\ndata[1] = (val & 0xff);\r\ndata[0] = (val & 0xff00) >> 8;\r\nPDEBUG(D_V4L2, "Set green balance %d", val);\r\nerr = m5602_write_sensor(sd, MT9M111_SC_GREEN_1_GAIN,\r\ndata, 2);\r\nif (err < 0)\r\nreturn err;\r\nreturn m5602_write_sensor(sd, MT9M111_SC_GREEN_2_GAIN,\r\ndata, 2);\r\n}\r\nstatic int mt9m111_get_green_balance(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[GREEN_BALANCE_IDX];\r\nPDEBUG(D_V4L2, "Read green balance %d", *val);\r\nreturn 0;\r\n}\r\nstatic int mt9m111_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nu8 data[2];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[BLUE_BALANCE_IDX] = val;\r\ndata[1] = (val & 0xff);\r\ndata[0] = (val & 0xff00) >> 8;\r\nPDEBUG(D_V4L2, "Set blue balance %d", val);\r\nreturn m5602_write_sensor(sd, MT9M111_SC_BLUE_GAIN,\r\ndata, 2);\r\n}\r\nstatic int mt9m111_get_blue_balance(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[BLUE_BALANCE_IDX];\r\nPDEBUG(D_V4L2, "Read blue balance %d", *val);\r\nreturn 0;\r\n}\r\nstatic int mt9m111_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nu8 data[2];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[RED_BALANCE_IDX] = val;\r\ndata[1] = (val & 0xff);\r\ndata[0] = (val & 0xff00) >> 8;\r\nPDEBUG(D_V4L2, "Set red balance %d", val);\r\nreturn m5602_write_sensor(sd, MT9M111_SC_RED_GAIN,\r\ndata, 2);\r\n}\r\nstatic int mt9m111_get_red_balance(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[RED_BALANCE_IDX];\r\nPDEBUG(D_V4L2, "Read red balance %d", *val);\r\nreturn 0;\r\n}\r\nstatic void mt9m111_dump_registers(struct sd *sd)\r\n{\r\nu8 address, value[2] = {0x00, 0x00};\r\ninfo("Dumping the mt9m111 register state");\r\ninfo("Dumping the mt9m111 sensor core registers");\r\nvalue[1] = MT9M111_SENSOR_CORE;\r\nm5602_write_sensor(sd, MT9M111_PAGE_MAP, value, 2);\r\nfor (address = 0; address < 0xff; address++) {\r\nm5602_read_sensor(sd, address, value, 2);\r\ninfo("register 0x%x contains 0x%x%x",\r\naddress, value[0], value[1]);\r\n}\r\ninfo("Dumping the mt9m111 color pipeline registers");\r\nvalue[1] = MT9M111_COLORPIPE;\r\nm5602_write_sensor(sd, MT9M111_PAGE_MAP, value, 2);\r\nfor (address = 0; address < 0xff; address++) {\r\nm5602_read_sensor(sd, address, value, 2);\r\ninfo("register 0x%x contains 0x%x%x",\r\naddress, value[0], value[1]);\r\n}\r\ninfo("Dumping the mt9m111 camera control registers");\r\nvalue[1] = MT9M111_CAMERA_CONTROL;\r\nm5602_write_sensor(sd, MT9M111_PAGE_MAP, value, 2);\r\nfor (address = 0; address < 0xff; address++) {\r\nm5602_read_sensor(sd, address, value, 2);\r\ninfo("register 0x%x contains 0x%x%x",\r\naddress, value[0], value[1]);\r\n}\r\ninfo("mt9m111 register state dump complete");\r\n}
