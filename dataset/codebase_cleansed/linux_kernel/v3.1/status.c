void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint tmp;\r\nskb->pkt_type = IEEE80211_TX_STATUS_MSG;\r\nskb_queue_tail(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS ?\r\n&local->skb_queue : &local->skb_queue_unreliable, skb);\r\ntmp = skb_queue_len(&local->skb_queue) +\r\nskb_queue_len(&local->skb_queue_unreliable);\r\nwhile (tmp > IEEE80211_IRQSAFE_QUEUE_LIMIT &&\r\n(skb = skb_dequeue(&local->skb_queue_unreliable))) {\r\ndev_kfree_skb_irq(skb);\r\ntmp--;\r\nI802_DEBUG_INC(local->tx_status_drop);\r\n}\r\ntasklet_schedule(&local->tasklet);\r\n}\r\nstatic void ieee80211_handle_filtered_frame(struct ieee80211_local *local,\r\nstruct sta_info *sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nmemset(&info->control, 0, sizeof(info->control));\r\ninfo->control.jiffies = jiffies;\r\ninfo->control.vif = &sta->sdata->vif;\r\ninfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING |\r\nIEEE80211_TX_INTFL_RETRANSMISSION;\r\ninfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\r\nsta->tx_filtered_count++;\r\nset_sta_flags(sta, WLAN_STA_CLEAR_PS_FILT);\r\nif (test_sta_flags(sta, WLAN_STA_PS_STA) &&\r\nskb_queue_len(&sta->tx_filtered) < STA_MAX_TX_BUFFER) {\r\nskb_queue_tail(&sta->tx_filtered, skb);\r\nreturn;\r\n}\r\nif (!test_sta_flags(sta, WLAN_STA_PS_STA) &&\r\n!(info->flags & IEEE80211_TX_INTFL_RETRIED)) {\r\ninfo->flags |= IEEE80211_TX_INTFL_RETRIED;\r\nieee80211_add_pending_skb(local, skb);\r\nreturn;\r\n}\r\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\r\nif (net_ratelimit())\r\nwiphy_debug(local->hw.wiphy,\r\n"dropped TX filtered frame, queue_len=%d PS=%d @%lu\n",\r\nskb_queue_len(&sta->tx_filtered),\r\n!!test_sta_flags(sta, WLAN_STA_PS_STA), jiffies);\r\n#endif\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void ieee80211_frame_acked(struct sta_info *sta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_mgmt *mgmt = (void *) skb->data;\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nif (ieee80211_is_action(mgmt->frame_control) &&\r\nsdata->vif.type == NL80211_IFTYPE_STATION &&\r\nmgmt->u.action.category == WLAN_CATEGORY_HT &&\r\nmgmt->u.action.u.ht_smps.action == WLAN_HT_ACTION_SMPS) {\r\nswitch (mgmt->u.action.u.ht_smps.smps_control) {\r\ncase WLAN_HT_SMPS_CONTROL_DYNAMIC:\r\nsta->sdata->u.mgd.ap_smps = IEEE80211_SMPS_DYNAMIC;\r\nbreak;\r\ncase WLAN_HT_SMPS_CONTROL_STATIC:\r\nsta->sdata->u.mgd.ap_smps = IEEE80211_SMPS_STATIC;\r\nbreak;\r\ncase WLAN_HT_SMPS_CONTROL_DISABLED:\r\ndefault:\r\nsta->sdata->u.mgd.ap_smps = IEEE80211_SMPS_OFF;\r\nbreak;\r\n}\r\nieee80211_queue_work(&local->hw, &local->recalc_smps);\r\n}\r\n}\r\nvoid ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skb2;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nu16 frag, type;\r\n__le16 fc;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_tx_status_rtap_hdr *rthdr;\r\nstruct ieee80211_sub_if_data *sdata;\r\nstruct net_device *prev_dev = NULL;\r\nstruct sta_info *sta, *tmp;\r\nint retry_count = -1, i;\r\nint rates_idx = -1;\r\nbool send_to_cooked;\r\nbool acked;\r\nfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\r\nif (info->status.rates[i].idx < 0) {\r\nbreak;\r\n} else if (i >= hw->max_report_rates) {\r\ninfo->status.rates[i].idx = -1;\r\ninfo->status.rates[i].count = 0;\r\nbreak;\r\n}\r\nretry_count += info->status.rates[i].count;\r\n}\r\nrates_idx = i - 1;\r\nif (retry_count < 0)\r\nretry_count = 0;\r\nrcu_read_lock();\r\nsband = local->hw.wiphy->bands[info->band];\r\nfc = hdr->frame_control;\r\nfor_each_sta_info(local, hdr->addr1, sta, tmp) {\r\nif (memcmp(hdr->addr2, sta->sdata->vif.addr, ETH_ALEN))\r\ncontinue;\r\nacked = !!(info->flags & IEEE80211_TX_STAT_ACK);\r\nif (!acked && test_sta_flags(sta, WLAN_STA_PS_STA)) {\r\nieee80211_handle_filtered_frame(local, sta, skb);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif ((local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL) &&\r\n(rates_idx != -1))\r\nsta->last_tx_rate = info->status.rates[rates_idx];\r\nif ((info->flags & IEEE80211_TX_STAT_AMPDU_NO_BACK) &&\r\n(ieee80211_is_data_qos(fc))) {\r\nu16 tid, ssn;\r\nu8 *qc;\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & 0xf;\r\nssn = ((le16_to_cpu(hdr->seq_ctrl) + 0x10)\r\n& IEEE80211_SCTL_SEQ);\r\nieee80211_send_bar(sta->sdata, hdr->addr1,\r\ntid, ssn);\r\n}\r\nif (info->flags & IEEE80211_TX_STAT_TX_FILTERED) {\r\nieee80211_handle_filtered_frame(local, sta, skb);\r\nrcu_read_unlock();\r\nreturn;\r\n} else {\r\nif (!acked)\r\nsta->tx_retry_failed++;\r\nsta->tx_retry_count += retry_count;\r\n}\r\nrate_control_tx_status(local, sband, sta, skb);\r\nif (ieee80211_vif_is_mesh(&sta->sdata->vif))\r\nieee80211s_update_metric(local, sta, skb);\r\nif (!(info->flags & IEEE80211_TX_CTL_INJECTED) && acked)\r\nieee80211_frame_acked(sta, skb);\r\nif ((sta->sdata->vif.type == NL80211_IFTYPE_STATION) &&\r\n(local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS))\r\nieee80211_sta_tx_notify(sta->sdata, (void *) skb->data, acked);\r\nif (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) {\r\nif (info->flags & IEEE80211_TX_STAT_ACK) {\r\nif (sta->lost_packets)\r\nsta->lost_packets = 0;\r\n} else if (++sta->lost_packets >= STA_LOST_PKT_THRESHOLD) {\r\ncfg80211_cqm_pktloss_notify(sta->sdata->dev,\r\nsta->sta.addr,\r\nsta->lost_packets,\r\nGFP_ATOMIC);\r\nsta->lost_packets = 0;\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\nieee80211_led_tx(local, 0);\r\nfrag = le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;\r\ntype = le16_to_cpu(hdr->frame_control) & IEEE80211_FCTL_FTYPE;\r\nif (info->flags & IEEE80211_TX_STAT_ACK) {\r\nif (frag == 0) {\r\nlocal->dot11TransmittedFrameCount++;\r\nif (is_multicast_ether_addr(hdr->addr1))\r\nlocal->dot11MulticastTransmittedFrameCount++;\r\nif (retry_count > 0)\r\nlocal->dot11RetryCount++;\r\nif (retry_count > 1)\r\nlocal->dot11MultipleRetryCount++;\r\n}\r\nif (!is_multicast_ether_addr(hdr->addr1) ||\r\ntype == IEEE80211_FTYPE_DATA ||\r\ntype == IEEE80211_FTYPE_MGMT)\r\nlocal->dot11TransmittedFragmentCount++;\r\n} else {\r\nif (frag == 0)\r\nlocal->dot11FailedCount++;\r\n}\r\nif (ieee80211_is_nullfunc(fc) && ieee80211_has_pm(fc) &&\r\n(local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) &&\r\n!(info->flags & IEEE80211_TX_CTL_INJECTED) &&\r\nlocal->ps_sdata && !(local->scanning)) {\r\nif (info->flags & IEEE80211_TX_STAT_ACK) {\r\nlocal->ps_sdata->u.mgd.flags |=\r\nIEEE80211_STA_NULLFUNC_ACKED;\r\n} else\r\nmod_timer(&local->dynamic_ps_timer, jiffies +\r\nmsecs_to_jiffies(10));\r\n}\r\nif (info->flags & IEEE80211_TX_INTFL_NL80211_FRAME_TX) {\r\nstruct ieee80211_work *wk;\r\nu64 cookie = (unsigned long)skb;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(wk, &local->work_list, list) {\r\nif (wk->type != IEEE80211_WORK_OFFCHANNEL_TX)\r\ncontinue;\r\nif (wk->offchan_tx.frame != skb)\r\ncontinue;\r\nwk->offchan_tx.frame = NULL;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (local->hw_roc_skb_for_status == skb) {\r\ncookie = local->hw_roc_cookie ^ 2;\r\nlocal->hw_roc_skb_for_status = NULL;\r\n}\r\nif (cookie == local->hw_offchan_tx_cookie)\r\nlocal->hw_offchan_tx_cookie = 0;\r\ncfg80211_mgmt_tx_status(\r\nskb->dev, cookie, skb->data, skb->len,\r\n!!(info->flags & IEEE80211_TX_STAT_ACK), GFP_ATOMIC);\r\n}\r\nskb_orphan(skb);\r\nsend_to_cooked = !!(info->flags & IEEE80211_TX_CTL_INJECTED) ||\r\n(type != IEEE80211_FTYPE_DATA);\r\nif (!local->monitors && (!send_to_cooked || !local->cooked_mntrs)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (skb_headroom(skb) < sizeof(*rthdr)) {\r\nprintk(KERN_ERR "ieee80211_tx_status: headroom too small\n");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nrthdr = (struct ieee80211_tx_status_rtap_hdr *)\r\nskb_push(skb, sizeof(*rthdr));\r\nmemset(rthdr, 0, sizeof(*rthdr));\r\nrthdr->hdr.it_len = cpu_to_le16(sizeof(*rthdr));\r\nrthdr->hdr.it_present =\r\ncpu_to_le32((1 << IEEE80211_RADIOTAP_TX_FLAGS) |\r\n(1 << IEEE80211_RADIOTAP_DATA_RETRIES) |\r\n(1 << IEEE80211_RADIOTAP_RATE));\r\nif (!(info->flags & IEEE80211_TX_STAT_ACK) &&\r\n!is_multicast_ether_addr(hdr->addr1))\r\nrthdr->tx_flags |= cpu_to_le16(IEEE80211_RADIOTAP_F_TX_FAIL);\r\nif ((info->status.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) ||\r\n(info->status.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT))\r\nrthdr->tx_flags |= cpu_to_le16(IEEE80211_RADIOTAP_F_TX_CTS);\r\nelse if (info->status.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)\r\nrthdr->tx_flags |= cpu_to_le16(IEEE80211_RADIOTAP_F_TX_RTS);\r\nif (info->status.rates[0].idx >= 0 &&\r\n!(info->status.rates[0].flags & IEEE80211_TX_RC_MCS))\r\nrthdr->rate = sband->bitrates[\r\ninfo->status.rates[0].idx].bitrate / 5;\r\nrthdr->data_retries = retry_count;\r\nskb_set_mac_header(skb, 0);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\r\nif (sdata->vif.type == NL80211_IFTYPE_MONITOR) {\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif ((sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) &&\r\n!send_to_cooked)\r\ncontinue;\r\nif (prev_dev) {\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2) {\r\nskb2->dev = prev_dev;\r\nnetif_rx(skb2);\r\n}\r\n}\r\nprev_dev = sdata->dev;\r\n}\r\n}\r\nif (prev_dev) {\r\nskb->dev = prev_dev;\r\nnetif_rx(skb);\r\nskb = NULL;\r\n}\r\nrcu_read_unlock();\r\ndev_kfree_skb(skb);\r\n}\r\nvoid ieee80211_report_low_ack(struct ieee80211_sta *pubsta, u32 num_packets)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\ncfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,\r\nnum_packets, GFP_ATOMIC);\r\n}
