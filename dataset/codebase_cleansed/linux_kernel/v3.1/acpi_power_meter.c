static int can_cap_in_hardware(void)\r\n{\r\nreturn force_cap_on || cap_in_hardware;\r\n}\r\nstatic int update_avg_interval(struct acpi_power_meter_resource *resource)\r\n{\r\nunsigned long long data;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(resource->acpi_dev->handle, "_GAI",\r\nNULL, &data);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _GAI"));\r\nreturn -ENODEV;\r\n}\r\nresource->avg_interval = data;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_avg_interval(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nmutex_lock(&resource->lock);\r\nupdate_avg_interval(resource);\r\nmutex_unlock(&resource->lock);\r\nreturn sprintf(buf, "%llu\n", resource->avg_interval);\r\n}\r\nstatic ssize_t set_avg_interval(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\r\nstruct acpi_object_list args = { 1, &arg0 };\r\nint res;\r\nunsigned long temp;\r\nunsigned long long data;\r\nacpi_status status;\r\nres = strict_strtoul(buf, 10, &temp);\r\nif (res)\r\nreturn res;\r\nif (temp > resource->caps.max_avg_interval ||\r\ntemp < resource->caps.min_avg_interval)\r\nreturn -EINVAL;\r\narg0.integer.value = temp;\r\nmutex_lock(&resource->lock);\r\nstatus = acpi_evaluate_integer(resource->acpi_dev->handle, "_PAI",\r\n&args, &data);\r\nif (!ACPI_FAILURE(status))\r\nresource->avg_interval = temp;\r\nmutex_unlock(&resource->lock);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PAI"));\r\nreturn -EINVAL;\r\n}\r\nif (data)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int update_cap(struct acpi_power_meter_resource *resource)\r\n{\r\nunsigned long long data;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(resource->acpi_dev->handle, "_GHL",\r\nNULL, &data);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _GHL"));\r\nreturn -ENODEV;\r\n}\r\nresource->cap = data;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_cap(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nmutex_lock(&resource->lock);\r\nupdate_cap(resource);\r\nmutex_unlock(&resource->lock);\r\nreturn sprintf(buf, "%llu\n", resource->cap * 1000);\r\n}\r\nstatic ssize_t set_cap(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\r\nstruct acpi_object_list args = { 1, &arg0 };\r\nint res;\r\nunsigned long temp;\r\nunsigned long long data;\r\nacpi_status status;\r\nres = strict_strtoul(buf, 10, &temp);\r\nif (res)\r\nreturn res;\r\ntemp /= 1000;\r\nif (temp > resource->caps.max_cap || temp < resource->caps.min_cap)\r\nreturn -EINVAL;\r\narg0.integer.value = temp;\r\nmutex_lock(&resource->lock);\r\nstatus = acpi_evaluate_integer(resource->acpi_dev->handle, "_SHL",\r\n&args, &data);\r\nif (!ACPI_FAILURE(status))\r\nresource->cap = temp;\r\nmutex_unlock(&resource->lock);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _SHL"));\r\nreturn -EINVAL;\r\n}\r\nif (data)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int set_acpi_trip(struct acpi_power_meter_resource *resource)\r\n{\r\nunion acpi_object arg_objs[] = {\r\n{ACPI_TYPE_INTEGER},\r\n{ACPI_TYPE_INTEGER}\r\n};\r\nstruct acpi_object_list args = { 2, arg_objs };\r\nunsigned long long data;\r\nacpi_status status;\r\nif (resource->trip[0] < 0 || resource->trip[1] < 0)\r\nreturn 0;\r\narg_objs[0].integer.value = resource->trip[1];\r\narg_objs[1].integer.value = resource->trip[0];\r\nstatus = acpi_evaluate_integer(resource->acpi_dev->handle, "_PTP",\r\n&args, &data);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PTP"));\r\nreturn -EINVAL;\r\n}\r\nif (data)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t set_trip(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nint res;\r\nunsigned long temp;\r\nres = strict_strtoul(buf, 10, &temp);\r\nif (res)\r\nreturn res;\r\ntemp /= 1000;\r\nif (temp < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&resource->lock);\r\nresource->trip[attr->index - 7] = temp;\r\nres = set_acpi_trip(resource);\r\nmutex_unlock(&resource->lock);\r\nif (res)\r\nreturn res;\r\nreturn count;\r\n}\r\nstatic int update_meter(struct acpi_power_meter_resource *resource)\r\n{\r\nunsigned long long data;\r\nacpi_status status;\r\nunsigned long local_jiffies = jiffies;\r\nif (time_before(local_jiffies, resource->sensors_last_updated +\r\nmsecs_to_jiffies(resource->caps.sampling_time)) &&\r\nresource->sensors_valid)\r\nreturn 0;\r\nstatus = acpi_evaluate_integer(resource->acpi_dev->handle, "_PMM",\r\nNULL, &data);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PMM"));\r\nreturn -ENODEV;\r\n}\r\nresource->power = data;\r\nresource->sensors_valid = 1;\r\nresource->sensors_last_updated = jiffies;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_power(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nmutex_lock(&resource->lock);\r\nupdate_meter(resource);\r\nmutex_unlock(&resource->lock);\r\nreturn sprintf(buf, "%llu\n", resource->power * 1000);\r\n}\r\nstatic ssize_t show_str(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nacpi_string val;\r\nswitch (attr->index) {\r\ncase 0:\r\nval = resource->model_number;\r\nbreak;\r\ncase 1:\r\nval = resource->serial_number;\r\nbreak;\r\ncase 2:\r\nval = resource->oem_info;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn sprintf(buf, "%s\n", val);\r\n}\r\nstatic ssize_t show_val(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nu64 val = 0;\r\nswitch (attr->index) {\r\ncase 0:\r\nval = resource->caps.min_avg_interval;\r\nbreak;\r\ncase 1:\r\nval = resource->caps.max_avg_interval;\r\nbreak;\r\ncase 2:\r\nval = resource->caps.min_cap * 1000;\r\nbreak;\r\ncase 3:\r\nval = resource->caps.max_cap * 1000;\r\nbreak;\r\ncase 4:\r\nif (resource->caps.hysteresis == UNKNOWN_HYSTERESIS)\r\nreturn sprintf(buf, "unknown\n");\r\nval = resource->caps.hysteresis * 1000;\r\nbreak;\r\ncase 5:\r\nif (resource->caps.flags & POWER_METER_IS_BATTERY)\r\nval = 1;\r\nelse\r\nval = 0;\r\nbreak;\r\ncase 6:\r\nif (resource->power > resource->cap)\r\nval = 1;\r\nelse\r\nval = 0;\r\nbreak;\r\ncase 7:\r\ncase 8:\r\nif (resource->trip[attr->index - 7] < 0)\r\nreturn sprintf(buf, "unknown\n");\r\nval = resource->trip[attr->index - 7] * 1000;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn sprintf(buf, "%llu\n", val);\r\n}\r\nstatic ssize_t show_accuracy(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi_dev = to_acpi_device(dev);\r\nstruct acpi_power_meter_resource *resource = acpi_dev->driver_data;\r\nunsigned int acc = resource->caps.accuracy;\r\nreturn sprintf(buf, "%u.%u%%\n", acc / 1000, acc % 1000);\r\n}\r\nstatic ssize_t show_name(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", ACPI_POWER_METER_NAME);\r\n}\r\nstatic void remove_domain_devices(struct acpi_power_meter_resource *resource)\r\n{\r\nint i;\r\nif (!resource->num_domain_devices)\r\nreturn;\r\nfor (i = 0; i < resource->num_domain_devices; i++) {\r\nstruct acpi_device *obj = resource->domain_devices[i];\r\nif (!obj)\r\ncontinue;\r\nsysfs_remove_link(resource->holders_dir,\r\nkobject_name(&obj->dev.kobj));\r\nput_device(&obj->dev);\r\n}\r\nkfree(resource->domain_devices);\r\nkobject_put(resource->holders_dir);\r\nresource->num_domain_devices = 0;\r\n}\r\nstatic int read_domain_devices(struct acpi_power_meter_resource *resource)\r\n{\r\nint res = 0;\r\nint i;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *pss;\r\nacpi_status status;\r\nstatus = acpi_evaluate_object(resource->acpi_dev->handle, "_PMD", NULL,\r\n&buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PMD"));\r\nreturn -ENODEV;\r\n}\r\npss = buffer.pointer;\r\nif (!pss ||\r\npss->type != ACPI_TYPE_PACKAGE) {\r\ndev_err(&resource->acpi_dev->dev, ACPI_POWER_METER_NAME\r\n"Invalid _PMD data\n");\r\nres = -EFAULT;\r\ngoto end;\r\n}\r\nif (!pss->package.count)\r\ngoto end;\r\nresource->domain_devices = kzalloc(sizeof(struct acpi_device *) *\r\npss->package.count, GFP_KERNEL);\r\nif (!resource->domain_devices) {\r\nres = -ENOMEM;\r\ngoto end;\r\n}\r\nresource->holders_dir = kobject_create_and_add("measures",\r\n&resource->acpi_dev->dev.kobj);\r\nif (!resource->holders_dir) {\r\nres = -ENOMEM;\r\ngoto exit_free;\r\n}\r\nresource->num_domain_devices = pss->package.count;\r\nfor (i = 0; i < pss->package.count; i++) {\r\nstruct acpi_device *obj;\r\nunion acpi_object *element = &(pss->package.elements[i]);\r\nif (element->type != ACPI_TYPE_LOCAL_REFERENCE)\r\ncontinue;\r\nresource->domain_devices[i] = NULL;\r\nstatus = acpi_bus_get_device(element->reference.handle,\r\n&resource->domain_devices[i]);\r\nif (ACPI_FAILURE(status))\r\ncontinue;\r\nobj = resource->domain_devices[i];\r\nget_device(&obj->dev);\r\nres = sysfs_create_link(resource->holders_dir, &obj->dev.kobj,\r\nkobject_name(&obj->dev.kobj));\r\nif (res) {\r\nput_device(&obj->dev);\r\nresource->domain_devices[i] = NULL;\r\n}\r\n}\r\nres = 0;\r\ngoto end;\r\nexit_free:\r\nkfree(resource->domain_devices);\r\nend:\r\nkfree(buffer.pointer);\r\nreturn res;\r\n}\r\nstatic int register_ro_attrs(struct acpi_power_meter_resource *resource,\r\nstruct ro_sensor_template *ro)\r\n{\r\nstruct device *dev = &resource->acpi_dev->dev;\r\nstruct sensor_device_attribute *sensors =\r\n&resource->sensors[resource->num_sensors];\r\nint res = 0;\r\nwhile (ro->label) {\r\nsensors->dev_attr.attr.name = ro->label;\r\nsensors->dev_attr.attr.mode = S_IRUGO;\r\nsensors->dev_attr.show = ro->show;\r\nsensors->index = ro->index;\r\nres = device_create_file(dev, &sensors->dev_attr);\r\nif (res) {\r\nsensors->dev_attr.attr.name = NULL;\r\ngoto error;\r\n}\r\nsensors++;\r\nresource->num_sensors++;\r\nro++;\r\n}\r\nerror:\r\nreturn res;\r\n}\r\nstatic int register_rw_attrs(struct acpi_power_meter_resource *resource,\r\nstruct rw_sensor_template *rw)\r\n{\r\nstruct device *dev = &resource->acpi_dev->dev;\r\nstruct sensor_device_attribute *sensors =\r\n&resource->sensors[resource->num_sensors];\r\nint res = 0;\r\nwhile (rw->label) {\r\nsensors->dev_attr.attr.name = rw->label;\r\nsensors->dev_attr.attr.mode = S_IRUGO | S_IWUSR;\r\nsensors->dev_attr.show = rw->show;\r\nsensors->dev_attr.store = rw->set;\r\nsensors->index = rw->index;\r\nres = device_create_file(dev, &sensors->dev_attr);\r\nif (res) {\r\nsensors->dev_attr.attr.name = NULL;\r\ngoto error;\r\n}\r\nsensors++;\r\nresource->num_sensors++;\r\nrw++;\r\n}\r\nerror:\r\nreturn res;\r\n}\r\nstatic void remove_attrs(struct acpi_power_meter_resource *resource)\r\n{\r\nint i;\r\nfor (i = 0; i < resource->num_sensors; i++) {\r\nif (!resource->sensors[i].dev_attr.attr.name)\r\ncontinue;\r\ndevice_remove_file(&resource->acpi_dev->dev,\r\n&resource->sensors[i].dev_attr);\r\n}\r\nremove_domain_devices(resource);\r\nresource->num_sensors = 0;\r\n}\r\nstatic int setup_attrs(struct acpi_power_meter_resource *resource)\r\n{\r\nint res = 0;\r\nres = read_domain_devices(resource);\r\nif (res)\r\nreturn res;\r\nif (resource->caps.flags & POWER_METER_CAN_MEASURE) {\r\nres = register_ro_attrs(resource, meter_ro_attrs);\r\nif (res)\r\ngoto error;\r\nres = register_rw_attrs(resource, meter_rw_attrs);\r\nif (res)\r\ngoto error;\r\n}\r\nif (resource->caps.flags & POWER_METER_CAN_CAP) {\r\nif (!can_cap_in_hardware()) {\r\ndev_err(&resource->acpi_dev->dev,\r\n"Ignoring unsafe software power cap!\n");\r\ngoto skip_unsafe_cap;\r\n}\r\nif (resource->caps.configurable_cap) {\r\nres = register_rw_attrs(resource, rw_cap_attrs);\r\nif (res)\r\ngoto error;\r\n} else {\r\nres = register_ro_attrs(resource, ro_cap_attrs);\r\nif (res)\r\ngoto error;\r\n}\r\nres = register_ro_attrs(resource, misc_cap_attrs);\r\nif (res)\r\ngoto error;\r\n}\r\nskip_unsafe_cap:\r\nif (resource->caps.flags & POWER_METER_CAN_TRIP) {\r\nres = register_rw_attrs(resource, trip_attrs);\r\nif (res)\r\ngoto error;\r\n}\r\nres = register_ro_attrs(resource, misc_attrs);\r\nif (res)\r\ngoto error;\r\nreturn res;\r\nerror:\r\nremove_attrs(resource);\r\nreturn res;\r\n}\r\nstatic void free_capabilities(struct acpi_power_meter_resource *resource)\r\n{\r\nacpi_string *str;\r\nint i;\r\nstr = &resource->model_number;\r\nfor (i = 0; i < 3; i++, str++)\r\nkfree(*str);\r\n}\r\nstatic int read_capabilities(struct acpi_power_meter_resource *resource)\r\n{\r\nint res = 0;\r\nint i;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer state = { 0, NULL };\r\nstruct acpi_buffer format = { sizeof("NNNNNNNNNNN"), "NNNNNNNNNNN" };\r\nunion acpi_object *pss;\r\nacpi_string *str;\r\nacpi_status status;\r\nstatus = acpi_evaluate_object(resource->acpi_dev->handle, "_PMC", NULL,\r\n&buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PMC"));\r\nreturn -ENODEV;\r\n}\r\npss = buffer.pointer;\r\nif (!pss ||\r\npss->type != ACPI_TYPE_PACKAGE ||\r\npss->package.count != 14) {\r\ndev_err(&resource->acpi_dev->dev, ACPI_POWER_METER_NAME\r\n"Invalid _PMC data\n");\r\nres = -EFAULT;\r\ngoto end;\r\n}\r\nstate.length = sizeof(struct acpi_power_meter_capabilities);\r\nstate.pointer = &resource->caps;\r\nstatus = acpi_extract_package(pss, &format, &state);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Invalid data"));\r\nres = -EFAULT;\r\ngoto end;\r\n}\r\nif (resource->caps.units) {\r\ndev_err(&resource->acpi_dev->dev, ACPI_POWER_METER_NAME\r\n"Unknown units %llu.\n",\r\nresource->caps.units);\r\nres = -EINVAL;\r\ngoto end;\r\n}\r\nstr = &resource->model_number;\r\nfor (i = 11; i < 14; i++) {\r\nunion acpi_object *element = &(pss->package.elements[i]);\r\nif (element->type != ACPI_TYPE_STRING) {\r\nres = -EINVAL;\r\ngoto error;\r\n}\r\n*str = kzalloc(sizeof(u8) * (element->string.length + 1),\r\nGFP_KERNEL);\r\nif (!*str) {\r\nres = -ENOMEM;\r\ngoto error;\r\n}\r\nstrncpy(*str, element->string.pointer, element->string.length);\r\nstr++;\r\n}\r\ndev_info(&resource->acpi_dev->dev, "Found ACPI power meter.\n");\r\ngoto end;\r\nerror:\r\nstr = &resource->model_number;\r\nfor (i = 0; i < 3; i++, str++)\r\nkfree(*str);\r\nend:\r\nkfree(buffer.pointer);\r\nreturn res;\r\n}\r\nstatic void acpi_power_meter_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_power_meter_resource *resource;\r\nint res;\r\nif (!device || !acpi_driver_data(device))\r\nreturn;\r\nresource = acpi_driver_data(device);\r\nmutex_lock(&resource->lock);\r\nswitch (event) {\r\ncase METER_NOTIFY_CONFIG:\r\nfree_capabilities(resource);\r\nres = read_capabilities(resource);\r\nif (res)\r\nbreak;\r\nremove_attrs(resource);\r\nsetup_attrs(resource);\r\nbreak;\r\ncase METER_NOTIFY_TRIP:\r\nsysfs_notify(&device->dev.kobj, NULL, POWER_AVERAGE_NAME);\r\nupdate_meter(resource);\r\nbreak;\r\ncase METER_NOTIFY_CAP:\r\nsysfs_notify(&device->dev.kobj, NULL, POWER_CAP_NAME);\r\nupdate_cap(resource);\r\nbreak;\r\ncase METER_NOTIFY_INTERVAL:\r\nsysfs_notify(&device->dev.kobj, NULL, POWER_AVG_INTERVAL_NAME);\r\nupdate_avg_interval(resource);\r\nbreak;\r\ncase METER_NOTIFY_CAPPING:\r\nsysfs_notify(&device->dev.kobj, NULL, POWER_ALARM_NAME);\r\ndev_info(&device->dev, "Capping in progress.\n");\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmutex_unlock(&resource->lock);\r\nacpi_bus_generate_netlink_event(ACPI_POWER_METER_CLASS,\r\ndev_name(&device->dev), event, 0);\r\n}\r\nstatic int acpi_power_meter_add(struct acpi_device *device)\r\n{\r\nint res;\r\nstruct acpi_power_meter_resource *resource;\r\nif (!device)\r\nreturn -EINVAL;\r\nresource = kzalloc(sizeof(struct acpi_power_meter_resource),\r\nGFP_KERNEL);\r\nif (!resource)\r\nreturn -ENOMEM;\r\nresource->sensors_valid = 0;\r\nresource->acpi_dev = device;\r\nmutex_init(&resource->lock);\r\nstrcpy(acpi_device_name(device), ACPI_POWER_METER_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_POWER_METER_CLASS);\r\ndevice->driver_data = resource;\r\nfree_capabilities(resource);\r\nres = read_capabilities(resource);\r\nif (res)\r\ngoto exit_free;\r\nresource->trip[0] = resource->trip[1] = -1;\r\nres = setup_attrs(resource);\r\nif (res)\r\ngoto exit_free;\r\nresource->hwmon_dev = hwmon_device_register(&device->dev);\r\nif (IS_ERR(resource->hwmon_dev)) {\r\nres = PTR_ERR(resource->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nres = 0;\r\ngoto exit;\r\nexit_remove:\r\nremove_attrs(resource);\r\nexit_free:\r\nkfree(resource);\r\nexit:\r\nreturn res;\r\n}\r\nstatic int acpi_power_meter_remove(struct acpi_device *device, int type)\r\n{\r\nstruct acpi_power_meter_resource *resource;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nresource = acpi_driver_data(device);\r\nhwmon_device_unregister(resource->hwmon_dev);\r\nfree_capabilities(resource);\r\nremove_attrs(resource);\r\nkfree(resource);\r\nreturn 0;\r\n}\r\nstatic int acpi_power_meter_resume(struct acpi_device *device)\r\n{\r\nstruct acpi_power_meter_resource *resource;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nresource = acpi_driver_data(device);\r\nfree_capabilities(resource);\r\nread_capabilities(resource);\r\nreturn 0;\r\n}\r\nstatic int __init enable_cap_knobs(const struct dmi_system_id *d)\r\n{\r\ncap_in_hardware = 1;\r\nreturn 0;\r\n}\r\nstatic int __init acpi_power_meter_init(void)\r\n{\r\nint result;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\ndmi_check_system(pm_dmi_table);\r\nresult = acpi_bus_register_driver(&acpi_power_meter_driver);\r\nif (result < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __exit acpi_power_meter_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_power_meter_driver);\r\n}
