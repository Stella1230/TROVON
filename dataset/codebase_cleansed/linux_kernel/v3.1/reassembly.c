int ip6_frag_nqueues(struct net *net)\r\n{\r\nreturn net->ipv6.frags.nqueues;\r\n}\r\nint ip6_frag_mem(struct net *net)\r\n{\r\nreturn atomic_read(&net->ipv6.frags.mem);\r\n}\r\nunsigned int inet6_hash_frag(__be32 id, const struct in6_addr *saddr,\r\nconst struct in6_addr *daddr, u32 rnd)\r\n{\r\nu32 c;\r\nc = jhash_3words((__force u32)saddr->s6_addr32[0],\r\n(__force u32)saddr->s6_addr32[1],\r\n(__force u32)saddr->s6_addr32[2],\r\nrnd);\r\nc = jhash_3words((__force u32)saddr->s6_addr32[3],\r\n(__force u32)daddr->s6_addr32[0],\r\n(__force u32)daddr->s6_addr32[1],\r\nc);\r\nc = jhash_3words((__force u32)daddr->s6_addr32[2],\r\n(__force u32)daddr->s6_addr32[3],\r\n(__force u32)id,\r\nc);\r\nreturn c & (INETFRAGS_HASHSZ - 1);\r\n}\r\nstatic unsigned int ip6_hashfn(struct inet_frag_queue *q)\r\n{\r\nstruct frag_queue *fq;\r\nfq = container_of(q, struct frag_queue, q);\r\nreturn inet6_hash_frag(fq->id, &fq->saddr, &fq->daddr, ip6_frags.rnd);\r\n}\r\nint ip6_frag_match(struct inet_frag_queue *q, void *a)\r\n{\r\nstruct frag_queue *fq;\r\nstruct ip6_create_arg *arg = a;\r\nfq = container_of(q, struct frag_queue, q);\r\nreturn (fq->id == arg->id && fq->user == arg->user &&\r\nipv6_addr_equal(&fq->saddr, arg->src) &&\r\nipv6_addr_equal(&fq->daddr, arg->dst));\r\n}\r\nvoid ip6_frag_init(struct inet_frag_queue *q, void *a)\r\n{\r\nstruct frag_queue *fq = container_of(q, struct frag_queue, q);\r\nstruct ip6_create_arg *arg = a;\r\nfq->id = arg->id;\r\nfq->user = arg->user;\r\nipv6_addr_copy(&fq->saddr, arg->src);\r\nipv6_addr_copy(&fq->daddr, arg->dst);\r\n}\r\nstatic __inline__ void fq_put(struct frag_queue *fq)\r\n{\r\ninet_frag_put(&fq->q, &ip6_frags);\r\n}\r\nstatic __inline__ void fq_kill(struct frag_queue *fq)\r\n{\r\ninet_frag_kill(&fq->q, &ip6_frags);\r\n}\r\nstatic void ip6_evictor(struct net *net, struct inet6_dev *idev)\r\n{\r\nint evicted;\r\nevicted = inet_frag_evictor(&net->ipv6.frags, &ip6_frags);\r\nif (evicted)\r\nIP6_ADD_STATS_BH(net, idev, IPSTATS_MIB_REASMFAILS, evicted);\r\n}\r\nstatic void ip6_frag_expire(unsigned long data)\r\n{\r\nstruct frag_queue *fq;\r\nstruct net_device *dev = NULL;\r\nstruct net *net;\r\nfq = container_of((struct inet_frag_queue *)data, struct frag_queue, q);\r\nspin_lock(&fq->q.lock);\r\nif (fq->q.last_in & INET_FRAG_COMPLETE)\r\ngoto out;\r\nfq_kill(fq);\r\nnet = container_of(fq->q.net, struct net, ipv6.frags);\r\nrcu_read_lock();\r\ndev = dev_get_by_index_rcu(net, fq->iif);\r\nif (!dev)\r\ngoto out_rcu_unlock;\r\nIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMTIMEOUT);\r\nIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\r\nif (!(fq->q.last_in & INET_FRAG_FIRST_IN) || !fq->q.fragments)\r\ngoto out_rcu_unlock;\r\nfq->q.fragments->dev = dev;\r\nicmpv6_send(fq->q.fragments, ICMPV6_TIME_EXCEED, ICMPV6_EXC_FRAGTIME, 0);\r\nout_rcu_unlock:\r\nrcu_read_unlock();\r\nout:\r\nspin_unlock(&fq->q.lock);\r\nfq_put(fq);\r\n}\r\nint ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\r\nstruct frag_hdr *fhdr, int nhoff)\r\n{\r\nstruct sk_buff *prev, *next;\r\nstruct net_device *dev;\r\nint offset, end;\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nif (fq->q.last_in & INET_FRAG_COMPLETE)\r\ngoto err;\r\noffset = ntohs(fhdr->frag_off) & ~0x7;\r\nend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\r\n((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\r\nif ((unsigned int)end > IPV6_MAXPLEN) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\r\n((u8 *)&fhdr->frag_off -\r\nskb_network_header(skb)));\r\nreturn -1;\r\n}\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\nconst unsigned char *nh = skb_network_header(skb);\r\nskb->csum = csum_sub(skb->csum,\r\ncsum_partial(nh, (u8 *)(fhdr + 1) - nh,\r\n0));\r\n}\r\nif (!(fhdr->frag_off & htons(IP6_MF))) {\r\nif (end < fq->q.len ||\r\n((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len))\r\ngoto err;\r\nfq->q.last_in |= INET_FRAG_LAST_IN;\r\nfq->q.len = end;\r\n} else {\r\nif (end & 0x7) {\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\r\noffsetof(struct ipv6hdr, payload_len));\r\nreturn -1;\r\n}\r\nif (end > fq->q.len) {\r\nif (fq->q.last_in & INET_FRAG_LAST_IN)\r\ngoto err;\r\nfq->q.len = end;\r\n}\r\n}\r\nif (end == offset)\r\ngoto err;\r\nif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\r\ngoto err;\r\nif (pskb_trim_rcsum(skb, end - offset))\r\ngoto err;\r\nprev = fq->q.fragments_tail;\r\nif (!prev || FRAG6_CB(prev)->offset < offset) {\r\nnext = NULL;\r\ngoto found;\r\n}\r\nprev = NULL;\r\nfor(next = fq->q.fragments; next != NULL; next = next->next) {\r\nif (FRAG6_CB(next)->offset >= offset)\r\nbreak;\r\nprev = next;\r\n}\r\nfound:\r\nif (prev &&\r\n(FRAG6_CB(prev)->offset + prev->len) > offset)\r\ngoto discard_fq;\r\nif (next && FRAG6_CB(next)->offset < end)\r\ngoto discard_fq;\r\nFRAG6_CB(skb)->offset = offset;\r\nskb->next = next;\r\nif (!next)\r\nfq->q.fragments_tail = skb;\r\nif (prev)\r\nprev->next = skb;\r\nelse\r\nfq->q.fragments = skb;\r\ndev = skb->dev;\r\nif (dev) {\r\nfq->iif = dev->ifindex;\r\nskb->dev = NULL;\r\n}\r\nfq->q.stamp = skb->tstamp;\r\nfq->q.meat += skb->len;\r\natomic_add(skb->truesize, &fq->q.net->mem);\r\nif (offset == 0) {\r\nfq->nhoffset = nhoff;\r\nfq->q.last_in |= INET_FRAG_FIRST_IN;\r\n}\r\nif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\r\nfq->q.meat == fq->q.len)\r\nreturn ip6_frag_reasm(fq, prev, dev);\r\nwrite_lock(&ip6_frags.lock);\r\nlist_move_tail(&fq->q.lru_list, &fq->q.net->lru_list);\r\nwrite_unlock(&ip6_frags.lock);\r\nreturn -1;\r\ndiscard_fq:\r\nfq_kill(fq);\r\nerr:\r\nIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_REASMFAILS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nstatic int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,\r\nstruct net_device *dev)\r\n{\r\nstruct net *net = container_of(fq->q.net, struct net, ipv6.frags);\r\nstruct sk_buff *fp, *head = fq->q.fragments;\r\nint payload_len;\r\nunsigned int nhoff;\r\nfq_kill(fq);\r\nif (prev) {\r\nhead = prev->next;\r\nfp = skb_clone(head, GFP_ATOMIC);\r\nif (!fp)\r\ngoto out_oom;\r\nfp->next = head->next;\r\nif (!fp->next)\r\nfq->q.fragments_tail = fp;\r\nprev->next = fp;\r\nskb_morph(head, fq->q.fragments);\r\nhead->next = fq->q.fragments->next;\r\nkfree_skb(fq->q.fragments);\r\nfq->q.fragments = head;\r\n}\r\nWARN_ON(head == NULL);\r\nWARN_ON(FRAG6_CB(head)->offset != 0);\r\npayload_len = ((head->data - skb_network_header(head)) -\r\nsizeof(struct ipv6hdr) + fq->q.len -\r\nsizeof(struct frag_hdr));\r\nif (payload_len > IPV6_MAXPLEN)\r\ngoto out_oversize;\r\nif (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC))\r\ngoto out_oom;\r\nif (skb_has_frag_list(head)) {\r\nstruct sk_buff *clone;\r\nint i, plen = 0;\r\nif ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL)\r\ngoto out_oom;\r\nclone->next = head->next;\r\nhead->next = clone;\r\nskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\r\nskb_frag_list_init(head);\r\nfor (i=0; i<skb_shinfo(head)->nr_frags; i++)\r\nplen += skb_shinfo(head)->frags[i].size;\r\nclone->len = clone->data_len = head->data_len - plen;\r\nhead->data_len -= clone->len;\r\nhead->len -= clone->len;\r\nclone->csum = 0;\r\nclone->ip_summed = head->ip_summed;\r\natomic_add(clone->truesize, &fq->q.net->mem);\r\n}\r\nnhoff = fq->nhoffset;\r\nskb_network_header(head)[nhoff] = skb_transport_header(head)[0];\r\nmemmove(head->head + sizeof(struct frag_hdr), head->head,\r\n(head->data - head->head) - sizeof(struct frag_hdr));\r\nhead->mac_header += sizeof(struct frag_hdr);\r\nhead->network_header += sizeof(struct frag_hdr);\r\nskb_shinfo(head)->frag_list = head->next;\r\nskb_reset_transport_header(head);\r\nskb_push(head, head->data - skb_network_header(head));\r\nfor (fp=head->next; fp; fp = fp->next) {\r\nhead->data_len += fp->len;\r\nhead->len += fp->len;\r\nif (head->ip_summed != fp->ip_summed)\r\nhead->ip_summed = CHECKSUM_NONE;\r\nelse if (head->ip_summed == CHECKSUM_COMPLETE)\r\nhead->csum = csum_add(head->csum, fp->csum);\r\nhead->truesize += fp->truesize;\r\n}\r\natomic_sub(head->truesize, &fq->q.net->mem);\r\nhead->next = NULL;\r\nhead->dev = dev;\r\nhead->tstamp = fq->q.stamp;\r\nipv6_hdr(head)->payload_len = htons(payload_len);\r\nIP6CB(head)->nhoff = nhoff;\r\nif (head->ip_summed == CHECKSUM_COMPLETE)\r\nhead->csum = csum_partial(skb_network_header(head),\r\nskb_network_header_len(head),\r\nhead->csum);\r\nrcu_read_lock();\r\nIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMOKS);\r\nrcu_read_unlock();\r\nfq->q.fragments = NULL;\r\nfq->q.fragments_tail = NULL;\r\nreturn 1;\r\nout_oversize:\r\nif (net_ratelimit())\r\nprintk(KERN_DEBUG "ip6_frag_reasm: payload len = %d\n", payload_len);\r\ngoto out_fail;\r\nout_oom:\r\nif (net_ratelimit())\r\nprintk(KERN_DEBUG "ip6_frag_reasm: no memory for reassembly\n");\r\nout_fail:\r\nrcu_read_lock();\r\nIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\r\nrcu_read_unlock();\r\nreturn -1;\r\n}\r\nstatic int ipv6_frag_rcv(struct sk_buff *skb)\r\n{\r\nstruct frag_hdr *fhdr;\r\nstruct frag_queue *fq;\r\nconst struct ipv6hdr *hdr = ipv6_hdr(skb);\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMREQDS);\r\nif (hdr->payload_len==0)\r\ngoto fail_hdr;\r\nif (!pskb_may_pull(skb, (skb_transport_offset(skb) +\r\nsizeof(struct frag_hdr))))\r\ngoto fail_hdr;\r\nhdr = ipv6_hdr(skb);\r\nfhdr = (struct frag_hdr *)skb_transport_header(skb);\r\nif (!(fhdr->frag_off & htons(0xFFF9))) {\r\nskb->transport_header += sizeof(struct frag_hdr);\r\nIP6_INC_STATS_BH(net,\r\nip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMOKS);\r\nIP6CB(skb)->nhoff = (u8 *)fhdr - skb_network_header(skb);\r\nreturn 1;\r\n}\r\nif (atomic_read(&net->ipv6.frags.mem) > net->ipv6.frags.high_thresh)\r\nip6_evictor(net, ip6_dst_idev(skb_dst(skb)));\r\nfq = fq_find(net, fhdr->identification, &hdr->saddr, &hdr->daddr);\r\nif (fq != NULL) {\r\nint ret;\r\nspin_lock(&fq->q.lock);\r\nret = ip6_frag_queue(fq, skb, fhdr, IP6CB(skb)->nhoff);\r\nspin_unlock(&fq->q.lock);\r\nfq_put(fq);\r\nreturn ret;\r\n}\r\nIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMFAILS);\r\nkfree_skb(skb);\r\nreturn -1;\r\nfail_hdr:\r\nIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));\r\nreturn -1;\r\n}\r\nstatic int __net_init ip6_frags_ns_sysctl_register(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nstruct ctl_table_header *hdr;\r\ntable = ip6_frags_ns_ctl_table;\r\nif (!net_eq(net, &init_net)) {\r\ntable = kmemdup(table, sizeof(ip6_frags_ns_ctl_table), GFP_KERNEL);\r\nif (table == NULL)\r\ngoto err_alloc;\r\ntable[0].data = &net->ipv6.frags.high_thresh;\r\ntable[1].data = &net->ipv6.frags.low_thresh;\r\ntable[2].data = &net->ipv6.frags.timeout;\r\n}\r\nhdr = register_net_sysctl_table(net, net_ipv6_ctl_path, table);\r\nif (hdr == NULL)\r\ngoto err_reg;\r\nnet->ipv6.sysctl.frags_hdr = hdr;\r\nreturn 0;\r\nerr_reg:\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\nerr_alloc:\r\nreturn -ENOMEM;\r\n}\r\nstatic void __net_exit ip6_frags_ns_sysctl_unregister(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = net->ipv6.sysctl.frags_hdr->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ipv6.sysctl.frags_hdr);\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\n}\r\nstatic int ip6_frags_sysctl_register(void)\r\n{\r\nip6_ctl_header = register_net_sysctl_rotable(net_ipv6_ctl_path,\r\nip6_frags_ctl_table);\r\nreturn ip6_ctl_header == NULL ? -ENOMEM : 0;\r\n}\r\nstatic void ip6_frags_sysctl_unregister(void)\r\n{\r\nunregister_net_sysctl_table(ip6_ctl_header);\r\n}\r\nstatic inline int ip6_frags_ns_sysctl_register(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void ip6_frags_ns_sysctl_unregister(struct net *net)\r\n{\r\n}\r\nstatic inline int ip6_frags_sysctl_register(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void ip6_frags_sysctl_unregister(void)\r\n{\r\n}\r\nstatic int __net_init ipv6_frags_init_net(struct net *net)\r\n{\r\nnet->ipv6.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\r\nnet->ipv6.frags.low_thresh = IPV6_FRAG_LOW_THRESH;\r\nnet->ipv6.frags.timeout = IPV6_FRAG_TIMEOUT;\r\ninet_frags_init_net(&net->ipv6.frags);\r\nreturn ip6_frags_ns_sysctl_register(net);\r\n}\r\nstatic void __net_exit ipv6_frags_exit_net(struct net *net)\r\n{\r\nip6_frags_ns_sysctl_unregister(net);\r\ninet_frags_exit_net(&net->ipv6.frags, &ip6_frags);\r\n}\r\nint __init ipv6_frag_init(void)\r\n{\r\nint ret;\r\nret = inet6_add_protocol(&frag_protocol, IPPROTO_FRAGMENT);\r\nif (ret)\r\ngoto out;\r\nret = ip6_frags_sysctl_register();\r\nif (ret)\r\ngoto err_sysctl;\r\nret = register_pernet_subsys(&ip6_frags_ops);\r\nif (ret)\r\ngoto err_pernet;\r\nip6_frags.hashfn = ip6_hashfn;\r\nip6_frags.constructor = ip6_frag_init;\r\nip6_frags.destructor = NULL;\r\nip6_frags.skb_free = NULL;\r\nip6_frags.qsize = sizeof(struct frag_queue);\r\nip6_frags.match = ip6_frag_match;\r\nip6_frags.frag_expire = ip6_frag_expire;\r\nip6_frags.secret_interval = 10 * 60 * HZ;\r\ninet_frags_init(&ip6_frags);\r\nout:\r\nreturn ret;\r\nerr_pernet:\r\nip6_frags_sysctl_unregister();\r\nerr_sysctl:\r\ninet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\r\ngoto out;\r\n}\r\nvoid ipv6_frag_exit(void)\r\n{\r\ninet_frags_fini(&ip6_frags);\r\nip6_frags_sysctl_unregister();\r\nunregister_pernet_subsys(&ip6_frags_ops);\r\ninet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\r\n}
