static inline unsigned long\r\nswap_ulong(volatile unsigned long *ptr, unsigned long val)\r\n{\r\n__asm__ __volatile__("swap [%1], %0\n\t" :\r\n"=&r" (val), "=&r" (ptr) :\r\n"0" (val), "1" (ptr));\r\nreturn val;\r\n}\r\nvoid __cpuinit smp4m_callin(void)\r\n{\r\nint cpuid = hard_smp_processor_id();\r\nlocal_flush_cache_all();\r\nlocal_flush_tlb_all();\r\nnotify_cpu_starting(cpuid);\r\nsmp_setup_percpu_timer();\r\ncalibrate_delay();\r\nsmp_store_cpu_info(cpuid);\r\nlocal_flush_cache_all();\r\nlocal_flush_tlb_all();\r\nswap_ulong(&cpu_callin_map[cpuid], 1);\r\nlocal_flush_cache_all();\r\nlocal_flush_tlb_all();\r\n__asm__ __volatile__("ld [%0], %%g6\n\t"\r\n: : "r" (&current_set[cpuid])\r\n: "memory" );\r\natomic_inc(&init_mm.mm_count);\r\ncurrent->active_mm = &init_mm;\r\nwhile (!cpumask_test_cpu(cpuid, &smp_commenced_mask))\r\nmb();\r\nlocal_irq_enable();\r\nset_cpu_online(cpuid, true);\r\n}\r\nvoid __init smp4m_boot_cpus(void)\r\n{\r\nsmp4m_ipi_init();\r\nsmp_setup_percpu_timer();\r\nlocal_flush_cache_all();\r\n}\r\nint __cpuinit smp4m_boot_one_cpu(int i)\r\n{\r\nunsigned long *entry = &sun4m_cpu_startup;\r\nstruct task_struct *p;\r\nint timeout;\r\nint cpu_node;\r\ncpu_find_by_mid(i, &cpu_node);\r\np = fork_idle(i);\r\ncurrent_set[i] = task_thread_info(p);\r\nentry += ((i - 1) * 3);\r\nsmp_penguin_ctable.which_io = 0;\r\nsmp_penguin_ctable.phys_addr = (unsigned int) srmmu_ctx_table_phys;\r\nsmp_penguin_ctable.reg_size = 0;\r\nprintk(KERN_INFO "Starting CPU %d at %p\n", i, entry);\r\nlocal_flush_cache_all();\r\nprom_startcpu(cpu_node, &smp_penguin_ctable, 0, (char *)entry);\r\nfor (timeout = 0; timeout < 10000; timeout++) {\r\nif (cpu_callin_map[i])\r\nbreak;\r\nudelay(200);\r\n}\r\nif (!(cpu_callin_map[i])) {\r\nprintk(KERN_ERR "Processor %d is stuck.\n", i);\r\nreturn -ENODEV;\r\n}\r\nlocal_flush_cache_all();\r\nreturn 0;\r\n}\r\nvoid __init smp4m_smp_done(void)\r\n{\r\nint i, first;\r\nint *prev;\r\nfirst = 0;\r\nprev = &first;\r\nfor_each_online_cpu(i) {\r\n*prev = i;\r\nprev = &cpu_data(i).next;\r\n}\r\n*prev = first;\r\nlocal_flush_cache_all();\r\n}\r\nstatic void __init smp4m_ipi_init(void)\r\n{\r\n}\r\nstatic void smp4m_ipi_resched(int cpu)\r\n{\r\nset_cpu_int(cpu, IRQ_IPI_RESCHED);\r\n}\r\nstatic void smp4m_ipi_single(int cpu)\r\n{\r\nset_cpu_int(cpu, IRQ_IPI_SINGLE);\r\n}\r\nstatic void smp4m_ipi_mask_one(int cpu)\r\n{\r\nset_cpu_int(cpu, IRQ_IPI_MASK);\r\n}\r\nstatic void smp4m_cross_call(smpfunc_t func, cpumask_t mask, unsigned long arg1,\r\nunsigned long arg2, unsigned long arg3,\r\nunsigned long arg4)\r\n{\r\nregister int ncpus = SUN4M_NCPUS;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cross_call_lock, flags);\r\nccall_info.func = func;\r\nccall_info.arg1 = arg1;\r\nccall_info.arg2 = arg2;\r\nccall_info.arg3 = arg3;\r\nccall_info.arg4 = arg4;\r\nccall_info.arg5 = 0;\r\n{\r\nregister int i;\r\ncpumask_clear_cpu(smp_processor_id(), &mask);\r\ncpumask_and(&mask, cpu_online_mask, &mask);\r\nfor (i = 0; i < ncpus; i++) {\r\nif (cpumask_test_cpu(i, &mask)) {\r\nccall_info.processors_in[i] = 0;\r\nccall_info.processors_out[i] = 0;\r\nset_cpu_int(i, IRQ_CROSS_CALL);\r\n} else {\r\nccall_info.processors_in[i] = 1;\r\nccall_info.processors_out[i] = 1;\r\n}\r\n}\r\n}\r\n{\r\nregister int i;\r\ni = 0;\r\ndo {\r\nif (!cpumask_test_cpu(i, &mask))\r\ncontinue;\r\nwhile (!ccall_info.processors_in[i])\r\nbarrier();\r\n} while (++i < ncpus);\r\ni = 0;\r\ndo {\r\nif (!cpumask_test_cpu(i, &mask))\r\ncontinue;\r\nwhile (!ccall_info.processors_out[i])\r\nbarrier();\r\n} while (++i < ncpus);\r\n}\r\nspin_unlock_irqrestore(&cross_call_lock, flags);\r\n}\r\nvoid smp4m_cross_call_irq(void)\r\n{\r\nint i = smp_processor_id();\r\nccall_info.processors_in[i] = 1;\r\nccall_info.func(ccall_info.arg1, ccall_info.arg2, ccall_info.arg3,\r\nccall_info.arg4, ccall_info.arg5);\r\nccall_info.processors_out[i] = 1;\r\n}\r\nvoid smp4m_percpu_timer_interrupt(struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs;\r\nint cpu = smp_processor_id();\r\nold_regs = set_irq_regs(regs);\r\nsun4m_clear_profile_irq(cpu);\r\nprofile_tick(CPU_PROFILING);\r\nif (!--prof_counter(cpu)) {\r\nint user = user_mode(regs);\r\nirq_enter();\r\nupdate_process_times(user);\r\nirq_exit();\r\nprof_counter(cpu) = prof_multiplier(cpu);\r\n}\r\nset_irq_regs(old_regs);\r\n}\r\nstatic void __cpuinit smp_setup_percpu_timer(void)\r\n{\r\nint cpu = smp_processor_id();\r\nprof_counter(cpu) = prof_multiplier(cpu) = 1;\r\nload_profile_irq(cpu, lvl14_resolution);\r\nif (cpu == boot_cpu_id)\r\nsun4m_unmask_profile_irq();\r\n}\r\nstatic void __init smp4m_blackbox_id(unsigned *addr)\r\n{\r\nint rd = *addr & 0x3e000000;\r\nint rs1 = rd >> 11;\r\naddr[0] = 0x81580000 | rd;\r\naddr[1] = 0x8130200c | rd | rs1;\r\naddr[2] = 0x80082003 | rd | rs1;\r\n}\r\nstatic void __init smp4m_blackbox_current(unsigned *addr)\r\n{\r\nint rd = *addr & 0x3e000000;\r\nint rs1 = rd >> 11;\r\naddr[0] = 0x81580000 | rd;\r\naddr[2] = 0x8130200a | rd | rs1;\r\naddr[4] = 0x8008200c | rd | rs1;\r\n}\r\nvoid __init sun4m_init_smp(void)\r\n{\r\nBTFIXUPSET_BLACKBOX(hard_smp_processor_id, smp4m_blackbox_id);\r\nBTFIXUPSET_BLACKBOX(load_current, smp4m_blackbox_current);\r\nBTFIXUPSET_CALL(smp_cross_call, smp4m_cross_call, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(__hard_smp_processor_id, __smp4m_processor_id, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(smp_ipi_resched, smp4m_ipi_resched, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(smp_ipi_single, smp4m_ipi_single, BTFIXUPCALL_NORM);\r\nBTFIXUPSET_CALL(smp_ipi_mask_one, smp4m_ipi_mask_one, BTFIXUPCALL_NORM);\r\n}
