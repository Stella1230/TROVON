static inline int tcp_probe_used(void)\r\n{\r\nreturn (tcp_probe.head - tcp_probe.tail) & (bufsize - 1);\r\n}\r\nstatic inline int tcp_probe_avail(void)\r\n{\r\nreturn bufsize - tcp_probe_used() - 1;\r\n}\r\nstatic int jtcp_rcv_established(struct sock *sk, struct sk_buff *skb,\r\nstruct tcphdr *th, unsigned len)\r\n{\r\nconst struct tcp_sock *tp = tcp_sk(sk);\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nif ((port == 0 || ntohs(inet->inet_dport) == port ||\r\nntohs(inet->inet_sport) == port) &&\r\n(full || tp->snd_cwnd != tcp_probe.lastcwnd)) {\r\nspin_lock(&tcp_probe.lock);\r\nif (tcp_probe_avail() > 1) {\r\nstruct tcp_log *p = tcp_probe.log + tcp_probe.head;\r\np->tstamp = ktime_get();\r\np->saddr = inet->inet_saddr;\r\np->sport = inet->inet_sport;\r\np->daddr = inet->inet_daddr;\r\np->dport = inet->inet_dport;\r\np->length = skb->len;\r\np->snd_nxt = tp->snd_nxt;\r\np->snd_una = tp->snd_una;\r\np->snd_cwnd = tp->snd_cwnd;\r\np->snd_wnd = tp->snd_wnd;\r\np->ssthresh = tcp_current_ssthresh(sk);\r\np->srtt = tp->srtt >> 3;\r\ntcp_probe.head = (tcp_probe.head + 1) & (bufsize - 1);\r\n}\r\ntcp_probe.lastcwnd = tp->snd_cwnd;\r\nspin_unlock(&tcp_probe.lock);\r\nwake_up(&tcp_probe.wait);\r\n}\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int tcpprobe_open(struct inode * inode, struct file * file)\r\n{\r\nspin_lock_bh(&tcp_probe.lock);\r\ntcp_probe.head = tcp_probe.tail = 0;\r\ntcp_probe.start = ktime_get();\r\nspin_unlock_bh(&tcp_probe.lock);\r\nreturn 0;\r\n}\r\nstatic int tcpprobe_sprint(char *tbuf, int n)\r\n{\r\nconst struct tcp_log *p\r\n= tcp_probe.log + tcp_probe.tail;\r\nstruct timespec tv\r\n= ktime_to_timespec(ktime_sub(p->tstamp, tcp_probe.start));\r\nreturn scnprintf(tbuf, n,\r\n"%lu.%09lu %pI4:%u %pI4:%u %d %#x %#x %u %u %u %u\n",\r\n(unsigned long) tv.tv_sec,\r\n(unsigned long) tv.tv_nsec,\r\n&p->saddr, ntohs(p->sport),\r\n&p->daddr, ntohs(p->dport),\r\np->length, p->snd_nxt, p->snd_una,\r\np->snd_cwnd, p->ssthresh, p->snd_wnd, p->srtt);\r\n}\r\nstatic ssize_t tcpprobe_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nint error = 0;\r\nsize_t cnt = 0;\r\nif (!buf)\r\nreturn -EINVAL;\r\nwhile (cnt < len) {\r\nchar tbuf[164];\r\nint width;\r\nerror = wait_event_interruptible(tcp_probe.wait,\r\ntcp_probe_used() > 0);\r\nif (error)\r\nbreak;\r\nspin_lock_bh(&tcp_probe.lock);\r\nif (tcp_probe.head == tcp_probe.tail) {\r\nspin_unlock_bh(&tcp_probe.lock);\r\ncontinue;\r\n}\r\nwidth = tcpprobe_sprint(tbuf, sizeof(tbuf));\r\nif (cnt + width < len)\r\ntcp_probe.tail = (tcp_probe.tail + 1) & (bufsize - 1);\r\nspin_unlock_bh(&tcp_probe.lock);\r\nif (cnt + width >= len)\r\nbreak;\r\nif (copy_to_user(buf + cnt, tbuf, width))\r\nreturn -EFAULT;\r\ncnt += width;\r\n}\r\nreturn cnt == 0 ? error : cnt;\r\n}\r\nstatic __init int tcpprobe_init(void)\r\n{\r\nint ret = -ENOMEM;\r\ninit_waitqueue_head(&tcp_probe.wait);\r\nspin_lock_init(&tcp_probe.lock);\r\nif (bufsize == 0)\r\nreturn -EINVAL;\r\nbufsize = roundup_pow_of_two(bufsize);\r\ntcp_probe.log = kcalloc(bufsize, sizeof(struct tcp_log), GFP_KERNEL);\r\nif (!tcp_probe.log)\r\ngoto err0;\r\nif (!proc_net_fops_create(&init_net, procname, S_IRUSR, &tcpprobe_fops))\r\ngoto err0;\r\nret = register_jprobe(&tcp_jprobe);\r\nif (ret)\r\ngoto err1;\r\npr_info("TCP probe registered (port=%d) bufsize=%u\n", port, bufsize);\r\nreturn 0;\r\nerr1:\r\nproc_net_remove(&init_net, procname);\r\nerr0:\r\nkfree(tcp_probe.log);\r\nreturn ret;\r\n}\r\nstatic __exit void tcpprobe_exit(void)\r\n{\r\nproc_net_remove(&init_net, procname);\r\nunregister_jprobe(&tcp_jprobe);\r\nkfree(tcp_probe.log);\r\n}
