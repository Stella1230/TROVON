static void gf_set_gpios(struct async_state *state, unsigned long ofs)\r\n{\r\nsize_t i = 0;\r\nint value;\r\nofs /= state->win_size;\r\ndo {\r\nvalue = ofs & (1 << i);\r\nif (state->gpio_values[i] != value) {\r\ngpio_set_value(state->gpio_addrs[i], value);\r\nstate->gpio_values[i] = value;\r\n}\r\n} while (++i < state->gpio_count);\r\n}\r\nstatic map_word gf_read(struct map_info *map, unsigned long ofs)\r\n{\r\nstruct async_state *state = gf_map_info_to_state(map);\r\nuint16_t word;\r\nmap_word test;\r\ngf_set_gpios(state, ofs);\r\nword = readw(map->virt + (ofs % state->win_size));\r\ntest.x[0] = word;\r\nreturn test;\r\n}\r\nstatic void gf_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)\r\n{\r\nstruct async_state *state = gf_map_info_to_state(map);\r\ngf_set_gpios(state, from);\r\nBUG_ON(!((from + len) % state->win_size <= (from + len)));\r\nmemcpy_fromio(to, map->virt + (from % state->win_size), len);\r\n}\r\nstatic void gf_write(struct map_info *map, map_word d1, unsigned long ofs)\r\n{\r\nstruct async_state *state = gf_map_info_to_state(map);\r\nuint16_t d;\r\ngf_set_gpios(state, ofs);\r\nd = d1.x[0];\r\nwritew(d, map->virt + (ofs % state->win_size));\r\n}\r\nstatic void gf_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)\r\n{\r\nstruct async_state *state = gf_map_info_to_state(map);\r\ngf_set_gpios(state, to);\r\nBUG_ON(!((to + len) % state->win_size <= (to + len)));\r\nmemcpy_toio(map->virt + (to % state->win_size), from, len);\r\n}\r\nstatic int __devinit gpio_flash_probe(struct platform_device *pdev)\r\n{\r\nint nr_parts;\r\nsize_t i, arr_size;\r\nstruct physmap_flash_data *pdata;\r\nstruct resource *memory;\r\nstruct resource *gpios;\r\nstruct async_state *state;\r\npdata = pdev->dev.platform_data;\r\nmemory = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngpios = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!memory || !gpios || !gpios->end)\r\nreturn -EINVAL;\r\narr_size = sizeof(int) * gpios->end;\r\nstate = kzalloc(sizeof(*state) + arr_size, GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nstate->gpio_count = gpios->end;\r\nstate->gpio_addrs = (void *)(unsigned long)gpios->start;\r\nstate->gpio_values = (void *)(state + 1);\r\nstate->win_size = resource_size(memory);\r\nmemset(state->gpio_values, 0xff, arr_size);\r\nstate->map.name = DRIVER_NAME;\r\nstate->map.read = gf_read;\r\nstate->map.copy_from = gf_copy_from;\r\nstate->map.write = gf_write;\r\nstate->map.copy_to = gf_copy_to;\r\nstate->map.bankwidth = pdata->width;\r\nstate->map.size = state->win_size * (1 << state->gpio_count);\r\nstate->map.virt = ioremap_nocache(memory->start, state->map.size);\r\nstate->map.phys = NO_XIP;\r\nstate->map.map_priv_1 = (unsigned long)state;\r\nplatform_set_drvdata(pdev, state);\r\ni = 0;\r\ndo {\r\nif (gpio_request(state->gpio_addrs[i], DRIVER_NAME)) {\r\npr_devinit(KERN_ERR PFX "failed to request gpio %d\n",\r\nstate->gpio_addrs[i]);\r\nwhile (i--)\r\ngpio_free(state->gpio_addrs[i]);\r\nkfree(state);\r\nreturn -EBUSY;\r\n}\r\ngpio_direction_output(state->gpio_addrs[i], 0);\r\n} while (++i < state->gpio_count);\r\npr_devinit(KERN_NOTICE PFX "probing %d-bit flash bus\n",\r\nstate->map.bankwidth * 8);\r\nstate->mtd = do_map_probe(memory->name, &state->map);\r\nif (!state->mtd) {\r\nfor (i = 0; i < state->gpio_count; ++i)\r\ngpio_free(state->gpio_addrs[i]);\r\nkfree(state);\r\nreturn -ENXIO;\r\n}\r\nnr_parts = parse_mtd_partitions(state->mtd, part_probe_types,\r\n&pdata->parts, 0);\r\nif (nr_parts > 0) {\r\npr_devinit(KERN_NOTICE PFX "Using commandline partition definition\n");\r\nkfree(pdata->parts);\r\n} else if (pdata->nr_parts) {\r\npr_devinit(KERN_NOTICE PFX "Using board partition definition\n");\r\nnr_parts = pdata->nr_parts;\r\n} else {\r\npr_devinit(KERN_NOTICE PFX "no partition info available, registering whole flash at once\n");\r\nnr_parts = 0;\r\n}\r\nmtd_device_register(state->mtd, pdata->parts, nr_parts);\r\nreturn 0;\r\n}\r\nstatic int __devexit gpio_flash_remove(struct platform_device *pdev)\r\n{\r\nstruct async_state *state = platform_get_drvdata(pdev);\r\nsize_t i = 0;\r\ndo {\r\ngpio_free(state->gpio_addrs[i]);\r\n} while (++i < state->gpio_count);\r\nmtd_device_unregister(state->mtd);\r\nmap_destroy(state->mtd);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_flash_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_flash_driver);\r\n}\r\nstatic void __exit gpio_flash_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_flash_driver);\r\n}
