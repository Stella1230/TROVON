static inline const char *basename(const char *path)\r\n{\r\nconst char *tail = strrchr(path, '/');\r\nreturn tail ? tail+1 : path;\r\n}\r\nstatic char *ddebug_describe_flags(struct _ddebug *dp, char *buf,\r\nsize_t maxlen)\r\n{\r\nchar *p = buf;\r\nint i;\r\nBUG_ON(maxlen < 4);\r\nfor (i = 0; i < ARRAY_SIZE(opt_array); ++i)\r\nif (dp->flags & opt_array[i].flag)\r\n*p++ = opt_array[i].opt_char;\r\nif (p == buf)\r\n*p++ = '-';\r\n*p = '\0';\r\nreturn buf;\r\n}\r\nstatic void ddebug_change(const struct ddebug_query *query,\r\nunsigned int flags, unsigned int mask)\r\n{\r\nint i;\r\nstruct ddebug_table *dt;\r\nunsigned int newflags;\r\nunsigned int nfound = 0;\r\nchar flagbuf[8];\r\nmutex_lock(&ddebug_lock);\r\nlist_for_each_entry(dt, &ddebug_tables, link) {\r\nif (query->module != NULL &&\r\nstrcmp(query->module, dt->mod_name))\r\ncontinue;\r\nfor (i = 0 ; i < dt->num_ddebugs ; i++) {\r\nstruct _ddebug *dp = &dt->ddebugs[i];\r\nif (query->filename != NULL &&\r\nstrcmp(query->filename, dp->filename) &&\r\nstrcmp(query->filename, basename(dp->filename)))\r\ncontinue;\r\nif (query->function != NULL &&\r\nstrcmp(query->function, dp->function))\r\ncontinue;\r\nif (query->format != NULL &&\r\nstrstr(dp->format, query->format) == NULL)\r\ncontinue;\r\nif (query->first_lineno &&\r\ndp->lineno < query->first_lineno)\r\ncontinue;\r\nif (query->last_lineno &&\r\ndp->lineno > query->last_lineno)\r\ncontinue;\r\nnfound++;\r\nnewflags = (dp->flags & mask) | flags;\r\nif (newflags == dp->flags)\r\ncontinue;\r\nif (!newflags)\r\ndt->num_enabled--;\r\nelse if (!dp->flags)\r\ndt->num_enabled++;\r\ndp->flags = newflags;\r\nif (newflags)\r\ndp->enabled = 1;\r\nelse\r\ndp->enabled = 0;\r\nif (verbose)\r\nprintk(KERN_INFO\r\n"ddebug: changed %s:%d [%s]%s %s\n",\r\ndp->filename, dp->lineno,\r\ndt->mod_name, dp->function,\r\nddebug_describe_flags(dp, flagbuf,\r\nsizeof(flagbuf)));\r\n}\r\n}\r\nmutex_unlock(&ddebug_lock);\r\nif (!nfound && verbose)\r\nprintk(KERN_INFO "ddebug: no matches for query\n");\r\n}\r\nstatic int ddebug_tokenize(char *buf, char *words[], int maxwords)\r\n{\r\nint nwords = 0;\r\nwhile (*buf) {\r\nchar *end;\r\nbuf = skip_spaces(buf);\r\nif (!*buf)\r\nbreak;\r\nif (*buf == '"' || *buf == '\'') {\r\nint quote = *buf++;\r\nfor (end = buf ; *end && *end != quote ; end++)\r\n;\r\nif (!*end)\r\nreturn -EINVAL;\r\n} else {\r\nfor (end = buf ; *end && !isspace(*end) ; end++)\r\n;\r\nBUG_ON(end == buf);\r\n}\r\nif (nwords == maxwords)\r\nreturn -EINVAL;\r\nif (*end)\r\n*end++ = '\0';\r\nwords[nwords++] = buf;\r\nbuf = end;\r\n}\r\nif (verbose) {\r\nint i;\r\nprintk(KERN_INFO "%s: split into words:", __func__);\r\nfor (i = 0 ; i < nwords ; i++)\r\nprintk(" \"%s\"", words[i]);\r\nprintk("\n");\r\n}\r\nreturn nwords;\r\n}\r\nstatic inline int parse_lineno(const char *str, unsigned int *val)\r\n{\r\nchar *end = NULL;\r\nBUG_ON(str == NULL);\r\nif (*str == '\0') {\r\n*val = 0;\r\nreturn 0;\r\n}\r\n*val = simple_strtoul(str, &end, 10);\r\nreturn end == NULL || end == str || *end != '\0' ? -EINVAL : 0;\r\n}\r\nstatic char *unescape(char *str)\r\n{\r\nchar *in = str;\r\nchar *out = str;\r\nwhile (*in) {\r\nif (*in == '\\') {\r\nif (in[1] == '\\') {\r\n*out++ = '\\';\r\nin += 2;\r\ncontinue;\r\n} else if (in[1] == 't') {\r\n*out++ = '\t';\r\nin += 2;\r\ncontinue;\r\n} else if (in[1] == 'n') {\r\n*out++ = '\n';\r\nin += 2;\r\ncontinue;\r\n} else if (isodigit(in[1]) &&\r\nisodigit(in[2]) &&\r\nisodigit(in[3])) {\r\n*out++ = ((in[1] - '0')<<6) |\r\n((in[2] - '0')<<3) |\r\n(in[3] - '0');\r\nin += 4;\r\ncontinue;\r\n}\r\n}\r\n*out++ = *in++;\r\n}\r\n*out = '\0';\r\nreturn str;\r\n}\r\nstatic int ddebug_parse_query(char *words[], int nwords,\r\nstruct ddebug_query *query)\r\n{\r\nunsigned int i;\r\nif (nwords % 2 != 0)\r\nreturn -EINVAL;\r\nmemset(query, 0, sizeof(*query));\r\nfor (i = 0 ; i < nwords ; i += 2) {\r\nif (!strcmp(words[i], "func"))\r\nquery->function = words[i+1];\r\nelse if (!strcmp(words[i], "file"))\r\nquery->filename = words[i+1];\r\nelse if (!strcmp(words[i], "module"))\r\nquery->module = words[i+1];\r\nelse if (!strcmp(words[i], "format"))\r\nquery->format = unescape(words[i+1]);\r\nelse if (!strcmp(words[i], "line")) {\r\nchar *first = words[i+1];\r\nchar *last = strchr(first, '-');\r\nif (last)\r\n*last++ = '\0';\r\nif (parse_lineno(first, &query->first_lineno) < 0)\r\nreturn -EINVAL;\r\nif (last != NULL) {\r\nif (parse_lineno(last, &query->last_lineno) < 0)\r\nreturn -EINVAL;\r\n} else {\r\nquery->last_lineno = query->first_lineno;\r\n}\r\n} else {\r\nif (verbose)\r\nprintk(KERN_ERR "%s: unknown keyword \"%s\"\n",\r\n__func__, words[i]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (verbose)\r\nprintk(KERN_INFO "%s: q->function=\"%s\" q->filename=\"%s\" "\r\n"q->module=\"%s\" q->format=\"%s\" q->lineno=%u-%u\n",\r\n__func__, query->function, query->filename,\r\nquery->module, query->format, query->first_lineno,\r\nquery->last_lineno);\r\nreturn 0;\r\n}\r\nstatic int ddebug_parse_flags(const char *str, unsigned int *flagsp,\r\nunsigned int *maskp)\r\n{\r\nunsigned flags = 0;\r\nint op = '=', i;\r\nswitch (*str) {\r\ncase '+':\r\ncase '-':\r\ncase '=':\r\nop = *str++;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (verbose)\r\nprintk(KERN_INFO "%s: op='%c'\n", __func__, op);\r\nfor ( ; *str ; ++str) {\r\nfor (i = ARRAY_SIZE(opt_array) - 1; i >= 0; i--) {\r\nif (*str == opt_array[i].opt_char) {\r\nflags |= opt_array[i].flag;\r\nbreak;\r\n}\r\n}\r\nif (i < 0)\r\nreturn -EINVAL;\r\n}\r\nif (flags == 0)\r\nreturn -EINVAL;\r\nif (verbose)\r\nprintk(KERN_INFO "%s: flags=0x%x\n", __func__, flags);\r\nswitch (op) {\r\ncase '=':\r\n*maskp = 0;\r\n*flagsp = flags;\r\nbreak;\r\ncase '+':\r\n*maskp = ~0U;\r\n*flagsp = flags;\r\nbreak;\r\ncase '-':\r\n*maskp = ~flags;\r\n*flagsp = 0;\r\nbreak;\r\n}\r\nif (verbose)\r\nprintk(KERN_INFO "%s: *flagsp=0x%x *maskp=0x%x\n",\r\n__func__, *flagsp, *maskp);\r\nreturn 0;\r\n}\r\nstatic int ddebug_exec_query(char *query_string)\r\n{\r\nunsigned int flags = 0, mask = 0;\r\nstruct ddebug_query query;\r\n#define MAXWORDS 9\r\nint nwords;\r\nchar *words[MAXWORDS];\r\nnwords = ddebug_tokenize(query_string, words, MAXWORDS);\r\nif (nwords <= 0)\r\nreturn -EINVAL;\r\nif (ddebug_parse_query(words, nwords-1, &query))\r\nreturn -EINVAL;\r\nif (ddebug_parse_flags(words[nwords-1], &flags, &mask))\r\nreturn -EINVAL;\r\nddebug_change(&query, flags, mask);\r\nreturn 0;\r\n}\r\nint __dynamic_pr_debug(struct _ddebug *descriptor, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint res;\r\nBUG_ON(!descriptor);\r\nBUG_ON(!fmt);\r\nva_start(args, fmt);\r\nres = printk(KERN_DEBUG);\r\nif (descriptor->flags & _DPRINTK_FLAGS_INCL_TID) {\r\nif (in_interrupt())\r\nres += printk(KERN_CONT "<intr> ");\r\nelse\r\nres += printk(KERN_CONT "[%d] ", task_pid_vnr(current));\r\n}\r\nif (descriptor->flags & _DPRINTK_FLAGS_INCL_MODNAME)\r\nres += printk(KERN_CONT "%s:", descriptor->modname);\r\nif (descriptor->flags & _DPRINTK_FLAGS_INCL_FUNCNAME)\r\nres += printk(KERN_CONT "%s:", descriptor->function);\r\nif (descriptor->flags & _DPRINTK_FLAGS_INCL_LINENO)\r\nres += printk(KERN_CONT "%d ", descriptor->lineno);\r\nres += vprintk(fmt, args);\r\nva_end(args);\r\nreturn res;\r\n}\r\nstatic __init int ddebug_setup_query(char *str)\r\n{\r\nif (strlen(str) >= 1024) {\r\npr_warning("ddebug boot param string too large\n");\r\nreturn 0;\r\n}\r\nstrcpy(ddebug_setup_string, str);\r\nreturn 1;\r\n}\r\nstatic ssize_t ddebug_proc_write(struct file *file, const char __user *ubuf,\r\nsize_t len, loff_t *offp)\r\n{\r\nchar tmpbuf[256];\r\nint ret;\r\nif (len == 0)\r\nreturn 0;\r\nif (len > sizeof(tmpbuf)-1)\r\nreturn -E2BIG;\r\nif (copy_from_user(tmpbuf, ubuf, len))\r\nreturn -EFAULT;\r\ntmpbuf[len] = '\0';\r\nif (verbose)\r\nprintk(KERN_INFO "%s: read %d bytes from userspace\n",\r\n__func__, (int)len);\r\nret = ddebug_exec_query(tmpbuf);\r\nif (ret)\r\nreturn ret;\r\n*offp += len;\r\nreturn len;\r\n}\r\nstatic struct _ddebug *ddebug_iter_first(struct ddebug_iter *iter)\r\n{\r\nif (list_empty(&ddebug_tables)) {\r\niter->table = NULL;\r\niter->idx = 0;\r\nreturn NULL;\r\n}\r\niter->table = list_entry(ddebug_tables.next,\r\nstruct ddebug_table, link);\r\niter->idx = 0;\r\nreturn &iter->table->ddebugs[iter->idx];\r\n}\r\nstatic struct _ddebug *ddebug_iter_next(struct ddebug_iter *iter)\r\n{\r\nif (iter->table == NULL)\r\nreturn NULL;\r\nif (++iter->idx == iter->table->num_ddebugs) {\r\niter->idx = 0;\r\nif (list_is_last(&iter->table->link, &ddebug_tables)) {\r\niter->table = NULL;\r\nreturn NULL;\r\n}\r\niter->table = list_entry(iter->table->link.next,\r\nstruct ddebug_table, link);\r\n}\r\nreturn &iter->table->ddebugs[iter->idx];\r\n}\r\nstatic void *ddebug_proc_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct ddebug_iter *iter = m->private;\r\nstruct _ddebug *dp;\r\nint n = *pos;\r\nif (verbose)\r\nprintk(KERN_INFO "%s: called m=%p *pos=%lld\n",\r\n__func__, m, (unsigned long long)*pos);\r\nmutex_lock(&ddebug_lock);\r\nif (!n)\r\nreturn SEQ_START_TOKEN;\r\nif (n < 0)\r\nreturn NULL;\r\ndp = ddebug_iter_first(iter);\r\nwhile (dp != NULL && --n > 0)\r\ndp = ddebug_iter_next(iter);\r\nreturn dp;\r\n}\r\nstatic void *ddebug_proc_next(struct seq_file *m, void *p, loff_t *pos)\r\n{\r\nstruct ddebug_iter *iter = m->private;\r\nstruct _ddebug *dp;\r\nif (verbose)\r\nprintk(KERN_INFO "%s: called m=%p p=%p *pos=%lld\n",\r\n__func__, m, p, (unsigned long long)*pos);\r\nif (p == SEQ_START_TOKEN)\r\ndp = ddebug_iter_first(iter);\r\nelse\r\ndp = ddebug_iter_next(iter);\r\n++*pos;\r\nreturn dp;\r\n}\r\nstatic int ddebug_proc_show(struct seq_file *m, void *p)\r\n{\r\nstruct ddebug_iter *iter = m->private;\r\nstruct _ddebug *dp = p;\r\nchar flagsbuf[8];\r\nif (verbose)\r\nprintk(KERN_INFO "%s: called m=%p p=%p\n",\r\n__func__, m, p);\r\nif (p == SEQ_START_TOKEN) {\r\nseq_puts(m,\r\n"# filename:lineno [module]function flags format\n");\r\nreturn 0;\r\n}\r\nseq_printf(m, "%s:%u [%s]%s %s \"",\r\ndp->filename, dp->lineno,\r\niter->table->mod_name, dp->function,\r\nddebug_describe_flags(dp, flagsbuf, sizeof(flagsbuf)));\r\nseq_escape(m, dp->format, "\t\r\n\"");\r\nseq_puts(m, "\"\n");\r\nreturn 0;\r\n}\r\nstatic void ddebug_proc_stop(struct seq_file *m, void *p)\r\n{\r\nif (verbose)\r\nprintk(KERN_INFO "%s: called m=%p p=%p\n",\r\n__func__, m, p);\r\nmutex_unlock(&ddebug_lock);\r\n}\r\nstatic int ddebug_proc_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ddebug_iter *iter;\r\nint err;\r\nif (verbose)\r\nprintk(KERN_INFO "%s: called\n", __func__);\r\niter = kzalloc(sizeof(*iter), GFP_KERNEL);\r\nif (iter == NULL)\r\nreturn -ENOMEM;\r\nerr = seq_open(file, &ddebug_proc_seqops);\r\nif (err) {\r\nkfree(iter);\r\nreturn err;\r\n}\r\n((struct seq_file *) file->private_data)->private = iter;\r\nreturn 0;\r\n}\r\nint ddebug_add_module(struct _ddebug *tab, unsigned int n,\r\nconst char *name)\r\n{\r\nstruct ddebug_table *dt;\r\nchar *new_name;\r\ndt = kzalloc(sizeof(*dt), GFP_KERNEL);\r\nif (dt == NULL)\r\nreturn -ENOMEM;\r\nnew_name = kstrdup(name, GFP_KERNEL);\r\nif (new_name == NULL) {\r\nkfree(dt);\r\nreturn -ENOMEM;\r\n}\r\ndt->mod_name = new_name;\r\ndt->num_ddebugs = n;\r\ndt->num_enabled = 0;\r\ndt->ddebugs = tab;\r\nmutex_lock(&ddebug_lock);\r\nlist_add_tail(&dt->link, &ddebug_tables);\r\nmutex_unlock(&ddebug_lock);\r\nif (verbose)\r\nprintk(KERN_INFO "%u debug prints in module %s\n",\r\nn, dt->mod_name);\r\nreturn 0;\r\n}\r\nstatic void ddebug_table_free(struct ddebug_table *dt)\r\n{\r\nlist_del_init(&dt->link);\r\nkfree(dt->mod_name);\r\nkfree(dt);\r\n}\r\nint ddebug_remove_module(const char *mod_name)\r\n{\r\nstruct ddebug_table *dt, *nextdt;\r\nint ret = -ENOENT;\r\nif (verbose)\r\nprintk(KERN_INFO "%s: removing module \"%s\"\n",\r\n__func__, mod_name);\r\nmutex_lock(&ddebug_lock);\r\nlist_for_each_entry_safe(dt, nextdt, &ddebug_tables, link) {\r\nif (!strcmp(dt->mod_name, mod_name)) {\r\nddebug_table_free(dt);\r\nret = 0;\r\n}\r\n}\r\nmutex_unlock(&ddebug_lock);\r\nreturn ret;\r\n}\r\nstatic void ddebug_remove_all_tables(void)\r\n{\r\nmutex_lock(&ddebug_lock);\r\nwhile (!list_empty(&ddebug_tables)) {\r\nstruct ddebug_table *dt = list_entry(ddebug_tables.next,\r\nstruct ddebug_table,\r\nlink);\r\nddebug_table_free(dt);\r\n}\r\nmutex_unlock(&ddebug_lock);\r\n}\r\nstatic int __init dynamic_debug_init_debugfs(void)\r\n{\r\nstruct dentry *dir, *file;\r\nif (!ddebug_init_success)\r\nreturn -ENODEV;\r\ndir = debugfs_create_dir("dynamic_debug", NULL);\r\nif (!dir)\r\nreturn -ENOMEM;\r\nfile = debugfs_create_file("control", 0644, dir, NULL,\r\n&ddebug_proc_fops);\r\nif (!file) {\r\ndebugfs_remove(dir);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init dynamic_debug_init(void)\r\n{\r\nstruct _ddebug *iter, *iter_start;\r\nconst char *modname = NULL;\r\nint ret = 0;\r\nint n = 0;\r\nif (__start___verbose != __stop___verbose) {\r\niter = __start___verbose;\r\nmodname = iter->modname;\r\niter_start = iter;\r\nfor (; iter < __stop___verbose; iter++) {\r\nif (strcmp(modname, iter->modname)) {\r\nret = ddebug_add_module(iter_start, n, modname);\r\nif (ret)\r\ngoto out_free;\r\nn = 0;\r\nmodname = iter->modname;\r\niter_start = iter;\r\n}\r\nn++;\r\n}\r\nret = ddebug_add_module(iter_start, n, modname);\r\n}\r\nif (ddebug_setup_string[0] != '\0') {\r\nret = ddebug_exec_query(ddebug_setup_string);\r\nif (ret)\r\npr_warning("Invalid ddebug boot param %s",\r\nddebug_setup_string);\r\nelse\r\npr_info("ddebug initialized with string %s",\r\nddebug_setup_string);\r\n}\r\nout_free:\r\nif (ret)\r\nddebug_remove_all_tables();\r\nelse\r\nddebug_init_success = 1;\r\nreturn 0;\r\n}
