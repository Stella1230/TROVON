void\r\ndsp_audio_generate_ulaw_samples(void)\r\n{\r\nint i, j;\r\ni = 0;\r\nwhile (samples[i].len) {\r\nj = 0;\r\nwhile (j < (*samples[i].len)) {\r\nsamples[i].data[j] =\r\ndsp_audio_alaw_to_ulaw[samples[i].data[j]];\r\nj++;\r\n}\r\ni++;\r\n}\r\n}\r\nvoid dsp_tone_copy(struct dsp *dsp, u8 *data, int len)\r\n{\r\nint index, count, start, num;\r\nstruct pattern *pat;\r\nstruct dsp_tone *tone = &dsp->tone;\r\nif (!tone->tone) {\r\nmemset(data, dsp_silence, len);\r\nreturn;\r\n}\r\npat = (struct pattern *)tone->pattern;\r\nindex = tone->index;\r\ncount = tone->count;\r\nwhile (len) {\r\nwhile (42) {\r\nif (!pat->seq[index]) {\r\ncount = 0;\r\nindex = 0;\r\n}\r\nif (count < pat->seq[index])\r\nbreak;\r\nif (dsp_debug & DEBUG_DSP_TONE)\r\nprintk(KERN_DEBUG "%s: reaching next sequence "\r\n"(index=%d)\n", __func__, index);\r\ncount -= pat->seq[index];\r\nindex++;\r\n}\r\nstart = count % (*(pat->siz[index]));\r\nnum = len;\r\nif (num+count > pat->seq[index])\r\nnum = pat->seq[index] - count;\r\nif (num+start > (*(pat->siz[index])))\r\nnum = (*(pat->siz[index])) - start;\r\nmemcpy(data, pat->data[index]+start, num);\r\ndata += num;\r\ncount += num;\r\nlen -= num;\r\n}\r\ntone->index = index;\r\ntone->count = count;\r\nreturn;\r\n}\r\nstatic void\r\ndsp_tone_hw_message(struct dsp *dsp, u8 *sample, int len)\r\n{\r\nstruct sk_buff *nskb;\r\nnskb = _alloc_mISDN_skb(PH_CONTROL_REQ,\r\n(len) ? HFC_SPL_LOOP_ON : HFC_SPL_LOOP_OFF, len, sample,\r\nGFP_ATOMIC);\r\nif (nskb) {\r\nif (dsp->ch.peer) {\r\nif (dsp->ch.recv(dsp->ch.peer, nskb))\r\ndev_kfree_skb(nskb);\r\n} else\r\ndev_kfree_skb(nskb);\r\n}\r\n}\r\nvoid\r\ndsp_tone_timeout(void *arg)\r\n{\r\nstruct dsp *dsp = arg;\r\nstruct dsp_tone *tone = &dsp->tone;\r\nstruct pattern *pat = (struct pattern *)tone->pattern;\r\nint index = tone->index;\r\nif (!tone->tone)\r\nreturn;\r\nindex++;\r\nif (!pat->seq[index])\r\nindex = 0;\r\ntone->index = index;\r\nif (pat->data[index] == DATA_S)\r\ndsp_tone_hw_message(dsp, NULL, 0);\r\nelse\r\ndsp_tone_hw_message(dsp, pat->data[index], *(pat->siz[index]));\r\ninit_timer(&tone->tl);\r\ntone->tl.expires = jiffies + (pat->seq[index] * HZ) / 8000;\r\nadd_timer(&tone->tl);\r\n}\r\nint\r\ndsp_tone(struct dsp *dsp, int tone)\r\n{\r\nstruct pattern *pat;\r\nint i;\r\nstruct dsp_tone *tonet = &dsp->tone;\r\ntonet->software = 0;\r\ntonet->hardware = 0;\r\nif (!tone) {\r\nif (dsp->features.hfc_loops && timer_pending(&tonet->tl))\r\ndel_timer(&tonet->tl);\r\nif (dsp->features.hfc_loops)\r\ndsp_tone_hw_message(dsp, NULL, 0);\r\ntonet->tone = 0;\r\nreturn 0;\r\n}\r\npat = NULL;\r\ni = 0;\r\nwhile (pattern[i].tone) {\r\nif (pattern[i].tone == tone) {\r\npat = &pattern[i];\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (!pat) {\r\nprintk(KERN_WARNING "dsp: given tone 0x%x is invalid\n", tone);\r\nreturn -EINVAL;\r\n}\r\nif (dsp_debug & DEBUG_DSP_TONE)\r\nprintk(KERN_DEBUG "%s: now starting tone %d (index=%d)\n",\r\n__func__, tone, 0);\r\ntonet->tone = tone;\r\ntonet->pattern = pat;\r\ntonet->index = 0;\r\ntonet->count = 0;\r\nif (dsp->features.hfc_loops) {\r\ntonet->hardware = 1;\r\ndsp_tone_hw_message(dsp, pat->data[0], *(pat->siz[0]));\r\nif (timer_pending(&tonet->tl))\r\ndel_timer(&tonet->tl);\r\ninit_timer(&tonet->tl);\r\ntonet->tl.expires = jiffies + (pat->seq[0] * HZ) / 8000;\r\nadd_timer(&tonet->tl);\r\n} else {\r\ntonet->software = 1;\r\n}\r\nreturn 0;\r\n}
