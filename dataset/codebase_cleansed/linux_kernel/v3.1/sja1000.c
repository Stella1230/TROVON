static void sja1000_write_cmdreg(struct sja1000_priv *priv, u8 val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->cmdreg_lock, flags);\r\npriv->write_reg(priv, REG_CMR, val);\r\npriv->read_reg(priv, REG_SR);\r\nspin_unlock_irqrestore(&priv->cmdreg_lock, flags);\r\n}\r\nstatic int sja1000_probe_chip(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nif (priv->reg_base && (priv->read_reg(priv, 0) == 0xFF)) {\r\nprintk(KERN_INFO "%s: probing @0x%lX failed\n",\r\nDRV_NAME, dev->base_addr);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic void set_reset_mode(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nunsigned char status = priv->read_reg(priv, REG_MOD);\r\nint i;\r\npriv->write_reg(priv, REG_IER, IRQ_OFF);\r\nfor (i = 0; i < 100; i++) {\r\nif (status & MOD_RM) {\r\npriv->can.state = CAN_STATE_STOPPED;\r\nreturn;\r\n}\r\npriv->write_reg(priv, REG_MOD, MOD_RM);\r\nudelay(10);\r\nstatus = priv->read_reg(priv, REG_MOD);\r\n}\r\ndev_err(dev->dev.parent, "setting SJA1000 into reset mode failed!\n");\r\n}\r\nstatic void set_normal_mode(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nunsigned char status = priv->read_reg(priv, REG_MOD);\r\nint i;\r\nfor (i = 0; i < 100; i++) {\r\nif ((status & MOD_RM) == 0) {\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\r\npriv->write_reg(priv, REG_IER, IRQ_ALL);\r\nelse\r\npriv->write_reg(priv, REG_IER,\r\nIRQ_ALL & ~IRQ_BEI);\r\nreturn;\r\n}\r\npriv->write_reg(priv, REG_MOD, 0x00);\r\nudelay(10);\r\nstatus = priv->read_reg(priv, REG_MOD);\r\n}\r\ndev_err(dev->dev.parent, "setting SJA1000 into normal mode failed!\n");\r\n}\r\nstatic void sja1000_start(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nif (priv->can.state != CAN_STATE_STOPPED)\r\nset_reset_mode(dev);\r\npriv->write_reg(priv, REG_TXERR, 0x0);\r\npriv->write_reg(priv, REG_RXERR, 0x0);\r\npriv->read_reg(priv, REG_ECC);\r\nset_normal_mode(dev);\r\n}\r\nstatic int sja1000_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nif (!priv->open_time)\r\nreturn -EINVAL;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nsja1000_start(dev);\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sja1000_set_bittiming(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nu8 btr0, btr1;\r\nbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\r\nbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\r\n(((bt->phase_seg2 - 1) & 0x7) << 4);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nbtr1 |= 0x80;\r\ndev_info(dev->dev.parent,\r\n"setting BTR0=0x%02x BTR1=0x%02x\n", btr0, btr1);\r\npriv->write_reg(priv, REG_BTR0, btr0);\r\npriv->write_reg(priv, REG_BTR1, btr1);\r\nreturn 0;\r\n}\r\nstatic int sja1000_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nbec->txerr = priv->read_reg(priv, REG_TXERR);\r\nbec->rxerr = priv->read_reg(priv, REG_RXERR);\r\nreturn 0;\r\n}\r\nstatic void chipset_init(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, REG_CDR, priv->cdr | CDR_PELICAN);\r\npriv->write_reg(priv, REG_ACCC0, 0x00);\r\npriv->write_reg(priv, REG_ACCC1, 0x00);\r\npriv->write_reg(priv, REG_ACCC2, 0x00);\r\npriv->write_reg(priv, REG_ACCC3, 0x00);\r\npriv->write_reg(priv, REG_ACCM0, 0xFF);\r\npriv->write_reg(priv, REG_ACCM1, 0xFF);\r\npriv->write_reg(priv, REG_ACCM2, 0xFF);\r\npriv->write_reg(priv, REG_ACCM3, 0xFF);\r\npriv->write_reg(priv, REG_OCR, priv->ocr | OCR_MODE_NORMAL);\r\n}\r\nstatic netdev_tx_t sja1000_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nuint8_t fi;\r\nuint8_t dlc;\r\ncanid_t id;\r\nuint8_t dreg;\r\nint i;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(dev);\r\nfi = dlc = cf->can_dlc;\r\nid = cf->can_id;\r\nif (id & CAN_RTR_FLAG)\r\nfi |= FI_RTR;\r\nif (id & CAN_EFF_FLAG) {\r\nfi |= FI_FF;\r\ndreg = EFF_BUF;\r\npriv->write_reg(priv, REG_FI, fi);\r\npriv->write_reg(priv, REG_ID1, (id & 0x1fe00000) >> (5 + 16));\r\npriv->write_reg(priv, REG_ID2, (id & 0x001fe000) >> (5 + 8));\r\npriv->write_reg(priv, REG_ID3, (id & 0x00001fe0) >> 5);\r\npriv->write_reg(priv, REG_ID4, (id & 0x0000001f) << 3);\r\n} else {\r\ndreg = SFF_BUF;\r\npriv->write_reg(priv, REG_FI, fi);\r\npriv->write_reg(priv, REG_ID1, (id & 0x000007f8) >> 3);\r\npriv->write_reg(priv, REG_ID2, (id & 0x00000007) << 5);\r\n}\r\nfor (i = 0; i < dlc; i++)\r\npriv->write_reg(priv, dreg++, cf->data[i]);\r\ncan_put_echo_skb(skb, dev, 0);\r\nsja1000_write_cmdreg(priv, CMD_TR);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void sja1000_rx(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nuint8_t fi;\r\nuint8_t dreg;\r\ncanid_t id;\r\nint i;\r\nskb = alloc_can_skb(dev, &cf);\r\nif (skb == NULL)\r\nreturn;\r\nfi = priv->read_reg(priv, REG_FI);\r\nif (fi & FI_FF) {\r\ndreg = EFF_BUF;\r\nid = (priv->read_reg(priv, REG_ID1) << (5 + 16))\r\n| (priv->read_reg(priv, REG_ID2) << (5 + 8))\r\n| (priv->read_reg(priv, REG_ID3) << 5)\r\n| (priv->read_reg(priv, REG_ID4) >> 3);\r\nid |= CAN_EFF_FLAG;\r\n} else {\r\ndreg = SFF_BUF;\r\nid = (priv->read_reg(priv, REG_ID1) << 3)\r\n| (priv->read_reg(priv, REG_ID2) >> 5);\r\n}\r\ncf->can_dlc = get_can_dlc(fi & 0x0F);\r\nif (fi & FI_RTR) {\r\nid |= CAN_RTR_FLAG;\r\n} else {\r\nfor (i = 0; i < cf->can_dlc; i++)\r\ncf->data[i] = priv->read_reg(priv, dreg++);\r\n}\r\ncf->can_id = id;\r\nsja1000_write_cmdreg(priv, CMD_RRB);\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\nstatic int sja1000_err(struct net_device *dev, uint8_t isrc, uint8_t status)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nenum can_state state = priv->can.state;\r\nuint8_t ecc, alc;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (isrc & IRQ_DOI) {\r\ndev_dbg(dev->dev.parent, "data overrun interrupt\n");\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nsja1000_write_cmdreg(priv, CMD_CDO);\r\n}\r\nif (isrc & IRQ_EI) {\r\ndev_dbg(dev->dev.parent, "error warning interrupt\n");\r\nif (status & SR_BS) {\r\nstate = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\ncan_bus_off(dev);\r\n} else if (status & SR_ES) {\r\nstate = CAN_STATE_ERROR_WARNING;\r\n} else\r\nstate = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nif (isrc & IRQ_BEI) {\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\necc = priv->read_reg(priv, REG_ECC);\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nswitch (ecc & ECC_MASK) {\r\ncase ECC_BIT:\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\nbreak;\r\ncase ECC_FORM:\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase ECC_STUFF:\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ndefault:\r\ncf->data[2] |= CAN_ERR_PROT_UNSPEC;\r\ncf->data[3] = ecc & ECC_SEG;\r\nbreak;\r\n}\r\nif ((ecc & ECC_DIR) == 0)\r\ncf->data[2] |= CAN_ERR_PROT_TX;\r\n}\r\nif (isrc & IRQ_EPI) {\r\ndev_dbg(dev->dev.parent, "error passive interrupt\n");\r\nif (status & SR_ES)\r\nstate = CAN_STATE_ERROR_PASSIVE;\r\nelse\r\nstate = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nif (isrc & IRQ_ALI) {\r\ndev_dbg(dev->dev.parent, "arbitration lost interrupt\n");\r\nalc = priv->read_reg(priv, REG_ALC);\r\npriv->can.can_stats.arbitration_lost++;\r\nstats->tx_errors++;\r\ncf->can_id |= CAN_ERR_LOSTARB;\r\ncf->data[0] = alc & 0x1f;\r\n}\r\nif (state != priv->can.state && (state == CAN_STATE_ERROR_WARNING ||\r\nstate == CAN_STATE_ERROR_PASSIVE)) {\r\nuint8_t rxerr = priv->read_reg(priv, REG_RXERR);\r\nuint8_t txerr = priv->read_reg(priv, REG_TXERR);\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (state == CAN_STATE_ERROR_WARNING) {\r\npriv->can.can_stats.error_warning++;\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\n} else {\r\npriv->can.can_stats.error_passive++;\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\npriv->can.state = state;\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nreturn 0;\r\n}\r\nirqreturn_t sja1000_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nuint8_t isrc, status;\r\nint n = 0;\r\nif (priv->read_reg(priv, REG_IER) == IRQ_OFF)\r\nreturn IRQ_NONE;\r\nif (priv->pre_irq)\r\npriv->pre_irq(priv);\r\nwhile ((isrc = priv->read_reg(priv, REG_IR)) && (n < SJA1000_MAX_IRQ)) {\r\nn++;\r\nstatus = priv->read_reg(priv, REG_SR);\r\nif (isrc & IRQ_WUI)\r\ndev_warn(dev->dev.parent, "wakeup interrupt\n");\r\nif (isrc & IRQ_TI) {\r\nstats->tx_bytes += priv->read_reg(priv, REG_FI) & 0xf;\r\nstats->tx_packets++;\r\ncan_get_echo_skb(dev, 0);\r\nnetif_wake_queue(dev);\r\n}\r\nif (isrc & IRQ_RI) {\r\nwhile (status & SR_RBS) {\r\nsja1000_rx(dev);\r\nstatus = priv->read_reg(priv, REG_SR);\r\n}\r\n}\r\nif (isrc & (IRQ_DOI | IRQ_EI | IRQ_BEI | IRQ_EPI | IRQ_ALI)) {\r\nif (sja1000_err(dev, isrc, status))\r\nbreak;\r\n}\r\n}\r\nif (priv->post_irq)\r\npriv->post_irq(priv);\r\nif (n >= SJA1000_MAX_IRQ)\r\ndev_dbg(dev->dev.parent, "%d messages handled in ISR", n);\r\nreturn (n) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int sja1000_open(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nint err;\r\nset_reset_mode(dev);\r\nerr = open_candev(dev);\r\nif (err)\r\nreturn err;\r\nif (!(priv->flags & SJA1000_CUSTOM_IRQ_HANDLER)) {\r\nerr = request_irq(dev->irq, sja1000_interrupt, priv->irq_flags,\r\ndev->name, (void *)dev);\r\nif (err) {\r\nclose_candev(dev);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nsja1000_start(dev);\r\npriv->open_time = jiffies;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int sja1000_close(struct net_device *dev)\r\n{\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nset_reset_mode(dev);\r\nif (!(priv->flags & SJA1000_CUSTOM_IRQ_HANDLER))\r\nfree_irq(dev->irq, (void *)dev);\r\nclose_candev(dev);\r\npriv->open_time = 0;\r\nreturn 0;\r\n}\r\nstruct net_device *alloc_sja1000dev(int sizeof_priv)\r\n{\r\nstruct net_device *dev;\r\nstruct sja1000_priv *priv;\r\ndev = alloc_candev(sizeof(struct sja1000_priv) + sizeof_priv,\r\nSJA1000_ECHO_SKB_MAX);\r\nif (!dev)\r\nreturn NULL;\r\npriv = netdev_priv(dev);\r\npriv->dev = dev;\r\npriv->can.bittiming_const = &sja1000_bittiming_const;\r\npriv->can.do_set_bittiming = sja1000_set_bittiming;\r\npriv->can.do_set_mode = sja1000_set_mode;\r\npriv->can.do_get_berr_counter = sja1000_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\nspin_lock_init(&priv->cmdreg_lock);\r\nif (sizeof_priv)\r\npriv->priv = (void *)priv + sizeof(struct sja1000_priv);\r\nreturn dev;\r\n}\r\nvoid free_sja1000dev(struct net_device *dev)\r\n{\r\nfree_candev(dev);\r\n}\r\nint register_sja1000dev(struct net_device *dev)\r\n{\r\nif (!sja1000_probe_chip(dev))\r\nreturn -ENODEV;\r\ndev->flags |= IFF_ECHO;\r\ndev->netdev_ops = &sja1000_netdev_ops;\r\nset_reset_mode(dev);\r\nchipset_init(dev);\r\nreturn register_candev(dev);\r\n}\r\nvoid unregister_sja1000dev(struct net_device *dev)\r\n{\r\nset_reset_mode(dev);\r\nunregister_candev(dev);\r\n}\r\nstatic __init int sja1000_init(void)\r\n{\r\nprintk(KERN_INFO "%s CAN netdevice driver\n", DRV_NAME);\r\nreturn 0;\r\n}\r\nstatic __exit void sja1000_exit(void)\r\n{\r\nprintk(KERN_INFO "%s: driver removed\n", DRV_NAME);\r\n}
