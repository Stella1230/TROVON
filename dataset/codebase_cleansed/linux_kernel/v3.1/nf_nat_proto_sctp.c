static void\r\nsctp_unique_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_nat_range *range,\r\nenum nf_nat_manip_type maniptype,\r\nconst struct nf_conn *ct)\r\n{\r\nnf_nat_proto_unique_tuple(tuple, range, maniptype, ct,\r\n&nf_sctp_port_rover);\r\n}\r\nstatic bool\r\nsctp_manip_pkt(struct sk_buff *skb,\r\nunsigned int iphdroff,\r\nconst struct nf_conntrack_tuple *tuple,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nconst struct iphdr *iph = (struct iphdr *)(skb->data + iphdroff);\r\nstruct sk_buff *frag;\r\nsctp_sctphdr_t *hdr;\r\nunsigned int hdroff = iphdroff + iph->ihl*4;\r\n__be32 oldip, newip;\r\n__be32 crc32;\r\nif (!skb_make_writable(skb, hdroff + sizeof(*hdr)))\r\nreturn false;\r\niph = (struct iphdr *)(skb->data + iphdroff);\r\nhdr = (struct sctphdr *)(skb->data + hdroff);\r\nif (maniptype == IP_NAT_MANIP_SRC) {\r\noldip = iph->saddr;\r\nnewip = tuple->src.u3.ip;\r\nhdr->source = tuple->src.u.sctp.port;\r\n} else {\r\noldip = iph->daddr;\r\nnewip = tuple->dst.u3.ip;\r\nhdr->dest = tuple->dst.u.sctp.port;\r\n}\r\ncrc32 = sctp_start_cksum((u8 *)hdr, skb_headlen(skb) - hdroff);\r\nskb_walk_frags(skb, frag)\r\ncrc32 = sctp_update_cksum((u8 *)frag->data, skb_headlen(frag),\r\ncrc32);\r\ncrc32 = sctp_end_cksum(crc32);\r\nhdr->checksum = crc32;\r\nreturn true;\r\n}\r\nstatic int __init nf_nat_proto_sctp_init(void)\r\n{\r\nreturn nf_nat_protocol_register(&nf_nat_protocol_sctp);\r\n}\r\nstatic void __exit nf_nat_proto_sctp_exit(void)\r\n{\r\nnf_nat_protocol_unregister(&nf_nat_protocol_sctp);\r\n}
