int omap4430_phy_init(struct device *dev)\r\n{\r\nctrl_base = ioremap(OMAP443X_SCM_BASE, SZ_1K);\r\nif (!ctrl_base) {\r\npr_err("control module ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\n__raw_writel(PHY_PD, ctrl_base + CONTROL_DEV_CONF);\r\nif (!dev) {\r\niounmap(ctrl_base);\r\nreturn 0;\r\n}\r\nphyclk = clk_get(dev, "ocp2scp_usb_phy_ick");\r\nif (IS_ERR(phyclk)) {\r\ndev_err(dev, "cannot clk_get ocp2scp_usb_phy_ick\n");\r\niounmap(ctrl_base);\r\nreturn PTR_ERR(phyclk);\r\n}\r\nclk48m = clk_get(dev, "ocp2scp_usb_phy_phy_48m");\r\nif (IS_ERR(clk48m)) {\r\ndev_err(dev, "cannot clk_get ocp2scp_usb_phy_phy_48m\n");\r\nclk_put(phyclk);\r\niounmap(ctrl_base);\r\nreturn PTR_ERR(clk48m);\r\n}\r\nclk32k = clk_get(dev, "usb_phy_cm_clk32k");\r\nif (IS_ERR(clk32k)) {\r\ndev_err(dev, "cannot clk_get usb_phy_cm_clk32k\n");\r\nclk_put(phyclk);\r\nclk_put(clk48m);\r\niounmap(ctrl_base);\r\nreturn PTR_ERR(clk32k);\r\n}\r\nreturn 0;\r\n}\r\nint omap4430_phy_set_clk(struct device *dev, int on)\r\n{\r\nstatic int state;\r\nif (on && !state) {\r\nclk_enable(phyclk);\r\nclk_enable(clk48m);\r\nclk_enable(clk32k);\r\nstate = 1;\r\n} else if (state) {\r\nclk_disable(phyclk);\r\nclk_disable(clk48m);\r\nclk_disable(clk32k);\r\nstate = 0;\r\n}\r\nreturn 0;\r\n}\r\nint omap4430_phy_power(struct device *dev, int ID, int on)\r\n{\r\nif (on) {\r\nif (ID)\r\n__raw_writel(AVALID | VBUSVALID, ctrl_base +\r\nUSBOTGHS_CONTROL);\r\nelse\r\n__raw_writel(IDDIG | AVALID | VBUSVALID,\r\nctrl_base + USBOTGHS_CONTROL);\r\n} else {\r\n__raw_writel(SESSEND | IDDIG, ctrl_base +\r\nUSBOTGHS_CONTROL);\r\n}\r\nreturn 0;\r\n}\r\nint omap4430_phy_suspend(struct device *dev, int suspend)\r\n{\r\nif (suspend) {\r\nomap4430_phy_set_clk(dev, 0);\r\n__raw_writel(PHY_PD, ctrl_base + CONTROL_DEV_CONF);\r\nusbotghs_control = __raw_readl(ctrl_base + USBOTGHS_CONTROL);\r\n} else {\r\nomap4430_phy_set_clk(dev, 1);\r\nif (__raw_readl(ctrl_base + CONTROL_DEV_CONF) & PHY_PD) {\r\n__raw_writel(~PHY_PD, ctrl_base + CONTROL_DEV_CONF);\r\nmdelay(200);\r\n}\r\n__raw_writel(usbotghs_control, ctrl_base + USBOTGHS_CONTROL);\r\n}\r\nreturn 0;\r\n}\r\nint omap4430_phy_exit(struct device *dev)\r\n{\r\nif (ctrl_base)\r\niounmap(ctrl_base);\r\nif (phyclk)\r\nclk_put(phyclk);\r\nif (clk48m)\r\nclk_put(clk48m);\r\nif (clk32k)\r\nclk_put(clk32k);\r\nreturn 0;\r\n}\r\nvoid am35x_musb_reset(void)\r\n{\r\nu32 regval;\r\nregval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);\r\nregval |= AM35XX_USBOTGSS_SW_RST;\r\nomap_ctrl_writel(regval, AM35XX_CONTROL_IP_SW_RESET);\r\nregval &= ~AM35XX_USBOTGSS_SW_RST;\r\nomap_ctrl_writel(regval, AM35XX_CONTROL_IP_SW_RESET);\r\nregval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);\r\n}\r\nvoid am35x_musb_phy_power(u8 on)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(100);\r\nu32 devconf2;\r\nif (on) {\r\ndevconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);\r\ndevconf2 &= ~(CONF2_RESET | CONF2_PHYPWRDN | CONF2_OTGPWRDN);\r\ndevconf2 |= CONF2_PHY_PLLON;\r\nomap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);\r\npr_info(KERN_INFO "Waiting for PHY clock good...\n");\r\nwhile (!(omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2)\r\n& CONF2_PHYCLKGD)) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\npr_err(KERN_ERR "musb PHY clock good timed out\n");\r\nbreak;\r\n}\r\n}\r\n} else {\r\ndevconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);\r\ndevconf2 &= ~CONF2_PHY_PLLON;\r\ndevconf2 |= CONF2_PHYPWRDN | CONF2_OTGPWRDN;\r\nomap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);\r\n}\r\n}\r\nvoid am35x_musb_clear_irq(void)\r\n{\r\nu32 regval;\r\nregval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);\r\nregval |= AM35XX_USBOTGSS_INT_CLR;\r\nomap_ctrl_writel(regval, AM35XX_CONTROL_LVL_INTR_CLEAR);\r\nregval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);\r\n}\r\nvoid am35x_set_mode(u8 musb_mode)\r\n{\r\nu32 devconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);\r\ndevconf2 &= ~CONF2_OTGMODE;\r\nswitch (musb_mode) {\r\n#ifdef CONFIG_USB_MUSB_HDRC_HCD\r\ncase MUSB_HOST:\r\ndevconf2 |= CONF2_FORCE_HOST;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_USB_GADGET_MUSB_HDRC\r\ncase MUSB_PERIPHERAL:\r\ndevconf2 |= CONF2_FORCE_DEVICE;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_USB_MUSB_OTG\r\ncase MUSB_OTG:\r\ndevconf2 |= CONF2_NO_OVERRIDE;\r\nbreak;\r\n#endif\r\ndefault:\r\npr_info(KERN_INFO "Unsupported mode %u\n", musb_mode);\r\n}\r\nomap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);\r\n}
