static int wdt_start(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&spinlock, flags);\r\noutb_p(UNLOCK_DATA, IO_INDEX_PORT);\r\noutb_p(UNLOCK_DATA, IO_INDEX_PORT);\r\noutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\r\noutb_p(0x08, IO_DATA_PORT);\r\noutb_p(0xF2, IO_INDEX_PORT);\r\noutb_p(timeoutW, IO_DATA_PORT);\r\noutb_p(0xF3, IO_INDEX_PORT);\r\noutb_p(0x08, IO_DATA_PORT);\r\noutb_p(0xF4, IO_INDEX_PORT);\r\noutb_p(0x00, IO_DATA_PORT);\r\noutb_p(0x30, IO_INDEX_PORT);\r\noutb_p(0x01, IO_DATA_PORT);\r\noutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\r\noutb_p(0x07, IO_DATA_PORT);\r\nif (!testmode) {\r\nunsigned pin_map;\r\noutb_p(0xE6, IO_INDEX_PORT);\r\noutb_p(0x0A, IO_DATA_PORT);\r\noutb_p(0x2C, IO_INDEX_PORT);\r\npin_map = inb_p(IO_DATA_PORT);\r\npin_map |= 0x10;\r\npin_map &= ~(0x20);\r\noutb_p(0x2C, IO_INDEX_PORT);\r\noutb_p(pin_map, IO_DATA_PORT);\r\n}\r\noutb_p(0xE3, IO_INDEX_PORT);\r\noutb_p(0x08, IO_DATA_PORT);\r\noutb_p(0x30, IO_INDEX_PORT);\r\noutb_p(0x01, IO_DATA_PORT);\r\noutb_p(LOCK_DATA, IO_INDEX_PORT);\r\nspin_unlock_irqrestore(&spinlock, flags);\r\nprintk(KERN_INFO PFX "activated.\n");\r\nreturn 0;\r\n}\r\nstatic int wdt_stop(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&spinlock, flags);\r\noutb_p(UNLOCK_DATA, IO_INDEX_PORT);\r\noutb_p(UNLOCK_DATA, IO_INDEX_PORT);\r\noutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\r\noutb_p(0x08, IO_DATA_PORT);\r\noutb_p(0xF2, IO_INDEX_PORT);\r\noutb_p(0xFF, IO_DATA_PORT);\r\noutb_p(0xF3, IO_INDEX_PORT);\r\noutb_p(0x00, IO_DATA_PORT);\r\noutb_p(0xF4, IO_INDEX_PORT);\r\noutb_p(0x00, IO_DATA_PORT);\r\noutb_p(0xF2, IO_INDEX_PORT);\r\noutb_p(0x00, IO_DATA_PORT);\r\noutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\r\noutb_p(0x07, IO_DATA_PORT);\r\nif (!testmode) {\r\noutb_p(0xE6, IO_INDEX_PORT);\r\noutb_p(0x01, IO_DATA_PORT);\r\n}\r\noutb_p(0xE3, IO_INDEX_PORT);\r\noutb_p(0x01, IO_DATA_PORT);\r\noutb_p(LOCK_DATA, IO_INDEX_PORT);\r\nspin_unlock_irqrestore(&spinlock, flags);\r\nprintk(KERN_INFO PFX "shutdown.\n");\r\nreturn 0;\r\n}\r\nstatic int wdt_keepalive(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&spinlock, flags);\r\noutb_p(UNLOCK_DATA, IO_INDEX_PORT);\r\noutb_p(UNLOCK_DATA, IO_INDEX_PORT);\r\noutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\r\noutb_p(0x08, IO_DATA_PORT);\r\noutb_p(0xF2, IO_INDEX_PORT);\r\noutb_p(timeoutW, IO_DATA_PORT);\r\noutb_p(LOCK_DATA, IO_INDEX_PORT);\r\nspin_unlock_irqrestore(&spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int wdt_set_timeout(int t)\r\n{\r\nint tmrval;\r\nif (t < 15)\r\nreturn -EINVAL;\r\ntmrval = ((t + 15) + 29) / 30;\r\nif (tmrval > 255)\r\nreturn -EINVAL;\r\ntimeoutW = tmrval;\r\ntimeout = (timeoutW * 30) - 15;\r\nreturn 0;\r\n}\r\nstatic int wdt_get_status(int *status)\r\n{\r\nint new_status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&spinlock, flags);\r\noutb_p(UNLOCK_DATA, IO_INDEX_PORT);\r\noutb_p(UNLOCK_DATA, IO_INDEX_PORT);\r\noutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\r\noutb_p(0x08, IO_DATA_PORT);\r\noutb_p(0xF4, IO_INDEX_PORT);\r\nnew_status = inb_p(IO_DATA_PORT);\r\noutb_p(LOCK_DATA, IO_INDEX_PORT);\r\nspin_unlock_irqrestore(&spinlock, flags);\r\n*status = 0;\r\nif (new_status & 1)\r\n*status |= WDIOF_CARDRESET;\r\nreturn 0;\r\n}\r\nstatic int wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &timer_alive))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nwdt_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42) {\r\nwdt_stop();\r\nclear_bit(0, &timer_alive);\r\n} else {\r\nwdt_keepalive();\r\nprintk(KERN_CRIT PFX\r\n"unexpected close, not stopping watchdog!\n");\r\n}\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t wdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t ofs;\r\nexpect_close = 0;\r\nfor (ofs = 0; ofs != count; ofs++) {\r\nchar c;\r\nif (get_user(c, buf + ofs))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nwdt_keepalive();\r\n}\r\nreturn count;\r\n}\r\nstatic long wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint status;\r\nint new_options, retval = -EINVAL;\r\nint new_timeout;\r\nunion {\r\nstruct watchdog_info __user *ident;\r\nint __user *i;\r\n} uarg;\r\nuarg.i = (int __user *)arg;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(uarg.ident, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nwdt_get_status(&status);\r\nreturn put_user(status, uarg.i);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, uarg.i);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(new_options, uarg.i))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD) {\r\nwdt_stop();\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_ENABLECARD) {\r\nwdt_start();\r\nretval = 0;\r\n}\r\nreturn retval;\r\ncase WDIOC_KEEPALIVE:\r\nwdt_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, uarg.i))\r\nreturn -EFAULT;\r\nif (wdt_set_timeout(new_timeout))\r\nreturn -EINVAL;\r\nwdt_keepalive();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout, uarg.i);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdt_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init w83977f_wdt_init(void)\r\n{\r\nint rc;\r\nprintk(KERN_INFO PFX DRIVER_VERSION);\r\nif (wdt_set_timeout(timeout)) {\r\nwdt_set_timeout(DEFAULT_TIMEOUT);\r\nprintk(KERN_INFO PFX\r\n"timeout value must be 15 <= timeout <= 7635, using %d\n",\r\nDEFAULT_TIMEOUT);\r\n}\r\nif (!request_region(IO_INDEX_PORT, 2, WATCHDOG_NAME)) {\r\nprintk(KERN_ERR PFX "I/O address 0x%04x already in use\n",\r\nIO_INDEX_PORT);\r\nrc = -EIO;\r\ngoto err_out;\r\n}\r\nrc = register_reboot_notifier(&wdt_notifier);\r\nif (rc) {\r\nprintk(KERN_ERR PFX\r\n"cannot register reboot notifier (err=%d)\n", rc);\r\ngoto err_out_region;\r\n}\r\nrc = misc_register(&wdt_miscdev);\r\nif (rc) {\r\nprintk(KERN_ERR PFX\r\n"cannot register miscdev on minor=%d (err=%d)\n",\r\nwdt_miscdev.minor, rc);\r\ngoto err_out_reboot;\r\n}\r\nprintk(KERN_INFO PFX\r\n"initialized. timeout=%d sec (nowayout=%d testmode=%d)\n",\r\ntimeout, nowayout, testmode);\r\nreturn 0;\r\nerr_out_reboot:\r\nunregister_reboot_notifier(&wdt_notifier);\r\nerr_out_region:\r\nrelease_region(IO_INDEX_PORT, 2);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic void __exit w83977f_wdt_exit(void)\r\n{\r\nwdt_stop();\r\nmisc_deregister(&wdt_miscdev);\r\nunregister_reboot_notifier(&wdt_notifier);\r\nrelease_region(IO_INDEX_PORT, 2);\r\n}
