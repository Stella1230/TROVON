static void\r\nnv50_dac_disconnect(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_channel *evo = nv50_display(dev)->master;\r\nint ret;\r\nif (!nv_encoder->crtc)\r\nreturn;\r\nnv50_crtc_blank(nouveau_crtc(nv_encoder->crtc), true);\r\nNV_DEBUG_KMS(dev, "Disconnecting DAC %d\n", nv_encoder->or);\r\nret = RING_SPACE(evo, 4);\r\nif (ret) {\r\nNV_ERROR(dev, "no space while disconnecting DAC\n");\r\nreturn;\r\n}\r\nBEGIN_RING(evo, 0, NV50_EVO_DAC(nv_encoder->or, MODE_CTRL), 1);\r\nOUT_RING (evo, 0);\r\nBEGIN_RING(evo, 0, NV50_EVO_UPDATE, 1);\r\nOUT_RING (evo, 0);\r\nnv_encoder->crtc = NULL;\r\n}\r\nstatic enum drm_connector_status\r\nnv50_dac_detect(struct drm_encoder *encoder, struct drm_connector *connector)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nenum drm_connector_status status = connector_status_disconnected;\r\nuint32_t dpms_state, load_pattern, load_state;\r\nint or = nv_encoder->or;\r\nnv_wr32(dev, NV50_PDISPLAY_DAC_CLK_CTRL1(or), 0x00000001);\r\ndpms_state = nv_rd32(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or));\r\nnv_wr32(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or),\r\n0x00150000 | NV50_PDISPLAY_DAC_DPMS_CTRL_PENDING);\r\nif (!nv_wait(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or),\r\nNV50_PDISPLAY_DAC_DPMS_CTRL_PENDING, 0)) {\r\nNV_ERROR(dev, "timeout: DAC_DPMS_CTRL_PENDING(%d) == 0\n", or);\r\nNV_ERROR(dev, "DAC_DPMS_CTRL(%d) = 0x%08x\n", or,\r\nnv_rd32(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or)));\r\nreturn status;\r\n}\r\nif (dev_priv->vbios.dactestval) {\r\nload_pattern = dev_priv->vbios.dactestval;\r\nNV_DEBUG_KMS(dev, "Using bios provided load_pattern of %d\n",\r\nload_pattern);\r\n} else {\r\nload_pattern = 340;\r\nNV_DEBUG_KMS(dev, "Using default load_pattern of %d\n",\r\nload_pattern);\r\n}\r\nnv_wr32(dev, NV50_PDISPLAY_DAC_LOAD_CTRL(or),\r\nNV50_PDISPLAY_DAC_LOAD_CTRL_ACTIVE | load_pattern);\r\nmdelay(45);\r\nload_state = nv_rd32(dev, NV50_PDISPLAY_DAC_LOAD_CTRL(or));\r\nnv_wr32(dev, NV50_PDISPLAY_DAC_LOAD_CTRL(or), 0);\r\nnv_wr32(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or), dpms_state |\r\nNV50_PDISPLAY_DAC_DPMS_CTRL_PENDING);\r\nif ((load_state & NV50_PDISPLAY_DAC_LOAD_CTRL_PRESENT) ==\r\nNV50_PDISPLAY_DAC_LOAD_CTRL_PRESENT)\r\nstatus = connector_status_connected;\r\nif (status == connector_status_connected)\r\nNV_DEBUG_KMS(dev, "Load was detected on output with or %d\n", or);\r\nelse\r\nNV_DEBUG_KMS(dev, "Load was not detected on output with or %d\n", or);\r\nreturn status;\r\n}\r\nstatic void\r\nnv50_dac_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nuint32_t val;\r\nint or = nv_encoder->or;\r\nNV_DEBUG_KMS(dev, "or %d mode %d\n", or, mode);\r\nif (!nv_wait(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or),\r\nNV50_PDISPLAY_DAC_DPMS_CTRL_PENDING, 0)) {\r\nNV_ERROR(dev, "timeout: DAC_DPMS_CTRL_PENDING(%d) == 0\n", or);\r\nNV_ERROR(dev, "DAC_DPMS_CTRL(%d) = 0x%08x\n", or,\r\nnv_rd32(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or)));\r\nreturn;\r\n}\r\nval = nv_rd32(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or)) & ~0x7F;\r\nif (mode != DRM_MODE_DPMS_ON)\r\nval |= NV50_PDISPLAY_DAC_DPMS_CTRL_BLANKED;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_STANDBY:\r\nval |= NV50_PDISPLAY_DAC_DPMS_CTRL_HSYNC_OFF;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nval |= NV50_PDISPLAY_DAC_DPMS_CTRL_VSYNC_OFF;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nval |= NV50_PDISPLAY_DAC_DPMS_CTRL_OFF;\r\nval |= NV50_PDISPLAY_DAC_DPMS_CTRL_HSYNC_OFF;\r\nval |= NV50_PDISPLAY_DAC_DPMS_CTRL_VSYNC_OFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nnv_wr32(dev, NV50_PDISPLAY_DAC_DPMS_CTRL(or), val |\r\nNV50_PDISPLAY_DAC_DPMS_CTRL_PENDING);\r\n}\r\nstatic void\r\nnv50_dac_save(struct drm_encoder *encoder)\r\n{\r\nNV_ERROR(encoder->dev, "!!\n");\r\n}\r\nstatic void\r\nnv50_dac_restore(struct drm_encoder *encoder)\r\n{\r\nNV_ERROR(encoder->dev, "!!\n");\r\n}\r\nstatic bool\r\nnv50_dac_mode_fixup(struct drm_encoder *encoder, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_connector *connector;\r\nNV_DEBUG_KMS(encoder->dev, "or %d\n", nv_encoder->or);\r\nconnector = nouveau_encoder_connector_get(nv_encoder);\r\nif (!connector) {\r\nNV_ERROR(encoder->dev, "Encoder has no connector\n");\r\nreturn false;\r\n}\r\nif (connector->scaling_mode != DRM_MODE_SCALE_NONE &&\r\nconnector->native_mode) {\r\nint id = adjusted_mode->base.id;\r\n*adjusted_mode = *connector->native_mode;\r\nadjusted_mode->base.id = id;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nnv50_dac_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void\r\nnv50_dac_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void\r\nnv50_dac_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_channel *evo = nv50_display(dev)->master;\r\nstruct nouveau_crtc *crtc = nouveau_crtc(encoder->crtc);\r\nuint32_t mode_ctl = 0, mode_ctl2 = 0;\r\nint ret;\r\nNV_DEBUG_KMS(dev, "or %d type %d crtc %d\n",\r\nnv_encoder->or, nv_encoder->dcb->type, crtc->index);\r\nnv50_dac_dpms(encoder, DRM_MODE_DPMS_ON);\r\nif (crtc->index == 1)\r\nmode_ctl |= NV50_EVO_DAC_MODE_CTRL_CRTC1;\r\nelse\r\nmode_ctl |= NV50_EVO_DAC_MODE_CTRL_CRTC0;\r\nif (nv_encoder->dcb->type == OUTPUT_ANALOG)\r\nmode_ctl |= 0x40;\r\nelse\r\nif (nv_encoder->dcb->type == OUTPUT_TV)\r\nmode_ctl |= 0x100;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nmode_ctl2 |= NV50_EVO_DAC_MODE_CTRL2_NHSYNC;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nmode_ctl2 |= NV50_EVO_DAC_MODE_CTRL2_NVSYNC;\r\nret = RING_SPACE(evo, 3);\r\nif (ret) {\r\nNV_ERROR(dev, "no space while connecting DAC\n");\r\nreturn;\r\n}\r\nBEGIN_RING(evo, 0, NV50_EVO_DAC(nv_encoder->or, MODE_CTRL), 2);\r\nOUT_RING(evo, mode_ctl);\r\nOUT_RING(evo, mode_ctl2);\r\nnv_encoder->crtc = encoder->crtc;\r\n}\r\nstatic struct drm_crtc *\r\nnv50_dac_crtc_get(struct drm_encoder *encoder)\r\n{\r\nreturn nouveau_encoder(encoder)->crtc;\r\n}\r\nstatic void\r\nnv50_dac_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nif (!encoder)\r\nreturn;\r\nNV_DEBUG_KMS(encoder->dev, "\n");\r\ndrm_encoder_cleanup(encoder);\r\nkfree(nv_encoder);\r\n}\r\nint\r\nnv50_dac_create(struct drm_connector *connector, struct dcb_entry *entry)\r\n{\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_encoder *encoder;\r\nnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\r\nif (!nv_encoder)\r\nreturn -ENOMEM;\r\nencoder = to_drm_encoder(nv_encoder);\r\nnv_encoder->dcb = entry;\r\nnv_encoder->or = ffs(entry->or) - 1;\r\ndrm_encoder_init(connector->dev, encoder, &nv50_dac_encoder_funcs,\r\nDRM_MODE_ENCODER_DAC);\r\ndrm_encoder_helper_add(encoder, &nv50_dac_helper_funcs);\r\nencoder->possible_crtcs = entry->heads;\r\nencoder->possible_clones = 0;\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}
