static struct dm_exception_store_type *__find_exception_store_type(const char *name)\r\n{\r\nstruct dm_exception_store_type *type;\r\nlist_for_each_entry(type, &_exception_store_types, list)\r\nif (!strcmp(name, type->name))\r\nreturn type;\r\nreturn NULL;\r\n}\r\nstatic struct dm_exception_store_type *_get_exception_store_type(const char *name)\r\n{\r\nstruct dm_exception_store_type *type;\r\nspin_lock(&_lock);\r\ntype = __find_exception_store_type(name);\r\nif (type && !try_module_get(type->module))\r\ntype = NULL;\r\nspin_unlock(&_lock);\r\nreturn type;\r\n}\r\nstatic struct dm_exception_store_type *get_type(const char *type_name)\r\n{\r\nchar *p, *type_name_dup;\r\nstruct dm_exception_store_type *type;\r\ntype = _get_exception_store_type(type_name);\r\nif (type)\r\nreturn type;\r\ntype_name_dup = kstrdup(type_name, GFP_KERNEL);\r\nif (!type_name_dup) {\r\nDMERR("No memory left to attempt load for \"%s\"", type_name);\r\nreturn NULL;\r\n}\r\nwhile (request_module("dm-exstore-%s", type_name_dup) ||\r\n!(type = _get_exception_store_type(type_name))) {\r\np = strrchr(type_name_dup, '-');\r\nif (!p)\r\nbreak;\r\np[0] = '\0';\r\n}\r\nif (!type)\r\nDMWARN("Module for exstore type \"%s\" not found.", type_name);\r\nkfree(type_name_dup);\r\nreturn type;\r\n}\r\nstatic void put_type(struct dm_exception_store_type *type)\r\n{\r\nspin_lock(&_lock);\r\nmodule_put(type->module);\r\nspin_unlock(&_lock);\r\n}\r\nint dm_exception_store_type_register(struct dm_exception_store_type *type)\r\n{\r\nint r = 0;\r\nspin_lock(&_lock);\r\nif (!__find_exception_store_type(type->name))\r\nlist_add(&type->list, &_exception_store_types);\r\nelse\r\nr = -EEXIST;\r\nspin_unlock(&_lock);\r\nreturn r;\r\n}\r\nint dm_exception_store_type_unregister(struct dm_exception_store_type *type)\r\n{\r\nspin_lock(&_lock);\r\nif (!__find_exception_store_type(type->name)) {\r\nspin_unlock(&_lock);\r\nreturn -EINVAL;\r\n}\r\nlist_del(&type->list);\r\nspin_unlock(&_lock);\r\nreturn 0;\r\n}\r\nstatic int set_chunk_size(struct dm_exception_store *store,\r\nconst char *chunk_size_arg, char **error)\r\n{\r\nunsigned long chunk_size_ulong;\r\nchar *value;\r\nchunk_size_ulong = simple_strtoul(chunk_size_arg, &value, 10);\r\nif (*chunk_size_arg == '\0' || *value != '\0' ||\r\nchunk_size_ulong > UINT_MAX) {\r\n*error = "Invalid chunk size";\r\nreturn -EINVAL;\r\n}\r\nif (!chunk_size_ulong) {\r\nstore->chunk_size = store->chunk_mask = store->chunk_shift = 0;\r\nreturn 0;\r\n}\r\nreturn dm_exception_store_set_chunk_size(store,\r\n(unsigned) chunk_size_ulong,\r\nerror);\r\n}\r\nint dm_exception_store_set_chunk_size(struct dm_exception_store *store,\r\nunsigned chunk_size,\r\nchar **error)\r\n{\r\nif (!is_power_of_2(chunk_size)) {\r\n*error = "Chunk size is not a power of 2";\r\nreturn -EINVAL;\r\n}\r\nif (chunk_size %\r\n(bdev_logical_block_size(dm_snap_cow(store->snap)->bdev) >> 9) ||\r\nchunk_size %\r\n(bdev_logical_block_size(dm_snap_origin(store->snap)->bdev) >> 9)) {\r\n*error = "Chunk size is not a multiple of device blocksize";\r\nreturn -EINVAL;\r\n}\r\nif (chunk_size > INT_MAX >> SECTOR_SHIFT) {\r\n*error = "Chunk size is too high";\r\nreturn -EINVAL;\r\n}\r\nstore->chunk_size = chunk_size;\r\nstore->chunk_mask = chunk_size - 1;\r\nstore->chunk_shift = ffs(chunk_size) - 1;\r\nreturn 0;\r\n}\r\nint dm_exception_store_create(struct dm_target *ti, int argc, char **argv,\r\nstruct dm_snapshot *snap,\r\nunsigned *args_used,\r\nstruct dm_exception_store **store)\r\n{\r\nint r = 0;\r\nstruct dm_exception_store_type *type = NULL;\r\nstruct dm_exception_store *tmp_store;\r\nchar persistent;\r\nif (argc < 2) {\r\nti->error = "Insufficient exception store arguments";\r\nreturn -EINVAL;\r\n}\r\ntmp_store = kmalloc(sizeof(*tmp_store), GFP_KERNEL);\r\nif (!tmp_store) {\r\nti->error = "Exception store allocation failed";\r\nreturn -ENOMEM;\r\n}\r\npersistent = toupper(*argv[0]);\r\nif (persistent == 'P')\r\ntype = get_type("P");\r\nelse if (persistent == 'N')\r\ntype = get_type("N");\r\nelse {\r\nti->error = "Persistent flag is not P or N";\r\nr = -EINVAL;\r\ngoto bad_type;\r\n}\r\nif (!type) {\r\nti->error = "Exception store type not recognised";\r\nr = -EINVAL;\r\ngoto bad_type;\r\n}\r\ntmp_store->type = type;\r\ntmp_store->snap = snap;\r\nr = set_chunk_size(tmp_store, argv[1], &ti->error);\r\nif (r)\r\ngoto bad;\r\nr = type->ctr(tmp_store, 0, NULL);\r\nif (r) {\r\nti->error = "Exception store type constructor failed";\r\ngoto bad;\r\n}\r\n*args_used = 2;\r\n*store = tmp_store;\r\nreturn 0;\r\nbad:\r\nput_type(type);\r\nbad_type:\r\nkfree(tmp_store);\r\nreturn r;\r\n}\r\nvoid dm_exception_store_destroy(struct dm_exception_store *store)\r\n{\r\nstore->type->dtr(store);\r\nput_type(store->type);\r\nkfree(store);\r\n}\r\nint dm_exception_store_init(void)\r\n{\r\nint r;\r\nr = dm_transient_snapshot_init();\r\nif (r) {\r\nDMERR("Unable to register transient exception store type.");\r\ngoto transient_fail;\r\n}\r\nr = dm_persistent_snapshot_init();\r\nif (r) {\r\nDMERR("Unable to register persistent exception store type");\r\ngoto persistent_fail;\r\n}\r\nreturn 0;\r\npersistent_fail:\r\ndm_persistent_snapshot_exit();\r\ntransient_fail:\r\nreturn r;\r\n}\r\nvoid dm_exception_store_exit(void)\r\n{\r\ndm_persistent_snapshot_exit();\r\ndm_transient_snapshot_exit();\r\n}
