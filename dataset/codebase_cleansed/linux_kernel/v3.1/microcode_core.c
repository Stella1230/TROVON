static void collect_cpu_info_local(void *arg)\r\n{\r\nstruct cpu_info_ctx *ctx = arg;\r\nctx->err = microcode_ops->collect_cpu_info(smp_processor_id(),\r\nctx->cpu_sig);\r\n}\r\nstatic int collect_cpu_info_on_target(int cpu, struct cpu_signature *cpu_sig)\r\n{\r\nstruct cpu_info_ctx ctx = { .cpu_sig = cpu_sig, .err = 0 };\r\nint ret;\r\nret = smp_call_function_single(cpu, collect_cpu_info_local, &ctx, 1);\r\nif (!ret)\r\nret = ctx.err;\r\nreturn ret;\r\n}\r\nstatic int collect_cpu_info(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nint ret;\r\nmemset(uci, 0, sizeof(*uci));\r\nret = collect_cpu_info_on_target(cpu, &uci->cpu_sig);\r\nif (!ret)\r\nuci->valid = 1;\r\nreturn ret;\r\n}\r\nstatic void apply_microcode_local(void *arg)\r\n{\r\nstruct apply_microcode_ctx *ctx = arg;\r\nctx->err = microcode_ops->apply_microcode(smp_processor_id());\r\n}\r\nstatic int apply_microcode_on_target(int cpu)\r\n{\r\nstruct apply_microcode_ctx ctx = { .err = 0 };\r\nint ret;\r\nret = smp_call_function_single(cpu, apply_microcode_local, &ctx, 1);\r\nif (!ret)\r\nret = ctx.err;\r\nreturn ret;\r\n}\r\nstatic int do_microcode_update(const void __user *buf, size_t size)\r\n{\r\nint error = 0;\r\nint cpu;\r\nfor_each_online_cpu(cpu) {\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nenum ucode_state ustate;\r\nif (!uci->valid)\r\ncontinue;\r\nustate = microcode_ops->request_microcode_user(cpu, buf, size);\r\nif (ustate == UCODE_ERROR) {\r\nerror = -1;\r\nbreak;\r\n} else if (ustate == UCODE_OK)\r\napply_microcode_on_target(cpu);\r\n}\r\nreturn error;\r\n}\r\nstatic int microcode_open(struct inode *inode, struct file *file)\r\n{\r\nreturn capable(CAP_SYS_RAWIO) ? nonseekable_open(inode, file) : -EPERM;\r\n}\r\nstatic ssize_t microcode_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nssize_t ret = -EINVAL;\r\nif ((len >> PAGE_SHIFT) > totalram_pages) {\r\npr_err("too much data (max %ld pages)\n", totalram_pages);\r\nreturn ret;\r\n}\r\nget_online_cpus();\r\nmutex_lock(&microcode_mutex);\r\nif (do_microcode_update(buf, len) == 0)\r\nret = (ssize_t)len;\r\nmutex_unlock(&microcode_mutex);\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic int __init microcode_dev_init(void)\r\n{\r\nint error;\r\nerror = misc_register(&microcode_dev);\r\nif (error) {\r\npr_err("can't misc_register on minor=%d\n", MICROCODE_MINOR);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void microcode_dev_exit(void)\r\n{\r\nmisc_deregister(&microcode_dev);\r\n}\r\nstatic int reload_for_cpu(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nint err = 0;\r\nmutex_lock(&microcode_mutex);\r\nif (uci->valid) {\r\nenum ucode_state ustate;\r\nustate = microcode_ops->request_microcode_fw(cpu, &microcode_pdev->dev);\r\nif (ustate == UCODE_OK)\r\napply_microcode_on_target(cpu);\r\nelse\r\nif (ustate == UCODE_ERROR)\r\nerr = -EINVAL;\r\n}\r\nmutex_unlock(&microcode_mutex);\r\nreturn err;\r\n}\r\nstatic ssize_t reload_store(struct sys_device *dev,\r\nstruct sysdev_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nint cpu = dev->id;\r\nint ret = 0;\r\nchar *end;\r\nval = simple_strtoul(buf, &end, 0);\r\nif (end == buf)\r\nreturn -EINVAL;\r\nif (val == 1) {\r\nget_online_cpus();\r\nif (cpu_online(cpu))\r\nret = reload_for_cpu(cpu);\r\nput_online_cpus();\r\n}\r\nif (!ret)\r\nret = size;\r\nreturn ret;\r\n}\r\nstatic ssize_t version_show(struct sys_device *dev,\r\nstruct sysdev_attribute *attr, char *buf)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + dev->id;\r\nreturn sprintf(buf, "0x%x\n", uci->cpu_sig.rev);\r\n}\r\nstatic ssize_t pf_show(struct sys_device *dev,\r\nstruct sysdev_attribute *attr, char *buf)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + dev->id;\r\nreturn sprintf(buf, "0x%x\n", uci->cpu_sig.pf);\r\n}\r\nstatic void microcode_fini_cpu(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nmicrocode_ops->microcode_fini_cpu(cpu);\r\nuci->valid = 0;\r\n}\r\nstatic enum ucode_state microcode_resume_cpu(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nif (!uci->mc)\r\nreturn UCODE_NFOUND;\r\npr_debug("CPU%d updated upon resume\n", cpu);\r\napply_microcode_on_target(cpu);\r\nreturn UCODE_OK;\r\n}\r\nstatic enum ucode_state microcode_init_cpu(int cpu)\r\n{\r\nenum ucode_state ustate;\r\nif (collect_cpu_info(cpu))\r\nreturn UCODE_ERROR;\r\nif (system_state != SYSTEM_RUNNING)\r\nreturn UCODE_NFOUND;\r\nustate = microcode_ops->request_microcode_fw(cpu, &microcode_pdev->dev);\r\nif (ustate == UCODE_OK) {\r\npr_debug("CPU%d updated upon init\n", cpu);\r\napply_microcode_on_target(cpu);\r\n}\r\nreturn ustate;\r\n}\r\nstatic enum ucode_state microcode_update_cpu(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nenum ucode_state ustate;\r\nif (uci->valid)\r\nustate = microcode_resume_cpu(cpu);\r\nelse\r\nustate = microcode_init_cpu(cpu);\r\nreturn ustate;\r\n}\r\nstatic int mc_sysdev_add(struct sys_device *sys_dev)\r\n{\r\nint err, cpu = sys_dev->id;\r\nif (!cpu_online(cpu))\r\nreturn 0;\r\npr_debug("CPU%d added\n", cpu);\r\nerr = sysfs_create_group(&sys_dev->kobj, &mc_attr_group);\r\nif (err)\r\nreturn err;\r\nif (microcode_init_cpu(cpu) == UCODE_ERROR) {\r\nsysfs_remove_group(&sys_dev->kobj, &mc_attr_group);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int mc_sysdev_remove(struct sys_device *sys_dev)\r\n{\r\nint cpu = sys_dev->id;\r\nif (!cpu_online(cpu))\r\nreturn 0;\r\npr_debug("CPU%d removed\n", cpu);\r\nmicrocode_fini_cpu(cpu);\r\nsysfs_remove_group(&sys_dev->kobj, &mc_attr_group);\r\nreturn 0;\r\n}\r\nstatic void mc_bp_resume(void)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nif (uci->valid && uci->mc)\r\nmicrocode_ops->apply_microcode(cpu);\r\n}\r\nstatic __cpuinit int\r\nmc_cpu_callback(struct notifier_block *nb, unsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nstruct sys_device *sys_dev;\r\nsys_dev = get_cpu_sysdev(cpu);\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nmicrocode_update_cpu(cpu);\r\ncase CPU_DOWN_FAILED:\r\ncase CPU_DOWN_FAILED_FROZEN:\r\npr_debug("CPU%d added\n", cpu);\r\nif (sysfs_create_group(&sys_dev->kobj, &mc_attr_group))\r\npr_err("Failed to create group for CPU%d\n", cpu);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\ncase CPU_DOWN_PREPARE_FROZEN:\r\nsysfs_remove_group(&sys_dev->kobj, &mc_attr_group);\r\npr_debug("CPU%d removed\n", cpu);\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_UP_CANCELED_FROZEN:\r\nmicrocode_fini_cpu(cpu);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init microcode_init(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nint error;\r\nif (c->x86_vendor == X86_VENDOR_INTEL)\r\nmicrocode_ops = init_intel_microcode();\r\nelse if (c->x86_vendor == X86_VENDOR_AMD)\r\nmicrocode_ops = init_amd_microcode();\r\nif (!microcode_ops) {\r\npr_err("no support for this CPU vendor\n");\r\nreturn -ENODEV;\r\n}\r\nmicrocode_pdev = platform_device_register_simple("microcode", -1,\r\nNULL, 0);\r\nif (IS_ERR(microcode_pdev)) {\r\nmicrocode_dev_exit();\r\nreturn PTR_ERR(microcode_pdev);\r\n}\r\nget_online_cpus();\r\nmutex_lock(&microcode_mutex);\r\nerror = sysdev_driver_register(&cpu_sysdev_class, &mc_sysdev_driver);\r\nmutex_unlock(&microcode_mutex);\r\nput_online_cpus();\r\nif (error) {\r\nplatform_device_unregister(microcode_pdev);\r\nreturn error;\r\n}\r\nerror = microcode_dev_init();\r\nif (error)\r\nreturn error;\r\nregister_syscore_ops(&mc_syscore_ops);\r\nregister_hotcpu_notifier(&mc_cpu_notifier);\r\npr_info("Microcode Update Driver: v" MICROCODE_VERSION\r\n" <tigran@aivazian.fsnet.co.uk>, Peter Oruba\n");\r\nreturn 0;\r\n}\r\nstatic void __exit microcode_exit(void)\r\n{\r\nmicrocode_dev_exit();\r\nunregister_hotcpu_notifier(&mc_cpu_notifier);\r\nunregister_syscore_ops(&mc_syscore_ops);\r\nget_online_cpus();\r\nmutex_lock(&microcode_mutex);\r\nsysdev_driver_unregister(&cpu_sysdev_class, &mc_sysdev_driver);\r\nmutex_unlock(&microcode_mutex);\r\nput_online_cpus();\r\nplatform_device_unregister(microcode_pdev);\r\nmicrocode_ops = NULL;\r\npr_info("Microcode Update Driver: v" MICROCODE_VERSION " removed.\n");\r\n}
