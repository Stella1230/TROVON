static irqreturn_t l3_interrupt_handler(int irq, void *_l3)\r\n{\r\nstruct omap4_l3 *l3 = _l3;\r\nint inttype, i, j;\r\nint err_src = 0;\r\nu32 std_err_main_addr, std_err_main, err_reg;\r\nu32 base, slave_addr, clear;\r\nchar *source_name;\r\ninttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;\r\nfor (i = 0; i < L3_MODULES; i++) {\r\nbase = (u32)l3->l3_base[i];\r\nerr_reg = readl(base + l3_flagmux[i] + (inttype << 3));\r\nif (err_reg) {\r\nfor (j = 0; !(err_reg & (1 << j)); j++)\r\n;\r\nerr_src = j;\r\nstd_err_main_addr = base + *(l3_targ[i] + err_src);\r\nstd_err_main = readl(std_err_main_addr);\r\nswitch (std_err_main & CUSTOM_ERROR) {\r\ncase STANDARD_ERROR:\r\nsource_name =\r\nl3_targ_stderrlog_main_name[i][err_src];\r\nslave_addr = std_err_main_addr +\r\nL3_SLAVE_ADDRESS_OFFSET;\r\nWARN(true, "L3 standard error: SOURCE:%s at address 0x%x\n",\r\nsource_name, readl(slave_addr));\r\nclear = std_err_main | CLEAR_STDERR_LOG;\r\nwritel(clear, std_err_main_addr);\r\nbreak;\r\ncase CUSTOM_ERROR:\r\nsource_name =\r\nl3_targ_stderrlog_main_name[i][err_src];\r\nWARN(true, "CUSTOM SRESP error with SOURCE:%s\n",\r\nsource_name);\r\nclear = std_err_main | CLEAR_STDERR_LOG;\r\nwritel(clear, std_err_main_addr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init omap4_l3_probe(struct platform_device *pdev)\r\n{\r\nstatic struct omap4_l3 *l3;\r\nstruct resource *res;\r\nint ret;\r\nint irq;\r\nl3 = kzalloc(sizeof(*l3), GFP_KERNEL);\r\nif (!l3)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, l3);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "couldn't find resource 0\n");\r\nret = -ENODEV;\r\ngoto err0;\r\n}\r\nl3->l3_base[0] = ioremap(res->start, resource_size(res));\r\nif (!l3->l3_base[0]) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "couldn't find resource 1\n");\r\nret = -ENODEV;\r\ngoto err1;\r\n}\r\nl3->l3_base[1] = ioremap(res->start, resource_size(res));\r\nif (!l3->l3_base[1]) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (!res) {\r\ndev_err(&pdev->dev, "couldn't find resource 2\n");\r\nret = -ENODEV;\r\ngoto err2;\r\n}\r\nl3->l3_base[2] = ioremap(res->start, resource_size(res));\r\nif (!l3->l3_base[2]) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nret = request_irq(irq,\r\nl3_interrupt_handler,\r\nIRQF_DISABLED, "l3-dbg-irq", l3);\r\nif (ret) {\r\npr_crit("L3: request_irq failed to register for 0x%x\n",\r\nOMAP44XX_IRQ_L3_DBG);\r\ngoto err3;\r\n}\r\nl3->debug_irq = irq;\r\nirq = platform_get_irq(pdev, 1);\r\nret = request_irq(irq,\r\nl3_interrupt_handler,\r\nIRQF_DISABLED, "l3-app-irq", l3);\r\nif (ret) {\r\npr_crit("L3: request_irq failed to register for 0x%x\n",\r\nOMAP44XX_IRQ_L3_APP);\r\ngoto err4;\r\n}\r\nl3->app_irq = irq;\r\nreturn 0;\r\nerr4:\r\nfree_irq(l3->debug_irq, l3);\r\nerr3:\r\niounmap(l3->l3_base[2]);\r\nerr2:\r\niounmap(l3->l3_base[1]);\r\nerr1:\r\niounmap(l3->l3_base[0]);\r\nerr0:\r\nkfree(l3);\r\nreturn ret;\r\n}\r\nstatic int __exit omap4_l3_remove(struct platform_device *pdev)\r\n{\r\nstruct omap4_l3 *l3 = platform_get_drvdata(pdev);\r\nfree_irq(l3->app_irq, l3);\r\nfree_irq(l3->debug_irq, l3);\r\niounmap(l3->l3_base[0]);\r\niounmap(l3->l3_base[1]);\r\niounmap(l3->l3_base[2]);\r\nkfree(l3);\r\nreturn 0;\r\n}\r\nstatic int __init omap4_l3_init(void)\r\n{\r\nreturn platform_driver_probe(&omap4_l3_driver, omap4_l3_probe);\r\n}\r\nstatic void __exit omap4_l3_exit(void)\r\n{\r\nplatform_driver_unregister(&omap4_l3_driver);\r\n}
