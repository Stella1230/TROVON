static struct phonet_protocol *phonet_proto_get(unsigned int protocol)\r\n{\r\nstruct phonet_protocol *pp;\r\nif (protocol >= PHONET_NPROTO)\r\nreturn NULL;\r\nrcu_read_lock();\r\npp = rcu_dereference(proto_tab[protocol]);\r\nif (pp && !try_module_get(pp->prot->owner))\r\npp = NULL;\r\nrcu_read_unlock();\r\nreturn pp;\r\n}\r\nstatic inline void phonet_proto_put(struct phonet_protocol *pp)\r\n{\r\nmodule_put(pp->prot->owner);\r\n}\r\nstatic int pn_socket_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nstruct pn_sock *pn;\r\nstruct phonet_protocol *pnp;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (protocol == 0) {\r\nswitch (sock->type) {\r\ncase SOCK_DGRAM:\r\nprotocol = PN_PROTO_PHONET;\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\nprotocol = PN_PROTO_PIPE;\r\nbreak;\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\n}\r\npnp = phonet_proto_get(protocol);\r\nif (pnp == NULL &&\r\nrequest_module("net-pf-%d-proto-%d", PF_PHONET, protocol) == 0)\r\npnp = phonet_proto_get(protocol);\r\nif (pnp == NULL)\r\nreturn -EPROTONOSUPPORT;\r\nif (sock->type != pnp->sock_type) {\r\nerr = -EPROTONOSUPPORT;\r\ngoto out;\r\n}\r\nsk = sk_alloc(net, PF_PHONET, GFP_KERNEL, pnp->prot);\r\nif (sk == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nsock_init_data(sock, sk);\r\nsock->state = SS_UNCONNECTED;\r\nsock->ops = pnp->ops;\r\nsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\r\nsk->sk_protocol = protocol;\r\npn = pn_sk(sk);\r\npn->sobject = 0;\r\npn->dobject = 0;\r\npn->resource = 0;\r\nsk->sk_prot->init(sk);\r\nerr = 0;\r\nout:\r\nphonet_proto_put(pnp);\r\nreturn err;\r\n}\r\nstatic int pn_header_create(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned len)\r\n{\r\nu8 *media = skb_push(skb, 1);\r\nif (type != ETH_P_PHONET)\r\nreturn -1;\r\nif (!saddr)\r\nsaddr = dev->dev_addr;\r\n*media = *(const u8 *)saddr;\r\nreturn 1;\r\n}\r\nstatic int pn_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nconst u8 *media = skb_mac_header(skb);\r\n*haddr = *media;\r\nreturn 1;\r\n}\r\nstatic int pn_send(struct sk_buff *skb, struct net_device *dev,\r\nu16 dst, u16 src, u8 res, u8 irq)\r\n{\r\nstruct phonethdr *ph;\r\nint err;\r\nif (skb->len + 2 > 0xffff ||\r\nskb->len + sizeof(struct phonethdr) > dev->mtu) {\r\nerr = -EMSGSIZE;\r\ngoto drop;\r\n}\r\nif (pn_addr(dst) == PNADDR_BROADCAST) {\r\nerr = -EOPNOTSUPP;\r\ngoto drop;\r\n}\r\nskb_reset_transport_header(skb);\r\nWARN_ON(skb_headroom(skb) & 1);\r\nskb_push(skb, sizeof(struct phonethdr));\r\nskb_reset_network_header(skb);\r\nph = pn_hdr(skb);\r\nph->pn_rdev = pn_dev(dst);\r\nph->pn_sdev = pn_dev(src);\r\nph->pn_res = res;\r\nph->pn_length = __cpu_to_be16(skb->len + 2 - sizeof(*ph));\r\nph->pn_robj = pn_obj(dst);\r\nph->pn_sobj = pn_obj(src);\r\nskb->protocol = htons(ETH_P_PHONET);\r\nskb->priority = 0;\r\nskb->dev = dev;\r\nif (skb->pkt_type == PACKET_LOOPBACK) {\r\nskb_reset_mac_header(skb);\r\nskb_orphan(skb);\r\nerr = (irq ? netif_rx(skb) : netif_rx_ni(skb)) ? -ENOBUFS : 0;\r\n} else {\r\nerr = dev_hard_header(skb, dev, ntohs(skb->protocol),\r\nNULL, NULL, skb->len);\r\nif (err < 0) {\r\nerr = -EHOSTUNREACH;\r\ngoto drop;\r\n}\r\nerr = dev_queue_xmit(skb);\r\nif (unlikely(err > 0))\r\nerr = net_xmit_errno(err);\r\n}\r\nreturn err;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int pn_raw_send(const void *data, int len, struct net_device *dev,\r\nu16 dst, u16 src, u8 res)\r\n{\r\nstruct sk_buff *skb = alloc_skb(MAX_PHONET_HEADER + len, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (phonet_address_lookup(dev_net(dev), pn_addr(dst)) == 0)\r\nskb->pkt_type = PACKET_LOOPBACK;\r\nskb_reserve(skb, MAX_PHONET_HEADER);\r\n__skb_put(skb, len);\r\nskb_copy_to_linear_data(skb, data, len);\r\nreturn pn_send(skb, dev, dst, src, res, 1);\r\n}\r\nint pn_skb_send(struct sock *sk, struct sk_buff *skb,\r\nconst struct sockaddr_pn *target)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct net_device *dev;\r\nstruct pn_sock *pn = pn_sk(sk);\r\nint err;\r\nu16 src, dst;\r\nu8 daddr, saddr, res;\r\nsrc = pn->sobject;\r\nif (target != NULL) {\r\ndst = pn_sockaddr_get_object(target);\r\nres = pn_sockaddr_get_resource(target);\r\n} else {\r\ndst = pn->dobject;\r\nres = pn->resource;\r\n}\r\ndaddr = pn_addr(dst);\r\nerr = -EHOSTUNREACH;\r\nif (sk->sk_bound_dev_if)\r\ndev = dev_get_by_index(net, sk->sk_bound_dev_if);\r\nelse if (phonet_address_lookup(net, daddr) == 0) {\r\ndev = phonet_device_get(net);\r\nskb->pkt_type = PACKET_LOOPBACK;\r\n} else if (dst == 0) {\r\nstruct sock *sk = pn_find_sock_by_res(net, res);\r\nif (sk) {\r\nsock_put(sk);\r\ndev = phonet_device_get(net);\r\nskb->pkt_type = PACKET_LOOPBACK;\r\n} else\r\ndev = phonet_route_output(net, daddr);\r\n} else\r\ndev = phonet_route_output(net, daddr);\r\nif (!dev || !(dev->flags & IFF_UP))\r\ngoto drop;\r\nsaddr = phonet_address_get(dev, daddr);\r\nif (saddr == PN_NO_ADDR)\r\ngoto drop;\r\nif (!pn_addr(src))\r\nsrc = pn_object(saddr, pn_obj(src));\r\nerr = pn_send(skb, dev, dst, src, res, 0);\r\ndev_put(dev);\r\nreturn err;\r\ndrop:\r\nkfree_skb(skb);\r\nif (dev)\r\ndev_put(dev);\r\nreturn err;\r\n}\r\nstatic inline int can_respond(struct sk_buff *skb)\r\n{\r\nconst struct phonethdr *ph;\r\nconst struct phonetmsg *pm;\r\nu8 submsg_id;\r\nif (!pskb_may_pull(skb, 3))\r\nreturn 0;\r\nph = pn_hdr(skb);\r\nif (ph->pn_res == PN_PREFIX && !pskb_may_pull(skb, 5))\r\nreturn 0;\r\nif (ph->pn_res == PN_COMMGR)\r\nreturn 0;\r\nph = pn_hdr(skb);\r\npm = pn_msg(skb);\r\nif (pm->pn_msg_id != PN_COMMON_MESSAGE)\r\nreturn 1;\r\nsubmsg_id = (ph->pn_res == PN_PREFIX)\r\n? pm->pn_e_submsg_id : pm->pn_submsg_id;\r\nif (submsg_id != PN_COMM_ISA_ENTITY_NOT_REACHABLE_RESP &&\r\npm->pn_e_submsg_id != PN_COMM_SERVICE_NOT_IDENTIFIED_RESP)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int send_obj_unreachable(struct sk_buff *rskb)\r\n{\r\nconst struct phonethdr *oph = pn_hdr(rskb);\r\nconst struct phonetmsg *opm = pn_msg(rskb);\r\nstruct phonetmsg resp;\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.pn_trans_id = opm->pn_trans_id;\r\nresp.pn_msg_id = PN_COMMON_MESSAGE;\r\nif (oph->pn_res == PN_PREFIX) {\r\nresp.pn_e_res_id = opm->pn_e_res_id;\r\nresp.pn_e_submsg_id = PN_COMM_ISA_ENTITY_NOT_REACHABLE_RESP;\r\nresp.pn_e_orig_msg_id = opm->pn_msg_id;\r\nresp.pn_e_status = 0;\r\n} else {\r\nresp.pn_submsg_id = PN_COMM_ISA_ENTITY_NOT_REACHABLE_RESP;\r\nresp.pn_orig_msg_id = opm->pn_msg_id;\r\nresp.pn_status = 0;\r\n}\r\nreturn pn_raw_send(&resp, sizeof(resp), rskb->dev,\r\npn_object(oph->pn_sdev, oph->pn_sobj),\r\npn_object(oph->pn_rdev, oph->pn_robj),\r\noph->pn_res);\r\n}\r\nstatic int send_reset_indications(struct sk_buff *rskb)\r\n{\r\nstruct phonethdr *oph = pn_hdr(rskb);\r\nstatic const u8 data[4] = {\r\n0x00 , 0x10 ,\r\n0x00 , 0x00\r\n};\r\nreturn pn_raw_send(data, sizeof(data), rskb->dev,\r\npn_object(oph->pn_sdev, 0x00),\r\npn_object(oph->pn_rdev, oph->pn_robj),\r\nPN_COMMGR);\r\n}\r\nstatic int phonet_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pkttype,\r\nstruct net_device *orig_dev)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct phonethdr *ph;\r\nstruct sockaddr_pn sa;\r\nu16 len;\r\nif (!pskb_pull(skb, sizeof(struct phonethdr)))\r\ngoto out;\r\nph = pn_hdr(skb);\r\nlen = get_unaligned_be16(&ph->pn_length);\r\nif (len < 2)\r\ngoto out;\r\nlen -= 2;\r\nif ((len > skb->len) || pskb_trim(skb, len))\r\ngoto out;\r\nskb_reset_transport_header(skb);\r\npn_skb_get_dst_sockaddr(skb, &sa);\r\nif (pn_sockaddr_get_addr(&sa) == PNADDR_BROADCAST) {\r\npn_deliver_sock_broadcast(net, skb);\r\ngoto out;\r\n}\r\nif (pn_sockaddr_get_object(&sa) == 0) {\r\nstruct sock *sk = pn_find_sock_by_res(net, sa.spn_resource);\r\nif (sk)\r\nreturn sk_receive_skb(sk, skb, 0);\r\n}\r\nif (phonet_address_lookup(net, pn_sockaddr_get_addr(&sa)) == 0) {\r\nstruct sock *sk = pn_find_sock_by_sa(net, &sa);\r\nif (sk)\r\nreturn sk_receive_skb(sk, skb, 0);\r\nif (can_respond(skb)) {\r\nsend_obj_unreachable(skb);\r\nsend_reset_indications(skb);\r\n}\r\n} else if (unlikely(skb->pkt_type == PACKET_LOOPBACK))\r\ngoto out;\r\nelse {\r\nstruct net_device *out_dev;\r\nout_dev = phonet_route_output(net, pn_sockaddr_get_addr(&sa));\r\nif (!out_dev) {\r\nLIMIT_NETDEBUG(KERN_WARNING"No Phonet route to %02X\n",\r\npn_sockaddr_get_addr(&sa));\r\ngoto out;\r\n}\r\n__skb_push(skb, sizeof(struct phonethdr));\r\nskb->dev = out_dev;\r\nif (out_dev == dev) {\r\nLIMIT_NETDEBUG(KERN_ERR"Phonet loop to %02X on %s\n",\r\npn_sockaddr_get_addr(&sa), dev->name);\r\ngoto out_dev;\r\n}\r\nif (skb_cow_head(skb, out_dev->hard_header_len))\r\ngoto out_dev;\r\nif (dev_hard_header(skb, out_dev, ETH_P_PHONET, NULL, NULL,\r\nskb->len) < 0)\r\ngoto out_dev;\r\ndev_queue_xmit(skb);\r\ndev_put(out_dev);\r\nreturn NET_RX_SUCCESS;\r\nout_dev:\r\ndev_put(out_dev);\r\n}\r\nout:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nint __init_or_module phonet_proto_register(unsigned int protocol,\r\nstruct phonet_protocol *pp)\r\n{\r\nint err = 0;\r\nif (protocol >= PHONET_NPROTO)\r\nreturn -EINVAL;\r\nerr = proto_register(pp->prot, 1);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&proto_tab_lock);\r\nif (proto_tab[protocol])\r\nerr = -EBUSY;\r\nelse\r\nrcu_assign_pointer(proto_tab[protocol], pp);\r\nmutex_unlock(&proto_tab_lock);\r\nreturn err;\r\n}\r\nvoid phonet_proto_unregister(unsigned int protocol, struct phonet_protocol *pp)\r\n{\r\nmutex_lock(&proto_tab_lock);\r\nBUG_ON(proto_tab[protocol] != pp);\r\nrcu_assign_pointer(proto_tab[protocol], NULL);\r\nmutex_unlock(&proto_tab_lock);\r\nsynchronize_rcu();\r\nproto_unregister(pp->prot);\r\n}\r\nstatic int __init phonet_init(void)\r\n{\r\nint err;\r\nerr = phonet_device_init();\r\nif (err)\r\nreturn err;\r\npn_sock_init();\r\nerr = sock_register(&phonet_proto_family);\r\nif (err) {\r\nprintk(KERN_ALERT\r\n"phonet protocol family initialization failed\n");\r\ngoto err_sock;\r\n}\r\ndev_add_pack(&phonet_packet_type);\r\nphonet_sysctl_init();\r\nerr = isi_register();\r\nif (err)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nphonet_sysctl_exit();\r\nsock_unregister(PF_PHONET);\r\ndev_remove_pack(&phonet_packet_type);\r\nerr_sock:\r\nphonet_device_exit();\r\nreturn err;\r\n}\r\nstatic void __exit phonet_exit(void)\r\n{\r\nisi_unregister();\r\nphonet_sysctl_exit();\r\nsock_unregister(PF_PHONET);\r\ndev_remove_pack(&phonet_packet_type);\r\nphonet_device_exit();\r\n}
