struct cflayer *cfserl_create(int type, int instance, bool use_stx)\r\n{\r\nstruct cfserl *this = kmalloc(sizeof(struct cfserl), GFP_ATOMIC);\r\nif (!this) {\r\npr_warn("Out of memory\n");\r\nreturn NULL;\r\n}\r\ncaif_assert(offsetof(struct cfserl, layer) == 0);\r\nmemset(this, 0, sizeof(struct cfserl));\r\nthis->layer.receive = cfserl_receive;\r\nthis->layer.transmit = cfserl_transmit;\r\nthis->layer.ctrlcmd = cfserl_ctrlcmd;\r\nthis->layer.type = type;\r\nthis->usestx = use_stx;\r\nspin_lock_init(&this->sync);\r\nsnprintf(this->layer.name, CAIF_LAYER_NAME_SZ, "ser1");\r\nreturn &this->layer;\r\n}\r\nstatic int cfserl_receive(struct cflayer *l, struct cfpkt *newpkt)\r\n{\r\nstruct cfserl *layr = container_obj(l);\r\nu16 pkt_len;\r\nstruct cfpkt *pkt = NULL;\r\nstruct cfpkt *tail_pkt = NULL;\r\nu8 tmp8;\r\nu16 tmp;\r\nu8 stx = CFSERL_STX;\r\nint ret;\r\nu16 expectlen = 0;\r\ncaif_assert(newpkt != NULL);\r\nspin_lock(&layr->sync);\r\nif (layr->incomplete_frm != NULL) {\r\nlayr->incomplete_frm =\r\ncfpkt_append(layr->incomplete_frm, newpkt, expectlen);\r\npkt = layr->incomplete_frm;\r\nif (pkt == NULL) {\r\nspin_unlock(&layr->sync);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\npkt = newpkt;\r\n}\r\nlayr->incomplete_frm = NULL;\r\ndo {\r\nif (layr->usestx) {\r\ncfpkt_extr_head(pkt, &tmp8, 1);\r\nif (tmp8 != CFSERL_STX) {\r\nwhile (cfpkt_more(pkt)\r\n&& tmp8 != CFSERL_STX) {\r\ncfpkt_extr_head(pkt, &tmp8, 1);\r\n}\r\nif (!cfpkt_more(pkt)) {\r\ncfpkt_destroy(pkt);\r\nlayr->incomplete_frm = NULL;\r\nspin_unlock(&layr->sync);\r\nreturn -EPROTO;\r\n}\r\n}\r\n}\r\npkt_len = cfpkt_getlen(pkt);\r\nif (pkt_len < 2) {\r\nif (layr->usestx)\r\ncfpkt_add_head(pkt, &stx, 1);\r\nlayr->incomplete_frm = pkt;\r\nspin_unlock(&layr->sync);\r\nreturn 0;\r\n}\r\ncfpkt_peek_head(pkt, &tmp, 2);\r\nexpectlen = le16_to_cpu(tmp) + 2;\r\nif (expectlen < SERIAL_MINIUM_PACKET_SIZE\r\n|| expectlen > SERIAL_MAX_FRAMESIZE) {\r\nif (!layr->usestx) {\r\nif (pkt != NULL)\r\ncfpkt_destroy(pkt);\r\nlayr->incomplete_frm = NULL;\r\nexpectlen = 0;\r\nspin_unlock(&layr->sync);\r\nreturn -EPROTO;\r\n}\r\ncontinue;\r\n}\r\nif (pkt_len < expectlen) {\r\nif (layr->usestx)\r\ncfpkt_add_head(pkt, &stx, 1);\r\nlayr->incomplete_frm = pkt;\r\nspin_unlock(&layr->sync);\r\nreturn 0;\r\n}\r\nif (pkt_len > expectlen)\r\ntail_pkt = cfpkt_split(pkt, expectlen);\r\nelse\r\ntail_pkt = NULL;\r\nspin_unlock(&layr->sync);\r\nret = layr->layer.up->receive(layr->layer.up, pkt);\r\nspin_lock(&layr->sync);\r\nif (ret == -EILSEQ) {\r\nif (layr->usestx) {\r\nif (tail_pkt != NULL)\r\npkt = cfpkt_append(pkt, tail_pkt, 0);\r\ncontinue;\r\n} else {\r\ncfpkt_destroy(pkt);\r\npkt = NULL;\r\n}\r\n}\r\npkt = tail_pkt;\r\n} while (pkt != NULL);\r\nspin_unlock(&layr->sync);\r\nreturn 0;\r\n}\r\nstatic int cfserl_transmit(struct cflayer *layer, struct cfpkt *newpkt)\r\n{\r\nstruct cfserl *layr = container_obj(layer);\r\nu8 tmp8 = CFSERL_STX;\r\nif (layr->usestx)\r\ncfpkt_add_head(newpkt, &tmp8, 1);\r\nreturn layer->dn->transmit(layer->dn, newpkt);\r\n}\r\nstatic void cfserl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\r\nint phyid)\r\n{\r\nlayr->up->ctrlcmd(layr->up, ctrl, phyid);\r\n}
