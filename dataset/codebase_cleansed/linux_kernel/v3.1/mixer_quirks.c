static void snd_usb_soundblaster_remote_complete(struct urb *urb)\r\n{\r\nstruct usb_mixer_interface *mixer = urb->context;\r\nconst struct rc_config *rc = mixer->rc_cfg;\r\nu32 code;\r\nif (urb->status < 0 || urb->actual_length < rc->min_packet_length)\r\nreturn;\r\ncode = mixer->rc_buffer[rc->offset];\r\nif (rc->length == 2)\r\ncode |= mixer->rc_buffer[rc->offset + 1] << 8;\r\nif (code == rc->mute_code)\r\nsnd_usb_mixer_notify_id(mixer, rc->mute_mixer_id);\r\nmixer->rc_code = code;\r\nwmb();\r\nwake_up(&mixer->rc_waitq);\r\n}\r\nstatic long snd_usb_sbrc_hwdep_read(struct snd_hwdep *hw, char __user *buf,\r\nlong count, loff_t *offset)\r\n{\r\nstruct usb_mixer_interface *mixer = hw->private_data;\r\nint err;\r\nu32 rc_code;\r\nif (count != 1 && count != 4)\r\nreturn -EINVAL;\r\nerr = wait_event_interruptible(mixer->rc_waitq,\r\n(rc_code = xchg(&mixer->rc_code, 0)) != 0);\r\nif (err == 0) {\r\nif (count == 1)\r\nerr = put_user(rc_code, buf);\r\nelse\r\nerr = put_user(rc_code, (u32 __user *)buf);\r\n}\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic unsigned int snd_usb_sbrc_hwdep_poll(struct snd_hwdep *hw, struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct usb_mixer_interface *mixer = hw->private_data;\r\npoll_wait(file, &mixer->rc_waitq, wait);\r\nreturn mixer->rc_code ? POLLIN | POLLRDNORM : 0;\r\n}\r\nstatic int snd_usb_soundblaster_remote_init(struct usb_mixer_interface *mixer)\r\n{\r\nstruct snd_hwdep *hwdep;\r\nint err, len, i;\r\nfor (i = 0; i < ARRAY_SIZE(rc_configs); ++i)\r\nif (rc_configs[i].usb_id == mixer->chip->usb_id)\r\nbreak;\r\nif (i >= ARRAY_SIZE(rc_configs))\r\nreturn 0;\r\nmixer->rc_cfg = &rc_configs[i];\r\nlen = mixer->rc_cfg->packet_length;\r\ninit_waitqueue_head(&mixer->rc_waitq);\r\nerr = snd_hwdep_new(mixer->chip->card, "SB remote control", 0, &hwdep);\r\nif (err < 0)\r\nreturn err;\r\nsnprintf(hwdep->name, sizeof(hwdep->name),\r\n"%s remote control", mixer->chip->card->shortname);\r\nhwdep->iface = SNDRV_HWDEP_IFACE_SB_RC;\r\nhwdep->private_data = mixer;\r\nhwdep->ops.read = snd_usb_sbrc_hwdep_read;\r\nhwdep->ops.poll = snd_usb_sbrc_hwdep_poll;\r\nhwdep->exclusive = 1;\r\nmixer->rc_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!mixer->rc_urb)\r\nreturn -ENOMEM;\r\nmixer->rc_setup_packet = kmalloc(sizeof(*mixer->rc_setup_packet), GFP_KERNEL);\r\nif (!mixer->rc_setup_packet) {\r\nusb_free_urb(mixer->rc_urb);\r\nmixer->rc_urb = NULL;\r\nreturn -ENOMEM;\r\n}\r\nmixer->rc_setup_packet->bRequestType =\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;\r\nmixer->rc_setup_packet->bRequest = UAC_GET_MEM;\r\nmixer->rc_setup_packet->wValue = cpu_to_le16(0);\r\nmixer->rc_setup_packet->wIndex = cpu_to_le16(0);\r\nmixer->rc_setup_packet->wLength = cpu_to_le16(len);\r\nusb_fill_control_urb(mixer->rc_urb, mixer->chip->dev,\r\nusb_rcvctrlpipe(mixer->chip->dev, 0),\r\n(u8*)mixer->rc_setup_packet, mixer->rc_buffer, len,\r\nsnd_usb_soundblaster_remote_complete, mixer);\r\nreturn 0;\r\n}\r\nstatic int snd_audigy2nx_led_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nucontrol->value.integer.value[0] = mixer->audigy2nx_leds[index];\r\nreturn 0;\r\n}\r\nstatic int snd_audigy2nx_led_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nint value = ucontrol->value.integer.value[0];\r\nint err, changed;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nchanged = value != mixer->audigy2nx_leds[index];\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x3042))\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n!value, 0, NULL, 0, 100);\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x30df))\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n!value, 0, NULL, 0, 100);\r\nelse\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), 0x24,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\nvalue, index + 2, NULL, 0, 100);\r\nif (err < 0)\r\nreturn err;\r\nmixer->audigy2nx_leds[index] = value;\r\nreturn changed;\r\n}\r\nstatic int snd_audigy2nx_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint i, err;\r\nfor (i = 0; i < ARRAY_SIZE(snd_audigy2nx_controls); ++i) {\r\nif ((mixer->chip->usb_id == USB_ID(0x041e, 0x3042)) && i == 0)\r\ncontinue;\r\nif ((mixer->chip->usb_id == USB_ID(0x041e, 0x30df)) && i == 0)\r\ncontinue;\r\nif (i > 1 &&\r\n(mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3042) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x30df) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048)))\r\nbreak;\r\nerr = snd_ctl_add(mixer->chip->card,\r\nsnd_ctl_new1(&snd_audigy2nx_controls[i], mixer));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nmixer->audigy2nx_leds[1] = 1;\r\nreturn 0;\r\n}\r\nstatic void snd_audigy2nx_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstatic const struct sb_jack {\r\nint unitid;\r\nconst char *name;\r\n} jacks_audigy2nx[] = {\r\n{4, "dig in "},\r\n{7, "line in"},\r\n{19, "spk out"},\r\n{20, "hph out"},\r\n{-1, NULL}\r\n}, jacks_live24ext[] = {\r\n{4, "line in"},\r\n{3, "hph out"},\r\n{0, "RC "},\r\n{-1, NULL}\r\n};\r\nconst struct sb_jack *jacks;\r\nstruct usb_mixer_interface *mixer = entry->private_data;\r\nint i, err;\r\nu8 buf[3];\r\nsnd_iprintf(buffer, "%s jacks\n\n", mixer->chip->card->shortname);\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x3020))\r\njacks = jacks_audigy2nx;\r\nelse if (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048))\r\njacks = jacks_live24ext;\r\nelse\r\nreturn;\r\nfor (i = 0; jacks[i].name; ++i) {\r\nsnd_iprintf(buffer, "%s: ", jacks[i].name);\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_rcvctrlpipe(mixer->chip->dev, 0),\r\nUAC_GET_MEM, USB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE, 0,\r\njacks[i].unitid << 8, buf, 3, 100);\r\nif (err == 3 && (buf[0] == 3 || buf[0] == 6))\r\nsnd_iprintf(buffer, "%02x %02x\n", buf[1], buf[2]);\r\nelse\r\nsnd_iprintf(buffer, "?\n");\r\n}\r\n}\r\nstatic int snd_xonar_u1_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = !!(mixer->xonar_u1_status & 0x02);\r\nreturn 0;\r\n}\r\nstatic int snd_xonar_u1_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nu8 old_status, new_status;\r\nint err, changed;\r\nold_status = mixer->xonar_u1_status;\r\nif (ucontrol->value.integer.value[0])\r\nnew_status = old_status | 0x02;\r\nelse\r\nnew_status = old_status & ~0x02;\r\nchanged = new_status != old_status;\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), 0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,\r\n50, 0, &new_status, 1, 100);\r\nif (err < 0)\r\nreturn err;\r\nmixer->xonar_u1_status = new_status;\r\nreturn changed;\r\n}\r\nstatic int snd_xonar_u1_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint err;\r\nerr = snd_ctl_add(mixer->chip->card,\r\nsnd_ctl_new1(&snd_xonar_u1_output_switch, mixer));\r\nif (err < 0)\r\nreturn err;\r\nmixer->xonar_u1_status = 0x05;\r\nreturn 0;\r\n}\r\nstatic int snd_nativeinstruments_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nstruct usb_device *dev = mixer->chip->dev;\r\nu8 bRequest = (kcontrol->private_value >> 16) & 0xff;\r\nu16 wIndex = kcontrol->private_value & 0xffff;\r\nu8 tmp;\r\nint ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), bRequest,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0, cpu_to_le16(wIndex),\r\n&tmp, sizeof(tmp), 1000);\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR\r\n"unable to issue vendor read request (ret = %d)", ret);\r\nreturn ret;\r\n}\r\nucontrol->value.integer.value[0] = tmp;\r\nreturn 0;\r\n}\r\nstatic int snd_nativeinstruments_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);\r\nstruct usb_device *dev = mixer->chip->dev;\r\nu8 bRequest = (kcontrol->private_value >> 16) & 0xff;\r\nu16 wIndex = kcontrol->private_value & 0xffff;\r\nu16 wValue = ucontrol->value.integer.value[0];\r\nint ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), bRequest,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\ncpu_to_le16(wValue), cpu_to_le16(wIndex),\r\nNULL, 0, 1000);\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR\r\n"unable to issue vendor write request (ret = %d)", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_nativeinstruments_create_mixer(struct usb_mixer_interface *mixer,\r\nconst struct snd_kcontrol_new *kc,\r\nunsigned int count)\r\n{\r\nint i, err = 0;\r\nstruct snd_kcontrol_new template = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\r\n.get = snd_nativeinstruments_control_get,\r\n.put = snd_nativeinstruments_control_put,\r\n.info = snd_ctl_boolean_mono_info,\r\n};\r\nfor (i = 0; i < count; i++) {\r\nstruct snd_kcontrol *c;\r\ntemplate.name = kc[i].name;\r\ntemplate.private_value = kc[i].private_value;\r\nc = snd_ctl_new1(&template, mixer);\r\nerr = snd_ctl_add(mixer->chip->card, c);\r\nif (err < 0)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void usb_mixer_elem_free(struct snd_kcontrol *kctl)\r\n{\r\nkfree(kctl->private_data);\r\nkctl->private_data = NULL;\r\n}\r\nstatic int snd_maudio_ftu_create_ctl(struct usb_mixer_interface *mixer,\r\nint in, int out, const char *name)\r\n{\r\nstruct usb_mixer_elem_info *cval;\r\nstruct snd_kcontrol *kctl;\r\ncval = kzalloc(sizeof(*cval), GFP_KERNEL);\r\nif (!cval)\r\nreturn -ENOMEM;\r\ncval->id = 5;\r\ncval->mixer = mixer;\r\ncval->val_type = USB_MIXER_S16;\r\ncval->channels = 1;\r\ncval->control = out + 1;\r\ncval->cmask = 1 << in;\r\nkctl = snd_ctl_new1(snd_usb_feature_unit_ctl, cval);\r\nif (!kctl) {\r\nkfree(cval);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(kctl->id.name, sizeof(kctl->id.name), name);\r\nkctl->private_free = usb_mixer_elem_free;\r\nreturn snd_usb_mixer_add_control(mixer, kctl);\r\n}\r\nstatic int snd_maudio_ftu_create_mixer(struct usb_mixer_interface *mixer)\r\n{\r\nchar name[64];\r\nint in, out, err;\r\nfor (out = 0; out < 8; out++) {\r\nfor (in = 0; in < 8; in++) {\r\nsnprintf(name, sizeof(name),\r\n"AIn%d - Out%d Capture Volume", in + 1, out + 1);\r\nerr = snd_maudio_ftu_create_ctl(mixer, in, out, name);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (in = 8; in < 16; in++) {\r\nsnprintf(name, sizeof(name),\r\n"DIn%d - Out%d Playback Volume", in - 7, out + 1);\r\nerr = snd_maudio_ftu_create_ctl(mixer, in, out, name);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_emuusb_set_samplerate(struct snd_usb_audio *chip,\r\nunsigned char samplerate_id)\r\n{\r\nstruct usb_mixer_interface *mixer;\r\nstruct usb_mixer_elem_info *cval;\r\nint unitid = 12;\r\nlist_for_each_entry(mixer, &chip->mixer_list, list) {\r\ncval = mixer->id_elems[unitid];\r\nif (cval) {\r\nsnd_usb_mixer_set_ctl_value(cval, UAC_SET_CUR,\r\ncval->control << 8,\r\nsamplerate_id);\r\nsnd_usb_mixer_notify_id(mixer, unitid);\r\n}\r\nbreak;\r\n}\r\n}\r\nint snd_usb_mixer_apply_create_quirk(struct usb_mixer_interface *mixer)\r\n{\r\nint err = 0;\r\nstruct snd_info_entry *entry;\r\nif ((err = snd_usb_soundblaster_remote_init(mixer)) < 0)\r\nreturn err;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x041e, 0x3020):\r\ncase USB_ID(0x041e, 0x3040):\r\ncase USB_ID(0x041e, 0x3042):\r\ncase USB_ID(0x041e, 0x30df):\r\ncase USB_ID(0x041e, 0x3048):\r\nerr = snd_audigy2nx_controls_create(mixer);\r\nif (err < 0)\r\nbreak;\r\nif (!snd_card_proc_new(mixer->chip->card, "audigy2nx", &entry))\r\nsnd_info_set_text_ops(entry, mixer,\r\nsnd_audigy2nx_proc_read);\r\nbreak;\r\ncase USB_ID(0x0763, 0x2080):\r\ncase USB_ID(0x0763, 0x2081):\r\nerr = snd_maudio_ftu_create_mixer(mixer);\r\nbreak;\r\ncase USB_ID(0x0b05, 0x1739):\r\ncase USB_ID(0x0b05, 0x1743):\r\nerr = snd_xonar_u1_controls_create(mixer);\r\nbreak;\r\ncase USB_ID(0x17cc, 0x1011):\r\nerr = snd_nativeinstruments_create_mixer(mixer,\r\nsnd_nativeinstruments_ta6_mixers,\r\nARRAY_SIZE(snd_nativeinstruments_ta6_mixers));\r\nbreak;\r\ncase USB_ID(0x17cc, 0x1021):\r\nerr = snd_nativeinstruments_create_mixer(mixer,\r\nsnd_nativeinstruments_ta10_mixers,\r\nARRAY_SIZE(snd_nativeinstruments_ta10_mixers));\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nvoid snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,\r\nint unitid)\r\n{\r\nif (!mixer->rc_cfg)\r\nreturn;\r\nswitch (unitid) {\r\ncase 0:\r\nmixer->rc_urb->dev = mixer->chip->dev;\r\nusb_submit_urb(mixer->rc_urb, GFP_ATOMIC);\r\nbreak;\r\ncase 4:\r\ncase 7:\r\ncase 19:\r\ncase 20:\r\nbreak;\r\ncase 3:\r\nif (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||\r\nmixer->chip->usb_id == USB_ID(0x041e, 0x3048))\r\nsnd_usb_mixer_notify_id(mixer, mixer->rc_cfg->mute_mixer_id);\r\nbreak;\r\ndefault:\r\nsnd_printd(KERN_DEBUG "memory change in unknown unit %d\n", unitid);\r\nbreak;\r\n}\r\n}
