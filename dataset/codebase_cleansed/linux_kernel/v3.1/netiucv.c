static inline int iucv_dbf_passes(debug_info_t *dbf_grp, int level)\r\n{\r\nreturn (level <= dbf_grp->level);\r\n}\r\nstatic inline void netiucv_clear_busy(struct net_device *dev)\r\n{\r\nstruct netiucv_priv *priv = netdev_priv(dev);\r\nclear_bit(0, &priv->tbusy);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic inline int netiucv_test_and_set_busy(struct net_device *dev)\r\n{\r\nstruct netiucv_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nreturn test_and_set_bit(0, &priv->tbusy);\r\n}\r\nstatic char *netiucv_printname(char *name)\r\n{\r\nstatic char tmp[9];\r\nchar *p = tmp;\r\nmemcpy(tmp, name, 8);\r\ntmp[8] = '\0';\r\nwhile (*p && (!isspace(*p)))\r\np++;\r\n*p = '\0';\r\nreturn tmp;\r\n}\r\nstatic void iucv_unregister_dbf_views(void)\r\n{\r\nif (iucv_dbf_setup)\r\ndebug_unregister(iucv_dbf_setup);\r\nif (iucv_dbf_data)\r\ndebug_unregister(iucv_dbf_data);\r\nif (iucv_dbf_trace)\r\ndebug_unregister(iucv_dbf_trace);\r\n}\r\nstatic int iucv_register_dbf_views(void)\r\n{\r\niucv_dbf_setup = debug_register(IUCV_DBF_SETUP_NAME,\r\nIUCV_DBF_SETUP_PAGES,\r\nIUCV_DBF_SETUP_NR_AREAS,\r\nIUCV_DBF_SETUP_LEN);\r\niucv_dbf_data = debug_register(IUCV_DBF_DATA_NAME,\r\nIUCV_DBF_DATA_PAGES,\r\nIUCV_DBF_DATA_NR_AREAS,\r\nIUCV_DBF_DATA_LEN);\r\niucv_dbf_trace = debug_register(IUCV_DBF_TRACE_NAME,\r\nIUCV_DBF_TRACE_PAGES,\r\nIUCV_DBF_TRACE_NR_AREAS,\r\nIUCV_DBF_TRACE_LEN);\r\nif ((iucv_dbf_setup == NULL) || (iucv_dbf_data == NULL) ||\r\n(iucv_dbf_trace == NULL)) {\r\niucv_unregister_dbf_views();\r\nreturn -ENOMEM;\r\n}\r\ndebug_register_view(iucv_dbf_setup, &debug_hex_ascii_view);\r\ndebug_set_level(iucv_dbf_setup, IUCV_DBF_SETUP_LEVEL);\r\ndebug_register_view(iucv_dbf_data, &debug_hex_ascii_view);\r\ndebug_set_level(iucv_dbf_data, IUCV_DBF_DATA_LEVEL);\r\ndebug_register_view(iucv_dbf_trace, &debug_hex_ascii_view);\r\ndebug_set_level(iucv_dbf_trace, IUCV_DBF_TRACE_LEVEL);\r\nreturn 0;\r\n}\r\nstatic void netiucv_callback_rx(struct iucv_path *path,\r\nstruct iucv_message *msg)\r\n{\r\nstruct iucv_connection *conn = path->private;\r\nstruct iucv_event ev;\r\nev.conn = conn;\r\nev.data = msg;\r\nfsm_event(conn->fsm, CONN_EVENT_RX, &ev);\r\n}\r\nstatic void netiucv_callback_txdone(struct iucv_path *path,\r\nstruct iucv_message *msg)\r\n{\r\nstruct iucv_connection *conn = path->private;\r\nstruct iucv_event ev;\r\nev.conn = conn;\r\nev.data = msg;\r\nfsm_event(conn->fsm, CONN_EVENT_TXDONE, &ev);\r\n}\r\nstatic void netiucv_callback_connack(struct iucv_path *path, u8 ipuser[16])\r\n{\r\nstruct iucv_connection *conn = path->private;\r\nfsm_event(conn->fsm, CONN_EVENT_CONN_ACK, conn);\r\n}\r\nstatic int netiucv_callback_connreq(struct iucv_path *path,\r\nu8 ipvmid[8], u8 ipuser[16])\r\n{\r\nstruct iucv_connection *conn = path->private;\r\nstruct iucv_event ev;\r\nint rc;\r\nif (memcmp(iucvMagic, ipuser, 16))\r\nreturn -EINVAL;\r\nrc = -EINVAL;\r\nread_lock_bh(&iucv_connection_rwlock);\r\nlist_for_each_entry(conn, &iucv_connection_list, list) {\r\nif (strncmp(ipvmid, conn->userid, 8))\r\ncontinue;\r\nconn->path = path;\r\nev.conn = conn;\r\nev.data = path;\r\nfsm_event(conn->fsm, CONN_EVENT_CONN_REQ, &ev);\r\nrc = 0;\r\n}\r\nread_unlock_bh(&iucv_connection_rwlock);\r\nreturn rc;\r\n}\r\nstatic void netiucv_callback_connrej(struct iucv_path *path, u8 ipuser[16])\r\n{\r\nstruct iucv_connection *conn = path->private;\r\nfsm_event(conn->fsm, CONN_EVENT_CONN_REJ, conn);\r\n}\r\nstatic void netiucv_callback_connsusp(struct iucv_path *path, u8 ipuser[16])\r\n{\r\nstruct iucv_connection *conn = path->private;\r\nfsm_event(conn->fsm, CONN_EVENT_CONN_SUS, conn);\r\n}\r\nstatic void netiucv_callback_connres(struct iucv_path *path, u8 ipuser[16])\r\n{\r\nstruct iucv_connection *conn = path->private;\r\nfsm_event(conn->fsm, CONN_EVENT_CONN_RES, conn);\r\n}\r\nstatic void netiucv_action_nop(fsm_instance *fi, int event, void *arg)\r\n{\r\n}\r\nstatic void netiucv_unpack_skb(struct iucv_connection *conn,\r\nstruct sk_buff *pskb)\r\n{\r\nstruct net_device *dev = conn->netdev;\r\nstruct netiucv_priv *privptr = netdev_priv(dev);\r\nu16 offset = 0;\r\nskb_put(pskb, NETIUCV_HDRLEN);\r\npskb->dev = dev;\r\npskb->ip_summed = CHECKSUM_NONE;\r\npskb->protocol = ntohs(ETH_P_IP);\r\nwhile (1) {\r\nstruct sk_buff *skb;\r\nstruct ll_header *header = (struct ll_header *) pskb->data;\r\nif (!header->next)\r\nbreak;\r\nskb_pull(pskb, NETIUCV_HDRLEN);\r\nheader->next -= offset;\r\noffset += header->next;\r\nheader->next -= NETIUCV_HDRLEN;\r\nif (skb_tailroom(pskb) < header->next) {\r\nIUCV_DBF_TEXT_(data, 2, "Illegal next field: %d > %d\n",\r\nheader->next, skb_tailroom(pskb));\r\nreturn;\r\n}\r\nskb_put(pskb, header->next);\r\nskb_reset_mac_header(pskb);\r\nskb = dev_alloc_skb(pskb->len);\r\nif (!skb) {\r\nIUCV_DBF_TEXT(data, 2,\r\n"Out of memory in netiucv_unpack_skb\n");\r\nprivptr->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_copy_from_linear_data(pskb, skb_put(skb, pskb->len),\r\npskb->len);\r\nskb_reset_mac_header(skb);\r\nskb->dev = pskb->dev;\r\nskb->protocol = pskb->protocol;\r\npskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nprivptr->stats.rx_packets++;\r\nprivptr->stats.rx_bytes += skb->len;\r\nnetif_rx_ni(skb);\r\nskb_pull(pskb, header->next);\r\nskb_put(pskb, NETIUCV_HDRLEN);\r\n}\r\n}\r\nstatic void conn_action_rx(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_event *ev = arg;\r\nstruct iucv_connection *conn = ev->conn;\r\nstruct iucv_message *msg = ev->data;\r\nstruct netiucv_priv *privptr = netdev_priv(conn->netdev);\r\nint rc;\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\nif (!conn->netdev) {\r\niucv_message_reject(conn->path, msg);\r\nIUCV_DBF_TEXT(data, 2,\r\n"Received data for unlinked connection\n");\r\nreturn;\r\n}\r\nif (msg->length > conn->max_buffsize) {\r\niucv_message_reject(conn->path, msg);\r\nprivptr->stats.rx_dropped++;\r\nIUCV_DBF_TEXT_(data, 2, "msglen %d > max_buffsize %d\n",\r\nmsg->length, conn->max_buffsize);\r\nreturn;\r\n}\r\nconn->rx_buff->data = conn->rx_buff->head;\r\nskb_reset_tail_pointer(conn->rx_buff);\r\nconn->rx_buff->len = 0;\r\nrc = iucv_message_receive(conn->path, msg, 0, conn->rx_buff->data,\r\nmsg->length, NULL);\r\nif (rc || msg->length < 5) {\r\nprivptr->stats.rx_errors++;\r\nIUCV_DBF_TEXT_(data, 2, "rc %d from iucv_receive\n", rc);\r\nreturn;\r\n}\r\nnetiucv_unpack_skb(conn, conn->rx_buff);\r\n}\r\nstatic void conn_action_txdone(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_event *ev = arg;\r\nstruct iucv_connection *conn = ev->conn;\r\nstruct iucv_message *msg = ev->data;\r\nstruct iucv_message txmsg;\r\nstruct netiucv_priv *privptr = NULL;\r\nu32 single_flag = msg->tag;\r\nu32 txbytes = 0;\r\nu32 txpackets = 0;\r\nu32 stat_maxcq = 0;\r\nstruct sk_buff *skb;\r\nunsigned long saveflags;\r\nstruct ll_header header;\r\nint rc;\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\nif (conn && conn->netdev)\r\nprivptr = netdev_priv(conn->netdev);\r\nconn->prof.tx_pending--;\r\nif (single_flag) {\r\nif ((skb = skb_dequeue(&conn->commit_queue))) {\r\natomic_dec(&skb->users);\r\nif (privptr) {\r\nprivptr->stats.tx_packets++;\r\nprivptr->stats.tx_bytes +=\r\n(skb->len - NETIUCV_HDRLEN\r\n- NETIUCV_HDRLEN);\r\n}\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nconn->tx_buff->data = conn->tx_buff->head;\r\nskb_reset_tail_pointer(conn->tx_buff);\r\nconn->tx_buff->len = 0;\r\nspin_lock_irqsave(&conn->collect_lock, saveflags);\r\nwhile ((skb = skb_dequeue(&conn->collect_queue))) {\r\nheader.next = conn->tx_buff->len + skb->len + NETIUCV_HDRLEN;\r\nmemcpy(skb_put(conn->tx_buff, NETIUCV_HDRLEN), &header,\r\nNETIUCV_HDRLEN);\r\nskb_copy_from_linear_data(skb,\r\nskb_put(conn->tx_buff, skb->len),\r\nskb->len);\r\ntxbytes += skb->len;\r\ntxpackets++;\r\nstat_maxcq++;\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_any(skb);\r\n}\r\nif (conn->collect_len > conn->prof.maxmulti)\r\nconn->prof.maxmulti = conn->collect_len;\r\nconn->collect_len = 0;\r\nspin_unlock_irqrestore(&conn->collect_lock, saveflags);\r\nif (conn->tx_buff->len == 0) {\r\nfsm_newstate(fi, CONN_STATE_IDLE);\r\nreturn;\r\n}\r\nheader.next = 0;\r\nmemcpy(skb_put(conn->tx_buff, NETIUCV_HDRLEN), &header, NETIUCV_HDRLEN);\r\nconn->prof.send_stamp = current_kernel_time();\r\ntxmsg.class = 0;\r\ntxmsg.tag = 0;\r\nrc = iucv_message_send(conn->path, &txmsg, 0, 0,\r\nconn->tx_buff->data, conn->tx_buff->len);\r\nconn->prof.doios_multi++;\r\nconn->prof.txlen += conn->tx_buff->len;\r\nconn->prof.tx_pending++;\r\nif (conn->prof.tx_pending > conn->prof.tx_max_pending)\r\nconn->prof.tx_max_pending = conn->prof.tx_pending;\r\nif (rc) {\r\nconn->prof.tx_pending--;\r\nfsm_newstate(fi, CONN_STATE_IDLE);\r\nif (privptr)\r\nprivptr->stats.tx_errors += txpackets;\r\nIUCV_DBF_TEXT_(data, 2, "rc %d from iucv_send\n", rc);\r\n} else {\r\nif (privptr) {\r\nprivptr->stats.tx_packets += txpackets;\r\nprivptr->stats.tx_bytes += txbytes;\r\n}\r\nif (stat_maxcq > conn->prof.maxcqueue)\r\nconn->prof.maxcqueue = stat_maxcq;\r\n}\r\n}\r\nstatic void conn_action_connaccept(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_event *ev = arg;\r\nstruct iucv_connection *conn = ev->conn;\r\nstruct iucv_path *path = ev->data;\r\nstruct net_device *netdev = conn->netdev;\r\nstruct netiucv_priv *privptr = netdev_priv(netdev);\r\nint rc;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nconn->path = path;\r\npath->msglim = NETIUCV_QUEUELEN_DEFAULT;\r\npath->flags = 0;\r\nrc = iucv_path_accept(path, &netiucv_handler, NULL, conn);\r\nif (rc) {\r\nIUCV_DBF_TEXT_(setup, 2, "rc %d from iucv_accept", rc);\r\nreturn;\r\n}\r\nfsm_newstate(fi, CONN_STATE_IDLE);\r\nnetdev->tx_queue_len = conn->path->msglim;\r\nfsm_event(privptr->fsm, DEV_EVENT_CONUP, netdev);\r\n}\r\nstatic void conn_action_connreject(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_event *ev = arg;\r\nstruct iucv_path *path = ev->data;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\niucv_path_sever(path, NULL);\r\n}\r\nstatic void conn_action_connack(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_connection *conn = arg;\r\nstruct net_device *netdev = conn->netdev;\r\nstruct netiucv_priv *privptr = netdev_priv(netdev);\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nfsm_deltimer(&conn->timer);\r\nfsm_newstate(fi, CONN_STATE_IDLE);\r\nnetdev->tx_queue_len = conn->path->msglim;\r\nfsm_event(privptr->fsm, DEV_EVENT_CONUP, netdev);\r\n}\r\nstatic void conn_action_conntimsev(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_connection *conn = arg;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nfsm_deltimer(&conn->timer);\r\niucv_path_sever(conn->path, NULL);\r\nfsm_newstate(fi, CONN_STATE_STARTWAIT);\r\n}\r\nstatic void conn_action_connsever(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_connection *conn = arg;\r\nstruct net_device *netdev = conn->netdev;\r\nstruct netiucv_priv *privptr = netdev_priv(netdev);\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nfsm_deltimer(&conn->timer);\r\niucv_path_sever(conn->path, NULL);\r\ndev_info(privptr->dev, "The peer interface of the IUCV device"\r\n" has closed the connection\n");\r\nIUCV_DBF_TEXT(data, 2,\r\n"conn_action_connsever: Remote dropped connection\n");\r\nfsm_newstate(fi, CONN_STATE_STARTWAIT);\r\nfsm_event(privptr->fsm, DEV_EVENT_CONDOWN, netdev);\r\n}\r\nstatic void conn_action_start(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_connection *conn = arg;\r\nstruct net_device *netdev = conn->netdev;\r\nstruct netiucv_priv *privptr = netdev_priv(netdev);\r\nint rc;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nfsm_newstate(fi, CONN_STATE_STARTWAIT);\r\nIUCV_DBF_TEXT_(setup, 2, "%s('%s'): connecting ...\n",\r\nnetdev->name, conn->userid);\r\nfsm_newstate(fi, CONN_STATE_SETUPWAIT);\r\nconn->path = iucv_path_alloc(NETIUCV_QUEUELEN_DEFAULT, 0, GFP_KERNEL);\r\nrc = iucv_path_connect(conn->path, &netiucv_handler, conn->userid,\r\nNULL, iucvMagic, conn);\r\nswitch (rc) {\r\ncase 0:\r\nnetdev->tx_queue_len = conn->path->msglim;\r\nfsm_addtimer(&conn->timer, NETIUCV_TIMEOUT_5SEC,\r\nCONN_EVENT_TIMER, conn);\r\nreturn;\r\ncase 11:\r\ndev_warn(privptr->dev,\r\n"The IUCV device failed to connect to z/VM guest %s\n",\r\nnetiucv_printname(conn->userid));\r\nfsm_newstate(fi, CONN_STATE_STARTWAIT);\r\nbreak;\r\ncase 12:\r\ndev_warn(privptr->dev,\r\n"The IUCV device failed to connect to the peer on z/VM"\r\n" guest %s\n", netiucv_printname(conn->userid));\r\nfsm_newstate(fi, CONN_STATE_STARTWAIT);\r\nbreak;\r\ncase 13:\r\ndev_err(privptr->dev,\r\n"Connecting the IUCV device would exceed the maximum"\r\n" number of IUCV connections\n");\r\nfsm_newstate(fi, CONN_STATE_CONNERR);\r\nbreak;\r\ncase 14:\r\ndev_err(privptr->dev,\r\n"z/VM guest %s has too many IUCV connections"\r\n" to connect with the IUCV device\n",\r\nnetiucv_printname(conn->userid));\r\nfsm_newstate(fi, CONN_STATE_CONNERR);\r\nbreak;\r\ncase 15:\r\ndev_err(privptr->dev,\r\n"The IUCV device cannot connect to a z/VM guest with no"\r\n" IUCV authorization\n");\r\nfsm_newstate(fi, CONN_STATE_CONNERR);\r\nbreak;\r\ndefault:\r\ndev_err(privptr->dev,\r\n"Connecting the IUCV device failed with error %d\n",\r\nrc);\r\nfsm_newstate(fi, CONN_STATE_CONNERR);\r\nbreak;\r\n}\r\nIUCV_DBF_TEXT_(setup, 5, "iucv_connect rc is %d\n", rc);\r\nkfree(conn->path);\r\nconn->path = NULL;\r\n}\r\nstatic void netiucv_purge_skb_queue(struct sk_buff_head *q)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(q))) {\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nstatic void conn_action_stop(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_event *ev = arg;\r\nstruct iucv_connection *conn = ev->conn;\r\nstruct net_device *netdev = conn->netdev;\r\nstruct netiucv_priv *privptr = netdev_priv(netdev);\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nfsm_deltimer(&conn->timer);\r\nfsm_newstate(fi, CONN_STATE_STOPPED);\r\nnetiucv_purge_skb_queue(&conn->collect_queue);\r\nif (conn->path) {\r\nIUCV_DBF_TEXT(trace, 5, "calling iucv_path_sever\n");\r\niucv_path_sever(conn->path, iucvMagic);\r\nkfree(conn->path);\r\nconn->path = NULL;\r\n}\r\nnetiucv_purge_skb_queue(&conn->commit_queue);\r\nfsm_event(privptr->fsm, DEV_EVENT_CONDOWN, netdev);\r\n}\r\nstatic void conn_action_inval(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct iucv_connection *conn = arg;\r\nstruct net_device *netdev = conn->netdev;\r\nIUCV_DBF_TEXT_(data, 2, "%s('%s'): conn_action_inval called\n",\r\nnetdev->name, conn->userid);\r\n}\r\nstatic void dev_action_start(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct netiucv_priv *privptr = netdev_priv(dev);\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT);\r\nfsm_event(privptr->conn->fsm, CONN_EVENT_START, privptr->conn);\r\n}\r\nstatic void\r\ndev_action_stop(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct netiucv_priv *privptr = netdev_priv(dev);\r\nstruct iucv_event ev;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nev.conn = privptr->conn;\r\nfsm_newstate(fi, DEV_STATE_STOPWAIT);\r\nfsm_event(privptr->conn->fsm, CONN_EVENT_STOP, &ev);\r\n}\r\nstatic void\r\ndev_action_connup(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct netiucv_priv *privptr = netdev_priv(dev);\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nswitch (fsm_getstate(fi)) {\r\ncase DEV_STATE_STARTWAIT:\r\nfsm_newstate(fi, DEV_STATE_RUNNING);\r\ndev_info(privptr->dev,\r\n"The IUCV device has been connected"\r\n" successfully to %s\n", privptr->conn->userid);\r\nIUCV_DBF_TEXT(setup, 3,\r\n"connection is up and running\n");\r\nbreak;\r\ncase DEV_STATE_STOPWAIT:\r\nIUCV_DBF_TEXT(data, 2,\r\n"dev_action_connup: in DEV_STATE_STOPWAIT\n");\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndev_action_conndown(fsm_instance *fi, int event, void *arg)\r\n{\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nswitch (fsm_getstate(fi)) {\r\ncase DEV_STATE_RUNNING:\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT);\r\nbreak;\r\ncase DEV_STATE_STOPWAIT:\r\nfsm_newstate(fi, DEV_STATE_STOPPED);\r\nIUCV_DBF_TEXT(setup, 3, "connection is down\n");\r\nbreak;\r\n}\r\n}\r\nstatic int netiucv_transmit_skb(struct iucv_connection *conn,\r\nstruct sk_buff *skb)\r\n{\r\nstruct iucv_message msg;\r\nunsigned long saveflags;\r\nstruct ll_header header;\r\nint rc;\r\nif (fsm_getstate(conn->fsm) != CONN_STATE_IDLE) {\r\nint l = skb->len + NETIUCV_HDRLEN;\r\nspin_lock_irqsave(&conn->collect_lock, saveflags);\r\nif (conn->collect_len + l >\r\n(conn->max_buffsize - NETIUCV_HDRLEN)) {\r\nrc = -EBUSY;\r\nIUCV_DBF_TEXT(data, 2,\r\n"EBUSY from netiucv_transmit_skb\n");\r\n} else {\r\natomic_inc(&skb->users);\r\nskb_queue_tail(&conn->collect_queue, skb);\r\nconn->collect_len += l;\r\nrc = 0;\r\n}\r\nspin_unlock_irqrestore(&conn->collect_lock, saveflags);\r\n} else {\r\nstruct sk_buff *nskb = skb;\r\nunsigned long hi = ((unsigned long)(skb_tail_pointer(skb) +\r\nNETIUCV_HDRLEN)) >> 31;\r\nint copied = 0;\r\nif (hi || (skb_tailroom(skb) < 2)) {\r\nnskb = alloc_skb(skb->len + NETIUCV_HDRLEN +\r\nNETIUCV_HDRLEN, GFP_ATOMIC | GFP_DMA);\r\nif (!nskb) {\r\nIUCV_DBF_TEXT(data, 2, "alloc_skb failed\n");\r\nrc = -ENOMEM;\r\nreturn rc;\r\n} else {\r\nskb_reserve(nskb, NETIUCV_HDRLEN);\r\nmemcpy(skb_put(nskb, skb->len),\r\nskb->data, skb->len);\r\n}\r\ncopied = 1;\r\n}\r\nheader.next = nskb->len + NETIUCV_HDRLEN;\r\nmemcpy(skb_push(nskb, NETIUCV_HDRLEN), &header, NETIUCV_HDRLEN);\r\nheader.next = 0;\r\nmemcpy(skb_put(nskb, NETIUCV_HDRLEN), &header, NETIUCV_HDRLEN);\r\nfsm_newstate(conn->fsm, CONN_STATE_TX);\r\nconn->prof.send_stamp = current_kernel_time();\r\nmsg.tag = 1;\r\nmsg.class = 0;\r\nrc = iucv_message_send(conn->path, &msg, 0, 0,\r\nnskb->data, nskb->len);\r\nconn->prof.doios_single++;\r\nconn->prof.txlen += skb->len;\r\nconn->prof.tx_pending++;\r\nif (conn->prof.tx_pending > conn->prof.tx_max_pending)\r\nconn->prof.tx_max_pending = conn->prof.tx_pending;\r\nif (rc) {\r\nstruct netiucv_priv *privptr;\r\nfsm_newstate(conn->fsm, CONN_STATE_IDLE);\r\nconn->prof.tx_pending--;\r\nprivptr = netdev_priv(conn->netdev);\r\nif (privptr)\r\nprivptr->stats.tx_errors++;\r\nif (copied)\r\ndev_kfree_skb(nskb);\r\nelse {\r\nskb_pull(skb, NETIUCV_HDRLEN);\r\nskb_trim(skb, skb->len - NETIUCV_HDRLEN);\r\n}\r\nIUCV_DBF_TEXT_(data, 2, "rc %d from iucv_send\n", rc);\r\n} else {\r\nif (copied)\r\ndev_kfree_skb(skb);\r\natomic_inc(&nskb->users);\r\nskb_queue_tail(&conn->commit_queue, nskb);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int netiucv_open(struct net_device *dev)\r\n{\r\nstruct netiucv_priv *priv = netdev_priv(dev);\r\nfsm_event(priv->fsm, DEV_EVENT_START, dev);\r\nreturn 0;\r\n}\r\nstatic int netiucv_close(struct net_device *dev)\r\n{\r\nstruct netiucv_priv *priv = netdev_priv(dev);\r\nfsm_event(priv->fsm, DEV_EVENT_STOP, dev);\r\nreturn 0;\r\n}\r\nstatic int netiucv_pm_prepare(struct device *dev)\r\n{\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nreturn 0;\r\n}\r\nstatic void netiucv_pm_complete(struct device *dev)\r\n{\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nreturn;\r\n}\r\nstatic int netiucv_pm_freeze(struct device *dev)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nstruct net_device *ndev = NULL;\r\nint rc = 0;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (priv && priv->conn)\r\nndev = priv->conn->netdev;\r\nif (!ndev)\r\ngoto out;\r\nnetif_device_detach(ndev);\r\npriv->pm_state = fsm_getstate(priv->fsm);\r\nrc = netiucv_close(ndev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int netiucv_pm_restore_thaw(struct device *dev)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nstruct net_device *ndev = NULL;\r\nint rc = 0;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (priv && priv->conn)\r\nndev = priv->conn->netdev;\r\nif (!ndev)\r\ngoto out;\r\nswitch (priv->pm_state) {\r\ncase DEV_STATE_RUNNING:\r\ncase DEV_STATE_STARTWAIT:\r\nrc = netiucv_open(ndev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nnetif_device_attach(ndev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int netiucv_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct netiucv_priv *privptr = netdev_priv(dev);\r\nint rc;\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\nif (skb == NULL) {\r\nIUCV_DBF_TEXT(data, 2, "netiucv_tx: skb is NULL\n");\r\nprivptr->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb_headroom(skb) < NETIUCV_HDRLEN) {\r\nIUCV_DBF_TEXT(data, 2,\r\n"netiucv_tx: skb_headroom < NETIUCV_HDRLEN\n");\r\ndev_kfree_skb(skb);\r\nprivptr->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (fsm_getstate(privptr->fsm) != DEV_STATE_RUNNING) {\r\ndev_kfree_skb(skb);\r\nprivptr->stats.tx_dropped++;\r\nprivptr->stats.tx_errors++;\r\nprivptr->stats.tx_carrier_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (netiucv_test_and_set_busy(dev)) {\r\nIUCV_DBF_TEXT(data, 2, "EBUSY from netiucv_tx\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ndev->trans_start = jiffies;\r\nrc = netiucv_transmit_skb(privptr->conn, skb);\r\nnetiucv_clear_busy(dev);\r\nreturn rc ? NETDEV_TX_BUSY : NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *netiucv_stats (struct net_device * dev)\r\n{\r\nstruct netiucv_priv *priv = netdev_priv(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn &priv->stats;\r\n}\r\nstatic int netiucv_change_mtu(struct net_device * dev, int new_mtu)\r\n{\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (new_mtu < 576 || new_mtu > NETIUCV_MTU_MAX) {\r\nIUCV_DBF_TEXT(setup, 2, "given MTU out of valid range\n");\r\nreturn -EINVAL;\r\n}\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic ssize_t user_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%s\n", netiucv_printname(priv->conn->userid));\r\n}\r\nstatic ssize_t user_write(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nstruct net_device *ndev = priv->conn->netdev;\r\nchar *p;\r\nchar *tmp;\r\nchar username[9];\r\nint i;\r\nstruct iucv_connection *cp;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (count > 9) {\r\nIUCV_DBF_TEXT_(setup, 2,\r\n"%d is length of username\n", (int) count);\r\nreturn -EINVAL;\r\n}\r\ntmp = strsep((char **) &buf, "\n");\r\nfor (i = 0, p = tmp; i < 8 && *p; i++, p++) {\r\nif (isalnum(*p) || (*p == '$')) {\r\nusername[i]= toupper(*p);\r\ncontinue;\r\n}\r\nif (*p == '\n') {\r\nbreak;\r\n}\r\nIUCV_DBF_TEXT_(setup, 2,\r\n"username: invalid character %c\n", *p);\r\nreturn -EINVAL;\r\n}\r\nwhile (i < 8)\r\nusername[i++] = ' ';\r\nusername[8] = '\0';\r\nif (memcmp(username, priv->conn->userid, 9) &&\r\n(ndev->flags & (IFF_UP | IFF_RUNNING))) {\r\nIUCV_DBF_TEXT(setup, 2, "user_write: device active\n");\r\nreturn -EPERM;\r\n}\r\nread_lock_bh(&iucv_connection_rwlock);\r\nlist_for_each_entry(cp, &iucv_connection_list, list) {\r\nif (!strncmp(username, cp->userid, 9) && cp->netdev != ndev) {\r\nread_unlock_bh(&iucv_connection_rwlock);\r\nIUCV_DBF_TEXT_(setup, 2, "user_write: Connection "\r\n"to %s already exists\n", username);\r\nreturn -EEXIST;\r\n}\r\n}\r\nread_unlock_bh(&iucv_connection_rwlock);\r\nmemcpy(priv->conn->userid, username, 9);\r\nreturn count;\r\n}\r\nstatic ssize_t buffer_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%d\n", priv->conn->max_buffsize);\r\n}\r\nstatic ssize_t buffer_write (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nstruct net_device *ndev = priv->conn->netdev;\r\nchar *e;\r\nint bs1;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (count >= 39)\r\nreturn -EINVAL;\r\nbs1 = simple_strtoul(buf, &e, 0);\r\nif (e && (!isspace(*e))) {\r\nIUCV_DBF_TEXT_(setup, 2, "buffer_write: invalid char %c\n", *e);\r\nreturn -EINVAL;\r\n}\r\nif (bs1 > NETIUCV_BUFSIZE_MAX) {\r\nIUCV_DBF_TEXT_(setup, 2,\r\n"buffer_write: buffer size %d too large\n",\r\nbs1);\r\nreturn -EINVAL;\r\n}\r\nif ((ndev->flags & IFF_RUNNING) &&\r\n(bs1 < (ndev->mtu + NETIUCV_HDRLEN + 2))) {\r\nIUCV_DBF_TEXT_(setup, 2,\r\n"buffer_write: buffer size %d too small\n",\r\nbs1);\r\nreturn -EINVAL;\r\n}\r\nif (bs1 < (576 + NETIUCV_HDRLEN + NETIUCV_HDRLEN)) {\r\nIUCV_DBF_TEXT_(setup, 2,\r\n"buffer_write: buffer size %d too small\n",\r\nbs1);\r\nreturn -EINVAL;\r\n}\r\npriv->conn->max_buffsize = bs1;\r\nif (!(ndev->flags & IFF_RUNNING))\r\nndev->mtu = bs1 - NETIUCV_HDRLEN - NETIUCV_HDRLEN;\r\nreturn count;\r\n}\r\nstatic ssize_t dev_fsm_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%s\n", fsm_getstate_str(priv->fsm));\r\n}\r\nstatic ssize_t conn_fsm_show (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%s\n", fsm_getstate_str(priv->conn->fsm));\r\n}\r\nstatic ssize_t maxmulti_show (struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%ld\n", priv->conn->prof.maxmulti);\r\n}\r\nstatic ssize_t maxmulti_write (struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\npriv->conn->prof.maxmulti = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t maxcq_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%ld\n", priv->conn->prof.maxcqueue);\r\n}\r\nstatic ssize_t maxcq_write (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\npriv->conn->prof.maxcqueue = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t sdoio_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%ld\n", priv->conn->prof.doios_single);\r\n}\r\nstatic ssize_t sdoio_write (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\npriv->conn->prof.doios_single = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t mdoio_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%ld\n", priv->conn->prof.doios_multi);\r\n}\r\nstatic ssize_t mdoio_write (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\npriv->conn->prof.doios_multi = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t txlen_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%ld\n", priv->conn->prof.txlen);\r\n}\r\nstatic ssize_t txlen_write (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\npriv->conn->prof.txlen = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t txtime_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%ld\n", priv->conn->prof.tx_time);\r\n}\r\nstatic ssize_t txtime_write (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\npriv->conn->prof.tx_time = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t txpend_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%ld\n", priv->conn->prof.tx_pending);\r\n}\r\nstatic ssize_t txpend_write (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\npriv->conn->prof.tx_pending = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t txmpnd_show (struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 5, __func__);\r\nreturn sprintf(buf, "%ld\n", priv->conn->prof.tx_max_pending);\r\n}\r\nstatic ssize_t txmpnd_write (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct netiucv_priv *priv = dev_get_drvdata(dev);\r\nIUCV_DBF_TEXT(trace, 4, __func__);\r\npriv->conn->prof.tx_max_pending = 0;\r\nreturn count;\r\n}\r\nstatic int netiucv_add_files(struct device *dev)\r\n{\r\nint ret;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nret = sysfs_create_group(&dev->kobj, &netiucv_attr_group);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &netiucv_stat_attr_group);\r\nif (ret)\r\nsysfs_remove_group(&dev->kobj, &netiucv_attr_group);\r\nreturn ret;\r\n}\r\nstatic void netiucv_remove_files(struct device *dev)\r\n{\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nsysfs_remove_group(&dev->kobj, &netiucv_stat_attr_group);\r\nsysfs_remove_group(&dev->kobj, &netiucv_attr_group);\r\n}\r\nstatic int netiucv_register_device(struct net_device *ndev)\r\n{\r\nstruct netiucv_priv *priv = netdev_priv(ndev);\r\nstruct device *dev = kzalloc(sizeof(struct device), GFP_KERNEL);\r\nint ret;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (dev) {\r\ndev_set_name(dev, "net%s", ndev->name);\r\ndev->bus = &iucv_bus;\r\ndev->parent = iucv_root;\r\ndev->release = (void (*)(struct device *))kfree;\r\ndev->driver = &netiucv_driver;\r\n} else\r\nreturn -ENOMEM;\r\nret = device_register(dev);\r\nif (ret) {\r\nput_device(dev);\r\nreturn ret;\r\n}\r\nret = netiucv_add_files(dev);\r\nif (ret)\r\ngoto out_unreg;\r\npriv->dev = dev;\r\ndev_set_drvdata(dev, priv);\r\nreturn 0;\r\nout_unreg:\r\ndevice_unregister(dev);\r\nreturn ret;\r\n}\r\nstatic void netiucv_unregister_device(struct device *dev)\r\n{\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nnetiucv_remove_files(dev);\r\ndevice_unregister(dev);\r\n}\r\nstatic struct iucv_connection *netiucv_new_connection(struct net_device *dev,\r\nchar *username)\r\n{\r\nstruct iucv_connection *conn;\r\nconn = kzalloc(sizeof(*conn), GFP_KERNEL);\r\nif (!conn)\r\ngoto out;\r\nskb_queue_head_init(&conn->collect_queue);\r\nskb_queue_head_init(&conn->commit_queue);\r\nspin_lock_init(&conn->collect_lock);\r\nconn->max_buffsize = NETIUCV_BUFSIZE_DEFAULT;\r\nconn->netdev = dev;\r\nconn->rx_buff = alloc_skb(conn->max_buffsize, GFP_KERNEL | GFP_DMA);\r\nif (!conn->rx_buff)\r\ngoto out_conn;\r\nconn->tx_buff = alloc_skb(conn->max_buffsize, GFP_KERNEL | GFP_DMA);\r\nif (!conn->tx_buff)\r\ngoto out_rx;\r\nconn->fsm = init_fsm("netiucvconn", conn_state_names,\r\nconn_event_names, NR_CONN_STATES,\r\nNR_CONN_EVENTS, conn_fsm, CONN_FSM_LEN,\r\nGFP_KERNEL);\r\nif (!conn->fsm)\r\ngoto out_tx;\r\nfsm_settimer(conn->fsm, &conn->timer);\r\nfsm_newstate(conn->fsm, CONN_STATE_INVALID);\r\nif (username) {\r\nmemcpy(conn->userid, username, 9);\r\nfsm_newstate(conn->fsm, CONN_STATE_STOPPED);\r\n}\r\nwrite_lock_bh(&iucv_connection_rwlock);\r\nlist_add_tail(&conn->list, &iucv_connection_list);\r\nwrite_unlock_bh(&iucv_connection_rwlock);\r\nreturn conn;\r\nout_tx:\r\nkfree_skb(conn->tx_buff);\r\nout_rx:\r\nkfree_skb(conn->rx_buff);\r\nout_conn:\r\nkfree(conn);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic void netiucv_remove_connection(struct iucv_connection *conn)\r\n{\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nwrite_lock_bh(&iucv_connection_rwlock);\r\nlist_del_init(&conn->list);\r\nwrite_unlock_bh(&iucv_connection_rwlock);\r\nfsm_deltimer(&conn->timer);\r\nnetiucv_purge_skb_queue(&conn->collect_queue);\r\nif (conn->path) {\r\niucv_path_sever(conn->path, iucvMagic);\r\nkfree(conn->path);\r\nconn->path = NULL;\r\n}\r\nnetiucv_purge_skb_queue(&conn->commit_queue);\r\nkfree_fsm(conn->fsm);\r\nkfree_skb(conn->rx_buff);\r\nkfree_skb(conn->tx_buff);\r\n}\r\nstatic void netiucv_free_netdevice(struct net_device *dev)\r\n{\r\nstruct netiucv_priv *privptr = netdev_priv(dev);\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (!dev)\r\nreturn;\r\nif (privptr) {\r\nif (privptr->conn)\r\nnetiucv_remove_connection(privptr->conn);\r\nif (privptr->fsm)\r\nkfree_fsm(privptr->fsm);\r\nprivptr->conn = NULL; privptr->fsm = NULL;\r\n}\r\nfree_netdev(dev);\r\n}\r\nstatic void netiucv_setup_netdevice(struct net_device *dev)\r\n{\r\ndev->mtu = NETIUCV_MTU_DEFAULT;\r\ndev->destructor = netiucv_free_netdevice;\r\ndev->hard_header_len = NETIUCV_HDRLEN;\r\ndev->addr_len = 0;\r\ndev->type = ARPHRD_SLIP;\r\ndev->tx_queue_len = NETIUCV_QUEUELEN_DEFAULT;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->netdev_ops = &netiucv_netdev_ops;\r\n}\r\nstatic struct net_device *netiucv_init_netdevice(char *username)\r\n{\r\nstruct netiucv_priv *privptr;\r\nstruct net_device *dev;\r\ndev = alloc_netdev(sizeof(struct netiucv_priv), "iucv%d",\r\nnetiucv_setup_netdevice);\r\nif (!dev)\r\nreturn NULL;\r\nprivptr = netdev_priv(dev);\r\nprivptr->fsm = init_fsm("netiucvdev", dev_state_names,\r\ndev_event_names, NR_DEV_STATES, NR_DEV_EVENTS,\r\ndev_fsm, DEV_FSM_LEN, GFP_KERNEL);\r\nif (!privptr->fsm)\r\ngoto out_netdev;\r\nprivptr->conn = netiucv_new_connection(dev, username);\r\nif (!privptr->conn) {\r\nIUCV_DBF_TEXT(setup, 2, "NULL from netiucv_new_connection\n");\r\ngoto out_fsm;\r\n}\r\nfsm_newstate(privptr->fsm, DEV_STATE_STOPPED);\r\nreturn dev;\r\nout_fsm:\r\nkfree_fsm(privptr->fsm);\r\nout_netdev:\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nstatic ssize_t conn_write(struct device_driver *drv,\r\nconst char *buf, size_t count)\r\n{\r\nconst char *p;\r\nchar username[9];\r\nint i, rc;\r\nstruct net_device *dev;\r\nstruct netiucv_priv *priv;\r\nstruct iucv_connection *cp;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (count>9) {\r\nIUCV_DBF_TEXT(setup, 2, "conn_write: too long\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0, p = buf; i < 8 && *p; i++, p++) {\r\nif (isalnum(*p) || *p == '$') {\r\nusername[i] = toupper(*p);\r\ncontinue;\r\n}\r\nif (*p == '\n')\r\nbreak;\r\nIUCV_DBF_TEXT_(setup, 2,\r\n"conn_write: invalid character %c\n", *p);\r\nreturn -EINVAL;\r\n}\r\nwhile (i < 8)\r\nusername[i++] = ' ';\r\nusername[8] = '\0';\r\nread_lock_bh(&iucv_connection_rwlock);\r\nlist_for_each_entry(cp, &iucv_connection_list, list) {\r\nif (!strncmp(username, cp->userid, 9)) {\r\nread_unlock_bh(&iucv_connection_rwlock);\r\nIUCV_DBF_TEXT_(setup, 2, "conn_write: Connection "\r\n"to %s already exists\n", username);\r\nreturn -EEXIST;\r\n}\r\n}\r\nread_unlock_bh(&iucv_connection_rwlock);\r\ndev = netiucv_init_netdevice(username);\r\nif (!dev) {\r\nIUCV_DBF_TEXT(setup, 2, "NULL from netiucv_init_netdevice\n");\r\nreturn -ENODEV;\r\n}\r\nrc = netiucv_register_device(dev);\r\nif (rc) {\r\nIUCV_DBF_TEXT_(setup, 2,\r\n"ret %d from netiucv_register_device\n", rc);\r\ngoto out_free_ndev;\r\n}\r\npriv = netdev_priv(dev);\r\nSET_NETDEV_DEV(dev, priv->dev);\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto out_unreg;\r\ndev_info(priv->dev, "The IUCV interface to %s has been"\r\n" established successfully\n", netiucv_printname(username));\r\nreturn count;\r\nout_unreg:\r\nnetiucv_unregister_device(priv->dev);\r\nout_free_ndev:\r\nnetiucv_free_netdevice(dev);\r\nreturn rc;\r\n}\r\nstatic ssize_t remove_write (struct device_driver *drv,\r\nconst char *buf, size_t count)\r\n{\r\nstruct iucv_connection *cp;\r\nstruct net_device *ndev;\r\nstruct netiucv_priv *priv;\r\nstruct device *dev;\r\nchar name[IFNAMSIZ];\r\nconst char *p;\r\nint i;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nif (count >= IFNAMSIZ)\r\ncount = IFNAMSIZ - 1;\r\nfor (i = 0, p = buf; i < count && *p; i++, p++) {\r\nif (*p == '\n' || *p == ' ')\r\nbreak;\r\nname[i] = *p;\r\n}\r\nname[i] = '\0';\r\nread_lock_bh(&iucv_connection_rwlock);\r\nlist_for_each_entry(cp, &iucv_connection_list, list) {\r\nndev = cp->netdev;\r\npriv = netdev_priv(ndev);\r\ndev = priv->dev;\r\nif (strncmp(name, ndev->name, count))\r\ncontinue;\r\nread_unlock_bh(&iucv_connection_rwlock);\r\nif (ndev->flags & (IFF_UP | IFF_RUNNING)) {\r\ndev_warn(dev, "The IUCV device is connected"\r\n" to %s and cannot be removed\n",\r\npriv->conn->userid);\r\nIUCV_DBF_TEXT(data, 2, "remove_write: still active\n");\r\nreturn -EPERM;\r\n}\r\nunregister_netdev(ndev);\r\nnetiucv_unregister_device(dev);\r\nreturn count;\r\n}\r\nread_unlock_bh(&iucv_connection_rwlock);\r\nIUCV_DBF_TEXT(data, 2, "remove_write: unknown device\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void netiucv_banner(void)\r\n{\r\npr_info("driver initialized\n");\r\n}\r\nstatic void __exit netiucv_exit(void)\r\n{\r\nstruct iucv_connection *cp;\r\nstruct net_device *ndev;\r\nstruct netiucv_priv *priv;\r\nstruct device *dev;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nwhile (!list_empty(&iucv_connection_list)) {\r\ncp = list_entry(iucv_connection_list.next,\r\nstruct iucv_connection, list);\r\nndev = cp->netdev;\r\npriv = netdev_priv(ndev);\r\ndev = priv->dev;\r\nunregister_netdev(ndev);\r\nnetiucv_unregister_device(dev);\r\n}\r\ndevice_unregister(netiucv_dev);\r\ndriver_unregister(&netiucv_driver);\r\niucv_unregister(&netiucv_handler, 1);\r\niucv_unregister_dbf_views();\r\npr_info("driver unloaded\n");\r\nreturn;\r\n}\r\nstatic int __init netiucv_init(void)\r\n{\r\nint rc;\r\nrc = iucv_register_dbf_views();\r\nif (rc)\r\ngoto out;\r\nrc = iucv_register(&netiucv_handler, 1);\r\nif (rc)\r\ngoto out_dbf;\r\nIUCV_DBF_TEXT(trace, 3, __func__);\r\nnetiucv_driver.groups = netiucv_drv_attr_groups;\r\nrc = driver_register(&netiucv_driver);\r\nif (rc) {\r\nIUCV_DBF_TEXT_(setup, 2, "ret %d from driver_register\n", rc);\r\ngoto out_iucv;\r\n}\r\nnetiucv_dev = kzalloc(sizeof(struct device), GFP_KERNEL);\r\nif (!netiucv_dev) {\r\nrc = -ENOMEM;\r\ngoto out_driver;\r\n}\r\ndev_set_name(netiucv_dev, "netiucv");\r\nnetiucv_dev->bus = &iucv_bus;\r\nnetiucv_dev->parent = iucv_root;\r\nnetiucv_dev->release = (void (*)(struct device *))kfree;\r\nnetiucv_dev->driver = &netiucv_driver;\r\nrc = device_register(netiucv_dev);\r\nif (rc) {\r\nput_device(netiucv_dev);\r\ngoto out_driver;\r\n}\r\nnetiucv_banner();\r\nreturn rc;\r\nout_driver:\r\ndriver_unregister(&netiucv_driver);\r\nout_iucv:\r\niucv_unregister(&netiucv_handler, 1);\r\nout_dbf:\r\niucv_unregister_dbf_views();\r\nout:\r\nreturn rc;\r\n}
