static int show_stat(struct seq_file *p, void *v)\r\n{\r\nint i, j;\r\nunsigned long jif;\r\ncputime64_t user, nice, system, idle, iowait, irq, softirq, steal;\r\ncputime64_t guest, guest_nice;\r\nu64 sum = 0;\r\nu64 sum_softirq = 0;\r\nunsigned int per_softirq_sums[NR_SOFTIRQS] = {0};\r\nstruct timespec boottime;\r\nuser = nice = system = idle = iowait =\r\nirq = softirq = steal = cputime64_zero;\r\nguest = guest_nice = cputime64_zero;\r\ngetboottime(&boottime);\r\njif = boottime.tv_sec;\r\nfor_each_possible_cpu(i) {\r\nuser = cputime64_add(user, kstat_cpu(i).cpustat.user);\r\nnice = cputime64_add(nice, kstat_cpu(i).cpustat.nice);\r\nsystem = cputime64_add(system, kstat_cpu(i).cpustat.system);\r\nidle = cputime64_add(idle, kstat_cpu(i).cpustat.idle);\r\nidle = cputime64_add(idle, arch_idle_time(i));\r\niowait = cputime64_add(iowait, kstat_cpu(i).cpustat.iowait);\r\nirq = cputime64_add(irq, kstat_cpu(i).cpustat.irq);\r\nsoftirq = cputime64_add(softirq, kstat_cpu(i).cpustat.softirq);\r\nsteal = cputime64_add(steal, kstat_cpu(i).cpustat.steal);\r\nguest = cputime64_add(guest, kstat_cpu(i).cpustat.guest);\r\nguest_nice = cputime64_add(guest_nice,\r\nkstat_cpu(i).cpustat.guest_nice);\r\nsum += kstat_cpu_irqs_sum(i);\r\nsum += arch_irq_stat_cpu(i);\r\nfor (j = 0; j < NR_SOFTIRQS; j++) {\r\nunsigned int softirq_stat = kstat_softirqs_cpu(j, i);\r\nper_softirq_sums[j] += softirq_stat;\r\nsum_softirq += softirq_stat;\r\n}\r\n}\r\nsum += arch_irq_stat();\r\nseq_printf(p, "cpu %llu %llu %llu %llu %llu %llu %llu %llu %llu "\r\n"%llu\n",\r\n(unsigned long long)cputime64_to_clock_t(user),\r\n(unsigned long long)cputime64_to_clock_t(nice),\r\n(unsigned long long)cputime64_to_clock_t(system),\r\n(unsigned long long)cputime64_to_clock_t(idle),\r\n(unsigned long long)cputime64_to_clock_t(iowait),\r\n(unsigned long long)cputime64_to_clock_t(irq),\r\n(unsigned long long)cputime64_to_clock_t(softirq),\r\n(unsigned long long)cputime64_to_clock_t(steal),\r\n(unsigned long long)cputime64_to_clock_t(guest),\r\n(unsigned long long)cputime64_to_clock_t(guest_nice));\r\nfor_each_online_cpu(i) {\r\nuser = kstat_cpu(i).cpustat.user;\r\nnice = kstat_cpu(i).cpustat.nice;\r\nsystem = kstat_cpu(i).cpustat.system;\r\nidle = kstat_cpu(i).cpustat.idle;\r\nidle = cputime64_add(idle, arch_idle_time(i));\r\niowait = kstat_cpu(i).cpustat.iowait;\r\nirq = kstat_cpu(i).cpustat.irq;\r\nsoftirq = kstat_cpu(i).cpustat.softirq;\r\nsteal = kstat_cpu(i).cpustat.steal;\r\nguest = kstat_cpu(i).cpustat.guest;\r\nguest_nice = kstat_cpu(i).cpustat.guest_nice;\r\nseq_printf(p,\r\n"cpu%d %llu %llu %llu %llu %llu %llu %llu %llu %llu "\r\n"%llu\n",\r\ni,\r\n(unsigned long long)cputime64_to_clock_t(user),\r\n(unsigned long long)cputime64_to_clock_t(nice),\r\n(unsigned long long)cputime64_to_clock_t(system),\r\n(unsigned long long)cputime64_to_clock_t(idle),\r\n(unsigned long long)cputime64_to_clock_t(iowait),\r\n(unsigned long long)cputime64_to_clock_t(irq),\r\n(unsigned long long)cputime64_to_clock_t(softirq),\r\n(unsigned long long)cputime64_to_clock_t(steal),\r\n(unsigned long long)cputime64_to_clock_t(guest),\r\n(unsigned long long)cputime64_to_clock_t(guest_nice));\r\n}\r\nseq_printf(p, "intr %llu", (unsigned long long)sum);\r\nfor_each_irq_nr(j)\r\nseq_printf(p, " %u", kstat_irqs(j));\r\nseq_printf(p,\r\n"\nctxt %llu\n"\r\n"btime %lu\n"\r\n"processes %lu\n"\r\n"procs_running %lu\n"\r\n"procs_blocked %lu\n",\r\nnr_context_switches(),\r\n(unsigned long)jif,\r\ntotal_forks,\r\nnr_running(),\r\nnr_iowait());\r\nseq_printf(p, "softirq %llu", (unsigned long long)sum_softirq);\r\nfor (i = 0; i < NR_SOFTIRQS; i++)\r\nseq_printf(p, " %u", per_softirq_sums[i]);\r\nseq_putc(p, '\n');\r\nreturn 0;\r\n}\r\nstatic int stat_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned size = 4096 * (1 + num_possible_cpus() / 32);\r\nchar *buf;\r\nstruct seq_file *m;\r\nint res;\r\nif (size > KMALLOC_MAX_SIZE)\r\nsize = KMALLOC_MAX_SIZE;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nres = single_open(file, show_stat, NULL);\r\nif (!res) {\r\nm = file->private_data;\r\nm->buf = buf;\r\nm->size = size;\r\n} else\r\nkfree(buf);\r\nreturn res;\r\n}\r\nstatic int __init proc_stat_init(void)\r\n{\r\nproc_create("stat", 0, NULL, &proc_stat_operations);\r\nreturn 0;\r\n}
