static inline void wb977_open(void)\r\n{\r\noutb(0x87, 0x370);\r\noutb(0x87, 0x370);\r\n}\r\nstatic inline void wb977_close(void)\r\n{\r\noutb(0xaa, 0x370);\r\n}\r\nstatic inline void wb977_wb(int reg, int val)\r\n{\r\noutb(reg, 0x370);\r\noutb(val, 0x371);\r\n}\r\nstatic inline void wb977_ww(int reg, int val)\r\n{\r\noutb(reg, 0x370);\r\noutb(val >> 8, 0x371);\r\noutb(reg + 1, 0x370);\r\noutb(val & 255, 0x371);\r\n}\r\nvoid nw_gpio_modify_op(unsigned int mask, unsigned int set)\r\n{\r\nunsigned int new_gpio, changed;\r\nnew_gpio = (current_gpio_op & ~mask) | set;\r\nchanged = new_gpio ^ current_gpio_op;\r\ncurrent_gpio_op = new_gpio;\r\nif (changed & 0xff)\r\noutb(new_gpio, GP1_IO_BASE);\r\nif (changed & 0xff00)\r\noutb(new_gpio >> 8, GP2_IO_BASE);\r\n}\r\nstatic inline void __gpio_modify_io(int mask, int in)\r\n{\r\nunsigned int new_gpio, changed;\r\nint port;\r\nnew_gpio = (current_gpio_io & ~mask) | in;\r\nchanged = new_gpio ^ current_gpio_io;\r\ncurrent_gpio_io = new_gpio;\r\nchanged >>= 1;\r\nnew_gpio >>= 1;\r\nwb977_device_select(7);\r\nfor (port = 0xe1; changed && port < 0xe8; changed >>= 1) {\r\nwb977_wb(port, new_gpio & 1);\r\nport += 1;\r\nnew_gpio >>= 1;\r\n}\r\nwb977_device_select(8);\r\nfor (port = 0xe8; changed && port < 0xec; changed >>= 1) {\r\nwb977_wb(port, new_gpio & 1);\r\nport += 1;\r\nnew_gpio >>= 1;\r\n}\r\n}\r\nvoid nw_gpio_modify_io(unsigned int mask, unsigned int in)\r\n{\r\nwb977_open();\r\n__gpio_modify_io(mask, in);\r\nwb977_close();\r\n}\r\nunsigned int nw_gpio_read(void)\r\n{\r\nreturn inb(GP1_IO_BASE) | inb(GP2_IO_BASE) << 8;\r\n}\r\nstatic inline void wb977_init_global(void)\r\n{\r\nwb977_wb(0x26, 0x40);\r\nwb977_wb(0x22, 0xfe);\r\nwb977_wb(0x2a, 0xc1);\r\nwb977_wb(0x2b, 0x6b);\r\nwb977_wb(0x2c, 0x55);\r\n}\r\nstatic inline void wb977_init_printer(void)\r\n{\r\nwb977_device_select(1);\r\nwb977_wb(0xf0, 0x01);\r\n}\r\nstatic inline void wb977_init_keyboard(void)\r\n{\r\nwb977_device_select(5);\r\nwb977_ww(0x60, 0x0060);\r\nwb977_ww(0x62, 0x0064);\r\nwb977_wb(0x70, 1);\r\nwb977_wb(0x71, 0x02);\r\nwb977_wb(0x72, 5);\r\nwb977_wb(0x73, 0x02);\r\nwb977_wb(0xf0, 0x40);\r\nwb977_device_enable();\r\n}\r\nstatic inline void wb977_init_irda(void)\r\n{\r\nwb977_device_select(6);\r\nwb977_ww(0x60, IRDA_IO_BASE);\r\nwb977_wb(0x70, 6);\r\nwb977_wb(0x71, 0x02);\r\nwb977_wb(0x74, 0x00);\r\nwb977_wb(0x75, 0x04);\r\nwb977_wb(0xf0, 0x03);\r\nwb977_device_enable();\r\n}\r\nstatic inline void wb977_init_gpio(void)\r\n{\r\nunsigned long flags;\r\ncurrent_gpio_io = -1;\r\n__gpio_modify_io(-1, GPIO_DONE | GPIO_WDTIMER);\r\nwb977_device_select(7);\r\nwb977_ww(0x60, GP1_IO_BASE);\r\nwb977_ww(0x62, 0);\r\nwb977_ww(0x64, 0);\r\nwb977_wb(0x70, 10);\r\nwb977_wb(0x71, 0x02);\r\nwb977_wb(0xe0, 0x19);\r\nwb977_device_enable();\r\nwb977_device_select(8);\r\nwb977_ww(0x60, GP2_IO_BASE);\r\nwb977_wb(0xf2, 0x00);\r\nwb977_wb(0xf3, 0x00);\r\nwb977_wb(0xf4, 0x00);\r\nwb977_device_enable();\r\nspin_lock_irqsave(&nw_gpio_lock, flags);\r\nnw_gpio_modify_op(-1, GPIO_RED_LED | GPIO_FAN);\r\nspin_unlock_irqrestore(&nw_gpio_lock, flags);\r\n}\r\nstatic void __init wb977_init(void)\r\n{\r\nrequest_region(0x370, 2, "W83977AF configuration");\r\nwb977_open();\r\nwb977_init_global();\r\nwb977_init_printer();\r\nwb977_init_keyboard();\r\nwb977_init_irda();\r\nwb977_init_gpio();\r\nwb977_close();\r\n}\r\nvoid nw_cpld_modify(unsigned int mask, unsigned int set)\r\n{\r\nint msk;\r\ncurrent_cpld = (current_cpld & ~mask) | set;\r\nnw_gpio_modify_io(GPIO_DATA | GPIO_IOCLK | GPIO_IOLOAD, 0);\r\nnw_gpio_modify_op(GPIO_IOLOAD, 0);\r\nfor (msk = 8; msk; msk >>= 1) {\r\nint bit = current_cpld & msk;\r\nnw_gpio_modify_op(GPIO_DATA | GPIO_IOCLK, bit ? GPIO_DATA : 0);\r\nnw_gpio_modify_op(GPIO_IOCLK, GPIO_IOCLK);\r\n}\r\nnw_gpio_modify_op(GPIO_IOCLK|GPIO_DATA, 0);\r\nnw_gpio_modify_op(GPIO_IOLOAD|GPIO_DSCLK, GPIO_IOLOAD|GPIO_DSCLK);\r\nnw_gpio_modify_op(GPIO_IOLOAD, 0);\r\n}\r\nstatic void __init cpld_init(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&nw_gpio_lock, flags);\r\nnw_cpld_modify(-1, CPLD_UNMUTE | CPLD_7111_DISABLE);\r\nspin_unlock_irqrestore(&nw_gpio_lock, flags);\r\n}\r\nstatic inline void rwa010_unlock(void)\r\n{\r\nint i;\r\nWRITE_RWA(2, 2);\r\nmdelay(10);\r\nfor (i = 0; i < sizeof(rwa_unlock); i++) {\r\noutb(rwa_unlock[i], 0x279);\r\nudelay(10);\r\n}\r\n}\r\nstatic inline void rwa010_read_ident(void)\r\n{\r\nunsigned char si[9];\r\nint i, j;\r\nWRITE_RWA(3, 0);\r\nWRITE_RWA(0, 128);\r\noutb(1, 0x279);\r\nmdelay(1);\r\ndprintk("Identifier: ");\r\nfor (i = 0; i < 9; i++) {\r\nsi[i] = 0;\r\nfor (j = 0; j < 8; j++) {\r\nint bit;\r\nudelay(250);\r\ninb(0x203);\r\nudelay(250);\r\nbit = inb(0x203);\r\ndprintk("%02X ", bit);\r\nbit = (bit == 0xaa) ? 1 : 0;\r\nsi[i] |= bit << j;\r\n}\r\ndprintk("(%02X) ", si[i]);\r\n}\r\ndprintk("\n");\r\n}\r\nstatic inline void rwa010_global_init(void)\r\n{\r\nWRITE_RWA(6, 2);\r\ndprintk("Card no = %d\n", inb(0x203));\r\nWRITE_RWA(7, 3);\r\nWRITE_RWA(0x30, 0);\r\nWRITE_RWA(7, 4);\r\nWRITE_RWA(0x30, 0);\r\nWRITE_RWA(7, 2);\r\nWRITE_RWA(0x30, 0);\r\n}\r\nstatic inline void rwa010_game_port_init(void)\r\n{\r\nint i;\r\nWRITE_RWA(7, 5);\r\ndprintk("Slider base: ");\r\nWRITE_RWA(0x61, 1);\r\ni = inb(0x203);\r\nWRITE_RWA(0x60, 2);\r\ndprintk("%02X%02X (201)\n", inb(0x203), i);\r\nWRITE_RWA(0x30, 1);\r\n}\r\nstatic inline void rwa010_waveartist_init(int base, int irq, int dma)\r\n{\r\nint i;\r\nWRITE_RWA(7, 0);\r\ndprintk("WaveArtist base: ");\r\nWRITE_RWA(0x61, base & 255);\r\ni = inb(0x203);\r\nWRITE_RWA(0x60, base >> 8);\r\ndprintk("%02X%02X (%X),", inb(0x203), i, base);\r\nWRITE_RWA(0x70, irq);\r\ndprintk(" irq: %d (%d),", inb(0x203), irq);\r\nWRITE_RWA(0x74, dma);\r\ndprintk(" dma: %d (%d)\n", inb(0x203), dma);\r\nWRITE_RWA(0x30, 1);\r\n}\r\nstatic inline void rwa010_soundblaster_init(int sb_base, int al_base, int irq, int dma)\r\n{\r\nint i;\r\nWRITE_RWA(7, 1);\r\ndprintk("SoundBlaster base: ");\r\nWRITE_RWA(0x61, sb_base & 255);\r\ni = inb(0x203);\r\nWRITE_RWA(0x60, sb_base >> 8);\r\ndprintk("%02X%02X (%X),", inb(0x203), i, sb_base);\r\ndprintk(" irq: ");\r\nWRITE_RWA(0x70, irq);\r\ndprintk("%d (%d),", inb(0x203), irq);\r\ndprintk(" 8-bit DMA: ");\r\nWRITE_RWA(0x74, dma);\r\ndprintk("%d (%d)\n", inb(0x203), dma);\r\ndprintk("AdLib base: ");\r\nWRITE_RWA(0x63, al_base & 255);\r\ni = inb(0x203);\r\nWRITE_RWA(0x62, al_base >> 8);\r\ndprintk("%02X%02X (%X)\n", inb(0x203), i, al_base);\r\nWRITE_RWA(0x30, 1);\r\n}\r\nstatic void rwa010_soundblaster_reset(void)\r\n{\r\nint i;\r\noutb(1, 0x226);\r\nudelay(3);\r\noutb(0, 0x226);\r\nfor (i = 0; i < 5; i++) {\r\nif (inb(0x22e) & 0x80)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == 5)\r\nprintk("SoundBlaster: DSP reset failed\n");\r\ndprintk("SoundBlaster DSP reset: %02X (AA)\n", inb(0x22a));\r\nfor (i = 0; i < 5; i++) {\r\nif ((inb(0x22c) & 0x80) == 0)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == 5)\r\nprintk("SoundBlaster: DSP not ready\n");\r\nelse {\r\noutb(0xe1, 0x22c);\r\ndprintk("SoundBlaster DSP id: ");\r\ni = inb(0x22a);\r\nudelay(1);\r\ni |= inb(0x22a) << 8;\r\ndprintk("%04X\n", i);\r\nfor (i = 0; i < 5; i++) {\r\nif ((inb(0x22c) & 0x80) == 0)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == 5)\r\nprintk("SoundBlaster: could not turn speaker off\n");\r\noutb(0xd3, 0x22c);\r\n}\r\noutb(5, 0x38a);\r\noutb(1, 0x38b);\r\n}\r\nstatic void __init rwa010_init(void)\r\n{\r\nrwa010_unlock();\r\nrwa010_read_ident();\r\nrwa010_global_init();\r\nrwa010_game_port_init();\r\nrwa010_waveartist_init(0x250, 3, 7);\r\nrwa010_soundblaster_init(0x220, 0x388, 3, 1);\r\nrwa010_soundblaster_reset();\r\n}\r\nstatic int __init nw_hw_init(void)\r\n{\r\nif (machine_is_netwinder()) {\r\nunsigned long flags;\r\nwb977_init();\r\ncpld_init();\r\nrwa010_init();\r\nspin_lock_irqsave(&nw_gpio_lock, flags);\r\nnw_gpio_modify_op(GPIO_RED_LED|GPIO_GREEN_LED, DEFAULT_LEDS);\r\nspin_unlock_irqrestore(&nw_gpio_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init\r\nfixup_netwinder(struct machine_desc *desc, struct tag *tags,\r\nchar **cmdline, struct meminfo *mi)\r\n{\r\n#ifdef CONFIG_ISAPNP\r\nextern int isapnp_disable;\r\nisapnp_disable = 1;\r\n#endif\r\n}
