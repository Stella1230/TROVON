static void\r\nlegacy_perf_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nvbios *bios = &dev_priv->vbios;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nchar *perf, *entry, *bmp = &bios->data[bios->offset];\r\nint headerlen, use_straps;\r\nif (bmp[5] < 0x5 || bmp[6] < 0x14) {\r\nNV_DEBUG(dev, "BMP version too old for perf\n");\r\nreturn;\r\n}\r\nperf = ROMPTR(bios, bmp[0x73]);\r\nif (!perf) {\r\nNV_DEBUG(dev, "No memclock table pointer found.\n");\r\nreturn;\r\n}\r\nswitch (perf[0]) {\r\ncase 0x12:\r\ncase 0x14:\r\ncase 0x18:\r\nuse_straps = 0;\r\nheaderlen = 1;\r\nbreak;\r\ncase 0x01:\r\nuse_straps = perf[1] & 1;\r\nheaderlen = (use_straps ? 8 : 2);\r\nbreak;\r\ndefault:\r\nNV_WARN(dev, "Unknown memclock table version %x.\n", perf[0]);\r\nreturn;\r\n}\r\nentry = perf + headerlen;\r\nif (use_straps)\r\nentry += (nv_rd32(dev, NV_PEXTDEV_BOOT_0) & 0x3c) >> 1;\r\nsprintf(pm->perflvl[0].name, "performance_level_0");\r\npm->perflvl[0].memory = ROM16(entry[0]) * 20;\r\npm->nr_perflvl = 1;\r\n}\r\nstatic struct nouveau_pm_memtiming *\r\nnouveau_perf_timing(struct drm_device *dev, struct bit_entry *P,\r\nu16 memclk, u8 *entry, u8 recordlen, u8 entries)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nvbios *bios = &dev_priv->vbios;\r\nu8 ramcfg;\r\nint i;\r\nif (P->version == 2) {\r\nu8 *tmap = ROMPTR(bios, P->data[4]);\r\nif (!tmap) {\r\nNV_DEBUG(dev, "no timing map pointer\n");\r\nreturn NULL;\r\n}\r\nif (tmap[0] != 0x10) {\r\nNV_WARN(dev, "timing map 0x%02x unknown\n", tmap[0]);\r\nreturn NULL;\r\n}\r\nentry = tmap + tmap[1];\r\nrecordlen = tmap[2] + (tmap[4] * tmap[3]);\r\nfor (i = 0; i < tmap[5]; i++, entry += recordlen) {\r\nif (memclk >= ROM16(entry[0]) &&\r\nmemclk <= ROM16(entry[2]))\r\nbreak;\r\n}\r\nif (i == tmap[5]) {\r\nNV_WARN(dev, "no match in timing map table\n");\r\nreturn NULL;\r\n}\r\nentry += tmap[2];\r\nrecordlen = tmap[3];\r\nentries = tmap[4];\r\n}\r\nramcfg = (nv_rd32(dev, NV_PEXTDEV_BOOT_0) & 0x0000003c) >> 2;\r\nif (bios->ram_restrict_tbl_ptr)\r\nramcfg = bios->data[bios->ram_restrict_tbl_ptr + ramcfg];\r\nif (ramcfg >= entries) {\r\nNV_WARN(dev, "ramcfg strap out of bounds!\n");\r\nreturn NULL;\r\n}\r\nentry += ramcfg * recordlen;\r\nif (entry[1] >= pm->memtimings.nr_timing) {\r\nNV_WARN(dev, "timingset %d does not exist\n", entry[1]);\r\nreturn NULL;\r\n}\r\nreturn &pm->memtimings.timing[entry[1]];\r\n}\r\nvoid\r\nnouveau_perf_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nvbios *bios = &dev_priv->vbios;\r\nstruct bit_entry P;\r\nu8 version, headerlen, recordlen, entries;\r\nu8 *perf, *entry;\r\nint vid, i;\r\nif (bios->type == NVBIOS_BIT) {\r\nif (bit_table(dev, 'P', &P))\r\nreturn;\r\nif (P.version != 1 && P.version != 2) {\r\nNV_WARN(dev, "unknown perf for BIT P %d\n", P.version);\r\nreturn;\r\n}\r\nperf = ROMPTR(bios, P.data[0]);\r\nversion = perf[0];\r\nheaderlen = perf[1];\r\nif (version < 0x40) {\r\nrecordlen = perf[3] + (perf[4] * perf[5]);\r\nentries = perf[2];\r\n} else {\r\nrecordlen = perf[2] + (perf[3] * perf[4]);\r\nentries = perf[5];\r\n}\r\n} else {\r\nif (bios->data[bios->offset + 6] < 0x25) {\r\nlegacy_perf_init(dev);\r\nreturn;\r\n}\r\nperf = ROMPTR(bios, bios->data[bios->offset + 0x94]);\r\nif (!perf) {\r\nNV_DEBUG(dev, "perf table pointer invalid\n");\r\nreturn;\r\n}\r\nversion = perf[1];\r\nheaderlen = perf[0];\r\nrecordlen = perf[3];\r\nentries = perf[2];\r\n}\r\nif (entries > NOUVEAU_PM_MAX_LEVEL) {\r\nNV_DEBUG(dev, "perf table has too many entries - buggy vbios?\n");\r\nentries = NOUVEAU_PM_MAX_LEVEL;\r\n}\r\nentry = perf + headerlen;\r\nfor (i = 0; i < entries; i++) {\r\nstruct nouveau_pm_level *perflvl = &pm->perflvl[pm->nr_perflvl];\r\nperflvl->timing = NULL;\r\nif (entry[0] == 0xff) {\r\nentry += recordlen;\r\ncontinue;\r\n}\r\nswitch (version) {\r\ncase 0x12:\r\ncase 0x13:\r\ncase 0x15:\r\nperflvl->fanspeed = entry[55];\r\nperflvl->voltage = (recordlen > 56) ? entry[56] : 0;\r\nperflvl->core = ROM32(entry[1]) * 10;\r\nperflvl->memory = ROM32(entry[5]) * 20;\r\nbreak;\r\ncase 0x21:\r\ncase 0x23:\r\ncase 0x24:\r\nperflvl->fanspeed = entry[4];\r\nperflvl->voltage = entry[5];\r\nperflvl->core = ROM16(entry[6]) * 1000;\r\nif (dev_priv->chipset == 0x49 ||\r\ndev_priv->chipset == 0x4b)\r\nperflvl->memory = ROM16(entry[11]) * 1000;\r\nelse\r\nperflvl->memory = ROM16(entry[11]) * 2000;\r\nbreak;\r\ncase 0x25:\r\nperflvl->fanspeed = entry[4];\r\nperflvl->voltage = entry[5];\r\nperflvl->core = ROM16(entry[6]) * 1000;\r\nperflvl->shader = ROM16(entry[10]) * 1000;\r\nperflvl->memory = ROM16(entry[12]) * 1000;\r\nbreak;\r\ncase 0x30:\r\nperflvl->memscript = ROM16(entry[2]);\r\ncase 0x35:\r\nperflvl->fanspeed = entry[6];\r\nperflvl->voltage = entry[7];\r\nperflvl->core = ROM16(entry[8]) * 1000;\r\nperflvl->shader = ROM16(entry[10]) * 1000;\r\nperflvl->memory = ROM16(entry[12]) * 1000;\r\nperflvl->unk05 = ROM16(entry[16]) * 1000;\r\nbreak;\r\ncase 0x40:\r\n#define subent(n) entry[perf[2] + ((n) * perf[3])]\r\nperflvl->fanspeed = 0;\r\nperflvl->voltage = entry[2];\r\nif (dev_priv->card_type == NV_50) {\r\nperflvl->core = ROM16(subent(0)) & 0xfff;\r\nperflvl->shader = ROM16(subent(1)) & 0xfff;\r\nperflvl->memory = ROM16(subent(2)) & 0xfff;\r\n} else {\r\nperflvl->shader = ROM16(subent(3)) & 0xfff;\r\nperflvl->core = perflvl->shader / 2;\r\nperflvl->unk0a = ROM16(subent(4)) & 0xfff;\r\nperflvl->memory = ROM16(subent(5)) & 0xfff;\r\n}\r\nperflvl->core *= 1000;\r\nperflvl->shader *= 1000;\r\nperflvl->memory *= 1000;\r\nperflvl->unk0a *= 1000;\r\nbreak;\r\n}\r\nif (pm->voltage.supported && perflvl->voltage) {\r\nvid = nouveau_volt_vid_lookup(dev, perflvl->voltage);\r\nif (vid < 0) {\r\nNV_DEBUG(dev, "drop perflvl %d, bad vid\n", i);\r\nentry += recordlen;\r\ncontinue;\r\n}\r\n}\r\nif (version > 0x15) {\r\nperflvl->timing =\r\nnouveau_perf_timing(dev, &P,\r\nperflvl->memory / 1000,\r\nentry + perf[3],\r\nperf[5], perf[4]);\r\n}\r\nsnprintf(perflvl->name, sizeof(perflvl->name),\r\n"performance_level_%d", i);\r\nperflvl->id = i;\r\npm->nr_perflvl++;\r\nentry += recordlen;\r\n}\r\n}\r\nvoid\r\nnouveau_perf_fini(struct drm_device *dev)\r\n{\r\n}
