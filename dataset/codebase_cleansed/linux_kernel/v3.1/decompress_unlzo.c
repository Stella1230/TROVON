STATIC inline int INIT parse_header(u8 *input, int *skip, int in_len)\r\n{\r\nint l;\r\nu8 *parse = input;\r\nu8 *end = input + in_len;\r\nu8 level = 0;\r\nu16 version;\r\nif (in_len < HEADER_SIZE_MIN)\r\nreturn 0;\r\nfor (l = 0; l < 9; l++) {\r\nif (*parse++ != lzop_magic[l])\r\nreturn 0;\r\n}\r\nversion = get_unaligned_be16(parse);\r\nparse += 7;\r\nif (version >= 0x0940)\r\nlevel = *parse++;\r\nif (get_unaligned_be32(parse) & HEADER_HAS_FILTER)\r\nparse += 8;\r\nelse\r\nparse += 4;\r\nif (end - parse < 8 + 1 + 4)\r\nreturn 0;\r\nparse += 8;\r\nif (version >= 0x0940)\r\nparse += 4;\r\nl = *parse++;\r\nif (end - parse < l + 4)\r\nreturn 0;\r\nparse += l + 4;\r\n*skip = parse - input;\r\nreturn 1;\r\n}\r\nSTATIC inline int INIT unlzo(u8 *input, int in_len,\r\nint (*fill) (void *, unsigned int),\r\nint (*flush) (void *, unsigned int),\r\nu8 *output, int *posp,\r\nvoid (*error) (char *x))\r\n{\r\nu8 r = 0;\r\nint skip = 0;\r\nu32 src_len, dst_len;\r\nsize_t tmp;\r\nu8 *in_buf, *in_buf_save, *out_buf;\r\nint ret = -1;\r\nif (output) {\r\nout_buf = output;\r\n} else if (!flush) {\r\nerror("NULL output pointer and no flush function provided");\r\ngoto exit;\r\n} else {\r\nout_buf = malloc(LZO_BLOCK_SIZE);\r\nif (!out_buf) {\r\nerror("Could not allocate output buffer");\r\ngoto exit;\r\n}\r\n}\r\nif (input && fill) {\r\nerror("Both input pointer and fill function provided, don't know what to do");\r\ngoto exit_1;\r\n} else if (input) {\r\nin_buf = input;\r\n} else if (!fill) {\r\nerror("NULL input pointer and missing fill function");\r\ngoto exit_1;\r\n} else {\r\nin_buf = malloc(lzo1x_worst_compress(LZO_BLOCK_SIZE));\r\nif (!in_buf) {\r\nerror("Could not allocate input buffer");\r\ngoto exit_1;\r\n}\r\n}\r\nin_buf_save = in_buf;\r\nif (posp)\r\n*posp = 0;\r\nif (fill) {\r\nin_buf += HEADER_SIZE_MAX;\r\nin_len = fill(in_buf, HEADER_SIZE_MAX);\r\n}\r\nif (!parse_header(in_buf, &skip, in_len)) {\r\nerror("invalid header");\r\ngoto exit_2;\r\n}\r\nin_buf += skip;\r\nin_len -= skip;\r\nif (fill) {\r\nmemcpy(in_buf_save, in_buf, in_len);\r\nin_buf = in_buf_save;\r\n}\r\nif (posp)\r\n*posp = skip;\r\nfor (;;) {\r\nif (fill && in_len < 4) {\r\nskip = fill(in_buf + in_len, 4 - in_len);\r\nif (skip > 0)\r\nin_len += skip;\r\n}\r\nif (in_len < 4) {\r\nerror("file corrupted");\r\ngoto exit_2;\r\n}\r\ndst_len = get_unaligned_be32(in_buf);\r\nin_buf += 4;\r\nin_len -= 4;\r\nif (dst_len == 0) {\r\nif (posp)\r\n*posp += 4;\r\nbreak;\r\n}\r\nif (dst_len > LZO_BLOCK_SIZE) {\r\nerror("dest len longer than block size");\r\ngoto exit_2;\r\n}\r\nif (fill && in_len < 8) {\r\nskip = fill(in_buf + in_len, 8 - in_len);\r\nif (skip > 0)\r\nin_len += skip;\r\n}\r\nif (in_len < 8) {\r\nerror("file corrupted");\r\ngoto exit_2;\r\n}\r\nsrc_len = get_unaligned_be32(in_buf);\r\nin_buf += 8;\r\nin_len -= 8;\r\nif (src_len <= 0 || src_len > dst_len) {\r\nerror("file corrupted");\r\ngoto exit_2;\r\n}\r\nif (fill && in_len < src_len) {\r\nskip = fill(in_buf + in_len, src_len - in_len);\r\nif (skip > 0)\r\nin_len += skip;\r\n}\r\nif (in_len < src_len) {\r\nerror("file corrupted");\r\ngoto exit_2;\r\n}\r\ntmp = dst_len;\r\nif (unlikely(dst_len == src_len))\r\nmemcpy(out_buf, in_buf, src_len);\r\nelse {\r\nr = lzo1x_decompress_safe((u8 *) in_buf, src_len,\r\nout_buf, &tmp);\r\nif (r != LZO_E_OK || dst_len != tmp) {\r\nerror("Compressed data violation");\r\ngoto exit_2;\r\n}\r\n}\r\nif (flush && flush(out_buf, dst_len) != dst_len)\r\ngoto exit_2;\r\nif (output)\r\nout_buf += dst_len;\r\nif (posp)\r\n*posp += src_len + 12;\r\nin_buf += src_len;\r\nin_len -= src_len;\r\nif (fill) {\r\nif (in_len > 0)\r\nfor (skip = 0; skip < in_len; ++skip)\r\nin_buf_save[skip] = in_buf[skip];\r\nin_buf = in_buf_save;\r\n}\r\n}\r\nret = 0;\r\nexit_2:\r\nif (!input)\r\nfree(in_buf);\r\nexit_1:\r\nif (!output)\r\nfree(out_buf);\r\nexit:\r\nreturn ret;\r\n}
