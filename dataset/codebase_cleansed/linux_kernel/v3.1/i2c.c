u8 solo_i2c_readbyte(struct solo_dev *solo_dev, int id, u8 addr, u8 off)\r\n{\r\nstruct i2c_msg msgs[2];\r\nu8 data;\r\nmsgs[0].flags = 0;\r\nmsgs[0].addr = addr;\r\nmsgs[0].len = 1;\r\nmsgs[0].buf = &off;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].addr = addr;\r\nmsgs[1].len = 1;\r\nmsgs[1].buf = &data;\r\ni2c_transfer(&solo_dev->i2c_adap[id], msgs, 2);\r\nreturn data;\r\n}\r\nvoid solo_i2c_writebyte(struct solo_dev *solo_dev, int id, u8 addr,\r\nu8 off, u8 data)\r\n{\r\nstruct i2c_msg msgs;\r\nu8 buf[2];\r\nbuf[0] = off;\r\nbuf[1] = data;\r\nmsgs.flags = 0;\r\nmsgs.addr = addr;\r\nmsgs.len = 2;\r\nmsgs.buf = buf;\r\ni2c_transfer(&solo_dev->i2c_adap[id], &msgs, 1);\r\n}\r\nstatic void solo_i2c_flush(struct solo_dev *solo_dev, int wr)\r\n{\r\nu32 ctrl;\r\nctrl = SOLO_IIC_CH_SET(solo_dev->i2c_id);\r\nif (solo_dev->i2c_state == IIC_STATE_START)\r\nctrl |= SOLO_IIC_START;\r\nif (wr) {\r\nctrl |= SOLO_IIC_WRITE;\r\n} else {\r\nctrl |= SOLO_IIC_READ;\r\nif (!(solo_dev->i2c_msg->flags & I2C_M_NO_RD_ACK))\r\nctrl |= SOLO_IIC_ACK_EN;\r\n}\r\nif (solo_dev->i2c_msg_ptr == solo_dev->i2c_msg->len)\r\nctrl |= SOLO_IIC_STOP;\r\nsolo_reg_write(solo_dev, SOLO_IIC_CTRL, ctrl);\r\n}\r\nstatic void solo_i2c_start(struct solo_dev *solo_dev)\r\n{\r\nu32 addr = solo_dev->i2c_msg->addr << 1;\r\nif (solo_dev->i2c_msg->flags & I2C_M_RD)\r\naddr |= 1;\r\nsolo_dev->i2c_state = IIC_STATE_START;\r\nsolo_reg_write(solo_dev, SOLO_IIC_TXD, addr);\r\nsolo_i2c_flush(solo_dev, 1);\r\n}\r\nstatic void solo_i2c_stop(struct solo_dev *solo_dev)\r\n{\r\nsolo_irq_off(solo_dev, SOLO_IRQ_IIC);\r\nsolo_reg_write(solo_dev, SOLO_IIC_CTRL, 0);\r\nsolo_dev->i2c_state = IIC_STATE_STOP;\r\nwake_up(&solo_dev->i2c_wait);\r\n}\r\nstatic int solo_i2c_handle_read(struct solo_dev *solo_dev)\r\n{\r\nprepare_read:\r\nif (solo_dev->i2c_msg_ptr != solo_dev->i2c_msg->len) {\r\nsolo_i2c_flush(solo_dev, 0);\r\nreturn 0;\r\n}\r\nsolo_dev->i2c_msg_ptr = 0;\r\nsolo_dev->i2c_msg++;\r\nsolo_dev->i2c_msg_num--;\r\nif (solo_dev->i2c_msg_num == 0) {\r\nsolo_i2c_stop(solo_dev);\r\nreturn 0;\r\n}\r\nif (!(solo_dev->i2c_msg->flags & I2C_M_NOSTART)) {\r\nsolo_i2c_start(solo_dev);\r\n} else {\r\nif (solo_dev->i2c_msg->flags & I2C_M_RD)\r\ngoto prepare_read;\r\nelse\r\nsolo_i2c_stop(solo_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int solo_i2c_handle_write(struct solo_dev *solo_dev)\r\n{\r\nretry_write:\r\nif (solo_dev->i2c_msg_ptr != solo_dev->i2c_msg->len) {\r\nsolo_reg_write(solo_dev, SOLO_IIC_TXD,\r\nsolo_dev->i2c_msg->buf[solo_dev->i2c_msg_ptr]);\r\nsolo_dev->i2c_msg_ptr++;\r\nsolo_i2c_flush(solo_dev, 1);\r\nreturn 0;\r\n}\r\nsolo_dev->i2c_msg_ptr = 0;\r\nsolo_dev->i2c_msg++;\r\nsolo_dev->i2c_msg_num--;\r\nif (solo_dev->i2c_msg_num == 0) {\r\nsolo_i2c_stop(solo_dev);\r\nreturn 0;\r\n}\r\nif (!(solo_dev->i2c_msg->flags & I2C_M_NOSTART)) {\r\nsolo_i2c_start(solo_dev);\r\n} else {\r\nif (solo_dev->i2c_msg->flags & I2C_M_RD)\r\nsolo_i2c_stop(solo_dev);\r\nelse\r\ngoto retry_write;\r\n}\r\nreturn 0;\r\n}\r\nint solo_i2c_isr(struct solo_dev *solo_dev)\r\n{\r\nu32 status = solo_reg_read(solo_dev, SOLO_IIC_CTRL);\r\nint ret = -EINVAL;\r\nsolo_reg_write(solo_dev, SOLO_IRQ_STAT, SOLO_IRQ_IIC);\r\nif (status & (SOLO_IIC_STATE_TRNS & SOLO_IIC_STATE_SIG_ERR) ||\r\nsolo_dev->i2c_id < 0) {\r\nsolo_i2c_stop(solo_dev);\r\nreturn -ENXIO;\r\n}\r\nswitch (solo_dev->i2c_state) {\r\ncase IIC_STATE_START:\r\nif (solo_dev->i2c_msg->flags & I2C_M_RD) {\r\nsolo_dev->i2c_state = IIC_STATE_READ;\r\nret = solo_i2c_handle_read(solo_dev);\r\nbreak;\r\n}\r\nsolo_dev->i2c_state = IIC_STATE_WRITE;\r\ncase IIC_STATE_WRITE:\r\nret = solo_i2c_handle_write(solo_dev);\r\nbreak;\r\ncase IIC_STATE_READ:\r\nsolo_dev->i2c_msg->buf[solo_dev->i2c_msg_ptr] =\r\nsolo_reg_read(solo_dev, SOLO_IIC_RXD);\r\nsolo_dev->i2c_msg_ptr++;\r\nret = solo_i2c_handle_read(solo_dev);\r\nbreak;\r\ndefault:\r\nsolo_i2c_stop(solo_dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int solo_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct solo_dev *solo_dev = adap->algo_data;\r\nunsigned long timeout;\r\nint ret;\r\nint i;\r\nDEFINE_WAIT(wait);\r\nfor (i = 0; i < SOLO_I2C_ADAPTERS; i++) {\r\nif (&solo_dev->i2c_adap[i] == adap)\r\nbreak;\r\n}\r\nif (i == SOLO_I2C_ADAPTERS)\r\nreturn num;\r\nmutex_lock(&solo_dev->i2c_mutex);\r\nsolo_dev->i2c_id = i;\r\nsolo_dev->i2c_msg = msgs;\r\nsolo_dev->i2c_msg_num = num;\r\nsolo_dev->i2c_msg_ptr = 0;\r\nsolo_reg_write(solo_dev, SOLO_IIC_CTRL, 0);\r\nsolo_irq_on(solo_dev, SOLO_IRQ_IIC);\r\nsolo_i2c_start(solo_dev);\r\ntimeout = HZ / 2;\r\nfor (;;) {\r\nprepare_to_wait(&solo_dev->i2c_wait, &wait, TASK_INTERRUPTIBLE);\r\nif (solo_dev->i2c_state == IIC_STATE_STOP)\r\nbreak;\r\ntimeout = schedule_timeout(timeout);\r\nif (!timeout)\r\nbreak;\r\nif (signal_pending(current))\r\nbreak;\r\n}\r\nfinish_wait(&solo_dev->i2c_wait, &wait);\r\nret = num - solo_dev->i2c_msg_num;\r\nsolo_dev->i2c_state = IIC_STATE_IDLE;\r\nsolo_dev->i2c_id = -1;\r\nmutex_unlock(&solo_dev->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 solo_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nint solo_i2c_init(struct solo_dev *solo_dev)\r\n{\r\nint i;\r\nint ret;\r\nsolo_reg_write(solo_dev, SOLO_IIC_CFG,\r\nSOLO_IIC_PRESCALE(8) | SOLO_IIC_ENABLE);\r\nsolo_dev->i2c_id = -1;\r\nsolo_dev->i2c_state = IIC_STATE_IDLE;\r\ninit_waitqueue_head(&solo_dev->i2c_wait);\r\nmutex_init(&solo_dev->i2c_mutex);\r\nfor (i = 0; i < SOLO_I2C_ADAPTERS; i++) {\r\nstruct i2c_adapter *adap = &solo_dev->i2c_adap[i];\r\nsnprintf(adap->name, I2C_NAME_SIZE, "%s I2C %d", SOLO6X10_NAME, i);\r\nadap->algo = &solo_i2c_algo;\r\nadap->algo_data = solo_dev;\r\nadap->retries = 1;\r\nadap->dev.parent = &solo_dev->pdev->dev;\r\nret = i2c_add_adapter(adap);\r\nif (ret) {\r\nadap->algo_data = NULL;\r\nbreak;\r\n}\r\n}\r\nif (ret) {\r\nfor (i = 0; i < SOLO_I2C_ADAPTERS; i++) {\r\nif (!solo_dev->i2c_adap[i].algo_data)\r\nbreak;\r\ni2c_del_adapter(&solo_dev->i2c_adap[i]);\r\nsolo_dev->i2c_adap[i].algo_data = NULL;\r\n}\r\nreturn ret;\r\n}\r\ndev_info(&solo_dev->pdev->dev, "Enabled %d i2c adapters\n",\r\nSOLO_I2C_ADAPTERS);\r\nreturn 0;\r\n}\r\nvoid solo_i2c_exit(struct solo_dev *solo_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < SOLO_I2C_ADAPTERS; i++) {\r\nif (!solo_dev->i2c_adap[i].algo_data)\r\ncontinue;\r\ni2c_del_adapter(&solo_dev->i2c_adap[i]);\r\nsolo_dev->i2c_adap[i].algo_data = NULL;\r\n}\r\n}
