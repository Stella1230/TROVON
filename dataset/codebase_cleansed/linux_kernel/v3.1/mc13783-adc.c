static ssize_t mc13783_adc_show_name(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nreturn sprintf(buf, "mc13783_adc\n");\r\n}\r\nstatic int mc13783_adc_read(struct device *dev,\r\nstruct device_attribute *devattr, unsigned int *val)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mc13783_adc_priv *priv = platform_get_drvdata(pdev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nunsigned int channel = attr->index;\r\nunsigned int sample[4];\r\nint ret;\r\nret = mc13783_adc_do_conversion(priv->mc13783,\r\nMC13783_ADC_MODE_MULT_CHAN,\r\nchannel, sample);\r\nif (ret)\r\nreturn ret;\r\nchannel &= 0x7;\r\n*val = (sample[channel % 4] >> (channel > 3 ? 14 : 2)) & 0x3ff;\r\nreturn 0;\r\n}\r\nstatic ssize_t mc13783_adc_read_bp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nunsigned val;\r\nint ret = mc13783_adc_read(dev, devattr, &val);\r\nif (ret)\r\nreturn ret;\r\nval = DIV_ROUND_CLOSEST(val * 9, 4) + 2400;\r\nreturn sprintf(buf, "%u\n", val);\r\n}\r\nstatic ssize_t mc13783_adc_read_gp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nunsigned val;\r\nint ret = mc13783_adc_read(dev, devattr, &val);\r\nif (ret)\r\nreturn ret;\r\nval = DIV_ROUND_CLOSEST(val * 9, 4);\r\nreturn sprintf(buf, "%u\n", val);\r\n}\r\nstatic int mc13783_adc_use_touchscreen(struct platform_device *pdev)\r\n{\r\nstruct mc13783_adc_priv *priv = platform_get_drvdata(pdev);\r\nunsigned flags = mc13783_get_flags(priv->mc13783);\r\nreturn flags & MC13783_USE_TOUCHSCREEN;\r\n}\r\nstatic int __init mc13783_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct mc13783_adc_priv *priv;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->mc13783 = dev_get_drvdata(pdev->dev.parent);\r\nplatform_set_drvdata(pdev, priv);\r\nret = sysfs_create_group(&pdev->dev.kobj, &mc13783_group);\r\nif (ret)\r\ngoto out_err_create1;\r\nif (!mc13783_adc_use_touchscreen(pdev)) {\r\nret = sysfs_create_group(&pdev->dev.kobj, &mc13783_group_ts);\r\nif (ret)\r\ngoto out_err_create2;\r\n}\r\npriv->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(priv->hwmon_dev)) {\r\nret = PTR_ERR(priv->hwmon_dev);\r\ndev_err(&pdev->dev,\r\n"hwmon_device_register failed with %d.\n", ret);\r\ngoto out_err_register;\r\n}\r\nreturn 0;\r\nout_err_register:\r\nif (!mc13783_adc_use_touchscreen(pdev))\r\nsysfs_remove_group(&pdev->dev.kobj, &mc13783_group_ts);\r\nout_err_create2:\r\nsysfs_remove_group(&pdev->dev.kobj, &mc13783_group);\r\nout_err_create1:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int __devexit mc13783_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct mc13783_adc_priv *priv = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(priv->hwmon_dev);\r\nif (!mc13783_adc_use_touchscreen(pdev))\r\nsysfs_remove_group(&pdev->dev.kobj, &mc13783_group_ts);\r\nsysfs_remove_group(&pdev->dev.kobj, &mc13783_group);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init mc13783_adc_init(void)\r\n{\r\nreturn platform_driver_probe(&mc13783_adc_driver, mc13783_adc_probe);\r\n}\r\nstatic void __exit mc13783_adc_exit(void)\r\n{\r\nplatform_driver_unregister(&mc13783_adc_driver);\r\n}
