static struct s3c_pl330_chan *id_to_chan(const enum dma_ch id)\r\n{\r\nstruct s3c_pl330_chan *ch;\r\nlist_for_each_entry(ch, &chan_list, node)\r\nif (ch->id == id)\r\nreturn ch;\r\nreturn NULL;\r\n}\r\nstatic void chan_add(const enum dma_ch id)\r\n{\r\nstruct s3c_pl330_chan *ch = id_to_chan(id);\r\nif (ch)\r\nreturn;\r\nch = kmalloc(sizeof(*ch), GFP_KERNEL);\r\nif (!ch)\r\nreturn;\r\nch->id = id;\r\nch->dmac = NULL;\r\nlist_add_tail(&ch->node, &chan_list);\r\n}\r\nstatic bool chan_free(struct s3c_pl330_chan *ch)\r\n{\r\nif (!ch)\r\nreturn false;\r\nreturn ch->dmac ? false : true;\r\n}\r\nstatic unsigned iface_of_dmac(struct s3c_pl330_dmac *dmac, enum dma_ch ch_id)\r\n{\r\nenum dma_ch *id = dmac->peri;\r\nint i;\r\nif (ch_id == DMACH_MAX)\r\nreturn 0;\r\nfor (i = 0; i < PL330_MAX_PERI; i++)\r\nif (id[i] == ch_id)\r\nreturn i + 1;\r\nreturn 0;\r\n}\r\nstatic inline bool dmac_busy(struct s3c_pl330_dmac *dmac)\r\n{\r\nstruct pl330_info *pi = dmac->pi;\r\nreturn (dmac->busy_chan < pi->pcfg.num_chan) ? false : true;\r\n}\r\nstatic unsigned ch_onlyby_dmac(struct s3c_pl330_dmac *dmac)\r\n{\r\nenum dma_ch *id = dmac->peri;\r\nstruct s3c_pl330_dmac *d;\r\nstruct s3c_pl330_chan *ch;\r\nunsigned found, count = 0;\r\nenum dma_ch p;\r\nint i;\r\nfor (i = 0; i < PL330_MAX_PERI; i++) {\r\np = id[i];\r\nch = id_to_chan(p);\r\nif (p == DMACH_MAX || !chan_free(ch))\r\ncontinue;\r\nfound = 0;\r\nlist_for_each_entry(d, &dmac_list, node) {\r\nif (d != dmac && iface_of_dmac(d, ch->id)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic unsigned suitablility(struct s3c_pl330_dmac *dmac,\r\nstruct s3c_pl330_chan *ch)\r\n{\r\nstruct pl330_info *pi = dmac->pi;\r\nenum dma_ch *id = dmac->peri;\r\nstruct s3c_pl330_dmac *d;\r\nunsigned s;\r\nint i;\r\ns = MIN_SUIT;\r\nif (dmac_busy(dmac))\r\nreturn s;\r\nfor (i = 0; i < PL330_MAX_PERI; i++)\r\nif (id[i] == ch->id)\r\nbreak;\r\nif (i == PL330_MAX_PERI)\r\nreturn s;\r\ns = MAX_SUIT;\r\nlist_for_each_entry(d, &dmac_list, node) {\r\nif (d != dmac && iface_of_dmac(d, ch->id) && !dmac_busy(d)) {\r\ns = 0;\r\nbreak;\r\n}\r\n}\r\nif (s)\r\nreturn s;\r\ns = 100;\r\ns += (pi->pcfg.num_chan - dmac->busy_chan) - ch_onlyby_dmac(dmac);\r\nreturn s;\r\n}\r\nstatic struct s3c_pl330_dmac *map_chan_to_dmac(struct s3c_pl330_chan *ch)\r\n{\r\nstruct s3c_pl330_dmac *d, *dmac = NULL;\r\nunsigned sn, sl = MIN_SUIT;\r\nlist_for_each_entry(d, &dmac_list, node) {\r\nsn = suitablility(d, ch);\r\nif (sn == MAX_SUIT)\r\nreturn d;\r\nif (sn > sl)\r\ndmac = d;\r\n}\r\nreturn dmac;\r\n}\r\nstatic struct s3c_pl330_chan *chan_acquire(const enum dma_ch id)\r\n{\r\nstruct s3c_pl330_chan *ch = id_to_chan(id);\r\nstruct s3c_pl330_dmac *dmac;\r\nif (!ch || !chan_free(ch)) {\r\nch = NULL;\r\ngoto acq_exit;\r\n}\r\ndmac = map_chan_to_dmac(ch);\r\nif (!dmac) {\r\nch = NULL;\r\ngoto acq_exit;\r\n}\r\ndmac->busy_chan++;\r\nch->dmac = dmac;\r\nacq_exit:\r\nreturn ch;\r\n}\r\nstatic inline void del_from_queue(struct s3c_pl330_xfer *xfer)\r\n{\r\nstruct s3c_pl330_xfer *t;\r\nstruct s3c_pl330_chan *ch;\r\nint found;\r\nif (!xfer)\r\nreturn;\r\nch = xfer->chan;\r\nfound = 0;\r\nlist_for_each_entry(t, &ch->xfer_list, node)\r\nif (t == xfer) {\r\nfound = 1;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn;\r\nif (xfer->node.next == &ch->xfer_list)\r\nt = list_entry(ch->xfer_list.next,\r\nstruct s3c_pl330_xfer, node);\r\nelse\r\nt = list_entry(xfer->node.next,\r\nstruct s3c_pl330_xfer, node);\r\nif (t == xfer)\r\nch->xfer_head = NULL;\r\nelse if (ch->xfer_head == xfer)\r\nch->xfer_head = t;\r\nlist_del(&xfer->node);\r\n}\r\nstatic struct s3c_pl330_xfer *get_from_queue(struct s3c_pl330_chan *ch,\r\nint pluck)\r\n{\r\nstruct s3c_pl330_xfer *xfer = ch->xfer_head;\r\nif (!xfer)\r\nreturn NULL;\r\nif (xfer->node.next == &ch->xfer_list)\r\nch->xfer_head = list_entry(ch->xfer_list.next,\r\nstruct s3c_pl330_xfer, node);\r\nelse\r\nch->xfer_head = list_entry(xfer->node.next,\r\nstruct s3c_pl330_xfer, node);\r\nif (pluck || !(ch->options & S3C2410_DMAF_CIRCULAR))\r\ndel_from_queue(xfer);\r\nreturn xfer;\r\n}\r\nstatic inline void add_to_queue(struct s3c_pl330_chan *ch,\r\nstruct s3c_pl330_xfer *xfer, int front)\r\n{\r\nstruct pl330_xfer *xt;\r\nif (ch->xfer_head == NULL)\r\nch->xfer_head = xfer;\r\nxt = &ch->xfer_head->px;\r\nif (ch->options & S3C2410_DMAF_CIRCULAR &&\r\n(xt == ch->req[0].x || xt == ch->req[1].x))\r\nch->xfer_head = xfer;\r\nif (front) {\r\nch->xfer_head = xfer;\r\nlist_add(&xfer->node, &ch->xfer_list);\r\n} else {\r\nlist_add_tail(&xfer->node, &ch->xfer_list);\r\n}\r\n}\r\nstatic inline void _finish_off(struct s3c_pl330_xfer *xfer,\r\nenum s3c2410_dma_buffresult res, int ffree)\r\n{\r\nstruct s3c_pl330_chan *ch;\r\nif (!xfer)\r\nreturn;\r\nch = xfer->chan;\r\nif (ch->callback_fn)\r\nch->callback_fn(NULL, xfer->token, xfer->px.bytes, res);\r\nif (ffree || !(ch->options & S3C2410_DMAF_CIRCULAR))\r\nkmem_cache_free(ch->dmac->kmcache, xfer);\r\n}\r\nstatic inline int s3c_pl330_submit(struct s3c_pl330_chan *ch,\r\nstruct pl330_req *r)\r\n{\r\nstruct s3c_pl330_xfer *xfer;\r\nint ret = 0;\r\nif (r->x)\r\nreturn 0;\r\nxfer = get_from_queue(ch, 0);\r\nif (xfer) {\r\nr->x = &xfer->px;\r\nif (r->rqtype == MEMTOMEM) {\r\nstruct pl330_info *pi = xfer->chan->dmac->pi;\r\nint burst = 1 << ch->rqcfg.brst_size;\r\nu32 bytes = r->x->bytes;\r\nint bl;\r\nbl = pi->pcfg.data_bus_width / 8;\r\nbl *= pi->pcfg.data_buf_dep;\r\nbl /= burst;\r\nif (bl > 16)\r\nbl = 16;\r\nwhile (bl > 1) {\r\nif (!(bytes % (bl * burst)))\r\nbreak;\r\nbl--;\r\n}\r\nch->rqcfg.brst_len = bl;\r\n} else {\r\nch->rqcfg.brst_len = 1;\r\n}\r\nret = pl330_submit_req(ch->pl330_chan_id, r);\r\nif (!ret) {\r\nch->lrq = r;\r\nreturn 0;\r\n}\r\nr->x = NULL;\r\nif (ret == -EAGAIN) {\r\ndev_err(ch->dmac->pi->dev, "%s:%d!\n",\r\n__func__, __LINE__);\r\nadd_to_queue(ch, xfer, 1);\r\nret = 0;\r\n} else {\r\ndev_err(ch->dmac->pi->dev, "%s:%d!\n",\r\n__func__, __LINE__);\r\n_finish_off(xfer, S3C2410_RES_ERR, 0);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void s3c_pl330_rq(struct s3c_pl330_chan *ch,\r\nstruct pl330_req *r, enum pl330_op_err err)\r\n{\r\nunsigned long flags;\r\nstruct s3c_pl330_xfer *xfer;\r\nstruct pl330_xfer *xl = r->x;\r\nenum s3c2410_dma_buffresult res;\r\nspin_lock_irqsave(&res_lock, flags);\r\nr->x = NULL;\r\ns3c_pl330_submit(ch, r);\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nif (err == PL330_ERR_NONE)\r\nres = S3C2410_RES_OK;\r\nelse if (err == PL330_ERR_ABORT)\r\nres = S3C2410_RES_ABORT;\r\nelse\r\nres = S3C2410_RES_ERR;\r\nif (xl) {\r\nxfer = container_of(xl, struct s3c_pl330_xfer, px);\r\n_finish_off(xfer, res, 0);\r\n} else {\r\ndev_info(ch->dmac->pi->dev, "%s:%d No Xfer?!\n",\r\n__func__, __LINE__);\r\n}\r\n}\r\nstatic void s3c_pl330_rq0(void *token, enum pl330_op_err err)\r\n{\r\nstruct pl330_req *r = token;\r\nstruct s3c_pl330_chan *ch = container_of(r,\r\nstruct s3c_pl330_chan, req[0]);\r\ns3c_pl330_rq(ch, r, err);\r\n}\r\nstatic void s3c_pl330_rq1(void *token, enum pl330_op_err err)\r\n{\r\nstruct pl330_req *r = token;\r\nstruct s3c_pl330_chan *ch = container_of(r,\r\nstruct s3c_pl330_chan, req[1]);\r\ns3c_pl330_rq(ch, r, err);\r\n}\r\nstatic void chan_release(struct s3c_pl330_chan *ch)\r\n{\r\nstruct s3c_pl330_dmac *dmac;\r\nif (chan_free(ch))\r\nreturn;\r\ndmac = ch->dmac;\r\nch->dmac = NULL;\r\ndmac->busy_chan--;\r\n}\r\nint s3c2410_dma_ctrl(enum dma_ch id, enum s3c2410_chan_op op)\r\n{\r\nstruct s3c_pl330_xfer *xfer;\r\nenum pl330_chan_op pl330op;\r\nstruct s3c_pl330_chan *ch;\r\nunsigned long flags;\r\nint idx, ret;\r\nspin_lock_irqsave(&res_lock, flags);\r\nch = id_to_chan(id);\r\nif (!ch || chan_free(ch)) {\r\nret = -EINVAL;\r\ngoto ctrl_exit;\r\n}\r\nswitch (op) {\r\ncase S3C2410_DMAOP_START:\r\nidx = (ch->lrq == &ch->req[0]) ? 1 : 0;\r\ns3c_pl330_submit(ch, &ch->req[idx]);\r\ns3c_pl330_submit(ch, &ch->req[1 - idx]);\r\npl330op = PL330_OP_START;\r\nbreak;\r\ncase S3C2410_DMAOP_STOP:\r\npl330op = PL330_OP_ABORT;\r\nbreak;\r\ncase S3C2410_DMAOP_FLUSH:\r\npl330op = PL330_OP_FLUSH;\r\nbreak;\r\ncase S3C2410_DMAOP_PAUSE:\r\ncase S3C2410_DMAOP_RESUME:\r\ncase S3C2410_DMAOP_TIMEOUT:\r\ncase S3C2410_DMAOP_STARTED:\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn 0;\r\ndefault:\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nret = pl330_chan_ctrl(ch->pl330_chan_id, pl330op);\r\nif (pl330op == PL330_OP_START) {\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn ret;\r\n}\r\nidx = (ch->lrq == &ch->req[0]) ? 1 : 0;\r\nif (ch->req[idx].x) {\r\nxfer = container_of(ch->req[idx].x,\r\nstruct s3c_pl330_xfer, px);\r\nif (pl330op == PL330_OP_FLUSH)\r\ndel_from_queue(xfer);\r\nch->req[idx].x = NULL;\r\nspin_unlock_irqrestore(&res_lock, flags);\r\n_finish_off(xfer, S3C2410_RES_ABORT,\r\npl330op == PL330_OP_FLUSH ? 1 : 0);\r\nspin_lock_irqsave(&res_lock, flags);\r\n}\r\nif (pl330op == PL330_OP_FLUSH) {\r\nif (ch->req[1 - idx].x) {\r\nxfer = container_of(ch->req[1 - idx].x,\r\nstruct s3c_pl330_xfer, px);\r\ndel_from_queue(xfer);\r\nch->req[1 - idx].x = NULL;\r\nspin_unlock_irqrestore(&res_lock, flags);\r\n_finish_off(xfer, S3C2410_RES_ABORT, 1);\r\nspin_lock_irqsave(&res_lock, flags);\r\n}\r\nxfer = ch->xfer_head;\r\nwhile (xfer) {\r\ndel_from_queue(xfer);\r\nspin_unlock_irqrestore(&res_lock, flags);\r\n_finish_off(xfer, S3C2410_RES_ABORT, 1);\r\nspin_lock_irqsave(&res_lock, flags);\r\nxfer = ch->xfer_head;\r\n}\r\n}\r\nctrl_exit:\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn ret;\r\n}\r\nint s3c2410_dma_enqueue(enum dma_ch id, void *token,\r\ndma_addr_t addr, int size)\r\n{\r\nstruct s3c_pl330_chan *ch;\r\nstruct s3c_pl330_xfer *xfer;\r\nunsigned long flags;\r\nint idx, ret = 0;\r\nspin_lock_irqsave(&res_lock, flags);\r\nch = id_to_chan(id);\r\nif (!ch || chan_free(ch)) {\r\nret = -EINVAL;\r\ngoto enq_exit;\r\n}\r\nif (ch->rqcfg.brst_size && size % (1 << ch->rqcfg.brst_size)) {\r\nret = -EINVAL;\r\ngoto enq_exit;\r\n}\r\nxfer = kmem_cache_alloc(ch->dmac->kmcache, GFP_ATOMIC);\r\nif (!xfer) {\r\nret = -ENOMEM;\r\ngoto enq_exit;\r\n}\r\nxfer->token = token;\r\nxfer->chan = ch;\r\nxfer->px.bytes = size;\r\nxfer->px.next = NULL;\r\nif (ch->req[0].rqtype == MEMTODEV) {\r\nxfer->px.src_addr = addr;\r\nxfer->px.dst_addr = ch->sdaddr;\r\n} else {\r\nxfer->px.src_addr = ch->sdaddr;\r\nxfer->px.dst_addr = addr;\r\n}\r\nadd_to_queue(ch, xfer, 0);\r\nidx = (ch->lrq == &ch->req[0]) ? 1 : 0;\r\nif (!ch->req[idx].x)\r\ns3c_pl330_submit(ch, &ch->req[idx]);\r\nelse\r\ns3c_pl330_submit(ch, &ch->req[1 - idx]);\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nif (ch->options & S3C2410_DMAF_AUTOSTART)\r\ns3c2410_dma_ctrl(id, S3C2410_DMAOP_START);\r\nreturn 0;\r\nenq_exit:\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn ret;\r\n}\r\nint s3c2410_dma_request(enum dma_ch id,\r\nstruct s3c2410_dma_client *client,\r\nvoid *dev)\r\n{\r\nstruct s3c_pl330_dmac *dmac;\r\nstruct s3c_pl330_chan *ch;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&res_lock, flags);\r\nch = chan_acquire(id);\r\nif (!ch) {\r\nret = -EBUSY;\r\ngoto req_exit;\r\n}\r\ndmac = ch->dmac;\r\nch->pl330_chan_id = pl330_request_channel(dmac->pi);\r\nif (!ch->pl330_chan_id) {\r\nchan_release(ch);\r\nret = -EBUSY;\r\ngoto req_exit;\r\n}\r\nch->client = client;\r\nch->options = 0;\r\nch->callback_fn = NULL;\r\nch->lrq = NULL;\r\nch->rqcfg.brst_size = 2;\r\nch->rqcfg.swap = SWAP_NO;\r\nch->rqcfg.scctl = SCCTRL0;\r\nch->rqcfg.dcctl = DCCTRL0;\r\nch->rqcfg.privileged = 0;\r\nch->rqcfg.insnaccess = 0;\r\nch->req[0].rqtype = DEVTODEV;\r\nch->req[1].rqtype = ch->req[0].rqtype;\r\nch->req[0].cfg = &ch->rqcfg;\r\nch->req[1].cfg = ch->req[0].cfg;\r\nch->req[0].peri = iface_of_dmac(dmac, id) - 1;\r\nch->req[1].peri = ch->req[0].peri;\r\nch->req[0].token = &ch->req[0];\r\nch->req[0].xfer_cb = s3c_pl330_rq0;\r\nch->req[1].token = &ch->req[1];\r\nch->req[1].xfer_cb = s3c_pl330_rq1;\r\nch->req[0].x = NULL;\r\nch->req[1].x = NULL;\r\nINIT_LIST_HEAD(&ch->xfer_list);\r\nch->xfer_head = NULL;\r\nreq_exit:\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn ret;\r\n}\r\nint s3c2410_dma_free(enum dma_ch id, struct s3c2410_dma_client *client)\r\n{\r\nstruct s3c_pl330_chan *ch;\r\nstruct s3c_pl330_xfer *xfer;\r\nunsigned long flags;\r\nint ret = 0;\r\nunsigned idx;\r\nspin_lock_irqsave(&res_lock, flags);\r\nch = id_to_chan(id);\r\nif (!ch || chan_free(ch))\r\ngoto free_exit;\r\nif (ch->client != client) {\r\nret = -EBUSY;\r\ngoto free_exit;\r\n}\r\npl330_chan_ctrl(ch->pl330_chan_id, PL330_OP_FLUSH);\r\nidx = (ch->lrq == &ch->req[0]) ? 1 : 0;\r\nif (ch->req[idx].x) {\r\nxfer = container_of(ch->req[idx].x,\r\nstruct s3c_pl330_xfer, px);\r\nch->req[idx].x = NULL;\r\ndel_from_queue(xfer);\r\nspin_unlock_irqrestore(&res_lock, flags);\r\n_finish_off(xfer, S3C2410_RES_ABORT, 1);\r\nspin_lock_irqsave(&res_lock, flags);\r\n}\r\nif (ch->req[1 - idx].x) {\r\nxfer = container_of(ch->req[1 - idx].x,\r\nstruct s3c_pl330_xfer, px);\r\nch->req[1 - idx].x = NULL;\r\ndel_from_queue(xfer);\r\nspin_unlock_irqrestore(&res_lock, flags);\r\n_finish_off(xfer, S3C2410_RES_ABORT, 1);\r\nspin_lock_irqsave(&res_lock, flags);\r\n}\r\ndo {\r\nxfer = get_from_queue(ch, 1);\r\nspin_unlock_irqrestore(&res_lock, flags);\r\n_finish_off(xfer, S3C2410_RES_ABORT, 1);\r\nspin_lock_irqsave(&res_lock, flags);\r\n} while (xfer);\r\nch->client = NULL;\r\npl330_release_channel(ch->pl330_chan_id);\r\nch->pl330_chan_id = NULL;\r\nchan_release(ch);\r\nfree_exit:\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn ret;\r\n}\r\nint s3c2410_dma_config(enum dma_ch id, int xferunit)\r\n{\r\nstruct s3c_pl330_chan *ch;\r\nstruct pl330_info *pi;\r\nunsigned long flags;\r\nint i, dbwidth, ret = 0;\r\nspin_lock_irqsave(&res_lock, flags);\r\nch = id_to_chan(id);\r\nif (!ch || chan_free(ch)) {\r\nret = -EINVAL;\r\ngoto cfg_exit;\r\n}\r\npi = ch->dmac->pi;\r\ndbwidth = pi->pcfg.data_bus_width / 8;\r\nif (xferunit > dbwidth) {\r\nret = -EINVAL;\r\ngoto cfg_exit;\r\n}\r\ni = 0;\r\nwhile (xferunit != (1 << i))\r\ni++;\r\nif (xferunit == (1 << i))\r\nch->rqcfg.brst_size = i;\r\nelse\r\nret = -EINVAL;\r\ncfg_exit:\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn ret;\r\n}\r\nint s3c2410_dma_setflags(enum dma_ch id, unsigned int options)\r\n{\r\nstruct s3c_pl330_chan *ch;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&res_lock, flags);\r\nch = id_to_chan(id);\r\nif (!ch || chan_free(ch) || options & ~(S3C_PL330_FLAGS))\r\nret = -EINVAL;\r\nelse\r\nch->options = options;\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn 0;\r\n}\r\nint s3c2410_dma_set_buffdone_fn(enum dma_ch id, s3c2410_dma_cbfn_t rtn)\r\n{\r\nstruct s3c_pl330_chan *ch;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&res_lock, flags);\r\nch = id_to_chan(id);\r\nif (!ch || chan_free(ch))\r\nret = -EINVAL;\r\nelse\r\nch->callback_fn = rtn;\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn ret;\r\n}\r\nint s3c2410_dma_devconfig(enum dma_ch id, enum s3c2410_dmasrc source,\r\nunsigned long address)\r\n{\r\nstruct s3c_pl330_chan *ch;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&res_lock, flags);\r\nch = id_to_chan(id);\r\nif (!ch || chan_free(ch)) {\r\nret = -EINVAL;\r\ngoto devcfg_exit;\r\n}\r\nswitch (source) {\r\ncase S3C2410_DMASRC_HW:\r\nch->req[0].rqtype = DEVTOMEM;\r\nch->req[1].rqtype = DEVTOMEM;\r\nch->rqcfg.src_inc = 0;\r\nch->rqcfg.dst_inc = 1;\r\nbreak;\r\ncase S3C2410_DMASRC_MEM:\r\nch->req[0].rqtype = MEMTODEV;\r\nch->req[1].rqtype = MEMTODEV;\r\nch->rqcfg.src_inc = 1;\r\nch->rqcfg.dst_inc = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto devcfg_exit;\r\n}\r\nch->sdaddr = address;\r\ndevcfg_exit:\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn ret;\r\n}\r\nint s3c2410_dma_getposition(enum dma_ch id, dma_addr_t *src, dma_addr_t *dst)\r\n{\r\nstruct s3c_pl330_chan *ch = id_to_chan(id);\r\nstruct pl330_chanstatus status;\r\nint ret;\r\nif (!ch || chan_free(ch))\r\nreturn -EINVAL;\r\nret = pl330_chan_status(ch->pl330_chan_id, &status);\r\nif (ret < 0)\r\nreturn ret;\r\n*src = status.src_addr;\r\n*dst = status.dst_addr;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pl330_irq_handler(int irq, void *data)\r\n{\r\nif (pl330_update(data))\r\nreturn IRQ_HANDLED;\r\nelse\r\nreturn IRQ_NONE;\r\n}\r\nstatic int pl330_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c_pl330_dmac *s3c_pl330_dmac;\r\nstruct s3c_pl330_platdata *pl330pd;\r\nstruct pl330_info *pl330_info;\r\nstruct resource *res;\r\nint i, ret, irq;\r\npl330pd = pdev->dev.platform_data;\r\nif (!pl330pd || !pl330pd->peri) {\r\ndev_err(&pdev->dev, "platform data missing!\n");\r\nreturn -ENODEV;\r\n}\r\npl330_info = kzalloc(sizeof(*pl330_info), GFP_KERNEL);\r\nif (!pl330_info)\r\nreturn -ENOMEM;\r\npl330_info->pl330_data = NULL;\r\npl330_info->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto probe_err1;\r\n}\r\nrequest_mem_region(res->start, resource_size(res), pdev->name);\r\npl330_info->base = ioremap(res->start, resource_size(res));\r\nif (!pl330_info->base) {\r\nret = -ENXIO;\r\ngoto probe_err2;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto probe_err3;\r\n}\r\nret = request_irq(irq, pl330_irq_handler, 0,\r\ndev_name(&pdev->dev), pl330_info);\r\nif (ret)\r\ngoto probe_err4;\r\ns3c_pl330_dmac = kmalloc(sizeof(*s3c_pl330_dmac), GFP_KERNEL);\r\nif (!s3c_pl330_dmac) {\r\nret = -ENOMEM;\r\ngoto probe_err5;\r\n}\r\ns3c_pl330_dmac->clk = clk_get(&pdev->dev, "pdma");\r\nif (IS_ERR(s3c_pl330_dmac->clk)) {\r\ndev_err(&pdev->dev, "Cannot get operation clock.\n");\r\nret = -EINVAL;\r\ngoto probe_err6;\r\n}\r\nclk_enable(s3c_pl330_dmac->clk);\r\nret = pl330_add(pl330_info);\r\nif (ret)\r\ngoto probe_err7;\r\ns3c_pl330_dmac->pi = pl330_info;\r\ns3c_pl330_dmac->busy_chan = 0;\r\ns3c_pl330_dmac->kmcache = kmem_cache_create(dev_name(&pdev->dev),\r\nsizeof(struct s3c_pl330_xfer), 0, 0, NULL);\r\nif (!s3c_pl330_dmac->kmcache) {\r\nret = -ENOMEM;\r\ngoto probe_err8;\r\n}\r\ns3c_pl330_dmac->peri = pl330pd->peri;\r\nlist_add_tail(&s3c_pl330_dmac->node, &dmac_list);\r\nfor (i = 0; i < PL330_MAX_PERI; i++)\r\nif (s3c_pl330_dmac->peri[i] != DMACH_MAX)\r\nchan_add(s3c_pl330_dmac->peri[i]);\r\nprintk(KERN_INFO\r\n"Loaded driver for PL330 DMAC-%d %s\n", pdev->id, pdev->name);\r\nprintk(KERN_INFO\r\n"\tDBUFF-%ux%ubytes Num_Chans-%u Num_Peri-%u Num_Events-%u\n",\r\npl330_info->pcfg.data_buf_dep,\r\npl330_info->pcfg.data_bus_width / 8, pl330_info->pcfg.num_chan,\r\npl330_info->pcfg.num_peri, pl330_info->pcfg.num_events);\r\nreturn 0;\r\nprobe_err8:\r\npl330_del(pl330_info);\r\nprobe_err7:\r\nclk_disable(s3c_pl330_dmac->clk);\r\nclk_put(s3c_pl330_dmac->clk);\r\nprobe_err6:\r\nkfree(s3c_pl330_dmac);\r\nprobe_err5:\r\nfree_irq(irq, pl330_info);\r\nprobe_err4:\r\nprobe_err3:\r\niounmap(pl330_info->base);\r\nprobe_err2:\r\nrelease_mem_region(res->start, resource_size(res));\r\nprobe_err1:\r\nkfree(pl330_info);\r\nreturn ret;\r\n}\r\nstatic int pl330_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c_pl330_dmac *dmac, *d;\r\nstruct s3c_pl330_chan *ch;\r\nunsigned long flags;\r\nint del, found;\r\nif (!pdev->dev.platform_data)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&res_lock, flags);\r\nfound = 0;\r\nlist_for_each_entry(d, &dmac_list, node)\r\nif (d->pi->dev == &pdev->dev) {\r\nfound = 1;\r\nbreak;\r\n}\r\nif (!found) {\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn 0;\r\n}\r\ndmac = d;\r\nlist_for_each_entry(ch, &chan_list, node) {\r\nif (iface_of_dmac(dmac, ch->id))\r\ndel = 1;\r\nelse\r\ncontinue;\r\nlist_for_each_entry(d, &dmac_list, node)\r\nif (d != dmac && iface_of_dmac(d, ch->id)) {\r\ndel = 0;\r\nbreak;\r\n}\r\nif (del) {\r\nspin_unlock_irqrestore(&res_lock, flags);\r\ns3c2410_dma_free(ch->id, ch->client);\r\nspin_lock_irqsave(&res_lock, flags);\r\nlist_del(&ch->node);\r\nkfree(ch);\r\n}\r\n}\r\nclk_disable(dmac->clk);\r\nclk_put(dmac->clk);\r\nlist_del(&dmac->node);\r\nkfree(dmac);\r\nspin_unlock_irqrestore(&res_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init pl330_init(void)\r\n{\r\nreturn platform_driver_register(&pl330_driver);\r\n}\r\nstatic void __exit pl330_exit(void)\r\n{\r\nplatform_driver_unregister(&pl330_driver);\r\nreturn;\r\n}
