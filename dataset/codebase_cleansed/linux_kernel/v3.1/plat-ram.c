static inline struct platram_info *to_platram_info(struct platform_device *dev)\r\n{\r\nreturn (struct platram_info *)platform_get_drvdata(dev);\r\n}\r\nstatic inline void platram_setrw(struct platram_info *info, int to)\r\n{\r\nif (info->pdata == NULL)\r\nreturn;\r\nif (info->pdata->set_rw != NULL)\r\n(info->pdata->set_rw)(info->dev, to);\r\n}\r\nstatic int platram_remove(struct platform_device *pdev)\r\n{\r\nstruct platram_info *info = to_platram_info(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\ndev_dbg(&pdev->dev, "removing device\n");\r\nif (info == NULL)\r\nreturn 0;\r\nif (info->mtd) {\r\nmtd_device_unregister(info->mtd);\r\nif (info->partitions) {\r\nif (info->free_partitions)\r\nkfree(info->partitions);\r\n}\r\nmap_destroy(info->mtd);\r\n}\r\nplatram_setrw(info, PLATRAM_RO);\r\nif (info->area) {\r\nrelease_resource(info->area);\r\nkfree(info->area);\r\n}\r\nif (info->map.virt != NULL)\r\niounmap(info->map.virt);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int platram_probe(struct platform_device *pdev)\r\n{\r\nstruct platdata_mtd_ram *pdata;\r\nstruct platram_info *info;\r\nstruct resource *res;\r\nint err = 0;\r\ndev_dbg(&pdev->dev, "probe entered\n");\r\nif (pdev->dev.platform_data == NULL) {\r\ndev_err(&pdev->dev, "no platform data supplied\n");\r\nerr = -ENOENT;\r\ngoto exit_error;\r\n}\r\npdata = pdev->dev.platform_data;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL) {\r\ndev_err(&pdev->dev, "no memory for flash info\n");\r\nerr = -ENOMEM;\r\ngoto exit_error;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\ninfo->dev = &pdev->dev;\r\ninfo->pdata = pdata;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no memory resource specified\n");\r\nerr = -ENOENT;\r\ngoto exit_free;\r\n}\r\ndev_dbg(&pdev->dev, "got platform resource %p (0x%llx)\n", res,\r\n(unsigned long long)res->start);\r\ninfo->map.phys = res->start;\r\ninfo->map.size = resource_size(res);\r\ninfo->map.name = pdata->mapname != NULL ?\r\n(char *)pdata->mapname : (char *)pdev->name;\r\ninfo->map.bankwidth = pdata->bankwidth;\r\ninfo->area = request_mem_region(res->start, info->map.size, pdev->name);\r\nif (info->area == NULL) {\r\ndev_err(&pdev->dev, "failed to request memory region\n");\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\ninfo->map.virt = ioremap(res->start, info->map.size);\r\ndev_dbg(&pdev->dev, "virt %p, %lu bytes\n", info->map.virt, info->map.size);\r\nif (info->map.virt == NULL) {\r\ndev_err(&pdev->dev, "failed to ioremap() region\n");\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\nsimple_map_init(&info->map);\r\ndev_dbg(&pdev->dev, "initialised map, probing for mtd\n");\r\nif (pdata->map_probes) {\r\nconst char **map_probes = pdata->map_probes;\r\nfor ( ; !info->mtd && *map_probes; map_probes++)\r\ninfo->mtd = do_map_probe(*map_probes , &info->map);\r\n}\r\nelse\r\ninfo->mtd = do_map_probe("map_ram", &info->map);\r\nif (info->mtd == NULL) {\r\ndev_err(&pdev->dev, "failed to probe for map_ram\n");\r\nerr = -ENOMEM;\r\ngoto exit_free;\r\n}\r\ninfo->mtd->owner = THIS_MODULE;\r\ninfo->mtd->dev.parent = &pdev->dev;\r\nplatram_setrw(info, PLATRAM_RW);\r\nif (!pdata->nr_partitions) {\r\nif (pdata->probes) {\r\nerr = parse_mtd_partitions(info->mtd, pdata->probes,\r\n&info->partitions, 0);\r\ninfo->free_partitions = 1;\r\nif (err > 0)\r\nerr = mtd_device_register(info->mtd,\r\ninfo->partitions, err);\r\n}\r\n}\r\nelse\r\nerr = mtd_device_register(info->mtd, pdata->partitions,\r\npdata->nr_partitions);\r\nif (!err)\r\ndev_info(&pdev->dev, "registered mtd device\n");\r\nerr = mtd_device_register(info->mtd, NULL, 0);\r\nif (err)\r\ndev_err(&pdev->dev, "failed to register the entire device\n");\r\nreturn err;\r\nexit_free:\r\nplatram_remove(pdev);\r\nexit_error:\r\nreturn err;\r\n}\r\nstatic int __init platram_init(void)\r\n{\r\nprintk("Generic platform RAM MTD, (c) 2004 Simtec Electronics\n");\r\nreturn platform_driver_register(&platram_driver);\r\n}\r\nstatic void __exit platram_exit(void)\r\n{\r\nplatform_driver_unregister(&platram_driver);\r\n}
