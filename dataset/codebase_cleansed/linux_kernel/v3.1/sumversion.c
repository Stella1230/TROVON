static inline uint32_t lshift(uint32_t x, unsigned int s)\r\n{\r\nx &= 0xFFFFFFFF;\r\nreturn ((x << s) & 0xFFFFFFFF) | (x >> (32 - s));\r\n}\r\nstatic inline uint32_t F(uint32_t x, uint32_t y, uint32_t z)\r\n{\r\nreturn (x & y) | ((~x) & z);\r\n}\r\nstatic inline uint32_t G(uint32_t x, uint32_t y, uint32_t z)\r\n{\r\nreturn (x & y) | (x & z) | (y & z);\r\n}\r\nstatic inline uint32_t H(uint32_t x, uint32_t y, uint32_t z)\r\n{\r\nreturn x ^ y ^ z;\r\n}\r\nstatic inline void le32_to_cpu_array(uint32_t *buf, unsigned int words)\r\n{\r\nwhile (words--) {\r\n*buf = ntohl(*buf);\r\nbuf++;\r\n}\r\n}\r\nstatic inline void cpu_to_le32_array(uint32_t *buf, unsigned int words)\r\n{\r\nwhile (words--) {\r\n*buf = htonl(*buf);\r\nbuf++;\r\n}\r\n}\r\nstatic void md4_transform(uint32_t *hash, uint32_t const *in)\r\n{\r\nuint32_t a, b, c, d;\r\na = hash[0];\r\nb = hash[1];\r\nc = hash[2];\r\nd = hash[3];\r\nROUND1(a, b, c, d, in[0], 3);\r\nROUND1(d, a, b, c, in[1], 7);\r\nROUND1(c, d, a, b, in[2], 11);\r\nROUND1(b, c, d, a, in[3], 19);\r\nROUND1(a, b, c, d, in[4], 3);\r\nROUND1(d, a, b, c, in[5], 7);\r\nROUND1(c, d, a, b, in[6], 11);\r\nROUND1(b, c, d, a, in[7], 19);\r\nROUND1(a, b, c, d, in[8], 3);\r\nROUND1(d, a, b, c, in[9], 7);\r\nROUND1(c, d, a, b, in[10], 11);\r\nROUND1(b, c, d, a, in[11], 19);\r\nROUND1(a, b, c, d, in[12], 3);\r\nROUND1(d, a, b, c, in[13], 7);\r\nROUND1(c, d, a, b, in[14], 11);\r\nROUND1(b, c, d, a, in[15], 19);\r\nROUND2(a, b, c, d,in[ 0], 3);\r\nROUND2(d, a, b, c, in[4], 5);\r\nROUND2(c, d, a, b, in[8], 9);\r\nROUND2(b, c, d, a, in[12], 13);\r\nROUND2(a, b, c, d, in[1], 3);\r\nROUND2(d, a, b, c, in[5], 5);\r\nROUND2(c, d, a, b, in[9], 9);\r\nROUND2(b, c, d, a, in[13], 13);\r\nROUND2(a, b, c, d, in[2], 3);\r\nROUND2(d, a, b, c, in[6], 5);\r\nROUND2(c, d, a, b, in[10], 9);\r\nROUND2(b, c, d, a, in[14], 13);\r\nROUND2(a, b, c, d, in[3], 3);\r\nROUND2(d, a, b, c, in[7], 5);\r\nROUND2(c, d, a, b, in[11], 9);\r\nROUND2(b, c, d, a, in[15], 13);\r\nROUND3(a, b, c, d,in[ 0], 3);\r\nROUND3(d, a, b, c, in[8], 9);\r\nROUND3(c, d, a, b, in[4], 11);\r\nROUND3(b, c, d, a, in[12], 15);\r\nROUND3(a, b, c, d, in[2], 3);\r\nROUND3(d, a, b, c, in[10], 9);\r\nROUND3(c, d, a, b, in[6], 11);\r\nROUND3(b, c, d, a, in[14], 15);\r\nROUND3(a, b, c, d, in[1], 3);\r\nROUND3(d, a, b, c, in[9], 9);\r\nROUND3(c, d, a, b, in[5], 11);\r\nROUND3(b, c, d, a, in[13], 15);\r\nROUND3(a, b, c, d, in[3], 3);\r\nROUND3(d, a, b, c, in[11], 9);\r\nROUND3(c, d, a, b, in[7], 11);\r\nROUND3(b, c, d, a, in[15], 15);\r\nhash[0] += a;\r\nhash[1] += b;\r\nhash[2] += c;\r\nhash[3] += d;\r\n}\r\nstatic inline void md4_transform_helper(struct md4_ctx *ctx)\r\n{\r\nle32_to_cpu_array(ctx->block, sizeof(ctx->block) / sizeof(uint32_t));\r\nmd4_transform(ctx->hash, ctx->block);\r\n}\r\nstatic void md4_init(struct md4_ctx *mctx)\r\n{\r\nmctx->hash[0] = 0x67452301;\r\nmctx->hash[1] = 0xefcdab89;\r\nmctx->hash[2] = 0x98badcfe;\r\nmctx->hash[3] = 0x10325476;\r\nmctx->byte_count = 0;\r\n}\r\nstatic void md4_update(struct md4_ctx *mctx,\r\nconst unsigned char *data, unsigned int len)\r\n{\r\nconst uint32_t avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);\r\nmctx->byte_count += len;\r\nif (avail > len) {\r\nmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\r\ndata, len);\r\nreturn;\r\n}\r\nmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\r\ndata, avail);\r\nmd4_transform_helper(mctx);\r\ndata += avail;\r\nlen -= avail;\r\nwhile (len >= sizeof(mctx->block)) {\r\nmemcpy(mctx->block, data, sizeof(mctx->block));\r\nmd4_transform_helper(mctx);\r\ndata += sizeof(mctx->block);\r\nlen -= sizeof(mctx->block);\r\n}\r\nmemcpy(mctx->block, data, len);\r\n}\r\nstatic void md4_final_ascii(struct md4_ctx *mctx, char *out, unsigned int len)\r\n{\r\nconst unsigned int offset = mctx->byte_count & 0x3f;\r\nchar *p = (char *)mctx->block + offset;\r\nint padding = 56 - (offset + 1);\r\n*p++ = 0x80;\r\nif (padding < 0) {\r\nmemset(p, 0x00, padding + sizeof (uint64_t));\r\nmd4_transform_helper(mctx);\r\np = (char *)mctx->block;\r\npadding = 56;\r\n}\r\nmemset(p, 0, padding);\r\nmctx->block[14] = mctx->byte_count << 3;\r\nmctx->block[15] = mctx->byte_count >> 29;\r\nle32_to_cpu_array(mctx->block, (sizeof(mctx->block) -\r\nsizeof(uint64_t)) / sizeof(uint32_t));\r\nmd4_transform(mctx->hash, mctx->block);\r\ncpu_to_le32_array(mctx->hash, sizeof(mctx->hash) / sizeof(uint32_t));\r\nsnprintf(out, len, "%08X%08X%08X%08X",\r\nmctx->hash[0], mctx->hash[1], mctx->hash[2], mctx->hash[3]);\r\n}\r\nstatic inline void add_char(unsigned char c, struct md4_ctx *md)\r\n{\r\nmd4_update(md, &c, 1);\r\n}\r\nstatic int parse_string(const char *file, unsigned long len,\r\nstruct md4_ctx *md)\r\n{\r\nunsigned long i;\r\nadd_char(file[0], md);\r\nfor (i = 1; i < len; i++) {\r\nadd_char(file[i], md);\r\nif (file[i] == '"' && file[i-1] != '\\')\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic int parse_comment(const char *file, unsigned long len)\r\n{\r\nunsigned long i;\r\nfor (i = 2; i < len; i++) {\r\nif (file[i-1] == '*' && file[i] == '/')\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic int parse_file(const char *fname, struct md4_ctx *md)\r\n{\r\nchar *file;\r\nunsigned long i, len;\r\nfile = grab_file(fname, &len);\r\nif (!file)\r\nreturn 0;\r\nfor (i = 0; i < len; i++) {\r\nif (file[i] == '\\' && (i+1 < len) && file[i+1] == '\n') {\r\ni++;\r\ncontinue;\r\n}\r\nif (isspace(file[i]))\r\ncontinue;\r\nif (file[i] == '"') {\r\ni += parse_string(file+i, len - i, md);\r\ncontinue;\r\n}\r\nif (file[i] == '/' && file[i+1] == '*') {\r\ni += parse_comment(file+i, len - i);\r\ncontinue;\r\n}\r\nadd_char(file[i], md);\r\n}\r\nrelease_file(file, len);\r\nreturn 1;\r\n}\r\nstatic int is_static_library(const char *objfile)\r\n{\r\nint len = strlen(objfile);\r\nif (objfile[len - 2] == '.' && objfile[len - 1] == 'a')\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int parse_source_files(const char *objfile, struct md4_ctx *md)\r\n{\r\nchar *cmd, *file, *line, *dir;\r\nconst char *base;\r\nunsigned long flen, pos = 0;\r\nint dirlen, ret = 0, check_files = 0;\r\ncmd = NOFAIL(malloc(strlen(objfile) + sizeof("..cmd")));\r\nbase = strrchr(objfile, '/');\r\nif (base) {\r\nbase++;\r\ndirlen = base - objfile;\r\nsprintf(cmd, "%.*s.%s.cmd", dirlen, objfile, base);\r\n} else {\r\ndirlen = 0;\r\nsprintf(cmd, ".%s.cmd", objfile);\r\n}\r\ndir = NOFAIL(malloc(dirlen + 1));\r\nstrncpy(dir, objfile, dirlen);\r\ndir[dirlen] = '\0';\r\nfile = grab_file(cmd, &flen);\r\nif (!file) {\r\nwarn("could not find %s for %s\n", cmd, objfile);\r\ngoto out;\r\n}\r\nwhile ((line = get_next_line(&pos, file, flen)) != NULL) {\r\nchar* p = line;\r\nif (strncmp(line, "source_", sizeof("source_")-1) == 0) {\r\np = strrchr(line, ' ');\r\nif (!p) {\r\nwarn("malformed line: %s\n", line);\r\ngoto out_file;\r\n}\r\np++;\r\nif (!parse_file(p, md)) {\r\nwarn("could not open %s: %s\n",\r\np, strerror(errno));\r\ngoto out_file;\r\n}\r\ncontinue;\r\n}\r\nif (strncmp(line, "deps_", sizeof("deps_")-1) == 0) {\r\ncheck_files = 1;\r\ncontinue;\r\n}\r\nif (!check_files)\r\ncontinue;\r\nif ( *(p + strlen(p)-1) != '\\')\r\nbreak;\r\nwhile (*p) {\r\nif (isspace(*p)) {\r\n*p = '\0';\r\nbreak;\r\n}\r\np++;\r\n}\r\nif ((strstr(line, dir)+strlen(dir)-1) == strrchr(line, '/')) {\r\nif (!parse_file(line, md)) {\r\nwarn("could not open %s: %s\n",\r\nline, strerror(errno));\r\ngoto out_file;\r\n}\r\n}\r\n}\r\nret = 1;\r\nout_file:\r\nrelease_file(file, flen);\r\nout:\r\nfree(dir);\r\nfree(cmd);\r\nreturn ret;\r\n}\r\nvoid get_src_version(const char *modname, char sum[], unsigned sumlen)\r\n{\r\nvoid *file;\r\nunsigned long len;\r\nstruct md4_ctx md;\r\nchar *sources, *end, *fname;\r\nconst char *basename;\r\nchar filelist[PATH_MAX + 1];\r\nchar *modverdir = getenv("MODVERDIR");\r\nif (!modverdir)\r\nmodverdir = ".";\r\nif (strrchr(modname, '/'))\r\nbasename = strrchr(modname, '/') + 1;\r\nelse\r\nbasename = modname;\r\nsprintf(filelist, "%s/%.*s.mod", modverdir,\r\n(int) strlen(basename) - 2, basename);\r\nfile = grab_file(filelist, &len);\r\nif (!file)\r\nreturn;\r\nsources = strchr(file, '\n');\r\nif (!sources) {\r\nwarn("malformed versions file for %s\n", modname);\r\ngoto release;\r\n}\r\nsources++;\r\nend = strchr(sources, '\n');\r\nif (!end) {\r\nwarn("bad ending versions file for %s\n", modname);\r\ngoto release;\r\n}\r\n*end = '\0';\r\nmd4_init(&md);\r\nwhile ((fname = strsep(&sources, " ")) != NULL) {\r\nif (!*fname)\r\ncontinue;\r\nif (!(is_static_library(fname)) &&\r\n!parse_source_files(fname, &md))\r\ngoto release;\r\n}\r\nmd4_final_ascii(&md, sum, sumlen);\r\nrelease:\r\nrelease_file(file, len);\r\n}\r\nstatic void write_version(const char *filename, const char *sum,\r\nunsigned long offset)\r\n{\r\nint fd;\r\nfd = open(filename, O_RDWR);\r\nif (fd < 0) {\r\nwarn("changing sum in %s failed: %s\n",\r\nfilename, strerror(errno));\r\nreturn;\r\n}\r\nif (lseek(fd, offset, SEEK_SET) == (off_t)-1) {\r\nwarn("changing sum in %s:%lu failed: %s\n",\r\nfilename, offset, strerror(errno));\r\ngoto out;\r\n}\r\nif (write(fd, sum, strlen(sum)+1) != strlen(sum)+1) {\r\nwarn("writing sum in %s failed: %s\n",\r\nfilename, strerror(errno));\r\ngoto out;\r\n}\r\nout:\r\nclose(fd);\r\n}\r\nstatic int strip_rcs_crap(char *version)\r\n{\r\nunsigned int len, full_len;\r\nif (strncmp(version, "$Revision", strlen("$Revision")) != 0)\r\nreturn 0;\r\nfull_len = strlen(version) + strlen(version + strlen(version) + 1) + 2;\r\nlen = strlen("$Revision");\r\nif (version[len] == ':' || version[len] == '$')\r\nlen++;\r\nwhile (isspace(version[len]))\r\nlen++;\r\nmemmove(version, version+len, full_len-len);\r\nfull_len -= len;\r\nlen = 0;\r\nwhile (version[len] && !isspace(version[len]))\r\nlen++;\r\nmemmove(version + len, version + strlen(version),\r\nfull_len - strlen(version));\r\nreturn 1;\r\n}\r\nvoid maybe_frob_rcs_version(const char *modfilename,\r\nchar *version,\r\nvoid *modinfo,\r\nunsigned long version_offset)\r\n{\r\nif (strip_rcs_crap(version))\r\nwrite_version(modfilename, version, version_offset);\r\n}
