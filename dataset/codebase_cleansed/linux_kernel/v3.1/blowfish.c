static void encrypt_block(struct bf_ctx *bctx, u32 *dst, u32 *src)\r\n{\r\nconst u32 *P = bctx->p;\r\nconst u32 *S = bctx->s;\r\nu32 yl = src[0];\r\nu32 yr = src[1];\r\nROUND(yr, yl, 0);\r\nROUND(yl, yr, 1);\r\nROUND(yr, yl, 2);\r\nROUND(yl, yr, 3);\r\nROUND(yr, yl, 4);\r\nROUND(yl, yr, 5);\r\nROUND(yr, yl, 6);\r\nROUND(yl, yr, 7);\r\nROUND(yr, yl, 8);\r\nROUND(yl, yr, 9);\r\nROUND(yr, yl, 10);\r\nROUND(yl, yr, 11);\r\nROUND(yr, yl, 12);\r\nROUND(yl, yr, 13);\r\nROUND(yr, yl, 14);\r\nROUND(yl, yr, 15);\r\nyl ^= P[16];\r\nyr ^= P[17];\r\ndst[0] = yr;\r\ndst[1] = yl;\r\n}\r\nstatic void bf_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nconst __be32 *in_blk = (const __be32 *)src;\r\n__be32 *const out_blk = (__be32 *)dst;\r\nu32 in32[2], out32[2];\r\nin32[0] = be32_to_cpu(in_blk[0]);\r\nin32[1] = be32_to_cpu(in_blk[1]);\r\nencrypt_block(crypto_tfm_ctx(tfm), out32, in32);\r\nout_blk[0] = cpu_to_be32(out32[0]);\r\nout_blk[1] = cpu_to_be32(out32[1]);\r\n}\r\nstatic void bf_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct bf_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __be32 *in_blk = (const __be32 *)src;\r\n__be32 *const out_blk = (__be32 *)dst;\r\nconst u32 *P = ctx->p;\r\nconst u32 *S = ctx->s;\r\nu32 yl = be32_to_cpu(in_blk[0]);\r\nu32 yr = be32_to_cpu(in_blk[1]);\r\nROUND(yr, yl, 17);\r\nROUND(yl, yr, 16);\r\nROUND(yr, yl, 15);\r\nROUND(yl, yr, 14);\r\nROUND(yr, yl, 13);\r\nROUND(yl, yr, 12);\r\nROUND(yr, yl, 11);\r\nROUND(yl, yr, 10);\r\nROUND(yr, yl, 9);\r\nROUND(yl, yr, 8);\r\nROUND(yr, yl, 7);\r\nROUND(yl, yr, 6);\r\nROUND(yr, yl, 5);\r\nROUND(yl, yr, 4);\r\nROUND(yr, yl, 3);\r\nROUND(yl, yr, 2);\r\nyl ^= P[1];\r\nyr ^= P[0];\r\nout_blk[0] = cpu_to_be32(yr);\r\nout_blk[1] = cpu_to_be32(yl);\r\n}\r\nstatic int bf_setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)\r\n{\r\nstruct bf_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 *P = ctx->p;\r\nu32 *S = ctx->s;\r\nshort i, j, count;\r\nu32 data[2], temp;\r\nfor (i = 0, count = 0; i < 256; i++)\r\nfor (j = 0; j < 4; j++, count++)\r\nS[count] = bf_sbox[count];\r\nfor (i = 0; i < 16 + 2; i++)\r\nP[i] = bf_pbox[i];\r\nfor (j = 0, i = 0; i < 16 + 2; i++) {\r\ntemp = (((u32)key[j] << 24) |\r\n((u32)key[(j + 1) % keylen] << 16) |\r\n((u32)key[(j + 2) % keylen] << 8) |\r\n((u32)key[(j + 3) % keylen]));\r\nP[i] = P[i] ^ temp;\r\nj = (j + 4) % keylen;\r\n}\r\ndata[0] = 0x00000000;\r\ndata[1] = 0x00000000;\r\nfor (i = 0; i < 16 + 2; i += 2) {\r\nencrypt_block((struct bf_ctx *)ctx, data, data);\r\nP[i] = data[0];\r\nP[i + 1] = data[1];\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = 0, count = i * 256; j < 256; j += 2, count += 2) {\r\nencrypt_block((struct bf_ctx *)ctx, data, data);\r\nS[count] = data[0];\r\nS[count + 1] = data[1];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init blowfish_mod_init(void)\r\n{\r\nreturn crypto_register_alg(&alg);\r\n}\r\nstatic void __exit blowfish_mod_fini(void)\r\n{\r\ncrypto_unregister_alg(&alg);\r\n}
