static int dw210x_op_rw(struct usb_device *dev, u8 request, u16 value,\r\nu16 index, u8 * data, u16 len, int flags)\r\n{\r\nint ret;\r\nu8 *u8buf;\r\nunsigned int pipe = (flags == DW210X_READ_MSG) ?\r\nusb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);\r\nu8 request_type = (flags == DW210X_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;\r\nu8buf = kmalloc(len, GFP_KERNEL);\r\nif (!u8buf)\r\nreturn -ENOMEM;\r\nif (flags == DW210X_WRITE_MSG)\r\nmemcpy(u8buf, data, len);\r\nret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,\r\nvalue, index , u8buf, len, 2000);\r\nif (flags == DW210X_READ_MSG)\r\nmemcpy(data, u8buf, len);\r\nkfree(u8buf);\r\nreturn ret;\r\n}\r\nstatic int dw2102_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i = 0, ret = 0;\r\nu8 buf6[] = {0x2c, 0x05, 0xc0, 0, 0, 0, 0};\r\nu16 value;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 2:\r\nvalue = msg[0].buf[0];\r\nfor (i = 0; i < msg[1].len; i++) {\r\nret = dw210x_op_rw(d->udev, 0xb5, value + i, 0,\r\nbuf6, 2, DW210X_READ_MSG);\r\nmsg[1].buf[i] = buf6[0];\r\n}\r\nbreak;\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase 0x68:\r\nbuf6[0] = 0x2a;\r\nbuf6[1] = msg[0].buf[0];\r\nbuf6[2] = msg[0].buf[1];\r\nret = dw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nbuf6, 3, DW210X_WRITE_MSG);\r\nbreak;\r\ncase 0x60:\r\nif (msg[0].flags == 0) {\r\nbuf6[0] = 0x2c;\r\nbuf6[1] = 5;\r\nbuf6[2] = 0xc0;\r\nbuf6[3] = msg[0].buf[0];\r\nbuf6[4] = msg[0].buf[1];\r\nbuf6[5] = msg[0].buf[2];\r\nbuf6[6] = msg[0].buf[3];\r\nret = dw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nbuf6, 7, DW210X_WRITE_MSG);\r\n} else {\r\nret = dw210x_op_rw(d->udev, 0xb5, 0, 0,\r\nbuf6, 1, DW210X_READ_MSG);\r\nmsg[0].buf[0] = buf6[0];\r\n}\r\nbreak;\r\ncase (DW2102_RC_QUERY):\r\nret = dw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nbuf6, 2, DW210X_READ_MSG);\r\nmsg[0].buf[0] = buf6[0];\r\nmsg[0].buf[1] = buf6[1];\r\nbreak;\r\ncase (DW2102_VOLTAGE_CTRL):\r\nbuf6[0] = 0x30;\r\nbuf6[1] = msg[0].buf[0];\r\nret = dw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nbuf6, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic int dw2102_serit_i2c_transfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret = 0;\r\nu8 buf6[] = {0, 0, 0, 0, 0, 0, 0};\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 2:\r\nbuf6[0] = msg[0].addr << 1;\r\nbuf6[1] = msg[0].len;\r\nbuf6[2] = msg[0].buf[0];\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nbuf6, msg[0].len + 2, DW210X_WRITE_MSG);\r\nret = dw210x_op_rw(d->udev, 0xc3, 0xd0, 0,\r\nbuf6, msg[1].len + 2, DW210X_READ_MSG);\r\nmemcpy(msg[1].buf, buf6 + 2, msg[1].len);\r\nbreak;\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase 0x68:\r\nbuf6[0] = msg[0].addr << 1;\r\nbuf6[1] = msg[0].len;\r\nmemcpy(buf6 + 2, msg[0].buf, msg[0].len);\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0, buf6,\r\nmsg[0].len + 2, DW210X_WRITE_MSG);\r\nbreak;\r\ncase(DW2102_RC_QUERY):\r\nret = dw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nbuf6, 2, DW210X_READ_MSG);\r\nmsg[0].buf[0] = buf6[0];\r\nmsg[0].buf[1] = buf6[1];\r\nbreak;\r\ncase(DW2102_VOLTAGE_CTRL):\r\nbuf6[0] = 0x30;\r\nbuf6[1] = msg[0].buf[0];\r\nret = dw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nbuf6, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic int dw2102_earda_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret = 0;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 2: {\r\nu8 ibuf[msg[1].len + 2], obuf[3];\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nobuf[2] = msg[0].buf[0];\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\nret = dw210x_op_rw(d->udev, 0xc3, 0xd1 , 0,\r\nibuf, msg[1].len + 2, DW210X_READ_MSG);\r\nmemcpy(msg[1].buf, ibuf + 2, msg[1].len);\r\nbreak;\r\n}\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase 0x68: {\r\nu8 obuf[msg[0].len + 2];\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nmemcpy(obuf + 2, msg[0].buf, msg[0].len);\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ncase 0x61: {\r\nu8 obuf[msg[0].len + 2];\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nmemcpy(obuf + 2, msg[0].buf, msg[0].len);\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ncase(DW2102_RC_QUERY): {\r\nu8 ibuf[2];\r\nret = dw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nibuf, 2, DW210X_READ_MSG);\r\nmemcpy(msg[0].buf, ibuf , 2);\r\nbreak;\r\n}\r\ncase(DW2102_VOLTAGE_CTRL): {\r\nu8 obuf[2];\r\nobuf[0] = 0x30;\r\nobuf[1] = msg[0].buf[0];\r\nret = dw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic int dw2104_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret = 0;\r\nint len, i, j;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (j = 0; j < num; j++) {\r\nswitch (msg[j].addr) {\r\ncase(DW2102_RC_QUERY): {\r\nu8 ibuf[2];\r\nret = dw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nibuf, 2, DW210X_READ_MSG);\r\nmemcpy(msg[j].buf, ibuf , 2);\r\nbreak;\r\n}\r\ncase(DW2102_VOLTAGE_CTRL): {\r\nu8 obuf[2];\r\nobuf[0] = 0x30;\r\nobuf[1] = msg[j].buf[0];\r\nret = dw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ndefault: {\r\nif (msg[j].flags == I2C_M_RD) {\r\nu8 ibuf[msg[j].len + 2];\r\nret = dw210x_op_rw(d->udev, 0xc3,\r\n(msg[j].addr << 1) + 1, 0,\r\nibuf, msg[j].len + 2,\r\nDW210X_READ_MSG);\r\nmemcpy(msg[j].buf, ibuf + 2, msg[j].len);\r\nmdelay(10);\r\n} else if (((msg[j].buf[0] == 0xb0) &&\r\n(msg[j].addr == 0x68)) ||\r\n((msg[j].buf[0] == 0xf7) &&\r\n(msg[j].addr == 0x55))) {\r\nu8 obuf[19];\r\nobuf[0] = msg[j].addr << 1;\r\nobuf[1] = (msg[j].len > 15 ? 17 : msg[j].len);\r\nobuf[2] = msg[j].buf[0];\r\nlen = msg[j].len - 1;\r\ni = 1;\r\ndo {\r\nmemcpy(obuf + 3, msg[j].buf + i,\r\n(len > 16 ? 16 : len));\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, (len > 16 ? 16 : len) + 3,\r\nDW210X_WRITE_MSG);\r\ni += 16;\r\nlen -= 16;\r\n} while (len > 0);\r\n} else {\r\nu8 obuf[msg[j].len + 2];\r\nobuf[0] = msg[j].addr << 1;\r\nobuf[1] = msg[j].len;\r\nmemcpy(obuf + 2, msg[j].buf, msg[j].len);\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[j].len + 2,\r\nDW210X_WRITE_MSG);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic int dw3101_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret = 0, i;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 2: {\r\nu8 ibuf[msg[1].len + 2], obuf[3];\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nobuf[2] = msg[0].buf[0];\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\nret = dw210x_op_rw(d->udev, 0xc3, 0x19 , 0,\r\nibuf, msg[1].len + 2, DW210X_READ_MSG);\r\nmemcpy(msg[1].buf, ibuf + 2, msg[1].len);\r\nbreak;\r\n}\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase 0x60:\r\ncase 0x0c: {\r\nu8 obuf[msg[0].len + 2];\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nmemcpy(obuf + 2, msg[0].buf, msg[0].len);\r\nret = dw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ncase(DW2102_RC_QUERY): {\r\nu8 ibuf[2];\r\nret = dw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nibuf, 2, DW210X_READ_MSG);\r\nmemcpy(msg[0].buf, ibuf , 2);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nfor (i = 0; i < num; i++) {\r\ndeb_xfer("%02x:%02x: %s ", i, msg[i].addr,\r\nmsg[i].flags == 0 ? ">>>" : "<<<");\r\ndebug_dump(msg[i].buf, msg[i].len, deb_xfer);\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic int s6x0_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct usb_device *udev;\r\nint ret = 0;\r\nint len, i, j;\r\nif (!d)\r\nreturn -ENODEV;\r\nudev = d->udev;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (j = 0; j < num; j++) {\r\nswitch (msg[j].addr) {\r\ncase (DW2102_RC_QUERY): {\r\nu8 ibuf[5];\r\nret = dw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nibuf, 5, DW210X_READ_MSG);\r\nmemcpy(msg[j].buf, ibuf + 3, 2);\r\nbreak;\r\n}\r\ncase (DW2102_VOLTAGE_CTRL): {\r\nu8 obuf[2];\r\nobuf[0] = 1;\r\nobuf[1] = msg[j].buf[1];\r\nret = dw210x_op_rw(d->udev, 0x8a, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nobuf[0] = 3;\r\nobuf[1] = msg[j].buf[0];\r\nret = dw210x_op_rw(d->udev, 0x8a, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ncase (DW2102_LED_CTRL): {\r\nu8 obuf[2];\r\nobuf[0] = 5;\r\nobuf[1] = msg[j].buf[0];\r\nret = dw210x_op_rw(d->udev, 0x8a, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ndefault: {\r\nif (msg[j].flags == I2C_M_RD) {\r\nu8 ibuf[msg[j].len];\r\nret = dw210x_op_rw(d->udev, 0x91, 0, 0,\r\nibuf, msg[j].len,\r\nDW210X_READ_MSG);\r\nmemcpy(msg[j].buf, ibuf, msg[j].len);\r\nbreak;\r\n} else if ((msg[j].buf[0] == 0xb0) &&\r\n(msg[j].addr == 0x68)) {\r\nu8 obuf[19];\r\nobuf[0] = (msg[j].len > 16 ?\r\n18 : msg[j].len + 1);\r\nobuf[1] = msg[j].addr << 1;\r\nobuf[2] = msg[j].buf[0];\r\nlen = msg[j].len - 1;\r\ni = 1;\r\ndo {\r\nmemcpy(obuf + 3, msg[j].buf + i,\r\n(len > 16 ? 16 : len));\r\nret = dw210x_op_rw(d->udev, 0x80, 0, 0,\r\nobuf, (len > 16 ? 16 : len) + 3,\r\nDW210X_WRITE_MSG);\r\ni += 16;\r\nlen -= 16;\r\n} while (len > 0);\r\n} else if (j < (num - 1)) {\r\nu8 obuf[msg[j].len + 2];\r\nobuf[0] = msg[j + 1].len;\r\nobuf[1] = (msg[j].addr << 1);\r\nmemcpy(obuf + 2, msg[j].buf, msg[j].len);\r\nret = dw210x_op_rw(d->udev,\r\nudev->descriptor.idProduct ==\r\n0x7500 ? 0x92 : 0x90, 0, 0,\r\nobuf, msg[j].len + 2,\r\nDW210X_WRITE_MSG);\r\nbreak;\r\n} else {\r\nu8 obuf[msg[j].len + 2];\r\nobuf[0] = msg[j].len + 1;\r\nobuf[1] = (msg[j].addr << 1);\r\nmemcpy(obuf + 2, msg[j].buf, msg[j].len);\r\nret = dw210x_op_rw(d->udev, 0x80, 0, 0,\r\nobuf, msg[j].len + 2,\r\nDW210X_WRITE_MSG);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nu8 obuf[0x40], ibuf[0x40];\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase SU3000_STREAM_CTRL:\r\nobuf[0] = msg[0].buf[0] + 0x36;\r\nobuf[1] = 3;\r\nobuf[2] = 0;\r\nif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 0, 0) < 0)\r\nerr("i2c transfer failed.");\r\nbreak;\r\ncase DW2102_RC_QUERY:\r\nobuf[0] = 0x10;\r\nif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 2, 0) < 0)\r\nerr("i2c transfer failed.");\r\nmsg[0].buf[1] = ibuf[0];\r\nmsg[0].buf[0] = ibuf[1];\r\nbreak;\r\ndefault:\r\nobuf[0] = 0x08;\r\nobuf[1] = msg[0].addr;\r\nobuf[2] = msg[0].len;\r\nmemcpy(&obuf[3], msg[0].buf, msg[0].len);\r\nif (dvb_usb_generic_rw(d, obuf, msg[0].len + 3,\r\nibuf, 1, 0) < 0)\r\nerr("i2c transfer failed.");\r\n}\r\nbreak;\r\ncase 2:\r\nobuf[0] = 0x09;\r\nobuf[1] = msg[0].len;\r\nobuf[2] = msg[1].len;\r\nobuf[3] = msg[0].addr;\r\nmemcpy(&obuf[4], msg[0].buf, msg[0].len);\r\nif (dvb_usb_generic_rw(d, obuf, msg[0].len + 4,\r\nibuf, msg[1].len + 1, 0) < 0)\r\nerr("i2c transfer failed.");\r\nmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\r\nbreak;\r\ndefault:\r\nwarn("more than 2 i2c messages at a time is not handled yet.");\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic u32 dw210x_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int dw210x_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nint i;\r\nu8 ibuf[] = {0, 0};\r\nu8 eeprom[256], eepromline[16];\r\nfor (i = 0; i < 256; i++) {\r\nif (dw210x_op_rw(d->udev, 0xb6, 0xa0 , i, ibuf, 2, DW210X_READ_MSG) < 0) {\r\nerr("read eeprom failed.");\r\nreturn -1;\r\n} else {\r\neepromline[i%16] = ibuf[0];\r\neeprom[i] = ibuf[0];\r\n}\r\nif ((i % 16) == 15) {\r\ndeb_xfer("%02x: ", i - 15);\r\ndebug_dump(eepromline, 16, deb_xfer);\r\n}\r\n}\r\nmemcpy(mac, eeprom + 8, 6);\r\nreturn 0;\r\n}\r\nstatic int s6x0_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nint i, ret;\r\nu8 ibuf[] = { 0 }, obuf[] = { 0 };\r\nu8 eeprom[256], eepromline[16];\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = 0xa0 >> 1,\r\n.flags = 0,\r\n.buf = obuf,\r\n.len = 1,\r\n}, {\r\n.addr = 0xa0 >> 1,\r\n.flags = I2C_M_RD,\r\n.buf = ibuf,\r\n.len = 1,\r\n}\r\n};\r\nfor (i = 0; i < 256; i++) {\r\nobuf[0] = i;\r\nret = s6x0_i2c_transfer(&d->i2c_adap, msg, 2);\r\nif (ret != 2) {\r\nerr("read eeprom failed.");\r\nreturn -1;\r\n} else {\r\neepromline[i % 16] = ibuf[0];\r\neeprom[i] = ibuf[0];\r\n}\r\nif ((i % 16) == 15) {\r\ndeb_xfer("%02x: ", i - 15);\r\ndebug_dump(eepromline, 16, deb_xfer);\r\n}\r\n}\r\nmemcpy(mac, eeprom + 16, 6);\r\nreturn 0;\r\n}\r\nstatic int su3000_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstatic u8 command_start[] = {0x00};\r\nstatic u8 command_stop[] = {0x01};\r\nstruct i2c_msg msg = {\r\n.addr = SU3000_STREAM_CTRL,\r\n.flags = 0,\r\n.buf = onoff ? command_start : command_stop,\r\n.len = 1\r\n};\r\ni2c_transfer(&adap->dev->i2c_adap, &msg, 1);\r\nreturn 0;\r\n}\r\nstatic int su3000_power_ctrl(struct dvb_usb_device *d, int i)\r\n{\r\nstruct su3000_state *state = (struct su3000_state *)d->priv;\r\nu8 obuf[] = {0xde, 0};\r\ninfo("%s: %d, initialized %d\n", __func__, i, state->initialized);\r\nif (i && !state->initialized) {\r\nstate->initialized = 1;\r\ndvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int su3000_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nint i;\r\nu8 obuf[] = { 0x1f, 0xf0 };\r\nu8 ibuf[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = 0x51,\r\n.flags = 0,\r\n.buf = obuf,\r\n.len = 2,\r\n}, {\r\n.addr = 0x51,\r\n.flags = I2C_M_RD,\r\n.buf = ibuf,\r\n.len = 1,\r\n}\r\n};\r\nfor (i = 0; i < 6; i++) {\r\nobuf[1] = 0xf0 + i;\r\nif (i2c_transfer(&d->i2c_adap, msg, 2) != 2)\r\nbreak;\r\nelse\r\nmac[i] = ibuf[0];\r\ndebug_dump(mac, 6, printk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int su3000_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\ninfo("%s\n", __func__);\r\n*cold = 0;\r\nreturn 0;\r\n}\r\nstatic int dw210x_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)\r\n{\r\nstatic u8 command_13v[] = {0x00, 0x01};\r\nstatic u8 command_18v[] = {0x01, 0x01};\r\nstatic u8 command_off[] = {0x00, 0x00};\r\nstruct i2c_msg msg = {\r\n.addr = DW2102_VOLTAGE_CTRL,\r\n.flags = 0,\r\n.buf = command_off,\r\n.len = 2,\r\n};\r\nstruct dvb_usb_adapter *udev_adap =\r\n(struct dvb_usb_adapter *)(fe->dvb->priv);\r\nif (voltage == SEC_VOLTAGE_18)\r\nmsg.buf = command_18v;\r\nelse if (voltage == SEC_VOLTAGE_13)\r\nmsg.buf = command_13v;\r\ni2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);\r\nreturn 0;\r\n}\r\nstatic int s660_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct dvb_usb_adapter *d =\r\n(struct dvb_usb_adapter *)(fe->dvb->priv);\r\nstruct s6x0_state *st = (struct s6x0_state *)d->dev->priv;\r\ndw210x_set_voltage(fe, voltage);\r\nif (st->old_set_voltage)\r\nst->old_set_voltage(fe, voltage);\r\nreturn 0;\r\n}\r\nstatic void dw210x_led_ctrl(struct dvb_frontend *fe, int offon)\r\n{\r\nstatic u8 led_off[] = { 0 };\r\nstatic u8 led_on[] = { 1 };\r\nstruct i2c_msg msg = {\r\n.addr = DW2102_LED_CTRL,\r\n.flags = 0,\r\n.buf = led_off,\r\n.len = 1\r\n};\r\nstruct dvb_usb_adapter *udev_adap =\r\n(struct dvb_usb_adapter *)(fe->dvb->priv);\r\nif (offon)\r\nmsg.buf = led_on;\r\ni2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);\r\n}\r\nstatic int dw2104_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nstruct dvb_tuner_ops *tuner_ops = NULL;\r\nif (demod_probe & 4) {\r\nd->fe = dvb_attach(stv0900_attach, &dw2104a_stv0900_config,\r\n&d->dev->i2c_adap, 0);\r\nif (d->fe != NULL) {\r\nif (dvb_attach(stb6100_attach, d->fe,\r\n&dw2104a_stb6100_config,\r\n&d->dev->i2c_adap)) {\r\ntuner_ops = &d->fe->ops.tuner_ops;\r\ntuner_ops->set_frequency = stb6100_set_freq;\r\ntuner_ops->get_frequency = stb6100_get_freq;\r\ntuner_ops->set_bandwidth = stb6100_set_bandw;\r\ntuner_ops->get_bandwidth = stb6100_get_bandw;\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached STV0900+STB6100!\n");\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (demod_probe & 2) {\r\nd->fe = dvb_attach(stv0900_attach, &dw2104_stv0900_config,\r\n&d->dev->i2c_adap, 0);\r\nif (d->fe != NULL) {\r\nif (dvb_attach(stv6110_attach, d->fe,\r\n&dw2104_stv6110_config,\r\n&d->dev->i2c_adap)) {\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached STV0900+STV6110A!\n");\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (demod_probe & 1) {\r\nd->fe = dvb_attach(cx24116_attach, &dw2104_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe != NULL) {\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached cx24116!\n");\r\nreturn 0;\r\n}\r\n}\r\nd->fe = dvb_attach(ds3000_attach, &dw2104_ds3000_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe != NULL) {\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached DS3000!\n");\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int dw2102_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nif (dw2102_properties.i2c_algo == &dw2102_serit_i2c_algo) {\r\nd->fe = dvb_attach(si21xx_attach, &serit_sp1511lhb_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe != NULL) {\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached si21xx!\n");\r\nreturn 0;\r\n}\r\n}\r\nif (dw2102_properties.i2c_algo == &dw2102_earda_i2c_algo) {\r\nd->fe = dvb_attach(stv0288_attach, &earda_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe != NULL) {\r\nif (dvb_attach(stb6000_attach, d->fe, 0x61,\r\n&d->dev->i2c_adap)) {\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached stv0288!\n");\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (dw2102_properties.i2c_algo == &dw2102_i2c_algo) {\r\nd->fe = dvb_attach(stv0299_attach, &sharp_z0194a_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe != NULL) {\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached stv0299!\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int dw3101_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nd->fe = dvb_attach(tda10023_attach, &dw3101_tda10023_config,\r\n&d->dev->i2c_adap, 0x48);\r\nif (d->fe != NULL) {\r\ninfo("Attached tda10023!\n");\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int zl100313_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nd->fe = dvb_attach(mt312_attach, &zl313_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe != NULL) {\r\nif (dvb_attach(zl10039_attach, d->fe, 0x60,\r\n&d->dev->i2c_adap)) {\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached zl100313+zl10039!\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int stv0288_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nu8 obuf[] = {7, 1};\r\nd->fe = dvb_attach(stv0288_attach, &earda_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe == NULL)\r\nreturn -EIO;\r\nif (NULL == dvb_attach(stb6000_attach, d->fe, 0x61, &d->dev->i2c_adap))\r\nreturn -EIO;\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ndw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\r\ninfo("Attached stv0288+stb6000!\n");\r\nreturn 0;\r\n}\r\nstatic int ds3000_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nstruct s6x0_state *st = (struct s6x0_state *)d->dev->priv;\r\nu8 obuf[] = {7, 1};\r\nd->fe = dvb_attach(ds3000_attach, &dw2104_ds3000_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe == NULL)\r\nreturn -EIO;\r\nst->old_set_voltage = d->fe->ops.set_voltage;\r\nd->fe->ops.set_voltage = s660_set_voltage;\r\ndw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\r\ninfo("Attached ds3000+ds2020!\n");\r\nreturn 0;\r\n}\r\nstatic int prof_7500_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nu8 obuf[] = {7, 1};\r\nd->fe = dvb_attach(stv0900_attach, &prof_7500_stv0900_config,\r\n&d->dev->i2c_adap, 0);\r\nif (d->fe == NULL)\r\nreturn -EIO;\r\nd->fe->ops.set_voltage = dw210x_set_voltage;\r\ndw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\r\ninfo("Attached STV0900+STB6100A!\n");\r\nreturn 0;\r\n}\r\nstatic int su3000_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nu8 obuf[3] = { 0xe, 0x80, 0 };\r\nu8 ibuf[] = { 0 };\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x83;\r\nobuf[2] = 0;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x83;\r\nobuf[2] = 1;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0x51;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\r\nerr("command 0x51 transfer failed.");\r\nd->fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe == NULL)\r\nreturn -EIO;\r\ninfo("Attached DS3000!\n");\r\nreturn 0;\r\n}\r\nstatic int dw2102_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(dvb_pll_attach, adap->fe, 0x60,\r\n&adap->dev->i2c_adap, DVB_PLL_OPERA1);\r\nreturn 0;\r\n}\r\nstatic int dw3101_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(dvb_pll_attach, adap->fe, 0x60,\r\n&adap->dev->i2c_adap, DVB_PLL_TUA6034);\r\nreturn 0;\r\n}\r\nstatic int dw2102_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\r\nint keymap_size = d->props.rc.legacy.rc_map_size;\r\nu8 key[2];\r\nstruct i2c_msg msg = {\r\n.addr = DW2102_RC_QUERY,\r\n.flags = I2C_M_RD,\r\n.buf = key,\r\n.len = 2\r\n};\r\nint i;\r\nif ((ir_keymap > 0) && (ir_keymap <= ARRAY_SIZE(keys_tables))) {\r\nkeymap = keys_tables[ir_keymap - 1].rc_keys ;\r\nkeymap_size = keys_tables[ir_keymap - 1].rc_keys_size;\r\n} else if (ir_keymap > ARRAY_SIZE(keys_tables))\r\nreturn 0;\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\r\nfor (i = 0; i < keymap_size ; i++) {\r\nif (rc5_data(&keymap[i]) == msg.buf[0]) {\r\n*state = REMOTE_KEY_PRESSED;\r\n*event = keymap[i].keycode;\r\nbreak;\r\n}\r\n}\r\nif ((*state) == REMOTE_KEY_PRESSED)\r\ndeb_rc("%s: found rc key: %x, %x, event: %x\n",\r\n__func__, key[0], key[1], (*event));\r\nelse if (key[0] != 0xff)\r\ndeb_rc("%s: unknown rc key: %x, %x\n",\r\n__func__, key[0], key[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dw2102_load_firmware(struct usb_device *dev,\r\nconst struct firmware *frmwr)\r\n{\r\nu8 *b, *p;\r\nint ret = 0, i;\r\nu8 reset;\r\nu8 reset16[] = {0, 0, 0, 0, 0, 0, 0};\r\nconst struct firmware *fw;\r\nconst char *fw_2101 = "dvb-usb-dw2101.fw";\r\nswitch (dev->descriptor.idProduct) {\r\ncase 0x2101:\r\nret = request_firmware(&fw, fw_2101, &dev->dev);\r\nif (ret != 0) {\r\nerr(err_str, fw_2101);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nfw = frmwr;\r\nbreak;\r\n}\r\ninfo("start downloading DW210X firmware");\r\np = kmalloc(fw->size, GFP_KERNEL);\r\nreset = 1;\r\ndw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, DW210X_WRITE_MSG);\r\ndw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, DW210X_WRITE_MSG);\r\nif (p != NULL) {\r\nmemcpy(p, fw->data, fw->size);\r\nfor (i = 0; i < fw->size; i += 0x40) {\r\nb = (u8 *) p + i;\r\nif (dw210x_op_rw(dev, 0xa0, i, 0, b , 0x40,\r\nDW210X_WRITE_MSG) != 0x40) {\r\nerr("error while transferring firmware");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nreset = 0;\r\nif (ret || dw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,\r\nDW210X_WRITE_MSG) != 1) {\r\nerr("could not restart the USB controller CPU.");\r\nret = -EINVAL;\r\n}\r\nif (ret || dw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,\r\nDW210X_WRITE_MSG) != 1) {\r\nerr("could not restart the USB controller CPU.");\r\nret = -EINVAL;\r\n}\r\nswitch (dev->descriptor.idProduct) {\r\ncase USB_PID_TEVII_S650:\r\ndw2104_properties.rc.legacy.rc_map_table = rc_map_tevii_table;\r\ndw2104_properties.rc.legacy.rc_map_size =\r\nARRAY_SIZE(rc_map_tevii_table);\r\ncase USB_PID_DW2104:\r\nreset = 1;\r\ndw210x_op_rw(dev, 0xc4, 0x0000, 0, &reset, 1,\r\nDW210X_WRITE_MSG);\r\ncase USB_PID_DW3101:\r\nreset = 0;\r\ndw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,\r\nDW210X_WRITE_MSG);\r\nbreak;\r\ncase USB_PID_CINERGY_S:\r\ncase USB_PID_DW2102:\r\ndw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,\r\nDW210X_WRITE_MSG);\r\ndw210x_op_rw(dev, 0xb9, 0x0000, 0, &reset16[0], 2,\r\nDW210X_READ_MSG);\r\ndw210x_op_rw(dev, 0xb5, 0, 0, &reset16[0], 2,\r\nDW210X_READ_MSG);\r\nif ((reset16[0] == 0xa1) || (reset16[0] == 0x80)) {\r\ndw2102_properties.i2c_algo = &dw2102_i2c_algo;\r\ndw2102_properties.adapter->tuner_attach = &dw2102_tuner_attach;\r\nbreak;\r\n} else {\r\nreset16[0] = 0xd0;\r\nreset16[1] = 1;\r\nreset16[2] = 0;\r\ndw210x_op_rw(dev, 0xc2, 0, 0, &reset16[0], 3,\r\nDW210X_WRITE_MSG);\r\ndw210x_op_rw(dev, 0xc3, 0xd1, 0, &reset16[0], 3,\r\nDW210X_READ_MSG);\r\nif (reset16[2] == 0x11) {\r\ndw2102_properties.i2c_algo = &dw2102_earda_i2c_algo;\r\nbreak;\r\n}\r\n}\r\ncase 0x2101:\r\ndw210x_op_rw(dev, 0xbc, 0x0030, 0, &reset16[0], 2,\r\nDW210X_READ_MSG);\r\ndw210x_op_rw(dev, 0xba, 0x0000, 0, &reset16[0], 7,\r\nDW210X_READ_MSG);\r\ndw210x_op_rw(dev, 0xba, 0x0000, 0, &reset16[0], 7,\r\nDW210X_READ_MSG);\r\ndw210x_op_rw(dev, 0xb9, 0x0000, 0, &reset16[0], 2,\r\nDW210X_READ_MSG);\r\nbreak;\r\n}\r\nmsleep(100);\r\nkfree(p);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dw2102_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\np1100 = kzalloc(sizeof(struct dvb_usb_device_properties), GFP_KERNEL);\r\nif (!p1100)\r\nreturn -ENOMEM;\r\nmemcpy(p1100, &s6x0_properties,\r\nsizeof(struct dvb_usb_device_properties));\r\np1100->firmware = "dvb-usb-p1100.fw";\r\np1100->devices[0] = d1100;\r\np1100->rc.legacy.rc_map_table = rc_map_tbs_table;\r\np1100->rc.legacy.rc_map_size = ARRAY_SIZE(rc_map_tbs_table);\r\np1100->adapter->frontend_attach = stv0288_frontend_attach;\r\ns660 = kzalloc(sizeof(struct dvb_usb_device_properties), GFP_KERNEL);\r\nif (!s660) {\r\nkfree(p1100);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(s660, &s6x0_properties,\r\nsizeof(struct dvb_usb_device_properties));\r\ns660->firmware = "dvb-usb-s660.fw";\r\ns660->num_device_descs = 3;\r\ns660->devices[0] = d660;\r\ns660->devices[1] = d480_1;\r\ns660->devices[2] = d480_2;\r\ns660->adapter->frontend_attach = ds3000_frontend_attach;\r\np7500 = kzalloc(sizeof(struct dvb_usb_device_properties), GFP_KERNEL);\r\nif (!p7500) {\r\nkfree(p1100);\r\nkfree(s660);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(p7500, &s6x0_properties,\r\nsizeof(struct dvb_usb_device_properties));\r\np7500->firmware = "dvb-usb-p7500.fw";\r\np7500->devices[0] = d7500;\r\np7500->rc.legacy.rc_map_table = rc_map_tbs_table;\r\np7500->rc.legacy.rc_map_size = ARRAY_SIZE(rc_map_tbs_table);\r\np7500->adapter->frontend_attach = prof_7500_frontend_attach;\r\nif (0 == dvb_usb_device_init(intf, &dw2102_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &dw2104_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &dw3101_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &s6x0_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, p1100,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, s660,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, p7500,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &su3000_properties,\r\nTHIS_MODULE, NULL, adapter_nr))\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int __init dw2102_module_init(void)\r\n{\r\nint ret = usb_register(&dw2102_driver);\r\nif (ret)\r\nerr("usb_register failed. Error number %d", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit dw2102_module_exit(void)\r\n{\r\nusb_deregister(&dw2102_driver);\r\n}
