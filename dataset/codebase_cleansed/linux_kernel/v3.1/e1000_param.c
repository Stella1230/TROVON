static int __devinit e1000_validate_option(unsigned int *value,\r\nconst struct e1000_option *opt,\r\nstruct e1000_adapter *adapter)\r\n{\r\nif (*value == OPTION_UNSET) {\r\n*value = opt->def;\r\nreturn 0;\r\n}\r\nswitch (opt->type) {\r\ncase enable_option:\r\nswitch (*value) {\r\ncase OPTION_ENABLED:\r\ne_dev_info("%s Enabled\n", opt->name);\r\nreturn 0;\r\ncase OPTION_DISABLED:\r\ne_dev_info("%s Disabled\n", opt->name);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase range_option:\r\nif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\r\ne_dev_info("%s set to %i\n", opt->name, *value);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase list_option: {\r\nint i;\r\nconst struct e1000_opt_list *ent;\r\nfor (i = 0; i < opt->arg.l.nr; i++) {\r\nent = &opt->arg.l.p[i];\r\nif (*value == ent->i) {\r\nif (ent->str[0] != '\0')\r\ne_dev_info("%s\n", ent->str);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ne_dev_info("Invalid %s value specified (%i) %s\n",\r\nopt->name, *value, opt->err);\r\n*value = opt->def;\r\nreturn -1;\r\n}\r\nvoid __devinit e1000_check_options(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_option opt;\r\nint bd = adapter->bd_number;\r\nif (bd >= E1000_MAX_NIC) {\r\ne_dev_warn("Warning: no configuration for board #%i "\r\n"using defaults for all values\n", bd);\r\n}\r\n{\r\nstruct e1000_tx_ring *tx_ring = adapter->tx_ring;\r\nint i;\r\ne1000_mac_type mac_type = adapter->hw.mac_type;\r\nopt = (struct e1000_option) {\r\n.type = range_option,\r\n.name = "Transmit Descriptors",\r\n.err = "using default of "\r\n__MODULE_STRING(E1000_DEFAULT_TXD),\r\n.def = E1000_DEFAULT_TXD,\r\n.arg = { .r = {\r\n.min = E1000_MIN_TXD,\r\n.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD\r\n}}\r\n};\r\nif (num_TxDescriptors > bd) {\r\ntx_ring->count = TxDescriptors[bd];\r\ne1000_validate_option(&tx_ring->count, &opt, adapter);\r\ntx_ring->count = ALIGN(tx_ring->count,\r\nREQ_TX_DESCRIPTOR_MULTIPLE);\r\n} else {\r\ntx_ring->count = opt.def;\r\n}\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\ntx_ring[i].count = tx_ring->count;\r\n}\r\n{\r\nstruct e1000_rx_ring *rx_ring = adapter->rx_ring;\r\nint i;\r\ne1000_mac_type mac_type = adapter->hw.mac_type;\r\nopt = (struct e1000_option) {\r\n.type = range_option,\r\n.name = "Receive Descriptors",\r\n.err = "using default of "\r\n__MODULE_STRING(E1000_DEFAULT_RXD),\r\n.def = E1000_DEFAULT_RXD,\r\n.arg = { .r = {\r\n.min = E1000_MIN_RXD,\r\n.max = mac_type < e1000_82544 ? E1000_MAX_RXD : E1000_MAX_82544_RXD\r\n}}\r\n};\r\nif (num_RxDescriptors > bd) {\r\nrx_ring->count = RxDescriptors[bd];\r\ne1000_validate_option(&rx_ring->count, &opt, adapter);\r\nrx_ring->count = ALIGN(rx_ring->count,\r\nREQ_RX_DESCRIPTOR_MULTIPLE);\r\n} else {\r\nrx_ring->count = opt.def;\r\n}\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nrx_ring[i].count = rx_ring->count;\r\n}\r\n{\r\nopt = (struct e1000_option) {\r\n.type = enable_option,\r\n.name = "Checksum Offload",\r\n.err = "defaulting to Enabled",\r\n.def = OPTION_ENABLED\r\n};\r\nif (num_XsumRX > bd) {\r\nunsigned int rx_csum = XsumRX[bd];\r\ne1000_validate_option(&rx_csum, &opt, adapter);\r\nadapter->rx_csum = rx_csum;\r\n} else {\r\nadapter->rx_csum = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct e1000_opt_list fc_list[] = {\r\n{ E1000_FC_NONE, "Flow Control Disabled" },\r\n{ E1000_FC_RX_PAUSE, "Flow Control Receive Only" },\r\n{ E1000_FC_TX_PAUSE, "Flow Control Transmit Only" },\r\n{ E1000_FC_FULL, "Flow Control Enabled" },\r\n{ E1000_FC_DEFAULT, "Flow Control Hardware Default" }\r\n};\r\nopt = (struct e1000_option) {\r\n.type = list_option,\r\n.name = "Flow Control",\r\n.err = "reading default settings from EEPROM",\r\n.def = E1000_FC_DEFAULT,\r\n.arg = { .l = { .nr = ARRAY_SIZE(fc_list),\r\n.p = fc_list }}\r\n};\r\nif (num_FlowControl > bd) {\r\nunsigned int fc = FlowControl[bd];\r\ne1000_validate_option(&fc, &opt, adapter);\r\nadapter->hw.fc = adapter->hw.original_fc = fc;\r\n} else {\r\nadapter->hw.fc = adapter->hw.original_fc = opt.def;\r\n}\r\n}\r\n{\r\nopt = (struct e1000_option) {\r\n.type = range_option,\r\n.name = "Transmit Interrupt Delay",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_TIDV),\r\n.def = DEFAULT_TIDV,\r\n.arg = { .r = { .min = MIN_TXDELAY,\r\n.max = MAX_TXDELAY }}\r\n};\r\nif (num_TxIntDelay > bd) {\r\nadapter->tx_int_delay = TxIntDelay[bd];\r\ne1000_validate_option(&adapter->tx_int_delay, &opt,\r\nadapter);\r\n} else {\r\nadapter->tx_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nopt = (struct e1000_option) {\r\n.type = range_option,\r\n.name = "Transmit Absolute Interrupt Delay",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_TADV),\r\n.def = DEFAULT_TADV,\r\n.arg = { .r = { .min = MIN_TXABSDELAY,\r\n.max = MAX_TXABSDELAY }}\r\n};\r\nif (num_TxAbsIntDelay > bd) {\r\nadapter->tx_abs_int_delay = TxAbsIntDelay[bd];\r\ne1000_validate_option(&adapter->tx_abs_int_delay, &opt,\r\nadapter);\r\n} else {\r\nadapter->tx_abs_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nopt = (struct e1000_option) {\r\n.type = range_option,\r\n.name = "Receive Interrupt Delay",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_RDTR),\r\n.def = DEFAULT_RDTR,\r\n.arg = { .r = { .min = MIN_RXDELAY,\r\n.max = MAX_RXDELAY }}\r\n};\r\nif (num_RxIntDelay > bd) {\r\nadapter->rx_int_delay = RxIntDelay[bd];\r\ne1000_validate_option(&adapter->rx_int_delay, &opt,\r\nadapter);\r\n} else {\r\nadapter->rx_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nopt = (struct e1000_option) {\r\n.type = range_option,\r\n.name = "Receive Absolute Interrupt Delay",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_RADV),\r\n.def = DEFAULT_RADV,\r\n.arg = { .r = { .min = MIN_RXABSDELAY,\r\n.max = MAX_RXABSDELAY }}\r\n};\r\nif (num_RxAbsIntDelay > bd) {\r\nadapter->rx_abs_int_delay = RxAbsIntDelay[bd];\r\ne1000_validate_option(&adapter->rx_abs_int_delay, &opt,\r\nadapter);\r\n} else {\r\nadapter->rx_abs_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nopt = (struct e1000_option) {\r\n.type = range_option,\r\n.name = "Interrupt Throttling Rate (ints/sec)",\r\n.err = "using default of " __MODULE_STRING(DEFAULT_ITR),\r\n.def = DEFAULT_ITR,\r\n.arg = { .r = { .min = MIN_ITR,\r\n.max = MAX_ITR }}\r\n};\r\nif (num_InterruptThrottleRate > bd) {\r\nadapter->itr = InterruptThrottleRate[bd];\r\nswitch (adapter->itr) {\r\ncase 0:\r\ne_dev_info("%s turned off\n", opt.name);\r\nbreak;\r\ncase 1:\r\ne_dev_info("%s set to dynamic mode\n",\r\nopt.name);\r\nadapter->itr_setting = adapter->itr;\r\nadapter->itr = 20000;\r\nbreak;\r\ncase 3:\r\ne_dev_info("%s set to dynamic conservative "\r\n"mode\n", opt.name);\r\nadapter->itr_setting = adapter->itr;\r\nadapter->itr = 20000;\r\nbreak;\r\ncase 4:\r\ne_dev_info("%s set to simplified "\r\n"(2000-8000) ints mode\n", opt.name);\r\nadapter->itr_setting = adapter->itr;\r\nbreak;\r\ndefault:\r\ne1000_validate_option(&adapter->itr, &opt,\r\nadapter);\r\nadapter->itr_setting = adapter->itr & ~3;\r\nbreak;\r\n}\r\n} else {\r\nadapter->itr_setting = opt.def;\r\nadapter->itr = 20000;\r\n}\r\n}\r\n{\r\nopt = (struct e1000_option) {\r\n.type = enable_option,\r\n.name = "PHY Smart Power Down",\r\n.err = "defaulting to Disabled",\r\n.def = OPTION_DISABLED\r\n};\r\nif (num_SmartPowerDownEnable > bd) {\r\nunsigned int spd = SmartPowerDownEnable[bd];\r\ne1000_validate_option(&spd, &opt, adapter);\r\nadapter->smart_power_down = spd;\r\n} else {\r\nadapter->smart_power_down = opt.def;\r\n}\r\n}\r\nswitch (adapter->hw.media_type) {\r\ncase e1000_media_type_fiber:\r\ncase e1000_media_type_internal_serdes:\r\ne1000_check_fiber_options(adapter);\r\nbreak;\r\ncase e1000_media_type_copper:\r\ne1000_check_copper_options(adapter);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void __devinit e1000_check_fiber_options(struct e1000_adapter *adapter)\r\n{\r\nint bd = adapter->bd_number;\r\nif (num_Speed > bd) {\r\ne_dev_info("Speed not valid for fiber adapters, parameter "\r\n"ignored\n");\r\n}\r\nif (num_Duplex > bd) {\r\ne_dev_info("Duplex not valid for fiber adapters, parameter "\r\n"ignored\n");\r\n}\r\nif ((num_AutoNeg > bd) && (AutoNeg[bd] != 0x20)) {\r\ne_dev_info("AutoNeg other than 1000/Full is not valid for fiber"\r\n"adapters, parameter ignored\n");\r\n}\r\n}\r\nstatic void __devinit e1000_check_copper_options(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_option opt;\r\nunsigned int speed, dplx, an;\r\nint bd = adapter->bd_number;\r\n{\r\nstatic const struct e1000_opt_list speed_list[] = {\r\n{ 0, "" },\r\n{ SPEED_10, "" },\r\n{ SPEED_100, "" },\r\n{ SPEED_1000, "" }};\r\nopt = (struct e1000_option) {\r\n.type = list_option,\r\n.name = "Speed",\r\n.err = "parameter ignored",\r\n.def = 0,\r\n.arg = { .l = { .nr = ARRAY_SIZE(speed_list),\r\n.p = speed_list }}\r\n};\r\nif (num_Speed > bd) {\r\nspeed = Speed[bd];\r\ne1000_validate_option(&speed, &opt, adapter);\r\n} else {\r\nspeed = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct e1000_opt_list dplx_list[] = {\r\n{ 0, "" },\r\n{ HALF_DUPLEX, "" },\r\n{ FULL_DUPLEX, "" }};\r\nopt = (struct e1000_option) {\r\n.type = list_option,\r\n.name = "Duplex",\r\n.err = "parameter ignored",\r\n.def = 0,\r\n.arg = { .l = { .nr = ARRAY_SIZE(dplx_list),\r\n.p = dplx_list }}\r\n};\r\nif (num_Duplex > bd) {\r\ndplx = Duplex[bd];\r\ne1000_validate_option(&dplx, &opt, adapter);\r\n} else {\r\ndplx = opt.def;\r\n}\r\n}\r\nif ((num_AutoNeg > bd) && (speed != 0 || dplx != 0)) {\r\ne_dev_info("AutoNeg specified along with Speed or Duplex, "\r\n"parameter ignored\n");\r\nadapter->hw.autoneg_advertised = AUTONEG_ADV_DEFAULT;\r\n} else {\r\nstatic const struct e1000_opt_list an_list[] =\r\n#define AA "AutoNeg advertising "\r\n{{ 0x01, AA "10/HD" },\r\n{ 0x02, AA "10/FD" },\r\n{ 0x03, AA "10/FD, 10/HD" },\r\n{ 0x04, AA "100/HD" },\r\n{ 0x05, AA "100/HD, 10/HD" },\r\n{ 0x06, AA "100/HD, 10/FD" },\r\n{ 0x07, AA "100/HD, 10/FD, 10/HD" },\r\n{ 0x08, AA "100/FD" },\r\n{ 0x09, AA "100/FD, 10/HD" },\r\n{ 0x0a, AA "100/FD, 10/FD" },\r\n{ 0x0b, AA "100/FD, 10/FD, 10/HD" },\r\n{ 0x0c, AA "100/FD, 100/HD" },\r\n{ 0x0d, AA "100/FD, 100/HD, 10/HD" },\r\n{ 0x0e, AA "100/FD, 100/HD, 10/FD" },\r\n{ 0x0f, AA "100/FD, 100/HD, 10/FD, 10/HD" },\r\n{ 0x20, AA "1000/FD" },\r\n{ 0x21, AA "1000/FD, 10/HD" },\r\n{ 0x22, AA "1000/FD, 10/FD" },\r\n{ 0x23, AA "1000/FD, 10/FD, 10/HD" },\r\n{ 0x24, AA "1000/FD, 100/HD" },\r\n{ 0x25, AA "1000/FD, 100/HD, 10/HD" },\r\n{ 0x26, AA "1000/FD, 100/HD, 10/FD" },\r\n{ 0x27, AA "1000/FD, 100/HD, 10/FD, 10/HD" },\r\n{ 0x28, AA "1000/FD, 100/FD" },\r\n{ 0x29, AA "1000/FD, 100/FD, 10/HD" },\r\n{ 0x2a, AA "1000/FD, 100/FD, 10/FD" },\r\n{ 0x2b, AA "1000/FD, 100/FD, 10/FD, 10/HD" },\r\n{ 0x2c, AA "1000/FD, 100/FD, 100/HD" },\r\n{ 0x2d, AA "1000/FD, 100/FD, 100/HD, 10/HD" },\r\n{ 0x2e, AA "1000/FD, 100/FD, 100/HD, 10/FD" },\r\n{ 0x2f, AA "1000/FD, 100/FD, 100/HD, 10/FD, 10/HD" }};\r\nopt = (struct e1000_option) {\r\n.type = list_option,\r\n.name = "AutoNeg",\r\n.err = "parameter ignored",\r\n.def = AUTONEG_ADV_DEFAULT,\r\n.arg = { .l = { .nr = ARRAY_SIZE(an_list),\r\n.p = an_list }}\r\n};\r\nif (num_AutoNeg > bd) {\r\nan = AutoNeg[bd];\r\ne1000_validate_option(&an, &opt, adapter);\r\n} else {\r\nan = opt.def;\r\n}\r\nadapter->hw.autoneg_advertised = an;\r\n}\r\nswitch (speed + dplx) {\r\ncase 0:\r\nadapter->hw.autoneg = adapter->fc_autoneg = 1;\r\nif ((num_Speed > bd) && (speed != 0 || dplx != 0))\r\ne_dev_info("Speed and duplex autonegotiation "\r\n"enabled\n");\r\nbreak;\r\ncase HALF_DUPLEX:\r\ne_dev_info("Half Duplex specified without Speed\n");\r\ne_dev_info("Using Autonegotiation at Half Duplex only\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 1;\r\nadapter->hw.autoneg_advertised = ADVERTISE_10_HALF |\r\nADVERTISE_100_HALF;\r\nbreak;\r\ncase FULL_DUPLEX:\r\ne_dev_info("Full Duplex specified without Speed\n");\r\ne_dev_info("Using Autonegotiation at Full Duplex only\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 1;\r\nadapter->hw.autoneg_advertised = ADVERTISE_10_FULL |\r\nADVERTISE_100_FULL |\r\nADVERTISE_1000_FULL;\r\nbreak;\r\ncase SPEED_10:\r\ne_dev_info("10 Mbps Speed specified without Duplex\n");\r\ne_dev_info("Using Autonegotiation at 10 Mbps only\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 1;\r\nadapter->hw.autoneg_advertised = ADVERTISE_10_HALF |\r\nADVERTISE_10_FULL;\r\nbreak;\r\ncase SPEED_10 + HALF_DUPLEX:\r\ne_dev_info("Forcing to 10 Mbps Half Duplex\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 0;\r\nadapter->hw.forced_speed_duplex = e1000_10_half;\r\nadapter->hw.autoneg_advertised = 0;\r\nbreak;\r\ncase SPEED_10 + FULL_DUPLEX:\r\ne_dev_info("Forcing to 10 Mbps Full Duplex\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 0;\r\nadapter->hw.forced_speed_duplex = e1000_10_full;\r\nadapter->hw.autoneg_advertised = 0;\r\nbreak;\r\ncase SPEED_100:\r\ne_dev_info("100 Mbps Speed specified without Duplex\n");\r\ne_dev_info("Using Autonegotiation at 100 Mbps only\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 1;\r\nadapter->hw.autoneg_advertised = ADVERTISE_100_HALF |\r\nADVERTISE_100_FULL;\r\nbreak;\r\ncase SPEED_100 + HALF_DUPLEX:\r\ne_dev_info("Forcing to 100 Mbps Half Duplex\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 0;\r\nadapter->hw.forced_speed_duplex = e1000_100_half;\r\nadapter->hw.autoneg_advertised = 0;\r\nbreak;\r\ncase SPEED_100 + FULL_DUPLEX:\r\ne_dev_info("Forcing to 100 Mbps Full Duplex\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 0;\r\nadapter->hw.forced_speed_duplex = e1000_100_full;\r\nadapter->hw.autoneg_advertised = 0;\r\nbreak;\r\ncase SPEED_1000:\r\ne_dev_info("1000 Mbps Speed specified without Duplex\n");\r\ngoto full_duplex_only;\r\ncase SPEED_1000 + HALF_DUPLEX:\r\ne_dev_info("Half Duplex is not supported at 1000 Mbps\n");\r\ncase SPEED_1000 + FULL_DUPLEX:\r\nfull_duplex_only:\r\ne_dev_info("Using Autonegotiation at 1000 Mbps Full Duplex "\r\n"only\n");\r\nadapter->hw.autoneg = adapter->fc_autoneg = 1;\r\nadapter->hw.autoneg_advertised = ADVERTISE_1000_FULL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (e1000_validate_mdi_setting(&(adapter->hw)) < 0) {\r\ne_dev_info("Speed, AutoNeg and MDI-X specs are incompatible. "\r\n"Setting MDI-X to a compatible value.\n");\r\n}\r\n}
