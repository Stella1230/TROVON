static int hists__add_entry(struct hists *self,\r\nstruct addr_location *al, u64 period)\r\n{\r\nif (__hists__add_entry(self, al, NULL, period) != NULL)\r\nreturn 0;\r\nreturn -ENOMEM;\r\n}\r\nstatic int diff__process_sample_event(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __used,\r\nstruct perf_session *session)\r\n{\r\nstruct addr_location al;\r\nif (perf_event__preprocess_sample(event, session, &al, sample, NULL) < 0) {\r\npr_warning("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (al.filtered || al.sym == NULL)\r\nreturn 0;\r\nif (hists__add_entry(&session->hists, &al, sample->period)) {\r\npr_warning("problem incrementing symbol period, skipping event\n");\r\nreturn -1;\r\n}\r\nsession->hists.stats.total_period += sample->period;\r\nreturn 0;\r\n}\r\nstatic void perf_session__insert_hist_entry_by_name(struct rb_root *root,\r\nstruct hist_entry *he)\r\n{\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct hist_entry *iter;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\niter = rb_entry(parent, struct hist_entry, rb_node);\r\nif (hist_entry__cmp(he, iter) < 0)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&he->rb_node, parent, p);\r\nrb_insert_color(&he->rb_node, root);\r\n}\r\nstatic void hists__resort_entries(struct hists *self)\r\n{\r\nunsigned long position = 1;\r\nstruct rb_root tmp = RB_ROOT;\r\nstruct rb_node *next = rb_first(&self->entries);\r\nwhile (next != NULL) {\r\nstruct hist_entry *n = rb_entry(next, struct hist_entry, rb_node);\r\nnext = rb_next(&n->rb_node);\r\nrb_erase(&n->rb_node, &self->entries);\r\nn->position = position++;\r\nperf_session__insert_hist_entry_by_name(&tmp, n);\r\n}\r\nself->entries = tmp;\r\n}\r\nstatic void hists__set_positions(struct hists *self)\r\n{\r\nhists__output_resort(self);\r\nhists__resort_entries(self);\r\n}\r\nstatic struct hist_entry *hists__find_entry(struct hists *self,\r\nstruct hist_entry *he)\r\n{\r\nstruct rb_node *n = self->entries.rb_node;\r\nwhile (n) {\r\nstruct hist_entry *iter = rb_entry(n, struct hist_entry, rb_node);\r\nint64_t cmp = hist_entry__cmp(he, iter);\r\nif (cmp < 0)\r\nn = n->rb_left;\r\nelse if (cmp > 0)\r\nn = n->rb_right;\r\nelse\r\nreturn iter;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void hists__match(struct hists *older, struct hists *newer)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&newer->entries); nd; nd = rb_next(nd)) {\r\nstruct hist_entry *pos = rb_entry(nd, struct hist_entry, rb_node);\r\npos->pair = hists__find_entry(older, pos);\r\n}\r\n}\r\nstatic int __cmd_diff(void)\r\n{\r\nint ret, i;\r\nstruct perf_session *session[2];\r\nsession[0] = perf_session__new(input_old, O_RDONLY, force, false, &event_ops);\r\nsession[1] = perf_session__new(input_new, O_RDONLY, force, false, &event_ops);\r\nif (session[0] == NULL || session[1] == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 2; ++i) {\r\nret = perf_session__process_events(session[i], &event_ops);\r\nif (ret)\r\ngoto out_delete;\r\n}\r\nhists__output_resort(&session[1]->hists);\r\nif (show_displacement)\r\nhists__set_positions(&session[0]->hists);\r\nhists__match(&session[0]->hists, &session[1]->hists);\r\nhists__fprintf(&session[1]->hists, &session[0]->hists,\r\nshow_displacement, stdout);\r\nout_delete:\r\nfor (i = 0; i < 2; ++i)\r\nperf_session__delete(session[i]);\r\nreturn ret;\r\n}\r\nint cmd_diff(int argc, const char **argv, const char *prefix __used)\r\n{\r\nsort_order = diff__default_sort_order;\r\nargc = parse_options(argc, argv, options, diff_usage, 0);\r\nif (argc) {\r\nif (argc > 2)\r\nusage_with_options(diff_usage, options);\r\nif (argc == 2) {\r\ninput_old = argv[0];\r\ninput_new = argv[1];\r\n} else\r\ninput_new = argv[0];\r\n} else if (symbol_conf.default_guest_vmlinux_name ||\r\nsymbol_conf.default_guest_kallsyms) {\r\ninput_old = "perf.data.host";\r\ninput_new = "perf.data.guest";\r\n}\r\nsymbol_conf.exclude_other = false;\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nsetup_sorting(diff_usage, options);\r\nsetup_pager();\r\nsort_entry__setup_elide(&sort_dso, symbol_conf.dso_list, "dso", NULL);\r\nsort_entry__setup_elide(&sort_comm, symbol_conf.comm_list, "comm", NULL);\r\nsort_entry__setup_elide(&sort_sym, symbol_conf.sym_list, "symbol", NULL);\r\nreturn __cmd_diff();\r\n}
