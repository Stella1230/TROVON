void *\r\naggr_init(ALLOC_NETBUFS netbuf_allocator)\r\n{\r\nstruct aggr_info *p_aggr = NULL;\r\nstruct rxtid *rxtid;\r\nu8 i;\r\nint status = 0;\r\nA_PRINTF("In aggr_init..\n");\r\ndo {\r\np_aggr = A_MALLOC(sizeof(struct aggr_info));\r\nif(!p_aggr) {\r\nA_PRINTF("Failed to allocate memory for aggr_node\n");\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\nA_MEMZERO(p_aggr, sizeof(struct aggr_info));\r\np_aggr->aggr_sz = AGGR_SZ_DEFAULT;\r\nA_INIT_TIMER(&p_aggr->timer, aggr_timeout, p_aggr);\r\np_aggr->timerScheduled = false;\r\nA_NETBUF_QUEUE_INIT(&p_aggr->freeQ);\r\np_aggr->netbuf_allocator = netbuf_allocator;\r\np_aggr->netbuf_allocator(&p_aggr->freeQ, AGGR_NUM_OF_FREE_NETBUFS);\r\nfor(i = 0; i < NUM_OF_TIDS; i++) {\r\nrxtid = AGGR_GET_RXTID(p_aggr, i);\r\nrxtid->aggr = false;\r\nrxtid->progress = false;\r\nrxtid->timerMon = false;\r\nA_NETBUF_QUEUE_INIT(&rxtid->q);\r\nA_MUTEX_INIT(&rxtid->lock);\r\n}\r\n}while(false);\r\nA_PRINTF("going out of aggr_init..status %s\n",\r\n(status == 0) ? "OK":"Error");\r\nif (status) {\r\naggr_module_destroy(p_aggr);\r\n}\r\nreturn ((status == 0) ? p_aggr : NULL);\r\n}\r\nstatic void\r\naggr_delete_tid_state(struct aggr_info *p_aggr, u8 tid)\r\n{\r\nstruct rxtid *rxtid;\r\nstruct rxtid_stats *stats;\r\nA_ASSERT(tid < NUM_OF_TIDS && p_aggr);\r\nrxtid = AGGR_GET_RXTID(p_aggr, tid);\r\nstats = AGGR_GET_RXTID_STATS(p_aggr, tid);\r\nif(rxtid->aggr) {\r\naggr_deque_frms(p_aggr, tid, 0, ALL_SEQNO);\r\n}\r\nrxtid->aggr = false;\r\nrxtid->progress = false;\r\nrxtid->timerMon = false;\r\nrxtid->win_sz = 0;\r\nrxtid->seq_next = 0;\r\nrxtid->hold_q_sz = 0;\r\nif(rxtid->hold_q) {\r\nkfree(rxtid->hold_q);\r\nrxtid->hold_q = NULL;\r\n}\r\nA_MEMZERO(stats, sizeof(struct rxtid_stats));\r\n}\r\nvoid\r\naggr_module_destroy(void *cntxt)\r\n{\r\nstruct aggr_info *p_aggr = (struct aggr_info *)cntxt;\r\nstruct rxtid *rxtid;\r\nu8 i, k;\r\nA_PRINTF("%s(): aggr = %p\n",_A_FUNCNAME_, p_aggr);\r\nA_ASSERT(p_aggr);\r\nif(p_aggr) {\r\nif(p_aggr->timerScheduled) {\r\nA_UNTIMEOUT(&p_aggr->timer);\r\np_aggr->timerScheduled = false;\r\n}\r\nfor(i = 0; i < NUM_OF_TIDS; i++) {\r\nrxtid = AGGR_GET_RXTID(p_aggr, i);\r\nif(rxtid->hold_q) {\r\nfor(k = 0; k< rxtid->hold_q_sz; k++) {\r\nif(rxtid->hold_q[k].osbuf) {\r\nA_NETBUF_FREE(rxtid->hold_q[k].osbuf);\r\n}\r\n}\r\nkfree(rxtid->hold_q);\r\n}\r\nwhile(A_NETBUF_QUEUE_SIZE(&rxtid->q)) {\r\nA_NETBUF_FREE(A_NETBUF_DEQUEUE(&rxtid->q));\r\n}\r\nif (A_IS_MUTEX_VALID(&rxtid->lock)) {\r\nA_MUTEX_DELETE(&rxtid->lock);\r\n}\r\n}\r\nwhile(A_NETBUF_QUEUE_SIZE(&p_aggr->freeQ)) {\r\nA_NETBUF_FREE(A_NETBUF_DEQUEUE(&p_aggr->freeQ));\r\n}\r\nkfree(p_aggr);\r\n}\r\nA_PRINTF("out aggr_module_destroy\n");\r\n}\r\nvoid\r\naggr_register_rx_dispatcher(void *cntxt, void * dev, RX_CALLBACK fn)\r\n{\r\nstruct aggr_info *p_aggr = (struct aggr_info *)cntxt;\r\nA_ASSERT(p_aggr && fn && dev);\r\np_aggr->rx_fn = fn;\r\np_aggr->dev = dev;\r\n}\r\nvoid\r\naggr_process_bar(void *cntxt, u8 tid, u16 seq_no)\r\n{\r\nstruct aggr_info *p_aggr = (struct aggr_info *)cntxt;\r\nstruct rxtid_stats *stats;\r\nA_ASSERT(p_aggr);\r\nstats = AGGR_GET_RXTID_STATS(p_aggr, tid);\r\nstats->num_bar++;\r\naggr_deque_frms(p_aggr, tid, seq_no, ALL_SEQNO);\r\n}\r\nvoid\r\naggr_recv_addba_req_evt(void *cntxt, u8 tid, u16 seq_no, u8 win_sz)\r\n{\r\nstruct aggr_info *p_aggr = (struct aggr_info *)cntxt;\r\nstruct rxtid *rxtid;\r\nstruct rxtid_stats *stats;\r\nA_ASSERT(p_aggr);\r\nrxtid = AGGR_GET_RXTID(p_aggr, tid);\r\nstats = AGGR_GET_RXTID_STATS(p_aggr, tid);\r\nA_PRINTF("%s(): win_sz = %d aggr %d\n", _A_FUNCNAME_, win_sz, rxtid->aggr);\r\nif(win_sz < AGGR_WIN_SZ_MIN || win_sz > AGGR_WIN_SZ_MAX) {\r\nA_PRINTF("win_sz %d, tid %d\n", win_sz, tid);\r\n}\r\nif(rxtid->aggr) {\r\naggr_delete_tid_state(p_aggr, tid);\r\n}\r\nrxtid->seq_next = seq_no;\r\nrxtid->hold_q = A_MALLOC(HOLD_Q_SZ(win_sz));\r\nif((rxtid->hold_q == NULL)) {\r\nA_PRINTF("Failed to allocate memory, tid = %d\n", tid);\r\nA_ASSERT(0);\r\n}\r\nA_MEMZERO(rxtid->hold_q, HOLD_Q_SZ(win_sz));\r\nrxtid->win_sz = win_sz;\r\nrxtid->hold_q_sz = TID_WINDOW_SZ(win_sz);\r\nif(A_NETBUF_QUEUE_SIZE(&rxtid->q) != 0) {\r\nA_PRINTF("ERROR: Frames still on queue ?\n");\r\nA_ASSERT(0);\r\n}\r\nrxtid->aggr = true;\r\n}\r\nvoid\r\naggr_recv_delba_req_evt(void *cntxt, u8 tid)\r\n{\r\nstruct aggr_info *p_aggr = (struct aggr_info *)cntxt;\r\nstruct rxtid *rxtid;\r\nA_ASSERT(p_aggr);\r\nA_PRINTF("%s(): tid %d\n", _A_FUNCNAME_, tid);\r\nrxtid = AGGR_GET_RXTID(p_aggr, tid);\r\nif(rxtid->aggr) {\r\naggr_delete_tid_state(p_aggr, tid);\r\n}\r\n}\r\nstatic void\r\naggr_deque_frms(struct aggr_info *p_aggr, u8 tid, u16 seq_no, u8 order)\r\n{\r\nstruct rxtid *rxtid;\r\nstruct osbuf_hold_q *node;\r\nu16 idx, idx_end, seq_end;\r\nstruct rxtid_stats *stats;\r\nA_ASSERT(p_aggr);\r\nrxtid = AGGR_GET_RXTID(p_aggr, tid);\r\nstats = AGGR_GET_RXTID_STATS(p_aggr, tid);\r\nidx = AGGR_WIN_IDX(rxtid->seq_next, rxtid->hold_q_sz);\r\nseq_end = (seq_no) ? seq_no : rxtid->seq_next;\r\nidx_end = AGGR_WIN_IDX(seq_end, rxtid->hold_q_sz);\r\nA_MUTEX_LOCK(&rxtid->lock);\r\ndo {\r\nnode = &rxtid->hold_q[idx];\r\nif((order == CONTIGUOUS_SEQNO) && (!node->osbuf))\r\nbreak;\r\nif(node->osbuf) {\r\nif(node->is_amsdu) {\r\naggr_slice_amsdu(p_aggr, rxtid, &node->osbuf);\r\n} else {\r\nA_NETBUF_ENQUEUE(&rxtid->q, node->osbuf);\r\n}\r\nnode->osbuf = NULL;\r\n} else {\r\nstats->num_hole++;\r\n}\r\nrxtid->seq_next = IEEE80211_NEXT_SEQ_NO(rxtid->seq_next);\r\nidx = AGGR_WIN_IDX(rxtid->seq_next, rxtid->hold_q_sz);\r\n} while(idx != idx_end);\r\nA_MUTEX_UNLOCK(&rxtid->lock);\r\nstats->num_delivered += A_NETBUF_QUEUE_SIZE(&rxtid->q);\r\naggr_dispatch_frames(p_aggr, &rxtid->q);\r\n}\r\nstatic void *\r\naggr_get_osbuf(struct aggr_info *p_aggr)\r\n{\r\nvoid *buf = NULL;\r\nif (A_NETBUF_QUEUE_SIZE(&p_aggr->freeQ) < (AGGR_NUM_OF_FREE_NETBUFS >> 2)) {\r\np_aggr->netbuf_allocator(&p_aggr->freeQ, AGGR_NUM_OF_FREE_NETBUFS);\r\n}\r\nif (A_NETBUF_QUEUE_SIZE(&p_aggr->freeQ)) {\r\nbuf = A_NETBUF_DEQUEUE(&p_aggr->freeQ);\r\n}\r\nreturn buf;\r\n}\r\nstatic void\r\naggr_slice_amsdu(struct aggr_info *p_aggr, struct rxtid *rxtid, void **osbuf)\r\n{\r\nvoid *new_buf;\r\nu16 frame_8023_len, payload_8023_len, mac_hdr_len, amsdu_len;\r\nu8 *framep;\r\nmac_hdr_len = sizeof(ATH_MAC_HDR);\r\nframep = A_NETBUF_DATA(*osbuf) + mac_hdr_len;\r\namsdu_len = A_NETBUF_LEN(*osbuf) - mac_hdr_len;\r\nwhile(amsdu_len > mac_hdr_len) {\r\npayload_8023_len = A_BE2CPU16(((ATH_MAC_HDR *)framep)->typeOrLen);\r\n#define MAX_MSDU_SUBFRAME_PAYLOAD_LEN 1508\r\n#define MIN_MSDU_SUBFRAME_PAYLOAD_LEN 46\r\nif(payload_8023_len < MIN_MSDU_SUBFRAME_PAYLOAD_LEN || payload_8023_len > MAX_MSDU_SUBFRAME_PAYLOAD_LEN) {\r\nA_PRINTF("802.3 AMSDU frame bound check failed. len %d\n", payload_8023_len);\r\nbreak;\r\n}\r\nframe_8023_len = payload_8023_len + mac_hdr_len;\r\nnew_buf = aggr_get_osbuf(p_aggr);\r\nif(new_buf == NULL) {\r\nA_PRINTF("No buffer available \n");\r\nbreak;\r\n}\r\nmemcpy(A_NETBUF_DATA(new_buf), framep, frame_8023_len);\r\nA_NETBUF_PUT(new_buf, frame_8023_len);\r\nif (wmi_dot3_2_dix(new_buf) != 0) {\r\nA_PRINTF("dot3_2_dix err..\n");\r\nA_NETBUF_FREE(new_buf);\r\nbreak;\r\n}\r\nA_NETBUF_ENQUEUE(&rxtid->q, new_buf);\r\nif ((amsdu_len - frame_8023_len) == 0) {\r\nbreak;\r\n}\r\nframe_8023_len = ((frame_8023_len + 3) & ~3);\r\nframep += frame_8023_len;\r\namsdu_len -= frame_8023_len;\r\n}\r\nA_NETBUF_FREE(*osbuf);\r\n*osbuf = NULL;\r\n}\r\nvoid\r\naggr_process_recv_frm(void *cntxt, u8 tid, u16 seq_no, bool is_amsdu, void **osbuf)\r\n{\r\nstruct aggr_info *p_aggr = (struct aggr_info *)cntxt;\r\nstruct rxtid *rxtid;\r\nstruct rxtid_stats *stats;\r\nu16 idx, st, cur, end;\r\nu16 *log_idx;\r\nstruct osbuf_hold_q *node;\r\nPACKET_LOG *log;\r\nA_ASSERT(p_aggr);\r\nA_ASSERT(tid < NUM_OF_TIDS);\r\nrxtid = AGGR_GET_RXTID(p_aggr, tid);\r\nstats = AGGR_GET_RXTID_STATS(p_aggr, tid);\r\nstats->num_into_aggr++;\r\nif(!rxtid->aggr) {\r\nif(is_amsdu) {\r\naggr_slice_amsdu(p_aggr, rxtid, osbuf);\r\nstats->num_amsdu++;\r\naggr_dispatch_frames(p_aggr, &rxtid->q);\r\n}\r\nreturn;\r\n}\r\nst = rxtid->seq_next;\r\ncur = seq_no;\r\nend = (st + rxtid->hold_q_sz-1) & IEEE80211_MAX_SEQ_NO;\r\nlog = &p_aggr->pkt_log;\r\nlog_idx = &log->last_idx;\r\nlog->info[*log_idx].cur = cur;\r\nlog->info[*log_idx].st = st;\r\nlog->info[*log_idx].end = end;\r\n*log_idx = IEEE80211_NEXT_SEQ_NO(*log_idx);\r\nif(((st < end) && (cur < st || cur > end)) ||\r\n((st > end) && (cur > end) && (cur < st))) {\r\nu16 extended_end;\r\nextended_end = (end + rxtid->hold_q_sz-1) & IEEE80211_MAX_SEQ_NO;\r\nif(((end < extended_end) && (cur < end || cur > extended_end)) ||\r\n((end > extended_end) && (cur > extended_end) && (cur < end))) {\r\naggr_deque_frms(p_aggr, tid, 0, ALL_SEQNO);\r\nif(cur >= rxtid->hold_q_sz-1) {\r\nrxtid->seq_next = cur - (rxtid->hold_q_sz-1);\r\n}else{\r\nrxtid->seq_next = IEEE80211_MAX_SEQ_NO - (rxtid->hold_q_sz-2 - cur);\r\n}\r\n} else {\r\nif(cur >= rxtid->hold_q_sz-1) {\r\nst = cur - (rxtid->hold_q_sz-1);\r\n}else{\r\nst = IEEE80211_MAX_SEQ_NO - (rxtid->hold_q_sz-2 - cur);\r\n}\r\naggr_deque_frms(p_aggr, tid, st, ALL_SEQNO);\r\n}\r\nstats->num_oow++;\r\n}\r\nidx = AGGR_WIN_IDX(seq_no, rxtid->hold_q_sz);\r\nnode = &rxtid->hold_q[idx];\r\nA_MUTEX_LOCK(&rxtid->lock);\r\nif(node->osbuf) {\r\nA_NETBUF_FREE(node->osbuf);\r\nstats->num_dups++;\r\n}\r\nnode->osbuf = *osbuf;\r\nnode->is_amsdu = is_amsdu;\r\nnode->seq_no = seq_no;\r\nif(node->is_amsdu) {\r\nstats->num_amsdu++;\r\n} else {\r\nstats->num_mpdu++;\r\n}\r\nA_MUTEX_UNLOCK(&rxtid->lock);\r\n*osbuf = NULL;\r\naggr_deque_frms(p_aggr, tid, 0, CONTIGUOUS_SEQNO);\r\nif(p_aggr->timerScheduled) {\r\nrxtid->progress = true;\r\n}else{\r\nfor(idx=0 ; idx<rxtid->hold_q_sz ; idx++) {\r\nif(rxtid->hold_q[idx].osbuf) {\r\np_aggr->timerScheduled = true;\r\nA_TIMEOUT_MS(&p_aggr->timer, AGGR_RX_TIMEOUT, 0);\r\nrxtid->progress = false;\r\nrxtid->timerMon = true;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\naggr_reset_state(void *cntxt)\r\n{\r\nu8 tid;\r\nstruct aggr_info *p_aggr = (struct aggr_info *)cntxt;\r\nA_ASSERT(p_aggr);\r\nfor(tid=0 ; tid<NUM_OF_TIDS ; tid++) {\r\naggr_delete_tid_state(p_aggr, tid);\r\n}\r\n}\r\nstatic void\r\naggr_timeout(unsigned long arg)\r\n{\r\nu8 i,j;\r\nstruct aggr_info *p_aggr = (struct aggr_info *)arg;\r\nstruct rxtid *rxtid;\r\nstruct rxtid_stats *stats;\r\nfor(i = 0; i < NUM_OF_TIDS; i++) {\r\nrxtid = AGGR_GET_RXTID(p_aggr, i);\r\nstats = AGGR_GET_RXTID_STATS(p_aggr, i);\r\nif(rxtid->aggr == false ||\r\nrxtid->timerMon == false ||\r\nrxtid->progress == true) {\r\ncontinue;\r\n}\r\nstats->num_timeouts++;\r\nA_PRINTF("TO: st %d end %d\n", rxtid->seq_next, ((rxtid->seq_next + rxtid->hold_q_sz-1) & IEEE80211_MAX_SEQ_NO));\r\naggr_deque_frms(p_aggr, i, 0, ALL_SEQNO);\r\n}\r\np_aggr->timerScheduled = false;\r\nfor(i = 0; i < NUM_OF_TIDS; i++) {\r\nrxtid = AGGR_GET_RXTID(p_aggr, i);\r\nif(rxtid->aggr == true && rxtid->hold_q) {\r\nfor(j = 0 ; j < rxtid->hold_q_sz ; j++)\r\n{\r\nif(rxtid->hold_q[j].osbuf)\r\n{\r\np_aggr->timerScheduled = true;\r\nrxtid->timerMon = true;\r\nrxtid->progress = false;\r\nbreak;\r\n}\r\n}\r\nif(j >= rxtid->hold_q_sz) {\r\nrxtid->timerMon = false;\r\n}\r\n}\r\n}\r\nif(p_aggr->timerScheduled) {\r\nA_TIMEOUT_MS(&p_aggr->timer, AGGR_RX_TIMEOUT, 0);\r\n}\r\n}\r\nstatic void\r\naggr_dispatch_frames(struct aggr_info *p_aggr, A_NETBUF_QUEUE_T *q)\r\n{\r\nvoid *osbuf;\r\nwhile((osbuf = A_NETBUF_DEQUEUE(q))) {\r\np_aggr->rx_fn(p_aggr->dev, osbuf);\r\n}\r\n}\r\nvoid\r\naggr_dump_stats(void *cntxt, PACKET_LOG **log_buf)\r\n{\r\nstruct aggr_info *p_aggr = (struct aggr_info *)cntxt;\r\nstruct rxtid *rxtid;\r\nstruct rxtid_stats *stats;\r\nu8 i;\r\n*log_buf = &p_aggr->pkt_log;\r\nA_PRINTF("\n\n================================================\n");\r\nA_PRINTF("tid: num_into_aggr, dups, oow, mpdu, amsdu, delivered, timeouts, holes, bar, seq_next\n");\r\nfor(i = 0; i < NUM_OF_TIDS; i++) {\r\nstats = AGGR_GET_RXTID_STATS(p_aggr, i);\r\nrxtid = AGGR_GET_RXTID(p_aggr, i);\r\nA_PRINTF("%d: %d %d %d %d %d %d %d %d %d : %d\n", i, stats->num_into_aggr, stats->num_dups,\r\nstats->num_oow, stats->num_mpdu,\r\nstats->num_amsdu, stats->num_delivered, stats->num_timeouts,\r\nstats->num_hole, stats->num_bar,\r\nrxtid->seq_next);\r\n}\r\nA_PRINTF("================================================\n\n");\r\n}
