static inline struct tvp7002 *to_tvp7002(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct tvp7002, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct tvp7002, hdl)->sd;\r\n}\r\nstatic int tvp7002_read(struct v4l2_subdev *sd, u8 addr, u8 *dst)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nint retry;\r\nint error;\r\nfor (retry = 0; retry < I2C_RETRY_COUNT; retry++) {\r\nerror = i2c_smbus_read_byte_data(c, addr);\r\nif (error >= 0) {\r\n*dst = (u8)error;\r\nreturn 0;\r\n}\r\nmsleep_interruptible(10);\r\n}\r\nv4l2_err(sd, "TVP7002 read error %d\n", error);\r\nreturn error;\r\n}\r\nstatic inline void tvp7002_read_err(struct v4l2_subdev *sd, u8 reg,\r\nu8 *dst, int *err)\r\n{\r\nif (!*err)\r\n*err = tvp7002_read(sd, reg, dst);\r\n}\r\nstatic int tvp7002_write(struct v4l2_subdev *sd, u8 addr, u8 value)\r\n{\r\nstruct i2c_client *c;\r\nint retry;\r\nint error;\r\nc = v4l2_get_subdevdata(sd);\r\nfor (retry = 0; retry < I2C_RETRY_COUNT; retry++) {\r\nerror = i2c_smbus_write_byte_data(c, addr, value);\r\nif (error >= 0)\r\nreturn 0;\r\nv4l2_warn(sd, "Write: retry ... %d\n", retry);\r\nmsleep_interruptible(10);\r\n}\r\nv4l2_err(sd, "TVP7002 write error %d\n", error);\r\nreturn error;\r\n}\r\nstatic inline void tvp7002_write_err(struct v4l2_subdev *sd, u8 reg,\r\nu8 val, int *err)\r\n{\r\nif (!*err)\r\n*err = tvp7002_write(sd, reg, val);\r\n}\r\nstatic int tvp7002_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nu8 rev;\r\nint error;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nerror = tvp7002_read(sd, TVP7002_CHIP_REV, &rev);\r\nif (error < 0)\r\nreturn error;\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_TVP7002, rev);\r\n}\r\nstatic int tvp7002_write_inittab(struct v4l2_subdev *sd,\r\nconst struct i2c_reg_value *regs)\r\n{\r\nint error = 0;\r\nwhile (TVP7002_EOR != regs->reg) {\r\nif (TVP7002_WRITE == regs->type)\r\ntvp7002_write_err(sd, regs->reg, regs->value, &error);\r\nregs++;\r\n}\r\nreturn error;\r\n}\r\nstatic int tvp7002_s_dv_preset(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_preset *dv_preset)\r\n{\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nu32 preset;\r\nint i;\r\nfor (i = 0; i < NUM_PRESETS; i++) {\r\npreset = tvp7002_presets[i].preset;\r\nif (preset == dv_preset->preset) {\r\ndevice->current_preset = &tvp7002_presets[i];\r\nreturn tvp7002_write_inittab(sd, tvp7002_presets[i].p_settings);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tvp7002_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nint error = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\ntvp7002_write_err(sd, TVP7002_R_FINE_GAIN, ctrl->val, &error);\r\ntvp7002_write_err(sd, TVP7002_G_FINE_GAIN, ctrl->val, &error);\r\ntvp7002_write_err(sd, TVP7002_B_FINE_GAIN, ctrl->val, &error);\r\nreturn error;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tvp7002_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)\r\n{\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nstruct v4l2_dv_enum_preset e_preset;\r\nint error;\r\nerror = v4l_fill_dv_preset_info(device->current_preset->preset, &e_preset);\r\nif (error)\r\nreturn error;\r\nf->width = e_preset.width;\r\nf->height = e_preset.height;\r\nf->code = V4L2_MBUS_FMT_YUYV10_1X20;\r\nf->field = device->current_preset->scanmode;\r\nf->colorspace = device->current_preset->color_space;\r\nv4l2_dbg(1, debug, sd, "MBUS_FMT: Width - %d, Height - %d",\r\nf->width, f->height);\r\nreturn 0;\r\n}\r\nstatic int tvp7002_query_dv_preset(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_preset *qpreset)\r\n{\r\nconst struct tvp7002_preset_definition *presets = tvp7002_presets;\r\nstruct tvp7002 *device;\r\nu8 progressive;\r\nu32 lpfr;\r\nu32 cpln;\r\nint error = 0;\r\nu8 lpf_lsb;\r\nu8 lpf_msb;\r\nu8 cpl_lsb;\r\nu8 cpl_msb;\r\nint index;\r\ndevice = to_tvp7002(sd);\r\ntvp7002_read_err(sd, TVP7002_L_FRAME_STAT_LSBS, &lpf_lsb, &error);\r\ntvp7002_read_err(sd, TVP7002_L_FRAME_STAT_MSBS, &lpf_msb, &error);\r\nif (error < 0)\r\nreturn error;\r\ntvp7002_read_err(sd, TVP7002_CLK_L_STAT_LSBS, &cpl_lsb, &error);\r\ntvp7002_read_err(sd, TVP7002_CLK_L_STAT_MSBS, &cpl_msb, &error);\r\nif (error < 0)\r\nreturn error;\r\nlpfr = lpf_lsb | ((TVP7002_CL_MASK & lpf_msb) << TVP7002_CL_SHIFT);\r\ncpln = cpl_lsb | ((TVP7002_CL_MASK & cpl_msb) << TVP7002_CL_SHIFT);\r\nprogressive = (lpf_msb & TVP7002_INPR_MASK) >> TVP7002_IP_SHIFT;\r\nfor (index = 0; index < NUM_PRESETS; index++, presets++)\r\nif (lpfr == presets->lines_per_frame &&\r\nprogressive == presets->progressive) {\r\nif (presets->cpl_min == 0xffff)\r\nbreak;\r\nif (cpln >= presets->cpl_min && cpln <= presets->cpl_max)\r\nbreak;\r\n}\r\nif (index == NUM_PRESETS) {\r\nv4l2_dbg(1, debug, sd, "detection failed: lpf = %x, cpl = %x\n",\r\nlpfr, cpln);\r\nqpreset->preset = V4L2_DV_INVALID;\r\nreturn 0;\r\n}\r\nqpreset->preset = presets->preset;\r\nv4l2_dbg(1, debug, sd, "detected preset: %d\n", presets->preset);\r\nreturn 0;\r\n}\r\nstatic int tvp7002_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 val;\r\nint ret;\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nret = tvp7002_read(sd, reg->reg & 0xff, &val);\r\nreg->val = val;\r\nreturn ret;\r\n}\r\nstatic int tvp7002_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn tvp7002_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\n}\r\nstatic int tvp7002_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index)\r\nreturn -EINVAL;\r\n*code = V4L2_MBUS_FMT_YUYV10_1X20;\r\nreturn 0;\r\n}\r\nstatic int tvp7002_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nint error = 0;\r\nif (device->streaming == enable)\r\nreturn 0;\r\nif (enable) {\r\nerror = tvp7002_write(sd, TVP7002_MISC_CTL_2, 0x00);\r\ndevice->streaming = enable;\r\n} else {\r\nerror = tvp7002_write(sd, TVP7002_MISC_CTL_2, 0x03);\r\nif (error)\r\nv4l2_dbg(1, debug, sd, "Unable to stop streaming\n");\r\ndevice->streaming = enable;\r\n}\r\nreturn error;\r\n}\r\nstatic int tvp7002_log_status(struct v4l2_subdev *sd)\r\n{\r\nconst struct tvp7002_preset_definition *presets = tvp7002_presets;\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nstruct v4l2_dv_enum_preset e_preset;\r\nstruct v4l2_dv_preset detected;\r\nint i;\r\ndetected.preset = V4L2_DV_INVALID;\r\ntvp7002_query_dv_preset(sd, &detected);\r\nfor (i = 0; i < NUM_PRESETS; i++, presets++)\r\nif (presets->preset == detected.preset)\r\nbreak;\r\nif (v4l_fill_dv_preset_info(device->current_preset->preset, &e_preset))\r\nreturn -EINVAL;\r\nv4l2_info(sd, "Selected DV Preset: %s\n", e_preset.name);\r\nv4l2_info(sd, " Pixels per line: %u\n", e_preset.width);\r\nv4l2_info(sd, " Lines per frame: %u\n\n", e_preset.height);\r\nif (i == NUM_PRESETS) {\r\nv4l2_info(sd, "Detected DV Preset: None\n");\r\n} else {\r\nif (v4l_fill_dv_preset_info(presets->preset, &e_preset))\r\nreturn -EINVAL;\r\nv4l2_info(sd, "Detected DV Preset: %s\n", e_preset.name);\r\nv4l2_info(sd, " Pixels per line: %u\n", e_preset.width);\r\nv4l2_info(sd, " Lines per frame: %u\n\n", e_preset.height);\r\n}\r\nv4l2_info(sd, "Streaming enabled: %s\n",\r\ndevice->streaming ? "yes" : "no");\r\nv4l2_ctrl_handler_log_status(&device->hdl, sd->name);\r\nreturn 0;\r\n}\r\nstatic int tvp7002_enum_dv_presets(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_enum_preset *preset)\r\n{\r\nif (preset->index >= NUM_PRESETS)\r\nreturn -EINVAL;\r\nreturn v4l_fill_dv_preset_info(tvp7002_presets[preset->index].preset, preset);\r\n}\r\nstatic int tvp7002_probe(struct i2c_client *c, const struct i2c_device_id *id)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct tvp7002 *device;\r\nstruct v4l2_dv_preset preset;\r\nint polarity_a;\r\nint polarity_b;\r\nu8 revision;\r\nint error;\r\nif (!i2c_check_functionality(c->adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -EIO;\r\nif (!c->dev.platform_data) {\r\nv4l_err(c, "No platform data!!\n");\r\nreturn -ENODEV;\r\n}\r\ndevice = kzalloc(sizeof(struct tvp7002), GFP_KERNEL);\r\nif (!device)\r\nreturn -ENOMEM;\r\nsd = &device->sd;\r\ndevice->pdata = c->dev.platform_data;\r\ndevice->current_preset = tvp7002_presets;\r\nv4l2_i2c_subdev_init(sd, c, &tvp7002_ops);\r\nv4l_info(c, "tvp7002 found @ 0x%02x (%s)\n",\r\nc->addr, c->adapter->name);\r\nerror = tvp7002_read(sd, TVP7002_CHIP_REV, &revision);\r\nif (error < 0)\r\ngoto found_error;\r\nv4l2_info(sd, "Rev. %02x detected.\n", revision);\r\nif (revision != 0x02)\r\nv4l2_info(sd, "Unknown revision detected.\n");\r\nerror = tvp7002_write_inittab(sd, tvp7002_init_default);\r\nif (error < 0)\r\ngoto found_error;\r\npolarity_a = 0x20 | device->pdata->hs_polarity << 5\r\n| device->pdata->vs_polarity << 2;\r\nerror = tvp7002_write(sd, TVP7002_SYNC_CTL_1, polarity_a);\r\nif (error < 0)\r\ngoto found_error;\r\npolarity_b = 0x01 | device->pdata->fid_polarity << 2\r\n| device->pdata->sog_polarity << 1\r\n| device->pdata->clk_polarity;\r\nerror = tvp7002_write(sd, TVP7002_MISC_CTL_3, polarity_b);\r\nif (error < 0)\r\ngoto found_error;\r\npreset.preset = device->current_preset->preset;\r\nerror = tvp7002_s_dv_preset(sd, &preset);\r\nv4l2_ctrl_handler_init(&device->hdl, 1);\r\nv4l2_ctrl_new_std(&device->hdl, &tvp7002_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 0);\r\nsd->ctrl_handler = &device->hdl;\r\nif (device->hdl.error) {\r\nint err = device->hdl.error;\r\nv4l2_ctrl_handler_free(&device->hdl);\r\nkfree(device);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&device->hdl);\r\nfound_error:\r\nif (error < 0)\r\nkfree(device);\r\nreturn error;\r\n}\r\nstatic int tvp7002_remove(struct i2c_client *c)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(c);\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nv4l2_dbg(1, debug, sd, "Removing tvp7002 adapter"\r\n"on address 0x%x\n", c->addr);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&device->hdl);\r\nkfree(device);\r\nreturn 0;\r\n}\r\nstatic int __init tvp7002_init(void)\r\n{\r\nreturn i2c_add_driver(&tvp7002_driver);\r\n}\r\nstatic void __exit tvp7002_exit(void)\r\n{\r\ni2c_del_driver(&tvp7002_driver);\r\n}
