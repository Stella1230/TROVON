static inline __u16 get_reg_index(enum mos_regs reg)\r\n{\r\nstatic const __u16 mos7715_index_lookup_table[] = {\r\n0x00,\r\n0x00,\r\n0x01,\r\n0x02,\r\n0x02,\r\n0x03,\r\n0x04,\r\n0x05,\r\n0x06,\r\n0x07,\r\n0x00,\r\n0x01,\r\n0x00,\r\n0x01,\r\n0x02,\r\n0x0a,\r\n0x01,\r\n0x02,\r\n0x04,\r\n0x08,\r\n};\r\nreturn mos7715_index_lookup_table[reg];\r\n}\r\nstatic inline __u16 get_reg_value(enum mos_regs reg,\r\nunsigned int serial_portnum)\r\n{\r\nif (reg >= SP1_REG)\r\nreturn 0x0000;\r\nelse if (reg >= DPR)\r\nreturn 0x0100;\r\nelse\r\nreturn (serial_portnum + 2) << 8;\r\n}\r\nstatic int write_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,\r\nenum mos_regs reg, __u8 data)\r\n{\r\nstruct usb_device *usbdev = serial->dev;\r\nunsigned int pipe = usb_sndctrlpipe(usbdev, 0);\r\n__u8 request = (__u8)0x0e;\r\n__u8 requesttype = (__u8)0x40;\r\n__u16 index = get_reg_index(reg);\r\n__u16 value = get_reg_value(reg, serial_portnum) + data;\r\nint status = usb_control_msg(usbdev, pipe, request, requesttype, value,\r\nindex, NULL, 0, MOS_WDR_TIMEOUT);\r\nif (status < 0)\r\ndev_err(&usbdev->dev,\r\n"mos7720: usb_control_msg() failed: %d", status);\r\nreturn status;\r\n}\r\nstatic int read_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,\r\nenum mos_regs reg, __u8 *data)\r\n{\r\nstruct usb_device *usbdev = serial->dev;\r\nunsigned int pipe = usb_rcvctrlpipe(usbdev, 0);\r\n__u8 request = (__u8)0x0d;\r\n__u8 requesttype = (__u8)0xc0;\r\n__u16 index = get_reg_index(reg);\r\n__u16 value = get_reg_value(reg, serial_portnum);\r\nint status = usb_control_msg(usbdev, pipe, request, requesttype, value,\r\nindex, data, 1, MOS_WDR_TIMEOUT);\r\nif (status < 0)\r\ndev_err(&usbdev->dev,\r\n"mos7720: usb_control_msg() failed: %d", status);\r\nreturn status;\r\n}\r\nstatic inline int mos7715_change_mode(struct mos7715_parport *mos_parport,\r\nenum mos7715_pp_modes mode)\r\n{\r\nmos_parport->shadowECR = mode;\r\nwrite_mos_reg(mos_parport->serial, dummy, ECR, mos_parport->shadowECR);\r\nreturn 0;\r\n}\r\nstatic void destroy_mos_parport(struct kref *kref)\r\n{\r\nstruct mos7715_parport *mos_parport =\r\ncontainer_of(kref, struct mos7715_parport, ref_count);\r\ndbg("%s called", __func__);\r\nkfree(mos_parport);\r\n}\r\nstatic void destroy_urbtracker(struct kref *kref)\r\n{\r\nstruct urbtracker *urbtrack =\r\ncontainer_of(kref, struct urbtracker, ref_count);\r\nstruct mos7715_parport *mos_parport = urbtrack->mos_parport;\r\ndbg("%s called", __func__);\r\nusb_free_urb(urbtrack->urb);\r\nkfree(urbtrack);\r\nkref_put(&mos_parport->ref_count, destroy_mos_parport);\r\n}\r\nstatic void send_deferred_urbs(unsigned long _mos_parport)\r\n{\r\nint ret_val;\r\nunsigned long flags;\r\nstruct mos7715_parport *mos_parport = (void *)_mos_parport;\r\nstruct urbtracker *urbtrack;\r\nstruct list_head *cursor, *next;\r\ndbg("%s called", __func__);\r\nif (unlikely(mos_parport->serial == NULL))\r\nreturn;\r\nif (!mutex_trylock(&mos_parport->serial->disc_mutex)) {\r\ndbg("%s: rescheduling tasklet", __func__);\r\ntasklet_schedule(&mos_parport->urb_tasklet);\r\nreturn;\r\n}\r\nif (unlikely(mos_parport->serial->disconnected)) {\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nif (list_empty(&mos_parport->deferred_urbs)) {\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\ndbg("%s: deferred_urbs list empty", __func__);\r\nreturn;\r\n}\r\nlist_for_each_safe(cursor, next, &mos_parport->deferred_urbs)\r\nlist_move_tail(cursor, &mos_parport->active_urbs);\r\nlist_for_each_entry(urbtrack, &mos_parport->active_urbs,\r\nurblist_entry) {\r\nret_val = usb_submit_urb(urbtrack->urb, GFP_ATOMIC);\r\ndbg("%s: urb submitted", __func__);\r\nif (ret_val) {\r\ndev_err(&mos_parport->serial->dev->dev,\r\n"usb_submit_urb() failed: %d", ret_val);\r\nlist_del(&urbtrack->urblist_entry);\r\nkref_put(&urbtrack->ref_count, destroy_urbtracker);\r\n}\r\n}\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\n}\r\nstatic void async_complete(struct urb *urb)\r\n{\r\nstruct urbtracker *urbtrack = urb->context;\r\nint status = urb->status;\r\ndbg("%s called", __func__);\r\nif (unlikely(status))\r\ndbg("%s - nonzero urb status received: %d", __func__, status);\r\nspin_lock(&urbtrack->mos_parport->listlock);\r\nlist_del(&urbtrack->urblist_entry);\r\nspin_unlock(&urbtrack->mos_parport->listlock);\r\nkref_put(&urbtrack->ref_count, destroy_urbtracker);\r\n}\r\nstatic int write_parport_reg_nonblock(struct mos7715_parport *mos_parport,\r\nenum mos_regs reg, __u8 data)\r\n{\r\nstruct urbtracker *urbtrack;\r\nint ret_val;\r\nunsigned long flags;\r\nstruct usb_ctrlrequest setup;\r\nstruct usb_serial *serial = mos_parport->serial;\r\nstruct usb_device *usbdev = serial->dev;\r\ndbg("%s called", __func__);\r\nurbtrack = kmalloc(sizeof(struct urbtracker), GFP_ATOMIC);\r\nif (urbtrack == NULL) {\r\ndev_err(&usbdev->dev, "out of memory");\r\nreturn -ENOMEM;\r\n}\r\nkref_get(&mos_parport->ref_count);\r\nurbtrack->mos_parport = mos_parport;\r\nurbtrack->urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (urbtrack->urb == NULL) {\r\ndev_err(&usbdev->dev, "out of urbs");\r\nkfree(urbtrack);\r\nreturn -ENOMEM;\r\n}\r\nsetup.bRequestType = (__u8)0x40;\r\nsetup.bRequest = (__u8)0x0e;\r\nsetup.wValue = get_reg_value(reg, dummy);\r\nsetup.wIndex = get_reg_index(reg);\r\nsetup.wLength = 0;\r\nusb_fill_control_urb(urbtrack->urb, usbdev,\r\nusb_sndctrlpipe(usbdev, 0),\r\n(unsigned char *)&setup,\r\nNULL, 0, async_complete, urbtrack);\r\nkref_init(&urbtrack->ref_count);\r\nINIT_LIST_HEAD(&urbtrack->urblist_entry);\r\nif (!mutex_trylock(&serial->disc_mutex)) {\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nlist_add_tail(&urbtrack->urblist_entry,\r\n&mos_parport->deferred_urbs);\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\ntasklet_schedule(&mos_parport->urb_tasklet);\r\ndbg("tasklet scheduled");\r\nreturn 0;\r\n}\r\nif (serial->disconnected) {\r\nkref_put(&urbtrack->ref_count, destroy_urbtracker);\r\nmutex_unlock(&serial->disc_mutex);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nlist_add_tail(&urbtrack->urblist_entry, &mos_parport->active_urbs);\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nret_val = usb_submit_urb(urbtrack->urb, GFP_ATOMIC);\r\nmutex_unlock(&serial->disc_mutex);\r\nif (ret_val) {\r\ndev_err(&usbdev->dev,\r\n"%s: submit_urb() failed: %d", __func__, ret_val);\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nlist_del(&urbtrack->urblist_entry);\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nkref_put(&urbtrack->ref_count, destroy_urbtracker);\r\nreturn ret_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parport_prologue(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport;\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn -1;\r\n}\r\nmos_parport->msg_pending = true;\r\nINIT_COMPLETION(mos_parport->syncmsg_compl);\r\nspin_unlock(&release_lock);\r\nmutex_lock(&mos_parport->serial->disc_mutex);\r\nif (mos_parport->serial->disconnected) {\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\nmos_parport->msg_pending = false;\r\ncomplete(&mos_parport->syncmsg_compl);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void parport_epilogue(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nmutex_unlock(&mos_parport->serial->disc_mutex);\r\nmos_parport->msg_pending = false;\r\ncomplete(&mos_parport->syncmsg_compl);\r\n}\r\nstatic void parport_mos7715_write_data(struct parport *pp, unsigned char d)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\ndbg("%s called: %2.2x", __func__, d);\r\nif (parport_prologue(pp) < 0)\r\nreturn;\r\nmos7715_change_mode(mos_parport, SPP);\r\nwrite_mos_reg(mos_parport->serial, dummy, DPR, (__u8)d);\r\nparport_epilogue(pp);\r\n}\r\nstatic unsigned char parport_mos7715_read_data(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nunsigned char d;\r\ndbg("%s called", __func__);\r\nif (parport_prologue(pp) < 0)\r\nreturn 0;\r\nread_mos_reg(mos_parport->serial, dummy, DPR, &d);\r\nparport_epilogue(pp);\r\nreturn d;\r\n}\r\nstatic void parport_mos7715_write_control(struct parport *pp, unsigned char d)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\n__u8 data;\r\ndbg("%s called: %2.2x", __func__, d);\r\nif (parport_prologue(pp) < 0)\r\nreturn;\r\ndata = ((__u8)d & 0x0f) | (mos_parport->shadowDCR & 0xf0);\r\nwrite_mos_reg(mos_parport->serial, dummy, DCR, data);\r\nmos_parport->shadowDCR = data;\r\nparport_epilogue(pp);\r\n}\r\nstatic unsigned char parport_mos7715_read_control(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\n__u8 dcr;\r\ndbg("%s called", __func__);\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn 0;\r\n}\r\ndcr = mos_parport->shadowDCR & 0x0f;\r\nspin_unlock(&release_lock);\r\nreturn dcr;\r\n}\r\nstatic unsigned char parport_mos7715_frob_control(struct parport *pp,\r\nunsigned char mask,\r\nunsigned char val)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\n__u8 dcr;\r\ndbg("%s called", __func__);\r\nmask &= 0x0f;\r\nval &= 0x0f;\r\nif (parport_prologue(pp) < 0)\r\nreturn 0;\r\nmos_parport->shadowDCR = (mos_parport->shadowDCR & (~mask)) ^ val;\r\nwrite_mos_reg(mos_parport->serial, dummy, DCR, mos_parport->shadowDCR);\r\ndcr = mos_parport->shadowDCR & 0x0f;\r\nparport_epilogue(pp);\r\nreturn dcr;\r\n}\r\nstatic unsigned char parport_mos7715_read_status(struct parport *pp)\r\n{\r\nunsigned char status;\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\ndbg("%s called", __func__);\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn 0;\r\n}\r\nstatus = atomic_read(&mos_parport->shadowDSR) & 0xf8;\r\nspin_unlock(&release_lock);\r\nreturn status;\r\n}\r\nstatic void parport_mos7715_enable_irq(struct parport *pp)\r\n{\r\ndbg("%s called", __func__);\r\n}\r\nstatic void parport_mos7715_disable_irq(struct parport *pp)\r\n{\r\ndbg("%s called", __func__);\r\n}\r\nstatic void parport_mos7715_data_forward(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\ndbg("%s called", __func__);\r\nif (parport_prologue(pp) < 0)\r\nreturn;\r\nmos7715_change_mode(mos_parport, PS2);\r\nmos_parport->shadowDCR &= ~0x20;\r\nwrite_mos_reg(mos_parport->serial, dummy, DCR, mos_parport->shadowDCR);\r\nparport_epilogue(pp);\r\n}\r\nstatic void parport_mos7715_data_reverse(struct parport *pp)\r\n{\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\ndbg("%s called", __func__);\r\nif (parport_prologue(pp) < 0)\r\nreturn;\r\nmos7715_change_mode(mos_parport, PS2);\r\nmos_parport->shadowDCR |= 0x20;\r\nwrite_mos_reg(mos_parport->serial, dummy, DCR, mos_parport->shadowDCR);\r\nparport_epilogue(pp);\r\n}\r\nstatic void parport_mos7715_init_state(struct pardevice *dev,\r\nstruct parport_state *s)\r\n{\r\ndbg("%s called", __func__);\r\ns->u.pc.ctr = DCR_INIT_VAL;\r\ns->u.pc.ecr = ECR_INIT_VAL;\r\n}\r\nstatic void parport_mos7715_save_state(struct parport *pp,\r\nstruct parport_state *s)\r\n{\r\nstruct mos7715_parport *mos_parport;\r\ndbg("%s called", __func__);\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn;\r\n}\r\ns->u.pc.ctr = mos_parport->shadowDCR;\r\ns->u.pc.ecr = mos_parport->shadowECR;\r\nspin_unlock(&release_lock);\r\n}\r\nstatic void parport_mos7715_restore_state(struct parport *pp,\r\nstruct parport_state *s)\r\n{\r\nstruct mos7715_parport *mos_parport;\r\ndbg("%s called", __func__);\r\nspin_lock(&release_lock);\r\nmos_parport = pp->private_data;\r\nif (unlikely(mos_parport == NULL)) {\r\nspin_unlock(&release_lock);\r\nreturn;\r\n}\r\nwrite_parport_reg_nonblock(mos_parport, DCR, mos_parport->shadowDCR);\r\nwrite_parport_reg_nonblock(mos_parport, ECR, mos_parport->shadowECR);\r\nspin_unlock(&release_lock);\r\n}\r\nstatic size_t parport_mos7715_write_compat(struct parport *pp,\r\nconst void *buffer,\r\nsize_t len, int flags)\r\n{\r\nint retval;\r\nstruct mos7715_parport *mos_parport = pp->private_data;\r\nint actual_len;\r\ndbg("%s called: %u chars", __func__, (unsigned int)len);\r\nif (parport_prologue(pp) < 0)\r\nreturn 0;\r\nmos7715_change_mode(mos_parport, PPF);\r\nretval = usb_bulk_msg(mos_parport->serial->dev,\r\nusb_sndbulkpipe(mos_parport->serial->dev, 2),\r\n(void *)buffer, len, &actual_len,\r\nMOS_WDR_TIMEOUT);\r\nparport_epilogue(pp);\r\nif (retval) {\r\ndev_err(&mos_parport->serial->dev->dev,\r\n"mos7720: usb_bulk_msg() failed: %d", retval);\r\nreturn 0;\r\n}\r\nreturn actual_len;\r\n}\r\nstatic int mos7715_parport_init(struct usb_serial *serial)\r\n{\r\nstruct mos7715_parport *mos_parport;\r\nmos_parport = kzalloc(sizeof(struct mos7715_parport), GFP_KERNEL);\r\nif (mos_parport == NULL) {\r\ndbg("mos7715_parport_init: kzalloc failed");\r\nreturn -ENOMEM;\r\n}\r\nmos_parport->msg_pending = false;\r\nkref_init(&mos_parport->ref_count);\r\nspin_lock_init(&mos_parport->listlock);\r\nINIT_LIST_HEAD(&mos_parport->active_urbs);\r\nINIT_LIST_HEAD(&mos_parport->deferred_urbs);\r\nusb_set_serial_data(serial, mos_parport);\r\nmos_parport->serial = serial;\r\ntasklet_init(&mos_parport->urb_tasklet, send_deferred_urbs,\r\n(unsigned long) mos_parport);\r\ninit_completion(&mos_parport->syncmsg_compl);\r\nwrite_mos_reg(mos_parport->serial, dummy, PP_REG, (__u8)0x80);\r\nwrite_mos_reg(mos_parport->serial, dummy, PP_REG, (__u8)0x00);\r\nmos_parport->shadowDCR = DCR_INIT_VAL;\r\nwrite_mos_reg(mos_parport->serial, dummy, DCR, mos_parport->shadowDCR);\r\nmos_parport->shadowECR = ECR_INIT_VAL;\r\nwrite_mos_reg(mos_parport->serial, dummy, ECR, mos_parport->shadowECR);\r\nmos_parport->pp = parport_register_port(0, PARPORT_IRQ_NONE,\r\nPARPORT_DMA_NONE,\r\n&parport_mos7715_ops);\r\nif (mos_parport->pp == NULL) {\r\ndev_err(&serial->interface->dev,\r\n"Could not register parport\n");\r\nkref_put(&mos_parport->ref_count, destroy_mos_parport);\r\nreturn -EIO;\r\n}\r\nmos_parport->pp->private_data = mos_parport;\r\nmos_parport->pp->modes = PARPORT_MODE_COMPAT | PARPORT_MODE_PCSPP;\r\nmos_parport->pp->dev = &serial->interface->dev;\r\nparport_announce_port(mos_parport->pp);\r\nreturn 0;\r\n}\r\nstatic void mos7720_interrupt_callback(struct urb *urb)\r\n{\r\nint result;\r\nint length;\r\nint status = urb->status;\r\n__u8 *data;\r\n__u8 sp1;\r\n__u8 sp2;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d", __func__,\r\nstatus);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d", __func__,\r\nstatus);\r\ngoto exit;\r\n}\r\nlength = urb->actual_length;\r\ndata = urb->transfer_buffer;\r\nif (unlikely(length != 4)) {\r\ndbg("Wrong data !!!");\r\nreturn;\r\n}\r\nsp1 = data[3];\r\nsp2 = data[2];\r\nif ((sp1 | sp2) & 0x01) {\r\ndbg("No Interrupt !!!");\r\n} else {\r\nswitch (sp1 & 0x0f) {\r\ncase SERIAL_IIR_RLS:\r\ndbg("Serial Port 1: Receiver status error or address "\r\n"bit detected in 9-bit mode\n");\r\nbreak;\r\ncase SERIAL_IIR_CTI:\r\ndbg("Serial Port 1: Receiver time out");\r\nbreak;\r\ncase SERIAL_IIR_MS:\r\nbreak;\r\n}\r\nswitch (sp2 & 0x0f) {\r\ncase SERIAL_IIR_RLS:\r\ndbg("Serial Port 2: Receiver status error or address "\r\n"bit detected in 9-bit mode");\r\nbreak;\r\ncase SERIAL_IIR_CTI:\r\ndbg("Serial Port 2: Receiver time out");\r\nbreak;\r\ncase SERIAL_IIR_MS:\r\nbreak;\r\n}\r\n}\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&urb->dev->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, result);\r\n}\r\nstatic void mos7715_interrupt_callback(struct urb *urb)\r\n{\r\nint result;\r\nint length;\r\nint status = urb->status;\r\n__u8 *data;\r\n__u8 iir;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ENODEV:\r\ndbg("%s - urb shutting down with status: %d", __func__,\r\nstatus);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d", __func__,\r\nstatus);\r\ngoto exit;\r\n}\r\nlength = urb->actual_length;\r\ndata = urb->transfer_buffer;\r\nif (unlikely(length != 4)) {\r\ndbg("Wrong data !!!");\r\nreturn;\r\n}\r\niir = data[0];\r\nif (!(iir & 0x01)) {\r\nswitch (iir & 0x0f) {\r\ncase SERIAL_IIR_RLS:\r\ndbg("Serial Port: Receiver status error or address "\r\n"bit detected in 9-bit mode\n");\r\nbreak;\r\ncase SERIAL_IIR_CTI:\r\ndbg("Serial Port: Receiver time out");\r\nbreak;\r\ncase SERIAL_IIR_MS:\r\nbreak;\r\n}\r\n}\r\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct mos7715_parport *mos_parport = port->serial->private;\r\nif (unlikely(mos_parport == NULL))\r\nreturn;\r\natomic_set(&mos_parport->shadowDSR, data[2]);\r\n}\r\n#endif\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&urb->dev->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, result);\r\n}\r\nstatic void mos7720_bulk_in_callback(struct urb *urb)\r\n{\r\nint retval;\r\nunsigned char *data ;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nint status = urb->status;\r\nif (status) {\r\ndbg("nonzero read bulk status received: %d", status);\r\nreturn;\r\n}\r\nport = urb->context;\r\ndbg("Entering...%s", __func__);\r\ndata = urb->transfer_buffer;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && urb->actual_length) {\r\ntty_insert_flip_string(tty, data, urb->actual_length);\r\ntty_flip_buffer_push(tty);\r\n}\r\ntty_kref_put(tty);\r\nif (!port->read_urb) {\r\ndbg("URB KILLED !!!");\r\nreturn;\r\n}\r\nif (port->read_urb->status != -EINPROGRESS) {\r\nport->read_urb->dev = port->serial->dev;\r\nretval = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (retval)\r\ndbg("usb_submit_urb(read bulk) failed, retval = %d",\r\nretval);\r\n}\r\n}\r\nstatic void mos7720_bulk_out_data_callback(struct urb *urb)\r\n{\r\nstruct moschip_port *mos7720_port;\r\nstruct tty_struct *tty;\r\nint status = urb->status;\r\nif (status) {\r\ndbg("nonzero write bulk status received:%d", status);\r\nreturn;\r\n}\r\nmos7720_port = urb->context;\r\nif (!mos7720_port) {\r\ndbg("NULL mos7720_port pointer");\r\nreturn ;\r\n}\r\ntty = tty_port_tty_get(&mos7720_port->port->port);\r\nif (tty && mos7720_port->open)\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int mos77xx_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nif (id->idProduct == MOSCHIP_DEVICE_ID_7715)\r\nmoschip7720_2port_driver.read_int_callback =\r\nmos7715_interrupt_callback;\r\nelse\r\nmoschip7720_2port_driver.read_int_callback =\r\nmos7720_interrupt_callback;\r\nreturn 0;\r\n}\r\nstatic int mos77xx_calc_num_ports(struct usb_serial *serial)\r\n{\r\nu16 product = le16_to_cpu(serial->dev->descriptor.idProduct);\r\nif (product == MOSCHIP_DEVICE_ID_7715)\r\nreturn 1;\r\nreturn 2;\r\n}\r\nstatic int mos7720_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port0;\r\nstruct urb *urb;\r\nstruct moschip_port *mos7720_port;\r\nint response;\r\nint port_number;\r\n__u8 data;\r\nint allocated_urbs = 0;\r\nint j;\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn -ENODEV;\r\nport0 = serial->port[0];\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nmos7720_port->write_urb_pool[j] = urb;\r\nif (urb == NULL) {\r\ndev_err(&port->dev, "No more urbs???\n");\r\ncontinue;\r\n}\r\nurb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (!urb->transfer_buffer) {\r\ndev_err(&port->dev,\r\n"%s-out of memory for urb buffers.\n",\r\n__func__);\r\nusb_free_urb(mos7720_port->write_urb_pool[j]);\r\nmos7720_port->write_urb_pool[j] = NULL;\r\ncontinue;\r\n}\r\nallocated_urbs++;\r\n}\r\nif (!allocated_urbs)\r\nreturn -ENOMEM;\r\nport_number = port->number - port->serial->minor;\r\nread_mos_reg(serial, port_number, LSR, &data);\r\ndbg("SS::%p LSR:%x", mos7720_port, data);\r\ndbg("Check:Sending Command ..........");\r\nwrite_mos_reg(serial, dummy, SP1_REG, 0x02);\r\nwrite_mos_reg(serial, dummy, SP2_REG, 0x02);\r\nwrite_mos_reg(serial, port_number, IER, 0x00);\r\nwrite_mos_reg(serial, port_number, FCR, 0x00);\r\nwrite_mos_reg(serial, port_number, FCR, 0xcf);\r\nmos7720_port->shadowLCR = 0x03;\r\nwrite_mos_reg(serial, port_number, LCR, mos7720_port->shadowLCR);\r\nmos7720_port->shadowMCR = 0x0b;\r\nwrite_mos_reg(serial, port_number, MCR, mos7720_port->shadowMCR);\r\nwrite_mos_reg(serial, port_number, SP_CONTROL_REG, 0x00);\r\nread_mos_reg(serial, dummy, SP_CONTROL_REG, &data);\r\ndata = data | (port->number - port->serial->minor + 1);\r\nwrite_mos_reg(serial, dummy, SP_CONTROL_REG, data);\r\nmos7720_port->shadowLCR = 0x83;\r\nwrite_mos_reg(serial, port_number, LCR, mos7720_port->shadowLCR);\r\nwrite_mos_reg(serial, port_number, THR, 0x0c);\r\nwrite_mos_reg(serial, port_number, IER, 0x00);\r\nmos7720_port->shadowLCR = 0x03;\r\nwrite_mos_reg(serial, port_number, LCR, mos7720_port->shadowLCR);\r\nwrite_mos_reg(serial, port_number, IER, 0x0c);\r\nresponse = usb_submit_urb(port->read_urb, GFP_KERNEL);\r\nif (response)\r\ndev_err(&port->dev, "%s - Error %d submitting read urb\n",\r\n__func__, response);\r\nmemset(&(mos7720_port->icount), 0x00, sizeof(mos7720_port->icount));\r\nmos7720_port->shadowMCR = UART_MCR_OUT2;\r\nmos7720_port->open = 1;\r\nreturn 0;\r\n}\r\nstatic int mos7720_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint i;\r\nint chars = 0;\r\nstruct moschip_port *mos7720_port;\r\ndbg("%s:entering ...........", __func__);\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL) {\r\ndbg("%s:leaving ...........", __func__);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (mos7720_port->write_urb_pool[i] &&\r\nmos7720_port->write_urb_pool[i]->status == -EINPROGRESS)\r\nchars += URB_TRANSFER_BUFFER_SIZE;\r\n}\r\ndbg("%s - returns %d", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic void mos7720_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7720_port;\r\nint j;\r\ndbg("mos7720_close:entering...");\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn;\r\nfor (j = 0; j < NUM_URBS; ++j)\r\nusb_kill_urb(mos7720_port->write_urb_pool[j]);\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nif (mos7720_port->write_urb_pool[j]) {\r\nkfree(mos7720_port->write_urb_pool[j]->transfer_buffer);\r\nusb_free_urb(mos7720_port->write_urb_pool[j]);\r\n}\r\n}\r\ndbg("Shutdown bulk write");\r\nusb_kill_urb(port->write_urb);\r\ndbg("Shutdown bulk read");\r\nusb_kill_urb(port->read_urb);\r\nmutex_lock(&serial->disc_mutex);\r\nif (!serial->disconnected) {\r\nwrite_mos_reg(serial, port->number - port->serial->minor,\r\nMCR, 0x00);\r\nwrite_mos_reg(serial, port->number - port->serial->minor,\r\nIER, 0x00);\r\n}\r\nmutex_unlock(&serial->disc_mutex);\r\nmos7720_port->open = 0;\r\ndbg("Leaving %s", __func__);\r\n}\r\nstatic void mos7720_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned char data;\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7720_port;\r\ndbg("Entering %s", __func__);\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn;\r\nif (break_state == -1)\r\ndata = mos7720_port->shadowLCR | UART_LCR_SBC;\r\nelse\r\ndata = mos7720_port->shadowLCR & ~UART_LCR_SBC;\r\nmos7720_port->shadowLCR = data;\r\nwrite_mos_reg(serial, port->number - port->serial->minor,\r\nLCR, mos7720_port->shadowLCR);\r\n}\r\nstatic int mos7720_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port;\r\nint room = 0;\r\nint i;\r\ndbg("%s:entering ...........", __func__);\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL) {\r\ndbg("%s:leaving ...........", __func__);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (mos7720_port->write_urb_pool[i] &&\r\nmos7720_port->write_urb_pool[i]->status != -EINPROGRESS)\r\nroom += URB_TRANSFER_BUFFER_SIZE;\r\n}\r\ndbg("%s - returns %d", __func__, room);\r\nreturn room;\r\n}\r\nstatic int mos7720_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *data, int count)\r\n{\r\nint status;\r\nint i;\r\nint bytes_sent = 0;\r\nint transfer_size;\r\nstruct moschip_port *mos7720_port;\r\nstruct usb_serial *serial;\r\nstruct urb *urb;\r\nconst unsigned char *current_position = data;\r\ndbg("%s:entering ...........", __func__);\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL) {\r\ndbg("mos7720_port is NULL");\r\nreturn -ENODEV;\r\n}\r\nurb = NULL;\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (mos7720_port->write_urb_pool[i] &&\r\nmos7720_port->write_urb_pool[i]->status != -EINPROGRESS) {\r\nurb = mos7720_port->write_urb_pool[i];\r\ndbg("URB:%d", i);\r\nbreak;\r\n}\r\n}\r\nif (urb == NULL) {\r\ndbg("%s - no more free urbs", __func__);\r\ngoto exit;\r\n}\r\nif (urb->transfer_buffer == NULL) {\r\nurb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (urb->transfer_buffer == NULL) {\r\ndev_err(&port->dev, "%s no more kernel memory...\n",\r\n__func__);\r\ngoto exit;\r\n}\r\n}\r\ntransfer_size = min(count, URB_TRANSFER_BUFFER_SIZE);\r\nmemcpy(urb->transfer_buffer, current_position, transfer_size);\r\nusb_serial_debug_data(debug, &port->dev, __func__, transfer_size,\r\nurb->transfer_buffer);\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->bulk_out_endpointAddress),\r\nurb->transfer_buffer, transfer_size,\r\nmos7720_bulk_out_data_callback, mos7720_port);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\ndev_err(&port->dev, "%s - usb_submit_urb(write bulk) failed "\r\n"with status = %d\n", __func__, status);\r\nbytes_sent = status;\r\ngoto exit;\r\n}\r\nbytes_sent = transfer_size;\r\nexit:\r\nreturn bytes_sent;\r\n}\r\nstatic void mos7720_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port;\r\nint status;\r\ndbg("%s- port %d", __func__, port->number);\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn;\r\nif (!mos7720_port->open) {\r\ndbg("port not opened");\r\nreturn;\r\n}\r\ndbg("%s: Entering ..........", __func__);\r\nif (I_IXOFF(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nstatus = mos7720_write(tty, port, &stop_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\nmos7720_port->shadowMCR &= ~UART_MCR_RTS;\r\nwrite_mos_reg(port->serial, port->number - port->serial->minor,\r\nMCR, mos7720_port->shadowMCR);\r\nif (status != 0)\r\nreturn;\r\n}\r\n}\r\nstatic void mos7720_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\r\nint status;\r\nif (mos7720_port == NULL)\r\nreturn;\r\nif (!mos7720_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\ndbg("%s: Entering ..........", __func__);\r\nif (I_IXOFF(tty)) {\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus = mos7720_write(tty, port, &start_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\nmos7720_port->shadowMCR |= UART_MCR_RTS;\r\nwrite_mos_reg(port->serial, port->number - port->serial->minor,\r\nMCR, mos7720_port->shadowMCR);\r\nif (status != 0)\r\nreturn;\r\n}\r\n}\r\nstatic int set_higher_rates(struct moschip_port *mos7720_port,\r\nunsigned int baud)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nint port_number;\r\nenum mos_regs sp_reg;\r\nif (mos7720_port == NULL)\r\nreturn -EINVAL;\r\nport = mos7720_port->port;\r\nserial = port->serial;\r\ndbg("Sending Setting Commands ..........");\r\nport_number = port->number - port->serial->minor;\r\nwrite_mos_reg(serial, port_number, IER, 0x00);\r\nwrite_mos_reg(serial, port_number, FCR, 0x00);\r\nwrite_mos_reg(serial, port_number, FCR, 0xcf);\r\nmos7720_port->shadowMCR = 0x0b;\r\nwrite_mos_reg(serial, port_number, MCR, mos7720_port->shadowMCR);\r\nwrite_mos_reg(serial, dummy, SP_CONTROL_REG, 0x00);\r\nif (port_number == 0)\r\nsp_reg = SP1_REG;\r\nelse\r\nsp_reg = SP2_REG;\r\nwrite_mos_reg(serial, dummy, sp_reg, baud * 0x10);\r\nwrite_mos_reg(serial, dummy, SP_CONTROL_REG, 0x03);\r\nmos7720_port->shadowMCR = 0x2b;\r\nwrite_mos_reg(serial, port_number, MCR, mos7720_port->shadowMCR);\r\nmos7720_port->shadowLCR = mos7720_port->shadowLCR | UART_LCR_DLAB;\r\nwrite_mos_reg(serial, port_number, LCR, mos7720_port->shadowLCR);\r\nwrite_mos_reg(serial, port_number, DLL, 0x01);\r\nwrite_mos_reg(serial, port_number, DLM, 0x00);\r\nmos7720_port->shadowLCR = mos7720_port->shadowLCR & ~UART_LCR_DLAB;\r\nwrite_mos_reg(serial, port_number, LCR, mos7720_port->shadowLCR);\r\nreturn 0;\r\n}\r\nstatic int calc_baud_rate_divisor(int baudrate, int *divisor)\r\n{\r\nint i;\r\n__u16 custom;\r\n__u16 round1;\r\n__u16 round;\r\ndbg("%s - %d", __func__, baudrate);\r\nfor (i = 0; i < ARRAY_SIZE(divisor_table); i++) {\r\nif (divisor_table[i].baudrate == baudrate) {\r\n*divisor = divisor_table[i].divisor;\r\nreturn 0;\r\n}\r\n}\r\nif (baudrate > 75 && baudrate < 230400) {\r\ncustom = (__u16)(230400L / baudrate);\r\nround1 = (__u16)(2304000L / baudrate);\r\nround = (__u16)(round1 - (custom * 10));\r\nif (round > 4)\r\ncustom++;\r\n*divisor = custom;\r\ndbg("Baud %d = %d", baudrate, custom);\r\nreturn 0;\r\n}\r\ndbg("Baud calculation Failed...");\r\nreturn -EINVAL;\r\n}\r\nstatic int send_cmd_write_baud_rate(struct moschip_port *mos7720_port,\r\nint baudrate)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nint divisor;\r\nint status;\r\nunsigned char number;\r\nif (mos7720_port == NULL)\r\nreturn -1;\r\nport = mos7720_port->port;\r\nserial = port->serial;\r\ndbg("%s: Entering ..........", __func__);\r\nnumber = port->number - port->serial->minor;\r\ndbg("%s - port = %d, baud = %d", __func__, port->number, baudrate);\r\nstatus = calc_baud_rate_divisor(baudrate, &divisor);\r\nif (status) {\r\ndev_err(&port->dev, "%s - bad baud rate\n", __func__);\r\nreturn status;\r\n}\r\nmos7720_port->shadowLCR = mos7720_port->shadowLCR | UART_LCR_DLAB;\r\nwrite_mos_reg(serial, number, LCR, mos7720_port->shadowLCR);\r\nwrite_mos_reg(serial, number, DLL, (__u8)(divisor & 0xff));\r\nwrite_mos_reg(serial, number, DLM, (__u8)((divisor & 0xff00) >> 8));\r\nmos7720_port->shadowLCR = mos7720_port->shadowLCR & ~UART_LCR_DLAB;\r\nwrite_mos_reg(serial, number, LCR, mos7720_port->shadowLCR);\r\nreturn status;\r\n}\r\nstatic void change_port_settings(struct tty_struct *tty,\r\nstruct moschip_port *mos7720_port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nint baud;\r\nunsigned cflag;\r\nunsigned iflag;\r\n__u8 mask = 0xff;\r\n__u8 lData;\r\n__u8 lParity;\r\n__u8 lStop;\r\nint status;\r\nint port_number;\r\nif (mos7720_port == NULL)\r\nreturn ;\r\nport = mos7720_port->port;\r\nserial = port->serial;\r\nport_number = port->number - port->serial->minor;\r\ndbg("%s - port %d", __func__, port->number);\r\nif (!mos7720_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\ndbg("%s: Entering ..........", __func__);\r\nlData = UART_LCR_WLEN8;\r\nlStop = 0x00;\r\nlParity = 0x00;\r\ncflag = tty->termios->c_cflag;\r\niflag = tty->termios->c_iflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nlData = UART_LCR_WLEN5;\r\nmask = 0x1f;\r\nbreak;\r\ncase CS6:\r\nlData = UART_LCR_WLEN6;\r\nmask = 0x3f;\r\nbreak;\r\ncase CS7:\r\nlData = UART_LCR_WLEN7;\r\nmask = 0x7f;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nlData = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD) {\r\nlParity = UART_LCR_PARITY;\r\ndbg("%s - parity = odd", __func__);\r\n} else {\r\nlParity = (UART_LCR_EPAR | UART_LCR_PARITY);\r\ndbg("%s - parity = even", __func__);\r\n}\r\n} else {\r\ndbg("%s - parity = none", __func__);\r\n}\r\nif (cflag & CMSPAR)\r\nlParity = lParity | 0x20;\r\nif (cflag & CSTOPB) {\r\nlStop = UART_LCR_STOP;\r\ndbg("%s - stop bits = 2", __func__);\r\n} else {\r\nlStop = 0x00;\r\ndbg("%s - stop bits = 1", __func__);\r\n}\r\n#define LCR_BITS_MASK 0x03\r\n#define LCR_STOP_MASK 0x04\r\n#define LCR_PAR_MASK 0x38\r\nmos7720_port->shadowLCR &=\r\n~(LCR_BITS_MASK | LCR_STOP_MASK | LCR_PAR_MASK);\r\nmos7720_port->shadowLCR |= (lData | lParity | lStop);\r\nwrite_mos_reg(serial, port_number, IER, 0x00);\r\nwrite_mos_reg(serial, port_number, FCR, 0x00);\r\nwrite_mos_reg(serial, port_number, FCR, 0xcf);\r\nwrite_mos_reg(serial, port_number, LCR, mos7720_port->shadowLCR);\r\nmos7720_port->shadowMCR = 0x0b;\r\nwrite_mos_reg(serial, port_number, MCR, mos7720_port->shadowMCR);\r\nmos7720_port->shadowMCR = UART_MCR_OUT2;\r\nif (cflag & CBAUD)\r\nmos7720_port->shadowMCR |= (UART_MCR_DTR | UART_MCR_RTS);\r\nif (cflag & CRTSCTS) {\r\nmos7720_port->shadowMCR |= (UART_MCR_XONANY);\r\nif (port->number)\r\nwrite_mos_reg(serial, dummy, SP_CONTROL_REG, 0x01);\r\nelse\r\nwrite_mos_reg(serial, dummy, SP_CONTROL_REG, 0x02);\r\n} else\r\nmos7720_port->shadowMCR &= ~(UART_MCR_XONANY);\r\nwrite_mos_reg(serial, port_number, MCR, mos7720_port->shadowMCR);\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud) {\r\ndbg("Picked default baud...");\r\nbaud = 9600;\r\n}\r\nif (baud >= 230400) {\r\nset_higher_rates(mos7720_port, baud);\r\nwrite_mos_reg(serial, port_number, IER, 0x0c);\r\nreturn;\r\n}\r\ndbg("%s - baud rate = %d", __func__, baud);\r\nstatus = send_cmd_write_baud_rate(mos7720_port, baud);\r\nif (cflag & CBAUD)\r\ntty_encode_baud_rate(tty, baud, baud);\r\nwrite_mos_reg(serial, port_number, IER, 0x0c);\r\nif (port->read_urb->status != -EINPROGRESS) {\r\nport->read_urb->dev = serial->dev;\r\nstatus = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (status)\r\ndbg("usb_submit_urb(read bulk) failed, status = %d",\r\nstatus);\r\n}\r\n}\r\nstatic void mos7720_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nint status;\r\nunsigned int cflag;\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7720_port;\r\nserial = port->serial;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn;\r\nif (!mos7720_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\ndbg("%s\n", "setting termios - ASPIRE");\r\ncflag = tty->termios->c_cflag;\r\ndbg("%s - cflag %08x iflag %08x", __func__,\r\ntty->termios->c_cflag,\r\nRELEVANT_IFLAG(tty->termios->c_iflag));\r\ndbg("%s - old cflag %08x old iflag %08x", __func__,\r\nold_termios->c_cflag,\r\nRELEVANT_IFLAG(old_termios->c_iflag));\r\ndbg("%s - port %d", __func__, port->number);\r\nchange_port_settings(tty, mos7720_port, old_termios);\r\nif (!port->read_urb) {\r\ndbg("%s", "URB KILLED !!!!!");\r\nreturn;\r\n}\r\nif (port->read_urb->status != -EINPROGRESS) {\r\nport->read_urb->dev = serial->dev;\r\nstatus = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (status)\r\ndbg("usb_submit_urb(read bulk) failed, status = %d",\r\nstatus);\r\n}\r\n}\r\nstatic int get_lsr_info(struct tty_struct *tty,\r\nstruct moschip_port *mos7720_port, unsigned int __user *value)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned int result = 0;\r\nunsigned char data = 0;\r\nint port_number = port->number - port->serial->minor;\r\nint count;\r\ncount = mos7720_chars_in_buffer(tty);\r\nif (count == 0) {\r\nread_mos_reg(port->serial, port_number, LSR, &data);\r\nif ((data & (UART_LSR_TEMT | UART_LSR_THRE))\r\n== (UART_LSR_TEMT | UART_LSR_THRE)) {\r\ndbg("%s -- Empty", __func__);\r\nresult = TIOCSER_TEMT;\r\n}\r\n}\r\nif (copy_to_user(value, &result, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mos7720_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\r\nunsigned int result = 0;\r\nunsigned int mcr ;\r\nunsigned int msr ;\r\ndbg("%s - port %d", __func__, port->number);\r\nmcr = mos7720_port->shadowMCR;\r\nmsr = mos7720_port->shadowMSR;\r\nresult = ((mcr & UART_MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & UART_MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((msr & UART_MSR_CTS) ? TIOCM_CTS : 0)\r\n| ((msr & UART_MSR_DCD) ? TIOCM_CAR : 0)\r\n| ((msr & UART_MSR_RI) ? TIOCM_RI : 0)\r\n| ((msr & UART_MSR_DSR) ? TIOCM_DSR : 0);\r\ndbg("%s -- %x", __func__, result);\r\nreturn result;\r\n}\r\nstatic int mos7720_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\r\nunsigned int mcr ;\r\ndbg("%s - port %d", __func__, port->number);\r\ndbg("he was at tiocmset");\r\nmcr = mos7720_port->shadowMCR;\r\nif (set & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (set & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nif (clear & TIOCM_RTS)\r\nmcr &= ~UART_MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\nmcr &= ~UART_MCR_DTR;\r\nif (clear & TIOCM_LOOP)\r\nmcr &= ~UART_MCR_LOOP;\r\nmos7720_port->shadowMCR = mcr;\r\nwrite_mos_reg(port->serial, port->number - port->serial->minor,\r\nMCR, mos7720_port->shadowMCR);\r\nreturn 0;\r\n}\r\nstatic int mos7720_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port;\r\nstruct async_icount cnow;\r\nmos7720_port = usb_get_serial_port_data(port);\r\ncnow = mos7720_port->icount;\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\ndbg("%s (%d) TIOCGICOUNT RX=%d, TX=%d", __func__,\r\nport->number, icount->rx, icount->tx);\r\nreturn 0;\r\n}\r\nstatic int set_modem_info(struct moschip_port *mos7720_port, unsigned int cmd,\r\nunsigned int __user *value)\r\n{\r\nunsigned int mcr;\r\nunsigned int arg;\r\nstruct usb_serial_port *port;\r\nif (mos7720_port == NULL)\r\nreturn -1;\r\nport = (struct usb_serial_port *)mos7720_port->port;\r\nmcr = mos7720_port->shadowMCR;\r\nif (copy_from_user(&arg, value, sizeof(int)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase TIOCMBIS:\r\nif (arg & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (arg & TIOCM_DTR)\r\nmcr |= UART_MCR_RTS;\r\nif (arg & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nbreak;\r\ncase TIOCMBIC:\r\nif (arg & TIOCM_RTS)\r\nmcr &= ~UART_MCR_RTS;\r\nif (arg & TIOCM_DTR)\r\nmcr &= ~UART_MCR_RTS;\r\nif (arg & TIOCM_LOOP)\r\nmcr &= ~UART_MCR_LOOP;\r\nbreak;\r\n}\r\nmos7720_port->shadowMCR = mcr;\r\nwrite_mos_reg(port->serial, port->number - port->serial->minor,\r\nMCR, mos7720_port->shadowMCR);\r\nreturn 0;\r\n}\r\nstatic int get_serial_info(struct moschip_port *mos7720_port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.line = mos7720_port->port->serial->minor;\r\ntmp.port = mos7720_port->port->number;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = NUM_URBS * URB_TRANSFER_BUFFER_SIZE;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = 30*HZ;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mos7720_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7720_port;\r\nstruct async_icount cnow;\r\nstruct async_icount cprev;\r\nmos7720_port = usb_get_serial_port_data(port);\r\nif (mos7720_port == NULL)\r\nreturn -ENODEV;\r\ndbg("%s - port %d, cmd = 0x%x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCSERGETLSR:\r\ndbg("%s (%d) TIOCSERGETLSR", __func__, port->number);\r\nreturn get_lsr_info(tty, mos7720_port,\r\n(unsigned int __user *)arg);\r\nreturn 0;\r\ncase TIOCMBIS:\r\ncase TIOCMBIC:\r\ndbg("%s (%d) TIOCMSET/TIOCMBIC/TIOCMSET",\r\n__func__, port->number);\r\nreturn set_modem_info(mos7720_port, cmd,\r\n(unsigned int __user *)arg);\r\ncase TIOCGSERIAL:\r\ndbg("%s (%d) TIOCGSERIAL", __func__, port->number);\r\nreturn get_serial_info(mos7720_port,\r\n(struct serial_struct __user *)arg);\r\ncase TIOCMIWAIT:\r\ndbg("%s (%d) TIOCMIWAIT", __func__, port->number);\r\ncprev = mos7720_port->icount;\r\nwhile (1) {\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\ncnow = mos7720_port->icount;\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts)\r\nreturn -EIO;\r\nif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {\r\nreturn 0;\r\n}\r\ncprev = cnow;\r\n}\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int mos7720_startup(struct usb_serial *serial)\r\n{\r\nstruct moschip_port *mos7720_port;\r\nstruct usb_device *dev;\r\nint i;\r\nchar data;\r\nu16 product;\r\nint ret_val;\r\ndbg("%s: Entering ..........", __func__);\r\nif (!serial) {\r\ndbg("Invalid Handler");\r\nreturn -ENODEV;\r\n}\r\nproduct = le16_to_cpu(serial->dev->descriptor.idProduct);\r\ndev = serial->dev;\r\nif (product == MOSCHIP_DEVICE_ID_7715) {\r\nstruct usb_serial_port *tmp = serial->port[0];\r\nserial->port[0] = serial->port[1];\r\nserial->port[1] = tmp;\r\nserial->port[0]->interrupt_in_urb = tmp->interrupt_in_urb;\r\nserial->port[0]->interrupt_in_buffer = tmp->interrupt_in_buffer;\r\nserial->port[0]->interrupt_in_endpointAddress =\r\ntmp->interrupt_in_endpointAddress;\r\nserial->port[1]->interrupt_in_urb = NULL;\r\nserial->port[1]->interrupt_in_buffer = NULL;\r\n}\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nmos7720_port = kzalloc(sizeof(struct moschip_port), GFP_KERNEL);\r\nif (mos7720_port == NULL) {\r\ndev_err(&dev->dev, "%s - Out of memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nserial->port[i]->interrupt_in_endpointAddress =\r\nserial->port[0]->interrupt_in_endpointAddress;\r\nmos7720_port->port = serial->port[i];\r\nusb_set_serial_port_data(serial->port[i], mos7720_port);\r\ndbg("port number is %d", serial->port[i]->number);\r\ndbg("serial number is %d", serial->minor);\r\n}\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\n(__u8)0x03, 0x00, 0x01, 0x00, NULL, 0x00, 5*HZ);\r\nret_val = usb_submit_urb(serial->port[0]->interrupt_in_urb, GFP_KERNEL);\r\nif (ret_val)\r\ndev_err(&dev->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, ret_val);\r\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\r\nif (product == MOSCHIP_DEVICE_ID_7715) {\r\nret_val = mos7715_parport_init(serial);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\n}\r\n#endif\r\nread_mos_reg(serial, 0, LSR, &data);\r\ndbg("LSR:%x", data);\r\nreturn 0;\r\n}\r\nstatic void mos7720_release(struct usb_serial *serial)\r\n{\r\nint i;\r\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\r\nif (le16_to_cpu(serial->dev->descriptor.idProduct)\r\n== MOSCHIP_DEVICE_ID_7715) {\r\nstruct urbtracker *urbtrack;\r\nunsigned long flags;\r\nstruct mos7715_parport *mos_parport =\r\nusb_get_serial_data(serial);\r\nspin_lock(&release_lock);\r\nmos_parport->pp->private_data = NULL;\r\nspin_unlock(&release_lock);\r\nif (mos_parport->msg_pending)\r\nwait_for_completion_timeout(&mos_parport->syncmsg_compl,\r\nMOS_WDR_TIMEOUT);\r\nparport_remove_port(mos_parport->pp);\r\nusb_set_serial_data(serial, NULL);\r\nmos_parport->serial = NULL;\r\ntasklet_kill(&mos_parport->urb_tasklet);\r\nspin_lock_irqsave(&mos_parport->listlock, flags);\r\nlist_for_each_entry(urbtrack,\r\n&mos_parport->active_urbs,\r\nurblist_entry)\r\nusb_unlink_urb(urbtrack->urb);\r\nspin_unlock_irqrestore(&mos_parport->listlock, flags);\r\nkref_put(&mos_parport->ref_count, destroy_mos_parport);\r\n}\r\n#endif\r\nfor (i = 0; i < serial->num_ports; ++i)\r\nkfree(usb_get_serial_port_data(serial->port[i]));\r\n}\r\nstatic int __init moschip7720_init(void)\r\n{\r\nint retval;\r\ndbg("%s: Entering ..........", __func__);\r\nretval = usb_serial_register(&moschip7720_2port_driver);\r\nif (retval)\r\ngoto failed_port_device_register;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nretval = usb_register(&usb_driver);\r\nif (retval)\r\ngoto failed_usb_register;\r\nreturn 0;\r\nfailed_usb_register:\r\nusb_serial_deregister(&moschip7720_2port_driver);\r\nfailed_port_device_register:\r\nreturn retval;\r\n}\r\nstatic void __exit moschip7720_exit(void)\r\n{\r\nusb_deregister(&usb_driver);\r\nusb_serial_deregister(&moschip7720_2port_driver);\r\n}
