static u32 htohl(u32 in, int swap)\r\n{\r\nreturn swap ? swab32(in) : in;\r\n}\r\nstatic void subscr_send_event(struct subscription *sub,\r\nu32 found_lower,\r\nu32 found_upper,\r\nu32 event,\r\nu32 port_ref,\r\nu32 node)\r\n{\r\nstruct iovec msg_sect;\r\nmsg_sect.iov_base = (void *)&sub->evt;\r\nmsg_sect.iov_len = sizeof(struct tipc_event);\r\nsub->evt.event = htohl(event, sub->swap);\r\nsub->evt.found_lower = htohl(found_lower, sub->swap);\r\nsub->evt.found_upper = htohl(found_upper, sub->swap);\r\nsub->evt.port.ref = htohl(port_ref, sub->swap);\r\nsub->evt.port.node = htohl(node, sub->swap);\r\ntipc_send(sub->server_ref, 1, &msg_sect, msg_sect.iov_len);\r\n}\r\nint tipc_subscr_overlap(struct subscription *sub,\r\nu32 found_lower,\r\nu32 found_upper)\r\n{\r\nif (found_lower < sub->seq.lower)\r\nfound_lower = sub->seq.lower;\r\nif (found_upper > sub->seq.upper)\r\nfound_upper = sub->seq.upper;\r\nif (found_lower > found_upper)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid tipc_subscr_report_overlap(struct subscription *sub,\r\nu32 found_lower,\r\nu32 found_upper,\r\nu32 event,\r\nu32 port_ref,\r\nu32 node,\r\nint must)\r\n{\r\nif (!tipc_subscr_overlap(sub, found_lower, found_upper))\r\nreturn;\r\nif (!must && !(sub->filter & TIPC_SUB_PORTS))\r\nreturn;\r\nsub->event_cb(sub, found_lower, found_upper, event, port_ref, node);\r\n}\r\nstatic void subscr_timeout(struct subscription *sub)\r\n{\r\nstruct tipc_port *server_port;\r\nserver_port = tipc_port_lock(sub->server_ref);\r\nif (server_port == NULL)\r\nreturn;\r\nif (sub->timeout == TIPC_WAIT_FOREVER) {\r\ntipc_port_unlock(server_port);\r\nreturn;\r\n}\r\ntipc_nametbl_unsubscribe(sub);\r\nlist_del(&sub->subscription_list);\r\ntipc_port_unlock(server_port);\r\nsubscr_send_event(sub, sub->evt.s.seq.lower, sub->evt.s.seq.upper,\r\nTIPC_SUBSCR_TIMEOUT, 0, 0);\r\nk_term_timer(&sub->timer);\r\nkfree(sub);\r\natomic_dec(&topsrv.subscription_count);\r\n}\r\nstatic void subscr_del(struct subscription *sub)\r\n{\r\ntipc_nametbl_unsubscribe(sub);\r\nlist_del(&sub->subscription_list);\r\nkfree(sub);\r\natomic_dec(&topsrv.subscription_count);\r\n}\r\nstatic void subscr_terminate(struct subscriber *subscriber)\r\n{\r\nu32 port_ref;\r\nstruct subscription *sub;\r\nstruct subscription *sub_temp;\r\nport_ref = subscriber->port_ref;\r\nsubscriber->port_ref = 0;\r\nspin_unlock_bh(subscriber->lock);\r\ntipc_shutdown(port_ref);\r\ntipc_deleteport(port_ref);\r\nlist_for_each_entry_safe(sub, sub_temp, &subscriber->subscription_list,\r\nsubscription_list) {\r\nif (sub->timeout != TIPC_WAIT_FOREVER) {\r\nk_cancel_timer(&sub->timer);\r\nk_term_timer(&sub->timer);\r\n}\r\nsubscr_del(sub);\r\n}\r\nspin_lock_bh(&topsrv.lock);\r\nlist_del(&subscriber->subscriber_list);\r\nspin_unlock_bh(&topsrv.lock);\r\nspin_lock_bh(subscriber->lock);\r\nkfree(subscriber);\r\n}\r\nstatic void subscr_cancel(struct tipc_subscr *s,\r\nstruct subscriber *subscriber)\r\n{\r\nstruct subscription *sub;\r\nstruct subscription *sub_temp;\r\nint found = 0;\r\nlist_for_each_entry_safe(sub, sub_temp, &subscriber->subscription_list,\r\nsubscription_list) {\r\nif (!memcmp(s, &sub->evt.s, sizeof(struct tipc_subscr))) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn;\r\nif (sub->timeout != TIPC_WAIT_FOREVER) {\r\nsub->timeout = TIPC_WAIT_FOREVER;\r\nspin_unlock_bh(subscriber->lock);\r\nk_cancel_timer(&sub->timer);\r\nk_term_timer(&sub->timer);\r\nspin_lock_bh(subscriber->lock);\r\n}\r\nsubscr_del(sub);\r\n}\r\nstatic struct subscription *subscr_subscribe(struct tipc_subscr *s,\r\nstruct subscriber *subscriber)\r\n{\r\nstruct subscription *sub;\r\nint swap;\r\nswap = !(s->filter & (TIPC_SUB_PORTS | TIPC_SUB_SERVICE));\r\nif (s->filter & htohl(TIPC_SUB_CANCEL, swap)) {\r\ns->filter &= ~htohl(TIPC_SUB_CANCEL, swap);\r\nsubscr_cancel(s, subscriber);\r\nreturn NULL;\r\n}\r\nif (atomic_read(&topsrv.subscription_count) >= tipc_max_subscriptions) {\r\nwarn("Subscription rejected, subscription limit reached (%u)\n",\r\ntipc_max_subscriptions);\r\nsubscr_terminate(subscriber);\r\nreturn NULL;\r\n}\r\nsub = kmalloc(sizeof(*sub), GFP_ATOMIC);\r\nif (!sub) {\r\nwarn("Subscription rejected, no memory\n");\r\nsubscr_terminate(subscriber);\r\nreturn NULL;\r\n}\r\nsub->seq.type = htohl(s->seq.type, swap);\r\nsub->seq.lower = htohl(s->seq.lower, swap);\r\nsub->seq.upper = htohl(s->seq.upper, swap);\r\nsub->timeout = htohl(s->timeout, swap);\r\nsub->filter = htohl(s->filter, swap);\r\nif ((!(sub->filter & TIPC_SUB_PORTS) ==\r\n!(sub->filter & TIPC_SUB_SERVICE)) ||\r\n(sub->seq.lower > sub->seq.upper)) {\r\nwarn("Subscription rejected, illegal request\n");\r\nkfree(sub);\r\nsubscr_terminate(subscriber);\r\nreturn NULL;\r\n}\r\nsub->event_cb = subscr_send_event;\r\nINIT_LIST_HEAD(&sub->nameseq_list);\r\nlist_add(&sub->subscription_list, &subscriber->subscription_list);\r\nsub->server_ref = subscriber->port_ref;\r\nsub->swap = swap;\r\nmemcpy(&sub->evt.s, s, sizeof(struct tipc_subscr));\r\natomic_inc(&topsrv.subscription_count);\r\nif (sub->timeout != TIPC_WAIT_FOREVER) {\r\nk_init_timer(&sub->timer,\r\n(Handler)subscr_timeout, (unsigned long)sub);\r\nk_start_timer(&sub->timer, sub->timeout);\r\n}\r\nreturn sub;\r\n}\r\nstatic void subscr_conn_shutdown_event(void *usr_handle,\r\nu32 port_ref,\r\nstruct sk_buff **buf,\r\nunsigned char const *data,\r\nunsigned int size,\r\nint reason)\r\n{\r\nstruct subscriber *subscriber = usr_handle;\r\nspinlock_t *subscriber_lock;\r\nif (tipc_port_lock(port_ref) == NULL)\r\nreturn;\r\nsubscriber_lock = subscriber->lock;\r\nsubscr_terminate(subscriber);\r\nspin_unlock_bh(subscriber_lock);\r\n}\r\nstatic void subscr_conn_msg_event(void *usr_handle,\r\nu32 port_ref,\r\nstruct sk_buff **buf,\r\nconst unchar *data,\r\nu32 size)\r\n{\r\nstruct subscriber *subscriber = usr_handle;\r\nspinlock_t *subscriber_lock;\r\nstruct subscription *sub;\r\nif (tipc_port_lock(port_ref) == NULL)\r\nreturn;\r\nsubscriber_lock = subscriber->lock;\r\nif (size != sizeof(struct tipc_subscr)) {\r\nsubscr_terminate(subscriber);\r\nspin_unlock_bh(subscriber_lock);\r\n} else {\r\nsub = subscr_subscribe((struct tipc_subscr *)data, subscriber);\r\nspin_unlock_bh(subscriber_lock);\r\nif (sub != NULL) {\r\ntipc_nametbl_subscribe(sub);\r\n}\r\n}\r\n}\r\nstatic void subscr_named_msg_event(void *usr_handle,\r\nu32 port_ref,\r\nstruct sk_buff **buf,\r\nconst unchar *data,\r\nu32 size,\r\nu32 importance,\r\nstruct tipc_portid const *orig,\r\nstruct tipc_name_seq const *dest)\r\n{\r\nstruct subscriber *subscriber;\r\nu32 server_port_ref;\r\nsubscriber = kzalloc(sizeof(struct subscriber), GFP_ATOMIC);\r\nif (subscriber == NULL) {\r\nwarn("Subscriber rejected, no memory\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&subscriber->subscription_list);\r\nINIT_LIST_HEAD(&subscriber->subscriber_list);\r\ntipc_createport(subscriber,\r\nimportance,\r\nNULL,\r\nNULL,\r\nsubscr_conn_shutdown_event,\r\nNULL,\r\nNULL,\r\nsubscr_conn_msg_event,\r\nNULL,\r\n&subscriber->port_ref);\r\nif (subscriber->port_ref == 0) {\r\nwarn("Subscriber rejected, unable to create port\n");\r\nkfree(subscriber);\r\nreturn;\r\n}\r\ntipc_connect2port(subscriber->port_ref, orig);\r\nsubscriber->lock = tipc_port_lock(subscriber->port_ref)->lock;\r\nspin_lock_bh(&topsrv.lock);\r\nlist_add(&subscriber->subscriber_list, &topsrv.subscriber_list);\r\nspin_unlock_bh(&topsrv.lock);\r\nserver_port_ref = subscriber->port_ref;\r\nspin_unlock_bh(subscriber->lock);\r\ntipc_send(server_port_ref, 0, NULL, 0);\r\nif (size != 0) {\r\nsubscr_conn_msg_event(subscriber, server_port_ref,\r\nbuf, data, size);\r\n}\r\n}\r\nint tipc_subscr_start(void)\r\n{\r\nstruct tipc_name_seq seq = {TIPC_TOP_SRV, TIPC_TOP_SRV, TIPC_TOP_SRV};\r\nint res;\r\nmemset(&topsrv, 0, sizeof(topsrv));\r\nspin_lock_init(&topsrv.lock);\r\nINIT_LIST_HEAD(&topsrv.subscriber_list);\r\nres = tipc_createport(NULL,\r\nTIPC_CRITICAL_IMPORTANCE,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nsubscr_named_msg_event,\r\nNULL,\r\nNULL,\r\n&topsrv.setup_port);\r\nif (res)\r\ngoto failed;\r\nres = tipc_nametbl_publish_rsv(topsrv.setup_port, TIPC_NODE_SCOPE, &seq);\r\nif (res) {\r\ntipc_deleteport(topsrv.setup_port);\r\ntopsrv.setup_port = 0;\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nerr("Failed to create subscription service\n");\r\nreturn res;\r\n}\r\nvoid tipc_subscr_stop(void)\r\n{\r\nstruct subscriber *subscriber;\r\nstruct subscriber *subscriber_temp;\r\nspinlock_t *subscriber_lock;\r\nif (topsrv.setup_port) {\r\ntipc_deleteport(topsrv.setup_port);\r\ntopsrv.setup_port = 0;\r\nlist_for_each_entry_safe(subscriber, subscriber_temp,\r\n&topsrv.subscriber_list,\r\nsubscriber_list) {\r\nsubscriber_lock = subscriber->lock;\r\nspin_lock_bh(subscriber_lock);\r\nsubscr_terminate(subscriber);\r\nspin_unlock_bh(subscriber_lock);\r\n}\r\n}\r\n}
