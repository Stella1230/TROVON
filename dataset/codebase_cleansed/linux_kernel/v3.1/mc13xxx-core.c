struct mc13xxx *mc13783_to_mc13xxx(struct mc13783 *mc13783)\r\n{\r\nreturn &mc13783->mc13xxx;\r\n}\r\nvoid mc13xxx_lock(struct mc13xxx *mc13xxx)\r\n{\r\nif (!mutex_trylock(&mc13xxx->lock)) {\r\ndev_dbg(&mc13xxx->spidev->dev, "wait for %s from %pf\n",\r\n__func__, __builtin_return_address(0));\r\nmutex_lock(&mc13xxx->lock);\r\n}\r\ndev_dbg(&mc13xxx->spidev->dev, "%s from %pf\n",\r\n__func__, __builtin_return_address(0));\r\n}\r\nvoid mc13xxx_unlock(struct mc13xxx *mc13xxx)\r\n{\r\ndev_dbg(&mc13xxx->spidev->dev, "%s from %pf\n",\r\n__func__, __builtin_return_address(0));\r\nmutex_unlock(&mc13xxx->lock);\r\n}\r\nint mc13xxx_reg_read(struct mc13xxx *mc13xxx, unsigned int offset, u32 *val)\r\n{\r\nstruct spi_transfer t;\r\nstruct spi_message m;\r\nint ret;\r\nBUG_ON(!mutex_is_locked(&mc13xxx->lock));\r\nif (offset > MC13XXX_NUMREGS)\r\nreturn -EINVAL;\r\n*val = offset << MC13XXX_REGOFFSET_SHIFT;\r\nmemset(&t, 0, sizeof(t));\r\nt.tx_buf = val;\r\nt.rx_buf = val;\r\nt.len = sizeof(u32);\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nret = spi_sync(mc13xxx->spidev, &m);\r\nBUG_ON(!ret && m.status);\r\nif (ret)\r\nreturn ret;\r\n*val &= 0xffffff;\r\ndev_vdbg(&mc13xxx->spidev->dev, "[0x%02x] -> 0x%06x\n", offset, *val);\r\nreturn 0;\r\n}\r\nint mc13xxx_reg_write(struct mc13xxx *mc13xxx, unsigned int offset, u32 val)\r\n{\r\nu32 buf;\r\nstruct spi_transfer t;\r\nstruct spi_message m;\r\nint ret;\r\nBUG_ON(!mutex_is_locked(&mc13xxx->lock));\r\ndev_vdbg(&mc13xxx->spidev->dev, "[0x%02x] <- 0x%06x\n", offset, val);\r\nif (offset > MC13XXX_NUMREGS || val > 0xffffff)\r\nreturn -EINVAL;\r\nbuf = 1 << 31 | offset << MC13XXX_REGOFFSET_SHIFT | val;\r\nmemset(&t, 0, sizeof(t));\r\nt.tx_buf = &buf;\r\nt.rx_buf = &buf;\r\nt.len = sizeof(u32);\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nret = spi_sync(mc13xxx->spidev, &m);\r\nBUG_ON(!ret && m.status);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint mc13xxx_reg_rmw(struct mc13xxx *mc13xxx, unsigned int offset,\r\nu32 mask, u32 val)\r\n{\r\nint ret;\r\nu32 valread;\r\nBUG_ON(val & ~mask);\r\nret = mc13xxx_reg_read(mc13xxx, offset, &valread);\r\nif (ret)\r\nreturn ret;\r\nvalread = (valread & ~mask) | val;\r\nreturn mc13xxx_reg_write(mc13xxx, offset, valread);\r\n}\r\nint mc13xxx_irq_mask(struct mc13xxx *mc13xxx, int irq)\r\n{\r\nint ret;\r\nunsigned int offmask = irq < 24 ? MC13XXX_IRQMASK0 : MC13XXX_IRQMASK1;\r\nu32 irqbit = 1 << (irq < 24 ? irq : irq - 24);\r\nu32 mask;\r\nif (irq < 0 || irq >= MC13XXX_NUM_IRQ)\r\nreturn -EINVAL;\r\nret = mc13xxx_reg_read(mc13xxx, offmask, &mask);\r\nif (ret)\r\nreturn ret;\r\nif (mask & irqbit)\r\nreturn 0;\r\nreturn mc13xxx_reg_write(mc13xxx, offmask, mask | irqbit);\r\n}\r\nint mc13xxx_irq_unmask(struct mc13xxx *mc13xxx, int irq)\r\n{\r\nint ret;\r\nunsigned int offmask = irq < 24 ? MC13XXX_IRQMASK0 : MC13XXX_IRQMASK1;\r\nu32 irqbit = 1 << (irq < 24 ? irq : irq - 24);\r\nu32 mask;\r\nif (irq < 0 || irq >= MC13XXX_NUM_IRQ)\r\nreturn -EINVAL;\r\nret = mc13xxx_reg_read(mc13xxx, offmask, &mask);\r\nif (ret)\r\nreturn ret;\r\nif (!(mask & irqbit))\r\nreturn 0;\r\nreturn mc13xxx_reg_write(mc13xxx, offmask, mask & ~irqbit);\r\n}\r\nint mc13xxx_irq_status(struct mc13xxx *mc13xxx, int irq,\r\nint *enabled, int *pending)\r\n{\r\nint ret;\r\nunsigned int offmask = irq < 24 ? MC13XXX_IRQMASK0 : MC13XXX_IRQMASK1;\r\nunsigned int offstat = irq < 24 ? MC13XXX_IRQSTAT0 : MC13XXX_IRQSTAT1;\r\nu32 irqbit = 1 << (irq < 24 ? irq : irq - 24);\r\nif (irq < 0 || irq >= MC13XXX_NUM_IRQ)\r\nreturn -EINVAL;\r\nif (enabled) {\r\nu32 mask;\r\nret = mc13xxx_reg_read(mc13xxx, offmask, &mask);\r\nif (ret)\r\nreturn ret;\r\n*enabled = mask & irqbit;\r\n}\r\nif (pending) {\r\nu32 stat;\r\nret = mc13xxx_reg_read(mc13xxx, offstat, &stat);\r\nif (ret)\r\nreturn ret;\r\n*pending = stat & irqbit;\r\n}\r\nreturn 0;\r\n}\r\nint mc13xxx_irq_ack(struct mc13xxx *mc13xxx, int irq)\r\n{\r\nunsigned int offstat = irq < 24 ? MC13XXX_IRQSTAT0 : MC13XXX_IRQSTAT1;\r\nunsigned int val = 1 << (irq < 24 ? irq : irq - 24);\r\nBUG_ON(irq < 0 || irq >= MC13XXX_NUM_IRQ);\r\nreturn mc13xxx_reg_write(mc13xxx, offstat, val);\r\n}\r\nint mc13xxx_irq_request_nounmask(struct mc13xxx *mc13xxx, int irq,\r\nirq_handler_t handler, const char *name, void *dev)\r\n{\r\nBUG_ON(!mutex_is_locked(&mc13xxx->lock));\r\nBUG_ON(!handler);\r\nif (irq < 0 || irq >= MC13XXX_NUM_IRQ)\r\nreturn -EINVAL;\r\nif (mc13xxx->irqhandler[irq])\r\nreturn -EBUSY;\r\nmc13xxx->irqhandler[irq] = handler;\r\nmc13xxx->irqdata[irq] = dev;\r\nreturn 0;\r\n}\r\nint mc13xxx_irq_request(struct mc13xxx *mc13xxx, int irq,\r\nirq_handler_t handler, const char *name, void *dev)\r\n{\r\nint ret;\r\nret = mc13xxx_irq_request_nounmask(mc13xxx, irq, handler, name, dev);\r\nif (ret)\r\nreturn ret;\r\nret = mc13xxx_irq_unmask(mc13xxx, irq);\r\nif (ret) {\r\nmc13xxx->irqhandler[irq] = NULL;\r\nmc13xxx->irqdata[irq] = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint mc13xxx_irq_free(struct mc13xxx *mc13xxx, int irq, void *dev)\r\n{\r\nint ret;\r\nBUG_ON(!mutex_is_locked(&mc13xxx->lock));\r\nif (irq < 0 || irq >= MC13XXX_NUM_IRQ || !mc13xxx->irqhandler[irq] ||\r\nmc13xxx->irqdata[irq] != dev)\r\nreturn -EINVAL;\r\nret = mc13xxx_irq_mask(mc13xxx, irq);\r\nif (ret)\r\nreturn ret;\r\nmc13xxx->irqhandler[irq] = NULL;\r\nmc13xxx->irqdata[irq] = NULL;\r\nreturn 0;\r\n}\r\nstatic inline irqreturn_t mc13xxx_irqhandler(struct mc13xxx *mc13xxx, int irq)\r\n{\r\nreturn mc13xxx->irqhandler[irq](irq, mc13xxx->irqdata[irq]);\r\n}\r\nstatic int mc13xxx_irq_handle(struct mc13xxx *mc13xxx,\r\nunsigned int offstat, unsigned int offmask, int baseirq)\r\n{\r\nu32 stat, mask;\r\nint ret = mc13xxx_reg_read(mc13xxx, offstat, &stat);\r\nint num_handled = 0;\r\nif (ret)\r\nreturn ret;\r\nret = mc13xxx_reg_read(mc13xxx, offmask, &mask);\r\nif (ret)\r\nreturn ret;\r\nwhile (stat & ~mask) {\r\nint irq = __ffs(stat & ~mask);\r\nstat &= ~(1 << irq);\r\nif (likely(mc13xxx->irqhandler[baseirq + irq])) {\r\nirqreturn_t handled;\r\nhandled = mc13xxx_irqhandler(mc13xxx, baseirq + irq);\r\nif (handled == IRQ_HANDLED)\r\nnum_handled++;\r\n} else {\r\ndev_err(&mc13xxx->spidev->dev,\r\n"BUG: irq %u but no handler\n",\r\nbaseirq + irq);\r\nmask |= 1 << irq;\r\nret = mc13xxx_reg_write(mc13xxx, offmask, mask);\r\n}\r\n}\r\nreturn num_handled;\r\n}\r\nstatic irqreturn_t mc13xxx_irq_thread(int irq, void *data)\r\n{\r\nstruct mc13xxx *mc13xxx = data;\r\nirqreturn_t ret;\r\nint handled = 0;\r\nmc13xxx_lock(mc13xxx);\r\nret = mc13xxx_irq_handle(mc13xxx, MC13XXX_IRQSTAT0,\r\nMC13XXX_IRQMASK0, 0);\r\nif (ret > 0)\r\nhandled = 1;\r\nret = mc13xxx_irq_handle(mc13xxx, MC13XXX_IRQSTAT1,\r\nMC13XXX_IRQMASK1, 24);\r\nif (ret > 0)\r\nhandled = 1;\r\nmc13xxx_unlock(mc13xxx);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int mc13xxx_identify(struct mc13xxx *mc13xxx, enum mc13xxx_id *id)\r\n{\r\nu32 icid;\r\nu32 revision;\r\nconst char *name;\r\nint ret;\r\nret = mc13xxx_reg_read(mc13xxx, 46, &icid);\r\nif (ret)\r\nreturn ret;\r\nicid = (icid >> 6) & 0x7;\r\nswitch (icid) {\r\ncase 2:\r\n*id = MC13XXX_ID_MC13783;\r\nname = "mc13783";\r\nbreak;\r\ncase 7:\r\n*id = MC13XXX_ID_MC13892;\r\nname = "mc13892";\r\nbreak;\r\ndefault:\r\n*id = MC13XXX_ID_INVALID;\r\nbreak;\r\n}\r\nif (*id == MC13XXX_ID_MC13783 || *id == MC13XXX_ID_MC13892) {\r\nret = mc13xxx_reg_read(mc13xxx, MC13XXX_REVISION, &revision);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&mc13xxx->spidev->dev, "%s: rev: %d.%d, "\r\n"fin: %d, fab: %d, icid: %d/%d\n",\r\nmc13xxx_chipname[*id],\r\nmaskval(revision, MC13XXX_REVISION_REVFULL),\r\nmaskval(revision, MC13XXX_REVISION_REVMETAL),\r\nmaskval(revision, MC13XXX_REVISION_FIN),\r\nmaskval(revision, MC13XXX_REVISION_FAB),\r\nmaskval(revision, MC13XXX_REVISION_ICID),\r\nmaskval(revision, MC13XXX_REVISION_ICIDCODE));\r\n}\r\nif (*id != MC13XXX_ID_INVALID) {\r\nconst struct spi_device_id *devid =\r\nspi_get_device_id(mc13xxx->spidev);\r\nif (!devid || devid->driver_data != *id)\r\ndev_warn(&mc13xxx->spidev->dev, "device id doesn't "\r\n"match auto detection!\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *mc13xxx_get_chipname(struct mc13xxx *mc13xxx)\r\n{\r\nconst struct spi_device_id *devid =\r\nspi_get_device_id(mc13xxx->spidev);\r\nif (!devid)\r\nreturn NULL;\r\nreturn mc13xxx_chipname[devid->driver_data];\r\n}\r\nint mc13xxx_get_flags(struct mc13xxx *mc13xxx)\r\n{\r\nstruct mc13xxx_platform_data *pdata =\r\ndev_get_platdata(&mc13xxx->spidev->dev);\r\nreturn pdata->flags;\r\n}\r\nstatic irqreturn_t mc13783_handler_adcdone(int irq, void *data)\r\n{\r\nstruct mc13xxx_adcdone_data *adcdone_data = data;\r\nmc13xxx_irq_ack(adcdone_data->mc13xxx, irq);\r\ncomplete_all(&adcdone_data->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nint mc13783_adc_do_conversion(struct mc13783 *mc13783, unsigned int mode,\r\nunsigned int channel, unsigned int *sample)\r\n{\r\nstruct mc13xxx *mc13xxx = &mc13783->mc13xxx;\r\nu32 adc0, adc1, old_adc0;\r\nint i, ret;\r\nstruct mc13xxx_adcdone_data adcdone_data = {\r\n.mc13xxx = mc13xxx,\r\n};\r\ninit_completion(&adcdone_data.done);\r\ndev_dbg(&mc13xxx->spidev->dev, "%s\n", __func__);\r\nmc13xxx_lock(mc13xxx);\r\nif (mc13783->adcflags & MC13783_ADC_WORKING) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmc13783->adcflags |= MC13783_ADC_WORKING;\r\nmc13xxx_reg_read(mc13xxx, MC13783_ADC0, &old_adc0);\r\nadc0 = MC13783_ADC0_ADINC1 | MC13783_ADC0_ADINC2;\r\nadc1 = MC13783_ADC1_ADEN | MC13783_ADC1_ADTRIGIGN | MC13783_ADC1_ASC;\r\nif (channel > 7)\r\nadc1 |= MC13783_ADC1_ADSEL;\r\nswitch (mode) {\r\ncase MC13783_ADC_MODE_TS:\r\nadc0 |= MC13783_ADC0_ADREFEN | MC13783_ADC0_TSMOD0 |\r\nMC13783_ADC0_TSMOD1;\r\nadc1 |= 4 << MC13783_ADC1_CHAN1_SHIFT;\r\nbreak;\r\ncase MC13783_ADC_MODE_SINGLE_CHAN:\r\nadc0 |= old_adc0 & MC13783_ADC0_TSMOD_MASK;\r\nadc1 |= (channel & 0x7) << MC13783_ADC1_CHAN0_SHIFT;\r\nadc1 |= MC13783_ADC1_RAND;\r\nbreak;\r\ncase MC13783_ADC_MODE_MULT_CHAN:\r\nadc0 |= old_adc0 & MC13783_ADC0_TSMOD_MASK;\r\nadc1 |= 4 << MC13783_ADC1_CHAN1_SHIFT;\r\nbreak;\r\ndefault:\r\nmc13783_unlock(mc13783);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&mc13783->mc13xxx.spidev->dev, "%s: request irq\n", __func__);\r\nmc13xxx_irq_request(mc13xxx, MC13783_IRQ_ADCDONE,\r\nmc13783_handler_adcdone, __func__, &adcdone_data);\r\nmc13xxx_irq_ack(mc13xxx, MC13783_IRQ_ADCDONE);\r\nmc13xxx_reg_write(mc13xxx, MC13783_ADC0, adc0);\r\nmc13xxx_reg_write(mc13xxx, MC13783_ADC1, adc1);\r\nmc13xxx_unlock(mc13xxx);\r\nret = wait_for_completion_interruptible_timeout(&adcdone_data.done, HZ);\r\nif (!ret)\r\nret = -ETIMEDOUT;\r\nmc13xxx_lock(mc13xxx);\r\nmc13xxx_irq_free(mc13xxx, MC13783_IRQ_ADCDONE, &adcdone_data);\r\nif (ret > 0)\r\nfor (i = 0; i < 4; ++i) {\r\nret = mc13xxx_reg_read(mc13xxx,\r\nMC13783_ADC2, &sample[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nif (mode == MC13783_ADC_MODE_TS)\r\nmc13xxx_reg_write(mc13xxx, MC13783_ADC0, old_adc0);\r\nmc13783->adcflags &= ~MC13783_ADC_WORKING;\r\nout:\r\nmc13xxx_unlock(mc13xxx);\r\nreturn ret;\r\n}\r\nstatic int mc13xxx_add_subdevice_pdata(struct mc13xxx *mc13xxx,\r\nconst char *format, void *pdata, size_t pdata_size)\r\n{\r\nchar buf[30];\r\nconst char *name = mc13xxx_get_chipname(mc13xxx);\r\nstruct mfd_cell cell = {\r\n.platform_data = pdata,\r\n.pdata_size = pdata_size,\r\n};\r\nif (snprintf(buf, sizeof(buf), format, name) > sizeof(buf))\r\nreturn -E2BIG;\r\ncell.name = kmemdup(buf, strlen(buf) + 1, GFP_KERNEL);\r\nif (!cell.name)\r\nreturn -ENOMEM;\r\nreturn mfd_add_devices(&mc13xxx->spidev->dev, -1, &cell, 1, NULL, 0);\r\n}\r\nstatic int mc13xxx_add_subdevice(struct mc13xxx *mc13xxx, const char *format)\r\n{\r\nreturn mc13xxx_add_subdevice_pdata(mc13xxx, format, NULL, 0);\r\n}\r\nstatic int mc13xxx_probe(struct spi_device *spi)\r\n{\r\nstruct mc13xxx *mc13xxx;\r\nstruct mc13xxx_platform_data *pdata = dev_get_platdata(&spi->dev);\r\nenum mc13xxx_id id;\r\nint ret;\r\nmc13xxx = kzalloc(sizeof(*mc13xxx), GFP_KERNEL);\r\nif (!mc13xxx)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&spi->dev, mc13xxx);\r\nspi->mode = SPI_MODE_0 | SPI_CS_HIGH;\r\nspi->bits_per_word = 32;\r\nspi_setup(spi);\r\nmc13xxx->spidev = spi;\r\nmutex_init(&mc13xxx->lock);\r\nmc13xxx_lock(mc13xxx);\r\nret = mc13xxx_identify(mc13xxx, &id);\r\nif (ret || id == MC13XXX_ID_INVALID)\r\ngoto err_revision;\r\nret = mc13xxx_reg_write(mc13xxx, MC13XXX_IRQMASK0, 0x00ffffff);\r\nif (ret)\r\ngoto err_mask;\r\nret = mc13xxx_reg_write(mc13xxx, MC13XXX_IRQMASK1, 0x00ffffff);\r\nif (ret)\r\ngoto err_mask;\r\nret = request_threaded_irq(spi->irq, NULL, mc13xxx_irq_thread,\r\nIRQF_ONESHOT | IRQF_TRIGGER_HIGH, "mc13xxx", mc13xxx);\r\nif (ret) {\r\nerr_mask:\r\nerr_revision:\r\nmc13xxx_unlock(mc13xxx);\r\ndev_set_drvdata(&spi->dev, NULL);\r\nkfree(mc13xxx);\r\nreturn ret;\r\n}\r\nmc13xxx_unlock(mc13xxx);\r\nif (pdata->flags & MC13XXX_USE_ADC)\r\nmc13xxx_add_subdevice(mc13xxx, "%s-adc");\r\nif (pdata->flags & MC13XXX_USE_CODEC)\r\nmc13xxx_add_subdevice(mc13xxx, "%s-codec");\r\nif (pdata->flags & MC13XXX_USE_REGULATOR) {\r\nmc13xxx_add_subdevice_pdata(mc13xxx, "%s-regulator",\r\n&pdata->regulators, sizeof(pdata->regulators));\r\n}\r\nif (pdata->flags & MC13XXX_USE_RTC)\r\nmc13xxx_add_subdevice(mc13xxx, "%s-rtc");\r\nif (pdata->flags & MC13XXX_USE_TOUCHSCREEN)\r\nmc13xxx_add_subdevice(mc13xxx, "%s-ts");\r\nif (pdata->flags & MC13XXX_USE_LED)\r\nmc13xxx_add_subdevice_pdata(mc13xxx, "%s-led",\r\npdata->leds, sizeof(*pdata->leds));\r\nreturn 0;\r\n}\r\nstatic int __devexit mc13xxx_remove(struct spi_device *spi)\r\n{\r\nstruct mc13xxx *mc13xxx = dev_get_drvdata(&spi->dev);\r\nfree_irq(mc13xxx->spidev->irq, mc13xxx);\r\nmfd_remove_devices(&spi->dev);\r\nkfree(mc13xxx);\r\nreturn 0;\r\n}\r\nstatic int __init mc13xxx_init(void)\r\n{\r\nreturn spi_register_driver(&mc13xxx_driver);\r\n}\r\nstatic void __exit mc13xxx_exit(void)\r\n{\r\nspi_unregister_driver(&mc13xxx_driver);\r\n}
