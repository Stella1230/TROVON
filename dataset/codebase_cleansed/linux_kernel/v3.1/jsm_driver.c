static int __devinit jsm_probe_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint rc = 0;\r\nstruct jsm_board *brd;\r\nstatic int adapter_count = 0;\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Device enable FAILED\n");\r\ngoto out;\r\n}\r\nrc = pci_request_regions(pdev, "jsm");\r\nif (rc) {\r\ndev_err(&pdev->dev, "pci_request_region FAILED\n");\r\ngoto out_disable_device;\r\n}\r\nbrd = kzalloc(sizeof(struct jsm_board), GFP_KERNEL);\r\nif (!brd) {\r\ndev_err(&pdev->dev,\r\n"memory allocation for board structure failed\n");\r\nrc = -ENOMEM;\r\ngoto out_release_regions;\r\n}\r\nbrd->boardnum = adapter_count++;\r\nbrd->pci_dev = pdev;\r\nif (pdev->device == PCIE_DEVICE_ID_NEO_4_IBM)\r\nbrd->maxports = 4;\r\nelse if (pdev->device == PCI_DEVICE_ID_DIGI_NEO_8)\r\nbrd->maxports = 8;\r\nelse\r\nbrd->maxports = 2;\r\nspin_lock_init(&brd->bd_intr_lock);\r\nbrd->rev = pdev->revision;\r\nbrd->irq = pdev->irq;\r\njsm_printk(INIT, INFO, &brd->pci_dev,\r\n"jsm_found_board - NEO adapter\n");\r\nbrd->membase = pci_resource_start(pdev, 0);\r\nbrd->membase_end = pci_resource_end(pdev, 0);\r\nif (brd->membase & 1)\r\nbrd->membase &= ~3;\r\nelse\r\nbrd->membase &= ~15;\r\nbrd->bd_ops = &jsm_neo_ops;\r\nbrd->bd_uart_offset = 0x200;\r\nbrd->bd_dividend = 921600;\r\nbrd->re_map_membase = ioremap(brd->membase, pci_resource_len(pdev, 0));\r\nif (!brd->re_map_membase) {\r\ndev_err(&pdev->dev,\r\n"card has no PCI Memory resources, "\r\n"failing board.\n");\r\nrc = -ENOMEM;\r\ngoto out_kfree_brd;\r\n}\r\nrc = request_irq(brd->irq, brd->bd_ops->intr,\r\nIRQF_SHARED, "JSM", brd);\r\nif (rc) {\r\nprintk(KERN_WARNING "Failed to hook IRQ %d\n",brd->irq);\r\ngoto out_iounmap;\r\n}\r\nrc = jsm_tty_init(brd);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "Can't init tty devices (%d)\n", rc);\r\nrc = -ENXIO;\r\ngoto out_free_irq;\r\n}\r\nrc = jsm_uart_port_init(brd);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "Can't init uart port (%d)\n", rc);\r\nrc = -ENXIO;\r\ngoto out_free_irq;\r\n}\r\ndev_info(&pdev->dev, "board %d: Digi Neo (rev %d), irq %d\n",\r\nadapter_count, brd->rev, brd->irq);\r\nbrd->flipbuf = kzalloc(MYFLIPLEN, GFP_KERNEL);\r\nif (!brd->flipbuf) {\r\ndev_err(&pdev->dev, "memory allocation for flipbuf failed\n");\r\nrc = -ENOMEM;\r\ngoto out_free_uart;\r\n}\r\npci_set_drvdata(pdev, brd);\r\npci_save_state(pdev);\r\nreturn 0;\r\nout_free_uart:\r\njsm_remove_uart_port(brd);\r\nout_free_irq:\r\njsm_remove_uart_port(brd);\r\nfree_irq(brd->irq, brd);\r\nout_iounmap:\r\niounmap(brd->re_map_membase);\r\nout_kfree_brd:\r\nkfree(brd);\r\nout_release_regions:\r\npci_release_regions(pdev);\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __devexit jsm_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct jsm_board *brd = pci_get_drvdata(pdev);\r\nint i = 0;\r\njsm_remove_uart_port(brd);\r\nfree_irq(brd->irq, brd);\r\niounmap(brd->re_map_membase);\r\nfor (i = 0; i < brd->maxports; i++) {\r\nif (brd->channels[i]) {\r\nkfree(brd->channels[i]->ch_rqueue);\r\nkfree(brd->channels[i]->ch_equeue);\r\nkfree(brd->channels[i]->ch_wqueue);\r\nkfree(brd->channels[i]);\r\n}\r\n}\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(brd->flipbuf);\r\nkfree(brd);\r\n}\r\nstatic pci_ers_result_t jsm_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct jsm_board *brd = pci_get_drvdata(pdev);\r\njsm_remove_uart_port(brd);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t jsm_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nint rc;\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\npci_set_master(pdev);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void jsm_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct jsm_board *brd = pci_get_drvdata(pdev);\r\npci_restore_state(pdev);\r\njsm_uart_port_init(brd);\r\n}\r\nstatic int __init jsm_init_module(void)\r\n{\r\nint rc;\r\nrc = uart_register_driver(&jsm_uart_driver);\r\nif (!rc) {\r\nrc = pci_register_driver(&jsm_driver);\r\nif (rc)\r\nuart_unregister_driver(&jsm_uart_driver);\r\n}\r\nreturn rc;\r\n}\r\nstatic void __exit jsm_exit_module(void)\r\n{\r\npci_unregister_driver(&jsm_driver);\r\nuart_unregister_driver(&jsm_uart_driver);\r\n}
