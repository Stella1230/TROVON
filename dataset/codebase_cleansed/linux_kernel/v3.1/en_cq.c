static void mlx4_en_cq_event(struct mlx4_cq *cq, enum mlx4_event event)\r\n{\r\nreturn;\r\n}\r\nint mlx4_en_create_cq(struct mlx4_en_priv *priv,\r\nstruct mlx4_en_cq *cq,\r\nint entries, int ring, enum cq_type mode)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err;\r\ncq->size = entries;\r\nif (mode == RX)\r\ncq->buf_size = cq->size * sizeof(struct mlx4_cqe);\r\nelse\r\ncq->buf_size = sizeof(struct mlx4_cqe);\r\ncq->ring = ring;\r\ncq->is_tx = mode;\r\nspin_lock_init(&cq->lock);\r\nerr = mlx4_alloc_hwq_res(mdev->dev, &cq->wqres,\r\ncq->buf_size, 2 * PAGE_SIZE);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_en_map_buffer(&cq->wqres.buf);\r\nif (err)\r\nmlx4_free_hwq_res(mdev->dev, &cq->wqres, cq->buf_size);\r\nelse\r\ncq->buf = (struct mlx4_cqe *) cq->wqres.buf.direct.buf;\r\nreturn err;\r\n}\r\nint mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err = 0;\r\nchar name[25];\r\ncq->dev = mdev->pndev[priv->port];\r\ncq->mcq.set_ci_db = cq->wqres.db.db;\r\ncq->mcq.arm_db = cq->wqres.db.db + 1;\r\n*cq->mcq.set_ci_db = 0;\r\n*cq->mcq.arm_db = 0;\r\nmemset(cq->buf, 0, cq->buf_size);\r\nif (cq->is_tx == RX) {\r\nif (mdev->dev->caps.comp_pool) {\r\nif (!cq->vector) {\r\nsprintf(name , "%s-rx-%d", priv->dev->name, cq->ring);\r\nif (mlx4_assign_eq(mdev->dev, name, &cq->vector)) {\r\ncq->vector = (cq->ring + 1 + priv->port) %\r\nmdev->dev->caps.num_comp_vectors;\r\nmlx4_warn(mdev, "Failed Assigning an EQ to "\r\n"%s_rx-%d ,Falling back to legacy EQ's\n",\r\npriv->dev->name, cq->ring);\r\n}\r\n}\r\n} else {\r\ncq->vector = (cq->ring + 1 + priv->port) %\r\nmdev->dev->caps.num_comp_vectors;\r\n}\r\n} else {\r\nif (!cq->vector || !mdev->dev->caps.comp_pool) {\r\ncq->vector = 0;\r\n}\r\n}\r\nif (!cq->is_tx)\r\ncq->size = priv->rx_ring[cq->ring].actual_size;\r\nerr = mlx4_cq_alloc(mdev->dev, cq->size, &cq->wqres.mtt, &mdev->priv_uar,\r\ncq->wqres.db.dma, &cq->mcq, cq->vector, cq->is_tx);\r\nif (err)\r\nreturn err;\r\ncq->mcq.comp = cq->is_tx ? mlx4_en_tx_irq : mlx4_en_rx_irq;\r\ncq->mcq.event = mlx4_en_cq_event;\r\nif (cq->is_tx) {\r\ninit_timer(&cq->timer);\r\ncq->timer.function = mlx4_en_poll_tx_cq;\r\ncq->timer.data = (unsigned long) cq;\r\n} else {\r\nnetif_napi_add(cq->dev, &cq->napi, mlx4_en_poll_rx_cq, 64);\r\nnapi_enable(&cq->napi);\r\n}\r\nreturn 0;\r\n}\r\nvoid mlx4_en_destroy_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq,\r\nbool reserve_vectors)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nmlx4_en_unmap_buffer(&cq->wqres.buf);\r\nmlx4_free_hwq_res(mdev->dev, &cq->wqres, cq->buf_size);\r\nif (priv->mdev->dev->caps.comp_pool && cq->vector && !reserve_vectors)\r\nmlx4_release_eq(priv->mdev->dev, cq->vector);\r\ncq->buf_size = 0;\r\ncq->buf = NULL;\r\n}\r\nvoid mlx4_en_deactivate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nif (cq->is_tx)\r\ndel_timer(&cq->timer);\r\nelse {\r\nnapi_disable(&cq->napi);\r\nnetif_napi_del(&cq->napi);\r\n}\r\nmlx4_cq_free(mdev->dev, &cq->mcq);\r\n}\r\nint mlx4_en_set_cq_moder(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nreturn mlx4_cq_modify(priv->mdev->dev, &cq->mcq,\r\ncq->moder_cnt, cq->moder_time);\r\n}\r\nint mlx4_en_arm_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nmlx4_cq_arm(&cq->mcq, MLX4_CQ_DB_REQ_NOT, priv->mdev->uar_map,\r\n&priv->mdev->uar_lock);\r\nreturn 0;\r\n}
