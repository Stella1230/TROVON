static inline void ucb1400_ts_mode_int(struct snd_ac97 *ac97)\r\n{\r\nucb1400_reg_write(ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |\r\nUCB_TS_CR_MODE_INT);\r\n}\r\nstatic inline unsigned int ucb1400_ts_read_pressure(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nudelay(ts_delay_pressure);\r\nreturn ucb1400_adc_read(ucb->ac97, UCB_ADC_INP_TSPY, adcsync);\r\n}\r\nstatic inline unsigned int ucb1400_ts_read_xpos(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\r\nudelay(ts_delay);\r\nreturn ucb1400_adc_read(ucb->ac97, UCB_ADC_INP_TSPY, adcsync);\r\n}\r\nstatic inline unsigned int ucb1400_ts_read_ypos(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\r\nudelay(ts_delay);\r\nreturn ucb1400_adc_read(ucb->ac97, UCB_ADC_INP_TSPX, adcsync);\r\n}\r\nstatic inline unsigned int ucb1400_ts_read_xres(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nreturn ucb1400_adc_read(ucb->ac97, 0, adcsync);\r\n}\r\nstatic inline unsigned int ucb1400_ts_read_yres(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nreturn ucb1400_adc_read(ucb->ac97, 0, adcsync);\r\n}\r\nstatic inline int ucb1400_ts_pen_up(struct snd_ac97 *ac97)\r\n{\r\nunsigned short val = ucb1400_reg_read(ac97, UCB_TS_CR);\r\nreturn val & (UCB_TS_CR_TSPX_LOW | UCB_TS_CR_TSMX_LOW);\r\n}\r\nstatic inline void ucb1400_ts_irq_enable(struct snd_ac97 *ac97)\r\n{\r\nucb1400_reg_write(ac97, UCB_IE_CLEAR, UCB_IE_TSPX);\r\nucb1400_reg_write(ac97, UCB_IE_CLEAR, 0);\r\nucb1400_reg_write(ac97, UCB_IE_FAL, UCB_IE_TSPX);\r\n}\r\nstatic inline void ucb1400_ts_irq_disable(struct snd_ac97 *ac97)\r\n{\r\nucb1400_reg_write(ac97, UCB_IE_FAL, 0);\r\n}\r\nstatic void ucb1400_ts_evt_add(struct input_dev *idev, u16 pressure, u16 x, u16 y)\r\n{\r\ninput_report_abs(idev, ABS_X, x);\r\ninput_report_abs(idev, ABS_Y, y);\r\ninput_report_abs(idev, ABS_PRESSURE, pressure);\r\ninput_report_key(idev, BTN_TOUCH, 1);\r\ninput_sync(idev);\r\n}\r\nstatic void ucb1400_ts_event_release(struct input_dev *idev)\r\n{\r\ninput_report_abs(idev, ABS_PRESSURE, 0);\r\ninput_report_key(idev, BTN_TOUCH, 0);\r\ninput_sync(idev);\r\n}\r\nstatic void ucb1400_handle_pending_irq(struct ucb1400_ts *ucb)\r\n{\r\nunsigned int isr;\r\nisr = ucb1400_reg_read(ucb->ac97, UCB_IE_STATUS);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, isr);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0);\r\nif (isr & UCB_IE_TSPX)\r\nucb1400_ts_irq_disable(ucb->ac97);\r\nelse\r\ndev_dbg(&ucb->ts_idev->dev, "ucb1400: unexpected IE_STATUS = %#x\n", isr);\r\nenable_irq(ucb->irq);\r\n}\r\nstatic int ucb1400_ts_thread(void *_ucb)\r\n{\r\nstruct ucb1400_ts *ucb = _ucb;\r\nstruct task_struct *tsk = current;\r\nint valid = 0;\r\nstruct sched_param param = { .sched_priority = 1 };\r\nsched_setscheduler(tsk, SCHED_FIFO, &param);\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\nunsigned int x, y, p;\r\nlong timeout;\r\nucb->ts_restart = 0;\r\nif (ucb->irq_pending) {\r\nucb->irq_pending = 0;\r\nucb1400_handle_pending_irq(ucb);\r\n}\r\nucb1400_adc_enable(ucb->ac97);\r\nx = ucb1400_ts_read_xpos(ucb);\r\ny = ucb1400_ts_read_ypos(ucb);\r\np = ucb1400_ts_read_pressure(ucb);\r\nucb1400_adc_disable(ucb->ac97);\r\nucb1400_ts_mode_int(ucb->ac97);\r\nmsleep(10);\r\nif (ucb1400_ts_pen_up(ucb->ac97)) {\r\nucb1400_ts_irq_enable(ucb->ac97);\r\nif (valid) {\r\nucb1400_ts_event_release(ucb->ts_idev);\r\nvalid = 0;\r\n}\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\n} else {\r\nvalid = 1;\r\nucb1400_ts_evt_add(ucb->ts_idev, p, x, y);\r\ntimeout = msecs_to_jiffies(10);\r\n}\r\nwait_event_freezable_timeout(ucb->ts_wait,\r\nucb->irq_pending || ucb->ts_restart ||\r\nkthread_should_stop(), timeout);\r\n}\r\nif (valid)\r\nucb1400_ts_event_release(ucb->ts_idev);\r\nucb->ts_task = NULL;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ucb1400_hard_irq(int irqnr, void *devid)\r\n{\r\nstruct ucb1400_ts *ucb = devid;\r\nif (irqnr == ucb->irq) {\r\ndisable_irq_nosync(ucb->irq);\r\nucb->irq_pending = 1;\r\nwake_up(&ucb->ts_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int ucb1400_ts_open(struct input_dev *idev)\r\n{\r\nstruct ucb1400_ts *ucb = input_get_drvdata(idev);\r\nint ret = 0;\r\nBUG_ON(ucb->ts_task);\r\nucb->ts_task = kthread_run(ucb1400_ts_thread, ucb, "UCB1400_ts");\r\nif (IS_ERR(ucb->ts_task)) {\r\nret = PTR_ERR(ucb->ts_task);\r\nucb->ts_task = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ucb1400_ts_close(struct input_dev *idev)\r\n{\r\nstruct ucb1400_ts *ucb = input_get_drvdata(idev);\r\nif (ucb->ts_task)\r\nkthread_stop(ucb->ts_task);\r\nucb1400_ts_irq_disable(ucb->ac97);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR, 0);\r\n}\r\nstatic int ucb1400_ts_detect_irq(struct ucb1400_ts *ucb)\r\n{\r\nunsigned long mask, timeout;\r\nmask = probe_irq_on();\r\nucb1400_reg_write(ucb->ac97, UCB_IE_RIS, UCB_IE_ADC);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_FAL, UCB_IE_ADC);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0xffff);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_ADC_CR, UCB_ADC_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_ADC_CR, UCB_ADC_ENA | UCB_ADC_START);\r\ntimeout = jiffies + HZ/2;\r\nwhile (!(ucb1400_reg_read(ucb->ac97, UCB_ADC_DATA) &\r\nUCB_ADC_DAT_VALID)) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\nprintk(KERN_ERR "ucb1400: timed out in IRQ probe\n");\r\nprobe_irq_off(mask);\r\nreturn -ENODEV;\r\n}\r\n}\r\nucb1400_reg_write(ucb->ac97, UCB_ADC_CR, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_RIS, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_FAL, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0xffff);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0);\r\nucb->irq = probe_irq_off(mask);\r\nif (ucb->irq < 0 || ucb->irq == NO_IRQ)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ucb1400_ts_probe(struct platform_device *dev)\r\n{\r\nint error, x_res, y_res;\r\nu16 fcsr;\r\nstruct ucb1400_ts *ucb = dev->dev.platform_data;\r\nucb->ts_idev = input_allocate_device();\r\nif (!ucb->ts_idev) {\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\nif (ucb->irq < 0) {\r\nerror = ucb1400_ts_detect_irq(ucb);\r\nif (error) {\r\nprintk(KERN_ERR "UCB1400: IRQ probe failed\n");\r\ngoto err_free_devs;\r\n}\r\n}\r\ninit_waitqueue_head(&ucb->ts_wait);\r\nerror = request_irq(ucb->irq, ucb1400_hard_irq, IRQF_TRIGGER_RISING,\r\n"UCB1400", ucb);\r\nif (error) {\r\nprintk(KERN_ERR "ucb1400: unable to grab irq%d: %d\n",\r\nucb->irq, error);\r\ngoto err_free_devs;\r\n}\r\nprintk(KERN_DEBUG "UCB1400: found IRQ %d\n", ucb->irq);\r\ninput_set_drvdata(ucb->ts_idev, ucb);\r\nucb->ts_idev->dev.parent = &dev->dev;\r\nucb->ts_idev->name = "UCB1400 touchscreen interface";\r\nucb->ts_idev->id.vendor = ucb1400_reg_read(ucb->ac97,\r\nAC97_VENDOR_ID1);\r\nucb->ts_idev->id.product = ucb->id;\r\nucb->ts_idev->open = ucb1400_ts_open;\r\nucb->ts_idev->close = ucb1400_ts_close;\r\nucb->ts_idev->evbit[0] = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);\r\nucb->ts_idev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\nfcsr = ucb1400_reg_read(ucb->ac97, UCB_FCSR);\r\nucb1400_reg_write(ucb->ac97, UCB_FCSR, fcsr | UCB_FCSR_AVE);\r\nucb1400_adc_enable(ucb->ac97);\r\nx_res = ucb1400_ts_read_xres(ucb);\r\ny_res = ucb1400_ts_read_yres(ucb);\r\nucb1400_adc_disable(ucb->ac97);\r\nprintk(KERN_DEBUG "UCB1400: x/y = %d/%d\n", x_res, y_res);\r\ninput_set_abs_params(ucb->ts_idev, ABS_X, 0, x_res, 0, 0);\r\ninput_set_abs_params(ucb->ts_idev, ABS_Y, 0, y_res, 0, 0);\r\ninput_set_abs_params(ucb->ts_idev, ABS_PRESSURE, 0, 0, 0, 0);\r\nerror = input_register_device(ucb->ts_idev);\r\nif (error)\r\ngoto err_free_irq;\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(ucb->irq, ucb);\r\nerr_free_devs:\r\ninput_free_device(ucb->ts_idev);\r\nerr:\r\nreturn error;\r\n}\r\nstatic int ucb1400_ts_remove(struct platform_device *dev)\r\n{\r\nstruct ucb1400_ts *ucb = dev->dev.platform_data;\r\nfree_irq(ucb->irq, ucb);\r\ninput_unregister_device(ucb->ts_idev);\r\nreturn 0;\r\n}\r\nstatic int ucb1400_ts_resume(struct platform_device *dev)\r\n{\r\nstruct ucb1400_ts *ucb = dev->dev.platform_data;\r\nif (ucb->ts_task) {\r\nucb->ts_restart = 1;\r\nwake_up(&ucb->ts_wait);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ucb1400_ts_init(void)\r\n{\r\nreturn platform_driver_register(&ucb1400_ts_driver);\r\n}\r\nstatic void __exit ucb1400_ts_exit(void)\r\n{\r\nplatform_driver_unregister(&ucb1400_ts_driver);\r\n}
