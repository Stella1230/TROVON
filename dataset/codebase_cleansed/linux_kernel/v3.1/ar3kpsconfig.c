void Hci_log(u8 * log_string,u8 *data,u32 len)\r\n{\r\nint i;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("%s : ",log_string));\r\nfor (i = 0; i < len; i++) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("0x%02x ", data[i]));\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("\n...................................\n"));\r\n}\r\nint AthPSInitialize(struct ar3k_config_info *hdev)\r\n{\r\nint status = 0;\r\nif(hdev == NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Invalid Device handle received\n"));\r\nreturn A_ERROR;\r\n}\r\n#ifndef HCI_TRANSPORT_SDIO\r\nDECLARE_WAITQUEUE(wait, current);\r\n#endif\r\n#ifdef HCI_TRANSPORT_SDIO\r\nstatus = PSSendOps((void*)hdev);\r\n#else\r\nif(InitPSState(hdev) == -1) {\r\nreturn A_ERROR;\r\n}\r\nallow_signal(SIGKILL);\r\nadd_wait_queue(&PsCompleteEvent,&wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif(!kernel_thread(PSSendOps,(void*)hdev,CLONE_FS|CLONE_FILES|CLONE_SIGHAND|SIGCHLD)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Kthread Failed\n"));\r\nremove_wait_queue(&PsCompleteEvent,&wait);\r\nreturn A_ERROR;\r\n}\r\nwait_event_interruptible(PsCompleteEvent,(PSTagMode == false));\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&PsCompleteEvent,&wait);\r\n#endif\r\nreturn status;\r\n}\r\nint PSSendOps(void *arg)\r\n{\r\nint i;\r\nint status = 0;\r\nstruct ps_cmd_packet *HciCmdList;\r\nconst struct firmware* firmware;\r\nu32 numCmds;\r\nu8 *event;\r\nu8 *bufferToFree;\r\nstruct hci_dev *device;\r\nu8 *buffer;\r\nu32 len;\r\nu32 DevType;\r\nu8 *PsFileName;\r\nu8 *patchFileName;\r\nu8 *path = NULL;\r\nu8 *config_path = NULL;\r\nu8 config_bdaddr[MAX_BDADDR_FORMAT_LENGTH];\r\nstruct ar3k_config_info *hdev = (struct ar3k_config_info*)arg;\r\nstruct device *firmwareDev = NULL;\r\nstatus = 0;\r\nHciCmdList = NULL;\r\n#ifdef HCI_TRANSPORT_SDIO\r\ndevice = hdev->pBtStackHCIDev;\r\nfirmwareDev = device->parent;\r\n#else\r\ndevice = hdev;\r\nfirmwareDev = &device->dev;\r\nAthEnableSyncCommandOp(true);\r\n#endif\r\npath =(u8 *)A_MALLOC(MAX_FW_PATH_LEN);\r\nif(path == NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Malloc failed to allocate %d bytes for path\n", MAX_FW_PATH_LEN));\r\ngoto complete;\r\n}\r\nconfig_path = (u8 *) A_MALLOC(MAX_FW_PATH_LEN);\r\nif(config_path == NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Malloc failed to allocate %d bytes for config_path\n", MAX_FW_PATH_LEN));\r\ngoto complete;\r\n}\r\nif(A_ERROR == getDeviceType(hdev,&DevType)) {\r\nstatus = 1;\r\ngoto complete;\r\n}\r\nif(A_ERROR == ReadVersionInfo(hdev)) {\r\nstatus = 1;\r\ngoto complete;\r\n}\r\npatchFileName = PATCH_FILE;\r\nsnprintf(path, MAX_FW_PATH_LEN, "%s/%xcoex/",CONFIG_PATH,Rom_Version);\r\nif(DevType){\r\nif(DevType == 0xdeadc0de){\r\nPsFileName = PS_ASIC_FILE;\r\n} else{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" FPGA Test Image : %x %x \n",Rom_Version,Build_Version));\r\nif((Rom_Version == 0x99999999) && (Build_Version == 1)){\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("FPGA Test Image : Skipping Patch File load\n"));\r\npatchFileName = NULL;\r\n}\r\nPsFileName = PS_FPGA_FILE;\r\n}\r\n}\r\nelse{\r\nPsFileName = PS_ASIC_FILE;\r\n}\r\nsnprintf(config_path, MAX_FW_PATH_LEN, "%s%s",path,PsFileName);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("%x: FPGA/ASIC PS File Name %s\n", DevType,config_path));\r\nif(A_REQUEST_FIRMWARE(&firmware,config_path,firmwareDev) < 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("%s: firmware file open error\n", __FUNCTION__ ));\r\nstatus = 1;\r\ngoto complete;\r\n}\r\nif(NULL == firmware || firmware->size == 0) {\r\nstatus = 1;\r\ngoto complete;\r\n}\r\nbuffer = (u8 *)A_MALLOC(firmware->size);\r\nif(buffer != NULL) {\r\nmemcpy(buffer,firmware->data,firmware->size);\r\nlen = firmware->size;\r\nA_RELEASE_FIRMWARE(firmware);\r\nstatus = AthDoParsePS(buffer,len);\r\nkfree(buffer);\r\n} else {\r\nA_RELEASE_FIRMWARE(firmware);\r\n}\r\nif(patchFileName != NULL)\r\nsnprintf(config_path,\r\nMAX_FW_PATH_LEN, "%s%s",path,patchFileName);\r\nelse {\r\nstatus = 0;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Patch File Name %s\n", config_path));\r\nif((patchFileName == NULL) || (A_REQUEST_FIRMWARE(&firmware,config_path,firmwareDev) < 0)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("%s: firmware file open error\n", __FUNCTION__ ));\r\nstatus = 0;\r\n} else {\r\nif(NULL == firmware || firmware->size == 0) {\r\nstatus = 0;\r\n} else {\r\nbuffer = (u8 *)A_MALLOC(firmware->size);\r\nif(buffer != NULL) {\r\nmemcpy(buffer,firmware->data,firmware->size);\r\nlen = firmware->size;\r\nA_RELEASE_FIRMWARE(firmware);\r\nstatus = AthDoParsePatch(buffer,len);\r\nkfree(buffer);\r\n} else {\r\nA_RELEASE_FIRMWARE(firmware);\r\n}\r\n}\r\n}\r\nAthCreateCommandList(&HciCmdList,&numCmds);\r\nif(SendHCICommandWaitCommandComplete\r\n(hdev,\r\nHciCmdList[0].Hcipacket,\r\nHciCmdList[0].packetLen,\r\n&event,\r\n&bufferToFree) == 0) {\r\nif(ReadPSEvent(event) == 0) {\r\nif(bufferToFree != NULL) {\r\nkfree(bufferToFree);\r\n}\r\n#ifndef HCI_TRANSPORT_SDIO\r\nif(bdaddr && bdaddr[0] !='\0') {\r\nwrite_bdaddr(hdev,bdaddr,BDADDR_TYPE_STRING);\r\n}\r\n#endif\r\nstatus = 1;\r\ngoto complete;\r\n}\r\nif(bufferToFree != NULL) {\r\nkfree(bufferToFree);\r\n}\r\n} else {\r\nstatus = 0;\r\ngoto complete;\r\n}\r\nfor(i = 1; i <numCmds; i++) {\r\nif(SendHCICommandWaitCommandComplete\r\n(hdev,\r\nHciCmdList[i].Hcipacket,\r\nHciCmdList[i].packetLen,\r\n&event,\r\n&bufferToFree) == 0) {\r\nif(ReadPSEvent(event) != 0) {\r\nif(bufferToFree != NULL) {\r\nkfree(bufferToFree);\r\n}\r\nstatus = 1;\r\ngoto complete;\r\n}\r\nif(bufferToFree != NULL) {\r\nkfree(bufferToFree);\r\n}\r\n} else {\r\nstatus = 0;\r\ngoto complete;\r\n}\r\n}\r\n#ifdef HCI_TRANSPORT_SDIO\r\nif(BDADDR == false)\r\nif(hdev->bdaddr[0] !=0x00 ||\r\nhdev->bdaddr[1] !=0x00 ||\r\nhdev->bdaddr[2] !=0x00 ||\r\nhdev->bdaddr[3] !=0x00 ||\r\nhdev->bdaddr[4] !=0x00 ||\r\nhdev->bdaddr[5] !=0x00)\r\nwrite_bdaddr(hdev,hdev->bdaddr,BDADDR_TYPE_HEX);\r\n#ifndef HCI_TRANSPORT_SDIO\r\nif(bdaddr && bdaddr[0] != '\0') {\r\nwrite_bdaddr(hdev,bdaddr,BDADDR_TYPE_STRING);\r\n} else\r\n#endif\r\n#endif\r\n{\r\nsnprintf(config_path,MAX_FW_PATH_LEN, "%s%s",path,BDADDR_FILE);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Patch File Name %s\n", config_path));\r\nif(A_REQUEST_FIRMWARE(&firmware,config_path,firmwareDev) < 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("%s: firmware file open error\n", __FUNCTION__ ));\r\nstatus = 1;\r\ngoto complete;\r\n}\r\nif(NULL == firmware || firmware->size == 0) {\r\nstatus = 1;\r\ngoto complete;\r\n}\r\nlen = min_t(size_t, firmware->size, MAX_BDADDR_FORMAT_LENGTH - 1);\r\nmemcpy(config_bdaddr, firmware->data, len);\r\nconfig_bdaddr[len] = '\0';\r\nwrite_bdaddr(hdev,config_bdaddr,BDADDR_TYPE_STRING);\r\nA_RELEASE_FIRMWARE(firmware);\r\n}\r\ncomplete:\r\n#ifndef HCI_TRANSPORT_SDIO\r\nAthEnableSyncCommandOp(false);\r\nPSTagMode = false;\r\nwake_up_interruptible(&PsCompleteEvent);\r\n#endif\r\nif(NULL != HciCmdList) {\r\nAthFreeCommandList(&HciCmdList,numCmds);\r\n}\r\nif(path) {\r\nkfree(path);\r\n}\r\nif(config_path) {\r\nkfree(config_path);\r\n}\r\nreturn status;\r\n}\r\nint SendHCICommandWaitCommandComplete(struct ar3k_config_info *pConfig,\r\nu8 *pHCICommand,\r\nint CmdLength,\r\nu8 **ppEventBuffer,\r\nu8 **ppBufferToFree)\r\n{\r\nif(CmdLength == 0) {\r\nreturn A_ERROR;\r\n}\r\nHci_log("COM Write -->",pHCICommand,CmdLength);\r\nPSAcked = false;\r\nif(PSHciWritepacket(pConfig,pHCICommand,CmdLength) == 0) {\r\nreturn A_ERROR;\r\n}\r\nwait_event_interruptible(HciEvent,(PSAcked == true));\r\nif(NULL != HciEventpacket) {\r\n*ppEventBuffer = HciEventpacket;\r\n*ppBufferToFree = HciEventpacket;\r\n} else {\r\n*ppBufferToFree = NULL;\r\nreturn A_ERROR;\r\n}\r\nreturn 0;\r\n}\r\nint ReadPSEvent(u8* Data){\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" PS Event %x %x %x\n",Data[4],Data[5],Data[3]));\r\nif(Data[4] == 0xFC && Data[5] == 0x00)\r\n{\r\nswitch(Data[3]){\r\ncase 0x0B:\r\nreturn 0;\r\nbreak;\r\ncase 0x0C:\r\nreturn 0;\r\nbreak;\r\ncase 0x04:\r\nreturn 0;\r\nbreak;\r\ncase 0x1E:\r\nRom_Version = Data[9];\r\nRom_Version = ((Rom_Version << 8) |Data[8]);\r\nRom_Version = ((Rom_Version << 8) |Data[7]);\r\nRom_Version = ((Rom_Version << 8) |Data[6]);\r\nBuild_Version = Data[13];\r\nBuild_Version = ((Build_Version << 8) |Data[12]);\r\nBuild_Version = ((Build_Version << 8) |Data[11]);\r\nBuild_Version = ((Build_Version << 8) |Data[10]);\r\nreturn 0;\r\nbreak;\r\n}\r\n}\r\nreturn A_ERROR;\r\n}\r\nint str2ba(unsigned char *str_bdaddr,unsigned char *bdaddr)\r\n{\r\nunsigned char bdbyte[3];\r\nunsigned char *str_byte = str_bdaddr;\r\nint i,j;\r\nunsigned char colon_present = 0;\r\nif(NULL != strstr(str_bdaddr,":")) {\r\ncolon_present = 1;\r\n}\r\nbdbyte[2] = '\0';\r\nfor( i = 0,j = 5; i < 6; i++, j--) {\r\nbdbyte[0] = str_byte[0];\r\nbdbyte[1] = str_byte[1];\r\nbdaddr[j] = A_STRTOL(bdbyte,NULL,16);\r\nif(colon_present == 1) {\r\nstr_byte+=3;\r\n} else {\r\nstr_byte+=2;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint write_bdaddr(struct ar3k_config_info *pConfig,u8 *bdaddr,int type)\r\n{\r\nu8 bdaddr_cmd[] = { 0x0B, 0xFC, 0x0A, 0x01, 0x01,\r\n0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nu8 *event;\r\nu8 *bufferToFree = NULL;\r\nint result = A_ERROR;\r\nint inc,outc;\r\nif (type == BDADDR_TYPE_STRING)\r\nstr2ba(bdaddr,&bdaddr_cmd[7]);\r\nelse {\r\nfor(inc = 5 ,outc = 7; inc >=0; inc--, outc++)\r\nbdaddr_cmd[outc] = bdaddr[inc];\r\n}\r\nif(0 == SendHCICommandWaitCommandComplete(pConfig,bdaddr_cmd,\r\nsizeof(bdaddr_cmd),\r\n&event,&bufferToFree)) {\r\nif(event[4] == 0xFC && event[5] == 0x00){\r\nif(event[3] == 0x0B){\r\nresult = 0;\r\n}\r\n}\r\n}\r\nif(bufferToFree != NULL) {\r\nkfree(bufferToFree);\r\n}\r\nreturn result;\r\n}\r\nint ReadVersionInfo(struct ar3k_config_info *pConfig)\r\n{\r\nu8 hciCommand[] = {0x1E,0xfc,0x00};\r\nu8 *event;\r\nu8 *bufferToFree = NULL;\r\nint result = A_ERROR;\r\nif(0 == SendHCICommandWaitCommandComplete(pConfig,hciCommand,sizeof(hciCommand),&event,&bufferToFree)) {\r\nresult = ReadPSEvent(event);\r\n}\r\nif(bufferToFree != NULL) {\r\nkfree(bufferToFree);\r\n}\r\nreturn result;\r\n}\r\nint getDeviceType(struct ar3k_config_info *pConfig, u32 *code)\r\n{\r\nu8 hciCommand[] = {0x05,0xfc,0x05,0x00,0x00,0x00,0x00,0x04};\r\nu8 *event;\r\nu8 *bufferToFree = NULL;\r\nu32 reg;\r\nint result = A_ERROR;\r\n*code = 0;\r\nhciCommand[3] = (u8)(FPGA_REGISTER & 0xFF);\r\nhciCommand[4] = (u8)((FPGA_REGISTER >> 8) & 0xFF);\r\nhciCommand[5] = (u8)((FPGA_REGISTER >> 16) & 0xFF);\r\nhciCommand[6] = (u8)((FPGA_REGISTER >> 24) & 0xFF);\r\nif(0 == SendHCICommandWaitCommandComplete(pConfig,hciCommand,sizeof(hciCommand),&event,&bufferToFree)) {\r\nif(event[4] == 0xFC && event[5] == 0x00){\r\nswitch(event[3]){\r\ncase 0x05:\r\nreg = event[9];\r\nreg = ((reg << 8) |event[8]);\r\nreg = ((reg << 8) |event[7]);\r\nreg = ((reg << 8) |event[6]);\r\n*code = reg;\r\nresult = 0;\r\nbreak;\r\ncase 0x06:\r\nbreak;\r\n}\r\n}\r\n}\r\nif(bufferToFree != NULL) {\r\nkfree(bufferToFree);\r\n}\r\nreturn result;\r\n}
