static void jornada_parse_kbd(struct jornadakbd *jornadakbd)\r\n{\r\nstruct input_dev *input_dev = jornadakbd->poll_dev->input;\r\nunsigned short *keymap = jornadakbd->keymap;\r\nunsigned int sync_me = 0;\r\nunsigned int i, j;\r\nfor (i = 0; i < JORNADA_SCAN_SIZE; i++) {\r\nunsigned char new = jornadakbd->new_scan[i];\r\nunsigned char old = jornadakbd->old_scan[i];\r\nunsigned int xor = new ^ old;\r\nif (xor == 0)\r\ncontinue;\r\nfor (j = 0; j < 8; j++) {\r\nunsigned int bit = 1 << j;\r\nif (xor & bit) {\r\nunsigned int scancode = (i << 3) + j;\r\ninput_event(input_dev,\r\nEV_MSC, MSC_SCAN, scancode);\r\ninput_report_key(input_dev,\r\nkeymap[scancode],\r\n!(new & bit));\r\nsync_me = 1;\r\n}\r\n}\r\n}\r\nif (sync_me)\r\ninput_sync(input_dev);\r\n}\r\nstatic void jornada_scan_keyb(unsigned char *s)\r\n{\r\nint i;\r\nunsigned short ec_static, dc_static;\r\nunsigned char matrix_switch[] = {\r\n0xfd, 0xff,\r\n0xdf, 0xff,\r\n0x7f, 0xff,\r\n0xff, 0xfe,\r\n0xff, 0xfd,\r\n0xff, 0xf7,\r\n0xff, 0xbf,\r\n0xff, 0x7f,\r\n}, *t = matrix_switch;\r\nunsigned short matrix_PDE[] = {\r\n0xcc04, 0xf0cf,\r\n0xc40c, 0xf0cf,\r\n0x4c0c, 0xf0cf,\r\n0xcc0c, 0xf0cd,\r\n0xcc0c, 0xf0c7,\r\n0xcc0c, 0xf04f,\r\n0xcc0c, 0xd0cf,\r\n0xcc0c, 0x70cf,\r\n}, *y = matrix_PDE;\r\ndc_static = (__raw_readw(PDCR) & (~0xcc0c));\r\nec_static = (__raw_readw(PECR) & (~0xf0cf));\r\nfor (i = 0; i < 8; i++) {\r\n__raw_writew((dc_static | *y++), PDCR);\r\n__raw_writew((ec_static | *y++), PECR);\r\nudelay(5);\r\n__raw_writeb(*t++, PDDR);\r\n__raw_writeb(*t++, PEDR);\r\nudelay(50);\r\n*s++ = __raw_readb(PCDR);\r\n*s++ = __raw_readb(PFDR);\r\n}\r\n__raw_writeb(0xff, PDDR);\r\n__raw_writeb(0xff, PEDR);\r\n__raw_writew((dc_static | (0x5555 & 0xcc0c)),PDCR);\r\n__raw_writew((ec_static | (0x5555 & 0xf0cf)),PECR);\r\n*s++ = __raw_readb(PGDR);\r\n*s++ = __raw_readb(PHDR);\r\n}\r\nstatic void jornadakbd680_poll(struct input_polled_dev *dev)\r\n{\r\nstruct jornadakbd *jornadakbd = dev->private;\r\njornada_scan_keyb(jornadakbd->new_scan);\r\njornada_parse_kbd(jornadakbd);\r\nmemcpy(jornadakbd->old_scan, jornadakbd->new_scan, JORNADA_SCAN_SIZE);\r\n}\r\nstatic int __devinit jornada680kbd_probe(struct platform_device *pdev)\r\n{\r\nstruct jornadakbd *jornadakbd;\r\nstruct input_polled_dev *poll_dev;\r\nstruct input_dev *input_dev;\r\nint i, error;\r\njornadakbd = kzalloc(sizeof(struct jornadakbd), GFP_KERNEL);\r\nif (!jornadakbd)\r\nreturn -ENOMEM;\r\npoll_dev = input_allocate_polled_device();\r\nif (!poll_dev) {\r\nerror = -ENOMEM;\r\ngoto failed;\r\n}\r\nplatform_set_drvdata(pdev, jornadakbd);\r\njornadakbd->poll_dev = poll_dev;\r\nmemcpy(jornadakbd->keymap, jornada_scancodes,\r\nsizeof(jornadakbd->keymap));\r\npoll_dev->private = jornadakbd;\r\npoll_dev->poll = jornadakbd680_poll;\r\npoll_dev->poll_interval = 50;\r\ninput_dev = poll_dev->input;\r\ninput_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_REP);\r\ninput_dev->name = "HP Jornada 680 keyboard";\r\ninput_dev->phys = "jornadakbd/input0";\r\ninput_dev->keycode = jornadakbd->keymap;\r\ninput_dev->keycodesize = sizeof(unsigned short);\r\ninput_dev->keycodemax = ARRAY_SIZE(jornada_scancodes);\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->id.bustype = BUS_HOST;\r\nfor (i = 0; i < 128; i++)\r\nif (jornadakbd->keymap[i])\r\n__set_bit(jornadakbd->keymap[i], input_dev->keybit);\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\nerror = input_register_polled_device(jornadakbd->poll_dev);\r\nif (error)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\nprintk(KERN_ERR "Jornadakbd: failed to register driver, error: %d\n",\r\nerror);\r\nplatform_set_drvdata(pdev, NULL);\r\ninput_free_polled_device(poll_dev);\r\nkfree(jornadakbd);\r\nreturn error;\r\n}\r\nstatic int __devexit jornada680kbd_remove(struct platform_device *pdev)\r\n{\r\nstruct jornadakbd *jornadakbd = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\ninput_unregister_polled_device(jornadakbd->poll_dev);\r\ninput_free_polled_device(jornadakbd->poll_dev);\r\nkfree(jornadakbd);\r\nreturn 0;\r\n}\r\nstatic int __init jornada680kbd_init(void)\r\n{\r\nreturn platform_driver_register(&jornada680kbd_driver);\r\n}\r\nstatic void __exit jornada680kbd_exit(void)\r\n{\r\nplatform_driver_unregister(&jornada680kbd_driver);\r\n}
