static void pca9665_reset(void *pd)\r\n{\r\nstruct i2c_algo_pca_data *adap = pd;\r\npca_outw(adap, I2C_PCA_INDPTR, I2C_PCA_IPRESET);\r\npca_outw(adap, I2C_PCA_IND, 0xA5);\r\npca_outw(adap, I2C_PCA_IND, 0x5A);\r\n}\r\nstatic int pca_start(struct i2c_algo_pca_data *adap)\r\n{\r\nint sta = pca_get_con(adap);\r\nDEB2("=== START\n");\r\nsta |= I2C_PCA_CON_STA;\r\nsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);\r\npca_set_con(adap, sta);\r\nreturn pca_wait(adap);\r\n}\r\nstatic int pca_repeated_start(struct i2c_algo_pca_data *adap)\r\n{\r\nint sta = pca_get_con(adap);\r\nDEB2("=== REPEATED START\n");\r\nsta |= I2C_PCA_CON_STA;\r\nsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);\r\npca_set_con(adap, sta);\r\nreturn pca_wait(adap);\r\n}\r\nstatic void pca_stop(struct i2c_algo_pca_data *adap)\r\n{\r\nint sta = pca_get_con(adap);\r\nDEB2("=== STOP\n");\r\nsta |= I2C_PCA_CON_STO;\r\nsta &= ~(I2C_PCA_CON_STA|I2C_PCA_CON_SI);\r\npca_set_con(adap, sta);\r\n}\r\nstatic int pca_address(struct i2c_algo_pca_data *adap,\r\nstruct i2c_msg *msg)\r\n{\r\nint sta = pca_get_con(adap);\r\nint addr;\r\naddr = ((0x7f & msg->addr) << 1);\r\nif (msg->flags & I2C_M_RD)\r\naddr |= 1;\r\nDEB2("=== SLAVE ADDRESS %#04x+%c=%#04x\n",\r\nmsg->addr, msg->flags & I2C_M_RD ? 'R' : 'W', addr);\r\npca_outw(adap, I2C_PCA_DAT, addr);\r\nsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);\r\npca_set_con(adap, sta);\r\nreturn pca_wait(adap);\r\n}\r\nstatic int pca_tx_byte(struct i2c_algo_pca_data *adap,\r\n__u8 b)\r\n{\r\nint sta = pca_get_con(adap);\r\nDEB2("=== WRITE %#04x\n", b);\r\npca_outw(adap, I2C_PCA_DAT, b);\r\nsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);\r\npca_set_con(adap, sta);\r\nreturn pca_wait(adap);\r\n}\r\nstatic void pca_rx_byte(struct i2c_algo_pca_data *adap,\r\n__u8 *b, int ack)\r\n{\r\n*b = pca_inw(adap, I2C_PCA_DAT);\r\nDEB2("=== READ %#04x %s\n", *b, ack ? "ACK" : "NACK");\r\n}\r\nstatic int pca_rx_ack(struct i2c_algo_pca_data *adap,\r\nint ack)\r\n{\r\nint sta = pca_get_con(adap);\r\nsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI|I2C_PCA_CON_AA);\r\nif (ack)\r\nsta |= I2C_PCA_CON_AA;\r\npca_set_con(adap, sta);\r\nreturn pca_wait(adap);\r\n}\r\nstatic int pca_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct i2c_algo_pca_data *adap = i2c_adap->algo_data;\r\nstruct i2c_msg *msg = NULL;\r\nint curmsg;\r\nint numbytes = 0;\r\nint state;\r\nint ret;\r\nint completed = 1;\r\nunsigned long timeout = jiffies + i2c_adap->timeout;\r\nwhile ((state = pca_status(adap)) != 0xf8) {\r\nif (time_before(jiffies, timeout)) {\r\nmsleep(10);\r\n} else {\r\ndev_dbg(&i2c_adap->dev, "bus is not idle. status is "\r\n"%#04x\n", state);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nDEB1("{{{ XFER %d messages\n", num);\r\nif (i2c_debug >= 2) {\r\nfor (curmsg = 0; curmsg < num; curmsg++) {\r\nint addr, i;\r\nmsg = &msgs[curmsg];\r\naddr = (0x7f & msg->addr) ;\r\nif (msg->flags & I2C_M_RD)\r\nprintk(KERN_INFO " [%02d] RD %d bytes from %#02x [%#02x, ...]\n",\r\ncurmsg, msg->len, addr, (addr << 1) | 1);\r\nelse {\r\nprintk(KERN_INFO " [%02d] WR %d bytes to %#02x [%#02x%s",\r\ncurmsg, msg->len, addr, addr << 1,\r\nmsg->len == 0 ? "" : ", ");\r\nfor (i = 0; i < msg->len; i++)\r\nprintk("%#04x%s", msg->buf[i], i == msg->len - 1 ? "" : ", ");\r\nprintk("]\n");\r\n}\r\n}\r\n}\r\ncurmsg = 0;\r\nret = -EREMOTEIO;\r\nwhile (curmsg < num) {\r\nstate = pca_status(adap);\r\nDEB3("STATE is 0x%02x\n", state);\r\nmsg = &msgs[curmsg];\r\nswitch (state) {\r\ncase 0xf8:\r\ncompleted = pca_start(adap);\r\nbreak;\r\ncase 0x08:\r\ncase 0x10:\r\ncompleted = pca_address(adap, msg);\r\nbreak;\r\ncase 0x18:\r\ncase 0x28:\r\nif (numbytes < msg->len) {\r\ncompleted = pca_tx_byte(adap,\r\nmsg->buf[numbytes]);\r\nnumbytes++;\r\nbreak;\r\n}\r\ncurmsg++; numbytes = 0;\r\nif (curmsg == num)\r\npca_stop(adap);\r\nelse\r\ncompleted = pca_repeated_start(adap);\r\nbreak;\r\ncase 0x20:\r\nDEB2("NOT ACK received after SLA+W\n");\r\npca_stop(adap);\r\ngoto out;\r\ncase 0x40:\r\ncompleted = pca_rx_ack(adap, msg->len > 1);\r\nbreak;\r\ncase 0x50:\r\nif (numbytes < msg->len) {\r\npca_rx_byte(adap, &msg->buf[numbytes], 1);\r\nnumbytes++;\r\ncompleted = pca_rx_ack(adap,\r\nnumbytes < msg->len - 1);\r\nbreak;\r\n}\r\ncurmsg++; numbytes = 0;\r\nif (curmsg == num)\r\npca_stop(adap);\r\nelse\r\ncompleted = pca_repeated_start(adap);\r\nbreak;\r\ncase 0x48:\r\nDEB2("NOT ACK received after SLA+R\n");\r\npca_stop(adap);\r\ngoto out;\r\ncase 0x30:\r\nDEB2("NOT ACK received after data byte\n");\r\npca_stop(adap);\r\ngoto out;\r\ncase 0x38:\r\nDEB2("Arbitration lost\n");\r\npca_start(adap);\r\ngoto out;\r\ncase 0x58:\r\nif (numbytes == msg->len - 1) {\r\npca_rx_byte(adap, &msg->buf[numbytes], 0);\r\ncurmsg++; numbytes = 0;\r\nif (curmsg == num)\r\npca_stop(adap);\r\nelse\r\ncompleted = pca_repeated_start(adap);\r\n} else {\r\nDEB2("NOT ACK sent after data byte received. "\r\n"Not final byte. numbytes %d. len %d\n",\r\nnumbytes, msg->len);\r\npca_stop(adap);\r\ngoto out;\r\n}\r\nbreak;\r\ncase 0x70:\r\nDEB2("BUS ERROR - SDA Stuck low\n");\r\npca_reset(adap);\r\ngoto out;\r\ncase 0x90:\r\nDEB2("BUS ERROR - SCL Stuck low\n");\r\npca_reset(adap);\r\ngoto out;\r\ncase 0x00:\r\nDEB2("BUS ERROR - Illegal START or STOP\n");\r\npca_reset(adap);\r\ngoto out;\r\ndefault:\r\ndev_err(&i2c_adap->dev, "unhandled SIO state 0x%02x\n", state);\r\nbreak;\r\n}\r\nif (!completed)\r\ngoto out;\r\n}\r\nret = curmsg;\r\nout:\r\nDEB1("}}} transferred %d/%d messages. "\r\n"status is %#04x. control is %#04x\n",\r\ncurmsg, num, pca_status(adap),\r\npca_get_con(adap));\r\nreturn ret;\r\n}\r\nstatic u32 pca_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic unsigned int pca_probe_chip(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_algo_pca_data *pca_data = adap->algo_data;\r\npca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IADR);\r\npca_outw(pca_data, I2C_PCA_IND, 0xAA);\r\npca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_ITO);\r\npca_outw(pca_data, I2C_PCA_IND, 0x00);\r\npca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IADR);\r\nif (pca_inw(pca_data, I2C_PCA_IND) == 0xAA) {\r\nprintk(KERN_INFO "%s: PCA9665 detected.\n", adap->name);\r\nreturn I2C_PCA_CHIP_9665;\r\n} else {\r\nprintk(KERN_INFO "%s: PCA9564 detected.\n", adap->name);\r\nreturn I2C_PCA_CHIP_9564;\r\n}\r\n}\r\nstatic int pca_init(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_algo_pca_data *pca_data = adap->algo_data;\r\nadap->algo = &pca_algo;\r\nif (pca_probe_chip(adap) == I2C_PCA_CHIP_9564) {\r\nstatic int freqs[] = {330, 288, 217, 146, 88, 59, 44, 36};\r\nint clock;\r\nif (pca_data->i2c_clock > 7) {\r\nswitch (pca_data->i2c_clock) {\r\ncase 330000:\r\npca_data->i2c_clock = I2C_PCA_CON_330kHz;\r\nbreak;\r\ncase 288000:\r\npca_data->i2c_clock = I2C_PCA_CON_288kHz;\r\nbreak;\r\ncase 217000:\r\npca_data->i2c_clock = I2C_PCA_CON_217kHz;\r\nbreak;\r\ncase 146000:\r\npca_data->i2c_clock = I2C_PCA_CON_146kHz;\r\nbreak;\r\ncase 88000:\r\npca_data->i2c_clock = I2C_PCA_CON_88kHz;\r\nbreak;\r\ncase 59000:\r\npca_data->i2c_clock = I2C_PCA_CON_59kHz;\r\nbreak;\r\ncase 44000:\r\npca_data->i2c_clock = I2C_PCA_CON_44kHz;\r\nbreak;\r\ncase 36000:\r\npca_data->i2c_clock = I2C_PCA_CON_36kHz;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: Invalid I2C clock speed selected."\r\n" Using default 59kHz.\n", adap->name);\r\npca_data->i2c_clock = I2C_PCA_CON_59kHz;\r\n}\r\n} else {\r\nprintk(KERN_WARNING "%s: "\r\n"Choosing the clock frequency based on "\r\n"index is deprecated."\r\n" Use the nominal frequency.\n", adap->name);\r\n}\r\npca_reset(pca_data);\r\nclock = pca_clock(pca_data);\r\nprintk(KERN_INFO "%s: Clock frequency is %dkHz\n",\r\nadap->name, freqs[clock]);\r\npca_set_con(pca_data, I2C_PCA_CON_ENSIO | clock);\r\n} else {\r\nint clock;\r\nint mode;\r\nint tlow, thi;\r\nint min_tlow, min_thi;\r\nint raise_fall_time;\r\npca_data->reset_chip = pca9665_reset;\r\nif (pca_data->i2c_clock > 1265800) {\r\nprintk(KERN_WARNING "%s: I2C clock speed too high."\r\n" Using 1265.8kHz.\n", adap->name);\r\npca_data->i2c_clock = 1265800;\r\n}\r\nif (pca_data->i2c_clock < 60300) {\r\nprintk(KERN_WARNING "%s: I2C clock speed too low."\r\n" Using 60.3kHz.\n", adap->name);\r\npca_data->i2c_clock = 60300;\r\n}\r\nclock = pca_clock(pca_data) / 100;\r\nif (pca_data->i2c_clock > 10000) {\r\nmode = I2C_PCA_MODE_TURBO;\r\nmin_tlow = 14;\r\nmin_thi = 5;\r\nraise_fall_time = 22;\r\n} else if (pca_data->i2c_clock > 4000) {\r\nmode = I2C_PCA_MODE_FASTP;\r\nmin_tlow = 17;\r\nmin_thi = 9;\r\nraise_fall_time = 22;\r\n} else if (pca_data->i2c_clock > 1000) {\r\nmode = I2C_PCA_MODE_FAST;\r\nmin_tlow = 44;\r\nmin_thi = 20;\r\nraise_fall_time = 58;\r\n} else {\r\nmode = I2C_PCA_MODE_STD;\r\nmin_tlow = 157;\r\nmin_thi = 134;\r\nraise_fall_time = 127;\r\n}\r\nif (clock < 648) {\r\ntlow = 255;\r\nthi = 1000000 - clock * raise_fall_time;\r\nthi /= (I2C_PCA_OSC_PER * clock) - tlow;\r\n} else {\r\ntlow = (1000000 - clock * raise_fall_time) * min_tlow;\r\ntlow /= I2C_PCA_OSC_PER * clock * (min_thi + min_tlow);\r\nthi = tlow * min_thi / min_tlow;\r\n}\r\npca_reset(pca_data);\r\nprintk(KERN_INFO\r\n"%s: Clock frequency is %dHz\n", adap->name, clock * 100);\r\npca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IMODE);\r\npca_outw(pca_data, I2C_PCA_IND, mode);\r\npca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_ISCLL);\r\npca_outw(pca_data, I2C_PCA_IND, tlow);\r\npca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_ISCLH);\r\npca_outw(pca_data, I2C_PCA_IND, thi);\r\npca_set_con(pca_data, I2C_PCA_CON_ENSIO);\r\n}\r\nudelay(500);\r\nreturn 0;\r\n}\r\nint i2c_pca_add_bus(struct i2c_adapter *adap)\r\n{\r\nint rval;\r\nrval = pca_init(adap);\r\nif (rval)\r\nreturn rval;\r\nreturn i2c_add_adapter(adap);\r\n}\r\nint i2c_pca_add_numbered_bus(struct i2c_adapter *adap)\r\n{\r\nint rval;\r\nrval = pca_init(adap);\r\nif (rval)\r\nreturn rval;\r\nreturn i2c_add_numbered_adapter(adap);\r\n}
