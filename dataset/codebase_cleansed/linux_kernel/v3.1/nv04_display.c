static void\r\nnv04_display_store_initial_head_owner(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->chipset != 0x11) {\r\ndev_priv->crtc_owner = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_44);\r\nreturn;\r\n}\r\nif (nvReadMC(dev, NV_PBUS_DEBUG_1) & (1 << 28))\r\ndev_priv->crtc_owner = 0x4;\r\nelse {\r\nuint8_t slaved_on_A, slaved_on_B;\r\nbool tvA = false;\r\nbool tvB = false;\r\nslaved_on_B = NVReadVgaCrtc(dev, 1, NV_CIO_CRE_PIXEL_INDEX) &\r\n0x80;\r\nif (slaved_on_B)\r\ntvB = !(NVReadVgaCrtc(dev, 1, NV_CIO_CRE_LCD__INDEX) &\r\nMASK(NV_CIO_CRE_LCD_LCD_SELECT));\r\nslaved_on_A = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_PIXEL_INDEX) &\r\n0x80;\r\nif (slaved_on_A)\r\ntvA = !(NVReadVgaCrtc(dev, 0, NV_CIO_CRE_LCD__INDEX) &\r\nMASK(NV_CIO_CRE_LCD_LCD_SELECT));\r\nif (slaved_on_A && !tvA)\r\ndev_priv->crtc_owner = 0x0;\r\nelse if (slaved_on_B && !tvB)\r\ndev_priv->crtc_owner = 0x3;\r\nelse if (slaved_on_A)\r\ndev_priv->crtc_owner = 0x0;\r\nelse if (slaved_on_B)\r\ndev_priv->crtc_owner = 0x3;\r\nelse\r\ndev_priv->crtc_owner = 0x0;\r\n}\r\n}\r\nint\r\nnv04_display_early_init(struct drm_device *dev)\r\n{\r\nif (!nv_gf4_disp_arch(dev)) {\r\nuint32_t pmc_enable = nv_rd32(dev, NV03_PMC_ENABLE);\r\nif (!(pmc_enable & 1))\r\nnv_wr32(dev, NV03_PMC_ENABLE, pmc_enable | 1);\r\n}\r\nNVLockVgaCrtcs(dev, false);\r\nif (nv_two_heads(dev)) {\r\nnv04_display_store_initial_head_owner(dev);\r\nNVSetOwner(dev, 0);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_display_late_takedown(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (nv_two_heads(dev))\r\nNVSetOwner(dev, dev_priv->crtc_owner);\r\nNVLockVgaCrtcs(dev, true);\r\n}\r\nint\r\nnv04_display_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct dcb_table *dcb = &dev_priv->vbios.dcb;\r\nstruct drm_connector *connector, *ct;\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nint i, ret;\r\nNV_DEBUG_KMS(dev, "\n");\r\nnouveau_hw_save_vga_fonts(dev, 1);\r\ndrm_mode_config_init(dev);\r\ndrm_mode_create_scaling_mode_property(dev);\r\ndrm_mode_create_dithering_property(dev);\r\ndev->mode_config.funcs = (void *)&nouveau_mode_config_funcs;\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\nswitch (dev_priv->card_type) {\r\ncase NV_04:\r\ndev->mode_config.max_width = 2048;\r\ndev->mode_config.max_height = 2048;\r\nbreak;\r\ndefault:\r\ndev->mode_config.max_width = 4096;\r\ndev->mode_config.max_height = 4096;\r\nbreak;\r\n}\r\ndev->mode_config.fb_base = dev_priv->fb_phys;\r\nnv04_crtc_create(dev, 0);\r\nif (nv_two_heads(dev))\r\nnv04_crtc_create(dev, 1);\r\nfor (i = 0; i < dcb->entries; i++) {\r\nstruct dcb_entry *dcbent = &dcb->entry[i];\r\nconnector = nouveau_connector_create(dev, dcbent->connector);\r\nif (IS_ERR(connector))\r\ncontinue;\r\nswitch (dcbent->type) {\r\ncase OUTPUT_ANALOG:\r\nret = nv04_dac_create(connector, dcbent);\r\nbreak;\r\ncase OUTPUT_LVDS:\r\ncase OUTPUT_TMDS:\r\nret = nv04_dfp_create(connector, dcbent);\r\nbreak;\r\ncase OUTPUT_TV:\r\nif (dcbent->location == DCB_LOC_ON_CHIP)\r\nret = nv17_tv_create(connector, dcbent);\r\nelse\r\nret = nv04_tv_create(connector, dcbent);\r\nbreak;\r\ndefault:\r\nNV_WARN(dev, "DCB type %d not known\n", dcbent->type);\r\ncontinue;\r\n}\r\nif (ret)\r\ncontinue;\r\n}\r\nlist_for_each_entry_safe(connector, ct,\r\n&dev->mode_config.connector_list, head) {\r\nif (!connector->encoder_ids[0]) {\r\nNV_WARN(dev, "%s has no encoders, removing\n",\r\ndrm_get_connector_name(connector));\r\nconnector->funcs->destroy(connector);\r\n}\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\r\ncrtc->funcs->save(crtc);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct drm_encoder_helper_funcs *func = encoder->helper_private;\r\nfunc->save(encoder);\r\n}\r\nnouveau_irq_register(dev, 24, nv04_vblank_crtc0_isr);\r\nnouveau_irq_register(dev, 25, nv04_vblank_crtc1_isr);\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_display_destroy(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nNV_DEBUG_KMS(dev, "\n");\r\nnouveau_irq_unregister(dev, 24);\r\nnouveau_irq_unregister(dev, 25);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct drm_mode_set modeset = {\r\n.crtc = crtc,\r\n};\r\ncrtc->funcs->set_config(&modeset);\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct drm_encoder_helper_funcs *func = encoder->helper_private;\r\nfunc->restore(encoder);\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\r\ncrtc->funcs->restore(crtc);\r\ndrm_mode_config_cleanup(dev);\r\nnouveau_hw_save_vga_fonts(dev, 0);\r\n}\r\nint\r\nnv04_display_init(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nstruct drm_encoder_helper_funcs *func = encoder->helper_private;\r\nfunc->restore(encoder);\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\r\ncrtc->funcs->restore(crtc);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv04_vblank_crtc0_isr(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, NV_CRTC0_INTSTAT, NV_CRTC_INTR_VBLANK);\r\ndrm_handle_vblank(dev, 0);\r\n}\r\nstatic void\r\nnv04_vblank_crtc1_isr(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, NV_CRTC1_INTSTAT, NV_CRTC_INTR_VBLANK);\r\ndrm_handle_vblank(dev, 1);\r\n}
