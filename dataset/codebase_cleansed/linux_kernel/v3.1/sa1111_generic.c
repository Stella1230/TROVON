static int sa1111_pcmcia_hw_init(struct soc_pcmcia_socket *skt)\r\n{\r\nreturn soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));\r\n}\r\nstatic void sa1111_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)\r\n{\r\nsoc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));\r\n}\r\nvoid sa1111_pcmcia_socket_state(struct soc_pcmcia_socket *skt, struct pcmcia_state *state)\r\n{\r\nstruct sa1111_pcmcia_socket *s = to_skt(skt);\r\nunsigned long status = sa1111_readl(s->dev->mapbase + SA1111_PCSR);\r\nswitch (skt->nr) {\r\ncase 0:\r\nstate->detect = status & PCSR_S0_DETECT ? 0 : 1;\r\nstate->ready = status & PCSR_S0_READY ? 1 : 0;\r\nstate->bvd1 = status & PCSR_S0_BVD1 ? 1 : 0;\r\nstate->bvd2 = status & PCSR_S0_BVD2 ? 1 : 0;\r\nstate->wrprot = status & PCSR_S0_WP ? 1 : 0;\r\nstate->vs_3v = status & PCSR_S0_VS1 ? 0 : 1;\r\nstate->vs_Xv = status & PCSR_S0_VS2 ? 0 : 1;\r\nbreak;\r\ncase 1:\r\nstate->detect = status & PCSR_S1_DETECT ? 0 : 1;\r\nstate->ready = status & PCSR_S1_READY ? 1 : 0;\r\nstate->bvd1 = status & PCSR_S1_BVD1 ? 1 : 0;\r\nstate->bvd2 = status & PCSR_S1_BVD2 ? 1 : 0;\r\nstate->wrprot = status & PCSR_S1_WP ? 1 : 0;\r\nstate->vs_3v = status & PCSR_S1_VS1 ? 0 : 1;\r\nstate->vs_Xv = status & PCSR_S1_VS2 ? 0 : 1;\r\nbreak;\r\n}\r\n}\r\nint sa1111_pcmcia_configure_socket(struct soc_pcmcia_socket *skt, const socket_state_t *state)\r\n{\r\nstruct sa1111_pcmcia_socket *s = to_skt(skt);\r\nunsigned int pccr_skt_mask, pccr_set_mask, val;\r\nunsigned long flags;\r\nswitch (skt->nr) {\r\ncase 0:\r\npccr_skt_mask = PCCR_S0_RST|PCCR_S0_FLT|PCCR_S0_PWAITEN|PCCR_S0_PSE;\r\nbreak;\r\ncase 1:\r\npccr_skt_mask = PCCR_S1_RST|PCCR_S1_FLT|PCCR_S1_PWAITEN|PCCR_S1_PSE;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\npccr_set_mask = 0;\r\nif (state->Vcc != 0)\r\npccr_set_mask |= PCCR_S0_PWAITEN|PCCR_S1_PWAITEN;\r\nif (state->Vcc == 50)\r\npccr_set_mask |= PCCR_S0_PSE|PCCR_S1_PSE;\r\nif (state->flags & SS_RESET)\r\npccr_set_mask |= PCCR_S0_RST|PCCR_S1_RST;\r\nif (state->flags & SS_OUTPUT_ENA)\r\npccr_set_mask |= PCCR_S0_FLT|PCCR_S1_FLT;\r\nlocal_irq_save(flags);\r\nval = sa1111_readl(s->dev->mapbase + SA1111_PCCR);\r\nval &= ~pccr_skt_mask;\r\nval |= pccr_set_mask & pccr_skt_mask;\r\nsa1111_writel(val, s->dev->mapbase + SA1111_PCCR);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nvoid sa1111_pcmcia_socket_init(struct soc_pcmcia_socket *skt)\r\n{\r\nsoc_pcmcia_enable_irqs(skt, irqs, ARRAY_SIZE(irqs));\r\n}\r\nstatic void sa1111_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)\r\n{\r\nsoc_pcmcia_disable_irqs(skt, irqs, ARRAY_SIZE(irqs));\r\n}\r\nint sa1111_pcmcia_add(struct sa1111_dev *dev, struct pcmcia_low_level *ops,\r\nint (*add)(struct soc_pcmcia_socket *))\r\n{\r\nstruct sa1111_pcmcia_socket *s;\r\nint i, ret = 0;\r\nops->hw_init = sa1111_pcmcia_hw_init;\r\nops->hw_shutdown = sa1111_pcmcia_hw_shutdown;\r\nops->socket_state = sa1111_pcmcia_socket_state;\r\nops->socket_suspend = sa1111_pcmcia_socket_suspend;\r\nfor (i = 0; i < ops->nr; i++) {\r\ns = kzalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\ns->soc.nr = ops->first + i;\r\ns->soc.ops = ops;\r\ns->soc.socket.owner = ops->owner;\r\ns->soc.socket.dev.parent = &dev->dev;\r\ns->soc.socket.pci_irq = s->soc.nr ?\r\ndev->irq[IDX_IRQ_S0_READY_NINT] :\r\ndev->irq[IDX_IRQ_S1_READY_NINT];\r\ns->dev = dev;\r\nret = add(&s->soc);\r\nif (ret == 0) {\r\ns->next = dev_get_drvdata(&dev->dev);\r\ndev_set_drvdata(&dev->dev, s);\r\n} else\r\nkfree(s);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pcmcia_probe(struct sa1111_dev *dev)\r\n{\r\nvoid __iomem *base;\r\ndev_set_drvdata(&dev->dev, NULL);\r\nif (!request_mem_region(dev->res.start, 512,\r\nSA1111_DRIVER_NAME(dev)))\r\nreturn -EBUSY;\r\nbase = dev->mapbase;\r\nirqs[0].irq = dev->irq[IDX_IRQ_S0_CD_VALID];\r\nirqs[1].irq = dev->irq[IDX_IRQ_S0_BVD1_STSCHG];\r\nirqs[2].irq = dev->irq[IDX_IRQ_S1_CD_VALID];\r\nirqs[3].irq = dev->irq[IDX_IRQ_S1_BVD1_STSCHG];\r\nsa1111_writel(PCSSR_S0_SLEEP | PCSSR_S1_SLEEP, base + SA1111_PCSSR);\r\nsa1111_writel(PCCR_S0_FLT | PCCR_S1_FLT, base + SA1111_PCCR);\r\n#ifdef CONFIG_SA1100_BADGE4\r\npcmcia_badge4_init(&dev->dev);\r\n#endif\r\n#ifdef CONFIG_SA1100_JORNADA720\r\npcmcia_jornada720_init(&dev->dev);\r\n#endif\r\n#ifdef CONFIG_ARCH_LUBBOCK\r\npcmcia_lubbock_init(dev);\r\n#endif\r\n#ifdef CONFIG_ASSABET_NEPONSET\r\npcmcia_neponset_init(dev);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __devexit pcmcia_remove(struct sa1111_dev *dev)\r\n{\r\nstruct sa1111_pcmcia_socket *next, *s = dev_get_drvdata(&dev->dev);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nfor (; next = s->next, s; s = next) {\r\nsoc_pcmcia_remove_one(&s->soc);\r\nkfree(s);\r\n}\r\nrelease_mem_region(dev->res.start, 512);\r\nreturn 0;\r\n}\r\nstatic int __init sa1111_drv_pcmcia_init(void)\r\n{\r\nreturn sa1111_driver_register(&pcmcia_driver);\r\n}\r\nstatic void __exit sa1111_drv_pcmcia_exit(void)\r\n{\r\nsa1111_driver_unregister(&pcmcia_driver);\r\n}
