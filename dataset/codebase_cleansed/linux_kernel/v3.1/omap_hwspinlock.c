static int omap_hwspinlock_trylock(struct hwspinlock *lock)\r\n{\r\nstruct omap_hwspinlock *omap_lock = to_omap_hwspinlock(lock);\r\nreturn (SPINLOCK_NOTTAKEN == readl(omap_lock->addr));\r\n}\r\nstatic void omap_hwspinlock_unlock(struct hwspinlock *lock)\r\n{\r\nstruct omap_hwspinlock *omap_lock = to_omap_hwspinlock(lock);\r\nwritel(SPINLOCK_NOTTAKEN, omap_lock->addr);\r\n}\r\nstatic void omap_hwspinlock_relax(struct hwspinlock *lock)\r\n{\r\nndelay(50);\r\n}\r\nstatic int __devinit omap_hwspinlock_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_hwspinlock *omap_lock;\r\nstruct omap_hwspinlock_state *state;\r\nstruct hwspinlock *lock;\r\nstruct resource *res;\r\nvoid __iomem *io_base;\r\nint i, ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nio_base = ioremap(res->start, resource_size(res));\r\nif (!io_base) {\r\nret = -ENOMEM;\r\ngoto free_state;\r\n}\r\ni = readl(io_base + SYSSTATUS_OFFSET);\r\ni >>= SPINLOCK_NUMLOCKS_BIT_OFFSET;\r\nif (hweight_long(i & 0xf) != 1 || i > 8) {\r\nret = -EINVAL;\r\ngoto iounmap_base;\r\n}\r\nstate->num_locks = i * 32;\r\nstate->io_base = io_base;\r\nplatform_set_drvdata(pdev, state);\r\npm_runtime_enable(&pdev->dev);\r\nfor (i = 0; i < state->num_locks; i++) {\r\nomap_lock = kzalloc(sizeof(*omap_lock), GFP_KERNEL);\r\nif (!omap_lock) {\r\nret = -ENOMEM;\r\ngoto free_locks;\r\n}\r\nomap_lock->lock.dev = &pdev->dev;\r\nomap_lock->lock.owner = THIS_MODULE;\r\nomap_lock->lock.id = i;\r\nomap_lock->lock.ops = &omap_hwspinlock_ops;\r\nomap_lock->addr = io_base + LOCK_BASE_OFFSET + sizeof(u32) * i;\r\nret = hwspin_lock_register(&omap_lock->lock);\r\nif (ret) {\r\nkfree(omap_lock);\r\ngoto free_locks;\r\n}\r\n}\r\nreturn 0;\r\nfree_locks:\r\nwhile (--i >= 0) {\r\nlock = hwspin_lock_unregister(i);\r\nif (!lock) {\r\ndev_err(&pdev->dev, "%s: cleanups failed\n", __func__);\r\ncontinue;\r\n}\r\nomap_lock = to_omap_hwspinlock(lock);\r\nkfree(omap_lock);\r\n}\r\npm_runtime_disable(&pdev->dev);\r\niounmap_base:\r\niounmap(io_base);\r\nfree_state:\r\nkfree(state);\r\nreturn ret;\r\n}\r\nstatic int omap_hwspinlock_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_hwspinlock_state *state = platform_get_drvdata(pdev);\r\nstruct hwspinlock *lock;\r\nstruct omap_hwspinlock *omap_lock;\r\nint i;\r\nfor (i = 0; i < state->num_locks; i++) {\r\nlock = hwspin_lock_unregister(i);\r\nif (!lock) {\r\ndev_err(&pdev->dev, "%s: failed on %d\n", __func__, i);\r\nreturn -EBUSY;\r\n}\r\nomap_lock = to_omap_hwspinlock(lock);\r\nkfree(omap_lock);\r\n}\r\npm_runtime_disable(&pdev->dev);\r\niounmap(state->io_base);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic int __init omap_hwspinlock_init(void)\r\n{\r\nreturn platform_driver_register(&omap_hwspinlock_driver);\r\n}\r\nstatic void __exit omap_hwspinlock_exit(void)\r\n{\r\nplatform_driver_unregister(&omap_hwspinlock_driver);\r\n}
