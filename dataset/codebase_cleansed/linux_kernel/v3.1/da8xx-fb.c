static inline unsigned int lcdc_read(unsigned int addr)\r\n{\r\nreturn (unsigned int)__raw_readl(da8xx_fb_reg_base + (addr));\r\n}\r\nstatic inline void lcdc_write(unsigned int val, unsigned int addr)\r\n{\r\n__raw_writel(val, da8xx_fb_reg_base + (addr));\r\n}\r\nstatic inline void lcd_enable_raster(void)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_CTRL_REG);\r\nif (!(reg & LCD_RASTER_ENABLE))\r\nlcdc_write(reg | LCD_RASTER_ENABLE, LCD_RASTER_CTRL_REG);\r\n}\r\nstatic inline void lcd_disable_raster(void)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_CTRL_REG);\r\nif (reg & LCD_RASTER_ENABLE)\r\nlcdc_write(reg & ~LCD_RASTER_ENABLE, LCD_RASTER_CTRL_REG);\r\n}\r\nstatic void lcd_blit(int load_mode, struct da8xx_fb_par *par)\r\n{\r\nu32 start;\r\nu32 end;\r\nu32 reg_ras;\r\nu32 reg_dma;\r\nreg_ras = lcdc_read(LCD_RASTER_CTRL_REG);\r\nreg_ras &= ~(3 << 20);\r\nreg_dma = lcdc_read(LCD_DMA_CTRL_REG);\r\nif (load_mode == LOAD_DATA) {\r\nstart = par->dma_start;\r\nend = par->dma_end;\r\nreg_ras |= LCD_PALETTE_LOAD_MODE(DATA_ONLY);\r\nreg_dma |= LCD_END_OF_FRAME_INT_ENA;\r\nreg_dma |= LCD_DUAL_FRAME_BUFFER_ENABLE;\r\nlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\nlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\n} else if (load_mode == LOAD_PALETTE) {\r\nstart = par->p_palette_base;\r\nend = start + par->palette_sz - 1;\r\nreg_ras |= LCD_PALETTE_LOAD_MODE(PALETTE_ONLY);\r\nreg_ras |= LCD_PL_ENABLE;\r\nlcdc_write(start, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(end, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\n}\r\nlcdc_write(reg_dma, LCD_DMA_CTRL_REG);\r\nlcdc_write(reg_ras, LCD_RASTER_CTRL_REG);\r\nlcd_enable_raster();\r\n}\r\nstatic int lcd_cfg_dma(int burst_size)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_DMA_CTRL_REG) & 0x00000001;\r\nswitch (burst_size) {\r\ncase 1:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_1);\r\nbreak;\r\ncase 2:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_2);\r\nbreak;\r\ncase 4:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_4);\r\nbreak;\r\ncase 8:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_8);\r\nbreak;\r\ncase 16:\r\nreg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_16);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlcdc_write(reg, LCD_DMA_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic void lcd_cfg_ac_bias(int period, int transitions_per_int)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_TIMING_2_REG) & 0xFFF00000;\r\nreg |= LCD_AC_BIAS_FREQUENCY(period) |\r\nLCD_AC_BIAS_TRANSITIONS_PER_INT(transitions_per_int);\r\nlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\r\n}\r\nstatic void lcd_cfg_horizontal_sync(int back_porch, int pulse_width,\r\nint front_porch)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_TIMING_0_REG) & 0xf;\r\nreg |= ((back_porch & 0xff) << 24)\r\n| ((front_porch & 0xff) << 16)\r\n| ((pulse_width & 0x3f) << 10);\r\nlcdc_write(reg, LCD_RASTER_TIMING_0_REG);\r\n}\r\nstatic void lcd_cfg_vertical_sync(int back_porch, int pulse_width,\r\nint front_porch)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_TIMING_1_REG) & 0x3ff;\r\nreg |= ((back_porch & 0xff) << 24)\r\n| ((front_porch & 0xff) << 16)\r\n| ((pulse_width & 0x3f) << 10);\r\nlcdc_write(reg, LCD_RASTER_TIMING_1_REG);\r\n}\r\nstatic int lcd_cfg_display(const struct lcd_ctrl_config *cfg)\r\n{\r\nu32 reg;\r\nreg = lcdc_read(LCD_RASTER_CTRL_REG) & ~(LCD_TFT_MODE |\r\nLCD_MONO_8BIT_MODE |\r\nLCD_MONOCHROME_MODE);\r\nswitch (cfg->p_disp_panel->panel_shade) {\r\ncase MONOCHROME:\r\nreg |= LCD_MONOCHROME_MODE;\r\nif (cfg->mono_8bit_mode)\r\nreg |= LCD_MONO_8BIT_MODE;\r\nbreak;\r\ncase COLOR_ACTIVE:\r\nreg |= LCD_TFT_MODE;\r\nif (cfg->tft_alt_mode)\r\nreg |= LCD_TFT_ALT_ENABLE;\r\nbreak;\r\ncase COLOR_PASSIVE:\r\nif (cfg->stn_565_mode)\r\nreg |= LCD_STN_565_ENABLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg |= LCD_UNDERFLOW_INT_ENA;\r\nlcdc_write(reg, LCD_RASTER_CTRL_REG);\r\nreg = lcdc_read(LCD_RASTER_TIMING_2_REG);\r\nif (cfg->sync_ctrl)\r\nreg |= LCD_SYNC_CTRL;\r\nelse\r\nreg &= ~LCD_SYNC_CTRL;\r\nif (cfg->sync_edge)\r\nreg |= LCD_SYNC_EDGE;\r\nelse\r\nreg &= ~LCD_SYNC_EDGE;\r\nif (cfg->invert_line_clock)\r\nreg |= LCD_INVERT_LINE_CLOCK;\r\nelse\r\nreg &= ~LCD_INVERT_LINE_CLOCK;\r\nif (cfg->invert_frm_clock)\r\nreg |= LCD_INVERT_FRAME_CLOCK;\r\nelse\r\nreg &= ~LCD_INVERT_FRAME_CLOCK;\r\nlcdc_write(reg, LCD_RASTER_TIMING_2_REG);\r\nreturn 0;\r\n}\r\nstatic int lcd_cfg_frame_buffer(struct da8xx_fb_par *par, u32 width, u32 height,\r\nu32 bpp, u32 raster_order)\r\n{\r\nu32 reg;\r\nwidth &= 0x3f0;\r\nreg = lcdc_read(LCD_RASTER_TIMING_0_REG);\r\nreg &= 0xfffffc00;\r\nreg |= ((width >> 4) - 1) << 4;\r\nlcdc_write(reg, LCD_RASTER_TIMING_0_REG);\r\nreg = lcdc_read(LCD_RASTER_TIMING_1_REG);\r\nreg = ((height - 1) & 0x3ff) | (reg & 0xfffffc00);\r\nlcdc_write(reg, LCD_RASTER_TIMING_1_REG);\r\nreg = lcdc_read(LCD_RASTER_CTRL_REG) & ~(1 << 8);\r\nif (raster_order)\r\nreg |= LCD_RASTER_ORDER;\r\nlcdc_write(reg, LCD_RASTER_CTRL_REG);\r\nswitch (bpp) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 16:\r\npar->palette_sz = 16 * 2;\r\nbreak;\r\ncase 8:\r\npar->palette_sz = 256 * 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct da8xx_fb_par *par = info->par;\r\nunsigned short *palette = (unsigned short *) par->v_palette_base;\r\nu_short pal;\r\nint update_hw = 0;\r\nif (regno > 255)\r\nreturn 1;\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR)\r\nreturn 1;\r\nif (info->var.bits_per_pixel == 8) {\r\nred >>= 4;\r\ngreen >>= 8;\r\nblue >>= 12;\r\npal = (red & 0x0f00);\r\npal |= (green & 0x00f0);\r\npal |= (blue & 0x000f);\r\nif (palette[regno] != pal) {\r\nupdate_hw = 1;\r\npalette[regno] = pal;\r\n}\r\n} else if ((info->var.bits_per_pixel == 16) && regno < 16) {\r\nred >>= (16 - info->var.red.length);\r\nred <<= info->var.red.offset;\r\ngreen >>= (16 - info->var.green.length);\r\ngreen <<= info->var.green.offset;\r\nblue >>= (16 - info->var.blue.length);\r\nblue <<= info->var.blue.offset;\r\npar->pseudo_palette[regno] = red | green | blue;\r\nif (palette[0] != 0x4000) {\r\nupdate_hw = 1;\r\npalette[0] = 0x4000;\r\n}\r\n}\r\nif (update_hw)\r\nlcd_blit(LOAD_PALETTE, par);\r\nreturn 0;\r\n}\r\nstatic void lcd_reset(struct da8xx_fb_par *par)\r\n{\r\nlcd_disable_raster();\r\nlcdc_write(0, LCD_DMA_CTRL_REG);\r\nlcdc_write(0, LCD_RASTER_CTRL_REG);\r\n}\r\nstatic void lcd_calc_clk_divider(struct da8xx_fb_par *par)\r\n{\r\nunsigned int lcd_clk, div;\r\nlcd_clk = clk_get_rate(par->lcdc_clk);\r\ndiv = lcd_clk / par->pxl_clk;\r\nlcdc_write(LCD_CLK_DIVISOR(div) |\r\n(LCD_RASTER_MODE & 0x1), LCD_CTRL_REG);\r\n}\r\nstatic int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,\r\nstruct da8xx_panel *panel)\r\n{\r\nu32 bpp;\r\nint ret = 0;\r\nlcd_reset(par);\r\nlcd_calc_clk_divider(par);\r\nif (panel->invert_pxl_clk)\r\nlcdc_write((lcdc_read(LCD_RASTER_TIMING_2_REG) |\r\nLCD_INVERT_PIXEL_CLOCK), LCD_RASTER_TIMING_2_REG);\r\nelse\r\nlcdc_write((lcdc_read(LCD_RASTER_TIMING_2_REG) &\r\n~LCD_INVERT_PIXEL_CLOCK), LCD_RASTER_TIMING_2_REG);\r\nret = lcd_cfg_dma(cfg->dma_burst_sz);\r\nif (ret < 0)\r\nreturn ret;\r\nlcd_cfg_ac_bias(cfg->ac_bias, cfg->ac_bias_intrpt);\r\nlcd_cfg_vertical_sync(panel->vbp, panel->vsw, panel->vfp);\r\nlcd_cfg_horizontal_sync(panel->hbp, panel->hsw, panel->hfp);\r\nret = lcd_cfg_display(cfg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (QVGA != cfg->p_disp_panel->panel_type)\r\nreturn -EINVAL;\r\nif (cfg->bpp <= cfg->p_disp_panel->max_bpp &&\r\ncfg->bpp >= cfg->p_disp_panel->min_bpp)\r\nbpp = cfg->bpp;\r\nelse\r\nbpp = cfg->p_disp_panel->max_bpp;\r\nif (bpp == 12)\r\nbpp = 16;\r\nret = lcd_cfg_frame_buffer(par, (unsigned int)panel->width,\r\n(unsigned int)panel->height, bpp,\r\ncfg->raster_order);\r\nif (ret < 0)\r\nreturn ret;\r\nlcdc_write((lcdc_read(LCD_RASTER_CTRL_REG) & 0xfff00fff) |\r\n(cfg->fdd << 12), LCD_RASTER_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t lcdc_irq_handler(int irq, void *arg)\r\n{\r\nstruct da8xx_fb_par *par = arg;\r\nu32 stat = lcdc_read(LCD_STAT_REG);\r\nu32 reg_ras;\r\nif ((stat & LCD_SYNC_LOST) && (stat & LCD_FIFO_UNDERFLOW)) {\r\nlcd_disable_raster();\r\nlcdc_write(stat, LCD_STAT_REG);\r\nlcd_enable_raster();\r\n} else if (stat & LCD_PL_LOAD_DONE) {\r\nlcd_disable_raster();\r\nlcdc_write(stat, LCD_STAT_REG);\r\nreg_ras = lcdc_read(LCD_RASTER_CTRL_REG);\r\nreg_ras &= ~LCD_PL_ENABLE;\r\nlcdc_write(reg_ras, LCD_RASTER_CTRL_REG);\r\nlcd_blit(LOAD_DATA, par);\r\n} else {\r\nlcdc_write(stat, LCD_STAT_REG);\r\nif (stat & LCD_END_OF_FRAME0) {\r\nlcdc_write(par->dma_start,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_0_REG);\r\nlcdc_write(par->dma_end,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);\r\npar->vsync_flag = 1;\r\nwake_up_interruptible(&par->vsync_wait);\r\n}\r\nif (stat & LCD_END_OF_FRAME1) {\r\nlcdc_write(par->dma_start,\r\nLCD_DMA_FRM_BUF_BASE_ADDR_1_REG);\r\nlcdc_write(par->dma_end,\r\nLCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);\r\npar->vsync_flag = 1;\r\nwake_up_interruptible(&par->vsync_wait);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint err = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 4:\r\nvar->red.offset = 0;\r\nvar->red.length = 4;\r\nvar->green.offset = 0;\r\nvar->green.length = 4;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 4;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nreturn err;\r\n}\r\nstatic int lcd_da8xx_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct da8xx_fb_par *par;\r\npar = container_of(nb, struct da8xx_fb_par, freq_transition);\r\nif (val == CPUFREQ_PRECHANGE) {\r\nlcd_disable_raster();\r\n} else if (val == CPUFREQ_POSTCHANGE) {\r\nlcd_calc_clk_divider(par);\r\nlcd_enable_raster();\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int lcd_da8xx_cpufreq_register(struct da8xx_fb_par *par)\r\n{\r\npar->freq_transition.notifier_call = lcd_da8xx_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&par->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void lcd_da8xx_cpufreq_deregister(struct da8xx_fb_par *par)\r\n{\r\ncpufreq_unregister_notifier(&par->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic int __devexit fb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&dev->dev);\r\nif (info) {\r\nstruct da8xx_fb_par *par = info->par;\r\n#ifdef CONFIG_CPU_FREQ\r\nlcd_da8xx_cpufreq_deregister(par);\r\n#endif\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(0);\r\nlcd_disable_raster();\r\nlcdc_write(0, LCD_RASTER_CTRL_REG);\r\nlcdc_write(0, LCD_DMA_CTRL_REG);\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\ndma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base,\r\npar->p_palette_base);\r\ndma_free_coherent(NULL, par->vram_size, par->vram_virt,\r\npar->vram_phys);\r\nfree_irq(par->irq, par);\r\nclk_disable(par->lcdc_clk);\r\nclk_put(par->lcdc_clk);\r\nframebuffer_release(info);\r\niounmap((void __iomem *)da8xx_fb_reg_base);\r\nrelease_mem_region(lcdc_regs->start, resource_size(lcdc_regs));\r\n}\r\nreturn 0;\r\n}\r\nstatic int fb_wait_for_vsync(struct fb_info *info)\r\n{\r\nstruct da8xx_fb_par *par = info->par;\r\nint ret;\r\npar->vsync_flag = 0;\r\nret = wait_event_interruptible_timeout(par->vsync_wait,\r\npar->vsync_flag != 0,\r\npar->vsync_timeout);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int fb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct lcd_sync_arg sync_arg;\r\nswitch (cmd) {\r\ncase FBIOGET_CONTRAST:\r\ncase FBIOPUT_CONTRAST:\r\ncase FBIGET_BRIGHTNESS:\r\ncase FBIPUT_BRIGHTNESS:\r\ncase FBIGET_COLOR:\r\ncase FBIPUT_COLOR:\r\nreturn -ENOTTY;\r\ncase FBIPUT_HSYNC:\r\nif (copy_from_user(&sync_arg, (char *)arg,\r\nsizeof(struct lcd_sync_arg)))\r\nreturn -EFAULT;\r\nlcd_cfg_horizontal_sync(sync_arg.back_porch,\r\nsync_arg.pulse_width,\r\nsync_arg.front_porch);\r\nbreak;\r\ncase FBIPUT_VSYNC:\r\nif (copy_from_user(&sync_arg, (char *)arg,\r\nsizeof(struct lcd_sync_arg)))\r\nreturn -EFAULT;\r\nlcd_cfg_vertical_sync(sync_arg.back_porch,\r\nsync_arg.pulse_width,\r\nsync_arg.front_porch);\r\nbreak;\r\ncase FBIO_WAITFORVSYNC:\r\nreturn fb_wait_for_vsync(info);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct da8xx_fb_par *par = info->par;\r\nint ret = 0;\r\nif (par->blank == blank)\r\nreturn 0;\r\npar->blank = blank;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(1);\r\nlcd_enable_raster();\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(0);\r\nlcd_disable_raster();\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int da8xx_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nint ret = 0;\r\nstruct fb_var_screeninfo new_var;\r\nstruct da8xx_fb_par *par = fbi->par;\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nunsigned int end;\r\nunsigned int start;\r\nif (var->xoffset != fbi->var.xoffset ||\r\nvar->yoffset != fbi->var.yoffset) {\r\nmemcpy(&new_var, &fbi->var, sizeof(new_var));\r\nnew_var.xoffset = var->xoffset;\r\nnew_var.yoffset = var->yoffset;\r\nif (fb_check_var(&new_var, fbi))\r\nret = -EINVAL;\r\nelse {\r\nmemcpy(&fbi->var, &new_var, sizeof(new_var));\r\nstart = fix->smem_start +\r\nnew_var.yoffset * fix->line_length +\r\nnew_var.xoffset * var->bits_per_pixel / 8;\r\nend = start + var->yres * fix->line_length - 1;\r\npar->dma_start = start;\r\npar->dma_end = end;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit fb_probe(struct platform_device *device)\r\n{\r\nstruct da8xx_lcdc_platform_data *fb_pdata =\r\ndevice->dev.platform_data;\r\nstruct lcd_ctrl_config *lcd_cfg;\r\nstruct da8xx_panel *lcdc_info;\r\nstruct fb_info *da8xx_fb_info;\r\nstruct clk *fb_clk = NULL;\r\nstruct da8xx_fb_par *par;\r\nresource_size_t len;\r\nint ret, i;\r\nif (fb_pdata == NULL) {\r\ndev_err(&device->dev, "Can not get platform data\n");\r\nreturn -ENOENT;\r\n}\r\nlcdc_regs = platform_get_resource(device, IORESOURCE_MEM, 0);\r\nif (!lcdc_regs) {\r\ndev_err(&device->dev,\r\n"Can not get memory resource for LCD controller\n");\r\nreturn -ENOENT;\r\n}\r\nlen = resource_size(lcdc_regs);\r\nlcdc_regs = request_mem_region(lcdc_regs->start, len, lcdc_regs->name);\r\nif (!lcdc_regs)\r\nreturn -EBUSY;\r\nda8xx_fb_reg_base = (resource_size_t)ioremap(lcdc_regs->start, len);\r\nif (!da8xx_fb_reg_base) {\r\nret = -EBUSY;\r\ngoto err_request_mem;\r\n}\r\nfb_clk = clk_get(&device->dev, NULL);\r\nif (IS_ERR(fb_clk)) {\r\ndev_err(&device->dev, "Can not get device clock\n");\r\nret = -ENODEV;\r\ngoto err_ioremap;\r\n}\r\nret = clk_enable(fb_clk);\r\nif (ret)\r\ngoto err_clk_put;\r\nfor (i = 0, lcdc_info = known_lcd_panels;\r\ni < ARRAY_SIZE(known_lcd_panels);\r\ni++, lcdc_info++) {\r\nif (strcmp(fb_pdata->type, lcdc_info->name) == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(known_lcd_panels)) {\r\ndev_err(&device->dev, "GLCD: No valid panel found\n");\r\nret = -ENODEV;\r\ngoto err_clk_disable;\r\n} else\r\ndev_info(&device->dev, "GLCD: Found %s panel\n",\r\nfb_pdata->type);\r\nlcd_cfg = (struct lcd_ctrl_config *)fb_pdata->controller_data;\r\nda8xx_fb_info = framebuffer_alloc(sizeof(struct da8xx_fb_par),\r\n&device->dev);\r\nif (!da8xx_fb_info) {\r\ndev_dbg(&device->dev, "Memory allocation failed for fb_info\n");\r\nret = -ENOMEM;\r\ngoto err_clk_disable;\r\n}\r\npar = da8xx_fb_info->par;\r\npar->lcdc_clk = fb_clk;\r\npar->pxl_clk = lcdc_info->pxl_clk;\r\nif (fb_pdata->panel_power_ctrl) {\r\npar->panel_power_ctrl = fb_pdata->panel_power_ctrl;\r\npar->panel_power_ctrl(1);\r\n}\r\nif (lcd_init(par, lcd_cfg, lcdc_info) < 0) {\r\ndev_err(&device->dev, "lcd_init failed\n");\r\nret = -EFAULT;\r\ngoto err_release_fb;\r\n}\r\npar->vram_size = lcdc_info->width * lcdc_info->height * lcd_cfg->bpp;\r\npar->vram_size = PAGE_ALIGN(par->vram_size/8);\r\npar->vram_size = par->vram_size * LCD_NUM_BUFFERS;\r\npar->vram_virt = dma_alloc_coherent(NULL,\r\npar->vram_size,\r\n(resource_size_t *) &par->vram_phys,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!par->vram_virt) {\r\ndev_err(&device->dev,\r\n"GLCD: kmalloc for frame buffer failed\n");\r\nret = -EINVAL;\r\ngoto err_release_fb;\r\n}\r\nda8xx_fb_info->screen_base = (char __iomem *) par->vram_virt;\r\nda8xx_fb_fix.smem_start = par->vram_phys;\r\nda8xx_fb_fix.smem_len = par->vram_size;\r\nda8xx_fb_fix.line_length = (lcdc_info->width * lcd_cfg->bpp) / 8;\r\npar->dma_start = par->vram_phys;\r\npar->dma_end = par->dma_start + lcdc_info->height *\r\nda8xx_fb_fix.line_length - 1;\r\npar->v_palette_base = dma_alloc_coherent(NULL,\r\nPALETTE_SIZE,\r\n(resource_size_t *)\r\n&par->p_palette_base,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!par->v_palette_base) {\r\ndev_err(&device->dev,\r\n"GLCD: kmalloc for palette buffer failed\n");\r\nret = -EINVAL;\r\ngoto err_release_fb_mem;\r\n}\r\nmemset(par->v_palette_base, 0, PALETTE_SIZE);\r\npar->irq = platform_get_irq(device, 0);\r\nif (par->irq < 0) {\r\nret = -ENOENT;\r\ngoto err_release_pl_mem;\r\n}\r\nda8xx_fb_info->var.bits_per_pixel = lcd_cfg->bpp;\r\nda8xx_fb_var.xres = lcdc_info->width;\r\nda8xx_fb_var.xres_virtual = lcdc_info->width;\r\nda8xx_fb_var.yres = lcdc_info->height;\r\nda8xx_fb_var.yres_virtual = lcdc_info->height * LCD_NUM_BUFFERS;\r\nda8xx_fb_var.grayscale =\r\nlcd_cfg->p_disp_panel->panel_shade == MONOCHROME ? 1 : 0;\r\nda8xx_fb_var.bits_per_pixel = lcd_cfg->bpp;\r\nda8xx_fb_var.hsync_len = lcdc_info->hsw;\r\nda8xx_fb_var.vsync_len = lcdc_info->vsw;\r\nda8xx_fb_info->flags = FBINFO_FLAG_DEFAULT;\r\nda8xx_fb_info->fix = da8xx_fb_fix;\r\nda8xx_fb_info->var = da8xx_fb_var;\r\nda8xx_fb_info->fbops = &da8xx_fb_ops;\r\nda8xx_fb_info->pseudo_palette = par->pseudo_palette;\r\nda8xx_fb_info->fix.visual = (da8xx_fb_info->var.bits_per_pixel <= 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\nret = fb_alloc_cmap(&da8xx_fb_info->cmap, PALETTE_SIZE, 0);\r\nif (ret)\r\ngoto err_release_pl_mem;\r\nda8xx_fb_info->cmap.len = par->palette_sz;\r\nda8xx_fb_var.activate = FB_ACTIVATE_FORCE;\r\nfb_set_var(da8xx_fb_info, &da8xx_fb_var);\r\ndev_set_drvdata(&device->dev, da8xx_fb_info);\r\ninit_waitqueue_head(&par->vsync_wait);\r\npar->vsync_timeout = HZ / 5;\r\nif (register_framebuffer(da8xx_fb_info) < 0) {\r\ndev_err(&device->dev,\r\n"GLCD: Frame Buffer Registration Failed!\n");\r\nret = -EINVAL;\r\ngoto err_dealloc_cmap;\r\n}\r\n#ifdef CONFIG_CPU_FREQ\r\nret = lcd_da8xx_cpufreq_register(par);\r\nif (ret) {\r\ndev_err(&device->dev, "failed to register cpufreq\n");\r\ngoto err_cpu_freq;\r\n}\r\n#endif\r\nret = request_irq(par->irq, lcdc_irq_handler, 0, DRIVER_NAME, par);\r\nif (ret)\r\ngoto irq_freq;\r\nreturn 0;\r\nirq_freq:\r\n#ifdef CONFIG_CPU_FREQ\r\nlcd_da8xx_cpufreq_deregister(par);\r\n#endif\r\nerr_cpu_freq:\r\nunregister_framebuffer(da8xx_fb_info);\r\nerr_dealloc_cmap:\r\nfb_dealloc_cmap(&da8xx_fb_info->cmap);\r\nerr_release_pl_mem:\r\ndma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base,\r\npar->p_palette_base);\r\nerr_release_fb_mem:\r\ndma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);\r\nerr_release_fb:\r\nframebuffer_release(da8xx_fb_info);\r\nerr_clk_disable:\r\nclk_disable(fb_clk);\r\nerr_clk_put:\r\nclk_put(fb_clk);\r\nerr_ioremap:\r\niounmap((void __iomem *)da8xx_fb_reg_base);\r\nerr_request_mem:\r\nrelease_mem_region(lcdc_regs->start, len);\r\nreturn ret;\r\n}\r\nstatic int fb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct da8xx_fb_par *par = info->par;\r\nconsole_lock();\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(0);\r\nfb_set_suspend(info, 1);\r\nlcd_disable_raster();\r\nclk_disable(par->lcdc_clk);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int fb_resume(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct da8xx_fb_par *par = info->par;\r\nconsole_lock();\r\nif (par->panel_power_ctrl)\r\npar->panel_power_ctrl(1);\r\nclk_enable(par->lcdc_clk);\r\nlcd_enable_raster();\r\nfb_set_suspend(info, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int __init da8xx_fb_init(void)\r\n{\r\nreturn platform_driver_register(&da8xx_fb_driver);\r\n}\r\nstatic void __exit da8xx_fb_cleanup(void)\r\n{\r\nplatform_driver_unregister(&da8xx_fb_driver);\r\n}
