int i_APCI1710_InsnConfigInitSSI(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int ui_TimerValue;\r\nunsigned char b_ModulNbr, b_SSIProfile, b_PositionTurnLength, b_TurnCptLength,\r\nb_PCIInputClock, b_SSICountingMode;\r\nunsigned int ul_SSIOutputClock;\r\nb_ModulNbr = CR_AREF(insn->chanspec);\r\nb_SSIProfile = (unsigned char) data[0];\r\nb_PositionTurnLength = (unsigned char) data[1];\r\nb_TurnCptLength = (unsigned char) data[2];\r\nb_PCIInputClock = (unsigned char) data[3];\r\nul_SSIOutputClock = (unsigned int) data[4];\r\nb_SSICountingMode = (unsigned char) data[5];\r\ni_ReturnValue = insn->n;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_SSI_COUNTER) {\r\nif (b_SSIProfile >= 2 && b_SSIProfile < 33) {\r\nif (b_PositionTurnLength > 0\r\n&& b_PositionTurnLength < 32) {\r\nif (b_TurnCptLength > 0\r\n&& b_TurnCptLength < 32) {\r\nif ((b_TurnCptLength +\r\nb_PositionTurnLength)\r\n<= b_SSIProfile) {\r\nif (b_PCIInputClock ==\r\nAPCI1710_30MHZ\r\n||\r\nb_PCIInputClock\r\n==\r\nAPCI1710_33MHZ)\r\n{\r\nif ((b_PCIInputClock == APCI1710_30MHZ && (ul_SSIOutputClock > 228 && ul_SSIOutputClock <= 5000000UL)) || (b_PCIInputClock == APCI1710_33MHZ && (ul_SSIOutputClock > 251 && ul_SSIOutputClock <= 5000000UL))) {\r\nif (b_SSICountingMode == APCI1710_BINARY_MODE || b_SSICountingMode == APCI1710_GRAY_MODE) {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_SSIProfile\r\n=\r\nb_SSIProfile;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_PositionTurnLength\r\n=\r\nb_PositionTurnLength;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_TurnCptLength\r\n=\r\nb_TurnCptLength;\r\nif (b_SSICountingMode == APCI1710_BINARY_MODE) {\r\noutl(b_SSIProfile + 1, devpriv->s_BoardInfos.ui_Address + 4 + (64 * b_ModulNbr));\r\n} else {\r\noutl(b_SSIProfile, devpriv->s_BoardInfos.ui_Address + 4 + (64 * b_ModulNbr));\r\n}\r\nui_TimerValue\r\n=\r\n(unsigned int)\r\n(\r\n((unsigned int) (b_PCIInputClock) * 500000UL) / ul_SSIOutputClock);\r\noutl(ui_TimerValue, devpriv->s_BoardInfos.ui_Address + (64 * b_ModulNbr));\r\noutl(7 * b_SSICountingMode, devpriv->s_BoardInfos.ui_Address + 12 + (64 * b_ModulNbr));\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_SSIInit\r\n=\r\n1;\r\n} else {\r\nDPRINTK("The selected SSI counting mode parameter is wrong\n");\r\ni_ReturnValue\r\n=\r\n-9;\r\n}\r\n} else {\r\nDPRINTK("The selected SSI output clock is wrong\n");\r\ni_ReturnValue\r\n=\r\n-8;\r\n}\r\n} else {\r\nDPRINTK("The selected PCI input clock is wrong\n");\r\ni_ReturnValue =\r\n-7;\r\n}\r\n} else {\r\nDPRINTK("The selected SSI profile length is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The selected SSI turn counter data length is wrong\n");\r\ni_ReturnValue = -6;\r\n}\r\n} else {\r\nDPRINTK("The selected SSI position data length is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("The selected SSI profile length is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a SSI module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnReadSSIValue(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned char b_Cpt;\r\nunsigned char b_Length;\r\nunsigned char b_Schift;\r\nunsigned char b_SSICpt;\r\nunsigned int dw_And;\r\nunsigned int dw_And1;\r\nunsigned int dw_And2;\r\nunsigned int dw_StatusReg;\r\nunsigned int dw_CounterValue;\r\nunsigned char b_ModulNbr;\r\nunsigned char b_SelectedSSI;\r\nunsigned char b_ReadType;\r\nunsigned int *pul_Position;\r\nunsigned int *pul_TurnCpt;\r\nunsigned int *pul_Position1;\r\nunsigned int *pul_TurnCpt1;\r\ni_ReturnValue = insn->n;\r\npul_Position1 = (unsigned int *) &data[0];\r\npul_TurnCpt1 = (unsigned int *) &data[1];\r\npul_Position = (unsigned int *) &data[0];\r\npul_TurnCpt = (unsigned int *) &data[3];\r\nb_ModulNbr = (unsigned char) CR_AREF(insn->chanspec);\r\nb_SelectedSSI = (unsigned char) CR_CHAN(insn->chanspec);\r\nb_ReadType = (unsigned char) CR_RANGE(insn->chanspec);\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_SSI_COUNTER) {\r\nif (devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_SSICounterInfo.b_SSIInit == 1) {\r\nswitch (b_ReadType) {\r\ncase APCI1710_SSI_READ1VALUE:\r\nif (b_SelectedSSI < 3) {\r\noutl(0, devpriv->s_BoardInfos.\r\nui_Address + 8 +\r\n(64 * b_ModulNbr));\r\ndo {\r\ndw_StatusReg =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address +\r\n(64 * b_ModulNbr));\r\n} while ((dw_StatusReg & 0x1)\r\n!= 0);\r\ndw_CounterValue =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address + 4 +\r\n(b_SelectedSSI * 4) +\r\n(64 * b_ModulNbr));\r\nb_Length =\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_SSIProfile / 2;\r\nif ((b_Length * 2) !=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_SSIProfile) {\r\nb_Length++;\r\n}\r\nb_Schift =\r\nb_Length -\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_PositionTurnLength;\r\n*pul_Position1 =\r\ndw_CounterValue >>\r\nb_Schift;\r\ndw_And = 1;\r\nfor (b_Cpt = 0;\r\nb_Cpt <\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_PositionTurnLength;\r\nb_Cpt++) {\r\ndw_And = dw_And * 2;\r\n}\r\n*pul_Position1 =\r\n*pul_Position1 &\r\n((dw_And) - 1);\r\n*pul_TurnCpt1 =\r\ndw_CounterValue >>\r\nb_Length;\r\ndw_And = 1;\r\nfor (b_Cpt = 0;\r\nb_Cpt <\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_TurnCptLength;\r\nb_Cpt++) {\r\ndw_And = dw_And * 2;\r\n}\r\n*pul_TurnCpt1 =\r\n*pul_TurnCpt1 &\r\n((dw_And) - 1);\r\n} else {\r\nDPRINTK("The selected SSI is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\nbreak;\r\ncase APCI1710_SSI_READALLVALUE:\r\ndw_And1 = 1;\r\nfor (b_Cpt = 0;\r\nb_Cpt <\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_PositionTurnLength; b_Cpt++) {\r\ndw_And1 = dw_And1 * 2;\r\n}\r\ndw_And2 = 1;\r\nfor (b_Cpt = 0;\r\nb_Cpt <\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_TurnCptLength; b_Cpt++) {\r\ndw_And2 = dw_And2 * 2;\r\n}\r\noutl(0, devpriv->s_BoardInfos.\r\nui_Address + 8 +\r\n(64 * b_ModulNbr));\r\ndo {\r\ndw_StatusReg =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address +\r\n(64 * b_ModulNbr));\r\n} while ((dw_StatusReg & 0x1) != 0);\r\nfor (b_SSICpt = 0; b_SSICpt < 3;\r\nb_SSICpt++) {\r\ndw_CounterValue =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address + 4 +\r\n(b_SSICpt * 4) +\r\n(64 * b_ModulNbr));\r\nb_Length =\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_SSIProfile / 2;\r\nif ((b_Length * 2) !=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_SSIProfile) {\r\nb_Length++;\r\n}\r\nb_Schift =\r\nb_Length -\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_SSICounterInfo.\r\nb_PositionTurnLength;\r\npul_Position[b_SSICpt] =\r\ndw_CounterValue >>\r\nb_Schift;\r\npul_Position[b_SSICpt] =\r\npul_Position[b_SSICpt] &\r\n((dw_And1) - 1);\r\npul_TurnCpt[b_SSICpt] =\r\ndw_CounterValue >>\r\nb_Length;\r\npul_TurnCpt[b_SSICpt] =\r\npul_TurnCpt[b_SSICpt] &\r\n((dw_And2) - 1);\r\n}\r\nbreak;\r\ndefault:\r\nprintk("Read Type Inputs Wrong\n");\r\n}\r\n} else {\r\nDPRINTK("SSI not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a SSI module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnBitsSSIDigitalIO(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_StatusReg;\r\nunsigned char b_ModulNbr;\r\nunsigned char b_InputChannel;\r\nunsigned char *pb_ChannelStatus;\r\nunsigned char *pb_InputStatus;\r\nunsigned char b_IOType;\r\ni_ReturnValue = insn->n;\r\nb_ModulNbr = (unsigned char) CR_AREF(insn->chanspec);\r\nb_IOType = (unsigned char) data[0];\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_SSI_COUNTER) {\r\nswitch (b_IOType) {\r\ncase APCI1710_SSI_SET_CHANNELON:\r\noutl(1, devpriv->s_BoardInfos.ui_Address + 16 +\r\n(64 * b_ModulNbr));\r\nbreak;\r\ncase APCI1710_SSI_SET_CHANNELOFF:\r\noutl(0, devpriv->s_BoardInfos.ui_Address + 16 +\r\n(64 * b_ModulNbr));\r\nbreak;\r\ncase APCI1710_SSI_READ_1CHANNEL:\r\nb_InputChannel = (unsigned char) CR_CHAN(insn->chanspec);\r\npb_ChannelStatus = (unsigned char *) &data[0];\r\nif (b_InputChannel <= 2) {\r\ndw_StatusReg =\r\ninl(devpriv->s_BoardInfos.\r\nui_Address + (64 * b_ModulNbr));\r\n*pb_ChannelStatus =\r\n(unsigned char) (((~dw_StatusReg) >> (4 +\r\nb_InputChannel))\r\n& 1);\r\n} else {\r\nDPRINTK("Selected digital input error\n");\r\ni_ReturnValue = -4;\r\n}\r\nbreak;\r\ncase APCI1710_SSI_READ_ALLCHANNEL:\r\npb_InputStatus = (unsigned char *) &data[0];\r\ndw_StatusReg =\r\ninl(devpriv->s_BoardInfos.ui_Address +\r\n(64 * b_ModulNbr));\r\n*pb_InputStatus =\r\n(unsigned char) (((~dw_StatusReg) >> 4) & 7);\r\nbreak;\r\ndefault:\r\nprintk("IO type wrong\n");\r\n}\r\n} else {\r\nDPRINTK("The module is not a SSI module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}
