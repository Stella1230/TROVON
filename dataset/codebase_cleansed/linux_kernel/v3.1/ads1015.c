static s32 ads1015_read_reg(struct i2c_client *client, unsigned int reg)\r\n{\r\ns32 data = i2c_smbus_read_word_data(client, reg);\r\nreturn (data < 0) ? data : swab16(data);\r\n}\r\nstatic s32 ads1015_write_reg(struct i2c_client *client, unsigned int reg,\r\nu16 val)\r\n{\r\nreturn i2c_smbus_write_word_data(client, reg, swab16(val));\r\n}\r\nstatic int ads1015_read_value(struct i2c_client *client, unsigned int channel,\r\nint *value)\r\n{\r\nu16 config;\r\ns16 conversion;\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nunsigned int pga = data->channel_data[channel].pga;\r\nint fullscale;\r\nunsigned int data_rate = data->channel_data[channel].data_rate;\r\nunsigned int conversion_time_ms;\r\nint res;\r\nmutex_lock(&data->update_lock);\r\nres = ads1015_read_reg(client, ADS1015_CONFIG);\r\nif (res < 0)\r\ngoto err_unlock;\r\nconfig = res;\r\nfullscale = fullscale_table[pga];\r\nconversion_time_ms = DIV_ROUND_UP(1000, data_rate_table[data_rate]);\r\nconfig &= 0x001f;\r\nconfig |= (1 << 15) | (1 << 8);\r\nconfig |= (channel & 0x0007) << 12;\r\nconfig |= (pga & 0x0007) << 9;\r\nconfig |= (data_rate & 0x0007) << 5;\r\nres = ads1015_write_reg(client, ADS1015_CONFIG, config);\r\nif (res < 0)\r\ngoto err_unlock;\r\nmsleep(conversion_time_ms);\r\nres = ads1015_read_reg(client, ADS1015_CONFIG);\r\nif (res < 0)\r\ngoto err_unlock;\r\nconfig = res;\r\nif (!(config & (1 << 15))) {\r\nres = -EIO;\r\ngoto err_unlock;\r\n}\r\nres = ads1015_read_reg(client, ADS1015_CONVERSION);\r\nif (res < 0)\r\ngoto err_unlock;\r\nconversion = res;\r\nmutex_unlock(&data->update_lock);\r\n*value = DIV_ROUND_CLOSEST(conversion * fullscale, 0x7ff0);\r\nreturn 0;\r\nerr_unlock:\r\nmutex_unlock(&data->update_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint in;\r\nint res;\r\nres = ads1015_read_value(client, attr->index, &in);\r\nreturn (res < 0) ? res : sprintf(buf, "%d\n", in);\r\n}\r\nstatic int ads1015_remove(struct i2c_client *client)\r\n{\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nint k;\r\nhwmon_device_unregister(data->hwmon_dev);\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k)\r\ndevice_remove_file(&client->dev, &ads1015_in[k].dev_attr);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int ads1015_get_channels_config_of(struct i2c_client *client)\r\n{\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nstruct device_node *node;\r\nif (!client->dev.of_node\r\n|| !of_get_next_child(client->dev.of_node, NULL))\r\nreturn -EINVAL;\r\nfor_each_child_of_node(client->dev.of_node, node) {\r\nconst __be32 *property;\r\nint len;\r\nunsigned int channel;\r\nunsigned int pga = ADS1015_DEFAULT_PGA;\r\nunsigned int data_rate = ADS1015_DEFAULT_DATA_RATE;\r\nproperty = of_get_property(node, "reg", &len);\r\nif (!property || len != sizeof(int)) {\r\ndev_err(&client->dev, "invalid reg on %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\nchannel = be32_to_cpup(property);\r\nif (channel > ADS1015_CHANNELS) {\r\ndev_err(&client->dev,\r\n"invalid channel index %d on %s\n",\r\nchannel, node->full_name);\r\ncontinue;\r\n}\r\nproperty = of_get_property(node, "ti,gain", &len);\r\nif (property && len == sizeof(int)) {\r\npga = be32_to_cpup(property);\r\nif (pga > 6) {\r\ndev_err(&client->dev,\r\n"invalid gain on %s\n",\r\nnode->full_name);\r\n}\r\n}\r\nproperty = of_get_property(node, "ti,datarate", &len);\r\nif (property && len == sizeof(int)) {\r\ndata_rate = be32_to_cpup(property);\r\nif (data_rate > 7) {\r\ndev_err(&client->dev,\r\n"invalid data_rate on %s\n",\r\nnode->full_name);\r\n}\r\n}\r\ndata->channel_data[channel].enabled = true;\r\ndata->channel_data[channel].pga = pga;\r\ndata->channel_data[channel].data_rate = data_rate;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ads1015_get_channels_config(struct i2c_client *client)\r\n{\r\nunsigned int k;\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nstruct ads1015_platform_data *pdata = dev_get_platdata(&client->dev);\r\nif (pdata) {\r\nmemcpy(data->channel_data, pdata->channel_data,\r\nsizeof(data->channel_data));\r\nreturn;\r\n}\r\n#ifdef CONFIG_OF\r\nif (!ads1015_get_channels_config_of(client))\r\nreturn;\r\n#endif\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k) {\r\ndata->channel_data[k].enabled = true;\r\ndata->channel_data[k].pga = ADS1015_DEFAULT_PGA;\r\ndata->channel_data[k].data_rate = ADS1015_DEFAULT_DATA_RATE;\r\n}\r\n}\r\nstatic int ads1015_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ads1015_data *data;\r\nint err;\r\nunsigned int k;\r\ndata = kzalloc(sizeof(struct ads1015_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nads1015_get_channels_config(client);\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k) {\r\nif (!data->channel_data[k].enabled)\r\ncontinue;\r\nerr = device_create_file(&client->dev, &ads1015_in[k].dev_attr);\r\nif (err)\r\ngoto exit_free;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k)\r\ndevice_remove_file(&client->dev, &ads1015_in[k].dev_attr);\r\nexit_free:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __init sensors_ads1015_init(void)\r\n{\r\nreturn i2c_add_driver(&ads1015_driver);\r\n}\r\nstatic void __exit sensors_ads1015_exit(void)\r\n{\r\ni2c_del_driver(&ads1015_driver);\r\n}
