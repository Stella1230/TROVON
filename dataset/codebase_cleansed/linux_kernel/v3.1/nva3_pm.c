static int\r\nnva3_pm_pll_offset(u32 id)\r\n{\r\nstatic const u32 pll_map[] = {\r\n0x00, PLL_CORE,\r\n0x01, PLL_SHADER,\r\n0x02, PLL_MEMORY,\r\n0x00, 0x00\r\n};\r\nconst u32 *map = pll_map;\r\nwhile (map[1]) {\r\nif (id == map[1])\r\nreturn map[0];\r\nmap += 2;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnva3_pm_clock_get(struct drm_device *dev, u32 id)\r\n{\r\nu32 src0, src1, ctrl, coef;\r\nstruct pll_lims pll;\r\nint ret, off;\r\nint P, N, M;\r\nret = get_pll_limits(dev, id, &pll);\r\nif (ret)\r\nreturn ret;\r\noff = nva3_pm_pll_offset(id);\r\nif (off < 0)\r\nreturn off;\r\nsrc0 = nv_rd32(dev, 0x4120 + (off * 4));\r\nsrc1 = nv_rd32(dev, 0x4160 + (off * 4));\r\nctrl = nv_rd32(dev, pll.reg + 0);\r\ncoef = nv_rd32(dev, pll.reg + 4);\r\nNV_DEBUG(dev, "PLL %02x: 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\nid, src0, src1, ctrl, coef);\r\nif (ctrl & 0x00000008) {\r\nu32 div = ((src1 & 0x003c0000) >> 18) + 1;\r\nreturn (pll.refclk * 2) / div;\r\n}\r\nP = (coef & 0x003f0000) >> 16;\r\nN = (coef & 0x0000ff00) >> 8;\r\nM = (coef & 0x000000ff);\r\nreturn pll.refclk * N / M / P;\r\n}\r\nvoid *\r\nnva3_pm_clock_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl,\r\nu32 id, int khz)\r\n{\r\nstruct nva3_pm_state *pll;\r\nstruct pll_lims limits;\r\nint N, M, P, diff;\r\nint ret, off;\r\nret = get_pll_limits(dev, id, &limits);\r\nif (ret < 0)\r\nreturn (ret == -ENOENT) ? NULL : ERR_PTR(ret);\r\noff = nva3_pm_pll_offset(id);\r\nif (id < 0)\r\nreturn ERR_PTR(-EINVAL);\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\npll->type = id;\r\npll->src0 = 0x004120 + (off * 4);\r\npll->src1 = 0x004160 + (off * 4);\r\npll->ctrl = limits.reg + 0;\r\npll->coef = limits.reg + 4;\r\npll->new_div = min((limits.refclk * 2) / (khz - 2999), 16);\r\nif (pll->new_div) {\r\ndiff = khz - ((limits.refclk * 2) / pll->new_div);\r\nif (diff < -2000 || diff >= 3000)\r\npll->new_div = 0;\r\n}\r\nif (!pll->new_div) {\r\nret = nva3_calc_pll(dev, &limits, khz, &N, NULL, &M, &P);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\npll->new_pnm = (P << 16) | (N << 8) | M;\r\npll->new_div = 2 - 1;\r\n} else {\r\npll->new_pnm = 0;\r\npll->new_div--;\r\n}\r\nif ((nv_rd32(dev, pll->src1) & 0x00000101) != 0x00000101)\r\npll->old_pnm = nv_rd32(dev, pll->coef);\r\nreturn pll;\r\n}\r\nvoid\r\nnva3_pm_clock_set(struct drm_device *dev, void *pre_state)\r\n{\r\nstruct nva3_pm_state *pll = pre_state;\r\nu32 ctrl = 0;\r\nif (pll->type == PLL_MEMORY) {\r\nnv_wr32(dev, 0x100210, 0);\r\nnv_wr32(dev, 0x1002dc, 1);\r\nnv_wr32(dev, 0x004018, 0x00001000);\r\nctrl = 0x18000100;\r\n}\r\nif (pll->old_pnm || !pll->new_pnm) {\r\nnv_mask(dev, pll->src1, 0x003c0101, 0x00000101 |\r\n(pll->new_div << 18));\r\nnv_wr32(dev, pll->ctrl, 0x0001001d | ctrl);\r\nnv_mask(dev, pll->ctrl, 0x00000001, 0x00000000);\r\n}\r\nif (pll->new_pnm) {\r\nnv_mask(dev, pll->src0, 0x00000101, 0x00000101);\r\nnv_wr32(dev, pll->coef, pll->new_pnm);\r\nnv_wr32(dev, pll->ctrl, 0x0001001d | ctrl);\r\nnv_mask(dev, pll->ctrl, 0x00000010, 0x00000000);\r\nnv_mask(dev, pll->ctrl, 0x00020010, 0x00020010);\r\nnv_wr32(dev, pll->ctrl, 0x00010015 | ctrl);\r\nnv_mask(dev, pll->src1, 0x00000100, 0x00000000);\r\nnv_mask(dev, pll->src1, 0x00000001, 0x00000000);\r\nif (pll->type == PLL_MEMORY)\r\nnv_wr32(dev, 0x4018, 0x10005000);\r\n} else {\r\nnv_mask(dev, pll->ctrl, 0x00000001, 0x00000000);\r\nnv_mask(dev, pll->src0, 0x00000100, 0x00000000);\r\nnv_mask(dev, pll->src0, 0x00000001, 0x00000000);\r\nif (pll->type == PLL_MEMORY)\r\nnv_wr32(dev, 0x4018, 0x1000d000);\r\n}\r\nif (pll->type == PLL_MEMORY) {\r\nnv_wr32(dev, 0x1002dc, 0);\r\nnv_wr32(dev, 0x100210, 0x80000000);\r\n}\r\nkfree(pll);\r\n}
