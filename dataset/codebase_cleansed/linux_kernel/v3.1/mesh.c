void ieee80211s_init(void)\r\n{\r\nmesh_pathtbl_init();\r\nmesh_allocated = 1;\r\nrm_cache = kmem_cache_create("mesh_rmc", sizeof(struct rmc_entry),\r\n0, 0, NULL);\r\n}\r\nvoid ieee80211s_stop(void)\r\n{\r\nmesh_pathtbl_unregister();\r\nkmem_cache_destroy(rm_cache);\r\n}\r\nstatic void ieee80211_mesh_housekeeping_timer(unsigned long data)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = (void *) data;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nset_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);\r\nif (local->quiescing) {\r\nset_bit(TMR_RUNNING_HK, &ifmsh->timers_running);\r\nreturn;\r\n}\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nbool mesh_matches_local(struct ieee802_11_elems *ie, struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nif (ifmsh->mesh_id_len == ie->mesh_id_len &&\r\nmemcmp(ifmsh->mesh_id, ie->mesh_id, ie->mesh_id_len) == 0 &&\r\n(ifmsh->mesh_pp_id == ie->mesh_config->meshconf_psel) &&\r\n(ifmsh->mesh_pm_id == ie->mesh_config->meshconf_pmetric) &&\r\n(ifmsh->mesh_cc_id == ie->mesh_config->meshconf_congest) &&\r\n(ifmsh->mesh_sp_id == ie->mesh_config->meshconf_synch) &&\r\n(ifmsh->mesh_auth_id == ie->mesh_config->meshconf_auth))\r\nreturn true;\r\nreturn false;\r\n}\r\nbool mesh_peer_accepts_plinks(struct ieee802_11_elems *ie)\r\n{\r\nreturn (ie->mesh_config->meshconf_cap &\r\nMESHCONF_CAPAB_ACCEPT_PLINKS) != 0;\r\n}\r\nvoid mesh_accept_plinks_update(struct ieee80211_sub_if_data *sdata)\r\n{\r\nbool free_plinks;\r\nfree_plinks = mesh_plink_availables(sdata);\r\nif (free_plinks != sdata->u.mesh.accepting_plinks)\r\nieee80211_mesh_housekeeping_timer((unsigned long) sdata);\r\n}\r\nint mesh_rmc_init(struct ieee80211_sub_if_data *sdata)\r\n{\r\nint i;\r\nsdata->u.mesh.rmc = kmalloc(sizeof(struct mesh_rmc), GFP_KERNEL);\r\nif (!sdata->u.mesh.rmc)\r\nreturn -ENOMEM;\r\nsdata->u.mesh.rmc->idx_mask = RMC_BUCKETS - 1;\r\nfor (i = 0; i < RMC_BUCKETS; i++)\r\nINIT_LIST_HEAD(&sdata->u.mesh.rmc->bucket[i].list);\r\nreturn 0;\r\n}\r\nvoid mesh_rmc_free(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct mesh_rmc *rmc = sdata->u.mesh.rmc;\r\nstruct rmc_entry *p, *n;\r\nint i;\r\nif (!sdata->u.mesh.rmc)\r\nreturn;\r\nfor (i = 0; i < RMC_BUCKETS; i++)\r\nlist_for_each_entry_safe(p, n, &rmc->bucket[i].list, list) {\r\nlist_del(&p->list);\r\nkmem_cache_free(rm_cache, p);\r\n}\r\nkfree(rmc);\r\nsdata->u.mesh.rmc = NULL;\r\n}\r\nint mesh_rmc_check(u8 *sa, struct ieee80211s_hdr *mesh_hdr,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct mesh_rmc *rmc = sdata->u.mesh.rmc;\r\nu32 seqnum = 0;\r\nint entries = 0;\r\nu8 idx;\r\nstruct rmc_entry *p, *n;\r\nmemcpy(&seqnum, &mesh_hdr->seqnum, sizeof(mesh_hdr->seqnum));\r\nidx = le32_to_cpu(mesh_hdr->seqnum) & rmc->idx_mask;\r\nlist_for_each_entry_safe(p, n, &rmc->bucket[idx].list, list) {\r\n++entries;\r\nif (time_after(jiffies, p->exp_time) ||\r\n(entries == RMC_QUEUE_MAX_LEN)) {\r\nlist_del(&p->list);\r\nkmem_cache_free(rm_cache, p);\r\n--entries;\r\n} else if ((seqnum == p->seqnum) &&\r\n(memcmp(sa, p->sa, ETH_ALEN) == 0))\r\nreturn -1;\r\n}\r\np = kmem_cache_alloc(rm_cache, GFP_ATOMIC);\r\nif (!p) {\r\nprintk(KERN_DEBUG "o11s: could not allocate RMC entry\n");\r\nreturn 0;\r\n}\r\np->seqnum = seqnum;\r\np->exp_time = jiffies + RMC_TIMEOUT;\r\nmemcpy(p->sa, sa, ETH_ALEN);\r\nlist_add(&p->list, &rmc->bucket[idx].list);\r\nreturn 0;\r\n}\r\nvoid mesh_mgmt_ies_add(struct sk_buff *skb, struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_supported_band *sband;\r\nu8 *pos;\r\nint len, i, rate;\r\nu8 neighbors;\r\nsband = local->hw.wiphy->bands[local->hw.conf.channel->band];\r\nlen = sband->n_bitrates;\r\nif (len > 8)\r\nlen = 8;\r\npos = skb_put(skb, len + 2);\r\n*pos++ = WLAN_EID_SUPP_RATES;\r\n*pos++ = len;\r\nfor (i = 0; i < len; i++) {\r\nrate = sband->bitrates[i].bitrate;\r\n*pos++ = (u8) (rate / 5);\r\n}\r\nif (sband->n_bitrates > len) {\r\npos = skb_put(skb, sband->n_bitrates - len + 2);\r\n*pos++ = WLAN_EID_EXT_SUPP_RATES;\r\n*pos++ = sband->n_bitrates - len;\r\nfor (i = len; i < sband->n_bitrates; i++) {\r\nrate = sband->bitrates[i].bitrate;\r\n*pos++ = (u8) (rate / 5);\r\n}\r\n}\r\nif (sband->band == IEEE80211_BAND_2GHZ) {\r\npos = skb_put(skb, 2 + 1);\r\n*pos++ = WLAN_EID_DS_PARAMS;\r\n*pos++ = 1;\r\n*pos++ = ieee80211_frequency_to_channel(local->hw.conf.channel->center_freq);\r\n}\r\npos = skb_put(skb, 2 + sdata->u.mesh.mesh_id_len);\r\n*pos++ = WLAN_EID_MESH_ID;\r\n*pos++ = sdata->u.mesh.mesh_id_len;\r\nif (sdata->u.mesh.mesh_id_len)\r\nmemcpy(pos, sdata->u.mesh.mesh_id, sdata->u.mesh.mesh_id_len);\r\npos = skb_put(skb, 2 + sizeof(struct ieee80211_meshconf_ie));\r\n*pos++ = WLAN_EID_MESH_CONFIG;\r\n*pos++ = sizeof(struct ieee80211_meshconf_ie);\r\n*pos++ = sdata->u.mesh.mesh_pp_id;\r\n*pos++ = sdata->u.mesh.mesh_pm_id;\r\n*pos++ = sdata->u.mesh.mesh_cc_id;\r\n*pos++ = sdata->u.mesh.mesh_sp_id;\r\n*pos++ = sdata->u.mesh.mesh_auth_id;\r\nneighbors = atomic_read(&sdata->u.mesh.mshstats.estab_plinks);\r\nneighbors = (neighbors > 15) ? 15 : neighbors;\r\n*pos++ = neighbors << 1;\r\nsdata->u.mesh.accepting_plinks = mesh_plink_availables(sdata);\r\n*pos = MESHCONF_CAPAB_FORWARDING;\r\n*pos++ |= sdata->u.mesh.accepting_plinks ?\r\nMESHCONF_CAPAB_ACCEPT_PLINKS : 0x00;\r\n*pos++ = 0x00;\r\nif (sdata->u.mesh.ie) {\r\nint len = sdata->u.mesh.ie_len;\r\nconst u8 *data = sdata->u.mesh.ie;\r\nif (skb_tailroom(skb) > len)\r\nmemcpy(skb_put(skb, len), data, len);\r\n}\r\n}\r\nstatic void ieee80211_mesh_path_timer(unsigned long data)\r\n{\r\nstruct ieee80211_sub_if_data *sdata =\r\n(struct ieee80211_sub_if_data *) data;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee80211_local *local = sdata->local;\r\nif (local->quiescing) {\r\nset_bit(TMR_RUNNING_MP, &ifmsh->timers_running);\r\nreturn;\r\n}\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nstatic void ieee80211_mesh_path_root_timer(unsigned long data)\r\n{\r\nstruct ieee80211_sub_if_data *sdata =\r\n(struct ieee80211_sub_if_data *) data;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee80211_local *local = sdata->local;\r\nset_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\r\nif (local->quiescing) {\r\nset_bit(TMR_RUNNING_MPR, &ifmsh->timers_running);\r\nreturn;\r\n}\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nvoid ieee80211_mesh_root_setup(struct ieee80211_if_mesh *ifmsh)\r\n{\r\nif (ifmsh->mshcfg.dot11MeshHWMPRootMode)\r\nset_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\r\nelse {\r\nclear_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\r\ndel_timer_sync(&ifmsh->mesh_path_root_timer);\r\n}\r\n}\r\nint ieee80211_fill_mesh_addresses(struct ieee80211_hdr *hdr, __le16 *fc,\r\nconst u8 *meshda, const u8 *meshsa)\r\n{\r\nif (is_multicast_ether_addr(meshda)) {\r\n*fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\r\nmemcpy(hdr->addr1, meshda, ETH_ALEN);\r\nmemcpy(hdr->addr2, meshsa, ETH_ALEN);\r\nmemcpy(hdr->addr3, meshsa, ETH_ALEN);\r\nreturn 24;\r\n} else {\r\n*fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\r\nIEEE80211_FCTL_TODS);\r\nmemset(hdr->addr1, 0, ETH_ALEN);\r\nmemcpy(hdr->addr2, meshsa, ETH_ALEN);\r\nmemcpy(hdr->addr3, meshda, ETH_ALEN);\r\nmemcpy(hdr->addr4, meshsa, ETH_ALEN);\r\nreturn 30;\r\n}\r\n}\r\nint ieee80211_new_mesh_header(struct ieee80211s_hdr *meshhdr,\r\nstruct ieee80211_sub_if_data *sdata, char *addr4or5,\r\nchar *addr6)\r\n{\r\nint aelen = 0;\r\nBUG_ON(!addr4or5 && addr6);\r\nmemset(meshhdr, 0, sizeof(*meshhdr));\r\nmeshhdr->ttl = sdata->u.mesh.mshcfg.dot11MeshTTL;\r\nput_unaligned(cpu_to_le32(sdata->u.mesh.mesh_seqnum), &meshhdr->seqnum);\r\nsdata->u.mesh.mesh_seqnum++;\r\nif (addr4or5 && !addr6) {\r\nmeshhdr->flags |= MESH_FLAGS_AE_A4;\r\naelen += ETH_ALEN;\r\nmemcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);\r\n} else if (addr4or5 && addr6) {\r\nmeshhdr->flags |= MESH_FLAGS_AE_A5_A6;\r\naelen += 2 * ETH_ALEN;\r\nmemcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);\r\nmemcpy(meshhdr->eaddr2, addr6, ETH_ALEN);\r\n}\r\nreturn 6 + aelen;\r\n}\r\nstatic void ieee80211_mesh_housekeeping(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_if_mesh *ifmsh)\r\n{\r\nbool free_plinks;\r\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\r\nprintk(KERN_DEBUG "%s: running mesh housekeeping\n",\r\nsdata->name);\r\n#endif\r\nieee80211_sta_expire(sdata, IEEE80211_MESH_PEER_INACTIVITY_LIMIT);\r\nmesh_path_expire(sdata);\r\nfree_plinks = mesh_plink_availables(sdata);\r\nif (free_plinks != sdata->u.mesh.accepting_plinks)\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON);\r\nmod_timer(&ifmsh->housekeeping_timer,\r\nround_jiffies(jiffies + IEEE80211_MESH_HOUSEKEEPING_INTERVAL));\r\n}\r\nstatic void ieee80211_mesh_rootpath(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nmesh_path_tx_root_frame(sdata);\r\nmod_timer(&ifmsh->mesh_path_root_timer,\r\nround_jiffies(jiffies + IEEE80211_MESH_RANN_INTERVAL));\r\n}\r\nvoid ieee80211_mesh_quiesce(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nif (del_timer_sync(&ifmsh->housekeeping_timer))\r\nset_bit(TMR_RUNNING_HK, &ifmsh->timers_running);\r\nif (del_timer_sync(&ifmsh->mesh_path_timer))\r\nset_bit(TMR_RUNNING_MP, &ifmsh->timers_running);\r\nif (del_timer_sync(&ifmsh->mesh_path_root_timer))\r\nset_bit(TMR_RUNNING_MPR, &ifmsh->timers_running);\r\n}\r\nvoid ieee80211_mesh_restart(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nif (test_and_clear_bit(TMR_RUNNING_HK, &ifmsh->timers_running))\r\nadd_timer(&ifmsh->housekeeping_timer);\r\nif (test_and_clear_bit(TMR_RUNNING_MP, &ifmsh->timers_running))\r\nadd_timer(&ifmsh->mesh_path_timer);\r\nif (test_and_clear_bit(TMR_RUNNING_MPR, &ifmsh->timers_running))\r\nadd_timer(&ifmsh->mesh_path_root_timer);\r\nieee80211_mesh_root_setup(ifmsh);\r\n}\r\nvoid ieee80211_start_mesh(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee80211_local *local = sdata->local;\r\nlocal->fif_other_bss++;\r\natomic_inc(&local->iff_allmultis);\r\nieee80211_configure_filter(local);\r\nifmsh->mesh_cc_id = 0;\r\nifmsh->mesh_sp_id = 0;\r\nifmsh->mesh_auth_id = 0;\r\nset_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);\r\nieee80211_mesh_root_setup(ifmsh);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\nsdata->vif.bss_conf.beacon_int = MESH_DEFAULT_BEACON_INTERVAL;\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON |\r\nBSS_CHANGED_BEACON_ENABLED |\r\nBSS_CHANGED_BEACON_INT);\r\n}\r\nvoid ieee80211_stop_mesh(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nifmsh->mesh_id_len = 0;\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED);\r\nsta_info_flush(local, NULL);\r\ndel_timer_sync(&sdata->u.mesh.housekeeping_timer);\r\ndel_timer_sync(&sdata->u.mesh.mesh_path_root_timer);\r\ncancel_work_sync(&sdata->work);\r\nlocal->fif_other_bss--;\r\natomic_dec(&local->iff_allmultis);\r\nieee80211_configure_filter(local);\r\n}\r\nstatic void ieee80211_mesh_rx_bcn_presp(struct ieee80211_sub_if_data *sdata,\r\nu16 stype,\r\nstruct ieee80211_mgmt *mgmt,\r\nsize_t len,\r\nstruct ieee80211_rx_status *rx_status)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee802_11_elems elems;\r\nstruct ieee80211_channel *channel;\r\nu32 supp_rates = 0;\r\nsize_t baselen;\r\nint freq;\r\nenum ieee80211_band band = rx_status->band;\r\nif (stype == IEEE80211_STYPE_PROBE_RESP &&\r\ncompare_ether_addr(mgmt->da, sdata->vif.addr))\r\nreturn;\r\nbaselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;\r\nif (baselen > len)\r\nreturn;\r\nieee802_11_parse_elems(mgmt->u.probe_resp.variable, len - baselen,\r\n&elems);\r\nif (elems.rsn_len && sdata->u.mesh.security == IEEE80211_MESH_SEC_NONE)\r\nreturn;\r\nif (elems.ds_params && elems.ds_params_len == 1)\r\nfreq = ieee80211_channel_to_frequency(elems.ds_params[0], band);\r\nelse\r\nfreq = rx_status->freq;\r\nchannel = ieee80211_get_channel(local->hw.wiphy, freq);\r\nif (!channel || channel->flags & IEEE80211_CHAN_DISABLED)\r\nreturn;\r\nif (elems.mesh_id && elems.mesh_config &&\r\nmesh_matches_local(&elems, sdata)) {\r\nsupp_rates = ieee80211_sta_get_rates(local, &elems, band);\r\nmesh_neighbour_update(mgmt->sa, supp_rates, sdata, &elems);\r\n}\r\n}\r\nstatic void ieee80211_mesh_rx_mgmt_action(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt,\r\nsize_t len,\r\nstruct ieee80211_rx_status *rx_status)\r\n{\r\nswitch (mgmt->u.action.category) {\r\ncase WLAN_CATEGORY_MESH_ACTION:\r\nmesh_rx_plink_frame(sdata, mgmt, len, rx_status);\r\nbreak;\r\ncase WLAN_CATEGORY_MESH_PATH_SEL:\r\nmesh_rx_path_sel_frame(sdata, mgmt, len);\r\nbreak;\r\n}\r\n}\r\nvoid ieee80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_rx_status *rx_status;\r\nstruct ieee80211_mgmt *mgmt;\r\nu16 stype;\r\nrx_status = IEEE80211_SKB_RXCB(skb);\r\nmgmt = (struct ieee80211_mgmt *) skb->data;\r\nstype = le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE;\r\nswitch (stype) {\r\ncase IEEE80211_STYPE_PROBE_RESP:\r\ncase IEEE80211_STYPE_BEACON:\r\nieee80211_mesh_rx_bcn_presp(sdata, stype, mgmt, skb->len,\r\nrx_status);\r\nbreak;\r\ncase IEEE80211_STYPE_ACTION:\r\nieee80211_mesh_rx_mgmt_action(sdata, mgmt, skb->len, rx_status);\r\nbreak;\r\n}\r\n}\r\nvoid ieee80211_mesh_work(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nif (ifmsh->preq_queue_len &&\r\ntime_after(jiffies,\r\nifmsh->last_preq + msecs_to_jiffies(ifmsh->mshcfg.dot11MeshHWMPpreqMinInterval)))\r\nmesh_path_start_discovery(sdata);\r\nif (test_and_clear_bit(MESH_WORK_GROW_MPATH_TABLE, &ifmsh->wrkq_flags))\r\nmesh_mpath_table_grow();\r\nif (test_and_clear_bit(MESH_WORK_GROW_MPP_TABLE, &ifmsh->wrkq_flags))\r\nmesh_mpp_table_grow();\r\nif (test_and_clear_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags))\r\nieee80211_mesh_housekeeping(sdata, ifmsh);\r\nif (test_and_clear_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags))\r\nieee80211_mesh_rootpath(sdata);\r\n}\r\nvoid ieee80211_mesh_notify_scan_completed(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sdata, &local->interfaces, list)\r\nif (ieee80211_vif_is_mesh(&sdata->vif))\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\nrcu_read_unlock();\r\n}\r\nvoid ieee80211_mesh_init_sdata(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nsetup_timer(&ifmsh->housekeeping_timer,\r\nieee80211_mesh_housekeeping_timer,\r\n(unsigned long) sdata);\r\nifmsh->accepting_plinks = true;\r\nifmsh->preq_id = 0;\r\nifmsh->sn = 0;\r\natomic_set(&ifmsh->mpaths, 0);\r\nmesh_rmc_init(sdata);\r\nifmsh->last_preq = jiffies;\r\nif (!mesh_allocated)\r\nieee80211s_init();\r\nsetup_timer(&ifmsh->mesh_path_timer,\r\nieee80211_mesh_path_timer,\r\n(unsigned long) sdata);\r\nsetup_timer(&ifmsh->mesh_path_root_timer,\r\nieee80211_mesh_path_root_timer,\r\n(unsigned long) sdata);\r\nINIT_LIST_HEAD(&ifmsh->preq_queue.list);\r\nspin_lock_init(&ifmsh->mesh_preq_queue_lock);\r\n}
