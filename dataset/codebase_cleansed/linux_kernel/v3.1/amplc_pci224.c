static int __devinit driver_amplc_pci224_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id\r\n*ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_amplc_pci224.driver_name);\r\n}\r\nstatic void __devexit driver_amplc_pci224_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_amplc_pci224_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_amplc_pci224);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_amplc_pci224_pci_driver.name =\r\n(char *)driver_amplc_pci224.driver_name;\r\nreturn pci_register_driver(&driver_amplc_pci224_pci_driver);\r\n}\r\nstatic void __exit driver_amplc_pci224_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_amplc_pci224_pci_driver);\r\ncomedi_driver_unregister(&driver_amplc_pci224);\r\n}\r\nstatic void\r\npci224_ao_set_data(struct comedi_device *dev, int chan, int range,\r\nunsigned int data)\r\n{\r\nunsigned short mangled;\r\ndevpriv->ao_readback[chan] = data;\r\noutw(1 << chan, dev->iobase + PCI224_DACCEN);\r\ndevpriv->daccon = COMBINE(devpriv->daccon, devpriv->hwrange[range],\r\n(PCI224_DACCON_POLAR_MASK |\r\nPCI224_DACCON_VREF_MASK));\r\noutw(devpriv->daccon | PCI224_DACCON_FIFORESET,\r\ndev->iobase + PCI224_DACCON);\r\nmangled = (unsigned short)data << (16 - thisboard->ao_bits);\r\nif ((devpriv->daccon & PCI224_DACCON_POLAR_MASK) ==\r\nPCI224_DACCON_POLAR_BI) {\r\nmangled ^= 0x8000;\r\n}\r\noutw(mangled, dev->iobase + PCI224_DACDATA);\r\ninw(dev->iobase + PCI224_SOFTTRIG);\r\n}\r\nstatic int\r\npci224_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nint chan, range;\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\npci224_ao_set_data(dev, chan, range, data[i]);\r\nreturn i;\r\n}\r\nstatic int\r\npci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nint chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn i;\r\n}\r\nstatic void\r\npci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,\r\nunsigned int *nanosec, int round_mode)\r\n{\r\ni8253_cascade_ns_to_timer(osc_base, d1, d2, nanosec, round_mode);\r\n}\r\nstatic void pci224_ao_stop(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nif (!test_and_clear_bit(AO_CMD_STARTED, &devpriv->state))\r\nreturn;\r\nspin_lock_irqsave(&devpriv->ao_spinlock, flags);\r\ndevpriv->intsce = 0;\r\noutb(0, devpriv->iobase1 + PCI224_INT_SCE);\r\nwhile (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {\r\nspin_unlock_irqrestore(&devpriv->ao_spinlock, flags);\r\nspin_lock_irqsave(&devpriv->ao_spinlock, flags);\r\n}\r\nspin_unlock_irqrestore(&devpriv->ao_spinlock, flags);\r\noutw(0, dev->iobase + PCI224_DACCEN);\r\ndevpriv->daccon = COMBINE(devpriv->daccon,\r\nPCI224_DACCON_TRIG_SW |\r\nPCI224_DACCON_FIFOINTR_EMPTY,\r\nPCI224_DACCON_TRIG_MASK |\r\nPCI224_DACCON_FIFOINTR_MASK);\r\noutw(devpriv->daccon | PCI224_DACCON_FIFORESET,\r\ndev->iobase + PCI224_DACCON);\r\n}\r\nstatic void pci224_ao_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long flags;\r\nset_bit(AO_CMD_STARTED, &devpriv->state);\r\nif (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {\r\npci224_ao_stop(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\n} else {\r\nspin_lock_irqsave(&devpriv->ao_spinlock, flags);\r\nif (cmd->stop_src == TRIG_EXT)\r\ndevpriv->intsce = PCI224_INTR_EXT | PCI224_INTR_DAC;\r\nelse\r\ndevpriv->intsce = PCI224_INTR_DAC;\r\noutb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->ao_spinlock, flags);\r\n}\r\n}\r\nstatic void pci224_ao_handle_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int num_scans;\r\nunsigned int room;\r\nunsigned short dacstat;\r\nunsigned int i, n;\r\nunsigned int bytes_per_scan;\r\nif (cmd->chanlist_len) {\r\nbytes_per_scan = cmd->chanlist_len * sizeof(short);\r\n} else {\r\nbytes_per_scan = sizeof(short);\r\n}\r\nnum_scans = comedi_buf_read_n_available(s->async) / bytes_per_scan;\r\nif (!devpriv->ao_stop_continuous) {\r\nif (num_scans > devpriv->ao_stop_count)\r\nnum_scans = devpriv->ao_stop_count;\r\n}\r\ndacstat = inw(dev->iobase + PCI224_DACCON);\r\nswitch (dacstat & PCI224_DACCON_FIFOFL_MASK) {\r\ncase PCI224_DACCON_FIFOFL_EMPTY:\r\nroom = PCI224_FIFO_ROOM_EMPTY;\r\nif (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {\r\npci224_ao_stop(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nbreak;\r\ncase PCI224_DACCON_FIFOFL_ONETOHALF:\r\nroom = PCI224_FIFO_ROOM_ONETOHALF;\r\nbreak;\r\ncase PCI224_DACCON_FIFOFL_HALFTOFULL:\r\nroom = PCI224_FIFO_ROOM_HALFTOFULL;\r\nbreak;\r\ndefault:\r\nroom = PCI224_FIFO_ROOM_FULL;\r\nbreak;\r\n}\r\nif (room >= PCI224_FIFO_ROOM_ONETOHALF) {\r\nif (num_scans == 0) {\r\npci224_ao_stop(dev, s);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\nprintk(KERN_ERR "comedi%d: "\r\n"AO buffer underrun\n", dev->minor);\r\n}\r\n}\r\nif (cmd->chanlist_len)\r\nroom /= cmd->chanlist_len;\r\nif (num_scans > room)\r\nnum_scans = room;\r\nfor (n = 0; n < num_scans; n++) {\r\ncfc_read_array_from_buffer(s, &devpriv->ao_scan_vals[0],\r\nbytes_per_scan);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\noutw(devpriv->ao_scan_vals[devpriv->ao_scan_order[i]],\r\ndev->iobase + PCI224_DACDATA);\r\n}\r\n}\r\nif (!devpriv->ao_stop_continuous) {\r\ndevpriv->ao_stop_count -= num_scans;\r\nif (devpriv->ao_stop_count == 0) {\r\ndevpriv->daccon = COMBINE(devpriv->daccon,\r\nPCI224_DACCON_FIFOINTR_EMPTY,\r\nPCI224_DACCON_FIFOINTR_MASK);\r\noutw(devpriv->daccon, dev->iobase + PCI224_DACCON);\r\n}\r\n}\r\nif ((devpriv->daccon & PCI224_DACCON_TRIG_MASK) ==\r\nPCI224_DACCON_TRIG_NONE) {\r\nunsigned short trig;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntrig = PCI224_DACCON_TRIG_Z2CT0;\r\n} else {\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\ntrig = PCI224_DACCON_TRIG_EXTN;\r\nelse\r\ntrig = PCI224_DACCON_TRIG_EXTP;\r\n}\r\ndevpriv->daccon = COMBINE(devpriv->daccon, trig,\r\nPCI224_DACCON_TRIG_MASK);\r\noutw(devpriv->daccon, dev->iobase + PCI224_DACCON);\r\n}\r\nif (s->async->events)\r\ncomedi_event(dev, s);\r\n}\r\nstatic int\r\npci224_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\ns->async->inttrig = NULLFUNC;\r\npci224_ao_start(dev, s);\r\nreturn 1;\r\n}\r\nstatic int\r\npci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_INT | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_EXT | TRIG_TIMER;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif ((cmd->start_src & (cmd->start_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->convert_src & (cmd->convert_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->stop_src & (cmd->stop_src - 1)) != 0)\r\nerr++;\r\ntmp = 0;\r\nif (cmd->start_src & TRIG_EXT)\r\ntmp++;\r\nif (cmd->scan_begin_src & TRIG_EXT)\r\ntmp++;\r\nif (cmd->stop_src & TRIG_EXT)\r\ntmp++;\r\nif (tmp > 1)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->start_arg & ~CR_FLAGS_MASK) != 0) {\r\ncmd->start_arg = COMBINE(cmd->start_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr++;\r\n}\r\nif ((cmd->start_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {\r\ncmd->start_arg = COMBINE(cmd->start_arg, 0,\r\nCR_FLAGS_MASK & ~CR_EDGE);\r\nerr++;\r\n}\r\nbreak;\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nif (cmd->scan_begin_arg > MAX_SCAN_PERIOD) {\r\ncmd->scan_begin_arg = MAX_SCAN_PERIOD;\r\nerr++;\r\n}\r\ntmp = cmd->chanlist_len * CONVERT_PERIOD;\r\nif (tmp < MIN_SCAN_PERIOD)\r\ntmp = MIN_SCAN_PERIOD;\r\nif (cmd->scan_begin_arg < tmp) {\r\ncmd->scan_begin_arg = tmp;\r\nerr++;\r\n}\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {\r\ncmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr++;\r\n}\r\nif ((cmd->scan_begin_arg & CR_FLAGS_MASK &\r\n~(CR_EDGE | CR_INVERT)) != 0) {\r\ncmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\r\nCR_FLAGS_MASK & ~(CR_EDGE\r\n|\r\nCR_INVERT));\r\nerr++;\r\n}\r\nbreak;\r\n}\r\nif (cmd->convert_arg != 0) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->stop_arg & ~CR_FLAGS_MASK) != 0) {\r\ncmd->stop_arg = COMBINE(cmd->stop_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr++;\r\n}\r\nif ((cmd->stop_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {\r\ncmd->stop_arg = COMBINE(cmd->stop_arg, 0,\r\nCR_FLAGS_MASK & ~CR_EDGE);\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int div1, div2, round;\r\nint round_mode = cmd->flags & TRIG_ROUND_MASK;\r\ntmp = cmd->scan_begin_arg;\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\nround = TIMEBASE_10MHZ / 2;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\nround = 0;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\nround = TIMEBASE_10MHZ - 1;\r\nbreak;\r\n}\r\ndiv2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;\r\ndiv2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /\r\nTIMEBASE_10MHZ;\r\nif (div2 <= 0x10000) {\r\nif (div2 < 2)\r\ndiv2 = 2;\r\ncmd->scan_begin_arg = div2 * TIMEBASE_10MHZ;\r\nif (cmd->scan_begin_arg < div2 ||\r\ncmd->scan_begin_arg < TIMEBASE_10MHZ) {\r\ncmd->scan_begin_arg = MAX_SCAN_PERIOD;\r\n}\r\n} else {\r\ndiv1 = devpriv->cached_div1;\r\ndiv2 = devpriv->cached_div2;\r\npci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,\r\n&cmd->scan_begin_arg,\r\nround_mode);\r\ndevpriv->cached_div1 = div1;\r\ndevpriv->cached_div2 = div2;\r\n}\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && (cmd->chanlist_len > 0)) {\r\nunsigned int range;\r\nenum { range_err = 1, dupchan_err = 2, };\r\nunsigned errors;\r\nunsigned int n;\r\nunsigned int ch;\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\nerrors = 0;\r\ntmp = 0;\r\nfor (n = 0; n < cmd->chanlist_len; n++) {\r\nch = CR_CHAN(cmd->chanlist[n]);\r\nif (tmp & (1U << ch))\r\nerrors |= dupchan_err;\r\ntmp |= (1U << ch);\r\nif (CR_RANGE(cmd->chanlist[n]) != range)\r\nerrors |= range_err;\r\n}\r\nif (errors) {\r\nif (errors & dupchan_err) {\r\nDPRINTK("comedi%d: " DRIVER_NAME\r\n": ao_cmdtest: "\r\n"entries in chanlist must contain no "\r\n"duplicate channels\n", dev->minor);\r\n}\r\nif (errors & range_err) {\r\nDPRINTK("comedi%d: " DRIVER_NAME\r\n": ao_cmdtest: "\r\n"entries in chanlist must all have "\r\n"the same range index\n", dev->minor);\r\n}\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint range;\r\nunsigned int i, j;\r\nunsigned int ch;\r\nunsigned int rank;\r\nunsigned long flags;\r\nif (cmd->chanlist == NULL || cmd->chanlist_len == 0)\r\nreturn -EINVAL;\r\ndevpriv->ao_enab = 0;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nch = CR_CHAN(cmd->chanlist[i]);\r\ndevpriv->ao_enab |= 1U << ch;\r\nrank = 0;\r\nfor (j = 0; j < cmd->chanlist_len; j++) {\r\nif (CR_CHAN(cmd->chanlist[j]) < ch)\r\nrank++;\r\n}\r\ndevpriv->ao_scan_order[rank] = i;\r\n}\r\noutw(devpriv->ao_enab, dev->iobase + PCI224_DACCEN);\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\ndevpriv->daccon = COMBINE(devpriv->daccon,\r\n(devpriv->\r\nhwrange[range] | PCI224_DACCON_TRIG_NONE |\r\nPCI224_DACCON_FIFOINTR_NHALF),\r\n(PCI224_DACCON_POLAR_MASK |\r\nPCI224_DACCON_VREF_MASK |\r\nPCI224_DACCON_TRIG_MASK |\r\nPCI224_DACCON_FIFOINTR_MASK));\r\noutw(devpriv->daccon | PCI224_DACCON_FIFORESET,\r\ndev->iobase + PCI224_DACCON);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int div1, div2, round;\r\nunsigned int ns = cmd->scan_begin_arg;\r\nint round_mode = cmd->flags & TRIG_ROUND_MASK;\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\nround = TIMEBASE_10MHZ / 2;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\nround = 0;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\nround = TIMEBASE_10MHZ - 1;\r\nbreak;\r\n}\r\ndiv2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;\r\ndiv2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /\r\nTIMEBASE_10MHZ;\r\nif (div2 <= 0x10000) {\r\nif (div2 < 2)\r\ndiv2 = 2;\r\ndiv2 &= 0xffff;\r\ndiv1 = 1;\r\n} else {\r\ndiv1 = devpriv->cached_div1;\r\ndiv2 = devpriv->cached_div2;\r\npci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,\r\n&ns, round_mode);\r\n}\r\noutb(GAT_CONFIG(0, GAT_VCC),\r\ndevpriv->iobase1 + PCI224_ZGAT_SCE);\r\nif (div1 == 1) {\r\noutb(CLK_CONFIG(0, CLK_10MHZ),\r\ndevpriv->iobase1 + PCI224_ZCLK_SCE);\r\n} else {\r\noutb(GAT_CONFIG(2, GAT_VCC),\r\ndevpriv->iobase1 + PCI224_ZGAT_SCE);\r\noutb(CLK_CONFIG(2, CLK_10MHZ),\r\ndevpriv->iobase1 + PCI224_ZCLK_SCE);\r\ni8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,\r\n2, div1, 2);\r\noutb(CLK_CONFIG(0, CLK_OUTNM1),\r\ndevpriv->iobase1 + PCI224_ZCLK_SCE);\r\n}\r\ni8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0, 0, div2, 2);\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\ndevpriv->ao_stop_continuous = 0;\r\ndevpriv->ao_stop_count = cmd->stop_arg;\r\nbreak;\r\ndefault:\r\ndevpriv->ao_stop_continuous = 1;\r\ndevpriv->ao_stop_count = 0;\r\nbreak;\r\n}\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\nspin_lock_irqsave(&devpriv->ao_spinlock, flags);\r\ns->async->inttrig = &pci224_ao_inttrig_start;\r\nspin_unlock_irqrestore(&devpriv->ao_spinlock, flags);\r\nbreak;\r\ncase TRIG_EXT:\r\nspin_lock_irqsave(&devpriv->ao_spinlock, flags);\r\ndevpriv->intsce |= PCI224_INTR_EXT;\r\noutb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->ao_spinlock, flags);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci224_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\npci224_ao_stop(dev, s);\r\nreturn 0;\r\n}\r\nstatic void\r\npci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,\r\nvoid *data, unsigned int num_bytes, unsigned int chan_index)\r\n{\r\nstruct comedi_async *async = s->async;\r\nshort *array = data;\r\nunsigned int length = num_bytes / sizeof(*array);\r\nunsigned int offset;\r\nunsigned int shift;\r\nunsigned int i;\r\nshift = 16 - thisboard->ao_bits;\r\nif ((devpriv->hwrange[CR_RANGE(async->cmd.chanlist[0])] &\r\nPCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {\r\noffset = 0;\r\n} else {\r\noffset = 32768;\r\n}\r\nfor (i = 0; i < length; i++)\r\narray[i] = (array[i] << shift) - offset;\r\n}\r\nstatic irqreturn_t pci224_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\nstruct comedi_cmd *cmd;\r\nunsigned char intstat, valid_intstat;\r\nunsigned char curenab;\r\nint retval = 0;\r\nunsigned long flags;\r\nintstat = inb(devpriv->iobase1 + PCI224_INT_SCE) & 0x3F;\r\nif (intstat) {\r\nretval = 1;\r\nspin_lock_irqsave(&devpriv->ao_spinlock, flags);\r\nvalid_intstat = devpriv->intsce & intstat;\r\ncurenab = devpriv->intsce & ~intstat;\r\noutb(curenab, devpriv->iobase1 + PCI224_INT_SCE);\r\ndevpriv->intr_running = 1;\r\ndevpriv->intr_cpuid = THISCPU;\r\nspin_unlock_irqrestore(&devpriv->ao_spinlock, flags);\r\nif (valid_intstat != 0) {\r\ncmd = &s->async->cmd;\r\nif (valid_intstat & PCI224_INTR_EXT) {\r\ndevpriv->intsce &= ~PCI224_INTR_EXT;\r\nif (cmd->start_src == TRIG_EXT)\r\npci224_ao_start(dev, s);\r\nelse if (cmd->stop_src == TRIG_EXT)\r\npci224_ao_stop(dev, s);\r\n}\r\nif (valid_intstat & PCI224_INTR_DAC)\r\npci224_ao_handle_fifo(dev, s);\r\n}\r\nspin_lock_irqsave(&devpriv->ao_spinlock, flags);\r\nif (curenab != devpriv->intsce) {\r\noutb(devpriv->intsce,\r\ndevpriv->iobase1 + PCI224_INT_SCE);\r\n}\r\ndevpriv->intr_running = 0;\r\nspin_unlock_irqrestore(&devpriv->ao_spinlock, flags);\r\n}\r\nreturn IRQ_RETVAL(retval);\r\n}\r\nstatic int\r\npci224_find_pci(struct comedi_device *dev, int bus, int slot,\r\nstruct pci_dev **pci_dev_p)\r\n{\r\nstruct pci_dev *pci_dev = NULL;\r\n*pci_dev_p = NULL;\r\nfor (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);\r\npci_dev != NULL;\r\npci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,\r\npci_dev)) {\r\nif (bus || slot) {\r\nif (bus != pci_dev->bus->number\r\n|| slot != PCI_SLOT(pci_dev->devfn))\r\ncontinue;\r\n}\r\nif (thisboard->model == any_model) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pci224_boards); i++) {\r\nif (pci_dev->device == pci224_boards[i].devid) {\r\ndev->board_ptr = &pci224_boards[i];\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(pci224_boards))\r\ncontinue;\r\n} else {\r\nif (thisboard->devid != pci_dev->device)\r\ncontinue;\r\n}\r\n*pci_dev_p = pci_dev;\r\nreturn 0;\r\n}\r\nif (bus || slot) {\r\nprintk(KERN_ERR "comedi%d: error! "\r\n"no %s found at pci %02x:%02x!\n",\r\ndev->minor, thisboard->name, bus, slot);\r\n} else {\r\nprintk(KERN_ERR "comedi%d: error! no %s found!\n",\r\ndev->minor, thisboard->name);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nstruct pci_dev *pci_dev;\r\nunsigned int irq;\r\nint bus = 0, slot = 0;\r\nunsigned n;\r\nint ret;\r\nprintk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor, DRIVER_NAME);\r\nbus = it->options[0];\r\nslot = it->options[1];\r\nret = alloc_private(dev, sizeof(struct pci224_private));\r\nif (ret < 0) {\r\nprintk(KERN_ERR "comedi%d: error! out of memory!\n",\r\ndev->minor);\r\nreturn ret;\r\n}\r\nret = pci224_find_pci(dev, bus, slot, &pci_dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndevpriv->pci_dev = pci_dev;\r\nret = comedi_pci_enable(pci_dev, DRIVER_NAME);\r\nif (ret < 0) {\r\nprintk(KERN_ERR\r\n"comedi%d: error! cannot enable PCI device "\r\n"and request regions!\n", dev->minor);\r\nreturn ret;\r\n}\r\nspin_lock_init(&devpriv->ao_spinlock);\r\ndevpriv->iobase1 = pci_resource_start(pci_dev, 2);\r\ndev->iobase = pci_resource_start(pci_dev, 3);\r\nirq = pci_dev->irq;\r\ndevpriv->ao_readback = kmalloc(sizeof(devpriv->ao_readback[0]) *\r\nthisboard->ao_chans, GFP_KERNEL);\r\nif (!devpriv->ao_readback)\r\nreturn -ENOMEM;\r\ndevpriv->ao_scan_vals = kmalloc(sizeof(devpriv->ao_scan_vals[0]) *\r\nthisboard->ao_chans, GFP_KERNEL);\r\nif (!devpriv->ao_scan_vals)\r\nreturn -ENOMEM;\r\ndevpriv->ao_scan_order = kmalloc(sizeof(devpriv->ao_scan_order[0]) *\r\nthisboard->ao_chans, GFP_KERNEL);\r\nif (!devpriv->ao_scan_order)\r\nreturn -ENOMEM;\r\ndevpriv->intsce = 0;\r\noutb(0, devpriv->iobase1 + PCI224_INT_SCE);\r\noutw(PCI224_DACCON_GLOBALRESET, dev->iobase + PCI224_DACCON);\r\noutw(0, dev->iobase + PCI224_DACCEN);\r\noutw(0, dev->iobase + PCI224_FIFOSIZ);\r\ndevpriv->daccon = (PCI224_DACCON_TRIG_SW | PCI224_DACCON_POLAR_BI |\r\nPCI224_DACCON_FIFOENAB |\r\nPCI224_DACCON_FIFOINTR_EMPTY);\r\noutw(devpriv->daccon | PCI224_DACCON_FIFORESET,\r\ndev->iobase + PCI224_DACCON);\r\nret = alloc_subdevices(dev, 1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "comedi%d: error! out of memory!\n",\r\ndev->minor);\r\nreturn ret;\r\n}\r\ns = dev->subdevices + 0;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;\r\ns->n_chan = thisboard->ao_chans;\r\ns->maxdata = (1 << thisboard->ao_bits) - 1;\r\ns->insn_write = &pci224_ao_insn_write;\r\ns->insn_read = &pci224_ao_insn_read;\r\ns->len_chanlist = s->n_chan;\r\ndev->write_subdev = s;\r\ns->do_cmd = &pci224_ao_cmd;\r\ns->do_cmdtest = &pci224_ao_cmdtest;\r\ns->cancel = &pci224_ao_cancel;\r\ns->munge = &pci224_ao_munge;\r\nif (thisboard->model == pci234_model) {\r\nconst struct comedi_lrange **range_table_list;\r\ns->range_table_list = range_table_list =\r\nkmalloc(sizeof(struct comedi_lrange *) * s->n_chan,\r\nGFP_KERNEL);\r\nif (!s->range_table_list)\r\nreturn -ENOMEM;\r\nfor (n = 2; n < 3 + s->n_chan; n++) {\r\nif (it->options[n] < 0 || it->options[n] > 1) {\r\nprintk(KERN_WARNING "comedi%d: %s: warning! "\r\n"bad options[%u]=%d\n",\r\ndev->minor, DRIVER_NAME, n,\r\nit->options[n]);\r\n}\r\n}\r\nfor (n = 0; n < s->n_chan; n++) {\r\nif (n < COMEDI_NDEVCONFOPTS - 3 &&\r\nit->options[3 + n] == 1) {\r\nif (it->options[2] == 1)\r\nrange_table_list[n] = &range_pci234_ext;\r\nelse\r\nrange_table_list[n] = &range_bipolar5;\r\n} else {\r\nif (it->options[2] == 1) {\r\nrange_table_list[n] =\r\n&range_pci234_ext2;\r\n} else {\r\nrange_table_list[n] = &range_bipolar10;\r\n}\r\n}\r\n}\r\ndevpriv->hwrange = hwrange_pci234;\r\n} else {\r\nif (it->options[2] == 1) {\r\ns->range_table = &range_pci224_external;\r\ndevpriv->hwrange = hwrange_pci224_external;\r\n} else {\r\nif (it->options[2] != 0) {\r\nprintk(KERN_WARNING "comedi%d: %s: warning! "\r\n"bad options[2]=%d\n",\r\ndev->minor, DRIVER_NAME, it->options[2]);\r\n}\r\ns->range_table = &range_pci224_internal;\r\ndevpriv->hwrange = hwrange_pci224_internal;\r\n}\r\n}\r\ndev->board_name = thisboard->name;\r\nif (irq) {\r\nret = request_irq(irq, pci224_interrupt, IRQF_SHARED,\r\nDRIVER_NAME, dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "comedi%d: error! "\r\n"unable to allocate irq %u\n", dev->minor, irq);\r\nreturn ret;\r\n} else {\r\ndev->irq = irq;\r\n}\r\n}\r\nprintk(KERN_INFO "comedi%d: %s ", dev->minor, dev->board_name);\r\nprintk("(pci %s) ", pci_name(pci_dev));\r\nif (irq)\r\nprintk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));\r\nelse\r\nprintk("(no irq) ");\r\nprintk("attached\n");\r\nreturn 1;\r\n}\r\nstatic int pci224_detach(struct comedi_device *dev)\r\n{\r\nprintk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->subdevices) {\r\nstruct comedi_subdevice *s;\r\ns = dev->subdevices + 0;\r\nkfree(s->range_table_list);\r\n}\r\nif (devpriv) {\r\nkfree(devpriv->ao_readback);\r\nkfree(devpriv->ao_scan_vals);\r\nkfree(devpriv->ao_scan_order);\r\nif (devpriv->pci_dev) {\r\nif (dev->iobase)\r\ncomedi_pci_disable(devpriv->pci_dev);\r\npci_dev_put(devpriv->pci_dev);\r\n}\r\n}\r\nif (dev->board_name) {\r\nprintk(KERN_INFO "comedi%d: %s removed\n",\r\ndev->minor, dev->board_name);\r\n}\r\nreturn 0;\r\n}
