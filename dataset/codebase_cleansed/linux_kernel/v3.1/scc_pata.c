static u8 scc_ide_inb(unsigned long port)\r\n{\r\nu32 data = in_be32((void*)port);\r\nreturn (u8)data;\r\n}\r\nstatic void scc_exec_command(ide_hwif_t *hwif, u8 cmd)\r\n{\r\nout_be32((void *)hwif->io_ports.command_addr, cmd);\r\neieio();\r\nin_be32((void *)(hwif->dma_base + 0x01c));\r\neieio();\r\n}\r\nstatic u8 scc_read_status(ide_hwif_t *hwif)\r\n{\r\nreturn (u8)in_be32((void *)hwif->io_ports.status_addr);\r\n}\r\nstatic u8 scc_read_altstatus(ide_hwif_t *hwif)\r\n{\r\nreturn (u8)in_be32((void *)hwif->io_ports.ctl_addr);\r\n}\r\nstatic u8 scc_dma_sff_read_status(ide_hwif_t *hwif)\r\n{\r\nreturn (u8)in_be32((void *)(hwif->dma_base + 4));\r\n}\r\nstatic void scc_write_devctl(ide_hwif_t *hwif, u8 ctl)\r\n{\r\nout_be32((void *)hwif->io_ports.ctl_addr, ctl);\r\neieio();\r\nin_be32((void *)(hwif->dma_base + 0x01c));\r\neieio();\r\n}\r\nstatic void scc_ide_insw(unsigned long port, void *addr, u32 count)\r\n{\r\nu16 *ptr = (u16 *)addr;\r\nwhile (count--) {\r\n*ptr++ = le16_to_cpu(in_be32((void*)port));\r\n}\r\n}\r\nstatic void scc_ide_insl(unsigned long port, void *addr, u32 count)\r\n{\r\nu16 *ptr = (u16 *)addr;\r\nwhile (count--) {\r\n*ptr++ = le16_to_cpu(in_be32((void*)port));\r\n*ptr++ = le16_to_cpu(in_be32((void*)port));\r\n}\r\n}\r\nstatic void scc_ide_outb(u8 addr, unsigned long port)\r\n{\r\nout_be32((void*)port, addr);\r\n}\r\nstatic void\r\nscc_ide_outsw(unsigned long port, void *addr, u32 count)\r\n{\r\nu16 *ptr = (u16 *)addr;\r\nwhile (count--) {\r\nout_be32((void*)port, cpu_to_le16(*ptr++));\r\n}\r\n}\r\nstatic void\r\nscc_ide_outsl(unsigned long port, void *addr, u32 count)\r\n{\r\nu16 *ptr = (u16 *)addr;\r\nwhile (count--) {\r\nout_be32((void*)port, cpu_to_le16(*ptr++));\r\nout_be32((void*)port, cpu_to_le16(*ptr++));\r\n}\r\n}\r\nstatic void scc_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstruct scc_ports *ports = ide_get_hwifdata(hwif);\r\nunsigned long ctl_base = ports->ctl;\r\nunsigned long cckctrl_port = ctl_base + 0xff0;\r\nunsigned long piosht_port = ctl_base + 0x000;\r\nunsigned long pioct_port = ctl_base + 0x004;\r\nunsigned long reg;\r\nint offset;\r\nconst u8 pio = drive->pio_mode - XFER_PIO_0;\r\nreg = in_be32((void __iomem *)cckctrl_port);\r\nif (reg & CCKCTRL_ATACLKOEN) {\r\noffset = 1;\r\n} else {\r\noffset = 0;\r\n}\r\nreg = JCHSTtbl[offset][pio] << 16 | JCHHTtbl[offset][pio];\r\nout_be32((void __iomem *)piosht_port, reg);\r\nreg = JCHCTtbl[offset][pio];\r\nout_be32((void __iomem *)pioct_port, reg);\r\n}\r\nstatic void scc_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstruct scc_ports *ports = ide_get_hwifdata(hwif);\r\nunsigned long ctl_base = ports->ctl;\r\nunsigned long cckctrl_port = ctl_base + 0xff0;\r\nunsigned long mdmact_port = ctl_base + 0x008;\r\nunsigned long mcrcst_port = ctl_base + 0x00c;\r\nunsigned long sdmact_port = ctl_base + 0x010;\r\nunsigned long scrcst_port = ctl_base + 0x014;\r\nunsigned long udenvt_port = ctl_base + 0x018;\r\nunsigned long tdvhsel_port = ctl_base + 0x020;\r\nint is_slave = drive->dn & 1;\r\nint offset, idx;\r\nunsigned long reg;\r\nunsigned long jcactsel;\r\nconst u8 speed = drive->dma_mode;\r\nreg = in_be32((void __iomem *)cckctrl_port);\r\nif (reg & CCKCTRL_ATACLKOEN) {\r\noffset = 1;\r\n} else {\r\noffset = 0;\r\n}\r\nidx = speed - XFER_UDMA_0;\r\njcactsel = JCACTSELtbl[offset][idx];\r\nif (is_slave) {\r\nout_be32((void __iomem *)sdmact_port, JCHDCTxtbl[offset][idx]);\r\nout_be32((void __iomem *)scrcst_port, JCSTWTxtbl[offset][idx]);\r\njcactsel = jcactsel << 2;\r\nout_be32((void __iomem *)tdvhsel_port, (in_be32((void __iomem *)tdvhsel_port) & ~TDVHSEL_SLAVE) | jcactsel);\r\n} else {\r\nout_be32((void __iomem *)mdmact_port, JCHDCTxtbl[offset][idx]);\r\nout_be32((void __iomem *)mcrcst_port, JCSTWTxtbl[offset][idx]);\r\nout_be32((void __iomem *)tdvhsel_port, (in_be32((void __iomem *)tdvhsel_port) & ~TDVHSEL_MASTER) | jcactsel);\r\n}\r\nreg = JCTSStbl[offset][idx] << 16 | JCENVTtbl[offset][idx];\r\nout_be32((void __iomem *)udenvt_port, reg);\r\n}\r\nstatic void scc_dma_host_set(ide_drive_t *drive, int on)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 unit = drive->dn & 1;\r\nu8 dma_stat = scc_dma_sff_read_status(hwif);\r\nif (on)\r\ndma_stat |= (1 << (5 + unit));\r\nelse\r\ndma_stat &= ~(1 << (5 + unit));\r\nscc_ide_outb(dma_stat, hwif->dma_base + 4);\r\n}\r\nstatic int scc_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu32 rw = (cmd->tf_flags & IDE_TFLAG_WRITE) ? 0 : ATA_DMA_WR;\r\nu8 dma_stat;\r\nif (ide_build_dmatable(drive, cmd) == 0)\r\nreturn 1;\r\nout_be32((void __iomem *)(hwif->dma_base + 8), hwif->dmatable_dma);\r\nout_be32((void __iomem *)hwif->dma_base, rw);\r\ndma_stat = scc_dma_sff_read_status(hwif);\r\nout_be32((void __iomem *)(hwif->dma_base + 4), dma_stat | 6);\r\nreturn 0;\r\n}\r\nstatic void scc_dma_start(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 dma_cmd = scc_ide_inb(hwif->dma_base);\r\nscc_ide_outb(dma_cmd | 1, hwif->dma_base);\r\n}\r\nstatic int __scc_dma_end(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 dma_stat, dma_cmd;\r\ndma_cmd = scc_ide_inb(hwif->dma_base);\r\nscc_ide_outb(dma_cmd & ~1, hwif->dma_base);\r\ndma_stat = scc_dma_sff_read_status(hwif);\r\nscc_ide_outb(dma_stat | 6, hwif->dma_base + 4);\r\nreturn (dma_stat & 7) != 4 ? (0x10 | dma_stat) : 0;\r\n}\r\nstatic int scc_dma_end(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nvoid __iomem *dma_base = (void __iomem *)hwif->dma_base;\r\nunsigned long intsts_port = hwif->dma_base + 0x014;\r\nu32 reg;\r\nint dma_stat, data_loss = 0;\r\nstatic int retry = 0;\r\nif (!(in_be32((void __iomem *)hwif->io_ports.ctl_addr)\r\n& ATA_ERR) &&\r\ndrive->media == ide_disk && drive->current_speed > XFER_UDMA_4) {\r\nreg = in_be32((void __iomem *)intsts_port);\r\nif (!(reg & INTSTS_ACTEINT)) {\r\nprintk(KERN_WARNING "%s: operation failed (transfer data loss)\n",\r\ndrive->name);\r\ndata_loss = 1;\r\nif (retry++) {\r\nstruct request *rq = hwif->rq;\r\nide_drive_t *drive;\r\nint i;\r\nif (rq)\r\nrq->errors |= ERROR_RESET;\r\nide_port_for_each_dev(i, drive, hwif)\r\ndrive->crc_count++;\r\n}\r\n}\r\n}\r\nwhile (1) {\r\nreg = in_be32((void __iomem *)intsts_port);\r\nif (reg & INTSTS_SERROR) {\r\nprintk(KERN_WARNING "%s: SERROR\n", SCC_PATA_NAME);\r\nout_be32((void __iomem *)intsts_port, INTSTS_SERROR|INTSTS_BMSINT);\r\nout_be32(dma_base, in_be32(dma_base) & ~QCHCD_IOS_SS);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_PRERR) {\r\nu32 maea0, maec0;\r\nunsigned long ctl_base = hwif->config_data;\r\nmaea0 = in_be32((void __iomem *)(ctl_base + 0xF50));\r\nmaec0 = in_be32((void __iomem *)(ctl_base + 0xF54));\r\nprintk(KERN_WARNING "%s: PRERR [addr:%x cmd:%x]\n", SCC_PATA_NAME, maea0, maec0);\r\nout_be32((void __iomem *)intsts_port, INTSTS_PRERR|INTSTS_BMSINT);\r\nout_be32(dma_base, in_be32(dma_base) & ~QCHCD_IOS_SS);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_RERR) {\r\nprintk(KERN_WARNING "%s: Response Error\n", SCC_PATA_NAME);\r\nout_be32((void __iomem *)intsts_port, INTSTS_RERR|INTSTS_BMSINT);\r\nout_be32(dma_base, in_be32(dma_base) & ~QCHCD_IOS_SS);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_ICERR) {\r\nout_be32(dma_base, in_be32(dma_base) & ~QCHCD_IOS_SS);\r\nprintk(KERN_WARNING "%s: Illegal Configuration\n", SCC_PATA_NAME);\r\nout_be32((void __iomem *)intsts_port, INTSTS_ICERR|INTSTS_BMSINT);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_BMSINT) {\r\nprintk(KERN_WARNING "%s: Internal Bus Error\n", SCC_PATA_NAME);\r\nout_be32((void __iomem *)intsts_port, INTSTS_BMSINT);\r\nide_do_reset(drive);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_BMHE) {\r\nout_be32((void __iomem *)intsts_port, INTSTS_BMHE);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_ACTEINT) {\r\nout_be32((void __iomem *)intsts_port, INTSTS_ACTEINT);\r\ncontinue;\r\n}\r\nif (reg & INTSTS_IOIRQS) {\r\nout_be32((void __iomem *)intsts_port, INTSTS_IOIRQS);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\ndma_stat = __scc_dma_end(drive);\r\nif (data_loss)\r\ndma_stat |= 2;\r\nreturn dma_stat;\r\n}\r\nstatic int scc_dma_test_irq(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu32 int_stat = in_be32((void __iomem *)hwif->dma_base + 0x014);\r\nif ((in_be32((void __iomem *)hwif->io_ports.ctl_addr)\r\n& ATA_ERR) &&\r\n(int_stat & INTSTS_INTRQ))\r\nreturn 1;\r\nif (int_stat & INTSTS_IOIRQS)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic u8 scc_udma_filter(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 mask = hwif->ultra_mask;\r\nif ((drive->media != ide_disk) && (mask & 0xE0)) {\r\nprintk(KERN_INFO "%s: limit %s to UDMA4\n",\r\nSCC_PATA_NAME, drive->name);\r\nmask = ATA_UDMA4;\r\n}\r\nreturn mask;\r\n}\r\nstatic int setup_mmio_scc (struct pci_dev *dev, const char *name)\r\n{\r\nvoid __iomem *ctl_addr;\r\nvoid __iomem *dma_addr;\r\nint i, ret;\r\nfor (i = 0; i < MAX_HWIFS; i++) {\r\nif (scc_ports[i].ctl == 0)\r\nbreak;\r\n}\r\nif (i >= MAX_HWIFS)\r\nreturn -ENOMEM;\r\nret = pci_request_selected_regions(dev, (1 << 2) - 1, name);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: can't reserve resources\n", name);\r\nreturn ret;\r\n}\r\nctl_addr = pci_ioremap_bar(dev, 0);\r\nif (!ctl_addr)\r\ngoto fail_0;\r\ndma_addr = pci_ioremap_bar(dev, 1);\r\nif (!dma_addr)\r\ngoto fail_1;\r\npci_set_master(dev);\r\nscc_ports[i].ctl = (unsigned long)ctl_addr;\r\nscc_ports[i].dma = (unsigned long)dma_addr;\r\npci_set_drvdata(dev, (void *) &scc_ports[i]);\r\nreturn 1;\r\nfail_1:\r\niounmap(ctl_addr);\r\nfail_0:\r\nreturn -ENOMEM;\r\n}\r\nstatic int scc_ide_setup_pci_device(struct pci_dev *dev,\r\nconst struct ide_port_info *d)\r\n{\r\nstruct scc_ports *ports = pci_get_drvdata(dev);\r\nstruct ide_host *host;\r\nstruct ide_hw hw, *hws[] = { &hw };\r\nint i, rc;\r\nmemset(&hw, 0, sizeof(hw));\r\nfor (i = 0; i <= 8; i++)\r\nhw.io_ports_array[i] = ports->dma + 0x20 + i * 4;\r\nhw.irq = dev->irq;\r\nhw.dev = &dev->dev;\r\nrc = ide_host_add(d, hws, 1, &host);\r\nif (rc)\r\nreturn rc;\r\nports->host = host;\r\nreturn 0;\r\n}\r\nstatic int __devinit init_setup_scc(struct pci_dev *dev,\r\nconst struct ide_port_info *d)\r\n{\r\nunsigned long ctl_base;\r\nunsigned long dma_base;\r\nunsigned long cckctrl_port;\r\nunsigned long intmask_port;\r\nunsigned long mode_port;\r\nunsigned long ecmode_port;\r\nu32 reg = 0;\r\nstruct scc_ports *ports;\r\nint rc;\r\nrc = pci_enable_device(dev);\r\nif (rc)\r\ngoto end;\r\nrc = setup_mmio_scc(dev, d->name);\r\nif (rc < 0)\r\ngoto end;\r\nports = pci_get_drvdata(dev);\r\nctl_base = ports->ctl;\r\ndma_base = ports->dma;\r\ncckctrl_port = ctl_base + 0xff0;\r\nintmask_port = dma_base + 0x010;\r\nmode_port = ctl_base + 0x024;\r\necmode_port = ctl_base + 0xf00;\r\nreg = 0;\r\nout_be32((void*)cckctrl_port, reg);\r\nreg |= CCKCTRL_ATACLKOEN;\r\nout_be32((void*)cckctrl_port, reg);\r\nreg |= CCKCTRL_LCLKEN | CCKCTRL_OCLKEN;\r\nout_be32((void*)cckctrl_port, reg);\r\nreg |= CCKCTRL_CRST;\r\nout_be32((void*)cckctrl_port, reg);\r\nfor (;;) {\r\nreg = in_be32((void*)cckctrl_port);\r\nif (reg & CCKCTRL_CRST)\r\nbreak;\r\nudelay(5000);\r\n}\r\nreg |= CCKCTRL_ATARESET;\r\nout_be32((void*)cckctrl_port, reg);\r\nout_be32((void*)ecmode_port, ECMODE_VALUE);\r\nout_be32((void*)mode_port, MODE_JCUSFEN);\r\nout_be32((void*)intmask_port, INTMASK_MSK);\r\nrc = scc_ide_setup_pci_device(dev, d);\r\nend:\r\nreturn rc;\r\n}\r\nstatic void scc_tf_load(ide_drive_t *drive, struct ide_taskfile *tf, u8 valid)\r\n{\r\nstruct ide_io_ports *io_ports = &drive->hwif->io_ports;\r\nif (valid & IDE_VALID_FEATURE)\r\nscc_ide_outb(tf->feature, io_ports->feature_addr);\r\nif (valid & IDE_VALID_NSECT)\r\nscc_ide_outb(tf->nsect, io_ports->nsect_addr);\r\nif (valid & IDE_VALID_LBAL)\r\nscc_ide_outb(tf->lbal, io_ports->lbal_addr);\r\nif (valid & IDE_VALID_LBAM)\r\nscc_ide_outb(tf->lbam, io_ports->lbam_addr);\r\nif (valid & IDE_VALID_LBAH)\r\nscc_ide_outb(tf->lbah, io_ports->lbah_addr);\r\nif (valid & IDE_VALID_DEVICE)\r\nscc_ide_outb(tf->device, io_ports->device_addr);\r\n}\r\nstatic void scc_tf_read(ide_drive_t *drive, struct ide_taskfile *tf, u8 valid)\r\n{\r\nstruct ide_io_ports *io_ports = &drive->hwif->io_ports;\r\nif (valid & IDE_VALID_ERROR)\r\ntf->error = scc_ide_inb(io_ports->feature_addr);\r\nif (valid & IDE_VALID_NSECT)\r\ntf->nsect = scc_ide_inb(io_ports->nsect_addr);\r\nif (valid & IDE_VALID_LBAL)\r\ntf->lbal = scc_ide_inb(io_ports->lbal_addr);\r\nif (valid & IDE_VALID_LBAM)\r\ntf->lbam = scc_ide_inb(io_ports->lbam_addr);\r\nif (valid & IDE_VALID_LBAH)\r\ntf->lbah = scc_ide_inb(io_ports->lbah_addr);\r\nif (valid & IDE_VALID_DEVICE)\r\ntf->device = scc_ide_inb(io_ports->device_addr);\r\n}\r\nstatic void scc_input_data(ide_drive_t *drive, struct ide_cmd *cmd,\r\nvoid *buf, unsigned int len)\r\n{\r\nunsigned long data_addr = drive->hwif->io_ports.data_addr;\r\nlen++;\r\nif (drive->io_32bit) {\r\nscc_ide_insl(data_addr, buf, len / 4);\r\nif ((len & 3) >= 2)\r\nscc_ide_insw(data_addr, (u8 *)buf + (len & ~3), 1);\r\n} else\r\nscc_ide_insw(data_addr, buf, len / 2);\r\n}\r\nstatic void scc_output_data(ide_drive_t *drive, struct ide_cmd *cmd,\r\nvoid *buf, unsigned int len)\r\n{\r\nunsigned long data_addr = drive->hwif->io_ports.data_addr;\r\nlen++;\r\nif (drive->io_32bit) {\r\nscc_ide_outsl(data_addr, buf, len / 4);\r\nif ((len & 3) >= 2)\r\nscc_ide_outsw(data_addr, (u8 *)buf + (len & ~3), 1);\r\n} else\r\nscc_ide_outsw(data_addr, buf, len / 2);\r\n}\r\nstatic void __devinit init_mmio_iops_scc(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct scc_ports *ports = pci_get_drvdata(dev);\r\nunsigned long dma_base = ports->dma;\r\nide_set_hwifdata(hwif, ports);\r\nhwif->dma_base = dma_base;\r\nhwif->config_data = ports->ctl;\r\n}\r\nstatic void __devinit init_iops_scc(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nhwif->hwif_data = NULL;\r\nif (pci_get_drvdata(dev) == NULL)\r\nreturn;\r\ninit_mmio_iops_scc(hwif);\r\n}\r\nstatic int __devinit scc_init_dma(ide_hwif_t *hwif,\r\nconst struct ide_port_info *d)\r\n{\r\nreturn ide_allocate_dma_engine(hwif);\r\n}\r\nstatic u8 scc_cable_detect(ide_hwif_t *hwif)\r\n{\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic void __devinit init_hwif_scc(ide_hwif_t *hwif)\r\n{\r\nout_be32((void __iomem *)(hwif->dma_base + 0x018), hwif->dmatable_dma);\r\nif (in_be32((void __iomem *)(hwif->config_data + 0xff0)) & CCKCTRL_ATACLKOEN)\r\nhwif->ultra_mask = ATA_UDMA6;\r\nelse\r\nhwif->ultra_mask = ATA_UDMA5;\r\n}\r\nstatic int __devinit scc_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nreturn init_setup_scc(dev, &scc_chipset);\r\n}\r\nstatic void __devexit scc_remove(struct pci_dev *dev)\r\n{\r\nstruct scc_ports *ports = pci_get_drvdata(dev);\r\nstruct ide_host *host = ports->host;\r\nide_host_remove(host);\r\niounmap((void*)ports->dma);\r\niounmap((void*)ports->ctl);\r\npci_release_selected_regions(dev, (1 << 2) - 1);\r\nmemset(ports, 0, sizeof(*ports));\r\n}\r\nstatic int __init scc_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&scc_pci_driver);\r\n}\r\nstatic void __exit scc_ide_exit(void)\r\n{\r\npci_unregister_driver(&scc_pci_driver);\r\n}
