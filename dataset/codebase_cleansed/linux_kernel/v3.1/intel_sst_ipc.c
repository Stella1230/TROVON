static void sst_send_sound_card_type(void)\r\n{\r\nstruct ipc_post *msg = NULL;\r\nif (sst_create_short_msg(&msg))\r\nreturn;\r\nsst_fill_header(&msg->header, IPC_IA_SET_PMIC_TYPE, 0, 0);\r\nmsg->header.part.data = sst_drv_ctx->pmic_vendor;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nreturn;\r\n}\r\nvoid sst_post_message(struct work_struct *work)\r\n{\r\nstruct ipc_post *msg;\r\nunion ipc_header header;\r\nunion interrupt_reg imr;\r\nint retval = 0;\r\nimr.full = 0;\r\nretval = sst_stalled();\r\nif (retval < 0) {\r\npr_err("in stalled state\n");\r\nreturn;\r\n}\r\npr_debug("post message called\n");\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nif (list_empty(&sst_drv_ctx->ipc_dispatch_list)) {\r\npr_debug("Empty msg queue... masking\n");\r\nimr.full = readl(sst_drv_ctx->shim + SST_IMRX);\r\nimr.part.done_interrupt = 1;\r\nsst_shim_write(sst_drv_ctx->shim, SST_IMRX, imr.full);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nreturn;\r\n}\r\nheader.full = sst_shim_read(sst_drv_ctx->shim, SST_IPCX);\r\nif (header.part.busy) {\r\npr_debug("Busy not free... unmasking\n");\r\nimr.full = readl(sst_drv_ctx->shim + SST_IMRX);\r\nimr.part.done_interrupt = 0;\r\nsst_shim_write(sst_drv_ctx->shim, SST_IMRX, imr.full);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nreturn;\r\n}\r\nmsg = list_entry(sst_drv_ctx->ipc_dispatch_list.next,\r\nstruct ipc_post, node);\r\nlist_del(&msg->node);\r\npr_debug("Post message: header = %x\n", msg->header.full);\r\npr_debug("size: = %x\n", msg->header.part.data);\r\nif (msg->header.part.large)\r\nmemcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,\r\nmsg->mailbox_data, msg->header.part.data);\r\nsst_shim_write(sst_drv_ctx->shim, SST_IPCX, msg->header.full);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nkfree(msg->mailbox_data);\r\nkfree(msg);\r\nreturn;\r\n}\r\nvoid sst_clear_interrupt(void)\r\n{\r\nunion interrupt_reg isr;\r\nunion interrupt_reg imr;\r\nunion ipc_header clear_ipc;\r\nimr.full = sst_shim_read(sst_drv_ctx->shim, SST_IMRX);\r\nisr.full = sst_shim_read(sst_drv_ctx->shim, SST_ISRX);\r\n;\r\nisr.part.busy_interrupt = 1;\r\nsst_shim_write(sst_drv_ctx->shim, SST_ISRX, isr.full);\r\nclear_ipc.full = sst_shim_read(sst_drv_ctx->shim, SST_IPCD);\r\nclear_ipc.part.busy = 0;\r\nclear_ipc.part.done = 1;\r\nclear_ipc.part.data = IPC_ACK_SUCCESS;\r\nsst_shim_write(sst_drv_ctx->shim, SST_IPCD, clear_ipc.full);\r\nimr.part.busy_interrupt = 0;\r\nsst_shim_write(sst_drv_ctx->shim, SST_IMRX, imr.full);\r\n}\r\nvoid sst_restore_fw_context(void)\r\n{\r\nstruct snd_sst_ctxt_params fw_context;\r\nstruct ipc_post *msg = NULL;\r\npr_debug("restore_fw_context\n");\r\nif (sst_drv_ctx->pci_id != SST_MFLD_PCI_ID)\r\nreturn;\r\nif (!sst_drv_ctx->fw_cntx_size)\r\nreturn;\r\npr_debug("restoring context......\n");\r\nif (sst_create_large_msg(&msg))\r\nreturn;\r\nsst_fill_header(&msg->header, IPC_IA_SET_FW_CTXT, 1, 0);\r\nmsg->header.part.data = sizeof(fw_context) + sizeof(u32);\r\nfw_context.address = virt_to_phys((void *)sst_drv_ctx->fw_cntx);\r\nfw_context.size = sst_drv_ctx->fw_cntx_size;\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32),\r\n&fw_context, sizeof(fw_context));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nreturn;\r\n}\r\nint process_fw_init(struct sst_ipc_msg_wq *msg)\r\n{\r\nstruct ipc_header_fw_init *init =\r\n(struct ipc_header_fw_init *)msg->mailbox;\r\nint retval = 0;\r\npr_debug("*** FW Init msg came***\n");\r\nif (init->result) {\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_drv_ctx->sst_state = SST_ERROR;\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\npr_debug("FW Init failed, Error %x\n", init->result);\r\npr_err("FW Init failed, Error %x\n", init->result);\r\nretval = -init->result;\r\nreturn retval;\r\n}\r\nif (sst_drv_ctx->pci_id == SST_MRST_PCI_ID)\r\nsst_send_sound_card_type();\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_drv_ctx->sst_state = SST_FW_RUNNING;\r\nsst_drv_ctx->lpe_stalled = 0;\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\npr_debug("FW Version %02x.%02x.%02x\n", init->fw_version.major,\r\ninit->fw_version.minor, init->fw_version.build);\r\npr_debug("Build Type %x\n", init->fw_version.type);\r\npr_debug(" Build date %s Time %s\n",\r\ninit->build_info.date, init->build_info.time);\r\nsst_wake_up_alloc_block(sst_drv_ctx, FW_DWNL_ID, retval, NULL);\r\nsst_restore_fw_context();\r\nreturn retval;\r\n}\r\nvoid sst_process_message(struct work_struct *work)\r\n{\r\nstruct sst_ipc_msg_wq *msg =\r\ncontainer_of(work, struct sst_ipc_msg_wq, wq);\r\nint str_id = msg->header.part.str_id;\r\npr_debug("IPC process for %x\n", msg->header.full);\r\nswitch (msg->header.part.msg_id) {\r\ncase IPC_SST_BUF_UNDER_RUN:\r\ncase IPC_SST_BUF_OVER_RUN:\r\nif (sst_validate_strid(str_id)) {\r\npr_err("stream id %d invalid\n", str_id);\r\nbreak;\r\n}\r\npr_err("Buffer under/overrun for %d\n",\r\nmsg->header.part.str_id);\r\npr_err("Got Underrun & not to send data...ignore\n");\r\nbreak;\r\ncase IPC_SST_GET_PLAY_FRAMES:\r\nif (sst_drv_ctx->pci_id == SST_MRST_PCI_ID) {\r\nstruct stream_info *stream ;\r\nif (sst_validate_strid(str_id)) {\r\npr_err("strid %d invalid\n", str_id);\r\nbreak;\r\n}\r\nstream = &sst_drv_ctx->streams[str_id];\r\npr_debug("sst_play_frames for %d\n",\r\nmsg->header.part.str_id);\r\nmutex_lock(&sst_drv_ctx->streams[str_id].lock);\r\nsst_play_frame(msg->header.part.str_id);\r\nmutex_unlock(&sst_drv_ctx->streams[str_id].lock);\r\nbreak;\r\n} else\r\npr_err("sst_play_frames for Penwell!!\n");\r\ncase IPC_SST_GET_CAPT_FRAMES:\r\nif (sst_drv_ctx->pci_id == SST_MRST_PCI_ID) {\r\nstruct stream_info *stream;\r\nif (sst_validate_strid(str_id)) {\r\npr_err("str id %d invalid\n", str_id);\r\nbreak;\r\n}\r\nstream = &sst_drv_ctx->streams[str_id];\r\npr_debug("sst_capture_frames for %d\n",\r\nmsg->header.part.str_id);\r\nmutex_lock(&stream->lock);\r\nif (stream->mmapped == false &&\r\nstream->src == SST_DRV) {\r\npr_debug("waking up block for copy.\n");\r\nstream->data_blk.ret_code = 0;\r\nstream->data_blk.condition = true;\r\nstream->data_blk.on = false;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n} else\r\nsst_capture_frame(msg->header.part.str_id);\r\nmutex_unlock(&stream->lock);\r\n} else\r\npr_err("sst_play_frames for Penwell!!\n");\r\nbreak;\r\ncase IPC_IA_PRINT_STRING:\r\npr_debug("been asked to print something by fw\n");\r\nbreak;\r\ncase IPC_IA_FW_INIT_CMPLT: {\r\nprocess_fw_init(msg);\r\nbreak;\r\n}\r\ncase IPC_SST_STREAM_PROCESS_FATAL_ERR:\r\nif (sst_validate_strid(str_id)) {\r\npr_err("stream id %d invalid\n", str_id);\r\nbreak;\r\n}\r\npr_err("codec fatal error %x stream %d...\n",\r\nmsg->header.full, msg->header.part.str_id);\r\npr_err("Dropping the stream\n");\r\nsst_drop_stream(msg->header.part.str_id);\r\nbreak;\r\ncase IPC_IA_LPE_GETTING_STALLED:\r\nsst_drv_ctx->lpe_stalled = 1;\r\nbreak;\r\ncase IPC_IA_LPE_UNSTALLED:\r\nsst_drv_ctx->lpe_stalled = 0;\r\nbreak;\r\ndefault:\r\npr_err("Unhandled msg %x header %x\n",\r\nmsg->header.part.msg_id, msg->header.full);\r\n}\r\nsst_clear_interrupt();\r\nreturn;\r\n}\r\nvoid sst_process_reply(struct work_struct *work)\r\n{\r\nstruct sst_ipc_msg_wq *msg =\r\ncontainer_of(work, struct sst_ipc_msg_wq, wq);\r\nint str_id = msg->header.part.str_id;\r\nstruct stream_info *str_info;\r\nswitch (msg->header.part.msg_id) {\r\ncase IPC_IA_TARGET_DEV_SELECT:\r\nif (!msg->header.part.data) {\r\nsst_drv_ctx->tgt_dev_blk.ret_code = 0;\r\n} else {\r\npr_err(" Msg %x reply error %x\n",\r\nmsg->header.part.msg_id, msg->header.part.data);\r\nsst_drv_ctx->tgt_dev_blk.ret_code =\r\n-msg->header.part.data;\r\n}\r\nif (sst_drv_ctx->tgt_dev_blk.on == true) {\r\nsst_drv_ctx->tgt_dev_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_ALG_PARAMS: {\r\npr_debug("sst:IPC_ALG_PARAMS response %x\n", msg->header.full);\r\npr_debug("sst: data value %x\n", msg->header.part.data);\r\npr_debug("sst: large value %x\n", msg->header.part.large);\r\nif (!msg->header.part.large) {\r\nif (!msg->header.part.data) {\r\npr_debug("sst: alg set success\n");\r\nsst_drv_ctx->ppp_params_blk.ret_code = 0;\r\n} else {\r\npr_debug("sst: alg set failed\n");\r\nsst_drv_ctx->ppp_params_blk.ret_code =\r\n-msg->header.part.data;\r\n}\r\n} else if (msg->header.part.data) {\r\nstruct snd_ppp_params *mailbox_params, *get_params;\r\nchar *params;\r\npr_debug("sst: alg get success\n");\r\nmailbox_params = (struct snd_ppp_params *)msg->mailbox;\r\nget_params = kzalloc(sizeof(*get_params), GFP_KERNEL);\r\nif (get_params == NULL) {\r\npr_err("sst: out of memory for ALG PARAMS");\r\nbreak;\r\n}\r\nmemcpy_fromio(get_params, mailbox_params,\r\nsizeof(*get_params));\r\nget_params->params = kzalloc(mailbox_params->size,\r\nGFP_KERNEL);\r\nif (get_params->params == NULL) {\r\nkfree(get_params);\r\npr_err("sst: out of memory for ALG PARAMS block");\r\nbreak;\r\n}\r\nparams = msg->mailbox;\r\nparams = params + sizeof(*mailbox_params) - sizeof(u32);\r\nmemcpy_fromio(get_params->params, params,\r\nget_params->size);\r\nsst_drv_ctx->ppp_params_blk.ret_code = 0;\r\nsst_drv_ctx->ppp_params_blk.data = get_params;\r\n}\r\nif (sst_drv_ctx->ppp_params_blk.on == true) {\r\nsst_drv_ctx->ppp_params_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\n}\r\ncase IPC_IA_TUNING_PARAMS: {\r\npr_debug("sst:IPC_TUNING_PARAMS resp: %x\n", msg->header.full);\r\npr_debug("data value %x\n", msg->header.part.data);\r\nif (msg->header.part.large) {\r\npr_debug("alg set failed\n");\r\nsst_drv_ctx->ppp_params_blk.ret_code =\r\n-msg->header.part.data;\r\n} else {\r\npr_debug("alg set success\n");\r\nsst_drv_ctx->ppp_params_blk.ret_code = 0;\r\n}\r\nif (sst_drv_ctx->ppp_params_blk.on == true) {\r\nsst_drv_ctx->ppp_params_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\n}\r\ncase IPC_IA_GET_FW_INFO: {\r\nstruct snd_sst_fw_info *fw_info =\r\n(struct snd_sst_fw_info *)msg->mailbox;\r\nif (msg->header.part.large) {\r\nint major = fw_info->fw_version.major;\r\nint minor = fw_info->fw_version.minor;\r\nint build = fw_info->fw_version.build;\r\npr_debug("Msg succeeded %x\n",\r\nmsg->header.part.msg_id);\r\npr_debug("INFO: ***FW*** = %02d.%02d.%02d\n",\r\nmajor, minor, build);\r\nmemcpy_fromio(sst_drv_ctx->fw_info_blk.data,\r\n((struct snd_sst_fw_info *)(msg->mailbox)),\r\nsizeof(struct snd_sst_fw_info));\r\nsst_drv_ctx->fw_info_blk.ret_code = 0;\r\n} else {\r\npr_err(" Msg %x reply error %x\n",\r\nmsg->header.part.msg_id, msg->header.part.data);\r\nsst_drv_ctx->fw_info_blk.ret_code =\r\n-msg->header.part.data;\r\n}\r\nif (sst_drv_ctx->fw_info_blk.on == true) {\r\npr_debug("Memcopy succeeded\n");\r\nsst_drv_ctx->fw_info_blk.on = false;\r\nsst_drv_ctx->fw_info_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\n}\r\ncase IPC_IA_SET_STREAM_MUTE:\r\nif (!msg->header.part.data) {\r\npr_debug("Msg succeeded %x\n",\r\nmsg->header.part.msg_id);\r\nsst_drv_ctx->mute_info_blk.ret_code = 0;\r\n} else {\r\npr_err(" Msg %x reply error %x\n",\r\nmsg->header.part.msg_id, msg->header.part.data);\r\nsst_drv_ctx->mute_info_blk.ret_code =\r\n-msg->header.part.data;\r\n}\r\nif (sst_drv_ctx->mute_info_blk.on == true) {\r\nsst_drv_ctx->mute_info_blk.on = false;\r\nsst_drv_ctx->mute_info_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_SET_STREAM_VOL:\r\nif (!msg->header.part.data) {\r\npr_debug("Msg succeeded %x\n",\r\nmsg->header.part.msg_id);\r\nsst_drv_ctx->vol_info_blk.ret_code = 0;\r\n} else {\r\npr_err(" Msg %x reply error %x\n",\r\nmsg->header.part.msg_id,\r\nmsg->header.part.data);\r\nsst_drv_ctx->vol_info_blk.ret_code =\r\n-msg->header.part.data;\r\n}\r\nif (sst_drv_ctx->vol_info_blk.on == true) {\r\nsst_drv_ctx->vol_info_blk.on = false;\r\nsst_drv_ctx->vol_info_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_GET_STREAM_VOL:\r\nif (msg->header.part.large) {\r\npr_debug("Large Msg Received Successfully\n");\r\npr_debug("Msg succeeded %x\n",\r\nmsg->header.part.msg_id);\r\nmemcpy_fromio(sst_drv_ctx->vol_info_blk.data,\r\n(void *) msg->mailbox,\r\nsizeof(struct snd_sst_vol));\r\nsst_drv_ctx->vol_info_blk.ret_code = 0;\r\n} else {\r\npr_err("Msg %x reply error %x\n",\r\nmsg->header.part.msg_id, msg->header.part.data);\r\nsst_drv_ctx->vol_info_blk.ret_code =\r\n-msg->header.part.data;\r\n}\r\nif (sst_drv_ctx->vol_info_blk.on == true) {\r\nsst_drv_ctx->vol_info_blk.on = false;\r\nsst_drv_ctx->vol_info_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_GET_STREAM_PARAMS:\r\nif (sst_validate_strid(str_id)) {\r\npr_err("stream id %d invalid\n", str_id);\r\nbreak;\r\n}\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (msg->header.part.large) {\r\npr_debug("Get stream large success\n");\r\nmemcpy_fromio(str_info->ctrl_blk.data,\r\n((void *)(msg->mailbox)),\r\nsizeof(struct snd_sst_fw_get_stream_params));\r\nstr_info->ctrl_blk.ret_code = 0;\r\n} else {\r\npr_err("Msg %x reply error %x\n",\r\nmsg->header.part.msg_id, msg->header.part.data);\r\nstr_info->ctrl_blk.ret_code = -msg->header.part.data;\r\n}\r\nif (str_info->ctrl_blk.on == true) {\r\nstr_info->ctrl_blk.on = false;\r\nstr_info->ctrl_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_DECODE_FRAMES:\r\nif (sst_validate_strid(str_id)) {\r\npr_err("stream id %d invalid\n", str_id);\r\nbreak;\r\n}\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (msg->header.part.large) {\r\npr_debug("Msg succeeded %x\n",\r\nmsg->header.part.msg_id);\r\nmemcpy_fromio(str_info->data_blk.data,\r\n((void *)(msg->mailbox)),\r\nsizeof(struct snd_sst_decode_info));\r\nstr_info->data_blk.ret_code = 0;\r\n} else {\r\npr_err("Msg %x reply error %x\n",\r\nmsg->header.part.msg_id, msg->header.part.data);\r\nstr_info->data_blk.ret_code = -msg->header.part.data;\r\n}\r\nif (str_info->data_blk.on == true) {\r\nstr_info->data_blk.on = false;\r\nstr_info->data_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_DRAIN_STREAM:\r\nif (sst_validate_strid(str_id)) {\r\npr_err("stream id %d invalid\n", str_id);\r\nbreak;\r\n}\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (!msg->header.part.data) {\r\npr_debug("Msg succeeded %x\n",\r\nmsg->header.part.msg_id);\r\nstr_info->ctrl_blk.ret_code = 0;\r\n} else {\r\npr_err(" Msg %x reply error %x\n",\r\nmsg->header.part.msg_id, msg->header.part.data);\r\nstr_info->ctrl_blk.ret_code = -msg->header.part.data;\r\n}\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->data_blk.on == true) {\r\nstr_info->data_blk.on = false;\r\nstr_info->data_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_DROP_STREAM:\r\nif (sst_validate_strid(str_id)) {\r\npr_err("str id %d invalid\n", str_id);\r\nbreak;\r\n}\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (msg->header.part.large) {\r\nstruct snd_sst_drop_response *drop_resp =\r\n(struct snd_sst_drop_response *)msg->mailbox;\r\npr_debug("Drop ret bytes %x\n", drop_resp->bytes);\r\nstr_info->curr_bytes = drop_resp->bytes;\r\nstr_info->ctrl_blk.ret_code = 0;\r\n} else {\r\npr_err(" Msg %x reply error %x\n",\r\nmsg->header.part.msg_id, msg->header.part.data);\r\nstr_info->ctrl_blk.ret_code = -msg->header.part.data;\r\n}\r\nif (str_info->ctrl_blk.on == true) {\r\nstr_info->ctrl_blk.on = false;\r\nstr_info->ctrl_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_ENABLE_RX_TIME_SLOT:\r\nif (!msg->header.part.data) {\r\npr_debug("RX_TIME_SLOT success\n");\r\nsst_drv_ctx->hs_info_blk.ret_code = 0;\r\n} else {\r\npr_err(" Msg %x reply error %x\n",\r\nmsg->header.part.msg_id,\r\nmsg->header.part.data);\r\nsst_drv_ctx->hs_info_blk.ret_code =\r\n-msg->header.part.data;\r\n}\r\nif (sst_drv_ctx->hs_info_blk.on == true) {\r\nsst_drv_ctx->hs_info_blk.on = false;\r\nsst_drv_ctx->hs_info_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_PAUSE_STREAM:\r\ncase IPC_IA_RESUME_STREAM:\r\ncase IPC_IA_SET_STREAM_PARAMS:\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (!msg->header.part.data) {\r\npr_debug("Msg succeeded %x\n",\r\nmsg->header.part.msg_id);\r\nstr_info->ctrl_blk.ret_code = 0;\r\n} else {\r\npr_err(" Msg %x reply error %x\n",\r\nmsg->header.part.msg_id,\r\nmsg->header.part.data);\r\nstr_info->ctrl_blk.ret_code = -msg->header.part.data;\r\n}\r\nif (sst_validate_strid(str_id)) {\r\npr_err(" stream id %d invalid\n", str_id);\r\nbreak;\r\n}\r\nif (str_info->ctrl_blk.on == true) {\r\nstr_info->ctrl_blk.on = false;\r\nstr_info->ctrl_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_FREE_STREAM:\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (!msg->header.part.data) {\r\npr_debug("Stream %d freed\n", str_id);\r\n} else {\r\npr_err("Free for %d ret error %x\n",\r\nstr_id, msg->header.part.data);\r\n}\r\nif (str_info->ctrl_blk.on == true) {\r\nstr_info->ctrl_blk.on = false;\r\nstr_info->ctrl_blk.condition = true;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nbreak;\r\ncase IPC_IA_ALLOC_STREAM: {\r\nstruct snd_sst_alloc_response *resp =\r\n(struct snd_sst_alloc_response *)msg->mailbox;\r\nif (resp->str_type.result)\r\npr_err("error alloc stream = %x\n",\r\nresp->str_type.result);\r\nsst_alloc_stream_response(str_id, resp);\r\nbreak;\r\n}\r\ncase IPC_IA_PLAY_FRAMES:\r\ncase IPC_IA_CAPT_FRAMES:\r\nif (sst_validate_strid(str_id)) {\r\npr_err("stream id %d invalid\n", str_id);\r\nbreak;\r\n}\r\npr_debug("Ack for play/capt frames received\n");\r\nbreak;\r\ncase IPC_IA_PREP_LIB_DNLD: {\r\nstruct snd_sst_str_type *str_type =\r\n(struct snd_sst_str_type *)msg->mailbox;\r\npr_debug("Prep Lib download %x\n",\r\nmsg->header.part.msg_id);\r\nif (str_type->result)\r\npr_err("Prep lib download %x\n", str_type->result);\r\nelse\r\npr_debug("Can download codec now...\n");\r\nsst_wake_up_alloc_block(sst_drv_ctx, str_id,\r\nstr_type->result, NULL);\r\nbreak;\r\n}\r\ncase IPC_IA_LIB_DNLD_CMPLT: {\r\nstruct snd_sst_lib_download_info *resp =\r\n(struct snd_sst_lib_download_info *)msg->mailbox;\r\nint retval = resp->result;\r\npr_debug("Lib downloaded %x\n", msg->header.part.msg_id);\r\nif (resp->result) {\r\npr_err("err in lib dload %x\n", resp->result);\r\n} else {\r\npr_debug("Codec download complete...\n");\r\npr_debug("codec Type %d Ver %d Built %s: %s\n",\r\nresp->dload_lib.lib_info.lib_type,\r\nresp->dload_lib.lib_info.lib_version,\r\nresp->dload_lib.lib_info.b_date,\r\nresp->dload_lib.lib_info.b_time);\r\n}\r\nsst_wake_up_alloc_block(sst_drv_ctx, str_id,\r\nretval, NULL);\r\nbreak;\r\n}\r\ncase IPC_IA_GET_FW_VERSION: {\r\nstruct ipc_header_fw_init *version =\r\n(struct ipc_header_fw_init *)msg->mailbox;\r\nint major = version->fw_version.major;\r\nint minor = version->fw_version.minor;\r\nint build = version->fw_version.build;\r\ndev_info(&sst_drv_ctx->pci->dev,\r\n"INFO: ***LOADED SST FW VERSION*** = %02d.%02d.%02d\n",\r\nmajor, minor, build);\r\nbreak;\r\n}\r\ncase IPC_IA_GET_FW_BUILD_INF: {\r\nstruct sst_fw_build_info *build =\r\n(struct sst_fw_build_info *)msg->mailbox;\r\npr_debug("Build date:%sTime:%s", build->date, build->time);\r\nbreak;\r\n}\r\ncase IPC_IA_SET_PMIC_TYPE:\r\nbreak;\r\ncase IPC_IA_START_STREAM:\r\npr_debug("reply for START STREAM %x\n", msg->header.full);\r\nbreak;\r\ncase IPC_IA_GET_FW_CTXT:\r\npr_debug("reply for get fw ctxt %x\n", msg->header.full);\r\nif (msg->header.part.data)\r\nsst_drv_ctx->fw_cntx_size = 0;\r\nelse\r\nsst_drv_ctx->fw_cntx_size = *sst_drv_ctx->fw_cntx;\r\npr_debug("fw copied data %x\n", sst_drv_ctx->fw_cntx_size);\r\nsst_wake_up_alloc_block(\r\nsst_drv_ctx, str_id, msg->header.part.data, NULL);\r\nbreak;\r\ndefault:\r\npr_err("process reply:default = %x\n", msg->header.full);\r\n}\r\nsst_clear_interrupt();\r\nreturn;\r\n}
