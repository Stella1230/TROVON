static inline struct hvcs_struct *from_vio_dev(struct vio_dev *viod)\r\n{\r\nreturn dev_get_drvdata(&viod->dev);\r\n}\r\nstatic ssize_t hvcs_partner_vtys_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct vio_dev *viod = to_vio_dev(dev);\r\nstruct hvcs_struct *hvcsd = from_vio_dev(viod);\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nretval = sprintf(buf, "%X\n", hvcsd->p_unit_address);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic ssize_t hvcs_partner_clcs_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct vio_dev *viod = to_vio_dev(dev);\r\nstruct hvcs_struct *hvcsd = from_vio_dev(viod);\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nretval = sprintf(buf, "%s\n", &hvcsd->p_location_code[0]);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic ssize_t hvcs_current_vty_store(struct device *dev, struct device_attribute *attr, const char * buf,\r\nsize_t count)\r\n{\r\nprintk(KERN_INFO "HVCS: Denied current_vty change: -EPERM.\n");\r\nreturn -EPERM;\r\n}\r\nstatic ssize_t hvcs_current_vty_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct vio_dev *viod = to_vio_dev(dev);\r\nstruct hvcs_struct *hvcsd = from_vio_dev(viod);\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nretval = sprintf(buf, "%s\n", &hvcsd->p_location_code[0]);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic ssize_t hvcs_vterm_state_store(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct vio_dev *viod = to_vio_dev(dev);\r\nstruct hvcs_struct *hvcsd = from_vio_dev(viod);\r\nunsigned long flags;\r\nif (simple_strtol(buf, NULL, 0) != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nif (hvcsd->open_count > 0) {\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nprintk(KERN_INFO "HVCS: vterm state unchanged. "\r\n"The hvcs device node is still in use.\n");\r\nreturn -EPERM;\r\n}\r\nif (hvcsd->connected == 0) {\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nprintk(KERN_INFO "HVCS: vterm state unchanged. The"\r\n" vty-server is not connected to a vty.\n");\r\nreturn -EPERM;\r\n}\r\nhvcs_partner_free(hvcsd);\r\nprintk(KERN_INFO "HVCS: Closed vty-server@%X and"\r\n" partner vty@%X:%d connection.\n",\r\nhvcsd->vdev->unit_address,\r\nhvcsd->p_unit_address,\r\n(uint32_t)hvcsd->p_partition_ID);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t hvcs_vterm_state_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct vio_dev *viod = to_vio_dev(dev);\r\nstruct hvcs_struct *hvcsd = from_vio_dev(viod);\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nretval = sprintf(buf, "%d\n", hvcsd->connected);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic ssize_t hvcs_index_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct vio_dev *viod = to_vio_dev(dev);\r\nstruct hvcs_struct *hvcsd = from_vio_dev(viod);\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nretval = sprintf(buf, "%d\n", hvcsd->index);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn retval;\r\n}\r\nstatic ssize_t hvcs_rescan_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", hvcs_rescan_status);\r\n}\r\nstatic ssize_t hvcs_rescan_store(struct device_driver *ddp, const char * buf,\r\nsize_t count)\r\n{\r\nif ((simple_strtol(buf, NULL, 0) != 1)\r\n&& (hvcs_rescan_status != 0))\r\nreturn -EINVAL;\r\nhvcs_rescan_status = 1;\r\nprintk(KERN_INFO "HVCS: rescanning partner info for all"\r\n" vty-servers.\n");\r\nhvcs_rescan_devices_list();\r\nhvcs_rescan_status = 0;\r\nreturn count;\r\n}\r\nstatic void hvcs_kick(void)\r\n{\r\nhvcs_kicked = 1;\r\nwmb();\r\nwake_up_process(hvcs_task);\r\n}\r\nstatic void hvcs_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct hvcs_struct *hvcsd = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nhvcsd->todo_mask |= HVCS_SCHED_READ;\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nhvcs_kick();\r\n}\r\nstatic void hvcs_throttle(struct tty_struct *tty)\r\n{\r\nstruct hvcs_struct *hvcsd = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nvio_disable_interrupts(hvcsd->vdev);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\n}\r\nstatic irqreturn_t hvcs_handle_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct hvcs_struct *hvcsd = dev_instance;\r\nspin_lock(&hvcsd->lock);\r\nvio_disable_interrupts(hvcsd->vdev);\r\nhvcsd->todo_mask |= HVCS_SCHED_READ;\r\nspin_unlock(&hvcsd->lock);\r\nhvcs_kick();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void hvcs_try_write(struct hvcs_struct *hvcsd)\r\n{\r\nuint32_t unit_address = hvcsd->vdev->unit_address;\r\nstruct tty_struct *tty = hvcsd->tty;\r\nint sent;\r\nif (hvcsd->todo_mask & HVCS_TRY_WRITE) {\r\nsent = hvc_put_chars(unit_address,\r\n&hvcsd->buffer[0],\r\nhvcsd->chars_in_buffer );\r\nif (sent > 0) {\r\nhvcsd->chars_in_buffer = 0;\r\nhvcsd->todo_mask &= ~(HVCS_TRY_WRITE);\r\nif (tty) {\r\ntty_wakeup(tty);\r\n}\r\n}\r\n}\r\n}\r\nstatic int hvcs_io(struct hvcs_struct *hvcsd)\r\n{\r\nuint32_t unit_address;\r\nstruct tty_struct *tty;\r\nchar buf[HVCS_BUFF_LEN] __ALIGNED__;\r\nunsigned long flags;\r\nint got = 0;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nunit_address = hvcsd->vdev->unit_address;\r\ntty = hvcsd->tty;\r\nhvcs_try_write(hvcsd);\r\nif (!tty || test_bit(TTY_THROTTLED, &tty->flags)) {\r\nhvcsd->todo_mask &= ~(HVCS_READ_MASK);\r\ngoto bail;\r\n} else if (!(hvcsd->todo_mask & (HVCS_READ_MASK)))\r\ngoto bail;\r\nhvcsd->todo_mask &= ~(HVCS_READ_MASK);\r\nif (tty_buffer_request_room(tty, HVCS_BUFF_LEN) >= HVCS_BUFF_LEN) {\r\ngot = hvc_get_chars(unit_address,\r\n&buf[0],\r\nHVCS_BUFF_LEN);\r\ntty_insert_flip_string(tty, buf, got);\r\n}\r\nif (got)\r\nhvcsd->todo_mask |= HVCS_QUICK_READ;\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nif(got)\r\ntty_flip_buffer_push(tty);\r\nif (!got) {\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nvio_enable_interrupts(hvcsd->vdev);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\n}\r\nreturn hvcsd->todo_mask;\r\nbail:\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn hvcsd->todo_mask;\r\n}\r\nstatic int khvcsd(void *unused)\r\n{\r\nstruct hvcs_struct *hvcsd;\r\nint hvcs_todo_mask;\r\n__set_current_state(TASK_RUNNING);\r\ndo {\r\nhvcs_todo_mask = 0;\r\nhvcs_kicked = 0;\r\nwmb();\r\nspin_lock(&hvcs_structs_lock);\r\nlist_for_each_entry(hvcsd, &hvcs_structs, next) {\r\nhvcs_todo_mask |= hvcs_io(hvcsd);\r\n}\r\nspin_unlock(&hvcs_structs_lock);\r\nif (hvcs_todo_mask & (HVCS_TRY_WRITE | HVCS_QUICK_READ)) {\r\nyield();\r\ncontinue;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!hvcs_kicked)\r\nschedule();\r\n__set_current_state(TASK_RUNNING);\r\n} while (!kthread_should_stop());\r\nreturn 0;\r\n}\r\nstatic void hvcs_return_index(int index)\r\n{\r\nif (!hvcs_index_list)\r\nreturn;\r\nif (index < 0 || index >= hvcs_index_count)\r\nreturn;\r\nif (hvcs_index_list[index] == -1)\r\nreturn;\r\nelse\r\nhvcs_index_list[index] = -1;\r\n}\r\nstatic void destroy_hvcs_struct(struct kref *kref)\r\n{\r\nstruct hvcs_struct *hvcsd = from_kref(kref);\r\nstruct vio_dev *vdev;\r\nunsigned long flags;\r\nspin_lock(&hvcs_structs_lock);\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nlist_del(&(hvcsd->next));\r\nif (hvcsd->connected == 1) {\r\nhvcs_partner_free(hvcsd);\r\nprintk(KERN_INFO "HVCS: Closed vty-server@%X and"\r\n" partner vty@%X:%d connection.\n",\r\nhvcsd->vdev->unit_address,\r\nhvcsd->p_unit_address,\r\n(uint32_t)hvcsd->p_partition_ID);\r\n}\r\nprintk(KERN_INFO "HVCS: Destroyed hvcs_struct for vty-server@%X.\n",\r\nhvcsd->vdev->unit_address);\r\nvdev = hvcsd->vdev;\r\nhvcsd->vdev = NULL;\r\nhvcsd->p_unit_address = 0;\r\nhvcsd->p_partition_ID = 0;\r\nhvcs_return_index(hvcsd->index);\r\nmemset(&hvcsd->p_location_code[0], 0x00, HVCS_CLC_LENGTH + 1);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nspin_unlock(&hvcs_structs_lock);\r\nsysfs_remove_group(&vdev->dev.kobj, &hvcs_attr_group);\r\nkfree(hvcsd);\r\n}\r\nstatic int hvcs_get_index(void)\r\n{\r\nint i;\r\nif (!hvcs_index_list) {\r\nprintk(KERN_ERR "HVCS: hvcs_index_list NOT valid!.\n");\r\nreturn -EFAULT;\r\n}\r\nfor(i = 0; i < hvcs_index_count; i++) {\r\nif (hvcs_index_list[i] == -1) {\r\nhvcs_index_list[i] = 0;\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int __devinit hvcs_probe(\r\nstruct vio_dev *dev,\r\nconst struct vio_device_id *id)\r\n{\r\nstruct hvcs_struct *hvcsd;\r\nint index, rc;\r\nint retval;\r\nif (!dev || !id) {\r\nprintk(KERN_ERR "HVCS: probed with invalid parameter.\n");\r\nreturn -EPERM;\r\n}\r\nrc = hvcs_initialize();\r\nif (rc) {\r\npr_err("HVCS: Failed to initialize core driver.\n");\r\nreturn rc;\r\n}\r\nindex = hvcs_get_index();\r\nif (index < 0) {\r\nreturn -EFAULT;\r\n}\r\nhvcsd = kzalloc(sizeof(*hvcsd), GFP_KERNEL);\r\nif (!hvcsd)\r\nreturn -ENODEV;\r\nspin_lock_init(&hvcsd->lock);\r\nkref_init(&hvcsd->kref);\r\nhvcsd->vdev = dev;\r\ndev_set_drvdata(&dev->dev, hvcsd);\r\nhvcsd->index = index;\r\nhvcsd->chars_in_buffer = 0;\r\nhvcsd->todo_mask = 0;\r\nhvcsd->connected = 0;\r\nif (hvcs_get_pi(hvcsd)) {\r\nprintk(KERN_ERR "HVCS: Failed to fetch partner"\r\n" info for vty-server@%X on device probe.\n",\r\nhvcsd->vdev->unit_address);\r\n}\r\nspin_lock(&hvcs_structs_lock);\r\nlist_add_tail(&(hvcsd->next), &hvcs_structs);\r\nspin_unlock(&hvcs_structs_lock);\r\nretval = sysfs_create_group(&dev->dev.kobj, &hvcs_attr_group);\r\nif (retval) {\r\nprintk(KERN_ERR "HVCS: Can't create sysfs attrs for vty-server@%X\n",\r\nhvcsd->vdev->unit_address);\r\nreturn retval;\r\n}\r\nprintk(KERN_INFO "HVCS: vty-server@%X added to the vio bus.\n", dev->unit_address);\r\nreturn 0;\r\n}\r\nstatic int __devexit hvcs_remove(struct vio_dev *dev)\r\n{\r\nstruct hvcs_struct *hvcsd = dev_get_drvdata(&dev->dev);\r\nunsigned long flags;\r\nstruct tty_struct *tty;\r\nif (!hvcsd)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\ntty = hvcsd->tty;\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nkref_put(&hvcsd->kref, destroy_hvcs_struct);\r\nif (tty)\r\ntty_hangup(tty);\r\nprintk(KERN_INFO "HVCS: vty-server@%X removed from the"\r\n" vio bus.\n", dev->unit_address);\r\nreturn 0;\r\n}\r\nstatic void hvcs_set_pi(struct hvcs_partner_info *pi, struct hvcs_struct *hvcsd)\r\n{\r\nint clclength;\r\nhvcsd->p_unit_address = pi->unit_address;\r\nhvcsd->p_partition_ID = pi->partition_ID;\r\nclclength = strlen(&pi->location_code[0]);\r\nif (clclength > HVCS_CLC_LENGTH)\r\nclclength = HVCS_CLC_LENGTH;\r\nstrncpy(&hvcsd->p_location_code[0],\r\n&pi->location_code[0], clclength + 1);\r\n}\r\nstatic int hvcs_get_pi(struct hvcs_struct *hvcsd)\r\n{\r\nstruct hvcs_partner_info *pi;\r\nuint32_t unit_address = hvcsd->vdev->unit_address;\r\nstruct list_head head;\r\nint retval;\r\nspin_lock(&hvcs_pi_lock);\r\nif (!hvcs_pi_buff) {\r\nspin_unlock(&hvcs_pi_lock);\r\nreturn -EFAULT;\r\n}\r\nretval = hvcs_get_partner_info(unit_address, &head, hvcs_pi_buff);\r\nspin_unlock(&hvcs_pi_lock);\r\nif (retval) {\r\nprintk(KERN_ERR "HVCS: Failed to fetch partner"\r\n" info for vty-server@%x.\n", unit_address);\r\nreturn retval;\r\n}\r\nhvcsd->p_unit_address = 0;\r\nhvcsd->p_partition_ID = 0;\r\nlist_for_each_entry(pi, &head, node)\r\nhvcs_set_pi(pi, hvcsd);\r\nhvcs_free_partner_info(&head);\r\nreturn 0;\r\n}\r\nstatic int hvcs_rescan_devices_list(void)\r\n{\r\nstruct hvcs_struct *hvcsd;\r\nunsigned long flags;\r\nspin_lock(&hvcs_structs_lock);\r\nlist_for_each_entry(hvcsd, &hvcs_structs, next) {\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nhvcs_get_pi(hvcsd);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\n}\r\nspin_unlock(&hvcs_structs_lock);\r\nreturn 0;\r\n}\r\nstatic int hvcs_has_pi(struct hvcs_struct *hvcsd)\r\n{\r\nif ((!hvcsd->p_unit_address) || (!hvcsd->p_partition_ID))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int hvcs_partner_connect(struct hvcs_struct *hvcsd)\r\n{\r\nint retval;\r\nunsigned int unit_address = hvcsd->vdev->unit_address;\r\nretval = hvcs_register_connection(unit_address,\r\nhvcsd->p_partition_ID,\r\nhvcsd->p_unit_address);\r\nif (!retval) {\r\nhvcsd->connected = 1;\r\nreturn 0;\r\n} else if (retval != -EINVAL)\r\nreturn retval;\r\nif (hvcs_get_pi(hvcsd))\r\nreturn -ENOMEM;\r\nif (!hvcs_has_pi(hvcsd))\r\nreturn -ENODEV;\r\nretval = hvcs_register_connection(unit_address,\r\nhvcsd->p_partition_ID,\r\nhvcsd->p_unit_address);\r\nif (retval != -EINVAL) {\r\nhvcsd->connected = 1;\r\nreturn retval;\r\n}\r\nprintk(KERN_INFO "HVCS: vty-server or partner"\r\n" vty is busy. Try again later.\n");\r\nreturn -EBUSY;\r\n}\r\nstatic void hvcs_partner_free(struct hvcs_struct *hvcsd)\r\n{\r\nint retval;\r\ndo {\r\nretval = hvcs_free_connection(hvcsd->vdev->unit_address);\r\n} while (retval == -EBUSY);\r\nhvcsd->connected = 0;\r\n}\r\nstatic int hvcs_enable_device(struct hvcs_struct *hvcsd, uint32_t unit_address,\r\nunsigned int irq, struct vio_dev *vdev)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nif (!(rc = request_irq(irq, &hvcs_handle_interrupt,\r\nIRQF_DISABLED, "ibmhvcs", hvcsd))) {\r\nif (vio_enable_interrupts(vdev) == H_SUCCESS)\r\nreturn 0;\r\nelse {\r\nprintk(KERN_ERR "HVCS: int enable failed for"\r\n" vty-server@%X.\n", unit_address);\r\nfree_irq(irq, hvcsd);\r\n}\r\n} else\r\nprintk(KERN_ERR "HVCS: irq req failed for"\r\n" vty-server@%X.\n", unit_address);\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nhvcs_partner_free(hvcsd);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn rc;\r\n}\r\nstatic struct hvcs_struct *hvcs_get_by_index(int index)\r\n{\r\nstruct hvcs_struct *hvcsd = NULL;\r\nunsigned long flags;\r\nspin_lock(&hvcs_structs_lock);\r\nif (index >= 0 && index < HVCS_MAX_SERVER_ADAPTERS) {\r\nlist_for_each_entry(hvcsd, &hvcs_structs, next) {\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nif (hvcsd->index == index) {\r\nkref_get(&hvcsd->kref);\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nspin_unlock(&hvcs_structs_lock);\r\nreturn hvcsd;\r\n}\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\n}\r\nhvcsd = NULL;\r\n}\r\nspin_unlock(&hvcs_structs_lock);\r\nreturn hvcsd;\r\n}\r\nstatic int hvcs_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct hvcs_struct *hvcsd;\r\nint rc, retval = 0;\r\nunsigned long flags;\r\nunsigned int irq;\r\nstruct vio_dev *vdev;\r\nunsigned long unit_address;\r\nif (tty->driver_data)\r\ngoto fast_open;\r\nif (!(hvcsd = hvcs_get_by_index(tty->index))) {\r\nprintk(KERN_WARNING "HVCS: open failed, no device associated"\r\n" with tty->index %d.\n", tty->index);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nif (hvcsd->connected == 0)\r\nif ((retval = hvcs_partner_connect(hvcsd)))\r\ngoto error_release;\r\nhvcsd->open_count = 1;\r\nhvcsd->tty = tty;\r\ntty->driver_data = hvcsd;\r\nmemset(&hvcsd->buffer[0], 0x00, HVCS_BUFF_LEN);\r\nirq = hvcsd->vdev->irq;\r\nvdev = hvcsd->vdev;\r\nunit_address = hvcsd->vdev->unit_address;\r\nhvcsd->todo_mask |= HVCS_SCHED_READ;\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nif (((rc = hvcs_enable_device(hvcsd, unit_address, irq, vdev)))) {\r\nkref_put(&hvcsd->kref, destroy_hvcs_struct);\r\nprintk(KERN_WARNING "HVCS: enable device failed.\n");\r\nreturn rc;\r\n}\r\ngoto open_success;\r\nfast_open:\r\nhvcsd = tty->driver_data;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nkref_get(&hvcsd->kref);\r\nhvcsd->open_count++;\r\nhvcsd->todo_mask |= HVCS_SCHED_READ;\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nopen_success:\r\nhvcs_kick();\r\nprintk(KERN_INFO "HVCS: vty-server@%X connection opened.\n",\r\nhvcsd->vdev->unit_address );\r\nreturn 0;\r\nerror_release:\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nkref_put(&hvcsd->kref, destroy_hvcs_struct);\r\nprintk(KERN_WARNING "HVCS: partner connect failed.\n");\r\nreturn retval;\r\n}\r\nstatic void hvcs_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct hvcs_struct *hvcsd;\r\nunsigned long flags;\r\nint irq = NO_IRQ;\r\nif (tty_hung_up_p(filp))\r\nreturn;\r\nif (!tty->driver_data)\r\nreturn;\r\nhvcsd = tty->driver_data;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nif (--hvcsd->open_count == 0) {\r\nvio_disable_interrupts(hvcsd->vdev);\r\nhvcsd->tty = NULL;\r\nirq = hvcsd->vdev->irq;\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\ntty_wait_until_sent(tty, HVCS_CLOSE_WAIT);\r\ntty->driver_data = NULL;\r\nfree_irq(irq, hvcsd);\r\nkref_put(&hvcsd->kref, destroy_hvcs_struct);\r\nreturn;\r\n} else if (hvcsd->open_count < 0) {\r\nprintk(KERN_ERR "HVCS: vty-server@%X open_count: %d"\r\n" is missmanaged.\n",\r\nhvcsd->vdev->unit_address, hvcsd->open_count);\r\n}\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nkref_put(&hvcsd->kref, destroy_hvcs_struct);\r\n}\r\nstatic void hvcs_hangup(struct tty_struct * tty)\r\n{\r\nstruct hvcs_struct *hvcsd = tty->driver_data;\r\nunsigned long flags;\r\nint temp_open_count;\r\nint irq = NO_IRQ;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\ntemp_open_count = hvcsd->open_count;\r\nvio_disable_interrupts(hvcsd->vdev);\r\nhvcsd->todo_mask = 0;\r\nhvcsd->tty->driver_data = NULL;\r\nhvcsd->tty = NULL;\r\nhvcsd->open_count = 0;\r\nmemset(&hvcsd->buffer[0], 0x00, HVCS_BUFF_LEN);\r\nhvcsd->chars_in_buffer = 0;\r\nirq = hvcsd->vdev->irq;\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nfree_irq(irq, hvcsd);\r\nwhile(temp_open_count) {\r\n--temp_open_count;\r\nkref_put(&hvcsd->kref, destroy_hvcs_struct);\r\n}\r\n}\r\nstatic int hvcs_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct hvcs_struct *hvcsd = tty->driver_data;\r\nunsigned int unit_address;\r\nconst unsigned char *charbuf;\r\nunsigned long flags;\r\nint total_sent = 0;\r\nint tosend = 0;\r\nint result = 0;\r\nif (!hvcsd)\r\nreturn -ENODEV;\r\nif (count > HVCS_MAX_FROM_USER) {\r\nprintk(KERN_WARNING "HVCS write: count being truncated to"\r\n" HVCS_MAX_FROM_USER.\n");\r\ncount = HVCS_MAX_FROM_USER;\r\n}\r\ncharbuf = buf;\r\nspin_lock_irqsave(&hvcsd->lock, flags);\r\nif (hvcsd->open_count <= 0) {\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nreturn -ENODEV;\r\n}\r\nunit_address = hvcsd->vdev->unit_address;\r\nwhile (count > 0) {\r\ntosend = min(count, (HVCS_BUFF_LEN - hvcsd->chars_in_buffer));\r\nif (!tosend)\r\nbreak;\r\nmemcpy(&hvcsd->buffer[hvcsd->chars_in_buffer],\r\n&charbuf[total_sent],\r\ntosend);\r\nhvcsd->chars_in_buffer += tosend;\r\nresult = 0;\r\nif (!(hvcsd->todo_mask & HVCS_TRY_WRITE))\r\nresult = hvc_put_chars(unit_address,\r\n&hvcsd->buffer[0],\r\nhvcsd->chars_in_buffer);\r\ntotal_sent+=tosend;\r\ncount-=tosend;\r\nif (result == 0) {\r\nhvcsd->todo_mask |= HVCS_TRY_WRITE;\r\nhvcs_kick();\r\nbreak;\r\n}\r\nhvcsd->chars_in_buffer = 0;\r\nif (result < 0)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&hvcsd->lock, flags);\r\nif (result == -1)\r\nreturn -EIO;\r\nelse\r\nreturn total_sent;\r\n}\r\nstatic int hvcs_write_room(struct tty_struct *tty)\r\n{\r\nstruct hvcs_struct *hvcsd = tty->driver_data;\r\nif (!hvcsd || hvcsd->open_count <= 0)\r\nreturn 0;\r\nreturn HVCS_BUFF_LEN - hvcsd->chars_in_buffer;\r\n}\r\nstatic int hvcs_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct hvcs_struct *hvcsd = tty->driver_data;\r\nreturn hvcsd->chars_in_buffer;\r\n}\r\nstatic int hvcs_alloc_index_list(int n)\r\n{\r\nint i;\r\nhvcs_index_list = kmalloc(n * sizeof(hvcs_index_count),GFP_KERNEL);\r\nif (!hvcs_index_list)\r\nreturn -ENOMEM;\r\nhvcs_index_count = n;\r\nfor (i = 0; i < hvcs_index_count; i++)\r\nhvcs_index_list[i] = -1;\r\nreturn 0;\r\n}\r\nstatic void hvcs_free_index_list(void)\r\n{\r\nkfree(hvcs_index_list);\r\nhvcs_index_list = NULL;\r\nhvcs_index_count = 0;\r\n}\r\nstatic int __devinit hvcs_initialize(void)\r\n{\r\nint rc, num_ttys_to_alloc;\r\nmutex_lock(&hvcs_init_mutex);\r\nif (hvcs_task) {\r\nmutex_unlock(&hvcs_init_mutex);\r\nreturn 0;\r\n}\r\nif (hvcs_parm_num_devs <= 0 ||\r\n(hvcs_parm_num_devs > HVCS_MAX_SERVER_ADAPTERS)) {\r\nnum_ttys_to_alloc = HVCS_DEFAULT_SERVER_ADAPTERS;\r\n} else\r\nnum_ttys_to_alloc = hvcs_parm_num_devs;\r\nhvcs_tty_driver = alloc_tty_driver(num_ttys_to_alloc);\r\nif (!hvcs_tty_driver)\r\nreturn -ENOMEM;\r\nif (hvcs_alloc_index_list(num_ttys_to_alloc)) {\r\nrc = -ENOMEM;\r\ngoto index_fail;\r\n}\r\nhvcs_tty_driver->owner = THIS_MODULE;\r\nhvcs_tty_driver->driver_name = hvcs_driver_name;\r\nhvcs_tty_driver->name = hvcs_device_node;\r\nhvcs_tty_driver->minor_start = HVCS_MINOR_START;\r\nhvcs_tty_driver->type = TTY_DRIVER_TYPE_SYSTEM;\r\nhvcs_tty_driver->init_termios = hvcs_tty_termios;\r\nhvcs_tty_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(hvcs_tty_driver, &hvcs_ops);\r\nif (tty_register_driver(hvcs_tty_driver)) {\r\nprintk(KERN_ERR "HVCS: registration as a tty driver failed.\n");\r\nrc = -EIO;\r\ngoto register_fail;\r\n}\r\nhvcs_pi_buff = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!hvcs_pi_buff) {\r\nrc = -ENOMEM;\r\ngoto buff_alloc_fail;\r\n}\r\nhvcs_task = kthread_run(khvcsd, NULL, "khvcsd");\r\nif (IS_ERR(hvcs_task)) {\r\nprintk(KERN_ERR "HVCS: khvcsd creation failed.\n");\r\nrc = -EIO;\r\ngoto kthread_fail;\r\n}\r\nmutex_unlock(&hvcs_init_mutex);\r\nreturn 0;\r\nkthread_fail:\r\nkfree(hvcs_pi_buff);\r\nbuff_alloc_fail:\r\ntty_unregister_driver(hvcs_tty_driver);\r\nregister_fail:\r\nhvcs_free_index_list();\r\nindex_fail:\r\nput_tty_driver(hvcs_tty_driver);\r\nhvcs_tty_driver = NULL;\r\nmutex_unlock(&hvcs_init_mutex);\r\nreturn rc;\r\n}\r\nstatic int __init hvcs_module_init(void)\r\n{\r\nint rc = vio_register_driver(&hvcs_vio_driver);\r\nif (rc) {\r\nprintk(KERN_ERR "HVCS: can't register vio driver\n");\r\nreturn rc;\r\n}\r\npr_info("HVCS: Driver registered.\n");\r\nrc = driver_create_file(&(hvcs_vio_driver.driver), &driver_attr_rescan);\r\nif (rc)\r\npr_warning(KERN_ERR "HVCS: Failed to create rescan file (err %d)\n", rc);\r\nreturn 0;\r\n}\r\nstatic void __exit hvcs_module_exit(void)\r\n{\r\nvio_unregister_driver(&hvcs_vio_driver);\r\nif (!hvcs_task)\r\nreturn;\r\nkthread_stop(hvcs_task);\r\nspin_lock(&hvcs_pi_lock);\r\nkfree(hvcs_pi_buff);\r\nhvcs_pi_buff = NULL;\r\nspin_unlock(&hvcs_pi_lock);\r\ndriver_remove_file(&hvcs_vio_driver.driver, &driver_attr_rescan);\r\ntty_unregister_driver(hvcs_tty_driver);\r\nhvcs_free_index_list();\r\nput_tty_driver(hvcs_tty_driver);\r\nprintk(KERN_INFO "HVCS: driver module removed.\n");\r\n}
