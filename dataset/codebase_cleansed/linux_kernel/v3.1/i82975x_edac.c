static void i82975x_get_error_info(struct mem_ctl_info *mci,\r\nstruct i82975x_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->dev);\r\npci_read_config_word(pdev, I82975X_ERRSTS, &info->errsts);\r\npci_read_config_dword(pdev, I82975X_EAP, &info->eap);\r\npci_read_config_byte(pdev, I82975X_XEAP, &info->xeap);\r\npci_read_config_byte(pdev, I82975X_DES, &info->des);\r\npci_read_config_byte(pdev, I82975X_DERRSYN, &info->derrsyn);\r\npci_read_config_word(pdev, I82975X_ERRSTS, &info->errsts2);\r\npci_write_bits16(pdev, I82975X_ERRSTS, 0x0003, 0x0003);\r\nif (!(info->errsts2 & 0x0003))\r\nreturn;\r\nif ((info->errsts ^ info->errsts2) & 0x0003) {\r\npci_read_config_dword(pdev, I82975X_EAP, &info->eap);\r\npci_read_config_byte(pdev, I82975X_XEAP, &info->xeap);\r\npci_read_config_byte(pdev, I82975X_DES, &info->des);\r\npci_read_config_byte(pdev, I82975X_DERRSYN,\r\n&info->derrsyn);\r\n}\r\n}\r\nstatic int i82975x_process_error_info(struct mem_ctl_info *mci,\r\nstruct i82975x_error_info *info, int handle_errors)\r\n{\r\nint row, multi_chan, chan;\r\nunsigned long offst, page;\r\nmulti_chan = mci->csrows[0].nr_channels - 1;\r\nif (!(info->errsts2 & 0x0003))\r\nreturn 0;\r\nif (!handle_errors)\r\nreturn 1;\r\nif ((info->errsts ^ info->errsts2) & 0x0003) {\r\nedac_mc_handle_ce_no_info(mci, "UE overwrote CE");\r\ninfo->errsts = info->errsts2;\r\n}\r\npage = (unsigned long) info->eap;\r\nif (info->xeap & 1)\r\npage |= 0x100000000ul;\r\nchan = page & 1;\r\npage >>= 1;\r\noffst = page & ((1 << PAGE_SHIFT) - 1);\r\npage >>= PAGE_SHIFT;\r\nrow = edac_mc_find_csrow_by_page(mci, page);\r\nif (info->errsts & 0x0002)\r\nedac_mc_handle_ue(mci, page, offst , row, "i82975x UE");\r\nelse\r\nedac_mc_handle_ce(mci, page, offst, info->derrsyn, row,\r\nmulti_chan ? chan : 0,\r\n"i82975x CE");\r\nreturn 1;\r\n}\r\nstatic void i82975x_check(struct mem_ctl_info *mci)\r\n{\r\nstruct i82975x_error_info info;\r\ndebugf1("MC%d: %s()\n", mci->mc_idx, __func__);\r\ni82975x_get_error_info(mci, &info);\r\ni82975x_process_error_info(mci, &info, 1);\r\n}\r\nstatic int dual_channel_active(void __iomem *mch_window)\r\n{\r\nu8 drb[4][2];\r\nint row;\r\nint dualch;\r\nfor (dualch = 1, row = 0; dualch && (row < 4); row++) {\r\ndrb[row][0] = readb(mch_window + I82975X_DRB + row);\r\ndrb[row][1] = readb(mch_window + I82975X_DRB + row + 0x80);\r\ndualch = dualch && (drb[row][0] == drb[row][1]);\r\n}\r\nreturn dualch;\r\n}\r\nstatic enum dev_type i82975x_dram_type(void __iomem *mch_window, int rank)\r\n{\r\nreturn DEV_X8;\r\n}\r\nstatic void i82975x_init_csrows(struct mem_ctl_info *mci,\r\nstruct pci_dev *pdev, void __iomem *mch_window)\r\n{\r\nstatic const char *labels[4] = {\r\n"DIMM A1", "DIMM A2",\r\n"DIMM B1", "DIMM B2"\r\n};\r\nstruct csrow_info *csrow;\r\nunsigned long last_cumul_size;\r\nu8 value;\r\nu32 cumul_size;\r\nint index, chan;\r\nlast_cumul_size = 0;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\ncsrow = &mci->csrows[index];\r\nvalue = readb(mch_window + I82975X_DRB + index +\r\n((index >= 4) ? 0x80 : 0));\r\ncumul_size = value;\r\ncumul_size <<= (I82975X_DRB_SHIFT - PAGE_SHIFT);\r\nif (csrow->nr_channels > 1)\r\ncumul_size <<= 1;\r\ndebugf3("%s(): (%d) cumul_size 0x%x\n", __func__, index,\r\ncumul_size);\r\nfor (chan = 0; chan < csrow->nr_channels; chan++)\r\nstrncpy(csrow->channels[chan].label,\r\nlabels[(index >> 1) + (chan * 2)],\r\nEDAC_MC_LABEL_LEN);\r\nif (cumul_size == last_cumul_size)\r\ncontinue;\r\ncsrow->first_page = last_cumul_size;\r\ncsrow->last_page = cumul_size - 1;\r\ncsrow->nr_pages = cumul_size - last_cumul_size;\r\nlast_cumul_size = cumul_size;\r\ncsrow->grain = 1 << 6;\r\ncsrow->mtype = MEM_DDR2;\r\ncsrow->dtype = i82975x_dram_type(mch_window, index);\r\ncsrow->edac_mode = EDAC_SECDED;\r\n}\r\n}\r\nstatic void i82975x_print_dram_timings(void __iomem *mch_window)\r\n{\r\nstatic const int caslats[4] = { 5, 4, 3, 6 };\r\nu32 dtreg[2];\r\ndtreg[0] = readl(mch_window + 0x114);\r\ndtreg[1] = readl(mch_window + 0x194);\r\ni82975x_printk(KERN_INFO, "DRAM Timings : Ch0 Ch1\n"\r\n" RAS Active Min = %d %d\n"\r\n" CAS latency = %d %d\n"\r\n" RAS to CAS = %d %d\n"\r\n" RAS precharge = %d %d\n",\r\n(dtreg[0] >> 19 ) & 0x0f,\r\n(dtreg[1] >> 19) & 0x0f,\r\ncaslats[(dtreg[0] >> 8) & 0x03],\r\ncaslats[(dtreg[1] >> 8) & 0x03],\r\n((dtreg[0] >> 4) & 0x07) + 2,\r\n((dtreg[1] >> 4) & 0x07) + 2,\r\n(dtreg[0] & 0x07) + 2,\r\n(dtreg[1] & 0x07) + 2\r\n);\r\n}\r\nstatic int i82975x_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nint rc = -ENODEV;\r\nstruct mem_ctl_info *mci;\r\nstruct i82975x_pvt *pvt;\r\nvoid __iomem *mch_window;\r\nu32 mchbar;\r\nu32 drc[2];\r\nstruct i82975x_error_info discard;\r\nint chans;\r\n#ifdef i82975x_DEBUG_IOMEM\r\nu8 c0drb[4];\r\nu8 c1drb[4];\r\n#endif\r\ndebugf0("%s()\n", __func__);\r\npci_read_config_dword(pdev, I82975X_MCHBAR, &mchbar);\r\nif (!(mchbar & 1)) {\r\ndebugf3("%s(): failed, MCHBAR disabled!\n", __func__);\r\ngoto fail0;\r\n}\r\nmchbar &= 0xffffc000;\r\nmch_window = ioremap_nocache(mchbar, 0x1000);\r\n#ifdef i82975x_DEBUG_IOMEM\r\ni82975x_printk(KERN_INFO, "MCHBAR real = %0x, remapped = %p\n",\r\nmchbar, mch_window);\r\nc0drb[0] = readb(mch_window + I82975X_DRB_CH0R0);\r\nc0drb[1] = readb(mch_window + I82975X_DRB_CH0R1);\r\nc0drb[2] = readb(mch_window + I82975X_DRB_CH0R2);\r\nc0drb[3] = readb(mch_window + I82975X_DRB_CH0R3);\r\nc1drb[0] = readb(mch_window + I82975X_DRB_CH1R0);\r\nc1drb[1] = readb(mch_window + I82975X_DRB_CH1R1);\r\nc1drb[2] = readb(mch_window + I82975X_DRB_CH1R2);\r\nc1drb[3] = readb(mch_window + I82975X_DRB_CH1R3);\r\ni82975x_printk(KERN_INFO, "DRBCH0R0 = 0x%02x\n", c0drb[0]);\r\ni82975x_printk(KERN_INFO, "DRBCH0R1 = 0x%02x\n", c0drb[1]);\r\ni82975x_printk(KERN_INFO, "DRBCH0R2 = 0x%02x\n", c0drb[2]);\r\ni82975x_printk(KERN_INFO, "DRBCH0R3 = 0x%02x\n", c0drb[3]);\r\ni82975x_printk(KERN_INFO, "DRBCH1R0 = 0x%02x\n", c1drb[0]);\r\ni82975x_printk(KERN_INFO, "DRBCH1R1 = 0x%02x\n", c1drb[1]);\r\ni82975x_printk(KERN_INFO, "DRBCH1R2 = 0x%02x\n", c1drb[2]);\r\ni82975x_printk(KERN_INFO, "DRBCH1R3 = 0x%02x\n", c1drb[3]);\r\n#endif\r\ndrc[0] = readl(mch_window + I82975X_DRC_CH0M0);\r\ndrc[1] = readl(mch_window + I82975X_DRC_CH1M0);\r\n#ifdef i82975x_DEBUG_IOMEM\r\ni82975x_printk(KERN_INFO, "DRC_CH0 = %0x, %s\n", drc[0],\r\n((drc[0] >> 21) & 3) == 1 ?\r\n"ECC enabled" : "ECC disabled");\r\ni82975x_printk(KERN_INFO, "DRC_CH1 = %0x, %s\n", drc[1],\r\n((drc[1] >> 21) & 3) == 1 ?\r\n"ECC enabled" : "ECC disabled");\r\ni82975x_printk(KERN_INFO, "C0 BNKARC = %0x\n",\r\nreadw(mch_window + I82975X_C0BNKARC));\r\ni82975x_printk(KERN_INFO, "C1 BNKARC = %0x\n",\r\nreadw(mch_window + I82975X_C1BNKARC));\r\ni82975x_print_dram_timings(mch_window);\r\ngoto fail1;\r\n#endif\r\nif (!(((drc[0] >> 21) & 3) == 1 || ((drc[1] >> 21) & 3) == 1)) {\r\ni82975x_printk(KERN_INFO, "ECC disabled on both channels.\n");\r\ngoto fail1;\r\n}\r\nchans = dual_channel_active(mch_window) + 1;\r\nmci = edac_mc_alloc(sizeof(*pvt), I82975X_NR_CSROWS(chans),\r\nchans, 0);\r\nif (!mci) {\r\nrc = -ENOMEM;\r\ngoto fail1;\r\n}\r\ndebugf3("%s(): init mci\n", __func__);\r\nmci->dev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = I82975X_REVISION;\r\nmci->ctl_name = i82975x_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = i82975x_check;\r\nmci->ctl_page_to_phys = NULL;\r\ndebugf3("%s(): init pvt\n", __func__);\r\npvt = (struct i82975x_pvt *) mci->pvt_info;\r\npvt->mch_window = mch_window;\r\ni82975x_init_csrows(mci, pdev, mch_window);\r\nmci->scrub_mode = SCRUB_HW_SRC;\r\ni82975x_get_error_info(mci, &discard);\r\nif (edac_mc_add_mc(mci)) {\r\ndebugf3("%s(): failed edac_mc_add_mc()\n", __func__);\r\ngoto fail2;\r\n}\r\ndebugf3("%s(): success\n", __func__);\r\nreturn 0;\r\nfail2:\r\nedac_mc_free(mci);\r\nfail1:\r\niounmap(mch_window);\r\nfail0:\r\nreturn rc;\r\n}\r\nstatic int __devinit i82975x_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint rc;\r\ndebugf0("%s()\n", __func__);\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nrc = i82975x_probe1(pdev, ent->driver_data);\r\nif (mci_pdev == NULL)\r\nmci_pdev = pci_dev_get(pdev);\r\nreturn rc;\r\n}\r\nstatic void __devexit i82975x_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct i82975x_pvt *pvt;\r\ndebugf0("%s()\n", __func__);\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (mci == NULL)\r\nreturn;\r\npvt = mci->pvt_info;\r\nif (pvt->mch_window)\r\niounmap( pvt->mch_window );\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i82975x_init(void)\r\n{\r\nint pci_rc;\r\ndebugf3("%s()\n", __func__);\r\nopstate_init();\r\npci_rc = pci_register_driver(&i82975x_driver);\r\nif (pci_rc < 0)\r\ngoto fail0;\r\nif (mci_pdev == NULL) {\r\nmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82975_0, NULL);\r\nif (!mci_pdev) {\r\ndebugf0("i82975x pci_get_device fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\npci_rc = i82975x_init_one(mci_pdev, i82975x_pci_tbl);\r\nif (pci_rc < 0) {\r\ndebugf0("i82975x init fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\npci_unregister_driver(&i82975x_driver);\r\nfail0:\r\nif (mci_pdev != NULL)\r\npci_dev_put(mci_pdev);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit i82975x_exit(void)\r\n{\r\ndebugf3("%s()\n", __func__);\r\npci_unregister_driver(&i82975x_driver);\r\nif (!i82975x_registered) {\r\ni82975x_remove_one(mci_pdev);\r\npci_dev_put(mci_pdev);\r\n}\r\n}
