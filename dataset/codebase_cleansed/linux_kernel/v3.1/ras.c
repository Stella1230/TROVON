static int __init init_ras_IRQ(void)\r\n{\r\nstruct device_node *np;\r\nras_get_sensor_state_token = rtas_token("get-sensor-state");\r\nras_check_exception_token = rtas_token("check-exception");\r\nnp = of_find_node_by_path("/event-sources/internal-errors");\r\nif (np != NULL) {\r\nrequest_event_sources_irqs(np, ras_error_interrupt,\r\n"RAS_ERROR");\r\nof_node_put(np);\r\n}\r\nnp = of_find_node_by_path("/event-sources/epow-events");\r\nif (np != NULL) {\r\nrequest_event_sources_irqs(np, ras_epow_interrupt, "RAS_EPOW");\r\nof_node_put(np);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ras_epow_interrupt(int irq, void *dev_id)\r\n{\r\nint status = 0xdeadbeef;\r\nint state = 0;\r\nint critical;\r\nstatus = rtas_call(ras_get_sensor_state_token, 2, 2, &state,\r\nEPOW_SENSOR_TOKEN, EPOW_SENSOR_INDEX);\r\nif (state > 3)\r\ncritical = 1;\r\nelse\r\ncritical = 0;\r\nspin_lock(&ras_log_buf_lock);\r\nstatus = rtas_call(ras_check_exception_token, 6, 1, NULL,\r\nRTAS_VECTOR_EXTERNAL_INTERRUPT,\r\nvirq_to_hw(irq),\r\nRTAS_EPOW_WARNING | RTAS_POWERMGM_EVENTS,\r\ncritical, __pa(&ras_log_buf),\r\nrtas_get_error_log_max());\r\nudbg_printf("EPOW <0x%lx 0x%x 0x%x>\n",\r\n*((unsigned long *)&ras_log_buf), status, state);\r\nprintk(KERN_WARNING "EPOW <0x%lx 0x%x 0x%x>\n",\r\n*((unsigned long *)&ras_log_buf), status, state);\r\nlog_error(ras_log_buf, ERR_TYPE_RTAS_LOG, 0);\r\nspin_unlock(&ras_log_buf_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ras_error_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rtas_error_log *rtas_elog;\r\nint status = 0xdeadbeef;\r\nint fatal;\r\nspin_lock(&ras_log_buf_lock);\r\nstatus = rtas_call(ras_check_exception_token, 6, 1, NULL,\r\nRTAS_VECTOR_EXTERNAL_INTERRUPT,\r\nvirq_to_hw(irq),\r\nRTAS_INTERNAL_ERROR, 1 ,\r\n__pa(&ras_log_buf),\r\nrtas_get_error_log_max());\r\nrtas_elog = (struct rtas_error_log *)ras_log_buf;\r\nif ((status == 0) && (rtas_elog->severity >= RTAS_SEVERITY_ERROR_SYNC))\r\nfatal = 1;\r\nelse\r\nfatal = 0;\r\nlog_error(ras_log_buf, ERR_TYPE_RTAS_LOG, fatal);\r\nif (fatal) {\r\nudbg_printf("Fatal HW Error <0x%lx 0x%x>\n",\r\n*((unsigned long *)&ras_log_buf), status);\r\nprintk(KERN_EMERG "Error: Fatal hardware error <0x%lx 0x%x>\n",\r\n*((unsigned long *)&ras_log_buf), status);\r\n#ifndef DEBUG_RTAS_POWER_OFF\r\nppc_md.power_off();\r\n#endif\r\n} else {\r\nudbg_printf("Recoverable HW Error <0x%lx 0x%x>\n",\r\n*((unsigned long *)&ras_log_buf), status);\r\nprintk(KERN_WARNING\r\n"Warning: Recoverable hardware error <0x%lx 0x%x>\n",\r\n*((unsigned long *)&ras_log_buf), status);\r\n}\r\nspin_unlock(&ras_log_buf_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct rtas_error_log *fwnmi_get_errinfo(struct pt_regs *regs)\r\n{\r\nunsigned long *savep;\r\nstruct rtas_error_log *h, *errhdr = NULL;\r\nif (!VALID_FWNMI_BUFFER(regs->gpr[3])) {\r\nprintk(KERN_ERR "FWNMI: corrupt r3 0x%016lx\n", regs->gpr[3]);\r\nreturn NULL;\r\n}\r\nsavep = __va(regs->gpr[3]);\r\nregs->gpr[3] = savep[0];\r\nh = (struct rtas_error_log *)&savep[1];\r\nif (!h->extended) {\r\nmemcpy(&__get_cpu_var(mce_data_buf), h, sizeof(__u64));\r\nerrhdr = (struct rtas_error_log *)&__get_cpu_var(mce_data_buf);\r\n} else {\r\nint len;\r\nlen = max_t(int, 8+h->extended_log_length, RTAS_ERROR_LOG_MAX);\r\nmemset(global_mce_data_buf, 0, RTAS_ERROR_LOG_MAX);\r\nmemcpy(global_mce_data_buf, h, len);\r\nerrhdr = (struct rtas_error_log *)global_mce_data_buf;\r\n}\r\nreturn errhdr;\r\n}\r\nstatic void fwnmi_release_errinfo(void)\r\n{\r\nint ret = rtas_call(rtas_token("ibm,nmi-interlock"), 0, 1, NULL);\r\nif (ret != 0)\r\nprintk(KERN_ERR "FWNMI: nmi-interlock failed: %d\n", ret);\r\n}\r\nint pSeries_system_reset_exception(struct pt_regs *regs)\r\n{\r\nif (fwnmi_active) {\r\nstruct rtas_error_log *errhdr = fwnmi_get_errinfo(regs);\r\nif (errhdr) {\r\n}\r\nfwnmi_release_errinfo();\r\n}\r\nreturn 0;\r\n}\r\nstatic int recover_mce(struct pt_regs *regs, struct rtas_error_log *err)\r\n{\r\nint recovered = 0;\r\nif (!(regs->msr & MSR_RI)) {\r\nrecovered = 0;\r\n} else if (err->disposition == RTAS_DISP_FULLY_RECOVERED) {\r\nrecovered = 1;\r\n} else if (err->disposition == RTAS_DISP_LIMITED_RECOVERY) {\r\nprintk(KERN_ERR "MCE: limited recovery, system may "\r\n"be degraded\n");\r\nrecovered = 1;\r\n} else if (user_mode(regs) && !is_global_init(current) &&\r\nerr->severity == RTAS_SEVERITY_ERROR_SYNC) {\r\nprintk(KERN_ERR "MCE: uncorrectable error, killing task "\r\n"%s:%d\n", current->comm, current->pid);\r\n_exception(SIGBUS, regs, BUS_MCEERR_AR, regs->nip);\r\nrecovered = 1;\r\n}\r\nlog_error((char *)err, ERR_TYPE_RTAS_LOG, 0);\r\nreturn recovered;\r\n}\r\nint pSeries_machine_check_exception(struct pt_regs *regs)\r\n{\r\nstruct rtas_error_log *errp;\r\nif (fwnmi_active) {\r\nerrp = fwnmi_get_errinfo(regs);\r\nfwnmi_release_errinfo();\r\nif (errp && recover_mce(regs, errp))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
