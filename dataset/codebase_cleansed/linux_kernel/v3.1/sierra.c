static int sierra_set_power_state(struct usb_device *udev, __u16 swiState)\r\n{\r\nint result;\r\ndev_dbg(&udev->dev, "%s\n", __func__);\r\nresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nSWIMS_USB_REQUEST_SetPower,\r\nUSB_TYPE_VENDOR,\r\nswiState,\r\n0,\r\nNULL,\r\n0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nreturn result;\r\n}\r\nstatic int sierra_vsc_set_nmea(struct usb_device *udev, __u16 enable)\r\n{\r\nint result;\r\ndev_dbg(&udev->dev, "%s\n", __func__);\r\nresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nSWIMS_USB_REQUEST_SetNmea,\r\nUSB_TYPE_VENDOR,\r\nenable,\r\n0x0000,\r\nNULL,\r\n0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nreturn result;\r\n}\r\nstatic int sierra_calc_num_ports(struct usb_serial *serial)\r\n{\r\nint num_ports = 0;\r\nu8 ifnum, numendpoints;\r\ndev_dbg(&serial->dev->dev, "%s\n", __func__);\r\nifnum = serial->interface->cur_altsetting->desc.bInterfaceNumber;\r\nnumendpoints = serial->interface->cur_altsetting->desc.bNumEndpoints;\r\nif (ifnum == 0x99)\r\nnum_ports = 0;\r\nelse if (numendpoints <= 3)\r\nnum_ports = 1;\r\nelse\r\nnum_ports = (numendpoints-1)/2;\r\nreturn num_ports;\r\n}\r\nstatic int is_blacklisted(const u8 ifnum,\r\nconst struct sierra_iface_info *blacklist)\r\n{\r\nconst u8 *info;\r\nint i;\r\nif (blacklist) {\r\ninfo = blacklist->ifaceinfo;\r\nfor (i = 0; i < blacklist->infolen; i++) {\r\nif (info[i] == ifnum)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_himemory(const u8 ifnum,\r\nconst struct sierra_iface_info *himemorylist)\r\n{\r\nconst u8 *info;\r\nint i;\r\nif (himemorylist) {\r\ninfo = himemorylist->ifaceinfo;\r\nfor (i=0; i < himemorylist->infolen; i++) {\r\nif (info[i] == ifnum)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sierra_calc_interface(struct usb_serial *serial)\r\n{\r\nint interface;\r\nstruct usb_interface *p_interface;\r\nstruct usb_host_interface *p_host_interface;\r\ndev_dbg(&serial->dev->dev, "%s\n", __func__);\r\np_interface = serial->interface;\r\np_host_interface = p_interface->cur_altsetting;\r\ninterface = p_host_interface->desc.bInterfaceNumber;\r\nreturn interface;\r\n}\r\nstatic int sierra_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nint result = 0;\r\nstruct usb_device *udev;\r\nstruct sierra_intf_private *data;\r\nu8 ifnum;\r\nudev = serial->dev;\r\ndev_dbg(&udev->dev, "%s\n", __func__);\r\nifnum = sierra_calc_interface(serial);\r\nif (serial->interface->num_altsetting == 2) {\r\ndev_dbg(&udev->dev, "Selecting alt setting for interface %d\n",\r\nifnum);\r\nusb_set_interface(udev, ifnum, 1);\r\n}\r\nifnum = sierra_calc_interface(serial);\r\nif (is_blacklisted(ifnum,\r\n(struct sierra_iface_info *)id->driver_info)) {\r\ndev_dbg(&serial->dev->dev,\r\n"Ignoring blacklisted interface #%d\n", ifnum);\r\nreturn -ENODEV;\r\n}\r\ndata = serial->private = kzalloc(sizeof(struct sierra_intf_private), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock_init(&data->susp_lock);\r\nreturn result;\r\n}\r\nstatic int sierra_send_setup(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct sierra_port_private *portdata;\r\n__u16 interface = 0;\r\nint val = 0;\r\nint do_send = 0;\r\nint retval;\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nportdata = usb_get_serial_port_data(port);\r\nif (portdata->dtr_state)\r\nval |= 0x01;\r\nif (portdata->rts_state)\r\nval |= 0x02;\r\nif (serial->num_ports == 1) {\r\ninterface = sierra_calc_interface(serial);\r\nif (port->interrupt_in_urb) {\r\ndo_send = 1;\r\n}\r\n}\r\nelse {\r\nif (port->bulk_out_endpointAddress == 2)\r\ninterface = 0;\r\nelse if (port->bulk_out_endpointAddress == 4)\r\ninterface = 1;\r\nelse if (port->bulk_out_endpointAddress == 5)\r\ninterface = 2;\r\ndo_send = 1;\r\n}\r\nif (!do_send)\r\nreturn 0;\r\nretval = usb_autopm_get_interface(serial->interface);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\n0x22, 0x21, val, interface, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\nusb_autopm_put_interface(serial->interface);\r\nreturn retval;\r\n}\r\nstatic void sierra_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\ntty_termios_copy_hw(tty->termios, old_termios);\r\nsierra_send_setup(port);\r\n}\r\nstatic int sierra_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned int value;\r\nstruct sierra_port_private *portdata;\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nportdata = usb_get_serial_port_data(port);\r\nvalue = ((portdata->rts_state) ? TIOCM_RTS : 0) |\r\n((portdata->dtr_state) ? TIOCM_DTR : 0) |\r\n((portdata->cts_state) ? TIOCM_CTS : 0) |\r\n((portdata->dsr_state) ? TIOCM_DSR : 0) |\r\n((portdata->dcd_state) ? TIOCM_CAR : 0) |\r\n((portdata->ri_state) ? TIOCM_RNG : 0);\r\nreturn value;\r\n}\r\nstatic int sierra_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct sierra_port_private *portdata;\r\nportdata = usb_get_serial_port_data(port);\r\nif (set & TIOCM_RTS)\r\nportdata->rts_state = 1;\r\nif (set & TIOCM_DTR)\r\nportdata->dtr_state = 1;\r\nif (clear & TIOCM_RTS)\r\nportdata->rts_state = 0;\r\nif (clear & TIOCM_DTR)\r\nportdata->dtr_state = 0;\r\nreturn sierra_send_setup(port);\r\n}\r\nstatic void sierra_release_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port;\r\nif (urb) {\r\nport = urb->context;\r\ndev_dbg(&port->dev, "%s: %p\n", __func__, urb);\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nstatic void sierra_outdat_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\r\nstruct sierra_intf_private *intfdata;\r\nint status = urb->status;\r\ndev_dbg(&port->dev, "%s - port %d\n", __func__, port->number);\r\nintfdata = port->serial->private;\r\nkfree(urb->transfer_buffer);\r\nusb_autopm_put_interface_async(port->serial->interface);\r\nif (status)\r\ndev_dbg(&port->dev, "%s - nonzero write bulk status "\r\n"received: %d\n", __func__, status);\r\nspin_lock(&portdata->lock);\r\n--portdata->outstanding_urbs;\r\nspin_unlock(&portdata->lock);\r\nspin_lock(&intfdata->susp_lock);\r\n--intfdata->in_flight;\r\nspin_unlock(&intfdata->susp_lock);\r\nusb_serial_port_softint(port);\r\n}\r\nstatic int sierra_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct sierra_port_private *portdata;\r\nstruct sierra_intf_private *intfdata;\r\nstruct usb_serial *serial = port->serial;\r\nunsigned long flags;\r\nunsigned char *buffer;\r\nstruct urb *urb;\r\nsize_t writesize = min((size_t)count, (size_t)MAX_TRANSFER);\r\nint retval = 0;\r\nif (count == 0)\r\nreturn 0;\r\nportdata = usb_get_serial_port_data(port);\r\nintfdata = serial->private;\r\ndev_dbg(&port->dev, "%s: write (%zd bytes)\n", __func__, writesize);\r\nspin_lock_irqsave(&portdata->lock, flags);\r\ndev_dbg(&port->dev, "%s - outstanding_urbs: %d\n", __func__,\r\nportdata->outstanding_urbs);\r\nif (portdata->outstanding_urbs > portdata->num_out_urbs) {\r\nspin_unlock_irqrestore(&portdata->lock, flags);\r\ndev_dbg(&port->dev, "%s - write limit hit\n", __func__);\r\nreturn 0;\r\n}\r\nportdata->outstanding_urbs++;\r\ndev_dbg(&port->dev, "%s - 1, outstanding_urbs: %d\n", __func__,\r\nportdata->outstanding_urbs);\r\nspin_unlock_irqrestore(&portdata->lock, flags);\r\nretval = usb_autopm_get_interface_async(serial->interface);\r\nif (retval < 0) {\r\nspin_lock_irqsave(&portdata->lock, flags);\r\nportdata->outstanding_urbs--;\r\nspin_unlock_irqrestore(&portdata->lock, flags);\r\ngoto error_simple;\r\n}\r\nbuffer = kmalloc(writesize, GFP_ATOMIC);\r\nif (!buffer) {\r\ndev_err(&port->dev, "out of memory\n");\r\nretval = -ENOMEM;\r\ngoto error_no_buffer;\r\n}\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\ndev_err(&port->dev, "no more free urbs\n");\r\nretval = -ENOMEM;\r\ngoto error_no_urb;\r\n}\r\nmemcpy(buffer, buf, writesize);\r\nusb_serial_debug_data(debug, &port->dev, __func__, writesize, buffer);\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->bulk_out_endpointAddress),\r\nbuffer, writesize, sierra_outdat_callback, port);\r\nurb->transfer_flags |= URB_ZERO_PACKET;\r\nspin_lock_irqsave(&intfdata->susp_lock, flags);\r\nif (intfdata->suspended) {\r\nusb_anchor_urb(urb, &portdata->delayed);\r\nspin_unlock_irqrestore(&intfdata->susp_lock, flags);\r\ngoto skip_power;\r\n} else {\r\nusb_anchor_urb(urb, &portdata->active);\r\n}\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval) {\r\nusb_unanchor_urb(urb);\r\nspin_unlock_irqrestore(&intfdata->susp_lock, flags);\r\ndev_err(&port->dev, "%s - usb_submit_urb(write bulk) failed "\r\n"with status = %d\n", __func__, retval);\r\ngoto error;\r\n} else {\r\nintfdata->in_flight++;\r\nspin_unlock_irqrestore(&intfdata->susp_lock, flags);\r\n}\r\nskip_power:\r\nusb_free_urb(urb);\r\nreturn writesize;\r\nerror:\r\nusb_free_urb(urb);\r\nerror_no_urb:\r\nkfree(buffer);\r\nerror_no_buffer:\r\nspin_lock_irqsave(&portdata->lock, flags);\r\n--portdata->outstanding_urbs;\r\ndev_dbg(&port->dev, "%s - 2. outstanding_urbs: %d\n", __func__,\r\nportdata->outstanding_urbs);\r\nspin_unlock_irqrestore(&portdata->lock, flags);\r\nusb_autopm_put_interface_async(serial->interface);\r\nerror_simple:\r\nreturn retval;\r\n}\r\nstatic void sierra_indat_callback(struct urb *urb)\r\n{\r\nint err;\r\nint endpoint;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint status = urb->status;\r\nendpoint = usb_pipeendpoint(urb->pipe);\r\nport = urb->context;\r\ndev_dbg(&port->dev, "%s: %p\n", __func__, urb);\r\nif (status) {\r\ndev_dbg(&port->dev, "%s: nonzero status: %d on"\r\n" endpoint %02x\n", __func__, status, endpoint);\r\n} else {\r\nif (urb->actual_length) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\ntty_insert_flip_string(tty, data,\r\nurb->actual_length);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\nusb_serial_debug_data(debug, &port->dev,\r\n__func__, urb->actual_length, data);\r\n}\r\n} else {\r\ndev_dbg(&port->dev, "%s: empty read urb"\r\n" received\n", __func__);\r\n}\r\n}\r\nif (status != -ESHUTDOWN && status != -EPERM) {\r\nusb_mark_last_busy(port->serial->dev);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err && err != -EPERM)\r\ndev_err(&port->dev, "resubmit read urb failed."\r\n"(%d)\n", err);\r\n}\r\n}\r\nstatic void sierra_instat_callback(struct urb *urb)\r\n{\r\nint err;\r\nint status = urb->status;\r\nstruct usb_serial_port *port = urb->context;\r\nstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial = port->serial;\r\ndev_dbg(&port->dev, "%s: urb %p port %p has data %p\n", __func__,\r\nurb, port, portdata);\r\nif (status == 0) {\r\nstruct usb_ctrlrequest *req_pkt =\r\n(struct usb_ctrlrequest *)urb->transfer_buffer;\r\nif (!req_pkt) {\r\ndev_dbg(&port->dev, "%s: NULL req_pkt\n",\r\n__func__);\r\nreturn;\r\n}\r\nif ((req_pkt->bRequestType == 0xA1) &&\r\n(req_pkt->bRequest == 0x20)) {\r\nint old_dcd_state;\r\nunsigned char signals = *((unsigned char *)\r\nurb->transfer_buffer +\r\nsizeof(struct usb_ctrlrequest));\r\nstruct tty_struct *tty;\r\ndev_dbg(&port->dev, "%s: signal x%x\n", __func__,\r\nsignals);\r\nold_dcd_state = portdata->dcd_state;\r\nportdata->cts_state = 1;\r\nportdata->dcd_state = ((signals & 0x01) ? 1 : 0);\r\nportdata->dsr_state = ((signals & 0x02) ? 1 : 0);\r\nportdata->ri_state = ((signals & 0x08) ? 1 : 0);\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && !C_CLOCAL(tty) &&\r\nold_dcd_state && !portdata->dcd_state)\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n} else {\r\ndev_dbg(&port->dev, "%s: type %x req %x\n",\r\n__func__, req_pkt->bRequestType,\r\nreq_pkt->bRequest);\r\n}\r\n} else\r\ndev_dbg(&port->dev, "%s: error %d\n", __func__, status);\r\nif (status != -ESHUTDOWN && status != -ENOENT) {\r\nusb_mark_last_busy(serial->dev);\r\nurb->dev = serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err && err != -EPERM)\r\ndev_err(&port->dev, "%s: resubmit intr urb "\r\n"failed. (%d)\n", __func__, err);\r\n}\r\n}\r\nstatic int sierra_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\ndev_dbg(&port->dev, "%s - port %d\n", __func__, port->number);\r\nspin_lock_irqsave(&portdata->lock, flags);\r\nif (portdata->outstanding_urbs > (portdata->num_out_urbs * 2) / 3) {\r\nspin_unlock_irqrestore(&portdata->lock, flags);\r\ndev_dbg(&port->dev, "%s - write limit hit\n", __func__);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&portdata->lock, flags);\r\nreturn 2048;\r\n}\r\nstatic void sierra_stop_rx_urbs(struct usb_serial_port *port)\r\n{\r\nint i;\r\nstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\r\nfor (i = 0; i < portdata->num_in_urbs; i++)\r\nusb_kill_urb(portdata->in_urbs[i]);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic int sierra_submit_rx_urbs(struct usb_serial_port *port, gfp_t mem_flags)\r\n{\r\nint ok_cnt;\r\nint err = -EINVAL;\r\nint i;\r\nstruct urb *urb;\r\nstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\r\nok_cnt = 0;\r\nfor (i = 0; i < portdata->num_in_urbs; i++) {\r\nurb = portdata->in_urbs[i];\r\nif (!urb)\r\ncontinue;\r\nerr = usb_submit_urb(urb, mem_flags);\r\nif (err) {\r\ndev_err(&port->dev, "%s: submit urb failed: %d\n",\r\n__func__, err);\r\n} else {\r\nok_cnt++;\r\n}\r\n}\r\nif (ok_cnt && port->interrupt_in_urb) {\r\nerr = usb_submit_urb(port->interrupt_in_urb, mem_flags);\r\nif (err) {\r\ndev_err(&port->dev, "%s: submit intr urb failed: %d\n",\r\n__func__, err);\r\n}\r\n}\r\nif (ok_cnt > 0)\r\nreturn 0;\r\nelse\r\nreturn err;\r\n}\r\nstatic struct urb *sierra_setup_urb(struct usb_serial *serial, int endpoint,\r\nint dir, void *ctx, int len,\r\ngfp_t mem_flags,\r\nusb_complete_t callback)\r\n{\r\nstruct urb *urb;\r\nu8 *buf;\r\nif (endpoint == -1)\r\nreturn NULL;\r\nurb = usb_alloc_urb(0, mem_flags);\r\nif (urb == NULL) {\r\ndev_dbg(&serial->dev->dev, "%s: alloc for endpoint %d failed\n",\r\n__func__, endpoint);\r\nreturn NULL;\r\n}\r\nbuf = kmalloc(len, mem_flags);\r\nif (buf) {\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev, endpoint) | dir,\r\nbuf, len, callback, ctx);\r\ndev_dbg(&serial->dev->dev, "%s %c u : %p d:%p\n", __func__,\r\ndir == USB_DIR_IN ? 'i' : 'o', urb, buf);\r\n} else {\r\ndev_dbg(&serial->dev->dev, "%s %c u:%p d:%p\n", __func__,\r\ndir == USB_DIR_IN ? 'i' : 'o', urb, buf);\r\nsierra_release_urb(urb);\r\nurb = NULL;\r\n}\r\nreturn urb;\r\n}\r\nstatic void sierra_close(struct usb_serial_port *port)\r\n{\r\nint i;\r\nstruct usb_serial *serial = port->serial;\r\nstruct sierra_port_private *portdata;\r\nstruct sierra_intf_private *intfdata = port->serial->private;\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nportdata = usb_get_serial_port_data(port);\r\nportdata->rts_state = 0;\r\nportdata->dtr_state = 0;\r\nif (serial->dev) {\r\nmutex_lock(&serial->disc_mutex);\r\nif (!serial->disconnected) {\r\nserial->interface->needs_remote_wakeup = 0;\r\nif (!usb_autopm_get_interface(serial->interface))\r\nsierra_send_setup(port);\r\nelse\r\nusb_autopm_get_interface_no_resume(serial->interface);\r\n}\r\nmutex_unlock(&serial->disc_mutex);\r\nspin_lock_irq(&intfdata->susp_lock);\r\nportdata->opened = 0;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nsierra_stop_rx_urbs(port);\r\nfor (i = 0; i < portdata->num_in_urbs; i++) {\r\nsierra_release_urb(portdata->in_urbs[i]);\r\nportdata->in_urbs[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int sierra_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct sierra_port_private *portdata;\r\nstruct usb_serial *serial = port->serial;\r\nstruct sierra_intf_private *intfdata = serial->private;\r\nint i;\r\nint err;\r\nint endpoint;\r\nstruct urb *urb;\r\nportdata = usb_get_serial_port_data(port);\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nportdata->rts_state = 1;\r\nportdata->dtr_state = 1;\r\nendpoint = port->bulk_in_endpointAddress;\r\nfor (i = 0; i < portdata->num_in_urbs; i++) {\r\nurb = sierra_setup_urb(serial, endpoint, USB_DIR_IN, port,\r\nIN_BUFLEN, GFP_KERNEL,\r\nsierra_indat_callback);\r\nportdata->in_urbs[i] = urb;\r\n}\r\nusb_clear_halt(serial->dev,\r\nusb_sndbulkpipe(serial->dev, endpoint) | USB_DIR_IN);\r\nerr = sierra_submit_rx_urbs(port, GFP_KERNEL);\r\nif (err) {\r\nsierra_close(port);\r\nif (!serial->disconnected)\r\nusb_autopm_put_interface(serial->interface);\r\nreturn err;\r\n}\r\nsierra_send_setup(port);\r\nserial->interface->needs_remote_wakeup = 1;\r\nspin_lock_irq(&intfdata->susp_lock);\r\nportdata->opened = 1;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nusb_autopm_put_interface(serial->interface);\r\nreturn 0;\r\n}\r\nstatic void sierra_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct sierra_port_private *portdata;\r\nportdata = usb_get_serial_port_data(port);\r\nportdata->rts_state = on;\r\nportdata->dtr_state = on;\r\nif (serial->dev) {\r\nmutex_lock(&serial->disc_mutex);\r\nif (!serial->disconnected)\r\nsierra_send_setup(port);\r\nmutex_unlock(&serial->disc_mutex);\r\n}\r\n}\r\nstatic int sierra_startup(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct sierra_port_private *portdata;\r\nstruct sierra_iface_info *himemoryp = NULL;\r\nint i;\r\nu8 ifnum;\r\ndev_dbg(&serial->dev->dev, "%s\n", __func__);\r\nsierra_set_power_state(serial->dev, 0x0000);\r\nif (nmea)\r\nsierra_vsc_set_nmea(serial->dev, 1);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nportdata = kzalloc(sizeof(*portdata), GFP_KERNEL);\r\nif (!portdata) {\r\ndev_dbg(&port->dev, "%s: kmalloc for "\r\n"sierra_port_private (%d) failed!\n",\r\n__func__, i);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&portdata->lock);\r\ninit_usb_anchor(&portdata->active);\r\ninit_usb_anchor(&portdata->delayed);\r\nifnum = i;\r\nportdata->num_out_urbs = N_OUT_URB;\r\nportdata->num_in_urbs = N_IN_URB;\r\nif (serial->num_ports == 1) {\r\nifnum = sierra_calc_interface(serial);\r\nhimemoryp =\r\n(struct sierra_iface_info *)&typeB_interface_list;\r\nif (is_himemory(ifnum, himemoryp)) {\r\nportdata->num_out_urbs = N_OUT_URB_HM;\r\nportdata->num_in_urbs = N_IN_URB_HM;\r\n}\r\n}\r\nelse {\r\nhimemoryp =\r\n(struct sierra_iface_info *)&typeA_interface_list;\r\nif (is_himemory(i, himemoryp)) {\r\nportdata->num_out_urbs = N_OUT_URB_HM;\r\nportdata->num_in_urbs = N_IN_URB_HM;\r\n}\r\n}\r\ndev_dbg(&serial->dev->dev,\r\n"Memory usage (urbs) interface #%d, in=%d, out=%d\n",\r\nifnum,portdata->num_in_urbs, portdata->num_out_urbs );\r\nusb_set_serial_port_data(port, portdata);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sierra_release(struct usb_serial *serial)\r\n{\r\nint i;\r\nstruct usb_serial_port *port;\r\nstruct sierra_port_private *portdata;\r\ndev_dbg(&serial->dev->dev, "%s\n", __func__);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\nif (!port)\r\ncontinue;\r\nportdata = usb_get_serial_port_data(port);\r\nif (!portdata)\r\ncontinue;\r\nkfree(portdata);\r\n}\r\n}\r\nstatic void stop_read_write_urbs(struct usb_serial *serial)\r\n{\r\nint i;\r\nstruct usb_serial_port *port;\r\nstruct sierra_port_private *portdata;\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\nportdata = usb_get_serial_port_data(port);\r\nsierra_stop_rx_urbs(port);\r\nusb_kill_anchored_urbs(&portdata->active);\r\n}\r\n}\r\nstatic int sierra_suspend(struct usb_serial *serial, pm_message_t message)\r\n{\r\nstruct sierra_intf_private *intfdata;\r\nint b;\r\nif (message.event & PM_EVENT_AUTO) {\r\nintfdata = serial->private;\r\nspin_lock_irq(&intfdata->susp_lock);\r\nb = intfdata->in_flight;\r\nif (b) {\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nreturn -EBUSY;\r\n} else {\r\nintfdata->suspended = 1;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\n}\r\n}\r\nstop_read_write_urbs(serial);\r\nreturn 0;\r\n}\r\nstatic int sierra_resume(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct sierra_intf_private *intfdata = serial->private;\r\nstruct sierra_port_private *portdata;\r\nstruct urb *urb;\r\nint ec = 0;\r\nint i, err;\r\nspin_lock_irq(&intfdata->susp_lock);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nportdata = usb_get_serial_port_data(port);\r\nwhile ((urb = usb_get_from_anchor(&portdata->delayed))) {\r\nusb_anchor_urb(urb, &portdata->active);\r\nintfdata->in_flight++;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nintfdata->in_flight--;\r\nusb_unanchor_urb(urb);\r\nusb_scuttle_anchored_urbs(&portdata->delayed);\r\nbreak;\r\n}\r\n}\r\nif (portdata->opened) {\r\nerr = sierra_submit_rx_urbs(port, GFP_ATOMIC);\r\nif (err)\r\nec++;\r\n}\r\n}\r\nintfdata->suspended = 0;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nreturn ec ? -EIO : 0;\r\n}\r\nstatic int sierra_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_serial *serial = usb_get_intfdata(intf);\r\ndev_err(&serial->dev->dev, "%s\n", __func__);\r\nreturn usb_serial_resume(intf);\r\n}\r\nstatic int __init sierra_init(void)\r\n{\r\nint retval;\r\nretval = usb_serial_register(&sierra_device);\r\nif (retval)\r\ngoto failed_device_register;\r\nretval = usb_register(&sierra_driver);\r\nif (retval)\r\ngoto failed_driver_register;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nreturn 0;\r\nfailed_driver_register:\r\nusb_serial_deregister(&sierra_device);\r\nfailed_device_register:\r\nreturn retval;\r\n}\r\nstatic void __exit sierra_exit(void)\r\n{\r\nusb_deregister(&sierra_driver);\r\nusb_serial_deregister(&sierra_device);\r\n}
