static int __cpuinit cmp_range(const void *x1, const void *x2)\r\n{\r\nconst struct range *r1 = x1;\r\nconst struct range *r2 = x2;\r\nint start1, start2;\r\nstart1 = r1->start >> 32;\r\nstart2 = r2->start >> 32;\r\nreturn start1 - start2;\r\n}\r\nstatic void __cpuinit get_fam10h_pci_mmconf_base(void)\r\n{\r\nint i;\r\nunsigned bus;\r\nunsigned slot;\r\nint found;\r\nu64 val;\r\nu32 address;\r\nu64 tom2;\r\nu64 base = FAM10H_PCI_MMCONF_BASE;\r\nint hi_mmio_num;\r\nstruct range range[8];\r\nif (fam10h_pci_mmconf_base)\r\nreturn;\r\nif (!early_pci_allowed())\r\nreturn;\r\nfound = 0;\r\nfor (i = 0; i < ARRAY_SIZE(pci_probes); i++) {\r\nu32 id;\r\nu16 device;\r\nu16 vendor;\r\nbus = pci_probes[i].bus;\r\nslot = pci_probes[i].slot;\r\nid = read_pci_config(bus, slot, 0, PCI_VENDOR_ID);\r\nvendor = id & 0xffff;\r\ndevice = (id>>16) & 0xffff;\r\nif (pci_probes[i].vendor == vendor &&\r\npci_probes[i].device == device) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn;\r\naddress = MSR_K8_SYSCFG;\r\nrdmsrl(address, val);\r\nif (!(val & (1<<21))) {\r\ntom2 = 1ULL << 32;\r\n} else {\r\naddress = MSR_K8_TOP_MEM2;\r\nrdmsrl(address, val);\r\ntom2 = max(val & 0xffffff800000ULL, 1ULL << 32);\r\n}\r\nif (base <= tom2)\r\nbase = (tom2 + 2 * MMCONF_UNIT - 1) & MMCONF_MASK;\r\nhi_mmio_num = 0;\r\nfor (i = 0; i < 8; i++) {\r\nu32 reg;\r\nu64 start;\r\nu64 end;\r\nreg = read_pci_config(bus, slot, 1, 0x80 + (i << 3));\r\nif (!(reg & 3))\r\ncontinue;\r\nstart = (u64)(reg & 0xffffff00) << 8;\r\nreg = read_pci_config(bus, slot, 1, 0x84 + (i << 3));\r\nend = ((u64)(reg & 0xffffff00) << 8) | 0xffff;\r\nif (end < tom2)\r\ncontinue;\r\nrange[hi_mmio_num].start = start;\r\nrange[hi_mmio_num].end = end;\r\nhi_mmio_num++;\r\n}\r\nif (!hi_mmio_num)\r\ngoto out;\r\nsort(range, hi_mmio_num, sizeof(struct range), cmp_range, NULL);\r\nif (range[hi_mmio_num - 1].end < base)\r\ngoto out;\r\nif (range[0].start > base + MMCONF_SIZE)\r\ngoto out;\r\nbase = (range[0].start & MMCONF_MASK) - MMCONF_UNIT;\r\nif ((base > tom2) && BASE_VALID(base))\r\ngoto out;\r\nbase = (range[hi_mmio_num - 1].end + MMCONF_UNIT) & MMCONF_MASK;\r\nif (BASE_VALID(base))\r\ngoto out;\r\nfor (i = 1; i < hi_mmio_num; i++) {\r\nbase = (range[i - 1].end + MMCONF_UNIT) & MMCONF_MASK;\r\nval = range[i].start & MMCONF_MASK;\r\nif (val >= base + MMCONF_SIZE && BASE_VALID(base))\r\ngoto out;\r\n}\r\nreturn;\r\nout:\r\nfam10h_pci_mmconf_base = base;\r\n}\r\nvoid __cpuinit fam10h_check_enable_mmcfg(void)\r\n{\r\nu64 val;\r\nu32 address;\r\nif (!(pci_probe & PCI_CHECK_ENABLE_AMD_MMCONF))\r\nreturn;\r\naddress = MSR_FAM10H_MMIO_CONF_BASE;\r\nrdmsrl(address, val);\r\nif (val & FAM10H_MMIO_CONF_ENABLE) {\r\nunsigned busnbits;\r\nbusnbits = (val >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) &\r\nFAM10H_MMIO_CONF_BUSRANGE_MASK;\r\nif (!acpi_pci_disabled || busnbits >= 8) {\r\nu64 base = val & MMCONF_MASK;\r\nif (!fam10h_pci_mmconf_base) {\r\nfam10h_pci_mmconf_base = base;\r\nreturn;\r\n} else if (fam10h_pci_mmconf_base == base)\r\nreturn;\r\n}\r\n}\r\nget_fam10h_pci_mmconf_base();\r\nif (!fam10h_pci_mmconf_base) {\r\npci_probe &= ~PCI_CHECK_ENABLE_AMD_MMCONF;\r\nreturn;\r\n}\r\nprintk(KERN_INFO "Enable MMCONFIG on AMD Family 10h\n");\r\nval &= ~((FAM10H_MMIO_CONF_BASE_MASK<<FAM10H_MMIO_CONF_BASE_SHIFT) |\r\n(FAM10H_MMIO_CONF_BUSRANGE_MASK<<FAM10H_MMIO_CONF_BUSRANGE_SHIFT));\r\nval |= fam10h_pci_mmconf_base | (8 << FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\r\nFAM10H_MMIO_CONF_ENABLE;\r\nwrmsrl(address, val);\r\n}\r\nstatic int __init set_check_enable_amd_mmconf(const struct dmi_system_id *d)\r\n{\r\npci_probe |= PCI_CHECK_ENABLE_AMD_MMCONF;\r\nreturn 0;\r\n}\r\nvoid __ref check_enable_amd_mmconf_dmi(void)\r\n{\r\ndmi_check_system(mmconf_dmi_table);\r\n}
