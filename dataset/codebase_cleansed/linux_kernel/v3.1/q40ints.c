static int q40_irq_startup(unsigned int irq)\r\n{\r\nswitch (irq) {\r\ncase 1: case 2: case 8: case 9:\r\ncase 11: case 12: case 13:\r\nprintk("%s: ISA IRQ %d not implemented by HW\n", __func__, irq);\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void q40_irq_shutdown(unsigned int irq)\r\n{\r\n}\r\nvoid __init q40_init_IRQ(void)\r\n{\r\nm68k_setup_irq_controller(&q40_irq_controller, 1, Q40_IRQ_MAX);\r\nm68k_setup_auto_interrupt(q40_irq_handler);\r\nm68k_irq_startup(IRQ_AUTO_2);\r\nm68k_irq_startup(IRQ_AUTO_4);\r\nmaster_outb(1, EXT_ENABLE_REG);\r\nmaster_outb(0, KEY_IRQ_ENABLE_REG);\r\n}\r\nvoid q40_mksound(unsigned int hz, unsigned int ticks)\r\n{\r\nif (hz == 0) {\r\nif (sound_ticks)\r\nsound_ticks = 1;\r\n*DAC_LEFT = 128;\r\n*DAC_RIGHT = 128;\r\nreturn;\r\n}\r\nif (sound_ticks == 0)\r\nsound_ticks = 1000;\r\nsound_ticks = ticks << 1;\r\n}\r\nstatic irqreturn_t q40_timer_int (int irq, void * dev)\r\n{\r\nql_ticks = ql_ticks ? 0 : 1;\r\nif (sound_ticks) {\r\nunsigned char sval=(sound_ticks & 1) ? 128-SVOL : 128+SVOL;\r\nsound_ticks--;\r\n*DAC_LEFT=sval;\r\n*DAC_RIGHT=sval;\r\n}\r\nif (!ql_ticks)\r\nq40_timer_routine(irq, dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid q40_sched_init (irq_handler_t timer_routine)\r\n{\r\nint timer_irq;\r\nq40_timer_routine = timer_routine;\r\ntimer_irq = Q40_IRQ_FRAME;\r\nif (request_irq(timer_irq, q40_timer_int, 0,\r\n"timer", q40_timer_int))\r\npanic("Couldn't register timer int");\r\nmaster_outb(-1, FRAME_CLEAR_REG);\r\nmaster_outb( 1, FRAME_RATE_REG);\r\n}\r\nstatic void q40_irq_handler(unsigned int irq, struct pt_regs *fp)\r\n{\r\nunsigned mir, mer;\r\nint i;\r\nmir = master_inb(IIRQ_REG);\r\n#ifdef CONFIG_BLK_DEV_FD\r\nif ((mir & Q40_IRQ_EXT_MASK) &&\r\n(master_inb(EIRQ_REG) & Q40_IRQ6_MASK)) {\r\nfloppy_hardint();\r\nreturn;\r\n}\r\n#endif\r\nswitch (irq) {\r\ncase 4:\r\ncase 6:\r\n__m68k_handle_int(Q40_IRQ_SAMPLE, fp);\r\nreturn;\r\n}\r\nif (mir & Q40_IRQ_FRAME_MASK) {\r\n__m68k_handle_int(Q40_IRQ_FRAME, fp);\r\nmaster_outb(-1, FRAME_CLEAR_REG);\r\n}\r\nif ((mir & Q40_IRQ_SER_MASK) || (mir & Q40_IRQ_EXT_MASK)) {\r\nmer = master_inb(EIRQ_REG);\r\nfor (i = 0; eirqs[i].mask; i++) {\r\nif (mer & eirqs[i].mask) {\r\nirq = eirqs[i].irq;\r\nif (irq > 4 && irq <= 15 && mext_disabled) {\r\ngoto iirq;\r\n}\r\nif (q40_state[irq] & IRQ_INPROGRESS) {\r\n#ifdef IP_USE_DISABLE\r\ndisable_irq(irq);\r\ndisabled = 1;\r\n#else\r\nfp->sr = (((fp->sr) & (~0x700))+0x200);\r\ndisabled = 1;\r\n#endif\r\ngoto iirq;\r\n}\r\nq40_state[irq] |= IRQ_INPROGRESS;\r\n__m68k_handle_int(irq, fp);\r\nq40_state[irq] &= ~IRQ_INPROGRESS;\r\nif (disabled) {\r\n#ifdef IP_USE_DISABLE\r\nif (irq > 4) {\r\ndisabled = 0;\r\nenable_irq(irq);\r\n}\r\n#else\r\ndisabled = 0;\r\n#endif\r\n}\r\nreturn;\r\n}\r\n}\r\nif (mer && ccleirq > 0 && !aliased_irq) {\r\nprintk("ISA interrupt from unknown source? EIRQ_REG = %x\n",mer);\r\nccleirq--;\r\n}\r\n}\r\niirq:\r\nmir = master_inb(IIRQ_REG);\r\nif (mir & Q40_IRQ_KEYB_MASK)\r\n__m68k_handle_int(Q40_IRQ_KEYBOARD, fp);\r\nreturn;\r\n}\r\nvoid q40_enable_irq(unsigned int irq)\r\n{\r\nif (irq >= 5 && irq <= 15) {\r\nmext_disabled--;\r\nif (mext_disabled > 0)\r\nprintk("q40_enable_irq : nested disable/enable\n");\r\nif (mext_disabled == 0)\r\nmaster_outb(1, EXT_ENABLE_REG);\r\n}\r\n}\r\nvoid q40_disable_irq(unsigned int irq)\r\n{\r\nif (irq >= 5 && irq <= 15) {\r\nmaster_outb(0, EXT_ENABLE_REG);\r\nmext_disabled++;\r\nif (mext_disabled > 1)\r\nprintk("disable_irq nesting count %d\n",mext_disabled);\r\n}\r\n}\r\nunsigned long q40_probe_irq_on(void)\r\n{\r\nprintk("irq probing not working - reconfigure the driver to avoid this\n");\r\nreturn -1;\r\n}\r\nint q40_probe_irq_off(unsigned long irqs)\r\n{\r\nreturn -1;\r\n}
