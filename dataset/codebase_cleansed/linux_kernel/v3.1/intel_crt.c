static struct intel_crt *intel_attached_crt(struct drm_connector *connector)\r\n{\r\nreturn container_of(intel_attached_encoder(connector),\r\nstruct intel_crt, base);\r\n}\r\nstatic void intel_crt_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 temp, reg;\r\nif (HAS_PCH_SPLIT(dev))\r\nreg = PCH_ADPA;\r\nelse\r\nreg = ADPA;\r\ntemp = I915_READ(reg);\r\ntemp &= ~(ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE);\r\ntemp &= ~ADPA_DAC_ENABLE;\r\nswitch(mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ntemp |= ADPA_DAC_ENABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ntemp |= ADPA_DAC_ENABLE | ADPA_HSYNC_CNTL_DISABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ntemp |= ADPA_DAC_ENABLE | ADPA_VSYNC_CNTL_DISABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\ntemp |= ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE;\r\nbreak;\r\n}\r\nI915_WRITE(reg, temp);\r\n}\r\nstatic int intel_crt_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nint max_clock = 0;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (mode->clock < 25000)\r\nreturn MODE_CLOCK_LOW;\r\nif (IS_GEN2(dev))\r\nmax_clock = 350000;\r\nelse\r\nmax_clock = 400000;\r\nif (mode->clock > max_clock)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic bool intel_crt_mode_fixup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void intel_crt_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(crtc);\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nint dpll_md_reg;\r\nu32 adpa, dpll_md;\r\nu32 adpa_reg;\r\ndpll_md_reg = DPLL_MD(intel_crtc->pipe);\r\nif (HAS_PCH_SPLIT(dev))\r\nadpa_reg = PCH_ADPA;\r\nelse\r\nadpa_reg = ADPA;\r\nif (INTEL_INFO(dev)->gen >= 4 && !HAS_PCH_SPLIT(dev)) {\r\ndpll_md = I915_READ(dpll_md_reg);\r\nI915_WRITE(dpll_md_reg,\r\ndpll_md & ~DPLL_MD_UDI_MULTIPLIER_MASK);\r\n}\r\nadpa = ADPA_HOTPLUG_BITS;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nadpa |= ADPA_HSYNC_ACTIVE_HIGH;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nadpa |= ADPA_VSYNC_ACTIVE_HIGH;\r\nif (intel_crtc->pipe == 0) {\r\nif (HAS_PCH_CPT(dev))\r\nadpa |= PORT_TRANS_A_SEL_CPT;\r\nelse\r\nadpa |= ADPA_PIPE_A_SELECT;\r\n} else {\r\nif (HAS_PCH_CPT(dev))\r\nadpa |= PORT_TRANS_B_SEL_CPT;\r\nelse\r\nadpa |= ADPA_PIPE_B_SELECT;\r\n}\r\nif (!HAS_PCH_SPLIT(dev))\r\nI915_WRITE(BCLRPAT(intel_crtc->pipe), 0);\r\nI915_WRITE(adpa_reg, adpa);\r\n}\r\nstatic bool intel_ironlake_crt_detect_hotplug(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 adpa;\r\nbool ret;\r\nif (crt->force_hotplug_required) {\r\nbool turn_off_dac = HAS_PCH_SPLIT(dev);\r\nu32 save_adpa;\r\ncrt->force_hotplug_required = 0;\r\nsave_adpa = adpa = I915_READ(PCH_ADPA);\r\nDRM_DEBUG_KMS("trigger hotplug detect cycle: adpa=0x%x\n", adpa);\r\nadpa |= ADPA_CRT_HOTPLUG_FORCE_TRIGGER;\r\nif (turn_off_dac)\r\nadpa &= ~ADPA_DAC_ENABLE;\r\nI915_WRITE(PCH_ADPA, adpa);\r\nif (wait_for((I915_READ(PCH_ADPA) & ADPA_CRT_HOTPLUG_FORCE_TRIGGER) == 0,\r\n1000))\r\nDRM_DEBUG_KMS("timed out waiting for FORCE_TRIGGER");\r\nif (turn_off_dac) {\r\nI915_WRITE(PCH_ADPA, save_adpa);\r\nPOSTING_READ(PCH_ADPA);\r\n}\r\n}\r\nadpa = I915_READ(PCH_ADPA);\r\nif ((adpa & ADPA_CRT_HOTPLUG_MONITOR_MASK) != 0)\r\nret = true;\r\nelse\r\nret = false;\r\nDRM_DEBUG_KMS("ironlake hotplug adpa=0x%x, result %d\n", adpa, ret);\r\nreturn ret;\r\n}\r\nstatic bool intel_crt_detect_hotplug(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 hotplug_en, orig, stat;\r\nbool ret = false;\r\nint i, tries = 0;\r\nif (HAS_PCH_SPLIT(dev))\r\nreturn intel_ironlake_crt_detect_hotplug(connector);\r\nif (IS_G4X(dev) && !IS_GM45(dev))\r\ntries = 2;\r\nelse\r\ntries = 1;\r\nhotplug_en = orig = I915_READ(PORT_HOTPLUG_EN);\r\nhotplug_en |= CRT_HOTPLUG_FORCE_DETECT;\r\nfor (i = 0; i < tries ; i++) {\r\nI915_WRITE(PORT_HOTPLUG_EN, hotplug_en);\r\nif (wait_for((I915_READ(PORT_HOTPLUG_EN) &\r\nCRT_HOTPLUG_FORCE_DETECT) == 0,\r\n1000))\r\nDRM_DEBUG_KMS("timed out waiting for FORCE_DETECT to go off");\r\n}\r\nstat = I915_READ(PORT_HOTPLUG_STAT);\r\nif ((stat & CRT_HOTPLUG_MONITOR_MASK) != CRT_HOTPLUG_MONITOR_NONE)\r\nret = true;\r\nI915_WRITE(PORT_HOTPLUG_STAT, CRT_HOTPLUG_INT_STATUS);\r\nI915_WRITE(PORT_HOTPLUG_EN, orig);\r\nreturn ret;\r\n}\r\nstatic bool intel_crt_detect_ddc(struct drm_connector *connector)\r\n{\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nstruct drm_i915_private *dev_priv = crt->base.base.dev->dev_private;\r\nif (crt->base.type != INTEL_OUTPUT_ANALOG)\r\nreturn false;\r\nif (intel_ddc_probe(&crt->base, dev_priv->crt_ddc_pin)) {\r\nstruct edid *edid;\r\nbool is_digital = false;\r\nedid = drm_get_edid(connector,\r\n&dev_priv->gmbus[dev_priv->crt_ddc_pin].adapter);\r\nif (edid != NULL) {\r\nis_digital = edid->input & DRM_EDID_INPUT_DIGITAL;\r\nconnector->display_info.raw_edid = NULL;\r\nkfree(edid);\r\n}\r\nif (!is_digital) {\r\nDRM_DEBUG_KMS("CRT detected via DDC:0x50 [EDID]\n");\r\nreturn true;\r\n} else {\r\nDRM_DEBUG_KMS("CRT not detected via DDC:0x50 [EDID reports a digital panel]\n");\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status\r\nintel_crt_load_detect(struct intel_crt *crt)\r\n{\r\nstruct drm_device *dev = crt->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nuint32_t pipe = to_intel_crtc(crt->base.base.crtc)->pipe;\r\nuint32_t save_bclrpat;\r\nuint32_t save_vtotal;\r\nuint32_t vtotal, vactive;\r\nuint32_t vsample;\r\nuint32_t vblank, vblank_start, vblank_end;\r\nuint32_t dsl;\r\nuint32_t bclrpat_reg;\r\nuint32_t vtotal_reg;\r\nuint32_t vblank_reg;\r\nuint32_t vsync_reg;\r\nuint32_t pipeconf_reg;\r\nuint32_t pipe_dsl_reg;\r\nuint8_t st00;\r\nenum drm_connector_status status;\r\nDRM_DEBUG_KMS("starting load-detect on CRT\n");\r\nbclrpat_reg = BCLRPAT(pipe);\r\nvtotal_reg = VTOTAL(pipe);\r\nvblank_reg = VBLANK(pipe);\r\nvsync_reg = VSYNC(pipe);\r\npipeconf_reg = PIPECONF(pipe);\r\npipe_dsl_reg = PIPEDSL(pipe);\r\nsave_bclrpat = I915_READ(bclrpat_reg);\r\nsave_vtotal = I915_READ(vtotal_reg);\r\nvblank = I915_READ(vblank_reg);\r\nvtotal = ((save_vtotal >> 16) & 0xfff) + 1;\r\nvactive = (save_vtotal & 0x7ff) + 1;\r\nvblank_start = (vblank & 0xfff) + 1;\r\nvblank_end = ((vblank >> 16) & 0xfff) + 1;\r\nI915_WRITE(bclrpat_reg, 0x500050);\r\nif (!IS_GEN2(dev)) {\r\nuint32_t pipeconf = I915_READ(pipeconf_reg);\r\nI915_WRITE(pipeconf_reg, pipeconf | PIPECONF_FORCE_BORDER);\r\nPOSTING_READ(pipeconf_reg);\r\nintel_wait_for_vblank(dev, pipe);\r\nst00 = I915_READ8(VGA_MSR_WRITE);\r\nstatus = ((st00 & (1 << 4)) != 0) ?\r\nconnector_status_connected :\r\nconnector_status_disconnected;\r\nI915_WRITE(pipeconf_reg, pipeconf);\r\n} else {\r\nbool restore_vblank = false;\r\nint count, detect;\r\nif (vblank_start <= vactive && vblank_end >= vtotal) {\r\nuint32_t vsync = I915_READ(vsync_reg);\r\nuint32_t vsync_start = (vsync & 0xffff) + 1;\r\nvblank_start = vsync_start;\r\nI915_WRITE(vblank_reg,\r\n(vblank_start - 1) |\r\n((vblank_end - 1) << 16));\r\nrestore_vblank = true;\r\n}\r\nif (vblank_start - vactive >= vtotal - vblank_end)\r\nvsample = (vblank_start + vactive) >> 1;\r\nelse\r\nvsample = (vtotal + vblank_end) >> 1;\r\nwhile (I915_READ(pipe_dsl_reg) >= vactive)\r\n;\r\nwhile ((dsl = I915_READ(pipe_dsl_reg)) <= vsample)\r\n;\r\ndetect = 0;\r\ncount = 0;\r\ndo {\r\ncount++;\r\nst00 = I915_READ8(VGA_MSR_WRITE);\r\nif (st00 & (1 << 4))\r\ndetect++;\r\n} while ((I915_READ(pipe_dsl_reg) == dsl));\r\nif (restore_vblank)\r\nI915_WRITE(vblank_reg, vblank);\r\nstatus = detect * 4 > count * 3 ?\r\nconnector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nI915_WRITE(bclrpat_reg, save_bclrpat);\r\nreturn status;\r\n}\r\nstatic enum drm_connector_status\r\nintel_crt_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nstruct drm_crtc *crtc;\r\nenum drm_connector_status status;\r\nif (I915_HAS_HOTPLUG(dev)) {\r\nif (intel_crt_detect_hotplug(connector)) {\r\nDRM_DEBUG_KMS("CRT detected via hotplug\n");\r\nreturn connector_status_connected;\r\n} else {\r\nDRM_DEBUG_KMS("CRT not detected via hotplug\n");\r\nreturn connector_status_disconnected;\r\n}\r\n}\r\nif (intel_crt_detect_ddc(connector))\r\nreturn connector_status_connected;\r\nif (!force)\r\nreturn connector->status;\r\ncrtc = crt->base.base.crtc;\r\nif (crtc && crtc->enabled) {\r\nstatus = intel_crt_load_detect(crt);\r\n} else {\r\nstruct intel_load_detect_pipe tmp;\r\nif (intel_get_load_detect_pipe(&crt->base, connector, NULL,\r\n&tmp)) {\r\nif (intel_crt_detect_ddc(connector))\r\nstatus = connector_status_connected;\r\nelse\r\nstatus = intel_crt_load_detect(crt);\r\nintel_release_load_detect_pipe(&crt->base, connector,\r\n&tmp);\r\n} else\r\nstatus = connector_status_unknown;\r\n}\r\nreturn status;\r\n}\r\nstatic void intel_crt_destroy(struct drm_connector *connector)\r\n{\r\ndrm_sysfs_connector_remove(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic int intel_crt_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nint ret;\r\nret = intel_ddc_get_modes(connector,\r\n&dev_priv->gmbus[dev_priv->crt_ddc_pin].adapter);\r\nif (ret || !IS_G4X(dev))\r\nreturn ret;\r\nreturn intel_ddc_get_modes(connector,\r\n&dev_priv->gmbus[GMBUS_PORT_DPB].adapter);\r\n}\r\nstatic int intel_crt_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nreturn 0;\r\n}\r\nstatic void intel_crt_reset(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nif (HAS_PCH_SPLIT(dev))\r\ncrt->force_hotplug_required = 1;\r\n}\r\nvoid intel_crt_init(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector;\r\nstruct intel_crt *crt;\r\nstruct intel_connector *intel_connector;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\ncrt = kzalloc(sizeof(struct intel_crt), GFP_KERNEL);\r\nif (!crt)\r\nreturn;\r\nintel_connector = kzalloc(sizeof(struct intel_connector), GFP_KERNEL);\r\nif (!intel_connector) {\r\nkfree(crt);\r\nreturn;\r\n}\r\nconnector = &intel_connector->base;\r\ndrm_connector_init(dev, &intel_connector->base,\r\n&intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);\r\ndrm_encoder_init(dev, &crt->base.base, &intel_crt_enc_funcs,\r\nDRM_MODE_ENCODER_DAC);\r\nintel_connector_attach_encoder(intel_connector, &crt->base);\r\ncrt->base.type = INTEL_OUTPUT_ANALOG;\r\ncrt->base.clone_mask = (1 << INTEL_SDVO_NON_TV_CLONE_BIT |\r\n1 << INTEL_ANALOG_CLONE_BIT |\r\n1 << INTEL_SDVO_LVDS_CLONE_BIT);\r\ncrt->base.crtc_mask = (1 << 0) | (1 << 1);\r\nconnector->interlace_allowed = 1;\r\nconnector->doublescan_allowed = 0;\r\ndrm_encoder_helper_add(&crt->base.base, &intel_crt_helper_funcs);\r\ndrm_connector_helper_add(connector, &intel_crt_connector_helper_funcs);\r\ndrm_sysfs_connector_add(connector);\r\nif (I915_HAS_HOTPLUG(dev))\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nelse\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\ncrt->force_hotplug_required = 0;\r\nif (HAS_PCH_SPLIT(dev)) {\r\nu32 adpa;\r\nadpa = I915_READ(PCH_ADPA);\r\nadpa &= ~ADPA_CRT_HOTPLUG_MASK;\r\nadpa |= ADPA_HOTPLUG_BITS;\r\nI915_WRITE(PCH_ADPA, adpa);\r\nPOSTING_READ(PCH_ADPA);\r\nDRM_DEBUG_KMS("pch crt adpa set to 0x%x\n", adpa);\r\ncrt->force_hotplug_required = 1;\r\n}\r\ndev_priv->hotplug_supported_mask |= CRT_HOTPLUG_INT_STATUS;\r\n}
