void\r\np9_release_req_pages(struct trans_rpage_info *rpinfo)\r\n{\r\nint i = 0;\r\nwhile (rpinfo->rp_data[i] && rpinfo->rp_nr_pages--) {\r\nput_page(rpinfo->rp_data[i]);\r\ni++;\r\n}\r\n}\r\nint\r\np9_nr_pages(struct p9_req_t *req)\r\n{\r\nunsigned long start_page, end_page;\r\nstart_page = (unsigned long)req->tc->pubuf >> PAGE_SHIFT;\r\nend_page = ((unsigned long)req->tc->pubuf + req->tc->pbuf_size +\r\nPAGE_SIZE - 1) >> PAGE_SHIFT;\r\nreturn end_page - start_page;\r\n}\r\nint\r\np9_payload_gup(struct p9_req_t *req, size_t *pdata_off, int *pdata_len,\r\nint nr_pages, u8 rw)\r\n{\r\nuint32_t first_page_bytes = 0;\r\nint32_t pdata_mapped_pages;\r\nstruct trans_rpage_info *rpinfo;\r\n*pdata_off = (__force size_t)req->tc->pubuf & (PAGE_SIZE-1);\r\nif (*pdata_off)\r\nfirst_page_bytes = min(((size_t)PAGE_SIZE - *pdata_off),\r\nreq->tc->pbuf_size);\r\nrpinfo = req->tc->private;\r\npdata_mapped_pages = get_user_pages_fast((unsigned long)req->tc->pubuf,\r\nnr_pages, rw, &rpinfo->rp_data[0]);\r\nif (pdata_mapped_pages <= 0)\r\nreturn pdata_mapped_pages;\r\nrpinfo->rp_nr_pages = pdata_mapped_pages;\r\nif (*pdata_off) {\r\n*pdata_len = first_page_bytes;\r\n*pdata_len += min((req->tc->pbuf_size - *pdata_len),\r\n((size_t)pdata_mapped_pages - 1) << PAGE_SHIFT);\r\n} else {\r\n*pdata_len = min(req->tc->pbuf_size,\r\n(size_t)pdata_mapped_pages << PAGE_SHIFT);\r\n}\r\nreturn 0;\r\n}
