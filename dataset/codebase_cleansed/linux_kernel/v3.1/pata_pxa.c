static void pxa_load_dmac(struct scatterlist *sg, struct ata_queued_cmd *qc)\r\n{\r\nstruct pata_pxa_data *pd = qc->ap->private_data;\r\nuint32_t cpu_len, seg_len;\r\ndma_addr_t cpu_addr;\r\ncpu_addr = sg_dma_address(sg);\r\ncpu_len = sg_dma_len(sg);\r\ndo {\r\nseg_len = (cpu_len > 0x1000) ? 0x1000 : cpu_len;\r\npd->dma_desc[pd->dma_desc_id].ddadr = pd->dma_desc_addr +\r\n((pd->dma_desc_id + 1) * sizeof(struct pxa_dma_desc));\r\npd->dma_desc[pd->dma_desc_id].dcmd = DCMD_BURST32 |\r\nDCMD_WIDTH2 | (DCMD_LENGTH & seg_len);\r\nif (qc->tf.flags & ATA_TFLAG_WRITE) {\r\npd->dma_desc[pd->dma_desc_id].dsadr = cpu_addr;\r\npd->dma_desc[pd->dma_desc_id].dtadr = pd->dma_io_addr;\r\npd->dma_desc[pd->dma_desc_id].dcmd |= DCMD_INCSRCADDR |\r\nDCMD_FLOWTRG;\r\n} else {\r\npd->dma_desc[pd->dma_desc_id].dsadr = pd->dma_io_addr;\r\npd->dma_desc[pd->dma_desc_id].dtadr = cpu_addr;\r\npd->dma_desc[pd->dma_desc_id].dcmd |= DCMD_INCTRGADDR |\r\nDCMD_FLOWSRC;\r\n}\r\ncpu_len -= seg_len;\r\ncpu_addr += seg_len;\r\npd->dma_desc_id++;\r\n} while (cpu_len);\r\nif (seg_len & 0x1f)\r\nDALGN |= (1 << pd->dma_dreq);\r\n}\r\nstatic void pxa_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct pata_pxa_data *pd = qc->ap->private_data;\r\nint si = 0;\r\nstruct scatterlist *sg;\r\nif (!(qc->flags & ATA_QCFLAG_DMAMAP))\r\nreturn;\r\npd->dma_desc_id = 0;\r\nDCSR(pd->dma_channel) = 0;\r\nDALGN &= ~(1 << pd->dma_dreq);\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si)\r\npxa_load_dmac(sg, qc);\r\npd->dma_desc[pd->dma_desc_id - 1].ddadr = DDADR_STOP;\r\npd->dma_desc[pd->dma_desc_id - 1].dcmd |= DCMD_ENDIRQEN;\r\nDDADR(pd->dma_channel) = pd->dma_desc_addr;\r\nDRCMR(pd->dma_dreq) = DRCMR_MAPVLD | pd->dma_channel;\r\n}\r\nstatic void pxa_bmdma_setup(struct ata_queued_cmd *qc)\r\n{\r\nqc->ap->ops->sff_exec_command(qc->ap, &qc->tf);\r\n}\r\nstatic void pxa_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct pata_pxa_data *pd = qc->ap->private_data;\r\ninit_completion(&pd->dma_done);\r\nDCSR(pd->dma_channel) = DCSR_RUN;\r\n}\r\nstatic void pxa_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct pata_pxa_data *pd = qc->ap->private_data;\r\nif ((DCSR(pd->dma_channel) & DCSR_RUN) &&\r\nwait_for_completion_timeout(&pd->dma_done, HZ))\r\ndev_err(qc->ap->dev, "Timeout waiting for DMA completion!");\r\nDCSR(pd->dma_channel) = 0;\r\n}\r\nstatic unsigned char pxa_bmdma_status(struct ata_port *ap)\r\n{\r\nstruct pata_pxa_data *pd = ap->private_data;\r\nunsigned char ret = ATA_DMA_INTR;\r\nif (pd->dma_dcsr & DCSR_BUSERR)\r\nret |= ATA_DMA_ERR;\r\nreturn ret;\r\n}\r\nstatic void pxa_irq_clear(struct ata_port *ap)\r\n{\r\n}\r\nstatic int pxa_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void pxa_ata_dma_irq(int dma, void *port)\r\n{\r\nstruct ata_port *ap = port;\r\nstruct pata_pxa_data *pd = ap->private_data;\r\npd->dma_dcsr = DCSR(dma);\r\nDCSR(dma) = pd->dma_dcsr;\r\nif (pd->dma_dcsr & DCSR_STOPSTATE)\r\ncomplete(&pd->dma_done);\r\n}\r\nstatic int __devinit pxa_ata_probe(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nstruct pata_pxa_data *data;\r\nstruct resource *cmd_res;\r\nstruct resource *ctl_res;\r\nstruct resource *dma_res;\r\nstruct resource *irq_res;\r\nstruct pata_pxa_pdata *pdata = pdev->dev.platform_data;\r\nint ret = 0;\r\nif (pdev->num_resources != 4) {\r\ndev_err(&pdev->dev, "invalid number of resources\n");\r\nreturn -EINVAL;\r\n}\r\ncmd_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(cmd_res == NULL))\r\nreturn -EINVAL;\r\nctl_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (unlikely(ctl_res == NULL))\r\nreturn -EINVAL;\r\ndma_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (unlikely(dma_res == NULL))\r\nreturn -EINVAL;\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (unlikely(irq_res == NULL))\r\nreturn -EINVAL;\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host)\r\nreturn -ENOMEM;\r\nap = host->ports[0];\r\nap->ops = &pxa_ata_port_ops;\r\nap->pio_mask = ATA_PIO4;\r\nap->mwdma_mask = ATA_MWDMA2;\r\nap->ioaddr.cmd_addr = devm_ioremap(&pdev->dev, cmd_res->start,\r\nresource_size(cmd_res));\r\nap->ioaddr.ctl_addr = devm_ioremap(&pdev->dev, ctl_res->start,\r\nresource_size(ctl_res));\r\nap->ioaddr.bmdma_addr = devm_ioremap(&pdev->dev, dma_res->start,\r\nresource_size(dma_res));\r\nap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;\r\nap->ioaddr.data_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_DATA << pdata->reg_shift);\r\nap->ioaddr.error_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_ERR << pdata->reg_shift);\r\nap->ioaddr.feature_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_FEATURE << pdata->reg_shift);\r\nap->ioaddr.nsect_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_NSECT << pdata->reg_shift);\r\nap->ioaddr.lbal_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_LBAL << pdata->reg_shift);\r\nap->ioaddr.lbam_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_LBAM << pdata->reg_shift);\r\nap->ioaddr.lbah_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_LBAH << pdata->reg_shift);\r\nap->ioaddr.device_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_DEVICE << pdata->reg_shift);\r\nap->ioaddr.status_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_STATUS << pdata->reg_shift);\r\nap->ioaddr.command_addr = ap->ioaddr.cmd_addr +\r\n(ATA_REG_CMD << pdata->reg_shift);\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct pata_pxa_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nap->private_data = data;\r\ndata->dma_dreq = pdata->dma_dreq;\r\ndata->dma_io_addr = dma_res->start;\r\ndata->dma_desc = dmam_alloc_coherent(&pdev->dev, PAGE_SIZE,\r\n&data->dma_desc_addr, GFP_KERNEL);\r\nif (!data->dma_desc)\r\nreturn -EINVAL;\r\ndata->dma_channel = pxa_request_dma(DRV_NAME, DMA_PRIO_LOW,\r\npxa_ata_dma_irq, ap);\r\nif (data->dma_channel < 0)\r\nreturn -EBUSY;\r\nDCSR(data->dma_channel) = 0;\r\nret = ata_host_activate(host, irq_res->start, ata_sff_interrupt,\r\npdata->irq_flags, &pxa_ata_sht);\r\nif (ret)\r\npxa_free_dma(data->dma_channel);\r\nreturn ret;\r\n}\r\nstatic int __devexit pxa_ata_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nstruct pata_pxa_data *data = host->ports[0]->private_data;\r\npxa_free_dma(data->dma_channel);\r\nata_host_detach(host);\r\nreturn 0;\r\n}\r\nstatic int __init pxa_ata_init(void)\r\n{\r\nreturn platform_driver_register(&pxa_ata_driver);\r\n}\r\nstatic void __exit pxa_ata_exit(void)\r\n{\r\nplatform_driver_unregister(&pxa_ata_driver);\r\n}
