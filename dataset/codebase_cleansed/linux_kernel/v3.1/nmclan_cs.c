static int nmclan_probe(struct pcmcia_device *link)\r\n{\r\nmace_private *lp;\r\nstruct net_device *dev;\r\ndev_dbg(&link->dev, "nmclan_attach()\n");\r\ndev = alloc_etherdev(sizeof(mace_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nlp->p_dev = link;\r\nlink->priv = dev;\r\nspin_lock_init(&lp->bank_lock);\r\nlink->resource[0]->end = 32;\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\nlink->config_index = 1;\r\nlink->config_regs = PRESENT_OPTION;\r\nlp->tx_free_frames=AM2150_MAX_TX_FRAMES;\r\ndev->netdev_ops = &mace_netdev_ops;\r\nSET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nreturn nmclan_config(link);\r\n}\r\nstatic void nmclan_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\ndev_dbg(&link->dev, "nmclan_detach\n");\r\nunregister_netdev(dev);\r\nnmclan_release(link);\r\nfree_netdev(dev);\r\n}\r\nstatic int mace_read(mace_private *lp, unsigned int ioaddr, int reg)\r\n{\r\nint data = 0xFF;\r\nunsigned long flags;\r\nswitch (reg >> 4) {\r\ncase 0:\r\ndata = inb(ioaddr + AM2150_MACE_BASE + reg);\r\nbreak;\r\ncase 1:\r\nspin_lock_irqsave(&lp->bank_lock, flags);\r\nMACEBANK(1);\r\ndata = inb(ioaddr + AM2150_MACE_BASE + (reg & 0x0F));\r\nMACEBANK(0);\r\nspin_unlock_irqrestore(&lp->bank_lock, flags);\r\nbreak;\r\n}\r\nreturn data & 0xFF;\r\n}\r\nstatic void mace_write(mace_private *lp, unsigned int ioaddr, int reg,\r\nint data)\r\n{\r\nunsigned long flags;\r\nswitch (reg >> 4) {\r\ncase 0:\r\noutb(data & 0xFF, ioaddr + AM2150_MACE_BASE + reg);\r\nbreak;\r\ncase 1:\r\nspin_lock_irqsave(&lp->bank_lock, flags);\r\nMACEBANK(1);\r\noutb(data & 0xFF, ioaddr + AM2150_MACE_BASE + (reg & 0x0F));\r\nMACEBANK(0);\r\nspin_unlock_irqrestore(&lp->bank_lock, flags);\r\nbreak;\r\n}\r\n}\r\nstatic int mace_init(mace_private *lp, unsigned int ioaddr, char *enet_addr)\r\n{\r\nint i;\r\nint ct = 0;\r\nmace_write(lp, ioaddr, MACE_BIUCC, 1);\r\nwhile (mace_read(lp, ioaddr, MACE_BIUCC) & 0x01) {\r\n;\r\nif(++ct > 500)\r\n{\r\npr_err("reset failed, card removed?\n");\r\nreturn -1;\r\n}\r\nudelay(1);\r\n}\r\nmace_write(lp, ioaddr, MACE_BIUCC, 0);\r\nmace_write(lp, ioaddr, MACE_FIFOCC, 0x0F);\r\nmace_write(lp,ioaddr, MACE_RCVFC, 0);\r\nmace_write(lp, ioaddr, MACE_IMR, 0xFF);\r\nswitch (if_port) {\r\ncase 1:\r\nmace_write(lp, ioaddr, MACE_PLSCC, 0x02);\r\nbreak;\r\ncase 2:\r\nmace_write(lp, ioaddr, MACE_PLSCC, 0x00);\r\nbreak;\r\ndefault:\r\nmace_write(lp, ioaddr, MACE_PHYCC, 4);\r\nbreak;\r\n}\r\nmace_write(lp, ioaddr, MACE_IAC, MACE_IAC_ADDRCHG | MACE_IAC_PHYADDR);\r\nct = 0;\r\nwhile (mace_read(lp, ioaddr, MACE_IAC) & MACE_IAC_ADDRCHG)\r\n{\r\nif(++ ct > 500)\r\n{\r\npr_err("ADDRCHG timeout, card removed?\n");\r\nreturn -1;\r\n}\r\n}\r\nfor (i = 0; i < ETHER_ADDR_LEN; i++)\r\nmace_write(lp, ioaddr, MACE_PADR, enet_addr[i]);\r\nmace_write(lp, ioaddr, MACE_MACCC, 0x00);\r\nreturn 0;\r\n}\r\nstatic int nmclan_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nmace_private *lp = netdev_priv(dev);\r\nu8 *buf;\r\nsize_t len;\r\nint i, ret;\r\nunsigned int ioaddr;\r\ndev_dbg(&link->dev, "nmclan_config\n");\r\nlink->io_lines = 5;\r\nret = pcmcia_request_io(link);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_request_exclusive_irq(link, mace_interrupt);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nioaddr = dev->base_addr;\r\nlen = pcmcia_get_tuple(link, 0x80, &buf);\r\nif (!buf || len < ETHER_ADDR_LEN) {\r\nkfree(buf);\r\ngoto failed;\r\n}\r\nmemcpy(dev->dev_addr, buf, ETHER_ADDR_LEN);\r\nkfree(buf);\r\n{\r\nchar sig[2];\r\nsig[0] = mace_read(lp, ioaddr, MACE_CHIPIDL);\r\nsig[1] = mace_read(lp, ioaddr, MACE_CHIPIDH);\r\nif ((sig[0] == 0x40) && ((sig[1] & 0x0F) == 0x09)) {\r\ndev_dbg(&link->dev, "nmclan_cs configured: mace id=%x %x\n",\r\nsig[0], sig[1]);\r\n} else {\r\npr_notice("mace id not found: %x %x should be 0x40 0x?9\n",\r\nsig[0], sig[1]);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif(mace_init(lp, ioaddr, dev->dev_addr) == -1)\r\ngoto failed;\r\nif (if_port <= 2)\r\ndev->if_port = if_port;\r\nelse\r\npr_notice("invalid if_port requested\n");\r\nSET_NETDEV_DEV(dev, &link->dev);\r\ni = register_netdev(dev);\r\nif (i != 0) {\r\npr_notice("register_netdev() failed\n");\r\ngoto failed;\r\n}\r\nnetdev_info(dev, "nmclan: port %#3lx, irq %d, %s port, hw_addr %pM\n",\r\ndev->base_addr, dev->irq, if_names[dev->if_port], dev->dev_addr);\r\nreturn 0;\r\nfailed:\r\nnmclan_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void nmclan_release(struct pcmcia_device *link)\r\n{\r\ndev_dbg(&link->dev, "nmclan_release\n");\r\npcmcia_disable_device(link);\r\n}\r\nstatic int nmclan_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int nmclan_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open) {\r\nnmclan_reset(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void nmclan_reset(struct net_device *dev)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\n#if RESET_XILINX\r\nstruct pcmcia_device *link = &lp->link;\r\nu8 OrigCorValue;\r\npcmcia_read_config_byte(link, CISREG_COR, &OrigCorValue);\r\ndev_dbg(&link->dev, "nmclan_reset: OrigCorValue=0x%x, resetting...\n",\r\nOrigCorValue);\r\npcmcia_write_config_byte(link, CISREG_COR, COR_SOFT_RESET);\r\npcmcia_write_config_byte(link, CISREG_COR,\r\n(COR_LEVEL_REQ | (OrigCorValue & COR_CONFIG_MASK)));\r\nlp->tx_free_frames=AM2150_MAX_TX_FRAMES;\r\n#endif\r\nlp->tx_free_frames=AM2150_MAX_TX_FRAMES;\r\nmace_init(lp, dev->base_addr, dev->dev_addr);\r\nmace_write(lp, dev->base_addr, MACE_IMR, MACE_IMR_DEFAULT);\r\nrestore_multicast_list(dev);\r\n}\r\nstatic int mace_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nif ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\r\nif (map->port <= 2) {\r\ndev->if_port = map->port;\r\nnetdev_info(dev, "switched to %s port\n", if_names[dev->if_port]);\r\n} else\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mace_open(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nmace_private *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\nif (!pcmcia_dev_present(link))\r\nreturn -ENODEV;\r\nlink->open++;\r\nMACEBANK(0);\r\nnetif_start_queue(dev);\r\nnmclan_reset(dev);\r\nreturn 0;\r\n}\r\nstatic int mace_close(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nmace_private *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\ndev_dbg(&link->dev, "%s: shutting down ethercard.\n", dev->name);\r\noutb(0xFF, ioaddr + AM2150_MACE_BASE + MACE_IMR);\r\nlink->open--;\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->bus_info, "PCMCIA 0x%lx", dev->base_addr);\r\n}\r\nstatic void mace_tx_timeout(struct net_device *dev)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\nnetdev_notice(dev, "transmit timed out -- ");\r\n#if RESET_ON_TIMEOUT\r\npr_cont("resetting card\n");\r\npcmcia_reset_card(link->socket);\r\n#else\r\npr_cont("NOT resetting card\n");\r\n#endif\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t mace_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nnetif_stop_queue(dev);\r\npr_debug("%s: mace_start_xmit(length = %ld) called.\n",\r\ndev->name, (long)skb->len);\r\n#if (!TX_INTERRUPTABLE)\r\noutb(MACE_IMR_DEFAULT | MACE_IR_XMTINT,\r\nioaddr + AM2150_MACE_BASE + MACE_IMR);\r\nlp->tx_irq_disabled=1;\r\n#endif\r\n{\r\nlp->linux_stats.tx_bytes += skb->len;\r\nlp->tx_free_frames--;\r\noutw(skb->len, ioaddr + AM2150_XMT);\r\noutsw(ioaddr + AM2150_XMT, skb->data, skb->len >> 1);\r\nif (skb->len & 1) {\r\noutb(skb->data[skb->len-1], ioaddr + AM2150_XMT);\r\n}\r\n#if MULTI_TX\r\nif (lp->tx_free_frames > 0)\r\nnetif_start_queue(dev);\r\n#endif\r\n}\r\n#if (!TX_INTERRUPTABLE)\r\nlp->tx_irq_disabled=0;\r\noutb(MACE_IMR_DEFAULT, ioaddr + AM2150_MACE_BASE + MACE_IMR);\r\n#endif\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t mace_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nmace_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr;\r\nint status;\r\nint IntrCnt = MACE_MAX_IR_ITERATIONS;\r\nif (dev == NULL) {\r\npr_debug("mace_interrupt(): irq 0x%X for unknown device.\n",\r\nirq);\r\nreturn IRQ_NONE;\r\n}\r\nioaddr = dev->base_addr;\r\nif (lp->tx_irq_disabled) {\r\nconst char *msg;\r\nif (lp->tx_irq_disabled)\r\nmsg = "Interrupt with tx_irq_disabled";\r\nelse\r\nmsg = "Re-entering the interrupt handler";\r\nnetdev_notice(dev, "%s [isr=%02X, imr=%02X]\n",\r\nmsg,\r\ninb(ioaddr + AM2150_MACE_BASE + MACE_IR),\r\ninb(ioaddr + AM2150_MACE_BASE + MACE_IMR));\r\nreturn IRQ_NONE;\r\n}\r\nif (!netif_device_present(dev)) {\r\nnetdev_dbg(dev, "interrupt from dead card\n");\r\nreturn IRQ_NONE;\r\n}\r\ndo {\r\nstatus = inb(ioaddr + AM2150_MACE_BASE + MACE_IR);\r\npr_debug("mace_interrupt: irq 0x%X status 0x%X.\n", irq, status);\r\nif (status & MACE_IR_RCVINT) {\r\nmace_rx(dev, MACE_MAX_RX_ITERATIONS);\r\n}\r\nif (status & MACE_IR_XMTINT) {\r\nunsigned char fifofc;\r\nunsigned char xmtrc;\r\nunsigned char xmtfs;\r\nfifofc = inb(ioaddr + AM2150_MACE_BASE + MACE_FIFOFC);\r\nif ((fifofc & MACE_FIFOFC_XMTFC)==0) {\r\nlp->linux_stats.tx_errors++;\r\noutb(0xFF, ioaddr + AM2150_XMT_SKIP);\r\n}\r\nxmtrc = inb(ioaddr + AM2150_MACE_BASE + MACE_XMTRC);\r\nif (xmtrc & MACE_XMTRC_EXDEF) lp->mace_stats.exdef++;\r\nlp->mace_stats.xmtrc += (xmtrc & MACE_XMTRC_XMTRC);\r\nif (\r\n(xmtfs = inb(ioaddr + AM2150_MACE_BASE + MACE_XMTFS)) &\r\nMACE_XMTFS_XMTSV\r\n) {\r\nlp->mace_stats.xmtsv++;\r\nif (xmtfs & ~MACE_XMTFS_XMTSV) {\r\nif (xmtfs & MACE_XMTFS_UFLO) {\r\nlp->mace_stats.uflo++;\r\n}\r\nif (xmtfs & MACE_XMTFS_LCOL) {\r\nlp->mace_stats.lcol++;\r\n}\r\nif (xmtfs & MACE_XMTFS_MORE) {\r\nlp->mace_stats.more++;\r\n}\r\nif (xmtfs & MACE_XMTFS_ONE) {\r\nlp->mace_stats.one++;\r\n}\r\nif (xmtfs & MACE_XMTFS_DEFER) {\r\nlp->mace_stats.defer++;\r\n}\r\nif (xmtfs & MACE_XMTFS_LCAR) {\r\nlp->mace_stats.lcar++;\r\n}\r\nif (xmtfs & MACE_XMTFS_RTRY) {\r\nlp->mace_stats.rtry++;\r\n}\r\n}\r\n}\r\nlp->linux_stats.tx_packets++;\r\nlp->tx_free_frames++;\r\nnetif_wake_queue(dev);\r\n}\r\nif (status & ~MACE_IMR_DEFAULT & ~MACE_IR_RCVINT & ~MACE_IR_XMTINT) {\r\nif (status & MACE_IR_JAB) {\r\nlp->mace_stats.jab++;\r\n}\r\nif (status & MACE_IR_BABL) {\r\nlp->mace_stats.babl++;\r\n}\r\nif (status & MACE_IR_CERR) {\r\nlp->mace_stats.cerr++;\r\n}\r\nif (status & MACE_IR_RCVCCO) {\r\nlp->mace_stats.rcvcco++;\r\n}\r\nif (status & MACE_IR_RNTPCO) {\r\nlp->mace_stats.rntpco++;\r\n}\r\nif (status & MACE_IR_MPCO) {\r\nlp->mace_stats.mpco++;\r\n}\r\n}\r\n} while ((status & ~MACE_IMR_DEFAULT) && (--IntrCnt));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mace_rx(struct net_device *dev, unsigned char RxCnt)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nunsigned char rx_framecnt;\r\nunsigned short rx_status;\r\nwhile (\r\n((rx_framecnt = inb(ioaddr + AM2150_RCV_FRAME_COUNT)) > 0) &&\r\n(rx_framecnt <= 12) &&\r\n(RxCnt--)\r\n) {\r\nrx_status = inw(ioaddr + AM2150_RCV);\r\npr_debug("%s: in mace_rx(), framecnt 0x%X, rx_status"\r\n" 0x%X.\n", dev->name, rx_framecnt, rx_status);\r\nif (rx_status & MACE_RCVFS_RCVSTS) {\r\nlp->linux_stats.rx_errors++;\r\nif (rx_status & MACE_RCVFS_OFLO) {\r\nlp->mace_stats.oflo++;\r\n}\r\nif (rx_status & MACE_RCVFS_CLSN) {\r\nlp->mace_stats.clsn++;\r\n}\r\nif (rx_status & MACE_RCVFS_FRAM) {\r\nlp->mace_stats.fram++;\r\n}\r\nif (rx_status & MACE_RCVFS_FCS) {\r\nlp->mace_stats.fcs++;\r\n}\r\n} else {\r\nshort pkt_len = (rx_status & ~MACE_RCVFS_RCVSTS) - 4;\r\nstruct sk_buff *skb;\r\nlp->mace_stats.rfs_rntpc += inb(ioaddr + AM2150_RCV);\r\nlp->mace_stats.rfs_rcvcc += inb(ioaddr + AM2150_RCV);\r\npr_debug(" receiving packet size 0x%X rx_status"\r\n" 0x%X.\n", pkt_len, rx_status);\r\nskb = dev_alloc_skb(pkt_len+2);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\ninsw(ioaddr + AM2150_RCV, skb_put(skb, pkt_len), pkt_len>>1);\r\nif (pkt_len & 1)\r\n*(skb_tail_pointer(skb) - 1) = inb(ioaddr + AM2150_RCV);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\nlp->linux_stats.rx_packets++;\r\nlp->linux_stats.rx_bytes += pkt_len;\r\noutb(0xFF, ioaddr + AM2150_RCV_NEXT);\r\ncontinue;\r\n} else {\r\npr_debug("%s: couldn't allocate a sk_buff of size"\r\n" %d.\n", dev->name, pkt_len);\r\nlp->linux_stats.rx_dropped++;\r\n}\r\n}\r\noutb(0xFF, ioaddr + AM2150_RCV_NEXT);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pr_linux_stats(struct net_device_stats *pstats)\r\n{\r\npr_debug("pr_linux_stats\n");\r\npr_debug(" rx_packets=%-7ld tx_packets=%ld\n",\r\n(long)pstats->rx_packets, (long)pstats->tx_packets);\r\npr_debug(" rx_errors=%-7ld tx_errors=%ld\n",\r\n(long)pstats->rx_errors, (long)pstats->tx_errors);\r\npr_debug(" rx_dropped=%-7ld tx_dropped=%ld\n",\r\n(long)pstats->rx_dropped, (long)pstats->tx_dropped);\r\npr_debug(" multicast=%-7ld collisions=%ld\n",\r\n(long)pstats->multicast, (long)pstats->collisions);\r\npr_debug(" rx_length_errors=%-7ld rx_over_errors=%ld\n",\r\n(long)pstats->rx_length_errors, (long)pstats->rx_over_errors);\r\npr_debug(" rx_crc_errors=%-7ld rx_frame_errors=%ld\n",\r\n(long)pstats->rx_crc_errors, (long)pstats->rx_frame_errors);\r\npr_debug(" rx_fifo_errors=%-7ld rx_missed_errors=%ld\n",\r\n(long)pstats->rx_fifo_errors, (long)pstats->rx_missed_errors);\r\npr_debug(" tx_aborted_errors=%-7ld tx_carrier_errors=%ld\n",\r\n(long)pstats->tx_aborted_errors, (long)pstats->tx_carrier_errors);\r\npr_debug(" tx_fifo_errors=%-7ld tx_heartbeat_errors=%ld\n",\r\n(long)pstats->tx_fifo_errors, (long)pstats->tx_heartbeat_errors);\r\npr_debug(" tx_window_errors=%ld\n",\r\n(long)pstats->tx_window_errors);\r\n}\r\nstatic void pr_mace_stats(mace_statistics *pstats)\r\n{\r\npr_debug("pr_mace_stats\n");\r\npr_debug(" xmtsv=%-7d uflo=%d\n",\r\npstats->xmtsv, pstats->uflo);\r\npr_debug(" lcol=%-7d more=%d\n",\r\npstats->lcol, pstats->more);\r\npr_debug(" one=%-7d defer=%d\n",\r\npstats->one, pstats->defer);\r\npr_debug(" lcar=%-7d rtry=%d\n",\r\npstats->lcar, pstats->rtry);\r\npr_debug(" exdef=%-7d xmtrc=%d\n",\r\npstats->exdef, pstats->xmtrc);\r\npr_debug(" oflo=%-7d clsn=%d\n",\r\npstats->oflo, pstats->clsn);\r\npr_debug(" fram=%-7d fcs=%d\n",\r\npstats->fram, pstats->fcs);\r\npr_debug(" rfs_rntpc=%-7d rfs_rcvcc=%d\n",\r\npstats->rfs_rntpc, pstats->rfs_rcvcc);\r\npr_debug(" jab=%-7d babl=%d\n",\r\npstats->jab, pstats->babl);\r\npr_debug(" cerr=%-7d rcvcco=%d\n",\r\npstats->cerr, pstats->rcvcco);\r\npr_debug(" rntpco=%-7d mpco=%d\n",\r\npstats->rntpco, pstats->mpco);\r\npr_debug(" mpc=%d\n", pstats->mpc);\r\npr_debug(" rntpc=%d\n", pstats->rntpc);\r\npr_debug(" rcvcc=%d\n", pstats->rcvcc);\r\n}\r\nstatic void update_stats(unsigned int ioaddr, struct net_device *dev)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\nlp->mace_stats.rcvcc += mace_read(lp, ioaddr, MACE_RCVCC);\r\nlp->mace_stats.rntpc += mace_read(lp, ioaddr, MACE_RNTPC);\r\nlp->mace_stats.mpc += mace_read(lp, ioaddr, MACE_MPC);\r\nlp->linux_stats.collisions =\r\nlp->mace_stats.rcvcco * 256 + lp->mace_stats.rcvcc;\r\nlp->linux_stats.rx_length_errors =\r\nlp->mace_stats.rntpco * 256 + lp->mace_stats.rntpc;\r\nlp->linux_stats.rx_crc_errors = lp->mace_stats.fcs;\r\nlp->linux_stats.rx_frame_errors = lp->mace_stats.fram;\r\nlp->linux_stats.rx_fifo_errors = lp->mace_stats.oflo;\r\nlp->linux_stats.rx_missed_errors =\r\nlp->mace_stats.mpco * 256 + lp->mace_stats.mpc;\r\nlp->linux_stats.tx_aborted_errors = lp->mace_stats.rtry;\r\nlp->linux_stats.tx_carrier_errors = lp->mace_stats.lcar;\r\nlp->linux_stats.tx_fifo_errors = lp->mace_stats.uflo;\r\nlp->linux_stats.tx_heartbeat_errors = lp->mace_stats.cerr;\r\n}\r\nstatic struct net_device_stats *mace_get_stats(struct net_device *dev)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\nupdate_stats(dev->base_addr, dev);\r\npr_debug("%s: updating the statistics.\n", dev->name);\r\npr_linux_stats(&lp->linux_stats);\r\npr_mace_stats(&lp->mace_stats);\r\nreturn &lp->linux_stats;\r\n}\r\nstatic void updateCRC(int *CRC, int bit)\r\n{\r\nstatic const int poly[]={\r\n1,1,1,0, 1,1,0,1,\r\n1,0,1,1, 1,0,0,0,\r\n1,0,0,0, 0,0,1,1,\r\n0,0,1,0, 0,0,0,0\r\n};\r\nint j;\r\nfor (j = 32; j > 0; j--)\r\nCRC[j] = CRC[j-1];\r\nCRC[0] = 0;\r\nif (bit ^ CRC[32])\r\nfor (j = 0; j < 32; j++)\r\nCRC[j] ^= poly[j];\r\n}\r\nstatic void BuildLAF(int *ladrf, int *adr)\r\n{\r\nint CRC[33]={1};\r\nint i, byte;\r\nint hashcode;\r\nCRC[32]=0;\r\nfor (byte = 0; byte < 6; byte++)\r\nfor (i = 0; i < 8; i++)\r\nupdateCRC(CRC, (adr[byte] >> i) & 1);\r\nhashcode = 0;\r\nfor (i = 0; i < 6; i++)\r\nhashcode = (hashcode << 1) + CRC[i];\r\nbyte = hashcode >> 3;\r\nladrf[byte] |= (1 << (hashcode & 7));\r\n#ifdef PCMCIA_DEBUG\r\nif (0)\r\nprintk(KERN_DEBUG " adr =%pM\n", adr);\r\nprintk(KERN_DEBUG " hashcode = %d(decimal), ladrf[0:63] =", hashcode);\r\nfor (i = 0; i < 8; i++)\r\npr_cont(" %02X", ladrf[i]);\r\npr_cont("\n");\r\n#endif\r\n}\r\nstatic void restore_multicast_list(struct net_device *dev)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\nint num_addrs = lp->multicast_num_addrs;\r\nint *ladrf = lp->multicast_ladrf;\r\nunsigned int ioaddr = dev->base_addr;\r\nint i;\r\npr_debug("%s: restoring Rx mode to %d addresses.\n",\r\ndev->name, num_addrs);\r\nif (num_addrs > 0) {\r\npr_debug("Attempt to restore multicast list detected.\n");\r\nmace_write(lp, ioaddr, MACE_IAC, MACE_IAC_ADDRCHG | MACE_IAC_LOGADDR);\r\nwhile (mace_read(lp, ioaddr, MACE_IAC) & MACE_IAC_ADDRCHG)\r\n;\r\nfor (i = 0; i < MACE_LADRF_LEN; i++)\r\nmace_write(lp, ioaddr, MACE_LADRF, ladrf[i]);\r\nmace_write(lp, ioaddr, MACE_UTR, MACE_UTR_RCVFCSE | MACE_UTR_LOOP_EXTERNAL);\r\nmace_write(lp, ioaddr, MACE_MACCC, MACE_MACCC_ENXMT | MACE_MACCC_ENRCV);\r\n} else if (num_addrs < 0) {\r\nmace_write(lp, ioaddr, MACE_UTR, MACE_UTR_LOOP_EXTERNAL);\r\nmace_write(lp, ioaddr, MACE_MACCC,\r\nMACE_MACCC_PROM | MACE_MACCC_ENXMT | MACE_MACCC_ENRCV\r\n);\r\n} else {\r\nmace_write(lp, ioaddr, MACE_UTR, MACE_UTR_LOOP_EXTERNAL);\r\nmace_write(lp, ioaddr, MACE_MACCC, MACE_MACCC_ENXMT | MACE_MACCC_ENRCV);\r\n}\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\nint adr[ETHER_ADDR_LEN] = {0};\r\nstruct netdev_hw_addr *ha;\r\n#ifdef PCMCIA_DEBUG\r\n{\r\nstatic int old;\r\nif (netdev_mc_count(dev) != old) {\r\nold = netdev_mc_count(dev);\r\npr_debug("%s: setting Rx mode to %d addresses.\n",\r\ndev->name, old);\r\n}\r\n}\r\n#endif\r\nlp->multicast_num_addrs = netdev_mc_count(dev);\r\nif (num_addrs > 0) {\r\nmemset(lp->multicast_ladrf, 0, MACE_LADRF_LEN);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nmemcpy(adr, ha->addr, ETHER_ADDR_LEN);\r\nBuildLAF(lp->multicast_ladrf, adr);\r\n}\r\n}\r\nrestore_multicast_list(dev);\r\n}\r\nstatic void restore_multicast_list(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nmace_private *lp = netdev_priv(dev);\r\npr_debug("%s: restoring Rx mode to %d addresses.\n", dev->name,\r\nlp->multicast_num_addrs);\r\nif (dev->flags & IFF_PROMISC) {\r\nmace_write(lp,ioaddr, MACE_UTR, MACE_UTR_LOOP_EXTERNAL);\r\nmace_write(lp, ioaddr, MACE_MACCC,\r\nMACE_MACCC_PROM | MACE_MACCC_ENXMT | MACE_MACCC_ENRCV\r\n);\r\n} else {\r\nmace_write(lp, ioaddr, MACE_UTR, MACE_UTR_LOOP_EXTERNAL);\r\nmace_write(lp, ioaddr, MACE_MACCC, MACE_MACCC_ENXMT | MACE_MACCC_ENRCV);\r\n}\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nmace_private *lp = netdev_priv(dev);\r\n#ifdef PCMCIA_DEBUG\r\n{\r\nstatic int old;\r\nif (netdev_mc_count(dev) != old) {\r\nold = netdev_mc_count(dev);\r\npr_debug("%s: setting Rx mode to %d addresses.\n",\r\ndev->name, old);\r\n}\r\n}\r\n#endif\r\nlp->multicast_num_addrs = netdev_mc_count(dev);\r\nrestore_multicast_list(dev);\r\n}\r\nstatic int __init init_nmclan_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&nmclan_cs_driver);\r\n}\r\nstatic void __exit exit_nmclan_cs(void)\r\n{\r\npcmcia_unregister_driver(&nmclan_cs_driver);\r\n}
