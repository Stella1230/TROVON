void tty_buffer_free_all(struct tty_struct *tty)\r\n{\r\nstruct tty_buffer *thead;\r\nwhile ((thead = tty->buf.head) != NULL) {\r\ntty->buf.head = thead->next;\r\nkfree(thead);\r\n}\r\nwhile ((thead = tty->buf.free) != NULL) {\r\ntty->buf.free = thead->next;\r\nkfree(thead);\r\n}\r\ntty->buf.tail = NULL;\r\ntty->buf.memory_used = 0;\r\n}\r\nstatic struct tty_buffer *tty_buffer_alloc(struct tty_struct *tty, size_t size)\r\n{\r\nstruct tty_buffer *p;\r\nif (tty->buf.memory_used + size > 65536)\r\nreturn NULL;\r\np = kmalloc(sizeof(struct tty_buffer) + 2 * size, GFP_ATOMIC);\r\nif (p == NULL)\r\nreturn NULL;\r\np->used = 0;\r\np->size = size;\r\np->next = NULL;\r\np->commit = 0;\r\np->read = 0;\r\np->char_buf_ptr = (char *)(p->data);\r\np->flag_buf_ptr = (unsigned char *)p->char_buf_ptr + size;\r\ntty->buf.memory_used += size;\r\nreturn p;\r\n}\r\nstatic void tty_buffer_free(struct tty_struct *tty, struct tty_buffer *b)\r\n{\r\ntty->buf.memory_used -= b->size;\r\nWARN_ON(tty->buf.memory_used < 0);\r\nif (b->size >= 512)\r\nkfree(b);\r\nelse {\r\nb->next = tty->buf.free;\r\ntty->buf.free = b;\r\n}\r\n}\r\nstatic void __tty_buffer_flush(struct tty_struct *tty)\r\n{\r\nstruct tty_buffer *thead;\r\nwhile ((thead = tty->buf.head) != NULL) {\r\ntty->buf.head = thead->next;\r\ntty_buffer_free(tty, thead);\r\n}\r\ntty->buf.tail = NULL;\r\n}\r\nvoid tty_buffer_flush(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->buf.lock, flags);\r\nif (test_bit(TTY_FLUSHING, &tty->flags)) {\r\nset_bit(TTY_FLUSHPENDING, &tty->flags);\r\nspin_unlock_irqrestore(&tty->buf.lock, flags);\r\nwait_event(tty->read_wait,\r\ntest_bit(TTY_FLUSHPENDING, &tty->flags) == 0);\r\nreturn;\r\n} else\r\n__tty_buffer_flush(tty);\r\nspin_unlock_irqrestore(&tty->buf.lock, flags);\r\n}\r\nstatic struct tty_buffer *tty_buffer_find(struct tty_struct *tty, size_t size)\r\n{\r\nstruct tty_buffer **tbh = &tty->buf.free;\r\nwhile ((*tbh) != NULL) {\r\nstruct tty_buffer *t = *tbh;\r\nif (t->size >= size) {\r\n*tbh = t->next;\r\nt->next = NULL;\r\nt->used = 0;\r\nt->commit = 0;\r\nt->read = 0;\r\ntty->buf.memory_used += t->size;\r\nreturn t;\r\n}\r\ntbh = &((*tbh)->next);\r\n}\r\nsize = (size + 0xFF) & ~0xFF;\r\nreturn tty_buffer_alloc(tty, size);\r\n}\r\nint tty_buffer_request_room(struct tty_struct *tty, size_t size)\r\n{\r\nstruct tty_buffer *b, *n;\r\nint left;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->buf.lock, flags);\r\nif ((b = tty->buf.tail) != NULL)\r\nleft = b->size - b->used;\r\nelse\r\nleft = 0;\r\nif (left < size) {\r\nif ((n = tty_buffer_find(tty, size)) != NULL) {\r\nif (b != NULL) {\r\nb->next = n;\r\nb->commit = b->used;\r\n} else\r\ntty->buf.head = n;\r\ntty->buf.tail = n;\r\n} else\r\nsize = left;\r\n}\r\nspin_unlock_irqrestore(&tty->buf.lock, flags);\r\nreturn size;\r\n}\r\nint tty_insert_flip_string_fixed_flag(struct tty_struct *tty,\r\nconst unsigned char *chars, char flag, size_t size)\r\n{\r\nint copied = 0;\r\ndo {\r\nint goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\r\nint space = tty_buffer_request_room(tty, goal);\r\nstruct tty_buffer *tb = tty->buf.tail;\r\nif (unlikely(space == 0))\r\nbreak;\r\nmemcpy(tb->char_buf_ptr + tb->used, chars, space);\r\nmemset(tb->flag_buf_ptr + tb->used, flag, space);\r\ntb->used += space;\r\ncopied += space;\r\nchars += space;\r\n} while (unlikely(size > copied));\r\nreturn copied;\r\n}\r\nint tty_insert_flip_string_flags(struct tty_struct *tty,\r\nconst unsigned char *chars, const char *flags, size_t size)\r\n{\r\nint copied = 0;\r\ndo {\r\nint goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\r\nint space = tty_buffer_request_room(tty, goal);\r\nstruct tty_buffer *tb = tty->buf.tail;\r\nif (unlikely(space == 0))\r\nbreak;\r\nmemcpy(tb->char_buf_ptr + tb->used, chars, space);\r\nmemcpy(tb->flag_buf_ptr + tb->used, flags, space);\r\ntb->used += space;\r\ncopied += space;\r\nchars += space;\r\nflags += space;\r\n} while (unlikely(size > copied));\r\nreturn copied;\r\n}\r\nvoid tty_schedule_flip(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->buf.lock, flags);\r\nif (tty->buf.tail != NULL)\r\ntty->buf.tail->commit = tty->buf.tail->used;\r\nspin_unlock_irqrestore(&tty->buf.lock, flags);\r\nschedule_work(&tty->buf.work);\r\n}\r\nint tty_prepare_flip_string(struct tty_struct *tty, unsigned char **chars,\r\nsize_t size)\r\n{\r\nint space = tty_buffer_request_room(tty, size);\r\nif (likely(space)) {\r\nstruct tty_buffer *tb = tty->buf.tail;\r\n*chars = tb->char_buf_ptr + tb->used;\r\nmemset(tb->flag_buf_ptr + tb->used, TTY_NORMAL, space);\r\ntb->used += space;\r\n}\r\nreturn space;\r\n}\r\nint tty_prepare_flip_string_flags(struct tty_struct *tty,\r\nunsigned char **chars, char **flags, size_t size)\r\n{\r\nint space = tty_buffer_request_room(tty, size);\r\nif (likely(space)) {\r\nstruct tty_buffer *tb = tty->buf.tail;\r\n*chars = tb->char_buf_ptr + tb->used;\r\n*flags = tb->flag_buf_ptr + tb->used;\r\ntb->used += space;\r\n}\r\nreturn space;\r\n}\r\nstatic void flush_to_ldisc(struct work_struct *work)\r\n{\r\nstruct tty_struct *tty =\r\ncontainer_of(work, struct tty_struct, buf.work);\r\nunsigned long flags;\r\nstruct tty_ldisc *disc;\r\ndisc = tty_ldisc_ref(tty);\r\nif (disc == NULL)\r\nreturn;\r\nspin_lock_irqsave(&tty->buf.lock, flags);\r\nif (!test_and_set_bit(TTY_FLUSHING, &tty->flags)) {\r\nstruct tty_buffer *head;\r\nwhile ((head = tty->buf.head) != NULL) {\r\nint count;\r\nchar *char_buf;\r\nunsigned char *flag_buf;\r\ncount = head->commit - head->read;\r\nif (!count) {\r\nif (head->next == NULL)\r\nbreak;\r\ntty->buf.head = head->next;\r\ntty_buffer_free(tty, head);\r\ncontinue;\r\n}\r\nif (test_bit(TTY_FLUSHPENDING, &tty->flags))\r\nbreak;\r\nif (!tty->receive_room)\r\nbreak;\r\nif (count > tty->receive_room)\r\ncount = tty->receive_room;\r\nchar_buf = head->char_buf_ptr + head->read;\r\nflag_buf = head->flag_buf_ptr + head->read;\r\nhead->read += count;\r\nspin_unlock_irqrestore(&tty->buf.lock, flags);\r\ndisc->ops->receive_buf(tty, char_buf,\r\nflag_buf, count);\r\nspin_lock_irqsave(&tty->buf.lock, flags);\r\n}\r\nclear_bit(TTY_FLUSHING, &tty->flags);\r\n}\r\nif (test_bit(TTY_FLUSHPENDING, &tty->flags)) {\r\n__tty_buffer_flush(tty);\r\nclear_bit(TTY_FLUSHPENDING, &tty->flags);\r\nwake_up(&tty->read_wait);\r\n}\r\nspin_unlock_irqrestore(&tty->buf.lock, flags);\r\ntty_ldisc_deref(disc);\r\n}\r\nvoid tty_flush_to_ldisc(struct tty_struct *tty)\r\n{\r\nflush_work(&tty->buf.work);\r\n}\r\nvoid tty_flip_buffer_push(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->buf.lock, flags);\r\nif (tty->buf.tail != NULL)\r\ntty->buf.tail->commit = tty->buf.tail->used;\r\nspin_unlock_irqrestore(&tty->buf.lock, flags);\r\nif (tty->low_latency)\r\nflush_to_ldisc(&tty->buf.work);\r\nelse\r\nschedule_work(&tty->buf.work);\r\n}\r\nvoid tty_buffer_init(struct tty_struct *tty)\r\n{\r\nspin_lock_init(&tty->buf.lock);\r\ntty->buf.head = NULL;\r\ntty->buf.tail = NULL;\r\ntty->buf.free = NULL;\r\ntty->buf.memory_used = 0;\r\nINIT_WORK(&tty->buf.work, flush_to_ldisc);\r\n}
