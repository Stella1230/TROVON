static int pseries_suspend_begin(suspend_state_t state)\r\n{\r\nlong vasi_state, rc;\r\nunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\r\nrc = plpar_hcall(H_VASI_STATE, retbuf, stream_id);\r\nvasi_state = retbuf[0];\r\nif (rc) {\r\npr_err("pseries_suspend_begin: vasi_state returned %ld\n",rc);\r\nreturn rc;\r\n} else if (vasi_state == H_VASI_ENABLED) {\r\nreturn -EAGAIN;\r\n} else if (vasi_state != H_VASI_SUSPENDING) {\r\npr_err("pseries_suspend_begin: vasi_state returned state %ld\n",\r\nvasi_state);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pseries_suspend_cpu(void)\r\n{\r\nif (atomic_read(&suspending))\r\nreturn rtas_suspend_cpu(&suspend_data);\r\nreturn 0;\r\n}\r\nstatic int pseries_suspend_enter(suspend_state_t state)\r\n{\r\nint rc = rtas_suspend_last_cpu(&suspend_data);\r\natomic_set(&suspending, 0);\r\natomic_set(&suspend_data.done, 1);\r\nreturn rc;\r\n}\r\nstatic int pseries_prepare_late(void)\r\n{\r\natomic_set(&suspending, 1);\r\natomic_set(&suspend_data.working, 0);\r\natomic_set(&suspend_data.done, 0);\r\natomic_set(&suspend_data.error, 0);\r\nsuspend_data.complete = &suspend_work;\r\nINIT_COMPLETION(suspend_work);\r\nreturn 0;\r\n}\r\nstatic ssize_t store_hibernate(struct sysdev_class *classdev,\r\nstruct sysdev_class_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint rc;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nstream_id = simple_strtoul(buf, NULL, 16);\r\ndo {\r\nrc = pseries_suspend_begin(PM_SUSPEND_MEM);\r\nif (rc == -EAGAIN)\r\nssleep(1);\r\n} while (rc == -EAGAIN);\r\nif (!rc)\r\nrc = pm_suspend(PM_SUSPEND_MEM);\r\nstream_id = 0;\r\nif (!rc)\r\nrc = count;\r\nreturn rc;\r\n}\r\nstatic int pseries_suspend_sysfs_register(struct sys_device *sysdev)\r\n{\r\nint rc;\r\nif ((rc = sysdev_class_register(&suspend_sysdev_class)))\r\nreturn rc;\r\nsysdev->id = 0;\r\nsysdev->cls = &suspend_sysdev_class;\r\nif ((rc = sysdev_class_create_file(&suspend_sysdev_class, &attr_hibernate)))\r\ngoto class_unregister;\r\nreturn 0;\r\nclass_unregister:\r\nsysdev_class_unregister(&suspend_sysdev_class);\r\nreturn rc;\r\n}\r\nstatic int __init pseries_suspend_init(void)\r\n{\r\nint rc;\r\nif (!machine_is(pseries) || !firmware_has_feature(FW_FEATURE_LPAR))\r\nreturn 0;\r\nsuspend_data.token = rtas_token("ibm,suspend-me");\r\nif (suspend_data.token == RTAS_UNKNOWN_SERVICE)\r\nreturn 0;\r\nif ((rc = pseries_suspend_sysfs_register(&suspend_sysdev)))\r\nreturn rc;\r\nppc_md.suspend_disable_cpu = pseries_suspend_cpu;\r\nsuspend_set_ops(&pseries_suspend_ops);\r\nreturn 0;\r\n}
