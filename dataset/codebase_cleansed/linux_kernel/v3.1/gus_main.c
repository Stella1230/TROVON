int snd_gus_use_inc(struct snd_gus_card * gus)\r\n{\r\nif (!try_module_get(gus->card->module))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid snd_gus_use_dec(struct snd_gus_card * gus)\r\n{\r\nmodule_put(gus->card->module);\r\n}\r\nstatic int snd_gus_joystick_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 31;\r\nreturn 0;\r\n}\r\nstatic int snd_gus_joystick_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = gus->joystick_dac & 31;\r\nreturn 0;\r\n}\r\nstatic int snd_gus_joystick_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned char nval;\r\nnval = ucontrol->value.integer.value[0] & 31;\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\nchange = gus->joystick_dac != nval;\r\ngus->joystick_dac = nval;\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_JOYSTICK_DAC_LEVEL, gus->joystick_dac);\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic void snd_gus_init_control(struct snd_gus_card *gus)\r\n{\r\nif (!gus->ace_flag)\r\nsnd_ctl_add(gus->card, snd_ctl_new1(&snd_gus_joystick_control, gus));\r\n}\r\nstatic int snd_gus_free(struct snd_gus_card *gus)\r\n{\r\nif (gus->gf1.res_port2 == NULL)\r\ngoto __hw_end;\r\nsnd_gf1_stop(gus);\r\nsnd_gus_init_dma_irq(gus, 0);\r\n__hw_end:\r\nrelease_and_free_resource(gus->gf1.res_port1);\r\nrelease_and_free_resource(gus->gf1.res_port2);\r\nif (gus->gf1.irq >= 0)\r\nfree_irq(gus->gf1.irq, (void *) gus);\r\nif (gus->gf1.dma1 >= 0) {\r\ndisable_dma(gus->gf1.dma1);\r\nfree_dma(gus->gf1.dma1);\r\n}\r\nif (!gus->equal_dma && gus->gf1.dma2 >= 0) {\r\ndisable_dma(gus->gf1.dma2);\r\nfree_dma(gus->gf1.dma2);\r\n}\r\nkfree(gus);\r\nreturn 0;\r\n}\r\nstatic int snd_gus_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_gus_card *gus = device->device_data;\r\nreturn snd_gus_free(gus);\r\n}\r\nint snd_gus_create(struct snd_card *card,\r\nunsigned long port,\r\nint irq, int dma1, int dma2,\r\nint timer_dev,\r\nint voices,\r\nint pcm_channels,\r\nint effect,\r\nstruct snd_gus_card **rgus)\r\n{\r\nstruct snd_gus_card *gus;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_gus_dev_free,\r\n};\r\n*rgus = NULL;\r\ngus = kzalloc(sizeof(*gus), GFP_KERNEL);\r\nif (gus == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&gus->reg_lock);\r\nspin_lock_init(&gus->voice_alloc);\r\nspin_lock_init(&gus->active_voice_lock);\r\nspin_lock_init(&gus->event_lock);\r\nspin_lock_init(&gus->dma_lock);\r\nspin_lock_init(&gus->pcm_volume_level_lock);\r\nspin_lock_init(&gus->uart_cmd_lock);\r\nmutex_init(&gus->dma_mutex);\r\ngus->gf1.irq = -1;\r\ngus->gf1.dma1 = -1;\r\ngus->gf1.dma2 = -1;\r\ngus->card = card;\r\ngus->gf1.port = port;\r\ngus->gf1.reg_page = GUSP(gus, GF1PAGE);\r\ngus->gf1.reg_regsel = GUSP(gus, GF1REGSEL);\r\ngus->gf1.reg_data8 = GUSP(gus, GF1DATAHIGH);\r\ngus->gf1.reg_data16 = GUSP(gus, GF1DATALOW);\r\ngus->gf1.reg_irqstat = GUSP(gus, IRQSTAT);\r\ngus->gf1.reg_dram = GUSP(gus, DRAM);\r\ngus->gf1.reg_timerctrl = GUSP(gus, TIMERCNTRL);\r\ngus->gf1.reg_timerdata = GUSP(gus, TIMERDATA);\r\nif ((gus->gf1.res_port1 = request_region(port, 16, "GUS GF1 (Adlib/SB)")) == NULL) {\r\nsnd_printk(KERN_ERR "gus: can't grab SB port 0x%lx\n", port);\r\nsnd_gus_free(gus);\r\nreturn -EBUSY;\r\n}\r\nif ((gus->gf1.res_port2 = request_region(port + 0x100, 12, "GUS GF1 (Synth)")) == NULL) {\r\nsnd_printk(KERN_ERR "gus: can't grab synth port 0x%lx\n", port + 0x100);\r\nsnd_gus_free(gus);\r\nreturn -EBUSY;\r\n}\r\nif (irq >= 0 && request_irq(irq, snd_gus_interrupt, IRQF_DISABLED, "GUS GF1", (void *) gus)) {\r\nsnd_printk(KERN_ERR "gus: can't grab irq %d\n", irq);\r\nsnd_gus_free(gus);\r\nreturn -EBUSY;\r\n}\r\ngus->gf1.irq = irq;\r\nif (request_dma(dma1, "GUS - 1")) {\r\nsnd_printk(KERN_ERR "gus: can't grab DMA1 %d\n", dma1);\r\nsnd_gus_free(gus);\r\nreturn -EBUSY;\r\n}\r\ngus->gf1.dma1 = dma1;\r\nif (dma2 >= 0 && dma1 != dma2) {\r\nif (request_dma(dma2, "GUS - 2")) {\r\nsnd_printk(KERN_ERR "gus: can't grab DMA2 %d\n", dma2);\r\nsnd_gus_free(gus);\r\nreturn -EBUSY;\r\n}\r\ngus->gf1.dma2 = dma2;\r\n} else {\r\ngus->gf1.dma2 = gus->gf1.dma1;\r\ngus->equal_dma = 1;\r\n}\r\ngus->timer_dev = timer_dev;\r\nif (voices < 14)\r\nvoices = 14;\r\nif (voices > 32)\r\nvoices = 32;\r\nif (pcm_channels < 0)\r\npcm_channels = 0;\r\nif (pcm_channels > 8)\r\npcm_channels = 8;\r\npcm_channels++;\r\npcm_channels &= ~1;\r\ngus->gf1.effect = effect ? 1 : 0;\r\ngus->gf1.active_voices = voices;\r\ngus->gf1.pcm_channels = pcm_channels;\r\ngus->gf1.volume_ramp = 25;\r\ngus->gf1.smooth_pan = 1;\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, gus, &ops)) < 0) {\r\nsnd_gus_free(gus);\r\nreturn err;\r\n}\r\n*rgus = gus;\r\nreturn 0;\r\n}\r\nstatic int snd_gus_detect_memory(struct snd_gus_card * gus)\r\n{\r\nint l, idx, local;\r\nunsigned char d;\r\nsnd_gf1_poke(gus, 0L, 0xaa);\r\nsnd_gf1_poke(gus, 1L, 0x55);\r\nif (snd_gf1_peek(gus, 0L) != 0xaa || snd_gf1_peek(gus, 1L) != 0x55) {\r\nsnd_printk(KERN_ERR "plain GF1 card at 0x%lx without onboard DRAM?\n", gus->gf1.port);\r\nreturn -ENOMEM;\r\n}\r\nfor (idx = 1, d = 0xab; idx < 4; idx++, d++) {\r\nlocal = idx << 18;\r\nsnd_gf1_poke(gus, local, d);\r\nsnd_gf1_poke(gus, local + 1, d + 1);\r\nif (snd_gf1_peek(gus, local) != d ||\r\nsnd_gf1_peek(gus, local + 1) != d + 1 ||\r\nsnd_gf1_peek(gus, 0L) != 0xaa)\r\nbreak;\r\n}\r\n#if 1\r\ngus->gf1.memory = idx << 18;\r\n#else\r\ngus->gf1.memory = 256 * 1024;\r\n#endif\r\nfor (l = 0, local = gus->gf1.memory; l < 4; l++, local -= 256 * 1024) {\r\ngus->gf1.mem_alloc.banks_8[l].address =\r\ngus->gf1.mem_alloc.banks_8[l].size = 0;\r\ngus->gf1.mem_alloc.banks_16[l].address = l << 18;\r\ngus->gf1.mem_alloc.banks_16[l].size = local > 0 ? 256 * 1024 : 0;\r\n}\r\ngus->gf1.mem_alloc.banks_8[0].size = gus->gf1.memory;\r\nreturn 0;\r\n}\r\nstatic int snd_gus_init_dma_irq(struct snd_gus_card * gus, int latches)\r\n{\r\nstruct snd_card *card;\r\nunsigned long flags;\r\nint irq, dma1, dma2;\r\nstatic unsigned char irqs[16] =\r\n{0, 0, 1, 3, 0, 2, 0, 4, 0, 1, 0, 5, 6, 0, 0, 7};\r\nstatic unsigned char dmas[8] =\r\n{6, 1, 0, 2, 0, 3, 4, 5};\r\nif (snd_BUG_ON(!gus))\r\nreturn -EINVAL;\r\ncard = gus->card;\r\nif (snd_BUG_ON(!card))\r\nreturn -EINVAL;\r\ngus->mix_cntrl_reg &= 0xf8;\r\ngus->mix_cntrl_reg |= 0x01;\r\nif (gus->codec_flag || gus->ess_flag) {\r\ngus->mix_cntrl_reg &= ~1;\r\ngus->mix_cntrl_reg |= 4;\r\n}\r\ndma1 = gus->gf1.dma1;\r\ndma1 = abs(dma1);\r\ndma1 = dmas[dma1 & 7];\r\ndma2 = gus->gf1.dma2;\r\ndma2 = abs(dma2);\r\ndma2 = dmas[dma2 & 7];\r\ndma1 |= gus->equal_dma ? 0x40 : (dma2 << 3);\r\nif ((dma1 & 7) == 0 || (dma2 & 7) == 0) {\r\nsnd_printk(KERN_ERR "Error! DMA isn't defined.\n");\r\nreturn -EINVAL;\r\n}\r\nirq = gus->gf1.irq;\r\nirq = abs(irq);\r\nirq = irqs[irq & 0x0f];\r\nif (irq == 0) {\r\nsnd_printk(KERN_ERR "Error! IRQ isn't defined.\n");\r\nreturn -EINVAL;\r\n}\r\nirq |= 0x40;\r\n#if 0\r\ncard->mixer.mix_ctrl_reg |= 0x10;\r\n#endif\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\noutb(5, GUSP(gus, REGCNTRLS));\r\noutb(gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\r\noutb(0x00, GUSP(gus, IRQDMACNTRLREG));\r\noutb(0, GUSP(gus, REGCNTRLS));\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\nudelay(100);\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\noutb(0x00 | gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\r\noutb(dma1, GUSP(gus, IRQDMACNTRLREG));\r\nif (latches) {\r\noutb(0x40 | gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\r\noutb(irq, GUSP(gus, IRQDMACNTRLREG));\r\n}\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\nudelay(100);\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\noutb(0x00 | gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\r\noutb(dma1, GUSP(gus, IRQDMACNTRLREG));\r\nif (latches) {\r\noutb(0x40 | gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\r\noutb(irq, GUSP(gus, IRQDMACNTRLREG));\r\n}\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\nsnd_gf1_delay(gus);\r\nif (latches)\r\ngus->mix_cntrl_reg |= 0x08;\r\nelse\r\ngus->mix_cntrl_reg &= ~0x08;\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\noutb(gus->mix_cntrl_reg, GUSP(gus, MIXCNTRLREG));\r\noutb(0, GUSP(gus, GF1PAGE));\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_gus_check_version(struct snd_gus_card * gus)\r\n{\r\nunsigned long flags;\r\nunsigned char val, rev;\r\nstruct snd_card *card;\r\ncard = gus->card;\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\noutb(0x20, GUSP(gus, REGCNTRLS));\r\nval = inb(GUSP(gus, REGCNTRLS));\r\nrev = inb(GUSP(gus, BOARDVERSION));\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\nsnd_printdd("GF1 [0x%lx] init - val = 0x%x, rev = 0x%x\n", gus->gf1.port, val, rev);\r\nstrcpy(card->driver, "GUS");\r\nstrcpy(card->longname, "Gravis UltraSound Classic (2.4)");\r\nif ((val != 255 && (val & 0x06)) || (rev >= 5 && rev != 255)) {\r\nif (rev >= 5 && rev <= 9) {\r\ngus->ics_flag = 1;\r\nif (rev == 5)\r\ngus->ics_flipped = 1;\r\ncard->longname[27] = '3';\r\ncard->longname[29] = rev == 5 ? '5' : '7';\r\n}\r\nif (rev >= 10 && rev != 255) {\r\nif (rev >= 10 && rev <= 11) {\r\nstrcpy(card->driver, "GUS MAX");\r\nstrcpy(card->longname, "Gravis UltraSound MAX");\r\ngus->max_flag = 1;\r\n} else if (rev == 0x30) {\r\nstrcpy(card->driver, "GUS ACE");\r\nstrcpy(card->longname, "Gravis UltraSound Ace");\r\ngus->ace_flag = 1;\r\n} else if (rev == 0x50) {\r\nstrcpy(card->driver, "GUS Extreme");\r\nstrcpy(card->longname, "Gravis UltraSound Extreme");\r\ngus->ess_flag = 1;\r\n} else {\r\nsnd_printk(KERN_ERR "unknown GF1 revision number at 0x%lx - 0x%x (0x%x)\n", gus->gf1.port, rev, val);\r\nsnd_printk(KERN_ERR " please - report to <perex@perex.cz>\n");\r\n}\r\n}\r\n}\r\nstrcpy(card->shortname, card->longname);\r\ngus->uart_enable = 1;\r\nsnd_gus_init_control(gus);\r\nreturn 0;\r\n}\r\nint snd_gus_initialize(struct snd_gus_card *gus)\r\n{\r\nint err;\r\nif (!gus->interwave) {\r\nif ((err = snd_gus_check_version(gus)) < 0) {\r\nsnd_printk(KERN_ERR "version check failed\n");\r\nreturn err;\r\n}\r\nif ((err = snd_gus_detect_memory(gus)) < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_gus_init_dma_irq(gus, 1)) < 0)\r\nreturn err;\r\nsnd_gf1_start(gus);\r\ngus->initialized = 1;\r\nreturn 0;\r\n}\r\nstatic int __init alsa_gus_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_gus_exit(void)\r\n{\r\n}
