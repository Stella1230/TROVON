void vmw_fence_queue_init(struct vmw_fence_queue *queue)\r\n{\r\nINIT_LIST_HEAD(&queue->head);\r\nqueue->lag = ns_to_timespec(0);\r\ngetrawmonotonic(&queue->lag_time);\r\nspin_lock_init(&queue->lock);\r\n}\r\nvoid vmw_fence_queue_takedown(struct vmw_fence_queue *queue)\r\n{\r\nstruct vmw_fence *fence, *next;\r\nspin_lock(&queue->lock);\r\nlist_for_each_entry_safe(fence, next, &queue->head, head) {\r\nkfree(fence);\r\n}\r\nspin_unlock(&queue->lock);\r\n}\r\nint vmw_fence_push(struct vmw_fence_queue *queue,\r\nuint32_t sequence)\r\n{\r\nstruct vmw_fence *fence = kmalloc(sizeof(*fence), GFP_KERNEL);\r\nif (unlikely(!fence))\r\nreturn -ENOMEM;\r\nfence->sequence = sequence;\r\ngetrawmonotonic(&fence->submitted);\r\nspin_lock(&queue->lock);\r\nlist_add_tail(&fence->head, &queue->head);\r\nspin_unlock(&queue->lock);\r\nreturn 0;\r\n}\r\nint vmw_fence_pull(struct vmw_fence_queue *queue,\r\nuint32_t signaled_sequence)\r\n{\r\nstruct vmw_fence *fence, *next;\r\nstruct timespec now;\r\nbool updated = false;\r\nspin_lock(&queue->lock);\r\ngetrawmonotonic(&now);\r\nif (list_empty(&queue->head)) {\r\nqueue->lag = ns_to_timespec(0);\r\nqueue->lag_time = now;\r\nupdated = true;\r\ngoto out_unlock;\r\n}\r\nlist_for_each_entry_safe(fence, next, &queue->head, head) {\r\nif (signaled_sequence - fence->sequence > (1 << 30))\r\ncontinue;\r\nqueue->lag = timespec_sub(now, fence->submitted);\r\nqueue->lag_time = now;\r\nupdated = true;\r\nlist_del(&fence->head);\r\nkfree(fence);\r\n}\r\nout_unlock:\r\nspin_unlock(&queue->lock);\r\nreturn (updated) ? 0 : -EBUSY;\r\n}\r\nstatic struct timespec vmw_timespec_add(struct timespec t1,\r\nstruct timespec t2)\r\n{\r\nt1.tv_sec += t2.tv_sec;\r\nt1.tv_nsec += t2.tv_nsec;\r\nif (t1.tv_nsec >= 1000000000L) {\r\nt1.tv_sec += 1;\r\nt1.tv_nsec -= 1000000000L;\r\n}\r\nreturn t1;\r\n}\r\nstatic struct timespec vmw_fifo_lag(struct vmw_fence_queue *queue)\r\n{\r\nstruct timespec now;\r\nspin_lock(&queue->lock);\r\ngetrawmonotonic(&now);\r\nqueue->lag = vmw_timespec_add(queue->lag,\r\ntimespec_sub(now, queue->lag_time));\r\nqueue->lag_time = now;\r\nspin_unlock(&queue->lock);\r\nreturn queue->lag;\r\n}\r\nstatic bool vmw_lag_lt(struct vmw_fence_queue *queue,\r\nuint32_t us)\r\n{\r\nstruct timespec lag, cond;\r\ncond = ns_to_timespec((s64) us * 1000);\r\nlag = vmw_fifo_lag(queue);\r\nreturn (timespec_compare(&lag, &cond) < 1);\r\n}\r\nint vmw_wait_lag(struct vmw_private *dev_priv,\r\nstruct vmw_fence_queue *queue, uint32_t us)\r\n{\r\nstruct vmw_fence *fence;\r\nuint32_t sequence;\r\nint ret;\r\nwhile (!vmw_lag_lt(queue, us)) {\r\nspin_lock(&queue->lock);\r\nif (list_empty(&queue->head))\r\nsequence = atomic_read(&dev_priv->fence_seq);\r\nelse {\r\nfence = list_first_entry(&queue->head,\r\nstruct vmw_fence, head);\r\nsequence = fence->sequence;\r\n}\r\nspin_unlock(&queue->lock);\r\nret = vmw_wait_fence(dev_priv, false, sequence, true,\r\n3*HZ);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\n(void) vmw_fence_pull(queue, sequence);\r\n}\r\nreturn 0;\r\n}
