static int __init set_no_mwait(const struct dmi_system_id *id)\r\n{\r\nprintk(KERN_NOTICE PREFIX "%s detected - "\r\n"disabling mwait for CPU C-states\n", id->ident);\r\nboot_option_idle_override = IDLE_NOMWAIT;\r\nreturn 0;\r\n}\r\nstatic int map_lapic_id(struct acpi_subtable_header *entry,\r\nu32 acpi_id, int *apic_id)\r\n{\r\nstruct acpi_madt_local_apic *lapic =\r\n(struct acpi_madt_local_apic *)entry;\r\nif (!(lapic->lapic_flags & ACPI_MADT_ENABLED))\r\nreturn 0;\r\nif (lapic->processor_id != acpi_id)\r\nreturn 0;\r\n*apic_id = lapic->id;\r\nreturn 1;\r\n}\r\nstatic int map_x2apic_id(struct acpi_subtable_header *entry,\r\nint device_declaration, u32 acpi_id, int *apic_id)\r\n{\r\nstruct acpi_madt_local_x2apic *apic =\r\n(struct acpi_madt_local_x2apic *)entry;\r\nif (!(apic->lapic_flags & ACPI_MADT_ENABLED))\r\nreturn 0;\r\nif (device_declaration && (apic->uid == acpi_id)) {\r\n*apic_id = apic->local_apic_id;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int map_lsapic_id(struct acpi_subtable_header *entry,\r\nint device_declaration, u32 acpi_id, int *apic_id)\r\n{\r\nstruct acpi_madt_local_sapic *lsapic =\r\n(struct acpi_madt_local_sapic *)entry;\r\nif (!(lsapic->lapic_flags & ACPI_MADT_ENABLED))\r\nreturn 0;\r\nif (device_declaration) {\r\nif ((entry->length < 16) || (lsapic->uid != acpi_id))\r\nreturn 0;\r\n} else if (lsapic->processor_id != acpi_id)\r\nreturn 0;\r\n*apic_id = (lsapic->id << 8) | lsapic->eid;\r\nreturn 1;\r\n}\r\nstatic int map_madt_entry(int type, u32 acpi_id)\r\n{\r\nunsigned long madt_end, entry;\r\nstatic struct acpi_table_madt *madt;\r\nstatic int read_madt;\r\nint apic_id = -1;\r\nif (!read_madt) {\r\nif (ACPI_FAILURE(acpi_get_table(ACPI_SIG_MADT, 0,\r\n(struct acpi_table_header **)&madt)))\r\nmadt = NULL;\r\nread_madt++;\r\n}\r\nif (!madt)\r\nreturn apic_id;\r\nentry = (unsigned long)madt;\r\nmadt_end = entry + madt->header.length;\r\nentry += sizeof(struct acpi_table_madt);\r\nwhile (entry + sizeof(struct acpi_subtable_header) < madt_end) {\r\nstruct acpi_subtable_header *header =\r\n(struct acpi_subtable_header *)entry;\r\nif (header->type == ACPI_MADT_TYPE_LOCAL_APIC) {\r\nif (map_lapic_id(header, acpi_id, &apic_id))\r\nbreak;\r\n} else if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC) {\r\nif (map_x2apic_id(header, type, acpi_id, &apic_id))\r\nbreak;\r\n} else if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC) {\r\nif (map_lsapic_id(header, type, acpi_id, &apic_id))\r\nbreak;\r\n}\r\nentry += header->length;\r\n}\r\nreturn apic_id;\r\n}\r\nstatic int map_mat_entry(acpi_handle handle, int type, u32 acpi_id)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nstruct acpi_subtable_header *header;\r\nint apic_id = -1;\r\nif (ACPI_FAILURE(acpi_evaluate_object(handle, "_MAT", NULL, &buffer)))\r\ngoto exit;\r\nif (!buffer.length || !buffer.pointer)\r\ngoto exit;\r\nobj = buffer.pointer;\r\nif (obj->type != ACPI_TYPE_BUFFER ||\r\nobj->buffer.length < sizeof(struct acpi_subtable_header)) {\r\ngoto exit;\r\n}\r\nheader = (struct acpi_subtable_header *)obj->buffer.pointer;\r\nif (header->type == ACPI_MADT_TYPE_LOCAL_APIC) {\r\nmap_lapic_id(header, acpi_id, &apic_id);\r\n} else if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC) {\r\nmap_lsapic_id(header, type, acpi_id, &apic_id);\r\n}\r\nexit:\r\nif (buffer.pointer)\r\nkfree(buffer.pointer);\r\nreturn apic_id;\r\n}\r\nint acpi_get_cpuid(acpi_handle handle, int type, u32 acpi_id)\r\n{\r\n#ifdef CONFIG_SMP\r\nint i;\r\n#endif\r\nint apic_id = -1;\r\napic_id = map_mat_entry(handle, type, acpi_id);\r\nif (apic_id == -1)\r\napic_id = map_madt_entry(type, acpi_id);\r\nif (apic_id == -1)\r\nreturn apic_id;\r\n#ifdef CONFIG_SMP\r\nfor_each_possible_cpu(i) {\r\nif (cpu_physical_id(i) == apic_id)\r\nreturn i;\r\n}\r\n#else\r\nif (apic_id == 0)\r\nreturn apic_id;\r\n#endif\r\nreturn -1;\r\n}\r\nstatic bool __init processor_physically_present(acpi_handle handle)\r\n{\r\nint cpuid, type;\r\nu32 acpi_id;\r\nacpi_status status;\r\nacpi_object_type acpi_type;\r\nunsigned long long tmp;\r\nunion acpi_object object = { 0 };\r\nstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\r\nstatus = acpi_get_type(handle, &acpi_type);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nswitch (acpi_type) {\r\ncase ACPI_TYPE_PROCESSOR:\r\nstatus = acpi_evaluate_object(handle, NULL, NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nacpi_id = object.processor.proc_id;\r\nbreak;\r\ncase ACPI_TYPE_DEVICE:\r\nstatus = acpi_evaluate_integer(handle, "_UID", NULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nacpi_id = tmp;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\ntype = (acpi_type == ACPI_TYPE_DEVICE) ? 1 : 0;\r\ncpuid = acpi_get_cpuid(handle, type, acpi_id);\r\nif (cpuid == -1)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void __cpuinit acpi_set_pdc_bits(u32 *buf)\r\n{\r\nbuf[0] = ACPI_PDC_REVISION_ID;\r\nbuf[1] = 1;\r\nbuf[2] = ACPI_PDC_SMP_T_SWCOORD;\r\narch_acpi_set_pdc_bits(buf);\r\n}\r\nstatic struct acpi_object_list *__cpuinit acpi_processor_alloc_pdc(void)\r\n{\r\nstruct acpi_object_list *obj_list;\r\nunion acpi_object *obj;\r\nu32 *buf;\r\nobj_list = kmalloc(sizeof(struct acpi_object_list), GFP_KERNEL);\r\nif (!obj_list) {\r\nprintk(KERN_ERR "Memory allocation error\n");\r\nreturn NULL;\r\n}\r\nobj = kmalloc(sizeof(union acpi_object), GFP_KERNEL);\r\nif (!obj) {\r\nprintk(KERN_ERR "Memory allocation error\n");\r\nkfree(obj_list);\r\nreturn NULL;\r\n}\r\nbuf = kmalloc(12, GFP_KERNEL);\r\nif (!buf) {\r\nprintk(KERN_ERR "Memory allocation error\n");\r\nkfree(obj);\r\nkfree(obj_list);\r\nreturn NULL;\r\n}\r\nacpi_set_pdc_bits(buf);\r\nobj->type = ACPI_TYPE_BUFFER;\r\nobj->buffer.length = 12;\r\nobj->buffer.pointer = (u8 *) buf;\r\nobj_list->count = 1;\r\nobj_list->pointer = obj;\r\nreturn obj_list;\r\n}\r\nstatic int __cpuinit\r\nacpi_processor_eval_pdc(acpi_handle handle, struct acpi_object_list *pdc_in)\r\n{\r\nacpi_status status = AE_OK;\r\nif (boot_option_idle_override == IDLE_NOMWAIT) {\r\nunion acpi_object *obj;\r\nu32 *buffer = NULL;\r\nobj = pdc_in->pointer;\r\nbuffer = (u32 *)(obj->buffer.pointer);\r\nbuffer[2] &= ~(ACPI_PDC_C_C2C3_FFH | ACPI_PDC_C_C1_FFH);\r\n}\r\nstatus = acpi_evaluate_object(handle, "_PDC", pdc_in, NULL);\r\nif (ACPI_FAILURE(status))\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Could not evaluate _PDC, using legacy perf. control.\n"));\r\nreturn status;\r\n}\r\nvoid __cpuinit acpi_processor_set_pdc(acpi_handle handle)\r\n{\r\nstruct acpi_object_list *obj_list;\r\nif (arch_has_acpi_pdc() == false)\r\nreturn;\r\nobj_list = acpi_processor_alloc_pdc();\r\nif (!obj_list)\r\nreturn;\r\nacpi_processor_eval_pdc(handle, obj_list);\r\nkfree(obj_list->pointer->buffer.pointer);\r\nkfree(obj_list->pointer);\r\nkfree(obj_list);\r\n}\r\nstatic acpi_status __init\r\nearly_init_pdc(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nif (processor_physically_present(handle) == false)\r\nreturn AE_OK;\r\nacpi_processor_set_pdc(handle);\r\nreturn AE_OK;\r\n}\r\nvoid __init acpi_early_processor_set_pdc(void)\r\n{\r\ndmi_check_system(processor_idle_dmi_table);\r\nacpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nearly_init_pdc, NULL, NULL, NULL);\r\nacpi_get_devices("ACPI0007", early_init_pdc, NULL, NULL);\r\n}
