static struct ima_iint_cache *__ima_iint_find(struct inode *inode)\r\n{\r\nstruct ima_iint_cache *iint;\r\nstruct rb_node *n = ima_iint_tree.rb_node;\r\nassert_spin_locked(&ima_iint_lock);\r\nwhile (n) {\r\niint = rb_entry(n, struct ima_iint_cache, rb_node);\r\nif (inode < iint->inode)\r\nn = n->rb_left;\r\nelse if (inode > iint->inode)\r\nn = n->rb_right;\r\nelse\r\nbreak;\r\n}\r\nif (!n)\r\nreturn NULL;\r\nreturn iint;\r\n}\r\nstruct ima_iint_cache *ima_iint_find(struct inode *inode)\r\n{\r\nstruct ima_iint_cache *iint;\r\nif (!IS_IMA(inode))\r\nreturn NULL;\r\nspin_lock(&ima_iint_lock);\r\niint = __ima_iint_find(inode);\r\nspin_unlock(&ima_iint_lock);\r\nreturn iint;\r\n}\r\nstatic void iint_free(struct ima_iint_cache *iint)\r\n{\r\niint->version = 0;\r\niint->flags = 0UL;\r\nkmem_cache_free(iint_cache, iint);\r\n}\r\nint ima_inode_alloc(struct inode *inode)\r\n{\r\nstruct rb_node **p;\r\nstruct rb_node *new_node, *parent = NULL;\r\nstruct ima_iint_cache *new_iint, *test_iint;\r\nint rc;\r\nnew_iint = kmem_cache_alloc(iint_cache, GFP_NOFS);\r\nif (!new_iint)\r\nreturn -ENOMEM;\r\nnew_iint->inode = inode;\r\nnew_node = &new_iint->rb_node;\r\nmutex_lock(&inode->i_mutex);\r\nspin_lock(&ima_iint_lock);\r\np = &ima_iint_tree.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\ntest_iint = rb_entry(parent, struct ima_iint_cache, rb_node);\r\nrc = -EEXIST;\r\nif (inode < test_iint->inode)\r\np = &(*p)->rb_left;\r\nelse if (inode > test_iint->inode)\r\np = &(*p)->rb_right;\r\nelse\r\ngoto out_err;\r\n}\r\ninode->i_flags |= S_IMA;\r\nrb_link_node(new_node, parent, p);\r\nrb_insert_color(new_node, &ima_iint_tree);\r\nspin_unlock(&ima_iint_lock);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn 0;\r\nout_err:\r\nspin_unlock(&ima_iint_lock);\r\nmutex_unlock(&inode->i_mutex);\r\niint_free(new_iint);\r\nreturn rc;\r\n}\r\nvoid ima_inode_free(struct inode *inode)\r\n{\r\nstruct ima_iint_cache *iint;\r\nif (!IS_IMA(inode))\r\nreturn;\r\nspin_lock(&ima_iint_lock);\r\niint = __ima_iint_find(inode);\r\nrb_erase(&iint->rb_node, &ima_iint_tree);\r\nspin_unlock(&ima_iint_lock);\r\niint_free(iint);\r\n}\r\nstatic void init_once(void *foo)\r\n{\r\nstruct ima_iint_cache *iint = foo;\r\nmemset(iint, 0, sizeof *iint);\r\niint->version = 0;\r\niint->flags = 0UL;\r\nmutex_init(&iint->mutex);\r\n}\r\nstatic int __init ima_iintcache_init(void)\r\n{\r\niint_cache =\r\nkmem_cache_create("iint_cache", sizeof(struct ima_iint_cache), 0,\r\nSLAB_PANIC, init_once);\r\niint_initialized = 1;\r\nreturn 0;\r\n}
