static void ibmvfc_trc_start(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_cmd *vfc_cmd = &evt->iu.cmd;\r\nstruct ibmvfc_mad_common *mad = &evt->iu.mad_common;\r\nstruct ibmvfc_trace_entry *entry;\r\nentry = &vhost->trace[vhost->trace_index++];\r\nentry->evt = evt;\r\nentry->time = jiffies;\r\nentry->fmt = evt->crq.format;\r\nentry->type = IBMVFC_TRC_START;\r\nswitch (entry->fmt) {\r\ncase IBMVFC_CMD_FORMAT:\r\nentry->op_code = vfc_cmd->iu.cdb[0];\r\nentry->scsi_id = vfc_cmd->tgt_scsi_id;\r\nentry->lun = scsilun_to_int(&vfc_cmd->iu.lun);\r\nentry->tmf_flags = vfc_cmd->iu.tmf_flags;\r\nentry->u.start.xfer_len = vfc_cmd->iu.xfer_len;\r\nbreak;\r\ncase IBMVFC_MAD_FORMAT:\r\nentry->op_code = mad->opcode;\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\n}\r\nstatic void ibmvfc_trc_end(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_cmd *vfc_cmd = &evt->xfer_iu->cmd;\r\nstruct ibmvfc_mad_common *mad = &evt->xfer_iu->mad_common;\r\nstruct ibmvfc_trace_entry *entry = &vhost->trace[vhost->trace_index++];\r\nentry->evt = evt;\r\nentry->time = jiffies;\r\nentry->fmt = evt->crq.format;\r\nentry->type = IBMVFC_TRC_END;\r\nswitch (entry->fmt) {\r\ncase IBMVFC_CMD_FORMAT:\r\nentry->op_code = vfc_cmd->iu.cdb[0];\r\nentry->scsi_id = vfc_cmd->tgt_scsi_id;\r\nentry->lun = scsilun_to_int(&vfc_cmd->iu.lun);\r\nentry->tmf_flags = vfc_cmd->iu.tmf_flags;\r\nentry->u.end.status = vfc_cmd->status;\r\nentry->u.end.error = vfc_cmd->error;\r\nentry->u.end.fcp_rsp_flags = vfc_cmd->rsp.flags;\r\nentry->u.end.rsp_code = vfc_cmd->rsp.data.info.rsp_code;\r\nentry->u.end.scsi_status = vfc_cmd->rsp.scsi_status;\r\nbreak;\r\ncase IBMVFC_MAD_FORMAT:\r\nentry->op_code = mad->opcode;\r\nentry->u.end.status = mad->status;\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\n}\r\nstatic int ibmvfc_get_err_index(u16 status, u16 error)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cmd_status); i++)\r\nif ((cmd_status[i].status & status) == cmd_status[i].status &&\r\ncmd_status[i].error == error)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic const char *ibmvfc_get_cmd_error(u16 status, u16 error)\r\n{\r\nint rc = ibmvfc_get_err_index(status, error);\r\nif (rc >= 0)\r\nreturn cmd_status[rc].name;\r\nreturn unknown_error;\r\n}\r\nstatic int ibmvfc_get_err_result(struct ibmvfc_cmd *vfc_cmd)\r\n{\r\nint err;\r\nstruct ibmvfc_fcp_rsp *rsp = &vfc_cmd->rsp;\r\nint fc_rsp_len = rsp->fcp_rsp_len;\r\nif ((rsp->flags & FCP_RSP_LEN_VALID) &&\r\n((fc_rsp_len && fc_rsp_len != 4 && fc_rsp_len != 8) ||\r\nrsp->data.info.rsp_code))\r\nreturn DID_ERROR << 16;\r\nerr = ibmvfc_get_err_index(vfc_cmd->status, vfc_cmd->error);\r\nif (err >= 0)\r\nreturn rsp->scsi_status | (cmd_status[err].result << 16);\r\nreturn rsp->scsi_status | (DID_ERROR << 16);\r\n}\r\nstatic int ibmvfc_retry_cmd(u16 status, u16 error)\r\n{\r\nint rc = ibmvfc_get_err_index(status, error);\r\nif (rc >= 0)\r\nreturn cmd_status[rc].retry;\r\nreturn 1;\r\n}\r\nstatic const char *ibmvfc_get_ls_explain(u16 status)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ls_explain); i++)\r\nif (ls_explain[i].fc_explain == status)\r\nreturn ls_explain[i].name;\r\nreturn unknown_fc_explain;\r\n}\r\nstatic const char *ibmvfc_get_gs_explain(u16 status)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(gs_explain); i++)\r\nif (gs_explain[i].fc_explain == status)\r\nreturn gs_explain[i].name;\r\nreturn unknown_fc_explain;\r\n}\r\nstatic const char *ibmvfc_get_fc_type(u16 status)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fc_type); i++)\r\nif (fc_type[i].fc_type == status)\r\nreturn fc_type[i].name;\r\nreturn unknown_fc_type;\r\n}\r\nstatic void ibmvfc_set_tgt_action(struct ibmvfc_target *tgt,\r\nenum ibmvfc_target_action action)\r\n{\r\nswitch (tgt->action) {\r\ncase IBMVFC_TGT_ACTION_DEL_RPORT:\r\nif (action == IBMVFC_TGT_ACTION_DELETED_RPORT)\r\ntgt->action = action;\r\ncase IBMVFC_TGT_ACTION_DELETED_RPORT:\r\nbreak;\r\ndefault:\r\nif (action == IBMVFC_TGT_ACTION_DEL_RPORT)\r\ntgt->add_rport = 0;\r\ntgt->action = action;\r\nbreak;\r\n}\r\n}\r\nstatic int ibmvfc_set_host_state(struct ibmvfc_host *vhost,\r\nenum ibmvfc_host_state state)\r\n{\r\nint rc = 0;\r\nswitch (vhost->state) {\r\ncase IBMVFC_HOST_OFFLINE:\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\nvhost->state = state;\r\nbreak;\r\n};\r\nreturn rc;\r\n}\r\nstatic void ibmvfc_set_host_action(struct ibmvfc_host *vhost,\r\nenum ibmvfc_host_action action)\r\n{\r\nswitch (action) {\r\ncase IBMVFC_HOST_ACTION_ALLOC_TGTS:\r\nif (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT)\r\nvhost->action = action;\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_LOGO_WAIT:\r\nif (vhost->action == IBMVFC_HOST_ACTION_LOGO)\r\nvhost->action = action;\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_INIT_WAIT:\r\nif (vhost->action == IBMVFC_HOST_ACTION_INIT)\r\nvhost->action = action;\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_QUERY:\r\nswitch (vhost->action) {\r\ncase IBMVFC_HOST_ACTION_INIT_WAIT:\r\ncase IBMVFC_HOST_ACTION_NONE:\r\ncase IBMVFC_HOST_ACTION_TGT_DEL_FAILED:\r\nvhost->action = action;\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_TGT_INIT:\r\nif (vhost->action == IBMVFC_HOST_ACTION_ALLOC_TGTS)\r\nvhost->action = action;\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_INIT:\r\ncase IBMVFC_HOST_ACTION_TGT_DEL:\r\nswitch (vhost->action) {\r\ncase IBMVFC_HOST_ACTION_RESET:\r\ncase IBMVFC_HOST_ACTION_REENABLE:\r\nbreak;\r\ndefault:\r\nvhost->action = action;\r\nbreak;\r\n};\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_LOGO:\r\ncase IBMVFC_HOST_ACTION_QUERY_TGTS:\r\ncase IBMVFC_HOST_ACTION_TGT_DEL_FAILED:\r\ncase IBMVFC_HOST_ACTION_NONE:\r\ncase IBMVFC_HOST_ACTION_RESET:\r\ncase IBMVFC_HOST_ACTION_REENABLE:\r\ndefault:\r\nvhost->action = action;\r\nbreak;\r\n};\r\n}\r\nstatic void ibmvfc_reinit_host(struct ibmvfc_host *vhost)\r\n{\r\nif (vhost->action == IBMVFC_HOST_ACTION_NONE) {\r\nif (!ibmvfc_set_host_state(vhost, IBMVFC_INITIALIZING)) {\r\nscsi_block_requests(vhost->host);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY);\r\n}\r\n} else\r\nvhost->reinit = 1;\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_link_down(struct ibmvfc_host *vhost,\r\nenum ibmvfc_host_state state)\r\n{\r\nstruct ibmvfc_target *tgt;\r\nENTER;\r\nscsi_block_requests(vhost->host);\r\nlist_for_each_entry(tgt, &vhost->targets, queue)\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nibmvfc_set_host_state(vhost, state);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_TGT_DEL);\r\nvhost->events_to_log |= IBMVFC_AE_LINKDOWN;\r\nwake_up(&vhost->work_wait_q);\r\nLEAVE;\r\n}\r\nstatic void ibmvfc_init_host(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_target *tgt;\r\nif (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT) {\r\nif (++vhost->init_retries > IBMVFC_MAX_HOST_INIT_RETRIES) {\r\ndev_err(vhost->dev,\r\n"Host initialization retries exceeded. Taking adapter offline\n");\r\nibmvfc_link_down(vhost, IBMVFC_HOST_OFFLINE);\r\nreturn;\r\n}\r\n}\r\nif (!ibmvfc_set_host_state(vhost, IBMVFC_INITIALIZING)) {\r\nmemset(vhost->async_crq.msgs, 0, PAGE_SIZE);\r\nvhost->async_crq.cur = 0;\r\nlist_for_each_entry(tgt, &vhost->targets, queue)\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nscsi_block_requests(vhost->host);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT);\r\nvhost->job_step = ibmvfc_npiv_login;\r\nwake_up(&vhost->work_wait_q);\r\n}\r\n}\r\nstatic int ibmvfc_send_crq(struct ibmvfc_host *vhost, u64 word1, u64 word2)\r\n{\r\nstruct vio_dev *vdev = to_vio_dev(vhost->dev);\r\nreturn plpar_hcall_norets(H_SEND_CRQ, vdev->unit_address, word1, word2);\r\n}\r\nstatic int ibmvfc_send_crq_init(struct ibmvfc_host *vhost)\r\n{\r\nibmvfc_dbg(vhost, "Sending CRQ init\n");\r\nreturn ibmvfc_send_crq(vhost, 0xC001000000000000LL, 0);\r\n}\r\nstatic int ibmvfc_send_crq_init_complete(struct ibmvfc_host *vhost)\r\n{\r\nibmvfc_dbg(vhost, "Sending CRQ init complete\n");\r\nreturn ibmvfc_send_crq(vhost, 0xC002000000000000LL, 0);\r\n}\r\nstatic void ibmvfc_release_crq_queue(struct ibmvfc_host *vhost)\r\n{\r\nlong rc = 0;\r\nstruct vio_dev *vdev = to_vio_dev(vhost->dev);\r\nstruct ibmvfc_crq_queue *crq = &vhost->crq;\r\nibmvfc_dbg(vhost, "Releasing CRQ\n");\r\nfree_irq(vdev->irq, vhost);\r\ntasklet_kill(&vhost->tasklet);\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\r\n} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\r\nvhost->state = IBMVFC_NO_CRQ;\r\nvhost->logged_in = 0;\r\ndma_unmap_single(vhost->dev, crq->msg_token, PAGE_SIZE, DMA_BIDIRECTIONAL);\r\nfree_page((unsigned long)crq->msgs);\r\n}\r\nstatic int ibmvfc_reenable_crq_queue(struct ibmvfc_host *vhost)\r\n{\r\nint rc = 0;\r\nstruct vio_dev *vdev = to_vio_dev(vhost->dev);\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_ENABLE_CRQ, vdev->unit_address);\r\n} while (rc == H_IN_PROGRESS || rc == H_BUSY || H_IS_LONG_BUSY(rc));\r\nif (rc)\r\ndev_err(vhost->dev, "Error enabling adapter (rc=%d)\n", rc);\r\nreturn rc;\r\n}\r\nstatic int ibmvfc_reset_crq(struct ibmvfc_host *vhost)\r\n{\r\nint rc = 0;\r\nunsigned long flags;\r\nstruct vio_dev *vdev = to_vio_dev(vhost->dev);\r\nstruct ibmvfc_crq_queue *crq = &vhost->crq;\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\r\n} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nvhost->state = IBMVFC_NO_CRQ;\r\nvhost->logged_in = 0;\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);\r\nmemset(crq->msgs, 0, PAGE_SIZE);\r\ncrq->cur = 0;\r\nrc = plpar_hcall_norets(H_REG_CRQ, vdev->unit_address,\r\ncrq->msg_token, PAGE_SIZE);\r\nif (rc == H_CLOSED)\r\ndev_warn(vhost->dev, "Partner adapter not ready\n");\r\nelse if (rc != 0)\r\ndev_warn(vhost->dev, "Couldn't register crq (rc=%d)\n", rc);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int ibmvfc_valid_event(struct ibmvfc_event_pool *pool,\r\nstruct ibmvfc_event *evt)\r\n{\r\nint index = evt - pool->events;\r\nif (index < 0 || index >= pool->size)\r\nreturn 0;\r\nif (evt != pool->events + index)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void ibmvfc_free_event(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_event_pool *pool = &vhost->pool;\r\nBUG_ON(!ibmvfc_valid_event(pool, evt));\r\nBUG_ON(atomic_inc_return(&evt->free) != 1);\r\nlist_add_tail(&evt->queue, &vhost->free);\r\n}\r\nstatic void ibmvfc_scsi_eh_done(struct ibmvfc_event *evt)\r\n{\r\nstruct scsi_cmnd *cmnd = evt->cmnd;\r\nif (cmnd) {\r\nscsi_dma_unmap(cmnd);\r\ncmnd->scsi_done(cmnd);\r\n}\r\nif (evt->eh_comp)\r\ncomplete(evt->eh_comp);\r\nibmvfc_free_event(evt);\r\n}\r\nstatic void ibmvfc_fail_request(struct ibmvfc_event *evt, int error_code)\r\n{\r\nif (evt->cmnd) {\r\nevt->cmnd->result = (error_code << 16);\r\nevt->done = ibmvfc_scsi_eh_done;\r\n} else\r\nevt->xfer_iu->mad_common.status = IBMVFC_MAD_DRIVER_FAILED;\r\nlist_del(&evt->queue);\r\ndel_timer(&evt->timer);\r\nibmvfc_trc_end(evt);\r\nevt->done(evt);\r\n}\r\nstatic void ibmvfc_purge_requests(struct ibmvfc_host *vhost, int error_code)\r\n{\r\nstruct ibmvfc_event *evt, *pos;\r\nibmvfc_dbg(vhost, "Purging all requests\n");\r\nlist_for_each_entry_safe(evt, pos, &vhost->sent, queue)\r\nibmvfc_fail_request(evt, error_code);\r\n}\r\nstatic void ibmvfc_hard_reset_host(struct ibmvfc_host *vhost)\r\n{\r\nibmvfc_purge_requests(vhost, DID_ERROR);\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_RESET);\r\n}\r\nstatic void __ibmvfc_reset_host(struct ibmvfc_host *vhost)\r\n{\r\nif (vhost->logged_in && vhost->action != IBMVFC_HOST_ACTION_LOGO_WAIT &&\r\n!ibmvfc_set_host_state(vhost, IBMVFC_INITIALIZING)) {\r\nscsi_block_requests(vhost->host);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_LOGO);\r\nvhost->job_step = ibmvfc_npiv_logout;\r\nwake_up(&vhost->work_wait_q);\r\n} else\r\nibmvfc_hard_reset_host(vhost);\r\n}\r\nstatic void ibmvfc_reset_host(struct ibmvfc_host *vhost)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\n__ibmvfc_reset_host(vhost);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\n}\r\nstatic int ibmvfc_retry_host_init(struct ibmvfc_host *vhost)\r\n{\r\nint retry = 0;\r\nif (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT) {\r\nvhost->delay_init = 1;\r\nif (++vhost->init_retries > IBMVFC_MAX_HOST_INIT_RETRIES) {\r\ndev_err(vhost->dev,\r\n"Host initialization retries exceeded. Taking adapter offline\n");\r\nibmvfc_link_down(vhost, IBMVFC_HOST_OFFLINE);\r\n} else if (vhost->init_retries == IBMVFC_MAX_HOST_INIT_RETRIES)\r\n__ibmvfc_reset_host(vhost);\r\nelse {\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT);\r\nretry = 1;\r\n}\r\n}\r\nwake_up(&vhost->work_wait_q);\r\nreturn retry;\r\n}\r\nstatic struct ibmvfc_target *__ibmvfc_get_target(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nstruct ibmvfc_target *tgt;\r\nlist_for_each_entry(tgt, &vhost->targets, queue)\r\nif (tgt->target_id == starget->id) {\r\nkref_get(&tgt->kref);\r\nreturn tgt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ibmvfc_target *ibmvfc_get_target(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ibmvfc_target *tgt;\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\ntgt = __ibmvfc_get_target(starget);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn tgt;\r\n}\r\nstatic void ibmvfc_get_host_speed(struct Scsi_Host *shost)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (vhost->state == IBMVFC_ACTIVE) {\r\nswitch (vhost->login_buf->resp.link_speed / 100) {\r\ncase 1:\r\nfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\r\nbreak;\r\ncase 2:\r\nfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\r\nbreak;\r\ncase 4:\r\nfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\r\nbreak;\r\ncase 8:\r\nfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\r\nbreak;\r\ncase 10:\r\nfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\r\nbreak;\r\ncase 16:\r\nfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\r\nbreak;\r\ndefault:\r\nibmvfc_log(vhost, 3, "Unknown port speed: %lld Gbit\n",\r\nvhost->login_buf->resp.link_speed / 100);\r\nfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\r\nbreak;\r\n}\r\n} else\r\nfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nstatic void ibmvfc_get_host_port_state(struct Scsi_Host *shost)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nswitch (vhost->state) {\r\ncase IBMVFC_INITIALIZING:\r\ncase IBMVFC_ACTIVE:\r\nfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\r\nbreak;\r\ncase IBMVFC_LINK_DOWN:\r\nfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\r\nbreak;\r\ncase IBMVFC_LINK_DEAD:\r\ncase IBMVFC_HOST_OFFLINE:\r\nfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\r\nbreak;\r\ncase IBMVFC_HALTED:\r\nfc_host_port_state(shost) = FC_PORTSTATE_BLOCKED;\r\nbreak;\r\ncase IBMVFC_NO_CRQ:\r\nfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\r\nbreak;\r\ndefault:\r\nibmvfc_log(vhost, 3, "Unknown port state: %d\n", vhost->state);\r\nfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nstatic void ibmvfc_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)\r\n{\r\nif (timeout)\r\nrport->dev_loss_tmo = timeout;\r\nelse\r\nrport->dev_loss_tmo = 1;\r\n}\r\nstatic void ibmvfc_release_tgt(struct kref *kref)\r\n{\r\nstruct ibmvfc_target *tgt = container_of(kref, struct ibmvfc_target, kref);\r\nkfree(tgt);\r\n}\r\nstatic void ibmvfc_get_starget_node_name(struct scsi_target *starget)\r\n{\r\nstruct ibmvfc_target *tgt = ibmvfc_get_target(starget);\r\nfc_starget_port_name(starget) = tgt ? tgt->ids.node_name : 0;\r\nif (tgt)\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n}\r\nstatic void ibmvfc_get_starget_port_name(struct scsi_target *starget)\r\n{\r\nstruct ibmvfc_target *tgt = ibmvfc_get_target(starget);\r\nfc_starget_port_name(starget) = tgt ? tgt->ids.port_name : 0;\r\nif (tgt)\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n}\r\nstatic void ibmvfc_get_starget_port_id(struct scsi_target *starget)\r\n{\r\nstruct ibmvfc_target *tgt = ibmvfc_get_target(starget);\r\nfc_starget_port_id(starget) = tgt ? tgt->scsi_id : -1;\r\nif (tgt)\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n}\r\nstatic int ibmvfc_wait_while_resetting(struct ibmvfc_host *vhost)\r\n{\r\nlong timeout = wait_event_timeout(vhost->init_wait_q,\r\n((vhost->state == IBMVFC_ACTIVE ||\r\nvhost->state == IBMVFC_HOST_OFFLINE ||\r\nvhost->state == IBMVFC_LINK_DEAD) &&\r\nvhost->action == IBMVFC_HOST_ACTION_NONE),\r\n(init_timeout * HZ));\r\nreturn timeout ? 0 : -EIO;\r\n}\r\nstatic int ibmvfc_issue_fc_host_lip(struct Scsi_Host *shost)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\ndev_err(vhost->dev, "Initiating host LIP. Resetting connection\n");\r\nibmvfc_reset_host(vhost);\r\nreturn ibmvfc_wait_while_resetting(vhost);\r\n}\r\nstatic void ibmvfc_gather_partition_info(struct ibmvfc_host *vhost)\r\n{\r\nstruct device_node *rootdn;\r\nconst char *name;\r\nconst unsigned int *num;\r\nrootdn = of_find_node_by_path("/");\r\nif (!rootdn)\r\nreturn;\r\nname = of_get_property(rootdn, "ibm,partition-name", NULL);\r\nif (name)\r\nstrncpy(vhost->partition_name, name, sizeof(vhost->partition_name));\r\nnum = of_get_property(rootdn, "ibm,partition-no", NULL);\r\nif (num)\r\nvhost->partition_number = *num;\r\nof_node_put(rootdn);\r\n}\r\nstatic void ibmvfc_set_login_info(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_npiv_login *login_info = &vhost->login_info;\r\nstruct device_node *of_node = vhost->dev->of_node;\r\nconst char *location;\r\nmemset(login_info, 0, sizeof(*login_info));\r\nlogin_info->ostype = IBMVFC_OS_LINUX;\r\nlogin_info->max_dma_len = IBMVFC_MAX_SECTORS << 9;\r\nlogin_info->max_payload = sizeof(struct ibmvfc_fcp_cmd_iu);\r\nlogin_info->max_response = sizeof(struct ibmvfc_fcp_rsp);\r\nlogin_info->partition_num = vhost->partition_number;\r\nlogin_info->vfc_frame_version = 1;\r\nlogin_info->fcp_version = 3;\r\nlogin_info->flags = IBMVFC_FLUSH_ON_HALT;\r\nif (vhost->client_migrated)\r\nlogin_info->flags |= IBMVFC_CLIENT_MIGRATED;\r\nlogin_info->max_cmds = max_requests + IBMVFC_NUM_INTERNAL_REQ;\r\nlogin_info->capabilities = IBMVFC_CAN_MIGRATE;\r\nlogin_info->async.va = vhost->async_crq.msg_token;\r\nlogin_info->async.len = vhost->async_crq.size * sizeof(*vhost->async_crq.msgs);\r\nstrncpy(login_info->partition_name, vhost->partition_name, IBMVFC_MAX_NAME);\r\nstrncpy(login_info->device_name,\r\ndev_name(&vhost->host->shost_gendev), IBMVFC_MAX_NAME);\r\nlocation = of_get_property(of_node, "ibm,loc-code", NULL);\r\nlocation = location ? location : dev_name(vhost->dev);\r\nstrncpy(login_info->drc_name, location, IBMVFC_MAX_NAME);\r\n}\r\nstatic int ibmvfc_init_event_pool(struct ibmvfc_host *vhost)\r\n{\r\nint i;\r\nstruct ibmvfc_event_pool *pool = &vhost->pool;\r\nENTER;\r\npool->size = max_requests + IBMVFC_NUM_INTERNAL_REQ;\r\npool->events = kcalloc(pool->size, sizeof(*pool->events), GFP_KERNEL);\r\nif (!pool->events)\r\nreturn -ENOMEM;\r\npool->iu_storage = dma_alloc_coherent(vhost->dev,\r\npool->size * sizeof(*pool->iu_storage),\r\n&pool->iu_token, 0);\r\nif (!pool->iu_storage) {\r\nkfree(pool->events);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < pool->size; ++i) {\r\nstruct ibmvfc_event *evt = &pool->events[i];\r\natomic_set(&evt->free, 1);\r\nevt->crq.valid = 0x80;\r\nevt->crq.ioba = pool->iu_token + (sizeof(*evt->xfer_iu) * i);\r\nevt->xfer_iu = pool->iu_storage + i;\r\nevt->vhost = vhost;\r\nevt->ext_list = NULL;\r\nlist_add_tail(&evt->queue, &vhost->free);\r\n}\r\nLEAVE;\r\nreturn 0;\r\n}\r\nstatic void ibmvfc_free_event_pool(struct ibmvfc_host *vhost)\r\n{\r\nint i;\r\nstruct ibmvfc_event_pool *pool = &vhost->pool;\r\nENTER;\r\nfor (i = 0; i < pool->size; ++i) {\r\nlist_del(&pool->events[i].queue);\r\nBUG_ON(atomic_read(&pool->events[i].free) != 1);\r\nif (pool->events[i].ext_list)\r\ndma_pool_free(vhost->sg_pool,\r\npool->events[i].ext_list,\r\npool->events[i].ext_list_token);\r\n}\r\nkfree(pool->events);\r\ndma_free_coherent(vhost->dev,\r\npool->size * sizeof(*pool->iu_storage),\r\npool->iu_storage, pool->iu_token);\r\nLEAVE;\r\n}\r\nstatic struct ibmvfc_event *ibmvfc_get_event(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_event *evt;\r\nBUG_ON(list_empty(&vhost->free));\r\nevt = list_entry(vhost->free.next, struct ibmvfc_event, queue);\r\natomic_set(&evt->free, 0);\r\nlist_del(&evt->queue);\r\nreturn evt;\r\n}\r\nstatic void ibmvfc_init_event(struct ibmvfc_event *evt,\r\nvoid (*done) (struct ibmvfc_event *), u8 format)\r\n{\r\nevt->cmnd = NULL;\r\nevt->sync_iu = NULL;\r\nevt->crq.format = format;\r\nevt->done = done;\r\nevt->eh_comp = NULL;\r\n}\r\nstatic void ibmvfc_map_sg_list(struct scsi_cmnd *scmd, int nseg,\r\nstruct srp_direct_buf *md)\r\n{\r\nint i;\r\nstruct scatterlist *sg;\r\nscsi_for_each_sg(scmd, sg, nseg, i) {\r\nmd[i].va = sg_dma_address(sg);\r\nmd[i].len = sg_dma_len(sg);\r\nmd[i].key = 0;\r\n}\r\n}\r\nstatic int ibmvfc_map_sg_data(struct scsi_cmnd *scmd,\r\nstruct ibmvfc_event *evt,\r\nstruct ibmvfc_cmd *vfc_cmd, struct device *dev)\r\n{\r\nint sg_mapped;\r\nstruct srp_direct_buf *data = &vfc_cmd->ioba;\r\nstruct ibmvfc_host *vhost = dev_get_drvdata(dev);\r\nsg_mapped = scsi_dma_map(scmd);\r\nif (!sg_mapped) {\r\nvfc_cmd->flags |= IBMVFC_NO_MEM_DESC;\r\nreturn 0;\r\n} else if (unlikely(sg_mapped < 0)) {\r\nif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\r\nscmd_printk(KERN_ERR, scmd, "Failed to map DMA buffer for command\n");\r\nreturn sg_mapped;\r\n}\r\nif (scmd->sc_data_direction == DMA_TO_DEVICE) {\r\nvfc_cmd->flags |= IBMVFC_WRITE;\r\nvfc_cmd->iu.add_cdb_len |= IBMVFC_WRDATA;\r\n} else {\r\nvfc_cmd->flags |= IBMVFC_READ;\r\nvfc_cmd->iu.add_cdb_len |= IBMVFC_RDDATA;\r\n}\r\nif (sg_mapped == 1) {\r\nibmvfc_map_sg_list(scmd, sg_mapped, data);\r\nreturn 0;\r\n}\r\nvfc_cmd->flags |= IBMVFC_SCATTERLIST;\r\nif (!evt->ext_list) {\r\nevt->ext_list = dma_pool_alloc(vhost->sg_pool, GFP_ATOMIC,\r\n&evt->ext_list_token);\r\nif (!evt->ext_list) {\r\nscsi_dma_unmap(scmd);\r\nif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\r\nscmd_printk(KERN_ERR, scmd, "Can't allocate memory for scatterlist\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nibmvfc_map_sg_list(scmd, sg_mapped, evt->ext_list);\r\ndata->va = evt->ext_list_token;\r\ndata->len = sg_mapped * sizeof(struct srp_direct_buf);\r\ndata->key = 0;\r\nreturn 0;\r\n}\r\nstatic void ibmvfc_timeout(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\ndev_err(vhost->dev, "Command timed out (%p). Resetting connection\n", evt);\r\nibmvfc_reset_host(vhost);\r\n}\r\nstatic int ibmvfc_send_event(struct ibmvfc_event *evt,\r\nstruct ibmvfc_host *vhost, unsigned long timeout)\r\n{\r\nu64 *crq_as_u64 = (u64 *) &evt->crq;\r\nint rc;\r\n*evt->xfer_iu = evt->iu;\r\nif (evt->crq.format == IBMVFC_CMD_FORMAT)\r\nevt->xfer_iu->cmd.tag = (u64)evt;\r\nelse if (evt->crq.format == IBMVFC_MAD_FORMAT)\r\nevt->xfer_iu->mad_common.tag = (u64)evt;\r\nelse\r\nBUG();\r\nlist_add_tail(&evt->queue, &vhost->sent);\r\ninit_timer(&evt->timer);\r\nif (timeout) {\r\nevt->timer.data = (unsigned long) evt;\r\nevt->timer.expires = jiffies + (timeout * HZ);\r\nevt->timer.function = (void (*)(unsigned long))ibmvfc_timeout;\r\nadd_timer(&evt->timer);\r\n}\r\nmb();\r\nif ((rc = ibmvfc_send_crq(vhost, crq_as_u64[0], crq_as_u64[1]))) {\r\nlist_del(&evt->queue);\r\ndel_timer(&evt->timer);\r\nif (rc == H_CLOSED) {\r\nif (printk_ratelimit())\r\ndev_warn(vhost->dev, "Send warning. Receive queue closed, will retry.\n");\r\nif (evt->cmnd)\r\nscsi_dma_unmap(evt->cmnd);\r\nibmvfc_free_event(evt);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\ndev_err(vhost->dev, "Send error (rc=%d)\n", rc);\r\nif (evt->cmnd) {\r\nevt->cmnd->result = DID_ERROR << 16;\r\nevt->done = ibmvfc_scsi_eh_done;\r\n} else\r\nevt->xfer_iu->mad_common.status = IBMVFC_MAD_CRQ_ERROR;\r\nevt->done(evt);\r\n} else\r\nibmvfc_trc_start(evt);\r\nreturn 0;\r\n}\r\nstatic void ibmvfc_log_error(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_cmd *vfc_cmd = &evt->xfer_iu->cmd;\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_fcp_rsp *rsp = &vfc_cmd->rsp;\r\nstruct scsi_cmnd *cmnd = evt->cmnd;\r\nconst char *err = unknown_error;\r\nint index = ibmvfc_get_err_index(vfc_cmd->status, vfc_cmd->error);\r\nint logerr = 0;\r\nint rsp_code = 0;\r\nif (index >= 0) {\r\nlogerr = cmd_status[index].log;\r\nerr = cmd_status[index].name;\r\n}\r\nif (!logerr && (vhost->log_level <= (IBMVFC_DEFAULT_LOG_LEVEL + 1)))\r\nreturn;\r\nif (rsp->flags & FCP_RSP_LEN_VALID)\r\nrsp_code = rsp->data.info.rsp_code;\r\nscmd_printk(KERN_ERR, cmnd, "Command (%02X) failed: %s (%x:%x) "\r\n"flags: %x fcp_rsp: %x, resid=%d, scsi_status: %x\n",\r\ncmnd->cmnd[0], err, vfc_cmd->status, vfc_cmd->error,\r\nrsp->flags, rsp_code, scsi_get_resid(cmnd), rsp->scsi_status);\r\n}\r\nstatic void ibmvfc_relogin(struct scsi_device *sdev)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(sdev->host);\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nstruct ibmvfc_target *tgt;\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (rport == tgt->rport) {\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nbreak;\r\n}\r\n}\r\nibmvfc_reinit_host(vhost);\r\n}\r\nstatic void ibmvfc_scsi_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_cmd *vfc_cmd = &evt->xfer_iu->cmd;\r\nstruct ibmvfc_fcp_rsp *rsp = &vfc_cmd->rsp;\r\nstruct scsi_cmnd *cmnd = evt->cmnd;\r\nu32 rsp_len = 0;\r\nu32 sense_len = rsp->fcp_sense_len;\r\nif (cmnd) {\r\nif (vfc_cmd->response_flags & IBMVFC_ADAPTER_RESID_VALID)\r\nscsi_set_resid(cmnd, vfc_cmd->adapter_resid);\r\nelse if (rsp->flags & FCP_RESID_UNDER)\r\nscsi_set_resid(cmnd, rsp->fcp_resid);\r\nelse\r\nscsi_set_resid(cmnd, 0);\r\nif (vfc_cmd->status) {\r\ncmnd->result = ibmvfc_get_err_result(vfc_cmd);\r\nif (rsp->flags & FCP_RSP_LEN_VALID)\r\nrsp_len = rsp->fcp_rsp_len;\r\nif ((sense_len + rsp_len) > SCSI_SENSE_BUFFERSIZE)\r\nsense_len = SCSI_SENSE_BUFFERSIZE - rsp_len;\r\nif ((rsp->flags & FCP_SNS_LEN_VALID) && rsp->fcp_sense_len && rsp_len <= 8)\r\nmemcpy(cmnd->sense_buffer, rsp->data.sense + rsp_len, sense_len);\r\nif ((vfc_cmd->status & IBMVFC_VIOS_FAILURE) && (vfc_cmd->error == IBMVFC_PLOGI_REQUIRED))\r\nibmvfc_relogin(cmnd->device);\r\nif (!cmnd->result && (!scsi_get_resid(cmnd) || (rsp->flags & FCP_RESID_OVER)))\r\ncmnd->result = (DID_ERROR << 16);\r\nibmvfc_log_error(evt);\r\n}\r\nif (!cmnd->result &&\r\n(scsi_bufflen(cmnd) - scsi_get_resid(cmnd) < cmnd->underflow))\r\ncmnd->result = (DID_ERROR << 16);\r\nscsi_dma_unmap(cmnd);\r\ncmnd->scsi_done(cmnd);\r\n}\r\nif (evt->eh_comp)\r\ncomplete(evt->eh_comp);\r\nibmvfc_free_event(evt);\r\n}\r\nstatic inline int ibmvfc_host_chkready(struct ibmvfc_host *vhost)\r\n{\r\nint result = 0;\r\nswitch (vhost->state) {\r\ncase IBMVFC_LINK_DEAD:\r\ncase IBMVFC_HOST_OFFLINE:\r\nresult = DID_NO_CONNECT << 16;\r\nbreak;\r\ncase IBMVFC_NO_CRQ:\r\ncase IBMVFC_INITIALIZING:\r\ncase IBMVFC_HALTED:\r\ncase IBMVFC_LINK_DOWN:\r\nresult = DID_REQUEUE << 16;\r\nbreak;\r\ncase IBMVFC_ACTIVE:\r\nresult = 0;\r\nbreak;\r\n};\r\nreturn result;\r\n}\r\nstatic int ibmvfc_queuecommand_lck(struct scsi_cmnd *cmnd,\r\nvoid (*done) (struct scsi_cmnd *))\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(cmnd->device->host);\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\r\nstruct ibmvfc_cmd *vfc_cmd;\r\nstruct ibmvfc_event *evt;\r\nu8 tag[2];\r\nint rc;\r\nif (unlikely((rc = fc_remote_port_chkready(rport))) ||\r\nunlikely((rc = ibmvfc_host_chkready(vhost)))) {\r\ncmnd->result = rc;\r\ndone(cmnd);\r\nreturn 0;\r\n}\r\ncmnd->result = (DID_OK << 16);\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_scsi_done, IBMVFC_CMD_FORMAT);\r\nevt->cmnd = cmnd;\r\ncmnd->scsi_done = done;\r\nvfc_cmd = &evt->iu.cmd;\r\nmemset(vfc_cmd, 0, sizeof(*vfc_cmd));\r\nvfc_cmd->resp.va = (u64)evt->crq.ioba + offsetof(struct ibmvfc_cmd, rsp);\r\nvfc_cmd->resp.len = sizeof(vfc_cmd->rsp);\r\nvfc_cmd->frame_type = IBMVFC_SCSI_FCP_TYPE;\r\nvfc_cmd->payload_len = sizeof(vfc_cmd->iu);\r\nvfc_cmd->resp_len = sizeof(vfc_cmd->rsp);\r\nvfc_cmd->cancel_key = (unsigned long)cmnd->device->hostdata;\r\nvfc_cmd->tgt_scsi_id = rport->port_id;\r\nvfc_cmd->iu.xfer_len = scsi_bufflen(cmnd);\r\nint_to_scsilun(cmnd->device->lun, &vfc_cmd->iu.lun);\r\nmemcpy(vfc_cmd->iu.cdb, cmnd->cmnd, cmnd->cmd_len);\r\nif (scsi_populate_tag_msg(cmnd, tag)) {\r\nvfc_cmd->task_tag = tag[1];\r\nswitch (tag[0]) {\r\ncase MSG_SIMPLE_TAG:\r\nvfc_cmd->iu.pri_task_attr = IBMVFC_SIMPLE_TASK;\r\nbreak;\r\ncase MSG_HEAD_TAG:\r\nvfc_cmd->iu.pri_task_attr = IBMVFC_HEAD_OF_QUEUE;\r\nbreak;\r\ncase MSG_ORDERED_TAG:\r\nvfc_cmd->iu.pri_task_attr = IBMVFC_ORDERED_TASK;\r\nbreak;\r\n};\r\n}\r\nif (likely(!(rc = ibmvfc_map_sg_data(cmnd, evt, vfc_cmd, vhost->dev))))\r\nreturn ibmvfc_send_event(evt, vhost, 0);\r\nibmvfc_free_event(evt);\r\nif (rc == -ENOMEM)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\r\nscmd_printk(KERN_ERR, cmnd,\r\n"Failed to map DMA buffer for command. rc=%d\n", rc);\r\ncmnd->result = DID_ERROR << 16;\r\ndone(cmnd);\r\nreturn 0;\r\n}\r\nvoid ibmvfc_bsg_timeout_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nibmvfc_free_event(evt);\r\nvhost->aborting_passthru = 0;\r\ndev_info(vhost->dev, "Passthru command cancelled\n");\r\n}\r\nstatic int ibmvfc_bsg_timeout(struct fc_bsg_job *job)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(job->shost);\r\nunsigned long port_id = (unsigned long)job->dd_data;\r\nstruct ibmvfc_event *evt;\r\nstruct ibmvfc_tmf *tmf;\r\nunsigned long flags;\r\nint rc;\r\nENTER;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nif (vhost->aborting_passthru || vhost->state != IBMVFC_ACTIVE) {\r\n__ibmvfc_reset_host(vhost);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn 0;\r\n}\r\nvhost->aborting_passthru = 1;\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_bsg_timeout_done, IBMVFC_MAD_FORMAT);\r\ntmf = &evt->iu.tmf;\r\nmemset(tmf, 0, sizeof(*tmf));\r\ntmf->common.version = 1;\r\ntmf->common.opcode = IBMVFC_TMF_MAD;\r\ntmf->common.length = sizeof(*tmf);\r\ntmf->scsi_id = port_id;\r\ntmf->cancel_key = IBMVFC_PASSTHRU_CANCEL_KEY;\r\ntmf->my_cancel_key = IBMVFC_INTERNAL_CANCEL_KEY;\r\nrc = ibmvfc_send_event(evt, vhost, default_timeout);\r\nif (rc != 0) {\r\nvhost->aborting_passthru = 0;\r\ndev_err(vhost->dev, "Failed to send cancel event. rc=%d\n", rc);\r\nrc = -EIO;\r\n} else\r\ndev_info(vhost->dev, "Cancelling passthru command to port id 0x%lx\n",\r\nport_id);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nLEAVE;\r\nreturn rc;\r\n}\r\nstatic int ibmvfc_bsg_plogi(struct ibmvfc_host *vhost, unsigned int port_id)\r\n{\r\nstruct ibmvfc_port_login *plogi;\r\nstruct ibmvfc_target *tgt;\r\nstruct ibmvfc_event *evt;\r\nunion ibmvfc_iu rsp_iu;\r\nunsigned long flags;\r\nint rc = 0, issue_login = 1;\r\nENTER;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (tgt->scsi_id == port_id) {\r\nissue_login = 0;\r\nbreak;\r\n}\r\n}\r\nif (!issue_login)\r\ngoto unlock_out;\r\nif (unlikely((rc = ibmvfc_host_chkready(vhost))))\r\ngoto unlock_out;\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);\r\nplogi = &evt->iu.plogi;\r\nmemset(plogi, 0, sizeof(*plogi));\r\nplogi->common.version = 1;\r\nplogi->common.opcode = IBMVFC_PORT_LOGIN;\r\nplogi->common.length = sizeof(*plogi);\r\nplogi->scsi_id = port_id;\r\nevt->sync_iu = &rsp_iu;\r\ninit_completion(&evt->comp);\r\nrc = ibmvfc_send_event(evt, vhost, default_timeout);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (rc)\r\nreturn -EIO;\r\nwait_for_completion(&evt->comp);\r\nif (rsp_iu.plogi.common.status)\r\nrc = -EIO;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nibmvfc_free_event(evt);\r\nunlock_out:\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nLEAVE;\r\nreturn rc;\r\n}\r\nstatic int ibmvfc_bsg_request(struct fc_bsg_job *job)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(job->shost);\r\nstruct fc_rport *rport = job->rport;\r\nstruct ibmvfc_passthru_mad *mad;\r\nstruct ibmvfc_event *evt;\r\nunion ibmvfc_iu rsp_iu;\r\nunsigned long flags, port_id = -1;\r\nunsigned int code = job->request->msgcode;\r\nint rc = 0, req_seg, rsp_seg, issue_login = 0;\r\nu32 fc_flags, rsp_len;\r\nENTER;\r\njob->reply->reply_payload_rcv_len = 0;\r\nif (rport)\r\nport_id = rport->port_id;\r\nswitch (code) {\r\ncase FC_BSG_HST_ELS_NOLOGIN:\r\nport_id = (job->request->rqst_data.h_els.port_id[0] << 16) |\r\n(job->request->rqst_data.h_els.port_id[1] << 8) |\r\njob->request->rqst_data.h_els.port_id[2];\r\ncase FC_BSG_RPT_ELS:\r\nfc_flags = IBMVFC_FC_ELS;\r\nbreak;\r\ncase FC_BSG_HST_CT:\r\nissue_login = 1;\r\nport_id = (job->request->rqst_data.h_ct.port_id[0] << 16) |\r\n(job->request->rqst_data.h_ct.port_id[1] << 8) |\r\njob->request->rqst_data.h_ct.port_id[2];\r\ncase FC_BSG_RPT_CT:\r\nfc_flags = IBMVFC_FC_CT_IU;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n};\r\nif (port_id == -1)\r\nreturn -EINVAL;\r\nif (!mutex_trylock(&vhost->passthru_mutex))\r\nreturn -EBUSY;\r\njob->dd_data = (void *)port_id;\r\nreq_seg = dma_map_sg(vhost->dev, job->request_payload.sg_list,\r\njob->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nif (!req_seg) {\r\nmutex_unlock(&vhost->passthru_mutex);\r\nreturn -ENOMEM;\r\n}\r\nrsp_seg = dma_map_sg(vhost->dev, job->reply_payload.sg_list,\r\njob->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\nif (!rsp_seg) {\r\ndma_unmap_sg(vhost->dev, job->request_payload.sg_list,\r\njob->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nmutex_unlock(&vhost->passthru_mutex);\r\nreturn -ENOMEM;\r\n}\r\nif (req_seg > 1 || rsp_seg > 1) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (issue_login)\r\nrc = ibmvfc_bsg_plogi(vhost, port_id);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nif (unlikely(rc || (rport && (rc = fc_remote_port_chkready(rport)))) ||\r\nunlikely((rc = ibmvfc_host_chkready(vhost)))) {\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\ngoto out;\r\n}\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);\r\nmad = &evt->iu.passthru;\r\nmemset(mad, 0, sizeof(*mad));\r\nmad->common.version = 1;\r\nmad->common.opcode = IBMVFC_PASSTHRU;\r\nmad->common.length = sizeof(*mad) - sizeof(mad->fc_iu) - sizeof(mad->iu);\r\nmad->cmd_ioba.va = (u64)evt->crq.ioba +\r\noffsetof(struct ibmvfc_passthru_mad, iu);\r\nmad->cmd_ioba.len = sizeof(mad->iu);\r\nmad->iu.cmd_len = job->request_payload.payload_len;\r\nmad->iu.rsp_len = job->reply_payload.payload_len;\r\nmad->iu.flags = fc_flags;\r\nmad->iu.cancel_key = IBMVFC_PASSTHRU_CANCEL_KEY;\r\nmad->iu.cmd.va = sg_dma_address(job->request_payload.sg_list);\r\nmad->iu.cmd.len = sg_dma_len(job->request_payload.sg_list);\r\nmad->iu.rsp.va = sg_dma_address(job->reply_payload.sg_list);\r\nmad->iu.rsp.len = sg_dma_len(job->reply_payload.sg_list);\r\nmad->iu.scsi_id = port_id;\r\nmad->iu.tag = (u64)evt;\r\nrsp_len = mad->iu.rsp.len;\r\nevt->sync_iu = &rsp_iu;\r\ninit_completion(&evt->comp);\r\nrc = ibmvfc_send_event(evt, vhost, 0);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (rc) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nwait_for_completion(&evt->comp);\r\nif (rsp_iu.passthru.common.status)\r\nrc = -EIO;\r\nelse\r\njob->reply->reply_payload_rcv_len = rsp_len;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nibmvfc_free_event(evt);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\njob->reply->result = rc;\r\njob->job_done(job);\r\nrc = 0;\r\nout:\r\ndma_unmap_sg(vhost->dev, job->request_payload.sg_list,\r\njob->request_payload.sg_cnt, DMA_TO_DEVICE);\r\ndma_unmap_sg(vhost->dev, job->reply_payload.sg_list,\r\njob->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\nmutex_unlock(&vhost->passthru_mutex);\r\nLEAVE;\r\nreturn rc;\r\n}\r\nstatic int ibmvfc_reset_device(struct scsi_device *sdev, int type, char *desc)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(sdev->host);\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nstruct ibmvfc_cmd *tmf;\r\nstruct ibmvfc_event *evt = NULL;\r\nunion ibmvfc_iu rsp_iu;\r\nstruct ibmvfc_fcp_rsp *fc_rsp = &rsp_iu.cmd.rsp;\r\nint rsp_rc = -EBUSY;\r\nunsigned long flags;\r\nint rsp_code = 0;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nif (vhost->state == IBMVFC_ACTIVE) {\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_CMD_FORMAT);\r\ntmf = &evt->iu.cmd;\r\nmemset(tmf, 0, sizeof(*tmf));\r\ntmf->resp.va = (u64)evt->crq.ioba + offsetof(struct ibmvfc_cmd, rsp);\r\ntmf->resp.len = sizeof(tmf->rsp);\r\ntmf->frame_type = IBMVFC_SCSI_FCP_TYPE;\r\ntmf->payload_len = sizeof(tmf->iu);\r\ntmf->resp_len = sizeof(tmf->rsp);\r\ntmf->cancel_key = (unsigned long)sdev->hostdata;\r\ntmf->tgt_scsi_id = rport->port_id;\r\nint_to_scsilun(sdev->lun, &tmf->iu.lun);\r\ntmf->flags = (IBMVFC_NO_MEM_DESC | IBMVFC_TMF);\r\ntmf->iu.tmf_flags = type;\r\nevt->sync_iu = &rsp_iu;\r\ninit_completion(&evt->comp);\r\nrsp_rc = ibmvfc_send_event(evt, vhost, default_timeout);\r\n}\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (rsp_rc != 0) {\r\nsdev_printk(KERN_ERR, sdev, "Failed to send %s reset event. rc=%d\n",\r\ndesc, rsp_rc);\r\nreturn -EIO;\r\n}\r\nsdev_printk(KERN_INFO, sdev, "Resetting %s\n", desc);\r\nwait_for_completion(&evt->comp);\r\nif (rsp_iu.cmd.status)\r\nrsp_code = ibmvfc_get_err_result(&rsp_iu.cmd);\r\nif (rsp_code) {\r\nif (fc_rsp->flags & FCP_RSP_LEN_VALID)\r\nrsp_code = fc_rsp->data.info.rsp_code;\r\nsdev_printk(KERN_ERR, sdev, "%s reset failed: %s (%x:%x) "\r\n"flags: %x fcp_rsp: %x, scsi_status: %x\n",\r\ndesc, ibmvfc_get_cmd_error(rsp_iu.cmd.status, rsp_iu.cmd.error),\r\nrsp_iu.cmd.status, rsp_iu.cmd.error, fc_rsp->flags, rsp_code,\r\nfc_rsp->scsi_status);\r\nrsp_rc = -EIO;\r\n} else\r\nsdev_printk(KERN_INFO, sdev, "%s reset successful\n", desc);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nibmvfc_free_event(evt);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn rsp_rc;\r\n}\r\nstatic int ibmvfc_match_rport(struct ibmvfc_event *evt, void *rport)\r\n{\r\nstruct fc_rport *cmd_rport;\r\nif (evt->cmnd) {\r\ncmd_rport = starget_to_rport(scsi_target(evt->cmnd->device));\r\nif (cmd_rport == rport)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_match_target(struct ibmvfc_event *evt, void *device)\r\n{\r\nif (evt->cmnd && scsi_target(evt->cmnd->device) == device)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_match_lun(struct ibmvfc_event *evt, void *device)\r\n{\r\nif (evt->cmnd && evt->cmnd->device == device)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_wait_for_ops(struct ibmvfc_host *vhost, void *device,\r\nint (*match) (struct ibmvfc_event *, void *))\r\n{\r\nstruct ibmvfc_event *evt;\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nint wait;\r\nunsigned long flags;\r\nsigned long timeout = IBMVFC_ABORT_WAIT_TIMEOUT * HZ;\r\nENTER;\r\ndo {\r\nwait = 0;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nlist_for_each_entry(evt, &vhost->sent, queue) {\r\nif (match(evt, device)) {\r\nevt->eh_comp = &comp;\r\nwait++;\r\n}\r\n}\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (wait) {\r\ntimeout = wait_for_completion_timeout(&comp, timeout);\r\nif (!timeout) {\r\nwait = 0;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nlist_for_each_entry(evt, &vhost->sent, queue) {\r\nif (match(evt, device)) {\r\nevt->eh_comp = NULL;\r\nwait++;\r\n}\r\n}\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (wait)\r\ndev_err(vhost->dev, "Timed out waiting for aborted commands\n");\r\nLEAVE;\r\nreturn wait ? FAILED : SUCCESS;\r\n}\r\n}\r\n} while (wait);\r\nLEAVE;\r\nreturn SUCCESS;\r\n}\r\nstatic int ibmvfc_cancel_all(struct scsi_device *sdev, int type)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(sdev->host);\r\nstruct scsi_target *starget = scsi_target(sdev);\r\nstruct fc_rport *rport = starget_to_rport(starget);\r\nstruct ibmvfc_tmf *tmf;\r\nstruct ibmvfc_event *evt, *found_evt;\r\nunion ibmvfc_iu rsp;\r\nint rsp_rc = -EBUSY;\r\nunsigned long flags;\r\nu16 status;\r\nENTER;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nfound_evt = NULL;\r\nlist_for_each_entry(evt, &vhost->sent, queue) {\r\nif (evt->cmnd && evt->cmnd->device == sdev) {\r\nfound_evt = evt;\r\nbreak;\r\n}\r\n}\r\nif (!found_evt) {\r\nif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\r\nsdev_printk(KERN_INFO, sdev, "No events found to cancel\n");\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn 0;\r\n}\r\nif (vhost->state == IBMVFC_ACTIVE) {\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);\r\ntmf = &evt->iu.tmf;\r\nmemset(tmf, 0, sizeof(*tmf));\r\ntmf->common.version = 1;\r\ntmf->common.opcode = IBMVFC_TMF_MAD;\r\ntmf->common.length = sizeof(*tmf);\r\ntmf->scsi_id = rport->port_id;\r\nint_to_scsilun(sdev->lun, &tmf->lun);\r\ntmf->flags = (type | IBMVFC_TMF_LUA_VALID);\r\ntmf->cancel_key = (unsigned long)sdev->hostdata;\r\ntmf->my_cancel_key = (unsigned long)starget->hostdata;\r\nevt->sync_iu = &rsp;\r\ninit_completion(&evt->comp);\r\nrsp_rc = ibmvfc_send_event(evt, vhost, default_timeout);\r\n}\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (rsp_rc != 0) {\r\nsdev_printk(KERN_ERR, sdev, "Failed to send cancel event. rc=%d\n", rsp_rc);\r\nreturn -EIO;\r\n}\r\nsdev_printk(KERN_INFO, sdev, "Cancelling outstanding commands.\n");\r\nwait_for_completion(&evt->comp);\r\nstatus = rsp.mad_common.status;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nibmvfc_free_event(evt);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (status != IBMVFC_MAD_SUCCESS) {\r\nsdev_printk(KERN_WARNING, sdev, "Cancel failed with rc=%x\n", status);\r\nreturn -EIO;\r\n}\r\nsdev_printk(KERN_INFO, sdev, "Successfully cancelled outstanding commands\n");\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_match_key(struct ibmvfc_event *evt, void *key)\r\n{\r\nunsigned long cancel_key = (unsigned long)key;\r\nif (evt->crq.format == IBMVFC_CMD_FORMAT &&\r\nevt->iu.cmd.cancel_key == cancel_key)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_abort_task_set(struct scsi_device *sdev)\r\n{\r\nstruct ibmvfc_host *vhost = shost_priv(sdev->host);\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nstruct ibmvfc_cmd *tmf;\r\nstruct ibmvfc_event *evt, *found_evt;\r\nunion ibmvfc_iu rsp_iu;\r\nstruct ibmvfc_fcp_rsp *fc_rsp = &rsp_iu.cmd.rsp;\r\nint rc, rsp_rc = -EBUSY;\r\nunsigned long flags, timeout = IBMVFC_ABORT_TIMEOUT;\r\nint rsp_code = 0;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nfound_evt = NULL;\r\nlist_for_each_entry(evt, &vhost->sent, queue) {\r\nif (evt->cmnd && evt->cmnd->device == sdev) {\r\nfound_evt = evt;\r\nbreak;\r\n}\r\n}\r\nif (!found_evt) {\r\nif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\r\nsdev_printk(KERN_INFO, sdev, "No events found to abort\n");\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn 0;\r\n}\r\nif (vhost->state == IBMVFC_ACTIVE) {\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_CMD_FORMAT);\r\ntmf = &evt->iu.cmd;\r\nmemset(tmf, 0, sizeof(*tmf));\r\ntmf->resp.va = (u64)evt->crq.ioba + offsetof(struct ibmvfc_cmd, rsp);\r\ntmf->resp.len = sizeof(tmf->rsp);\r\ntmf->frame_type = IBMVFC_SCSI_FCP_TYPE;\r\ntmf->payload_len = sizeof(tmf->iu);\r\ntmf->resp_len = sizeof(tmf->rsp);\r\ntmf->cancel_key = (unsigned long)sdev->hostdata;\r\ntmf->tgt_scsi_id = rport->port_id;\r\nint_to_scsilun(sdev->lun, &tmf->iu.lun);\r\ntmf->flags = (IBMVFC_NO_MEM_DESC | IBMVFC_TMF);\r\ntmf->iu.tmf_flags = IBMVFC_ABORT_TASK_SET;\r\nevt->sync_iu = &rsp_iu;\r\ninit_completion(&evt->comp);\r\nrsp_rc = ibmvfc_send_event(evt, vhost, default_timeout);\r\n}\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (rsp_rc != 0) {\r\nsdev_printk(KERN_ERR, sdev, "Failed to send abort. rc=%d\n", rsp_rc);\r\nreturn -EIO;\r\n}\r\nsdev_printk(KERN_INFO, sdev, "Aborting outstanding commands\n");\r\ntimeout = wait_for_completion_timeout(&evt->comp, timeout);\r\nif (!timeout) {\r\nrc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_ABORT_TASK_SET);\r\nif (!rc) {\r\nrc = ibmvfc_wait_for_ops(vhost, sdev->hostdata, ibmvfc_match_key);\r\nif (rc == SUCCESS)\r\nrc = 0;\r\n}\r\nif (rc) {\r\nsdev_printk(KERN_INFO, sdev, "Cancel failed, resetting host\n");\r\nibmvfc_reset_host(vhost);\r\nrsp_rc = 0;\r\ngoto out;\r\n}\r\n}\r\nif (rsp_iu.cmd.status)\r\nrsp_code = ibmvfc_get_err_result(&rsp_iu.cmd);\r\nif (rsp_code) {\r\nif (fc_rsp->flags & FCP_RSP_LEN_VALID)\r\nrsp_code = fc_rsp->data.info.rsp_code;\r\nsdev_printk(KERN_ERR, sdev, "Abort failed: %s (%x:%x) "\r\n"flags: %x fcp_rsp: %x, scsi_status: %x\n",\r\nibmvfc_get_cmd_error(rsp_iu.cmd.status, rsp_iu.cmd.error),\r\nrsp_iu.cmd.status, rsp_iu.cmd.error, fc_rsp->flags, rsp_code,\r\nfc_rsp->scsi_status);\r\nrsp_rc = -EIO;\r\n} else\r\nsdev_printk(KERN_INFO, sdev, "Abort successful\n");\r\nout:\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nibmvfc_free_event(evt);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn rsp_rc;\r\n}\r\nstatic int ibmvfc_eh_abort_handler(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct ibmvfc_host *vhost = shost_priv(sdev->host);\r\nint cancel_rc, abort_rc;\r\nint rc = FAILED;\r\nENTER;\r\nfc_block_scsi_eh(cmd);\r\nibmvfc_wait_while_resetting(vhost);\r\ncancel_rc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_ABORT_TASK_SET);\r\nabort_rc = ibmvfc_abort_task_set(sdev);\r\nif (!cancel_rc && !abort_rc)\r\nrc = ibmvfc_wait_for_ops(vhost, sdev, ibmvfc_match_lun);\r\nLEAVE;\r\nreturn rc;\r\n}\r\nstatic int ibmvfc_eh_device_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct ibmvfc_host *vhost = shost_priv(sdev->host);\r\nint cancel_rc, reset_rc;\r\nint rc = FAILED;\r\nENTER;\r\nfc_block_scsi_eh(cmd);\r\nibmvfc_wait_while_resetting(vhost);\r\ncancel_rc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_LUN_RESET);\r\nreset_rc = ibmvfc_reset_device(sdev, IBMVFC_LUN_RESET, "LUN");\r\nif (!cancel_rc && !reset_rc)\r\nrc = ibmvfc_wait_for_ops(vhost, sdev, ibmvfc_match_lun);\r\nLEAVE;\r\nreturn rc;\r\n}\r\nstatic void ibmvfc_dev_cancel_all_reset(struct scsi_device *sdev, void *data)\r\n{\r\nunsigned long *rc = data;\r\n*rc |= ibmvfc_cancel_all(sdev, IBMVFC_TMF_TGT_RESET);\r\n}\r\nstatic int ibmvfc_eh_target_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct ibmvfc_host *vhost = shost_priv(sdev->host);\r\nstruct scsi_target *starget = scsi_target(sdev);\r\nint reset_rc;\r\nint rc = FAILED;\r\nunsigned long cancel_rc = 0;\r\nENTER;\r\nfc_block_scsi_eh(cmd);\r\nibmvfc_wait_while_resetting(vhost);\r\nstarget_for_each_device(starget, &cancel_rc, ibmvfc_dev_cancel_all_reset);\r\nreset_rc = ibmvfc_reset_device(sdev, IBMVFC_TARGET_RESET, "target");\r\nif (!cancel_rc && !reset_rc)\r\nrc = ibmvfc_wait_for_ops(vhost, starget, ibmvfc_match_target);\r\nLEAVE;\r\nreturn rc;\r\n}\r\nstatic int ibmvfc_eh_host_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nint rc;\r\nstruct ibmvfc_host *vhost = shost_priv(cmd->device->host);\r\nfc_block_scsi_eh(cmd);\r\ndev_err(vhost->dev, "Resetting connection due to error recovery\n");\r\nrc = ibmvfc_issue_fc_host_lip(vhost->host);\r\nreturn rc ? FAILED : SUCCESS;\r\n}\r\nstatic void ibmvfc_terminate_rport_io(struct fc_rport *rport)\r\n{\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nstruct fc_rport *dev_rport;\r\nstruct scsi_device *sdev;\r\nunsigned long rc;\r\nENTER;\r\nshost_for_each_device(sdev, shost) {\r\ndev_rport = starget_to_rport(scsi_target(sdev));\r\nif (dev_rport != rport)\r\ncontinue;\r\nibmvfc_cancel_all(sdev, IBMVFC_TMF_ABORT_TASK_SET);\r\nibmvfc_abort_task_set(sdev);\r\n}\r\nrc = ibmvfc_wait_for_ops(vhost, rport, ibmvfc_match_rport);\r\nif (rc == FAILED)\r\nibmvfc_issue_fc_host_lip(shost);\r\nLEAVE;\r\n}\r\nstatic const struct ibmvfc_async_desc *ibmvfc_get_ae_desc(u64 ae)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ae_desc); i++)\r\nif (ae_desc[i].ae == ae)\r\nreturn &ae_desc[i];\r\nreturn &unknown_ae;\r\n}\r\nstatic const char *ibmvfc_get_link_state(enum ibmvfc_ae_link_state state)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(link_desc); i++)\r\nif (link_desc[i].state == state)\r\nreturn link_desc[i].desc;\r\nreturn "";\r\n}\r\nstatic void ibmvfc_handle_async(struct ibmvfc_async_crq *crq,\r\nstruct ibmvfc_host *vhost)\r\n{\r\nconst struct ibmvfc_async_desc *desc = ibmvfc_get_ae_desc(crq->event);\r\nstruct ibmvfc_target *tgt;\r\nibmvfc_log(vhost, desc->log_level, "%s event received. scsi_id: %llx, wwpn: %llx,"\r\n" node_name: %llx%s\n", desc->desc, crq->scsi_id, crq->wwpn, crq->node_name,\r\nibmvfc_get_link_state(crq->link_state));\r\nswitch (crq->event) {\r\ncase IBMVFC_AE_RESUME:\r\nswitch (crq->link_state) {\r\ncase IBMVFC_AE_LS_LINK_DOWN:\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\r\nbreak;\r\ncase IBMVFC_AE_LS_LINK_DEAD:\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\nbreak;\r\ncase IBMVFC_AE_LS_LINK_UP:\r\ncase IBMVFC_AE_LS_LINK_BOUNCED:\r\ndefault:\r\nvhost->events_to_log |= IBMVFC_AE_LINKUP;\r\nvhost->delay_init = 1;\r\n__ibmvfc_reset_host(vhost);\r\nbreak;\r\n};\r\nbreak;\r\ncase IBMVFC_AE_LINK_UP:\r\nvhost->events_to_log |= IBMVFC_AE_LINKUP;\r\nvhost->delay_init = 1;\r\n__ibmvfc_reset_host(vhost);\r\nbreak;\r\ncase IBMVFC_AE_SCN_FABRIC:\r\ncase IBMVFC_AE_SCN_DOMAIN:\r\nvhost->events_to_log |= IBMVFC_AE_RSCN;\r\nvhost->delay_init = 1;\r\n__ibmvfc_reset_host(vhost);\r\nbreak;\r\ncase IBMVFC_AE_SCN_NPORT:\r\ncase IBMVFC_AE_SCN_GROUP:\r\nvhost->events_to_log |= IBMVFC_AE_RSCN;\r\nibmvfc_reinit_host(vhost);\r\nbreak;\r\ncase IBMVFC_AE_ELS_LOGO:\r\ncase IBMVFC_AE_ELS_PRLO:\r\ncase IBMVFC_AE_ELS_PLOGI:\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (!crq->scsi_id && !crq->wwpn && !crq->node_name)\r\nbreak;\r\nif (crq->scsi_id && tgt->scsi_id != crq->scsi_id)\r\ncontinue;\r\nif (crq->wwpn && tgt->ids.port_name != crq->wwpn)\r\ncontinue;\r\nif (crq->node_name && tgt->ids.node_name != crq->node_name)\r\ncontinue;\r\nif (tgt->need_login && crq->event == IBMVFC_AE_ELS_LOGO)\r\ntgt->logo_rcvd = 1;\r\nif (!tgt->need_login || crq->event == IBMVFC_AE_ELS_PLOGI) {\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nibmvfc_reinit_host(vhost);\r\n}\r\n}\r\nbreak;\r\ncase IBMVFC_AE_LINK_DOWN:\r\ncase IBMVFC_AE_ADAPTER_FAILED:\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\r\nbreak;\r\ncase IBMVFC_AE_LINK_DEAD:\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\nbreak;\r\ncase IBMVFC_AE_HALT:\r\nibmvfc_link_down(vhost, IBMVFC_HALTED);\r\nbreak;\r\ndefault:\r\ndev_err(vhost->dev, "Unknown async event received: %lld\n", crq->event);\r\nbreak;\r\n};\r\n}\r\nstatic void ibmvfc_handle_crq(struct ibmvfc_crq *crq, struct ibmvfc_host *vhost)\r\n{\r\nlong rc;\r\nstruct ibmvfc_event *evt = (struct ibmvfc_event *)crq->ioba;\r\nswitch (crq->valid) {\r\ncase IBMVFC_CRQ_INIT_RSP:\r\nswitch (crq->format) {\r\ncase IBMVFC_CRQ_INIT:\r\ndev_info(vhost->dev, "Partner initialized\n");\r\nrc = ibmvfc_send_crq_init_complete(vhost);\r\nif (rc == 0)\r\nibmvfc_init_host(vhost);\r\nelse\r\ndev_err(vhost->dev, "Unable to send init rsp. rc=%ld\n", rc);\r\nbreak;\r\ncase IBMVFC_CRQ_INIT_COMPLETE:\r\ndev_info(vhost->dev, "Partner initialization complete\n");\r\nibmvfc_init_host(vhost);\r\nbreak;\r\ndefault:\r\ndev_err(vhost->dev, "Unknown crq message type: %d\n", crq->format);\r\n}\r\nreturn;\r\ncase IBMVFC_CRQ_XPORT_EVENT:\r\nvhost->state = IBMVFC_NO_CRQ;\r\nvhost->logged_in = 0;\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);\r\nif (crq->format == IBMVFC_PARTITION_MIGRATED) {\r\ndev_info(vhost->dev, "Re-enabling adapter\n");\r\nvhost->client_migrated = 1;\r\nibmvfc_purge_requests(vhost, DID_REQUEUE);\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_REENABLE);\r\n} else {\r\ndev_err(vhost->dev, "Virtual adapter failed (rc=%d)\n", crq->format);\r\nibmvfc_purge_requests(vhost, DID_ERROR);\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_RESET);\r\n}\r\nreturn;\r\ncase IBMVFC_CRQ_CMD_RSP:\r\nbreak;\r\ndefault:\r\ndev_err(vhost->dev, "Got an invalid message type 0x%02x\n", crq->valid);\r\nreturn;\r\n}\r\nif (crq->format == IBMVFC_ASYNC_EVENT)\r\nreturn;\r\nif (unlikely(!ibmvfc_valid_event(&vhost->pool, evt))) {\r\ndev_err(vhost->dev, "Returned correlation_token 0x%08llx is invalid!\n",\r\ncrq->ioba);\r\nreturn;\r\n}\r\nif (unlikely(atomic_read(&evt->free))) {\r\ndev_err(vhost->dev, "Received duplicate correlation_token 0x%08llx!\n",\r\ncrq->ioba);\r\nreturn;\r\n}\r\ndel_timer(&evt->timer);\r\nlist_del(&evt->queue);\r\nibmvfc_trc_end(evt);\r\nevt->done(evt);\r\n}\r\nstatic int ibmvfc_scan_finished(struct Scsi_Host *shost, unsigned long time)\r\n{\r\nunsigned long flags;\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nint done = 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (time >= (init_timeout * HZ)) {\r\ndev_info(vhost->dev, "Scan taking longer than %d seconds, "\r\n"continuing initialization\n", init_timeout);\r\ndone = 1;\r\n}\r\nif (vhost->scan_complete)\r\ndone = 1;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn done;\r\n}\r\nstatic int ibmvfc_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *shost = sdev->host;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nunsigned long flags = 0;\r\nif (!rport || fc_remote_port_chkready(rport))\r\nreturn -ENXIO;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nsdev->hostdata = (void *)(unsigned long)vhost->task_set++;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nstarget->hostdata = (void *)(unsigned long)vhost->task_set++;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *shost = sdev->host;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (sdev->type == TYPE_DISK)\r\nsdev->allow_restart = 1;\r\nif (sdev->tagged_supported) {\r\nscsi_set_tag_type(sdev, MSG_SIMPLE_TAG);\r\nscsi_activate_tcq(sdev, sdev->queue_depth);\r\n} else\r\nscsi_deactivate_tcq(sdev, sdev->queue_depth);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_change_queue_depth(struct scsi_device *sdev, int qdepth,\r\nint reason)\r\n{\r\nif (reason != SCSI_QDEPTH_DEFAULT)\r\nreturn -EOPNOTSUPP;\r\nif (qdepth > IBMVFC_MAX_CMDS_PER_LUN)\r\nqdepth = IBMVFC_MAX_CMDS_PER_LUN;\r\nscsi_adjust_queue_depth(sdev, 0, qdepth);\r\nreturn sdev->queue_depth;\r\n}\r\nstatic int ibmvfc_change_queue_type(struct scsi_device *sdev, int tag_type)\r\n{\r\nif (sdev->tagged_supported) {\r\nscsi_set_tag_type(sdev, tag_type);\r\nif (tag_type)\r\nscsi_activate_tcq(sdev, sdev->queue_depth);\r\nelse\r\nscsi_deactivate_tcq(sdev, sdev->queue_depth);\r\n} else\r\ntag_type = 0;\r\nreturn tag_type;\r\n}\r\nstatic ssize_t ibmvfc_show_host_partition_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nvhost->login_buf->resp.partition_name);\r\n}\r\nstatic ssize_t ibmvfc_show_host_device_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nvhost->login_buf->resp.device_name);\r\n}\r\nstatic ssize_t ibmvfc_show_host_loc_code(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nvhost->login_buf->resp.port_loc_code);\r\n}\r\nstatic ssize_t ibmvfc_show_host_drc_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nvhost->login_buf->resp.drc_name);\r\n}\r\nstatic ssize_t ibmvfc_show_host_npiv_version(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", vhost->login_buf->resp.version);\r\n}\r\nstatic ssize_t ibmvfc_show_host_capabilities(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%llx\n", vhost->login_buf->resp.capabilities);\r\n}\r\nstatic ssize_t ibmvfc_show_log_level(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nunsigned long flags = 0;\r\nint len;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlen = snprintf(buf, PAGE_SIZE, "%d\n", vhost->log_level);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn len;\r\n}\r\nstatic ssize_t ibmvfc_store_log_level(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nvhost->log_level = simple_strtoul(buf, NULL, 10);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t ibmvfc_read_trace(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ibmvfc_host *vhost = shost_priv(shost);\r\nunsigned long flags = 0;\r\nint size = IBMVFC_TRACE_SIZE;\r\nchar *src = (char *)vhost->trace;\r\nif (off > size)\r\nreturn 0;\r\nif (off + count > size) {\r\nsize -= off;\r\ncount = size;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nmemcpy(buf, &src[off], count);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn count;\r\n}\r\nstatic struct ibmvfc_async_crq *ibmvfc_next_async_crq(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_async_crq_queue *async_crq = &vhost->async_crq;\r\nstruct ibmvfc_async_crq *crq;\r\ncrq = &async_crq->msgs[async_crq->cur];\r\nif (crq->valid & 0x80) {\r\nif (++async_crq->cur == async_crq->size)\r\nasync_crq->cur = 0;\r\nrmb();\r\n} else\r\ncrq = NULL;\r\nreturn crq;\r\n}\r\nstatic struct ibmvfc_crq *ibmvfc_next_crq(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_crq_queue *queue = &vhost->crq;\r\nstruct ibmvfc_crq *crq;\r\ncrq = &queue->msgs[queue->cur];\r\nif (crq->valid & 0x80) {\r\nif (++queue->cur == queue->size)\r\nqueue->cur = 0;\r\nrmb();\r\n} else\r\ncrq = NULL;\r\nreturn crq;\r\n}\r\nstatic irqreturn_t ibmvfc_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct ibmvfc_host *vhost = (struct ibmvfc_host *)dev_instance;\r\nunsigned long flags;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nvio_disable_interrupts(to_vio_dev(vhost->dev));\r\ntasklet_schedule(&vhost->tasklet);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ibmvfc_tasklet(void *data)\r\n{\r\nstruct ibmvfc_host *vhost = data;\r\nstruct vio_dev *vdev = to_vio_dev(vhost->dev);\r\nstruct ibmvfc_crq *crq;\r\nstruct ibmvfc_async_crq *async;\r\nunsigned long flags;\r\nint done = 0;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nwhile (!done) {\r\nwhile ((async = ibmvfc_next_async_crq(vhost)) != NULL) {\r\nibmvfc_handle_async(async, vhost);\r\nasync->valid = 0;\r\nwmb();\r\n}\r\nwhile ((crq = ibmvfc_next_crq(vhost)) != NULL) {\r\nibmvfc_handle_crq(crq, vhost);\r\ncrq->valid = 0;\r\nwmb();\r\n}\r\nvio_enable_interrupts(vdev);\r\nif ((async = ibmvfc_next_async_crq(vhost)) != NULL) {\r\nvio_disable_interrupts(vdev);\r\nibmvfc_handle_async(async, vhost);\r\nasync->valid = 0;\r\nwmb();\r\n} else if ((crq = ibmvfc_next_crq(vhost)) != NULL) {\r\nvio_disable_interrupts(vdev);\r\nibmvfc_handle_crq(crq, vhost);\r\ncrq->valid = 0;\r\nwmb();\r\n} else\r\ndone = 1;\r\n}\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\n}\r\nstatic void ibmvfc_init_tgt(struct ibmvfc_target *tgt,\r\nvoid (*job_step) (struct ibmvfc_target *))\r\n{\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT);\r\ntgt->job_step = job_step;\r\nwake_up(&tgt->vhost->work_wait_q);\r\n}\r\nstatic int ibmvfc_retry_tgt_init(struct ibmvfc_target *tgt,\r\nvoid (*job_step) (struct ibmvfc_target *))\r\n{\r\nif (++tgt->init_retries > IBMVFC_MAX_TGT_INIT_RETRIES) {\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nwake_up(&tgt->vhost->work_wait_q);\r\nreturn 0;\r\n} else\r\nibmvfc_init_tgt(tgt, job_step);\r\nreturn 1;\r\n}\r\nstatic int ibmvfc_get_prli_rsp(u16 flags)\r\n{\r\nint i;\r\nint code = (flags & 0x0f00) >> 8;\r\nfor (i = 0; i < ARRAY_SIZE(prli_rsp); i++)\r\nif (prli_rsp[i].code == code)\r\nreturn i;\r\nreturn 0;\r\n}\r\nstatic void ibmvfc_tgt_prli_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_target *tgt = evt->tgt;\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_process_login *rsp = &evt->xfer_iu->prli;\r\nstruct ibmvfc_prli_svc_parms *parms = &rsp->parms;\r\nu32 status = rsp->common.status;\r\nint index, level = IBMVFC_DEFAULT_LOG_LEVEL;\r\nvhost->discovery_threads--;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nswitch (status) {\r\ncase IBMVFC_MAD_SUCCESS:\r\ntgt_dbg(tgt, "Process Login succeeded: %X %02X %04X\n",\r\nparms->type, parms->flags, parms->service_parms);\r\nif (parms->type == IBMVFC_SCSI_FCP_TYPE) {\r\nindex = ibmvfc_get_prli_rsp(parms->flags);\r\nif (prli_rsp[index].logged_in) {\r\nif (parms->flags & IBMVFC_PRLI_EST_IMG_PAIR) {\r\ntgt->need_login = 0;\r\ntgt->ids.roles = 0;\r\nif (parms->service_parms & IBMVFC_PRLI_TARGET_FUNC)\r\ntgt->ids.roles |= FC_PORT_ROLE_FCP_TARGET;\r\nif (parms->service_parms & IBMVFC_PRLI_INITIATOR_FUNC)\r\ntgt->ids.roles |= FC_PORT_ROLE_FCP_INITIATOR;\r\ntgt->add_rport = 1;\r\n} else\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\n} else if (prli_rsp[index].retry)\r\nibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_prli);\r\nelse\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\n} else\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nbreak;\r\ncase IBMVFC_MAD_DRIVER_FAILED:\r\nbreak;\r\ncase IBMVFC_MAD_CRQ_ERROR:\r\nibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_prli);\r\nbreak;\r\ncase IBMVFC_MAD_FAILED:\r\ndefault:\r\nif ((rsp->status & IBMVFC_VIOS_FAILURE) && rsp->error == IBMVFC_PLOGI_REQUIRED)\r\nlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_plogi);\r\nelse if (tgt->logo_rcvd)\r\nlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_plogi);\r\nelse if (ibmvfc_retry_cmd(rsp->status, rsp->error))\r\nlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_prli);\r\nelse\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\ntgt_log(tgt, level, "Process Login failed: %s (%x:%x) rc=0x%02X\n",\r\nibmvfc_get_cmd_error(rsp->status, rsp->error),\r\nrsp->status, rsp->error, status);\r\nbreak;\r\n};\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nibmvfc_free_event(evt);\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_tgt_send_prli(struct ibmvfc_target *tgt)\r\n{\r\nstruct ibmvfc_process_login *prli;\r\nstruct ibmvfc_host *vhost = tgt->vhost;\r\nstruct ibmvfc_event *evt;\r\nif (vhost->discovery_threads >= disc_threads)\r\nreturn;\r\nkref_get(&tgt->kref);\r\nevt = ibmvfc_get_event(vhost);\r\nvhost->discovery_threads++;\r\nibmvfc_init_event(evt, ibmvfc_tgt_prli_done, IBMVFC_MAD_FORMAT);\r\nevt->tgt = tgt;\r\nprli = &evt->iu.prli;\r\nmemset(prli, 0, sizeof(*prli));\r\nprli->common.version = 1;\r\nprli->common.opcode = IBMVFC_PROCESS_LOGIN;\r\nprli->common.length = sizeof(*prli);\r\nprli->scsi_id = tgt->scsi_id;\r\nprli->parms.type = IBMVFC_SCSI_FCP_TYPE;\r\nprli->parms.flags = IBMVFC_PRLI_EST_IMG_PAIR;\r\nprli->parms.service_parms = IBMVFC_PRLI_INITIATOR_FUNC;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\r\nif (ibmvfc_send_event(evt, vhost, default_timeout)) {\r\nvhost->discovery_threads--;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n} else\r\ntgt_dbg(tgt, "Sent process login\n");\r\n}\r\nstatic void ibmvfc_tgt_plogi_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_target *tgt = evt->tgt;\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_port_login *rsp = &evt->xfer_iu->plogi;\r\nu32 status = rsp->common.status;\r\nint level = IBMVFC_DEFAULT_LOG_LEVEL;\r\nvhost->discovery_threads--;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nswitch (status) {\r\ncase IBMVFC_MAD_SUCCESS:\r\ntgt_dbg(tgt, "Port Login succeeded\n");\r\nif (tgt->ids.port_name &&\r\ntgt->ids.port_name != wwn_to_u64(rsp->service_parms.port_name)) {\r\nvhost->reinit = 1;\r\ntgt_dbg(tgt, "Port re-init required\n");\r\nbreak;\r\n}\r\ntgt->ids.node_name = wwn_to_u64(rsp->service_parms.node_name);\r\ntgt->ids.port_name = wwn_to_u64(rsp->service_parms.port_name);\r\ntgt->ids.port_id = tgt->scsi_id;\r\nmemcpy(&tgt->service_parms, &rsp->service_parms,\r\nsizeof(tgt->service_parms));\r\nmemcpy(&tgt->service_parms_change, &rsp->service_parms_change,\r\nsizeof(tgt->service_parms_change));\r\nibmvfc_init_tgt(tgt, ibmvfc_tgt_send_prli);\r\nbreak;\r\ncase IBMVFC_MAD_DRIVER_FAILED:\r\nbreak;\r\ncase IBMVFC_MAD_CRQ_ERROR:\r\nibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_plogi);\r\nbreak;\r\ncase IBMVFC_MAD_FAILED:\r\ndefault:\r\nif (ibmvfc_retry_cmd(rsp->status, rsp->error))\r\nlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_plogi);\r\nelse\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\ntgt_log(tgt, level, "Port Login failed: %s (%x:%x) %s (%x) %s (%x) rc=0x%02X\n",\r\nibmvfc_get_cmd_error(rsp->status, rsp->error), rsp->status, rsp->error,\r\nibmvfc_get_fc_type(rsp->fc_type), rsp->fc_type,\r\nibmvfc_get_ls_explain(rsp->fc_explain), rsp->fc_explain, status);\r\nbreak;\r\n};\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nibmvfc_free_event(evt);\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_tgt_send_plogi(struct ibmvfc_target *tgt)\r\n{\r\nstruct ibmvfc_port_login *plogi;\r\nstruct ibmvfc_host *vhost = tgt->vhost;\r\nstruct ibmvfc_event *evt;\r\nif (vhost->discovery_threads >= disc_threads)\r\nreturn;\r\nkref_get(&tgt->kref);\r\ntgt->logo_rcvd = 0;\r\nevt = ibmvfc_get_event(vhost);\r\nvhost->discovery_threads++;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\r\nibmvfc_init_event(evt, ibmvfc_tgt_plogi_done, IBMVFC_MAD_FORMAT);\r\nevt->tgt = tgt;\r\nplogi = &evt->iu.plogi;\r\nmemset(plogi, 0, sizeof(*plogi));\r\nplogi->common.version = 1;\r\nplogi->common.opcode = IBMVFC_PORT_LOGIN;\r\nplogi->common.length = sizeof(*plogi);\r\nplogi->scsi_id = tgt->scsi_id;\r\nif (ibmvfc_send_event(evt, vhost, default_timeout)) {\r\nvhost->discovery_threads--;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n} else\r\ntgt_dbg(tgt, "Sent port login\n");\r\n}\r\nstatic void ibmvfc_tgt_implicit_logout_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_target *tgt = evt->tgt;\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_implicit_logout *rsp = &evt->xfer_iu->implicit_logout;\r\nu32 status = rsp->common.status;\r\nvhost->discovery_threads--;\r\nibmvfc_free_event(evt);\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nswitch (status) {\r\ncase IBMVFC_MAD_SUCCESS:\r\ntgt_dbg(tgt, "Implicit Logout succeeded\n");\r\nbreak;\r\ncase IBMVFC_MAD_DRIVER_FAILED:\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nwake_up(&vhost->work_wait_q);\r\nreturn;\r\ncase IBMVFC_MAD_FAILED:\r\ndefault:\r\ntgt_err(tgt, "Implicit Logout failed: rc=0x%02X\n", status);\r\nbreak;\r\n};\r\nif (vhost->action == IBMVFC_HOST_ACTION_TGT_INIT)\r\nibmvfc_init_tgt(tgt, ibmvfc_tgt_send_plogi);\r\nelse if (vhost->action == IBMVFC_HOST_ACTION_QUERY_TGTS &&\r\ntgt->scsi_id != tgt->new_scsi_id)\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_tgt_implicit_logout(struct ibmvfc_target *tgt)\r\n{\r\nstruct ibmvfc_implicit_logout *mad;\r\nstruct ibmvfc_host *vhost = tgt->vhost;\r\nstruct ibmvfc_event *evt;\r\nif (vhost->discovery_threads >= disc_threads)\r\nreturn;\r\nkref_get(&tgt->kref);\r\nevt = ibmvfc_get_event(vhost);\r\nvhost->discovery_threads++;\r\nibmvfc_init_event(evt, ibmvfc_tgt_implicit_logout_done, IBMVFC_MAD_FORMAT);\r\nevt->tgt = tgt;\r\nmad = &evt->iu.implicit_logout;\r\nmemset(mad, 0, sizeof(*mad));\r\nmad->common.version = 1;\r\nmad->common.opcode = IBMVFC_IMPLICIT_LOGOUT;\r\nmad->common.length = sizeof(*mad);\r\nmad->old_scsi_id = tgt->scsi_id;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\r\nif (ibmvfc_send_event(evt, vhost, default_timeout)) {\r\nvhost->discovery_threads--;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n} else\r\ntgt_dbg(tgt, "Sent Implicit Logout\n");\r\n}\r\nstatic int ibmvfc_adisc_needs_plogi(struct ibmvfc_passthru_mad *mad,\r\nstruct ibmvfc_target *tgt)\r\n{\r\nif (memcmp(&mad->fc_iu.response[2], &tgt->ids.port_name,\r\nsizeof(tgt->ids.port_name)))\r\nreturn 1;\r\nif (memcmp(&mad->fc_iu.response[4], &tgt->ids.node_name,\r\nsizeof(tgt->ids.node_name)))\r\nreturn 1;\r\nif (mad->fc_iu.response[6] != tgt->scsi_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ibmvfc_tgt_adisc_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_target *tgt = evt->tgt;\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_passthru_mad *mad = &evt->xfer_iu->passthru;\r\nu32 status = mad->common.status;\r\nu8 fc_reason, fc_explain;\r\nvhost->discovery_threads--;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\ndel_timer(&tgt->timer);\r\nswitch (status) {\r\ncase IBMVFC_MAD_SUCCESS:\r\ntgt_dbg(tgt, "ADISC succeeded\n");\r\nif (ibmvfc_adisc_needs_plogi(mad, tgt))\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nbreak;\r\ncase IBMVFC_MAD_DRIVER_FAILED:\r\nbreak;\r\ncase IBMVFC_MAD_FAILED:\r\ndefault:\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nfc_reason = (mad->fc_iu.response[1] & 0x00ff0000) >> 16;\r\nfc_explain = (mad->fc_iu.response[1] & 0x0000ff00) >> 8;\r\ntgt_info(tgt, "ADISC failed: %s (%x:%x) %s (%x) %s (%x) rc=0x%02X\n",\r\nibmvfc_get_cmd_error(mad->iu.status, mad->iu.error),\r\nmad->iu.status, mad->iu.error,\r\nibmvfc_get_fc_type(fc_reason), fc_reason,\r\nibmvfc_get_ls_explain(fc_explain), fc_explain, status);\r\nbreak;\r\n};\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nibmvfc_free_event(evt);\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_init_passthru(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_passthru_mad *mad = &evt->iu.passthru;\r\nmemset(mad, 0, sizeof(*mad));\r\nmad->common.version = 1;\r\nmad->common.opcode = IBMVFC_PASSTHRU;\r\nmad->common.length = sizeof(*mad) - sizeof(mad->fc_iu) - sizeof(mad->iu);\r\nmad->cmd_ioba.va = (u64)evt->crq.ioba +\r\noffsetof(struct ibmvfc_passthru_mad, iu);\r\nmad->cmd_ioba.len = sizeof(mad->iu);\r\nmad->iu.cmd_len = sizeof(mad->fc_iu.payload);\r\nmad->iu.rsp_len = sizeof(mad->fc_iu.response);\r\nmad->iu.cmd.va = (u64)evt->crq.ioba +\r\noffsetof(struct ibmvfc_passthru_mad, fc_iu) +\r\noffsetof(struct ibmvfc_passthru_fc_iu, payload);\r\nmad->iu.cmd.len = sizeof(mad->fc_iu.payload);\r\nmad->iu.rsp.va = (u64)evt->crq.ioba +\r\noffsetof(struct ibmvfc_passthru_mad, fc_iu) +\r\noffsetof(struct ibmvfc_passthru_fc_iu, response);\r\nmad->iu.rsp.len = sizeof(mad->fc_iu.response);\r\n}\r\nstatic void ibmvfc_tgt_adisc_cancel_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_target *tgt = evt->tgt;\r\ntgt_dbg(tgt, "ADISC cancel complete\n");\r\nvhost->abort_threads--;\r\nibmvfc_free_event(evt);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_adisc_timeout(struct ibmvfc_target *tgt)\r\n{\r\nstruct ibmvfc_host *vhost = tgt->vhost;\r\nstruct ibmvfc_event *evt;\r\nstruct ibmvfc_tmf *tmf;\r\nunsigned long flags;\r\nint rc;\r\ntgt_dbg(tgt, "ADISC timeout\n");\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nif (vhost->abort_threads >= disc_threads ||\r\ntgt->action != IBMVFC_TGT_ACTION_INIT_WAIT ||\r\nvhost->state != IBMVFC_INITIALIZING ||\r\nvhost->action != IBMVFC_HOST_ACTION_QUERY_TGTS) {\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn;\r\n}\r\nvhost->abort_threads++;\r\nkref_get(&tgt->kref);\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_tgt_adisc_cancel_done, IBMVFC_MAD_FORMAT);\r\nevt->tgt = tgt;\r\ntmf = &evt->iu.tmf;\r\nmemset(tmf, 0, sizeof(*tmf));\r\ntmf->common.version = 1;\r\ntmf->common.opcode = IBMVFC_TMF_MAD;\r\ntmf->common.length = sizeof(*tmf);\r\ntmf->scsi_id = tgt->scsi_id;\r\ntmf->cancel_key = tgt->cancel_key;\r\nrc = ibmvfc_send_event(evt, vhost, default_timeout);\r\nif (rc) {\r\ntgt_err(tgt, "Failed to send cancel event for ADISC. rc=%d\n", rc);\r\nvhost->abort_threads--;\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n__ibmvfc_reset_host(vhost);\r\n} else\r\ntgt_dbg(tgt, "Attempting to cancel ADISC\n");\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\n}\r\nstatic void ibmvfc_tgt_adisc(struct ibmvfc_target *tgt)\r\n{\r\nstruct ibmvfc_passthru_mad *mad;\r\nstruct ibmvfc_host *vhost = tgt->vhost;\r\nstruct ibmvfc_event *evt;\r\nif (vhost->discovery_threads >= disc_threads)\r\nreturn;\r\nkref_get(&tgt->kref);\r\nevt = ibmvfc_get_event(vhost);\r\nvhost->discovery_threads++;\r\nibmvfc_init_event(evt, ibmvfc_tgt_adisc_done, IBMVFC_MAD_FORMAT);\r\nevt->tgt = tgt;\r\nibmvfc_init_passthru(evt);\r\nmad = &evt->iu.passthru;\r\nmad->iu.flags = IBMVFC_FC_ELS;\r\nmad->iu.scsi_id = tgt->scsi_id;\r\nmad->iu.cancel_key = tgt->cancel_key;\r\nmad->fc_iu.payload[0] = IBMVFC_ADISC;\r\nmemcpy(&mad->fc_iu.payload[2], &vhost->login_buf->resp.port_name,\r\nsizeof(vhost->login_buf->resp.port_name));\r\nmemcpy(&mad->fc_iu.payload[4], &vhost->login_buf->resp.node_name,\r\nsizeof(vhost->login_buf->resp.node_name));\r\nmad->fc_iu.payload[6] = vhost->login_buf->resp.scsi_id & 0x00ffffff;\r\nif (timer_pending(&tgt->timer))\r\nmod_timer(&tgt->timer, jiffies + (IBMVFC_ADISC_TIMEOUT * HZ));\r\nelse {\r\ntgt->timer.data = (unsigned long) tgt;\r\ntgt->timer.expires = jiffies + (IBMVFC_ADISC_TIMEOUT * HZ);\r\ntgt->timer.function = (void (*)(unsigned long))ibmvfc_adisc_timeout;\r\nadd_timer(&tgt->timer);\r\n}\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\r\nif (ibmvfc_send_event(evt, vhost, IBMVFC_ADISC_PLUS_CANCEL_TIMEOUT)) {\r\nvhost->discovery_threads--;\r\ndel_timer(&tgt->timer);\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n} else\r\ntgt_dbg(tgt, "Sent ADISC\n");\r\n}\r\nstatic void ibmvfc_tgt_query_target_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_target *tgt = evt->tgt;\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_query_tgt *rsp = &evt->xfer_iu->query_tgt;\r\nu32 status = rsp->common.status;\r\nint level = IBMVFC_DEFAULT_LOG_LEVEL;\r\nvhost->discovery_threads--;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nswitch (status) {\r\ncase IBMVFC_MAD_SUCCESS:\r\ntgt_dbg(tgt, "Query Target succeeded\n");\r\ntgt->new_scsi_id = rsp->scsi_id;\r\nif (rsp->scsi_id != tgt->scsi_id)\r\nibmvfc_init_tgt(tgt, ibmvfc_tgt_implicit_logout);\r\nelse\r\nibmvfc_init_tgt(tgt, ibmvfc_tgt_adisc);\r\nbreak;\r\ncase IBMVFC_MAD_DRIVER_FAILED:\r\nbreak;\r\ncase IBMVFC_MAD_CRQ_ERROR:\r\nibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_query_target);\r\nbreak;\r\ncase IBMVFC_MAD_FAILED:\r\ndefault:\r\nif ((rsp->status & IBMVFC_FABRIC_MAPPED) == IBMVFC_FABRIC_MAPPED &&\r\nrsp->error == IBMVFC_UNABLE_TO_PERFORM_REQ &&\r\nrsp->fc_explain == IBMVFC_PORT_NAME_NOT_REG)\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\nelse if (ibmvfc_retry_cmd(rsp->status, rsp->error))\r\nlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_query_target);\r\nelse\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\r\ntgt_log(tgt, level, "Query Target failed: %s (%x:%x) %s (%x) %s (%x) rc=0x%02X\n",\r\nibmvfc_get_cmd_error(rsp->status, rsp->error), rsp->status, rsp->error,\r\nibmvfc_get_fc_type(rsp->fc_type), rsp->fc_type,\r\nibmvfc_get_gs_explain(rsp->fc_explain), rsp->fc_explain, status);\r\nbreak;\r\n};\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nibmvfc_free_event(evt);\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_tgt_query_target(struct ibmvfc_target *tgt)\r\n{\r\nstruct ibmvfc_query_tgt *query_tgt;\r\nstruct ibmvfc_host *vhost = tgt->vhost;\r\nstruct ibmvfc_event *evt;\r\nif (vhost->discovery_threads >= disc_threads)\r\nreturn;\r\nkref_get(&tgt->kref);\r\nevt = ibmvfc_get_event(vhost);\r\nvhost->discovery_threads++;\r\nevt->tgt = tgt;\r\nibmvfc_init_event(evt, ibmvfc_tgt_query_target_done, IBMVFC_MAD_FORMAT);\r\nquery_tgt = &evt->iu.query_tgt;\r\nmemset(query_tgt, 0, sizeof(*query_tgt));\r\nquery_tgt->common.version = 1;\r\nquery_tgt->common.opcode = IBMVFC_QUERY_TARGET;\r\nquery_tgt->common.length = sizeof(*query_tgt);\r\nquery_tgt->wwpn = tgt->ids.port_name;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\r\nif (ibmvfc_send_event(evt, vhost, default_timeout)) {\r\nvhost->discovery_threads--;\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\n} else\r\ntgt_dbg(tgt, "Sent Query Target\n");\r\n}\r\nstatic int ibmvfc_alloc_target(struct ibmvfc_host *vhost, u64 scsi_id)\r\n{\r\nstruct ibmvfc_target *tgt;\r\nunsigned long flags;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (tgt->scsi_id == scsi_id) {\r\nif (tgt->need_login)\r\nibmvfc_init_tgt(tgt, ibmvfc_tgt_implicit_logout);\r\ngoto unlock_out;\r\n}\r\n}\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\ntgt = mempool_alloc(vhost->tgt_pool, GFP_NOIO);\r\nif (!tgt) {\r\ndev_err(vhost->dev, "Target allocation failure for scsi id %08llx\n",\r\nscsi_id);\r\nreturn -ENOMEM;\r\n}\r\nmemset(tgt, 0, sizeof(*tgt));\r\ntgt->scsi_id = scsi_id;\r\ntgt->new_scsi_id = scsi_id;\r\ntgt->vhost = vhost;\r\ntgt->need_login = 1;\r\ntgt->cancel_key = vhost->task_set++;\r\ninit_timer(&tgt->timer);\r\nkref_init(&tgt->kref);\r\nibmvfc_init_tgt(tgt, ibmvfc_tgt_implicit_logout);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nlist_add_tail(&tgt->queue, &vhost->targets);\r\nunlock_out:\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_alloc_targets(struct ibmvfc_host *vhost)\r\n{\r\nint i, rc;\r\nfor (i = 0, rc = 0; !rc && i < vhost->num_targets; i++)\r\nrc = ibmvfc_alloc_target(vhost,\r\nvhost->disc_buf->scsi_id[i] & IBMVFC_DISC_TGT_SCSI_ID_MASK);\r\nreturn rc;\r\n}\r\nstatic void ibmvfc_discover_targets_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nstruct ibmvfc_discover_targets *rsp = &evt->xfer_iu->discover_targets;\r\nu32 mad_status = rsp->common.status;\r\nint level = IBMVFC_DEFAULT_LOG_LEVEL;\r\nswitch (mad_status) {\r\ncase IBMVFC_MAD_SUCCESS:\r\nibmvfc_dbg(vhost, "Discover Targets succeeded\n");\r\nvhost->num_targets = rsp->num_written;\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_ALLOC_TGTS);\r\nbreak;\r\ncase IBMVFC_MAD_FAILED:\r\nlevel += ibmvfc_retry_host_init(vhost);\r\nibmvfc_log(vhost, level, "Discover Targets failed: %s (%x:%x)\n",\r\nibmvfc_get_cmd_error(rsp->status, rsp->error), rsp->status, rsp->error);\r\nbreak;\r\ncase IBMVFC_MAD_DRIVER_FAILED:\r\nbreak;\r\ndefault:\r\ndev_err(vhost->dev, "Invalid Discover Targets response: 0x%x\n", mad_status);\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\nbreak;\r\n}\r\nibmvfc_free_event(evt);\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_discover_targets(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_discover_targets *mad;\r\nstruct ibmvfc_event *evt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_discover_targets_done, IBMVFC_MAD_FORMAT);\r\nmad = &evt->iu.discover_targets;\r\nmemset(mad, 0, sizeof(*mad));\r\nmad->common.version = 1;\r\nmad->common.opcode = IBMVFC_DISC_TARGETS;\r\nmad->common.length = sizeof(*mad);\r\nmad->bufflen = vhost->disc_buf_sz;\r\nmad->buffer.va = vhost->disc_buf_dma;\r\nmad->buffer.len = vhost->disc_buf_sz;\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT_WAIT);\r\nif (!ibmvfc_send_event(evt, vhost, default_timeout))\r\nibmvfc_dbg(vhost, "Sent discover targets\n");\r\nelse\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\n}\r\nstatic void ibmvfc_npiv_login_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nu32 mad_status = evt->xfer_iu->npiv_login.common.status;\r\nstruct ibmvfc_npiv_login_resp *rsp = &vhost->login_buf->resp;\r\nunsigned int npiv_max_sectors;\r\nint level = IBMVFC_DEFAULT_LOG_LEVEL;\r\nswitch (mad_status) {\r\ncase IBMVFC_MAD_SUCCESS:\r\nibmvfc_free_event(evt);\r\nbreak;\r\ncase IBMVFC_MAD_FAILED:\r\nif (ibmvfc_retry_cmd(rsp->status, rsp->error))\r\nlevel += ibmvfc_retry_host_init(vhost);\r\nelse\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\nibmvfc_log(vhost, level, "NPIV Login failed: %s (%x:%x)\n",\r\nibmvfc_get_cmd_error(rsp->status, rsp->error), rsp->status, rsp->error);\r\nibmvfc_free_event(evt);\r\nreturn;\r\ncase IBMVFC_MAD_CRQ_ERROR:\r\nibmvfc_retry_host_init(vhost);\r\ncase IBMVFC_MAD_DRIVER_FAILED:\r\nibmvfc_free_event(evt);\r\nreturn;\r\ndefault:\r\ndev_err(vhost->dev, "Invalid NPIV Login response: 0x%x\n", mad_status);\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\nibmvfc_free_event(evt);\r\nreturn;\r\n}\r\nvhost->client_migrated = 0;\r\nif (!(rsp->flags & IBMVFC_NATIVE_FC)) {\r\ndev_err(vhost->dev, "Virtual adapter does not support FC. %x\n",\r\nrsp->flags);\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\nwake_up(&vhost->work_wait_q);\r\nreturn;\r\n}\r\nif (rsp->max_cmds <= IBMVFC_NUM_INTERNAL_REQ) {\r\ndev_err(vhost->dev, "Virtual adapter supported queue depth too small: %d\n",\r\nrsp->max_cmds);\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\nwake_up(&vhost->work_wait_q);\r\nreturn;\r\n}\r\nvhost->logged_in = 1;\r\nnpiv_max_sectors = min((uint)(rsp->max_dma_len >> 9), IBMVFC_MAX_SECTORS);\r\ndev_info(vhost->dev, "Host partition: %s, device: %s %s %s max sectors %u\n",\r\nrsp->partition_name, rsp->device_name, rsp->port_loc_code,\r\nrsp->drc_name, npiv_max_sectors);\r\nfc_host_fabric_name(vhost->host) = rsp->node_name;\r\nfc_host_node_name(vhost->host) = rsp->node_name;\r\nfc_host_port_name(vhost->host) = rsp->port_name;\r\nfc_host_port_id(vhost->host) = rsp->scsi_id;\r\nfc_host_port_type(vhost->host) = FC_PORTTYPE_NPIV;\r\nfc_host_supported_classes(vhost->host) = 0;\r\nif (rsp->service_parms.class1_parms[0] & 0x80000000)\r\nfc_host_supported_classes(vhost->host) |= FC_COS_CLASS1;\r\nif (rsp->service_parms.class2_parms[0] & 0x80000000)\r\nfc_host_supported_classes(vhost->host) |= FC_COS_CLASS2;\r\nif (rsp->service_parms.class3_parms[0] & 0x80000000)\r\nfc_host_supported_classes(vhost->host) |= FC_COS_CLASS3;\r\nfc_host_maxframe_size(vhost->host) =\r\nrsp->service_parms.common.bb_rcv_sz & 0x0fff;\r\nvhost->host->can_queue = rsp->max_cmds - IBMVFC_NUM_INTERNAL_REQ;\r\nvhost->host->max_sectors = npiv_max_sectors;\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY);\r\nwake_up(&vhost->work_wait_q);\r\n}\r\nstatic void ibmvfc_npiv_login(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_npiv_login_mad *mad;\r\nstruct ibmvfc_event *evt = ibmvfc_get_event(vhost);\r\nibmvfc_gather_partition_info(vhost);\r\nibmvfc_set_login_info(vhost);\r\nibmvfc_init_event(evt, ibmvfc_npiv_login_done, IBMVFC_MAD_FORMAT);\r\nmemcpy(vhost->login_buf, &vhost->login_info, sizeof(vhost->login_info));\r\nmad = &evt->iu.npiv_login;\r\nmemset(mad, 0, sizeof(struct ibmvfc_npiv_login_mad));\r\nmad->common.version = 1;\r\nmad->common.opcode = IBMVFC_NPIV_LOGIN;\r\nmad->common.length = sizeof(struct ibmvfc_npiv_login_mad);\r\nmad->buffer.va = vhost->login_buf_dma;\r\nmad->buffer.len = sizeof(*vhost->login_buf);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT_WAIT);\r\nif (!ibmvfc_send_event(evt, vhost, default_timeout))\r\nibmvfc_dbg(vhost, "Sent NPIV login\n");\r\nelse\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\n}\r\nstatic void ibmvfc_npiv_logout_done(struct ibmvfc_event *evt)\r\n{\r\nstruct ibmvfc_host *vhost = evt->vhost;\r\nu32 mad_status = evt->xfer_iu->npiv_logout.common.status;\r\nibmvfc_free_event(evt);\r\nswitch (mad_status) {\r\ncase IBMVFC_MAD_SUCCESS:\r\nif (list_empty(&vhost->sent) &&\r\nvhost->action == IBMVFC_HOST_ACTION_LOGO_WAIT) {\r\nibmvfc_init_host(vhost);\r\nreturn;\r\n}\r\nbreak;\r\ncase IBMVFC_MAD_FAILED:\r\ncase IBMVFC_MAD_NOT_SUPPORTED:\r\ncase IBMVFC_MAD_CRQ_ERROR:\r\ncase IBMVFC_MAD_DRIVER_FAILED:\r\ndefault:\r\nibmvfc_dbg(vhost, "NPIV Logout failed. 0x%X\n", mad_status);\r\nbreak;\r\n}\r\nibmvfc_hard_reset_host(vhost);\r\n}\r\nstatic void ibmvfc_npiv_logout(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_npiv_logout_mad *mad;\r\nstruct ibmvfc_event *evt;\r\nevt = ibmvfc_get_event(vhost);\r\nibmvfc_init_event(evt, ibmvfc_npiv_logout_done, IBMVFC_MAD_FORMAT);\r\nmad = &evt->iu.npiv_logout;\r\nmemset(mad, 0, sizeof(*mad));\r\nmad->common.version = 1;\r\nmad->common.opcode = IBMVFC_NPIV_LOGOUT;\r\nmad->common.length = sizeof(struct ibmvfc_npiv_logout_mad);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_LOGO_WAIT);\r\nif (!ibmvfc_send_event(evt, vhost, default_timeout))\r\nibmvfc_dbg(vhost, "Sent NPIV logout\n");\r\nelse\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\n}\r\nstatic int ibmvfc_dev_init_to_do(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_target *tgt;\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (tgt->action == IBMVFC_TGT_ACTION_INIT ||\r\ntgt->action == IBMVFC_TGT_ACTION_INIT_WAIT)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __ibmvfc_work_to_do(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_target *tgt;\r\nif (kthread_should_stop())\r\nreturn 1;\r\nswitch (vhost->action) {\r\ncase IBMVFC_HOST_ACTION_NONE:\r\ncase IBMVFC_HOST_ACTION_INIT_WAIT:\r\ncase IBMVFC_HOST_ACTION_LOGO_WAIT:\r\nreturn 0;\r\ncase IBMVFC_HOST_ACTION_TGT_INIT:\r\ncase IBMVFC_HOST_ACTION_QUERY_TGTS:\r\nif (vhost->discovery_threads == disc_threads)\r\nreturn 0;\r\nlist_for_each_entry(tgt, &vhost->targets, queue)\r\nif (tgt->action == IBMVFC_TGT_ACTION_INIT)\r\nreturn 1;\r\nlist_for_each_entry(tgt, &vhost->targets, queue)\r\nif (tgt->action == IBMVFC_TGT_ACTION_INIT_WAIT)\r\nreturn 0;\r\nreturn 1;\r\ncase IBMVFC_HOST_ACTION_LOGO:\r\ncase IBMVFC_HOST_ACTION_INIT:\r\ncase IBMVFC_HOST_ACTION_ALLOC_TGTS:\r\ncase IBMVFC_HOST_ACTION_TGT_DEL:\r\ncase IBMVFC_HOST_ACTION_TGT_DEL_FAILED:\r\ncase IBMVFC_HOST_ACTION_QUERY:\r\ncase IBMVFC_HOST_ACTION_RESET:\r\ncase IBMVFC_HOST_ACTION_REENABLE:\r\ndefault:\r\nbreak;\r\n};\r\nreturn 1;\r\n}\r\nstatic int ibmvfc_work_to_do(struct ibmvfc_host *vhost)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nrc = __ibmvfc_work_to_do(vhost);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void ibmvfc_log_ae(struct ibmvfc_host *vhost, int events)\r\n{\r\nif (events & IBMVFC_AE_RSCN)\r\nfc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_RSCN, 0);\r\nif ((events & IBMVFC_AE_LINKDOWN) &&\r\nvhost->state >= IBMVFC_HALTED)\r\nfc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_LINKDOWN, 0);\r\nif ((events & IBMVFC_AE_LINKUP) &&\r\nvhost->state == IBMVFC_INITIALIZING)\r\nfc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_LINKUP, 0);\r\n}\r\nstatic void ibmvfc_tgt_add_rport(struct ibmvfc_target *tgt)\r\n{\r\nstruct ibmvfc_host *vhost = tgt->vhost;\r\nstruct fc_rport *rport;\r\nunsigned long flags;\r\ntgt_dbg(tgt, "Adding rport\n");\r\nrport = fc_remote_port_add(vhost->host, 0, &tgt->ids);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nif (rport && tgt->action == IBMVFC_TGT_ACTION_DEL_RPORT) {\r\ntgt_dbg(tgt, "Deleting rport\n");\r\nlist_del(&tgt->queue);\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DELETED_RPORT);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nfc_remote_port_delete(rport);\r\ndel_timer_sync(&tgt->timer);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nreturn;\r\n} else if (rport && tgt->action == IBMVFC_TGT_ACTION_DELETED_RPORT) {\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn;\r\n}\r\nif (rport) {\r\ntgt_dbg(tgt, "rport add succeeded\n");\r\ntgt->rport = rport;\r\nrport->maxframe_size = tgt->service_parms.common.bb_rcv_sz & 0x0fff;\r\nrport->supported_classes = 0;\r\ntgt->target_id = rport->scsi_target_id;\r\nif (tgt->service_parms.class1_parms[0] & 0x80000000)\r\nrport->supported_classes |= FC_COS_CLASS1;\r\nif (tgt->service_parms.class2_parms[0] & 0x80000000)\r\nrport->supported_classes |= FC_COS_CLASS2;\r\nif (tgt->service_parms.class3_parms[0] & 0x80000000)\r\nrport->supported_classes |= FC_COS_CLASS3;\r\nif (rport->rqst_q)\r\nblk_queue_max_segments(rport->rqst_q, 1);\r\n} else\r\ntgt_dbg(tgt, "rport add failed\n");\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\n}\r\nstatic void ibmvfc_do_work(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_target *tgt;\r\nunsigned long flags;\r\nstruct fc_rport *rport;\r\nint rc;\r\nibmvfc_log_ae(vhost, vhost->events_to_log);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nvhost->events_to_log = 0;\r\nswitch (vhost->action) {\r\ncase IBMVFC_HOST_ACTION_NONE:\r\ncase IBMVFC_HOST_ACTION_LOGO_WAIT:\r\ncase IBMVFC_HOST_ACTION_INIT_WAIT:\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_RESET:\r\nvhost->action = IBMVFC_HOST_ACTION_TGT_DEL;\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nrc = ibmvfc_reset_crq(vhost);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nif (rc == H_CLOSED)\r\nvio_enable_interrupts(to_vio_dev(vhost->dev));\r\nif (rc || (rc = ibmvfc_send_crq_init(vhost)) ||\r\n(rc = vio_enable_interrupts(to_vio_dev(vhost->dev)))) {\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\ndev_err(vhost->dev, "Error after reset (rc=%d)\n", rc);\r\n}\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_REENABLE:\r\nvhost->action = IBMVFC_HOST_ACTION_TGT_DEL;\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nrc = ibmvfc_reenable_crq_queue(vhost);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nif (rc || (rc = ibmvfc_send_crq_init(vhost))) {\r\nibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\r\ndev_err(vhost->dev, "Error after enable (rc=%d)\n", rc);\r\n}\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_LOGO:\r\nvhost->job_step(vhost);\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_INIT:\r\nBUG_ON(vhost->state != IBMVFC_INITIALIZING);\r\nif (vhost->delay_init) {\r\nvhost->delay_init = 0;\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nssleep(15);\r\nreturn;\r\n} else\r\nvhost->job_step(vhost);\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_QUERY:\r\nlist_for_each_entry(tgt, &vhost->targets, queue)\r\nibmvfc_init_tgt(tgt, ibmvfc_tgt_query_target);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY_TGTS);\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_QUERY_TGTS:\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (tgt->action == IBMVFC_TGT_ACTION_INIT) {\r\ntgt->job_step(tgt);\r\nbreak;\r\n}\r\n}\r\nif (!ibmvfc_dev_init_to_do(vhost))\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_TGT_DEL);\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_TGT_DEL:\r\ncase IBMVFC_HOST_ACTION_TGT_DEL_FAILED:\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (tgt->action == IBMVFC_TGT_ACTION_DEL_RPORT) {\r\ntgt_dbg(tgt, "Deleting rport\n");\r\nrport = tgt->rport;\r\ntgt->rport = NULL;\r\nlist_del(&tgt->queue);\r\nibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DELETED_RPORT);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nif (rport)\r\nfc_remote_port_delete(rport);\r\ndel_timer_sync(&tgt->timer);\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nreturn;\r\n}\r\n}\r\nif (vhost->state == IBMVFC_INITIALIZING) {\r\nif (vhost->action == IBMVFC_HOST_ACTION_TGT_DEL_FAILED) {\r\nif (vhost->reinit) {\r\nvhost->reinit = 0;\r\nscsi_block_requests(vhost->host);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\n} else {\r\nibmvfc_set_host_state(vhost, IBMVFC_ACTIVE);\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);\r\nwake_up(&vhost->init_wait_q);\r\nschedule_work(&vhost->rport_add_work_q);\r\nvhost->init_retries = 0;\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nscsi_unblock_requests(vhost->host);\r\n}\r\nreturn;\r\n} else {\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT);\r\nvhost->job_step = ibmvfc_discover_targets;\r\n}\r\n} else {\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nscsi_unblock_requests(vhost->host);\r\nwake_up(&vhost->init_wait_q);\r\nreturn;\r\n}\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_ALLOC_TGTS:\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_TGT_INIT);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nibmvfc_alloc_targets(vhost);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nbreak;\r\ncase IBMVFC_HOST_ACTION_TGT_INIT:\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (tgt->action == IBMVFC_TGT_ACTION_INIT) {\r\ntgt->job_step(tgt);\r\nbreak;\r\n}\r\n}\r\nif (!ibmvfc_dev_init_to_do(vhost))\r\nibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_TGT_DEL_FAILED);\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\n}\r\nstatic int ibmvfc_work(void *data)\r\n{\r\nstruct ibmvfc_host *vhost = data;\r\nint rc;\r\nset_user_nice(current, -20);\r\nwhile (1) {\r\nrc = wait_event_interruptible(vhost->work_wait_q,\r\nibmvfc_work_to_do(vhost));\r\nBUG_ON(rc);\r\nif (kthread_should_stop())\r\nbreak;\r\nibmvfc_do_work(vhost);\r\n}\r\nibmvfc_dbg(vhost, "ibmvfc kthread exiting...\n");\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_init_crq(struct ibmvfc_host *vhost)\r\n{\r\nint rc, retrc = -ENOMEM;\r\nstruct device *dev = vhost->dev;\r\nstruct vio_dev *vdev = to_vio_dev(dev);\r\nstruct ibmvfc_crq_queue *crq = &vhost->crq;\r\nENTER;\r\ncrq->msgs = (struct ibmvfc_crq *)get_zeroed_page(GFP_KERNEL);\r\nif (!crq->msgs)\r\nreturn -ENOMEM;\r\ncrq->size = PAGE_SIZE / sizeof(*crq->msgs);\r\ncrq->msg_token = dma_map_single(dev, crq->msgs,\r\nPAGE_SIZE, DMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(dev, crq->msg_token))\r\ngoto map_failed;\r\nretrc = rc = plpar_hcall_norets(H_REG_CRQ, vdev->unit_address,\r\ncrq->msg_token, PAGE_SIZE);\r\nif (rc == H_RESOURCE)\r\nretrc = rc = ibmvfc_reset_crq(vhost);\r\nif (rc == H_CLOSED)\r\ndev_warn(dev, "Partner adapter not ready\n");\r\nelse if (rc) {\r\ndev_warn(dev, "Error %d opening adapter\n", rc);\r\ngoto reg_crq_failed;\r\n}\r\nretrc = 0;\r\ntasklet_init(&vhost->tasklet, (void *)ibmvfc_tasklet, (unsigned long)vhost);\r\nif ((rc = request_irq(vdev->irq, ibmvfc_interrupt, 0, IBMVFC_NAME, vhost))) {\r\ndev_err(dev, "Couldn't register irq 0x%x. rc=%d\n", vdev->irq, rc);\r\ngoto req_irq_failed;\r\n}\r\nif ((rc = vio_enable_interrupts(vdev))) {\r\ndev_err(dev, "Error %d enabling interrupts\n", rc);\r\ngoto req_irq_failed;\r\n}\r\ncrq->cur = 0;\r\nLEAVE;\r\nreturn retrc;\r\nreq_irq_failed:\r\ntasklet_kill(&vhost->tasklet);\r\ndo {\r\nrc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\r\n} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\r\nreg_crq_failed:\r\ndma_unmap_single(dev, crq->msg_token, PAGE_SIZE, DMA_BIDIRECTIONAL);\r\nmap_failed:\r\nfree_page((unsigned long)crq->msgs);\r\nreturn retrc;\r\n}\r\nstatic void ibmvfc_free_mem(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_async_crq_queue *async_q = &vhost->async_crq;\r\nENTER;\r\nmempool_destroy(vhost->tgt_pool);\r\nkfree(vhost->trace);\r\ndma_free_coherent(vhost->dev, vhost->disc_buf_sz, vhost->disc_buf,\r\nvhost->disc_buf_dma);\r\ndma_free_coherent(vhost->dev, sizeof(*vhost->login_buf),\r\nvhost->login_buf, vhost->login_buf_dma);\r\ndma_pool_destroy(vhost->sg_pool);\r\ndma_unmap_single(vhost->dev, async_q->msg_token,\r\nasync_q->size * sizeof(*async_q->msgs), DMA_BIDIRECTIONAL);\r\nfree_page((unsigned long)async_q->msgs);\r\nLEAVE;\r\n}\r\nstatic int ibmvfc_alloc_mem(struct ibmvfc_host *vhost)\r\n{\r\nstruct ibmvfc_async_crq_queue *async_q = &vhost->async_crq;\r\nstruct device *dev = vhost->dev;\r\nENTER;\r\nasync_q->msgs = (struct ibmvfc_async_crq *)get_zeroed_page(GFP_KERNEL);\r\nif (!async_q->msgs) {\r\ndev_err(dev, "Couldn't allocate async queue.\n");\r\ngoto nomem;\r\n}\r\nasync_q->size = PAGE_SIZE / sizeof(struct ibmvfc_async_crq);\r\nasync_q->msg_token = dma_map_single(dev, async_q->msgs,\r\nasync_q->size * sizeof(*async_q->msgs),\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(dev, async_q->msg_token)) {\r\ndev_err(dev, "Failed to map async queue\n");\r\ngoto free_async_crq;\r\n}\r\nvhost->sg_pool = dma_pool_create(IBMVFC_NAME, dev,\r\nSG_ALL * sizeof(struct srp_direct_buf),\r\nsizeof(struct srp_direct_buf), 0);\r\nif (!vhost->sg_pool) {\r\ndev_err(dev, "Failed to allocate sg pool\n");\r\ngoto unmap_async_crq;\r\n}\r\nvhost->login_buf = dma_alloc_coherent(dev, sizeof(*vhost->login_buf),\r\n&vhost->login_buf_dma, GFP_KERNEL);\r\nif (!vhost->login_buf) {\r\ndev_err(dev, "Couldn't allocate NPIV login buffer\n");\r\ngoto free_sg_pool;\r\n}\r\nvhost->disc_buf_sz = sizeof(vhost->disc_buf->scsi_id[0]) * max_targets;\r\nvhost->disc_buf = dma_alloc_coherent(dev, vhost->disc_buf_sz,\r\n&vhost->disc_buf_dma, GFP_KERNEL);\r\nif (!vhost->disc_buf) {\r\ndev_err(dev, "Couldn't allocate Discover Targets buffer\n");\r\ngoto free_login_buffer;\r\n}\r\nvhost->trace = kcalloc(IBMVFC_NUM_TRACE_ENTRIES,\r\nsizeof(struct ibmvfc_trace_entry), GFP_KERNEL);\r\nif (!vhost->trace)\r\ngoto free_disc_buffer;\r\nvhost->tgt_pool = mempool_create_kmalloc_pool(IBMVFC_TGT_MEMPOOL_SZ,\r\nsizeof(struct ibmvfc_target));\r\nif (!vhost->tgt_pool) {\r\ndev_err(dev, "Couldn't allocate target memory pool\n");\r\ngoto free_trace;\r\n}\r\nLEAVE;\r\nreturn 0;\r\nfree_trace:\r\nkfree(vhost->trace);\r\nfree_disc_buffer:\r\ndma_free_coherent(dev, vhost->disc_buf_sz, vhost->disc_buf,\r\nvhost->disc_buf_dma);\r\nfree_login_buffer:\r\ndma_free_coherent(dev, sizeof(*vhost->login_buf),\r\nvhost->login_buf, vhost->login_buf_dma);\r\nfree_sg_pool:\r\ndma_pool_destroy(vhost->sg_pool);\r\nunmap_async_crq:\r\ndma_unmap_single(dev, async_q->msg_token,\r\nasync_q->size * sizeof(*async_q->msgs), DMA_BIDIRECTIONAL);\r\nfree_async_crq:\r\nfree_page((unsigned long)async_q->msgs);\r\nnomem:\r\nLEAVE;\r\nreturn -ENOMEM;\r\n}\r\nstatic void ibmvfc_rport_add_thread(struct work_struct *work)\r\n{\r\nstruct ibmvfc_host *vhost = container_of(work, struct ibmvfc_host,\r\nrport_add_work_q);\r\nstruct ibmvfc_target *tgt;\r\nstruct fc_rport *rport;\r\nunsigned long flags;\r\nint did_work;\r\nENTER;\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\ndo {\r\ndid_work = 0;\r\nif (vhost->state != IBMVFC_ACTIVE)\r\nbreak;\r\nlist_for_each_entry(tgt, &vhost->targets, queue) {\r\nif (tgt->add_rport) {\r\ndid_work = 1;\r\ntgt->add_rport = 0;\r\nkref_get(&tgt->kref);\r\nrport = tgt->rport;\r\nif (!rport) {\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nibmvfc_tgt_add_rport(tgt);\r\n} else if (get_device(&rport->dev)) {\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\ntgt_dbg(tgt, "Setting rport roles\n");\r\nfc_remote_port_rolechg(rport, tgt->ids.roles);\r\nput_device(&rport->dev);\r\n}\r\nkref_put(&tgt->kref, ibmvfc_release_tgt);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nbreak;\r\n}\r\n}\r\n} while(did_work);\r\nif (vhost->state == IBMVFC_ACTIVE)\r\nvhost->scan_complete = 1;\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nLEAVE;\r\n}\r\nstatic int ibmvfc_probe(struct vio_dev *vdev, const struct vio_device_id *id)\r\n{\r\nstruct ibmvfc_host *vhost;\r\nstruct Scsi_Host *shost;\r\nstruct device *dev = &vdev->dev;\r\nint rc = -ENOMEM;\r\nENTER;\r\nshost = scsi_host_alloc(&driver_template, sizeof(*vhost));\r\nif (!shost) {\r\ndev_err(dev, "Couldn't allocate host data\n");\r\ngoto out;\r\n}\r\nshost->transportt = ibmvfc_transport_template;\r\nshost->can_queue = max_requests;\r\nshost->max_lun = max_lun;\r\nshost->max_id = max_targets;\r\nshost->max_sectors = IBMVFC_MAX_SECTORS;\r\nshost->max_cmd_len = IBMVFC_MAX_CDB_LEN;\r\nshost->unique_id = shost->host_no;\r\nvhost = shost_priv(shost);\r\nINIT_LIST_HEAD(&vhost->sent);\r\nINIT_LIST_HEAD(&vhost->free);\r\nINIT_LIST_HEAD(&vhost->targets);\r\nsprintf(vhost->name, IBMVFC_NAME);\r\nvhost->host = shost;\r\nvhost->dev = dev;\r\nvhost->partition_number = -1;\r\nvhost->log_level = log_level;\r\nvhost->task_set = 1;\r\nstrcpy(vhost->partition_name, "UNKNOWN");\r\ninit_waitqueue_head(&vhost->work_wait_q);\r\ninit_waitqueue_head(&vhost->init_wait_q);\r\nINIT_WORK(&vhost->rport_add_work_q, ibmvfc_rport_add_thread);\r\nmutex_init(&vhost->passthru_mutex);\r\nif ((rc = ibmvfc_alloc_mem(vhost)))\r\ngoto free_scsi_host;\r\nvhost->work_thread = kthread_run(ibmvfc_work, vhost, "%s_%d", IBMVFC_NAME,\r\nshost->host_no);\r\nif (IS_ERR(vhost->work_thread)) {\r\ndev_err(dev, "Couldn't create kernel thread: %ld\n",\r\nPTR_ERR(vhost->work_thread));\r\ngoto free_host_mem;\r\n}\r\nif ((rc = ibmvfc_init_crq(vhost))) {\r\ndev_err(dev, "Couldn't initialize crq. rc=%d\n", rc);\r\ngoto kill_kthread;\r\n}\r\nif ((rc = ibmvfc_init_event_pool(vhost))) {\r\ndev_err(dev, "Couldn't initialize event pool. rc=%d\n", rc);\r\ngoto release_crq;\r\n}\r\nif ((rc = scsi_add_host(shost, dev)))\r\ngoto release_event_pool;\r\nfc_host_dev_loss_tmo(shost) = IBMVFC_DEV_LOSS_TMO;\r\nif ((rc = ibmvfc_create_trace_file(&shost->shost_dev.kobj,\r\n&ibmvfc_trace_attr))) {\r\ndev_err(dev, "Failed to create trace file. rc=%d\n", rc);\r\ngoto remove_shost;\r\n}\r\nif (shost_to_fc_host(shost)->rqst_q)\r\nblk_queue_max_segments(shost_to_fc_host(shost)->rqst_q, 1);\r\ndev_set_drvdata(dev, vhost);\r\nspin_lock(&ibmvfc_driver_lock);\r\nlist_add_tail(&vhost->queue, &ibmvfc_head);\r\nspin_unlock(&ibmvfc_driver_lock);\r\nibmvfc_send_crq_init(vhost);\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nremove_shost:\r\nscsi_remove_host(shost);\r\nrelease_event_pool:\r\nibmvfc_free_event_pool(vhost);\r\nrelease_crq:\r\nibmvfc_release_crq_queue(vhost);\r\nkill_kthread:\r\nkthread_stop(vhost->work_thread);\r\nfree_host_mem:\r\nibmvfc_free_mem(vhost);\r\nfree_scsi_host:\r\nscsi_host_put(shost);\r\nout:\r\nLEAVE;\r\nreturn rc;\r\n}\r\nstatic int ibmvfc_remove(struct vio_dev *vdev)\r\n{\r\nstruct ibmvfc_host *vhost = dev_get_drvdata(&vdev->dev);\r\nunsigned long flags;\r\nENTER;\r\nibmvfc_remove_trace_file(&vhost->host->shost_dev.kobj, &ibmvfc_trace_attr);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nibmvfc_link_down(vhost, IBMVFC_HOST_OFFLINE);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nibmvfc_wait_while_resetting(vhost);\r\nibmvfc_release_crq_queue(vhost);\r\nkthread_stop(vhost->work_thread);\r\nfc_remove_host(vhost->host);\r\nscsi_remove_host(vhost->host);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nibmvfc_purge_requests(vhost, DID_ERROR);\r\nibmvfc_free_event_pool(vhost);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nibmvfc_free_mem(vhost);\r\nspin_lock(&ibmvfc_driver_lock);\r\nlist_del(&vhost->queue);\r\nspin_unlock(&ibmvfc_driver_lock);\r\nscsi_host_put(vhost->host);\r\nLEAVE;\r\nreturn 0;\r\n}\r\nstatic int ibmvfc_resume(struct device *dev)\r\n{\r\nunsigned long flags;\r\nstruct ibmvfc_host *vhost = dev_get_drvdata(dev);\r\nstruct vio_dev *vdev = to_vio_dev(dev);\r\nspin_lock_irqsave(vhost->host->host_lock, flags);\r\nvio_disable_interrupts(vdev);\r\ntasklet_schedule(&vhost->tasklet);\r\nspin_unlock_irqrestore(vhost->host->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic unsigned long ibmvfc_get_desired_dma(struct vio_dev *vdev)\r\n{\r\nunsigned long pool_dma = max_requests * sizeof(union ibmvfc_iu);\r\nreturn pool_dma + ((512 * 1024) * driver_template.cmd_per_lun);\r\n}\r\nstatic int __init ibmvfc_module_init(void)\r\n{\r\nint rc;\r\nif (!firmware_has_feature(FW_FEATURE_VIO))\r\nreturn -ENODEV;\r\nprintk(KERN_INFO IBMVFC_NAME": IBM Virtual Fibre Channel Driver version: %s %s\n",\r\nIBMVFC_DRIVER_VERSION, IBMVFC_DRIVER_DATE);\r\nibmvfc_transport_template = fc_attach_transport(&ibmvfc_transport_functions);\r\nif (!ibmvfc_transport_template)\r\nreturn -ENOMEM;\r\nrc = vio_register_driver(&ibmvfc_driver);\r\nif (rc)\r\nfc_release_transport(ibmvfc_transport_template);\r\nreturn rc;\r\n}\r\nstatic void __exit ibmvfc_module_exit(void)\r\n{\r\nvio_unregister_driver(&ibmvfc_driver);\r\nfc_release_transport(ibmvfc_transport_template);\r\n}
