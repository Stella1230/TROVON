void snd_request_card(int card)\r\n{\r\nif (snd_card_locked(card))\r\nreturn;\r\nif (card < 0 || card >= cards_limit)\r\nreturn;\r\nrequest_module("snd-card-%i", card);\r\n}\r\nstatic void snd_request_other(int minor)\r\n{\r\nchar *str;\r\nswitch (minor) {\r\ncase SNDRV_MINOR_SEQUENCER: str = "snd-seq"; break;\r\ncase SNDRV_MINOR_TIMER: str = "snd-timer"; break;\r\ndefault: return;\r\n}\r\nrequest_module(str);\r\n}\r\nvoid *snd_lookup_minor_data(unsigned int minor, int type)\r\n{\r\nstruct snd_minor *mreg;\r\nvoid *private_data;\r\nif (minor >= ARRAY_SIZE(snd_minors))\r\nreturn NULL;\r\nmutex_lock(&sound_mutex);\r\nmreg = snd_minors[minor];\r\nif (mreg && mreg->type == type)\r\nprivate_data = mreg->private_data;\r\nelse\r\nprivate_data = NULL;\r\nmutex_unlock(&sound_mutex);\r\nreturn private_data;\r\n}\r\nstatic struct snd_minor *autoload_device(unsigned int minor)\r\n{\r\nint dev;\r\nmutex_unlock(&sound_mutex);\r\ndev = SNDRV_MINOR_DEVICE(minor);\r\nif (dev == SNDRV_MINOR_CONTROL) {\r\nint card = SNDRV_MINOR_CARD(minor);\r\nif (snd_cards[card] == NULL)\r\nsnd_request_card(card);\r\n} else if (dev == SNDRV_MINOR_GLOBAL) {\r\nsnd_request_other(minor);\r\n}\r\nmutex_lock(&sound_mutex);\r\nreturn snd_minors[minor];\r\n}\r\nstatic int snd_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct snd_minor *mptr = NULL;\r\nconst struct file_operations *old_fops;\r\nint err = 0;\r\nif (minor >= ARRAY_SIZE(snd_minors))\r\nreturn -ENODEV;\r\nmutex_lock(&sound_mutex);\r\nmptr = snd_minors[minor];\r\nif (mptr == NULL) {\r\nmptr = autoload_device(minor);\r\nif (!mptr) {\r\nmutex_unlock(&sound_mutex);\r\nreturn -ENODEV;\r\n}\r\n}\r\nold_fops = file->f_op;\r\nfile->f_op = fops_get(mptr->f_ops);\r\nif (file->f_op == NULL) {\r\nfile->f_op = old_fops;\r\nerr = -ENODEV;\r\n}\r\nmutex_unlock(&sound_mutex);\r\nif (err < 0)\r\nreturn err;\r\nif (file->f_op->open) {\r\nerr = file->f_op->open(inode, file);\r\nif (err) {\r\nfops_put(file->f_op);\r\nfile->f_op = fops_get(old_fops);\r\n}\r\n}\r\nfops_put(old_fops);\r\nreturn err;\r\n}\r\nstatic int snd_find_free_minor(int type)\r\n{\r\nint minor;\r\nif (type == SNDRV_DEVICE_TYPE_SEQUENCER)\r\nreturn SNDRV_MINOR_SEQUENCER;\r\nif (type == SNDRV_DEVICE_TYPE_TIMER)\r\nreturn SNDRV_MINOR_TIMER;\r\nfor (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor) {\r\nif (SNDRV_MINOR_DEVICE(minor) == SNDRV_MINOR_CONTROL)\r\ncontinue;\r\nif (minor == SNDRV_MINOR_SEQUENCER ||\r\nminor == SNDRV_MINOR_TIMER)\r\ncontinue;\r\nif (!snd_minors[minor])\r\nreturn minor;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int snd_kernel_minor(int type, struct snd_card *card, int dev)\r\n{\r\nint minor;\r\nswitch (type) {\r\ncase SNDRV_DEVICE_TYPE_SEQUENCER:\r\ncase SNDRV_DEVICE_TYPE_TIMER:\r\nminor = type;\r\nbreak;\r\ncase SNDRV_DEVICE_TYPE_CONTROL:\r\nif (snd_BUG_ON(!card))\r\nreturn -EINVAL;\r\nminor = SNDRV_MINOR(card->number, type);\r\nbreak;\r\ncase SNDRV_DEVICE_TYPE_HWDEP:\r\ncase SNDRV_DEVICE_TYPE_RAWMIDI:\r\ncase SNDRV_DEVICE_TYPE_PCM_PLAYBACK:\r\ncase SNDRV_DEVICE_TYPE_PCM_CAPTURE:\r\nif (snd_BUG_ON(!card))\r\nreturn -EINVAL;\r\nminor = SNDRV_MINOR(card->number, type + dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (snd_BUG_ON(minor < 0 || minor >= SNDRV_OS_MINORS))\r\nreturn -EINVAL;\r\nreturn minor;\r\n}\r\nint snd_register_device_for_dev(int type, struct snd_card *card, int dev,\r\nconst struct file_operations *f_ops,\r\nvoid *private_data,\r\nconst char *name, struct device *device)\r\n{\r\nint minor;\r\nstruct snd_minor *preg;\r\nif (snd_BUG_ON(!name))\r\nreturn -EINVAL;\r\npreg = kmalloc(sizeof *preg, GFP_KERNEL);\r\nif (preg == NULL)\r\nreturn -ENOMEM;\r\npreg->type = type;\r\npreg->card = card ? card->number : -1;\r\npreg->device = dev;\r\npreg->f_ops = f_ops;\r\npreg->private_data = private_data;\r\nmutex_lock(&sound_mutex);\r\n#ifdef CONFIG_SND_DYNAMIC_MINORS\r\nminor = snd_find_free_minor(type);\r\n#else\r\nminor = snd_kernel_minor(type, card, dev);\r\nif (minor >= 0 && snd_minors[minor])\r\nminor = -EBUSY;\r\n#endif\r\nif (minor < 0) {\r\nmutex_unlock(&sound_mutex);\r\nkfree(preg);\r\nreturn minor;\r\n}\r\nsnd_minors[minor] = preg;\r\npreg->dev = device_create(sound_class, device, MKDEV(major, minor),\r\nprivate_data, "%s", name);\r\nif (IS_ERR(preg->dev)) {\r\nsnd_minors[minor] = NULL;\r\nmutex_unlock(&sound_mutex);\r\nminor = PTR_ERR(preg->dev);\r\nkfree(preg);\r\nreturn minor;\r\n}\r\nmutex_unlock(&sound_mutex);\r\nreturn 0;\r\n}\r\nstatic int find_snd_minor(int type, struct snd_card *card, int dev)\r\n{\r\nint cardnum, minor;\r\nstruct snd_minor *mptr;\r\ncardnum = card ? card->number : -1;\r\nfor (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor)\r\nif ((mptr = snd_minors[minor]) != NULL &&\r\nmptr->type == type &&\r\nmptr->card == cardnum &&\r\nmptr->device == dev)\r\nreturn minor;\r\nreturn -1;\r\n}\r\nint snd_unregister_device(int type, struct snd_card *card, int dev)\r\n{\r\nint minor;\r\nmutex_lock(&sound_mutex);\r\nminor = find_snd_minor(type, card, dev);\r\nif (minor < 0) {\r\nmutex_unlock(&sound_mutex);\r\nreturn -EINVAL;\r\n}\r\ndevice_destroy(sound_class, MKDEV(major, minor));\r\nkfree(snd_minors[minor]);\r\nsnd_minors[minor] = NULL;\r\nmutex_unlock(&sound_mutex);\r\nreturn 0;\r\n}\r\nint snd_add_device_sysfs_file(int type, struct snd_card *card, int dev,\r\nstruct device_attribute *attr)\r\n{\r\nint minor, ret = -EINVAL;\r\nstruct device *d;\r\nmutex_lock(&sound_mutex);\r\nminor = find_snd_minor(type, card, dev);\r\nif (minor >= 0 && (d = snd_minors[minor]->dev) != NULL)\r\nret = device_create_file(d, attr);\r\nmutex_unlock(&sound_mutex);\r\nreturn ret;\r\n}\r\nstatic const char *snd_device_type_name(int type)\r\n{\r\nswitch (type) {\r\ncase SNDRV_DEVICE_TYPE_CONTROL:\r\nreturn "control";\r\ncase SNDRV_DEVICE_TYPE_HWDEP:\r\nreturn "hardware dependent";\r\ncase SNDRV_DEVICE_TYPE_RAWMIDI:\r\nreturn "raw midi";\r\ncase SNDRV_DEVICE_TYPE_PCM_PLAYBACK:\r\nreturn "digital audio playback";\r\ncase SNDRV_DEVICE_TYPE_PCM_CAPTURE:\r\nreturn "digital audio capture";\r\ncase SNDRV_DEVICE_TYPE_SEQUENCER:\r\nreturn "sequencer";\r\ncase SNDRV_DEVICE_TYPE_TIMER:\r\nreturn "timer";\r\ndefault:\r\nreturn "?";\r\n}\r\n}\r\nstatic void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nint minor;\r\nstruct snd_minor *mptr;\r\nmutex_lock(&sound_mutex);\r\nfor (minor = 0; minor < SNDRV_OS_MINORS; ++minor) {\r\nif (!(mptr = snd_minors[minor]))\r\ncontinue;\r\nif (mptr->card >= 0) {\r\nif (mptr->device >= 0)\r\nsnd_iprintf(buffer, "%3i: [%2i-%2i]: %s\n",\r\nminor, mptr->card, mptr->device,\r\nsnd_device_type_name(mptr->type));\r\nelse\r\nsnd_iprintf(buffer, "%3i: [%2i] : %s\n",\r\nminor, mptr->card,\r\nsnd_device_type_name(mptr->type));\r\n} else\r\nsnd_iprintf(buffer, "%3i: : %s\n", minor,\r\nsnd_device_type_name(mptr->type));\r\n}\r\nmutex_unlock(&sound_mutex);\r\n}\r\nint __init snd_minor_info_init(void)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = snd_info_create_module_entry(THIS_MODULE, "devices", NULL);\r\nif (entry) {\r\nentry->c.text.read = snd_minor_info_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nsnd_minor_info_entry = entry;\r\nreturn 0;\r\n}\r\nint __exit snd_minor_info_done(void)\r\n{\r\nsnd_info_free_entry(snd_minor_info_entry);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_sound_init(void)\r\n{\r\nsnd_major = major;\r\nsnd_ecards_limit = cards_limit;\r\nif (register_chrdev(major, "alsa", &snd_fops)) {\r\nsnd_printk(KERN_ERR "unable to register native major device number %d\n", major);\r\nreturn -EIO;\r\n}\r\nif (snd_info_init() < 0) {\r\nunregister_chrdev(major, "alsa");\r\nreturn -ENOMEM;\r\n}\r\nsnd_info_minor_register();\r\n#ifndef MODULE\r\nprintk(KERN_INFO "Advanced Linux Sound Architecture Driver Version " CONFIG_SND_VERSION CONFIG_SND_DATE ".\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_sound_exit(void)\r\n{\r\nsnd_info_minor_unregister();\r\nsnd_info_done();\r\nunregister_chrdev(major, "alsa");\r\n}
