static uint32_t GetFifoSize(dmacHw_HANDLE_t handle\r\n) {\r\nuint32_t val = 0;\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\ndmacHw_MISC_t *pMiscReg =\r\n(dmacHw_MISC_t *) dmacHw_REG_MISC_BASE(pCblk->module);\r\nswitch (pCblk->channel) {\r\ncase 0:\r\nval = (pMiscReg->CompParm2.lo & 0x70000000) >> 28;\r\nbreak;\r\ncase 1:\r\nval = (pMiscReg->CompParm3.hi & 0x70000000) >> 28;\r\nbreak;\r\ncase 2:\r\nval = (pMiscReg->CompParm3.lo & 0x70000000) >> 28;\r\nbreak;\r\ncase 3:\r\nval = (pMiscReg->CompParm4.hi & 0x70000000) >> 28;\r\nbreak;\r\ncase 4:\r\nval = (pMiscReg->CompParm4.lo & 0x70000000) >> 28;\r\nbreak;\r\ncase 5:\r\nval = (pMiscReg->CompParm5.hi & 0x70000000) >> 28;\r\nbreak;\r\ncase 6:\r\nval = (pMiscReg->CompParm5.lo & 0x70000000) >> 28;\r\nbreak;\r\ncase 7:\r\nval = (pMiscReg->CompParm6.hi & 0x70000000) >> 28;\r\nbreak;\r\n}\r\nif (val <= 0x4) {\r\nreturn 8 << val;\r\n} else {\r\ndmacHw_ASSERT(0);\r\n}\r\nreturn 0;\r\n}\r\nvoid dmacHw_initiateTransfer(dmacHw_HANDLE_t handle,\r\ndmacHw_CONFIG_t *pConfig,\r\nvoid *pDescriptor\r\n) {\r\ndmacHw_DESC_RING_t *pRing;\r\ndmacHw_DESC_t *pProg;\r\ndmacHw_CBLK_t *pCblk;\r\npCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\npRing = dmacHw_GET_DESC_RING(pDescriptor);\r\nif (CHANNEL_BUSY(pCblk->module, pCblk->channel)) {\r\nreturn;\r\n}\r\nif (pCblk->varDataStarted) {\r\nif (pCblk->descUpdated) {\r\npCblk->descUpdated = 0;\r\npProg =\r\n(dmacHw_DESC_t *) ((uint32_t)\r\ndmacHw_REG_LLP(pCblk->module,\r\npCblk->channel) +\r\npRing->virt2PhyOffset);\r\nif (!(pProg->ctl.hi & dmacHw_REG_CTL_DONE)) {\r\ndmacHw_SET_SAR(pCblk->module, pCblk->channel,\r\npProg->sar);\r\ndmacHw_SET_DAR(pCblk->module, pCblk->channel,\r\npProg->dar);\r\ndmacHw_REG_CTL_LO(pCblk->module,\r\npCblk->channel) =\r\npProg->ctl.lo;\r\ndmacHw_REG_CTL_HI(pCblk->module,\r\npCblk->channel) =\r\npProg->ctl.hi;\r\n} else if (pProg == (dmacHw_DESC_t *) pRing->pEnd->llp) {\r\nreturn;\r\n} else {\r\ndmacHw_ASSERT(0);\r\n}\r\n} else {\r\nreturn;\r\n}\r\n} else {\r\nif (pConfig->transferMode == dmacHw_TRANSFER_MODE_PERIODIC) {\r\npProg = pRing->pHead;\r\ndmacHw_NEXT_DESC(pRing, pHead);\r\n} else {\r\nif (pRing->pEnd == NULL) {\r\nreturn;\r\n}\r\npProg = pRing->pProg;\r\nif (pConfig->transferMode ==\r\ndmacHw_TRANSFER_MODE_CONTINUOUS) {\r\ndmacHw_ASSERT((dmacHw_DESC_t *) pRing->pEnd->\r\nllp == pRing->pProg);\r\ndmacHw_ASSERT((dmacHw_DESC_t *) pRing->pProg ==\r\npRing->pHead);\r\ndo {\r\npRing->pProg->ctl.lo |=\r\n(dmacHw_REG_CTL_LLP_DST_EN |\r\ndmacHw_REG_CTL_LLP_SRC_EN);\r\npRing->pProg =\r\n(dmacHw_DESC_t *) pRing->pProg->llp;\r\n} while (pRing->pProg != pRing->pHead);\r\n} else {\r\nwhile (pRing->pProg != pRing->pEnd) {\r\npRing->pProg->ctl.lo |=\r\n(dmacHw_REG_CTL_LLP_DST_EN |\r\ndmacHw_REG_CTL_LLP_SRC_EN);\r\npRing->pProg =\r\n(dmacHw_DESC_t *) pRing->pProg->llp;\r\n}\r\n}\r\n}\r\ndmacHw_SET_SAR(pCblk->module, pCblk->channel, pProg->sar);\r\ndmacHw_SET_DAR(pCblk->module, pCblk->channel, pProg->dar);\r\ndmacHw_SET_LLP(pCblk->module, pCblk->channel,\r\n(uint32_t) pProg - pRing->virt2PhyOffset);\r\ndmacHw_REG_CTL_LO(pCblk->module, pCblk->channel) =\r\npProg->ctl.lo;\r\ndmacHw_REG_CTL_HI(pCblk->module, pCblk->channel) =\r\npProg->ctl.hi;\r\nif (pRing->pEnd) {\r\npRing->pProg = (dmacHw_DESC_t *) pRing->pEnd->llp;\r\n}\r\npRing->pEnd = (dmacHw_DESC_t *) NULL;\r\n}\r\ndmacHw_DMA_START(pCblk->module, pCblk->channel);\r\n}\r\nvoid dmacHw_initDma(void)\r\n{\r\nuint32_t i = 0;\r\ndmaChannelCount_0 = dmacHw_GET_NUM_CHANNEL(0);\r\ndmaChannelCount_1 = dmacHw_GET_NUM_CHANNEL(1);\r\nchipcHw_busInterfaceClockEnable(chipcHw_REG_BUS_CLOCK_DMAC0);\r\nchipcHw_busInterfaceClockEnable(chipcHw_REG_BUS_CLOCK_DMAC1);\r\nif ((dmaChannelCount_0 + dmaChannelCount_1) > dmacHw_MAX_CHANNEL_COUNT) {\r\ndmacHw_ASSERT(0);\r\n}\r\nmemset((void *)dmacHw_gCblk, 0,\r\nsizeof(dmacHw_CBLK_t) * (dmaChannelCount_0 + dmaChannelCount_1));\r\nfor (i = 0; i < dmaChannelCount_0; i++) {\r\ndmacHw_gCblk[i].module = 0;\r\ndmacHw_gCblk[i].channel = i;\r\n}\r\nfor (i = 0; i < dmaChannelCount_1; i++) {\r\ndmacHw_gCblk[i + dmaChannelCount_0].module = 1;\r\ndmacHw_gCblk[i + dmaChannelCount_0].channel = i;\r\n}\r\n}\r\nvoid dmacHw_exitDma(void)\r\n{\r\nchipcHw_busInterfaceClockDisable(chipcHw_REG_BUS_CLOCK_DMAC0);\r\nchipcHw_busInterfaceClockDisable(chipcHw_REG_BUS_CLOCK_DMAC1);\r\n}\r\ndmacHw_HANDLE_t dmacHw_getChannelHandle(dmacHw_ID_t channelId\r\n) {\r\nint idx;\r\nswitch ((channelId >> 8)) {\r\ncase 0:\r\ndmacHw_ASSERT((channelId & 0xff) < dmaChannelCount_0);\r\nidx = (channelId & 0xff);\r\nbreak;\r\ncase 1:\r\ndmacHw_ASSERT((channelId & 0xff) < dmaChannelCount_1);\r\nidx = dmaChannelCount_0 + (channelId & 0xff);\r\nbreak;\r\ndefault:\r\ndmacHw_ASSERT(0);\r\nreturn (dmacHw_HANDLE_t) -1;\r\n}\r\nreturn dmacHw_CBLK_TO_HANDLE(&dmacHw_gCblk[idx]);\r\n}\r\nint dmacHw_initChannel(dmacHw_HANDLE_t handle\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\nint module = pCblk->module;\r\nint channel = pCblk->channel;\r\nmemset((void *)pCblk, 0, sizeof(dmacHw_CBLK_t));\r\npCblk->module = module;\r\npCblk->channel = channel;\r\ndmacHw_DMA_ENABLE(pCblk->module);\r\ndmacHw_RESET_CONTROL_LO(pCblk->module, pCblk->channel);\r\ndmacHw_RESET_CONTROL_HI(pCblk->module, pCblk->channel);\r\ndmacHw_RESET_CONFIG_LO(pCblk->module, pCblk->channel);\r\ndmacHw_RESET_CONFIG_HI(pCblk->module, pCblk->channel);\r\ndmacHw_TRAN_INT_CLEAR(pCblk->module, pCblk->channel);\r\ndmacHw_BLOCK_INT_CLEAR(pCblk->module, pCblk->channel);\r\ndmacHw_ERROR_INT_CLEAR(pCblk->module, pCblk->channel);\r\ndmacHw_TRAN_INT_DISABLE(pCblk->module, pCblk->channel);\r\ndmacHw_BLOCK_INT_DISABLE(pCblk->module, pCblk->channel);\r\ndmacHw_STRAN_INT_DISABLE(pCblk->module, pCblk->channel);\r\ndmacHw_DTRAN_INT_DISABLE(pCblk->module, pCblk->channel);\r\ndmacHw_ERROR_INT_DISABLE(pCblk->module, pCblk->channel);\r\nreturn 0;\r\n}\r\nuint32_t dmacHw_descriptorLen(uint32_t descCnt\r\n) {\r\nreturn (descCnt * sizeof(dmacHw_DESC_t)) + sizeof(dmacHw_DESC_RING_t) +\r\nsizeof(uint32_t);\r\n}\r\nint dmacHw_initDescriptor(void *pDescriptorVirt,\r\nuint32_t descriptorPhyAddr,\r\nuint32_t len,\r\nuint32_t num\r\n) {\r\nuint32_t i;\r\ndmacHw_DESC_RING_t *pRing;\r\ndmacHw_DESC_t *pDesc;\r\nif ((uint32_t) pDescriptorVirt & 0x00000003) {\r\ndmacHw_ASSERT(0);\r\nreturn -1;\r\n}\r\nif (len < dmacHw_descriptorLen(num)) {\r\nreturn -1;\r\n}\r\npRing = dmacHw_GET_DESC_RING(pDescriptorVirt);\r\npRing->pHead =\r\n(dmacHw_DESC_t *) ((uint32_t) pRing + sizeof(dmacHw_DESC_RING_t));\r\npRing->pFree = pRing->pTail = pRing->pEnd = pRing->pHead;\r\npRing->pProg = dmacHw_DESC_INIT;\r\npDesc = pRing->pHead;\r\npRing->virt2PhyOffset = (uint32_t) pDescriptorVirt - descriptorPhyAddr;\r\nfor (i = 0; i < num - 1; i++) {\r\nmemset((void *)pDesc, 0, sizeof(dmacHw_DESC_t));\r\npDesc->llpPhy = (uint32_t) (pDesc + 1) - pRing->virt2PhyOffset;\r\npDesc->llp = (uint32_t) (pDesc + 1);\r\npDesc->ctl.hi = dmacHw_DESC_FREE;\r\npDesc++;\r\n}\r\nmemset((void *)pDesc, 0, sizeof(dmacHw_DESC_t));\r\npDesc->llpPhy = (uint32_t) pRing->pHead - pRing->virt2PhyOffset;\r\npDesc->llp = (uint32_t) pRing->pHead;\r\npDesc->ctl.hi = dmacHw_DESC_FREE;\r\npRing->num = num;\r\nreturn 0;\r\n}\r\nint dmacHw_configChannel(dmacHw_HANDLE_t handle,\r\ndmacHw_CONFIG_t *pConfig\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\nuint32_t cfgHigh = 0;\r\nint srcTrSize;\r\nint dstTrSize;\r\npCblk->varDataStarted = 0;\r\npCblk->userData = NULL;\r\ncfgHigh =\r\ndmacHw_REG_CFG_HI_FIFO_ENOUGH | dmacHw_REG_CFG_HI_AHB_HPROT_1 |\r\ndmacHw_SRC_PERI_INTF(pConfig->\r\nsrcPeripheralPort) |\r\ndmacHw_DST_PERI_INTF(pConfig->dstPeripheralPort);\r\ndmacHw_SET_CHANNEL_PRIORITY(pCblk->module, pCblk->channel,\r\npConfig->channelPriority);\r\nif (pConfig->dstStatusRegisterAddress != 0) {\r\ncfgHigh |= dmacHw_REG_CFG_HI_UPDATE_DST_STAT;\r\ndmacHw_SET_DSTATAR(pCblk->module, pCblk->channel,\r\npConfig->dstStatusRegisterAddress);\r\n}\r\nif (pConfig->srcStatusRegisterAddress != 0) {\r\ncfgHigh |= dmacHw_REG_CFG_HI_UPDATE_SRC_STAT;\r\ndmacHw_SET_SSTATAR(pCblk->module, pCblk->channel,\r\npConfig->srcStatusRegisterAddress);\r\n}\r\ndmacHw_GET_CONFIG_HI(pCblk->module, pCblk->channel) = cfgHigh;\r\ndmacHw_TRAN_INT_CLEAR(pCblk->module, pCblk->channel);\r\ndmacHw_BLOCK_INT_CLEAR(pCblk->module, pCblk->channel);\r\ndmacHw_ERROR_INT_CLEAR(pCblk->module, pCblk->channel);\r\nif (pConfig->blockTransferInterrupt == dmacHw_INTERRUPT_ENABLE) {\r\ndmacHw_BLOCK_INT_ENABLE(pCblk->module, pCblk->channel);\r\n} else {\r\ndmacHw_BLOCK_INT_DISABLE(pCblk->module, pCblk->channel);\r\n}\r\nif (pConfig->completeTransferInterrupt == dmacHw_INTERRUPT_ENABLE) {\r\ndmacHw_TRAN_INT_ENABLE(pCblk->module, pCblk->channel);\r\n} else {\r\ndmacHw_TRAN_INT_DISABLE(pCblk->module, pCblk->channel);\r\n}\r\nif (pConfig->errorInterrupt == dmacHw_INTERRUPT_ENABLE) {\r\ndmacHw_ERROR_INT_ENABLE(pCblk->module, pCblk->channel);\r\n} else {\r\ndmacHw_ERROR_INT_DISABLE(pCblk->module, pCblk->channel);\r\n}\r\nif (pConfig->srcGatherWidth) {\r\nsrcTrSize =\r\ndmacHw_GetTrWidthInBytes(pConfig->srcMaxTransactionWidth);\r\nif (!\r\n((pConfig->srcGatherWidth % srcTrSize)\r\n&& (pConfig->srcGatherJump % srcTrSize))) {\r\ndmacHw_REG_SGR_LO(pCblk->module, pCblk->channel) =\r\n((pConfig->srcGatherWidth /\r\nsrcTrSize) << 20) | (pConfig->srcGatherJump /\r\nsrcTrSize);\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nif (pConfig->dstScatterWidth) {\r\ndstTrSize =\r\ndmacHw_GetTrWidthInBytes(pConfig->dstMaxTransactionWidth);\r\nif (!\r\n((pConfig->dstScatterWidth % dstTrSize)\r\n&& (pConfig->dstScatterJump % dstTrSize))) {\r\ndmacHw_REG_DSR_LO(pCblk->module, pCblk->channel) =\r\n((pConfig->dstScatterWidth /\r\ndstTrSize) << 20) | (pConfig->dstScatterJump /\r\ndstTrSize);\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\ndmacHw_TRANSFER_STATUS_e dmacHw_transferCompleted(dmacHw_HANDLE_t handle\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\nif (CHANNEL_BUSY(pCblk->module, pCblk->channel)) {\r\nreturn dmacHw_TRANSFER_STATUS_BUSY;\r\n} else if (dmacHw_REG_INT_RAW_ERROR(pCblk->module) &\r\n(0x00000001 << pCblk->channel)) {\r\nreturn dmacHw_TRANSFER_STATUS_ERROR;\r\n}\r\nreturn dmacHw_TRANSFER_STATUS_DONE;\r\n}\r\nint dmacHw_setDataDescriptor(dmacHw_CONFIG_t *pConfig,\r\nvoid *pDescriptor,\r\nvoid *pSrcAddr,\r\nvoid *pDstAddr,\r\nsize_t dataLen\r\n) {\r\ndmacHw_TRANSACTION_WIDTH_e dstTrWidth;\r\ndmacHw_TRANSACTION_WIDTH_e srcTrWidth;\r\ndmacHw_DESC_RING_t *pRing = dmacHw_GET_DESC_RING(pDescriptor);\r\ndmacHw_DESC_t *pStart;\r\ndmacHw_DESC_t *pProg;\r\nint srcTs = 0;\r\nint blkTs = 0;\r\nint oddSize = 0;\r\nint descCount = 0;\r\nint count = 0;\r\nint dstTrSize = 0;\r\nint srcTrSize = 0;\r\nuint32_t maxBlockSize = dmacHw_MAX_BLOCKSIZE;\r\ndstTrSize = dmacHw_GetTrWidthInBytes(pConfig->dstMaxTransactionWidth);\r\nsrcTrSize = dmacHw_GetTrWidthInBytes(pConfig->srcMaxTransactionWidth);\r\nif ((pSrcAddr == NULL) || (pDstAddr == NULL) || (dataLen == 0)) {\r\nreturn -1;\r\n}\r\nif ((pConfig->srcGatherWidth % srcTrSize)\r\n|| (pConfig->dstScatterWidth % dstTrSize)) {\r\nreturn -2;\r\n}\r\ndstTrWidth = pConfig->dstMaxTransactionWidth;\r\nwhile (dmacHw_ADDRESS_MASK(dstTrSize) & (uint32_t) pDstAddr) {\r\ndstTrWidth = dmacHw_GetNextTrWidth(dstTrWidth);\r\ndstTrSize = dmacHw_GetTrWidthInBytes(dstTrWidth);\r\n}\r\nsrcTrWidth = pConfig->srcMaxTransactionWidth;\r\nwhile (dmacHw_ADDRESS_MASK(srcTrSize) & (uint32_t) pSrcAddr) {\r\nsrcTrWidth = dmacHw_GetNextTrWidth(srcTrWidth);\r\nsrcTrSize = dmacHw_GetTrWidthInBytes(srcTrWidth);\r\n}\r\nif (pConfig->maxDataPerBlock\r\n&& ((pConfig->maxDataPerBlock / srcTrSize) <\r\ndmacHw_MAX_BLOCKSIZE)) {\r\nmaxBlockSize = pConfig->maxDataPerBlock / srcTrSize;\r\n}\r\nsrcTs = dataLen / srcTrSize;\r\nif (srcTs && (dstTrSize > srcTrSize)) {\r\noddSize = dataLen % dstTrSize;\r\nsrcTs = srcTs - (oddSize / srcTrSize);\r\n} else {\r\noddSize = dataLen % srcTrSize;\r\n}\r\nif (oddSize) {\r\ndescCount++;\r\n}\r\nif (srcTs) {\r\ndescCount += ((srcTs - 1) / maxBlockSize) + 1;\r\n}\r\npProg = pRing->pHead;\r\nfor (count = 0; (descCount <= pRing->num) && (count < descCount);\r\ncount++) {\r\nif ((pProg->ctl.hi & dmacHw_DESC_FREE) == 0) {\r\nreturn -3;\r\n}\r\npProg = (dmacHw_DESC_t *) pProg->llp;\r\n}\r\npStart = pProg = pRing->pHead;\r\nwhile (count) {\r\npProg->ctl.lo = 0;\r\nif (pConfig->srcGatherWidth) {\r\npProg->ctl.lo |= dmacHw_REG_CTL_SG_ENABLE;\r\n}\r\nif (pConfig->dstScatterWidth) {\r\npProg->ctl.lo |= dmacHw_REG_CTL_DS_ENABLE;\r\n}\r\npProg->sar = (uint32_t) pSrcAddr;\r\npProg->dar = (uint32_t) pDstAddr;\r\nif (pProg == pRing->pHead) {\r\npProg->devCtl = dmacHw_FREE_USER_MEMORY;\r\n} else {\r\npProg->devCtl = 0;\r\n}\r\nblkTs = srcTs;\r\nif (count == 1) {\r\npProg->ctl.lo &=\r\n~(dmacHw_REG_CTL_LLP_DST_EN |\r\ndmacHw_REG_CTL_LLP_SRC_EN);\r\nif (oddSize) {\r\nswitch (pConfig->transferType) {\r\ncase dmacHw_TRANSFER_TYPE_PERIPHERAL_TO_MEM:\r\ndstTrWidth =\r\ndmacHw_DST_TRANSACTION_WIDTH_8;\r\nblkTs =\r\n(oddSize / srcTrSize) +\r\n((oddSize % srcTrSize) ? 1 : 0);\r\nbreak;\r\ncase dmacHw_TRANSFER_TYPE_MEM_TO_PERIPHERAL:\r\nsrcTrWidth =\r\ndmacHw_SRC_TRANSACTION_WIDTH_8;\r\nblkTs = oddSize;\r\nbreak;\r\ncase dmacHw_TRANSFER_TYPE_MEM_TO_MEM:\r\nsrcTrWidth =\r\ndmacHw_SRC_TRANSACTION_WIDTH_8;\r\ndstTrWidth =\r\ndmacHw_DST_TRANSACTION_WIDTH_8;\r\nblkTs = oddSize;\r\nbreak;\r\ncase dmacHw_TRANSFER_TYPE_PERIPHERAL_TO_PERIPHERAL:\r\nbreak;\r\n}\r\n} else {\r\nsrcTs -= blkTs;\r\n}\r\n} else {\r\nif (srcTs / maxBlockSize) {\r\nblkTs = maxBlockSize;\r\n}\r\nsrcTs -= blkTs;\r\n}\r\ndmacHw_ASSERT(blkTs > 0);\r\nif (pConfig->flowControler == dmacHw_FLOW_CONTROL_DMA) {\r\npProg->ctl.lo |= pConfig->transferType |\r\npConfig->srcUpdate |\r\npConfig->dstUpdate |\r\nsrcTrWidth |\r\ndstTrWidth |\r\npConfig->srcMaxBurstWidth |\r\npConfig->dstMaxBurstWidth |\r\npConfig->srcMasterInterface |\r\npConfig->dstMasterInterface | dmacHw_REG_CTL_INT_EN;\r\n} else {\r\nuint32_t transferType = 0;\r\nswitch (pConfig->transferType) {\r\ncase dmacHw_TRANSFER_TYPE_PERIPHERAL_TO_MEM:\r\ntransferType = dmacHw_REG_CTL_TTFC_PM_PERI;\r\nbreak;\r\ncase dmacHw_TRANSFER_TYPE_MEM_TO_PERIPHERAL:\r\ntransferType = dmacHw_REG_CTL_TTFC_MP_PERI;\r\nbreak;\r\ndefault:\r\ndmacHw_ASSERT(0);\r\n}\r\npProg->ctl.lo |= transferType |\r\npConfig->srcUpdate |\r\npConfig->dstUpdate |\r\nsrcTrWidth |\r\ndstTrWidth |\r\npConfig->srcMaxBurstWidth |\r\npConfig->dstMaxBurstWidth |\r\npConfig->srcMasterInterface |\r\npConfig->dstMasterInterface | dmacHw_REG_CTL_INT_EN;\r\n}\r\npProg->ctl.hi = blkTs & dmacHw_REG_CTL_BLOCK_TS_MASK;\r\nif (count > 1) {\r\npProg = (dmacHw_DESC_t *) pProg->llp;\r\nswitch (pConfig->transferType) {\r\ncase dmacHw_TRANSFER_TYPE_PERIPHERAL_TO_MEM:\r\nif (pConfig->dstScatterWidth) {\r\npDstAddr =\r\n(char *)pDstAddr +\r\nblkTs * srcTrSize +\r\n(((blkTs * srcTrSize) /\r\npConfig->dstScatterWidth) *\r\npConfig->dstScatterJump);\r\n} else {\r\npDstAddr =\r\n(char *)pDstAddr +\r\nblkTs * srcTrSize;\r\n}\r\nbreak;\r\ncase dmacHw_TRANSFER_TYPE_MEM_TO_PERIPHERAL:\r\nif (pConfig->srcGatherWidth) {\r\npSrcAddr =\r\n(char *)pDstAddr +\r\nblkTs * srcTrSize +\r\n(((blkTs * srcTrSize) /\r\npConfig->srcGatherWidth) *\r\npConfig->srcGatherJump);\r\n} else {\r\npSrcAddr =\r\n(char *)pSrcAddr +\r\nblkTs * srcTrSize;\r\n}\r\nbreak;\r\ncase dmacHw_TRANSFER_TYPE_MEM_TO_MEM:\r\nif (pConfig->dstScatterWidth) {\r\npDstAddr =\r\n(char *)pDstAddr +\r\nblkTs * srcTrSize +\r\n(((blkTs * srcTrSize) /\r\npConfig->dstScatterWidth) *\r\npConfig->dstScatterJump);\r\n} else {\r\npDstAddr =\r\n(char *)pDstAddr +\r\nblkTs * srcTrSize;\r\n}\r\nif (pConfig->srcGatherWidth) {\r\npSrcAddr =\r\n(char *)pDstAddr +\r\nblkTs * srcTrSize +\r\n(((blkTs * srcTrSize) /\r\npConfig->srcGatherWidth) *\r\npConfig->srcGatherJump);\r\n} else {\r\npSrcAddr =\r\n(char *)pSrcAddr +\r\nblkTs * srcTrSize;\r\n}\r\nbreak;\r\ncase dmacHw_TRANSFER_TYPE_PERIPHERAL_TO_PERIPHERAL:\r\nbreak;\r\ndefault:\r\ndmacHw_ASSERT(0);\r\n}\r\n} else {\r\ndmacHw_ASSERT(srcTs == 0);\r\n}\r\ncount--;\r\n}\r\nif (pRing->pProg == dmacHw_DESC_INIT) {\r\npRing->pProg = pStart;\r\n}\r\npRing->pEnd = pProg;\r\npRing->pHead = (dmacHw_DESC_t *) pProg->llp;\r\nif (!dmacHw_DST_IS_MEMORY(pConfig->transferType)) {\r\npRing->pTail = pRing->pHead;\r\n}\r\nreturn 0;\r\n}\r\nuint32_t dmacHw_getDmaControllerAttribute(dmacHw_HANDLE_t handle,\r\ndmacHw_CONTROLLER_ATTRIB_e attr\r\n) {\r\ndmacHw_CBLK_t *pCblk = dmacHw_HANDLE_TO_CBLK(handle);\r\nswitch (attr) {\r\ncase dmacHw_CONTROLLER_ATTRIB_CHANNEL_NUM:\r\nreturn dmacHw_GET_NUM_CHANNEL(pCblk->module);\r\ncase dmacHw_CONTROLLER_ATTRIB_CHANNEL_MAX_BLOCK_SIZE:\r\nreturn (1 <<\r\n(dmacHw_GET_MAX_BLOCK_SIZE\r\n(pCblk->module, pCblk->module) + 2)) - 8;\r\ncase dmacHw_CONTROLLER_ATTRIB_MASTER_INTF_NUM:\r\nreturn dmacHw_GET_NUM_INTERFACE(pCblk->module);\r\ncase dmacHw_CONTROLLER_ATTRIB_CHANNEL_BUS_WIDTH:\r\nreturn 32 << dmacHw_GET_CHANNEL_DATA_WIDTH(pCblk->module,\r\npCblk->channel);\r\ncase dmacHw_CONTROLLER_ATTRIB_CHANNEL_FIFO_SIZE:\r\nreturn GetFifoSize(handle);\r\n}\r\ndmacHw_ASSERT(0);\r\nreturn 0;\r\n}
