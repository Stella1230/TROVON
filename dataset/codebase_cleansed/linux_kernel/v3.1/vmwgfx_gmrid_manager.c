static int vmw_gmrid_man_get_node(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct vmwgfx_gmrid_man *gman =\r\n(struct vmwgfx_gmrid_man *)man->priv;\r\nint ret;\r\nint id;\r\nmem->mm_node = NULL;\r\ndo {\r\nif (unlikely(ida_pre_get(&gman->gmr_ida, GFP_KERNEL) == 0))\r\nreturn -ENOMEM;\r\nspin_lock(&gman->lock);\r\nret = ida_get_new(&gman->gmr_ida, &id);\r\nif (unlikely(ret == 0 && id >= gman->max_gmr_ids)) {\r\nida_remove(&gman->gmr_ida, id);\r\nspin_unlock(&gman->lock);\r\nreturn 0;\r\n}\r\nspin_unlock(&gman->lock);\r\n} while (ret == -EAGAIN);\r\nif (likely(ret == 0)) {\r\nmem->mm_node = gman;\r\nmem->start = id;\r\n}\r\nreturn ret;\r\n}\r\nstatic void vmw_gmrid_man_put_node(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct vmwgfx_gmrid_man *gman =\r\n(struct vmwgfx_gmrid_man *)man->priv;\r\nif (mem->mm_node) {\r\nspin_lock(&gman->lock);\r\nida_remove(&gman->gmr_ida, mem->start);\r\nspin_unlock(&gman->lock);\r\nmem->mm_node = NULL;\r\n}\r\n}\r\nstatic int vmw_gmrid_man_init(struct ttm_mem_type_manager *man,\r\nunsigned long p_size)\r\n{\r\nstruct vmwgfx_gmrid_man *gman =\r\nkzalloc(sizeof(*gman), GFP_KERNEL);\r\nif (unlikely(gman == NULL))\r\nreturn -ENOMEM;\r\nspin_lock_init(&gman->lock);\r\nida_init(&gman->gmr_ida);\r\ngman->max_gmr_ids = p_size;\r\nman->priv = (void *) gman;\r\nreturn 0;\r\n}\r\nstatic int vmw_gmrid_man_takedown(struct ttm_mem_type_manager *man)\r\n{\r\nstruct vmwgfx_gmrid_man *gman =\r\n(struct vmwgfx_gmrid_man *)man->priv;\r\nif (gman) {\r\nida_destroy(&gman->gmr_ida);\r\nkfree(gman);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vmw_gmrid_man_debug(struct ttm_mem_type_manager *man,\r\nconst char *prefix)\r\n{\r\nprintk(KERN_INFO "%s: No debug info available for the GMR "\r\n"id manager.\n", prefix);\r\n}
