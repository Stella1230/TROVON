static struct vmu_block *ofs_to_block(unsigned long src_ofs,\r\nstruct mtd_info *mtd, int partition)\r\n{\r\nstruct vmu_block *vblock;\r\nstruct maple_device *mdev;\r\nstruct memcard *card;\r\nstruct mdev_part *mpart;\r\nint num;\r\nmpart = mtd->priv;\r\nmdev = mpart->mdev;\r\ncard = maple_get_drvdata(mdev);\r\nif (src_ofs >= card->parts[partition].numblocks * card->blocklen)\r\ngoto failed;\r\nnum = src_ofs / card->blocklen;\r\nif (num > card->parts[partition].numblocks)\r\ngoto failed;\r\nvblock = kmalloc(sizeof(struct vmu_block), GFP_KERNEL);\r\nif (!vblock)\r\ngoto failed;\r\nvblock->num = num;\r\nvblock->ofs = src_ofs % card->blocklen;\r\nreturn vblock;\r\nfailed:\r\nreturn NULL;\r\n}\r\nstatic void vmu_blockread(struct mapleq *mq)\r\n{\r\nstruct maple_device *mdev;\r\nstruct memcard *card;\r\nmdev = mq->dev;\r\ncard = maple_get_drvdata(mdev);\r\nif (unlikely(!card->blockread))\r\nreturn;\r\nmemcpy(card->blockread, mq->recvbuf->buf + 12,\r\ncard->blocklen/card->readcnt);\r\n}\r\nstatic int maple_vmu_read_block(unsigned int num, unsigned char *buf,\r\nstruct mtd_info *mtd)\r\n{\r\nstruct memcard *card;\r\nstruct mdev_part *mpart;\r\nstruct maple_device *mdev;\r\nint partition, error = 0, x, wait;\r\nunsigned char *blockread = NULL;\r\nstruct vmu_cache *pcache;\r\n__be32 sendbuf;\r\nmpart = mtd->priv;\r\nmdev = mpart->mdev;\r\npartition = mpart->partition;\r\ncard = maple_get_drvdata(mdev);\r\npcache = card->parts[partition].pcache;\r\npcache->valid = 0;\r\nif (!pcache->buffer) {\r\npcache->buffer = kmalloc(card->blocklen, GFP_KERNEL);\r\nif (!pcache->buffer) {\r\ndev_err(&mdev->dev, "VMU at (%d, %d) - read fails due"\r\n" to lack of memory\n", mdev->port,\r\nmdev->unit);\r\nerror = -ENOMEM;\r\ngoto outB;\r\n}\r\n}\r\nfor (x = 0; x < card->readcnt; x++) {\r\nsendbuf = cpu_to_be32(partition << 24 | x << 16 | num);\r\nif (atomic_read(&mdev->busy) == 1) {\r\nwait_event_interruptible_timeout(mdev->maple_wait,\r\natomic_read(&mdev->busy) == 0, HZ);\r\nif (atomic_read(&mdev->busy) == 1) {\r\ndev_notice(&mdev->dev, "VMU at (%d, %d)"\r\n" is busy\n", mdev->port, mdev->unit);\r\nerror = -EAGAIN;\r\ngoto outB;\r\n}\r\n}\r\natomic_set(&mdev->busy, 1);\r\nblockread = kmalloc(card->blocklen/card->readcnt, GFP_KERNEL);\r\nif (!blockread) {\r\nerror = -ENOMEM;\r\natomic_set(&mdev->busy, 0);\r\ngoto outB;\r\n}\r\ncard->blockread = blockread;\r\nmaple_getcond_callback(mdev, vmu_blockread, 0,\r\nMAPLE_FUNC_MEMCARD);\r\nerror = maple_add_packet(mdev, MAPLE_FUNC_MEMCARD,\r\nMAPLE_COMMAND_BREAD, 2, &sendbuf);\r\nwait = wait_event_interruptible_timeout(mdev->maple_wait,\r\n(atomic_read(&mdev->busy) == 0 ||\r\natomic_read(&mdev->busy) == 2), HZ * 3);\r\nif (error || atomic_read(&mdev->busy) == 2) {\r\nif (atomic_read(&mdev->busy) == 2)\r\nerror = -ENXIO;\r\natomic_set(&mdev->busy, 0);\r\ncard->blockread = NULL;\r\ngoto outA;\r\n}\r\nif (wait == 0 || wait == -ERESTARTSYS) {\r\ncard->blockread = NULL;\r\natomic_set(&mdev->busy, 0);\r\nerror = -EIO;\r\nlist_del_init(&(mdev->mq->list));\r\nkfree(mdev->mq->sendbuf);\r\nmdev->mq->sendbuf = NULL;\r\nif (wait == -ERESTARTSYS) {\r\ndev_warn(&mdev->dev, "VMU read on (%d, %d)"\r\n" interrupted on block 0x%X\n",\r\nmdev->port, mdev->unit, num);\r\n} else\r\ndev_notice(&mdev->dev, "VMU read on (%d, %d)"\r\n" timed out on block 0x%X\n",\r\nmdev->port, mdev->unit, num);\r\ngoto outA;\r\n}\r\nmemcpy(buf + (card->blocklen/card->readcnt) * x, blockread,\r\ncard->blocklen/card->readcnt);\r\nmemcpy(pcache->buffer + (card->blocklen/card->readcnt) * x,\r\ncard->blockread, card->blocklen/card->readcnt);\r\ncard->blockread = NULL;\r\npcache->block = num;\r\npcache->jiffies_atc = jiffies;\r\npcache->valid = 1;\r\nkfree(blockread);\r\n}\r\nreturn error;\r\noutA:\r\nkfree(blockread);\r\noutB:\r\nreturn error;\r\n}\r\nstatic int maple_vmu_write_block(unsigned int num, const unsigned char *buf,\r\nstruct mtd_info *mtd)\r\n{\r\nstruct memcard *card;\r\nstruct mdev_part *mpart;\r\nstruct maple_device *mdev;\r\nint partition, error, locking, x, phaselen, wait;\r\n__be32 *sendbuf;\r\nmpart = mtd->priv;\r\nmdev = mpart->mdev;\r\npartition = mpart->partition;\r\ncard = maple_get_drvdata(mdev);\r\nphaselen = card->blocklen/card->writecnt;\r\nsendbuf = kmalloc(phaselen + 4, GFP_KERNEL);\r\nif (!sendbuf) {\r\nerror = -ENOMEM;\r\ngoto fail_nosendbuf;\r\n}\r\nfor (x = 0; x < card->writecnt; x++) {\r\nsendbuf[0] = cpu_to_be32(partition << 24 | x << 16 | num);\r\nmemcpy(&sendbuf[1], buf + phaselen * x, phaselen);\r\nif (atomic_read(&mdev->busy) == 1) {\r\nwait_event_interruptible_timeout(mdev->maple_wait,\r\natomic_read(&mdev->busy) == 0, HZ);\r\nif (atomic_read(&mdev->busy) == 1) {\r\nerror = -EBUSY;\r\ndev_notice(&mdev->dev, "VMU write at (%d, %d)"\r\n"failed - device is busy\n",\r\nmdev->port, mdev->unit);\r\ngoto fail_nolock;\r\n}\r\n}\r\natomic_set(&mdev->busy, 1);\r\nlocking = maple_add_packet(mdev, MAPLE_FUNC_MEMCARD,\r\nMAPLE_COMMAND_BWRITE, phaselen / 4 + 2, sendbuf);\r\nwait = wait_event_interruptible_timeout(mdev->maple_wait,\r\natomic_read(&mdev->busy) == 0, HZ/10);\r\nif (locking) {\r\nerror = -EIO;\r\natomic_set(&mdev->busy, 0);\r\ngoto fail_nolock;\r\n}\r\nif (atomic_read(&mdev->busy) == 2) {\r\natomic_set(&mdev->busy, 0);\r\n} else if (wait == 0 || wait == -ERESTARTSYS) {\r\nerror = -EIO;\r\ndev_warn(&mdev->dev, "Write at (%d, %d) of block"\r\n" 0x%X at phase %d failed: could not"\r\n" communicate with VMU", mdev->port,\r\nmdev->unit, num, x);\r\natomic_set(&mdev->busy, 0);\r\nkfree(mdev->mq->sendbuf);\r\nmdev->mq->sendbuf = NULL;\r\nlist_del_init(&(mdev->mq->list));\r\ngoto fail_nolock;\r\n}\r\n}\r\nkfree(sendbuf);\r\nreturn card->blocklen;\r\nfail_nolock:\r\nkfree(sendbuf);\r\nfail_nosendbuf:\r\ndev_err(&mdev->dev, "VMU (%d, %d): write failed\n", mdev->port,\r\nmdev->unit);\r\nreturn error;\r\n}\r\nstatic unsigned char vmu_flash_read_char(unsigned long ofs, int *retval,\r\nstruct mtd_info *mtd)\r\n{\r\nstruct vmu_block *vblock;\r\nstruct memcard *card;\r\nstruct mdev_part *mpart;\r\nstruct maple_device *mdev;\r\nunsigned char *buf, ret;\r\nint partition, error;\r\nmpart = mtd->priv;\r\nmdev = mpart->mdev;\r\npartition = mpart->partition;\r\ncard = maple_get_drvdata(mdev);\r\n*retval = 0;\r\nbuf = kmalloc(card->blocklen, GFP_KERNEL);\r\nif (!buf) {\r\n*retval = 1;\r\nret = -ENOMEM;\r\ngoto finish;\r\n}\r\nvblock = ofs_to_block(ofs, mtd, partition);\r\nif (!vblock) {\r\n*retval = 3;\r\nret = -ENOMEM;\r\ngoto out_buf;\r\n}\r\nerror = maple_vmu_read_block(vblock->num, buf, mtd);\r\nif (error) {\r\nret = error;\r\n*retval = 2;\r\ngoto out_vblock;\r\n}\r\nret = buf[vblock->ofs];\r\nout_vblock:\r\nkfree(vblock);\r\nout_buf:\r\nkfree(buf);\r\nfinish:\r\nreturn ret;\r\n}\r\nstatic int vmu_flash_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct maple_device *mdev;\r\nstruct memcard *card;\r\nstruct mdev_part *mpart;\r\nstruct vmu_cache *pcache;\r\nstruct vmu_block *vblock;\r\nint index = 0, retval, partition, leftover, numblocks;\r\nunsigned char cx;\r\nif (len < 1)\r\nreturn -EIO;\r\nmpart = mtd->priv;\r\nmdev = mpart->mdev;\r\npartition = mpart->partition;\r\ncard = maple_get_drvdata(mdev);\r\nnumblocks = card->parts[partition].numblocks;\r\nif (from + len > numblocks * card->blocklen)\r\nlen = numblocks * card->blocklen - from;\r\nif (len == 0)\r\nreturn -EIO;\r\npcache = card->parts[partition].pcache;\r\ndo {\r\nvblock = ofs_to_block(from + index, mtd, partition);\r\nif (!vblock)\r\nreturn -ENOMEM;\r\nif (pcache->valid &&\r\ntime_before(jiffies, pcache->jiffies_atc + HZ) &&\r\n(pcache->block == vblock->num)) {\r\nleftover = card->blocklen - vblock->ofs;\r\nif (vblock->ofs + len - index < card->blocklen) {\r\nmemcpy(buf + index,\r\npcache->buffer + vblock->ofs,\r\nlen - index);\r\nindex = len;\r\n} else {\r\nmemcpy(buf + index, pcache->buffer +\r\nvblock->ofs, leftover);\r\nindex += leftover;\r\n}\r\n} else {\r\ncx = vmu_flash_read_char(from + index, &retval, mtd);\r\nif (retval) {\r\n*retlen = index;\r\nkfree(vblock);\r\nreturn cx;\r\n}\r\nmemset(buf + index, cx, 1);\r\nindex++;\r\n}\r\nkfree(vblock);\r\n} while (len > index);\r\n*retlen = index;\r\nreturn 0;\r\n}\r\nstatic int vmu_flash_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct maple_device *mdev;\r\nstruct memcard *card;\r\nstruct mdev_part *mpart;\r\nint index = 0, partition, error = 0, numblocks;\r\nstruct vmu_cache *pcache;\r\nstruct vmu_block *vblock;\r\nunsigned char *buffer;\r\nmpart = mtd->priv;\r\nmdev = mpart->mdev;\r\npartition = mpart->partition;\r\ncard = maple_get_drvdata(mdev);\r\nif (len < 1) {\r\nerror = -EIO;\r\ngoto failed;\r\n}\r\nnumblocks = card->parts[partition].numblocks;\r\nif (to + len > numblocks * card->blocklen)\r\nlen = numblocks * card->blocklen - to;\r\nif (len == 0) {\r\nerror = -EIO;\r\ngoto failed;\r\n}\r\nvblock = ofs_to_block(to, mtd, partition);\r\nif (!vblock) {\r\nerror = -ENOMEM;\r\ngoto failed;\r\n}\r\nbuffer = kmalloc(card->blocklen, GFP_KERNEL);\r\nif (!buffer) {\r\nerror = -ENOMEM;\r\ngoto fail_buffer;\r\n}\r\ndo {\r\nerror = maple_vmu_read_block(vblock->num, buffer, mtd);\r\nif (error)\r\ngoto fail_io;\r\ndo {\r\nbuffer[vblock->ofs] = buf[index];\r\nvblock->ofs++;\r\nindex++;\r\nif (index >= len)\r\nbreak;\r\n} while (vblock->ofs < card->blocklen);\r\nerror = maple_vmu_write_block(vblock->num, buffer, mtd);\r\npcache = card->parts[partition].pcache;\r\npcache->valid = 0;\r\nif (error != card->blocklen)\r\ngoto fail_io;\r\nvblock->num++;\r\nvblock->ofs = 0;\r\n} while (len > index);\r\nkfree(buffer);\r\n*retlen = index;\r\nkfree(vblock);\r\nreturn 0;\r\nfail_io:\r\nkfree(buffer);\r\nfail_buffer:\r\nkfree(vblock);\r\nfailed:\r\ndev_err(&mdev->dev, "VMU write failing with error %d\n", error);\r\nreturn error;\r\n}\r\nstatic void vmu_flash_sync(struct mtd_info *mtd)\r\n{\r\n}\r\nstatic void vmu_queryblocks(struct mapleq *mq)\r\n{\r\nstruct maple_device *mdev;\r\nunsigned short *res;\r\nstruct memcard *card;\r\n__be32 partnum;\r\nstruct vmu_cache *pcache;\r\nstruct mdev_part *mpart;\r\nstruct mtd_info *mtd_cur;\r\nstruct vmupart *part_cur;\r\nint error;\r\nmdev = mq->dev;\r\ncard = maple_get_drvdata(mdev);\r\nres = (unsigned short *) (mq->recvbuf->buf);\r\ncard->tempA = res[12];\r\ncard->tempB = res[6];\r\ndev_info(&mdev->dev, "VMU device at partition %d has %d user "\r\n"blocks with a root block at %d\n", card->partition,\r\ncard->tempA, card->tempB);\r\npart_cur = &card->parts[card->partition];\r\npart_cur->user_blocks = card->tempA;\r\npart_cur->root_block = card->tempB;\r\npart_cur->numblocks = card->tempB + 1;\r\npart_cur->name = kmalloc(12, GFP_KERNEL);\r\nif (!part_cur->name)\r\ngoto fail_name;\r\nsprintf(part_cur->name, "vmu%d.%d.%d",\r\nmdev->port, mdev->unit, card->partition);\r\nmtd_cur = &card->mtd[card->partition];\r\nmtd_cur->name = part_cur->name;\r\nmtd_cur->type = 8;\r\nmtd_cur->flags = MTD_WRITEABLE|MTD_NO_ERASE;\r\nmtd_cur->size = part_cur->numblocks * card->blocklen;\r\nmtd_cur->erasesize = card->blocklen;\r\nmtd_cur->write = vmu_flash_write;\r\nmtd_cur->read = vmu_flash_read;\r\nmtd_cur->sync = vmu_flash_sync;\r\nmtd_cur->writesize = card->blocklen;\r\nmpart = kmalloc(sizeof(struct mdev_part), GFP_KERNEL);\r\nif (!mpart)\r\ngoto fail_mpart;\r\nmpart->mdev = mdev;\r\nmpart->partition = card->partition;\r\nmtd_cur->priv = mpart;\r\nmtd_cur->owner = THIS_MODULE;\r\npcache = kzalloc(sizeof(struct vmu_cache), GFP_KERNEL);\r\nif (!pcache)\r\ngoto fail_cache_create;\r\npart_cur->pcache = pcache;\r\nerror = mtd_device_register(mtd_cur, NULL, 0);\r\nif (error)\r\ngoto fail_mtd_register;\r\nmaple_getcond_callback(mdev, NULL, 0,\r\nMAPLE_FUNC_MEMCARD);\r\nif (++card->partition < card->partitions) {\r\npartnum = cpu_to_be32(card->partition << 24);\r\nmaple_getcond_callback(mdev, vmu_queryblocks, 0,\r\nMAPLE_FUNC_MEMCARD);\r\nmaple_add_packet(mdev, MAPLE_FUNC_MEMCARD,\r\nMAPLE_COMMAND_GETMINFO, 2, &partnum);\r\n}\r\nreturn;\r\nfail_mtd_register:\r\ndev_err(&mdev->dev, "Could not register maple device at (%d, %d)"\r\n"error is 0x%X\n", mdev->port, mdev->unit, error);\r\nfor (error = 0; error <= card->partition; error++) {\r\nkfree(((card->parts)[error]).pcache);\r\n((card->parts)[error]).pcache = NULL;\r\n}\r\nfail_cache_create:\r\nfail_mpart:\r\nfor (error = 0; error <= card->partition; error++) {\r\nkfree(((card->mtd)[error]).priv);\r\n((card->mtd)[error]).priv = NULL;\r\n}\r\nmaple_getcond_callback(mdev, NULL, 0,\r\nMAPLE_FUNC_MEMCARD);\r\nkfree(part_cur->name);\r\nfail_name:\r\nreturn;\r\n}\r\nstatic int __devinit vmu_connect(struct maple_device *mdev)\r\n{\r\nunsigned long test_flash_data, basic_flash_data;\r\nint c, error;\r\nstruct memcard *card;\r\nu32 partnum = 0;\r\ntest_flash_data = be32_to_cpu(mdev->devinfo.function);\r\nc = hweight_long(test_flash_data);\r\nbasic_flash_data = be32_to_cpu(mdev->devinfo.function_data[c - 1]);\r\ncard = kmalloc(sizeof(struct memcard), GFP_KERNEL);\r\nif (!card) {\r\nerror = -ENOMEM;\r\ngoto fail_nomem;\r\n}\r\ncard->partitions = (basic_flash_data >> 24 & 0xFF) + 1;\r\ncard->blocklen = ((basic_flash_data >> 16 & 0xFF) + 1) << 5;\r\ncard->writecnt = basic_flash_data >> 12 & 0xF;\r\ncard->readcnt = basic_flash_data >> 8 & 0xF;\r\ncard->removeable = basic_flash_data >> 7 & 1;\r\ncard->partition = 0;\r\ncard->parts = kmalloc(sizeof(struct vmupart) * card->partitions,\r\nGFP_KERNEL);\r\nif (!card->parts) {\r\nerror = -ENOMEM;\r\ngoto fail_partitions;\r\n}\r\ncard->mtd = kmalloc(sizeof(struct mtd_info) * card->partitions,\r\nGFP_KERNEL);\r\nif (!card->mtd) {\r\nerror = -ENOMEM;\r\ngoto fail_mtd_info;\r\n}\r\nmaple_set_drvdata(mdev, card);\r\nmaple_getcond_callback(mdev, vmu_queryblocks, 0,\r\nMAPLE_FUNC_MEMCARD);\r\nif (atomic_read(&mdev->busy) == 1) {\r\nwait_event_interruptible_timeout(mdev->maple_wait,\r\natomic_read(&mdev->busy) == 0, HZ);\r\nif (atomic_read(&mdev->busy) == 1) {\r\ndev_notice(&mdev->dev, "VMU at (%d, %d) is busy\n",\r\nmdev->port, mdev->unit);\r\nerror = -EAGAIN;\r\ngoto fail_device_busy;\r\n}\r\n}\r\natomic_set(&mdev->busy, 1);\r\nerror = maple_add_packet(mdev, MAPLE_FUNC_MEMCARD,\r\nMAPLE_COMMAND_GETMINFO, 2, &partnum);\r\nif (error) {\r\ndev_err(&mdev->dev, "Could not lock VMU at (%d, %d)"\r\n" error is 0x%X\n", mdev->port, mdev->unit, error);\r\ngoto fail_mtd_info;\r\n}\r\nreturn 0;\r\nfail_device_busy:\r\nkfree(card->mtd);\r\nfail_mtd_info:\r\nkfree(card->parts);\r\nfail_partitions:\r\nkfree(card);\r\nfail_nomem:\r\nreturn error;\r\n}\r\nstatic void __devexit vmu_disconnect(struct maple_device *mdev)\r\n{\r\nstruct memcard *card;\r\nstruct mdev_part *mpart;\r\nint x;\r\nmdev->callback = NULL;\r\ncard = maple_get_drvdata(mdev);\r\nfor (x = 0; x < card->partitions; x++) {\r\nmpart = ((card->mtd)[x]).priv;\r\nmpart->mdev = NULL;\r\nmtd_device_unregister(&((card->mtd)[x]));\r\nkfree(((card->parts)[x]).name);\r\n}\r\nkfree(card->parts);\r\nkfree(card->mtd);\r\nkfree(card);\r\n}\r\nstatic int vmu_can_unload(struct maple_device *mdev)\r\n{\r\nstruct memcard *card;\r\nint x;\r\nstruct mtd_info *mtd;\r\ncard = maple_get_drvdata(mdev);\r\nfor (x = 0; x < card->partitions; x++) {\r\nmtd = &((card->mtd)[x]);\r\nif (mtd->usecount > 0)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void vmu_file_error(struct maple_device *mdev, void *recvbuf)\r\n{\r\nenum maple_file_errors error = ((int *)recvbuf)[1];\r\nswitch (error) {\r\ncase MAPLE_FILEERR_INVALID_PARTITION:\r\ndev_notice(&mdev->dev, ERRSTR " invalid partition number\n",\r\nmdev->port, mdev->unit);\r\nbreak;\r\ncase MAPLE_FILEERR_PHASE_ERROR:\r\ndev_notice(&mdev->dev, ERRSTR " phase error\n",\r\nmdev->port, mdev->unit);\r\nbreak;\r\ncase MAPLE_FILEERR_INVALID_BLOCK:\r\ndev_notice(&mdev->dev, ERRSTR " invalid block number\n",\r\nmdev->port, mdev->unit);\r\nbreak;\r\ncase MAPLE_FILEERR_WRITE_ERROR:\r\ndev_notice(&mdev->dev, ERRSTR " write error\n",\r\nmdev->port, mdev->unit);\r\nbreak;\r\ncase MAPLE_FILEERR_INVALID_WRITE_LENGTH:\r\ndev_notice(&mdev->dev, ERRSTR " invalid write length\n",\r\nmdev->port, mdev->unit);\r\nbreak;\r\ncase MAPLE_FILEERR_BAD_CRC:\r\ndev_notice(&mdev->dev, ERRSTR " bad CRC\n",\r\nmdev->port, mdev->unit);\r\nbreak;\r\ndefault:\r\ndev_notice(&mdev->dev, ERRSTR " 0x%X\n",\r\nmdev->port, mdev->unit, error);\r\n}\r\n}\r\nstatic int __devinit probe_maple_vmu(struct device *dev)\r\n{\r\nint error;\r\nstruct maple_device *mdev = to_maple_dev(dev);\r\nstruct maple_driver *mdrv = to_maple_driver(dev->driver);\r\nmdev->can_unload = vmu_can_unload;\r\nmdev->fileerr_handler = vmu_file_error;\r\nmdev->driver = mdrv;\r\nerror = vmu_connect(mdev);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int __devexit remove_maple_vmu(struct device *dev)\r\n{\r\nstruct maple_device *mdev = to_maple_dev(dev);\r\nvmu_disconnect(mdev);\r\nreturn 0;\r\n}\r\nstatic int __init vmu_flash_map_init(void)\r\n{\r\nreturn maple_driver_register(&vmu_flash_driver);\r\n}\r\nstatic void __exit vmu_flash_map_exit(void)\r\n{\r\nmaple_driver_unregister(&vmu_flash_driver);\r\n}
