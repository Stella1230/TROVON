static void ndfc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nuint32_t ccr;\r\nstruct nand_chip *nchip = mtd->priv;\r\nstruct ndfc_controller *ndfc = nchip->priv;\r\nccr = in_be32(ndfc->ndfcbase + NDFC_CCR);\r\nif (chip >= 0) {\r\nccr &= ~NDFC_CCR_BS_MASK;\r\nccr |= NDFC_CCR_BS(chip + ndfc->chip_select);\r\n} else\r\nccr |= NDFC_CCR_RESET_CE;\r\nout_be32(ndfc->ndfcbase + NDFC_CCR, ccr);\r\n}\r\nstatic void ndfc_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct ndfc_controller *ndfc = chip->priv;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwritel(cmd & 0xFF, ndfc->ndfcbase + NDFC_CMD);\r\nelse\r\nwritel(cmd & 0xFF, ndfc->ndfcbase + NDFC_ALE);\r\n}\r\nstatic int ndfc_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct ndfc_controller *ndfc = chip->priv;\r\nreturn in_be32(ndfc->ndfcbase + NDFC_STAT) & NDFC_STAT_IS_READY;\r\n}\r\nstatic void ndfc_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nuint32_t ccr;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct ndfc_controller *ndfc = chip->priv;\r\nccr = in_be32(ndfc->ndfcbase + NDFC_CCR);\r\nccr |= NDFC_CCR_RESET_ECC;\r\nout_be32(ndfc->ndfcbase + NDFC_CCR, ccr);\r\nwmb();\r\n}\r\nstatic int ndfc_calculate_ecc(struct mtd_info *mtd,\r\nconst u_char *dat, u_char *ecc_code)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct ndfc_controller *ndfc = chip->priv;\r\nuint32_t ecc;\r\nuint8_t *p = (uint8_t *)&ecc;\r\nwmb();\r\necc = in_be32(ndfc->ndfcbase + NDFC_ECC);\r\necc_code[0] = p[1];\r\necc_code[1] = p[2];\r\necc_code[2] = p[3];\r\nreturn 0;\r\n}\r\nstatic void ndfc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct ndfc_controller *ndfc = chip->priv;\r\nuint32_t *p = (uint32_t *) buf;\r\nfor(;len > 0; len -= 4)\r\n*p++ = in_be32(ndfc->ndfcbase + NDFC_DATA);\r\n}\r\nstatic void ndfc_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct ndfc_controller *ndfc = chip->priv;\r\nuint32_t *p = (uint32_t *) buf;\r\nfor(;len > 0; len -= 4)\r\nout_be32(ndfc->ndfcbase + NDFC_DATA, *p++);\r\n}\r\nstatic int ndfc_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct ndfc_controller *ndfc = chip->priv;\r\nuint32_t *p = (uint32_t *) buf;\r\nfor(;len > 0; len -= 4)\r\nif (*p++ != in_be32(ndfc->ndfcbase + NDFC_DATA))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ndfc_chip_init(struct ndfc_controller *ndfc,\r\nstruct device_node *node)\r\n{\r\n#ifdef CONFIG_MTD_CMDLINE_PARTS\r\nstatic const char *part_types[] = { "cmdlinepart", NULL };\r\n#else\r\nstatic const char *part_types[] = { NULL };\r\n#endif\r\nstruct device_node *flash_np;\r\nstruct nand_chip *chip = &ndfc->chip;\r\nint ret;\r\nchip->IO_ADDR_R = ndfc->ndfcbase + NDFC_DATA;\r\nchip->IO_ADDR_W = ndfc->ndfcbase + NDFC_DATA;\r\nchip->cmd_ctrl = ndfc_hwcontrol;\r\nchip->dev_ready = ndfc_ready;\r\nchip->select_chip = ndfc_select_chip;\r\nchip->chip_delay = 50;\r\nchip->controller = &ndfc->ndfc_control;\r\nchip->read_buf = ndfc_read_buf;\r\nchip->write_buf = ndfc_write_buf;\r\nchip->verify_buf = ndfc_verify_buf;\r\nchip->ecc.correct = nand_correct_data;\r\nchip->ecc.hwctl = ndfc_enable_hwecc;\r\nchip->ecc.calculate = ndfc_calculate_ecc;\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.size = 256;\r\nchip->ecc.bytes = 3;\r\nchip->priv = ndfc;\r\nndfc->mtd.priv = chip;\r\nndfc->mtd.owner = THIS_MODULE;\r\nflash_np = of_get_next_child(node, NULL);\r\nif (!flash_np)\r\nreturn -ENODEV;\r\nndfc->mtd.name = kasprintf(GFP_KERNEL, "%s.%s",\r\ndev_name(&ndfc->ofdev->dev), flash_np->name);\r\nif (!ndfc->mtd.name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = nand_scan(&ndfc->mtd, 1);\r\nif (ret)\r\ngoto err;\r\nret = parse_mtd_partitions(&ndfc->mtd, part_types, &ndfc->parts, 0);\r\nif (ret < 0)\r\ngoto err;\r\nif (ret == 0) {\r\nret = of_mtd_parse_partitions(&ndfc->ofdev->dev, flash_np,\r\n&ndfc->parts);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nret = mtd_device_register(&ndfc->mtd, ndfc->parts, ret);\r\nerr:\r\nof_node_put(flash_np);\r\nif (ret)\r\nkfree(ndfc->mtd.name);\r\nreturn ret;\r\n}\r\nstatic int __devinit ndfc_probe(struct platform_device *ofdev)\r\n{\r\nstruct ndfc_controller *ndfc;\r\nconst __be32 *reg;\r\nu32 ccr;\r\nint err, len, cs;\r\nreg = of_get_property(ofdev->dev.of_node, "reg", &len);\r\nif (reg == NULL || len != 12) {\r\ndev_err(&ofdev->dev, "unable read reg property (%d)\n", len);\r\nreturn -ENOENT;\r\n}\r\ncs = be32_to_cpu(reg[0]);\r\nif (cs >= NDFC_MAX_CS) {\r\ndev_err(&ofdev->dev, "invalid CS number (%d)\n", cs);\r\nreturn -EINVAL;\r\n}\r\nndfc = &ndfc_ctrl[cs];\r\nndfc->chip_select = cs;\r\nspin_lock_init(&ndfc->ndfc_control.lock);\r\ninit_waitqueue_head(&ndfc->ndfc_control.wq);\r\nndfc->ofdev = ofdev;\r\ndev_set_drvdata(&ofdev->dev, ndfc);\r\nndfc->ndfcbase = of_iomap(ofdev->dev.of_node, 0);\r\nif (!ndfc->ndfcbase) {\r\ndev_err(&ofdev->dev, "failed to get memory\n");\r\nreturn -EIO;\r\n}\r\nccr = NDFC_CCR_BS(ndfc->chip_select);\r\nreg = of_get_property(ofdev->dev.of_node, "ccr", NULL);\r\nif (reg)\r\nccr |= be32_to_cpup(reg);\r\nout_be32(ndfc->ndfcbase + NDFC_CCR, ccr);\r\nreg = of_get_property(ofdev->dev.of_node, "bank-settings", NULL);\r\nif (reg) {\r\nint offset = NDFC_BCFG0 + (ndfc->chip_select << 2);\r\nout_be32(ndfc->ndfcbase + offset, be32_to_cpup(reg));\r\n}\r\nerr = ndfc_chip_init(ndfc, ofdev->dev.of_node);\r\nif (err) {\r\niounmap(ndfc->ndfcbase);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit ndfc_remove(struct platform_device *ofdev)\r\n{\r\nstruct ndfc_controller *ndfc = dev_get_drvdata(&ofdev->dev);\r\nnand_release(&ndfc->mtd);\r\nreturn 0;\r\n}\r\nstatic int __init ndfc_nand_init(void)\r\n{\r\nreturn platform_driver_register(&ndfc_driver);\r\n}\r\nstatic void __exit ndfc_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&ndfc_driver);\r\n}
