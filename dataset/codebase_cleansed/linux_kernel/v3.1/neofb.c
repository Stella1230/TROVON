static inline void write_le32(int regindex, u32 val, const struct neofb_par *par)\r\n{\r\nwritel(val, par->neo2200 + par->cursorOff + regindex);\r\n}\r\nstatic int neoFindMode(int xres, int yres, int depth)\r\n{\r\nint xres_s;\r\nint i, size;\r\nbiosMode *mode;\r\nswitch (depth) {\r\ncase 8:\r\nsize = ARRAY_SIZE(bios8);\r\nmode = bios8;\r\nbreak;\r\ncase 16:\r\nsize = ARRAY_SIZE(bios16);\r\nmode = bios16;\r\nbreak;\r\ncase 24:\r\nsize = ARRAY_SIZE(bios24);\r\nmode = bios24;\r\nbreak;\r\n#ifdef NO_32BIT_SUPPORT_YET\r\ncase 32:\r\nsize = ARRAY_SIZE(bios32);\r\nmode = bios32;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn 0;\r\n}\r\nfor (i = 0; i < size; i++) {\r\nif (xres <= mode[i].x_res) {\r\nxres_s = mode[i].x_res;\r\nfor (; i < size; i++) {\r\nif (mode[i].x_res != xres_s)\r\nreturn mode[i - 1].mode;\r\nif (yres <= mode[i].y_res)\r\nreturn mode[i].mode;\r\n}\r\n}\r\n}\r\nreturn mode[size - 1].mode;\r\n}\r\nstatic void neoCalcVCLK(const struct fb_info *info,\r\nstruct neofb_par *par, long freq)\r\n{\r\nint n, d, f;\r\nint n_best = 0, d_best = 0, f_best = 0;\r\nlong f_best_diff = 0x7ffff;\r\nfor (f = 0; f <= MAX_F; f++)\r\nfor (d = 0; d <= MAX_D; d++)\r\nfor (n = 0; n <= MAX_N; n++) {\r\nlong f_out;\r\nlong f_diff;\r\nf_out = ((14318 * (n + 1)) / (d + 1)) >> f;\r\nf_diff = abs(f_out - freq);\r\nif (f_diff <= f_best_diff) {\r\nf_best_diff = f_diff;\r\nn_best = n;\r\nd_best = d;\r\nf_best = f;\r\n}\r\nif (f_out > freq)\r\nbreak;\r\n}\r\nif (info->fix.accel == FB_ACCEL_NEOMAGIC_NM2200 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2230 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2360 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2380) {\r\npar->VCLK3NumeratorLow = n_best;\r\npar->VCLK3NumeratorHigh = (f_best << 7);\r\n} else\r\npar->VCLK3NumeratorLow = n_best | (f_best << 7);\r\npar->VCLK3Denominator = d_best;\r\n#ifdef NEOFB_DEBUG\r\nprintk(KERN_DEBUG "neoVCLK: f:%ld NumLow=%d NumHi=%d Den=%d Df=%ld\n",\r\nfreq,\r\npar->VCLK3NumeratorLow,\r\npar->VCLK3NumeratorHigh,\r\npar->VCLK3Denominator, f_best_diff);\r\n#endif\r\n}\r\nstatic int vgaHWInit(const struct fb_var_screeninfo *var,\r\nstruct neofb_par *par)\r\n{\r\nint hsync_end = var->xres + var->right_margin + var->hsync_len;\r\nint htotal = (hsync_end + var->left_margin) >> 3;\r\nint vsync_start = var->yres + var->lower_margin;\r\nint vsync_end = vsync_start + var->vsync_len;\r\nint vtotal = vsync_end + var->upper_margin;\r\npar->MiscOutReg = 0x23;\r\nif (!(var->sync & FB_SYNC_HOR_HIGH_ACT))\r\npar->MiscOutReg |= 0x40;\r\nif (!(var->sync & FB_SYNC_VERT_HIGH_ACT))\r\npar->MiscOutReg |= 0x80;\r\npar->Sequencer[0] = 0x00;\r\npar->Sequencer[1] = 0x01;\r\npar->Sequencer[2] = 0x0F;\r\npar->Sequencer[3] = 0x00;\r\npar->Sequencer[4] = 0x0E;\r\npar->CRTC[0] = htotal - 5;\r\npar->CRTC[1] = (var->xres >> 3) - 1;\r\npar->CRTC[2] = (var->xres >> 3) - 1;\r\npar->CRTC[3] = ((htotal - 1) & 0x1F) | 0x80;\r\npar->CRTC[4] = ((var->xres + var->right_margin) >> 3);\r\npar->CRTC[5] = (((htotal - 1) & 0x20) << 2)\r\n| (((hsync_end >> 3)) & 0x1F);\r\npar->CRTC[6] = (vtotal - 2) & 0xFF;\r\npar->CRTC[7] = (((vtotal - 2) & 0x100) >> 8)\r\n| (((var->yres - 1) & 0x100) >> 7)\r\n| ((vsync_start & 0x100) >> 6)\r\n| (((var->yres - 1) & 0x100) >> 5)\r\n| 0x10 | (((vtotal - 2) & 0x200) >> 4)\r\n| (((var->yres - 1) & 0x200) >> 3)\r\n| ((vsync_start & 0x200) >> 2);\r\npar->CRTC[8] = 0x00;\r\npar->CRTC[9] = (((var->yres - 1) & 0x200) >> 4) | 0x40;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\npar->CRTC[9] |= 0x80;\r\npar->CRTC[10] = 0x00;\r\npar->CRTC[11] = 0x00;\r\npar->CRTC[12] = 0x00;\r\npar->CRTC[13] = 0x00;\r\npar->CRTC[14] = 0x00;\r\npar->CRTC[15] = 0x00;\r\npar->CRTC[16] = vsync_start & 0xFF;\r\npar->CRTC[17] = (vsync_end & 0x0F) | 0x20;\r\npar->CRTC[18] = (var->yres - 1) & 0xFF;\r\npar->CRTC[19] = var->xres_virtual >> 4;\r\npar->CRTC[20] = 0x00;\r\npar->CRTC[21] = (var->yres - 1) & 0xFF;\r\npar->CRTC[22] = (vtotal - 1) & 0xFF;\r\npar->CRTC[23] = 0xC3;\r\npar->CRTC[24] = 0xFF;\r\npar->Graphics[0] = 0x00;\r\npar->Graphics[1] = 0x00;\r\npar->Graphics[2] = 0x00;\r\npar->Graphics[3] = 0x00;\r\npar->Graphics[4] = 0x00;\r\npar->Graphics[5] = 0x40;\r\npar->Graphics[6] = 0x05;\r\npar->Graphics[7] = 0x0F;\r\npar->Graphics[8] = 0xFF;\r\npar->Attribute[0] = 0x00;\r\npar->Attribute[1] = 0x01;\r\npar->Attribute[2] = 0x02;\r\npar->Attribute[3] = 0x03;\r\npar->Attribute[4] = 0x04;\r\npar->Attribute[5] = 0x05;\r\npar->Attribute[6] = 0x06;\r\npar->Attribute[7] = 0x07;\r\npar->Attribute[8] = 0x08;\r\npar->Attribute[9] = 0x09;\r\npar->Attribute[10] = 0x0A;\r\npar->Attribute[11] = 0x0B;\r\npar->Attribute[12] = 0x0C;\r\npar->Attribute[13] = 0x0D;\r\npar->Attribute[14] = 0x0E;\r\npar->Attribute[15] = 0x0F;\r\npar->Attribute[16] = 0x41;\r\npar->Attribute[17] = 0xFF;\r\npar->Attribute[18] = 0x0F;\r\npar->Attribute[19] = 0x00;\r\npar->Attribute[20] = 0x00;\r\nreturn 0;\r\n}\r\nstatic void vgaHWLock(struct vgastate *state)\r\n{\r\nvga_wcrt(state->vgabase, 0x11, vga_rcrt(state->vgabase, 0x11) | 0x80);\r\n}\r\nstatic void vgaHWUnlock(void)\r\n{\r\nvga_wcrt(NULL, 0x11, vga_rcrt(NULL, 0x11) & ~0x80);\r\n}\r\nstatic void neoLock(struct vgastate *state)\r\n{\r\nvga_wgfx(state->vgabase, 0x09, 0x00);\r\nvgaHWLock(state);\r\n}\r\nstatic void neoUnlock(void)\r\n{\r\nvgaHWUnlock();\r\nvga_wgfx(NULL, 0x09, 0x26);\r\n}\r\nstatic inline void VGAenablePalette(void)\r\n{\r\nvga_r(NULL, VGA_IS1_RC);\r\nvga_w(NULL, VGA_ATT_W, 0x00);\r\npaletteEnabled = 1;\r\n}\r\nstatic inline void VGAdisablePalette(void)\r\n{\r\nvga_r(NULL, VGA_IS1_RC);\r\nvga_w(NULL, VGA_ATT_W, 0x20);\r\npaletteEnabled = 0;\r\n}\r\nstatic inline void VGAwATTR(u8 index, u8 value)\r\n{\r\nif (paletteEnabled)\r\nindex &= ~0x20;\r\nelse\r\nindex |= 0x20;\r\nvga_r(NULL, VGA_IS1_RC);\r\nvga_wattr(NULL, index, value);\r\n}\r\nstatic void vgaHWProtect(int on)\r\n{\r\nunsigned char tmp;\r\ntmp = vga_rseq(NULL, 0x01);\r\nif (on) {\r\nvga_wseq(NULL, 0x00, 0x01);\r\nvga_wseq(NULL, 0x01, tmp | 0x20);\r\nVGAenablePalette();\r\n} else {\r\nvga_wseq(NULL, 0x01, tmp & ~0x20);\r\nvga_wseq(NULL, 0x00, 0x03);\r\nVGAdisablePalette();\r\n}\r\n}\r\nstatic void vgaHWRestore(const struct fb_info *info,\r\nconst struct neofb_par *par)\r\n{\r\nint i;\r\nvga_w(NULL, VGA_MIS_W, par->MiscOutReg);\r\nfor (i = 1; i < 5; i++)\r\nvga_wseq(NULL, i, par->Sequencer[i]);\r\nvga_wcrt(NULL, 17, par->CRTC[17] & ~0x80);\r\nfor (i = 0; i < 25; i++)\r\nvga_wcrt(NULL, i, par->CRTC[i]);\r\nfor (i = 0; i < 9; i++)\r\nvga_wgfx(NULL, i, par->Graphics[i]);\r\nVGAenablePalette();\r\nfor (i = 0; i < 21; i++)\r\nVGAwATTR(i, par->Attribute[i]);\r\nVGAdisablePalette();\r\n}\r\nstatic inline int neo2200_sync(struct fb_info *info)\r\n{\r\nstruct neofb_par *par = info->par;\r\nwhile (readl(&par->neo2200->bltStat) & 1)\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic inline void neo2200_wait_fifo(struct fb_info *info,\r\nint requested_fifo_space)\r\n{\r\nneo2200_sync(info);\r\n}\r\nstatic inline void neo2200_accel_init(struct fb_info *info,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nstruct neofb_par *par = info->par;\r\nNeo2200 __iomem *neo2200 = par->neo2200;\r\nu32 bltMod, pitch;\r\nneo2200_sync(info);\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nbltMod = NEO_MODE1_DEPTH8;\r\npitch = var->xres_virtual;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\nbltMod = NEO_MODE1_DEPTH16;\r\npitch = var->xres_virtual * 2;\r\nbreak;\r\ncase 24:\r\nbltMod = NEO_MODE1_DEPTH24;\r\npitch = var->xres_virtual * 3;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"neofb: neo2200_accel_init: unexpected bits per pixel!\n");\r\nreturn;\r\n}\r\nwritel(bltMod << 16, &neo2200->bltStat);\r\nwritel((pitch << 16) | pitch, &neo2200->pitch);\r\n}\r\nstatic int\r\nneofb_open(struct fb_info *info, int user)\r\n{\r\nstruct neofb_par *par = info->par;\r\nif (!par->ref_count) {\r\nmemset(&par->state, 0, sizeof(struct vgastate));\r\npar->state.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS;\r\nsave_vga(&par->state);\r\n}\r\npar->ref_count++;\r\nreturn 0;\r\n}\r\nstatic int\r\nneofb_release(struct fb_info *info, int user)\r\n{\r\nstruct neofb_par *par = info->par;\r\nif (!par->ref_count)\r\nreturn -EINVAL;\r\nif (par->ref_count == 1) {\r\nrestore_vga(&par->state);\r\n}\r\npar->ref_count--;\r\nreturn 0;\r\n}\r\nstatic int\r\nneofb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct neofb_par *par = info->par;\r\nint memlen, vramlen;\r\nint mode_ok = 0;\r\nDBG("neofb_check_var");\r\nif (PICOS2KHZ(var->pixclock) > par->maxClock)\r\nreturn -EINVAL;\r\nif (par->internal_display &&\r\n((var->xres > par->NeoPanelWidth) ||\r\n(var->yres > par->NeoPanelHeight))) {\r\nprintk(KERN_INFO\r\n"Mode (%dx%d) larger than the LCD panel (%dx%d)\n",\r\nvar->xres, var->yres, par->NeoPanelWidth,\r\npar->NeoPanelHeight);\r\nreturn -EINVAL;\r\n}\r\nif (!par->internal_display)\r\nmode_ok = 1;\r\nelse {\r\nswitch (var->xres) {\r\ncase 1280:\r\nif (var->yres == 1024)\r\nmode_ok = 1;\r\nbreak;\r\ncase 1024:\r\nif (var->yres == 768)\r\nmode_ok = 1;\r\nbreak;\r\ncase 800:\r\nif (var->yres == (par->libretto ? 480 : 600))\r\nmode_ok = 1;\r\nbreak;\r\ncase 640:\r\nif (var->yres == 480)\r\nmode_ok = 1;\r\nbreak;\r\n}\r\n}\r\nif (!mode_ok) {\r\nprintk(KERN_INFO\r\n"Mode (%dx%d) won't display properly on LCD\n",\r\nvar->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\n#ifdef NO_32BIT_SUPPORT_YET\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\n#endif\r\ndefault:\r\nprintk(KERN_WARNING "neofb: no support for %dbpp\n",\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nvramlen = info->fix.smem_len;\r\nif (vramlen > 4 * 1024 * 1024)\r\nvramlen = 4 * 1024 * 1024;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nmemlen = var->xres_virtual * var->bits_per_pixel * var->yres_virtual >> 3;\r\nif (memlen > vramlen) {\r\nvar->yres_virtual = vramlen * 8 / (var->xres_virtual *\r\nvar->bits_per_pixel);\r\nmemlen = var->xres_virtual * var->bits_per_pixel *\r\nvar->yres_virtual / 8;\r\n}\r\nif (var->yres_virtual < var->yres)\r\nvar->yres = var->yres_virtual;\r\nif (var->xoffset + var->xres > var->xres_virtual)\r\nvar->xoffset = var->xres_virtual - var->xres;\r\nif (var->yoffset + var->yres > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual - var->yres;\r\nvar->nonstd = 0;\r\nvar->height = -1;\r\nvar->width = -1;\r\nif (var->bits_per_pixel >= 24 || !par->neo2200)\r\nvar->accel_flags &= ~FB_ACCELF_TEXT;\r\nreturn 0;\r\n}\r\nstatic int neofb_set_par(struct fb_info *info)\r\n{\r\nstruct neofb_par *par = info->par;\r\nunsigned char temp;\r\nint i, clock_hi = 0;\r\nint lcd_stretch;\r\nint hoffset, voffset;\r\nint vsync_start, vtotal;\r\nDBG("neofb_set_par");\r\nneoUnlock();\r\nvgaHWProtect(1);\r\nvsync_start = info->var.yres + info->var.lower_margin;\r\nvtotal = vsync_start + info->var.vsync_len + info->var.upper_margin;\r\nif (vgaHWInit(&info->var, par))\r\nreturn -EINVAL;\r\npar->Attribute[16] = 0x01;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\npar->CRTC[0x13] = info->var.xres_virtual >> 3;\r\npar->ExtCRTOffset = info->var.xres_virtual >> 11;\r\npar->ExtColorModeSelect = 0x11;\r\nbreak;\r\ncase 16:\r\npar->CRTC[0x13] = info->var.xres_virtual >> 2;\r\npar->ExtCRTOffset = info->var.xres_virtual >> 10;\r\npar->ExtColorModeSelect = 0x13;\r\nbreak;\r\ncase 24:\r\npar->CRTC[0x13] = (info->var.xres_virtual * 3) >> 3;\r\npar->ExtCRTOffset = (info->var.xres_virtual * 3) >> 11;\r\npar->ExtColorModeSelect = 0x14;\r\nbreak;\r\n#ifdef NO_32BIT_SUPPORT_YET\r\ncase 32:\r\npar->CRTC[0x13] = info->var.xres_virtual >> 1;\r\npar->ExtCRTOffset = info->var.xres_virtual >> 9;\r\npar->ExtColorModeSelect = 0x15;\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\npar->ExtCRTDispAddr = 0x10;\r\npar->VerticalExt = (((vtotal - 2) & 0x400) >> 10)\r\n| (((info->var.yres - 1) & 0x400) >> 9)\r\n| (((vsync_start) & 0x400) >> 8)\r\n| (((vsync_start) & 0x400) >> 7);\r\nif (par->pci_burst)\r\npar->SysIfaceCntl1 = 0x30;\r\nelse\r\npar->SysIfaceCntl1 = 0x00;\r\npar->SysIfaceCntl2 = 0xc0;\r\npar->PanelDispCntlRegRead = 1;\r\npar->PanelDispCntlReg1 = 0x00;\r\nif (par->internal_display)\r\npar->PanelDispCntlReg1 |= 0x02;\r\nif (par->external_display)\r\npar->PanelDispCntlReg1 |= 0x01;\r\nif (par->PanelDispCntlReg1 == 0x00) {\r\npar->PanelDispCntlReg1 = vga_rgfx(NULL, 0x20) & 0x03;\r\n}\r\nswitch (info->var.xres) {\r\ncase 1280:\r\npar->PanelDispCntlReg1 |= 0x60;\r\nbreak;\r\ncase 1024:\r\npar->PanelDispCntlReg1 |= 0x40;\r\nbreak;\r\ncase 800:\r\npar->PanelDispCntlReg1 |= 0x20;\r\nbreak;\r\ncase 640:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (par->PanelDispCntlReg1 & 0x03) {\r\ncase 0x01:\r\npar->GeneralLockReg = 0x00;\r\npar->ProgramVCLK = 1;\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\npar->GeneralLockReg = 0x01;\r\npar->ProgramVCLK = 0;\r\nbreak;\r\n}\r\npar->PanelDispCntlReg2 = 0x00;\r\npar->PanelDispCntlReg3 = 0x00;\r\nif (par->lcd_stretch && (par->PanelDispCntlReg1 == 0x02) &&\r\n(info->var.xres != par->NeoPanelWidth)) {\r\nswitch (info->var.xres) {\r\ncase 320:\r\ncase 400:\r\ncase 640:\r\ncase 800:\r\ncase 1024:\r\nlcd_stretch = 1;\r\npar->PanelDispCntlReg2 |= 0xC6;\r\nbreak;\r\ndefault:\r\nlcd_stretch = 0;\r\n}\r\n} else\r\nlcd_stretch = 0;\r\npar->PanelVertCenterReg1 = 0x00;\r\npar->PanelVertCenterReg2 = 0x00;\r\npar->PanelVertCenterReg3 = 0x00;\r\npar->PanelVertCenterReg4 = 0x00;\r\npar->PanelVertCenterReg5 = 0x00;\r\npar->PanelHorizCenterReg1 = 0x00;\r\npar->PanelHorizCenterReg2 = 0x00;\r\npar->PanelHorizCenterReg3 = 0x00;\r\npar->PanelHorizCenterReg4 = 0x00;\r\npar->PanelHorizCenterReg5 = 0x00;\r\nif (par->PanelDispCntlReg1 & 0x02) {\r\nif (info->var.xres == par->NeoPanelWidth) {\r\n} else {\r\npar->PanelDispCntlReg2 |= 0x01;\r\npar->PanelDispCntlReg3 |= 0x10;\r\nif (!lcd_stretch) {\r\nhoffset =\r\n((par->NeoPanelWidth -\r\ninfo->var.xres) >> 4) - 1;\r\nvoffset =\r\n((par->NeoPanelHeight -\r\ninfo->var.yres) >> 1) - 2;\r\n} else {\r\nhoffset = 0;\r\nvoffset = 0;\r\n}\r\nswitch (info->var.xres) {\r\ncase 320:\r\npar->PanelHorizCenterReg3 = hoffset;\r\npar->PanelVertCenterReg2 = voffset;\r\nbreak;\r\ncase 400:\r\npar->PanelHorizCenterReg4 = hoffset;\r\npar->PanelVertCenterReg1 = voffset;\r\nbreak;\r\ncase 640:\r\npar->PanelHorizCenterReg1 = hoffset;\r\npar->PanelVertCenterReg3 = voffset;\r\nbreak;\r\ncase 800:\r\npar->PanelHorizCenterReg2 = hoffset;\r\npar->PanelVertCenterReg4 = voffset;\r\nbreak;\r\ncase 1024:\r\npar->PanelHorizCenterReg5 = hoffset;\r\npar->PanelVertCenterReg5 = voffset;\r\nbreak;\r\ncase 1280:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\npar->biosMode =\r\nneoFindMode(info->var.xres, info->var.yres,\r\ninfo->var.bits_per_pixel);\r\nneoCalcVCLK(info, par, PICOS2KHZ(info->var.pixclock));\r\npar->MiscOutReg |= 0x0C;\r\nvga_wgfx(NULL, 0x15, 0x00);\r\nvga_wgfx(NULL, 0x0A, par->GeneralLockReg);\r\ntemp = vga_rgfx(NULL, 0x90);\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2070:\r\ntemp &= 0xF0;\r\ntemp |= (par->ExtColorModeSelect & ~0xF0);\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2090:\r\ncase FB_ACCEL_NEOMAGIC_NM2093:\r\ncase FB_ACCEL_NEOMAGIC_NM2097:\r\ncase FB_ACCEL_NEOMAGIC_NM2160:\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\ntemp &= 0x70;\r\ntemp |= (par->ExtColorModeSelect & ~0x70);\r\nbreak;\r\n}\r\nvga_wgfx(NULL, 0x90, temp);\r\ntemp = vga_rgfx(NULL, 0x25);\r\ntemp &= 0x39;\r\nvga_wgfx(NULL, 0x25, temp);\r\nmdelay(200);\r\nvgaHWRestore(info, par);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ncase 16:\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfor (i = 0; i < 64; i++) {\r\noutb(i, 0x3c8);\r\noutb(i << 1, 0x3c9);\r\noutb(i, 0x3c9);\r\noutb(i << 1, 0x3c9);\r\n}\r\nbreak;\r\ncase 24:\r\n#ifdef NO_32BIT_SUPPORT_YET\r\ncase 32:\r\n#endif\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfor (i = 0; i < 256; i++) {\r\noutb(i, 0x3c8);\r\noutb(i, 0x3c9);\r\noutb(i, 0x3c9);\r\noutb(i, 0x3c9);\r\n}\r\nbreak;\r\n}\r\nvga_wgfx(NULL, 0x0E, par->ExtCRTDispAddr);\r\nvga_wgfx(NULL, 0x0F, par->ExtCRTOffset);\r\ntemp = vga_rgfx(NULL, 0x10);\r\ntemp &= 0x0F;\r\ntemp |= (par->SysIfaceCntl1 & ~0x0F);\r\nvga_wgfx(NULL, 0x10, temp);\r\nvga_wgfx(NULL, 0x11, par->SysIfaceCntl2);\r\nvga_wgfx(NULL, 0x15, 0 );\r\nvga_wgfx(NULL, 0x16, 0 );\r\ntemp = vga_rgfx(NULL, 0x20);\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2070:\r\ntemp &= 0xFC;\r\ntemp |= (par->PanelDispCntlReg1 & ~0xFC);\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2090:\r\ncase FB_ACCEL_NEOMAGIC_NM2093:\r\ncase FB_ACCEL_NEOMAGIC_NM2097:\r\ncase FB_ACCEL_NEOMAGIC_NM2160:\r\ntemp &= 0xDC;\r\ntemp |= (par->PanelDispCntlReg1 & ~0xDC);\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\ntemp &= 0x98;\r\ntemp |= (par->PanelDispCntlReg1 & ~0x98);\r\nbreak;\r\n}\r\nvga_wgfx(NULL, 0x20, temp);\r\ntemp = vga_rgfx(NULL, 0x25);\r\ntemp &= 0x38;\r\ntemp |= (par->PanelDispCntlReg2 & ~0x38);\r\nvga_wgfx(NULL, 0x25, temp);\r\nif (info->fix.accel != FB_ACCEL_NEOMAGIC_NM2070) {\r\ntemp = vga_rgfx(NULL, 0x30);\r\ntemp &= 0xEF;\r\ntemp |= (par->PanelDispCntlReg3 & ~0xEF);\r\nvga_wgfx(NULL, 0x30, temp);\r\n}\r\nvga_wgfx(NULL, 0x28, par->PanelVertCenterReg1);\r\nvga_wgfx(NULL, 0x29, par->PanelVertCenterReg2);\r\nvga_wgfx(NULL, 0x2a, par->PanelVertCenterReg3);\r\nif (info->fix.accel != FB_ACCEL_NEOMAGIC_NM2070) {\r\nvga_wgfx(NULL, 0x32, par->PanelVertCenterReg4);\r\nvga_wgfx(NULL, 0x33, par->PanelHorizCenterReg1);\r\nvga_wgfx(NULL, 0x34, par->PanelHorizCenterReg2);\r\nvga_wgfx(NULL, 0x35, par->PanelHorizCenterReg3);\r\n}\r\nif (info->fix.accel == FB_ACCEL_NEOMAGIC_NM2160)\r\nvga_wgfx(NULL, 0x36, par->PanelHorizCenterReg4);\r\nif (info->fix.accel == FB_ACCEL_NEOMAGIC_NM2200 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2230 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2360 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2380) {\r\nvga_wgfx(NULL, 0x36, par->PanelHorizCenterReg4);\r\nvga_wgfx(NULL, 0x37, par->PanelVertCenterReg5);\r\nvga_wgfx(NULL, 0x38, par->PanelHorizCenterReg5);\r\nclock_hi = 1;\r\n}\r\nif (par->ProgramVCLK && ((vga_rgfx(NULL, 0x9B) != par->VCLK3NumeratorLow)\r\n|| (vga_rgfx(NULL, 0x9F) != par->VCLK3Denominator)\r\n|| (clock_hi && ((vga_rgfx(NULL, 0x8F) & ~0x0f)\r\n!= (par->VCLK3NumeratorHigh &\r\n~0x0F))))) {\r\nvga_wgfx(NULL, 0x9B, par->VCLK3NumeratorLow);\r\nif (clock_hi) {\r\ntemp = vga_rgfx(NULL, 0x8F);\r\ntemp &= 0x0F;\r\ntemp |= (par->VCLK3NumeratorHigh & ~0x0F);\r\nvga_wgfx(NULL, 0x8F, temp);\r\n}\r\nvga_wgfx(NULL, 0x9F, par->VCLK3Denominator);\r\n}\r\nif (par->biosMode)\r\nvga_wcrt(NULL, 0x23, par->biosMode);\r\nvga_wgfx(NULL, 0x93, 0xc0);\r\nif (info->fix.accel == FB_ACCEL_NEOMAGIC_NM2200 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2230 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2360 ||\r\ninfo->fix.accel == FB_ACCEL_NEOMAGIC_NM2380) {\r\nvga_wcrt(NULL, 0x70, par->VerticalExt);\r\n}\r\nvgaHWProtect(0);\r\nneoLock(&par->state);\r\ninfo->fix.line_length =\r\ninfo->var.xres_virtual * (info->var.bits_per_pixel >> 3);\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\nneo2200_accel_init(info, &info->var);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int neofb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct neofb_par *par = info->par;\r\nstruct vgastate *state = &par->state;\r\nint oldExtCRTDispAddr;\r\nint Base;\r\nDBG("neofb_update_start");\r\nBase = (var->yoffset * var->xres_virtual + var->xoffset) >> 2;\r\nBase *= (var->bits_per_pixel + 7) / 8;\r\nneoUnlock();\r\nvga_wcrt(state->vgabase, 0x0C, (Base & 0x00FF00) >> 8);\r\nvga_wcrt(state->vgabase, 0x0D, (Base & 0x00FF));\r\noldExtCRTDispAddr = vga_rgfx(NULL, 0x0E);\r\nvga_wgfx(state->vgabase, 0x0E, (((Base >> 16) & 0x0f) | (oldExtCRTDispAddr & 0xf0)));\r\nneoLock(state);\r\nreturn 0;\r\n}\r\nstatic int neofb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *fb)\r\n{\r\nif (regno >= fb->cmap.len || regno > 255)\r\nreturn -EINVAL;\r\nif (fb->var.bits_per_pixel <= 8) {\r\noutb(regno, 0x3c8);\r\noutb(red >> 10, 0x3c9);\r\noutb(green >> 10, 0x3c9);\r\noutb(blue >> 10, 0x3c9);\r\n} else if (regno < 16) {\r\nswitch (fb->var.bits_per_pixel) {\r\ncase 16:\r\n((u32 *) fb->pseudo_palette)[regno] =\r\n((red & 0xf800)) | ((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\nbreak;\r\ncase 24:\r\n((u32 *) fb->pseudo_palette)[regno] =\r\n((red & 0xff00) << 8) | ((green & 0xff00)) |\r\n((blue & 0xff00) >> 8);\r\nbreak;\r\n#ifdef NO_32BIT_SUPPORT_YET\r\ncase 32:\r\n((u32 *) fb->pseudo_palette)[regno] =\r\n((transp & 0xff00) << 16) | ((red & 0xff00) << 8) |\r\n((green & 0xff00)) | ((blue & 0xff00) >> 8);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int neofb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct neofb_par *par = info->par;\r\nint seqflags, lcdflags, dpmsflags, reg, tmpdisp;\r\nneoUnlock();\r\ntmpdisp = vga_rgfx(NULL, 0x20) & 0x03;\r\nneoLock(&par->state);\r\nif (par->PanelDispCntlRegRead) {\r\npar->PanelDispCntlReg1 = tmpdisp;\r\n}\r\npar->PanelDispCntlRegRead = !blank_mode;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_POWERDOWN:\r\nseqflags = VGA_SR01_SCREEN_OFF;\r\nlcdflags = 0;\r\ndpmsflags = NEO_GR01_SUPPRESS_HSYNC |\r\nNEO_GR01_SUPPRESS_VSYNC;\r\n#ifdef CONFIG_TOSHIBA\r\n{\r\nSMMRegisters regs;\r\nregs.eax = 0xff00;\r\nregs.ebx = 0x0002;\r\nregs.ecx = 0x0000;\r\ntosh_smm(&regs);\r\n}\r\n#endif\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nseqflags = VGA_SR01_SCREEN_OFF;\r\nlcdflags = 0;\r\ndpmsflags = NEO_GR01_SUPPRESS_HSYNC;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nseqflags = VGA_SR01_SCREEN_OFF;\r\nlcdflags = 0;\r\ndpmsflags = NEO_GR01_SUPPRESS_VSYNC;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nseqflags = VGA_SR01_SCREEN_OFF;\r\nlcdflags = ((par->PanelDispCntlReg1 | tmpdisp) & 0x02);\r\ndpmsflags = 0x00;\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nseqflags = 0;\r\nlcdflags = ((par->PanelDispCntlReg1 | tmpdisp) & 0x02);\r\ndpmsflags = 0x00;\r\n#ifdef CONFIG_TOSHIBA\r\n{\r\nSMMRegisters regs;\r\nregs.eax = 0xff00;\r\nregs.ebx = 0x0002;\r\nregs.ecx = 0x0001;\r\ntosh_smm(&regs);\r\n}\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nneoUnlock();\r\nreg = (vga_rseq(NULL, 0x01) & ~0x20) | seqflags;\r\nvga_wseq(NULL, 0x01, reg);\r\nreg = (vga_rgfx(NULL, 0x20) & ~0x02) | lcdflags;\r\nvga_wgfx(NULL, 0x20, reg);\r\nreg = (vga_rgfx(NULL, 0x01) & ~0xF0) | 0x80 | dpmsflags;\r\nvga_wgfx(NULL, 0x01, reg);\r\nneoLock(&par->state);\r\nreturn 0;\r\n}\r\nstatic void\r\nneo2200_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct neofb_par *par = info->par;\r\nu_long dst, rop;\r\ndst = rect->dx + rect->dy * info->var.xres_virtual;\r\nrop = rect->rop ? 0x060000 : 0x0c0000;\r\nneo2200_wait_fifo(info, 4);\r\nwritel(NEO_BC3_FIFO_EN |\r\nNEO_BC0_SRC_IS_FG | NEO_BC3_SKIP_MAPPING |\r\nrop, &par->neo2200->bltCntl);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nwritel(rect->color, &par->neo2200->fgColor);\r\nbreak;\r\ncase 16:\r\ncase 24:\r\nwritel(((u32 *) (info->pseudo_palette))[rect->color],\r\n&par->neo2200->fgColor);\r\nbreak;\r\n}\r\nwritel(dst * ((info->var.bits_per_pixel + 7) >> 3),\r\n&par->neo2200->dstStart);\r\nwritel((rect->height << 16) | (rect->width & 0xffff),\r\n&par->neo2200->xyExt);\r\n}\r\nstatic void\r\nneo2200_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nu32 sx = area->sx, sy = area->sy, dx = area->dx, dy = area->dy;\r\nstruct neofb_par *par = info->par;\r\nu_long src, dst, bltCntl;\r\nbltCntl = NEO_BC3_FIFO_EN | NEO_BC3_SKIP_MAPPING | 0x0C0000;\r\nif ((dy > sy) || ((dy == sy) && (dx > sx))) {\r\nsy += (area->height - 1);\r\ndy += (area->height - 1);\r\nsx += (area->width - 1);\r\ndx += (area->width - 1);\r\nbltCntl |= NEO_BC0_X_DEC | NEO_BC0_DST_Y_DEC | NEO_BC0_SRC_Y_DEC;\r\n}\r\nsrc = sx * (info->var.bits_per_pixel >> 3) + sy*info->fix.line_length;\r\ndst = dx * (info->var.bits_per_pixel >> 3) + dy*info->fix.line_length;\r\nneo2200_wait_fifo(info, 4);\r\nwritel(bltCntl, &par->neo2200->bltCntl);\r\nwritel(src, &par->neo2200->srcStart);\r\nwritel(dst, &par->neo2200->dstStart);\r\nwritel((area->height << 16) | (area->width & 0xffff),\r\n&par->neo2200->xyExt);\r\n}\r\nstatic void\r\nneo2200_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct neofb_par *par = info->par;\r\nint s_pitch = (image->width * image->depth + 7) >> 3;\r\nint scan_align = info->pixmap.scan_align - 1;\r\nint buf_align = info->pixmap.buf_align - 1;\r\nint bltCntl_flags, d_pitch, data_len;\r\nd_pitch = (s_pitch + scan_align) & ~scan_align;\r\ndata_len = ((d_pitch * image->height) + buf_align) & ~buf_align;\r\nneo2200_sync(info);\r\nif (image->depth == 1) {\r\nif (info->var.bits_per_pixel == 24 && image->width < 16) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nbltCntl_flags = NEO_BC0_SRC_MONO;\r\n} else if (image->depth == info->var.bits_per_pixel) {\r\nbltCntl_flags = 0;\r\n} else {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nwritel(image->fg_color, &par->neo2200->fgColor);\r\nwritel(image->bg_color, &par->neo2200->bgColor);\r\nbreak;\r\ncase 16:\r\ncase 24:\r\nwritel(((u32 *) (info->pseudo_palette))[image->fg_color],\r\n&par->neo2200->fgColor);\r\nwritel(((u32 *) (info->pseudo_palette))[image->bg_color],\r\n&par->neo2200->bgColor);\r\nbreak;\r\n}\r\nwritel(NEO_BC0_SYS_TO_VID |\r\nNEO_BC3_SKIP_MAPPING | bltCntl_flags |\r\n0x0c0000, &par->neo2200->bltCntl);\r\nwritel(0, &par->neo2200->srcStart);\r\nwritel(((image->dx & 0xffff) * (info->var.bits_per_pixel >> 3) +\r\nimage->dy * info->fix.line_length), &par->neo2200->dstStart);\r\nwritel((image->height << 16) | (image->width & 0xffff),\r\n&par->neo2200->xyExt);\r\nmemcpy_toio(par->mmio_vbase + 0x100000, image->data, data_len);\r\n}\r\nstatic void\r\nneofb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\nneo2200_fillrect(info, rect);\r\nbreak;\r\ndefault:\r\ncfb_fillrect(info, rect);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nneofb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\nneo2200_copyarea(info, area);\r\nbreak;\r\ndefault:\r\ncfb_copyarea(info, area);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nneofb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\nneo2200_imageblit(info, image);\r\nbreak;\r\ndefault:\r\ncfb_imageblit(info, image);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nneofb_sync(struct fb_info *info)\r\n{\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\nneo2200_sync(info);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit neo_map_mmio(struct fb_info *info,\r\nstruct pci_dev *dev)\r\n{\r\nstruct neofb_par *par = info->par;\r\nDBG("neo_map_mmio");\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2070:\r\ninfo->fix.mmio_start = pci_resource_start(dev, 0)+\r\n0x100000;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2090:\r\ncase FB_ACCEL_NEOMAGIC_NM2093:\r\ninfo->fix.mmio_start = pci_resource_start(dev, 0)+\r\n0x200000;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2160:\r\ncase FB_ACCEL_NEOMAGIC_NM2097:\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\ninfo->fix.mmio_start = pci_resource_start(dev, 1);\r\nbreak;\r\ndefault:\r\ninfo->fix.mmio_start = pci_resource_start(dev, 0);\r\n}\r\ninfo->fix.mmio_len = MMIO_SIZE;\r\nif (!request_mem_region\r\n(info->fix.mmio_start, MMIO_SIZE, "memory mapped I/O")) {\r\nprintk("neofb: memory mapped IO in use\n");\r\nreturn -EBUSY;\r\n}\r\npar->mmio_vbase = ioremap(info->fix.mmio_start, MMIO_SIZE);\r\nif (!par->mmio_vbase) {\r\nprintk("neofb: unable to map memory mapped IO\n");\r\nrelease_mem_region(info->fix.mmio_start,\r\ninfo->fix.mmio_len);\r\nreturn -ENOMEM;\r\n} else\r\nprintk(KERN_INFO "neofb: mapped io at %p\n",\r\npar->mmio_vbase);\r\nreturn 0;\r\n}\r\nstatic void neo_unmap_mmio(struct fb_info *info)\r\n{\r\nstruct neofb_par *par = info->par;\r\nDBG("neo_unmap_mmio");\r\niounmap(par->mmio_vbase);\r\npar->mmio_vbase = NULL;\r\nrelease_mem_region(info->fix.mmio_start,\r\ninfo->fix.mmio_len);\r\n}\r\nstatic int __devinit neo_map_video(struct fb_info *info,\r\nstruct pci_dev *dev, int video_len)\r\n{\r\nDBG("neo_map_video");\r\ninfo->fix.smem_start = pci_resource_start(dev, 0);\r\ninfo->fix.smem_len = video_len;\r\nif (!request_mem_region(info->fix.smem_start, info->fix.smem_len,\r\n"frame buffer")) {\r\nprintk("neofb: frame buffer in use\n");\r\nreturn -EBUSY;\r\n}\r\ninfo->screen_base =\r\nioremap(info->fix.smem_start, info->fix.smem_len);\r\nif (!info->screen_base) {\r\nprintk("neofb: unable to map screen memory\n");\r\nrelease_mem_region(info->fix.smem_start,\r\ninfo->fix.smem_len);\r\nreturn -ENOMEM;\r\n} else\r\nprintk(KERN_INFO "neofb: mapped framebuffer at %p\n",\r\ninfo->screen_base);\r\n#ifdef CONFIG_MTRR\r\n((struct neofb_par *)(info->par))->mtrr =\r\nmtrr_add(info->fix.smem_start, pci_resource_len(dev, 0),\r\nMTRR_TYPE_WRCOMB, 1);\r\n#endif\r\nmemset_io(info->screen_base, 0, info->fix.smem_len);\r\nreturn 0;\r\n}\r\nstatic void neo_unmap_video(struct fb_info *info)\r\n{\r\nDBG("neo_unmap_video");\r\n#ifdef CONFIG_MTRR\r\n{\r\nstruct neofb_par *par = info->par;\r\nmtrr_del(par->mtrr, info->fix.smem_start,\r\ninfo->fix.smem_len);\r\n}\r\n#endif\r\niounmap(info->screen_base);\r\ninfo->screen_base = NULL;\r\nrelease_mem_region(info->fix.smem_start,\r\ninfo->fix.smem_len);\r\n}\r\nstatic int __devinit neo_scan_monitor(struct fb_info *info)\r\n{\r\nstruct neofb_par *par = info->par;\r\nunsigned char type, display;\r\nint w;\r\ninfo->monspecs.modedb = kmalloc(sizeof(struct fb_videomode), GFP_KERNEL);\r\nif (!info->monspecs.modedb)\r\nreturn -ENOMEM;\r\ninfo->monspecs.modedb_len = 1;\r\nvga_wgfx(NULL, 0x09, 0x26);\r\ntype = vga_rgfx(NULL, 0x21);\r\ndisplay = vga_rgfx(NULL, 0x20);\r\nif (!par->internal_display && !par->external_display) {\r\npar->internal_display = display & 2 || !(display & 3) ? 1 : 0;\r\npar->external_display = display & 1;\r\nprintk (KERN_INFO "Autodetected %s display\n",\r\npar->internal_display && par->external_display ? "simultaneous" :\r\npar->internal_display ? "internal" : "external");\r\n}\r\nw = vga_rgfx(NULL, 0x20);\r\nvga_wgfx(NULL, 0x09, 0x00);\r\nswitch ((w & 0x18) >> 3) {\r\ncase 0x00:\r\npar->NeoPanelWidth = 640;\r\npar->NeoPanelHeight = 480;\r\nmemcpy(info->monspecs.modedb, &vesa_modes[3], sizeof(struct fb_videomode));\r\nbreak;\r\ncase 0x01:\r\npar->NeoPanelWidth = 800;\r\nif (par->libretto) {\r\npar->NeoPanelHeight = 480;\r\nmemcpy(info->monspecs.modedb, &mode800x480, sizeof(struct fb_videomode));\r\n} else {\r\npar->NeoPanelHeight = 600;\r\nmemcpy(info->monspecs.modedb, &vesa_modes[8], sizeof(struct fb_videomode));\r\n}\r\nbreak;\r\ncase 0x02:\r\npar->NeoPanelWidth = 1024;\r\npar->NeoPanelHeight = 768;\r\nmemcpy(info->monspecs.modedb, &vesa_modes[13], sizeof(struct fb_videomode));\r\nbreak;\r\ncase 0x03:\r\n#ifdef NOT_DONE\r\npar->NeoPanelWidth = 1280;\r\npar->NeoPanelHeight = 1024;\r\nmemcpy(info->monspecs.modedb, &vesa_modes[20], sizeof(struct fb_videomode));\r\nbreak;\r\n#else\r\nprintk(KERN_ERR\r\n"neofb: Only 640x480, 800x600/480 and 1024x768 panels are currently supported\n");\r\nreturn -1;\r\n#endif\r\ndefault:\r\npar->NeoPanelWidth = 640;\r\npar->NeoPanelHeight = 480;\r\nmemcpy(info->monspecs.modedb, &vesa_modes[3], sizeof(struct fb_videomode));\r\nbreak;\r\n}\r\nprintk(KERN_INFO "Panel is a %dx%d %s %s display\n",\r\npar->NeoPanelWidth,\r\npar->NeoPanelHeight,\r\n(type & 0x02) ? "color" : "monochrome",\r\n(type & 0x10) ? "TFT" : "dual scan");\r\nreturn 0;\r\n}\r\nstatic int __devinit neo_init_hw(struct fb_info *info)\r\n{\r\nstruct neofb_par *par = info->par;\r\nint videoRam = 896;\r\nint maxClock = 65000;\r\nint CursorMem = 1024;\r\nint CursorOff = 0x100;\r\nDBG("neo_init_hw");\r\nneoUnlock();\r\n#if 0\r\nprintk(KERN_DEBUG "--- Neo extended register dump ---\n");\r\nfor (int w = 0; w < 0x85; w++)\r\nprintk(KERN_DEBUG "CR %p: %p\n", (void *) w,\r\n(void *) vga_rcrt(NULL, w));\r\nfor (int w = 0; w < 0xC7; w++)\r\nprintk(KERN_DEBUG "GR %p: %p\n", (void *) w,\r\n(void *) vga_rgfx(NULL, w));\r\n#endif\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2070:\r\nvideoRam = 896;\r\nmaxClock = 65000;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2090:\r\ncase FB_ACCEL_NEOMAGIC_NM2093:\r\ncase FB_ACCEL_NEOMAGIC_NM2097:\r\nvideoRam = 1152;\r\nmaxClock = 80000;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2160:\r\nvideoRam = 2048;\r\nmaxClock = 90000;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\nvideoRam = 2560;\r\nmaxClock = 110000;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\nvideoRam = 3008;\r\nmaxClock = 110000;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\nvideoRam = 4096;\r\nmaxClock = 110000;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\nvideoRam = 6144;\r\nmaxClock = 110000;\r\nbreak;\r\n}\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2070:\r\ncase FB_ACCEL_NEOMAGIC_NM2090:\r\ncase FB_ACCEL_NEOMAGIC_NM2093:\r\nCursorMem = 2048;\r\nCursorOff = 0x100;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2097:\r\ncase FB_ACCEL_NEOMAGIC_NM2160:\r\nCursorMem = 1024;\r\nCursorOff = 0x100;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\nCursorMem = 1024;\r\nCursorOff = 0x1000;\r\npar->neo2200 = (Neo2200 __iomem *) par->mmio_vbase;\r\nbreak;\r\n}\r\npar->maxClock = maxClock;\r\npar->cursorOff = CursorOff;\r\nreturn videoRam * 1024;\r\n}\r\nstatic struct fb_info *__devinit neo_alloc_fb_info(struct pci_dev *dev, const struct\r\npci_device_id *id)\r\n{\r\nstruct fb_info *info;\r\nstruct neofb_par *par;\r\ninfo = framebuffer_alloc(sizeof(struct neofb_par), &dev->dev);\r\nif (!info)\r\nreturn NULL;\r\npar = info->par;\r\ninfo->fix.accel = id->driver_data;\r\npar->pci_burst = !nopciburst;\r\npar->lcd_stretch = !nostretch;\r\npar->libretto = libretto;\r\npar->internal_display = internal;\r\npar->external_display = external;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_NEOMAGIC_NM2070:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 128");\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2090:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 128V");\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2093:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 128ZV");\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2097:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 128ZV+");\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2160:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 128XD");\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2200:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 256AV");\r\ninfo->flags |= FBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2230:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 256AV+");\r\ninfo->flags |= FBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2360:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 256ZX");\r\ninfo->flags |= FBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT;\r\nbreak;\r\ncase FB_ACCEL_NEOMAGIC_NM2380:\r\nsnprintf(info->fix.id, sizeof(info->fix.id),\r\n"MagicGraph 256XL+");\r\ninfo->flags |= FBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT;\r\nbreak;\r\n}\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 4;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = id->driver_data;\r\ninfo->fbops = &neofb_ops;\r\ninfo->pseudo_palette = par->palette;\r\nreturn info;\r\n}\r\nstatic void neo_free_fb_info(struct fb_info *info)\r\n{\r\nif (info) {\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\n}\r\nstatic int __devinit neofb_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct fb_info *info;\r\nu_int h_sync, v_sync;\r\nint video_len, err;\r\nDBG("neofb_probe");\r\nerr = pci_enable_device(dev);\r\nif (err)\r\nreturn err;\r\nerr = -ENOMEM;\r\ninfo = neo_alloc_fb_info(dev, id);\r\nif (!info)\r\nreturn err;\r\nerr = neo_map_mmio(info, dev);\r\nif (err)\r\ngoto err_map_mmio;\r\nerr = neo_scan_monitor(info);\r\nif (err)\r\ngoto err_scan_monitor;\r\nvideo_len = neo_init_hw(info);\r\nif (video_len < 0) {\r\nerr = video_len;\r\ngoto err_init_hw;\r\n}\r\nerr = neo_map_video(info, dev, video_len);\r\nif (err)\r\ngoto err_init_hw;\r\nif (!fb_find_mode(&info->var, info, mode_option, NULL, 0,\r\ninfo->monspecs.modedb, 16)) {\r\nprintk(KERN_ERR "neofb: Unable to find usable video mode.\n");\r\ngoto err_map_video;\r\n}\r\nh_sync = 1953125000 / info->var.pixclock;\r\nh_sync =\r\nh_sync * 512 / (info->var.xres + info->var.left_margin +\r\ninfo->var.right_margin + info->var.hsync_len);\r\nv_sync =\r\nh_sync / (info->var.yres + info->var.upper_margin +\r\ninfo->var.lower_margin + info->var.vsync_len);\r\nprintk(KERN_INFO "neofb v" NEOFB_VERSION\r\n": %dkB VRAM, using %dx%d, %d.%03dkHz, %dHz\n",\r\ninfo->fix.smem_len >> 10, info->var.xres,\r\ninfo->var.yres, h_sync / 1000, h_sync % 1000, v_sync);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0)\r\ngoto err_map_video;\r\nerr = register_framebuffer(info);\r\nif (err < 0)\r\ngoto err_reg_fb;\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\npci_set_drvdata(dev, info);\r\nreturn 0;\r\nerr_reg_fb:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_map_video:\r\nneo_unmap_video(info);\r\nerr_init_hw:\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nerr_scan_monitor:\r\nneo_unmap_mmio(info);\r\nerr_map_mmio:\r\nneo_free_fb_info(info);\r\nreturn err;\r\n}\r\nstatic void __devexit neofb_remove(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nDBG("neofb_remove");\r\nif (info) {\r\nif (unregister_framebuffer(info))\r\nprintk(KERN_WARNING\r\n"neofb: danger danger! Oopsen imminent!\n");\r\nneo_unmap_video(info);\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nneo_unmap_mmio(info);\r\nneo_free_fb_info(info);\r\npci_set_drvdata(dev, NULL);\r\n}\r\n}\r\nstatic int __init neofb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nDBG("neofb_setup");\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strncmp(this_opt, "internal", 8))\r\ninternal = 1;\r\nelse if (!strncmp(this_opt, "external", 8))\r\nexternal = 1;\r\nelse if (!strncmp(this_opt, "nostretch", 9))\r\nnostretch = 1;\r\nelse if (!strncmp(this_opt, "nopciburst", 10))\r\nnopciburst = 1;\r\nelse if (!strncmp(this_opt, "libretto", 8))\r\nlibretto = 1;\r\nelse\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init neofb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("neofb", &option))\r\nreturn -ENODEV;\r\nneofb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&neofb_driver);\r\n}\r\nstatic void __exit neofb_exit(void)\r\n{\r\npci_unregister_driver(&neofb_driver);\r\n}
