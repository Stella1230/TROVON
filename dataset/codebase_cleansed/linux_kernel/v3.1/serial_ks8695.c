static inline int tx_enabled(struct uart_port *port)\r\n{\r\nreturn port->unused[0] & 1;\r\n}\r\nstatic inline int rx_enabled(struct uart_port *port)\r\n{\r\nreturn port->unused[0] & 2;\r\n}\r\nstatic inline int ms_enabled(struct uart_port *port)\r\n{\r\nreturn port->unused[0] & 4;\r\n}\r\nstatic inline void ms_enable(struct uart_port *port, int enabled)\r\n{\r\nif(enabled)\r\nport->unused[0] |= 4;\r\nelse\r\nport->unused[0] &= ~4;\r\n}\r\nstatic inline void rx_enable(struct uart_port *port, int enabled)\r\n{\r\nif(enabled)\r\nport->unused[0] |= 2;\r\nelse\r\nport->unused[0] &= ~2;\r\n}\r\nstatic inline void tx_enable(struct uart_port *port, int enabled)\r\n{\r\nif(enabled)\r\nport->unused[0] |= 1;\r\nelse\r\nport->unused[0] &= ~1;\r\n}\r\nstatic void ks8695uart_stop_tx(struct uart_port *port)\r\n{\r\nif (tx_enabled(port)) {\r\ndisable_irq_nosync(KS8695_IRQ_UART_TX);\r\ntx_enable(port, 0);\r\n}\r\n}\r\nstatic void ks8695uart_start_tx(struct uart_port *port)\r\n{\r\nif (!tx_enabled(port)) {\r\nenable_irq(KS8695_IRQ_UART_TX);\r\ntx_enable(port, 1);\r\n}\r\n}\r\nstatic void ks8695uart_stop_rx(struct uart_port *port)\r\n{\r\nif (rx_enabled(port)) {\r\ndisable_irq(KS8695_IRQ_UART_RX);\r\nrx_enable(port, 0);\r\n}\r\n}\r\nstatic void ks8695uart_enable_ms(struct uart_port *port)\r\n{\r\nif (!ms_enabled(port)) {\r\nenable_irq(KS8695_IRQ_UART_MODEM_STATUS);\r\nms_enable(port,1);\r\n}\r\n}\r\nstatic void ks8695uart_disable_ms(struct uart_port *port)\r\n{\r\nif (ms_enabled(port)) {\r\ndisable_irq(KS8695_IRQ_UART_MODEM_STATUS);\r\nms_enable(port,0);\r\n}\r\n}\r\nstatic irqreturn_t ks8695uart_rx_chars(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct tty_struct *tty = port->state->port.tty;\r\nunsigned int status, ch, lsr, flg, max_count = 256;\r\nstatus = UART_GET_LSR(port);\r\nwhile ((status & URLS_URDR) && max_count--) {\r\nch = UART_GET_CHAR(port);\r\nflg = TTY_NORMAL;\r\nport->icount.rx++;\r\nlsr = UART_GET_LSR(port) | UART_DUMMY_LSR_RX;\r\nif (unlikely(lsr & (URLS_URBI | URLS_URPE | URLS_URFE | URLS_URROE))) {\r\nif (lsr & URLS_URBI) {\r\nlsr &= ~(URLS_URFE | URLS_URPE);\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ngoto ignore_char;\r\n}\r\nif (lsr & URLS_URPE)\r\nport->icount.parity++;\r\nif (lsr & URLS_URFE)\r\nport->icount.frame++;\r\nif (lsr & URLS_URROE)\r\nport->icount.overrun++;\r\nlsr &= port->read_status_mask;\r\nif (lsr & URLS_URBI)\r\nflg = TTY_BREAK;\r\nelse if (lsr & URLS_URPE)\r\nflg = TTY_PARITY;\r\nelse if (lsr & URLS_URFE)\r\nflg = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(port, lsr, URLS_URROE, ch, flg);\r\nignore_char:\r\nstatus = UART_GET_LSR(port);\r\n}\r\ntty_flip_buffer_push(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ks8695uart_tx_chars(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int count;\r\nif (port->x_char) {\r\nKS8695_CLR_TX_INT();\r\nUART_PUT_CHAR(port, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (uart_tx_stopped(port) || uart_circ_empty(xmit)) {\r\nks8695uart_stop_tx(port);\r\nreturn IRQ_HANDLED;\r\n}\r\ncount = 16;\r\nwhile (!uart_circ_empty(xmit) && (count-- > 0)) {\r\nKS8695_CLR_TX_INT();\r\nUART_PUT_CHAR(port, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nks8695uart_stop_tx(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ks8695uart_modem_status(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nunsigned int status;\r\nstatus = UART_GET_MSR(port);\r\nif (status & URMS_URDDCD)\r\nuart_handle_dcd_change(port, status & URMS_URDDCD);\r\nif (status & URMS_URDDST)\r\nport->icount.dsr++;\r\nif (status & URMS_URDCTS)\r\nuart_handle_cts_change(port, status & URMS_URDCTS);\r\nif (status & URMS_URTERI)\r\nport->icount.rng++;\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int ks8695uart_tx_empty(struct uart_port *port)\r\n{\r\nreturn (UART_GET_LSR(port) & URLS_URTE) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int ks8695uart_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int result = 0;\r\nunsigned int status;\r\nstatus = UART_GET_MSR(port);\r\nif (status & URMS_URDCD)\r\nresult |= TIOCM_CAR;\r\nif (status & URMS_URDSR)\r\nresult |= TIOCM_DSR;\r\nif (status & URMS_URCTS)\r\nresult |= TIOCM_CTS;\r\nif (status & URMS_URRI)\r\nresult |= TIOCM_RI;\r\nreturn result;\r\n}\r\nstatic void ks8695uart_set_mctrl(struct uart_port *port, u_int mctrl)\r\n{\r\nunsigned int mcr;\r\nmcr = UART_GET_MCR(port);\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= URMC_URRTS;\r\nelse\r\nmcr &= ~URMC_URRTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= URMC_URDTR;\r\nelse\r\nmcr &= ~URMC_URDTR;\r\nUART_PUT_MCR(port, mcr);\r\n}\r\nstatic void ks8695uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned int lcr;\r\nlcr = UART_GET_LCR(port);\r\nif (break_state == -1)\r\nlcr |= URLC_URSBC;\r\nelse\r\nlcr &= ~URLC_URSBC;\r\nUART_PUT_LCR(port, lcr);\r\n}\r\nstatic int ks8695uart_startup(struct uart_port *port)\r\n{\r\nint retval;\r\nset_irq_flags(KS8695_IRQ_UART_TX, IRQF_VALID | IRQF_NOAUTOEN);\r\ntx_enable(port, 0);\r\nrx_enable(port, 1);\r\nms_enable(port, 1);\r\nretval = request_irq(KS8695_IRQ_UART_TX, ks8695uart_tx_chars, IRQF_DISABLED, "UART TX", port);\r\nif (retval)\r\ngoto err_tx;\r\nretval = request_irq(KS8695_IRQ_UART_RX, ks8695uart_rx_chars, IRQF_DISABLED, "UART RX", port);\r\nif (retval)\r\ngoto err_rx;\r\nretval = request_irq(KS8695_IRQ_UART_LINE_STATUS, ks8695uart_rx_chars, IRQF_DISABLED, "UART LineStatus", port);\r\nif (retval)\r\ngoto err_ls;\r\nretval = request_irq(KS8695_IRQ_UART_MODEM_STATUS, ks8695uart_modem_status, IRQF_DISABLED, "UART ModemStatus", port);\r\nif (retval)\r\ngoto err_ms;\r\nreturn 0;\r\nerr_ms:\r\nfree_irq(KS8695_IRQ_UART_LINE_STATUS, port);\r\nerr_ls:\r\nfree_irq(KS8695_IRQ_UART_RX, port);\r\nerr_rx:\r\nfree_irq(KS8695_IRQ_UART_TX, port);\r\nerr_tx:\r\nreturn retval;\r\n}\r\nstatic void ks8695uart_shutdown(struct uart_port *port)\r\n{\r\nfree_irq(KS8695_IRQ_UART_RX, port);\r\nfree_irq(KS8695_IRQ_UART_TX, port);\r\nfree_irq(KS8695_IRQ_UART_MODEM_STATUS, port);\r\nfree_irq(KS8695_IRQ_UART_LINE_STATUS, port);\r\nUART_PUT_LCR(port, UART_GET_LCR(port) & ~URLC_URSBC);\r\nUART_PUT_FCR(port, UART_GET_FCR(port) & ~URFC_URFE);\r\n}\r\nstatic void ks8695uart_set_termios(struct uart_port *port, struct ktermios *termios, struct ktermios *old)\r\n{\r\nunsigned int lcr, fcr = 0;\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr = URCL_5;\r\nbreak;\r\ncase CS6:\r\nlcr = URCL_6;\r\nbreak;\r\ncase CS7:\r\nlcr = URCL_7;\r\nbreak;\r\ndefault:\r\nlcr = URCL_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nlcr |= URLC_URSB;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\nlcr |= URPE_MARK;\r\nelse\r\nlcr |= URPE_SPACE;\r\n}\r\nelse if (termios->c_cflag & PARODD)\r\nlcr |= URPE_ODD;\r\nelse\r\nlcr |= URPE_EVEN;\r\n}\r\nif (port->fifosize > 1)\r\nfcr = URFC_URFRT_8 | URFC_URTFR | URFC_URRFR | URFC_URFE;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nport->read_status_mask = URLS_URROE;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= (URLS_URFE | URLS_URPE);\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= URLS_URBI;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= (URLS_URFE | URLS_URPE);\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= URLS_URBI;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= URLS_URROE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= UART_DUMMY_LSR_RX;\r\nif (UART_ENABLE_MS(port, termios->c_cflag))\r\nks8695uart_enable_ms(port);\r\nelse\r\nks8695uart_disable_ms(port);\r\nUART_PUT_BRDR(port, quot);\r\nUART_PUT_LCR(port, lcr);\r\nUART_PUT_FCR(port, fcr);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *ks8695uart_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_KS8695 ? "KS8695" : NULL;\r\n}\r\nstatic void ks8695uart_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, UART_PORT_SIZE);\r\n}\r\nstatic int ks8695uart_request_port(struct uart_port *port)\r\n{\r\nreturn request_mem_region(port->mapbase, UART_PORT_SIZE,\r\n"serial_ks8695") != NULL ? 0 : -EBUSY;\r\n}\r\nstatic void ks8695uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_KS8695;\r\nks8695uart_request_port(port);\r\n}\r\n}\r\nstatic int ks8695uart_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_KS8695)\r\nret = -EINVAL;\r\nif (ser->irq != port->irq)\r\nret = -EINVAL;\r\nif (ser->baud_base < 9600)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void ks8695_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (!(UART_GET_LSR(port) & URLS_URTHRE))\r\nbarrier();\r\nUART_PUT_CHAR(port, ch);\r\n}\r\nstatic void ks8695_console_write(struct console *co, const char *s, u_int count)\r\n{\r\nstruct uart_port *port = ks8695uart_ports + co->index;\r\nuart_console_write(port, s, count, ks8695_console_putchar);\r\n}\r\nstatic void __init ks8695_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)\r\n{\r\nunsigned int lcr;\r\nlcr = UART_GET_LCR(port);\r\nswitch (lcr & URLC_PARITY) {\r\ncase URPE_ODD:\r\n*parity = 'o';\r\nbreak;\r\ncase URPE_EVEN:\r\n*parity = 'e';\r\nbreak;\r\ndefault:\r\n*parity = 'n';\r\n}\r\nswitch (lcr & URLC_URCL) {\r\ncase URCL_5:\r\n*bits = 5;\r\nbreak;\r\ncase URCL_6:\r\n*bits = 6;\r\nbreak;\r\ncase URCL_7:\r\n*bits = 7;\r\nbreak;\r\ndefault:\r\n*bits = 8;\r\n}\r\n*baud = port->uartclk / (UART_GET_BRDR(port) & 0x0FFF);\r\n*baud /= 16;\r\n*baud &= 0xFFFFFFF0;\r\n}\r\nstatic int __init ks8695_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nport = uart_get_console(ks8695uart_ports, SERIAL_KS8695_NR, co);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nks8695_console_get_options(port, &baud, &parity, &bits);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init ks8695_console_init(void)\r\n{\r\nadd_preferred_console(SERIAL_KS8695_DEVNAME, 0, NULL);\r\nregister_console(&ks8695_console);\r\nreturn 0;\r\n}\r\nstatic int __init ks8695uart_init(void)\r\n{\r\nint i, ret;\r\nprintk(KERN_INFO "Serial: Micrel KS8695 UART driver\n");\r\nret = uart_register_driver(&ks8695_reg);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < SERIAL_KS8695_NR; i++)\r\nuart_add_one_port(&ks8695_reg, &ks8695uart_ports[0]);\r\nreturn 0;\r\n}\r\nstatic void __exit ks8695uart_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SERIAL_KS8695_NR; i++)\r\nuart_remove_one_port(&ks8695_reg, &ks8695uart_ports[0]);\r\nuart_unregister_driver(&ks8695_reg);\r\n}
