static u16 dib8000_i2c_read16(struct i2c_device *i2c, u16 reg)\r\n{\r\nstruct i2c_msg msg[2] = {\r\n{.addr = i2c->addr >> 1, .flags = 0,\r\n.buf = i2c->i2c_write_buffer, .len = 2},\r\n{.addr = i2c->addr >> 1, .flags = I2C_M_RD,\r\n.buf = i2c->i2c_read_buffer, .len = 2},\r\n};\r\nmsg[0].buf[0] = reg >> 8;\r\nmsg[0].buf[1] = reg & 0xff;\r\nif (i2c_transfer(i2c->adap, msg, 2) != 2)\r\ndprintk("i2c read error on %d", reg);\r\nreturn (msg[1].buf[0] << 8) | msg[1].buf[1];\r\n}\r\nstatic u16 dib8000_read_word(struct dib8000_state *state, u16 reg)\r\n{\r\nstate->i2c_write_buffer[0] = reg >> 8;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c.addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 2;\r\nstate->msg[1].addr = state->i2c.addr >> 1;\r\nstate->msg[1].flags = I2C_M_RD;\r\nstate->msg[1].buf = state->i2c_read_buffer;\r\nstate->msg[1].len = 2;\r\nif (i2c_transfer(state->i2c.adap, state->msg, 2) != 2)\r\ndprintk("i2c read error on %d", reg);\r\nreturn (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\r\n}\r\nstatic u32 dib8000_read32(struct dib8000_state *state, u16 reg)\r\n{\r\nu16 rw[2];\r\nrw[0] = dib8000_read_word(state, reg + 0);\r\nrw[1] = dib8000_read_word(state, reg + 1);\r\nreturn ((rw[0] << 16) | (rw[1]));\r\n}\r\nstatic int dib8000_i2c_write16(struct i2c_device *i2c, u16 reg, u16 val)\r\n{\r\nstruct i2c_msg msg = {.addr = i2c->addr >> 1, .flags = 0,\r\n.buf = i2c->i2c_write_buffer, .len = 4};\r\nint ret = 0;\r\nmsg.buf[0] = (reg >> 8) & 0xff;\r\nmsg.buf[1] = reg & 0xff;\r\nmsg.buf[2] = (val >> 8) & 0xff;\r\nmsg.buf[3] = val & 0xff;\r\nret = i2c_transfer(i2c->adap, &msg, 1) != 1 ? -EREMOTEIO : 0;\r\nreturn ret;\r\n}\r\nstatic int dib8000_write_word(struct dib8000_state *state, u16 reg, u16 val)\r\n{\r\nstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nstate->i2c_write_buffer[2] = (val >> 8) & 0xff;\r\nstate->i2c_write_buffer[3] = val & 0xff;\r\nmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c.addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 4;\r\nreturn i2c_transfer(state->i2c.adap, state->msg, 1) != 1 ? -EREMOTEIO : 0;\r\n}\r\nstatic u16 fft_to_mode(struct dib8000_state *state)\r\n{\r\nu16 mode;\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nmode = 1;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nmode = 2;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_AUTO:\r\ncase TRANSMISSION_MODE_8K:\r\nmode = 3;\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic void dib8000_set_acquisition_mode(struct dib8000_state *state)\r\n{\r\nu16 nud = dib8000_read_word(state, 298);\r\nnud |= (1 << 3) | (1 << 0);\r\ndprintk("acquisition mode activated");\r\ndib8000_write_word(state, 298, nud);\r\n}\r\nstatic int dib8000_set_output_mode(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 outreg, fifo_threshold, smo_mode, sram = 0x0205;\r\noutreg = 0;\r\nfifo_threshold = 1792;\r\nsmo_mode = (dib8000_read_word(state, 299) & 0x0050) | (1 << 1);\r\ndprintk("-I- Setting output mode for demod %p to %d",\r\n&state->fe[0], mode);\r\nswitch (mode) {\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\noutreg = (1 << 10);\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\noutreg = (1 << 10) | (1 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\noutreg = (1 << 10) | (2 << 6) | (0 << 1);\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\nif (state->cfg.hostbus_diversity) {\r\noutreg = (1 << 10) | (4 << 6);\r\nsram &= 0xfdff;\r\n} else\r\nsram |= 0x0c00;\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\nsmo_mode |= (3 << 1);\r\nfifo_threshold = 512;\r\noutreg = (1 << 10) | (5 << 6);\r\nbreak;\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ncase OUTMODE_ANALOG_ADC:\r\noutreg = (1 << 10) | (3 << 6);\r\ndib8000_set_acquisition_mode(state);\r\nbreak;\r\ndefault:\r\ndprintk("Unhandled output_mode passed to be set for demod %p",\r\n&state->fe[0]);\r\nreturn -EINVAL;\r\n}\r\nif (state->cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5);\r\ndib8000_write_word(state, 299, smo_mode);\r\ndib8000_write_word(state, 300, fifo_threshold);\r\ndib8000_write_word(state, 1286, outreg);\r\ndib8000_write_word(state, 1291, sram);\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_diversity_in(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 sync_wait = dib8000_read_word(state, 273) & 0xfff0;\r\nif (!state->differential_constellation) {\r\ndib8000_write_word(state, 272, 1 << 9);\r\ndib8000_write_word(state, 273, sync_wait | (1 << 2) | 2);\r\n} else {\r\ndib8000_write_word(state, 272, 0);\r\ndib8000_write_word(state, 273, sync_wait);\r\n}\r\nstate->diversity_onoff = onoff;\r\nswitch (onoff) {\r\ncase 0:\r\ndib8000_write_word(state, 270, 1);\r\ndib8000_write_word(state, 271, 0);\r\nbreak;\r\ncase 1:\r\ndib8000_write_word(state, 270, 6);\r\ndib8000_write_word(state, 271, 6);\r\nbreak;\r\ncase 2:\r\ndib8000_write_word(state, 270, 0);\r\ndib8000_write_word(state, 271, 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dib8000_set_power_mode(struct dib8000_state *state, enum dib8000_power_mode mode)\r\n{\r\nu16 reg_774 = 0x3fff, reg_775 = 0xffff, reg_776 = 0xffff,\r\nreg_900 = (dib8000_read_word(state, 900) & 0xfffc) | 0x3,\r\nreg_1280 = (dib8000_read_word(state, 1280) & 0x00ff) | 0xff00;\r\nswitch (mode) {\r\ncase DIB8000M_POWER_ALL:\r\nreg_774 = 0x0000;\r\nreg_775 = 0x0000;\r\nreg_776 = 0x0000;\r\nreg_900 &= 0xfffc;\r\nreg_1280 &= 0x00ff;\r\nbreak;\r\ncase DIB8000M_POWER_INTERFACE_ONLY:\r\nreg_1280 &= 0x00ff;\r\nbreak;\r\n}\r\ndprintk("powermode : 774 : %x ; 775 : %x; 776 : %x ; 900 : %x; 1280 : %x", reg_774, reg_775, reg_776, reg_900, reg_1280);\r\ndib8000_write_word(state, 774, reg_774);\r\ndib8000_write_word(state, 775, reg_775);\r\ndib8000_write_word(state, 776, reg_776);\r\ndib8000_write_word(state, 900, reg_900);\r\ndib8000_write_word(state, 1280, reg_1280);\r\n}\r\nstatic int dib8000_set_adc_state(struct dib8000_state *state, enum dibx000_adc_states no)\r\n{\r\nint ret = 0;\r\nu16 reg_907 = dib8000_read_word(state, 907), reg_908 = dib8000_read_word(state, 908);\r\nswitch (no) {\r\ncase DIBX000_SLOW_ADC_ON:\r\nreg_908 |= (1 << 1) | (1 << 0);\r\nret |= dib8000_write_word(state, 908, reg_908);\r\nreg_908 &= ~(1 << 1);\r\nbreak;\r\ncase DIBX000_SLOW_ADC_OFF:\r\nreg_908 |= (1 << 1) | (1 << 0);\r\nbreak;\r\ncase DIBX000_ADC_ON:\r\nreg_907 &= 0x0fff;\r\nreg_908 &= 0x0003;\r\nbreak;\r\ncase DIBX000_ADC_OFF:\r\nreg_907 |= (1 << 14) | (1 << 13) | (1 << 12);\r\nreg_908 |= (1 << 5) | (1 << 4) | (1 << 3) | (1 << 2);\r\nbreak;\r\ncase DIBX000_VBG_ENABLE:\r\nreg_907 &= ~(1 << 15);\r\nbreak;\r\ncase DIBX000_VBG_DISABLE:\r\nreg_907 |= (1 << 15);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret |= dib8000_write_word(state, 907, reg_907);\r\nret |= dib8000_write_word(state, 908, reg_908);\r\nreturn ret;\r\n}\r\nstatic int dib8000_set_bandwidth(struct dvb_frontend *fe, u32 bw)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 timf;\r\nif (bw == 0)\r\nbw = 6000;\r\nif (state->timf == 0) {\r\ndprintk("using default timf");\r\ntimf = state->timf_default;\r\n} else {\r\ndprintk("using updated timf");\r\ntimf = state->timf;\r\n}\r\ndib8000_write_word(state, 29, (u16) ((timf >> 16) & 0xffff));\r\ndib8000_write_word(state, 30, (u16) ((timf) & 0xffff));\r\nreturn 0;\r\n}\r\nstatic int dib8000_sad_calib(struct dib8000_state *state)\r\n{\r\ndib8000_write_word(state, 923, (0 << 1) | (0 << 0));\r\ndib8000_write_word(state, 924, 776);\r\ndib8000_write_word(state, 923, (1 << 0));\r\ndib8000_write_word(state, 923, (0 << 0));\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nint dib8000_set_wbd_ref(struct dvb_frontend *fe, u16 value)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (value > 4095)\r\nvalue = 4095;\r\nstate->wbd_ref = value;\r\nreturn dib8000_write_word(state, 106, value);\r\n}\r\nstatic void dib8000_reset_pll_common(struct dib8000_state *state, const struct dibx000_bandwidth_config *bw)\r\n{\r\ndprintk("ifreq: %d %x, inversion: %d", bw->ifreq, bw->ifreq, bw->ifreq >> 25);\r\ndib8000_write_word(state, 23, (u16) (((bw->internal * 1000) >> 16) & 0xffff));\r\ndib8000_write_word(state, 24, (u16) ((bw->internal * 1000) & 0xffff));\r\ndib8000_write_word(state, 27, (u16) ((bw->ifreq >> 16) & 0x01ff));\r\ndib8000_write_word(state, 28, (u16) (bw->ifreq & 0xffff));\r\ndib8000_write_word(state, 26, (u16) ((bw->ifreq >> 25) & 0x0003));\r\ndib8000_write_word(state, 922, bw->sad_cfg);\r\n}\r\nstatic void dib8000_reset_pll(struct dib8000_state *state)\r\n{\r\nconst struct dibx000_bandwidth_config *pll = state->cfg.pll;\r\nu16 clk_cfg1;\r\ndib8000_write_word(state, 901, (pll->pll_prediv << 8) | (pll->pll_ratio << 0));\r\nclk_cfg1 = (1 << 10) | (0 << 9) | (pll->IO_CLK_en_core << 8) |\r\n(pll->bypclk_div << 5) | (pll->enable_refdiv << 4) | (1 << 3) |\r\n(pll->pll_range << 1) | (pll->pll_reset << 0);\r\ndib8000_write_word(state, 902, clk_cfg1);\r\nclk_cfg1 = (clk_cfg1 & 0xfff7) | (pll->pll_bypass << 3);\r\ndib8000_write_word(state, 902, clk_cfg1);\r\ndprintk("clk_cfg1: 0x%04x", clk_cfg1);\r\nif (state->cfg.pll->ADClkSrc == 0)\r\ndib8000_write_word(state, 904, (0 << 15) | (0 << 12) | (0 << 10) |\r\n(pll->modulo << 8) | (pll->ADClkSrc << 7) | (0 << 1));\r\nelse if (state->cfg.refclksel != 0)\r\ndib8000_write_word(state, 904, (0 << 15) | (1 << 12) |\r\n((state->cfg.refclksel & 0x3) << 10) | (pll->modulo << 8) |\r\n(pll->ADClkSrc << 7) | (0 << 1));\r\nelse\r\ndib8000_write_word(state, 904, (0 << 15) | (1 << 12) | (3 << 10) | (pll->modulo << 8) | (pll->ADClkSrc << 7) | (0 << 1));\r\ndib8000_reset_pll_common(state, pll);\r\n}\r\nstatic int dib8000_reset_gpio(struct dib8000_state *st)\r\n{\r\ndib8000_write_word(st, 1029, st->cfg.gpio_dir);\r\ndib8000_write_word(st, 1030, st->cfg.gpio_val);\r\ndib8000_write_word(st, 1032, st->cfg.gpio_pwm_pos);\r\ndib8000_write_word(st, 1037, st->cfg.pwm_freq_div);\r\nreturn 0;\r\n}\r\nstatic int dib8000_cfg_gpio(struct dib8000_state *st, u8 num, u8 dir, u8 val)\r\n{\r\nst->cfg.gpio_dir = dib8000_read_word(st, 1029);\r\nst->cfg.gpio_dir &= ~(1 << num);\r\nst->cfg.gpio_dir |= (dir & 0x1) << num;\r\ndib8000_write_word(st, 1029, st->cfg.gpio_dir);\r\nst->cfg.gpio_val = dib8000_read_word(st, 1030);\r\nst->cfg.gpio_val &= ~(1 << num);\r\nst->cfg.gpio_val |= (val & 0x01) << num;\r\ndib8000_write_word(st, 1030, st->cfg.gpio_val);\r\ndprintk("gpio dir: %x: gpio val: %x", st->cfg.gpio_dir, st->cfg.gpio_val);\r\nreturn 0;\r\n}\r\nint dib8000_set_gpio(struct dvb_frontend *fe, u8 num, u8 dir, u8 val)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nreturn dib8000_cfg_gpio(state, num, dir, val);\r\n}\r\nstatic u16 dib8000_identify(struct i2c_device *client)\r\n{\r\nu16 value;\r\nvalue = dib8000_i2c_read16(client, 896);\r\nif ((value = dib8000_i2c_read16(client, 896)) != 0x01b3) {\r\ndprintk("wrong Vendor ID (read=0x%x)", value);\r\nreturn 0;\r\n}\r\nvalue = dib8000_i2c_read16(client, 897);\r\nif (value != 0x8000 && value != 0x8001 && value != 0x8002) {\r\ndprintk("wrong Device ID (%x)", value);\r\nreturn 0;\r\n}\r\nswitch (value) {\r\ncase 0x8000:\r\ndprintk("found DiB8000A");\r\nbreak;\r\ncase 0x8001:\r\ndprintk("found DiB8000B");\r\nbreak;\r\ncase 0x8002:\r\ndprintk("found DiB8000C");\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic int dib8000_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\ndib8000_write_word(state, 1287, 0x0003);\r\nif ((state->revision = dib8000_identify(&state->i2c)) == 0)\r\nreturn -EINVAL;\r\nif (state->revision == 0x8000)\r\ndprintk("error : dib8000 MA not supported");\r\ndibx000_reset_i2c_master(&state->i2c_master);\r\ndib8000_set_power_mode(state, DIB8000M_POWER_ALL);\r\ndib8000_set_adc_state(state, DIBX000_VBG_ENABLE);\r\ndib8000_write_word(state, 770, 0xffff);\r\ndib8000_write_word(state, 771, 0xffff);\r\ndib8000_write_word(state, 772, 0xfffc);\r\ndib8000_write_word(state, 898, 0x000c);\r\ndib8000_write_word(state, 1280, 0x004d);\r\ndib8000_write_word(state, 1281, 0x000c);\r\ndib8000_write_word(state, 770, 0x0000);\r\ndib8000_write_word(state, 771, 0x0000);\r\ndib8000_write_word(state, 772, 0x0000);\r\ndib8000_write_word(state, 898, 0x0004);\r\ndib8000_write_word(state, 1280, 0x0000);\r\ndib8000_write_word(state, 1281, 0x0000);\r\nif (state->cfg.drives)\r\ndib8000_write_word(state, 906, state->cfg.drives);\r\nelse {\r\ndprintk("using standard PAD-drive-settings, please adjust settings in config-struct to be optimal.");\r\ndib8000_write_word(state, 906, 0x2d98);\r\n}\r\ndib8000_reset_pll(state);\r\nif (dib8000_reset_gpio(state) != 0)\r\ndprintk("GPIO reset was not successful.");\r\nif (dib8000_set_output_mode(fe, OUTMODE_HIGH_Z) != 0)\r\ndprintk("OUTPUT_MODE could not be resetted.");\r\nstate->current_agc = NULL;\r\nif (state->cfg.pll->ifreq == 0)\r\ndib8000_write_word(state, 40, 0x0755);\r\nelse\r\ndib8000_write_word(state, 40, 0x1f55);\r\n{\r\nu16 l = 0, r;\r\nconst u16 *n;\r\nn = dib8000_defaults;\r\nl = *n++;\r\nwhile (l) {\r\nr = *n++;\r\ndo {\r\ndib8000_write_word(state, r, *n++);\r\nr++;\r\n} while (--l);\r\nl = *n++;\r\n}\r\n}\r\nstate->isdbt_cfg_loaded = 0;\r\nif (state->cfg.div_cfg != 0)\r\ndib8000_write_word(state, 903, state->cfg.div_cfg);\r\ndib8000_write_word(state, 1285, dib8000_read_word(state, 1285) & ~(1 << 1));\r\ndib8000_set_bandwidth(fe, 6000);\r\ndib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON);\r\ndib8000_sad_calib(state);\r\ndib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF);\r\ndib8000_set_power_mode(state, DIB8000M_POWER_INTERFACE_ONLY);\r\nreturn 0;\r\n}\r\nstatic void dib8000_restart_agc(struct dib8000_state *state)\r\n{\r\ndib8000_write_word(state, 770, 0x0a00);\r\ndib8000_write_word(state, 770, 0x0000);\r\n}\r\nstatic int dib8000_update_lna(struct dib8000_state *state)\r\n{\r\nu16 dyn_gain;\r\nif (state->cfg.update_lna) {\r\ndyn_gain = dib8000_read_word(state, 390);\r\nif (state->cfg.update_lna(state->fe[0], dyn_gain)) {\r\ndib8000_restart_agc(state);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_agc_config(struct dib8000_state *state, u8 band)\r\n{\r\nstruct dibx000_agc_config *agc = NULL;\r\nint i;\r\nif (state->current_band == band && state->current_agc != NULL)\r\nreturn 0;\r\nstate->current_band = band;\r\nfor (i = 0; i < state->cfg.agc_config_count; i++)\r\nif (state->cfg.agc[i].band_caps & band) {\r\nagc = &state->cfg.agc[i];\r\nbreak;\r\n}\r\nif (agc == NULL) {\r\ndprintk("no valid AGC configuration found for band 0x%02x", band);\r\nreturn -EINVAL;\r\n}\r\nstate->current_agc = agc;\r\ndib8000_write_word(state, 76, agc->setup);\r\ndib8000_write_word(state, 77, agc->inv_gain);\r\ndib8000_write_word(state, 78, agc->time_stabiliz);\r\ndib8000_write_word(state, 101, (agc->alpha_level << 12) | agc->thlock);\r\ndib8000_write_word(state, 102, (agc->alpha_mant << 5) | agc->alpha_exp);\r\ndib8000_write_word(state, 103, (agc->beta_mant << 6) | agc->beta_exp);\r\ndprintk("WBD: ref: %d, sel: %d, active: %d, alpha: %d",\r\nstate->wbd_ref != 0 ? state->wbd_ref : agc->wbd_ref, agc->wbd_sel, !agc->perform_agc_softsplit, agc->wbd_sel);\r\nif (state->wbd_ref != 0)\r\ndib8000_write_word(state, 106, state->wbd_ref);\r\nelse\r\ndib8000_write_word(state, 106, agc->wbd_ref);\r\ndib8000_write_word(state, 107, (agc->wbd_alpha << 9) | (agc->perform_agc_softsplit << 8));\r\ndib8000_write_word(state, 108, agc->agc1_max);\r\ndib8000_write_word(state, 109, agc->agc1_min);\r\ndib8000_write_word(state, 110, agc->agc2_max);\r\ndib8000_write_word(state, 111, agc->agc2_min);\r\ndib8000_write_word(state, 112, (agc->agc1_pt1 << 8) | agc->agc1_pt2);\r\ndib8000_write_word(state, 113, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\r\ndib8000_write_word(state, 114, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\r\ndib8000_write_word(state, 115, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\r\ndib8000_write_word(state, 75, agc->agc1_pt3);\r\ndib8000_write_word(state, 923, (dib8000_read_word(state, 923) & 0xffe3) | (agc->wbd_inv << 4) | (agc->wbd_sel << 2));\r\nreturn 0;\r\n}\r\nvoid dib8000_pwm_agc_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\ndib8000_set_agc_config(state, (unsigned char)(BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000)));\r\n}\r\nstatic int dib8000_agc_soft_split(struct dib8000_state *state)\r\n{\r\nu16 agc, split_offset;\r\nif (!state->current_agc || !state->current_agc->perform_agc_softsplit || state->current_agc->split.max == 0)\r\nreturn FE_CALLBACK_TIME_NEVER;\r\nagc = dib8000_read_word(state, 390);\r\nif (agc > state->current_agc->split.min_thres)\r\nsplit_offset = state->current_agc->split.min;\r\nelse if (agc < state->current_agc->split.max_thres)\r\nsplit_offset = state->current_agc->split.max;\r\nelse\r\nsplit_offset = state->current_agc->split.max *\r\n(agc - state->current_agc->split.min_thres) /\r\n(state->current_agc->split.max_thres - state->current_agc->split.min_thres);\r\ndprintk("AGC split_offset: %d", split_offset);\r\ndib8000_write_word(state, 107, (dib8000_read_word(state, 107) & 0xff00) | split_offset);\r\nreturn 5000;\r\n}\r\nstatic int dib8000_agc_startup(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nenum frontend_tune_state *tune_state = &state->tune_state;\r\nint ret = 0;\r\nswitch (*tune_state) {\r\ncase CT_AGC_START:\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\nif (dib8000_set_agc_config(state, (unsigned char)(BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000))) != 0) {\r\n*tune_state = CT_AGC_STOP;\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\nbreak;\r\n}\r\nret = 70;\r\n*tune_state = CT_AGC_STEP_0;\r\nbreak;\r\ncase CT_AGC_STEP_0:\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(fe, 1);\r\ndib8000_restart_agc(state);\r\nret = 50;\r\n*tune_state = CT_AGC_STEP_1;\r\nbreak;\r\ncase CT_AGC_STEP_1:\r\nret = 70;\r\nif (dib8000_update_lna(state))\r\nret = 50;\r\nelse\r\n*tune_state = CT_AGC_STEP_2;\r\nbreak;\r\ncase CT_AGC_STEP_2:\r\ndib8000_agc_soft_split(state);\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(fe, 0);\r\n*tune_state = CT_AGC_STOP;\r\nbreak;\r\ndefault:\r\nret = dib8000_agc_soft_split(state);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\ns32 dib8000_get_adc_power(struct dvb_frontend *fe, u8 mode)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 ix = 0, tmp_val = 0, exp = 0, mant = 0;\r\ns32 val;\r\nval = dib8000_read32(state, 384);\r\nif (mode) {\r\ntmp_val = val;\r\nwhile (tmp_val >>= 1)\r\nexp++;\r\nmant = (val * 1000 / (1<<exp));\r\nix = (u8)((mant-1000)/100);\r\nval = (lut_1000ln_mant[ix] + 693*(exp-20) - 6908);\r\nval = (val*256)/1000;\r\n}\r\nreturn val;\r\n}\r\nstatic void dib8000_update_timf(struct dib8000_state *state)\r\n{\r\nu32 timf = state->timf = dib8000_read32(state, 435);\r\ndib8000_write_word(state, 29, (u16) (timf >> 16));\r\ndib8000_write_word(state, 30, (u16) (timf & 0xffff));\r\ndprintk("Updated timing frequency: %d (default: %d)", state->timf, state->timf_default);\r\n}\r\nstatic void dib8000_set_channel(struct dib8000_state *state, u8 seq, u8 autosearching)\r\n{\r\nu16 mode, max_constellation, seg_diff_mask = 0, nbseg_diff = 0;\r\nu8 guard, crate, constellation, timeI;\r\nu16 i, coeff[4], P_cfr_left_edge = 0, P_cfr_right_edge = 0, seg_mask13 = 0x1fff;\r\nconst s16 *ncoeff = NULL, *ana_fe;\r\nu16 tmcc_pow = 0;\r\nu16 coff_pow = 0x2800;\r\nu16 init_prbs = 0xfff;\r\nu16 ana_gain = 0;\r\nif (state->ber_monitored_layer != LAYER_ALL)\r\ndib8000_write_word(state, 285, (dib8000_read_word(state, 285) & 0x60) | state->ber_monitored_layer);\r\nelse\r\ndib8000_write_word(state, 285, dib8000_read_word(state, 285) & 0x60);\r\ni = dib8000_read_word(state, 26) & 1;\r\ndib8000_write_word(state, 26, state->fe[0]->dtv_property_cache.inversion^i);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {\r\nint seg_offset =\r\nstate->fe[0]->dtv_property_cache.isdbt_sb_segment_idx -\r\n(state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) -\r\n(state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2);\r\nint clk = state->cfg.pll->internal;\r\nu32 segtodds = ((u32) (430 << 23) / clk) << 3;\r\nint dds_offset = seg_offset * segtodds;\r\nint new_dds, sub_channel;\r\nif ((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\r\ndds_offset -= (int)(segtodds / 2);\r\nif (state->cfg.pll->ifreq == 0) {\r\nif ((state->fe[0]->dtv_property_cache.inversion ^ i) == 0) {\r\ndib8000_write_word(state, 26, dib8000_read_word(state, 26) | 1);\r\nnew_dds = dds_offset;\r\n} else\r\nnew_dds = dds_offset;\r\nif ((state->fe[0]->dtv_property_cache.delivery_system == SYS_ISDBT)\r\n&& (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1)\r\n&& (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2)\r\n&& (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx ==\r\n((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) + 1)))\r\n|| (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\r\n&& (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx == (state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2)))\r\n|| (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\r\n&& (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx ==\r\n((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) + 1)))\r\n)) {\r\nnew_dds -= ((u32) (850 << 22) / clk) << 4;\r\n}\r\n} else {\r\nif ((state->fe[0]->dtv_property_cache.inversion ^ i) == 0)\r\nnew_dds = state->cfg.pll->ifreq - dds_offset;\r\nelse\r\nnew_dds = state->cfg.pll->ifreq + dds_offset;\r\n}\r\ndib8000_write_word(state, 27, (u16) ((new_dds >> 16) & 0x01ff));\r\ndib8000_write_word(state, 28, (u16) (new_dds & 0xffff));\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2)\r\nsub_channel = ((state->fe[0]->dtv_property_cache.isdbt_sb_subchannel + (3 * seg_offset) + 1) % 41) / 3;\r\nelse\r\nsub_channel = ((state->fe[0]->dtv_property_cache.isdbt_sb_subchannel + (3 * seg_offset)) % 41) / 3;\r\nsub_channel -= 6;\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_2K\r\n|| state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_4K) {\r\ndib8000_write_word(state, 219, dib8000_read_word(state, 219) | 0x1);\r\ndib8000_write_word(state, 190, dib8000_read_word(state, 190) | (0x1 << 14));\r\n} else {\r\ndib8000_write_word(state, 219, dib8000_read_word(state, 219) & 0xfffe);\r\ndib8000_write_word(state, 190, dib8000_read_word(state, 190) & 0xbfff);\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nswitch (sub_channel) {\r\ncase -6:\r\ninit_prbs = 0x0;\r\nbreak;\r\ncase -5:\r\ninit_prbs = 0x423;\r\nbreak;\r\ncase -4:\r\ninit_prbs = 0x9;\r\nbreak;\r\ncase -3:\r\ninit_prbs = 0x5C7;\r\nbreak;\r\ncase -2:\r\ninit_prbs = 0x7A6;\r\nbreak;\r\ncase -1:\r\ninit_prbs = 0x3D8;\r\nbreak;\r\ncase 0:\r\ninit_prbs = 0x527;\r\nbreak;\r\ncase 1:\r\ninit_prbs = 0x7FF;\r\nbreak;\r\ncase 2:\r\ninit_prbs = 0x79B;\r\nbreak;\r\ncase 3:\r\ninit_prbs = 0x3D6;\r\nbreak;\r\ncase 4:\r\ninit_prbs = 0x3A2;\r\nbreak;\r\ncase 5:\r\ninit_prbs = 0x53B;\r\nbreak;\r\ncase 6:\r\ninit_prbs = 0x2F4;\r\nbreak;\r\ndefault:\r\ncase 7:\r\ninit_prbs = 0x213;\r\nbreak;\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nswitch (sub_channel) {\r\ncase -6:\r\ninit_prbs = 0x0;\r\nbreak;\r\ncase -5:\r\ninit_prbs = 0x208;\r\nbreak;\r\ncase -4:\r\ninit_prbs = 0xC3;\r\nbreak;\r\ncase -3:\r\ninit_prbs = 0x7B9;\r\nbreak;\r\ncase -2:\r\ninit_prbs = 0x423;\r\nbreak;\r\ncase -1:\r\ninit_prbs = 0x5C7;\r\nbreak;\r\ncase 0:\r\ninit_prbs = 0x3D8;\r\nbreak;\r\ncase 1:\r\ninit_prbs = 0x7FF;\r\nbreak;\r\ncase 2:\r\ninit_prbs = 0x3D6;\r\nbreak;\r\ncase 3:\r\ninit_prbs = 0x53B;\r\nbreak;\r\ncase 4:\r\ninit_prbs = 0x213;\r\nbreak;\r\ncase 5:\r\ninit_prbs = 0x29;\r\nbreak;\r\ncase 6:\r\ninit_prbs = 0xD0;\r\nbreak;\r\ndefault:\r\ncase 7:\r\ninit_prbs = 0x48E;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K:\r\nswitch (sub_channel) {\r\ncase -6:\r\ninit_prbs = 0x0;\r\nbreak;\r\ncase -5:\r\ninit_prbs = 0x740;\r\nbreak;\r\ncase -4:\r\ninit_prbs = 0x069;\r\nbreak;\r\ncase -3:\r\ninit_prbs = 0x7DD;\r\nbreak;\r\ncase -2:\r\ninit_prbs = 0x208;\r\nbreak;\r\ncase -1:\r\ninit_prbs = 0x7B9;\r\nbreak;\r\ncase 0:\r\ninit_prbs = 0x5C7;\r\nbreak;\r\ncase 1:\r\ninit_prbs = 0x7FF;\r\nbreak;\r\ncase 2:\r\ninit_prbs = 0x53B;\r\nbreak;\r\ncase 3:\r\ninit_prbs = 0x29;\r\nbreak;\r\ncase 4:\r\ninit_prbs = 0x48E;\r\nbreak;\r\ncase 5:\r\ninit_prbs = 0x4C4;\r\nbreak;\r\ncase 6:\r\ninit_prbs = 0x367;\r\nbreak;\r\ndefault:\r\ncase 7:\r\ninit_prbs = 0x684;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n} else {\r\ndib8000_write_word(state, 27, (u16) ((state->cfg.pll->ifreq >> 16) & 0x01ff));\r\ndib8000_write_word(state, 28, (u16) (state->cfg.pll->ifreq & 0xffff));\r\ndib8000_write_word(state, 26, (u16) ((state->cfg.pll->ifreq >> 25) & 0x0003));\r\n}\r\ndib8000_write_word(state, 10, (seq << 4));\r\nswitch (state->fe[0]->dtv_property_cache.guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\nguard = 0;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nguard = 1;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nguard = 2;\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\ndefault:\r\nguard = 3;\r\nbreak;\r\n}\r\ndib8000_write_word(state, 1, (init_prbs << 2) | (guard & 0x3));\r\nmax_constellation = DQPSK;\r\nfor (i = 0; i < 3; i++) {\r\nswitch (state->fe[0]->dtv_property_cache.layer[i].modulation) {\r\ncase DQPSK:\r\nconstellation = 0;\r\nbreak;\r\ncase QPSK:\r\nconstellation = 1;\r\nbreak;\r\ncase QAM_16:\r\nconstellation = 2;\r\nbreak;\r\ncase QAM_64:\r\ndefault:\r\nconstellation = 3;\r\nbreak;\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.layer[i].fec) {\r\ncase FEC_1_2:\r\ncrate = 1;\r\nbreak;\r\ncase FEC_2_3:\r\ncrate = 2;\r\nbreak;\r\ncase FEC_3_4:\r\ncrate = 3;\r\nbreak;\r\ncase FEC_5_6:\r\ncrate = 5;\r\nbreak;\r\ncase FEC_7_8:\r\ndefault:\r\ncrate = 7;\r\nbreak;\r\n}\r\nif ((state->fe[0]->dtv_property_cache.layer[i].interleaving > 0) &&\r\n((state->fe[0]->dtv_property_cache.layer[i].interleaving <= 3) ||\r\n(state->fe[0]->dtv_property_cache.layer[i].interleaving == 4 && state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1))\r\n)\r\ntimeI = state->fe[0]->dtv_property_cache.layer[i].interleaving;\r\nelse\r\ntimeI = 0;\r\ndib8000_write_word(state, 2 + i, (constellation << 10) | ((state->fe[0]->dtv_property_cache.layer[i].segment_count & 0xf) << 6) |\r\n(crate << 3) | timeI);\r\nif (state->fe[0]->dtv_property_cache.layer[i].segment_count > 0) {\r\nswitch (max_constellation) {\r\ncase DQPSK:\r\ncase QPSK:\r\nif (state->fe[0]->dtv_property_cache.layer[i].modulation == QAM_16 ||\r\nstate->fe[0]->dtv_property_cache.layer[i].modulation == QAM_64)\r\nmax_constellation = state->fe[0]->dtv_property_cache.layer[i].modulation;\r\nbreak;\r\ncase QAM_16:\r\nif (state->fe[0]->dtv_property_cache.layer[i].modulation == QAM_64)\r\nmax_constellation = state->fe[0]->dtv_property_cache.layer[i].modulation;\r\nbreak;\r\n}\r\n}\r\n}\r\nmode = fft_to_mode(state);\r\ndib8000_write_word(state, 274, (dib8000_read_word(state, 274) & 0xffcf) |\r\n((state->fe[0]->dtv_property_cache.isdbt_partial_reception & 1) << 5) | ((state->fe[0]->dtv_property_cache.\r\nisdbt_sb_mode & 1) << 4));\r\ndprintk("mode = %d ; guard = %d", mode, state->fe[0]->dtv_property_cache.guard_interval);\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception) {\r\nseg_diff_mask = (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) << permu_seg[0];\r\nfor (i = 1; i < 3; i++)\r\nnbseg_diff +=\r\n(state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * state->fe[0]->dtv_property_cache.layer[i].segment_count;\r\nfor (i = 0; i < nbseg_diff; i++)\r\nseg_diff_mask |= 1 << permu_seg[i + 1];\r\n} else {\r\nfor (i = 0; i < 3; i++)\r\nnbseg_diff +=\r\n(state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * state->fe[0]->dtv_property_cache.layer[i].segment_count;\r\nfor (i = 0; i < nbseg_diff; i++)\r\nseg_diff_mask |= 1 << permu_seg[i];\r\n}\r\ndprintk("nbseg_diff = %X (%d)", seg_diff_mask, seg_diff_mask);\r\nstate->differential_constellation = (seg_diff_mask != 0);\r\ndib8000_set_diversity_in(state->fe[0], state->diversity_onoff);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 1)\r\nseg_mask13 = 0x00E0;\r\nelse\r\nseg_mask13 = 0x0040;\r\n} else\r\nseg_mask13 = 0x1fff;\r\ndib8000_write_word(state, 0, (mode << 13) | seg_diff_mask);\r\nif ((seg_diff_mask) || (state->fe[0]->dtv_property_cache.isdbt_sb_mode))\r\ndib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);\r\nelse\r\ndib8000_write_word(state, 268, (2 << 9) | 39);\r\ndib8000_write_word(state, 352, seg_diff_mask);\r\ndib8000_write_word(state, 353, seg_mask13);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_1seg;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_3seg_0dqpsk_1dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_3seg_0dqpsk;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_3seg_1dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)\r\nncoeff = coeff_4k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_4k_sb_1seg;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {\r\nncoeff = coeff_4k_sb_3seg_0dqpsk_1dqpsk;\r\n} else {\r\nncoeff = coeff_4k_sb_3seg_0dqpsk;\r\n}\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {\r\nncoeff = coeff_4k_sb_3seg_1dqpsk;\r\n} else\r\nncoeff = coeff_4k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_AUTO:\r\ncase TRANSMISSION_MODE_8K:\r\ndefault:\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)\r\nncoeff = coeff_8k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_8k_sb_1seg;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {\r\nncoeff = coeff_8k_sb_3seg_0dqpsk_1dqpsk;\r\n} else {\r\nncoeff = coeff_8k_sb_3seg_0dqpsk;\r\n}\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {\r\nncoeff = coeff_8k_sb_3seg_1dqpsk;\r\n} else\r\nncoeff = coeff_8k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\n}\r\nfor (i = 0; i < 8; i++)\r\ndib8000_write_word(state, 343 + i, ncoeff[i]);\r\n}\r\ndib8000_write_word(state, 351,\r\n(state->fe[0]->dtv_property_cache.isdbt_sb_mode << 9) | (state->fe[0]->dtv_property_cache.isdbt_sb_mode << 8) | (13 << 4) | 5);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\ndib8000_write_word(state, 187,\r\n(4 << 12) | (0 << 11) | (63 << 5) | (0x3 << 3) | ((~state->fe[0]->dtv_property_cache.isdbt_partial_reception & 1) << 2)\r\n| 0x3);\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\nif (mode == 3)\r\ndib8000_write_word(state, 180, 0x1fcf | ((mode - 1) << 14));\r\nelse\r\ndib8000_write_word(state, 180, 0x0fcf | ((mode - 1) << 14));\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (5 << 5) | 4);\r\ndib8000_write_word(state, 340, (16 << 6) | (8 << 0));\r\ndib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\r\ndib8000_write_word(state, 181, 300);\r\ndib8000_write_word(state, 182, 150);\r\ndib8000_write_word(state, 183, 80);\r\ndib8000_write_word(state, 184, 300);\r\ndib8000_write_word(state, 185, 150);\r\ndib8000_write_word(state, 186, 80);\r\n} else {\r\ndib8000_write_word(state, 180, 0x1fcf | (1 << 14));\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (4 << 5) | 4);\r\ndib8000_write_word(state, 340, (16 << 6) | (8 << 0));\r\ndib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\r\ndib8000_write_word(state, 181, 350);\r\ndib8000_write_word(state, 182, 300);\r\ndib8000_write_word(state, 183, 250);\r\ndib8000_write_word(state, 184, 350);\r\ndib8000_write_word(state, 185, 300);\r\ndib8000_write_word(state, 186, 250);\r\n}\r\n} else if (state->isdbt_cfg_loaded == 0) {\r\ndib8000_write_word(state, 180, (16 << 6) | 9);\r\ndib8000_write_word(state, 187, (4 << 12) | (8 << 5) | 0x2);\r\ncoff_pow = 0x2800;\r\nfor (i = 0; i < 6; i++)\r\ndib8000_write_word(state, 181 + i, coff_pow);\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (3 << 5) | 1);\r\ndib8000_write_word(state, 340, (8 << 6) | (6 << 0));\r\ndib8000_write_word(state, 341, (4 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\r\n}\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1 && state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)\r\ndib8000_write_word(state, 178, 64);\r\nelse\r\ndib8000_write_word(state, 178, 32);\r\ndib8000_write_word(state, 189, ~seg_mask13 | seg_diff_mask);\r\ndib8000_write_word(state, 192, ~seg_mask13 | seg_diff_mask);\r\ndib8000_write_word(state, 225, ~seg_mask13 | seg_diff_mask);\r\nif ((!state->fe[0]->dtv_property_cache.isdbt_sb_mode) && (state->cfg.pll->ifreq == 0))\r\ndib8000_write_word(state, 266, ~seg_mask13 | seg_diff_mask | 0x40);\r\nelse\r\ndib8000_write_word(state, 266, ~seg_mask13 | seg_diff_mask);\r\ndib8000_write_word(state, 287, ~seg_mask13 | 0x1000);\r\nif (!autosearching)\r\ndib8000_write_word(state, 288, (~seg_mask13 | seg_diff_mask) & 0x1fff);\r\nelse\r\ndib8000_write_word(state, 288, 0x1fff);\r\ndprintk("287 = %X (%d)", ~seg_mask13 | 0x1000, ~seg_mask13 | 0x1000);\r\ndib8000_write_word(state, 211, seg_mask13 & (~seg_diff_mask));\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)\r\ndib8000_write_word(state, 32, ((11 - mode) << 12) | (6 << 8) | 0x40);\r\nelse\r\ndib8000_write_word(state, 32, ((10 - mode) << 12) | (6 << 8) | 0x60);\r\n} else\r\ndib8000_write_word(state, 32, ((9 - mode) << 12) | (6 << 8) | 0x80);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)\r\ndib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (10 - mode));\r\nelse\r\ndib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (9 - mode));\r\n} else\r\ndib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (8 - mode));\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_8K:\r\nmode = 256;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nmode = 128;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_2K:\r\nmode = 64;\r\nbreak;\r\n}\r\nif (state->cfg.diversity_delay == 0)\r\nmode = (mode * (1 << (guard)) * 3) / 2 + 48;\r\nelse\r\nmode = (mode * (1 << (guard)) * 3) / 2 + state->cfg.diversity_delay;\r\nmode <<= 4;\r\ndib8000_write_word(state, 273, (dib8000_read_word(state, 273) & 0x000f) | mode);\r\nswitch (max_constellation) {\r\ncase QAM_64:\r\nana_gain = 0x7;\r\ncoeff[0] = 0x0148;\r\ncoeff[1] = 0xfff0;\r\ncoeff[2] = 0x00a4;\r\ncoeff[3] = 0xfff8;\r\nbreak;\r\ncase QAM_16:\r\nana_gain = 0x7;\r\ncoeff[0] = 0x023d;\r\ncoeff[1] = 0xffdf;\r\ncoeff[2] = 0x00a4;\r\ncoeff[3] = 0xfff0;\r\nbreak;\r\ndefault:\r\nana_gain = 0;\r\ncoeff[0] = 0x099a;\r\ncoeff[1] = 0xffae;\r\ncoeff[2] = 0x0333;\r\ncoeff[3] = 0xfff8;\r\nbreak;\r\n}\r\nfor (mode = 0; mode < 4; mode++)\r\ndib8000_write_word(state, 215 + mode, coeff[mode]);\r\ndib8000_write_word(state, 116, ana_gain);\r\nif (ana_gain) {\r\nfor (i = 0; i < 10; i++)\r\ndib8000_write_word(state, 80 + i, adc_target_16dB[i]);\r\n} else {\r\nfor (i = 0; i < 10; i++)\r\ndib8000_write_word(state, 80 + i, adc_target_16dB[i] - 355);\r\n}\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 1)\r\nana_fe = ana_fe_coeff_3seg;\r\nelse\r\nana_fe = ana_fe_coeff_1seg;\r\n} else\r\nana_fe = ana_fe_coeff_13seg;\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1 || state->isdbt_cfg_loaded == 0)\r\nfor (mode = 0; mode < 24; mode++)\r\ndib8000_write_word(state, 117 + mode, ana_fe[mode]);\r\nfor (i = 0; i < 13; i++) {\r\nif ((((~seg_diff_mask) >> i) & 1) == 1) {\r\nP_cfr_left_edge += (1 << i) * ((i == 0) || ((((seg_mask13 & (~seg_diff_mask)) >> (i - 1)) & 1) == 0));\r\nP_cfr_right_edge += (1 << i) * ((i == 12) || ((((seg_mask13 & (~seg_diff_mask)) >> (i + 1)) & 1) == 0));\r\n}\r\n}\r\ndib8000_write_word(state, 222, P_cfr_left_edge);\r\ndib8000_write_word(state, 223, P_cfr_right_edge);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\ndib8000_write_word(state, 228, 1);\r\ndib8000_write_word(state, 205, dib8000_read_word(state, 205) & 0xfff0);\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0\r\n&& state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_2K) {\r\ndib8000_write_word(state, 265, 15);\r\n}\r\n} else if (state->isdbt_cfg_loaded == 0) {\r\ndib8000_write_word(state, 228, 0);\r\ndib8000_write_word(state, 265, 31);\r\ndib8000_write_word(state, 205, 0x200f);\r\n}\r\nfor (i = 0; i < 3; i++)\r\ntmcc_pow +=\r\n(((state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * 4 + 1) * state->fe[0]->dtv_property_cache.layer[i].segment_count);\r\ntmcc_pow *= (1 << (9 - 2));\r\ndib8000_write_word(state, 290, tmcc_pow);\r\ndib8000_write_word(state, 291, tmcc_pow);\r\ndib8000_write_word(state, 292, tmcc_pow);\r\nif (state->isdbt_cfg_loaded == 0)\r\ndib8000_write_word(state, 250, 3285);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1)\r\nstate->isdbt_cfg_loaded = 0;\r\nelse\r\nstate->isdbt_cfg_loaded = 1;\r\n}\r\nstatic int dib8000_autosearch_start(struct dvb_frontend *fe)\r\n{\r\nu8 factor;\r\nu32 value;\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nint slist = 0;\r\nstate->fe[0]->dtv_property_cache.inversion = 0;\r\nif (!state->fe[0]->dtv_property_cache.isdbt_sb_mode)\r\nstate->fe[0]->dtv_property_cache.layer[0].segment_count = 13;\r\nstate->fe[0]->dtv_property_cache.layer[0].modulation = QAM_64;\r\nstate->fe[0]->dtv_property_cache.layer[0].fec = FEC_2_3;\r\nstate->fe[0]->dtv_property_cache.layer[0].interleaving = 0;\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {\r\nstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;\r\nslist = 7;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO) {\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) {\r\nslist = 7;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else\r\nslist = 3;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) {\r\nslist = 2;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else\r\nslist = 0;\r\n}\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO)\r\nstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;\r\nif (state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO)\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;\r\ndprintk("using list for autosearch : %d", slist);\r\ndib8000_set_channel(state, (unsigned char)slist, 1);\r\nfactor = 1;\r\ndib8000_write_word(state, 6, 0x4);\r\ndib8000_write_word(state, 7, 0x8);\r\ndib8000_write_word(state, 8, 0x1000);\r\nvalue = 50 * state->cfg.pll->internal * factor;\r\ndib8000_write_word(state, 11, (u16) ((value >> 16) & 0xffff));\r\ndib8000_write_word(state, 12, (u16) (value & 0xffff));\r\nvalue = 100 * state->cfg.pll->internal * factor;\r\ndib8000_write_word(state, 13, (u16) ((value >> 16) & 0xffff));\r\ndib8000_write_word(state, 14, (u16) (value & 0xffff));\r\nvalue = 1000 * state->cfg.pll->internal * factor;\r\ndib8000_write_word(state, 15, (u16) ((value >> 16) & 0xffff));\r\ndib8000_write_word(state, 16, (u16) (value & 0xffff));\r\nvalue = dib8000_read_word(state, 0);\r\ndib8000_write_word(state, 0, (u16) ((1 << 15) | value));\r\ndib8000_read_word(state, 1284);\r\ndib8000_write_word(state, 0, (u16) value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_autosearch_irq(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 irq_pending = dib8000_read_word(state, 1284);\r\nif (irq_pending & 0x1) {\r\ndprintk("dib8000_autosearch_irq failed");\r\nreturn 1;\r\n}\r\nif (irq_pending & 0x2) {\r\ndprintk("dib8000_autosearch_irq succeeded");\r\nreturn 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_tune(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\nu16 value, mode = fft_to_mode(state);\r\nif (state == NULL)\r\nreturn -EINVAL;\r\ndib8000_set_bandwidth(fe, state->fe[0]->dtv_property_cache.bandwidth_hz / 1000);\r\ndib8000_set_channel(state, 0, 0);\r\nret |= dib8000_write_word(state, 770, 0x4000);\r\nret |= dib8000_write_word(state, 770, 0x0000);\r\nmsleep(45);\r\nif (state->timf == 0) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)\r\nmsleep(300);\r\nelse\r\nmsleep(500);\r\n} else\r\nmsleep(200);\r\n}\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\ndib8000_write_word(state, 32, ((13 - mode) << 12) | (6 << 8) | 0x40);\r\nret |= dib8000_write_word(state, 37, (12 - mode) | ((5 + mode) << 5));\r\n} else {\r\ndib8000_write_word(state, 32, ((12 - mode) << 12) | (6 << 8) | 0x60);\r\nret |= dib8000_write_word(state, 37, (11 - mode) | ((5 + mode) << 5));\r\n}\r\n} else {\r\ndib8000_write_word(state, 32, ((11 - mode) << 12) | (6 << 8) | 0x80);\r\nret |= dib8000_write_word(state, 37, (10 - mode) | ((5 + mode) << 5));\r\n}\r\nif ((dib8000_read_word(state, 568) >> 11) & 0x1)\r\ndib8000_update_timf(state);\r\ndib8000_write_word(state, 6, 0x200);\r\nif (state->revision == 0x8002) {\r\nvalue = dib8000_read_word(state, 903);\r\ndib8000_write_word(state, 903, value & ~(1 << 3));\r\nmsleep(1);\r\ndib8000_write_word(state, 903, value | (1 << 3));\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib8000_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nint ret;\r\ndib8000_set_power_mode(state, DIB8000M_POWER_ALL);\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\nif (dib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON) != 0)\r\ndprintk("could not start Slow ADC");\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nret = state->fe[index_frontend]->ops.init(state->fe[index_frontend]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nint ret;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nret = state->fe[index_frontend]->ops.sleep(state->fe[index_frontend]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndib8000_set_output_mode(fe, OUTMODE_HIGH_Z);\r\ndib8000_set_power_mode(state, DIB8000M_POWER_INTERFACE_ONLY);\r\nreturn dib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF) | dib8000_set_adc_state(state, DIBX000_ADC_OFF);\r\n}\r\nenum frontend_tune_state dib8000_get_tune_state(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nreturn state->tune_state;\r\n}\r\nint dib8000_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstate->tune_state = tune_state;\r\nreturn 0;\r\n}\r\nstatic int dib8000_get_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *fep)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 i, val = 0;\r\nfe_status_t stat;\r\nu8 index_frontend, sub_index_frontend;\r\nfe->dtv_property_cache.bandwidth_hz = 6000000;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->ops.read_status(state->fe[index_frontend], &stat);\r\nif (stat&FE_HAS_SYNC) {\r\ndprintk("TMCC lock on the slave%i", index_frontend);\r\nstate->fe[index_frontend]->ops.get_frontend(state->fe[index_frontend], fep);\r\nfor (sub_index_frontend = 0; (sub_index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[sub_index_frontend] != NULL); sub_index_frontend++) {\r\nif (sub_index_frontend != index_frontend) {\r\nstate->fe[sub_index_frontend]->dtv_property_cache.isdbt_sb_mode = state->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.inversion = state->fe[index_frontend]->dtv_property_cache.inversion;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.transmission_mode = state->fe[index_frontend]->dtv_property_cache.transmission_mode;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.guard_interval = state->fe[index_frontend]->dtv_property_cache.guard_interval;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.isdbt_partial_reception = state->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception;\r\nfor (i = 0; i < 3; i++) {\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].segment_count = state->fe[index_frontend]->dtv_property_cache.layer[i].segment_count;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].interleaving = state->fe[index_frontend]->dtv_property_cache.layer[i].interleaving;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].fec = state->fe[index_frontend]->dtv_property_cache.layer[i].fec;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].modulation = state->fe[index_frontend]->dtv_property_cache.layer[i].modulation;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\n}\r\nfe->dtv_property_cache.isdbt_sb_mode = dib8000_read_word(state, 508) & 0x1;\r\nval = dib8000_read_word(state, 570);\r\nfe->dtv_property_cache.inversion = (val & 0x40) >> 6;\r\nswitch ((val & 0x30) >> 4) {\r\ncase 1:\r\nfe->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nfe->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nswitch (val & 0x3) {\r\ncase 0:\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_32;\r\ndprintk("dib8000_get_frontend GI = 1/32 ");\r\nbreak;\r\ncase 1:\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_16;\r\ndprintk("dib8000_get_frontend GI = 1/16 ");\r\nbreak;\r\ncase 2:\r\ndprintk("dib8000_get_frontend GI = 1/8 ");\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\ndprintk("dib8000_get_frontend GI = 1/4 ");\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nval = dib8000_read_word(state, 505);\r\nfe->dtv_property_cache.isdbt_partial_reception = val & 1;\r\ndprintk("dib8000_get_frontend : partial_reception = %d ", fe->dtv_property_cache.isdbt_partial_reception);\r\nfor (i = 0; i < 3; i++) {\r\nval = dib8000_read_word(state, 493 + i);\r\nfe->dtv_property_cache.layer[i].segment_count = val & 0x0F;\r\ndprintk("dib8000_get_frontend : Layer %d segments = %d ", i, fe->dtv_property_cache.layer[i].segment_count);\r\nval = dib8000_read_word(state, 499 + i);\r\nfe->dtv_property_cache.layer[i].interleaving = val & 0x3;\r\ndprintk("dib8000_get_frontend : Layer %d time_intlv = %d ", i, fe->dtv_property_cache.layer[i].interleaving);\r\nval = dib8000_read_word(state, 481 + i);\r\nswitch (val & 0x7) {\r\ncase 1:\r\nfe->dtv_property_cache.layer[i].fec = FEC_1_2;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 1/2 ", i);\r\nbreak;\r\ncase 2:\r\nfe->dtv_property_cache.layer[i].fec = FEC_2_3;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 2/3 ", i);\r\nbreak;\r\ncase 3:\r\nfe->dtv_property_cache.layer[i].fec = FEC_3_4;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 3/4 ", i);\r\nbreak;\r\ncase 5:\r\nfe->dtv_property_cache.layer[i].fec = FEC_5_6;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 5/6 ", i);\r\nbreak;\r\ndefault:\r\nfe->dtv_property_cache.layer[i].fec = FEC_7_8;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 7/8 ", i);\r\nbreak;\r\n}\r\nval = dib8000_read_word(state, 487 + i);\r\nswitch (val & 0x3) {\r\ncase 0:\r\ndprintk("dib8000_get_frontend : Layer %d DQPSK ", i);\r\nfe->dtv_property_cache.layer[i].modulation = DQPSK;\r\nbreak;\r\ncase 1:\r\nfe->dtv_property_cache.layer[i].modulation = QPSK;\r\ndprintk("dib8000_get_frontend : Layer %d QPSK ", i);\r\nbreak;\r\ncase 2:\r\nfe->dtv_property_cache.layer[i].modulation = QAM_16;\r\ndprintk("dib8000_get_frontend : Layer %d QAM16 ", i);\r\nbreak;\r\ncase 3:\r\ndefault:\r\ndprintk("dib8000_get_frontend : Layer %d QAM64 ", i);\r\nfe->dtv_property_cache.layer[i].modulation = QAM_64;\r\nbreak;\r\n}\r\n}\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode = fe->dtv_property_cache.isdbt_sb_mode;\r\nstate->fe[index_frontend]->dtv_property_cache.inversion = fe->dtv_property_cache.inversion;\r\nstate->fe[index_frontend]->dtv_property_cache.transmission_mode = fe->dtv_property_cache.transmission_mode;\r\nstate->fe[index_frontend]->dtv_property_cache.guard_interval = fe->dtv_property_cache.guard_interval;\r\nstate->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception = fe->dtv_property_cache.isdbt_partial_reception;\r\nfor (i = 0; i < 3; i++) {\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].segment_count = fe->dtv_property_cache.layer[i].segment_count;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].interleaving = fe->dtv_property_cache.layer[i].interleaving;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].fec = fe->dtv_property_cache.layer[i].fec;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].modulation = fe->dtv_property_cache.layer[i].modulation;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *fep)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 nbr_pending, exit_condition, index_frontend;\r\ns8 index_frontend_success = -1;\r\nint time, ret;\r\nint time_slave = FE_CALLBACK_TIME_NEVER;\r\nif (state->fe[0]->dtv_property_cache.frequency == 0) {\r\ndprintk("dib8000: must at least specify frequency ");\r\nreturn 0;\r\n}\r\nif (state->fe[0]->dtv_property_cache.bandwidth_hz == 0) {\r\ndprintk("dib8000: no bandwidth specified, set to default ");\r\nstate->fe[0]->dtv_property_cache.bandwidth_hz = 6000000;\r\n}\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->dtv_property_cache.delivery_system = SYS_ISDBT;\r\nmemcpy(&state->fe[index_frontend]->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));\r\ndib8000_set_output_mode(state->fe[index_frontend], OUTMODE_HIGH_Z);\r\nif (state->fe[index_frontend]->ops.tuner_ops.set_params)\r\nstate->fe[index_frontend]->ops.tuner_ops.set_params(state->fe[index_frontend], fep);\r\ndib8000_set_tune_state(state->fe[index_frontend], CT_AGC_START);\r\n}\r\ndo {\r\ntime = dib8000_agc_startup(state->fe[0]);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\ntime_slave = dib8000_agc_startup(state->fe[index_frontend]);\r\nif (time == FE_CALLBACK_TIME_NEVER)\r\ntime = time_slave;\r\nelse if ((time_slave != FE_CALLBACK_TIME_NEVER) && (time_slave > time))\r\ntime = time_slave;\r\n}\r\nif (time != FE_CALLBACK_TIME_NEVER)\r\nmsleep(time / 10);\r\nelse\r\nbreak;\r\nexit_condition = 1;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (dib8000_get_tune_state(state->fe[index_frontend]) != CT_AGC_STOP) {\r\nexit_condition = 0;\r\nbreak;\r\n}\r\n}\r\n} while (exit_condition == 0);\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\ndib8000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);\r\nif ((state->fe[0]->dtv_property_cache.delivery_system != SYS_ISDBT) ||\r\n(state->fe[0]->dtv_property_cache.inversion == INVERSION_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO) ||\r\n(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 0)) != 0) &&\r\n(state->fe[0]->dtv_property_cache.layer[0].segment_count != 0xff) &&\r\n(state->fe[0]->dtv_property_cache.layer[0].segment_count != 0) &&\r\n((state->fe[0]->dtv_property_cache.layer[0].modulation == QAM_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.layer[0].fec == FEC_AUTO))) ||\r\n(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 1)) != 0) &&\r\n(state->fe[0]->dtv_property_cache.layer[1].segment_count != 0xff) &&\r\n(state->fe[0]->dtv_property_cache.layer[1].segment_count != 0) &&\r\n((state->fe[0]->dtv_property_cache.layer[1].modulation == QAM_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.layer[1].fec == FEC_AUTO))) ||\r\n(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 2)) != 0) &&\r\n(state->fe[0]->dtv_property_cache.layer[2].segment_count != 0xff) &&\r\n(state->fe[0]->dtv_property_cache.layer[2].segment_count != 0) &&\r\n((state->fe[0]->dtv_property_cache.layer[2].modulation == QAM_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.layer[2].fec == FEC_AUTO))) ||\r\n(((state->fe[0]->dtv_property_cache.layer[0].segment_count == 0) ||\r\n((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 0)) == 0)) &&\r\n((state->fe[0]->dtv_property_cache.layer[1].segment_count == 0) ||\r\n((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (2 << 0)) == 0)) &&\r\n((state->fe[0]->dtv_property_cache.layer[2].segment_count == 0) || ((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (3 << 0)) == 0)))) {\r\nint i = 80000;\r\nu8 found = 0;\r\nu8 tune_failed = 0;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\ndib8000_set_bandwidth(state->fe[index_frontend], fe->dtv_property_cache.bandwidth_hz / 1000);\r\ndib8000_autosearch_start(state->fe[index_frontend]);\r\n}\r\ndo {\r\nmsleep(20);\r\nnbr_pending = 0;\r\nexit_condition = 0;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (((tune_failed >> index_frontend) & 0x1) == 0) {\r\nfound = dib8000_autosearch_irq(state->fe[index_frontend]);\r\nswitch (found) {\r\ncase 0:\r\nnbr_pending++;\r\nbreak;\r\ncase 2:\r\ndprintk("autosearch succeed on the frontend%i", index_frontend);\r\nexit_condition = 2;\r\nindex_frontend_success = index_frontend;\r\nbreak;\r\ndefault:\r\ndprintk("unhandled autosearch result");\r\ncase 1:\r\ndprintk("autosearch failed for the frontend%i", index_frontend);\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((nbr_pending == 0) && (exit_condition == 0))\r\nexit_condition = 1;\r\n} while ((exit_condition == 0) && i--);\r\nif (exit_condition == 1) {\r\ndprintk("tune failed");\r\nreturn 0;\r\n}\r\ndprintk("tune success on frontend%i", index_frontend_success);\r\ndib8000_get_frontend(fe, fep);\r\n}\r\nfor (index_frontend = 0, ret = 0; (ret >= 0) && (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nret = dib8000_tune(state->fe[index_frontend]);\r\ndib8000_set_output_mode(state->fe[0], state->cfg.output_mode);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\ndib8000_set_output_mode(state->fe[index_frontend], OUTMODE_DIVERSITY);\r\ndib8000_set_diversity_in(state->fe[index_frontend-1], 1);\r\n}\r\ndib8000_set_diversity_in(state->fe[index_frontend-1], 0);\r\nreturn ret;\r\n}\r\nstatic u16 dib8000_read_lock(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nreturn dib8000_read_word(state, 568);\r\n}\r\nstatic int dib8000_read_status(struct dvb_frontend *fe, fe_status_t * stat)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 lock_slave = 0, lock = dib8000_read_word(state, 568);\r\nu8 index_frontend;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nlock_slave |= dib8000_read_lock(state->fe[index_frontend]);\r\n*stat = 0;\r\nif (((lock >> 13) & 1) || ((lock_slave >> 13) & 1))\r\n*stat |= FE_HAS_SIGNAL;\r\nif (((lock >> 8) & 1) || ((lock_slave >> 8) & 1))\r\n*stat |= FE_HAS_CARRIER;\r\nif ((((lock >> 1) & 0xf) == 0xf) || (((lock_slave >> 1) & 0xf) == 0xf))\r\n*stat |= FE_HAS_SYNC;\r\nif ((((lock >> 12) & 1) || ((lock_slave >> 12) & 1)) && ((lock >> 5) & 7))\r\n*stat |= FE_HAS_LOCK;\r\nif (((lock >> 12) & 1) || ((lock_slave >> 12) & 1)) {\r\nlock = dib8000_read_word(state, 554);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\nlock = dib8000_read_word(state, 555);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\nlock = dib8000_read_word(state, 556);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_ber(struct dvb_frontend *fe, u32 * ber)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\n*ber = (dib8000_read_word(state, 560) << 16) | dib8000_read_word(state, 561);\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\n*unc = dib8000_read_word(state, 565);\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu16 val;\r\n*strength = 0;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->ops.read_signal_strength(state->fe[index_frontend], &val);\r\nif (val > 65535 - *strength)\r\n*strength = 65535;\r\nelse\r\n*strength += val;\r\n}\r\nval = 65535 - dib8000_read_word(state, 390);\r\nif (val > 65535 - *strength)\r\n*strength = 65535;\r\nelse\r\n*strength += val;\r\nreturn 0;\r\n}\r\nstatic u32 dib8000_get_snr(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 n, s, exp;\r\nu16 val;\r\nval = dib8000_read_word(state, 542);\r\nn = (val >> 6) & 0xff;\r\nexp = (val & 0x3f);\r\nif ((exp & 0x20) != 0)\r\nexp -= 0x40;\r\nn <<= exp+16;\r\nval = dib8000_read_word(state, 543);\r\ns = (val >> 6) & 0xff;\r\nexp = (val & 0x3f);\r\nif ((exp & 0x20) != 0)\r\nexp -= 0x40;\r\ns <<= exp+16;\r\nif (n > 0) {\r\nu32 t = (s/n) << 16;\r\nreturn t + ((s << 16) - n*t) / n;\r\n}\r\nreturn 0xffffffff;\r\n}\r\nstatic int dib8000_read_snr(struct dvb_frontend *fe, u16 * snr)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu32 snr_master;\r\nsnr_master = dib8000_get_snr(fe);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nsnr_master += dib8000_get_snr(state->fe[index_frontend]);\r\nif (snr_master != 0) {\r\nsnr_master = 10*intlog10(snr_master>>16);\r\n*snr = snr_master / ((1 << 24) / 10);\r\n}\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nint dib8000_set_slave_frontend(struct dvb_frontend *fe, struct dvb_frontend *fe_slave)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend = 1;\r\nwhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\r\nindex_frontend++;\r\nif (index_frontend < MAX_NUMBER_OF_FRONTENDS) {\r\ndprintk("set slave fe %p to index %i", fe_slave, index_frontend);\r\nstate->fe[index_frontend] = fe_slave;\r\nreturn 0;\r\n}\r\ndprintk("too many slave frontend");\r\nreturn -ENOMEM;\r\n}\r\nint dib8000_remove_slave_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend = 1;\r\nwhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\r\nindex_frontend++;\r\nif (index_frontend != 1) {\r\ndprintk("remove slave fe %p (index %i)", state->fe[index_frontend-1], index_frontend-1);\r\nstate->fe[index_frontend] = NULL;\r\nreturn 0;\r\n}\r\ndprintk("no frontend to be removed");\r\nreturn -ENODEV;\r\n}\r\nstruct dvb_frontend *dib8000_get_slave_frontend(struct dvb_frontend *fe, int slave_index)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (slave_index >= MAX_NUMBER_OF_FRONTENDS)\r\nreturn NULL;\r\nreturn state->fe[slave_index];\r\n}\r\nint dib8000_i2c_enumeration(struct i2c_adapter *host, int no_of_demods, u8 default_addr, u8 first_addr)\r\n{\r\nint k = 0, ret = 0;\r\nu8 new_addr = 0;\r\nstruct i2c_device client = {.adap = host };\r\nclient.i2c_write_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);\r\nif (!client.i2c_write_buffer) {\r\ndprintk("%s: not enough memory", __func__);\r\nreturn -ENOMEM;\r\n}\r\nclient.i2c_read_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);\r\nif (!client.i2c_read_buffer) {\r\ndprintk("%s: not enough memory", __func__);\r\nret = -ENOMEM;\r\ngoto error_memory;\r\n}\r\nfor (k = no_of_demods - 1; k >= 0; k--) {\r\nnew_addr = first_addr + (k << 1);\r\nclient.addr = new_addr;\r\ndib8000_i2c_write16(&client, 1287, 0x0003);\r\nif (dib8000_identify(&client) == 0) {\r\ndib8000_i2c_write16(&client, 1287, 0x0003);\r\nclient.addr = default_addr;\r\nif (dib8000_identify(&client) == 0) {\r\ndprintk("#%d: not identified", k);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\n}\r\ndib8000_i2c_write16(&client, 1286, (1 << 10) | (4 << 6));\r\ndib8000_i2c_write16(&client, 1285, (new_addr << 2) | 0x2);\r\nclient.addr = new_addr;\r\ndib8000_identify(&client);\r\ndprintk("IC %d initialized (to i2c_address 0x%x)", k, new_addr);\r\n}\r\nfor (k = 0; k < no_of_demods; k++) {\r\nnew_addr = first_addr | (k << 1);\r\nclient.addr = new_addr;\r\ndib8000_i2c_write16(&client, 1285, new_addr << 2);\r\ndib8000_i2c_write16(&client, 1286, 0);\r\n}\r\nerror:\r\nkfree(client.i2c_read_buffer);\r\nerror_memory:\r\nkfree(client.i2c_write_buffer);\r\nreturn ret;\r\n}\r\nstatic int dib8000_fe_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\ntune->step_size = 0;\r\ntune->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void dib8000_release(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nu8 index_frontend;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (st->fe[index_frontend] != NULL); index_frontend++)\r\ndvb_frontend_detach(st->fe[index_frontend]);\r\ndibx000_exit_i2c_master(&st->i2c_master);\r\nkfree(st->fe[0]);\r\nkfree(st);\r\n}\r\nstruct i2c_adapter *dib8000_get_i2c_master(struct dvb_frontend *fe, enum dibx000_i2c_interface intf, int gating)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nreturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\r\n}\r\nint dib8000_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nu16 val = dib8000_read_word(st, 299) & 0xffef;\r\nval |= (onoff & 0x1) << 4;\r\ndprintk("pid filter enabled %d", onoff);\r\nreturn dib8000_write_word(st, 299, val);\r\n}\r\nint dib8000_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\ndprintk("Index %x, PID %d, OnOff %d", id, pid, onoff);\r\nreturn dib8000_write_word(st, 305 + id, onoff ? (1 << 13) | pid : 0);\r\n}\r\nstruct dvb_frontend *dib8000_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib8000_config *cfg)\r\n{\r\nstruct dvb_frontend *fe;\r\nstruct dib8000_state *state;\r\ndprintk("dib8000_attach");\r\nstate = kzalloc(sizeof(struct dib8000_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nfe = kzalloc(sizeof(struct dvb_frontend), GFP_KERNEL);\r\nif (fe == NULL)\r\ngoto error;\r\nmemcpy(&state->cfg, cfg, sizeof(struct dib8000_config));\r\nstate->i2c.adap = i2c_adap;\r\nstate->i2c.addr = i2c_addr;\r\nstate->i2c.i2c_write_buffer = state->i2c_write_buffer;\r\nstate->i2c.i2c_read_buffer = state->i2c_read_buffer;\r\nstate->gpio_val = cfg->gpio_val;\r\nstate->gpio_dir = cfg->gpio_dir;\r\nif ((state->cfg.output_mode != OUTMODE_MPEG2_SERIAL) && (state->cfg.output_mode != OUTMODE_MPEG2_PAR_GATED_CLK))\r\nstate->cfg.output_mode = OUTMODE_MPEG2_FIFO;\r\nstate->fe[0] = fe;\r\nfe->demodulator_priv = state;\r\nmemcpy(&state->fe[0]->ops, &dib8000_ops, sizeof(struct dvb_frontend_ops));\r\nstate->timf_default = cfg->pll->timf;\r\nif (dib8000_identify(&state->i2c) == 0)\r\ngoto error;\r\ndibx000_init_i2c_master(&state->i2c_master, DIB8000, state->i2c.adap, state->i2c.addr);\r\ndib8000_reset(fe);\r\ndib8000_write_word(state, 285, (dib8000_read_word(state, 285) & ~0x60) | (3 << 5));\r\nreturn fe;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
