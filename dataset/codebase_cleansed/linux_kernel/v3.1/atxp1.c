static struct atxp1_data * atxp1_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client;\r\nstruct atxp1_data *data;\r\nclient = to_i2c_client(dev);\r\ndata = i2c_get_clientdata(client);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\ndata->reg.vid = i2c_smbus_read_byte_data(client, ATXP1_VID);\r\ndata->reg.cpu_vid = i2c_smbus_read_byte_data(client, ATXP1_CVID);\r\ndata->reg.gpio1 = i2c_smbus_read_byte_data(client, ATXP1_GPIO1);\r\ndata->reg.gpio2 = i2c_smbus_read_byte_data(client, ATXP1_GPIO2);\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn(data);\r\n}\r\nstatic ssize_t atxp1_showvcore(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint size;\r\nstruct atxp1_data *data;\r\ndata = atxp1_update_device(dev);\r\nsize = sprintf(buf, "%d\n", vid_from_reg(data->reg.vid & ATXP1_VIDMASK, data->vrm));\r\nreturn size;\r\n}\r\nstatic ssize_t atxp1_storevcore(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct atxp1_data *data;\r\nstruct i2c_client *client;\r\nint vid, cvid;\r\nunsigned int vcore;\r\nclient = to_i2c_client(dev);\r\ndata = atxp1_update_device(dev);\r\nvcore = simple_strtoul(buf, NULL, 10);\r\nvcore /= 25;\r\nvcore *= 25;\r\nvid = vid_to_reg(vcore, data->vrm);\r\nif (vid < 0) {\r\ndev_err(dev, "VID calculation failed.\n");\r\nreturn -1;\r\n}\r\nif (data->reg.vid & ATXP1_VIDENA)\r\ncvid = data->reg.vid & ATXP1_VIDMASK;\r\nelse\r\ncvid = data->reg.cpu_vid;\r\nif (vid == cvid)\r\nreturn count;\r\ndev_dbg(dev, "Setting VCore to %d mV (0x%02x)\n", vcore, vid);\r\nif (cvid > vid) {\r\nfor (; cvid >= vid; cvid--) {\r\ni2c_smbus_write_byte_data(client, ATXP1_VID, cvid | ATXP1_VIDENA);\r\n}\r\n}\r\nelse {\r\nfor (; cvid <= vid; cvid++) {\r\ni2c_smbus_write_byte_data(client, ATXP1_VID, cvid | ATXP1_VIDENA);\r\n}\r\n}\r\ndata->valid = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t atxp1_showgpio1(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint size;\r\nstruct atxp1_data *data;\r\ndata = atxp1_update_device(dev);\r\nsize = sprintf(buf, "0x%02x\n", data->reg.gpio1 & ATXP1_GPIO1MASK);\r\nreturn size;\r\n}\r\nstatic ssize_t atxp1_storegpio1(struct device *dev, struct device_attribute *attr, const char*buf, size_t count)\r\n{\r\nstruct atxp1_data *data;\r\nstruct i2c_client *client;\r\nunsigned int value;\r\nclient = to_i2c_client(dev);\r\ndata = atxp1_update_device(dev);\r\nvalue = simple_strtoul(buf, NULL, 16);\r\nvalue &= ATXP1_GPIO1MASK;\r\nif (value != (data->reg.gpio1 & ATXP1_GPIO1MASK)) {\r\ndev_info(dev, "Writing 0x%x to GPIO1.\n", value);\r\ni2c_smbus_write_byte_data(client, ATXP1_GPIO1, value);\r\ndata->valid = 0;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t atxp1_showgpio2(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint size;\r\nstruct atxp1_data *data;\r\ndata = atxp1_update_device(dev);\r\nsize = sprintf(buf, "0x%02x\n", data->reg.gpio2);\r\nreturn size;\r\n}\r\nstatic ssize_t atxp1_storegpio2(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct atxp1_data *data;\r\nstruct i2c_client *client;\r\nunsigned int value;\r\nclient = to_i2c_client(dev);\r\ndata = atxp1_update_device(dev);\r\nvalue = simple_strtoul(buf, NULL, 16) & 0xff;\r\nif (value != data->reg.gpio2) {\r\ndev_info(dev, "Writing 0x%x to GPIO1.\n", value);\r\ni2c_smbus_write_byte_data(client, ATXP1_GPIO2, value);\r\ndata->valid = 0;\r\n}\r\nreturn count;\r\n}\r\nstatic int atxp1_detect(struct i2c_client *new_client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nu8 temp;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nif (!((i2c_smbus_read_byte_data(new_client, 0x3e) == 0) &&\r\n(i2c_smbus_read_byte_data(new_client, 0x3f) == 0) &&\r\n(i2c_smbus_read_byte_data(new_client, 0xfe) == 0) &&\r\n(i2c_smbus_read_byte_data(new_client, 0xff) == 0)))\r\nreturn -ENODEV;\r\ntemp = i2c_smbus_read_byte_data(new_client, 0x00);\r\nif (!((i2c_smbus_read_byte_data(new_client, 0x10) == temp) &&\r\n(i2c_smbus_read_byte_data(new_client, 0x11) == temp)))\r\nreturn -ENODEV;\r\ntemp = vid_which_vrm();\r\nif ((temp != 90) && (temp != 91)) {\r\ndev_err(&adapter->dev, "atxp1: Not supporting VRM %d.%d\n",\r\ntemp / 10, temp % 10);\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, "atxp1", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int atxp1_probe(struct i2c_client *new_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct atxp1_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(struct atxp1_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata->vrm = vid_which_vrm();\r\ni2c_set_clientdata(new_client, data);\r\ndata->valid = 0;\r\nmutex_init(&data->update_lock);\r\nif ((err = sysfs_create_group(&new_client->dev.kobj, &atxp1_group)))\r\ngoto exit_free;\r\ndata->hwmon_dev = hwmon_device_register(&new_client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\ndev_info(&new_client->dev, "Using VRM: %d.%d\n",\r\ndata->vrm / 10, data->vrm % 10);\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&new_client->dev.kobj, &atxp1_group);\r\nexit_free:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int atxp1_remove(struct i2c_client *client)\r\n{\r\nstruct atxp1_data * data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &atxp1_group);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init atxp1_init(void)\r\n{\r\nreturn i2c_add_driver(&atxp1_driver);\r\n}\r\nstatic void __exit atxp1_exit(void)\r\n{\r\ni2c_del_driver(&atxp1_driver);\r\n}
