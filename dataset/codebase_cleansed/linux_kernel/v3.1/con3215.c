static inline struct raw3215_req *raw3215_alloc_req(void)\r\n{\r\nstruct raw3215_req *req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&raw3215_freelist_lock, flags);\r\nreq = raw3215_freelist;\r\nraw3215_freelist = req->next;\r\nspin_unlock_irqrestore(&raw3215_freelist_lock, flags);\r\nreturn req;\r\n}\r\nstatic inline void raw3215_free_req(struct raw3215_req *req)\r\n{\r\nunsigned long flags;\r\nif (req->type == RAW3215_FREE)\r\nreturn;\r\nreq->type = RAW3215_FREE;\r\nspin_lock_irqsave(&raw3215_freelist_lock, flags);\r\nreq->next = raw3215_freelist;\r\nraw3215_freelist = req;\r\nspin_unlock_irqrestore(&raw3215_freelist_lock, flags);\r\n}\r\nstatic void raw3215_mk_read_req(struct raw3215_info *raw)\r\n{\r\nstruct raw3215_req *req;\r\nstruct ccw1 *ccw;\r\nreq = raw->queued_read;\r\nif (req == NULL) {\r\nreq = raw3215_alloc_req();\r\nreq->type = RAW3215_READ;\r\nreq->info = raw;\r\nraw->queued_read = req;\r\n}\r\nccw = req->ccws;\r\nccw->cmd_code = 0x0A;\r\nccw->flags = 0x20;\r\nccw->count = 160;\r\nccw->cda = (__u32) __pa(raw->inbuf);\r\n}\r\nstatic void raw3215_mk_write_req(struct raw3215_info *raw)\r\n{\r\nstruct raw3215_req *req;\r\nstruct ccw1 *ccw;\r\nint len, count, ix, lines;\r\nif (raw->count <= raw->written)\r\nreturn;\r\nreq = raw->queued_write;\r\nif (req == NULL) {\r\nreq = raw3215_alloc_req();\r\nreq->type = RAW3215_WRITE;\r\nreq->info = raw;\r\nraw->queued_write = req;\r\n} else {\r\nraw->written -= req->len;\r\n}\r\nccw = req->ccws;\r\nreq->start = (raw->head - raw->count + raw->written) &\r\n(RAW3215_BUFFER_SIZE - 1);\r\nlines = 0;\r\nix = req->start;\r\nwhile (lines < RAW3215_MAX_NEWLINE && ix != raw->head) {\r\nif (raw->buffer[ix] == 0x15)\r\nlines++;\r\nix = (ix + 1) & (RAW3215_BUFFER_SIZE - 1);\r\n}\r\nlen = ((ix - 1 - req->start) & (RAW3215_BUFFER_SIZE - 1)) + 1;\r\nif (len > RAW3215_MAX_BYTES)\r\nlen = RAW3215_MAX_BYTES;\r\nreq->len = len;\r\nraw->written += len;\r\nreq->delayable = (ix == raw->head) && (len < RAW3215_MIN_WRITE);\r\nix = req->start;\r\nwhile (len > 0) {\r\nif (ccw > req->ccws)\r\nccw[-1].flags |= 0x40;\r\nccw->cmd_code = 0x01;\r\nccw->flags = 0x20;\r\nccw->cda =\r\n(__u32) __pa(raw->buffer + ix);\r\ncount = len;\r\nif (ix + count > RAW3215_BUFFER_SIZE)\r\ncount = RAW3215_BUFFER_SIZE - ix;\r\nccw->count = count;\r\nlen -= count;\r\nix = (ix + count) & (RAW3215_BUFFER_SIZE - 1);\r\nccw++;\r\n}\r\nif (ccw > req->ccws)\r\nccw[-1].flags |= 0x40;\r\nccw->cmd_code = 0x03;\r\nccw->flags = 0;\r\nccw->cda = 0;\r\nccw->count = 1;\r\n}\r\nstatic void raw3215_start_io(struct raw3215_info *raw)\r\n{\r\nstruct raw3215_req *req;\r\nint res;\r\nreq = raw->queued_read;\r\nif (req != NULL &&\r\n!(raw->flags & (RAW3215_WORKING | RAW3215_THROTTLED))) {\r\nraw->queued_read = NULL;\r\nres = ccw_device_start(raw->cdev, req->ccws,\r\n(unsigned long) req, 0, 0);\r\nif (res != 0) {\r\nraw->queued_read = req;\r\n} else {\r\nraw->flags |= RAW3215_WORKING;\r\n}\r\n}\r\nreq = raw->queued_write;\r\nif (req != NULL &&\r\n!(raw->flags & (RAW3215_WORKING | RAW3215_STOPPED))) {\r\nraw->queued_write = NULL;\r\nres = ccw_device_start(raw->cdev, req->ccws,\r\n(unsigned long) req, 0, 0);\r\nif (res != 0) {\r\nraw->queued_write = req;\r\n} else {\r\nraw->flags |= RAW3215_WORKING;\r\n}\r\n}\r\n}\r\nstatic void raw3215_timeout(unsigned long __data)\r\n{\r\nstruct raw3215_info *raw = (struct raw3215_info *) __data;\r\nunsigned long flags;\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nif (raw->flags & RAW3215_TIMER_RUNS) {\r\ndel_timer(&raw->timer);\r\nraw->flags &= ~RAW3215_TIMER_RUNS;\r\nif (!(raw->flags & RAW3215_FROZEN)) {\r\nraw3215_mk_write_req(raw);\r\nraw3215_start_io(raw);\r\n}\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\n}\r\nstatic inline void raw3215_try_io(struct raw3215_info *raw)\r\n{\r\nif (!(raw->flags & RAW3215_ACTIVE) || (raw->flags & RAW3215_FROZEN))\r\nreturn;\r\nif (raw->queued_read != NULL)\r\nraw3215_start_io(raw);\r\nelse if (raw->queued_write != NULL) {\r\nif ((raw->queued_write->delayable == 0) ||\r\n(raw->flags & RAW3215_FLUSHING)) {\r\nraw3215_start_io(raw);\r\nif (raw->flags & RAW3215_TIMER_RUNS) {\r\ndel_timer(&raw->timer);\r\nraw->flags &= ~RAW3215_TIMER_RUNS;\r\n}\r\n} else if (!(raw->flags & RAW3215_TIMER_RUNS)) {\r\ninit_timer(&raw->timer);\r\nraw->timer.expires = RAW3215_TIMEOUT + jiffies;\r\nraw->timer.data = (unsigned long) raw;\r\nraw->timer.function = raw3215_timeout;\r\nadd_timer(&raw->timer);\r\nraw->flags |= RAW3215_TIMER_RUNS;\r\n}\r\n}\r\n}\r\nstatic void raw3215_next_io(struct raw3215_info *raw)\r\n{\r\nstruct tty_struct *tty;\r\nraw3215_mk_write_req(raw);\r\nraw3215_try_io(raw);\r\ntty = raw->tty;\r\nif (tty != NULL &&\r\nRAW3215_BUFFER_SIZE - raw->count >= RAW3215_MIN_SPACE) {\r\ntty_wakeup(tty);\r\n}\r\n}\r\nstatic void raw3215_irq(struct ccw_device *cdev, unsigned long intparm,\r\nstruct irb *irb)\r\n{\r\nstruct raw3215_info *raw;\r\nstruct raw3215_req *req;\r\nstruct tty_struct *tty;\r\nint cstat, dstat;\r\nint count;\r\nkstat_cpu(smp_processor_id()).irqs[IOINT_C15]++;\r\nraw = dev_get_drvdata(&cdev->dev);\r\nreq = (struct raw3215_req *) intparm;\r\ncstat = irb->scsw.cmd.cstat;\r\ndstat = irb->scsw.cmd.dstat;\r\nif (cstat != 0)\r\nraw3215_next_io(raw);\r\nif (dstat & 0x01) {\r\ndstat &= ~0x01;\r\n}\r\nswitch (dstat) {\r\ncase 0x80:\r\nif (cstat != 0)\r\nbreak;\r\nraw3215_mk_read_req(raw);\r\nraw3215_next_io(raw);\r\nbreak;\r\ncase 0x08:\r\ncase 0x0C:\r\nif ((raw = req->info) == NULL)\r\nreturn;\r\nif (req->type == RAW3215_READ) {\r\nreq->residual = irb->scsw.cmd.count;\r\n}\r\nif (dstat == 0x08)\r\nbreak;\r\ncase 0x04:\r\nif ((raw = req->info) == NULL)\r\nreturn;\r\nif (req->type == RAW3215_READ && raw->tty != NULL) {\r\nunsigned int cchar;\r\ntty = raw->tty;\r\ncount = 160 - req->residual;\r\nEBCASC(raw->inbuf, count);\r\ncchar = ctrlchar_handle(raw->inbuf, count, tty);\r\nswitch (cchar & CTRLCHAR_MASK) {\r\ncase CTRLCHAR_SYSRQ:\r\nbreak;\r\ncase CTRLCHAR_CTRL:\r\ntty_insert_flip_char(tty, cchar, TTY_NORMAL);\r\ntty_flip_buffer_push(raw->tty);\r\nbreak;\r\ncase CTRLCHAR_NONE:\r\nif (count < 2 ||\r\n(strncmp(raw->inbuf+count-2, "\252n", 2) &&\r\nstrncmp(raw->inbuf+count-2, "^n", 2)) ) {\r\nraw->inbuf[count] = '\n';\r\ncount++;\r\n} else\r\ncount -= 2;\r\ntty_insert_flip_string(tty, raw->inbuf, count);\r\ntty_flip_buffer_push(raw->tty);\r\nbreak;\r\n}\r\n} else if (req->type == RAW3215_WRITE) {\r\nraw->count -= req->len;\r\nraw->written -= req->len;\r\n}\r\nraw->flags &= ~RAW3215_WORKING;\r\nraw3215_free_req(req);\r\nif (waitqueue_active(&raw->empty_wait) &&\r\nraw->queued_write == NULL &&\r\nraw->queued_read == NULL) {\r\nwake_up_interruptible(&raw->empty_wait);\r\n}\r\nraw3215_next_io(raw);\r\nbreak;\r\ndefault:\r\nif (req != NULL && req->type != RAW3215_FREE) {\r\nif (req->type == RAW3215_WRITE) {\r\nraw->count -= req->len;\r\nraw->written -= req->len;\r\n}\r\nraw->flags &= ~RAW3215_WORKING;\r\nraw3215_free_req(req);\r\n}\r\nraw3215_next_io(raw);\r\n}\r\nreturn;\r\n}\r\nstatic void raw3215_drop_line(struct raw3215_info *raw)\r\n{\r\nint ix;\r\nchar ch;\r\nBUG_ON(raw->written != 0);\r\nix = (raw->head - raw->count) & (RAW3215_BUFFER_SIZE - 1);\r\nwhile (raw->count > 0) {\r\nch = raw->buffer[ix];\r\nix = (ix + 1) & (RAW3215_BUFFER_SIZE - 1);\r\nraw->count--;\r\nif (ch == 0x15)\r\nbreak;\r\n}\r\nraw->head = ix;\r\n}\r\nstatic void raw3215_make_room(struct raw3215_info *raw, unsigned int length)\r\n{\r\nwhile (RAW3215_BUFFER_SIZE - raw->count < length) {\r\nif (raw->flags & RAW3215_FROZEN) {\r\nraw3215_drop_line(raw);\r\ncontinue;\r\n}\r\nraw->flags |= RAW3215_FLUSHING;\r\nraw3215_mk_write_req(raw);\r\nraw3215_try_io(raw);\r\nraw->flags &= ~RAW3215_FLUSHING;\r\n#ifdef CONFIG_TN3215_CONSOLE\r\nwait_cons_dev();\r\n#endif\r\nif (RAW3215_BUFFER_SIZE - raw->count >= length)\r\nbreak;\r\nspin_unlock(get_ccwdev_lock(raw->cdev));\r\nudelay(100);\r\nspin_lock(get_ccwdev_lock(raw->cdev));\r\n}\r\n}\r\nstatic void raw3215_write(struct raw3215_info *raw, const char *str,\r\nunsigned int length)\r\n{\r\nunsigned long flags;\r\nint c, count;\r\nwhile (length > 0) {\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\ncount = (length > RAW3215_BUFFER_SIZE) ?\r\nRAW3215_BUFFER_SIZE : length;\r\nlength -= count;\r\nraw3215_make_room(raw, count);\r\nwhile (1) {\r\nc = min_t(int, count,\r\nmin(RAW3215_BUFFER_SIZE - raw->count,\r\nRAW3215_BUFFER_SIZE - raw->head));\r\nif (c <= 0)\r\nbreak;\r\nmemcpy(raw->buffer + raw->head, str, c);\r\nASCEBC(raw->buffer + raw->head, c);\r\nraw->head = (raw->head + c) & (RAW3215_BUFFER_SIZE - 1);\r\nraw->count += c;\r\nraw->line_pos += c;\r\nstr += c;\r\ncount -= c;\r\n}\r\nif (!(raw->flags & RAW3215_WORKING)) {\r\nraw3215_mk_write_req(raw);\r\nraw3215_try_io(raw);\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\n}\r\n}\r\nstatic void raw3215_putchar(struct raw3215_info *raw, unsigned char ch)\r\n{\r\nunsigned long flags;\r\nunsigned int length, i;\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nif (ch == '\t') {\r\nlength = TAB_STOP_SIZE - (raw->line_pos%TAB_STOP_SIZE);\r\nraw->line_pos += length;\r\nch = ' ';\r\n} else if (ch == '\n') {\r\nlength = 1;\r\nraw->line_pos = 0;\r\n} else {\r\nlength = 1;\r\nraw->line_pos++;\r\n}\r\nraw3215_make_room(raw, length);\r\nfor (i = 0; i < length; i++) {\r\nraw->buffer[raw->head] = (char) _ascebc[(int) ch];\r\nraw->head = (raw->head + 1) & (RAW3215_BUFFER_SIZE - 1);\r\nraw->count++;\r\n}\r\nif (!(raw->flags & RAW3215_WORKING)) {\r\nraw3215_mk_write_req(raw);\r\nraw3215_try_io(raw);\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\n}\r\nstatic void raw3215_flush_buffer(struct raw3215_info *raw)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nif (raw->count > 0) {\r\nraw->flags |= RAW3215_FLUSHING;\r\nraw3215_try_io(raw);\r\nraw->flags &= ~RAW3215_FLUSHING;\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\n}\r\nstatic int raw3215_startup(struct raw3215_info *raw)\r\n{\r\nunsigned long flags;\r\nif (raw->flags & RAW3215_ACTIVE)\r\nreturn 0;\r\nraw->line_pos = 0;\r\nraw->flags |= RAW3215_ACTIVE;\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nraw3215_try_io(raw);\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\nreturn 0;\r\n}\r\nstatic void raw3215_shutdown(struct raw3215_info *raw)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long flags;\r\nif (!(raw->flags & RAW3215_ACTIVE) || (raw->flags & RAW3215_FIXED))\r\nreturn;\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nif ((raw->flags & RAW3215_WORKING) ||\r\nraw->queued_write != NULL ||\r\nraw->queued_read != NULL) {\r\nraw->flags |= RAW3215_CLOSING;\r\nadd_wait_queue(&raw->empty_wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\nschedule();\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nremove_wait_queue(&raw->empty_wait, &wait);\r\nset_current_state(TASK_RUNNING);\r\nraw->flags &= ~(RAW3215_ACTIVE | RAW3215_CLOSING);\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\n}\r\nstatic int raw3215_probe (struct ccw_device *cdev)\r\n{\r\nstruct raw3215_info *raw;\r\nint line;\r\nif (raw3215[0] && (raw3215[0] == dev_get_drvdata(&cdev->dev)))\r\nreturn 0;\r\nraw = kmalloc(sizeof(struct raw3215_info) +\r\nRAW3215_INBUF_SIZE, GFP_KERNEL|GFP_DMA);\r\nif (raw == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&raw3215_device_lock);\r\nfor (line = 0; line < NR_3215; line++) {\r\nif (!raw3215[line]) {\r\nraw3215[line] = raw;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&raw3215_device_lock);\r\nif (line == NR_3215) {\r\nkfree(raw);\r\nreturn -ENODEV;\r\n}\r\nraw->cdev = cdev;\r\nraw->inbuf = (char *) raw + sizeof(struct raw3215_info);\r\nmemset(raw, 0, sizeof(struct raw3215_info));\r\nraw->buffer = kmalloc(RAW3215_BUFFER_SIZE,\r\nGFP_KERNEL|GFP_DMA);\r\nif (raw->buffer == NULL) {\r\nspin_lock(&raw3215_device_lock);\r\nraw3215[line] = NULL;\r\nspin_unlock(&raw3215_device_lock);\r\nkfree(raw);\r\nreturn -ENOMEM;\r\n}\r\ninit_waitqueue_head(&raw->empty_wait);\r\ndev_set_drvdata(&cdev->dev, raw);\r\ncdev->handler = raw3215_irq;\r\nreturn 0;\r\n}\r\nstatic void raw3215_remove (struct ccw_device *cdev)\r\n{\r\nstruct raw3215_info *raw;\r\nccw_device_set_offline(cdev);\r\nraw = dev_get_drvdata(&cdev->dev);\r\nif (raw) {\r\ndev_set_drvdata(&cdev->dev, NULL);\r\nkfree(raw->buffer);\r\nkfree(raw);\r\n}\r\n}\r\nstatic int raw3215_set_online (struct ccw_device *cdev)\r\n{\r\nstruct raw3215_info *raw;\r\nraw = dev_get_drvdata(&cdev->dev);\r\nif (!raw)\r\nreturn -ENODEV;\r\nreturn raw3215_startup(raw);\r\n}\r\nstatic int raw3215_set_offline (struct ccw_device *cdev)\r\n{\r\nstruct raw3215_info *raw;\r\nraw = dev_get_drvdata(&cdev->dev);\r\nif (!raw)\r\nreturn -ENODEV;\r\nraw3215_shutdown(raw);\r\nreturn 0;\r\n}\r\nstatic int raw3215_pm_stop(struct ccw_device *cdev)\r\n{\r\nstruct raw3215_info *raw;\r\nunsigned long flags;\r\nraw = dev_get_drvdata(&cdev->dev);\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nraw3215_make_room(raw, RAW3215_BUFFER_SIZE);\r\nraw->flags |= RAW3215_FROZEN;\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\nreturn 0;\r\n}\r\nstatic int raw3215_pm_start(struct ccw_device *cdev)\r\n{\r\nstruct raw3215_info *raw;\r\nunsigned long flags;\r\nraw = dev_get_drvdata(&cdev->dev);\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nraw->flags &= ~RAW3215_FROZEN;\r\nraw->flags |= RAW3215_FLUSHING;\r\nraw3215_try_io(raw);\r\nraw->flags &= ~RAW3215_FLUSHING;\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\nreturn 0;\r\n}\r\nstatic void con3215_write(struct console *co, const char *str,\r\nunsigned int count)\r\n{\r\nstruct raw3215_info *raw;\r\nint i;\r\nif (count <= 0)\r\nreturn;\r\nraw = raw3215[0];\r\nwhile (count > 0) {\r\nfor (i = 0; i < count; i++)\r\nif (str[i] == '\t' || str[i] == '\n')\r\nbreak;\r\nraw3215_write(raw, str, i);\r\ncount -= i;\r\nstr += i;\r\nif (count > 0) {\r\nraw3215_putchar(raw, *str);\r\ncount--;\r\nstr++;\r\n}\r\n}\r\n}\r\nstatic struct tty_driver *con3215_device(struct console *c, int *index)\r\n{\r\n*index = c->index;\r\nreturn tty3215_driver;\r\n}\r\nstatic void con3215_flush(void)\r\n{\r\nstruct raw3215_info *raw;\r\nunsigned long flags;\r\nraw = raw3215[0];\r\nif (raw->flags & RAW3215_FROZEN)\r\nif (ccw_device_force_console())\r\nreturn;\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nraw3215_make_room(raw, RAW3215_BUFFER_SIZE);\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\n}\r\nstatic int con3215_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\ncon3215_flush();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init con3215_init(void)\r\n{\r\nstruct ccw_device *cdev;\r\nstruct raw3215_info *raw;\r\nstruct raw3215_req *req;\r\nint i;\r\nif (!CONSOLE_IS_3215)\r\nreturn -ENODEV;\r\nif (MACHINE_IS_VM) {\r\ncpcmd("TERM CONMODE 3215", NULL, 0, NULL);\r\ncpcmd("TERM AUTOCR OFF", NULL, 0, NULL);\r\n}\r\nraw3215_freelist = NULL;\r\nspin_lock_init(&raw3215_freelist_lock);\r\nfor (i = 0; i < NR_3215_REQ; i++) {\r\nreq = kzalloc(sizeof(struct raw3215_req), GFP_KERNEL | GFP_DMA);\r\nreq->next = raw3215_freelist;\r\nraw3215_freelist = req;\r\n}\r\ncdev = ccw_device_probe_console();\r\nif (IS_ERR(cdev))\r\nreturn -ENODEV;\r\nraw3215[0] = raw = (struct raw3215_info *)\r\nkzalloc(sizeof(struct raw3215_info), GFP_KERNEL | GFP_DMA);\r\nraw->buffer = kzalloc(RAW3215_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);\r\nraw->inbuf = kzalloc(RAW3215_INBUF_SIZE, GFP_KERNEL | GFP_DMA);\r\nraw->cdev = cdev;\r\ndev_set_drvdata(&cdev->dev, raw);\r\ncdev->handler = raw3215_irq;\r\nraw->flags |= RAW3215_FIXED;\r\ninit_waitqueue_head(&raw->empty_wait);\r\nif (raw3215_startup(raw) != 0) {\r\nkfree(raw->inbuf);\r\nkfree(raw->buffer);\r\nkfree(raw);\r\nraw3215[0] = NULL;\r\nreturn -ENODEV;\r\n}\r\natomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\r\nregister_reboot_notifier(&on_reboot_nb);\r\nregister_console(&con3215);\r\nreturn 0;\r\n}\r\nstatic int tty3215_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct raw3215_info *raw;\r\nint retval, line;\r\nline = tty->index;\r\nif ((line < 0) || (line >= NR_3215))\r\nreturn -ENODEV;\r\nraw = raw3215[line];\r\nif (raw == NULL)\r\nreturn -ENODEV;\r\ntty->driver_data = raw;\r\nraw->tty = tty;\r\ntty->low_latency = 0;\r\nretval = raw3215_startup(raw);\r\nif (retval)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstatic void tty3215_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct raw3215_info *raw;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nif (raw == NULL || tty->count > 1)\r\nreturn;\r\ntty->closing = 1;\r\nraw3215_shutdown(raw);\r\ntty->closing = 0;\r\nraw->tty = NULL;\r\n}\r\nstatic int tty3215_write_room(struct tty_struct *tty)\r\n{\r\nstruct raw3215_info *raw;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nif ((RAW3215_BUFFER_SIZE - raw->count - TAB_STOP_SIZE) >= 0)\r\nreturn RAW3215_BUFFER_SIZE - raw->count - TAB_STOP_SIZE;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int tty3215_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct raw3215_info *raw;\r\nif (!tty)\r\nreturn 0;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nraw3215_write(raw, buf, count);\r\nreturn count;\r\n}\r\nstatic int tty3215_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct raw3215_info *raw;\r\nif (!tty)\r\nreturn 0;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nraw3215_putchar(raw, ch);\r\nreturn 1;\r\n}\r\nstatic void tty3215_flush_chars(struct tty_struct *tty)\r\n{\r\n}\r\nstatic int tty3215_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct raw3215_info *raw;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nreturn raw->count;\r\n}\r\nstatic void tty3215_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct raw3215_info *raw;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nraw3215_flush_buffer(raw);\r\ntty_wakeup(tty);\r\n}\r\nstatic void tty3215_throttle(struct tty_struct * tty)\r\n{\r\nstruct raw3215_info *raw;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nraw->flags |= RAW3215_THROTTLED;\r\n}\r\nstatic void tty3215_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct raw3215_info *raw;\r\nunsigned long flags;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nif (raw->flags & RAW3215_THROTTLED) {\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nraw->flags &= ~RAW3215_THROTTLED;\r\nraw3215_try_io(raw);\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\n}\r\n}\r\nstatic void tty3215_stop(struct tty_struct *tty)\r\n{\r\nstruct raw3215_info *raw;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nraw->flags |= RAW3215_STOPPED;\r\n}\r\nstatic void tty3215_start(struct tty_struct *tty)\r\n{\r\nstruct raw3215_info *raw;\r\nunsigned long flags;\r\nraw = (struct raw3215_info *) tty->driver_data;\r\nif (raw->flags & RAW3215_STOPPED) {\r\nspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\r\nraw->flags &= ~RAW3215_STOPPED;\r\nraw3215_try_io(raw);\r\nspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\r\n}\r\n}\r\nstatic int __init tty3215_init(void)\r\n{\r\nstruct tty_driver *driver;\r\nint ret;\r\nif (!CONSOLE_IS_3215)\r\nreturn 0;\r\ndriver = alloc_tty_driver(NR_3215);\r\nif (!driver)\r\nreturn -ENOMEM;\r\nret = ccw_driver_register(&raw3215_ccw_driver);\r\nif (ret) {\r\nput_tty_driver(driver);\r\nreturn ret;\r\n}\r\ndriver->owner = THIS_MODULE;\r\ndriver->driver_name = "tty3215";\r\ndriver->name = "ttyS";\r\ndriver->major = TTY_MAJOR;\r\ndriver->minor_start = 64;\r\ndriver->type = TTY_DRIVER_TYPE_SYSTEM;\r\ndriver->subtype = SYSTEM_TYPE_TTY;\r\ndriver->init_termios = tty_std_termios;\r\ndriver->init_termios.c_iflag = IGNBRK | IGNPAR;\r\ndriver->init_termios.c_oflag = ONLCR | XTABS;\r\ndriver->init_termios.c_lflag = ISIG;\r\ndriver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(driver, &tty3215_ops);\r\nret = tty_register_driver(driver);\r\nif (ret) {\r\nput_tty_driver(driver);\r\nreturn ret;\r\n}\r\ntty3215_driver = driver;\r\nreturn 0;\r\n}\r\nstatic void __exit tty3215_exit(void)\r\n{\r\ntty_unregister_driver(tty3215_driver);\r\nput_tty_driver(tty3215_driver);\r\nccw_driver_unregister(&raw3215_ccw_driver);\r\n}
