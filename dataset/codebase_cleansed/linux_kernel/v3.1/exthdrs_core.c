int ipv6_ext_hdr(u8 nexthdr)\r\n{\r\nreturn (nexthdr == NEXTHDR_HOP) ||\r\n(nexthdr == NEXTHDR_ROUTING) ||\r\n(nexthdr == NEXTHDR_FRAGMENT) ||\r\n(nexthdr == NEXTHDR_AUTH) ||\r\n(nexthdr == NEXTHDR_NONE) ||\r\n(nexthdr == NEXTHDR_DEST);\r\n}\r\nint ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp)\r\n{\r\nu8 nexthdr = *nexthdrp;\r\nwhile (ipv6_ext_hdr(nexthdr)) {\r\nstruct ipv6_opt_hdr _hdr, *hp;\r\nint hdrlen;\r\nif (nexthdr == NEXTHDR_NONE)\r\nreturn -1;\r\nhp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn -1;\r\nif (nexthdr == NEXTHDR_FRAGMENT) {\r\n__be16 _frag_off, *fp;\r\nfp = skb_header_pointer(skb,\r\nstart+offsetof(struct frag_hdr,\r\nfrag_off),\r\nsizeof(_frag_off),\r\n&_frag_off);\r\nif (fp == NULL)\r\nreturn -1;\r\nif (ntohs(*fp) & ~0x7)\r\nbreak;\r\nhdrlen = 8;\r\n} else if (nexthdr == NEXTHDR_AUTH)\r\nhdrlen = (hp->hdrlen+2)<<2;\r\nelse\r\nhdrlen = ipv6_optlen(hp);\r\nnexthdr = hp->nexthdr;\r\nstart += hdrlen;\r\n}\r\n*nexthdrp = nexthdr;\r\nreturn start;\r\n}
