static inline struct adv7343_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7343_state, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct adv7343_state, hdl)->sd;\r\n}\r\nstatic inline int adv7343_write(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int adv7343_setstd(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct adv7343_state *state = to_state(sd);\r\nstruct adv7343_std_info *std_info;\r\nint output_idx, num_std;\r\nchar *fsc_ptr;\r\nu8 reg, val;\r\nint err = 0;\r\nint i = 0;\r\noutput_idx = state->output;\r\nstd_info = (struct adv7343_std_info *)stdinfo;\r\nnum_std = ARRAY_SIZE(stdinfo);\r\nfor (i = 0; i < num_std; i++) {\r\nif (std_info[i].stdid & std)\r\nbreak;\r\n}\r\nif (i == num_std) {\r\nv4l2_dbg(1, debug, sd,\r\n"Invalid std or std is not supported: %llx\n",\r\n(unsigned long long)std);\r\nreturn -EINVAL;\r\n}\r\nval = state->reg80 & (~(SD_STD_MASK));\r\nval |= std_info[i].standard_val3;\r\nerr = adv7343_write(sd, ADV7343_SD_MODE_REG1, val);\r\nif (err < 0)\r\ngoto setstd_exit;\r\nstate->reg80 = val;\r\nval = state->reg01 & (~((u8) INPUT_MODE_MASK));\r\nval |= SD_INPUT_MODE;\r\nerr = adv7343_write(sd, ADV7343_MODE_SELECT_REG, val);\r\nif (err < 0)\r\ngoto setstd_exit;\r\nstate->reg01 = val;\r\nfsc_ptr = (unsigned char *)&std_info[i].fsc_val;\r\nreg = ADV7343_FSC_REG0;\r\nfor (i = 0; i < 4; i++, reg++, fsc_ptr++) {\r\nerr = adv7343_write(sd, reg, *fsc_ptr);\r\nif (err < 0)\r\ngoto setstd_exit;\r\n}\r\nval = state->reg80;\r\nif (std & (V4L2_STD_NTSC | V4L2_STD_NTSC_443))\r\nval &= 0x03;\r\nelse if (std & ~V4L2_STD_SECAM)\r\nval |= 0x04;\r\nerr = adv7343_write(sd, ADV7343_SD_MODE_REG1, val);\r\nif (err < 0)\r\ngoto setstd_exit;\r\nstate->reg80 = val;\r\nsetstd_exit:\r\nif (err != 0)\r\nv4l2_err(sd, "Error setting std, write failed\n");\r\nreturn err;\r\n}\r\nstatic int adv7343_setoutput(struct v4l2_subdev *sd, u32 output_type)\r\n{\r\nstruct adv7343_state *state = to_state(sd);\r\nunsigned char val;\r\nint err = 0;\r\nif (output_type > ADV7343_SVIDEO_ID) {\r\nv4l2_dbg(1, debug, sd,\r\n"Invalid output type or output type not supported:%d\n",\r\noutput_type);\r\nreturn -EINVAL;\r\n}\r\nval = state->reg00 & 0x03;\r\nif (output_type == ADV7343_COMPOSITE_ID)\r\nval |= ADV7343_COMPOSITE_POWER_VALUE;\r\nelse if (output_type == ADV7343_COMPONENT_ID)\r\nval |= ADV7343_COMPONENT_POWER_VALUE;\r\nelse\r\nval |= ADV7343_SVIDEO_POWER_VALUE;\r\nerr = adv7343_write(sd, ADV7343_POWER_MODE_REG, val);\r\nif (err < 0)\r\ngoto setoutput_exit;\r\nstate->reg00 = val;\r\nval = state->reg02 | YUV_OUTPUT_SELECT;\r\nerr = adv7343_write(sd, ADV7343_MODE_REG0, val);\r\nif (err < 0)\r\ngoto setoutput_exit;\r\nstate->reg02 = val;\r\nval = state->reg82 & (SD_DAC_1_DI & SD_DAC_2_DI);\r\nerr = adv7343_write(sd, ADV7343_SD_MODE_REG2, val);\r\nif (err < 0)\r\ngoto setoutput_exit;\r\nstate->reg82 = val;\r\nval = state->reg35 & (HD_RGB_INPUT_DI & HD_DAC_SWAP_DI);\r\nerr = adv7343_write(sd, ADV7343_HD_MODE_REG6, val);\r\nif (err < 0)\r\ngoto setoutput_exit;\r\nstate->reg35 = val;\r\nsetoutput_exit:\r\nif (err != 0)\r\nv4l2_err(sd, "Error setting output, write failed\n");\r\nreturn err;\r\n}\r\nstatic int adv7343_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7343_state *state = to_state(sd);\r\nv4l2_info(sd, "Standard: %llx\n", (unsigned long long)state->std);\r\nv4l2_info(sd, "Output: %s\n", (state->output == 0) ? "Composite" :\r\n((state->output == 1) ? "Component" : "S-Video"));\r\nreturn 0;\r\n}\r\nstatic int adv7343_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn adv7343_write(sd, ADV7343_SD_BRIGHTNESS_WSS,\r\nctrl->val);\r\ncase V4L2_CID_HUE:\r\nreturn adv7343_write(sd, ADV7343_SD_HUE_REG, ctrl->val);\r\ncase V4L2_CID_GAIN:\r\nreturn adv7343_write(sd, ADV7343_DAC2_OUTPUT_LEVEL, ctrl->val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int adv7343_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_ADV7343, 0);\r\n}\r\nstatic int adv7343_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct adv7343_state *state = to_state(sd);\r\nint err = 0;\r\nif (state->std == std)\r\nreturn 0;\r\nerr = adv7343_setstd(sd, std);\r\nif (!err)\r\nstate->std = std;\r\nreturn err;\r\n}\r\nstatic int adv7343_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct adv7343_state *state = to_state(sd);\r\nint err = 0;\r\nif (state->output == output)\r\nreturn 0;\r\nerr = adv7343_setoutput(sd, output);\r\nif (!err)\r\nstate->output = output;\r\nreturn err;\r\n}\r\nstatic int adv7343_initialize(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7343_state *state = to_state(sd);\r\nint err = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(adv7343_init_reg_val); i += 2) {\r\nerr = adv7343_write(sd, adv7343_init_reg_val[i],\r\nadv7343_init_reg_val[i+1]);\r\nif (err) {\r\nv4l2_err(sd, "Error initializing\n");\r\nreturn err;\r\n}\r\n}\r\nerr = adv7343_setoutput(sd, state->output);\r\nif (err < 0) {\r\nv4l2_err(sd, "Error setting output during init\n");\r\nreturn -EINVAL;\r\n}\r\nerr = adv7343_setstd(sd, state->std);\r\nif (err < 0) {\r\nv4l2_err(sd, "Error setting std during init\n");\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int adv7343_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adv7343_state *state;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nstate = kzalloc(sizeof(struct adv7343_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nstate->reg00 = 0x80;\r\nstate->reg01 = 0x00;\r\nstate->reg02 = 0x20;\r\nstate->reg35 = 0x00;\r\nstate->reg80 = ADV7343_SD_MODE_REG1_DEFAULT;\r\nstate->reg82 = ADV7343_SD_MODE_REG2_DEFAULT;\r\nstate->output = ADV7343_COMPOSITE_ID;\r\nstate->std = V4L2_STD_NTSC;\r\nv4l2_i2c_subdev_init(&state->sd, client, &adv7343_ops);\r\nv4l2_ctrl_handler_init(&state->hdl, 2);\r\nv4l2_ctrl_new_std(&state->hdl, &adv7343_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, ADV7343_BRIGHTNESS_MIN,\r\nADV7343_BRIGHTNESS_MAX, 1,\r\nADV7343_BRIGHTNESS_DEF);\r\nv4l2_ctrl_new_std(&state->hdl, &adv7343_ctrl_ops,\r\nV4L2_CID_HUE, ADV7343_HUE_MIN,\r\nADV7343_HUE_MAX, 1,\r\nADV7343_HUE_DEF);\r\nv4l2_ctrl_new_std(&state->hdl, &adv7343_ctrl_ops,\r\nV4L2_CID_GAIN, ADV7343_GAIN_MIN,\r\nADV7343_GAIN_MAX, 1,\r\nADV7343_GAIN_DEF);\r\nstate->sd.ctrl_handler = &state->hdl;\r\nif (state->hdl.error) {\r\nint err = state->hdl.error;\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(state);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&state->hdl);\r\nerr = adv7343_initialize(&state->sd);\r\nif (err) {\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(state);\r\n}\r\nreturn err;\r\n}\r\nstatic int adv7343_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7343_state *state = to_state(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic __init int init_adv7343(void)\r\n{\r\nreturn i2c_add_driver(&adv7343_driver);\r\n}\r\nstatic __exit void exit_adv7343(void)\r\n{\r\ni2c_del_driver(&adv7343_driver);\r\n}
