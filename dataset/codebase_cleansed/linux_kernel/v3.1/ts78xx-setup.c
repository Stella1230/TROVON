void __init ts78xx_map_io(void)\r\n{\r\norion5x_map_io();\r\niotable_init(ts78xx_io_desc, ARRAY_SIZE(ts78xx_io_desc));\r\n}\r\nstatic unsigned char ts78xx_ts_rtc_readbyte(unsigned long addr)\r\n{\r\nwriteb(addr, TS_RTC_CTRL);\r\nreturn readb(TS_RTC_DATA);\r\n}\r\nstatic void ts78xx_ts_rtc_writebyte(unsigned char value, unsigned long addr)\r\n{\r\nwriteb(addr, TS_RTC_CTRL);\r\nwriteb(value, TS_RTC_DATA);\r\n}\r\nstatic int ts78xx_ts_rtc_load(void)\r\n{\r\nint rc;\r\nunsigned char tmp_rtc0, tmp_rtc1;\r\ntmp_rtc0 = ts78xx_ts_rtc_readbyte(126);\r\ntmp_rtc1 = ts78xx_ts_rtc_readbyte(127);\r\nts78xx_ts_rtc_writebyte(0x00, 126);\r\nts78xx_ts_rtc_writebyte(0x55, 127);\r\nif (ts78xx_ts_rtc_readbyte(127) == 0x55) {\r\nts78xx_ts_rtc_writebyte(0xaa, 127);\r\nif (ts78xx_ts_rtc_readbyte(127) == 0xaa\r\n&& ts78xx_ts_rtc_readbyte(126) == 0x00) {\r\nts78xx_ts_rtc_writebyte(tmp_rtc0, 126);\r\nts78xx_ts_rtc_writebyte(tmp_rtc1, 127);\r\nif (ts78xx_fpga.supports.ts_rtc.init == 0) {\r\nrc = platform_device_register(&ts78xx_ts_rtc_device);\r\nif (!rc)\r\nts78xx_fpga.supports.ts_rtc.init = 1;\r\n} else\r\nrc = platform_device_add(&ts78xx_ts_rtc_device);\r\nreturn rc;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void ts78xx_ts_rtc_unload(void)\r\n{\r\nplatform_device_del(&ts78xx_ts_rtc_device);\r\n}\r\nstatic void ts78xx_ts_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nunsigned char bits;\r\nbits = (ctrl & NAND_NCE) << 2;\r\nbits |= ctrl & NAND_CLE;\r\nbits |= (ctrl & NAND_ALE) >> 2;\r\nwriteb((readb(TS_NAND_CTRL) & ~0x7) | bits, TS_NAND_CTRL);\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, this->IO_ADDR_W);\r\n}\r\nstatic int ts78xx_ts_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nreturn readb(TS_NAND_CTRL) & 0x20;\r\n}\r\nstatic void ts78xx_ts_nand_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nvoid __iomem *io_base = chip->IO_ADDR_W;\r\nunsigned long off = ((unsigned long)buf & 3);\r\nint sz;\r\nif (off) {\r\nsz = min_t(int, 4 - off, len);\r\nwritesb(io_base, buf, sz);\r\nbuf += sz;\r\nlen -= sz;\r\n}\r\nsz = len >> 2;\r\nif (sz) {\r\nu32 *buf32 = (u32 *)buf;\r\nwritesl(io_base, buf32, sz);\r\nbuf += sz << 2;\r\nlen -= sz << 2;\r\n}\r\nif (len)\r\nwritesb(io_base, buf, len);\r\n}\r\nstatic void ts78xx_ts_nand_read_buf(struct mtd_info *mtd,\r\nuint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nvoid __iomem *io_base = chip->IO_ADDR_R;\r\nunsigned long off = ((unsigned long)buf & 3);\r\nint sz;\r\nif (off) {\r\nsz = min_t(int, 4 - off, len);\r\nreadsb(io_base, buf, sz);\r\nbuf += sz;\r\nlen -= sz;\r\n}\r\nsz = len >> 2;\r\nif (sz) {\r\nu32 *buf32 = (u32 *)buf;\r\nreadsl(io_base, buf32, sz);\r\nbuf += sz << 2;\r\nlen -= sz << 2;\r\n}\r\nif (len)\r\nreadsb(io_base, buf, len);\r\n}\r\nstatic int ts78xx_ts_nand_load(void)\r\n{\r\nint rc;\r\nif (ts78xx_fpga.supports.ts_nand.init == 0) {\r\nrc = platform_device_register(&ts78xx_ts_nand_device);\r\nif (!rc)\r\nts78xx_fpga.supports.ts_nand.init = 1;\r\n} else\r\nrc = platform_device_add(&ts78xx_ts_nand_device);\r\nreturn rc;\r\n}\r\nstatic void ts78xx_ts_nand_unload(void)\r\n{\r\nplatform_device_del(&ts78xx_ts_nand_device);\r\n}\r\nstatic int ts78xx_ts_rng_load(void)\r\n{\r\nint rc;\r\nif (ts78xx_fpga.supports.ts_rng.init == 0) {\r\nrc = platform_device_register(&ts78xx_ts_rng_device);\r\nif (!rc)\r\nts78xx_fpga.supports.ts_rng.init = 1;\r\n} else\r\nrc = platform_device_add(&ts78xx_ts_rng_device);\r\nreturn rc;\r\n}\r\nstatic void ts78xx_ts_rng_unload(void)\r\n{\r\nplatform_device_del(&ts78xx_ts_rng_device);\r\n}\r\nstatic void ts78xx_fpga_devices_zero_init(void)\r\n{\r\nts78xx_fpga.supports.ts_rtc.init = 0;\r\nts78xx_fpga.supports.ts_nand.init = 0;\r\nts78xx_fpga.supports.ts_rng.init = 0;\r\n}\r\nstatic void ts78xx_fpga_supports(void)\r\n{\r\nswitch (ts78xx_fpga.id) {\r\ncase TS7800_REV_1:\r\ncase TS7800_REV_2:\r\ncase TS7800_REV_3:\r\ncase TS7800_REV_4:\r\ncase TS7800_REV_5:\r\ncase TS7800_REV_6:\r\ncase TS7800_REV_7:\r\ncase TS7800_REV_8:\r\ncase TS7800_REV_9:\r\nts78xx_fpga.supports.ts_rtc.present = 1;\r\nts78xx_fpga.supports.ts_nand.present = 1;\r\nts78xx_fpga.supports.ts_rng.present = 1;\r\nbreak;\r\ndefault:\r\nswitch ((ts78xx_fpga.id >> 8) & 0xffffff) {\r\ncase TS7800_FPGA_MAGIC:\r\npr_warning("TS-7800 FPGA: unrecognized revision 0x%.2x\n",\r\nts78xx_fpga.id & 0xff);\r\nts78xx_fpga.supports.ts_rtc.present = 1;\r\nts78xx_fpga.supports.ts_nand.present = 1;\r\nts78xx_fpga.supports.ts_rng.present = 1;\r\nbreak;\r\ndefault:\r\nts78xx_fpga.supports.ts_rtc.present = 0;\r\nts78xx_fpga.supports.ts_nand.present = 0;\r\nts78xx_fpga.supports.ts_rng.present = 0;\r\n}\r\n}\r\n}\r\nstatic int ts78xx_fpga_load_devices(void)\r\n{\r\nint tmp, ret = 0;\r\nif (ts78xx_fpga.supports.ts_rtc.present == 1) {\r\ntmp = ts78xx_ts_rtc_load();\r\nif (tmp) {\r\npr_info("TS-78xx: RTC not registered\n");\r\nts78xx_fpga.supports.ts_rtc.present = 0;\r\n}\r\nret |= tmp;\r\n}\r\nif (ts78xx_fpga.supports.ts_nand.present == 1) {\r\ntmp = ts78xx_ts_nand_load();\r\nif (tmp) {\r\npr_info("TS-78xx: NAND not registered\n");\r\nts78xx_fpga.supports.ts_nand.present = 0;\r\n}\r\nret |= tmp;\r\n}\r\nif (ts78xx_fpga.supports.ts_rng.present == 1) {\r\ntmp = ts78xx_ts_rng_load();\r\nif (tmp) {\r\npr_info("TS-78xx: RNG not registered\n");\r\nts78xx_fpga.supports.ts_rng.present = 0;\r\n}\r\nret |= tmp;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ts78xx_fpga_unload_devices(void)\r\n{\r\nint ret = 0;\r\nif (ts78xx_fpga.supports.ts_rtc.present == 1)\r\nts78xx_ts_rtc_unload();\r\nif (ts78xx_fpga.supports.ts_nand.present == 1)\r\nts78xx_ts_nand_unload();\r\nif (ts78xx_fpga.supports.ts_rng.present == 1)\r\nts78xx_ts_rng_unload();\r\nreturn ret;\r\n}\r\nstatic int ts78xx_fpga_load(void)\r\n{\r\nts78xx_fpga.id = readl(TS78XX_FPGA_REGS_VIRT_BASE);\r\npr_info("TS-78xx FPGA: magic=0x%.6x, rev=0x%.2x\n",\r\n(ts78xx_fpga.id >> 8) & 0xffffff,\r\nts78xx_fpga.id & 0xff);\r\nts78xx_fpga_supports();\r\nif (ts78xx_fpga_load_devices()) {\r\nts78xx_fpga.state = -1;\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ts78xx_fpga_unload(void)\r\n{\r\nunsigned int fpga_id;\r\nfpga_id = readl(TS78XX_FPGA_REGS_VIRT_BASE);\r\nif (ts78xx_fpga.id != fpga_id) {\r\npr_err("TS-78xx FPGA: magic/rev mismatch\n"\r\n"TS-78xx FPGA: was 0x%.6x/%.2x but now 0x%.6x/%.2x\n",\r\n(ts78xx_fpga.id >> 8) & 0xffffff, ts78xx_fpga.id & 0xff,\r\n(fpga_id >> 8) & 0xffffff, fpga_id & 0xff);\r\nts78xx_fpga.state = -1;\r\nreturn -EBUSY;\r\n}\r\nif (ts78xx_fpga_unload_devices()) {\r\nts78xx_fpga.state = -1;\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t ts78xx_fpga_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nif (ts78xx_fpga.state < 0)\r\nreturn sprintf(buf, "borked\n");\r\nreturn sprintf(buf, "%s\n", (ts78xx_fpga.state) ? "online" : "offline");\r\n}\r\nstatic ssize_t ts78xx_fpga_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr, const char *buf, size_t n)\r\n{\r\nint value, ret;\r\nif (ts78xx_fpga.state < 0) {\r\npr_err("TS-78xx FPGA: borked, you must powercycle asap\n");\r\nreturn -EBUSY;\r\n}\r\nif (strncmp(buf, "online", sizeof("online") - 1) == 0)\r\nvalue = 1;\r\nelse if (strncmp(buf, "offline", sizeof("offline") - 1) == 0)\r\nvalue = 0;\r\nelse {\r\npr_err("ts78xx_fpga_store: Invalid value\n");\r\nreturn -EINVAL;\r\n}\r\nif (ts78xx_fpga.state == value)\r\nreturn n;\r\nret = (ts78xx_fpga.state == 0)\r\n? ts78xx_fpga_load()\r\n: ts78xx_fpga_unload();\r\nif (!(ret < 0))\r\nts78xx_fpga.state = value;\r\nreturn n;\r\n}\r\nstatic void __init ts78xx_init(void)\r\n{\r\nint ret;\r\norion5x_init();\r\norion5x_mpp_conf(ts78xx_mpp_modes);\r\norion5x_ehci0_init();\r\norion5x_ehci1_init();\r\norion5x_eth_init(&ts78xx_eth_data);\r\norion5x_sata_init(&ts78xx_sata_data);\r\norion5x_uart0_init();\r\norion5x_uart1_init();\r\norion5x_xor_init();\r\nts78xx_fpga_devices_zero_init();\r\nret = ts78xx_fpga_load();\r\nret = sysfs_create_file(power_kobj, &ts78xx_fpga_attr.attr);\r\nif (ret)\r\npr_err("sysfs_create_file failed: %d\n", ret);\r\n}
