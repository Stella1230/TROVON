static inline void add_wildcard(char *str)\r\n{\r\nint len = strlen(str);\r\nif (str[len - 1] != '*')\r\nstrcat(str + len, "*");\r\n}\r\nstatic void device_id_check(const char *modname, const char *device_id,\r\nunsigned long size, unsigned long id_size,\r\nvoid *symval)\r\n{\r\nint i;\r\nif (size % id_size || size < id_size) {\r\nif (cross_build != 0)\r\nreturn;\r\nfatal("%s: sizeof(struct %s_device_id)=%lu is not a modulo "\r\n"of the size of section __mod_%s_device_table=%lu.\n"\r\n"Fix definition of struct %s_device_id "\r\n"in mod_devicetable.h\n",\r\nmodname, device_id, id_size, device_id, size, device_id);\r\n}\r\nfor (i = 0; i < id_size; i++ ) {\r\nif (*(uint8_t*)(symval+size-id_size+i)) {\r\nfprintf(stderr,"%s: struct %s_device_id is %lu bytes. "\r\n"The last of %lu is:\n",\r\nmodname, device_id, id_size, size / id_size);\r\nfor (i = 0; i < id_size; i++ )\r\nfprintf(stderr,"0x%02x ",\r\n*(uint8_t*)(symval+size-id_size+i) );\r\nfprintf(stderr,"\n");\r\nfatal("%s: struct %s_device_id is not terminated "\r\n"with a NULL entry!\n", modname, device_id);\r\n}\r\n}\r\n}\r\nstatic void do_usb_entry(struct usb_device_id *id,\r\nunsigned int bcdDevice_initial, int bcdDevice_initial_digits,\r\nunsigned char range_lo, unsigned char range_hi,\r\nunsigned char max, struct module *mod)\r\n{\r\nchar alias[500];\r\nstrcpy(alias, "usb:");\r\nADD(alias, "v", id->match_flags&USB_DEVICE_ID_MATCH_VENDOR,\r\nid->idVendor);\r\nADD(alias, "p", id->match_flags&USB_DEVICE_ID_MATCH_PRODUCT,\r\nid->idProduct);\r\nstrcat(alias, "d");\r\nif (bcdDevice_initial_digits)\r\nsprintf(alias + strlen(alias), "%0*X",\r\nbcdDevice_initial_digits, bcdDevice_initial);\r\nif (range_lo == range_hi)\r\nsprintf(alias + strlen(alias), "%X", range_lo);\r\nelse if (range_lo > 0 || range_hi < max) {\r\nif (range_lo > 0x9 || range_hi < 0xA)\r\nsprintf(alias + strlen(alias),\r\n"[%X-%X]",\r\nrange_lo,\r\nrange_hi);\r\nelse {\r\nsprintf(alias + strlen(alias),\r\nrange_lo < 0x9 ? "[%X-9" : "[%X",\r\nrange_lo);\r\nsprintf(alias + strlen(alias),\r\nrange_hi > 0xA ? "a-%X]" : "%X]",\r\nrange_lo);\r\n}\r\n}\r\nif (bcdDevice_initial_digits < (sizeof(id->bcdDevice_lo) * 2 - 1))\r\nstrcat(alias, "*");\r\nADD(alias, "dc", id->match_flags&USB_DEVICE_ID_MATCH_DEV_CLASS,\r\nid->bDeviceClass);\r\nADD(alias, "dsc",\r\nid->match_flags&USB_DEVICE_ID_MATCH_DEV_SUBCLASS,\r\nid->bDeviceSubClass);\r\nADD(alias, "dp",\r\nid->match_flags&USB_DEVICE_ID_MATCH_DEV_PROTOCOL,\r\nid->bDeviceProtocol);\r\nADD(alias, "ic",\r\nid->match_flags&USB_DEVICE_ID_MATCH_INT_CLASS,\r\nid->bInterfaceClass);\r\nADD(alias, "isc",\r\nid->match_flags&USB_DEVICE_ID_MATCH_INT_SUBCLASS,\r\nid->bInterfaceSubClass);\r\nADD(alias, "ip",\r\nid->match_flags&USB_DEVICE_ID_MATCH_INT_PROTOCOL,\r\nid->bInterfaceProtocol);\r\nadd_wildcard(alias);\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"%s\");\n", alias);\r\n}\r\nstatic unsigned int incbcd(unsigned int *bcd,\r\nint inc,\r\nunsigned char max,\r\nsize_t chars)\r\n{\r\nunsigned int init = *bcd, i, j;\r\nunsigned long long c, dec = 0;\r\nif (max > 0x9) {\r\n*bcd += inc;\r\nreturn init;\r\n}\r\nfor (i=0 ; i < chars ; i++) {\r\nc = (*bcd >> (i << 2)) & 0xf;\r\nc = c > 9 ? 9 : c;\r\nfor (j=0 ; j < i ; j++)\r\nc = c * 10;\r\ndec += c;\r\n}\r\ndec += inc;\r\n*bcd = 0;\r\nfor (i=0 ; i < chars ; i++) {\r\nfor (c=1,j=0 ; j < i ; j++)\r\nc = c * 10;\r\nc = (dec / c) % 10;\r\n*bcd += c << (i << 2);\r\n}\r\nreturn init;\r\n}\r\nstatic void do_usb_entry_multi(struct usb_device_id *id, struct module *mod)\r\n{\r\nunsigned int devlo, devhi;\r\nunsigned char chi, clo, max;\r\nint ndigits;\r\nid->match_flags = TO_NATIVE(id->match_flags);\r\nid->idVendor = TO_NATIVE(id->idVendor);\r\nid->idProduct = TO_NATIVE(id->idProduct);\r\ndevlo = id->match_flags & USB_DEVICE_ID_MATCH_DEV_LO ?\r\nTO_NATIVE(id->bcdDevice_lo) : 0x0U;\r\ndevhi = id->match_flags & USB_DEVICE_ID_MATCH_DEV_HI ?\r\nTO_NATIVE(id->bcdDevice_hi) : ~0x0U;\r\nmax = 0x9;\r\nfor (ndigits = 0 ; ndigits < sizeof(id->bcdDevice_lo) * 2 ; ndigits++) {\r\nclo = (devlo >> (ndigits << 2)) & 0xf;\r\nchi = ((devhi > 0x9999 ? 0x9999 : devhi) >> (ndigits << 2)) & 0xf;\r\nif (clo > max || chi > max) {\r\nmax = 0xf;\r\nbreak;\r\n}\r\n}\r\nif (!(id->idVendor | id->idProduct | id->bDeviceClass | id->bInterfaceClass))\r\nreturn;\r\nfor (ndigits = sizeof(id->bcdDevice_lo) * 2 - 1; devlo <= devhi; ndigits--) {\r\nclo = devlo & 0xf;\r\nchi = devhi & 0xf;\r\nif (chi > max)\r\nchi = max;\r\ndevlo >>= 4;\r\ndevhi >>= 4;\r\nif (devlo == devhi || !ndigits) {\r\ndo_usb_entry(id, devlo, ndigits, clo, chi, max, mod);\r\nbreak;\r\n}\r\nif (clo > 0x0)\r\ndo_usb_entry(id,\r\nincbcd(&devlo, 1, max,\r\nsizeof(id->bcdDevice_lo) * 2),\r\nndigits, clo, max, max, mod);\r\nif (chi < max)\r\ndo_usb_entry(id,\r\nincbcd(&devhi, -1, max,\r\nsizeof(id->bcdDevice_lo) * 2),\r\nndigits, 0x0, chi, max, mod);\r\n}\r\n}\r\nstatic void do_usb_table(void *symval, unsigned long size,\r\nstruct module *mod)\r\n{\r\nunsigned int i;\r\nconst unsigned long id_size = sizeof(struct usb_device_id);\r\ndevice_id_check(mod->name, "usb", size, id_size, symval);\r\nsize -= id_size;\r\nfor (i = 0; i < size; i += id_size)\r\ndo_usb_entry_multi(symval + i, mod);\r\n}\r\nstatic int do_hid_entry(const char *filename,\r\nstruct hid_device_id *id, char *alias)\r\n{\r\nid->bus = TO_NATIVE(id->bus);\r\nid->vendor = TO_NATIVE(id->vendor);\r\nid->product = TO_NATIVE(id->product);\r\nsprintf(alias, "hid:b%04X", id->bus);\r\nADD(alias, "v", id->vendor != HID_ANY_ID, id->vendor);\r\nADD(alias, "p", id->product != HID_ANY_ID, id->product);\r\nreturn 1;\r\n}\r\nstatic int do_ieee1394_entry(const char *filename,\r\nstruct ieee1394_device_id *id, char *alias)\r\n{\r\nid->match_flags = TO_NATIVE(id->match_flags);\r\nid->vendor_id = TO_NATIVE(id->vendor_id);\r\nid->model_id = TO_NATIVE(id->model_id);\r\nid->specifier_id = TO_NATIVE(id->specifier_id);\r\nid->version = TO_NATIVE(id->version);\r\nstrcpy(alias, "ieee1394:");\r\nADD(alias, "ven", id->match_flags & IEEE1394_MATCH_VENDOR_ID,\r\nid->vendor_id);\r\nADD(alias, "mo", id->match_flags & IEEE1394_MATCH_MODEL_ID,\r\nid->model_id);\r\nADD(alias, "sp", id->match_flags & IEEE1394_MATCH_SPECIFIER_ID,\r\nid->specifier_id);\r\nADD(alias, "ver", id->match_flags & IEEE1394_MATCH_VERSION,\r\nid->version);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_pci_entry(const char *filename,\r\nstruct pci_device_id *id, char *alias)\r\n{\r\nunsigned char baseclass, subclass, interface,\r\nbaseclass_mask, subclass_mask, interface_mask;\r\nid->vendor = TO_NATIVE(id->vendor);\r\nid->device = TO_NATIVE(id->device);\r\nid->subvendor = TO_NATIVE(id->subvendor);\r\nid->subdevice = TO_NATIVE(id->subdevice);\r\nid->class = TO_NATIVE(id->class);\r\nid->class_mask = TO_NATIVE(id->class_mask);\r\nstrcpy(alias, "pci:");\r\nADD(alias, "v", id->vendor != PCI_ANY_ID, id->vendor);\r\nADD(alias, "d", id->device != PCI_ANY_ID, id->device);\r\nADD(alias, "sv", id->subvendor != PCI_ANY_ID, id->subvendor);\r\nADD(alias, "sd", id->subdevice != PCI_ANY_ID, id->subdevice);\r\nbaseclass = (id->class) >> 16;\r\nbaseclass_mask = (id->class_mask) >> 16;\r\nsubclass = (id->class) >> 8;\r\nsubclass_mask = (id->class_mask) >> 8;\r\ninterface = id->class;\r\ninterface_mask = id->class_mask;\r\nif ((baseclass_mask != 0 && baseclass_mask != 0xFF)\r\n|| (subclass_mask != 0 && subclass_mask != 0xFF)\r\n|| (interface_mask != 0 && interface_mask != 0xFF)) {\r\nwarn("Can't handle masks in %s:%04X\n",\r\nfilename, id->class_mask);\r\nreturn 0;\r\n}\r\nADD(alias, "bc", baseclass_mask == 0xFF, baseclass);\r\nADD(alias, "sc", subclass_mask == 0xFF, subclass);\r\nADD(alias, "i", interface_mask == 0xFF, interface);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_ccw_entry(const char *filename,\r\nstruct ccw_device_id *id, char *alias)\r\n{\r\nid->match_flags = TO_NATIVE(id->match_flags);\r\nid->cu_type = TO_NATIVE(id->cu_type);\r\nid->cu_model = TO_NATIVE(id->cu_model);\r\nid->dev_type = TO_NATIVE(id->dev_type);\r\nid->dev_model = TO_NATIVE(id->dev_model);\r\nstrcpy(alias, "ccw:");\r\nADD(alias, "t", id->match_flags&CCW_DEVICE_ID_MATCH_CU_TYPE,\r\nid->cu_type);\r\nADD(alias, "m", id->match_flags&CCW_DEVICE_ID_MATCH_CU_MODEL,\r\nid->cu_model);\r\nADD(alias, "dt", id->match_flags&CCW_DEVICE_ID_MATCH_DEVICE_TYPE,\r\nid->dev_type);\r\nADD(alias, "dm", id->match_flags&CCW_DEVICE_ID_MATCH_DEVICE_MODEL,\r\nid->dev_model);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_ap_entry(const char *filename,\r\nstruct ap_device_id *id, char *alias)\r\n{\r\nsprintf(alias, "ap:t%02X*", id->dev_type);\r\nreturn 1;\r\n}\r\nstatic int do_css_entry(const char *filename,\r\nstruct css_device_id *id, char *alias)\r\n{\r\nsprintf(alias, "css:t%01X", id->type);\r\nreturn 1;\r\n}\r\nstatic int do_serio_entry(const char *filename,\r\nstruct serio_device_id *id, char *alias)\r\n{\r\nid->type = TO_NATIVE(id->type);\r\nid->proto = TO_NATIVE(id->proto);\r\nid->id = TO_NATIVE(id->id);\r\nid->extra = TO_NATIVE(id->extra);\r\nstrcpy(alias, "serio:");\r\nADD(alias, "ty", id->type != SERIO_ANY, id->type);\r\nADD(alias, "pr", id->proto != SERIO_ANY, id->proto);\r\nADD(alias, "id", id->id != SERIO_ANY, id->id);\r\nADD(alias, "ex", id->extra != SERIO_ANY, id->extra);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_acpi_entry(const char *filename,\r\nstruct acpi_device_id *id, char *alias)\r\n{\r\nsprintf(alias, "acpi*:%s:*", id->id);\r\nreturn 1;\r\n}\r\nstatic void do_pnp_device_entry(void *symval, unsigned long size,\r\nstruct module *mod)\r\n{\r\nconst unsigned long id_size = sizeof(struct pnp_device_id);\r\nconst unsigned int count = (size / id_size)-1;\r\nconst struct pnp_device_id *devs = symval;\r\nunsigned int i;\r\ndevice_id_check(mod->name, "pnp", size, id_size, symval);\r\nfor (i = 0; i < count; i++) {\r\nconst char *id = (char *)devs[i].id;\r\nchar acpi_id[sizeof(devs[0].id)];\r\nint j;\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"pnp:d%s*\");\n", id);\r\nfor (j = 0; j < sizeof(acpi_id); j++)\r\nacpi_id[j] = toupper(id[j]);\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"acpi*:%s:*\");\n", acpi_id);\r\n}\r\n}\r\nstatic void do_pnp_card_entries(void *symval, unsigned long size,\r\nstruct module *mod)\r\n{\r\nconst unsigned long id_size = sizeof(struct pnp_card_device_id);\r\nconst unsigned int count = (size / id_size)-1;\r\nconst struct pnp_card_device_id *cards = symval;\r\nunsigned int i;\r\ndevice_id_check(mod->name, "pnp", size, id_size, symval);\r\nfor (i = 0; i < count; i++) {\r\nunsigned int j;\r\nconst struct pnp_card_device_id *card = &cards[i];\r\nfor (j = 0; j < PNP_MAX_DEVICES; j++) {\r\nconst char *id = (char *)card->devs[j].id;\r\nint i2, j2;\r\nint dup = 0;\r\nif (!id[0])\r\nbreak;\r\nfor (i2 = 0; i2 < i && !dup; i2++) {\r\nconst struct pnp_card_device_id *card2 = &cards[i2];\r\nfor (j2 = 0; j2 < PNP_MAX_DEVICES; j2++) {\r\nconst char *id2 = (char *)card2->devs[j2].id;\r\nif (!id2[0])\r\nbreak;\r\nif (!strcmp(id, id2)) {\r\ndup = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!dup) {\r\nchar acpi_id[sizeof(card->devs[0].id)];\r\nint k;\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"pnp:d%s*\");\n", id);\r\nfor (k = 0; k < sizeof(acpi_id); k++)\r\nacpi_id[k] = toupper(id[k]);\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"acpi*:%s:*\");\n", acpi_id);\r\n}\r\n}\r\n}\r\n}\r\nstatic int do_pcmcia_entry(const char *filename,\r\nstruct pcmcia_device_id *id, char *alias)\r\n{\r\nunsigned int i;\r\nid->match_flags = TO_NATIVE(id->match_flags);\r\nid->manf_id = TO_NATIVE(id->manf_id);\r\nid->card_id = TO_NATIVE(id->card_id);\r\nid->func_id = TO_NATIVE(id->func_id);\r\nid->function = TO_NATIVE(id->function);\r\nid->device_no = TO_NATIVE(id->device_no);\r\nfor (i=0; i<4; i++) {\r\nid->prod_id_hash[i] = TO_NATIVE(id->prod_id_hash[i]);\r\n}\r\nstrcpy(alias, "pcmcia:");\r\nADD(alias, "m", id->match_flags & PCMCIA_DEV_ID_MATCH_MANF_ID,\r\nid->manf_id);\r\nADD(alias, "c", id->match_flags & PCMCIA_DEV_ID_MATCH_CARD_ID,\r\nid->card_id);\r\nADD(alias, "f", id->match_flags & PCMCIA_DEV_ID_MATCH_FUNC_ID,\r\nid->func_id);\r\nADD(alias, "fn", id->match_flags & PCMCIA_DEV_ID_MATCH_FUNCTION,\r\nid->function);\r\nADD(alias, "pfn", id->match_flags & PCMCIA_DEV_ID_MATCH_DEVICE_NO,\r\nid->device_no);\r\nADD(alias, "pa", id->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID1, id->prod_id_hash[0]);\r\nADD(alias, "pb", id->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID2, id->prod_id_hash[1]);\r\nADD(alias, "pc", id->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID3, id->prod_id_hash[2]);\r\nADD(alias, "pd", id->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID4, id->prod_id_hash[3]);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_of_entry (const char *filename, struct of_device_id *of, char *alias)\r\n{\r\nint len;\r\nchar *tmp;\r\nlen = sprintf (alias, "of:N%sT%s",\r\nof->name[0] ? of->name : "*",\r\nof->type[0] ? of->type : "*");\r\nif (of->compatible[0])\r\nsprintf (&alias[len], "%sC%s",\r\nof->type[0] ? "*" : "",\r\nof->compatible);\r\nfor (tmp = alias; tmp && *tmp; tmp++)\r\nif (isspace (*tmp))\r\n*tmp = '_';\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_vio_entry(const char *filename, struct vio_device_id *vio,\r\nchar *alias)\r\n{\r\nchar *tmp;\r\nsprintf(alias, "vio:T%sS%s", vio->type[0] ? vio->type : "*",\r\nvio->compat[0] ? vio->compat : "*");\r\nfor (tmp = alias; tmp && *tmp; tmp++)\r\nif (isspace (*tmp))\r\n*tmp = '_';\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic void do_input(char *alias,\r\nkernel_ulong_t *arr, unsigned int min, unsigned int max)\r\n{\r\nunsigned int i;\r\nfor (i = min; i < max; i++)\r\nif (arr[i / BITS_PER_LONG] & (1L << (i%BITS_PER_LONG)))\r\nsprintf(alias + strlen(alias), "%X,*", i);\r\n}\r\nstatic int do_input_entry(const char *filename, struct input_device_id *id,\r\nchar *alias)\r\n{\r\nsprintf(alias, "input:");\r\nADD(alias, "b", id->flags & INPUT_DEVICE_ID_MATCH_BUS, id->bustype);\r\nADD(alias, "v", id->flags & INPUT_DEVICE_ID_MATCH_VENDOR, id->vendor);\r\nADD(alias, "p", id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT, id->product);\r\nADD(alias, "e", id->flags & INPUT_DEVICE_ID_MATCH_VERSION, id->version);\r\nsprintf(alias + strlen(alias), "-e*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_EVBIT)\r\ndo_input(alias, id->evbit, 0, INPUT_DEVICE_ID_EV_MAX);\r\nsprintf(alias + strlen(alias), "k*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_KEYBIT)\r\ndo_input(alias, id->keybit,\r\nINPUT_DEVICE_ID_KEY_MIN_INTERESTING,\r\nINPUT_DEVICE_ID_KEY_MAX);\r\nsprintf(alias + strlen(alias), "r*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_RELBIT)\r\ndo_input(alias, id->relbit, 0, INPUT_DEVICE_ID_REL_MAX);\r\nsprintf(alias + strlen(alias), "a*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_ABSBIT)\r\ndo_input(alias, id->absbit, 0, INPUT_DEVICE_ID_ABS_MAX);\r\nsprintf(alias + strlen(alias), "m*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_MSCIT)\r\ndo_input(alias, id->mscbit, 0, INPUT_DEVICE_ID_MSC_MAX);\r\nsprintf(alias + strlen(alias), "l*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_LEDBIT)\r\ndo_input(alias, id->ledbit, 0, INPUT_DEVICE_ID_LED_MAX);\r\nsprintf(alias + strlen(alias), "s*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_SNDBIT)\r\ndo_input(alias, id->sndbit, 0, INPUT_DEVICE_ID_SND_MAX);\r\nsprintf(alias + strlen(alias), "f*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_FFBIT)\r\ndo_input(alias, id->ffbit, 0, INPUT_DEVICE_ID_FF_MAX);\r\nsprintf(alias + strlen(alias), "w*");\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_SWBIT)\r\ndo_input(alias, id->swbit, 0, INPUT_DEVICE_ID_SW_MAX);\r\nreturn 1;\r\n}\r\nstatic int do_eisa_entry(const char *filename, struct eisa_device_id *eisa,\r\nchar *alias)\r\n{\r\nif (eisa->sig[0])\r\nsprintf(alias, EISA_DEVICE_MODALIAS_FMT "*", eisa->sig);\r\nelse\r\nstrcat(alias, "*");\r\nreturn 1;\r\n}\r\nstatic int do_parisc_entry(const char *filename, struct parisc_device_id *id,\r\nchar *alias)\r\n{\r\nid->hw_type = TO_NATIVE(id->hw_type);\r\nid->hversion = TO_NATIVE(id->hversion);\r\nid->hversion_rev = TO_NATIVE(id->hversion_rev);\r\nid->sversion = TO_NATIVE(id->sversion);\r\nstrcpy(alias, "parisc:");\r\nADD(alias, "t", id->hw_type != PA_HWTYPE_ANY_ID, id->hw_type);\r\nADD(alias, "hv", id->hversion != PA_HVERSION_ANY_ID, id->hversion);\r\nADD(alias, "rev", id->hversion_rev != PA_HVERSION_REV_ANY_ID, id->hversion_rev);\r\nADD(alias, "sv", id->sversion != PA_SVERSION_ANY_ID, id->sversion);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_sdio_entry(const char *filename,\r\nstruct sdio_device_id *id, char *alias)\r\n{\r\nid->class = TO_NATIVE(id->class);\r\nid->vendor = TO_NATIVE(id->vendor);\r\nid->device = TO_NATIVE(id->device);\r\nstrcpy(alias, "sdio:");\r\nADD(alias, "c", id->class != (__u8)SDIO_ANY_ID, id->class);\r\nADD(alias, "v", id->vendor != (__u16)SDIO_ANY_ID, id->vendor);\r\nADD(alias, "d", id->device != (__u16)SDIO_ANY_ID, id->device);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_ssb_entry(const char *filename,\r\nstruct ssb_device_id *id, char *alias)\r\n{\r\nid->vendor = TO_NATIVE(id->vendor);\r\nid->coreid = TO_NATIVE(id->coreid);\r\nid->revision = TO_NATIVE(id->revision);\r\nstrcpy(alias, "ssb:");\r\nADD(alias, "v", id->vendor != SSB_ANY_VENDOR, id->vendor);\r\nADD(alias, "id", id->coreid != SSB_ANY_ID, id->coreid);\r\nADD(alias, "rev", id->revision != SSB_ANY_REV, id->revision);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_bcma_entry(const char *filename,\r\nstruct bcma_device_id *id, char *alias)\r\n{\r\nid->manuf = TO_NATIVE(id->manuf);\r\nid->id = TO_NATIVE(id->id);\r\nid->rev = TO_NATIVE(id->rev);\r\nid->class = TO_NATIVE(id->class);\r\nstrcpy(alias, "bcma:");\r\nADD(alias, "m", id->manuf != BCMA_ANY_MANUF, id->manuf);\r\nADD(alias, "id", id->id != BCMA_ANY_ID, id->id);\r\nADD(alias, "rev", id->rev != BCMA_ANY_REV, id->rev);\r\nADD(alias, "cl", id->class != BCMA_ANY_CLASS, id->class);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_virtio_entry(const char *filename, struct virtio_device_id *id,\r\nchar *alias)\r\n{\r\nid->device = TO_NATIVE(id->device);\r\nid->vendor = TO_NATIVE(id->vendor);\r\nstrcpy(alias, "virtio:");\r\nADD(alias, "d", id->device != VIRTIO_DEV_ANY_ID, id->device);\r\nADD(alias, "v", id->vendor != VIRTIO_DEV_ANY_ID, id->vendor);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_i2c_entry(const char *filename, struct i2c_device_id *id,\r\nchar *alias)\r\n{\r\nsprintf(alias, I2C_MODULE_PREFIX "%s", id->name);\r\nreturn 1;\r\n}\r\nstatic int do_spi_entry(const char *filename, struct spi_device_id *id,\r\nchar *alias)\r\n{\r\nsprintf(alias, SPI_MODULE_PREFIX "%s", id->name);\r\nreturn 1;\r\n}\r\nstatic void dmi_ascii_filter(char *d, const char *s)\r\n{\r\nfor (; *s; s++)\r\nif (*s > ' ' && *s < 127 && *s != ':')\r\n*(d++) = *s;\r\n*d = 0;\r\n}\r\nstatic int do_dmi_entry(const char *filename, struct dmi_system_id *id,\r\nchar *alias)\r\n{\r\nint i, j;\r\nsprintf(alias, "dmi*");\r\nfor (i = 0; i < ARRAY_SIZE(dmi_fields); i++) {\r\nfor (j = 0; j < 4; j++) {\r\nif (id->matches[j].slot &&\r\nid->matches[j].slot == dmi_fields[i].field) {\r\nsprintf(alias + strlen(alias), ":%s*",\r\ndmi_fields[i].prefix);\r\ndmi_ascii_filter(alias + strlen(alias),\r\nid->matches[j].substr);\r\nstrcat(alias, "*");\r\n}\r\n}\r\n}\r\nstrcat(alias, ":");\r\nreturn 1;\r\n}\r\nstatic int do_platform_entry(const char *filename,\r\nstruct platform_device_id *id, char *alias)\r\n{\r\nsprintf(alias, PLATFORM_MODULE_PREFIX "%s", id->name);\r\nreturn 1;\r\n}\r\nstatic int do_mdio_entry(const char *filename,\r\nstruct mdio_device_id *id, char *alias)\r\n{\r\nint i;\r\nalias += sprintf(alias, MDIO_MODULE_PREFIX);\r\nfor (i = 0; i < 32; i++) {\r\nif (!((id->phy_id_mask >> (31-i)) & 1))\r\n*(alias++) = '?';\r\nelse if ((id->phy_id >> (31-i)) & 1)\r\n*(alias++) = '1';\r\nelse\r\n*(alias++) = '0';\r\n}\r\n*alias = 0;\r\nreturn 1;\r\n}\r\nstatic int do_zorro_entry(const char *filename, struct zorro_device_id *id,\r\nchar *alias)\r\n{\r\nid->id = TO_NATIVE(id->id);\r\nstrcpy(alias, "zorro:");\r\nADD(alias, "i", id->id != ZORRO_WILDCARD, id->id);\r\nreturn 1;\r\n}\r\nstatic int do_isapnp_entry(const char *filename,\r\nstruct isapnp_device_id *id, char *alias)\r\n{\r\nsprintf(alias, "pnp:d%c%c%c%x%x%x%x*",\r\n'A' + ((id->vendor >> 2) & 0x3f) - 1,\r\n'A' + (((id->vendor & 3) << 3) | ((id->vendor >> 13) & 7)) - 1,\r\n'A' + ((id->vendor >> 8) & 0x1f) - 1,\r\n(id->function >> 4) & 0x0f, id->function & 0x0f,\r\n(id->function >> 12) & 0x0f, (id->function >> 8) & 0x0f);\r\nreturn 1;\r\n}\r\nstatic inline int sym_is(const char *symbol, const char *name)\r\n{\r\nconst char *match;\r\nmatch = strstr(symbol, name);\r\nif (!match)\r\nreturn 0;\r\nreturn match[strlen(name)] == '\0';\r\n}\r\nstatic void do_table(void *symval, unsigned long size,\r\nunsigned long id_size,\r\nconst char *device_id,\r\nvoid *function,\r\nstruct module *mod)\r\n{\r\nunsigned int i;\r\nchar alias[500];\r\nint (*do_entry)(const char *, void *entry, char *alias) = function;\r\ndevice_id_check(mod->name, device_id, size, id_size, symval);\r\nsize -= id_size;\r\nfor (i = 0; i < size; i += id_size) {\r\nif (do_entry(mod->name, symval+i, alias)) {\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"%s\");\n", alias);\r\n}\r\n}\r\n}\r\nvoid handle_moddevtable(struct module *mod, struct elf_info *info,\r\nElf_Sym *sym, const char *symname)\r\n{\r\nvoid *symval;\r\nchar *zeros = NULL;\r\nif (!sym->st_shndx || get_secindex(info, sym) >= info->num_sections)\r\nreturn;\r\nif (info->sechdrs[get_secindex(info, sym)].sh_type & SHT_NOBITS) {\r\nzeros = calloc(1, sym->st_size);\r\nsymval = zeros;\r\n} else {\r\nsymval = (void *)info->hdr\r\n+ info->sechdrs[get_secindex(info, sym)].sh_offset\r\n+ sym->st_value;\r\n}\r\nif (sym_is(symname, "__mod_pci_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct pci_device_id), "pci",\r\ndo_pci_entry, mod);\r\nelse if (sym_is(symname, "__mod_usb_device_table"))\r\ndo_usb_table(symval, sym->st_size, mod);\r\nelse if (sym_is(symname, "__mod_hid_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct hid_device_id), "hid",\r\ndo_hid_entry, mod);\r\nelse if (sym_is(symname, "__mod_ieee1394_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct ieee1394_device_id), "ieee1394",\r\ndo_ieee1394_entry, mod);\r\nelse if (sym_is(symname, "__mod_ccw_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct ccw_device_id), "ccw",\r\ndo_ccw_entry, mod);\r\nelse if (sym_is(symname, "__mod_ap_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct ap_device_id), "ap",\r\ndo_ap_entry, mod);\r\nelse if (sym_is(symname, "__mod_css_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct css_device_id), "css",\r\ndo_css_entry, mod);\r\nelse if (sym_is(symname, "__mod_serio_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct serio_device_id), "serio",\r\ndo_serio_entry, mod);\r\nelse if (sym_is(symname, "__mod_acpi_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct acpi_device_id), "acpi",\r\ndo_acpi_entry, mod);\r\nelse if (sym_is(symname, "__mod_pnp_device_table"))\r\ndo_pnp_device_entry(symval, sym->st_size, mod);\r\nelse if (sym_is(symname, "__mod_pnp_card_device_table"))\r\ndo_pnp_card_entries(symval, sym->st_size, mod);\r\nelse if (sym_is(symname, "__mod_pcmcia_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct pcmcia_device_id), "pcmcia",\r\ndo_pcmcia_entry, mod);\r\nelse if (sym_is(symname, "__mod_of_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct of_device_id), "of",\r\ndo_of_entry, mod);\r\nelse if (sym_is(symname, "__mod_vio_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct vio_device_id), "vio",\r\ndo_vio_entry, mod);\r\nelse if (sym_is(symname, "__mod_input_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct input_device_id), "input",\r\ndo_input_entry, mod);\r\nelse if (sym_is(symname, "__mod_eisa_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct eisa_device_id), "eisa",\r\ndo_eisa_entry, mod);\r\nelse if (sym_is(symname, "__mod_parisc_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct parisc_device_id), "parisc",\r\ndo_parisc_entry, mod);\r\nelse if (sym_is(symname, "__mod_sdio_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct sdio_device_id), "sdio",\r\ndo_sdio_entry, mod);\r\nelse if (sym_is(symname, "__mod_ssb_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct ssb_device_id), "ssb",\r\ndo_ssb_entry, mod);\r\nelse if (sym_is(symname, "__mod_bcma_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct bcma_device_id), "bcma",\r\ndo_bcma_entry, mod);\r\nelse if (sym_is(symname, "__mod_virtio_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct virtio_device_id), "virtio",\r\ndo_virtio_entry, mod);\r\nelse if (sym_is(symname, "__mod_i2c_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct i2c_device_id), "i2c",\r\ndo_i2c_entry, mod);\r\nelse if (sym_is(symname, "__mod_spi_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct spi_device_id), "spi",\r\ndo_spi_entry, mod);\r\nelse if (sym_is(symname, "__mod_dmi_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct dmi_system_id), "dmi",\r\ndo_dmi_entry, mod);\r\nelse if (sym_is(symname, "__mod_platform_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct platform_device_id), "platform",\r\ndo_platform_entry, mod);\r\nelse if (sym_is(symname, "__mod_mdio_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct mdio_device_id), "mdio",\r\ndo_mdio_entry, mod);\r\nelse if (sym_is(symname, "__mod_zorro_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct zorro_device_id), "zorro",\r\ndo_zorro_entry, mod);\r\nelse if (sym_is(symname, "__mod_isapnp_device_table"))\r\ndo_table(symval, sym->st_size,\r\nsizeof(struct isapnp_device_id), "isa",\r\ndo_isapnp_entry, mod);\r\nfree(zeros);\r\n}\r\nvoid add_moddevtable(struct buffer *buf, struct module *mod)\r\n{\r\nbuf_printf(buf, "\n");\r\nbuf_write(buf, mod->dev_table_buf.p, mod->dev_table_buf.pos);\r\nfree(mod->dev_table_buf.p);\r\n}
