static int db1200_card_inserted(struct db1x_pcmcia_sock *sock)\r\n{\r\nunsigned short sigstat;\r\nsigstat = bcsr_read(BCSR_SIGSTAT);\r\nreturn sigstat & 1 << (8 + 2 * sock->nr);\r\n}\r\nstatic int db1000_card_inserted(struct db1x_pcmcia_sock *sock)\r\n{\r\nreturn !gpio_get_value(irq_to_gpio(sock->insert_irq));\r\n}\r\nstatic int db1x_card_inserted(struct db1x_pcmcia_sock *sock)\r\n{\r\nswitch (sock->board_type) {\r\ncase BOARD_TYPE_DB1200:\r\nreturn db1200_card_inserted(sock);\r\ndefault:\r\nreturn db1000_card_inserted(sock);\r\n}\r\n}\r\nstatic inline void set_stschg(struct db1x_pcmcia_sock *sock, int en)\r\n{\r\nif (sock->stschg_irq != -1) {\r\nif (en)\r\nenable_irq(sock->stschg_irq);\r\nelse\r\ndisable_irq(sock->stschg_irq);\r\n}\r\n}\r\nstatic irqreturn_t db1000_pcmcia_cdirq(int irq, void *data)\r\n{\r\nstruct db1x_pcmcia_sock *sock = data;\r\npcmcia_parse_events(&sock->socket, SS_DETECT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t db1000_pcmcia_stschgirq(int irq, void *data)\r\n{\r\nstruct db1x_pcmcia_sock *sock = data;\r\npcmcia_parse_events(&sock->socket, SS_STSCHG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t db1200_pcmcia_cdirq(int irq, void *data)\r\n{\r\nstruct db1x_pcmcia_sock *sock = data;\r\nif (irq == sock->insert_irq) {\r\ndisable_irq_nosync(sock->insert_irq);\r\nenable_irq(sock->eject_irq);\r\n} else {\r\ndisable_irq_nosync(sock->eject_irq);\r\nenable_irq(sock->insert_irq);\r\n}\r\npcmcia_parse_events(&sock->socket, SS_DETECT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int db1x_pcmcia_setup_irqs(struct db1x_pcmcia_sock *sock)\r\n{\r\nint ret;\r\nif (sock->stschg_irq != -1) {\r\nret = request_irq(sock->stschg_irq, db1000_pcmcia_stschgirq,\r\n0, "pcmcia_stschg", sock);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (sock->board_type == BOARD_TYPE_DB1200) {\r\nret = request_irq(sock->insert_irq, db1200_pcmcia_cdirq,\r\nIRQF_DISABLED, "pcmcia_insert", sock);\r\nif (ret)\r\ngoto out1;\r\nret = request_irq(sock->eject_irq, db1200_pcmcia_cdirq,\r\nIRQF_DISABLED, "pcmcia_eject", sock);\r\nif (ret) {\r\nfree_irq(sock->insert_irq, sock);\r\ngoto out1;\r\n}\r\nif (db1200_card_inserted(sock))\r\nenable_irq(sock->eject_irq);\r\nelse\r\nenable_irq(sock->insert_irq);\r\n} else {\r\nirq_set_irq_type(sock->insert_irq, IRQ_TYPE_EDGE_BOTH);\r\nret = request_irq(sock->insert_irq, db1000_pcmcia_cdirq,\r\n0, "pcmcia_carddetect", sock);\r\nif (ret)\r\ngoto out1;\r\n}\r\nreturn 0;\r\nout1:\r\nif (sock->stschg_irq != -1)\r\nfree_irq(sock->stschg_irq, sock);\r\nreturn ret;\r\n}\r\nstatic void db1x_pcmcia_free_irqs(struct db1x_pcmcia_sock *sock)\r\n{\r\nif (sock->stschg_irq != -1)\r\nfree_irq(sock->stschg_irq, sock);\r\nfree_irq(sock->insert_irq, sock);\r\nif (sock->eject_irq != -1)\r\nfree_irq(sock->eject_irq, sock);\r\n}\r\nstatic int db1x_pcmcia_configure(struct pcmcia_socket *skt,\r\nstruct socket_state_t *state)\r\n{\r\nstruct db1x_pcmcia_sock *sock = to_db1x_socket(skt);\r\nunsigned short cr_clr, cr_set;\r\nunsigned int changed;\r\nint v, p, ret;\r\ncr_clr = (0xf << (sock->nr * 8));\r\ncr_set = 0;\r\nv = p = ret = 0;\r\nswitch (state->Vcc) {\r\ncase 50:\r\n++v;\r\ncase 33:\r\n++v;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "pcmcia%d unsupported Vcc %d\n",\r\nsock->nr, state->Vcc);\r\n}\r\nswitch (state->Vpp) {\r\ncase 12:\r\n++p;\r\ncase 33:\r\ncase 50:\r\n++p;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "pcmcia%d unsupported Vpp %d\n",\r\nsock->nr, state->Vpp);\r\n}\r\nif (((state->Vcc == 33) && (state->Vpp == 50)) ||\r\n((state->Vcc == 50) && (state->Vpp == 33))) {\r\nprintk(KERN_INFO "pcmcia%d bad Vcc/Vpp combo (%d %d)\n",\r\nsock->nr, state->Vcc, state->Vpp);\r\nv = p = 0;\r\nret = -EINVAL;\r\n}\r\ncr_set |= ((v << 2) | p) << (sock->nr * 8);\r\nchanged = state->flags ^ sock->old_flags;\r\nif (changed & SS_RESET) {\r\nif (state->flags & SS_RESET) {\r\nset_stschg(sock, 0);\r\ncr_clr |= (1 << (7 + (sock->nr * 8)));\r\ncr_clr |= (1 << (4 + (sock->nr * 8)));\r\n} else {\r\ncr_set |= 1 << (7 + (sock->nr * 8));\r\ncr_set |= 1 << (4 + (sock->nr * 8));\r\n}\r\n}\r\nbcsr_mod(BCSR_PCMCIA, cr_clr, cr_set);\r\nsock->old_flags = state->flags;\r\nif ((changed & SS_RESET) && !(state->flags & SS_RESET)) {\r\nmsleep(500);\r\nset_stschg(sock, 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int db1x_pcmcia_get_status(struct pcmcia_socket *skt,\r\nunsigned int *value)\r\n{\r\nstruct db1x_pcmcia_sock *sock = to_db1x_socket(skt);\r\nunsigned short cr, sr;\r\nunsigned int status;\r\nstatus = db1x_card_inserted(sock) ? SS_DETECT : 0;\r\ncr = bcsr_read(BCSR_PCMCIA);\r\nsr = bcsr_read(BCSR_STATUS);\r\nif (sock->board_type == BOARD_TYPE_PB1100)\r\nsr >>= 4;\r\nswitch (GET_VS(sr, sock->nr)) {\r\ncase 0:\r\ncase 2:\r\nstatus |= SS_3VCARD;\r\ncase 3:\r\nbreak;\r\ndefault:\r\nstatus |= SS_XVCARD;\r\n}\r\nstatus |= GET_VCC(cr, sock->nr) ? SS_POWERON : 0;\r\nstatus |= (GET_RESET(cr, sock->nr)) ? SS_READY : SS_RESET;\r\n*value = status;\r\nreturn 0;\r\n}\r\nstatic int db1x_pcmcia_sock_init(struct pcmcia_socket *skt)\r\n{\r\nreturn 0;\r\n}\r\nstatic int db1x_pcmcia_sock_suspend(struct pcmcia_socket *skt)\r\n{\r\nreturn 0;\r\n}\r\nstatic int au1x00_pcmcia_set_io_map(struct pcmcia_socket *skt,\r\nstruct pccard_io_map *map)\r\n{\r\nstruct db1x_pcmcia_sock *sock = to_db1x_socket(skt);\r\nmap->start = (u32)sock->virt_io;\r\nmap->stop = map->start + IO_MAP_SIZE;\r\nreturn 0;\r\n}\r\nstatic int au1x00_pcmcia_set_mem_map(struct pcmcia_socket *skt,\r\nstruct pccard_mem_map *map)\r\n{\r\nstruct db1x_pcmcia_sock *sock = to_db1x_socket(skt);\r\nif (map->flags & MAP_ATTRIB)\r\nmap->static_start = sock->phys_attr + map->card_start;\r\nelse\r\nmap->static_start = sock->phys_mem + map->card_start;\r\nreturn 0;\r\n}\r\nstatic int __devinit db1x_pcmcia_socket_probe(struct platform_device *pdev)\r\n{\r\nstruct db1x_pcmcia_sock *sock;\r\nstruct resource *r;\r\nint ret, bid;\r\nsock = kzalloc(sizeof(struct db1x_pcmcia_sock), GFP_KERNEL);\r\nif (!sock)\r\nreturn -ENOMEM;\r\nsock->nr = pdev->id;\r\nbid = BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI));\r\nswitch (bid) {\r\ncase BCSR_WHOAMI_PB1500:\r\ncase BCSR_WHOAMI_PB1500R2:\r\ncase BCSR_WHOAMI_PB1100:\r\nsock->board_type = BOARD_TYPE_PB1100;\r\nbreak;\r\ncase BCSR_WHOAMI_DB1000 ... BCSR_WHOAMI_PB1550_SDR:\r\nsock->board_type = BOARD_TYPE_DEFAULT;\r\nbreak;\r\ncase BCSR_WHOAMI_PB1200 ... BCSR_WHOAMI_DB1200:\r\nsock->board_type = BOARD_TYPE_DB1200;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "db1xxx-ss: unknown board %d!\n", bid);\r\nret = -ENODEV;\r\ngoto out0;\r\n};\r\nr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "card");\r\nsock->card_irq = r ? r->start : 0;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "insert");\r\nsock->insert_irq = r ? r->start : -1;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "stschg");\r\nsock->stschg_irq = r ? r->start : -1;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "eject");\r\nsock->eject_irq = r ? r->start : -1;\r\nret = -ENODEV;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pcmcia-attr");\r\nif (!r) {\r\nprintk(KERN_ERR "pcmcia%d has no 'pseudo-attr' resource!\n",\r\nsock->nr);\r\ngoto out0;\r\n}\r\nsock->phys_attr = r->start;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pcmcia-mem");\r\nif (!r) {\r\nprintk(KERN_ERR "pcmcia%d has no 'pseudo-mem' resource!\n",\r\nsock->nr);\r\ngoto out0;\r\n}\r\nsock->phys_mem = r->start;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pcmcia-io");\r\nif (!r) {\r\nprintk(KERN_ERR "pcmcia%d has no 'pseudo-io' resource!\n",\r\nsock->nr);\r\ngoto out0;\r\n}\r\nsock->phys_io = r->start;\r\nsock->virt_io = (void *)(ioremap(sock->phys_io, IO_MAP_SIZE) -\r\nmips_io_port_base);\r\nif (!sock->virt_io) {\r\nprintk(KERN_ERR "pcmcia%d: cannot remap IO area\n",\r\nsock->nr);\r\nret = -ENOMEM;\r\ngoto out0;\r\n}\r\nsock->socket.ops = &db1x_pcmcia_operations;\r\nsock->socket.owner = THIS_MODULE;\r\nsock->socket.pci_irq = sock->card_irq;\r\nsock->socket.features = SS_CAP_STATIC_MAP | SS_CAP_PCCARD;\r\nsock->socket.map_size = MEM_MAP_SIZE;\r\nsock->socket.io_offset = (unsigned long)sock->virt_io;\r\nsock->socket.dev.parent = &pdev->dev;\r\nsock->socket.resource_ops = &pccard_static_ops;\r\nplatform_set_drvdata(pdev, sock);\r\nret = db1x_pcmcia_setup_irqs(sock);\r\nif (ret) {\r\nprintk(KERN_ERR "pcmcia%d cannot setup interrupts\n",\r\nsock->nr);\r\ngoto out1;\r\n}\r\nset_stschg(sock, 0);\r\nret = pcmcia_register_socket(&sock->socket);\r\nif (ret) {\r\nprintk(KERN_ERR "pcmcia%d failed to register\n", sock->nr);\r\ngoto out2;\r\n}\r\nprintk(KERN_INFO "Alchemy Db/Pb1xxx pcmcia%d @ io/attr/mem %09llx"\r\n"(%p) %09llx %09llx card/insert/stschg/eject irqs @ %d "\r\n"%d %d %d\n", sock->nr, sock->phys_io, sock->virt_io,\r\nsock->phys_attr, sock->phys_mem, sock->card_irq,\r\nsock->insert_irq, sock->stschg_irq, sock->eject_irq);\r\nreturn 0;\r\nout2:\r\ndb1x_pcmcia_free_irqs(sock);\r\nout1:\r\niounmap((void *)(sock->virt_io + (u32)mips_io_port_base));\r\nout0:\r\nkfree(sock);\r\nreturn ret;\r\n}\r\nstatic int __devexit db1x_pcmcia_socket_remove(struct platform_device *pdev)\r\n{\r\nstruct db1x_pcmcia_sock *sock = platform_get_drvdata(pdev);\r\ndb1x_pcmcia_free_irqs(sock);\r\npcmcia_unregister_socket(&sock->socket);\r\niounmap((void *)(sock->virt_io + (u32)mips_io_port_base));\r\nkfree(sock);\r\nreturn 0;\r\n}\r\nint __init db1x_pcmcia_socket_load(void)\r\n{\r\nreturn platform_driver_register(&db1x_pcmcia_socket_driver);\r\n}\r\nvoid __exit db1x_pcmcia_socket_unload(void)\r\n{\r\nplatform_driver_unregister(&db1x_pcmcia_socket_driver);\r\n}
