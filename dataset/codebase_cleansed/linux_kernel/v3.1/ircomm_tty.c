static int __init ircomm_tty_init(void)\r\n{\r\ndriver = alloc_tty_driver(IRCOMM_TTY_PORTS);\r\nif (!driver)\r\nreturn -ENOMEM;\r\nircomm_tty = hashbin_new(HB_LOCK);\r\nif (ircomm_tty == NULL) {\r\nIRDA_ERROR("%s(), can't allocate hashbin!\n", __func__);\r\nput_tty_driver(driver);\r\nreturn -ENOMEM;\r\n}\r\ndriver->owner = THIS_MODULE;\r\ndriver->driver_name = "ircomm";\r\ndriver->name = "ircomm";\r\ndriver->major = IRCOMM_TTY_MAJOR;\r\ndriver->minor_start = IRCOMM_TTY_MINOR;\r\ndriver->type = TTY_DRIVER_TYPE_SERIAL;\r\ndriver->subtype = SERIAL_TYPE_NORMAL;\r\ndriver->init_termios = tty_std_termios;\r\ndriver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\ndriver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(driver, &ops);\r\nif (tty_register_driver(driver)) {\r\nIRDA_ERROR("%s(): Couldn't register serial driver\n",\r\n__func__);\r\nput_tty_driver(driver);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit __ircomm_tty_cleanup(struct ircomm_tty_cb *self)\r\n{\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nircomm_tty_shutdown(self);\r\nself->magic = 0;\r\nkfree(self);\r\n}\r\nstatic void __exit ircomm_tty_cleanup(void)\r\n{\r\nint ret;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nret = tty_unregister_driver(driver);\r\nif (ret) {\r\nIRDA_ERROR("%s(), failed to unregister driver\n",\r\n__func__);\r\nreturn;\r\n}\r\nhashbin_delete(ircomm_tty, (FREE_FUNC) __ircomm_tty_cleanup);\r\nput_tty_driver(driver);\r\n}\r\nstatic int ircomm_tty_startup(struct ircomm_tty_cb *self)\r\n{\r\nnotify_t notify;\r\nint ret = -ENODEV;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nif (test_and_set_bit(ASYNC_B_INITIALIZED, &self->flags)) {\r\nIRDA_DEBUG(2, "%s(), already open so break out!\n", __func__ );\r\nreturn 0;\r\n}\r\nirda_notify_init(&notify);\r\nnotify.data_indication = ircomm_tty_data_indication;\r\nnotify.udata_indication = ircomm_tty_control_indication;\r\nnotify.flow_indication = ircomm_tty_flow_indication;\r\nnotify.disconnect_indication = ircomm_tty_disconnect_indication;\r\nnotify.connect_confirm = ircomm_tty_connect_confirm;\r\nnotify.connect_indication = ircomm_tty_connect_indication;\r\nstrlcpy(notify.name, "ircomm_tty", sizeof(notify.name));\r\nnotify.instance = self;\r\nif (!self->ircomm) {\r\nself->ircomm = ircomm_open(&notify, self->service_type,\r\nself->line);\r\n}\r\nif (!self->ircomm)\r\ngoto err;\r\nself->slsap_sel = self->ircomm->slsap_sel;\r\nret = ircomm_tty_attach_cable(self);\r\nif (ret < 0) {\r\nIRDA_ERROR("%s(), error attaching cable!\n", __func__);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nclear_bit(ASYNC_B_INITIALIZED, &self->flags);\r\nreturn ret;\r\n}\r\nstatic int ircomm_tty_block_til_ready(struct ircomm_tty_cb *self,\r\nstruct file *filp)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint retval;\r\nint do_clocal = 0, extra_count = 0;\r\nunsigned long flags;\r\nstruct tty_struct *tty;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\ntty = self->tty;\r\nif (filp->f_flags & O_NONBLOCK || tty->flags & (1 << TTY_IO_ERROR)){\r\nself->flags |= ASYNC_NORMAL_ACTIVE;\r\nIRDA_DEBUG(1, "%s(), O_NONBLOCK requested!\n", __func__ );\r\nreturn 0;\r\n}\r\nif (tty->termios->c_cflag & CLOCAL) {\r\nIRDA_DEBUG(1, "%s(), doing CLOCAL!\n", __func__ );\r\ndo_clocal = 1;\r\n}\r\nretval = 0;\r\nadd_wait_queue(&self->open_wait, &wait);\r\nIRDA_DEBUG(2, "%s(%d):block_til_ready before block on %s open_count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, self->open_count );\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nif (!tty_hung_up_p(filp)) {\r\nextra_count = 1;\r\nself->open_count--;\r\n}\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nself->blocked_open++;\r\nwhile (1) {\r\nif (tty->termios->c_cflag & CBAUD) {\r\nself->settings.dte |= IRCOMM_RTS + IRCOMM_DTR;\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\n}\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nif (tty_hung_up_p(filp) ||\r\n!test_bit(ASYNC_B_INITIALIZED, &self->flags)) {\r\nretval = (self->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!test_bit(ASYNC_B_CLOSING, &self->flags) &&\r\n(do_clocal || (self->settings.dce & IRCOMM_CD)) &&\r\nself->state == IRCOMM_TTY_READY)\r\n{\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nIRDA_DEBUG(1, "%s(%d):block_til_ready blocking on %s open_count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, self->open_count );\r\nschedule();\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&self->open_wait, &wait);\r\nif (extra_count) {\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nself->open_count++;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\n}\r\nself->blocked_open--;\r\nIRDA_DEBUG(1, "%s(%d):block_til_ready after blocking on %s open_count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, self->open_count);\r\nif (!retval)\r\nself->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn retval;\r\n}\r\nstatic int ircomm_tty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct ircomm_tty_cb *self;\r\nunsigned int line;\r\nunsigned long flags;\r\nint ret;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nline = tty->index;\r\nif (line >= IRCOMM_TTY_PORTS)\r\nreturn -ENODEV;\r\nself = hashbin_lock_find(ircomm_tty, line, NULL);\r\nif (!self) {\r\nself = kzalloc(sizeof(struct ircomm_tty_cb), GFP_KERNEL);\r\nif (self == NULL) {\r\nIRDA_ERROR("%s(), kmalloc failed!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nself->magic = IRCOMM_TTY_MAGIC;\r\nself->flow = FLOW_STOP;\r\nself->line = line;\r\nINIT_WORK(&self->tqueue, ircomm_tty_do_softint);\r\nself->max_header_size = IRCOMM_TTY_HDR_UNINITIALISED;\r\nself->max_data_size = IRCOMM_TTY_DATA_UNINITIALISED;\r\nself->close_delay = 5*HZ/10;\r\nself->closing_wait = 30*HZ;\r\ninit_timer(&self->watchdog_timer);\r\ninit_waitqueue_head(&self->open_wait);\r\ninit_waitqueue_head(&self->close_wait);\r\nspin_lock_init(&self->spinlock);\r\ntty->termios->c_iflag = 0;\r\ntty->termios->c_oflag = 0;\r\nhashbin_insert(ircomm_tty, (irda_queue_t *) self, line, NULL);\r\n}\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nself->open_count++;\r\ntty->driver_data = self;\r\nself->tty = tty;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nIRDA_DEBUG(1, "%s(), %s%d, count = %d\n", __func__ , tty->driver->name,\r\nself->line, self->open_count);\r\nself->tty->low_latency = (self->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nif (tty_hung_up_p(filp) ||\r\ntest_bit(ASYNC_B_CLOSING, &self->flags)) {\r\nif (wait_event_interruptible(self->close_wait, !test_bit(ASYNC_B_CLOSING, &self->flags))) {\r\nIRDA_WARNING("%s - got signal while blocking on ASYNC_CLOSING!\n",\r\n__func__);\r\nreturn -ERESTARTSYS;\r\n}\r\n#ifdef SERIAL_DO_RESTART\r\nreturn (self->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS;\r\n#else\r\nreturn -EAGAIN;\r\n#endif\r\n}\r\nif (line < 0x10) {\r\nself->service_type = IRCOMM_3_WIRE | IRCOMM_9_WIRE;\r\nself->settings.service_type = IRCOMM_9_WIRE;\r\nself->settings.dce = IRCOMM_CTS | IRCOMM_CD | IRCOMM_DSR | IRCOMM_RI;\r\nIRDA_DEBUG(2, "%s(), IrCOMM device\n", __func__ );\r\n} else {\r\nIRDA_DEBUG(2, "%s(), IrLPT device\n", __func__ );\r\nself->service_type = IRCOMM_3_WIRE_RAW;\r\nself->settings.service_type = IRCOMM_3_WIRE_RAW;\r\n}\r\nret = ircomm_tty_startup(self);\r\nif (ret)\r\nreturn ret;\r\nret = ircomm_tty_block_til_ready(self, filp);\r\nif (ret) {\r\nIRDA_DEBUG(2,\r\n"%s(), returning after block_til_ready with %d\n", __func__ ,\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ircomm_tty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned long flags;\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nif (tty_hung_up_p(filp)) {\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nIRDA_DEBUG(0, "%s(), returning 1\n", __func__ );\r\nreturn;\r\n}\r\nif ((tty->count == 1) && (self->open_count != 1)) {\r\nIRDA_DEBUG(0, "%s(), bad serial port count; "\r\n"tty->count is 1, state->count is %d\n", __func__ ,\r\nself->open_count);\r\nself->open_count = 1;\r\n}\r\nif (--self->open_count < 0) {\r\nIRDA_ERROR("%s(), bad serial port count for ttys%d: %d\n",\r\n__func__, self->line, self->open_count);\r\nself->open_count = 0;\r\n}\r\nif (self->open_count) {\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nIRDA_DEBUG(0, "%s(), open count > 0\n", __func__ );\r\nreturn;\r\n}\r\nset_bit(ASYNC_B_CLOSING, &self->flags);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\ntty->closing = 1;\r\nif (self->closing_wait != ASYNC_CLOSING_WAIT_NONE)\r\ntty_wait_until_sent(tty, self->closing_wait);\r\nircomm_tty_shutdown(self);\r\ntty_driver_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\ntty->closing = 0;\r\nself->tty = NULL;\r\nif (self->blocked_open) {\r\nif (self->close_delay)\r\nschedule_timeout_interruptible(self->close_delay);\r\nwake_up_interruptible(&self->open_wait);\r\n}\r\nself->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);\r\nwake_up_interruptible(&self->close_wait);\r\n}\r\nstatic void ircomm_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nschedule_work(&self->tqueue);\r\n}\r\nstatic void ircomm_tty_do_softint(struct work_struct *work)\r\n{\r\nstruct ircomm_tty_cb *self =\r\ncontainer_of(work, struct ircomm_tty_cb, tqueue);\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nstruct sk_buff *skb, *ctrl_skb;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif (!self || self->magic != IRCOMM_TTY_MAGIC)\r\nreturn;\r\ntty = self->tty;\r\nif (!tty)\r\nreturn;\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nctrl_skb = self->ctrl_skb;\r\nself->ctrl_skb = NULL;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nif(ctrl_skb) {\r\nif(self->flow == FLOW_START)\r\nircomm_control_request(self->ircomm, ctrl_skb);\r\ndev_kfree_skb(ctrl_skb);\r\n}\r\nif (tty->hw_stopped)\r\nreturn;\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nskb = self->tx_skb;\r\nself->tx_skb = NULL;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nif (skb) {\r\nircomm_tty_do_event(self, IRCOMM_TTY_DATA_REQUEST, skb, NULL);\r\ndev_kfree_skb(skb);\r\n}\r\ntty_wakeup(tty);\r\n}\r\nstatic int ircomm_tty_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nint tailroom = 0;\r\nint len = 0;\r\nint size;\r\nIRDA_DEBUG(2, "%s(), count=%d, hw_stopped=%d\n", __func__ , count,\r\ntty->hw_stopped);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nif (self->max_header_size == IRCOMM_TTY_HDR_UNINITIALISED) {\r\nIRDA_DEBUG(1, "%s() : not initialised\n", __func__);\r\n#ifdef IRCOMM_NO_TX_BEFORE_INIT\r\nreturn 0;\r\n#endif\r\n}\r\nif (count < 1)\r\nreturn 0;\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nskb = self->tx_skb;\r\nwhile (count) {\r\nsize = count;\r\nif (size > self->max_data_size)\r\nsize = self->max_data_size;\r\nif (skb) {\r\nif ((tailroom = (self->tx_data_size - skb->len)) > 0) {\r\nif (size > tailroom)\r\nsize = tailroom;\r\n} else {\r\nbreak;\r\n}\r\n} else {\r\nskb = alloc_skb(self->max_data_size+\r\nself->max_header_size,\r\nGFP_ATOMIC);\r\nif (!skb) {\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nreturn -ENOBUFS;\r\n}\r\nskb_reserve(skb, self->max_header_size);\r\nself->tx_skb = skb;\r\nself->tx_data_size = self->max_data_size;\r\n}\r\nmemcpy(skb_put(skb,size), buf + len, size);\r\ncount -= size;\r\nlen += size;\r\n}\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nschedule_work(&self->tqueue);\r\nreturn len;\r\n}\r\nstatic int ircomm_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned long flags;\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\n#ifdef IRCOMM_NO_TX_BEFORE_INIT\r\nif (self->max_header_size == IRCOMM_TTY_HDR_UNINITIALISED)\r\nreturn 0;\r\n#endif\r\nif (tty->hw_stopped)\r\nret = 0;\r\nelse {\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nif (self->tx_skb)\r\nret = self->tx_data_size - self->tx_skb->len;\r\nelse\r\nret = self->max_data_size;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\n}\r\nIRDA_DEBUG(2, "%s(), ret=%d\n", __func__ , ret);\r\nreturn ret;\r\n}\r\nstatic void ircomm_tty_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned long orig_jiffies, poll_time;\r\nunsigned long flags;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\norig_jiffies = jiffies;\r\npoll_time = IRDA_MIN(timeout, msecs_to_jiffies(200));\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nwhile (self->tx_skb && self->tx_skb->len) {\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nschedule_timeout_interruptible(poll_time);\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\ncurrent->state = TASK_RUNNING;\r\n}\r\nstatic void ircomm_tty_throttle(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nif (I_IXOFF(tty))\r\nircomm_tty_send_xchar(tty, STOP_CHAR(tty));\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\nself->settings.dte &= ~IRCOMM_RTS;\r\nself->settings.dte |= IRCOMM_DELTA_RTS;\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\n}\r\nircomm_flow_request(self->ircomm, FLOW_STOP);\r\n}\r\nstatic void ircomm_tty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nif (I_IXOFF(tty)) {\r\nircomm_tty_send_xchar(tty, START_CHAR(tty));\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\nself->settings.dte |= (IRCOMM_RTS|IRCOMM_DELTA_RTS);\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\nIRDA_DEBUG(1, "%s(), FLOW_START\n", __func__ );\r\n}\r\nircomm_flow_request(self->ircomm, FLOW_START);\r\n}\r\nstatic int ircomm_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned long flags;\r\nint len = 0;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nif (self->tx_skb)\r\nlen = self->tx_skb->len;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nreturn len;\r\n}\r\nstatic void ircomm_tty_shutdown(struct ircomm_tty_cb *self)\r\n{\r\nunsigned long flags;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nif (!test_and_clear_bit(ASYNC_B_INITIALIZED, &self->flags))\r\nreturn;\r\nircomm_tty_detach_cable(self);\r\nspin_lock_irqsave(&self->spinlock, flags);\r\ndel_timer(&self->watchdog_timer);\r\nif (self->ctrl_skb) {\r\ndev_kfree_skb(self->ctrl_skb);\r\nself->ctrl_skb = NULL;\r\n}\r\nif (self->tx_skb) {\r\ndev_kfree_skb(self->tx_skb);\r\nself->tx_skb = NULL;\r\n}\r\nif (self->ircomm) {\r\nircomm_close(self->ircomm);\r\nself->ircomm = NULL;\r\n}\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\n}\r\nstatic void ircomm_tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned long flags;\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nircomm_tty_shutdown(self);\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nself->flags &= ~ASYNC_NORMAL_ACTIVE;\r\nself->tty = NULL;\r\nself->open_count = 0;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nwake_up_interruptible(&self->open_wait);\r\n}\r\nstatic void ircomm_tty_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nIRDA_DEBUG(0, "%s(), not impl\n", __func__ );\r\n}\r\nvoid ircomm_tty_start(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nircomm_flow_request(self->ircomm, FLOW_START);\r\n}\r\nstatic void ircomm_tty_stop(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nircomm_flow_request(self->ircomm, FLOW_STOP);\r\n}\r\nvoid ircomm_tty_check_modem_status(struct ircomm_tty_cb *self)\r\n{\r\nstruct tty_struct *tty;\r\nint status;\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\ntty = self->tty;\r\nstatus = self->settings.dce;\r\nif (status & IRCOMM_DCE_DELTA_ANY) {\r\n}\r\nif ((self->flags & ASYNC_CHECK_CD) && (status & IRCOMM_DELTA_CD)) {\r\nIRDA_DEBUG(2,\r\n"%s(), ircomm%d CD now %s...\n", __func__ , self->line,\r\n(status & IRCOMM_CD) ? "on" : "off");\r\nif (status & IRCOMM_CD) {\r\nwake_up_interruptible(&self->open_wait);\r\n} else {\r\nIRDA_DEBUG(2,\r\n"%s(), Doing serial hangup..\n", __func__ );\r\nif (tty)\r\ntty_hangup(tty);\r\nreturn;\r\n}\r\n}\r\nif (self->flags & ASYNC_CTS_FLOW) {\r\nif (tty->hw_stopped) {\r\nif (status & IRCOMM_CTS) {\r\nIRDA_DEBUG(2,\r\n"%s(), CTS tx start...\n", __func__ );\r\ntty->hw_stopped = 0;\r\nwake_up_interruptible(&self->open_wait);\r\nschedule_work(&self->tqueue);\r\nreturn;\r\n}\r\n} else {\r\nif (!(status & IRCOMM_CTS)) {\r\nIRDA_DEBUG(2,\r\n"%s(), CTS tx stop...\n", __func__ );\r\ntty->hw_stopped = 1;\r\n}\r\n}\r\n}\r\n}\r\nstatic int ircomm_tty_data_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) instance;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nif (!self->tty) {\r\nIRDA_DEBUG(0, "%s(), no tty!\n", __func__ );\r\nreturn 0;\r\n}\r\nif (self->tty->hw_stopped && (self->flow == FLOW_START)) {\r\nIRDA_DEBUG(0, "%s(), polling for line settings!\n", __func__ );\r\nircomm_param_request(self, IRCOMM_POLL, TRUE);\r\nircomm_tty_send_initial_parameters(self);\r\nircomm_tty_link_established(self);\r\n}\r\ntty_insert_flip_string(self->tty, skb->data, skb->len);\r\ntty_flip_buffer_push(self->tty);\r\nreturn 0;\r\n}\r\nstatic int ircomm_tty_control_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) instance;\r\nint clen;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nclen = skb->data[0];\r\nirda_param_extract_all(self, skb->data+1, IRDA_MIN(skb->len-1, clen),\r\n&ircomm_param_info);\r\nreturn 0;\r\n}\r\nstatic void ircomm_tty_flow_indication(void *instance, void *sap,\r\nLOCAL_FLOW cmd)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) instance;\r\nstruct tty_struct *tty;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\ntty = self->tty;\r\nswitch (cmd) {\r\ncase FLOW_START:\r\nIRDA_DEBUG(2, "%s(), hw start!\n", __func__ );\r\ntty->hw_stopped = 0;\r\nschedule_work(&self->tqueue);\r\nbreak;\r\ndefault:\r\ncase FLOW_STOP:\r\nIRDA_DEBUG(2, "%s(), hw stopped!\n", __func__ );\r\ntty->hw_stopped = 1;\r\nbreak;\r\n}\r\nself->flow = cmd;\r\n}\r\nstatic void ircomm_tty_line_info(struct ircomm_tty_cb *self, struct seq_file *m)\r\n{\r\nchar sep;\r\nseq_printf(m, "State: %s\n", ircomm_tty_state[self->state]);\r\nseq_puts(m, "Service type: ");\r\nif (self->service_type & IRCOMM_9_WIRE)\r\nseq_puts(m, "9_WIRE");\r\nelse if (self->service_type & IRCOMM_3_WIRE)\r\nseq_puts(m, "3_WIRE");\r\nelse if (self->service_type & IRCOMM_3_WIRE_RAW)\r\nseq_puts(m, "3_WIRE_RAW");\r\nelse\r\nseq_puts(m, "No common service type!\n");\r\nseq_putc(m, '\n');\r\nseq_printf(m, "Port name: %s\n", self->settings.port_name);\r\nseq_printf(m, "DTE status:");\r\nsep = ' ';\r\nif (self->settings.dte & IRCOMM_RTS) {\r\nseq_printf(m, "%cRTS", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.dte & IRCOMM_DTR) {\r\nseq_printf(m, "%cDTR", sep);\r\nsep = '|';\r\n}\r\nseq_putc(m, '\n');\r\nseq_puts(m, "DCE status:");\r\nsep = ' ';\r\nif (self->settings.dce & IRCOMM_CTS) {\r\nseq_printf(m, "%cCTS", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.dce & IRCOMM_DSR) {\r\nseq_printf(m, "%cDSR", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.dce & IRCOMM_CD) {\r\nseq_printf(m, "%cCD", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.dce & IRCOMM_RI) {\r\nseq_printf(m, "%cRI", sep);\r\nsep = '|';\r\n}\r\nseq_putc(m, '\n');\r\nseq_puts(m, "Configuration: ");\r\nif (!self->settings.null_modem)\r\nseq_puts(m, "DTE <-> DCE\n");\r\nelse\r\nseq_puts(m, "DTE <-> DTE (null modem emulation)\n");\r\nseq_printf(m, "Data rate: %d\n", self->settings.data_rate);\r\nseq_puts(m, "Flow control:");\r\nsep = ' ';\r\nif (self->settings.flow_control & IRCOMM_XON_XOFF_IN) {\r\nseq_printf(m, "%cXON_XOFF_IN", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.flow_control & IRCOMM_XON_XOFF_OUT) {\r\nseq_printf(m, "%cXON_XOFF_OUT", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.flow_control & IRCOMM_RTS_CTS_IN) {\r\nseq_printf(m, "%cRTS_CTS_IN", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.flow_control & IRCOMM_RTS_CTS_OUT) {\r\nseq_printf(m, "%cRTS_CTS_OUT", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.flow_control & IRCOMM_DSR_DTR_IN) {\r\nseq_printf(m, "%cDSR_DTR_IN", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.flow_control & IRCOMM_DSR_DTR_OUT) {\r\nseq_printf(m, "%cDSR_DTR_OUT", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.flow_control & IRCOMM_ENQ_ACK_IN) {\r\nseq_printf(m, "%cENQ_ACK_IN", sep);\r\nsep = '|';\r\n}\r\nif (self->settings.flow_control & IRCOMM_ENQ_ACK_OUT) {\r\nseq_printf(m, "%cENQ_ACK_OUT", sep);\r\nsep = '|';\r\n}\r\nseq_putc(m, '\n');\r\nseq_puts(m, "Flags:");\r\nsep = ' ';\r\nif (self->flags & ASYNC_CTS_FLOW) {\r\nseq_printf(m, "%cASYNC_CTS_FLOW", sep);\r\nsep = '|';\r\n}\r\nif (self->flags & ASYNC_CHECK_CD) {\r\nseq_printf(m, "%cASYNC_CHECK_CD", sep);\r\nsep = '|';\r\n}\r\nif (self->flags & ASYNC_INITIALIZED) {\r\nseq_printf(m, "%cASYNC_INITIALIZED", sep);\r\nsep = '|';\r\n}\r\nif (self->flags & ASYNC_LOW_LATENCY) {\r\nseq_printf(m, "%cASYNC_LOW_LATENCY", sep);\r\nsep = '|';\r\n}\r\nif (self->flags & ASYNC_CLOSING) {\r\nseq_printf(m, "%cASYNC_CLOSING", sep);\r\nsep = '|';\r\n}\r\nif (self->flags & ASYNC_NORMAL_ACTIVE) {\r\nseq_printf(m, "%cASYNC_NORMAL_ACTIVE", sep);\r\nsep = '|';\r\n}\r\nseq_putc(m, '\n');\r\nseq_printf(m, "Role: %s\n", self->client ? "client" : "server");\r\nseq_printf(m, "Open count: %d\n", self->open_count);\r\nseq_printf(m, "Max data size: %d\n", self->max_data_size);\r\nseq_printf(m, "Max header size: %d\n", self->max_header_size);\r\nif (self->tty)\r\nseq_printf(m, "Hardware: %s\n",\r\nself->tty->hw_stopped ? "Stopped" : "Running");\r\n}\r\nstatic int ircomm_tty_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct ircomm_tty_cb *self;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ircomm_tty->hb_spinlock, flags);\r\nself = (struct ircomm_tty_cb *) hashbin_get_first(ircomm_tty);\r\nwhile (self != NULL) {\r\nif (self->magic != IRCOMM_TTY_MAGIC)\r\nbreak;\r\nircomm_tty_line_info(self, m);\r\nself = (struct ircomm_tty_cb *) hashbin_get_next(ircomm_tty);\r\n}\r\nspin_unlock_irqrestore(&ircomm_tty->hb_spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int ircomm_tty_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ircomm_tty_proc_show, NULL);\r\n}
