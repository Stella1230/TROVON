static inline struct CHIPSTATE *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct CHIPSTATE, sd);\r\n}\r\nstatic int chip_write(struct CHIPSTATE *chip, int subaddr, int val)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nunsigned char buffer[2];\r\nif (subaddr < 0) {\r\nv4l2_dbg(1, debug, sd, "chip_write: 0x%x\n", val);\r\nchip->shadow.bytes[1] = val;\r\nbuffer[0] = val;\r\nif (1 != i2c_master_send(c, buffer, 1)) {\r\nv4l2_warn(sd, "I/O error (write 0x%x)\n", val);\r\nreturn -1;\r\n}\r\n} else {\r\nif (subaddr + 1 >= ARRAY_SIZE(chip->shadow.bytes)) {\r\nv4l2_info(sd,\r\n"Tried to access a non-existent register: %d\n",\r\nsubaddr);\r\nreturn -EINVAL;\r\n}\r\nv4l2_dbg(1, debug, sd, "chip_write: reg%d=0x%x\n",\r\nsubaddr, val);\r\nchip->shadow.bytes[subaddr+1] = val;\r\nbuffer[0] = subaddr;\r\nbuffer[1] = val;\r\nif (2 != i2c_master_send(c, buffer, 2)) {\r\nv4l2_warn(sd, "I/O error (write reg%d=0x%x)\n",\r\nsubaddr, val);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int chip_write_masked(struct CHIPSTATE *chip,\r\nint subaddr, int val, int mask)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nif (mask != 0) {\r\nif (subaddr < 0) {\r\nval = (chip->shadow.bytes[1] & ~mask) | (val & mask);\r\n} else {\r\nif (subaddr + 1 >= ARRAY_SIZE(chip->shadow.bytes)) {\r\nv4l2_info(sd,\r\n"Tried to access a non-existent register: %d\n",\r\nsubaddr);\r\nreturn -EINVAL;\r\n}\r\nval = (chip->shadow.bytes[subaddr+1] & ~mask) | (val & mask);\r\n}\r\n}\r\nreturn chip_write(chip, subaddr, val);\r\n}\r\nstatic int chip_read(struct CHIPSTATE *chip)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nunsigned char buffer;\r\nif (1 != i2c_master_recv(c, &buffer, 1)) {\r\nv4l2_warn(sd, "I/O error (read)\n");\r\nreturn -1;\r\n}\r\nv4l2_dbg(1, debug, sd, "chip_read: 0x%x\n", buffer);\r\nreturn buffer;\r\n}\r\nstatic int chip_read2(struct CHIPSTATE *chip, int subaddr)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nunsigned char write[1];\r\nunsigned char read[1];\r\nstruct i2c_msg msgs[2] = {\r\n{ c->addr, 0, 1, write },\r\n{ c->addr, I2C_M_RD, 1, read }\r\n};\r\nwrite[0] = subaddr;\r\nif (2 != i2c_transfer(c->adapter, msgs, 2)) {\r\nv4l2_warn(sd, "I/O error (read2)\n");\r\nreturn -1;\r\n}\r\nv4l2_dbg(1, debug, sd, "chip_read2: reg%d=0x%x\n",\r\nsubaddr, read[0]);\r\nreturn read[0];\r\n}\r\nstatic int chip_cmd(struct CHIPSTATE *chip, char *name, audiocmd *cmd)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nint i;\r\nif (0 == cmd->count)\r\nreturn 0;\r\nif (cmd->count + cmd->bytes[0] - 1 >= ARRAY_SIZE(chip->shadow.bytes)) {\r\nv4l2_info(sd,\r\n"Tried to access a non-existent register range: %d to %d\n",\r\ncmd->bytes[0] + 1, cmd->bytes[0] + cmd->count - 1);\r\nreturn -EINVAL;\r\n}\r\nv4l2_dbg(1, debug, sd, "chip_cmd(%s): reg=%d, data:",\r\nname, cmd->bytes[0]);\r\nfor (i = 1; i < cmd->count; i++) {\r\nif (debug)\r\nprintk(KERN_CONT " 0x%x", cmd->bytes[i]);\r\nchip->shadow.bytes[i+cmd->bytes[0]] = cmd->bytes[i];\r\n}\r\nif (debug)\r\nprintk(KERN_CONT "\n");\r\nif (cmd->count != i2c_master_send(c, cmd->bytes, cmd->count)) {\r\nv4l2_warn(sd, "I/O error (%s)\n", name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void chip_thread_wake(unsigned long data)\r\n{\r\nstruct CHIPSTATE *chip = (struct CHIPSTATE*)data;\r\nwake_up_process(chip->thread);\r\n}\r\nstatic int chip_thread(void *data)\r\n{\r\nstruct CHIPSTATE *chip = data;\r\nstruct CHIPDESC *desc = chip->desc;\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nint mode;\r\nv4l2_dbg(1, debug, sd, "thread started\n");\r\nset_freezable();\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!kthread_should_stop())\r\nschedule();\r\nset_current_state(TASK_RUNNING);\r\ntry_to_freeze();\r\nif (kthread_should_stop())\r\nbreak;\r\nv4l2_dbg(1, debug, sd, "thread wakeup\n");\r\nif (chip->radio || chip->mode != 0)\r\ncontinue;\r\nmode = desc->getmode(chip);\r\nif (mode == chip->prevmode)\r\ncontinue;\r\nv4l2_dbg(1, debug, sd, "thread checkmode\n");\r\nchip->prevmode = mode;\r\nif (mode & V4L2_TUNER_MODE_STEREO)\r\ndesc->setmode(chip, V4L2_TUNER_MODE_STEREO);\r\nif (mode & V4L2_TUNER_MODE_LANG1_LANG2)\r\ndesc->setmode(chip, V4L2_TUNER_MODE_STEREO);\r\nelse if (mode & V4L2_TUNER_MODE_LANG1)\r\ndesc->setmode(chip, V4L2_TUNER_MODE_LANG1);\r\nelse if (mode & V4L2_TUNER_MODE_LANG2)\r\ndesc->setmode(chip, V4L2_TUNER_MODE_LANG2);\r\nelse\r\ndesc->setmode(chip, V4L2_TUNER_MODE_MONO);\r\nmod_timer(&chip->wt, jiffies+msecs_to_jiffies(2000));\r\n}\r\nv4l2_dbg(1, debug, sd, "thread exiting\n");\r\nreturn 0;\r\n}\r\nstatic int tda9840_getmode(struct CHIPSTATE *chip)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nint val, mode;\r\nval = chip_read(chip);\r\nmode = V4L2_TUNER_MODE_MONO;\r\nif (val & TDA9840_DS_DUAL)\r\nmode |= V4L2_TUNER_MODE_LANG1 | V4L2_TUNER_MODE_LANG2;\r\nif (val & TDA9840_ST_STEREO)\r\nmode |= V4L2_TUNER_MODE_STEREO;\r\nv4l2_dbg(1, debug, sd, "tda9840_getmode(): raw chip read: %d, return: %d\n",\r\nval, mode);\r\nreturn mode;\r\n}\r\nstatic void tda9840_setmode(struct CHIPSTATE *chip, int mode)\r\n{\r\nint update = 1;\r\nint t = chip->shadow.bytes[TDA9840_SW + 1] & ~0x7e;\r\nswitch (mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nt |= TDA9840_MONO;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nt |= TDA9840_STEREO;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nt |= TDA9840_DUALA;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nt |= TDA9840_DUALB;\r\nbreak;\r\ndefault:\r\nupdate = 0;\r\n}\r\nif (update)\r\nchip_write(chip, TDA9840_SW, t);\r\n}\r\nstatic int tda9840_checkit(struct CHIPSTATE *chip)\r\n{\r\nint rc;\r\nrc = chip_read(chip);\r\nreturn ((rc & 0x1f) == 0) ? 1 : 0;\r\n}\r\nstatic int tda9855_volume(int val) { return val/0x2e8+0x27; }\r\nstatic int tda9855_bass(int val) { return val/0xccc+0x06; }\r\nstatic int tda9855_treble(int val) { return (val/0x1c71+0x3)<<1; }\r\nstatic int tda985x_getmode(struct CHIPSTATE *chip)\r\n{\r\nint mode;\r\nmode = ((TDA985x_STP | TDA985x_SAPP) &\r\nchip_read(chip)) >> 4;\r\nreturn mode | V4L2_TUNER_MODE_MONO;\r\n}\r\nstatic void tda985x_setmode(struct CHIPSTATE *chip, int mode)\r\n{\r\nint update = 1;\r\nint c6 = chip->shadow.bytes[TDA985x_C6+1] & 0x3f;\r\nswitch (mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nc6 |= TDA985x_MONO;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nc6 |= TDA985x_STEREO;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nc6 |= TDA985x_SAP;\r\nbreak;\r\ndefault:\r\nupdate = 0;\r\n}\r\nif (update)\r\nchip_write(chip,TDA985x_C6,c6);\r\n}\r\nstatic int tda9873_getmode(struct CHIPSTATE *chip)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nint val,mode;\r\nval = chip_read(chip);\r\nmode = V4L2_TUNER_MODE_MONO;\r\nif (val & TDA9873_STEREO)\r\nmode |= V4L2_TUNER_MODE_STEREO;\r\nif (val & TDA9873_DUAL)\r\nmode |= V4L2_TUNER_MODE_LANG1 | V4L2_TUNER_MODE_LANG2;\r\nv4l2_dbg(1, debug, sd, "tda9873_getmode(): raw chip read: %d, return: %d\n",\r\nval, mode);\r\nreturn mode;\r\n}\r\nstatic void tda9873_setmode(struct CHIPSTATE *chip, int mode)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nint sw_data = chip->shadow.bytes[TDA9873_SW+1] & ~ TDA9873_TR_MASK;\r\nif ((sw_data & TDA9873_INP_MASK) != TDA9873_INTERNAL) {\r\nv4l2_dbg(1, debug, sd, "tda9873_setmode(): external input\n");\r\nreturn;\r\n}\r\nv4l2_dbg(1, debug, sd, "tda9873_setmode(): chip->shadow.bytes[%d] = %d\n", TDA9873_SW+1, chip->shadow.bytes[TDA9873_SW+1]);\r\nv4l2_dbg(1, debug, sd, "tda9873_setmode(): sw_data = %d\n", sw_data);\r\nswitch (mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nsw_data |= TDA9873_TR_MONO;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nsw_data |= TDA9873_TR_STEREO;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nsw_data |= TDA9873_TR_DUALA;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nsw_data |= TDA9873_TR_DUALB;\r\nbreak;\r\ndefault:\r\nchip->mode = 0;\r\nreturn;\r\n}\r\nchip_write(chip, TDA9873_SW, sw_data);\r\nv4l2_dbg(1, debug, sd, "tda9873_setmode(): req. mode %d; chip_write: %d\n",\r\nmode, sw_data);\r\n}\r\nstatic int tda9873_checkit(struct CHIPSTATE *chip)\r\n{\r\nint rc;\r\nif (-1 == (rc = chip_read2(chip,254)))\r\nreturn 0;\r\nreturn (rc & ~0x1f) == 0x80;\r\n}\r\nstatic int tda9874a_setup(struct CHIPSTATE *chip)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nchip_write(chip, TDA9874A_AGCGR, 0x00);\r\nchip_write(chip, TDA9874A_GCONR, tda9874a_GCONR);\r\nchip_write(chip, TDA9874A_MSR, (tda9874a_mode) ? 0x03:0x02);\r\nif(tda9874a_dic == 0x11) {\r\nchip_write(chip, TDA9874A_FMMR, 0x80);\r\n} else {\r\nchip_cmd(chip,"tda9874_modelist",&tda9874a_modelist[tda9874a_STD].cmd);\r\nchip_write(chip, TDA9874A_FMMR, 0x00);\r\n}\r\nchip_write(chip, TDA9874A_C1OLAR, 0x00);\r\nchip_write(chip, TDA9874A_C2OLAR, 0x00);\r\nchip_write(chip, TDA9874A_NCONR, tda9874a_NCONR);\r\nchip_write(chip, TDA9874A_NOLAR, 0x00);\r\nchip_write(chip, TDA9874A_NLELR, 0x14);\r\nchip_write(chip, TDA9874A_NUELR, 0x50);\r\nif(tda9874a_dic == 0x11) {\r\nchip_write(chip, TDA9874A_AMCONR, 0xf9);\r\nchip_write(chip, TDA9874A_SDACOSR, (tda9874a_mode) ? 0x81:0x80);\r\nchip_write(chip, TDA9874A_AOSR, 0x80);\r\nchip_write(chip, TDA9874A_MDACOSR, (tda9874a_mode) ? 0x82:0x80);\r\nchip_write(chip, TDA9874A_ESP, tda9874a_ESP);\r\n} else {\r\nchip_write(chip, TDA9874A_AMCONR, 0xfb);\r\nchip_write(chip, TDA9874A_SDACOSR, (tda9874a_mode) ? 0x81:0x80);\r\nchip_write(chip, TDA9874A_AOSR, 0x00);\r\n}\r\nv4l2_dbg(1, debug, sd, "tda9874a_setup(): %s [0x%02X].\n",\r\ntda9874a_modelist[tda9874a_STD].name,tda9874a_STD);\r\nreturn 1;\r\n}\r\nstatic int tda9874a_getmode(struct CHIPSTATE *chip)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nint dsr,nsr,mode;\r\nint necr;\r\nmode = V4L2_TUNER_MODE_MONO;\r\nif(-1 == (dsr = chip_read2(chip,TDA9874A_DSR)))\r\nreturn mode;\r\nif(-1 == (nsr = chip_read2(chip,TDA9874A_NSR)))\r\nreturn mode;\r\nif(-1 == (necr = chip_read2(chip,TDA9874A_NECR)))\r\nreturn mode;\r\nchip->shadow.bytes[MAXREGS-2] = dsr;\r\nchip->shadow.bytes[MAXREGS-1] = nsr;\r\nif(tda9874a_mode) {\r\nif(nsr & 0x02)\r\nmode |= V4L2_TUNER_MODE_STEREO;\r\nif(nsr & 0x01)\r\nmode |= V4L2_TUNER_MODE_LANG1 | V4L2_TUNER_MODE_LANG2;\r\n} else {\r\nif(dsr & 0x02)\r\nmode |= V4L2_TUNER_MODE_STEREO;\r\nif(dsr & 0x04)\r\nmode |= V4L2_TUNER_MODE_LANG1 | V4L2_TUNER_MODE_LANG2;\r\n}\r\nv4l2_dbg(1, debug, sd, "tda9874a_getmode(): DSR=0x%X, NSR=0x%X, NECR=0x%X, return: %d.\n",\r\ndsr, nsr, necr, mode);\r\nreturn mode;\r\n}\r\nstatic void tda9874a_setmode(struct CHIPSTATE *chip, int mode)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nif (tda9874a_mode) {\r\nif(chip->shadow.bytes[MAXREGS-2] & 0x20)\r\ntda9874a_NCONR &= 0xfe;\r\nelse\r\ntda9874a_NCONR |= 0x01;\r\nchip_write(chip, TDA9874A_NCONR, tda9874a_NCONR);\r\n}\r\nif(tda9874a_dic == 0x11) {\r\nint aosr = 0x80;\r\nint mdacosr = (tda9874a_mode) ? 0x82:0x80;\r\nswitch(mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\ncase V4L2_TUNER_MODE_STEREO:\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\naosr = 0x80;\r\nmdacosr = (tda9874a_mode) ? 0x82:0x80;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\naosr = 0xa0;\r\nmdacosr = (tda9874a_mode) ? 0x83:0x81;\r\nbreak;\r\ndefault:\r\nchip->mode = 0;\r\nreturn;\r\n}\r\nchip_write(chip, TDA9874A_AOSR, aosr);\r\nchip_write(chip, TDA9874A_MDACOSR, mdacosr);\r\nv4l2_dbg(1, debug, sd, "tda9874a_setmode(): req. mode %d; AOSR=0x%X, MDACOSR=0x%X.\n",\r\nmode, aosr, mdacosr);\r\n} else {\r\nint fmmr,aosr;\r\nswitch(mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nfmmr = 0x00;\r\naosr = 0x10;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nif(tda9874a_mode) {\r\nfmmr = 0x00;\r\naosr = 0x00;\r\n} else {\r\nfmmr = (tda9874a_ESP == 1) ? 0x05 : 0x04;\r\naosr = 0x00;\r\n}\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nfmmr = 0x02;\r\naosr = 0x10;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nfmmr = 0x02;\r\naosr = 0x20;\r\nbreak;\r\ndefault:\r\nchip->mode = 0;\r\nreturn;\r\n}\r\nchip_write(chip, TDA9874A_FMMR, fmmr);\r\nchip_write(chip, TDA9874A_AOSR, aosr);\r\nv4l2_dbg(1, debug, sd, "tda9874a_setmode(): req. mode %d; FMMR=0x%X, AOSR=0x%X.\n",\r\nmode, fmmr, aosr);\r\n}\r\n}\r\nstatic int tda9874a_checkit(struct CHIPSTATE *chip)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nint dic,sic;\r\nif(-1 == (dic = chip_read2(chip,TDA9874A_DIC)))\r\nreturn 0;\r\nif(-1 == (sic = chip_read2(chip,TDA9874A_SIC)))\r\nreturn 0;\r\nv4l2_dbg(1, debug, sd, "tda9874a_checkit(): DIC=0x%X, SIC=0x%X.\n", dic, sic);\r\nif((dic == 0x11)||(dic == 0x07)) {\r\nv4l2_info(sd, "found tda9874%s.\n", (dic == 0x11) ? "a" : "h");\r\ntda9874a_dic = dic;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda9874a_initialize(struct CHIPSTATE *chip)\r\n{\r\nif (tda9874a_SIF > 2)\r\ntda9874a_SIF = 1;\r\nif (tda9874a_STD >= ARRAY_SIZE(tda9874a_modelist))\r\ntda9874a_STD = 0;\r\nif(tda9874a_AMSEL > 1)\r\ntda9874a_AMSEL = 0;\r\nif(tda9874a_SIF == 1)\r\ntda9874a_GCONR = 0xc0;\r\nelse\r\ntda9874a_GCONR = 0xc1;\r\ntda9874a_ESP = tda9874a_STD;\r\ntda9874a_mode = (tda9874a_STD < 5) ? 0 : 1;\r\nif(tda9874a_AMSEL == 0)\r\ntda9874a_NCONR = 0x01;\r\nelse\r\ntda9874a_NCONR = 0x05;\r\ntda9874a_setup(chip);\r\nreturn 0;\r\n}\r\nstatic int tda9875_initialize(struct CHIPSTATE *chip)\r\n{\r\nchip_write(chip, TDA9875_CFG, 0xd0);\r\nchip_write(chip, TDA9875_MSR, 0x03);\r\nchip_write(chip, TDA9875_C1MSB, 0x00);\r\nchip_write(chip, TDA9875_C1MIB, 0x00);\r\nchip_write(chip, TDA9875_C1LSB, 0x00);\r\nchip_write(chip, TDA9875_C2MSB, 0x00);\r\nchip_write(chip, TDA9875_C2MIB, 0x00);\r\nchip_write(chip, TDA9875_C2LSB, 0x00);\r\nchip_write(chip, TDA9875_DCR, 0x00);\r\nchip_write(chip, TDA9875_DEEM, 0x44);\r\nchip_write(chip, TDA9875_FMAT, 0x00);\r\nchip_write(chip, TDA9875_SC1, 0x00);\r\nchip_write(chip, TDA9875_SC2, 0x01);\r\nchip_write(chip, TDA9875_CH1V, 0x10);\r\nchip_write(chip, TDA9875_CH2V, 0x10);\r\nchip_write(chip, TDA9875_DACOS, 0x02);\r\nchip_write(chip, TDA9875_ADCIS, 0x6f);\r\nchip_write(chip, TDA9875_LOSR, 0x00);\r\nchip_write(chip, TDA9875_AER, 0x00);\r\nchip_write(chip, TDA9875_MCS, 0x44);\r\nchip_write(chip, TDA9875_MVL, 0x03);\r\nchip_write(chip, TDA9875_MVR, 0x03);\r\nchip_write(chip, TDA9875_MBA, 0x00);\r\nchip_write(chip, TDA9875_MTR, 0x00);\r\nchip_write(chip, TDA9875_ACS, 0x44);\r\nchip_write(chip, TDA9875_AVL, 0x00);\r\nchip_write(chip, TDA9875_AVR, 0x00);\r\nchip_write(chip, TDA9875_ABA, 0x00);\r\nchip_write(chip, TDA9875_ATR, 0x00);\r\nchip_write(chip, TDA9875_MUT, 0xcc);\r\nreturn 0;\r\n}\r\nstatic int tda9875_volume(int val) { return (unsigned char)(val / 602 - 84); }\r\nstatic int tda9875_bass(int val) { return (unsigned char)(max(-12, val / 2115 - 15)); }\r\nstatic int tda9875_treble(int val) { return (unsigned char)(val / 2622 - 12); }\r\nstatic int tda9875_checkit(struct CHIPSTATE *chip)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nint dic, rev;\r\ndic = chip_read2(chip, 254);\r\nrev = chip_read2(chip, 255);\r\nif (dic == 0 || dic == 2) {\r\nv4l2_info(sd, "found tda9875%s rev. %d.\n",\r\ndic == 0 ? "" : "A", rev);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tea6300_shift10(int val) { return val >> 10; }\r\nstatic int tea6300_shift12(int val) { return val >> 12; }\r\nstatic int tea6320_volume(int val) { return (val / (65535/(63-12)) + 12) & 0x3f; }\r\nstatic int tea6320_shift11(int val) { return val >> 11; }\r\nstatic int tea6320_initialize(struct CHIPSTATE * chip)\r\n{\r\nchip_write(chip, TEA6320_FFR, 0x3f);\r\nchip_write(chip, TEA6320_FFL, 0x3f);\r\nchip_write(chip, TEA6320_FRR, 0x3f);\r\nchip_write(chip, TEA6320_FRL, 0x3f);\r\nreturn 0;\r\n}\r\nstatic int tda8425_shift10(int val) { return (val >> 10) | 0xc0; }\r\nstatic int tda8425_shift12(int val) { return (val >> 12) | 0xf0; }\r\nstatic void tda8425_setmode(struct CHIPSTATE *chip, int mode)\r\n{\r\nint s1 = chip->shadow.bytes[TDA8425_S1+1] & 0xe1;\r\nif (mode & V4L2_TUNER_MODE_LANG1) {\r\ns1 |= TDA8425_S1_ML_SOUND_A;\r\ns1 |= TDA8425_S1_STEREO_PSEUDO;\r\n} else if (mode & V4L2_TUNER_MODE_LANG2) {\r\ns1 |= TDA8425_S1_ML_SOUND_B;\r\ns1 |= TDA8425_S1_STEREO_PSEUDO;\r\n} else {\r\ns1 |= TDA8425_S1_ML_STEREO;\r\nif (mode & V4L2_TUNER_MODE_MONO)\r\ns1 |= TDA8425_S1_STEREO_MONO;\r\nif (mode & V4L2_TUNER_MODE_STEREO)\r\ns1 |= TDA8425_S1_STEREO_SPATIAL;\r\n}\r\nchip_write(chip,TDA8425_S1,s1);\r\n}\r\nstatic int ta8874z_getmode(struct CHIPSTATE *chip)\r\n{\r\nint val, mode;\r\nval = chip_read(chip);\r\nmode = V4L2_TUNER_MODE_MONO;\r\nif (val & TA8874Z_B1){\r\nmode |= V4L2_TUNER_MODE_LANG1 | V4L2_TUNER_MODE_LANG2;\r\n}else if (!(val & TA8874Z_B0)){\r\nmode |= V4L2_TUNER_MODE_STEREO;\r\n}\r\nreturn mode;\r\n}\r\nstatic void ta8874z_setmode(struct CHIPSTATE *chip, int mode)\r\n{\r\nstruct v4l2_subdev *sd = &chip->sd;\r\nint update = 1;\r\naudiocmd *t = NULL;\r\nv4l2_dbg(1, debug, sd, "ta8874z_setmode(): mode: 0x%02x\n", mode);\r\nswitch(mode){\r\ncase V4L2_TUNER_MODE_MONO:\r\nt = &ta8874z_mono;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nt = &ta8874z_stereo;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nt = &ta8874z_main;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nt = &ta8874z_sub;\r\nbreak;\r\ndefault:\r\nupdate = 0;\r\n}\r\nif(update)\r\nchip_cmd(chip, "TA8874Z", t);\r\n}\r\nstatic int ta8874z_checkit(struct CHIPSTATE *chip)\r\n{\r\nint rc;\r\nrc = chip_read(chip);\r\nreturn ((rc & 0x1f) == 0x1f) ? 1 : 0;\r\n}\r\nstatic int tvaudio_g_ctrl(struct v4l2_subdev *sd,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nstruct CHIPDESC *desc = chip->desc;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (!(desc->flags & CHIP_HAS_INPUTSEL))\r\nbreak;\r\nctrl->value=chip->muted;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nif (!(desc->flags & CHIP_HAS_VOLUME))\r\nbreak;\r\nctrl->value = max(chip->left,chip->right);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_BALANCE:\r\n{\r\nint volume;\r\nif (!(desc->flags & CHIP_HAS_VOLUME))\r\nbreak;\r\nvolume = max(chip->left,chip->right);\r\nif (volume)\r\nctrl->value=(32768*min(chip->left,chip->right))/volume;\r\nelse\r\nctrl->value=32768;\r\nreturn 0;\r\n}\r\ncase V4L2_CID_AUDIO_BASS:\r\nif (!(desc->flags & CHIP_HAS_BASSTREBLE))\r\nbreak;\r\nctrl->value = chip->bass;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_TREBLE:\r\nif (!(desc->flags & CHIP_HAS_BASSTREBLE))\r\nbreak;\r\nctrl->value = chip->treble;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tvaudio_s_ctrl(struct v4l2_subdev *sd,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nstruct CHIPDESC *desc = chip->desc;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (!(desc->flags & CHIP_HAS_INPUTSEL))\r\nbreak;\r\nif (ctrl->value < 0 || ctrl->value >= 2)\r\nreturn -ERANGE;\r\nchip->muted = ctrl->value;\r\nif (chip->muted)\r\nchip_write_masked(chip,desc->inputreg,desc->inputmute,desc->inputmask);\r\nelse\r\nchip_write_masked(chip,desc->inputreg,\r\ndesc->inputmap[chip->input],desc->inputmask);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\n{\r\nint volume,balance;\r\nif (!(desc->flags & CHIP_HAS_VOLUME))\r\nbreak;\r\nvolume = max(chip->left,chip->right);\r\nif (volume)\r\nbalance=(32768*min(chip->left,chip->right))/volume;\r\nelse\r\nbalance=32768;\r\nvolume=ctrl->value;\r\nchip->left = (min(65536 - balance,32768) * volume) / 32768;\r\nchip->right = (min(balance,volume *(__u16)32768)) / 32768;\r\nchip_write(chip,desc->leftreg,desc->volfunc(chip->left));\r\nchip_write(chip,desc->rightreg,desc->volfunc(chip->right));\r\nreturn 0;\r\n}\r\ncase V4L2_CID_AUDIO_BALANCE:\r\n{\r\nint volume, balance;\r\nif (!(desc->flags & CHIP_HAS_VOLUME))\r\nbreak;\r\nvolume = max(chip->left,chip->right);\r\nbalance = ctrl->value;\r\nchip_write(chip,desc->leftreg,desc->volfunc(chip->left));\r\nchip_write(chip,desc->rightreg,desc->volfunc(chip->right));\r\nreturn 0;\r\n}\r\ncase V4L2_CID_AUDIO_BASS:\r\nif (!(desc->flags & CHIP_HAS_BASSTREBLE))\r\nbreak;\r\nchip->bass = ctrl->value;\r\nchip_write(chip,desc->bassreg,desc->bassfunc(chip->bass));\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_TREBLE:\r\nif (!(desc->flags & CHIP_HAS_BASSTREBLE))\r\nbreak;\r\nchip->treble = ctrl->value;\r\nchip_write(chip,desc->treblereg,desc->treblefunc(chip->treble));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tvaudio_s_radio(struct v4l2_subdev *sd)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nchip->radio = 1;\r\nchip->watch_stereo = 0;\r\nreturn 0;\r\n}\r\nstatic int tvaudio_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nstruct CHIPDESC *desc = chip->desc;\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (desc->flags & CHIP_HAS_INPUTSEL)\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nif (desc->flags & CHIP_HAS_VOLUME)\r\nreturn v4l2_ctrl_query_fill(qc, 0, 65535, 65535 / 100, 58880);\r\nbreak;\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nif (desc->flags & CHIP_HAS_VOLUME)\r\nreturn v4l2_ctrl_query_fill(qc, 0, 65535, 65535 / 100, 32768);\r\nbreak;\r\ncase V4L2_CID_AUDIO_BASS:\r\ncase V4L2_CID_AUDIO_TREBLE:\r\nif (desc->flags & CHIP_HAS_BASSTREBLE)\r\nreturn v4l2_ctrl_query_fill(qc, 0, 65535, 65535 / 100, 32768);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tvaudio_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nstruct CHIPDESC *desc = chip->desc;\r\nif (!(desc->flags & CHIP_HAS_INPUTSEL))\r\nreturn 0;\r\nif (input >= 4)\r\nreturn -EINVAL;\r\nchip->input = input;\r\nif (chip->muted)\r\nreturn 0;\r\nchip_write_masked(chip, desc->inputreg,\r\ndesc->inputmap[chip->input], desc->inputmask);\r\nreturn 0;\r\n}\r\nstatic int tvaudio_s_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nstruct CHIPDESC *desc = chip->desc;\r\nint mode = 0;\r\nif (!desc->setmode)\r\nreturn 0;\r\nif (chip->radio)\r\nreturn 0;\r\nswitch (vt->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\ncase V4L2_TUNER_MODE_STEREO:\r\ncase V4L2_TUNER_MODE_LANG1:\r\ncase V4L2_TUNER_MODE_LANG2:\r\nmode = vt->audmode;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nmode = V4L2_TUNER_MODE_STEREO;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nchip->audmode = vt->audmode;\r\nif (mode) {\r\nchip->watch_stereo = 0;\r\nchip->mode = mode;\r\ndesc->setmode(chip, mode);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvaudio_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nstruct CHIPDESC *desc = chip->desc;\r\nint mode = V4L2_TUNER_MODE_MONO;\r\nif (!desc->getmode)\r\nreturn 0;\r\nif (chip->radio)\r\nreturn 0;\r\nvt->audmode = chip->audmode;\r\nvt->rxsubchans = 0;\r\nvt->capability = V4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;\r\nmode = desc->getmode(chip);\r\nif (mode & V4L2_TUNER_MODE_MONO)\r\nvt->rxsubchans |= V4L2_TUNER_SUB_MONO;\r\nif (mode & V4L2_TUNER_MODE_STEREO)\r\nvt->rxsubchans |= V4L2_TUNER_SUB_STEREO;\r\nif (mode & V4L2_TUNER_MODE_LANG1)\r\nvt->rxsubchans = V4L2_TUNER_SUB_LANG1 |\r\nV4L2_TUNER_SUB_LANG2;\r\nreturn 0;\r\n}\r\nstatic int tvaudio_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nchip->radio = 0;\r\nreturn 0;\r\n}\r\nstatic int tvaudio_s_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *freq)\r\n{\r\nstruct CHIPSTATE *chip = to_state(sd);\r\nstruct CHIPDESC *desc = chip->desc;\r\nchip->mode = 0;\r\nif (chip->thread) {\r\ndesc->setmode(chip, V4L2_TUNER_MODE_MONO);\r\nif (chip->prevmode != V4L2_TUNER_MODE_MONO)\r\nchip->prevmode = -1;\r\nmod_timer(&chip->wt, jiffies+msecs_to_jiffies(2000));\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvaudio_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_TVAUDIO, 0);\r\n}\r\nstatic int tvaudio_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct CHIPSTATE *chip;\r\nstruct CHIPDESC *desc;\r\nstruct v4l2_subdev *sd;\r\nif (debug) {\r\nprintk(KERN_INFO "tvaudio: TV audio decoder + audio/video mux driver\n");\r\nprintk(KERN_INFO "tvaudio: known chips: ");\r\nfor (desc = chiplist; desc->name != NULL; desc++)\r\nprintk("%s%s", (desc == chiplist) ? "" : ", ", desc->name);\r\nprintk("\n");\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nsd = &chip->sd;\r\nv4l2_i2c_subdev_init(sd, client, &tvaudio_ops);\r\nv4l2_dbg(1, debug, sd, "chip found @ 0x%x\n", client->addr<<1);\r\nfor (desc = chiplist; desc->name != NULL; desc++) {\r\nif (0 == *(desc->insmodopt))\r\ncontinue;\r\nif (client->addr < desc->addr_lo ||\r\nclient->addr > desc->addr_hi)\r\ncontinue;\r\nif (desc->checkit && !desc->checkit(chip))\r\ncontinue;\r\nbreak;\r\n}\r\nif (desc->name == NULL) {\r\nv4l2_dbg(1, debug, sd, "no matching chip description found\n");\r\nkfree(chip);\r\nreturn -EIO;\r\n}\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", desc->name, client->addr<<1, client->adapter->name);\r\nif (desc->flags) {\r\nv4l2_dbg(1, debug, sd, "matches:%s%s%s.\n",\r\n(desc->flags & CHIP_HAS_VOLUME) ? " volume" : "",\r\n(desc->flags & CHIP_HAS_BASSTREBLE) ? " bass/treble" : "",\r\n(desc->flags & CHIP_HAS_INPUTSEL) ? " audiomux" : "");\r\n}\r\nif (!id)\r\nstrlcpy(client->name, desc->name, I2C_NAME_SIZE);\r\nchip->desc = desc;\r\nchip->shadow.count = desc->registers+1;\r\nchip->prevmode = -1;\r\nchip->audmode = V4L2_TUNER_MODE_LANG1;\r\nif (desc->initialize != NULL)\r\ndesc->initialize(chip);\r\nelse\r\nchip_cmd(chip, "init", &desc->init);\r\nif (desc->flags & CHIP_HAS_VOLUME) {\r\nif (!desc->volfunc) {\r\nv4l2_info(sd, "volume callback undefined!\n");\r\ndesc->flags &= ~CHIP_HAS_VOLUME;\r\n} else {\r\nchip->left = desc->leftinit ? desc->leftinit : 65535;\r\nchip->right = desc->rightinit ? desc->rightinit : 65535;\r\nchip_write(chip, desc->leftreg,\r\ndesc->volfunc(chip->left));\r\nchip_write(chip, desc->rightreg,\r\ndesc->volfunc(chip->right));\r\n}\r\n}\r\nif (desc->flags & CHIP_HAS_BASSTREBLE) {\r\nif (!desc->bassfunc || !desc->treblefunc) {\r\nv4l2_info(sd, "bass/treble callbacks undefined!\n");\r\ndesc->flags &= ~CHIP_HAS_BASSTREBLE;\r\n} else {\r\nchip->treble = desc->trebleinit ?\r\ndesc->trebleinit : 32768;\r\nchip->bass = desc->bassinit ?\r\ndesc->bassinit : 32768;\r\nchip_write(chip, desc->bassreg,\r\ndesc->bassfunc(chip->bass));\r\nchip_write(chip, desc->treblereg,\r\ndesc->treblefunc(chip->treble));\r\n}\r\n}\r\nchip->thread = NULL;\r\ninit_timer(&chip->wt);\r\nif (desc->flags & CHIP_NEED_CHECKMODE) {\r\nif (!desc->getmode || !desc->setmode) {\r\nv4l2_info(sd, "set/get mode callbacks undefined!\n");\r\nreturn 0;\r\n}\r\nchip->wt.function = chip_thread_wake;\r\nchip->wt.data = (unsigned long)chip;\r\nchip->thread = kthread_run(chip_thread, chip, client->name);\r\nif (IS_ERR(chip->thread)) {\r\nv4l2_warn(sd, "failed to create kthread\n");\r\nchip->thread = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvaudio_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct CHIPSTATE *chip = to_state(sd);\r\ndel_timer_sync(&chip->wt);\r\nif (chip->thread) {\r\nkthread_stop(chip->thread);\r\nchip->thread = NULL;\r\n}\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic __init int init_tvaudio(void)\r\n{\r\nreturn i2c_add_driver(&tvaudio_driver);\r\n}\r\nstatic __exit void exit_tvaudio(void)\r\n{\r\ni2c_del_driver(&tvaudio_driver);\r\n}
