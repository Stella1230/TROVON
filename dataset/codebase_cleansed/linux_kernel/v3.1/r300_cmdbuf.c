static int r300_emit_cliprects(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf, int n)\r\n{\r\nstruct drm_clip_rect box;\r\nint nr;\r\nint i;\r\nRING_LOCALS;\r\nnr = cmdbuf->nbox - n;\r\nif (nr > R300_SIMULTANEOUS_CLIPRECTS)\r\nnr = R300_SIMULTANEOUS_CLIPRECTS;\r\nDRM_DEBUG("%i cliprects\n", nr);\r\nif (nr) {\r\nBEGIN_RING(6 + nr * 2);\r\nOUT_RING(CP_PACKET0(R300_RE_CLIPRECT_TL_0, nr * 2 - 1));\r\nfor (i = 0; i < nr; ++i) {\r\nif (DRM_COPY_FROM_USER_UNCHECKED\r\n(&box, &cmdbuf->boxes[n + i], sizeof(box))) {\r\nDRM_ERROR("copy cliprect faulted\n");\r\nreturn -EFAULT;\r\n}\r\nbox.x2--;\r\nbox.y2--;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_RV515) {\r\nbox.x1 = (box.x1) &\r\nR300_CLIPRECT_MASK;\r\nbox.y1 = (box.y1) &\r\nR300_CLIPRECT_MASK;\r\nbox.x2 = (box.x2) &\r\nR300_CLIPRECT_MASK;\r\nbox.y2 = (box.y2) &\r\nR300_CLIPRECT_MASK;\r\n} else {\r\nbox.x1 = (box.x1 + R300_CLIPRECT_OFFSET) &\r\nR300_CLIPRECT_MASK;\r\nbox.y1 = (box.y1 + R300_CLIPRECT_OFFSET) &\r\nR300_CLIPRECT_MASK;\r\nbox.x2 = (box.x2 + R300_CLIPRECT_OFFSET) &\r\nR300_CLIPRECT_MASK;\r\nbox.y2 = (box.y2 + R300_CLIPRECT_OFFSET) &\r\nR300_CLIPRECT_MASK;\r\n}\r\nOUT_RING((box.x1 << R300_CLIPRECT_X_SHIFT) |\r\n(box.y1 << R300_CLIPRECT_Y_SHIFT));\r\nOUT_RING((box.x2 << R300_CLIPRECT_X_SHIFT) |\r\n(box.y2 << R300_CLIPRECT_Y_SHIFT));\r\n}\r\nOUT_RING_REG(R300_RE_CLIPRECT_CNTL, r300_cliprect_cntl[nr - 1]);\r\nOUT_RING(CP_PACKET0(R300_RE_SCISSORS_TL, 1));\r\nOUT_RING(0);\r\nOUT_RING(R300_SCISSORS_X_MASK | R300_SCISSORS_Y_MASK);\r\nADVANCE_RING();\r\n} else {\r\nBEGIN_RING(2);\r\nOUT_RING_REG(R300_RE_CLIPRECT_CNTL, 0);\r\nADVANCE_RING();\r\n}\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\r\nOUT_RING(R300_RB3D_DC_FLUSH);\r\nADVANCE_RING();\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));\r\nOUT_RING(RADEON_WAIT_3D_IDLECLEAN);\r\nADVANCE_RING();\r\ndev_priv->track_flush |= RADEON_FLUSH_EMITED;\r\nreturn 0;\r\n}\r\nvoid r300_init_reg_flags(struct drm_device *dev)\r\n{\r\nint i;\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nmemset(r300_reg_flags, 0, 0x10000 >> 2);\r\n#define ADD_RANGE_MARK(reg, count,mark) \\r\nfor(i=((reg)>>2);i<((reg)>>2)+(count);i++)\\r\nr300_reg_flags[i]|=(mark);\r\n#define MARK_SAFE 1\r\n#define MARK_CHECK_OFFSET 2\r\n#define ADD_RANGE(reg, count) ADD_RANGE_MARK(reg, count, MARK_SAFE)\r\nADD_RANGE(R300_SE_VPORT_XSCALE, 6);\r\nADD_RANGE(R300_VAP_CNTL, 1);\r\nADD_RANGE(R300_SE_VTE_CNTL, 2);\r\nADD_RANGE(0x2134, 2);\r\nADD_RANGE(R300_VAP_CNTL_STATUS, 1);\r\nADD_RANGE(R300_VAP_INPUT_CNTL_0, 2);\r\nADD_RANGE(0x21DC, 1);\r\nADD_RANGE(R300_VAP_UNKNOWN_221C, 1);\r\nADD_RANGE(R300_VAP_CLIP_X_0, 4);\r\nADD_RANGE(R300_VAP_PVS_STATE_FLUSH_REG, 1);\r\nADD_RANGE(R300_VAP_UNKNOWN_2288, 1);\r\nADD_RANGE(R300_VAP_OUTPUT_VTX_FMT_0, 2);\r\nADD_RANGE(R300_VAP_PVS_CNTL_1, 3);\r\nADD_RANGE(R300_GB_ENABLE, 1);\r\nADD_RANGE(R300_GB_MSPOS0, 5);\r\nADD_RANGE(R300_TX_INVALTAGS, 1);\r\nADD_RANGE(R300_TX_ENABLE, 1);\r\nADD_RANGE(0x4200, 4);\r\nADD_RANGE(0x4214, 1);\r\nADD_RANGE(R300_RE_POINTSIZE, 1);\r\nADD_RANGE(0x4230, 3);\r\nADD_RANGE(R300_RE_LINE_CNT, 1);\r\nADD_RANGE(R300_RE_UNK4238, 1);\r\nADD_RANGE(0x4260, 3);\r\nADD_RANGE(R300_RE_SHADE, 4);\r\nADD_RANGE(R300_RE_POLYGON_MODE, 5);\r\nADD_RANGE(R300_RE_ZBIAS_CNTL, 1);\r\nADD_RANGE(R300_RE_ZBIAS_T_FACTOR, 4);\r\nADD_RANGE(R300_RE_OCCLUSION_CNTL, 1);\r\nADD_RANGE(R300_RE_CULL_CNTL, 1);\r\nADD_RANGE(0x42C0, 2);\r\nADD_RANGE(R300_RS_CNTL_0, 2);\r\nADD_RANGE(R300_SU_REG_DEST, 1);\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) == CHIP_RV530)\r\nADD_RANGE(RV530_FG_ZBREG_DEST, 1);\r\nADD_RANGE(R300_SC_HYPERZ, 2);\r\nADD_RANGE(0x43E8, 1);\r\nADD_RANGE(0x46A4, 5);\r\nADD_RANGE(R300_RE_FOG_STATE, 1);\r\nADD_RANGE(R300_FOG_COLOR_R, 3);\r\nADD_RANGE(R300_PP_ALPHA_TEST, 2);\r\nADD_RANGE(0x4BD8, 1);\r\nADD_RANGE(R300_PFS_PARAM_0_X, 64);\r\nADD_RANGE(0x4E00, 1);\r\nADD_RANGE(R300_RB3D_CBLEND, 2);\r\nADD_RANGE(R300_RB3D_COLORMASK, 1);\r\nADD_RANGE(R300_RB3D_BLEND_COLOR, 3);\r\nADD_RANGE_MARK(R300_RB3D_COLOROFFSET0, 1, MARK_CHECK_OFFSET);\r\nADD_RANGE(R300_RB3D_COLORPITCH0, 1);\r\nADD_RANGE(0x4E50, 9);\r\nADD_RANGE(0x4E88, 1);\r\nADD_RANGE(0x4EA0, 2);\r\nADD_RANGE(R300_ZB_CNTL, 3);\r\nADD_RANGE(R300_ZB_FORMAT, 4);\r\nADD_RANGE_MARK(R300_ZB_DEPTHOFFSET, 1, MARK_CHECK_OFFSET);\r\nADD_RANGE(R300_ZB_DEPTHPITCH, 1);\r\nADD_RANGE(R300_ZB_DEPTHCLEARVALUE, 1);\r\nADD_RANGE(R300_ZB_ZMASK_OFFSET, 13);\r\nADD_RANGE(R300_ZB_ZPASS_DATA, 2);\r\nADD_RANGE(R300_TX_FILTER_0, 16);\r\nADD_RANGE(R300_TX_FILTER1_0, 16);\r\nADD_RANGE(R300_TX_SIZE_0, 16);\r\nADD_RANGE(R300_TX_FORMAT_0, 16);\r\nADD_RANGE(R300_TX_PITCH_0, 16);\r\nADD_RANGE_MARK(R300_TX_OFFSET_0, 16, MARK_CHECK_OFFSET);\r\nADD_RANGE(R300_TX_CHROMA_KEY_0, 16);\r\nADD_RANGE(R300_TX_BORDER_COLOR_0, 16);\r\nADD_RANGE(R300_ZB_ZCACHE_CTLSTAT, 1);\r\nADD_RANGE(R300_RB3D_DSTCACHE_CTLSTAT, 1);\r\nADD_RANGE(R300_VAP_INPUT_ROUTE_0_0, 8);\r\nADD_RANGE(R300_VAP_INPUT_ROUTE_1_0, 8);\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_RV515) {\r\nADD_RANGE(R500_VAP_INDEX_OFFSET, 1);\r\nADD_RANGE(R500_US_CONFIG, 2);\r\nADD_RANGE(R500_US_CODE_ADDR, 3);\r\nADD_RANGE(R500_US_FC_CTRL, 1);\r\nADD_RANGE(R500_RS_IP_0, 16);\r\nADD_RANGE(R500_RS_INST_0, 16);\r\nADD_RANGE(R500_RB3D_COLOR_CLEAR_VALUE_AR, 2);\r\nADD_RANGE(R500_RB3D_CONSTANT_COLOR_AR, 2);\r\nADD_RANGE(R500_ZB_FIFO_SIZE, 2);\r\n} else {\r\nADD_RANGE(R300_PFS_CNTL_0, 3);\r\nADD_RANGE(R300_PFS_NODE_0, 4);\r\nADD_RANGE(R300_PFS_TEXI_0, 64);\r\nADD_RANGE(R300_PFS_INSTR0_0, 64);\r\nADD_RANGE(R300_PFS_INSTR1_0, 64);\r\nADD_RANGE(R300_PFS_INSTR2_0, 64);\r\nADD_RANGE(R300_PFS_INSTR3_0, 64);\r\nADD_RANGE(R300_RS_INTERP_0, 8);\r\nADD_RANGE(R300_RS_ROUTE_0, 8);\r\n}\r\n}\r\nstatic __inline__ int r300_check_range(unsigned reg, int count)\r\n{\r\nint i;\r\nif (reg & ~0xffff)\r\nreturn -1;\r\nfor (i = (reg >> 2); i < (reg >> 2) + count; i++)\r\nif (r300_reg_flags[i] != MARK_SAFE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_carefully_checked_packet0(drm_radeon_private_t *\r\ndev_priv,\r\ndrm_radeon_kcmd_buffer_t\r\n* cmdbuf,\r\ndrm_r300_cmd_header_t\r\nheader)\r\n{\r\nint reg;\r\nint sz;\r\nint i;\r\nu32 *value;\r\nRING_LOCALS;\r\nsz = header.packet0.count;\r\nreg = (header.packet0.reghi << 8) | header.packet0.reglo;\r\nif ((sz > 64) || (sz < 0)) {\r\nDRM_ERROR("Cannot emit more than 64 values at a time (reg=%04x sz=%d)\n",\r\nreg, sz);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < sz; i++) {\r\nswitch (r300_reg_flags[(reg >> 2) + i]) {\r\ncase MARK_SAFE:\r\nbreak;\r\ncase MARK_CHECK_OFFSET:\r\nvalue = drm_buffer_pointer_to_dword(cmdbuf->buffer, i);\r\nif (!radeon_check_offset(dev_priv, *value)) {\r\nDRM_ERROR("Offset failed range check (reg=%04x sz=%d)\n",\r\nreg, sz);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Register %04x failed check as flag=%02x\n",\r\nreg + i * 4, r300_reg_flags[(reg >> 2) + i]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nBEGIN_RING(1 + sz);\r\nOUT_RING(CP_PACKET0(reg, sz - 1));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_packet0(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf,\r\ndrm_r300_cmd_header_t header)\r\n{\r\nint reg;\r\nint sz;\r\nRING_LOCALS;\r\nsz = header.packet0.count;\r\nreg = (header.packet0.reghi << 8) | header.packet0.reglo;\r\nif (!sz)\r\nreturn 0;\r\nif (sz * 4 > drm_buffer_unprocessed(cmdbuf->buffer))\r\nreturn -EINVAL;\r\nif (reg + sz * 4 >= 0x10000) {\r\nDRM_ERROR("No such registers in hardware reg=%04x sz=%d\n", reg,\r\nsz);\r\nreturn -EINVAL;\r\n}\r\nif (r300_check_range(reg, sz)) {\r\nreturn r300_emit_carefully_checked_packet0(dev_priv, cmdbuf,\r\nheader);\r\n}\r\nBEGIN_RING(1 + sz);\r\nOUT_RING(CP_PACKET0(reg, sz - 1));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_vpu(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf,\r\ndrm_r300_cmd_header_t header)\r\n{\r\nint sz;\r\nint addr;\r\nRING_LOCALS;\r\nsz = header.vpu.count;\r\naddr = (header.vpu.adrhi << 8) | header.vpu.adrlo;\r\nif (!sz)\r\nreturn 0;\r\nif (sz * 16 > drm_buffer_unprocessed(cmdbuf->buffer))\r\nreturn -EINVAL;\r\nBEGIN_RING(6);\r\nOUT_RING(CP_PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\r\nOUT_RING(R300_RB3D_DC_FLUSH);\r\nOUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));\r\nOUT_RING(RADEON_WAIT_3D_IDLECLEAN);\r\nOUT_RING(CP_PACKET0(R300_VAP_PVS_STATE_FLUSH_REG, 0));\r\nOUT_RING(0);\r\nADVANCE_RING();\r\ndev_priv->track_flush |= RADEON_FLUSH_EMITED;\r\nBEGIN_RING(3 + sz * 4);\r\nOUT_RING_REG(R300_VAP_PVS_UPLOAD_ADDRESS, addr);\r\nOUT_RING(CP_PACKET0_TABLE(R300_VAP_PVS_UPLOAD_DATA, sz * 4 - 1));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz * 4);\r\nADVANCE_RING();\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(R300_VAP_PVS_STATE_FLUSH_REG, 0));\r\nOUT_RING(0);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_clear(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nRING_LOCALS;\r\nif (8 * 4 > drm_buffer_unprocessed(cmdbuf->buffer))\r\nreturn -EINVAL;\r\nBEGIN_RING(10);\r\nOUT_RING(CP_PACKET3(R200_3D_DRAW_IMMD_2, 8));\r\nOUT_RING(R300_PRIM_TYPE_POINT | R300_PRIM_WALK_RING |\r\n(1 << R300_PRIM_NUM_VERTICES_SHIFT));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, 8);\r\nADVANCE_RING();\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\r\nOUT_RING(R300_RB3D_DC_FLUSH);\r\nOUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));\r\nOUT_RING(RADEON_WAIT_3D_IDLECLEAN);\r\nADVANCE_RING();\r\ndev_priv->track_flush |= RADEON_FLUSH_EMITED;\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_3d_load_vbpntr(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf,\r\nu32 header)\r\n{\r\nint count, i, k;\r\n#define MAX_ARRAY_PACKET 64\r\nu32 *data;\r\nu32 narrays;\r\nRING_LOCALS;\r\ncount = (header & RADEON_CP_PACKET_COUNT_MASK) >> 16;\r\nif ((count + 1) > MAX_ARRAY_PACKET) {\r\nDRM_ERROR("Too large payload in 3D_LOAD_VBPNTR (count=%d)\n",\r\ncount);\r\nreturn -EINVAL;\r\n}\r\ndrm_buffer_advance(cmdbuf->buffer, 4);\r\nnarrays = *(u32 *)drm_buffer_pointer_to_dword(cmdbuf->buffer, 0);\r\nk = 0;\r\ni = 1;\r\nwhile ((k < narrays) && (i < (count + 1))) {\r\ni++;\r\ndata = drm_buffer_pointer_to_dword(cmdbuf->buffer, i);\r\nif (!radeon_check_offset(dev_priv, *data)) {\r\nDRM_ERROR\r\n("Offset failed range check (k=%d i=%d) while processing 3D_LOAD_VBPNTR packet.\n",\r\nk, i);\r\nreturn -EINVAL;\r\n}\r\nk++;\r\ni++;\r\nif (k == narrays)\r\nbreak;\r\ndata = drm_buffer_pointer_to_dword(cmdbuf->buffer, i);\r\nif (!radeon_check_offset(dev_priv, *data)) {\r\nDRM_ERROR\r\n("Offset failed range check (k=%d i=%d) while processing 3D_LOAD_VBPNTR packet.\n",\r\nk, i);\r\nreturn -EINVAL;\r\n}\r\nk++;\r\ni++;\r\n}\r\nif ((k != narrays) || (i != (count + 1))) {\r\nDRM_ERROR\r\n("Malformed 3D_LOAD_VBPNTR packet (k=%d i=%d narrays=%d count+1=%d).\n",\r\nk, i, narrays, count + 1);\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(count + 2);\r\nOUT_RING(header);\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, count + 1);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_bitblt_multi(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nu32 *cmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 0);\r\nint count, ret;\r\nRING_LOCALS;\r\ncount = (*cmd & RADEON_CP_PACKET_COUNT_MASK) >> 16;\r\nif (*cmd & 0x8000) {\r\nu32 offset;\r\nu32 *cmd1 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 1);\r\nif (*cmd1 & (RADEON_GMC_SRC_PITCH_OFFSET_CNTL\r\n| RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {\r\nu32 *cmd2 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 2);\r\noffset = *cmd2 << 10;\r\nret = !radeon_check_offset(dev_priv, offset);\r\nif (ret) {\r\nDRM_ERROR("Invalid bitblt first offset is %08X\n", offset);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((*cmd1 & RADEON_GMC_SRC_PITCH_OFFSET_CNTL) &&\r\n(*cmd1 & RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {\r\nu32 *cmd3 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 3);\r\noffset = *cmd3 << 10;\r\nret = !radeon_check_offset(dev_priv, offset);\r\nif (ret) {\r\nDRM_ERROR("Invalid bitblt second offset is %08X\n", offset);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nBEGIN_RING(count+2);\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, count + 2);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_draw_indx_2(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nu32 *cmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 0);\r\nu32 *cmd1 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 1);\r\nint count;\r\nint expected_count;\r\nRING_LOCALS;\r\ncount = (*cmd & RADEON_CP_PACKET_COUNT_MASK) >> 16;\r\nexpected_count = *cmd1 >> 16;\r\nif (!(*cmd1 & R300_VAP_VF_CNTL__INDEX_SIZE_32bit))\r\nexpected_count = (expected_count+1)/2;\r\nif (count && count != expected_count) {\r\nDRM_ERROR("3D_DRAW_INDX_2: packet size %i, expected %i\n",\r\ncount, expected_count);\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(count+2);\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, count + 2);\r\nADVANCE_RING();\r\nif (!count) {\r\ndrm_r300_cmd_header_t stack_header, *header;\r\nu32 *cmd1, *cmd2, *cmd3;\r\nif (drm_buffer_unprocessed(cmdbuf->buffer)\r\n< 4*4 + sizeof(stack_header)) {\r\nDRM_ERROR("3D_DRAW_INDX_2: expect subsequent INDX_BUFFER, but stream is too short.\n");\r\nreturn -EINVAL;\r\n}\r\nheader = drm_buffer_read_object(cmdbuf->buffer,\r\nsizeof(stack_header), &stack_header);\r\ncmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 0);\r\ncmd1 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 1);\r\ncmd2 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 2);\r\ncmd3 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 3);\r\nif (header->header.cmd_type != R300_CMD_PACKET3 ||\r\nheader->packet3.packet != R300_CMD_PACKET3_RAW ||\r\n*cmd != CP_PACKET3(RADEON_CP_INDX_BUFFER, 2)) {\r\nDRM_ERROR("3D_DRAW_INDX_2: expect subsequent INDX_BUFFER.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((*cmd1 & 0x8000ffff) != 0x80000810) {\r\nDRM_ERROR("Invalid indx_buffer reg address %08X\n",\r\n*cmd1);\r\nreturn -EINVAL;\r\n}\r\nif (!radeon_check_offset(dev_priv, *cmd2)) {\r\nDRM_ERROR("Invalid indx_buffer offset is %08X\n",\r\n*cmd2);\r\nreturn -EINVAL;\r\n}\r\nif (*cmd3 != expected_count) {\r\nDRM_ERROR("INDX_BUFFER: buffer size %i, expected %i\n",\r\n*cmd3, expected_count);\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(4);\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, 4);\r\nADVANCE_RING();\r\n}\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_raw_packet3(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nu32 *header;\r\nint count;\r\nRING_LOCALS;\r\nif (4 > drm_buffer_unprocessed(cmdbuf->buffer))\r\nreturn -EINVAL;\r\nheader = drm_buffer_pointer_to_dword(cmdbuf->buffer, 0);\r\nif ((*header >> 30) != 0x3) {\r\nDRM_ERROR("Not a packet3 header (0x%08x)\n", *header);\r\nreturn -EINVAL;\r\n}\r\ncount = (*header >> 16) & 0x3fff;\r\nif ((count + 2) * 4 > drm_buffer_unprocessed(cmdbuf->buffer)) {\r\nDRM_ERROR\r\n("Expected packet3 of length %d but have only %d bytes left\n",\r\n(count + 2) * 4, drm_buffer_unprocessed(cmdbuf->buffer));\r\nreturn -EINVAL;\r\n}\r\nswitch (*header & 0xff00) {\r\ncase RADEON_3D_LOAD_VBPNTR:\r\nreturn r300_emit_3d_load_vbpntr(dev_priv, cmdbuf, *header);\r\ncase RADEON_CNTL_BITBLT_MULTI:\r\nreturn r300_emit_bitblt_multi(dev_priv, cmdbuf);\r\ncase RADEON_CP_INDX_BUFFER:\r\nDRM_ERROR("packet3 INDX_BUFFER without preceding 3D_DRAW_INDX_2 is illegal.\n");\r\nreturn -EINVAL;\r\ncase RADEON_CP_3D_DRAW_IMMD_2:\r\ncase RADEON_CP_3D_DRAW_VBUF_2:\r\ndev_priv->track_flush &= ~(RADEON_FLUSH_EMITED |\r\nRADEON_PURGE_EMITED);\r\nbreak;\r\ncase RADEON_CP_3D_DRAW_INDX_2:\r\ndev_priv->track_flush &= ~(RADEON_FLUSH_EMITED |\r\nRADEON_PURGE_EMITED);\r\nreturn r300_emit_draw_indx_2(dev_priv, cmdbuf);\r\ncase RADEON_WAIT_FOR_IDLE:\r\ncase RADEON_CP_NOP:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown packet3 header (0x%08x)\n", *header);\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(count + 2);\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, count + 2);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int r300_emit_packet3(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf,\r\ndrm_r300_cmd_header_t header)\r\n{\r\nint n;\r\nint ret;\r\nint orig_iter = cmdbuf->buffer->iterator;\r\nn = 0;\r\ndo {\r\nif (cmdbuf->nbox > R300_SIMULTANEOUS_CLIPRECTS) {\r\nret = r300_emit_cliprects(dev_priv, cmdbuf, n);\r\nif (ret)\r\nreturn ret;\r\ncmdbuf->buffer->iterator = orig_iter;\r\n}\r\nswitch (header.packet3.packet) {\r\ncase R300_CMD_PACKET3_CLEAR:\r\nDRM_DEBUG("R300_CMD_PACKET3_CLEAR\n");\r\nret = r300_emit_clear(dev_priv, cmdbuf);\r\nif (ret) {\r\nDRM_ERROR("r300_emit_clear failed\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ncase R300_CMD_PACKET3_RAW:\r\nDRM_DEBUG("R300_CMD_PACKET3_RAW\n");\r\nret = r300_emit_raw_packet3(dev_priv, cmdbuf);\r\nif (ret) {\r\nDRM_ERROR("r300_emit_raw_packet3 failed\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("bad packet3 type %i at byte %d\n",\r\nheader.packet3.packet,\r\ncmdbuf->buffer->iterator - (int)sizeof(header));\r\nreturn -EINVAL;\r\n}\r\nn += R300_SIMULTANEOUS_CLIPRECTS;\r\n} while (n < cmdbuf->nbox);\r\nreturn 0;\r\n}\r\nstatic __inline__ void r300_pacify(drm_radeon_private_t *dev_priv)\r\n{\r\nuint32_t cache_z, cache_3d, cache_2d;\r\nRING_LOCALS;\r\ncache_z = R300_ZC_FLUSH;\r\ncache_2d = R300_RB2D_DC_FLUSH;\r\ncache_3d = R300_RB3D_DC_FLUSH;\r\nif (!(dev_priv->track_flush & RADEON_PURGE_EMITED)) {\r\ncache_z |= R300_ZC_FREE;\r\ncache_2d |= R300_RB2D_DC_FREE;\r\ncache_3d |= R300_RB3D_DC_FREE;\r\n}\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(R300_ZB_ZCACHE_CTLSTAT, 0));\r\nOUT_RING(cache_z);\r\nADVANCE_RING();\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\r\nOUT_RING(cache_3d);\r\nADVANCE_RING();\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(R300_TX_INVALTAGS, 0));\r\nOUT_RING(0);\r\nADVANCE_RING();\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(R300_RB3D_AARESOLVE_CTL, 0));\r\nOUT_RING(0);\r\nADVANCE_RING();\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));\r\nOUT_RING(RADEON_WAIT_3D_IDLECLEAN);\r\nADVANCE_RING();\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET0(R300_DSTCACHE_CTLSTAT, 0));\r\nOUT_RING(cache_2d);\r\nOUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));\r\nOUT_RING(RADEON_WAIT_2D_IDLECLEAN |\r\nRADEON_WAIT_HOST_IDLECLEAN);\r\nADVANCE_RING();\r\ndev_priv->track_flush |= RADEON_FLUSH_EMITED | RADEON_PURGE_EMITED;\r\n}\r\nstatic void r300_discard_buffer(struct drm_device *dev, struct drm_master *master, struct drm_buf *buf)\r\n{\r\ndrm_radeon_buf_priv_t *buf_priv = buf->dev_private;\r\nstruct drm_radeon_master_private *master_priv = master->driver_priv;\r\nbuf_priv->age = ++master_priv->sarea_priv->last_dispatch;\r\nbuf->pending = 1;\r\nbuf->used = 0;\r\n}\r\nstatic void r300_cmd_wait(drm_radeon_private_t * dev_priv,\r\ndrm_r300_cmd_header_t header)\r\n{\r\nu32 wait_until;\r\nRING_LOCALS;\r\nif (!header.wait.flags)\r\nreturn;\r\nwait_until = 0;\r\nswitch(header.wait.flags) {\r\ncase R300_WAIT_2D:\r\nwait_until = RADEON_WAIT_2D_IDLE;\r\nbreak;\r\ncase R300_WAIT_3D:\r\nwait_until = RADEON_WAIT_3D_IDLE;\r\nbreak;\r\ncase R300_NEW_WAIT_2D_3D:\r\nwait_until = RADEON_WAIT_2D_IDLE|RADEON_WAIT_3D_IDLE;\r\nbreak;\r\ncase R300_NEW_WAIT_2D_2D_CLEAN:\r\nwait_until = RADEON_WAIT_2D_IDLE|RADEON_WAIT_2D_IDLECLEAN;\r\nbreak;\r\ncase R300_NEW_WAIT_3D_3D_CLEAN:\r\nwait_until = RADEON_WAIT_3D_IDLE|RADEON_WAIT_3D_IDLECLEAN;\r\nbreak;\r\ncase R300_NEW_WAIT_2D_2D_CLEAN_3D_3D_CLEAN:\r\nwait_until = RADEON_WAIT_2D_IDLE|RADEON_WAIT_2D_IDLECLEAN;\r\nwait_until |= RADEON_WAIT_3D_IDLE|RADEON_WAIT_3D_IDLECLEAN;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));\r\nOUT_RING(wait_until);\r\nADVANCE_RING();\r\n}\r\nstatic int r300_scratch(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf,\r\ndrm_r300_cmd_header_t header)\r\n{\r\nu32 *ref_age_base;\r\nu32 i, *buf_idx, h_pending;\r\nu64 *ptr_addr;\r\nu64 stack_ptr_addr;\r\nRING_LOCALS;\r\nif (drm_buffer_unprocessed(cmdbuf->buffer) <\r\n(sizeof(u64) + header.scratch.n_bufs * sizeof(*buf_idx))) {\r\nreturn -EINVAL;\r\n}\r\nif (header.scratch.reg >= 5) {\r\nreturn -EINVAL;\r\n}\r\ndev_priv->scratch_ages[header.scratch.reg]++;\r\nptr_addr = drm_buffer_read_object(cmdbuf->buffer,\r\nsizeof(stack_ptr_addr), &stack_ptr_addr);\r\nref_age_base = (u32 *)(unsigned long)get_unaligned(ptr_addr);\r\nfor (i=0; i < header.scratch.n_bufs; i++) {\r\nbuf_idx = drm_buffer_pointer_to_dword(cmdbuf->buffer, 0);\r\n*buf_idx *= 2;\r\nif (DRM_COPY_TO_USER(ref_age_base + *buf_idx,\r\n&dev_priv->scratch_ages[header.scratch.reg],\r\nsizeof(u32)))\r\nreturn -EINVAL;\r\nif (DRM_COPY_FROM_USER(&h_pending,\r\nref_age_base + *buf_idx + 1,\r\nsizeof(u32)))\r\nreturn -EINVAL;\r\nif (h_pending == 0)\r\nreturn -EINVAL;\r\nh_pending--;\r\nif (DRM_COPY_TO_USER(ref_age_base + *buf_idx + 1,\r\n&h_pending,\r\nsizeof(u32)))\r\nreturn -EINVAL;\r\ndrm_buffer_advance(cmdbuf->buffer, sizeof(*buf_idx));\r\n}\r\nBEGIN_RING(2);\r\nOUT_RING( CP_PACKET0( RADEON_SCRATCH_REG0 + header.scratch.reg * 4, 0 ) );\r\nOUT_RING( dev_priv->scratch_ages[header.scratch.reg] );\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic inline int r300_emit_r500fp(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf,\r\ndrm_r300_cmd_header_t header)\r\n{\r\nint sz;\r\nint addr;\r\nint type;\r\nint isclamp;\r\nint stride;\r\nRING_LOCALS;\r\nsz = header.r500fp.count;\r\naddr = ((header.r500fp.adrhi_flags & 1) << 8) | header.r500fp.adrlo;\r\ntype = !!(header.r500fp.adrhi_flags & R500FP_CONSTANT_TYPE);\r\nisclamp = !!(header.r500fp.adrhi_flags & R500FP_CONSTANT_CLAMP);\r\naddr |= (type << 16);\r\naddr |= (isclamp << 17);\r\nstride = type ? 4 : 6;\r\nDRM_DEBUG("r500fp %d %d type: %d\n", sz, addr, type);\r\nif (!sz)\r\nreturn 0;\r\nif (sz * stride * 4 > drm_buffer_unprocessed(cmdbuf->buffer))\r\nreturn -EINVAL;\r\nBEGIN_RING(3 + sz * stride);\r\nOUT_RING_REG(R500_GA_US_VECTOR_INDEX, addr);\r\nOUT_RING(CP_PACKET0_TABLE(R500_GA_US_VECTOR_DATA, sz * stride - 1));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz * stride);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nint r300_do_cp_cmdbuf(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = file_priv->master->driver_priv;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf = NULL;\r\nint emit_dispatch_age = 0;\r\nint ret = 0;\r\nDRM_DEBUG("\n");\r\nr300_pacify(dev_priv);\r\nif (cmdbuf->nbox <= R300_SIMULTANEOUS_CLIPRECTS) {\r\nret = r300_emit_cliprects(dev_priv, cmdbuf, 0);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\nwhile (drm_buffer_unprocessed(cmdbuf->buffer)\r\n>= sizeof(drm_r300_cmd_header_t)) {\r\nint idx;\r\ndrm_r300_cmd_header_t *header, stack_header;\r\nheader = drm_buffer_read_object(cmdbuf->buffer,\r\nsizeof(stack_header), &stack_header);\r\nswitch (header->header.cmd_type) {\r\ncase R300_CMD_PACKET0:\r\nDRM_DEBUG("R300_CMD_PACKET0\n");\r\nret = r300_emit_packet0(dev_priv, cmdbuf, *header);\r\nif (ret) {\r\nDRM_ERROR("r300_emit_packet0 failed\n");\r\ngoto cleanup;\r\n}\r\nbreak;\r\ncase R300_CMD_VPU:\r\nDRM_DEBUG("R300_CMD_VPU\n");\r\nret = r300_emit_vpu(dev_priv, cmdbuf, *header);\r\nif (ret) {\r\nDRM_ERROR("r300_emit_vpu failed\n");\r\ngoto cleanup;\r\n}\r\nbreak;\r\ncase R300_CMD_PACKET3:\r\nDRM_DEBUG("R300_CMD_PACKET3\n");\r\nret = r300_emit_packet3(dev_priv, cmdbuf, *header);\r\nif (ret) {\r\nDRM_ERROR("r300_emit_packet3 failed\n");\r\ngoto cleanup;\r\n}\r\nbreak;\r\ncase R300_CMD_END3D:\r\nDRM_DEBUG("R300_CMD_END3D\n");\r\nr300_pacify(dev_priv);\r\nbreak;\r\ncase R300_CMD_CP_DELAY:\r\nDRM_DEBUG("R300_CMD_CP_DELAY\n");\r\n{\r\nint i;\r\nRING_LOCALS;\r\nBEGIN_RING(header->delay.count);\r\nfor (i = 0; i < header->delay.count; i++)\r\nOUT_RING(RADEON_CP_PACKET2);\r\nADVANCE_RING();\r\n}\r\nbreak;\r\ncase R300_CMD_DMA_DISCARD:\r\nDRM_DEBUG("RADEON_CMD_DMA_DISCARD\n");\r\nidx = header->dma.buf_idx;\r\nif (idx < 0 || idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nidx, dma->buf_count - 1);\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nbuf = dma->buflist[idx];\r\nif (buf->file_priv != file_priv || buf->pending) {\r\nDRM_ERROR("bad buffer %p %p %d\n",\r\nbuf->file_priv, file_priv,\r\nbuf->pending);\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nemit_dispatch_age = 1;\r\nr300_discard_buffer(dev, file_priv->master, buf);\r\nbreak;\r\ncase R300_CMD_WAIT:\r\nDRM_DEBUG("R300_CMD_WAIT\n");\r\nr300_cmd_wait(dev_priv, *header);\r\nbreak;\r\ncase R300_CMD_SCRATCH:\r\nDRM_DEBUG("R300_CMD_SCRATCH\n");\r\nret = r300_scratch(dev_priv, cmdbuf, *header);\r\nif (ret) {\r\nDRM_ERROR("r300_scratch failed\n");\r\ngoto cleanup;\r\n}\r\nbreak;\r\ncase R300_CMD_R500FP:\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) < CHIP_RV515) {\r\nDRM_ERROR("Calling r500 command on r300 card\n");\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nDRM_DEBUG("R300_CMD_R500FP\n");\r\nret = r300_emit_r500fp(dev_priv, cmdbuf, *header);\r\nif (ret) {\r\nDRM_ERROR("r300_emit_r500fp failed\n");\r\ngoto cleanup;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("bad cmd_type %i at byte %d\n",\r\nheader->header.cmd_type,\r\ncmdbuf->buffer->iterator - (int)sizeof(*header));\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\n}\r\nDRM_DEBUG("END\n");\r\ncleanup:\r\nr300_pacify(dev_priv);\r\nif (emit_dispatch_age) {\r\nRING_LOCALS;\r\nBEGIN_RING(2);\r\nRADEON_DISPATCH_AGE(master_priv->sarea_priv->last_dispatch);\r\nADVANCE_RING();\r\n}\r\nCOMMIT_RING();\r\nreturn ret;\r\n}
