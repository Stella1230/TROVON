int sst_get_stream_params(int str_id,\r\nstruct snd_sst_get_stream_params *get_params)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct stream_info *str_info;\r\nstruct snd_sst_fw_get_stream_params *fw_params;\r\npr_debug("get_stream for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->status != STREAM_UN_INIT) {\r\nif (str_info->ctrl_blk.on == true) {\r\npr_err("control path in use\n");\r\nreturn -EINVAL;\r\n}\r\nif (sst_create_short_msg(&msg)) {\r\npr_err("message creation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfw_params = kzalloc(sizeof(*fw_params), GFP_ATOMIC);\r\nif (!fw_params) {\r\npr_err("mem allocation failed\n");\r\nkfree(msg);\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_GET_STREAM_PARAMS,\r\n0, str_id);\r\nstr_info->ctrl_blk.condition = false;\r\nstr_info->ctrl_blk.ret_code = 0;\r\nstr_info->ctrl_blk.on = true;\r\nstr_info->ctrl_blk.data = (void *) fw_params;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&str_info->ctrl_blk, SST_BLOCK_TIMEOUT);\r\nif (retval) {\r\nget_params->codec_params.result = retval;\r\nkfree(fw_params);\r\nreturn -EIO;\r\n}\r\nmemcpy(&get_params->pcm_params, &fw_params->pcm_params,\r\nsizeof(fw_params->pcm_params));\r\nmemcpy(&get_params->codec_params.sparams,\r\n&fw_params->codec_params,\r\nsizeof(fw_params->codec_params));\r\nget_params->codec_params.result = 0;\r\nget_params->codec_params.stream_id = str_id;\r\nget_params->codec_params.codec = str_info->codec;\r\nget_params->codec_params.ops = str_info->ops;\r\nget_params->codec_params.stream_type = str_info->str_type;\r\nkfree(fw_params);\r\n} else {\r\npr_debug("Stream is not in the init state\n");\r\n}\r\nreturn retval;\r\n}\r\nint sst_set_stream_param(int str_id, struct snd_sst_params *str_param)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct stream_info *str_info;\r\nBUG_ON(!str_param);\r\nif (sst_drv_ctx->streams[str_id].ops != str_param->ops) {\r\npr_err("Invalid operation\n");\r\nreturn -EINVAL;\r\n}\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\npr_debug("set_stream for %d\n", str_id);\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (sst_drv_ctx->streams[str_id].status == STREAM_INIT) {\r\nif (str_info->ctrl_blk.on == true) {\r\npr_err("control path in use\n");\r\nreturn -EAGAIN;\r\n}\r\nif (sst_create_large_msg(&msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&msg->header,\r\nIPC_IA_SET_STREAM_PARAMS, 1, str_id);\r\nstr_info->ctrl_blk.condition = false;\r\nstr_info->ctrl_blk.ret_code = 0;\r\nstr_info->ctrl_blk.on = true;\r\nmsg->header.part.data = sizeof(u32) +\r\nsizeof(str_param->sparams);\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), &str_param->sparams,\r\nsizeof(str_param->sparams));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&str_info->ctrl_blk, SST_BLOCK_TIMEOUT);\r\nif (retval < 0) {\r\nretval = -EIO;\r\nsst_clean_stream(str_info);\r\n}\r\n} else {\r\nretval = -EBADRQC;\r\npr_err("BADQRC for stream\n");\r\n}\r\nreturn retval;\r\n}\r\nint sst_get_vol(struct snd_sst_vol *get_vol)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct snd_sst_vol *fw_get_vol;\r\nint str_id = get_vol->stream_id;\r\npr_debug("get vol called\n");\r\nif (sst_create_short_msg(&msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&msg->header,\r\nIPC_IA_GET_STREAM_VOL, 0, str_id);\r\nsst_drv_ctx->vol_info_blk.condition = false;\r\nsst_drv_ctx->vol_info_blk.ret_code = 0;\r\nsst_drv_ctx->vol_info_blk.on = true;\r\nfw_get_vol = kzalloc(sizeof(*fw_get_vol), GFP_ATOMIC);\r\nif (!fw_get_vol) {\r\npr_err("mem allocation failed\n");\r\nkfree(msg);\r\nreturn -ENOMEM;\r\n}\r\nsst_drv_ctx->vol_info_blk.data = (void *)fw_get_vol;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&sst_drv_ctx->vol_info_blk, SST_BLOCK_TIMEOUT);\r\nif (retval)\r\nretval = -EIO;\r\nelse {\r\npr_debug("stream id %d\n", fw_get_vol->stream_id);\r\npr_debug("volume %d\n", fw_get_vol->volume);\r\npr_debug("ramp duration %d\n", fw_get_vol->ramp_duration);\r\npr_debug("ramp_type %d\n", fw_get_vol->ramp_type);\r\nmemcpy(get_vol, fw_get_vol, sizeof(*fw_get_vol));\r\n}\r\nreturn retval;\r\n}\r\nint sst_set_vol(struct snd_sst_vol *set_vol)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\npr_debug("set vol called\n");\r\nif (sst_create_large_msg(&msg)) {\r\npr_err("message creation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_SET_STREAM_VOL, 1,\r\nset_vol->stream_id);\r\nmsg->header.part.data = sizeof(u32) + sizeof(*set_vol);\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), set_vol, sizeof(*set_vol));\r\nsst_drv_ctx->vol_info_blk.condition = false;\r\nsst_drv_ctx->vol_info_blk.ret_code = 0;\r\nsst_drv_ctx->vol_info_blk.on = true;\r\nsst_drv_ctx->vol_info_blk.data = set_vol;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&sst_drv_ctx->vol_info_blk, SST_BLOCK_TIMEOUT);\r\nif (retval) {\r\npr_err("error in set_vol = %d\n", retval);\r\nretval = -EIO;\r\n}\r\nreturn retval;\r\n}\r\nint sst_set_mute(struct snd_sst_mute *set_mute)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\npr_debug("set mute called\n");\r\nif (sst_create_large_msg(&msg)) {\r\npr_err("message creation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_SET_STREAM_MUTE, 1,\r\nset_mute->stream_id);\r\nsst_drv_ctx->mute_info_blk.condition = false;\r\nsst_drv_ctx->mute_info_blk.ret_code = 0;\r\nsst_drv_ctx->mute_info_blk.on = true;\r\nsst_drv_ctx->mute_info_blk.data = set_mute;\r\nmsg->header.part.data = sizeof(u32) + sizeof(*set_mute);\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), set_mute,\r\nsizeof(*set_mute));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&sst_drv_ctx->mute_info_blk, SST_BLOCK_TIMEOUT);\r\nif (retval) {\r\npr_err("error in set_mute = %d\n", retval);\r\nretval = -EIO;\r\n}\r\nreturn retval;\r\n}\r\nint sst_prepare_target(struct snd_sst_slot_info *slot)\r\n{\r\nif (slot->target_device == SND_SST_TARGET_PMIC\r\n&& slot->device_instance == 1) {\r\nif (sst_drv_ctx->pmic_port_instance == 0)\r\nsst_drv_ctx->scard_ops->set_voice_port(\r\nDEACTIVATE);\r\n} else if ((slot->target_device == SND_SST_TARGET_PMIC ||\r\nslot->target_device == SND_SST_TARGET_MODEM) &&\r\nslot->device_instance == 0) {\r\nif (sst_drv_ctx->pmic_port_instance == 1)\r\nsst_drv_ctx->scard_ops->set_audio_port(\r\nDEACTIVATE);\r\n}\r\nreturn 0;\r\n}\r\nint sst_activate_target(struct snd_sst_slot_info *slot)\r\n{\r\nif (slot->target_device == SND_SST_TARGET_PMIC &&\r\nslot->device_instance == 1) {\r\nsst_drv_ctx->pmic_port_instance = 1;\r\nsst_drv_ctx->scard_ops->set_audio_port(ACTIVATE);\r\nsst_drv_ctx->scard_ops->set_pcm_audio_params(\r\nslot->pcm_params.sfreq,\r\nslot->pcm_params.pcm_wd_sz,\r\nslot->pcm_params.num_chan);\r\nif (sst_drv_ctx->pb_streams)\r\nsst_drv_ctx->scard_ops->power_up_pmic_pb(1);\r\nif (sst_drv_ctx->cp_streams)\r\nsst_drv_ctx->scard_ops->power_up_pmic_cp(1);\r\n} else if ((slot->target_device == SND_SST_TARGET_PMIC ||\r\nslot->target_device == SND_SST_TARGET_MODEM) &&\r\nslot->device_instance == 0) {\r\nsst_drv_ctx->pmic_port_instance = 0;\r\nsst_drv_ctx->scard_ops->set_voice_port(\r\nACTIVATE);\r\nsst_drv_ctx->scard_ops->power_up_pmic_pb(0);\r\n}\r\nreturn 0;\r\n}\r\nint sst_parse_target(struct snd_sst_slot_info *slot)\r\n{\r\nint retval = 0;\r\nif (slot->action == SND_SST_PORT_ACTIVATE &&\r\nslot->device_type == SND_SST_DEVICE_PCM) {\r\nretval = sst_activate_target(slot);\r\nif (retval)\r\npr_err("SST_Activate_target_fail\n");\r\nelse\r\npr_err("SST_Activate_target_pass\n");\r\n} else if (slot->action == SND_SST_PORT_PREPARE &&\r\nslot->device_type == SND_SST_DEVICE_PCM) {\r\nretval = sst_prepare_target(slot);\r\nif (retval)\r\npr_err("SST_prepare_target_fail\n");\r\nelse\r\npr_err("SST_prepare_target_pass\n");\r\n} else {\r\npr_err("slot_action : %d, device_type: %d\n",\r\nslot->action, slot->device_type);\r\n}\r\nreturn retval;\r\n}\r\nint sst_send_target(struct snd_sst_target_device *target)\r\n{\r\nint retval;\r\nstruct ipc_post *msg;\r\nif (sst_create_large_msg(&msg)) {\r\npr_err("message creation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_TARGET_DEV_SELECT, 1, 0);\r\nsst_drv_ctx->tgt_dev_blk.condition = false;\r\nsst_drv_ctx->tgt_dev_blk.ret_code = 0;\r\nsst_drv_ctx->tgt_dev_blk.on = true;\r\nmsg->header.part.data = sizeof(u32) + sizeof(*target);\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), target,\r\nsizeof(*target));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\npr_debug("message sent- waiting\n");\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&sst_drv_ctx->tgt_dev_blk, TARGET_DEV_BLOCK_TIMEOUT);\r\nif (retval)\r\npr_err("target device ipc failed = 0x%x\n", retval);\r\nreturn retval;\r\n}\r\nint sst_target_device_validate(struct snd_sst_target_device *target)\r\n{\r\nint retval = 0;\r\nint i;\r\nfor (i = 0; i < SST_MAX_TARGET_DEVICES; i++) {\r\nif (target->devices[i].device_type == SND_SST_DEVICE_PCM) {\r\nif (target->devices[i].device_instance == 1) {\r\nif ((target->devices[i].device_mode !=\r\nSND_SST_DEV_MODE_PCM_MODE4_I2S) &&\r\n(target->devices[i].device_mode !=\r\nSND_SST_DEV_MODE_PCM_MODE4_RIGHT_JUSTIFIED)\r\n&& (target->devices[i].device_mode !=\r\nSND_SST_DEV_MODE_PCM_MODE1))\r\ngoto err;\r\n} else if (target->devices[i].device_instance == 0) {\r\nif ((target->devices[i].device_mode !=\r\nSND_SST_DEV_MODE_PCM_MODE2)\r\n&& (target->devices[i].device_mode !=\r\nSND_SST_DEV_MODE_PCM_MODE4_I2S)\r\n&& (target->devices[i].device_mode !=\r\nSND_SST_DEV_MODE_PCM_MODE1))\r\ngoto err;\r\nif (target->devices[i].pcm_params.sfreq != 8000\r\n|| target->devices[i].pcm_params.num_chan != 1\r\n|| target->devices[i].pcm_params.pcm_wd_sz !=\r\n16)\r\ngoto err;\r\n} else {\r\nerr:\r\npr_err("i/p params incorrect\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nint sst_target_device_select(struct snd_sst_target_device *target)\r\n{\r\nint retval, i, prepare_count = 0;\r\npr_debug("Target Device Select\n");\r\nif (target->device_route < 0 || target->device_route > 2) {\r\npr_err("device route is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif (target->device_route != 0) {\r\npr_err("Unsupported config\n");\r\nreturn -EIO;\r\n}\r\nretval = sst_target_device_validate(target);\r\nif (retval)\r\nreturn retval;\r\nretval = sst_send_target(target);\r\nif (retval)\r\nreturn retval;\r\nfor (i = 0; i < SST_MAX_TARGET_DEVICES; i++) {\r\nif (target->devices[i].action == SND_SST_PORT_ACTIVATE) {\r\npr_debug("activate called in %d\n", i);\r\nretval = sst_parse_target(&target->devices[i]);\r\nif (retval)\r\nreturn retval;\r\n} else if (target->devices[i].action == SND_SST_PORT_PREPARE) {\r\npr_debug("PREPARE in %d, Forwarding\n", i);\r\nretval = sst_parse_target(&target->devices[i]);\r\nif (retval) {\r\npr_err("Parse Target fail %d\n", retval);\r\nreturn retval;\r\n}\r\npr_debug("Parse Target successful %d\n", retval);\r\nif (target->devices[i].device_type ==\r\nSND_SST_DEVICE_PCM)\r\nprepare_count++;\r\n}\r\n}\r\nif (target->devices[0].action == SND_SST_PORT_PREPARE &&\r\nprepare_count == 0)\r\nsst_drv_ctx->scard_ops->power_down_pmic();\r\nreturn retval;\r\n}\r\nstatic inline int sst_get_RAR(struct RAR_buffer *buffers, int count)\r\n{\r\nint retval = 0, rar_status = 0;\r\nrar_status = rar_handle_to_bus(buffers, count);\r\nif (count != rar_status) {\r\npr_err("The rar CALL Failed");\r\nretval = -EIO;\r\n}\r\nif (buffers->info.type != RAR_TYPE_AUDIO) {\r\npr_err("Invalid RAR type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic int sst_create_sg_list(struct stream_info *stream,\r\nstruct sst_frame_info *sg_list)\r\n{\r\nstruct sst_stream_bufs *kbufs = NULL;\r\n#ifdef CONFIG_MRST_RAR_HANDLER\r\nstruct RAR_buffer rar_buffers;\r\nint retval = 0;\r\n#endif\r\nint i = 0;\r\nlist_for_each_entry(kbufs, &stream->bufs, node) {\r\nif (kbufs->in_use == false) {\r\n#ifdef CONFIG_MRST_RAR_HANDLER\r\nif (stream->ops == STREAM_OPS_PLAYBACK_DRM) {\r\npr_debug("DRM playback handling\n");\r\nrar_buffers.info.handle = (__u32)kbufs->addr;\r\nrar_buffers.info.size = kbufs->size;\r\npr_debug("rar handle 0x%x size=0x%x\n",\r\nrar_buffers.info.handle,\r\nrar_buffers.info.size);\r\nretval = sst_get_RAR(&rar_buffers, 1);\r\nif (retval)\r\nreturn retval;\r\nsg_list->addr[i].addr = rar_buffers.bus_address;\r\nsg_list->addr[i].size = (__u32)kbufs->size;\r\npr_debug("phyaddr[%d] 0x%x Size:0x%x\n"\r\n, i, sg_list->addr[i].addr,\r\nsg_list->addr[i].size);\r\n}\r\n#endif\r\nif (stream->ops != STREAM_OPS_PLAYBACK_DRM) {\r\nsg_list->addr[i].addr =\r\nvirt_to_phys((void *)\r\nkbufs->addr + kbufs->offset);\r\nsg_list->addr[i].size = kbufs->size;\r\npr_debug("phyaddr[%d]:0x%x Size:0x%x\n"\r\n, i , sg_list->addr[i].addr, kbufs->size);\r\n}\r\nstream->curr_bytes += sg_list->addr[i].size;\r\nkbufs->in_use = true;\r\ni++;\r\n}\r\nif (i >= MAX_NUM_SCATTER_BUFFERS)\r\nbreak;\r\n}\r\nsg_list->num_entries = i;\r\npr_debug("sg list entries = %d\n", sg_list->num_entries);\r\nreturn i;\r\n}\r\nint sst_play_frame(int str_id)\r\n{\r\nint i = 0, retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct sst_frame_info sg_list = {0};\r\nstruct sst_stream_bufs *kbufs = NULL, *_kbufs;\r\nstruct stream_info *stream;\r\npr_debug("play frame for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstream = &sst_drv_ctx->streams[str_id];\r\nlist_for_each_entry_safe(kbufs, _kbufs, &stream->bufs, node) {\r\nif (kbufs->in_use == true) {\r\nspin_lock(&stream->pcm_lock);\r\nlist_del(&kbufs->node);\r\nspin_unlock(&stream->pcm_lock);\r\nkfree(kbufs);\r\n}\r\n}\r\nstream->cumm_bytes += stream->curr_bytes;\r\nstream->curr_bytes = 0;\r\nif (list_empty(&stream->bufs)) {\r\npr_debug("Null buffer stream status %d\n", stream->status);\r\nstream->prev = stream->status;\r\nstream->status = STREAM_INIT;\r\npr_debug("new stream status = %d\n", stream->status);\r\nif (stream->need_draining == true) {\r\npr_debug("draining stream\n");\r\nif (sst_create_short_msg(&msg)) {\r\npr_err("mem allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_DRAIN_STREAM,\r\n0, str_id);\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node,\r\n&sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\n} else if (stream->data_blk.on == true) {\r\npr_debug("user list empty.. wake\n");\r\nstream->data_blk.ret_code = 0;\r\nstream->data_blk.condition = true;\r\nstream->data_blk.on = false;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nreturn 0;\r\n}\r\ni = sst_create_sg_list(stream, &sg_list);\r\nif (sst_create_large_msg(&msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&msg->header, IPC_IA_PLAY_FRAMES, 1, str_id);\r\nmsg->header.part.data = sizeof(u32) + sizeof(sg_list);\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), &sg_list, sizeof(sg_list));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nreturn 0;\r\n}\r\nint sst_capture_frame(int str_id)\r\n{\r\nint i = 0, retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nstruct sst_frame_info sg_list = {0};\r\nstruct sst_stream_bufs *kbufs = NULL, *_kbufs;\r\nstruct stream_info *stream;\r\npr_debug("capture frame for %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstream = &sst_drv_ctx->streams[str_id];\r\nlist_for_each_entry_safe(kbufs, _kbufs, &stream->bufs, node) {\r\nif (kbufs->in_use == true) {\r\nlist_del(&kbufs->node);\r\nkfree(kbufs);\r\npr_debug("del node\n");\r\n}\r\n}\r\nif (list_empty(&stream->bufs)) {\r\npr_debug("Null buffer!!!!stream status %d\n",\r\nstream->status);\r\nstream->prev = stream->status;\r\nstream->status = STREAM_INIT;\r\npr_debug("new stream status = %d\n",\r\nstream->status);\r\nif (stream->data_blk.on == true) {\r\npr_debug("user list empty.. wake\n");\r\nstream->data_blk.ret_code = 0;\r\nstream->data_blk.condition = true;\r\nstream->data_blk.on = false;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\n}\r\nreturn 0;\r\n}\r\ni = sst_create_sg_list(stream, &sg_list);\r\nif (sst_create_large_msg(&msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&msg->header, IPC_IA_CAPT_FRAMES, 1, str_id);\r\nmsg->header.part.data = sizeof(u32) + sizeof(sg_list);\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), &sg_list, sizeof(sg_list));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nstream->cumm_bytes += stream->curr_bytes;\r\nstream->curr_bytes = 0;\r\npr_debug("Cum bytes = %d\n", stream->cumm_bytes);\r\nreturn 0;\r\n}\r\nstatic unsigned int calculate_min_size(struct snd_sst_buffs *bufs)\r\n{\r\nint i, min_val = bufs->buff_entry[0].size;\r\nfor (i = 1 ; i < bufs->entries; i++) {\r\nif (bufs->buff_entry[i].size < min_val)\r\nmin_val = bufs->buff_entry[i].size;\r\n}\r\npr_debug("min_val = %d\n", min_val);\r\nreturn min_val;\r\n}\r\nstatic unsigned int calculate_max_size(struct snd_sst_buffs *bufs)\r\n{\r\nint i, max_val = bufs->buff_entry[0].size;\r\nfor (i = 1 ; i < bufs->entries; i++) {\r\nif (bufs->buff_entry[i].size > max_val)\r\nmax_val = bufs->buff_entry[i].size;\r\n}\r\npr_debug("max_val = %d\n", max_val);\r\nreturn max_val;\r\n}\r\nstatic int sst_allocate_decode_buf(struct stream_info *str_info,\r\nstruct snd_sst_dbufs *dbufs,\r\nunsigned int cum_input_given,\r\nunsigned int cum_output_given)\r\n{\r\n#ifdef CONFIG_MRST_RAR_HANDLER\r\nif (str_info->ops == STREAM_OPS_PLAYBACK_DRM) {\r\nif (dbufs->ibufs->type == SST_BUF_RAR &&\r\ndbufs->obufs->type == SST_BUF_RAR) {\r\nif (dbufs->ibufs->entries == dbufs->obufs->entries)\r\nreturn 0;\r\nelse {\r\npr_err("RAR entries dont match\n");\r\nreturn -EINVAL;\r\n}\r\n} else\r\nstr_info->decode_osize = cum_output_given;\r\nreturn 0;\r\n}\r\n#endif\r\nif (!str_info->decode_ibuf) {\r\npr_debug("no i/p buffers, trying full size\n");\r\nstr_info->decode_isize = cum_input_given;\r\nstr_info->decode_ibuf = kzalloc(str_info->decode_isize,\r\nGFP_KERNEL);\r\nstr_info->idecode_alloc = str_info->decode_isize;\r\n}\r\nif (!str_info->decode_ibuf) {\r\npr_debug("buff alloc failed, try max size\n");\r\nstr_info->decode_isize = calculate_max_size(dbufs->ibufs);\r\nstr_info->decode_ibuf = kzalloc(\r\nstr_info->decode_isize, GFP_KERNEL);\r\nstr_info->idecode_alloc = str_info->decode_isize;\r\n}\r\nif (!str_info->decode_ibuf) {\r\npr_debug("buff alloc failed, try min size\n");\r\nstr_info->decode_isize = calculate_min_size(dbufs->ibufs);\r\nstr_info->decode_ibuf = kzalloc(str_info->decode_isize,\r\nGFP_KERNEL);\r\nif (!str_info->decode_ibuf) {\r\npr_err("mem allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nstr_info->idecode_alloc = str_info->decode_isize;\r\n}\r\nstr_info->decode_osize = cum_output_given;\r\nif (str_info->decode_osize > sst_drv_ctx->mmap_len)\r\nstr_info->decode_osize = sst_drv_ctx->mmap_len;\r\nreturn 0;\r\n}\r\nstatic int sst_send_decode_mess(int str_id, struct stream_info *str_info,\r\nstruct snd_sst_decode_info *dec_info)\r\n{\r\nstruct ipc_post *msg = NULL;\r\nint retval = 0;\r\npr_debug("SST DBG:sst_set_mute:called\n");\r\nif (str_info->decode_ibuf_type == SST_BUF_RAR) {\r\n#ifdef CONFIG_MRST_RAR_HANDLER\r\ndec_info->frames_in.addr[0].addr =\r\n(unsigned long)str_info->decode_ibuf;\r\ndec_info->frames_in.addr[0].size =\r\nstr_info->decode_isize;\r\n#endif\r\n} else {\r\ndec_info->frames_in.addr[0].addr = virt_to_phys((void *)\r\nstr_info->decode_ibuf);\r\ndec_info->frames_in.addr[0].size = str_info->decode_isize;\r\n}\r\nif (str_info->decode_obuf_type == SST_BUF_RAR) {\r\n#ifdef CONFIG_MRST_RAR_HANDLER\r\ndec_info->frames_out.addr[0].addr =\r\n(unsigned long)str_info->decode_obuf;\r\ndec_info->frames_out.addr[0].size = str_info->decode_osize;\r\n#endif\r\n} else {\r\ndec_info->frames_out.addr[0].addr = virt_to_phys((void *)\r\nstr_info->decode_obuf) ;\r\ndec_info->frames_out.addr[0].size = str_info->decode_osize;\r\n}\r\ndec_info->frames_in.num_entries = 1;\r\ndec_info->frames_out.num_entries = 1;\r\ndec_info->frames_in.rsrvd = 0;\r\ndec_info->frames_out.rsrvd = 0;\r\ndec_info->input_bytes_consumed = 0;\r\ndec_info->output_bytes_produced = 0;\r\nif (sst_create_large_msg(&msg)) {\r\npr_err("message creation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsst_fill_header(&msg->header, IPC_IA_DECODE_FRAMES, 1, str_id);\r\nmsg->header.part.data = sizeof(u32) + sizeof(*dec_info);\r\nmemcpy(msg->mailbox_data, &msg->header, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), dec_info,\r\nsizeof(*dec_info));\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nstr_info->data_blk.condition = false;\r\nstr_info->data_blk.ret_code = 0;\r\nstr_info->data_blk.on = true;\r\nstr_info->data_blk.data = dec_info;\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible(sst_drv_ctx, &str_info->data_blk);\r\nreturn retval;\r\n}\r\nstatic int sst_prepare_input_buffers_rar(struct stream_info *str_info,\r\nstruct snd_sst_dbufs *dbufs,\r\nint *input_index, int *in_copied,\r\nint *input_index_valid_size, int *new_entry_flag)\r\n{\r\nint retval = 0, i;\r\nif (str_info->ops == STREAM_OPS_PLAYBACK_DRM) {\r\nstruct RAR_buffer rar_buffers;\r\n__u32 info;\r\nretval = copy_from_user((void *) &info,\r\ndbufs->ibufs->buff_entry[i].buffer,\r\nsizeof(__u32));\r\nif (retval) {\r\npr_err("cpy from user fail\n");\r\nreturn -EAGAIN;\r\n}\r\nrar_buffers.info.type = dbufs->ibufs->type;\r\nrar_buffers.info.size = dbufs->ibufs->buff_entry[i].size;\r\nrar_buffers.info.handle = info;\r\npr_debug("rar in DnR(input buffer function)=0x%x size=0x%x",\r\nrar_buffers.info.handle,\r\nrar_buffers.info.size);\r\nretval = sst_get_RAR(&rar_buffers, 1);\r\nif (retval) {\r\npr_debug("SST ERR: RAR API failed\n");\r\nreturn retval;\r\n}\r\nstr_info->decode_ibuf =\r\n(void *) ((unsigned long) rar_buffers.bus_address);\r\npr_debug("RAR buf addr in DnR (input buffer function)0x%lu",\r\n(unsigned long) str_info->decode_ibuf);\r\npr_debug("rar in DnR decode function/output b_add rar =0x%lu",\r\n(unsigned long) rar_buffers.bus_address);\r\n*input_index = i + 1;\r\nstr_info->decode_isize = dbufs->ibufs->buff_entry[i].size;\r\nstr_info->decode_ibuf_type = dbufs->ibufs->type;\r\n*in_copied = str_info->decode_isize;\r\n}\r\nreturn retval;\r\n}\r\nstatic int sst_prepare_input_buffers(struct stream_info *str_info,\r\nstruct snd_sst_dbufs *dbufs,\r\nint *input_index, int *in_copied,\r\nint *input_index_valid_size, int *new_entry_flag)\r\n{\r\nint i, cpy_size, retval = 0;\r\npr_debug("input_index = %d, input entries = %d\n",\r\n*input_index, dbufs->ibufs->entries);\r\nfor (i = *input_index; i < dbufs->ibufs->entries; i++) {\r\n#ifdef CONFIG_MRST_RAR_HANDLER\r\nretval = sst_prepare_input_buffers_rar(str_info,\r\ndbufs, input_index, in_copied,\r\ninput_index_valid_size, new_entry_flag);\r\nif (retval) {\r\npr_err("In prepare input buffers for RAR\n");\r\nreturn -EIO;\r\n}\r\n#endif\r\n*input_index = i;\r\nif (*input_index_valid_size == 0)\r\n*input_index_valid_size =\r\ndbufs->ibufs->buff_entry[i].size;\r\npr_debug("inout addr = %p, size = %d\n",\r\ndbufs->ibufs->buff_entry[i].buffer,\r\n*input_index_valid_size);\r\npr_debug("decode_isize = %d, in_copied %d\n",\r\nstr_info->decode_isize, *in_copied);\r\nif (*input_index_valid_size <=\r\n(str_info->decode_isize - *in_copied))\r\ncpy_size = *input_index_valid_size;\r\nelse\r\ncpy_size = str_info->decode_isize - *in_copied;\r\npr_debug("cpy size = %d\n", cpy_size);\r\nif (!dbufs->ibufs->buff_entry[i].buffer) {\r\npr_err("i/p buffer is null\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("Try copy To %p, From %p, size %d\n",\r\nstr_info->decode_ibuf + *in_copied,\r\ndbufs->ibufs->buff_entry[i].buffer, cpy_size);\r\nretval =\r\ncopy_from_user((void *)(str_info->decode_ibuf + *in_copied),\r\n(void *) dbufs->ibufs->buff_entry[i].buffer,\r\ncpy_size);\r\nif (retval) {\r\npr_err("copy from user failed\n");\r\nreturn -EIO;\r\n}\r\n*in_copied += cpy_size;\r\n*input_index_valid_size -= cpy_size;\r\npr_debug("in buff size = %d, in_copied = %d\n",\r\n*input_index_valid_size, *in_copied);\r\nif (*input_index_valid_size != 0) {\r\npr_debug("more input buffers left\n");\r\ndbufs->ibufs->buff_entry[i].buffer += cpy_size;\r\nbreak;\r\n}\r\nif (*in_copied == str_info->decode_isize &&\r\n*input_index_valid_size == 0 &&\r\n(i+1) <= dbufs->ibufs->entries) {\r\npr_debug("all input buffers copied\n");\r\n*new_entry_flag = true;\r\n*input_index = i + 1;\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int sst_prepare_output_buffers(struct stream_info *str_info,\r\nstruct snd_sst_dbufs *dbufs,\r\nint *output_index, int output_size,\r\nint *out_copied)\r\n{\r\nint i, cpy_size, retval = 0;\r\npr_debug("output_index = %d, output entries = %d\n",\r\n*output_index,\r\ndbufs->obufs->entries);\r\nfor (i = *output_index; i < dbufs->obufs->entries; i++) {\r\n*output_index = i;\r\npr_debug("output addr = %p, size = %d\n",\r\ndbufs->obufs->buff_entry[i].buffer,\r\ndbufs->obufs->buff_entry[i].size);\r\npr_debug("output_size = %d, out_copied = %d\n",\r\noutput_size, *out_copied);\r\nif (dbufs->obufs->buff_entry[i].size <\r\n(output_size - *out_copied))\r\ncpy_size = dbufs->obufs->buff_entry[i].size;\r\nelse\r\ncpy_size = output_size - *out_copied;\r\npr_debug("cpy size = %d\n", cpy_size);\r\npr_debug("Try copy To: %p, From %p, size %d\n",\r\ndbufs->obufs->buff_entry[i].buffer,\r\nsst_drv_ctx->mmap_mem + *out_copied,\r\ncpy_size);\r\nretval = copy_to_user(dbufs->obufs->buff_entry[i].buffer,\r\nsst_drv_ctx->mmap_mem + *out_copied,\r\ncpy_size);\r\nif (retval) {\r\npr_err("copy to user failed\n");\r\nreturn -EIO;\r\n} else\r\npr_debug("copy to user passed\n");\r\n*out_copied += cpy_size;\r\ndbufs->obufs->buff_entry[i].size -= cpy_size;\r\npr_debug("o/p buff size %d, out_copied %d\n",\r\ndbufs->obufs->buff_entry[i].size, *out_copied);\r\nif (dbufs->obufs->buff_entry[i].size != 0) {\r\n*output_index = i;\r\ndbufs->obufs->buff_entry[i].buffer += cpy_size;\r\nbreak;\r\n} else if (*out_copied == output_size) {\r\n*output_index = i + 1;\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nint sst_decode(int str_id, struct snd_sst_dbufs *dbufs)\r\n{\r\nint retval = 0, i;\r\nunsigned long long total_input = 0 , total_output = 0;\r\nunsigned int cum_input_given = 0 , cum_output_given = 0;\r\nint copy_in_done = false, copy_out_done = false;\r\nint input_index = 0, output_index = 0;\r\nint input_index_valid_size = 0;\r\nint in_copied, out_copied;\r\nint new_entry_flag;\r\nu64 output_size;\r\nstruct stream_info *str_info;\r\nstruct snd_sst_decode_info dec_info;\r\nunsigned long long input_bytes, output_bytes;\r\nsst_drv_ctx->scard_ops->power_down_pmic();\r\npr_debug("Powering_down_PMIC...\n");\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn retval;\r\nstr_info = &sst_drv_ctx->streams[str_id];\r\nif (str_info->status != STREAM_INIT) {\r\npr_err("invalid stream state = %d\n",\r\nstr_info->status);\r\nreturn -EINVAL;\r\n}\r\nstr_info->prev = str_info->status;\r\nstr_info->status = STREAM_DECODE;\r\nfor (i = 0; i < dbufs->ibufs->entries; i++)\r\ncum_input_given += dbufs->ibufs->buff_entry[i].size;\r\nfor (i = 0; i < dbufs->obufs->entries; i++)\r\ncum_output_given += dbufs->obufs->buff_entry[i].size;\r\nretval = sst_allocate_decode_buf(str_info, dbufs,\r\ncum_input_given, cum_output_given);\r\nif (retval) {\r\npr_err("mem allocation failed, abort!!!\n");\r\nretval = -ENOMEM;\r\ngoto finish;\r\n}\r\nstr_info->decode_isize = str_info->idecode_alloc;\r\nstr_info->decode_ibuf_type = dbufs->ibufs->type;\r\nstr_info->decode_obuf_type = dbufs->obufs->type;\r\nwhile ((copy_out_done == false) && (copy_in_done == false)) {\r\nin_copied = 0;\r\nnew_entry_flag = false;\r\nretval = sst_prepare_input_buffers(str_info,\\r\ndbufs, &input_index, &in_copied,\r\n&input_index_valid_size, &new_entry_flag);\r\nif (retval) {\r\npr_err("prepare in buffers failed\n");\r\ngoto finish;\r\n}\r\nif (str_info->ops != STREAM_OPS_PLAYBACK_DRM)\r\nstr_info->decode_obuf = sst_drv_ctx->mmap_mem;\r\n#ifdef CONFIG_MRST_RAR_HANDLER\r\nelse {\r\nif (dbufs->obufs->type == SST_BUF_RAR) {\r\nstruct RAR_buffer rar_buffers;\r\n__u32 info;\r\npr_debug("DRM");\r\nretval = copy_from_user((void *) &info,\r\ndbufs->obufs->\r\nbuff_entry[output_index].buffer,\r\nsizeof(__u32));\r\nrar_buffers.info.size = dbufs->obufs->\r\nbuff_entry[output_index].size;\r\nrar_buffers.info.handle = info;\r\nretval = sst_get_RAR(&rar_buffers, 1);\r\nif (retval)\r\nreturn retval;\r\nstr_info->decode_obuf = (void *)((unsigned long)\r\nrar_buffers.bus_address);\r\nstr_info->decode_osize = dbufs->obufs->\r\nbuff_entry[output_index].size;\r\nstr_info->decode_obuf_type = dbufs->obufs->type;\r\npr_debug("DRM handling\n");\r\npr_debug("o/p_add=0x%lu Size=0x%x\n",\r\n(unsigned long) str_info->decode_obuf,\r\nstr_info->decode_osize);\r\n} else {\r\nstr_info->decode_obuf = sst_drv_ctx->mmap_mem;\r\nstr_info->decode_osize = dbufs->obufs->\r\nbuff_entry[output_index].size;\r\n}\r\n}\r\n#endif\r\nif (str_info->ops != STREAM_OPS_PLAYBACK_DRM) {\r\nif (str_info->decode_isize > in_copied) {\r\nstr_info->decode_isize = in_copied;\r\npr_debug("i/p size = %d\n",\r\nstr_info->decode_isize);\r\n}\r\n}\r\nretval = sst_send_decode_mess(str_id, str_info, &dec_info);\r\nif (retval || dec_info.input_bytes_consumed == 0) {\r\npr_err("SST ERR: mess failed or no input consumed\n");\r\ngoto finish;\r\n}\r\ninput_bytes = dec_info.input_bytes_consumed;\r\noutput_bytes = dec_info.output_bytes_produced;\r\npr_debug("in_copied=%d, con=%lld, prod=%lld\n",\r\nin_copied, input_bytes, output_bytes);\r\nif (dbufs->obufs->type == SST_BUF_RAR) {\r\noutput_index += 1;\r\nif (output_index == dbufs->obufs->entries) {\r\ncopy_in_done = true;\r\npr_debug("all i/p cpy done\n");\r\n}\r\ntotal_output += output_bytes;\r\n} else {\r\nout_copied = 0;\r\noutput_size = output_bytes;\r\nretval = sst_prepare_output_buffers(str_info, dbufs,\r\n&output_index, output_size, &out_copied);\r\nif (retval) {\r\npr_err("prep out buff fail\n");\r\ngoto finish;\r\n}\r\nif (str_info->ops != STREAM_OPS_PLAYBACK_DRM) {\r\nif (in_copied != input_bytes) {\r\nint bytes_left = in_copied -\r\ninput_bytes;\r\npr_debug("bytes %d\n",\r\nbytes_left);\r\nif (new_entry_flag == true)\r\ninput_index--;\r\nwhile (bytes_left) {\r\nstruct snd_sst_buffs *ibufs;\r\nstruct snd_sst_buff_entry\r\n*buff_entry;\r\nunsigned int size_sent;\r\nibufs = dbufs->ibufs;\r\nbuff_entry =\r\n&ibufs->buff_entry[input_index];\r\nsize_sent = buff_entry->size -\\r\ninput_index_valid_size;\r\nif (bytes_left == size_sent) {\r\nbytes_left = 0;\r\n} else if (bytes_left <\r\nsize_sent) {\r\nbuff_entry->buffer +=\r\n(size_sent -\r\nbytes_left);\r\nbuff_entry->size -=\r\n(size_sent -\r\nbytes_left);\r\nbytes_left = 0;\r\n} else {\r\nbytes_left -= size_sent;\r\ninput_index--;\r\ninput_index_valid_size =\r\n0;\r\n}\r\n}\r\n}\r\n}\r\ntotal_output += out_copied;\r\nif (str_info->decode_osize != out_copied) {\r\nstr_info->decode_osize -= out_copied;\r\npr_debug("output size modified = %d\n",\r\nstr_info->decode_osize);\r\n}\r\n}\r\ntotal_input += input_bytes;\r\nif (str_info->ops == STREAM_OPS_PLAYBACK_DRM) {\r\nif (total_input == cum_input_given)\r\ncopy_in_done = true;\r\ncopy_out_done = true;\r\n} else {\r\nif (total_output == cum_output_given) {\r\ncopy_out_done = true;\r\npr_debug("all o/p cpy done\n");\r\n}\r\nif (total_input == cum_input_given) {\r\ncopy_in_done = true;\r\npr_debug("all i/p cpy done\n");\r\n}\r\n}\r\npr_debug("copy_out = %d, copy_in = %d\n",\r\ncopy_out_done, copy_in_done);\r\n}\r\nfinish:\r\ndbufs->input_bytes_consumed = total_input;\r\ndbufs->output_bytes_produced = total_output;\r\nstr_info->status = str_info->prev;\r\nstr_info->prev = STREAM_DECODE;\r\nkfree(str_info->decode_ibuf);\r\nstr_info->decode_ibuf = NULL;\r\nreturn retval;\r\n}
