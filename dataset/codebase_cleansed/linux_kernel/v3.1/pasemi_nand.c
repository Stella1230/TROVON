static void pasemi_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nwhile (len > 0x800) {\r\nmemcpy_fromio(buf, chip->IO_ADDR_R, 0x800);\r\nbuf += 0x800;\r\nlen -= 0x800;\r\n}\r\nmemcpy_fromio(buf, chip->IO_ADDR_R, len);\r\n}\r\nstatic void pasemi_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nwhile (len > 0x800) {\r\nmemcpy_toio(chip->IO_ADDR_R, buf, 0x800);\r\nbuf += 0x800;\r\nlen -= 0x800;\r\n}\r\nmemcpy_toio(chip->IO_ADDR_R, buf, len);\r\n}\r\nstatic void pasemi_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nout_8(chip->IO_ADDR_W + (1 << CLE_PIN_CTL), cmd);\r\nelse\r\nout_8(chip->IO_ADDR_W + (1 << ALE_PIN_CTL), cmd);\r\neieio();\r\ninl(lpcctl);\r\n}\r\nint pasemi_device_ready(struct mtd_info *mtd)\r\n{\r\nreturn !!(inl(lpcctl) & LBICTRL_LPCCTL_NR);\r\n}\r\nstatic int __devinit pasemi_nand_probe(struct platform_device *ofdev)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct resource res;\r\nstruct nand_chip *chip;\r\nint err = 0;\r\nerr = of_address_to_resource(np, 0, &res);\r\nif (err)\r\nreturn -EINVAL;\r\nif (pasemi_nand_mtd)\r\nreturn -ENODEV;\r\npr_debug("pasemi_nand at %pR\n", &res);\r\npasemi_nand_mtd = kzalloc(sizeof(struct mtd_info) +\r\nsizeof(struct nand_chip), GFP_KERNEL);\r\nif (!pasemi_nand_mtd) {\r\nprintk(KERN_WARNING\r\n"Unable to allocate PASEMI NAND MTD device structure\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nchip = (struct nand_chip *)&pasemi_nand_mtd[1];\r\npasemi_nand_mtd->priv = chip;\r\npasemi_nand_mtd->owner = THIS_MODULE;\r\nchip->IO_ADDR_R = of_iomap(np, 0);\r\nchip->IO_ADDR_W = chip->IO_ADDR_R;\r\nif (!chip->IO_ADDR_R) {\r\nerr = -EIO;\r\ngoto out_mtd;\r\n}\r\npdev = pci_get_device(PCI_VENDOR_ID_PASEMI, 0xa008, NULL);\r\nif (!pdev) {\r\nerr = -ENODEV;\r\ngoto out_ior;\r\n}\r\nlpcctl = pci_resource_start(pdev, 0);\r\npci_dev_put(pdev);\r\nif (!request_region(lpcctl, 4, driver_name)) {\r\nerr = -EBUSY;\r\ngoto out_ior;\r\n}\r\nchip->cmd_ctrl = pasemi_hwcontrol;\r\nchip->dev_ready = pasemi_device_ready;\r\nchip->read_buf = pasemi_read_buf;\r\nchip->write_buf = pasemi_write_buf;\r\nchip->chip_delay = 0;\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nchip->options = NAND_USE_FLASH_BBT | NAND_NO_AUTOINCR;\r\nif (nand_scan(pasemi_nand_mtd, 1)) {\r\nerr = -ENXIO;\r\ngoto out_lpc;\r\n}\r\nif (mtd_device_register(pasemi_nand_mtd, NULL, 0)) {\r\nprintk(KERN_ERR "pasemi_nand: Unable to register MTD device\n");\r\nerr = -ENODEV;\r\ngoto out_lpc;\r\n}\r\nprintk(KERN_INFO "PA Semi NAND flash at %08llx, control at I/O %x\n",\r\nres.start, lpcctl);\r\nreturn 0;\r\nout_lpc:\r\nrelease_region(lpcctl, 4);\r\nout_ior:\r\niounmap(chip->IO_ADDR_R);\r\nout_mtd:\r\nkfree(pasemi_nand_mtd);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __devexit pasemi_nand_remove(struct platform_device *ofdev)\r\n{\r\nstruct nand_chip *chip;\r\nif (!pasemi_nand_mtd)\r\nreturn 0;\r\nchip = pasemi_nand_mtd->priv;\r\nnand_release(pasemi_nand_mtd);\r\nrelease_region(lpcctl, 4);\r\niounmap(chip->IO_ADDR_R);\r\nkfree(pasemi_nand_mtd);\r\npasemi_nand_mtd = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init pasemi_nand_init(void)\r\n{\r\nreturn platform_driver_register(&pasemi_nand_driver);\r\n}\r\nstatic void __exit pasemi_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&pasemi_nand_driver);\r\n}
