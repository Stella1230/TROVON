static int v3020_mmio_map(struct v3020 *chip, struct platform_device *pdev,\r\nstruct v3020_platform_data *pdata)\r\n{\r\nif (pdev->num_resources != 1)\r\nreturn -EBUSY;\r\nif (pdev->resource[0].flags != IORESOURCE_MEM)\r\nreturn -EBUSY;\r\nchip->leftshift = pdata->leftshift;\r\nchip->ioaddress = ioremap(pdev->resource[0].start, 1);\r\nif (chip->ioaddress == NULL)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void v3020_mmio_unmap(struct v3020 *chip)\r\n{\r\niounmap(chip->ioaddress);\r\n}\r\nstatic void v3020_mmio_write_bit(struct v3020 *chip, unsigned char bit)\r\n{\r\nwritel(bit << chip->leftshift, chip->ioaddress);\r\n}\r\nstatic unsigned char v3020_mmio_read_bit(struct v3020 *chip)\r\n{\r\nreturn !!(readl(chip->ioaddress) & (1 << chip->leftshift));\r\n}\r\nstatic int v3020_gpio_map(struct v3020 *chip, struct platform_device *pdev,\r\nstruct v3020_platform_data *pdata)\r\n{\r\nint i, err;\r\nv3020_gpio[V3020_CS].gpio = pdata->gpio_cs;\r\nv3020_gpio[V3020_WR].gpio = pdata->gpio_wr;\r\nv3020_gpio[V3020_RD].gpio = pdata->gpio_rd;\r\nv3020_gpio[V3020_IO].gpio = pdata->gpio_io;\r\nfor (i = 0; i < ARRAY_SIZE(v3020_gpio); i++) {\r\nerr = gpio_request(v3020_gpio[i].gpio, v3020_gpio[i].name);\r\nif (err)\r\ngoto err_request;\r\ngpio_direction_output(v3020_gpio[i].gpio, 1);\r\n}\r\nchip->gpio = v3020_gpio;\r\nreturn 0;\r\nerr_request:\r\nwhile (--i >= 0)\r\ngpio_free(v3020_gpio[i].gpio);\r\nreturn err;\r\n}\r\nstatic void v3020_gpio_unmap(struct v3020 *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(v3020_gpio); i++)\r\ngpio_free(v3020_gpio[i].gpio);\r\n}\r\nstatic void v3020_gpio_write_bit(struct v3020 *chip, unsigned char bit)\r\n{\r\ngpio_direction_output(chip->gpio[V3020_IO].gpio, bit);\r\ngpio_set_value(chip->gpio[V3020_CS].gpio, 0);\r\ngpio_set_value(chip->gpio[V3020_WR].gpio, 0);\r\nudelay(1);\r\ngpio_set_value(chip->gpio[V3020_WR].gpio, 1);\r\ngpio_set_value(chip->gpio[V3020_CS].gpio, 1);\r\n}\r\nstatic unsigned char v3020_gpio_read_bit(struct v3020 *chip)\r\n{\r\nint bit;\r\ngpio_direction_input(chip->gpio[V3020_IO].gpio);\r\ngpio_set_value(chip->gpio[V3020_CS].gpio, 0);\r\ngpio_set_value(chip->gpio[V3020_RD].gpio, 0);\r\nudelay(1);\r\nbit = !!gpio_get_value(chip->gpio[V3020_IO].gpio);\r\nudelay(1);\r\ngpio_set_value(chip->gpio[V3020_RD].gpio, 1);\r\ngpio_set_value(chip->gpio[V3020_CS].gpio, 1);\r\nreturn bit;\r\n}\r\nstatic void v3020_set_reg(struct v3020 *chip, unsigned char address,\r\nunsigned char data)\r\n{\r\nint i;\r\nunsigned char tmp;\r\ntmp = address;\r\nfor (i = 0; i < 4; i++) {\r\nchip->ops->write_bit(chip, (tmp & 1));\r\ntmp >>= 1;\r\nudelay(1);\r\n}\r\nif (!V3020_IS_COMMAND(address)) {\r\nfor (i = 0; i < 8; i++) {\r\nchip->ops->write_bit(chip, (data & 1));\r\ndata >>= 1;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nstatic unsigned char v3020_get_reg(struct v3020 *chip, unsigned char address)\r\n{\r\nunsigned int data = 0;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nchip->ops->write_bit(chip, (address & 1));\r\naddress >>= 1;\r\nudelay(1);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ndata >>= 1;\r\nif (chip->ops->read_bit(chip))\r\ndata |= 0x80;\r\nudelay(1);\r\n}\r\nreturn data;\r\n}\r\nstatic int v3020_read_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct v3020 *chip = dev_get_drvdata(dev);\r\nint tmp;\r\nv3020_set_reg(chip, V3020_CMD_CLOCK2RAM, 0);\r\ntmp = v3020_get_reg(chip, V3020_SECONDS);\r\ndt->tm_sec = bcd2bin(tmp);\r\ntmp = v3020_get_reg(chip, V3020_MINUTES);\r\ndt->tm_min = bcd2bin(tmp);\r\ntmp = v3020_get_reg(chip, V3020_HOURS);\r\ndt->tm_hour = bcd2bin(tmp);\r\ntmp = v3020_get_reg(chip, V3020_MONTH_DAY);\r\ndt->tm_mday = bcd2bin(tmp);\r\ntmp = v3020_get_reg(chip, V3020_MONTH);\r\ndt->tm_mon = bcd2bin(tmp) - 1;\r\ntmp = v3020_get_reg(chip, V3020_WEEK_DAY);\r\ndt->tm_wday = bcd2bin(tmp);\r\ntmp = v3020_get_reg(chip, V3020_YEAR);\r\ndt->tm_year = bcd2bin(tmp)+100;\r\ndev_dbg(dev, "\n%s : Read RTC values\n", __func__);\r\ndev_dbg(dev, "tm_hour: %i\n", dt->tm_hour);\r\ndev_dbg(dev, "tm_min : %i\n", dt->tm_min);\r\ndev_dbg(dev, "tm_sec : %i\n", dt->tm_sec);\r\ndev_dbg(dev, "tm_year: %i\n", dt->tm_year);\r\ndev_dbg(dev, "tm_mon : %i\n", dt->tm_mon);\r\ndev_dbg(dev, "tm_mday: %i\n", dt->tm_mday);\r\ndev_dbg(dev, "tm_wday: %i\n", dt->tm_wday);\r\nreturn 0;\r\n}\r\nstatic int v3020_set_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct v3020 *chip = dev_get_drvdata(dev);\r\ndev_dbg(dev, "\n%s : Setting RTC values\n", __func__);\r\ndev_dbg(dev, "tm_sec : %i\n", dt->tm_sec);\r\ndev_dbg(dev, "tm_min : %i\n", dt->tm_min);\r\ndev_dbg(dev, "tm_hour: %i\n", dt->tm_hour);\r\ndev_dbg(dev, "tm_mday: %i\n", dt->tm_mday);\r\ndev_dbg(dev, "tm_wday: %i\n", dt->tm_wday);\r\ndev_dbg(dev, "tm_year: %i\n", dt->tm_year);\r\nv3020_set_reg(chip, V3020_SECONDS, bin2bcd(dt->tm_sec));\r\nv3020_set_reg(chip, V3020_MINUTES, bin2bcd(dt->tm_min));\r\nv3020_set_reg(chip, V3020_HOURS, bin2bcd(dt->tm_hour));\r\nv3020_set_reg(chip, V3020_MONTH_DAY, bin2bcd(dt->tm_mday));\r\nv3020_set_reg(chip, V3020_MONTH, bin2bcd(dt->tm_mon + 1));\r\nv3020_set_reg(chip, V3020_WEEK_DAY, bin2bcd(dt->tm_wday));\r\nv3020_set_reg(chip, V3020_YEAR, bin2bcd(dt->tm_year % 100));\r\nv3020_set_reg(chip, V3020_CMD_RAM2CLOCK, 0);\r\nreturn 0;\r\n}\r\nstatic int rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct v3020_platform_data *pdata = pdev->dev.platform_data;\r\nstruct v3020 *chip;\r\nint retval = -EBUSY;\r\nint i;\r\nint temp;\r\nchip = kzalloc(sizeof *chip, GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nif (pdata->use_gpio)\r\nchip->ops = &v3020_gpio_ops;\r\nelse\r\nchip->ops = &v3020_mmio_ops;\r\nretval = chip->ops->map_io(chip, pdev, pdata);\r\nif (retval)\r\ngoto err_chip;\r\nfor (i = 0; i < 8; i++)\r\ntemp = chip->ops->read_bit(chip);\r\nv3020_set_reg(chip, V3020_SECONDS, 0x33);\r\nif (v3020_get_reg(chip, V3020_SECONDS) != 0x33) {\r\nretval = -ENODEV;\r\ngoto err_io;\r\n}\r\nv3020_set_reg(chip, V3020_STATUS_0, 0x0);\r\nif (pdata->use_gpio)\r\ndev_info(&pdev->dev, "Chip available at GPIOs "\r\n"%d, %d, %d, %d\n",\r\nchip->gpio[V3020_CS].gpio, chip->gpio[V3020_WR].gpio,\r\nchip->gpio[V3020_RD].gpio, chip->gpio[V3020_IO].gpio);\r\nelse\r\ndev_info(&pdev->dev, "Chip available at "\r\n"physical address 0x%llx,"\r\n"data connected to D%d\n",\r\n(unsigned long long)pdev->resource[0].start,\r\nchip->leftshift);\r\nplatform_set_drvdata(pdev, chip);\r\nchip->rtc = rtc_device_register("v3020",\r\n&pdev->dev, &v3020_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(chip->rtc)) {\r\nretval = PTR_ERR(chip->rtc);\r\ngoto err_io;\r\n}\r\nreturn 0;\r\nerr_io:\r\nchip->ops->unmap_io(chip);\r\nerr_chip:\r\nkfree(chip);\r\nreturn retval;\r\n}\r\nstatic int rtc_remove(struct platform_device *dev)\r\n{\r\nstruct v3020 *chip = platform_get_drvdata(dev);\r\nstruct rtc_device *rtc = chip->rtc;\r\nif (rtc)\r\nrtc_device_unregister(rtc);\r\nchip->ops->unmap_io(chip);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic __init int v3020_init(void)\r\n{\r\nreturn platform_driver_register(&rtc_device_driver);\r\n}\r\nstatic __exit void v3020_exit(void)\r\n{\r\nplatform_driver_unregister(&rtc_device_driver);\r\n}
