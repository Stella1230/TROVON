static void __init set_addr(unsigned int *addr, unsigned int q1, int fmangled, unsigned int value)\r\n{\r\nif (!fmangled)\r\n*addr = value;\r\nelse {\r\nunsigned int *q = (unsigned int *)q1;\r\nif (*addr == 0x01000000) {\r\n*q = value;\r\n} else if (addr[-1] == *q) {\r\naddr[-1] = value;\r\n*q = value;\r\n} else {\r\nprom_printf(wrong_setaddr, addr-1, addr[-1], *addr, *q, value);\r\nprom_halt();\r\n}\r\n}\r\n}\r\nstatic inline void set_addr(unsigned int *addr, unsigned int q1, int fmangled, unsigned int value)\r\n{\r\n*addr = value;\r\n}\r\nvoid __init btfixup(void)\r\n{\r\nunsigned int *p, *q;\r\nint type, count;\r\nunsigned insn;\r\nunsigned *addr;\r\nint fmangled = 0;\r\nvoid (*flush_cacheall)(void);\r\nif (!visited) {\r\nvisited++;\r\nprintk(version);\r\nif (ARCH_SUN4C)\r\nprintk(str_sun4c);\r\nelse {\r\nprintk(str_srmmu, srmmu_name);\r\nif (sparc_cpu_model == sun4d)\r\nprintk(str_iounit);\r\nelse\r\nprintk(str_iommu);\r\n}\r\n}\r\nfor (p = ___btfixup_start; p < ___btfixup_end; ) {\r\ncount = p[2];\r\nq = p + 3;\r\nswitch (type = *(unsigned char *)p) {\r\ncase 'f':\r\ncount = p[3];\r\nq = p + 4;\r\nif (((p[0] & 1) || p[1])\r\n&& ((p[1] & 3) || (unsigned *)(p[1]) < _stext || (unsigned *)(p[1]) >= _end)) {\r\nprom_printf(wrong_f, p, p[1]);\r\nprom_halt();\r\n}\r\nbreak;\r\ncase 'b':\r\nif (p[1] < (unsigned long)__init_begin || p[1] >= (unsigned long)__init_text_end || (p[1] & 3)) {\r\nprom_printf(wrong_b, p, p[1]);\r\nprom_halt();\r\n}\r\nbreak;\r\ncase 's':\r\nif (p[1] + 0x1000 >= 0x2000) {\r\nprom_printf(wrong_s, p, p[1]);\r\nprom_halt();\r\n}\r\nbreak;\r\ncase 'h':\r\nif (p[1] & 0x3ff) {\r\nprom_printf(wrong_h, p, p[1]);\r\nprom_halt();\r\n}\r\nbreak;\r\ncase 'a':\r\nif (p[1] + 0x1000 >= 0x2000 && (p[1] & 0x3ff)) {\r\nprom_printf(wrong_a, p, p[1]);\r\nprom_halt();\r\n}\r\nbreak;\r\n}\r\nif (p[0] & 1) {\r\np[0] &= ~1;\r\nwhile (count) {\r\nfmangled = 0;\r\naddr = (unsigned *)*q;\r\nif (addr < _stext || addr >= _end) {\r\nprom_printf(wrong, type, p);\r\nprom_halt();\r\n}\r\ninsn = *addr;\r\n#ifdef BTFIXUP_OPTIMIZE_OTHER\r\nif (type != 'f' && q[1]) {\r\ninsn = *(unsigned int *)q[1];\r\nif (!insn || insn == 1)\r\ninsn = *addr;\r\nelse\r\nfmangled = 1;\r\n}\r\n#endif\r\nswitch (type) {\r\ncase 'f':\r\nif (addr >= __start___ksymtab && addr < __stop___ksymtab) {\r\n*addr = p[1];\r\nbreak;\r\n} else if (!q[1]) {\r\nif ((insn & 0xc1c00000) == 0x01000000) {\r\n*addr = (insn & 0xffc00000) | (p[1] >> 10); break;\r\n} else if ((insn & 0xc1f82000) == 0x80102000) {\r\n*addr = (insn & 0xffffe000) | (p[1] & 0x3ff); break;\r\n} else if ((insn & 0xc0000000) != 0x40000000) {\r\nbad_f:\r\nprom_printf(insn_f, p, addr, insn, addr[1]);\r\nprom_halt();\r\n}\r\n} else if (q[1] != 1)\r\naddr[1] = q[1];\r\nif (p[2] == BTFIXUPCALL_NORM) {\r\nnorm_f:\r\n*addr = 0x40000000 | ((p[1] - (unsigned)addr) >> 2);\r\nq[1] = 0;\r\nbreak;\r\n}\r\n#ifndef BTFIXUP_OPTIMIZE_NOP\r\ngoto norm_f;\r\n#else\r\nif (!(addr[1] & 0x80000000)) {\r\nif ((addr[1] & 0xc1c00000) != 0x01000000)\r\ngoto bad_f;\r\n} else {\r\nif ((addr[1] & 0x01800000) == 0x01800000) {\r\nif ((addr[1] & 0x01f80000) == 0x01e80000) {\r\ngoto norm_f;\r\n}\r\ngoto bad_f;\r\n}\r\nif ((addr[1] & 0xffffe003) == 0x9e03e000) {\r\nint displac = (addr[1] << 19);\r\ndisplac = (displac >> 21) + 2;\r\n*addr = (0x10800000) + (displac & 0x3fffff);\r\nq[1] = addr[1];\r\naddr[1] = p[2];\r\nbreak;\r\n}\r\nif ((addr[1] & 0x201f) == 0x200f || (addr[1] & 0x7c000) == 0x3c000)\r\ngoto norm_f;\r\nif ((addr[1] & 0x3e000000) == 0x1e000000)\r\ngoto norm_f;\r\n}\r\nif (p[2] == BTFIXUPCALL_NOP) {\r\n*addr = 0x01000000;\r\nq[1] = 1;\r\nbreak;\r\n}\r\n#ifndef BTFIXUP_OPTIMIZE_OTHER\r\ngoto norm_f;\r\n#else\r\nif (addr[1] == 0x01000000) {\r\nq[1] = addr[1];\r\n*addr = p[2];\r\nbreak;\r\n}\r\nif ((addr[1] & 0xc0000000) != 0xc0000000) {\r\nif ((addr[1] & 0x30000000) == 0x10000000) {\r\nif ((addr[1] & 0x3e000000) == 0x1c000000)\r\ngoto bad_f;\r\nif ((addr[1] & 0x3e000000) > 0x12000000 ||\r\n((addr[1] & 0x3e000000) == 0x12000000 &&\r\np[2] != BTFIXUPCALL_STO1O0 && p[2] != BTFIXUPCALL_SWAPO0O1) ||\r\n((p[2] & 0xffffe000) == BTFIXUPCALL_RETINT(0))) {\r\n*addr = p[2];\r\nq[1] = addr[1];\r\naddr[1] = 0x01000000;\r\nbreak;\r\n}\r\nif ((addr[1] & 0xf1ffffe0) == 0x90100000) {\r\nif ((addr[1] & 0x3e000000) == 0x10000000 &&\r\n(p[2] & 0x7c000) == 0x20000) {\r\n*addr = (p[2] & ~0x7c000) | ((addr[1] & 0x1f) << 14);\r\nq[1] = addr[1];\r\naddr[1] = 0x01000000;\r\nbreak;\r\n}\r\nif ((addr[1] & 0x3e000000) == 0x12000000 &&\r\np[2] == BTFIXUPCALL_STO1O0) {\r\n*addr = (p[2] & ~0x3e000000) | ((addr[1] & 0x1f) << 25);\r\nq[1] = addr[1];\r\naddr[1] = 0x01000000;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n*addr = addr[1];\r\nq[1] = addr[1];\r\naddr[1] = p[2];\r\nbreak;\r\n#endif\r\n#endif\r\ncase 'b':\r\nif ((insn & 0xc1c00000) != 0x01000000) {\r\nprom_printf(insn_b, p, addr, insn);\r\nprom_halt();\r\n} else {\r\nvoid (*do_fixup)(unsigned *);\r\ndo_fixup = (void (*)(unsigned *))p[1];\r\ndo_fixup(addr);\r\n}\r\nbreak;\r\ncase 's':\r\nif ((insn & 0xc1ffe000) != 0x80102000) {\r\nprom_printf(insn_s, p, addr, insn);\r\nprom_halt();\r\n}\r\nset_addr(addr, q[1], fmangled, (insn & 0xffffe000) | (p[1] & 0x1fff));\r\nbreak;\r\ncase 'h':\r\nif ((insn & 0xc1c00000) != 0x01000000) {\r\nprom_printf(insn_h, p, addr, insn);\r\nprom_halt();\r\n}\r\nset_addr(addr, q[1], fmangled, (insn & 0xffc00000) | (p[1] >> 10));\r\nbreak;\r\ncase 'a':\r\nif ((insn & 0xc1c00000) != 0x01000000 &&\r\n(insn & 0xc1ffe000) != 0x80102000) {\r\nprom_printf(insn_a, p, addr, insn);\r\nprom_halt();\r\n}\r\nif (p[1] & 0x3ff)\r\nset_addr(addr, q[1], fmangled,\r\n(insn & 0x3e000000) | 0x80102000 | (p[1] & 0x1fff));\r\nelse\r\nset_addr(addr, q[1], fmangled,\r\n(insn & 0x3e000000) | 0x01000000 | (p[1] >> 10));\r\nbreak;\r\ncase 'i':\r\nif ((insn & 0xc1c00000) == 0x01000000)\r\nset_addr(addr, q[1], fmangled, (insn & 0xffc00000) | (p[1] >> 10));\r\nelse if ((insn & 0x80002000) == 0x80002000 &&\r\n(insn & 0x01800000) != 0x01800000)\r\nset_addr(addr, q[1], fmangled, (insn & 0xffffe000) | (p[1] & 0x3ff));\r\nelse {\r\nprom_printf(insn_i, p, addr, insn);\r\nprom_halt();\r\n}\r\nbreak;\r\n}\r\ncount -= 2;\r\nq += 2;\r\n}\r\n} else\r\np = q + count;\r\n}\r\n#ifdef CONFIG_SMP\r\nflush_cacheall = (void (*)(void))BTFIXUPVAL_CALL(local_flush_cache_all);\r\n#else\r\nflush_cacheall = (void (*)(void))BTFIXUPVAL_CALL(flush_cache_all);\r\n#endif\r\nif (!flush_cacheall) {\r\nprom_printf(fca_und);\r\nprom_halt();\r\n}\r\n(*flush_cacheall)();\r\n}
