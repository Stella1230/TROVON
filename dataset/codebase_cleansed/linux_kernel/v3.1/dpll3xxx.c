static void _omap3_dpll_write_clken(struct clk *clk, u8 clken_bits)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\ndd = clk->dpll_data;\r\nv = __raw_readl(dd->control_reg);\r\nv &= ~dd->enable_mask;\r\nv |= clken_bits << __ffs(dd->enable_mask);\r\n__raw_writel(v, dd->control_reg);\r\n}\r\nstatic int _omap3_wait_dpll_status(struct clk *clk, u8 state)\r\n{\r\nconst struct dpll_data *dd;\r\nint i = 0;\r\nint ret = -EINVAL;\r\ndd = clk->dpll_data;\r\nstate <<= __ffs(dd->idlest_mask);\r\nwhile (((__raw_readl(dd->idlest_reg) & dd->idlest_mask) != state) &&\r\ni < MAX_DPLL_WAIT_TRIES) {\r\ni++;\r\nudelay(1);\r\n}\r\nif (i == MAX_DPLL_WAIT_TRIES) {\r\nprintk(KERN_ERR "clock: %s failed transition to '%s'\n",\r\nclk->name, (state) ? "locked" : "bypassed");\r\n} else {\r\npr_debug("clock: %s transition to '%s' in %d loops\n",\r\nclk->name, (state) ? "locked" : "bypassed", i);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic u16 _omap3_dpll_compute_freqsel(struct clk *clk, u8 n)\r\n{\r\nunsigned long fint;\r\nu16 f = 0;\r\nfint = clk->dpll_data->clk_ref->rate / n;\r\npr_debug("clock: fint is %lu\n", fint);\r\nif (fint >= 750000 && fint <= 1000000)\r\nf = 0x3;\r\nelse if (fint > 1000000 && fint <= 1250000)\r\nf = 0x4;\r\nelse if (fint > 1250000 && fint <= 1500000)\r\nf = 0x5;\r\nelse if (fint > 1500000 && fint <= 1750000)\r\nf = 0x6;\r\nelse if (fint > 1750000 && fint <= 2100000)\r\nf = 0x7;\r\nelse if (fint > 7500000 && fint <= 10000000)\r\nf = 0xB;\r\nelse if (fint > 10000000 && fint <= 12500000)\r\nf = 0xC;\r\nelse if (fint > 12500000 && fint <= 15000000)\r\nf = 0xD;\r\nelse if (fint > 15000000 && fint <= 17500000)\r\nf = 0xE;\r\nelse if (fint > 17500000 && fint <= 21000000)\r\nf = 0xF;\r\nelse\r\npr_debug("clock: unknown freqsel setting for %d\n", n);\r\nreturn f;\r\n}\r\nstatic int _omap3_noncore_dpll_lock(struct clk *clk)\r\n{\r\nu8 ai;\r\nint r;\r\npr_debug("clock: locking DPLL %s\n", clk->name);\r\nai = omap3_dpll_autoidle_read(clk);\r\nomap3_dpll_deny_idle(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOCKED);\r\nr = _omap3_wait_dpll_status(clk, 1);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\nreturn r;\r\n}\r\nstatic int _omap3_noncore_dpll_bypass(struct clk *clk)\r\n{\r\nint r;\r\nu8 ai;\r\nif (!(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_BYPASS)))\r\nreturn -EINVAL;\r\npr_debug("clock: configuring DPLL %s for low-power bypass\n",\r\nclk->name);\r\nai = omap3_dpll_autoidle_read(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOW_POWER_BYPASS);\r\nr = _omap3_wait_dpll_status(clk, 0);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\nelse\r\nomap3_dpll_deny_idle(clk);\r\nreturn r;\r\n}\r\nstatic int _omap3_noncore_dpll_stop(struct clk *clk)\r\n{\r\nu8 ai;\r\nif (!(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_STOP)))\r\nreturn -EINVAL;\r\npr_debug("clock: stopping DPLL %s\n", clk->name);\r\nai = omap3_dpll_autoidle_read(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOW_POWER_STOP);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\nelse\r\nomap3_dpll_deny_idle(clk);\r\nreturn 0;\r\n}\r\nstatic void _lookup_dco(struct clk *clk, u8 *dco, u16 m, u8 n)\r\n{\r\nunsigned long fint, clkinp;\r\nclkinp = clk->parent->rate;\r\nfint = (clkinp / n) * m;\r\nif (fint < 1000000000)\r\n*dco = 2;\r\nelse\r\n*dco = 4;\r\n}\r\nstatic void _lookup_sddiv(struct clk *clk, u8 *sd_div, u16 m, u8 n)\r\n{\r\nunsigned long clkinp, sd;\r\nint mod1, mod2;\r\nclkinp = clk->parent->rate;\r\nclkinp /= 100000;\r\nmod1 = (clkinp * m) % (250 * n);\r\nsd = (clkinp * m) / (250 * n);\r\nmod2 = sd % 10;\r\nsd /= 10;\r\nif (mod1 || mod2)\r\nsd++;\r\n*sd_div = sd;\r\n}\r\nstatic int omap3_noncore_dpll_program(struct clk *clk, u16 m, u8 n, u16 freqsel)\r\n{\r\nstruct dpll_data *dd = clk->dpll_data;\r\nu8 dco, sd_div;\r\nu32 v;\r\n_omap3_noncore_dpll_bypass(clk);\r\nif (!cpu_is_omap44xx() && !cpu_is_omap3630()) {\r\nv = __raw_readl(dd->control_reg);\r\nv &= ~dd->freqsel_mask;\r\nv |= freqsel << __ffs(dd->freqsel_mask);\r\n__raw_writel(v, dd->control_reg);\r\n}\r\nv = __raw_readl(dd->mult_div1_reg);\r\nv &= ~(dd->mult_mask | dd->div1_mask);\r\nv |= m << __ffs(dd->mult_mask);\r\nv |= (n - 1) << __ffs(dd->div1_mask);\r\nif (dd->dco_mask) {\r\n_lookup_dco(clk, &dco, m, n);\r\nv &= ~(dd->dco_mask);\r\nv |= dco << __ffs(dd->dco_mask);\r\n}\r\nif (dd->sddiv_mask) {\r\n_lookup_sddiv(clk, &sd_div, m, n);\r\nv &= ~(dd->sddiv_mask);\r\nv |= sd_div << __ffs(dd->sddiv_mask);\r\n}\r\n__raw_writel(v, dd->mult_div1_reg);\r\n_omap3_noncore_dpll_lock(clk);\r\nreturn 0;\r\n}\r\nunsigned long omap3_dpll_recalc(struct clk *clk)\r\n{\r\nreturn omap2_get_dpll_rate(clk);\r\n}\r\nint omap3_noncore_dpll_enable(struct clk *clk)\r\n{\r\nint r;\r\nstruct dpll_data *dd;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\nif (clk->rate == dd->clk_bypass->rate) {\r\nWARN_ON(clk->parent != dd->clk_bypass);\r\nr = _omap3_noncore_dpll_bypass(clk);\r\n} else {\r\nWARN_ON(clk->parent != dd->clk_ref);\r\nr = _omap3_noncore_dpll_lock(clk);\r\n}\r\nif (!r)\r\nclk->rate = omap2_get_dpll_rate(clk);\r\nreturn r;\r\n}\r\nvoid omap3_noncore_dpll_disable(struct clk *clk)\r\n{\r\n_omap3_noncore_dpll_stop(clk);\r\n}\r\nint omap3_noncore_dpll_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nstruct clk *new_parent = NULL;\r\nu16 freqsel = 0;\r\nstruct dpll_data *dd;\r\nint ret;\r\nif (!clk || !rate)\r\nreturn -EINVAL;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\nif (rate == omap2_get_dpll_rate(clk))\r\nreturn 0;\r\nomap2_clk_enable(dd->clk_bypass);\r\nomap2_clk_enable(dd->clk_ref);\r\nif (dd->clk_bypass->rate == rate &&\r\n(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_BYPASS))) {\r\npr_debug("clock: %s: set rate: entering bypass.\n", clk->name);\r\nret = _omap3_noncore_dpll_bypass(clk);\r\nif (!ret)\r\nnew_parent = dd->clk_bypass;\r\n} else {\r\nif (dd->last_rounded_rate != rate)\r\nomap2_dpll_round_rate(clk, rate);\r\nif (dd->last_rounded_rate == 0)\r\nreturn -EINVAL;\r\nif (!cpu_is_omap44xx() && !cpu_is_omap3630()) {\r\nfreqsel = _omap3_dpll_compute_freqsel(clk,\r\ndd->last_rounded_n);\r\nif (!freqsel)\r\nWARN_ON(1);\r\n}\r\npr_debug("clock: %s: set rate: locking rate to %lu.\n",\r\nclk->name, rate);\r\nret = omap3_noncore_dpll_program(clk, dd->last_rounded_m,\r\ndd->last_rounded_n, freqsel);\r\nif (!ret)\r\nnew_parent = dd->clk_ref;\r\n}\r\nif (!ret) {\r\nif (clk->usecount) {\r\nomap2_clk_enable(new_parent);\r\nomap2_clk_disable(clk->parent);\r\n}\r\nclk_reparent(clk, new_parent);\r\nclk->rate = rate;\r\n}\r\nomap2_clk_disable(dd->clk_ref);\r\nomap2_clk_disable(dd->clk_bypass);\r\nreturn 0;\r\n}\r\nu32 omap3_dpll_autoidle_read(struct clk *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn -EINVAL;\r\ndd = clk->dpll_data;\r\nv = __raw_readl(dd->autoidle_reg);\r\nv &= dd->autoidle_mask;\r\nv >>= __ffs(dd->autoidle_mask);\r\nreturn v;\r\n}\r\nvoid omap3_dpll_allow_idle(struct clk *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn;\r\ndd = clk->dpll_data;\r\nv = __raw_readl(dd->autoidle_reg);\r\nv &= ~dd->autoidle_mask;\r\nv |= DPLL_AUTOIDLE_LOW_POWER_STOP << __ffs(dd->autoidle_mask);\r\n__raw_writel(v, dd->autoidle_reg);\r\n}\r\nvoid omap3_dpll_deny_idle(struct clk *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn;\r\ndd = clk->dpll_data;\r\nv = __raw_readl(dd->autoidle_reg);\r\nv &= ~dd->autoidle_mask;\r\nv |= DPLL_AUTOIDLE_DISABLE << __ffs(dd->autoidle_mask);\r\n__raw_writel(v, dd->autoidle_reg);\r\n}\r\nunsigned long omap3_clkoutx2_recalc(struct clk *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nunsigned long rate;\r\nu32 v;\r\nstruct clk *pclk;\r\npclk = clk->parent;\r\nwhile (pclk && !pclk->dpll_data)\r\npclk = pclk->parent;\r\nWARN_ON(!pclk);\r\ndd = pclk->dpll_data;\r\nWARN_ON(!dd->enable_mask);\r\nv = __raw_readl(dd->control_reg) & dd->enable_mask;\r\nv >>= __ffs(dd->enable_mask);\r\nif ((v != OMAP3XXX_EN_DPLL_LOCKED) || (dd->flags & DPLL_J_TYPE))\r\nrate = clk->parent->rate;\r\nelse\r\nrate = clk->parent->rate * 2;\r\nreturn rate;\r\n}
