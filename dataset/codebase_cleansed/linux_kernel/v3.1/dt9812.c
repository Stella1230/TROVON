static inline struct usb_dt9812 *to_dt9812_dev(struct kref *d)\r\n{\r\nreturn container_of(d, struct usb_dt9812, kref);\r\n}\r\nstatic void dt9812_delete(struct kref *kref)\r\n{\r\nstruct usb_dt9812 *dev = to_dt9812_dev(kref);\r\nusb_put_dev(dev->udev);\r\nkfree(dev);\r\n}\r\nstatic int dt9812_read_info(struct usb_dt9812 *dev, int offset, void *buf,\r\nsize_t buf_size)\r\n{\r\nstruct dt9812_usb_cmd cmd;\r\nint count, retval;\r\ncmd.cmd = cpu_to_le32(DT9812_R_FLASH_DATA);\r\ncmd.u.flash_data_info.address =\r\ncpu_to_le16(DT9812_DIAGS_BOARD_INFO_ADDR + offset);\r\ncmd.u.flash_data_info.numbytes = cpu_to_le16(buf_size);\r\ncount = 32;\r\nretval = usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->command_write.addr),\r\n&cmd, 32, &count, HZ * 1);\r\nif (retval)\r\nreturn retval;\r\nretval = usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->command_read.addr),\r\nbuf, buf_size, &count, HZ * 1);\r\nreturn retval;\r\n}\r\nstatic int dt9812_read_multiple_registers(struct usb_dt9812 *dev, int reg_count,\r\nu8 * address, u8 * value)\r\n{\r\nstruct dt9812_usb_cmd cmd;\r\nint i, count, retval;\r\ncmd.cmd = cpu_to_le32(DT9812_R_MULTI_BYTE_REG);\r\ncmd.u.read_multi_info.count = reg_count;\r\nfor (i = 0; i < reg_count; i++)\r\ncmd.u.read_multi_info.address[i] = address[i];\r\ncount = 32;\r\nretval = usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->command_write.addr),\r\n&cmd, 32, &count, HZ * 1);\r\nif (retval)\r\nreturn retval;\r\nretval = usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->command_read.addr),\r\nvalue, reg_count, &count, HZ * 1);\r\nreturn retval;\r\n}\r\nstatic int dt9812_write_multiple_registers(struct usb_dt9812 *dev,\r\nint reg_count, u8 * address,\r\nu8 * value)\r\n{\r\nstruct dt9812_usb_cmd cmd;\r\nint i, count, retval;\r\ncmd.cmd = cpu_to_le32(DT9812_W_MULTI_BYTE_REG);\r\ncmd.u.read_multi_info.count = reg_count;\r\nfor (i = 0; i < reg_count; i++) {\r\ncmd.u.write_multi_info.write[i].address = address[i];\r\ncmd.u.write_multi_info.write[i].value = value[i];\r\n}\r\nretval = usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->command_write.addr),\r\n&cmd, 32, &count, HZ * 1);\r\nreturn retval;\r\n}\r\nstatic int dt9812_rmw_multiple_registers(struct usb_dt9812 *dev, int reg_count,\r\nstruct dt9812_rmw_byte *rmw)\r\n{\r\nstruct dt9812_usb_cmd cmd;\r\nint i, count, retval;\r\ncmd.cmd = cpu_to_le32(DT9812_RMW_MULTI_BYTE_REG);\r\ncmd.u.rmw_multi_info.count = reg_count;\r\nfor (i = 0; i < reg_count; i++)\r\ncmd.u.rmw_multi_info.rmw[i] = rmw[i];\r\nretval = usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->command_write.addr),\r\n&cmd, 32, &count, HZ * 1);\r\nreturn retval;\r\n}\r\nstatic int dt9812_digital_in(struct slot_dt9812 *slot, u8 * bits)\r\n{\r\nint result = -ENODEV;\r\ndown(&slot->mutex);\r\nif (slot->usb) {\r\nu8 reg[2] = { F020_SFR_P3, F020_SFR_P1 };\r\nu8 value[2];\r\nresult = dt9812_read_multiple_registers(slot->usb, 2, reg,\r\nvalue);\r\nif (result == 0) {\r\n*bits = (value[0] & 0x7f) | ((value[1] & 0x08) << 4);\r\n}\r\n}\r\nup(&slot->mutex);\r\nreturn result;\r\n}\r\nstatic int dt9812_digital_out(struct slot_dt9812 *slot, u8 bits)\r\n{\r\nint result = -ENODEV;\r\ndown(&slot->mutex);\r\nif (slot->usb) {\r\nu8 reg[1];\r\nu8 value[1];\r\nreg[0] = F020_SFR_P2;\r\nvalue[0] = bits;\r\nresult = dt9812_write_multiple_registers(slot->usb, 1, reg,\r\nvalue);\r\nslot->usb->digital_out_shadow = bits;\r\n}\r\nup(&slot->mutex);\r\nreturn result;\r\n}\r\nstatic int dt9812_digital_out_shadow(struct slot_dt9812 *slot, u8 * bits)\r\n{\r\nint result = -ENODEV;\r\ndown(&slot->mutex);\r\nif (slot->usb) {\r\n*bits = slot->usb->digital_out_shadow;\r\nresult = 0;\r\n}\r\nup(&slot->mutex);\r\nreturn result;\r\n}\r\nstatic void dt9812_configure_mux(struct usb_dt9812 *dev,\r\nstruct dt9812_rmw_byte *rmw, int channel)\r\n{\r\nif (dev->device == DT9812_DEVID_DT9812_10) {\r\nrmw->address = F020_SFR_P1;\r\nrmw->and_mask = 0xe0;\r\nrmw->or_value = channel << 5;\r\n} else {\r\nrmw->address = F020_SFR_AMX0SL;\r\nrmw->and_mask = 0xff;\r\nrmw->or_value = channel & 0x07;\r\n}\r\n}\r\nstatic void dt9812_configure_gain(struct usb_dt9812 *dev,\r\nstruct dt9812_rmw_byte *rmw,\r\nenum dt9812_gain gain)\r\n{\r\nif (dev->device == DT9812_DEVID_DT9812_10) {\r\ngain <<= 1;\r\n}\r\nrmw->address = F020_SFR_ADC0CF;\r\nrmw->and_mask = F020_MASK_ADC0CF_AMP0GN2 |\r\nF020_MASK_ADC0CF_AMP0GN1 | F020_MASK_ADC0CF_AMP0GN0;\r\nswitch (gain) {\r\ncase DT9812_GAIN_0PT5:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN2 ||\r\nF020_MASK_ADC0CF_AMP0GN1;\r\nbreak;\r\ncase DT9812_GAIN_1:\r\nrmw->or_value = 0x00;\r\nbreak;\r\ncase DT9812_GAIN_2:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN0;\r\nbreak;\r\ncase DT9812_GAIN_4:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN1;\r\nbreak;\r\ncase DT9812_GAIN_8:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN1 ||\r\nF020_MASK_ADC0CF_AMP0GN0;\r\nbreak;\r\ncase DT9812_GAIN_16:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN2;\r\nbreak;\r\ndefault:\r\nerr("Illegal gain %d\n", gain);\r\n}\r\n}\r\nstatic int dt9812_analog_in(struct slot_dt9812 *slot, int channel, u16 * value,\r\nenum dt9812_gain gain)\r\n{\r\nstruct dt9812_rmw_byte rmw[3];\r\nu8 reg[3] = {\r\nF020_SFR_ADC0CN,\r\nF020_SFR_ADC0H,\r\nF020_SFR_ADC0L\r\n};\r\nu8 val[3];\r\nint result = -ENODEV;\r\ndown(&slot->mutex);\r\nif (!slot->usb)\r\ngoto exit;\r\ndt9812_configure_gain(slot->usb, &rmw[0], gain);\r\ndt9812_configure_mux(slot->usb, &rmw[1], channel);\r\nrmw[2].address = F020_SFR_ADC0CN;\r\nrmw[2].and_mask = 0xff;\r\nrmw[2].or_value = F020_MASK_ADC0CN_AD0EN | F020_MASK_ADC0CN_AD0BUSY;\r\nresult = dt9812_rmw_multiple_registers(slot->usb, 3, rmw);\r\nif (result)\r\ngoto exit;\r\nresult = dt9812_read_multiple_registers(slot->usb, 3, reg, val);\r\nif (result)\r\ngoto exit;\r\nif ((val[0] & (F020_MASK_ADC0CN_AD0INT | F020_MASK_ADC0CN_AD0BUSY)) ==\r\nF020_MASK_ADC0CN_AD0INT) {\r\nswitch (slot->usb->device) {\r\ncase DT9812_DEVID_DT9812_10:\r\n*value = ((val[1] << 8) | val[2]) + 0x800;\r\nbreak;\r\ncase DT9812_DEVID_DT9812_2PT5:\r\n*value = (val[1] << 8) | val[2];\r\nbreak;\r\n}\r\n}\r\nexit:\r\nup(&slot->mutex);\r\nreturn result;\r\n}\r\nstatic int dt9812_analog_out_shadow(struct slot_dt9812 *slot, int channel,\r\nu16 * value)\r\n{\r\nint result = -ENODEV;\r\ndown(&slot->mutex);\r\nif (slot->usb) {\r\n*value = slot->usb->analog_out_shadow[channel];\r\nresult = 0;\r\n}\r\nup(&slot->mutex);\r\nreturn result;\r\n}\r\nstatic int dt9812_analog_out(struct slot_dt9812 *slot, int channel, u16 value)\r\n{\r\nint result = -ENODEV;\r\ndown(&slot->mutex);\r\nif (slot->usb) {\r\nstruct dt9812_rmw_byte rmw[3];\r\nswitch (channel) {\r\ncase 0:\r\nrmw[0].address = F020_SFR_DAC0CN;\r\nrmw[0].and_mask = 0xff;\r\nrmw[0].or_value = F020_MASK_DACxCN_DACxEN;\r\nrmw[1].address = F020_SFR_DAC0L;\r\nrmw[1].and_mask = 0xff;\r\nrmw[1].or_value = value & 0xff;\r\nrmw[2].address = F020_SFR_DAC0H;\r\nrmw[2].and_mask = 0xff;\r\nrmw[2].or_value = (value >> 8) & 0xf;\r\nbreak;\r\ncase 1:\r\nrmw[0].address = F020_SFR_DAC1CN;\r\nrmw[0].and_mask = 0xff;\r\nrmw[0].or_value = F020_MASK_DACxCN_DACxEN;\r\nrmw[1].address = F020_SFR_DAC1L;\r\nrmw[1].and_mask = 0xff;\r\nrmw[1].or_value = value & 0xff;\r\nrmw[2].address = F020_SFR_DAC1H;\r\nrmw[2].and_mask = 0xff;\r\nrmw[2].or_value = (value >> 8) & 0xf;\r\nbreak;\r\n}\r\nresult = dt9812_rmw_multiple_registers(slot->usb, 3, rmw);\r\nslot->usb->analog_out_shadow[channel] = value;\r\n}\r\nup(&slot->mutex);\r\nreturn result;\r\n}\r\nstatic int dt9812_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nint retval = -ENOMEM;\r\nstruct usb_dt9812 *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\nu8 fw;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\ngoto error;\r\n}\r\nkref_init(&dev->kref);\r\ndev->udev = usb_get_dev(interface_to_usbdev(interface));\r\ndev->interface = interface;\r\niface_desc = interface->cur_altsetting;\r\nif (iface_desc->desc.bNumEndpoints != 5) {\r\nerr("Wrong number of endpints.");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nint direction = -1;\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nswitch (i) {\r\ncase 0:\r\ndirection = USB_DIR_IN;\r\ndev->message_pipe.addr = endpoint->bEndpointAddress;\r\ndev->message_pipe.size =\r\nle16_to_cpu(endpoint->wMaxPacketSize);\r\nbreak;\r\ncase 1:\r\ndirection = USB_DIR_OUT;\r\ndev->command_write.addr = endpoint->bEndpointAddress;\r\ndev->command_write.size =\r\nle16_to_cpu(endpoint->wMaxPacketSize);\r\nbreak;\r\ncase 2:\r\ndirection = USB_DIR_IN;\r\ndev->command_read.addr = endpoint->bEndpointAddress;\r\ndev->command_read.size =\r\nle16_to_cpu(endpoint->wMaxPacketSize);\r\nbreak;\r\ncase 3:\r\ndirection = USB_DIR_OUT;\r\ndev->write_stream.addr = endpoint->bEndpointAddress;\r\ndev->write_stream.size =\r\nle16_to_cpu(endpoint->wMaxPacketSize);\r\nbreak;\r\ncase 4:\r\ndirection = USB_DIR_IN;\r\ndev->read_stream.addr = endpoint->bEndpointAddress;\r\ndev->read_stream.size =\r\nle16_to_cpu(endpoint->wMaxPacketSize);\r\nbreak;\r\n}\r\nif ((endpoint->bEndpointAddress & USB_DIR_IN) != direction) {\r\ndev_err(&interface->dev,\r\n"Endpoint has wrong direction.\n");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\n}\r\nif (dt9812_read_info(dev, 0, &fw, sizeof(fw)) != 0) {\r\nusb_reset_configuration(dev->udev);\r\nfor (i = 0; i < 10; i++) {\r\nretval = dt9812_read_info(dev, 1, &fw, sizeof(fw));\r\nif (retval == 0) {\r\ndev_info(&interface->dev,\r\n"usb_reset_configuration succeeded "\r\n"after %d iterations\n", i);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (dt9812_read_info(dev, 1, &dev->vendor, sizeof(dev->vendor)) != 0) {\r\nerr("Failed to read vendor.");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nif (dt9812_read_info(dev, 3, &dev->product, sizeof(dev->product)) != 0) {\r\nerr("Failed to read product.");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nif (dt9812_read_info(dev, 5, &dev->device, sizeof(dev->device)) != 0) {\r\nerr("Failed to read device.");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nif (dt9812_read_info(dev, 7, &dev->serial, sizeof(dev->serial)) != 0) {\r\nerr("Failed to read serial.");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\ndev->vendor = le16_to_cpu(dev->vendor);\r\ndev->product = le16_to_cpu(dev->product);\r\ndev->device = le16_to_cpu(dev->device);\r\ndev->serial = le32_to_cpu(dev->serial);\r\nswitch (dev->device) {\r\ncase DT9812_DEVID_DT9812_10:\r\ndev->analog_out_shadow[0] = 0x0800;\r\ndev->analog_out_shadow[1] = 0x800;\r\nbreak;\r\ncase DT9812_DEVID_DT9812_2PT5:\r\ndev->analog_out_shadow[0] = 0x0000;\r\ndev->analog_out_shadow[1] = 0x0000;\r\nbreak;\r\n}\r\ndev->digital_out_shadow = 0;\r\nusb_set_intfdata(interface, dev);\r\ndev_info(&interface->dev, "USB DT9812 (%4.4x.%4.4x.%4.4x) #0x%8.8x\n",\r\ndev->vendor, dev->product, dev->device, dev->serial);\r\ndown(&dt9812_mutex);\r\n{\r\nstruct slot_dt9812 *first = NULL;\r\nstruct slot_dt9812 *best = NULL;\r\nfor (i = 0; i < DT9812_NUM_SLOTS; i++) {\r\nif (!first && !dt9812[i].usb && dt9812[i].serial == 0)\r\nfirst = &dt9812[i];\r\nif (!best && dt9812[i].serial == dev->serial)\r\nbest = &dt9812[i];\r\n}\r\nif (!best)\r\nbest = first;\r\nif (best) {\r\ndown(&best->mutex);\r\nbest->usb = dev;\r\ndev->slot = best;\r\nup(&best->mutex);\r\n}\r\n}\r\nup(&dt9812_mutex);\r\nreturn 0;\r\nerror:\r\nif (dev)\r\nkref_put(&dev->kref, dt9812_delete);\r\nreturn retval;\r\n}\r\nstatic void dt9812_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_dt9812 *dev;\r\nint minor = interface->minor;\r\ndown(&dt9812_mutex);\r\ndev = usb_get_intfdata(interface);\r\nif (dev->slot) {\r\ndown(&dev->slot->mutex);\r\ndev->slot->usb = NULL;\r\nup(&dev->slot->mutex);\r\ndev->slot = NULL;\r\n}\r\nusb_set_intfdata(interface, NULL);\r\nup(&dt9812_mutex);\r\nkref_put(&dev->kref, dt9812_delete);\r\ndev_info(&interface->dev, "USB Dt9812 #%d now disconnected\n", minor);\r\n}\r\nstatic int dt9812_comedi_open(struct comedi_device *dev)\r\n{\r\nint result = -ENODEV;\r\ndown(&devpriv->slot->mutex);\r\nif (devpriv->slot->usb) {\r\nstruct comedi_subdevice *s;\r\ns = &dev->subdevices[0];\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns = &dev->subdevices[1];\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns = &dev->subdevices[2];\r\ns->n_chan = 8;\r\nswitch (devpriv->slot->usb->device) {\r\ncase 0:{\r\ns->maxdata = 4095;\r\ns->range_table = &dt9812_10_ain_range;\r\n}\r\nbreak;\r\ncase 1:{\r\ns->maxdata = 4095;\r\ns->range_table = &dt9812_2pt5_ain_range;\r\n}\r\nbreak;\r\n}\r\ns = &dev->subdevices[3];\r\ns->n_chan = 2;\r\nswitch (devpriv->slot->usb->device) {\r\ncase 0:{\r\ns->maxdata = 4095;\r\ns->range_table = &dt9812_10_aout_range;\r\n}\r\nbreak;\r\ncase 1:{\r\ns->maxdata = 4095;\r\ns->range_table = &dt9812_2pt5_aout_range;\r\n}\r\nbreak;\r\n}\r\nresult = 0;\r\n}\r\nup(&devpriv->slot->mutex);\r\nreturn result;\r\n}\r\nstatic int dt9812_di_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint n;\r\nu8 bits = 0;\r\ndt9812_digital_in(devpriv->slot, &bits);\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = ((1 << insn->chanspec) & bits) != 0;\r\nreturn n;\r\n}\r\nstatic int dt9812_do_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint n;\r\nu8 bits = 0;\r\ndt9812_digital_out_shadow(devpriv->slot, &bits);\r\nfor (n = 0; n < insn->n; n++) {\r\nu8 mask = 1 << insn->chanspec;\r\nbits &= ~mask;\r\nif (data[n])\r\nbits |= mask;\r\n}\r\ndt9812_digital_out(devpriv->slot, bits);\r\nreturn n;\r\n}\r\nstatic int dt9812_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint n;\r\nfor (n = 0; n < insn->n; n++) {\r\nu16 value = 0;\r\ndt9812_analog_in(devpriv->slot, insn->chanspec, &value,\r\nDT9812_GAIN_1);\r\ndata[n] = value;\r\n}\r\nreturn n;\r\n}\r\nstatic int dt9812_ao_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint n;\r\nu16 value;\r\nfor (n = 0; n < insn->n; n++) {\r\nvalue = 0;\r\ndt9812_analog_out_shadow(devpriv->slot, insn->chanspec, &value);\r\ndata[n] = value;\r\n}\r\nreturn n;\r\n}\r\nstatic int dt9812_ao_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint n;\r\nfor (n = 0; n < insn->n; n++)\r\ndt9812_analog_out(devpriv->slot, insn->chanspec, data[n]);\r\nreturn n;\r\n}\r\nstatic int dt9812_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nint i;\r\nstruct comedi_subdevice *s;\r\ndev->board_name = "dt9812";\r\nif (alloc_private(dev, sizeof(struct comedi_dt9812)) < 0)\r\nreturn -ENOMEM;\r\ndev->open = dt9812_comedi_open;\r\ndevpriv->serial = it->options[0];\r\nif (alloc_subdevices(dev, 4) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_read = &dt9812_di_rinsn;\r\ns = dev->subdevices + 1;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITEABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_write = &dt9812_do_winsn;\r\ns = dev->subdevices + 2;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = NULL;\r\ns->insn_read = &dt9812_ai_rinsn;\r\ns = dev->subdevices + 3;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITEABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = NULL;\r\ns->insn_write = &dt9812_ao_winsn;\r\ns->insn_read = &dt9812_ao_rinsn;\r\nprintk(KERN_INFO "comedi%d: successfully attached to dt9812.\n",\r\ndev->minor);\r\ndown(&dt9812_mutex);\r\n{\r\nstruct slot_dt9812 *first = NULL;\r\nstruct slot_dt9812 *best = NULL;\r\nfor (i = 0; i < DT9812_NUM_SLOTS; i++) {\r\nif (!first && !dt9812[i].comedi) {\r\nfirst = &dt9812[i];\r\n}\r\nif (!best &&\r\ndt9812[i].usb &&\r\ndt9812[i].usb->serial == devpriv->serial) {\r\nbest = &dt9812[i];\r\n}\r\n}\r\nif (!best)\r\nbest = first;\r\nif (best) {\r\ndown(&best->mutex);\r\nbest->comedi = devpriv;\r\nbest->serial = devpriv->serial;\r\ndevpriv->slot = best;\r\nup(&best->mutex);\r\n}\r\n}\r\nup(&dt9812_mutex);\r\nreturn 0;\r\n}\r\nstatic int dt9812_detach(struct comedi_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init usb_dt9812_init(void)\r\n{\r\nint result, i;\r\nfor (i = 0; i < DT9812_NUM_SLOTS; i++) {\r\nsema_init(&dt9812[i].mutex, 1);\r\ndt9812[i].serial = 0;\r\ndt9812[i].usb = NULL;\r\ndt9812[i].comedi = NULL;\r\n}\r\ndt9812[12].serial = 0x0;\r\nresult = usb_register(&dt9812_usb_driver);\r\nif (result) {\r\nprintk(KERN_ERR KBUILD_MODNAME\r\n": usb_register failed. Error number %d\n", result);\r\nreturn result;\r\n}\r\nresult = comedi_driver_register(&dt9812_comedi_driver);\r\nif (result) {\r\nusb_deregister(&dt9812_usb_driver);\r\nerr("comedi_driver_register failed. Error number %d", result);\r\n}\r\nreturn result;\r\n}\r\nstatic void __exit usb_dt9812_exit(void)\r\n{\r\ncomedi_driver_unregister(&dt9812_comedi_driver);\r\nusb_deregister(&dt9812_usb_driver);\r\n}
