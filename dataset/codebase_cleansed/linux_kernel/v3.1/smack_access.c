int smk_access_entry(char *subject_label, char *object_label,\r\nstruct list_head *rule_list)\r\n{\r\nint may = -ENOENT;\r\nstruct smack_rule *srp;\r\nlist_for_each_entry_rcu(srp, rule_list, list) {\r\nif (srp->smk_subject == subject_label ||\r\nstrcmp(srp->smk_subject, subject_label) == 0) {\r\nif (srp->smk_object == object_label ||\r\nstrcmp(srp->smk_object, object_label) == 0) {\r\nmay = srp->smk_access;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn may;\r\n}\r\nint smk_access(char *subject_label, char *object_label, int request,\r\nstruct smk_audit_info *a)\r\n{\r\nint may = MAY_NOT;\r\nint rc = 0;\r\nif (subject_label == smack_known_star.smk_known ||\r\nstrcmp(subject_label, smack_known_star.smk_known) == 0) {\r\nrc = -EACCES;\r\ngoto out_audit;\r\n}\r\nif (object_label == smack_known_web.smk_known ||\r\nsubject_label == smack_known_web.smk_known ||\r\nstrcmp(object_label, smack_known_web.smk_known) == 0 ||\r\nstrcmp(subject_label, smack_known_web.smk_known) == 0)\r\ngoto out_audit;\r\nif (object_label == smack_known_star.smk_known ||\r\nstrcmp(object_label, smack_known_star.smk_known) == 0)\r\ngoto out_audit;\r\nif (subject_label == object_label ||\r\nstrcmp(subject_label, object_label) == 0)\r\ngoto out_audit;\r\nif ((request & MAY_ANYREAD) == request) {\r\nif (object_label == smack_known_floor.smk_known ||\r\nstrcmp(object_label, smack_known_floor.smk_known) == 0)\r\ngoto out_audit;\r\nif (subject_label == smack_known_hat.smk_known ||\r\nstrcmp(subject_label, smack_known_hat.smk_known) == 0)\r\ngoto out_audit;\r\n}\r\nrcu_read_lock();\r\nmay = smk_access_entry(subject_label, object_label, &smack_rule_list);\r\nrcu_read_unlock();\r\nif (may > 0 && (request & may) == request)\r\ngoto out_audit;\r\nrc = -EACCES;\r\nout_audit:\r\n#ifdef CONFIG_AUDIT\r\nif (a)\r\nsmack_log(subject_label, object_label, request, rc, a);\r\n#endif\r\nreturn rc;\r\n}\r\nint smk_curacc(char *obj_label, u32 mode, struct smk_audit_info *a)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nchar *sp = smk_of_task(tsp);\r\nint may;\r\nint rc;\r\nrc = smk_access(sp, obj_label, mode, NULL);\r\nif (rc == 0) {\r\nmay = smk_access_entry(sp, obj_label, &tsp->smk_rules);\r\nif (may < 0)\r\ngoto out_audit;\r\nif ((mode & may) == mode)\r\ngoto out_audit;\r\nrc = -EACCES;\r\n}\r\nif (smack_onlycap != NULL && smack_onlycap != sp)\r\ngoto out_audit;\r\nif (capable(CAP_MAC_OVERRIDE))\r\nrc = 0;\r\nout_audit:\r\n#ifdef CONFIG_AUDIT\r\nif (a)\r\nsmack_log(sp, obj_label, mode, rc, a);\r\n#endif\r\nreturn rc;\r\n}\r\nstatic inline void smack_str_from_perm(char *string, int access)\r\n{\r\nint i = 0;\r\nif (access & MAY_READ)\r\nstring[i++] = 'r';\r\nif (access & MAY_WRITE)\r\nstring[i++] = 'w';\r\nif (access & MAY_EXEC)\r\nstring[i++] = 'x';\r\nif (access & MAY_APPEND)\r\nstring[i++] = 'a';\r\nstring[i] = '\0';\r\n}\r\nstatic void smack_log_callback(struct audit_buffer *ab, void *a)\r\n{\r\nstruct common_audit_data *ad = a;\r\nstruct smack_audit_data *sad = &ad->smack_audit_data;\r\naudit_log_format(ab, "lsm=SMACK fn=%s action=%s",\r\nad->smack_audit_data.function,\r\nsad->result ? "denied" : "granted");\r\naudit_log_format(ab, " subject=");\r\naudit_log_untrustedstring(ab, sad->subject);\r\naudit_log_format(ab, " object=");\r\naudit_log_untrustedstring(ab, sad->object);\r\naudit_log_format(ab, " requested=%s", sad->request);\r\n}\r\nvoid smack_log(char *subject_label, char *object_label, int request,\r\nint result, struct smk_audit_info *ad)\r\n{\r\nchar request_buffer[SMK_NUM_ACCESS_TYPE + 1];\r\nstruct smack_audit_data *sad;\r\nstruct common_audit_data *a = &ad->a;\r\nif (result != 0 && (log_policy & SMACK_AUDIT_DENIED) == 0)\r\nreturn;\r\nif (result == 0 && (log_policy & SMACK_AUDIT_ACCEPT) == 0)\r\nreturn;\r\nif (a->smack_audit_data.function == NULL)\r\na->smack_audit_data.function = "unknown";\r\nsad = &a->smack_audit_data;\r\nsmack_str_from_perm(request_buffer, request);\r\nsad->subject = subject_label;\r\nsad->object = object_label;\r\nsad->request = request_buffer;\r\nsad->result = result;\r\na->lsm_pre_audit = smack_log_callback;\r\ncommon_lsm_audit(a);\r\n}\r\nvoid smack_log(char *subject_label, char *object_label, int request,\r\nint result, struct smk_audit_info *ad)\r\n{\r\n}\r\nstruct smack_known *smk_import_entry(const char *string, int len)\r\n{\r\nstruct smack_known *skp;\r\nchar smack[SMK_LABELLEN];\r\nint found;\r\nint i;\r\nif (len <= 0 || len > SMK_MAXLEN)\r\nlen = SMK_MAXLEN;\r\nfor (i = 0, found = 0; i < SMK_LABELLEN; i++) {\r\nif (found)\r\nsmack[i] = '\0';\r\nelse if (i >= len || string[i] > '~' || string[i] <= ' ' ||\r\nstring[i] == '/' || string[i] == '"' ||\r\nstring[i] == '\\' || string[i] == '\'') {\r\nsmack[i] = '\0';\r\nfound = 1;\r\n} else\r\nsmack[i] = string[i];\r\n}\r\nif (smack[0] == '\0')\r\nreturn NULL;\r\nmutex_lock(&smack_known_lock);\r\nfound = 0;\r\nlist_for_each_entry_rcu(skp, &smack_known_list, list) {\r\nif (strncmp(skp->smk_known, smack, SMK_MAXLEN) == 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found == 0) {\r\nskp = kzalloc(sizeof(struct smack_known), GFP_KERNEL);\r\nif (skp != NULL) {\r\nstrncpy(skp->smk_known, smack, SMK_MAXLEN);\r\nskp->smk_secid = smack_next_secid++;\r\nskp->smk_cipso = NULL;\r\nspin_lock_init(&skp->smk_cipsolock);\r\nlist_add_rcu(&skp->list, &smack_known_list);\r\n}\r\n}\r\nmutex_unlock(&smack_known_lock);\r\nreturn skp;\r\n}\r\nchar *smk_import(const char *string, int len)\r\n{\r\nstruct smack_known *skp;\r\nif (string[0] == '-')\r\nreturn NULL;\r\nskp = smk_import_entry(string, len);\r\nif (skp == NULL)\r\nreturn NULL;\r\nreturn skp->smk_known;\r\n}\r\nchar *smack_from_secid(const u32 secid)\r\n{\r\nstruct smack_known *skp;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(skp, &smack_known_list, list) {\r\nif (skp->smk_secid == secid) {\r\nrcu_read_unlock();\r\nreturn skp->smk_known;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn smack_known_invalid.smk_known;\r\n}\r\nu32 smack_to_secid(const char *smack)\r\n{\r\nstruct smack_known *skp;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(skp, &smack_known_list, list) {\r\nif (strncmp(skp->smk_known, smack, SMK_MAXLEN) == 0) {\r\nrcu_read_unlock();\r\nreturn skp->smk_secid;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nvoid smack_from_cipso(u32 level, char *cp, char *result)\r\n{\r\nstruct smack_known *kp;\r\nchar *final = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry(kp, &smack_known_list, list) {\r\nif (kp->smk_cipso == NULL)\r\ncontinue;\r\nspin_lock_bh(&kp->smk_cipsolock);\r\nif (kp->smk_cipso->smk_level == level &&\r\nmemcmp(kp->smk_cipso->smk_catset, cp, SMK_LABELLEN) == 0)\r\nfinal = kp->smk_known;\r\nspin_unlock_bh(&kp->smk_cipsolock);\r\n}\r\nrcu_read_unlock();\r\nif (final == NULL)\r\nfinal = smack_known_huh.smk_known;\r\nstrncpy(result, final, SMK_MAXLEN);\r\nreturn;\r\n}\r\nint smack_to_cipso(const char *smack, struct smack_cipso *cp)\r\n{\r\nstruct smack_known *kp;\r\nint found = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(kp, &smack_known_list, list) {\r\nif (kp->smk_known == smack ||\r\nstrcmp(kp->smk_known, smack) == 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (found == 0 || kp->smk_cipso == NULL)\r\nreturn -ENOENT;\r\nmemcpy(cp, kp->smk_cipso, sizeof(struct smack_cipso));\r\nreturn 0;\r\n}
