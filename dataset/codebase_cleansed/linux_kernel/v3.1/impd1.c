static void impd1_setvco(struct clk *clk, struct icst_vco vco)\r\n{\r\nstruct impd1_module *impd1 = clk->data;\r\nu32 val = vco.v | (vco.r << 9) | (vco.s << 16);\r\nwritel(0xa05f, impd1->base + IMPD1_LOCK);\r\nwritel(val, clk->vcoreg);\r\nwritel(0, impd1->base + IMPD1_LOCK);\r\n#ifdef DEBUG\r\nvco.v = val & 0x1ff;\r\nvco.r = (val >> 9) & 0x7f;\r\nvco.s = (val >> 16) & 7;\r\npr_debug("IM-PD1: VCO%d clock is %ld Hz\n",\r\nvconr, icst525_hz(&impd1_vco_params, vco));\r\n#endif\r\n}\r\nvoid impd1_tweak_control(struct device *dev, u32 mask, u32 val)\r\n{\r\nstruct impd1_module *impd1 = dev_get_drvdata(dev);\r\nu32 cur;\r\nval &= mask;\r\ncur = readl(impd1->base + IMPD1_CTRL) & ~mask;\r\nwritel(cur | val, impd1->base + IMPD1_CTRL);\r\n}\r\nstatic void impd1fb_clcd_disable(struct clcd_fb *fb)\r\n{\r\nimpd1_tweak_control(fb->dev->dev.parent, IMPD1_CTRL_DISP_MASK, 0);\r\n}\r\nstatic void impd1fb_clcd_enable(struct clcd_fb *fb)\r\n{\r\nimpd1_tweak_control(fb->dev->dev.parent, IMPD1_CTRL_DISP_MASK,\r\nfb->panel->connector | IMPD1_CTRL_DISP_ENABLE);\r\n}\r\nstatic int impd1fb_clcd_setup(struct clcd_fb *fb)\r\n{\r\nunsigned long framebase = fb->dev->res.start + 0x01000000;\r\nunsigned long framesize = SZ_1M;\r\nint ret = 0;\r\nfb->panel = &PANELTYPE;\r\nif (!request_mem_region(framebase, framesize, "clcd framebuffer")) {\r\nprintk(KERN_ERR "IM-PD1: unable to reserve framebuffer\n");\r\nreturn -EBUSY;\r\n}\r\nfb->fb.screen_base = ioremap(framebase, framesize);\r\nif (!fb->fb.screen_base) {\r\nprintk(KERN_ERR "IM-PD1: unable to map framebuffer\n");\r\nret = -ENOMEM;\r\ngoto free_buffer;\r\n}\r\nfb->fb.fix.smem_start = framebase;\r\nfb->fb.fix.smem_len = framesize;\r\nreturn 0;\r\nfree_buffer:\r\nrelease_mem_region(framebase, framesize);\r\nreturn ret;\r\n}\r\nstatic int impd1fb_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)\r\n{\r\nunsigned long start, size;\r\nstart = vma->vm_pgoff + (fb->fb.fix.smem_start >> PAGE_SHIFT);\r\nsize = vma->vm_end - vma->vm_start;\r\nreturn remap_pfn_range(vma, vma->vm_start, start, size,\r\nvma->vm_page_prot);\r\n}\r\nstatic void impd1fb_clcd_remove(struct clcd_fb *fb)\r\n{\r\niounmap(fb->fb.screen_base);\r\nrelease_mem_region(fb->fb.fix.smem_start, fb->fb.fix.smem_len);\r\n}\r\nstatic int impd1_probe(struct lm_device *dev)\r\n{\r\nstruct impd1_module *impd1;\r\nint i, ret;\r\nif (dev->id != module_id)\r\nreturn -EINVAL;\r\nif (!request_mem_region(dev->resource.start, SZ_4K, "LM registers"))\r\nreturn -EBUSY;\r\nimpd1 = kzalloc(sizeof(struct impd1_module), GFP_KERNEL);\r\nif (!impd1) {\r\nret = -ENOMEM;\r\ngoto release_lm;\r\n}\r\nimpd1->base = ioremap(dev->resource.start, SZ_4K);\r\nif (!impd1->base) {\r\nret = -ENOMEM;\r\ngoto free_impd1;\r\n}\r\nlm_set_drvdata(dev, impd1);\r\nprintk("IM-PD1 found at 0x%08lx\n",\r\n(unsigned long)dev->resource.start);\r\nfor (i = 0; i < ARRAY_SIZE(impd1->vcos); i++) {\r\nimpd1->vcos[i].ops = &impd1_clk_ops,\r\nimpd1->vcos[i].owner = THIS_MODULE,\r\nimpd1->vcos[i].params = &impd1_vco_params,\r\nimpd1->vcos[i].data = impd1;\r\n}\r\nimpd1->vcos[0].vcoreg = impd1->base + IMPD1_OSC1;\r\nimpd1->vcos[1].vcoreg = impd1->base + IMPD1_OSC2;\r\nimpd1->clks[0] = clkdev_alloc(&impd1->vcos[0], NULL, "lm%x:01000",\r\ndev->id);\r\nimpd1->clks[1] = clkdev_alloc(&fixed_14745600, NULL, "lm%x:00100",\r\ndev->id);\r\nimpd1->clks[2] = clkdev_alloc(&fixed_14745600, NULL, "lm%x:00200",\r\ndev->id);\r\nfor (i = 0; i < ARRAY_SIZE(impd1->clks); i++)\r\nclkdev_add(impd1->clks[i]);\r\nfor (i = 0; i < ARRAY_SIZE(impd1_devs); i++) {\r\nstruct impd1_device *idev = impd1_devs + i;\r\nstruct amba_device *d;\r\nunsigned long pc_base;\r\npc_base = dev->resource.start + idev->offset;\r\nd = kzalloc(sizeof(struct amba_device), GFP_KERNEL);\r\nif (!d)\r\ncontinue;\r\ndev_set_name(&d->dev, "lm%x:%5.5lx", dev->id, idev->offset >> 12);\r\nd->dev.parent = &dev->dev;\r\nd->res.start = dev->resource.start + idev->offset;\r\nd->res.end = d->res.start + SZ_4K - 1;\r\nd->res.flags = IORESOURCE_MEM;\r\nd->irq[0] = dev->irq;\r\nd->irq[1] = dev->irq;\r\nd->periphid = idev->id;\r\nd->dev.platform_data = idev->platform_data;\r\nret = amba_device_register(d, &dev->resource);\r\nif (ret) {\r\ndev_err(&d->dev, "unable to register device: %d\n", ret);\r\nkfree(d);\r\n}\r\n}\r\nreturn 0;\r\nfree_impd1:\r\nif (impd1 && impd1->base)\r\niounmap(impd1->base);\r\nkfree(impd1);\r\nrelease_lm:\r\nrelease_mem_region(dev->resource.start, SZ_4K);\r\nreturn ret;\r\n}\r\nstatic int impd1_remove_one(struct device *dev, void *data)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void impd1_remove(struct lm_device *dev)\r\n{\r\nstruct impd1_module *impd1 = lm_get_drvdata(dev);\r\nint i;\r\ndevice_for_each_child(&dev->dev, NULL, impd1_remove_one);\r\nfor (i = 0; i < ARRAY_SIZE(impd1->clks); i++)\r\nclkdev_drop(impd1->clks[i]);\r\nlm_set_drvdata(dev, NULL);\r\niounmap(impd1->base);\r\nkfree(impd1);\r\nrelease_mem_region(dev->resource.start, SZ_4K);\r\n}\r\nstatic int __init impd1_init(void)\r\n{\r\nreturn lm_driver_register(&impd1_driver);\r\n}\r\nstatic void __exit impd1_exit(void)\r\n{\r\nlm_driver_unregister(&impd1_driver);\r\n}
