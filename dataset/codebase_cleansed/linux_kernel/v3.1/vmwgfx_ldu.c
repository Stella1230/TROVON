static void vmw_ldu_destroy(struct vmw_legacy_display_unit *ldu)\r\n{\r\nlist_del_init(&ldu->active);\r\nvmw_display_unit_cleanup(&ldu->base);\r\nkfree(ldu);\r\n}\r\nstatic void vmw_ldu_crtc_save(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void vmw_ldu_crtc_restore(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void vmw_ldu_crtc_gamma_set(struct drm_crtc *crtc,\r\nu16 *r, u16 *g, u16 *b,\r\nuint32_t start, uint32_t size)\r\n{\r\n}\r\nstatic void vmw_ldu_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nvmw_ldu_destroy(vmw_crtc_to_ldu(crtc));\r\n}\r\nstatic int vmw_ldu_commit_list(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_legacy_display *lds = dev_priv->ldu_priv;\r\nstruct vmw_legacy_display_unit *entry;\r\nstruct drm_framebuffer *fb = NULL;\r\nstruct drm_crtc *crtc = NULL;\r\nint i = 0;\r\nif (!(dev_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY)) {\r\nint w = 0, h = 0;\r\nlist_for_each_entry(entry, &lds->active, active) {\r\ncrtc = &entry->base.crtc;\r\nw = max(w, crtc->x + crtc->mode.hdisplay);\r\nh = max(h, crtc->y + crtc->mode.vdisplay);\r\ni++;\r\n}\r\nif (crtc == NULL)\r\nreturn 0;\r\nfb = entry->base.crtc.fb;\r\nvmw_kms_write_svga(dev_priv, w, h, fb->pitch,\r\nfb->bits_per_pixel, fb->depth);\r\nreturn 0;\r\n}\r\nif (!list_empty(&lds->active)) {\r\nentry = list_entry(lds->active.next, typeof(*entry), active);\r\nfb = entry->base.crtc.fb;\r\nvmw_kms_write_svga(dev_priv, fb->width, fb->height, fb->pitch,\r\nfb->bits_per_pixel, fb->depth);\r\n}\r\nvmw_write(dev_priv, SVGA_REG_NUM_GUEST_DISPLAYS,\r\nlds->num_active ? lds->num_active : 1);\r\ni = 0;\r\nlist_for_each_entry(entry, &lds->active, active) {\r\ncrtc = &entry->base.crtc;\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_ID, i);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_IS_PRIMARY, !i);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_POSITION_X, crtc->x);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_POSITION_Y, crtc->y);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_WIDTH, crtc->mode.hdisplay);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_HEIGHT, crtc->mode.vdisplay);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\ni++;\r\n}\r\nBUG_ON(i != lds->num_active);\r\nlds->last_num_active = lds->num_active;\r\nreturn 0;\r\n}\r\nstatic int vmw_ldu_del_active(struct vmw_private *vmw_priv,\r\nstruct vmw_legacy_display_unit *ldu)\r\n{\r\nstruct vmw_legacy_display *ld = vmw_priv->ldu_priv;\r\nif (list_empty(&ldu->active))\r\nreturn 0;\r\nlist_del_init(&ldu->active);\r\nif (--(ld->num_active) == 0) {\r\nBUG_ON(!ld->fb);\r\nif (ld->fb->unpin)\r\nld->fb->unpin(ld->fb);\r\nld->fb = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_ldu_add_active(struct vmw_private *vmw_priv,\r\nstruct vmw_legacy_display_unit *ldu,\r\nstruct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_legacy_display *ld = vmw_priv->ldu_priv;\r\nstruct vmw_legacy_display_unit *entry;\r\nstruct list_head *at;\r\nBUG_ON(!ld->num_active && ld->fb);\r\nif (vfb != ld->fb) {\r\nif (ld->fb && ld->fb->unpin)\r\nld->fb->unpin(ld->fb);\r\nif (vfb->pin)\r\nvfb->pin(vfb);\r\nld->fb = vfb;\r\n}\r\nif (!list_empty(&ldu->active))\r\nreturn 0;\r\nat = &ld->active;\r\nlist_for_each_entry(entry, &ld->active, active) {\r\nif (entry->base.unit > ldu->base.unit)\r\nbreak;\r\nat = &entry->active;\r\n}\r\nlist_add(&ldu->active, at);\r\nld->num_active++;\r\nreturn 0;\r\n}\r\nstatic int vmw_ldu_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nstruct vmw_private *dev_priv;\r\nstruct vmw_legacy_display_unit *ldu;\r\nstruct drm_connector *connector;\r\nstruct drm_display_mode *mode;\r\nstruct drm_encoder *encoder;\r\nstruct vmw_framebuffer *vfb;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_crtc *crtc;\r\nif (!set)\r\nreturn -EINVAL;\r\nif (!set->crtc)\r\nreturn -EINVAL;\r\ncrtc = set->crtc;\r\nldu = vmw_crtc_to_ldu(crtc);\r\nvfb = set->fb ? vmw_framebuffer_to_vfb(set->fb) : NULL;\r\ndev_priv = vmw_priv(crtc->dev);\r\nif (set->num_connectors > 1) {\r\nDRM_ERROR("to many connectors\n");\r\nreturn -EINVAL;\r\n}\r\nif (set->num_connectors == 1 &&\r\nset->connectors[0] != &ldu->base.connector) {\r\nDRM_ERROR("connector doesn't match %p %p\n",\r\nset->connectors[0], &ldu->base.connector);\r\nreturn -EINVAL;\r\n}\r\nif (dev_priv->ldu_priv->fb && vfb &&\r\n!(dev_priv->ldu_priv->num_active == 1 &&\r\n!list_empty(&ldu->active)) &&\r\ndev_priv->ldu_priv->fb != vfb) {\r\nDRM_ERROR("Multiple framebuffers not supported\n");\r\nreturn -EINVAL;\r\n}\r\nconnector = &ldu->base.connector;\r\nencoder = &ldu->base.encoder;\r\nif (set->num_connectors == 0 || !set->mode || !set->fb) {\r\nconnector->encoder = NULL;\r\nencoder->crtc = NULL;\r\ncrtc->fb = NULL;\r\nvmw_ldu_del_active(dev_priv, ldu);\r\nvmw_ldu_commit_list(dev_priv);\r\nreturn 0;\r\n}\r\nmode = set->mode;\r\nfb = set->fb;\r\nif (set->x + mode->hdisplay > fb->width ||\r\nset->y + mode->vdisplay > fb->height) {\r\nDRM_ERROR("set outside of framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nvmw_fb_off(dev_priv);\r\ncrtc->fb = fb;\r\nencoder->crtc = crtc;\r\nconnector->encoder = encoder;\r\ncrtc->x = set->x;\r\ncrtc->y = set->y;\r\ncrtc->mode = *mode;\r\nvmw_ldu_add_active(dev_priv, ldu, vfb);\r\nvmw_ldu_commit_list(dev_priv);\r\nreturn 0;\r\n}\r\nstatic void vmw_ldu_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nvmw_ldu_destroy(vmw_encoder_to_ldu(encoder));\r\n}\r\nstatic void vmw_ldu_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\n}\r\nstatic void vmw_ldu_connector_save(struct drm_connector *connector)\r\n{\r\n}\r\nstatic void vmw_ldu_connector_restore(struct drm_connector *connector)\r\n{\r\n}\r\nstatic enum drm_connector_status\r\nvmw_ldu_connector_detect(struct drm_connector *connector,\r\nbool force)\r\n{\r\nif (vmw_connector_to_ldu(connector)->pref_active)\r\nreturn connector_status_connected;\r\nreturn connector_status_disconnected;\r\n}\r\nstatic int vmw_ldu_connector_fill_modes(struct drm_connector *connector,\r\nuint32_t max_width, uint32_t max_height)\r\n{\r\nstruct vmw_legacy_display_unit *ldu = vmw_connector_to_ldu(connector);\r\nstruct drm_device *dev = connector->dev;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_display_mode prefmode = { DRM_MODE("preferred",\r\nDRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\nDRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC)\r\n};\r\nint i;\r\n{\r\nmode = drm_mode_duplicate(dev, &prefmode);\r\nif (!mode)\r\nreturn 0;\r\nmode->hdisplay = ldu->pref_width;\r\nmode->vdisplay = ldu->pref_height;\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\nif (vmw_kms_validate_mode_vram(dev_priv, mode->hdisplay * 2,\r\nmode->vdisplay)) {\r\ndrm_mode_probed_add(connector, mode);\r\nif (ldu->pref_mode) {\r\nlist_del_init(&ldu->pref_mode->head);\r\ndrm_mode_destroy(dev, ldu->pref_mode);\r\n}\r\nldu->pref_mode = mode;\r\n}\r\n}\r\nfor (i = 0; vmw_ldu_connector_builtin[i].type != 0; i++) {\r\nconst struct drm_display_mode *bmode;\r\nbmode = &vmw_ldu_connector_builtin[i];\r\nif (bmode->hdisplay > max_width ||\r\nbmode->vdisplay > max_height)\r\ncontinue;\r\nif (!vmw_kms_validate_mode_vram(dev_priv, bmode->hdisplay * 2,\r\nbmode->vdisplay))\r\ncontinue;\r\nmode = drm_mode_duplicate(dev, bmode);\r\nif (!mode)\r\nreturn 0;\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\ndrm_mode_connector_list_update(connector);\r\nreturn 1;\r\n}\r\nstatic int vmw_ldu_connector_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vmw_ldu_connector_destroy(struct drm_connector *connector)\r\n{\r\nvmw_ldu_destroy(vmw_connector_to_ldu(connector));\r\n}\r\nstatic int vmw_ldu_init(struct vmw_private *dev_priv, unsigned unit)\r\n{\r\nstruct vmw_legacy_display_unit *ldu;\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nldu = kzalloc(sizeof(*ldu), GFP_KERNEL);\r\nif (!ldu)\r\nreturn -ENOMEM;\r\nldu->base.unit = unit;\r\ncrtc = &ldu->base.crtc;\r\nencoder = &ldu->base.encoder;\r\nconnector = &ldu->base.connector;\r\nINIT_LIST_HEAD(&ldu->active);\r\nldu->pref_active = (unit == 0);\r\nldu->pref_width = 800;\r\nldu->pref_height = 600;\r\nldu->pref_mode = NULL;\r\ndrm_connector_init(dev, connector, &vmw_legacy_connector_funcs,\r\nDRM_MODE_CONNECTOR_LVDS);\r\nconnector->status = vmw_ldu_connector_detect(connector, true);\r\ndrm_encoder_init(dev, encoder, &vmw_legacy_encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nencoder->possible_crtcs = (1 << unit);\r\nencoder->possible_clones = 0;\r\ndrm_crtc_init(dev, crtc, &vmw_legacy_crtc_funcs);\r\ndrm_connector_attach_property(connector,\r\ndev->mode_config.dirty_info_property,\r\n1);\r\nreturn 0;\r\n}\r\nint vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nint i;\r\nint ret;\r\nif (dev_priv->ldu_priv) {\r\nDRM_INFO("ldu system already on\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->ldu_priv = kmalloc(sizeof(*dev_priv->ldu_priv), GFP_KERNEL);\r\nif (!dev_priv->ldu_priv)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&dev_priv->ldu_priv->active);\r\ndev_priv->ldu_priv->num_active = 0;\r\ndev_priv->ldu_priv->last_num_active = 0;\r\ndev_priv->ldu_priv->fb = NULL;\r\ndrm_mode_create_dirty_info_property(dev_priv->dev);\r\nif (dev_priv->capabilities & SVGA_CAP_MULTIMON) {\r\nfor (i = 0; i < VMWGFX_LDU_NUM_DU; ++i)\r\nvmw_ldu_init(dev_priv, i);\r\nret = drm_vblank_init(dev, VMWGFX_LDU_NUM_DU);\r\n} else {\r\nvmw_ldu_init(dev_priv, 0);\r\nret = drm_vblank_init(dev, 1);\r\n}\r\nreturn ret;\r\n}\r\nint vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\ndrm_vblank_cleanup(dev);\r\nif (!dev_priv->ldu_priv)\r\nreturn -ENOSYS;\r\nBUG_ON(!list_empty(&dev_priv->ldu_priv->active));\r\nkfree(dev_priv->ldu_priv);\r\nreturn 0;\r\n}\r\nint vmw_kms_ldu_update_layout(struct vmw_private *dev_priv, unsigned num,\r\nstruct drm_vmw_rect *rects)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_legacy_display_unit *ldu;\r\nstruct drm_connector *con;\r\nint i;\r\nmutex_lock(&dev->mode_config.mutex);\r\n#if 0\r\nDRM_INFO("%s: new layout ", __func__);\r\nfor (i = 0; i < (int)num; i++)\r\nDRM_INFO("(%i, %i %ux%u) ", rects[i].x, rects[i].y,\r\nrects[i].w, rects[i].h);\r\nDRM_INFO("\n");\r\n#else\r\n(void)i;\r\n#endif\r\nlist_for_each_entry(con, &dev->mode_config.connector_list, head) {\r\nldu = vmw_connector_to_ldu(con);\r\nif (num > ldu->base.unit) {\r\nldu->pref_width = rects[ldu->base.unit].w;\r\nldu->pref_height = rects[ldu->base.unit].h;\r\nldu->pref_active = true;\r\n} else {\r\nldu->pref_width = 800;\r\nldu->pref_height = 600;\r\nldu->pref_active = false;\r\n}\r\ncon->status = vmw_ldu_connector_detect(con, true);\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn 0;\r\n}
