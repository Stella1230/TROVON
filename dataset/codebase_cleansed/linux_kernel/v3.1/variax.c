static void variax_decode(const unsigned char *raw_data, unsigned char *data,\r\nint raw_size)\r\n{\r\nfor (; raw_size > 0; raw_size -= 6) {\r\ndata[2] = raw_data[0] | (raw_data[1] << 4);\r\ndata[1] = raw_data[2] | (raw_data[3] << 4);\r\ndata[0] = raw_data[4] | (raw_data[5] << 4);\r\nraw_data += 6;\r\ndata += 3;\r\n}\r\n}\r\nstatic void variax_activate_async(struct usb_line6_variax *variax, int a)\r\n{\r\nvariax->buffer_activate[VARIAX_OFFSET_ACTIVATE] = a;\r\nline6_send_raw_message_async(&variax->line6, variax->buffer_activate,\r\nsizeof(variax_activate));\r\n}\r\nstatic void variax_startup1(struct usb_line6_variax *variax)\r\n{\r\nCHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_INIT);\r\nline6_start_timer(&variax->startup_timer1, VARIAX_STARTUP_DELAY1,\r\nvariax_startup2, (unsigned long)variax);\r\n}\r\nstatic void variax_startup2(unsigned long data)\r\n{\r\nstruct usb_line6_variax *variax = (struct usb_line6_variax *)data;\r\nstruct usb_line6 *line6 = &variax->line6;\r\nif (variax->startup_progress >= VARIAX_STARTUP_LAST)\r\nreturn;\r\nvariax->startup_progress = VARIAX_STARTUP_VERSIONREQ;\r\nline6_start_timer(&variax->startup_timer1, VARIAX_STARTUP_DELAY1,\r\nvariax_startup2, (unsigned long)variax);\r\nline6_version_request_async(line6);\r\n}\r\nstatic void variax_startup3(struct usb_line6_variax *variax)\r\n{\r\nCHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_WAIT);\r\nline6_start_timer(&variax->startup_timer2, VARIAX_STARTUP_DELAY3,\r\nvariax_startup4, (unsigned long)variax);\r\n}\r\nstatic void variax_startup4(unsigned long data)\r\n{\r\nstruct usb_line6_variax *variax = (struct usb_line6_variax *)data;\r\nCHECK_STARTUP_PROGRESS(variax->startup_progress,\r\nVARIAX_STARTUP_ACTIVATE);\r\nvariax_activate_async(variax, 1);\r\nline6_start_timer(&variax->startup_timer2, VARIAX_STARTUP_DELAY4,\r\nvariax_startup5, (unsigned long)variax);\r\n}\r\nstatic void variax_startup5(unsigned long data)\r\n{\r\nstruct usb_line6_variax *variax = (struct usb_line6_variax *)data;\r\nCHECK_STARTUP_PROGRESS(variax->startup_progress,\r\nVARIAX_STARTUP_DUMPREQ);\r\nline6_dump_request_async(&variax->dumpreq, &variax->line6, 0,\r\nVARIAX_DUMP_PASS1);\r\n}\r\nstatic void variax_startup6(struct usb_line6_variax *variax)\r\n{\r\nCHECK_STARTUP_PROGRESS(variax->startup_progress,\r\nVARIAX_STARTUP_WORKQUEUE);\r\nschedule_work(&variax->startup_work);\r\n}\r\nstatic void variax_startup7(struct work_struct *work)\r\n{\r\nstruct usb_line6_variax *variax =\r\ncontainer_of(work, struct usb_line6_variax, startup_work);\r\nstruct usb_line6 *line6 = &variax->line6;\r\nCHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_SETUP);\r\nline6_register_audio(&variax->line6);\r\nline6_variax_create_files(0, 0, line6->ifcdev);\r\nvariax_create_files2(line6->ifcdev);\r\n}\r\nvoid line6_variax_process_message(struct usb_line6_variax *variax)\r\n{\r\nconst unsigned char *buf = variax->line6.buffer_message;\r\nswitch (buf[0]) {\r\ncase LINE6_PARAM_CHANGE | LINE6_CHANNEL_HOST:\r\nswitch (buf[1]) {\r\ncase VARIAXMIDI_volume:\r\nvariax->volume = buf[2];\r\nbreak;\r\ncase VARIAXMIDI_tone:\r\nvariax->tone = buf[2];\r\n}\r\nbreak;\r\ncase LINE6_PROGRAM_CHANGE | LINE6_CHANNEL_DEVICE:\r\ncase LINE6_PROGRAM_CHANGE | LINE6_CHANNEL_HOST:\r\nvariax->model = buf[1];\r\nline6_dump_request_async(&variax->dumpreq, &variax->line6, 0,\r\nVARIAX_DUMP_PASS1);\r\nbreak;\r\ncase LINE6_RESET:\r\ndev_info(variax->line6.ifcdev, "VARIAX reset\n");\r\nbreak;\r\ncase LINE6_SYSEX_BEGIN:\r\nif (memcmp(buf + 1, variax_request_model1 + 1,\r\nVARIAX_MODEL_HEADER_LENGTH - 1) == 0) {\r\nif (variax->line6.message_length ==\r\nVARIAX_MODEL_MESSAGE_LENGTH) {\r\nswitch (variax->dumpreq.in_progress) {\r\ncase VARIAX_DUMP_PASS1:\r\nvariax_decode(buf +\r\nVARIAX_MODEL_HEADER_LENGTH,\r\n(unsigned char *)\r\n&variax->model_data,\r\n(sizeof\r\n(variax->model_data.\r\nname) +\r\nsizeof(variax->\r\nmodel_data.\r\ncontrol)\r\n/ 2) * 2);\r\nline6_dump_request_async\r\n(&variax->dumpreq, &variax->line6,\r\n1, VARIAX_DUMP_PASS2);\r\nbreak;\r\ncase VARIAX_DUMP_PASS2:\r\nvariax_decode(buf +\r\nVARIAX_MODEL_HEADER_LENGTH,\r\n(unsigned char *)\r\n&variax->\r\nmodel_data.control +\r\nsizeof(variax->model_data.\r\ncontrol)\r\n/ 2,\r\nsizeof(variax->model_data.\r\ncontrol)\r\n/ 2 * 2);\r\nline6_dump_request_async\r\n(&variax->dumpreq, &variax->line6,\r\n2, VARIAX_DUMP_PASS3);\r\n}\r\n} else {\r\nDEBUG_MESSAGES(dev_err\r\n(variax->line6.ifcdev,\r\n"illegal length %d of model data\n",\r\nvariax->line6.message_length));\r\nline6_dump_finished(&variax->dumpreq);\r\n}\r\n} else if (memcmp(buf + 1, variax_request_bank + 1,\r\nsizeof(variax_request_bank) - 2) == 0) {\r\nmemcpy(variax->bank,\r\nbuf + sizeof(variax_request_bank) - 1,\r\nsizeof(variax->bank));\r\nline6_dump_finished(&variax->dumpreq);\r\nvariax_startup6(variax);\r\n} else if (memcmp(buf + 1, variax_init_model + 1,\r\nsizeof(variax_init_model) - 1) == 0) {\r\nmemcpy(variax->guitar,\r\nbuf + sizeof(variax_init_model),\r\nsizeof(variax->guitar));\r\n} else if (memcmp(buf + 1, variax_init_version + 1,\r\nsizeof(variax_init_version) - 1) == 0) {\r\nvariax_startup3(variax);\r\n} else if (memcmp(buf + 1, variax_init_done + 1,\r\nsizeof(variax_init_done) - 1) == 0) {\r\nvariax_startup4((unsigned long)variax);\r\n}\r\nbreak;\r\ncase LINE6_SYSEX_END:\r\nbreak;\r\ndefault:\r\nDEBUG_MESSAGES(dev_err\r\n(variax->line6.ifcdev,\r\n"Variax: unknown message %02X\n", buf[0]));\r\n}\r\n}\r\nstatic ssize_t variax_get_volume(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nreturn sprintf(buf, "%d\n", variax->volume);\r\n}\r\nstatic ssize_t variax_set_volume(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nunsigned long value;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\nif (line6_transmit_parameter(&variax->line6, VARIAXMIDI_volume,\r\nvalue) == 0)\r\nvariax->volume = value;\r\nreturn count;\r\n}\r\nstatic ssize_t variax_get_model(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nreturn sprintf(buf, "%d\n", variax->model);\r\n}\r\nstatic ssize_t variax_set_model(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nunsigned long value;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\nif (line6_send_program(&variax->line6, value) == 0)\r\nvariax->model = value;\r\nreturn count;\r\n}\r\nstatic ssize_t variax_get_active(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nreturn sprintf(buf, "%d\n",\r\nvariax->buffer_activate[VARIAX_OFFSET_ACTIVATE]);\r\n}\r\nstatic ssize_t variax_set_active(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nunsigned long value;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\nvariax_activate_async(variax, value ? 1 : 0);\r\nreturn count;\r\n}\r\nstatic ssize_t variax_get_tone(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nreturn sprintf(buf, "%d\n", variax->tone);\r\n}\r\nstatic ssize_t variax_set_tone(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nunsigned long value;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\nif (line6_transmit_parameter(&variax->line6, VARIAXMIDI_tone,\r\nvalue) == 0)\r\nvariax->tone = value;\r\nreturn count;\r\n}\r\nstatic ssize_t get_string(char *buf, const char *data, int length)\r\n{\r\nint i;\r\nmemcpy(buf, data, length);\r\nfor (i = length; i--;) {\r\nchar c = buf[i];\r\nif ((c != 0) && (c != ' '))\r\nbreak;\r\n}\r\nbuf[i + 1] = '\n';\r\nreturn i + 2;\r\n}\r\nstatic ssize_t variax_get_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nline6_dump_wait_interruptible(&variax->dumpreq);\r\nreturn get_string(buf, variax->model_data.name,\r\nsizeof(variax->model_data.name));\r\n}\r\nstatic ssize_t variax_get_bank(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nline6_dump_wait_interruptible(&variax->dumpreq);\r\nreturn get_string(buf, variax->bank, sizeof(variax->bank));\r\n}\r\nstatic ssize_t variax_get_dump(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nint retval;\r\nretval = line6_dump_wait_interruptible(&variax->dumpreq);\r\nif (retval < 0)\r\nreturn retval;\r\nmemcpy(buf, &variax->model_data.control,\r\nsizeof(variax->model_data.control));\r\nreturn sizeof(variax->model_data.control);\r\n}\r\nstatic ssize_t variax_get_guitar(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nreturn sprintf(buf, "%s\n", variax->guitar);\r\n}\r\nstatic char *variax_alloc_sysex_buffer(struct usb_line6_variax *variax,\r\nint code, int size)\r\n{\r\nreturn line6_alloc_sysex_buffer(&variax->line6, VARIAX_SYSEX_CODE, code,\r\nsize);\r\n}\r\nstatic ssize_t variax_set_raw2(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_line6_variax *variax =\r\nusb_get_intfdata(to_usb_interface(dev));\r\nint size;\r\nint i;\r\nchar *sysex;\r\ncount -= count % 3;\r\nsize = count * 2;\r\nsysex = variax_alloc_sysex_buffer(variax, VARIAX_SYSEX_PARAM, size);\r\nif (!sysex)\r\nreturn 0;\r\nfor (i = 0; i < count; i += 3) {\r\nconst unsigned char *p1 = buf + i;\r\nchar *p2 = sysex + SYSEX_DATA_OFS + i * 2;\r\np2[0] = p1[2] & 0x0f;\r\np2[1] = p1[2] >> 4;\r\np2[2] = p1[1] & 0x0f;\r\np2[3] = p1[1] >> 4;\r\np2[4] = p1[0] & 0x0f;\r\np2[5] = p1[0] >> 4;\r\n}\r\nline6_send_sysex_message(&variax->line6, sysex, size);\r\nkfree(sysex);\r\nreturn count;\r\n}\r\nstatic void variax_destruct(struct usb_interface *interface)\r\n{\r\nstruct usb_line6_variax *variax = usb_get_intfdata(interface);\r\nstruct usb_line6 *line6;\r\nif (variax == NULL)\r\nreturn;\r\nline6 = &variax->line6;\r\nif (line6 == NULL)\r\nreturn;\r\nline6_cleanup_audio(line6);\r\ndel_timer(&variax->startup_timer1);\r\ndel_timer(&variax->startup_timer2);\r\ncancel_work_sync(&variax->startup_work);\r\nline6_dumpreq_destructbuf(&variax->dumpreq, 2);\r\nline6_dumpreq_destructbuf(&variax->dumpreq, 1);\r\nline6_dumpreq_destruct(&variax->dumpreq);\r\nkfree(variax->buffer_activate);\r\n}\r\nstatic int variax_create_files2(struct device *dev)\r\n{\r\nint err;\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_model));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_volume));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_tone));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_name));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_bank));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_dump));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_active));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_guitar));\r\n#ifdef CONFIG_LINE6_USB_RAW\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_raw));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_raw2));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int variax_try_init(struct usb_interface *interface,\r\nstruct usb_line6_variax *variax)\r\n{\r\nint err;\r\ninit_timer(&variax->startup_timer1);\r\ninit_timer(&variax->startup_timer2);\r\nINIT_WORK(&variax->startup_work, variax_startup7);\r\nif ((interface == NULL) || (variax == NULL))\r\nreturn -ENODEV;\r\nerr = line6_dumpreq_init(&variax->dumpreq, variax_request_model1,\r\nsizeof(variax_request_model1));\r\nif (err < 0) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nreturn err;\r\n}\r\nerr = line6_dumpreq_initbuf(&variax->dumpreq, variax_request_model2,\r\nsizeof(variax_request_model2), 1);\r\nif (err < 0) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nreturn err;\r\n}\r\nerr = line6_dumpreq_initbuf(&variax->dumpreq, variax_request_bank,\r\nsizeof(variax_request_bank), 2);\r\nif (err < 0) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nreturn err;\r\n}\r\nvariax->buffer_activate = kmemdup(variax_activate,\r\nsizeof(variax_activate), GFP_KERNEL);\r\nif (variax->buffer_activate == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = line6_init_audio(&variax->line6);\r\nif (err < 0)\r\nreturn err;\r\nerr = line6_init_midi(&variax->line6);\r\nif (err < 0)\r\nreturn err;\r\nvariax_startup1(variax);\r\nreturn 0;\r\n}\r\nint line6_variax_init(struct usb_interface *interface,\r\nstruct usb_line6_variax *variax)\r\n{\r\nint err = variax_try_init(interface, variax);\r\nif (err < 0)\r\nvariax_destruct(interface);\r\nreturn err;\r\n}\r\nvoid line6_variax_disconnect(struct usb_interface *interface)\r\n{\r\nstruct device *dev;\r\nif (interface == NULL)\r\nreturn;\r\ndev = &interface->dev;\r\nif (dev != NULL) {\r\nline6_variax_remove_files(0, 0, dev);\r\ndevice_remove_file(dev, &dev_attr_model);\r\ndevice_remove_file(dev, &dev_attr_volume);\r\ndevice_remove_file(dev, &dev_attr_tone);\r\ndevice_remove_file(dev, &dev_attr_name);\r\ndevice_remove_file(dev, &dev_attr_bank);\r\ndevice_remove_file(dev, &dev_attr_dump);\r\ndevice_remove_file(dev, &dev_attr_active);\r\ndevice_remove_file(dev, &dev_attr_guitar);\r\n#ifdef CONFIG_LINE6_USB_RAW\r\ndevice_remove_file(dev, &dev_attr_raw);\r\ndevice_remove_file(dev, &dev_attr_raw2);\r\n#endif\r\n}\r\nvariax_destruct(interface);\r\n}
