static int _dpll_test_fint(struct clk *clk, u8 n)\r\n{\r\nstruct dpll_data *dd;\r\nlong fint;\r\nint ret = 0;\r\ndd = clk->dpll_data;\r\nfint = clk->parent->rate / n;\r\nif (fint < DPLL_FINT_BAND1_MIN) {\r\npr_debug("rejecting n=%d due to Fint failure, "\r\n"lowering max_divider\n", n);\r\ndd->max_divider = n;\r\nret = DPLL_FINT_UNDERFLOW;\r\n} else if (fint > DPLL_FINT_BAND1_MAX &&\r\nfint < DPLL_FINT_BAND2_MIN) {\r\npr_debug("rejecting n=%d due to Fint failure\n", n);\r\nret = DPLL_FINT_INVALID;\r\n} else if (fint > DPLL_FINT_BAND2_MAX) {\r\npr_debug("rejecting n=%d due to Fint failure, "\r\n"boosting min_divider\n", n);\r\ndd->min_divider = n;\r\nret = DPLL_FINT_INVALID;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned long _dpll_compute_new_rate(unsigned long parent_rate,\r\nunsigned int m, unsigned int n)\r\n{\r\nunsigned long long num;\r\nnum = (unsigned long long)parent_rate * m;\r\ndo_div(num, n);\r\nreturn num;\r\n}\r\nstatic int _dpll_test_mult(int *m, int n, unsigned long *new_rate,\r\nunsigned long target_rate,\r\nunsigned long parent_rate)\r\n{\r\nint r = 0, carry = 0;\r\nif (*m % DPLL_SCALE_FACTOR >= DPLL_ROUNDING_VAL)\r\ncarry = 1;\r\n*m = (*m / DPLL_SCALE_FACTOR) + carry;\r\n*new_rate = _dpll_compute_new_rate(parent_rate, *m, n);\r\nif (*new_rate > target_rate) {\r\n(*m)--;\r\n*new_rate = 0;\r\n}\r\nif (*m < DPLL_MIN_MULTIPLIER) {\r\n*m = DPLL_MIN_MULTIPLIER;\r\n*new_rate = 0;\r\nr = DPLL_MULT_UNDERFLOW;\r\n}\r\nif (*new_rate == 0)\r\n*new_rate = _dpll_compute_new_rate(parent_rate, *m, n);\r\nreturn r;\r\n}\r\nvoid omap2_init_dpll_parent(struct clk *clk)\r\n{\r\nu32 v;\r\nstruct dpll_data *dd;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn;\r\nv = __raw_readl(dd->control_reg);\r\nv &= dd->enable_mask;\r\nv >>= __ffs(dd->enable_mask);\r\nif (cpu_is_omap24xx()) {\r\nif (v == OMAP2XXX_EN_DPLL_LPBYPASS ||\r\nv == OMAP2XXX_EN_DPLL_FRBYPASS)\r\nclk_reparent(clk, dd->clk_bypass);\r\n} else if (cpu_is_omap34xx()) {\r\nif (v == OMAP3XXX_EN_DPLL_LPBYPASS ||\r\nv == OMAP3XXX_EN_DPLL_FRBYPASS)\r\nclk_reparent(clk, dd->clk_bypass);\r\n} else if (cpu_is_omap44xx()) {\r\nif (v == OMAP4XXX_EN_DPLL_LPBYPASS ||\r\nv == OMAP4XXX_EN_DPLL_FRBYPASS ||\r\nv == OMAP4XXX_EN_DPLL_MNBYPASS)\r\nclk_reparent(clk, dd->clk_bypass);\r\n}\r\nreturn;\r\n}\r\nu32 omap2_get_dpll_rate(struct clk *clk)\r\n{\r\nlong long dpll_clk;\r\nu32 dpll_mult, dpll_div, v;\r\nstruct dpll_data *dd;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn 0;\r\nv = __raw_readl(dd->control_reg);\r\nv &= dd->enable_mask;\r\nv >>= __ffs(dd->enable_mask);\r\nif (cpu_is_omap24xx()) {\r\nif (v == OMAP2XXX_EN_DPLL_LPBYPASS ||\r\nv == OMAP2XXX_EN_DPLL_FRBYPASS)\r\nreturn dd->clk_bypass->rate;\r\n} else if (cpu_is_omap34xx()) {\r\nif (v == OMAP3XXX_EN_DPLL_LPBYPASS ||\r\nv == OMAP3XXX_EN_DPLL_FRBYPASS)\r\nreturn dd->clk_bypass->rate;\r\n} else if (cpu_is_omap44xx()) {\r\nif (v == OMAP4XXX_EN_DPLL_LPBYPASS ||\r\nv == OMAP4XXX_EN_DPLL_FRBYPASS ||\r\nv == OMAP4XXX_EN_DPLL_MNBYPASS)\r\nreturn dd->clk_bypass->rate;\r\n}\r\nv = __raw_readl(dd->mult_div1_reg);\r\ndpll_mult = v & dd->mult_mask;\r\ndpll_mult >>= __ffs(dd->mult_mask);\r\ndpll_div = v & dd->div1_mask;\r\ndpll_div >>= __ffs(dd->div1_mask);\r\ndpll_clk = (long long)dd->clk_ref->rate * dpll_mult;\r\ndo_div(dpll_clk, dpll_div + 1);\r\nreturn dpll_clk;\r\n}\r\nlong omap2_dpll_round_rate(struct clk *clk, unsigned long target_rate)\r\n{\r\nint m, n, r, scaled_max_m;\r\nunsigned long scaled_rt_rp;\r\nunsigned long new_rate = 0;\r\nstruct dpll_data *dd;\r\nif (!clk || !clk->dpll_data)\r\nreturn ~0;\r\ndd = clk->dpll_data;\r\npr_debug("clock: %s: starting DPLL round_rate, target rate %ld\n",\r\nclk->name, target_rate);\r\nscaled_rt_rp = target_rate / (dd->clk_ref->rate / DPLL_SCALE_FACTOR);\r\nscaled_max_m = dd->max_multiplier * DPLL_SCALE_FACTOR;\r\ndd->last_rounded_rate = 0;\r\nfor (n = dd->min_divider; n <= dd->max_divider; n++) {\r\nr = _dpll_test_fint(clk, n);\r\nif (r == DPLL_FINT_UNDERFLOW)\r\nbreak;\r\nelse if (r == DPLL_FINT_INVALID)\r\ncontinue;\r\nm = scaled_rt_rp * n;\r\nif (m > scaled_max_m)\r\nbreak;\r\nr = _dpll_test_mult(&m, n, &new_rate, target_rate,\r\ndd->clk_ref->rate);\r\nif (r == DPLL_MULT_UNDERFLOW)\r\ncontinue;\r\npr_debug("clock: %s: m = %d: n = %d: new_rate = %ld\n",\r\nclk->name, m, n, new_rate);\r\nif (target_rate == new_rate) {\r\ndd->last_rounded_m = m;\r\ndd->last_rounded_n = n;\r\ndd->last_rounded_rate = target_rate;\r\nbreak;\r\n}\r\n}\r\nif (target_rate != new_rate) {\r\npr_debug("clock: %s: cannot round to rate %ld\n", clk->name,\r\ntarget_rate);\r\nreturn ~0;\r\n}\r\nreturn target_rate;\r\n}
