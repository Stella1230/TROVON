static inline size_t w1_f2d_fix_count(loff_t off, size_t count, size_t size)\r\n{\r\nif (off > size)\r\nreturn 0;\r\nif ((off + count) > size)\r\nreturn size - off;\r\nreturn count;\r\n}\r\nstatic int w1_f2d_readblock(struct w1_slave *sl, int off, int count, char *buf)\r\n{\r\nu8 wrbuf[3];\r\nu8 cmp[W1_F2D_READ_MAXLEN];\r\nint tries = W1_F2D_READ_RETRIES;\r\ndo {\r\nwrbuf[0] = W1_F2D_READ_EEPROM;\r\nwrbuf[1] = off & 0xff;\r\nwrbuf[2] = off >> 8;\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_read_block(sl->master, buf, count);\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_read_block(sl->master, cmp, count);\r\nif (!memcmp(cmp, buf, count))\r\nreturn 0;\r\n} while (--tries);\r\ndev_err(&sl->dev, "proof reading failed %d times\n",\r\nW1_F2D_READ_RETRIES);\r\nreturn -1;\r\n}\r\nstatic ssize_t w1_f2d_read_bin(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nint todo = count;\r\ncount = w1_f2d_fix_count(off, count, W1_F2D_EEPROM_SIZE);\r\nif (count == 0)\r\nreturn 0;\r\nmutex_lock(&sl->master->mutex);\r\nwhile (todo > 0) {\r\nint block_read;\r\nif (todo >= W1_F2D_READ_MAXLEN)\r\nblock_read = W1_F2D_READ_MAXLEN;\r\nelse\r\nblock_read = todo;\r\nif (w1_f2d_readblock(sl, off, block_read, buf) < 0)\r\ncount = -EIO;\r\ntodo -= W1_F2D_READ_MAXLEN;\r\nbuf += W1_F2D_READ_MAXLEN;\r\noff += W1_F2D_READ_MAXLEN;\r\n}\r\nmutex_unlock(&sl->master->mutex);\r\nreturn count;\r\n}\r\nstatic int w1_f2d_write(struct w1_slave *sl, int addr, int len, const u8 *data)\r\n{\r\nint tries = W1_F2D_READ_RETRIES;\r\nu8 wrbuf[4];\r\nu8 rdbuf[W1_F2D_SCRATCH_SIZE + 3];\r\nu8 es = (addr + len - 1) % W1_F2D_SCRATCH_SIZE;\r\nretry:\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nwrbuf[0] = W1_F2D_WRITE_SCRATCH;\r\nwrbuf[1] = addr & 0xff;\r\nwrbuf[2] = addr >> 8;\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_write_block(sl->master, data, len);\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nw1_write_8(sl->master, W1_F2D_READ_SCRATCH);\r\nw1_read_block(sl->master, rdbuf, len + 3);\r\nif ((rdbuf[0] != wrbuf[1]) || (rdbuf[1] != wrbuf[2]) ||\r\n(rdbuf[2] != es) || (memcmp(data, &rdbuf[3], len) != 0)) {\r\nif (--tries)\r\ngoto retry;\r\ndev_err(&sl->dev,\r\n"could not write to eeprom, scratchpad compare failed %d times\n",\r\nW1_F2D_READ_RETRIES);\r\nreturn -1;\r\n}\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nwrbuf[0] = W1_F2D_COPY_SCRATCH;\r\nwrbuf[3] = es;\r\nw1_write_block(sl->master, wrbuf, 4);\r\nmsleep(W1_F2D_TPROG_MS);\r\nw1_reset_bus(sl->master);\r\nreturn 0;\r\n}\r\nstatic ssize_t w1_f2d_write_bin(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nint addr, len;\r\nint copy;\r\ncount = w1_f2d_fix_count(off, count, W1_F2D_EEPROM_SIZE);\r\nif (count == 0)\r\nreturn 0;\r\nmutex_lock(&sl->master->mutex);\r\naddr = off;\r\nlen = count;\r\nwhile (len > 0) {\r\nif (len < W1_F2D_SCRATCH_SIZE || addr & W1_F2D_SCRATCH_MASK) {\r\nchar tmp[W1_F2D_SCRATCH_SIZE];\r\nif (w1_f2d_readblock(sl, addr & ~W1_F2D_SCRATCH_MASK,\r\nW1_F2D_SCRATCH_SIZE, tmp)) {\r\ncount = -EIO;\r\ngoto out_up;\r\n}\r\ncopy = W1_F2D_SCRATCH_SIZE -\r\n(addr & W1_F2D_SCRATCH_MASK);\r\nif (copy > len)\r\ncopy = len;\r\nmemcpy(&tmp[addr & W1_F2D_SCRATCH_MASK], buf, copy);\r\nif (w1_f2d_write(sl, addr & ~W1_F2D_SCRATCH_MASK,\r\nW1_F2D_SCRATCH_SIZE, tmp) < 0) {\r\ncount = -EIO;\r\ngoto out_up;\r\n}\r\n} else {\r\ncopy = W1_F2D_SCRATCH_SIZE;\r\nif (w1_f2d_write(sl, addr, copy, buf) < 0) {\r\ncount = -EIO;\r\ngoto out_up;\r\n}\r\n}\r\nbuf += copy;\r\naddr += copy;\r\nlen -= copy;\r\n}\r\nout_up:\r\nmutex_unlock(&sl->master->mutex);\r\nreturn count;\r\n}\r\nstatic int w1_f2d_add_slave(struct w1_slave *sl)\r\n{\r\nreturn sysfs_create_bin_file(&sl->dev.kobj, &w1_f2d_bin_attr);\r\n}\r\nstatic void w1_f2d_remove_slave(struct w1_slave *sl)\r\n{\r\nsysfs_remove_bin_file(&sl->dev.kobj, &w1_f2d_bin_attr);\r\n}\r\nstatic int __init w1_f2d_init(void)\r\n{\r\nreturn w1_register_family(&w1_family_2d);\r\n}\r\nstatic void __exit w1_f2d_fini(void)\r\n{\r\nw1_unregister_family(&w1_family_2d);\r\n}
