static inline void meram_write_icb(void __iomem *base, int idx, int off,\r\nunsigned long val)\r\n{\r\niowrite32(val, MERAM_ICB_OFFSET(base, idx, off));\r\n}\r\nstatic inline unsigned long meram_read_icb(void __iomem *base, int idx, int off)\r\n{\r\nreturn ioread32(MERAM_ICB_OFFSET(base, idx, off));\r\n}\r\nstatic inline void meram_write_reg(void __iomem *base, int off,\r\nunsigned long val)\r\n{\r\niowrite32(val, base + off);\r\n}\r\nstatic inline unsigned long meram_read_reg(void __iomem *base, int off)\r\n{\r\nreturn ioread32(base + off);\r\n}\r\nstatic inline int meram_check_overlap(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_icb *new)\r\n{\r\nint i;\r\nint used_start, used_end, meram_start, meram_end;\r\nif (new->marker_icb & ~0x1f || new->cache_icb & ~0x1f)\r\nreturn 1;\r\nif (test_bit(new->marker_icb, &priv->used_icb) ||\r\ntest_bit(new->cache_icb, &priv->used_icb))\r\nreturn 1;\r\nfor (i = 0; i < priv->used_meram_cache_regions; i++) {\r\nused_start = MERAM_CACHE_START(priv->used_meram_cache[i]);\r\nused_end = MERAM_CACHE_END(priv->used_meram_cache[i]);\r\nmeram_start = new->meram_offset;\r\nmeram_end = new->meram_offset + new->meram_size;\r\nif ((meram_start >= used_start && meram_start < used_end) ||\r\n(meram_end > used_start && meram_end < used_end))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void meram_mark(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_icb *new)\r\n{\r\nint n;\r\nif (new->marker_icb < 0 || new->cache_icb < 0)\r\nreturn;\r\n__set_bit(new->marker_icb, &priv->used_icb);\r\n__set_bit(new->cache_icb, &priv->used_icb);\r\nn = priv->used_meram_cache_regions;\r\npriv->used_meram_cache[n] = MERAM_CACHE_SET(new->meram_offset,\r\nnew->meram_size);\r\npriv->used_meram_cache_regions++;\r\n}\r\nstatic inline void meram_unmark(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_icb *icb)\r\n{\r\nint i;\r\nunsigned long pattern;\r\nif (icb->marker_icb < 0 || icb->cache_icb < 0)\r\nreturn;\r\n__clear_bit(icb->marker_icb, &priv->used_icb);\r\n__clear_bit(icb->cache_icb, &priv->used_icb);\r\npattern = MERAM_CACHE_SET(icb->meram_offset, icb->meram_size);\r\nfor (i = 0; i < priv->used_meram_cache_regions; i++) {\r\nif (priv->used_meram_cache[i] == pattern) {\r\nwhile (i < priv->used_meram_cache_regions - 1) {\r\npriv->used_meram_cache[i] =\r\npriv->used_meram_cache[i + 1] ;\r\ni++;\r\n}\r\npriv->used_meram_cache[i] = 0;\r\npriv->used_meram_cache_regions--;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic inline int is_nvcolor(int cspace)\r\n{\r\nif (cspace == SH_MOBILE_MERAM_PF_NV ||\r\ncspace == SH_MOBILE_MERAM_PF_NV24)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void meram_set_next_addr(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_cfg *cfg,\r\nunsigned long base_addr_y,\r\nunsigned long base_addr_c)\r\n{\r\nunsigned long target;\r\ntarget = (cfg->current_reg) ? MExxSARA : MExxSARB;\r\ncfg->current_reg ^= 1;\r\nmeram_write_icb(priv->base, cfg->icb[0].cache_icb, target,\r\nbase_addr_y);\r\nmeram_write_icb(priv->base, cfg->icb[0].marker_icb, target,\r\nbase_addr_y + cfg->icb[0].cache_unit);\r\nif (is_nvcolor(cfg->pixelformat)) {\r\nmeram_write_icb(priv->base, cfg->icb[1].cache_icb, target,\r\nbase_addr_c);\r\nmeram_write_icb(priv->base, cfg->icb[1].marker_icb, target,\r\nbase_addr_c + cfg->icb[1].cache_unit);\r\n}\r\n}\r\nstatic inline void meram_get_next_icb_addr(struct sh_mobile_meram_info *pdata,\r\nstruct sh_mobile_meram_cfg *cfg,\r\nunsigned long *icb_addr_y,\r\nunsigned long *icb_addr_c)\r\n{\r\nunsigned long icb_offset;\r\nif (pdata->addr_mode == SH_MOBILE_MERAM_MODE0)\r\nicb_offset = 0x80000000 | (cfg->current_reg << 29);\r\nelse\r\nicb_offset = 0xc0000000 | (cfg->current_reg << 23);\r\n*icb_addr_y = icb_offset | (cfg->icb[0].marker_icb << 24);\r\nif (is_nvcolor(cfg->pixelformat))\r\n*icb_addr_c = icb_offset | (cfg->icb[1].marker_icb << 24);\r\n}\r\nstatic int meram_init(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_icb *icb,\r\nint xres, int yres, int *out_pitch)\r\n{\r\nunsigned long total_byte_count = MERAM_CALC_BYTECOUNT(xres, yres);\r\nunsigned long bnm;\r\nint lcdc_pitch, xpitch, line_cnt;\r\nint save_lines;\r\nlcdc_pitch = (xres - 1) | 1023;\r\nlcdc_pitch = lcdc_pitch | (lcdc_pitch >> 1);\r\nlcdc_pitch = lcdc_pitch | (lcdc_pitch >> 2);\r\nlcdc_pitch += 1;\r\nif (lcdc_pitch == 8192 && yres >= 1024) {\r\nlcdc_pitch = xpitch = MERAM_LINE_WIDTH;\r\nline_cnt = total_byte_count >> 11;\r\n*out_pitch = xres;\r\nsave_lines = (icb->meram_size / 16 / MERAM_SEC_LINE);\r\nsave_lines *= MERAM_SEC_LINE;\r\n} else {\r\nxpitch = xres;\r\nline_cnt = yres;\r\n*out_pitch = lcdc_pitch;\r\nsave_lines = icb->meram_size / (lcdc_pitch >> 10) / 2;\r\nsave_lines &= 0xff;\r\n}\r\nbnm = (save_lines - 1) << 16;\r\nmeram_write_icb(priv->base, icb->cache_icb, MExxBSIZE,\r\nMERAM_MExxBSIZE_VAL(0x0, line_cnt - 1, xpitch - 1));\r\nmeram_write_icb(priv->base, icb->marker_icb, MExxBSIZE,\r\nMERAM_MExxBSIZE_VAL(0xf, line_cnt - 1, xpitch - 1));\r\nmeram_write_icb(priv->base, icb->cache_icb, MExxMNCF, bnm);\r\nmeram_write_icb(priv->base, icb->marker_icb, MExxMNCF, bnm);\r\nmeram_write_icb(priv->base, icb->cache_icb, MExxSBSIZE, xpitch);\r\nmeram_write_icb(priv->base, icb->marker_icb, MExxSBSIZE, xpitch);\r\nicb->cache_unit = xres * save_lines;\r\nmeram_write_icb(priv->base, icb->cache_icb, MExxCTL,\r\nMERAM_MExxCTL_VAL(0x70f, icb->marker_icb,\r\nicb->meram_offset));\r\nmeram_write_icb(priv->base, icb->marker_icb, MExxCTL,\r\nMERAM_MExxCTL_VAL(0x70f, icb->cache_icb,\r\nicb->meram_offset +\r\nicb->meram_size / 2));\r\nreturn 0;\r\n}\r\nstatic void meram_deinit(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_icb *icb)\r\n{\r\nmeram_write_icb(priv->base, icb->cache_icb, MExxCTL, 0);\r\nmeram_write_icb(priv->base, icb->marker_icb, MExxCTL, 0);\r\nicb->cache_unit = 0;\r\n}\r\nstatic int sh_mobile_meram_register(struct sh_mobile_meram_info *pdata,\r\nstruct sh_mobile_meram_cfg *cfg,\r\nint xres, int yres, int pixelformat,\r\nunsigned long base_addr_y,\r\nunsigned long base_addr_c,\r\nunsigned long *icb_addr_y,\r\nunsigned long *icb_addr_c,\r\nint *pitch)\r\n{\r\nstruct platform_device *pdev;\r\nstruct sh_mobile_meram_priv *priv;\r\nint n, out_pitch;\r\nint error = 0;\r\nif (!pdata || !pdata->priv || !pdata->pdev || !cfg)\r\nreturn -EINVAL;\r\nif (pixelformat != SH_MOBILE_MERAM_PF_NV &&\r\npixelformat != SH_MOBILE_MERAM_PF_NV24 &&\r\npixelformat != SH_MOBILE_MERAM_PF_RGB)\r\nreturn -EINVAL;\r\npriv = pdata->priv;\r\npdev = pdata->pdev;\r\ndev_dbg(&pdev->dev, "registering %dx%d (%s) (y=%08lx, c=%08lx)",\r\nxres, yres, (!pixelformat) ? "yuv" : "rgb",\r\nbase_addr_y, base_addr_c);\r\nmutex_lock(&priv->lock);\r\nif (xres > 8192) {\r\ndev_err(&pdev->dev, "width exceeding the limit (> 8192).");\r\nerror = -EINVAL;\r\ngoto err;\r\n}\r\nif (priv->used_meram_cache_regions + 2 > SH_MOBILE_MERAM_ICB_NUM) {\r\ndev_err(&pdev->dev, "no more ICB available.");\r\nerror = -EINVAL;\r\ngoto err;\r\n}\r\nif (cfg->icb[0].marker_icb < 0 || cfg->icb[0].cache_icb < 0) {\r\ndev_err(&pdev->dev, "at least one ICB is required.");\r\nerror = -EINVAL;\r\ngoto err;\r\n}\r\nif (meram_check_overlap(priv, &cfg->icb[0])) {\r\ndev_err(&pdev->dev, "conflicting config detected.");\r\nerror = -EINVAL;\r\ngoto err;\r\n}\r\nn = 1;\r\nif (cfg->icb[1].marker_icb >= 0 && cfg->icb[1].cache_icb >= 0) {\r\nif (meram_check_overlap(priv, &cfg->icb[1])) {\r\ndev_err(&pdev->dev, "conflicting config detected.");\r\nerror = -EINVAL;\r\ngoto err;\r\n}\r\nn = 2;\r\n}\r\nif (is_nvcolor(pixelformat) && n != 2) {\r\ndev_err(&pdev->dev, "requires two ICB sets for planar Y/C.");\r\nerror = -EINVAL;\r\ngoto err;\r\n}\r\ncfg->pixelformat = pixelformat;\r\nmeram_mark(priv, &cfg->icb[0]);\r\nif (is_nvcolor(pixelformat))\r\nmeram_mark(priv, &cfg->icb[1]);\r\nmeram_init(priv, &cfg->icb[0], xres, yres, &out_pitch);\r\n*pitch = out_pitch;\r\nif (pixelformat == SH_MOBILE_MERAM_PF_NV)\r\nmeram_init(priv, &cfg->icb[1], xres, (yres + 1) / 2,\r\n&out_pitch);\r\nelse if (pixelformat == SH_MOBILE_MERAM_PF_NV24)\r\nmeram_init(priv, &cfg->icb[1], 2 * xres, (yres + 1) / 2,\r\n&out_pitch);\r\ncfg->current_reg = 1;\r\nmeram_set_next_addr(priv, cfg, base_addr_y, base_addr_c);\r\nmeram_get_next_icb_addr(pdata, cfg, icb_addr_y, icb_addr_c);\r\ndev_dbg(&pdev->dev, "registered - can access via y=%08lx, c=%08lx",\r\n*icb_addr_y, *icb_addr_c);\r\nerr:\r\nmutex_unlock(&priv->lock);\r\nreturn error;\r\n}\r\nstatic int sh_mobile_meram_unregister(struct sh_mobile_meram_info *pdata,\r\nstruct sh_mobile_meram_cfg *cfg)\r\n{\r\nstruct sh_mobile_meram_priv *priv;\r\nif (!pdata || !pdata->priv || !cfg)\r\nreturn -EINVAL;\r\npriv = pdata->priv;\r\nmutex_lock(&priv->lock);\r\nif (is_nvcolor(cfg->pixelformat)) {\r\nmeram_deinit(priv, &cfg->icb[1]);\r\nmeram_unmark(priv, &cfg->icb[1]);\r\n}\r\nmeram_deinit(priv, &cfg->icb[0]);\r\nmeram_unmark(priv, &cfg->icb[0]);\r\nmutex_unlock(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_meram_update(struct sh_mobile_meram_info *pdata,\r\nstruct sh_mobile_meram_cfg *cfg,\r\nunsigned long base_addr_y,\r\nunsigned long base_addr_c,\r\nunsigned long *icb_addr_y,\r\nunsigned long *icb_addr_c)\r\n{\r\nstruct sh_mobile_meram_priv *priv;\r\nif (!pdata || !pdata->priv || !cfg)\r\nreturn -EINVAL;\r\npriv = pdata->priv;\r\nmutex_lock(&priv->lock);\r\nmeram_set_next_addr(priv, cfg, base_addr_y, base_addr_c);\r\nmeram_get_next_icb_addr(pdata, cfg, icb_addr_y, icb_addr_c);\r\nmutex_unlock(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int __devinit sh_mobile_meram_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_meram_priv *priv;\r\nstruct sh_mobile_meram_info *pdata = pdev->dev.platform_data;\r\nstruct resource *res;\r\nint error;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot get platform resources\n");\r\nreturn -ENOENT;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "cannot allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nmutex_init(&priv->lock);\r\npriv->base = ioremap_nocache(res->start, resource_size(res));\r\nif (!priv->base) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nerror = -EFAULT;\r\ngoto err;\r\n}\r\npdata->ops = &sh_mobile_meram_ops;\r\npdata->priv = priv;\r\npdata->pdev = pdev;\r\nif (pdata->addr_mode == SH_MOBILE_MERAM_MODE1)\r\nmeram_write_reg(priv->base, MEVCR1, 1 << 29);\r\ndev_info(&pdev->dev, "sh_mobile_meram initialized.");\r\nreturn 0;\r\nerr:\r\nsh_mobile_meram_remove(pdev);\r\nreturn error;\r\n}\r\nstatic int sh_mobile_meram_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_meram_priv *priv = platform_get_drvdata(pdev);\r\nif (priv->base)\r\niounmap(priv->base);\r\nmutex_destroy(&priv->lock);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init sh_mobile_meram_init(void)\r\n{\r\nreturn platform_driver_register(&sh_mobile_meram_driver);\r\n}\r\nstatic void __exit sh_mobile_meram_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_mobile_meram_driver);\r\n}
