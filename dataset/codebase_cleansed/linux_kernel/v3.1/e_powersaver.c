static unsigned int eps_get(unsigned int cpu)\r\n{\r\nstruct eps_cpu_data *centaur;\r\nu32 lo, hi;\r\nif (cpu)\r\nreturn 0;\r\ncentaur = eps_cpu[cpu];\r\nif (centaur == NULL)\r\nreturn 0;\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\nreturn centaur->fsb * ((lo >> 8) & 0xff);\r\n}\r\nstatic int eps_set_state(struct eps_cpu_data *centaur,\r\nunsigned int cpu,\r\nu32 dest_state)\r\n{\r\nstruct cpufreq_freqs freqs;\r\nu32 lo, hi;\r\nint err = 0;\r\nint i;\r\nfreqs.old = eps_get(cpu);\r\nfreqs.new = centaur->fsb * ((dest_state >> 8) & 0xff);\r\nfreqs.cpu = cpu;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ni = 0;\r\nwhile (lo & ((1 << 16) | (1 << 17))) {\r\nudelay(16);\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ni++;\r\nif (unlikely(i > 64)) {\r\nerr = -ENODEV;\r\ngoto postchange;\r\n}\r\n}\r\nwrmsr(MSR_IA32_PERF_CTL, dest_state & 0xffff, 0);\r\ni = 0;\r\ndo {\r\nudelay(16);\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ni++;\r\nif (unlikely(i > 64)) {\r\nerr = -ENODEV;\r\ngoto postchange;\r\n}\r\n} while (lo & ((1 << 16) | (1 << 17)));\r\npostchange:\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\nfreqs.new = centaur->fsb * ((lo >> 8) & 0xff);\r\n#ifdef DEBUG\r\n{\r\nu8 current_multiplier, current_voltage;\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ncurrent_voltage = lo & 0xff;\r\nprintk(KERN_INFO "eps: Current voltage = %dmV\n",\r\ncurrent_voltage * 16 + 700);\r\ncurrent_multiplier = (lo >> 8) & 0xff;\r\nprintk(KERN_INFO "eps: Current multiplier = %d\n",\r\ncurrent_multiplier);\r\n}\r\n#endif\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\nreturn err;\r\n}\r\nstatic int eps_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nstruct eps_cpu_data *centaur;\r\nunsigned int newstate = 0;\r\nunsigned int cpu = policy->cpu;\r\nunsigned int dest_state;\r\nint ret;\r\nif (unlikely(eps_cpu[cpu] == NULL))\r\nreturn -ENODEV;\r\ncentaur = eps_cpu[cpu];\r\nif (unlikely(cpufreq_frequency_table_target(policy,\r\n&eps_cpu[cpu]->freq_table[0],\r\ntarget_freq,\r\nrelation,\r\n&newstate))) {\r\nreturn -EINVAL;\r\n}\r\ndest_state = centaur->freq_table[newstate].index & 0xffff;\r\nret = eps_set_state(centaur, cpu, dest_state);\r\nif (ret)\r\nprintk(KERN_ERR "eps: Timeout!\n");\r\nreturn ret;\r\n}\r\nstatic int eps_verify(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy,\r\n&eps_cpu[policy->cpu]->freq_table[0]);\r\n}\r\nstatic int eps_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int i;\r\nu32 lo, hi;\r\nu64 val;\r\nu8 current_multiplier, current_voltage;\r\nu8 max_multiplier, max_voltage;\r\nu8 min_multiplier, min_voltage;\r\nu8 brand = 0;\r\nu32 fsb;\r\nstruct eps_cpu_data *centaur;\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nstruct cpufreq_frequency_table *f_table;\r\nint k, step, voltage;\r\nint ret;\r\nint states;\r\nif (policy->cpu != 0)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "eps: Detected VIA ");\r\nswitch (c->x86_model) {\r\ncase 10:\r\nrdmsr(0x1153, lo, hi);\r\nbrand = (((lo >> 2) ^ lo) >> 18) & 3;\r\nprintk(KERN_CONT "Model A ");\r\nbreak;\r\ncase 13:\r\nrdmsr(0x1154, lo, hi);\r\nbrand = (((lo >> 4) ^ (lo >> 2))) & 0x000000ff;\r\nprintk(KERN_CONT "Model D ");\r\nbreak;\r\n}\r\nswitch (brand) {\r\ncase EPS_BRAND_C7M:\r\nprintk(KERN_CONT "C7-M\n");\r\nbreak;\r\ncase EPS_BRAND_C7:\r\nprintk(KERN_CONT "C7\n");\r\nbreak;\r\ncase EPS_BRAND_EDEN:\r\nprintk(KERN_CONT "Eden\n");\r\nbreak;\r\ncase EPS_BRAND_C7D:\r\nprintk(KERN_CONT "C7-D\n");\r\nbreak;\r\ncase EPS_BRAND_C3:\r\nprintk(KERN_CONT "C3\n");\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\nrdmsrl(MSR_IA32_MISC_ENABLE, val);\r\nif (!(val & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\r\nval |= MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP;\r\nwrmsrl(MSR_IA32_MISC_ENABLE, val);\r\nrdmsrl(MSR_IA32_MISC_ENABLE, val);\r\nif (!(val & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\r\nprintk(KERN_INFO "eps: Can't enable Enhanced PowerSaver\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\ncurrent_voltage = lo & 0xff;\r\nprintk(KERN_INFO "eps: Current voltage = %dmV\n",\r\ncurrent_voltage * 16 + 700);\r\ncurrent_multiplier = (lo >> 8) & 0xff;\r\nprintk(KERN_INFO "eps: Current multiplier = %d\n", current_multiplier);\r\nmax_voltage = hi & 0xff;\r\nprintk(KERN_INFO "eps: Highest voltage = %dmV\n",\r\nmax_voltage * 16 + 700);\r\nmax_multiplier = (hi >> 8) & 0xff;\r\nprintk(KERN_INFO "eps: Highest multiplier = %d\n", max_multiplier);\r\nmin_voltage = (hi >> 16) & 0xff;\r\nprintk(KERN_INFO "eps: Lowest voltage = %dmV\n",\r\nmin_voltage * 16 + 700);\r\nmin_multiplier = (hi >> 24) & 0xff;\r\nprintk(KERN_INFO "eps: Lowest multiplier = %d\n", min_multiplier);\r\nif (current_multiplier == 0 || max_multiplier == 0\r\n|| min_multiplier == 0)\r\nreturn -EINVAL;\r\nif (current_multiplier > max_multiplier\r\n|| max_multiplier <= min_multiplier)\r\nreturn -EINVAL;\r\nif (current_voltage > 0x1f || max_voltage > 0x1f)\r\nreturn -EINVAL;\r\nif (max_voltage < min_voltage)\r\nreturn -EINVAL;\r\nfsb = cpu_khz / current_multiplier;\r\nif (brand == EPS_BRAND_C7M)\r\nstates = max_multiplier - min_multiplier + 1;\r\nelse\r\nstates = 2;\r\ncentaur = kzalloc(sizeof(struct eps_cpu_data)\r\n+ (states + 1) * sizeof(struct cpufreq_frequency_table),\r\nGFP_KERNEL);\r\nif (!centaur)\r\nreturn -ENOMEM;\r\neps_cpu[0] = centaur;\r\ncentaur->fsb = fsb;\r\nf_table = &centaur->freq_table[0];\r\nif (brand != EPS_BRAND_C7M) {\r\nf_table[0].frequency = fsb * min_multiplier;\r\nf_table[0].index = (min_multiplier << 8) | min_voltage;\r\nf_table[1].frequency = fsb * max_multiplier;\r\nf_table[1].index = (max_multiplier << 8) | max_voltage;\r\nf_table[2].frequency = CPUFREQ_TABLE_END;\r\n} else {\r\nk = 0;\r\nstep = ((max_voltage - min_voltage) * 256)\r\n/ (max_multiplier - min_multiplier);\r\nfor (i = min_multiplier; i <= max_multiplier; i++) {\r\nvoltage = (k * step) / 256 + min_voltage;\r\nf_table[k].frequency = fsb * i;\r\nf_table[k].index = (i << 8) | voltage;\r\nk++;\r\n}\r\nf_table[k].frequency = CPUFREQ_TABLE_END;\r\n}\r\npolicy->cpuinfo.transition_latency = 140000;\r\npolicy->cur = fsb * current_multiplier;\r\nret = cpufreq_frequency_table_cpuinfo(policy, &centaur->freq_table[0]);\r\nif (ret) {\r\nkfree(centaur);\r\nreturn ret;\r\n}\r\ncpufreq_frequency_table_get_attr(&centaur->freq_table[0], policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int eps_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nstruct eps_cpu_data *centaur;\r\nu32 lo, hi;\r\nif (eps_cpu[cpu] == NULL)\r\nreturn -ENODEV;\r\ncentaur = eps_cpu[cpu];\r\nrdmsr(MSR_IA32_PERF_STATUS, lo, hi);\r\neps_set_state(centaur, cpu, hi & 0xffff);\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nkfree(eps_cpu[cpu]);\r\neps_cpu[cpu] = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init eps_init(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nif (c->x86_vendor != X86_VENDOR_CENTAUR\r\n|| c->x86 != 6 || c->x86_model < 10)\r\nreturn -ENODEV;\r\nif (!cpu_has(c, X86_FEATURE_EST))\r\nreturn -ENODEV;\r\nif (cpufreq_register_driver(&eps_driver))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void __exit eps_exit(void)\r\n{\r\ncpufreq_unregister_driver(&eps_driver);\r\n}
