static void onenand_lock_handle(struct onenand_chip *this, int cmd)\r\n{\r\nint block_lock_scheme;\r\nint status;\r\nstatus = ONENAND_GET_WP_STATUS(this);\r\nblock_lock_scheme = !(this->options & ONENAND_HAS_CONT_LOCK);\r\nswitch (cmd) {\r\ncase ONENAND_CMD_UNLOCK:\r\ncase ONENAND_CMD_UNLOCK_ALL:\r\nif (block_lock_scheme)\r\nONENAND_SET_WP_STATUS(ONENAND_WP_US, this);\r\nelse\r\nONENAND_SET_WP_STATUS(status | ONENAND_WP_US, this);\r\nbreak;\r\ncase ONENAND_CMD_LOCK:\r\nif (block_lock_scheme)\r\nONENAND_SET_WP_STATUS(ONENAND_WP_LS, this);\r\nelse\r\nONENAND_SET_WP_STATUS(status | ONENAND_WP_LS, this);\r\nbreak;\r\ncase ONENAND_CMD_LOCK_TIGHT:\r\nif (block_lock_scheme)\r\nONENAND_SET_WP_STATUS(ONENAND_WP_LTS, this);\r\nelse\r\nONENAND_SET_WP_STATUS(status | ONENAND_WP_LTS, this);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void onenand_bootram_handle(struct onenand_chip *this, int cmd)\r\n{\r\nswitch (cmd) {\r\ncase ONENAND_CMD_READID:\r\nwritew(manuf_id, this->base);\r\nwritew(device_id, this->base + 2);\r\nwritew(version_id, this->base + 4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void onenand_update_interrupt(struct onenand_chip *this, int cmd)\r\n{\r\nint interrupt = ONENAND_INT_MASTER;\r\nswitch (cmd) {\r\ncase ONENAND_CMD_READ:\r\ncase ONENAND_CMD_READOOB:\r\ninterrupt |= ONENAND_INT_READ;\r\nbreak;\r\ncase ONENAND_CMD_PROG:\r\ncase ONENAND_CMD_PROGOOB:\r\ninterrupt |= ONENAND_INT_WRITE;\r\nbreak;\r\ncase ONENAND_CMD_ERASE:\r\ninterrupt |= ONENAND_INT_ERASE;\r\nbreak;\r\ncase ONENAND_CMD_RESET:\r\ninterrupt |= ONENAND_INT_RESET;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritew(interrupt, this->base + ONENAND_REG_INTERRUPT);\r\n}\r\nstatic int onenand_check_overwrite(void *dest, void *src, size_t count)\r\n{\r\nunsigned int *s = (unsigned int *) src;\r\nunsigned int *d = (unsigned int *) dest;\r\nint i;\r\ncount >>= 2;\r\nfor (i = 0; i < count; i++)\r\nif ((*s++ ^ *d++) != 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void onenand_data_handle(struct onenand_chip *this, int cmd,\r\nint dataram, unsigned int offset)\r\n{\r\nstruct mtd_info *mtd = &info->mtd;\r\nstruct onenand_flash *flash = this->priv;\r\nint main_offset, spare_offset, die = 0;\r\nvoid __iomem *src;\r\nvoid __iomem *dest;\r\nunsigned int i;\r\nstatic int pi_operation;\r\nint erasesize, rgn;\r\nif (dataram) {\r\nmain_offset = mtd->writesize;\r\nspare_offset = mtd->oobsize;\r\n} else {\r\nmain_offset = 0;\r\nspare_offset = 0;\r\n}\r\nif (pi_operation) {\r\ndie = readw(this->base + ONENAND_REG_START_ADDRESS2);\r\ndie >>= ONENAND_DDP_SHIFT;\r\n}\r\nswitch (cmd) {\r\ncase FLEXONENAND_CMD_PI_ACCESS:\r\npi_operation = 1;\r\nbreak;\r\ncase ONENAND_CMD_RESET:\r\npi_operation = 0;\r\nbreak;\r\ncase ONENAND_CMD_READ:\r\nsrc = ONENAND_CORE(flash) + offset;\r\ndest = ONENAND_MAIN_AREA(this, main_offset);\r\nif (pi_operation) {\r\nwritew(boundary[die], this->base + ONENAND_DATARAM);\r\nbreak;\r\n}\r\nmemcpy(dest, src, mtd->writesize);\r\ncase ONENAND_CMD_READOOB:\r\nsrc = ONENAND_CORE_SPARE(flash, this, offset);\r\ndest = ONENAND_SPARE_AREA(this, spare_offset);\r\nmemcpy(dest, src, mtd->oobsize);\r\nbreak;\r\ncase ONENAND_CMD_PROG:\r\nsrc = ONENAND_MAIN_AREA(this, main_offset);\r\ndest = ONENAND_CORE(flash) + offset;\r\nif (pi_operation) {\r\nboundary[die] = readw(this->base + ONENAND_DATARAM);\r\nbreak;\r\n}\r\nfor (i = 0; i < (1 << mtd->subpage_sft); i++) {\r\nint off = i * this->subpagesize;\r\nif (!memcmp(src + off, ffchars, this->subpagesize))\r\ncontinue;\r\nif (memcmp(dest + off, ffchars, this->subpagesize) &&\r\nonenand_check_overwrite(dest + off, src + off, this->subpagesize))\r\nprintk(KERN_ERR "over-write happened at 0x%08x\n", offset);\r\nmemcpy(dest + off, src + off, this->subpagesize);\r\n}\r\ncase ONENAND_CMD_PROGOOB:\r\nsrc = ONENAND_SPARE_AREA(this, spare_offset);\r\nif (!memcmp(src, ffchars, mtd->oobsize))\r\nbreak;\r\ndest = ONENAND_CORE_SPARE(flash, this, offset);\r\nif (memcmp(dest, ffchars, mtd->oobsize) &&\r\nonenand_check_overwrite(dest, src, mtd->oobsize))\r\nprintk(KERN_ERR "OOB: over-write happened at 0x%08x\n",\r\noffset);\r\nmemcpy(dest, src, mtd->oobsize);\r\nbreak;\r\ncase ONENAND_CMD_ERASE:\r\nif (pi_operation)\r\nbreak;\r\nif (FLEXONENAND(this)) {\r\nrgn = flexonenand_region(mtd, offset);\r\nerasesize = mtd->eraseregions[rgn].erasesize;\r\n} else\r\nerasesize = mtd->erasesize;\r\nmemset(ONENAND_CORE(flash) + offset, 0xff, erasesize);\r\nmemset(ONENAND_CORE_SPARE(flash, this, offset), 0xff,\r\n(erasesize >> 5));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void onenand_command_handle(struct onenand_chip *this, int cmd)\r\n{\r\nunsigned long offset = 0;\r\nint block = -1, page = -1, bufferram = -1;\r\nint dataram = 0;\r\nswitch (cmd) {\r\ncase ONENAND_CMD_UNLOCK:\r\ncase ONENAND_CMD_LOCK:\r\ncase ONENAND_CMD_LOCK_TIGHT:\r\ncase ONENAND_CMD_UNLOCK_ALL:\r\nonenand_lock_handle(this, cmd);\r\nbreak;\r\ncase ONENAND_CMD_BUFFERRAM:\r\nreturn;\r\ndefault:\r\nblock = (int) readw(this->base + ONENAND_REG_START_ADDRESS1);\r\nif (block & (1 << ONENAND_DDP_SHIFT)) {\r\nblock &= ~(1 << ONENAND_DDP_SHIFT);\r\nblock += this->chipsize >> (this->erase_shift + 1);\r\n}\r\nif (cmd == ONENAND_CMD_ERASE)\r\nbreak;\r\npage = (int) readw(this->base + ONENAND_REG_START_ADDRESS8);\r\npage = (page >> ONENAND_FPA_SHIFT);\r\nbufferram = (int) readw(this->base + ONENAND_REG_START_BUFFER);\r\nbufferram >>= ONENAND_BSA_SHIFT;\r\nbufferram &= ONENAND_BSA_DATARAM1;\r\ndataram = (bufferram == ONENAND_BSA_DATARAM1) ? 1 : 0;\r\nbreak;\r\n}\r\nif (block != -1)\r\noffset = onenand_addr(this, block);\r\nif (page != -1)\r\noffset += page << this->page_shift;\r\nonenand_data_handle(this, cmd, dataram, offset);\r\nonenand_update_interrupt(this, cmd);\r\n}\r\nstatic void onenand_writew(unsigned short value, void __iomem * addr)\r\n{\r\nstruct onenand_chip *this = info->mtd.priv;\r\nif (addr < this->base + ONENAND_DATARAM) {\r\nonenand_bootram_handle(this, value);\r\nreturn;\r\n}\r\nif (addr == this->base + ONENAND_REG_COMMAND)\r\nonenand_command_handle(this, value);\r\nwritew(value, addr);\r\n}\r\nstatic int __init flash_init(struct onenand_flash *flash)\r\n{\r\nint density, size;\r\nint buffer_size;\r\nflash->base = kzalloc(131072, GFP_KERNEL);\r\nif (!flash->base) {\r\nprintk(KERN_ERR "Unable to allocate base address.\n");\r\nreturn -ENOMEM;\r\n}\r\ndensity = device_id >> ONENAND_DEVICE_DENSITY_SHIFT;\r\ndensity &= ONENAND_DEVICE_DENSITY_MASK;\r\nsize = ((16 << 20) << density);\r\nONENAND_CORE(flash) = vmalloc(size + (size >> 5));\r\nif (!ONENAND_CORE(flash)) {\r\nprintk(KERN_ERR "Unable to allocate nand core address.\n");\r\nkfree(flash->base);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ONENAND_CORE(flash), 0xff, size + (size >> 5));\r\nwritew(manuf_id, flash->base + ONENAND_REG_MANUFACTURER_ID);\r\nwritew(device_id, flash->base + ONENAND_REG_DEVICE_ID);\r\nwritew(version_id, flash->base + ONENAND_REG_VERSION_ID);\r\nwritew(technology_id, flash->base + ONENAND_REG_TECHNOLOGY);\r\nif (density < 2 && (!CONFIG_FLEXONENAND))\r\nbuffer_size = 0x0400;\r\nelse\r\nbuffer_size = 0x0800;\r\nwritew(buffer_size, flash->base + ONENAND_REG_DATA_BUFFER_SIZE);\r\nreturn 0;\r\n}\r\nstatic void flash_exit(struct onenand_flash *flash)\r\n{\r\nvfree(ONENAND_CORE(flash));\r\nkfree(flash->base);\r\n}\r\nstatic int __init onenand_sim_init(void)\r\n{\r\nffchars = kmalloc(MAX_ONENAND_PAGESIZE, GFP_KERNEL);\r\nif (!ffchars) {\r\nprintk(KERN_ERR "Unable to allocate ff chars.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(ffchars, 0xff, MAX_ONENAND_PAGESIZE);\r\ninfo = kzalloc(sizeof(struct onenand_info), GFP_KERNEL);\r\nif (!info) {\r\nprintk(KERN_ERR "Unable to allocate core structures.\n");\r\nkfree(ffchars);\r\nreturn -ENOMEM;\r\n}\r\ninfo->onenand.write_word = onenand_writew;\r\nif (flash_init(&info->flash)) {\r\nprintk(KERN_ERR "Unable to allocate flash.\n");\r\nkfree(ffchars);\r\nkfree(info);\r\nreturn -ENOMEM;\r\n}\r\ninfo->parts = os_partitions;\r\ninfo->onenand.base = info->flash.base;\r\ninfo->onenand.priv = &info->flash;\r\ninfo->mtd.name = "OneNAND simulator";\r\ninfo->mtd.priv = &info->onenand;\r\ninfo->mtd.owner = THIS_MODULE;\r\nif (onenand_scan(&info->mtd, 1)) {\r\nflash_exit(&info->flash);\r\nkfree(ffchars);\r\nkfree(info);\r\nreturn -ENXIO;\r\n}\r\nmtd_device_register(&info->mtd, info->parts,\r\nARRAY_SIZE(os_partitions));\r\nreturn 0;\r\n}\r\nstatic void __exit onenand_sim_exit(void)\r\n{\r\nstruct onenand_chip *this = info->mtd.priv;\r\nstruct onenand_flash *flash = this->priv;\r\nonenand_release(&info->mtd);\r\nflash_exit(flash);\r\nkfree(ffchars);\r\nkfree(info);\r\n}
