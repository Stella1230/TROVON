ktime_t timecompare_transform(struct timecompare *sync,\r\nu64 source_tstamp)\r\n{\r\nu64 nsec;\r\nnsec = source_tstamp + sync->offset;\r\nnsec += (s64)(source_tstamp - sync->last_update) * sync->skew /\r\nTIMECOMPARE_SKEW_RESOLUTION;\r\nreturn ns_to_ktime(nsec);\r\n}\r\nint timecompare_offset(struct timecompare *sync,\r\ns64 *offset,\r\nu64 *source_tstamp)\r\n{\r\nu64 start_source = 0, end_source = 0;\r\nstruct {\r\ns64 offset;\r\ns64 duration_target;\r\n} buffer[10], sample, *samples;\r\nint counter = 0, i;\r\nint used;\r\nint index;\r\nint num_samples = sync->num_samples;\r\nif (num_samples > ARRAY_SIZE(buffer)) {\r\nsamples = kmalloc(sizeof(*samples) * num_samples, GFP_ATOMIC);\r\nif (!samples) {\r\nsamples = buffer;\r\nnum_samples = ARRAY_SIZE(buffer);\r\n}\r\n} else {\r\nsamples = buffer;\r\n}\r\ni = 0;\r\ncounter = 0;\r\nwhile (1) {\r\nu64 ts;\r\nktime_t start, end;\r\nstart = sync->target();\r\nts = timecounter_read(sync->source);\r\nend = sync->target();\r\nif (!i)\r\nstart_source = ts;\r\nsample.duration_target = ktime_to_ns(ktime_sub(end, start));\r\nif (sample.duration_target >= 0) {\r\nsample.offset =\r\n(ktime_to_ns(end) + ktime_to_ns(start)) / 2 -\r\nts;\r\nindex = counter - 1;\r\nwhile (index >= 0) {\r\nif (samples[index].duration_target <\r\nsample.duration_target)\r\nbreak;\r\nsamples[index + 1] = samples[index];\r\nindex--;\r\n}\r\nsamples[index + 1] = sample;\r\ncounter++;\r\n}\r\ni++;\r\nif (counter >= num_samples || i >= 100000) {\r\nend_source = ts;\r\nbreak;\r\n}\r\n}\r\n*source_tstamp = (end_source + start_source) / 2;\r\nused = counter * 3 / 4;\r\nif (!used)\r\nused = counter;\r\nif (used) {\r\ns64 off = 0;\r\nfor (index = 0; index < used; index++)\r\noff += samples[index].offset;\r\n*offset = div_s64(off, used);\r\n}\r\nif (samples && samples != buffer)\r\nkfree(samples);\r\nreturn used;\r\n}\r\nvoid __timecompare_update(struct timecompare *sync,\r\nu64 source_tstamp)\r\n{\r\ns64 offset;\r\nu64 average_time;\r\nif (!timecompare_offset(sync, &offset, &average_time))\r\nreturn;\r\nif (!sync->last_update) {\r\nsync->last_update = average_time;\r\nsync->offset = offset;\r\nsync->skew = 0;\r\n} else {\r\ns64 delta_nsec = average_time - sync->last_update;\r\nif (delta_nsec >= 10000) {\r\ns64 delta_offset_nsec = offset - sync->offset;\r\ns64 skew;\r\nu64 divisor;\r\nskew = delta_offset_nsec * TIMECOMPARE_SKEW_RESOLUTION;\r\ndivisor = delta_nsec;\r\nwhile (unlikely(divisor >= ((s64)1) << 32)) {\r\nskew = div_s64(skew, 2);\r\ndivisor >>= 1;\r\n}\r\nskew = div_s64(skew, divisor);\r\n#define TIMECOMPARE_NEW_SKEW_PER_16 12\r\nsync->skew =\r\ndiv_s64((16 - TIMECOMPARE_NEW_SKEW_PER_16) *\r\nsync->skew +\r\nTIMECOMPARE_NEW_SKEW_PER_16 * skew,\r\n16);\r\nsync->last_update = average_time;\r\nsync->offset = offset;\r\n}\r\n}\r\n}
