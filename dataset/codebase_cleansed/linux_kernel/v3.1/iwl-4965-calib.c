void iwl4965_calib_free_results(struct iwl_priv *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < IWL_CALIB_MAX; i++) {\r\nkfree(priv->calib_results[i].buf);\r\npriv->calib_results[i].buf = NULL;\r\npriv->calib_results[i].buf_len = 0;\r\n}\r\n}\r\nstatic int iwl4965_sens_energy_cck(struct iwl_priv *priv,\r\nu32 norm_fa,\r\nu32 rx_enable_time,\r\nstruct statistics_general_data *rx_info)\r\n{\r\nu32 max_nrg_cck = 0;\r\nint i = 0;\r\nu8 max_silence_rssi = 0;\r\nu32 silence_ref = 0;\r\nu8 silence_rssi_a = 0;\r\nu8 silence_rssi_b = 0;\r\nu8 silence_rssi_c = 0;\r\nu32 val;\r\nu32 false_alarms = norm_fa * 200 * 1024;\r\nu32 max_false_alarms = MAX_FA_CCK * rx_enable_time;\r\nu32 min_false_alarms = MIN_FA_CCK * rx_enable_time;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\r\ndata = &(priv->sensitivity_data);\r\ndata->nrg_auto_corr_silence_diff = 0;\r\nsilence_rssi_a = (u8)((rx_info->beacon_silence_rssi_a &\r\nALL_BAND_FILTER) >> 8);\r\nsilence_rssi_b = (u8)((rx_info->beacon_silence_rssi_b &\r\nALL_BAND_FILTER) >> 8);\r\nsilence_rssi_c = (u8)((rx_info->beacon_silence_rssi_c &\r\nALL_BAND_FILTER) >> 8);\r\nval = max(silence_rssi_b, silence_rssi_c);\r\nmax_silence_rssi = max(silence_rssi_a, (u8) val);\r\ndata->nrg_silence_rssi[data->nrg_silence_idx] = max_silence_rssi;\r\ndata->nrg_silence_idx++;\r\nif (data->nrg_silence_idx >= NRG_NUM_PREV_STAT_L)\r\ndata->nrg_silence_idx = 0;\r\nfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++) {\r\nval = data->nrg_silence_rssi[i];\r\nsilence_ref = max(silence_ref, val);\r\n}\r\nIWL_DEBUG_CALIB(priv, "silence a %u, b %u, c %u, 20-bcn max %u\n",\r\nsilence_rssi_a, silence_rssi_b, silence_rssi_c,\r\nsilence_ref);\r\ni = data->nrg_energy_idx;\r\nval = min(rx_info->beacon_energy_b, rx_info->beacon_energy_c);\r\ndata->nrg_value[i] = min(rx_info->beacon_energy_a, val);\r\ndata->nrg_energy_idx++;\r\nif (data->nrg_energy_idx >= 10)\r\ndata->nrg_energy_idx = 0;\r\nmax_nrg_cck = data->nrg_value[0];\r\nfor (i = 1; i < 10; i++)\r\nmax_nrg_cck = (u32) max(max_nrg_cck, (data->nrg_value[i]));\r\nmax_nrg_cck += 6;\r\nIWL_DEBUG_CALIB(priv, "rx energy a %u, b %u, c %u, 10-bcn max/min %u\n",\r\nrx_info->beacon_energy_a, rx_info->beacon_energy_b,\r\nrx_info->beacon_energy_c, max_nrg_cck - 6);\r\nif (false_alarms < min_false_alarms)\r\ndata->num_in_cck_no_fa++;\r\nelse\r\ndata->num_in_cck_no_fa = 0;\r\nIWL_DEBUG_CALIB(priv, "consecutive bcns with few false alarms = %u\n",\r\ndata->num_in_cck_no_fa);\r\nif ((false_alarms > max_false_alarms) &&\r\n(data->auto_corr_cck > AUTO_CORR_MAX_TH_CCK)) {\r\nIWL_DEBUG_CALIB(priv, "norm FA %u > max FA %u\n",\r\nfalse_alarms, max_false_alarms);\r\nIWL_DEBUG_CALIB(priv, "... reducing sensitivity\n");\r\ndata->nrg_curr_state = IWL_FA_TOO_MANY;\r\ndata->nrg_silence_ref = silence_ref;\r\ndata->nrg_th_cck = data->nrg_th_cck - NRG_STEP_CCK;\r\n} else if (false_alarms < min_false_alarms) {\r\ndata->nrg_curr_state = IWL_FA_TOO_FEW;\r\ndata->nrg_auto_corr_silence_diff = (s32)data->nrg_silence_ref -\r\n(s32)silence_ref;\r\nIWL_DEBUG_CALIB(priv,\r\n"norm FA %u < min FA %u, silence diff %d\n",\r\nfalse_alarms, min_false_alarms,\r\ndata->nrg_auto_corr_silence_diff);\r\nif ((data->nrg_prev_state != IWL_FA_TOO_MANY) &&\r\n((data->nrg_auto_corr_silence_diff > NRG_DIFF) ||\r\n(data->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA))) {\r\nIWL_DEBUG_CALIB(priv, "... increasing sensitivity\n");\r\nval = data->nrg_th_cck + NRG_STEP_CCK;\r\ndata->nrg_th_cck = min((u32)ranges->min_nrg_cck, val);\r\n} else {\r\nIWL_DEBUG_CALIB(priv,\r\n"... but not changing sensitivity\n");\r\n}\r\n} else {\r\nIWL_DEBUG_CALIB(priv, " FA in safe zone\n");\r\ndata->nrg_curr_state = IWL_FA_GOOD_RANGE;\r\ndata->nrg_silence_ref = silence_ref;\r\nif (IWL_FA_TOO_MANY == data->nrg_prev_state) {\r\nIWL_DEBUG_CALIB(priv, "... increasing margin\n");\r\nif (data->nrg_th_cck > (max_nrg_cck + NRG_MARGIN))\r\ndata->nrg_th_cck -= NRG_MARGIN;\r\nelse\r\ndata->nrg_th_cck = max_nrg_cck;\r\n}\r\n}\r\ndata->nrg_th_cck = max(max_nrg_cck, data->nrg_th_cck);\r\nIWL_DEBUG_CALIB(priv, "new nrg_th_cck %u\n", data->nrg_th_cck);\r\ndata->nrg_prev_state = data->nrg_curr_state;\r\nif (false_alarms > min_false_alarms) {\r\nif (data->auto_corr_cck < AUTO_CORR_MAX_TH_CCK)\r\ndata->auto_corr_cck = AUTO_CORR_MAX_TH_CCK + 1;\r\nelse {\r\nval = data->auto_corr_cck + AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck =\r\nmin((u32)ranges->auto_corr_max_cck, val);\r\n}\r\nval = data->auto_corr_cck_mrc + AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck_mrc =\r\nmin((u32)ranges->auto_corr_max_cck_mrc, val);\r\n} else if ((false_alarms < min_false_alarms) &&\r\n((data->nrg_auto_corr_silence_diff > NRG_DIFF) ||\r\n(data->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA))) {\r\nval = data->auto_corr_cck - AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck =\r\nmax((u32)ranges->auto_corr_min_cck, val);\r\nval = data->auto_corr_cck_mrc - AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck_mrc =\r\nmax((u32)ranges->auto_corr_min_cck_mrc, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iwl4965_sens_auto_corr_ofdm(struct iwl_priv *priv,\r\nu32 norm_fa,\r\nu32 rx_enable_time)\r\n{\r\nu32 val;\r\nu32 false_alarms = norm_fa * 200 * 1024;\r\nu32 max_false_alarms = MAX_FA_OFDM * rx_enable_time;\r\nu32 min_false_alarms = MIN_FA_OFDM * rx_enable_time;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\r\ndata = &(priv->sensitivity_data);\r\nif (false_alarms > max_false_alarms) {\r\nIWL_DEBUG_CALIB(priv, "norm FA %u > max FA %u)\n",\r\nfalse_alarms, max_false_alarms);\r\nval = data->auto_corr_ofdm + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm =\r\nmin((u32)ranges->auto_corr_max_ofdm, val);\r\nval = data->auto_corr_ofdm_mrc + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc =\r\nmin((u32)ranges->auto_corr_max_ofdm_mrc, val);\r\nval = data->auto_corr_ofdm_x1 + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_x1 =\r\nmin((u32)ranges->auto_corr_max_ofdm_x1, val);\r\nval = data->auto_corr_ofdm_mrc_x1 + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc_x1 =\r\nmin((u32)ranges->auto_corr_max_ofdm_mrc_x1, val);\r\n}\r\nelse if (false_alarms < min_false_alarms) {\r\nIWL_DEBUG_CALIB(priv, "norm FA %u < min FA %u\n",\r\nfalse_alarms, min_false_alarms);\r\nval = data->auto_corr_ofdm - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm =\r\nmax((u32)ranges->auto_corr_min_ofdm, val);\r\nval = data->auto_corr_ofdm_mrc - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc =\r\nmax((u32)ranges->auto_corr_min_ofdm_mrc, val);\r\nval = data->auto_corr_ofdm_x1 - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_x1 =\r\nmax((u32)ranges->auto_corr_min_ofdm_x1, val);\r\nval = data->auto_corr_ofdm_mrc_x1 - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc_x1 =\r\nmax((u32)ranges->auto_corr_min_ofdm_mrc_x1, val);\r\n} else {\r\nIWL_DEBUG_CALIB(priv, "min FA %u < norm FA %u < max FA %u OK\n",\r\nmin_false_alarms, false_alarms, max_false_alarms);\r\n}\r\nreturn 0;\r\n}\r\nstatic void iwl4965_prepare_legacy_sensitivity_tbl(struct iwl_priv *priv,\r\nstruct iwl_sensitivity_data *data,\r\n__le16 *tbl)\r\n{\r\ntbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_ofdm);\r\ntbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_MRC_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_ofdm_mrc);\r\ntbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_ofdm_x1);\r\ntbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_MRC_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_ofdm_mrc_x1);\r\ntbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_cck);\r\ntbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_cck_mrc);\r\ntbl[HD_MIN_ENERGY_CCK_DET_INDEX] =\r\ncpu_to_le16((u16)data->nrg_th_cck);\r\ntbl[HD_MIN_ENERGY_OFDM_DET_INDEX] =\r\ncpu_to_le16((u16)data->nrg_th_ofdm);\r\ntbl[HD_BARKER_CORR_TH_ADD_MIN_INDEX] =\r\ncpu_to_le16(data->barker_corr_th_min);\r\ntbl[HD_BARKER_CORR_TH_ADD_MIN_MRC_INDEX] =\r\ncpu_to_le16(data->barker_corr_th_min_mrc);\r\ntbl[HD_OFDM_ENERGY_TH_IN_INDEX] =\r\ncpu_to_le16(data->nrg_th_cca);\r\nIWL_DEBUG_CALIB(priv, "ofdm: ac %u mrc %u x1 %u mrc_x1 %u thresh %u\n",\r\ndata->auto_corr_ofdm, data->auto_corr_ofdm_mrc,\r\ndata->auto_corr_ofdm_x1, data->auto_corr_ofdm_mrc_x1,\r\ndata->nrg_th_ofdm);\r\nIWL_DEBUG_CALIB(priv, "cck: ac %u mrc %u thresh %u\n",\r\ndata->auto_corr_cck, data->auto_corr_cck_mrc,\r\ndata->nrg_th_cck);\r\n}\r\nstatic int iwl4965_sensitivity_write(struct iwl_priv *priv)\r\n{\r\nstruct iwl_sensitivity_cmd cmd;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nstruct iwl_host_cmd cmd_out = {\r\n.id = SENSITIVITY_CMD,\r\n.len = sizeof(struct iwl_sensitivity_cmd),\r\n.flags = CMD_ASYNC,\r\n.data = &cmd,\r\n};\r\ndata = &(priv->sensitivity_data);\r\nmemset(&cmd, 0, sizeof(cmd));\r\niwl4965_prepare_legacy_sensitivity_tbl(priv, data, &cmd.table[0]);\r\ncmd.control = SENSITIVITY_CMD_CONTROL_WORK_TABLE;\r\nif (!memcmp(&cmd.table[0], &(priv->sensitivity_tbl[0]),\r\nsizeof(u16)*HD_TABLE_SIZE)) {\r\nIWL_DEBUG_CALIB(priv, "No change in SENSITIVITY_CMD\n");\r\nreturn 0;\r\n}\r\nmemcpy(&(priv->sensitivity_tbl[0]), &(cmd.table[0]),\r\nsizeof(u16)*HD_TABLE_SIZE);\r\nreturn iwl_legacy_send_cmd(priv, &cmd_out);\r\n}\r\nvoid iwl4965_init_sensitivity(struct iwl_priv *priv)\r\n{\r\nint ret = 0;\r\nint i;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\r\nif (priv->disable_sens_cal)\r\nreturn;\r\nIWL_DEBUG_CALIB(priv, "Start iwl4965_init_sensitivity\n");\r\ndata = &(priv->sensitivity_data);\r\nif (ranges == NULL)\r\nreturn;\r\nmemset(data, 0, sizeof(struct iwl_sensitivity_data));\r\ndata->num_in_cck_no_fa = 0;\r\ndata->nrg_curr_state = IWL_FA_TOO_MANY;\r\ndata->nrg_prev_state = IWL_FA_TOO_MANY;\r\ndata->nrg_silence_ref = 0;\r\ndata->nrg_silence_idx = 0;\r\ndata->nrg_energy_idx = 0;\r\nfor (i = 0; i < 10; i++)\r\ndata->nrg_value[i] = 0;\r\nfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++)\r\ndata->nrg_silence_rssi[i] = 0;\r\ndata->auto_corr_ofdm = ranges->auto_corr_min_ofdm;\r\ndata->auto_corr_ofdm_mrc = ranges->auto_corr_min_ofdm_mrc;\r\ndata->auto_corr_ofdm_x1 = ranges->auto_corr_min_ofdm_x1;\r\ndata->auto_corr_ofdm_mrc_x1 = ranges->auto_corr_min_ofdm_mrc_x1;\r\ndata->auto_corr_cck = AUTO_CORR_CCK_MIN_VAL_DEF;\r\ndata->auto_corr_cck_mrc = ranges->auto_corr_min_cck_mrc;\r\ndata->nrg_th_cck = ranges->nrg_th_cck;\r\ndata->nrg_th_ofdm = ranges->nrg_th_ofdm;\r\ndata->barker_corr_th_min = ranges->barker_corr_th_min;\r\ndata->barker_corr_th_min_mrc = ranges->barker_corr_th_min_mrc;\r\ndata->nrg_th_cca = ranges->nrg_th_cca;\r\ndata->last_bad_plcp_cnt_ofdm = 0;\r\ndata->last_fa_cnt_ofdm = 0;\r\ndata->last_bad_plcp_cnt_cck = 0;\r\ndata->last_fa_cnt_cck = 0;\r\nret |= iwl4965_sensitivity_write(priv);\r\nIWL_DEBUG_CALIB(priv, "<<return 0x%X\n", ret);\r\n}\r\nvoid iwl4965_sensitivity_calibration(struct iwl_priv *priv, void *resp)\r\n{\r\nu32 rx_enable_time;\r\nu32 fa_cck;\r\nu32 fa_ofdm;\r\nu32 bad_plcp_cck;\r\nu32 bad_plcp_ofdm;\r\nu32 norm_fa_ofdm;\r\nu32 norm_fa_cck;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nstruct statistics_rx_non_phy *rx_info;\r\nstruct statistics_rx_phy *ofdm, *cck;\r\nunsigned long flags;\r\nstruct statistics_general_data statis;\r\nif (priv->disable_sens_cal)\r\nreturn;\r\ndata = &(priv->sensitivity_data);\r\nif (!iwl_legacy_is_any_associated(priv)) {\r\nIWL_DEBUG_CALIB(priv, "<< - not associated\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrx_info = &(((struct iwl_notif_statistics *)resp)->rx.general);\r\nofdm = &(((struct iwl_notif_statistics *)resp)->rx.ofdm);\r\ncck = &(((struct iwl_notif_statistics *)resp)->rx.cck);\r\nif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\r\nIWL_DEBUG_CALIB(priv, "<< invalid data.\n");\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\nrx_enable_time = le32_to_cpu(rx_info->channel_load);\r\nfa_cck = le32_to_cpu(cck->false_alarm_cnt);\r\nfa_ofdm = le32_to_cpu(ofdm->false_alarm_cnt);\r\nbad_plcp_cck = le32_to_cpu(cck->plcp_err);\r\nbad_plcp_ofdm = le32_to_cpu(ofdm->plcp_err);\r\nstatis.beacon_silence_rssi_a =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_a);\r\nstatis.beacon_silence_rssi_b =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_b);\r\nstatis.beacon_silence_rssi_c =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_c);\r\nstatis.beacon_energy_a =\r\nle32_to_cpu(rx_info->beacon_energy_a);\r\nstatis.beacon_energy_b =\r\nle32_to_cpu(rx_info->beacon_energy_b);\r\nstatis.beacon_energy_c =\r\nle32_to_cpu(rx_info->beacon_energy_c);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nIWL_DEBUG_CALIB(priv, "rx_enable_time = %u usecs\n", rx_enable_time);\r\nif (!rx_enable_time) {\r\nIWL_DEBUG_CALIB(priv, "<< RX Enable Time == 0!\n");\r\nreturn;\r\n}\r\nif (data->last_bad_plcp_cnt_cck > bad_plcp_cck)\r\ndata->last_bad_plcp_cnt_cck = bad_plcp_cck;\r\nelse {\r\nbad_plcp_cck -= data->last_bad_plcp_cnt_cck;\r\ndata->last_bad_plcp_cnt_cck += bad_plcp_cck;\r\n}\r\nif (data->last_bad_plcp_cnt_ofdm > bad_plcp_ofdm)\r\ndata->last_bad_plcp_cnt_ofdm = bad_plcp_ofdm;\r\nelse {\r\nbad_plcp_ofdm -= data->last_bad_plcp_cnt_ofdm;\r\ndata->last_bad_plcp_cnt_ofdm += bad_plcp_ofdm;\r\n}\r\nif (data->last_fa_cnt_ofdm > fa_ofdm)\r\ndata->last_fa_cnt_ofdm = fa_ofdm;\r\nelse {\r\nfa_ofdm -= data->last_fa_cnt_ofdm;\r\ndata->last_fa_cnt_ofdm += fa_ofdm;\r\n}\r\nif (data->last_fa_cnt_cck > fa_cck)\r\ndata->last_fa_cnt_cck = fa_cck;\r\nelse {\r\nfa_cck -= data->last_fa_cnt_cck;\r\ndata->last_fa_cnt_cck += fa_cck;\r\n}\r\nnorm_fa_ofdm = fa_ofdm + bad_plcp_ofdm;\r\nnorm_fa_cck = fa_cck + bad_plcp_cck;\r\nIWL_DEBUG_CALIB(priv,\r\n"cck: fa %u badp %u ofdm: fa %u badp %u\n", fa_cck,\r\nbad_plcp_cck, fa_ofdm, bad_plcp_ofdm);\r\niwl4965_sens_auto_corr_ofdm(priv, norm_fa_ofdm, rx_enable_time);\r\niwl4965_sens_energy_cck(priv, norm_fa_cck, rx_enable_time, &statis);\r\niwl4965_sensitivity_write(priv);\r\n}\r\nstatic inline u8 iwl4965_find_first_chain(u8 mask)\r\n{\r\nif (mask & ANT_A)\r\nreturn CHAIN_A;\r\nif (mask & ANT_B)\r\nreturn CHAIN_B;\r\nreturn CHAIN_C;\r\n}\r\nstatic void\r\niwl4965_find_disconn_antenna(struct iwl_priv *priv, u32* average_sig,\r\nstruct iwl_chain_noise_data *data)\r\n{\r\nu32 active_chains = 0;\r\nu32 max_average_sig;\r\nu16 max_average_sig_antenna_i;\r\nu8 num_tx_chains;\r\nu8 first_chain;\r\nu16 i = 0;\r\naverage_sig[0] = data->chain_signal_a /\r\npriv->cfg->base_params->chain_noise_num_beacons;\r\naverage_sig[1] = data->chain_signal_b /\r\npriv->cfg->base_params->chain_noise_num_beacons;\r\naverage_sig[2] = data->chain_signal_c /\r\npriv->cfg->base_params->chain_noise_num_beacons;\r\nif (average_sig[0] >= average_sig[1]) {\r\nmax_average_sig = average_sig[0];\r\nmax_average_sig_antenna_i = 0;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n} else {\r\nmax_average_sig = average_sig[1];\r\nmax_average_sig_antenna_i = 1;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n}\r\nif (average_sig[2] >= max_average_sig) {\r\nmax_average_sig = average_sig[2];\r\nmax_average_sig_antenna_i = 2;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n}\r\nIWL_DEBUG_CALIB(priv, "average_sig: a %d b %d c %d\n",\r\naverage_sig[0], average_sig[1], average_sig[2]);\r\nIWL_DEBUG_CALIB(priv, "max_average_sig = %d, antenna %d\n",\r\nmax_average_sig, max_average_sig_antenna_i);\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nif (i != max_average_sig_antenna_i) {\r\ns32 rssi_delta = (max_average_sig - average_sig[i]);\r\nif (rssi_delta > MAXIMUM_ALLOWED_PATHLOSS)\r\ndata->disconn_array[i] = 1;\r\nelse\r\nactive_chains |= (1 << i);\r\nIWL_DEBUG_CALIB(priv, "i = %d rssiDelta = %d "\r\n"disconn_array[i] = %d\n",\r\ni, rssi_delta, data->disconn_array[i]);\r\n}\r\n}\r\nactive_chains &= priv->hw_params.valid_rx_ant;\r\nnum_tx_chains = 0;\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nu8 ant_msk = (1 << i);\r\nif (!(priv->hw_params.valid_tx_ant & ant_msk))\r\ncontinue;\r\nnum_tx_chains++;\r\nif (data->disconn_array[i] == 0)\r\nbreak;\r\nif (num_tx_chains == priv->hw_params.tx_chains_num &&\r\ndata->disconn_array[i]) {\r\nfirst_chain =\r\niwl4965_find_first_chain(priv->cfg->valid_tx_ant);\r\ndata->disconn_array[first_chain] = 0;\r\nactive_chains |= BIT(first_chain);\r\nIWL_DEBUG_CALIB(priv,\r\n"All Tx chains are disconnected W/A - declare %d as connected\n",\r\nfirst_chain);\r\nbreak;\r\n}\r\n}\r\nif (active_chains != priv->hw_params.valid_rx_ant &&\r\nactive_chains != priv->chain_noise_data.active_chains)\r\nIWL_DEBUG_CALIB(priv,\r\n"Detected that not all antennas are connected! "\r\n"Connected: %#x, valid: %#x.\n",\r\nactive_chains, priv->hw_params.valid_rx_ant);\r\ndata->active_chains = active_chains;\r\nIWL_DEBUG_CALIB(priv, "active_chains (bitwise) = 0x%x\n",\r\nactive_chains);\r\n}\r\nstatic void iwl4965_gain_computation(struct iwl_priv *priv,\r\nu32 *average_noise,\r\nu16 min_average_noise_antenna_i,\r\nu32 min_average_noise,\r\nu8 default_chain)\r\n{\r\nint i, ret;\r\nstruct iwl_chain_noise_data *data = &priv->chain_noise_data;\r\ndata->delta_gain_code[min_average_noise_antenna_i] = 0;\r\nfor (i = default_chain; i < NUM_RX_CHAINS; i++) {\r\ns32 delta_g = 0;\r\nif (!(data->disconn_array[i]) &&\r\n(data->delta_gain_code[i] ==\r\nCHAIN_NOISE_DELTA_GAIN_INIT_VAL)) {\r\ndelta_g = average_noise[i] - min_average_noise;\r\ndata->delta_gain_code[i] = (u8)((delta_g * 10) / 15);\r\ndata->delta_gain_code[i] =\r\nmin(data->delta_gain_code[i],\r\n(u8) CHAIN_NOISE_MAX_DELTA_GAIN_CODE);\r\ndata->delta_gain_code[i] =\r\n(data->delta_gain_code[i] | (1 << 2));\r\n} else {\r\ndata->delta_gain_code[i] = 0;\r\n}\r\n}\r\nIWL_DEBUG_CALIB(priv, "delta_gain_codes: a %d b %d c %d\n",\r\ndata->delta_gain_code[0],\r\ndata->delta_gain_code[1],\r\ndata->delta_gain_code[2]);\r\nif (!data->radio_write) {\r\nstruct iwl_calib_diff_gain_cmd cmd;\r\ndata->radio_write = 1;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.hdr.op_code = IWL_PHY_CALIBRATE_DIFF_GAIN_CMD;\r\ncmd.diff_gain_a = data->delta_gain_code[0];\r\ncmd.diff_gain_b = data->delta_gain_code[1];\r\ncmd.diff_gain_c = data->delta_gain_code[2];\r\nret = iwl_legacy_send_cmd_pdu(priv, REPLY_PHY_CALIBRATION_CMD,\r\nsizeof(cmd), &cmd);\r\nif (ret)\r\nIWL_DEBUG_CALIB(priv, "fail sending cmd "\r\n"REPLY_PHY_CALIBRATION_CMD\n");\r\ndata->state = IWL_CHAIN_NOISE_CALIBRATED;\r\n}\r\n}\r\nvoid iwl4965_chain_noise_calibration(struct iwl_priv *priv, void *stat_resp)\r\n{\r\nstruct iwl_chain_noise_data *data = NULL;\r\nu32 chain_noise_a;\r\nu32 chain_noise_b;\r\nu32 chain_noise_c;\r\nu32 chain_sig_a;\r\nu32 chain_sig_b;\r\nu32 chain_sig_c;\r\nu32 average_sig[NUM_RX_CHAINS] = {INITIALIZATION_VALUE};\r\nu32 average_noise[NUM_RX_CHAINS] = {INITIALIZATION_VALUE};\r\nu32 min_average_noise = MIN_AVERAGE_NOISE_MAX_VALUE;\r\nu16 min_average_noise_antenna_i = INITIALIZATION_VALUE;\r\nu16 i = 0;\r\nu16 rxon_chnum = INITIALIZATION_VALUE;\r\nu16 stat_chnum = INITIALIZATION_VALUE;\r\nu8 rxon_band24;\r\nu8 stat_band24;\r\nunsigned long flags;\r\nstruct statistics_rx_non_phy *rx_info;\r\nstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\r\nif (priv->disable_chain_noise_cal)\r\nreturn;\r\ndata = &(priv->chain_noise_data);\r\nif (data->state != IWL_CHAIN_NOISE_ACCUMULATE) {\r\nif (data->state == IWL_CHAIN_NOISE_ALIVE)\r\nIWL_DEBUG_CALIB(priv, "Wait for noise calib reset\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrx_info = &(((struct iwl_notif_statistics *)stat_resp)->\r\nrx.general);\r\nif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\r\nIWL_DEBUG_CALIB(priv, " << Interference data unavailable\n");\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\nrxon_band24 = !!(ctx->staging.flags & RXON_FLG_BAND_24G_MSK);\r\nrxon_chnum = le16_to_cpu(ctx->staging.channel);\r\nstat_band24 = !!(((struct iwl_notif_statistics *)\r\nstat_resp)->flag &\r\nSTATISTICS_REPLY_FLG_BAND_24G_MSK);\r\nstat_chnum = le32_to_cpu(((struct iwl_notif_statistics *)\r\nstat_resp)->flag) >> 16;\r\nif ((rxon_chnum != stat_chnum) || (rxon_band24 != stat_band24)) {\r\nIWL_DEBUG_CALIB(priv, "Stats not from chan=%d, band24=%d\n",\r\nrxon_chnum, rxon_band24);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\nchain_noise_a = le32_to_cpu(rx_info->beacon_silence_rssi_a) &\r\nIN_BAND_FILTER;\r\nchain_noise_b = le32_to_cpu(rx_info->beacon_silence_rssi_b) &\r\nIN_BAND_FILTER;\r\nchain_noise_c = le32_to_cpu(rx_info->beacon_silence_rssi_c) &\r\nIN_BAND_FILTER;\r\nchain_sig_a = le32_to_cpu(rx_info->beacon_rssi_a) & IN_BAND_FILTER;\r\nchain_sig_b = le32_to_cpu(rx_info->beacon_rssi_b) & IN_BAND_FILTER;\r\nchain_sig_c = le32_to_cpu(rx_info->beacon_rssi_c) & IN_BAND_FILTER;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndata->beacon_count++;\r\ndata->chain_noise_a = (chain_noise_a + data->chain_noise_a);\r\ndata->chain_noise_b = (chain_noise_b + data->chain_noise_b);\r\ndata->chain_noise_c = (chain_noise_c + data->chain_noise_c);\r\ndata->chain_signal_a = (chain_sig_a + data->chain_signal_a);\r\ndata->chain_signal_b = (chain_sig_b + data->chain_signal_b);\r\ndata->chain_signal_c = (chain_sig_c + data->chain_signal_c);\r\nIWL_DEBUG_CALIB(priv, "chan=%d, band24=%d, beacon=%d\n",\r\nrxon_chnum, rxon_band24, data->beacon_count);\r\nIWL_DEBUG_CALIB(priv, "chain_sig: a %d b %d c %d\n",\r\nchain_sig_a, chain_sig_b, chain_sig_c);\r\nIWL_DEBUG_CALIB(priv, "chain_noise: a %d b %d c %d\n",\r\nchain_noise_a, chain_noise_b, chain_noise_c);\r\nif (data->beacon_count !=\r\npriv->cfg->base_params->chain_noise_num_beacons)\r\nreturn;\r\niwl4965_find_disconn_antenna(priv, average_sig, data);\r\naverage_noise[0] = data->chain_noise_a /\r\npriv->cfg->base_params->chain_noise_num_beacons;\r\naverage_noise[1] = data->chain_noise_b /\r\npriv->cfg->base_params->chain_noise_num_beacons;\r\naverage_noise[2] = data->chain_noise_c /\r\npriv->cfg->base_params->chain_noise_num_beacons;\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nif (!(data->disconn_array[i]) &&\r\n(average_noise[i] <= min_average_noise)) {\r\nmin_average_noise = average_noise[i];\r\nmin_average_noise_antenna_i = i;\r\n}\r\n}\r\nIWL_DEBUG_CALIB(priv, "average_noise: a %d b %d c %d\n",\r\naverage_noise[0], average_noise[1],\r\naverage_noise[2]);\r\nIWL_DEBUG_CALIB(priv, "min_average_noise = %d, antenna %d\n",\r\nmin_average_noise, min_average_noise_antenna_i);\r\niwl4965_gain_computation(priv, average_noise,\r\nmin_average_noise_antenna_i, min_average_noise,\r\niwl4965_find_first_chain(priv->cfg->valid_rx_ant));\r\nif (priv->cfg->ops->lib->update_chain_flags)\r\npriv->cfg->ops->lib->update_chain_flags(priv);\r\ndata->state = IWL_CHAIN_NOISE_DONE;\r\niwl_legacy_power_update_mode(priv, false);\r\n}\r\nvoid iwl4965_reset_run_time_calib(struct iwl_priv *priv)\r\n{\r\nint i;\r\nmemset(&(priv->sensitivity_data), 0,\r\nsizeof(struct iwl_sensitivity_data));\r\nmemset(&(priv->chain_noise_data), 0,\r\nsizeof(struct iwl_chain_noise_data));\r\nfor (i = 0; i < NUM_RX_CHAINS; i++)\r\npriv->chain_noise_data.delta_gain_code[i] =\r\nCHAIN_NOISE_DELTA_GAIN_INIT_VAL;\r\niwl_legacy_send_statistics_request(priv, CMD_ASYNC, true);\r\n}
