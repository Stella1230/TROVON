void __init add_memory_region(phys_t start, phys_t size, long type)\r\n{\r\nint x = boot_mem_map.nr_map;\r\nstruct boot_mem_map_entry *prev = boot_mem_map.map + x - 1;\r\nif (start + size < start) {\r\npr_warning("Trying to add an invalid memory region, skipped\n");\r\nreturn;\r\n}\r\nif (x && prev->addr + prev->size == start && prev->type == type) {\r\nprev->size += size;\r\nreturn;\r\n}\r\nif (x == BOOT_MEM_MAP_MAX) {\r\npr_err("Ooops! Too many entries in the memory map!\n");\r\nreturn;\r\n}\r\nboot_mem_map.map[x].addr = start;\r\nboot_mem_map.map[x].size = size;\r\nboot_mem_map.map[x].type = type;\r\nboot_mem_map.nr_map++;\r\n}\r\nstatic void __init print_memory_map(void)\r\n{\r\nint i;\r\nconst int field = 2 * sizeof(unsigned long);\r\nfor (i = 0; i < boot_mem_map.nr_map; i++) {\r\nprintk(KERN_INFO " memory: %0*Lx @ %0*Lx ",\r\nfield, (unsigned long long) boot_mem_map.map[i].size,\r\nfield, (unsigned long long) boot_mem_map.map[i].addr);\r\nswitch (boot_mem_map.map[i].type) {\r\ncase BOOT_MEM_RAM:\r\nprintk(KERN_CONT "(usable)\n");\r\nbreak;\r\ncase BOOT_MEM_ROM_DATA:\r\nprintk(KERN_CONT "(ROM data)\n");\r\nbreak;\r\ncase BOOT_MEM_RESERVED:\r\nprintk(KERN_CONT "(reserved)\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_CONT "type %lu\n", boot_mem_map.map[i].type);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int __init rd_start_early(char *p)\r\n{\r\nunsigned long start = memparse(p, &p);\r\n#ifdef CONFIG_64BIT\r\nif (start < XKPHYS)\r\nstart = (int)start;\r\n#endif\r\ninitrd_start = start;\r\ninitrd_end += start;\r\nreturn 0;\r\n}\r\nstatic int __init rd_size_early(char *p)\r\n{\r\ninitrd_end += memparse(p, &p);\r\nreturn 0;\r\n}\r\nstatic unsigned long __init init_initrd(void)\r\n{\r\nunsigned long end;\r\nif (!initrd_start || initrd_end <= initrd_start)\r\ngoto disable;\r\nif (initrd_start & ~PAGE_MASK) {\r\npr_err("initrd start must be page aligned\n");\r\ngoto disable;\r\n}\r\nif (initrd_start < PAGE_OFFSET) {\r\npr_err("initrd start < PAGE_OFFSET\n");\r\ngoto disable;\r\n}\r\nend = __pa(initrd_end);\r\ninitrd_end = (unsigned long)__va(end);\r\ninitrd_start = (unsigned long)__va(__pa(initrd_start));\r\nROOT_DEV = Root_RAM0;\r\nreturn PFN_UP(end);\r\ndisable:\r\ninitrd_start = 0;\r\ninitrd_end = 0;\r\nreturn 0;\r\n}\r\nstatic void __init finalize_initrd(void)\r\n{\r\nunsigned long size = initrd_end - initrd_start;\r\nif (size == 0) {\r\nprintk(KERN_INFO "Initrd not found or empty");\r\ngoto disable;\r\n}\r\nif (__pa(initrd_end) > PFN_PHYS(max_low_pfn)) {\r\nprintk(KERN_ERR "Initrd extends beyond end of memory");\r\ngoto disable;\r\n}\r\nreserve_bootmem(__pa(initrd_start), size, BOOTMEM_DEFAULT);\r\ninitrd_below_start_ok = 1;\r\npr_info("Initial ramdisk at: 0x%lx (%lu bytes)\n",\r\ninitrd_start, size);\r\nreturn;\r\ndisable:\r\nprintk(KERN_CONT " - disabling initrd\n");\r\ninitrd_start = 0;\r\ninitrd_end = 0;\r\n}\r\nstatic unsigned long __init init_initrd(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init bootmem_init(void)\r\n{\r\ninit_initrd();\r\nfinalize_initrd();\r\n}\r\nstatic void __init bootmem_init(void)\r\n{\r\nunsigned long reserved_end;\r\nunsigned long mapstart = ~0UL;\r\nunsigned long bootmap_size;\r\nint i;\r\nreserved_end = max(init_initrd(),\r\n(unsigned long) PFN_UP(__pa_symbol(&_end)));\r\nmin_low_pfn = ~0UL;\r\nmax_low_pfn = 0;\r\nfor (i = 0; i < boot_mem_map.nr_map; i++) {\r\nunsigned long start, end;\r\nif (boot_mem_map.map[i].type != BOOT_MEM_RAM)\r\ncontinue;\r\nstart = PFN_UP(boot_mem_map.map[i].addr);\r\nend = PFN_DOWN(boot_mem_map.map[i].addr\r\n+ boot_mem_map.map[i].size);\r\nif (end > max_low_pfn)\r\nmax_low_pfn = end;\r\nif (start < min_low_pfn)\r\nmin_low_pfn = start;\r\nif (end <= reserved_end)\r\ncontinue;\r\nif (start >= mapstart)\r\ncontinue;\r\nmapstart = max(reserved_end, start);\r\n}\r\nif (min_low_pfn >= max_low_pfn)\r\npanic("Incorrect memory mapping !!!");\r\nif (min_low_pfn > ARCH_PFN_OFFSET) {\r\npr_info("Wasting %lu bytes for tracking %lu unused pages\n",\r\n(min_low_pfn - ARCH_PFN_OFFSET) * sizeof(struct page),\r\nmin_low_pfn - ARCH_PFN_OFFSET);\r\n} else if (min_low_pfn < ARCH_PFN_OFFSET) {\r\npr_info("%lu free pages won't be used\n",\r\nARCH_PFN_OFFSET - min_low_pfn);\r\n}\r\nmin_low_pfn = ARCH_PFN_OFFSET;\r\nmax_pfn = max_low_pfn;\r\nif (max_low_pfn > PFN_DOWN(HIGHMEM_START)) {\r\n#ifdef CONFIG_HIGHMEM\r\nhighstart_pfn = PFN_DOWN(HIGHMEM_START);\r\nhighend_pfn = max_low_pfn;\r\n#endif\r\nmax_low_pfn = PFN_DOWN(HIGHMEM_START);\r\n}\r\nbootmap_size = init_bootmem_node(NODE_DATA(0), mapstart,\r\nmin_low_pfn, max_low_pfn);\r\nfor (i = 0; i < boot_mem_map.nr_map; i++) {\r\nunsigned long start, end;\r\nstart = PFN_UP(boot_mem_map.map[i].addr);\r\nend = PFN_DOWN(boot_mem_map.map[i].addr\r\n+ boot_mem_map.map[i].size);\r\nif (start <= min_low_pfn)\r\nstart = min_low_pfn;\r\nif (start >= end)\r\ncontinue;\r\n#ifndef CONFIG_HIGHMEM\r\nif (end > max_low_pfn)\r\nend = max_low_pfn;\r\nif (end <= start)\r\ncontinue;\r\n#endif\r\nadd_active_range(0, start, end);\r\n}\r\nfor (i = 0; i < boot_mem_map.nr_map; i++) {\r\nunsigned long start, end, size;\r\nif (boot_mem_map.map[i].type != BOOT_MEM_RAM)\r\ncontinue;\r\nstart = PFN_UP(boot_mem_map.map[i].addr);\r\nend = PFN_DOWN(boot_mem_map.map[i].addr\r\n+ boot_mem_map.map[i].size);\r\nif (start >= max_low_pfn)\r\ncontinue;\r\nif (start < reserved_end)\r\nstart = reserved_end;\r\nif (end > max_low_pfn)\r\nend = max_low_pfn;\r\nif (end <= start)\r\ncontinue;\r\nsize = end - start;\r\nfree_bootmem(PFN_PHYS(start), size << PAGE_SHIFT);\r\nmemory_present(0, start, end);\r\n}\r\nreserve_bootmem(PFN_PHYS(mapstart), bootmap_size, BOOTMEM_DEFAULT);\r\nfinalize_initrd();\r\n}\r\nstatic int __init early_parse_mem(char *p)\r\n{\r\nunsigned long start, size;\r\nif (usermem == 0) {\r\nboot_mem_map.nr_map = 0;\r\nusermem = 1;\r\n}\r\nstart = 0;\r\nsize = memparse(p, &p);\r\nif (*p == '@')\r\nstart = memparse(p + 1, &p);\r\nadd_memory_region(start, size, BOOT_MEM_RAM);\r\nreturn 0;\r\n}\r\nstatic void __init arch_mem_init(char **cmdline_p)\r\n{\r\nextern void plat_mem_setup(void);\r\nplat_mem_setup();\r\npr_info("Determined physical RAM map:\n");\r\nprint_memory_map();\r\n#ifdef CONFIG_CMDLINE_BOOL\r\n#ifdef CONFIG_CMDLINE_OVERRIDE\r\nstrlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);\r\n#else\r\nif (builtin_cmdline[0]) {\r\nstrlcat(arcs_cmdline, " ", COMMAND_LINE_SIZE);\r\nstrlcat(arcs_cmdline, builtin_cmdline, COMMAND_LINE_SIZE);\r\n}\r\nstrlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);\r\n#endif\r\n#else\r\nstrlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);\r\n#endif\r\nstrlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);\r\n*cmdline_p = command_line;\r\nparse_early_param();\r\nif (usermem) {\r\npr_info("User-defined physical RAM map:\n");\r\nprint_memory_map();\r\n}\r\nbootmem_init();\r\ndevice_tree_init();\r\nsparse_init();\r\nplat_swiotlb_setup();\r\npaging_init();\r\n}\r\nstatic void __init resource_init(void)\r\n{\r\nint i;\r\nif (UNCAC_BASE != IO_BASE)\r\nreturn;\r\ncode_resource.start = __pa_symbol(&_text);\r\ncode_resource.end = __pa_symbol(&_etext) - 1;\r\ndata_resource.start = __pa_symbol(&_etext);\r\ndata_resource.end = __pa_symbol(&_edata) - 1;\r\nfor (i = 0; i < boot_mem_map.nr_map; i++) {\r\nstruct resource *res;\r\nunsigned long start, end;\r\nstart = boot_mem_map.map[i].addr;\r\nend = boot_mem_map.map[i].addr + boot_mem_map.map[i].size - 1;\r\nif (start >= HIGHMEM_START)\r\ncontinue;\r\nif (end >= HIGHMEM_START)\r\nend = HIGHMEM_START - 1;\r\nres = alloc_bootmem(sizeof(struct resource));\r\nswitch (boot_mem_map.map[i].type) {\r\ncase BOOT_MEM_RAM:\r\ncase BOOT_MEM_ROM_DATA:\r\nres->name = "System RAM";\r\nbreak;\r\ncase BOOT_MEM_RESERVED:\r\ndefault:\r\nres->name = "reserved";\r\n}\r\nres->start = start;\r\nres->end = end;\r\nres->flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nrequest_resource(&iomem_resource, res);\r\nrequest_resource(res, &code_resource);\r\nrequest_resource(res, &data_resource);\r\n}\r\n}\r\nvoid __init setup_arch(char **cmdline_p)\r\n{\r\ncpu_probe();\r\nprom_init();\r\n#ifdef CONFIG_EARLY_PRINTK\r\nsetup_early_printk();\r\n#endif\r\ncpu_report();\r\ncheck_bugs_early();\r\n#if defined(CONFIG_VT)\r\n#if defined(CONFIG_VGA_CONSOLE)\r\nconswitchp = &vga_con;\r\n#elif defined(CONFIG_DUMMY_CONSOLE)\r\nconswitchp = &dummy_con;\r\n#endif\r\n#endif\r\narch_mem_init(cmdline_p);\r\nresource_init();\r\nplat_smp_setup();\r\n}\r\nstatic int __init debugfs_mips(void)\r\n{\r\nstruct dentry *d;\r\nd = debugfs_create_dir("mips", NULL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nmips_debugfs_dir = d;\r\nreturn 0;\r\n}
