int\r\nJadeVersion(struct IsdnCardState *cs, char *s)\r\n{\r\nint ver;\r\nint to = 50;\r\ncs->BC_Write_Reg(cs, -1, 0x50, 0x19);\r\nwhile (to) {\r\nudelay(1);\r\nver = cs->BC_Read_Reg(cs, -1, 0x60);\r\nto--;\r\nif (ver)\r\nbreak;\r\nif (!to) {\r\nprintk(KERN_INFO "%s JADE version not obtainable\n", s);\r\nreturn (0);\r\n}\r\n}\r\nudelay(10);\r\nver = cs->BC_Read_Reg(cs, -1, 0x60);\r\nprintk(KERN_INFO "%s JADE version: %d\n", s, ver);\r\nreturn (1);\r\n}\r\nstatic void\r\njade_write_indirect(struct IsdnCardState *cs, u_char reg, u_char value)\r\n{\r\nint to = 50;\r\nu_char ret;\r\ncs->BC_Write_Reg(cs, -1, COMM_JADE+1, value);\r\ncs->BC_Write_Reg(cs, -1, COMM_JADE, reg);\r\nto = 50;\r\nwhile (to) {\r\nudelay(1);\r\nret = cs->BC_Read_Reg(cs, -1, COMM_JADE);\r\nto--;\r\nif (ret & 1)\r\nbreak;\r\nif (!to) {\r\nprintk(KERN_INFO "Can not see ready bit from JADE DSP (reg=0x%X, value=0x%X)\n", reg, value);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void\r\nmodejade(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint jade = bcs->hw.hscx.hscx;\r\nif (cs->debug & L1_DEB_HSCX) {\r\nchar tmp[40];\r\nsprintf(tmp, "jade %c mode %d ichan %d",\r\n'A' + jade, mode, bc);\r\ndebugl1(cs, tmp);\r\n}\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_MODE, (mode == L1_MODE_TRANS ? jadeMODE_TMO:0x00));\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_CCR0, (jadeCCR0_PU|jadeCCR0_ITF));\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_CCR1, 0x00);\r\njade_write_indirect(cs, jade_HDLC1SERRXPATH, 0x08);\r\njade_write_indirect(cs, jade_HDLC2SERRXPATH, 0x08);\r\njade_write_indirect(cs, jade_HDLC1SERTXPATH, 0x00);\r\njade_write_indirect(cs, jade_HDLC2SERTXPATH, 0x00);\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_XCCR, 0x07);\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_RCCR, 0x07);\r\nif (bc == 0) {\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_TSAX, 0x00);\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_TSAR, 0x00);\r\n} else {\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_TSAX, 0x04);\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_TSAR, 0x04);\r\n}\r\nswitch (mode) {\r\ncase (L1_MODE_NULL):\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_MODE, jadeMODE_TMO);\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_MODE, (jadeMODE_TMO|jadeMODE_RAC|jadeMODE_XAC));\r\nbreak;\r\ncase (L1_MODE_HDLC):\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_MODE, (jadeMODE_RAC|jadeMODE_XAC));\r\nbreak;\r\n}\r\nif (mode) {\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_RCMD, (jadeRCMD_RRES|jadeRCMD_RMC));\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_XCMD, jadeXCMD_XRES);\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_IMR, 0xF8);\r\n}\r\nelse\r\ncs->BC_Write_Reg(cs, jade, jade_HDLC_IMR, 0x00);\r\n}\r\nstatic void\r\njade_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->hw.hscx.count = 0;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "jade_l2l1: this shouldn't happen\n");\r\n} else {\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->tx_skb = skb;\r\nbcs->hw.hscx.count = 0;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nmodejade(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nmodejade(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_jadestate(struct BCState *bcs)\r\n{\r\nmodejade(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nkfree(bcs->hw.hscx.rcvbuf);\r\nbcs->hw.hscx.rcvbuf = NULL;\r\nkfree(bcs->blog);\r\nbcs->blog = NULL;\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nstatic int\r\nopen_jadestate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nif (!(bcs->hw.hscx.rcvbuf = kmalloc(HSCX_BUFMAX, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for hscx.rcvbuf\n");\r\ntest_and_clear_bit(BC_FLG_INIT, &bcs->Flag);\r\nreturn (1);\r\n}\r\nif (!(bcs->blog = kmalloc(MAX_BLOG_SPACE, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for bcs->blog\n");\r\ntest_and_clear_bit(BC_FLG_INIT, &bcs->Flag);\r\nkfree(bcs->hw.hscx.rcvbuf);\r\nbcs->hw.hscx.rcvbuf = NULL;\r\nreturn (2);\r\n}\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->hw.hscx.rcvidx = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_jade(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_jadestate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = jade_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nvoid\r\nclear_pending_jade_ints(struct IsdnCardState *cs)\r\n{\r\nint val;\r\nchar tmp[64];\r\ncs->BC_Write_Reg(cs, 0, jade_HDLC_IMR, 0x00);\r\ncs->BC_Write_Reg(cs, 1, jade_HDLC_IMR, 0x00);\r\nval = cs->BC_Read_Reg(cs, 1, jade_HDLC_ISR);\r\nsprintf(tmp, "jade B ISTA %x", val);\r\ndebugl1(cs, tmp);\r\nval = cs->BC_Read_Reg(cs, 0, jade_HDLC_ISR);\r\nsprintf(tmp, "jade A ISTA %x", val);\r\ndebugl1(cs, tmp);\r\nval = cs->BC_Read_Reg(cs, 1, jade_HDLC_STAR);\r\nsprintf(tmp, "jade B STAR %x", val);\r\ndebugl1(cs, tmp);\r\nval = cs->BC_Read_Reg(cs, 0, jade_HDLC_STAR);\r\nsprintf(tmp, "jade A STAR %x", val);\r\ndebugl1(cs, tmp);\r\ncs->BC_Write_Reg(cs, 0, jade_HDLC_IMR, 0xF8);\r\ncs->BC_Write_Reg(cs, 1, jade_HDLC_IMR, 0xF8);\r\n}\r\nvoid\r\ninitjade(struct IsdnCardState *cs)\r\n{\r\ncs->bcs[0].BC_SetStack = setstack_jade;\r\ncs->bcs[1].BC_SetStack = setstack_jade;\r\ncs->bcs[0].BC_Close = close_jadestate;\r\ncs->bcs[1].BC_Close = close_jadestate;\r\ncs->bcs[0].hw.hscx.hscx = 0;\r\ncs->bcs[1].hw.hscx.hscx = 1;\r\njade_write_indirect(cs, 0x11, 0x0f);\r\njade_write_indirect(cs, 0x17, 0x2f);\r\ncs->BC_Write_Reg(cs, 0, jade_HDLC_MODE, jadeMODE_TMO);\r\ncs->BC_Write_Reg(cs, 1, jade_HDLC_MODE, jadeMODE_TMO);\r\ncs->BC_Write_Reg(cs, 0, jade_HDLC_CCR0, 0x00);\r\ncs->BC_Write_Reg(cs, 1, jade_HDLC_CCR0, 0x00);\r\ncs->BC_Write_Reg(cs, 0, jade_HDLC_IMR, 0x00);\r\ncs->BC_Write_Reg(cs, 1, jade_HDLC_IMR, 0x00);\r\njade_write_indirect(cs, jade_HDLCCNTRACCESS, (jadeINDIRECT_HAH1|jadeINDIRECT_HAH2));\r\ncs->BC_Write_Reg(cs, -1,jade_INT, (jadeINT_HDLC1|jadeINT_HDLC2));\r\nmodejade(cs->bcs, 0, 0);\r\nmodejade(cs->bcs + 1, 0, 0);\r\n}
