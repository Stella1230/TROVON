static void *fsl_diu_alloc(size_t size, phys_addr_t *phys)\r\n{\r\nvoid *virt;\r\npr_debug("size=%zu\n", size);\r\nvirt = alloc_pages_exact(size, GFP_DMA | __GFP_ZERO);\r\nif (virt) {\r\n*phys = virt_to_phys(virt);\r\npr_debug("virt=%p phys=%llx\n", virt,\r\n(unsigned long long)*phys);\r\n}\r\nreturn virt;\r\n}\r\nstatic void fsl_diu_free(void *virt, size_t size)\r\n{\r\npr_debug("virt=%p size=%zu\n", virt, size);\r\nif (virt && size)\r\nfree_pages_exact(virt, size);\r\n}\r\nvoid wr_reg_wa(u32 *reg, u32 val)\r\n{\r\ndo {\r\nout_be32(reg, val);\r\n} while (in_be32(reg) != val);\r\n}\r\nstatic int fsl_diu_enable_panel(struct fb_info *info)\r\n{\r\nstruct mfb_info *pmfbi, *cmfbi, *mfbi = info->par;\r\nstruct diu *hw = dr.diu_reg;\r\nstruct diu_ad *ad = mfbi->ad;\r\nstruct fsl_diu_data *machine_data = mfbi->parent;\r\nint res = 0;\r\npr_debug("enable_panel index %d\n", mfbi->index);\r\nif (mfbi->type != MFB_TYPE_OFF) {\r\nswitch (mfbi->index) {\r\ncase 0:\r\nif (hw->desc[0] != ad->paddr)\r\nwr_reg_wa(&hw->desc[0], ad->paddr);\r\nbreak;\r\ncase 1:\r\ncmfbi = machine_data->fsl_diu_info[2]->par;\r\nif (hw->desc[1] != ad->paddr) {\r\nif (cmfbi->count > 0)\r\nad->next_ad =\r\ncpu_to_le32(cmfbi->ad->paddr);\r\nelse\r\nad->next_ad = 0;\r\nwr_reg_wa(&hw->desc[1], ad->paddr);\r\n}\r\nbreak;\r\ncase 3:\r\ncmfbi = machine_data->fsl_diu_info[4]->par;\r\nif (hw->desc[2] != ad->paddr) {\r\nif (cmfbi->count > 0)\r\nad->next_ad =\r\ncpu_to_le32(cmfbi->ad->paddr);\r\nelse\r\nad->next_ad = 0;\r\nwr_reg_wa(&hw->desc[2], ad->paddr);\r\n}\r\nbreak;\r\ncase 2:\r\npmfbi = machine_data->fsl_diu_info[1]->par;\r\nad->next_ad = 0;\r\nif (hw->desc[1] == machine_data->dummy_ad->paddr)\r\nwr_reg_wa(&hw->desc[1], ad->paddr);\r\nelse\r\npmfbi->ad->next_ad = cpu_to_le32(ad->paddr);\r\nbreak;\r\ncase 4:\r\npmfbi = machine_data->fsl_diu_info[3]->par;\r\nad->next_ad = 0;\r\nif (hw->desc[2] == machine_data->dummy_ad->paddr)\r\nwr_reg_wa(&hw->desc[2], ad->paddr);\r\nelse\r\npmfbi->ad->next_ad = cpu_to_le32(ad->paddr);\r\nbreak;\r\ndefault:\r\nres = -EINVAL;\r\nbreak;\r\n}\r\n} else\r\nres = -EINVAL;\r\nreturn res;\r\n}\r\nstatic int fsl_diu_disable_panel(struct fb_info *info)\r\n{\r\nstruct mfb_info *pmfbi, *cmfbi, *mfbi = info->par;\r\nstruct diu *hw = dr.diu_reg;\r\nstruct diu_ad *ad = mfbi->ad;\r\nstruct fsl_diu_data *machine_data = mfbi->parent;\r\nint res = 0;\r\nswitch (mfbi->index) {\r\ncase 0:\r\nif (hw->desc[0] != machine_data->dummy_ad->paddr)\r\nwr_reg_wa(&hw->desc[0], machine_data->dummy_ad->paddr);\r\nbreak;\r\ncase 1:\r\ncmfbi = machine_data->fsl_diu_info[2]->par;\r\nif (cmfbi->count > 0)\r\nwr_reg_wa(&hw->desc[1], cmfbi->ad->paddr);\r\nelse\r\nwr_reg_wa(&hw->desc[1], machine_data->dummy_ad->paddr);\r\nbreak;\r\ncase 3:\r\ncmfbi = machine_data->fsl_diu_info[4]->par;\r\nif (cmfbi->count > 0)\r\nwr_reg_wa(&hw->desc[2], cmfbi->ad->paddr);\r\nelse\r\nwr_reg_wa(&hw->desc[2], machine_data->dummy_ad->paddr);\r\nbreak;\r\ncase 2:\r\npmfbi = machine_data->fsl_diu_info[1]->par;\r\nif (hw->desc[1] != ad->paddr) {\r\nif (pmfbi->count > 0)\r\npmfbi->ad->next_ad = 0;\r\n} else\r\nwr_reg_wa(&hw->desc[1], machine_data->dummy_ad->paddr);\r\nbreak;\r\ncase 4:\r\npmfbi = machine_data->fsl_diu_info[3]->par;\r\nif (hw->desc[2] != ad->paddr) {\r\nif (pmfbi->count > 0)\r\npmfbi->ad->next_ad = 0;\r\n} else\r\nwr_reg_wa(&hw->desc[2], machine_data->dummy_ad->paddr);\r\nbreak;\r\ndefault:\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nstatic void enable_lcdc(struct fb_info *info)\r\n{\r\nstruct diu *hw = dr.diu_reg;\r\nstruct mfb_info *mfbi = info->par;\r\nstruct fsl_diu_data *machine_data = mfbi->parent;\r\nif (!machine_data->fb_enabled) {\r\nout_be32(&hw->diu_mode, dr.mode);\r\nmachine_data->fb_enabled++;\r\n}\r\n}\r\nstatic void disable_lcdc(struct fb_info *info)\r\n{\r\nstruct diu *hw = dr.diu_reg;\r\nstruct mfb_info *mfbi = info->par;\r\nstruct fsl_diu_data *machine_data = mfbi->parent;\r\nif (machine_data->fb_enabled) {\r\nout_be32(&hw->diu_mode, 0);\r\nmachine_data->fb_enabled = 0;\r\n}\r\n}\r\nstatic void adjust_aoi_size_position(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct mfb_info *lower_aoi_mfbi, *upper_aoi_mfbi, *mfbi = info->par;\r\nstruct fsl_diu_data *machine_data = mfbi->parent;\r\nint available_height, upper_aoi_bottom, index = mfbi->index;\r\nint lower_aoi_is_open, upper_aoi_is_open;\r\n__u32 base_plane_width, base_plane_height, upper_aoi_height;\r\nbase_plane_width = machine_data->fsl_diu_info[0]->var.xres;\r\nbase_plane_height = machine_data->fsl_diu_info[0]->var.yres;\r\nif (mfbi->x_aoi_d < 0)\r\nmfbi->x_aoi_d = 0;\r\nif (mfbi->y_aoi_d < 0)\r\nmfbi->y_aoi_d = 0;\r\nswitch (index) {\r\ncase 0:\r\nif (mfbi->x_aoi_d != 0)\r\nmfbi->x_aoi_d = 0;\r\nif (mfbi->y_aoi_d != 0)\r\nmfbi->y_aoi_d = 0;\r\nbreak;\r\ncase 1:\r\ncase 3:\r\nlower_aoi_mfbi = machine_data->fsl_diu_info[index+1]->par;\r\nlower_aoi_is_open = lower_aoi_mfbi->count > 0 ? 1 : 0;\r\nif (var->xres > base_plane_width)\r\nvar->xres = base_plane_width;\r\nif ((mfbi->x_aoi_d + var->xres) > base_plane_width)\r\nmfbi->x_aoi_d = base_plane_width - var->xres;\r\nif (lower_aoi_is_open)\r\navailable_height = lower_aoi_mfbi->y_aoi_d;\r\nelse\r\navailable_height = base_plane_height;\r\nif (var->yres > available_height)\r\nvar->yres = available_height;\r\nif ((mfbi->y_aoi_d + var->yres) > available_height)\r\nmfbi->y_aoi_d = available_height - var->yres;\r\nbreak;\r\ncase 2:\r\ncase 4:\r\nupper_aoi_mfbi = machine_data->fsl_diu_info[index-1]->par;\r\nupper_aoi_height =\r\nmachine_data->fsl_diu_info[index-1]->var.yres;\r\nupper_aoi_bottom = upper_aoi_mfbi->y_aoi_d + upper_aoi_height;\r\nupper_aoi_is_open = upper_aoi_mfbi->count > 0 ? 1 : 0;\r\nif (var->xres > base_plane_width)\r\nvar->xres = base_plane_width;\r\nif ((mfbi->x_aoi_d + var->xres) > base_plane_width)\r\nmfbi->x_aoi_d = base_plane_width - var->xres;\r\nif (mfbi->y_aoi_d < 0)\r\nmfbi->y_aoi_d = 0;\r\nif (upper_aoi_is_open) {\r\nif (mfbi->y_aoi_d < upper_aoi_bottom)\r\nmfbi->y_aoi_d = upper_aoi_bottom;\r\navailable_height = base_plane_height\r\n- upper_aoi_bottom;\r\n} else\r\navailable_height = base_plane_height;\r\nif (var->yres > available_height)\r\nvar->yres = available_height;\r\nif ((mfbi->y_aoi_d + var->yres) > base_plane_height)\r\nmfbi->y_aoi_d = base_plane_height - var->yres;\r\nbreak;\r\n}\r\n}\r\nstatic int fsl_diu_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\npr_debug("check_var xres: %d\n", var->xres);\r\npr_debug("check_var yres: %d\n", var->yres);\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->xoffset < 0)\r\nvar->xoffset = 0;\r\nif (var->yoffset < 0)\r\nvar->yoffset = 0;\r\nif (var->xoffset + info->var.xres > info->var.xres_virtual)\r\nvar->xoffset = info->var.xres_virtual - info->var.xres;\r\nif (var->yoffset + info->var.yres > info->var.yres_virtual)\r\nvar->yoffset = info->var.yres_virtual - info->var.yres;\r\nif ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&\r\n(var->bits_per_pixel != 16))\r\nvar->bits_per_pixel = default_bpp;\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nvar->red.length = 5;\r\nvar->red.offset = 11;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 6;\r\nvar->green.offset = 5;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\ncase 24:\r\nvar->red.length = 8;\r\nvar->red.offset = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\n}\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->grayscale = 0;\r\nvar->sync |= var->nonstd;\r\nvar->nonstd |= var->sync;\r\nadjust_aoi_size_position(var, info);\r\nreturn 0;\r\n}\r\nstatic void set_fix(struct fb_info *info)\r\n{\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mfb_info *mfbi = info->par;\r\nstrncpy(fix->id, mfbi->id, strlen(mfbi->id));\r\nfix->line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->accel = FB_ACCEL_NONE;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nfix->xpanstep = 1;\r\nfix->ypanstep = 1;\r\n}\r\nstatic void update_lcdc(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mfb_info *mfbi = info->par;\r\nstruct fsl_diu_data *machine_data = mfbi->parent;\r\nstruct diu *hw;\r\nint i, j;\r\nchar __iomem *cursor_base, *gamma_table_base;\r\nu32 temp;\r\nhw = dr.diu_reg;\r\nif (mfbi->type == MFB_TYPE_OFF) {\r\nfsl_diu_disable_panel(info);\r\nreturn;\r\n}\r\ndiu_ops.set_monitor_port(machine_data->monitor_port);\r\ngamma_table_base = pool.gamma.vaddr;\r\ncursor_base = pool.cursor.vaddr;\r\nfor (i = 0; i <= 2; i++)\r\nfor (j = 0; j <= 255; j++)\r\n*gamma_table_base++ = j;\r\ndiu_ops.set_gamma_table(machine_data->monitor_port, pool.gamma.vaddr);\r\npr_debug("update-lcdc: HW - %p\n Disabling DIU\n", hw);\r\ndisable_lcdc(info);\r\nout_be32(&hw->gamma, pool.gamma.paddr);\r\nout_be32(&hw->cursor, pool.cursor.paddr);\r\nout_be32(&hw->bgnd, 0x007F7F7F);\r\nout_be32(&hw->bgnd_wb, 0);\r\nout_be32(&hw->disp_size, (var->yres << 16 | var->xres));\r\npr_debug("DIU xres: %d\n", var->xres);\r\npr_debug("DIU yres: %d\n", var->yres);\r\nout_be32(&hw->wb_size, 0);\r\nout_be32(&hw->wb_mem_addr, 0);\r\ntemp = var->left_margin << 22 |\r\nvar->hsync_len << 11 |\r\nvar->right_margin;\r\nout_be32(&hw->hsyn_para, temp);\r\ntemp = var->upper_margin << 22 |\r\nvar->vsync_len << 11 |\r\nvar->lower_margin;\r\nout_be32(&hw->vsyn_para, temp);\r\npr_debug("DIU right_margin - %d\n", var->right_margin);\r\npr_debug("DIU left_margin - %d\n", var->left_margin);\r\npr_debug("DIU hsync_len - %d\n", var->hsync_len);\r\npr_debug("DIU upper_margin - %d\n", var->upper_margin);\r\npr_debug("DIU lower_margin - %d\n", var->lower_margin);\r\npr_debug("DIU vsync_len - %d\n", var->vsync_len);\r\npr_debug("DIU HSYNC - 0x%08x\n", hw->hsyn_para);\r\npr_debug("DIU VSYNC - 0x%08x\n", hw->vsyn_para);\r\ndiu_ops.set_pixel_clock(var->pixclock);\r\nout_be32(&hw->syn_pol, 0);\r\nout_be32(&hw->thresholds, 0x00037800);\r\nout_be32(&hw->int_status, 0);\r\nout_be32(&hw->plut, 0x01F5F666);\r\nenable_lcdc(info);\r\n}\r\nstatic int map_video_memory(struct fb_info *info)\r\n{\r\nphys_addr_t phys;\r\nu32 smem_len = info->fix.line_length * info->var.yres_virtual;\r\npr_debug("info->var.xres_virtual = %d\n", info->var.xres_virtual);\r\npr_debug("info->var.yres_virtual = %d\n", info->var.yres_virtual);\r\npr_debug("info->fix.line_length = %d\n", info->fix.line_length);\r\npr_debug("MAP_VIDEO_MEMORY: smem_len = %u\n", smem_len);\r\ninfo->screen_base = fsl_diu_alloc(smem_len, &phys);\r\nif (info->screen_base == NULL) {\r\nprintk(KERN_ERR "Unable to allocate fb memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&info->mm_lock);\r\ninfo->fix.smem_start = (unsigned long) phys;\r\ninfo->fix.smem_len = smem_len;\r\nmutex_unlock(&info->mm_lock);\r\ninfo->screen_size = info->fix.smem_len;\r\npr_debug("Allocated fb @ paddr=0x%08lx, size=%d.\n",\r\ninfo->fix.smem_start, info->fix.smem_len);\r\npr_debug("screen base %p\n", info->screen_base);\r\nreturn 0;\r\n}\r\nstatic void unmap_video_memory(struct fb_info *info)\r\n{\r\nfsl_diu_free(info->screen_base, info->fix.smem_len);\r\nmutex_lock(&info->mm_lock);\r\ninfo->screen_base = NULL;\r\ninfo->fix.smem_start = 0;\r\ninfo->fix.smem_len = 0;\r\nmutex_unlock(&info->mm_lock);\r\n}\r\nstatic int fsl_diu_set_aoi(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mfb_info *mfbi = info->par;\r\nstruct diu_ad *ad = mfbi->ad;\r\nad->offset_xyi = cpu_to_le32((var->yoffset << 16) | var->xoffset);\r\nad->offset_xyd = cpu_to_le32((mfbi->y_aoi_d << 16) | mfbi->x_aoi_d);\r\nreturn 0;\r\n}\r\nstatic int fsl_diu_set_par(struct fb_info *info)\r\n{\r\nunsigned long len;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mfb_info *mfbi = info->par;\r\nstruct fsl_diu_data *machine_data = mfbi->parent;\r\nstruct diu_ad *ad = mfbi->ad;\r\nstruct diu *hw;\r\nhw = dr.diu_reg;\r\nset_fix(info);\r\nmfbi->cursor_reset = 1;\r\nlen = info->var.yres_virtual * info->fix.line_length;\r\nif (len != info->fix.smem_len) {\r\nif (info->fix.smem_start)\r\nunmap_video_memory(info);\r\npr_debug("SET PAR: smem_len = %d\n", info->fix.smem_len);\r\nif (map_video_memory(info)) {\r\nprintk(KERN_ERR "Unable to allocate fb memory 1\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nad->pix_fmt =\r\ndiu_ops.get_pixel_format(var->bits_per_pixel,\r\nmachine_data->monitor_port);\r\nad->addr = cpu_to_le32(info->fix.smem_start);\r\nad->src_size_g_alpha = cpu_to_le32((var->yres_virtual << 12) |\r\nvar->xres_virtual) | mfbi->g_alpha;\r\nad->aoi_size = cpu_to_le32((var->yres << 16) | var->xres);\r\nad->offset_xyi = cpu_to_le32((var->yoffset << 16) | var->xoffset);\r\nad->offset_xyd = cpu_to_le32((mfbi->y_aoi_d << 16) | mfbi->x_aoi_d);\r\nad->ckmax_r = 0;\r\nad->ckmax_g = 0;\r\nad->ckmax_b = 0;\r\nad->ckmin_r = 255;\r\nad->ckmin_g = 255;\r\nad->ckmin_b = 255;\r\nif (mfbi->index == 0)\r\nupdate_lcdc(info);\r\nreturn 0;\r\n}\r\nstatic inline __u32 CNVT_TOHW(__u32 val, __u32 width)\r\n{\r\nreturn ((val<<width) + 0x7FFF - val)>>16;\r\n}\r\nstatic int fsl_diu_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *info)\r\n{\r\nint ret = 1;\r\nif (info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nu32 v;\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\npal[regno] = v;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_STATIC_PSEUDOCOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fsl_diu_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif ((info->var.xoffset == var->xoffset) &&\r\n(info->var.yoffset == var->yoffset))\r\nreturn 0;\r\nif (var->xoffset < 0 || var->yoffset < 0\r\n|| var->xoffset + info->var.xres > info->var.xres_virtual\r\n|| var->yoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nfsl_diu_set_aoi(info);\r\nreturn 0;\r\n}\r\nstatic int fsl_diu_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nmfbi->blank = blank_mode;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_diu_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nstruct diu_ad *ad = mfbi->ad;\r\nstruct mfb_chroma_key ck;\r\nunsigned char global_alpha;\r\nstruct aoi_display_offset aoi_d;\r\n__u32 pix_fmt;\r\nvoid __user *buf = (void __user *)arg;\r\nif (!arg)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase MFB_SET_PIXFMT:\r\nif (copy_from_user(&pix_fmt, buf, sizeof(pix_fmt)))\r\nreturn -EFAULT;\r\nad->pix_fmt = pix_fmt;\r\npr_debug("Set pixel format to 0x%08x\n", ad->pix_fmt);\r\nbreak;\r\ncase MFB_GET_PIXFMT:\r\npix_fmt = ad->pix_fmt;\r\nif (copy_to_user(buf, &pix_fmt, sizeof(pix_fmt)))\r\nreturn -EFAULT;\r\npr_debug("get pixel format 0x%08x\n", ad->pix_fmt);\r\nbreak;\r\ncase MFB_SET_AOID:\r\nif (copy_from_user(&aoi_d, buf, sizeof(aoi_d)))\r\nreturn -EFAULT;\r\nmfbi->x_aoi_d = aoi_d.x_aoi_d;\r\nmfbi->y_aoi_d = aoi_d.y_aoi_d;\r\npr_debug("set AOI display offset of index %d to (%d,%d)\n",\r\nmfbi->index, aoi_d.x_aoi_d, aoi_d.y_aoi_d);\r\nfsl_diu_check_var(&info->var, info);\r\nfsl_diu_set_aoi(info);\r\nbreak;\r\ncase MFB_GET_AOID:\r\naoi_d.x_aoi_d = mfbi->x_aoi_d;\r\naoi_d.y_aoi_d = mfbi->y_aoi_d;\r\nif (copy_to_user(buf, &aoi_d, sizeof(aoi_d)))\r\nreturn -EFAULT;\r\npr_debug("get AOI display offset of index %d (%d,%d)\n",\r\nmfbi->index, aoi_d.x_aoi_d, aoi_d.y_aoi_d);\r\nbreak;\r\ncase MFB_GET_ALPHA:\r\nglobal_alpha = mfbi->g_alpha;\r\nif (copy_to_user(buf, &global_alpha, sizeof(global_alpha)))\r\nreturn -EFAULT;\r\npr_debug("get global alpha of index %d\n", mfbi->index);\r\nbreak;\r\ncase MFB_SET_ALPHA:\r\nif (copy_from_user(&global_alpha, buf, sizeof(global_alpha)))\r\nreturn -EFAULT;\r\nad->src_size_g_alpha = (ad->src_size_g_alpha & (~0xff)) |\r\n(global_alpha & 0xff);\r\nmfbi->g_alpha = global_alpha;\r\npr_debug("set global alpha for index %d\n", mfbi->index);\r\nbreak;\r\ncase MFB_SET_CHROMA_KEY:\r\nif (copy_from_user(&ck, buf, sizeof(ck)))\r\nreturn -EFAULT;\r\nif (ck.enable &&\r\n(ck.red_max < ck.red_min ||\r\nck.green_max < ck.green_min ||\r\nck.blue_max < ck.blue_min))\r\nreturn -EINVAL;\r\nif (!ck.enable) {\r\nad->ckmax_r = 0;\r\nad->ckmax_g = 0;\r\nad->ckmax_b = 0;\r\nad->ckmin_r = 255;\r\nad->ckmin_g = 255;\r\nad->ckmin_b = 255;\r\n} else {\r\nad->ckmax_r = ck.red_max;\r\nad->ckmax_g = ck.green_max;\r\nad->ckmax_b = ck.blue_max;\r\nad->ckmin_r = ck.red_min;\r\nad->ckmin_g = ck.green_min;\r\nad->ckmin_b = ck.blue_min;\r\n}\r\npr_debug("set chroma key\n");\r\nbreak;\r\ncase FBIOGET_GWINFO:\r\nif (mfbi->type == MFB_TYPE_OFF)\r\nreturn -ENODEV;\r\nif (copy_to_user(buf, ad, sizeof(*ad)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase FBIOGET_HWCINFO:\r\npr_debug("FBIOGET_HWCINFO:0x%08x\n", FBIOGET_HWCINFO);\r\nbreak;\r\ncase FBIOPUT_MODEINFO:\r\npr_debug("FBIOPUT_MODEINFO:0x%08x\n", FBIOPUT_MODEINFO);\r\nbreak;\r\ncase FBIOGET_DISPINFO:\r\npr_debug("FBIOGET_DISPINFO:0x%08x\n", FBIOGET_DISPINFO);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unknown ioctl command (0x%08X)\n", cmd);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_diu_open(struct fb_info *info, int user)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nint res = 0;\r\nif (!mfbi->index && diu_ops.release_bootmem)\r\ndiu_ops.release_bootmem();\r\nspin_lock(&diu_lock);\r\nmfbi->count++;\r\nif (mfbi->count == 1) {\r\npr_debug("open plane index %d\n", mfbi->index);\r\nfsl_diu_check_var(&info->var, info);\r\nres = fsl_diu_set_par(info);\r\nif (res < 0)\r\nmfbi->count--;\r\nelse {\r\nres = fsl_diu_enable_panel(info);\r\nif (res < 0)\r\nmfbi->count--;\r\n}\r\n}\r\nspin_unlock(&diu_lock);\r\nreturn res;\r\n}\r\nstatic int fsl_diu_release(struct fb_info *info, int user)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nint res = 0;\r\nspin_lock(&diu_lock);\r\nmfbi->count--;\r\nif (mfbi->count == 0) {\r\npr_debug("release plane index %d\n", mfbi->index);\r\nres = fsl_diu_disable_panel(info);\r\nif (res < 0)\r\nmfbi->count++;\r\n}\r\nspin_unlock(&diu_lock);\r\nreturn res;\r\n}\r\nstatic int init_fbinfo(struct fb_info *info)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\ninfo->device = NULL;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->fbops = &fsl_diu_ops;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\ninfo->pseudo_palette = &mfbi->pseudo_palette;\r\nfb_alloc_cmap(&info->cmap, 16, 0);\r\nreturn 0;\r\n}\r\nstatic int __devinit install_fb(struct fb_info *info)\r\n{\r\nint rc;\r\nstruct mfb_info *mfbi = info->par;\r\nconst char *aoi_mode, *init_aoi_mode = "320x240";\r\nstruct fb_videomode *db = fsl_diu_mode_db;\r\nunsigned int dbsize = ARRAY_SIZE(fsl_diu_mode_db);\r\nint has_default_mode = 1;\r\nif (init_fbinfo(info))\r\nreturn -EINVAL;\r\nif (mfbi->index == 0) {\r\nif (mfbi->edid_data) {\r\nfb_edid_to_monspecs(mfbi->edid_data, &info->monspecs);\r\nfb_videomode_to_modelist(info->monspecs.modedb,\r\ninfo->monspecs.modedb_len,\r\n&info->modelist);\r\ndb = info->monspecs.modedb;\r\ndbsize = info->monspecs.modedb_len;\r\n}\r\naoi_mode = fb_mode;\r\n} else {\r\naoi_mode = init_aoi_mode;\r\n}\r\npr_debug("mode used = %s\n", aoi_mode);\r\nrc = fb_find_mode(&info->var, info, aoi_mode, db, dbsize,\r\n&fsl_diu_default_mode, default_bpp);\r\nswitch (rc) {\r\ncase 1:\r\npr_debug("using mode specified in @mode\n");\r\nbreak;\r\ncase 2:\r\npr_debug("using mode specified in @mode "\r\n"with ignored refresh rate\n");\r\nbreak;\r\ncase 3:\r\npr_debug("using mode default mode\n");\r\nbreak;\r\ncase 4:\r\npr_debug("using mode from list\n");\r\nbreak;\r\ndefault:\r\npr_debug("rc = %d\n", rc);\r\npr_debug("failed to find mode\n");\r\nif (mfbi->index == 0 && mfbi->edid_data)\r\nhas_default_mode = 0;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (!has_default_mode) {\r\nrc = fb_find_mode(&info->var, info, aoi_mode, fsl_diu_mode_db,\r\nARRAY_SIZE(fsl_diu_mode_db),\r\n&fsl_diu_default_mode,\r\ndefault_bpp);\r\nif (rc > 0 && rc < 5)\r\nhas_default_mode = 1;\r\n}\r\nif (!has_default_mode && info->monspecs.modedb) {\r\nstruct fb_monspecs *specs = &info->monspecs;\r\nstruct fb_videomode *modedb = &specs->modedb[0];\r\nif (specs->misc & FB_MISC_1ST_DETAIL) {\r\nint i;\r\nfor (i = 0; i < specs->modedb_len; i++) {\r\nif (specs->modedb[i].flag & FB_MODE_IS_FIRST) {\r\nmodedb = &specs->modedb[i];\r\nbreak;\r\n}\r\n}\r\n}\r\ninfo->var.bits_per_pixel = default_bpp;\r\nfb_videomode_to_var(&info->var, modedb);\r\n}\r\npr_debug("xres_virtual %d\n", info->var.xres_virtual);\r\npr_debug("bits_per_pixel %d\n", info->var.bits_per_pixel);\r\npr_debug("info->var.yres_virtual = %d\n", info->var.yres_virtual);\r\npr_debug("info->fix.line_length = %d\n", info->fix.line_length);\r\nif (mfbi->type == MFB_TYPE_OFF)\r\nmfbi->blank = FB_BLANK_NORMAL;\r\nelse\r\nmfbi->blank = FB_BLANK_UNBLANK;\r\nif (fsl_diu_check_var(&info->var, info)) {\r\nprintk(KERN_ERR "fb_check_var failed");\r\nfb_dealloc_cmap(&info->cmap);\r\nreturn -EINVAL;\r\n}\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR "register_framebuffer failed");\r\nunmap_video_memory(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nreturn -EINVAL;\r\n}\r\nmfbi->registered = 1;\r\nprintk(KERN_INFO "fb%d: %s fb device registered successfully.\n",\r\ninfo->node, info->fix.id);\r\nreturn 0;\r\n}\r\nstatic void uninstall_fb(struct fb_info *info)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nif (!mfbi->registered)\r\nreturn;\r\nif (mfbi->index == 0)\r\nkfree(mfbi->edid_data);\r\nunregister_framebuffer(info);\r\nunmap_video_memory(info);\r\nif (&info->cmap)\r\nfb_dealloc_cmap(&info->cmap);\r\nmfbi->registered = 0;\r\n}\r\nstatic irqreturn_t fsl_diu_isr(int irq, void *dev_id)\r\n{\r\nstruct diu *hw = dr.diu_reg;\r\nunsigned int status = in_be32(&hw->int_status);\r\nif (status) {\r\nif (status & INT_UNDRUN) {\r\nout_be32(&hw->diu_mode, 0);\r\npr_debug("Err: DIU occurs underrun!\n");\r\nudelay(1);\r\nout_be32(&hw->diu_mode, 1);\r\n}\r\n#if defined(CONFIG_NOT_COHERENT_CACHE)\r\nelse if (status & INT_VSYNC) {\r\nunsigned int i;\r\nfor (i = 0; i < coherence_data_size;\r\ni += d_cache_line_size)\r\n__asm__ __volatile__ (\r\n"dcbz 0, %[input]"\r\n::[input]"r"(&coherence_data[i]));\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int request_irq_local(int irq)\r\n{\r\nunsigned long status, ints;\r\nstruct diu *hw;\r\nint ret;\r\nhw = dr.diu_reg;\r\nstatus = in_be32(&hw->int_status);\r\nret = request_irq(irq, fsl_diu_isr, 0, "diu", NULL);\r\nif (ret)\r\npr_info("Request diu IRQ failed.\n");\r\nelse {\r\nints = INT_PARERR | INT_LS_BF_VS;\r\n#if !defined(CONFIG_NOT_COHERENT_CACHE)\r\nints |= INT_VSYNC;\r\n#endif\r\nif (dr.mode == MFB_MODE2 || dr.mode == MFB_MODE3)\r\nints |= INT_VSYNC_WB;\r\nstatus = in_be32(&hw->int_status);\r\nout_be32(&hw->int_mask, ints);\r\n}\r\nreturn ret;\r\n}\r\nstatic void free_irq_local(int irq)\r\n{\r\nstruct diu *hw = dr.diu_reg;\r\nout_be32(&hw->int_mask, 0x1f);\r\nfree_irq(irq, NULL);\r\n}\r\nstatic int fsl_diu_suspend(struct platform_device *ofdev, pm_message_t state)\r\n{\r\nstruct fsl_diu_data *machine_data;\r\nmachine_data = dev_get_drvdata(&ofdev->dev);\r\ndisable_lcdc(machine_data->fsl_diu_info[0]);\r\nreturn 0;\r\n}\r\nstatic int fsl_diu_resume(struct platform_device *ofdev)\r\n{\r\nstruct fsl_diu_data *machine_data;\r\nmachine_data = dev_get_drvdata(&ofdev->dev);\r\nenable_lcdc(machine_data->fsl_diu_info[0]);\r\nreturn 0;\r\n}\r\nstatic int allocate_buf(struct device *dev, struct diu_addr *buf, u32 size,\r\nu32 bytes_align)\r\n{\r\nu32 offset, ssize;\r\nu32 mask;\r\ndma_addr_t paddr = 0;\r\nssize = size + bytes_align;\r\nbuf->vaddr = dma_alloc_coherent(dev, ssize, &paddr, GFP_DMA |\r\n__GFP_ZERO);\r\nif (!buf->vaddr)\r\nreturn -ENOMEM;\r\nbuf->paddr = (__u32) paddr;\r\nmask = bytes_align - 1;\r\noffset = (u32)buf->paddr & mask;\r\nif (offset) {\r\nbuf->offset = bytes_align - offset;\r\nbuf->paddr = (u32)buf->paddr + offset;\r\n} else\r\nbuf->offset = 0;\r\nreturn 0;\r\n}\r\nstatic void free_buf(struct device *dev, struct diu_addr *buf, u32 size,\r\nu32 bytes_align)\r\n{\r\ndma_free_coherent(dev, size + bytes_align,\r\nbuf->vaddr, (buf->paddr - buf->offset));\r\nreturn;\r\n}\r\nstatic ssize_t store_monitor(struct device *device,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint old_monitor_port;\r\nunsigned long val;\r\nstruct fsl_diu_data *machine_data =\r\ncontainer_of(attr, struct fsl_diu_data, dev_attr);\r\nif (strict_strtoul(buf, 10, &val))\r\nreturn 0;\r\nold_monitor_port = machine_data->monitor_port;\r\nmachine_data->monitor_port = diu_ops.set_sysfs_monitor_port(val);\r\nif (old_monitor_port != machine_data->monitor_port) {\r\nfsl_diu_set_par(machine_data->fsl_diu_info[0]);\r\nfsl_diu_set_par(machine_data->fsl_diu_info[1]);\r\nfsl_diu_set_par(machine_data->fsl_diu_info[2]);\r\nfsl_diu_set_par(machine_data->fsl_diu_info[3]);\r\nfsl_diu_set_par(machine_data->fsl_diu_info[4]);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_monitor(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fsl_diu_data *machine_data =\r\ncontainer_of(attr, struct fsl_diu_data, dev_attr);\r\nreturn diu_ops.show_monitor_port(machine_data->monitor_port, buf);\r\n}\r\nstatic int __devinit fsl_diu_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct mfb_info *mfbi;\r\nphys_addr_t dummy_ad_addr;\r\nint ret, i, error = 0;\r\nstruct resource res;\r\nstruct fsl_diu_data *machine_data;\r\nint diu_mode;\r\nmachine_data = kzalloc(sizeof(struct fsl_diu_data), GFP_KERNEL);\r\nif (!machine_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(machine_data->fsl_diu_info); i++) {\r\nmachine_data->fsl_diu_info[i] =\r\nframebuffer_alloc(sizeof(struct mfb_info), &ofdev->dev);\r\nif (!machine_data->fsl_diu_info[i]) {\r\ndev_err(&ofdev->dev, "cannot allocate memory\n");\r\nret = -ENOMEM;\r\ngoto error2;\r\n}\r\nmfbi = machine_data->fsl_diu_info[i]->par;\r\nmemcpy(mfbi, &mfb_template[i], sizeof(struct mfb_info));\r\nmfbi->parent = machine_data;\r\nif (mfbi->index == 0) {\r\nconst u8 *prop;\r\nint len;\r\nprop = of_get_property(np, "edid", &len);\r\nif (prop && len == EDID_LENGTH)\r\nmfbi->edid_data = kmemdup(prop, EDID_LENGTH,\r\nGFP_KERNEL);\r\n}\r\n}\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret) {\r\ndev_err(&ofdev->dev, "could not obtain DIU address\n");\r\ngoto error;\r\n}\r\nif (!res.start) {\r\ndev_err(&ofdev->dev, "invalid DIU address\n");\r\ngoto error;\r\n}\r\ndev_dbg(&ofdev->dev, "%s, res.start: 0x%08x\n", __func__, res.start);\r\ndr.diu_reg = ioremap(res.start, sizeof(struct diu));\r\nif (!dr.diu_reg) {\r\ndev_err(&ofdev->dev, "Err: can't map DIU registers!\n");\r\nret = -EFAULT;\r\ngoto error2;\r\n}\r\ndiu_mode = in_be32(&dr.diu_reg->diu_mode);\r\nif (diu_mode != MFB_MODE1)\r\nout_be32(&dr.diu_reg->diu_mode, 0);\r\nmachine_data->irq = irq_of_parse_and_map(np, 0);\r\nif (!machine_data->irq) {\r\ndev_err(&ofdev->dev, "could not get DIU IRQ\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nmachine_data->monitor_port = monitor_port;\r\nif (allocate_buf(&ofdev->dev, &pool.ad,\r\nsizeof(struct diu_ad) * FSL_AOI_NUM, 8))\r\nreturn -ENOMEM;\r\nif (allocate_buf(&ofdev->dev, &pool.gamma, 768, 32)) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (allocate_buf(&ofdev->dev, &pool.cursor, MAX_CURS * MAX_CURS * 2,\r\n32)) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\ni = ARRAY_SIZE(machine_data->fsl_diu_info);\r\nmachine_data->dummy_ad = (struct diu_ad *)\r\n((u32)pool.ad.vaddr + pool.ad.offset) + i;\r\nmachine_data->dummy_ad->paddr = pool.ad.paddr +\r\ni * sizeof(struct diu_ad);\r\nmachine_data->dummy_aoi_virt = fsl_diu_alloc(64, &dummy_ad_addr);\r\nif (!machine_data->dummy_aoi_virt) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nmachine_data->dummy_ad->addr = cpu_to_le32(dummy_ad_addr);\r\nmachine_data->dummy_ad->pix_fmt = 0x88882317;\r\nmachine_data->dummy_ad->src_size_g_alpha = cpu_to_le32((4 << 12) | 4);\r\nmachine_data->dummy_ad->aoi_size = cpu_to_le32((4 << 16) | 2);\r\nmachine_data->dummy_ad->offset_xyi = 0;\r\nmachine_data->dummy_ad->offset_xyd = 0;\r\nmachine_data->dummy_ad->next_ad = 0;\r\nif (diu_mode != MFB_MODE1)\r\nout_be32(&dr.diu_reg->desc[0], machine_data->dummy_ad->paddr);\r\nout_be32(&dr.diu_reg->desc[1], machine_data->dummy_ad->paddr);\r\nout_be32(&dr.diu_reg->desc[2], machine_data->dummy_ad->paddr);\r\nfor (i = 0; i < ARRAY_SIZE(machine_data->fsl_diu_info); i++) {\r\nmachine_data->fsl_diu_info[i]->fix.smem_start = 0;\r\nmfbi = machine_data->fsl_diu_info[i]->par;\r\nmfbi->ad = (struct diu_ad *)((u32)pool.ad.vaddr\r\n+ pool.ad.offset) + i;\r\nmfbi->ad->paddr = pool.ad.paddr + i * sizeof(struct diu_ad);\r\nret = install_fb(machine_data->fsl_diu_info[i]);\r\nif (ret) {\r\ndev_err(&ofdev->dev,\r\n"Failed to register framebuffer %d\n",\r\ni);\r\ngoto error;\r\n}\r\n}\r\nif (request_irq_local(machine_data->irq)) {\r\ndev_err(machine_data->fsl_diu_info[0]->dev,\r\n"could not request irq for diu.");\r\ngoto error;\r\n}\r\nsysfs_attr_init(&machine_data->dev_attr.attr);\r\nmachine_data->dev_attr.attr.name = "monitor";\r\nmachine_data->dev_attr.attr.mode = S_IRUGO|S_IWUSR;\r\nmachine_data->dev_attr.show = show_monitor;\r\nmachine_data->dev_attr.store = store_monitor;\r\nerror = device_create_file(machine_data->fsl_diu_info[0]->dev,\r\n&machine_data->dev_attr);\r\nif (error) {\r\ndev_err(machine_data->fsl_diu_info[0]->dev,\r\n"could not create sysfs %s file\n",\r\nmachine_data->dev_attr.attr.name);\r\n}\r\ndev_set_drvdata(&ofdev->dev, machine_data);\r\nreturn 0;\r\nerror:\r\nfor (i = ARRAY_SIZE(machine_data->fsl_diu_info);\r\ni > 0; i--)\r\nuninstall_fb(machine_data->fsl_diu_info[i - 1]);\r\nif (pool.ad.vaddr)\r\nfree_buf(&ofdev->dev, &pool.ad,\r\nsizeof(struct diu_ad) * FSL_AOI_NUM, 8);\r\nif (pool.gamma.vaddr)\r\nfree_buf(&ofdev->dev, &pool.gamma, 768, 32);\r\nif (pool.cursor.vaddr)\r\nfree_buf(&ofdev->dev, &pool.cursor, MAX_CURS * MAX_CURS * 2,\r\n32);\r\nif (machine_data->dummy_aoi_virt)\r\nfsl_diu_free(machine_data->dummy_aoi_virt, 64);\r\niounmap(dr.diu_reg);\r\nerror2:\r\nfor (i = 0; i < ARRAY_SIZE(machine_data->fsl_diu_info); i++)\r\nif (machine_data->fsl_diu_info[i])\r\nframebuffer_release(machine_data->fsl_diu_info[i]);\r\nkfree(machine_data);\r\nreturn ret;\r\n}\r\nstatic int fsl_diu_remove(struct platform_device *ofdev)\r\n{\r\nstruct fsl_diu_data *machine_data;\r\nint i;\r\nmachine_data = dev_get_drvdata(&ofdev->dev);\r\ndisable_lcdc(machine_data->fsl_diu_info[0]);\r\nfree_irq_local(machine_data->irq);\r\nfor (i = ARRAY_SIZE(machine_data->fsl_diu_info); i > 0; i--)\r\nuninstall_fb(machine_data->fsl_diu_info[i - 1]);\r\nif (pool.ad.vaddr)\r\nfree_buf(&ofdev->dev, &pool.ad,\r\nsizeof(struct diu_ad) * FSL_AOI_NUM, 8);\r\nif (pool.gamma.vaddr)\r\nfree_buf(&ofdev->dev, &pool.gamma, 768, 32);\r\nif (pool.cursor.vaddr)\r\nfree_buf(&ofdev->dev, &pool.cursor, MAX_CURS * MAX_CURS * 2,\r\n32);\r\nif (machine_data->dummy_aoi_virt)\r\nfsl_diu_free(machine_data->dummy_aoi_virt, 64);\r\niounmap(dr.diu_reg);\r\nfor (i = 0; i < ARRAY_SIZE(machine_data->fsl_diu_info); i++)\r\nif (machine_data->fsl_diu_info[i])\r\nframebuffer_release(machine_data->fsl_diu_info[i]);\r\nkfree(machine_data);\r\nreturn 0;\r\n}\r\nstatic int __init fsl_diu_setup(char *options)\r\n{\r\nchar *opt;\r\nunsigned long val;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nif (!strncmp(opt, "monitor=", 8)) {\r\nif (!strict_strtoul(opt + 8, 10, &val) && (val <= 2))\r\nmonitor_port = val;\r\n} else if (!strncmp(opt, "bpp=", 4)) {\r\nif (!strict_strtoul(opt + 4, 10, &val))\r\ndefault_bpp = val;\r\n} else\r\nfb_mode = opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init fsl_diu_init(void)\r\n{\r\n#ifdef CONFIG_NOT_COHERENT_CACHE\r\nstruct device_node *np;\r\nconst u32 *prop;\r\n#endif\r\nint ret;\r\n#ifndef MODULE\r\nchar *option;\r\nif (fb_get_options("fslfb", &option))\r\nreturn -ENODEV;\r\nfsl_diu_setup(option);\r\n#endif\r\nprintk(KERN_INFO "Freescale DIU driver\n");\r\n#ifdef CONFIG_NOT_COHERENT_CACHE\r\nnp = of_find_node_by_type(NULL, "cpu");\r\nif (!np) {\r\nprintk(KERN_ERR "Err: can't find device node 'cpu'\n");\r\nreturn -ENODEV;\r\n}\r\nprop = of_get_property(np, "d-cache-size", NULL);\r\nif (prop == NULL) {\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\ncoherence_data_size = *prop * 13;\r\ncoherence_data_size /= 8;\r\nprop = of_get_property(np, "d-cache-line-size", NULL);\r\nif (prop == NULL) {\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nd_cache_line_size = *prop;\r\nof_node_put(np);\r\ncoherence_data = vmalloc(coherence_data_size);\r\nif (!coherence_data)\r\nreturn -ENOMEM;\r\n#endif\r\nret = platform_driver_register(&fsl_diu_driver);\r\nif (ret) {\r\nprintk(KERN_ERR\r\n"fsl-diu: failed to register platform driver\n");\r\n#if defined(CONFIG_NOT_COHERENT_CACHE)\r\nvfree(coherence_data);\r\n#endif\r\niounmap(dr.diu_reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit fsl_diu_exit(void)\r\n{\r\nplatform_driver_unregister(&fsl_diu_driver);\r\n#if defined(CONFIG_NOT_COHERENT_CACHE)\r\nvfree(coherence_data);\r\n#endif\r\n}
