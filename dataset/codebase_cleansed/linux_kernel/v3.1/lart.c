static __u8 read8 (__u32 offset)\r\n{\r\nvolatile __u8 *data = (__u8 *) (FLASH_OFFSET + offset);\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG "%s(): 0x%.8x -> 0x%.2x\n", __func__, offset, *data);\r\n#endif\r\nreturn (*data);\r\n}\r\nstatic __u32 read32 (__u32 offset)\r\n{\r\nvolatile __u32 *data = (__u32 *) (FLASH_OFFSET + offset);\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG "%s(): 0x%.8x -> 0x%.8x\n", __func__, offset, *data);\r\n#endif\r\nreturn (*data);\r\n}\r\nstatic void write32 (__u32 x,__u32 offset)\r\n{\r\nvolatile __u32 *data = (__u32 *) (FLASH_OFFSET + offset);\r\n*data = x;\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG "%s(): 0x%.8x <- 0x%.8x\n", __func__, offset, *data);\r\n#endif\r\n}\r\nstatic int flash_probe (void)\r\n{\r\n__u32 manufacturer,devtype;\r\nwrite32 (DATA_TO_FLASH (READ_ID_CODES),0x00000000);\r\nmanufacturer = FLASH_TO_DATA (read32 (ADDR_TO_FLASH_U2 (0x00000000)));\r\ndevtype = FLASH_TO_DATA (read32 (ADDR_TO_FLASH_U2 (0x00000001)));\r\nwrite32 (DATA_TO_FLASH (READ_ARRAY),0x00000000);\r\nreturn (manufacturer == FLASH_MANUFACTURER && (devtype == FLASH_DEVICE_16mbit_TOP || devtype == FLASH_DEVICE_16mbit_BOTTOM));\r\n}\r\nstatic inline int erase_block (__u32 offset)\r\n{\r\n__u32 status;\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG "%s(): 0x%.8x\n", __func__, offset);\r\n#endif\r\nwrite32 (DATA_TO_FLASH (ERASE_SETUP),offset);\r\nwrite32 (DATA_TO_FLASH (ERASE_CONFIRM),offset);\r\ndo\r\n{\r\nwrite32 (DATA_TO_FLASH (STATUS_READ),offset);\r\nstatus = FLASH_TO_DATA (read32 (offset));\r\n}\r\nwhile ((~status & STATUS_BUSY) != 0);\r\nwrite32 (DATA_TO_FLASH (READ_ARRAY),offset);\r\nif ((status & STATUS_ERASE_ERR))\r\n{\r\nprintk (KERN_WARNING "%s: erase error at address 0x%.8x.\n",module_name,offset);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic int flash_erase (struct mtd_info *mtd,struct erase_info *instr)\r\n{\r\n__u32 addr,len;\r\nint i,first;\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG "%s(addr = 0x%.8x, len = %d)\n", __func__, instr->addr, instr->len);\r\n#endif\r\nif (instr->addr + instr->len > mtd->size) return (-EINVAL);\r\nfor (i = 0; i < mtd->numeraseregions && instr->addr >= mtd->eraseregions[i].offset; i++) ;\r\ni--;\r\nif (i < 0 || (instr->addr & (mtd->eraseregions[i].erasesize - 1)))\r\nreturn -EINVAL;\r\nfirst = i;\r\nfor (; i < mtd->numeraseregions && instr->addr + instr->len >= mtd->eraseregions[i].offset; i++) ;\r\ni--;\r\nif (i < 0 || ((instr->addr + instr->len) & (mtd->eraseregions[i].erasesize - 1)))\r\nreturn -EINVAL;\r\naddr = instr->addr;\r\nlen = instr->len;\r\ni = first;\r\nwhile (len)\r\n{\r\nif (!erase_block (addr))\r\n{\r\ninstr->state = MTD_ERASE_FAILED;\r\nreturn (-EIO);\r\n}\r\naddr += mtd->eraseregions[i].erasesize;\r\nlen -= mtd->eraseregions[i].erasesize;\r\nif (addr == mtd->eraseregions[i].offset + (mtd->eraseregions[i].erasesize * mtd->eraseregions[i].numblocks)) i++;\r\n}\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn (0);\r\n}\r\nstatic int flash_read (struct mtd_info *mtd,loff_t from,size_t len,size_t *retlen,u_char *buf)\r\n{\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG "%s(from = 0x%.8x, len = %d)\n", __func__, (__u32)from, len);\r\n#endif\r\nif (!len) return (0);\r\nif (from + len > mtd->size) return (-EINVAL);\r\n*retlen = len;\r\nif (from & (BUSWIDTH - 1))\r\n{\r\nint gap = BUSWIDTH - (from & (BUSWIDTH - 1));\r\nwhile (len && gap--) *buf++ = read8 (from++), len--;\r\n}\r\nwhile (len >= BUSWIDTH)\r\n{\r\n*((__u32 *) buf) = read32 (from);\r\nbuf += BUSWIDTH;\r\nfrom += BUSWIDTH;\r\nlen -= BUSWIDTH;\r\n}\r\nif (len & (BUSWIDTH - 1))\r\nwhile (len--) *buf++ = read8 (from++);\r\nreturn (0);\r\n}\r\nstatic inline int write_dword (__u32 offset,__u32 x)\r\n{\r\n__u32 status;\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG "%s(): 0x%.8x <- 0x%.8x\n", __func__, offset, x);\r\n#endif\r\nwrite32 (DATA_TO_FLASH (PGM_SETUP),offset);\r\nwrite32 (x,offset);\r\ndo\r\n{\r\nwrite32 (DATA_TO_FLASH (STATUS_READ),offset);\r\nstatus = FLASH_TO_DATA (read32 (offset));\r\n}\r\nwhile ((~status & STATUS_BUSY) != 0);\r\nwrite32 (DATA_TO_FLASH (READ_ARRAY),offset);\r\nif ((status & STATUS_PGM_ERR) || read32 (offset) != x)\r\n{\r\nprintk (KERN_WARNING "%s: write error at address 0x%.8x.\n",module_name,offset);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic int flash_write (struct mtd_info *mtd,loff_t to,size_t len,size_t *retlen,const u_char *buf)\r\n{\r\n__u8 tmp[4];\r\nint i,n;\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG "%s(to = 0x%.8x, len = %d)\n", __func__, (__u32)to, len);\r\n#endif\r\n*retlen = 0;\r\nif (!len) return (0);\r\nif (to + len > mtd->size) return (-EINVAL);\r\nif (to & (BUSWIDTH - 1))\r\n{\r\n__u32 aligned = to & ~(BUSWIDTH - 1);\r\nint gap = to - aligned;\r\ni = n = 0;\r\nwhile (gap--) tmp[i++] = 0xFF;\r\nwhile (len && i < BUSWIDTH) tmp[i++] = buf[n++], len--;\r\nwhile (i < BUSWIDTH) tmp[i++] = 0xFF;\r\nif (!write_dword (aligned,*((__u32 *) tmp))) return (-EIO);\r\nto += n;\r\nbuf += n;\r\n*retlen += n;\r\n}\r\nwhile (len >= BUSWIDTH)\r\n{\r\nif (!write_dword (to,*((__u32 *) buf))) return (-EIO);\r\nto += BUSWIDTH;\r\nbuf += BUSWIDTH;\r\n*retlen += BUSWIDTH;\r\nlen -= BUSWIDTH;\r\n}\r\nif (len & (BUSWIDTH - 1))\r\n{\r\ni = n = 0;\r\nwhile (len--) tmp[i++] = buf[n++];\r\nwhile (i < BUSWIDTH) tmp[i++] = 0xFF;\r\nif (!write_dword (to,*((__u32 *) tmp))) return (-EIO);\r\n*retlen += n;\r\n}\r\nreturn (0);\r\n}\r\nstatic int __init lart_flash_init (void)\r\n{\r\nint result;\r\nmemset (&mtd,0,sizeof (mtd));\r\nprintk ("MTD driver for LART. Written by Abraham vd Merwe <abraham@2d3d.co.za>\n");\r\nprintk ("%s: Probing for 28F160x3 flash on LART...\n",module_name);\r\nif (!flash_probe ())\r\n{\r\nprintk (KERN_WARNING "%s: Found no LART compatible flash device\n",module_name);\r\nreturn (-ENXIO);\r\n}\r\nprintk ("%s: This looks like a LART board to me.\n",module_name);\r\nmtd.name = module_name;\r\nmtd.type = MTD_NORFLASH;\r\nmtd.writesize = 1;\r\nmtd.flags = MTD_CAP_NORFLASH;\r\nmtd.size = FLASH_BLOCKSIZE_PARAM * FLASH_NUMBLOCKS_16m_PARAM + FLASH_BLOCKSIZE_MAIN * FLASH_NUMBLOCKS_16m_MAIN;\r\nmtd.erasesize = FLASH_BLOCKSIZE_MAIN;\r\nmtd.numeraseregions = ARRAY_SIZE(erase_regions);\r\nmtd.eraseregions = erase_regions;\r\nmtd.erase = flash_erase;\r\nmtd.read = flash_read;\r\nmtd.write = flash_write;\r\nmtd.owner = THIS_MODULE;\r\n#ifdef LART_DEBUG\r\nprintk (KERN_DEBUG\r\n"mtd.name = %s\n"\r\n"mtd.size = 0x%.8x (%uM)\n"\r\n"mtd.erasesize = 0x%.8x (%uK)\n"\r\n"mtd.numeraseregions = %d\n",\r\nmtd.name,\r\nmtd.size,mtd.size / (1024*1024),\r\nmtd.erasesize,mtd.erasesize / 1024,\r\nmtd.numeraseregions);\r\nif (mtd.numeraseregions)\r\nfor (result = 0; result < mtd.numeraseregions; result++)\r\nprintk (KERN_DEBUG\r\n"\n\n"\r\n"mtd.eraseregions[%d].offset = 0x%.8x\n"\r\n"mtd.eraseregions[%d].erasesize = 0x%.8x (%uK)\n"\r\n"mtd.eraseregions[%d].numblocks = %d\n",\r\nresult,mtd.eraseregions[result].offset,\r\nresult,mtd.eraseregions[result].erasesize,mtd.eraseregions[result].erasesize / 1024,\r\nresult,mtd.eraseregions[result].numblocks);\r\n#ifdef HAVE_PARTITIONS\r\nprintk ("\npartitions = %d\n", ARRAY_SIZE(lart_partitions));\r\nfor (result = 0; result < ARRAY_SIZE(lart_partitions); result++)\r\nprintk (KERN_DEBUG\r\n"\n\n"\r\n"lart_partitions[%d].name = %s\n"\r\n"lart_partitions[%d].offset = 0x%.8x\n"\r\n"lart_partitions[%d].size = 0x%.8x (%uK)\n",\r\nresult,lart_partitions[result].name,\r\nresult,lart_partitions[result].offset,\r\nresult,lart_partitions[result].size,lart_partitions[result].size / 1024);\r\n#endif\r\n#endif\r\n#ifndef HAVE_PARTITIONS\r\nresult = mtd_device_register(&mtd, NULL, 0);\r\n#else\r\nresult = mtd_device_register(&mtd, lart_partitions,\r\nARRAY_SIZE(lart_partitions));\r\n#endif\r\nreturn (result);\r\n}\r\nstatic void __exit lart_flash_exit (void)\r\n{\r\n#ifndef HAVE_PARTITIONS\r\nmtd_device_unregister(&mtd);\r\n#else\r\nmtd_device_unregister(&mtd);\r\n#endif\r\n}
