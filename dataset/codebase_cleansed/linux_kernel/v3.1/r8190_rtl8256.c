void PHY_SetRF8256Bandwidth(struct r8192_priv *priv, HT_CHANNEL_WIDTH Bandwidth)\r\n{\r\nu8 eRFPath;\r\nfor(eRFPath = 0; eRFPath <priv->NumTotalRFPath; eRFPath++)\r\n{\r\nif (!rtl8192_phy_CheckIsLegalRFPath(priv, eRFPath))\r\ncontinue;\r\nswitch(Bandwidth)\r\n{\r\ncase HT_CHANNEL_WIDTH_20:\r\nif(priv->card_8192_version == VERSION_8190_BD || priv->card_8192_version == VERSION_8190_BE)\r\n{\r\nrtl8192_phy_SetRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, 0x0b, bMask12Bits, 0x100);\r\nrtl8192_phy_SetRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, 0x2c, bMask12Bits, 0x3d7);\r\nrtl8192_phy_SetRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, 0x0e, bMask12Bits, 0x021);\r\n}\r\nelse\r\n{\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): unknown hardware version\n");\r\n}\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nif(priv->card_8192_version == VERSION_8190_BD ||priv->card_8192_version == VERSION_8190_BE)\r\n{\r\nrtl8192_phy_SetRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, 0x0b, bMask12Bits, 0x300);\r\nrtl8192_phy_SetRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, 0x2c, bMask12Bits, 0x3ff);\r\nrtl8192_phy_SetRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, 0x0e, bMask12Bits, 0x0e1);\r\n}\r\nelse\r\n{\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): unknown hardware version\n");\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): unknown Bandwidth: %#X\n",Bandwidth );\r\nbreak;\r\n}\r\n}\r\n}\r\nRT_STATUS PHY_RF8256_Config(struct r8192_priv *priv)\r\n{\r\nRT_STATUS rtStatus = RT_STATUS_SUCCESS;\r\npriv->NumTotalRFPath = RTL819X_TOTAL_RF_PATH;\r\nrtStatus = phy_RF8256_Config_ParaFile(priv);\r\nreturn rtStatus;\r\n}\r\nRT_STATUS phy_RF8256_Config_ParaFile(struct r8192_priv *priv)\r\n{\r\nu32 u4RegValue = 0;\r\nu8 eRFPath;\r\nRT_STATUS rtStatus = RT_STATUS_SUCCESS;\r\nBB_REGISTER_DEFINITION_T *pPhyReg;\r\nu32 RegOffSetToBeCheck = 0x3;\r\nu32 RegValueToBeCheck = 0x7f1;\r\nu32 RF3_Final_Value = 0;\r\nu8 ConstRetryTimes = 5, RetryTimes = 5;\r\nu8 ret = 0;\r\nfor(eRFPath = (RF90_RADIO_PATH_E)RF90_PATH_A; eRFPath <priv->NumTotalRFPath; eRFPath++)\r\n{\r\nif (!rtl8192_phy_CheckIsLegalRFPath(priv, eRFPath))\r\ncontinue;\r\npPhyReg = &priv->PHYRegDef[eRFPath];\r\nswitch(eRFPath)\r\n{\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nu4RegValue = rtl8192_QueryBBReg(priv, pPhyReg->rfintfs, bRFSI_RFENV);\r\nbreak;\r\ncase RF90_PATH_B :\r\ncase RF90_PATH_D:\r\nu4RegValue = rtl8192_QueryBBReg(priv, pPhyReg->rfintfs, bRFSI_RFENV<<16);\r\nbreak;\r\n}\r\nrtl8192_setBBreg(priv, pPhyReg->rfintfe, bRFSI_RFENV<<16, 0x1);\r\nrtl8192_setBBreg(priv, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);\r\nrtl8192_setBBreg(priv, pPhyReg->rfHSSIPara2, b3WireAddressLength, 0x0);\r\nrtl8192_setBBreg(priv, pPhyReg->rfHSSIPara2, b3WireDataLength, 0x0);\r\nrtl8192_phy_SetRFReg(priv, (RF90_RADIO_PATH_E) eRFPath, 0x0, bMask12Bits, 0xbf);\r\nrtStatus = rtl8192_phy_checkBBAndRF(priv, HW90_BLOCK_RF, (RF90_RADIO_PATH_E)eRFPath);\r\nif(rtStatus!= RT_STATUS_SUCCESS)\r\n{\r\nRT_TRACE(COMP_ERR, "PHY_RF8256_Config():Check Radio[%d] Fail!!\n", eRFPath);\r\ngoto phy_RF8256_Config_ParaFile_Fail;\r\n}\r\nRetryTimes = ConstRetryTimes;\r\nRF3_Final_Value = 0;\r\nswitch(eRFPath)\r\n{\r\ncase RF90_PATH_A:\r\nwhile(RF3_Final_Value!=RegValueToBeCheck && RetryTimes!=0)\r\n{\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(priv,(RF90_RADIO_PATH_E)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nwhile(RF3_Final_Value!=RegValueToBeCheck && RetryTimes!=0)\r\n{\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(priv,(RF90_RADIO_PATH_E)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\nwhile(RF3_Final_Value!=RegValueToBeCheck && RetryTimes!=0)\r\n{\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(priv,(RF90_RADIO_PATH_E)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_D:\r\nwhile(RF3_Final_Value!=RegValueToBeCheck && RetryTimes!=0)\r\n{\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(priv,(RF90_RADIO_PATH_E)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(priv, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\n}\r\n;\r\nswitch(eRFPath)\r\n{\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nrtl8192_setBBreg(priv, pPhyReg->rfintfs, bRFSI_RFENV, u4RegValue);\r\nbreak;\r\ncase RF90_PATH_B :\r\ncase RF90_PATH_D:\r\nrtl8192_setBBreg(priv, pPhyReg->rfintfs, bRFSI_RFENV<<16, u4RegValue);\r\nbreak;\r\n}\r\nif(ret){\r\nRT_TRACE(COMP_ERR, "phy_RF8256_Config_ParaFile():Radio[%d] Fail!!", eRFPath);\r\ngoto phy_RF8256_Config_ParaFile_Fail;\r\n}\r\n}\r\nRT_TRACE(COMP_PHY, "PHY Initialization Success\n") ;\r\nreturn RT_STATUS_SUCCESS;\r\nphy_RF8256_Config_ParaFile_Fail:\r\nRT_TRACE(COMP_ERR, "PHY Initialization failed\n") ;\r\nreturn RT_STATUS_FAILURE;\r\n}\r\nvoid PHY_SetRF8256CCKTxPower(struct r8192_priv *priv, u8 powerlevel)\r\n{\r\nu32 TxAGC=0;\r\nTxAGC = powerlevel;\r\nif(priv->bDynamicTxLowPower == true)\r\n{\r\nif(priv->CustomerID == RT_CID_819x_Netcore)\r\nTxAGC = 0x22;\r\nelse\r\nTxAGC += priv->CckPwEnl;\r\n}\r\nif(TxAGC > 0x24)\r\nTxAGC = 0x24;\r\nrtl8192_setBBreg(priv, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);\r\n}\r\nvoid PHY_SetRF8256OFDMTxPower(struct r8192_priv *priv, u8 powerlevel)\r\n{\r\nu32 writeVal, powerBase0, powerBase1, writeVal_tmp;\r\nu8 index = 0;\r\nu16 RegOffset[6] = {0xe00, 0xe04, 0xe10, 0xe14, 0xe18, 0xe1c};\r\nu8 byte0, byte1, byte2, byte3;\r\npowerBase0 = powerlevel + priv->LegacyHTTxPowerDiff;\r\npowerBase0 = (powerBase0<<24) | (powerBase0<<16) |(powerBase0<<8) |powerBase0;\r\npowerBase1 = powerlevel;\r\npowerBase1 = (powerBase1<<24) | (powerBase1<<16) |(powerBase1<<8) |powerBase1;\r\nfor(index=0; index<6; index++)\r\n{\r\nwriteVal = priv->MCSTxPowerLevelOriginalOffset[index] + ((index<2)?powerBase0:powerBase1);\r\nbyte0 = (u8)(writeVal & 0x7f);\r\nbyte1 = (u8)((writeVal & 0x7f00)>>8);\r\nbyte2 = (u8)((writeVal & 0x7f0000)>>16);\r\nbyte3 = (u8)((writeVal & 0x7f000000)>>24);\r\nif(byte0 > 0x24)\r\nbyte0 = 0x24;\r\nif(byte1 > 0x24)\r\nbyte1 = 0x24;\r\nif(byte2 > 0x24)\r\nbyte2 = 0x24;\r\nif(byte3 > 0x24)\r\nbyte3 = 0x24;\r\nif(index == 3)\r\n{\r\nwriteVal_tmp = (byte3<<24) | (byte2<<16) |(byte1<<8) |byte0;\r\npriv->Pwr_Track = writeVal_tmp;\r\n}\r\nif(priv->bDynamicTxHighPower == true)\r\n{\r\nwriteVal = 0x03030303;\r\n}\r\nelse\r\n{\r\nwriteVal = (byte3<<24) | (byte2<<16) |(byte1<<8) |byte0;\r\n}\r\nrtl8192_setBBreg(priv, RegOffset[index], 0x7f7f7f7f, writeVal);\r\n}\r\n}\r\nstatic void r8192e_drain_tx_queues(struct r8192_priv *priv)\r\n{\r\nu8 i, QueueID;\r\nfor (QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; )\r\n{\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[QueueID];\r\nif(skb_queue_len(&ring->queue) == 0)\r\n{\r\nQueueID++;\r\ncontinue;\r\n}\r\nudelay(10);\r\ni++;\r\nif (i >= MAX_DOZE_WAITING_TIMES_9x)\r\n{\r\nRT_TRACE(COMP_POWER, "r8192e_drain_tx_queues() timeout queue %d\n", QueueID);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic bool SetRFPowerState8190(struct r8192_priv *priv,\r\nRT_RF_POWER_STATE eRFPowerState)\r\n{\r\nPRT_POWER_SAVE_CONTROL pPSC = &priv->PowerSaveControl;\r\nbool bResult = true;\r\nif (eRFPowerState == priv->eRFPowerState &&\r\npriv->bHwRfOffAction == 0) {\r\nbResult = false;\r\ngoto out;\r\n}\r\nswitch( eRFPowerState )\r\n{\r\ncase eRfOn:\r\nif ((priv->eRFPowerState == eRfOff) &&\r\nRT_IN_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC))\r\n{\r\nif (!NicIFEnableNIC(priv)) {\r\nRT_TRACE(COMP_ERR, "%s(): NicIFEnableNIC failed\n",__FUNCTION__);\r\nbResult = false;\r\ngoto out;\r\n}\r\nRT_CLEAR_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC);\r\n} else {\r\nwrite_nic_byte(priv, ANAPAR, 0x37);\r\nmdelay(1);\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter1, 0x4, 0x1);\r\npriv->bHwRfOffAction = 0;\r\nrtl8192_setBBreg(priv, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter4, 0x300, 0x3);\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter1, 0x18, 0x3);\r\nrtl8192_setBBreg(priv, rOFDM0_TRxPathEnable, 0x3, 0x3);\r\nrtl8192_setBBreg(priv, rOFDM1_TRxPathEnable, 0x3, 0x3);\r\nrtl8192_setBBreg(priv, rFPGA0_AnalogParameter1, 0x60, 0x3);\r\n}\r\nbreak;\r\ncase eRfSleep:\r\nif(priv->eRFPowerState == eRfOff)\r\nbreak;\r\nr8192e_drain_tx_queues(priv);\r\nPHY_SetRtl8192eRfOff(priv);\r\nbreak;\r\ncase eRfOff:\r\nr8192e_drain_tx_queues(priv);\r\nif (pPSC->RegRfPsLevel & RT_RF_OFF_LEVL_HALT_NIC && !RT_IN_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC))\r\n{\r\nNicIFDisableNIC(priv);\r\nRT_SET_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC);\r\n}\r\nelse if (!(pPSC->RegRfPsLevel & RT_RF_OFF_LEVL_HALT_NIC))\r\n{\r\nPHY_SetRtl8192eRfOff(priv);\r\n}\r\nbreak;\r\ndefault:\r\nbResult = false;\r\nRT_TRACE(COMP_ERR, "SetRFPowerState8190(): unknow state to set: 0x%X!!!\n", eRFPowerState);\r\nbreak;\r\n}\r\nif(bResult)\r\n{\r\npriv->eRFPowerState = eRFPowerState;\r\n}\r\nout:\r\nreturn bResult;\r\n}\r\nstatic void MgntDisconnectIBSS(struct r8192_priv *priv)\r\n{\r\nu8 i;\r\nbool bFilterOutNonAssociatedBSSID = false;\r\npriv->ieee80211->state = IEEE80211_NOLINK;\r\nfor(i=0;i<6;i++) priv->ieee80211->current_network.bssid[i]= 0x55;\r\npriv->OpMode = RT_OP_MODE_NO_LINK;\r\nwrite_nic_word(priv, BSSIDR, ((u16*)priv->ieee80211->current_network.bssid)[0]);\r\nwrite_nic_dword(priv, BSSIDR+2, ((u32*)(priv->ieee80211->current_network.bssid+2))[0]);\r\n{\r\nRT_OP_MODE OpMode = priv->OpMode;\r\nu8 btMsr = read_nic_byte(priv, MSR);\r\nbtMsr &= 0xfc;\r\nswitch(OpMode)\r\n{\r\ncase RT_OP_MODE_INFRASTRUCTURE:\r\nbtMsr |= MSR_LINK_MANAGED;\r\nbreak;\r\ncase RT_OP_MODE_IBSS:\r\nbtMsr |= MSR_LINK_ADHOC;\r\nbreak;\r\ncase RT_OP_MODE_AP:\r\nbtMsr |= MSR_LINK_MASTER;\r\nbreak;\r\ndefault:\r\nbtMsr |= MSR_LINK_NONE;\r\nbreak;\r\n}\r\nwrite_nic_byte(priv, MSR, btMsr);\r\n}\r\nieee80211_stop_send_beacons(priv->ieee80211);\r\nbFilterOutNonAssociatedBSSID = false;\r\n{\r\nu32 RegRCR, Type;\r\nType = bFilterOutNonAssociatedBSSID;\r\nRegRCR = read_nic_dword(priv, RCR);\r\npriv->ReceiveConfig = RegRCR;\r\nif (Type == true)\r\nRegRCR |= (RCR_CBSSID);\r\nelse if (Type == false)\r\nRegRCR &= (~RCR_CBSSID);\r\n{\r\nwrite_nic_dword(priv, RCR, RegRCR);\r\npriv->ReceiveConfig = RegRCR;\r\n}\r\n}\r\nnotify_wx_assoc_event(priv->ieee80211);\r\n}\r\nstatic void MlmeDisassociateRequest(struct r8192_priv *priv, u8 *asSta,\r\nu8 asRsn)\r\n{\r\nu8 i;\r\nRemovePeerTS(priv->ieee80211, asSta);\r\nSendDisassociation( priv->ieee80211, asSta, asRsn );\r\nif(memcpy(priv->ieee80211->current_network.bssid,asSta,6) == NULL)\r\n{\r\npriv->ieee80211->state = IEEE80211_NOLINK;\r\nfor(i=0;i<6;i++) priv->ieee80211->current_network.bssid[i] = 0x22;\r\npriv->OpMode = RT_OP_MODE_NO_LINK;\r\n{\r\nRT_OP_MODE OpMode = priv->OpMode;\r\nu8 btMsr = read_nic_byte(priv, MSR);\r\nbtMsr &= 0xfc;\r\nswitch(OpMode)\r\n{\r\ncase RT_OP_MODE_INFRASTRUCTURE:\r\nbtMsr |= MSR_LINK_MANAGED;\r\nbreak;\r\ncase RT_OP_MODE_IBSS:\r\nbtMsr |= MSR_LINK_ADHOC;\r\nbreak;\r\ncase RT_OP_MODE_AP:\r\nbtMsr |= MSR_LINK_MASTER;\r\nbreak;\r\ndefault:\r\nbtMsr |= MSR_LINK_NONE;\r\nbreak;\r\n}\r\nwrite_nic_byte(priv, MSR, btMsr);\r\n}\r\nieee80211_disassociate(priv->ieee80211);\r\nwrite_nic_word(priv, BSSIDR, ((u16*)priv->ieee80211->current_network.bssid)[0]);\r\nwrite_nic_dword(priv, BSSIDR+2, ((u32*)(priv->ieee80211->current_network.bssid+2))[0]);\r\n}\r\n}\r\nstatic void MgntDisconnectAP(struct r8192_priv *priv, u8 asRsn)\r\n{\r\nbool bFilterOutNonAssociatedBSSID = false;\r\nu32 RegRCR, Type;\r\nbFilterOutNonAssociatedBSSID = false;\r\nType = bFilterOutNonAssociatedBSSID;\r\nRegRCR = read_nic_dword(priv, RCR);\r\npriv->ReceiveConfig = RegRCR;\r\nif (Type == true)\r\nRegRCR |= (RCR_CBSSID);\r\nelse if (Type == false)\r\nRegRCR &= (~RCR_CBSSID);\r\nwrite_nic_dword(priv, RCR, RegRCR);\r\npriv->ReceiveConfig = RegRCR;\r\nMlmeDisassociateRequest(priv, priv->ieee80211->current_network.bssid, asRsn);\r\npriv->ieee80211->state = IEEE80211_NOLINK;\r\n}\r\nstatic bool MgntDisconnect(struct r8192_priv *priv, u8 asRsn)\r\n{\r\nif( priv->ieee80211->state == IEEE80211_LINKED )\r\n{\r\nif( priv->ieee80211->iw_mode == IW_MODE_ADHOC )\r\n{\r\nMgntDisconnectIBSS(priv);\r\n}\r\nif( priv->ieee80211->iw_mode == IW_MODE_INFRA )\r\n{\r\nMgntDisconnectAP(priv, asRsn);\r\n}\r\n}\r\nreturn true;\r\n}\r\nbool MgntActSet_RF_State(struct r8192_priv *priv, RT_RF_POWER_STATE StateToSet,\r\nRT_RF_CHANGE_SOURCE ChangeSource)\r\n{\r\nbool bActionAllowed = false;\r\nbool bConnectBySSID = false;\r\nRT_RF_POWER_STATE rtState;\r\nRT_TRACE(COMP_POWER, "===>MgntActSet_RF_State(): StateToSet(%d)\n",StateToSet);\r\nspin_lock(&priv->rf_ps_lock);\r\nrtState = priv->eRFPowerState;\r\nswitch(StateToSet)\r\n{\r\ncase eRfOn:\r\npriv->RfOffReason &= (~ChangeSource);\r\nif (!priv->RfOffReason)\r\n{\r\npriv->RfOffReason = 0;\r\nbActionAllowed = true;\r\nif(rtState == eRfOff && ChangeSource >=RF_CHANGE_BY_HW )\r\n{\r\nbConnectBySSID = true;\r\n}\r\n}\r\nelse\r\nRT_TRACE(COMP_POWER, "MgntActSet_RF_State - eRfon reject pMgntInfo->RfOffReason= 0x%x, ChangeSource=0x%X\n", priv->RfOffReason, ChangeSource);\r\nbreak;\r\ncase eRfOff:\r\nif (priv->RfOffReason > RF_CHANGE_BY_IPS)\r\n{\r\nMgntDisconnect(priv, disas_lv_ss);\r\n}\r\npriv->RfOffReason |= ChangeSource;\r\nbActionAllowed = true;\r\nbreak;\r\ncase eRfSleep:\r\npriv->RfOffReason |= ChangeSource;\r\nbActionAllowed = true;\r\nbreak;\r\n}\r\nif (bActionAllowed)\r\n{\r\nRT_TRACE(COMP_POWER, "MgntActSet_RF_State(): Action is allowed.... StateToSet(%d), RfOffReason(%#X)\n", StateToSet, priv->RfOffReason);\r\nSetRFPowerState8190(priv, StateToSet);\r\n}\r\nelse\r\n{\r\nRT_TRACE(COMP_POWER, "MgntActSet_RF_State(): Action is rejected.... StateToSet(%d), ChangeSource(%#X), RfOffReason(%#X)\n", StateToSet, ChangeSource, priv->RfOffReason);\r\n}\r\nspin_unlock(&priv->rf_ps_lock);\r\nRT_TRACE(COMP_POWER, "<===MgntActSet_RF_State()\n");\r\nreturn bActionAllowed;\r\n}
