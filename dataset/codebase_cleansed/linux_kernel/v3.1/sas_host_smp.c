static void sas_host_smp_discover(struct sas_ha_struct *sas_ha, u8 *resp_data,\r\nu8 phy_id)\r\n{\r\nstruct sas_phy *phy;\r\nstruct sas_rphy *rphy;\r\nif (phy_id >= sas_ha->num_phys) {\r\nresp_data[2] = SMP_RESP_NO_PHY;\r\nreturn;\r\n}\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nphy = sas_ha->sas_phy[phy_id]->phy;\r\nresp_data[9] = phy_id;\r\nresp_data[13] = phy->negotiated_linkrate;\r\nmemcpy(resp_data + 16, sas_ha->sas_addr, SAS_ADDR_SIZE);\r\nmemcpy(resp_data + 24, sas_ha->sas_phy[phy_id]->attached_sas_addr,\r\nSAS_ADDR_SIZE);\r\nresp_data[40] = (phy->minimum_linkrate << 4) |\r\nphy->minimum_linkrate_hw;\r\nresp_data[41] = (phy->maximum_linkrate << 4) |\r\nphy->maximum_linkrate_hw;\r\nif (!sas_ha->sas_phy[phy_id]->port ||\r\n!sas_ha->sas_phy[phy_id]->port->port_dev)\r\nreturn;\r\nrphy = sas_ha->sas_phy[phy_id]->port->port_dev->rphy;\r\nresp_data[12] = rphy->identify.device_type << 4;\r\nresp_data[14] = rphy->identify.initiator_port_protocols;\r\nresp_data[15] = rphy->identify.target_port_protocols;\r\n}\r\nstatic void sas_report_phy_sata(struct sas_ha_struct *sas_ha, u8 *resp_data,\r\nu8 phy_id)\r\n{\r\nstruct sas_rphy *rphy;\r\nstruct dev_to_host_fis *fis;\r\nint i;\r\nif (phy_id >= sas_ha->num_phys) {\r\nresp_data[2] = SMP_RESP_NO_PHY;\r\nreturn;\r\n}\r\nresp_data[2] = SMP_RESP_PHY_NO_SATA;\r\nif (!sas_ha->sas_phy[phy_id]->port)\r\nreturn;\r\nrphy = sas_ha->sas_phy[phy_id]->port->port_dev->rphy;\r\nfis = (struct dev_to_host_fis *)\r\nsas_ha->sas_phy[phy_id]->port->port_dev->frame_rcvd;\r\nif (rphy->identify.target_port_protocols != SAS_PROTOCOL_SATA)\r\nreturn;\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nresp_data[9] = phy_id;\r\nmemcpy(resp_data + 16, sas_ha->sas_phy[phy_id]->attached_sas_addr,\r\nSAS_ADDR_SIZE);\r\nif (fis->fis_type != 0x34)\r\nreturn;\r\nfor (i = 0; i < 20; i += 4) {\r\nu8 *dst = resp_data + 24 + i, *src =\r\n&sas_ha->sas_phy[phy_id]->port->port_dev->frame_rcvd[i];\r\ndst[0] = src[3];\r\ndst[1] = src[2];\r\ndst[2] = src[1];\r\ndst[3] = src[0];\r\n}\r\n}\r\nstatic void sas_phy_control(struct sas_ha_struct *sas_ha, u8 phy_id,\r\nu8 phy_op, enum sas_linkrate min,\r\nenum sas_linkrate max, u8 *resp_data)\r\n{\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nstruct sas_phy_linkrates rates;\r\nif (phy_id >= sas_ha->num_phys) {\r\nresp_data[2] = SMP_RESP_NO_PHY;\r\nreturn;\r\n}\r\nswitch (phy_op) {\r\ncase PHY_FUNC_NOP:\r\ncase PHY_FUNC_LINK_RESET:\r\ncase PHY_FUNC_HARD_RESET:\r\ncase PHY_FUNC_DISABLE:\r\ncase PHY_FUNC_CLEAR_ERROR_LOG:\r\ncase PHY_FUNC_CLEAR_AFFIL:\r\ncase PHY_FUNC_TX_SATA_PS_SIGNAL:\r\nbreak;\r\ndefault:\r\nresp_data[2] = SMP_RESP_PHY_UNK_OP;\r\nreturn;\r\n}\r\nrates.minimum_linkrate = min;\r\nrates.maximum_linkrate = max;\r\nif (i->dft->lldd_control_phy(sas_ha->sas_phy[phy_id], phy_op, &rates))\r\nresp_data[2] = SMP_RESP_FUNC_FAILED;\r\nelse\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\n}\r\nint sas_smp_host_handler(struct Scsi_Host *shost, struct request *req,\r\nstruct request *rsp)\r\n{\r\nu8 *req_data = NULL, *resp_data = NULL, *buf;\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nint error = -EINVAL;\r\nif (blk_rq_bytes(req) < 8 || blk_rq_bytes(rsp) < 8)\r\ngoto out;\r\nif (bio_offset(req->bio) + blk_rq_bytes(req) > PAGE_SIZE ||\r\nbio_offset(rsp->bio) + blk_rq_bytes(rsp) > PAGE_SIZE) {\r\nshost_printk(KERN_ERR, shost,\r\n"SMP request/response frame crosses page boundary");\r\ngoto out;\r\n}\r\nreq_data = kzalloc(blk_rq_bytes(req), GFP_KERNEL);\r\nresp_data = kzalloc(max(blk_rq_bytes(rsp), 128U), GFP_KERNEL);\r\nif (!req_data || !resp_data) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nlocal_irq_disable();\r\nbuf = kmap_atomic(bio_page(req->bio), KM_USER0) + bio_offset(req->bio);\r\nmemcpy(req_data, buf, blk_rq_bytes(req));\r\nkunmap_atomic(buf - bio_offset(req->bio), KM_USER0);\r\nlocal_irq_enable();\r\nif (req_data[0] != SMP_REQUEST)\r\ngoto out;\r\nerror = 0;\r\nresp_data[0] = SMP_RESPONSE;\r\nresp_data[1] = req_data[1];\r\nresp_data[2] = SMP_RESP_FUNC_UNK;\r\nswitch (req_data[1]) {\r\ncase SMP_REPORT_GENERAL:\r\nreq->resid_len -= 8;\r\nrsp->resid_len -= 32;\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nresp_data[9] = sas_ha->num_phys;\r\nbreak;\r\ncase SMP_REPORT_MANUF_INFO:\r\nreq->resid_len -= 8;\r\nrsp->resid_len -= 64;\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nmemcpy(resp_data + 12, shost->hostt->name,\r\nSAS_EXPANDER_VENDOR_ID_LEN);\r\nmemcpy(resp_data + 20, "libsas virt phy",\r\nSAS_EXPANDER_PRODUCT_ID_LEN);\r\nbreak;\r\ncase SMP_READ_GPIO_REG:\r\nbreak;\r\ncase SMP_DISCOVER:\r\nreq->resid_len -= 16;\r\nif ((int)req->resid_len < 0) {\r\nreq->resid_len = 0;\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nrsp->resid_len -= 56;\r\nsas_host_smp_discover(sas_ha, resp_data, req_data[9]);\r\nbreak;\r\ncase SMP_REPORT_PHY_ERR_LOG:\r\nbreak;\r\ncase SMP_REPORT_PHY_SATA:\r\nreq->resid_len -= 16;\r\nif ((int)req->resid_len < 0) {\r\nreq->resid_len = 0;\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nrsp->resid_len -= 60;\r\nsas_report_phy_sata(sas_ha, resp_data, req_data[9]);\r\nbreak;\r\ncase SMP_REPORT_ROUTE_INFO:\r\nbreak;\r\ncase SMP_WRITE_GPIO_REG:\r\nbreak;\r\ncase SMP_CONF_ROUTE_INFO:\r\nbreak;\r\ncase SMP_PHY_CONTROL:\r\nreq->resid_len -= 44;\r\nif ((int)req->resid_len < 0) {\r\nreq->resid_len = 0;\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nrsp->resid_len -= 8;\r\nsas_phy_control(sas_ha, req_data[9], req_data[10],\r\nreq_data[32] >> 4, req_data[33] >> 4,\r\nresp_data);\r\nbreak;\r\ncase SMP_PHY_TEST_FUNCTION:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlocal_irq_disable();\r\nbuf = kmap_atomic(bio_page(rsp->bio), KM_USER0) + bio_offset(rsp->bio);\r\nmemcpy(buf, resp_data, blk_rq_bytes(rsp));\r\nflush_kernel_dcache_page(bio_page(rsp->bio));\r\nkunmap_atomic(buf - bio_offset(rsp->bio), KM_USER0);\r\nlocal_irq_enable();\r\nout:\r\nkfree(req_data);\r\nkfree(resp_data);\r\nreturn error;\r\n}
