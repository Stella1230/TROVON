static int reg_r(struct gspca_dev *gspca_dev, u16 reg, u16 length)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint result;\r\nresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n0x00,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nreg,\r\n0x00,\r\ngspca_dev->usb_buf,\r\nlength,\r\n500);\r\nif (unlikely(result < 0 || result != length)) {\r\nerr("Read register failed 0x%02X", reg);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int reg_w(struct gspca_dev *gspca_dev, u16 reg,\r\nconst u8 *buffer, int length)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint result;\r\nmemcpy(gspca_dev->usb_buf, buffer, length);\r\nresult = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nreg,\r\n0x00,\r\ngspca_dev->usb_buf,\r\nlength,\r\n500);\r\nif (unlikely(result < 0 || result != length)) {\r\nerr("Write register failed index 0x%02X", reg);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int reg_w1(struct gspca_dev *gspca_dev, u16 reg, const u8 value)\r\n{\r\nu8 data[1] = {value};\r\nreturn reg_w(gspca_dev, reg, data, 1);\r\n}\r\nstatic int i2c_w(struct gspca_dev *gspca_dev, const u8 *buffer)\r\n{\r\nint i;\r\nreg_w(gspca_dev, 0x10c0, buffer, 8);\r\nfor (i = 0; i < 5; i++) {\r\nreg_r(gspca_dev, 0x10c0, 1);\r\nif (gspca_dev->usb_buf[0] & 0x04) {\r\nif (gspca_dev->usb_buf[0] & 0x08)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nmsleep(1);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int i2c_w1(struct gspca_dev *gspca_dev, u8 reg, u8 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 row[8];\r\nrow[0] = 0x81 | (2 << 4);\r\nrow[1] = sd->i2c_addr;\r\nrow[2] = reg;\r\nrow[3] = val;\r\nrow[4] = 0x00;\r\nrow[5] = 0x00;\r\nrow[6] = 0x00;\r\nrow[7] = 0x10;\r\nreturn i2c_w(gspca_dev, row);\r\n}\r\nstatic int i2c_w2(struct gspca_dev *gspca_dev, u8 reg, u16 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 row[8];\r\nrow[0] = 0x81 | (3 << 4);\r\nrow[1] = sd->i2c_addr;\r\nrow[2] = reg;\r\nrow[3] = (val >> 8) & 0xff;\r\nrow[4] = val & 0xff;\r\nrow[5] = 0x00;\r\nrow[6] = 0x00;\r\nrow[7] = 0x10;\r\nreturn i2c_w(gspca_dev, row);\r\n}\r\nstatic int i2c_r1(struct gspca_dev *gspca_dev, u8 reg, u8 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 row[8];\r\nrow[0] = 0x81 | (1 << 4);\r\nrow[1] = sd->i2c_addr;\r\nrow[2] = reg;\r\nrow[3] = 0;\r\nrow[4] = 0;\r\nrow[5] = 0;\r\nrow[6] = 0;\r\nrow[7] = 0x10;\r\nif (i2c_w(gspca_dev, row) < 0)\r\nreturn -EIO;\r\nrow[0] = 0x81 | (1 << 4) | 0x02;\r\nrow[2] = 0;\r\nif (i2c_w(gspca_dev, row) < 0)\r\nreturn -EIO;\r\nif (reg_r(gspca_dev, 0x10c2, 5) < 0)\r\nreturn -EIO;\r\n*val = gspca_dev->usb_buf[4];\r\nreturn 0;\r\n}\r\nstatic int i2c_r2(struct gspca_dev *gspca_dev, u8 reg, u16 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 row[8];\r\nrow[0] = 0x81 | (1 << 4);\r\nrow[1] = sd->i2c_addr;\r\nrow[2] = reg;\r\nrow[3] = 0;\r\nrow[4] = 0;\r\nrow[5] = 0;\r\nrow[6] = 0;\r\nrow[7] = 0x10;\r\nif (i2c_w(gspca_dev, row) < 0)\r\nreturn -EIO;\r\nrow[0] = 0x81 | (2 << 4) | 0x02;\r\nrow[2] = 0;\r\nif (i2c_w(gspca_dev, row) < 0)\r\nreturn -EIO;\r\nif (reg_r(gspca_dev, 0x10c2, 5) < 0)\r\nreturn -EIO;\r\n*val = (gspca_dev->usb_buf[3] << 8) | gspca_dev->usb_buf[4];\r\nreturn 0;\r\n}\r\nstatic int ov9650_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nu16 id;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (i2c_r2(gspca_dev, 0x1c, &id) < 0)\r\nreturn -EINVAL;\r\nif (id != 0x7fa2) {\r\nerr("sensor id for ov9650 doesn't match (0x%04x)", id);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ov9650_init); i++) {\r\nif (i2c_w1(gspca_dev, ov9650_init[i].reg,\r\nov9650_init[i].val) < 0) {\r\nerr("OV9650 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\nsd->hstart = 1;\r\nsd->vstart = 7;\r\nreturn 0;\r\n}\r\nstatic int ov9655_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nfor (i = 0; i < ARRAY_SIZE(ov9655_init); i++) {\r\nif (i2c_w1(gspca_dev, ov9655_init[i].reg,\r\nov9655_init[i].val) < 0) {\r\nerr("OV9655 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\ngspca_dev->ctrl_dis = (1 << HFLIP_IDX) | (1 << VFLIP_IDX);\r\nsd->hstart = 1;\r\nsd->vstart = 2;\r\nreturn 0;\r\n}\r\nstatic int soi968_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nfor (i = 0; i < ARRAY_SIZE(soi968_init); i++) {\r\nif (i2c_w1(gspca_dev, soi968_init[i].reg,\r\nsoi968_init[i].val) < 0) {\r\nerr("SOI968 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\ngspca_dev->ctrl_dis = (1 << HFLIP_IDX) | (1 << VFLIP_IDX)\r\n| (1 << EXPOSURE_IDX);\r\nsd->hstart = 60;\r\nsd->vstart = 11;\r\nreturn 0;\r\n}\r\nstatic int ov7660_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nfor (i = 0; i < ARRAY_SIZE(ov7660_init); i++) {\r\nif (i2c_w1(gspca_dev, ov7660_init[i].reg,\r\nov7660_init[i].val) < 0) {\r\nerr("OV7660 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\nsd->hstart = 3;\r\nsd->vstart = 3;\r\nreturn 0;\r\n}\r\nstatic int ov7670_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nfor (i = 0; i < ARRAY_SIZE(ov7670_init); i++) {\r\nif (i2c_w1(gspca_dev, ov7670_init[i].reg,\r\nov7670_init[i].val) < 0) {\r\nerr("OV7670 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\ngspca_dev->ctrl_dis = (1 << HFLIP_IDX) | (1 << VFLIP_IDX);\r\nsd->hstart = 0;\r\nsd->vstart = 1;\r\nreturn 0;\r\n}\r\nstatic int mt9v_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nu16 value;\r\nint ret;\r\nsd->i2c_addr = 0x5d;\r\nret = i2c_r2(gspca_dev, 0xff, &value);\r\nif ((ret == 0) && (value == 0x8243)) {\r\nfor (i = 0; i < ARRAY_SIZE(mt9v011_init); i++) {\r\nif (i2c_w2(gspca_dev, mt9v011_init[i].reg,\r\nmt9v011_init[i].val) < 0) {\r\nerr("MT9V011 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\nsd->hstart = 2;\r\nsd->vstart = 2;\r\nsd->sensor = SENSOR_MT9V011;\r\ninfo("MT9V011 sensor detected");\r\nreturn 0;\r\n}\r\nsd->i2c_addr = 0x5c;\r\ni2c_w2(gspca_dev, 0x01, 0x0004);\r\nret = i2c_r2(gspca_dev, 0xff, &value);\r\nif ((ret == 0) && (value == 0x823a)) {\r\nfor (i = 0; i < ARRAY_SIZE(mt9v111_init); i++) {\r\nif (i2c_w2(gspca_dev, mt9v111_init[i].reg,\r\nmt9v111_init[i].val) < 0) {\r\nerr("MT9V111 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\ngspca_dev->ctrl_dis = (1 << EXPOSURE_IDX)\r\n| (1 << AUTOGAIN_IDX)\r\n| (1 << GAIN_IDX);\r\nsd->hstart = 2;\r\nsd->vstart = 2;\r\nsd->sensor = SENSOR_MT9V111;\r\ninfo("MT9V111 sensor detected");\r\nreturn 0;\r\n}\r\nsd->i2c_addr = 0x5d;\r\nret = i2c_w2(gspca_dev, 0xf0, 0x0000);\r\nif (ret < 0) {\r\nsd->i2c_addr = 0x48;\r\ni2c_w2(gspca_dev, 0xf0, 0x0000);\r\n}\r\nret = i2c_r2(gspca_dev, 0x00, &value);\r\nif ((ret == 0) && (value == 0x1229)) {\r\nfor (i = 0; i < ARRAY_SIZE(mt9v112_init); i++) {\r\nif (i2c_w2(gspca_dev, mt9v112_init[i].reg,\r\nmt9v112_init[i].val) < 0) {\r\nerr("MT9V112 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\nsd->hstart = 6;\r\nsd->vstart = 2;\r\nsd->sensor = SENSOR_MT9V112;\r\ninfo("MT9V112 sensor detected");\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int mt9m112_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mt9m112_init); i++) {\r\nif (i2c_w2(gspca_dev, mt9m112_init[i].reg,\r\nmt9m112_init[i].val) < 0) {\r\nerr("MT9M112 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\ngspca_dev->ctrl_dis = (1 << EXPOSURE_IDX) | (1 << AUTOGAIN_IDX)\r\n| (1 << GAIN_IDX);\r\nsd->hstart = 0;\r\nsd->vstart = 2;\r\nreturn 0;\r\n}\r\nstatic int mt9m111_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mt9m111_init); i++) {\r\nif (i2c_w2(gspca_dev, mt9m111_init[i].reg,\r\nmt9m111_init[i].val) < 0) {\r\nerr("MT9M111 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\ngspca_dev->ctrl_dis = (1 << EXPOSURE_IDX) | (1 << AUTOGAIN_IDX)\r\n| (1 << GAIN_IDX);\r\nsd->hstart = 0;\r\nsd->vstart = 2;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nu16 id;\r\nif (i2c_r2(gspca_dev, 0x00, &id) < 0)\r\nreturn -EINVAL;\r\nswitch (id) {\r\ncase 0x8411:\r\ncase 0x8421:\r\ninfo("MT9M001 color sensor detected");\r\nbreak;\r\ncase 0x8431:\r\ninfo("MT9M001 mono sensor detected");\r\nbreak;\r\ndefault:\r\nerr("No MT9M001 chip detected, ID = %x\n", id);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mt9m001_init); i++) {\r\nif (i2c_w2(gspca_dev, mt9m001_init[i].reg,\r\nmt9m001_init[i].val) < 0) {\r\nerr("MT9M001 sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\ngspca_dev->ctrl_dis = (1 << HFLIP_IDX) | (1 << VFLIP_IDX);\r\nsd->hstart = 1;\r\nsd->vstart = 1;\r\nreturn 0;\r\n}\r\nstatic int hv7131r_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nfor (i = 0; i < ARRAY_SIZE(hv7131r_init); i++) {\r\nif (i2c_w1(gspca_dev, hv7131r_init[i].reg,\r\nhv7131r_init[i].val) < 0) {\r\nerr("HV7131R Sensor initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\nsd->hstart = 0;\r\nsd->vstart = 1;\r\nreturn 0;\r\n}\r\nstatic int set_cmatrix(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 hue_coord, hue_index = 180 + sd->hue;\r\nu8 cmatrix[21];\r\nmemset(cmatrix, 0, sizeof cmatrix);\r\ncmatrix[2] = (sd->contrast * 0x25 / 0x100) + 0x26;\r\ncmatrix[0] = 0x13 + (cmatrix[2] - 0x26) * 0x13 / 0x25;\r\ncmatrix[4] = 0x07 + (cmatrix[2] - 0x26) * 0x07 / 0x25;\r\ncmatrix[18] = sd->brightness - 0x80;\r\nhue_coord = (hsv_red_x[hue_index] * sd->saturation) >> 8;\r\ncmatrix[6] = hue_coord;\r\ncmatrix[7] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_red_y[hue_index] * sd->saturation) >> 8;\r\ncmatrix[8] = hue_coord;\r\ncmatrix[9] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_green_x[hue_index] * sd->saturation) >> 8;\r\ncmatrix[10] = hue_coord;\r\ncmatrix[11] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_green_y[hue_index] * sd->saturation) >> 8;\r\ncmatrix[12] = hue_coord;\r\ncmatrix[13] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_blue_x[hue_index] * sd->saturation) >> 8;\r\ncmatrix[14] = hue_coord;\r\ncmatrix[15] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_blue_y[hue_index] * sd->saturation) >> 8;\r\ncmatrix[16] = hue_coord;\r\ncmatrix[17] = (hue_coord >> 8) & 0x0f;\r\nreturn reg_w(gspca_dev, 0x10e1, cmatrix, 21);\r\n}\r\nstatic int set_gamma(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 gamma[17];\r\nu8 gval = sd->gamma * 0xb8 / 0x100;\r\ngamma[0] = 0x0a;\r\ngamma[1] = 0x13 + (gval * (0xcb - 0x13) / 0xb8);\r\ngamma[2] = 0x25 + (gval * (0xee - 0x25) / 0xb8);\r\ngamma[3] = 0x37 + (gval * (0xfa - 0x37) / 0xb8);\r\ngamma[4] = 0x45 + (gval * (0xfc - 0x45) / 0xb8);\r\ngamma[5] = 0x55 + (gval * (0xfb - 0x55) / 0xb8);\r\ngamma[6] = 0x65 + (gval * (0xfc - 0x65) / 0xb8);\r\ngamma[7] = 0x74 + (gval * (0xfd - 0x74) / 0xb8);\r\ngamma[8] = 0x83 + (gval * (0xfe - 0x83) / 0xb8);\r\ngamma[9] = 0x92 + (gval * (0xfc - 0x92) / 0xb8);\r\ngamma[10] = 0xa1 + (gval * (0xfc - 0xa1) / 0xb8);\r\ngamma[11] = 0xb0 + (gval * (0xfc - 0xb0) / 0xb8);\r\ngamma[12] = 0xbf + (gval * (0xfb - 0xbf) / 0xb8);\r\ngamma[13] = 0xce + (gval * (0xfb - 0xce) / 0xb8);\r\ngamma[14] = 0xdf + (gval * (0xfd - 0xdf) / 0xb8);\r\ngamma[15] = 0xea + (gval * (0xf9 - 0xea) / 0xb8);\r\ngamma[16] = 0xf5;\r\nreturn reg_w(gspca_dev, 0x1190, gamma, 17);\r\n}\r\nstatic int set_redblue(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w1(gspca_dev, 0x118c, sd->red);\r\nreg_w1(gspca_dev, 0x118f, sd->blue);\r\nreturn 0;\r\n}\r\nstatic int set_hvflip(struct gspca_dev *gspca_dev)\r\n{\r\nu8 value, tslb, hflip, vflip;\r\nu16 value2;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif ((sd->flags & FLIP_DETECT) && dmi_check_system(flip_dmi_table)) {\r\nhflip = !sd->hflip;\r\nvflip = !sd->vflip;\r\n} else {\r\nhflip = sd->hflip;\r\nvflip = sd->vflip;\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7660:\r\nvalue = 0x01;\r\nif (hflip)\r\nvalue |= 0x20;\r\nif (vflip) {\r\nvalue |= 0x10;\r\nsd->vstart = 2;\r\n} else\r\nsd->vstart = 3;\r\nreg_w1(gspca_dev, 0x1182, sd->vstart);\r\ni2c_w1(gspca_dev, 0x1e, value);\r\nbreak;\r\ncase SENSOR_OV9650:\r\ni2c_r1(gspca_dev, 0x1e, &value);\r\nvalue &= ~0x30;\r\ntslb = 0x01;\r\nif (hflip)\r\nvalue |= 0x20;\r\nif (vflip) {\r\nvalue |= 0x10;\r\ntslb = 0x49;\r\n}\r\ni2c_w1(gspca_dev, 0x1e, value);\r\ni2c_w1(gspca_dev, 0x3a, tslb);\r\nbreak;\r\ncase SENSOR_MT9V111:\r\ncase SENSOR_MT9V011:\r\ni2c_r2(gspca_dev, 0x20, &value2);\r\nvalue2 &= ~0xc0a0;\r\nif (hflip)\r\nvalue2 |= 0x8080;\r\nif (vflip)\r\nvalue2 |= 0x4020;\r\ni2c_w2(gspca_dev, 0x20, value2);\r\nbreak;\r\ncase SENSOR_MT9M112:\r\ncase SENSOR_MT9M111:\r\ncase SENSOR_MT9V112:\r\ni2c_r2(gspca_dev, 0x20, &value2);\r\nvalue2 &= ~0x0003;\r\nif (hflip)\r\nvalue2 |= 0x0002;\r\nif (vflip)\r\nvalue2 |= 0x0001;\r\ni2c_w2(gspca_dev, 0x20, value2);\r\nbreak;\r\ncase SENSOR_HV7131R:\r\ni2c_r1(gspca_dev, 0x01, &value);\r\nvalue &= ~0x03;\r\nif (vflip)\r\nvalue |= 0x01;\r\nif (hflip)\r\nvalue |= 0x02;\r\ni2c_w1(gspca_dev, 0x01, value);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_exposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 exp[8] = {0x81, sd->i2c_addr, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e};\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7660:\r\ncase SENSOR_OV7670:\r\ncase SENSOR_OV9655:\r\ncase SENSOR_OV9650:\r\nexp[0] |= (3 << 4);\r\nexp[2] = 0x2d;\r\nexp[3] = sd->exposure & 0xff;\r\nexp[4] = sd->exposure >> 8;\r\nbreak;\r\ncase SENSOR_MT9M001:\r\ncase SENSOR_MT9V112:\r\ncase SENSOR_MT9V011:\r\nexp[0] |= (3 << 4);\r\nexp[2] = 0x09;\r\nexp[3] = sd->exposure >> 8;\r\nexp[4] = sd->exposure & 0xff;\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nexp[0] |= (4 << 4);\r\nexp[2] = 0x25;\r\nexp[3] = (sd->exposure >> 5) & 0xff;\r\nexp[4] = (sd->exposure << 3) & 0xff;\r\nexp[5] = 0;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ni2c_w(gspca_dev, exp);\r\nreturn 0;\r\n}\r\nstatic int set_gain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 gain[8] = {0x81, sd->i2c_addr, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d};\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7660:\r\ncase SENSOR_OV7670:\r\ncase SENSOR_SOI968:\r\ncase SENSOR_OV9655:\r\ncase SENSOR_OV9650:\r\ngain[0] |= (2 << 4);\r\ngain[3] = ov_gain[sd->gain];\r\nbreak;\r\ncase SENSOR_MT9V011:\r\ngain[0] |= (3 << 4);\r\ngain[2] = 0x35;\r\ngain[3] = micron1_gain[sd->gain] >> 8;\r\ngain[4] = micron1_gain[sd->gain] & 0xff;\r\nbreak;\r\ncase SENSOR_MT9V112:\r\ngain[0] |= (3 << 4);\r\ngain[2] = 0x2f;\r\ngain[3] = micron1_gain[sd->gain] >> 8;\r\ngain[4] = micron1_gain[sd->gain] & 0xff;\r\nbreak;\r\ncase SENSOR_MT9M001:\r\ngain[0] |= (3 << 4);\r\ngain[2] = 0x2f;\r\ngain[3] = micron2_gain[sd->gain] >> 8;\r\ngain[4] = micron2_gain[sd->gain] & 0xff;\r\nbreak;\r\ncase SENSOR_HV7131R:\r\ngain[0] |= (2 << 4);\r\ngain[2] = 0x30;\r\ngain[3] = hv7131r_gain[sd->gain];\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ni2c_w(gspca_dev, gain);\r\nreturn 0;\r\n}\r\nstatic int sd_setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->brightness = val;\r\nif (gspca_dev->streaming)\r\nreturn set_cmatrix(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getbrightness(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->brightness;\r\nreturn 0;\r\n}\r\nstatic int sd_setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->contrast = val;\r\nif (gspca_dev->streaming)\r\nreturn set_cmatrix(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getcontrast(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->contrast;\r\nreturn 0;\r\n}\r\nstatic int sd_setsaturation(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->saturation = val;\r\nif (gspca_dev->streaming)\r\nreturn set_cmatrix(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getsaturation(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->saturation;\r\nreturn 0;\r\n}\r\nstatic int sd_sethue(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->hue = val;\r\nif (gspca_dev->streaming)\r\nreturn set_cmatrix(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_gethue(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->hue;\r\nreturn 0;\r\n}\r\nstatic int sd_setgamma(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->gamma = val;\r\nif (gspca_dev->streaming)\r\nreturn set_gamma(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getgamma(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->gamma;\r\nreturn 0;\r\n}\r\nstatic int sd_setredbalance(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->red = val;\r\nif (gspca_dev->streaming)\r\nreturn set_redblue(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getredbalance(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->red;\r\nreturn 0;\r\n}\r\nstatic int sd_setbluebalance(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->blue = val;\r\nif (gspca_dev->streaming)\r\nreturn set_redblue(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getbluebalance(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->blue;\r\nreturn 0;\r\n}\r\nstatic int sd_sethflip(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->hflip = val;\r\nif (gspca_dev->streaming)\r\nreturn set_hvflip(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_gethflip(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->hflip;\r\nreturn 0;\r\n}\r\nstatic int sd_setvflip(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->vflip = val;\r\nif (gspca_dev->streaming)\r\nreturn set_hvflip(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getvflip(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->vflip;\r\nreturn 0;\r\n}\r\nstatic int sd_setexposure(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->exposure = val;\r\nif (gspca_dev->streaming)\r\nreturn set_exposure(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getexposure(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->exposure;\r\nreturn 0;\r\n}\r\nstatic int sd_setgain(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->gain = val;\r\nif (gspca_dev->streaming)\r\nreturn set_gain(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getgain(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->gain;\r\nreturn 0;\r\n}\r\nstatic int sd_setautoexposure(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->auto_exposure = val;\r\nreturn 0;\r\n}\r\nstatic int sd_getautoexposure(struct gspca_dev *gspca_dev, s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->auto_exposure;\r\nreturn 0;\r\n}\r\nstatic int sd_dbg_g_register(struct gspca_dev *gspca_dev,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_HOST:\r\nif (reg->match.addr != 0)\r\nreturn -EINVAL;\r\nif (reg->reg < 0x1000 || reg->reg > 0x11ff)\r\nreturn -EINVAL;\r\nif (reg_r(gspca_dev, reg->reg, 1) < 0)\r\nreturn -EINVAL;\r\nreg->val = gspca_dev->usb_buf[0];\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nif (reg->match.addr != sd->i2c_addr)\r\nreturn -EINVAL;\r\nif (sd->sensor >= SENSOR_MT9V011 &&\r\nsd->sensor <= SENSOR_MT9M112) {\r\nif (i2c_r2(gspca_dev, reg->reg, (u16 *)&reg->val) < 0)\r\nreturn -EINVAL;\r\n} else {\r\nif (i2c_r1(gspca_dev, reg->reg, (u8 *)&reg->val) < 0)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_dbg_s_register(struct gspca_dev *gspca_dev,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_HOST:\r\nif (reg->match.addr != 0)\r\nreturn -EINVAL;\r\nif (reg->reg < 0x1000 || reg->reg > 0x11ff)\r\nreturn -EINVAL;\r\nif (reg_w1(gspca_dev, reg->reg, reg->val) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nif (reg->match.addr != sd->i2c_addr)\r\nreturn -EINVAL;\r\nif (sd->sensor >= SENSOR_MT9V011 &&\r\nsd->sensor <= SENSOR_MT9M112) {\r\nif (i2c_w2(gspca_dev, reg->reg, reg->val) < 0)\r\nreturn -EINVAL;\r\n} else {\r\nif (i2c_w1(gspca_dev, reg->reg, reg->val) < 0)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_chip_ident(struct gspca_dev *gspca_dev,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (chip->match.type) {\r\ncase V4L2_CHIP_MATCH_HOST:\r\nif (chip->match.addr != 0)\r\nreturn -EINVAL;\r\nchip->revision = 0;\r\nchip->ident = V4L2_IDENT_SN9C20X;\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nif (chip->match.addr != sd->i2c_addr)\r\nreturn -EINVAL;\r\nchip->revision = 0;\r\nchip->ident = i2c_ident[sd->sensor];\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\nsd->sensor = (id->driver_info >> 8) & 0xff;\r\nsd->i2c_addr = id->driver_info & 0xff;\r\nsd->flags = (id->driver_info >> 16) & 0xff;\r\nswitch (sd->sensor) {\r\ncase SENSOR_MT9M112:\r\ncase SENSOR_MT9M111:\r\ncase SENSOR_OV9650:\r\ncase SENSOR_SOI968:\r\ncam->cam_mode = sxga_mode;\r\ncam->nmodes = ARRAY_SIZE(sxga_mode);\r\nbreak;\r\ncase SENSOR_MT9M001:\r\ncam->cam_mode = mono_mode;\r\ncam->nmodes = ARRAY_SIZE(mono_mode);\r\nbreak;\r\ndefault:\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nbreak;\r\n}\r\nsd->old_step = 0;\r\nsd->older_step = 0;\r\nsd->exposure_step = 16;\r\nsd->brightness = BRIGHTNESS_DEFAULT;\r\nsd->contrast = CONTRAST_DEFAULT;\r\nsd->saturation = SATURATION_DEFAULT;\r\nsd->hue = HUE_DEFAULT;\r\nsd->gamma = GAMMA_DEFAULT;\r\nsd->red = RED_DEFAULT;\r\nsd->blue = BLUE_DEFAULT;\r\nsd->hflip = HFLIP_DEFAULT;\r\nsd->vflip = VFLIP_DEFAULT;\r\nsd->exposure = EXPOSURE_DEFAULT;\r\nsd->gain = GAIN_DEFAULT;\r\nsd->auto_exposure = AUTO_EXPOSURE_DEFAULT;\r\nsd->quality = 95;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nu8 value;\r\nu8 i2c_init[9] =\r\n{0x80, sd->i2c_addr, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03};\r\nfor (i = 0; i < ARRAY_SIZE(bridge_init); i++) {\r\nvalue = bridge_init[i][1];\r\nif (reg_w(gspca_dev, bridge_init[i][0], &value, 1) < 0) {\r\nerr("Device initialization failed");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (sd->flags & LED_REVERSE)\r\nreg_w1(gspca_dev, 0x1006, 0x00);\r\nelse\r\nreg_w1(gspca_dev, 0x1006, 0x20);\r\nif (reg_w(gspca_dev, 0x10c0, i2c_init, 9) < 0) {\r\nerr("Device initialization failed");\r\nreturn -ENODEV;\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV9650:\r\nif (ov9650_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\ninfo("OV9650 sensor detected");\r\nbreak;\r\ncase SENSOR_OV9655:\r\nif (ov9655_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\ninfo("OV9655 sensor detected");\r\nbreak;\r\ncase SENSOR_SOI968:\r\nif (soi968_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\ninfo("SOI968 sensor detected");\r\nbreak;\r\ncase SENSOR_OV7660:\r\nif (ov7660_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\ninfo("OV7660 sensor detected");\r\nbreak;\r\ncase SENSOR_OV7670:\r\nif (ov7670_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\ninfo("OV7670 sensor detected");\r\nbreak;\r\ncase SENSOR_MT9VPRB:\r\nif (mt9v_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\nbreak;\r\ncase SENSOR_MT9M111:\r\nif (mt9m111_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\ninfo("MT9M111 sensor detected");\r\nbreak;\r\ncase SENSOR_MT9M112:\r\nif (mt9m112_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\ninfo("MT9M112 sensor detected");\r\nbreak;\r\ncase SENSOR_MT9M001:\r\nif (mt9m001_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nif (hv7131r_init_sensor(gspca_dev) < 0)\r\nreturn -ENODEV;\r\ninfo("HV7131R sensor detected");\r\nbreak;\r\ndefault:\r\ninfo("Unsupported Sensor");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void configure_sensor_output(struct gspca_dev *gspca_dev, int mode)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 value;\r\nswitch (sd->sensor) {\r\ncase SENSOR_SOI968:\r\nif (mode & MODE_SXGA) {\r\ni2c_w1(gspca_dev, 0x17, 0x1d);\r\ni2c_w1(gspca_dev, 0x18, 0xbd);\r\ni2c_w1(gspca_dev, 0x19, 0x01);\r\ni2c_w1(gspca_dev, 0x1a, 0x81);\r\ni2c_w1(gspca_dev, 0x12, 0x00);\r\nsd->hstart = 140;\r\nsd->vstart = 19;\r\n} else {\r\ni2c_w1(gspca_dev, 0x17, 0x13);\r\ni2c_w1(gspca_dev, 0x18, 0x63);\r\ni2c_w1(gspca_dev, 0x19, 0x01);\r\ni2c_w1(gspca_dev, 0x1a, 0x79);\r\ni2c_w1(gspca_dev, 0x12, 0x40);\r\nsd->hstart = 60;\r\nsd->vstart = 11;\r\n}\r\nbreak;\r\ncase SENSOR_OV9650:\r\nif (mode & MODE_SXGA) {\r\ni2c_w1(gspca_dev, 0x17, 0x1b);\r\ni2c_w1(gspca_dev, 0x18, 0xbc);\r\ni2c_w1(gspca_dev, 0x19, 0x01);\r\ni2c_w1(gspca_dev, 0x1a, 0x82);\r\ni2c_r1(gspca_dev, 0x12, &value);\r\ni2c_w1(gspca_dev, 0x12, value & 0x07);\r\n} else {\r\ni2c_w1(gspca_dev, 0x17, 0x24);\r\ni2c_w1(gspca_dev, 0x18, 0xc5);\r\ni2c_w1(gspca_dev, 0x19, 0x00);\r\ni2c_w1(gspca_dev, 0x1a, 0x3c);\r\ni2c_r1(gspca_dev, 0x12, &value);\r\ni2c_w1(gspca_dev, 0x12, (value & 0x7) | 0x40);\r\n}\r\nbreak;\r\ncase SENSOR_MT9M112:\r\ncase SENSOR_MT9M111:\r\nif (mode & MODE_SXGA) {\r\ni2c_w2(gspca_dev, 0xf0, 0x0002);\r\ni2c_w2(gspca_dev, 0xc8, 0x970b);\r\ni2c_w2(gspca_dev, 0xf0, 0x0000);\r\n} else {\r\ni2c_w2(gspca_dev, 0xf0, 0x0002);\r\ni2c_w2(gspca_dev, 0xc8, 0x8000);\r\ni2c_w2(gspca_dev, 0xf0, 0x0000);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint mode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;\r\nint width = gspca_dev->width;\r\nint height = gspca_dev->height;\r\nu8 fmt, scale = 0;\r\njpeg_define(sd->jpeg_hdr, height, width,\r\n0x21);\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\nif (mode & MODE_RAW)\r\nfmt = 0x2d;\r\nelse if (mode & MODE_JPEG)\r\nfmt = 0x2c;\r\nelse\r\nfmt = 0x2f;\r\nswitch (mode & SCALE_MASK) {\r\ncase SCALE_1280x1024:\r\nscale = 0xc0;\r\ninfo("Set 1280x1024");\r\nbreak;\r\ncase SCALE_640x480:\r\nscale = 0x80;\r\ninfo("Set 640x480");\r\nbreak;\r\ncase SCALE_320x240:\r\nscale = 0x90;\r\ninfo("Set 320x240");\r\nbreak;\r\ncase SCALE_160x120:\r\nscale = 0xa0;\r\ninfo("Set 160x120");\r\nbreak;\r\n}\r\nconfigure_sensor_output(gspca_dev, mode);\r\nreg_w(gspca_dev, 0x1100, &sd->jpeg_hdr[JPEG_QT0_OFFSET], 64);\r\nreg_w(gspca_dev, 0x1140, &sd->jpeg_hdr[JPEG_QT1_OFFSET], 64);\r\nreg_w(gspca_dev, 0x10fb, CLR_WIN(width, height), 5);\r\nreg_w(gspca_dev, 0x1180, HW_WIN(mode, sd->hstart, sd->vstart), 6);\r\nreg_w1(gspca_dev, 0x1189, scale);\r\nreg_w1(gspca_dev, 0x10e0, fmt);\r\nset_cmatrix(gspca_dev);\r\nset_gamma(gspca_dev);\r\nset_redblue(gspca_dev);\r\nset_gain(gspca_dev);\r\nset_exposure(gspca_dev);\r\nset_hvflip(gspca_dev);\r\nreg_w1(gspca_dev, 0x1007, 0x20);\r\nreg_r(gspca_dev, 0x1061, 1);\r\nreg_w1(gspca_dev, 0x1061, gspca_dev->usb_buf[0] | 0x02);\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w1(gspca_dev, 0x1007, 0x00);\r\nreg_r(gspca_dev, 0x1061, 1);\r\nreg_w1(gspca_dev, 0x1061, gspca_dev->usb_buf[0] & ~0x02);\r\n}\r\nstatic void do_autoexposure(struct gspca_dev *gspca_dev, u16 avg_lum)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns16 new_exp;\r\nif (avg_lum < MIN_AVG_LUM) {\r\nif (sd->exposure > 0x1770)\r\nreturn;\r\nnew_exp = sd->exposure + sd->exposure_step;\r\nif (new_exp > 0x1770)\r\nnew_exp = 0x1770;\r\nif (new_exp < 0x10)\r\nnew_exp = 0x10;\r\nsd->exposure = new_exp;\r\nset_exposure(gspca_dev);\r\nsd->older_step = sd->old_step;\r\nsd->old_step = 1;\r\nif (sd->old_step ^ sd->older_step)\r\nsd->exposure_step /= 2;\r\nelse\r\nsd->exposure_step += 2;\r\n}\r\nif (avg_lum > MAX_AVG_LUM) {\r\nif (sd->exposure < 0x10)\r\nreturn;\r\nnew_exp = sd->exposure - sd->exposure_step;\r\nif (new_exp > 0x1700)\r\nnew_exp = 0x1770;\r\nif (new_exp < 0x10)\r\nnew_exp = 0x10;\r\nsd->exposure = new_exp;\r\nset_exposure(gspca_dev);\r\nsd->older_step = sd->old_step;\r\nsd->old_step = 0;\r\nif (sd->old_step ^ sd->older_step)\r\nsd->exposure_step /= 2;\r\nelse\r\nsd->exposure_step += 2;\r\n}\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev, u16 avg_lum)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (avg_lum < MIN_AVG_LUM) {\r\nif (sd->gain + 1 <= 28) {\r\nsd->gain++;\r\nset_gain(gspca_dev);\r\n}\r\n}\r\nif (avg_lum > MAX_AVG_LUM) {\r\nif (sd->gain > 0) {\r\nsd->gain--;\r\nset_gain(gspca_dev);\r\n}\r\n}\r\n}\r\nstatic void sd_dqcallback(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint avg_lum;\r\nif (!sd->auto_exposure)\r\nreturn;\r\navg_lum = atomic_read(&sd->avg_lum);\r\nif (sd->sensor == SENSOR_SOI968)\r\ndo_autogain(gspca_dev, avg_lum);\r\nelse\r\ndo_autoexposure(gspca_dev, avg_lum);\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint ret = -EINVAL;\r\nif (!(sd->flags & HAS_NO_BUTTON) && len == 1) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint avg_lum;\r\nstatic u8 frame_header[] =\r\n{0xff, 0xff, 0x00, 0xc4, 0xc4, 0x96};\r\nif (len == 64 && memcmp(data, frame_header, 6) == 0) {\r\navg_lum = ((data[35] >> 2) & 3) |\r\n(data[20] << 2) |\r\n(data[19] << 10);\r\navg_lum += ((data[35] >> 4) & 3) |\r\n(data[22] << 2) |\r\n(data[21] << 10);\r\navg_lum += ((data[35] >> 6) & 3) |\r\n(data[24] << 2) |\r\n(data[23] << 10);\r\navg_lum += (data[36] & 3) |\r\n(data[26] << 2) |\r\n(data[25] << 10);\r\navg_lum += ((data[36] >> 2) & 3) |\r\n(data[28] << 2) |\r\n(data[27] << 10);\r\navg_lum += ((data[36] >> 4) & 3) |\r\n(data[30] << 2) |\r\n(data[29] << 10);\r\navg_lum += ((data[36] >> 6) & 3) |\r\n(data[32] << 2) |\r\n(data[31] << 10);\r\navg_lum += ((data[44] >> 4) & 3) |\r\n(data[34] << 2) |\r\n(data[33] << 10);\r\navg_lum >>= 9;\r\natomic_set(&sd->avg_lum, avg_lum);\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\nreturn;\r\n}\r\nif (gspca_dev->last_packet_type == LAST_PACKET) {\r\nif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv\r\n& MODE_JPEG) {\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata, len);\r\n} else {\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\ndata, len);\r\n}\r\n} else {\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int __init sd_mod_init(void)\r\n{\r\nreturn usb_register(&sd_driver);\r\n}\r\nstatic void __exit sd_mod_exit(void)\r\n{\r\nusb_deregister(&sd_driver);\r\n}
