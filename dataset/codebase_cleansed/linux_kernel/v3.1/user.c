static int snapshot_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct snapshot_data *data;\r\nint error;\r\nmutex_lock(&pm_mutex);\r\nif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\r\nerror = -EBUSY;\r\ngoto Unlock;\r\n}\r\nif ((filp->f_flags & O_ACCMODE) == O_RDWR) {\r\natomic_inc(&snapshot_device_available);\r\nerror = -ENOSYS;\r\ngoto Unlock;\r\n}\r\nif(create_basic_memory_bitmaps()) {\r\natomic_inc(&snapshot_device_available);\r\nerror = -ENOMEM;\r\ngoto Unlock;\r\n}\r\nnonseekable_open(inode, filp);\r\ndata = &snapshot_state;\r\nfilp->private_data = data;\r\nmemset(&data->handle, 0, sizeof(struct snapshot_handle));\r\nif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {\r\ndata->swap = swsusp_resume_device ?\r\nswap_type_of(swsusp_resume_device, 0, NULL) : -1;\r\ndata->mode = O_RDONLY;\r\nerror = pm_notifier_call_chain(PM_HIBERNATION_PREPARE);\r\nif (error)\r\npm_notifier_call_chain(PM_POST_HIBERNATION);\r\n} else {\r\nwait_for_device_probe();\r\nscsi_complete_async_scans();\r\ndata->swap = -1;\r\ndata->mode = O_WRONLY;\r\nerror = pm_notifier_call_chain(PM_RESTORE_PREPARE);\r\nif (error)\r\npm_notifier_call_chain(PM_POST_RESTORE);\r\n}\r\nif (error) {\r\nfree_basic_memory_bitmaps();\r\natomic_inc(&snapshot_device_available);\r\n}\r\ndata->frozen = 0;\r\ndata->ready = 0;\r\ndata->platform_support = 0;\r\nUnlock:\r\nmutex_unlock(&pm_mutex);\r\nreturn error;\r\n}\r\nstatic int snapshot_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct snapshot_data *data;\r\nmutex_lock(&pm_mutex);\r\nswsusp_free();\r\nfree_basic_memory_bitmaps();\r\ndata = filp->private_data;\r\nfree_all_swap_pages(data->swap);\r\nif (data->frozen) {\r\npm_restore_gfp_mask();\r\nthaw_processes();\r\n}\r\npm_notifier_call_chain(data->mode == O_RDONLY ?\r\nPM_POST_HIBERNATION : PM_POST_RESTORE);\r\natomic_inc(&snapshot_device_available);\r\nmutex_unlock(&pm_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t snapshot_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct snapshot_data *data;\r\nssize_t res;\r\nloff_t pg_offp = *offp & ~PAGE_MASK;\r\nmutex_lock(&pm_mutex);\r\ndata = filp->private_data;\r\nif (!data->ready) {\r\nres = -ENODATA;\r\ngoto Unlock;\r\n}\r\nif (!pg_offp) {\r\nres = snapshot_read_next(&data->handle);\r\nif (res <= 0)\r\ngoto Unlock;\r\n} else {\r\nres = PAGE_SIZE - pg_offp;\r\n}\r\nres = simple_read_from_buffer(buf, count, &pg_offp,\r\ndata_of(data->handle), res);\r\nif (res > 0)\r\n*offp += res;\r\nUnlock:\r\nmutex_unlock(&pm_mutex);\r\nreturn res;\r\n}\r\nstatic ssize_t snapshot_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct snapshot_data *data;\r\nssize_t res;\r\nloff_t pg_offp = *offp & ~PAGE_MASK;\r\nmutex_lock(&pm_mutex);\r\ndata = filp->private_data;\r\nif (!pg_offp) {\r\nres = snapshot_write_next(&data->handle);\r\nif (res <= 0)\r\ngoto unlock;\r\n} else {\r\nres = PAGE_SIZE - pg_offp;\r\n}\r\nres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,\r\nbuf, count);\r\nif (res > 0)\r\n*offp += res;\r\nunlock:\r\nmutex_unlock(&pm_mutex);\r\nreturn res;\r\n}\r\nstatic void snapshot_deprecated_ioctl(unsigned int cmd)\r\n{\r\nif (printk_ratelimit())\r\nprintk(KERN_NOTICE "%pf: ioctl '%.8x' is deprecated and will "\r\n"be removed soon, update your suspend-to-disk "\r\n"utilities\n",\r\n__builtin_return_address(0), cmd);\r\n}\r\nstatic long snapshot_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint error = 0;\r\nstruct snapshot_data *data;\r\nloff_t size;\r\nsector_t offset;\r\nif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\r\nreturn -ENOTTY;\r\nif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\r\nreturn -ENOTTY;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (!mutex_trylock(&pm_mutex))\r\nreturn -EBUSY;\r\ndata = filp->private_data;\r\nswitch (cmd) {\r\ncase SNAPSHOT_FREEZE:\r\nif (data->frozen)\r\nbreak;\r\nprintk("Syncing filesystems ... ");\r\nsys_sync();\r\nprintk("done.\n");\r\nerror = usermodehelper_disable();\r\nif (error)\r\nbreak;\r\nerror = freeze_processes();\r\nif (error) {\r\nthaw_processes();\r\nusermodehelper_enable();\r\n}\r\nif (!error)\r\ndata->frozen = 1;\r\nbreak;\r\ncase SNAPSHOT_UNFREEZE:\r\nif (!data->frozen || data->ready)\r\nbreak;\r\npm_restore_gfp_mask();\r\nthaw_processes();\r\nusermodehelper_enable();\r\ndata->frozen = 0;\r\nbreak;\r\ncase SNAPSHOT_ATOMIC_SNAPSHOT:\r\nsnapshot_deprecated_ioctl(cmd);\r\ncase SNAPSHOT_CREATE_IMAGE:\r\nif (data->mode != O_RDONLY || !data->frozen || data->ready) {\r\nerror = -EPERM;\r\nbreak;\r\n}\r\npm_restore_gfp_mask();\r\nerror = hibernation_snapshot(data->platform_support);\r\nif (!error)\r\nerror = put_user(in_suspend, (int __user *)arg);\r\nif (!error)\r\ndata->ready = 1;\r\nbreak;\r\ncase SNAPSHOT_ATOMIC_RESTORE:\r\nsnapshot_write_finalize(&data->handle);\r\nif (data->mode != O_WRONLY || !data->frozen ||\r\n!snapshot_image_loaded(&data->handle)) {\r\nerror = -EPERM;\r\nbreak;\r\n}\r\nerror = hibernation_restore(data->platform_support);\r\nbreak;\r\ncase SNAPSHOT_FREE:\r\nswsusp_free();\r\nmemset(&data->handle, 0, sizeof(struct snapshot_handle));\r\ndata->ready = 0;\r\nbreak;\r\ncase SNAPSHOT_SET_IMAGE_SIZE:\r\nsnapshot_deprecated_ioctl(cmd);\r\ncase SNAPSHOT_PREF_IMAGE_SIZE:\r\nimage_size = arg;\r\nbreak;\r\ncase SNAPSHOT_GET_IMAGE_SIZE:\r\nif (!data->ready) {\r\nerror = -ENODATA;\r\nbreak;\r\n}\r\nsize = snapshot_get_image_size();\r\nsize <<= PAGE_SHIFT;\r\nerror = put_user(size, (loff_t __user *)arg);\r\nbreak;\r\ncase SNAPSHOT_AVAIL_SWAP:\r\nsnapshot_deprecated_ioctl(cmd);\r\ncase SNAPSHOT_AVAIL_SWAP_SIZE:\r\nsize = count_swap_pages(data->swap, 1);\r\nsize <<= PAGE_SHIFT;\r\nerror = put_user(size, (loff_t __user *)arg);\r\nbreak;\r\ncase SNAPSHOT_GET_SWAP_PAGE:\r\nsnapshot_deprecated_ioctl(cmd);\r\ncase SNAPSHOT_ALLOC_SWAP_PAGE:\r\nif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\r\nerror = -ENODEV;\r\nbreak;\r\n}\r\noffset = alloc_swapdev_block(data->swap);\r\nif (offset) {\r\noffset <<= PAGE_SHIFT;\r\nerror = put_user(offset, (loff_t __user *)arg);\r\n} else {\r\nerror = -ENOSPC;\r\n}\r\nbreak;\r\ncase SNAPSHOT_FREE_SWAP_PAGES:\r\nif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\r\nerror = -ENODEV;\r\nbreak;\r\n}\r\nfree_all_swap_pages(data->swap);\r\nbreak;\r\ncase SNAPSHOT_SET_SWAP_FILE:\r\nsnapshot_deprecated_ioctl(cmd);\r\nif (!swsusp_swap_in_use()) {\r\nif (old_decode_dev(arg)) {\r\ndata->swap = swap_type_of(old_decode_dev(arg),\r\n0, NULL);\r\nif (data->swap < 0)\r\nerror = -ENODEV;\r\n} else {\r\ndata->swap = -1;\r\nerror = -EINVAL;\r\n}\r\n} else {\r\nerror = -EPERM;\r\n}\r\nbreak;\r\ncase SNAPSHOT_S2RAM:\r\nif (!data->frozen) {\r\nerror = -EPERM;\r\nbreak;\r\n}\r\nerror = suspend_devices_and_enter(PM_SUSPEND_MEM);\r\ndata->ready = 0;\r\nbreak;\r\ncase SNAPSHOT_PLATFORM_SUPPORT:\r\ndata->platform_support = !!arg;\r\nbreak;\r\ncase SNAPSHOT_POWER_OFF:\r\nif (data->platform_support)\r\nerror = hibernation_platform_enter();\r\nbreak;\r\ncase SNAPSHOT_PMOPS:\r\nsnapshot_deprecated_ioctl(cmd);\r\nerror = -EINVAL;\r\nswitch (arg) {\r\ncase PMOPS_PREPARE:\r\ndata->platform_support = 1;\r\nerror = 0;\r\nbreak;\r\ncase PMOPS_ENTER:\r\nif (data->platform_support)\r\nerror = hibernation_platform_enter();\r\nbreak;\r\ncase PMOPS_FINISH:\r\nif (data->platform_support)\r\nerror = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "SNAPSHOT_PMOPS: invalid argument %ld\n", arg);\r\n}\r\nbreak;\r\ncase SNAPSHOT_SET_SWAP_AREA:\r\nif (swsusp_swap_in_use()) {\r\nerror = -EPERM;\r\n} else {\r\nstruct resume_swap_area swap_area;\r\ndev_t swdev;\r\nerror = copy_from_user(&swap_area, (void __user *)arg,\r\nsizeof(struct resume_swap_area));\r\nif (error) {\r\nerror = -EFAULT;\r\nbreak;\r\n}\r\nswdev = new_decode_dev(swap_area.dev);\r\nif (swdev) {\r\noffset = swap_area.offset;\r\ndata->swap = swap_type_of(swdev, offset, NULL);\r\nif (data->swap < 0)\r\nerror = -ENODEV;\r\n} else {\r\ndata->swap = -1;\r\nerror = -EINVAL;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nerror = -ENOTTY;\r\n}\r\nmutex_unlock(&pm_mutex);\r\nreturn error;\r\n}\r\nstatic int __init snapshot_device_init(void)\r\n{\r\nreturn misc_register(&snapshot_device);\r\n}
