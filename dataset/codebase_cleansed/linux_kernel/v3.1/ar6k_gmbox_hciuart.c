static void HCIUartCleanup(struct gmbox_proto_hci_uart *pProtocol)\r\n{\r\nA_ASSERT(pProtocol != NULL);\r\nA_MUTEX_DELETE(&pProtocol->HCIRxLock);\r\nA_MUTEX_DELETE(&pProtocol->HCITxLock);\r\nkfree(pProtocol);\r\n}\r\nstatic int InitTxCreditState(struct gmbox_proto_hci_uart *pProt)\r\n{\r\nint status;\r\nint credits;\r\nint creditPollCount = CREDIT_POLL_COUNT;\r\nbool gotCredits = false;\r\npProt->CreditsConsumed = 0;\r\ndo {\r\nif (pProt->CreditsMax != 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("HCI: InitTxCreditState - already called! \n"));\r\nA_ASSERT(false);\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nwhile (creditPollCount) {\r\ncredits = 0;\r\nstatus = DevGMboxReadCreditCounter(pProt->pDev, PROC_IO_SYNC, &credits);\r\nif (status) {\r\nbreak;\r\n}\r\nif (!gotCredits && (0 == credits)) {\r\ncreditPollCount--;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("HCI: credit is 0, retrying (%d) \n",creditPollCount));\r\nA_MDELAY(HCI_DELAY_PER_INTERVAL_MS);\r\ncontinue;\r\n} else {\r\ngotCredits = true;\r\n}\r\nif (0 == credits) {\r\nbreak;\r\n}\r\npProt->CreditsMax += credits;\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\nif (0 == creditPollCount) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("** HCI : Failed to get credits! GMBOX Target was not available \n"));\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\nstatus = DevGMboxReadCreditSize(pProt->pDev, &pProt->CreditSize);\r\nif (status) {\r\nbreak;\r\n}\r\n} while (false);\r\nif (!status) {\r\npProt->CreditsAvailable = pProt->CreditsMax;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("HCI : InitTxCreditState - credits avail: %d, size: %d \n",\r\npProt->CreditsAvailable, pProt->CreditSize));\r\n}\r\nreturn status;\r\n}\r\nstatic int CreditsAvailableCallback(void *pContext, int Credits, bool CreditIRQEnabled)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)pContext;\r\nbool enableCreditIrq = false;\r\nbool disableCreditIrq = false;\r\nbool doPendingSends = false;\r\nint status = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+CreditsAvailableCallback (Credits:%d, IRQ:%s) \n",\r\nCredits, CreditIRQEnabled ? "ON" : "OFF"));\r\nLOCK_HCI_TX(pProt);\r\ndo {\r\nif (0 == Credits) {\r\nif (!CreditIRQEnabled) {\r\nenableCreditIrq = true;\r\n}\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("HCI: current credit state, consumed:%d available:%d max:%d seek:%d\n",\r\npProt->CreditsConsumed,\r\npProt->CreditsAvailable,\r\npProt->CreditsMax,\r\npProt->CreditsCurrentSeek));\r\npProt->CreditsAvailable += Credits;\r\nA_ASSERT(pProt->CreditsAvailable <= pProt->CreditsMax);\r\npProt->CreditsConsumed -= Credits;\r\nA_ASSERT(pProt->CreditsConsumed >= 0);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("HCI: new credit state, consumed:%d available:%d max:%d seek:%d\n",\r\npProt->CreditsConsumed,\r\npProt->CreditsAvailable,\r\npProt->CreditsMax,\r\npProt->CreditsCurrentSeek));\r\nif (pProt->CreditsAvailable >= pProt->CreditsCurrentSeek) {\r\npProt->CreditsCurrentSeek = 0;\r\npProt->SendStateFlags &= ~HCI_SEND_WAIT_CREDITS;\r\ndoPendingSends = true;\r\nif (CreditIRQEnabled) {\r\ndisableCreditIrq = true;\r\n}\r\n} else {\r\nif (!CreditIRQEnabled) {\r\nenableCreditIrq = true;\r\n}\r\n}\r\n} while (false);\r\nUNLOCK_HCI_TX(pProt);\r\nif (enableCreditIrq) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,(" Enabling credit count IRQ...\n"));\r\nstatus = DevGMboxIRQAction(pProt->pDev, GMBOX_CREDIT_IRQ_ENABLE, PROC_IO_ASYNC);\r\n} else if (disableCreditIrq) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,(" Disabling credit count IRQ...\n"));\r\nstatus = DevGMboxIRQAction(pProt->pDev, GMBOX_CREDIT_IRQ_DISABLE, PROC_IO_ASYNC);\r\n}\r\nif (doPendingSends) {\r\nHCITrySend(pProt, NULL, false);\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+CreditsAvailableCallback \n"));\r\nreturn status;\r\n}\r\nstatic INLINE void NotifyTransportFailure(struct gmbox_proto_hci_uart *pProt, int status)\r\n{\r\nif (pProt->HCIConfig.TransportFailure != NULL) {\r\npProt->HCIConfig.TransportFailure(pProt->HCIConfig.pContext, status);\r\n}\r\n}\r\nstatic void FailureCallback(void *pContext, int Status)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)pContext;\r\nNotifyTransportFailure(pProt, Status);\r\n}\r\nstatic void StateDumpCallback(void *pContext)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)pContext;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("============ HCIUart State ======================\n"));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("RecvStateFlags : 0x%X \n",pProt->RecvStateFlags));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("SendStateFlags : 0x%X \n",pProt->SendStateFlags));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("WaitBufferType : %d \n",pProt->WaitBufferType));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("SendQueue Depth : %d \n",HTC_PACKET_QUEUE_DEPTH(&pProt->SendQueue)));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("CreditsMax : %d \n",pProt->CreditsMax));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("CreditsConsumed : %d \n",pProt->CreditsConsumed));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("CreditsAvailable : %d \n",pProt->CreditsAvailable));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("==================================================\n"));\r\n}\r\nstatic int HCIUartMessagePending(void *pContext, u8 LookAheadBytes[], int ValidBytes)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)pContext;\r\nint status = 0;\r\nint totalRecvLength = 0;\r\nHCI_TRANSPORT_PACKET_TYPE pktType = HCI_PACKET_INVALID;\r\nbool recvRefillCalled = false;\r\nbool blockRecv = false;\r\nstruct htc_packet *pPacket = NULL;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HCIUartMessagePending Lookahead Bytes:%d \n",ValidBytes));\r\nLOCK_HCI_RX(pProt);\r\ndo {\r\nif (ValidBytes < 3) {\r\nbreak;\r\n}\r\nif ((LookAheadBytes[0] == HCI_UART_ACL_PKT) && (ValidBytes < 5)) {\r\nbreak;\r\n}\r\nswitch (LookAheadBytes[0]) {\r\ncase HCI_UART_EVENT_PKT:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("HCI Event: %d param length: %d \n",\r\nLookAheadBytes[1], LookAheadBytes[2]));\r\ntotalRecvLength = LookAheadBytes[2];\r\ntotalRecvLength += 3;\r\npktType = HCI_EVENT_TYPE;\r\nbreak;\r\ncase HCI_UART_ACL_PKT:\r\ntotalRecvLength = (LookAheadBytes[4] << 8) | LookAheadBytes[3];\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("HCI ACL: conn:0x%X length: %d \n",\r\n((LookAheadBytes[2] & 0xF0) << 8) | LookAheadBytes[1], totalRecvLength));\r\ntotalRecvLength += 5;\r\npktType = HCI_ACL_TYPE;\r\nbreak;\r\ndefault:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("**Invalid HCI packet type: %d \n",LookAheadBytes[0]));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\nif (pProt->HCIConfig.pHCIPktRecvAlloc != NULL) {\r\nUNLOCK_HCI_RX(pProt);\r\npPacket = pProt->HCIConfig.pHCIPktRecvAlloc(pProt->HCIConfig.pContext,\r\npktType,\r\ntotalRecvLength);\r\nLOCK_HCI_RX(pProt);\r\n} else {\r\nstruct htc_packet_queue *pQueue;\r\nif (pktType == HCI_ACL_TYPE) {\r\npQueue = &pProt->HCIACLRecvBuffers;\r\n} else {\r\npQueue = &pProt->HCIEventBuffers;\r\n}\r\nif (HTC_QUEUE_EMPTY(pQueue)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("** HCI pkt type: %d has no buffers available calling allocation handler \n",\r\npktType));\r\nif (pProt->HCIConfig.pHCIPktRecvRefill != NULL) {\r\nrecvRefillCalled = true;\r\nUNLOCK_HCI_RX(pProt);\r\npProt->HCIConfig.pHCIPktRecvRefill(pProt->HCIConfig.pContext,\r\npktType,\r\n0);\r\nLOCK_HCI_RX(pProt);\r\npPacket = HTC_PACKET_DEQUEUE(pQueue);\r\n}\r\n} else {\r\npPacket = HTC_PACKET_DEQUEUE(pQueue);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("HCI pkt type: %d now has %d recv buffers left \n",\r\npktType, HTC_PACKET_QUEUE_DEPTH(pQueue)));\r\n}\r\n}\r\nif (NULL == pPacket) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("** HCI pkt type: %d has no buffers available stopping recv...\n", pktType));\r\npProt->RecvStateFlags |= HCI_RECV_WAIT_BUFFERS;\r\npProt->WaitBufferType = pktType;\r\nblockRecv = true;\r\nbreak;\r\n}\r\nif (totalRecvLength > (int)pPacket->BufferLength) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("** HCI-UART pkt: %d requires %d bytes (%d buffer bytes avail) ! \n",\r\nLookAheadBytes[0], totalRecvLength, pPacket->BufferLength));\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\n} while (false);\r\nUNLOCK_HCI_RX(pProt);\r\ndo {\r\nif (status || (NULL == pPacket)) {\r\nbreak;\r\n}\r\npPacket->Completion = NULL;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("HCI : getting recv packet len:%d hci-uart-type: %s \n",\r\ntotalRecvLength, (LookAheadBytes[0] == HCI_UART_EVENT_PKT) ? "EVENT" : "ACL"));\r\nstatus = DevGMboxRead(pProt->pDev, pPacket, totalRecvLength);\r\nif (status) {\r\nbreak;\r\n}\r\nif (pPacket->pBuffer[0] != LookAheadBytes[0]) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("** HCI buffer does not contain expected packet type: %d ! \n",\r\npPacket->pBuffer[0]));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (pPacket->pBuffer[0] == HCI_UART_EVENT_PKT) {\r\nif ((pPacket->pBuffer[1] != LookAheadBytes[1]) ||\r\n(pPacket->pBuffer[2] != LookAheadBytes[2])) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("** HCI buffer does not match lookahead! \n"));\r\nDebugDumpBytes(LookAheadBytes, 3, "Expected HCI-UART Header");\r\nDebugDumpBytes(pPacket->pBuffer, 3, "** Bad HCI-UART Header");\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\n} else if (pPacket->pBuffer[0] == HCI_UART_ACL_PKT) {\r\nif ((pPacket->pBuffer[1] != LookAheadBytes[1]) ||\r\n(pPacket->pBuffer[2] != LookAheadBytes[2]) ||\r\n(pPacket->pBuffer[3] != LookAheadBytes[3]) ||\r\n(pPacket->pBuffer[4] != LookAheadBytes[4])) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("** HCI buffer does not match lookahead! \n"));\r\nDebugDumpBytes(LookAheadBytes, 5, "Expected HCI-UART Header");\r\nDebugDumpBytes(pPacket->pBuffer, 5, "** Bad HCI-UART Header");\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\n}\r\npPacket->pBuffer++;\r\npPacket->ActualLength = totalRecvLength - 1;\r\npPacket->Status = 0;\r\nDO_HCI_RECV_INDICATION(pProt,pPacket);\r\npPacket = NULL;\r\nif ((pProt->HCIConfig.pHCIPktRecvRefill != NULL) && !recvRefillCalled) {\r\nstruct htc_packet_queue *pQueue;\r\nint watermark;\r\nif (pktType == HCI_ACL_TYPE) {\r\nwatermark = pProt->HCIConfig.ACLRecvBufferWaterMark;\r\npQueue = &pProt->HCIACLRecvBuffers;\r\n} else {\r\nwatermark = pProt->HCIConfig.EventRecvBufferWaterMark;\r\npQueue = &pProt->HCIEventBuffers;\r\n}\r\nif (HTC_PACKET_QUEUE_DEPTH(pQueue) < watermark) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,\r\n("** HCI pkt type: %d watermark hit (%d) current:%d \n",\r\npktType, watermark, HTC_PACKET_QUEUE_DEPTH(pQueue)));\r\npProt->HCIConfig.pHCIPktRecvRefill(pProt->HCIConfig.pContext,\r\npktType,\r\nHTC_PACKET_QUEUE_DEPTH(pQueue));\r\n}\r\n}\r\n} while (false);\r\nif (status || blockRecv) {\r\nDevGMboxIRQAction(pProt->pDev, GMBOX_RECV_IRQ_DISABLE, PROC_IO_SYNC);\r\n}\r\nif (status && (pPacket != NULL)) {\r\nstruct htc_packet_queue queue;\r\nif (A_EPROTO == status) {\r\nDebugDumpBytes(pPacket->pBuffer, totalRecvLength, "Bad HCI-UART Recv packet");\r\n}\r\nHTC_PACKET_RESET_RX(pPacket);\r\nINIT_HTC_PACKET_QUEUE_AND_ADD(&queue,pPacket);\r\nHCI_TransportAddReceivePkts(pProt,&queue);\r\nNotifyTransportFailure(pProt,status);\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HCIUartMessagePending \n"));\r\nreturn status;\r\n}\r\nstatic void HCISendPacketCompletion(void *Context, struct htc_packet *pPacket)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)Context;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("+HCISendPacketCompletion (pPacket:0x%lX) \n",(unsigned long)pPacket));\r\nif (pPacket->Status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" Send Packet (0x%lX) failed: %d , len:%d \n",\r\n(unsigned long)pPacket, pPacket->Status, pPacket->ActualLength));\r\n}\r\nDO_HCI_SEND_INDICATION(pProt,pPacket);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("+HCISendPacketCompletion \n"));\r\n}\r\nstatic int SeekCreditsSynch(struct gmbox_proto_hci_uart *pProt)\r\n{\r\nint status = 0;\r\nint credits;\r\nint retry = 100;\r\nwhile (true) {\r\ncredits = 0;\r\nstatus = DevGMboxReadCreditCounter(pProt->pDev, PROC_IO_SYNC, &credits);\r\nif (status) {\r\nbreak;\r\n}\r\nLOCK_HCI_TX(pProt);\r\npProt->CreditsAvailable += credits;\r\npProt->CreditsConsumed -= credits;\r\nif (pProt->CreditsAvailable >= pProt->CreditsCurrentSeek) {\r\npProt->CreditsCurrentSeek = 0;\r\nUNLOCK_HCI_TX(pProt);\r\nbreak;\r\n}\r\nUNLOCK_HCI_TX(pProt);\r\nretry--;\r\nif (0 == retry) {\r\nstatus = A_EBUSY;\r\nbreak;\r\n}\r\nA_MDELAY(20);\r\n}\r\nreturn status;\r\n}\r\nstatic int HCITrySend(struct gmbox_proto_hci_uart *pProt, struct htc_packet *pPacket, bool Synchronous)\r\n{\r\nint status = 0;\r\nint transferLength;\r\nint creditsRequired, remainder;\r\nu8 hciUartType;\r\nbool synchSendComplete = false;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("+HCITrySend (pPacket:0x%lX) %s \n",(unsigned long)pPacket,\r\nSynchronous ? "SYNC" :"ASYNC"));\r\nLOCK_HCI_TX(pProt);\r\npProt->SendProcessCount++;\r\ndo {\r\nif (pProt->HCIStopped) {\r\nstatus = A_ECANCELED;\r\nbreak;\r\n}\r\nif (pPacket != NULL) {\r\nif (Synchronous) {\r\nif (!HTC_QUEUE_EMPTY(&pProt->SendQueue)) {\r\nstatus = A_EBUSY;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nif (pProt->SendProcessCount > 1) {\r\nstatus = A_EBUSY;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nHTC_PACKET_ENQUEUE(&pProt->SendQueue,pPacket);\r\n} else {\r\nif ((pProt->HCIConfig.MaxSendQueueDepth > 0) &&\r\n((HTC_PACKET_QUEUE_DEPTH(&pProt->SendQueue) + 1) >= pProt->HCIConfig.MaxSendQueueDepth)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("HCI Send queue is full, Depth:%d, Max:%d \n",\r\nHTC_PACKET_QUEUE_DEPTH(&pProt->SendQueue),\r\npProt->HCIConfig.MaxSendQueueDepth));\r\nif (pProt->HCIConfig.pHCISendFull != NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,\r\n("HCI : Calling driver's send full callback.... \n"));\r\nif (pProt->HCIConfig.pHCISendFull(pProt->HCIConfig.pContext,\r\npPacket) == HCI_SEND_FULL_DROP) {\r\nstatus = A_NO_RESOURCE;\r\nbreak;\r\n}\r\n}\r\n}\r\nHTC_PACKET_ENQUEUE(&pProt->SendQueue,pPacket);\r\n}\r\n}\r\nif (pProt->SendStateFlags & HCI_SEND_WAIT_CREDITS) {\r\nbreak;\r\n}\r\nif (pProt->SendProcessCount > 1) {\r\nbreak;\r\n}\r\nwhile (!HTC_QUEUE_EMPTY(&pProt->SendQueue)) {\r\npPacket = HTC_PACKET_DEQUEUE(&pProt->SendQueue);\r\nswitch (HCI_GET_PACKET_TYPE(pPacket)) {\r\ncase HCI_COMMAND_TYPE:\r\nhciUartType = HCI_UART_COMMAND_PKT;\r\nbreak;\r\ncase HCI_ACL_TYPE:\r\nhciUartType = HCI_UART_ACL_PKT;\r\nbreak;\r\ndefault:\r\nstatus = A_EINVAL;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("HCI: Got head packet:0x%lX , Type:%d Length: %d Remaining Queue Depth: %d\n",\r\n(unsigned long)pPacket, HCI_GET_PACKET_TYPE(pPacket), pPacket->ActualLength,\r\nHTC_PACKET_QUEUE_DEPTH(&pProt->SendQueue)));\r\ntransferLength = 1;\r\ntransferLength += pPacket->ActualLength;\r\ntransferLength = DEV_CALC_SEND_PADDED_LEN(pProt->pDev, transferLength);\r\ncreditsRequired = transferLength / pProt->CreditSize;\r\nremainder = transferLength % pProt->CreditSize;\r\nif (remainder) {\r\ncreditsRequired++;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("HCI: Creds Required:%d Got:%d\n",\r\ncreditsRequired, pProt->CreditsAvailable));\r\nif (creditsRequired > pProt->CreditsAvailable) {\r\nif (Synchronous) {\r\npProt->CreditsCurrentSeek = creditsRequired;\r\nUNLOCK_HCI_TX(pProt);\r\nstatus = SeekCreditsSynch(pProt);\r\nLOCK_HCI_TX(pProt);\r\nif (status) {\r\nbreak;\r\n}\r\n} else {\r\nHTC_PACKET_ENQUEUE_TO_HEAD(&pProt->SendQueue,pPacket);\r\npProt->SendStateFlags |= HCI_SEND_WAIT_CREDITS;\r\npProt->CreditsCurrentSeek = creditsRequired;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("HCI: packet:0x%lX placed back in queue. head packet needs: %d credits \n",\r\n(unsigned long)pPacket, pProt->CreditsCurrentSeek));\r\npPacket = NULL;\r\nUNLOCK_HCI_TX(pProt);\r\nDevGMboxReadCreditCounter(pProt->pDev, PROC_IO_ASYNC, NULL);\r\nLOCK_HCI_TX(pProt);\r\nbreak;\r\n}\r\n}\r\npPacket->pBuffer--;\r\npPacket->pBuffer[0] = hciUartType;\r\npProt->CreditsAvailable -= creditsRequired;\r\npProt->CreditsConsumed += creditsRequired;\r\nA_ASSERT(pProt->CreditsConsumed <= pProt->CreditsMax);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("HCI: new credit state: consumed:%d available:%d max:%d\n",\r\npProt->CreditsConsumed, pProt->CreditsAvailable, pProt->CreditsMax));\r\nUNLOCK_HCI_TX(pProt);\r\nif (Synchronous) {\r\npPacket->Completion = NULL;\r\npPacket->pContext = NULL;\r\n} else {\r\npPacket->Completion = HCISendPacketCompletion;\r\npPacket->pContext = pProt;\r\n}\r\nstatus = DevGMboxWrite(pProt->pDev,pPacket,transferLength);\r\nif (Synchronous) {\r\nsynchSendComplete = true;\r\n} else {\r\npPacket = NULL;\r\n}\r\nLOCK_HCI_TX(pProt);\r\n}\r\n} while (false);\r\npProt->SendProcessCount--;\r\nA_ASSERT(pProt->SendProcessCount >= 0);\r\nUNLOCK_HCI_TX(pProt);\r\nif (Synchronous) {\r\nA_ASSERT(pPacket != NULL);\r\nif (!status && (!synchSendComplete)) {\r\nstatus = A_EBUSY;\r\nA_ASSERT(false);\r\nLOCK_HCI_TX(pProt);\r\nif (pPacket->ListLink.pNext != NULL) {\r\nHTC_PACKET_REMOVE(&pProt->SendQueue,pPacket);\r\n}\r\nUNLOCK_HCI_TX(pProt);\r\n}\r\n} else {\r\nif (status && (pPacket != NULL)) {\r\npPacket->Status = status;\r\nDO_HCI_SEND_INDICATION(pProt,pPacket);\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_SEND,("-HCITrySend: \n"));\r\nreturn status;\r\n}\r\nstatic void FlushSendQueue(struct gmbox_proto_hci_uart *pProt)\r\n{\r\nstruct htc_packet *pPacket;\r\nstruct htc_packet_queue discardQueue;\r\nINIT_HTC_PACKET_QUEUE(&discardQueue);\r\nLOCK_HCI_TX(pProt);\r\nif (!HTC_QUEUE_EMPTY(&pProt->SendQueue)) {\r\nHTC_PACKET_QUEUE_TRANSFER_TO_TAIL(&discardQueue,&pProt->SendQueue);\r\n}\r\nUNLOCK_HCI_TX(pProt);\r\nwhile (!HTC_QUEUE_EMPTY(&discardQueue)) {\r\npPacket = HTC_PACKET_DEQUEUE(&discardQueue);\r\npPacket->Status = A_ECANCELED;\r\nDO_HCI_SEND_INDICATION(pProt,pPacket);\r\n}\r\n}\r\nstatic void FlushRecvBuffers(struct gmbox_proto_hci_uart *pProt)\r\n{\r\nstruct htc_packet_queue discardQueue;\r\nstruct htc_packet *pPacket;\r\nINIT_HTC_PACKET_QUEUE(&discardQueue);\r\nLOCK_HCI_RX(pProt);\r\nif (!HTC_QUEUE_EMPTY(&pProt->HCIACLRecvBuffers)) {\r\nHTC_PACKET_QUEUE_TRANSFER_TO_TAIL(&discardQueue,&pProt->HCIACLRecvBuffers);\r\n}\r\nif (!HTC_QUEUE_EMPTY(&pProt->HCIEventBuffers)) {\r\nHTC_PACKET_QUEUE_TRANSFER_TO_TAIL(&discardQueue,&pProt->HCIEventBuffers);\r\n}\r\nUNLOCK_HCI_RX(pProt);\r\nwhile (!HTC_QUEUE_EMPTY(&discardQueue)) {\r\npPacket = HTC_PACKET_DEQUEUE(&discardQueue);\r\npPacket->Status = A_ECANCELED;\r\nDO_HCI_RECV_INDICATION(pProt,pPacket);\r\n}\r\n}\r\nint GMboxProtocolInstall(struct ar6k_device *pDev)\r\n{\r\nint status = 0;\r\nstruct gmbox_proto_hci_uart *pProtocol = NULL;\r\ndo {\r\npProtocol = A_MALLOC(sizeof(struct gmbox_proto_hci_uart));\r\nif (NULL == pProtocol) {\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\nA_MEMZERO(pProtocol, sizeof(*pProtocol));\r\npProtocol->pDev = pDev;\r\nINIT_HTC_PACKET_QUEUE(&pProtocol->SendQueue);\r\nINIT_HTC_PACKET_QUEUE(&pProtocol->HCIACLRecvBuffers);\r\nINIT_HTC_PACKET_QUEUE(&pProtocol->HCIEventBuffers);\r\nA_MUTEX_INIT(&pProtocol->HCIRxLock);\r\nA_MUTEX_INIT(&pProtocol->HCITxLock);\r\n} while (false);\r\nif (!status) {\r\nLOCK_AR6K(pDev);\r\nDEV_GMBOX_SET_PROTOCOL(pDev,\r\nHCIUartMessagePending,\r\nCreditsAvailableCallback,\r\nFailureCallback,\r\nStateDumpCallback,\r\npProtocol);\r\nUNLOCK_AR6K(pDev);\r\n} else {\r\nif (pProtocol != NULL) {\r\nHCIUartCleanup(pProtocol);\r\n}\r\n}\r\nreturn status;\r\n}\r\nvoid GMboxProtocolUninstall(struct ar6k_device *pDev)\r\n{\r\nstruct gmbox_proto_hci_uart *pProtocol = (struct gmbox_proto_hci_uart *)DEV_GMBOX_GET_PROTOCOL(pDev);\r\nif (pProtocol != NULL) {\r\nif (pProtocol->HCIAttached) {\r\nA_ASSERT(pProtocol->HCIConfig.TransportRemoved != NULL);\r\npProtocol->HCIConfig.TransportRemoved(pProtocol->HCIConfig.pContext);\r\npProtocol->HCIAttached = false;\r\n}\r\nHCIUartCleanup(pProtocol);\r\nDEV_GMBOX_SET_PROTOCOL(pDev,NULL,NULL,NULL,NULL,NULL);\r\n}\r\n}\r\nstatic int NotifyTransportReady(struct gmbox_proto_hci_uart *pProt)\r\n{\r\nstruct hci_transport_properties props;\r\nint status = 0;\r\ndo {\r\nA_MEMZERO(&props,sizeof(props));\r\nprops.HeadRoom = 1;\r\nprops.TailRoom = 0;\r\nprops.IOBlockPad = pProt->pDev->BlockSize;\r\nif (pProt->HCIAttached) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("HCI: notifying attached client to transport... \n"));\r\nA_ASSERT(pProt->HCIConfig.TransportReady != NULL);\r\nstatus = pProt->HCIConfig.TransportReady(pProt,\r\n&props,\r\npProt->HCIConfig.pContext);\r\n}\r\n} while (false);\r\nreturn status;\r\n}\r\nHCI_TRANSPORT_HANDLE HCI_TransportAttach(void *HTCHandle, struct hci_transport_config_info *pInfo)\r\n{\r\nstruct gmbox_proto_hci_uart *pProtocol = NULL;\r\nstruct ar6k_device *pDev;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("+HCI_TransportAttach \n"));\r\npDev = HTCGetAR6KDevice(HTCHandle);\r\nLOCK_AR6K(pDev);\r\ndo {\r\npProtocol = (struct gmbox_proto_hci_uart *)DEV_GMBOX_GET_PROTOCOL(pDev);\r\nif (NULL == pProtocol) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("GMBOX protocol not installed! \n"));\r\nbreak;\r\n}\r\nif (pProtocol->HCIAttached) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("GMBOX protocol already attached! \n"));\r\nbreak;\r\n}\r\nmemcpy(&pProtocol->HCIConfig, pInfo, sizeof(struct hci_transport_config_info));\r\nA_ASSERT(pProtocol->HCIConfig.pHCIPktRecv != NULL);\r\nA_ASSERT(pProtocol->HCIConfig.pHCISendComplete != NULL);\r\npProtocol->HCIAttached = true;\r\n} while (false);\r\nUNLOCK_AR6K(pDev);\r\nif (pProtocol != NULL) {\r\nNotifyTransportReady(pProtocol);\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("-HCI_TransportAttach (0x%lX) \n",(unsigned long)pProtocol));\r\nreturn (HCI_TRANSPORT_HANDLE)pProtocol;\r\n}\r\nvoid HCI_TransportDetach(HCI_TRANSPORT_HANDLE HciTrans)\r\n{\r\nstruct gmbox_proto_hci_uart *pProtocol = (struct gmbox_proto_hci_uart *)HciTrans;\r\nstruct ar6k_device *pDev = pProtocol->pDev;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("+HCI_TransportDetach \n"));\r\nLOCK_AR6K(pDev);\r\nif (!pProtocol->HCIAttached) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("GMBOX protocol not attached! \n"));\r\nUNLOCK_AR6K(pDev);\r\nreturn;\r\n}\r\npProtocol->HCIAttached = false;\r\nUNLOCK_AR6K(pDev);\r\nHCI_TransportStop(HciTrans);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("-HCI_TransportAttach \n"));\r\n}\r\nint HCI_TransportAddReceivePkts(HCI_TRANSPORT_HANDLE HciTrans, struct htc_packet_queue *pQueue)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)HciTrans;\r\nint status = 0;\r\nbool unblockRecv = false;\r\nstruct htc_packet *pPacket;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HCI_TransportAddReceivePkt \n"));\r\nLOCK_HCI_RX(pProt);\r\ndo {\r\nif (pProt->HCIStopped) {\r\nstatus = A_ECANCELED;\r\nbreak;\r\n}\r\npPacket = HTC_GET_PKT_AT_HEAD(pQueue);\r\nif (NULL == pPacket) {\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,(" HCI recv packet added, type :%d, len:%d num:%d \n",\r\nHCI_GET_PACKET_TYPE(pPacket), pPacket->BufferLength, HTC_PACKET_QUEUE_DEPTH(pQueue)));\r\nif (HCI_GET_PACKET_TYPE(pPacket) == HCI_EVENT_TYPE) {\r\nHTC_PACKET_QUEUE_TRANSFER_TO_TAIL(&pProt->HCIEventBuffers, pQueue);\r\n} else if (HCI_GET_PACKET_TYPE(pPacket) == HCI_ACL_TYPE) {\r\nHTC_PACKET_QUEUE_TRANSFER_TO_TAIL(&pProt->HCIACLRecvBuffers, pQueue);\r\n} else {\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nif (pProt->RecvStateFlags & HCI_RECV_WAIT_BUFFERS) {\r\nif (pProt->WaitBufferType == HCI_GET_PACKET_TYPE(pPacket)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,(" HCI recv was blocked on packet type :%d, unblocking.. \n",\r\npProt->WaitBufferType));\r\npProt->RecvStateFlags &= ~HCI_RECV_WAIT_BUFFERS;\r\npProt->WaitBufferType = HCI_PACKET_INVALID;\r\nunblockRecv = true;\r\n}\r\n}\r\n} while (false);\r\nUNLOCK_HCI_RX(pProt);\r\nif (status) {\r\nwhile (!HTC_QUEUE_EMPTY(pQueue)) {\r\npPacket = HTC_PACKET_DEQUEUE(pQueue);\r\npPacket->Status = A_ECANCELED;\r\nDO_HCI_RECV_INDICATION(pProt,pPacket);\r\n}\r\n}\r\nif (unblockRecv) {\r\nDevGMboxIRQAction(pProt->pDev, GMBOX_RECV_IRQ_ENABLE, PROC_IO_ASYNC);\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HCI_TransportAddReceivePkt \n"));\r\nreturn 0;\r\n}\r\nint HCI_TransportSendPkt(HCI_TRANSPORT_HANDLE HciTrans, struct htc_packet *pPacket, bool Synchronous)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)HciTrans;\r\nreturn HCITrySend(pProt,pPacket,Synchronous);\r\n}\r\nvoid HCI_TransportStop(HCI_TRANSPORT_HANDLE HciTrans)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)HciTrans;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("+HCI_TransportStop \n"));\r\nLOCK_AR6K(pProt->pDev);\r\nif (pProt->HCIStopped) {\r\nUNLOCK_AR6K(pProt->pDev);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("-HCI_TransportStop \n"));\r\nreturn;\r\n}\r\npProt->HCIStopped = true;\r\nUNLOCK_AR6K(pProt->pDev);\r\nDevGMboxIRQAction(pProt->pDev, GMBOX_DISABLE_ALL, PROC_IO_SYNC);\r\nFlushSendQueue(pProt);\r\nFlushRecvBuffers(pProt);\r\nDevGMboxSetTargetInterrupt(pProt->pDev, MBOX_SIG_HCI_BRIDGE_BT_OFF, BTOFF_TIMEOUT_MS);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("-HCI_TransportStop \n"));\r\n}\r\nint HCI_TransportStart(HCI_TRANSPORT_HANDLE HciTrans)\r\n{\r\nint status;\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)HciTrans;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("+HCI_TransportStart \n"));\r\npProt->HCIStopped = true;\r\ndo {\r\nstatus = InitTxCreditState(pProt);\r\nif (status) {\r\nbreak;\r\n}\r\nstatus = DevGMboxIRQAction(pProt->pDev, GMBOX_ERRORS_IRQ_ENABLE, PROC_IO_SYNC);\r\nif (status) {\r\nbreak;\r\n}\r\nstatus = DevGMboxIRQAction(pProt->pDev, GMBOX_RECV_IRQ_ENABLE, PROC_IO_SYNC);\r\nif (status) {\r\nbreak;\r\n}\r\nstatus = DevGMboxSetTargetInterrupt(pProt->pDev, MBOX_SIG_HCI_BRIDGE_BT_ON, BTON_TIMEOUT_MS);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("HCI_TransportStart : Failed to trigger BT ON \n"));\r\nbreak;\r\n}\r\npProt->HCIStopped = false;\r\n} while (false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,("-HCI_TransportStart \n"));\r\nreturn status;\r\n}\r\nint HCI_TransportEnableDisableAsyncRecv(HCI_TRANSPORT_HANDLE HciTrans, bool Enable)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)HciTrans;\r\nreturn DevGMboxIRQAction(pProt->pDev,\r\nEnable ? GMBOX_RECV_IRQ_ENABLE : GMBOX_RECV_IRQ_DISABLE,\r\nPROC_IO_SYNC);\r\n}\r\nint HCI_TransportRecvHCIEventSync(HCI_TRANSPORT_HANDLE HciTrans,\r\nstruct htc_packet *pPacket,\r\nint MaxPollMS)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)HciTrans;\r\nint status = 0;\r\nu8 lookAhead[8];\r\nint bytes;\r\nint totalRecvLength;\r\nMaxPollMS = MaxPollMS / 16;\r\nif (MaxPollMS < 2) {\r\nMaxPollMS = 2;\r\n}\r\nwhile (MaxPollMS) {\r\nbytes = sizeof(lookAhead);\r\nstatus = DevGMboxRecvLookAheadPeek(pProt->pDev,lookAhead,&bytes);\r\nif (status) {\r\nbreak;\r\n}\r\nif (bytes < 3) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("HCI recv poll got bytes: %d, retry : %d \n",\r\nbytes, MaxPollMS));\r\nA_MDELAY(16);\r\nMaxPollMS--;\r\ncontinue;\r\n}\r\ntotalRecvLength = 0;\r\nswitch (lookAhead[0]) {\r\ncase HCI_UART_EVENT_PKT:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_RECV,("HCI Event: %d param length: %d \n",\r\nlookAhead[1], lookAhead[2]));\r\ntotalRecvLength = lookAhead[2];\r\ntotalRecvLength += 3;\r\nbreak;\r\ndefault:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("**Invalid HCI packet type: %d \n",lookAhead[0]));\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\npPacket->Completion = NULL;\r\nstatus = DevGMboxRead(pProt->pDev,pPacket,totalRecvLength);\r\nif (status) {\r\nbreak;\r\n}\r\npPacket->pBuffer++;\r\npPacket->ActualLength = totalRecvLength - 1;\r\npPacket->Status = 0;\r\nbreak;\r\n}\r\nif (MaxPollMS == 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("HCI recv poll timeout! \n"));\r\nstatus = A_ERROR;\r\n}\r\nreturn status;\r\n}\r\nint HCI_TransportSetBaudRate(HCI_TRANSPORT_HANDLE HciTrans, u32 Baud)\r\n{\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)HciTrans;\r\nstruct hif_device *pHIFDevice = (struct hif_device *)(pProt->pDev->HIFDevice);\r\nu32 scaledBaud, scratchAddr;\r\nint status = 0;\r\nscratchAddr = MBOX_BASE_ADDRESS | (LOCAL_SCRATCH_ADDRESS + 4 * LSB_SCRATCH_IDX);\r\nscaledBaud = (Baud / 100) & LOCAL_SCRATCH_VALUE_MASK;\r\nstatus = ar6000_WriteRegDiag(pHIFDevice, &scratchAddr, &scaledBaud);\r\nscratchAddr = MBOX_BASE_ADDRESS | (LOCAL_SCRATCH_ADDRESS + 4 * MSB_SCRATCH_IDX);\r\nscaledBaud = ((Baud / 100) >> (LOCAL_SCRATCH_VALUE_MSB+1)) & LOCAL_SCRATCH_VALUE_MASK;\r\nstatus |= ar6000_WriteRegDiag(pHIFDevice, &scratchAddr, &scaledBaud);\r\nif (0 != status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to set up baud rate in scratch register!"));\r\nreturn status;\r\n}\r\nstatus = DevGMboxSetTargetInterrupt(pProt->pDev, MBOX_SIG_HCI_BRIDGE_BAUD_SET, BAUD_TIMEOUT_MS);\r\nif (0 != status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to tell target to change baud rate!"));\r\n}\r\nreturn status;\r\n}\r\nint HCI_TransportEnablePowerMgmt(HCI_TRANSPORT_HANDLE HciTrans, bool Enable)\r\n{\r\nint status;\r\nstruct gmbox_proto_hci_uart *pProt = (struct gmbox_proto_hci_uart *)HciTrans;\r\nif (Enable) {\r\nstatus = DevGMboxSetTargetInterrupt(pProt->pDev, MBOX_SIG_HCI_BRIDGE_PWR_SAV_ON, BTPWRSAV_TIMEOUT_MS);\r\n} else {\r\nstatus = DevGMboxSetTargetInterrupt(pProt->pDev, MBOX_SIG_HCI_BRIDGE_PWR_SAV_OFF, BTPWRSAV_TIMEOUT_MS);\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to enable/disable HCI power management!\n"));\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("HCI power management enabled/disabled!\n"));\r\n}\r\nreturn status;\r\n}
