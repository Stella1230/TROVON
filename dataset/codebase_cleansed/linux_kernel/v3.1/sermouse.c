static void sermouse_process_msc(struct sermouse *sermouse, signed char data)\r\n{\r\nstruct input_dev *dev = sermouse->dev;\r\nsigned char *buf = sermouse->buf;\r\nswitch (sermouse->count) {\r\ncase 0:\r\nif ((data & 0xf8) != 0x80)\r\nreturn;\r\ninput_report_key(dev, BTN_LEFT, !(data & 4));\r\ninput_report_key(dev, BTN_RIGHT, !(data & 1));\r\ninput_report_key(dev, BTN_MIDDLE, !(data & 2));\r\nbreak;\r\ncase 1:\r\ncase 3:\r\ninput_report_rel(dev, REL_X, data / 2);\r\ninput_report_rel(dev, REL_Y, -buf[1]);\r\nbuf[0] = data - data / 2;\r\nbreak;\r\ncase 2:\r\ncase 4:\r\ninput_report_rel(dev, REL_X, buf[0]);\r\ninput_report_rel(dev, REL_Y, buf[1] - data);\r\nbuf[1] = data / 2;\r\nbreak;\r\n}\r\ninput_sync(dev);\r\nif (++sermouse->count == 5)\r\nsermouse->count = 0;\r\n}\r\nstatic void sermouse_process_ms(struct sermouse *sermouse, signed char data)\r\n{\r\nstruct input_dev *dev = sermouse->dev;\r\nsigned char *buf = sermouse->buf;\r\nif (data & 0x40)\r\nsermouse->count = 0;\r\nelse if (sermouse->count == 0)\r\nreturn;\r\nswitch (sermouse->count) {\r\ncase 0:\r\nbuf[1] = data;\r\ninput_report_key(dev, BTN_LEFT, (data >> 5) & 1);\r\ninput_report_key(dev, BTN_RIGHT, (data >> 4) & 1);\r\nbreak;\r\ncase 1:\r\nbuf[2] = data;\r\ndata = (signed char) (((buf[1] << 6) & 0xc0) | (data & 0x3f));\r\ninput_report_rel(dev, REL_X, data / 2);\r\ninput_report_rel(dev, REL_Y, buf[4]);\r\nbuf[3] = data - data / 2;\r\nbreak;\r\ncase 2:\r\nif ((sermouse->type == SERIO_MS) && !data && !buf[2] && !((buf[0] & 0xf0) ^ buf[1]))\r\ninput_report_key(dev, BTN_MIDDLE, !test_bit(BTN_MIDDLE, dev->key));\r\nbuf[0] = buf[1];\r\ndata = (signed char) (((buf[1] << 4) & 0xc0) | (data & 0x3f));\r\ninput_report_rel(dev, REL_X, buf[3]);\r\ninput_report_rel(dev, REL_Y, data - buf[4]);\r\nbuf[4] = data / 2;\r\nbreak;\r\ncase 3:\r\nswitch (sermouse->type) {\r\ncase SERIO_MS:\r\nsermouse->type = SERIO_MP;\r\ncase SERIO_MP:\r\nif ((data >> 2) & 3) break;\r\ninput_report_key(dev, BTN_MIDDLE, (data >> 5) & 1);\r\ninput_report_key(dev, BTN_SIDE, (data >> 4) & 1);\r\nbreak;\r\ncase SERIO_MZP:\r\ncase SERIO_MZPP:\r\ninput_report_key(dev, BTN_SIDE, (data >> 5) & 1);\r\ncase SERIO_MZ:\r\ninput_report_key(dev, BTN_MIDDLE, (data >> 4) & 1);\r\ninput_report_rel(dev, REL_WHEEL, (data & 8) - (data & 7));\r\nbreak;\r\n}\r\nbreak;\r\ncase 4:\r\ncase 6:\r\nbuf[1] = (data >> 2) & 0x0f;\r\nbreak;\r\ncase 5:\r\ncase 7:\r\nif (sermouse->type != SERIO_MZPP)\r\nbreak;\r\nswitch (buf[1]) {\r\ncase 1:\r\ninput_report_key(dev, BTN_SIDE, (data >> 4) & 1);\r\ninput_report_key(dev, BTN_EXTRA, (data >> 5) & 1);\r\ninput_report_rel(dev, data & 0x80 ? REL_HWHEEL : REL_WHEEL, (data & 7) - (data & 8));\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"sermouse.c: Received MZ++ packet %x, don't know how to handle.\n", buf[1]);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ninput_sync(dev);\r\nsermouse->count++;\r\n}\r\nstatic irqreturn_t sermouse_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct sermouse *sermouse = serio_get_drvdata(serio);\r\nif (time_after(jiffies, sermouse->last + HZ/10))\r\nsermouse->count = 0;\r\nsermouse->last = jiffies;\r\nif (sermouse->type > SERIO_SUN)\r\nsermouse_process_ms(sermouse, data);\r\nelse\r\nsermouse_process_msc(sermouse, data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sermouse_disconnect(struct serio *serio)\r\n{\r\nstruct sermouse *sermouse = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_unregister_device(sermouse->dev);\r\nkfree(sermouse);\r\n}\r\nstatic int sermouse_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct sermouse *sermouse;\r\nstruct input_dev *input_dev;\r\nunsigned char c = serio->id.extra;\r\nint err = -ENOMEM;\r\nsermouse = kzalloc(sizeof(struct sermouse), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!sermouse || !input_dev)\r\ngoto fail1;\r\nsermouse->dev = input_dev;\r\nsnprintf(sermouse->phys, sizeof(sermouse->phys), "%s/input0", serio->phys);\r\nsermouse->type = serio->id.proto;\r\ninput_dev->name = sermouse_protocols[sermouse->type];\r\ninput_dev->phys = sermouse->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = sermouse->type;\r\ninput_dev->id.product = c;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ninput_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\r\nBIT_MASK(BTN_RIGHT);\r\ninput_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\nif (c & 0x01) set_bit(BTN_MIDDLE, input_dev->keybit);\r\nif (c & 0x02) set_bit(BTN_SIDE, input_dev->keybit);\r\nif (c & 0x04) set_bit(BTN_EXTRA, input_dev->keybit);\r\nif (c & 0x10) set_bit(REL_WHEEL, input_dev->relbit);\r\nif (c & 0x20) set_bit(REL_HWHEEL, input_dev->relbit);\r\nserio_set_drvdata(serio, sermouse);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = input_register_device(sermouse->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(sermouse);\r\nreturn err;\r\n}\r\nstatic int __init sermouse_init(void)\r\n{\r\nreturn serio_register_driver(&sermouse_drv);\r\n}\r\nstatic void __exit sermouse_exit(void)\r\n{\r\nserio_unregister_driver(&sermouse_drv);\r\n}
