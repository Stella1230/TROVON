static inline char *nand_flash_manufacturer(int manuf_id) {\r\nswitch(manuf_id) {\r\ncase NAND_MFR_AMD:\r\nreturn "AMD";\r\ncase NAND_MFR_NATSEMI:\r\nreturn "NATSEMI";\r\ncase NAND_MFR_TOSHIBA:\r\nreturn "Toshiba";\r\ncase NAND_MFR_SAMSUNG:\r\nreturn "Samsung";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic struct nand_flash_dev *\r\nnand_find_id(unsigned char id) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nand_flash_ids); i++)\r\nif (nand_flash_ids[i].model_id == id)\r\nreturn &(nand_flash_ids[i]);\r\nreturn NULL;\r\n}\r\nstatic void nand_init_ecc(void) {\r\nint i, j, a;\r\nparity[0] = 0;\r\nfor (i = 1; i < 256; i++)\r\nparity[i] = (parity[i&(i-1)] ^ 1);\r\nfor (i = 0; i < 256; i++) {\r\na = 0;\r\nfor (j = 0; j < 8; j++) {\r\nif (i & (1<<j)) {\r\nif ((j & 1) == 0)\r\na ^= 0x04;\r\nif ((j & 2) == 0)\r\na ^= 0x10;\r\nif ((j & 4) == 0)\r\na ^= 0x40;\r\n}\r\n}\r\necc2[i] = ~(a ^ (a<<1) ^ (parity[i] ? 0xa8 : 0));\r\n}\r\n}\r\nstatic void nand_compute_ecc(unsigned char *data, unsigned char *ecc) {\r\nint i, j, a;\r\nunsigned char par, bit, bits[8];\r\npar = 0;\r\nfor (j = 0; j < 8; j++)\r\nbits[j] = 0;\r\nfor (i = 0; i < 256; i++) {\r\npar ^= data[i];\r\nbit = parity[data[i]];\r\nfor (j = 0; j < 8; j++)\r\nif ((i & (1<<j)) == 0)\r\nbits[j] ^= bit;\r\n}\r\na = (bits[3] << 6) + (bits[2] << 4) + (bits[1] << 2) + bits[0];\r\necc[0] = ~(a ^ (a<<1) ^ (parity[par] ? 0xaa : 0));\r\na = (bits[7] << 6) + (bits[6] << 4) + (bits[5] << 2) + bits[4];\r\necc[1] = ~(a ^ (a<<1) ^ (parity[par] ? 0xaa : 0));\r\necc[2] = ecc2[par];\r\n}\r\nstatic int nand_compare_ecc(unsigned char *data, unsigned char *ecc) {\r\nreturn (data[0] == ecc[0] && data[1] == ecc[1] && data[2] == ecc[2]);\r\n}\r\nstatic void nand_store_ecc(unsigned char *data, unsigned char *ecc) {\r\nmemcpy(data, ecc, 3);\r\n}\r\nstatic int\r\nsddr09_send_command(struct us_data *us,\r\nunsigned char request,\r\nunsigned char direction,\r\nunsigned char *xfer_data,\r\nunsigned int xfer_len) {\r\nunsigned int pipe;\r\nunsigned char requesttype = (0x41 | direction);\r\nint rc;\r\nif (direction == USB_DIR_IN)\r\npipe = us->recv_ctrl_pipe;\r\nelse\r\npipe = us->send_ctrl_pipe;\r\nrc = usb_stor_ctrl_transfer(us, pipe, request, requesttype,\r\n0, 0, xfer_data, xfer_len);\r\nswitch (rc) {\r\ncase USB_STOR_XFER_GOOD: return 0;\r\ncase USB_STOR_XFER_STALLED: return -EPIPE;\r\ndefault: return -EIO;\r\n}\r\n}\r\nstatic int\r\nsddr09_send_scsi_command(struct us_data *us,\r\nunsigned char *command,\r\nunsigned int command_len) {\r\nreturn sddr09_send_command(us, 0, USB_DIR_OUT, command, command_len);\r\n}\r\nstatic int\r\nsddr09_request_sense(struct us_data *us, unsigned char *sensebuf, int buflen) {\r\nunsigned char *command = us->iobuf;\r\nint result;\r\nmemset(command, 0, 12);\r\ncommand[0] = 0x03;\r\ncommand[1] = LUNBITS;\r\ncommand[4] = buflen;\r\nresult = sddr09_send_scsi_command(us, command, 12);\r\nif (result)\r\nreturn result;\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\nsensebuf, buflen, NULL);\r\nreturn (result == USB_STOR_XFER_GOOD ? 0 : -EIO);\r\n}\r\nstatic int\r\nsddr09_readX(struct us_data *us, int x, unsigned long fromaddress,\r\nint nr_of_pages, int bulklen, unsigned char *buf,\r\nint use_sg) {\r\nunsigned char *command = us->iobuf;\r\nint result;\r\ncommand[0] = 0xE8;\r\ncommand[1] = LUNBITS | x;\r\ncommand[2] = MSB_of(fromaddress>>16);\r\ncommand[3] = LSB_of(fromaddress>>16);\r\ncommand[4] = MSB_of(fromaddress & 0xFFFF);\r\ncommand[5] = LSB_of(fromaddress & 0xFFFF);\r\ncommand[6] = 0;\r\ncommand[7] = 0;\r\ncommand[8] = 0;\r\ncommand[9] = 0;\r\ncommand[10] = MSB_of(nr_of_pages);\r\ncommand[11] = LSB_of(nr_of_pages);\r\nresult = sddr09_send_scsi_command(us, command, 12);\r\nif (result) {\r\nUS_DEBUGP("Result for send_control in sddr09_read2%d %d\n",\r\nx, result);\r\nreturn result;\r\n}\r\nresult = usb_stor_bulk_transfer_sg(us, us->recv_bulk_pipe,\r\nbuf, bulklen, use_sg, NULL);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nUS_DEBUGP("Result for bulk_transfer in sddr09_read2%d %d\n",\r\nx, result);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsddr09_read20(struct us_data *us, unsigned long fromaddress,\r\nint nr_of_pages, int pageshift, unsigned char *buf, int use_sg) {\r\nint bulklen = nr_of_pages << pageshift;\r\nreturn sddr09_readX(us, 0, fromaddress, nr_of_pages, bulklen,\r\nbuf, use_sg);\r\n}\r\nstatic int\r\nsddr09_read21(struct us_data *us, unsigned long fromaddress,\r\nint count, int controlshift, unsigned char *buf, int use_sg) {\r\nint bulklen = (count << controlshift);\r\nreturn sddr09_readX(us, 1, fromaddress, count, bulklen,\r\nbuf, use_sg);\r\n}\r\nstatic int\r\nsddr09_read22(struct us_data *us, unsigned long fromaddress,\r\nint nr_of_pages, int pageshift, unsigned char *buf, int use_sg) {\r\nint bulklen = (nr_of_pages << pageshift) + (nr_of_pages << CONTROL_SHIFT);\r\nUS_DEBUGP("sddr09_read22: reading %d pages, %d bytes\n",\r\nnr_of_pages, bulklen);\r\nreturn sddr09_readX(us, 2, fromaddress, nr_of_pages, bulklen,\r\nbuf, use_sg);\r\n}\r\nstatic int\r\nsddr09_erase(struct us_data *us, unsigned long Eaddress) {\r\nunsigned char *command = us->iobuf;\r\nint result;\r\nUS_DEBUGP("sddr09_erase: erase address %lu\n", Eaddress);\r\nmemset(command, 0, 12);\r\ncommand[0] = 0xEA;\r\ncommand[1] = LUNBITS;\r\ncommand[6] = MSB_of(Eaddress>>16);\r\ncommand[7] = LSB_of(Eaddress>>16);\r\ncommand[8] = MSB_of(Eaddress & 0xFFFF);\r\ncommand[9] = LSB_of(Eaddress & 0xFFFF);\r\nresult = sddr09_send_scsi_command(us, command, 12);\r\nif (result)\r\nUS_DEBUGP("Result for send_control in sddr09_erase %d\n",\r\nresult);\r\nreturn result;\r\n}\r\nstatic int\r\nsddr09_writeX(struct us_data *us,\r\nunsigned long Waddress, unsigned long Eaddress,\r\nint nr_of_pages, int bulklen, unsigned char *buf, int use_sg) {\r\nunsigned char *command = us->iobuf;\r\nint result;\r\ncommand[0] = 0xE9;\r\ncommand[1] = LUNBITS;\r\ncommand[2] = MSB_of(Waddress>>16);\r\ncommand[3] = LSB_of(Waddress>>16);\r\ncommand[4] = MSB_of(Waddress & 0xFFFF);\r\ncommand[5] = LSB_of(Waddress & 0xFFFF);\r\ncommand[6] = MSB_of(Eaddress>>16);\r\ncommand[7] = LSB_of(Eaddress>>16);\r\ncommand[8] = MSB_of(Eaddress & 0xFFFF);\r\ncommand[9] = LSB_of(Eaddress & 0xFFFF);\r\ncommand[10] = MSB_of(nr_of_pages);\r\ncommand[11] = LSB_of(nr_of_pages);\r\nresult = sddr09_send_scsi_command(us, command, 12);\r\nif (result) {\r\nUS_DEBUGP("Result for send_control in sddr09_writeX %d\n",\r\nresult);\r\nreturn result;\r\n}\r\nresult = usb_stor_bulk_transfer_sg(us, us->send_bulk_pipe,\r\nbuf, bulklen, use_sg, NULL);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nUS_DEBUGP("Result for bulk_transfer in sddr09_writeX %d\n",\r\nresult);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsddr09_write_inplace(struct us_data *us, unsigned long address,\r\nint nr_of_pages, int pageshift, unsigned char *buf,\r\nint use_sg) {\r\nint bulklen = (nr_of_pages << pageshift) + (nr_of_pages << CONTROL_SHIFT);\r\nreturn sddr09_writeX(us, address, address, nr_of_pages, bulklen,\r\nbuf, use_sg);\r\n}\r\nstatic int\r\nsddr09_read_status(struct us_data *us, unsigned char *status) {\r\nunsigned char *command = us->iobuf;\r\nunsigned char *data = us->iobuf;\r\nint result;\r\nUS_DEBUGP("Reading status...\n");\r\nmemset(command, 0, 12);\r\ncommand[0] = 0xEC;\r\ncommand[1] = LUNBITS;\r\nresult = sddr09_send_scsi_command(us, command, 12);\r\nif (result)\r\nreturn result;\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\ndata, 64, NULL);\r\n*status = data[0];\r\nreturn (result == USB_STOR_XFER_GOOD ? 0 : -EIO);\r\n}\r\nstatic int\r\nsddr09_read_data(struct us_data *us,\r\nunsigned long address,\r\nunsigned int sectors) {\r\nstruct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;\r\nunsigned char *buffer;\r\nunsigned int lba, maxlba, pba;\r\nunsigned int page, pages;\r\nunsigned int len, offset;\r\nstruct scatterlist *sg;\r\nint result;\r\nlba = address >> info->blockshift;\r\npage = (address & info->blockmask);\r\nmaxlba = info->capacity >> (info->pageshift + info->blockshift);\r\nif (lba >= maxlba)\r\nreturn -EIO;\r\nlen = min(sectors, (unsigned int) info->blocksize) * info->pagesize;\r\nbuffer = kmalloc(len, GFP_NOIO);\r\nif (buffer == NULL) {\r\nprintk(KERN_WARNING "sddr09_read_data: Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nresult = 0;\r\noffset = 0;\r\nsg = NULL;\r\nwhile (sectors > 0) {\r\npages = min(sectors, info->blocksize - page);\r\nlen = pages << info->pageshift;\r\nif (lba >= maxlba) {\r\nUS_DEBUGP("Error: Requested lba %u exceeds "\r\n"maximum %u\n", lba, maxlba);\r\nresult = -EIO;\r\nbreak;\r\n}\r\npba = info->lba_to_pba[lba];\r\nif (pba == UNDEF) {\r\nUS_DEBUGP("Read %d zero pages (LBA %d) page %d\n",\r\npages, lba, page);\r\nmemset(buffer, 0, len);\r\n} else {\r\nUS_DEBUGP("Read %d pages, from PBA %d"\r\n" (LBA %d) page %d\n",\r\npages, pba, lba, page);\r\naddress = ((pba << info->blockshift) + page) <<\r\ninfo->pageshift;\r\nresult = sddr09_read20(us, address>>1,\r\npages, info->pageshift, buffer, 0);\r\nif (result)\r\nbreak;\r\n}\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &offset, TO_XFER_BUF);\r\npage = 0;\r\nlba++;\r\nsectors -= pages;\r\n}\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic unsigned int\r\nsddr09_find_unused_pba(struct sddr09_card_info *info, unsigned int lba) {\r\nstatic unsigned int lastpba = 1;\r\nint zonestart, end, i;\r\nzonestart = (lba/1000) << 10;\r\nend = info->capacity >> (info->blockshift + info->pageshift);\r\nend -= zonestart;\r\nif (end > 1024)\r\nend = 1024;\r\nfor (i = lastpba+1; i < end; i++) {\r\nif (info->pba_to_lba[zonestart+i] == UNDEF) {\r\nlastpba = i;\r\nreturn zonestart+i;\r\n}\r\n}\r\nfor (i = 0; i <= lastpba; i++) {\r\nif (info->pba_to_lba[zonestart+i] == UNDEF) {\r\nlastpba = i;\r\nreturn zonestart+i;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsddr09_write_lba(struct us_data *us, unsigned int lba,\r\nunsigned int page, unsigned int pages,\r\nunsigned char *ptr, unsigned char *blockbuffer) {\r\nstruct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;\r\nunsigned long address;\r\nunsigned int pba, lbap;\r\nunsigned int pagelen;\r\nunsigned char *bptr, *cptr, *xptr;\r\nunsigned char ecc[3];\r\nint i, result, isnew;\r\nlbap = ((lba % 1000) << 1) | 0x1000;\r\nif (parity[MSB_of(lbap) ^ LSB_of(lbap)])\r\nlbap ^= 1;\r\npba = info->lba_to_pba[lba];\r\nisnew = 0;\r\nif (pba == UNDEF) {\r\npba = sddr09_find_unused_pba(info, lba);\r\nif (!pba) {\r\nprintk(KERN_WARNING\r\n"sddr09_write_lba: Out of unused blocks\n");\r\nreturn -ENOSPC;\r\n}\r\ninfo->pba_to_lba[pba] = lba;\r\ninfo->lba_to_pba[lba] = pba;\r\nisnew = 1;\r\n}\r\nif (pba == 1) {\r\nprintk(KERN_WARNING "sddr09: avoid writing to pba 1\n");\r\nreturn 0;\r\n}\r\npagelen = (1 << info->pageshift) + (1 << CONTROL_SHIFT);\r\naddress = (pba << (info->pageshift + info->blockshift));\r\nresult = sddr09_read22(us, address>>1, info->blocksize,\r\ninfo->pageshift, blockbuffer, 0);\r\nif (result)\r\nreturn result;\r\nfor (i = 0; i < info->blocksize; i++) {\r\nbptr = blockbuffer + i*pagelen;\r\ncptr = bptr + info->pagesize;\r\nnand_compute_ecc(bptr, ecc);\r\nif (!nand_compare_ecc(cptr+13, ecc)) {\r\nUS_DEBUGP("Warning: bad ecc in page %d- of pba %d\n",\r\ni, pba);\r\nnand_store_ecc(cptr+13, ecc);\r\n}\r\nnand_compute_ecc(bptr+(info->pagesize / 2), ecc);\r\nif (!nand_compare_ecc(cptr+8, ecc)) {\r\nUS_DEBUGP("Warning: bad ecc in page %d+ of pba %d\n",\r\ni, pba);\r\nnand_store_ecc(cptr+8, ecc);\r\n}\r\ncptr[6] = cptr[11] = MSB_of(lbap);\r\ncptr[7] = cptr[12] = LSB_of(lbap);\r\n}\r\nxptr = ptr;\r\nfor (i = page; i < page+pages; i++) {\r\nbptr = blockbuffer + i*pagelen;\r\ncptr = bptr + info->pagesize;\r\nmemcpy(bptr, xptr, info->pagesize);\r\nxptr += info->pagesize;\r\nnand_compute_ecc(bptr, ecc);\r\nnand_store_ecc(cptr+13, ecc);\r\nnand_compute_ecc(bptr+(info->pagesize / 2), ecc);\r\nnand_store_ecc(cptr+8, ecc);\r\n}\r\nUS_DEBUGP("Rewrite PBA %d (LBA %d)\n", pba, lba);\r\nresult = sddr09_write_inplace(us, address>>1, info->blocksize,\r\ninfo->pageshift, blockbuffer, 0);\r\nUS_DEBUGP("sddr09_write_inplace returns %d\n", result);\r\n#if 0\r\n{\r\nunsigned char status = 0;\r\nint result2 = sddr09_read_status(us, &status);\r\nif (result2)\r\nUS_DEBUGP("sddr09_write_inplace: cannot read status\n");\r\nelse if (status != 0xc0)\r\nUS_DEBUGP("sddr09_write_inplace: status after write: 0x%x\n",\r\nstatus);\r\n}\r\n#endif\r\n#if 0\r\n{\r\nint result2 = sddr09_test_unit_ready(us);\r\n}\r\n#endif\r\nreturn result;\r\n}\r\nstatic int\r\nsddr09_write_data(struct us_data *us,\r\nunsigned long address,\r\nunsigned int sectors) {\r\nstruct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;\r\nunsigned int lba, maxlba, page, pages;\r\nunsigned int pagelen, blocklen;\r\nunsigned char *blockbuffer;\r\nunsigned char *buffer;\r\nunsigned int len, offset;\r\nstruct scatterlist *sg;\r\nint result;\r\nlba = address >> info->blockshift;\r\npage = (address & info->blockmask);\r\nmaxlba = info->capacity >> (info->pageshift + info->blockshift);\r\nif (lba >= maxlba)\r\nreturn -EIO;\r\npagelen = (1 << info->pageshift) + (1 << CONTROL_SHIFT);\r\nblocklen = (pagelen << info->blockshift);\r\nblockbuffer = kmalloc(blocklen, GFP_NOIO);\r\nif (!blockbuffer) {\r\nprintk(KERN_WARNING "sddr09_write_data: Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nlen = min(sectors, (unsigned int) info->blocksize) * info->pagesize;\r\nbuffer = kmalloc(len, GFP_NOIO);\r\nif (buffer == NULL) {\r\nprintk(KERN_WARNING "sddr09_write_data: Out of memory\n");\r\nkfree(blockbuffer);\r\nreturn -ENOMEM;\r\n}\r\nresult = 0;\r\noffset = 0;\r\nsg = NULL;\r\nwhile (sectors > 0) {\r\npages = min(sectors, info->blocksize - page);\r\nlen = (pages << info->pageshift);\r\nif (lba >= maxlba) {\r\nUS_DEBUGP("Error: Requested lba %u exceeds "\r\n"maximum %u\n", lba, maxlba);\r\nresult = -EIO;\r\nbreak;\r\n}\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &offset, FROM_XFER_BUF);\r\nresult = sddr09_write_lba(us, lba, page, pages,\r\nbuffer, blockbuffer);\r\nif (result)\r\nbreak;\r\npage = 0;\r\nlba++;\r\nsectors -= pages;\r\n}\r\nkfree(buffer);\r\nkfree(blockbuffer);\r\nreturn result;\r\n}\r\nstatic int\r\nsddr09_read_control(struct us_data *us,\r\nunsigned long address,\r\nunsigned int blocks,\r\nunsigned char *content,\r\nint use_sg) {\r\nUS_DEBUGP("Read control address %lu, blocks %d\n",\r\naddress, blocks);\r\nreturn sddr09_read21(us, address, blocks,\r\nCONTROL_SHIFT, content, use_sg);\r\n}\r\nstatic int\r\nsddr09_read_deviceID(struct us_data *us, unsigned char *deviceID) {\r\nunsigned char *command = us->iobuf;\r\nunsigned char *content = us->iobuf;\r\nint result, i;\r\nmemset(command, 0, 12);\r\ncommand[0] = 0xED;\r\ncommand[1] = LUNBITS;\r\nresult = sddr09_send_scsi_command(us, command, 12);\r\nif (result)\r\nreturn result;\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\ncontent, 64, NULL);\r\nfor (i = 0; i < 4; i++)\r\ndeviceID[i] = content[i];\r\nreturn (result == USB_STOR_XFER_GOOD ? 0 : -EIO);\r\n}\r\nstatic int\r\nsddr09_get_wp(struct us_data *us, struct sddr09_card_info *info) {\r\nint result;\r\nunsigned char status;\r\nresult = sddr09_read_status(us, &status);\r\nif (result) {\r\nUS_DEBUGP("sddr09_get_wp: read_status fails\n");\r\nreturn result;\r\n}\r\nUS_DEBUGP("sddr09_get_wp: status 0x%02X", status);\r\nif ((status & 0x80) == 0) {\r\ninfo->flags |= SDDR09_WP;\r\nUS_DEBUGP(" WP");\r\n}\r\nif (status & 0x40)\r\nUS_DEBUGP(" Ready");\r\nif (status & LUNBITS)\r\nUS_DEBUGP(" Suspended");\r\nif (status & 0x1)\r\nUS_DEBUGP(" Error");\r\nUS_DEBUGP("\n");\r\nreturn 0;\r\n}\r\nstatic struct nand_flash_dev *\r\nsddr09_get_cardinfo(struct us_data *us, unsigned char flags) {\r\nstruct nand_flash_dev *cardinfo;\r\nunsigned char deviceID[4];\r\nchar blurbtxt[256];\r\nint result;\r\nUS_DEBUGP("Reading capacity...\n");\r\nresult = sddr09_read_deviceID(us, deviceID);\r\nif (result) {\r\nUS_DEBUGP("Result of read_deviceID is %d\n", result);\r\nprintk(KERN_WARNING "sddr09: could not read card info\n");\r\nreturn NULL;\r\n}\r\nsprintf(blurbtxt, "sddr09: Found Flash card, ID = %02X %02X %02X %02X",\r\ndeviceID[0], deviceID[1], deviceID[2], deviceID[3]);\r\nsprintf(blurbtxt + strlen(blurbtxt),\r\n": Manuf. %s",\r\nnand_flash_manufacturer(deviceID[0]));\r\ncardinfo = nand_find_id(deviceID[1]);\r\nif (cardinfo) {\r\nsprintf(blurbtxt + strlen(blurbtxt),\r\n", %d MB", 1<<(cardinfo->chipshift - 20));\r\n} else {\r\nsprintf(blurbtxt + strlen(blurbtxt),\r\n", type unrecognized");\r\n}\r\nif (deviceID[2] == 0xa5) {\r\nsprintf(blurbtxt + strlen(blurbtxt),\r\n", 128-bit ID");\r\n}\r\nif (deviceID[3] == 0xc0) {\r\nsprintf(blurbtxt + strlen(blurbtxt),\r\n", extra cmd");\r\n}\r\nif (flags & SDDR09_WP)\r\nsprintf(blurbtxt + strlen(blurbtxt),\r\n", WP");\r\nprintk(KERN_WARNING "%s\n", blurbtxt);\r\nreturn cardinfo;\r\n}\r\nstatic int\r\nsddr09_read_map(struct us_data *us) {\r\nstruct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;\r\nint numblocks, alloc_len, alloc_blocks;\r\nint i, j, result;\r\nunsigned char *buffer, *buffer_end, *ptr;\r\nunsigned int lba, lbact;\r\nif (!info->capacity)\r\nreturn -1;\r\nnumblocks = info->capacity >> (info->blockshift + info->pageshift);\r\n#define SDDR09_READ_MAP_BUFSZ 65536\r\nalloc_blocks = min(numblocks, SDDR09_READ_MAP_BUFSZ >> CONTROL_SHIFT);\r\nalloc_len = (alloc_blocks << CONTROL_SHIFT);\r\nbuffer = kmalloc(alloc_len, GFP_NOIO);\r\nif (buffer == NULL) {\r\nprintk(KERN_WARNING "sddr09_read_map: out of memory\n");\r\nresult = -1;\r\ngoto done;\r\n}\r\nbuffer_end = buffer + alloc_len;\r\n#undef SDDR09_READ_MAP_BUFSZ\r\nkfree(info->lba_to_pba);\r\nkfree(info->pba_to_lba);\r\ninfo->lba_to_pba = kmalloc(numblocks*sizeof(int), GFP_NOIO);\r\ninfo->pba_to_lba = kmalloc(numblocks*sizeof(int), GFP_NOIO);\r\nif (info->lba_to_pba == NULL || info->pba_to_lba == NULL) {\r\nprintk(KERN_WARNING "sddr09_read_map: out of memory\n");\r\nresult = -1;\r\ngoto done;\r\n}\r\nfor (i = 0; i < numblocks; i++)\r\ninfo->lba_to_pba[i] = info->pba_to_lba[i] = UNDEF;\r\nptr = buffer_end;\r\nfor (i = 0; i < numblocks; i++) {\r\nptr += (1 << CONTROL_SHIFT);\r\nif (ptr >= buffer_end) {\r\nunsigned long address;\r\naddress = i << (info->pageshift + info->blockshift);\r\nresult = sddr09_read_control(\r\nus, address>>1,\r\nmin(alloc_blocks, numblocks - i),\r\nbuffer, 0);\r\nif (result) {\r\nresult = -1;\r\ngoto done;\r\n}\r\nptr = buffer;\r\n}\r\nif (i == 0 || i == 1) {\r\ninfo->pba_to_lba[i] = UNUSABLE;\r\ncontinue;\r\n}\r\nfor (j = 0; j < 16; j++)\r\nif (ptr[j] != 0)\r\ngoto nonz;\r\ninfo->pba_to_lba[i] = UNUSABLE;\r\nprintk(KERN_WARNING "sddr09: PBA %d has no logical mapping\n",\r\ni);\r\ncontinue;\r\nnonz:\r\nfor (j = 0; j < 16; j++)\r\nif (ptr[j] != 0xff)\r\ngoto nonff;\r\ncontinue;\r\nnonff:\r\nif (j < 6) {\r\nprintk(KERN_WARNING\r\n"sddr09: PBA %d has no logical mapping: "\r\n"reserved area = %02X%02X%02X%02X "\r\n"data status %02X block status %02X\n",\r\ni, ptr[0], ptr[1], ptr[2], ptr[3],\r\nptr[4], ptr[5]);\r\ninfo->pba_to_lba[i] = UNUSABLE;\r\ncontinue;\r\n}\r\nif ((ptr[6] >> 4) != 0x01) {\r\nprintk(KERN_WARNING\r\n"sddr09: PBA %d has invalid address field "\r\n"%02X%02X/%02X%02X\n",\r\ni, ptr[6], ptr[7], ptr[11], ptr[12]);\r\ninfo->pba_to_lba[i] = UNUSABLE;\r\ncontinue;\r\n}\r\nif (parity[ptr[6] ^ ptr[7]]) {\r\nprintk(KERN_WARNING\r\n"sddr09: Bad parity in LBA for block %d"\r\n" (%02X %02X)\n", i, ptr[6], ptr[7]);\r\ninfo->pba_to_lba[i] = UNUSABLE;\r\ncontinue;\r\n}\r\nlba = short_pack(ptr[7], ptr[6]);\r\nlba = (lba & 0x07FF) >> 1;\r\nif (lba >= 1000) {\r\nprintk(KERN_WARNING\r\n"sddr09: Bad low LBA %d for block %d\n",\r\nlba, i);\r\ngoto possibly_erase;\r\n}\r\nlba += 1000*(i/0x400);\r\nif (info->lba_to_pba[lba] != UNDEF) {\r\nprintk(KERN_WARNING\r\n"sddr09: LBA %d seen for PBA %d and %d\n",\r\nlba, info->lba_to_pba[lba], i);\r\ngoto possibly_erase;\r\n}\r\ninfo->pba_to_lba[i] = lba;\r\ninfo->lba_to_pba[lba] = i;\r\ncontinue;\r\npossibly_erase:\r\nif (erase_bad_lba_entries) {\r\nunsigned long address;\r\naddress = (i << (info->pageshift + info->blockshift));\r\nsddr09_erase(us, address>>1);\r\ninfo->pba_to_lba[i] = UNDEF;\r\n} else\r\ninfo->pba_to_lba[i] = UNUSABLE;\r\n}\r\nlbact = 0;\r\nfor (i = 0; i < numblocks; i += 1024) {\r\nint ct = 0;\r\nfor (j = 0; j < 1024 && i+j < numblocks; j++) {\r\nif (info->pba_to_lba[i+j] != UNUSABLE) {\r\nif (ct >= 1000)\r\ninfo->pba_to_lba[i+j] = SPARE;\r\nelse\r\nct++;\r\n}\r\n}\r\nlbact += ct;\r\n}\r\ninfo->lbact = lbact;\r\nUS_DEBUGP("Found %d LBA's\n", lbact);\r\nresult = 0;\r\ndone:\r\nif (result != 0) {\r\nkfree(info->lba_to_pba);\r\nkfree(info->pba_to_lba);\r\ninfo->lba_to_pba = NULL;\r\ninfo->pba_to_lba = NULL;\r\n}\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic void\r\nsddr09_card_info_destructor(void *extra) {\r\nstruct sddr09_card_info *info = (struct sddr09_card_info *)extra;\r\nif (!info)\r\nreturn;\r\nkfree(info->lba_to_pba);\r\nkfree(info->pba_to_lba);\r\n}\r\nstatic int\r\nsddr09_common_init(struct us_data *us) {\r\nint result;\r\nif (us->pusb_dev->actconfig->desc.bConfigurationValue != 1) {\r\nUS_DEBUGP("active config #%d != 1 ??\n", us->pusb_dev\r\n->actconfig->desc.bConfigurationValue);\r\nreturn -EINVAL;\r\n}\r\nresult = usb_reset_configuration(us->pusb_dev);\r\nUS_DEBUGP("Result of usb_reset_configuration is %d\n", result);\r\nif (result == -EPIPE) {\r\nUS_DEBUGP("-- stall on control interface\n");\r\n} else if (result != 0) {\r\nUS_DEBUGP("-- Unknown error. Rejecting device\n");\r\nreturn -EINVAL;\r\n}\r\nus->extra = kzalloc(sizeof(struct sddr09_card_info), GFP_NOIO);\r\nif (!us->extra)\r\nreturn -ENOMEM;\r\nus->extra_destructor = sddr09_card_info_destructor;\r\nnand_init_ecc();\r\nreturn 0;\r\n}\r\nstatic int\r\nusb_stor_sddr09_dpcm_init(struct us_data *us) {\r\nint result;\r\nunsigned char *data = us->iobuf;\r\nresult = sddr09_common_init(us);\r\nif (result)\r\nreturn result;\r\nresult = sddr09_send_command(us, 0x01, USB_DIR_IN, data, 2);\r\nif (result) {\r\nUS_DEBUGP("sddr09_init: send_command fails\n");\r\nreturn result;\r\n}\r\nUS_DEBUGP("SDDR09init: %02X %02X\n", data[0], data[1]);\r\nresult = sddr09_send_command(us, 0x08, USB_DIR_IN, data, 2);\r\nif (result) {\r\nUS_DEBUGP("sddr09_init: 2nd send_command fails\n");\r\nreturn result;\r\n}\r\nUS_DEBUGP("SDDR09init: %02X %02X\n", data[0], data[1]);\r\nresult = sddr09_request_sense(us, data, 18);\r\nif (result == 0 && data[2] != 0) {\r\nint j;\r\nfor (j=0; j<18; j++)\r\nprintk(" %02X", data[j]);\r\nprintk("\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nint ret;\r\nUS_DEBUGP("dpcm_transport: LUN=%d\n", srb->device->lun);\r\nswitch (srb->device->lun) {\r\ncase 0:\r\nret = usb_stor_CB_transport(srb, us);\r\nbreak;\r\ncase 1:\r\nsrb->device->lun = 0;\r\nret = sddr09_transport(srb, us);\r\nsrb->device->lun = 1;\r\nbreak;\r\ndefault:\r\nUS_DEBUGP("dpcm_transport: Invalid LUN %d\n",\r\nsrb->device->lun);\r\nret = USB_STOR_TRANSPORT_ERROR;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sddr09_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nstatic unsigned char sensekey = 0, sensecode = 0;\r\nstatic unsigned char havefakesense = 0;\r\nint result, i;\r\nunsigned char *ptr = us->iobuf;\r\nunsigned long capacity;\r\nunsigned int page, pages;\r\nstruct sddr09_card_info *info;\r\nstatic unsigned char inquiry_response[8] = {\r\n0x00, 0x80, 0x00, 0x02, 0x1F, 0x00, 0x00, 0x00\r\n};\r\nstatic unsigned char mode_page_01[19] = {\r\n0x00, 0x0F, 0x00, 0x0, 0x0, 0x0, 0x00,\r\n0x01, 0x0A,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n};\r\ninfo = (struct sddr09_card_info *)us->extra;\r\nif (srb->cmnd[0] == REQUEST_SENSE && havefakesense) {\r\nmemset(ptr, 0, 18);\r\nptr[0] = 0x70;\r\nptr[2] = sensekey;\r\nptr[7] = 11;\r\nptr[12] = sensecode;\r\nusb_stor_set_xfer_buf(ptr, 18, srb);\r\nsensekey = sensecode = havefakesense = 0;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nhavefakesense = 1;\r\nif (srb->cmnd[0] == INQUIRY) {\r\nmemcpy(ptr, inquiry_response, 8);\r\nfill_inquiry_response(us, ptr, 36);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == READ_CAPACITY) {\r\nstruct nand_flash_dev *cardinfo;\r\nsddr09_get_wp(us, info);\r\ncardinfo = sddr09_get_cardinfo(us, info->flags);\r\nif (!cardinfo) {\r\ninit_error:\r\nsensekey = 0x02;\r\nsensecode = 0x3a;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\ninfo->capacity = (1 << cardinfo->chipshift);\r\ninfo->pageshift = cardinfo->pageshift;\r\ninfo->pagesize = (1 << info->pageshift);\r\ninfo->blockshift = cardinfo->blockshift;\r\ninfo->blocksize = (1 << info->blockshift);\r\ninfo->blockmask = info->blocksize - 1;\r\nif (sddr09_read_map(us)) {\r\ngoto init_error;\r\n}\r\ncapacity = (info->lbact << info->blockshift) - 1;\r\n((__be32 *) ptr)[0] = cpu_to_be32(capacity);\r\n((__be32 *) ptr)[1] = cpu_to_be32(info->pagesize);\r\nusb_stor_set_xfer_buf(ptr, 8, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == MODE_SENSE_10) {\r\nint modepage = (srb->cmnd[2] & 0x3F);\r\nif (modepage == 0x01 || modepage == 0x3F) {\r\nUS_DEBUGP("SDDR09: Dummy up request for "\r\n"mode page 0x%x\n", modepage);\r\nmemcpy(ptr, mode_page_01, sizeof(mode_page_01));\r\n((__be16*)ptr)[0] = cpu_to_be16(sizeof(mode_page_01) - 2);\r\nptr[3] = (info->flags & SDDR09_WP) ? 0x80 : 0;\r\nusb_stor_set_xfer_buf(ptr, sizeof(mode_page_01), srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nsensekey = 0x05;\r\nsensecode = 0x24;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL)\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nhavefakesense = 0;\r\nif (srb->cmnd[0] == READ_10) {\r\npage = short_pack(srb->cmnd[3], srb->cmnd[2]);\r\npage <<= 16;\r\npage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\r\npages = short_pack(srb->cmnd[8], srb->cmnd[7]);\r\nUS_DEBUGP("READ_10: read page %d pagect %d\n",\r\npage, pages);\r\nresult = sddr09_read_data(us, page, pages);\r\nreturn (result == 0 ? USB_STOR_TRANSPORT_GOOD :\r\nUSB_STOR_TRANSPORT_ERROR);\r\n}\r\nif (srb->cmnd[0] == WRITE_10) {\r\npage = short_pack(srb->cmnd[3], srb->cmnd[2]);\r\npage <<= 16;\r\npage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\r\npages = short_pack(srb->cmnd[8], srb->cmnd[7]);\r\nUS_DEBUGP("WRITE_10: write page %d pagect %d\n",\r\npage, pages);\r\nresult = sddr09_write_data(us, page, pages);\r\nreturn (result == 0 ? USB_STOR_TRANSPORT_GOOD :\r\nUSB_STOR_TRANSPORT_ERROR);\r\n}\r\nif (srb->cmnd[0] != TEST_UNIT_READY &&\r\nsrb->cmnd[0] != REQUEST_SENSE) {\r\nsensekey = 0x05;\r\nsensecode = 0x20;\r\nhavefakesense = 1;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nfor (; srb->cmd_len<12; srb->cmd_len++)\r\nsrb->cmnd[srb->cmd_len] = 0;\r\nsrb->cmnd[1] = LUNBITS;\r\nptr[0] = 0;\r\nfor (i=0; i<12; i++)\r\nsprintf(ptr+strlen(ptr), "%02X ", srb->cmnd[i]);\r\nUS_DEBUGP("SDDR09: Send control for command %s\n", ptr);\r\nresult = sddr09_send_scsi_command(us, srb->cmnd, 12);\r\nif (result) {\r\nUS_DEBUGP("sddr09_transport: sddr09_send_scsi_command "\r\n"returns %d\n", result);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (scsi_bufflen(srb) == 0)\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nif (srb->sc_data_direction == DMA_TO_DEVICE ||\r\nsrb->sc_data_direction == DMA_FROM_DEVICE) {\r\nunsigned int pipe = (srb->sc_data_direction == DMA_TO_DEVICE)\r\n? us->send_bulk_pipe : us->recv_bulk_pipe;\r\nUS_DEBUGP("SDDR09: %s %d bytes\n",\r\n(srb->sc_data_direction == DMA_TO_DEVICE) ?\r\n"sending" : "receiving",\r\nscsi_bufflen(srb));\r\nresult = usb_stor_bulk_srb(us, pipe, srb);\r\nreturn (result == USB_STOR_XFER_GOOD ?\r\nUSB_STOR_TRANSPORT_GOOD : USB_STOR_TRANSPORT_ERROR);\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int\r\nusb_stor_sddr09_init(struct us_data *us) {\r\nreturn sddr09_common_init(us);\r\n}\r\nstatic int sddr09_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - sddr09_usb_ids) + sddr09_unusual_dev_list);\r\nif (result)\r\nreturn result;\r\nif (us->protocol == USB_PR_DPCM_USB) {\r\nus->transport_name = "Control/Bulk-EUSB/SDDR09";\r\nus->transport = dpcm_transport;\r\nus->transport_reset = usb_stor_CB_reset;\r\nus->max_lun = 1;\r\n} else {\r\nus->transport_name = "EUSB/SDDR09";\r\nus->transport = sddr09_transport;\r\nus->transport_reset = usb_stor_CB_reset;\r\nus->max_lun = 0;\r\n}\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}\r\nstatic int __init sddr09_init(void)\r\n{\r\nreturn usb_register(&sddr09_driver);\r\n}\r\nstatic void __exit sddr09_exit(void)\r\n{\r\nusb_deregister(&sddr09_driver);\r\n}
