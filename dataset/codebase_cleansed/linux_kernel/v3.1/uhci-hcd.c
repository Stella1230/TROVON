static __hc32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)\r\n{\r\nint skelnum;\r\nskelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);\r\nif (skelnum <= 1)\r\nskelnum = 9;\r\nreturn LINK_TO_QH(uhci, uhci->skelqh[skelnum]);\r\n}\r\nstatic void finish_reset(struct uhci_hcd *uhci)\r\n{\r\nint port;\r\nfor (port = 0; port < uhci->rh_numports; ++port)\r\nuhci_writew(uhci, 0, USBPORTSC1 + (port * 2));\r\nuhci->port_c_suspend = uhci->resuming_ports = 0;\r\nuhci->rh_state = UHCI_RH_RESET;\r\nuhci->is_stopped = UHCI_IS_STOPPED;\r\nclear_bit(HCD_FLAG_POLL_RH, &uhci_to_hcd(uhci)->flags);\r\n}\r\nstatic void uhci_hc_died(struct uhci_hcd *uhci)\r\n{\r\nuhci_get_current_frame_number(uhci);\r\nuhci->reset_hc(uhci);\r\nfinish_reset(uhci);\r\nuhci->dead = 1;\r\n++uhci->frame_number;\r\n}\r\nstatic void check_and_reset_hc(struct uhci_hcd *uhci)\r\n{\r\nif (uhci->check_and_reset_hc(uhci))\r\nfinish_reset(uhci);\r\n}\r\nstatic void uhci_generic_reset_hc(struct uhci_hcd *uhci)\r\n{\r\nuhci_writew(uhci, USBCMD_HCRESET, USBCMD);\r\nmb();\r\nudelay(5);\r\nif (uhci_readw(uhci, USBCMD) & USBCMD_HCRESET)\r\ndev_warn(uhci_dev(uhci), "HCRESET not completed yet!\n");\r\nuhci_writew(uhci, 0, USBINTR);\r\nuhci_writew(uhci, 0, USBCMD);\r\n}\r\nstatic int uhci_generic_check_and_reset_hc(struct uhci_hcd *uhci)\r\n{\r\nunsigned int cmd, intr;\r\ncmd = uhci_readw(uhci, USBCMD);\r\nif ((cmd & USBCMD_RS) || !(cmd & USBCMD_CF) || !(cmd & USBCMD_EGSM)) {\r\ndev_dbg(uhci_dev(uhci), "%s: cmd = 0x%04x\n",\r\n__func__, cmd);\r\ngoto reset_needed;\r\n}\r\nintr = uhci_readw(uhci, USBINTR);\r\nif (intr & (~USBINTR_RESUME)) {\r\ndev_dbg(uhci_dev(uhci), "%s: intr = 0x%04x\n",\r\n__func__, intr);\r\ngoto reset_needed;\r\n}\r\nreturn 0;\r\nreset_needed:\r\ndev_dbg(uhci_dev(uhci), "Performing full reset\n");\r\nuhci_generic_reset_hc(uhci);\r\nreturn 1;\r\n}\r\nstatic void configure_hc(struct uhci_hcd *uhci)\r\n{\r\nuhci_writeb(uhci, USBSOF_DEFAULT, USBSOF);\r\nuhci_writel(uhci, uhci->frame_dma_handle, USBFLBASEADD);\r\nuhci_writew(uhci, uhci->frame_number & UHCI_MAX_SOF_NUMBER,\r\nUSBFRNUM);\r\nif (uhci->configure_hc)\r\nuhci->configure_hc(uhci);\r\n}\r\nstatic int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)\r\n{\r\nif (ignore_oc)\r\nreturn 1;\r\nreturn uhci->resume_detect_interrupts_are_broken ?\r\nuhci->resume_detect_interrupts_are_broken(uhci) : 0;\r\n}\r\nstatic int global_suspend_mode_is_broken(struct uhci_hcd *uhci)\r\n{\r\nreturn uhci->global_suspend_mode_is_broken ?\r\nuhci->global_suspend_mode_is_broken(uhci) : 0;\r\n}\r\nstatic void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state)\r\n__releases(uhci->lock)\r\n__acquires(uhci->lock)\r\n{\r\nint auto_stop;\r\nint int_enable, egsm_enable, wakeup_enable;\r\nstruct usb_device *rhdev = uhci_to_hcd(uhci)->self.root_hub;\r\nauto_stop = (new_state == UHCI_RH_AUTO_STOPPED);\r\ndev_dbg(&rhdev->dev, "%s%s\n", __func__,\r\n(auto_stop ? " (auto-stop)" : ""));\r\negsm_enable = USBCMD_EGSM;\r\nuhci->RD_enable = 1;\r\nint_enable = USBINTR_RESUME;\r\nwakeup_enable = 1;\r\nif (auto_stop) {\r\nif (!device_may_wakeup(&rhdev->dev))\r\nint_enable = 0;\r\n} else {\r\n#ifdef CONFIG_PM\r\nif (!rhdev->do_remote_wakeup)\r\nwakeup_enable = 0;\r\n#endif\r\n}\r\nif (!wakeup_enable || global_suspend_mode_is_broken(uhci))\r\negsm_enable = 0;\r\nif (!wakeup_enable || resume_detect_interrupts_are_broken(uhci) ||\r\n!int_enable)\r\nuhci->RD_enable = int_enable = 0;\r\nuhci_writew(uhci, int_enable, USBINTR);\r\nuhci_writew(uhci, egsm_enable | USBCMD_CF, USBCMD);\r\nmb();\r\nudelay(5);\r\nif (!auto_stop && !(uhci_readw(uhci, USBSTS) & USBSTS_HCH)) {\r\nuhci->rh_state = UHCI_RH_SUSPENDING;\r\nspin_unlock_irq(&uhci->lock);\r\nmsleep(1);\r\nspin_lock_irq(&uhci->lock);\r\nif (uhci->dead)\r\nreturn;\r\n}\r\nif (!(uhci_readw(uhci, USBSTS) & USBSTS_HCH))\r\ndev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");\r\nuhci_get_current_frame_number(uhci);\r\nuhci->rh_state = new_state;\r\nuhci->is_stopped = UHCI_IS_STOPPED;\r\nif (!int_enable && wakeup_enable)\r\nset_bit(HCD_FLAG_POLL_RH, &uhci_to_hcd(uhci)->flags);\r\nelse\r\nclear_bit(HCD_FLAG_POLL_RH, &uhci_to_hcd(uhci)->flags);\r\nuhci_scan_schedule(uhci);\r\nuhci_fsbr_off(uhci);\r\n}\r\nstatic void start_rh(struct uhci_hcd *uhci)\r\n{\r\nuhci->is_stopped = 0;\r\nuhci_writew(uhci, USBCMD_RS | USBCMD_CF | USBCMD_MAXP, USBCMD);\r\nuhci_writew(uhci, USBINTR_TIMEOUT | USBINTR_RESUME |\r\nUSBINTR_IOC | USBINTR_SP, USBINTR);\r\nmb();\r\nuhci->rh_state = UHCI_RH_RUNNING;\r\nset_bit(HCD_FLAG_POLL_RH, &uhci_to_hcd(uhci)->flags);\r\n}\r\nstatic void wakeup_rh(struct uhci_hcd *uhci)\r\n__releases(uhci->lock)\r\n__acquires(uhci->lock)\r\n{\r\ndev_dbg(&uhci_to_hcd(uhci)->self.root_hub->dev,\r\n"%s%s\n", __func__,\r\nuhci->rh_state == UHCI_RH_AUTO_STOPPED ?\r\n" (auto-start)" : "");\r\nif (uhci->rh_state == UHCI_RH_SUSPENDED) {\r\nunsigned egsm;\r\negsm = uhci_readw(uhci, USBCMD) & USBCMD_EGSM;\r\nuhci->rh_state = UHCI_RH_RESUMING;\r\nuhci_writew(uhci, USBCMD_FGR | USBCMD_CF | egsm, USBCMD);\r\nspin_unlock_irq(&uhci->lock);\r\nmsleep(20);\r\nspin_lock_irq(&uhci->lock);\r\nif (uhci->dead)\r\nreturn;\r\nuhci_writew(uhci, USBCMD_CF, USBCMD);\r\nmb();\r\nudelay(4);\r\nif (uhci_readw(uhci, USBCMD) & USBCMD_FGR)\r\ndev_warn(uhci_dev(uhci), "FGR not stopped yet!\n");\r\n}\r\nstart_rh(uhci);\r\nmod_timer(&uhci_to_hcd(uhci)->rh_timer, jiffies);\r\n}\r\nstatic irqreturn_t uhci_irq(struct usb_hcd *hcd)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nunsigned short status;\r\nstatus = uhci_readw(uhci, USBSTS);\r\nif (!(status & ~USBSTS_HCH))\r\nreturn IRQ_NONE;\r\nuhci_writew(uhci, status, USBSTS);\r\nif (status & ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {\r\nif (status & USBSTS_HSE)\r\ndev_err(uhci_dev(uhci), "host system error, "\r\n"PCI problems?\n");\r\nif (status & USBSTS_HCPE)\r\ndev_err(uhci_dev(uhci), "host controller process "\r\n"error, something bad happened!\n");\r\nif (status & USBSTS_HCH) {\r\nspin_lock(&uhci->lock);\r\nif (uhci->rh_state >= UHCI_RH_RUNNING) {\r\ndev_err(uhci_dev(uhci),\r\n"host controller halted, "\r\n"very bad!\n");\r\nif (debug > 1 && errbuf) {\r\nuhci_sprint_schedule(uhci,\r\nerrbuf, ERRBUF_LEN);\r\nlprintk(errbuf);\r\n}\r\nuhci_hc_died(uhci);\r\nusb_hc_died(hcd);\r\nmod_timer(&hcd->rh_timer, jiffies);\r\n}\r\nspin_unlock(&uhci->lock);\r\n}\r\n}\r\nif (status & USBSTS_RD)\r\nusb_hcd_poll_rh_status(hcd);\r\nelse {\r\nspin_lock(&uhci->lock);\r\nuhci_scan_schedule(uhci);\r\nspin_unlock(&uhci->lock);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void uhci_get_current_frame_number(struct uhci_hcd *uhci)\r\n{\r\nif (!uhci->is_stopped) {\r\nunsigned delta;\r\ndelta = (uhci_readw(uhci, USBFRNUM) - uhci->frame_number) &\r\n(UHCI_NUMFRAMES - 1);\r\nuhci->frame_number += delta;\r\n}\r\n}\r\nstatic void release_uhci(struct uhci_hcd *uhci)\r\n{\r\nint i;\r\nif (DEBUG_CONFIGURED) {\r\nspin_lock_irq(&uhci->lock);\r\nuhci->is_initialized = 0;\r\nspin_unlock_irq(&uhci->lock);\r\ndebugfs_remove(uhci->dentry);\r\n}\r\nfor (i = 0; i < UHCI_NUM_SKELQH; i++)\r\nuhci_free_qh(uhci, uhci->skelqh[i]);\r\nuhci_free_td(uhci, uhci->term_td);\r\ndma_pool_destroy(uhci->qh_pool);\r\ndma_pool_destroy(uhci->td_pool);\r\nkfree(uhci->frame_cpu);\r\ndma_free_coherent(uhci_dev(uhci),\r\nUHCI_NUMFRAMES * sizeof(*uhci->frame),\r\nuhci->frame, uhci->frame_dma_handle);\r\n}\r\nstatic int uhci_start(struct usb_hcd *hcd)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nint retval = -EBUSY;\r\nint i;\r\nstruct dentry __maybe_unused *dentry;\r\nhcd->uses_new_polling = 1;\r\nspin_lock_init(&uhci->lock);\r\nsetup_timer(&uhci->fsbr_timer, uhci_fsbr_timeout,\r\n(unsigned long) uhci);\r\nINIT_LIST_HEAD(&uhci->idle_qh_list);\r\ninit_waitqueue_head(&uhci->waitqh);\r\n#ifdef UHCI_DEBUG_OPS\r\ndentry = debugfs_create_file(hcd->self.bus_name,\r\nS_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root,\r\nuhci, &uhci_debug_operations);\r\nif (!dentry) {\r\ndev_err(uhci_dev(uhci), "couldn't create uhci debugfs entry\n");\r\nreturn -ENOMEM;\r\n}\r\nuhci->dentry = dentry;\r\n#endif\r\nuhci->frame = dma_alloc_coherent(uhci_dev(uhci),\r\nUHCI_NUMFRAMES * sizeof(*uhci->frame),\r\n&uhci->frame_dma_handle, 0);\r\nif (!uhci->frame) {\r\ndev_err(uhci_dev(uhci), "unable to allocate "\r\n"consistent memory for frame list\n");\r\ngoto err_alloc_frame;\r\n}\r\nmemset(uhci->frame, 0, UHCI_NUMFRAMES * sizeof(*uhci->frame));\r\nuhci->frame_cpu = kcalloc(UHCI_NUMFRAMES, sizeof(*uhci->frame_cpu),\r\nGFP_KERNEL);\r\nif (!uhci->frame_cpu) {\r\ndev_err(uhci_dev(uhci), "unable to allocate "\r\n"memory for frame pointers\n");\r\ngoto err_alloc_frame_cpu;\r\n}\r\nuhci->td_pool = dma_pool_create("uhci_td", uhci_dev(uhci),\r\nsizeof(struct uhci_td), 16, 0);\r\nif (!uhci->td_pool) {\r\ndev_err(uhci_dev(uhci), "unable to create td dma_pool\n");\r\ngoto err_create_td_pool;\r\n}\r\nuhci->qh_pool = dma_pool_create("uhci_qh", uhci_dev(uhci),\r\nsizeof(struct uhci_qh), 16, 0);\r\nif (!uhci->qh_pool) {\r\ndev_err(uhci_dev(uhci), "unable to create qh dma_pool\n");\r\ngoto err_create_qh_pool;\r\n}\r\nuhci->term_td = uhci_alloc_td(uhci);\r\nif (!uhci->term_td) {\r\ndev_err(uhci_dev(uhci), "unable to allocate terminating TD\n");\r\ngoto err_alloc_term_td;\r\n}\r\nfor (i = 0; i < UHCI_NUM_SKELQH; i++) {\r\nuhci->skelqh[i] = uhci_alloc_qh(uhci, NULL, NULL);\r\nif (!uhci->skelqh[i]) {\r\ndev_err(uhci_dev(uhci), "unable to allocate QH\n");\r\ngoto err_alloc_skelqh;\r\n}\r\n}\r\nfor (i = SKEL_ISO + 1; i < SKEL_ASYNC; ++i)\r\nuhci->skelqh[i]->link = LINK_TO_QH(uhci, uhci->skel_async_qh);\r\nuhci->skel_async_qh->link = UHCI_PTR_TERM(uhci);\r\nuhci->skel_term_qh->link = LINK_TO_QH(uhci, uhci->skel_term_qh);\r\nuhci_fill_td(uhci, uhci->term_td, 0, uhci_explen(0) |\r\n(0x7f << TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);\r\nuhci->term_td->link = UHCI_PTR_TERM(uhci);\r\nuhci->skel_async_qh->element = uhci->skel_term_qh->element =\r\nLINK_TO_TD(uhci, uhci->term_td);\r\nfor (i = 0; i < UHCI_NUMFRAMES; i++) {\r\nuhci->frame[i] = uhci_frame_skel_link(uhci, i);\r\n}\r\nmb();\r\nconfigure_hc(uhci);\r\nuhci->is_initialized = 1;\r\nspin_lock_irq(&uhci->lock);\r\nstart_rh(uhci);\r\nspin_unlock_irq(&uhci->lock);\r\nreturn 0;\r\nerr_alloc_skelqh:\r\nfor (i = 0; i < UHCI_NUM_SKELQH; i++) {\r\nif (uhci->skelqh[i])\r\nuhci_free_qh(uhci, uhci->skelqh[i]);\r\n}\r\nuhci_free_td(uhci, uhci->term_td);\r\nerr_alloc_term_td:\r\ndma_pool_destroy(uhci->qh_pool);\r\nerr_create_qh_pool:\r\ndma_pool_destroy(uhci->td_pool);\r\nerr_create_td_pool:\r\nkfree(uhci->frame_cpu);\r\nerr_alloc_frame_cpu:\r\ndma_free_coherent(uhci_dev(uhci),\r\nUHCI_NUMFRAMES * sizeof(*uhci->frame),\r\nuhci->frame, uhci->frame_dma_handle);\r\nerr_alloc_frame:\r\ndebugfs_remove(uhci->dentry);\r\nreturn retval;\r\n}\r\nstatic void uhci_stop(struct usb_hcd *hcd)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nspin_lock_irq(&uhci->lock);\r\nif (HCD_HW_ACCESSIBLE(hcd) && !uhci->dead)\r\nuhci_hc_died(uhci);\r\nuhci_scan_schedule(uhci);\r\nspin_unlock_irq(&uhci->lock);\r\nsynchronize_irq(hcd->irq);\r\ndel_timer_sync(&uhci->fsbr_timer);\r\nrelease_uhci(uhci);\r\n}\r\nstatic int uhci_rh_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nint rc = 0;\r\nspin_lock_irq(&uhci->lock);\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\nrc = -ESHUTDOWN;\r\nelse if (uhci->dead)\r\n;\r\nelse if (hcd->self.root_hub->do_remote_wakeup &&\r\nuhci->resuming_ports) {\r\ndev_dbg(uhci_dev(uhci), "suspend failed because a port "\r\n"is resuming\n");\r\nrc = -EBUSY;\r\n} else\r\nsuspend_rh(uhci, UHCI_RH_SUSPENDED);\r\nspin_unlock_irq(&uhci->lock);\r\nreturn rc;\r\n}\r\nstatic int uhci_rh_resume(struct usb_hcd *hcd)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nint rc = 0;\r\nspin_lock_irq(&uhci->lock);\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\nrc = -ESHUTDOWN;\r\nelse if (!uhci->dead)\r\nwakeup_rh(uhci);\r\nspin_unlock_irq(&uhci->lock);\r\nreturn rc;\r\n}\r\nstatic void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *hep)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nstruct uhci_qh *qh;\r\nspin_lock_irq(&uhci->lock);\r\nqh = (struct uhci_qh *) hep->hcpriv;\r\nif (qh == NULL)\r\ngoto done;\r\nwhile (qh->state != QH_STATE_IDLE) {\r\n++uhci->num_waiting;\r\nspin_unlock_irq(&uhci->lock);\r\nwait_event_interruptible(uhci->waitqh,\r\nqh->state == QH_STATE_IDLE);\r\nspin_lock_irq(&uhci->lock);\r\n--uhci->num_waiting;\r\n}\r\nuhci_free_qh(uhci, qh);\r\ndone:\r\nspin_unlock_irq(&uhci->lock);\r\n}\r\nstatic int uhci_hcd_get_frame_number(struct usb_hcd *hcd)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nunsigned frame_number;\r\nunsigned delta;\r\nframe_number = uhci->frame_number;\r\nbarrier();\r\ndelta = (uhci_readw(uhci, USBFRNUM) - frame_number) &\r\n(UHCI_NUMFRAMES - 1);\r\nreturn frame_number + delta;\r\n}\r\nstatic int uhci_count_ports(struct usb_hcd *hcd)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nunsigned io_size = (unsigned) hcd->rsrc_len;\r\nint port;\r\nfor (port = 0; port < (io_size - USBPORTSC1) / 2; port++) {\r\nunsigned int portstatus;\r\nportstatus = uhci_readw(uhci, USBPORTSC1 + (port * 2));\r\nif (!(portstatus & 0x0080) || portstatus == 0xffff)\r\nbreak;\r\n}\r\nif (debug)\r\ndev_info(uhci_dev(uhci), "detected %d ports\n", port);\r\nif (port > UHCI_RH_MAXCHILD) {\r\ndev_info(uhci_dev(uhci), "port count misdetected? "\r\n"forcing to 2 ports\n");\r\nport = 2;\r\n}\r\nreturn port;\r\n}\r\nstatic int __init uhci_hcd_init(void)\r\n{\r\nint retval = -ENOMEM;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "uhci_hcd: " DRIVER_DESC "%s\n",\r\nignore_oc ? ", overcurrent ignored" : "");\r\nset_bit(USB_UHCI_LOADED, &usb_hcds_loaded);\r\nif (DEBUG_CONFIGURED) {\r\nerrbuf = kmalloc(ERRBUF_LEN, GFP_KERNEL);\r\nif (!errbuf)\r\ngoto errbuf_failed;\r\nuhci_debugfs_root = debugfs_create_dir("uhci", usb_debug_root);\r\nif (!uhci_debugfs_root)\r\ngoto debug_failed;\r\n}\r\nuhci_up_cachep = kmem_cache_create("uhci_urb_priv",\r\nsizeof(struct urb_priv), 0, 0, NULL);\r\nif (!uhci_up_cachep)\r\ngoto up_failed;\r\n#ifdef PLATFORM_DRIVER\r\nretval = platform_driver_register(&PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto clean0;\r\n#endif\r\n#ifdef PCI_DRIVER\r\nretval = pci_register_driver(&PCI_DRIVER);\r\nif (retval < 0)\r\ngoto clean1;\r\n#endif\r\nreturn 0;\r\n#ifdef PCI_DRIVER\r\nclean1:\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nplatform_driver_unregister(&PLATFORM_DRIVER);\r\nclean0:\r\n#endif\r\nkmem_cache_destroy(uhci_up_cachep);\r\nup_failed:\r\ndebugfs_remove(uhci_debugfs_root);\r\ndebug_failed:\r\nkfree(errbuf);\r\nerrbuf_failed:\r\nclear_bit(USB_UHCI_LOADED, &usb_hcds_loaded);\r\nreturn retval;\r\n}\r\nstatic void __exit uhci_hcd_cleanup(void)\r\n{\r\n#ifdef PLATFORM_DRIVER\r\nplatform_driver_unregister(&PLATFORM_DRIVER);\r\n#endif\r\n#ifdef PCI_DRIVER\r\npci_unregister_driver(&PCI_DRIVER);\r\n#endif\r\nkmem_cache_destroy(uhci_up_cachep);\r\ndebugfs_remove(uhci_debugfs_root);\r\nkfree(errbuf);\r\nclear_bit(USB_UHCI_LOADED, &usb_hcds_loaded);\r\n}
