static int raid_match(struct attribute_container *cont, struct device *dev)\r\n{\r\nstruct raid_internal *i = ac_to_raid_internal(cont);\r\n#if defined(CONFIG_SCSI) || defined(CONFIG_SCSI_MODULE)\r\nif (scsi_is_sdev_device(dev)) {\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nif (i->f->cookie != sdev->host->hostt)\r\nreturn 0;\r\nreturn i->f->is_raid(dev);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int raid_setup(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct raid_data *rd;\r\nBUG_ON(dev_get_drvdata(cdev));\r\nrd = kzalloc(sizeof(*rd), GFP_KERNEL);\r\nif (!rd)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&rd->component_list);\r\ndev_set_drvdata(cdev, rd);\r\nreturn 0;\r\n}\r\nstatic int raid_remove(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct raid_data *rd = dev_get_drvdata(cdev);\r\nstruct raid_component *rc, *next;\r\ndev_printk(KERN_ERR, dev, "RAID REMOVE\n");\r\ndev_set_drvdata(cdev, NULL);\r\nlist_for_each_entry_safe(rc, next, &rd->component_list, node) {\r\nlist_del(&rc->node);\r\ndev_printk(KERN_ERR, rc->dev.parent, "RAID COMPONENT REMOVE\n");\r\ndevice_unregister(&rc->dev);\r\n}\r\ndev_printk(KERN_ERR, dev, "RAID REMOVE DONE\n");\r\nkfree(rd);\r\nreturn 0;\r\n}\r\nstatic const char *raid_state_name(enum raid_state state)\r\n{\r\nint i;\r\nchar *name = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(raid_states); i++) {\r\nif (raid_states[i].value == state) {\r\nname = raid_states[i].name;\r\nbreak;\r\n}\r\n}\r\nreturn name;\r\n}\r\nstatic const char *raid_level_name(enum raid_level level)\r\n{\r\nint i;\r\nchar *name = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(raid_levels); i++) {\r\nif (raid_levels[i].value == level) {\r\nname = raid_levels[i].name;\r\nbreak;\r\n}\r\n}\r\nreturn name;\r\n}\r\nstatic void raid_component_release(struct device *dev)\r\n{\r\nstruct raid_component *rc =\r\ncontainer_of(dev, struct raid_component, dev);\r\ndev_printk(KERN_ERR, rc->dev.parent, "COMPONENT RELEASE\n");\r\nput_device(rc->dev.parent);\r\nkfree(rc);\r\n}\r\nint raid_component_add(struct raid_template *r,struct device *raid_dev,\r\nstruct device *component_dev)\r\n{\r\nstruct device *cdev =\r\nattribute_container_find_class_device(&r->raid_attrs.ac,\r\nraid_dev);\r\nstruct raid_component *rc;\r\nstruct raid_data *rd = dev_get_drvdata(cdev);\r\nint err;\r\nrc = kzalloc(sizeof(*rc), GFP_KERNEL);\r\nif (!rc)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&rc->node);\r\ndevice_initialize(&rc->dev);\r\nrc->dev.release = raid_component_release;\r\nrc->dev.parent = get_device(component_dev);\r\nrc->num = rd->component_count++;\r\ndev_set_name(&rc->dev, "component-%d", rc->num);\r\nlist_add_tail(&rc->node, &rd->component_list);\r\nrc->dev.class = &raid_class.class;\r\nerr = device_add(&rc->dev);\r\nif (err)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nlist_del(&rc->node);\r\nrd->component_count--;\r\nput_device(component_dev);\r\nkfree(rc);\r\nreturn err;\r\n}\r\nstruct raid_template *\r\nraid_class_attach(struct raid_function_template *ft)\r\n{\r\nstruct raid_internal *i = kzalloc(sizeof(struct raid_internal),\r\nGFP_KERNEL);\r\nint count = 0;\r\nif (unlikely(!i))\r\nreturn NULL;\r\ni->f = ft;\r\ni->r.raid_attrs.ac.class = &raid_class.class;\r\ni->r.raid_attrs.ac.match = raid_match;\r\ni->r.raid_attrs.ac.attrs = &i->attrs[0];\r\nattribute_container_register(&i->r.raid_attrs.ac);\r\ni->attrs[count++] = &dev_attr_level;\r\ni->attrs[count++] = &dev_attr_resync;\r\ni->attrs[count++] = &dev_attr_state;\r\ni->attrs[count] = NULL;\r\nBUG_ON(count > RAID_NUM_ATTRS);\r\nreturn &i->r;\r\n}\r\nvoid\r\nraid_class_release(struct raid_template *r)\r\n{\r\nstruct raid_internal *i = to_raid_internal(r);\r\nBUG_ON(attribute_container_unregister(&i->r.raid_attrs.ac));\r\nkfree(i);\r\n}\r\nstatic __init int raid_init(void)\r\n{\r\nreturn transport_class_register(&raid_class);\r\n}\r\nstatic __exit void raid_exit(void)\r\n{\r\ntransport_class_unregister(&raid_class);\r\n}
