static sector_t\r\ncchh2blk (struct vtoc_cchh *ptr, struct hd_geometry *geo) {\r\nsector_t cyl;\r\n__u16 head;\r\ncyl = ptr->hh & 0xFFF0;\r\ncyl <<= 12;\r\ncyl |= ptr->cc;\r\nhead = ptr->hh & 0x000F;\r\nreturn cyl * geo->heads * geo->sectors +\r\nhead * geo->sectors;\r\n}\r\nstatic sector_t\r\ncchhb2blk (struct vtoc_cchhb *ptr, struct hd_geometry *geo) {\r\nsector_t cyl;\r\n__u16 head;\r\ncyl = ptr->hh & 0xFFF0;\r\ncyl <<= 12;\r\ncyl |= ptr->cc;\r\nhead = ptr->hh & 0x000F;\r\nreturn cyl * geo->heads * geo->sectors +\r\nhead * geo->sectors +\r\nptr->b;\r\n}\r\nint ibm_partition(struct parsed_partitions *state)\r\n{\r\nstruct block_device *bdev = state->bdev;\r\nint blocksize, res;\r\nloff_t i_size, offset, size, fmt_size;\r\ndasd_information2_t *info;\r\nstruct hd_geometry *geo;\r\nchar type[5] = {0,};\r\nchar name[7] = {0,};\r\nunion label_t {\r\nstruct vtoc_volume_label_cdl vol;\r\nstruct vtoc_volume_label_ldl lnx;\r\nstruct vtoc_cms_label cms;\r\n} *label;\r\nunsigned char *data;\r\nSector sect;\r\nsector_t labelsect;\r\nchar tmp[64];\r\nres = 0;\r\nblocksize = bdev_logical_block_size(bdev);\r\nif (blocksize <= 0)\r\ngoto out_exit;\r\ni_size = i_size_read(bdev->bd_inode);\r\nif (i_size == 0)\r\ngoto out_exit;\r\ninfo = kmalloc(sizeof(dasd_information2_t), GFP_KERNEL);\r\nif (info == NULL)\r\ngoto out_exit;\r\ngeo = kmalloc(sizeof(struct hd_geometry), GFP_KERNEL);\r\nif (geo == NULL)\r\ngoto out_nogeo;\r\nlabel = kmalloc(sizeof(union label_t), GFP_KERNEL);\r\nif (label == NULL)\r\ngoto out_nolab;\r\nif (ioctl_by_bdev(bdev, BIODASDINFO2, (unsigned long)info) != 0 ||\r\nioctl_by_bdev(bdev, HDIO_GETGEO, (unsigned long)geo) != 0)\r\ngoto out_freeall;\r\nif ((info->cu_type == 0x6310 && info->dev_type == 0x9336) ||\r\n(info->cu_type == 0x3880 && info->dev_type == 0x3370))\r\nlabelsect = info->label_block;\r\nelse\r\nlabelsect = info->label_block * (blocksize >> 9);\r\ndata = read_part_sector(state, labelsect, &sect);\r\nif (data == NULL)\r\ngoto out_readerr;\r\nmemcpy(label, data, sizeof(union label_t));\r\nput_dev_sector(sect);\r\nif ((!info->FBA_layout) && (!strcmp(info->type, "ECKD"))) {\r\nstrncpy(type, label->vol.vollbl, 4);\r\nstrncpy(name, label->vol.volid, 6);\r\n} else {\r\nstrncpy(type, label->lnx.vollbl, 4);\r\nstrncpy(name, label->lnx.volid, 6);\r\n}\r\nEBCASC(type, 4);\r\nEBCASC(name, 6);\r\nres = 1;\r\nif (info->format == DASD_FORMAT_LDL) {\r\nif (strncmp(type, "CMS1", 4) == 0) {\r\nblocksize = label->cms.block_size;\r\nif (label->cms.disk_offset != 0) {\r\nsnprintf(tmp, sizeof(tmp), "CMS1/%8s(MDSK):", name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\noffset = label->cms.disk_offset;\r\nsize = (label->cms.block_count - 1)\r\n* (blocksize >> 9);\r\n} else {\r\nsnprintf(tmp, sizeof(tmp), "CMS1/%8s:", name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\noffset = (info->label_block + 1);\r\nsize = label->cms.block_count\r\n* (blocksize >> 9);\r\n}\r\nput_partition(state, 1, offset*(blocksize >> 9),\r\nsize-offset*(blocksize >> 9));\r\n} else {\r\nif (strncmp(type, "LNX1", 4) == 0) {\r\nsnprintf(tmp, sizeof(tmp), "LNX1/%8s:", name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nif (label->lnx.ldl_version == 0xf2) {\r\nfmt_size = label->lnx.formatted_blocks\r\n* (blocksize >> 9);\r\n} else if (!strcmp(info->type, "ECKD")) {\r\nfmt_size = geo->cylinders * geo->heads\r\n* geo->sectors * (blocksize >> 9);\r\n} else {\r\nfmt_size = i_size >> 9;\r\n}\r\nsize = i_size >> 9;\r\nif (fmt_size < size)\r\nsize = fmt_size;\r\noffset = (info->label_block + 1);\r\n} else {\r\nstrlcat(state->pp_buf, "(nonl)", PAGE_SIZE);\r\nsize = i_size >> 9;\r\noffset = (info->label_block + 1);\r\n}\r\nput_partition(state, 1, offset*(blocksize >> 9),\r\nsize-offset*(blocksize >> 9));\r\n}\r\n} else if (info->format == DASD_FORMAT_CDL) {\r\nsector_t blk;\r\nint counter;\r\nif (strncmp(type, "VOL1", 4) == 0) {\r\nsnprintf(tmp, sizeof(tmp), "VOL1/%8s:", name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nblk = cchhb2blk(&label->vol.vtoc, geo) + 1;\r\ncounter = 0;\r\ndata = read_part_sector(state, blk * (blocksize/512),\r\n&sect);\r\nwhile (data != NULL) {\r\nstruct vtoc_format1_label f1;\r\nmemcpy(&f1, data,\r\nsizeof(struct vtoc_format1_label));\r\nput_dev_sector(sect);\r\nif (f1.DS1FMTID == _ascebc['4']\r\n|| f1.DS1FMTID == _ascebc['5']\r\n|| f1.DS1FMTID == _ascebc['7']\r\n|| f1.DS1FMTID == _ascebc['9']) {\r\nblk++;\r\ndata = read_part_sector(state,\r\nblk * (blocksize/512), &sect);\r\ncontinue;\r\n}\r\nif (f1.DS1FMTID != _ascebc['1'] &&\r\nf1.DS1FMTID != _ascebc['8'])\r\nbreak;\r\noffset = cchh2blk(&f1.DS1EXT1.llimit, geo);\r\nsize = cchh2blk(&f1.DS1EXT1.ulimit, geo) -\r\noffset + geo->sectors;\r\nif (counter >= state->limit)\r\nbreak;\r\nput_partition(state, counter + 1,\r\noffset * (blocksize >> 9),\r\nsize * (blocksize >> 9));\r\ncounter++;\r\nblk++;\r\ndata = read_part_sector(state,\r\nblk * (blocksize/512), &sect);\r\n}\r\nif (!data)\r\ngoto out_readerr;\r\n} else\r\nprintk(KERN_WARNING "Warning, expected Label VOL1 not "\r\n"found, treating as CDL formated Disk");\r\n}\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\ngoto out_freeall;\r\nout_readerr:\r\nres = -1;\r\nout_freeall:\r\nkfree(label);\r\nout_nolab:\r\nkfree(geo);\r\nout_nogeo:\r\nkfree(info);\r\nout_exit:\r\nreturn res;\r\n}
