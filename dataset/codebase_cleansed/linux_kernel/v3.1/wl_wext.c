static int wireless_commit(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *rqu, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nDBG_FUNC( "wireless_commit" );\r\nDBG_ENTER(DbgInfo);\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nwl_apply(lp);\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_protocol(struct net_device *dev, struct iw_request_info *info, char *name, char *extra)\r\n{\r\nDBG_FUNC( "wireless_get_protocol" );\r\nDBG_ENTER( DbgInfo );\r\nstrcpy(name, "IEEE 802.11b");\r\nDBG_LEAVE(DbgInfo);\r\nreturn 0;\r\n}\r\nstatic int wireless_set_frequency(struct net_device *dev, struct iw_request_info *info, struct iw_freq *freq, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint channel = 0;\r\nint ret = 0;\r\nDBG_FUNC( "wireless_set_frequency" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif( !capable( CAP_NET_ADMIN )) {\r\nret = -EPERM;\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nif( freq->e == 1 ) {\r\nint f = freq->m / 100000;\r\nchannel = wl_get_chan_from_freq( f );\r\n}\r\nif( freq->e == 0 ) {\r\nchannel = freq->m;\r\n}\r\nif( channel > 14 ) {\r\nchannel = channel | 0x100;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->Channel = channel;\r\nwl_apply( lp );\r\nwl_wext_event_freq( lp->dev );\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_frequency(struct net_device *dev, struct iw_request_info *info, struct iw_freq *freq, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = -1;\r\nDBG_FUNC( "wireless_get_frequency" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CUR_CHANNEL;\r\nret = hcf_get_info( &(lp->hcfCtx), (LTVP)&( lp->ltvRecord ));\r\nif( ret == HCF_SUCCESS ) {\r\nhcf_16 channel = CNV_LITTLE_TO_INT( lp->ltvRecord.u.u16[0] );\r\n#ifdef USE_FREQUENCY\r\nfreq->m = wl_get_freq_from_chan( channel ) * 100000;\r\nfreq->e = 1;\r\n#else\r\nfreq->m = channel;\r\nfreq->e = 0;\r\n#endif\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nret = (ret == HCF_SUCCESS ? 0 : -EFAULT);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_range(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nstruct iw_range *range = (struct iw_range *) extra;\r\nint ret = 0;\r\nint status = -1;\r\nint count;\r\n__u16 *pTxRate;\r\nint retries = 0;\r\nDBG_FUNC( "wireless_get_range" );\r\nDBG_ENTER( DbgInfo );\r\ndata->length = sizeof(struct iw_range);\r\nmemset(range, 0, sizeof(struct iw_range));\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nmemset( range, 0, sizeof( struct iw_range ));\r\nretry:\r\nlp->ltvRecord.len = 1 + (sizeof(*pTxRate) / sizeof(hcf_16));\r\nlp->ltvRecord.typ = CFG_CUR_TX_RATE;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "Get CFG_CUR_TX_RATE failed: 0x%x\n", status );\r\nif (retries < 10) {\r\nretries++;\r\nwl_unlock(lp, &flags);\r\nwl_lock( lp, &flags );\r\nstatus = wl_reset( dev );\r\nif ( status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "reset failed: 0x%x\n", status );\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nwl_unlock(lp, &flags);\r\nwl_lock( lp, &flags );\r\ngoto retry;\r\n} else {\r\nDBG_TRACE( DbgInfo, "Get CFG_CUR_TX_RATE failed: %d retries\n", retries );\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\n}\r\nwl_unlock(lp, &flags);\r\nwl_lock( lp, &flags );\r\npTxRate = (__u16 *)&( lp->ltvRecord.u.u32 );\r\nrange->throughput = CNV_LITTLE_TO_INT( *pTxRate ) * MEGABIT;\r\nif (retries > 0) {\r\nDBG_TRACE( DbgInfo, "Get CFG_CUR_TX_RATE succes: %d retries\n", retries );\r\n}\r\nrange->num_channels = RADIO_CHANNELS;\r\nrange->sensitivity = RADIO_SENSITIVITY_LEVELS;\r\n#ifdef USE_DBM\r\nrange->max_qual.qual = (u_char)HCF_MAX_COMM_QUALITY;\r\nrange->max_qual.level = (u_char)( dbm( HCF_MIN_SIGNAL_LEVEL ) - 1 );\r\nrange->max_qual.noise = (u_char)( dbm( HCF_MIN_NOISE_LEVEL ) - 1 );\r\n#else\r\nrange->max_qual.qual = 100;\r\nrange->max_qual.level = 100;\r\nrange->max_qual.noise = 100;\r\n#endif\r\nrange->num_bitrates = 0;\r\nlp->ltvRecord.len = 6;\r\nlp->ltvRecord.typ = CFG_SUPPORTED_DATA_RATES;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\nfor( count = 0; count < MAX_RATES; count++ )\r\nif( lp->ltvRecord.u.u8[count+2] != 0 ) {\r\nrange->bitrate[count] = lp->ltvRecord.u.u8[count+2] * MEGABIT / 2;\r\nrange->num_bitrates++;\r\n}\r\n} else {\r\nDBG_TRACE( DbgInfo, "CFG_SUPPORTED_DATA_RATES: 0x%x\n", status );\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nrange->min_rts = MIN_RTS_BYTES;\r\nrange->max_rts = MAX_RTS_BYTES;\r\n#if WIRELESS_EXT > 8\r\nwl_unlock(lp, &flags);\r\nwl_lock( lp, &flags );\r\nif( wl_has_wep( &( lp->hcfCtx ))) {\r\nrange->encoding_size[0] = MIN_KEY_SIZE;\r\nrange->encoding_size[1] = MAX_KEY_SIZE;\r\nrange->num_encoding_sizes = 2;\r\nrange->max_encoding_tokens = MAX_KEYS;\r\n}\r\n#endif\r\nrange->txpower_capa = IW_TXPOW_MWATT;\r\nrange->num_txpower = 1;\r\nrange->txpower[0] = RADIO_TX_POWER_MWATT;\r\n#if WIRELESS_EXT > 10\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = WIRELESS_SUPPORT;\r\n#endif\r\n#if WIRELESS_EXT > 11\r\nwl_unlock(lp, &flags);\r\nwl_lock( lp, &flags );\r\nDBG_TRACE( DbgInfo, "calling wl_wireless_stats\n" );\r\nwl_wireless_stats( lp->dev );\r\nrange->avg_qual = lp->wstats.qual;\r\nDBG_TRACE( DbgInfo, "wl_wireless_stats done\n" );\r\n#endif\r\nrange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\r\nIW_EVENT_CAPA_MASK(SIOCGIWAP) |\r\nIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\r\nrange->event_capa[1] = IW_EVENT_CAPA_K_1;\r\nrange->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVREGISTERED) |\r\nIW_EVENT_CAPA_MASK(IWEVCUSTOM) |\r\nIW_EVENT_CAPA_MASK(IWEVEXPIRED));\r\nrange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_CIPHER_TKIP;\r\nout_unlock:\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nDBG_LEAVE(DbgInfo);\r\nreturn ret;\r\n}\r\nstatic int wireless_get_bssid(struct net_device *dev, struct iw_request_info *info, struct sockaddr *ap_addr, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\n#if 1\r\nint status = -1;\r\n#endif\r\nDBG_FUNC( "wireless_get_bssid" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nmemset( &ap_addr->sa_data, 0, ETH_ALEN );\r\nap_addr->sa_family = ARPHRD_ETHER;\r\nmemcpy(&ap_addr->sa_data, lp->dev->dev_addr, ETH_ALEN);\r\n#if 1\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_STA ) {\r\nlp->ltvRecord.typ = CFG_CUR_BSSID;\r\nlp->ltvRecord.len = 4;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\nmemcpy(&ap_addr->sa_data, lp->ltvRecord.u.u8, ETH_ALEN);\r\n} else {\r\nret = -EFAULT;\r\n}\r\n}\r\n#endif\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE(DbgInfo);\r\nreturn ret;\r\n}\r\nstatic int wireless_get_ap_list (struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret;\r\nint num_aps = -1;\r\nint sec_count = 0;\r\nhcf_32 count;\r\nstruct sockaddr *hwa = NULL;\r\nstruct iw_quality *qual = NULL;\r\n#ifdef WARP\r\nScanResult *p = &lp->scan_results;\r\n#else\r\nProbeResult *p = &lp->probe_results;\r\n#endif\r\nDBG_FUNC( "wireless_get_ap_list" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->scan_results.scan_complete = FALSE;\r\nlp->probe_results.scan_complete = FALSE;\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_SCAN_CHANNELS_2GHZ;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0x7FFF );\r\nret = hcf_put_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nDBG_TRACE( DbgInfo, "CFG_SCAN_CHANNELS_2GHZ result: 0x%x\n", ret );\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_SCAN_SSID;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0 );\r\nret = hcf_put_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nDBG_TRACE( DbgInfo, "CFG_SCAN_SSID to 'any' ret: 0x%x\n", ret );\r\n#ifdef WARP\r\nret = hcf_action( &( lp->hcfCtx ), MDD_ACT_SCAN );\r\n#else\r\nret = hcf_action( &( lp->hcfCtx ), HCF_ACT_ACS_SCAN );\r\n#endif\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nif( ret == HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "SUCCESSFULLY INITIATED SCAN...\n" );\r\nwhile( (*p).scan_complete == FALSE && ret == HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "Waiting for scan results...\n" );\r\nif( sec_count++ > MAX_SCAN_TIME_SEC ) {\r\nret = -EIO;\r\n} else {\r\nfor( count = 0; count < 100; count ++ ) {\r\nmdelay( 10 );\r\nschedule( );\r\n}\r\n}\r\n}\r\nrmb();\r\nif ( ret != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, "timeout waiting for scan results\n" );\r\n} else {\r\nnum_aps = (*p).num_aps;\r\nif (num_aps > IW_MAX_AP) {\r\nnum_aps = IW_MAX_AP;\r\n}\r\ndata->length = num_aps;\r\nhwa = (struct sockaddr *)extra;\r\nqual = (struct iw_quality *) extra +\r\n( sizeof( struct sockaddr ) * num_aps );\r\ndata->flags = 0;\r\nfor( count = 0; count < num_aps; count++ ) {\r\n#ifdef WARP\r\nmemcpy( hwa[count].sa_data,\r\n(*p).APTable[count].bssid, ETH_ALEN );\r\n#else\r\nDBG_PRINT("BSSID: %pM\n",\r\n(*p).ProbeTable[count].BSSID);\r\nmemcpy( hwa[count].sa_data,\r\n(*p).ProbeTable[count].BSSID, ETH_ALEN );\r\n#endif\r\n}\r\n(*p).scan_complete = FALSE;\r\nwl_wext_event_scan_complete( lp->dev );\r\n}\r\n}\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_sensitivity(struct net_device *dev, struct iw_request_info *info, struct iw_param *sens, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint dens = sens->value;\r\nDBG_FUNC( "wireless_set_sensitivity" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif(( dens < 1 ) || ( dens > 3 )) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->DistanceBetweenAPs = dens;\r\nwl_apply( lp );\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_sensitivity(struct net_device *dev, struct iw_request_info *info, struct iw_param *sens, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nint ret = 0;\r\nDBG_FUNC( "wireless_get_sensitivity" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nsens->value = lp->DistanceBetweenAPs;\r\nsens->fixed = 0;\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_essid(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *ssid)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nDBG_FUNC( "wireless_set_essid" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (data->flags != 0 && data->length > HCF_MAX_NAME_LEN + 1) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nmemset( lp->NetworkName, 0, sizeof( lp->NetworkName ));\r\nif( data->flags == 0 ) {\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_STA ) {\r\nstrcpy( lp->NetworkName, "ANY" );\r\n} else {\r\nstrcpy( lp->NetworkName, PARM_DEFAULT_SSID );\r\n}\r\n} else {\r\nmemcpy( lp->NetworkName, ssid, data->length );\r\n}\r\nDBG_NOTICE( DbgInfo, "set NetworkName: %s\n", ssid );\r\nwl_apply( lp );\r\nwl_wext_event_essid( lp->dev );\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_essid(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *essid)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint status = -1;\r\nwvName_t *pName;\r\nDBG_FUNC( "wireless_get_essid" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->ltvRecord.len = 1 + ( sizeof( *pName ) / sizeof( hcf_16 ));\r\n#if 1\r\nlp->ltvRecord.typ = CFG_DESIRED_SSID;\r\n#endif\r\n#if 1\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nlp->ltvRecord.typ = CFG_CNF_OWN_SSID;\r\n}\r\n#endif\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\npName = (wvName_t *)&( lp->ltvRecord.u.u32 );\r\npName->length = CNV_LITTLE_TO_INT( pName->length );\r\ndata->length = pName->length;\r\ndata->length = pName->length + 1;\r\nif( pName->length < HCF_MAX_NAME_LEN ) {\r\npName->name[pName->length] = '\0';\r\n}\r\ndata->flags = 1;\r\n#if 1\r\n#ifdef RETURN_CURRENT_NETWORKNAME\r\nif( pName->name[0] == '\0' ) {\r\nlp->ltvRecord.len = 1 + ( sizeof(*pName ) / sizeof( hcf_16 ));\r\nlp->ltvRecord.typ = CFG_CUR_SSID;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\npName = (wvName_t *)&( lp->ltvRecord.u.u32 );\r\npName->length = CNV_LITTLE_TO_INT( pName->length );\r\ndata->length = pName->length + 1;\r\nif( pName->length < HCF_MAX_NAME_LEN ) {\r\npName->name[pName->length] = '\0';\r\n}\r\ndata->flags = 1;\r\n} else {\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\n}\r\n#endif\r\n#endif\r\ndata->length--;\r\nif (pName->length > IW_ESSID_MAX_SIZE) {\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nmemcpy(essid, pName->name, pName->length);\r\n} else {\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nout_unlock:\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_encode(struct net_device *dev, struct iw_request_info *info, struct iw_point *erq, char *keybuf)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\n#if 1\r\nhcf_8 encryption_state;\r\n#endif\r\nDBG_FUNC( "wireless_set_encode" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nif( !wl_has_wep( &( lp->hcfCtx ))) {\r\nDBG_WARNING( DbgInfo, "WEP not supported on this device\n" );\r\nret = -EOPNOTSUPP;\r\ngoto out_unlock;\r\n}\r\nDBG_NOTICE( DbgInfo, "pointer: %p, length: %d, flags: %#x\n",\r\nkeybuf, erq->length,\r\nerq->flags);\r\nencryption_state = lp->EnableEncryption;\r\nif((erq->length) != 0) {\r\nint index = ( erq->flags & IW_ENCODE_INDEX ) - 1;\r\nint tk = lp->TransmitKeyID - 1;\r\nswitch(erq->length) {\r\ncase 0:\r\nbreak;\r\ncase MIN_KEY_SIZE:\r\ncase MAX_KEY_SIZE:\r\nif(( index < 0 ) || ( index >= MAX_KEYS )) {\r\nindex = tk;\r\n}\r\nmemset( lp->DefaultKeys.key[index].key, 0, MAX_KEY_SIZE );\r\nmemcpy( lp->DefaultKeys.key[index].key, keybuf, erq->length);\r\nlp->DefaultKeys.key[index].len = erq->length;\r\nDBG_NOTICE( DbgInfo, "encoding.length: %d\n", erq->length );\r\nDBG_NOTICE( DbgInfo, "set key: %s(%d) [%d]\n", lp->DefaultKeys.key[index].key,\r\nlp->DefaultKeys.key[index].len, index );\r\nif(( index == tk ) && ( lp->DefaultKeys.key[tk].len > 0 )) {\r\nlp->EnableEncryption = 1;\r\n}\r\nbreak;\r\ndefault:\r\nDBG_WARNING( DbgInfo, "Invalid Key length\n" );\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\n} else {\r\nint index = ( erq->flags & IW_ENCODE_INDEX ) - 1;\r\nif(( index >= 0 ) && ( index < MAX_KEYS )) {\r\nDBG_NOTICE( DbgInfo, "index: %d; len: %d\n", index,\r\nlp->DefaultKeys.key[index].len );\r\nif( lp->DefaultKeys.key[index].len > 0 ) {\r\nlp->TransmitKeyID = index + 1;\r\nlp->EnableEncryption = 1;\r\n} else {\r\nDBG_WARNING( DbgInfo, "Problem setting the current TxKey\n" );\r\nDBG_LEAVE( DbgInfo );\r\nret = -EINVAL;\r\n}\r\n}\r\n}\r\nif( erq->flags & IW_ENCODE_DISABLED ) {\r\nlp->EnableEncryption = 0;\r\n} else {\r\nlp->EnableEncryption = 1;\r\n}\r\nif( erq->flags & IW_ENCODE_RESTRICTED ) {\r\nDBG_WARNING( DbgInfo, "IW_ENCODE_RESTRICTED invalid\n" );\r\nret = -EINVAL;\r\n}\r\nDBG_TRACE( DbgInfo, "encryption_state : %d\n", encryption_state );\r\nDBG_TRACE( DbgInfo, "lp->EnableEncryption : %d\n", lp->EnableEncryption );\r\nDBG_TRACE( DbgInfo, "erq->length : %d\n",\r\nerq->length);\r\nDBG_TRACE( DbgInfo, "erq->flags : 0x%x\n",\r\nerq->flags);\r\nif( ret == 0 ) {\r\nDBG_NOTICE( DbgInfo, "encrypt: %d, ID: %d\n", lp->EnableEncryption,\r\nlp->TransmitKeyID );\r\nif( lp->EnableEncryption == encryption_state ) {\r\nif( erq->length != 0 ) {\r\nwl_set_wep_keys( lp );\r\n}\r\n} else {\r\nwl_apply( lp );\r\n}\r\n}\r\nwl_wext_event_encode( dev );\r\nout_unlock:\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_encode(struct net_device *dev, struct iw_request_info *info, struct iw_point *erq, char *key)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint index;\r\nDBG_FUNC( "wireless_get_encode" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_NOTICE(DbgInfo, "GIWENCODE: encrypt: %d, ID: %d\n", lp->EnableEncryption, lp->TransmitKeyID);\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif( !capable( CAP_NET_ADMIN )) {\r\nret = -EPERM;\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nif( !wl_has_wep( &( lp->hcfCtx ))) {\r\nret = -EOPNOTSUPP;\r\ngoto out_unlock;\r\n}\r\nindex = (erq->flags & IW_ENCODE_INDEX ) - 1;\r\nerq->flags = 0;\r\nif( lp->EnableEncryption == 0 ) {\r\nerq->flags |= IW_ENCODE_DISABLED;\r\n}\r\nif(( index < 0 ) || ( index >= MAX_KEYS )) {\r\nindex = lp->TransmitKeyID - 1;\r\n}\r\nerq->flags |= index + 1;\r\nerq->length = lp->DefaultKeys.key[index].len;\r\nmemcpy(key, lp->DefaultKeys.key[index].key, erq->length);\r\nout_unlock:\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_nickname(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *nickname)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nDBG_FUNC( "wireless_set_nickname" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n#if 0\r\nif( !capable(CAP_NET_ADMIN )) {\r\nret = -EPERM;\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\n#endif\r\nif(data->length > HCF_MAX_NAME_LEN) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nmemset( lp->StationName, 0, sizeof( lp->StationName ));\r\nmemcpy( lp->StationName, nickname, data->length );\r\nwl_apply( lp );\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_nickname(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *nickname)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint status = -1;\r\nwvName_t *pName;\r\nDBG_FUNC( "wireless_get_nickname" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->ltvRecord.len = 1 + ( sizeof( *pName ) / sizeof( hcf_16 ));\r\nlp->ltvRecord.typ = CFG_CNF_OWN_NAME;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\npName = (wvName_t *)&( lp->ltvRecord.u.u32 );\r\npName->length = CNV_LITTLE_TO_INT( pName->length );\r\nif ( pName->length > IW_ESSID_MAX_SIZE ) {\r\nret = -EFAULT;\r\n} else {\r\ndata->length = pName->length;\r\nmemcpy(nickname, pName->name, pName->length);\r\n}\r\n} else {\r\nret = -EFAULT;\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE(DbgInfo);\r\nreturn ret;\r\n}\r\nstatic int wireless_set_porttype(struct net_device *dev, struct iw_request_info *info, __u32 *mode, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nhcf_16 portType;\r\nhcf_16 createIBSS;\r\nDBG_FUNC( "wireless_set_porttype" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nswitch( *mode ) {\r\ncase IW_MODE_ADHOC:\r\nportType = 1;\r\ncreateIBSS = 1;\r\nlp->DownloadFirmware = WVLAN_DRV_MODE_STA;\r\nbreak;\r\ncase IW_MODE_AUTO:\r\ncase IW_MODE_INFRA:\r\nportType = 1;\r\ncreateIBSS = 0;\r\nlp->DownloadFirmware = WVLAN_DRV_MODE_STA;\r\nbreak;\r\n#if 0\r\ncase IW_MODE_MASTER:\r\nportType = 1;\r\nlp->CreateIBSS = 0;\r\nlp->DownloadFirmware = WVLAN_DRV_MODE_AP;\r\nbreak;\r\n#endif\r\ndefault:\r\nportType = 0;\r\ncreateIBSS = 0;\r\nret = -EINVAL;\r\n}\r\nif( portType != 0 ) {\r\nif( ( lp->PortType != portType ) || (lp->CreateIBSS != createIBSS)) {\r\nlp->PortType = portType;\r\nlp->CreateIBSS = createIBSS;\r\nwl_go( lp );\r\nwl_wext_event_mode( lp->dev );\r\n}\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_porttype(struct net_device *dev, struct iw_request_info *info, __u32 *mode, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint status = -1;\r\nhcf_16 *pPortType;\r\nDBG_FUNC( "wireless_get_porttype" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->ltvRecord.len = 1 + ( sizeof( *pPortType ) / sizeof( hcf_16 ));\r\nlp->ltvRecord.typ = CFG_CNF_PORT_TYPE;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\npPortType = (hcf_16 *)&( lp->ltvRecord.u.u32 );\r\n*pPortType = CNV_LITTLE_TO_INT( *pPortType );\r\nswitch( *pPortType ) {\r\ncase 1:\r\n#if 0\r\n#if (HCF_TYPE) & HCF_TYPE_AP\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\n*mode = IW_MODE_MASTER;\r\n} else {\r\n*mode = IW_MODE_INFRA;\r\n}\r\n#else\r\n*mode = IW_MODE_INFRA;\r\n#endif\r\n#endif\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\n*mode = IW_MODE_MASTER;\r\n} else {\r\nif( lp->CreateIBSS ) {\r\n*mode = IW_MODE_ADHOC;\r\n} else {\r\n*mode = IW_MODE_INFRA;\r\n}\r\n}\r\nbreak;\r\ncase 3:\r\n*mode = IW_MODE_ADHOC;\r\nbreak;\r\ndefault:\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n} else {\r\nret = -EFAULT;\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_power(struct net_device *dev, struct iw_request_info *info, struct iw_param *wrq, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nDBG_FUNC( "wireless_set_power" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nDBG_PRINT( "THIS CORRUPTS PMEnabled ;?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n" );\r\n#if 0\r\nif( !capable( CAP_NET_ADMIN )) {\r\nret = -EPERM;\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\n#endif\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nif( wrq->disabled ) {\r\nlp->PMEnabled = 0;\r\n} else {\r\nlp->PMEnabled = 1;\r\n}\r\nwl_apply( lp );\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_power(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nDBG_FUNC( "wireless_get_power" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nDBG_PRINT( "THIS IS PROBABLY AN OVER-SIMPLIFICATION ;?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n" );\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nrrq->flags = 0;\r\nrrq->value = 0;\r\nif( lp->PMEnabled ) {\r\nrrq->disabled = 0;\r\n} else {\r\nrrq->disabled = 1;\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_tx_power(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nDBG_FUNC( "wireless_get_tx_power" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\n#ifdef USE_POWER_DBM\r\nrrq->value = RADIO_TX_POWER_DBM;\r\nrrq->flags = IW_TXPOW_DBM;\r\n#else\r\nrrq->value = RADIO_TX_POWER_MWATT;\r\nrrq->flags = IW_TXPOW_MWATT;\r\n#endif\r\nrrq->fixed = 1;\r\nrrq->disabled = 0;\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_rts_threshold (struct net_device *dev, struct iw_request_info *info, struct iw_param *rts, char *extra)\r\n{\r\nint ret = 0;\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint rthr = rts->value;\r\nDBG_FUNC( "wireless_set_rts_threshold" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif(rts->fixed == 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n#if WIRELESS_EXT > 8\r\nif( rts->disabled ) {\r\nrthr = 2347;\r\n}\r\n#endif\r\nif(( rthr < 256 ) || ( rthr > 2347 )) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->RTSThreshold = rthr;\r\nwl_apply( lp );\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_rts_threshold (struct net_device *dev, struct iw_request_info *info, struct iw_param *rts, char *extra)\r\n{\r\nint ret = 0;\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nDBG_FUNC( "wireless_get_rts_threshold" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nrts->value = lp->RTSThreshold;\r\n#if WIRELESS_EXT > 8\r\nrts->disabled = ( rts->value == 2347 );\r\n#endif\r\nrts->fixed = 1;\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_rate(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\n#ifdef WARP\r\nint status = -1;\r\nint index = 0;\r\n#endif\r\nDBG_FUNC( "wireless_set_rate" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\n#ifdef WARP\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_CUR_CHANNEL;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\nindex = ( CNV_LITTLE_TO_INT( lp->ltvRecord.u.u16[0] ) & 0x100 ) ? 1 : 0;\r\nDBG_PRINT( "Index: %d\n", index );\r\n} else {\r\nDBG_ERROR( DbgInfo, "Could not determine radio frequency\n" );\r\nDBG_LEAVE( DbgInfo );\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif( rrq->value > 0 &&\r\nrrq->value <= 1 * MEGABIT ) {\r\nlp->TxRateControl[index] = 0x0001;\r\n}\r\nelse if( rrq->value > 1 * MEGABIT &&\r\nrrq->value <= 2 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0002;\r\n} else {\r\nlp->TxRateControl[index] = 0x0003;\r\n}\r\n}\r\nelse if( rrq->value > 2 * MEGABIT &&\r\nrrq->value <= 5 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0004;\r\n} else {\r\nlp->TxRateControl[index] = 0x0007;\r\n}\r\n}\r\nelse if( rrq->value > 5 * MEGABIT &&\r\nrrq->value <= 6 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0010;\r\n} else {\r\nlp->TxRateControl[index] = 0x0017;\r\n}\r\n}\r\nelse if( rrq->value > 6 * MEGABIT &&\r\nrrq->value <= 9 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0020;\r\n} else {\r\nlp->TxRateControl[index] = 0x0037;\r\n}\r\n}\r\nelse if( rrq->value > 9 * MEGABIT &&\r\nrrq->value <= 11 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0008;\r\n} else {\r\nlp->TxRateControl[index] = 0x003F;\r\n}\r\n}\r\nelse if( rrq->value > 11 * MEGABIT &&\r\nrrq->value <= 12 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0040;\r\n} else {\r\nlp->TxRateControl[index] = 0x007F;\r\n}\r\n}\r\nelse if( rrq->value > 12 * MEGABIT &&\r\nrrq->value <= 18 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0080;\r\n} else {\r\nlp->TxRateControl[index] = 0x00FF;\r\n}\r\n}\r\nelse if( rrq->value > 18 * MEGABIT &&\r\nrrq->value <= 24 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0100;\r\n} else {\r\nlp->TxRateControl[index] = 0x01FF;\r\n}\r\n}\r\nelse if( rrq->value > 24 * MEGABIT &&\r\nrrq->value <= 36 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0200;\r\n} else {\r\nlp->TxRateControl[index] = 0x03FF;\r\n}\r\n}\r\nelse if( rrq->value > 36 * MEGABIT &&\r\nrrq->value <= 48 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0400;\r\n} else {\r\nlp->TxRateControl[index] = 0x07FF;\r\n}\r\n}\r\nelse if( rrq->value > 48 * MEGABIT &&\r\nrrq->value <= 54 * MEGABIT ) {\r\nif( rrq->fixed == 1 ) {\r\nlp->TxRateControl[index] = 0x0800;\r\n} else {\r\nlp->TxRateControl[index] = 0x0FFF;\r\n}\r\n}\r\nelse if( rrq->fixed == 0 ) {\r\nlp->TxRateControl[index] = PARM_MAX_TX_RATE;\r\n} else {\r\nrrq->value = 0;\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\n#else\r\nif( rrq->value > 0 &&\r\nrrq->value <= 1 * MEGABIT ) {\r\nlp->TxRateControl[0] = 1;\r\n}\r\nelse if( rrq->value > 1 * MEGABIT &&\r\nrrq->value <= 2 * MEGABIT ) {\r\nif( rrq->fixed ) {\r\nlp->TxRateControl[0] = 2;\r\n} else {\r\nlp->TxRateControl[0] = 6;\r\n}\r\n}\r\nelse if( rrq->value > 2 * MEGABIT &&\r\nrrq->value <= 5 * MEGABIT ) {\r\nif( rrq->fixed ) {\r\nlp->TxRateControl[0] = 4;\r\n} else {\r\nlp->TxRateControl[0] = 7;\r\n}\r\n}\r\nelse if( rrq->value > 5 * MEGABIT &&\r\nrrq->value <= 11 * MEGABIT ) {\r\nif( rrq->fixed) {\r\nlp->TxRateControl[0] = 5;\r\n} else {\r\nlp->TxRateControl[0] = 3;\r\n}\r\n}\r\nelse if( rrq->fixed == 0 ) {\r\nlp->TxRateControl[0] = 3;\r\n} else {\r\nrrq->value = 0;\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\n#endif\r\nwl_apply( lp );\r\nout_unlock:\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_rate(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint status = -1;\r\nhcf_16 txRate;\r\nDBG_FUNC( "wireless_get_rate" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nlp->ltvRecord.len = 1 + ( sizeof(txRate)/sizeof(hcf_16));\r\nlp->ltvRecord.typ = CFG_CUR_TX_RATE;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\n#ifdef WARP\r\ntxRate = CNV_LITTLE_TO_INT( lp->ltvRecord.u.u16[0] );\r\nif( txRate & 0x0001 ) {\r\ntxRate = 1;\r\n}\r\nelse if( txRate & 0x0002 ) {\r\ntxRate = 2;\r\n}\r\nelse if( txRate & 0x0004 ) {\r\ntxRate = 5;\r\n}\r\nelse if( txRate & 0x0008 ) {\r\ntxRate = 11;\r\n}\r\nelse if( txRate & 0x00010 ) {\r\ntxRate = 6;\r\n}\r\nelse if( txRate & 0x00020 ) {\r\ntxRate = 9;\r\n}\r\nelse if( txRate & 0x00040 ) {\r\ntxRate = 12;\r\n}\r\nelse if( txRate & 0x00080 ) {\r\ntxRate = 18;\r\n}\r\nelse if( txRate & 0x00100 ) {\r\ntxRate = 24;\r\n}\r\nelse if( txRate & 0x00200 ) {\r\ntxRate = 36;\r\n}\r\nelse if( txRate & 0x00400 ) {\r\ntxRate = 48;\r\n}\r\nelse if( txRate & 0x00800 ) {\r\ntxRate = 54;\r\n}\r\n#else\r\ntxRate = (hcf_16)CNV_LITTLE_TO_LONG( lp->ltvRecord.u.u32[0] );\r\n#endif\r\nrrq->value = txRate * MEGABIT;\r\n} else {\r\nrrq->value = 0;\r\nret = -EFAULT;\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_scan(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint status = -1;\r\nint retries = 0;\r\nDBG_FUNC( "wireless_set_scan" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nif((lp->hcfCtx.IFB_CardStat & CARD_STAT_DEFUNCT) != 0)\r\n{\r\nDBG_TRACE( DbgInfo, "CARD is in DEFUNCT mode, reset it to bring it back to life\n" );\r\nwl_reset( dev );\r\n}\r\nretry:\r\nlp->probe_results.scan_complete = FALSE;\r\n#ifdef WARP\r\nlp->ltvRecord.len = 5;\r\nlp->ltvRecord.typ = CFG_SCAN_CHANNEL;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0x3FFF );\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( 0xFFFF );\r\nlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE( 0xFFFF );\r\nlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE( 0x0007 );\r\n#else\r\nlp->ltvRecord.len = 2;\r\nlp->ltvRecord.typ = CFG_SCAN_CHANNEL;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0x7FFF );\r\n#endif\r\nstatus = hcf_put_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nDBG_TRACE( DbgInfo, "CFG_SCAN_CHANNEL result : 0x%x\n", status );\r\nwl_unlock(lp, &flags);\r\nwl_lock( lp, &flags );\r\nif( status != HCF_SUCCESS ) {\r\nretries++;\r\nif(retries <= 10) {\r\nDBG_TRACE( DbgInfo, "Reset card to recover, attempt: %d\n", retries );\r\nwl_reset( dev );\r\nwl_unlock(lp, &flags);\r\nwl_lock( lp, &flags );\r\ngoto retry;\r\n}\r\n}\r\nlp->ltvRecord.len = 18;\r\nlp->ltvRecord.typ = CFG_SCAN_SSID;\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE( 0 );\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE( 0 );\r\nstatus = hcf_put_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nwl_unlock(lp, &flags);\r\nwl_lock( lp, &flags );\r\nDBG_TRACE( DbgInfo, "CFG_SCAN_SSID to 'any' status: 0x%x\n", status );\r\nstatus = hcf_action( &( lp->hcfCtx ), HCF_ACT_ACS_SCAN );\r\nif( status == HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "SUCCESSFULLY INITIATED SCAN...\n" );\r\n} else {\r\nDBG_TRACE( DbgInfo, "INITIATE SCAN FAILED...\n" );\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE(DbgInfo);\r\nreturn ret;\r\n}\r\nstatic int wireless_get_scan(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint count;\r\nchar *buf;\r\nchar *buf_end;\r\nstruct iw_event iwe;\r\nPROBE_RESP *probe_resp;\r\nhcf_8 msg[512];\r\nhcf_8 *wpa_ie;\r\nhcf_16 wpa_ie_len;\r\nDBG_FUNC( "wireless_get_scan" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nif( !lp->probe_results.scan_complete ) {\r\nret = -EAGAIN;\r\ngoto out_unlock;\r\n}\r\nDBG_TRACE( DbgInfo, "SCAN COMPLETE, Num of APs: %d\n",\r\nlp->probe_results.num_aps );\r\nbuf = extra;\r\nbuf_end = extra + IW_SCAN_MAX_DATA;\r\nfor( count = 0; count < lp->probe_results.num_aps; count++ ) {\r\nprobe_resp = (PROBE_RESP *)&lp->probe_results.ProbeTable[count];\r\nmemset( &iwe, 0, sizeof( iwe ));\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy( iwe.u.ap_addr.sa_data, probe_resp->BSSID, ETH_ALEN);\r\niwe.len = IW_EV_ADDR_LEN;\r\nbuf = IWE_STREAM_ADD_EVENT(info, buf, buf_end, &iwe, IW_EV_ADDR_LEN);\r\nmemset( &iwe, 0, sizeof( iwe ));\r\niwe.cmd = SIOCGIWMODE;\r\nif( probe_resp->capability & CAPABILITY_IBSS ) {\r\niwe.u.mode = IW_MODE_INFRA;\r\n} else {\r\niwe.u.mode = IW_MODE_MASTER;\r\n}\r\niwe.len = IW_EV_UINT_LEN;\r\nbuf = IWE_STREAM_ADD_EVENT(info, buf, buf_end, &iwe, IW_EV_UINT_LEN);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVQUAL;\r\niwe.u.qual.level = dbm(probe_resp->signal);\r\niwe.u.qual.noise = dbm(probe_resp->silence);\r\niwe.u.qual.qual = iwe.u.qual.level - iwe.u.qual.noise;\r\niwe.u.qual.updated = lp->probe_results.scan_complete | IW_QUAL_DBM;\r\niwe.len = IW_EV_QUAL_LEN;\r\nbuf = IWE_STREAM_ADD_EVENT(info, buf, buf_end, &iwe, IW_EV_QUAL_LEN);\r\nif( probe_resp->rawData[1] > 0 ) {\r\nmemset( &iwe, 0, sizeof( iwe ));\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.length = probe_resp->rawData[1];\r\niwe.u.data.flags = 1;\r\nbuf = IWE_STREAM_ADD_POINT(info, buf, buf_end, &iwe, &probe_resp->rawData[2]);\r\n}\r\nmemset( &iwe, 0, sizeof( iwe ));\r\niwe.cmd = SIOCGIWENCODE;\r\niwe.u.data.length = 0;\r\nif( probe_resp->capability & CAPABILITY_PRIVACY ) {\r\niwe.u.data.flags |= IW_ENCODE_ENABLED;\r\n} else {\r\niwe.u.data.flags |= IW_ENCODE_DISABLED;\r\n}\r\nbuf = IWE_STREAM_ADD_POINT(info, buf, buf_end, &iwe, NULL);\r\nmemset( &iwe, 0, sizeof( iwe ));\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.len = IW_EV_FREQ_LEN;\r\niwe.u.freq.m = wl_parse_ds_ie( probe_resp );\r\niwe.u.freq.e = 0;\r\nbuf = IWE_STREAM_ADD_EVENT(info, buf, buf_end, &iwe, IW_EV_FREQ_LEN);\r\n#if WIRELESS_EXT > 14\r\nmemset( &iwe, 0, sizeof( iwe ));\r\nmemset( msg, 0, sizeof( msg ));\r\niwe.cmd = IWEVCUSTOM;\r\nsprintf( msg, "beacon_interval=%d", probe_resp->beaconInterval );\r\niwe.u.data.length = strlen( msg );\r\nbuf = IWE_STREAM_ADD_POINT(info, buf, buf_end, &iwe, msg);\r\nwpa_ie = NULL;\r\nwpa_ie_len = 0;\r\nwpa_ie = wl_parse_wpa_ie( probe_resp, &wpa_ie_len );\r\nif( wpa_ie != NULL ) {\r\nmemset( &iwe, 0, sizeof( iwe ));\r\nmemset( msg, 0, sizeof( msg ));\r\niwe.cmd = IWEVCUSTOM;\r\nsprintf( msg, "wpa_ie=%s", wl_print_wpa_ie( wpa_ie, wpa_ie_len ));\r\niwe.u.data.length = strlen( msg );\r\nbuf = IWE_STREAM_ADD_POINT(info, buf, buf_end, &iwe, msg);\r\n}\r\n#endif\r\n}\r\ndata->length = buf - extra;\r\nout_unlock:\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *data, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret;\r\nint iwa_idx = data->flags & IW_AUTH_INDEX;\r\nint iwa_val = data->value;\r\nDBG_FUNC( "wireless_set_auth" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nswitch (iwa_idx) {\r\ncase IW_AUTH_WPA_VERSION:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_WPA_VERSION\n");\r\nif (iwa_val == IW_AUTH_WPA_VERSION_WPA)\r\nret = 0;\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_WPA_ENABLED: val = %d\n", iwa_val);\r\nif (iwa_val)\r\nlp->EnableEncryption = 2;\r\nelse\r\nlp->EnableEncryption = 0;\r\nret = 0;\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_TKIP_COUNTERMEASURES\n");\r\nlp->driverEnable = !iwa_val;\r\nif(lp->driverEnable)\r\nhcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\r\nelse\r\nhcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\r\nret = 0;\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_DROP_UNENCRYPTED\n");\r\nret = 0;\r\nbreak;\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_CIPHER_PAIRWISE\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_CIPHER_GROUP:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_CIPHER_GROUP\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_KEY_MGMT:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_KEY_MGMT\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_80211_AUTH_ALG\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_RX_UNENCRYPTED_EAPOL\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_ROAMING_CONTROL:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_ROAMING_CONTROL\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_PRIVACY_INVOKED\n");\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, "IW_AUTH_?? (%d) unknown\n", iwa_idx);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int hermes_set_key(ltv_t *ltv, int alg, int key_idx, u8 *addr,\r\nint set_tx, u8 *seq, u8 *key, size_t key_len)\r\n{\r\nint ret = -EINVAL;\r\nint buf_idx = 0;\r\nhcf_8 tsc[IW_ENCODE_SEQ_MAX_SIZE] =\r\n{ 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00 };\r\nDBG_FUNC( "hermes_set_key" );\r\nDBG_ENTER( DbgInfo );\r\nswitch (alg)\r\n{\r\ncase IW_ENCODE_ALG_TKIP:\r\nDBG_TRACE( DbgInfo, "IW_ENCODE_ALG_TKIP: key(%d)\n", key_idx);\r\n#if 0\r\nfor( count = 0; count < 100; count++ )\r\n{\r\nusleep( 1000 );\r\nltv.len = 2;\r\nltv.typ = 0xFD91;\r\nltv.u.u16[0] = 0;\r\nwl_get_info( sock, &ltv, ifname );\r\nif( ltv.u.u16[0] == 0 )\r\n{\r\nbreak;\r\n}\r\n}\r\nif( count == 100 )\r\n{\r\nwpa_printf( MSG_DEBUG, "Timed out waiting for TxQ!" );\r\n}\r\n#endif\r\nswitch (key_idx) {\r\ncase 0:\r\nltv->len = 28;\r\nltv->typ = CFG_ADD_TKIP_MAPPED_KEY;\r\nmemcpy(&ltv->u.u8[buf_idx], addr, ETH_ALEN);\r\nbuf_idx += ETH_ALEN;\r\nmemcpy(&ltv->u.u8[buf_idx], &key[0], 16);\r\nbuf_idx += 16;\r\nmemcpy(&ltv->u.u8[buf_idx], tsc, IW_ENCODE_SEQ_MAX_SIZE);\r\nbuf_idx += IW_ENCODE_SEQ_MAX_SIZE;\r\nmemcpy(&ltv->u.u8[buf_idx], seq, IW_ENCODE_SEQ_MAX_SIZE);\r\nbuf_idx += IW_ENCODE_SEQ_MAX_SIZE;\r\nmemcpy(&ltv->u.u8[buf_idx], &key[16], 8);\r\nbuf_idx += 8;\r\nmemcpy(&ltv->u.u8[buf_idx], &key[24], 8);\r\nret = 0;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nltv->len = 26;\r\nltv->typ = CFG_ADD_TKIP_DEFAULT_KEY;\r\nltv->u.u16[buf_idx] = key_idx;\r\nif(set_tx)\r\nltv->u.u16[buf_idx] |= 0x8000;\r\nbuf_idx += 2;\r\nmemcpy(&ltv->u.u8[buf_idx], seq, IW_ENCODE_SEQ_MAX_SIZE);\r\nbuf_idx += IW_ENCODE_SEQ_MAX_SIZE;\r\nmemcpy(&ltv->u.u8[buf_idx], key, key_len);\r\nbuf_idx += key_len;\r\nmemcpy(&ltv->u.u8[buf_idx], tsc, IW_ENCODE_SEQ_MAX_SIZE);\r\nltv->u.u16[0] = CNV_INT_TO_LITTLE(ltv->u.u16[0]);\r\nret = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nDBG_TRACE( DbgInfo, "IW_ENCODE_ALG_WEP: key(%d)\n", key_idx);\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\nDBG_TRACE( DbgInfo, "IW_ENCODE_ALG_CCMP: key(%d)\n", key_idx);\r\nbreak;\r\ncase IW_ENCODE_ALG_NONE:\r\nDBG_TRACE( DbgInfo, "IW_ENCODE_ALG_NONE: key(%d)\n", key_idx);\r\nswitch (key_idx) {\r\ncase 0:\r\nif (memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) != 0) {\r\nltv->len = 7;\r\nltv->typ = CFG_REMOVE_TKIP_MAPPED_KEY;\r\nmemcpy(&ltv->u.u8[0], addr, ETH_ALEN);\r\nret = 0;\r\n}\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nltv->len = 2;\r\nltv->typ = CFG_REMOVE_TKIP_DEFAULT_KEY;\r\nltv->u.u16[0] = key_idx;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, "IW_ENCODE_??: key(%d)\n", key_idx);\r\nbreak;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_set_encodeext (struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq, char *keybuf)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret;\r\nint key_idx = (erq->flags&IW_ENCODE_INDEX) - 1;\r\nltv_t ltv;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)keybuf;\r\nDBG_FUNC( "wireless_set_encodeext" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (sizeof(ext->rx_seq) != 8) {\r\nDBG_TRACE(DbgInfo, "rz_seq size mismatch\n");\r\nDBG_LEAVE(DbgInfo);\r\nreturn -EINVAL;\r\n}\r\nif(ext->alg == IW_ENCODE_ALG_WEP) {\r\nstruct iw_point wep_erq;\r\nchar *wep_keybuf;\r\nwep_erq.flags = erq->flags;\r\nwep_erq.length = ext->key_len;\r\nwep_keybuf = ext->key;\r\nret = wireless_set_encode(dev, info, &wep_erq, wep_keybuf);\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nmemset(&ltv, 0, sizeof(ltv));\r\nret = hermes_set_key(&ltv, ext->alg, key_idx, ext->addr.sa_data,\r\next->ext_flags & IW_ENCODE_EXT_SET_TX_KEY,\r\next->rx_seq, ext->key, ext->key_len);\r\nif (ret != 0) {\r\nDBG_TRACE( DbgInfo, "hermes_set_key returned != 0, key not set\n");\r\ngoto out_unlock;\r\n}\r\nret = hcf_put_info(&(lp->hcfCtx), (LTVP)&ltv);\r\nout_unlock:\r\nif(ret == HCF_SUCCESS) {\r\nDBG_TRACE( DbgInfo, "Put key info succes\n");\r\n} else {\r\nDBG_TRACE( DbgInfo, "Put key info failed, key not set\n");\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstatic int wireless_get_genie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nltv_t ltv;\r\nDBG_FUNC( "wireless_get_genie" );\r\nDBG_ENTER( DbgInfo );\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\nmemset(&ltv, 0, sizeof(ltv));\r\nltv.len = 2;\r\nltv.typ = CFG_SET_WPA_AUTH_KEY_MGMT_SUITE;\r\nlp->AuthKeyMgmtSuite = ltv.u.u16[0] = 4;\r\nltv.u.u16[0] = CNV_INT_TO_LITTLE(ltv.u.u16[0]);\r\nret = hcf_put_info(&(lp->hcfCtx), (LTVP)&ltv);\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nout:\r\nDBG_LEAVE( DbgInfo );\r\nreturn ret;\r\n}\r\nstruct iw_statistics * wl_wireless_stats( struct net_device *dev )\r\n{\r\nstruct iw_statistics *pStats;\r\nstruct wl_private *lp = wl_priv(dev);\r\nDBG_FUNC( "wl_wireless_stats" );\r\nDBG_ENTER(DbgInfo);\r\nDBG_PARAM(DbgInfo, "dev", "%s (0x%p)", dev->name, dev);\r\npStats = NULL;\r\npStats = &( lp->wstats );\r\npStats->qual.updated = 0x00;\r\nif( !( lp->flags & WVLAN2_UIL_BUSY ))\r\n{\r\nCFG_COMMS_QUALITY_STRCT *pQual;\r\nCFG_HERMES_TALLIES_STRCT tallies;\r\nint status;\r\npStats->status = 0;\r\nlp->ltvRecord.len = 1 + ( sizeof( *pQual ) / sizeof( hcf_16 ));\r\nlp->ltvRecord.typ = CFG_COMMS_QUALITY;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\npQual = (CFG_COMMS_QUALITY_STRCT *)&( lp->ltvRecord );\r\n#ifdef USE_DBM\r\npStats->qual.qual = (u_char) CNV_LITTLE_TO_INT( pQual->coms_qual );\r\npStats->qual.level = (u_char) dbm( CNV_LITTLE_TO_INT( pQual->signal_lvl ));\r\npStats->qual.noise = (u_char) dbm( CNV_LITTLE_TO_INT( pQual->noise_lvl ));\r\npStats->qual.updated |= (IW_QUAL_QUAL_UPDATED |\r\nIW_QUAL_LEVEL_UPDATED |\r\nIW_QUAL_NOISE_UPDATED |\r\nIW_QUAL_DBM);\r\n#else\r\npStats->qual.qual = percent( CNV_LITTLE_TO_INT( pQual->coms_qual ),\r\nHCF_MIN_COMM_QUALITY,\r\nHCF_MAX_COMM_QUALITY );\r\npStats->qual.level = percent( CNV_LITTLE_TO_INT( pQual->signal_lvl ),\r\nHCF_MIN_SIGNAL_LEVEL,\r\nHCF_MAX_SIGNAL_LEVEL );\r\npStats->qual.noise = percent( CNV_LITTLE_TO_INT( pQual->noise_lvl ),\r\nHCF_MIN_NOISE_LEVEL,\r\nHCF_MAX_NOISE_LEVEL );\r\npStats->qual.updated |= (IW_QUAL_QUAL_UPDATED |\r\nIW_QUAL_LEVEL_UPDATED |\r\nIW_QUAL_NOISE_UPDATED);\r\n#endif\r\n} else {\r\nmemset( &( pStats->qual ), 0, sizeof( pStats->qual ));\r\n}\r\nif(lp->portState == WVLAN_PORT_STATE_DISABLED) {\r\nif( wl_get_tallies( lp, &tallies ) == 0 ) {\r\npStats->discard.nwid = 0L;\r\npStats->discard.code = tallies.RxWEPUndecryptable;\r\npStats->discard.misc = tallies.TxDiscards +\r\ntallies.RxFCSErrors +\r\ntallies.TxDiscardsWrongSA;\r\npStats->discard.retries = tallies.TxRetryLimitExceeded;\r\npStats->discard.fragment = tallies.RxMsgInBadMsgFragments;\r\n} else {\r\nmemset( &( pStats->discard ), 0, sizeof( pStats->discard ));\r\n}\r\n} else {\r\nmemset( &( pStats->discard ), 0, sizeof( pStats->discard ));\r\n}\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn pStats;\r\n}\r\nstruct iw_statistics * wl_get_wireless_stats( struct net_device *dev )\r\n{\r\nunsigned long flags;\r\nstruct wl_private *lp = wl_priv(dev);\r\nstruct iw_statistics *pStats = NULL;\r\nDBG_FUNC( "wl_get_wireless_stats" );\r\nDBG_ENTER(DbgInfo);\r\nwl_lock( lp, &flags );\r\nwl_act_int_off( lp );\r\n#ifdef USE_RTS\r\nif( lp->useRTS == 1 ) {\r\nDBG_TRACE( DbgInfo, "Skipping wireless stats, in RTS mode\n" );\r\n} else\r\n#endif\r\n{\r\npStats = wl_wireless_stats( dev );\r\n}\r\nwl_act_int_on( lp );\r\nwl_unlock(lp, &flags);\r\nDBG_LEAVE( DbgInfo );\r\nreturn pStats;\r\n}\r\ninline void wl_spy_gather( struct net_device *dev, u_char *mac )\r\n{\r\nstruct iw_quality wstats;\r\nint status;\r\nu_char stats[2];\r\nDESC_STRCT desc[1];\r\nstruct wl_private *lp = wl_priv(dev);\r\nif (!lp->spy_data.spy_number) {\r\nreturn;\r\n}\r\nmemset( stats, 0, sizeof(stats));\r\nmemset( desc, 0, sizeof(DESC_STRCT));\r\ndesc[0].buf_addr = stats;\r\ndesc[0].BUF_SIZE = sizeof(stats);\r\ndesc[0].next_desc_addr = 0;\r\nstatus = hcf_rcv_msg( &( lp->hcfCtx ), &desc[0], 0 );\r\nif( status == HCF_SUCCESS ) {\r\nwstats.level = (u_char) dbm(stats[1]);\r\nwstats.noise = (u_char) dbm(stats[0]);\r\nwstats.qual = wstats.level > wstats.noise ? wstats.level - wstats.noise : 0;\r\nwstats.updated = (IW_QUAL_QUAL_UPDATED |\r\nIW_QUAL_LEVEL_UPDATED |\r\nIW_QUAL_NOISE_UPDATED |\r\nIW_QUAL_DBM);\r\nwireless_spy_update( dev, mac, &wstats );\r\n}\r\n}\r\nvoid wl_wext_event_freq( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 13\r\nunion iwreq_data wrqu;\r\nstruct wl_private *lp = wl_priv(dev);\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nwrqu.freq.m = lp->Channel;\r\nwrqu.freq.e = 0;\r\nwireless_send_event( dev, SIOCSIWFREQ, &wrqu, NULL );\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_mode( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 13\r\nunion iwreq_data wrqu;\r\nstruct wl_private *lp = wl_priv(dev);\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_STA ) {\r\nwrqu.mode = IW_MODE_INFRA;\r\n} else {\r\nwrqu.mode = IW_MODE_MASTER;\r\n}\r\nwireless_send_event( dev, SIOCSIWMODE, &wrqu, NULL );\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_essid( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 13\r\nunion iwreq_data wrqu;\r\nstruct wl_private *lp = wl_priv(dev);\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nwrqu.essid.length = strlen( lp->NetworkName );\r\nwrqu.essid.pointer = (caddr_t)lp->NetworkName;\r\nwrqu.essid.flags = 1;\r\nwireless_send_event( dev, SIOCSIWESSID, &wrqu, lp->NetworkName );\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_encode( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 13\r\nunion iwreq_data wrqu;\r\nstruct wl_private *lp = wl_priv(dev);\r\nint index = 0;\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nif( lp->EnableEncryption == 0 ) {\r\nwrqu.encoding.flags = IW_ENCODE_DISABLED;\r\n} else {\r\nwrqu.encoding.flags |= lp->TransmitKeyID;\r\nindex = lp->TransmitKeyID - 1;\r\n#if 1\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nif( lp->ExcludeUnencrypted ) {\r\nwrqu.encoding.flags |= IW_ENCODE_RESTRICTED;\r\n} else {\r\nwrqu.encoding.flags |= IW_ENCODE_OPEN;\r\n}\r\n}\r\n#endif\r\nif( capable( CAP_NET_ADMIN )) {\r\nwrqu.encoding.pointer = (caddr_t)lp->DefaultKeys.key[index].key;\r\nwrqu.encoding.length = lp->DefaultKeys.key[index].len;\r\n} else {\r\nwrqu.encoding.flags |= IW_ENCODE_NOKEY;\r\n}\r\n}\r\nwireless_send_event( dev, SIOCSIWENCODE, &wrqu,\r\nlp->DefaultKeys.key[index].key );\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_ap( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 13\r\nunion iwreq_data wrqu;\r\nstruct wl_private *lp = wl_priv(dev);\r\nint status;\r\nwl_wext_event_assoc_ie( dev );\r\nlp->ltvRecord.typ = CFG_CUR_BSSID;\r\nlp->ltvRecord.len = 4;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS ) {\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nmemcpy( wrqu.addr.sa_data, lp->ltvRecord.u.u8, ETH_ALEN );\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event( dev, SIOCGIWAP, &wrqu, NULL );\r\n}\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_scan_complete( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 13\r\nunion iwreq_data wrqu;\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event( dev, SIOCGIWSCAN, &wrqu, NULL );\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_new_sta( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 14\r\nunion iwreq_data wrqu;\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nmemcpy( wrqu.addr.sa_data, dev->dev_addr, ETH_ALEN );\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event( dev, IWEVREGISTERED, &wrqu, NULL );\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_expired_sta( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 14\r\nunion iwreq_data wrqu;\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nmemcpy( wrqu.addr.sa_data, dev->dev_addr, ETH_ALEN );\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event( dev, IWEVEXPIRED, &wrqu, NULL );\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_mic_failed( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 14\r\nchar msg[512];\r\nunion iwreq_data wrqu;\r\nstruct wl_private *lp = wl_priv(dev);\r\nint key_idx;\r\nchar *addr1;\r\nchar *addr2;\r\nWVLAN_RX_WMP_HDR *hdr;\r\nkey_idx = lp->lookAheadBuf[HFS_STAT+1] >> 3;\r\nkey_idx &= 0x03;\r\nhdr = (WVLAN_RX_WMP_HDR *)&lp->lookAheadBuf[HFS_STAT];\r\naddr1 = (char *)hdr->address1;\r\naddr2 = (char *)hdr->address2;\r\nDBG_PRINT( "MIC FAIL - KEY USED : %d, STATUS : 0x%04x\n", key_idx,\r\nhdr->status );\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nmemset( msg, 0, sizeof( msg ));\r\n#if DBG\r\nsprintf(msg, "MLME-MICHAELMICFAILURE.indication(keyid=%d %scast "\r\n"addr=%pM)", key_idx, addr1[0] & 0x01 ? "broad" : "uni",\r\naddr2);\r\n#endif\r\nwrqu.data.length = strlen( msg );\r\nwireless_send_event( dev, IWEVCUSTOM, &wrqu, msg );\r\n#endif\r\nreturn;\r\n}\r\nvoid wl_wext_event_assoc_ie( struct net_device *dev )\r\n{\r\n#if WIRELESS_EXT > 14\r\nchar msg[512];\r\nunion iwreq_data wrqu;\r\nstruct wl_private *lp = wl_priv(dev);\r\nint status;\r\nPROBE_RESP data;\r\nhcf_16 length;\r\nhcf_8 *wpa_ie;\r\nmemset( &wrqu, 0, sizeof( wrqu ));\r\nmemset( msg, 0, sizeof( msg ));\r\nlp->ltvRecord.len = 45;\r\nlp->ltvRecord.typ = CFG_CUR_ASSOC_REQ_INFO;\r\nstatus = hcf_get_info( &( lp->hcfCtx ), (LTVP)&( lp->ltvRecord ));\r\nif( status == HCF_SUCCESS )\r\n{\r\nlength = 0;\r\nmemcpy( &data.rawData, &( lp->ltvRecord.u.u8[1] ), 88 );\r\nwpa_ie = wl_parse_wpa_ie( &data, &length );\r\nif( length != 0 )\r\n{\r\nsprintf( msg, "ASSOCINFO(ReqIEs=%s)", wl_print_wpa_ie( wpa_ie, length ));\r\nwrqu.data.length = strlen( msg );\r\nwireless_send_event( dev, IWEVCUSTOM, &wrqu, msg );\r\n}\r\n}\r\n#endif\r\nreturn;\r\n}
