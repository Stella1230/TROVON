static inline void byte_set_bit(u8 nr, u8 map[])\r\n{\r\nmap[nr >> 3] |= (1UL << (nr & 7));\r\n}\r\nstatic inline int byte_test_bit(u8 nr, u8 map[])\r\n{\r\nreturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\r\n}\r\nstatic inline void byte_copymap(u8 dmap[], unsigned long smap[],\r\nunsigned int sz)\r\n{\r\nunsigned int nn;\r\nif (!sz)\r\nreturn;\r\nmemset(dmap, 0, ((sz + 7) >> 3));\r\nfor (nn = 0 ; nn < sz; nn++)\r\nif (test_bit(nn, smap))\r\nbyte_set_bit(nn, dmap);\r\n}\r\nstatic void dlm_free_pagevec(void **vec, int pages)\r\n{\r\nwhile (pages--)\r\nfree_page((unsigned long)vec[pages]);\r\nkfree(vec);\r\n}\r\nstatic void **dlm_alloc_pagevec(int pages)\r\n{\r\nvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\r\nint i;\r\nif (!vec)\r\nreturn NULL;\r\nfor (i = 0; i < pages; i++)\r\nif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\r\ngoto out_free;\r\nmlog(0, "Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\n",\r\npages, (unsigned long)DLM_HASH_PAGES,\r\n(unsigned long)DLM_BUCKETS_PER_PAGE);\r\nreturn vec;\r\nout_free:\r\ndlm_free_pagevec(vec, i);\r\nreturn NULL;\r\n}\r\nvoid __dlm_unhash_lockres(struct dlm_lock_resource *lockres)\r\n{\r\nif (!hlist_unhashed(&lockres->hash_node)) {\r\nhlist_del_init(&lockres->hash_node);\r\ndlm_lockres_put(lockres);\r\n}\r\n}\r\nvoid __dlm_insert_lockres(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res)\r\n{\r\nstruct hlist_head *bucket;\r\nstruct qstr *q;\r\nassert_spin_locked(&dlm->spinlock);\r\nq = &res->lockname;\r\nbucket = dlm_lockres_hash(dlm, q->hash);\r\ndlm_lockres_get(res);\r\nhlist_add_head(&res->hash_node, bucket);\r\n}\r\nstruct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\r\nconst char *name,\r\nunsigned int len,\r\nunsigned int hash)\r\n{\r\nstruct hlist_head *bucket;\r\nstruct hlist_node *list;\r\nmlog(0, "%.*s\n", len, name);\r\nassert_spin_locked(&dlm->spinlock);\r\nbucket = dlm_lockres_hash(dlm, hash);\r\nhlist_for_each(list, bucket) {\r\nstruct dlm_lock_resource *res = hlist_entry(list,\r\nstruct dlm_lock_resource, hash_node);\r\nif (res->lockname.name[0] != name[0])\r\ncontinue;\r\nif (unlikely(res->lockname.len != len))\r\ncontinue;\r\nif (memcmp(res->lockname.name + 1, name + 1, len - 1))\r\ncontinue;\r\ndlm_lockres_get(res);\r\nreturn res;\r\n}\r\nreturn NULL;\r\n}\r\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\r\nconst char *name,\r\nunsigned int len,\r\nunsigned int hash)\r\n{\r\nstruct dlm_lock_resource *res = NULL;\r\nmlog(0, "%.*s\n", len, name);\r\nassert_spin_locked(&dlm->spinlock);\r\nres = __dlm_lookup_lockres_full(dlm, name, len, hash);\r\nif (res) {\r\nspin_lock(&res->spinlock);\r\nif (res->state & DLM_LOCK_RES_DROPPING_REF) {\r\nspin_unlock(&res->spinlock);\r\ndlm_lockres_put(res);\r\nreturn NULL;\r\n}\r\nspin_unlock(&res->spinlock);\r\n}\r\nreturn res;\r\n}\r\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\r\nconst char *name,\r\nunsigned int len)\r\n{\r\nstruct dlm_lock_resource *res;\r\nunsigned int hash = dlm_lockid_hash(name, len);\r\nspin_lock(&dlm->spinlock);\r\nres = __dlm_lookup_lockres(dlm, name, len, hash);\r\nspin_unlock(&dlm->spinlock);\r\nreturn res;\r\n}\r\nstatic struct dlm_ctxt * __dlm_lookup_domain_full(const char *domain, int len)\r\n{\r\nstruct dlm_ctxt *tmp = NULL;\r\nstruct list_head *iter;\r\nassert_spin_locked(&dlm_domain_lock);\r\nlist_for_each(iter, &dlm_domains) {\r\ntmp = list_entry (iter, struct dlm_ctxt, list);\r\nif (strlen(tmp->name) == len &&\r\nmemcmp(tmp->name, domain, len)==0)\r\nbreak;\r\ntmp = NULL;\r\n}\r\nreturn tmp;\r\n}\r\nstatic struct dlm_ctxt * __dlm_lookup_domain(const char *domain)\r\n{\r\nassert_spin_locked(&dlm_domain_lock);\r\nreturn __dlm_lookup_domain_full(domain, strlen(domain));\r\n}\r\nstatic int dlm_wait_on_domain_helper(const char *domain)\r\n{\r\nint ret = 0;\r\nstruct dlm_ctxt *tmp = NULL;\r\nspin_lock(&dlm_domain_lock);\r\ntmp = __dlm_lookup_domain(domain);\r\nif (!tmp)\r\nret = 1;\r\nelse if (tmp->dlm_state == DLM_CTXT_JOINED)\r\nret = 1;\r\nspin_unlock(&dlm_domain_lock);\r\nreturn ret;\r\n}\r\nstatic void dlm_free_ctxt_mem(struct dlm_ctxt *dlm)\r\n{\r\ndlm_destroy_debugfs_subroot(dlm);\r\nif (dlm->lockres_hash)\r\ndlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\r\nif (dlm->master_hash)\r\ndlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\r\nif (dlm->name)\r\nkfree(dlm->name);\r\nkfree(dlm);\r\n}\r\nstatic void dlm_ctxt_release(struct kref *kref)\r\n{\r\nstruct dlm_ctxt *dlm;\r\ndlm = container_of(kref, struct dlm_ctxt, dlm_refs);\r\nBUG_ON(dlm->num_joins);\r\nBUG_ON(dlm->dlm_state == DLM_CTXT_JOINED);\r\nlist_del_init(&dlm->list);\r\nspin_unlock(&dlm_domain_lock);\r\nmlog(0, "freeing memory from domain %s\n", dlm->name);\r\nwake_up(&dlm_domain_events);\r\ndlm_free_ctxt_mem(dlm);\r\nspin_lock(&dlm_domain_lock);\r\n}\r\nvoid dlm_put(struct dlm_ctxt *dlm)\r\n{\r\nspin_lock(&dlm_domain_lock);\r\nkref_put(&dlm->dlm_refs, dlm_ctxt_release);\r\nspin_unlock(&dlm_domain_lock);\r\n}\r\nstatic void __dlm_get(struct dlm_ctxt *dlm)\r\n{\r\nkref_get(&dlm->dlm_refs);\r\n}\r\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\r\n{\r\nstruct list_head *iter;\r\nstruct dlm_ctxt *target = NULL;\r\nspin_lock(&dlm_domain_lock);\r\nlist_for_each(iter, &dlm_domains) {\r\ntarget = list_entry (iter, struct dlm_ctxt, list);\r\nif (target == dlm) {\r\n__dlm_get(target);\r\nbreak;\r\n}\r\ntarget = NULL;\r\n}\r\nspin_unlock(&dlm_domain_lock);\r\nreturn target;\r\n}\r\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\r\n{\r\nint ret;\r\nspin_lock(&dlm_domain_lock);\r\nret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\r\n(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\r\nspin_unlock(&dlm_domain_lock);\r\nreturn ret;\r\n}\r\nstatic void dlm_destroy_dlm_worker(struct dlm_ctxt *dlm)\r\n{\r\nif (dlm->dlm_worker) {\r\nflush_workqueue(dlm->dlm_worker);\r\ndestroy_workqueue(dlm->dlm_worker);\r\ndlm->dlm_worker = NULL;\r\n}\r\n}\r\nstatic void dlm_complete_dlm_shutdown(struct dlm_ctxt *dlm)\r\n{\r\ndlm_unregister_domain_handlers(dlm);\r\ndlm_debug_shutdown(dlm);\r\ndlm_complete_thread(dlm);\r\ndlm_complete_recovery_thread(dlm);\r\ndlm_destroy_dlm_worker(dlm);\r\nspin_lock(&dlm_domain_lock);\r\nlist_del_init(&dlm->list);\r\nspin_unlock(&dlm_domain_lock);\r\nwake_up(&dlm_domain_events);\r\n}\r\nstatic int dlm_migrate_all_locks(struct dlm_ctxt *dlm)\r\n{\r\nint i, num, n, ret = 0;\r\nstruct dlm_lock_resource *res;\r\nstruct hlist_node *iter;\r\nstruct hlist_head *bucket;\r\nint dropped;\r\nmlog(0, "Migrating locks from domain %s\n", dlm->name);\r\nnum = 0;\r\nspin_lock(&dlm->spinlock);\r\nfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\r\nredo_bucket:\r\nn = 0;\r\nbucket = dlm_lockres_hash(dlm, i);\r\niter = bucket->first;\r\nwhile (iter) {\r\nn++;\r\nres = hlist_entry(iter, struct dlm_lock_resource,\r\nhash_node);\r\ndlm_lockres_get(res);\r\ndropped = dlm_empty_lockres(dlm, res);\r\nspin_lock(&res->spinlock);\r\nif (dropped)\r\n__dlm_lockres_calc_usage(dlm, res);\r\nelse\r\niter = res->hash_node.next;\r\nspin_unlock(&res->spinlock);\r\ndlm_lockres_put(res);\r\nif (dropped) {\r\ncond_resched_lock(&dlm->spinlock);\r\ngoto redo_bucket;\r\n}\r\n}\r\ncond_resched_lock(&dlm->spinlock);\r\nnum += n;\r\n}\r\nspin_unlock(&dlm->spinlock);\r\nwake_up(&dlm->dlm_thread_wq);\r\nif (num) {\r\nmlog(0, "%s: %d lock resources in hash last pass\n",\r\ndlm->name, num);\r\nret = -EAGAIN;\r\n}\r\nmlog(0, "DONE Migrating locks from domain %s\n", dlm->name);\r\nreturn ret;\r\n}\r\nstatic int dlm_no_joining_node(struct dlm_ctxt *dlm)\r\n{\r\nint ret;\r\nspin_lock(&dlm->spinlock);\r\nret = dlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN;\r\nspin_unlock(&dlm->spinlock);\r\nreturn ret;\r\n}\r\nstatic int dlm_begin_exit_domain_handler(struct o2net_msg *msg, u32 len,\r\nvoid *data, void **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nunsigned int node;\r\nstruct dlm_exit_domain *exit_msg = (struct dlm_exit_domain *) msg->buf;\r\nif (!dlm_grab(dlm))\r\nreturn 0;\r\nnode = exit_msg->node_idx;\r\nmlog(0, "%s: Node %u sent a begin exit domain message\n", dlm->name, node);\r\nspin_lock(&dlm->spinlock);\r\nset_bit(node, dlm->exit_domain_map);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_put(dlm);\r\nreturn 0;\r\n}\r\nstatic void dlm_mark_domain_leaving(struct dlm_ctxt *dlm)\r\n{\r\nagain:\r\nspin_lock(&dlm_domain_lock);\r\nspin_lock(&dlm->spinlock);\r\nif (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\r\nmlog(0, "Node %d is joining, we wait on it.\n",\r\ndlm->joining_node);\r\nspin_unlock(&dlm->spinlock);\r\nspin_unlock(&dlm_domain_lock);\r\nwait_event(dlm->dlm_join_events, dlm_no_joining_node(dlm));\r\ngoto again;\r\n}\r\ndlm->dlm_state = DLM_CTXT_LEAVING;\r\nspin_unlock(&dlm->spinlock);\r\nspin_unlock(&dlm_domain_lock);\r\n}\r\nstatic void __dlm_print_nodes(struct dlm_ctxt *dlm)\r\n{\r\nint node = -1;\r\nassert_spin_locked(&dlm->spinlock);\r\nprintk(KERN_NOTICE "o2dlm: Nodes in domain %s: ", dlm->name);\r\nwhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\r\nnode + 1)) < O2NM_MAX_NODES) {\r\nprintk("%d ", node);\r\n}\r\nprintk("\n");\r\n}\r\nstatic int dlm_exit_domain_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nunsigned int node;\r\nstruct dlm_exit_domain *exit_msg = (struct dlm_exit_domain *) msg->buf;\r\nmlog(0, "%p %u %p", msg, len, data);\r\nif (!dlm_grab(dlm))\r\nreturn 0;\r\nnode = exit_msg->node_idx;\r\nprintk(KERN_NOTICE "o2dlm: Node %u leaves domain %s\n", node, dlm->name);\r\nspin_lock(&dlm->spinlock);\r\nclear_bit(node, dlm->domain_map);\r\nclear_bit(node, dlm->exit_domain_map);\r\n__dlm_print_nodes(dlm);\r\ndlm_hb_event_notify_attached(dlm, node, 0);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_put(dlm);\r\nreturn 0;\r\n}\r\nstatic int dlm_send_one_domain_exit(struct dlm_ctxt *dlm, u32 msg_type,\r\nunsigned int node)\r\n{\r\nint status;\r\nstruct dlm_exit_domain leave_msg;\r\nmlog(0, "%s: Sending domain exit message %u to node %u\n", dlm->name,\r\nmsg_type, node);\r\nmemset(&leave_msg, 0, sizeof(leave_msg));\r\nleave_msg.node_idx = dlm->node_num;\r\nstatus = o2net_send_message(msg_type, dlm->key, &leave_msg,\r\nsizeof(leave_msg), node, NULL);\r\nif (status < 0)\r\nmlog(ML_ERROR, "Error %d sending domain exit message %u "\r\n"to node %u on domain %s\n", status, msg_type, node,\r\ndlm->name);\r\nreturn status;\r\n}\r\nstatic void dlm_begin_exit_domain(struct dlm_ctxt *dlm)\r\n{\r\nint node = -1;\r\nif (dlm->dlm_locking_proto.pv_major == 1 &&\r\ndlm->dlm_locking_proto.pv_minor < 2)\r\nreturn;\r\nspin_lock(&dlm->spinlock);\r\nwhile (1) {\r\nnode = find_next_bit(dlm->domain_map, O2NM_MAX_NODES, node + 1);\r\nif (node >= O2NM_MAX_NODES)\r\nbreak;\r\nif (node == dlm->node_num)\r\ncontinue;\r\nspin_unlock(&dlm->spinlock);\r\ndlm_send_one_domain_exit(dlm, DLM_BEGIN_EXIT_DOMAIN_MSG, node);\r\nspin_lock(&dlm->spinlock);\r\n}\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nstatic void dlm_leave_domain(struct dlm_ctxt *dlm)\r\n{\r\nint node, clear_node, status;\r\nspin_lock(&dlm->spinlock);\r\nclear_bit(dlm->node_num, dlm->domain_map);\r\nwhile ((node = find_next_bit(dlm->domain_map, O2NM_MAX_NODES,\r\n0)) < O2NM_MAX_NODES) {\r\nspin_unlock(&dlm->spinlock);\r\nclear_node = 1;\r\nstatus = dlm_send_one_domain_exit(dlm, DLM_EXIT_DOMAIN_MSG,\r\nnode);\r\nif (status < 0 &&\r\nstatus != -ENOPROTOOPT &&\r\nstatus != -ENOTCONN) {\r\nmlog(ML_NOTICE, "Error %d sending domain exit message "\r\n"to node %d\n", status, node);\r\nmsleep(DLM_DOMAIN_BACKOFF_MS);\r\nclear_node = 0;\r\n}\r\nspin_lock(&dlm->spinlock);\r\nif (clear_node)\r\nclear_bit(node, dlm->domain_map);\r\n}\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nint dlm_joined(struct dlm_ctxt *dlm)\r\n{\r\nint ret = 0;\r\nspin_lock(&dlm_domain_lock);\r\nif (dlm->dlm_state == DLM_CTXT_JOINED)\r\nret = 1;\r\nspin_unlock(&dlm_domain_lock);\r\nreturn ret;\r\n}\r\nint dlm_shutting_down(struct dlm_ctxt *dlm)\r\n{\r\nint ret = 0;\r\nspin_lock(&dlm_domain_lock);\r\nif (dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN)\r\nret = 1;\r\nspin_unlock(&dlm_domain_lock);\r\nreturn ret;\r\n}\r\nvoid dlm_unregister_domain(struct dlm_ctxt *dlm)\r\n{\r\nint leave = 0;\r\nstruct dlm_lock_resource *res;\r\nspin_lock(&dlm_domain_lock);\r\nBUG_ON(dlm->dlm_state != DLM_CTXT_JOINED);\r\nBUG_ON(!dlm->num_joins);\r\ndlm->num_joins--;\r\nif (!dlm->num_joins) {\r\ndlm->dlm_state = DLM_CTXT_IN_SHUTDOWN;\r\nleave = 1;\r\n}\r\nspin_unlock(&dlm_domain_lock);\r\nif (leave) {\r\nmlog(0, "shutting down domain %s\n", dlm->name);\r\ndlm_begin_exit_domain(dlm);\r\ndlm_kick_thread(dlm, NULL);\r\nwhile (dlm_migrate_all_locks(dlm)) {\r\nmsleep(500);\r\nmlog(0, "%s: more migration to do\n", dlm->name);\r\n}\r\nif (!list_empty(&dlm->tracking_list)) {\r\nmlog(ML_ERROR, "Following lockres' are still on the "\r\n"tracking list:\n");\r\nlist_for_each_entry(res, &dlm->tracking_list, tracking)\r\ndlm_print_one_lock_resource(res);\r\n}\r\ndlm_mark_domain_leaving(dlm);\r\ndlm_leave_domain(dlm);\r\ndlm_force_free_mles(dlm);\r\ndlm_complete_dlm_shutdown(dlm);\r\n}\r\ndlm_put(dlm);\r\n}\r\nstatic int dlm_query_join_proto_check(char *proto_type, int node,\r\nstruct dlm_protocol_version *ours,\r\nstruct dlm_protocol_version *request)\r\n{\r\nint rc;\r\nstruct dlm_protocol_version proto = *request;\r\nif (!dlm_protocol_compare(ours, &proto)) {\r\nmlog(0,\r\n"node %u wanted to join with %s locking protocol "\r\n"%u.%u, we respond with %u.%u\n",\r\nnode, proto_type,\r\nrequest->pv_major,\r\nrequest->pv_minor,\r\nproto.pv_major, proto.pv_minor);\r\nrequest->pv_minor = proto.pv_minor;\r\nrc = 0;\r\n} else {\r\nmlog(ML_NOTICE,\r\n"Node %u wanted to join with %s locking "\r\n"protocol %u.%u, but we have %u.%u, disallowing\n",\r\nnode, proto_type,\r\nrequest->pv_major,\r\nrequest->pv_minor,\r\nours->pv_major,\r\nours->pv_minor);\r\nrc = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic void dlm_query_join_packet_to_wire(struct dlm_query_join_packet *packet,\r\nu32 *wire)\r\n{\r\nunion dlm_query_join_response response;\r\nresponse.packet = *packet;\r\n*wire = cpu_to_be32(response.intval);\r\n}\r\nstatic void dlm_query_join_wire_to_packet(u32 wire,\r\nstruct dlm_query_join_packet *packet)\r\n{\r\nunion dlm_query_join_response response;\r\nresponse.intval = cpu_to_be32(wire);\r\n*packet = response.packet;\r\n}\r\nstatic int dlm_query_join_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_query_join_request *query;\r\nstruct dlm_query_join_packet packet = {\r\n.code = JOIN_DISALLOW,\r\n};\r\nstruct dlm_ctxt *dlm = NULL;\r\nu32 response;\r\nu8 nodenum;\r\nquery = (struct dlm_query_join_request *) msg->buf;\r\nmlog(0, "node %u wants to join domain %s\n", query->node_idx,\r\nquery->domain);\r\nif (!o2hb_check_node_heartbeating(query->node_idx)) {\r\nmlog(0, "node %u is not in our live map yet\n",\r\nquery->node_idx);\r\npacket.code = JOIN_DISALLOW;\r\ngoto respond;\r\n}\r\npacket.code = JOIN_OK_NO_MAP;\r\nspin_lock(&dlm_domain_lock);\r\ndlm = __dlm_lookup_domain_full(query->domain, query->name_len);\r\nif (!dlm)\r\ngoto unlock_respond;\r\nnodenum=0;\r\nwhile (nodenum < O2NM_MAX_NODES) {\r\nif (test_bit(nodenum, dlm->domain_map)) {\r\nif (!byte_test_bit(nodenum, query->node_map)) {\r\nmlog(0, "disallow join as node %u does not "\r\n"have node %u in its nodemap\n",\r\nquery->node_idx, nodenum);\r\npacket.code = JOIN_DISALLOW;\r\ngoto unlock_respond;\r\n}\r\n}\r\nnodenum++;\r\n}\r\nif (dlm && dlm->dlm_state != DLM_CTXT_LEAVING) {\r\nint bit = query->node_idx;\r\nspin_lock(&dlm->spinlock);\r\nif (dlm->dlm_state == DLM_CTXT_NEW &&\r\ndlm->joining_node == DLM_LOCK_RES_OWNER_UNKNOWN) {\r\npacket.code = JOIN_OK_NO_MAP;\r\n} else if (dlm->joining_node != DLM_LOCK_RES_OWNER_UNKNOWN) {\r\npacket.code = JOIN_DISALLOW;\r\n} else if (dlm->reco.state & DLM_RECO_STATE_ACTIVE) {\r\nmlog(0, "node %u trying to join, but recovery "\r\n"is ongoing.\n", bit);\r\npacket.code = JOIN_DISALLOW;\r\n} else if (test_bit(bit, dlm->recovery_map)) {\r\nmlog(0, "node %u trying to join, but it "\r\n"still needs recovery.\n", bit);\r\npacket.code = JOIN_DISALLOW;\r\n} else if (test_bit(bit, dlm->domain_map)) {\r\nmlog(0, "node %u trying to join, but it "\r\n"is still in the domain! needs recovery?\n",\r\nbit);\r\npacket.code = JOIN_DISALLOW;\r\n} else {\r\nif (dlm_query_join_proto_check("DLM", bit,\r\n&dlm->dlm_locking_proto,\r\n&query->dlm_proto)) {\r\npacket.code = JOIN_PROTOCOL_MISMATCH;\r\n} else if (dlm_query_join_proto_check("fs", bit,\r\n&dlm->fs_locking_proto,\r\n&query->fs_proto)) {\r\npacket.code = JOIN_PROTOCOL_MISMATCH;\r\n} else {\r\npacket.dlm_minor = query->dlm_proto.pv_minor;\r\npacket.fs_minor = query->fs_proto.pv_minor;\r\npacket.code = JOIN_OK;\r\n__dlm_set_joining_node(dlm, query->node_idx);\r\n}\r\n}\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nunlock_respond:\r\nspin_unlock(&dlm_domain_lock);\r\nrespond:\r\nmlog(0, "We respond with %u\n", packet.code);\r\ndlm_query_join_packet_to_wire(&packet, &response);\r\nreturn response;\r\n}\r\nstatic int dlm_assert_joined_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_assert_joined *assert;\r\nstruct dlm_ctxt *dlm = NULL;\r\nassert = (struct dlm_assert_joined *) msg->buf;\r\nmlog(0, "node %u asserts join on domain %s\n", assert->node_idx,\r\nassert->domain);\r\nspin_lock(&dlm_domain_lock);\r\ndlm = __dlm_lookup_domain_full(assert->domain, assert->name_len);\r\nif (dlm) {\r\nspin_lock(&dlm->spinlock);\r\nBUG_ON(dlm->joining_node != assert->node_idx);\r\nset_bit(assert->node_idx, dlm->domain_map);\r\nclear_bit(assert->node_idx, dlm->exit_domain_map);\r\n__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\r\nprintk(KERN_NOTICE "o2dlm: Node %u joins domain %s\n",\r\nassert->node_idx, dlm->name);\r\n__dlm_print_nodes(dlm);\r\ndlm_hb_event_notify_attached(dlm, assert->node_idx, 1);\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nspin_unlock(&dlm_domain_lock);\r\nreturn 0;\r\n}\r\nstatic int dlm_match_regions(struct dlm_ctxt *dlm,\r\nstruct dlm_query_region *qr,\r\nchar *local, int locallen)\r\n{\r\nchar *remote = qr->qr_regions;\r\nchar *l, *r;\r\nint localnr, i, j, foundit;\r\nint status = 0;\r\nif (!o2hb_global_heartbeat_active()) {\r\nif (qr->qr_numregions) {\r\nmlog(ML_ERROR, "Domain %s: Joining node %d has global "\r\n"heartbeat enabled but local node %d does not\n",\r\nqr->qr_domain, qr->qr_node, dlm->node_num);\r\nstatus = -EINVAL;\r\n}\r\ngoto bail;\r\n}\r\nif (o2hb_global_heartbeat_active() && !qr->qr_numregions) {\r\nmlog(ML_ERROR, "Domain %s: Local node %d has global "\r\n"heartbeat enabled but joining node %d does not\n",\r\nqr->qr_domain, dlm->node_num, qr->qr_node);\r\nstatus = -EINVAL;\r\ngoto bail;\r\n}\r\nr = remote;\r\nfor (i = 0; i < qr->qr_numregions; ++i) {\r\nmlog(0, "Region %.*s\n", O2HB_MAX_REGION_NAME_LEN, r);\r\nr += O2HB_MAX_REGION_NAME_LEN;\r\n}\r\nlocalnr = min(O2NM_MAX_REGIONS, locallen/O2HB_MAX_REGION_NAME_LEN);\r\nlocalnr = o2hb_get_all_regions(local, (u8)localnr);\r\nl = local;\r\nfor (i = 0; i < localnr; ++i) {\r\nfoundit = 0;\r\nr = remote;\r\nfor (j = 0; j <= qr->qr_numregions; ++j) {\r\nif (!memcmp(l, r, O2HB_MAX_REGION_NAME_LEN)) {\r\nfoundit = 1;\r\nbreak;\r\n}\r\nr += O2HB_MAX_REGION_NAME_LEN;\r\n}\r\nif (!foundit) {\r\nstatus = -EINVAL;\r\nmlog(ML_ERROR, "Domain %s: Region '%.*s' registered "\r\n"in local node %d but not in joining node %d\n",\r\nqr->qr_domain, O2HB_MAX_REGION_NAME_LEN, l,\r\ndlm->node_num, qr->qr_node);\r\ngoto bail;\r\n}\r\nl += O2HB_MAX_REGION_NAME_LEN;\r\n}\r\nr = remote;\r\nfor (i = 0; i < qr->qr_numregions; ++i) {\r\nfoundit = 0;\r\nl = local;\r\nfor (j = 0; j < localnr; ++j) {\r\nif (!memcmp(r, l, O2HB_MAX_REGION_NAME_LEN)) {\r\nfoundit = 1;\r\nbreak;\r\n}\r\nl += O2HB_MAX_REGION_NAME_LEN;\r\n}\r\nif (!foundit) {\r\nstatus = -EINVAL;\r\nmlog(ML_ERROR, "Domain %s: Region '%.*s' registered "\r\n"in joining node %d but not in local node %d\n",\r\nqr->qr_domain, O2HB_MAX_REGION_NAME_LEN, r,\r\nqr->qr_node, dlm->node_num);\r\ngoto bail;\r\n}\r\nr += O2HB_MAX_REGION_NAME_LEN;\r\n}\r\nbail:\r\nreturn status;\r\n}\r\nstatic int dlm_send_regions(struct dlm_ctxt *dlm, unsigned long *node_map)\r\n{\r\nstruct dlm_query_region *qr = NULL;\r\nint status, ret = 0, i;\r\nchar *p;\r\nif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\r\ngoto bail;\r\nqr = kzalloc(sizeof(struct dlm_query_region), GFP_KERNEL);\r\nif (!qr) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto bail;\r\n}\r\nqr->qr_node = dlm->node_num;\r\nqr->qr_namelen = strlen(dlm->name);\r\nmemcpy(qr->qr_domain, dlm->name, qr->qr_namelen);\r\nif (o2hb_global_heartbeat_active())\r\nqr->qr_numregions = o2hb_get_all_regions(qr->qr_regions,\r\nO2NM_MAX_REGIONS);\r\np = qr->qr_regions;\r\nfor (i = 0; i < qr->qr_numregions; ++i, p += O2HB_MAX_REGION_NAME_LEN)\r\nmlog(0, "Region %.*s\n", O2HB_MAX_REGION_NAME_LEN, p);\r\ni = -1;\r\nwhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\r\ni + 1)) < O2NM_MAX_NODES) {\r\nif (i == dlm->node_num)\r\ncontinue;\r\nmlog(0, "Sending regions to node %d\n", i);\r\nret = o2net_send_message(DLM_QUERY_REGION, DLM_MOD_KEY, qr,\r\nsizeof(struct dlm_query_region),\r\ni, &status);\r\nif (ret >= 0)\r\nret = status;\r\nif (ret) {\r\nmlog(ML_ERROR, "Region mismatch %d, node %d\n",\r\nret, i);\r\nbreak;\r\n}\r\n}\r\nbail:\r\nkfree(qr);\r\nreturn ret;\r\n}\r\nstatic int dlm_query_region_handler(struct o2net_msg *msg, u32 len,\r\nvoid *data, void **ret_data)\r\n{\r\nstruct dlm_query_region *qr;\r\nstruct dlm_ctxt *dlm = NULL;\r\nchar *local = NULL;\r\nint status = 0;\r\nint locked = 0;\r\nqr = (struct dlm_query_region *) msg->buf;\r\nmlog(0, "Node %u queries hb regions on domain %s\n", qr->qr_node,\r\nqr->qr_domain);\r\nlocal = kmalloc(sizeof(qr->qr_regions), GFP_KERNEL);\r\nif (!local) {\r\nstatus = -ENOMEM;\r\ngoto bail;\r\n}\r\nstatus = -EINVAL;\r\nspin_lock(&dlm_domain_lock);\r\ndlm = __dlm_lookup_domain_full(qr->qr_domain, qr->qr_namelen);\r\nif (!dlm) {\r\nmlog(ML_ERROR, "Node %d queried hb regions on domain %s "\r\n"before join domain\n", qr->qr_node, qr->qr_domain);\r\ngoto bail;\r\n}\r\nspin_lock(&dlm->spinlock);\r\nlocked = 1;\r\nif (dlm->joining_node != qr->qr_node) {\r\nmlog(ML_ERROR, "Node %d queried hb regions on domain %s "\r\n"but joining node is %d\n", qr->qr_node, qr->qr_domain,\r\ndlm->joining_node);\r\ngoto bail;\r\n}\r\nif (dlm->dlm_locking_proto.pv_major == 1 &&\r\ndlm->dlm_locking_proto.pv_minor == 0) {\r\nmlog(ML_ERROR, "Node %d queried hb regions on domain %s "\r\n"but active dlm protocol is %d.%d\n", qr->qr_node,\r\nqr->qr_domain, dlm->dlm_locking_proto.pv_major,\r\ndlm->dlm_locking_proto.pv_minor);\r\ngoto bail;\r\n}\r\nstatus = dlm_match_regions(dlm, qr, local, sizeof(qr->qr_regions));\r\nbail:\r\nif (locked)\r\nspin_unlock(&dlm->spinlock);\r\nspin_unlock(&dlm_domain_lock);\r\nkfree(local);\r\nreturn status;\r\n}\r\nstatic int dlm_match_nodes(struct dlm_ctxt *dlm, struct dlm_query_nodeinfo *qn)\r\n{\r\nstruct o2nm_node *local;\r\nstruct dlm_node_info *remote;\r\nint i, j;\r\nint status = 0;\r\nfor (j = 0; j < qn->qn_numnodes; ++j)\r\nmlog(0, "Node %3d, %pI4:%u\n", qn->qn_nodes[j].ni_nodenum,\r\n&(qn->qn_nodes[j].ni_ipv4_address),\r\nntohs(qn->qn_nodes[j].ni_ipv4_port));\r\nfor (i = 0; i < O2NM_MAX_NODES && !status; ++i) {\r\nlocal = o2nm_get_node_by_num(i);\r\nremote = NULL;\r\nfor (j = 0; j < qn->qn_numnodes; ++j) {\r\nif (qn->qn_nodes[j].ni_nodenum == i) {\r\nremote = &(qn->qn_nodes[j]);\r\nbreak;\r\n}\r\n}\r\nif (!local && !remote)\r\ncontinue;\r\nif ((local && !remote) || (!local && remote))\r\nstatus = -EINVAL;\r\nif (!status &&\r\n((remote->ni_nodenum != local->nd_num) ||\r\n(remote->ni_ipv4_port != local->nd_ipv4_port) ||\r\n(remote->ni_ipv4_address != local->nd_ipv4_address)))\r\nstatus = -EINVAL;\r\nif (status) {\r\nif (remote && !local)\r\nmlog(ML_ERROR, "Domain %s: Node %d (%pI4:%u) "\r\n"registered in joining node %d but not in "\r\n"local node %d\n", qn->qn_domain,\r\nremote->ni_nodenum,\r\n&(remote->ni_ipv4_address),\r\nntohs(remote->ni_ipv4_port),\r\nqn->qn_nodenum, dlm->node_num);\r\nif (local && !remote)\r\nmlog(ML_ERROR, "Domain %s: Node %d (%pI4:%u) "\r\n"registered in local node %d but not in "\r\n"joining node %d\n", qn->qn_domain,\r\nlocal->nd_num, &(local->nd_ipv4_address),\r\nntohs(local->nd_ipv4_port),\r\ndlm->node_num, qn->qn_nodenum);\r\nBUG_ON((!local && !remote));\r\n}\r\nif (local)\r\no2nm_node_put(local);\r\n}\r\nreturn status;\r\n}\r\nstatic int dlm_send_nodeinfo(struct dlm_ctxt *dlm, unsigned long *node_map)\r\n{\r\nstruct dlm_query_nodeinfo *qn = NULL;\r\nstruct o2nm_node *node;\r\nint ret = 0, status, count, i;\r\nif (find_next_bit(node_map, O2NM_MAX_NODES, 0) >= O2NM_MAX_NODES)\r\ngoto bail;\r\nqn = kzalloc(sizeof(struct dlm_query_nodeinfo), GFP_KERNEL);\r\nif (!qn) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto bail;\r\n}\r\nfor (i = 0, count = 0; i < O2NM_MAX_NODES; ++i) {\r\nnode = o2nm_get_node_by_num(i);\r\nif (!node)\r\ncontinue;\r\nqn->qn_nodes[count].ni_nodenum = node->nd_num;\r\nqn->qn_nodes[count].ni_ipv4_port = node->nd_ipv4_port;\r\nqn->qn_nodes[count].ni_ipv4_address = node->nd_ipv4_address;\r\nmlog(0, "Node %3d, %pI4:%u\n", node->nd_num,\r\n&(node->nd_ipv4_address), ntohs(node->nd_ipv4_port));\r\n++count;\r\no2nm_node_put(node);\r\n}\r\nqn->qn_nodenum = dlm->node_num;\r\nqn->qn_numnodes = count;\r\nqn->qn_namelen = strlen(dlm->name);\r\nmemcpy(qn->qn_domain, dlm->name, qn->qn_namelen);\r\ni = -1;\r\nwhile ((i = find_next_bit(node_map, O2NM_MAX_NODES,\r\ni + 1)) < O2NM_MAX_NODES) {\r\nif (i == dlm->node_num)\r\ncontinue;\r\nmlog(0, "Sending nodeinfo to node %d\n", i);\r\nret = o2net_send_message(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\r\nqn, sizeof(struct dlm_query_nodeinfo),\r\ni, &status);\r\nif (ret >= 0)\r\nret = status;\r\nif (ret) {\r\nmlog(ML_ERROR, "node mismatch %d, node %d\n", ret, i);\r\nbreak;\r\n}\r\n}\r\nbail:\r\nkfree(qn);\r\nreturn ret;\r\n}\r\nstatic int dlm_query_nodeinfo_handler(struct o2net_msg *msg, u32 len,\r\nvoid *data, void **ret_data)\r\n{\r\nstruct dlm_query_nodeinfo *qn;\r\nstruct dlm_ctxt *dlm = NULL;\r\nint locked = 0, status = -EINVAL;\r\nqn = (struct dlm_query_nodeinfo *) msg->buf;\r\nmlog(0, "Node %u queries nodes on domain %s\n", qn->qn_nodenum,\r\nqn->qn_domain);\r\nspin_lock(&dlm_domain_lock);\r\ndlm = __dlm_lookup_domain_full(qn->qn_domain, qn->qn_namelen);\r\nif (!dlm) {\r\nmlog(ML_ERROR, "Node %d queried nodes on domain %s before "\r\n"join domain\n", qn->qn_nodenum, qn->qn_domain);\r\ngoto bail;\r\n}\r\nspin_lock(&dlm->spinlock);\r\nlocked = 1;\r\nif (dlm->joining_node != qn->qn_nodenum) {\r\nmlog(ML_ERROR, "Node %d queried nodes on domain %s but "\r\n"joining node is %d\n", qn->qn_nodenum, qn->qn_domain,\r\ndlm->joining_node);\r\ngoto bail;\r\n}\r\nif (dlm->dlm_locking_proto.pv_major == 1 &&\r\ndlm->dlm_locking_proto.pv_minor == 0) {\r\nmlog(ML_ERROR, "Node %d queried nodes on domain %s "\r\n"but active dlm protocol is %d.%d\n", qn->qn_nodenum,\r\nqn->qn_domain, dlm->dlm_locking_proto.pv_major,\r\ndlm->dlm_locking_proto.pv_minor);\r\ngoto bail;\r\n}\r\nstatus = dlm_match_nodes(dlm, qn);\r\nbail:\r\nif (locked)\r\nspin_unlock(&dlm->spinlock);\r\nspin_unlock(&dlm_domain_lock);\r\nreturn status;\r\n}\r\nstatic int dlm_cancel_join_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_cancel_join *cancel;\r\nstruct dlm_ctxt *dlm = NULL;\r\ncancel = (struct dlm_cancel_join *) msg->buf;\r\nmlog(0, "node %u cancels join on domain %s\n", cancel->node_idx,\r\ncancel->domain);\r\nspin_lock(&dlm_domain_lock);\r\ndlm = __dlm_lookup_domain_full(cancel->domain, cancel->name_len);\r\nif (dlm) {\r\nspin_lock(&dlm->spinlock);\r\nBUG_ON(dlm->joining_node != cancel->node_idx);\r\n__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nspin_unlock(&dlm_domain_lock);\r\nreturn 0;\r\n}\r\nstatic int dlm_send_one_join_cancel(struct dlm_ctxt *dlm,\r\nunsigned int node)\r\n{\r\nint status;\r\nstruct dlm_cancel_join cancel_msg;\r\nmemset(&cancel_msg, 0, sizeof(cancel_msg));\r\ncancel_msg.node_idx = dlm->node_num;\r\ncancel_msg.name_len = strlen(dlm->name);\r\nmemcpy(cancel_msg.domain, dlm->name, cancel_msg.name_len);\r\nstatus = o2net_send_message(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\r\n&cancel_msg, sizeof(cancel_msg), node,\r\nNULL);\r\nif (status < 0) {\r\nmlog(ML_ERROR, "Error %d when sending message %u (key 0x%x) to "\r\n"node %u\n", status, DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\r\nnode);\r\ngoto bail;\r\n}\r\nbail:\r\nreturn status;\r\n}\r\nstatic int dlm_send_join_cancels(struct dlm_ctxt *dlm,\r\nunsigned long *node_map,\r\nunsigned int map_size)\r\n{\r\nint status, tmpstat;\r\nunsigned int node;\r\nif (map_size != (BITS_TO_LONGS(O2NM_MAX_NODES) *\r\nsizeof(unsigned long))) {\r\nmlog(ML_ERROR,\r\n"map_size %u != BITS_TO_LONGS(O2NM_MAX_NODES) %u\n",\r\nmap_size, (unsigned)BITS_TO_LONGS(O2NM_MAX_NODES));\r\nreturn -EINVAL;\r\n}\r\nstatus = 0;\r\nnode = -1;\r\nwhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\r\nnode + 1)) < O2NM_MAX_NODES) {\r\nif (node == dlm->node_num)\r\ncontinue;\r\ntmpstat = dlm_send_one_join_cancel(dlm, node);\r\nif (tmpstat) {\r\nmlog(ML_ERROR, "Error return %d cancelling join on "\r\n"node %d\n", tmpstat, node);\r\nif (!status)\r\nstatus = tmpstat;\r\n}\r\n}\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int dlm_request_join(struct dlm_ctxt *dlm,\r\nint node,\r\nenum dlm_query_join_response_code *response)\r\n{\r\nint status;\r\nstruct dlm_query_join_request join_msg;\r\nstruct dlm_query_join_packet packet;\r\nu32 join_resp;\r\nmlog(0, "querying node %d\n", node);\r\nmemset(&join_msg, 0, sizeof(join_msg));\r\njoin_msg.node_idx = dlm->node_num;\r\njoin_msg.name_len = strlen(dlm->name);\r\nmemcpy(join_msg.domain, dlm->name, join_msg.name_len);\r\njoin_msg.dlm_proto = dlm->dlm_locking_proto;\r\njoin_msg.fs_proto = dlm->fs_locking_proto;\r\nbyte_copymap(join_msg.node_map, dlm->live_nodes_map, O2NM_MAX_NODES);\r\nstatus = o2net_send_message(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY, &join_msg,\r\nsizeof(join_msg), node, &join_resp);\r\nif (status < 0 && status != -ENOPROTOOPT) {\r\nmlog(ML_ERROR, "Error %d when sending message %u (key 0x%x) to "\r\n"node %u\n", status, DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\r\nnode);\r\ngoto bail;\r\n}\r\ndlm_query_join_wire_to_packet(join_resp, &packet);\r\nif (status == -ENOPROTOOPT) {\r\nstatus = 0;\r\n*response = JOIN_OK_NO_MAP;\r\n} else if (packet.code == JOIN_DISALLOW ||\r\npacket.code == JOIN_OK_NO_MAP) {\r\n*response = packet.code;\r\n} else if (packet.code == JOIN_PROTOCOL_MISMATCH) {\r\nmlog(ML_NOTICE,\r\n"This node requested DLM locking protocol %u.%u and "\r\n"filesystem locking protocol %u.%u. At least one of "\r\n"the protocol versions on node %d is not compatible, "\r\n"disconnecting\n",\r\ndlm->dlm_locking_proto.pv_major,\r\ndlm->dlm_locking_proto.pv_minor,\r\ndlm->fs_locking_proto.pv_major,\r\ndlm->fs_locking_proto.pv_minor,\r\nnode);\r\nstatus = -EPROTO;\r\n*response = packet.code;\r\n} else if (packet.code == JOIN_OK) {\r\n*response = packet.code;\r\ndlm->dlm_locking_proto.pv_minor = packet.dlm_minor;\r\ndlm->fs_locking_proto.pv_minor = packet.fs_minor;\r\nmlog(0,\r\n"Node %d responds JOIN_OK with DLM locking protocol "\r\n"%u.%u and fs locking protocol %u.%u\n",\r\nnode,\r\ndlm->dlm_locking_proto.pv_major,\r\ndlm->dlm_locking_proto.pv_minor,\r\ndlm->fs_locking_proto.pv_major,\r\ndlm->fs_locking_proto.pv_minor);\r\n} else {\r\nstatus = -EINVAL;\r\nmlog(ML_ERROR, "invalid response %d from node %u\n",\r\npacket.code, node);\r\n}\r\nmlog(0, "status %d, node %d response is %d\n", status, node,\r\n*response);\r\nbail:\r\nreturn status;\r\n}\r\nstatic int dlm_send_one_join_assert(struct dlm_ctxt *dlm,\r\nunsigned int node)\r\n{\r\nint status;\r\nstruct dlm_assert_joined assert_msg;\r\nmlog(0, "Sending join assert to node %u\n", node);\r\nmemset(&assert_msg, 0, sizeof(assert_msg));\r\nassert_msg.node_idx = dlm->node_num;\r\nassert_msg.name_len = strlen(dlm->name);\r\nmemcpy(assert_msg.domain, dlm->name, assert_msg.name_len);\r\nstatus = o2net_send_message(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\r\n&assert_msg, sizeof(assert_msg), node,\r\nNULL);\r\nif (status < 0)\r\nmlog(ML_ERROR, "Error %d when sending message %u (key 0x%x) to "\r\n"node %u\n", status, DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\r\nnode);\r\nreturn status;\r\n}\r\nstatic void dlm_send_join_asserts(struct dlm_ctxt *dlm,\r\nunsigned long *node_map)\r\n{\r\nint status, node, live;\r\nstatus = 0;\r\nnode = -1;\r\nwhile ((node = find_next_bit(node_map, O2NM_MAX_NODES,\r\nnode + 1)) < O2NM_MAX_NODES) {\r\nif (node == dlm->node_num)\r\ncontinue;\r\ndo {\r\nstatus = dlm_send_one_join_assert(dlm, node);\r\nspin_lock(&dlm->spinlock);\r\nlive = test_bit(node, dlm->live_nodes_map);\r\nspin_unlock(&dlm->spinlock);\r\nif (status) {\r\nmlog(ML_ERROR, "Error return %d asserting "\r\n"join on node %d\n", status, node);\r\nif (live)\r\nmsleep(DLM_DOMAIN_BACKOFF_MS);\r\n}\r\n} while (status && live);\r\n}\r\n}\r\nstatic int dlm_should_restart_join(struct dlm_ctxt *dlm,\r\nstruct domain_join_ctxt *ctxt,\r\nenum dlm_query_join_response_code response)\r\n{\r\nint ret;\r\nif (response == JOIN_DISALLOW) {\r\nmlog(0, "Latest response of disallow -- should restart\n");\r\nreturn 1;\r\n}\r\nspin_lock(&dlm->spinlock);\r\nret = memcmp(ctxt->live_map, dlm->live_nodes_map,\r\nsizeof(dlm->live_nodes_map));\r\nspin_unlock(&dlm->spinlock);\r\nif (ret)\r\nmlog(0, "Node maps changed -- should restart\n");\r\nreturn ret;\r\n}\r\nstatic int dlm_try_to_join_domain(struct dlm_ctxt *dlm)\r\n{\r\nint status = 0, tmpstat, node;\r\nstruct domain_join_ctxt *ctxt;\r\nenum dlm_query_join_response_code response = JOIN_DISALLOW;\r\nmlog(0, "%p", dlm);\r\nctxt = kzalloc(sizeof(*ctxt), GFP_KERNEL);\r\nif (!ctxt) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\no2hb_fill_node_map(dlm->live_nodes_map, sizeof(dlm->live_nodes_map));\r\nspin_lock(&dlm->spinlock);\r\nmemcpy(ctxt->live_map, dlm->live_nodes_map, sizeof(ctxt->live_map));\r\n__dlm_set_joining_node(dlm, dlm->node_num);\r\nspin_unlock(&dlm->spinlock);\r\nnode = -1;\r\nwhile ((node = find_next_bit(ctxt->live_map, O2NM_MAX_NODES,\r\nnode + 1)) < O2NM_MAX_NODES) {\r\nif (node == dlm->node_num)\r\ncontinue;\r\nstatus = dlm_request_join(dlm, node, &response);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nif (response == JOIN_OK)\r\nset_bit(node, ctxt->yes_resp_map);\r\nif (dlm_should_restart_join(dlm, ctxt, response)) {\r\nstatus = -EAGAIN;\r\ngoto bail;\r\n}\r\n}\r\nmlog(0, "Yay, done querying nodes!\n");\r\nspin_lock(&dlm->spinlock);\r\nmemcpy(dlm->domain_map, ctxt->yes_resp_map,\r\nsizeof(ctxt->yes_resp_map));\r\nset_bit(dlm->node_num, dlm->domain_map);\r\nspin_unlock(&dlm->spinlock);\r\nif (dlm->dlm_locking_proto.pv_major > 1 ||\r\ndlm->dlm_locking_proto.pv_minor > 0) {\r\nstatus = dlm_send_nodeinfo(dlm, ctxt->yes_resp_map);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = dlm_send_regions(dlm, ctxt->yes_resp_map);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\n}\r\ndlm_send_join_asserts(dlm, ctxt->yes_resp_map);\r\nspin_lock(&dlm_domain_lock);\r\ndlm->dlm_state = DLM_CTXT_JOINED;\r\ndlm->num_joins++;\r\nspin_unlock(&dlm_domain_lock);\r\nbail:\r\nspin_lock(&dlm->spinlock);\r\n__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\r\nif (!status)\r\n__dlm_print_nodes(dlm);\r\nspin_unlock(&dlm->spinlock);\r\nif (ctxt) {\r\nif (status < 0) {\r\ntmpstat = dlm_send_join_cancels(dlm,\r\nctxt->yes_resp_map,\r\nsizeof(ctxt->yes_resp_map));\r\nif (tmpstat < 0)\r\nmlog_errno(tmpstat);\r\n}\r\nkfree(ctxt);\r\n}\r\nmlog(0, "returning %d\n", status);\r\nreturn status;\r\n}\r\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)\r\n{\r\no2hb_unregister_callback(dlm->name, &dlm->dlm_hb_up);\r\no2hb_unregister_callback(dlm->name, &dlm->dlm_hb_down);\r\no2net_unregister_handler_list(&dlm->dlm_domain_handlers);\r\n}\r\nstatic int dlm_register_domain_handlers(struct dlm_ctxt *dlm)\r\n{\r\nint status;\r\nmlog(0, "registering handlers.\n");\r\no2hb_setup_callback(&dlm->dlm_hb_down, O2HB_NODE_DOWN_CB,\r\ndlm_hb_node_down_cb, dlm, DLM_HB_NODE_DOWN_PRI);\r\nstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_down);\r\nif (status)\r\ngoto bail;\r\no2hb_setup_callback(&dlm->dlm_hb_up, O2HB_NODE_UP_CB,\r\ndlm_hb_node_up_cb, dlm, DLM_HB_NODE_UP_PRI);\r\nstatus = o2hb_register_callback(dlm->name, &dlm->dlm_hb_up);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_MASTER_REQUEST_MSG, dlm->key,\r\nsizeof(struct dlm_master_request),\r\ndlm_master_request_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_ASSERT_MASTER_MSG, dlm->key,\r\nsizeof(struct dlm_assert_master),\r\ndlm_assert_master_handler,\r\ndlm, dlm_assert_master_post_handler,\r\n&dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_CREATE_LOCK_MSG, dlm->key,\r\nsizeof(struct dlm_create_lock),\r\ndlm_create_lock_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_CONVERT_LOCK_MSG, dlm->key,\r\nDLM_CONVERT_LOCK_MAX_LEN,\r\ndlm_convert_lock_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_UNLOCK_LOCK_MSG, dlm->key,\r\nDLM_UNLOCK_LOCK_MAX_LEN,\r\ndlm_unlock_lock_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_PROXY_AST_MSG, dlm->key,\r\nDLM_PROXY_AST_MAX_LEN,\r\ndlm_proxy_ast_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_EXIT_DOMAIN_MSG, dlm->key,\r\nsizeof(struct dlm_exit_domain),\r\ndlm_exit_domain_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_DEREF_LOCKRES_MSG, dlm->key,\r\nsizeof(struct dlm_deref_lockres),\r\ndlm_deref_lockres_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_MIGRATE_REQUEST_MSG, dlm->key,\r\nsizeof(struct dlm_migrate_request),\r\ndlm_migrate_request_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_MIG_LOCKRES_MSG, dlm->key,\r\nDLM_MIG_LOCKRES_MAX_LEN,\r\ndlm_mig_lockres_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_MASTER_REQUERY_MSG, dlm->key,\r\nsizeof(struct dlm_master_requery),\r\ndlm_master_requery_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_LOCK_REQUEST_MSG, dlm->key,\r\nsizeof(struct dlm_lock_request),\r\ndlm_request_all_locks_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_RECO_DATA_DONE_MSG, dlm->key,\r\nsizeof(struct dlm_reco_data_done),\r\ndlm_reco_data_done_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_BEGIN_RECO_MSG, dlm->key,\r\nsizeof(struct dlm_begin_reco),\r\ndlm_begin_reco_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_FINALIZE_RECO_MSG, dlm->key,\r\nsizeof(struct dlm_finalize_reco),\r\ndlm_finalize_reco_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_BEGIN_EXIT_DOMAIN_MSG, dlm->key,\r\nsizeof(struct dlm_exit_domain),\r\ndlm_begin_exit_domain_handler,\r\ndlm, NULL, &dlm->dlm_domain_handlers);\r\nif (status)\r\ngoto bail;\r\nbail:\r\nif (status)\r\ndlm_unregister_domain_handlers(dlm);\r\nreturn status;\r\n}\r\nstatic int dlm_join_domain(struct dlm_ctxt *dlm)\r\n{\r\nint status;\r\nunsigned int backoff;\r\nunsigned int total_backoff = 0;\r\nBUG_ON(!dlm);\r\nmlog(0, "Join domain %s\n", dlm->name);\r\nstatus = dlm_register_domain_handlers(dlm);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = dlm_debug_init(dlm);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = dlm_launch_thread(dlm);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = dlm_launch_recovery_thread(dlm);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\ndlm->dlm_worker = create_singlethread_workqueue("dlm_wq");\r\nif (!dlm->dlm_worker) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\ndo {\r\nstatus = dlm_try_to_join_domain(dlm);\r\n#define DLM_JOIN_TIMEOUT_MSECS 90000\r\nif (status == -EAGAIN) {\r\nif (signal_pending(current)) {\r\nstatus = -ERESTARTSYS;\r\ngoto bail;\r\n}\r\nif (total_backoff >\r\nmsecs_to_jiffies(DLM_JOIN_TIMEOUT_MSECS)) {\r\nstatus = -ERESTARTSYS;\r\nmlog(ML_NOTICE, "Timed out joining dlm domain "\r\n"%s after %u msecs\n", dlm->name,\r\njiffies_to_msecs(total_backoff));\r\ngoto bail;\r\n}\r\nbackoff = (unsigned int)(jiffies & 0x3);\r\nbackoff *= DLM_DOMAIN_BACKOFF_MS;\r\ntotal_backoff += backoff;\r\nmlog(0, "backoff %d\n", backoff);\r\nmsleep(backoff);\r\n}\r\n} while (status == -EAGAIN);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = 0;\r\nbail:\r\nwake_up(&dlm_domain_events);\r\nif (status) {\r\ndlm_unregister_domain_handlers(dlm);\r\ndlm_debug_shutdown(dlm);\r\ndlm_complete_thread(dlm);\r\ndlm_complete_recovery_thread(dlm);\r\ndlm_destroy_dlm_worker(dlm);\r\n}\r\nreturn status;\r\n}\r\nstatic struct dlm_ctxt *dlm_alloc_ctxt(const char *domain,\r\nu32 key)\r\n{\r\nint i;\r\nint ret;\r\nstruct dlm_ctxt *dlm = NULL;\r\ndlm = kzalloc(sizeof(*dlm), GFP_KERNEL);\r\nif (!dlm) {\r\nmlog_errno(-ENOMEM);\r\ngoto leave;\r\n}\r\ndlm->name = kstrdup(domain, GFP_KERNEL);\r\nif (dlm->name == NULL) {\r\nmlog_errno(-ENOMEM);\r\nkfree(dlm);\r\ndlm = NULL;\r\ngoto leave;\r\n}\r\ndlm->lockres_hash = (struct hlist_head **)dlm_alloc_pagevec(DLM_HASH_PAGES);\r\nif (!dlm->lockres_hash) {\r\nmlog_errno(-ENOMEM);\r\nkfree(dlm->name);\r\nkfree(dlm);\r\ndlm = NULL;\r\ngoto leave;\r\n}\r\nfor (i = 0; i < DLM_HASH_BUCKETS; i++)\r\nINIT_HLIST_HEAD(dlm_lockres_hash(dlm, i));\r\ndlm->master_hash = (struct hlist_head **)\r\ndlm_alloc_pagevec(DLM_HASH_PAGES);\r\nif (!dlm->master_hash) {\r\nmlog_errno(-ENOMEM);\r\ndlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\r\nkfree(dlm->name);\r\nkfree(dlm);\r\ndlm = NULL;\r\ngoto leave;\r\n}\r\nfor (i = 0; i < DLM_HASH_BUCKETS; i++)\r\nINIT_HLIST_HEAD(dlm_master_hash(dlm, i));\r\ndlm->key = key;\r\ndlm->node_num = o2nm_this_node();\r\nret = dlm_create_debugfs_subroot(dlm);\r\nif (ret < 0) {\r\ndlm_free_pagevec((void **)dlm->master_hash, DLM_HASH_PAGES);\r\ndlm_free_pagevec((void **)dlm->lockres_hash, DLM_HASH_PAGES);\r\nkfree(dlm->name);\r\nkfree(dlm);\r\ndlm = NULL;\r\ngoto leave;\r\n}\r\nspin_lock_init(&dlm->spinlock);\r\nspin_lock_init(&dlm->master_lock);\r\nspin_lock_init(&dlm->ast_lock);\r\nspin_lock_init(&dlm->track_lock);\r\nINIT_LIST_HEAD(&dlm->list);\r\nINIT_LIST_HEAD(&dlm->dirty_list);\r\nINIT_LIST_HEAD(&dlm->reco.resources);\r\nINIT_LIST_HEAD(&dlm->reco.received);\r\nINIT_LIST_HEAD(&dlm->reco.node_data);\r\nINIT_LIST_HEAD(&dlm->purge_list);\r\nINIT_LIST_HEAD(&dlm->dlm_domain_handlers);\r\nINIT_LIST_HEAD(&dlm->tracking_list);\r\ndlm->reco.state = 0;\r\nINIT_LIST_HEAD(&dlm->pending_asts);\r\nINIT_LIST_HEAD(&dlm->pending_basts);\r\nmlog(0, "dlm->recovery_map=%p, &(dlm->recovery_map[0])=%p\n",\r\ndlm->recovery_map, &(dlm->recovery_map[0]));\r\nmemset(dlm->recovery_map, 0, sizeof(dlm->recovery_map));\r\nmemset(dlm->live_nodes_map, 0, sizeof(dlm->live_nodes_map));\r\nmemset(dlm->domain_map, 0, sizeof(dlm->domain_map));\r\ndlm->dlm_thread_task = NULL;\r\ndlm->dlm_reco_thread_task = NULL;\r\ndlm->dlm_worker = NULL;\r\ninit_waitqueue_head(&dlm->dlm_thread_wq);\r\ninit_waitqueue_head(&dlm->dlm_reco_thread_wq);\r\ninit_waitqueue_head(&dlm->reco.event);\r\ninit_waitqueue_head(&dlm->ast_wq);\r\ninit_waitqueue_head(&dlm->migration_wq);\r\nINIT_LIST_HEAD(&dlm->mle_hb_events);\r\ndlm->joining_node = DLM_LOCK_RES_OWNER_UNKNOWN;\r\ninit_waitqueue_head(&dlm->dlm_join_events);\r\ndlm->reco.new_master = O2NM_INVALID_NODE_NUM;\r\ndlm->reco.dead_node = O2NM_INVALID_NODE_NUM;\r\natomic_set(&dlm->res_tot_count, 0);\r\natomic_set(&dlm->res_cur_count, 0);\r\nfor (i = 0; i < DLM_MLE_NUM_TYPES; ++i) {\r\natomic_set(&dlm->mle_tot_count[i], 0);\r\natomic_set(&dlm->mle_cur_count[i], 0);\r\n}\r\nspin_lock_init(&dlm->work_lock);\r\nINIT_LIST_HEAD(&dlm->work_list);\r\nINIT_WORK(&dlm->dispatched_work, dlm_dispatch_work);\r\nkref_init(&dlm->dlm_refs);\r\ndlm->dlm_state = DLM_CTXT_NEW;\r\nINIT_LIST_HEAD(&dlm->dlm_eviction_callbacks);\r\nmlog(0, "context init: refcount %u\n",\r\natomic_read(&dlm->dlm_refs.refcount));\r\nleave:\r\nreturn dlm;\r\n}\r\nstatic int dlm_protocol_compare(struct dlm_protocol_version *existing,\r\nstruct dlm_protocol_version *request)\r\n{\r\nif (existing->pv_major != request->pv_major)\r\nreturn 1;\r\nif (existing->pv_minor > request->pv_minor)\r\nreturn 1;\r\nif (existing->pv_minor < request->pv_minor)\r\nrequest->pv_minor = existing->pv_minor;\r\nreturn 0;\r\n}\r\nstruct dlm_ctxt * dlm_register_domain(const char *domain,\r\nu32 key,\r\nstruct dlm_protocol_version *fs_proto)\r\n{\r\nint ret;\r\nstruct dlm_ctxt *dlm = NULL;\r\nstruct dlm_ctxt *new_ctxt = NULL;\r\nif (strlen(domain) >= O2NM_MAX_NAME_LEN) {\r\nret = -ENAMETOOLONG;\r\nmlog(ML_ERROR, "domain name length too long\n");\r\ngoto leave;\r\n}\r\nif (!o2hb_check_local_node_heartbeating()) {\r\nmlog(ML_ERROR, "the local node has not been configured, or is "\r\n"not heartbeating\n");\r\nret = -EPROTO;\r\ngoto leave;\r\n}\r\nmlog(0, "register called for domain \"%s\"\n", domain);\r\nretry:\r\ndlm = NULL;\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nmlog_errno(ret);\r\ngoto leave;\r\n}\r\nspin_lock(&dlm_domain_lock);\r\ndlm = __dlm_lookup_domain(domain);\r\nif (dlm) {\r\nif (dlm->dlm_state != DLM_CTXT_JOINED) {\r\nspin_unlock(&dlm_domain_lock);\r\nmlog(0, "This ctxt is not joined yet!\n");\r\nwait_event_interruptible(dlm_domain_events,\r\ndlm_wait_on_domain_helper(\r\ndomain));\r\ngoto retry;\r\n}\r\nif (dlm_protocol_compare(&dlm->fs_locking_proto, fs_proto)) {\r\nspin_unlock(&dlm_domain_lock);\r\nmlog(ML_ERROR,\r\n"Requested locking protocol version is not "\r\n"compatible with already registered domain "\r\n"\"%s\"\n", domain);\r\nret = -EPROTO;\r\ngoto leave;\r\n}\r\n__dlm_get(dlm);\r\ndlm->num_joins++;\r\nspin_unlock(&dlm_domain_lock);\r\nret = 0;\r\ngoto leave;\r\n}\r\nif (!new_ctxt) {\r\nspin_unlock(&dlm_domain_lock);\r\nnew_ctxt = dlm_alloc_ctxt(domain, key);\r\nif (new_ctxt)\r\ngoto retry;\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto leave;\r\n}\r\ndlm = new_ctxt;\r\nnew_ctxt = NULL;\r\nlist_add_tail(&dlm->list, &dlm_domains);\r\nspin_unlock(&dlm_domain_lock);\r\ndlm->dlm_locking_proto = dlm_protocol;\r\ndlm->fs_locking_proto = *fs_proto;\r\nret = dlm_join_domain(dlm);\r\nif (ret) {\r\nmlog_errno(ret);\r\ndlm_put(dlm);\r\ngoto leave;\r\n}\r\n*fs_proto = dlm->fs_locking_proto;\r\nret = 0;\r\nleave:\r\nif (new_ctxt)\r\ndlm_free_ctxt_mem(new_ctxt);\r\nif (ret < 0)\r\ndlm = ERR_PTR(ret);\r\nreturn dlm;\r\n}\r\nstatic void dlm_unregister_net_handlers(void)\r\n{\r\no2net_unregister_handler_list(&dlm_join_handlers);\r\n}\r\nstatic int dlm_register_net_handlers(void)\r\n{\r\nint status = 0;\r\nstatus = o2net_register_handler(DLM_QUERY_JOIN_MSG, DLM_MOD_KEY,\r\nsizeof(struct dlm_query_join_request),\r\ndlm_query_join_handler,\r\nNULL, NULL, &dlm_join_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_ASSERT_JOINED_MSG, DLM_MOD_KEY,\r\nsizeof(struct dlm_assert_joined),\r\ndlm_assert_joined_handler,\r\nNULL, NULL, &dlm_join_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_CANCEL_JOIN_MSG, DLM_MOD_KEY,\r\nsizeof(struct dlm_cancel_join),\r\ndlm_cancel_join_handler,\r\nNULL, NULL, &dlm_join_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_QUERY_REGION, DLM_MOD_KEY,\r\nsizeof(struct dlm_query_region),\r\ndlm_query_region_handler,\r\nNULL, NULL, &dlm_join_handlers);\r\nif (status)\r\ngoto bail;\r\nstatus = o2net_register_handler(DLM_QUERY_NODEINFO, DLM_MOD_KEY,\r\nsizeof(struct dlm_query_nodeinfo),\r\ndlm_query_nodeinfo_handler,\r\nNULL, NULL, &dlm_join_handlers);\r\nbail:\r\nif (status < 0)\r\ndlm_unregister_net_handlers();\r\nreturn status;\r\n}\r\nvoid dlm_fire_domain_eviction_callbacks(struct dlm_ctxt *dlm,\r\nint node_num)\r\n{\r\nstruct list_head *iter;\r\nstruct dlm_eviction_cb *cb;\r\ndown_read(&dlm_callback_sem);\r\nlist_for_each(iter, &dlm->dlm_eviction_callbacks) {\r\ncb = list_entry(iter, struct dlm_eviction_cb, ec_item);\r\ncb->ec_func(node_num, cb->ec_data);\r\n}\r\nup_read(&dlm_callback_sem);\r\n}\r\nvoid dlm_setup_eviction_cb(struct dlm_eviction_cb *cb,\r\ndlm_eviction_func *f,\r\nvoid *data)\r\n{\r\nINIT_LIST_HEAD(&cb->ec_item);\r\ncb->ec_func = f;\r\ncb->ec_data = data;\r\n}\r\nvoid dlm_register_eviction_cb(struct dlm_ctxt *dlm,\r\nstruct dlm_eviction_cb *cb)\r\n{\r\ndown_write(&dlm_callback_sem);\r\nlist_add_tail(&cb->ec_item, &dlm->dlm_eviction_callbacks);\r\nup_write(&dlm_callback_sem);\r\n}\r\nvoid dlm_unregister_eviction_cb(struct dlm_eviction_cb *cb)\r\n{\r\ndown_write(&dlm_callback_sem);\r\nlist_del_init(&cb->ec_item);\r\nup_write(&dlm_callback_sem);\r\n}\r\nstatic int __init dlm_init(void)\r\n{\r\nint status;\r\ndlm_print_version();\r\nstatus = dlm_init_mle_cache();\r\nif (status) {\r\nmlog(ML_ERROR, "Could not create o2dlm_mle slabcache\n");\r\ngoto error;\r\n}\r\nstatus = dlm_init_master_caches();\r\nif (status) {\r\nmlog(ML_ERROR, "Could not create o2dlm_lockres and "\r\n"o2dlm_lockname slabcaches\n");\r\ngoto error;\r\n}\r\nstatus = dlm_init_lock_cache();\r\nif (status) {\r\nmlog(ML_ERROR, "Count not create o2dlm_lock slabcache\n");\r\ngoto error;\r\n}\r\nstatus = dlm_register_net_handlers();\r\nif (status) {\r\nmlog(ML_ERROR, "Unable to register network handlers\n");\r\ngoto error;\r\n}\r\nstatus = dlm_create_debugfs_root();\r\nif (status)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ndlm_unregister_net_handlers();\r\ndlm_destroy_lock_cache();\r\ndlm_destroy_master_caches();\r\ndlm_destroy_mle_cache();\r\nreturn -1;\r\n}\r\nstatic void __exit dlm_exit (void)\r\n{\r\ndlm_destroy_debugfs_root();\r\ndlm_unregister_net_handlers();\r\ndlm_destroy_lock_cache();\r\ndlm_destroy_master_caches();\r\ndlm_destroy_mle_cache();\r\n}
