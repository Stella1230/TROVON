static void opticon_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct opticon_private *priv = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct usb_serial_port *port = priv->port;\r\nint status = urb->status;\r\nstruct tty_struct *tty;\r\nint result;\r\nint data_length;\r\nunsigned long flags;\r\ndbg("%s - port %d", __func__, port->number);\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length,\r\ndata);\r\nif (urb->actual_length > 2) {\r\ndata_length = urb->actual_length - 2;\r\nif ((data[0] == 0x00) && (data[1] == 0x00)) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\ntty_insert_flip_string(tty, data + 2,\r\ndata_length);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\n} else {\r\nif ((data[0] == 0x00) && (data[1] == 0x01)) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (data[2] == 0x00)\r\npriv->cts = false;\r\nelse\r\npriv->cts = true;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n} else {\r\ndev_dbg(&priv->udev->dev,\r\n"Unknown data packet received from the device:"\r\n" %2x %2x\n",\r\ndata[0], data[1]);\r\n}\r\n}\r\n} else {\r\ndev_dbg(&priv->udev->dev,\r\n"Improper amount of data received from the device, "\r\n"%d bytes", urb->actual_length);\r\n}\r\nexit:\r\nspin_lock(&priv->lock);\r\nif (!priv->throttled) {\r\nusb_fill_bulk_urb(priv->bulk_read_urb, priv->udev,\r\nusb_rcvbulkpipe(priv->udev,\r\npriv->bulk_address),\r\npriv->bulk_in_buffer, priv->buffer_size,\r\nopticon_read_bulk_callback, priv);\r\nresult = usb_submit_urb(priv->bulk_read_urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed resubmitting read urb, error %d\n",\r\n__func__, result);\r\n} else\r\npriv->actually_throttled = true;\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic int send_control_msg(struct usb_serial_port *port, u8 requesttype,\r\nu8 val)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nint retval;\r\nu8 buffer[2];\r\nbuffer[0] = val;\r\nretval = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nrequesttype,\r\nUSB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\r\n0, 0, buffer, 1, 0);\r\nreturn retval;\r\n}\r\nstatic int opticon_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\nunsigned long flags;\r\nint result = 0;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->throttled = false;\r\npriv->actually_throttled = false;\r\npriv->port = port;\r\npriv->rts = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nsend_control_msg(port, CONTROL_RTS, 0);\r\nusb_fill_bulk_urb(priv->bulk_read_urb, priv->udev,\r\nusb_rcvbulkpipe(priv->udev,\r\npriv->bulk_address),\r\npriv->bulk_in_buffer, priv->buffer_size,\r\nopticon_read_bulk_callback, priv);\r\nusb_clear_halt(priv->udev, priv->bulk_read_urb->pipe);\r\nresult = usb_submit_urb(priv->bulk_read_urb, GFP_KERNEL);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed resubmitting read urb, error %d\n",\r\n__func__, result);\r\nsend_control_msg(port, RESEND_CTS_STATE, 1);\r\nreturn result;\r\n}\r\nstatic void opticon_close(struct usb_serial_port *port)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\ndbg("%s - port %d", __func__, port->number);\r\nusb_kill_urb(priv->bulk_read_urb);\r\n}\r\nstatic void opticon_write_control_callback(struct urb *urb)\r\n{\r\nstruct opticon_private *priv = urb->context;\r\nint status = urb->status;\r\nunsigned long flags;\r\nkfree(urb->transfer_buffer);\r\nkfree(urb->setup_packet);\r\nif (status)\r\ndbg("%s - nonzero write bulk status received: %d",\r\n__func__, status);\r\nspin_lock_irqsave(&priv->lock, flags);\r\n--priv->outstanding_urbs;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nusb_serial_port_softint(priv->port);\r\n}\r\nstatic int opticon_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\nstruct usb_serial *serial = port->serial;\r\nstruct urb *urb;\r\nunsigned char *buffer;\r\nunsigned long flags;\r\nint status;\r\nstruct usb_ctrlrequest *dr;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->outstanding_urbs > URB_UPPER_LIMIT) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndbg("%s - write limit hit", __func__);\r\nreturn 0;\r\n}\r\npriv->outstanding_urbs++;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbuffer = kmalloc(count, GFP_ATOMIC);\r\nif (!buffer) {\r\ndev_err(&port->dev, "out of memory\n");\r\ncount = -ENOMEM;\r\ngoto error_no_buffer;\r\n}\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\ndev_err(&port->dev, "no more free urbs\n");\r\ncount = -ENOMEM;\r\ngoto error_no_urb;\r\n}\r\nmemcpy(buffer, buf, count);\r\nusb_serial_debug_data(debug, &port->dev, __func__, count, buffer);\r\ndr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);\r\nif (!dr) {\r\ndev_err(&port->dev, "out of memory\n");\r\ncount = -ENOMEM;\r\ngoto error;\r\n}\r\ndr->bRequestType = USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT;\r\ndr->bRequest = 0x01;\r\ndr->wValue = 0;\r\ndr->wIndex = 0;\r\ndr->wLength = cpu_to_le16(count);\r\nusb_fill_control_urb(urb, serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\n(unsigned char *)dr, buffer, count,\r\nopticon_write_control_callback, priv);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\ndev_err(&port->dev,\r\n"%s - usb_submit_urb(write endpoint) failed status = %d\n",\r\n__func__, status);\r\ncount = status;\r\ngoto error;\r\n}\r\nusb_free_urb(urb);\r\nreturn count;\r\nerror:\r\nusb_free_urb(urb);\r\nerror_no_urb:\r\nkfree(buffer);\r\nerror_no_buffer:\r\nspin_lock_irqsave(&priv->lock, flags);\r\n--priv->outstanding_urbs;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn count;\r\n}\r\nstatic int opticon_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\nunsigned long flags;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->outstanding_urbs > URB_UPPER_LIMIT * 2 / 3) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndbg("%s - write limit hit", __func__);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 2048;\r\n}\r\nstatic void opticon_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\nunsigned long flags;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->throttled = true;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void opticon_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\nunsigned long flags;\r\nint result, was_throttled;\r\ndbg("%s - port %d", __func__, port->number);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->throttled = false;\r\nwas_throttled = priv->actually_throttled;\r\npriv->actually_throttled = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\npriv->bulk_read_urb->dev = port->serial->dev;\r\nif (was_throttled) {\r\nresult = usb_submit_urb(priv->bulk_read_urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed submitting read urb, error %d\n",\r\n__func__, result);\r\n}\r\n}\r\nstatic int opticon_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\nunsigned long flags;\r\nint result = 0;\r\ndbg("%s - port %d", __func__, port->number);\r\nif (!usb_get_intfdata(port->serial->interface))\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->rts)\r\nresult |= TIOCM_RTS;\r\nif (priv->cts)\r\nresult |= TIOCM_CTS;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndbg("%s - %x", __func__, result);\r\nreturn result;\r\n}\r\nstatic int opticon_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\nunsigned long flags;\r\nbool rts;\r\nbool changed = false;\r\nif (!usb_get_intfdata(port->serial->interface))\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrts = priv->rts;\r\nif (set & TIOCM_RTS)\r\npriv->rts = true;\r\nif (clear & TIOCM_RTS)\r\npriv->rts = false;\r\nchanged = rts ^ priv->rts;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (!changed)\r\nreturn 0;\r\nreturn send_control_msg(port, CONTROL_RTS, !rts);\r\n}\r\nstatic int get_serial_info(struct opticon_private *priv,\r\nstruct serial_struct __user *serial)\r\n{\r\nstruct serial_struct tmp;\r\nif (!serial)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0x00, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.line = priv->serial->minor;\r\ntmp.port = 0;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = 1024;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = 30*HZ;\r\nif (copy_to_user(serial, &tmp, sizeof(*serial)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int opticon_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_data(port->serial);\r\ndbg("%s - port %d, cmd = 0x%x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(priv,\r\n(struct serial_struct __user *)arg);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int opticon_startup(struct usb_serial *serial)\r\n{\r\nstruct opticon_private *priv;\r\nstruct usb_host_interface *intf;\r\nint i;\r\nint retval = -ENOMEM;\r\nbool bulk_in_found = false;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&serial->dev->dev, "%s - Out of memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&priv->lock);\r\npriv->serial = serial;\r\npriv->port = serial->port[0];\r\npriv->udev = serial->dev;\r\npriv->outstanding_urbs = 0;\r\nintf = serial->interface->altsetting;\r\nfor (i = 0; i < intf->desc.bNumEndpoints; ++i) {\r\nstruct usb_endpoint_descriptor *endpoint;\r\nendpoint = &intf->endpoint[i].desc;\r\nif (!usb_endpoint_is_bulk_in(endpoint))\r\ncontinue;\r\npriv->bulk_read_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!priv->bulk_read_urb) {\r\ndev_err(&priv->udev->dev, "out of memory\n");\r\ngoto error;\r\n}\r\npriv->buffer_size = le16_to_cpu(endpoint->wMaxPacketSize) * 2;\r\npriv->bulk_in_buffer = kmalloc(priv->buffer_size, GFP_KERNEL);\r\nif (!priv->bulk_in_buffer) {\r\ndev_err(&priv->udev->dev, "out of memory\n");\r\ngoto error;\r\n}\r\npriv->bulk_address = endpoint->bEndpointAddress;\r\nbulk_in_found = true;\r\nbreak;\r\n}\r\nif (!bulk_in_found) {\r\ndev_err(&priv->udev->dev,\r\n"Error - the proper endpoints were not found!\n");\r\ngoto error;\r\n}\r\nusb_set_serial_data(serial, priv);\r\nreturn 0;\r\nerror:\r\nusb_free_urb(priv->bulk_read_urb);\r\nkfree(priv->bulk_in_buffer);\r\nkfree(priv);\r\nreturn retval;\r\n}\r\nstatic void opticon_disconnect(struct usb_serial *serial)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_data(serial);\r\ndbg("%s", __func__);\r\nusb_kill_urb(priv->bulk_read_urb);\r\nusb_free_urb(priv->bulk_read_urb);\r\n}\r\nstatic void opticon_release(struct usb_serial *serial)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_data(serial);\r\ndbg("%s", __func__);\r\nkfree(priv->bulk_in_buffer);\r\nkfree(priv);\r\n}\r\nstatic int opticon_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usb_serial *serial = usb_get_intfdata(intf);\r\nstruct opticon_private *priv = usb_get_serial_data(serial);\r\nusb_kill_urb(priv->bulk_read_urb);\r\nreturn 0;\r\n}\r\nstatic int opticon_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_serial *serial = usb_get_intfdata(intf);\r\nstruct opticon_private *priv = usb_get_serial_data(serial);\r\nstruct usb_serial_port *port = serial->port[0];\r\nint result;\r\nmutex_lock(&port->port.mutex);\r\nif (test_bit(ASYNCB_INITIALIZED, &port->port.flags))\r\nresult = usb_submit_urb(priv->bulk_read_urb, GFP_NOIO);\r\nelse\r\nresult = 0;\r\nmutex_unlock(&port->port.mutex);\r\nreturn result;\r\n}\r\nstatic int __init opticon_init(void)\r\n{\r\nint retval;\r\nretval = usb_serial_register(&opticon_device);\r\nif (retval)\r\nreturn retval;\r\nretval = usb_register(&opticon_driver);\r\nif (retval)\r\nusb_serial_deregister(&opticon_device);\r\nreturn retval;\r\n}\r\nstatic void __exit opticon_exit(void)\r\n{\r\nusb_deregister(&opticon_driver);\r\nusb_serial_deregister(&opticon_device);\r\n}
