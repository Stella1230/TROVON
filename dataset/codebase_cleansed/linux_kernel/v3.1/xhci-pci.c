static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)\r\n{\r\nif (!pci_set_mwi(pdev))\r\nxhci_dbg(xhci, "MWI active\n");\r\nxhci_dbg(xhci, "Finished xhci_pci_reinit\n");\r\nreturn 0;\r\n}\r\nstatic int xhci_pci_setup(struct usb_hcd *hcd)\r\n{\r\nstruct xhci_hcd *xhci;\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nint retval;\r\nu32 temp;\r\nhcd->self.sg_tablesize = TRBS_PER_SEGMENT - 2;\r\nif (usb_hcd_is_primary_hcd(hcd)) {\r\nxhci = kzalloc(sizeof(struct xhci_hcd), GFP_KERNEL);\r\nif (!xhci)\r\nreturn -ENOMEM;\r\n*((struct xhci_hcd **) hcd->hcd_priv) = xhci;\r\nxhci->main_hcd = hcd;\r\nhcd->speed = HCD_USB2;\r\nhcd->self.root_hub->speed = USB_SPEED_HIGH;\r\nhcd->has_tt = 1;\r\n} else {\r\nxhci = hcd_to_xhci(hcd);\r\ntemp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);\r\nif (HCC_64BIT_ADDR(temp)) {\r\nxhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");\r\ndma_set_mask(hcd->self.controller, DMA_BIT_MASK(64));\r\n} else {\r\ndma_set_mask(hcd->self.controller, DMA_BIT_MASK(32));\r\n}\r\nreturn 0;\r\n}\r\nxhci->cap_regs = hcd->regs;\r\nxhci->op_regs = hcd->regs +\r\nHC_LENGTH(xhci_readl(xhci, &xhci->cap_regs->hc_capbase));\r\nxhci->run_regs = hcd->regs +\r\n(xhci_readl(xhci, &xhci->cap_regs->run_regs_off) & RTSOFF_MASK);\r\nxhci->hcs_params1 = xhci_readl(xhci, &xhci->cap_regs->hcs_params1);\r\nxhci->hcs_params2 = xhci_readl(xhci, &xhci->cap_regs->hcs_params2);\r\nxhci->hcs_params3 = xhci_readl(xhci, &xhci->cap_regs->hcs_params3);\r\nxhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hc_capbase);\r\nxhci->hci_version = HC_VERSION(xhci->hcc_params);\r\nxhci->hcc_params = xhci_readl(xhci, &xhci->cap_regs->hcc_params);\r\nxhci_print_registers(xhci);\r\nif (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&\r\npdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK) {\r\nif (pdev->revision == 0x0) {\r\nxhci->quirks |= XHCI_RESET_EP_QUIRK;\r\nxhci_dbg(xhci, "QUIRK: Fresco Logic xHC needs configure"\r\n" endpoint cmd after reset endpoint\n");\r\n}\r\nxhci->quirks |= XHCI_BROKEN_MSI;\r\nxhci_dbg(xhci, "QUIRK: Fresco Logic revision %u "\r\n"has broken MSI implementation\n",\r\npdev->revision);\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_NEC)\r\nxhci->quirks |= XHCI_NEC_HOST;\r\nif (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())\r\nxhci->quirks |= XHCI_AMD_PLL_FIX;\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\r\npdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {\r\nxhci->quirks |= XHCI_SPURIOUS_SUCCESS;\r\nxhci->quirks |= XHCI_EP_LIMIT_QUIRK;\r\nxhci->limit_active_eps = 64;\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_ETRON &&\r\npdev->device == PCI_DEVICE_ID_ASROCK_P67) {\r\nxhci->quirks |= XHCI_RESET_ON_RESUME;\r\nxhci_dbg(xhci, "QUIRK: Resetting on resume\n");\r\n}\r\nretval = xhci_halt(xhci);\r\nif (retval)\r\ngoto error;\r\nxhci_dbg(xhci, "Resetting HCD\n");\r\nretval = xhci_reset(xhci);\r\nif (retval)\r\ngoto error;\r\nxhci_dbg(xhci, "Reset complete\n");\r\ntemp = xhci_readl(xhci, &xhci->cap_regs->hcc_params);\r\nif (HCC_64BIT_ADDR(temp)) {\r\nxhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");\r\ndma_set_mask(hcd->self.controller, DMA_BIT_MASK(64));\r\n} else {\r\ndma_set_mask(hcd->self.controller, DMA_BIT_MASK(32));\r\n}\r\nxhci_dbg(xhci, "Calling HCD init\n");\r\nretval = xhci_init(hcd);\r\nif (retval)\r\ngoto error;\r\nxhci_dbg(xhci, "Called HCD init\n");\r\npci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);\r\nxhci_dbg(xhci, "Got SBRN %u\n", (unsigned int) xhci->sbrn);\r\nretval = xhci_pci_reinit(xhci, pdev);\r\nif (!retval)\r\nreturn retval;\r\nerror:\r\nkfree(xhci);\r\nreturn retval;\r\n}\r\nstatic int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nint retval;\r\nstruct xhci_hcd *xhci;\r\nstruct hc_driver *driver;\r\nstruct usb_hcd *hcd;\r\ndriver = (struct hc_driver *)id->driver_data;\r\nretval = usb_hcd_pci_probe(dev, id);\r\nif (retval)\r\nreturn retval;\r\nhcd = dev_get_drvdata(&dev->dev);\r\nxhci = hcd_to_xhci(hcd);\r\nxhci->shared_hcd = usb_create_shared_hcd(driver, &dev->dev,\r\npci_name(dev), hcd);\r\nif (!xhci->shared_hcd) {\r\nretval = -ENOMEM;\r\ngoto dealloc_usb2_hcd;\r\n}\r\n*((struct xhci_hcd **) xhci->shared_hcd->hcd_priv) = xhci;\r\nretval = usb_add_hcd(xhci->shared_hcd, dev->irq,\r\nIRQF_DISABLED | IRQF_SHARED);\r\nif (retval)\r\ngoto put_usb3_hcd;\r\nreturn 0;\r\nput_usb3_hcd:\r\nusb_put_hcd(xhci->shared_hcd);\r\ndealloc_usb2_hcd:\r\nusb_hcd_pci_remove(dev);\r\nreturn retval;\r\n}\r\nstatic void xhci_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct xhci_hcd *xhci;\r\nxhci = hcd_to_xhci(pci_get_drvdata(dev));\r\nif (xhci->shared_hcd) {\r\nusb_remove_hcd(xhci->shared_hcd);\r\nusb_put_hcd(xhci->shared_hcd);\r\n}\r\nusb_hcd_pci_remove(dev);\r\nkfree(xhci);\r\n}\r\nstatic int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nint retval = 0;\r\nif (hcd->state != HC_STATE_SUSPENDED ||\r\nxhci->shared_hcd->state != HC_STATE_SUSPENDED)\r\nreturn -EINVAL;\r\nretval = xhci_suspend(xhci);\r\nreturn retval;\r\n}\r\nstatic int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nint retval = 0;\r\nif (usb_is_intel_switchable_xhci(pdev))\r\nusb_enable_xhci_ports(pdev);\r\nretval = xhci_resume(xhci, hibernated);\r\nreturn retval;\r\n}\r\nint xhci_register_pci(void)\r\n{\r\nreturn pci_register_driver(&xhci_pci_driver);\r\n}\r\nvoid xhci_unregister_pci(void)\r\n{\r\npci_unregister_driver(&xhci_pci_driver);\r\n}
