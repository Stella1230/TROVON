static int handle_loop(struct cfctrl *ctrl,\r\nint cmd, struct cfpkt *pkt){\r\nreturn -1;\r\n}\r\nstruct cflayer *cfctrl_create(void)\r\n{\r\nstruct dev_info dev_info;\r\nstruct cfctrl *this =\r\nkmalloc(sizeof(struct cfctrl), GFP_ATOMIC);\r\nif (!this) {\r\npr_warn("Out of memory\n");\r\nreturn NULL;\r\n}\r\ncaif_assert(offsetof(struct cfctrl, serv.layer) == 0);\r\nmemset(&dev_info, 0, sizeof(dev_info));\r\ndev_info.id = 0xff;\r\nmemset(this, 0, sizeof(*this));\r\ncfsrvl_init(&this->serv, 0, &dev_info, false);\r\natomic_set(&this->req_seq_no, 1);\r\natomic_set(&this->rsp_seq_no, 1);\r\nthis->serv.layer.receive = cfctrl_recv;\r\nsprintf(this->serv.layer.name, "ctrl");\r\nthis->serv.layer.ctrlcmd = cfctrl_ctrlcmd;\r\n#ifndef CAIF_NO_LOOP\r\nspin_lock_init(&this->loop_linkid_lock);\r\nthis->loop_linkid = 1;\r\n#endif\r\nspin_lock_init(&this->info_list_lock);\r\nINIT_LIST_HEAD(&this->list);\r\nreturn &this->serv.layer;\r\n}\r\nvoid cfctrl_remove(struct cflayer *layer)\r\n{\r\nstruct cfctrl_request_info *p, *tmp;\r\nstruct cfctrl *ctrl = container_obj(layer);\r\nspin_lock_bh(&ctrl->info_list_lock);\r\nlist_for_each_entry_safe(p, tmp, &ctrl->list, list) {\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\nspin_unlock_bh(&ctrl->info_list_lock);\r\nkfree(layer);\r\n}\r\nstatic bool param_eq(const struct cfctrl_link_param *p1,\r\nconst struct cfctrl_link_param *p2)\r\n{\r\nbool eq =\r\np1->linktype == p2->linktype &&\r\np1->priority == p2->priority &&\r\np1->phyid == p2->phyid &&\r\np1->endpoint == p2->endpoint && p1->chtype == p2->chtype;\r\nif (!eq)\r\nreturn false;\r\nswitch (p1->linktype) {\r\ncase CFCTRL_SRV_VEI:\r\nreturn true;\r\ncase CFCTRL_SRV_DATAGRAM:\r\nreturn p1->u.datagram.connid == p2->u.datagram.connid;\r\ncase CFCTRL_SRV_RFM:\r\nreturn\r\np1->u.rfm.connid == p2->u.rfm.connid &&\r\nstrcmp(p1->u.rfm.volume, p2->u.rfm.volume) == 0;\r\ncase CFCTRL_SRV_UTIL:\r\nreturn\r\np1->u.utility.fifosize_kb == p2->u.utility.fifosize_kb\r\n&& p1->u.utility.fifosize_bufs ==\r\np2->u.utility.fifosize_bufs\r\n&& strcmp(p1->u.utility.name, p2->u.utility.name) == 0\r\n&& p1->u.utility.paramlen == p2->u.utility.paramlen\r\n&& memcmp(p1->u.utility.params, p2->u.utility.params,\r\np1->u.utility.paramlen) == 0;\r\ncase CFCTRL_SRV_VIDEO:\r\nreturn p1->u.video.connid == p2->u.video.connid;\r\ncase CFCTRL_SRV_DBG:\r\nreturn true;\r\ncase CFCTRL_SRV_DECM:\r\nreturn false;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nstatic bool cfctrl_req_eq(const struct cfctrl_request_info *r1,\r\nconst struct cfctrl_request_info *r2)\r\n{\r\nif (r1->cmd != r2->cmd)\r\nreturn false;\r\nif (r1->cmd == CFCTRL_CMD_LINK_SETUP)\r\nreturn param_eq(&r1->param, &r2->param);\r\nelse\r\nreturn r1->channel_id == r2->channel_id;\r\n}\r\nstatic void cfctrl_insert_req(struct cfctrl *ctrl,\r\nstruct cfctrl_request_info *req)\r\n{\r\nspin_lock_bh(&ctrl->info_list_lock);\r\natomic_inc(&ctrl->req_seq_no);\r\nreq->sequence_no = atomic_read(&ctrl->req_seq_no);\r\nlist_add_tail(&req->list, &ctrl->list);\r\nspin_unlock_bh(&ctrl->info_list_lock);\r\n}\r\nstatic struct cfctrl_request_info *cfctrl_remove_req(struct cfctrl *ctrl,\r\nstruct cfctrl_request_info *req)\r\n{\r\nstruct cfctrl_request_info *p, *tmp, *first;\r\nfirst = list_first_entry(&ctrl->list, struct cfctrl_request_info, list);\r\nlist_for_each_entry_safe(p, tmp, &ctrl->list, list) {\r\nif (cfctrl_req_eq(req, p)) {\r\nif (p != first)\r\npr_warn("Requests are not received in order\n");\r\natomic_set(&ctrl->rsp_seq_no,\r\np->sequence_no);\r\nlist_del(&p->list);\r\ngoto out;\r\n}\r\n}\r\np = NULL;\r\nout:\r\nreturn p;\r\n}\r\nstruct cfctrl_rsp *cfctrl_get_respfuncs(struct cflayer *layer)\r\n{\r\nstruct cfctrl *this = container_obj(layer);\r\nreturn &this->res;\r\n}\r\nstatic void init_info(struct caif_payload_info *info, struct cfctrl *cfctrl)\r\n{\r\ninfo->hdr_len = 0;\r\ninfo->channel_id = cfctrl->serv.layer.id;\r\ninfo->dev_info = &cfctrl->serv.dev_info;\r\n}\r\nvoid cfctrl_enum_req(struct cflayer *layer, u8 physlinkid)\r\n{\r\nstruct cfctrl *cfctrl = container_obj(layer);\r\nstruct cfpkt *pkt = cfpkt_create(CFPKT_CTRL_PKT_LEN);\r\nstruct cflayer *dn = cfctrl->serv.layer.dn;\r\nif (!pkt) {\r\npr_warn("Out of memory\n");\r\nreturn;\r\n}\r\nif (!dn) {\r\npr_debug("not able to send enum request\n");\r\nreturn;\r\n}\r\ncaif_assert(offsetof(struct cfctrl, serv.layer) == 0);\r\ninit_info(cfpkt_info(pkt), cfctrl);\r\ncfpkt_info(pkt)->dev_info->id = physlinkid;\r\ncfctrl->serv.dev_info.id = physlinkid;\r\ncfpkt_addbdy(pkt, CFCTRL_CMD_ENUM);\r\ncfpkt_addbdy(pkt, physlinkid);\r\ndn->transmit(dn, pkt);\r\n}\r\nint cfctrl_linkup_request(struct cflayer *layer,\r\nstruct cfctrl_link_param *param,\r\nstruct cflayer *user_layer)\r\n{\r\nstruct cfctrl *cfctrl = container_obj(layer);\r\nu32 tmp32;\r\nu16 tmp16;\r\nu8 tmp8;\r\nstruct cfctrl_request_info *req;\r\nint ret;\r\nchar utility_name[16];\r\nstruct cfpkt *pkt;\r\nstruct cflayer *dn = cfctrl->serv.layer.dn;\r\nif (!dn) {\r\npr_debug("not able to send linkup request\n");\r\nreturn -ENODEV;\r\n}\r\nif (cfctrl_cancel_req(layer, user_layer) > 0) {\r\npr_err("Duplicate connect request for same client\n");\r\nWARN_ON(1);\r\nreturn -EALREADY;\r\n}\r\npkt = cfpkt_create(CFPKT_CTRL_PKT_LEN);\r\nif (!pkt) {\r\npr_warn("Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\ncfpkt_addbdy(pkt, CFCTRL_CMD_LINK_SETUP);\r\ncfpkt_addbdy(pkt, (param->chtype << 4) | param->linktype);\r\ncfpkt_addbdy(pkt, (param->priority << 3) | param->phyid);\r\ncfpkt_addbdy(pkt, param->endpoint & 0x03);\r\nswitch (param->linktype) {\r\ncase CFCTRL_SRV_VEI:\r\nbreak;\r\ncase CFCTRL_SRV_VIDEO:\r\ncfpkt_addbdy(pkt, (u8) param->u.video.connid);\r\nbreak;\r\ncase CFCTRL_SRV_DBG:\r\nbreak;\r\ncase CFCTRL_SRV_DATAGRAM:\r\ntmp32 = cpu_to_le32(param->u.datagram.connid);\r\ncfpkt_add_body(pkt, &tmp32, 4);\r\nbreak;\r\ncase CFCTRL_SRV_RFM:\r\ntmp32 = cpu_to_le32(param->u.rfm.connid);\r\ncfpkt_add_body(pkt, &tmp32, 4);\r\ncfpkt_add_body(pkt, param->u.rfm.volume,\r\nstrlen(param->u.rfm.volume) + 1);\r\nbreak;\r\ncase CFCTRL_SRV_UTIL:\r\ntmp16 = cpu_to_le16(param->u.utility.fifosize_kb);\r\ncfpkt_add_body(pkt, &tmp16, 2);\r\ntmp16 = cpu_to_le16(param->u.utility.fifosize_bufs);\r\ncfpkt_add_body(pkt, &tmp16, 2);\r\nmemset(utility_name, 0, sizeof(utility_name));\r\nstrncpy(utility_name, param->u.utility.name,\r\nUTILITY_NAME_LENGTH - 1);\r\ncfpkt_add_body(pkt, utility_name, UTILITY_NAME_LENGTH);\r\ntmp8 = param->u.utility.paramlen;\r\ncfpkt_add_body(pkt, &tmp8, 1);\r\ncfpkt_add_body(pkt, param->u.utility.params,\r\nparam->u.utility.paramlen);\r\nbreak;\r\ndefault:\r\npr_warn("Request setup of bad link type = %d\n",\r\nparam->linktype);\r\nreturn -EINVAL;\r\n}\r\nreq = kzalloc(sizeof(*req), GFP_KERNEL);\r\nif (!req) {\r\npr_warn("Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nreq->client_layer = user_layer;\r\nreq->cmd = CFCTRL_CMD_LINK_SETUP;\r\nreq->param = *param;\r\ncfctrl_insert_req(cfctrl, req);\r\ninit_info(cfpkt_info(pkt), cfctrl);\r\ncfpkt_info(pkt)->dev_info->id = param->phyid;\r\nret =\r\ndn->transmit(dn, pkt);\r\nif (ret < 0) {\r\nint count;\r\ncount = cfctrl_cancel_req(&cfctrl->serv.layer,\r\nuser_layer);\r\nif (count != 1)\r\npr_err("Could not remove request (%d)", count);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint cfctrl_linkdown_req(struct cflayer *layer, u8 channelid,\r\nstruct cflayer *client)\r\n{\r\nint ret;\r\nstruct cfctrl *cfctrl = container_obj(layer);\r\nstruct cfpkt *pkt = cfpkt_create(CFPKT_CTRL_PKT_LEN);\r\nstruct cflayer *dn = cfctrl->serv.layer.dn;\r\nif (!pkt) {\r\npr_warn("Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!dn) {\r\npr_debug("not able to send link-down request\n");\r\nreturn -ENODEV;\r\n}\r\ncfpkt_addbdy(pkt, CFCTRL_CMD_LINK_DESTROY);\r\ncfpkt_addbdy(pkt, channelid);\r\ninit_info(cfpkt_info(pkt), cfctrl);\r\nret =\r\ndn->transmit(dn, pkt);\r\n#ifndef CAIF_NO_LOOP\r\ncfctrl->loop_linkused[channelid] = 0;\r\n#endif\r\nreturn ret;\r\n}\r\nint cfctrl_cancel_req(struct cflayer *layr, struct cflayer *adap_layer)\r\n{\r\nstruct cfctrl_request_info *p, *tmp;\r\nstruct cfctrl *ctrl = container_obj(layr);\r\nint found = 0;\r\nspin_lock_bh(&ctrl->info_list_lock);\r\nlist_for_each_entry_safe(p, tmp, &ctrl->list, list) {\r\nif (p->client_layer == adap_layer) {\r\nlist_del(&p->list);\r\nkfree(p);\r\nfound++;\r\n}\r\n}\r\nspin_unlock_bh(&ctrl->info_list_lock);\r\nreturn found;\r\n}\r\nstatic int cfctrl_recv(struct cflayer *layer, struct cfpkt *pkt)\r\n{\r\nu8 cmdrsp;\r\nu8 cmd;\r\nint ret = -1;\r\nu16 tmp16;\r\nu8 len;\r\nu8 param[255];\r\nu8 linkid;\r\nstruct cfctrl *cfctrl = container_obj(layer);\r\nstruct cfctrl_request_info rsp, *req;\r\ncfpkt_extr_head(pkt, &cmdrsp, 1);\r\ncmd = cmdrsp & CFCTRL_CMD_MASK;\r\nif (cmd != CFCTRL_CMD_LINK_ERR\r\n&& CFCTRL_RSP_BIT != (CFCTRL_RSP_BIT & cmdrsp)\r\n&& CFCTRL_ERR_BIT != (CFCTRL_ERR_BIT & cmdrsp)) {\r\nif (handle_loop(cfctrl, cmd, pkt) != 0)\r\ncmdrsp |= CFCTRL_ERR_BIT;\r\n}\r\nswitch (cmd) {\r\ncase CFCTRL_CMD_LINK_SETUP:\r\n{\r\nenum cfctrl_srv serv;\r\nenum cfctrl_srv servtype;\r\nu8 endpoint;\r\nu8 physlinkid;\r\nu8 prio;\r\nu8 tmp;\r\nu32 tmp32;\r\nu8 *cp;\r\nint i;\r\nstruct cfctrl_link_param linkparam;\r\nmemset(&linkparam, 0, sizeof(linkparam));\r\ncfpkt_extr_head(pkt, &tmp, 1);\r\nserv = tmp & CFCTRL_SRV_MASK;\r\nlinkparam.linktype = serv;\r\nservtype = tmp >> 4;\r\nlinkparam.chtype = servtype;\r\ncfpkt_extr_head(pkt, &tmp, 1);\r\nphyslinkid = tmp & 0x07;\r\nprio = tmp >> 3;\r\nlinkparam.priority = prio;\r\nlinkparam.phyid = physlinkid;\r\ncfpkt_extr_head(pkt, &endpoint, 1);\r\nlinkparam.endpoint = endpoint & 0x03;\r\nswitch (serv) {\r\ncase CFCTRL_SRV_VEI:\r\ncase CFCTRL_SRV_DBG:\r\nif (CFCTRL_ERR_BIT & cmdrsp)\r\nbreak;\r\ncfpkt_extr_head(pkt, &linkid, 1);\r\nbreak;\r\ncase CFCTRL_SRV_VIDEO:\r\ncfpkt_extr_head(pkt, &tmp, 1);\r\nlinkparam.u.video.connid = tmp;\r\nif (CFCTRL_ERR_BIT & cmdrsp)\r\nbreak;\r\ncfpkt_extr_head(pkt, &linkid, 1);\r\nbreak;\r\ncase CFCTRL_SRV_DATAGRAM:\r\ncfpkt_extr_head(pkt, &tmp32, 4);\r\nlinkparam.u.datagram.connid =\r\nle32_to_cpu(tmp32);\r\nif (CFCTRL_ERR_BIT & cmdrsp)\r\nbreak;\r\ncfpkt_extr_head(pkt, &linkid, 1);\r\nbreak;\r\ncase CFCTRL_SRV_RFM:\r\ncfpkt_extr_head(pkt, &tmp32, 4);\r\nlinkparam.u.rfm.connid =\r\nle32_to_cpu(tmp32);\r\ncp = (u8 *) linkparam.u.rfm.volume;\r\nfor (cfpkt_extr_head(pkt, &tmp, 1);\r\ncfpkt_more(pkt) && tmp != '\0';\r\ncfpkt_extr_head(pkt, &tmp, 1))\r\n*cp++ = tmp;\r\n*cp = '\0';\r\nif (CFCTRL_ERR_BIT & cmdrsp)\r\nbreak;\r\ncfpkt_extr_head(pkt, &linkid, 1);\r\nbreak;\r\ncase CFCTRL_SRV_UTIL:\r\ncfpkt_extr_head(pkt, &tmp16, 2);\r\nlinkparam.u.utility.fifosize_kb =\r\nle16_to_cpu(tmp16);\r\ncfpkt_extr_head(pkt, &tmp16, 2);\r\nlinkparam.u.utility.fifosize_bufs =\r\nle16_to_cpu(tmp16);\r\ncp = (u8 *) linkparam.u.utility.name;\r\ncaif_assert(sizeof(linkparam.u.utility.name)\r\n>= UTILITY_NAME_LENGTH);\r\nfor (i = 0;\r\ni < UTILITY_NAME_LENGTH\r\n&& cfpkt_more(pkt); i++) {\r\ncfpkt_extr_head(pkt, &tmp, 1);\r\n*cp++ = tmp;\r\n}\r\ncfpkt_extr_head(pkt, &len, 1);\r\nlinkparam.u.utility.paramlen = len;\r\ncp = linkparam.u.utility.params;\r\nwhile (cfpkt_more(pkt) && len--) {\r\ncfpkt_extr_head(pkt, &tmp, 1);\r\n*cp++ = tmp;\r\n}\r\nif (CFCTRL_ERR_BIT & cmdrsp)\r\nbreak;\r\ncfpkt_extr_head(pkt, &linkid, 1);\r\ncfpkt_extr_head(pkt, &len, 1);\r\ncfpkt_extr_head(pkt, &param, len);\r\nbreak;\r\ndefault:\r\npr_warn("Request setup, invalid type (%d)\n",\r\nserv);\r\ngoto error;\r\n}\r\nrsp.cmd = cmd;\r\nrsp.param = linkparam;\r\nspin_lock_bh(&cfctrl->info_list_lock);\r\nreq = cfctrl_remove_req(cfctrl, &rsp);\r\nif (CFCTRL_ERR_BIT == (CFCTRL_ERR_BIT & cmdrsp) ||\r\ncfpkt_erroneous(pkt)) {\r\npr_err("Invalid O/E bit or parse error "\r\n"on CAIF control channel\n");\r\ncfctrl->res.reject_rsp(cfctrl->serv.layer.up,\r\n0,\r\nreq ? req->client_layer\r\n: NULL);\r\n} else {\r\ncfctrl->res.linksetup_rsp(cfctrl->serv.\r\nlayer.up, linkid,\r\nserv, physlinkid,\r\nreq ? req->\r\nclient_layer : NULL);\r\n}\r\nif (req != NULL)\r\nkfree(req);\r\nspin_unlock_bh(&cfctrl->info_list_lock);\r\n}\r\nbreak;\r\ncase CFCTRL_CMD_LINK_DESTROY:\r\ncfpkt_extr_head(pkt, &linkid, 1);\r\ncfctrl->res.linkdestroy_rsp(cfctrl->serv.layer.up, linkid);\r\nbreak;\r\ncase CFCTRL_CMD_LINK_ERR:\r\npr_err("Frame Error Indication received\n");\r\ncfctrl->res.linkerror_ind();\r\nbreak;\r\ncase CFCTRL_CMD_ENUM:\r\ncfctrl->res.enum_rsp();\r\nbreak;\r\ncase CFCTRL_CMD_SLEEP:\r\ncfctrl->res.sleep_rsp();\r\nbreak;\r\ncase CFCTRL_CMD_WAKE:\r\ncfctrl->res.wake_rsp();\r\nbreak;\r\ncase CFCTRL_CMD_LINK_RECONF:\r\ncfctrl->res.restart_rsp();\r\nbreak;\r\ncase CFCTRL_CMD_RADIO_SET:\r\ncfctrl->res.radioset_rsp();\r\nbreak;\r\ndefault:\r\npr_err("Unrecognized Control Frame\n");\r\ngoto error;\r\nbreak;\r\n}\r\nret = 0;\r\nerror:\r\ncfpkt_destroy(pkt);\r\nreturn ret;\r\n}\r\nstatic void cfctrl_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\r\nint phyid)\r\n{\r\nstruct cfctrl *this = container_obj(layr);\r\nswitch (ctrl) {\r\ncase _CAIF_CTRLCMD_PHYIF_FLOW_OFF_IND:\r\ncase CAIF_CTRLCMD_FLOW_OFF_IND:\r\nspin_lock_bh(&this->info_list_lock);\r\nif (!list_empty(&this->list))\r\npr_debug("Received flow off in control layer\n");\r\nspin_unlock_bh(&this->info_list_lock);\r\nbreak;\r\ncase _CAIF_CTRLCMD_PHYIF_DOWN_IND: {\r\nstruct cfctrl_request_info *p, *tmp;\r\nspin_lock_bh(&this->info_list_lock);\r\nlist_for_each_entry_safe(p, tmp, &this->list, list) {\r\nif (p->param.phyid == phyid) {\r\nlist_del(&p->list);\r\np->client_layer->ctrlcmd(p->client_layer,\r\nCAIF_CTRLCMD_INIT_FAIL_RSP,\r\nphyid);\r\nkfree(p);\r\n}\r\n}\r\nspin_unlock_bh(&this->info_list_lock);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int handle_loop(struct cfctrl *ctrl, int cmd, struct cfpkt *pkt)\r\n{\r\nstatic int last_linkid;\r\nstatic int dec;\r\nu8 linkid, linktype, tmp;\r\nswitch (cmd) {\r\ncase CFCTRL_CMD_LINK_SETUP:\r\nspin_lock_bh(&ctrl->loop_linkid_lock);\r\nif (!dec) {\r\nfor (linkid = last_linkid + 1; linkid < 254; linkid++)\r\nif (!ctrl->loop_linkused[linkid])\r\ngoto found;\r\n}\r\ndec = 1;\r\nfor (linkid = last_linkid - 1; linkid > 1; linkid--)\r\nif (!ctrl->loop_linkused[linkid])\r\ngoto found;\r\nspin_unlock_bh(&ctrl->loop_linkid_lock);\r\nreturn -1;\r\nfound:\r\nif (linkid < 10)\r\ndec = 0;\r\nif (!ctrl->loop_linkused[linkid])\r\nctrl->loop_linkused[linkid] = 1;\r\nlast_linkid = linkid;\r\ncfpkt_add_trail(pkt, &linkid, 1);\r\nspin_unlock_bh(&ctrl->loop_linkid_lock);\r\ncfpkt_peek_head(pkt, &linktype, 1);\r\nif (linktype == CFCTRL_SRV_UTIL) {\r\ntmp = 0x01;\r\ncfpkt_add_trail(pkt, &tmp, 1);\r\ncfpkt_add_trail(pkt, &tmp, 1);\r\n}\r\nbreak;\r\ncase CFCTRL_CMD_LINK_DESTROY:\r\nspin_lock_bh(&ctrl->loop_linkid_lock);\r\ncfpkt_peek_head(pkt, &linkid, 1);\r\nctrl->loop_linkused[linkid] = 0;\r\nspin_unlock_bh(&ctrl->loop_linkid_lock);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}
