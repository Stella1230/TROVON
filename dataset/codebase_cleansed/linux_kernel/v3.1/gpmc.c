static void gpmc_write_reg(int idx, u32 val)\r\n{\r\n__raw_writel(val, gpmc_base + idx);\r\n}\r\nstatic u32 gpmc_read_reg(int idx)\r\n{\r\nreturn __raw_readl(gpmc_base + idx);\r\n}\r\nstatic void gpmc_cs_write_byte(int cs, int idx, u8 val)\r\n{\r\nvoid __iomem *reg_addr;\r\nreg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;\r\n__raw_writeb(val, reg_addr);\r\n}\r\nstatic u8 gpmc_cs_read_byte(int cs, int idx)\r\n{\r\nvoid __iomem *reg_addr;\r\nreg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;\r\nreturn __raw_readb(reg_addr);\r\n}\r\nvoid gpmc_cs_write_reg(int cs, int idx, u32 val)\r\n{\r\nvoid __iomem *reg_addr;\r\nreg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;\r\n__raw_writel(val, reg_addr);\r\n}\r\nu32 gpmc_cs_read_reg(int cs, int idx)\r\n{\r\nvoid __iomem *reg_addr;\r\nreg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;\r\nreturn __raw_readl(reg_addr);\r\n}\r\nunsigned long gpmc_get_fclk_period(void)\r\n{\r\nunsigned long rate = clk_get_rate(gpmc_l3_clk);\r\nif (rate == 0) {\r\nprintk(KERN_WARNING "gpmc_l3_clk not enabled\n");\r\nreturn 0;\r\n}\r\nrate /= 1000;\r\nrate = 1000000000 / rate;\r\nreturn rate;\r\n}\r\nunsigned int gpmc_ns_to_ticks(unsigned int time_ns)\r\n{\r\nunsigned long tick_ps;\r\ntick_ps = gpmc_get_fclk_period();\r\nreturn (time_ns * 1000 + tick_ps - 1) / tick_ps;\r\n}\r\nunsigned int gpmc_ps_to_ticks(unsigned int time_ps)\r\n{\r\nunsigned long tick_ps;\r\ntick_ps = gpmc_get_fclk_period();\r\nreturn (time_ps + tick_ps - 1) / tick_ps;\r\n}\r\nunsigned int gpmc_ticks_to_ns(unsigned int ticks)\r\n{\r\nreturn ticks * gpmc_get_fclk_period() / 1000;\r\n}\r\nunsigned int gpmc_round_ns_to_ticks(unsigned int time_ns)\r\n{\r\nunsigned long ticks = gpmc_ns_to_ticks(time_ns);\r\nreturn ticks * gpmc_get_fclk_period() / 1000;\r\n}\r\nint gpmc_cs_calc_divider(int cs, unsigned int sync_clk)\r\n{\r\nint div;\r\nu32 l;\r\nl = sync_clk + (gpmc_get_fclk_period() - 1);\r\ndiv = l / gpmc_get_fclk_period();\r\nif (div > 4)\r\nreturn -1;\r\nif (div <= 0)\r\ndiv = 1;\r\nreturn div;\r\n}\r\nint gpmc_cs_set_timings(int cs, const struct gpmc_timings *t)\r\n{\r\nint div;\r\nu32 l;\r\ndiv = gpmc_cs_calc_divider(cs, t->sync_clk);\r\nif (div < 0)\r\nreturn -1;\r\nGPMC_SET_ONE(GPMC_CS_CONFIG2, 0, 3, cs_on);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG2, 8, 12, cs_rd_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG2, 16, 20, cs_wr_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG3, 0, 3, adv_on);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG3, 8, 12, adv_rd_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG3, 16, 20, adv_wr_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG4, 0, 3, oe_on);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG4, 8, 12, oe_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG4, 16, 19, we_on);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG4, 24, 28, we_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG5, 0, 4, rd_cycle);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG5, 8, 12, wr_cycle);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG5, 16, 20, access);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG5, 24, 27, page_burst_access);\r\nif (cpu_is_omap34xx()) {\r\nGPMC_SET_ONE(GPMC_CS_CONFIG6, 16, 19, wr_data_mux_bus);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG6, 24, 28, wr_access);\r\n}\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);\r\nif (l & (GPMC_CONFIG1_READTYPE_SYNC | GPMC_CONFIG1_WRITETYPE_SYNC)) {\r\n#ifdef DEBUG\r\nprintk(KERN_INFO "GPMC CS%d CLK period is %lu ns (div %d)\n",\r\ncs, (div * gpmc_get_fclk_period()) / 1000, div);\r\n#endif\r\nl &= ~0x03;\r\nl |= (div - 1);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, l);\r\n}\r\nreturn 0;\r\n}\r\nstatic void gpmc_cs_enable_mem(int cs, u32 base, u32 size)\r\n{\r\nu32 l;\r\nu32 mask;\r\nmask = (1 << GPMC_SECTION_SHIFT) - size;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\nl &= ~0x3f;\r\nl = (base >> GPMC_CHUNK_SHIFT) & 0x3f;\r\nl &= ~(0x0f << 8);\r\nl |= ((mask >> GPMC_CHUNK_SHIFT) & 0x0f) << 8;\r\nl |= GPMC_CONFIG7_CSVALID;\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG7, l);\r\n}\r\nstatic void gpmc_cs_disable_mem(int cs)\r\n{\r\nu32 l;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\nl &= ~GPMC_CONFIG7_CSVALID;\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG7, l);\r\n}\r\nstatic void gpmc_cs_get_memconf(int cs, u32 *base, u32 *size)\r\n{\r\nu32 l;\r\nu32 mask;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\n*base = (l & 0x3f) << GPMC_CHUNK_SHIFT;\r\nmask = (l >> 8) & 0x0f;\r\n*size = (1 << GPMC_SECTION_SHIFT) - (mask << GPMC_CHUNK_SHIFT);\r\n}\r\nstatic int gpmc_cs_mem_enabled(int cs)\r\n{\r\nu32 l;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\nreturn l & GPMC_CONFIG7_CSVALID;\r\n}\r\nint gpmc_cs_set_reserved(int cs, int reserved)\r\n{\r\nif (cs > GPMC_CS_NUM)\r\nreturn -ENODEV;\r\ngpmc_cs_map &= ~(1 << cs);\r\ngpmc_cs_map |= (reserved ? 1 : 0) << cs;\r\nreturn 0;\r\n}\r\nint gpmc_cs_reserved(int cs)\r\n{\r\nif (cs > GPMC_CS_NUM)\r\nreturn -ENODEV;\r\nreturn gpmc_cs_map & (1 << cs);\r\n}\r\nstatic unsigned long gpmc_mem_align(unsigned long size)\r\n{\r\nint order;\r\nsize = (size - 1) >> (GPMC_CHUNK_SHIFT - 1);\r\norder = GPMC_CHUNK_SHIFT - 1;\r\ndo {\r\nsize >>= 1;\r\norder++;\r\n} while (size);\r\nsize = 1 << order;\r\nreturn size;\r\n}\r\nstatic int gpmc_cs_insert_mem(int cs, unsigned long base, unsigned long size)\r\n{\r\nstruct resource *res = &gpmc_cs_mem[cs];\r\nint r;\r\nsize = gpmc_mem_align(size);\r\nspin_lock(&gpmc_mem_lock);\r\nres->start = base;\r\nres->end = base + size - 1;\r\nr = request_resource(&gpmc_mem_root, res);\r\nspin_unlock(&gpmc_mem_lock);\r\nreturn r;\r\n}\r\nint gpmc_cs_request(int cs, unsigned long size, unsigned long *base)\r\n{\r\nstruct resource *res = &gpmc_cs_mem[cs];\r\nint r = -1;\r\nif (cs > GPMC_CS_NUM)\r\nreturn -ENODEV;\r\nsize = gpmc_mem_align(size);\r\nif (size > (1 << GPMC_SECTION_SHIFT))\r\nreturn -ENOMEM;\r\nspin_lock(&gpmc_mem_lock);\r\nif (gpmc_cs_reserved(cs)) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nif (gpmc_cs_mem_enabled(cs))\r\nr = adjust_resource(res, res->start & ~(size - 1), size);\r\nif (r < 0)\r\nr = allocate_resource(&gpmc_mem_root, res, size, 0, ~0,\r\nsize, NULL, NULL);\r\nif (r < 0)\r\ngoto out;\r\ngpmc_cs_enable_mem(cs, res->start, resource_size(res));\r\n*base = res->start;\r\ngpmc_cs_set_reserved(cs, 1);\r\nout:\r\nspin_unlock(&gpmc_mem_lock);\r\nreturn r;\r\n}\r\nvoid gpmc_cs_free(int cs)\r\n{\r\nspin_lock(&gpmc_mem_lock);\r\nif (cs >= GPMC_CS_NUM || cs < 0 || !gpmc_cs_reserved(cs)) {\r\nprintk(KERN_ERR "Trying to free non-reserved GPMC CS%d\n", cs);\r\nBUG();\r\nspin_unlock(&gpmc_mem_lock);\r\nreturn;\r\n}\r\ngpmc_cs_disable_mem(cs);\r\nrelease_resource(&gpmc_cs_mem[cs]);\r\ngpmc_cs_set_reserved(cs, 0);\r\nspin_unlock(&gpmc_mem_lock);\r\n}\r\nint gpmc_read_status(int cmd)\r\n{\r\nint status = -EINVAL;\r\nu32 regval = 0;\r\nswitch (cmd) {\r\ncase GPMC_GET_IRQ_STATUS:\r\nstatus = gpmc_read_reg(GPMC_IRQSTATUS);\r\nbreak;\r\ncase GPMC_PREFETCH_FIFO_CNT:\r\nregval = gpmc_read_reg(GPMC_PREFETCH_STATUS);\r\nstatus = GPMC_PREFETCH_STATUS_FIFO_CNT(regval);\r\nbreak;\r\ncase GPMC_PREFETCH_COUNT:\r\nregval = gpmc_read_reg(GPMC_PREFETCH_STATUS);\r\nstatus = GPMC_PREFETCH_STATUS_COUNT(regval);\r\nbreak;\r\ncase GPMC_STATUS_BUFFER:\r\nregval = gpmc_read_reg(GPMC_STATUS);\r\nstatus = regval & GPMC_STATUS_BUFF_EMPTY;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "gpmc_read_status: Not supported\n");\r\n}\r\nreturn status;\r\n}\r\nint gpmc_cs_configure(int cs, int cmd, int wval)\r\n{\r\nint err = 0;\r\nu32 regval = 0;\r\nswitch (cmd) {\r\ncase GPMC_ENABLE_IRQ:\r\ngpmc_write_reg(GPMC_IRQENABLE, wval);\r\nbreak;\r\ncase GPMC_SET_IRQ_STATUS:\r\ngpmc_write_reg(GPMC_IRQSTATUS, wval);\r\nbreak;\r\ncase GPMC_CONFIG_WP:\r\nregval = gpmc_read_reg(GPMC_CONFIG);\r\nif (wval)\r\nregval &= ~GPMC_CONFIG_WRITEPROTECT;\r\nelse\r\nregval |= GPMC_CONFIG_WRITEPROTECT;\r\ngpmc_write_reg(GPMC_CONFIG, regval);\r\nbreak;\r\ncase GPMC_CONFIG_RDY_BSY:\r\nregval = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);\r\nif (wval)\r\nregval |= WR_RD_PIN_MONITORING;\r\nelse\r\nregval &= ~WR_RD_PIN_MONITORING;\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, regval);\r\nbreak;\r\ncase GPMC_CONFIG_DEV_SIZE:\r\nregval = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);\r\nregval |= GPMC_CONFIG1_DEVICESIZE(wval);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, regval);\r\nbreak;\r\ncase GPMC_CONFIG_DEV_TYPE:\r\nregval = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);\r\nregval |= GPMC_CONFIG1_DEVICETYPE(wval);\r\nif (wval == GPMC_DEVICETYPE_NOR)\r\nregval |= GPMC_CONFIG1_MUXADDDATA;\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, regval);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "gpmc_configure_cs: Not supported\n");\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nint gpmc_nand_read(int cs, int cmd)\r\n{\r\nint rval = -EINVAL;\r\nswitch (cmd) {\r\ncase GPMC_NAND_DATA:\r\nrval = gpmc_cs_read_byte(cs, GPMC_CS_NAND_DATA);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "gpmc_read_nand_ctrl: Not supported\n");\r\n}\r\nreturn rval;\r\n}\r\nint gpmc_nand_write(int cs, int cmd, int wval)\r\n{\r\nint err = 0;\r\nswitch (cmd) {\r\ncase GPMC_NAND_COMMAND:\r\ngpmc_cs_write_byte(cs, GPMC_CS_NAND_COMMAND, wval);\r\nbreak;\r\ncase GPMC_NAND_ADDRESS:\r\ngpmc_cs_write_byte(cs, GPMC_CS_NAND_ADDRESS, wval);\r\nbreak;\r\ncase GPMC_NAND_DATA:\r\ngpmc_cs_write_byte(cs, GPMC_CS_NAND_DATA, wval);\r\ndefault:\r\nprintk(KERN_ERR "gpmc_write_nand_ctrl: Not supported\n");\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nint gpmc_prefetch_enable(int cs, int fifo_th, int dma_mode,\r\nunsigned int u32_count, int is_write)\r\n{\r\nif (fifo_th > PREFETCH_FIFOTHRESHOLD_MAX) {\r\npr_err("gpmc: fifo threshold is not supported\n");\r\nreturn -1;\r\n} else if (!(gpmc_read_reg(GPMC_PREFETCH_CONTROL))) {\r\ngpmc_write_reg(GPMC_PREFETCH_CONFIG2, u32_count);\r\ngpmc_write_reg(GPMC_PREFETCH_CONFIG1, ((cs << CS_NUM_SHIFT) |\r\nPREFETCH_FIFOTHRESHOLD(fifo_th) |\r\nENABLE_PREFETCH |\r\n(dma_mode << DMA_MPU_MODE) |\r\n(0x1 & is_write)));\r\ngpmc_write_reg(GPMC_PREFETCH_CONTROL, 0x1);\r\n} else {\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nint gpmc_prefetch_reset(int cs)\r\n{\r\nu32 config1;\r\nconfig1 = gpmc_read_reg(GPMC_PREFETCH_CONFIG1);\r\nif (((config1 >> CS_NUM_SHIFT) & 0x7) != cs)\r\nreturn -EINVAL;\r\ngpmc_write_reg(GPMC_PREFETCH_CONTROL, 0x0);\r\ngpmc_write_reg(GPMC_PREFETCH_CONFIG1, 0x0);\r\nreturn 0;\r\n}\r\nstatic void __init gpmc_mem_init(void)\r\n{\r\nint cs;\r\nunsigned long boot_rom_space = 0;\r\nboot_rom_space = BOOT_ROM_SPACE;\r\nif (machine_is_omap_apollon())\r\nboot_rom_space = 0;\r\ngpmc_mem_root.start = GPMC_MEM_START + boot_rom_space;\r\ngpmc_mem_root.end = GPMC_MEM_END;\r\nfor (cs = 0; cs < GPMC_CS_NUM; cs++) {\r\nu32 base, size;\r\nif (!gpmc_cs_mem_enabled(cs))\r\ncontinue;\r\ngpmc_cs_get_memconf(cs, &base, &size);\r\nif (gpmc_cs_insert_mem(cs, base, size) < 0)\r\nBUG();\r\n}\r\n}\r\nstatic int __init gpmc_init(void)\r\n{\r\nu32 l, irq;\r\nint cs, ret = -EINVAL;\r\nint gpmc_irq;\r\nchar *ck = NULL;\r\nif (cpu_is_omap24xx()) {\r\nck = "core_l3_ck";\r\nif (cpu_is_omap2420())\r\nl = OMAP2420_GPMC_BASE;\r\nelse\r\nl = OMAP34XX_GPMC_BASE;\r\ngpmc_irq = INT_34XX_GPMC_IRQ;\r\n} else if (cpu_is_omap34xx()) {\r\nck = "gpmc_fck";\r\nl = OMAP34XX_GPMC_BASE;\r\ngpmc_irq = INT_34XX_GPMC_IRQ;\r\n} else if (cpu_is_omap44xx()) {\r\nck = "gpmc_ck";\r\nl = OMAP44XX_GPMC_BASE;\r\ngpmc_irq = OMAP44XX_IRQ_GPMC;\r\n}\r\nif (WARN_ON(!ck))\r\nreturn ret;\r\ngpmc_l3_clk = clk_get(NULL, ck);\r\nif (IS_ERR(gpmc_l3_clk)) {\r\nprintk(KERN_ERR "Could not get GPMC clock %s\n", ck);\r\nBUG();\r\n}\r\ngpmc_base = ioremap(l, SZ_4K);\r\nif (!gpmc_base) {\r\nclk_put(gpmc_l3_clk);\r\nprintk(KERN_ERR "Could not get GPMC register memory\n");\r\nBUG();\r\n}\r\nclk_enable(gpmc_l3_clk);\r\nl = gpmc_read_reg(GPMC_REVISION);\r\nprintk(KERN_INFO "GPMC revision %d.%d\n", (l >> 4) & 0x0f, l & 0x0f);\r\nl = gpmc_read_reg(GPMC_SYSCONFIG);\r\nl &= 0x03 << 3;\r\nl |= (0x02 << 3) | (1 << 0);\r\ngpmc_write_reg(GPMC_SYSCONFIG, l);\r\ngpmc_mem_init();\r\nirq = OMAP_GPMC_IRQ_BASE;\r\nfor (cs = 0; cs < GPMC_CS_NUM; cs++) {\r\nirq_set_chip_and_handler(irq, &dummy_irq_chip,\r\nhandle_simple_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\nirq++;\r\n}\r\nret = request_irq(gpmc_irq,\r\ngpmc_handle_irq, IRQF_SHARED, "gpmc", gpmc_base);\r\nif (ret)\r\npr_err("gpmc: irq-%d could not claim: err %d\n",\r\ngpmc_irq, ret);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t gpmc_handle_irq(int irq, void *dev)\r\n{\r\nu8 cs;\r\ncs = ((gpmc_read_reg(GPMC_PREFETCH_CONFIG1)) >> CS_NUM_SHIFT) & 0x7;\r\nif (OMAP_GPMC_IRQ_BASE+cs <= OMAP_GPMC_IRQ_END)\r\ngeneric_handle_irq(OMAP_GPMC_IRQ_BASE+cs);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid omap3_gpmc_save_context(void)\r\n{\r\nint i;\r\ngpmc_context.sysconfig = gpmc_read_reg(GPMC_SYSCONFIG);\r\ngpmc_context.irqenable = gpmc_read_reg(GPMC_IRQENABLE);\r\ngpmc_context.timeout_ctrl = gpmc_read_reg(GPMC_TIMEOUT_CONTROL);\r\ngpmc_context.config = gpmc_read_reg(GPMC_CONFIG);\r\ngpmc_context.prefetch_config1 = gpmc_read_reg(GPMC_PREFETCH_CONFIG1);\r\ngpmc_context.prefetch_config2 = gpmc_read_reg(GPMC_PREFETCH_CONFIG2);\r\ngpmc_context.prefetch_control = gpmc_read_reg(GPMC_PREFETCH_CONTROL);\r\nfor (i = 0; i < GPMC_CS_NUM; i++) {\r\ngpmc_context.cs_context[i].is_valid = gpmc_cs_mem_enabled(i);\r\nif (gpmc_context.cs_context[i].is_valid) {\r\ngpmc_context.cs_context[i].config1 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG1);\r\ngpmc_context.cs_context[i].config2 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG2);\r\ngpmc_context.cs_context[i].config3 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG3);\r\ngpmc_context.cs_context[i].config4 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG4);\r\ngpmc_context.cs_context[i].config5 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG5);\r\ngpmc_context.cs_context[i].config6 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG6);\r\ngpmc_context.cs_context[i].config7 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG7);\r\n}\r\n}\r\n}\r\nvoid omap3_gpmc_restore_context(void)\r\n{\r\nint i;\r\ngpmc_write_reg(GPMC_SYSCONFIG, gpmc_context.sysconfig);\r\ngpmc_write_reg(GPMC_IRQENABLE, gpmc_context.irqenable);\r\ngpmc_write_reg(GPMC_TIMEOUT_CONTROL, gpmc_context.timeout_ctrl);\r\ngpmc_write_reg(GPMC_CONFIG, gpmc_context.config);\r\ngpmc_write_reg(GPMC_PREFETCH_CONFIG1, gpmc_context.prefetch_config1);\r\ngpmc_write_reg(GPMC_PREFETCH_CONFIG2, gpmc_context.prefetch_config2);\r\ngpmc_write_reg(GPMC_PREFETCH_CONTROL, gpmc_context.prefetch_control);\r\nfor (i = 0; i < GPMC_CS_NUM; i++) {\r\nif (gpmc_context.cs_context[i].is_valid) {\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG1,\r\ngpmc_context.cs_context[i].config1);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG2,\r\ngpmc_context.cs_context[i].config2);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG3,\r\ngpmc_context.cs_context[i].config3);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG4,\r\ngpmc_context.cs_context[i].config4);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG5,\r\ngpmc_context.cs_context[i].config5);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG6,\r\ngpmc_context.cs_context[i].config6);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG7,\r\ngpmc_context.cs_context[i].config7);\r\n}\r\n}\r\n}\r\nint gpmc_enable_hwecc(int cs, int mode, int dev_width, int ecc_size)\r\n{\r\nunsigned int val;\r\nif (gpmc_ecc_used != -EINVAL)\r\nreturn -EINVAL;\r\ngpmc_ecc_used = cs;\r\nval = ((0x00000001<<8) | 0x00000001);\r\ngpmc_write_reg(GPMC_ECC_CONTROL, val);\r\nval = ((((ecc_size >> 1) - 1) << 22) | (0x0000000F));\r\ngpmc_write_reg(GPMC_ECC_SIZE_CONFIG, val);\r\nswitch (mode) {\r\ncase GPMC_ECC_READ:\r\ngpmc_write_reg(GPMC_ECC_CONTROL, 0x101);\r\nbreak;\r\ncase GPMC_ECC_READSYN:\r\ngpmc_write_reg(GPMC_ECC_CONTROL, 0x100);\r\nbreak;\r\ncase GPMC_ECC_WRITE:\r\ngpmc_write_reg(GPMC_ECC_CONTROL, 0x101);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Error: Unrecognized Mode[%d]!\n", mode);\r\nbreak;\r\n}\r\nval = (dev_width << 7) | (cs << 1) | (0x1);\r\ngpmc_write_reg(GPMC_ECC_CONFIG, val);\r\nreturn 0;\r\n}\r\nint gpmc_calculate_ecc(int cs, const u_char *dat, u_char *ecc_code)\r\n{\r\nunsigned int val = 0x0;\r\nif (gpmc_ecc_used != cs)\r\nreturn -EINVAL;\r\nval = gpmc_read_reg(GPMC_ECC1_RESULT);\r\n*ecc_code++ = val;\r\n*ecc_code++ = val >> 16;\r\n*ecc_code++ = ((val >> 8) & 0x0f) | ((val >> 20) & 0xf0);\r\ngpmc_ecc_used = -EINVAL;\r\nreturn 0;\r\n}
