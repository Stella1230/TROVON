struct ab8500_gpadc *ab8500_gpadc_get(char *name)\r\n{\r\nstruct ab8500_gpadc *gpadc;\r\nlist_for_each_entry(gpadc, &ab8500_gpadc_list, node) {\r\nif (!strcmp(name, dev_name(gpadc->dev)))\r\nreturn gpadc;\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic int ab8500_gpadc_ad_to_voltage(struct ab8500_gpadc *gpadc, u8 input,\r\nint ad_value)\r\n{\r\nint res;\r\nswitch (input) {\r\ncase MAIN_CHARGER_V:\r\nif (!gpadc->cal_data[ADC_INPUT_VMAIN].gain) {\r\nres = ADC_CH_CHG_V_MIN + (ADC_CH_CHG_V_MAX -\r\nADC_CH_CHG_V_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\n}\r\nres = (int) (ad_value * gpadc->cal_data[ADC_INPUT_VMAIN].gain +\r\ngpadc->cal_data[ADC_INPUT_VMAIN].offset) / CALIB_SCALE;\r\nbreak;\r\ncase BAT_CTRL:\r\ncase BTEMP_BALL:\r\ncase ACC_DETECT1:\r\ncase ADC_AUX1:\r\ncase ADC_AUX2:\r\nif (!gpadc->cal_data[ADC_INPUT_BTEMP].gain) {\r\nres = ADC_CH_BTEMP_MIN + (ADC_CH_BTEMP_MAX -\r\nADC_CH_BTEMP_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\n}\r\nres = (int) (ad_value * gpadc->cal_data[ADC_INPUT_BTEMP].gain +\r\ngpadc->cal_data[ADC_INPUT_BTEMP].offset) / CALIB_SCALE;\r\nbreak;\r\ncase MAIN_BAT_V:\r\nif (!gpadc->cal_data[ADC_INPUT_VBAT].gain) {\r\nres = ADC_CH_VBAT_MIN + (ADC_CH_VBAT_MAX -\r\nADC_CH_VBAT_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\n}\r\nres = (int) (ad_value * gpadc->cal_data[ADC_INPUT_VBAT].gain +\r\ngpadc->cal_data[ADC_INPUT_VBAT].offset) / CALIB_SCALE;\r\nbreak;\r\ncase DIE_TEMP:\r\nres = ADC_CH_DIETEMP_MIN +\r\n(ADC_CH_DIETEMP_MAX - ADC_CH_DIETEMP_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase ACC_DETECT2:\r\nres = ADC_CH_ACCDET2_MIN +\r\n(ADC_CH_ACCDET2_MAX - ADC_CH_ACCDET2_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase VBUS_V:\r\nres = ADC_CH_CHG_V_MIN +\r\n(ADC_CH_CHG_V_MAX - ADC_CH_CHG_V_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase MAIN_CHARGER_C:\r\ncase USB_CHARGER_C:\r\nres = ADC_CH_CHG_I_MIN +\r\n(ADC_CH_CHG_I_MAX - ADC_CH_CHG_I_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase BK_BAT_V:\r\nres = ADC_CH_BKBAT_MIN +\r\n(ADC_CH_BKBAT_MAX - ADC_CH_BKBAT_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ndefault:\r\ndev_err(gpadc->dev,\r\n"unknown channel, not possible to convert\n");\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nint ab8500_gpadc_convert(struct ab8500_gpadc *gpadc, u8 input)\r\n{\r\nint ret;\r\nu16 data = 0;\r\nint looplimit = 0;\r\nu8 val, low_data, high_data;\r\nif (!gpadc)\r\nreturn -ENODEV;\r\nmutex_lock(&gpadc->ab8500_gpadc_lock);\r\nregulator_enable(gpadc->regu);\r\ndo {\r\nret = abx500_get_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_STAT_REG, &val);\r\nif (ret < 0)\r\ngoto out;\r\nif (!(val & GPADC_BUSY))\r\nbreak;\r\nmsleep(10);\r\n} while (++looplimit < 10);\r\nif (looplimit >= 10 && (val & GPADC_BUSY)) {\r\ndev_err(gpadc->dev, "gpadc_conversion: GPADC busy");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = abx500_mask_and_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL1_REG, EN_GPADC, EN_GPADC);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev, "gpadc_conversion: enable gpadc failed\n");\r\ngoto out;\r\n}\r\nret = abx500_set_register_interruptible(gpadc->dev, AB8500_GPADC,\r\nAB8500_GPADC_CTRL2_REG, (input | SW_AVG_16));\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: set avg samples failed\n");\r\ngoto out;\r\n}\r\nswitch (input) {\r\ncase MAIN_CHARGER_C:\r\ncase USB_CHARGER_C:\r\nret = abx500_mask_and_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL1_REG,\r\nEN_BUF | EN_ICHAR,\r\nEN_BUF | EN_ICHAR);\r\nbreak;\r\ncase BTEMP_BALL:\r\nif (gpadc->chip_id >= AB8500_CUT3P0) {\r\nret = abx500_mask_and_set_register_interruptible(\r\ngpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL1_REG,\r\nEN_BUF | BTEMP_PULL_UP,\r\nEN_BUF | BTEMP_PULL_UP);\r\nmsleep(1);\r\nbreak;\r\n}\r\ndefault:\r\nret = abx500_mask_and_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL1_REG, EN_BUF, EN_BUF);\r\nbreak;\r\n}\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: select falling edge failed\n");\r\ngoto out;\r\n}\r\nret = abx500_mask_and_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL1_REG, ADC_SW_CONV, ADC_SW_CONV);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: start s/w conversion failed\n");\r\ngoto out;\r\n}\r\nif (!wait_for_completion_timeout(&gpadc->ab8500_gpadc_complete, 2*HZ)) {\r\ndev_err(gpadc->dev,\r\n"timeout: didn't receive GPADC conversion interrupt\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = abx500_get_register_interruptible(gpadc->dev, AB8500_GPADC,\r\nAB8500_GPADC_MANDATAL_REG, &low_data);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev, "gpadc_conversion: read low data failed\n");\r\ngoto out;\r\n}\r\nret = abx500_get_register_interruptible(gpadc->dev, AB8500_GPADC,\r\nAB8500_GPADC_MANDATAH_REG, &high_data);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: read high data failed\n");\r\ngoto out;\r\n}\r\ndata = (high_data << 8) | low_data;\r\nret = abx500_set_register_interruptible(gpadc->dev, AB8500_GPADC,\r\nAB8500_GPADC_CTRL1_REG, DIS_GPADC);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev, "gpadc_conversion: disable gpadc failed\n");\r\ngoto out;\r\n}\r\nregulator_disable(gpadc->regu);\r\nmutex_unlock(&gpadc->ab8500_gpadc_lock);\r\nret = ab8500_gpadc_ad_to_voltage(gpadc, input, data);\r\nreturn ret;\r\nout:\r\n(void) abx500_set_register_interruptible(gpadc->dev, AB8500_GPADC,\r\nAB8500_GPADC_CTRL1_REG, DIS_GPADC);\r\nregulator_disable(gpadc->regu);\r\nmutex_unlock(&gpadc->ab8500_gpadc_lock);\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: Failed to AD convert channel %d\n", input);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ab8500_bm_gpswadcconvend_handler(int irq, void *_gpadc)\r\n{\r\nstruct ab8500_gpadc *gpadc = _gpadc;\r\ncomplete(&gpadc->ab8500_gpadc_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ab8500_gpadc_read_calibration_data(struct ab8500_gpadc *gpadc)\r\n{\r\nint i;\r\nint ret[ARRAY_SIZE(otp_cal_regs)];\r\nu8 gpadc_cal[ARRAY_SIZE(otp_cal_regs)];\r\nint vmain_high, vmain_low;\r\nint btemp_high, btemp_low;\r\nint vbat_high, vbat_low;\r\nfor (i = 0; i < ARRAY_SIZE(otp_cal_regs); i++) {\r\nret[i] = abx500_get_register_interruptible(gpadc->dev,\r\nAB8500_OTP_EMUL, otp_cal_regs[i], &gpadc_cal[i]);\r\nif (ret[i] < 0)\r\ndev_err(gpadc->dev, "%s: read otp reg 0x%02x failed\n",\r\n__func__, otp_cal_regs[i]);\r\n}\r\nif (!(ret[0] < 0 || ret[1] < 0 || ret[2] < 0)) {\r\nvmain_high = (((gpadc_cal[0] & 0x03) << 8) |\r\n((gpadc_cal[1] & 0x3F) << 2) |\r\n((gpadc_cal[2] & 0xC0) >> 6));\r\nvmain_low = ((gpadc_cal[2] & 0x3E) >> 1);\r\ngpadc->cal_data[ADC_INPUT_VMAIN].gain = CALIB_SCALE *\r\n(19500 - 315) / (vmain_high - vmain_low);\r\ngpadc->cal_data[ADC_INPUT_VMAIN].offset = CALIB_SCALE * 19500 -\r\n(CALIB_SCALE * (19500 - 315) /\r\n(vmain_high - vmain_low)) * vmain_high;\r\n} else {\r\ngpadc->cal_data[ADC_INPUT_VMAIN].gain = 0;\r\n}\r\nif (!(ret[2] < 0 || ret[3] < 0 || ret[4] < 0)) {\r\nbtemp_high = (((gpadc_cal[2] & 0x01) << 9) |\r\n(gpadc_cal[3] << 1) |\r\n((gpadc_cal[4] & 0x80) >> 7));\r\nbtemp_low = ((gpadc_cal[4] & 0x7C) >> 2);\r\ngpadc->cal_data[ADC_INPUT_BTEMP].gain =\r\nCALIB_SCALE * (1300 - 21) / (btemp_high - btemp_low);\r\ngpadc->cal_data[ADC_INPUT_BTEMP].offset = CALIB_SCALE * 1300 -\r\n(CALIB_SCALE * (1300 - 21) /\r\n(btemp_high - btemp_low)) * btemp_high;\r\n} else {\r\ngpadc->cal_data[ADC_INPUT_BTEMP].gain = 0;\r\n}\r\nif (!(ret[4] < 0 || ret[5] < 0 || ret[6] < 0)) {\r\nvbat_high = (((gpadc_cal[4] & 0x03) << 8) | gpadc_cal[5]);\r\nvbat_low = ((gpadc_cal[6] & 0xFC) >> 2);\r\ngpadc->cal_data[ADC_INPUT_VBAT].gain = CALIB_SCALE *\r\n(4700 - 2380) / (vbat_high - vbat_low);\r\ngpadc->cal_data[ADC_INPUT_VBAT].offset = CALIB_SCALE * 4700 -\r\n(CALIB_SCALE * (4700 - 2380) /\r\n(vbat_high - vbat_low)) * vbat_high;\r\n} else {\r\ngpadc->cal_data[ADC_INPUT_VBAT].gain = 0;\r\n}\r\ndev_dbg(gpadc->dev, "VMAIN gain %llu offset %llu\n",\r\ngpadc->cal_data[ADC_INPUT_VMAIN].gain,\r\ngpadc->cal_data[ADC_INPUT_VMAIN].offset);\r\ndev_dbg(gpadc->dev, "BTEMP gain %llu offset %llu\n",\r\ngpadc->cal_data[ADC_INPUT_BTEMP].gain,\r\ngpadc->cal_data[ADC_INPUT_BTEMP].offset);\r\ndev_dbg(gpadc->dev, "VBAT gain %llu offset %llu\n",\r\ngpadc->cal_data[ADC_INPUT_VBAT].gain,\r\ngpadc->cal_data[ADC_INPUT_VBAT].offset);\r\n}\r\nstatic int __devinit ab8500_gpadc_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct ab8500_gpadc *gpadc;\r\ngpadc = kzalloc(sizeof(struct ab8500_gpadc), GFP_KERNEL);\r\nif (!gpadc) {\r\ndev_err(&pdev->dev, "Error: No memory\n");\r\nreturn -ENOMEM;\r\n}\r\ngpadc->irq = platform_get_irq_byname(pdev, "SW_CONV_END");\r\nif (gpadc->irq < 0) {\r\ndev_err(gpadc->dev, "failed to get platform irq-%d\n",\r\ngpadc->irq);\r\nret = gpadc->irq;\r\ngoto fail;\r\n}\r\ngpadc->dev = &pdev->dev;\r\nmutex_init(&gpadc->ab8500_gpadc_lock);\r\ninit_completion(&gpadc->ab8500_gpadc_complete);\r\nret = request_threaded_irq(gpadc->irq, NULL,\r\nab8500_bm_gpswadcconvend_handler,\r\nIRQF_NO_SUSPEND | IRQF_SHARED, "ab8500-gpadc", gpadc);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev, "Failed to register interrupt, irq: %d\n",\r\ngpadc->irq);\r\ngoto fail;\r\n}\r\nret = abx500_get_chip_id(gpadc->dev);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev, "failed to get chip ID\n");\r\ngoto fail_irq;\r\n}\r\ngpadc->chip_id = (u8) ret;\r\ngpadc->regu = regulator_get(&pdev->dev, "vddadc");\r\nif (IS_ERR(gpadc->regu)) {\r\nret = PTR_ERR(gpadc->regu);\r\ndev_err(gpadc->dev, "failed to get vtvout LDO\n");\r\ngoto fail_irq;\r\n}\r\nab8500_gpadc_read_calibration_data(gpadc);\r\nlist_add_tail(&gpadc->node, &ab8500_gpadc_list);\r\ndev_dbg(gpadc->dev, "probe success\n");\r\nreturn 0;\r\nfail_irq:\r\nfree_irq(gpadc->irq, gpadc);\r\nfail:\r\nkfree(gpadc);\r\ngpadc = NULL;\r\nreturn ret;\r\n}\r\nstatic int __devexit ab8500_gpadc_remove(struct platform_device *pdev)\r\n{\r\nstruct ab8500_gpadc *gpadc = platform_get_drvdata(pdev);\r\nlist_del(&gpadc->node);\r\nfree_irq(gpadc->irq, gpadc);\r\nregulator_put(gpadc->regu);\r\nkfree(gpadc);\r\ngpadc = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init ab8500_gpadc_init(void)\r\n{\r\nreturn platform_driver_register(&ab8500_gpadc_driver);\r\n}\r\nstatic void __exit ab8500_gpadc_exit(void)\r\n{\r\nplatform_driver_unregister(&ab8500_gpadc_driver);\r\n}
