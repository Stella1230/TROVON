static int broken_suspend(struct usb_hcd *hcd)\r\n{\r\ndevice_init_wakeup(&hcd->self.root_hub->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int ohci_quirk_amd756(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nohci->flags = OHCI_QUIRK_AMD756;\r\nohci_dbg (ohci, "AMD756 erratum 4 workaround\n");\r\nreturn broken_suspend(hcd);\r\n}\r\nstatic int ohci_quirk_opti(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nohci_dbg (ohci, "WARNING: OPTi workarounds unavailable\n");\r\nreturn 0;\r\n}\r\nstatic int ohci_quirk_ns(struct usb_hcd *hcd)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nstruct pci_dev *b;\r\nb = pci_get_slot (pdev->bus, PCI_DEVFN (PCI_SLOT (pdev->devfn), 1));\r\nif (b && b->device == PCI_DEVICE_ID_NS_87560_LIO\r\n&& b->vendor == PCI_VENDOR_ID_NS) {\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nohci->flags |= OHCI_QUIRK_SUPERIO;\r\nohci_dbg (ohci, "Using NSC SuperIO setup\n");\r\n}\r\npci_dev_put(b);\r\nreturn 0;\r\n}\r\nstatic int ohci_quirk_zfmicro(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nohci->flags |= OHCI_QUIRK_ZFMICRO;\r\nohci_dbg(ohci, "enabled Compaq ZFMicro chipset quirks\n");\r\nreturn 0;\r\n}\r\nstatic int ohci_quirk_toshiba_scc(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\n#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO\r\nohci->flags |= OHCI_QUIRK_BE_MMIO;\r\nohci_dbg (ohci, "enabled big endian Toshiba quirk\n");\r\nreturn 0;\r\n#else\r\nohci_err (ohci, "unsupported big endian Toshiba quirk\n");\r\nreturn -ENXIO;\r\n#endif\r\n}\r\nstatic void ohci_quirk_nec_worker(struct work_struct *work)\r\n{\r\nstruct ohci_hcd *ohci = container_of(work, struct ohci_hcd, nec_work);\r\nint status;\r\nstatus = ohci_init(ohci);\r\nif (status != 0) {\r\nohci_err(ohci, "Restarting NEC controller failed in %s, %d\n",\r\n"ohci_init", status);\r\nreturn;\r\n}\r\nstatus = ohci_restart(ohci);\r\nif (status != 0)\r\nohci_err(ohci, "Restarting NEC controller failed in %s, %d\n",\r\n"ohci_restart", status);\r\n}\r\nstatic int ohci_quirk_nec(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nohci->flags |= OHCI_QUIRK_NEC;\r\nINIT_WORK(&ohci->nec_work, ohci_quirk_nec_worker);\r\nohci_dbg (ohci, "enabled NEC chipset lost interrupt quirk\n");\r\nreturn 0;\r\n}\r\nstatic int ohci_quirk_amd700(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct pci_dev *amd_smbus_dev;\r\nu8 rev;\r\nif (usb_amd_find_chipset_info())\r\nohci->flags |= OHCI_QUIRK_AMD_PLL;\r\namd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,\r\nPCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);\r\nif (!amd_smbus_dev)\r\nreturn 0;\r\nrev = amd_smbus_dev->revision;\r\nif ((rev >= 0x40) && (rev <= 0x4f)) {\r\nohci->flags |= OHCI_QUIRK_AMD_PREFETCH;\r\nohci_dbg(ohci, "enabled AMD prefetch quirk\n");\r\n}\r\npci_dev_put(amd_smbus_dev);\r\namd_smbus_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\n#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB 0x026d\r\nif (pdev->device < PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB) {\r\nohci->flags |= OHCI_QUIRK_SHUTDOWN;\r\nohci_dbg(ohci, "enabled nVidia shutdown quirk\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void sb800_prefetch(struct ohci_hcd *ohci, int on)\r\n{\r\nstruct pci_dev *pdev;\r\nu16 misc;\r\npdev = to_pci_dev(ohci_to_hcd(ohci)->self.controller);\r\npci_read_config_word(pdev, 0x50, &misc);\r\nif (on == 0)\r\npci_write_config_word(pdev, 0x50, misc & 0xfcff);\r\nelse\r\npci_write_config_word(pdev, 0x50, misc | 0x0300);\r\n}\r\nstatic int ohci_pci_reset (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint ret = 0;\r\nif (hcd->self.controller) {\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nconst struct pci_device_id *quirk_id;\r\nquirk_id = pci_match_id(ohci_pci_quirks, pdev);\r\nif (quirk_id != NULL) {\r\nint (*quirk)(struct usb_hcd *ohci);\r\nquirk = (void *)quirk_id->driver_data;\r\nret = quirk(hcd);\r\n}\r\n}\r\nif (ret == 0) {\r\nohci_hcd_init (ohci);\r\nreturn ohci_init (ohci);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit ohci_pci_start (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint ret;\r\n#ifdef CONFIG_PM\r\nif (hcd->self.controller) {\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nif (device_can_wakeup(&pdev->dev))\r\nohci->hc_control |= OHCI_CTRL_RWC;\r\n}\r\n#endif\r\nret = ohci_run (ohci);\r\nif (ret < 0) {\r\nohci_err (ohci, "can't start\n");\r\nohci_stop (hcd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ohci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nif (hcd->state != HC_STATE_SUSPENDED) {\r\nrc = -EINVAL;\r\ngoto bail;\r\n}\r\nohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\r\n(void)ohci_readl(ohci, &ohci->regs->intrdisable);\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nbail:\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int ohci_pci_resume(struct usb_hcd *hcd, bool hibernated)\r\n{\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nif (hibernated)\r\nohci_usb_reset(hcd_to_ohci(hcd));\r\nohci_finish_controller_resume(hcd);\r\nreturn 0;\r\n}
