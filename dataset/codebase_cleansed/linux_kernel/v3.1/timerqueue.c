void timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\r\n{\r\nstruct rb_node **p = &head->head.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct timerqueue_node *ptr;\r\nWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\r\nwhile (*p) {\r\nparent = *p;\r\nptr = rb_entry(parent, struct timerqueue_node, node);\r\nif (node->expires.tv64 < ptr->expires.tv64)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&node->node, parent, p);\r\nrb_insert_color(&node->node, &head->head);\r\nif (!head->next || node->expires.tv64 < head->next->expires.tv64)\r\nhead->next = node;\r\n}\r\nvoid timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)\r\n{\r\nWARN_ON_ONCE(RB_EMPTY_NODE(&node->node));\r\nif (head->next == node) {\r\nstruct rb_node *rbn = rb_next(&node->node);\r\nhead->next = rbn ?\r\nrb_entry(rbn, struct timerqueue_node, node) : NULL;\r\n}\r\nrb_erase(&node->node, &head->head);\r\nRB_CLEAR_NODE(&node->node);\r\n}\r\nstruct timerqueue_node *timerqueue_iterate_next(struct timerqueue_node *node)\r\n{\r\nstruct rb_node *next;\r\nif (!node)\r\nreturn NULL;\r\nnext = rb_next(&node->node);\r\nif (!next)\r\nreturn NULL;\r\nreturn container_of(next, struct timerqueue_node, node);\r\n}
