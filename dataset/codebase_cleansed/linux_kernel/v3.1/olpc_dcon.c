static s32 dcon_write(struct dcon_priv *dcon, u8 reg, u16 val)\r\n{\r\nreturn i2c_smbus_write_word_data(dcon->client, reg, val);\r\n}\r\nstatic s32 dcon_read(struct dcon_priv *dcon, u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_data(dcon->client, reg);\r\n}\r\nstatic int dcon_hw_init(struct dcon_priv *dcon, int is_init)\r\n{\r\nstruct i2c_client *client = dcon->client;\r\nuint16_t ver;\r\nint rc = 0;\r\nver = i2c_smbus_read_word_data(client, DCON_REG_ID);\r\nif ((ver >> 8) != 0xDC) {\r\nprintk(KERN_ERR "olpc-dcon: DCON ID not 0xDCxx: 0x%04x "\r\n"instead.\n", ver);\r\nrc = -ENXIO;\r\ngoto err;\r\n}\r\nif (is_init) {\r\nprintk(KERN_INFO "olpc-dcon: Discovered DCON version %x\n",\r\nver & 0xFF);\r\nrc = pdata->init(dcon);\r\nif (rc != 0) {\r\nprintk(KERN_ERR "olpc-dcon: Unable to init.\n");\r\ngoto err;\r\n}\r\n}\r\nif (ver < 0xdc02 && !noinit) {\r\ni2c_smbus_write_word_data(client, 0x4b, 0x00cc);\r\ni2c_smbus_write_word_data(client, 0x4b, 0x00cc);\r\ni2c_smbus_write_word_data(client, 0x4b, 0x00cc);\r\ni2c_smbus_write_word_data(client, 0x0b, 0x007a);\r\ni2c_smbus_write_word_data(client, 0x36, 0x025c);\r\ni2c_smbus_write_word_data(client, 0x37, 0x025e);\r\ni2c_smbus_write_word_data(client, 0x3b, 0x002b);\r\ni2c_smbus_write_word_data(client, 0x41, 0x0101);\r\ni2c_smbus_write_word_data(client, 0x42, 0x0101);\r\n} else if (!noinit) {\r\ni2c_smbus_write_word_data(client, 0x3a, 0xc040);\r\ni2c_smbus_write_word_data(client, 0x41, 0x0000);\r\ni2c_smbus_write_word_data(client, 0x41, 0x0101);\r\ni2c_smbus_write_word_data(client, 0x42, 0x0101);\r\n}\r\nif (is_init) {\r\ndcon->disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE |\r\nMODE_CSWIZZLE;\r\nif (useaa)\r\ndcon->disp_mode |= MODE_COL_AA;\r\n}\r\ni2c_smbus_write_word_data(client, DCON_REG_MODE, dcon->disp_mode);\r\ni2c_smbus_write_word_data(client, DCON_REG_SCAN_INT, resumeline);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int dcon_bus_stabilize(struct dcon_priv *dcon, int is_powered_down)\r\n{\r\nunsigned long timeout;\r\nint x;\r\npower_up:\r\nif (is_powered_down) {\r\nx = 1;\r\nx = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);\r\nif (x) {\r\nprintk(KERN_WARNING "olpc-dcon: unable to force dcon "\r\n"to power up: %d!\n", x);\r\nreturn x;\r\n}\r\nmsleep(10);\r\n}\r\npdata->bus_stabilize_wiggle();\r\nfor (x = -1, timeout = 50; timeout && x < 0; timeout--) {\r\nmsleep(1);\r\nx = dcon_read(dcon, DCON_REG_ID);\r\n}\r\nif (x < 0) {\r\nprintk(KERN_ERR "olpc-dcon: unable to stabilize dcon's "\r\n"smbus, reasserting power and praying.\n");\r\nBUG_ON(olpc_board_at_least(olpc_board(0xc2)));\r\nx = 0;\r\nolpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);\r\nmsleep(100);\r\nis_powered_down = 1;\r\ngoto power_up;\r\n}\r\nif (is_powered_down)\r\nreturn dcon_hw_init(dcon, 0);\r\nreturn 0;\r\n}\r\nstatic void dcon_set_backlight(struct dcon_priv *dcon, u8 level)\r\n{\r\ndcon->bl_val = level;\r\ndcon_write(dcon, DCON_REG_BRIGHT, dcon->bl_val);\r\nif (dcon->bl_val == 0) {\r\ndcon->disp_mode &= ~MODE_BL_ENABLE;\r\ndcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);\r\n} else if (!(dcon->disp_mode & MODE_BL_ENABLE)) {\r\ndcon->disp_mode |= MODE_BL_ENABLE;\r\ndcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);\r\n}\r\n}\r\nstatic int dcon_set_mono_mode(struct dcon_priv *dcon, bool enable_mono)\r\n{\r\nif (dcon->mono == enable_mono)\r\nreturn 0;\r\ndcon->mono = enable_mono;\r\nif (enable_mono) {\r\ndcon->disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);\r\ndcon->disp_mode |= MODE_MONO_LUMA;\r\n} else {\r\ndcon->disp_mode &= ~(MODE_MONO_LUMA);\r\ndcon->disp_mode |= MODE_CSWIZZLE;\r\nif (useaa)\r\ndcon->disp_mode |= MODE_COL_AA;\r\n}\r\ndcon_write(dcon, DCON_REG_MODE, dcon->disp_mode);\r\nreturn 0;\r\n}\r\nstatic void dcon_sleep(struct dcon_priv *dcon, bool sleep)\r\n{\r\nint x;\r\nif (dcon->asleep == sleep)\r\nreturn;\r\nif (!olpc_board_at_least(olpc_board(0xc2)))\r\nreturn;\r\nif (sleep) {\r\nx = 0;\r\nx = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);\r\nif (x)\r\nprintk(KERN_WARNING "olpc-dcon: unable to force dcon "\r\n"to power down: %d!\n", x);\r\nelse\r\ndcon->asleep = sleep;\r\n} else {\r\nif (dcon->bl_val != 0)\r\ndcon->disp_mode |= MODE_BL_ENABLE;\r\nx = dcon_bus_stabilize(dcon, 1);\r\nif (x)\r\nprintk(KERN_WARNING "olpc-dcon: unable to reinit dcon"\r\n" hardware: %d!\n", x);\r\nelse\r\ndcon->asleep = sleep;\r\ndcon_set_backlight(dcon, dcon->bl_val);\r\n}\r\n}\r\nstatic void dcon_load_holdoff(struct dcon_priv *dcon)\r\n{\r\nstruct timespec delta_t, now;\r\nwhile (1) {\r\ngetnstimeofday(&now);\r\ndelta_t = timespec_sub(now, dcon->load_time);\r\nif (delta_t.tv_sec != 0 ||\r\ndelta_t.tv_nsec > NSEC_PER_MSEC * 20) {\r\nbreak;\r\n}\r\nmdelay(4);\r\n}\r\n}\r\nstatic bool dcon_blank_fb(struct dcon_priv *dcon, bool blank)\r\n{\r\nint err;\r\nif (!lock_fb_info(dcon->fbinfo)) {\r\ndev_err(&dcon->client->dev, "unable to lock framebuffer\n");\r\nreturn false;\r\n}\r\nconsole_lock();\r\ndcon->ignore_fb_events = true;\r\nerr = fb_blank(dcon->fbinfo,\r\nblank ? FB_BLANK_POWERDOWN : FB_BLANK_UNBLANK);\r\ndcon->ignore_fb_events = false;\r\nconsole_unlock();\r\nunlock_fb_info(dcon->fbinfo);\r\nif (err) {\r\ndev_err(&dcon->client->dev, "couldn't %sblank framebuffer\n",\r\nblank ? "" : "un");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void dcon_source_switch(struct work_struct *work)\r\n{\r\nstruct dcon_priv *dcon = container_of(work, struct dcon_priv,\r\nswitch_source);\r\nDECLARE_WAITQUEUE(wait, current);\r\nint source = dcon->pending_src;\r\nif (dcon->curr_src == source)\r\nreturn;\r\ndcon_load_holdoff(dcon);\r\ndcon->switched = false;\r\nswitch (source) {\r\ncase DCON_SOURCE_CPU:\r\nprintk("dcon_source_switch to CPU\n");\r\nif (dcon_write(dcon, DCON_REG_MODE,\r\ndcon->disp_mode | MODE_SCAN_INT))\r\nprintk(KERN_ERR\r\n"olpc-dcon: couldn't enable scanline interrupt!\n");\r\nelse {\r\nwait_event_timeout(dcon_wait_queue,\r\ndcon->switched == true, HZ);\r\n}\r\nif (!dcon->switched)\r\nprintk(KERN_ERR "olpc-dcon: Timeout entering CPU mode; expect a screen glitch.\n");\r\nif (dcon_write(dcon, DCON_REG_MODE, dcon->disp_mode))\r\nprintk(KERN_ERR "olpc-dcon: couldn't disable scanline interrupt!\n");\r\nif (!dcon_blank_fb(dcon, false)) {\r\nprintk(KERN_ERR "olpc-dcon: Failed to enter CPU mode\n");\r\ndcon->pending_src = DCON_SOURCE_DCON;\r\nreturn;\r\n}\r\npdata->set_dconload(1);\r\ngetnstimeofday(&dcon->load_time);\r\nprintk(KERN_INFO "olpc-dcon: The CPU has control\n");\r\nbreak;\r\ncase DCON_SOURCE_DCON:\r\n{\r\nint t;\r\nstruct timespec delta_t;\r\nprintk(KERN_INFO "dcon_source_switch to DCON\n");\r\nadd_wait_queue(&dcon_wait_queue, &wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\npdata->set_dconload(0);\r\ngetnstimeofday(&dcon->load_time);\r\nt = schedule_timeout(HZ/2);\r\nremove_wait_queue(&dcon_wait_queue, &wait);\r\nset_current_state(TASK_RUNNING);\r\nif (!dcon->switched) {\r\nprintk(KERN_ERR "olpc-dcon: Timeout entering DCON mode; expect a screen glitch.\n");\r\n} else {\r\ndelta_t = timespec_sub(dcon->irq_time, dcon->load_time);\r\nif (dcon->switched && delta_t.tv_sec == 0 &&\r\ndelta_t.tv_nsec < NSEC_PER_MSEC * 20) {\r\nprintk(KERN_ERR "olpc-dcon: missed loading, retrying\n");\r\npdata->set_dconload(1);\r\nmdelay(41);\r\npdata->set_dconload(0);\r\ngetnstimeofday(&dcon->load_time);\r\nmdelay(41);\r\n}\r\n}\r\ndcon_blank_fb(dcon, true);\r\nprintk(KERN_INFO "olpc-dcon: The DCON has control\n");\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\ndcon->curr_src = source;\r\n}\r\nstatic void dcon_set_source(struct dcon_priv *dcon, int arg)\r\n{\r\nif (dcon->pending_src == arg)\r\nreturn;\r\ndcon->pending_src = arg;\r\nif ((dcon->curr_src != arg) && !work_pending(&dcon->switch_source))\r\nschedule_work(&dcon->switch_source);\r\n}\r\nstatic void dcon_set_source_sync(struct dcon_priv *dcon, int arg)\r\n{\r\ndcon_set_source(dcon, arg);\r\nflush_scheduled_work();\r\n}\r\nstatic ssize_t dcon_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dcon_priv *dcon = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%4.4X\n", dcon->disp_mode);\r\n}\r\nstatic ssize_t dcon_sleep_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dcon_priv *dcon = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", dcon->asleep);\r\n}\r\nstatic ssize_t dcon_freeze_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dcon_priv *dcon = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", dcon->curr_src == DCON_SOURCE_DCON ? 1 : 0);\r\n}\r\nstatic ssize_t dcon_mono_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dcon_priv *dcon = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", dcon->mono);\r\n}\r\nstatic ssize_t dcon_resumeline_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", resumeline);\r\n}\r\nstatic ssize_t dcon_mono_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long enable_mono;\r\nint rc;\r\nrc = strict_strtoul(buf, 10, &enable_mono);\r\nif (rc)\r\nreturn rc;\r\ndcon_set_mono_mode(dev_get_drvdata(dev), enable_mono ? true : false);\r\nreturn count;\r\n}\r\nstatic ssize_t dcon_freeze_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct dcon_priv *dcon = dev_get_drvdata(dev);\r\nunsigned long output;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &output);\r\nif (ret)\r\nreturn ret;\r\nprintk(KERN_INFO "dcon_freeze_store: %lu\n", output);\r\nswitch (output) {\r\ncase 0:\r\ndcon_set_source(dcon, DCON_SOURCE_CPU);\r\nbreak;\r\ncase 1:\r\ndcon_set_source_sync(dcon, DCON_SOURCE_DCON);\r\nbreak;\r\ncase 2:\r\ndcon_set_source(dcon, DCON_SOURCE_DCON);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dcon_resumeline_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long rl;\r\nint rc;\r\nrc = strict_strtoul(buf, 10, &rl);\r\nif (rc)\r\nreturn rc;\r\nresumeline = rl;\r\ndcon_write(dev_get_drvdata(dev), DCON_REG_SCAN_INT, resumeline);\r\nreturn count;\r\n}\r\nstatic ssize_t dcon_sleep_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long output;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &output);\r\nif (ret)\r\nreturn ret;\r\ndcon_sleep(dev_get_drvdata(dev), output ? true : false);\r\nreturn count;\r\n}\r\nstatic int dcon_bl_update(struct backlight_device *dev)\r\n{\r\nstruct dcon_priv *dcon = bl_get_data(dev);\r\nu8 level = dev->props.brightness & 0x0F;\r\nif (dev->props.power != FB_BLANK_UNBLANK)\r\nlevel = 0;\r\nif (level != dcon->bl_val)\r\ndcon_set_backlight(dcon, level);\r\nreturn 0;\r\n}\r\nstatic int dcon_bl_get(struct backlight_device *dev)\r\n{\r\nstruct dcon_priv *dcon = bl_get_data(dev);\r\nreturn dcon->bl_val;\r\n}\r\nstatic int dcon_reboot_notify(struct notifier_block *nb,\r\nunsigned long foo, void *bar)\r\n{\r\nstruct dcon_priv *dcon = container_of(nb, struct dcon_priv, reboot_nb);\r\nif (!dcon || !dcon->client)\r\nreturn 0;\r\ndcon_write(dcon, DCON_REG_MODE, 0x39);\r\ndcon_write(dcon, DCON_REG_MODE, 0x32);\r\nreturn 0;\r\n}\r\nstatic int unfreeze_on_panic(struct notifier_block *nb,\r\nunsigned long e, void *p)\r\n{\r\npdata->set_dconload(1);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int dcon_fb_notifier(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nstruct fb_event *evdata = data;\r\nstruct dcon_priv *dcon = container_of(self, struct dcon_priv,\r\nfbevent_nb);\r\nint *blank = (int *) evdata->data;\r\nif (((event != FB_EVENT_BLANK) && (event != FB_EVENT_CONBLANK)) ||\r\ndcon->ignore_fb_events)\r\nreturn 0;\r\ndcon_sleep(dcon, *blank ? true : false);\r\nreturn 0;\r\n}\r\nstatic int dcon_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nstrlcpy(info->type, "olpc_dcon", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int dcon_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct dcon_priv *dcon;\r\nint rc, i, j;\r\nif (!pdata)\r\nreturn -ENXIO;\r\ndcon = kzalloc(sizeof(*dcon), GFP_KERNEL);\r\nif (!dcon)\r\nreturn -ENOMEM;\r\ndcon->client = client;\r\nINIT_WORK(&dcon->switch_source, dcon_source_switch);\r\ndcon->reboot_nb.notifier_call = dcon_reboot_notify;\r\ndcon->reboot_nb.priority = -1;\r\ndcon->fbevent_nb.notifier_call = dcon_fb_notifier;\r\ni2c_set_clientdata(client, dcon);\r\nif (num_registered_fb < 1) {\r\ndev_err(&client->dev, "DCON driver requires a registered fb\n");\r\nrc = -EIO;\r\ngoto einit;\r\n}\r\ndcon->fbinfo = registered_fb[0];\r\nrc = dcon_hw_init(dcon, 1);\r\nif (rc)\r\ngoto einit;\r\ndcon_device = platform_device_alloc("dcon", -1);\r\nif (dcon_device == NULL) {\r\nprintk(KERN_ERR "dcon: Unable to create the DCON device\n");\r\nrc = -ENOMEM;\r\ngoto eirq;\r\n}\r\nrc = platform_device_add(dcon_device);\r\nplatform_set_drvdata(dcon_device, dcon);\r\nif (rc) {\r\nprintk(KERN_ERR "dcon: Unable to add the DCON device\n");\r\ngoto edev;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(dcon_device_files); i++) {\r\nrc = device_create_file(&dcon_device->dev,\r\n&dcon_device_files[i]);\r\nif (rc) {\r\ndev_err(&dcon_device->dev, "Cannot create sysfs file\n");\r\ngoto ecreate;\r\n}\r\n}\r\ndcon->bl_val = dcon_read(dcon, DCON_REG_BRIGHT) & 0x0F;\r\ndcon_bl_props.brightness = dcon->bl_val;\r\ndcon->bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,\r\ndcon, &dcon_bl_ops, &dcon_bl_props);\r\nif (IS_ERR(dcon->bl_dev)) {\r\ndev_err(&client->dev, "cannot register backlight dev (%ld)\n",\r\nPTR_ERR(dcon->bl_dev));\r\ndcon->bl_dev = NULL;\r\n}\r\nregister_reboot_notifier(&dcon->reboot_nb);\r\natomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);\r\nfb_register_client(&dcon->fbevent_nb);\r\nreturn 0;\r\necreate:\r\nfor (j = 0; j < i; j++)\r\ndevice_remove_file(&dcon_device->dev, &dcon_device_files[j]);\r\nedev:\r\nplatform_device_unregister(dcon_device);\r\ndcon_device = NULL;\r\neirq:\r\nfree_irq(DCON_IRQ, dcon);\r\neinit:\r\ni2c_set_clientdata(client, NULL);\r\nkfree(dcon);\r\nreturn rc;\r\n}\r\nstatic int dcon_remove(struct i2c_client *client)\r\n{\r\nstruct dcon_priv *dcon = i2c_get_clientdata(client);\r\ni2c_set_clientdata(client, NULL);\r\nfb_unregister_client(&dcon->fbevent_nb);\r\nunregister_reboot_notifier(&dcon->reboot_nb);\r\natomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);\r\nfree_irq(DCON_IRQ, dcon);\r\nif (dcon->bl_dev)\r\nbacklight_device_unregister(dcon->bl_dev);\r\nif (dcon_device != NULL)\r\nplatform_device_unregister(dcon_device);\r\ncancel_work_sync(&dcon->switch_source);\r\nkfree(dcon);\r\nreturn 0;\r\n}\r\nstatic int dcon_suspend(struct i2c_client *client, pm_message_t state)\r\n{\r\nstruct dcon_priv *dcon = i2c_get_clientdata(client);\r\nif (!dcon->asleep) {\r\ndcon_set_source_sync(dcon, DCON_SOURCE_DCON);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dcon_resume(struct i2c_client *client)\r\n{\r\nstruct dcon_priv *dcon = i2c_get_clientdata(client);\r\nif (!dcon->asleep) {\r\ndcon_bus_stabilize(dcon, 0);\r\ndcon_set_source(dcon, DCON_SOURCE_CPU);\r\n}\r\nreturn 0;\r\n}\r\nirqreturn_t dcon_interrupt(int irq, void *id)\r\n{\r\nstruct dcon_priv *dcon = id;\r\nint status = pdata->read_status();\r\nif (status == -1)\r\nreturn IRQ_NONE;\r\nswitch (status & 3) {\r\ncase 3:\r\nprintk(KERN_DEBUG "olpc-dcon: DCONLOAD_MISSED interrupt\n");\r\nbreak;\r\ncase 2:\r\ncase 1:\r\ndcon->switched = true;\r\ngetnstimeofday(&dcon->irq_time);\r\nwake_up(&dcon_wait_queue);\r\nbreak;\r\ncase 0:\r\nif (dcon->curr_src != dcon->pending_src && !dcon->switched) {\r\ndcon->switched = true;\r\ngetnstimeofday(&dcon->irq_time);\r\nwake_up(&dcon_wait_queue);\r\nprintk(KERN_DEBUG "olpc-dcon: switching w/ status 0/0\n");\r\n} else {\r\nprintk(KERN_DEBUG "olpc-dcon: scanline interrupt w/CPU\n");\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init olpc_dcon_init(void)\r\n{\r\n#ifdef CONFIG_FB_OLPC_DCON_1_5\r\nif (olpc_board_at_least(olpc_board(0xd0)))\r\npdata = &dcon_pdata_xo_1_5;\r\n#endif\r\n#ifdef CONFIG_FB_OLPC_DCON_1\r\nif (!pdata)\r\npdata = &dcon_pdata_xo_1;\r\n#endif\r\nreturn i2c_add_driver(&dcon_driver);\r\n}\r\nstatic void __exit olpc_dcon_exit(void)\r\n{\r\ni2c_del_driver(&dcon_driver);\r\n}
