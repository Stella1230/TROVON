static int media_device_open(struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int media_device_close(struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int media_device_get_info(struct media_device *dev,\r\nstruct media_device_info __user *__info)\r\n{\r\nstruct media_device_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.driver, dev->dev->driver->name, sizeof(info.driver));\r\nstrlcpy(info.model, dev->model, sizeof(info.model));\r\nstrlcpy(info.serial, dev->serial, sizeof(info.serial));\r\nstrlcpy(info.bus_info, dev->bus_info, sizeof(info.bus_info));\r\ninfo.media_version = MEDIA_API_VERSION;\r\ninfo.hw_revision = dev->hw_revision;\r\ninfo.driver_version = dev->driver_version;\r\nreturn copy_to_user(__info, &info, sizeof(*__info));\r\n}\r\nstatic struct media_entity *find_entity(struct media_device *mdev, u32 id)\r\n{\r\nstruct media_entity *entity;\r\nint next = id & MEDIA_ENT_ID_FLAG_NEXT;\r\nid &= ~MEDIA_ENT_ID_FLAG_NEXT;\r\nspin_lock(&mdev->lock);\r\nmedia_device_for_each_entity(entity, mdev) {\r\nif ((entity->id == id && !next) ||\r\n(entity->id > id && next)) {\r\nspin_unlock(&mdev->lock);\r\nreturn entity;\r\n}\r\n}\r\nspin_unlock(&mdev->lock);\r\nreturn NULL;\r\n}\r\nstatic long media_device_enum_entities(struct media_device *mdev,\r\nstruct media_entity_desc __user *uent)\r\n{\r\nstruct media_entity *ent;\r\nstruct media_entity_desc u_ent;\r\nif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\r\nreturn -EFAULT;\r\nent = find_entity(mdev, u_ent.id);\r\nif (ent == NULL)\r\nreturn -EINVAL;\r\nu_ent.id = ent->id;\r\nu_ent.name[0] = '\0';\r\nif (ent->name)\r\nstrlcpy(u_ent.name, ent->name, sizeof(u_ent.name));\r\nu_ent.type = ent->type;\r\nu_ent.revision = ent->revision;\r\nu_ent.flags = ent->flags;\r\nu_ent.group_id = ent->group_id;\r\nu_ent.pads = ent->num_pads;\r\nu_ent.links = ent->num_links - ent->num_backlinks;\r\nu_ent.v4l.major = ent->v4l.major;\r\nu_ent.v4l.minor = ent->v4l.minor;\r\nif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void media_device_kpad_to_upad(const struct media_pad *kpad,\r\nstruct media_pad_desc *upad)\r\n{\r\nupad->entity = kpad->entity->id;\r\nupad->index = kpad->index;\r\nupad->flags = kpad->flags;\r\n}\r\nstatic long media_device_enum_links(struct media_device *mdev,\r\nstruct media_links_enum __user *ulinks)\r\n{\r\nstruct media_entity *entity;\r\nstruct media_links_enum links;\r\nif (copy_from_user(&links, ulinks, sizeof(links)))\r\nreturn -EFAULT;\r\nentity = find_entity(mdev, links.entity);\r\nif (entity == NULL)\r\nreturn -EINVAL;\r\nif (links.pads) {\r\nunsigned int p;\r\nfor (p = 0; p < entity->num_pads; p++) {\r\nstruct media_pad_desc pad;\r\nmedia_device_kpad_to_upad(&entity->pads[p], &pad);\r\nif (copy_to_user(&links.pads[p], &pad, sizeof(pad)))\r\nreturn -EFAULT;\r\n}\r\n}\r\nif (links.links) {\r\nstruct media_link_desc __user *ulink;\r\nunsigned int l;\r\nfor (l = 0, ulink = links.links; l < entity->num_links; l++) {\r\nstruct media_link_desc link;\r\nif (entity->links[l].source->entity != entity)\r\ncontinue;\r\nmedia_device_kpad_to_upad(entity->links[l].source,\r\n&link.source);\r\nmedia_device_kpad_to_upad(entity->links[l].sink,\r\n&link.sink);\r\nlink.flags = entity->links[l].flags;\r\nif (copy_to_user(ulink, &link, sizeof(*ulink)))\r\nreturn -EFAULT;\r\nulink++;\r\n}\r\n}\r\nif (copy_to_user(ulinks, &links, sizeof(*ulinks)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long media_device_setup_link(struct media_device *mdev,\r\nstruct media_link_desc __user *_ulink)\r\n{\r\nstruct media_link *link = NULL;\r\nstruct media_link_desc ulink;\r\nstruct media_entity *source;\r\nstruct media_entity *sink;\r\nint ret;\r\nif (copy_from_user(&ulink, _ulink, sizeof(ulink)))\r\nreturn -EFAULT;\r\nsource = find_entity(mdev, ulink.source.entity);\r\nsink = find_entity(mdev, ulink.sink.entity);\r\nif (source == NULL || sink == NULL)\r\nreturn -EINVAL;\r\nif (ulink.source.index >= source->num_pads ||\r\nulink.sink.index >= sink->num_pads)\r\nreturn -EINVAL;\r\nlink = media_entity_find_link(&source->pads[ulink.source.index],\r\n&sink->pads[ulink.sink.index]);\r\nif (link == NULL)\r\nreturn -EINVAL;\r\nret = __media_entity_setup_link(link, ulink.flags);\r\nif (copy_to_user(_ulink, &ulink, sizeof(ulink)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic long media_device_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nstruct media_device *dev = to_media_device(devnode);\r\nlong ret;\r\nswitch (cmd) {\r\ncase MEDIA_IOC_DEVICE_INFO:\r\nret = media_device_get_info(dev,\r\n(struct media_device_info __user *)arg);\r\nbreak;\r\ncase MEDIA_IOC_ENUM_ENTITIES:\r\nret = media_device_enum_entities(dev,\r\n(struct media_entity_desc __user *)arg);\r\nbreak;\r\ncase MEDIA_IOC_ENUM_LINKS:\r\nmutex_lock(&dev->graph_mutex);\r\nret = media_device_enum_links(dev,\r\n(struct media_links_enum __user *)arg);\r\nmutex_unlock(&dev->graph_mutex);\r\nbreak;\r\ncase MEDIA_IOC_SETUP_LINK:\r\nmutex_lock(&dev->graph_mutex);\r\nret = media_device_setup_link(dev,\r\n(struct media_link_desc __user *)arg);\r\nmutex_unlock(&dev->graph_mutex);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t show_model(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct media_device *mdev = to_media_device(to_media_devnode(cd));\r\nreturn sprintf(buf, "%.*s\n", (int)sizeof(mdev->model), mdev->model);\r\n}\r\nstatic void media_device_release(struct media_devnode *mdev)\r\n{\r\n}\r\nint __must_check media_device_register(struct media_device *mdev)\r\n{\r\nint ret;\r\nif (WARN_ON(mdev->dev == NULL || mdev->model[0] == 0))\r\nreturn -EINVAL;\r\nmdev->entity_id = 1;\r\nINIT_LIST_HEAD(&mdev->entities);\r\nspin_lock_init(&mdev->lock);\r\nmutex_init(&mdev->graph_mutex);\r\nmdev->devnode.fops = &media_device_fops;\r\nmdev->devnode.parent = mdev->dev;\r\nmdev->devnode.release = media_device_release;\r\nret = media_devnode_register(&mdev->devnode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = device_create_file(&mdev->devnode.dev, &dev_attr_model);\r\nif (ret < 0) {\r\nmedia_devnode_unregister(&mdev->devnode);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid media_device_unregister(struct media_device *mdev)\r\n{\r\nstruct media_entity *entity;\r\nstruct media_entity *next;\r\nlist_for_each_entry_safe(entity, next, &mdev->entities, list)\r\nmedia_device_unregister_entity(entity);\r\ndevice_remove_file(&mdev->devnode.dev, &dev_attr_model);\r\nmedia_devnode_unregister(&mdev->devnode);\r\n}\r\nint __must_check media_device_register_entity(struct media_device *mdev,\r\nstruct media_entity *entity)\r\n{\r\nWARN_ON(entity->parent != NULL);\r\nentity->parent = mdev;\r\nspin_lock(&mdev->lock);\r\nif (entity->id == 0)\r\nentity->id = mdev->entity_id++;\r\nelse\r\nmdev->entity_id = max(entity->id + 1, mdev->entity_id);\r\nlist_add_tail(&entity->list, &mdev->entities);\r\nspin_unlock(&mdev->lock);\r\nreturn 0;\r\n}\r\nvoid media_device_unregister_entity(struct media_entity *entity)\r\n{\r\nstruct media_device *mdev = entity->parent;\r\nif (mdev == NULL)\r\nreturn;\r\nspin_lock(&mdev->lock);\r\nlist_del(&entity->list);\r\nspin_unlock(&mdev->lock);\r\nentity->parent = NULL;\r\n}
