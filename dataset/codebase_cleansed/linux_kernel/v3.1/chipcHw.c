chipcHw_freq chipcHw_getClockFrequency(chipcHw_CLOCK_e clock\r\n) {\r\nvolatile uint32_t *pPLLReg = (uint32_t *) 0x0;\r\nvolatile uint32_t *pClockCtrl = (uint32_t *) 0x0;\r\nvolatile uint32_t *pDependentClock = (uint32_t *) 0x0;\r\nuint32_t vcoFreqPll1Hz = 0;\r\nuint32_t vcoFreqPll2Hz = 0;\r\nuint32_t dependentClockType = 0;\r\nuint32_t vcoHz = 0;\r\nif ((pChipcHw->PLLPreDivider & chipcHw_REG_PLL_PREDIVIDER_NDIV_MODE_MASK) != chipcHw_REG_PLL_PREDIVIDER_NDIV_MODE_INTEGER) {\r\nuint64_t adjustFreq = 0;\r\nvcoFreqPll1Hz = chipcHw_XTAL_FREQ_Hz *\r\nchipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, chipcHw_REG_PLL_PREDIVIDER_P2) *\r\n((pChipcHw->PLLPreDivider & chipcHw_REG_PLL_PREDIVIDER_NDIV_MASK) >>\r\nchipcHw_REG_PLL_PREDIVIDER_NDIV_SHIFT);\r\nadjustFreq = (uint64_t) chipcHw_XTAL_FREQ_Hz *\r\n(uint64_t) chipcHw_REG_PLL_DIVIDER_NDIV_f_SS *\r\nchipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, (chipcHw_REG_PLL_PREDIVIDER_P2 * (uint64_t) chipcHw_REG_PLL_DIVIDER_FRAC));\r\nvcoFreqPll1Hz += (uint32_t) adjustFreq;\r\n} else {\r\nvcoFreqPll1Hz = chipcHw_XTAL_FREQ_Hz *\r\nchipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, chipcHw_REG_PLL_PREDIVIDER_P2) *\r\n((pChipcHw->PLLPreDivider & chipcHw_REG_PLL_PREDIVIDER_NDIV_MASK) >>\r\nchipcHw_REG_PLL_PREDIVIDER_NDIV_SHIFT);\r\n}\r\nvcoFreqPll2Hz =\r\nchipcHw_XTAL_FREQ_Hz *\r\nchipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, chipcHw_REG_PLL_PREDIVIDER_P2) *\r\n((pChipcHw->PLLPreDivider2 & chipcHw_REG_PLL_PREDIVIDER_NDIV_MASK) >>\r\nchipcHw_REG_PLL_PREDIVIDER_NDIV_SHIFT);\r\nswitch (clock) {\r\ncase chipcHw_CLOCK_DDR:\r\npPLLReg = &pChipcHw->DDRClock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_ARM:\r\npPLLReg = &pChipcHw->ARMClock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_ESW:\r\npPLLReg = &pChipcHw->ESWClock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_VPM:\r\npPLLReg = &pChipcHw->VPMClock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_ESW125:\r\npPLLReg = &pChipcHw->ESW125Clock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_UART:\r\npPLLReg = &pChipcHw->UARTClock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_SDIO0:\r\npPLLReg = &pChipcHw->SDIO0Clock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_SDIO1:\r\npPLLReg = &pChipcHw->SDIO1Clock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_SPI:\r\npPLLReg = &pChipcHw->SPIClock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_ETM:\r\npPLLReg = &pChipcHw->ETMClock;\r\nvcoHz = vcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_USB:\r\npPLLReg = &pChipcHw->USBClock;\r\nvcoHz = vcoFreqPll2Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_LCD:\r\npPLLReg = &pChipcHw->LCDClock;\r\nvcoHz = vcoFreqPll2Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_APM:\r\npPLLReg = &pChipcHw->APMClock;\r\nvcoHz = vcoFreqPll2Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_BUS:\r\npClockCtrl = &pChipcHw->ACLKClock;\r\npDependentClock = &pChipcHw->ARMClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndependentClockType = PLL_CLOCK;\r\nbreak;\r\ncase chipcHw_CLOCK_OTP:\r\npClockCtrl = &pChipcHw->OTPClock;\r\nbreak;\r\ncase chipcHw_CLOCK_I2C:\r\npClockCtrl = &pChipcHw->I2CClock;\r\nbreak;\r\ncase chipcHw_CLOCK_I2S0:\r\npClockCtrl = &pChipcHw->I2S0Clock;\r\nbreak;\r\ncase chipcHw_CLOCK_RTBUS:\r\npClockCtrl = &pChipcHw->RTBUSClock;\r\npDependentClock = &pChipcHw->ACLKClock;\r\ndependentClockType = NON_PLL_CLOCK;\r\nbreak;\r\ncase chipcHw_CLOCK_APM100:\r\npClockCtrl = &pChipcHw->APM100Clock;\r\npDependentClock = &pChipcHw->APMClock;\r\nvcoHz = vcoFreqPll2Hz;\r\ndependentClockType = PLL_CLOCK;\r\nbreak;\r\ncase chipcHw_CLOCK_TSC:\r\npClockCtrl = &pChipcHw->TSCClock;\r\nbreak;\r\ncase chipcHw_CLOCK_LED:\r\npClockCtrl = &pChipcHw->LEDClock;\r\nbreak;\r\ncase chipcHw_CLOCK_I2S1:\r\npClockCtrl = &pChipcHw->I2S1Clock;\r\nbreak;\r\n}\r\nif (pPLLReg) {\r\nif (*pPLLReg & chipcHw_REG_PLL_CLOCK_BYPASS_SELECT) {\r\nreturn chipcHw_XTAL_FREQ_Hz;\r\n} else if (clock == chipcHw_CLOCK_DDR) {\r\nreturn chipcHw_divide (vcoHz, (((pChipcHw->PLLDivider & 0xFF000000) >> 24) ? ((pChipcHw->PLLDivider & 0xFF000000) >> 24) : 256));\r\n} else {\r\nif ((pPLLReg == &pChipcHw->LCDClock) && (chipcHw_getChipRevisionNumber() != chipcHw_REV_NUMBER_A0)) {\r\nvcoHz >>= 1;\r\n}\r\nreturn chipcHw_divide(vcoHz, ((*pPLLReg & chipcHw_REG_PLL_CLOCK_MDIV_MASK) ? (*pPLLReg & chipcHw_REG_PLL_CLOCK_MDIV_MASK) : 256));\r\n}\r\n} else if (pClockCtrl) {\r\nuint32_t div;\r\nuint32_t freq = 0;\r\nif (*pClockCtrl & chipcHw_REG_DIV_CLOCK_BYPASS_SELECT) {\r\nreturn chipcHw_XTAL_FREQ_Hz;\r\n} else if (pDependentClock) {\r\nswitch (dependentClockType) {\r\ncase PLL_CLOCK:\r\nif (*pDependentClock & chipcHw_REG_PLL_CLOCK_BYPASS_SELECT) {\r\nfreq = chipcHw_XTAL_FREQ_Hz;\r\n} else {\r\ndiv = *pDependentClock & chipcHw_REG_PLL_CLOCK_MDIV_MASK;\r\nfreq = div ? chipcHw_divide(vcoHz, div) : 0;\r\n}\r\nbreak;\r\ncase NON_PLL_CLOCK:\r\nif (pDependentClock == (uint32_t *) &pChipcHw->ACLKClock) {\r\nfreq = chipcHw_getClockFrequency (chipcHw_CLOCK_BUS);\r\n} else {\r\nif (*pDependentClock & chipcHw_REG_DIV_CLOCK_BYPASS_SELECT) {\r\nfreq = chipcHw_XTAL_FREQ_Hz;\r\n} else {\r\ndiv = *pDependentClock & chipcHw_REG_DIV_CLOCK_DIV_MASK;\r\nfreq = chipcHw_divide (chipcHw_XTAL_FREQ_Hz, (div ? div : 256));\r\n}\r\n}\r\nbreak;\r\n}\r\n} else {\r\nfreq = chipcHw_XTAL_FREQ_Hz;\r\n}\r\ndiv = *pClockCtrl & chipcHw_REG_DIV_CLOCK_DIV_MASK;\r\nreturn chipcHw_divide(freq, (div ? div : 256));\r\n}\r\nreturn 0;\r\n}\r\nchipcHw_freq chipcHw_setClockFrequency(chipcHw_CLOCK_e clock,\r\nuint32_t freq\r\n) {\r\nvolatile uint32_t *pPLLReg = (uint32_t *) 0x0;\r\nvolatile uint32_t *pClockCtrl = (uint32_t *) 0x0;\r\nvolatile uint32_t *pDependentClock = (uint32_t *) 0x0;\r\nuint32_t vcoFreqPll1Hz = 0;\r\nuint32_t desVcoFreqPll1Hz = 0;\r\nuint32_t vcoFreqPll2Hz = 0;\r\nuint32_t dependentClockType = 0;\r\nuint32_t vcoHz = 0;\r\nuint32_t desVcoHz = 0;\r\nif ((pChipcHw->PLLPreDivider & chipcHw_REG_PLL_PREDIVIDER_NDIV_MODE_MASK) != chipcHw_REG_PLL_PREDIVIDER_NDIV_MODE_INTEGER) {\r\nuint64_t adjustFreq = 0;\r\nvcoFreqPll1Hz = chipcHw_XTAL_FREQ_Hz *\r\nchipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, chipcHw_REG_PLL_PREDIVIDER_P2) *\r\n((pChipcHw->PLLPreDivider & chipcHw_REG_PLL_PREDIVIDER_NDIV_MASK) >>\r\nchipcHw_REG_PLL_PREDIVIDER_NDIV_SHIFT);\r\nadjustFreq = (uint64_t) chipcHw_XTAL_FREQ_Hz *\r\n(uint64_t) chipcHw_REG_PLL_DIVIDER_NDIV_f_SS *\r\nchipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, (chipcHw_REG_PLL_PREDIVIDER_P2 * (uint64_t) chipcHw_REG_PLL_DIVIDER_FRAC));\r\nvcoFreqPll1Hz += (uint32_t) adjustFreq;\r\ndesVcoFreqPll1Hz = chipcHw_XTAL_FREQ_Hz *\r\nchipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, chipcHw_REG_PLL_PREDIVIDER_P2) *\r\n(((pChipcHw->PLLPreDivider & chipcHw_REG_PLL_PREDIVIDER_NDIV_MASK) >>\r\nchipcHw_REG_PLL_PREDIVIDER_NDIV_SHIFT) + 1);\r\n} else {\r\nvcoFreqPll1Hz = desVcoFreqPll1Hz = chipcHw_XTAL_FREQ_Hz *\r\nchipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, chipcHw_REG_PLL_PREDIVIDER_P2) *\r\n((pChipcHw->PLLPreDivider & chipcHw_REG_PLL_PREDIVIDER_NDIV_MASK) >>\r\nchipcHw_REG_PLL_PREDIVIDER_NDIV_SHIFT);\r\n}\r\nvcoFreqPll2Hz = chipcHw_XTAL_FREQ_Hz * chipcHw_divide(chipcHw_REG_PLL_PREDIVIDER_P1, chipcHw_REG_PLL_PREDIVIDER_P2) *\r\n((pChipcHw->PLLPreDivider2 & chipcHw_REG_PLL_PREDIVIDER_NDIV_MASK) >>\r\nchipcHw_REG_PLL_PREDIVIDER_NDIV_SHIFT);\r\nswitch (clock) {\r\ncase chipcHw_CLOCK_DDR:\r\n{\r\nREG_LOCAL_IRQ_SAVE;\r\npChipcHw->DDRClock = (pChipcHw->DDRClock & ~chipcHw_REG_PLL_CLOCK_TO_BUS_RATIO_MASK) | ((((freq / 2) / chipcHw_getClockFrequency(chipcHw_CLOCK_BUS)) - 1)\r\n<< chipcHw_REG_PLL_CLOCK_TO_BUS_RATIO_SHIFT);\r\nREG_LOCAL_IRQ_RESTORE;\r\n}\r\npPLLReg = &pChipcHw->DDRClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_ARM:\r\npPLLReg = &pChipcHw->ARMClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_ESW:\r\npPLLReg = &pChipcHw->ESWClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_VPM:\r\n{\r\nREG_LOCAL_IRQ_SAVE;\r\npChipcHw->VPMClock = (pChipcHw->VPMClock & ~chipcHw_REG_PLL_CLOCK_TO_BUS_RATIO_MASK) | ((chipcHw_divide (freq, chipcHw_getClockFrequency(chipcHw_CLOCK_BUS)) - 1)\r\n<< chipcHw_REG_PLL_CLOCK_TO_BUS_RATIO_SHIFT);\r\nREG_LOCAL_IRQ_RESTORE;\r\n}\r\npPLLReg = &pChipcHw->VPMClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_ESW125:\r\npPLLReg = &pChipcHw->ESW125Clock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_UART:\r\npPLLReg = &pChipcHw->UARTClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_SDIO0:\r\npPLLReg = &pChipcHw->SDIO0Clock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_SDIO1:\r\npPLLReg = &pChipcHw->SDIO1Clock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_SPI:\r\npPLLReg = &pChipcHw->SPIClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_ETM:\r\npPLLReg = &pChipcHw->ETMClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_USB:\r\npPLLReg = &pChipcHw->USBClock;\r\nvcoHz = vcoFreqPll2Hz;\r\ndesVcoHz = vcoFreqPll2Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_LCD:\r\npPLLReg = &pChipcHw->LCDClock;\r\nvcoHz = vcoFreqPll2Hz;\r\ndesVcoHz = vcoFreqPll2Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_APM:\r\npPLLReg = &pChipcHw->APMClock;\r\nvcoHz = vcoFreqPll2Hz;\r\ndesVcoHz = vcoFreqPll2Hz;\r\nbreak;\r\ncase chipcHw_CLOCK_BUS:\r\npClockCtrl = &pChipcHw->ACLKClock;\r\npDependentClock = &pChipcHw->ARMClock;\r\nvcoHz = vcoFreqPll1Hz;\r\ndesVcoHz = desVcoFreqPll1Hz;\r\ndependentClockType = PLL_CLOCK;\r\nbreak;\r\ncase chipcHw_CLOCK_OTP:\r\npClockCtrl = &pChipcHw->OTPClock;\r\nbreak;\r\ncase chipcHw_CLOCK_I2C:\r\npClockCtrl = &pChipcHw->I2CClock;\r\nbreak;\r\ncase chipcHw_CLOCK_I2S0:\r\npClockCtrl = &pChipcHw->I2S0Clock;\r\nbreak;\r\ncase chipcHw_CLOCK_RTBUS:\r\npClockCtrl = &pChipcHw->RTBUSClock;\r\npDependentClock = &pChipcHw->ACLKClock;\r\ndependentClockType = NON_PLL_CLOCK;\r\nbreak;\r\ncase chipcHw_CLOCK_APM100:\r\npClockCtrl = &pChipcHw->APM100Clock;\r\npDependentClock = &pChipcHw->APMClock;\r\nvcoHz = vcoFreqPll2Hz;\r\ndesVcoHz = vcoFreqPll2Hz;\r\ndependentClockType = PLL_CLOCK;\r\nbreak;\r\ncase chipcHw_CLOCK_TSC:\r\npClockCtrl = &pChipcHw->TSCClock;\r\nbreak;\r\ncase chipcHw_CLOCK_LED:\r\npClockCtrl = &pChipcHw->LEDClock;\r\nbreak;\r\ncase chipcHw_CLOCK_I2S1:\r\npClockCtrl = &pChipcHw->I2S1Clock;\r\nbreak;\r\n}\r\nif (pPLLReg) {\r\nreg32_modify_and(pPLLReg, ~chipcHw_REG_PLL_CLOCK_SOURCE_GPIO);\r\nreg32_modify_or(pPLLReg, chipcHw_REG_PLL_CLOCK_BYPASS_SELECT);\r\nif (pPLLReg == &pChipcHw->DDRClock) {\r\nreg32_write(&pChipcHw->PLLDivider, (pChipcHw->PLLDivider & 0x00FFFFFF) | ((chipcHw_REG_PLL_DIVIDER_MDIV (desVcoHz, freq)) << 24));\r\nfreq = chipcHw_divide(vcoHz, (((pChipcHw->PLLDivider & 0xFF000000) >> 24) ? ((pChipcHw->PLLDivider & 0xFF000000) >> 24) : 256));\r\n} else {\r\nif ((pPLLReg == &pChipcHw->LCDClock) && (chipcHw_getChipRevisionNumber() != chipcHw_REV_NUMBER_A0)) {\r\ndesVcoHz >>= 1;\r\nvcoHz >>= 1;\r\n}\r\nreg32_modify_and(pPLLReg, ~(chipcHw_REG_PLL_CLOCK_MDIV_MASK));\r\nreg32_modify_or(pPLLReg, chipcHw_REG_PLL_DIVIDER_MDIV(desVcoHz, freq));\r\nfreq = chipcHw_divide(vcoHz, ((*(pPLLReg) & chipcHw_REG_PLL_CLOCK_MDIV_MASK) ? (*(pPLLReg) & chipcHw_REG_PLL_CLOCK_MDIV_MASK) : 256));\r\n}\r\nudelay(1);\r\nreg32_modify_and(pPLLReg, ~chipcHw_REG_PLL_CLOCK_BYPASS_SELECT);\r\nreturn freq;\r\n} else if (pClockCtrl) {\r\nuint32_t divider = 0;\r\nreg32_modify_and(pClockCtrl,\r\n~chipcHw_REG_DIV_CLOCK_BYPASS_SELECT);\r\nif (pDependentClock) {\r\nswitch (dependentClockType) {\r\ncase PLL_CLOCK:\r\ndivider = chipcHw_divide(chipcHw_divide (desVcoHz, (*pDependentClock & chipcHw_REG_PLL_CLOCK_MDIV_MASK)), freq);\r\nbreak;\r\ncase NON_PLL_CLOCK:\r\n{\r\nuint32_t sourceClock = 0;\r\nif (pDependentClock == (uint32_t *) &pChipcHw->ACLKClock) {\r\nsourceClock = chipcHw_getClockFrequency (chipcHw_CLOCK_BUS);\r\n} else {\r\nuint32_t div = *pDependentClock & chipcHw_REG_DIV_CLOCK_DIV_MASK;\r\nsourceClock = chipcHw_divide (chipcHw_XTAL_FREQ_Hz, ((div) ? div : 256));\r\n}\r\ndivider = chipcHw_divide(sourceClock, freq);\r\n}\r\nbreak;\r\n}\r\n} else {\r\ndivider = chipcHw_divide(chipcHw_XTAL_FREQ_Hz, freq);\r\n}\r\nif (divider) {\r\nREG_LOCAL_IRQ_SAVE;\r\n*pClockCtrl = (*pClockCtrl & (~chipcHw_REG_DIV_CLOCK_DIV_MASK)) | (((divider > 256) ? chipcHw_REG_DIV_CLOCK_DIV_256 : divider) & chipcHw_REG_DIV_CLOCK_DIV_MASK);\r\nREG_LOCAL_IRQ_RESTORE;\r\nreturn freq;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpmPhaseAlignA0(void)\r\n{\r\nuint32_t phaseControl;\r\nuint32_t phaseValue;\r\nuint32_t prevPhaseComp;\r\nint iter = 0;\r\nint adjustCount = 0;\r\nint count = 0;\r\nfor (iter = 0; (iter < MAX_PHASE_ALIGN_ATTEMPTS) && (adjustCount < MAX_PHASE_ADJUST_COUNT); iter++) {\r\nphaseControl = (pChipcHw->VPMClock & chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_MASK) >> chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT;\r\nphaseValue = 0;\r\nprevPhaseComp = 0;\r\nphaseValue = pChipcHw->VPMClock;\r\ndo {\r\nprevPhaseComp = phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP;\r\nreg32_write(&pChipcHw->VPMClock, (pChipcHw->VPMClock & (~chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_MASK)) | (phaseControl << chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT));\r\nudelay(1);\r\npChipcHw->VPMClock ^= chipcHw_REG_PLL_CLOCK_PHASE_UPDATE_ENABLE;\r\nphaseValue = pChipcHw->VPMClock;\r\nif ((phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP) == 0x0) {\r\nphaseControl = (0x3F & (phaseControl - 1));\r\n} else {\r\nphaseControl = (0x3F & (phaseControl + 1));\r\n}\r\nadjustCount++;\r\n} while (((prevPhaseComp == (phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP)) ||\r\n((phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP) != 0x0)) &&\r\n(adjustCount < MAX_PHASE_ADJUST_COUNT)\r\n);\r\nif (adjustCount >= MAX_PHASE_ADJUST_COUNT) {\r\nreturn -1;\r\n}\r\nfor (count = 0; (count < 5) && ((phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP) == 0); count++) {\r\nphaseControl = (0x3F & (phaseControl + 1));\r\nreg32_write(&pChipcHw->VPMClock, (pChipcHw->VPMClock & (~chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_MASK)) | (phaseControl << chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT));\r\nudelay(1);\r\npChipcHw->VPMClock ^= chipcHw_REG_PLL_CLOCK_PHASE_UPDATE_ENABLE;\r\nphaseValue = pChipcHw->VPMClock;\r\nadjustCount++;\r\n}\r\nif (adjustCount >= MAX_PHASE_ADJUST_COUNT) {\r\nreturn -1;\r\n}\r\nif (count != 5) {\r\ncontinue;\r\n}\r\nfor (count = 0; (count < 3) && ((phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP) == 0); count++) {\r\nphaseControl = (0x3F & (phaseControl - 1));\r\nreg32_write(&pChipcHw->VPMClock, (pChipcHw->VPMClock & (~chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_MASK)) | (phaseControl << chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT));\r\nudelay(1);\r\npChipcHw->VPMClock ^= chipcHw_REG_PLL_CLOCK_PHASE_UPDATE_ENABLE;\r\nphaseValue = pChipcHw->VPMClock;\r\nadjustCount++;\r\n}\r\nif (adjustCount >= MAX_PHASE_ADJUST_COUNT) {\r\nreturn -1;\r\n}\r\nif (count != 3) {\r\ncontinue;\r\n}\r\nfor (count = 0; (count < 5); count++) {\r\nphaseControl = (0x3F & (phaseControl - 1));\r\nreg32_write(&pChipcHw->VPMClock, (pChipcHw->VPMClock & (~chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_MASK)) | (phaseControl << chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT));\r\nudelay(1);\r\npChipcHw->VPMClock ^= chipcHw_REG_PLL_CLOCK_PHASE_UPDATE_ENABLE;\r\nphaseValue = pChipcHw->VPMClock;\r\nadjustCount++;\r\n}\r\nif (adjustCount >= MAX_PHASE_ADJUST_COUNT) {\r\nreturn -1;\r\n}\r\nif ((phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP) == 0) {\r\ncontinue;\r\n}\r\ndo {\r\nprevPhaseComp = phaseValue;\r\nreg32_write(&pChipcHw->VPMClock, (pChipcHw->VPMClock & (~chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_MASK)) | (phaseControl << chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT));\r\nudelay(1);\r\npChipcHw->VPMClock ^=\r\nchipcHw_REG_PLL_CLOCK_PHASE_UPDATE_ENABLE;\r\nphaseValue = pChipcHw->VPMClock;\r\nif ((phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP) == 0x0) {\r\nphaseControl = (0x3F & (phaseControl - 1));\r\n} else {\r\nphaseControl = (0x3F & (phaseControl + 1));\r\n}\r\nadjustCount++;\r\n} while (((prevPhaseComp == (phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP)) || ((phaseValue & chipcHw_REG_PLL_CLOCK_PHASE_COMP) != 0x0)) && (adjustCount < MAX_PHASE_ADJUST_COUNT));\r\nif (adjustCount >= MAX_PHASE_ADJUST_COUNT) {\r\nreturn -1;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nphaseControl = (((pChipcHw->VPMClock >> chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT) - 1) & 0x3F);\r\n{\r\nREG_LOCAL_IRQ_SAVE;\r\npChipcHw->VPMClock = (pChipcHw->VPMClock & ~chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_MASK) | (phaseControl << chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT);\r\npChipcHw->VPMClock ^= chipcHw_REG_PLL_CLOCK_PHASE_UPDATE_ENABLE;\r\nREG_LOCAL_IRQ_RESTORE;\r\n}\r\nreturn (int)adjustCount;\r\n}\r\nint chipcHw_vpmPhaseAlign(void)\r\n{\r\nif (chipcHw_getChipRevisionNumber() == chipcHw_REV_NUMBER_A0) {\r\nreturn vpmPhaseAlignA0();\r\n} else {\r\nuint32_t phaseControl = chipcHw_getVpmPhaseControl();\r\nuint32_t phaseValue = 0;\r\nint adjustCount = 0;\r\npChipcHw->Spare1 &= ~chipcHw_REG_SPARE1_VPM_BUS_ACCESS_ENABLE;\r\nchipcHw_vpmHwPhaseAlignDisable();\r\nchipcHw_vpmSwPhaseAlignEnable();\r\nwhile (adjustCount < MAX_PHASE_ADJUST_COUNT) {\r\nphaseValue = chipcHw_getVpmHwPhaseAlignStatus();\r\nif (phaseValue > 0xF) {\r\nphaseControl++;\r\n} else if (phaseValue < 0xF) {\r\nphaseControl--;\r\n} else {\r\npChipcHw->Spare1 |= chipcHw_REG_SPARE1_VPM_BUS_ACCESS_ENABLE;\r\nreturn adjustCount;\r\n}\r\nreg32_write(&pChipcHw->VPMClock, (pChipcHw->VPMClock & (~chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_MASK)) | (phaseControl << chipcHw_REG_PLL_CLOCK_PHASE_CONTROL_SHIFT));\r\nudelay(1);\r\npChipcHw->VPMClock ^= chipcHw_REG_PLL_CLOCK_PHASE_UPDATE_ENABLE;\r\nadjustCount++;\r\n}\r\n}\r\npChipcHw->Spare1 &= ~chipcHw_REG_SPARE1_VPM_BUS_ACCESS_ENABLE;\r\nreturn -1;\r\n}\r\nstatic int chipcHw_divide(int num, int denom)\r\n{\r\nint r;\r\nint t = 1;\r\nwhile ((denom & 0x40000000) == 0) {\r\ndenom = denom << 1;\r\nt = t << 1;\r\n}\r\nr = 0;\r\ndo {\r\nif ((num - denom) >= 0) {\r\nnum = num - denom;\r\nr = r + t;\r\n}\r\ndenom = denom >> 1;\r\nt = t >> 1;\r\n} while (t != 0);\r\nreturn r;\r\n}
