static unsigned long get_purr(void)\r\n{\r\nunsigned long sum_purr = 0;\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nif (firmware_has_feature(FW_FEATURE_ISERIES))\r\nsum_purr += lppaca_of(cpu).emulated_time_base;\r\nelse {\r\nstruct cpu_usage *cu;\r\ncu = &per_cpu(cpu_usage_array, cpu);\r\nsum_purr += cu->current_tb;\r\n}\r\n}\r\nreturn sum_purr;\r\n}\r\nstatic int iseries_lparcfg_data(struct seq_file *m, void *v)\r\n{\r\nunsigned long pool_id;\r\nint shared, entitled_capacity, max_entitled_capacity;\r\nint processors, max_processors;\r\nunsigned long purr = get_purr();\r\nshared = (int)(local_paca->lppaca_ptr->shared_proc);\r\nseq_printf(m, "system_active_processors=%d\n",\r\n(int)HvLpConfig_getSystemPhysicalProcessors());\r\nseq_printf(m, "system_potential_processors=%d\n",\r\n(int)HvLpConfig_getSystemPhysicalProcessors());\r\nprocessors = (int)HvLpConfig_getPhysicalProcessors();\r\nseq_printf(m, "partition_active_processors=%d\n", processors);\r\nmax_processors = (int)HvLpConfig_getMaxPhysicalProcessors();\r\nseq_printf(m, "partition_potential_processors=%d\n", max_processors);\r\nif (shared) {\r\nentitled_capacity = HvLpConfig_getSharedProcUnits();\r\nmax_entitled_capacity = HvLpConfig_getMaxSharedProcUnits();\r\n} else {\r\nentitled_capacity = processors * 100;\r\nmax_entitled_capacity = max_processors * 100;\r\n}\r\nseq_printf(m, "partition_entitled_capacity=%d\n", entitled_capacity);\r\nseq_printf(m, "partition_max_entitled_capacity=%d\n",\r\nmax_entitled_capacity);\r\nif (shared) {\r\npool_id = HvLpConfig_getSharedPoolIndex();\r\nseq_printf(m, "pool=%d\n", (int)pool_id);\r\nseq_printf(m, "pool_capacity=%d\n",\r\n(int)(HvLpConfig_getNumProcsInSharedPool(pool_id) *\r\n100));\r\nseq_printf(m, "purr=%ld\n", purr);\r\n}\r\nseq_printf(m, "shared_processor_mode=%d\n", shared);\r\nreturn 0;\r\n}\r\nstatic int iseries_lparcfg_data(struct seq_file *m, void *v)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int h_get_ppp(struct hvcall_ppp_data *ppp_data)\r\n{\r\nunsigned long rc;\r\nunsigned long retbuf[PLPAR_HCALL9_BUFSIZE];\r\nrc = plpar_hcall9(H_GET_PPP, retbuf);\r\nppp_data->entitlement = retbuf[0];\r\nppp_data->unallocated_entitlement = retbuf[1];\r\nppp_data->group_num = (retbuf[2] >> 2 * 8) & 0xffff;\r\nppp_data->pool_num = retbuf[2] & 0xffff;\r\nppp_data->capped = (retbuf[3] >> 6 * 8) & 0x01;\r\nppp_data->weight = (retbuf[3] >> 5 * 8) & 0xff;\r\nppp_data->unallocated_weight = (retbuf[3] >> 4 * 8) & 0xff;\r\nppp_data->active_procs_in_pool = (retbuf[3] >> 2 * 8) & 0xffff;\r\nppp_data->active_system_procs = retbuf[3] & 0xffff;\r\nppp_data->phys_platform_procs = retbuf[4] >> 6 * 8;\r\nppp_data->max_proc_cap_avail = (retbuf[4] >> 3 * 8) & 0xffffff;\r\nppp_data->entitled_proc_cap_avail = retbuf[4] & 0xffffff;\r\nreturn rc;\r\n}\r\nstatic unsigned h_pic(unsigned long *pool_idle_time,\r\nunsigned long *num_procs)\r\n{\r\nunsigned long rc;\r\nunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\r\nrc = plpar_hcall(H_PIC, retbuf);\r\n*pool_idle_time = retbuf[0];\r\n*num_procs = retbuf[1];\r\nreturn rc;\r\n}\r\nstatic void parse_ppp_data(struct seq_file *m)\r\n{\r\nstruct hvcall_ppp_data ppp_data;\r\nstruct device_node *root;\r\nconst int *perf_level;\r\nint rc;\r\nrc = h_get_ppp(&ppp_data);\r\nif (rc)\r\nreturn;\r\nseq_printf(m, "partition_entitled_capacity=%lld\n",\r\nppp_data.entitlement);\r\nseq_printf(m, "group=%d\n", ppp_data.group_num);\r\nseq_printf(m, "system_active_processors=%d\n",\r\nppp_data.active_system_procs);\r\nif (lppaca_of(0).shared_proc) {\r\nunsigned long pool_idle_time, pool_procs;\r\nseq_printf(m, "pool=%d\n", ppp_data.pool_num);\r\nseq_printf(m, "pool_capacity=%d\n",\r\nppp_data.active_procs_in_pool * 100);\r\nh_pic(&pool_idle_time, &pool_procs);\r\nseq_printf(m, "pool_idle_time=%ld\n", pool_idle_time);\r\nseq_printf(m, "pool_num_procs=%ld\n", pool_procs);\r\n}\r\nseq_printf(m, "unallocated_capacity_weight=%d\n",\r\nppp_data.unallocated_weight);\r\nseq_printf(m, "capacity_weight=%d\n", ppp_data.weight);\r\nseq_printf(m, "capped=%d\n", ppp_data.capped);\r\nseq_printf(m, "unallocated_capacity=%lld\n",\r\nppp_data.unallocated_entitlement);\r\nroot = of_find_node_by_path("/");\r\nif (root) {\r\nperf_level = of_get_property(root,\r\n"ibm,partition-performance-parameters-level",\r\nNULL);\r\nif (perf_level && (*perf_level >= 1)) {\r\nseq_printf(m,\r\n"physical_procs_allocated_to_virtualization=%d\n",\r\nppp_data.phys_platform_procs);\r\nseq_printf(m, "max_proc_capacity_available=%d\n",\r\nppp_data.max_proc_cap_avail);\r\nseq_printf(m, "entitled_proc_capacity_available=%d\n",\r\nppp_data.entitled_proc_cap_avail);\r\n}\r\nof_node_put(root);\r\n}\r\n}\r\nstatic void parse_mpp_data(struct seq_file *m)\r\n{\r\nstruct hvcall_mpp_data mpp_data;\r\nint rc;\r\nrc = h_get_mpp(&mpp_data);\r\nif (rc)\r\nreturn;\r\nseq_printf(m, "entitled_memory=%ld\n", mpp_data.entitled_mem);\r\nif (mpp_data.mapped_mem != -1)\r\nseq_printf(m, "mapped_entitled_memory=%ld\n",\r\nmpp_data.mapped_mem);\r\nseq_printf(m, "entitled_memory_group_number=%d\n", mpp_data.group_num);\r\nseq_printf(m, "entitled_memory_pool_number=%d\n", mpp_data.pool_num);\r\nseq_printf(m, "entitled_memory_weight=%d\n", mpp_data.mem_weight);\r\nseq_printf(m, "unallocated_entitled_memory_weight=%d\n",\r\nmpp_data.unallocated_mem_weight);\r\nseq_printf(m, "unallocated_io_mapping_entitlement=%ld\n",\r\nmpp_data.unallocated_entitlement);\r\nif (mpp_data.pool_size != -1)\r\nseq_printf(m, "entitled_memory_pool_size=%ld bytes\n",\r\nmpp_data.pool_size);\r\nseq_printf(m, "entitled_memory_loan_request=%ld\n",\r\nmpp_data.loan_request);\r\nseq_printf(m, "backing_memory=%ld bytes\n", mpp_data.backing_mem);\r\n}\r\nstatic void parse_mpp_x_data(struct seq_file *m)\r\n{\r\nstruct hvcall_mpp_x_data mpp_x_data;\r\nif (!firmware_has_feature(FW_FEATURE_XCMO))\r\nreturn;\r\nif (h_get_mpp_x(&mpp_x_data))\r\nreturn;\r\nseq_printf(m, "coalesced_bytes=%ld\n", mpp_x_data.coalesced_bytes);\r\nif (mpp_x_data.pool_coalesced_bytes)\r\nseq_printf(m, "pool_coalesced_bytes=%ld\n",\r\nmpp_x_data.pool_coalesced_bytes);\r\nif (mpp_x_data.pool_purr_cycles)\r\nseq_printf(m, "coalesce_pool_purr=%ld\n", mpp_x_data.pool_purr_cycles);\r\nif (mpp_x_data.pool_spurr_cycles)\r\nseq_printf(m, "coalesce_pool_spurr=%ld\n", mpp_x_data.pool_spurr_cycles);\r\n}\r\nstatic void parse_system_parameter_string(struct seq_file *m)\r\n{\r\nint call_status;\r\nunsigned char *local_buffer = kmalloc(SPLPAR_MAXLENGTH, GFP_KERNEL);\r\nif (!local_buffer) {\r\nprintk(KERN_ERR "%s %s kmalloc failure at line %d\n",\r\n__FILE__, __func__, __LINE__);\r\nreturn;\r\n}\r\nspin_lock(&rtas_data_buf_lock);\r\nmemset(rtas_data_buf, 0, SPLPAR_MAXLENGTH);\r\ncall_status = rtas_call(rtas_token("ibm,get-system-parameter"), 3, 1,\r\nNULL,\r\nSPLPAR_CHARACTERISTICS_TOKEN,\r\n__pa(rtas_data_buf),\r\nRTAS_DATA_BUF_SIZE);\r\nmemcpy(local_buffer, rtas_data_buf, SPLPAR_MAXLENGTH);\r\nspin_unlock(&rtas_data_buf_lock);\r\nif (call_status != 0) {\r\nprintk(KERN_INFO\r\n"%s %s Error calling get-system-parameter (0x%x)\n",\r\n__FILE__, __func__, call_status);\r\n} else {\r\nint splpar_strlen;\r\nint idx, w_idx;\r\nchar *workbuffer = kzalloc(SPLPAR_MAXLENGTH, GFP_KERNEL);\r\nif (!workbuffer) {\r\nprintk(KERN_ERR "%s %s kmalloc failure at line %d\n",\r\n__FILE__, __func__, __LINE__);\r\nkfree(local_buffer);\r\nreturn;\r\n}\r\n#ifdef LPARCFG_DEBUG\r\nprintk(KERN_INFO "success calling get-system-parameter\n");\r\n#endif\r\nsplpar_strlen = local_buffer[0] * 256 + local_buffer[1];\r\nlocal_buffer += 2;\r\nw_idx = 0;\r\nidx = 0;\r\nwhile ((*local_buffer) && (idx < splpar_strlen)) {\r\nworkbuffer[w_idx++] = local_buffer[idx++];\r\nif ((local_buffer[idx] == ',')\r\n|| (local_buffer[idx] == '\0')) {\r\nworkbuffer[w_idx] = '\0';\r\nif (w_idx) {\r\nseq_printf(m, "%s\n", workbuffer);\r\n}\r\nmemset(workbuffer, 0, SPLPAR_MAXLENGTH);\r\nidx++;\r\nw_idx = 0;\r\n} else if (local_buffer[idx] == '=') {\r\nif (0 == strcmp(workbuffer, "MaxEntCap")) {\r\nstrcpy(workbuffer,\r\n"partition_max_entitled_capacity");\r\nw_idx = strlen(workbuffer);\r\n}\r\nif (0 == strcmp(workbuffer, "MaxPlatProcs")) {\r\nstrcpy(workbuffer,\r\n"system_potential_processors");\r\nw_idx = strlen(workbuffer);\r\n}\r\n}\r\n}\r\nkfree(workbuffer);\r\nlocal_buffer -= 2;\r\n}\r\nkfree(local_buffer);\r\n}\r\nstatic int lparcfg_count_active_processors(void)\r\n{\r\nstruct device_node *cpus_dn = NULL;\r\nint count = 0;\r\nwhile ((cpus_dn = of_find_node_by_type(cpus_dn, "cpu"))) {\r\n#ifdef LPARCFG_DEBUG\r\nprintk(KERN_ERR "cpus_dn %p\n", cpus_dn);\r\n#endif\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void pseries_cmo_data(struct seq_file *m)\r\n{\r\nint cpu;\r\nunsigned long cmo_faults = 0;\r\nunsigned long cmo_fault_time = 0;\r\nseq_printf(m, "cmo_enabled=%d\n", firmware_has_feature(FW_FEATURE_CMO));\r\nif (!firmware_has_feature(FW_FEATURE_CMO))\r\nreturn;\r\nfor_each_possible_cpu(cpu) {\r\ncmo_faults += lppaca_of(cpu).cmo_faults;\r\ncmo_fault_time += lppaca_of(cpu).cmo_fault_time;\r\n}\r\nseq_printf(m, "cmo_faults=%lu\n", cmo_faults);\r\nseq_printf(m, "cmo_fault_time_usec=%lu\n",\r\ncmo_fault_time / tb_ticks_per_usec);\r\nseq_printf(m, "cmo_primary_psp=%d\n", cmo_get_primary_psp());\r\nseq_printf(m, "cmo_secondary_psp=%d\n", cmo_get_secondary_psp());\r\nseq_printf(m, "cmo_page_size=%lu\n", cmo_get_page_size());\r\n}\r\nstatic void splpar_dispatch_data(struct seq_file *m)\r\n{\r\nint cpu;\r\nunsigned long dispatches = 0;\r\nunsigned long dispatch_dispersions = 0;\r\nfor_each_possible_cpu(cpu) {\r\ndispatches += lppaca_of(cpu).yield_count;\r\ndispatch_dispersions += lppaca_of(cpu).dispersion_count;\r\n}\r\nseq_printf(m, "dispatches=%lu\n", dispatches);\r\nseq_printf(m, "dispatch_dispersions=%lu\n", dispatch_dispersions);\r\n}\r\nstatic void parse_em_data(struct seq_file *m)\r\n{\r\nunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\r\nif (plpar_hcall(H_GET_EM_PARMS, retbuf) == H_SUCCESS)\r\nseq_printf(m, "power_mode_data=%016lx\n", retbuf[0]);\r\n}\r\nstatic int pseries_lparcfg_data(struct seq_file *m, void *v)\r\n{\r\nint partition_potential_processors;\r\nint partition_active_processors;\r\nstruct device_node *rtas_node;\r\nconst int *lrdrp = NULL;\r\nrtas_node = of_find_node_by_path("/rtas");\r\nif (rtas_node)\r\nlrdrp = of_get_property(rtas_node, "ibm,lrdr-capacity", NULL);\r\nif (lrdrp == NULL) {\r\npartition_potential_processors = vdso_data->processorCount;\r\n} else {\r\npartition_potential_processors = *(lrdrp + 4);\r\n}\r\nof_node_put(rtas_node);\r\npartition_active_processors = lparcfg_count_active_processors();\r\nif (firmware_has_feature(FW_FEATURE_SPLPAR)) {\r\nparse_system_parameter_string(m);\r\nparse_ppp_data(m);\r\nparse_mpp_data(m);\r\nparse_mpp_x_data(m);\r\npseries_cmo_data(m);\r\nsplpar_dispatch_data(m);\r\nseq_printf(m, "purr=%ld\n", get_purr());\r\n} else {\r\nseq_printf(m, "system_active_processors=%d\n",\r\npartition_potential_processors);\r\nseq_printf(m, "system_potential_processors=%d\n",\r\npartition_potential_processors);\r\nseq_printf(m, "partition_max_entitled_capacity=%d\n",\r\npartition_potential_processors * 100);\r\nseq_printf(m, "partition_entitled_capacity=%d\n",\r\npartition_active_processors * 100);\r\n}\r\nseq_printf(m, "partition_active_processors=%d\n",\r\npartition_active_processors);\r\nseq_printf(m, "partition_potential_processors=%d\n",\r\npartition_potential_processors);\r\nseq_printf(m, "shared_processor_mode=%d\n", lppaca_of(0).shared_proc);\r\nseq_printf(m, "slb_size=%d\n", mmu_slb_size);\r\nparse_em_data(m);\r\nreturn 0;\r\n}\r\nstatic ssize_t update_ppp(u64 *entitlement, u8 *weight)\r\n{\r\nstruct hvcall_ppp_data ppp_data;\r\nu8 new_weight;\r\nu64 new_entitled;\r\nssize_t retval;\r\nretval = h_get_ppp(&ppp_data);\r\nif (retval)\r\nreturn retval;\r\nif (entitlement) {\r\nnew_weight = ppp_data.weight;\r\nnew_entitled = *entitlement;\r\n} else if (weight) {\r\nnew_weight = *weight;\r\nnew_entitled = ppp_data.entitlement;\r\n} else\r\nreturn -EINVAL;\r\npr_debug("%s: current_entitled = %llu, current_weight = %u\n",\r\n__func__, ppp_data.entitlement, ppp_data.weight);\r\npr_debug("%s: new_entitled = %llu, new_weight = %u\n",\r\n__func__, new_entitled, new_weight);\r\nretval = plpar_hcall_norets(H_SET_PPP, new_entitled, new_weight);\r\nreturn retval;\r\n}\r\nstatic ssize_t update_mpp(u64 *entitlement, u8 *weight)\r\n{\r\nstruct hvcall_mpp_data mpp_data;\r\nu64 new_entitled;\r\nu8 new_weight;\r\nssize_t rc;\r\nif (entitlement) {\r\nrc = vio_cmo_entitlement_update(*entitlement);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = h_get_mpp(&mpp_data);\r\nif (rc)\r\nreturn rc;\r\nif (entitlement) {\r\nnew_weight = mpp_data.mem_weight;\r\nnew_entitled = *entitlement;\r\n} else if (weight) {\r\nnew_weight = *weight;\r\nnew_entitled = mpp_data.entitled_mem;\r\n} else\r\nreturn -EINVAL;\r\npr_debug("%s: current_entitled = %lu, current_weight = %u\n",\r\n__func__, mpp_data.entitled_mem, mpp_data.mem_weight);\r\npr_debug("%s: new_entitled = %llu, new_weight = %u\n",\r\n__func__, new_entitled, new_weight);\r\nrc = plpar_hcall_norets(H_SET_MPP, new_entitled, new_weight);\r\nreturn rc;\r\n}\r\nstatic ssize_t lparcfg_write(struct file *file, const char __user * buf,\r\nsize_t count, loff_t * off)\r\n{\r\nint kbuf_sz = 64;\r\nchar kbuf[kbuf_sz];\r\nchar *tmp;\r\nu64 new_entitled, *new_entitled_ptr = &new_entitled;\r\nu8 new_weight, *new_weight_ptr = &new_weight;\r\nssize_t retval;\r\nif (!firmware_has_feature(FW_FEATURE_SPLPAR) ||\r\nfirmware_has_feature(FW_FEATURE_ISERIES))\r\nreturn -EINVAL;\r\nif (count > kbuf_sz)\r\nreturn -EINVAL;\r\nif (copy_from_user(kbuf, buf, count))\r\nreturn -EFAULT;\r\nkbuf[count - 1] = '\0';\r\ntmp = strchr(kbuf, '=');\r\nif (!tmp)\r\nreturn -EINVAL;\r\n*tmp++ = '\0';\r\nif (!strcmp(kbuf, "partition_entitled_capacity")) {\r\nchar *endp;\r\n*new_entitled_ptr = (u64) simple_strtoul(tmp, &endp, 10);\r\nif (endp == tmp)\r\nreturn -EINVAL;\r\nretval = update_ppp(new_entitled_ptr, NULL);\r\n} else if (!strcmp(kbuf, "capacity_weight")) {\r\nchar *endp;\r\n*new_weight_ptr = (u8) simple_strtoul(tmp, &endp, 10);\r\nif (endp == tmp)\r\nreturn -EINVAL;\r\nretval = update_ppp(NULL, new_weight_ptr);\r\n} else if (!strcmp(kbuf, "entitled_memory")) {\r\nchar *endp;\r\n*new_entitled_ptr = (u64) simple_strtoul(tmp, &endp, 10);\r\nif (endp == tmp)\r\nreturn -EINVAL;\r\nretval = update_mpp(new_entitled_ptr, NULL);\r\n} else if (!strcmp(kbuf, "entitled_memory_weight")) {\r\nchar *endp;\r\n*new_weight_ptr = (u8) simple_strtoul(tmp, &endp, 10);\r\nif (endp == tmp)\r\nreturn -EINVAL;\r\nretval = update_mpp(NULL, new_weight_ptr);\r\n} else\r\nreturn -EINVAL;\r\nif (retval == H_SUCCESS || retval == H_CONSTRAINED) {\r\nretval = count;\r\n} else if (retval == H_BUSY) {\r\nretval = -EBUSY;\r\n} else if (retval == H_HARDWARE) {\r\nretval = -EIO;\r\n} else if (retval == H_PARAMETER) {\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic int pseries_lparcfg_data(struct seq_file *m, void *v)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t lparcfg_write(struct file *file, const char __user * buf,\r\nsize_t count, loff_t * off)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int lparcfg_data(struct seq_file *m, void *v)\r\n{\r\nstruct device_node *rootdn;\r\nconst char *model = "";\r\nconst char *system_id = "";\r\nconst char *tmp;\r\nconst unsigned int *lp_index_ptr;\r\nunsigned int lp_index = 0;\r\nseq_printf(m, "%s %s\n", MODULE_NAME, MODULE_VERS);\r\nrootdn = of_find_node_by_path("/");\r\nif (rootdn) {\r\ntmp = of_get_property(rootdn, "model", NULL);\r\nif (tmp) {\r\nmodel = tmp;\r\nif (firmware_has_feature(FW_FEATURE_ISERIES))\r\nmodel += 4;\r\n}\r\ntmp = of_get_property(rootdn, "system-id", NULL);\r\nif (tmp) {\r\nsystem_id = tmp;\r\nif (firmware_has_feature(FW_FEATURE_ISERIES))\r\nsystem_id += 4;\r\n}\r\nlp_index_ptr = of_get_property(rootdn, "ibm,partition-no",\r\nNULL);\r\nif (lp_index_ptr)\r\nlp_index = *lp_index_ptr;\r\nof_node_put(rootdn);\r\n}\r\nseq_printf(m, "serial_number=%s\n", system_id);\r\nseq_printf(m, "system_type=%s\n", model);\r\nseq_printf(m, "partition_id=%d\n", (int)lp_index);\r\nif (firmware_has_feature(FW_FEATURE_ISERIES))\r\nreturn iseries_lparcfg_data(m, v);\r\nreturn pseries_lparcfg_data(m, v);\r\n}\r\nstatic int lparcfg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, lparcfg_data, NULL);\r\n}\r\nstatic int __init lparcfg_init(void)\r\n{\r\nstruct proc_dir_entry *ent;\r\nmode_t mode = S_IRUSR | S_IRGRP | S_IROTH;\r\nif (firmware_has_feature(FW_FEATURE_SPLPAR) &&\r\n!firmware_has_feature(FW_FEATURE_ISERIES))\r\nmode |= S_IWUSR;\r\nent = proc_create("powerpc/lparcfg", mode, NULL, &lparcfg_fops);\r\nif (!ent) {\r\nprintk(KERN_ERR "Failed to create powerpc/lparcfg\n");\r\nreturn -EIO;\r\n}\r\nproc_ppc64_lparcfg = ent;\r\nreturn 0;\r\n}\r\nstatic void __exit lparcfg_cleanup(void)\r\n{\r\nif (proc_ppc64_lparcfg)\r\nremove_proc_entry("lparcfg", proc_ppc64_lparcfg->parent);\r\n}
