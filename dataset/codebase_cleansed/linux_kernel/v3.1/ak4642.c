static inline unsigned int ak4642_read_reg_cache(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg >= AK4642_CACHEREGNUM)\r\nreturn -1;\r\nreturn cache[reg];\r\n}\r\nstatic inline void ak4642_write_reg_cache(struct snd_soc_codec *codec,\r\nu16 reg, unsigned int value)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg >= AK4642_CACHEREGNUM)\r\nreturn;\r\ncache[reg] = value;\r\n}\r\nstatic int ak4642_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nu8 data[2];\r\ndata[0] = reg & 0xff;\r\ndata[1] = value & 0xff;\r\nif (codec->hw_write(codec->control_data, data, 2) == 2) {\r\nak4642_write_reg_cache(codec, reg, value);\r\nreturn 0;\r\n} else\r\nreturn -EIO;\r\n}\r\nstatic int ak4642_sync(struct snd_soc_codec *codec)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nint i, r = 0;\r\nfor (i = 0; i < AK4642_CACHEREGNUM; i++)\r\nr |= ak4642_write(codec, i, cache[i]);\r\nreturn r;\r\n}\r\nstatic int ak4642_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (is_play) {\r\nsnd_soc_update_bits(codec, MD_CTL4, DACH, DACH);\r\nsnd_soc_update_bits(codec, MD_CTL3, BST1, BST1);\r\nak4642_write(codec, L_IVC, 0x91);\r\nak4642_write(codec, R_IVC, 0x91);\r\nsnd_soc_update_bits(codec, PW_MGMT1, PMVCM | PMMIN | PMDAC,\r\nPMVCM | PMMIN | PMDAC);\r\nsnd_soc_update_bits(codec, PW_MGMT2, PMHP_MASK, PMHP);\r\nsnd_soc_update_bits(codec, PW_MGMT2, HPMTN, HPMTN);\r\n} else {\r\nak4642_write(codec, SG_SL1, PMMP | MGAIN0);\r\nak4642_write(codec, TIMER, ZTM(0x3) | WTM(0x3));\r\nak4642_write(codec, ALC_CTL1, ALC | LMTH0);\r\nsnd_soc_update_bits(codec, PW_MGMT1, PMVCM | PMADL,\r\nPMVCM | PMADL);\r\nsnd_soc_update_bits(codec, PW_MGMT3, PMADR, PMADR);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ak4642_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (is_play) {\r\nsnd_soc_update_bits(codec, PW_MGMT2, HPMTN, 0);\r\nsnd_soc_update_bits(codec, PW_MGMT2, PMHP_MASK, 0);\r\nsnd_soc_update_bits(codec, PW_MGMT1, PMMIN | PMDAC, 0);\r\nsnd_soc_update_bits(codec, MD_CTL3, BST1, 0);\r\nsnd_soc_update_bits(codec, MD_CTL4, DACH, 0);\r\n} else {\r\nsnd_soc_update_bits(codec, PW_MGMT1, PMADL, 0);\r\nsnd_soc_update_bits(codec, PW_MGMT3, PMADR, 0);\r\nsnd_soc_update_bits(codec, ALC_CTL1, ALC, 0);\r\n}\r\n}\r\nstatic int ak4642_dai_set_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 pll;\r\nswitch (freq) {\r\ncase 11289600:\r\npll = PLL2;\r\nbreak;\r\ncase 12288000:\r\npll = PLL2 | PLL0;\r\nbreak;\r\ncase 12000000:\r\npll = PLL2 | PLL1;\r\nbreak;\r\ncase 24000000:\r\npll = PLL2 | PLL1 | PLL0;\r\nbreak;\r\ncase 13500000:\r\npll = PLL3 | PLL2;\r\nbreak;\r\ncase 27000000:\r\npll = PLL3 | PLL2 | PLL0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, MD_CTL1, PLL_MASK, pll);\r\nreturn 0;\r\n}\r\nstatic int ak4642_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 data;\r\nu8 bcko;\r\ndata = MCKO | PMPLL;\r\nbcko = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ndata |= MS;\r\nbcko = BCKO_64;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, PW_MGMT2, MS | MCKO | PMPLL, data);\r\nsnd_soc_update_bits(codec, MD_CTL1, BCKO_MASK, bcko);\r\ndata = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ndata = LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ndata = I2S;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, MD_CTL1, DIF_MASK, data);\r\nreturn 0;\r\n}\r\nstatic int ak4642_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 rate;\r\nswitch (params_rate(params)) {\r\ncase 7350:\r\nrate = FS2;\r\nbreak;\r\ncase 8000:\r\nrate = 0;\r\nbreak;\r\ncase 11025:\r\nrate = FS2 | FS0;\r\nbreak;\r\ncase 12000:\r\nrate = FS0;\r\nbreak;\r\ncase 14700:\r\nrate = FS2 | FS1;\r\nbreak;\r\ncase 16000:\r\nrate = FS1;\r\nbreak;\r\ncase 22050:\r\nrate = FS2 | FS1 | FS0;\r\nbreak;\r\ncase 24000:\r\nrate = FS1 | FS0;\r\nbreak;\r\ncase 29400:\r\nrate = FS3 | FS2 | FS1;\r\nbreak;\r\ncase 32000:\r\nrate = FS3 | FS1;\r\nbreak;\r\ncase 44100:\r\nrate = FS3 | FS2 | FS1 | FS0;\r\nbreak;\r\ncase 48000:\r\nrate = FS3 | FS1 | FS0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, MD_CTL2, FS_MASK, rate);\r\nreturn 0;\r\n}\r\nstatic int ak4642_resume(struct snd_soc_codec *codec)\r\n{\r\nak4642_sync(codec);\r\nreturn 0;\r\n}\r\nstatic int ak4642_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4642_priv *ak4642 = snd_soc_codec_get_drvdata(codec);\r\ndev_info(codec->dev, "AK4642 Audio Codec %s", AK4642_VERSION);\r\ncodec->hw_write = (hw_write_t)i2c_master_send;\r\ncodec->control_data = ak4642->control_data;\r\nsnd_soc_add_controls(codec, ak4642_snd_controls,\r\nARRAY_SIZE(ak4642_snd_controls));\r\nreturn 0;\r\n}\r\nstatic __devinit int ak4642_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ak4642_priv *ak4642;\r\nint ret;\r\nak4642 = kzalloc(sizeof(struct ak4642_priv), GFP_KERNEL);\r\nif (!ak4642)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, ak4642);\r\nak4642->control_data = i2c;\r\nak4642->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_ak4642, &ak4642_dai, 1);\r\nif (ret < 0)\r\nkfree(ak4642);\r\nreturn ret;\r\n}\r\nstatic __devexit int ak4642_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int __init ak4642_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&ak4642_i2c_driver);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit ak4642_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&ak4642_i2c_driver);\r\n#endif\r\n}
