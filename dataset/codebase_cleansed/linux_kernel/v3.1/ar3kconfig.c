static int SendHCICommand(struct ar3k_config_info *pConfig,\r\nu8 *pBuffer,\r\nint Length)\r\n{\r\nstruct htc_packet *pPacket = NULL;\r\nint status = 0;\r\ndo {\r\npPacket = (struct htc_packet *)A_MALLOC(sizeof(struct htc_packet));\r\nif (NULL == pPacket) {\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\nA_MEMZERO(pPacket,sizeof(struct htc_packet));\r\nSET_HTC_PACKET_INFO_TX(pPacket,\r\nNULL,\r\npBuffer,\r\nLength,\r\nHCI_COMMAND_TYPE,\r\nAR6K_CONTROL_PKT_TAG);\r\nstatus = HCI_TransportSendPkt(pConfig->pHCIDev,pPacket,true);\r\n} while (false);\r\nif (pPacket != NULL) {\r\nkfree(pPacket);\r\n}\r\nreturn status;\r\n}\r\nstatic int RecvHCIEvent(struct ar3k_config_info *pConfig,\r\nu8 *pBuffer,\r\nint *pLength)\r\n{\r\nint status = 0;\r\nstruct htc_packet *pRecvPacket = NULL;\r\ndo {\r\npRecvPacket = (struct htc_packet *)A_MALLOC(sizeof(struct htc_packet));\r\nif (NULL == pRecvPacket) {\r\nstatus = A_NO_MEMORY;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to alloc HTC struct \n"));\r\nbreak;\r\n}\r\nA_MEMZERO(pRecvPacket,sizeof(struct htc_packet));\r\nSET_HTC_PACKET_INFO_RX_REFILL(pRecvPacket,NULL,pBuffer,*pLength,HCI_EVENT_TYPE);\r\nstatus = HCI_TransportRecvHCIEventSync(pConfig->pHCIDev,\r\npRecvPacket,\r\nHCI_EVENT_RESP_TIMEOUTMS);\r\nif (status) {\r\nbreak;\r\n}\r\n*pLength = pRecvPacket->ActualLength;\r\n} while (false);\r\nif (pRecvPacket != NULL) {\r\nkfree(pRecvPacket);\r\n}\r\nreturn status;\r\n}\r\nint SendHCICommandWaitCommandComplete(struct ar3k_config_info *pConfig,\r\nu8 *pHCICommand,\r\nint CmdLength,\r\nu8 **ppEventBuffer,\r\nu8 **ppBufferToFree)\r\n{\r\nint status = 0;\r\nu8 *pBuffer = NULL;\r\nu8 *pTemp;\r\nint length;\r\nbool commandComplete = false;\r\nu8 opCodeBytes[2];\r\ndo {\r\nlength = max(HCI_MAX_EVT_RECV_LENGTH,CmdLength);\r\nlength += pConfig->pHCIProps->HeadRoom + pConfig->pHCIProps->TailRoom;\r\nlength += pConfig->pHCIProps->IOBlockPad;\r\npBuffer = (u8 *)A_MALLOC(length);\r\nif (NULL == pBuffer) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR3K Config: Failed to allocate bt buffer \n"));\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\nopCodeBytes[0] = pHCICommand[HCI_CMD_OPCODE_BYTE_LOW_OFFSET];\r\nopCodeBytes[1] = pHCICommand[HCI_CMD_OPCODE_BYTE_HI_OFFSET];\r\nmemcpy(pBuffer + pConfig->pHCIProps->HeadRoom,pHCICommand,CmdLength);\r\nstatus = SendHCICommand(pConfig,\r\npBuffer + pConfig->pHCIProps->HeadRoom,\r\nCmdLength);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR3K Config: Failed to send HCI Command (%d) \n", status));\r\nAR_DEBUG_PRINTBUF(pHCICommand,CmdLength,"HCI Bridge Failed HCI Command");\r\nbreak;\r\n}\r\nA_MEMZERO(pBuffer,length);\r\nstatus = RecvHCIEvent(pConfig,pBuffer,&length);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR3K Config: HCI event recv failed \n"));\r\nAR_DEBUG_PRINTBUF(pHCICommand,CmdLength,"HCI Bridge Failed HCI Command");\r\nbreak;\r\n}\r\npTemp = pBuffer + pConfig->pHCIProps->HeadRoom;\r\nif (pTemp[0] == HCI_CMD_COMPLETE_EVENT_CODE) {\r\nif ((pTemp[HCI_EVENT_OPCODE_BYTE_LOW] == opCodeBytes[0]) &&\r\n(pTemp[HCI_EVENT_OPCODE_BYTE_HI] == opCodeBytes[1])) {\r\ncommandComplete = true;\r\n}\r\n}\r\nif (!commandComplete) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR3K Config: Unexpected HCI event : %d \n",pTemp[0]));\r\nAR_DEBUG_PRINTBUF(pTemp,pTemp[1],"Unexpected HCI event");\r\nstatus = A_ECOMM;\r\nbreak;\r\n}\r\nif (ppEventBuffer != NULL) {\r\n*ppEventBuffer = pTemp;\r\nif (ppBufferToFree == NULL) {\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\n*ppBufferToFree = pBuffer;\r\npBuffer = NULL;\r\n}\r\n} while (false);\r\nif (pBuffer != NULL) {\r\nkfree(pBuffer);\r\n}\r\nreturn status;\r\n}\r\nstatic int AR3KConfigureHCIBaud(struct ar3k_config_info *pConfig)\r\n{\r\nint status = 0;\r\nu8 hciBaudChangeCommand[] = {0x0c,0xfc,0x2,0,0};\r\nu16 baudVal;\r\nu8 *pEvent = NULL;\r\nu8 *pBufferToFree = NULL;\r\ndo {\r\nif (pConfig->Flags & AR3K_CONFIG_FLAG_SET_AR3K_BAUD) {\r\nbaudVal = (u16)(pConfig->AR3KBaudRate / 100);\r\nhciBaudChangeCommand[3] = (u8)baudVal;\r\nhciBaudChangeCommand[4] = (u8)(baudVal >> 8);\r\nstatus = SendHCICommandWaitCommandComplete(pConfig,\r\nhciBaudChangeCommand,\r\nsizeof(hciBaudChangeCommand),\r\n&pEvent,\r\n&pBufferToFree);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR3K Config: Baud rate change failed! \n"));\r\nbreak;\r\n}\r\nif (pEvent[BAUD_CHANGE_COMMAND_STATUS_OFFSET] != 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("AR3K Config: Baud change command event status failed: %d \n",\r\npEvent[BAUD_CHANGE_COMMAND_STATUS_OFFSET]));\r\nstatus = A_ECOMM;\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("AR3K Config: Baud Changed to %d \n",pConfig->AR3KBaudRate));\r\n}\r\nif (pConfig->Flags & AR3K_CONFIG_FLAG_AR3K_BAUD_CHANGE_DELAY) {\r\nA_MDELAY(325);\r\n}\r\nif (pConfig->Flags & AR3K_CONFIG_FLAG_SET_AR6K_SCALE_STEP) {\r\nstatus = HCI_TransportSetBaudRate(pConfig->pHCIDev, pConfig->AR3KBaudRate);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("AR3K Config: failed to set scale and step values: %d \n", status));\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,\r\n("AR3K Config: Baud changed to %d for AR6K\n", pConfig->AR3KBaudRate));\r\n}\r\n} while (false);\r\nif (pBufferToFree != NULL) {\r\nkfree(pBufferToFree);\r\n}\r\nreturn status;\r\n}\r\nstatic int AR3KExitMinBoot(struct ar3k_config_info *pConfig)\r\n{\r\nint status;\r\nchar exitMinBootCmd[] = {0x25,0xFC,0x0c,0x03,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00};\r\nu8 *pEvent = NULL;\r\nu8 *pBufferToFree = NULL;\r\nstatus = SendHCICommandWaitCommandComplete(pConfig,\r\nexitMinBootCmd,\r\nsizeof(exitMinBootCmd),\r\n&pEvent,\r\n&pBufferToFree);\r\nif (!status) {\r\nif (pEvent[EXIT_MIN_BOOT_COMMAND_STATUS_OFFSET] != 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\r\n("AR3K Config: MinBoot exit command event status failed: %d \n",\r\npEvent[EXIT_MIN_BOOT_COMMAND_STATUS_OFFSET]));\r\nstatus = A_ECOMM;\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_INFO,\r\n("AR3K Config: MinBoot Exit Command Complete (Success) \n"));\r\nA_MDELAY(1);\r\n}\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR3K Config: MinBoot Exit Failed! \n"));\r\n}\r\nif (pBufferToFree != NULL) {\r\nkfree(pBufferToFree);\r\n}\r\nreturn status;\r\n}\r\nstatic int AR3KConfigureSendHCIReset(struct ar3k_config_info *pConfig)\r\n{\r\nint status = 0;\r\nu8 hciResetCommand[] = {0x03,0x0c,0x0};\r\nu8 *pEvent = NULL;\r\nu8 *pBufferToFree = NULL;\r\nstatus = SendHCICommandWaitCommandComplete( pConfig,\r\nhciResetCommand,\r\nsizeof(hciResetCommand),\r\n&pEvent,\r\n&pBufferToFree );\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR3K Config: HCI reset failed! \n"));\r\n}\r\nif (pBufferToFree != NULL) {\r\nkfree(pBufferToFree);\r\n}\r\nreturn status;\r\n}\r\nstatic int AR3KEnableTLPM(struct ar3k_config_info *pConfig)\r\n{\r\nint status;\r\nchar hostWakeupConfig[] = {0x31,0xFC,0x18,\r\n0x02,0x00,0x00,0x00,\r\n0x01,0x00,0x00,0x00,\r\nTLPM_DEFAULT_IDLE_TIMEOUT_LSB,TLPM_DEFAULT_IDLE_TIMEOUT_MSB,0x00,0x00,\r\n0x00,0x00,0x00,0x00,\r\nTLPM_DEFAULT_WAKEUP_TIMEOUT_MS,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00};\r\nchar targetWakeupConfig[] = {0x31,0xFC,0x18,\r\n0x04,0x00,0x00,0x00,\r\n0x01,0x00,0x00,0x00,\r\nTLPM_DEFAULT_IDLE_TIMEOUT_LSB,TLPM_DEFAULT_IDLE_TIMEOUT_MSB,0x00,0x00,\r\n0x00,0x00,0x00,0x00,\r\nTLPM_DEFAULT_WAKEUP_TIMEOUT_MS,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00};\r\nchar hostWakeupEnable[] = {0x31,0xFC,0x4,\r\n0x01,0x00,0x00,0x00};\r\nchar targetWakeupEnable[] = {0x31,0xFC,0x4,\r\n0x06,0x00,0x00,0x00};\r\nchar sleepEnable[] = {0x4,0xFC,0x1,\r\n0x1};\r\nu8 *pEvent = NULL;\r\nu8 *pBufferToFree = NULL;\r\nif (0 != pConfig->IdleTimeout) {\r\nu8 idle_lsb = pConfig->IdleTimeout & 0xFF;\r\nu8 idle_msb = (pConfig->IdleTimeout & 0xFF00) >> 8;\r\nhostWakeupConfig[11] = targetWakeupConfig[11] = idle_lsb;\r\nhostWakeupConfig[12] = targetWakeupConfig[12] = idle_msb;\r\n}\r\nif (0 != pConfig->WakeupTimeout) {\r\nhostWakeupConfig[19] = targetWakeupConfig[19] = (pConfig->WakeupTimeout & 0xFF);\r\n}\r\nstatus = SendHCICommandWaitCommandComplete(pConfig,\r\nhostWakeupConfig,\r\nsizeof(hostWakeupConfig),\r\n&pEvent,\r\n&pBufferToFree);\r\nif (pBufferToFree != NULL) {\r\nkfree(pBufferToFree);\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("HostWakeup Config Failed! \n"));\r\nreturn status;\r\n}\r\npEvent = NULL;\r\npBufferToFree = NULL;\r\nstatus = SendHCICommandWaitCommandComplete(pConfig,\r\ntargetWakeupConfig,\r\nsizeof(targetWakeupConfig),\r\n&pEvent,\r\n&pBufferToFree);\r\nif (pBufferToFree != NULL) {\r\nkfree(pBufferToFree);\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Target Wakeup Config Failed! \n"));\r\nreturn status;\r\n}\r\npEvent = NULL;\r\npBufferToFree = NULL;\r\nstatus = SendHCICommandWaitCommandComplete(pConfig,\r\nhostWakeupEnable,\r\nsizeof(hostWakeupEnable),\r\n&pEvent,\r\n&pBufferToFree);\r\nif (pBufferToFree != NULL) {\r\nkfree(pBufferToFree);\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("HostWakeup Enable Failed! \n"));\r\nreturn status;\r\n}\r\npEvent = NULL;\r\npBufferToFree = NULL;\r\nstatus = SendHCICommandWaitCommandComplete(pConfig,\r\ntargetWakeupEnable,\r\nsizeof(targetWakeupEnable),\r\n&pEvent,\r\n&pBufferToFree);\r\nif (pBufferToFree != NULL) {\r\nkfree(pBufferToFree);\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Target Wakeup Enable Failed! \n"));\r\nreturn status;\r\n}\r\npEvent = NULL;\r\npBufferToFree = NULL;\r\nstatus = SendHCICommandWaitCommandComplete(pConfig,\r\nsleepEnable,\r\nsizeof(sleepEnable),\r\n&pEvent,\r\n&pBufferToFree);\r\nif (pBufferToFree != NULL) {\r\nkfree(pBufferToFree);\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Sleep Enable Failed! \n"));\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR3K Config: Enable TLPM Completed (status = %d) \n",status));\r\nreturn status;\r\n}\r\nint AR3KConfigure(struct ar3k_config_info *pConfig)\r\n{\r\nint status = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_INFO,("AR3K Config: Configuring AR3K ...\n"));\r\ndo {\r\nif ((pConfig->pHCIDev == NULL) || (pConfig->pHCIProps == NULL) || (pConfig->pHIFDevice == NULL)) {\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nstatus = HCI_TransportEnableDisableAsyncRecv(pConfig->pHCIDev,false);\r\nif (status) {\r\nbreak;\r\n}\r\nif (pConfig->Flags & AR3K_CONFIG_FLAG_FORCE_MINBOOT_EXIT) {\r\nstatus = AR3KExitMinBoot(pConfig);\r\nif (status) {\r\nbreak;\r\n}\r\n}\r\nif (0 != AthPSInitialize(pConfig)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Patch Download Failed!\n"));\r\n}\r\nAR3KConfigureSendHCIReset(pConfig);\r\nif (pConfig->Flags &\r\n(AR3K_CONFIG_FLAG_SET_AR3K_BAUD | AR3K_CONFIG_FLAG_SET_AR6K_SCALE_STEP)) {\r\nstatus = AR3KConfigureHCIBaud(pConfig);\r\nif (status) {\r\nbreak;\r\n}\r\n}\r\nif (pConfig->PwrMgmtEnabled) {\r\nA_MDELAY(200);\r\nAR3KEnableTLPM(pConfig);\r\n}\r\nstatus = HCI_TransportEnableDisableAsyncRecv(pConfig->pHCIDev,true);\r\nif (status) {\r\nbreak;\r\n}\r\n} while (false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_INFO,("AR3K Config: Configuration Complete (status = %d) \n",status));\r\nreturn status;\r\n}\r\nint AR3KConfigureExit(void *config)\r\n{\r\nint status = 0;\r\nstruct ar3k_config_info *pConfig = (struct ar3k_config_info *)config;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_INFO,("AR3K Config: Cleaning up AR3K ...\n"));\r\ndo {\r\nif ((pConfig->pHCIDev == NULL) || (pConfig->pHCIProps == NULL) || (pConfig->pHIFDevice == NULL)) {\r\nstatus = A_EINVAL;\r\nbreak;\r\n}\r\nstatus = HCI_TransportEnableDisableAsyncRecv(pConfig->pHCIDev,false);\r\nif (status) {\r\nbreak;\r\n}\r\nif (pConfig->Flags &\r\n(AR3K_CONFIG_FLAG_SET_AR3K_BAUD | AR3K_CONFIG_FLAG_SET_AR6K_SCALE_STEP)) {\r\nstatus = AR3KConfigureHCIBaud(pConfig);\r\nif (status) {\r\nbreak;\r\n}\r\n}\r\nstatus = HCI_TransportEnableDisableAsyncRecv(pConfig->pHCIDev,true);\r\nif (status) {\r\nbreak;\r\n}\r\n} while (false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_INFO,("AR3K Config: Cleanup Complete (status = %d) \n",status));\r\nreturn status;\r\n}
