static inline struct vfsmount *next_peer(struct vfsmount *p)\r\n{\r\nreturn list_entry(p->mnt_share.next, struct vfsmount, mnt_share);\r\n}\r\nstatic inline struct vfsmount *first_slave(struct vfsmount *p)\r\n{\r\nreturn list_entry(p->mnt_slave_list.next, struct vfsmount, mnt_slave);\r\n}\r\nstatic inline struct vfsmount *next_slave(struct vfsmount *p)\r\n{\r\nreturn list_entry(p->mnt_slave.next, struct vfsmount, mnt_slave);\r\n}\r\nstatic bool is_path_reachable(struct vfsmount *mnt, struct dentry *dentry,\r\nconst struct path *root)\r\n{\r\nwhile (mnt != root->mnt && mnt->mnt_parent != mnt) {\r\ndentry = mnt->mnt_mountpoint;\r\nmnt = mnt->mnt_parent;\r\n}\r\nreturn mnt == root->mnt && is_subdir(dentry, root->dentry);\r\n}\r\nstatic struct vfsmount *get_peer_under_root(struct vfsmount *mnt,\r\nstruct mnt_namespace *ns,\r\nconst struct path *root)\r\n{\r\nstruct vfsmount *m = mnt;\r\ndo {\r\nif (m->mnt_ns == ns && is_path_reachable(m, m->mnt_root, root))\r\nreturn m;\r\nm = next_peer(m);\r\n} while (m != mnt);\r\nreturn NULL;\r\n}\r\nint get_dominating_id(struct vfsmount *mnt, const struct path *root)\r\n{\r\nstruct vfsmount *m;\r\nfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\r\nstruct vfsmount *d = get_peer_under_root(m, mnt->mnt_ns, root);\r\nif (d)\r\nreturn d->mnt_group_id;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_make_slave(struct vfsmount *mnt)\r\n{\r\nstruct vfsmount *peer_mnt = mnt, *master = mnt->mnt_master;\r\nstruct vfsmount *slave_mnt;\r\nwhile ((peer_mnt = next_peer(peer_mnt)) != mnt &&\r\npeer_mnt->mnt_root != mnt->mnt_root) ;\r\nif (peer_mnt == mnt) {\r\npeer_mnt = next_peer(mnt);\r\nif (peer_mnt == mnt)\r\npeer_mnt = NULL;\r\n}\r\nif (IS_MNT_SHARED(mnt) && list_empty(&mnt->mnt_share))\r\nmnt_release_group_id(mnt);\r\nlist_del_init(&mnt->mnt_share);\r\nmnt->mnt_group_id = 0;\r\nif (peer_mnt)\r\nmaster = peer_mnt;\r\nif (master) {\r\nlist_for_each_entry(slave_mnt, &mnt->mnt_slave_list, mnt_slave)\r\nslave_mnt->mnt_master = master;\r\nlist_move(&mnt->mnt_slave, &master->mnt_slave_list);\r\nlist_splice(&mnt->mnt_slave_list, master->mnt_slave_list.prev);\r\nINIT_LIST_HEAD(&mnt->mnt_slave_list);\r\n} else {\r\nstruct list_head *p = &mnt->mnt_slave_list;\r\nwhile (!list_empty(p)) {\r\nslave_mnt = list_first_entry(p,\r\nstruct vfsmount, mnt_slave);\r\nlist_del_init(&slave_mnt->mnt_slave);\r\nslave_mnt->mnt_master = NULL;\r\n}\r\n}\r\nmnt->mnt_master = master;\r\nCLEAR_MNT_SHARED(mnt);\r\nreturn 0;\r\n}\r\nvoid change_mnt_propagation(struct vfsmount *mnt, int type)\r\n{\r\nif (type == MS_SHARED) {\r\nset_mnt_shared(mnt);\r\nreturn;\r\n}\r\ndo_make_slave(mnt);\r\nif (type != MS_SLAVE) {\r\nlist_del_init(&mnt->mnt_slave);\r\nmnt->mnt_master = NULL;\r\nif (type == MS_UNBINDABLE)\r\nmnt->mnt_flags |= MNT_UNBINDABLE;\r\nelse\r\nmnt->mnt_flags &= ~MNT_UNBINDABLE;\r\n}\r\n}\r\nstatic struct vfsmount *propagation_next(struct vfsmount *m,\r\nstruct vfsmount *origin)\r\n{\r\nif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\r\nreturn first_slave(m);\r\nwhile (1) {\r\nstruct vfsmount *next;\r\nstruct vfsmount *master = m->mnt_master;\r\nif (master == origin->mnt_master) {\r\nnext = next_peer(m);\r\nreturn ((next == origin) ? NULL : next);\r\n} else if (m->mnt_slave.next != &master->mnt_slave_list)\r\nreturn next_slave(m);\r\nm = master;\r\n}\r\n}\r\nstatic struct vfsmount *get_source(struct vfsmount *dest,\r\nstruct vfsmount *last_dest,\r\nstruct vfsmount *last_src,\r\nint *type)\r\n{\r\nstruct vfsmount *p_last_src = NULL;\r\nstruct vfsmount *p_last_dest = NULL;\r\nwhile (last_dest != dest->mnt_master) {\r\np_last_dest = last_dest;\r\np_last_src = last_src;\r\nlast_dest = last_dest->mnt_master;\r\nlast_src = last_src->mnt_master;\r\n}\r\nif (p_last_dest) {\r\ndo {\r\np_last_dest = next_peer(p_last_dest);\r\n} while (IS_MNT_NEW(p_last_dest));\r\nif (dest == p_last_dest) {\r\n*type = CL_MAKE_SHARED;\r\nreturn p_last_src;\r\n}\r\n}\r\n*type = CL_SLAVE;\r\nif (IS_MNT_SHARED(dest))\r\n*type |= CL_MAKE_SHARED;\r\nreturn last_src;\r\n}\r\nint propagate_mnt(struct vfsmount *dest_mnt, struct dentry *dest_dentry,\r\nstruct vfsmount *source_mnt, struct list_head *tree_list)\r\n{\r\nstruct vfsmount *m, *child;\r\nint ret = 0;\r\nstruct vfsmount *prev_dest_mnt = dest_mnt;\r\nstruct vfsmount *prev_src_mnt = source_mnt;\r\nLIST_HEAD(tmp_list);\r\nLIST_HEAD(umount_list);\r\nfor (m = propagation_next(dest_mnt, dest_mnt); m;\r\nm = propagation_next(m, dest_mnt)) {\r\nint type;\r\nstruct vfsmount *source;\r\nif (IS_MNT_NEW(m))\r\ncontinue;\r\nsource = get_source(m, prev_dest_mnt, prev_src_mnt, &type);\r\nif (!(child = copy_tree(source, source->mnt_root, type))) {\r\nret = -ENOMEM;\r\nlist_splice(tree_list, tmp_list.prev);\r\ngoto out;\r\n}\r\nif (is_subdir(dest_dentry, m->mnt_root)) {\r\nmnt_set_mountpoint(m, dest_dentry, child);\r\nlist_add_tail(&child->mnt_hash, tree_list);\r\n} else {\r\nlist_add_tail(&child->mnt_hash, &tmp_list);\r\n}\r\nprev_dest_mnt = m;\r\nprev_src_mnt = child;\r\n}\r\nout:\r\nbr_write_lock(vfsmount_lock);\r\nwhile (!list_empty(&tmp_list)) {\r\nchild = list_first_entry(&tmp_list, struct vfsmount, mnt_hash);\r\numount_tree(child, 0, &umount_list);\r\n}\r\nbr_write_unlock(vfsmount_lock);\r\nrelease_mounts(&umount_list);\r\nreturn ret;\r\n}\r\nstatic inline int do_refcount_check(struct vfsmount *mnt, int count)\r\n{\r\nint mycount = mnt_get_count(mnt) - mnt->mnt_ghosts;\r\nreturn (mycount > count);\r\n}\r\nint propagate_mount_busy(struct vfsmount *mnt, int refcnt)\r\n{\r\nstruct vfsmount *m, *child;\r\nstruct vfsmount *parent = mnt->mnt_parent;\r\nint ret = 0;\r\nif (mnt == parent)\r\nreturn do_refcount_check(mnt, refcnt);\r\nif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\r\nreturn 1;\r\nfor (m = propagation_next(parent, parent); m;\r\nm = propagation_next(m, parent)) {\r\nchild = __lookup_mnt(m, mnt->mnt_mountpoint, 0);\r\nif (child && list_empty(&child->mnt_mounts) &&\r\n(ret = do_refcount_check(child, 1)))\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __propagate_umount(struct vfsmount *mnt)\r\n{\r\nstruct vfsmount *parent = mnt->mnt_parent;\r\nstruct vfsmount *m;\r\nBUG_ON(parent == mnt);\r\nfor (m = propagation_next(parent, parent); m;\r\nm = propagation_next(m, parent)) {\r\nstruct vfsmount *child = __lookup_mnt(m,\r\nmnt->mnt_mountpoint, 0);\r\nif (child && list_empty(&child->mnt_mounts))\r\nlist_move_tail(&child->mnt_hash, &mnt->mnt_hash);\r\n}\r\n}\r\nint propagate_umount(struct list_head *list)\r\n{\r\nstruct vfsmount *mnt;\r\nlist_for_each_entry(mnt, list, mnt_hash)\r\n__propagate_umount(mnt);\r\nreturn 0;\r\n}
