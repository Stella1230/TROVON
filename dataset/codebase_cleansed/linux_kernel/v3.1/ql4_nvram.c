static inline void eeprom_cmd(uint32_t cmd, struct scsi_qla_host *ha)\r\n{\r\nwritel(cmd, isp_nvram(ha));\r\nreadl(isp_nvram(ha));\r\nudelay(1);\r\n}\r\nstatic inline int eeprom_size(struct scsi_qla_host *ha)\r\n{\r\nreturn is_qla4010(ha) ? FM93C66A_SIZE_16 : FM93C86A_SIZE_16;\r\n}\r\nstatic inline int eeprom_no_addr_bits(struct scsi_qla_host *ha)\r\n{\r\nreturn is_qla4010(ha) ? FM93C56A_NO_ADDR_BITS_16 :\r\nFM93C86A_NO_ADDR_BITS_16 ;\r\n}\r\nstatic inline int eeprom_no_data_bits(struct scsi_qla_host *ha)\r\n{\r\nreturn FM93C56A_DATA_BITS_16;\r\n}\r\nstatic int fm93c56a_select(struct scsi_qla_host * ha)\r\n{\r\nDEBUG5(printk(KERN_ERR "fm93c56a_select:\n"));\r\nha->eeprom_cmd_data = AUBURN_EEPROM_CS_1 | 0x000f0000;\r\neeprom_cmd(ha->eeprom_cmd_data, ha);\r\nreturn 1;\r\n}\r\nstatic int fm93c56a_cmd(struct scsi_qla_host * ha, int cmd, int addr)\r\n{\r\nint i;\r\nint mask;\r\nint dataBit;\r\nint previousBit;\r\neeprom_cmd(ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1, ha);\r\neeprom_cmd(ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1 |\r\nAUBURN_EEPROM_CLK_RISE, ha);\r\neeprom_cmd(ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1 |\r\nAUBURN_EEPROM_CLK_FALL, ha);\r\nmask = 1 << (FM93C56A_CMD_BITS - 1);\r\npreviousBit = 0xffff;\r\nfor (i = 0; i < FM93C56A_CMD_BITS; i++) {\r\ndataBit =\r\n(cmd & mask) ? AUBURN_EEPROM_DO_1 : AUBURN_EEPROM_DO_0;\r\nif (previousBit != dataBit) {\r\neeprom_cmd(ha->eeprom_cmd_data | dataBit, ha);\r\npreviousBit = dataBit;\r\n}\r\neeprom_cmd(ha->eeprom_cmd_data | dataBit |\r\nAUBURN_EEPROM_CLK_RISE, ha);\r\neeprom_cmd(ha->eeprom_cmd_data | dataBit |\r\nAUBURN_EEPROM_CLK_FALL, ha);\r\ncmd = cmd << 1;\r\n}\r\nmask = 1 << (eeprom_no_addr_bits(ha) - 1);\r\npreviousBit = 0xffff;\r\nfor (i = 0; i < eeprom_no_addr_bits(ha); i++) {\r\ndataBit = addr & mask ? AUBURN_EEPROM_DO_1 :\r\nAUBURN_EEPROM_DO_0;\r\nif (previousBit != dataBit) {\r\neeprom_cmd(ha->eeprom_cmd_data | dataBit, ha);\r\npreviousBit = dataBit;\r\n}\r\neeprom_cmd(ha->eeprom_cmd_data | dataBit |\r\nAUBURN_EEPROM_CLK_RISE, ha);\r\neeprom_cmd(ha->eeprom_cmd_data | dataBit |\r\nAUBURN_EEPROM_CLK_FALL, ha);\r\naddr = addr << 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int fm93c56a_deselect(struct scsi_qla_host * ha)\r\n{\r\nha->eeprom_cmd_data = AUBURN_EEPROM_CS_0 | 0x000f0000;\r\neeprom_cmd(ha->eeprom_cmd_data, ha);\r\nreturn 1;\r\n}\r\nstatic int fm93c56a_datain(struct scsi_qla_host * ha, unsigned short *value)\r\n{\r\nint i;\r\nint data = 0;\r\nint dataBit;\r\nfor (i = 0; i < eeprom_no_data_bits(ha); i++) {\r\neeprom_cmd(ha->eeprom_cmd_data |\r\nAUBURN_EEPROM_CLK_RISE, ha);\r\neeprom_cmd(ha->eeprom_cmd_data |\r\nAUBURN_EEPROM_CLK_FALL, ha);\r\ndataBit = (readw(isp_nvram(ha)) & AUBURN_EEPROM_DI_1) ? 1 : 0;\r\ndata = (data << 1) | dataBit;\r\n}\r\n*value = data;\r\nreturn 1;\r\n}\r\nstatic int eeprom_readword(int eepromAddr, u16 * value,\r\nstruct scsi_qla_host * ha)\r\n{\r\nfm93c56a_select(ha);\r\nfm93c56a_cmd(ha, FM93C56A_READ, eepromAddr);\r\nfm93c56a_datain(ha, value);\r\nfm93c56a_deselect(ha);\r\nreturn 1;\r\n}\r\nu16 rd_nvram_word(struct scsi_qla_host * ha, int offset)\r\n{\r\nu16 val = 0;\r\neeprom_readword(offset, &val, ha);\r\nreturn val;\r\n}\r\nint qla4xxx_is_nvram_configuration_valid(struct scsi_qla_host * ha)\r\n{\r\nint status = QLA_ERROR;\r\nuint16_t checksum = 0;\r\nuint32_t index;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (index = 0; index < eeprom_size(ha); index++)\r\nchecksum += rd_nvram_word(ha, index);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (checksum == 0)\r\nstatus = QLA_SUCCESS;\r\nreturn status;\r\n}\r\nint ql4xxx_sem_spinlock(struct scsi_qla_host * ha, u32 sem_mask, u32 sem_bits)\r\n{\r\nuint32_t value;\r\nunsigned long flags;\r\nunsigned int seconds = 30;\r\nDEBUG2(printk("scsi%ld : Trying to get SEM lock - mask= 0x%x, code = "\r\n"0x%x\n", ha->host_no, sem_mask, sem_bits));\r\ndo {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel((sem_mask | sem_bits), isp_semaphore(ha));\r\nvalue = readw(isp_semaphore(ha));\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif ((value & (sem_mask >> 16)) == sem_bits) {\r\nDEBUG2(printk("scsi%ld : Got SEM LOCK - mask= 0x%x, "\r\n"code = 0x%x\n", ha->host_no,\r\nsem_mask, sem_bits));\r\nreturn QLA_SUCCESS;\r\n}\r\nssleep(1);\r\n} while (--seconds);\r\nreturn QLA_ERROR;\r\n}\r\nvoid ql4xxx_sem_unlock(struct scsi_qla_host * ha, u32 sem_mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel(sem_mask, isp_semaphore(ha));\r\nreadl(isp_semaphore(ha));\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nDEBUG2(printk("scsi%ld : UNLOCK SEM - mask= 0x%x\n", ha->host_no,\r\nsem_mask));\r\n}\r\nint ql4xxx_sem_lock(struct scsi_qla_host * ha, u32 sem_mask, u32 sem_bits)\r\n{\r\nuint32_t value;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel((sem_mask | sem_bits), isp_semaphore(ha));\r\nvalue = readw(isp_semaphore(ha));\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif ((value & (sem_mask >> 16)) == sem_bits) {\r\nDEBUG2(printk("scsi%ld : Got SEM LOCK - mask= 0x%x, code = "\r\n"0x%x, sema code=0x%x\n", ha->host_no,\r\nsem_mask, sem_bits, value));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
