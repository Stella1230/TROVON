static inline struct kvm_coalesced_mmio_dev *to_mmio(struct kvm_io_device *dev)\r\n{\r\nreturn container_of(dev, struct kvm_coalesced_mmio_dev, dev);\r\n}\r\nstatic int coalesced_mmio_in_range(struct kvm_coalesced_mmio_dev *dev,\r\ngpa_t addr, int len)\r\n{\r\nstruct kvm_coalesced_mmio_zone *zone;\r\nstruct kvm_coalesced_mmio_ring *ring;\r\nunsigned avail;\r\nint i;\r\nring = dev->kvm->coalesced_mmio_ring;\r\navail = (ring->first - ring->last - 1) % KVM_COALESCED_MMIO_MAX;\r\nif (avail < KVM_MAX_VCPUS) {\r\nreturn 0;\r\n}\r\nfor (i = 0; i < dev->nb_zones; i++) {\r\nzone = &dev->zone[i];\r\nif (zone->addr <= addr &&\r\naddr + len <= zone->addr + zone->size)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int coalesced_mmio_write(struct kvm_io_device *this,\r\ngpa_t addr, int len, const void *val)\r\n{\r\nstruct kvm_coalesced_mmio_dev *dev = to_mmio(this);\r\nstruct kvm_coalesced_mmio_ring *ring = dev->kvm->coalesced_mmio_ring;\r\nif (!coalesced_mmio_in_range(dev, addr, len))\r\nreturn -EOPNOTSUPP;\r\nspin_lock(&dev->lock);\r\nring->coalesced_mmio[ring->last].phys_addr = addr;\r\nring->coalesced_mmio[ring->last].len = len;\r\nmemcpy(ring->coalesced_mmio[ring->last].data, val, len);\r\nsmp_wmb();\r\nring->last = (ring->last + 1) % KVM_COALESCED_MMIO_MAX;\r\nspin_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic void coalesced_mmio_destructor(struct kvm_io_device *this)\r\n{\r\nstruct kvm_coalesced_mmio_dev *dev = to_mmio(this);\r\nkfree(dev);\r\n}\r\nint kvm_coalesced_mmio_init(struct kvm *kvm)\r\n{\r\nstruct kvm_coalesced_mmio_dev *dev;\r\nstruct page *page;\r\nint ret;\r\nret = -ENOMEM;\r\npage = alloc_page(GFP_KERNEL | __GFP_ZERO);\r\nif (!page)\r\ngoto out_err;\r\nkvm->coalesced_mmio_ring = page_address(page);\r\nret = -ENOMEM;\r\ndev = kzalloc(sizeof(struct kvm_coalesced_mmio_dev), GFP_KERNEL);\r\nif (!dev)\r\ngoto out_free_page;\r\nspin_lock_init(&dev->lock);\r\nkvm_iodevice_init(&dev->dev, &coalesced_mmio_ops);\r\ndev->kvm = kvm;\r\nkvm->coalesced_mmio_dev = dev;\r\nmutex_lock(&kvm->slots_lock);\r\nret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, &dev->dev);\r\nmutex_unlock(&kvm->slots_lock);\r\nif (ret < 0)\r\ngoto out_free_dev;\r\nreturn ret;\r\nout_free_dev:\r\nkvm->coalesced_mmio_dev = NULL;\r\nkfree(dev);\r\nout_free_page:\r\nkvm->coalesced_mmio_ring = NULL;\r\n__free_page(page);\r\nout_err:\r\nreturn ret;\r\n}\r\nvoid kvm_coalesced_mmio_free(struct kvm *kvm)\r\n{\r\nif (kvm->coalesced_mmio_ring)\r\nfree_page((unsigned long)kvm->coalesced_mmio_ring);\r\n}\r\nint kvm_vm_ioctl_register_coalesced_mmio(struct kvm *kvm,\r\nstruct kvm_coalesced_mmio_zone *zone)\r\n{\r\nstruct kvm_coalesced_mmio_dev *dev = kvm->coalesced_mmio_dev;\r\nif (dev == NULL)\r\nreturn -ENXIO;\r\nmutex_lock(&kvm->slots_lock);\r\nif (dev->nb_zones >= KVM_COALESCED_MMIO_ZONE_MAX) {\r\nmutex_unlock(&kvm->slots_lock);\r\nreturn -ENOBUFS;\r\n}\r\ndev->zone[dev->nb_zones] = *zone;\r\ndev->nb_zones++;\r\nmutex_unlock(&kvm->slots_lock);\r\nreturn 0;\r\n}\r\nint kvm_vm_ioctl_unregister_coalesced_mmio(struct kvm *kvm,\r\nstruct kvm_coalesced_mmio_zone *zone)\r\n{\r\nint i;\r\nstruct kvm_coalesced_mmio_dev *dev = kvm->coalesced_mmio_dev;\r\nstruct kvm_coalesced_mmio_zone *z;\r\nif (dev == NULL)\r\nreturn -ENXIO;\r\nmutex_lock(&kvm->slots_lock);\r\ni = dev->nb_zones;\r\nwhile (i) {\r\nz = &dev->zone[i - 1];\r\nif (zone->addr <= z->addr &&\r\nz->addr + z->size <= zone->addr + zone->size) {\r\ndev->nb_zones--;\r\n*z = dev->zone[dev->nb_zones];\r\n}\r\ni--;\r\n}\r\nmutex_unlock(&kvm->slots_lock);\r\nreturn 0;\r\n}
