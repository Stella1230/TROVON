static int ceph_x_is_authenticated(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nint need;\r\nceph_x_validate_tickets(ac, &need);\r\ndout("ceph_x_is_authenticated want=%d need=%d have=%d\n",\r\nac->want_keys, need, xi->have_keys);\r\nreturn (ac->want_keys & xi->have_keys) == ac->want_keys;\r\n}\r\nstatic int ceph_x_should_authenticate(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nint need;\r\nceph_x_validate_tickets(ac, &need);\r\ndout("ceph_x_should_authenticate want=%d need=%d have=%d\n",\r\nac->want_keys, need, xi->have_keys);\r\nreturn need != 0;\r\n}\r\nstatic int ceph_x_encrypt_buflen(int ilen)\r\n{\r\nreturn sizeof(struct ceph_x_encrypt_header) + ilen + 16 +\r\nsizeof(u32);\r\n}\r\nstatic int ceph_x_encrypt(struct ceph_crypto_key *secret,\r\nvoid *ibuf, int ilen, void *obuf, size_t olen)\r\n{\r\nstruct ceph_x_encrypt_header head = {\r\n.struct_v = 1,\r\n.magic = cpu_to_le64(CEPHX_ENC_MAGIC)\r\n};\r\nsize_t len = olen - sizeof(u32);\r\nint ret;\r\nret = ceph_encrypt2(secret, obuf + sizeof(u32), &len,\r\n&head, sizeof(head), ibuf, ilen);\r\nif (ret)\r\nreturn ret;\r\nceph_encode_32(&obuf, len);\r\nreturn len + sizeof(u32);\r\n}\r\nstatic int ceph_x_decrypt(struct ceph_crypto_key *secret,\r\nvoid **p, void *end, void *obuf, size_t olen)\r\n{\r\nstruct ceph_x_encrypt_header head;\r\nsize_t head_len = sizeof(head);\r\nint len, ret;\r\nlen = ceph_decode_32(p);\r\nif (*p + len > end)\r\nreturn -EINVAL;\r\ndout("ceph_x_decrypt len %d\n", len);\r\nret = ceph_decrypt2(secret, &head, &head_len, obuf, &olen,\r\n*p, len);\r\nif (ret)\r\nreturn ret;\r\nif (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)\r\nreturn -EPERM;\r\n*p += len;\r\nreturn olen;\r\n}\r\nstatic struct ceph_x_ticket_handler *\r\nget_ticket_handler(struct ceph_auth_client *ac, int service)\r\n{\r\nstruct ceph_x_ticket_handler *th;\r\nstruct ceph_x_info *xi = ac->private;\r\nstruct rb_node *parent = NULL, **p = &xi->ticket_handlers.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nth = rb_entry(parent, struct ceph_x_ticket_handler, node);\r\nif (service < th->service)\r\np = &(*p)->rb_left;\r\nelse if (service > th->service)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn th;\r\n}\r\nth = kzalloc(sizeof(*th), GFP_NOFS);\r\nif (!th)\r\nreturn ERR_PTR(-ENOMEM);\r\nth->service = service;\r\nrb_link_node(&th->node, parent, p);\r\nrb_insert_color(&th->node, &xi->ticket_handlers);\r\nreturn th;\r\n}\r\nstatic void remove_ticket_handler(struct ceph_auth_client *ac,\r\nstruct ceph_x_ticket_handler *th)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\ndout("remove_ticket_handler %p %d\n", th, th->service);\r\nrb_erase(&th->node, &xi->ticket_handlers);\r\nceph_crypto_key_destroy(&th->session_key);\r\nif (th->ticket_blob)\r\nceph_buffer_put(th->ticket_blob);\r\nkfree(th);\r\n}\r\nstatic int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\r\nstruct ceph_crypto_key *secret,\r\nvoid *buf, void *end)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nint num;\r\nvoid *p = buf;\r\nint ret;\r\nchar *dbuf;\r\nchar *ticket_buf;\r\nu8 reply_struct_v;\r\ndbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\r\nif (!dbuf)\r\nreturn -ENOMEM;\r\nret = -ENOMEM;\r\nticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\r\nif (!ticket_buf)\r\ngoto out_dbuf;\r\nceph_decode_need(&p, end, 1 + sizeof(u32), bad);\r\nreply_struct_v = ceph_decode_8(&p);\r\nif (reply_struct_v != 1)\r\ngoto bad;\r\nnum = ceph_decode_32(&p);\r\ndout("%d tickets\n", num);\r\nwhile (num--) {\r\nint type;\r\nu8 tkt_struct_v, blob_struct_v;\r\nstruct ceph_x_ticket_handler *th;\r\nvoid *dp, *dend;\r\nint dlen;\r\nchar is_enc;\r\nstruct timespec validity;\r\nstruct ceph_crypto_key old_key;\r\nvoid *tp, *tpend;\r\nstruct ceph_timespec new_validity;\r\nstruct ceph_crypto_key new_session_key;\r\nstruct ceph_buffer *new_ticket_blob;\r\nunsigned long new_expires, new_renew_after;\r\nu64 new_secret_id;\r\nceph_decode_need(&p, end, sizeof(u32) + 1, bad);\r\ntype = ceph_decode_32(&p);\r\ndout(" ticket type %d %s\n", type, ceph_entity_type_name(type));\r\ntkt_struct_v = ceph_decode_8(&p);\r\nif (tkt_struct_v != 1)\r\ngoto bad;\r\nth = get_ticket_handler(ac, type);\r\nif (IS_ERR(th)) {\r\nret = PTR_ERR(th);\r\ngoto out;\r\n}\r\ndlen = ceph_x_decrypt(secret, &p, end, dbuf,\r\nTEMP_TICKET_BUF_LEN);\r\nif (dlen <= 0) {\r\nret = dlen;\r\ngoto out;\r\n}\r\ndout(" decrypted %d bytes\n", dlen);\r\ndend = dbuf + dlen;\r\ndp = dbuf;\r\ntkt_struct_v = ceph_decode_8(&dp);\r\nif (tkt_struct_v != 1)\r\ngoto bad;\r\nmemcpy(&old_key, &th->session_key, sizeof(old_key));\r\nret = ceph_crypto_key_decode(&new_session_key, &dp, dend);\r\nif (ret)\r\ngoto out;\r\nceph_decode_copy(&dp, &new_validity, sizeof(new_validity));\r\nceph_decode_timespec(&validity, &new_validity);\r\nnew_expires = get_seconds() + validity.tv_sec;\r\nnew_renew_after = new_expires - (validity.tv_sec / 4);\r\ndout(" expires=%lu renew_after=%lu\n", new_expires,\r\nnew_renew_after);\r\nceph_decode_8_safe(&p, end, is_enc, bad);\r\ntp = ticket_buf;\r\nif (is_enc) {\r\ndout(" encrypted ticket\n");\r\ndlen = ceph_x_decrypt(&old_key, &p, end, ticket_buf,\r\nTEMP_TICKET_BUF_LEN);\r\nif (dlen < 0) {\r\nret = dlen;\r\ngoto out;\r\n}\r\ndlen = ceph_decode_32(&tp);\r\n} else {\r\nceph_decode_32_safe(&p, end, dlen, bad);\r\nceph_decode_need(&p, end, dlen, bad);\r\nceph_decode_copy(&p, ticket_buf, dlen);\r\n}\r\ntpend = tp + dlen;\r\ndout(" ticket blob is %d bytes\n", dlen);\r\nceph_decode_need(&tp, tpend, 1 + sizeof(u64), bad);\r\nblob_struct_v = ceph_decode_8(&tp);\r\nnew_secret_id = ceph_decode_64(&tp);\r\nret = ceph_decode_buffer(&new_ticket_blob, &tp, tpend);\r\nif (ret)\r\ngoto out;\r\nceph_crypto_key_destroy(&th->session_key);\r\nif (th->ticket_blob)\r\nceph_buffer_put(th->ticket_blob);\r\nth->session_key = new_session_key;\r\nth->ticket_blob = new_ticket_blob;\r\nth->validity = new_validity;\r\nth->secret_id = new_secret_id;\r\nth->expires = new_expires;\r\nth->renew_after = new_renew_after;\r\ndout(" got ticket service %d (%s) secret_id %lld len %d\n",\r\ntype, ceph_entity_type_name(type), th->secret_id,\r\n(int)th->ticket_blob->vec.iov_len);\r\nxi->have_keys |= th->service;\r\n}\r\nret = 0;\r\nout:\r\nkfree(ticket_buf);\r\nout_dbuf:\r\nkfree(dbuf);\r\nreturn ret;\r\nbad:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nstatic int ceph_x_build_authorizer(struct ceph_auth_client *ac,\r\nstruct ceph_x_ticket_handler *th,\r\nstruct ceph_x_authorizer *au)\r\n{\r\nint maxlen;\r\nstruct ceph_x_authorize_a *msg_a;\r\nstruct ceph_x_authorize_b msg_b;\r\nvoid *p, *end;\r\nint ret;\r\nint ticket_blob_len =\r\n(th->ticket_blob ? th->ticket_blob->vec.iov_len : 0);\r\ndout("build_authorizer for %s %p\n",\r\nceph_entity_type_name(th->service), au);\r\nmaxlen = sizeof(*msg_a) + sizeof(msg_b) +\r\nceph_x_encrypt_buflen(ticket_blob_len);\r\ndout(" need len %d\n", maxlen);\r\nif (au->buf && au->buf->alloc_len < maxlen) {\r\nceph_buffer_put(au->buf);\r\nau->buf = NULL;\r\n}\r\nif (!au->buf) {\r\nau->buf = ceph_buffer_new(maxlen, GFP_NOFS);\r\nif (!au->buf)\r\nreturn -ENOMEM;\r\n}\r\nau->service = th->service;\r\nmsg_a = au->buf->vec.iov_base;\r\nmsg_a->struct_v = 1;\r\nmsg_a->global_id = cpu_to_le64(ac->global_id);\r\nmsg_a->service_id = cpu_to_le32(th->service);\r\nmsg_a->ticket_blob.struct_v = 1;\r\nmsg_a->ticket_blob.secret_id = cpu_to_le64(th->secret_id);\r\nmsg_a->ticket_blob.blob_len = cpu_to_le32(ticket_blob_len);\r\nif (ticket_blob_len) {\r\nmemcpy(msg_a->ticket_blob.blob, th->ticket_blob->vec.iov_base,\r\nth->ticket_blob->vec.iov_len);\r\n}\r\ndout(" th %p secret_id %lld %lld\n", th, th->secret_id,\r\nle64_to_cpu(msg_a->ticket_blob.secret_id));\r\np = msg_a + 1;\r\np += ticket_blob_len;\r\nend = au->buf->vec.iov_base + au->buf->vec.iov_len;\r\nget_random_bytes(&au->nonce, sizeof(au->nonce));\r\nmsg_b.struct_v = 1;\r\nmsg_b.nonce = cpu_to_le64(au->nonce);\r\nret = ceph_x_encrypt(&th->session_key, &msg_b, sizeof(msg_b),\r\np, end - p);\r\nif (ret < 0)\r\ngoto out_buf;\r\np += ret;\r\nau->buf->vec.iov_len = p - au->buf->vec.iov_base;\r\ndout(" built authorizer nonce %llx len %d\n", au->nonce,\r\n(int)au->buf->vec.iov_len);\r\nBUG_ON(au->buf->vec.iov_len > maxlen);\r\nreturn 0;\r\nout_buf:\r\nceph_buffer_put(au->buf);\r\nau->buf = NULL;\r\nreturn ret;\r\n}\r\nstatic int ceph_x_encode_ticket(struct ceph_x_ticket_handler *th,\r\nvoid **p, void *end)\r\n{\r\nceph_decode_need(p, end, 1 + sizeof(u64), bad);\r\nceph_encode_8(p, 1);\r\nceph_encode_64(p, th->secret_id);\r\nif (th->ticket_blob) {\r\nconst char *buf = th->ticket_blob->vec.iov_base;\r\nu32 len = th->ticket_blob->vec.iov_len;\r\nceph_encode_32_safe(p, end, len, bad);\r\nceph_encode_copy_safe(p, end, buf, len, bad);\r\n} else {\r\nceph_encode_32_safe(p, end, 0, bad);\r\n}\r\nreturn 0;\r\nbad:\r\nreturn -ERANGE;\r\n}\r\nstatic void ceph_x_validate_tickets(struct ceph_auth_client *ac, int *pneed)\r\n{\r\nint want = ac->want_keys;\r\nstruct ceph_x_info *xi = ac->private;\r\nint service;\r\n*pneed = ac->want_keys & ~(xi->have_keys);\r\nfor (service = 1; service <= want; service <<= 1) {\r\nstruct ceph_x_ticket_handler *th;\r\nif (!(ac->want_keys & service))\r\ncontinue;\r\nif (*pneed & service)\r\ncontinue;\r\nth = get_ticket_handler(ac, service);\r\nif (IS_ERR(th)) {\r\n*pneed |= service;\r\ncontinue;\r\n}\r\nif (get_seconds() >= th->renew_after)\r\n*pneed |= service;\r\nif (get_seconds() >= th->expires)\r\nxi->have_keys &= ~service;\r\n}\r\n}\r\nstatic int ceph_x_build_request(struct ceph_auth_client *ac,\r\nvoid *buf, void *end)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nint need;\r\nstruct ceph_x_request_header *head = buf;\r\nint ret;\r\nstruct ceph_x_ticket_handler *th =\r\nget_ticket_handler(ac, CEPH_ENTITY_TYPE_AUTH);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nceph_x_validate_tickets(ac, &need);\r\ndout("build_request want %x have %x need %x\n",\r\nac->want_keys, xi->have_keys, need);\r\nif (need & CEPH_ENTITY_TYPE_AUTH) {\r\nstruct ceph_x_authenticate *auth = (void *)(head + 1);\r\nvoid *p = auth + 1;\r\nstruct ceph_x_challenge_blob tmp;\r\nchar tmp_enc[40];\r\nu64 *u;\r\nif (p > end)\r\nreturn -ERANGE;\r\ndout(" get_auth_session_key\n");\r\nhead->op = cpu_to_le16(CEPHX_GET_AUTH_SESSION_KEY);\r\nget_random_bytes(&auth->client_challenge, sizeof(u64));\r\ntmp.client_challenge = auth->client_challenge;\r\ntmp.server_challenge = cpu_to_le64(xi->server_challenge);\r\nret = ceph_x_encrypt(&xi->secret, &tmp, sizeof(tmp),\r\ntmp_enc, sizeof(tmp_enc));\r\nif (ret < 0)\r\nreturn ret;\r\nauth->struct_v = 1;\r\nauth->key = 0;\r\nfor (u = (u64 *)tmp_enc; u + 1 <= (u64 *)(tmp_enc + ret); u++)\r\nauth->key ^= *(__le64 *)u;\r\ndout(" server_challenge %llx client_challenge %llx key %llx\n",\r\nxi->server_challenge, le64_to_cpu(auth->client_challenge),\r\nle64_to_cpu(auth->key));\r\nret = ceph_x_encode_ticket(th, &p, end);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn p - buf;\r\n}\r\nif (need) {\r\nvoid *p = head + 1;\r\nstruct ceph_x_service_ticket_request *req;\r\nif (p > end)\r\nreturn -ERANGE;\r\nhead->op = cpu_to_le16(CEPHX_GET_PRINCIPAL_SESSION_KEY);\r\nret = ceph_x_build_authorizer(ac, th, &xi->auth_authorizer);\r\nif (ret)\r\nreturn ret;\r\nceph_encode_copy(&p, xi->auth_authorizer.buf->vec.iov_base,\r\nxi->auth_authorizer.buf->vec.iov_len);\r\nreq = p;\r\nreq->keys = cpu_to_le32(need);\r\np += sizeof(*req);\r\nreturn p - buf;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ceph_x_handle_reply(struct ceph_auth_client *ac, int result,\r\nvoid *buf, void *end)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nstruct ceph_x_reply_header *head = buf;\r\nstruct ceph_x_ticket_handler *th;\r\nint len = end - buf;\r\nint op;\r\nint ret;\r\nif (result)\r\nreturn result;\r\nif (xi->starting) {\r\nstruct ceph_x_server_challenge *sc = buf;\r\nif (len != sizeof(*sc))\r\nreturn -EINVAL;\r\nxi->server_challenge = le64_to_cpu(sc->server_challenge);\r\ndout("handle_reply got server challenge %llx\n",\r\nxi->server_challenge);\r\nxi->starting = false;\r\nxi->have_keys &= ~CEPH_ENTITY_TYPE_AUTH;\r\nreturn -EAGAIN;\r\n}\r\nop = le16_to_cpu(head->op);\r\nresult = le32_to_cpu(head->result);\r\ndout("handle_reply op %d result %d\n", op, result);\r\nswitch (op) {\r\ncase CEPHX_GET_AUTH_SESSION_KEY:\r\nret = ceph_x_proc_ticket_reply(ac, &xi->secret,\r\nbuf + sizeof(*head), end);\r\nbreak;\r\ncase CEPHX_GET_PRINCIPAL_SESSION_KEY:\r\nth = get_ticket_handler(ac, CEPH_ENTITY_TYPE_AUTH);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nret = ceph_x_proc_ticket_reply(ac, &th->session_key,\r\nbuf + sizeof(*head), end);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (ac->want_keys == xi->have_keys)\r\nreturn 0;\r\nreturn -EAGAIN;\r\n}\r\nstatic int ceph_x_create_authorizer(\r\nstruct ceph_auth_client *ac, int peer_type,\r\nstruct ceph_authorizer **a,\r\nvoid **buf, size_t *len,\r\nvoid **reply_buf, size_t *reply_len)\r\n{\r\nstruct ceph_x_authorizer *au;\r\nstruct ceph_x_ticket_handler *th;\r\nint ret;\r\nth = get_ticket_handler(ac, peer_type);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nau = kzalloc(sizeof(*au), GFP_NOFS);\r\nif (!au)\r\nreturn -ENOMEM;\r\nret = ceph_x_build_authorizer(ac, th, au);\r\nif (ret) {\r\nkfree(au);\r\nreturn ret;\r\n}\r\n*a = (struct ceph_authorizer *)au;\r\n*buf = au->buf->vec.iov_base;\r\n*len = au->buf->vec.iov_len;\r\n*reply_buf = au->reply_buf;\r\n*reply_len = sizeof(au->reply_buf);\r\nreturn 0;\r\n}\r\nstatic int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\r\nstruct ceph_authorizer *a, size_t len)\r\n{\r\nstruct ceph_x_authorizer *au = (void *)a;\r\nstruct ceph_x_ticket_handler *th;\r\nint ret = 0;\r\nstruct ceph_x_authorize_reply reply;\r\nvoid *p = au->reply_buf;\r\nvoid *end = p + sizeof(au->reply_buf);\r\nth = get_ticket_handler(ac, au->service);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != sizeof(reply))\r\nreturn -EPERM;\r\nif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\r\nret = -EPERM;\r\nelse\r\nret = 0;\r\ndout("verify_authorizer_reply nonce %llx got %llx ret %d\n",\r\nau->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\r\nreturn ret;\r\n}\r\nstatic void ceph_x_destroy_authorizer(struct ceph_auth_client *ac,\r\nstruct ceph_authorizer *a)\r\n{\r\nstruct ceph_x_authorizer *au = (void *)a;\r\nceph_buffer_put(au->buf);\r\nkfree(au);\r\n}\r\nstatic void ceph_x_reset(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\ndout("reset\n");\r\nxi->starting = true;\r\nxi->server_challenge = 0;\r\n}\r\nstatic void ceph_x_destroy(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nstruct rb_node *p;\r\ndout("ceph_x_destroy %p\n", ac);\r\nceph_crypto_key_destroy(&xi->secret);\r\nwhile ((p = rb_first(&xi->ticket_handlers)) != NULL) {\r\nstruct ceph_x_ticket_handler *th =\r\nrb_entry(p, struct ceph_x_ticket_handler, node);\r\nremove_ticket_handler(ac, th);\r\n}\r\nif (xi->auth_authorizer.buf)\r\nceph_buffer_put(xi->auth_authorizer.buf);\r\nkfree(ac->private);\r\nac->private = NULL;\r\n}\r\nstatic void ceph_x_invalidate_authorizer(struct ceph_auth_client *ac,\r\nint peer_type)\r\n{\r\nstruct ceph_x_ticket_handler *th;\r\nth = get_ticket_handler(ac, peer_type);\r\nif (!IS_ERR(th))\r\nremove_ticket_handler(ac, th);\r\n}\r\nint ceph_x_init(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi;\r\nint ret;\r\ndout("ceph_x_init %p\n", ac);\r\nret = -ENOMEM;\r\nxi = kzalloc(sizeof(*xi), GFP_NOFS);\r\nif (!xi)\r\ngoto out;\r\nret = -EINVAL;\r\nif (!ac->key) {\r\npr_err("no secret set (for auth_x protocol)\n");\r\ngoto out_nomem;\r\n}\r\nret = ceph_crypto_key_clone(&xi->secret, ac->key);\r\nif (ret < 0) {\r\npr_err("cannot clone key: %d\n", ret);\r\ngoto out_nomem;\r\n}\r\nxi->starting = true;\r\nxi->ticket_handlers = RB_ROOT;\r\nac->protocol = CEPH_AUTH_CEPHX;\r\nac->private = xi;\r\nac->ops = &ceph_x_ops;\r\nreturn 0;\r\nout_nomem:\r\nkfree(xi);\r\nout:\r\nreturn ret;\r\n}
