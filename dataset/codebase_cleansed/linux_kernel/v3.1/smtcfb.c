static void sm712_set_timing(struct smtcfb_info *sfb,\r\nstruct par_info *ppar_info)\r\n{\r\nint i = 0, j = 0;\r\nu32 m_nScreenStride;\r\nsmdbg("\nppar_info->width = %d ppar_info->height = %d"\r\n"sfb->fb.var.bits_per_pixel = %d ppar_info->hz = %d\n",\r\nppar_info->width, ppar_info->height,\r\nsfb->fb.var.bits_per_pixel, ppar_info->hz);\r\nfor (j = 0; j < numVGAModes; j++) {\r\nif (VGAMode[j].mmSizeX == ppar_info->width &&\r\nVGAMode[j].mmSizeY == ppar_info->height &&\r\nVGAMode[j].bpp == sfb->fb.var.bits_per_pixel &&\r\nVGAMode[j].hz == ppar_info->hz) {\r\nsmdbg("\nVGAMode[j].mmSizeX = %d VGAMode[j].mmSizeY ="\r\n"%d VGAMode[j].bpp = %d"\r\n"VGAMode[j].hz=%d\n",\r\nVGAMode[j].mmSizeX, VGAMode[j].mmSizeY,\r\nVGAMode[j].bpp, VGAMode[j].hz);\r\nsmdbg("VGAMode index=%d\n", j);\r\nsmtc_mmiowb(0x0, 0x3c6);\r\nsmtc_seqw(0, 0x1);\r\nsmtc_mmiowb(VGAMode[j].Init_MISC, 0x3c2);\r\nfor (i = 0; i < SIZE_SR00_SR04; i++)\r\nsmtc_seqw(i, VGAMode[j].Init_SR00_SR04[i]);\r\nfor (i = 0; i < SIZE_SR10_SR24; i++)\r\nsmtc_seqw(i + 0x10,\r\nVGAMode[j].Init_SR10_SR24[i]);\r\nfor (i = 0; i < SIZE_SR30_SR75; i++)\r\nif (((i + 0x30) != 0x62) \\r\n&& ((i + 0x30) != 0x6a) \\r\n&& ((i + 0x30) != 0x6b))\r\nsmtc_seqw(i + 0x30,\r\nVGAMode[j].Init_SR30_SR75[i]);\r\nfor (i = 0; i < SIZE_SR80_SR93; i++)\r\nsmtc_seqw(i + 0x80,\r\nVGAMode[j].Init_SR80_SR93[i]);\r\nfor (i = 0; i < SIZE_SRA0_SRAF; i++)\r\nsmtc_seqw(i + 0xa0,\r\nVGAMode[j].Init_SRA0_SRAF[i]);\r\nfor (i = 0; i < SIZE_GR00_GR08; i++)\r\nsmtc_grphw(i, VGAMode[j].Init_GR00_GR08[i]);\r\nfor (i = 0; i < SIZE_AR00_AR14; i++)\r\nsmtc_attrw(i, VGAMode[j].Init_AR00_AR14[i]);\r\nfor (i = 0; i < SIZE_CR00_CR18; i++)\r\nsmtc_crtcw(i, VGAMode[j].Init_CR00_CR18[i]);\r\nfor (i = 0; i < SIZE_CR30_CR4D; i++)\r\nsmtc_crtcw(i + 0x30,\r\nVGAMode[j].Init_CR30_CR4D[i]);\r\nfor (i = 0; i < SIZE_CR90_CRA7; i++)\r\nsmtc_crtcw(i + 0x90,\r\nVGAMode[j].Init_CR90_CRA7[i]);\r\n}\r\n}\r\nsmtc_mmiowb(0x67, 0x3c2);\r\nwritel(0x0, ppar_info->m_pVPR + 0x0C);\r\nwritel(0x0, ppar_info->m_pVPR + 0x40);\r\nm_nScreenStride =\r\n(ppar_info->width * sfb->fb.var.bits_per_pixel) / 64;\r\nswitch (sfb->fb.var.bits_per_pixel) {\r\ncase 8:\r\nwritel(0x0, ppar_info->m_pVPR + 0x0);\r\nbreak;\r\ncase 16:\r\nwritel(0x00020000, ppar_info->m_pVPR + 0x0);\r\nbreak;\r\ncase 24:\r\nwritel(0x00040000, ppar_info->m_pVPR + 0x0);\r\nbreak;\r\ncase 32:\r\nwritel(0x00030000, ppar_info->m_pVPR + 0x0);\r\nbreak;\r\n}\r\nwritel((u32) (((m_nScreenStride + 2) << 16) | m_nScreenStride),\r\nppar_info->m_pVPR + 0x10);\r\n}\r\nstatic void sm712_setpalette(int regno, unsigned red, unsigned green,\r\nunsigned blue, struct fb_info *info)\r\n{\r\nstruct par_info *cur_par = (struct par_info *)info->par;\r\nif (cur_par->BaseAddressInVRAM)\r\nsmtc_seqw(0x66, (smtc_seqr(0x66) & 0xC3) | 0x20);\r\nelse\r\nsmtc_seqw(0x66, (smtc_seqr(0x66) & 0xC3) | 0x10);\r\nsmtc_mmiowb(regno, dac_reg);\r\nsmtc_mmiowb(red >> 10, dac_val);\r\nsmtc_mmiowb(green >> 10, dac_val);\r\nsmtc_mmiowb(blue >> 10, dac_val);\r\n}\r\nstatic void smtc_set_timing(struct smtcfb_info *sfb, struct par_info\r\n*ppar_info)\r\n{\r\nswitch (ppar_info->chipID) {\r\ncase 0x710:\r\ncase 0x712:\r\ncase 0x720:\r\nsm712_set_timing(sfb, ppar_info);\r\nbreak;\r\n}\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan,\r\nstruct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int cfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) & (~0x20)));\r\nsmtc_seqw(0x6a, 0x16);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x21, (smtc_seqr(0x21) & 0x77));\r\nsmtc_seqw(0x22, (smtc_seqr(0x22) & (~0x30)));\r\nsmtc_seqw(0x23, (smtc_seqr(0x23) & (~0xc0)));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) | 0x01));\r\nsmtc_seqw(0x31, (smtc_seqr(0x31) | 0x03));\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) & (~0x20)));\r\nsmtc_seqw(0x6a, 0x16);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x22, (smtc_seqr(0x22) & (~0x30)));\r\nsmtc_seqw(0x23, (smtc_seqr(0x23) & (~0xc0)));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) | 0x01));\r\nsmtc_seqw(0x31, ((smtc_seqr(0x31) & (~0x07)) | 0x00));\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) | 0x20));\r\nsmtc_seqw(0x20, (smtc_seqr(0x20) & (~0xB0)));\r\nsmtc_seqw(0x6a, 0x0c);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x21, (smtc_seqr(0x21) | 0x88));\r\nsmtc_seqw(0x22, ((smtc_seqr(0x22) & (~0x30)) | 0x20));\r\nsmtc_seqw(0x23, ((smtc_seqr(0x23) & (~0xc0)) | 0x20));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) & (~0x01)));\r\nsmtc_seqw(0x31, ((smtc_seqr(0x31) & (~0x07)) | 0x00));\r\nsmtc_seqw(0x34, (smtc_seqr(0x34) | 0x80));\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) | 0x20));\r\nsmtc_seqw(0x20, (smtc_seqr(0x20) & (~0xB0)));\r\nsmtc_seqw(0x6a, 0x0c);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x21, (smtc_seqr(0x21) | 0x88));\r\nsmtc_seqw(0x22, ((smtc_seqr(0x22) & (~0x30)) | 0x10));\r\nsmtc_seqw(0x23, ((smtc_seqr(0x23) & (~0xc0)) | 0xD8));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) & (~0x01)));\r\nsmtc_seqw(0x31, ((smtc_seqr(0x31) & (~0x07)) | 0x00));\r\nsmtc_seqw(0x34, (smtc_seqr(0x34) | 0x80));\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nsmtc_seqw(0x01, (smtc_seqr(0x01) | 0x20));\r\nsmtc_seqw(0x20, (smtc_seqr(0x20) & (~0xB0)));\r\nsmtc_seqw(0x6a, 0x0c);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x21, (smtc_seqr(0x21) | 0x88));\r\nsmtc_seqw(0x22, ((smtc_seqr(0x22) & (~0x30)) | 0x30));\r\nsmtc_seqw(0x23, ((smtc_seqr(0x23) & (~0xc0)) | 0xD8));\r\nsmtc_seqw(0x24, (smtc_seqr(0x24) & (~0x01)));\r\nsmtc_seqw(0x31, ((smtc_seqr(0x31) & (~0x07)) | 0x00));\r\nsmtc_seqw(0x34, (smtc_seqr(0x34) | 0x80));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smtc_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned trans, struct fb_info *info)\r\n{\r\nstruct smtcfb_info *sfb = (struct smtcfb_info *)info;\r\nu32 val;\r\nif (regno > 255)\r\nreturn 1;\r\nswitch (sfb->fb.fix.visual) {\r\ncase FB_VISUAL_DIRECTCOLOR:\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nif (sfb->fb.var.bits_per_pixel == 16) {\r\nu32 *pal = sfb->fb.pseudo_palette;\r\nval = chan_to_field(red, &sfb->fb.var.red);\r\nval |= chan_to_field(green, \\r\n&sfb->fb.var.green);\r\nval |= chan_to_field(blue, &sfb->fb.var.blue);\r\n#ifdef __BIG_ENDIAN\r\npal[regno] =\r\n((red & 0xf800) >> 8) |\r\n((green & 0xe000) >> 13) |\r\n((green & 0x1c00) << 3) |\r\n((blue & 0xf800) >> 3);\r\n#else\r\npal[regno] = val;\r\n#endif\r\n} else {\r\nu32 *pal = sfb->fb.pseudo_palette;\r\nval = chan_to_field(red, &sfb->fb.var.red);\r\nval |= chan_to_field(green, \\r\n&sfb->fb.var.green);\r\nval |= chan_to_field(blue, &sfb->fb.var.blue);\r\n#ifdef __BIG_ENDIAN\r\nval =\r\n(val & 0xff00ff00 >> 8) |\r\n(val & 0x00ff00ff << 8);\r\n#endif\r\npal[regno] = val;\r\n}\r\n}\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nsm712_setpalette(regno, red, green, blue, info);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t smtcfb_read(struct fb_info *info, char __user * buf, size_t\r\ncount, loff_t *ppos)\r\n{\r\nunsigned long p = *ppos;\r\nu32 *buffer, *dst;\r\nu32 __iomem *src;\r\nint c, i, cnt = 0, err = 0;\r\nunsigned long total_size;\r\nif (!info || !info->screen_base)\r\nreturn -ENODEV;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\ntotal_size = info->screen_size;\r\nif (total_size == 0)\r\ntotal_size = info->fix.smem_len;\r\nif (p >= total_size)\r\nreturn 0;\r\nif (count >= total_size)\r\ncount = total_size;\r\nif (count + p > total_size)\r\ncount = total_size - p;\r\nbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nsrc = (u32 __iomem *) (info->screen_base + p);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\nwhile (count) {\r\nc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\r\ndst = buffer;\r\nfor (i = c >> 2; i--;) {\r\n*dst = fb_readl(src++);\r\n*dst =\r\n(*dst & 0xff00ff00 >> 8) |\r\n(*dst & 0x00ff00ff << 8);\r\ndst++;\r\n}\r\nif (c & 3) {\r\nu8 *dst8 = (u8 *) dst;\r\nu8 __iomem *src8 = (u8 __iomem *) src;\r\nfor (i = c & 3; i--;) {\r\nif (i & 1) {\r\n*dst8++ = fb_readb(++src8);\r\n} else {\r\n*dst8++ = fb_readb(--src8);\r\nsrc8 += 2;\r\n}\r\n}\r\nsrc = (u32 __iomem *) src8;\r\n}\r\nif (copy_to_user(buf, buffer, c)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\n*ppos += c;\r\nbuf += c;\r\ncnt += c;\r\ncount -= c;\r\n}\r\nkfree(buffer);\r\nreturn (err) ? err : cnt;\r\n}\r\nstatic ssize_t\r\nsmtcfb_write(struct fb_info *info, const char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nunsigned long p = *ppos;\r\nu32 *buffer, *src;\r\nu32 __iomem *dst;\r\nint c, i, cnt = 0, err = 0;\r\nunsigned long total_size;\r\nif (!info || !info->screen_base)\r\nreturn -ENODEV;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\ntotal_size = info->screen_size;\r\nif (total_size == 0)\r\ntotal_size = info->fix.smem_len;\r\nif (p > total_size)\r\nreturn -EFBIG;\r\nif (count > total_size) {\r\nerr = -EFBIG;\r\ncount = total_size;\r\n}\r\nif (count + p > total_size) {\r\nif (!err)\r\nerr = -ENOSPC;\r\ncount = total_size - p;\r\n}\r\nbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\ndst = (u32 __iomem *) (info->screen_base + p);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\nwhile (count) {\r\nc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\r\nsrc = buffer;\r\nif (copy_from_user(src, buf, c)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nfor (i = c >> 2; i--;) {\r\nfb_writel((*src & 0xff00ff00 >> 8) |\r\n(*src & 0x00ff00ff << 8), dst++);\r\nsrc++;\r\n}\r\nif (c & 3) {\r\nu8 *src8 = (u8 *) src;\r\nu8 __iomem *dst8 = (u8 __iomem *) dst;\r\nfor (i = c & 3; i--;) {\r\nif (i & 1) {\r\nfb_writeb(*src8++, ++dst8);\r\n} else {\r\nfb_writeb(*src8++, --dst8);\r\ndst8 += 2;\r\n}\r\n}\r\ndst = (u32 __iomem *) dst8;\r\n}\r\n*ppos += c;\r\nbuf += c;\r\ncnt += c;\r\ncount -= c;\r\n}\r\nkfree(buffer);\r\nreturn (cnt) ? cnt : err;\r\n}\r\nvoid smtcfb_setmode(struct smtcfb_info *sfb)\r\n{\r\nswitch (sfb->fb.var.bits_per_pixel) {\r\ncase 32:\r\nsfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\r\nsfb->fb.fix.line_length = sfb->fb.var.xres * 4;\r\nsfb->fb.var.red.length = 8;\r\nsfb->fb.var.green.length = 8;\r\nsfb->fb.var.blue.length = 8;\r\nsfb->fb.var.red.offset = 16;\r\nsfb->fb.var.green.offset = 8;\r\nsfb->fb.var.blue.offset = 0;\r\nbreak;\r\ncase 8:\r\nsfb->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nsfb->fb.fix.line_length = sfb->fb.var.xres;\r\nsfb->fb.var.red.offset = 5;\r\nsfb->fb.var.red.length = 3;\r\nsfb->fb.var.green.offset = 2;\r\nsfb->fb.var.green.length = 3;\r\nsfb->fb.var.blue.offset = 0;\r\nsfb->fb.var.blue.length = 2;\r\nbreak;\r\ncase 24:\r\nsfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\r\nsfb->fb.fix.line_length = sfb->fb.var.xres * 3;\r\nsfb->fb.var.red.length = 8;\r\nsfb->fb.var.green.length = 8;\r\nsfb->fb.var.blue.length = 8;\r\nsfb->fb.var.red.offset = 16;\r\nsfb->fb.var.green.offset = 8;\r\nsfb->fb.var.blue.offset = 0;\r\nbreak;\r\ncase 16:\r\ndefault:\r\nsfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\r\nsfb->fb.fix.line_length = sfb->fb.var.xres * 2;\r\nsfb->fb.var.red.length = 5;\r\nsfb->fb.var.green.length = 6;\r\nsfb->fb.var.blue.length = 5;\r\nsfb->fb.var.red.offset = 11;\r\nsfb->fb.var.green.offset = 5;\r\nsfb->fb.var.blue.offset = 0;\r\nbreak;\r\n}\r\nhw.width = sfb->fb.var.xres;\r\nhw.height = sfb->fb.var.yres;\r\nhw.hz = 60;\r\nsmtc_set_timing(sfb, &hw);\r\n}\r\nstatic int smtc_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif ((var->bits_per_pixel != 8) && (var->bits_per_pixel != 16) &&\r\n(var->bits_per_pixel != 24) && (var->bits_per_pixel != 32))\r\nvar->bits_per_pixel = 16;\r\nreturn 0;\r\n}\r\nstatic int smtc_set_par(struct fb_info *info)\r\n{\r\nstruct smtcfb_info *sfb = (struct smtcfb_info *)info;\r\nsmtcfb_setmode(sfb);\r\nreturn 0;\r\n}\r\nstatic struct smtcfb_info *smtc_alloc_fb_info(struct pci_dev *dev,\r\nchar *name)\r\n{\r\nstruct smtcfb_info *sfb;\r\nsfb = kzalloc(sizeof(*sfb), GFP_KERNEL);\r\nif (!sfb)\r\nreturn NULL;\r\nsfb->currcon = -1;\r\nsfb->dev = dev;\r\nsfb->fb.flags = FBINFO_FLAG_DEFAULT;\r\nsfb->fb.fbops = &smtcfb_ops;\r\nsfb->fb.var = smtcfb_var;\r\nsfb->fb.fix = smtcfb_fix;\r\nstrcpy(sfb->fb.fix.id, name);\r\nsfb->fb.fix.type = FB_TYPE_PACKED_PIXELS;\r\nsfb->fb.fix.type_aux = 0;\r\nsfb->fb.fix.xpanstep = 0;\r\nsfb->fb.fix.ypanstep = 0;\r\nsfb->fb.fix.ywrapstep = 0;\r\nsfb->fb.fix.accel = FB_ACCEL_SMI_LYNX;\r\nsfb->fb.var.nonstd = 0;\r\nsfb->fb.var.activate = FB_ACTIVATE_NOW;\r\nsfb->fb.var.height = -1;\r\nsfb->fb.var.width = -1;\r\nsfb->fb.var.accel_flags = FB_ACCELF_TEXT;\r\nsfb->fb.var.vmode = FB_VMODE_NONINTERLACED;\r\nsfb->fb.par = &hw;\r\nsfb->fb.pseudo_palette = colreg;\r\nreturn sfb;\r\n}\r\nstatic void smtc_unmap_mmio(struct smtcfb_info *sfb)\r\n{\r\nif (sfb && smtc_RegBaseAddress)\r\nsmtc_RegBaseAddress = NULL;\r\n}\r\nstatic int smtc_map_smem(struct smtcfb_info *sfb,\r\nstruct pci_dev *dev, u_long smem_len)\r\n{\r\nif (sfb->fb.var.bits_per_pixel == 32) {\r\n#ifdef __BIG_ENDIAN\r\nsfb->fb.fix.smem_start = pci_resource_start(dev, 0)\r\n+ 0x800000;\r\n#else\r\nsfb->fb.fix.smem_start = pci_resource_start(dev, 0);\r\n#endif\r\n} else {\r\nsfb->fb.fix.smem_start = pci_resource_start(dev, 0);\r\n}\r\nsfb->fb.fix.smem_len = smem_len;\r\nsfb->fb.screen_base = smtc_VRAMBaseAddress;\r\nif (!sfb->fb.screen_base) {\r\nprintk(KERN_ERR "%s: unable to map screen memory\n",\r\nsfb->fb.fix.id);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void smtc_unmap_smem(struct smtcfb_info *sfb)\r\n{\r\nif (sfb && sfb->fb.screen_base) {\r\niounmap(sfb->fb.screen_base);\r\nsfb->fb.screen_base = NULL;\r\n}\r\n}\r\nstatic inline void sm7xx_init_hw(void)\r\n{\r\noutb_p(0x18, 0x3c4);\r\noutb_p(0x11, 0x3c5);\r\n}\r\nstatic void smtc_free_fb_info(struct smtcfb_info *sfb)\r\n{\r\nif (sfb) {\r\nfb_alloc_cmap(&sfb->fb.cmap, 0, 0);\r\nkfree(sfb);\r\n}\r\n}\r\nstatic int __init sm712vga_setup(char *options)\r\n{\r\nint index;\r\nif (!options || !*options) {\r\nsmdbg("\n No vga parameter\n");\r\nreturn -EINVAL;\r\n}\r\nsmtc_screen_info.lfb_width = 0;\r\nsmtc_screen_info.lfb_height = 0;\r\nsmtc_screen_info.lfb_depth = 0;\r\nsmdbg("\nsm712vga_setup = %s\n", options);\r\nfor (index = 0;\r\nindex < ARRAY_SIZE(vesa_mode);\r\nindex++) {\r\nif (strstr(options, vesa_mode[index].mode_index)) {\r\nsmtc_screen_info.lfb_width = vesa_mode[index].lfb_width;\r\nsmtc_screen_info.lfb_height =\r\nvesa_mode[index].lfb_height;\r\nsmtc_screen_info.lfb_depth = vesa_mode[index].lfb_depth;\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int __devinit smtcfb_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct smtcfb_info *sfb;\r\nu_long smem_size = 0x00800000;\r\nchar name[16];\r\nint err;\r\nunsigned long pFramebufferPhysical;\r\nprintk(KERN_INFO\r\n"Silicon Motion display driver " SMTC_LINUX_FB_VERSION "\n");\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\nhw.chipID = ent->device;\r\nsprintf(name, "sm%Xfb", hw.chipID);\r\nsfb = smtc_alloc_fb_info(pdev, name);\r\nif (!sfb)\r\ngoto failed_free;\r\npci_set_drvdata(pdev, sfb);\r\nsm7xx_init_hw();\r\nif (smtc_screen_info.lfb_width != 0) {\r\nsfb->fb.var.xres = smtc_screen_info.lfb_width;\r\nsfb->fb.var.yres = smtc_screen_info.lfb_height;\r\nsfb->fb.var.bits_per_pixel = smtc_screen_info.lfb_depth;\r\n} else {\r\nsfb->fb.var.xres = SCREEN_X_RES;\r\nsfb->fb.var.yres = SCREEN_Y_RES;\r\nsfb->fb.var.bits_per_pixel = SCREEN_BPP;\r\n}\r\n#ifdef __BIG_ENDIAN\r\nif (sfb->fb.var.bits_per_pixel == 24)\r\nsfb->fb.var.bits_per_pixel = (smtc_screen_info.lfb_depth = 32);\r\n#endif\r\npFramebufferPhysical = pci_resource_start(pdev, 0);\r\npci_read_config_byte(pdev, PCI_REVISION_ID, &hw.chipRevID);\r\nswitch (hw.chipID) {\r\ncase 0x710:\r\ncase 0x712:\r\nsfb->fb.fix.mmio_start = pFramebufferPhysical + 0x00400000;\r\nsfb->fb.fix.mmio_len = 0x00400000;\r\nsmem_size = SM712_VIDEOMEMORYSIZE;\r\n#ifdef __BIG_ENDIAN\r\nhw.m_pLFB = (smtc_VRAMBaseAddress =\r\nioremap(pFramebufferPhysical, 0x00c00000));\r\n#else\r\nhw.m_pLFB = (smtc_VRAMBaseAddress =\r\nioremap(pFramebufferPhysical, 0x00800000));\r\n#endif\r\nhw.m_pMMIO = (smtc_RegBaseAddress =\r\nsmtc_VRAMBaseAddress + 0x00700000);\r\nhw.m_pDPR = smtc_VRAMBaseAddress + 0x00408000;\r\nhw.m_pVPR = hw.m_pLFB + 0x0040c000;\r\n#ifdef __BIG_ENDIAN\r\nif (sfb->fb.var.bits_per_pixel == 32) {\r\nsmtc_VRAMBaseAddress += 0x800000;\r\nhw.m_pLFB += 0x800000;\r\nprintk(KERN_INFO\r\n"\nsmtc_VRAMBaseAddress=%p hw.m_pLFB=%p\n",\r\nsmtc_VRAMBaseAddress, hw.m_pLFB);\r\n}\r\n#endif\r\nif (!smtc_RegBaseAddress) {\r\nprintk(KERN_ERR\r\n"%s: unable to map memory mapped IO\n",\r\nsfb->fb.fix.id);\r\nerr = -ENOMEM;\r\ngoto failed_fb;\r\n}\r\nsmtc_seqw(0x6a, 0x16);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x62, 0x3e);\r\nsmtc_seqw(0x17, 0x20);\r\n#ifdef __BIG_ENDIAN\r\nif (sfb->fb.var.bits_per_pixel == 32)\r\nsmtc_seqw(0x17, 0x30);\r\n#endif\r\nbreak;\r\ncase 0x720:\r\nsfb->fb.fix.mmio_start = pFramebufferPhysical;\r\nsfb->fb.fix.mmio_len = 0x00200000;\r\nsmem_size = SM722_VIDEOMEMORYSIZE;\r\nhw.m_pDPR = ioremap(pFramebufferPhysical, 0x00a00000);\r\nhw.m_pLFB = (smtc_VRAMBaseAddress =\r\nhw.m_pDPR + 0x00200000);\r\nhw.m_pMMIO = (smtc_RegBaseAddress =\r\nhw.m_pDPR + 0x000c0000);\r\nhw.m_pVPR = hw.m_pDPR + 0x800;\r\nsmtc_seqw(0x62, 0xff);\r\nsmtc_seqw(0x6a, 0x0d);\r\nsmtc_seqw(0x6b, 0x02);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"No valid Silicon Motion display chip was detected!\n");\r\ngoto failed_fb;\r\n}\r\nif (15 == sfb->fb.var.bits_per_pixel)\r\nsfb->fb.var.bits_per_pixel = 16;\r\nsfb->fb.var.xres_virtual = sfb->fb.var.xres;\r\nsfb->fb.var.yres_virtual = sfb->fb.var.yres;\r\nerr = smtc_map_smem(sfb, pdev, smem_size);\r\nif (err)\r\ngoto failed;\r\nsmtcfb_setmode(sfb);\r\nhw.BaseAddressInVRAM = 0;\r\nsfb->fb.par = &hw;\r\nerr = register_framebuffer(&sfb->fb);\r\nif (err < 0)\r\ngoto failed;\r\nprintk(KERN_INFO "Silicon Motion SM%X Rev%X primary display mode"\r\n"%dx%d-%d Init Complete.\n", hw.chipID, hw.chipRevID,\r\nsfb->fb.var.xres, sfb->fb.var.yres,\r\nsfb->fb.var.bits_per_pixel);\r\nreturn 0;\r\nfailed:\r\nprintk(KERN_ERR "Silicon Motion, Inc. primary display init fail\n");\r\nsmtc_unmap_smem(sfb);\r\nsmtc_unmap_mmio(sfb);\r\nfailed_fb:\r\nsmtc_free_fb_info(sfb);\r\nfailed_free:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void __devexit smtcfb_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct smtcfb_info *sfb;\r\nsfb = pci_get_drvdata(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nsmtc_unmap_smem(sfb);\r\nsmtc_unmap_mmio(sfb);\r\nunregister_framebuffer(&sfb->fb);\r\nsmtc_free_fb_info(sfb);\r\n}\r\nstatic int smtcfb_pci_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct smtcfb_info *sfb;\r\nsfb = pci_get_drvdata(pdev);\r\nsmtc_seqw(0x20, (smtc_seqr(0x20) | 0xc0));\r\nsmtc_seqw(0x69, (smtc_seqr(0x69) & 0xf7));\r\nconsole_lock();\r\nfb_set_suspend(&sfb->fb, 1);\r\nconsole_unlock();\r\nsmtc_seqw(0x21, 0xff);\r\nreturn 0;\r\n}\r\nstatic int smtcfb_pci_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct smtcfb_info *sfb;\r\nsfb = pci_get_drvdata(pdev);\r\nsm7xx_init_hw();\r\nswitch (hw.chipID) {\r\ncase 0x710:\r\ncase 0x712:\r\nsmtc_seqw(0x6a, 0x16);\r\nsmtc_seqw(0x6b, 0x02);\r\nsmtc_seqw(0x62, 0x3e);\r\nsmtc_seqw(0x17, 0x20);\r\n#ifdef __BIG_ENDIAN\r\nif (sfb->fb.var.bits_per_pixel == 32)\r\nsmtc_seqw(0x17, 0x30);\r\n#endif\r\nbreak;\r\ncase 0x720:\r\nsmtc_seqw(0x62, 0xff);\r\nsmtc_seqw(0x6a, 0x0d);\r\nsmtc_seqw(0x6b, 0x02);\r\nbreak;\r\n}\r\nsmtc_seqw(0x34, (smtc_seqr(0x34) | 0xc0));\r\nsmtc_seqw(0x33, ((smtc_seqr(0x33) | 0x08) & 0xfb));\r\nsmtcfb_setmode(sfb);\r\nconsole_lock();\r\nfb_set_suspend(&sfb->fb, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int __init smtcfb_init(void)\r\n{\r\nreturn pci_register_driver(&smtcfb_driver);\r\n}\r\nstatic void __exit smtcfb_exit(void)\r\n{\r\npci_unregister_driver(&smtcfb_driver);\r\n}
