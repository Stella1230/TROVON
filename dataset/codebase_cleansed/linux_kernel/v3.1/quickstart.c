static ssize_t buttons_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct quickstart_btn *ptr = quickstart_data.btn_lst;\r\nif (!ptr)\r\nreturn snprintf(buf, PAGE_SIZE, "none");\r\nwhile (ptr && (count < PAGE_SIZE)) {\r\nif (ptr->name) {\r\ncount += snprintf(buf + count,\r\nPAGE_SIZE - count,\r\n"%d\t%s\n", ptr->id, ptr->name);\r\n}\r\nptr = ptr->next;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t pressed_button_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\n(quickstart_data.pressed ?\r\nquickstart_data.pressed->name : "none"));\r\n}\r\nstatic ssize_t pressed_button_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nif (count < 2)\r\nreturn -EINVAL;\r\nif (strncasecmp(buf, "none", 4) != 0)\r\nreturn -EINVAL;\r\nquickstart_data.pressed = NULL;\r\nreturn count;\r\n}\r\nstatic int quickstart_btnlst_add(struct quickstart_btn **data)\r\n{\r\nstruct quickstart_btn **ptr = &quickstart_data.btn_lst;\r\nwhile (*ptr)\r\nptr = &((*ptr)->next);\r\n*ptr = kzalloc(sizeof(struct quickstart_btn), GFP_KERNEL);\r\nif (!*ptr) {\r\n*data = NULL;\r\nreturn -ENOMEM;\r\n}\r\n*data = *ptr;\r\nreturn 0;\r\n}\r\nstatic void quickstart_btnlst_del(struct quickstart_btn *data)\r\n{\r\nstruct quickstart_btn **ptr = &quickstart_data.btn_lst;\r\nif (!data)\r\nreturn;\r\nwhile (*ptr) {\r\nif (*ptr == data) {\r\n*ptr = (*ptr)->next;\r\nkfree(data);\r\nreturn;\r\n}\r\nptr = &((*ptr)->next);\r\n}\r\nreturn;\r\n}\r\nstatic void quickstart_btnlst_free(void)\r\n{\r\nstruct quickstart_btn *ptr = quickstart_data.btn_lst;\r\nstruct quickstart_btn *lptr = NULL;\r\nwhile (ptr) {\r\nlptr = ptr;\r\nptr = ptr->next;\r\nkfree(lptr->name);\r\nkfree(lptr);\r\n}\r\nreturn;\r\n}\r\nstatic void quickstart_acpi_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct quickstart_acpi *quickstart = data;\r\nif (!quickstart)\r\nreturn;\r\nif (event == QUICKSTART_EVENT_WAKE)\r\nquickstart_data.pressed = quickstart->btn;\r\nelse if (event == QUICKSTART_EVENT_RUNTIME) {\r\ninput_report_key(quickstart_input, quickstart->btn->id, 1);\r\ninput_sync(quickstart_input);\r\ninput_report_key(quickstart_input, quickstart->btn->id, 0);\r\ninput_sync(quickstart_input);\r\n}\r\nreturn;\r\n}\r\nstatic void quickstart_acpi_ghid(struct quickstart_acpi *quickstart)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nuint32_t usageid = 0;\r\nif (!quickstart)\r\nreturn;\r\nstatus = acpi_evaluate_object(quickstart->device->handle,\r\n"GHID", NULL, &buffer);\r\nif (ACPI_FAILURE(status) || !buffer.pointer) {\r\nprintk(KERN_ERR "quickstart: %s GHID method failed.\n",\r\nquickstart->btn->name);\r\nreturn;\r\n}\r\nif (buffer.length < 8)\r\nreturn;\r\nusageid = *((uint32_t *)(buffer.pointer + (buffer.length - 8)));\r\nquickstart->btn->id = usageid;\r\nkfree(buffer.pointer);\r\n}\r\nstatic int quickstart_acpi_config(struct quickstart_acpi *quickstart, char *bid)\r\n{\r\nint len = strlen(bid);\r\nint ret;\r\nret = quickstart_btnlst_add(&quickstart->btn);\r\nif (ret)\r\nreturn ret;\r\nquickstart->btn->name = kzalloc(len + 1, GFP_KERNEL);\r\nif (!quickstart->btn->name) {\r\nquickstart_btnlst_free();\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(quickstart->btn->name, bid);\r\nreturn 0;\r\n}\r\nstatic int quickstart_acpi_add(struct acpi_device *device)\r\n{\r\nint ret = 0;\r\nacpi_status status = AE_OK;\r\nstruct quickstart_acpi *quickstart = NULL;\r\nif (!device)\r\nreturn -EINVAL;\r\nquickstart = kzalloc(sizeof(struct quickstart_acpi), GFP_KERNEL);\r\nif (!quickstart)\r\nreturn -ENOMEM;\r\nquickstart->device = device;\r\nstrcpy(acpi_device_name(device), QUICKSTART_ACPI_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), QUICKSTART_ACPI_CLASS);\r\ndevice->driver_data = quickstart;\r\nret = quickstart_acpi_config(quickstart, acpi_device_bid(device));\r\nif (ret)\r\ngoto fail_config;\r\nstatus = acpi_install_notify_handler(device->handle,\r\nACPI_ALL_NOTIFY,\r\nquickstart_acpi_notify,\r\nquickstart);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR "quickstart: Notify handler install error\n");\r\nret = -ENODEV;\r\ngoto fail_installnotify;\r\n}\r\nquickstart_acpi_ghid(quickstart);\r\nreturn 0;\r\nfail_installnotify:\r\nquickstart_btnlst_del(quickstart->btn);\r\nfail_config:\r\nkfree(quickstart);\r\nreturn ret;\r\n}\r\nstatic int quickstart_acpi_remove(struct acpi_device *device, int type)\r\n{\r\nacpi_status status = 0;\r\nstruct quickstart_acpi *quickstart = NULL;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nquickstart = acpi_driver_data(device);\r\nstatus = acpi_remove_notify_handler(device->handle,\r\nACPI_ALL_NOTIFY,\r\nquickstart_acpi_notify);\r\nif (ACPI_FAILURE(status))\r\nprintk(KERN_ERR "quickstart: Error removing notify handler\n");\r\nkfree(quickstart);\r\nreturn 0;\r\n}\r\nstatic void quickstart_exit(void)\r\n{\r\ninput_unregister_device(quickstart_input);\r\ndevice_remove_file(&pf_device->dev, &dev_attr_pressed_button);\r\ndevice_remove_file(&pf_device->dev, &dev_attr_buttons);\r\nplatform_device_unregister(pf_device);\r\nplatform_driver_unregister(&pf_driver);\r\nacpi_bus_unregister_driver(&quickstart_acpi_driver);\r\nquickstart_btnlst_free();\r\nreturn;\r\n}\r\nstatic int __init quickstart_init_input(void)\r\n{\r\nstruct quickstart_btn **ptr = &quickstart_data.btn_lst;\r\nint count;\r\nint ret;\r\nquickstart_input = input_allocate_device();\r\nif (!quickstart_input)\r\nreturn -ENOMEM;\r\nquickstart_input->name = "Quickstart ACPI Buttons";\r\nquickstart_input->id.bustype = BUS_HOST;\r\nwhile (*ptr) {\r\ncount++;\r\nset_bit(EV_KEY, quickstart_input->evbit);\r\nset_bit((*ptr)->id, quickstart_input->keybit);\r\nptr = &((*ptr)->next);\r\n}\r\nret = input_register_device(quickstart_input);\r\nif (ret) {\r\ninput_free_device(quickstart_input);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init quickstart_init(void)\r\n{\r\nint ret;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nret = acpi_bus_register_driver(&quickstart_acpi_driver);\r\nif (ret)\r\nreturn ret;\r\nif (!quickstart_data.btn_lst) {\r\nret = -ENODEV;\r\ngoto fail_pfdrv_reg;\r\n}\r\nret = platform_driver_register(&pf_driver);\r\nif (ret)\r\ngoto fail_pfdrv_reg;\r\npf_device = platform_device_alloc(QUICKSTART_PF_DEVICE_NAME, -1);\r\nif (!pf_device) {\r\nret = -ENOMEM;\r\ngoto fail_pfdev_alloc;\r\n}\r\nret = platform_device_add(pf_device);\r\nif (ret)\r\ngoto fail_pfdev_add;\r\nret = device_create_file(&pf_device->dev, &dev_attr_pressed_button);\r\nif (ret)\r\ngoto fail_dev_file;\r\nret = device_create_file(&pf_device->dev, &dev_attr_buttons);\r\nif (ret)\r\ngoto fail_dev_file2;\r\nret = quickstart_init_input();\r\nif (ret)\r\ngoto fail_input;\r\nprintk(KERN_INFO "quickstart: ACPI Direct App Launch ver %s\n",\r\nQUICKSTART_VERSION);\r\nreturn 0;\r\nfail_input:\r\ndevice_remove_file(&pf_device->dev, &dev_attr_buttons);\r\nfail_dev_file2:\r\ndevice_remove_file(&pf_device->dev, &dev_attr_pressed_button);\r\nfail_dev_file:\r\nplatform_device_del(pf_device);\r\nfail_pfdev_add:\r\nplatform_device_put(pf_device);\r\nfail_pfdev_alloc:\r\nplatform_driver_unregister(&pf_driver);\r\nfail_pfdrv_reg:\r\nacpi_bus_unregister_driver(&quickstart_acpi_driver);\r\nreturn ret;\r\n}
