void ptrace_disable(struct task_struct *child)\r\n{\r\n}\r\nstatic int genregs32_get(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nconst struct pt_regs *regs = target->thread.kregs;\r\nunsigned long __user *reg_window;\r\nunsigned long *k = kbuf;\r\nunsigned long __user *u = ubuf;\r\nunsigned long reg;\r\nif (target == current)\r\nflush_user_windows();\r\npos /= sizeof(reg);\r\ncount /= sizeof(reg);\r\nif (kbuf) {\r\nfor (; count > 0 && pos < 16; count--)\r\n*k++ = regs->u_regs[pos++];\r\nreg_window = (unsigned long __user *) regs->u_regs[UREG_I6];\r\nreg_window -= 16;\r\nfor (; count > 0 && pos < 32; count--) {\r\nif (get_user(*k++, &reg_window[pos++]))\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nfor (; count > 0 && pos < 16; count--) {\r\nif (put_user(regs->u_regs[pos++], u++))\r\nreturn -EFAULT;\r\n}\r\nreg_window = (unsigned long __user *) regs->u_regs[UREG_I6];\r\nreg_window -= 16;\r\nfor (; count > 0 && pos < 32; count--) {\r\nif (get_user(reg, &reg_window[pos++]) ||\r\nput_user(reg, u++))\r\nreturn -EFAULT;\r\n}\r\n}\r\nwhile (count > 0) {\r\nswitch (pos) {\r\ncase 32:\r\nreg = regs->psr;\r\nbreak;\r\ncase 33:\r\nreg = regs->pc;\r\nbreak;\r\ncase 34:\r\nreg = regs->npc;\r\nbreak;\r\ncase 35:\r\nreg = regs->y;\r\nbreak;\r\ncase 36:\r\ncase 37:\r\nreg = 0;\r\nbreak;\r\ndefault:\r\ngoto finish;\r\n}\r\nif (kbuf)\r\n*k++ = reg;\r\nelse if (put_user(reg, u++))\r\nreturn -EFAULT;\r\npos++;\r\ncount--;\r\n}\r\nfinish:\r\npos *= sizeof(reg);\r\ncount *= sizeof(reg);\r\nreturn user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\r\n38 * sizeof(reg), -1);\r\n}\r\nstatic int genregs32_set(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct pt_regs *regs = target->thread.kregs;\r\nunsigned long __user *reg_window;\r\nconst unsigned long *k = kbuf;\r\nconst unsigned long __user *u = ubuf;\r\nunsigned long reg;\r\nif (target == current)\r\nflush_user_windows();\r\npos /= sizeof(reg);\r\ncount /= sizeof(reg);\r\nif (kbuf) {\r\nfor (; count > 0 && pos < 16; count--)\r\nregs->u_regs[pos++] = *k++;\r\nreg_window = (unsigned long __user *) regs->u_regs[UREG_I6];\r\nreg_window -= 16;\r\nfor (; count > 0 && pos < 32; count--) {\r\nif (put_user(*k++, &reg_window[pos++]))\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nfor (; count > 0 && pos < 16; count--) {\r\nif (get_user(reg, u++))\r\nreturn -EFAULT;\r\nregs->u_regs[pos++] = reg;\r\n}\r\nreg_window = (unsigned long __user *) regs->u_regs[UREG_I6];\r\nreg_window -= 16;\r\nfor (; count > 0 && pos < 32; count--) {\r\nif (get_user(reg, u++) ||\r\nput_user(reg, &reg_window[pos++]))\r\nreturn -EFAULT;\r\n}\r\n}\r\nwhile (count > 0) {\r\nunsigned long psr;\r\nif (kbuf)\r\nreg = *k++;\r\nelse if (get_user(reg, u++))\r\nreturn -EFAULT;\r\nswitch (pos) {\r\ncase 32:\r\npsr = regs->psr;\r\npsr &= ~(PSR_ICC | PSR_SYSCALL);\r\npsr |= (reg & (PSR_ICC | PSR_SYSCALL));\r\nregs->psr = psr;\r\nbreak;\r\ncase 33:\r\nregs->pc = reg;\r\nbreak;\r\ncase 34:\r\nregs->npc = reg;\r\nbreak;\r\ncase 35:\r\nregs->y = reg;\r\nbreak;\r\ncase 36:\r\ncase 37:\r\nbreak;\r\ndefault:\r\ngoto finish;\r\n}\r\npos++;\r\ncount--;\r\n}\r\nfinish:\r\npos *= sizeof(reg);\r\ncount *= sizeof(reg);\r\nreturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\r\n38 * sizeof(reg), -1);\r\n}\r\nstatic int fpregs32_get(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nconst unsigned long *fpregs = target->thread.float_regs;\r\nint ret = 0;\r\n#if 0\r\nif (target == current)\r\nsave_and_clear_fpu();\r\n#endif\r\nret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\nfpregs,\r\n0, 32 * sizeof(u32));\r\nif (!ret)\r\nret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\r\n32 * sizeof(u32),\r\n33 * sizeof(u32));\r\nif (!ret)\r\nret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\n&target->thread.fsr,\r\n33 * sizeof(u32),\r\n34 * sizeof(u32));\r\nif (!ret) {\r\nunsigned long val;\r\nval = (1 << 8) | (8 << 16);\r\nret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\n&val,\r\n34 * sizeof(u32),\r\n35 * sizeof(u32));\r\n}\r\nif (!ret)\r\nret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\r\n35 * sizeof(u32), -1);\r\nreturn ret;\r\n}\r\nstatic int fpregs32_set(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nunsigned long *fpregs = target->thread.float_regs;\r\nint ret;\r\n#if 0\r\nif (target == current)\r\nsave_and_clear_fpu();\r\n#endif\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\nfpregs,\r\n0, 32 * sizeof(u32));\r\nif (!ret)\r\nuser_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\r\n32 * sizeof(u32),\r\n33 * sizeof(u32));\r\nif (!ret && count > 0) {\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\n&target->thread.fsr,\r\n33 * sizeof(u32),\r\n34 * sizeof(u32));\r\n}\r\nif (!ret)\r\nret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\r\n34 * sizeof(u32), -1);\r\nreturn ret;\r\n}\r\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\r\n{\r\nreturn &user_sparc32_view;\r\n}\r\nlong arch_ptrace(struct task_struct *child, long request,\r\nunsigned long addr, unsigned long data)\r\n{\r\nunsigned long addr2 = current->thread.kregs->u_regs[UREG_I4];\r\nvoid __user *addr2p;\r\nconst struct user_regset_view *view;\r\nstruct pt_regs __user *pregs;\r\nstruct fps __user *fps;\r\nint ret;\r\nview = task_user_regset_view(current);\r\naddr2p = (void __user *) addr2;\r\npregs = (struct pt_regs __user *) addr;\r\nfps = (struct fps __user *) addr;\r\nswitch(request) {\r\ncase PTRACE_GETREGS: {\r\nret = copy_regset_to_user(child, view, REGSET_GENERAL,\r\n32 * sizeof(u32),\r\n4 * sizeof(u32),\r\n&pregs->psr);\r\nif (!ret)\r\ncopy_regset_to_user(child, view, REGSET_GENERAL,\r\n1 * sizeof(u32),\r\n15 * sizeof(u32),\r\n&pregs->u_regs[0]);\r\nbreak;\r\n}\r\ncase PTRACE_SETREGS: {\r\nret = copy_regset_from_user(child, view, REGSET_GENERAL,\r\n32 * sizeof(u32),\r\n4 * sizeof(u32),\r\n&pregs->psr);\r\nif (!ret)\r\ncopy_regset_from_user(child, view, REGSET_GENERAL,\r\n1 * sizeof(u32),\r\n15 * sizeof(u32),\r\n&pregs->u_regs[0]);\r\nbreak;\r\n}\r\ncase PTRACE_GETFPREGS: {\r\nret = copy_regset_to_user(child, view, REGSET_FP,\r\n0 * sizeof(u32),\r\n32 * sizeof(u32),\r\n&fps->regs[0]);\r\nif (!ret)\r\nret = copy_regset_to_user(child, view, REGSET_FP,\r\n33 * sizeof(u32),\r\n1 * sizeof(u32),\r\n&fps->fsr);\r\nif (!ret) {\r\nif (__put_user(0, &fps->fpqd) ||\r\n__put_user(0, &fps->flags) ||\r\n__put_user(0, &fps->extra) ||\r\nclear_user(fps->fpq, sizeof(fps->fpq)))\r\nret = -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase PTRACE_SETFPREGS: {\r\nret = copy_regset_from_user(child, view, REGSET_FP,\r\n0 * sizeof(u32),\r\n32 * sizeof(u32),\r\n&fps->regs[0]);\r\nif (!ret)\r\nret = copy_regset_from_user(child, view, REGSET_FP,\r\n33 * sizeof(u32),\r\n1 * sizeof(u32),\r\n&fps->fsr);\r\nbreak;\r\n}\r\ncase PTRACE_READTEXT:\r\ncase PTRACE_READDATA:\r\nret = ptrace_readdata(child, addr, addr2p, data);\r\nif (ret == data)\r\nret = 0;\r\nelse if (ret >= 0)\r\nret = -EIO;\r\nbreak;\r\ncase PTRACE_WRITETEXT:\r\ncase PTRACE_WRITEDATA:\r\nret = ptrace_writedata(child, addr2p, addr, data);\r\nif (ret == data)\r\nret = 0;\r\nelse if (ret >= 0)\r\nret = -EIO;\r\nbreak;\r\ndefault:\r\nif (request == PTRACE_SPARC_DETACH)\r\nrequest = PTRACE_DETACH;\r\nret = ptrace_request(child, request, addr, data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage int syscall_trace(struct pt_regs *regs, int syscall_exit_p)\r\n{\r\nint ret = 0;\r\nif (test_thread_flag(TIF_SYSCALL_TRACE)) {\r\nif (syscall_exit_p)\r\ntracehook_report_syscall_exit(regs, 0);\r\nelse\r\nret = tracehook_report_syscall_entry(regs);\r\n}\r\nreturn ret;\r\n}
