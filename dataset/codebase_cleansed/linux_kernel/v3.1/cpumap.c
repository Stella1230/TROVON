static struct cpu_map *cpu_map__default_new(void)\r\n{\r\nstruct cpu_map *cpus;\r\nint nr_cpus;\r\nnr_cpus = sysconf(_SC_NPROCESSORS_ONLN);\r\nif (nr_cpus < 0)\r\nreturn NULL;\r\ncpus = malloc(sizeof(*cpus) + nr_cpus * sizeof(int));\r\nif (cpus != NULL) {\r\nint i;\r\nfor (i = 0; i < nr_cpus; ++i)\r\ncpus->map[i] = i;\r\ncpus->nr = nr_cpus;\r\n}\r\nreturn cpus;\r\n}\r\nstatic struct cpu_map *cpu_map__trim_new(int nr_cpus, int *tmp_cpus)\r\n{\r\nsize_t payload_size = nr_cpus * sizeof(int);\r\nstruct cpu_map *cpus = malloc(sizeof(*cpus) + payload_size);\r\nif (cpus != NULL) {\r\ncpus->nr = nr_cpus;\r\nmemcpy(cpus->map, tmp_cpus, payload_size);\r\n}\r\nreturn cpus;\r\n}\r\nstatic struct cpu_map *cpu_map__read_all_cpu_map(void)\r\n{\r\nstruct cpu_map *cpus = NULL;\r\nFILE *onlnf;\r\nint nr_cpus = 0;\r\nint *tmp_cpus = NULL, *tmp;\r\nint max_entries = 0;\r\nint n, cpu, prev;\r\nchar sep;\r\nonlnf = fopen("/sys/devices/system/cpu/online", "r");\r\nif (!onlnf)\r\nreturn cpu_map__default_new();\r\nsep = 0;\r\nprev = -1;\r\nfor (;;) {\r\nn = fscanf(onlnf, "%u%c", &cpu, &sep);\r\nif (n <= 0)\r\nbreak;\r\nif (prev >= 0) {\r\nint new_max = nr_cpus + cpu - prev - 1;\r\nif (new_max >= max_entries) {\r\nmax_entries = new_max + MAX_NR_CPUS / 2;\r\ntmp = realloc(tmp_cpus, max_entries * sizeof(int));\r\nif (tmp == NULL)\r\ngoto out_free_tmp;\r\ntmp_cpus = tmp;\r\n}\r\nwhile (++prev < cpu)\r\ntmp_cpus[nr_cpus++] = prev;\r\n}\r\nif (nr_cpus == max_entries) {\r\nmax_entries += MAX_NR_CPUS;\r\ntmp = realloc(tmp_cpus, max_entries * sizeof(int));\r\nif (tmp == NULL)\r\ngoto out_free_tmp;\r\ntmp_cpus = tmp;\r\n}\r\ntmp_cpus[nr_cpus++] = cpu;\r\nif (n == 2 && sep == '-')\r\nprev = cpu;\r\nelse\r\nprev = -1;\r\nif (n == 1 || sep == '\n')\r\nbreak;\r\n}\r\nif (nr_cpus > 0)\r\ncpus = cpu_map__trim_new(nr_cpus, tmp_cpus);\r\nelse\r\ncpus = cpu_map__default_new();\r\nout_free_tmp:\r\nfree(tmp_cpus);\r\nfclose(onlnf);\r\nreturn cpus;\r\n}\r\nstruct cpu_map *cpu_map__new(const char *cpu_list)\r\n{\r\nstruct cpu_map *cpus = NULL;\r\nunsigned long start_cpu, end_cpu = 0;\r\nchar *p = NULL;\r\nint i, nr_cpus = 0;\r\nint *tmp_cpus = NULL, *tmp;\r\nint max_entries = 0;\r\nif (!cpu_list)\r\nreturn cpu_map__read_all_cpu_map();\r\nif (!isdigit(*cpu_list))\r\ngoto out;\r\nwhile (isdigit(*cpu_list)) {\r\np = NULL;\r\nstart_cpu = strtoul(cpu_list, &p, 0);\r\nif (start_cpu >= INT_MAX\r\n|| (*p != '\0' && *p != ',' && *p != '-'))\r\ngoto invalid;\r\nif (*p == '-') {\r\ncpu_list = ++p;\r\np = NULL;\r\nend_cpu = strtoul(cpu_list, &p, 0);\r\nif (end_cpu >= INT_MAX || (*p != '\0' && *p != ','))\r\ngoto invalid;\r\nif (end_cpu < start_cpu)\r\ngoto invalid;\r\n} else {\r\nend_cpu = start_cpu;\r\n}\r\nfor (; start_cpu <= end_cpu; start_cpu++) {\r\nfor (i = 0; i < nr_cpus; i++)\r\nif (tmp_cpus[i] == (int)start_cpu)\r\ngoto invalid;\r\nif (nr_cpus == max_entries) {\r\nmax_entries += MAX_NR_CPUS;\r\ntmp = realloc(tmp_cpus, max_entries * sizeof(int));\r\nif (tmp == NULL)\r\ngoto invalid;\r\ntmp_cpus = tmp;\r\n}\r\ntmp_cpus[nr_cpus++] = (int)start_cpu;\r\n}\r\nif (*p)\r\n++p;\r\ncpu_list = p;\r\n}\r\nif (nr_cpus > 0)\r\ncpus = cpu_map__trim_new(nr_cpus, tmp_cpus);\r\nelse\r\ncpus = cpu_map__default_new();\r\ninvalid:\r\nfree(tmp_cpus);\r\nout:\r\nreturn cpus;\r\n}\r\nstruct cpu_map *cpu_map__dummy_new(void)\r\n{\r\nstruct cpu_map *cpus = malloc(sizeof(*cpus) + sizeof(int));\r\nif (cpus != NULL) {\r\ncpus->nr = 1;\r\ncpus->map[0] = -1;\r\n}\r\nreturn cpus;\r\n}\r\nvoid cpu_map__delete(struct cpu_map *map)\r\n{\r\nfree(map);\r\n}
