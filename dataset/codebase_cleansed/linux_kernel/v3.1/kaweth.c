static int kaweth_control(struct kaweth_device *kaweth,\r\nunsigned int pipe,\r\n__u8 request,\r\n__u8 requesttype,\r\n__u16 value,\r\n__u16 index,\r\nvoid *data,\r\n__u16 size,\r\nint timeout)\r\n{\r\nstruct usb_ctrlrequest *dr;\r\nint retval;\r\ndbg("kaweth_control()");\r\nif(in_interrupt()) {\r\ndbg("in_interrupt()");\r\nreturn -EBUSY;\r\n}\r\ndr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\r\nif (!dr) {\r\ndbg("kmalloc() failed");\r\nreturn -ENOMEM;\r\n}\r\ndr->bRequestType = requesttype;\r\ndr->bRequest = request;\r\ndr->wValue = cpu_to_le16(value);\r\ndr->wIndex = cpu_to_le16(index);\r\ndr->wLength = cpu_to_le16(size);\r\nretval = kaweth_internal_control_msg(kaweth->dev,\r\npipe,\r\ndr,\r\ndata,\r\nsize,\r\ntimeout);\r\nkfree(dr);\r\nreturn retval;\r\n}\r\nstatic int kaweth_read_configuration(struct kaweth_device *kaweth)\r\n{\r\nint retval;\r\ndbg("Reading kaweth configuration");\r\nretval = kaweth_control(kaweth,\r\nusb_rcvctrlpipe(kaweth->dev, 0),\r\nKAWETH_COMMAND_GET_ETHERNET_DESC,\r\nUSB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\r\n0,\r\n0,\r\n(void *)&kaweth->configuration,\r\nsizeof(kaweth->configuration),\r\nKAWETH_CONTROL_TIMEOUT);\r\nreturn retval;\r\n}\r\nstatic int kaweth_set_urb_size(struct kaweth_device *kaweth, __u16 urb_size)\r\n{\r\nint retval;\r\ndbg("Setting URB size to %d", (unsigned)urb_size);\r\nretval = kaweth_control(kaweth,\r\nusb_sndctrlpipe(kaweth->dev, 0),\r\nKAWETH_COMMAND_SET_URB_SIZE,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\nurb_size,\r\n0,\r\n(void *)&kaweth->scratch,\r\n0,\r\nKAWETH_CONTROL_TIMEOUT);\r\nreturn retval;\r\n}\r\nstatic int kaweth_set_sofs_wait(struct kaweth_device *kaweth, __u16 sofs_wait)\r\n{\r\nint retval;\r\ndbg("Set SOFS wait to %d", (unsigned)sofs_wait);\r\nretval = kaweth_control(kaweth,\r\nusb_sndctrlpipe(kaweth->dev, 0),\r\nKAWETH_COMMAND_SET_SOFS_WAIT,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\nsofs_wait,\r\n0,\r\n(void *)&kaweth->scratch,\r\n0,\r\nKAWETH_CONTROL_TIMEOUT);\r\nreturn retval;\r\n}\r\nstatic int kaweth_set_receive_filter(struct kaweth_device *kaweth,\r\n__u16 receive_filter)\r\n{\r\nint retval;\r\ndbg("Set receive filter to %d", (unsigned)receive_filter);\r\nretval = kaweth_control(kaweth,\r\nusb_sndctrlpipe(kaweth->dev, 0),\r\nKAWETH_COMMAND_SET_PACKET_FILTER,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\nreceive_filter,\r\n0,\r\n(void *)&kaweth->scratch,\r\n0,\r\nKAWETH_CONTROL_TIMEOUT);\r\nreturn retval;\r\n}\r\nstatic int kaweth_download_firmware(struct kaweth_device *kaweth,\r\nconst char *fwname,\r\n__u8 interrupt,\r\n__u8 type)\r\n{\r\nconst struct firmware *fw;\r\nint data_len;\r\nint ret;\r\nret = request_firmware(&fw, fwname, &kaweth->dev->dev);\r\nif (ret) {\r\nerr("Firmware request failed\n");\r\nreturn ret;\r\n}\r\nif (fw->size > KAWETH_FIRMWARE_BUF_SIZE) {\r\nerr("Firmware too big: %zu", fw->size);\r\nrelease_firmware(fw);\r\nreturn -ENOSPC;\r\n}\r\ndata_len = fw->size;\r\nmemcpy(kaweth->firmware_buf, fw->data, fw->size);\r\nrelease_firmware(fw);\r\nkaweth->firmware_buf[2] = (data_len & 0xFF) - 7;\r\nkaweth->firmware_buf[3] = data_len >> 8;\r\nkaweth->firmware_buf[4] = type;\r\nkaweth->firmware_buf[5] = interrupt;\r\ndbg("High: %i, Low:%i", kaweth->firmware_buf[3],\r\nkaweth->firmware_buf[2]);\r\ndbg("Downloading firmware at %p to kaweth device at %p",\r\nfw->data, kaweth);\r\ndbg("Firmware length: %d", data_len);\r\nreturn kaweth_control(kaweth,\r\nusb_sndctrlpipe(kaweth->dev, 0),\r\nKAWETH_COMMAND_SCAN,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\n0,\r\n0,\r\n(void *)kaweth->firmware_buf,\r\ndata_len,\r\nKAWETH_CONTROL_TIMEOUT);\r\n}\r\nstatic int kaweth_trigger_firmware(struct kaweth_device *kaweth,\r\n__u8 interrupt)\r\n{\r\nkaweth->firmware_buf[0] = 0xB6;\r\nkaweth->firmware_buf[1] = 0xC3;\r\nkaweth->firmware_buf[2] = 0x01;\r\nkaweth->firmware_buf[3] = 0x00;\r\nkaweth->firmware_buf[4] = 0x06;\r\nkaweth->firmware_buf[5] = interrupt;\r\nkaweth->firmware_buf[6] = 0x00;\r\nkaweth->firmware_buf[7] = 0x00;\r\ndbg("Triggering firmware");\r\nreturn kaweth_control(kaweth,\r\nusb_sndctrlpipe(kaweth->dev, 0),\r\nKAWETH_COMMAND_SCAN,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\n0,\r\n0,\r\n(void *)kaweth->firmware_buf,\r\n8,\r\nKAWETH_CONTROL_TIMEOUT);\r\n}\r\nstatic int kaweth_reset(struct kaweth_device *kaweth)\r\n{\r\nint result;\r\ndbg("kaweth_reset(%p)", kaweth);\r\nresult = usb_reset_configuration(kaweth->dev);\r\nmdelay(10);\r\ndbg("kaweth_reset() returns %d.",result);\r\nreturn result;\r\n}\r\nstatic void kaweth_resubmit_int_urb(struct kaweth_device *kaweth, gfp_t mf)\r\n{\r\nint status;\r\nstatus = usb_submit_urb (kaweth->irq_urb, mf);\r\nif (unlikely(status == -ENOMEM)) {\r\nkaweth->suspend_lowmem_ctrl = 1;\r\nschedule_delayed_work(&kaweth->lowmem_work, HZ/4);\r\n} else {\r\nkaweth->suspend_lowmem_ctrl = 0;\r\n}\r\nif (status)\r\nerr ("can't resubmit intr, %s-%s, status %d",\r\nkaweth->dev->bus->bus_name,\r\nkaweth->dev->devpath, status);\r\n}\r\nstatic void int_callback(struct urb *u)\r\n{\r\nstruct kaweth_device *kaweth = u->context;\r\nint act_state;\r\nint status = u->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ngoto resubmit;\r\n}\r\nif (kaweth->linkstate != (act_state = ( kaweth->intbuffer[STATE_OFFSET] | STATE_MASK) >> STATE_SHIFT)) {\r\nif (act_state)\r\nnetif_carrier_on(kaweth->net);\r\nelse\r\nnetif_carrier_off(kaweth->net);\r\nkaweth->linkstate = act_state;\r\n}\r\nresubmit:\r\nkaweth_resubmit_int_urb(kaweth, GFP_ATOMIC);\r\n}\r\nstatic void kaweth_resubmit_tl(struct work_struct *work)\r\n{\r\nstruct kaweth_device *kaweth =\r\ncontainer_of(work, struct kaweth_device, lowmem_work.work);\r\nif (IS_BLOCKED(kaweth->status))\r\nreturn;\r\nif (kaweth->suspend_lowmem_rx)\r\nkaweth_resubmit_rx_urb(kaweth, GFP_NOIO);\r\nif (kaweth->suspend_lowmem_ctrl)\r\nkaweth_resubmit_int_urb(kaweth, GFP_NOIO);\r\n}\r\nstatic int kaweth_resubmit_rx_urb(struct kaweth_device *kaweth,\r\ngfp_t mem_flags)\r\n{\r\nint result;\r\nusb_fill_bulk_urb(kaweth->rx_urb,\r\nkaweth->dev,\r\nusb_rcvbulkpipe(kaweth->dev, 1),\r\nkaweth->rx_buf,\r\nKAWETH_BUF_SIZE,\r\nkaweth_usb_receive,\r\nkaweth);\r\nkaweth->rx_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nkaweth->rx_urb->transfer_dma = kaweth->rxbufferhandle;\r\nif((result = usb_submit_urb(kaweth->rx_urb, mem_flags))) {\r\nif (result == -ENOMEM) {\r\nkaweth->suspend_lowmem_rx = 1;\r\nschedule_delayed_work(&kaweth->lowmem_work, HZ/4);\r\n}\r\nerr("resubmitting rx_urb %d failed", result);\r\n} else {\r\nkaweth->suspend_lowmem_rx = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic void kaweth_usb_receive(struct urb *urb)\r\n{\r\nstruct kaweth_device *kaweth = urb->context;\r\nstruct net_device *net = kaweth->net;\r\nint status = urb->status;\r\nint count = urb->actual_length;\r\nint count2 = urb->transfer_buffer_length;\r\n__u16 pkt_len = le16_to_cpup((__le16 *)kaweth->rx_buf);\r\nstruct sk_buff *skb;\r\nif (unlikely(status == -EPIPE)) {\r\nkaweth->stats.rx_errors++;\r\nkaweth->end = 1;\r\nwake_up(&kaweth->term_wait);\r\ndbg("Status was -EPIPE.");\r\nreturn;\r\n}\r\nif (unlikely(status == -ECONNRESET || status == -ESHUTDOWN)) {\r\nkaweth->end = 1;\r\nwake_up(&kaweth->term_wait);\r\ndbg("Status was -ECONNRESET or -ESHUTDOWN.");\r\nreturn;\r\n}\r\nif (unlikely(status == -EPROTO || status == -ETIME ||\r\nstatus == -EILSEQ)) {\r\nkaweth->stats.rx_errors++;\r\ndbg("Status was -EPROTO, -ETIME, or -EILSEQ.");\r\nreturn;\r\n}\r\nif (unlikely(status == -EOVERFLOW)) {\r\nkaweth->stats.rx_errors++;\r\ndbg("Status was -EOVERFLOW.");\r\n}\r\nspin_lock(&kaweth->device_lock);\r\nif (IS_BLOCKED(kaweth->status)) {\r\nspin_unlock(&kaweth->device_lock);\r\nreturn;\r\n}\r\nspin_unlock(&kaweth->device_lock);\r\nif(status && status != -EREMOTEIO && count != 1) {\r\nerr("%s RX status: %d count: %d packet_len: %d",\r\nnet->name,\r\nstatus,\r\ncount,\r\n(int)pkt_len);\r\nkaweth_resubmit_rx_urb(kaweth, GFP_ATOMIC);\r\nreturn;\r\n}\r\nif(kaweth->net && (count > 2)) {\r\nif(pkt_len > (count - 2)) {\r\nerr("Packet length too long for USB frame (pkt_len: %x, count: %x)",pkt_len, count);\r\nerr("Packet len & 2047: %x", pkt_len & 2047);\r\nerr("Count 2: %x", count2);\r\nkaweth_resubmit_rx_urb(kaweth, GFP_ATOMIC);\r\nreturn;\r\n}\r\nif(!(skb = dev_alloc_skb(pkt_len+2))) {\r\nkaweth_resubmit_rx_urb(kaweth, GFP_ATOMIC);\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nskb_copy_to_linear_data(skb, kaweth->rx_buf + 2, pkt_len);\r\nskb_put(skb, pkt_len);\r\nskb->protocol = eth_type_trans(skb, net);\r\nnetif_rx(skb);\r\nkaweth->stats.rx_packets++;\r\nkaweth->stats.rx_bytes += pkt_len;\r\n}\r\nkaweth_resubmit_rx_urb(kaweth, GFP_ATOMIC);\r\n}\r\nstatic int kaweth_open(struct net_device *net)\r\n{\r\nstruct kaweth_device *kaweth = netdev_priv(net);\r\nint res;\r\ndbg("Opening network device.");\r\nres = usb_autopm_get_interface(kaweth->intf);\r\nif (res) {\r\nerr("Interface cannot be resumed.");\r\nreturn -EIO;\r\n}\r\nres = kaweth_resubmit_rx_urb(kaweth, GFP_KERNEL);\r\nif (res)\r\ngoto err_out;\r\nusb_fill_int_urb(\r\nkaweth->irq_urb,\r\nkaweth->dev,\r\nusb_rcvintpipe(kaweth->dev, 3),\r\nkaweth->intbuffer,\r\nINTBUFFERSIZE,\r\nint_callback,\r\nkaweth,\r\n250);\r\nkaweth->irq_urb->transfer_dma = kaweth->intbufferhandle;\r\nkaweth->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nres = usb_submit_urb(kaweth->irq_urb, GFP_KERNEL);\r\nif (res) {\r\nusb_kill_urb(kaweth->rx_urb);\r\ngoto err_out;\r\n}\r\nkaweth->opened = 1;\r\nnetif_start_queue(net);\r\nkaweth_async_set_rx_mode(kaweth);\r\nreturn 0;\r\nerr_out:\r\nusb_autopm_put_interface(kaweth->intf);\r\nreturn -EIO;\r\n}\r\nstatic void kaweth_kill_urbs(struct kaweth_device *kaweth)\r\n{\r\nusb_kill_urb(kaweth->irq_urb);\r\nusb_kill_urb(kaweth->rx_urb);\r\nusb_kill_urb(kaweth->tx_urb);\r\ncancel_delayed_work_sync(&kaweth->lowmem_work);\r\nusb_kill_urb(kaweth->irq_urb);\r\nusb_kill_urb(kaweth->rx_urb);\r\n}\r\nstatic int kaweth_close(struct net_device *net)\r\n{\r\nstruct kaweth_device *kaweth = netdev_priv(net);\r\nnetif_stop_queue(net);\r\nkaweth->opened = 0;\r\nkaweth->status |= KAWETH_STATUS_CLOSING;\r\nkaweth_kill_urbs(kaweth);\r\nkaweth->status &= ~KAWETH_STATUS_CLOSING;\r\nusb_autopm_put_interface(kaweth->intf);\r\nreturn 0;\r\n}\r\nstatic u32 kaweth_get_link(struct net_device *dev)\r\n{\r\nstruct kaweth_device *kaweth = netdev_priv(dev);\r\nreturn kaweth->linkstate;\r\n}\r\nstatic void kaweth_usb_transmit_complete(struct urb *urb)\r\n{\r\nstruct kaweth_device *kaweth = urb->context;\r\nstruct sk_buff *skb = kaweth->tx_skb;\r\nint status = urb->status;\r\nif (unlikely(status != 0))\r\nif (status != -ENOENT)\r\ndbg("%s: TX status %d.", kaweth->net->name, status);\r\nnetif_wake_queue(kaweth->net);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nstatic netdev_tx_t kaweth_start_xmit(struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\nstruct kaweth_device *kaweth = netdev_priv(net);\r\n__le16 *private_header;\r\nint res;\r\nspin_lock_irq(&kaweth->device_lock);\r\nkaweth_async_set_rx_mode(kaweth);\r\nnetif_stop_queue(net);\r\nif (IS_BLOCKED(kaweth->status)) {\r\ngoto skip;\r\n}\r\nif (skb_cloned(skb) || skb_headroom(skb) < 2) {\r\nstruct sk_buff *copied_skb;\r\ncopied_skb = skb_copy_expand(skb, 2, 0, GFP_ATOMIC);\r\ndev_kfree_skb_irq(skb);\r\nskb = copied_skb;\r\nif (!copied_skb) {\r\nkaweth->stats.tx_errors++;\r\nnetif_start_queue(net);\r\nspin_unlock_irq(&kaweth->device_lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\nprivate_header = (__le16 *)__skb_push(skb, 2);\r\n*private_header = cpu_to_le16(skb->len-2);\r\nkaweth->tx_skb = skb;\r\nusb_fill_bulk_urb(kaweth->tx_urb,\r\nkaweth->dev,\r\nusb_sndbulkpipe(kaweth->dev, 2),\r\nprivate_header,\r\nskb->len,\r\nkaweth_usb_transmit_complete,\r\nkaweth);\r\nkaweth->end = 0;\r\nif((res = usb_submit_urb(kaweth->tx_urb, GFP_ATOMIC)))\r\n{\r\ndev_warn(&net->dev, "kaweth failed tx_urb %d\n", res);\r\nskip:\r\nkaweth->stats.tx_errors++;\r\nnetif_start_queue(net);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nelse\r\n{\r\nkaweth->stats.tx_packets++;\r\nkaweth->stats.tx_bytes += skb->len;\r\n}\r\nspin_unlock_irq(&kaweth->device_lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void kaweth_set_rx_mode(struct net_device *net)\r\n{\r\nstruct kaweth_device *kaweth = netdev_priv(net);\r\n__u16 packet_filter_bitmap = KAWETH_PACKET_FILTER_DIRECTED |\r\nKAWETH_PACKET_FILTER_BROADCAST |\r\nKAWETH_PACKET_FILTER_MULTICAST;\r\ndbg("Setting Rx mode to %d", packet_filter_bitmap);\r\nnetif_stop_queue(net);\r\nif (net->flags & IFF_PROMISC) {\r\npacket_filter_bitmap |= KAWETH_PACKET_FILTER_PROMISCUOUS;\r\n}\r\nelse if (!netdev_mc_empty(net) || (net->flags & IFF_ALLMULTI)) {\r\npacket_filter_bitmap |= KAWETH_PACKET_FILTER_ALL_MULTICAST;\r\n}\r\nkaweth->packet_filter_bitmap = packet_filter_bitmap;\r\nnetif_wake_queue(net);\r\n}\r\nstatic void kaweth_async_set_rx_mode(struct kaweth_device *kaweth)\r\n{\r\nint result;\r\n__u16 packet_filter_bitmap = kaweth->packet_filter_bitmap;\r\nkaweth->packet_filter_bitmap = 0;\r\nif (packet_filter_bitmap == 0)\r\nreturn;\r\nif (in_interrupt())\r\nreturn;\r\nresult = kaweth_control(kaweth,\r\nusb_sndctrlpipe(kaweth->dev, 0),\r\nKAWETH_COMMAND_SET_PACKET_FILTER,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\npacket_filter_bitmap,\r\n0,\r\n(void *)&kaweth->scratch,\r\n0,\r\nKAWETH_CONTROL_TIMEOUT);\r\nif(result < 0) {\r\nerr("Failed to set Rx mode: %d", result);\r\n}\r\nelse {\r\ndbg("Set Rx mode to %d", packet_filter_bitmap);\r\n}\r\n}\r\nstatic struct net_device_stats *kaweth_netdev_stats(struct net_device *dev)\r\n{\r\nstruct kaweth_device *kaweth = netdev_priv(dev);\r\nreturn &kaweth->stats;\r\n}\r\nstatic void kaweth_tx_timeout(struct net_device *net)\r\n{\r\nstruct kaweth_device *kaweth = netdev_priv(net);\r\ndev_warn(&net->dev, "%s: Tx timed out. Resetting.\n", net->name);\r\nkaweth->stats.tx_errors++;\r\nnet->trans_start = jiffies;\r\nusb_unlink_urb(kaweth->tx_urb);\r\n}\r\nstatic int kaweth_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct kaweth_device *kaweth = usb_get_intfdata(intf);\r\nunsigned long flags;\r\ndbg("Suspending device");\r\nspin_lock_irqsave(&kaweth->device_lock, flags);\r\nkaweth->status |= KAWETH_STATUS_SUSPENDING;\r\nspin_unlock_irqrestore(&kaweth->device_lock, flags);\r\nkaweth_kill_urbs(kaweth);\r\nreturn 0;\r\n}\r\nstatic int kaweth_resume(struct usb_interface *intf)\r\n{\r\nstruct kaweth_device *kaweth = usb_get_intfdata(intf);\r\nunsigned long flags;\r\ndbg("Resuming device");\r\nspin_lock_irqsave(&kaweth->device_lock, flags);\r\nkaweth->status &= ~KAWETH_STATUS_SUSPENDING;\r\nspin_unlock_irqrestore(&kaweth->device_lock, flags);\r\nif (!kaweth->opened)\r\nreturn 0;\r\nkaweth_resubmit_rx_urb(kaweth, GFP_NOIO);\r\nkaweth_resubmit_int_urb(kaweth, GFP_NOIO);\r\nreturn 0;\r\n}\r\nstatic int kaweth_probe(\r\nstruct usb_interface *intf,\r\nconst struct usb_device_id *id\r\n)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct kaweth_device *kaweth;\r\nstruct net_device *netdev;\r\nconst eth_addr_t bcast_addr = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\r\nint result = 0;\r\ndbg("Kawasaki Device Probe (Device number:%d): 0x%4.4x:0x%4.4x:0x%4.4x",\r\ndev->devnum,\r\nle16_to_cpu(dev->descriptor.idVendor),\r\nle16_to_cpu(dev->descriptor.idProduct),\r\nle16_to_cpu(dev->descriptor.bcdDevice));\r\ndbg("Device at %p", dev);\r\ndbg("Descriptor length: %x type: %x",\r\n(int)dev->descriptor.bLength,\r\n(int)dev->descriptor.bDescriptorType);\r\nnetdev = alloc_etherdev(sizeof(*kaweth));\r\nif (!netdev)\r\nreturn -ENOMEM;\r\nkaweth = netdev_priv(netdev);\r\nkaweth->dev = dev;\r\nkaweth->net = netdev;\r\nspin_lock_init(&kaweth->device_lock);\r\ninit_waitqueue_head(&kaweth->term_wait);\r\ndbg("Resetting.");\r\nkaweth_reset(kaweth);\r\nif (le16_to_cpu(dev->descriptor.bcdDevice) >> 8) {\r\ndev_info(&intf->dev, "Firmware present in device.\n");\r\n} else {\r\ndev_info(&intf->dev, "Downloading firmware...\n");\r\nkaweth->firmware_buf = (__u8 *)__get_free_page(GFP_KERNEL);\r\nif ((result = kaweth_download_firmware(kaweth,\r\n"kaweth/new_code.bin",\r\n100,\r\n2)) < 0) {\r\nerr("Error downloading firmware (%d)", result);\r\ngoto err_fw;\r\n}\r\nif ((result = kaweth_download_firmware(kaweth,\r\n"kaweth/new_code_fix.bin",\r\n100,\r\n3)) < 0) {\r\nerr("Error downloading firmware fix (%d)", result);\r\ngoto err_fw;\r\n}\r\nif ((result = kaweth_download_firmware(kaweth,\r\n"kaweth/trigger_code.bin",\r\n126,\r\n2)) < 0) {\r\nerr("Error downloading trigger code (%d)", result);\r\ngoto err_fw;\r\n}\r\nif ((result = kaweth_download_firmware(kaweth,\r\n"kaweth/trigger_code_fix.bin",\r\n126,\r\n3)) < 0) {\r\nerr("Error downloading trigger code fix (%d)", result);\r\ngoto err_fw;\r\n}\r\nif ((result = kaweth_trigger_firmware(kaweth, 126)) < 0) {\r\nerr("Error triggering firmware (%d)", result);\r\ngoto err_fw;\r\n}\r\ndev_info(&intf->dev, "Firmware loaded. I'll be back...\n");\r\nerr_fw:\r\nfree_page((unsigned long)kaweth->firmware_buf);\r\nfree_netdev(netdev);\r\nreturn -EIO;\r\n}\r\nresult = kaweth_read_configuration(kaweth);\r\nif(result < 0) {\r\nerr("Error reading configuration (%d), no net device created", result);\r\ngoto err_free_netdev;\r\n}\r\ndev_info(&intf->dev, "Statistics collection: %x\n", kaweth->configuration.statistics_mask);\r\ndev_info(&intf->dev, "Multicast filter limit: %x\n", kaweth->configuration.max_multicast_filters & ((1 << 15) - 1));\r\ndev_info(&intf->dev, "MTU: %d\n", le16_to_cpu(kaweth->configuration.segment_size));\r\ndev_info(&intf->dev, "Read MAC address %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",\r\n(int)kaweth->configuration.hw_addr[0],\r\n(int)kaweth->configuration.hw_addr[1],\r\n(int)kaweth->configuration.hw_addr[2],\r\n(int)kaweth->configuration.hw_addr[3],\r\n(int)kaweth->configuration.hw_addr[4],\r\n(int)kaweth->configuration.hw_addr[5]);\r\nif(!memcmp(&kaweth->configuration.hw_addr,\r\n&bcast_addr,\r\nsizeof(bcast_addr))) {\r\nerr("Firmware not functioning properly, no net device created");\r\ngoto err_free_netdev;\r\n}\r\nif(kaweth_set_urb_size(kaweth, KAWETH_BUF_SIZE) < 0) {\r\ndbg("Error setting URB size");\r\ngoto err_free_netdev;\r\n}\r\nif(kaweth_set_sofs_wait(kaweth, KAWETH_SOFS_TO_WAIT) < 0) {\r\nerr("Error setting SOFS wait");\r\ngoto err_free_netdev;\r\n}\r\nresult = kaweth_set_receive_filter(kaweth,\r\nKAWETH_PACKET_FILTER_DIRECTED |\r\nKAWETH_PACKET_FILTER_BROADCAST |\r\nKAWETH_PACKET_FILTER_MULTICAST);\r\nif(result < 0) {\r\nerr("Error setting receive filter");\r\ngoto err_free_netdev;\r\n}\r\ndbg("Initializing net device.");\r\nkaweth->intf = intf;\r\nkaweth->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!kaweth->tx_urb)\r\ngoto err_free_netdev;\r\nkaweth->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!kaweth->rx_urb)\r\ngoto err_only_tx;\r\nkaweth->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!kaweth->irq_urb)\r\ngoto err_tx_and_rx;\r\nkaweth->intbuffer = usb_alloc_coherent( kaweth->dev,\r\nINTBUFFERSIZE,\r\nGFP_KERNEL,\r\n&kaweth->intbufferhandle);\r\nif (!kaweth->intbuffer)\r\ngoto err_tx_and_rx_and_irq;\r\nkaweth->rx_buf = usb_alloc_coherent( kaweth->dev,\r\nKAWETH_BUF_SIZE,\r\nGFP_KERNEL,\r\n&kaweth->rxbufferhandle);\r\nif (!kaweth->rx_buf)\r\ngoto err_all_but_rxbuf;\r\nmemcpy(netdev->broadcast, &bcast_addr, sizeof(bcast_addr));\r\nmemcpy(netdev->dev_addr, &kaweth->configuration.hw_addr,\r\nsizeof(kaweth->configuration.hw_addr));\r\nnetdev->netdev_ops = &kaweth_netdev_ops;\r\nnetdev->watchdog_timeo = KAWETH_TX_TIMEOUT;\r\nnetdev->mtu = le16_to_cpu(kaweth->configuration.segment_size);\r\nSET_ETHTOOL_OPS(netdev, &ops);\r\nINIT_DELAYED_WORK(&kaweth->lowmem_work, kaweth_resubmit_tl);\r\nusb_set_intfdata(intf, kaweth);\r\n#if 0\r\nif (dma_supported (&intf->dev, 0xffffffffffffffffULL))\r\nkaweth->net->features |= NETIF_F_HIGHDMA;\r\n#endif\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nif (register_netdev(netdev) != 0) {\r\nerr("Error registering netdev.");\r\ngoto err_intfdata;\r\n}\r\ndev_info(&intf->dev, "kaweth interface created at %s\n",\r\nkaweth->net->name);\r\ndbg("Kaweth probe returning.");\r\nreturn 0;\r\nerr_intfdata:\r\nusb_set_intfdata(intf, NULL);\r\nusb_free_coherent(kaweth->dev, KAWETH_BUF_SIZE, (void *)kaweth->rx_buf, kaweth->rxbufferhandle);\r\nerr_all_but_rxbuf:\r\nusb_free_coherent(kaweth->dev, INTBUFFERSIZE, (void *)kaweth->intbuffer, kaweth->intbufferhandle);\r\nerr_tx_and_rx_and_irq:\r\nusb_free_urb(kaweth->irq_urb);\r\nerr_tx_and_rx:\r\nusb_free_urb(kaweth->rx_urb);\r\nerr_only_tx:\r\nusb_free_urb(kaweth->tx_urb);\r\nerr_free_netdev:\r\nfree_netdev(netdev);\r\nreturn -EIO;\r\n}\r\nstatic void kaweth_disconnect(struct usb_interface *intf)\r\n{\r\nstruct kaweth_device *kaweth = usb_get_intfdata(intf);\r\nstruct net_device *netdev;\r\ndev_info(&intf->dev, "Unregistering\n");\r\nusb_set_intfdata(intf, NULL);\r\nif (!kaweth) {\r\ndev_warn(&intf->dev, "unregistering non-existent device\n");\r\nreturn;\r\n}\r\nnetdev = kaweth->net;\r\ndbg("Unregistering net device");\r\nunregister_netdev(netdev);\r\nusb_free_urb(kaweth->rx_urb);\r\nusb_free_urb(kaweth->tx_urb);\r\nusb_free_urb(kaweth->irq_urb);\r\nusb_free_coherent(kaweth->dev, KAWETH_BUF_SIZE, (void *)kaweth->rx_buf, kaweth->rxbufferhandle);\r\nusb_free_coherent(kaweth->dev, INTBUFFERSIZE, (void *)kaweth->intbuffer, kaweth->intbufferhandle);\r\nfree_netdev(netdev);\r\n}\r\nstatic void usb_api_blocking_completion(struct urb *urb)\r\n{\r\nstruct usb_api_data *awd = (struct usb_api_data *)urb->context;\r\nawd->done=1;\r\nwake_up(&awd->wqh);\r\n}\r\nstatic int usb_start_wait_urb(struct urb *urb, int timeout, int* actual_length)\r\n{\r\nstruct usb_api_data awd;\r\nint status;\r\ninit_waitqueue_head(&awd.wqh);\r\nawd.done = 0;\r\nurb->context = &awd;\r\nstatus = usb_submit_urb(urb, GFP_NOIO);\r\nif (status) {\r\nusb_free_urb(urb);\r\nreturn status;\r\n}\r\nif (!wait_event_timeout(awd.wqh, awd.done, timeout)) {\r\ndev_warn(&urb->dev->dev, "usb_control/bulk_msg: timeout\n");\r\nusb_kill_urb(urb);\r\nstatus = -ETIMEDOUT;\r\n}\r\nelse {\r\nstatus = urb->status;\r\n}\r\nif (actual_length) {\r\n*actual_length = urb->actual_length;\r\n}\r\nusb_free_urb(urb);\r\nreturn status;\r\n}\r\nstatic int kaweth_internal_control_msg(struct usb_device *usb_dev,\r\nunsigned int pipe,\r\nstruct usb_ctrlrequest *cmd, void *data,\r\nint len, int timeout)\r\n{\r\nstruct urb *urb;\r\nint retv;\r\nint length = 0;\r\nurb = usb_alloc_urb(0, GFP_NOIO);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nusb_fill_control_urb(urb, usb_dev, pipe, (unsigned char*)cmd, data,\r\nlen, usb_api_blocking_completion, NULL);\r\nretv = usb_start_wait_urb(urb, timeout, &length);\r\nif (retv < 0) {\r\nreturn retv;\r\n}\r\nelse {\r\nreturn length;\r\n}\r\n}\r\nstatic int __init kaweth_init(void)\r\n{\r\ndbg("Driver loading");\r\nreturn usb_register(&kaweth_driver);\r\n}\r\nstatic void __exit kaweth_exit(void)\r\n{\r\nusb_deregister(&kaweth_driver);\r\n}
