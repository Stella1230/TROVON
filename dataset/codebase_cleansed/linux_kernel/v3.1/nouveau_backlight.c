static int nv40_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nint val = (nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK)\r\n>> 16;\r\nreturn val;\r\n}\r\nstatic int nv40_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nint val = bd->props.brightness;\r\nint reg = nv_rd32(dev, NV40_PMC_BACKLIGHT);\r\nnv_wr32(dev, NV40_PMC_BACKLIGHT,\r\n(val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));\r\nreturn 0;\r\n}\r\nstatic int nv50_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nreturn nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT);\r\n}\r\nstatic int nv50_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nint val = bd->props.brightness;\r\nnv_wr32(dev, NV50_PDISPLAY_SOR_BACKLIGHT,\r\nval | NV50_PDISPLAY_SOR_BACKLIGHT_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int nouveau_nv40_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nif (!(nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))\r\nreturn 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 31;\r\nbd = backlight_device_register("nv_backlight", &connector->kdev, dev,\r\n&nv40_bl_ops, &props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\ndev_priv->backlight = bd;\r\nbd->props.brightness = nv40_get_intensity(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nstatic int nouveau_nv50_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nif (!nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT))\r\nreturn 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 1025;\r\nbd = backlight_device_register("nv_backlight", &connector->kdev, dev,\r\n&nv50_bl_ops, &props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\ndev_priv->backlight = bd;\r\nbd->props.brightness = nv50_get_intensity(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nint nouveau_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\n#ifdef CONFIG_ACPI\r\nif (acpi_video_backlight_support()) {\r\nNV_INFO(dev, "ACPI backlight interface available, "\r\n"not registering our own\n");\r\nreturn 0;\r\n}\r\n#endif\r\nswitch (dev_priv->card_type) {\r\ncase NV_40:\r\nreturn nouveau_nv40_backlight_init(connector);\r\ncase NV_50:\r\nreturn nouveau_nv50_backlight_init(connector);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid nouveau_backlight_exit(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->backlight) {\r\nbacklight_device_unregister(dev_priv->backlight);\r\ndev_priv->backlight = NULL;\r\n}\r\n}
