sint _r8712_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag)\r\n{\r\nphw_txqueue->ac_tag = ac_tag;\r\nswitch (ac_tag) {\r\ncase BE_QUEUE_INX:\r\nphw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;\r\nbreak;\r\ncase BK_QUEUE_INX:\r\nphw_txqueue->ff_hwaddr = RTL8712_DMA_BKQ;\r\nbreak;\r\ncase VI_QUEUE_INX:\r\nphw_txqueue->ff_hwaddr = RTL8712_DMA_VIQ;\r\nbreak;\r\ncase VO_QUEUE_INX:\r\nphw_txqueue->ff_hwaddr = RTL8712_DMA_VOQ;\r\nbreak;\r\ncase BMC_QUEUE_INX:\r\nphw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;\r\nbreak;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nint r8712_txframes_sta_ac_pending(struct _adapter *padapter,\r\nstruct pkt_attrib *pattrib)\r\n{\r\nstruct sta_info *psta;\r\nstruct tx_servq *ptxservq;\r\nint priority = pattrib->priority;\r\npsta = pattrib->psta;\r\nswitch (priority) {\r\ncase 1:\r\ncase 2:\r\nptxservq = &(psta->sta_xmitpriv.bk_q);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nptxservq = &(psta->sta_xmitpriv.vi_q);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nptxservq = &(psta->sta_xmitpriv.vo_q);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nptxservq = &(psta->sta_xmitpriv.be_q);\r\nbreak;\r\n}\r\nreturn ptxservq->qcnt;\r\n}\r\nstatic u32 get_ff_hwaddr(struct xmit_frame *pxmitframe)\r\n{\r\nu32 addr = 0;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct _adapter *padapter = pxmitframe->padapter;\r\nstruct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;\r\nif (pxmitframe->frame_tag == TXAGG_FRAMETAG)\r\naddr = RTL8712_DMA_H2CCMD;\r\nelse if (pxmitframe->frame_tag == MGNT_FRAMETAG)\r\naddr = RTL8712_DMA_MGTQ;\r\nelse if (pdvobj->nr_endpoint == 6) {\r\nswitch (pattrib->priority) {\r\ncase 0:\r\ncase 3:\r\naddr = RTL8712_DMA_BEQ;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\naddr = RTL8712_DMA_BKQ;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\naddr = RTL8712_DMA_VIQ;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\naddr = RTL8712_DMA_VOQ;\r\nbreak;\r\ncase 0x10:\r\ncase 0x11:\r\ncase 0x12:\r\ncase 0x13:\r\naddr = RTL8712_DMA_H2CCMD;\r\nbreak;\r\ndefault:\r\naddr = RTL8712_DMA_BEQ;\r\nbreak;\r\n}\r\n} else if (pdvobj->nr_endpoint == 4) {\r\nswitch (pattrib->qsel) {\r\ncase 0:\r\ncase 3:\r\ncase 1:\r\ncase 2:\r\naddr = RTL8712_DMA_BEQ;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\naddr = RTL8712_DMA_VOQ;\r\nbreak;\r\ncase 0x10:\r\ncase 0x11:\r\ncase 0x12:\r\ncase 0x13:\r\naddr = RTL8712_DMA_H2CCMD;\r\nbreak;\r\ndefault:\r\naddr = RTL8712_DMA_BEQ;\r\nbreak;\r\n}\r\n}\r\nreturn addr;\r\n}\r\nstatic struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv,\r\nstruct hw_xmit *phwxmit,\r\nstruct tx_servq *ptxservq,\r\nstruct __queue *pframe_queue)\r\n{\r\nstruct list_head *xmitframe_plist, *xmitframe_phead;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nxmitframe_phead = get_list_head(pframe_queue);\r\nxmitframe_plist = get_next(xmitframe_phead);\r\nif ((end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {\r\npxmitframe = LIST_CONTAINOR(xmitframe_plist,\r\nstruct xmit_frame, list);\r\nlist_delete(&pxmitframe->list);\r\nptxservq->qcnt--;\r\nphwxmit->txcmdcnt++;\r\n}\r\nreturn pxmitframe;\r\n}\r\nstatic struct xmit_frame *dequeue_xframe_ex(struct xmit_priv *pxmitpriv,\r\nstruct hw_xmit *phwxmit_i, sint entry)\r\n{\r\nunsigned long irqL0;\r\nstruct list_head *sta_plist, *sta_phead;\r\nstruct hw_xmit *phwxmit;\r\nstruct tx_servq *ptxservq = NULL;\r\nstruct __queue *pframe_queue = NULL;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nint i, inx[4];\r\nint j, tmp, acirp_cnt[4];\r\ninx[0] = 0; acirp_cnt[0] = pxmitpriv->voq_cnt;\r\ninx[1] = 1; acirp_cnt[1] = pxmitpriv->viq_cnt;\r\ninx[2] = 2; acirp_cnt[2] = pxmitpriv->beq_cnt;\r\ninx[3] = 3; acirp_cnt[3] = pxmitpriv->bkq_cnt;\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = i + 1; j < 4; j++) {\r\nif (acirp_cnt[j] < acirp_cnt[i]) {\r\ntmp = acirp_cnt[i];\r\nacirp_cnt[i] = acirp_cnt[j];\r\nacirp_cnt[j] = tmp;\r\ntmp = inx[i];\r\ninx[i] = inx[j];\r\ninx[j] = tmp;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&pxmitpriv->lock, irqL0);\r\nfor (i = 0; i < entry; i++) {\r\nphwxmit = phwxmit_i + inx[i];\r\nsta_phead = get_list_head(phwxmit->sta_queue);\r\nsta_plist = get_next(sta_phead);\r\nwhile ((end_of_queue_search(sta_phead, sta_plist)) == false) {\r\nptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq,\r\ntx_pending);\r\npframe_queue = &ptxservq->sta_pending;\r\npxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit,\r\nptxservq, pframe_queue);\r\nif (pxmitframe) {\r\nphwxmit->accnt--;\r\ngoto exit_dequeue_xframe_ex;\r\n}\r\nsta_plist = get_next(sta_plist);\r\nif (_queue_empty(pframe_queue)) {\r\nlist_delete(&ptxservq->tx_pending);\r\n}\r\n}\r\n}\r\nexit_dequeue_xframe_ex:\r\nspin_unlock_irqrestore(&pxmitpriv->lock, irqL0);\r\nreturn pxmitframe;\r\n}\r\nvoid r8712_do_queue_select(struct _adapter *padapter,\r\nstruct pkt_attrib *pattrib)\r\n{\r\nu8 qsel = 0;\r\nstruct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;\r\nif (pdvobj->nr_endpoint == 6)\r\nqsel = pattrib->priority;\r\nelse if (pdvobj->nr_endpoint == 4)\r\nqsel = pattrib->priority;\r\npattrib->qsel = qsel;\r\n}\r\nstatic void update_txdesc(struct xmit_frame *pxmitframe, uint *pmem, int sz)\r\n{\r\nuint qsel;\r\nstruct _adapter *padapter = pxmitframe->padapter;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct tx_desc *ptxdesc = (struct tx_desc *)pmem;\r\nstruct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;\r\nu8 blnSetTxDescOffset;\r\nsint bmcst = IS_MCAST(pattrib->ra);\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nstruct tx_desc txdesc_mp;\r\nmemcpy(&txdesc_mp, ptxdesc, sizeof(struct tx_desc));\r\nmemset(ptxdesc, 0, sizeof(struct tx_desc));\r\nptxdesc->txdw0 |= cpu_to_le32(sz&0x0000ffff);\r\nif (pdvobj->ishighspeed) {\r\nif (((sz + TXDESC_SIZE) % 512) == 0)\r\nblnSetTxDescOffset = 1;\r\nelse\r\nblnSetTxDescOffset = 0;\r\n} else {\r\nif (((sz + TXDESC_SIZE) % 64) == 0)\r\nblnSetTxDescOffset = 1;\r\nelse\r\nblnSetTxDescOffset = 0;\r\n}\r\nif (blnSetTxDescOffset) {\r\nptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ + 8) <<\r\nOFFSET_SHT) & 0x00ff0000);\r\n} else {\r\nptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ) <<\r\nOFFSET_SHT) & 0x00ff0000);\r\n}\r\nptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\r\nif (pxmitframe->frame_tag == DATA_FRAMETAG) {\r\nptxdesc->txdw1 |= cpu_to_le32((pattrib->mac_id)&0x1f);\r\nqsel = (uint)(pattrib->qsel & 0x0000001f);\r\nptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\r\nif (!pqospriv->qos_option)\r\nptxdesc->txdw1 |= cpu_to_le32(BIT(16));\r\nif ((pattrib->encrypt > 0) && !pattrib->bswenc) {\r\nswitch (pattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nptxdesc->txdw1 |= cpu_to_le32((0x01 << 22) &\r\n0x00c00000);\r\nptxdesc->txdw1 |= cpu_to_le32((psecuritypriv->\r\nPrivacyKeyIndex << 17) &\r\n0x00060000);\r\nbreak;\r\ncase _TKIP_:\r\ncase _TKIP_WTMIC_:\r\nptxdesc->txdw1 |= cpu_to_le32((0x02 << 22) &\r\n0x00c00000);\r\nbreak;\r\ncase _AES_:\r\nptxdesc->txdw1 |= cpu_to_le32((0x03 << 22) &\r\n0x00c00000);\r\nbreak;\r\ncase _NO_PRIVACY_:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (bmcst)\r\nptxdesc->txdw2 |= cpu_to_le32(BMC);\r\nptxdesc->txdw3 = cpu_to_le32((pattrib->priority << SEQ_SHT) &\r\n0x0fff0000);\r\nif ((pattrib->ether_type != 0x888e) &&\r\n(pattrib->ether_type != 0x0806) &&\r\n(pattrib->dhcp_pkt != 1)) {\r\nif (phtpriv->ht_option == 1) {\r\nif (phtpriv->ampdu_enable != true)\r\nptxdesc->txdw2 |= cpu_to_le32(BK);\r\n}\r\n} else {\r\nptxdesc->txdw4 = cpu_to_le32(0x80000000);\r\nptxdesc->txdw5 = cpu_to_le32(0x001f8000);\r\n}\r\nif (pattrib->pctrl == 1) {\r\nstruct tx_desc *ptxdesc_mp;\r\nptxdesc_mp = &txdesc_mp;\r\nptxdesc->txdw2 = cpu_to_le32(ptxdesc_mp->txdw2);\r\nif (bmcst)\r\nptxdesc->txdw2 |= cpu_to_le32(BMC);\r\nptxdesc->txdw2 |= cpu_to_le32(BK);\r\nptxdesc->txdw4 = cpu_to_le32(ptxdesc_mp->txdw4);\r\nptxdesc->txdw5 = cpu_to_le32(ptxdesc_mp->txdw5);\r\npattrib->pctrl = 0;\r\n}\r\n} else if (pxmitframe->frame_tag == MGNT_FRAMETAG) {\r\nptxdesc->txdw1 |= (0x05) & 0x1f;\r\nqsel = (uint)(pattrib->qsel & 0x0000001f);\r\nptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\r\nptxdesc->txdw1 |= cpu_to_le32(BIT(16));\r\nif (bmcst)\r\nptxdesc->txdw2 |= cpu_to_le32(BMC);\r\nptxdesc->txdw3 = cpu_to_le32((pattrib->priority << SEQ_SHT) &\r\n0x0fff0000);\r\nptxdesc->txdw4 = cpu_to_le32(0x80002040);\r\nptxdesc->txdw5 = cpu_to_le32(0x001f8000);\r\n} else if (pxmitframe->frame_tag == TXAGG_FRAMETAG) {\r\nqsel = 0x13;\r\nptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\r\n} else {\r\nqsel = (uint)(pattrib->priority&0x0000001f);\r\nptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\r\nptxdesc->txdw3 = cpu_to_le32((pattrib->seqnum << SEQ_SHT) &\r\n0x0fff0000);\r\nptxdesc->txdw4 = cpu_to_le32(0x80002040);\r\nptxdesc->txdw5 = cpu_to_le32(0x001f9600);\r\n}\r\n}\r\nint r8712_xmitframe_complete(struct _adapter *padapter,\r\nstruct xmit_priv *pxmitpriv,\r\nstruct xmit_buf *pxmitbuf)\r\n{\r\nstruct hw_xmit *phwxmits;\r\nsint hwentry;\r\nstruct xmit_frame *pxmitframe = NULL;\r\nint res = _SUCCESS, xcnt = 0;\r\nphwxmits = pxmitpriv->hwxmits;\r\nhwentry = pxmitpriv->hwxmit_entry;\r\nif (pxmitbuf == NULL) {\r\npxmitbuf = r8712_alloc_xmitbuf(pxmitpriv);\r\nif (!pxmitbuf)\r\nreturn false;\r\n}\r\ndo {\r\npxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits, hwentry);\r\nif (pxmitframe) {\r\npxmitframe->pxmitbuf = pxmitbuf;\r\npxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];\r\npxmitframe->buf_addr = pxmitbuf->pbuf;\r\nif (pxmitframe->frame_tag == DATA_FRAMETAG) {\r\nif (pxmitframe->attrib.priority <= 15)\r\nres = r8712_xmitframe_coalesce(padapter,\r\npxmitframe->pkt, pxmitframe);\r\nr8712_xmit_complete(padapter, pxmitframe);\r\n}\r\nif (res == _SUCCESS)\r\ndump_xframe(padapter, pxmitframe);\r\nelse\r\nr8712_free_xmitframe_ex(pxmitpriv, pxmitframe);\r\nxcnt++;\r\n} else {\r\nr8712_free_xmitbuf(pxmitpriv, pxmitbuf);\r\nreturn false;\r\n}\r\nbreak;\r\n} while (0);\r\nreturn true;\r\n}\r\nstatic void dump_xframe(struct _adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nint t, sz, w_sz;\r\nu8 *mem_addr;\r\nu32 ff_hwaddr;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nif (pxmitframe->attrib.ether_type != 0x0806) {\r\nif (pxmitframe->attrib.ether_type != 0x888e)\r\nr8712_issue_addbareq_cmd(padapter, pattrib->priority);\r\n}\r\nmem_addr = pxmitframe->buf_addr;\r\nfor (t = 0; t < pattrib->nr_frags; t++) {\r\nif (t != (pattrib->nr_frags - 1)) {\r\nsz = pxmitpriv->frag_len;\r\nsz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 :\r\npattrib->icv_len);\r\npxmitframe->last[t] = 0;\r\n} else {\r\nsz = pattrib->last_txcmdsz;\r\npxmitframe->last[t] = 1;\r\n}\r\nupdate_txdesc(pxmitframe, (uint *)mem_addr, sz);\r\nw_sz = sz + TXDESC_SIZE;\r\npxmitframe->mem_addr = mem_addr;\r\npxmitframe->bpending[t] = false;\r\nff_hwaddr = get_ff_hwaddr(pxmitframe);\r\nr8712_write_port(padapter, ff_hwaddr, w_sz,\r\n(unsigned char *)pxmitframe);\r\nmem_addr += w_sz;\r\nmem_addr = (u8 *)RND4(((addr_t)(mem_addr)));\r\n}\r\n}\r\nint r8712_xmit_direct(struct _adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nint res = _SUCCESS;\r\nres = r8712_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);\r\npxmitframe->pkt = NULL;\r\nif (res == _SUCCESS)\r\ndump_xframe(padapter, pxmitframe);\r\nreturn res;\r\n}\r\nint r8712_xmit_enqueue(struct _adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nif (r8712_xmit_classifier(padapter, pxmitframe) == _FAIL) {\r\npxmitframe->pkt = NULL;\r\nreturn _FAIL;\r\n}\r\nreturn _SUCCESS;\r\n}
