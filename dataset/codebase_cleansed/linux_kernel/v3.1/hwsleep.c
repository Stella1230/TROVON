acpi_status\r\nacpi_set_firmware_waking_vector(u32 physical_address)\r\n{\r\nACPI_FUNCTION_TRACE(acpi_set_firmware_waking_vector);\r\nacpi_gbl_FACS->firmware_waking_vector = physical_address;\r\nif ((acpi_gbl_FACS->length > 32) && (acpi_gbl_FACS->version >= 1)) {\r\nacpi_gbl_FACS->xfirmware_waking_vector = 0;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_set_firmware_waking_vector64(u64 physical_address)\r\n{\r\nACPI_FUNCTION_TRACE(acpi_set_firmware_waking_vector64);\r\nif ((acpi_gbl_FACS->length <= 32) || (acpi_gbl_FACS->version < 1)) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nacpi_gbl_FACS->firmware_waking_vector = 0;\r\nacpi_gbl_FACS->xfirmware_waking_vector = physical_address;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_enter_sleep_state_prep(u8 sleep_state)\r\n{\r\nacpi_status status;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nACPI_FUNCTION_TRACE(acpi_enter_sleep_state_prep);\r\nstatus = acpi_get_sleep_type_data(sleep_state,\r\n&acpi_gbl_sleep_type_a,\r\n&acpi_gbl_sleep_type_b);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = sleep_state;\r\nstatus = acpi_evaluate_object(NULL, METHOD_NAME__PTS, &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nswitch (sleep_state) {\r\ncase ACPI_STATE_S0:\r\narg.integer.value = ACPI_SST_WORKING;\r\nbreak;\r\ncase ACPI_STATE_S1:\r\ncase ACPI_STATE_S2:\r\ncase ACPI_STATE_S3:\r\narg.integer.value = ACPI_SST_SLEEPING;\r\nbreak;\r\ncase ACPI_STATE_S4:\r\narg.integer.value = ACPI_SST_SLEEP_CONTEXT;\r\nbreak;\r\ndefault:\r\narg.integer.value = ACPI_SST_INDICATOR_OFF;\r\nbreak;\r\n}\r\nstatus = acpi_evaluate_object(NULL, METHOD_NAME__SST, &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"While executing method _SST"));\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status asmlinkage acpi_enter_sleep_state(u8 sleep_state)\r\n{\r\nu32 pm1a_control;\r\nu32 pm1b_control;\r\nstruct acpi_bit_register_info *sleep_type_reg_info;\r\nstruct acpi_bit_register_info *sleep_enable_reg_info;\r\nu32 in_value;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_enter_sleep_state);\r\nif ((acpi_gbl_sleep_type_a > ACPI_SLEEP_TYPE_MAX) ||\r\n(acpi_gbl_sleep_type_b > ACPI_SLEEP_TYPE_MAX)) {\r\nACPI_ERROR((AE_INFO, "Sleep values out of range: A=0x%X B=0x%X",\r\nacpi_gbl_sleep_type_a, acpi_gbl_sleep_type_b));\r\nreturn_ACPI_STATUS(AE_AML_OPERAND_VALUE);\r\n}\r\nsleep_type_reg_info =\r\nacpi_hw_get_bit_register_info(ACPI_BITREG_SLEEP_TYPE);\r\nsleep_enable_reg_info =\r\nacpi_hw_get_bit_register_info(ACPI_BITREG_SLEEP_ENABLE);\r\nstatus =\r\nacpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_clear_acpi_status();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_disable_all_gpes();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_gbl_system_awake_and_running = FALSE;\r\nstatus = acpi_hw_enable_all_wakeup_gpes();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (gts) {\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = sleep_state;\r\nstatus = acpi_evaluate_object(NULL, METHOD_NAME__GTS, &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nstatus = acpi_hw_register_read(ACPI_REGISTER_PM1_CONTROL,\r\n&pm1a_control);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INIT,\r\n"Entering sleep state [S%u]\n", sleep_state));\r\npm1a_control &= ~(sleep_type_reg_info->access_bit_mask |\r\nsleep_enable_reg_info->access_bit_mask);\r\npm1b_control = pm1a_control;\r\npm1a_control |=\r\n(acpi_gbl_sleep_type_a << sleep_type_reg_info->bit_position);\r\npm1b_control |=\r\n(acpi_gbl_sleep_type_b << sleep_type_reg_info->bit_position);\r\nstatus = acpi_hw_write_pm1_control(pm1a_control, pm1b_control);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\npm1a_control |= sleep_enable_reg_info->access_bit_mask;\r\npm1b_control |= sleep_enable_reg_info->access_bit_mask;\r\nACPI_FLUSH_CPU_CACHE();\r\ntboot_sleep(sleep_state, pm1a_control, pm1b_control);\r\nstatus = acpi_hw_write_pm1_control(pm1a_control, pm1b_control);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (sleep_state > ACPI_STATE_S3) {\r\nacpi_os_stall(10000000);\r\nstatus = acpi_hw_register_write(ACPI_REGISTER_PM1_CONTROL,\r\nsleep_enable_reg_info->\r\naccess_bit_mask);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\ndo {\r\nstatus = acpi_read_bit_register(ACPI_BITREG_WAKE_STATUS,\r\n&in_value);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n} while (!in_value);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status asmlinkage acpi_enter_sleep_state_s4bios(void)\r\n{\r\nu32 in_value;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_enter_sleep_state_s4bios);\r\nstatus =\r\nacpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_clear_acpi_status();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_disable_all_gpes();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_gbl_system_awake_and_running = FALSE;\r\nstatus = acpi_hw_enable_all_wakeup_gpes();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nACPI_FLUSH_CPU_CACHE();\r\nstatus = acpi_hw_write_port(acpi_gbl_FADT.smi_command,\r\n(u32) acpi_gbl_FADT.S4bios_request, 8);\r\ndo {\r\nacpi_os_stall(1000);\r\nstatus =\r\nacpi_read_bit_register(ACPI_BITREG_WAKE_STATUS, &in_value);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n} while (!in_value);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_leave_sleep_state_prep(u8 sleep_state)\r\n{\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status;\r\nstruct acpi_bit_register_info *sleep_type_reg_info;\r\nstruct acpi_bit_register_info *sleep_enable_reg_info;\r\nu32 pm1a_control;\r\nu32 pm1b_control;\r\nACPI_FUNCTION_TRACE(acpi_leave_sleep_state_prep);\r\nstatus = acpi_get_sleep_type_data(ACPI_STATE_S0,\r\n&acpi_gbl_sleep_type_a,\r\n&acpi_gbl_sleep_type_b);\r\nif (ACPI_SUCCESS(status)) {\r\nsleep_type_reg_info =\r\nacpi_hw_get_bit_register_info(ACPI_BITREG_SLEEP_TYPE);\r\nsleep_enable_reg_info =\r\nacpi_hw_get_bit_register_info(ACPI_BITREG_SLEEP_ENABLE);\r\nstatus = acpi_hw_register_read(ACPI_REGISTER_PM1_CONTROL,\r\n&pm1a_control);\r\nif (ACPI_SUCCESS(status)) {\r\npm1a_control &= ~(sleep_type_reg_info->access_bit_mask |\r\nsleep_enable_reg_info->\r\naccess_bit_mask);\r\npm1b_control = pm1a_control;\r\npm1a_control |= (acpi_gbl_sleep_type_a <<\r\nsleep_type_reg_info->bit_position);\r\npm1b_control |= (acpi_gbl_sleep_type_b <<\r\nsleep_type_reg_info->bit_position);\r\n(void)acpi_hw_write_pm1_control(pm1a_control,\r\npm1b_control);\r\n}\r\n}\r\nif (bfs) {\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = sleep_state;\r\nstatus = acpi_evaluate_object(NULL, METHOD_NAME__BFS, &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "During Method _BFS"));\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_leave_sleep_state(u8 sleep_state)\r\n{\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_leave_sleep_state);\r\nacpi_gbl_sleep_type_a = ACPI_SLEEP_TYPE_INVALID;\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = ACPI_SST_WAKING;\r\nstatus = acpi_evaluate_object(NULL, METHOD_NAME__SST, &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "During Method _SST"));\r\n}\r\nstatus = acpi_hw_disable_all_gpes();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_hw_enable_all_runtime_gpes();\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\narg.integer.value = sleep_state;\r\nstatus = acpi_evaluate_object(NULL, METHOD_NAME__WAK, &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "During Method _WAK"));\r\n}\r\nacpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, 1);\r\nacpi_gbl_system_awake_and_running = TRUE;\r\n(void)\r\nacpi_write_bit_register(acpi_gbl_fixed_event_info\r\n[ACPI_EVENT_POWER_BUTTON].\r\nenable_register_id, ACPI_ENABLE_EVENT);\r\n(void)\r\nacpi_write_bit_register(acpi_gbl_fixed_event_info\r\n[ACPI_EVENT_POWER_BUTTON].\r\nstatus_register_id, ACPI_CLEAR_STATUS);\r\narg.integer.value = ACPI_SST_WORKING;\r\nstatus = acpi_evaluate_object(NULL, METHOD_NAME__SST, &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "During Method _SST"));\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}
