static struct csis_state *sd_to_csis_state(struct v4l2_subdev *sdev)\r\n{\r\nreturn container_of(sdev, struct csis_state, sd);\r\n}\r\nstatic const struct csis_pix_format *find_csis_format(\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(s5pcsis_formats); i++)\r\nif (mf->code == s5pcsis_formats[i].code)\r\nreturn &s5pcsis_formats[i];\r\nreturn NULL;\r\n}\r\nstatic void s5pcsis_enable_interrupts(struct csis_state *state, bool on)\r\n{\r\nu32 val = s5pcsis_read(state, S5PCSIS_INTMSK);\r\nval = on ? val | S5PCSIS_INTMSK_EN_ALL :\r\nval & ~S5PCSIS_INTMSK_EN_ALL;\r\ns5pcsis_write(state, S5PCSIS_INTMSK, val);\r\n}\r\nstatic void s5pcsis_reset(struct csis_state *state)\r\n{\r\nu32 val = s5pcsis_read(state, S5PCSIS_CTRL);\r\ns5pcsis_write(state, S5PCSIS_CTRL, val | S5PCSIS_CTRL_RESET);\r\nudelay(10);\r\n}\r\nstatic void s5pcsis_system_enable(struct csis_state *state, int on)\r\n{\r\nu32 val;\r\nval = s5pcsis_read(state, S5PCSIS_CTRL);\r\nif (on)\r\nval |= S5PCSIS_CTRL_ENABLE;\r\nelse\r\nval &= ~S5PCSIS_CTRL_ENABLE;\r\ns5pcsis_write(state, S5PCSIS_CTRL, val);\r\nval = s5pcsis_read(state, S5PCSIS_DPHYCTRL);\r\nif (on)\r\nval |= S5PCSIS_DPHYCTRL_ENABLE;\r\nelse\r\nval &= ~S5PCSIS_DPHYCTRL_ENABLE;\r\ns5pcsis_write(state, S5PCSIS_DPHYCTRL, val);\r\n}\r\nstatic void __s5pcsis_set_format(struct csis_state *state)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &state->format;\r\nu32 val;\r\nv4l2_dbg(1, debug, &state->sd, "fmt: %d, %d x %d\n",\r\nmf->code, mf->width, mf->height);\r\nval = s5pcsis_read(state, S5PCSIS_CONFIG);\r\nval = (val & ~S5PCSIS_CFG_FMT_MASK) | state->csis_fmt->fmt_reg;\r\ns5pcsis_write(state, S5PCSIS_CONFIG, val);\r\nval = (mf->width << 16) | mf->height;\r\ns5pcsis_write(state, S5PCSIS_RESOL, val);\r\n}\r\nstatic void s5pcsis_set_hsync_settle(struct csis_state *state, int settle)\r\n{\r\nu32 val = s5pcsis_read(state, S5PCSIS_DPHYCTRL);\r\nval = (val & ~S5PCSIS_DPHYCTRL_HSS_MASK) | (settle << 27);\r\ns5pcsis_write(state, S5PCSIS_DPHYCTRL, val);\r\n}\r\nstatic void s5pcsis_set_params(struct csis_state *state)\r\n{\r\nstruct s5p_platform_mipi_csis *pdata = state->pdev->dev.platform_data;\r\nu32 val;\r\nval = s5pcsis_read(state, S5PCSIS_CONFIG);\r\nval = (val & ~S5PCSIS_CFG_NR_LANE_MASK) | (pdata->lanes - 1);\r\ns5pcsis_write(state, S5PCSIS_CONFIG, val);\r\n__s5pcsis_set_format(state);\r\ns5pcsis_set_hsync_settle(state, pdata->hs_settle);\r\nval = s5pcsis_read(state, S5PCSIS_CTRL);\r\nif (pdata->alignment == 32)\r\nval |= S5PCSIS_CTRL_ALIGN_32BIT;\r\nelse\r\nval &= ~S5PCSIS_CTRL_ALIGN_32BIT;\r\nval &= ~S5PCSIS_CTRL_WCLK_EXTCLK;\r\ns5pcsis_write(state, S5PCSIS_CTRL, val);\r\nval = s5pcsis_read(state, S5PCSIS_CTRL);\r\ns5pcsis_write(state, S5PCSIS_CTRL, val | S5PCSIS_CTRL_UPDATE_SHADOW);\r\n}\r\nstatic void s5pcsis_clk_put(struct csis_state *state)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_CSIS_CLOCKS; i++)\r\nif (!IS_ERR_OR_NULL(state->clock[i]))\r\nclk_put(state->clock[i]);\r\n}\r\nstatic int s5pcsis_clk_get(struct csis_state *state)\r\n{\r\nstruct device *dev = &state->pdev->dev;\r\nint i;\r\nfor (i = 0; i < NUM_CSIS_CLOCKS; i++) {\r\nstate->clock[i] = clk_get(dev, csi_clock_name[i]);\r\nif (IS_ERR(state->clock[i])) {\r\ns5pcsis_clk_put(state);\r\ndev_err(dev, "failed to get clock: %s\n",\r\ncsi_clock_name[i]);\r\nreturn -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5pcsis_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nstruct device *dev = &state->pdev->dev;\r\nif (on)\r\nreturn pm_runtime_get_sync(dev);\r\nreturn pm_runtime_put_sync(dev);\r\n}\r\nstatic void s5pcsis_start_stream(struct csis_state *state)\r\n{\r\ns5pcsis_reset(state);\r\ns5pcsis_set_params(state);\r\ns5pcsis_system_enable(state, true);\r\ns5pcsis_enable_interrupts(state, true);\r\n}\r\nstatic void s5pcsis_stop_stream(struct csis_state *state)\r\n{\r\ns5pcsis_enable_interrupts(state, false);\r\ns5pcsis_system_enable(state, false);\r\n}\r\nstatic int s5pcsis_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "%s: %d, state: 0x%x\n",\r\n__func__, enable, state->flags);\r\nif (enable) {\r\nret = pm_runtime_get_sync(&state->pdev->dev);\r\nif (ret && ret != 1)\r\nreturn ret;\r\n}\r\nmutex_lock(&state->lock);\r\nif (enable) {\r\nif (state->flags & ST_SUSPENDED) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\ns5pcsis_start_stream(state);\r\nstate->flags |= ST_STREAMING;\r\n} else {\r\ns5pcsis_stop_stream(state);\r\nstate->flags &= ~ST_STREAMING;\r\n}\r\nunlock:\r\nmutex_unlock(&state->lock);\r\nif (!enable)\r\npm_runtime_put(&state->pdev->dev);\r\nreturn ret == 1 ? 0 : ret;\r\n}\r\nstatic int s5pcsis_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(s5pcsis_formats))\r\nreturn -EINVAL;\r\ncode->code = s5pcsis_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic struct csis_pix_format const *s5pcsis_try_format(\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct csis_pix_format const *csis_fmt;\r\ncsis_fmt = find_csis_format(mf);\r\nif (csis_fmt == NULL)\r\ncsis_fmt = &s5pcsis_formats[0];\r\nmf->code = csis_fmt->code;\r\nv4l_bound_align_image(&mf->width, 1, CSIS_MAX_PIX_WIDTH,\r\ncsis_fmt->pix_width_alignment,\r\n&mf->height, 1, CSIS_MAX_PIX_HEIGHT, 1,\r\n0);\r\nreturn csis_fmt;\r\n}\r\nstatic struct v4l2_mbus_framefmt *__s5pcsis_get_format(\r\nstruct csis_state *state, struct v4l2_subdev_fh *fh,\r\nu32 pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn fh ? v4l2_subdev_get_try_format(fh, pad) : NULL;\r\nreturn &state->format;\r\n}\r\nstatic int s5pcsis_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nstruct csis_pix_format const *csis_fmt;\r\nstruct v4l2_mbus_framefmt *mf;\r\nif (fmt->pad != CSIS_PAD_SOURCE && fmt->pad != CSIS_PAD_SINK)\r\nreturn -EINVAL;\r\nmf = __s5pcsis_get_format(state, fh, fmt->pad, fmt->which);\r\nif (fmt->pad == CSIS_PAD_SOURCE) {\r\nif (mf) {\r\nmutex_lock(&state->lock);\r\nfmt->format = *mf;\r\nmutex_unlock(&state->lock);\r\n}\r\nreturn 0;\r\n}\r\ncsis_fmt = s5pcsis_try_format(&fmt->format);\r\nif (mf) {\r\nmutex_lock(&state->lock);\r\n*mf = fmt->format;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nstate->csis_fmt = csis_fmt;\r\nmutex_unlock(&state->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5pcsis_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nif (fmt->pad != CSIS_PAD_SOURCE && fmt->pad != CSIS_PAD_SINK)\r\nreturn -EINVAL;\r\nmf = __s5pcsis_get_format(state, fh, fmt->pad, fmt->which);\r\nif (!mf)\r\nreturn -EINVAL;\r\nmutex_lock(&state->lock);\r\nfmt->format = *mf;\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t s5pcsis_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct csis_state *state = dev_id;\r\nu32 val;\r\nval = s5pcsis_read(state, S5PCSIS_INTSRC);\r\ns5pcsis_write(state, S5PCSIS_INTSRC, val);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit s5pcsis_probe(struct platform_device *pdev)\r\n{\r\nstruct s5p_platform_mipi_csis *pdata;\r\nstruct resource *mem_res;\r\nstruct resource *regs_res;\r\nstruct csis_state *state;\r\nint ret = -ENOMEM;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nmutex_init(&state->lock);\r\nstate->pdev = pdev;\r\npdata = pdev->dev.platform_data;\r\nif (pdata == NULL || pdata->phy_enable == NULL) {\r\ndev_err(&pdev->dev, "Platform data not fully specified\n");\r\ngoto e_free;\r\n}\r\nif ((pdev->id == 1 && pdata->lanes > CSIS1_MAX_LANES) ||\r\npdata->lanes > CSIS0_MAX_LANES) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "Unsupported number of data lanes: %d\n",\r\npdata->lanes);\r\ngoto e_free;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_res) {\r\ndev_err(&pdev->dev, "Failed to get IO memory region\n");\r\ngoto e_free;\r\n}\r\nregs_res = request_mem_region(mem_res->start, resource_size(mem_res),\r\npdev->name);\r\nif (!regs_res) {\r\ndev_err(&pdev->dev, "Failed to request IO memory region\n");\r\ngoto e_free;\r\n}\r\nstate->regs_res = regs_res;\r\nstate->regs = ioremap(mem_res->start, resource_size(mem_res));\r\nif (!state->regs) {\r\ndev_err(&pdev->dev, "Failed to remap IO region\n");\r\ngoto e_reqmem;\r\n}\r\nret = s5pcsis_clk_get(state);\r\nif (ret)\r\ngoto e_unmap;\r\nclk_enable(state->clock[CSIS_CLK_MUX]);\r\nif (pdata->clk_rate)\r\nclk_set_rate(state->clock[CSIS_CLK_MUX], pdata->clk_rate);\r\nelse\r\ndev_WARN(&pdev->dev, "No clock frequency specified!\n");\r\nstate->irq = platform_get_irq(pdev, 0);\r\nif (state->irq < 0) {\r\nret = state->irq;\r\ndev_err(&pdev->dev, "Failed to get irq\n");\r\ngoto e_clkput;\r\n}\r\nif (!pdata->fixed_phy_vdd) {\r\nstate->supply = regulator_get(&pdev->dev, "vdd");\r\nif (IS_ERR(state->supply)) {\r\nret = PTR_ERR(state->supply);\r\nstate->supply = NULL;\r\ngoto e_clkput;\r\n}\r\n}\r\nret = request_irq(state->irq, s5pcsis_irq_handler, 0,\r\ndev_name(&pdev->dev), state);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\ngoto e_regput;\r\n}\r\nv4l2_subdev_init(&state->sd, &s5pcsis_subdev_ops);\r\nstate->sd.owner = THIS_MODULE;\r\nstrlcpy(state->sd.name, dev_name(&pdev->dev), sizeof(state->sd.name));\r\nstate->csis_fmt = &s5pcsis_formats[0];\r\nstate->pads[CSIS_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\nstate->pads[CSIS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&state->sd.entity,\r\nCSIS_PADS_NUM, state->pads, 0);\r\nif (ret < 0)\r\ngoto e_irqfree;\r\nv4l2_set_subdevdata(&state->sd, pdev);\r\nplatform_set_drvdata(pdev, &state->sd);\r\nstate->flags = ST_SUSPENDED;\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\ne_irqfree:\r\nfree_irq(state->irq, state);\r\ne_regput:\r\nif (state->supply)\r\nregulator_put(state->supply);\r\ne_clkput:\r\nclk_disable(state->clock[CSIS_CLK_MUX]);\r\ns5pcsis_clk_put(state);\r\ne_unmap:\r\niounmap(state->regs);\r\ne_reqmem:\r\nrelease_mem_region(regs_res->start, resource_size(regs_res));\r\ne_free:\r\nkfree(state);\r\nreturn ret;\r\n}\r\nstatic int s5pcsis_suspend(struct device *dev)\r\n{\r\nstruct s5p_platform_mipi_csis *pdata = dev->platform_data;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "%s: flags: 0x%x\n",\r\n__func__, state->flags);\r\nmutex_lock(&state->lock);\r\nif (state->flags & ST_POWERED) {\r\ns5pcsis_stop_stream(state);\r\nret = pdata->phy_enable(state->pdev, false);\r\nif (ret)\r\ngoto unlock;\r\nif (state->supply) {\r\nret = regulator_disable(state->supply);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nclk_disable(state->clock[CSIS_CLK_GATE]);\r\nstate->flags &= ~ST_POWERED;\r\n}\r\nstate->flags |= ST_SUSPENDED;\r\nunlock:\r\nmutex_unlock(&state->lock);\r\nreturn ret ? -EAGAIN : 0;\r\n}\r\nstatic int s5pcsis_resume(struct device *dev)\r\n{\r\nstruct s5p_platform_mipi_csis *pdata = dev->platform_data;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "%s: flags: 0x%x\n",\r\n__func__, state->flags);\r\nmutex_lock(&state->lock);\r\nif (!(state->flags & ST_SUSPENDED))\r\ngoto unlock;\r\nif (!(state->flags & ST_POWERED)) {\r\nif (state->supply)\r\nret = regulator_enable(state->supply);\r\nif (ret)\r\ngoto unlock;\r\nret = pdata->phy_enable(state->pdev, true);\r\nif (!ret) {\r\nstate->flags |= ST_POWERED;\r\n} else if (state->supply) {\r\nregulator_disable(state->supply);\r\ngoto unlock;\r\n}\r\nclk_enable(state->clock[CSIS_CLK_GATE]);\r\n}\r\nif (state->flags & ST_STREAMING)\r\ns5pcsis_start_stream(state);\r\nstate->flags &= ~ST_SUSPENDED;\r\nunlock:\r\nmutex_unlock(&state->lock);\r\nreturn ret ? -EAGAIN : 0;\r\n}\r\nstatic int s5pcsis_pm_suspend(struct device *dev)\r\n{\r\nreturn s5pcsis_suspend(dev);\r\n}\r\nstatic int s5pcsis_pm_resume(struct device *dev)\r\n{\r\nint ret;\r\nret = s5pcsis_resume(dev);\r\nif (!ret) {\r\npm_runtime_disable(dev);\r\nret = pm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devexit s5pcsis_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nstruct resource *res = state->regs_res;\r\npm_runtime_disable(&pdev->dev);\r\ns5pcsis_suspend(&pdev->dev);\r\nclk_disable(state->clock[CSIS_CLK_MUX]);\r\npm_runtime_set_suspended(&pdev->dev);\r\ns5pcsis_clk_put(state);\r\nif (state->supply)\r\nregulator_put(state->supply);\r\nmedia_entity_cleanup(&state->sd.entity);\r\nfree_irq(state->irq, state);\r\niounmap(state->regs);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic int __init s5pcsis_init(void)\r\n{\r\nreturn platform_driver_probe(&s5pcsis_driver, s5pcsis_probe);\r\n}\r\nstatic void __exit s5pcsis_exit(void)\r\n{\r\nplatform_driver_unregister(&s5pcsis_driver);\r\n}
