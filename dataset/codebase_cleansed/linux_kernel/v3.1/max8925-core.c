static inline struct max8925_irq_data *irq_to_max8925(struct max8925_chip *chip,\r\nint irq)\r\n{\r\nreturn &max8925_irqs[irq - chip->irq_base];\r\n}\r\nstatic irqreturn_t max8925_irq(int irq, void *data)\r\n{\r\nstruct max8925_chip *chip = data;\r\nstruct max8925_irq_data *irq_data;\r\nstruct i2c_client *i2c;\r\nint read_reg = -1, value = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(max8925_irqs); i++) {\r\nirq_data = &max8925_irqs[i];\r\nif (irq_data->tsc_irq)\r\ncontinue;\r\nif (irq_data->flags == FLAGS_RTC)\r\ni2c = chip->rtc;\r\nelse if (irq_data->flags == FLAGS_ADC)\r\ni2c = chip->adc;\r\nelse\r\ni2c = chip->i2c;\r\nif (read_reg != irq_data->reg) {\r\nread_reg = irq_data->reg;\r\nvalue = max8925_reg_read(i2c, irq_data->reg);\r\n}\r\nif (value & irq_data->enable)\r\nhandle_nested_irq(chip->irq_base + i);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t max8925_tsc_irq(int irq, void *data)\r\n{\r\nstruct max8925_chip *chip = data;\r\nstruct max8925_irq_data *irq_data;\r\nstruct i2c_client *i2c;\r\nint read_reg = -1, value = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(max8925_irqs); i++) {\r\nirq_data = &max8925_irqs[i];\r\nif (!irq_data->tsc_irq)\r\ncontinue;\r\nif (irq_data->flags == FLAGS_RTC)\r\ni2c = chip->rtc;\r\nelse if (irq_data->flags == FLAGS_ADC)\r\ni2c = chip->adc;\r\nelse\r\ni2c = chip->i2c;\r\nif (read_reg != irq_data->reg) {\r\nread_reg = irq_data->reg;\r\nvalue = max8925_reg_read(i2c, irq_data->reg);\r\n}\r\nif (value & irq_data->enable)\r\nhandle_nested_irq(chip->irq_base + i);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void max8925_irq_lock(struct irq_data *data)\r\n{\r\nstruct max8925_chip *chip = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&chip->irq_lock);\r\n}\r\nstatic void max8925_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct max8925_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct max8925_irq_data *irq_data;\r\nstatic unsigned char cache_chg[2] = {0xff, 0xff};\r\nstatic unsigned char cache_on[2] = {0xff, 0xff};\r\nstatic unsigned char cache_rtc = 0xff, cache_tsc = 0xff;\r\nunsigned char irq_chg[2], irq_on[2];\r\nunsigned char irq_rtc, irq_tsc;\r\nint i;\r\nirq_chg[0] = cache_chg[0];\r\nirq_chg[1] = cache_chg[1];\r\nirq_on[0] = cache_on[0];\r\nirq_on[1] = cache_on[1];\r\nirq_rtc = cache_rtc;\r\nirq_tsc = cache_tsc;\r\nfor (i = 0; i < ARRAY_SIZE(max8925_irqs); i++) {\r\nirq_data = &max8925_irqs[i];\r\nswitch (irq_data->mask_reg) {\r\ncase MAX8925_CHG_IRQ1_MASK:\r\nirq_chg[0] &= ~irq_data->enable;\r\nbreak;\r\ncase MAX8925_CHG_IRQ2_MASK:\r\nirq_chg[1] &= ~irq_data->enable;\r\nbreak;\r\ncase MAX8925_ON_OFF_IRQ1_MASK:\r\nirq_on[0] &= ~irq_data->enable;\r\nbreak;\r\ncase MAX8925_ON_OFF_IRQ2_MASK:\r\nirq_on[1] &= ~irq_data->enable;\r\nbreak;\r\ncase MAX8925_RTC_IRQ_MASK:\r\nirq_rtc &= ~irq_data->enable;\r\nbreak;\r\ncase MAX8925_TSC_IRQ_MASK:\r\nirq_tsc &= ~irq_data->enable;\r\nbreak;\r\ndefault:\r\ndev_err(chip->dev, "wrong IRQ\n");\r\nbreak;\r\n}\r\n}\r\nif (cache_chg[0] != irq_chg[0]) {\r\ncache_chg[0] = irq_chg[0];\r\nmax8925_reg_write(chip->i2c, MAX8925_CHG_IRQ1_MASK,\r\nirq_chg[0]);\r\n}\r\nif (cache_chg[1] != irq_chg[1]) {\r\ncache_chg[1] = irq_chg[1];\r\nmax8925_reg_write(chip->i2c, MAX8925_CHG_IRQ2_MASK,\r\nirq_chg[1]);\r\n}\r\nif (cache_on[0] != irq_on[0]) {\r\ncache_on[0] = irq_on[0];\r\nmax8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ1_MASK,\r\nirq_on[0]);\r\n}\r\nif (cache_on[1] != irq_on[1]) {\r\ncache_on[1] = irq_on[1];\r\nmax8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ2_MASK,\r\nirq_on[1]);\r\n}\r\nif (cache_rtc != irq_rtc) {\r\ncache_rtc = irq_rtc;\r\nmax8925_reg_write(chip->rtc, MAX8925_RTC_IRQ_MASK, irq_rtc);\r\n}\r\nif (cache_tsc != irq_tsc) {\r\ncache_tsc = irq_tsc;\r\nmax8925_reg_write(chip->adc, MAX8925_TSC_IRQ_MASK, irq_tsc);\r\n}\r\nmutex_unlock(&chip->irq_lock);\r\n}\r\nstatic void max8925_irq_enable(struct irq_data *data)\r\n{\r\nstruct max8925_chip *chip = irq_data_get_irq_chip_data(data);\r\nmax8925_irqs[data->irq - chip->irq_base].enable\r\n= max8925_irqs[data->irq - chip->irq_base].offs;\r\n}\r\nstatic void max8925_irq_disable(struct irq_data *data)\r\n{\r\nstruct max8925_chip *chip = irq_data_get_irq_chip_data(data);\r\nmax8925_irqs[data->irq - chip->irq_base].enable = 0;\r\n}\r\nstatic int max8925_irq_init(struct max8925_chip *chip, int irq,\r\nstruct max8925_platform_data *pdata)\r\n{\r\nunsigned long flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\r\nint i, ret;\r\nint __irq;\r\nif (!pdata || !pdata->irq_base) {\r\ndev_warn(chip->dev, "No interrupt support on IRQ base\n");\r\nreturn -EINVAL;\r\n}\r\nmax8925_reg_read(chip->i2c, MAX8925_CHG_IRQ1);\r\nmax8925_reg_read(chip->i2c, MAX8925_CHG_IRQ2);\r\nmax8925_reg_read(chip->i2c, MAX8925_ON_OFF_IRQ1);\r\nmax8925_reg_read(chip->i2c, MAX8925_ON_OFF_IRQ2);\r\nmax8925_reg_read(chip->rtc, MAX8925_RTC_IRQ);\r\nmax8925_reg_read(chip->adc, MAX8925_TSC_IRQ);\r\nmax8925_reg_write(chip->rtc, MAX8925_ALARM0_CNTL, 0);\r\nmax8925_reg_write(chip->rtc, MAX8925_ALARM1_CNTL, 0);\r\nmax8925_reg_write(chip->i2c, MAX8925_CHG_IRQ1_MASK, 0xff);\r\nmax8925_reg_write(chip->i2c, MAX8925_CHG_IRQ2_MASK, 0xff);\r\nmax8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ1_MASK, 0xff);\r\nmax8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ2_MASK, 0xff);\r\nmax8925_reg_write(chip->rtc, MAX8925_RTC_IRQ_MASK, 0xff);\r\nmutex_init(&chip->irq_lock);\r\nchip->core_irq = irq;\r\nchip->irq_base = pdata->irq_base;\r\nfor (i = 0; i < ARRAY_SIZE(max8925_irqs); i++) {\r\n__irq = i + chip->irq_base;\r\nirq_set_chip_data(__irq, chip);\r\nirq_set_chip_and_handler(__irq, &max8925_irq_chip,\r\nhandle_edge_irq);\r\nirq_set_nested_thread(__irq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(__irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(__irq);\r\n#endif\r\n}\r\nif (!irq) {\r\ndev_warn(chip->dev, "No interrupt support on core IRQ\n");\r\ngoto tsc_irq;\r\n}\r\nret = request_threaded_irq(irq, NULL, max8925_irq, flags,\r\n"max8925", chip);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to request core IRQ: %d\n", ret);\r\nchip->core_irq = 0;\r\n}\r\ntsc_irq:\r\nmax8925_reg_write(chip->adc, MAX8925_TSC_IRQ_MASK, 0x0f);\r\nif (!pdata->tsc_irq) {\r\ndev_warn(chip->dev, "No interrupt support on TSC IRQ\n");\r\nreturn 0;\r\n}\r\nchip->tsc_irq = pdata->tsc_irq;\r\nret = request_threaded_irq(chip->tsc_irq, NULL, max8925_tsc_irq,\r\nflags, "max8925-tsc", chip);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to request TSC IRQ: %d\n", ret);\r\nchip->tsc_irq = 0;\r\n}\r\nreturn 0;\r\n}\r\nint __devinit max8925_device_init(struct max8925_chip *chip,\r\nstruct max8925_platform_data *pdata)\r\n{\r\nint ret;\r\nmax8925_irq_init(chip, chip->i2c->irq, pdata);\r\nif (pdata && (pdata->power || pdata->touch)) {\r\nmax8925_set_bits(chip->i2c, MAX8925_RESET_CNFG, 1, 1);\r\nmax8925_set_bits(chip->adc, MAX8925_TSC_CNFG1, 3, 2);\r\ndo {\r\nret = max8925_reg_read(chip->adc, MAX8925_TSC_IRQ);\r\n} while (ret & MAX8925_NREF_OK);\r\nmax8925_set_bits(chip->adc, MAX8925_ADC_SCHED, 3, 2);\r\n}\r\nmax8925_set_bits(chip->rtc, MAX8925_MPL_CNTL, 1 << 4, 1 << 4);\r\nret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],\r\nARRAY_SIZE(rtc_devs),\r\n&rtc_resources[0], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add rtc subdev\n");\r\ngoto out;\r\n}\r\nret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],\r\nARRAY_SIZE(onkey_devs),\r\n&onkey_resources[0], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add onkey subdev\n");\r\ngoto out_dev;\r\n}\r\nif (pdata) {\r\nret = mfd_add_devices(chip->dev, 0, &regulator_devs[0],\r\nARRAY_SIZE(regulator_devs),\r\n&regulator_resources[0], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add regulator subdev\n");\r\ngoto out_dev;\r\n}\r\n}\r\nif (pdata && pdata->backlight) {\r\nret = mfd_add_devices(chip->dev, 0, &backlight_devs[0],\r\nARRAY_SIZE(backlight_devs),\r\n&backlight_resources[0], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add backlight subdev\n");\r\ngoto out_dev;\r\n}\r\n}\r\nif (pdata && pdata->power) {\r\nret = mfd_add_devices(chip->dev, 0, &power_devs[0],\r\nARRAY_SIZE(power_devs),\r\n&power_supply_resources[0], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add power supply "\r\n"subdev\n");\r\ngoto out_dev;\r\n}\r\n}\r\nif (pdata && pdata->touch) {\r\nret = mfd_add_devices(chip->dev, 0, &touch_devs[0],\r\nARRAY_SIZE(touch_devs),\r\n&touch_resources[0], 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add touch subdev\n");\r\ngoto out_dev;\r\n}\r\n}\r\nreturn 0;\r\nout_dev:\r\nmfd_remove_devices(chip->dev);\r\nout:\r\nreturn ret;\r\n}\r\nvoid __devexit max8925_device_exit(struct max8925_chip *chip)\r\n{\r\nif (chip->core_irq)\r\nfree_irq(chip->core_irq, chip);\r\nif (chip->tsc_irq)\r\nfree_irq(chip->tsc_irq, chip);\r\nmfd_remove_devices(chip->dev);\r\n}
