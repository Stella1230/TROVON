static void tegra_ehci_power_up(struct usb_hcd *hcd)\r\n{\r\nstruct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);\r\nclk_enable(tegra->emc_clk);\r\nclk_enable(tegra->clk);\r\ntegra_usb_phy_power_on(tegra->phy);\r\ntegra->host_resumed = 1;\r\n}\r\nstatic void tegra_ehci_power_down(struct usb_hcd *hcd)\r\n{\r\nstruct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);\r\ntegra->host_resumed = 0;\r\ntegra_usb_phy_power_off(tegra->phy);\r\nclk_disable(tegra->clk);\r\nclk_disable(tegra->emc_clk);\r\n}\r\nstatic int tegra_ehci_internal_port_reset(\r\nstruct ehci_hcd *ehci,\r\nu32 __iomem *portsc_reg\r\n)\r\n{\r\nu32 temp;\r\nunsigned long flags;\r\nint retval = 0;\r\nint i, tries;\r\nu32 saved_usbintr;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nsaved_usbintr = ehci_readl(ehci, &ehci->regs->intr_enable);\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nfor (i = 0; i < 2; i++) {\r\ntemp = ehci_readl(ehci, portsc_reg);\r\ntemp |= PORT_RESET;\r\nehci_writel(ehci, temp, portsc_reg);\r\nmdelay(10);\r\ntemp &= ~PORT_RESET;\r\nehci_writel(ehci, temp, portsc_reg);\r\nmdelay(1);\r\ntries = 100;\r\ndo {\r\nmdelay(1);\r\ntemp = ehci_readl(ehci, portsc_reg);\r\n} while (!(temp & PORT_PE) && tries--);\r\nif (temp & PORT_PE)\r\nbreak;\r\n}\r\nif (i == 2)\r\nretval = -ETIMEDOUT;\r\nif (temp & PORT_CSC)\r\nehci_writel(ehci, PORT_CSC, portsc_reg);\r\ntemp = ehci_readl(ehci, &ehci->regs->status);\r\nehci_writel(ehci, temp, &ehci->regs->status);\r\nehci_writel(ehci, saved_usbintr, &ehci->regs->intr_enable);\r\nreturn retval;\r\n}\r\nstatic int tegra_ehci_hub_control(\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength\r\n)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);\r\nu32 __iomem *status_reg;\r\nu32 temp;\r\nunsigned long flags;\r\nint retval = 0;\r\nstatus_reg = &ehci->regs->port_status[(wIndex & 0xff) - 1];\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (typeReq == ClearPortFeature && wValue == USB_PORT_FEAT_ENABLE) {\r\ntemp = ehci_readl(ehci, status_reg) & ~PORT_RWC_BITS;\r\nehci_writel(ehci, temp & ~PORT_PE, status_reg);\r\ngoto done;\r\n}\r\nelse if (typeReq == GetPortStatus) {\r\ntemp = ehci_readl(ehci, status_reg);\r\nif (tegra->port_resuming && !(temp & PORT_SUSPEND)) {\r\ntegra->port_resuming = 0;\r\ntegra_usb_phy_postresume(tegra->phy);\r\n}\r\n}\r\nelse if (typeReq == SetPortFeature && wValue == USB_PORT_FEAT_SUSPEND) {\r\ntemp = ehci_readl(ehci, status_reg);\r\nif ((temp & PORT_PE) == 0 || (temp & PORT_RESET) != 0) {\r\nretval = -EPIPE;\r\ngoto done;\r\n}\r\ntemp &= ~PORT_WKCONN_E;\r\ntemp |= PORT_WKDISC_E | PORT_WKOC_E;\r\nehci_writel(ehci, temp | PORT_SUSPEND, status_reg);\r\nif (handshake(ehci, status_reg, PORT_SUSPEND,\r\nPORT_SUSPEND, 5000))\r\npr_err("%s: timeout waiting for SUSPEND\n", __func__);\r\nset_bit((wIndex & 0xff) - 1, &ehci->suspended_ports);\r\ngoto done;\r\n}\r\nif (tegra->phy->instance == 0 &&\r\n(typeReq == SetPortFeature && wValue == USB_PORT_FEAT_RESET)) {\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn tegra_ehci_internal_port_reset(ehci, status_reg);\r\n}\r\nelse if (typeReq == ClearPortFeature &&\r\nwValue == USB_PORT_FEAT_SUSPEND) {\r\ntemp = ehci_readl(ehci, status_reg);\r\nif ((temp & PORT_RESET) || !(temp & PORT_PE)) {\r\nretval = -EPIPE;\r\ngoto done;\r\n}\r\nif (!(temp & PORT_SUSPEND))\r\ngoto done;\r\ntegra_usb_phy_preresume(tegra->phy);\r\nehci->reset_done[wIndex-1] = jiffies + msecs_to_jiffies(25);\r\ntemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\r\nehci_writel(ehci, temp | PORT_RESUME, status_reg);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nmsleep(20);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (handshake(ehci, status_reg, PORT_RESUME, 0, 2000))\r\npr_err("%s: timeout waiting for RESUME\n", __func__);\r\nif (handshake(ehci, status_reg, PORT_SUSPEND, 0, 2000))\r\npr_err("%s: timeout waiting for SUSPEND\n", __func__);\r\nehci->reset_done[wIndex-1] = 0;\r\ntegra->port_resuming = 1;\r\ngoto done;\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn ehci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);\r\ndone:\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void tegra_ehci_restart(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nehci_reset(ehci);\r\nehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);\r\nehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);\r\nehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);\r\nehci->command |= CMD_RUN;\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\ndown_write(&ehci_cf_port_reset_rwsem);\r\nehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);\r\nehci_readl(ehci, &ehci->regs->command);\r\nup_write(&ehci_cf_port_reset_rwsem);\r\n}\r\nstatic int tegra_usb_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);\r\nstruct ehci_regs __iomem *hw = tegra->ehci->regs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tegra->ehci->lock, flags);\r\ntegra->port_speed = (readl(&hw->port_status[0]) >> 26) & 0x3;\r\nehci_halt(tegra->ehci);\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nspin_unlock_irqrestore(&tegra->ehci->lock, flags);\r\ntegra_ehci_power_down(hcd);\r\nreturn 0;\r\n}\r\nstatic int tegra_usb_resume(struct usb_hcd *hcd)\r\n{\r\nstruct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct ehci_regs __iomem *hw = ehci->regs;\r\nunsigned long val;\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\ntegra_ehci_power_up(hcd);\r\nif (tegra->port_speed > TEGRA_USB_PHY_PORT_SPEED_HIGH) {\r\nmsleep(10);\r\ngoto restart;\r\n}\r\ntegra_ehci_phy_restore_start(tegra->phy, tegra->port_speed);\r\ntdi_reset(ehci);\r\nval = readl(&hw->port_status[0]);\r\nval |= PORT_POWER;\r\nwritel(val, &hw->port_status[0]);\r\nudelay(10);\r\nif (!readl(&hw->async_next)) {\r\nval = readl(&hw->port_status[0]);\r\nval &= ~PORT_TEST(~0);\r\nif (tegra->port_speed == TEGRA_USB_PHY_PORT_SPEED_HIGH)\r\nval |= PORT_TEST_FORCE;\r\nelse if (tegra->port_speed == TEGRA_USB_PHY_PORT_SPEED_FULL)\r\nval |= PORT_TEST(6);\r\nelse if (tegra->port_speed == TEGRA_USB_PHY_PORT_SPEED_LOW)\r\nval |= PORT_TEST(7);\r\nwritel(val, &hw->port_status[0]);\r\nudelay(10);\r\nval = readl(&hw->port_status[0]);\r\nval &= ~PORT_TEST(~0);\r\nwritel(val, &hw->port_status[0]);\r\nudelay(10);\r\n}\r\nif (handshake(ehci, &hw->port_status[0], PORT_CONNECT,\r\nPORT_CONNECT, 2000)) {\r\npr_err("%s: timeout waiting for PORT_CONNECT\n", __func__);\r\ngoto restart;\r\n}\r\nif (handshake(ehci, &hw->port_status[0], PORT_PE,\r\nPORT_PE, 2000)) {\r\npr_err("%s: timeout waiting for USB_PORTSC1_PE\n", __func__);\r\ngoto restart;\r\n}\r\nval = readl(&hw->status);\r\nval |= STS_PCD;\r\nwritel(val, &hw->status);\r\nval = readl(&hw->port_status[0]);\r\nif ((val & PORT_POWER) && (val & PORT_PE)) {\r\nval |= PORT_SUSPEND;\r\nwritel(val, &hw->port_status[0]);\r\nif (handshake(ehci, &hw->port_status[0], PORT_SUSPEND,\r\nPORT_SUSPEND, 1000)) {\r\npr_err("%s: timeout waiting for PORT_SUSPEND\n",\r\n__func__);\r\ngoto restart;\r\n}\r\n}\r\ntegra_ehci_phy_restore_end(tegra->phy);\r\nreturn 0;\r\nrestart:\r\nif (tegra->port_speed <= TEGRA_USB_PHY_PORT_SPEED_HIGH)\r\ntegra_ehci_phy_restore_end(tegra->phy);\r\ntegra_ehci_restart(hcd);\r\nreturn 0;\r\n}\r\nstatic void tegra_ehci_shutdown(struct usb_hcd *hcd)\r\n{\r\nstruct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);\r\nif (!tegra->host_resumed)\r\ntegra_ehci_power_up(hcd);\r\nehci_shutdown(hcd);\r\n}\r\nstatic int tegra_ehci_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint retval;\r\nehci->caps = hcd->regs + 0x100;\r\nehci->regs = hcd->regs + 0x100 +\r\nHC_LENGTH(ehci, readl(&ehci->caps->hc_capbase));\r\ndbg_hcs_params(ehci, "reset");\r\ndbg_hcc_params(ehci, "reset");\r\nehci->hcs_params = readl(&ehci->caps->hcs_params);\r\nhcd->has_tt = 1;\r\nehci_reset(ehci);\r\nretval = ehci_halt(ehci);\r\nif (retval)\r\nreturn retval;\r\nretval = ehci_init(hcd);\r\nif (retval)\r\nreturn retval;\r\nehci->sbrn = 0x20;\r\nehci_port_power(ehci, 1);\r\nreturn retval;\r\n}\r\nstatic int tegra_ehci_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);\r\nint error_status = 0;\r\nerror_status = ehci_bus_suspend(hcd);\r\nif (!error_status && tegra->power_down_on_bus_suspend) {\r\ntegra_usb_suspend(hcd);\r\ntegra->bus_suspended = 1;\r\n}\r\nreturn error_status;\r\n}\r\nstatic int tegra_ehci_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd->self.controller);\r\nif (tegra->bus_suspended && tegra->power_down_on_bus_suspend) {\r\ntegra_usb_resume(hcd);\r\ntegra->bus_suspended = 0;\r\n}\r\ntegra_usb_phy_preresume(tegra->phy);\r\ntegra->port_resuming = 1;\r\nreturn ehci_bus_resume(hcd);\r\n}\r\nstatic void free_temp_buffer(struct urb *urb)\r\n{\r\nenum dma_data_direction dir;\r\nstruct temp_buffer *temp;\r\nif (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))\r\nreturn;\r\ndir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\ntemp = container_of(urb->transfer_buffer, struct temp_buffer,\r\ndata);\r\nif (dir == DMA_FROM_DEVICE)\r\nmemcpy(temp->old_xfer_buffer, temp->data,\r\nurb->transfer_buffer_length);\r\nurb->transfer_buffer = temp->old_xfer_buffer;\r\nkfree(temp->kmalloc_ptr);\r\nurb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;\r\n}\r\nstatic int alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)\r\n{\r\nenum dma_data_direction dir;\r\nstruct temp_buffer *temp, *kmalloc_ptr;\r\nsize_t kmalloc_size;\r\nif (urb->num_sgs || urb->sg ||\r\nurb->transfer_buffer_length == 0 ||\r\n!((uintptr_t)urb->transfer_buffer & (TEGRA_USB_DMA_ALIGN - 1)))\r\nreturn 0;\r\ndir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nkmalloc_size = urb->transfer_buffer_length +\r\nsizeof(struct temp_buffer) + TEGRA_USB_DMA_ALIGN - 1;\r\nkmalloc_ptr = kmalloc(kmalloc_size, mem_flags);\r\nif (!kmalloc_ptr)\r\nreturn -ENOMEM;\r\ntemp = PTR_ALIGN(kmalloc_ptr + 1, TEGRA_USB_DMA_ALIGN) - 1;\r\ntemp->kmalloc_ptr = kmalloc_ptr;\r\ntemp->old_xfer_buffer = urb->transfer_buffer;\r\nif (dir == DMA_TO_DEVICE)\r\nmemcpy(temp->data, urb->transfer_buffer,\r\nurb->transfer_buffer_length);\r\nurb->transfer_buffer = temp->data;\r\nurb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;\r\nreturn 0;\r\n}\r\nstatic int tegra_ehci_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint ret;\r\nret = alloc_temp_buffer(urb, mem_flags);\r\nif (ret)\r\nreturn ret;\r\nret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\r\nif (ret)\r\nfree_temp_buffer(urb);\r\nreturn ret;\r\n}\r\nstatic void tegra_ehci_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nusb_hcd_unmap_urb_for_dma(hcd, urb);\r\nfree_temp_buffer(urb);\r\n}\r\nstatic int tegra_ehci_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct usb_hcd *hcd;\r\nstruct tegra_ehci_hcd *tegra;\r\nstruct tegra_ehci_platform_data *pdata;\r\nint err = 0;\r\nint irq;\r\nint instance = pdev->id;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Platform data missing\n");\r\nreturn -EINVAL;\r\n}\r\ntegra = kzalloc(sizeof(struct tegra_ehci_hcd), GFP_KERNEL);\r\nif (!tegra)\r\nreturn -ENOMEM;\r\nhcd = usb_create_hcd(&tegra_ehci_hc_driver, &pdev->dev,\r\ndev_name(&pdev->dev));\r\nif (!hcd) {\r\ndev_err(&pdev->dev, "Unable to create HCD\n");\r\nerr = -ENOMEM;\r\ngoto fail_hcd;\r\n}\r\nplatform_set_drvdata(pdev, tegra);\r\ntegra->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(tegra->clk)) {\r\ndev_err(&pdev->dev, "Can't get ehci clock\n");\r\nerr = PTR_ERR(tegra->clk);\r\ngoto fail_clk;\r\n}\r\nerr = clk_enable(tegra->clk);\r\nif (err)\r\ngoto fail_clken;\r\ntegra->emc_clk = clk_get(&pdev->dev, "emc");\r\nif (IS_ERR(tegra->emc_clk)) {\r\ndev_err(&pdev->dev, "Can't get emc clock\n");\r\nerr = PTR_ERR(tegra->emc_clk);\r\ngoto fail_emc_clk;\r\n}\r\nclk_enable(tegra->emc_clk);\r\nclk_set_rate(tegra->emc_clk, 400000000);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Failed to get I/O memory\n");\r\nerr = -ENXIO;\r\ngoto fail_io;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nhcd->regs = ioremap(res->start, resource_size(res));\r\nif (!hcd->regs) {\r\ndev_err(&pdev->dev, "Failed to remap I/O memory\n");\r\nerr = -ENOMEM;\r\ngoto fail_io;\r\n}\r\ntegra->phy = tegra_usb_phy_open(instance, hcd->regs, pdata->phy_config,\r\nTEGRA_USB_PHY_MODE_HOST);\r\nif (IS_ERR(tegra->phy)) {\r\ndev_err(&pdev->dev, "Failed to open USB phy\n");\r\nerr = -ENXIO;\r\ngoto fail_phy;\r\n}\r\nerr = tegra_usb_phy_power_on(tegra->phy);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to power on the phy\n");\r\ngoto fail;\r\n}\r\ntegra->host_resumed = 1;\r\ntegra->power_down_on_bus_suspend = pdata->power_down_on_bus_suspend;\r\ntegra->ehci = hcd_to_ehci(hcd);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "Failed to get IRQ\n");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nset_irq_flags(irq, IRQF_VALID);\r\n#ifdef CONFIG_USB_OTG_UTILS\r\nif (pdata->operating_mode == TEGRA_USB_OTG) {\r\ntegra->transceiver = otg_get_transceiver();\r\nif (tegra->transceiver)\r\notg_set_host(tegra->transceiver, &hcd->self);\r\n}\r\n#endif\r\nerr = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to add USB HCD\n");\r\ngoto fail;\r\n}\r\nreturn err;\r\nfail:\r\n#ifdef CONFIG_USB_OTG_UTILS\r\nif (tegra->transceiver) {\r\notg_set_host(tegra->transceiver, NULL);\r\notg_put_transceiver(tegra->transceiver);\r\n}\r\n#endif\r\ntegra_usb_phy_close(tegra->phy);\r\nfail_phy:\r\niounmap(hcd->regs);\r\nfail_io:\r\nclk_disable(tegra->emc_clk);\r\nclk_put(tegra->emc_clk);\r\nfail_emc_clk:\r\nclk_disable(tegra->clk);\r\nfail_clken:\r\nclk_put(tegra->clk);\r\nfail_clk:\r\nusb_put_hcd(hcd);\r\nfail_hcd:\r\nkfree(tegra);\r\nreturn err;\r\n}\r\nstatic int tegra_ehci_resume(struct platform_device *pdev)\r\n{\r\nstruct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = ehci_to_hcd(tegra->ehci);\r\nif (tegra->bus_suspended)\r\nreturn 0;\r\nreturn tegra_usb_resume(hcd);\r\n}\r\nstatic int tegra_ehci_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = ehci_to_hcd(tegra->ehci);\r\nif (tegra->bus_suspended)\r\nreturn 0;\r\nif (time_before(jiffies, tegra->ehci->next_statechange))\r\nmsleep(10);\r\nreturn tegra_usb_suspend(hcd);\r\n}\r\nstatic int tegra_ehci_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = ehci_to_hcd(tegra->ehci);\r\nif (tegra == NULL || hcd == NULL)\r\nreturn -EINVAL;\r\n#ifdef CONFIG_USB_OTG_UTILS\r\nif (tegra->transceiver) {\r\notg_set_host(tegra->transceiver, NULL);\r\notg_put_transceiver(tegra->transceiver);\r\n}\r\n#endif\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\ntegra_usb_phy_close(tegra->phy);\r\niounmap(hcd->regs);\r\nclk_disable(tegra->clk);\r\nclk_put(tegra->clk);\r\nclk_disable(tegra->emc_clk);\r\nclk_put(tegra->emc_clk);\r\nkfree(tegra);\r\nreturn 0;\r\n}\r\nstatic void tegra_ehci_hcd_shutdown(struct platform_device *pdev)\r\n{\r\nstruct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = ehci_to_hcd(tegra->ehci);\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}
