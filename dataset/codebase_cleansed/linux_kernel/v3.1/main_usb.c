static void\r\ndevice_set_options(PSDevice pDevice) {\r\nBYTE abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nBYTE abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};\r\nu8 abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};\r\nmemcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);\r\npDevice->cbTD = TX_DESC_DEF0;\r\npDevice->cbRD = RX_DESC_DEF0;\r\npDevice->uChannel = CHANNEL_DEF;\r\npDevice->wRTSThreshold = RTS_THRESH_DEF;\r\npDevice->wFragmentationThreshold = FRAG_THRESH_DEF;\r\npDevice->byShortRetryLimit = SHORT_RETRY_DEF;\r\npDevice->byLongRetryLimit = LONG_RETRY_DEF;\r\npDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;\r\npDevice->byShortPreamble = PREAMBLE_TYPE_DEF;\r\npDevice->ePSMode = PS_MODE_DEF;\r\npDevice->b11hEnable = X80211h_MODE_DEF;\r\npDevice->eOPMode = OP_MODE_DEF;\r\npDevice->uConnectionRate = DATA_RATE_DEF;\r\nif (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = TRUE;\r\npDevice->byBBType = BBP_TYPE_DEF;\r\npDevice->byPacketType = pDevice->byBBType;\r\npDevice->byAutoFBCtrl = AUTO_FB_0;\r\npDevice->bUpdateBBVGA = TRUE;\r\npDevice->byFOETuning = 0;\r\npDevice->byAutoPwrTunning = 0;\r\npDevice->wCTSDuration = 0;\r\npDevice->byPreambleType = 0;\r\npDevice->bExistSWNetAddr = FALSE;\r\npDevice->bDiversityRegCtlON = FALSE;\r\n}\r\nstatic void device_init_diversity_timer(PSDevice pDevice)\r\n{\r\ninit_timer(&pDevice->TimerSQ3Tmax1);\r\npDevice->TimerSQ3Tmax1.data = (unsigned long)pDevice;\r\npDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;\r\npDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);\r\ninit_timer(&pDevice->TimerSQ3Tmax2);\r\npDevice->TimerSQ3Tmax2.data = (unsigned long)pDevice;\r\npDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;\r\npDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);\r\ninit_timer(&pDevice->TimerSQ3Tmax3);\r\npDevice->TimerSQ3Tmax3.data = (unsigned long)pDevice;\r\npDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerSQ3Tmax3CallBack;\r\npDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);\r\nreturn;\r\n}\r\nstatic BOOL device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)\r\n{\r\nu8 abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};\r\nu8 abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};\r\nBYTE byAntenna;\r\nunsigned int ii;\r\nCMD_CARD_INIT sInitCmd;\r\nint ntStatus = STATUS_SUCCESS;\r\nRSP_CARD_INIT sInitRsp;\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nBYTE byTmp;\r\nBYTE byCalibTXIQ = 0;\r\nBYTE byCalibTXDC = 0;\r\nBYTE byCalibRXIQ = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---->INIbInitAdapter. [%d][%d]\n", InitType, pDevice->byPacketType);\r\nspin_lock_irq(&pDevice->lock);\r\nif (InitType == DEVICE_INIT_COLD) {\r\nmemcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_Bridgetunnel,\r\nabySNAP_Bridgetunnel,\r\nETH_ALEN);\r\nif ( !FIRMWAREbCheckVersion(pDevice) ) {\r\nif (FIRMWAREbDownload(pDevice) == TRUE) {\r\nif (FIRMWAREbBrach2Sram(pDevice) == FALSE) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" FIRMWAREbBrach2Sram fail \n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn FALSE;\r\n}\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" FIRMWAREbDownload fail \n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn FALSE;\r\n}\r\n}\r\nif ( !BBbVT3184Init(pDevice) ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" BBbVT3184Init fail \n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn FALSE;\r\n}\r\n}\r\nsInitCmd.byInitClass = (BYTE)InitType;\r\nsInitCmd.bExistSWNetAddr = (BYTE) pDevice->bExistSWNetAddr;\r\nfor (ii = 0; ii < 6; ii++)\r\nsInitCmd.bySWNetAddr[ii] = pDevice->abyCurrentNetAddr[ii];\r\nsInitCmd.byShortRetryLimit = pDevice->byShortRetryLimit;\r\nsInitCmd.byLongRetryLimit = pDevice->byLongRetryLimit;\r\nntStatus = CONTROLnsRequestOut(pDevice,\r\nMESSAGE_TYPE_CARDINIT,\r\n0,\r\n0,\r\nsizeof(CMD_CARD_INIT),\r\n(PBYTE) &(sInitCmd));\r\nif ( ntStatus != STATUS_SUCCESS ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Issue Card init fail \n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn FALSE;\r\n}\r\nif (InitType == DEVICE_INIT_COLD) {\r\nntStatus = CONTROLnsRequestIn(pDevice,MESSAGE_TYPE_INIT_RSP,0,0,sizeof(RSP_CARD_INIT), (PBYTE) &(sInitRsp));\r\nif (ntStatus != STATUS_SUCCESS) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Cardinit request in status fail!\n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn FALSE;\r\n}\r\nntStatus = CONTROLnsRequestIn(pDevice,\r\nMESSAGE_TYPE_READ,\r\nMAC_REG_LOCALID,\r\nMESSAGE_REQUEST_MACREG,\r\n1,\r\n&pDevice->byLocalID);\r\nif ( ntStatus != STATUS_SUCCESS ) {\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn FALSE;\r\n}\r\npDevice->bCCK = TRUE;\r\npDevice->bProtectMode = FALSE;\r\npDevice->bNonERPPresent = FALSE;\r\npDevice->bBarkerPreambleMd = FALSE;\r\nif ( pDevice->bFixRate ) {\r\npDevice->wCurrentRate = (WORD) pDevice->uConnectionRate;\r\n} else {\r\nif ( pDevice->byBBType == BB_TYPE_11B )\r\npDevice->wCurrentRate = RATE_11M;\r\nelse\r\npDevice->wCurrentRate = RATE_54M;\r\n}\r\nCHvInitChannelTable(pDevice);\r\npDevice->byTopOFDMBasicRate = RATE_24M;\r\npDevice->byTopCCKBasicRate = RATE_1M;\r\npDevice->byRevId = 0;\r\npDevice->byCurPwr = 0xFF;\r\npDevice->byCCKPwr = pDevice->abyEEPROM[EEP_OFS_PWR_CCK];\r\npDevice->byOFDMPwrG = pDevice->abyEEPROM[EEP_OFS_PWR_OFDMG];\r\nfor (ii=0;ii<14;ii++) {\r\npDevice->abyCCKPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_CCK_PWR_TBL];\r\nif (pDevice->abyCCKPwrTbl[ii] == 0)\r\npDevice->abyCCKPwrTbl[ii] = pDevice->byCCKPwr;\r\npDevice->abyOFDMPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_OFDM_PWR_TBL];\r\nif (pDevice->abyOFDMPwrTbl[ii] == 0)\r\npDevice->abyOFDMPwrTbl[ii] = pDevice->byOFDMPwrG;\r\n}\r\nif(((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||\r\n(pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe))&&\r\n(pDevice->byOriginalZonetype == ZoneType_USA)) {\r\nfor (ii = 11; ii < 14; ii++) {\r\npDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];\r\npDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];\r\n}\r\n}\r\npDevice->byOFDMPwrA = 0x34;\r\nfor (ii=0;ii<CB_MAX_CHANNEL_5G;ii++) {\r\npDevice->abyOFDMAPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_OFDMA_PWR_TBL];\r\nif (pDevice->abyOFDMAPwrTbl[ii] == 0)\r\npDevice->abyOFDMAPwrTbl[ii] = pDevice->byOFDMPwrA;\r\n}\r\nbyAntenna = pDevice->abyEEPROM[EEP_OFS_ANTENNA];\r\nif (byAntenna & EEP_ANTINV)\r\npDevice->bTxRxAntInv = TRUE;\r\nelse\r\npDevice->bTxRxAntInv = FALSE;\r\nbyAntenna &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (byAntenna == 0)\r\nbyAntenna = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (byAntenna == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {\r\npDevice->byAntennaCount = 2;\r\npDevice->byTxAntennaMode = ANT_B;\r\npDevice->dwTxAntennaSel = 1;\r\npDevice->dwRxAntennaSel = 1;\r\nif (pDevice->bTxRxAntInv == TRUE)\r\npDevice->byRxAntennaMode = ANT_A;\r\nelse\r\npDevice->byRxAntennaMode = ANT_B;\r\nif (pDevice->bDiversityRegCtlON)\r\npDevice->bDiversityEnable = TRUE;\r\nelse\r\npDevice->bDiversityEnable = FALSE;\r\n} else {\r\npDevice->bDiversityEnable = FALSE;\r\npDevice->byAntennaCount = 1;\r\npDevice->dwTxAntennaSel = 0;\r\npDevice->dwRxAntennaSel = 0;\r\nif (byAntenna & EEP_ANTENNA_AUX) {\r\npDevice->byTxAntennaMode = ANT_A;\r\nif (pDevice->bTxRxAntInv == TRUE)\r\npDevice->byRxAntennaMode = ANT_B;\r\nelse\r\npDevice->byRxAntennaMode = ANT_A;\r\n} else {\r\npDevice->byTxAntennaMode = ANT_B;\r\nif (pDevice->bTxRxAntInv == TRUE)\r\npDevice->byRxAntennaMode = ANT_A;\r\nelse\r\npDevice->byRxAntennaMode = ANT_B;\r\n}\r\n}\r\npDevice->ulDiversityNValue = 100*255;\r\npDevice->ulDiversityMValue = 100*16;\r\npDevice->byTMax = 1;\r\npDevice->byTMax2 = 4;\r\npDevice->ulSQ3TH = 0;\r\npDevice->byTMax3 = 64;\r\npDevice->byAutoFBCtrl = AUTO_FB_0;\r\npDevice->uScanTime = WLAN_SCAN_MINITIME;\r\npDevice->eConfigPHYMode = PHY_TYPE_AUTO;\r\npDevice->byBBType = BB_TYPE_11G;\r\npDevice->ulTxPower = 25;\r\npDevice->byMinChannel = 1;\r\npDevice->byMaxChannel = CB_MAX_CHANNEL;\r\npDevice->byRFType = sInitRsp.byRFType;\r\nif ((pDevice->byRFType & RF_EMU) != 0) {\r\npDevice->byRevId = 0x80;\r\n}\r\nif (pDevice->byRFType == RF_VT3226D0) {\r\nif((pDevice->abyEEPROM[EEP_OFS_MAJOR_VER] == 0x1) &&\r\n(pDevice->abyEEPROM[EEP_OFS_MINOR_VER] >= 0x4)) {\r\nbyCalibTXIQ = pDevice->abyEEPROM[EEP_OFS_CALIB_TX_IQ];\r\nbyCalibTXDC = pDevice->abyEEPROM[EEP_OFS_CALIB_TX_DC];\r\nbyCalibRXIQ = pDevice->abyEEPROM[EEP_OFS_CALIB_RX_IQ];\r\nif( (byCalibTXIQ || byCalibTXDC || byCalibRXIQ) ) {\r\nControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFF, 0x03);\r\nControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFB, byCalibTXIQ);\r\nControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFC, byCalibTXDC);\r\nControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFD, byCalibRXIQ);\r\n} else {\r\nControlvWriteByte(pDevice, MESSAGE_REQUEST_BBREG, 0xFF, 0x0);\r\n}\r\n}\r\n}\r\npMgmt->eScanType = WMAC_SCAN_PASSIVE;\r\npMgmt->uCurrChannel = pDevice->uChannel;\r\npMgmt->uIBSSChannel = pDevice->uChannel;\r\nCARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);\r\nmemcpy(pDevice->abyPermanentNetAddr,&(sInitRsp.byNetAddr[0]),6);\r\nmemcpy(pDevice->abyCurrentNetAddr,\r\npDevice->abyPermanentNetAddr,\r\nETH_ALEN);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %02x-%02x-%02x=%02x-%02x-%02x\n",\r\npDevice->abyCurrentNetAddr[0],\r\npDevice->abyCurrentNetAddr[1],\r\npDevice->abyCurrentNetAddr[2],\r\npDevice->abyCurrentNetAddr[3],\r\npDevice->abyCurrentNetAddr[4],\r\npDevice->abyCurrentNetAddr[5]);\r\n}\r\nif (pDevice->byBBType == BB_TYPE_11A) {\r\nCARDbAddBasicRate(pDevice, RATE_6M);\r\npDevice->bShortSlotTime = TRUE;\r\n} else {\r\nCARDbAddBasicRate(pDevice, RATE_1M);\r\npDevice->bShortSlotTime = FALSE;\r\n}\r\nBBvSetShortSlotTime(pDevice);\r\nCARDvSetBSSMode(pDevice);\r\nif (pDevice->bUpdateBBVGA) {\r\npDevice->byBBVGACurrent = pDevice->abyBBVGA[0];\r\npDevice->byBBVGANew = pDevice->byBBVGACurrent;\r\nBBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);\r\n}\r\npDevice->byRadioCtl = pDevice->abyEEPROM[EEP_OFS_RADIOCTL];\r\npDevice->bHWRadioOff = FALSE;\r\nif ( (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) != 0 ) {\r\nntStatus = CONTROLnsRequestIn(pDevice,\r\nMESSAGE_TYPE_READ,\r\nMAC_REG_GPIOCTL1,\r\nMESSAGE_REQUEST_MACREG,\r\n1,\r\n&byTmp);\r\nif ( ntStatus != STATUS_SUCCESS ) {\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn FALSE;\r\n}\r\nif ( (byTmp & GPIO3_DATA) == 0 ) {\r\npDevice->bHWRadioOff = TRUE;\r\nMACvRegBitsOn(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);\r\n} else {\r\nMACvRegBitsOff(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);\r\npDevice->bHWRadioOff = FALSE;\r\n}\r\n}\r\nControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_TMLEN,0x38);\r\nControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);\r\nMACvRegBitsOn(pDevice,MAC_REG_GPIOCTL0,0x01);\r\nif ((pDevice->bHWRadioOff == TRUE) || (pDevice->bRadioControlOff == TRUE)) {\r\nCARDbRadioPowerOff(pDevice);\r\n} else {\r\nCARDbRadioPowerOn(pDevice);\r\n}\r\nspin_unlock_irq(&pDevice->lock);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"<----INIbInitAdapter Exit\n");\r\nreturn TRUE;\r\n}\r\nstatic BOOL device_release_WPADEV(PSDevice pDevice)\r\n{\r\nviawget_wpa_header *wpahdr;\r\nint ii=0;\r\nif (pDevice->bWPADEVUp==TRUE) {\r\nwpahdr = (viawget_wpa_header *)pDevice->skb->data;\r\nwpahdr->type = VIAWGET_DEVICECLOSE_MSG;\r\nwpahdr->resp_ie_len = 0;\r\nwpahdr->req_ie_len = 0;\r\nskb_put(pDevice->skb, sizeof(viawget_wpa_header));\r\npDevice->skb->dev = pDevice->wpadev;\r\nskb_reset_mac_header(pDevice->skb);\r\npDevice->skb->pkt_type = PACKET_HOST;\r\npDevice->skb->protocol = htons(ETH_P_802_2);\r\nmemset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));\r\nnetif_rx(pDevice->skb);\r\npDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nwhile(pDevice->bWPADEVUp==TRUE) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout (HZ/20);\r\nii++;\r\nif(ii>20)\r\nbreak;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int vt6656_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nPSDevice device = usb_get_intfdata(intf);\r\nif (!device || !device->dev)\r\nreturn -ENODEV;\r\nif (device->flags & DEVICE_FLAGS_OPENED)\r\ndevice_close(device->dev);\r\nusb_put_dev(interface_to_usbdev(intf));\r\nreturn 0;\r\n}\r\nstatic int vt6656_resume(struct usb_interface *intf)\r\n{\r\nPSDevice device = usb_get_intfdata(intf);\r\nif (!device || !device->dev)\r\nreturn -ENODEV;\r\nusb_get_dev(interface_to_usbdev(intf));\r\nif (!(device->flags & DEVICE_FLAGS_OPENED))\r\ndevice_open(device->dev);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nvt6656_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nu8 fake_mac[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nint rc = 0;\r\nstruct net_device *netdev = NULL;\r\nPSDevice pDevice = NULL;\r\nprintk(KERN_NOTICE "%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);\r\nprintk(KERN_NOTICE "Copyright (c) 2004 VIA Networking Technologies, Inc.\n");\r\nudev = usb_get_dev(udev);\r\nnetdev = alloc_etherdev(sizeof(DEVICE_INFO));\r\nif (!netdev) {\r\nprintk(KERN_ERR DEVICE_NAME ": allocate net device failed\n");\r\nrc = -ENOMEM;\r\ngoto err_nomem;\r\n}\r\npDevice = netdev_priv(netdev);\r\nmemset(pDevice, 0, sizeof(DEVICE_INFO));\r\npDevice->dev = netdev;\r\npDevice->usb = udev;\r\ndevice_set_options(pDevice);\r\nspin_lock_init(&pDevice->lock);\r\npDevice->tx_80211 = device_dma0_tx_80211;\r\npDevice->sMgmtObj.pAdapter = (void *) pDevice;\r\nnetdev->netdev_ops = &device_netdev_ops;\r\nnetdev->wireless_handlers =\r\n(struct iw_handler_def *) &iwctl_handler_def;\r\nusb_set_intfdata(intf, pDevice);\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nmemcpy(pDevice->dev->dev_addr, fake_mac, ETH_ALEN);\r\nrc = register_netdev(netdev);\r\nif (rc) {\r\nprintk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");\r\ngoto err_netdev;\r\n}\r\nusb_device_reset(pDevice);\r\n{\r\nunion iwreq_data wrqu;\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.flags = RT_INSMOD_EVENT_FLAG;\r\nwrqu.data.length = IFNAMSIZ;\r\nwireless_send_event(pDevice->dev,\r\nIWEVCUSTOM,\r\n&wrqu,\r\npDevice->dev->name);\r\n}\r\nreturn 0;\r\nerr_netdev:\r\nfree_netdev(netdev);\r\nerr_nomem:\r\nusb_put_dev(udev);\r\nreturn rc;\r\n}\r\nstatic void device_free_tx_bufs(PSDevice pDevice)\r\n{\r\nPUSB_SEND_CONTEXT pTxContext;\r\nint ii;\r\nfor (ii = 0; ii < pDevice->cbTD; ii++) {\r\npTxContext = pDevice->apTD[ii];\r\nif (pTxContext->pUrb) {\r\nusb_kill_urb(pTxContext->pUrb);\r\nusb_free_urb(pTxContext->pUrb);\r\n}\r\nkfree(pTxContext);\r\n}\r\nreturn;\r\n}\r\nstatic void device_free_rx_bufs(PSDevice pDevice)\r\n{\r\nPRCB pRCB;\r\nint ii;\r\nfor (ii = 0; ii < pDevice->cbRD; ii++) {\r\npRCB = pDevice->apRCB[ii];\r\nif (pRCB->pUrb) {\r\nusb_kill_urb(pRCB->pUrb);\r\nusb_free_urb(pRCB->pUrb);\r\n}\r\nif (pRCB->skb)\r\ndev_kfree_skb(pRCB->skb);\r\n}\r\nkfree(pDevice->pRCBMem);\r\nreturn;\r\n}\r\nstatic void usb_device_reset(PSDevice pDevice)\r\n{\r\nint status;\r\nstatus = usb_reset_device(pDevice->usb);\r\nif (status)\r\nprintk("usb_device_reset fail status=%d\n",status);\r\nreturn ;\r\n}\r\nstatic void device_free_int_bufs(PSDevice pDevice)\r\n{\r\nkfree(pDevice->intBuf.pDataBuf);\r\nreturn;\r\n}\r\nstatic BOOL device_alloc_bufs(PSDevice pDevice) {\r\nPUSB_SEND_CONTEXT pTxContext;\r\nPRCB pRCB;\r\nint ii;\r\nfor (ii = 0; ii < pDevice->cbTD; ii++) {\r\npTxContext = kmalloc(sizeof(USB_SEND_CONTEXT), GFP_KERNEL);\r\nif (pTxContext == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate tx usb context failed\n", pDevice->dev->name);\r\ngoto free_tx;\r\n}\r\npDevice->apTD[ii] = pTxContext;\r\npTxContext->pDevice = (void *) pDevice;\r\npTxContext->pUrb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (pTxContext->pUrb == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "alloc tx urb failed\n");\r\ngoto free_tx;\r\n}\r\npTxContext->bBoolInUse = FALSE;\r\n}\r\npDevice->pRCBMem = kmalloc((sizeof(RCB) * pDevice->cbRD), GFP_KERNEL);\r\nif (pDevice->pRCBMem == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : alloc rx usb context failed\n", pDevice->dev->name);\r\ngoto free_tx;\r\n}\r\npDevice->FirstRecvFreeList = NULL;\r\npDevice->LastRecvFreeList = NULL;\r\npDevice->FirstRecvMngList = NULL;\r\npDevice->LastRecvMngList = NULL;\r\npDevice->NumRecvFreeList = 0;\r\nmemset(pDevice->pRCBMem, 0, (sizeof(RCB) * pDevice->cbRD));\r\npRCB = (PRCB) pDevice->pRCBMem;\r\nfor (ii = 0; ii < pDevice->cbRD; ii++) {\r\npDevice->apRCB[ii] = pRCB;\r\npRCB->pDevice = (void *) pDevice;\r\npRCB->pUrb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (pRCB->pUrb == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to alloc rx urb\n");\r\ngoto free_rx_tx;\r\n}\r\npRCB->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (pRCB->skb == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to alloc rx skb\n");\r\ngoto free_rx_tx;\r\n}\r\npRCB->skb->dev = pDevice->dev;\r\npRCB->bBoolInUse = FALSE;\r\nEnqueueRCB(pDevice->FirstRecvFreeList, pDevice->LastRecvFreeList, pRCB);\r\npDevice->NumRecvFreeList++;\r\npRCB++;\r\n}\r\npDevice->pControlURB = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (pDevice->pControlURB == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc control urb\n");\r\ngoto free_rx_tx;\r\n}\r\npDevice->pInterruptURB = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (pDevice->pInterruptURB == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc int urb\n");\r\nusb_free_urb(pDevice->pControlURB);\r\ngoto free_rx_tx;\r\n}\r\npDevice->intBuf.pDataBuf = kmalloc(MAX_INTERRUPT_SIZE, GFP_KERNEL);\r\nif (pDevice->intBuf.pDataBuf == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc int buf\n");\r\nusb_free_urb(pDevice->pControlURB);\r\nusb_free_urb(pDevice->pInterruptURB);\r\ngoto free_rx_tx;\r\n}\r\nreturn TRUE;\r\nfree_rx_tx:\r\ndevice_free_rx_bufs(pDevice);\r\nfree_tx:\r\ndevice_free_tx_bufs(pDevice);\r\nreturn FALSE;\r\n}\r\nstatic BOOL device_init_defrag_cb(PSDevice pDevice) {\r\nint i;\r\nPSDeFragControlBlock pDeF;\r\nfor (i = 0; i < CB_MAX_RX_FRAG; i++) {\r\npDeF = &(pDevice->sRxDFCB[i]);\r\nif (!device_alloc_frag_buf(pDevice, pDeF)) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",\r\npDevice->dev->name);\r\ngoto free_frag;\r\n}\r\n}\r\npDevice->cbDFCB = CB_MAX_RX_FRAG;\r\npDevice->cbFreeDFCB = pDevice->cbDFCB;\r\nreturn TRUE;\r\nfree_frag:\r\ndevice_free_frag_bufs(pDevice);\r\nreturn FALSE;\r\n}\r\nstatic void device_free_frag_bufs(PSDevice pDevice) {\r\nPSDeFragControlBlock pDeF;\r\nint i;\r\nfor (i = 0; i < CB_MAX_RX_FRAG; i++) {\r\npDeF = &(pDevice->sRxDFCB[i]);\r\nif (pDeF->skb)\r\ndev_kfree_skb(pDeF->skb);\r\n}\r\n}\r\nBOOL device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {\r\npDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (pDeF->skb == NULL)\r\nreturn FALSE;\r\nASSERT(pDeF->skb);\r\npDeF->skb->dev = pDevice->dev;\r\nreturn TRUE;\r\n}\r\nstatic int device_open(struct net_device *dev) {\r\nPSDevice pDevice=(PSDevice) netdev_priv(dev);\r\nextern SWPAResult wpa_Result;\r\nmemset(wpa_Result.ifname,0,sizeof(wpa_Result.ifname));\r\nwpa_Result.proto = 0;\r\nwpa_Result.key_mgmt = 0;\r\nwpa_Result.eap_type = 0;\r\nwpa_Result.authenticated = FALSE;\r\npDevice->fWPA_Authened = FALSE;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " device_open...\n");\r\npDevice->rx_buf_sz = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;\r\nif (device_alloc_bufs(pDevice) == FALSE) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " device_alloc_bufs fail... \n");\r\nreturn -ENOMEM;\r\n}\r\nif (device_init_defrag_cb(pDevice)== FALSE) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Initial defragement cb fail \n");\r\ngoto free_rx_tx;\r\n}\r\nMP_CLEAR_FLAG(pDevice, fMP_DISCONNECTED);\r\nMP_CLEAR_FLAG(pDevice, fMP_CONTROL_READS);\r\nMP_CLEAR_FLAG(pDevice, fMP_CONTROL_WRITES);\r\nMP_SET_FLAG(pDevice, fMP_POST_READS);\r\nMP_SET_FLAG(pDevice, fMP_POST_WRITES);\r\nRead_config_file(pDevice);\r\nif (device_init_registers(pDevice, DEVICE_INIT_COLD) == FALSE) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " init register fail\n");\r\ngoto free_all;\r\n}\r\ndevice_set_multi(pDevice->dev);\r\nKeyvInitTable(pDevice,&pDevice->sKey);\r\nmemcpy(pDevice->sMgmtObj.abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);\r\nmemcpy(pDevice->dev->dev_addr, pDevice->abyCurrentNetAddr, ETH_ALEN);\r\npDevice->bStopTx0Pkt = FALSE;\r\npDevice->bStopDataPkt = FALSE;\r\npDevice->bRoaming = FALSE;\r\npDevice->bIsRoaming = FALSE;\r\npDevice->bEnableRoaming = FALSE;\r\nif (pDevice->bDiversityRegCtlON) {\r\ndevice_init_diversity_timer(pDevice);\r\n}\r\nvMgrObjectInit(pDevice);\r\ntasklet_init(&pDevice->RxMngWorkItem, (void *)RXvMngWorkItem, (unsigned long)pDevice);\r\ntasklet_init(&pDevice->ReadWorkItem, (void *)RXvWorkItem, (unsigned long)pDevice);\r\ntasklet_init(&pDevice->EventWorkItem, (void *)INTvWorkItem, (unsigned long)pDevice);\r\nadd_timer(&(pDevice->sMgmtObj.sTimerSecondCallback));\r\npDevice->int_interval = 100;\r\npDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;\r\npDevice->bIsRxWorkItemQueued = TRUE;\r\npDevice->fKillEventPollingThread = FALSE;\r\npDevice->bEventAvailable = FALSE;\r\npDevice->bWPADEVUp = FALSE;\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\npDevice->bwextstep0 = FALSE;\r\npDevice->bwextstep1 = FALSE;\r\npDevice->bwextstep2 = FALSE;\r\npDevice->bwextstep3 = FALSE;\r\npDevice->bWPASuppWextEnabled = FALSE;\r\n#endif\r\npDevice->byReAssocCount = 0;\r\nRXvWorkItem(pDevice);\r\nINTvWorkItem(pDevice);\r\nif ((pDevice->bEncryptionEnable == TRUE) && (pDevice->bTransmitKey == TRUE)) {\r\nspin_lock_irq(&pDevice->lock);\r\nKeybSetDefaultKey( pDevice,\r\n&(pDevice->sKey),\r\npDevice->byKeyIndex | (1 << 31),\r\npDevice->uKeyLength,\r\nNULL,\r\npDevice->abyKey,\r\nKEY_CTL_WEP\r\n);\r\nspin_unlock_irq(&pDevice->lock);\r\npDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;\r\n}\r\nif (pDevice->sMgmtObj.eConfigMode == WMAC_CONFIG_AP) {\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_RUN_AP, NULL);\r\n}\r\nelse {\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, NULL);\r\n}\r\nnetif_stop_queue(pDevice->dev);\r\npDevice->flags |= DEVICE_FLAGS_OPENED;\r\n{\r\nunion iwreq_data wrqu;\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.flags = RT_UPDEV_EVENT_FLAG;\r\nwireless_send_event(pDevice->dev, IWEVCUSTOM, &wrqu, NULL);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");\r\nreturn 0;\r\nfree_all:\r\ndevice_free_frag_bufs(pDevice);\r\nfree_rx_tx:\r\ndevice_free_rx_bufs(pDevice);\r\ndevice_free_tx_bufs(pDevice);\r\ndevice_free_int_bufs(pDevice);\r\nusb_kill_urb(pDevice->pControlURB);\r\nusb_kill_urb(pDevice->pInterruptURB);\r\nusb_free_urb(pDevice->pControlURB);\r\nusb_free_urb(pDevice->pInterruptURB);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open fail.. \n");\r\nreturn -ENOMEM;\r\n}\r\nstatic int device_close(struct net_device *dev) {\r\nPSDevice pDevice=(PSDevice) netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nint uu;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close1 \n");\r\nif (pDevice == NULL)\r\nreturn -ENODEV;\r\n{\r\nunion iwreq_data wrqu;\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.flags = RT_DOWNDEV_EVENT_FLAG;\r\nwireless_send_event(pDevice->dev, IWEVCUSTOM, &wrqu, NULL);\r\n}\r\nif (pDevice->bLinkPass) {\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_DISASSOCIATE, NULL);\r\nmdelay(30);\r\n}\r\ndevice_release_WPADEV(pDevice);\r\nmemset(pMgmt->abyDesireSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);\r\npMgmt->bShareKeyAlgorithm = FALSE;\r\npDevice->bEncryptionEnable = FALSE;\r\npDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;\r\nspin_lock_irq(&pDevice->lock);\r\nfor (uu = 0; uu < MAX_KEY_TABLE; uu++)\r\nMACvDisableKeyEntry(pDevice,uu);\r\nspin_unlock_irq(&pDevice->lock);\r\nif ((pDevice->flags & DEVICE_FLAGS_UNPLUG) == FALSE) {\r\nMACbShutdown(pDevice);\r\n}\r\nnetif_stop_queue(pDevice->dev);\r\nMP_SET_FLAG(pDevice, fMP_DISCONNECTED);\r\nMP_CLEAR_FLAG(pDevice, fMP_POST_WRITES);\r\nMP_CLEAR_FLAG(pDevice, fMP_POST_READS);\r\npDevice->fKillEventPollingThread = TRUE;\r\ndel_timer(&pDevice->sTimerCommand);\r\ndel_timer(&pMgmt->sTimerSecondCallback);\r\ndel_timer(&pDevice->sTimerTxData);\r\nif (pDevice->bDiversityRegCtlON) {\r\ndel_timer(&pDevice->TimerSQ3Tmax1);\r\ndel_timer(&pDevice->TimerSQ3Tmax2);\r\ndel_timer(&pDevice->TimerSQ3Tmax3);\r\n}\r\ntasklet_kill(&pDevice->RxMngWorkItem);\r\ntasklet_kill(&pDevice->ReadWorkItem);\r\ntasklet_kill(&pDevice->EventWorkItem);\r\npDevice->bRoaming = FALSE;\r\npDevice->bIsRoaming = FALSE;\r\npDevice->bEnableRoaming = FALSE;\r\npDevice->bCmdRunning = FALSE;\r\npDevice->bLinkPass = FALSE;\r\nmemset(pMgmt->abyCurrBSSID, 0, 6);\r\npMgmt->eCurrState = WMAC_STATE_IDLE;\r\ndevice_free_tx_bufs(pDevice);\r\ndevice_free_rx_bufs(pDevice);\r\ndevice_free_int_bufs(pDevice);\r\ndevice_free_frag_bufs(pDevice);\r\nusb_kill_urb(pDevice->pControlURB);\r\nusb_kill_urb(pDevice->pInterruptURB);\r\nusb_free_urb(pDevice->pControlURB);\r\nusb_free_urb(pDevice->pInterruptURB);\r\nBSSvClearNodeDBTable(pDevice, 0);\r\npDevice->flags &=(~DEVICE_FLAGS_OPENED);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close2 \n");\r\nreturn 0;\r\n}\r\nstatic void __devexit vt6656_disconnect(struct usb_interface *intf)\r\n{\r\nPSDevice device = usb_get_intfdata(intf);\r\nif (!device)\r\nreturn;\r\n{\r\nunion iwreq_data req;\r\nmemset(&req, 0, sizeof(req));\r\nreq.data.flags = RT_RMMOD_EVENT_FLAG;\r\nwireless_send_event(device->dev, IWEVCUSTOM, &req, NULL);\r\n}\r\ndevice_release_WPADEV(device);\r\nif (device->firmware)\r\nrelease_firmware(device->firmware);\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(interface_to_usbdev(intf));\r\ndevice->flags |= DEVICE_FLAGS_UNPLUG;\r\nif (device->dev) {\r\nunregister_netdev(device->dev);\r\nwpa_set_wpadev(device, 0);\r\nfree_netdev(device->dev);\r\n}\r\n}\r\nstatic int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nPSDevice pDevice = netdev_priv(dev);\r\nspin_lock_irq(&pDevice->lock);\r\nif (unlikely(pDevice->bStopTx0Pkt))\r\ndev_kfree_skb_irq(skb);\r\nelse\r\nvDMA0_tx_80211(pDevice, skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int device_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nPSDevice pDevice = netdev_priv(dev);\r\nstruct net_device_stats *stats = &pDevice->stats;\r\nspin_lock_irq(&pDevice->lock);\r\nnetif_stop_queue(dev);\r\nif (!pDevice->bLinkPass) {\r\ndev_kfree_skb_irq(skb);\r\ngoto out;\r\n}\r\nif (pDevice->bStopDataPkt) {\r\ndev_kfree_skb_irq(skb);\r\nstats->tx_dropped++;\r\ngoto out;\r\n}\r\nif (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb)) {\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nout:\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic inline u32 ether_crc(int length, unsigned char *data)\r\n{\r\nint crc = -1;\r\nwhile(--length >= 0) {\r\nunsigned char current_octet = *data++;\r\nint bit;\r\nfor (bit = 0; bit < 8; bit++, current_octet >>= 1) {\r\ncrc = (crc << 1) ^\r\n((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);\r\n}\r\n}\r\nreturn crc;\r\n}\r\nstatic unsigned char *kstrstr(const unsigned char *str1,\r\nconst unsigned char *str2) {\r\nint str1_len = strlen(str1);\r\nint str2_len = strlen(str2);\r\nwhile (str1_len >= str2_len) {\r\nstr1_len--;\r\nif(memcmp(str1,str2,str2_len)==0)\r\nreturn (unsigned char *) str1;\r\nstr1++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int Config_FileGetParameter(unsigned char *string,\r\nunsigned char *dest,\r\nunsigned char *source)\r\n{\r\nunsigned char buf1[100];\r\nunsigned char buf2[100];\r\nunsigned char *start_p = NULL, *end_p = NULL, *tmp_p = NULL;\r\nint ii;\r\nmemset(buf1,0,100);\r\nstrcat(buf1, string);\r\nstrcat(buf1, "=");\r\nsource+=strlen(buf1);\r\nstart_p = kstrstr(source,buf1);\r\nif (start_p == NULL)\r\nreturn FALSE;\r\nfor (ii = 1; ; ii++) {\r\nif (memcmp(start_p - ii, "\n", 1) == 0)\r\nbreak;\r\nif (memcmp(start_p - ii, "#", 1) == 0)\r\nreturn FALSE;\r\n}\r\nend_p = kstrstr(start_p,"\n");\r\nif (end_p == NULL) {\r\nend_p=start_p+strlen(start_p);\r\n}\r\nmemset(buf2,0,100);\r\nmemcpy(buf2,start_p,end_p-start_p);\r\nbuf2[end_p-start_p]='\0';\r\nstart_p = kstrstr(buf2,"=");\r\nif (start_p == NULL)\r\nreturn FALSE;\r\nmemset(buf1,0,100);\r\nstrcpy(buf1,start_p+1);\r\ntmp_p = buf1;\r\nwhile(*tmp_p != 0x00) {\r\nif(*tmp_p==' ')\r\ntmp_p++;\r\nelse\r\nbreak;\r\n}\r\nmemcpy(dest,tmp_p,strlen(tmp_p));\r\nreturn TRUE;\r\n}\r\nstatic unsigned char *Config_FileOperation(PSDevice pDevice)\r\n{\r\nunsigned char *config_path = CONFIG_PATH;\r\nunsigned char *buffer = NULL;\r\nstruct file *filp=NULL;\r\nmm_segment_t old_fs = get_fs();\r\nint result = 0;\r\nset_fs (KERNEL_DS);\r\nfilp = filp_open(config_path, O_RDWR, 0);\r\nif (IS_ERR(filp)) {\r\nprintk("Config_FileOperation file Not exist\n");\r\nresult=-1;\r\ngoto error2;\r\n}\r\nif(!(filp->f_op) || !(filp->f_op->read) ||!(filp->f_op->write)) {\r\nprintk("file %s cann't readable or writable?\n",config_path);\r\nresult = -1;\r\ngoto error1;\r\n}\r\nbuffer = kmalloc(1024, GFP_KERNEL);\r\nif(buffer==NULL) {\r\nprintk("allocate mem for file fail?\n");\r\nresult = -1;\r\ngoto error1;\r\n}\r\nif(filp->f_op->read(filp, buffer, 1024, &filp->f_pos)<0) {\r\nprintk("read file error?\n");\r\nresult = -1;\r\n}\r\nerror1:\r\nif(filp_close(filp,NULL))\r\nprintk("Config_FileOperation:close file fail\n");\r\nerror2:\r\nset_fs (old_fs);\r\nif(result!=0) {\r\nkfree(buffer);\r\nbuffer=NULL;\r\n}\r\nreturn buffer;\r\n}\r\nstatic int Read_config_file(PSDevice pDevice) {\r\nint result = 0;\r\nunsigned char tmpbuffer[100];\r\nunsigned char *buffer = NULL;\r\npDevice->config_file.ZoneType = -1;\r\npDevice->config_file.eAuthenMode = -1;\r\npDevice->config_file.eEncryptionStatus = -1;\r\nbuffer = Config_FileOperation(pDevice);\r\nif (buffer == NULL) {\r\nresult =-1;\r\nreturn result;\r\n}\r\n{\r\nmemset(tmpbuffer,0,sizeof(tmpbuffer));\r\nif(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer) ==TRUE) {\r\nif(memcmp(tmpbuffer,"USA",3)==0) {\r\npDevice->config_file.ZoneType=ZoneType_USA;\r\n}\r\nelse if(memcmp(tmpbuffer,"JAPAN",5)==0) {\r\npDevice->config_file.ZoneType=ZoneType_Japan;\r\n}\r\nelse if(memcmp(tmpbuffer,"EUROPE",6)==0) {\r\npDevice->config_file.ZoneType=ZoneType_Europe;\r\n}\r\nelse {\r\nprintk("Unknown Zonetype[%s]?\n",tmpbuffer);\r\n}\r\n}\r\n}\r\n{\r\nmemset(tmpbuffer,0,sizeof(tmpbuffer));\r\nif(Config_FileGetParameter("AUTHENMODE",tmpbuffer,buffer)==TRUE) {\r\npDevice->config_file.eAuthenMode = (int) simple_strtol(tmpbuffer, NULL, 10);\r\n}\r\nmemset(tmpbuffer,0,sizeof(tmpbuffer));\r\nif(Config_FileGetParameter("ENCRYPTIONMODE",tmpbuffer,buffer)==TRUE) {\r\npDevice->config_file.eEncryptionStatus= (int) simple_strtol(tmpbuffer, NULL, 10);\r\n}\r\n}\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic void device_set_multi(struct net_device *dev) {\r\nPSDevice pDevice = (PSDevice) netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nu32 mc_filter[2];\r\nint ii;\r\nstruct netdev_hw_addr *ha;\r\nBYTE pbyData[8] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};\r\nBYTE byTmpMode = 0;\r\nint rc;\r\nspin_lock_irq(&pDevice->lock);\r\nrc = CONTROLnsRequestIn(pDevice,\r\nMESSAGE_TYPE_READ,\r\nMAC_REG_RCR,\r\nMESSAGE_REQUEST_MACREG,\r\n1,\r\n&byTmpMode\r\n);\r\nif (rc == 0) pDevice->byRxMode = byTmpMode;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode in= %x\n", pDevice->byRxMode);\r\nif (dev->flags & IFF_PROMISC) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);\r\n}\r\nelse if ((netdev_mc_count(dev) > pDevice->multicast_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nCONTROLnsRequestOut(pDevice,\r\nMESSAGE_TYPE_WRITE,\r\nMAC_REG_MAR0,\r\nMESSAGE_REQUEST_MACREG,\r\n8,\r\npbyData\r\n);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\n}\r\nelse {\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));\r\n}\r\nfor (ii = 0; ii < 4; ii++) {\r\nMACvWriteMultiAddr(pDevice, ii, *((PBYTE)&mc_filter[0] + ii));\r\nMACvWriteMultiAddr(pDevice, ii+ 4, *((PBYTE)&mc_filter[1] + ii));\r\n}\r\npDevice->byRxMode &= ~(RCR_UNICAST);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\n}\r\nif (pMgmt->eConfigMode == WMAC_CONFIG_AP) {\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\npDevice->byRxMode &= ~(RCR_UNICAST);\r\n}\r\nControlvWriteByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_RCR, pDevice->byRxMode);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode out= %x\n", pDevice->byRxMode);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\nstatic struct net_device_stats *device_get_stats(struct net_device *dev) {\r\nPSDevice pDevice=(PSDevice) netdev_priv(dev);\r\nreturn &pDevice->stats;\r\n}\r\nstatic int device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nPSCmdRequest pReq;\r\nstruct iwreq *wrq = (struct iwreq *) rq;\r\nint rc =0;\r\nif (pMgmt == NULL) {\r\nrc = -EFAULT;\r\nreturn rc;\r\n}\r\nswitch(cmd) {\r\ncase SIOCGIWNAME:\r\nrc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);\r\nbreak;\r\ncase SIOCSIWNWID:\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCGIWNWID:\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\nrc = iwctl_giwnwid(dev, NULL, &(wrq->u.nwid), NULL);\r\n#else\r\nrc = -EOPNOTSUPP;\r\n#endif\r\nbreak;\r\ncase SIOCSIWFREQ:\r\nrc = iwctl_siwfreq(dev, NULL, &(wrq->u.freq), NULL);\r\nbreak;\r\ncase SIOCGIWFREQ:\r\nrc = iwctl_giwfreq(dev, NULL, &(wrq->u.freq), NULL);\r\nbreak;\r\ncase SIOCSIWESSID:\r\n{\r\nchar essid[IW_ESSID_MAX_SIZE+1];\r\nif (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {\r\nrc = -E2BIG;\r\nbreak;\r\n}\r\nif (copy_from_user(essid, wrq->u.essid.pointer,\r\nwrq->u.essid.length)) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nrc = iwctl_siwessid(dev, NULL,\r\n&(wrq->u.essid), essid);\r\n}\r\nbreak;\r\ncase SIOCGIWESSID:\r\n{\r\nchar essid[IW_ESSID_MAX_SIZE+1];\r\nif (wrq->u.essid.pointer) {\r\nrc = iwctl_giwessid(dev, NULL,\r\n&(wrq->u.essid), essid);\r\nif (copy_to_user(wrq->u.essid.pointer,\r\nessid,\r\nwrq->u.essid.length) )\r\nrc = -EFAULT;\r\n}\r\n}\r\nbreak;\r\ncase SIOCSIWAP:\r\nrc = iwctl_siwap(dev, NULL, &(wrq->u.ap_addr), NULL);\r\nbreak;\r\ncase SIOCGIWAP:\r\nrc = iwctl_giwap(dev, NULL, &(wrq->u.ap_addr), NULL);\r\nbreak;\r\ncase SIOCSIWNICKN:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCGIWNICKN:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCSIWRATE:\r\nrc = iwctl_siwrate(dev, NULL, &(wrq->u.bitrate), NULL);\r\nbreak;\r\ncase SIOCGIWRATE:\r\nrc = iwctl_giwrate(dev, NULL, &(wrq->u.bitrate), NULL);\r\nbreak;\r\ncase SIOCSIWRTS:\r\nrc = iwctl_siwrts(dev, NULL, &(wrq->u.rts), NULL);\r\nbreak;\r\ncase SIOCGIWRTS:\r\nrc = iwctl_giwrts(dev, NULL, &(wrq->u.rts), NULL);\r\nbreak;\r\ncase SIOCSIWFRAG:\r\nrc = iwctl_siwfrag(dev, NULL, &(wrq->u.frag), NULL);\r\nbreak;\r\ncase SIOCGIWFRAG:\r\nrc = iwctl_giwfrag(dev, NULL, &(wrq->u.frag), NULL);\r\nbreak;\r\ncase SIOCSIWMODE:\r\nrc = iwctl_siwmode(dev, NULL, &(wrq->u.mode), NULL);\r\nbreak;\r\ncase SIOCGIWMODE:\r\nrc = iwctl_giwmode(dev, NULL, &(wrq->u.mode), NULL);\r\nbreak;\r\ncase SIOCSIWENCODE:\r\n{\r\nchar abyKey[WLAN_WEP232_KEYLEN];\r\nif (wrq->u.encoding.pointer) {\r\nif (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {\r\nrc = -E2BIG;\r\nbreak;\r\n}\r\nmemset(abyKey, 0, WLAN_WEP232_KEYLEN);\r\nif (copy_from_user(abyKey,\r\nwrq->u.encoding.pointer,\r\nwrq->u.encoding.length)) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\n} else if (wrq->u.encoding.length != 0) {\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nrc = iwctl_siwencode(dev, NULL, &(wrq->u.encoding), abyKey);\r\n}\r\nbreak;\r\ncase SIOCGIWENCODE:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\n{\r\nchar abyKey[WLAN_WEP232_KEYLEN];\r\nrc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);\r\nif (rc != 0) break;\r\nif (wrq->u.encoding.pointer) {\r\nif (copy_to_user(wrq->u.encoding.pointer,\r\nabyKey,\r\nwrq->u.encoding.length))\r\nrc = -EFAULT;\r\n}\r\n}\r\nbreak;\r\ncase SIOCGIWTXPOW:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCSIWTXPOW:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCSIWRETRY:\r\nrc = iwctl_siwretry(dev, NULL, &(wrq->u.retry), NULL);\r\nbreak;\r\ncase SIOCGIWRETRY:\r\nrc = iwctl_giwretry(dev, NULL, &(wrq->u.retry), NULL);\r\nbreak;\r\ncase SIOCGIWRANGE:\r\n{\r\nstruct iw_range range;\r\nrc = iwctl_giwrange(dev, NULL, &(wrq->u.data), (char *) &range);\r\nif (copy_to_user(wrq->u.data.pointer, &range, sizeof(struct iw_range)))\r\nrc = -EFAULT;\r\n}\r\nbreak;\r\ncase SIOCGIWPOWER:\r\nrc = iwctl_giwpower(dev, NULL, &(wrq->u.power), NULL);\r\nbreak;\r\ncase SIOCSIWPOWER:\r\nrc = iwctl_siwpower(dev, NULL, &(wrq->u.power), NULL);\r\nbreak;\r\ncase SIOCGIWSENS:\r\nrc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);\r\nbreak;\r\ncase SIOCSIWSENS:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCGIWAPLIST:\r\n{\r\nchar buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];\r\nif (wrq->u.data.pointer) {\r\nrc = iwctl_giwaplist(dev, NULL, &(wrq->u.data), buffer);\r\nif (rc == 0) {\r\nif (copy_to_user(wrq->u.data.pointer,\r\nbuffer,\r\n(wrq->u.data.length * (sizeof(struct sockaddr) + sizeof(struct iw_quality)))\r\n))\r\nrc = -EFAULT;\r\n}\r\n}\r\n}\r\nbreak;\r\n#ifdef WIRELESS_SPY\r\ncase SIOCSIWSPY:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCGIWSPY:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\n#endif\r\ncase SIOCGIWPRIV:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\ncase SIOCSIWAUTH:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH\n");\r\nrc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);\r\nbreak;\r\ncase SIOCGIWAUTH:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH \n");\r\nrc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);\r\nbreak;\r\ncase SIOCSIWGENIE:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE \n");\r\nrc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);\r\nbreak;\r\ncase SIOCGIWGENIE:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE \n");\r\nrc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);\r\nbreak;\r\ncase SIOCSIWENCODEEXT:\r\n{\r\nchar extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");\r\nif(wrq->u.encoding.pointer){\r\nmemset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1);\r\nif(wrq->u.encoding.length > (sizeof(struct iw_encode_ext)+ MAX_KEY_LEN)){\r\nrc = -E2BIG;\r\nbreak;\r\n}\r\nif(copy_from_user(extra, wrq->u.encoding.pointer,wrq->u.encoding.length)){\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\n}else if(wrq->u.encoding.length != 0){\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nrc = iwctl_siwencodeext(dev, NULL, &(wrq->u.encoding), extra);\r\n}\r\nbreak;\r\ncase SIOCGIWENCODEEXT:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");\r\nrc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);\r\nbreak;\r\ncase SIOCSIWMLME:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME \n");\r\nrc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);\r\nbreak;\r\n#endif\r\ncase IOCTL_CMD_TEST:\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {\r\nrc = -EFAULT;\r\nbreak;\r\n} else {\r\nrc = 0;\r\n}\r\npReq = (PSCmdRequest)rq;\r\npReq->wResult = MAGIC_CODE;\r\nbreak;\r\ncase IOCTL_CMD_SET:\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&\r\n(((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_WPA))\r\n{\r\nrc = -EFAULT;\r\nbreak;\r\n} else {\r\nrc = 0;\r\n}\r\nif (test_and_set_bit( 0, (void*)&(pMgmt->uCmdBusy))) {\r\nreturn -EBUSY;\r\n}\r\nrc = private_ioctl(pDevice, rq);\r\nclear_bit( 0, (void*)&(pMgmt->uCmdBusy));\r\nbreak;\r\ncase IOCTL_CMD_HOSTAPD:\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {\r\nrc = -EFAULT;\r\nbreak;\r\n} else {\r\nrc = 0;\r\n}\r\nrc = vt6656_hostap_ioctl(pDevice, &wrq->u.data);\r\nbreak;\r\ncase IOCTL_CMD_WPA:\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {\r\nrc = -EFAULT;\r\nbreak;\r\n} else {\r\nrc = 0;\r\n}\r\nrc = wpa_ioctl(pDevice, &wrq->u.data);\r\nbreak;\r\ncase SIOCETHTOOL:\r\nreturn ethtool_ioctl(dev, (void *) rq->ifr_data);\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);\r\n}\r\nif (pDevice->bCommit) {\r\nif (pMgmt->eConfigMode == WMAC_CONFIG_AP) {\r\nnetif_stop_queue(pDevice->dev);\r\nspin_lock_irq(&pDevice->lock);\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_RUN_AP, NULL);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\nelse {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");\r\nspin_lock_irq(&pDevice->lock);\r\nif (pDevice->bLinkPass &&\r\nmemcmp(pMgmt->abyCurrSSID,pMgmt->abyDesireSSID,WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN)) {\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_DISASSOCIATE, NULL);\r\n} else {\r\npDevice->bLinkPass = FALSE;\r\npMgmt->eCurrState = WMAC_STATE_IDLE;\r\nmemset(pMgmt->abyCurrBSSID, 0, 6);\r\n}\r\nControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);\r\nnetif_stop_queue(pDevice->dev);\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\npMgmt->eScanType = WMAC_SCAN_ACTIVE;\r\nif (!pDevice->bWPASuppWextEnabled)\r\n#endif\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_BSSID_SCAN,\r\npMgmt->abyDesireSSID);\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_SSID,\r\nNULL);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\npDevice->bCommit = FALSE;\r\n}\r\nreturn rc;\r\n}\r\nstatic int ethtool_ioctl(struct net_device *dev, void *useraddr)\r\n{\r\nu32 ethcmd;\r\nif (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))\r\nreturn -EFAULT;\r\nswitch (ethcmd) {\r\ncase ETHTOOL_GDRVINFO: {\r\nstruct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};\r\nstrncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);\r\nstrncpy(info.version, DEVICE_VERSION, sizeof(info.version)-1);\r\nif (copy_to_user(useraddr, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int __init vt6656_init_module(void)\r\n{\r\nprintk(KERN_NOTICE DEVICE_FULL_DRV_NAM " " DEVICE_VERSION);\r\nreturn usb_register(&vt6656_driver);\r\n}\r\nstatic void __exit vt6656_cleanup_module(void)\r\n{\r\nusb_deregister(&vt6656_driver);\r\n}
