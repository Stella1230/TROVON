static int check_offs_len(struct mtd_info *mtd,\r\nloff_t ofs, uint64_t len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret = 0;\r\nif (ofs & ((1 << chip->phys_erase_shift) - 1)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Unaligned address\n", __func__);\r\nret = -EINVAL;\r\n}\r\nif (len & ((1 << chip->phys_erase_shift) - 1)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Length not block aligned\n",\r\n__func__);\r\nret = -EINVAL;\r\n}\r\nif (ofs + len > mtd->size) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Past end of device\n",\r\n__func__);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void nand_release_device(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nchip->select_chip(mtd, -1);\r\nspin_lock(&chip->controller->lock);\r\nchip->controller->active = NULL;\r\nchip->state = FL_READY;\r\nwake_up(&chip->controller->wq);\r\nspin_unlock(&chip->controller->lock);\r\n}\r\nstatic uint8_t nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nreturn readb(chip->IO_ADDR_R);\r\n}\r\nstatic uint8_t nand_read_byte16(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nreturn (uint8_t) cpu_to_le16(readw(chip->IO_ADDR_R));\r\n}\r\nstatic u16 nand_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nreturn readw(chip->IO_ADDR_R);\r\n}\r\nstatic void nand_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nswitch (chipnr) {\r\ncase -1:\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd->priv;\r\nfor (i = 0; i < len; i++)\r\nwriteb(buf[i], chip->IO_ADDR_W);\r\n}\r\nstatic void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd->priv;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = readb(chip->IO_ADDR_R);\r\n}\r\nstatic int nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd->priv;\r\nfor (i = 0; i < len; i++)\r\nif (buf[i] != readb(chip->IO_ADDR_R))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++)\r\nwritew(p[i], chip->IO_ADDR_W);\r\n}\r\nstatic void nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++)\r\np[i] = readw(chip->IO_ADDR_R);\r\n}\r\nstatic int nand_verify_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++)\r\nif (p[i] != readw(chip->IO_ADDR_R))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)\r\n{\r\nint page, chipnr, res = 0;\r\nstruct nand_chip *chip = mtd->priv;\r\nu16 bad;\r\nif (chip->options & NAND_BBT_SCANLASTPAGE)\r\nofs += mtd->erasesize - mtd->writesize;\r\npage = (int)(ofs >> chip->page_shift) & chip->pagemask;\r\nif (getchip) {\r\nchipnr = (int)(ofs >> chip->chip_shift);\r\nnand_get_device(chip, mtd, FL_READING);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\nif (chip->options & NAND_BUSWIDTH_16) {\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos & 0xFE,\r\npage);\r\nbad = cpu_to_le16(chip->read_word(mtd));\r\nif (chip->badblockpos & 0x1)\r\nbad >>= 8;\r\nelse\r\nbad &= 0xFF;\r\n} else {\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos, page);\r\nbad = chip->read_byte(mtd);\r\n}\r\nif (likely(chip->badblockbits == 8))\r\nres = bad != 0xFF;\r\nelse\r\nres = hweight8(bad) < chip->badblockbits;\r\nif (getchip)\r\nnand_release_device(mtd);\r\nreturn res;\r\n}\r\nstatic int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nuint8_t buf[2] = { 0, 0 };\r\nint block, ret, i = 0;\r\nif (chip->options & NAND_BBT_SCANLASTPAGE)\r\nofs += mtd->erasesize - mtd->writesize;\r\nblock = (int)(ofs >> chip->bbt_erase_shift);\r\nif (chip->bbt)\r\nchip->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);\r\nif (chip->options & NAND_USE_FLASH_BBT)\r\nret = nand_update_bbt(mtd, ofs);\r\nelse {\r\nnand_get_device(chip, mtd, FL_WRITING);\r\ndo {\r\nchip->ops.len = chip->ops.ooblen = 2;\r\nchip->ops.datbuf = NULL;\r\nchip->ops.oobbuf = buf;\r\nchip->ops.ooboffs = chip->badblockpos & ~0x01;\r\nret = nand_do_write_oob(mtd, ofs, &chip->ops);\r\nif (!ret && (chip->options & NAND_BBT_SCANBYTE1AND6)) {\r\nchip->ops.ooboffs = NAND_SMALL_BADBLOCK_POS\r\n& ~0x01;\r\nret = nand_do_write_oob(mtd, ofs, &chip->ops);\r\n}\r\ni++;\r\nofs += mtd->writesize;\r\n} while (!ret && (chip->options & NAND_BBT_SCAN2NDPAGE) &&\r\ni < 2);\r\nnand_release_device(mtd);\r\n}\r\nif (!ret)\r\nmtd->ecc_stats.badblocks++;\r\nreturn ret;\r\n}\r\nstatic int nand_check_wp(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (chip->options & NAND_BROKEN_XD)\r\nreturn 0;\r\nchip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);\r\nreturn (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;\r\n}\r\nstatic int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,\r\nint allowbbt)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (!chip->bbt)\r\nreturn chip->block_bad(mtd, ofs, getchip);\r\nreturn nand_isbad_bbt(mtd, ofs, allowbbt);\r\n}\r\nstatic void panic_nand_wait_ready(struct mtd_info *mtd, unsigned long timeo)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint i;\r\nfor (i = 0; i < timeo; i++) {\r\nif (chip->dev_ready(mtd))\r\nbreak;\r\ntouch_softlockup_watchdog();\r\nmdelay(1);\r\n}\r\n}\r\nvoid nand_wait_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nunsigned long timeo = jiffies + 2;\r\nif (in_interrupt() || oops_in_progress)\r\nreturn panic_nand_wait_ready(mtd, 400);\r\nled_trigger_event(nand_led_trigger, LED_FULL);\r\ndo {\r\nif (chip->dev_ready(mtd))\r\nbreak;\r\ntouch_softlockup_watchdog();\r\n} while (time_before(jiffies, timeo));\r\nled_trigger_event(nand_led_trigger, LED_OFF);\r\n}\r\nstatic void nand_command(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nregister struct nand_chip *chip = mtd->priv;\r\nint ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;\r\nif (command == NAND_CMD_SEQIN) {\r\nint readcmd;\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nreadcmd = NAND_CMD_READOOB;\r\n} else if (column < 256) {\r\nreadcmd = NAND_CMD_READ0;\r\n} else {\r\ncolumn -= 256;\r\nreadcmd = NAND_CMD_READ1;\r\n}\r\nchip->cmd_ctrl(mtd, readcmd, ctrl);\r\nctrl &= ~NAND_CTRL_CHANGE;\r\n}\r\nchip->cmd_ctrl(mtd, command, ctrl);\r\nctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;\r\nif (column != -1) {\r\nif (chip->options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nchip->cmd_ctrl(mtd, column, ctrl);\r\nctrl &= ~NAND_CTRL_CHANGE;\r\n}\r\nif (page_addr != -1) {\r\nchip->cmd_ctrl(mtd, page_addr, ctrl);\r\nctrl &= ~NAND_CTRL_CHANGE;\r\nchip->cmd_ctrl(mtd, page_addr >> 8, ctrl);\r\nif (chip->chipsize > (32 << 20))\r\nchip->cmd_ctrl(mtd, page_addr >> 16, ctrl);\r\n}\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);\r\nswitch (command) {\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_STATUS:\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nif (chip->dev_ready)\r\nbreak;\r\nudelay(chip->chip_delay);\r\nchip->cmd_ctrl(mtd, NAND_CMD_STATUS,\r\nNAND_CTRL_CLE | NAND_CTRL_CHANGE);\r\nchip->cmd_ctrl(mtd,\r\nNAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);\r\nwhile (!(chip->read_byte(mtd) & NAND_STATUS_READY))\r\n;\r\nreturn;\r\ndefault:\r\nif (!chip->dev_ready) {\r\nudelay(chip->chip_delay);\r\nreturn;\r\n}\r\n}\r\nndelay(100);\r\nnand_wait_ready(mtd);\r\n}\r\nstatic void nand_command_lp(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nregister struct nand_chip *chip = mtd->priv;\r\nif (command == NAND_CMD_READOOB) {\r\ncolumn += mtd->writesize;\r\ncommand = NAND_CMD_READ0;\r\n}\r\nchip->cmd_ctrl(mtd, command & 0xff,\r\nNAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\r\nif (column != -1 || page_addr != -1) {\r\nint ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;\r\nif (column != -1) {\r\nif (chip->options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nchip->cmd_ctrl(mtd, column, ctrl);\r\nctrl &= ~NAND_CTRL_CHANGE;\r\nchip->cmd_ctrl(mtd, column >> 8, ctrl);\r\n}\r\nif (page_addr != -1) {\r\nchip->cmd_ctrl(mtd, page_addr, ctrl);\r\nchip->cmd_ctrl(mtd, page_addr >> 8,\r\nNAND_NCE | NAND_ALE);\r\nif (chip->chipsize > (128 << 20))\r\nchip->cmd_ctrl(mtd, page_addr >> 16,\r\nNAND_NCE | NAND_ALE);\r\n}\r\n}\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);\r\nswitch (command) {\r\ncase NAND_CMD_CACHEDPROG:\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_RNDIN:\r\ncase NAND_CMD_STATUS:\r\ncase NAND_CMD_DEPLETE1:\r\nreturn;\r\ncase NAND_CMD_STATUS_ERROR:\r\ncase NAND_CMD_STATUS_ERROR0:\r\ncase NAND_CMD_STATUS_ERROR1:\r\ncase NAND_CMD_STATUS_ERROR2:\r\ncase NAND_CMD_STATUS_ERROR3:\r\nudelay(chip->chip_delay);\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nif (chip->dev_ready)\r\nbreak;\r\nudelay(chip->chip_delay);\r\nchip->cmd_ctrl(mtd, NAND_CMD_STATUS,\r\nNAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE,\r\nNAND_NCE | NAND_CTRL_CHANGE);\r\nwhile (!(chip->read_byte(mtd) & NAND_STATUS_READY))\r\n;\r\nreturn;\r\ncase NAND_CMD_RNDOUT:\r\nchip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,\r\nNAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE,\r\nNAND_NCE | NAND_CTRL_CHANGE);\r\nreturn;\r\ncase NAND_CMD_READ0:\r\nchip->cmd_ctrl(mtd, NAND_CMD_READSTART,\r\nNAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE,\r\nNAND_NCE | NAND_CTRL_CHANGE);\r\ndefault:\r\nif (!chip->dev_ready) {\r\nudelay(chip->chip_delay);\r\nreturn;\r\n}\r\n}\r\nndelay(100);\r\nnand_wait_ready(mtd);\r\n}\r\nstatic void panic_nand_get_device(struct nand_chip *chip,\r\nstruct mtd_info *mtd, int new_state)\r\n{\r\nchip->controller->active = chip;\r\nchip->state = new_state;\r\n}\r\nstatic int\r\nnand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)\r\n{\r\nspinlock_t *lock = &chip->controller->lock;\r\nwait_queue_head_t *wq = &chip->controller->wq;\r\nDECLARE_WAITQUEUE(wait, current);\r\nretry:\r\nspin_lock(lock);\r\nif (!chip->controller->active)\r\nchip->controller->active = chip;\r\nif (chip->controller->active == chip && chip->state == FL_READY) {\r\nchip->state = new_state;\r\nspin_unlock(lock);\r\nreturn 0;\r\n}\r\nif (new_state == FL_PM_SUSPENDED) {\r\nif (chip->controller->active->state == FL_PM_SUSPENDED) {\r\nchip->state = FL_PM_SUSPENDED;\r\nspin_unlock(lock);\r\nreturn 0;\r\n}\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(wq, &wait);\r\nspin_unlock(lock);\r\nschedule();\r\nremove_wait_queue(wq, &wait);\r\ngoto retry;\r\n}\r\nstatic void panic_nand_wait(struct mtd_info *mtd, struct nand_chip *chip,\r\nunsigned long timeo)\r\n{\r\nint i;\r\nfor (i = 0; i < timeo; i++) {\r\nif (chip->dev_ready) {\r\nif (chip->dev_ready(mtd))\r\nbreak;\r\n} else {\r\nif (chip->read_byte(mtd) & NAND_STATUS_READY)\r\nbreak;\r\n}\r\nmdelay(1);\r\n}\r\n}\r\nstatic int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nunsigned long timeo = jiffies;\r\nint status, state = chip->state;\r\nif (state == FL_ERASING)\r\ntimeo += (HZ * 400) / 1000;\r\nelse\r\ntimeo += (HZ * 20) / 1000;\r\nled_trigger_event(nand_led_trigger, LED_FULL);\r\nndelay(100);\r\nif ((state == FL_ERASING) && (chip->options & NAND_IS_AND))\r\nchip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);\r\nelse\r\nchip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);\r\nif (in_interrupt() || oops_in_progress)\r\npanic_nand_wait(mtd, chip, timeo);\r\nelse {\r\nwhile (time_before(jiffies, timeo)) {\r\nif (chip->dev_ready) {\r\nif (chip->dev_ready(mtd))\r\nbreak;\r\n} else {\r\nif (chip->read_byte(mtd) & NAND_STATUS_READY)\r\nbreak;\r\n}\r\ncond_resched();\r\n}\r\n}\r\nled_trigger_event(nand_led_trigger, LED_OFF);\r\nstatus = (int)chip->read_byte(mtd);\r\nreturn status;\r\n}\r\nstatic int __nand_unlock(struct mtd_info *mtd, loff_t ofs,\r\nuint64_t len, int invert)\r\n{\r\nint ret = 0;\r\nint status, page;\r\nstruct nand_chip *chip = mtd->priv;\r\npage = ofs >> chip->page_shift;\r\nchip->cmdfunc(mtd, NAND_CMD_UNLOCK1, -1, page & chip->pagemask);\r\npage = (ofs + len) >> chip->page_shift;\r\nchip->cmdfunc(mtd, NAND_CMD_UNLOCK2, -1,\r\n(page | invert) & chip->pagemask);\r\nstatus = chip->waitfunc(mtd, chip);\r\nudelay(1000);\r\nif (status & 0x01) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Error status = 0x%08x\n",\r\n__func__, status);\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nint nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nint ret = 0;\r\nint chipnr;\r\nstruct nand_chip *chip = mtd->priv;\r\nDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",\r\n__func__, (unsigned long long)ofs, len);\r\nif (check_offs_len(mtd, ofs, len))\r\nret = -EINVAL;\r\nif (ofs + len == mtd->size)\r\nlen -= mtd->erasesize;\r\nnand_get_device(chip, mtd, FL_UNLOCKING);\r\nchipnr = ofs >> chip->chip_shift;\r\nchip->select_chip(mtd, chipnr);\r\nif (nand_check_wp(mtd)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",\r\n__func__);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = __nand_unlock(mtd, ofs, len, 0);\r\nout:\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nint nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nint ret = 0;\r\nint chipnr, status, page;\r\nstruct nand_chip *chip = mtd->priv;\r\nDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",\r\n__func__, (unsigned long long)ofs, len);\r\nif (check_offs_len(mtd, ofs, len))\r\nret = -EINVAL;\r\nnand_get_device(chip, mtd, FL_LOCKING);\r\nchipnr = ofs >> chip->chip_shift;\r\nchip->select_chip(mtd, chipnr);\r\nif (nand_check_wp(mtd)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",\r\n__func__);\r\nstatus = MTD_ERASE_FAILED;\r\nret = -EIO;\r\ngoto out;\r\n}\r\npage = ofs >> chip->page_shift;\r\nchip->cmdfunc(mtd, NAND_CMD_LOCK, -1, page & chip->pagemask);\r\nstatus = chip->waitfunc(mtd, chip);\r\nudelay(1000);\r\nif (status & 0x01) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Error status = 0x%08x\n",\r\n__func__, status);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = __nand_unlock(mtd, ofs, len, 0x1);\r\nout:\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int page)\r\n{\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int nand_read_page_raw_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nuint8_t *buf, int page)\r\n{\r\nint eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nuint8_t *oob = chip->oob_poi;\r\nint steps, size;\r\nfor (steps = chip->ecc.steps; steps > 0; steps--) {\r\nchip->read_buf(mtd, buf, eccsize);\r\nbuf += eccsize;\r\nif (chip->ecc.prepad) {\r\nchip->read_buf(mtd, oob, chip->ecc.prepad);\r\noob += chip->ecc.prepad;\r\n}\r\nchip->read_buf(mtd, oob, eccbytes);\r\noob += eccbytes;\r\nif (chip->ecc.postpad) {\r\nchip->read_buf(mtd, oob, chip->ecc.postpad);\r\noob += chip->ecc.postpad;\r\n}\r\n}\r\nsize = mtd->oobsize - (oob - chip->oob_poi);\r\nif (size)\r\nchip->read_buf(mtd, oob, size);\r\nreturn 0;\r\n}\r\nstatic int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nchip->ecc.read_page_raw(mtd, chip, buf, page);\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\necc_code[i] = chip->oob_poi[eccpos[i]];\r\neccsteps = chip->ecc.steps;\r\np = buf;\r\nfor (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nint stat;\r\nstat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);\r\nif (stat < 0)\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += stat;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)\r\n{\r\nint start_step, end_step, num_steps;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *p;\r\nint data_col_addr, i, gaps = 0;\r\nint datafrag_len, eccfrag_len, aligned_len, aligned_pos;\r\nint busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;\r\nint index = 0;\r\nstart_step = data_offs / chip->ecc.size;\r\nend_step = (data_offs + readlen - 1) / chip->ecc.size;\r\nnum_steps = end_step - start_step + 1;\r\ndatafrag_len = num_steps * chip->ecc.size;\r\neccfrag_len = num_steps * chip->ecc.bytes;\r\ndata_col_addr = start_step * chip->ecc.size;\r\nif (data_col_addr != 0)\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);\r\np = bufpoi + data_col_addr;\r\nchip->read_buf(mtd, p, datafrag_len);\r\nfor (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)\r\nchip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);\r\nfor (i = 0; i < eccfrag_len - 1; i++) {\r\nif (eccpos[i + start_step * chip->ecc.bytes] + 1 !=\r\neccpos[i + start_step * chip->ecc.bytes + 1]) {\r\ngaps = 1;\r\nbreak;\r\n}\r\n}\r\nif (gaps) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\n} else {\r\nindex = start_step * chip->ecc.bytes;\r\naligned_pos = eccpos[index] & ~(busw - 1);\r\naligned_len = eccfrag_len;\r\nif (eccpos[index] & (busw - 1))\r\naligned_len++;\r\nif (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))\r\naligned_len++;\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT,\r\nmtd->writesize + aligned_pos, -1);\r\nchip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);\r\n}\r\nfor (i = 0; i < eccfrag_len; i++)\r\nchip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];\r\np = bufpoi + data_col_addr;\r\nfor (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {\r\nint stat;\r\nstat = chip->ecc.correct(mtd, p,\r\n&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);\r\nif (stat < 0)\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += stat;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, p, eccsize);\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\n}\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\necc_code[i] = chip->oob_poi[eccpos[i]];\r\neccsteps = chip->ecc.steps;\r\np = buf;\r\nfor (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nint stat;\r\nstat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);\r\nif (stat < 0)\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += stat;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\necc_code[i] = chip->oob_poi[eccpos[i]];\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nint stat;\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, p, eccsize);\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\nstat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);\r\nif (stat < 0)\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += stat;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nuint8_t *oob = chip->oob_poi;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nint stat;\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, p, eccsize);\r\nif (chip->ecc.prepad) {\r\nchip->read_buf(mtd, oob, chip->ecc.prepad);\r\noob += chip->ecc.prepad;\r\n}\r\nchip->ecc.hwctl(mtd, NAND_ECC_READSYN);\r\nchip->read_buf(mtd, oob, eccbytes);\r\nstat = chip->ecc.correct(mtd, p, oob, NULL);\r\nif (stat < 0)\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += stat;\r\noob += eccbytes;\r\nif (chip->ecc.postpad) {\r\nchip->read_buf(mtd, oob, chip->ecc.postpad);\r\noob += chip->ecc.postpad;\r\n}\r\n}\r\ni = mtd->oobsize - (oob - chip->oob_poi);\r\nif (i)\r\nchip->read_buf(mtd, oob, i);\r\nreturn 0;\r\n}\r\nstatic uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,\r\nstruct mtd_oob_ops *ops, size_t len)\r\n{\r\nswitch (ops->mode) {\r\ncase MTD_OOB_PLACE:\r\ncase MTD_OOB_RAW:\r\nmemcpy(oob, chip->oob_poi + ops->ooboffs, len);\r\nreturn oob + len;\r\ncase MTD_OOB_AUTO: {\r\nstruct nand_oobfree *free = chip->ecc.layout->oobfree;\r\nuint32_t boffs = 0, roffs = ops->ooboffs;\r\nsize_t bytes = 0;\r\nfor (; free->length && len; free++, len -= bytes) {\r\nif (unlikely(roffs)) {\r\nif (roffs >= free->length) {\r\nroffs -= free->length;\r\ncontinue;\r\n}\r\nboffs = free->offset + roffs;\r\nbytes = min_t(size_t, len,\r\n(free->length - roffs));\r\nroffs = 0;\r\n} else {\r\nbytes = min_t(size_t, len, free->length);\r\nboffs = free->offset;\r\n}\r\nmemcpy(oob, chip->oob_poi + boffs, bytes);\r\noob += bytes;\r\n}\r\nreturn oob;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}\r\nstatic int nand_do_read_ops(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint chipnr, page, realpage, col, bytes, aligned;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mtd_ecc_stats stats;\r\nint blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;\r\nint sndcmd = 1;\r\nint ret = 0;\r\nuint32_t readlen = ops->len;\r\nuint32_t oobreadlen = ops->ooblen;\r\nuint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?\r\nmtd->oobavail : mtd->oobsize;\r\nuint8_t *bufpoi, *oob, *buf;\r\nstats = mtd->ecc_stats;\r\nchipnr = (int)(from >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\nrealpage = (int)(from >> chip->page_shift);\r\npage = realpage & chip->pagemask;\r\ncol = (int)(from & (mtd->writesize - 1));\r\nbuf = ops->datbuf;\r\noob = ops->oobbuf;\r\nwhile (1) {\r\nbytes = min(mtd->writesize - col, readlen);\r\naligned = (bytes == mtd->writesize);\r\nif (realpage != chip->pagebuf || oob) {\r\nbufpoi = aligned ? buf : chip->buffers->databuf;\r\nif (likely(sndcmd)) {\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);\r\nsndcmd = 0;\r\n}\r\nif (unlikely(ops->mode == MTD_OOB_RAW))\r\nret = chip->ecc.read_page_raw(mtd, chip,\r\nbufpoi, page);\r\nelse if (!aligned && NAND_SUBPAGE_READ(chip) && !oob)\r\nret = chip->ecc.read_subpage(mtd, chip,\r\ncol, bytes, bufpoi);\r\nelse\r\nret = chip->ecc.read_page(mtd, chip, bufpoi,\r\npage);\r\nif (ret < 0)\r\nbreak;\r\nif (!aligned) {\r\nif (!NAND_SUBPAGE_READ(chip) && !oob &&\r\n!(mtd->ecc_stats.failed - stats.failed))\r\nchip->pagebuf = realpage;\r\nmemcpy(buf, chip->buffers->databuf + col, bytes);\r\n}\r\nbuf += bytes;\r\nif (unlikely(oob)) {\r\nint toread = min(oobreadlen, max_oobsize);\r\nif (toread) {\r\noob = nand_transfer_oob(chip,\r\noob, ops, toread);\r\noobreadlen -= toread;\r\n}\r\n}\r\nif (!(chip->options & NAND_NO_READRDY)) {\r\nif (!chip->dev_ready)\r\nudelay(chip->chip_delay);\r\nelse\r\nnand_wait_ready(mtd);\r\n}\r\n} else {\r\nmemcpy(buf, chip->buffers->databuf + col, bytes);\r\nbuf += bytes;\r\n}\r\nreadlen -= bytes;\r\nif (!readlen)\r\nbreak;\r\ncol = 0;\r\nrealpage++;\r\npage = realpage & chip->pagemask;\r\nif (!page) {\r\nchipnr++;\r\nchip->select_chip(mtd, -1);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\nif (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))\r\nsndcmd = 1;\r\n}\r\nops->retlen = ops->len - (size_t) readlen;\r\nif (oob)\r\nops->oobretlen = ops->ooblen - oobreadlen;\r\nif (ret)\r\nreturn ret;\r\nif (mtd->ecc_stats.failed - stats.failed)\r\nreturn -EBADMSG;\r\nreturn mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;\r\n}\r\nstatic int nand_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, uint8_t *buf)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret;\r\nif ((from + len) > mtd->size)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\nnand_get_device(chip, mtd, FL_READING);\r\nchip->ops.len = len;\r\nchip->ops.datbuf = buf;\r\nchip->ops.oobbuf = NULL;\r\nret = nand_do_read_ops(mtd, from, &chip->ops);\r\n*retlen = chip->ops.retlen;\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page, int sndcmd)\r\n{\r\nif (sndcmd) {\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);\r\nsndcmd = 0;\r\n}\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn sndcmd;\r\n}\r\nstatic int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page, int sndcmd)\r\n{\r\nuint8_t *buf = chip->oob_poi;\r\nint length = mtd->oobsize;\r\nint chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;\r\nint eccsize = chip->ecc.size;\r\nuint8_t *bufpoi = buf;\r\nint i, toread, sndrnd = 0, pos;\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\nif (sndrnd) {\r\npos = eccsize + i * (eccsize + chunk);\r\nif (mtd->writesize > 512)\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);\r\nelse\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);\r\n} else\r\nsndrnd = 1;\r\ntoread = min_t(int, length, chunk);\r\nchip->read_buf(mtd, bufpoi, toread);\r\nbufpoi += toread;\r\nlength -= toread;\r\n}\r\nif (length > 0)\r\nchip->read_buf(mtd, bufpoi, length);\r\nreturn 1;\r\n}\r\nstatic int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nint status = 0;\r\nconst uint8_t *buf = chip->oob_poi;\r\nint length = mtd->oobsize;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);\r\nchip->write_buf(mtd, buf, length);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic int nand_write_oob_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip, int page)\r\n{\r\nint chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;\r\nint eccsize = chip->ecc.size, length = mtd->oobsize;\r\nint i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;\r\nconst uint8_t *bufpoi = chip->oob_poi;\r\nif (!chip->ecc.prepad && !chip->ecc.postpad) {\r\npos = steps * (eccsize + chunk);\r\nsteps = 0;\r\n} else\r\npos = eccsize;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);\r\nfor (i = 0; i < steps; i++) {\r\nif (sndcmd) {\r\nif (mtd->writesize <= 512) {\r\nuint32_t fill = 0xFFFFFFFF;\r\nlen = eccsize;\r\nwhile (len > 0) {\r\nint num = min_t(int, len, 4);\r\nchip->write_buf(mtd, (uint8_t *)&fill,\r\nnum);\r\nlen -= num;\r\n}\r\n} else {\r\npos = eccsize + i * (eccsize + chunk);\r\nchip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);\r\n}\r\n} else\r\nsndcmd = 1;\r\nlen = min_t(int, length, chunk);\r\nchip->write_buf(mtd, bufpoi, len);\r\nbufpoi += len;\r\nlength -= len;\r\n}\r\nif (length > 0)\r\nchip->write_buf(mtd, bufpoi, length);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic int nand_do_read_oob(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint page, realpage, chipnr, sndcmd = 1;\r\nstruct nand_chip *chip = mtd->priv;\r\nint blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;\r\nint readlen = ops->ooblen;\r\nint len;\r\nuint8_t *buf = ops->oobbuf;\r\nDEBUG(MTD_DEBUG_LEVEL3, "%s: from = 0x%08Lx, len = %i\n",\r\n__func__, (unsigned long long)from, readlen);\r\nif (ops->mode == MTD_OOB_AUTO)\r\nlen = chip->ecc.layout->oobavail;\r\nelse\r\nlen = mtd->oobsize;\r\nif (unlikely(ops->ooboffs >= len)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to start read "\r\n"outside oob\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(from >= mtd->size ||\r\nops->ooboffs + readlen > ((mtd->size >> chip->page_shift) -\r\n(from >> chip->page_shift)) * len)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read beyond end "\r\n"of device\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nchipnr = (int)(from >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\nrealpage = (int)(from >> chip->page_shift);\r\npage = realpage & chip->pagemask;\r\nwhile (1) {\r\nsndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);\r\nlen = min(len, readlen);\r\nbuf = nand_transfer_oob(chip, buf, ops, len);\r\nif (!(chip->options & NAND_NO_READRDY)) {\r\nif (!chip->dev_ready)\r\nudelay(chip->chip_delay);\r\nelse\r\nnand_wait_ready(mtd);\r\n}\r\nreadlen -= len;\r\nif (!readlen)\r\nbreak;\r\nrealpage++;\r\npage = realpage & chip->pagemask;\r\nif (!page) {\r\nchipnr++;\r\nchip->select_chip(mtd, -1);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\nif (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))\r\nsndcmd = 1;\r\n}\r\nops->oobretlen = ops->ooblen;\r\nreturn 0;\r\n}\r\nstatic int nand_read_oob(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret = -ENOTSUPP;\r\nops->retlen = 0;\r\nif (ops->datbuf && (from + ops->len) > mtd->size) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read "\r\n"beyond end of device\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nnand_get_device(chip, mtd, FL_READING);\r\nswitch (ops->mode) {\r\ncase MTD_OOB_PLACE:\r\ncase MTD_OOB_AUTO:\r\ncase MTD_OOB_RAW:\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nif (!ops->datbuf)\r\nret = nand_do_read_oob(mtd, from, ops);\r\nelse\r\nret = nand_do_read_ops(mtd, from, ops);\r\nout:\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic void nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf)\r\n{\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\n}\r\nstatic void nand_write_page_raw_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf)\r\n{\r\nint eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nuint8_t *oob = chip->oob_poi;\r\nint steps, size;\r\nfor (steps = chip->ecc.steps; steps > 0; steps--) {\r\nchip->write_buf(mtd, buf, eccsize);\r\nbuf += eccsize;\r\nif (chip->ecc.prepad) {\r\nchip->write_buf(mtd, oob, chip->ecc.prepad);\r\noob += chip->ecc.prepad;\r\n}\r\nchip->read_buf(mtd, oob, eccbytes);\r\noob += eccbytes;\r\nif (chip->ecc.postpad) {\r\nchip->write_buf(mtd, oob, chip->ecc.postpad);\r\noob += chip->ecc.postpad;\r\n}\r\n}\r\nsize = mtd->oobsize - (oob - chip->oob_poi);\r\nif (size)\r\nchip->write_buf(mtd, oob, size);\r\n}\r\nstatic void nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nconst uint8_t *p = buf;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\nchip->oob_poi[eccpos[i]] = ecc_calc[i];\r\nchip->ecc.write_page_raw(mtd, chip, buf);\r\n}\r\nstatic void nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nconst uint8_t *p = buf;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nchip->ecc.hwctl(mtd, NAND_ECC_WRITE);\r\nchip->write_buf(mtd, p, eccsize);\r\nchip->ecc.calculate(mtd, p, &ecc_calc[i]);\r\n}\r\nfor (i = 0; i < chip->ecc.total; i++)\r\nchip->oob_poi[eccpos[i]] = ecc_calc[i];\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\n}\r\nstatic void nand_write_page_syndrome(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nconst uint8_t *p = buf;\r\nuint8_t *oob = chip->oob_poi;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nchip->ecc.hwctl(mtd, NAND_ECC_WRITE);\r\nchip->write_buf(mtd, p, eccsize);\r\nif (chip->ecc.prepad) {\r\nchip->write_buf(mtd, oob, chip->ecc.prepad);\r\noob += chip->ecc.prepad;\r\n}\r\nchip->ecc.calculate(mtd, p, oob);\r\nchip->write_buf(mtd, oob, eccbytes);\r\noob += eccbytes;\r\nif (chip->ecc.postpad) {\r\nchip->write_buf(mtd, oob, chip->ecc.postpad);\r\noob += chip->ecc.postpad;\r\n}\r\n}\r\ni = mtd->oobsize - (oob - chip->oob_poi);\r\nif (i)\r\nchip->write_buf(mtd, oob, i);\r\n}\r\nstatic int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int page, int cached, int raw)\r\n{\r\nint status;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);\r\nif (unlikely(raw))\r\nchip->ecc.write_page_raw(mtd, chip, buf);\r\nelse\r\nchip->ecc.write_page(mtd, chip, buf);\r\ncached = 0;\r\nif (!cached || !(chip->options & NAND_CACHEPRG)) {\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif ((status & NAND_STATUS_FAIL) && (chip->errstat))\r\nstatus = chip->errstat(mtd, chip, FL_WRITING, status,\r\npage);\r\nif (status & NAND_STATUS_FAIL)\r\nreturn -EIO;\r\n} else {\r\nchip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\n}\r\n#ifdef CONFIG_MTD_NAND_VERIFY_WRITE\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nif (chip->verify_buf(mtd, buf, mtd->writesize))\r\nreturn -EIO;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nswitch (ops->mode) {\r\ncase MTD_OOB_PLACE:\r\ncase MTD_OOB_RAW:\r\nmemcpy(chip->oob_poi + ops->ooboffs, oob, len);\r\nreturn oob + len;\r\ncase MTD_OOB_AUTO: {\r\nstruct nand_oobfree *free = chip->ecc.layout->oobfree;\r\nuint32_t boffs = 0, woffs = ops->ooboffs;\r\nsize_t bytes = 0;\r\nfor (; free->length && len; free++, len -= bytes) {\r\nif (unlikely(woffs)) {\r\nif (woffs >= free->length) {\r\nwoffs -= free->length;\r\ncontinue;\r\n}\r\nboffs = free->offset + woffs;\r\nbytes = min_t(size_t, len,\r\n(free->length - woffs));\r\nwoffs = 0;\r\n} else {\r\nbytes = min_t(size_t, len, free->length);\r\nboffs = free->offset;\r\n}\r\nmemcpy(chip->oob_poi + boffs, oob, bytes);\r\noob += bytes;\r\n}\r\nreturn oob;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}\r\nstatic int nand_do_write_ops(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint chipnr, realpage, page, blockmask, column;\r\nstruct nand_chip *chip = mtd->priv;\r\nuint32_t writelen = ops->len;\r\nuint32_t oobwritelen = ops->ooblen;\r\nuint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?\r\nmtd->oobavail : mtd->oobsize;\r\nuint8_t *oob = ops->oobbuf;\r\nuint8_t *buf = ops->datbuf;\r\nint ret, subpage;\r\nops->retlen = 0;\r\nif (!writelen)\r\nreturn 0;\r\nif (NOTALIGNED(to) || NOTALIGNED(ops->len)) {\r\nprintk(KERN_NOTICE "%s: Attempt to write not "\r\n"page aligned data\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncolumn = to & (mtd->writesize - 1);\r\nsubpage = column || (writelen & (mtd->writesize - 1));\r\nif (subpage && oob)\r\nreturn -EINVAL;\r\nchipnr = (int)(to >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\nif (nand_check_wp(mtd))\r\nreturn -EIO;\r\nrealpage = (int)(to >> chip->page_shift);\r\npage = realpage & chip->pagemask;\r\nblockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;\r\nif (to <= (chip->pagebuf << chip->page_shift) &&\r\n(chip->pagebuf << chip->page_shift) < (to + ops->len))\r\nchip->pagebuf = -1;\r\nif (likely(!oob))\r\nmemset(chip->oob_poi, 0xff, mtd->oobsize);\r\nif (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen))\r\nreturn -EINVAL;\r\nwhile (1) {\r\nint bytes = mtd->writesize;\r\nint cached = writelen > bytes && page != blockmask;\r\nuint8_t *wbuf = buf;\r\nif (unlikely(column || writelen < (mtd->writesize - 1))) {\r\ncached = 0;\r\nbytes = min_t(int, bytes - column, (int) writelen);\r\nchip->pagebuf = -1;\r\nmemset(chip->buffers->databuf, 0xff, mtd->writesize);\r\nmemcpy(&chip->buffers->databuf[column], buf, bytes);\r\nwbuf = chip->buffers->databuf;\r\n}\r\nif (unlikely(oob)) {\r\nsize_t len = min(oobwritelen, oobmaxlen);\r\noob = nand_fill_oob(chip, oob, len, ops);\r\noobwritelen -= len;\r\n}\r\nret = chip->write_page(mtd, chip, wbuf, page, cached,\r\n(ops->mode == MTD_OOB_RAW));\r\nif (ret)\r\nbreak;\r\nwritelen -= bytes;\r\nif (!writelen)\r\nbreak;\r\ncolumn = 0;\r\nbuf += bytes;\r\nrealpage++;\r\npage = realpage & chip->pagemask;\r\nif (!page) {\r\nchipnr++;\r\nchip->select_chip(mtd, -1);\r\nchip->select_chip(mtd, chipnr);\r\n}\r\n}\r\nops->retlen = ops->len - writelen;\r\nif (unlikely(oob))\r\nops->oobretlen = ops->ooblen;\r\nreturn ret;\r\n}\r\nstatic int panic_nand_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const uint8_t *buf)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret;\r\nif ((to + len) > mtd->size)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\npanic_nand_wait(mtd, chip, 400);\r\npanic_nand_get_device(chip, mtd, FL_WRITING);\r\nchip->ops.len = len;\r\nchip->ops.datbuf = (uint8_t *)buf;\r\nchip->ops.oobbuf = NULL;\r\nret = nand_do_write_ops(mtd, to, &chip->ops);\r\n*retlen = chip->ops.retlen;\r\nreturn ret;\r\n}\r\nstatic int nand_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const uint8_t *buf)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret;\r\nif ((to + len) > mtd->size)\r\nreturn -EINVAL;\r\nif (!len)\r\nreturn 0;\r\nnand_get_device(chip, mtd, FL_WRITING);\r\nchip->ops.len = len;\r\nchip->ops.datbuf = (uint8_t *)buf;\r\nchip->ops.oobbuf = NULL;\r\nret = nand_do_write_ops(mtd, to, &chip->ops);\r\n*retlen = chip->ops.retlen;\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic int nand_do_write_oob(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nint chipnr, page, status, len;\r\nstruct nand_chip *chip = mtd->priv;\r\nDEBUG(MTD_DEBUG_LEVEL3, "%s: to = 0x%08x, len = %i\n",\r\n__func__, (unsigned int)to, (int)ops->ooblen);\r\nif (ops->mode == MTD_OOB_AUTO)\r\nlen = chip->ecc.layout->oobavail;\r\nelse\r\nlen = mtd->oobsize;\r\nif ((ops->ooboffs + ops->ooblen) > len) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to write "\r\n"past end of page\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(ops->ooboffs >= len)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to start "\r\n"write outside oob\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(to >= mtd->size ||\r\nops->ooboffs + ops->ooblen >\r\n((mtd->size >> chip->page_shift) -\r\n(to >> chip->page_shift)) * len)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "\r\n"end of device\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nchipnr = (int)(to >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\npage = (int)(to >> chip->page_shift);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nif (nand_check_wp(mtd))\r\nreturn -EROFS;\r\nif (page == chip->pagebuf)\r\nchip->pagebuf = -1;\r\nmemset(chip->oob_poi, 0xff, mtd->oobsize);\r\nnand_fill_oob(chip, ops->oobbuf, ops->ooblen, ops);\r\nstatus = chip->ecc.write_oob(mtd, chip, page & chip->pagemask);\r\nmemset(chip->oob_poi, 0xff, mtd->oobsize);\r\nif (status)\r\nreturn status;\r\nops->oobretlen = ops->ooblen;\r\nreturn 0;\r\n}\r\nstatic int nand_write_oob(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret = -ENOTSUPP;\r\nops->retlen = 0;\r\nif (ops->datbuf && (to + ops->len) > mtd->size) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "\r\n"end of device\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nnand_get_device(chip, mtd, FL_WRITING);\r\nswitch (ops->mode) {\r\ncase MTD_OOB_PLACE:\r\ncase MTD_OOB_AUTO:\r\ncase MTD_OOB_RAW:\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nif (!ops->datbuf)\r\nret = nand_do_write_oob(mtd, to, ops);\r\nelse\r\nret = nand_do_write_ops(mtd, to, ops);\r\nout:\r\nnand_release_device(mtd);\r\nreturn ret;\r\n}\r\nstatic void single_erase_cmd(struct mtd_info *mtd, int page)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);\r\n}\r\nstatic void multi_erase_cmd(struct mtd_info *mtd, int page)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);\r\n}\r\nstatic int nand_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nreturn nand_erase_nand(mtd, instr, 0);\r\n}\r\nint nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,\r\nint allowbbt)\r\n{\r\nint page, status, pages_per_block, ret, chipnr;\r\nstruct nand_chip *chip = mtd->priv;\r\nloff_t rewrite_bbt[NAND_MAX_CHIPS] = {0};\r\nunsigned int bbt_masked_page = 0xffffffff;\r\nloff_t len;\r\nDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",\r\n__func__, (unsigned long long)instr->addr,\r\n(unsigned long long)instr->len);\r\nif (check_offs_len(mtd, instr->addr, instr->len))\r\nreturn -EINVAL;\r\ninstr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\r\nnand_get_device(chip, mtd, FL_ERASING);\r\npage = (int)(instr->addr >> chip->page_shift);\r\nchipnr = (int)(instr->addr >> chip->chip_shift);\r\npages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);\r\nchip->select_chip(mtd, chipnr);\r\nif (nand_check_wp(mtd)) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",\r\n__func__);\r\ninstr->state = MTD_ERASE_FAILED;\r\ngoto erase_exit;\r\n}\r\nif (chip->options & BBT_AUTO_REFRESH && !allowbbt)\r\nbbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;\r\nlen = instr->len;\r\ninstr->state = MTD_ERASING;\r\nwhile (len) {\r\nif (nand_block_checkbad(mtd, ((loff_t) page) <<\r\nchip->page_shift, 0, allowbbt)) {\r\nprintk(KERN_WARNING "%s: attempt to erase a bad block "\r\n"at page 0x%08x\n", __func__, page);\r\ninstr->state = MTD_ERASE_FAILED;\r\ngoto erase_exit;\r\n}\r\nif (page <= chip->pagebuf && chip->pagebuf <\r\n(page + pages_per_block))\r\nchip->pagebuf = -1;\r\nchip->erase_cmd(mtd, page & chip->pagemask);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif ((status & NAND_STATUS_FAIL) && (chip->errstat))\r\nstatus = chip->errstat(mtd, chip, FL_ERASING,\r\nstatus, page);\r\nif (status & NAND_STATUS_FAIL) {\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: Failed erase, "\r\n"page 0x%08x\n", __func__, page);\r\ninstr->state = MTD_ERASE_FAILED;\r\ninstr->fail_addr =\r\n((loff_t)page << chip->page_shift);\r\ngoto erase_exit;\r\n}\r\nif (bbt_masked_page != 0xffffffff &&\r\n(page & BBT_PAGE_MASK) == bbt_masked_page)\r\nrewrite_bbt[chipnr] =\r\n((loff_t)page << chip->page_shift);\r\nlen -= (1 << chip->phys_erase_shift);\r\npage += pages_per_block;\r\nif (len && !(page & chip->pagemask)) {\r\nchipnr++;\r\nchip->select_chip(mtd, -1);\r\nchip->select_chip(mtd, chipnr);\r\nif (bbt_masked_page != 0xffffffff &&\r\n(chip->bbt_td->options & NAND_BBT_PERCHIP))\r\nbbt_masked_page = chip->bbt_td->pages[chipnr] &\r\nBBT_PAGE_MASK;\r\n}\r\n}\r\ninstr->state = MTD_ERASE_DONE;\r\nerase_exit:\r\nret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;\r\nnand_release_device(mtd);\r\nif (!ret)\r\nmtd_erase_callback(instr);\r\nif (bbt_masked_page == 0xffffffff || ret)\r\nreturn ret;\r\nfor (chipnr = 0; chipnr < chip->numchips; chipnr++) {\r\nif (!rewrite_bbt[chipnr])\r\ncontinue;\r\nDEBUG(MTD_DEBUG_LEVEL0, "%s: nand_update_bbt "\r\n"(%d:0x%0llx 0x%0x)\n", __func__, chipnr,\r\nrewrite_bbt[chipnr], chip->bbt_td->pages[chipnr]);\r\nnand_update_bbt(mtd, rewrite_bbt[chipnr]);\r\n}\r\nreturn ret;\r\n}\r\nstatic void nand_sync(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nDEBUG(MTD_DEBUG_LEVEL3, "%s: called\n", __func__);\r\nnand_get_device(chip, mtd, FL_SYNCING);\r\nnand_release_device(mtd);\r\n}\r\nstatic int nand_block_isbad(struct mtd_info *mtd, loff_t offs)\r\n{\r\nif (offs > mtd->size)\r\nreturn -EINVAL;\r\nreturn nand_block_checkbad(mtd, offs, 1, 0);\r\n}\r\nstatic int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret;\r\nret = nand_block_isbad(mtd, ofs);\r\nif (ret) {\r\nif (ret > 0)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nreturn chip->block_markbad(mtd, ofs);\r\n}\r\nstatic int nand_suspend(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nreturn nand_get_device(chip, mtd, FL_PM_SUSPENDED);\r\n}\r\nstatic void nand_resume(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (chip->state == FL_PM_SUSPENDED)\r\nnand_release_device(mtd);\r\nelse\r\nprintk(KERN_ERR "%s called for a chip which is not "\r\n"in suspended state\n", __func__);\r\n}\r\nstatic void nand_set_defaults(struct nand_chip *chip, int busw)\r\n{\r\nif (!chip->chip_delay)\r\nchip->chip_delay = 20;\r\nif (chip->cmdfunc == NULL)\r\nchip->cmdfunc = nand_command;\r\nif (chip->waitfunc == NULL)\r\nchip->waitfunc = nand_wait;\r\nif (!chip->select_chip)\r\nchip->select_chip = nand_select_chip;\r\nif (!chip->read_byte)\r\nchip->read_byte = busw ? nand_read_byte16 : nand_read_byte;\r\nif (!chip->read_word)\r\nchip->read_word = nand_read_word;\r\nif (!chip->block_bad)\r\nchip->block_bad = nand_block_bad;\r\nif (!chip->block_markbad)\r\nchip->block_markbad = nand_default_block_markbad;\r\nif (!chip->write_buf)\r\nchip->write_buf = busw ? nand_write_buf16 : nand_write_buf;\r\nif (!chip->read_buf)\r\nchip->read_buf = busw ? nand_read_buf16 : nand_read_buf;\r\nif (!chip->verify_buf)\r\nchip->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;\r\nif (!chip->scan_bbt)\r\nchip->scan_bbt = nand_default_bbt;\r\nif (!chip->controller) {\r\nchip->controller = &chip->hwcontrol;\r\nspin_lock_init(&chip->controller->lock);\r\ninit_waitqueue_head(&chip->controller->wq);\r\n}\r\n}\r\nstatic void sanitize_string(uint8_t *s, size_t len)\r\n{\r\nssize_t i;\r\ns[len - 1] = 0;\r\nfor (i = 0; i < len - 1; i++) {\r\nif (s[i] < ' ' || s[i] > 127)\r\ns[i] = '?';\r\n}\r\nstrim(s);\r\n}\r\nstatic u16 onfi_crc16(u16 crc, u8 const *p, size_t len)\r\n{\r\nint i;\r\nwhile (len--) {\r\ncrc ^= *p++ << 8;\r\nfor (i = 0; i < 8; i++)\r\ncrc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);\r\n}\r\nreturn crc;\r\n}\r\nstatic int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,\r\nint busw)\r\n{\r\nstruct nand_onfi_params *p = &chip->onfi_params;\r\nint i;\r\nint val;\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);\r\nif (chip->read_byte(mtd) != 'O' || chip->read_byte(mtd) != 'N' ||\r\nchip->read_byte(mtd) != 'F' || chip->read_byte(mtd) != 'I')\r\nreturn 0;\r\nprintk(KERN_INFO "ONFI flash detected\n");\r\nchip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);\r\nfor (i = 0; i < 3; i++) {\r\nchip->read_buf(mtd, (uint8_t *)p, sizeof(*p));\r\nif (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 254) ==\r\nle16_to_cpu(p->crc)) {\r\nprintk(KERN_INFO "ONFI param page %d valid\n", i);\r\nbreak;\r\n}\r\n}\r\nif (i == 3)\r\nreturn 0;\r\nval = le16_to_cpu(p->revision);\r\nif (val & (1 << 5))\r\nchip->onfi_version = 23;\r\nelse if (val & (1 << 4))\r\nchip->onfi_version = 22;\r\nelse if (val & (1 << 3))\r\nchip->onfi_version = 21;\r\nelse if (val & (1 << 2))\r\nchip->onfi_version = 20;\r\nelse if (val & (1 << 1))\r\nchip->onfi_version = 10;\r\nelse\r\nchip->onfi_version = 0;\r\nif (!chip->onfi_version) {\r\nprintk(KERN_INFO "%s: unsupported ONFI version: %d\n",\r\n__func__, val);\r\nreturn 0;\r\n}\r\nsanitize_string(p->manufacturer, sizeof(p->manufacturer));\r\nsanitize_string(p->model, sizeof(p->model));\r\nif (!mtd->name)\r\nmtd->name = p->model;\r\nmtd->writesize = le32_to_cpu(p->byte_per_page);\r\nmtd->erasesize = le32_to_cpu(p->pages_per_block) * mtd->writesize;\r\nmtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);\r\nchip->chipsize = (uint64_t)le32_to_cpu(p->blocks_per_lun) * mtd->erasesize;\r\nbusw = 0;\r\nif (le16_to_cpu(p->features) & 1)\r\nbusw = NAND_BUSWIDTH_16;\r\nchip->options &= ~NAND_CHIPOPTIONS_MSK;\r\nchip->options |= (NAND_NO_READRDY |\r\nNAND_NO_AUTOINCR) & NAND_CHIPOPTIONS_MSK;\r\nreturn 1;\r\n}\r\nstatic struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nint busw,\r\nint *maf_id, int *dev_id,\r\nstruct nand_flash_dev *type)\r\n{\r\nint i, maf_idx;\r\nu8 id_data[8];\r\nint ret;\r\nchip->select_chip(mtd, 0);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\n*maf_id = chip->read_byte(mtd);\r\n*dev_id = chip->read_byte(mtd);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\nfor (i = 0; i < 2; i++)\r\nid_data[i] = chip->read_byte(mtd);\r\nif (id_data[0] != *maf_id || id_data[1] != *dev_id) {\r\nprintk(KERN_INFO "%s: second ID read did not match "\r\n"%02x,%02x against %02x,%02x\n", __func__,\r\n*maf_id, *dev_id, id_data[0], id_data[1]);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (!type)\r\ntype = nand_flash_ids;\r\nfor (; type->name != NULL; type++)\r\nif (*dev_id == type->id)\r\nbreak;\r\nchip->onfi_version = 0;\r\nif (!type->name || !type->pagesize) {\r\nret = nand_flash_detect_onfi(mtd, chip, busw);\r\nif (ret)\r\ngoto ident_done;\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\nfor (i = 0; i < 8; i++)\r\nid_data[i] = chip->read_byte(mtd);\r\nif (!type->name)\r\nreturn ERR_PTR(-ENODEV);\r\nif (!mtd->name)\r\nmtd->name = type->name;\r\nchip->chipsize = (uint64_t)type->chipsize << 20;\r\nif (!type->pagesize && chip->init_size) {\r\nbusw = chip->init_size(mtd, chip, id_data);\r\n} else if (!type->pagesize) {\r\nint extid;\r\nchip->cellinfo = id_data[2];\r\nextid = id_data[3];\r\nif (id_data[0] == id_data[6] && id_data[1] == id_data[7] &&\r\nid_data[0] == NAND_MFR_SAMSUNG &&\r\n(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&\r\nid_data[5] != 0x00) {\r\nmtd->writesize = 2048 << (extid & 0x03);\r\nextid >>= 2;\r\nswitch (extid & 0x03) {\r\ncase 1:\r\nmtd->oobsize = 128;\r\nbreak;\r\ncase 2:\r\nmtd->oobsize = 218;\r\nbreak;\r\ncase 3:\r\nmtd->oobsize = 400;\r\nbreak;\r\ndefault:\r\nmtd->oobsize = 436;\r\nbreak;\r\n}\r\nextid >>= 2;\r\nmtd->erasesize = (128 * 1024) <<\r\n(((extid >> 1) & 0x04) | (extid & 0x03));\r\nbusw = 0;\r\n} else {\r\nmtd->writesize = 1024 << (extid & 0x03);\r\nextid >>= 2;\r\nmtd->oobsize = (8 << (extid & 0x01)) *\r\n(mtd->writesize >> 9);\r\nextid >>= 2;\r\nmtd->erasesize = (64 * 1024) << (extid & 0x03);\r\nextid >>= 2;\r\nbusw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;\r\n}\r\n} else {\r\nmtd->erasesize = type->erasesize;\r\nmtd->writesize = type->pagesize;\r\nmtd->oobsize = mtd->writesize / 32;\r\nbusw = type->options & NAND_BUSWIDTH_16;\r\nif (*maf_id == NAND_MFR_AMD && id_data[4] != 0x00 &&\r\nid_data[5] == 0x00 && id_data[6] == 0x00 &&\r\nid_data[7] == 0x00 && mtd->writesize == 512) {\r\nmtd->erasesize = 128 * 1024;\r\nmtd->erasesize <<= ((id_data[3] & 0x03) << 1);\r\n}\r\n}\r\nchip->options &= ~NAND_CHIPOPTIONS_MSK;\r\nchip->options |= type->options & NAND_CHIPOPTIONS_MSK;\r\nif (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)\r\nchip->options &= ~NAND_SAMSUNG_LP_OPTIONS;\r\nident_done:\r\nchip->options |= NAND_NO_AUTOINCR;\r\nfor (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {\r\nif (nand_manuf_ids[maf_idx].id == *maf_id)\r\nbreak;\r\n}\r\nif (busw != (chip->options & NAND_BUSWIDTH_16)) {\r\nprintk(KERN_INFO "NAND device: Manufacturer ID:"\r\n" 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,\r\n*dev_id, nand_manuf_ids[maf_idx].name, mtd->name);\r\nprintk(KERN_WARNING "NAND bus width %d instead %d bit\n",\r\n(chip->options & NAND_BUSWIDTH_16) ? 16 : 8,\r\nbusw ? 16 : 8);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nchip->page_shift = ffs(mtd->writesize) - 1;\r\nchip->pagemask = (chip->chipsize >> chip->page_shift) - 1;\r\nchip->bbt_erase_shift = chip->phys_erase_shift =\r\nffs(mtd->erasesize) - 1;\r\nif (chip->chipsize & 0xffffffff)\r\nchip->chip_shift = ffs((unsigned)chip->chipsize) - 1;\r\nelse {\r\nchip->chip_shift = ffs((unsigned)(chip->chipsize >> 32));\r\nchip->chip_shift += 32 - 1;\r\n}\r\nchip->badblockbits = 8;\r\nif (mtd->writesize > 512 || (busw & NAND_BUSWIDTH_16))\r\nchip->badblockpos = NAND_LARGE_BADBLOCK_POS;\r\nelse\r\nchip->badblockpos = NAND_SMALL_BADBLOCK_POS;\r\nif ((chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&\r\n(*maf_id == NAND_MFR_SAMSUNG ||\r\n*maf_id == NAND_MFR_HYNIX))\r\nchip->options |= NAND_BBT_SCANLASTPAGE;\r\nelse if ((!(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&\r\n(*maf_id == NAND_MFR_SAMSUNG ||\r\n*maf_id == NAND_MFR_HYNIX ||\r\n*maf_id == NAND_MFR_TOSHIBA ||\r\n*maf_id == NAND_MFR_AMD)) ||\r\n(mtd->writesize == 2048 &&\r\n*maf_id == NAND_MFR_MICRON))\r\nchip->options |= NAND_BBT_SCAN2NDPAGE;\r\nif (!(busw & NAND_BUSWIDTH_16) &&\r\n*maf_id == NAND_MFR_STMICRO &&\r\nmtd->writesize == 2048) {\r\nchip->options |= NAND_BBT_SCANBYTE1AND6;\r\nchip->badblockpos = 0;\r\n}\r\nif (chip->options & NAND_4PAGE_ARRAY)\r\nchip->erase_cmd = multi_erase_cmd;\r\nelse\r\nchip->erase_cmd = single_erase_cmd;\r\nif (mtd->writesize > 512 && chip->cmdfunc == nand_command)\r\nchip->cmdfunc = nand_command_lp;\r\nprintk(KERN_INFO "NAND device: Manufacturer ID:"\r\n" 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, *dev_id,\r\nnand_manuf_ids[maf_idx].name,\r\nchip->onfi_version ? chip->onfi_params.model : type->name);\r\nreturn type;\r\n}\r\nint nand_scan_ident(struct mtd_info *mtd, int maxchips,\r\nstruct nand_flash_dev *table)\r\n{\r\nint i, busw, nand_maf_id, nand_dev_id;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct nand_flash_dev *type;\r\nbusw = chip->options & NAND_BUSWIDTH_16;\r\nnand_set_defaults(chip, busw);\r\ntype = nand_get_flash_type(mtd, chip, busw,\r\n&nand_maf_id, &nand_dev_id, table);\r\nif (IS_ERR(type)) {\r\nif (!(chip->options & NAND_SCAN_SILENT_NODEV))\r\nprintk(KERN_WARNING "No NAND device found.\n");\r\nchip->select_chip(mtd, -1);\r\nreturn PTR_ERR(type);\r\n}\r\nfor (i = 1; i < maxchips; i++) {\r\nchip->select_chip(mtd, i);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\nif (nand_maf_id != chip->read_byte(mtd) ||\r\nnand_dev_id != chip->read_byte(mtd))\r\nbreak;\r\n}\r\nif (i > 1)\r\nprintk(KERN_INFO "%d NAND chips detected\n", i);\r\nchip->numchips = i;\r\nmtd->size = i * chip->chipsize;\r\nreturn 0;\r\n}\r\nint nand_scan_tail(struct mtd_info *mtd)\r\n{\r\nint i;\r\nstruct nand_chip *chip = mtd->priv;\r\nif (!(chip->options & NAND_OWN_BUFFERS))\r\nchip->buffers = kmalloc(sizeof(*chip->buffers), GFP_KERNEL);\r\nif (!chip->buffers)\r\nreturn -ENOMEM;\r\nchip->oob_poi = chip->buffers->databuf + mtd->writesize;\r\nif (!chip->ecc.layout && (chip->ecc.mode != NAND_ECC_SOFT_BCH)) {\r\nswitch (mtd->oobsize) {\r\ncase 8:\r\nchip->ecc.layout = &nand_oob_8;\r\nbreak;\r\ncase 16:\r\nchip->ecc.layout = &nand_oob_16;\r\nbreak;\r\ncase 64:\r\nchip->ecc.layout = &nand_oob_64;\r\nbreak;\r\ncase 128:\r\nchip->ecc.layout = &nand_oob_128;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "No oob scheme defined for "\r\n"oobsize %d\n", mtd->oobsize);\r\nBUG();\r\n}\r\n}\r\nif (!chip->write_page)\r\nchip->write_page = nand_write_page;\r\nswitch (chip->ecc.mode) {\r\ncase NAND_ECC_HW_OOB_FIRST:\r\nif (!chip->ecc.calculate || !chip->ecc.correct ||\r\n!chip->ecc.hwctl) {\r\nprintk(KERN_WARNING "No ECC functions supplied; "\r\n"Hardware ECC not possible\n");\r\nBUG();\r\n}\r\nif (!chip->ecc.read_page)\r\nchip->ecc.read_page = nand_read_page_hwecc_oob_first;\r\ncase NAND_ECC_HW:\r\nif (!chip->ecc.read_page)\r\nchip->ecc.read_page = nand_read_page_hwecc;\r\nif (!chip->ecc.write_page)\r\nchip->ecc.write_page = nand_write_page_hwecc;\r\nif (!chip->ecc.read_page_raw)\r\nchip->ecc.read_page_raw = nand_read_page_raw;\r\nif (!chip->ecc.write_page_raw)\r\nchip->ecc.write_page_raw = nand_write_page_raw;\r\nif (!chip->ecc.read_oob)\r\nchip->ecc.read_oob = nand_read_oob_std;\r\nif (!chip->ecc.write_oob)\r\nchip->ecc.write_oob = nand_write_oob_std;\r\ncase NAND_ECC_HW_SYNDROME:\r\nif ((!chip->ecc.calculate || !chip->ecc.correct ||\r\n!chip->ecc.hwctl) &&\r\n(!chip->ecc.read_page ||\r\nchip->ecc.read_page == nand_read_page_hwecc ||\r\n!chip->ecc.write_page ||\r\nchip->ecc.write_page == nand_write_page_hwecc)) {\r\nprintk(KERN_WARNING "No ECC functions supplied; "\r\n"Hardware ECC not possible\n");\r\nBUG();\r\n}\r\nif (!chip->ecc.read_page)\r\nchip->ecc.read_page = nand_read_page_syndrome;\r\nif (!chip->ecc.write_page)\r\nchip->ecc.write_page = nand_write_page_syndrome;\r\nif (!chip->ecc.read_page_raw)\r\nchip->ecc.read_page_raw = nand_read_page_raw_syndrome;\r\nif (!chip->ecc.write_page_raw)\r\nchip->ecc.write_page_raw = nand_write_page_raw_syndrome;\r\nif (!chip->ecc.read_oob)\r\nchip->ecc.read_oob = nand_read_oob_syndrome;\r\nif (!chip->ecc.write_oob)\r\nchip->ecc.write_oob = nand_write_oob_syndrome;\r\nif (mtd->writesize >= chip->ecc.size)\r\nbreak;\r\nprintk(KERN_WARNING "%d byte HW ECC not possible on "\r\n"%d byte page size, fallback to SW ECC\n",\r\nchip->ecc.size, mtd->writesize);\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\ncase NAND_ECC_SOFT:\r\nchip->ecc.calculate = nand_calculate_ecc;\r\nchip->ecc.correct = nand_correct_data;\r\nchip->ecc.read_page = nand_read_page_swecc;\r\nchip->ecc.read_subpage = nand_read_subpage;\r\nchip->ecc.write_page = nand_write_page_swecc;\r\nchip->ecc.read_page_raw = nand_read_page_raw;\r\nchip->ecc.write_page_raw = nand_write_page_raw;\r\nchip->ecc.read_oob = nand_read_oob_std;\r\nchip->ecc.write_oob = nand_write_oob_std;\r\nif (!chip->ecc.size)\r\nchip->ecc.size = 256;\r\nchip->ecc.bytes = 3;\r\nbreak;\r\ncase NAND_ECC_SOFT_BCH:\r\nif (!mtd_nand_has_bch()) {\r\nprintk(KERN_WARNING "CONFIG_MTD_ECC_BCH not enabled\n");\r\nBUG();\r\n}\r\nchip->ecc.calculate = nand_bch_calculate_ecc;\r\nchip->ecc.correct = nand_bch_correct_data;\r\nchip->ecc.read_page = nand_read_page_swecc;\r\nchip->ecc.read_subpage = nand_read_subpage;\r\nchip->ecc.write_page = nand_write_page_swecc;\r\nchip->ecc.read_page_raw = nand_read_page_raw;\r\nchip->ecc.write_page_raw = nand_write_page_raw;\r\nchip->ecc.read_oob = nand_read_oob_std;\r\nchip->ecc.write_oob = nand_write_oob_std;\r\nif (!chip->ecc.size && (mtd->oobsize >= 64)) {\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 7;\r\n}\r\nchip->ecc.priv = nand_bch_init(mtd,\r\nchip->ecc.size,\r\nchip->ecc.bytes,\r\n&chip->ecc.layout);\r\nif (!chip->ecc.priv) {\r\nprintk(KERN_WARNING "BCH ECC initialization failed!\n");\r\nBUG();\r\n}\r\nbreak;\r\ncase NAND_ECC_NONE:\r\nprintk(KERN_WARNING "NAND_ECC_NONE selected by board driver. "\r\n"This is not recommended !!\n");\r\nchip->ecc.read_page = nand_read_page_raw;\r\nchip->ecc.write_page = nand_write_page_raw;\r\nchip->ecc.read_oob = nand_read_oob_std;\r\nchip->ecc.read_page_raw = nand_read_page_raw;\r\nchip->ecc.write_page_raw = nand_write_page_raw;\r\nchip->ecc.write_oob = nand_write_oob_std;\r\nchip->ecc.size = mtd->writesize;\r\nchip->ecc.bytes = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "Invalid NAND_ECC_MODE %d\n",\r\nchip->ecc.mode);\r\nBUG();\r\n}\r\nchip->ecc.layout->oobavail = 0;\r\nfor (i = 0; chip->ecc.layout->oobfree[i].length\r\n&& i < ARRAY_SIZE(chip->ecc.layout->oobfree); i++)\r\nchip->ecc.layout->oobavail +=\r\nchip->ecc.layout->oobfree[i].length;\r\nmtd->oobavail = chip->ecc.layout->oobavail;\r\nchip->ecc.steps = mtd->writesize / chip->ecc.size;\r\nif (chip->ecc.steps * chip->ecc.size != mtd->writesize) {\r\nprintk(KERN_WARNING "Invalid ecc parameters\n");\r\nBUG();\r\n}\r\nchip->ecc.total = chip->ecc.steps * chip->ecc.bytes;\r\nif (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&\r\n!(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {\r\nswitch (chip->ecc.steps) {\r\ncase 2:\r\nmtd->subpage_sft = 1;\r\nbreak;\r\ncase 4:\r\ncase 8:\r\ncase 16:\r\nmtd->subpage_sft = 2;\r\nbreak;\r\n}\r\n}\r\nchip->subpagesize = mtd->writesize >> mtd->subpage_sft;\r\nchip->state = FL_READY;\r\nchip->select_chip(mtd, -1);\r\nchip->pagebuf = -1;\r\nmtd->type = MTD_NANDFLASH;\r\nmtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :\r\nMTD_CAP_NANDFLASH;\r\nmtd->erase = nand_erase;\r\nmtd->point = NULL;\r\nmtd->unpoint = NULL;\r\nmtd->read = nand_read;\r\nmtd->write = nand_write;\r\nmtd->panic_write = panic_nand_write;\r\nmtd->read_oob = nand_read_oob;\r\nmtd->write_oob = nand_write_oob;\r\nmtd->sync = nand_sync;\r\nmtd->lock = NULL;\r\nmtd->unlock = NULL;\r\nmtd->suspend = nand_suspend;\r\nmtd->resume = nand_resume;\r\nmtd->block_isbad = nand_block_isbad;\r\nmtd->block_markbad = nand_block_markbad;\r\nmtd->writebufsize = mtd->writesize;\r\nmtd->ecclayout = chip->ecc.layout;\r\nif (chip->options & NAND_SKIP_BBTSCAN)\r\nreturn 0;\r\nreturn chip->scan_bbt(mtd);\r\n}\r\nint nand_scan(struct mtd_info *mtd, int maxchips)\r\n{\r\nint ret;\r\nif (!mtd->owner && caller_is_module()) {\r\nprintk(KERN_CRIT "%s called with NULL mtd->owner!\n",\r\n__func__);\r\nBUG();\r\n}\r\nret = nand_scan_ident(mtd, maxchips, NULL);\r\nif (!ret)\r\nret = nand_scan_tail(mtd);\r\nreturn ret;\r\n}\r\nvoid nand_release(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (chip->ecc.mode == NAND_ECC_SOFT_BCH)\r\nnand_bch_free((struct nand_bch_control *)chip->ecc.priv);\r\nmtd_device_unregister(mtd);\r\nkfree(chip->bbt);\r\nif (!(chip->options & NAND_OWN_BUFFERS))\r\nkfree(chip->buffers);\r\nif (chip->badblock_pattern && chip->badblock_pattern->options\r\n& NAND_BBT_DYNAMICSTRUCT)\r\nkfree(chip->badblock_pattern);\r\n}\r\nstatic int __init nand_base_init(void)\r\n{\r\nled_trigger_register_simple("nand-disk", &nand_led_trigger);\r\nreturn 0;\r\n}\r\nstatic void __exit nand_base_exit(void)\r\n{\r\nled_trigger_unregister_simple(nand_led_trigger);\r\n}
