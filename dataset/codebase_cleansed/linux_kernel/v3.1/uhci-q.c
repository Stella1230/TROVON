static void uhci_set_next_interrupt(struct uhci_hcd *uhci)\r\n{\r\nif (uhci->is_stopped)\r\nmod_timer(&uhci_to_hcd(uhci)->rh_timer, jiffies);\r\nuhci->term_td->status |= cpu_to_hc32(uhci, TD_CTRL_IOC);\r\n}\r\nstatic inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)\r\n{\r\nuhci->term_td->status &= ~cpu_to_hc32(uhci, TD_CTRL_IOC);\r\n}\r\nstatic void uhci_fsbr_on(struct uhci_hcd *uhci)\r\n{\r\nstruct uhci_qh *lqh;\r\nuhci->fsbr_is_on = 1;\r\nlqh = list_entry(uhci->skel_async_qh->node.prev,\r\nstruct uhci_qh, node);\r\nlqh->link = LINK_TO_QH(uhci, uhci->skel_term_qh);\r\n}\r\nstatic void uhci_fsbr_off(struct uhci_hcd *uhci)\r\n{\r\nstruct uhci_qh *lqh;\r\nuhci->fsbr_is_on = 0;\r\nlqh = list_entry(uhci->skel_async_qh->node.prev,\r\nstruct uhci_qh, node);\r\nlqh->link = UHCI_PTR_TERM(uhci);\r\n}\r\nstatic void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)\r\n{\r\nstruct urb_priv *urbp = urb->hcpriv;\r\nif (!(urb->transfer_flags & URB_NO_FSBR))\r\nurbp->fsbr = 1;\r\n}\r\nstatic void uhci_urbp_wants_fsbr(struct uhci_hcd *uhci, struct urb_priv *urbp)\r\n{\r\nif (urbp->fsbr) {\r\nuhci->fsbr_is_wanted = 1;\r\nif (!uhci->fsbr_is_on)\r\nuhci_fsbr_on(uhci);\r\nelse if (uhci->fsbr_expiring) {\r\nuhci->fsbr_expiring = 0;\r\ndel_timer(&uhci->fsbr_timer);\r\n}\r\n}\r\n}\r\nstatic void uhci_fsbr_timeout(unsigned long _uhci)\r\n{\r\nstruct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;\r\nunsigned long flags;\r\nspin_lock_irqsave(&uhci->lock, flags);\r\nif (uhci->fsbr_expiring) {\r\nuhci->fsbr_expiring = 0;\r\nuhci_fsbr_off(uhci);\r\n}\r\nspin_unlock_irqrestore(&uhci->lock, flags);\r\n}\r\nstatic struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)\r\n{\r\ndma_addr_t dma_handle;\r\nstruct uhci_td *td;\r\ntd = dma_pool_alloc(uhci->td_pool, GFP_ATOMIC, &dma_handle);\r\nif (!td)\r\nreturn NULL;\r\ntd->dma_handle = dma_handle;\r\ntd->frame = -1;\r\nINIT_LIST_HEAD(&td->list);\r\nINIT_LIST_HEAD(&td->fl_list);\r\nreturn td;\r\n}\r\nstatic void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)\r\n{\r\nif (!list_empty(&td->list))\r\ndev_WARN(uhci_dev(uhci), "td %p still in list!\n", td);\r\nif (!list_empty(&td->fl_list))\r\ndev_WARN(uhci_dev(uhci), "td %p still in fl_list!\n", td);\r\ndma_pool_free(uhci->td_pool, td, td->dma_handle);\r\n}\r\nstatic inline void uhci_fill_td(struct uhci_hcd *uhci, struct uhci_td *td,\r\nu32 status, u32 token, u32 buffer)\r\n{\r\ntd->status = cpu_to_hc32(uhci, status);\r\ntd->token = cpu_to_hc32(uhci, token);\r\ntd->buffer = cpu_to_hc32(uhci, buffer);\r\n}\r\nstatic void uhci_add_td_to_urbp(struct uhci_td *td, struct urb_priv *urbp)\r\n{\r\nlist_add_tail(&td->list, &urbp->td_list);\r\n}\r\nstatic void uhci_remove_td_from_urbp(struct uhci_td *td)\r\n{\r\nlist_del_init(&td->list);\r\n}\r\nstatic inline void uhci_insert_td_in_frame_list(struct uhci_hcd *uhci,\r\nstruct uhci_td *td, unsigned framenum)\r\n{\r\nframenum &= (UHCI_NUMFRAMES - 1);\r\ntd->frame = framenum;\r\nif (uhci->frame_cpu[framenum]) {\r\nstruct uhci_td *ftd, *ltd;\r\nftd = uhci->frame_cpu[framenum];\r\nltd = list_entry(ftd->fl_list.prev, struct uhci_td, fl_list);\r\nlist_add_tail(&td->fl_list, &ftd->fl_list);\r\ntd->link = ltd->link;\r\nwmb();\r\nltd->link = LINK_TO_TD(uhci, td);\r\n} else {\r\ntd->link = uhci->frame[framenum];\r\nwmb();\r\nuhci->frame[framenum] = LINK_TO_TD(uhci, td);\r\nuhci->frame_cpu[framenum] = td;\r\n}\r\n}\r\nstatic inline void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci,\r\nstruct uhci_td *td)\r\n{\r\nif (td->frame == -1) {\r\nWARN_ON(!list_empty(&td->fl_list));\r\nreturn;\r\n}\r\nif (uhci->frame_cpu[td->frame] == td) {\r\nif (list_empty(&td->fl_list)) {\r\nuhci->frame[td->frame] = td->link;\r\nuhci->frame_cpu[td->frame] = NULL;\r\n} else {\r\nstruct uhci_td *ntd;\r\nntd = list_entry(td->fl_list.next,\r\nstruct uhci_td,\r\nfl_list);\r\nuhci->frame[td->frame] = LINK_TO_TD(uhci, ntd);\r\nuhci->frame_cpu[td->frame] = ntd;\r\n}\r\n} else {\r\nstruct uhci_td *ptd;\r\nptd = list_entry(td->fl_list.prev, struct uhci_td, fl_list);\r\nptd->link = td->link;\r\n}\r\nlist_del_init(&td->fl_list);\r\ntd->frame = -1;\r\n}\r\nstatic inline void uhci_remove_tds_from_frame(struct uhci_hcd *uhci,\r\nunsigned int framenum)\r\n{\r\nstruct uhci_td *ftd, *ltd;\r\nframenum &= (UHCI_NUMFRAMES - 1);\r\nftd = uhci->frame_cpu[framenum];\r\nif (ftd) {\r\nltd = list_entry(ftd->fl_list.prev, struct uhci_td, fl_list);\r\nuhci->frame[framenum] = ltd->link;\r\nuhci->frame_cpu[framenum] = NULL;\r\nwhile (!list_empty(&ftd->fl_list))\r\nlist_del_init(ftd->fl_list.prev);\r\n}\r\n}\r\nstatic void uhci_unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)\r\n{\r\nstruct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;\r\nstruct uhci_td *td;\r\nlist_for_each_entry(td, &urbp->td_list, list)\r\nuhci_remove_td_from_frame_list(uhci, td);\r\n}\r\nstatic struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,\r\nstruct usb_device *udev, struct usb_host_endpoint *hep)\r\n{\r\ndma_addr_t dma_handle;\r\nstruct uhci_qh *qh;\r\nqh = dma_pool_alloc(uhci->qh_pool, GFP_ATOMIC, &dma_handle);\r\nif (!qh)\r\nreturn NULL;\r\nmemset(qh, 0, sizeof(*qh));\r\nqh->dma_handle = dma_handle;\r\nqh->element = UHCI_PTR_TERM(uhci);\r\nqh->link = UHCI_PTR_TERM(uhci);\r\nINIT_LIST_HEAD(&qh->queue);\r\nINIT_LIST_HEAD(&qh->node);\r\nif (udev) {\r\nqh->type = usb_endpoint_type(&hep->desc);\r\nif (qh->type != USB_ENDPOINT_XFER_ISOC) {\r\nqh->dummy_td = uhci_alloc_td(uhci);\r\nif (!qh->dummy_td) {\r\ndma_pool_free(uhci->qh_pool, qh, dma_handle);\r\nreturn NULL;\r\n}\r\n}\r\nqh->state = QH_STATE_IDLE;\r\nqh->hep = hep;\r\nqh->udev = udev;\r\nhep->hcpriv = qh;\r\nif (qh->type == USB_ENDPOINT_XFER_INT ||\r\nqh->type == USB_ENDPOINT_XFER_ISOC)\r\nqh->load = usb_calc_bus_time(udev->speed,\r\nusb_endpoint_dir_in(&hep->desc),\r\nqh->type == USB_ENDPOINT_XFER_ISOC,\r\nle16_to_cpu(hep->desc.wMaxPacketSize))\r\n/ 1000 + 1;\r\n} else {\r\nqh->state = QH_STATE_ACTIVE;\r\nqh->type = -1;\r\n}\r\nreturn qh;\r\n}\r\nstatic void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nWARN_ON(qh->state != QH_STATE_IDLE && qh->udev);\r\nif (!list_empty(&qh->queue))\r\ndev_WARN(uhci_dev(uhci), "qh %p list not empty!\n", qh);\r\nlist_del(&qh->node);\r\nif (qh->udev) {\r\nqh->hep->hcpriv = NULL;\r\nif (qh->dummy_td)\r\nuhci_free_td(uhci, qh->dummy_td);\r\n}\r\ndma_pool_free(uhci->qh_pool, qh, qh->dma_handle);\r\n}\r\nstatic int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,\r\nstruct urb *urb)\r\n{\r\nstruct urb_priv *urbp = urb->hcpriv;\r\nstruct uhci_td *td;\r\nint ret = 1;\r\nif (qh->type == USB_ENDPOINT_XFER_ISOC) {\r\nret = (uhci->frame_number + uhci->is_stopped !=\r\nqh->unlink_frame);\r\ngoto done;\r\n}\r\nif (qh->queue.next != &urbp->node) {\r\nstruct urb_priv *purbp;\r\nstruct uhci_td *ptd;\r\npurbp = list_entry(urbp->node.prev, struct urb_priv, node);\r\nWARN_ON(list_empty(&purbp->td_list));\r\nptd = list_entry(purbp->td_list.prev, struct uhci_td,\r\nlist);\r\ntd = list_entry(urbp->td_list.prev, struct uhci_td,\r\nlist);\r\nptd->link = td->link;\r\ngoto done;\r\n}\r\nif (qh_element(qh) == UHCI_PTR_TERM(uhci))\r\ngoto done;\r\nqh->element = UHCI_PTR_TERM(uhci);\r\nif (qh->type == USB_ENDPOINT_XFER_CONTROL)\r\ngoto done;\r\nWARN_ON(list_empty(&urbp->td_list));\r\ntd = list_entry(urbp->td_list.next, struct uhci_td, list);\r\nqh->needs_fixup = 1;\r\nqh->initial_toggle = uhci_toggle(td_token(uhci, td));\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void uhci_fixup_toggles(struct uhci_hcd *uhci, struct uhci_qh *qh,\r\nint skip_first)\r\n{\r\nstruct urb_priv *urbp = NULL;\r\nstruct uhci_td *td;\r\nunsigned int toggle = qh->initial_toggle;\r\nunsigned int pipe;\r\nif (skip_first)\r\nurbp = list_entry(qh->queue.next, struct urb_priv, node);\r\nelse if (qh_element(qh) != UHCI_PTR_TERM(uhci))\r\ntoggle = 2;\r\nurbp = list_prepare_entry(urbp, &qh->queue, node);\r\nlist_for_each_entry_continue(urbp, &qh->queue, node) {\r\ntd = list_entry(urbp->td_list.next, struct uhci_td, list);\r\nif (toggle > 1 || uhci_toggle(td_token(uhci, td)) == toggle) {\r\ntd = list_entry(urbp->td_list.prev, struct uhci_td,\r\nlist);\r\ntoggle = uhci_toggle(td_token(uhci, td)) ^ 1;\r\n} else {\r\nlist_for_each_entry(td, &urbp->td_list, list) {\r\ntd->token ^= cpu_to_hc32(uhci,\r\nTD_TOKEN_TOGGLE);\r\ntoggle ^= 1;\r\n}\r\n}\r\n}\r\nwmb();\r\npipe = list_entry(qh->queue.next, struct urb_priv, node)->urb->pipe;\r\nusb_settoggle(qh->udev, usb_pipeendpoint(pipe),\r\nusb_pipeout(pipe), toggle);\r\nqh->needs_fixup = 0;\r\n}\r\nstatic inline void link_iso(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nlist_add_tail(&qh->node, &uhci->skel_iso_qh->node);\r\n}\r\nstatic void link_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nstruct uhci_qh *pqh;\r\nlist_add_tail(&qh->node, &uhci->skelqh[qh->skel]->node);\r\npqh = list_entry(qh->node.prev, struct uhci_qh, node);\r\nqh->link = pqh->link;\r\nwmb();\r\npqh->link = LINK_TO_QH(uhci, qh);\r\n}\r\nstatic void link_async(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nstruct uhci_qh *pqh;\r\n__hc32 link_to_new_qh;\r\nlist_for_each_entry_reverse(pqh, &uhci->skel_async_qh->node, node) {\r\nif (pqh->skel <= qh->skel)\r\nbreak;\r\n}\r\nlist_add(&qh->node, &pqh->node);\r\nqh->link = pqh->link;\r\nwmb();\r\nlink_to_new_qh = LINK_TO_QH(uhci, qh);\r\npqh->link = link_to_new_qh;\r\nif (pqh->skel < SKEL_FSBR && qh->skel >= SKEL_FSBR)\r\nuhci->skel_term_qh->link = link_to_new_qh;\r\n}\r\nstatic void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nWARN_ON(list_empty(&qh->queue));\r\nif (qh_element(qh) == UHCI_PTR_TERM(uhci)) {\r\nstruct urb_priv *urbp = list_entry(qh->queue.next,\r\nstruct urb_priv, node);\r\nstruct uhci_td *td = list_entry(urbp->td_list.next,\r\nstruct uhci_td, list);\r\nqh->element = LINK_TO_TD(uhci, td);\r\n}\r\nqh->wait_expired = 0;\r\nqh->advance_jiffies = jiffies;\r\nif (qh->state == QH_STATE_ACTIVE)\r\nreturn;\r\nqh->state = QH_STATE_ACTIVE;\r\nif (qh == uhci->next_qh)\r\nuhci->next_qh = list_entry(qh->node.next, struct uhci_qh,\r\nnode);\r\nlist_del(&qh->node);\r\nif (qh->skel == SKEL_ISO)\r\nlink_iso(uhci, qh);\r\nelse if (qh->skel < SKEL_ASYNC)\r\nlink_interrupt(uhci, qh);\r\nelse\r\nlink_async(uhci, qh);\r\n}\r\nstatic void unlink_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nstruct uhci_qh *pqh;\r\npqh = list_entry(qh->node.prev, struct uhci_qh, node);\r\npqh->link = qh->link;\r\nmb();\r\n}\r\nstatic void unlink_async(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nstruct uhci_qh *pqh;\r\n__hc32 link_to_next_qh = qh->link;\r\npqh = list_entry(qh->node.prev, struct uhci_qh, node);\r\npqh->link = link_to_next_qh;\r\nif (pqh->skel < SKEL_FSBR && qh->skel >= SKEL_FSBR)\r\nuhci->skel_term_qh->link = link_to_next_qh;\r\nmb();\r\n}\r\nstatic void uhci_unlink_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nif (qh->state == QH_STATE_UNLINKING)\r\nreturn;\r\nWARN_ON(qh->state != QH_STATE_ACTIVE || !qh->udev);\r\nqh->state = QH_STATE_UNLINKING;\r\nif (qh->skel == SKEL_ISO)\r\n;\r\nelse if (qh->skel < SKEL_ASYNC)\r\nunlink_interrupt(uhci, qh);\r\nelse\r\nunlink_async(uhci, qh);\r\nuhci_get_current_frame_number(uhci);\r\nqh->unlink_frame = uhci->frame_number;\r\nif (list_empty(&uhci->skel_unlink_qh->node) || uhci->is_stopped)\r\nuhci_set_next_interrupt(uhci);\r\nif (qh == uhci->next_qh)\r\nuhci->next_qh = list_entry(qh->node.next, struct uhci_qh,\r\nnode);\r\nlist_move_tail(&qh->node, &uhci->skel_unlink_qh->node);\r\n}\r\nstatic void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nWARN_ON(qh->state == QH_STATE_ACTIVE);\r\nif (qh == uhci->next_qh)\r\nuhci->next_qh = list_entry(qh->node.next, struct uhci_qh,\r\nnode);\r\nlist_move(&qh->node, &uhci->idle_qh_list);\r\nqh->state = QH_STATE_IDLE;\r\nif (qh->post_td) {\r\nuhci_free_td(uhci, qh->post_td);\r\nqh->post_td = NULL;\r\n}\r\nif (uhci->num_waiting)\r\nwake_up_all(&uhci->waitqh);\r\n}\r\nstatic int uhci_highest_load(struct uhci_hcd *uhci, int phase, int period)\r\n{\r\nint highest_load = uhci->load[phase];\r\nfor (phase += period; phase < MAX_PHASE; phase += period)\r\nhighest_load = max_t(int, highest_load, uhci->load[phase]);\r\nreturn highest_load;\r\n}\r\nstatic int uhci_check_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nint minimax_load;\r\nif (qh->phase >= 0)\r\nminimax_load = uhci_highest_load(uhci, qh->phase, qh->period);\r\nelse {\r\nint phase, load;\r\nint max_phase = min_t(int, MAX_PHASE, qh->period);\r\nqh->phase = 0;\r\nminimax_load = uhci_highest_load(uhci, qh->phase, qh->period);\r\nfor (phase = 1; phase < max_phase; ++phase) {\r\nload = uhci_highest_load(uhci, phase, qh->period);\r\nif (load < minimax_load) {\r\nminimax_load = load;\r\nqh->phase = phase;\r\n}\r\n}\r\n}\r\nif (minimax_load + qh->load > 900) {\r\ndev_dbg(uhci_dev(uhci), "bandwidth allocation failed: "\r\n"period %d, phase %d, %d + %d us\n",\r\nqh->period, qh->phase, minimax_load, qh->load);\r\nreturn -ENOSPC;\r\n}\r\nreturn 0;\r\n}\r\nstatic void uhci_reserve_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nint i;\r\nint load = qh->load;\r\nchar *p = "??";\r\nfor (i = qh->phase; i < MAX_PHASE; i += qh->period) {\r\nuhci->load[i] += load;\r\nuhci->total_load += load;\r\n}\r\nuhci_to_hcd(uhci)->self.bandwidth_allocated =\r\nuhci->total_load / MAX_PHASE;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_INT:\r\n++uhci_to_hcd(uhci)->self.bandwidth_int_reqs;\r\np = "INT";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\n++uhci_to_hcd(uhci)->self.bandwidth_isoc_reqs;\r\np = "ISO";\r\nbreak;\r\n}\r\nqh->bandwidth_reserved = 1;\r\ndev_dbg(uhci_dev(uhci),\r\n"%s dev %d ep%02x-%s, period %d, phase %d, %d us\n",\r\n"reserve", qh->udev->devnum,\r\nqh->hep->desc.bEndpointAddress, p,\r\nqh->period, qh->phase, load);\r\n}\r\nstatic void uhci_release_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nint i;\r\nint load = qh->load;\r\nchar *p = "??";\r\nfor (i = qh->phase; i < MAX_PHASE; i += qh->period) {\r\nuhci->load[i] -= load;\r\nuhci->total_load -= load;\r\n}\r\nuhci_to_hcd(uhci)->self.bandwidth_allocated =\r\nuhci->total_load / MAX_PHASE;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_INT:\r\n--uhci_to_hcd(uhci)->self.bandwidth_int_reqs;\r\np = "INT";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\n--uhci_to_hcd(uhci)->self.bandwidth_isoc_reqs;\r\np = "ISO";\r\nbreak;\r\n}\r\nqh->bandwidth_reserved = 0;\r\ndev_dbg(uhci_dev(uhci),\r\n"%s dev %d ep%02x-%s, period %d, phase %d, %d us\n",\r\n"release", qh->udev->devnum,\r\nqh->hep->desc.bEndpointAddress, p,\r\nqh->period, qh->phase, load);\r\n}\r\nstatic inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,\r\nstruct urb *urb)\r\n{\r\nstruct urb_priv *urbp;\r\nurbp = kmem_cache_zalloc(uhci_up_cachep, GFP_ATOMIC);\r\nif (!urbp)\r\nreturn NULL;\r\nurbp->urb = urb;\r\nurb->hcpriv = urbp;\r\nINIT_LIST_HEAD(&urbp->node);\r\nINIT_LIST_HEAD(&urbp->td_list);\r\nreturn urbp;\r\n}\r\nstatic void uhci_free_urb_priv(struct uhci_hcd *uhci,\r\nstruct urb_priv *urbp)\r\n{\r\nstruct uhci_td *td, *tmp;\r\nif (!list_empty(&urbp->node))\r\ndev_WARN(uhci_dev(uhci), "urb %p still on QH's list!\n",\r\nurbp->urb);\r\nlist_for_each_entry_safe(td, tmp, &urbp->td_list, list) {\r\nuhci_remove_td_from_urbp(td);\r\nuhci_free_td(uhci, td);\r\n}\r\nkmem_cache_free(uhci_up_cachep, urbp);\r\n}\r\nstatic int uhci_map_status(int status, int dir_out)\r\n{\r\nif (!status)\r\nreturn 0;\r\nif (status & TD_CTRL_BITSTUFF)\r\nreturn -EPROTO;\r\nif (status & TD_CTRL_CRCTIMEO) {\r\nif (dir_out)\r\nreturn -EPROTO;\r\nelse\r\nreturn -EILSEQ;\r\n}\r\nif (status & TD_CTRL_BABBLE)\r\nreturn -EOVERFLOW;\r\nif (status & TD_CTRL_DBUFERR)\r\nreturn -ENOSR;\r\nif (status & TD_CTRL_STALLED)\r\nreturn -EPIPE;\r\nreturn 0;\r\n}\r\nstatic int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,\r\nstruct uhci_qh *qh)\r\n{\r\nstruct uhci_td *td;\r\nunsigned long destination, status;\r\nint maxsze = le16_to_cpu(qh->hep->desc.wMaxPacketSize);\r\nint len = urb->transfer_buffer_length;\r\ndma_addr_t data = urb->transfer_dma;\r\n__hc32 *plink;\r\nstruct urb_priv *urbp = urb->hcpriv;\r\nint skel;\r\ndestination = (urb->pipe & PIPE_DEVEP_MASK) | USB_PID_SETUP;\r\nstatus = uhci_maxerr(3);\r\nif (urb->dev->speed == USB_SPEED_LOW)\r\nstatus |= TD_CTRL_LS;\r\ntd = qh->dummy_td;\r\nuhci_add_td_to_urbp(td, urbp);\r\nuhci_fill_td(uhci, td, status, destination | uhci_explen(8),\r\nurb->setup_dma);\r\nplink = &td->link;\r\nstatus |= TD_CTRL_ACTIVE;\r\nif (usb_pipeout(urb->pipe) || len == 0)\r\ndestination ^= (USB_PID_SETUP ^ USB_PID_OUT);\r\nelse {\r\ndestination ^= (USB_PID_SETUP ^ USB_PID_IN);\r\nstatus |= TD_CTRL_SPD;\r\n}\r\nwhile (len > 0) {\r\nint pktsze = maxsze;\r\nif (len <= pktsze) {\r\npktsze = len;\r\nstatus &= ~TD_CTRL_SPD;\r\n}\r\ntd = uhci_alloc_td(uhci);\r\nif (!td)\r\ngoto nomem;\r\n*plink = LINK_TO_TD(uhci, td);\r\ndestination ^= TD_TOKEN_TOGGLE;\r\nuhci_add_td_to_urbp(td, urbp);\r\nuhci_fill_td(uhci, td, status,\r\ndestination | uhci_explen(pktsze), data);\r\nplink = &td->link;\r\ndata += pktsze;\r\nlen -= pktsze;\r\n}\r\ntd = uhci_alloc_td(uhci);\r\nif (!td)\r\ngoto nomem;\r\n*plink = LINK_TO_TD(uhci, td);\r\ndestination ^= (USB_PID_IN ^ USB_PID_OUT);\r\ndestination |= TD_TOKEN_TOGGLE;\r\nuhci_add_td_to_urbp(td, urbp);\r\nuhci_fill_td(uhci, td, status | TD_CTRL_IOC,\r\ndestination | uhci_explen(0), 0);\r\nplink = &td->link;\r\ntd = uhci_alloc_td(uhci);\r\nif (!td)\r\ngoto nomem;\r\n*plink = LINK_TO_TD(uhci, td);\r\nuhci_fill_td(uhci, td, 0, USB_PID_OUT | uhci_explen(0), 0);\r\nwmb();\r\nqh->dummy_td->status |= cpu_to_hc32(uhci, TD_CTRL_ACTIVE);\r\nqh->dummy_td = td;\r\nif (urb->dev->speed == USB_SPEED_LOW ||\r\nurb->dev->state != USB_STATE_CONFIGURED)\r\nskel = SKEL_LS_CONTROL;\r\nelse {\r\nskel = SKEL_FS_CONTROL;\r\nuhci_add_fsbr(uhci, urb);\r\n}\r\nif (qh->state != QH_STATE_ACTIVE)\r\nqh->skel = skel;\r\nreturn 0;\r\nnomem:\r\nuhci_remove_td_from_urbp(qh->dummy_td);\r\nreturn -ENOMEM;\r\n}\r\nstatic int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,\r\nstruct uhci_qh *qh)\r\n{\r\nstruct uhci_td *td;\r\nunsigned long destination, status;\r\nint maxsze = le16_to_cpu(qh->hep->desc.wMaxPacketSize);\r\nint len = urb->transfer_buffer_length;\r\nint this_sg_len;\r\ndma_addr_t data;\r\n__hc32 *plink;\r\nstruct urb_priv *urbp = urb->hcpriv;\r\nunsigned int toggle;\r\nstruct scatterlist *sg;\r\nint i;\r\nif (len < 0)\r\nreturn -EINVAL;\r\ndestination = (urb->pipe & PIPE_DEVEP_MASK) | usb_packetid(urb->pipe);\r\ntoggle = usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe));\r\nstatus = uhci_maxerr(3);\r\nif (urb->dev->speed == USB_SPEED_LOW)\r\nstatus |= TD_CTRL_LS;\r\nif (usb_pipein(urb->pipe))\r\nstatus |= TD_CTRL_SPD;\r\ni = urb->num_sgs;\r\nif (len > 0 && i > 0) {\r\nsg = urb->sg;\r\ndata = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n} else {\r\nsg = NULL;\r\ndata = urb->transfer_dma;\r\nthis_sg_len = len;\r\n}\r\nplink = NULL;\r\ntd = qh->dummy_td;\r\nfor (;;) {\r\nint pktsze = maxsze;\r\nif (len <= pktsze) {\r\npktsze = len;\r\nif (!(urb->transfer_flags & URB_SHORT_NOT_OK))\r\nstatus &= ~TD_CTRL_SPD;\r\n}\r\nif (plink) {\r\ntd = uhci_alloc_td(uhci);\r\nif (!td)\r\ngoto nomem;\r\n*plink = LINK_TO_TD(uhci, td);\r\n}\r\nuhci_add_td_to_urbp(td, urbp);\r\nuhci_fill_td(uhci, td, status,\r\ndestination | uhci_explen(pktsze) |\r\n(toggle << TD_TOKEN_TOGGLE_SHIFT),\r\ndata);\r\nplink = &td->link;\r\nstatus |= TD_CTRL_ACTIVE;\r\ntoggle ^= 1;\r\ndata += pktsze;\r\nthis_sg_len -= pktsze;\r\nlen -= maxsze;\r\nif (this_sg_len <= 0) {\r\nif (--i <= 0 || len <= 0)\r\nbreak;\r\nsg = sg_next(sg);\r\ndata = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n}\r\n}\r\nif ((urb->transfer_flags & URB_ZERO_PACKET) &&\r\nusb_pipeout(urb->pipe) && len == 0 &&\r\nurb->transfer_buffer_length > 0) {\r\ntd = uhci_alloc_td(uhci);\r\nif (!td)\r\ngoto nomem;\r\n*plink = LINK_TO_TD(uhci, td);\r\nuhci_add_td_to_urbp(td, urbp);\r\nuhci_fill_td(uhci, td, status,\r\ndestination | uhci_explen(0) |\r\n(toggle << TD_TOKEN_TOGGLE_SHIFT),\r\ndata);\r\nplink = &td->link;\r\ntoggle ^= 1;\r\n}\r\ntd->status |= cpu_to_hc32(uhci, TD_CTRL_IOC);\r\ntd = uhci_alloc_td(uhci);\r\nif (!td)\r\ngoto nomem;\r\n*plink = LINK_TO_TD(uhci, td);\r\nuhci_fill_td(uhci, td, 0, USB_PID_OUT | uhci_explen(0), 0);\r\nwmb();\r\nqh->dummy_td->status |= cpu_to_hc32(uhci, TD_CTRL_ACTIVE);\r\nqh->dummy_td = td;\r\nusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe), toggle);\r\nreturn 0;\r\nnomem:\r\nuhci_remove_td_from_urbp(qh->dummy_td);\r\nreturn -ENOMEM;\r\n}\r\nstatic int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,\r\nstruct uhci_qh *qh)\r\n{\r\nint ret;\r\nif (urb->dev->speed == USB_SPEED_LOW)\r\nreturn -EINVAL;\r\nif (qh->state != QH_STATE_ACTIVE)\r\nqh->skel = SKEL_BULK;\r\nret = uhci_submit_common(uhci, urb, qh);\r\nif (ret == 0)\r\nuhci_add_fsbr(uhci, urb);\r\nreturn ret;\r\n}\r\nstatic int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,\r\nstruct uhci_qh *qh)\r\n{\r\nint ret;\r\nif (!qh->bandwidth_reserved) {\r\nint exponent;\r\nfor (exponent = 7; exponent >= 0; --exponent) {\r\nif ((1 << exponent) <= urb->interval)\r\nbreak;\r\n}\r\nif (exponent < 0)\r\nreturn -EINVAL;\r\ndo {\r\nqh->period = 1 << exponent;\r\nqh->skel = SKEL_INDEX(exponent);\r\nqh->phase = (qh->period / 2) & (MAX_PHASE - 1);\r\nret = uhci_check_bandwidth(uhci, qh);\r\n} while (ret != 0 && --exponent >= 0);\r\nif (ret)\r\nreturn ret;\r\n} else if (qh->period > urb->interval)\r\nreturn -EINVAL;\r\nret = uhci_submit_common(uhci, urb, qh);\r\nif (ret == 0) {\r\nurb->interval = qh->period;\r\nif (!qh->bandwidth_reserved)\r\nuhci_reserve_bandwidth(uhci, qh);\r\n}\r\nreturn ret;\r\n}\r\nstatic int uhci_fixup_short_transfer(struct uhci_hcd *uhci,\r\nstruct uhci_qh *qh, struct urb_priv *urbp)\r\n{\r\nstruct uhci_td *td;\r\nstruct list_head *tmp;\r\nint ret;\r\ntd = list_entry(urbp->td_list.prev, struct uhci_td, list);\r\nif (qh->type == USB_ENDPOINT_XFER_CONTROL) {\r\nWARN_ON(list_empty(&urbp->td_list));\r\nqh->element = LINK_TO_TD(uhci, td);\r\ntmp = td->list.prev;\r\nret = -EINPROGRESS;\r\n} else {\r\nqh->initial_toggle =\r\nuhci_toggle(td_token(uhci, qh->post_td)) ^ 1;\r\nuhci_fixup_toggles(uhci, qh, 1);\r\nif (list_empty(&urbp->td_list))\r\ntd = qh->post_td;\r\nqh->element = td->link;\r\ntmp = urbp->td_list.prev;\r\nret = 0;\r\n}\r\nwhile (tmp != &urbp->td_list) {\r\ntd = list_entry(tmp, struct uhci_td, list);\r\ntmp = tmp->prev;\r\nuhci_remove_td_from_urbp(td);\r\nuhci_free_td(uhci, td);\r\n}\r\nreturn ret;\r\n}\r\nstatic int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)\r\n{\r\nstruct urb_priv *urbp = urb->hcpriv;\r\nstruct uhci_qh *qh = urbp->qh;\r\nstruct uhci_td *td, *tmp;\r\nunsigned status;\r\nint ret = 0;\r\nlist_for_each_entry_safe(td, tmp, &urbp->td_list, list) {\r\nunsigned int ctrlstat;\r\nint len;\r\nctrlstat = td_status(uhci, td);\r\nstatus = uhci_status_bits(ctrlstat);\r\nif (status & TD_CTRL_ACTIVE)\r\nreturn -EINPROGRESS;\r\nlen = uhci_actual_length(ctrlstat);\r\nurb->actual_length += len;\r\nif (status) {\r\nret = uhci_map_status(status,\r\nuhci_packetout(td_token(uhci, td)));\r\nif ((debug == 1 && ret != -EPIPE) || debug > 1) {\r\ndev_dbg(&urb->dev->dev,\r\n"%s: failed with status %x\n",\r\n__func__, status);\r\nif (debug > 1 && errbuf) {\r\nuhci_show_qh(uhci, urbp->qh, errbuf,\r\nERRBUF_LEN, 0);\r\nlprintk(errbuf);\r\n}\r\n}\r\n} else if (len < uhci_expected_length(td_token(uhci, td))) {\r\nif (qh->type == USB_ENDPOINT_XFER_CONTROL) {\r\nif (td->list.next != urbp->td_list.prev)\r\nret = 1;\r\n}\r\nelse if (urb->transfer_flags & URB_SHORT_NOT_OK)\r\nret = -EREMOTEIO;\r\nelse if (&td->list != urbp->td_list.prev)\r\nret = 1;\r\n}\r\nuhci_remove_td_from_urbp(td);\r\nif (qh->post_td)\r\nuhci_free_td(uhci, qh->post_td);\r\nqh->post_td = td;\r\nif (ret != 0)\r\ngoto err;\r\n}\r\nreturn ret;\r\nerr:\r\nif (ret < 0) {\r\nqh->element = UHCI_PTR_TERM(uhci);\r\nqh->is_stopped = 1;\r\nqh->needs_fixup = (qh->type != USB_ENDPOINT_XFER_CONTROL);\r\nqh->initial_toggle = uhci_toggle(td_token(uhci, td)) ^\r\n(ret == -EREMOTEIO);\r\n} else\r\nret = uhci_fixup_short_transfer(uhci, qh, urbp);\r\nreturn ret;\r\n}\r\nstatic int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,\r\nstruct uhci_qh *qh)\r\n{\r\nstruct uhci_td *td = NULL;\r\nint i, frame;\r\nunsigned long destination, status;\r\nstruct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;\r\nif (urb->interval >= UHCI_NUMFRAMES ||\r\nurb->number_of_packets >= UHCI_NUMFRAMES)\r\nreturn -EFBIG;\r\nif (!qh->bandwidth_reserved) {\r\nqh->period = urb->interval;\r\nif (urb->transfer_flags & URB_ISO_ASAP) {\r\nqh->phase = -1;\r\ni = uhci_check_bandwidth(uhci, qh);\r\nif (i)\r\nreturn i;\r\nuhci_get_current_frame_number(uhci);\r\nframe = uhci->frame_number + 10;\r\nurb->start_frame = frame + ((qh->phase - frame) &\r\n(qh->period - 1));\r\n} else {\r\ni = urb->start_frame - uhci->last_iso_frame;\r\nif (i <= 0 || i >= UHCI_NUMFRAMES)\r\nreturn -EINVAL;\r\nqh->phase = urb->start_frame & (qh->period - 1);\r\ni = uhci_check_bandwidth(uhci, qh);\r\nif (i)\r\nreturn i;\r\n}\r\n} else if (qh->period != urb->interval) {\r\nreturn -EINVAL;\r\n} else {\r\nif (list_empty(&qh->queue)) {\r\nframe = qh->iso_frame;\r\n} else {\r\nstruct urb *lurb;\r\nlurb = list_entry(qh->queue.prev,\r\nstruct urb_priv, node)->urb;\r\nframe = lurb->start_frame +\r\nlurb->number_of_packets *\r\nlurb->interval;\r\n}\r\nif (urb->transfer_flags & URB_ISO_ASAP) {\r\nuhci_get_current_frame_number(uhci);\r\nif (uhci_frame_before_eq(frame, uhci->frame_number)) {\r\nframe = uhci->frame_number + 1;\r\nframe += ((qh->phase - frame) &\r\n(qh->period - 1));\r\n}\r\n}\r\nurb->start_frame = frame;\r\n}\r\nif (uhci_frame_before_eq(uhci->last_iso_frame + UHCI_NUMFRAMES,\r\nurb->start_frame + urb->number_of_packets *\r\nurb->interval))\r\nreturn -EFBIG;\r\nstatus = TD_CTRL_ACTIVE | TD_CTRL_IOS;\r\ndestination = (urb->pipe & PIPE_DEVEP_MASK) | usb_packetid(urb->pipe);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\ntd = uhci_alloc_td(uhci);\r\nif (!td)\r\nreturn -ENOMEM;\r\nuhci_add_td_to_urbp(td, urbp);\r\nuhci_fill_td(uhci, td, status, destination |\r\nuhci_explen(urb->iso_frame_desc[i].length),\r\nurb->transfer_dma +\r\nurb->iso_frame_desc[i].offset);\r\n}\r\ntd->status |= cpu_to_hc32(uhci, TD_CTRL_IOC);\r\nframe = urb->start_frame;\r\nlist_for_each_entry(td, &urbp->td_list, list) {\r\nuhci_insert_td_in_frame_list(uhci, td, frame);\r\nframe += qh->period;\r\n}\r\nif (list_empty(&qh->queue)) {\r\nqh->iso_packet_desc = &urb->iso_frame_desc[0];\r\nqh->iso_frame = urb->start_frame;\r\n}\r\nqh->skel = SKEL_ISO;\r\nif (!qh->bandwidth_reserved)\r\nuhci_reserve_bandwidth(uhci, qh);\r\nreturn 0;\r\n}\r\nstatic int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)\r\n{\r\nstruct uhci_td *td, *tmp;\r\nstruct urb_priv *urbp = urb->hcpriv;\r\nstruct uhci_qh *qh = urbp->qh;\r\nlist_for_each_entry_safe(td, tmp, &urbp->td_list, list) {\r\nunsigned int ctrlstat;\r\nint status;\r\nint actlength;\r\nif (uhci_frame_before_eq(uhci->cur_iso_frame, qh->iso_frame))\r\nreturn -EINPROGRESS;\r\nuhci_remove_tds_from_frame(uhci, qh->iso_frame);\r\nctrlstat = td_status(uhci, td);\r\nif (ctrlstat & TD_CTRL_ACTIVE) {\r\nstatus = -EXDEV;\r\n} else {\r\nstatus = uhci_map_status(uhci_status_bits(ctrlstat),\r\nusb_pipeout(urb->pipe));\r\nactlength = uhci_actual_length(ctrlstat);\r\nurb->actual_length += actlength;\r\nqh->iso_packet_desc->actual_length = actlength;\r\nqh->iso_packet_desc->status = status;\r\n}\r\nif (status)\r\nurb->error_count++;\r\nuhci_remove_td_from_urbp(td);\r\nuhci_free_td(uhci, td);\r\nqh->iso_frame += qh->period;\r\n++qh->iso_packet_desc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uhci_urb_enqueue(struct usb_hcd *hcd,\r\nstruct urb *urb, gfp_t mem_flags)\r\n{\r\nint ret;\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nunsigned long flags;\r\nstruct urb_priv *urbp;\r\nstruct uhci_qh *qh;\r\nspin_lock_irqsave(&uhci->lock, flags);\r\nret = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (ret)\r\ngoto done_not_linked;\r\nret = -ENOMEM;\r\nurbp = uhci_alloc_urb_priv(uhci, urb);\r\nif (!urbp)\r\ngoto done;\r\nif (urb->ep->hcpriv)\r\nqh = urb->ep->hcpriv;\r\nelse {\r\nqh = uhci_alloc_qh(uhci, urb->dev, urb->ep);\r\nif (!qh)\r\ngoto err_no_qh;\r\n}\r\nurbp->qh = qh;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nret = uhci_submit_control(uhci, urb, qh);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nret = uhci_submit_bulk(uhci, urb, qh);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nret = uhci_submit_interrupt(uhci, urb, qh);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nurb->error_count = 0;\r\nret = uhci_submit_isochronous(uhci, urb, qh);\r\nbreak;\r\n}\r\nif (ret != 0)\r\ngoto err_submit_failed;\r\nlist_add_tail(&urbp->node, &qh->queue);\r\nif (qh->queue.next == &urbp->node && !qh->is_stopped) {\r\nuhci_activate_qh(uhci, qh);\r\nuhci_urbp_wants_fsbr(uhci, urbp);\r\n}\r\ngoto done;\r\nerr_submit_failed:\r\nif (qh->state == QH_STATE_IDLE)\r\nuhci_make_qh_idle(uhci, qh);\r\nerr_no_qh:\r\nuhci_free_urb_priv(uhci, urbp);\r\ndone:\r\nif (ret)\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore(&uhci->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\r\nunsigned long flags;\r\nstruct uhci_qh *qh;\r\nint rc;\r\nspin_lock_irqsave(&uhci->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto done;\r\nqh = ((struct urb_priv *) urb->hcpriv)->qh;\r\nif (qh->type == USB_ENDPOINT_XFER_ISOC) {\r\nuhci_unlink_isochronous_tds(uhci, urb);\r\nmb();\r\nuhci_get_current_frame_number(uhci);\r\nif (uhci_frame_before_eq(urb->start_frame, uhci->frame_number))\r\nqh->unlink_frame = uhci->frame_number;\r\n}\r\nuhci_unlink_qh(uhci, qh);\r\ndone:\r\nspin_unlock_irqrestore(&uhci->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void uhci_giveback_urb(struct uhci_hcd *uhci, struct uhci_qh *qh,\r\nstruct urb *urb, int status)\r\n__releases(uhci->lock)\r\n__acquires(uhci->lock)\r\n{\r\nstruct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;\r\nif (qh->type == USB_ENDPOINT_XFER_CONTROL) {\r\nurb->actual_length -= min_t(u32, 8, urb->actual_length);\r\n}\r\nelse if (qh->type == USB_ENDPOINT_XFER_ISOC &&\r\nurbp->node.prev == &qh->queue &&\r\nurbp->node.next != &qh->queue) {\r\nstruct urb *nurb = list_entry(urbp->node.next,\r\nstruct urb_priv, node)->urb;\r\nqh->iso_packet_desc = &nurb->iso_frame_desc[0];\r\nqh->iso_frame = nurb->start_frame;\r\n}\r\nlist_del_init(&urbp->node);\r\nif (list_empty(&qh->queue) && qh->needs_fixup) {\r\nusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe), qh->initial_toggle);\r\nqh->needs_fixup = 0;\r\n}\r\nuhci_free_urb_priv(uhci, urbp);\r\nusb_hcd_unlink_urb_from_ep(uhci_to_hcd(uhci), urb);\r\nspin_unlock(&uhci->lock);\r\nusb_hcd_giveback_urb(uhci_to_hcd(uhci), urb, status);\r\nspin_lock(&uhci->lock);\r\nif (list_empty(&qh->queue)) {\r\nuhci_unlink_qh(uhci, qh);\r\nif (qh->bandwidth_reserved)\r\nuhci_release_bandwidth(uhci, qh);\r\n}\r\n}\r\nstatic void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nstruct urb_priv *urbp;\r\nstruct urb *urb;\r\nint status;\r\nwhile (!list_empty(&qh->queue)) {\r\nurbp = list_entry(qh->queue.next, struct urb_priv, node);\r\nurb = urbp->urb;\r\nif (qh->type == USB_ENDPOINT_XFER_ISOC)\r\nstatus = uhci_result_isochronous(uhci, urb);\r\nelse\r\nstatus = uhci_result_common(uhci, urb);\r\nif (status == -EINPROGRESS)\r\nbreak;\r\nif (urb->unlinked) {\r\nif (QH_FINISHED_UNLINKING(qh))\r\nqh->is_stopped = 1;\r\nelse if (!qh->is_stopped)\r\nreturn;\r\n}\r\nuhci_giveback_urb(uhci, qh, urb, status);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (QH_FINISHED_UNLINKING(qh))\r\nqh->is_stopped = 1;\r\nelse if (!qh->is_stopped)\r\nreturn;\r\nrestart:\r\nlist_for_each_entry(urbp, &qh->queue, node) {\r\nurb = urbp->urb;\r\nif (urb->unlinked) {\r\nif (!uhci_cleanup_queue(uhci, qh, urb)) {\r\nqh->is_stopped = 0;\r\nreturn;\r\n}\r\nuhci_giveback_urb(uhci, qh, urb, 0);\r\ngoto restart;\r\n}\r\n}\r\nqh->is_stopped = 0;\r\nif (!list_empty(&qh->queue)) {\r\nif (qh->needs_fixup)\r\nuhci_fixup_toggles(uhci, qh, 0);\r\nurbp = list_entry(qh->queue.next, struct urb_priv, node);\r\nif (urbp->fsbr && qh->wait_expired) {\r\nstruct uhci_td *td = list_entry(urbp->td_list.next,\r\nstruct uhci_td, list);\r\ntd->status |= cpu_to_hc32(uhci, TD_CTRL_IOC);\r\n}\r\nuhci_activate_qh(uhci, qh);\r\n}\r\nelse if (QH_FINISHED_UNLINKING(qh))\r\nuhci_make_qh_idle(uhci, qh);\r\n}\r\nstatic int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)\r\n{\r\nstruct urb_priv *urbp = NULL;\r\nstruct uhci_td *td;\r\nint ret = 1;\r\nunsigned status;\r\nif (qh->type == USB_ENDPOINT_XFER_ISOC)\r\ngoto done;\r\nif (qh->state != QH_STATE_ACTIVE) {\r\nurbp = NULL;\r\nstatus = 0;\r\n} else {\r\nurbp = list_entry(qh->queue.next, struct urb_priv, node);\r\ntd = list_entry(urbp->td_list.next, struct uhci_td, list);\r\nstatus = td_status(uhci, td);\r\nif (!(status & TD_CTRL_ACTIVE)) {\r\nqh->wait_expired = 0;\r\nqh->advance_jiffies = jiffies;\r\ngoto done;\r\n}\r\nret = uhci->is_stopped;\r\n}\r\nif (qh->wait_expired)\r\ngoto done;\r\nif (time_after(jiffies, qh->advance_jiffies + QH_WAIT_TIMEOUT)) {\r\nif (qh->post_td && qh_element(qh) ==\r\nLINK_TO_TD(uhci, qh->post_td)) {\r\nqh->element = qh->post_td->link;\r\nqh->advance_jiffies = jiffies;\r\nret = 1;\r\ngoto done;\r\n}\r\nqh->wait_expired = 1;\r\nif (urbp && urbp->fsbr && !(status & TD_CTRL_IOC))\r\nuhci_unlink_qh(uhci, qh);\r\n} else {\r\nif (urbp)\r\nuhci_urbp_wants_fsbr(uhci, urbp);\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void uhci_scan_schedule(struct uhci_hcd *uhci)\r\n{\r\nint i;\r\nstruct uhci_qh *qh;\r\nif (uhci->scan_in_progress) {\r\nuhci->need_rescan = 1;\r\nreturn;\r\n}\r\nuhci->scan_in_progress = 1;\r\nrescan:\r\nuhci->need_rescan = 0;\r\nuhci->fsbr_is_wanted = 0;\r\nuhci_clear_next_interrupt(uhci);\r\nuhci_get_current_frame_number(uhci);\r\nuhci->cur_iso_frame = uhci->frame_number;\r\nfor (i = 0; i < UHCI_NUM_SKELQH - 1; ++i) {\r\nuhci->next_qh = list_entry(uhci->skelqh[i]->node.next,\r\nstruct uhci_qh, node);\r\nwhile ((qh = uhci->next_qh) != uhci->skelqh[i]) {\r\nuhci->next_qh = list_entry(qh->node.next,\r\nstruct uhci_qh, node);\r\nif (uhci_advance_check(uhci, qh)) {\r\nuhci_scan_qh(uhci, qh);\r\nif (qh->state == QH_STATE_ACTIVE) {\r\nuhci_urbp_wants_fsbr(uhci,\r\nlist_entry(qh->queue.next, struct urb_priv, node));\r\n}\r\n}\r\n}\r\n}\r\nuhci->last_iso_frame = uhci->cur_iso_frame;\r\nif (uhci->need_rescan)\r\ngoto rescan;\r\nuhci->scan_in_progress = 0;\r\nif (uhci->fsbr_is_on && !uhci->fsbr_is_wanted &&\r\n!uhci->fsbr_expiring) {\r\nuhci->fsbr_expiring = 1;\r\nmod_timer(&uhci->fsbr_timer, jiffies + FSBR_OFF_DELAY);\r\n}\r\nif (list_empty(&uhci->skel_unlink_qh->node))\r\nuhci_clear_next_interrupt(uhci);\r\nelse\r\nuhci_set_next_interrupt(uhci);\r\n}
