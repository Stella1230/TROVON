static int __ref pciehp_add_bridge(struct pci_dev *dev)\r\n{\r\nstruct pci_bus *parent = dev->bus;\r\nint pass, busnr, start = parent->secondary;\r\nint end = parent->subordinate;\r\nfor (busnr = start; busnr <= end; busnr++) {\r\nif (!pci_find_bus(pci_domain_nr(parent), busnr))\r\nbreak;\r\n}\r\nif (busnr-- > end) {\r\nerr("No bus number available for hot-added bridge %s\n",\r\npci_name(dev));\r\nreturn -1;\r\n}\r\nfor (pass = 0; pass < 2; pass++)\r\nbusnr = pci_scan_bridge(parent, dev, busnr, pass);\r\nif (!dev->subordinate)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint pciehp_configure_device(struct slot *p_slot)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_dev *bridge = p_slot->ctrl->pcie->port;\r\nstruct pci_bus *parent = bridge->subordinate;\r\nint num, fn;\r\nstruct controller *ctrl = p_slot->ctrl;\r\ndev = pci_get_slot(parent, PCI_DEVFN(0, 0));\r\nif (dev) {\r\nctrl_err(ctrl, "Device %s already exists "\r\n"at %04x:%02x:00, cannot hot-add\n", pci_name(dev),\r\npci_domain_nr(parent), parent->number);\r\npci_dev_put(dev);\r\nreturn -EINVAL;\r\n}\r\nnum = pci_scan_slot(parent, PCI_DEVFN(0, 0));\r\nif (num == 0) {\r\nctrl_err(ctrl, "No new device found\n");\r\nreturn -ENODEV;\r\n}\r\nfor (fn = 0; fn < 8; fn++) {\r\ndev = pci_get_slot(parent, PCI_DEVFN(0, fn));\r\nif (!dev)\r\ncontinue;\r\nif ((dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) ||\r\n(dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)) {\r\npciehp_add_bridge(dev);\r\n}\r\npci_dev_put(dev);\r\n}\r\npci_assign_unassigned_bridge_resources(bridge);\r\nfor (fn = 0; fn < 8; fn++) {\r\ndev = pci_get_slot(parent, PCI_DEVFN(0, fn));\r\nif (!dev)\r\ncontinue;\r\nif ((dev->class >> 16) == PCI_BASE_CLASS_DISPLAY) {\r\npci_dev_put(dev);\r\ncontinue;\r\n}\r\npci_configure_slot(dev);\r\npci_dev_put(dev);\r\n}\r\npci_bus_add_devices(parent);\r\nreturn 0;\r\n}\r\nint pciehp_unconfigure_device(struct slot *p_slot)\r\n{\r\nint ret, rc = 0;\r\nint j;\r\nu8 bctl = 0;\r\nu8 presence = 0;\r\nstruct pci_bus *parent = p_slot->ctrl->pcie->port->subordinate;\r\nu16 command;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nctrl_dbg(ctrl, "%s: domain:bus:dev = %04x:%02x:00\n",\r\n__func__, pci_domain_nr(parent), parent->number);\r\nret = pciehp_get_adapter_status(p_slot, &presence);\r\nif (ret)\r\npresence = 0;\r\nfor (j = 0; j < 8; j++) {\r\nstruct pci_dev *temp = pci_get_slot(parent, PCI_DEVFN(0, j));\r\nif (!temp)\r\ncontinue;\r\nif (temp->hdr_type == PCI_HEADER_TYPE_BRIDGE && presence) {\r\npci_read_config_byte(temp, PCI_BRIDGE_CONTROL, &bctl);\r\nif (bctl & PCI_BRIDGE_CTL_VGA) {\r\nctrl_err(ctrl,\r\n"Cannot remove display device %s\n",\r\npci_name(temp));\r\npci_dev_put(temp);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\n}\r\npci_remove_bus_device(temp);\r\nif (presence) {\r\npci_read_config_word(temp, PCI_COMMAND, &command);\r\ncommand &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_SERR);\r\ncommand |= PCI_COMMAND_INTX_DISABLE;\r\npci_write_config_word(temp, PCI_COMMAND, command);\r\n}\r\npci_dev_put(temp);\r\n}\r\nreturn rc;\r\n}
