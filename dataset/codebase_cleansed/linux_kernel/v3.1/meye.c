static void *rvmalloc(unsigned long size)\r\n{\r\nvoid *mem;\r\nunsigned long adr;\r\nsize = PAGE_ALIGN(size);\r\nmem = vmalloc_32(size);\r\nif (mem) {\r\nmemset(mem, 0, size);\r\nadr = (unsigned long) mem;\r\nwhile (size > 0) {\r\nSetPageReserved(vmalloc_to_page((void *)adr));\r\nadr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\n}\r\nreturn mem;\r\n}\r\nstatic void rvfree(void * mem, unsigned long size)\r\n{\r\nunsigned long adr;\r\nif (mem) {\r\nadr = (unsigned long) mem;\r\nwhile ((long) size > 0) {\r\nClearPageReserved(vmalloc_to_page((void *)adr));\r\nadr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nvfree(mem);\r\n}\r\n}\r\nstatic int ptable_alloc(void)\r\n{\r\nu32 *pt;\r\nint i;\r\nmemset(meye.mchip_ptable, 0, sizeof(meye.mchip_ptable));\r\nif (dma_set_mask(&meye.mchip_dev->dev, DMA_BIT_MASK(32)))\r\nreturn -1;\r\nmeye.mchip_ptable_toc = dma_alloc_coherent(&meye.mchip_dev->dev,\r\nPAGE_SIZE,\r\n&meye.mchip_dmahandle,\r\nGFP_KERNEL);\r\nif (!meye.mchip_ptable_toc) {\r\nmeye.mchip_dmahandle = 0;\r\nreturn -1;\r\n}\r\npt = meye.mchip_ptable_toc;\r\nfor (i = 0; i < MCHIP_NB_PAGES; i++) {\r\ndma_addr_t dma;\r\nmeye.mchip_ptable[i] = dma_alloc_coherent(&meye.mchip_dev->dev,\r\nPAGE_SIZE,\r\n&dma,\r\nGFP_KERNEL);\r\nif (!meye.mchip_ptable[i]) {\r\nint j;\r\npt = meye.mchip_ptable_toc;\r\nfor (j = 0; j < i; ++j) {\r\ndma = (dma_addr_t) *pt;\r\ndma_free_coherent(&meye.mchip_dev->dev,\r\nPAGE_SIZE,\r\nmeye.mchip_ptable[j], dma);\r\npt++;\r\n}\r\ndma_free_coherent(&meye.mchip_dev->dev,\r\nPAGE_SIZE,\r\nmeye.mchip_ptable_toc,\r\nmeye.mchip_dmahandle);\r\nmeye.mchip_ptable_toc = NULL;\r\nmeye.mchip_dmahandle = 0;\r\nreturn -1;\r\n}\r\n*pt = (u32) dma;\r\npt++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ptable_free(void)\r\n{\r\nu32 *pt;\r\nint i;\r\npt = meye.mchip_ptable_toc;\r\nfor (i = 0; i < MCHIP_NB_PAGES; i++) {\r\ndma_addr_t dma = (dma_addr_t) *pt;\r\nif (meye.mchip_ptable[i])\r\ndma_free_coherent(&meye.mchip_dev->dev,\r\nPAGE_SIZE,\r\nmeye.mchip_ptable[i], dma);\r\npt++;\r\n}\r\nif (meye.mchip_ptable_toc)\r\ndma_free_coherent(&meye.mchip_dev->dev,\r\nPAGE_SIZE,\r\nmeye.mchip_ptable_toc,\r\nmeye.mchip_dmahandle);\r\nmemset(meye.mchip_ptable, 0, sizeof(meye.mchip_ptable));\r\nmeye.mchip_ptable_toc = NULL;\r\nmeye.mchip_dmahandle = 0;\r\n}\r\nstatic void ptable_copy(u8 *buf, int start, int size, int pt_pages)\r\n{\r\nint i;\r\nfor (i = 0; i < (size / PAGE_SIZE) * PAGE_SIZE; i += PAGE_SIZE) {\r\nmemcpy(buf + i, meye.mchip_ptable[start++], PAGE_SIZE);\r\nif (start >= pt_pages)\r\nstart = 0;\r\n}\r\nmemcpy(buf + i, meye.mchip_ptable[start], size % PAGE_SIZE);\r\n}\r\nstatic u16 *jpeg_quantisation_tables(int *length, int quality)\r\n{\r\nstatic u16 jpeg_tables[][70] = { {\r\n0xdbff, 0x4300, 0xff00, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff,\r\n0xdbff, 0x4300, 0xff01, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x5000, 0x3c37, 0x3c46, 0x5032, 0x4146, 0x5a46,\r\n0x5055, 0x785f, 0x82c8, 0x6e78, 0x786e, 0xaff5, 0x91b9, 0xffc8,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff,\r\n0xdbff, 0x4300, 0x5501, 0x5a5a, 0x6978, 0xeb78, 0x8282, 0xffeb,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\r\n0xffff, 0xffff, 0xffff,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x2800, 0x1e1c, 0x1e23, 0x2819, 0x2123, 0x2d23,\r\n0x282b, 0x3c30, 0x4164, 0x373c, 0x3c37, 0x587b, 0x495d, 0x9164,\r\n0x9980, 0x8f96, 0x8c80, 0xa08a, 0xe6b4, 0xa0c3, 0xdaaa, 0x8aad,\r\n0xc88c, 0xcbff, 0xeeda, 0xfff5, 0xffff, 0xc19b, 0xffff, 0xfaff,\r\n0xe6ff, 0xfffd, 0xfff8,\r\n0xdbff, 0x4300, 0x2b01, 0x2d2d, 0x353c, 0x763c, 0x4141, 0xf876,\r\n0x8ca5, 0xf8a5, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8,\r\n0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8,\r\n0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8, 0xf8f8,\r\n0xf8f8, 0xf8f8, 0xfff8,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x1b00, 0x1412, 0x1417, 0x1b11, 0x1617, 0x1e17,\r\n0x1b1c, 0x2820, 0x2b42, 0x2528, 0x2825, 0x3a51, 0x303d, 0x6042,\r\n0x6555, 0x5f64, 0x5d55, 0x6a5b, 0x9978, 0x6a81, 0x9071, 0x5b73,\r\n0x855d, 0x86b5, 0x9e90, 0xaba3, 0xabad, 0x8067, 0xc9bc, 0xa6ba,\r\n0x99c7, 0xaba8, 0xffa4,\r\n0xdbff, 0x4300, 0x1c01, 0x1e1e, 0x2328, 0x4e28, 0x2b2b, 0xa44e,\r\n0x5d6e, 0xa46e, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4,\r\n0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4,\r\n0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4, 0xa4a4,\r\n0xa4a4, 0xa4a4, 0xffa4,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x1400, 0x0f0e, 0x0f12, 0x140d, 0x1012, 0x1712,\r\n0x1415, 0x1e18, 0x2132, 0x1c1e, 0x1e1c, 0x2c3d, 0x242e, 0x4932,\r\n0x4c40, 0x474b, 0x4640, 0x5045, 0x735a, 0x5062, 0x6d55, 0x4556,\r\n0x6446, 0x6588, 0x776d, 0x817b, 0x8182, 0x604e, 0x978d, 0x7d8c,\r\n0x7396, 0x817e, 0xff7c,\r\n0xdbff, 0x4300, 0x1501, 0x1717, 0x1a1e, 0x3b1e, 0x2121, 0x7c3b,\r\n0x4653, 0x7c53, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c,\r\n0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c,\r\n0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c, 0x7c7c,\r\n0x7c7c, 0x7c7c, 0xff7c,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x1000, 0x0c0b, 0x0c0e, 0x100a, 0x0d0e, 0x120e,\r\n0x1011, 0x1813, 0x1a28, 0x1618, 0x1816, 0x2331, 0x1d25, 0x3a28,\r\n0x3d33, 0x393c, 0x3833, 0x4037, 0x5c48, 0x404e, 0x5744, 0x3745,\r\n0x5038, 0x516d, 0x5f57, 0x6762, 0x6768, 0x4d3e, 0x7971, 0x6470,\r\n0x5c78, 0x6765, 0xff63,\r\n0xdbff, 0x4300, 0x1101, 0x1212, 0x1518, 0x2f18, 0x1a1a, 0x632f,\r\n0x3842, 0x6342, 0x6363, 0x6363, 0x6363, 0x6363, 0x6363, 0x6363,\r\n0x6363, 0x6363, 0x6363, 0x6363, 0x6363, 0x6363, 0x6363, 0x6363,\r\n0x6363, 0x6363, 0x6363, 0x6363, 0x6363, 0x6363, 0x6363, 0x6363,\r\n0x6363, 0x6363, 0xff63,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x0d00, 0x0a09, 0x0a0b, 0x0d08, 0x0a0b, 0x0e0b,\r\n0x0d0e, 0x130f, 0x1520, 0x1213, 0x1312, 0x1c27, 0x171e, 0x2e20,\r\n0x3129, 0x2e30, 0x2d29, 0x332c, 0x4a3a, 0x333e, 0x4636, 0x2c37,\r\n0x402d, 0x4157, 0x4c46, 0x524e, 0x5253, 0x3e32, 0x615a, 0x505a,\r\n0x4a60, 0x5251, 0xff4f,\r\n0xdbff, 0x4300, 0x0e01, 0x0e0e, 0x1113, 0x2613, 0x1515, 0x4f26,\r\n0x2d35, 0x4f35, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f,\r\n0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f,\r\n0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f, 0x4f4f,\r\n0x4f4f, 0x4f4f, 0xff4f,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x0a00, 0x0707, 0x0708, 0x0a06, 0x0808, 0x0b08,\r\n0x0a0a, 0x0e0b, 0x1018, 0x0d0e, 0x0e0d, 0x151d, 0x1116, 0x2318,\r\n0x251f, 0x2224, 0x221f, 0x2621, 0x372b, 0x262f, 0x3429, 0x2129,\r\n0x3022, 0x3141, 0x3934, 0x3e3b, 0x3e3e, 0x2e25, 0x4944, 0x3c43,\r\n0x3748, 0x3e3d, 0xff3b,\r\n0xdbff, 0x4300, 0x0a01, 0x0b0b, 0x0d0e, 0x1c0e, 0x1010, 0x3b1c,\r\n0x2228, 0x3b28, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b,\r\n0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b,\r\n0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b, 0x3b3b,\r\n0x3b3b, 0x3b3b, 0xff3b,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x0600, 0x0504, 0x0506, 0x0604, 0x0506, 0x0706,\r\n0x0607, 0x0a08, 0x0a10, 0x090a, 0x0a09, 0x0e14, 0x0c0f, 0x1710,\r\n0x1814, 0x1718, 0x1614, 0x1a16, 0x251d, 0x1a1f, 0x231b, 0x161c,\r\n0x2016, 0x202c, 0x2623, 0x2927, 0x292a, 0x1f19, 0x302d, 0x282d,\r\n0x2530, 0x2928, 0xff28,\r\n0xdbff, 0x4300, 0x0701, 0x0707, 0x080a, 0x130a, 0x0a0a, 0x2813,\r\n0x161a, 0x281a, 0x2828, 0x2828, 0x2828, 0x2828, 0x2828, 0x2828,\r\n0x2828, 0x2828, 0x2828, 0x2828, 0x2828, 0x2828, 0x2828, 0x2828,\r\n0x2828, 0x2828, 0x2828, 0x2828, 0x2828, 0x2828, 0x2828, 0x2828,\r\n0x2828, 0x2828, 0xff28,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x0300, 0x0202, 0x0203, 0x0302, 0x0303, 0x0403,\r\n0x0303, 0x0504, 0x0508, 0x0405, 0x0504, 0x070a, 0x0607, 0x0c08,\r\n0x0c0a, 0x0b0c, 0x0b0a, 0x0d0b, 0x120e, 0x0d10, 0x110e, 0x0b0e,\r\n0x100b, 0x1016, 0x1311, 0x1514, 0x1515, 0x0f0c, 0x1817, 0x1416,\r\n0x1218, 0x1514, 0xff14,\r\n0xdbff, 0x4300, 0x0301, 0x0404, 0x0405, 0x0905, 0x0505, 0x1409,\r\n0x0b0d, 0x140d, 0x1414, 0x1414, 0x1414, 0x1414, 0x1414, 0x1414,\r\n0x1414, 0x1414, 0x1414, 0x1414, 0x1414, 0x1414, 0x1414, 0x1414,\r\n0x1414, 0x1414, 0x1414, 0x1414, 0x1414, 0x1414, 0x1414, 0x1414,\r\n0x1414, 0x1414, 0xff14,\r\n},\r\n{\r\n0xdbff, 0x4300, 0x0100, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0101, 0x0101, 0xff01,\r\n0xdbff, 0x4300, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0101, 0x0101, 0xff01,\r\n} };\r\nif (quality < 0 || quality > 10) {\r\nprintk(KERN_WARNING\r\n"meye: invalid quality level %d - using 8\n", quality);\r\nquality = 8;\r\n}\r\n*length = ARRAY_SIZE(jpeg_tables[quality]);\r\nreturn jpeg_tables[quality];\r\n}\r\nstatic u16 *jpeg_huffman_tables(int *length)\r\n{\r\nstatic u16 tables[] = {\r\n0xC4FF, 0xB500, 0x0010, 0x0102, 0x0303, 0x0402, 0x0503, 0x0405,\r\n0x0004, 0x0100, 0x017D, 0x0302, 0x0400, 0x0511, 0x2112, 0x4131,\r\n0x1306, 0x6151, 0x2207, 0x1471, 0x8132, 0xA191, 0x2308, 0xB142,\r\n0x15C1, 0xD152, 0x24F0, 0x6233, 0x8272, 0x0A09, 0x1716, 0x1918,\r\n0x251A, 0x2726, 0x2928, 0x342A, 0x3635, 0x3837, 0x3A39, 0x4443,\r\n0x4645, 0x4847, 0x4A49, 0x5453, 0x5655, 0x5857, 0x5A59, 0x6463,\r\n0x6665, 0x6867, 0x6A69, 0x7473, 0x7675, 0x7877, 0x7A79, 0x8483,\r\n0x8685, 0x8887, 0x8A89, 0x9392, 0x9594, 0x9796, 0x9998, 0xA29A,\r\n0xA4A3, 0xA6A5, 0xA8A7, 0xAAA9, 0xB3B2, 0xB5B4, 0xB7B6, 0xB9B8,\r\n0xC2BA, 0xC4C3, 0xC6C5, 0xC8C7, 0xCAC9, 0xD3D2, 0xD5D4, 0xD7D6,\r\n0xD9D8, 0xE1DA, 0xE3E2, 0xE5E4, 0xE7E6, 0xE9E8, 0xF1EA, 0xF3F2,\r\n0xF5F4, 0xF7F6, 0xF9F8, 0xFFFA,\r\n0xC4FF, 0xB500, 0x0011, 0x0102, 0x0402, 0x0304, 0x0704, 0x0405,\r\n0x0004, 0x0201, 0x0077, 0x0201, 0x1103, 0x0504, 0x3121, 0x1206,\r\n0x5141, 0x6107, 0x1371, 0x3222, 0x0881, 0x4214, 0xA191, 0xC1B1,\r\n0x2309, 0x5233, 0x15F0, 0x7262, 0x0AD1, 0x2416, 0xE134, 0xF125,\r\n0x1817, 0x1A19, 0x2726, 0x2928, 0x352A, 0x3736, 0x3938, 0x433A,\r\n0x4544, 0x4746, 0x4948, 0x534A, 0x5554, 0x5756, 0x5958, 0x635A,\r\n0x6564, 0x6766, 0x6968, 0x736A, 0x7574, 0x7776, 0x7978, 0x827A,\r\n0x8483, 0x8685, 0x8887, 0x8A89, 0x9392, 0x9594, 0x9796, 0x9998,\r\n0xA29A, 0xA4A3, 0xA6A5, 0xA8A7, 0xAAA9, 0xB3B2, 0xB5B4, 0xB7B6,\r\n0xB9B8, 0xC2BA, 0xC4C3, 0xC6C5, 0xC8C7, 0xCAC9, 0xD3D2, 0xD5D4,\r\n0xD7D6, 0xD9D8, 0xE2DA, 0xE4E3, 0xE6E5, 0xE8E7, 0xEAE9, 0xF3F2,\r\n0xF5F4, 0xF7F6, 0xF9F8, 0xFFFA,\r\n0xC4FF, 0x1F00, 0x0000, 0x0501, 0x0101, 0x0101, 0x0101, 0x0000,\r\n0x0000, 0x0000, 0x0000, 0x0201, 0x0403, 0x0605, 0x0807, 0x0A09,\r\n0xFF0B,\r\n0xC4FF, 0x1F00, 0x0001, 0x0103, 0x0101, 0x0101, 0x0101, 0x0101,\r\n0x0000, 0x0000, 0x0000, 0x0201, 0x0403, 0x0605, 0x0807, 0x0A09,\r\n0xFF0B\r\n};\r\n*length = ARRAY_SIZE(tables);\r\nreturn tables;\r\n}\r\nstatic inline int mchip_hsize(void)\r\n{\r\nreturn meye.params.subsample ? 320 : 640;\r\n}\r\nstatic inline int mchip_vsize(void)\r\n{\r\nreturn meye.params.subsample ? 240 : 480;\r\n}\r\nstatic void mchip_sync(int reg)\r\n{\r\nu32 status;\r\nint i;\r\nif (reg == MCHIP_MM_FIFO_DATA) {\r\nfor (i = 0; i < MCHIP_REG_TIMEOUT; i++) {\r\nstatus = readl(meye.mchip_mmregs +\r\nMCHIP_MM_FIFO_STATUS);\r\nif (!(status & MCHIP_MM_FIFO_WAIT)) {\r\nprintk(KERN_WARNING "meye: fifo not ready\n");\r\nreturn;\r\n}\r\nif (status & MCHIP_MM_FIFO_READY)\r\nreturn;\r\nudelay(1);\r\n}\r\n} else if (reg > 0x80) {\r\nu32 mask = (reg < 0x100) ? MCHIP_HIC_STATUS_MCC_RDY\r\n: MCHIP_HIC_STATUS_VRJ_RDY;\r\nfor (i = 0; i < MCHIP_REG_TIMEOUT; i++) {\r\nstatus = readl(meye.mchip_mmregs + MCHIP_HIC_STATUS);\r\nif (status & mask)\r\nreturn;\r\nudelay(1);\r\n}\r\n} else\r\nreturn;\r\nprintk(KERN_WARNING\r\n"meye: mchip_sync() timeout on reg 0x%x status=0x%x\n",\r\nreg, status);\r\n}\r\nstatic inline void mchip_set(int reg, u32 v)\r\n{\r\nmchip_sync(reg);\r\nwritel(v, meye.mchip_mmregs + reg);\r\n}\r\nstatic inline u32 mchip_read(int reg)\r\n{\r\nmchip_sync(reg);\r\nreturn readl(meye.mchip_mmregs + reg);\r\n}\r\nstatic inline int mchip_delay(u32 reg, u32 v)\r\n{\r\nint n = 10;\r\nwhile (--n && mchip_read(reg) != v)\r\nudelay(1);\r\nreturn n;\r\n}\r\nstatic void mchip_subsample(void)\r\n{\r\nmchip_set(MCHIP_MCC_R_SAMPLING, meye.params.subsample);\r\nmchip_set(MCHIP_MCC_R_XRANGE, mchip_hsize());\r\nmchip_set(MCHIP_MCC_R_YRANGE, mchip_vsize());\r\nmchip_set(MCHIP_MCC_B_XRANGE, mchip_hsize());\r\nmchip_set(MCHIP_MCC_B_YRANGE, mchip_vsize());\r\nmchip_delay(MCHIP_HIC_STATUS, MCHIP_HIC_STATUS_IDLE);\r\n}\r\nstatic void mchip_set_framerate(void)\r\n{\r\nmchip_set(MCHIP_HIC_S_RATE, meye.params.framerate);\r\n}\r\nstatic void mchip_load_tables(void)\r\n{\r\nint i;\r\nint length;\r\nu16 *tables;\r\ntables = jpeg_huffman_tables(&length);\r\nfor (i = 0; i < length; i++)\r\nwritel(tables[i], meye.mchip_mmregs + MCHIP_VRJ_TABLE_DATA);\r\ntables = jpeg_quantisation_tables(&length, meye.params.quality);\r\nfor (i = 0; i < length; i++)\r\nwritel(tables[i], meye.mchip_mmregs + MCHIP_VRJ_TABLE_DATA);\r\n}\r\nstatic void mchip_vrj_setup(u8 mode)\r\n{\r\nmchip_set(MCHIP_VRJ_BUS_MODE, 5);\r\nmchip_set(MCHIP_VRJ_SIGNAL_ACTIVE_LEVEL, 0x1f);\r\nmchip_set(MCHIP_VRJ_PDAT_USE, 1);\r\nmchip_set(MCHIP_VRJ_IRQ_FLAG, 0xa0);\r\nmchip_set(MCHIP_VRJ_MODE_SPECIFY, mode);\r\nmchip_set(MCHIP_VRJ_NUM_LINES, mchip_vsize());\r\nmchip_set(MCHIP_VRJ_NUM_PIXELS, mchip_hsize());\r\nmchip_set(MCHIP_VRJ_NUM_COMPONENTS, 0x1b);\r\nmchip_set(MCHIP_VRJ_LIMIT_COMPRESSED_LO, 0xFFFF);\r\nmchip_set(MCHIP_VRJ_LIMIT_COMPRESSED_HI, 0xFFFF);\r\nmchip_set(MCHIP_VRJ_COMP_DATA_FORMAT, 0xC);\r\nmchip_set(MCHIP_VRJ_RESTART_INTERVAL, 0);\r\nmchip_set(MCHIP_VRJ_SOF1, 0x601);\r\nmchip_set(MCHIP_VRJ_SOF2, 0x1502);\r\nmchip_set(MCHIP_VRJ_SOF3, 0x1503);\r\nmchip_set(MCHIP_VRJ_SOF4, 0x1596);\r\nmchip_set(MCHIP_VRJ_SOS, 0x0ed0);\r\nmchip_load_tables();\r\n}\r\nstatic void mchip_dma_setup(dma_addr_t dma_addr)\r\n{\r\nint i;\r\nmchip_set(MCHIP_MM_PT_ADDR, (u32)dma_addr);\r\nfor (i = 0; i < 4; i++)\r\nmchip_set(MCHIP_MM_FIR(i), 0);\r\nmeye.mchip_fnum = 0;\r\n}\r\nstatic int mchip_dma_alloc(void)\r\n{\r\nif (!meye.mchip_dmahandle)\r\nif (ptable_alloc())\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void mchip_dma_free(void)\r\n{\r\nif (meye.mchip_dmahandle) {\r\nmchip_dma_setup(0);\r\nptable_free();\r\n}\r\n}\r\nstatic void mchip_hic_stop(void)\r\n{\r\nint i, j;\r\nmeye.mchip_mode = MCHIP_HIC_MODE_NOOP;\r\nif (!(mchip_read(MCHIP_HIC_STATUS) & MCHIP_HIC_STATUS_BUSY))\r\nreturn;\r\nfor (i = 0; i < 20; ++i) {\r\nmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_STOP);\r\nmchip_delay(MCHIP_HIC_CMD, 0);\r\nfor (j = 0; j < 100; ++j) {\r\nif (mchip_delay(MCHIP_HIC_STATUS,\r\nMCHIP_HIC_STATUS_IDLE))\r\nreturn;\r\nmsleep(1);\r\n}\r\nprintk(KERN_ERR "meye: need to reset HIC!\n");\r\nmchip_set(MCHIP_HIC_CTL, MCHIP_HIC_CTL_SOFT_RESET);\r\nmsleep(250);\r\n}\r\nprintk(KERN_ERR "meye: resetting HIC hanged!\n");\r\n}\r\nstatic u32 mchip_get_frame(void)\r\n{\r\nu32 v;\r\nv = mchip_read(MCHIP_MM_FIR(meye.mchip_fnum));\r\nreturn v;\r\n}\r\nstatic void mchip_free_frame(void)\r\n{\r\nmchip_set(MCHIP_MM_FIR(meye.mchip_fnum), 0);\r\nmeye.mchip_fnum++;\r\nmeye.mchip_fnum %= 4;\r\n}\r\nstatic void mchip_cont_read_frame(u32 v, u8 *buf, int size)\r\n{\r\nint pt_id;\r\npt_id = (v >> 17) & 0x3FF;\r\nptable_copy(buf, pt_id, size, MCHIP_NB_PAGES);\r\n}\r\nstatic int mchip_comp_read_frame(u32 v, u8 *buf, int size)\r\n{\r\nint pt_start, pt_end, trailer;\r\nint fsize;\r\nint i;\r\npt_start = (v >> 19) & 0xFF;\r\npt_end = (v >> 11) & 0xFF;\r\ntrailer = (v >> 1) & 0x3FF;\r\nif (pt_end < pt_start)\r\nfsize = (MCHIP_NB_PAGES_MJPEG - pt_start) * PAGE_SIZE +\r\npt_end * PAGE_SIZE + trailer * 4;\r\nelse\r\nfsize = (pt_end - pt_start) * PAGE_SIZE + trailer * 4;\r\nif (fsize > size) {\r\nprintk(KERN_WARNING "meye: oversized compressed frame %d\n",\r\nfsize);\r\nreturn -1;\r\n}\r\nptable_copy(buf, pt_start, fsize, MCHIP_NB_PAGES_MJPEG);\r\n#ifdef MEYE_JPEG_CORRECTION\r\nfor (i = fsize - 1; i > 0 && buf[i] == 0xff; i--) ;\r\nif (i < 2 || buf[i - 1] != 0xff || buf[i] != 0xd9)\r\nreturn -1;\r\n#endif\r\nreturn fsize;\r\n}\r\nstatic void mchip_take_picture(void)\r\n{\r\nint i;\r\nmchip_hic_stop();\r\nmchip_subsample();\r\nmchip_dma_setup(meye.mchip_dmahandle);\r\nmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_STILL_CAP);\r\nmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\r\nmchip_delay(MCHIP_HIC_CMD, 0);\r\nfor (i = 0; i < 100; ++i) {\r\nif (mchip_delay(MCHIP_HIC_STATUS, MCHIP_HIC_STATUS_IDLE))\r\nbreak;\r\nmsleep(1);\r\n}\r\n}\r\nstatic void mchip_get_picture(u8 *buf, int bufsize)\r\n{\r\nu32 v;\r\nint i;\r\nmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_STILL_OUT);\r\nmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\r\nmchip_delay(MCHIP_HIC_CMD, 0);\r\nfor (i = 0; i < 100; ++i) {\r\nif (mchip_delay(MCHIP_HIC_STATUS, MCHIP_HIC_STATUS_IDLE))\r\nbreak;\r\nmsleep(1);\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nv = mchip_get_frame();\r\nif (v & MCHIP_MM_FIR_RDY) {\r\nmchip_cont_read_frame(v, buf, bufsize);\r\nbreak;\r\n}\r\nmchip_free_frame();\r\n}\r\n}\r\nstatic void mchip_continuous_start(void)\r\n{\r\nmchip_hic_stop();\r\nmchip_subsample();\r\nmchip_set_framerate();\r\nmchip_dma_setup(meye.mchip_dmahandle);\r\nmeye.mchip_mode = MCHIP_HIC_MODE_CONT_OUT;\r\nmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_CONT_OUT);\r\nmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\r\nmchip_delay(MCHIP_HIC_CMD, 0);\r\n}\r\nstatic int mchip_compress_frame(u8 *buf, int bufsize)\r\n{\r\nu32 v;\r\nint len = -1, i;\r\nmchip_vrj_setup(0x3f);\r\nudelay(50);\r\nmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_STILL_COMP);\r\nmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\r\nmchip_delay(MCHIP_HIC_CMD, 0);\r\nfor (i = 0; i < 100; ++i) {\r\nif (mchip_delay(MCHIP_HIC_STATUS, MCHIP_HIC_STATUS_IDLE))\r\nbreak;\r\nmsleep(1);\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nv = mchip_get_frame();\r\nif (v & MCHIP_MM_FIR_RDY) {\r\nlen = mchip_comp_read_frame(v, buf, bufsize);\r\nbreak;\r\n}\r\nmchip_free_frame();\r\n}\r\nreturn len;\r\n}\r\nstatic void mchip_cont_compression_start(void)\r\n{\r\nmchip_hic_stop();\r\nmchip_vrj_setup(0x3f);\r\nmchip_subsample();\r\nmchip_set_framerate();\r\nmchip_dma_setup(meye.mchip_dmahandle);\r\nmeye.mchip_mode = MCHIP_HIC_MODE_CONT_COMP;\r\nmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_CONT_COMP);\r\nmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\r\nmchip_delay(MCHIP_HIC_CMD, 0);\r\n}\r\nstatic irqreturn_t meye_irq(int irq, void *dev_id)\r\n{\r\nu32 v;\r\nint reqnr;\r\nstatic int sequence;\r\nv = mchip_read(MCHIP_MM_INTA);\r\nif (meye.mchip_mode != MCHIP_HIC_MODE_CONT_OUT &&\r\nmeye.mchip_mode != MCHIP_HIC_MODE_CONT_COMP)\r\nreturn IRQ_NONE;\r\nagain:\r\nv = mchip_get_frame();\r\nif (!(v & MCHIP_MM_FIR_RDY))\r\nreturn IRQ_HANDLED;\r\nif (meye.mchip_mode == MCHIP_HIC_MODE_CONT_OUT) {\r\nif (kfifo_out_locked(&meye.grabq, (unsigned char *)&reqnr,\r\nsizeof(int), &meye.grabq_lock) != sizeof(int)) {\r\nmchip_free_frame();\r\nreturn IRQ_HANDLED;\r\n}\r\nmchip_cont_read_frame(v, meye.grab_fbuffer + gbufsize * reqnr,\r\nmchip_hsize() * mchip_vsize() * 2);\r\nmeye.grab_buffer[reqnr].size = mchip_hsize() * mchip_vsize() * 2;\r\nmeye.grab_buffer[reqnr].state = MEYE_BUF_DONE;\r\ndo_gettimeofday(&meye.grab_buffer[reqnr].timestamp);\r\nmeye.grab_buffer[reqnr].sequence = sequence++;\r\nkfifo_in_locked(&meye.doneq, (unsigned char *)&reqnr,\r\nsizeof(int), &meye.doneq_lock);\r\nwake_up_interruptible(&meye.proc_list);\r\n} else {\r\nint size;\r\nsize = mchip_comp_read_frame(v, meye.grab_temp, gbufsize);\r\nif (size == -1) {\r\nmchip_free_frame();\r\ngoto again;\r\n}\r\nif (kfifo_out_locked(&meye.grabq, (unsigned char *)&reqnr,\r\nsizeof(int), &meye.grabq_lock) != sizeof(int)) {\r\nmchip_free_frame();\r\ngoto again;\r\n}\r\nmemcpy(meye.grab_fbuffer + gbufsize * reqnr, meye.grab_temp,\r\nsize);\r\nmeye.grab_buffer[reqnr].size = size;\r\nmeye.grab_buffer[reqnr].state = MEYE_BUF_DONE;\r\ndo_gettimeofday(&meye.grab_buffer[reqnr].timestamp);\r\nmeye.grab_buffer[reqnr].sequence = sequence++;\r\nkfifo_in_locked(&meye.doneq, (unsigned char *)&reqnr,\r\nsizeof(int), &meye.doneq_lock);\r\nwake_up_interruptible(&meye.proc_list);\r\n}\r\nmchip_free_frame();\r\ngoto again;\r\n}\r\nstatic int meye_open(struct file *file)\r\n{\r\nint i;\r\nif (test_and_set_bit(0, &meye.in_use))\r\nreturn -EBUSY;\r\nmchip_hic_stop();\r\nif (mchip_dma_alloc()) {\r\nprintk(KERN_ERR "meye: mchip framebuffer allocation failed\n");\r\nclear_bit(0, &meye.in_use);\r\nreturn -ENOBUFS;\r\n}\r\nfor (i = 0; i < MEYE_MAX_BUFNBRS; i++)\r\nmeye.grab_buffer[i].state = MEYE_BUF_UNUSED;\r\nkfifo_reset(&meye.grabq);\r\nkfifo_reset(&meye.doneq);\r\nreturn 0;\r\n}\r\nstatic int meye_release(struct file *file)\r\n{\r\nmchip_hic_stop();\r\nmchip_dma_free();\r\nclear_bit(0, &meye.in_use);\r\nreturn 0;\r\n}\r\nstatic int meyeioc_g_params(struct meye_params *p)\r\n{\r\n*p = meye.params;\r\nreturn 0;\r\n}\r\nstatic int meyeioc_s_params(struct meye_params *jp)\r\n{\r\nif (jp->subsample > 1)\r\nreturn -EINVAL;\r\nif (jp->quality > 10)\r\nreturn -EINVAL;\r\nif (jp->sharpness > 63 || jp->agc > 63 || jp->picture > 63)\r\nreturn -EINVAL;\r\nif (jp->framerate > 31)\r\nreturn -EINVAL;\r\nmutex_lock(&meye.lock);\r\nif (meye.params.subsample != jp->subsample ||\r\nmeye.params.quality != jp->quality)\r\nmchip_hic_stop();\r\nmeye.params = *jp;\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERASHARPNESS,\r\nmeye.params.sharpness);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERAAGC,\r\nmeye.params.agc);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERAPICTURE,\r\nmeye.params.picture);\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int meyeioc_qbuf_capt(int *nb)\r\n{\r\nif (!meye.grab_fbuffer)\r\nreturn -EINVAL;\r\nif (*nb >= gbuffers)\r\nreturn -EINVAL;\r\nif (*nb < 0) {\r\nmchip_hic_stop();\r\nreturn 0;\r\n}\r\nif (meye.grab_buffer[*nb].state != MEYE_BUF_UNUSED)\r\nreturn -EBUSY;\r\nmutex_lock(&meye.lock);\r\nif (meye.mchip_mode != MCHIP_HIC_MODE_CONT_COMP)\r\nmchip_cont_compression_start();\r\nmeye.grab_buffer[*nb].state = MEYE_BUF_USING;\r\nkfifo_in_locked(&meye.grabq, (unsigned char *)nb, sizeof(int),\r\n&meye.grabq_lock);\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int meyeioc_sync(struct file *file, void *fh, int *i)\r\n{\r\nint unused;\r\nif (*i < 0 || *i >= gbuffers)\r\nreturn -EINVAL;\r\nmutex_lock(&meye.lock);\r\nswitch (meye.grab_buffer[*i].state) {\r\ncase MEYE_BUF_UNUSED:\r\nmutex_unlock(&meye.lock);\r\nreturn -EINVAL;\r\ncase MEYE_BUF_USING:\r\nif (file->f_flags & O_NONBLOCK) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EAGAIN;\r\n}\r\nif (wait_event_interruptible(meye.proc_list,\r\n(meye.grab_buffer[*i].state != MEYE_BUF_USING))) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EINTR;\r\n}\r\ncase MEYE_BUF_DONE:\r\nmeye.grab_buffer[*i].state = MEYE_BUF_UNUSED;\r\nif (kfifo_out_locked(&meye.doneq, (unsigned char *)&unused,\r\nsizeof(int), &meye.doneq_lock) != sizeof(int))\r\nbreak;\r\n}\r\n*i = meye.grab_buffer[*i].size;\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int meyeioc_stillcapt(void)\r\n{\r\nif (!meye.grab_fbuffer)\r\nreturn -EINVAL;\r\nif (meye.grab_buffer[0].state != MEYE_BUF_UNUSED)\r\nreturn -EBUSY;\r\nmutex_lock(&meye.lock);\r\nmeye.grab_buffer[0].state = MEYE_BUF_USING;\r\nmchip_take_picture();\r\nmchip_get_picture(meye.grab_fbuffer,\r\nmchip_hsize() * mchip_vsize() * 2);\r\nmeye.grab_buffer[0].state = MEYE_BUF_DONE;\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int meyeioc_stilljcapt(int *len)\r\n{\r\nif (!meye.grab_fbuffer)\r\nreturn -EINVAL;\r\nif (meye.grab_buffer[0].state != MEYE_BUF_UNUSED)\r\nreturn -EBUSY;\r\nmutex_lock(&meye.lock);\r\nmeye.grab_buffer[0].state = MEYE_BUF_USING;\r\n*len = -1;\r\nwhile (*len == -1) {\r\nmchip_take_picture();\r\n*len = mchip_compress_frame(meye.grab_fbuffer, gbufsize);\r\n}\r\nmeye.grab_buffer[0].state = MEYE_BUF_DONE;\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrcpy(cap->driver, "meye");\r\nstrcpy(cap->card, "meye");\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(meye.mchip_dev));\r\ncap->version = (MEYE_DRIVER_MAJORVERSION << 8) +\r\nMEYE_DRIVER_MINORVERSION;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(i->name, "Camera");\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int i)\r\n{\r\nif (i != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *fh,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Brightness");\r\nc->minimum = 0;\r\nc->maximum = 63;\r\nc->step = 1;\r\nc->default_value = 32;\r\nc->flags = 0;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Hue");\r\nc->minimum = 0;\r\nc->maximum = 63;\r\nc->step = 1;\r\nc->default_value = 32;\r\nc->flags = 0;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Contrast");\r\nc->minimum = 0;\r\nc->maximum = 63;\r\nc->step = 1;\r\nc->default_value = 32;\r\nc->flags = 0;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Saturation");\r\nc->minimum = 0;\r\nc->maximum = 63;\r\nc->step = 1;\r\nc->default_value = 32;\r\nc->flags = 0;\r\nbreak;\r\ncase V4L2_CID_AGC:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Agc");\r\nc->minimum = 0;\r\nc->maximum = 63;\r\nc->step = 1;\r\nc->default_value = 48;\r\nc->flags = 0;\r\nbreak;\r\ncase V4L2_CID_MEYE_SHARPNESS:\r\ncase V4L2_CID_SHARPNESS:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Sharpness");\r\nc->minimum = 0;\r\nc->maximum = 63;\r\nc->step = 1;\r\nc->default_value = 32;\r\nc->flags = (c->id == V4L2_CID_SHARPNESS) ? 0 :\r\nV4L2_CTRL_FLAG_DISABLED;\r\nbreak;\r\ncase V4L2_CID_PICTURE:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Picture");\r\nc->minimum = 0;\r\nc->maximum = 63;\r\nc->step = 1;\r\nc->default_value = 0;\r\nc->flags = 0;\r\nbreak;\r\ncase V4L2_CID_JPEGQUAL:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "JPEG quality");\r\nc->minimum = 0;\r\nc->maximum = 10;\r\nc->step = 1;\r\nc->default_value = 8;\r\nc->flags = 0;\r\nbreak;\r\ncase V4L2_CID_FRAMERATE:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Framerate");\r\nc->minimum = 0;\r\nc->maximum = 31;\r\nc->step = 1;\r\nc->default_value = 0;\r\nc->flags = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c)\r\n{\r\nmutex_lock(&meye.lock);\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsony_pic_camera_command(\r\nSONY_PIC_COMMAND_SETCAMERABRIGHTNESS, c->value);\r\nmeye.brightness = c->value << 10;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nsony_pic_camera_command(\r\nSONY_PIC_COMMAND_SETCAMERAHUE, c->value);\r\nmeye.hue = c->value << 10;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsony_pic_camera_command(\r\nSONY_PIC_COMMAND_SETCAMERACONTRAST, c->value);\r\nmeye.contrast = c->value << 10;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsony_pic_camera_command(\r\nSONY_PIC_COMMAND_SETCAMERACOLOR, c->value);\r\nmeye.colour = c->value << 10;\r\nbreak;\r\ncase V4L2_CID_AGC:\r\nsony_pic_camera_command(\r\nSONY_PIC_COMMAND_SETCAMERAAGC, c->value);\r\nmeye.params.agc = c->value;\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\ncase V4L2_CID_MEYE_SHARPNESS:\r\nsony_pic_camera_command(\r\nSONY_PIC_COMMAND_SETCAMERASHARPNESS, c->value);\r\nmeye.params.sharpness = c->value;\r\nbreak;\r\ncase V4L2_CID_PICTURE:\r\nsony_pic_camera_command(\r\nSONY_PIC_COMMAND_SETCAMERAPICTURE, c->value);\r\nmeye.params.picture = c->value;\r\nbreak;\r\ncase V4L2_CID_JPEGQUAL:\r\nmeye.params.quality = c->value;\r\nbreak;\r\ncase V4L2_CID_FRAMERATE:\r\nmeye.params.framerate = c->value;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&meye.lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *c)\r\n{\r\nmutex_lock(&meye.lock);\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nc->value = meye.brightness >> 10;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nc->value = meye.hue >> 10;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nc->value = meye.contrast >> 10;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nc->value = meye.colour >> 10;\r\nbreak;\r\ncase V4L2_CID_AGC:\r\nc->value = meye.params.agc;\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\ncase V4L2_CID_MEYE_SHARPNESS:\r\nc->value = meye.params.sharpness;\r\nbreak;\r\ncase V4L2_CID_PICTURE:\r\nc->value = meye.params.picture;\r\nbreak;\r\ncase V4L2_CID_JPEGQUAL:\r\nc->value = meye.params.quality;\r\nbreak;\r\ncase V4L2_CID_FRAMERATE:\r\nc->value = meye.params.framerate;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&meye.lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index > 1)\r\nreturn -EINVAL;\r\nif (f->index == 0) {\r\nf->flags = 0;\r\nstrcpy(f->description, "YUV422");\r\nf->pixelformat = V4L2_PIX_FMT_YUYV;\r\n} else {\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nstrcpy(f->description, "MJPEG");\r\nf->pixelformat = V4L2_PIX_FMT_MJPEG;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nif (f->fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV &&\r\nf->fmt.pix.pixelformat != V4L2_PIX_FMT_MJPEG)\r\nreturn -EINVAL;\r\nif (f->fmt.pix.field != V4L2_FIELD_ANY &&\r\nf->fmt.pix.field != V4L2_FIELD_NONE)\r\nreturn -EINVAL;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nif (f->fmt.pix.width <= 320) {\r\nf->fmt.pix.width = 320;\r\nf->fmt.pix.height = 240;\r\n} else {\r\nf->fmt.pix.width = 640;\r\nf->fmt.pix.height = 480;\r\n}\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height *\r\nf->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nswitch (meye.mchip_mode) {\r\ncase MCHIP_HIC_MODE_CONT_OUT:\r\ndefault:\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;\r\nbreak;\r\ncase MCHIP_HIC_MODE_CONT_COMP:\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;\r\nbreak;\r\n}\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.width = mchip_hsize();\r\nf->fmt.pix.height = mchip_vsize();\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height *\r\nf->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nif (f->fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV &&\r\nf->fmt.pix.pixelformat != V4L2_PIX_FMT_MJPEG)\r\nreturn -EINVAL;\r\nif (f->fmt.pix.field != V4L2_FIELD_ANY &&\r\nf->fmt.pix.field != V4L2_FIELD_NONE)\r\nreturn -EINVAL;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nmutex_lock(&meye.lock);\r\nif (f->fmt.pix.width <= 320) {\r\nf->fmt.pix.width = 320;\r\nf->fmt.pix.height = 240;\r\nmeye.params.subsample = 1;\r\n} else {\r\nf->fmt.pix.width = 640;\r\nf->fmt.pix.height = 480;\r\nmeye.params.subsample = 0;\r\n}\r\nswitch (f->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\nmeye.mchip_mode = MCHIP_HIC_MODE_CONT_OUT;\r\nbreak;\r\ncase V4L2_PIX_FMT_MJPEG:\r\nmeye.mchip_mode = MCHIP_HIC_MODE_CONT_COMP;\r\nbreak;\r\n}\r\nmutex_unlock(&meye.lock);\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height *\r\nf->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *fh,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nint i;\r\nif (req->memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nif (meye.grab_fbuffer && req->count == gbuffers) {\r\nreturn 0;\r\n}\r\nmutex_lock(&meye.lock);\r\nif (meye.grab_fbuffer) {\r\nfor (i = 0; i < gbuffers; i++)\r\nif (meye.vma_use_count[i]) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EINVAL;\r\n}\r\nrvfree(meye.grab_fbuffer, gbuffers * gbufsize);\r\nmeye.grab_fbuffer = NULL;\r\n}\r\ngbuffers = max(2, min((int)req->count, MEYE_MAX_BUFNBRS));\r\nreq->count = gbuffers;\r\nmeye.grab_fbuffer = rvmalloc(gbuffers * gbufsize);\r\nif (!meye.grab_fbuffer) {\r\nprintk(KERN_ERR "meye: v4l framebuffer allocation"\r\n" failed\n");\r\nmutex_unlock(&meye.lock);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < gbuffers; i++)\r\nmeye.vma_use_count[i] = 0;\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *buf)\r\n{\r\nunsigned int index = buf->index;\r\nif (index >= gbuffers)\r\nreturn -EINVAL;\r\nbuf->bytesused = meye.grab_buffer[index].size;\r\nbuf->flags = V4L2_BUF_FLAG_MAPPED;\r\nif (meye.grab_buffer[index].state == MEYE_BUF_USING)\r\nbuf->flags |= V4L2_BUF_FLAG_QUEUED;\r\nif (meye.grab_buffer[index].state == MEYE_BUF_DONE)\r\nbuf->flags |= V4L2_BUF_FLAG_DONE;\r\nbuf->field = V4L2_FIELD_NONE;\r\nbuf->timestamp = meye.grab_buffer[index].timestamp;\r\nbuf->sequence = meye.grab_buffer[index].sequence;\r\nbuf->memory = V4L2_MEMORY_MMAP;\r\nbuf->m.offset = index * gbufsize;\r\nbuf->length = gbufsize;\r\nreturn 0;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\r\n{\r\nif (buf->memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nif (buf->index >= gbuffers)\r\nreturn -EINVAL;\r\nif (meye.grab_buffer[buf->index].state != MEYE_BUF_UNUSED)\r\nreturn -EINVAL;\r\nmutex_lock(&meye.lock);\r\nbuf->flags |= V4L2_BUF_FLAG_QUEUED;\r\nbuf->flags &= ~V4L2_BUF_FLAG_DONE;\r\nmeye.grab_buffer[buf->index].state = MEYE_BUF_USING;\r\nkfifo_in_locked(&meye.grabq, (unsigned char *)&buf->index,\r\nsizeof(int), &meye.grabq_lock);\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\r\n{\r\nint reqnr;\r\nif (buf->memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nmutex_lock(&meye.lock);\r\nif (kfifo_len(&meye.doneq) == 0 && file->f_flags & O_NONBLOCK) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EAGAIN;\r\n}\r\nif (wait_event_interruptible(meye.proc_list,\r\nkfifo_len(&meye.doneq) != 0) < 0) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EINTR;\r\n}\r\nif (!kfifo_out_locked(&meye.doneq, (unsigned char *)&reqnr,\r\nsizeof(int), &meye.doneq_lock)) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EBUSY;\r\n}\r\nif (meye.grab_buffer[reqnr].state != MEYE_BUF_DONE) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EINVAL;\r\n}\r\nbuf->index = reqnr;\r\nbuf->bytesused = meye.grab_buffer[reqnr].size;\r\nbuf->flags = V4L2_BUF_FLAG_MAPPED;\r\nbuf->field = V4L2_FIELD_NONE;\r\nbuf->timestamp = meye.grab_buffer[reqnr].timestamp;\r\nbuf->sequence = meye.grab_buffer[reqnr].sequence;\r\nbuf->memory = V4L2_MEMORY_MMAP;\r\nbuf->m.offset = reqnr * gbufsize;\r\nbuf->length = gbufsize;\r\nmeye.grab_buffer[reqnr].state = MEYE_BUF_UNUSED;\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)\r\n{\r\nmutex_lock(&meye.lock);\r\nswitch (meye.mchip_mode) {\r\ncase MCHIP_HIC_MODE_CONT_OUT:\r\nmchip_continuous_start();\r\nbreak;\r\ncase MCHIP_HIC_MODE_CONT_COMP:\r\nmchip_cont_compression_start();\r\nbreak;\r\ndefault:\r\nmutex_unlock(&meye.lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)\r\n{\r\nmutex_lock(&meye.lock);\r\nmchip_hic_stop();\r\nkfifo_reset(&meye.grabq);\r\nkfifo_reset(&meye.doneq);\r\nfor (i = 0; i < MEYE_MAX_BUFNBRS; i++)\r\nmeye.grab_buffer[i].state = MEYE_BUF_UNUSED;\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic long vidioc_default(struct file *file, void *fh, bool valid_prio,\r\nint cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase MEYEIOC_G_PARAMS:\r\nreturn meyeioc_g_params((struct meye_params *) arg);\r\ncase MEYEIOC_S_PARAMS:\r\nreturn meyeioc_s_params((struct meye_params *) arg);\r\ncase MEYEIOC_QBUF_CAPT:\r\nreturn meyeioc_qbuf_capt((int *) arg);\r\ncase MEYEIOC_SYNC:\r\nreturn meyeioc_sync(file, fh, (int *) arg);\r\ncase MEYEIOC_STILLCAPT:\r\nreturn meyeioc_stillcapt();\r\ncase MEYEIOC_STILLJCAPT:\r\nreturn meyeioc_stilljcapt((int *) arg);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic unsigned int meye_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int res = 0;\r\nmutex_lock(&meye.lock);\r\npoll_wait(file, &meye.proc_list, wait);\r\nif (kfifo_len(&meye.doneq))\r\nres = POLLIN | POLLRDNORM;\r\nmutex_unlock(&meye.lock);\r\nreturn res;\r\n}\r\nstatic void meye_vm_open(struct vm_area_struct *vma)\r\n{\r\nlong idx = (long)vma->vm_private_data;\r\nmeye.vma_use_count[idx]++;\r\n}\r\nstatic void meye_vm_close(struct vm_area_struct *vma)\r\n{\r\nlong idx = (long)vma->vm_private_data;\r\nmeye.vma_use_count[idx]--;\r\n}\r\nstatic int meye_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nunsigned long start = vma->vm_start;\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nunsigned long page, pos;\r\nmutex_lock(&meye.lock);\r\nif (size > gbuffers * gbufsize) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EINVAL;\r\n}\r\nif (!meye.grab_fbuffer) {\r\nint i;\r\nmeye.grab_fbuffer = rvmalloc(gbuffers*gbufsize);\r\nif (!meye.grab_fbuffer) {\r\nprintk(KERN_ERR "meye: v4l framebuffer allocation failed\n");\r\nmutex_unlock(&meye.lock);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < gbuffers; i++)\r\nmeye.vma_use_count[i] = 0;\r\n}\r\npos = (unsigned long)meye.grab_fbuffer + offset;\r\nwhile (size > 0) {\r\npage = vmalloc_to_pfn((void *)pos);\r\nif (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED)) {\r\nmutex_unlock(&meye.lock);\r\nreturn -EAGAIN;\r\n}\r\nstart += PAGE_SIZE;\r\npos += PAGE_SIZE;\r\nif (size > PAGE_SIZE)\r\nsize -= PAGE_SIZE;\r\nelse\r\nsize = 0;\r\n}\r\nvma->vm_ops = &meye_vm_ops;\r\nvma->vm_flags &= ~VM_IO;\r\nvma->vm_flags |= VM_RESERVED;\r\nvma->vm_private_data = (void *) (offset / gbufsize);\r\nmeye_vm_open(vma);\r\nmutex_unlock(&meye.lock);\r\nreturn 0;\r\n}\r\nstatic int meye_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_save_state(pdev);\r\nmeye.pm_mchip_mode = meye.mchip_mode;\r\nmchip_hic_stop();\r\nmchip_set(MCHIP_MM_INTA, 0x0);\r\nreturn 0;\r\n}\r\nstatic int meye_resume(struct pci_dev *pdev)\r\n{\r\npci_restore_state(pdev);\r\npci_write_config_word(meye.mchip_dev, MCHIP_PCI_SOFTRESET_SET, 1);\r\nmchip_delay(MCHIP_HIC_CMD, 0);\r\nmchip_delay(MCHIP_HIC_STATUS, MCHIP_HIC_STATUS_IDLE);\r\nmsleep(1);\r\nmchip_set(MCHIP_VRJ_SOFT_RESET, 1);\r\nmsleep(1);\r\nmchip_set(MCHIP_MM_PCI_MODE, 5);\r\nmsleep(1);\r\nmchip_set(MCHIP_MM_INTA, MCHIP_MM_INTA_HIC_1_MASK);\r\nswitch (meye.pm_mchip_mode) {\r\ncase MCHIP_HIC_MODE_CONT_OUT:\r\nmchip_continuous_start();\r\nbreak;\r\ncase MCHIP_HIC_MODE_CONT_COMP:\r\nmchip_cont_compression_start();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit meye_probe(struct pci_dev *pcidev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct v4l2_device *v4l2_dev = &meye.v4l2_dev;\r\nint ret = -EBUSY;\r\nunsigned long mchip_adr;\r\nif (meye.mchip_dev != NULL) {\r\nprintk(KERN_ERR "meye: only one device allowed!\n");\r\ngoto outnotdev;\r\n}\r\nret = v4l2_device_register(&pcidev->dev, v4l2_dev);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nreturn ret;\r\n}\r\nret = -ENOMEM;\r\nmeye.mchip_dev = pcidev;\r\nmeye.vdev = video_device_alloc();\r\nif (!meye.vdev) {\r\nv4l2_err(v4l2_dev, "video_device_alloc() failed!\n");\r\ngoto outnotdev;\r\n}\r\nmeye.grab_temp = vmalloc(MCHIP_NB_PAGES_MJPEG * PAGE_SIZE);\r\nif (!meye.grab_temp) {\r\nv4l2_err(v4l2_dev, "grab buffer allocation failed\n");\r\ngoto outvmalloc;\r\n}\r\nspin_lock_init(&meye.grabq_lock);\r\nif (kfifo_alloc(&meye.grabq, sizeof(int) * MEYE_MAX_BUFNBRS,\r\nGFP_KERNEL)) {\r\nv4l2_err(v4l2_dev, "fifo allocation failed\n");\r\ngoto outkfifoalloc1;\r\n}\r\nspin_lock_init(&meye.doneq_lock);\r\nif (kfifo_alloc(&meye.doneq, sizeof(int) * MEYE_MAX_BUFNBRS,\r\nGFP_KERNEL)) {\r\nv4l2_err(v4l2_dev, "fifo allocation failed\n");\r\ngoto outkfifoalloc2;\r\n}\r\nmemcpy(meye.vdev, &meye_template, sizeof(meye_template));\r\nmeye.vdev->v4l2_dev = &meye.v4l2_dev;\r\nret = -EIO;\r\nif ((ret = sony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERA, 1))) {\r\nv4l2_err(v4l2_dev, "meye: unable to power on the camera\n");\r\nv4l2_err(v4l2_dev, "meye: did you enable the camera in "\r\n"sonypi using the module options ?\n");\r\ngoto outsonypienable;\r\n}\r\nif ((ret = pci_enable_device(meye.mchip_dev))) {\r\nv4l2_err(v4l2_dev, "meye: pci_enable_device failed\n");\r\ngoto outenabledev;\r\n}\r\nmchip_adr = pci_resource_start(meye.mchip_dev,0);\r\nif (!mchip_adr) {\r\nv4l2_err(v4l2_dev, "meye: mchip has no device base address\n");\r\ngoto outregions;\r\n}\r\nif (!request_mem_region(pci_resource_start(meye.mchip_dev, 0),\r\npci_resource_len(meye.mchip_dev, 0),\r\n"meye")) {\r\nv4l2_err(v4l2_dev, "meye: request_mem_region failed\n");\r\ngoto outregions;\r\n}\r\nmeye.mchip_mmregs = ioremap(mchip_adr, MCHIP_MM_REGS);\r\nif (!meye.mchip_mmregs) {\r\nv4l2_err(v4l2_dev, "meye: ioremap failed\n");\r\ngoto outremap;\r\n}\r\nmeye.mchip_irq = pcidev->irq;\r\nif (request_irq(meye.mchip_irq, meye_irq,\r\nIRQF_DISABLED | IRQF_SHARED, "meye", meye_irq)) {\r\nv4l2_err(v4l2_dev, "request_irq failed\n");\r\ngoto outreqirq;\r\n}\r\npci_write_config_byte(meye.mchip_dev, PCI_CACHE_LINE_SIZE, 8);\r\npci_write_config_byte(meye.mchip_dev, PCI_LATENCY_TIMER, 64);\r\npci_set_master(meye.mchip_dev);\r\npci_write_config_word(meye.mchip_dev, MCHIP_PCI_SOFTRESET_SET, 1);\r\nmchip_delay(MCHIP_HIC_CMD, 0);\r\nmchip_delay(MCHIP_HIC_STATUS, MCHIP_HIC_STATUS_IDLE);\r\nmsleep(1);\r\nmchip_set(MCHIP_VRJ_SOFT_RESET, 1);\r\nmsleep(1);\r\nmchip_set(MCHIP_MM_PCI_MODE, 5);\r\nmsleep(1);\r\nmchip_set(MCHIP_MM_INTA, MCHIP_MM_INTA_HIC_1_MASK);\r\nmutex_init(&meye.lock);\r\ninit_waitqueue_head(&meye.proc_list);\r\nmeye.brightness = 32 << 10;\r\nmeye.hue = 32 << 10;\r\nmeye.colour = 32 << 10;\r\nmeye.contrast = 32 << 10;\r\nmeye.params.subsample = 0;\r\nmeye.params.quality = 8;\r\nmeye.params.sharpness = 32;\r\nmeye.params.agc = 48;\r\nmeye.params.picture = 0;\r\nmeye.params.framerate = 0;\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERABRIGHTNESS, 32);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERAHUE, 32);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERACOLOR, 32);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERACONTRAST, 32);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERASHARPNESS, 32);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERAPICTURE, 0);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERAAGC, 48);\r\nif (video_register_device(meye.vdev, VFL_TYPE_GRABBER,\r\nvideo_nr) < 0) {\r\nv4l2_err(v4l2_dev, "video_register_device failed\n");\r\ngoto outvideoreg;\r\n}\r\nv4l2_info(v4l2_dev, "Motion Eye Camera Driver v%s.\n",\r\nMEYE_DRIVER_VERSION);\r\nv4l2_info(v4l2_dev, "mchip KL5A72002 rev. %d, base %lx, irq %d\n",\r\nmeye.mchip_dev->revision, mchip_adr, meye.mchip_irq);\r\nreturn 0;\r\noutvideoreg:\r\nfree_irq(meye.mchip_irq, meye_irq);\r\noutreqirq:\r\niounmap(meye.mchip_mmregs);\r\noutremap:\r\nrelease_mem_region(pci_resource_start(meye.mchip_dev, 0),\r\npci_resource_len(meye.mchip_dev, 0));\r\noutregions:\r\npci_disable_device(meye.mchip_dev);\r\noutenabledev:\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERA, 0);\r\noutsonypienable:\r\nkfifo_free(&meye.doneq);\r\noutkfifoalloc2:\r\nkfifo_free(&meye.grabq);\r\noutkfifoalloc1:\r\nvfree(meye.grab_temp);\r\noutvmalloc:\r\nvideo_device_release(meye.vdev);\r\noutnotdev:\r\nreturn ret;\r\n}\r\nstatic void __devexit meye_remove(struct pci_dev *pcidev)\r\n{\r\nvideo_unregister_device(meye.vdev);\r\nmchip_hic_stop();\r\nmchip_dma_free();\r\nmchip_set(MCHIP_MM_INTA, 0x0);\r\nfree_irq(meye.mchip_irq, meye_irq);\r\niounmap(meye.mchip_mmregs);\r\nrelease_mem_region(pci_resource_start(meye.mchip_dev, 0),\r\npci_resource_len(meye.mchip_dev, 0));\r\npci_disable_device(meye.mchip_dev);\r\nsony_pic_camera_command(SONY_PIC_COMMAND_SETCAMERA, 0);\r\nkfifo_free(&meye.doneq);\r\nkfifo_free(&meye.grabq);\r\nvfree(meye.grab_temp);\r\nif (meye.grab_fbuffer) {\r\nrvfree(meye.grab_fbuffer, gbuffers*gbufsize);\r\nmeye.grab_fbuffer = NULL;\r\n}\r\nprintk(KERN_INFO "meye: removed\n");\r\n}\r\nstatic int __init meye_init(void)\r\n{\r\ngbuffers = max(2, min((int)gbuffers, MEYE_MAX_BUFNBRS));\r\nif (gbufsize < 0 || gbufsize > MEYE_MAX_BUFSIZE)\r\ngbufsize = MEYE_MAX_BUFSIZE;\r\ngbufsize = PAGE_ALIGN(gbufsize);\r\nprintk(KERN_INFO "meye: using %d buffers with %dk (%dk total) "\r\n"for capture\n",\r\ngbuffers,\r\ngbufsize / 1024, gbuffers * gbufsize / 1024);\r\nreturn pci_register_driver(&meye_driver);\r\n}\r\nstatic void __exit meye_exit(void)\r\n{\r\npci_unregister_driver(&meye_driver);\r\n}
