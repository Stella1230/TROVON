static int write_reg(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int write_regs(struct i2c_client *client, u8 *regs)\r\n{\r\nint i;\r\nfor (i = 0; regs[i] != 0x00; i += 2)\r\nif (i2c_smbus_write_byte_data(client, regs[i], regs[i + 1]) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int wis_saa7115_command(struct i2c_client *client,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct wis_saa7115 *dec = i2c_get_clientdata(client);\r\nswitch (cmd) {\r\ncase VIDIOC_S_INPUT:\r\n{\r\nint *input = arg;\r\ni2c_smbus_write_byte_data(client, 0x02, 0xC0 | *input);\r\ni2c_smbus_write_byte_data(client, 0x09,\r\n*input < 6 ? 0x40 : 0xC0);\r\nbreak;\r\n}\r\ncase DECODER_SET_RESOLUTION:\r\n{\r\nstruct video_decoder_resolution *res = arg;\r\nint h_integer_scaler = res->width < 704 ? 704 / res->width : 1;\r\nint h_scaling_increment = (704 / h_integer_scaler) *\r\n1024 / res->width;\r\nint v_scaling_increment = (dec->norm & V4L2_STD_NTSC ?\r\n240 : 288) * 1024 / res->height;\r\nu8 regs[] = {\r\n0x88, 0xc0,\r\n0x9c, res->width & 0xff,\r\n0x9d, res->width >> 8,\r\n0x9e, res->height & 0xff,\r\n0x9f, res->height >> 8,\r\n0xa0, h_integer_scaler,\r\n0xa1, 1,\r\n0xa2, 1,\r\n0xa8, h_scaling_increment & 0xff,\r\n0xa9, h_scaling_increment >> 8,\r\n0xac, (h_scaling_increment / 2) & 0xff,\r\n0xad, (h_scaling_increment / 2) >> 8,\r\n0xb0, v_scaling_increment & 0xff,\r\n0xb1, v_scaling_increment >> 8,\r\n0xb2, v_scaling_increment & 0xff,\r\n0xb3, v_scaling_increment >> 8,\r\n0xcc, res->width & 0xff,\r\n0xcd, res->width >> 8,\r\n0xce, res->height & 0xff,\r\n0xcf, res->height >> 8,\r\n0xd0, h_integer_scaler,\r\n0xd1, 1,\r\n0xd2, 1,\r\n0xd8, h_scaling_increment & 0xff,\r\n0xd9, h_scaling_increment >> 8,\r\n0xdc, (h_scaling_increment / 2) & 0xff,\r\n0xdd, (h_scaling_increment / 2) >> 8,\r\n0xe0, v_scaling_increment & 0xff,\r\n0xe1, v_scaling_increment >> 8,\r\n0xe2, v_scaling_increment & 0xff,\r\n0xe3, v_scaling_increment >> 8,\r\n0x88, 0xf0,\r\n0, 0,\r\n};\r\nwrite_regs(client, regs);\r\nbreak;\r\n}\r\ncase VIDIOC_S_STD:\r\n{\r\nv4l2_std_id *input = arg;\r\nu8 regs[] = {\r\n0x88, 0xc0,\r\n0x98, *input & V4L2_STD_NTSC ? 0x12 : 0x16,\r\n0x9a, *input & V4L2_STD_NTSC ? 0xf2 : 0x20,\r\n0x9b, *input & V4L2_STD_NTSC ? 0x00 : 0x01,\r\n0xc8, *input & V4L2_STD_NTSC ? 0x12 : 0x16,\r\n0xca, *input & V4L2_STD_NTSC ? 0xf2 : 0x20,\r\n0xcb, *input & V4L2_STD_NTSC ? 0x00 : 0x01,\r\n0x88, 0xf0,\r\n0x30, *input & V4L2_STD_NTSC ? 0x66 : 0x00,\r\n0x31, *input & V4L2_STD_NTSC ? 0x90 : 0xe0,\r\n0, 0,\r\n};\r\nwrite_regs(client, regs);\r\ndec->norm = *input;\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYCTRL:\r\n{\r\nstruct v4l2_queryctrl *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Brightness", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 255;\r\nctrl->step = 1;\r\nctrl->default_value = 128;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Contrast", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 64;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Saturation", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 64;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Hue", sizeof(ctrl->name));\r\nctrl->minimum = -128;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 0;\r\nctrl->flags = 0;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nif (ctrl->value > 255)\r\ndec->brightness = 255;\r\nelse if (ctrl->value < 0)\r\ndec->brightness = 0;\r\nelse\r\ndec->brightness = ctrl->value;\r\nwrite_reg(client, 0x0a, dec->brightness);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nif (ctrl->value > 127)\r\ndec->contrast = 127;\r\nelse if (ctrl->value < 0)\r\ndec->contrast = 0;\r\nelse\r\ndec->contrast = ctrl->value;\r\nwrite_reg(client, 0x0b, dec->contrast);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nif (ctrl->value > 127)\r\ndec->saturation = 127;\r\nelse if (ctrl->value < 0)\r\ndec->saturation = 0;\r\nelse\r\ndec->saturation = ctrl->value;\r\nwrite_reg(client, 0x0c, dec->saturation);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nif (ctrl->value > 127)\r\ndec->hue = 127;\r\nelse if (ctrl->value < -128)\r\ndec->hue = -128;\r\nelse\r\ndec->hue = ctrl->value;\r\nwrite_reg(client, 0x0d, dec->hue);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->value = dec->brightness;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->value = dec->contrast;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->value = dec->saturation;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->value = dec->hue;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wis_saa7115_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct wis_saa7115 *dec;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ndec = kmalloc(sizeof(struct wis_saa7115), GFP_KERNEL);\r\nif (dec == NULL)\r\nreturn -ENOMEM;\r\ndec->norm = V4L2_STD_NTSC;\r\ndec->brightness = 128;\r\ndec->contrast = 64;\r\ndec->saturation = 64;\r\ndec->hue = 0;\r\ni2c_set_clientdata(client, dec);\r\nprintk(KERN_DEBUG\r\n"wis-saa7115: initializing SAA7115 at address %d on %s\n",\r\nclient->addr, adapter->name);\r\nif (write_regs(client, initial_registers) < 0) {\r\nprintk(KERN_ERR\r\n"wis-saa7115: error initializing SAA7115\n");\r\nkfree(dec);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wis_saa7115_remove(struct i2c_client *client)\r\n{\r\nstruct wis_saa7115 *dec = i2c_get_clientdata(client);\r\nkfree(dec);\r\nreturn 0;\r\n}\r\nstatic int __init wis_saa7115_init(void)\r\n{\r\nreturn i2c_add_driver(&wis_saa7115_driver);\r\n}\r\nstatic void __exit wis_saa7115_cleanup(void)\r\n{\r\ni2c_del_driver(&wis_saa7115_driver);\r\n}
