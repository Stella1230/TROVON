static void toshiba_request_vsync(struct msm_panel_data *panel_data,\r\nstruct msmfb_callback *callback)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\npanel->toshiba_callback = callback;\r\nif (panel->toshiba_got_int) {\r\npanel->toshiba_got_int = 0;\r\nclient_data->activate_link(client_data);\r\n}\r\n}\r\nstatic void toshiba_clear_vsync(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nclient_data->activate_link(client_data);\r\n}\r\nstatic void toshiba_wait_vsync(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nif (panel->toshiba_got_int) {\r\npanel->toshiba_got_int = 0;\r\nclient_data->activate_link(client_data);\r\n}\r\nif (wait_event_timeout(toshiba_vsync_wait, panel->toshiba_got_int,\r\nHZ/2) == 0)\r\nprintk(KERN_ERR "timeout waiting for VSYNC\n");\r\npanel->toshiba_got_int = 0;\r\n}\r\nstatic int toshiba_suspend(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nint ret;\r\nret = bridge_data->uninit(bridge_data, client_data);\r\nif (ret) {\r\nprintk(KERN_INFO "mddi toshiba client: non zero return from "\r\n"uninit\n");\r\nreturn ret;\r\n}\r\nclient_data->suspend(client_data);\r\nreturn 0;\r\n}\r\nstatic int toshiba_resume(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nint ret;\r\nclient_data->resume(client_data);\r\nret = bridge_data->init(bridge_data, client_data);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int toshiba_blank(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nreturn bridge_data->blank(bridge_data, client_data);\r\n}\r\nstatic int toshiba_unblank(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nreturn bridge_data->unblank(bridge_data, client_data);\r\n}\r\nirqreturn_t toshiba_vsync_interrupt(int irq, void *data)\r\n{\r\nstruct panel_info *panel = data;\r\npanel->toshiba_got_int = 1;\r\nif (panel->toshiba_callback) {\r\npanel->toshiba_callback->func(panel->toshiba_callback);\r\npanel->toshiba_callback = 0;\r\n}\r\nwake_up(&toshiba_vsync_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int setup_vsync(struct panel_info *panel,\r\nint init)\r\n{\r\nint ret;\r\nint gpio = 97;\r\nunsigned int irq;\r\nif (!init) {\r\nret = 0;\r\ngoto uninit;\r\n}\r\nret = gpio_request(gpio, "vsync");\r\nif (ret)\r\ngoto err_request_gpio_failed;\r\nret = gpio_direction_input(gpio);\r\nif (ret)\r\ngoto err_gpio_direction_input_failed;\r\nret = irq = gpio_to_irq(gpio);\r\nif (ret < 0)\r\ngoto err_get_irq_num_failed;\r\nret = request_irq(irq, toshiba_vsync_interrupt, IRQF_TRIGGER_RISING,\r\n"vsync", panel);\r\nif (ret)\r\ngoto err_request_irq_failed;\r\nprintk(KERN_INFO "vsync on gpio %d now %d\n",\r\ngpio, gpio_get_value(gpio));\r\nreturn 0;\r\nuninit:\r\nfree_irq(gpio_to_irq(gpio), panel);\r\nerr_request_irq_failed:\r\nerr_get_irq_num_failed:\r\nerr_gpio_direction_input_failed:\r\ngpio_free(gpio);\r\nerr_request_gpio_failed:\r\nreturn ret;\r\n}\r\nstatic int mddi_toshiba_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct msm_mddi_client_data *client_data = pdev->dev.platform_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nstruct panel_info *panel =\r\nkzalloc(sizeof(struct panel_info), GFP_KERNEL);\r\nif (!panel)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, panel);\r\nclient_data->remote_write(client_data, GPIOSEL_VWAKEINT, GPIOSEL);\r\nclient_data->remote_write(client_data, INTMASK_VWAKEOUT, INTMASK);\r\nret = setup_vsync(panel, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "mddi_bridge_setup_vsync failed\n");\r\nreturn ret;\r\n}\r\npanel->client_data = client_data;\r\npanel->panel_data.suspend = toshiba_suspend;\r\npanel->panel_data.resume = toshiba_resume;\r\npanel->panel_data.wait_vsync = toshiba_wait_vsync;\r\npanel->panel_data.request_vsync = toshiba_request_vsync;\r\npanel->panel_data.clear_vsync = toshiba_clear_vsync;\r\npanel->panel_data.blank = toshiba_blank;\r\npanel->panel_data.unblank = toshiba_unblank;\r\npanel->panel_data.fb_data = &bridge_data->fb_data;\r\npanel->panel_data.caps = MSMFB_CAP_PARTIAL_UPDATES;\r\npanel->pdev.name = "msm_panel";\r\npanel->pdev.id = pdev->id;\r\npanel->pdev.resource = client_data->fb_resource;\r\npanel->pdev.num_resources = 1;\r\npanel->pdev.dev.platform_data = &panel->panel_data;\r\nbridge_data->init(bridge_data, client_data);\r\nplatform_device_register(&panel->pdev);\r\nreturn 0;\r\n}\r\nstatic int mddi_toshiba_remove(struct platform_device *pdev)\r\n{\r\nstruct panel_info *panel = platform_get_drvdata(pdev);\r\nsetup_vsync(panel, 0);\r\nkfree(panel);\r\nreturn 0;\r\n}\r\nstatic int __init mddi_client_toshiba_init(void)\r\n{\r\nplatform_driver_register(&mddi_client_d263_0000);\r\nreturn 0;\r\n}
