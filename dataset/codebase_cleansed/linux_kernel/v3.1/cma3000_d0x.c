static void decode_mg(struct cma3000_accl_data *data, int *datax,\r\nint *datay, int *dataz)\r\n{\r\n*datax = ((s8)*datax) * data->bit_to_mg;\r\n*datay = ((s8)*datay) * data->bit_to_mg;\r\n*dataz = ((s8)*dataz) * data->bit_to_mg;\r\n}\r\nstatic irqreturn_t cma3000_thread_irq(int irq, void *dev_id)\r\n{\r\nstruct cma3000_accl_data *data = dev_id;\r\nint datax, datay, dataz;\r\nu8 ctrl, mode, range, intr_status;\r\nintr_status = CMA3000_READ(data, CMA3000_INTSTATUS, "interrupt status");\r\nif (intr_status < 0)\r\nreturn IRQ_NONE;\r\nif (intr_status & CMA3000_INTSTATUS_FFDET) {\r\ninput_report_abs(data->input_dev, ABS_MISC, 1);\r\ninput_sync(data->input_dev);\r\n} else {\r\ninput_report_abs(data->input_dev, ABS_MISC, 0);\r\n}\r\ndatax = CMA3000_READ(data, CMA3000_DOUTX, "X");\r\ndatay = CMA3000_READ(data, CMA3000_DOUTY, "Y");\r\ndataz = CMA3000_READ(data, CMA3000_DOUTZ, "Z");\r\nctrl = CMA3000_READ(data, CMA3000_CTRL, "ctrl");\r\nmode = (ctrl & CMA3000_MODEMASK) >> 1;\r\nrange = (ctrl & CMA3000_GRANGEMASK) >> 7;\r\ndata->bit_to_mg = mode_to_mg[mode][range];\r\nif (data->bit_to_mg == 0)\r\nreturn IRQ_NONE;\r\ndecode_mg(data, &datax, &datay, &dataz);\r\ninput_report_abs(data->input_dev, ABS_X, datax);\r\ninput_report_abs(data->input_dev, ABS_Y, datay);\r\ninput_report_abs(data->input_dev, ABS_Z, dataz);\r\ninput_sync(data->input_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cma3000_reset(struct cma3000_accl_data *data)\r\n{\r\nint val;\r\nCMA3000_SET(data, CMA3000_RSTR, 0x02, "Reset");\r\nCMA3000_SET(data, CMA3000_RSTR, 0x0A, "Reset");\r\nCMA3000_SET(data, CMA3000_RSTR, 0x04, "Reset");\r\nmdelay(10);\r\nval = CMA3000_READ(data, CMA3000_STATUS, "Status");\r\nif (val < 0) {\r\ndev_err(data->dev, "Reset failed\n");\r\nreturn val;\r\n}\r\nif (val & CMA3000_STATUS_PERR) {\r\ndev_err(data->dev, "Parity Error\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cma3000_poweron(struct cma3000_accl_data *data)\r\n{\r\nconst struct cma3000_platform_data *pdata = data->pdata;\r\nu8 ctrl = 0;\r\nint ret;\r\nif (data->g_range == CMARANGE_2G) {\r\nctrl = (data->mode << 1) | CMA3000_RANGE2G;\r\n} else if (data->g_range == CMARANGE_8G) {\r\nctrl = (data->mode << 1) | CMA3000_RANGE8G;\r\n} else {\r\ndev_info(data->dev,\r\n"Invalid G range specified, assuming 8G\n");\r\nctrl = (data->mode << 1) | CMA3000_RANGE8G;\r\n}\r\nctrl |= data->bus_ops->ctrl_mod;\r\nCMA3000_SET(data, CMA3000_MDTHR, pdata->mdthr,\r\n"Motion Detect Threshold");\r\nCMA3000_SET(data, CMA3000_MDFFTMR, pdata->mdfftmr,\r\n"Time register");\r\nCMA3000_SET(data, CMA3000_FFTHR, pdata->ffthr,\r\n"Free fall threshold");\r\nret = CMA3000_SET(data, CMA3000_CTRL, ctrl, "Mode setting");\r\nif (ret < 0)\r\nreturn -EIO;\r\nmsleep(CMA3000_SETDELAY);\r\nreturn 0;\r\n}\r\nstatic int cma3000_poweroff(struct cma3000_accl_data *data)\r\n{\r\nint ret;\r\nret = CMA3000_SET(data, CMA3000_CTRL, CMAMODE_POFF, "Mode setting");\r\nmsleep(CMA3000_SETDELAY);\r\nreturn ret;\r\n}\r\nstatic int cma3000_open(struct input_dev *input_dev)\r\n{\r\nstruct cma3000_accl_data *data = input_get_drvdata(input_dev);\r\nmutex_lock(&data->mutex);\r\nif (!data->suspended)\r\ncma3000_poweron(data);\r\ndata->opened = true;\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic void cma3000_close(struct input_dev *input_dev)\r\n{\r\nstruct cma3000_accl_data *data = input_get_drvdata(input_dev);\r\nmutex_lock(&data->mutex);\r\nif (!data->suspended)\r\ncma3000_poweroff(data);\r\ndata->opened = false;\r\nmutex_unlock(&data->mutex);\r\n}\r\nvoid cma3000_suspend(struct cma3000_accl_data *data)\r\n{\r\nmutex_lock(&data->mutex);\r\nif (!data->suspended && data->opened)\r\ncma3000_poweroff(data);\r\ndata->suspended = true;\r\nmutex_unlock(&data->mutex);\r\n}\r\nvoid cma3000_resume(struct cma3000_accl_data *data)\r\n{\r\nmutex_lock(&data->mutex);\r\nif (data->suspended && data->opened)\r\ncma3000_poweron(data);\r\ndata->suspended = false;\r\nmutex_unlock(&data->mutex);\r\n}\r\nstruct cma3000_accl_data *cma3000_init(struct device *dev, int irq,\r\nconst struct cma3000_bus_ops *bops)\r\n{\r\nconst struct cma3000_platform_data *pdata = dev->platform_data;\r\nstruct cma3000_accl_data *data;\r\nstruct input_dev *input_dev;\r\nint rev;\r\nint error;\r\nif (!pdata) {\r\ndev_err(dev, "platform data not found\n");\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (irq == 0) {\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\ndata = kzalloc(sizeof(struct cma3000_accl_data), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!data || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ndata->dev = dev;\r\ndata->input_dev = input_dev;\r\ndata->bus_ops = bops;\r\ndata->pdata = pdata;\r\ndata->irq = irq;\r\nmutex_init(&data->mutex);\r\ndata->mode = pdata->mode;\r\nif (data->mode < CMAMODE_DEFAULT || data->mode > CMAMODE_POFF) {\r\ndata->mode = CMAMODE_MOTDET;\r\ndev_warn(dev,\r\n"Invalid mode specified, assuming Motion Detect\n");\r\n}\r\ndata->g_range = pdata->g_range;\r\nif (data->g_range != CMARANGE_2G && data->g_range != CMARANGE_8G) {\r\ndev_info(dev,\r\n"Invalid G range specified, assuming 8G\n");\r\ndata->g_range = CMARANGE_8G;\r\n}\r\ninput_dev->name = "cma3000-accelerometer";\r\ninput_dev->id.bustype = bops->bustype;\r\ninput_dev->open = cma3000_open;\r\ninput_dev->close = cma3000_close;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_X,\r\n-data->g_range, data->g_range, pdata->fuzz_x, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\n-data->g_range, data->g_range, pdata->fuzz_y, 0);\r\ninput_set_abs_params(input_dev, ABS_Z,\r\n-data->g_range, data->g_range, pdata->fuzz_z, 0);\r\ninput_set_abs_params(input_dev, ABS_MISC, 0, 1, 0, 0);\r\ninput_set_drvdata(input_dev, data);\r\nerror = cma3000_reset(data);\r\nif (error)\r\ngoto err_free_mem;\r\nrev = CMA3000_READ(data, CMA3000_REVID, "Revid");\r\nif (rev < 0) {\r\nerror = rev;\r\ngoto err_free_mem;\r\n}\r\npr_info("CMA3000 Accelerometer: Revision %x\n", rev);\r\nerror = request_threaded_irq(irq, NULL, cma3000_thread_irq,\r\npdata->irqflags | IRQF_ONESHOT,\r\n"cma3000_d0x", data);\r\nif (error) {\r\ndev_err(dev, "request_threaded_irq failed\n");\r\ngoto err_free_mem;\r\n}\r\nerror = input_register_device(data->input_dev);\r\nif (error) {\r\ndev_err(dev, "Unable to register input device\n");\r\ngoto err_free_irq;\r\n}\r\nreturn data;\r\nerr_free_irq:\r\nfree_irq(irq, data);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(data);\r\nerr_out:\r\nreturn ERR_PTR(error);\r\n}\r\nvoid cma3000_exit(struct cma3000_accl_data *data)\r\n{\r\nfree_irq(data->irq, data);\r\ninput_unregister_device(data->input_dev);\r\nkfree(data);\r\n}
