static int\r\nnv50_gpio_location(struct dcb_gpio_entry *gpio, uint32_t *reg, uint32_t *shift)\r\n{\r\nconst uint32_t nv50_gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };\r\nif (gpio->line >= 32)\r\nreturn -EINVAL;\r\n*reg = nv50_gpio_reg[gpio->line >> 3];\r\n*shift = (gpio->line & 7) << 2;\r\nreturn 0;\r\n}\r\nint\r\nnv50_gpio_get(struct drm_device *dev, enum dcb_gpio_tag tag)\r\n{\r\nstruct dcb_gpio_entry *gpio;\r\nuint32_t r, s, v;\r\ngpio = nouveau_bios_gpio_entry(dev, tag);\r\nif (!gpio)\r\nreturn -ENOENT;\r\nif (nv50_gpio_location(gpio, &r, &s))\r\nreturn -EINVAL;\r\nv = nv_rd32(dev, r) >> (s + 2);\r\nreturn ((v & 1) == (gpio->state[1] & 1));\r\n}\r\nint\r\nnv50_gpio_set(struct drm_device *dev, enum dcb_gpio_tag tag, int state)\r\n{\r\nstruct dcb_gpio_entry *gpio;\r\nuint32_t r, s, v;\r\ngpio = nouveau_bios_gpio_entry(dev, tag);\r\nif (!gpio)\r\nreturn -ENOENT;\r\nif (nv50_gpio_location(gpio, &r, &s))\r\nreturn -EINVAL;\r\nv = nv_rd32(dev, r) & ~(0x3 << s);\r\nv |= (gpio->state[state] ^ 2) << s;\r\nnv_wr32(dev, r, v);\r\nreturn 0;\r\n}\r\nint\r\nnv50_gpio_irq_register(struct drm_device *dev, enum dcb_gpio_tag tag,\r\nvoid (*handler)(void *, int), void *data)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct nv50_gpio_priv *priv = pgpio->priv;\r\nstruct nv50_gpio_handler *gpioh;\r\nstruct dcb_gpio_entry *gpio;\r\nunsigned long flags;\r\ngpio = nouveau_bios_gpio_entry(dev, tag);\r\nif (!gpio)\r\nreturn -ENOENT;\r\ngpioh = kzalloc(sizeof(*gpioh), GFP_KERNEL);\r\nif (!gpioh)\r\nreturn -ENOMEM;\r\nINIT_WORK(&gpioh->work, nv50_gpio_isr_bh);\r\ngpioh->dev = dev;\r\ngpioh->gpio = gpio;\r\ngpioh->handler = handler;\r\ngpioh->data = data;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_add(&gpioh->head, &priv->handlers);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_gpio_irq_unregister(struct drm_device *dev, enum dcb_gpio_tag tag,\r\nvoid (*handler)(void *, int), void *data)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct nv50_gpio_priv *priv = pgpio->priv;\r\nstruct nv50_gpio_handler *gpioh, *tmp;\r\nstruct dcb_gpio_entry *gpio;\r\nLIST_HEAD(tofree);\r\nunsigned long flags;\r\ngpio = nouveau_bios_gpio_entry(dev, tag);\r\nif (!gpio)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_for_each_entry_safe(gpioh, tmp, &priv->handlers, head) {\r\nif (gpioh->gpio != gpio ||\r\ngpioh->handler != handler ||\r\ngpioh->data != data)\r\ncontinue;\r\nlist_move(&gpioh->head, &tofree);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nlist_for_each_entry_safe(gpioh, tmp, &tofree, head) {\r\nflush_work_sync(&gpioh->work);\r\nkfree(gpioh);\r\n}\r\n}\r\nbool\r\nnv50_gpio_irq_enable(struct drm_device *dev, enum dcb_gpio_tag tag, bool on)\r\n{\r\nstruct dcb_gpio_entry *gpio;\r\nu32 reg, mask;\r\ngpio = nouveau_bios_gpio_entry(dev, tag);\r\nif (!gpio)\r\nreturn false;\r\nreg = gpio->line < 16 ? 0xe050 : 0xe070;\r\nmask = 0x00010001 << (gpio->line & 0xf);\r\nnv_wr32(dev, reg + 4, mask);\r\nreg = nv_mask(dev, reg + 0, mask, on ? mask : 0);\r\nreturn (reg & mask) == mask;\r\n}\r\nstatic int\r\nnv50_gpio_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct nv50_gpio_priv *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&priv->handlers);\r\nspin_lock_init(&priv->lock);\r\npgpio->priv = priv;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_gpio_destroy(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nkfree(pgpio->priv);\r\npgpio->priv = NULL;\r\n}\r\nint\r\nnv50_gpio_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nint ret;\r\nif (!pgpio->priv) {\r\nret = nv50_gpio_create(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nnv_wr32(dev, 0xe050, 0x00000000);\r\nnv_wr32(dev, 0xe054, 0xffffffff);\r\nif (dev_priv->chipset >= 0x90) {\r\nnv_wr32(dev, 0xe070, 0x00000000);\r\nnv_wr32(dev, 0xe074, 0xffffffff);\r\n}\r\nnouveau_irq_register(dev, 21, nv50_gpio_isr);\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_gpio_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nnv_wr32(dev, 0xe050, 0x00000000);\r\nif (dev_priv->chipset >= 0x90)\r\nnv_wr32(dev, 0xe070, 0x00000000);\r\nnouveau_irq_unregister(dev, 21);\r\nnv50_gpio_destroy(dev);\r\n}\r\nstatic void\r\nnv50_gpio_isr_bh(struct work_struct *work)\r\n{\r\nstruct nv50_gpio_handler *gpioh =\r\ncontainer_of(work, struct nv50_gpio_handler, work);\r\nstruct drm_nouveau_private *dev_priv = gpioh->dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct nv50_gpio_priv *priv = pgpio->priv;\r\nunsigned long flags;\r\nint state;\r\nstate = pgpio->get(gpioh->dev, gpioh->gpio->tag);\r\nif (state < 0)\r\nreturn;\r\ngpioh->handler(gpioh->data, state);\r\nspin_lock_irqsave(&priv->lock, flags);\r\ngpioh->inhibit = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void\r\nnv50_gpio_isr(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct nv50_gpio_priv *priv = pgpio->priv;\r\nstruct nv50_gpio_handler *gpioh;\r\nu32 intr0, intr1 = 0;\r\nu32 hi, lo, ch;\r\nintr0 = nv_rd32(dev, 0xe054) & nv_rd32(dev, 0xe050);\r\nif (dev_priv->chipset >= 0x90)\r\nintr1 = nv_rd32(dev, 0xe074) & nv_rd32(dev, 0xe070);\r\nhi = (intr0 & 0x0000ffff) | (intr1 << 16);\r\nlo = (intr0 >> 16) | (intr1 & 0xffff0000);\r\nch = hi | lo;\r\nnv_wr32(dev, 0xe054, intr0);\r\nif (dev_priv->chipset >= 0x90)\r\nnv_wr32(dev, 0xe074, intr1);\r\nspin_lock(&priv->lock);\r\nlist_for_each_entry(gpioh, &priv->handlers, head) {\r\nif (!(ch & (1 << gpioh->gpio->line)))\r\ncontinue;\r\nif (gpioh->inhibit)\r\ncontinue;\r\ngpioh->inhibit = true;\r\nschedule_work(&gpioh->work);\r\n}\r\nspin_unlock(&priv->lock);\r\n}
