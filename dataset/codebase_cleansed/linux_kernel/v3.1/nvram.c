static ssize_t pSeries_nvram_read(char *buf, size_t count, loff_t *index)\r\n{\r\nunsigned int i;\r\nunsigned long len;\r\nint done;\r\nunsigned long flags;\r\nchar *p = buf;\r\nif (nvram_size == 0 || nvram_fetch == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENODEV;\r\nif (*index >= nvram_size)\r\nreturn 0;\r\ni = *index;\r\nif (i + count > nvram_size)\r\ncount = nvram_size - i;\r\nspin_lock_irqsave(&nvram_lock, flags);\r\nfor (; count != 0; count -= len) {\r\nlen = count;\r\nif (len > NVRW_CNT)\r\nlen = NVRW_CNT;\r\nif ((rtas_call(nvram_fetch, 3, 2, &done, i, __pa(nvram_buf),\r\nlen) != 0) || len != done) {\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\nreturn -EIO;\r\n}\r\nmemcpy(p, nvram_buf, len);\r\np += len;\r\ni += len;\r\n}\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\n*index = i;\r\nreturn p - buf;\r\n}\r\nstatic ssize_t pSeries_nvram_write(char *buf, size_t count, loff_t *index)\r\n{\r\nunsigned int i;\r\nunsigned long len;\r\nint done;\r\nunsigned long flags;\r\nconst char *p = buf;\r\nif (nvram_size == 0 || nvram_store == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENODEV;\r\nif (*index >= nvram_size)\r\nreturn 0;\r\ni = *index;\r\nif (i + count > nvram_size)\r\ncount = nvram_size - i;\r\nspin_lock_irqsave(&nvram_lock, flags);\r\nfor (; count != 0; count -= len) {\r\nlen = count;\r\nif (len > NVRW_CNT)\r\nlen = NVRW_CNT;\r\nmemcpy(nvram_buf, p, len);\r\nif ((rtas_call(nvram_store, 3, 2, &done, i, __pa(nvram_buf),\r\nlen) != 0) || len != done) {\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\nreturn -EIO;\r\n}\r\np += len;\r\ni += len;\r\n}\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\n*index = i;\r\nreturn p - buf;\r\n}\r\nstatic ssize_t pSeries_nvram_get_size(void)\r\n{\r\nreturn nvram_size ? nvram_size : -ENODEV;\r\n}\r\nint nvram_write_os_partition(struct nvram_os_partition *part, char * buff,\r\nint length, unsigned int err_type, unsigned int error_log_cnt)\r\n{\r\nint rc;\r\nloff_t tmp_index;\r\nstruct err_log_info info;\r\nif (part->index == -1) {\r\nreturn -ESPIPE;\r\n}\r\nif (length > part->size) {\r\nlength = part->size;\r\n}\r\ninfo.error_type = err_type;\r\ninfo.seq_num = error_log_cnt;\r\ntmp_index = part->index;\r\nrc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info), &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_write (%d)\n", __FUNCTION__, rc);\r\nreturn rc;\r\n}\r\nrc = ppc_md.nvram_write(buff, length, &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_write (%d)\n", __FUNCTION__, rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint nvram_write_error_log(char * buff, int length,\r\nunsigned int err_type, unsigned int error_log_cnt)\r\n{\r\nint rc = nvram_write_os_partition(&rtas_log_partition, buff, length,\r\nerr_type, error_log_cnt);\r\nif (!rc)\r\nlast_unread_rtas_event = get_seconds();\r\nreturn rc;\r\n}\r\nint nvram_read_error_log(char * buff, int length,\r\nunsigned int * err_type, unsigned int * error_log_cnt)\r\n{\r\nint rc;\r\nloff_t tmp_index;\r\nstruct err_log_info info;\r\nif (rtas_log_partition.index == -1)\r\nreturn -1;\r\nif (length > rtas_log_partition.size)\r\nlength = rtas_log_partition.size;\r\ntmp_index = rtas_log_partition.index;\r\nrc = ppc_md.nvram_read((char *)&info, sizeof(struct err_log_info), &tmp_index);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_read_error_log: Failed nvram_read (%d)\n", rc);\r\nreturn rc;\r\n}\r\nrc = ppc_md.nvram_read(buff, length, &tmp_index);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_read_error_log: Failed nvram_read (%d)\n", rc);\r\nreturn rc;\r\n}\r\n*error_log_cnt = info.seq_num;\r\n*err_type = info.error_type;\r\nreturn 0;\r\n}\r\nint nvram_clear_error_log(void)\r\n{\r\nloff_t tmp_index;\r\nint clear_word = ERR_FLAG_ALREADY_LOGGED;\r\nint rc;\r\nif (rtas_log_partition.index == -1)\r\nreturn -1;\r\ntmp_index = rtas_log_partition.index;\r\nrc = ppc_md.nvram_write((char *)&clear_word, sizeof(int), &tmp_index);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_clear_error_log: Failed nvram_write (%d)\n", rc);\r\nreturn rc;\r\n}\r\nlast_unread_rtas_event = 0;\r\nreturn 0;\r\n}\r\nstatic int __init pseries_nvram_init_os_partition(struct nvram_os_partition\r\n*part)\r\n{\r\nloff_t p;\r\nint size;\r\nnvram_scan_partitions();\r\np = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\r\nif (p && size < part->min_size) {\r\npr_info("nvram: Found too small %s partition,"\r\n" removing it...\n", part->name);\r\nnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\r\np = 0;\r\n}\r\nif (!p) {\r\np = nvram_create_partition(part->name, NVRAM_SIG_OS,\r\npart->req_size, part->min_size);\r\nif (p == -ENOSPC) {\r\npr_info("nvram: No room to create %s partition, "\r\n"deleting any obsolete OS partitions...\n",\r\npart->name);\r\nnvram_remove_partition(NULL, NVRAM_SIG_OS,\r\npseries_nvram_os_partitions);\r\np = nvram_create_partition(part->name, NVRAM_SIG_OS,\r\npart->req_size, part->min_size);\r\n}\r\n}\r\nif (p <= 0) {\r\npr_err("nvram: Failed to find or create %s"\r\n" partition, err %d\n", part->name, (int)p);\r\nreturn -1;\r\n}\r\npart->index = p;\r\npart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\r\nreturn 0;\r\n}\r\nstatic void __init nvram_init_oops_partition(int rtas_partition_exists)\r\n{\r\nint rc;\r\nrc = pseries_nvram_init_os_partition(&oops_log_partition);\r\nif (rc != 0) {\r\nif (!rtas_partition_exists)\r\nreturn;\r\npr_notice("nvram: Using %s partition to log both"\r\n" RTAS errors and oops/panic reports\n",\r\nrtas_log_partition.name);\r\nmemcpy(&oops_log_partition, &rtas_log_partition,\r\nsizeof(rtas_log_partition));\r\n}\r\noops_buf = kmalloc(oops_log_partition.size, GFP_KERNEL);\r\nrc = kmsg_dump_register(&nvram_kmsg_dumper);\r\nif (rc != 0) {\r\npr_err("nvram: kmsg_dump_register() failed; returned %d\n", rc);\r\nkfree(oops_buf);\r\nreturn;\r\n}\r\n}\r\nstatic int __init pseries_nvram_init_log_partitions(void)\r\n{\r\nint rc;\r\nrc = pseries_nvram_init_os_partition(&rtas_log_partition);\r\nnvram_init_oops_partition(rc == 0);\r\nreturn 0;\r\n}\r\nint __init pSeries_nvram_init(void)\r\n{\r\nstruct device_node *nvram;\r\nconst unsigned int *nbytes_p;\r\nunsigned int proplen;\r\nnvram = of_find_node_by_type(NULL, "nvram");\r\nif (nvram == NULL)\r\nreturn -ENODEV;\r\nnbytes_p = of_get_property(nvram, "#bytes", &proplen);\r\nif (nbytes_p == NULL || proplen != sizeof(unsigned int)) {\r\nof_node_put(nvram);\r\nreturn -EIO;\r\n}\r\nnvram_size = *nbytes_p;\r\nnvram_fetch = rtas_token("nvram-fetch");\r\nnvram_store = rtas_token("nvram-store");\r\nprintk(KERN_INFO "PPC64 nvram contains %d bytes\n", nvram_size);\r\nof_node_put(nvram);\r\nppc_md.nvram_read = pSeries_nvram_read;\r\nppc_md.nvram_write = pSeries_nvram_write;\r\nppc_md.nvram_size = pSeries_nvram_get_size;\r\nreturn 0;\r\n}\r\nstatic size_t capture_last_msgs(const char *old_msgs, size_t old_len,\r\nconst char *new_msgs, size_t new_len,\r\nchar *captured, size_t capture_len)\r\n{\r\nif (new_len >= capture_len) {\r\nmemcpy(captured, new_msgs + (new_len - capture_len),\r\ncapture_len);\r\nreturn capture_len;\r\n} else {\r\nsize_t old_tail_len = min(old_len, capture_len - new_len);\r\nmemcpy(captured, old_msgs + (old_len - old_tail_len),\r\nold_tail_len);\r\nmemcpy(captured + old_tail_len, new_msgs, new_len);\r\nreturn old_tail_len + new_len;\r\n}\r\n}\r\nstatic int clobbering_unread_rtas_event(void)\r\n{\r\nreturn (oops_log_partition.index == rtas_log_partition.index\r\n&& last_unread_rtas_event\r\n&& get_seconds() - last_unread_rtas_event <=\r\nNVRAM_RTAS_READ_TIMEOUT);\r\n}\r\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\r\nenum kmsg_dump_reason reason,\r\nconst char *old_msgs, unsigned long old_len,\r\nconst char *new_msgs, unsigned long new_len)\r\n{\r\nstatic unsigned int oops_count = 0;\r\nstatic bool panicking = false;\r\nsize_t text_len;\r\nswitch (reason) {\r\ncase KMSG_DUMP_RESTART:\r\ncase KMSG_DUMP_HALT:\r\ncase KMSG_DUMP_POWEROFF:\r\nreturn;\r\ncase KMSG_DUMP_OOPS:\r\ncase KMSG_DUMP_KEXEC:\r\nbreak;\r\ncase KMSG_DUMP_PANIC:\r\npanicking = true;\r\nbreak;\r\ncase KMSG_DUMP_EMERG:\r\nif (panicking)\r\nreturn;\r\nbreak;\r\ndefault:\r\npr_err("%s: ignoring unrecognized KMSG_DUMP_* reason %d\n",\r\n__FUNCTION__, (int) reason);\r\nreturn;\r\n}\r\nif (clobbering_unread_rtas_event())\r\nreturn;\r\ntext_len = capture_last_msgs(old_msgs, old_len, new_msgs, new_len,\r\noops_buf, oops_log_partition.size);\r\n(void) nvram_write_os_partition(&oops_log_partition, oops_buf,\r\n(int) text_len, ERR_TYPE_KERNEL_PANIC, ++oops_count);\r\n}
