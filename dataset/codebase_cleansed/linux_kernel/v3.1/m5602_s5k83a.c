int s5k83a_probe(struct sd *sd)\r\n{\r\nstruct s5k83a_priv *sens_priv;\r\nu8 prod_id = 0, ver_id = 0;\r\nint i, err = 0;\r\nif (force_sensor) {\r\nif (force_sensor == S5K83A_SENSOR) {\r\ninfo("Forcing a %s sensor", s5k83a.name);\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\n}\r\nPDEBUG(D_PROBE, "Probing for a s5k83a sensor");\r\nfor (i = 0; i < ARRAY_SIZE(preinit_s5k83a) && !err; i++) {\r\nu8 data[2] = {preinit_s5k83a[i][2], preinit_s5k83a[i][3]};\r\nif (preinit_s5k83a[i][0] == SENSOR)\r\nerr = m5602_write_sensor(sd, preinit_s5k83a[i][1],\r\ndata, 2);\r\nelse\r\nerr = m5602_write_bridge(sd, preinit_s5k83a[i][1],\r\ndata[0]);\r\n}\r\nif (m5602_read_sensor(sd, 0x00, &prod_id, 1))\r\nreturn -ENODEV;\r\nif (m5602_read_sensor(sd, 0x01, &ver_id, 1))\r\nreturn -ENODEV;\r\nif ((prod_id == 0xff) || (ver_id == 0xff))\r\nreturn -ENODEV;\r\nelse\r\ninfo("Detected a s5k83a sensor");\r\nsensor_found:\r\nsens_priv = kmalloc(\r\nsizeof(struct s5k83a_priv), GFP_KERNEL);\r\nif (!sens_priv)\r\nreturn -ENOMEM;\r\nsens_priv->settings =\r\nkmalloc(sizeof(s32)*ARRAY_SIZE(s5k83a_ctrls), GFP_KERNEL);\r\nif (!sens_priv->settings) {\r\nkfree(sens_priv);\r\nreturn -ENOMEM;\r\n}\r\nsd->gspca_dev.cam.cam_mode = s5k83a_modes;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(s5k83a_modes);\r\nsd->desc->ctrls = s5k83a_ctrls;\r\nsd->desc->nctrls = ARRAY_SIZE(s5k83a_ctrls);\r\nsens_priv->rotation_thread = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(s5k83a_ctrls); i++)\r\nsens_priv->settings[i] = s5k83a_ctrls[i].qctrl.default_value;\r\nsd->sensor_priv = sens_priv;\r\nreturn 0;\r\n}\r\nint s5k83a_init(struct sd *sd)\r\n{\r\nint i, err = 0;\r\ns32 *sensor_settings =\r\n((struct s5k83a_priv *) sd->sensor_priv)->settings;\r\nfor (i = 0; i < ARRAY_SIZE(init_s5k83a) && !err; i++) {\r\nu8 data[2] = {0x00, 0x00};\r\nswitch (init_s5k83a[i][0]) {\r\ncase BRIDGE:\r\nerr = m5602_write_bridge(sd,\r\ninit_s5k83a[i][1],\r\ninit_s5k83a[i][2]);\r\nbreak;\r\ncase SENSOR:\r\ndata[0] = init_s5k83a[i][2];\r\nerr = m5602_write_sensor(sd,\r\ninit_s5k83a[i][1], data, 1);\r\nbreak;\r\ncase SENSOR_LONG:\r\ndata[0] = init_s5k83a[i][2];\r\ndata[1] = init_s5k83a[i][3];\r\nerr = m5602_write_sensor(sd,\r\ninit_s5k83a[i][1], data, 2);\r\nbreak;\r\ndefault:\r\ninfo("Invalid stream command, exiting init");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (dump_sensor)\r\ns5k83a_dump_registers(sd);\r\nerr = s5k83a_set_gain(&sd->gspca_dev, sensor_settings[GAIN_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k83a_set_brightness(&sd->gspca_dev,\r\nsensor_settings[BRIGHTNESS_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k83a_set_exposure(&sd->gspca_dev,\r\nsensor_settings[EXPOSURE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k83a_set_hflip(&sd->gspca_dev, sensor_settings[HFLIP_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k83a_set_vflip(&sd->gspca_dev, sensor_settings[VFLIP_IDX]);\r\nreturn err;\r\n}\r\nstatic int rotation_thread_function(void *data)\r\n{\r\nstruct sd *sd = (struct sd *) data;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\nu8 reg, previous_rotation = 0;\r\n__s32 vflip, hflip;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (!schedule_timeout(100)) {\r\nif (mutex_lock_interruptible(&sd->gspca_dev.usb_lock))\r\nbreak;\r\ns5k83a_get_rotation(sd, &reg);\r\nif (previous_rotation != reg) {\r\nprevious_rotation = reg;\r\ninfo("Camera was flipped");\r\ns5k83a_get_vflip((struct gspca_dev *) sd, &vflip);\r\ns5k83a_get_hflip((struct gspca_dev *) sd, &hflip);\r\nif (reg) {\r\nvflip = !vflip;\r\nhflip = !hflip;\r\n}\r\ns5k83a_set_flip_real((struct gspca_dev *) sd,\r\nvflip, hflip);\r\n}\r\nmutex_unlock(&sd->gspca_dev.usb_lock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nif (previous_rotation) {\r\ns5k83a_get_vflip((struct gspca_dev *) sd, &vflip);\r\ns5k83a_get_hflip((struct gspca_dev *) sd, &hflip);\r\ns5k83a_set_flip_real((struct gspca_dev *) sd, vflip, hflip);\r\n}\r\nsens_priv->rotation_thread = NULL;\r\nreturn 0;\r\n}\r\nint s5k83a_start(struct sd *sd)\r\n{\r\nint i, err = 0;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\nsens_priv->rotation_thread = kthread_create(rotation_thread_function,\r\nsd, "rotation thread");\r\nwake_up_process(sens_priv->rotation_thread);\r\nfor (i = 0; i < ARRAY_SIZE(start_s5k83a) && !err; i++) {\r\nu8 data[2] = {start_s5k83a[i][2], start_s5k83a[i][3]};\r\nif (start_s5k83a[i][0] == SENSOR)\r\nerr = m5602_write_sensor(sd, start_s5k83a[i][1],\r\ndata, 2);\r\nelse\r\nerr = m5602_write_bridge(sd, start_s5k83a[i][1],\r\ndata[0]);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nreturn s5k83a_set_led_indication(sd, 1);\r\n}\r\nint s5k83a_stop(struct sd *sd)\r\n{\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\nif (sens_priv->rotation_thread)\r\nkthread_stop(sens_priv->rotation_thread);\r\nreturn s5k83a_set_led_indication(sd, 0);\r\n}\r\nvoid s5k83a_disconnect(struct sd *sd)\r\n{\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\ns5k83a_stop(sd);\r\nsd->sensor = NULL;\r\nkfree(sens_priv->settings);\r\nkfree(sens_priv);\r\n}\r\nstatic int s5k83a_get_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\n*val = sens_priv->settings[GAIN_IDX];\r\nreturn 0;\r\n}\r\nstatic int s5k83a_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[2];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\nsens_priv->settings[GAIN_IDX] = val;\r\ndata[0] = 0x00;\r\ndata[1] = 0x20;\r\nerr = m5602_write_sensor(sd, 0x14, data, 2);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = 0x01;\r\ndata[1] = 0x00;\r\nerr = m5602_write_sensor(sd, 0x0d, data, 2);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = val >> 3;\r\ndata[1] = val >> 1;\r\nerr = m5602_write_sensor(sd, S5K83A_GAIN, data, 2);\r\nreturn err;\r\n}\r\nstatic int s5k83a_get_brightness(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\n*val = sens_priv->settings[BRIGHTNESS_IDX];\r\nreturn 0;\r\n}\r\nstatic int s5k83a_set_brightness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[1];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\nsens_priv->settings[BRIGHTNESS_IDX] = val;\r\ndata[0] = val;\r\nerr = m5602_write_sensor(sd, S5K83A_BRIGHTNESS, data, 1);\r\nreturn err;\r\n}\r\nstatic int s5k83a_get_exposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\n*val = sens_priv->settings[EXPOSURE_IDX];\r\nreturn 0;\r\n}\r\nstatic int s5k83a_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[2];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\nsens_priv->settings[EXPOSURE_IDX] = val;\r\ndata[0] = 0;\r\ndata[1] = val;\r\nerr = m5602_write_sensor(sd, S5K83A_EXPOSURE, data, 2);\r\nreturn err;\r\n}\r\nstatic int s5k83a_get_vflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\n*val = sens_priv->settings[VFLIP_IDX];\r\nreturn 0;\r\n}\r\nstatic int s5k83a_set_flip_real(struct gspca_dev *gspca_dev,\r\n__s32 vflip, __s32 hflip)\r\n{\r\nint err;\r\nu8 data[1];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ndata[0] = 0x05;\r\nerr = m5602_write_sensor(sd, S5K83A_PAGE_MAP, data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = S5K83A_FLIP_MASK;\r\ndata[0] = (vflip) ? data[0] | 0x40 : data[0];\r\ndata[0] = (hflip) ? data[0] | 0x80 : data[0];\r\nerr = m5602_write_sensor(sd, S5K83A_FLIP, data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = (vflip) ? 0x0b : 0x0a;\r\nerr = m5602_write_sensor(sd, S5K83A_VFLIP_TUNE, data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = (hflip) ? 0x0a : 0x0b;\r\nerr = m5602_write_sensor(sd, S5K83A_HFLIP_TUNE, data, 1);\r\nreturn err;\r\n}\r\nstatic int s5k83a_set_vflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 reg;\r\n__s32 hflip;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\nsens_priv->settings[VFLIP_IDX] = val;\r\ns5k83a_get_hflip(gspca_dev, &hflip);\r\nerr = s5k83a_get_rotation(sd, &reg);\r\nif (err < 0)\r\nreturn err;\r\nif (reg) {\r\nval = !val;\r\nhflip = !hflip;\r\n}\r\nerr = s5k83a_set_flip_real(gspca_dev, val, hflip);\r\nreturn err;\r\n}\r\nstatic int s5k83a_get_hflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\n*val = sens_priv->settings[HFLIP_IDX];\r\nreturn 0;\r\n}\r\nstatic int s5k83a_set_hflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 reg;\r\n__s32 vflip;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct s5k83a_priv *sens_priv = sd->sensor_priv;\r\nsens_priv->settings[HFLIP_IDX] = val;\r\ns5k83a_get_vflip(gspca_dev, &vflip);\r\nerr = s5k83a_get_rotation(sd, &reg);\r\nif (err < 0)\r\nreturn err;\r\nif (reg) {\r\nval = !val;\r\nvflip = !vflip;\r\n}\r\nerr = s5k83a_set_flip_real(gspca_dev, vflip, val);\r\nreturn err;\r\n}\r\nstatic int s5k83a_set_led_indication(struct sd *sd, u8 val)\r\n{\r\nint err = 0;\r\nu8 data[1];\r\nerr = m5602_read_bridge(sd, M5602_XB_GPIO_DAT, data);\r\nif (err < 0)\r\nreturn err;\r\nif (val)\r\ndata[0] = data[0] | S5K83A_GPIO_LED_MASK;\r\nelse\r\ndata[0] = data[0] & ~S5K83A_GPIO_LED_MASK;\r\nerr = m5602_write_bridge(sd, M5602_XB_GPIO_DAT, data[0]);\r\nreturn err;\r\n}\r\nstatic int s5k83a_get_rotation(struct sd *sd, u8 *reg_data)\r\n{\r\nint err = m5602_read_bridge(sd, M5602_XB_GPIO_DAT, reg_data);\r\n*reg_data = (*reg_data & S5K83A_GPIO_ROTATION_MASK) ? 0 : 1;\r\nreturn err;\r\n}\r\nstatic void s5k83a_dump_registers(struct sd *sd)\r\n{\r\nint address;\r\nu8 page, old_page;\r\nm5602_read_sensor(sd, S5K83A_PAGE_MAP, &old_page, 1);\r\nfor (page = 0; page < 16; page++) {\r\nm5602_write_sensor(sd, S5K83A_PAGE_MAP, &page, 1);\r\ninfo("Dumping the s5k83a register state for page 0x%x", page);\r\nfor (address = 0; address <= 0xff; address++) {\r\nu8 val = 0;\r\nm5602_read_sensor(sd, address, &val, 1);\r\ninfo("register 0x%x contains 0x%x",\r\naddress, val);\r\n}\r\n}\r\ninfo("s5k83a register state dump complete");\r\nfor (page = 0; page < 16; page++) {\r\nm5602_write_sensor(sd, S5K83A_PAGE_MAP, &page, 1);\r\ninfo("Probing for which registers that are read/write "\r\n"for page 0x%x", page);\r\nfor (address = 0; address <= 0xff; address++) {\r\nu8 old_val, ctrl_val, test_val = 0xff;\r\nm5602_read_sensor(sd, address, &old_val, 1);\r\nm5602_write_sensor(sd, address, &test_val, 1);\r\nm5602_read_sensor(sd, address, &ctrl_val, 1);\r\nif (ctrl_val == test_val)\r\ninfo("register 0x%x is writeable", address);\r\nelse\r\ninfo("register 0x%x is read only", address);\r\nm5602_write_sensor(sd, address, &old_val, 1);\r\n}\r\n}\r\ninfo("Read/write register probing complete");\r\nm5602_write_sensor(sd, S5K83A_PAGE_MAP, &old_page, 1);\r\n}
