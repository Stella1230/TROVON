static void b1isa_remove(struct pci_dev *pdev)\r\n{\r\navmctrl_info *cinfo = pci_get_drvdata(pdev);\r\navmcard *card;\r\nif (!cinfo)\r\nreturn;\r\ncard = cinfo->card;\r\nb1_reset(card->port);\r\nb1_reset(card->port);\r\ndetach_capi_ctr(&cinfo->capi_ctrl);\r\nfree_irq(card->irq, card);\r\nrelease_region(card->port, AVMB1_PORTLEN);\r\nb1_free_card(card);\r\n}\r\nstatic int b1isa_probe(struct pci_dev *pdev)\r\n{\r\navmctrl_info *cinfo;\r\navmcard *card;\r\nint retval;\r\ncard = b1_alloc_card(1);\r\nif (!card) {\r\nprintk(KERN_WARNING "b1isa: no memory.\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\ncinfo = card->ctrlinfo;\r\ncard->port = pci_resource_start(pdev, 0);\r\ncard->irq = pdev->irq;\r\ncard->cardtype = avm_b1isa;\r\nsprintf(card->name, "b1isa-%x", card->port);\r\nif ( card->port != 0x150 && card->port != 0x250\r\n&& card->port != 0x300 && card->port != 0x340) {\r\nprintk(KERN_WARNING "b1isa: invalid port 0x%x.\n", card->port);\r\nretval = -EINVAL;\r\ngoto err_free;\r\n}\r\nif (b1_irq_table[card->irq & 0xf] == 0) {\r\nprintk(KERN_WARNING "b1isa: irq %d not valid.\n", card->irq);\r\nretval = -EINVAL;\r\ngoto err_free;\r\n}\r\nif (!request_region(card->port, AVMB1_PORTLEN, card->name)) {\r\nprintk(KERN_WARNING "b1isa: ports 0x%03x-0x%03x in use.\n",\r\ncard->port, card->port + AVMB1_PORTLEN);\r\nretval = -EBUSY;\r\ngoto err_free;\r\n}\r\nretval = request_irq(card->irq, b1_interrupt, 0, card->name, card);\r\nif (retval) {\r\nprintk(KERN_ERR "b1isa: unable to get IRQ %d.\n", card->irq);\r\ngoto err_release_region;\r\n}\r\nb1_reset(card->port);\r\nif ((retval = b1_detect(card->port, card->cardtype)) != 0) {\r\nprintk(KERN_NOTICE "b1isa: NO card at 0x%x (%d)\n",\r\ncard->port, retval);\r\nretval = -ENODEV;\r\ngoto err_free_irq;\r\n}\r\nb1_reset(card->port);\r\nb1_getrevision(card);\r\ncinfo->capi_ctrl.owner = THIS_MODULE;\r\ncinfo->capi_ctrl.driver_name = "b1isa";\r\ncinfo->capi_ctrl.driverdata = cinfo;\r\ncinfo->capi_ctrl.register_appl = b1_register_appl;\r\ncinfo->capi_ctrl.release_appl = b1_release_appl;\r\ncinfo->capi_ctrl.send_message = b1_send_message;\r\ncinfo->capi_ctrl.load_firmware = b1_load_firmware;\r\ncinfo->capi_ctrl.reset_ctr = b1_reset_ctr;\r\ncinfo->capi_ctrl.procinfo = b1isa_procinfo;\r\ncinfo->capi_ctrl.proc_fops = &b1ctl_proc_fops;\r\nstrcpy(cinfo->capi_ctrl.name, card->name);\r\nretval = attach_capi_ctr(&cinfo->capi_ctrl);\r\nif (retval) {\r\nprintk(KERN_ERR "b1isa: attach controller failed.\n");\r\ngoto err_free_irq;\r\n}\r\nprintk(KERN_INFO "b1isa: AVM B1 ISA at i/o %#x, irq %d, revision %d\n",\r\ncard->port, card->irq, card->revision);\r\npci_set_drvdata(pdev, cinfo);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(card->irq, card);\r\nerr_release_region:\r\nrelease_region(card->port, AVMB1_PORTLEN);\r\nerr_free:\r\nb1_free_card(card);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic char *b1isa_procinfo(struct capi_ctr *ctrl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\nif (!cinfo)\r\nreturn "";\r\nsprintf(cinfo->infobuf, "%s %s 0x%x %d r%d",\r\ncinfo->cardname[0] ? cinfo->cardname : "-",\r\ncinfo->version[VER_DRIVER] ? cinfo->version[VER_DRIVER] : "-",\r\ncinfo->card ? cinfo->card->port : 0x0,\r\ncinfo->card ? cinfo->card->irq : 0,\r\ncinfo->card ? cinfo->card->revision : 0\r\n);\r\nreturn cinfo->infobuf;\r\n}\r\nstatic int b1isa_add_card(struct capi_driver *driver, capicardparams *data)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CARDS; i++) {\r\nif (isa_dev[i].resource[0].start)\r\ncontinue;\r\nisa_dev[i].resource[0].start = data->port;\r\nisa_dev[i].irq = data->irq;\r\nif (b1isa_probe(&isa_dev[i]) == 0)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init b1isa_init(void)\r\n{\r\nchar *p;\r\nchar rev[32];\r\nint i;\r\nif ((p = strchr(revision, ':')) != NULL && p[1]) {\r\nstrlcpy(rev, p + 2, 32);\r\nif ((p = strchr(rev, '$')) != NULL && p > rev)\r\n*(p-1) = 0;\r\n} else\r\nstrcpy(rev, "1.0");\r\nfor (i = 0; i < MAX_CARDS; i++) {\r\nif (!io[i])\r\nbreak;\r\nisa_dev[i].resource[0].start = io[i];\r\nisa_dev[i].irq = irq[i];\r\nif (b1isa_probe(&isa_dev[i]) != 0)\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(capi_driver_b1isa.revision, rev, 32);\r\nregister_capi_driver(&capi_driver_b1isa);\r\nprintk(KERN_INFO "b1isa: revision %s\n", rev);\r\nreturn 0;\r\n}\r\nstatic void __exit b1isa_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CARDS; i++) {\r\nif (isa_dev[i].resource[0].start)\r\nb1isa_remove(&isa_dev[i]);\r\n}\r\nunregister_capi_driver(&capi_driver_b1isa);\r\n}
