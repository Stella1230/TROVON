static void octeon_i2c_write_sw(struct octeon_i2c *i2c,\r\nu64 eop_reg,\r\nu8 data)\r\n{\r\nu64 tmp;\r\n__raw_writeq(SW_TWSI_V | eop_reg | data, i2c->twsi_base + SW_TWSI);\r\ndo {\r\ntmp = __raw_readq(i2c->twsi_base + SW_TWSI);\r\n} while ((tmp & SW_TWSI_V) != 0);\r\n}\r\nstatic u8 octeon_i2c_read_sw(struct octeon_i2c *i2c, u64 eop_reg)\r\n{\r\nu64 tmp;\r\n__raw_writeq(SW_TWSI_V | eop_reg | SW_TWSI_R, i2c->twsi_base + SW_TWSI);\r\ndo {\r\ntmp = __raw_readq(i2c->twsi_base + SW_TWSI);\r\n} while ((tmp & SW_TWSI_V) != 0);\r\nreturn tmp & 0xFF;\r\n}\r\nstatic void octeon_i2c_write_int(struct octeon_i2c *i2c, u64 data)\r\n{\r\nu64 tmp;\r\n__raw_writeq(data, i2c->twsi_base + TWSI_INT);\r\ntmp = __raw_readq(i2c->twsi_base + TWSI_INT);\r\n}\r\nstatic void octeon_i2c_int_enable(struct octeon_i2c *i2c)\r\n{\r\nocteon_i2c_write_int(i2c, 0x40);\r\n}\r\nstatic void octeon_i2c_int_disable(struct octeon_i2c *i2c)\r\n{\r\nocteon_i2c_write_int(i2c, 0);\r\n}\r\nstatic void octeon_i2c_unblock(struct octeon_i2c *i2c)\r\n{\r\nint i;\r\ndev_dbg(i2c->dev, "%s\n", __func__);\r\nfor (i = 0; i < 9; i++) {\r\nocteon_i2c_write_int(i2c, 0x0);\r\nudelay(5);\r\nocteon_i2c_write_int(i2c, 0x200);\r\nudelay(5);\r\n}\r\nocteon_i2c_write_int(i2c, 0x300);\r\nudelay(5);\r\nocteon_i2c_write_int(i2c, 0x100);\r\nudelay(5);\r\nocteon_i2c_write_int(i2c, 0x0);\r\n}\r\nstatic irqreturn_t octeon_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct octeon_i2c *i2c = dev_id;\r\nocteon_i2c_int_disable(i2c);\r\nwake_up_interruptible(&i2c->queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int octeon_i2c_test_iflg(struct octeon_i2c *i2c)\r\n{\r\nreturn (octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_CTL) & TWSI_CTL_IFLG) != 0;\r\n}\r\nstatic int octeon_i2c_wait(struct octeon_i2c *i2c)\r\n{\r\nint result;\r\nocteon_i2c_int_enable(i2c);\r\nresult = wait_event_interruptible_timeout(i2c->queue,\r\nocteon_i2c_test_iflg(i2c),\r\ni2c->adap.timeout);\r\nocteon_i2c_int_disable(i2c);\r\nif (result < 0) {\r\ndev_dbg(i2c->dev, "%s: wait interrupted\n", __func__);\r\nreturn result;\r\n} else if (result == 0) {\r\ndev_dbg(i2c->dev, "%s: timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_start(struct octeon_i2c *i2c)\r\n{\r\nu8 data;\r\nint result;\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL,\r\nTWSI_CTL_ENAB | TWSI_CTL_STA);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result) {\r\nif (octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT) == STAT_IDLE) {\r\nocteon_i2c_unblock(i2c);\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL,\r\nTWSI_CTL_ENAB | TWSI_CTL_STA);\r\nresult = octeon_i2c_wait(i2c);\r\n}\r\nif (result)\r\nreturn result;\r\n}\r\ndata = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);\r\nif ((data != STAT_START) && (data != STAT_RSTART)) {\r\ndev_err(i2c->dev, "%s: bad status (0x%x)\n", __func__, data);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_stop(struct octeon_i2c *i2c)\r\n{\r\nu8 data;\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL,\r\nTWSI_CTL_ENAB | TWSI_CTL_STP);\r\ndata = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);\r\nif (data != STAT_IDLE) {\r\ndev_err(i2c->dev, "%s: bad status(0x%x)\n", __func__, data);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_write(struct octeon_i2c *i2c, int target,\r\nconst u8 *data, int length)\r\n{\r\nint i, result;\r\nu8 tmp;\r\nresult = octeon_i2c_start(i2c);\r\nif (result)\r\nreturn result;\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_DATA, target << 1);\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL, TWSI_CTL_ENAB);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result)\r\nreturn result;\r\nfor (i = 0; i < length; i++) {\r\ntmp = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);\r\nif ((tmp != STAT_TXADDR_ACK) && (tmp != STAT_TXDATA_ACK)) {\r\ndev_err(i2c->dev,\r\n"%s: bad status before write (0x%x)\n",\r\n__func__, tmp);\r\nreturn -EIO;\r\n}\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_DATA, data[i]);\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL, TWSI_CTL_ENAB);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result)\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_read(struct octeon_i2c *i2c, int target,\r\nu8 *data, int length)\r\n{\r\nint i, result;\r\nu8 tmp;\r\nif (length < 1)\r\nreturn -EINVAL;\r\nresult = octeon_i2c_start(i2c);\r\nif (result)\r\nreturn result;\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_DATA, (target<<1) | 1);\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL, TWSI_CTL_ENAB);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result)\r\nreturn result;\r\nfor (i = 0; i < length; i++) {\r\ntmp = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);\r\nif ((tmp != STAT_RXDATA_ACK) && (tmp != STAT_RXADDR_ACK)) {\r\ndev_err(i2c->dev,\r\n"%s: bad status before read (0x%x)\n",\r\n__func__, tmp);\r\nreturn -EIO;\r\n}\r\nif (i+1 < length)\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL,\r\nTWSI_CTL_ENAB | TWSI_CTL_AAK);\r\nelse\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL,\r\nTWSI_CTL_ENAB);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result)\r\nreturn result;\r\ndata[i] = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_DATA);\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct i2c_msg *pmsg;\r\nint i;\r\nint ret = 0;\r\nstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\r\nfor (i = 0; ret == 0 && i < num; i++) {\r\npmsg = &msgs[i];\r\ndev_dbg(i2c->dev,\r\n"Doing %s %d byte(s) to/from 0x%02x - %d of %d messages\n",\r\npmsg->flags & I2C_M_RD ? "read" : "write",\r\npmsg->len, pmsg->addr, i + 1, num);\r\nif (pmsg->flags & I2C_M_RD)\r\nret = octeon_i2c_read(i2c, pmsg->addr, pmsg->buf,\r\npmsg->len);\r\nelse\r\nret = octeon_i2c_write(i2c, pmsg->addr, pmsg->buf,\r\npmsg->len);\r\n}\r\nocteon_i2c_stop(i2c);\r\nreturn (ret != 0) ? ret : num;\r\n}\r\nstatic u32 octeon_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int __devinit octeon_i2c_setclock(struct octeon_i2c *i2c)\r\n{\r\nint tclk, thp_base, inc, thp_idx, mdiv_idx, ndiv_idx, foscl, diff;\r\nint thp = 0x18, mdiv = 2, ndiv = 0, delta_hz = 1000000;\r\nfor (ndiv_idx = 0; ndiv_idx < 8 && delta_hz != 0; ndiv_idx++) {\r\nfor (mdiv_idx = 15; mdiv_idx >= 2 && delta_hz != 0; mdiv_idx--) {\r\ntclk = i2c->twsi_freq * (mdiv_idx + 1) * 10;\r\ntclk *= (1 << ndiv_idx);\r\nthp_base = (i2c->sys_freq / (tclk * 2)) - 1;\r\nfor (inc = 0; inc <= 1; inc++) {\r\nthp_idx = thp_base + inc;\r\nif (thp_idx < 5 || thp_idx > 0xff)\r\ncontinue;\r\nfoscl = i2c->sys_freq / (2 * (thp_idx + 1));\r\nfoscl = foscl / (1 << ndiv_idx);\r\nfoscl = foscl / (mdiv_idx + 1) / 10;\r\ndiff = abs(foscl - i2c->twsi_freq);\r\nif (diff < delta_hz) {\r\ndelta_hz = diff;\r\nthp = thp_idx;\r\nmdiv = mdiv_idx;\r\nndiv = ndiv_idx;\r\n}\r\n}\r\n}\r\n}\r\nocteon_i2c_write_sw(i2c, SW_TWSI_OP_TWSI_CLK, thp);\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CLKCTL, (mdiv << 3) | ndiv);\r\nreturn 0;\r\n}\r\nstatic int __devinit octeon_i2c_initlowlevel(struct octeon_i2c *i2c)\r\n{\r\nu8 status;\r\nint tries;\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL, TWSI_CTL_ENAB);\r\nocteon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_RST, 0);\r\nfor (tries = 10; tries; tries--) {\r\nudelay(1);\r\nstatus = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);\r\nif (status == STAT_IDLE)\r\nreturn 0;\r\n}\r\ndev_err(i2c->dev, "%s: TWSI_RST failed! (0x%x)\n", __func__, status);\r\nreturn -EIO;\r\n}\r\nstatic int __devinit octeon_i2c_probe(struct platform_device *pdev)\r\n{\r\nint irq, result = 0;\r\nstruct octeon_i2c *i2c;\r\nstruct octeon_i2c_data *i2c_data;\r\nstruct resource *res_mem;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ni2c = kzalloc(sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c) {\r\ndev_err(&pdev->dev, "kzalloc failed\n");\r\nresult = -ENOMEM;\r\ngoto out;\r\n}\r\ni2c->dev = &pdev->dev;\r\ni2c_data = pdev->dev.platform_data;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res_mem == NULL) {\r\ndev_err(i2c->dev, "found no memory resource\n");\r\nresult = -ENXIO;\r\ngoto fail_region;\r\n}\r\nif (i2c_data == NULL) {\r\ndev_err(i2c->dev, "no I2C frequency data\n");\r\nresult = -ENXIO;\r\ngoto fail_region;\r\n}\r\ni2c->twsi_phys = res_mem->start;\r\ni2c->regsize = resource_size(res_mem);\r\ni2c->twsi_freq = i2c_data->i2c_freq;\r\ni2c->sys_freq = i2c_data->sys_freq;\r\nif (!request_mem_region(i2c->twsi_phys, i2c->regsize, res_mem->name)) {\r\ndev_err(i2c->dev, "request_mem_region failed\n");\r\ngoto fail_region;\r\n}\r\ni2c->twsi_base = ioremap(i2c->twsi_phys, i2c->regsize);\r\ninit_waitqueue_head(&i2c->queue);\r\ni2c->irq = irq;\r\nresult = request_irq(i2c->irq, octeon_i2c_isr, 0, DRV_NAME, i2c);\r\nif (result < 0) {\r\ndev_err(i2c->dev, "failed to attach interrupt\n");\r\ngoto fail_irq;\r\n}\r\nresult = octeon_i2c_initlowlevel(i2c);\r\nif (result) {\r\ndev_err(i2c->dev, "init low level failed\n");\r\ngoto fail_add;\r\n}\r\nresult = octeon_i2c_setclock(i2c);\r\nif (result) {\r\ndev_err(i2c->dev, "clock init failed\n");\r\ngoto fail_add;\r\n}\r\ni2c->adap = octeon_i2c_ops;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.nr = pdev->id >= 0 ? pdev->id : 0;\r\ni2c_set_adapdata(&i2c->adap, i2c);\r\nplatform_set_drvdata(pdev, i2c);\r\nresult = i2c_add_numbered_adapter(&i2c->adap);\r\nif (result < 0) {\r\ndev_err(i2c->dev, "failed to add adapter\n");\r\ngoto fail_add;\r\n}\r\ndev_info(i2c->dev, "version %s\n", DRV_VERSION);\r\nreturn result;\r\nfail_add:\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(i2c->irq, i2c);\r\nfail_irq:\r\niounmap(i2c->twsi_base);\r\nrelease_mem_region(i2c->twsi_phys, i2c->regsize);\r\nfail_region:\r\nkfree(i2c);\r\nout:\r\nreturn result;\r\n}\r\nstatic int __devexit octeon_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct octeon_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(i2c->irq, i2c);\r\niounmap(i2c->twsi_base);\r\nrelease_mem_region(i2c->twsi_phys, i2c->regsize);\r\nkfree(i2c);\r\nreturn 0;\r\n}\r\nstatic int __init octeon_i2c_init(void)\r\n{\r\nint rv;\r\nrv = platform_driver_register(&octeon_i2c_driver);\r\nreturn rv;\r\n}\r\nstatic void __exit octeon_i2c_exit(void)\r\n{\r\nplatform_driver_unregister(&octeon_i2c_driver);\r\n}
