static\r\nvoid\r\ns_vProcessRxMACHeader (\r\nPSDevice pDevice,\r\nPBYTE pbyRxBufferAddr,\r\nunsigned int cbPacketSize,\r\nBOOL bIsWEP,\r\nBOOL bExtIV,\r\nunsigned int *pcbHeadSize\r\n)\r\n{\r\nPBYTE pbyRxBuffer;\r\nunsigned int cbHeaderSize = 0;\r\nPWORD pwType;\r\nPS802_11Header pMACHeader;\r\nint ii;\r\npMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);\r\ns_vGetDASA((PBYTE)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);\r\nif (bIsWEP) {\r\nif (bExtIV) {\r\ncbHeaderSize += (WLAN_HDR_ADDR3_LEN + 8);\r\n} else {\r\ncbHeaderSize += (WLAN_HDR_ADDR3_LEN + 4);\r\n}\r\n}\r\nelse {\r\ncbHeaderSize += WLAN_HDR_ADDR3_LEN;\r\n};\r\npbyRxBuffer = (PBYTE) (pbyRxBufferAddr + cbHeaderSize);\r\nif (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {\r\ncbHeaderSize += 6;\r\n} else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {\r\ncbHeaderSize += 6;\r\npwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);\r\nif ((*pwType == cpu_to_le16(ETH_P_IPX)) ||\r\n(*pwType == cpu_to_le16(0xF380))) {\r\ncbHeaderSize -= 8;\r\npwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);\r\nif (bIsWEP) {\r\nif (bExtIV) {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);\r\n} else {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);\r\n}\r\n}\r\nelse {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);\r\n}\r\n}\r\n}\r\nelse {\r\ncbHeaderSize -= 2;\r\npwType = (PWORD) (pbyRxBufferAddr + cbHeaderSize);\r\nif (bIsWEP) {\r\nif (bExtIV) {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);\r\n} else {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);\r\n}\r\n}\r\nelse {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);\r\n}\r\n}\r\ncbHeaderSize -= (ETH_ALEN * 2);\r\npbyRxBuffer = (PBYTE) (pbyRxBufferAddr + cbHeaderSize);\r\nfor (ii = 0; ii < ETH_ALEN; ii++)\r\n*pbyRxBuffer++ = pDevice->sRxEthHeader.abyDstAddr[ii];\r\nfor (ii = 0; ii < ETH_ALEN; ii++)\r\n*pbyRxBuffer++ = pDevice->sRxEthHeader.abySrcAddr[ii];\r\n*pcbHeadSize = cbHeaderSize;\r\n}\r\nstatic BYTE s_byGetRateIdx(BYTE byRate)\r\n{\r\nBYTE byRateIdx;\r\nfor (byRateIdx = 0; byRateIdx <MAX_RATE ; byRateIdx++) {\r\nif (acbyRxRate[byRateIdx%MAX_RATE] == byRate)\r\nreturn byRateIdx;\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nvoid\r\ns_vGetDASA (\r\nPBYTE pbyRxBufferAddr,\r\nunsigned int *pcbHeaderSize,\r\nPSEthernetHeader psEthHeader\r\n)\r\n{\r\nunsigned int cbHeaderSize = 0;\r\nPS802_11Header pMACHeader;\r\nint ii;\r\npMACHeader = (PS802_11Header) (pbyRxBufferAddr + cbHeaderSize);\r\nif ((pMACHeader->wFrameCtl & FC_TODS) == 0) {\r\nif (pMACHeader->wFrameCtl & FC_FROMDS) {\r\nfor (ii = 0; ii < ETH_ALEN; ii++) {\r\npsEthHeader->abyDstAddr[ii] =\r\npMACHeader->abyAddr1[ii];\r\npsEthHeader->abySrcAddr[ii] =\r\npMACHeader->abyAddr3[ii];\r\n}\r\n} else {\r\nfor (ii = 0; ii < ETH_ALEN; ii++) {\r\npsEthHeader->abyDstAddr[ii] =\r\npMACHeader->abyAddr1[ii];\r\npsEthHeader->abySrcAddr[ii] =\r\npMACHeader->abyAddr2[ii];\r\n}\r\n}\r\n} else {\r\nif (pMACHeader->wFrameCtl & FC_FROMDS) {\r\nfor (ii = 0; ii < ETH_ALEN; ii++) {\r\npsEthHeader->abyDstAddr[ii] =\r\npMACHeader->abyAddr3[ii];\r\npsEthHeader->abySrcAddr[ii] =\r\npMACHeader->abyAddr4[ii];\r\ncbHeaderSize += 6;\r\n}\r\n} else {\r\nfor (ii = 0; ii < ETH_ALEN; ii++) {\r\npsEthHeader->abyDstAddr[ii] =\r\npMACHeader->abyAddr3[ii];\r\npsEthHeader->abySrcAddr[ii] =\r\npMACHeader->abyAddr2[ii];\r\n}\r\n}\r\n};\r\n*pcbHeaderSize = cbHeaderSize;\r\n}\r\nBOOL\r\nRXbBulkInProcessData (\r\nPSDevice pDevice,\r\nPRCB pRCB,\r\nunsigned long BytesToIndicate\r\n)\r\n{\r\nstruct net_device_stats* pStats=&pDevice->stats;\r\nstruct sk_buff* skb;\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nPSRxMgmtPacket pRxPacket = &(pMgmt->sRxPacket);\r\nPS802_11Header p802_11Header;\r\nPBYTE pbyRsr;\r\nPBYTE pbyNewRsr;\r\nPBYTE pbyRSSI;\r\nPQWORD pqwTSFTime;\r\nPBYTE pbyFrame;\r\nBOOL bDeFragRx = FALSE;\r\nunsigned int cbHeaderOffset;\r\nunsigned int FrameSize;\r\nWORD wEtherType = 0;\r\nsigned int iSANodeIndex = -1;\r\nsigned int iDANodeIndex = -1;\r\nunsigned int ii;\r\nunsigned int cbIVOffset;\r\nPBYTE pbyRxSts;\r\nPBYTE pbyRxRate;\r\nPBYTE pbySQ;\r\nPBYTE pby3SQ;\r\nunsigned int cbHeaderSize;\r\nPSKeyItem pKey = NULL;\r\nWORD wRxTSC15_0 = 0;\r\nDWORD dwRxTSC47_16 = 0;\r\nSKeyItem STempKey;\r\nBOOL bIsWEP = FALSE;\r\nBOOL bExtIV = FALSE;\r\nDWORD dwWbkStatus;\r\nPRCB pRCBIndicate = pRCB;\r\nPBYTE pbyDAddress;\r\nPWORD pwPLCP_Length;\r\nBYTE abyVaildRate[MAX_RATE] = {2,4,11,22,12,18,24,36,48,72,96,108};\r\nWORD wPLCPwithPadding;\r\nPS802_11Header pMACHeader;\r\nBOOL bRxeapol_key = FALSE;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- RXbBulkInProcessData---\n");\r\nskb = pRCB->skb;\r\ndwWbkStatus = *( (PDWORD)(skb->data) );\r\nFrameSize = (unsigned int)(dwWbkStatus >> 16);\r\nFrameSize += 4;\r\nif (BytesToIndicate != FrameSize) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- WRONG Length 1 \n");\r\nreturn FALSE;\r\n}\r\nif ((BytesToIndicate > 2372) || (BytesToIndicate <= 40)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 2\n");\r\nreturn FALSE;\r\n}\r\npbyDAddress = (PBYTE)(skb->data);\r\npbyRxSts = pbyDAddress+4;\r\npbyRxRate = pbyDAddress+5;\r\npwPLCP_Length = (PWORD) (pbyDAddress + 6);\r\nif ( ((BytesToIndicate - (*pwPLCP_Length)) > 27) ||\r\n((BytesToIndicate - (*pwPLCP_Length)) < 24) ||\r\n(BytesToIndicate < (*pwPLCP_Length)) ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Wrong PLCP Length %x\n", (int) *pwPLCP_Length);\r\nASSERT(0);\r\nreturn FALSE;\r\n}\r\nfor ( ii=RATE_1M;ii<MAX_RATE;ii++) {\r\nif ( *pbyRxRate == abyVaildRate[ii] ) {\r\nbreak;\r\n}\r\n}\r\nif ( ii==MAX_RATE ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Wrong RxRate %x\n",(int) *pbyRxRate);\r\nreturn FALSE;\r\n}\r\nwPLCPwithPadding = ( (*pwPLCP_Length / 4) + ( (*pwPLCP_Length % 4) ? 1:0 ) ) *4;\r\npqwTSFTime = (PQWORD) (pbyDAddress + 8 + wPLCPwithPadding);\r\nif(pDevice->byBBType == BB_TYPE_11G) {\r\npby3SQ = pbyDAddress + 8 + wPLCPwithPadding + 12;\r\npbySQ = pby3SQ;\r\n}\r\nelse {\r\npbySQ = pbyDAddress + 8 + wPLCPwithPadding + 8;\r\npby3SQ = pbySQ;\r\n}\r\npbyNewRsr = pbyDAddress + 8 + wPLCPwithPadding + 9;\r\npbyRSSI = pbyDAddress + 8 + wPLCPwithPadding + 10;\r\npbyRsr = pbyDAddress + 8 + wPLCPwithPadding + 11;\r\nFrameSize = *pwPLCP_Length;\r\npbyFrame = pbyDAddress + 8;\r\nSTAvUpdateRDStatCounter(&pDevice->scStatistic,\r\n*pbyRsr,\r\n*pbyNewRsr,\r\n*pbyRxSts,\r\n*pbyRxRate,\r\npbyFrame,\r\nFrameSize\r\n);\r\npMACHeader = (PS802_11Header) pbyFrame;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_STANDBY) ||\r\n(pMgmt->eCurrMode == WMAC_MODE_ESS_STA)) {\r\nif (pMgmt->sNodeDBTable[0].bActive) {\r\nif (!compare_ether_addr(pMgmt->abyCurrBSSID, pMACHeader->abyAddr2)) {\r\nif (pMgmt->sNodeDBTable[0].uInActiveCount != 0)\r\npMgmt->sNodeDBTable[0].uInActiveCount = 0;\r\n}\r\n}\r\n}\r\nif (!is_multicast_ether_addr(pMACHeader->abyAddr1) && !is_broadcast_ether_addr(pMACHeader->abyAddr1)) {\r\nif ( WCTLbIsDuplicate(&(pDevice->sDupRxCache), (PS802_11Header) pbyFrame) ) {\r\npDevice->s802_11Counter.FrameDuplicateCount++;\r\nreturn FALSE;\r\n}\r\nif (compare_ether_addr(pDevice->abyCurrentNetAddr,\r\npMACHeader->abyAddr1)) {\r\nreturn FALSE;\r\n}\r\n}\r\ns_vGetDASA(pbyFrame, &cbHeaderSize, &pDevice->sRxEthHeader);\r\nif (!compare_ether_addr((PBYTE)&(pDevice->sRxEthHeader.abySrcAddr[0]),\r\npDevice->abyCurrentNetAddr))\r\nreturn FALSE;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {\r\nif (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {\r\np802_11Header = (PS802_11Header) (pbyFrame);\r\nif (BSSbIsSTAInNodeDB(pDevice, (PBYTE)(p802_11Header->abyAddr2), &iSANodeIndex)) {\r\npMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;\r\npMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;\r\n}\r\n}\r\n}\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == TRUE) {\r\nreturn FALSE;\r\n}\r\n}\r\nif (IS_FC_WEP(pbyFrame)) {\r\nBOOL bRxDecryOK = FALSE;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");\r\nbIsWEP = TRUE;\r\nif ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {\r\npKey = &STempKey;\r\npKey->byCipherSuite = pMgmt->sNodeDBTable[iSANodeIndex].byCipherSuite;\r\npKey->dwKeyIndex = pMgmt->sNodeDBTable[iSANodeIndex].dwKeyIndex;\r\npKey->uKeyLength = pMgmt->sNodeDBTable[iSANodeIndex].uWepKeyLength;\r\npKey->dwTSC47_16 = pMgmt->sNodeDBTable[iSANodeIndex].dwTSC47_16;\r\npKey->wTSC15_0 = pMgmt->sNodeDBTable[iSANodeIndex].wTSC15_0;\r\nmemcpy(pKey->abyKey,\r\n&pMgmt->sNodeDBTable[iSANodeIndex].abyWepKey[0],\r\npKey->uKeyLength\r\n);\r\nbRxDecryOK = s_bHostWepRxEncryption(pDevice,\r\npbyFrame,\r\nFrameSize,\r\npbyRsr,\r\npMgmt->sNodeDBTable[iSANodeIndex].bOnFly,\r\npKey,\r\npbyNewRsr,\r\n&bExtIV,\r\n&wRxTSC15_0,\r\n&dwRxTSC47_16);\r\n} else {\r\nbRxDecryOK = s_bHandleRxEncryption(pDevice,\r\npbyFrame,\r\nFrameSize,\r\npbyRsr,\r\npbyNewRsr,\r\n&pKey,\r\n&bExtIV,\r\n&wRxTSC15_0,\r\n&dwRxTSC47_16);\r\n}\r\nif (bRxDecryOK) {\r\nif ((*pbyNewRsr & NEWRSR_DECRYPTOK) == 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV Fail\n");\r\nif ( (pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {\r\nif ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {\r\npDevice->s802_11Counter.TKIPICVErrors++;\r\n} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP)) {\r\npDevice->s802_11Counter.CCMPDecryptErrors++;\r\n} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_WEP)) {\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"WEP Func Fail\n");\r\nreturn FALSE;\r\n}\r\nif ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))\r\nFrameSize -= 8;\r\nelse\r\nFrameSize -= 4;\r\n}\r\nFrameSize -= ETH_FCS_LEN;\r\nif ( !(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) &&\r\n(IS_FRAGMENT_PKT((pbyFrame)))\r\n) {\r\nbDeFragRx = WCTLbHandleFragment(pDevice, (PS802_11Header) (pbyFrame), FrameSize, bIsWEP, bExtIV);\r\npDevice->s802_11Counter.ReceivedFragmentCount++;\r\nif (bDeFragRx) {\r\nskb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;\r\nFrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;\r\npbyFrame = skb->data + 8;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\nif ((IS_TYPE_DATA((pbyFrame))) == FALSE) {\r\nif (IS_TYPE_MGMT((pbyFrame))) {\r\nPBYTE pbyData1;\r\nPBYTE pbyData2;\r\npRxPacket = &(pRCB->sMngPacket);\r\npRxPacket->p80211Header = (PUWLAN_80211HDR)(pbyFrame);\r\npRxPacket->cbMPDULen = FrameSize;\r\npRxPacket->uRSSI = *pbyRSSI;\r\npRxPacket->bySQ = *pbySQ;\r\nHIDWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(HIDWORD(*pqwTSFTime));\r\nLODWORD(pRxPacket->qwLocalTSF) = cpu_to_le32(LODWORD(*pqwTSFTime));\r\nif (bIsWEP) {\r\npbyData1 = WLAN_HDR_A3_DATA_PTR(pbyFrame);\r\npbyData2 = WLAN_HDR_A3_DATA_PTR(pbyFrame) + 4;\r\nfor (ii = 0; ii < (FrameSize - 4); ii++) {\r\n*pbyData1 = *pbyData2;\r\npbyData1++;\r\npbyData2++;\r\n}\r\n}\r\npRxPacket->byRxRate = s_byGetRateIdx(*pbyRxRate);\r\nif ( *pbyRxSts == 0 ) {\r\nif ( (WLAN_GET_FC_FSTYPE((pRxPacket->p80211Header->sA3.wFrameCtl)) == WLAN_FSTYPE_BEACON) ||\r\n(WLAN_GET_FC_FSTYPE((pRxPacket->p80211Header->sA3.wFrameCtl)) == WLAN_FSTYPE_PROBERESP) ) {\r\nreturn TRUE;\r\n}\r\n}\r\npRxPacket->byRxChannel = (*pbyRxSts) >> 2;\r\nif (pDevice->bEnableHostapd) {\r\nskb->dev = pDevice->apdev;\r\nskb->data += 8;\r\nskb->tail += 8;\r\nskb_put(skb, FrameSize);\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\nreturn TRUE;\r\n}\r\nEnqueueRCB(pDevice->FirstRecvMngList, pDevice->LastRecvMngList, pRCBIndicate);\r\npDevice->NumRecvMngList++;\r\nif ( bDeFragRx == FALSE) {\r\npRCB->Ref++;\r\n}\r\nif (pDevice->bIsRxMngWorkItemQueued == FALSE) {\r\npDevice->bIsRxMngWorkItemQueued = TRUE;\r\ntasklet_schedule(&pDevice->RxMngWorkItem);\r\n}\r\n}\r\nelse {\r\n};\r\nreturn FALSE;\r\n}\r\nelse {\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif ( !(*pbyRsr & RSR_BSSIDOK)) {\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\n}\r\nelse {\r\nif ((pDevice->bLinkPass == FALSE) ||\r\n!(*pbyRsr & RSR_BSSIDOK)) {\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\n{\r\nBYTE Protocol_Version;\r\nBYTE Packet_Type;\r\nBYTE Descriptor_type;\r\nWORD Key_info;\r\nif (bIsWEP)\r\ncbIVOffset = 8;\r\nelse\r\ncbIVOffset = 0;\r\nwEtherType = (skb->data[cbIVOffset + 8 + 24 + 6] << 8) |\r\nskb->data[cbIVOffset + 8 + 24 + 6 + 1];\r\nProtocol_Version = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1];\r\nPacket_Type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1];\r\nif (wEtherType == ETH_P_PAE) {\r\nif(((Protocol_Version==1) ||(Protocol_Version==2)) &&\r\n(Packet_Type==3)) {\r\nbRxeapol_key = TRUE;\r\nDescriptor_type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1+1+2];\r\nKey_info = (skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1+1+2+1]<<8) |skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1+1+2+2] ;\r\nif(Descriptor_type==2) {\r\n}\r\nelse if(Descriptor_type==254) {\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (pDevice->bEnablePSMode) {\r\nif (IS_FC_MOREDATA((pbyFrame))) {\r\nif (*pbyRsr & RSR_ADDROK) {\r\n}\r\n}\r\nelse {\r\nif (pMgmt->bInTIMWake == TRUE) {\r\npMgmt->bInTIMWake = FALSE;\r\n}\r\n}\r\n}\r\nif (pDevice->bDiversityEnable && (FrameSize>50) &&\r\n(pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&\r\n(pDevice->bLinkPass == TRUE)) {\r\nBBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);\r\n}\r\npDevice->uCurrRSSI = *pbyRSSI;\r\npDevice->byCurrSQ = *pbySQ;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == TRUE)){\r\nBYTE abyMacHdr[24];\r\nif (bIsWEP)\r\ncbIVOffset = 8;\r\nelse\r\ncbIVOffset = 0;\r\nwEtherType = (skb->data[cbIVOffset + 8 + 24 + 6] << 8) |\r\nskb->data[cbIVOffset + 8 + 24 + 6 + 1];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"wEtherType = %04x \n", wEtherType);\r\nif (wEtherType == ETH_P_PAE) {\r\nskb->dev = pDevice->apdev;\r\nif (bIsWEP == TRUE) {\r\nmemcpy(&abyMacHdr[0], (skb->data + 8), 24);\r\nmemcpy((skb->data + 8 + cbIVOffset), &abyMacHdr[0], 24);\r\n}\r\nskb->data += (cbIVOffset + 8);\r\nskb->tail += (cbIVOffset + 8);\r\nskb_put(skb, FrameSize);\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\nreturn TRUE;\r\n}\r\nif (!(pMgmt->sNodeDBTable[iSANodeIndex].dwFlags & WLAN_STA_AUTHORIZED))\r\nreturn FALSE;\r\n}\r\nif ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {\r\nif (bIsWEP) {\r\nFrameSize -= 8;\r\n}\r\n}\r\nif ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {\r\nif (bIsWEP) {\r\nPDWORD pdwMIC_L;\r\nPDWORD pdwMIC_R;\r\nDWORD dwMIC_Priority;\r\nDWORD dwMICKey0 = 0, dwMICKey1 = 0;\r\nDWORD dwLocalMIC_L = 0;\r\nDWORD dwLocalMIC_R = 0;\r\nviawget_wpa_header *wpahdr;\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\ndwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[24]));\r\ndwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[28]));\r\n}\r\nelse {\r\nif (pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {\r\ndwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[16]));\r\ndwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[20]));\r\n} else if ((pKey->dwKeyIndex & BIT28) == 0) {\r\ndwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[16]));\r\ndwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[20]));\r\n} else {\r\ndwMICKey0 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[24]));\r\ndwMICKey1 = cpu_to_le32(*(PDWORD)(&pKey->abyKey[28]));\r\n}\r\n}\r\nMIC_vInit(dwMICKey0, dwMICKey1);\r\nMIC_vAppend((PBYTE)&(pDevice->sRxEthHeader.abyDstAddr[0]), 12);\r\ndwMIC_Priority = 0;\r\nMIC_vAppend((PBYTE)&dwMIC_Priority, 4);\r\nMIC_vAppend((PBYTE)(skb->data + 8 + WLAN_HDR_ADDR3_LEN + 8),\r\nFrameSize - WLAN_HDR_ADDR3_LEN - 8);\r\nMIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);\r\nMIC_vUnInit();\r\npdwMIC_L = (PDWORD)(skb->data + 8 + FrameSize);\r\npdwMIC_R = (PDWORD)(skb->data + 8 + FrameSize + 4);\r\nif ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||\r\n(pDevice->bRxMICFail == TRUE)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC comparison is fail!\n");\r\npDevice->bRxMICFail = FALSE;\r\npDevice->s802_11Counter.TKIPLocalMICFailures++;\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\n{\r\nunion iwreq_data wrqu;\r\nstruct iw_michaelmicfailure ev;\r\nint keyidx = pbyFrame[cbHeaderSize+3] >> 6;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.flags = keyidx & IW_MICFAILURE_KEY_ID;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&\r\n(pMgmt->eCurrState == WMAC_STATE_ASSOC) &&\r\n(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {\r\nev.flags |= IW_MICFAILURE_PAIRWISE;\r\n} else {\r\nev.flags |= IW_MICFAILURE_GROUP;\r\n}\r\nev.src_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(ev.src_addr.sa_data, pMACHeader->abyAddr2, ETH_ALEN);\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.length = sizeof(ev);\r\nPRINT_K("wireless_send_event--->IWEVMICHAELMICFAILURE\n");\r\nwireless_send_event(pDevice->dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);\r\n}\r\n#endif\r\nif ((pDevice->bWPADEVUp) && (pDevice->skb != NULL)) {\r\nwpahdr = (viawget_wpa_header *)pDevice->skb->data;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&\r\n(pMgmt->eCurrState == WMAC_STATE_ASSOC) &&\r\n(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {\r\nwpahdr->type = VIAWGET_PTK_MIC_MSG;\r\n} else {\r\nwpahdr->type = VIAWGET_GTK_MIC_MSG;\r\n}\r\nwpahdr->resp_ie_len = 0;\r\nwpahdr->req_ie_len = 0;\r\nskb_put(pDevice->skb, sizeof(viawget_wpa_header));\r\npDevice->skb->dev = pDevice->wpadev;\r\nskb_reset_mac_header(pDevice->skb);\r\npDevice->skb->pkt_type = PACKET_HOST;\r\npDevice->skb->protocol = htons(ETH_P_802_2);\r\nmemset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));\r\nnetif_rx(pDevice->skb);\r\npDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\n}\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nif ((pKey != NULL) && ((pKey->byCipherSuite == KEY_CTL_TKIP) ||\r\n(pKey->byCipherSuite == KEY_CTL_CCMP))) {\r\nif (bIsWEP) {\r\nWORD wLocalTSC15_0 = 0;\r\nDWORD dwLocalTSC47_16 = 0;\r\nunsigned long long RSC = 0;\r\nRSC = *((unsigned long long *) &(pKey->KeyRSC));\r\nwLocalTSC15_0 = (WORD) RSC;\r\ndwLocalTSC47_16 = (DWORD) (RSC>>16);\r\nRSC = dwRxTSC47_16;\r\nRSC <<= 16;\r\nRSC += wRxTSC15_0;\r\nmemcpy(&(pKey->KeyRSC), &RSC, sizeof(QWORD));\r\nif ( (pDevice->sMgmtObj.eCurrMode == WMAC_MODE_ESS_STA) &&\r\n(pDevice->sMgmtObj.eCurrState == WMAC_STATE_ASSOC)) {\r\nif ( (wRxTSC15_0 < wLocalTSC15_0) &&\r\n(dwRxTSC47_16 <= dwLocalTSC47_16) &&\r\n!((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC is illegal~~!\n ");\r\nif (pKey->byCipherSuite == KEY_CTL_TKIP)\r\npDevice->s802_11Counter.TKIPReplays++;\r\nelse\r\npDevice->s802_11Counter.CCMPReplays++;\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\n}\r\ns_vProcessRxMACHeader(pDevice, (PBYTE)(skb->data+8), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);\r\nFrameSize -= cbHeaderOffset;\r\ncbHeaderOffset += 8;\r\nif (FrameSize < 12)\r\nreturn FALSE;\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif (s_bAPModeRxData(pDevice,\r\nskb,\r\nFrameSize,\r\ncbHeaderOffset,\r\niSANodeIndex,\r\niDANodeIndex\r\n) == FALSE) {\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\n}\r\nskb->data += cbHeaderOffset;\r\nskb->tail += cbHeaderOffset;\r\nskb_put(skb, FrameSize);\r\nskb->protocol=eth_type_trans(skb, skb->dev);\r\nskb->ip_summed=CHECKSUM_NONE;\r\npStats->rx_bytes +=skb->len;\r\npStats->rx_packets++;\r\nnetif_rx(skb);\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic BOOL s_bAPModeRxCtl (\r\nPSDevice pDevice,\r\nPBYTE pbyFrame,\r\nsigned int iSANodeIndex\r\n)\r\n{\r\nPS802_11Header p802_11Header;\r\nCMD_STATUS Status;\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nif (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {\r\np802_11Header = (PS802_11Header) (pbyFrame);\r\nif (!IS_TYPE_MGMT(pbyFrame)) {\r\nif (iSANodeIndex > 0) {\r\nif (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_AUTH) {\r\nvMgrDeAuthenBeginSta(pDevice,\r\npMgmt,\r\n(PBYTE)(p802_11Header->abyAddr2),\r\n(WLAN_MGMT_REASON_CLASS2_NONAUTH),\r\n&Status\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");\r\nreturn TRUE;\r\n}\r\nif (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {\r\nvMgrDisassocBeginSta(pDevice,\r\npMgmt,\r\n(PBYTE)(p802_11Header->abyAddr2),\r\n(WLAN_MGMT_REASON_CLASS3_NONASSOC),\r\n&Status\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");\r\nreturn TRUE;\r\n}\r\nif (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {\r\nif (IS_CTL_PSPOLL(pbyFrame)) {\r\npMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_RX_PSPOLL,\r\nNULL);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");\r\n}\r\nelse {\r\nif (!IS_FC_POWERMGT(pbyFrame)) {\r\npMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;\r\npMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_RX_PSPOLL,\r\nNULL);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");\r\n}\r\n}\r\n}\r\nelse {\r\nif (IS_FC_POWERMGT(pbyFrame)) {\r\npMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = TRUE;\r\npMgmt->sNodeDBTable[0].bPSEnable = TRUE;\r\n}\r\nelse {\r\nif (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {\r\npMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = FALSE;\r\npMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = TRUE;\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_RX_PSPOLL,\r\nNULL);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nvMgrDeAuthenBeginSta(pDevice,\r\npMgmt,\r\n(PBYTE)(p802_11Header->abyAddr2),\r\n(WLAN_MGMT_REASON_CLASS2_NONAUTH),\r\n&Status\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%02x-%02x-%02x=%02x-%02x-%02x \n",\r\np802_11Header->abyAddr3[0],\r\np802_11Header->abyAddr3[1],\r\np802_11Header->abyAddr3[2],\r\np802_11Header->abyAddr3[3],\r\np802_11Header->abyAddr3[4],\r\np802_11Header->abyAddr3[5]\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%02x-%02x-%02x=%02x-%02x-%02x \n",\r\np802_11Header->abyAddr2[0],\r\np802_11Header->abyAddr2[1],\r\np802_11Header->abyAddr2[2],\r\np802_11Header->abyAddr2[3],\r\np802_11Header->abyAddr2[4],\r\np802_11Header->abyAddr2[5]\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%02x-%02x-%02x=%02x-%02x-%02x \n",\r\np802_11Header->abyAddr1[0],\r\np802_11Header->abyAddr1[1],\r\np802_11Header->abyAddr1[2],\r\np802_11Header->abyAddr1[3],\r\np802_11Header->abyAddr1[4],\r\np802_11Header->abyAddr1[5]\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: wFrameCtl= %x\n", p802_11Header->wFrameCtl );\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic BOOL s_bHandleRxEncryption (\r\nPSDevice pDevice,\r\nPBYTE pbyFrame,\r\nunsigned int FrameSize,\r\nPBYTE pbyRsr,\r\nPBYTE pbyNewRsr,\r\nPSKeyItem * pKeyOut,\r\nint * pbExtIV,\r\nPWORD pwRxTSC15_0,\r\nPDWORD pdwRxTSC47_16\r\n)\r\n{\r\nunsigned int PayloadLen = FrameSize;\r\nPBYTE pbyIV;\r\nBYTE byKeyIdx;\r\nPSKeyItem pKey = NULL;\r\nBYTE byDecMode = KEY_CTL_WEP;\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\n*pwRxTSC15_0 = 0;\r\n*pdwRxTSC47_16 = 0;\r\npbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;\r\nif ( WLAN_GET_FC_TODS(*(PWORD)pbyFrame) &&\r\nWLAN_GET_FC_FROMDS(*(PWORD)pbyFrame) ) {\r\npbyIV += 6;\r\nPayloadLen -= 6;\r\n}\r\nbyKeyIdx = (*(pbyIV+3) & 0xc0);\r\nbyKeyIdx >>= 6;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);\r\nif ((pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {\r\nif (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&\r\n(pMgmt->byCSSPK != KEY_CTL_NONE)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt\n");\r\nif (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == TRUE) {\r\nif (pMgmt->byCSSPK == KEY_CTL_TKIP)\r\nbyDecMode = KEY_CTL_TKIP;\r\nelse if (pMgmt->byCSSPK == KEY_CTL_CCMP)\r\nbyDecMode = KEY_CTL_CCMP;\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt: %d, %p\n", byDecMode, pKey);\r\n} else {\r\nKeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);\r\nif (pMgmt->byCSSGK == KEY_CTL_TKIP)\r\nbyDecMode = KEY_CTL_TKIP;\r\nelse if (pMgmt->byCSSGK == KEY_CTL_CCMP)\r\nbyDecMode = KEY_CTL_CCMP;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"group pkt: %d, %d, %p\n", byKeyIdx, byDecMode, pKey);\r\n}\r\n}\r\nif (pKey == NULL) {\r\nKeybGetKey(&(pDevice->sKey), pDevice->abyBroadcastAddr, byKeyIdx, &pKey);\r\nif (pMgmt->byCSSGK == KEY_CTL_TKIP)\r\nbyDecMode = KEY_CTL_TKIP;\r\nelse if (pMgmt->byCSSGK == KEY_CTL_CCMP)\r\nbyDecMode = KEY_CTL_CCMP;\r\n}\r\n*pKeyOut = pKey;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pMgmt->byCSSPK, pMgmt->byCSSGK, byDecMode);\r\nif (pKey == NULL) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey == NULL\n");\r\nif (byDecMode == KEY_CTL_WEP) {\r\n} else if (pDevice->bLinkPass == TRUE) {\r\n}\r\nreturn FALSE;\r\n}\r\nif (byDecMode != pKey->byCipherSuite) {\r\nif (byDecMode == KEY_CTL_WEP) {\r\n} else if (pDevice->bLinkPass == TRUE) {\r\n}\r\n*pKeyOut = NULL;\r\nreturn FALSE;\r\n}\r\nif (byDecMode == KEY_CTL_WEP) {\r\nif ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||\r\n(((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == TRUE)) {\r\nPayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4);\r\nmemcpy(pDevice->abyPRNG, pbyIV, 3);\r\nmemcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);\r\nrc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);\r\nif (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\n}\r\n}\r\n} else if ((byDecMode == KEY_CTL_TKIP) ||\r\n(byDecMode == KEY_CTL_CCMP)) {\r\nPayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4);\r\n*pdwRxTSC47_16 = cpu_to_le32(*(PDWORD)(pbyIV + 4));\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);\r\nif (byDecMode == KEY_CTL_TKIP) {\r\n*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));\r\n} else {\r\n*pwRxTSC15_0 = cpu_to_le16(*(PWORD)pbyIV);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);\r\nif ((byDecMode == KEY_CTL_TKIP) &&\r\n(pDevice->byLocalID <= REV_ID_VT3253_A1)) {\r\nPS802_11Header pMACHeader = (PS802_11Header) (pbyFrame);\r\nTKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);\r\nrc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);\r\nif (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);\r\n}\r\n}\r\n}\r\nif ((*(pbyIV+3) & 0x20) != 0)\r\n*pbExtIV = TRUE;\r\nreturn TRUE;\r\n}\r\nstatic BOOL s_bHostWepRxEncryption (\r\nPSDevice pDevice,\r\nPBYTE pbyFrame,\r\nunsigned int FrameSize,\r\nPBYTE pbyRsr,\r\nBOOL bOnFly,\r\nPSKeyItem pKey,\r\nPBYTE pbyNewRsr,\r\nint * pbExtIV,\r\nPWORD pwRxTSC15_0,\r\nPDWORD pdwRxTSC47_16\r\n)\r\n{\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nunsigned int PayloadLen = FrameSize;\r\nPBYTE pbyIV;\r\nBYTE byKeyIdx;\r\nBYTE byDecMode = KEY_CTL_WEP;\r\nPS802_11Header pMACHeader;\r\n*pwRxTSC15_0 = 0;\r\n*pdwRxTSC47_16 = 0;\r\npbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;\r\nif ( WLAN_GET_FC_TODS(*(PWORD)pbyFrame) &&\r\nWLAN_GET_FC_FROMDS(*(PWORD)pbyFrame) ) {\r\npbyIV += 6;\r\nPayloadLen -= 6;\r\n}\r\nbyKeyIdx = (*(pbyIV+3) & 0xc0);\r\nbyKeyIdx >>= 6;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);\r\nif (pMgmt->byCSSGK == KEY_CTL_TKIP)\r\nbyDecMode = KEY_CTL_TKIP;\r\nelse if (pMgmt->byCSSGK == KEY_CTL_CCMP)\r\nbyDecMode = KEY_CTL_CCMP;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pMgmt->byCSSPK, pMgmt->byCSSGK, byDecMode);\r\nif (byDecMode != pKey->byCipherSuite) {\r\nif (byDecMode == KEY_CTL_WEP) {\r\n} else if (pDevice->bLinkPass == TRUE) {\r\n}\r\nreturn FALSE;\r\n}\r\nif (byDecMode == KEY_CTL_WEP) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"byDecMode == KEY_CTL_WEP \n");\r\nif ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||\r\n(((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == TRUE) ||\r\n(bOnFly == FALSE)) {\r\nPayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4);\r\nmemcpy(pDevice->abyPRNG, pbyIV, 3);\r\nmemcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);\r\nrc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);\r\nif (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\n}\r\n}\r\n} else if ((byDecMode == KEY_CTL_TKIP) ||\r\n(byDecMode == KEY_CTL_CCMP)) {\r\nPayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4);\r\n*pdwRxTSC47_16 = cpu_to_le32(*(PDWORD)(pbyIV + 4));\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);\r\nif (byDecMode == KEY_CTL_TKIP) {\r\n*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));\r\n} else {\r\n*pwRxTSC15_0 = cpu_to_le16(*(PWORD)pbyIV);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);\r\nif (byDecMode == KEY_CTL_TKIP) {\r\nif ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == FALSE)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_TKIP \n");\r\npMACHeader = (PS802_11Header) (pbyFrame);\r\nTKIPvMixKey(pKey->abyKey, pMACHeader->abyAddr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);\r\nrc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);\r\nif (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);\r\n}\r\n}\r\n}\r\nif (byDecMode == KEY_CTL_CCMP) {\r\nif (bOnFly == FALSE) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_CCMP\n");\r\nif (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC compare OK!\n");\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC fail!\n");\r\n}\r\n}\r\n}\r\n}\r\nif ((*(pbyIV+3) & 0x20) != 0)\r\n*pbExtIV = TRUE;\r\nreturn TRUE;\r\n}\r\nstatic BOOL s_bAPModeRxData (\r\nPSDevice pDevice,\r\nstruct sk_buff *skb,\r\nunsigned int FrameSize,\r\nunsigned int cbHeaderOffset,\r\nsigned int iSANodeIndex,\r\nsigned int iDANodeIndex\r\n)\r\n{\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nBOOL bRelayAndForward = FALSE;\r\nBOOL bRelayOnly = FALSE;\r\nBYTE byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};\r\nWORD wAID;\r\nstruct sk_buff* skbcpy = NULL;\r\nif (FrameSize > CB_MAX_BUF_SIZE)\r\nreturn FALSE;\r\nif (is_multicast_ether_addr((PBYTE)(skb->data+cbHeaderOffset))) {\r\nif (pMgmt->sNodeDBTable[0].bPSEnable) {\r\nskbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (skbcpy == NULL) {\r\nDBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");\r\n}\r\nelse {\r\nskbcpy->dev = pDevice->dev;\r\nskbcpy->len = FrameSize;\r\nmemcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);\r\nskb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);\r\npMgmt->sNodeDBTable[0].wEnQueueCnt++;\r\npMgmt->abyPSTxMap[0] |= byMask[0];\r\n}\r\n}\r\nelse {\r\nbRelayAndForward = TRUE;\r\n}\r\n}\r\nelse {\r\nif (BSSbIsSTAInNodeDB(pDevice, (PBYTE)(skb->data+cbHeaderOffset), &iDANodeIndex)) {\r\nif (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {\r\nif (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {\r\nskb->data += cbHeaderOffset;\r\nskb->tail += cbHeaderOffset;\r\nskb_put(skb, FrameSize);\r\nskb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb);\r\npMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;\r\nwAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;\r\npMgmt->abyPSTxMap[wAID >> 3] |= byMask[wAID & 7];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",\r\niDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);\r\nreturn TRUE;\r\n}\r\nelse {\r\nbRelayOnly = TRUE;\r\n}\r\n}\r\n}\r\n}\r\nif (bRelayOnly || bRelayAndForward) {\r\nif (bRelayAndForward)\r\niDANodeIndex = 0;\r\nif ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0)) {\r\nbRelayPacketSend(pDevice, (PBYTE) (skb->data + cbHeaderOffset),\r\nFrameSize, (unsigned int) iDANodeIndex);\r\n}\r\nif (bRelayOnly)\r\nreturn FALSE;\r\n}\r\nif (pDevice->uAssocCount == 0)\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nvoid RXvWorkItem(void *Context)\r\n{\r\nPSDevice pDevice = (PSDevice) Context;\r\nint ntStatus;\r\nPRCB pRCB=NULL;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->Rx Polling Thread\n");\r\nspin_lock_irq(&pDevice->lock);\r\nwhile ((pDevice->Flags & fMP_POST_READS) &&\r\nMP_IS_READY(pDevice) &&\r\n(pDevice->NumRecvFreeList != 0) ) {\r\npRCB = pDevice->FirstRecvFreeList;\r\npDevice->NumRecvFreeList--;\r\nASSERT(pRCB);\r\nDequeueRCB(pDevice->FirstRecvFreeList, pDevice->LastRecvFreeList);\r\nntStatus = PIPEnsBulkInUsbRead(pDevice, pRCB);\r\n}\r\npDevice->bIsRxWorkItemQueued = FALSE;\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\nvoid\r\nRXvFreeRCB(\r\nPRCB pRCB,\r\nBOOL bReAllocSkb\r\n)\r\n{\r\nPSDevice pDevice = (PSDevice)pRCB->pDevice;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->RXvFreeRCB\n");\r\nASSERT(!pRCB->Ref);\r\nASSERT(pRCB->pDevice);\r\nif (bReAllocSkb == TRUE) {\r\npRCB->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (pRCB->skb == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to re-alloc rx skb\n");\r\n}else {\r\npRCB->skb->dev = pDevice->dev;\r\n}\r\n}\r\nEnqueueRCB(pDevice->FirstRecvFreeList, pDevice->LastRecvFreeList, pRCB);\r\npDevice->NumRecvFreeList++;\r\nif ((pDevice->Flags & fMP_POST_READS) && MP_IS_READY(pDevice) &&\r\n(pDevice->bIsRxWorkItemQueued == FALSE) ) {\r\npDevice->bIsRxWorkItemQueued = TRUE;\r\ntasklet_schedule(&pDevice->ReadWorkItem);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"<----RXFreeRCB %d %d\n",pDevice->NumRecvFreeList, pDevice->NumRecvMngList);\r\n}\r\nvoid RXvMngWorkItem(void *Context)\r\n{\r\nPSDevice pDevice = (PSDevice) Context;\r\nPRCB pRCB=NULL;\r\nPSRxMgmtPacket pRxPacket;\r\nBOOL bReAllocSkb = FALSE;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->Rx Mng Thread\n");\r\nspin_lock_irq(&pDevice->lock);\r\nwhile (pDevice->NumRecvMngList!=0)\r\n{\r\npRCB = pDevice->FirstRecvMngList;\r\npDevice->NumRecvMngList--;\r\nDequeueRCB(pDevice->FirstRecvMngList, pDevice->LastRecvMngList);\r\nif(!pRCB){\r\nbreak;\r\n}\r\nASSERT(pRCB);\r\npRxPacket = &(pRCB->sMngPacket);\r\nvMgrRxManagePacket((void *) pDevice, &(pDevice->sMgmtObj), pRxPacket);\r\npRCB->Ref--;\r\nif(pRCB->Ref == 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"RxvFreeMng %d %d\n",pDevice->NumRecvFreeList, pDevice->NumRecvMngList);\r\nRXvFreeRCB(pRCB, bReAllocSkb);\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Rx Mng Only we have the right to free RCB\n");\r\n}\r\n}\r\npDevice->bIsRxMngWorkItemQueued = FALSE;\r\nspin_unlock_irq(&pDevice->lock);\r\n}
