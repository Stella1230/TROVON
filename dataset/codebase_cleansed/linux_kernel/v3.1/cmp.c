void cmp_connection_destroy(struct cmp_connection *c)\r\n{\r\nWARN_ON(c->connected);\r\nmutex_destroy(&c->mutex);\r\nfw_iso_resources_destroy(&c->resources);\r\n}\r\nstatic __be32 ipcr_set_modify(struct cmp_connection *c, __be32 ipcr)\r\n{\r\nipcr &= ~cpu_to_be32(IPCR_BCAST_CONN |\r\nIPCR_P2P_CONN_MASK |\r\nIPCR_CHANNEL_MASK);\r\nipcr |= cpu_to_be32(1 << IPCR_P2P_CONN_SHIFT);\r\nipcr |= cpu_to_be32(c->resources.channel << IPCR_CHANNEL_SHIFT);\r\nreturn ipcr;\r\n}\r\nstatic int ipcr_set_check(struct cmp_connection *c, __be32 ipcr)\r\n{\r\nif (ipcr & cpu_to_be32(IPCR_BCAST_CONN |\r\nIPCR_P2P_CONN_MASK)) {\r\ncmp_error(c, "plug is already in use\n");\r\nreturn -EBUSY;\r\n}\r\nif (!(ipcr & cpu_to_be32(IPCR_ONLINE))) {\r\ncmp_error(c, "plug is not on-line\n");\r\nreturn -ECONNREFUSED;\r\n}\r\nreturn 0;\r\n}\r\nint cmp_connection_establish(struct cmp_connection *c,\r\nunsigned int max_payload_bytes)\r\n{\r\nint err;\r\nif (WARN_ON(c->connected))\r\nreturn -EISCONN;\r\nc->speed = min(c->max_speed,\r\nfw_parent_device(c->resources.unit)->max_speed);\r\nmutex_lock(&c->mutex);\r\nretry_after_bus_reset:\r\nerr = fw_iso_resources_allocate(&c->resources,\r\nmax_payload_bytes, c->speed);\r\nif (err < 0)\r\ngoto err_mutex;\r\nerr = pcr_modify(c, ipcr_set_modify, ipcr_set_check,\r\nABORT_ON_BUS_RESET);\r\nif (err == -EAGAIN) {\r\nfw_iso_resources_free(&c->resources);\r\ngoto retry_after_bus_reset;\r\n}\r\nif (err < 0)\r\ngoto err_resources;\r\nc->connected = true;\r\nmutex_unlock(&c->mutex);\r\nreturn 0;\r\nerr_resources:\r\nfw_iso_resources_free(&c->resources);\r\nerr_mutex:\r\nmutex_unlock(&c->mutex);\r\nreturn err;\r\n}\r\nint cmp_connection_update(struct cmp_connection *c)\r\n{\r\nint err;\r\nmutex_lock(&c->mutex);\r\nif (!c->connected) {\r\nmutex_unlock(&c->mutex);\r\nreturn 0;\r\n}\r\nerr = fw_iso_resources_update(&c->resources);\r\nif (err < 0)\r\ngoto err_unconnect;\r\nerr = pcr_modify(c, ipcr_set_modify, ipcr_set_check,\r\nSUCCEED_ON_BUS_RESET);\r\nif (err < 0)\r\ngoto err_resources;\r\nmutex_unlock(&c->mutex);\r\nreturn 0;\r\nerr_resources:\r\nfw_iso_resources_free(&c->resources);\r\nerr_unconnect:\r\nc->connected = false;\r\nmutex_unlock(&c->mutex);\r\nreturn err;\r\n}\r\nstatic __be32 ipcr_break_modify(struct cmp_connection *c, __be32 ipcr)\r\n{\r\nreturn ipcr & ~cpu_to_be32(IPCR_BCAST_CONN | IPCR_P2P_CONN_MASK);\r\n}\r\nvoid cmp_connection_break(struct cmp_connection *c)\r\n{\r\nint err;\r\nmutex_lock(&c->mutex);\r\nif (!c->connected) {\r\nmutex_unlock(&c->mutex);\r\nreturn;\r\n}\r\nerr = pcr_modify(c, ipcr_break_modify, NULL, SUCCEED_ON_BUS_RESET);\r\nif (err < 0)\r\ncmp_error(c, "plug is still connected\n");\r\nfw_iso_resources_free(&c->resources);\r\nc->connected = false;\r\nmutex_unlock(&c->mutex);\r\n}
