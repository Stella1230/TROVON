static int tda18212_wr_regs(struct tda18212_priv *priv, u8 reg, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 buf[len+1];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg->i2c_address,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\nwarn("i2c wr failed ret:%d reg:%02x len:%d", ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda18212_rd_regs(struct tda18212_priv *priv, u8 reg, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 buf[len];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg->i2c_address,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->cfg->i2c_address,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\nwarn("i2c rd failed ret:%d reg:%02x len:%d", ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda18212_wr_reg(struct tda18212_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn tda18212_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int tda18212_rd_reg(struct tda18212_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn tda18212_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int tda18212_set_params(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nstruct tda18212_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu32 if_khz;\r\nu8 buf[9];\r\nstatic const u8 bw_params[][3] = {\r\n{ 0xb3, 0x20, 0x03 },\r\n{ 0xb3, 0x31, 0x01 },\r\n{ 0xb3, 0x22, 0x01 },\r\n{ 0x92, 0x53, 0x03 },\r\n};\r\ndbg("%s: delsys=%d RF=%d BW=%d", __func__,\r\nc->delivery_system, c->frequency, c->bandwidth_hz);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nif_khz = priv->cfg->if_dvbt_6;\r\ni = 0;\r\nbreak;\r\ncase 7000000:\r\nif_khz = priv->cfg->if_dvbt_7;\r\ni = 1;\r\nbreak;\r\ncase 8000000:\r\nif_khz = priv->cfg->if_dvbt_8;\r\ni = 2;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbreak;\r\ncase SYS_DVBC_ANNEX_AC:\r\nif_khz = priv->cfg->if_dvbc;\r\ni = 3;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = tda18212_wr_reg(priv, 0x23, bw_params[i][2]);\r\nif (ret)\r\ngoto error;\r\nret = tda18212_wr_reg(priv, 0x06, 0x00);\r\nif (ret)\r\ngoto error;\r\nret = tda18212_wr_reg(priv, 0x0f, bw_params[i][0]);\r\nif (ret)\r\ngoto error;\r\nbuf[0] = 0x02;\r\nbuf[1] = bw_params[i][1];\r\nbuf[2] = 0x03;\r\nbuf[3] = if_khz / 50;\r\nbuf[4] = ((c->frequency / 1000) >> 16) & 0xff;\r\nbuf[5] = ((c->frequency / 1000) >> 8) & 0xff;\r\nbuf[6] = ((c->frequency / 1000) >> 0) & 0xff;\r\nbuf[7] = 0xc1;\r\nbuf[8] = 0x01;\r\nret = tda18212_wr_regs(priv, 0x12, buf, sizeof(buf));\r\nif (ret)\r\ngoto error;\r\nexit:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\nerror:\r\ndbg("%s: failed:%d", __func__, ret);\r\ngoto exit;\r\n}\r\nstatic int tda18212_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tda18212_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, struct tda18212_config *cfg)\r\n{\r\nstruct tda18212_priv *priv = NULL;\r\nint ret;\r\nu8 val;\r\npriv = kzalloc(sizeof(struct tda18212_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\nfe->tuner_priv = priv;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = tda18212_rd_reg(priv, 0x00, &val);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndbg("%s: ret:%d chip ID:%02x", __func__, ret, val);\r\nif (ret || val != 0xc7) {\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\ninfo("NXP TDA18212HN successfully identified.");\r\nmemcpy(&fe->ops.tuner_ops, &tda18212_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\n}
