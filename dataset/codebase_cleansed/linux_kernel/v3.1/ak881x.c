static int reg_read(struct i2c_client *client, const u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int reg_write(struct i2c_client *client, const u8 reg,\r\nconst u8 data)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, data);\r\n}\r\nstatic int reg_set(struct i2c_client *client, const u8 reg,\r\nconst u8 data, u8 mask)\r\n{\r\nint ret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, (ret & ~mask) | (data & mask));\r\n}\r\nstatic struct ak881x *to_ak881x(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct ak881x, subdev);\r\n}\r\nstatic int ak881x_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nif (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)\r\nreturn -EINVAL;\r\nif (id->match.addr != client->addr)\r\nreturn -ENODEV;\r\nid->ident = ak881x->id;\r\nid->revision = ak881x->revision;\r\nreturn 0;\r\n}\r\nstatic int ak881x_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->match.type != V4L2_CHIP_MATCH_I2C_ADDR || reg->reg > 0x26)\r\nreturn -EINVAL;\r\nif (reg->match.addr != client->addr)\r\nreturn -ENODEV;\r\nreg->val = reg_read(client, reg->reg);\r\nif (reg->val > 0xffff)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ak881x_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->match.type != V4L2_CHIP_MATCH_I2C_ADDR || reg->reg > 0x26)\r\nreturn -EINVAL;\r\nif (reg->match.addr != client->addr)\r\nreturn -ENODEV;\r\nif (reg_write(client, reg->reg, reg->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ak881x_try_g_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nv4l_bound_align_image(&mf->width, 0, 720, 2,\r\n&mf->height, 0, ak881x->lines, 1, 0);\r\nmf->field = V4L2_FIELD_INTERLACED;\r\nmf->code = V4L2_MBUS_FMT_YUYV8_2X8;\r\nmf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int ak881x_s_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nif (mf->field != V4L2_FIELD_INTERLACED ||\r\nmf->code != V4L2_MBUS_FMT_YUYV8_2X8)\r\nreturn -EINVAL;\r\nreturn ak881x_try_g_mbus_fmt(sd, mf);\r\n}\r\nstatic int ak881x_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index)\r\nreturn -EINVAL;\r\n*code = V4L2_MBUS_FMT_YUYV8_2X8;\r\nreturn 0;\r\n}\r\nstatic int ak881x_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = 720;\r\na->bounds.height = ak881x->lines;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int ak881x_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nu8 vp1;\r\nif (std == V4L2_STD_NTSC_443) {\r\nvp1 = 3;\r\nak881x->lines = 480;\r\n} else if (std == V4L2_STD_PAL_M) {\r\nvp1 = 5;\r\nak881x->lines = 480;\r\n} else if (std == V4L2_STD_PAL_60) {\r\nvp1 = 7;\r\nak881x->lines = 480;\r\n} else if (std && !(std & ~V4L2_STD_PAL)) {\r\nvp1 = 0xf;\r\nak881x->lines = 576;\r\n} else if (std && !(std & ~V4L2_STD_NTSC)) {\r\nvp1 = 0;\r\nak881x->lines = 480;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreg_set(client, AK881X_VIDEO_PROCESS1, vp1, 0xf);\r\nreturn 0;\r\n}\r\nstatic int ak881x_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nif (enable) {\r\nu8 dac;\r\nif (ak881x->pdata->flags & AK881X_COMPONENT)\r\ndac = 3;\r\nelse\r\ndac = 4;\r\nreg_write(client, AK881X_DAC_MODE, dac);\r\ndev_dbg(&client->dev, "chip status 0x%x\n",\r\nreg_read(client, AK881X_STATUS));\r\n} else {\r\nreg_write(client, AK881X_DAC_MODE, 0);\r\ndev_dbg(&client->dev, "chip status 0x%x\n",\r\nreg_read(client, AK881X_STATUS));\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak881x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct ak881x *ak881x;\r\nu8 ifmode, data;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nak881x = kzalloc(sizeof(struct ak881x), GFP_KERNEL);\r\nif (!ak881x)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&ak881x->subdev, client, &ak881x_subdev_ops);\r\ndata = reg_read(client, AK881X_DEVICE_ID);\r\nswitch (data) {\r\ncase 0x13:\r\nak881x->id = V4L2_IDENT_AK8813;\r\nbreak;\r\ncase 0x14:\r\nak881x->id = V4L2_IDENT_AK8814;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"No ak881x chip detected, register read %x\n", data);\r\nkfree(ak881x);\r\nreturn -ENODEV;\r\n}\r\nak881x->revision = reg_read(client, AK881X_DEVICE_REVISION);\r\nak881x->pdata = client->dev.platform_data;\r\nif (ak881x->pdata) {\r\nif (ak881x->pdata->flags & AK881X_FIELD)\r\nifmode = 4;\r\nelse\r\nifmode = 0;\r\nswitch (ak881x->pdata->flags & AK881X_IF_MODE_MASK) {\r\ncase AK881X_IF_MODE_BT656:\r\nifmode |= 1;\r\nbreak;\r\ncase AK881X_IF_MODE_MASTER:\r\nifmode |= 2;\r\nbreak;\r\ncase AK881X_IF_MODE_SLAVE:\r\ndefault:\r\nbreak;\r\n}\r\ndev_dbg(&client->dev, "IF mode %x\n", ifmode);\r\nreg_write(client, AK881X_INTERFACE_MODE, ifmode | (20 << 3));\r\n}\r\nak881x->lines = 480;\r\ndev_info(&client->dev, "Detected an ak881x chip ID %x, revision %x\n",\r\ndata, ak881x->revision);\r\nreturn 0;\r\n}\r\nstatic int ak881x_remove(struct i2c_client *client)\r\n{\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nv4l2_device_unregister_subdev(&ak881x->subdev);\r\nkfree(ak881x);\r\nreturn 0;\r\n}\r\nstatic int __init ak881x_module_init(void)\r\n{\r\nreturn i2c_add_driver(&ak881x_i2c_driver);\r\n}\r\nstatic void __exit ak881x_module_exit(void)\r\n{\r\ni2c_del_driver(&ak881x_i2c_driver);\r\n}
