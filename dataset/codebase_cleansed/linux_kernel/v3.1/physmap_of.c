static int parse_obsolete_partitions(struct platform_device *dev,\r\nstruct of_flash *info,\r\nstruct device_node *dp)\r\n{\r\nint i, plen, nr_parts;\r\nconst struct {\r\n__be32 offset, len;\r\n} *part;\r\nconst char *names;\r\npart = of_get_property(dp, "partitions", &plen);\r\nif (!part)\r\nreturn 0;\r\ndev_warn(&dev->dev, "Device tree uses obsolete partition map binding\n");\r\nnr_parts = plen / sizeof(part[0]);\r\ninfo->parts = kzalloc(nr_parts * sizeof(*info->parts), GFP_KERNEL);\r\nif (!info->parts)\r\nreturn -ENOMEM;\r\nnames = of_get_property(dp, "partition-names", &plen);\r\nfor (i = 0; i < nr_parts; i++) {\r\ninfo->parts[i].offset = be32_to_cpu(part->offset);\r\ninfo->parts[i].size = be32_to_cpu(part->len) & ~1;\r\nif (be32_to_cpu(part->len) & 1)\r\ninfo->parts[i].mask_flags = MTD_WRITEABLE;\r\nif (names && (plen > 0)) {\r\nint len = strlen(names) + 1;\r\ninfo->parts[i].name = (char *)names;\r\nplen -= len;\r\nnames += len;\r\n} else {\r\ninfo->parts[i].name = "unnamed";\r\n}\r\npart++;\r\n}\r\nreturn nr_parts;\r\n}\r\nstatic int of_flash_remove(struct platform_device *dev)\r\n{\r\nstruct of_flash *info;\r\nint i;\r\ninfo = dev_get_drvdata(&dev->dev);\r\nif (!info)\r\nreturn 0;\r\ndev_set_drvdata(&dev->dev, NULL);\r\nif (info->cmtd != info->list[0].mtd) {\r\nmtd_device_unregister(info->cmtd);\r\nmtd_concat_destroy(info->cmtd);\r\n}\r\nif (info->cmtd) {\r\nif (OF_FLASH_PARTS(info))\r\nkfree(OF_FLASH_PARTS(info));\r\nmtd_device_unregister(info->cmtd);\r\n}\r\nfor (i = 0; i < info->list_size; i++) {\r\nif (info->list[i].mtd)\r\nmap_destroy(info->list[i].mtd);\r\nif (info->list[i].map.virt)\r\niounmap(info->list[i].map.virt);\r\nif (info->list[i].res) {\r\nrelease_resource(info->list[i].res);\r\nkfree(info->list[i].res);\r\n}\r\n}\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic struct mtd_info * __devinit obsolete_probe(struct platform_device *dev,\r\nstruct map_info *map)\r\n{\r\nstruct device_node *dp = dev->dev.of_node;\r\nconst char *of_probe;\r\nstruct mtd_info *mtd;\r\nstatic const char *rom_probe_types[]\r\n= { "cfi_probe", "jedec_probe", "map_rom"};\r\nint i;\r\ndev_warn(&dev->dev, "Device tree uses obsolete \"direct-mapped\" "\r\n"flash binding\n");\r\nof_probe = of_get_property(dp, "probe-type", NULL);\r\nif (!of_probe) {\r\nfor (i = 0; i < ARRAY_SIZE(rom_probe_types); i++) {\r\nmtd = do_map_probe(rom_probe_types[i], map);\r\nif (mtd)\r\nreturn mtd;\r\n}\r\nreturn NULL;\r\n} else if (strcmp(of_probe, "CFI") == 0) {\r\nreturn do_map_probe("cfi_probe", map);\r\n} else if (strcmp(of_probe, "JEDEC") == 0) {\r\nreturn do_map_probe("jedec_probe", map);\r\n} else {\r\nif (strcmp(of_probe, "ROM") != 0)\r\ndev_warn(&dev->dev, "obsolete_probe: don't know probe "\r\n"type '%s', mapping as rom\n", of_probe);\r\nreturn do_map_probe("mtd_rom", map);\r\n}\r\n}\r\nstatic const char ** __devinit of_get_probes(struct device_node *dp)\r\n{\r\nconst char *cp;\r\nint cplen;\r\nunsigned int l;\r\nunsigned int count;\r\nconst char **res;\r\ncp = of_get_property(dp, "linux,part-probe", &cplen);\r\nif (cp == NULL)\r\nreturn part_probe_types_def;\r\ncount = 0;\r\nfor (l = 0; l != cplen; l++)\r\nif (cp[l] == 0)\r\ncount++;\r\nres = kzalloc((count + 1)*sizeof(*res), GFP_KERNEL);\r\ncount = 0;\r\nwhile (cplen > 0) {\r\nres[count] = cp;\r\nl = strlen(cp) + 1;\r\ncp += l;\r\ncplen -= l;\r\ncount++;\r\n}\r\nreturn res;\r\n}\r\nstatic void __devinit of_free_probes(const char **probes)\r\n{\r\nif (probes != part_probe_types_def)\r\nkfree(probes);\r\n}\r\nstatic int __devinit of_flash_probe(struct platform_device *dev)\r\n{\r\nconst char **part_probe_types;\r\nconst struct of_device_id *match;\r\nstruct device_node *dp = dev->dev.of_node;\r\nstruct resource res;\r\nstruct of_flash *info;\r\nconst char *probe_type;\r\nconst __be32 *width;\r\nint err;\r\nint i;\r\nint count;\r\nconst __be32 *p;\r\nint reg_tuple_size;\r\nstruct mtd_info **mtd_list = NULL;\r\nresource_size_t res_size;\r\nmatch = of_match_device(of_flash_match, &dev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nprobe_type = match->data;\r\nreg_tuple_size = (of_n_addr_cells(dp) + of_n_size_cells(dp)) * sizeof(u32);\r\np = of_get_property(dp, "reg", &count);\r\nif (count % reg_tuple_size != 0) {\r\ndev_err(&dev->dev, "Malformed reg property on %s\n",\r\ndev->dev.of_node->full_name);\r\nerr = -EINVAL;\r\ngoto err_flash_remove;\r\n}\r\ncount /= reg_tuple_size;\r\nerr = -ENOMEM;\r\ninfo = kzalloc(sizeof(struct of_flash) +\r\nsizeof(struct of_flash_list) * count, GFP_KERNEL);\r\nif (!info)\r\ngoto err_flash_remove;\r\ndev_set_drvdata(&dev->dev, info);\r\nmtd_list = kzalloc(sizeof(*mtd_list) * count, GFP_KERNEL);\r\nif (!mtd_list)\r\ngoto err_flash_remove;\r\nfor (i = 0; i < count; i++) {\r\nerr = -ENXIO;\r\nif (of_address_to_resource(dp, i, &res)) {\r\ncontinue;\r\n}\r\ndev_dbg(&dev->dev, "of_flash device: %pR\n", &res);\r\nerr = -EBUSY;\r\nres_size = resource_size(&res);\r\ninfo->list[i].res = request_mem_region(res.start, res_size,\r\ndev_name(&dev->dev));\r\nif (!info->list[i].res)\r\ngoto err_out;\r\nerr = -ENXIO;\r\nwidth = of_get_property(dp, "bank-width", NULL);\r\nif (!width) {\r\ndev_err(&dev->dev, "Can't get bank width from device"\r\n" tree\n");\r\ngoto err_out;\r\n}\r\ninfo->list[i].map.name = dev_name(&dev->dev);\r\ninfo->list[i].map.phys = res.start;\r\ninfo->list[i].map.size = res_size;\r\ninfo->list[i].map.bankwidth = be32_to_cpup(width);\r\nerr = -ENOMEM;\r\ninfo->list[i].map.virt = ioremap(info->list[i].map.phys,\r\ninfo->list[i].map.size);\r\nif (!info->list[i].map.virt) {\r\ndev_err(&dev->dev, "Failed to ioremap() flash"\r\n" region\n");\r\ngoto err_out;\r\n}\r\nsimple_map_init(&info->list[i].map);\r\nif (probe_type) {\r\ninfo->list[i].mtd = do_map_probe(probe_type,\r\n&info->list[i].map);\r\n} else {\r\ninfo->list[i].mtd = obsolete_probe(dev,\r\n&info->list[i].map);\r\n}\r\nmtd_list[i] = info->list[i].mtd;\r\nerr = -ENXIO;\r\nif (!info->list[i].mtd) {\r\ndev_err(&dev->dev, "do_map_probe() failed\n");\r\ngoto err_out;\r\n} else {\r\ninfo->list_size++;\r\n}\r\ninfo->list[i].mtd->owner = THIS_MODULE;\r\ninfo->list[i].mtd->dev.parent = &dev->dev;\r\n}\r\nerr = 0;\r\nif (info->list_size == 1) {\r\ninfo->cmtd = info->list[0].mtd;\r\n} else if (info->list_size > 1) {\r\ninfo->cmtd = mtd_concat_create(mtd_list, info->list_size,\r\ndev_name(&dev->dev));\r\nif (info->cmtd == NULL)\r\nerr = -ENXIO;\r\n}\r\nif (err)\r\ngoto err_out;\r\npart_probe_types = of_get_probes(dp);\r\nerr = parse_mtd_partitions(info->cmtd, part_probe_types,\r\n&info->parts, 0);\r\nif (err < 0) {\r\nof_free_probes(part_probe_types);\r\ngoto err_out;\r\n}\r\nof_free_probes(part_probe_types);\r\nif (err == 0) {\r\nerr = of_mtd_parse_partitions(&dev->dev, dp, &info->parts);\r\nif (err < 0)\r\ngoto err_out;\r\n}\r\nif (err == 0) {\r\nerr = parse_obsolete_partitions(dev, info, dp);\r\nif (err < 0)\r\ngoto err_out;\r\n}\r\nmtd_device_register(info->cmtd, info->parts, err);\r\nkfree(mtd_list);\r\nreturn 0;\r\nerr_out:\r\nkfree(mtd_list);\r\nerr_flash_remove:\r\nof_flash_remove(dev);\r\nreturn err;\r\n}\r\nstatic int __init of_flash_init(void)\r\n{\r\nreturn platform_driver_register(&of_flash_driver);\r\n}\r\nstatic void __exit of_flash_exit(void)\r\n{\r\nplatform_driver_unregister(&of_flash_driver);\r\n}
