static void do_z2_request(struct request_queue *q)\r\n{\r\nstruct request *req;\r\nreq = blk_fetch_request(q);\r\nwhile (req) {\r\nunsigned long start = blk_rq_pos(req) << 9;\r\nunsigned long len = blk_rq_cur_bytes(req);\r\nint err = 0;\r\nif (start + len > z2ram_size) {\r\npr_err(DEVICE_NAME ": bad access: block=%llu, "\r\n"count=%u\n",\r\n(unsigned long long)blk_rq_pos(req),\r\nblk_rq_cur_sectors(req));\r\nerr = -EIO;\r\ngoto done;\r\n}\r\nwhile (len) {\r\nunsigned long addr = start & Z2RAM_CHUNKMASK;\r\nunsigned long size = Z2RAM_CHUNKSIZE - addr;\r\nif (len < size)\r\nsize = len;\r\naddr += z2ram_map[ start >> Z2RAM_CHUNKSHIFT ];\r\nif (rq_data_dir(req) == READ)\r\nmemcpy(req->buffer, (char *)addr, size);\r\nelse\r\nmemcpy((char *)addr, req->buffer, size);\r\nstart += size;\r\nlen -= size;\r\n}\r\ndone:\r\nif (!__blk_end_request_cur(req, err))\r\nreq = blk_fetch_request(q);\r\n}\r\n}\r\nstatic void\r\nget_z2ram( void )\r\n{\r\nint i;\r\nfor ( i = 0; i < Z2RAM_SIZE / Z2RAM_CHUNKSIZE; i++ )\r\n{\r\nif ( test_bit( i, zorro_unused_z2ram ) )\r\n{\r\nz2_count++;\r\nz2ram_map[ z2ram_size++ ] =\r\nZTWO_VADDR( Z2RAM_START ) + ( i << Z2RAM_CHUNKSHIFT );\r\nclear_bit( i, zorro_unused_z2ram );\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nget_chipram( void )\r\n{\r\nwhile ( amiga_chip_avail() > ( Z2RAM_CHUNKSIZE * 4 ) )\r\n{\r\nchip_count++;\r\nz2ram_map[ z2ram_size ] =\r\n(u_long)amiga_chip_alloc( Z2RAM_CHUNKSIZE, "z2ram" );\r\nif ( z2ram_map[ z2ram_size ] == 0 )\r\n{\r\nbreak;\r\n}\r\nz2ram_size++;\r\n}\r\nreturn;\r\n}\r\nstatic int z2_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint device;\r\nint max_z2_map = ( Z2RAM_SIZE / Z2RAM_CHUNKSIZE ) *\r\nsizeof( z2ram_map[0] );\r\nint max_chip_map = ( amiga_chip_size / Z2RAM_CHUNKSIZE ) *\r\nsizeof( z2ram_map[0] );\r\nint rc = -ENOMEM;\r\ndevice = MINOR(bdev->bd_dev);\r\nmutex_lock(&z2ram_mutex);\r\nif ( current_device != -1 && current_device != device )\r\n{\r\nrc = -EBUSY;\r\ngoto err_out;\r\n}\r\nif ( current_device == -1 )\r\n{\r\nz2_count = 0;\r\nchip_count = 0;\r\nlist_count = 0;\r\nz2ram_size = 0;\r\nif (device >= Z2MINOR_MEMLIST1 && device <= Z2MINOR_MEMLIST4) {\r\nint index = device - Z2MINOR_MEMLIST1 + 1;\r\nunsigned long size, paddr, vaddr;\r\nif (index >= m68k_realnum_memory) {\r\nprintk( KERN_ERR DEVICE_NAME\r\n": no such entry in z2ram_map\n" );\r\ngoto err_out;\r\n}\r\npaddr = m68k_memory[index].addr;\r\nsize = m68k_memory[index].size & ~(Z2RAM_CHUNKSIZE-1);\r\n#ifdef __powerpc__\r\n{\r\nvfree(vmalloc (size));\r\n}\r\nvaddr = (unsigned long) __ioremap (paddr, size,\r\n_PAGE_WRITETHRU);\r\n#else\r\nvaddr = (unsigned long)z_remap_nocache_nonser(paddr, size);\r\n#endif\r\nz2ram_map =\r\nkmalloc((size/Z2RAM_CHUNKSIZE)*sizeof(z2ram_map[0]),\r\nGFP_KERNEL);\r\nif ( z2ram_map == NULL )\r\n{\r\nprintk( KERN_ERR DEVICE_NAME\r\n": cannot get mem for z2ram_map\n" );\r\ngoto err_out;\r\n}\r\nwhile (size) {\r\nz2ram_map[ z2ram_size++ ] = vaddr;\r\nsize -= Z2RAM_CHUNKSIZE;\r\nvaddr += Z2RAM_CHUNKSIZE;\r\nlist_count++;\r\n}\r\nif ( z2ram_size != 0 )\r\nprintk( KERN_INFO DEVICE_NAME\r\n": using %iK List Entry %d Memory\n",\r\nlist_count * Z2RAM_CHUNK1024, index );\r\n} else\r\nswitch ( device )\r\n{\r\ncase Z2MINOR_COMBINED:\r\nz2ram_map = kmalloc( max_z2_map + max_chip_map, GFP_KERNEL );\r\nif ( z2ram_map == NULL )\r\n{\r\nprintk( KERN_ERR DEVICE_NAME\r\n": cannot get mem for z2ram_map\n" );\r\ngoto err_out;\r\n}\r\nget_z2ram();\r\nget_chipram();\r\nif ( z2ram_size != 0 )\r\nprintk( KERN_INFO DEVICE_NAME\r\n": using %iK Zorro II RAM and %iK Chip RAM (Total %dK)\n",\r\nz2_count * Z2RAM_CHUNK1024,\r\nchip_count * Z2RAM_CHUNK1024,\r\n( z2_count + chip_count ) * Z2RAM_CHUNK1024 );\r\nbreak;\r\ncase Z2MINOR_Z2ONLY:\r\nz2ram_map = kmalloc( max_z2_map, GFP_KERNEL );\r\nif ( z2ram_map == NULL )\r\n{\r\nprintk( KERN_ERR DEVICE_NAME\r\n": cannot get mem for z2ram_map\n" );\r\ngoto err_out;\r\n}\r\nget_z2ram();\r\nif ( z2ram_size != 0 )\r\nprintk( KERN_INFO DEVICE_NAME\r\n": using %iK of Zorro II RAM\n",\r\nz2_count * Z2RAM_CHUNK1024 );\r\nbreak;\r\ncase Z2MINOR_CHIPONLY:\r\nz2ram_map = kmalloc( max_chip_map, GFP_KERNEL );\r\nif ( z2ram_map == NULL )\r\n{\r\nprintk( KERN_ERR DEVICE_NAME\r\n": cannot get mem for z2ram_map\n" );\r\ngoto err_out;\r\n}\r\nget_chipram();\r\nif ( z2ram_size != 0 )\r\nprintk( KERN_INFO DEVICE_NAME\r\n": using %iK Chip RAM\n",\r\nchip_count * Z2RAM_CHUNK1024 );\r\nbreak;\r\ndefault:\r\nrc = -ENODEV;\r\ngoto err_out;\r\nbreak;\r\n}\r\nif ( z2ram_size == 0 )\r\n{\r\nprintk( KERN_NOTICE DEVICE_NAME\r\n": no unused ZII/Chip RAM found\n" );\r\ngoto err_out_kfree;\r\n}\r\ncurrent_device = device;\r\nz2ram_size <<= Z2RAM_CHUNKSHIFT;\r\nset_capacity(z2ram_gendisk, z2ram_size >> 9);\r\n}\r\nmutex_unlock(&z2ram_mutex);\r\nreturn 0;\r\nerr_out_kfree:\r\nkfree(z2ram_map);\r\nerr_out:\r\nmutex_unlock(&z2ram_mutex);\r\nreturn rc;\r\n}\r\nstatic int\r\nz2_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nmutex_lock(&z2ram_mutex);\r\nif ( current_device == -1 ) {\r\nmutex_unlock(&z2ram_mutex);\r\nreturn 0;\r\n}\r\nmutex_unlock(&z2ram_mutex);\r\nreturn 0;\r\n}\r\nstatic struct kobject *z2_find(dev_t dev, int *part, void *data)\r\n{\r\n*part = 0;\r\nreturn get_disk(z2ram_gendisk);\r\n}\r\nstatic int __init\r\nz2_init(void)\r\n{\r\nint ret;\r\nif (!MACH_IS_AMIGA)\r\nreturn -ENODEV;\r\nret = -EBUSY;\r\nif (register_blkdev(Z2RAM_MAJOR, DEVICE_NAME))\r\ngoto err;\r\nret = -ENOMEM;\r\nz2ram_gendisk = alloc_disk(1);\r\nif (!z2ram_gendisk)\r\ngoto out_disk;\r\nz2_queue = blk_init_queue(do_z2_request, &z2ram_lock);\r\nif (!z2_queue)\r\ngoto out_queue;\r\nz2ram_gendisk->major = Z2RAM_MAJOR;\r\nz2ram_gendisk->first_minor = 0;\r\nz2ram_gendisk->fops = &z2_fops;\r\nsprintf(z2ram_gendisk->disk_name, "z2ram");\r\nz2ram_gendisk->queue = z2_queue;\r\nadd_disk(z2ram_gendisk);\r\nblk_register_region(MKDEV(Z2RAM_MAJOR, 0), Z2MINOR_COUNT, THIS_MODULE,\r\nz2_find, NULL, NULL);\r\nreturn 0;\r\nout_queue:\r\nput_disk(z2ram_gendisk);\r\nout_disk:\r\nunregister_blkdev(Z2RAM_MAJOR, DEVICE_NAME);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void __exit z2_exit(void)\r\n{\r\nint i, j;\r\nblk_unregister_region(MKDEV(Z2RAM_MAJOR, 0), Z2MINOR_COUNT);\r\nunregister_blkdev(Z2RAM_MAJOR, DEVICE_NAME);\r\ndel_gendisk(z2ram_gendisk);\r\nput_disk(z2ram_gendisk);\r\nblk_cleanup_queue(z2_queue);\r\nif ( current_device != -1 )\r\n{\r\ni = 0;\r\nfor ( j = 0 ; j < z2_count; j++ )\r\n{\r\nset_bit( i++, zorro_unused_z2ram );\r\n}\r\nfor ( j = 0 ; j < chip_count; j++ )\r\n{\r\nif ( z2ram_map[ i ] )\r\n{\r\namiga_chip_free( (void *) z2ram_map[ i++ ] );\r\n}\r\n}\r\nif ( z2ram_map != NULL )\r\n{\r\nkfree( z2ram_map );\r\n}\r\n}\r\nreturn;\r\n}
