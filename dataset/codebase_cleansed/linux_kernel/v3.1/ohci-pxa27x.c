static int pxa27x_ohci_select_pmm(struct pxa27x_ohci *ohci, int mode)\r\n{\r\nuint32_t uhcrhda = __raw_readl(ohci->mmio_base + UHCRHDA);\r\nuint32_t uhcrhdb = __raw_readl(ohci->mmio_base + UHCRHDB);\r\nswitch (mode) {\r\ncase PMM_NPS_MODE:\r\nuhcrhda |= RH_A_NPS;\r\nbreak;\r\ncase PMM_GLOBAL_MODE:\r\nuhcrhda &= ~(RH_A_NPS & RH_A_PSM);\r\nbreak;\r\ncase PMM_PERPORT_MODE:\r\nuhcrhda &= ~(RH_A_NPS);\r\nuhcrhda |= RH_A_PSM;\r\nuhcrhdb |= (0x7<<17);\r\nbreak;\r\ndefault:\r\nprintk( KERN_ERR\r\n"Invalid mode %d, set to non-power switch mode.\n",\r\nmode );\r\nuhcrhda |= RH_A_NPS;\r\n}\r\n__raw_writel(uhcrhda, ohci->mmio_base + UHCRHDA);\r\n__raw_writel(uhcrhdb, ohci->mmio_base + UHCRHDB);\r\nreturn 0;\r\n}\r\nstatic inline void pxa27x_setup_hc(struct pxa27x_ohci *ohci,\r\nstruct pxaohci_platform_data *inf)\r\n{\r\nuint32_t uhchr = __raw_readl(ohci->mmio_base + UHCHR);\r\nuint32_t uhcrhda = __raw_readl(ohci->mmio_base + UHCRHDA);\r\nif (inf->flags & ENABLE_PORT1)\r\nuhchr &= ~UHCHR_SSEP1;\r\nif (inf->flags & ENABLE_PORT2)\r\nuhchr &= ~UHCHR_SSEP2;\r\nif (inf->flags & ENABLE_PORT3)\r\nuhchr &= ~UHCHR_SSEP3;\r\nif (inf->flags & POWER_CONTROL_LOW)\r\nuhchr |= UHCHR_PCPL;\r\nif (inf->flags & POWER_SENSE_LOW)\r\nuhchr |= UHCHR_PSPL;\r\nif (inf->flags & NO_OC_PROTECTION)\r\nuhcrhda |= UHCRHDA_NOCP;\r\nelse\r\nuhcrhda &= ~UHCRHDA_NOCP;\r\nif (inf->flags & OC_MODE_PERPORT)\r\nuhcrhda |= UHCRHDA_OCPM;\r\nelse\r\nuhcrhda &= ~UHCRHDA_OCPM;\r\nif (inf->power_on_delay) {\r\nuhcrhda &= ~UHCRHDA_POTPGT(0xff);\r\nuhcrhda |= UHCRHDA_POTPGT(inf->power_on_delay / 2);\r\n}\r\n__raw_writel(uhchr, ohci->mmio_base + UHCHR);\r\n__raw_writel(uhcrhda, ohci->mmio_base + UHCRHDA);\r\n}\r\nstatic inline void pxa27x_reset_hc(struct pxa27x_ohci *ohci)\r\n{\r\nuint32_t uhchr = __raw_readl(ohci->mmio_base + UHCHR);\r\n__raw_writel(uhchr | UHCHR_FHR, ohci->mmio_base + UHCHR);\r\nudelay(11);\r\n__raw_writel(uhchr & ~UHCHR_FHR, ohci->mmio_base + UHCHR);\r\n}\r\nstatic int pxa27x_start_hc(struct pxa27x_ohci *ohci, struct device *dev)\r\n{\r\nint retval = 0;\r\nstruct pxaohci_platform_data *inf;\r\nuint32_t uhchr;\r\ninf = dev->platform_data;\r\nclk_enable(ohci->clk);\r\npxa27x_reset_hc(ohci);\r\nuhchr = __raw_readl(ohci->mmio_base + UHCHR) | UHCHR_FSBIR;\r\n__raw_writel(uhchr, ohci->mmio_base + UHCHR);\r\nwhile (__raw_readl(ohci->mmio_base + UHCHR) & UHCHR_FSBIR)\r\ncpu_relax();\r\npxa27x_setup_hc(ohci, inf);\r\nif (inf->init)\r\nretval = inf->init(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nif (cpu_is_pxa3xx())\r\npxa3xx_u2d_start_hc(&ohci_to_hcd(&ohci->ohci)->self);\r\nuhchr = __raw_readl(ohci->mmio_base + UHCHR) & ~UHCHR_SSE;\r\n__raw_writel(uhchr, ohci->mmio_base + UHCHR);\r\n__raw_writel(UHCHIE_UPRIE | UHCHIE_RWIE, ohci->mmio_base + UHCHIE);\r\npxa27x_clear_otgph();\r\nreturn 0;\r\n}\r\nstatic void pxa27x_stop_hc(struct pxa27x_ohci *ohci, struct device *dev)\r\n{\r\nstruct pxaohci_platform_data *inf;\r\nuint32_t uhccoms;\r\ninf = dev->platform_data;\r\nif (cpu_is_pxa3xx())\r\npxa3xx_u2d_stop_hc(&ohci_to_hcd(&ohci->ohci)->self);\r\nif (inf->exit)\r\ninf->exit(dev);\r\npxa27x_reset_hc(ohci);\r\nuhccoms = __raw_readl(ohci->mmio_base + UHCCOMS) | 0x01;\r\n__raw_writel(uhccoms, ohci->mmio_base + UHCCOMS);\r\nudelay(10);\r\nclk_disable(ohci->clk);\r\n}\r\nint usb_hcd_pxa27x_probe (const struct hc_driver *driver, struct platform_device *pdev)\r\n{\r\nint retval, irq;\r\nstruct usb_hcd *hcd;\r\nstruct pxaohci_platform_data *inf;\r\nstruct pxa27x_ohci *ohci;\r\nstruct resource *r;\r\nstruct clk *usb_clk;\r\ninf = pdev->dev.platform_data;\r\nif (!inf)\r\nreturn -ENODEV;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\npr_err("no resource of IORESOURCE_IRQ");\r\nreturn -ENXIO;\r\n}\r\nusb_clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(usb_clk))\r\nreturn PTR_ERR(usb_clk);\r\nhcd = usb_create_hcd (driver, &pdev->dev, "pxa27x");\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto err0;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\npr_err("no resource of IORESOURCE_MEM");\r\nretval = -ENXIO;\r\ngoto err1;\r\n}\r\nhcd->rsrc_start = r->start;\r\nhcd->rsrc_len = resource_size(r);\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\r\npr_debug("request_mem_region failed");\r\nretval = -EBUSY;\r\ngoto err1;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\npr_debug("ioremap failed");\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\nohci = (struct pxa27x_ohci *)hcd_to_ohci(hcd);\r\nohci->dev = &pdev->dev;\r\nohci->clk = usb_clk;\r\nohci->mmio_base = (void __iomem *)hcd->regs;\r\nif ((retval = pxa27x_start_hc(ohci, &pdev->dev)) < 0) {\r\npr_debug("pxa27x_start_hc failed");\r\ngoto err3;\r\n}\r\npxa27x_ohci_select_pmm(ohci, inf->port_mode);\r\nif (inf->power_budget)\r\nhcd->power_budget = inf->power_budget;\r\nohci_hcd_init(hcd_to_ohci(hcd));\r\nretval = usb_add_hcd(hcd, irq, IRQF_DISABLED);\r\nif (retval == 0)\r\nreturn retval;\r\npxa27x_stop_hc(ohci, &pdev->dev);\r\nerr3:\r\niounmap(hcd->regs);\r\nerr2:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr1:\r\nusb_put_hcd(hcd);\r\nerr0:\r\nclk_put(usb_clk);\r\nreturn retval;\r\n}\r\nvoid usb_hcd_pxa27x_remove (struct usb_hcd *hcd, struct platform_device *pdev)\r\n{\r\nstruct pxa27x_ohci *ohci = to_pxa27x_ohci(hcd);\r\nusb_remove_hcd(hcd);\r\npxa27x_stop_hc(ohci, &pdev->dev);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\nclk_put(ohci->clk);\r\n}\r\nstatic int __devinit\r\nohci_pxa27x_start (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint ret;\r\nohci_dbg (ohci, "ohci_pxa27x_start, ohci:%p", ohci);\r\nohci->num_ports = 3;\r\nif ((ret = ohci_init(ohci)) < 0)\r\nreturn ret;\r\nif ((ret = ohci_run (ohci)) < 0) {\r\nerr ("can't start %s", hcd->self.bus_name);\r\nohci_stop (hcd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_pxa27x_drv_probe(struct platform_device *pdev)\r\n{\r\npr_debug ("In ohci_hcd_pxa27x_drv_probe");\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nreturn usb_hcd_pxa27x_probe(&ohci_pxa27x_hc_driver, pdev);\r\n}\r\nstatic int ohci_hcd_pxa27x_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nusb_hcd_pxa27x_remove(hcd, pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_pxa27x_drv_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct pxa27x_ohci *ohci = to_pxa27x_ohci(hcd);\r\nif (time_before(jiffies, ohci->ohci.next_statechange))\r\nmsleep(5);\r\nohci->ohci.next_statechange = jiffies;\r\npxa27x_stop_hc(ohci, dev);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_pxa27x_drv_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct pxa27x_ohci *ohci = to_pxa27x_ohci(hcd);\r\nstruct pxaohci_platform_data *inf = dev->platform_data;\r\nint status;\r\nif (time_before(jiffies, ohci->ohci.next_statechange))\r\nmsleep(5);\r\nohci->ohci.next_statechange = jiffies;\r\nif ((status = pxa27x_start_hc(ohci, dev)) < 0)\r\nreturn status;\r\npxa27x_ohci_select_pmm(ohci, inf->port_mode);\r\nohci_finish_controller_resume(hcd);\r\nreturn 0;\r\n}
