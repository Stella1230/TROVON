static struct urdev *urdev_alloc(struct ccw_device *cdev)\r\n{\r\nstruct urdev *urd;\r\nurd = kzalloc(sizeof(struct urdev), GFP_KERNEL);\r\nif (!urd)\r\nreturn NULL;\r\nurd->reclen = cdev->id.driver_info;\r\nccw_device_get_id(cdev, &urd->dev_id);\r\nmutex_init(&urd->io_mutex);\r\ninit_waitqueue_head(&urd->wait);\r\nspin_lock_init(&urd->open_lock);\r\natomic_set(&urd->ref_count, 1);\r\nurd->cdev = cdev;\r\nget_device(&cdev->dev);\r\nreturn urd;\r\n}\r\nstatic void urdev_free(struct urdev *urd)\r\n{\r\nTRACE("urdev_free: %p\n", urd);\r\nif (urd->cdev)\r\nput_device(&urd->cdev->dev);\r\nkfree(urd);\r\n}\r\nstatic void urdev_get(struct urdev *urd)\r\n{\r\natomic_inc(&urd->ref_count);\r\n}\r\nstatic struct urdev *urdev_get_from_cdev(struct ccw_device *cdev)\r\n{\r\nstruct urdev *urd;\r\nunsigned long flags;\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\nurd = dev_get_drvdata(&cdev->dev);\r\nif (urd)\r\nurdev_get(urd);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nreturn urd;\r\n}\r\nstatic struct urdev *urdev_get_from_devno(u16 devno)\r\n{\r\nchar bus_id[16];\r\nstruct ccw_device *cdev;\r\nstruct urdev *urd;\r\nsprintf(bus_id, "0.0.%04x", devno);\r\ncdev = get_ccwdev_by_busid(&ur_driver, bus_id);\r\nif (!cdev)\r\nreturn NULL;\r\nurd = urdev_get_from_cdev(cdev);\r\nput_device(&cdev->dev);\r\nreturn urd;\r\n}\r\nstatic void urdev_put(struct urdev *urd)\r\n{\r\nif (atomic_dec_and_test(&urd->ref_count))\r\nurdev_free(urd);\r\n}\r\nstatic int ur_pm_suspend(struct ccw_device *cdev)\r\n{\r\nstruct urdev *urd = dev_get_drvdata(&cdev->dev);\r\nTRACE("ur_pm_suspend: cdev=%p\n", cdev);\r\nif (urd->open_flag) {\r\npr_err("Unit record device %s is busy, %s refusing to "\r\n"suspend.\n", dev_name(&cdev->dev), ur_banner);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_chan_prog(struct ccw1 *cpa)\r\n{\r\nstruct ccw1 *ptr = cpa;\r\nwhile (ptr->cda) {\r\nkfree((void *)(addr_t) ptr->cda);\r\nptr++;\r\n}\r\nkfree(cpa);\r\n}\r\nstatic struct ccw1 *alloc_chan_prog(const char __user *ubuf, int rec_count,\r\nint reclen)\r\n{\r\nstruct ccw1 *cpa;\r\nvoid *kbuf;\r\nint i;\r\nTRACE("alloc_chan_prog(%p, %i, %i)\n", ubuf, rec_count, reclen);\r\ncpa = kzalloc((rec_count + 1) * sizeof(struct ccw1),\r\nGFP_KERNEL | GFP_DMA);\r\nif (!cpa)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < rec_count; i++) {\r\ncpa[i].cmd_code = WRITE_CCW_CMD;\r\ncpa[i].flags = CCW_FLAG_CC | CCW_FLAG_SLI;\r\ncpa[i].count = reclen;\r\nkbuf = kmalloc(reclen, GFP_KERNEL | GFP_DMA);\r\nif (!kbuf) {\r\nfree_chan_prog(cpa);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncpa[i].cda = (u32)(addr_t) kbuf;\r\nif (copy_from_user(kbuf, ubuf, reclen)) {\r\nfree_chan_prog(cpa);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nubuf += reclen;\r\n}\r\ncpa[i].cmd_code = CCW_CMD_NOOP;\r\nreturn cpa;\r\n}\r\nstatic int do_ur_io(struct urdev *urd, struct ccw1 *cpa)\r\n{\r\nint rc;\r\nstruct ccw_device *cdev = urd->cdev;\r\nDECLARE_COMPLETION_ONSTACK(event);\r\nTRACE("do_ur_io: cpa=%p\n", cpa);\r\nrc = mutex_lock_interruptible(&urd->io_mutex);\r\nif (rc)\r\nreturn rc;\r\nurd->io_done = &event;\r\nspin_lock_irq(get_ccwdev_lock(cdev));\r\nrc = ccw_device_start(cdev, cpa, 1, 0, 0);\r\nspin_unlock_irq(get_ccwdev_lock(cdev));\r\nTRACE("do_ur_io: ccw_device_start returned %d\n", rc);\r\nif (rc)\r\ngoto out;\r\nwait_for_completion(&event);\r\nTRACE("do_ur_io: I/O complete\n");\r\nrc = 0;\r\nout:\r\nmutex_unlock(&urd->io_mutex);\r\nreturn rc;\r\n}\r\nstatic void ur_int_handler(struct ccw_device *cdev, unsigned long intparm,\r\nstruct irb *irb)\r\n{\r\nstruct urdev *urd;\r\nkstat_cpu(smp_processor_id()).irqs[IOINT_VMR]++;\r\nTRACE("ur_int_handler: intparm=0x%lx cstat=%02x dstat=%02x res=%u\n",\r\nintparm, irb->scsw.cmd.cstat, irb->scsw.cmd.dstat,\r\nirb->scsw.cmd.count);\r\nif (!intparm) {\r\nTRACE("ur_int_handler: unsolicited interrupt\n");\r\nreturn;\r\n}\r\nurd = dev_get_drvdata(&cdev->dev);\r\nBUG_ON(!urd);\r\nif (IS_ERR(irb))\r\nurd->io_request_rc = PTR_ERR(irb);\r\nelse if (irb->scsw.cmd.dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))\r\nurd->io_request_rc = 0;\r\nelse\r\nurd->io_request_rc = -EIO;\r\ncomplete(urd->io_done);\r\n}\r\nstatic ssize_t ur_attr_reclen_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct urdev *urd;\r\nint rc;\r\nurd = urdev_get_from_cdev(to_ccwdev(dev));\r\nif (!urd)\r\nreturn -ENODEV;\r\nrc = sprintf(buf, "%zu\n", urd->reclen);\r\nurdev_put(urd);\r\nreturn rc;\r\n}\r\nstatic int ur_create_attributes(struct device *dev)\r\n{\r\nreturn device_create_file(dev, &dev_attr_reclen);\r\n}\r\nstatic void ur_remove_attributes(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_reclen);\r\n}\r\nstatic int get_urd_class(struct urdev *urd)\r\n{\r\nstatic struct diag210 ur_diag210;\r\nint cc;\r\nur_diag210.vrdcdvno = urd->dev_id.devno;\r\nur_diag210.vrdclen = sizeof(struct diag210);\r\ncc = diag210(&ur_diag210);\r\nswitch (cc) {\r\ncase 0:\r\nreturn -EOPNOTSUPP;\r\ncase 2:\r\nreturn ur_diag210.vrdcvcla;\r\ncase 3:\r\nreturn -ENODEV;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic struct urfile *urfile_alloc(struct urdev *urd)\r\n{\r\nstruct urfile *urf;\r\nurf = kzalloc(sizeof(struct urfile), GFP_KERNEL);\r\nif (!urf)\r\nreturn NULL;\r\nurf->urd = urd;\r\nTRACE("urfile_alloc: urd=%p urf=%p rl=%zu\n", urd, urf,\r\nurf->dev_reclen);\r\nreturn urf;\r\n}\r\nstatic void urfile_free(struct urfile *urf)\r\n{\r\nTRACE("urfile_free: urf=%p urd=%p\n", urf, urf->urd);\r\nkfree(urf);\r\n}\r\nstatic ssize_t do_write(struct urdev *urd, const char __user *udata,\r\nsize_t count, size_t reclen, loff_t *ppos)\r\n{\r\nstruct ccw1 *cpa;\r\nint rc;\r\ncpa = alloc_chan_prog(udata, count / reclen, reclen);\r\nif (IS_ERR(cpa))\r\nreturn PTR_ERR(cpa);\r\nrc = do_ur_io(urd, cpa);\r\nif (rc)\r\ngoto fail_kfree_cpa;\r\nif (urd->io_request_rc) {\r\nrc = urd->io_request_rc;\r\ngoto fail_kfree_cpa;\r\n}\r\n*ppos += count;\r\nrc = count;\r\nfail_kfree_cpa:\r\nfree_chan_prog(cpa);\r\nreturn rc;\r\n}\r\nstatic ssize_t ur_write(struct file *file, const char __user *udata,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct urfile *urf = file->private_data;\r\nTRACE("ur_write: count=%zu\n", count);\r\nif (count == 0)\r\nreturn 0;\r\nif (count % urf->dev_reclen)\r\nreturn -EINVAL;\r\nif (count > urf->dev_reclen * MAX_RECS_PER_IO)\r\ncount = urf->dev_reclen * MAX_RECS_PER_IO;\r\nreturn do_write(urf->urd, udata, count, urf->dev_reclen, ppos);\r\n}\r\nstatic int diag_position_to_record(int devno, int record)\r\n{\r\nint cc;\r\ncc = diag14(record, devno, 0x28);\r\nswitch (cc) {\r\ncase 0:\r\nreturn 0;\r\ncase 2:\r\nreturn -ENOMEDIUM;\r\ncase 3:\r\nreturn -ENODATA;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int diag_read_file(int devno, char *buf)\r\n{\r\nint cc;\r\ncc = diag14((unsigned long) buf, devno, 0x00);\r\nswitch (cc) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nreturn -ENODATA;\r\ncase 2:\r\nreturn -ENOMEDIUM;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic ssize_t diag14_read(struct file *file, char __user *ubuf, size_t count,\r\nloff_t *offs)\r\n{\r\nsize_t len, copied, res;\r\nchar *buf;\r\nint rc;\r\nu16 reclen;\r\nstruct urdev *urd;\r\nurd = ((struct urfile *) file->private_data)->urd;\r\nreclen = ((struct urfile *) file->private_data)->file_reclen;\r\nrc = diag_position_to_record(urd->dev_id.devno, *offs / PAGE_SIZE + 1);\r\nif (rc == -ENODATA)\r\nreturn 0;\r\nif (rc)\r\nreturn rc;\r\nlen = min((size_t) PAGE_SIZE, count);\r\nbuf = (char *) __get_free_page(GFP_KERNEL | GFP_DMA);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ncopied = 0;\r\nres = (size_t) (*offs % PAGE_SIZE);\r\ndo {\r\nrc = diag_read_file(urd->dev_id.devno, buf);\r\nif (rc == -ENODATA) {\r\nbreak;\r\n}\r\nif (rc)\r\ngoto fail;\r\nif (reclen && (copied == 0) && (*offs < PAGE_SIZE))\r\n*((u16 *) &buf[FILE_RECLEN_OFFSET]) = reclen;\r\nlen = min(count - copied, PAGE_SIZE - res);\r\nif (copy_to_user(ubuf + copied, buf + res, len)) {\r\nrc = -EFAULT;\r\ngoto fail;\r\n}\r\nres = 0;\r\ncopied += len;\r\n} while (copied != count);\r\n*offs += copied;\r\nrc = copied;\r\nfail:\r\nfree_page((unsigned long) buf);\r\nreturn rc;\r\n}\r\nstatic ssize_t ur_read(struct file *file, char __user *ubuf, size_t count,\r\nloff_t *offs)\r\n{\r\nstruct urdev *urd;\r\nint rc;\r\nTRACE("ur_read: count=%zu ppos=%li\n", count, (unsigned long) *offs);\r\nif (count == 0)\r\nreturn 0;\r\nurd = ((struct urfile *) file->private_data)->urd;\r\nrc = mutex_lock_interruptible(&urd->io_mutex);\r\nif (rc)\r\nreturn rc;\r\nrc = diag14_read(file, ubuf, count, offs);\r\nmutex_unlock(&urd->io_mutex);\r\nreturn rc;\r\n}\r\nstatic int diag_read_next_file_info(struct file_control_block *buf, int spid)\r\n{\r\nint cc;\r\ncc = diag14((unsigned long) buf, spid, 0xfff);\r\nswitch (cc) {\r\ncase 0:\r\nreturn 0;\r\ndefault:\r\nreturn -ENODATA;\r\n}\r\n}\r\nstatic int verify_uri_device(struct urdev *urd)\r\n{\r\nstruct file_control_block *fcb;\r\nchar *buf;\r\nint rc;\r\nfcb = kmalloc(sizeof(*fcb), GFP_KERNEL | GFP_DMA);\r\nif (!fcb)\r\nreturn -ENOMEM;\r\nrc = diag_read_next_file_info(fcb, 0);\r\nif (rc)\r\ngoto fail_free_fcb;\r\nif (fcb->file_stat & (FLG_SYSTEM_HOLD | FLG_USER_HOLD)) {\r\nrc = -EPERM;\r\ngoto fail_free_fcb;\r\n}\r\nbuf = (char *) __get_free_page(GFP_KERNEL | GFP_DMA);\r\nif (!buf) {\r\nrc = -ENOMEM;\r\ngoto fail_free_fcb;\r\n}\r\nrc = diag_read_file(urd->dev_id.devno, buf);\r\nif ((rc != 0) && (rc != -ENODATA))\r\ngoto fail_free_buf;\r\nrc = diag_read_next_file_info(fcb, 0);\r\nif (rc)\r\ngoto fail_free_buf;\r\nif (!(fcb->file_stat & FLG_IN_USE)) {\r\nrc = -EMFILE;\r\ngoto fail_free_buf;\r\n}\r\nrc = 0;\r\nfail_free_buf:\r\nfree_page((unsigned long) buf);\r\nfail_free_fcb:\r\nkfree(fcb);\r\nreturn rc;\r\n}\r\nstatic int verify_device(struct urdev *urd)\r\n{\r\nswitch (urd->class) {\r\ncase DEV_CLASS_UR_O:\r\nreturn 0;\r\ncase DEV_CLASS_UR_I:\r\nreturn verify_uri_device(urd);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int get_uri_file_reclen(struct urdev *urd)\r\n{\r\nstruct file_control_block *fcb;\r\nint rc;\r\nfcb = kmalloc(sizeof(*fcb), GFP_KERNEL | GFP_DMA);\r\nif (!fcb)\r\nreturn -ENOMEM;\r\nrc = diag_read_next_file_info(fcb, 0);\r\nif (rc)\r\ngoto fail_free;\r\nif (fcb->file_stat & FLG_CP_DUMP)\r\nrc = 0;\r\nelse\r\nrc = fcb->rec_len;\r\nfail_free:\r\nkfree(fcb);\r\nreturn rc;\r\n}\r\nstatic int get_file_reclen(struct urdev *urd)\r\n{\r\nswitch (urd->class) {\r\ncase DEV_CLASS_UR_O:\r\nreturn 0;\r\ncase DEV_CLASS_UR_I:\r\nreturn get_uri_file_reclen(urd);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int ur_open(struct inode *inode, struct file *file)\r\n{\r\nu16 devno;\r\nstruct urdev *urd;\r\nstruct urfile *urf;\r\nunsigned short accmode;\r\nint rc;\r\naccmode = file->f_flags & O_ACCMODE;\r\nif (accmode == O_RDWR)\r\nreturn -EACCES;\r\ndevno = MINOR(file->f_dentry->d_inode->i_rdev);\r\nurd = urdev_get_from_devno(devno);\r\nif (!urd) {\r\nrc = -ENXIO;\r\ngoto out;\r\n}\r\nspin_lock(&urd->open_lock);\r\nwhile (urd->open_flag) {\r\nspin_unlock(&urd->open_lock);\r\nif (file->f_flags & O_NONBLOCK) {\r\nrc = -EBUSY;\r\ngoto fail_put;\r\n}\r\nif (wait_event_interruptible(urd->wait, urd->open_flag == 0)) {\r\nrc = -ERESTARTSYS;\r\ngoto fail_put;\r\n}\r\nspin_lock(&urd->open_lock);\r\n}\r\nurd->open_flag++;\r\nspin_unlock(&urd->open_lock);\r\nTRACE("ur_open\n");\r\nif (((accmode == O_RDONLY) && (urd->class != DEV_CLASS_UR_I)) ||\r\n((accmode == O_WRONLY) && (urd->class != DEV_CLASS_UR_O))) {\r\nTRACE("ur_open: unsupported dev class (%d)\n", urd->class);\r\nrc = -EACCES;\r\ngoto fail_unlock;\r\n}\r\nrc = verify_device(urd);\r\nif (rc)\r\ngoto fail_unlock;\r\nurf = urfile_alloc(urd);\r\nif (!urf) {\r\nrc = -ENOMEM;\r\ngoto fail_unlock;\r\n}\r\nurf->dev_reclen = urd->reclen;\r\nrc = get_file_reclen(urd);\r\nif (rc < 0)\r\ngoto fail_urfile_free;\r\nurf->file_reclen = rc;\r\nfile->private_data = urf;\r\nreturn 0;\r\nfail_urfile_free:\r\nurfile_free(urf);\r\nfail_unlock:\r\nspin_lock(&urd->open_lock);\r\nurd->open_flag--;\r\nspin_unlock(&urd->open_lock);\r\nfail_put:\r\nurdev_put(urd);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ur_release(struct inode *inode, struct file *file)\r\n{\r\nstruct urfile *urf = file->private_data;\r\nTRACE("ur_release\n");\r\nspin_lock(&urf->urd->open_lock);\r\nurf->urd->open_flag--;\r\nspin_unlock(&urf->urd->open_lock);\r\nwake_up_interruptible(&urf->urd->wait);\r\nurdev_put(urf->urd);\r\nurfile_free(urf);\r\nreturn 0;\r\n}\r\nstatic loff_t ur_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nloff_t newpos;\r\nif ((file->f_flags & O_ACCMODE) != O_RDONLY)\r\nreturn -ESPIPE;\r\nif (offset % PAGE_SIZE)\r\nreturn -ESPIPE;\r\nswitch (whence) {\r\ncase 0:\r\nnewpos = offset;\r\nbreak;\r\ncase 1:\r\nnewpos = file->f_pos + offset;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfile->f_pos = newpos;\r\nreturn newpos;\r\n}\r\nstatic int ur_probe(struct ccw_device *cdev)\r\n{\r\nstruct urdev *urd;\r\nint rc;\r\nTRACE("ur_probe: cdev=%p\n", cdev);\r\nmutex_lock(&vmur_mutex);\r\nurd = urdev_alloc(cdev);\r\nif (!urd) {\r\nrc = -ENOMEM;\r\ngoto fail_unlock;\r\n}\r\nrc = ur_create_attributes(&cdev->dev);\r\nif (rc) {\r\nrc = -ENOMEM;\r\ngoto fail_urdev_put;\r\n}\r\ncdev->handler = ur_int_handler;\r\nurd->class = get_urd_class(urd);\r\nif (urd->class < 0) {\r\nrc = urd->class;\r\ngoto fail_remove_attr;\r\n}\r\nif ((urd->class != DEV_CLASS_UR_I) && (urd->class != DEV_CLASS_UR_O)) {\r\nrc = -EOPNOTSUPP;\r\ngoto fail_remove_attr;\r\n}\r\nspin_lock_irq(get_ccwdev_lock(cdev));\r\ndev_set_drvdata(&cdev->dev, urd);\r\nspin_unlock_irq(get_ccwdev_lock(cdev));\r\nmutex_unlock(&vmur_mutex);\r\nreturn 0;\r\nfail_remove_attr:\r\nur_remove_attributes(&cdev->dev);\r\nfail_urdev_put:\r\nurdev_put(urd);\r\nfail_unlock:\r\nmutex_unlock(&vmur_mutex);\r\nreturn rc;\r\n}\r\nstatic int ur_set_online(struct ccw_device *cdev)\r\n{\r\nstruct urdev *urd;\r\nint minor, major, rc;\r\nchar node_id[16];\r\nTRACE("ur_set_online: cdev=%p\n", cdev);\r\nmutex_lock(&vmur_mutex);\r\nurd = urdev_get_from_cdev(cdev);\r\nif (!urd) {\r\nrc = -ENODEV;\r\ngoto fail_unlock;\r\n}\r\nif (urd->char_device) {\r\nrc = -EBUSY;\r\ngoto fail_urdev_put;\r\n}\r\nminor = urd->dev_id.devno;\r\nmajor = MAJOR(ur_first_dev_maj_min);\r\nurd->char_device = cdev_alloc();\r\nif (!urd->char_device) {\r\nrc = -ENOMEM;\r\ngoto fail_urdev_put;\r\n}\r\ncdev_init(urd->char_device, &ur_fops);\r\nurd->char_device->dev = MKDEV(major, minor);\r\nurd->char_device->owner = ur_fops.owner;\r\nrc = cdev_add(urd->char_device, urd->char_device->dev, 1);\r\nif (rc)\r\ngoto fail_free_cdev;\r\nif (urd->cdev->id.cu_type == READER_PUNCH_DEVTYPE) {\r\nif (urd->class == DEV_CLASS_UR_I)\r\nsprintf(node_id, "vmrdr-%s", dev_name(&cdev->dev));\r\nif (urd->class == DEV_CLASS_UR_O)\r\nsprintf(node_id, "vmpun-%s", dev_name(&cdev->dev));\r\n} else if (urd->cdev->id.cu_type == PRINTER_DEVTYPE) {\r\nsprintf(node_id, "vmprt-%s", dev_name(&cdev->dev));\r\n} else {\r\nrc = -EOPNOTSUPP;\r\ngoto fail_free_cdev;\r\n}\r\nurd->device = device_create(vmur_class, NULL, urd->char_device->dev,\r\nNULL, "%s", node_id);\r\nif (IS_ERR(urd->device)) {\r\nrc = PTR_ERR(urd->device);\r\nTRACE("ur_set_online: device_create rc=%d\n", rc);\r\ngoto fail_free_cdev;\r\n}\r\nurdev_put(urd);\r\nmutex_unlock(&vmur_mutex);\r\nreturn 0;\r\nfail_free_cdev:\r\ncdev_del(urd->char_device);\r\nurd->char_device = NULL;\r\nfail_urdev_put:\r\nurdev_put(urd);\r\nfail_unlock:\r\nmutex_unlock(&vmur_mutex);\r\nreturn rc;\r\n}\r\nstatic int ur_set_offline_force(struct ccw_device *cdev, int force)\r\n{\r\nstruct urdev *urd;\r\nint rc;\r\nTRACE("ur_set_offline: cdev=%p\n", cdev);\r\nurd = urdev_get_from_cdev(cdev);\r\nif (!urd)\r\nreturn -ENODEV;\r\nif (!urd->char_device) {\r\nrc = -EBUSY;\r\ngoto fail_urdev_put;\r\n}\r\nif (!force && (atomic_read(&urd->ref_count) > 2)) {\r\nTRACE("ur_set_offline: BUSY\n");\r\nrc = -EBUSY;\r\ngoto fail_urdev_put;\r\n}\r\ndevice_destroy(vmur_class, urd->char_device->dev);\r\ncdev_del(urd->char_device);\r\nurd->char_device = NULL;\r\nrc = 0;\r\nfail_urdev_put:\r\nurdev_put(urd);\r\nreturn rc;\r\n}\r\nstatic int ur_set_offline(struct ccw_device *cdev)\r\n{\r\nint rc;\r\nmutex_lock(&vmur_mutex);\r\nrc = ur_set_offline_force(cdev, 0);\r\nmutex_unlock(&vmur_mutex);\r\nreturn rc;\r\n}\r\nstatic void ur_remove(struct ccw_device *cdev)\r\n{\r\nunsigned long flags;\r\nTRACE("ur_remove\n");\r\nmutex_lock(&vmur_mutex);\r\nif (cdev->online)\r\nur_set_offline_force(cdev, 1);\r\nur_remove_attributes(&cdev->dev);\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\nurdev_put(dev_get_drvdata(&cdev->dev));\r\ndev_set_drvdata(&cdev->dev, NULL);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nmutex_unlock(&vmur_mutex);\r\n}\r\nstatic int __init ur_init(void)\r\n{\r\nint rc;\r\ndev_t dev;\r\nif (!MACHINE_IS_VM) {\r\npr_err("The %s cannot be loaded without z/VM\n",\r\nur_banner);\r\nreturn -ENODEV;\r\n}\r\nvmur_dbf = debug_register("vmur", 4, 1, 4 * sizeof(long));\r\nif (!vmur_dbf)\r\nreturn -ENOMEM;\r\nrc = debug_register_view(vmur_dbf, &debug_sprintf_view);\r\nif (rc)\r\ngoto fail_free_dbf;\r\ndebug_set_level(vmur_dbf, 6);\r\nvmur_class = class_create(THIS_MODULE, "vmur");\r\nif (IS_ERR(vmur_class)) {\r\nrc = PTR_ERR(vmur_class);\r\ngoto fail_free_dbf;\r\n}\r\nrc = ccw_driver_register(&ur_driver);\r\nif (rc)\r\ngoto fail_class_destroy;\r\nrc = alloc_chrdev_region(&dev, 0, NUM_MINORS, "vmur");\r\nif (rc) {\r\npr_err("Kernel function alloc_chrdev_region failed with "\r\n"error code %d\n", rc);\r\ngoto fail_unregister_driver;\r\n}\r\nur_first_dev_maj_min = MKDEV(MAJOR(dev), 0);\r\npr_info("%s loaded.\n", ur_banner);\r\nreturn 0;\r\nfail_unregister_driver:\r\nccw_driver_unregister(&ur_driver);\r\nfail_class_destroy:\r\nclass_destroy(vmur_class);\r\nfail_free_dbf:\r\ndebug_unregister(vmur_dbf);\r\nreturn rc;\r\n}\r\nstatic void __exit ur_exit(void)\r\n{\r\nunregister_chrdev_region(ur_first_dev_maj_min, NUM_MINORS);\r\nccw_driver_unregister(&ur_driver);\r\nclass_destroy(vmur_class);\r\ndebug_unregister(vmur_dbf);\r\npr_info("%s unloaded.\n", ur_banner);\r\n}
