void dccp_time_wait(struct sock *sk, int state, int timeo)\r\n{\r\nstruct inet_timewait_sock *tw = NULL;\r\nif (dccp_death_row.tw_count < dccp_death_row.sysctl_max_tw_buckets)\r\ntw = inet_twsk_alloc(sk, state);\r\nif (tw != NULL) {\r\nconst struct inet_connection_sock *icsk = inet_csk(sk);\r\nconst int rto = (icsk->icsk_rto << 2) - (icsk->icsk_rto >> 1);\r\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\r\nif (tw->tw_family == PF_INET6) {\r\nconst struct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct inet6_timewait_sock *tw6;\r\ntw->tw_ipv6_offset = inet6_tw_offset(sk->sk_prot);\r\ntw6 = inet6_twsk((struct sock *)tw);\r\nipv6_addr_copy(&tw6->tw_v6_daddr, &np->daddr);\r\nipv6_addr_copy(&tw6->tw_v6_rcv_saddr, &np->rcv_saddr);\r\ntw->tw_ipv6only = np->ipv6only;\r\n}\r\n#endif\r\n__inet_twsk_hashdance(tw, sk, &dccp_hashinfo);\r\nif (timeo < rto)\r\ntimeo = rto;\r\ntw->tw_timeout = DCCP_TIMEWAIT_LEN;\r\nif (state == DCCP_TIME_WAIT)\r\ntimeo = DCCP_TIMEWAIT_LEN;\r\ninet_twsk_schedule(tw, &dccp_death_row, timeo,\r\nDCCP_TIMEWAIT_LEN);\r\ninet_twsk_put(tw);\r\n} else {\r\nDCCP_WARN("time wait bucket table overflow\n");\r\n}\r\ndccp_done(sk);\r\n}\r\nstruct sock *dccp_create_openreq_child(struct sock *sk,\r\nconst struct request_sock *req,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct sock *newsk = inet_csk_clone(sk, req, GFP_ATOMIC);\r\nif (newsk != NULL) {\r\nstruct dccp_request_sock *dreq = dccp_rsk(req);\r\nstruct inet_connection_sock *newicsk = inet_csk(newsk);\r\nstruct dccp_sock *newdp = dccp_sk(newsk);\r\nnewdp->dccps_role = DCCP_ROLE_SERVER;\r\nnewdp->dccps_hc_rx_ackvec = NULL;\r\nnewdp->dccps_service_list = NULL;\r\nnewdp->dccps_service = dreq->dreq_service;\r\nnewdp->dccps_timestamp_echo = dreq->dreq_timestamp_echo;\r\nnewdp->dccps_timestamp_time = dreq->dreq_timestamp_time;\r\nnewicsk->icsk_rto = DCCP_TIMEOUT_INIT;\r\nINIT_LIST_HEAD(&newdp->dccps_featneg);\r\nnewdp->dccps_gss = newdp->dccps_iss = dreq->dreq_iss;\r\nnewdp->dccps_gar = newdp->dccps_iss;\r\nnewdp->dccps_gsr = newdp->dccps_isr = dreq->dreq_isr;\r\nif (dccp_feat_activate_values(newsk, &dreq->dreq_featneg)) {\r\nnewsk->sk_destruct = NULL;\r\nsk_free(newsk);\r\nreturn NULL;\r\n}\r\ndccp_init_xmit_timers(newsk);\r\nDCCP_INC_STATS_BH(DCCP_MIB_PASSIVEOPENS);\r\n}\r\nreturn newsk;\r\n}\r\nstruct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,\r\nstruct request_sock *req,\r\nstruct request_sock **prev)\r\n{\r\nstruct sock *child = NULL;\r\nstruct dccp_request_sock *dreq = dccp_rsk(req);\r\nif (dccp_hdr(skb)->dccph_type == DCCP_PKT_REQUEST) {\r\nif (after48(DCCP_SKB_CB(skb)->dccpd_seq, dreq->dreq_isr)) {\r\ndccp_pr_debug("Retransmitted REQUEST\n");\r\ndreq->dreq_isr = DCCP_SKB_CB(skb)->dccpd_seq;\r\nreq->retrans++;\r\nreq->rsk_ops->rtx_syn_ack(sk, req, NULL);\r\n}\r\nreturn NULL;\r\n}\r\nDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_PACKET_ERROR;\r\nif (dccp_hdr(skb)->dccph_type != DCCP_PKT_ACK &&\r\ndccp_hdr(skb)->dccph_type != DCCP_PKT_DATAACK)\r\ngoto drop;\r\nif (DCCP_SKB_CB(skb)->dccpd_ack_seq != dreq->dreq_iss) {\r\ndccp_pr_debug("Invalid ACK number: ack_seq=%llu, "\r\n"dreq_iss=%llu\n",\r\n(unsigned long long)\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq,\r\n(unsigned long long) dreq->dreq_iss);\r\ngoto drop;\r\n}\r\nif (dccp_parse_options(sk, dreq, skb))\r\ngoto drop;\r\nchild = inet_csk(sk)->icsk_af_ops->syn_recv_sock(sk, skb, req, NULL);\r\nif (child == NULL)\r\ngoto listen_overflow;\r\ninet_csk_reqsk_queue_unlink(sk, req, prev);\r\ninet_csk_reqsk_queue_removed(sk, req);\r\ninet_csk_reqsk_queue_add(sk, req, child);\r\nout:\r\nreturn child;\r\nlisten_overflow:\r\ndccp_pr_debug("listen_overflow!\n");\r\nDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\r\ndrop:\r\nif (dccp_hdr(skb)->dccph_type != DCCP_PKT_RESET)\r\nreq->rsk_ops->send_reset(sk, skb);\r\ninet_csk_reqsk_queue_drop(sk, req, prev);\r\ngoto out;\r\n}\r\nint dccp_child_process(struct sock *parent, struct sock *child,\r\nstruct sk_buff *skb)\r\n{\r\nint ret = 0;\r\nconst int state = child->sk_state;\r\nif (!sock_owned_by_user(child)) {\r\nret = dccp_rcv_state_process(child, skb, dccp_hdr(skb),\r\nskb->len);\r\nif (state == DCCP_RESPOND && child->sk_state != state)\r\nparent->sk_data_ready(parent, 0);\r\n} else {\r\n__sk_add_backlog(child, skb);\r\n}\r\nbh_unlock_sock(child);\r\nsock_put(child);\r\nreturn ret;\r\n}\r\nvoid dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,\r\nstruct request_sock *rsk)\r\n{\r\nDCCP_BUG("DCCP-ACK packets are never sent in LISTEN/RESPOND state");\r\n}\r\nint dccp_reqsk_init(struct request_sock *req,\r\nstruct dccp_sock const *dp, struct sk_buff const *skb)\r\n{\r\nstruct dccp_request_sock *dreq = dccp_rsk(req);\r\ninet_rsk(req)->rmt_port = dccp_hdr(skb)->dccph_sport;\r\ninet_rsk(req)->loc_port = dccp_hdr(skb)->dccph_dport;\r\ninet_rsk(req)->acked = 0;\r\ndreq->dreq_timestamp_echo = 0;\r\nreturn dccp_feat_clone_list(&dp->dccps_featneg, &dreq->dreq_featneg);\r\n}
