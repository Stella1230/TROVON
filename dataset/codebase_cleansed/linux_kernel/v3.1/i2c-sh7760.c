static inline void OUT32(struct cami2c *cam, int reg, unsigned long val)\r\n{\r\n__raw_writel(val, (unsigned long)cam->iobase + reg);\r\n}\r\nstatic inline unsigned long IN32(struct cami2c *cam, int reg)\r\n{\r\nreturn __raw_readl((unsigned long)cam->iobase + reg);\r\n}\r\nstatic irqreturn_t sh7760_i2c_irq(int irq, void *ptr)\r\n{\r\nstruct cami2c *id = ptr;\r\nstruct i2c_msg *msg = id->msg;\r\nchar *data = msg->buf;\r\nunsigned long msr, fsr, fier, len;\r\nmsr = IN32(id, I2CMSR);\r\nfsr = IN32(id, I2CFSR);\r\nif (msr & MSR_MAL) {\r\nOUT32(id, I2CMCR, 0);\r\nOUT32(id, I2CSCR, 0);\r\nOUT32(id, I2CSAR, 0);\r\nid->status |= IDS_DONE | IDS_ARBLOST;\r\ngoto out;\r\n}\r\nif (msr & MSR_MNR) {\r\nudelay(100);\r\nOUT32(id, I2CFCR, FCR_RFRST | FCR_TFRST);\r\nOUT32(id, I2CMCR, MCR_MIE | MCR_FSB);\r\nOUT32(id, I2CFIER, 0);\r\nOUT32(id, I2CMIER, MIE_MSTE);\r\nOUT32(id, I2CSCR, 0);\r\nOUT32(id, I2CSAR, 0);\r\nid->status |= IDS_NACK;\r\nmsr &= ~MSR_MAT;\r\nfsr = 0;\r\n}\r\nif (msr & MSR_MST) {\r\nid->status |= IDS_DONE;\r\ngoto out;\r\n}\r\nif (msr & MSR_MAT)\r\nOUT32(id, I2CMCR, MCR_MIE);\r\nfier = IN32(id, I2CFIER);\r\nif (fsr & FSR_RDF) {\r\nlen = IN32(id, I2CRFDR);\r\nif (msg->len <= len) {\r\nif (id->flags & IDF_STOP) {\r\nOUT32(id, I2CMCR, MCR_MIE | MCR_FSB);\r\nOUT32(id, I2CFIER, 0);\r\nudelay(5);\r\n} else {\r\nid->status |= IDS_DONE;\r\nfsr &= ~FSR_RDF;\r\n}\r\n}\r\nwhile (msg->len && len) {\r\n*data++ = IN32(id, I2CRXTX);\r\nmsg->len--;\r\nlen--;\r\n}\r\nif (msg->len) {\r\nlen = (msg->len >= FIFO_SIZE) ? FIFO_SIZE - 1\r\n: msg->len - 1;\r\nOUT32(id, I2CFCR, FCR_TFRST | ((len & 0xf) << 4));\r\n}\r\n} else if (id->flags & IDF_SEND) {\r\nif ((fsr & FSR_TEND) && (msg->len < 1)) {\r\nif (id->flags & IDF_STOP) {\r\nOUT32(id, I2CMCR, MCR_MIE | MCR_FSB);\r\n} else {\r\nid->status |= IDS_DONE;\r\nfsr &= ~FSR_TEND;\r\n}\r\n}\r\nif (fsr & FSR_TDFE) {\r\nwhile (msg->len && (IN32(id, I2CTFDR) < FIFO_SIZE)) {\r\nOUT32(id, I2CRXTX, *data++);\r\nmsg->len--;\r\n}\r\nif (msg->len < 1) {\r\nfier &= ~FIER_TXIE;\r\nOUT32(id, I2CFIER, fier);\r\n} else {\r\nlen = (msg->len >= FIFO_SIZE) ? 2 : 0;\r\nOUT32(id, I2CFCR,\r\nFCR_RFRST | ((len & 3) << 2));\r\n}\r\n}\r\n}\r\nout:\r\nif (id->status & IDS_DONE) {\r\nOUT32(id, I2CMIER, 0);\r\nOUT32(id, I2CFIER, 0);\r\nid->msg = NULL;\r\ncomplete(&id->xfer_done);\r\n}\r\nOUT32(id, I2CMSR, ~msr);\r\nOUT32(id, I2CFSR, ~fsr);\r\nOUT32(id, I2CSSR, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sh7760_i2c_mrecv(struct cami2c *id)\r\n{\r\nint len;\r\nid->flags |= IDF_RECV;\r\nOUT32(id, I2CSAR, 0xfe);\r\nOUT32(id, I2CMAR, (id->msg->addr << 1) | 1);\r\nif (id->msg->len >= FIFO_SIZE)\r\nlen = FIFO_SIZE - 1;\r\nelse\r\nlen = id->msg->len - 1;\r\nOUT32(id, I2CFCR, FCR_RFRST | FCR_TFRST);\r\nOUT32(id, I2CFCR, FCR_TFRST | ((len & 0xF) << 4));\r\nOUT32(id, I2CMSR, 0);\r\nOUT32(id, I2CMCR, MCR_MIE | MCR_ESG);\r\nOUT32(id, I2CMIER, MIE_MNRE | MIE_MALE | MIE_MSTE | MIE_MATE);\r\nOUT32(id, I2CFIER, FIER_RXIE);\r\n}\r\nstatic void sh7760_i2c_msend(struct cami2c *id)\r\n{\r\nint len;\r\nid->flags |= IDF_SEND;\r\nOUT32(id, I2CSAR, 0xfe);\r\nOUT32(id, I2CMAR, (id->msg->addr << 1) | 0);\r\nif (id->msg->len >= FIFO_SIZE)\r\nlen = 2;\r\nelse\r\nlen = 0;\r\nOUT32(id, I2CFCR, FCR_RFRST | FCR_TFRST);\r\nOUT32(id, I2CFCR, FCR_RFRST | ((len & 3) << 2));\r\nwhile (id->msg->len && IN32(id, I2CTFDR) < FIFO_SIZE) {\r\nOUT32(id, I2CRXTX, *(id->msg->buf));\r\n(id->msg->len)--;\r\n(id->msg->buf)++;\r\n}\r\nOUT32(id, I2CMSR, 0);\r\nOUT32(id, I2CMCR, MCR_MIE | MCR_ESG);\r\nOUT32(id, I2CFSR, 0);\r\nOUT32(id, I2CMIER, MIE_MNRE | MIE_MALE | MIE_MSTE | MIE_MATE);\r\nOUT32(id, I2CFIER, FIER_TEIE | (id->msg->len ? FIER_TXIE : 0));\r\n}\r\nstatic inline int sh7760_i2c_busy_check(struct cami2c *id)\r\n{\r\nreturn (IN32(id, I2CMCR) & MCR_FSDA);\r\n}\r\nstatic int sh7760_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct cami2c *id = adap->algo_data;\r\nint i, retr;\r\nif (sh7760_i2c_busy_check(id)) {\r\ndev_err(&adap->dev, "sh7760-i2c%d: bus busy!\n", adap->nr);\r\nreturn -EBUSY;\r\n}\r\ni = 0;\r\nwhile (i < num) {\r\nretr = adap->retries;\r\nretry:\r\nid->flags = ((i == (num-1)) ? IDF_STOP : 0);\r\nid->status = 0;\r\nid->msg = msgs;\r\ninit_completion(&id->xfer_done);\r\nif (msgs->flags & I2C_M_RD)\r\nsh7760_i2c_mrecv(id);\r\nelse\r\nsh7760_i2c_msend(id);\r\nwait_for_completion(&id->xfer_done);\r\nif (id->status == 0) {\r\nnum = -EIO;\r\nbreak;\r\n}\r\nif (id->status & IDS_NACK) {\r\nmdelay(1);\r\nnum = -EREMOTEIO;\r\nbreak;\r\n}\r\nif (id->status & IDS_ARBLOST) {\r\nif (retr--) {\r\nmdelay(2);\r\ngoto retry;\r\n}\r\nnum = -EREMOTEIO;\r\nbreak;\r\n}\r\nmsgs++;\r\ni++;\r\n}\r\nid->msg = NULL;\r\nid->flags = 0;\r\nid->status = 0;\r\nOUT32(id, I2CMCR, 0);\r\nOUT32(id, I2CMSR, 0);\r\nOUT32(id, I2CMIER, 0);\r\nOUT32(id, I2CFIER, 0);\r\nOUT32(id, I2CSCR, 0);\r\nOUT32(id, I2CSAR, 0);\r\nOUT32(id, I2CSSR, 0);\r\nreturn num;\r\n}\r\nstatic u32 sh7760_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\r\n}\r\nstatic int __devinit calc_CCR(unsigned long scl_hz)\r\n{\r\nstruct clk *mclk;\r\nunsigned long mck, m1, dff, odff, iclk;\r\nsigned char cdf, cdfm;\r\nint scgd, scgdm, scgds;\r\nmclk = clk_get(NULL, "peripheral_clk");\r\nif (IS_ERR(mclk)) {\r\nreturn PTR_ERR(mclk);\r\n} else {\r\nmck = mclk->rate;\r\nclk_put(mclk);\r\n}\r\nodff = scl_hz;\r\nscgdm = cdfm = m1 = 0;\r\nfor (cdf = 3; cdf >= 0; cdf--) {\r\niclk = mck / (1 + cdf);\r\nif (iclk >= 20000000)\r\ncontinue;\r\nscgds = ((iclk / scl_hz) - 20) >> 3;\r\nfor (scgd = scgds; (scgd < 63) && scgd <= scgds + 1; scgd++) {\r\nm1 = iclk / (20 + (scgd << 3));\r\ndff = abs(scl_hz - m1);\r\nif (dff < odff) {\r\nodff = dff;\r\ncdfm = cdf;\r\nscgdm = scgd;\r\n}\r\n}\r\n}\r\nif (odff > (scl_hz >> 2))\r\nreturn -EINVAL;\r\nreturn ((scgdm << 2) | cdfm);\r\n}\r\nstatic int __devinit sh7760_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct sh7760_i2c_platdata *pd;\r\nstruct resource *res;\r\nstruct cami2c *id;\r\nint ret;\r\npd = pdev->dev.platform_data;\r\nif (!pd) {\r\ndev_err(&pdev->dev, "no platform_data!\n");\r\nret = -ENODEV;\r\ngoto out0;\r\n}\r\nid = kzalloc(sizeof(struct cami2c), GFP_KERNEL);\r\nif (!id) {\r\ndev_err(&pdev->dev, "no mem for private data\n");\r\nret = -ENOMEM;\r\ngoto out0;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no mmio resources\n");\r\nret = -ENODEV;\r\ngoto out1;\r\n}\r\nid->ioarea = request_mem_region(res->start, REGSIZE, pdev->name);\r\nif (!id->ioarea) {\r\ndev_err(&pdev->dev, "mmio already reserved\n");\r\nret = -EBUSY;\r\ngoto out1;\r\n}\r\nid->iobase = ioremap(res->start, REGSIZE);\r\nif (!id->iobase) {\r\ndev_err(&pdev->dev, "cannot ioremap\n");\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\nid->irq = platform_get_irq(pdev, 0);\r\nid->adap.nr = pdev->id;\r\nid->adap.algo = &sh7760_i2c_algo;\r\nid->adap.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nid->adap.retries = 3;\r\nid->adap.algo_data = id;\r\nid->adap.dev.parent = &pdev->dev;\r\nsnprintf(id->adap.name, sizeof(id->adap.name),\r\n"SH7760 I2C at %08lx", (unsigned long)res->start);\r\nOUT32(id, I2CMCR, 0);\r\nOUT32(id, I2CMSR, 0);\r\nOUT32(id, I2CMIER, 0);\r\nOUT32(id, I2CMAR, 0);\r\nOUT32(id, I2CSIER, 0);\r\nOUT32(id, I2CSAR, 0);\r\nOUT32(id, I2CSCR, 0);\r\nOUT32(id, I2CSSR, 0);\r\nOUT32(id, I2CFIER, 0);\r\nOUT32(id, I2CFCR, FCR_RFRST | FCR_TFRST);\r\nOUT32(id, I2CFSR, 0);\r\nret = calc_CCR(pd->speed_khz * 1000);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "invalid SCL clock: %dkHz\n",\r\npd->speed_khz);\r\ngoto out3;\r\n}\r\nOUT32(id, I2CCCR, ret);\r\nif (request_irq(id->irq, sh7760_i2c_irq, IRQF_DISABLED,\r\nSH7760_I2C_DEVNAME, id)) {\r\ndev_err(&pdev->dev, "cannot get irq %d\n", id->irq);\r\nret = -EBUSY;\r\ngoto out3;\r\n}\r\nret = i2c_add_numbered_adapter(&id->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "reg adap failed: %d\n", ret);\r\ngoto out4;\r\n}\r\nplatform_set_drvdata(pdev, id);\r\ndev_info(&pdev->dev, "%d kHz mmio %08x irq %d\n",\r\npd->speed_khz, res->start, id->irq);\r\nreturn 0;\r\nout4:\r\nfree_irq(id->irq, id);\r\nout3:\r\niounmap(id->iobase);\r\nout2:\r\nrelease_resource(id->ioarea);\r\nkfree(id->ioarea);\r\nout1:\r\nkfree(id);\r\nout0:\r\nreturn ret;\r\n}\r\nstatic int __devexit sh7760_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct cami2c *id = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&id->adap);\r\nfree_irq(id->irq, id);\r\niounmap(id->iobase);\r\nrelease_resource(id->ioarea);\r\nkfree(id->ioarea);\r\nkfree(id);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init sh7760_i2c_init(void)\r\n{\r\nreturn platform_driver_register(&sh7760_i2c_drv);\r\n}\r\nstatic void __exit sh7760_i2c_exit(void)\r\n{\r\nplatform_driver_unregister(&sh7760_i2c_drv);\r\n}
