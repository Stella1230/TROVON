static void get_lrate_mode(struct asd_phy *phy, u8 oob_mode)\r\n{\r\nstruct sas_phy *sas_phy = phy->sas_phy.phy;\r\nswitch (oob_mode & 7) {\r\ncase PHY_SPEED_60:\r\nphy->sas_phy.linkrate = SAS_LINK_RATE_6_0_GBPS;\r\nphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_6_0_GBPS;\r\nbreak;\r\ncase PHY_SPEED_30:\r\nphy->sas_phy.linkrate = SAS_LINK_RATE_3_0_GBPS;\r\nphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_3_0_GBPS;\r\nbreak;\r\ncase PHY_SPEED_15:\r\nphy->sas_phy.linkrate = SAS_LINK_RATE_1_5_GBPS;\r\nphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_1_5_GBPS;\r\nbreak;\r\n}\r\nsas_phy->negotiated_linkrate = phy->sas_phy.linkrate;\r\nsas_phy->maximum_linkrate_hw = SAS_LINK_RATE_3_0_GBPS;\r\nsas_phy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\r\nsas_phy->maximum_linkrate = phy->phy_desc->max_sas_lrate;\r\nsas_phy->minimum_linkrate = phy->phy_desc->min_sas_lrate;\r\nif (oob_mode & SAS_MODE)\r\nphy->sas_phy.oob_mode = SAS_OOB_MODE;\r\nelse if (oob_mode & SATA_MODE)\r\nphy->sas_phy.oob_mode = SATA_OOB_MODE;\r\n}\r\nstatic void asd_phy_event_tasklet(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl)\r\n{\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct sas_ha_struct *sas_ha = &asd_ha->sas_ha;\r\nint phy_id = dl->status_block[0] & DL_PHY_MASK;\r\nstruct asd_phy *phy = &asd_ha->phys[phy_id];\r\nu8 oob_status = dl->status_block[1] & PHY_EVENTS_STATUS;\r\nu8 oob_mode = dl->status_block[2];\r\nswitch (oob_status) {\r\ncase CURRENT_LOSS_OF_SIGNAL:\r\nASD_DPRINTK("phy%d: device unplugged\n", phy_id);\r\nasd_turn_led(asd_ha, phy_id, 0);\r\nsas_phy_disconnected(&phy->sas_phy);\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_LOSS_OF_SIGNAL);\r\nbreak;\r\ncase CURRENT_OOB_DONE:\r\nasd_turn_led(asd_ha, phy_id, 1);\r\nget_lrate_mode(phy, oob_mode);\r\nASD_DPRINTK("phy%d device plugged: lrate:0x%x, proto:0x%x\n",\r\nphy_id, phy->sas_phy.linkrate, phy->sas_phy.iproto);\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE);\r\nbreak;\r\ncase CURRENT_SPINUP_HOLD:\r\nasd_turn_led(asd_ha, phy_id, 1);\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_SPINUP_HOLD);\r\nbreak;\r\ncase CURRENT_GTO_TIMEOUT:\r\ncase CURRENT_OOB_ERROR:\r\nASD_DPRINTK("phy%d error while OOB: oob status:0x%x\n", phy_id,\r\ndl->status_block[1]);\r\nasd_turn_led(asd_ha, phy_id, 0);\r\nsas_phy_disconnected(&phy->sas_phy);\r\nsas_ha->notify_phy_event(&phy->sas_phy, PHYE_OOB_ERROR);\r\nbreak;\r\n}\r\n}\r\nstatic unsigned ord_phy(struct asd_ha_struct *asd_ha, struct asd_phy *phy)\r\n{\r\nu8 enabled_mask = asd_ha->hw_prof.enabled_phys;\r\nint i, k = 0;\r\nfor_each_phy(enabled_mask, enabled_mask, i) {\r\nif (&asd_ha->phys[i] == phy)\r\nreturn k;\r\nk++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void asd_get_attached_sas_addr(struct asd_phy *phy, u8 *sas_addr)\r\n{\r\nif (phy->sas_phy.frame_rcvd[0] == 0x34\r\n&& phy->sas_phy.oob_mode == SATA_OOB_MODE) {\r\nstruct asd_ha_struct *asd_ha = phy->sas_phy.ha->lldd_ha;\r\nu64 addr = be64_to_cpu(*(__be64 *)phy->phy_desc->sas_addr);\r\naddr += asd_ha->hw_prof.sata_name_base + ord_phy(asd_ha, phy);\r\n*(__be64 *)sas_addr = cpu_to_be64(addr);\r\n} else {\r\nstruct sas_identify_frame *idframe =\r\n(void *) phy->sas_phy.frame_rcvd;\r\nmemcpy(sas_addr, idframe->sas_addr, SAS_ADDR_SIZE);\r\n}\r\n}\r\nstatic void asd_form_port(struct asd_ha_struct *asd_ha, struct asd_phy *phy)\r\n{\r\nint i;\r\nstruct asd_port *free_port = NULL;\r\nstruct asd_port *port;\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nunsigned long flags;\r\nspin_lock_irqsave(&asd_ha->asd_ports_lock, flags);\r\nif (!phy->asd_port) {\r\nfor (i = 0; i < ASD_MAX_PHYS; i++) {\r\nport = &asd_ha->asd_ports[i];\r\nif (port->num_phys > 0 &&\r\nmemcmp(port->sas_addr, sas_phy->sas_addr,\r\nSAS_ADDR_SIZE) == 0 &&\r\nmemcmp(port->attached_sas_addr,\r\nsas_phy->attached_sas_addr,\r\nSAS_ADDR_SIZE) == 0) {\r\nbreak;\r\n}\r\nif (port->num_phys == 0 && free_port == NULL) {\r\nfree_port = port;\r\n}\r\n}\r\nif (i >= ASD_MAX_PHYS) {\r\nport = free_port;\r\nBUG_ON(!port);\r\nmemcpy(port->sas_addr, sas_phy->sas_addr,\r\nSAS_ADDR_SIZE);\r\nmemcpy(port->attached_sas_addr,\r\nsas_phy->attached_sas_addr,\r\nSAS_ADDR_SIZE);\r\n}\r\nport->num_phys++;\r\nport->phy_mask |= (1U << sas_phy->id);\r\nphy->asd_port = port;\r\n}\r\nASD_DPRINTK("%s: updating phy_mask 0x%x for phy%d\n",\r\n__func__, phy->asd_port->phy_mask, sas_phy->id);\r\nasd_update_port_links(asd_ha, phy);\r\nspin_unlock_irqrestore(&asd_ha->asd_ports_lock, flags);\r\n}\r\nstatic void asd_deform_port(struct asd_ha_struct *asd_ha, struct asd_phy *phy)\r\n{\r\nstruct asd_port *port = phy->asd_port;\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nunsigned long flags;\r\nspin_lock_irqsave(&asd_ha->asd_ports_lock, flags);\r\nif (port) {\r\nport->num_phys--;\r\nport->phy_mask &= ~(1U << sas_phy->id);\r\nphy->asd_port = NULL;\r\n}\r\nspin_unlock_irqrestore(&asd_ha->asd_ports_lock, flags);\r\n}\r\nstatic void asd_bytes_dmaed_tasklet(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl,\r\nint edb_id, int phy_id)\r\n{\r\nunsigned long flags;\r\nint edb_el = edb_id + ascb->edb_index;\r\nstruct asd_dma_tok *edb = ascb->ha->seq.edb_arr[edb_el];\r\nstruct asd_phy *phy = &ascb->ha->phys[phy_id];\r\nstruct sas_ha_struct *sas_ha = phy->sas_phy.ha;\r\nu16 size = ((dl->status_block[3] & 7) << 8) | dl->status_block[2];\r\nsize = min(size, (u16) sizeof(phy->frame_rcvd));\r\nspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\r\nmemcpy(phy->sas_phy.frame_rcvd, edb->vaddr, size);\r\nphy->sas_phy.frame_rcvd_size = size;\r\nasd_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\r\nspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\r\nasd_dump_frame_rcvd(phy, dl);\r\nasd_form_port(ascb->ha, phy);\r\nsas_ha->notify_port_event(&phy->sas_phy, PORTE_BYTES_DMAED);\r\n}\r\nstatic void asd_link_reset_err_tasklet(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl,\r\nint phy_id)\r\n{\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct sas_ha_struct *sas_ha = &asd_ha->sas_ha;\r\nstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\r\nstruct asd_phy *phy = &asd_ha->phys[phy_id];\r\nu8 lr_error = dl->status_block[1];\r\nu8 retries_left = dl->status_block[2];\r\nswitch (lr_error) {\r\ncase 0:\r\nASD_DPRINTK("phy%d: Receive ID timer expired\n", phy_id);\r\nbreak;\r\ncase 1:\r\nASD_DPRINTK("phy%d: Loss of signal\n", phy_id);\r\nbreak;\r\ncase 2:\r\nASD_DPRINTK("phy%d: Loss of dword sync\n", phy_id);\r\nbreak;\r\ncase 3:\r\nASD_DPRINTK("phy%d: Receive FIS timeout\n", phy_id);\r\nbreak;\r\ndefault:\r\nASD_DPRINTK("phy%d: unknown link reset error code: 0x%x\n",\r\nphy_id, lr_error);\r\nbreak;\r\n}\r\nasd_turn_led(asd_ha, phy_id, 0);\r\nsas_phy_disconnected(sas_phy);\r\nasd_deform_port(asd_ha, phy);\r\nsas_ha->notify_port_event(sas_phy, PORTE_LINK_RESET_ERR);\r\nif (retries_left == 0) {\r\nint num = 1;\r\nstruct asd_ascb *cp = asd_ascb_alloc_list(ascb->ha, &num,\r\nGFP_ATOMIC);\r\nif (!cp) {\r\nasd_printk("%s: out of memory\n", __func__);\r\ngoto out;\r\n}\r\nASD_DPRINTK("phy%d: retries:0 performing link reset seq\n",\r\nphy_id);\r\nasd_build_control_phy(cp, phy_id, ENABLE_PHY);\r\nif (asd_post_ascb_list(ascb->ha, cp, 1) != 0)\r\nasd_ascb_free(cp);\r\n}\r\nout:\r\n;\r\n}\r\nstatic void asd_primitive_rcvd_tasklet(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl,\r\nint phy_id)\r\n{\r\nunsigned long flags;\r\nstruct sas_ha_struct *sas_ha = &ascb->ha->sas_ha;\r\nstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct asd_phy *phy = &asd_ha->phys[phy_id];\r\nu8 reg = dl->status_block[1];\r\nu32 cont = dl->status_block[2] << ((reg & 3)*8);\r\nreg &= ~3;\r\nswitch (reg) {\r\ncase LmPRMSTAT0BYTE0:\r\nswitch (cont) {\r\ncase LmBROADCH:\r\ncase LmBROADRVCH0:\r\ncase LmBROADRVCH1:\r\ncase LmBROADSES:\r\nASD_DPRINTK("phy%d: BROADCAST change received:%d\n",\r\nphy_id, cont);\r\nspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\r\nsas_phy->sas_prim = ffs(cont);\r\nspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\r\nsas_ha->notify_port_event(sas_phy,PORTE_BROADCAST_RCVD);\r\nbreak;\r\ncase LmUNKNOWNP:\r\nASD_DPRINTK("phy%d: unknown BREAK\n", phy_id);\r\nbreak;\r\ndefault:\r\nASD_DPRINTK("phy%d: primitive reg:0x%x, cont:0x%04x\n",\r\nphy_id, reg, cont);\r\nbreak;\r\n}\r\nbreak;\r\ncase LmPRMSTAT1BYTE0:\r\nswitch (cont) {\r\ncase LmHARDRST:\r\nASD_DPRINTK("phy%d: HARD_RESET primitive rcvd\n",\r\nphy_id);\r\nasd_deform_port(asd_ha, phy);\r\nsas_ha->notify_port_event(sas_phy, PORTE_HARD_RESET);\r\nbreak;\r\ndefault:\r\nASD_DPRINTK("phy%d: primitive reg:0x%x, cont:0x%04x\n",\r\nphy_id, reg, cont);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nASD_DPRINTK("unknown primitive register:0x%x\n",\r\ndl->status_block[1]);\r\nbreak;\r\n}\r\n}\r\nvoid asd_invalidate_edb(struct asd_ascb *ascb, int edb_id)\r\n{\r\nstruct asd_seq_data *seq = &ascb->ha->seq;\r\nstruct empty_scb *escb = &ascb->scb->escb;\r\nstruct sg_el *eb = &escb->eb[edb_id];\r\nstruct asd_dma_tok *edb = seq->edb_arr[ascb->edb_index + edb_id];\r\nmemset(edb->vaddr, 0, ASD_EDB_SIZE);\r\neb->flags |= ELEMENT_NOT_VALID;\r\nescb->num_valid--;\r\nif (escb->num_valid == 0) {\r\nint i;\r\nescb->num_valid = ASD_EDBS_PER_SCB;\r\nfor (i = 0; i < ASD_EDBS_PER_SCB; i++)\r\nescb->eb[i].flags = 0;\r\nif (!list_empty(&ascb->list))\r\nlist_del_init(&ascb->list);\r\ni = asd_post_escb_list(ascb->ha, ascb, 1);\r\nif (i)\r\nasd_printk("couldn't post escb, err:%d\n", i);\r\n}\r\n}\r\nstatic void escb_tasklet_complete(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl)\r\n{\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct sas_ha_struct *sas_ha = &asd_ha->sas_ha;\r\nint edb = (dl->opcode & DL_PHY_MASK) - 1;\r\nu8 sb_opcode = dl->status_block[0];\r\nint phy_id = sb_opcode & DL_PHY_MASK;\r\nstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\r\nstruct asd_phy *phy = &asd_ha->phys[phy_id];\r\nif (edb > 6 || edb < 0) {\r\nASD_DPRINTK("edb is 0x%x! dl->opcode is 0x%x\n",\r\nedb, dl->opcode);\r\nASD_DPRINTK("sb_opcode : 0x%x, phy_id: 0x%x\n",\r\nsb_opcode, phy_id);\r\nASD_DPRINTK("escb: vaddr: 0x%p, "\r\n"dma_handle: 0x%llx, next: 0x%llx, "\r\n"index:%d, opcode:0x%02x\n",\r\nascb->dma_scb.vaddr,\r\n(unsigned long long)ascb->dma_scb.dma_handle,\r\n(unsigned long long)\r\nle64_to_cpu(ascb->scb->header.next_scb),\r\nle16_to_cpu(ascb->scb->header.index),\r\nascb->scb->header.opcode);\r\n}\r\nswitch (sb_opcode) {\r\ncase REQ_TASK_ABORT: {\r\nstruct asd_ascb *a, *b;\r\nu16 tc_abort;\r\nstruct domain_device *failed_dev = NULL;\r\nASD_DPRINTK("%s: REQ_TASK_ABORT, reason=0x%X\n",\r\n__func__, dl->status_block[3]);\r\ntc_abort = *((u16*)(&dl->status_block[1]));\r\ntc_abort = le16_to_cpu(tc_abort);\r\nlist_for_each_entry_safe(a, b, &asd_ha->seq.pend_q, list) {\r\nstruct sas_task *task = a->uldd_task;\r\nif (a->tc_index != tc_abort)\r\ncontinue;\r\nif (task) {\r\nfailed_dev = task->dev;\r\nsas_task_abort(task);\r\n} else {\r\nASD_DPRINTK("R_T_A for non TASK scb 0x%x\n",\r\na->scb->header.opcode);\r\n}\r\nbreak;\r\n}\r\nif (!failed_dev) {\r\nASD_DPRINTK("%s: Can't find task (tc=%d) to abort!\n",\r\n__func__, tc_abort);\r\ngoto out;\r\n}\r\nlist_for_each_entry_safe(a, b, &asd_ha->seq.pend_q, list) {\r\nstruct sas_task *task = a->uldd_task;\r\nif (task &&\r\ntask->dev == failed_dev &&\r\na->tc_index != tc_abort)\r\nsas_task_abort(task);\r\n}\r\ngoto out;\r\n}\r\ncase REQ_DEVICE_RESET: {\r\nstruct asd_ascb *a;\r\nu16 conn_handle;\r\nunsigned long flags;\r\nstruct sas_task *last_dev_task = NULL;\r\nconn_handle = *((u16*)(&dl->status_block[1]));\r\nconn_handle = le16_to_cpu(conn_handle);\r\nASD_DPRINTK("%s: REQ_DEVICE_RESET, reason=0x%X\n", __func__,\r\ndl->status_block[3]);\r\nlist_for_each_entry(a, &asd_ha->seq.pend_q, list) {\r\nu16 x;\r\nstruct domain_device *dev;\r\nstruct sas_task *task = a->uldd_task;\r\nif (!task)\r\ncontinue;\r\ndev = task->dev;\r\nx = (unsigned long)dev->lldd_dev;\r\nif (x == conn_handle)\r\nlast_dev_task = task;\r\n}\r\nif (!last_dev_task) {\r\nASD_DPRINTK("%s: Device reset for idle device %d?\n",\r\n__func__, conn_handle);\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&last_dev_task->task_state_lock, flags);\r\nlast_dev_task->task_state_flags |= SAS_TASK_NEED_DEV_RESET;\r\nspin_unlock_irqrestore(&last_dev_task->task_state_lock, flags);\r\nlist_for_each_entry(a, &asd_ha->seq.pend_q, list) {\r\nu16 x;\r\nstruct domain_device *dev;\r\nstruct sas_task *task = a->uldd_task;\r\nif (!task)\r\ncontinue;\r\ndev = task->dev;\r\nx = (unsigned long)dev->lldd_dev;\r\nif (x == conn_handle)\r\nsas_task_abort(task);\r\n}\r\ngoto out;\r\n}\r\ncase SIGNAL_NCQ_ERROR:\r\nASD_DPRINTK("%s: SIGNAL_NCQ_ERROR\n", __func__);\r\ngoto out;\r\ncase CLEAR_NCQ_ERROR:\r\nASD_DPRINTK("%s: CLEAR_NCQ_ERROR\n", __func__);\r\ngoto out;\r\n}\r\nsb_opcode &= ~DL_PHY_MASK;\r\nswitch (sb_opcode) {\r\ncase BYTES_DMAED:\r\nASD_DPRINTK("%s: phy%d: BYTES_DMAED\n", __func__, phy_id);\r\nasd_bytes_dmaed_tasklet(ascb, dl, edb, phy_id);\r\nbreak;\r\ncase PRIMITIVE_RECVD:\r\nASD_DPRINTK("%s: phy%d: PRIMITIVE_RECVD\n", __func__,\r\nphy_id);\r\nasd_primitive_rcvd_tasklet(ascb, dl, phy_id);\r\nbreak;\r\ncase PHY_EVENT:\r\nASD_DPRINTK("%s: phy%d: PHY_EVENT\n", __func__, phy_id);\r\nasd_phy_event_tasklet(ascb, dl);\r\nbreak;\r\ncase LINK_RESET_ERROR:\r\nASD_DPRINTK("%s: phy%d: LINK_RESET_ERROR\n", __func__,\r\nphy_id);\r\nasd_link_reset_err_tasklet(ascb, dl, phy_id);\r\nbreak;\r\ncase TIMER_EVENT:\r\nASD_DPRINTK("%s: phy%d: TIMER_EVENT, lost dw sync\n",\r\n__func__, phy_id);\r\nasd_turn_led(asd_ha, phy_id, 0);\r\nsas_phy_disconnected(sas_phy);\r\nasd_deform_port(asd_ha, phy);\r\nsas_ha->notify_port_event(sas_phy, PORTE_TIMER_EVENT);\r\nbreak;\r\ndefault:\r\nASD_DPRINTK("%s: phy%d: unknown event:0x%x\n", __func__,\r\nphy_id, sb_opcode);\r\nASD_DPRINTK("edb is 0x%x! dl->opcode is 0x%x\n",\r\nedb, dl->opcode);\r\nASD_DPRINTK("sb_opcode : 0x%x, phy_id: 0x%x\n",\r\nsb_opcode, phy_id);\r\nASD_DPRINTK("escb: vaddr: 0x%p, "\r\n"dma_handle: 0x%llx, next: 0x%llx, "\r\n"index:%d, opcode:0x%02x\n",\r\nascb->dma_scb.vaddr,\r\n(unsigned long long)ascb->dma_scb.dma_handle,\r\n(unsigned long long)\r\nle64_to_cpu(ascb->scb->header.next_scb),\r\nle16_to_cpu(ascb->scb->header.index),\r\nascb->scb->header.opcode);\r\nbreak;\r\n}\r\nout:\r\nasd_invalidate_edb(ascb, edb);\r\n}\r\nint asd_init_post_escbs(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nint i;\r\nfor (i = 0; i < seq->num_escbs; i++)\r\nseq->escb_arr[i]->tasklet_complete = escb_tasklet_complete;\r\nASD_DPRINTK("posting %d escbs\n", i);\r\nreturn asd_post_escb_list(asd_ha, seq->escb_arr[0], seq->num_escbs);\r\n}\r\nstatic void control_phy_tasklet_complete(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl)\r\n{\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nstruct scb *scb = ascb->scb;\r\nstruct control_phy *control_phy = &scb->control_phy;\r\nu8 phy_id = control_phy->phy_id;\r\nstruct asd_phy *phy = &ascb->ha->phys[phy_id];\r\nu8 status = dl->status_block[0];\r\nu8 oob_status = dl->status_block[1];\r\nu8 oob_mode = dl->status_block[2];\r\nif (status != 0) {\r\nASD_DPRINTK("%s: phy%d status block opcode:0x%x\n",\r\n__func__, phy_id, status);\r\ngoto out;\r\n}\r\nswitch (control_phy->sub_func) {\r\ncase DISABLE_PHY:\r\nasd_ha->hw_prof.enabled_phys &= ~(1 << phy_id);\r\nasd_turn_led(asd_ha, phy_id, 0);\r\nasd_control_led(asd_ha, phy_id, 0);\r\nASD_DPRINTK("%s: disable phy%d\n", __func__, phy_id);\r\nbreak;\r\ncase ENABLE_PHY:\r\nasd_control_led(asd_ha, phy_id, 1);\r\nif (oob_status & CURRENT_OOB_DONE) {\r\nasd_ha->hw_prof.enabled_phys |= (1 << phy_id);\r\nget_lrate_mode(phy, oob_mode);\r\nasd_turn_led(asd_ha, phy_id, 1);\r\nASD_DPRINTK("%s: phy%d, lrate:0x%x, proto:0x%x\n",\r\n__func__, phy_id,phy->sas_phy.linkrate,\r\nphy->sas_phy.iproto);\r\n} else if (oob_status & CURRENT_SPINUP_HOLD) {\r\nasd_ha->hw_prof.enabled_phys |= (1 << phy_id);\r\nasd_turn_led(asd_ha, phy_id, 1);\r\nASD_DPRINTK("%s: phy%d, spinup hold\n", __func__,\r\nphy_id);\r\n} else if (oob_status & CURRENT_ERR_MASK) {\r\nasd_turn_led(asd_ha, phy_id, 0);\r\nASD_DPRINTK("%s: phy%d: error: oob status:0x%02x\n",\r\n__func__, phy_id, oob_status);\r\n} else if (oob_status & (CURRENT_HOT_PLUG_CNCT\r\n| CURRENT_DEVICE_PRESENT)) {\r\nasd_ha->hw_prof.enabled_phys |= (1 << phy_id);\r\nasd_turn_led(asd_ha, phy_id, 1);\r\nASD_DPRINTK("%s: phy%d: hot plug or device present\n",\r\n__func__, phy_id);\r\n} else {\r\nasd_ha->hw_prof.enabled_phys |= (1 << phy_id);\r\nasd_turn_led(asd_ha, phy_id, 0);\r\nASD_DPRINTK("%s: phy%d: no device present: "\r\n"oob_status:0x%x\n",\r\n__func__, phy_id, oob_status);\r\n}\r\nbreak;\r\ncase RELEASE_SPINUP_HOLD:\r\ncase PHY_NO_OP:\r\ncase EXECUTE_HARD_RESET:\r\nASD_DPRINTK("%s: phy%d: sub_func:0x%x\n", __func__,\r\nphy_id, control_phy->sub_func);\r\nbreak;\r\ndefault:\r\nASD_DPRINTK("%s: phy%d: sub_func:0x%x?\n", __func__,\r\nphy_id, control_phy->sub_func);\r\nbreak;\r\n}\r\nout:\r\nasd_ascb_free(ascb);\r\n}\r\nstatic void set_speed_mask(u8 *speed_mask, struct asd_phy_desc *pd)\r\n{\r\n*speed_mask = SAS_SPEED_60_DIS | SAS_SPEED_30_DIS | SAS_SPEED_15_DIS\r\n| SATA_SPEED_30_DIS | SATA_SPEED_15_DIS;\r\nswitch (pd->max_sas_lrate) {\r\ncase SAS_LINK_RATE_6_0_GBPS:\r\n*speed_mask &= ~SAS_SPEED_60_DIS;\r\ndefault:\r\ncase SAS_LINK_RATE_3_0_GBPS:\r\n*speed_mask &= ~SAS_SPEED_30_DIS;\r\ncase SAS_LINK_RATE_1_5_GBPS:\r\n*speed_mask &= ~SAS_SPEED_15_DIS;\r\n}\r\nswitch (pd->min_sas_lrate) {\r\ncase SAS_LINK_RATE_6_0_GBPS:\r\n*speed_mask |= SAS_SPEED_30_DIS;\r\ncase SAS_LINK_RATE_3_0_GBPS:\r\n*speed_mask |= SAS_SPEED_15_DIS;\r\ndefault:\r\ncase SAS_LINK_RATE_1_5_GBPS:\r\n;\r\n}\r\nswitch (pd->max_sata_lrate) {\r\ncase SAS_LINK_RATE_3_0_GBPS:\r\n*speed_mask &= ~SATA_SPEED_30_DIS;\r\ndefault:\r\ncase SAS_LINK_RATE_1_5_GBPS:\r\n*speed_mask &= ~SATA_SPEED_15_DIS;\r\n}\r\nswitch (pd->min_sata_lrate) {\r\ncase SAS_LINK_RATE_3_0_GBPS:\r\n*speed_mask |= SATA_SPEED_15_DIS;\r\ndefault:\r\ncase SAS_LINK_RATE_1_5_GBPS:\r\n;\r\n}\r\n}\r\nvoid asd_build_control_phy(struct asd_ascb *ascb, int phy_id, u8 subfunc)\r\n{\r\nstruct asd_phy *phy = &ascb->ha->phys[phy_id];\r\nstruct scb *scb = ascb->scb;\r\nstruct control_phy *control_phy = &scb->control_phy;\r\nscb->header.opcode = CONTROL_PHY;\r\ncontrol_phy->phy_id = (u8) phy_id;\r\ncontrol_phy->sub_func = subfunc;\r\nswitch (subfunc) {\r\ncase EXECUTE_HARD_RESET:\r\ncase ENABLE_PHY:\r\ncontrol_phy->hot_plug_delay = HOTPLUG_DELAY_TIMEOUT;\r\nset_speed_mask(&control_phy->speed_mask, phy->phy_desc);\r\nif (phy->sas_phy.role == PHY_ROLE_INITIATOR)\r\ncontrol_phy->port_type = SAS_PROTOCOL_ALL << 4;\r\nelse if (phy->sas_phy.role == PHY_ROLE_TARGET)\r\ncontrol_phy->port_type = SAS_PROTOCOL_ALL;\r\nelse\r\ncontrol_phy->port_type =\r\n(SAS_PROTOCOL_ALL << 4) | SAS_PROTOCOL_ALL;\r\ncontrol_phy->link_reset_retries = 10;\r\ncase RELEASE_SPINUP_HOLD:\r\ncontrol_phy->func_mask = FUNCTION_MASK_DEFAULT;\r\nif (phy->phy_desc->flags & ASD_SATA_SPINUP_HOLD)\r\ncontrol_phy->func_mask &= ~SPINUP_HOLD_DIS;\r\nelse\r\ncontrol_phy->func_mask |= SPINUP_HOLD_DIS;\r\n}\r\ncontrol_phy->conn_handle = cpu_to_le16(0xFFFF);\r\nascb->tasklet_complete = control_phy_tasklet_complete;\r\n}\r\nvoid asd_ascb_timedout(unsigned long data)\r\n{\r\nstruct asd_ascb *ascb = (void *) data;\r\nstruct asd_seq_data *seq = &ascb->ha->seq;\r\nunsigned long flags;\r\nASD_DPRINTK("scb:0x%x timed out\n", ascb->scb->header.opcode);\r\nspin_lock_irqsave(&seq->pend_q_lock, flags);\r\nseq->pending--;\r\nlist_del_init(&ascb->list);\r\nspin_unlock_irqrestore(&seq->pend_q_lock, flags);\r\nasd_ascb_free(ascb);\r\n}\r\nint asd_control_phy(struct asd_sas_phy *phy, enum phy_func func, void *arg)\r\n{\r\nstruct asd_ha_struct *asd_ha = phy->ha->lldd_ha;\r\nstruct asd_phy_desc *pd = asd_ha->phys[phy->id].phy_desc;\r\nstruct asd_ascb *ascb;\r\nstruct sas_phy_linkrates *rates;\r\nint res = 1;\r\nswitch (func) {\r\ncase PHY_FUNC_CLEAR_ERROR_LOG:\r\nreturn -ENOSYS;\r\ncase PHY_FUNC_SET_LINK_RATE:\r\nrates = arg;\r\nif (rates->minimum_linkrate) {\r\npd->min_sas_lrate = rates->minimum_linkrate;\r\npd->min_sata_lrate = rates->minimum_linkrate;\r\n}\r\nif (rates->maximum_linkrate) {\r\npd->max_sas_lrate = rates->maximum_linkrate;\r\npd->max_sata_lrate = rates->maximum_linkrate;\r\n}\r\nfunc = PHY_FUNC_LINK_RESET;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nascb = asd_ascb_alloc_list(asd_ha, &res, GFP_KERNEL);\r\nif (!ascb)\r\nreturn -ENOMEM;\r\nasd_build_control_phy(ascb, phy->id, phy_func_table[func]);\r\nres = asd_post_ascb_list(asd_ha, ascb , 1);\r\nif (res)\r\nasd_ascb_free(ascb);\r\nreturn res;\r\n}
