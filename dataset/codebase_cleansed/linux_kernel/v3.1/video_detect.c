static acpi_status\r\nacpi_backlight_cap_match(acpi_handle handle, u32 level, void *context,\r\nvoid **retyurn_value)\r\n{\r\nlong *cap = context;\r\nacpi_handle h_dummy;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_BCM", &h_dummy)) &&\r\nACPI_SUCCESS(acpi_get_handle(handle, "_BCL", &h_dummy))) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found generic backlight "\r\n"support\n"));\r\n*cap |= ACPI_VIDEO_BACKLIGHT;\r\nif (ACPI_FAILURE(acpi_get_handle(handle, "_BQC", &h_dummy)))\r\nprintk(KERN_WARNING FW_BUG PREFIX "No _BQC method, "\r\n"cannot determine initial brightness\n");\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nreturn 0;\r\n}\r\nlong acpi_is_video_device(struct acpi_device *device)\r\n{\r\nacpi_handle h_dummy;\r\nlong video_caps = 0;\r\nif (!device)\r\nreturn 0;\r\nif (ACPI_SUCCESS(acpi_get_handle(device->handle, "_DOD", &h_dummy)) ||\r\nACPI_SUCCESS(acpi_get_handle(device->handle, "_DOS", &h_dummy)))\r\nvideo_caps |= ACPI_VIDEO_OUTPUT_SWITCHING;\r\nif (ACPI_SUCCESS(acpi_get_handle(device->handle, "_ROM", &h_dummy)))\r\nvideo_caps |= ACPI_VIDEO_ROM_AVAILABLE;\r\nif (ACPI_SUCCESS(acpi_get_handle(device->handle, "_VPO", &h_dummy)) &&\r\nACPI_SUCCESS(acpi_get_handle(device->handle, "_GPD", &h_dummy)) &&\r\nACPI_SUCCESS(acpi_get_handle(device->handle, "_SPD", &h_dummy)))\r\nvideo_caps |= ACPI_VIDEO_DEVICE_POSTING;\r\nif (video_caps)\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, device->handle,\r\nACPI_UINT32_MAX, acpi_backlight_cap_match, NULL,\r\n&video_caps, NULL);\r\nreturn video_caps;\r\n}\r\nstatic acpi_status\r\nfind_video(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nlong *cap = context;\r\nstruct pci_dev *dev;\r\nstruct acpi_device *acpi_dev;\r\nconst struct acpi_device_id video_ids[] = {\r\n{ACPI_VIDEO_HID, 0},\r\n{"", 0},\r\n};\r\nif (acpi_bus_get_device(handle, &acpi_dev))\r\nreturn AE_OK;\r\nif (!acpi_match_device_ids(acpi_dev, video_ids)) {\r\ndev = acpi_get_pci_dev(handle);\r\nif (!dev)\r\nreturn AE_OK;\r\npci_dev_put(dev);\r\n*cap |= acpi_is_video_device(acpi_dev);\r\n}\r\nreturn AE_OK;\r\n}\r\nlong acpi_video_get_capabilities(acpi_handle graphics_handle)\r\n{\r\nlong caps = 0;\r\nstruct acpi_device *tmp_dev;\r\nacpi_status status;\r\nif (acpi_video_caps_checked && graphics_handle == NULL)\r\nreturn acpi_video_support;\r\nif (!graphics_handle) {\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, find_video, NULL,\r\n&caps, NULL);\r\nacpi_video_support |= caps;\r\nacpi_video_caps_checked = 1;\r\n} else {\r\nstatus = acpi_bus_get_device(graphics_handle, &tmp_dev);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Invalid device"));\r\nreturn 0;\r\n}\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, graphics_handle,\r\nACPI_UINT32_MAX, find_video, NULL,\r\n&caps, NULL);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "We have 0x%lX video support %s %s\n",\r\ngraphics_handle ? caps : acpi_video_support,\r\ngraphics_handle ? "on device " : "in general",\r\ngraphics_handle ? acpi_device_bid(tmp_dev) : ""));\r\nreturn caps;\r\n}\r\nint acpi_video_backlight_support(void)\r\n{\r\nif (!acpi_video_caps_checked)\r\nacpi_video_get_capabilities(NULL);\r\nif (acpi_video_support & ACPI_VIDEO_BACKLIGHT_FORCE_VENDOR)\r\nreturn 0;\r\nelse if (acpi_video_support & ACPI_VIDEO_BACKLIGHT_FORCE_VIDEO)\r\nreturn 1;\r\nif (acpi_video_support & ACPI_VIDEO_BACKLIGHT_DMI_VENDOR)\r\nreturn 0;\r\nelse if (acpi_video_support & ACPI_VIDEO_BACKLIGHT_DMI_VIDEO)\r\nreturn 1;\r\nreturn acpi_video_support & ACPI_VIDEO_BACKLIGHT;\r\n}\r\nstatic int __init acpi_backlight(char *str)\r\n{\r\nif (str == NULL || *str == '\0')\r\nreturn 1;\r\nelse {\r\nif (!strcmp("vendor", str))\r\nacpi_video_support |=\r\nACPI_VIDEO_BACKLIGHT_FORCE_VENDOR;\r\nif (!strcmp("video", str))\r\nacpi_video_support |=\r\nACPI_VIDEO_BACKLIGHT_FORCE_VIDEO;\r\n}\r\nreturn 1;\r\n}
