static int serio_raw_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct serio_raw_list *list = file->private_data;\r\nreturn fasync_helper(fd, file, on, &list->fasync);\r\n}\r\nstatic struct serio_raw *serio_raw_locate(int minor)\r\n{\r\nstruct serio_raw *serio_raw;\r\nlist_for_each_entry(serio_raw, &serio_raw_list, node) {\r\nif (serio_raw->dev.minor == minor)\r\nreturn serio_raw;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int serio_raw_open(struct inode *inode, struct file *file)\r\n{\r\nstruct serio_raw *serio_raw;\r\nstruct serio_raw_list *list;\r\nint retval = 0;\r\nretval = mutex_lock_interruptible(&serio_raw_mutex);\r\nif (retval)\r\nreturn retval;\r\nserio_raw = serio_raw_locate(iminor(inode));\r\nif (!serio_raw) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (!serio_raw->serio) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nlist = kzalloc(sizeof(struct serio_raw_list), GFP_KERNEL);\r\nif (!list) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nlist->serio_raw = serio_raw;\r\nfile->private_data = list;\r\nserio_raw->refcnt++;\r\nlist_add_tail(&list->node, &serio_raw->list);\r\nout:\r\nmutex_unlock(&serio_raw_mutex);\r\nreturn retval;\r\n}\r\nstatic int serio_raw_cleanup(struct serio_raw *serio_raw)\r\n{\r\nif (--serio_raw->refcnt == 0) {\r\nmisc_deregister(&serio_raw->dev);\r\nlist_del_init(&serio_raw->node);\r\nkfree(serio_raw);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int serio_raw_release(struct inode *inode, struct file *file)\r\n{\r\nstruct serio_raw_list *list = file->private_data;\r\nstruct serio_raw *serio_raw = list->serio_raw;\r\nmutex_lock(&serio_raw_mutex);\r\nserio_raw_cleanup(serio_raw);\r\nmutex_unlock(&serio_raw_mutex);\r\nreturn 0;\r\n}\r\nstatic int serio_raw_fetch_byte(struct serio_raw *serio_raw, char *c)\r\n{\r\nunsigned long flags;\r\nint empty;\r\nspin_lock_irqsave(&serio_raw->serio->lock, flags);\r\nempty = serio_raw->head == serio_raw->tail;\r\nif (!empty) {\r\n*c = serio_raw->queue[serio_raw->tail];\r\nserio_raw->tail = (serio_raw->tail + 1) % SERIO_RAW_QUEUE_LEN;\r\n}\r\nspin_unlock_irqrestore(&serio_raw->serio->lock, flags);\r\nreturn !empty;\r\n}\r\nstatic ssize_t serio_raw_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct serio_raw_list *list = file->private_data;\r\nstruct serio_raw *serio_raw = list->serio_raw;\r\nchar uninitialized_var(c);\r\nssize_t retval = 0;\r\nif (!serio_raw->serio)\r\nreturn -ENODEV;\r\nif (serio_raw->head == serio_raw->tail && (file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nretval = wait_event_interruptible(list->serio_raw->wait,\r\nserio_raw->head != serio_raw->tail || !serio_raw->serio);\r\nif (retval)\r\nreturn retval;\r\nif (!serio_raw->serio)\r\nreturn -ENODEV;\r\nwhile (retval < count && serio_raw_fetch_byte(serio_raw, &c)) {\r\nif (put_user(c, buffer++))\r\nreturn -EFAULT;\r\nretval++;\r\n}\r\nreturn retval;\r\n}\r\nstatic ssize_t serio_raw_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct serio_raw_list *list = file->private_data;\r\nssize_t written = 0;\r\nint retval;\r\nunsigned char c;\r\nretval = mutex_lock_interruptible(&serio_raw_mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!list->serio_raw->serio) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (count > 32)\r\ncount = 32;\r\nwhile (count--) {\r\nif (get_user(c, buffer++)) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nif (serio_write(list->serio_raw->serio, c)) {\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nwritten++;\r\n};\r\nout:\r\nmutex_unlock(&serio_raw_mutex);\r\nreturn written;\r\n}\r\nstatic unsigned int serio_raw_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct serio_raw_list *list = file->private_data;\r\npoll_wait(file, &list->serio_raw->wait, wait);\r\nif (list->serio_raw->head != list->serio_raw->tail)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t serio_raw_interrupt(struct serio *serio, unsigned char data,\r\nunsigned int dfl)\r\n{\r\nstruct serio_raw *serio_raw = serio_get_drvdata(serio);\r\nstruct serio_raw_list *list;\r\nunsigned int head = serio_raw->head;\r\nserio_raw->queue[head] = data;\r\nhead = (head + 1) % SERIO_RAW_QUEUE_LEN;\r\nif (likely(head != serio_raw->tail)) {\r\nserio_raw->head = head;\r\nlist_for_each_entry(list, &serio_raw->list, node)\r\nkill_fasync(&list->fasync, SIGIO, POLL_IN);\r\nwake_up_interruptible(&serio_raw->wait);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int serio_raw_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct serio_raw *serio_raw;\r\nint err;\r\nif (!(serio_raw = kzalloc(sizeof(struct serio_raw), GFP_KERNEL))) {\r\nprintk(KERN_ERR "serio_raw.c: can't allocate memory for a device\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&serio_raw_mutex);\r\nsnprintf(serio_raw->name, sizeof(serio_raw->name), "serio_raw%d", serio_raw_no++);\r\nserio_raw->refcnt = 1;\r\nserio_raw->serio = serio;\r\nINIT_LIST_HEAD(&serio_raw->list);\r\ninit_waitqueue_head(&serio_raw->wait);\r\nserio_set_drvdata(serio, serio_raw);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto out_free;\r\nlist_add_tail(&serio_raw->node, &serio_raw_list);\r\nserio_raw->dev.minor = PSMOUSE_MINOR;\r\nserio_raw->dev.name = serio_raw->name;\r\nserio_raw->dev.parent = &serio->dev;\r\nserio_raw->dev.fops = &serio_raw_fops;\r\nerr = misc_register(&serio_raw->dev);\r\nif (err) {\r\nserio_raw->dev.minor = MISC_DYNAMIC_MINOR;\r\nerr = misc_register(&serio_raw->dev);\r\n}\r\nif (err) {\r\nprintk(KERN_INFO "serio_raw: failed to register raw access device for %s\n",\r\nserio->phys);\r\ngoto out_close;\r\n}\r\nprintk(KERN_INFO "serio_raw: raw access enabled on %s (%s, minor %d)\n",\r\nserio->phys, serio_raw->name, serio_raw->dev.minor);\r\ngoto out;\r\nout_close:\r\nserio_close(serio);\r\nlist_del_init(&serio_raw->node);\r\nout_free:\r\nserio_set_drvdata(serio, NULL);\r\nkfree(serio_raw);\r\nout:\r\nmutex_unlock(&serio_raw_mutex);\r\nreturn err;\r\n}\r\nstatic int serio_raw_reconnect(struct serio *serio)\r\n{\r\nstruct serio_raw *serio_raw = serio_get_drvdata(serio);\r\nstruct serio_driver *drv = serio->drv;\r\nif (!drv || !serio_raw) {\r\nprintk(KERN_DEBUG "serio_raw: reconnect request, but serio is disconnected, ignoring...\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void serio_raw_disconnect(struct serio *serio)\r\n{\r\nstruct serio_raw *serio_raw;\r\nmutex_lock(&serio_raw_mutex);\r\nserio_raw = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\nserio_raw->serio = NULL;\r\nif (!serio_raw_cleanup(serio_raw))\r\nwake_up_interruptible(&serio_raw->wait);\r\nmutex_unlock(&serio_raw_mutex);\r\n}\r\nstatic int __init serio_raw_init(void)\r\n{\r\nreturn serio_register_driver(&serio_raw_drv);\r\n}\r\nstatic void __exit serio_raw_exit(void)\r\n{\r\nserio_unregister_driver(&serio_raw_drv);\r\n}
