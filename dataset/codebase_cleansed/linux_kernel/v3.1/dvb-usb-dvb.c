static int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;\r\nint newfeedcount, ret;\r\nif (adap == NULL)\r\nreturn -ENODEV;\r\nnewfeedcount = adap->feedcount + (onoff ? 1 : -1);\r\nif (newfeedcount == 0) {\r\ndeb_ts("stop feeding\n");\r\nusb_urb_kill(&adap->stream);\r\nif (adap->props.streaming_ctrl != NULL) {\r\nret = adap->props.streaming_ctrl(adap, 0);\r\nif (ret < 0) {\r\nerr("error while stopping stream.");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nadap->feedcount = newfeedcount;\r\ndeb_ts("setting pid (%s): %5d %04x at index %d '%s'\n",adap->pid_filtering ?\r\n"yes" : "no", dvbdmxfeed->pid,dvbdmxfeed->pid,dvbdmxfeed->index,onoff ?\r\n"on" : "off");\r\nif (adap->props.caps & DVB_USB_ADAP_HAS_PID_FILTER &&\r\nadap->pid_filtering &&\r\nadap->props.pid_filter != NULL)\r\nadap->props.pid_filter(adap, dvbdmxfeed->index, dvbdmxfeed->pid,onoff);\r\nif (adap->feedcount == onoff && adap->feedcount > 0) {\r\ndeb_ts("submitting all URBs\n");\r\nusb_urb_submit(&adap->stream);\r\ndeb_ts("controlling pid parser\n");\r\nif (adap->props.caps & DVB_USB_ADAP_HAS_PID_FILTER &&\r\nadap->props.caps &\r\nDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF &&\r\nadap->props.pid_filter_ctrl != NULL) {\r\nret = adap->props.pid_filter_ctrl(adap,\r\nadap->pid_filtering);\r\nif (ret < 0) {\r\nerr("could not handle pid_parser");\r\nreturn ret;\r\n}\r\n}\r\ndeb_ts("start feeding\n");\r\nif (adap->props.streaming_ctrl != NULL) {\r\nret = adap->props.streaming_ctrl(adap, 1);\r\nif (ret < 0) {\r\nerr("error while enabling fifo.");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\ndeb_ts("start pid: 0x%04x, feedtype: %d\n", dvbdmxfeed->pid,dvbdmxfeed->type);\r\nreturn dvb_usb_ctrl_feed(dvbdmxfeed,1);\r\n}\r\nstatic int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\ndeb_ts("stop pid: 0x%04x, feedtype: %d\n", dvbdmxfeed->pid, dvbdmxfeed->type);\r\nreturn dvb_usb_ctrl_feed(dvbdmxfeed,0);\r\n}\r\nint dvb_usb_adapter_dvb_init(struct dvb_usb_adapter *adap, short *adapter_nums)\r\n{\r\nint ret = dvb_register_adapter(&adap->dvb_adap, adap->dev->desc->name,\r\nadap->dev->owner, &adap->dev->udev->dev,\r\nadapter_nums);\r\nif (ret < 0) {\r\ndeb_info("dvb_register_adapter failed: error %d", ret);\r\ngoto err;\r\n}\r\nadap->dvb_adap.priv = adap;\r\nadap->dvb_adap.fe_ioctl_override = adap->props.fe_ioctl_override;\r\nif (adap->dev->props.read_mac_address) {\r\nif (adap->dev->props.read_mac_address(adap->dev,adap->dvb_adap.proposed_mac) == 0)\r\ninfo("MAC address: %pM",adap->dvb_adap.proposed_mac);\r\nelse\r\nerr("MAC address reading failed.");\r\n}\r\nadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\r\nadap->demux.priv = adap;\r\nadap->demux.feednum = adap->demux.filternum = adap->max_feed_count;\r\nadap->demux.start_feed = dvb_usb_start_feed;\r\nadap->demux.stop_feed = dvb_usb_stop_feed;\r\nadap->demux.write_to_decoder = NULL;\r\nif ((ret = dvb_dmx_init(&adap->demux)) < 0) {\r\nerr("dvb_dmx_init failed: error %d",ret);\r\ngoto err_dmx;\r\n}\r\nadap->dmxdev.filternum = adap->demux.filternum;\r\nadap->dmxdev.demux = &adap->demux.dmx;\r\nadap->dmxdev.capabilities = 0;\r\nif ((ret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap)) < 0) {\r\nerr("dvb_dmxdev_init failed: error %d",ret);\r\ngoto err_dmx_dev;\r\n}\r\ndvb_net_init(&adap->dvb_adap, &adap->dvb_net, &adap->demux.dmx);\r\nadap->state |= DVB_USB_ADAP_STATE_DVB;\r\nreturn 0;\r\nerr_dmx_dev:\r\ndvb_dmx_release(&adap->demux);\r\nerr_dmx:\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\nerr:\r\nreturn ret;\r\n}\r\nint dvb_usb_adapter_dvb_exit(struct dvb_usb_adapter *adap)\r\n{\r\nif (adap->state & DVB_USB_ADAP_STATE_DVB) {\r\ndeb_info("unregistering DVB part\n");\r\ndvb_net_release(&adap->dvb_net);\r\nadap->demux.dmx.close(&adap->demux.dmx);\r\ndvb_dmxdev_release(&adap->dmxdev);\r\ndvb_dmx_release(&adap->demux);\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\nadap->state &= ~DVB_USB_ADAP_STATE_DVB;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_fe_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\ndvb_usb_device_power_ctrl(adap->dev, 1);\r\nif (adap->fe_init)\r\nadap->fe_init(fe);\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nif (adap->fe_sleep)\r\nadap->fe_sleep(fe);\r\nreturn dvb_usb_device_power_ctrl(adap->dev, 0);\r\n}\r\nint dvb_usb_adapter_frontend_init(struct dvb_usb_adapter *adap)\r\n{\r\nif (adap->props.frontend_attach == NULL) {\r\nerr("strange: '%s' #%d doesn't want to attach a frontend.",adap->dev->desc->name, adap->id);\r\nreturn 0;\r\n}\r\nif (adap->props.frontend_attach(adap) == 0 && adap->fe != NULL) {\r\nadap->fe_init = adap->fe->ops.init; adap->fe->ops.init = dvb_usb_fe_wakeup;\r\nadap->fe_sleep = adap->fe->ops.sleep; adap->fe->ops.sleep = dvb_usb_fe_sleep;\r\nif (dvb_register_frontend(&adap->dvb_adap, adap->fe)) {\r\nerr("Frontend registration failed.");\r\ndvb_frontend_detach(adap->fe);\r\nadap->fe = NULL;\r\nreturn -ENODEV;\r\n}\r\nif (adap->props.tuner_attach != NULL)\r\nadap->props.tuner_attach(adap);\r\n} else\r\nerr("no frontend was attached by '%s'",adap->dev->desc->name);\r\nreturn 0;\r\n}\r\nint dvb_usb_adapter_frontend_exit(struct dvb_usb_adapter *adap)\r\n{\r\nif (adap->fe != NULL) {\r\ndvb_unregister_frontend(adap->fe);\r\ndvb_frontend_detach(adap->fe);\r\n}\r\nreturn 0;\r\n}
