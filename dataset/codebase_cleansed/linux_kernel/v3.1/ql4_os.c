static enum blk_eh_timer_return qla4xxx_eh_cmd_timed_out(struct scsi_cmnd *sc)\r\n{\r\nstruct iscsi_cls_session *session;\r\nstruct ddb_entry *ddb_entry;\r\nsession = starget_to_session(scsi_target(sc->device));\r\nddb_entry = session->dd_data;\r\nif (atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE)\r\nreturn BLK_EH_RESET_TIMER;\r\nelse\r\nreturn BLK_EH_NOT_HANDLED;\r\n}\r\nstatic void qla4xxx_recovery_timedout(struct iscsi_cls_session *session)\r\n{\r\nstruct ddb_entry *ddb_entry = session->dd_data;\r\nstruct scsi_qla_host *ha = ddb_entry->ha;\r\nif (atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE) {\r\natomic_set(&ddb_entry->state, DDB_STATE_DEAD);\r\nDEBUG2(printk("scsi%ld: %s: ddb [%d] session recovery timeout "\r\n"of (%d) secs exhausted, marking device DEAD.\n",\r\nha->host_no, __func__, ddb_entry->fw_ddb_index,\r\nddb_entry->sess->recovery_tmo));\r\n}\r\n}\r\nstatic int qla4xxx_host_get_param(struct Scsi_Host *shost,\r\nenum iscsi_host_param param, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(shost);\r\nint len;\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\nlen = sysfs_format_mac(buf, ha->my_mac, MAC_ADDR_LEN);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_IPADDRESS:\r\nlen = sprintf(buf, "%d.%d.%d.%d\n", ha->ip_address[0],\r\nha->ip_address[1], ha->ip_address[2],\r\nha->ip_address[3]);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nlen = sprintf(buf, "%s\n", ha->name_string);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nstatic int qla4xxx_sess_get_param(struct iscsi_cls_session *sess,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct ddb_entry *ddb_entry = sess->dd_data;\r\nint len;\r\nswitch (param) {\r\ncase ISCSI_PARAM_TARGET_NAME:\r\nlen = snprintf(buf, PAGE_SIZE - 1, "%s\n",\r\nddb_entry->iscsi_name);\r\nbreak;\r\ncase ISCSI_PARAM_TPGT:\r\nlen = sprintf(buf, "%u\n", ddb_entry->tpgt);\r\nbreak;\r\ncase ISCSI_PARAM_TARGET_ALIAS:\r\nlen = snprintf(buf, PAGE_SIZE - 1, "%s\n",\r\nddb_entry->iscsi_alias);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nstatic int qla4xxx_conn_get_param(struct iscsi_cls_conn *conn,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct iscsi_cls_session *session;\r\nstruct ddb_entry *ddb_entry;\r\nint len;\r\nsession = iscsi_dev_to_session(conn->dev.parent);\r\nddb_entry = session->dd_data;\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\nlen = sprintf(buf, "%hu\n", ddb_entry->port);\r\nbreak;\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\nlen = sprintf(buf, "%pI4\n", &ddb_entry->ip_addr);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nstatic int qla4xxx_tgt_dscvr(struct Scsi_Host *shost,\r\nenum iscsi_tgt_dscvr type, uint32_t enable,\r\nstruct sockaddr *dst_addr)\r\n{\r\nstruct scsi_qla_host *ha;\r\nstruct sockaddr_in *addr;\r\nstruct sockaddr_in6 *addr6;\r\nint ret = 0;\r\nha = (struct scsi_qla_host *) shost->hostdata;\r\nswitch (type) {\r\ncase ISCSI_TGT_DSCVR_SEND_TARGETS:\r\nif (dst_addr->sa_family == AF_INET) {\r\naddr = (struct sockaddr_in *)dst_addr;\r\nif (qla4xxx_send_tgts(ha, (char *)&addr->sin_addr,\r\naddr->sin_port) != QLA_SUCCESS)\r\nret = -EIO;\r\n} else if (dst_addr->sa_family == AF_INET6) {\r\naddr6 = (struct sockaddr_in6 *)dst_addr;\r\nif (qla4xxx_send_tgts(ha, (char *)&addr6->sin6_addr,\r\naddr6->sin6_port) != QLA_SUCCESS)\r\nret = -EIO;\r\n} else\r\nret = -ENOSYS;\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\n}\r\nreturn ret;\r\n}\r\nvoid qla4xxx_destroy_sess(struct ddb_entry *ddb_entry)\r\n{\r\nif (!ddb_entry->sess)\r\nreturn;\r\nif (ddb_entry->conn) {\r\natomic_set(&ddb_entry->state, DDB_STATE_DEAD);\r\niscsi_remove_session(ddb_entry->sess);\r\n}\r\niscsi_free_session(ddb_entry->sess);\r\n}\r\nint qla4xxx_add_sess(struct ddb_entry *ddb_entry)\r\n{\r\nint err;\r\nddb_entry->sess->recovery_tmo = ql4xsess_recovery_tmo;\r\nerr = iscsi_add_session(ddb_entry->sess, ddb_entry->fw_ddb_index);\r\nif (err) {\r\nDEBUG2(printk(KERN_ERR "Could not add session.\n"));\r\nreturn err;\r\n}\r\nddb_entry->conn = iscsi_create_conn(ddb_entry->sess, 0, 0);\r\nif (!ddb_entry->conn) {\r\niscsi_remove_session(ddb_entry->sess);\r\nDEBUG2(printk(KERN_ERR "Could not add connection.\n"));\r\nreturn -ENOMEM;\r\n}\r\niscsi_unblock_session(ddb_entry->sess);\r\nreturn 0;\r\n}\r\nstruct ddb_entry *qla4xxx_alloc_sess(struct scsi_qla_host *ha)\r\n{\r\nstruct ddb_entry *ddb_entry;\r\nstruct iscsi_cls_session *sess;\r\nsess = iscsi_alloc_session(ha->host, &qla4xxx_iscsi_transport,\r\nsizeof(struct ddb_entry));\r\nif (!sess)\r\nreturn NULL;\r\nddb_entry = sess->dd_data;\r\nmemset(ddb_entry, 0, sizeof(*ddb_entry));\r\nddb_entry->ha = ha;\r\nddb_entry->sess = sess;\r\nreturn ddb_entry;\r\n}\r\nstatic void qla4xxx_scan_start(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_qla_host *ha = shost_priv(shost);\r\nstruct ddb_entry *ddb_entry, *ddbtemp;\r\nlist_for_each_entry_safe(ddb_entry, ddbtemp, &ha->ddb_list, list) {\r\nif (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE)\r\nqla4xxx_add_sess(ddb_entry);\r\n}\r\n}\r\nstatic void qla4xxx_start_timer(struct scsi_qla_host *ha, void *func,\r\nunsigned long interval)\r\n{\r\nDEBUG(printk("scsi: %s: Starting timer thread for adapter %d\n",\r\n__func__, ha->host->host_no));\r\ninit_timer(&ha->timer);\r\nha->timer.expires = jiffies + interval * HZ;\r\nha->timer.data = (unsigned long)ha;\r\nha->timer.function = (void (*)(unsigned long))func;\r\nadd_timer(&ha->timer);\r\nha->timer_active = 1;\r\n}\r\nstatic void qla4xxx_stop_timer(struct scsi_qla_host *ha)\r\n{\r\ndel_timer_sync(&ha->timer);\r\nha->timer_active = 0;\r\n}\r\nvoid qla4xxx_mark_device_missing(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry)\r\n{\r\nif ((atomic_read(&ddb_entry->state) != DDB_STATE_DEAD)) {\r\natomic_set(&ddb_entry->state, DDB_STATE_MISSING);\r\nDEBUG2(printk("scsi%ld: ddb [%d] marked MISSING\n",\r\nha->host_no, ddb_entry->fw_ddb_index));\r\n} else\r\nDEBUG2(printk("scsi%ld: ddb [%d] DEAD\n", ha->host_no,\r\nddb_entry->fw_ddb_index))\r\niscsi_block_session(ddb_entry->sess);\r\niscsi_conn_error_event(ddb_entry->conn, ISCSI_ERR_CONN_FAILED);\r\n}\r\nvoid qla4xxx_mark_all_devices_missing(struct scsi_qla_host *ha)\r\n{\r\nstruct ddb_entry *ddb_entry, *ddbtemp;\r\nlist_for_each_entry_safe(ddb_entry, ddbtemp, &ha->ddb_list, list) {\r\nqla4xxx_mark_device_missing(ha, ddb_entry);\r\n}\r\n}\r\nstatic struct srb* qla4xxx_get_new_srb(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct srb *srb;\r\nsrb = mempool_alloc(ha->srb_mempool, GFP_ATOMIC);\r\nif (!srb)\r\nreturn srb;\r\nkref_init(&srb->srb_ref);\r\nsrb->ha = ha;\r\nsrb->ddb = ddb_entry;\r\nsrb->cmd = cmd;\r\nsrb->flags = 0;\r\nCMD_SP(cmd) = (void *)srb;\r\nreturn srb;\r\n}\r\nstatic void qla4xxx_srb_free_dma(struct scsi_qla_host *ha, struct srb *srb)\r\n{\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nif (srb->flags & SRB_DMA_VALID) {\r\nscsi_dma_unmap(cmd);\r\nsrb->flags &= ~SRB_DMA_VALID;\r\n}\r\nCMD_SP(cmd) = NULL;\r\n}\r\nvoid qla4xxx_srb_compl(struct kref *ref)\r\n{\r\nstruct srb *srb = container_of(ref, struct srb, srb_ref);\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nstruct scsi_qla_host *ha = srb->ha;\r\nqla4xxx_srb_free_dma(ha, srb);\r\nmempool_free(srb, ha->srb_mempool);\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic int qla4xxx_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct ddb_entry *ddb_entry = cmd->device->hostdata;\r\nstruct iscsi_cls_session *sess = ddb_entry->sess;\r\nstruct srb *srb;\r\nint rval;\r\nif (test_bit(AF_EEH_BUSY, &ha->flags)) {\r\nif (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))\r\ncmd->result = DID_NO_CONNECT << 16;\r\nelse\r\ncmd->result = DID_REQUEUE << 16;\r\ngoto qc_fail_command;\r\n}\r\nif (!sess) {\r\ncmd->result = DID_IMM_RETRY << 16;\r\ngoto qc_fail_command;\r\n}\r\nrval = iscsi_session_chkready(sess);\r\nif (rval) {\r\ncmd->result = rval;\r\ngoto qc_fail_command;\r\n}\r\nif (atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE) {\r\nif (atomic_read(&ddb_entry->state) == DDB_STATE_DEAD) {\r\ncmd->result = DID_NO_CONNECT << 16;\r\ngoto qc_fail_command;\r\n}\r\nreturn SCSI_MLQUEUE_TARGET_BUSY;\r\n}\r\nif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||\r\ntest_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||\r\n!test_bit(AF_ONLINE, &ha->flags) ||\r\ntest_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))\r\ngoto qc_host_busy;\r\nsrb = qla4xxx_get_new_srb(ha, ddb_entry, cmd);\r\nif (!srb)\r\ngoto qc_host_busy;\r\nrval = qla4xxx_send_command_to_isp(ha, srb);\r\nif (rval != QLA_SUCCESS)\r\ngoto qc_host_busy_free_sp;\r\nreturn 0;\r\nqc_host_busy_free_sp:\r\nqla4xxx_srb_free_dma(ha, srb);\r\nmempool_free(srb, ha->srb_mempool);\r\nqc_host_busy:\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nqc_fail_command:\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\nstatic void qla4xxx_mem_free(struct scsi_qla_host *ha)\r\n{\r\nif (ha->queues)\r\ndma_free_coherent(&ha->pdev->dev, ha->queues_len, ha->queues,\r\nha->queues_dma);\r\nha->queues_len = 0;\r\nha->queues = NULL;\r\nha->queues_dma = 0;\r\nha->request_ring = NULL;\r\nha->request_dma = 0;\r\nha->response_ring = NULL;\r\nha->response_dma = 0;\r\nha->shadow_regs = NULL;\r\nha->shadow_regs_dma = 0;\r\nif (ha->srb_mempool)\r\nmempool_destroy(ha->srb_mempool);\r\nha->srb_mempool = NULL;\r\nif (is_qla8022(ha)) {\r\nif (ha->nx_pcibase)\r\niounmap(\r\n(struct device_reg_82xx __iomem *)ha->nx_pcibase);\r\n} else if (ha->reg)\r\niounmap(ha->reg);\r\npci_release_regions(ha->pdev);\r\n}\r\nstatic int qla4xxx_mem_alloc(struct scsi_qla_host *ha)\r\n{\r\nunsigned long align;\r\nha->queues_len = ((REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +\r\n(RESPONSE_QUEUE_DEPTH * QUEUE_SIZE) +\r\nsizeof(struct shadow_regs) +\r\nMEM_ALIGN_VALUE +\r\n(PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\r\nha->queues = dma_alloc_coherent(&ha->pdev->dev, ha->queues_len,\r\n&ha->queues_dma, GFP_KERNEL);\r\nif (ha->queues == NULL) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Memory Allocation failed - queues.\n");\r\ngoto mem_alloc_error_exit;\r\n}\r\nmemset(ha->queues, 0, ha->queues_len);\r\nalign = 0;\r\nif ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1))\r\nalign = MEM_ALIGN_VALUE - ((unsigned long)ha->queues_dma &\r\n(MEM_ALIGN_VALUE - 1));\r\nha->request_dma = ha->queues_dma + align;\r\nha->request_ring = (struct queue_entry *) (ha->queues + align);\r\nha->response_dma = ha->queues_dma + align +\r\n(REQUEST_QUEUE_DEPTH * QUEUE_SIZE);\r\nha->response_ring = (struct queue_entry *) (ha->queues + align +\r\n(REQUEST_QUEUE_DEPTH *\r\nQUEUE_SIZE));\r\nha->shadow_regs_dma = ha->queues_dma + align +\r\n(REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +\r\n(RESPONSE_QUEUE_DEPTH * QUEUE_SIZE);\r\nha->shadow_regs = (struct shadow_regs *) (ha->queues + align +\r\n(REQUEST_QUEUE_DEPTH *\r\nQUEUE_SIZE) +\r\n(RESPONSE_QUEUE_DEPTH *\r\nQUEUE_SIZE));\r\nha->srb_mempool = mempool_create(SRB_MIN_REQ, mempool_alloc_slab,\r\nmempool_free_slab, srb_cachep);\r\nif (ha->srb_mempool == NULL) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Memory Allocation failed - SRB Pool.\n");\r\ngoto mem_alloc_error_exit;\r\n}\r\nreturn QLA_SUCCESS;\r\nmem_alloc_error_exit:\r\nqla4xxx_mem_free(ha);\r\nreturn QLA_ERROR;\r\n}\r\nstatic void qla4_8xxx_check_fw_alive(struct scsi_qla_host *ha)\r\n{\r\nuint32_t fw_heartbeat_counter, halt_status;\r\nfw_heartbeat_counter = qla4_8xxx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);\r\nif (fw_heartbeat_counter == 0xffffffff) {\r\nDEBUG2(printk(KERN_WARNING "scsi%ld: %s: Device in frozen "\r\n"state, QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\n",\r\nha->host_no, __func__));\r\nreturn;\r\n}\r\nif (ha->fw_heartbeat_counter == fw_heartbeat_counter) {\r\nha->seconds_since_last_heartbeat++;\r\nif (ha->seconds_since_last_heartbeat == 2) {\r\nha->seconds_since_last_heartbeat = 0;\r\nhalt_status = qla4_8xxx_rd_32(ha,\r\nQLA82XX_PEG_HALT_STATUS1);\r\nql4_printk(KERN_INFO, ha,\r\n"scsi(%ld): %s, Dumping hw/fw registers:\n "\r\n" PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2:"\r\n" 0x%x,\n PEG_NET_0_PC: 0x%x, PEG_NET_1_PC:"\r\n" 0x%x,\n PEG_NET_2_PC: 0x%x, PEG_NET_3_PC:"\r\n" 0x%x,\n PEG_NET_4_PC: 0x%x\n",\r\nha->host_no, __func__, halt_status,\r\nqla4_8xxx_rd_32(ha,\r\nQLA82XX_PEG_HALT_STATUS2),\r\nqla4_8xxx_rd_32(ha, QLA82XX_CRB_PEG_NET_0 +\r\n0x3c),\r\nqla4_8xxx_rd_32(ha, QLA82XX_CRB_PEG_NET_1 +\r\n0x3c),\r\nqla4_8xxx_rd_32(ha, QLA82XX_CRB_PEG_NET_2 +\r\n0x3c),\r\nqla4_8xxx_rd_32(ha, QLA82XX_CRB_PEG_NET_3 +\r\n0x3c),\r\nqla4_8xxx_rd_32(ha, QLA82XX_CRB_PEG_NET_4 +\r\n0x3c));\r\nif (halt_status & HALT_STATUS_UNRECOVERABLE)\r\nset_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);\r\nelse {\r\nprintk("scsi%ld: %s: detect abort needed!\n",\r\nha->host_no, __func__);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\nqla4xxx_wake_dpc(ha);\r\nqla4xxx_mailbox_premature_completion(ha);\r\n}\r\n} else\r\nha->seconds_since_last_heartbeat = 0;\r\nha->fw_heartbeat_counter = fw_heartbeat_counter;\r\n}\r\nvoid qla4_8xxx_watchdog(struct scsi_qla_host *ha)\r\n{\r\nuint32_t dev_state;\r\ndev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nif (!(test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags))) {\r\nif (dev_state == QLA82XX_DEV_NEED_RESET &&\r\n!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nif (!ql4xdontresethba) {\r\nql4_printk(KERN_INFO, ha, "%s: HW State: "\r\n"NEED RESET!\n", __func__);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nqla4xxx_wake_dpc(ha);\r\nqla4xxx_mailbox_premature_completion(ha);\r\n}\r\n} else if (dev_state == QLA82XX_DEV_NEED_QUIESCENT &&\r\n!test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {\r\nql4_printk(KERN_INFO, ha, "%s: HW State: NEED QUIES!\n",\r\n__func__);\r\nset_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags);\r\nqla4xxx_wake_dpc(ha);\r\n} else {\r\nqla4_8xxx_check_fw_alive(ha);\r\n}\r\n}\r\n}\r\nstatic void qla4xxx_timer(struct scsi_qla_host *ha)\r\n{\r\nstruct ddb_entry *ddb_entry, *dtemp;\r\nint start_dpc = 0;\r\nuint16_t w;\r\nif (test_bit(AF_EEH_BUSY, &ha->flags)) {\r\nmod_timer(&ha->timer, jiffies + HZ);\r\nreturn;\r\n}\r\nif (!pci_channel_offline(ha->pdev))\r\npci_read_config_word(ha->pdev, PCI_VENDOR_ID, &w);\r\nif (is_qla8022(ha)) {\r\nqla4_8xxx_watchdog(ha);\r\n}\r\nlist_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list) {\r\nif (adapter_up(ha) &&\r\n!test_bit(DF_RELOGIN, &ddb_entry->flags) &&\r\natomic_read(&ddb_entry->state) != DDB_STATE_ONLINE) {\r\nif (atomic_read(&ddb_entry->retry_relogin_timer) !=\r\nINVALID_ENTRY) {\r\nif (atomic_read(&ddb_entry->retry_relogin_timer)\r\n== 0) {\r\natomic_set(&ddb_entry->\r\nretry_relogin_timer,\r\nINVALID_ENTRY);\r\nset_bit(DPC_RELOGIN_DEVICE,\r\n&ha->dpc_flags);\r\nset_bit(DF_RELOGIN, &ddb_entry->flags);\r\nDEBUG2(printk("scsi%ld: %s: ddb [%d]"\r\n" login device\n",\r\nha->host_no, __func__,\r\nddb_entry->fw_ddb_index));\r\n} else\r\natomic_dec(&ddb_entry->\r\nretry_relogin_timer);\r\n}\r\n}\r\nif (atomic_read(&ddb_entry->relogin_timer) &&\r\n(atomic_dec_and_test(&ddb_entry->relogin_timer) != 0)) {\r\nif (atomic_read(&ddb_entry->state) !=\r\nDDB_STATE_ONLINE &&\r\nddb_entry->fw_ddb_device_state ==\r\nDDB_DS_SESSION_FAILED) {\r\natomic_inc(&ddb_entry->relogin_retry_count);\r\nDEBUG2(printk("scsi%ld: ddb [%d] relogin"\r\n" timed out-retrying"\r\n" relogin (%d)\n",\r\nha->host_no,\r\nddb_entry->fw_ddb_index,\r\natomic_read(&ddb_entry->\r\nrelogin_retry_count))\r\n);\r\nstart_dpc++;\r\nDEBUG(printk("scsi%ld:%d:%d: ddb [%d] "\r\n"initiate relogin after"\r\n" %d seconds\n",\r\nha->host_no, ddb_entry->bus,\r\nddb_entry->target,\r\nddb_entry->fw_ddb_index,\r\nddb_entry->default_time2wait + 4)\r\n);\r\natomic_set(&ddb_entry->retry_relogin_timer,\r\nddb_entry->default_time2wait + 4);\r\n}\r\n}\r\n}\r\nif (!is_qla8022(ha)) {\r\nif (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE &&\r\nha->heartbeat_interval != 0) {\r\nha->seconds_since_last_heartbeat++;\r\nif (ha->seconds_since_last_heartbeat >\r\nha->heartbeat_interval + 2)\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\n}\r\nif (start_dpc ||\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\r\ntest_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags) ||\r\ntest_bit(DPC_LINK_CHANGED, &ha->dpc_flags) ||\r\ntest_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||\r\ntest_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||\r\ntest_bit(DPC_AEN, &ha->dpc_flags)) {\r\nDEBUG2(printk("scsi%ld: %s: scheduling dpc routine"\r\n" - dpc flags = 0x%lx\n",\r\nha->host_no, __func__, ha->dpc_flags));\r\nqla4xxx_wake_dpc(ha);\r\n}\r\nmod_timer(&ha->timer, jiffies + HZ);\r\nDEBUG2(ha->seconds_since_last_intr++);\r\n}\r\nstatic int qla4xxx_cmd_wait(struct scsi_qla_host *ha)\r\n{\r\nuint32_t index = 0;\r\nunsigned long flags;\r\nstruct scsi_cmnd *cmd;\r\nunsigned long wtime = jiffies + (WAIT_CMD_TOV * HZ);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Wait up to %d seconds for cmds to "\r\n"complete\n", WAIT_CMD_TOV));\r\nwhile (!time_after_eq(jiffies, wtime)) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (index = 0; index < ha->host->can_queue; index++) {\r\ncmd = scsi_host_find_tag(ha->host, index);\r\nif (cmd != NULL && CMD_SP(cmd))\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (index == ha->host->can_queue)\r\nreturn QLA_SUCCESS;\r\nmsleep(1000);\r\n}\r\nreturn QLA_ERROR;\r\n}\r\nint qla4xxx_hw_reset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t ctrl_status;\r\nunsigned long flags = 0;\r\nDEBUG2(printk(KERN_ERR "scsi%ld: %s\n", ha->host_no, __func__));\r\nif (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)\r\nreturn QLA_ERROR;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nif ((ctrl_status & CSR_SCSI_RESET_INTR) != 0)\r\nwritel(set_rmask(CSR_SCSI_RESET_INTR), &ha->reg->ctrl_status);\r\nwritel(set_rmask(CSR_SOFT_RESET), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_soft_reset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t max_wait_time;\r\nunsigned long flags = 0;\r\nint status;\r\nuint32_t ctrl_status;\r\nstatus = qla4xxx_hw_reset(ha);\r\nif (status != QLA_SUCCESS)\r\nreturn status;\r\nstatus = QLA_ERROR;\r\nmax_wait_time = RESET_INTR_TOV;\r\ndo {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif ((ctrl_status & CSR_NET_RESET_INTR) == 0)\r\nbreak;\r\nmsleep(1000);\r\n} while ((--max_wait_time));\r\nif ((ctrl_status & CSR_NET_RESET_INTR) != 0) {\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: Network Reset Intr not cleared by "\r\n"Network function, clearing it now!\n",\r\nha->host_no));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel(set_rmask(CSR_NET_RESET_INTR), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nmax_wait_time = SOFT_RESET_TOV;\r\ndo {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif ((ctrl_status & CSR_SOFT_RESET) == 0) {\r\nstatus = QLA_SUCCESS;\r\nbreak;\r\n}\r\nmsleep(1000);\r\n} while ((--max_wait_time));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nif ((ctrl_status & CSR_SCSI_RESET_INTR) != 0) {\r\nwritel(set_rmask(CSR_SCSI_RESET_INTR), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (max_wait_time == 0) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwritel(set_rmask(CSR_FORCE_SOFT_RESET), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmax_wait_time = SOFT_RESET_TOV;\r\ndo {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nctrl_status = readw(&ha->reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif ((ctrl_status & CSR_FORCE_SOFT_RESET) == 0) {\r\nstatus = QLA_SUCCESS;\r\nbreak;\r\n}\r\nmsleep(1000);\r\n} while ((--max_wait_time));\r\n}\r\nreturn status;\r\n}\r\nstatic void qla4xxx_abort_active_cmds(struct scsi_qla_host *ha, int res)\r\n{\r\nstruct srb *srb;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (i = 0; i < ha->host->can_queue; i++) {\r\nsrb = qla4xxx_del_from_active_array(ha, i);\r\nif (srb != NULL) {\r\nsrb->cmd->result = res;\r\nkref_put(&srb->srb_ref, qla4xxx_srb_compl);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nvoid qla4xxx_dead_adapter_cleanup(struct scsi_qla_host *ha)\r\n{\r\nclear_bit(AF_ONLINE, &ha->flags);\r\nql4_printk(KERN_INFO, ha, "Disabling the board\n");\r\nqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\r\nqla4xxx_mark_all_devices_missing(ha);\r\nclear_bit(AF_INIT_DONE, &ha->flags);\r\n}\r\nstatic int qla4xxx_recover_adapter(struct scsi_qla_host *ha)\r\n{\r\nint status = QLA_ERROR;\r\nuint8_t reset_chip = 0;\r\nscsi_block_requests(ha->host);\r\nclear_bit(AF_ONLINE, &ha->flags);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: adapter OFFLINE\n", __func__));\r\nset_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\r\nif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\r\nreset_chip = 1;\r\nif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\r\nstatus = QLA_SUCCESS;\r\ngoto recover_ha_init_adapter;\r\n}\r\nif (is_qla8022(ha) && !reset_chip &&\r\ntest_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s - Performing stop_firmware...\n",\r\nha->host_no, __func__));\r\nstatus = ha->isp_ops->reset_firmware(ha);\r\nif (status == QLA_SUCCESS) {\r\nif (!test_bit(AF_FW_RECOVERY, &ha->flags))\r\nqla4xxx_cmd_wait(ha);\r\nha->isp_ops->disable_intrs(ha);\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\r\n} else {\r\nreset_chip = 1;\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\n}\r\nif (!is_qla8022(ha) || reset_chip) {\r\nif (!test_bit(AF_FW_RECOVERY, &ha->flags))\r\nqla4xxx_cmd_wait(ha);\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s - Performing chip reset..\n",\r\nha->host_no, __func__));\r\nstatus = ha->isp_ops->reset_chip(ha);\r\n}\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nrecover_ha_init_adapter:\r\nif (status == QLA_SUCCESS) {\r\nif (!is_qla8022(ha) && (ha->mac_index == 3))\r\nssleep(6);\r\nstatus = qla4xxx_initialize_adapter(ha, PRESERVE_DDB_LIST);\r\n}\r\nif (!test_bit(AF_ONLINE, &ha->flags) &&\r\n!test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\r\nif (!test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags)) {\r\nha->retry_reset_ha_cnt = MAX_RESET_HA_RETRIES;\r\nDEBUG2(printk("scsi%ld: recover adapter - retrying "\r\n"(%d) more times\n", ha->host_no,\r\nha->retry_reset_ha_cnt));\r\nset_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\r\nstatus = QLA_ERROR;\r\n} else {\r\nif (ha->retry_reset_ha_cnt > 0) {\r\nha->retry_reset_ha_cnt--;\r\nDEBUG2(printk("scsi%ld: recover adapter - "\r\n"retry remaining %d\n",\r\nha->host_no,\r\nha->retry_reset_ha_cnt));\r\nstatus = QLA_ERROR;\r\n}\r\nif (ha->retry_reset_ha_cnt == 0) {\r\nDEBUG2(printk("scsi%ld: recover adapter "\r\n"failed - board disabled\n",\r\nha->host_no));\r\nqla4xxx_dead_adapter_cleanup(ha);\r\nclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT,\r\n&ha->dpc_flags);\r\nstatus = QLA_ERROR;\r\n}\r\n}\r\n} else {\r\nclear_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\nclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\r\n}\r\nha->adapter_error_count++;\r\nif (test_bit(AF_ONLINE, &ha->flags))\r\nha->isp_ops->enable_intrs(ha);\r\nscsi_unblock_requests(ha->host);\r\nclear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\r\nDEBUG2(printk("scsi%ld: recover adapter: %s\n", ha->host_no,\r\nstatus == QLA_ERROR ? "FAILED" : "SUCCEEDED"));\r\nreturn status;\r\n}\r\nstatic void qla4xxx_relogin_all_devices(struct scsi_qla_host *ha)\r\n{\r\nstruct ddb_entry *ddb_entry, *dtemp;\r\nlist_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list) {\r\nif ((atomic_read(&ddb_entry->state) == DDB_STATE_MISSING) ||\r\n(atomic_read(&ddb_entry->state) == DDB_STATE_DEAD)) {\r\nif (ddb_entry->fw_ddb_device_state ==\r\nDDB_DS_SESSION_ACTIVE) {\r\natomic_set(&ddb_entry->state, DDB_STATE_ONLINE);\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: ddb[%d]"\r\n" marked ONLINE\n", ha->host_no, __func__,\r\nddb_entry->fw_ddb_index);\r\niscsi_unblock_session(ddb_entry->sess);\r\n} else\r\nqla4xxx_relogin_device(ha, ddb_entry);\r\n}\r\n}\r\n}\r\nvoid qla4xxx_wake_dpc(struct scsi_qla_host *ha)\r\n{\r\nif (ha->dpc_thread)\r\nqueue_work(ha->dpc_thread, &ha->dpc_work);\r\n}\r\nstatic void qla4xxx_do_dpc(struct work_struct *work)\r\n{\r\nstruct scsi_qla_host *ha =\r\ncontainer_of(work, struct scsi_qla_host, dpc_work);\r\nstruct ddb_entry *ddb_entry, *dtemp;\r\nint status = QLA_ERROR;\r\nDEBUG2(printk("scsi%ld: %s: DPC handler waking up."\r\n"flags = 0x%08lx, dpc_flags = 0x%08lx\n",\r\nha->host_no, __func__, ha->flags, ha->dpc_flags))\r\nif (!test_bit(AF_INIT_DONE, &ha->flags))\r\nreturn;\r\nif (test_bit(AF_EEH_BUSY, &ha->flags)) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: flags = %lx\n",\r\nha->host_no, __func__, ha->flags));\r\nreturn;\r\n}\r\nif (is_qla8022(ha)) {\r\nif (test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags)) {\r\nqla4_8xxx_idc_lock(ha);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_FAILED);\r\nqla4_8xxx_idc_unlock(ha);\r\nql4_printk(KERN_INFO, ha, "HW State: FAILED\n");\r\nqla4_8xxx_device_state_handler(ha);\r\n}\r\nif (test_and_clear_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {\r\nqla4_8xxx_need_qsnt_handler(ha);\r\n}\r\n}\r\nif (!test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) &&\r\n(test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))) {\r\nif (ql4xdontresethba) {\r\nDEBUG2(printk("scsi%ld: %s: Don't Reset HBA\n",\r\nha->host_no, __func__));\r\nclear_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\r\nclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\ngoto dpc_post_reset_ha;\r\n}\r\nif (test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\r\ntest_bit(DPC_RESET_HA, &ha->dpc_flags))\r\nqla4xxx_recover_adapter(ha);\r\nif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\r\nuint8_t wait_time = RESET_INTR_TOV;\r\nwhile ((readw(&ha->reg->ctrl_status) &\r\n(CSR_SOFT_RESET | CSR_FORCE_SOFT_RESET)) != 0) {\r\nif (--wait_time == 0)\r\nbreak;\r\nmsleep(1000);\r\n}\r\nif (wait_time == 0)\r\nDEBUG2(printk("scsi%ld: %s: SR|FSR "\r\n"bit not cleared-- resetting\n",\r\nha->host_no, __func__));\r\nqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\r\nif (ql4xxx_lock_drvr_wait(ha) == QLA_SUCCESS) {\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\nstatus = qla4xxx_recover_adapter(ha);\r\n}\r\nclear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\r\nif (status == QLA_SUCCESS)\r\nha->isp_ops->enable_intrs(ha);\r\n}\r\n}\r\ndpc_post_reset_ha:\r\nif (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))\r\nqla4xxx_process_aen(ha, PROCESS_ALL_AENS);\r\nif (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))\r\nqla4xxx_get_dhcp_ip_address(ha);\r\nif (test_and_clear_bit(DPC_LINK_CHANGED, &ha->dpc_flags)) {\r\nif (!test_bit(AF_LINK_UP, &ha->flags)) {\r\nqla4xxx_mark_all_devices_missing(ha);\r\n} else {\r\nqla4xxx_relogin_all_devices(ha);\r\n}\r\n}\r\nif (adapter_up(ha) &&\r\ntest_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {\r\nlist_for_each_entry_safe(ddb_entry, dtemp,\r\n&ha->ddb_list, list) {\r\nif (test_and_clear_bit(DF_RELOGIN, &ddb_entry->flags) &&\r\natomic_read(&ddb_entry->state) != DDB_STATE_ONLINE)\r\nqla4xxx_relogin_device(ha, ddb_entry);\r\nif (test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nprintk(KERN_WARNING "scsi%ld: %s: "\r\n"need to reset hba\n",\r\nha->host_no, __func__);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void qla4xxx_free_adapter(struct scsi_qla_host *ha)\r\n{\r\nif (test_bit(AF_INTERRUPTS_ON, &ha->flags)) {\r\nha->isp_ops->disable_intrs(ha);\r\n}\r\nif (ha->timer_active)\r\nqla4xxx_stop_timer(ha);\r\nif (ha->dpc_thread)\r\ndestroy_workqueue(ha->dpc_thread);\r\nha->isp_ops->reset_firmware(ha);\r\nif (is_qla8022(ha)) {\r\nqla4_8xxx_idc_lock(ha);\r\nqla4_8xxx_clear_drv_active(ha);\r\nqla4_8xxx_idc_unlock(ha);\r\n}\r\nif (test_and_clear_bit(AF_IRQ_ATTACHED, &ha->flags))\r\nqla4xxx_free_irqs(ha);\r\nqla4xxx_mem_free(ha);\r\n}\r\nint qla4_8xxx_iospace_config(struct scsi_qla_host *ha)\r\n{\r\nint status = 0;\r\nuint8_t revision_id;\r\nunsigned long mem_base, mem_len, db_base, db_len;\r\nstruct pci_dev *pdev = ha->pdev;\r\nstatus = pci_request_regions(pdev, DRIVER_NAME);\r\nif (status) {\r\nprintk(KERN_WARNING\r\n"scsi(%ld) Failed to reserve PIO regions (%s) "\r\n"status=%d\n", ha->host_no, pci_name(pdev), status);\r\ngoto iospace_error_exit;\r\n}\r\npci_read_config_byte(pdev, PCI_REVISION_ID, &revision_id);\r\nDEBUG2(printk(KERN_INFO "%s: revision-id=%d\n",\r\n__func__, revision_id));\r\nha->revision_id = revision_id;\r\nmem_base = pci_resource_start(pdev, 0);\r\nmem_len = pci_resource_len(pdev, 0);\r\nDEBUG2(printk(KERN_INFO "%s: ioremap from %lx a size of %lx\n",\r\n__func__, mem_base, mem_len));\r\nha->nx_pcibase = (unsigned long)ioremap(mem_base, mem_len);\r\nif (!ha->nx_pcibase) {\r\nprintk(KERN_ERR\r\n"cannot remap MMIO (%s), aborting\n", pci_name(pdev));\r\npci_release_regions(ha->pdev);\r\ngoto iospace_error_exit;\r\n}\r\nha->qla4_8xxx_reg =\r\n(struct device_reg_82xx __iomem *)((uint8_t *)ha->nx_pcibase +\r\n0xbc000 + (ha->pdev->devfn << 11));\r\ndb_base = pci_resource_start(pdev, 4);\r\ndb_len = pci_resource_len(pdev, 4);\r\nha->nx_db_wr_ptr = (ha->pdev->devfn == 4 ? QLA82XX_CAM_RAM_DB1 :\r\nQLA82XX_CAM_RAM_DB2);\r\nreturn 0;\r\niospace_error_exit:\r\nreturn -ENOMEM;\r\n}\r\nint qla4xxx_iospace_config(struct scsi_qla_host *ha)\r\n{\r\nunsigned long pio, pio_len, pio_flags;\r\nunsigned long mmio, mmio_len, mmio_flags;\r\npio = pci_resource_start(ha->pdev, 0);\r\npio_len = pci_resource_len(ha->pdev, 0);\r\npio_flags = pci_resource_flags(ha->pdev, 0);\r\nif (pio_flags & IORESOURCE_IO) {\r\nif (pio_len < MIN_IOBASE_LEN) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Invalid PCI I/O region size\n");\r\npio = 0;\r\n}\r\n} else {\r\nql4_printk(KERN_WARNING, ha, "region #0 not a PIO resource\n");\r\npio = 0;\r\n}\r\nmmio = pci_resource_start(ha->pdev, 1);\r\nmmio_len = pci_resource_len(ha->pdev, 1);\r\nmmio_flags = pci_resource_flags(ha->pdev, 1);\r\nif (!(mmio_flags & IORESOURCE_MEM)) {\r\nql4_printk(KERN_ERR, ha,\r\n"region #0 not an MMIO resource, aborting\n");\r\ngoto iospace_error_exit;\r\n}\r\nif (mmio_len < MIN_IOBASE_LEN) {\r\nql4_printk(KERN_ERR, ha,\r\n"Invalid PCI mem region size, aborting\n");\r\ngoto iospace_error_exit;\r\n}\r\nif (pci_request_regions(ha->pdev, DRIVER_NAME)) {\r\nql4_printk(KERN_WARNING, ha,\r\n"Failed to reserve PIO/MMIO regions\n");\r\ngoto iospace_error_exit;\r\n}\r\nha->pio_address = pio;\r\nha->pio_length = pio_len;\r\nha->reg = ioremap(mmio, MIN_IOBASE_LEN);\r\nif (!ha->reg) {\r\nql4_printk(KERN_ERR, ha,\r\n"cannot remap MMIO, aborting\n");\r\ngoto iospace_error_exit;\r\n}\r\nreturn 0;\r\niospace_error_exit:\r\nreturn -ENOMEM;\r\n}\r\nuint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)\r\n{\r\nreturn (uint16_t)le32_to_cpu(ha->shadow_regs->req_q_out);\r\n}\r\nuint16_t qla4_8xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)\r\n{\r\nreturn (uint16_t)le32_to_cpu(readl(&ha->qla4_8xxx_reg->req_q_out));\r\n}\r\nuint16_t qla4xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)\r\n{\r\nreturn (uint16_t)le32_to_cpu(ha->shadow_regs->rsp_q_in);\r\n}\r\nuint16_t qla4_8xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)\r\n{\r\nreturn (uint16_t)le32_to_cpu(readl(&ha->qla4_8xxx_reg->rsp_q_in));\r\n}\r\nstatic int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret = -ENODEV, status;\r\nstruct Scsi_Host *host;\r\nstruct scsi_qla_host *ha;\r\nuint8_t init_retry_count = 0;\r\nchar buf[34];\r\nstruct qla4_8xxx_legacy_intr_set *nx_legacy_intr;\r\nuint32_t dev_state;\r\nif (pci_enable_device(pdev))\r\nreturn -1;\r\nhost = scsi_host_alloc(&qla4xxx_driver_template, sizeof(*ha));\r\nif (host == NULL) {\r\nprintk(KERN_WARNING\r\n"qla4xxx: Couldn't allocate host from scsi layer!\n");\r\ngoto probe_disable_device;\r\n}\r\nha = (struct scsi_qla_host *) host->hostdata;\r\nmemset(ha, 0, sizeof(*ha));\r\nha->pdev = pdev;\r\nha->host = host;\r\nha->host_no = host->host_no;\r\npci_enable_pcie_error_reporting(pdev);\r\nif (is_qla8022(ha)) {\r\nha->isp_ops = &qla4_8xxx_isp_ops;\r\nrwlock_init(&ha->hw_lock);\r\nha->qdr_sn_window = -1;\r\nha->ddr_mn_window = -1;\r\nha->curr_window = 255;\r\nha->func_num = PCI_FUNC(ha->pdev->devfn);\r\nnx_legacy_intr = &legacy_intr[ha->func_num];\r\nha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;\r\nha->nx_legacy_intr.tgt_status_reg =\r\nnx_legacy_intr->tgt_status_reg;\r\nha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;\r\nha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;\r\n} else {\r\nha->isp_ops = &qla4xxx_isp_ops;\r\n}\r\nif (is_qla8022(ha))\r\npdev->needs_freset = 1;\r\nret = ha->isp_ops->iospace_config(ha);\r\nif (ret)\r\ngoto probe_failed_ioconfig;\r\nql4_printk(KERN_INFO, ha, "Found an ISP%04x, irq %d, iobase 0x%p\n",\r\npdev->device, pdev->irq, ha->reg);\r\nqla4xxx_config_dma_addressing(ha);\r\nINIT_LIST_HEAD(&ha->ddb_list);\r\nINIT_LIST_HEAD(&ha->free_srb_q);\r\nmutex_init(&ha->mbox_sem);\r\ninit_completion(&ha->mbx_intr_comp);\r\nspin_lock_init(&ha->hardware_lock);\r\nif (qla4xxx_mem_alloc(ha)) {\r\nql4_printk(KERN_WARNING, ha,\r\n"[ERROR] Failed to allocate memory for adapter\n");\r\nret = -ENOMEM;\r\ngoto probe_failed;\r\n}\r\nif (is_qla8022(ha))\r\n(void) qla4_8xxx_get_flash_info(ha);\r\nstatus = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);\r\nwhile ((!test_bit(AF_ONLINE, &ha->flags)) &&\r\ninit_retry_count++ < MAX_INIT_RETRIES) {\r\nif (is_qla8022(ha)) {\r\nqla4_8xxx_idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nqla4_8xxx_idc_unlock(ha);\r\nif (dev_state == QLA82XX_DEV_FAILED) {\r\nql4_printk(KERN_WARNING, ha, "%s: don't retry "\r\n"initialize adapter. H/W is in failed state\n",\r\n__func__);\r\nbreak;\r\n}\r\n}\r\nDEBUG2(printk("scsi: %s: retrying adapter initialization "\r\n"(%d)\n", __func__, init_retry_count));\r\nif (ha->isp_ops->reset_chip(ha) == QLA_ERROR)\r\ncontinue;\r\nstatus = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);\r\n}\r\nif (!test_bit(AF_ONLINE, &ha->flags)) {\r\nql4_printk(KERN_WARNING, ha, "Failed to initialize adapter\n");\r\nif (is_qla8022(ha) && ql4xdontresethba) {\r\nDEBUG2(printk(KERN_ERR "HW STATE: FAILED\n"));\r\nqla4_8xxx_idc_lock(ha);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_FAILED);\r\nqla4_8xxx_idc_unlock(ha);\r\n}\r\nret = -ENODEV;\r\ngoto probe_failed;\r\n}\r\nhost->cmd_per_lun = 3;\r\nhost->max_channel = 0;\r\nhost->max_lun = MAX_LUNS - 1;\r\nhost->max_id = MAX_TARGETS;\r\nhost->max_cmd_len = IOCB_MAX_CDB_LEN;\r\nhost->can_queue = MAX_SRBS ;\r\nhost->transportt = qla4xxx_scsi_transport;\r\nret = scsi_init_shared_tag_map(host, MAX_SRBS);\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha,\r\n"scsi_init_shared_tag_map failed\n");\r\ngoto probe_failed;\r\n}\r\nDEBUG2(printk("scsi: %s: Starting kernel thread for "\r\n"qla4xxx_dpc\n", __func__));\r\nsprintf(buf, "qla4xxx_%lu_dpc", ha->host_no);\r\nha->dpc_thread = create_singlethread_workqueue(buf);\r\nif (!ha->dpc_thread) {\r\nql4_printk(KERN_WARNING, ha, "Unable to start DPC thread!\n");\r\nret = -ENODEV;\r\ngoto probe_failed;\r\n}\r\nINIT_WORK(&ha->dpc_work, qla4xxx_do_dpc);\r\nif (!is_qla8022(ha)) {\r\nret = qla4xxx_request_irqs(ha);\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha, "Failed to reserve "\r\n"interrupt %d already in use.\n", pdev->irq);\r\ngoto probe_failed;\r\n}\r\n}\r\npci_save_state(ha->pdev);\r\nha->isp_ops->enable_intrs(ha);\r\nqla4xxx_start_timer(ha, qla4xxx_timer, 1);\r\nset_bit(AF_INIT_DONE, &ha->flags);\r\npci_set_drvdata(pdev, ha);\r\nret = scsi_add_host(host, &pdev->dev);\r\nif (ret)\r\ngoto probe_failed;\r\nprintk(KERN_INFO\r\n" QLogic iSCSI HBA Driver version: %s\n"\r\n" QLogic ISP%04x @ %s, host#=%ld, fw=%02d.%02d.%02d.%02d\n",\r\nqla4xxx_version_str, ha->pdev->device, pci_name(ha->pdev),\r\nha->host_no, ha->firmware_version[0], ha->firmware_version[1],\r\nha->patch_number, ha->build_number);\r\nscsi_scan_host(host);\r\nreturn 0;\r\nprobe_failed:\r\nqla4xxx_free_adapter(ha);\r\nprobe_failed_ioconfig:\r\npci_disable_pcie_error_reporting(pdev);\r\nscsi_host_put(ha->host);\r\nprobe_disable_device:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void qla4xxx_prevent_other_port_reinit(struct scsi_qla_host *ha)\r\n{\r\nstruct scsi_qla_host *other_ha = NULL;\r\nstruct pci_dev *other_pdev = NULL;\r\nint fn = ISP4XXX_PCI_FN_2;\r\nif (PCI_FUNC(ha->pdev->devfn) & BIT_1)\r\nfn = ISP4XXX_PCI_FN_1;\r\nother_pdev =\r\npci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),\r\nha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),\r\nfn));\r\nif (other_pdev) {\r\nif (atomic_read(&other_pdev->enable_cnt)) {\r\nother_ha = pci_get_drvdata(other_pdev);\r\nif (other_ha) {\r\nset_bit(AF_HA_REMOVAL, &other_ha->flags);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: "\r\n"Prevent %s reinit\n", __func__,\r\ndev_name(&other_ha->pdev->dev)));\r\n}\r\n}\r\npci_dev_put(other_pdev);\r\n}\r\n}\r\nstatic void __devexit qla4xxx_remove_adapter(struct pci_dev *pdev)\r\n{\r\nstruct scsi_qla_host *ha;\r\nha = pci_get_drvdata(pdev);\r\nif (!is_qla8022(ha))\r\nqla4xxx_prevent_other_port_reinit(ha);\r\nqla4xxx_free_ddb_list(ha);\r\nscsi_remove_host(ha->host);\r\nqla4xxx_free_adapter(ha);\r\nscsi_host_put(ha->host);\r\npci_disable_pcie_error_reporting(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic void qla4xxx_config_dma_addressing(struct scsi_qla_host *ha)\r\n{\r\nint retval;\r\nif (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(64)) == 0) {\r\nif (pci_set_consistent_dma_mask(ha->pdev, DMA_BIT_MASK(64))) {\r\ndev_dbg(&ha->pdev->dev,\r\n"Failed to set 64 bit PCI consistent mask; "\r\n"using 32 bit.\n");\r\nretval = pci_set_consistent_dma_mask(ha->pdev,\r\nDMA_BIT_MASK(32));\r\n}\r\n} else\r\nretval = pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32));\r\n}\r\nstatic int qla4xxx_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct iscsi_cls_session *sess = starget_to_session(sdev->sdev_target);\r\nstruct ddb_entry *ddb = sess->dd_data;\r\nint queue_depth = QL4_DEF_QDEPTH;\r\nsdev->hostdata = ddb;\r\nsdev->tagged_supported = 1;\r\nif (ql4xmaxqdepth != 0 && ql4xmaxqdepth <= 0xffffU)\r\nqueue_depth = ql4xmaxqdepth;\r\nscsi_activate_tcq(sdev, queue_depth);\r\nreturn 0;\r\n}\r\nstatic int qla4xxx_slave_configure(struct scsi_device *sdev)\r\n{\r\nsdev->tagged_supported = 1;\r\nreturn 0;\r\n}\r\nstatic void qla4xxx_slave_destroy(struct scsi_device *sdev)\r\n{\r\nscsi_deactivate_tcq(sdev, 1);\r\n}\r\nstruct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha,\r\nuint32_t index)\r\n{\r\nstruct srb *srb = NULL;\r\nstruct scsi_cmnd *cmd = NULL;\r\ncmd = scsi_host_find_tag(ha->host, index);\r\nif (!cmd)\r\nreturn srb;\r\nsrb = (struct srb *)CMD_SP(cmd);\r\nif (!srb)\r\nreturn srb;\r\nif (srb->flags & SRB_DMA_VALID) {\r\nha->req_q_count += srb->iocb_cnt;\r\nha->iocb_cnt -= srb->iocb_cnt;\r\nif (srb->cmd)\r\nsrb->cmd->host_scribble =\r\n(unsigned char *)(unsigned long) MAX_SRBS;\r\n}\r\nreturn srb;\r\n}\r\nstatic int qla4xxx_eh_wait_on_command(struct scsi_qla_host *ha,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nint done = 0;\r\nstruct srb *rp;\r\nuint32_t max_wait_time = EH_WAIT_CMD_TOV;\r\nint ret = SUCCESS;\r\nif (unlikely(pci_channel_offline(ha->pdev)) ||\r\n(test_bit(AF_EEH_BUSY, &ha->flags))) {\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: Return from %s\n",\r\nha->host_no, __func__);\r\nreturn ret;\r\n}\r\ndo {\r\nrp = (struct srb *) CMD_SP(cmd);\r\nif (rp == NULL) {\r\ndone++;\r\nbreak;\r\n}\r\nmsleep(2000);\r\n} while (max_wait_time--);\r\nreturn done;\r\n}\r\nstatic int qla4xxx_wait_for_hba_online(struct scsi_qla_host *ha)\r\n{\r\nunsigned long wait_online;\r\nwait_online = jiffies + (HBA_ONLINE_TOV * HZ);\r\nwhile (time_before(jiffies, wait_online)) {\r\nif (adapter_up(ha))\r\nreturn QLA_SUCCESS;\r\nmsleep(2000);\r\n}\r\nreturn QLA_ERROR;\r\n}\r\nstatic int qla4xxx_eh_wait_for_commands(struct scsi_qla_host *ha,\r\nstruct scsi_target *stgt,\r\nstruct scsi_device *sdev)\r\n{\r\nint cnt;\r\nint status = 0;\r\nstruct scsi_cmnd *cmd;\r\nfor (cnt = 0; cnt < ha->host->can_queue; cnt++) {\r\ncmd = scsi_host_find_tag(ha->host, cnt);\r\nif (cmd && stgt == scsi_target(cmd->device) &&\r\n(!sdev || sdev == cmd->device)) {\r\nif (!qla4xxx_eh_wait_on_command(ha, cmd)) {\r\nstatus++;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int qla4xxx_eh_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\r\nunsigned int id = cmd->device->id;\r\nunsigned int lun = cmd->device->lun;\r\nunsigned long flags;\r\nstruct srb *srb = NULL;\r\nint ret = SUCCESS;\r\nint wait = 0;\r\nql4_printk(KERN_INFO, ha,\r\n"scsi%ld:%d:%d: Abort command issued cmd=%p\n",\r\nha->host_no, id, lun, cmd);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nsrb = (struct srb *) CMD_SP(cmd);\r\nif (!srb) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nkref_get(&srb->srb_ref);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (qla4xxx_abort_task(ha, srb) != QLA_SUCCESS) {\r\nDEBUG3(printk("scsi%ld:%d:%d: Abort_task mbx failed.\n",\r\nha->host_no, id, lun));\r\nret = FAILED;\r\n} else {\r\nDEBUG3(printk("scsi%ld:%d:%d: Abort_task mbx success.\n",\r\nha->host_no, id, lun));\r\nwait = 1;\r\n}\r\nkref_put(&srb->srb_ref, qla4xxx_srb_compl);\r\nif (wait) {\r\nif (!qla4xxx_eh_wait_on_command(ha, cmd)) {\r\nDEBUG2(printk("scsi%ld:%d:%d: Abort handler timed out\n",\r\nha->host_no, id, lun));\r\nret = FAILED;\r\n}\r\n}\r\nql4_printk(KERN_INFO, ha,\r\n"scsi%ld:%d:%d: Abort command - %s\n",\r\nha->host_no, id, lun, (ret == SUCCESS) ? "succeeded" : "failed");\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\r\nstruct ddb_entry *ddb_entry = cmd->device->hostdata;\r\nint ret = FAILED, stat;\r\nif (!ddb_entry)\r\nreturn ret;\r\nret = iscsi_block_scsi_eh(cmd);\r\nif (ret)\r\nreturn ret;\r\nret = FAILED;\r\nql4_printk(KERN_INFO, ha,\r\n"scsi%ld:%d:%d:%d: DEVICE RESET ISSUED.\n", ha->host_no,\r\ncmd->device->channel, cmd->device->id, cmd->device->lun);\r\nDEBUG2(printk(KERN_INFO\r\n"scsi%ld: DEVICE_RESET cmd=%p jiffies = 0x%lx, to=%x,"\r\n"dpc_flags=%lx, status=%x allowed=%d\n", ha->host_no,\r\ncmd, jiffies, cmd->request->timeout / HZ,\r\nha->dpc_flags, cmd->result, cmd->allowed));\r\nstat = qla4xxx_reset_lun(ha, ddb_entry, cmd->device->lun);\r\nif (stat != QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "DEVICE RESET FAILED. %d\n", stat);\r\ngoto eh_dev_reset_done;\r\n}\r\nif (qla4xxx_eh_wait_for_commands(ha, scsi_target(cmd->device),\r\ncmd->device)) {\r\nql4_printk(KERN_INFO, ha,\r\n"DEVICE RESET FAILED - waiting for "\r\n"commands.\n");\r\ngoto eh_dev_reset_done;\r\n}\r\nif (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun,\r\nMM_LUN_RESET) != QLA_SUCCESS)\r\ngoto eh_dev_reset_done;\r\nql4_printk(KERN_INFO, ha,\r\n"scsi(%ld:%d:%d:%d): DEVICE RESET SUCCEEDED.\n",\r\nha->host_no, cmd->device->channel, cmd->device->id,\r\ncmd->device->lun);\r\nret = SUCCESS;\r\neh_dev_reset_done:\r\nreturn ret;\r\n}\r\nstatic int qla4xxx_eh_target_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\r\nstruct ddb_entry *ddb_entry = cmd->device->hostdata;\r\nint stat, ret;\r\nif (!ddb_entry)\r\nreturn FAILED;\r\nret = iscsi_block_scsi_eh(cmd);\r\nif (ret)\r\nreturn ret;\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET RESET ISSUED.\n");\r\nDEBUG2(printk(KERN_INFO\r\n"scsi%ld: TARGET_DEVICE_RESET cmd=%p jiffies = 0x%lx, "\r\n"to=%x,dpc_flags=%lx, status=%x allowed=%d\n",\r\nha->host_no, cmd, jiffies, cmd->request->timeout / HZ,\r\nha->dpc_flags, cmd->result, cmd->allowed));\r\nstat = qla4xxx_reset_target(ha, ddb_entry);\r\nif (stat != QLA_SUCCESS) {\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET RESET FAILED.\n");\r\nreturn FAILED;\r\n}\r\nif (qla4xxx_eh_wait_for_commands(ha, scsi_target(cmd->device),\r\nNULL)) {\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET DEVICE RESET FAILED - "\r\n"waiting for commands.\n");\r\nreturn FAILED;\r\n}\r\nif (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun,\r\nMM_TGT_WARM_RESET) != QLA_SUCCESS) {\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET DEVICE RESET FAILED - "\r\n"marker iocb failed.\n");\r\nreturn FAILED;\r\n}\r\nstarget_printk(KERN_INFO, scsi_target(cmd->device),\r\n"WARM TARGET RESET SUCCEEDED.\n");\r\nreturn SUCCESS;\r\n}\r\nstatic int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)\r\n{\r\nint return_status = FAILED;\r\nstruct scsi_qla_host *ha;\r\nha = (struct scsi_qla_host *) cmd->device->host->hostdata;\r\nif (ql4xdontresethba) {\r\nDEBUG2(printk("scsi%ld: %s: Don't Reset HBA\n",\r\nha->host_no, __func__));\r\nreturn FAILED;\r\n}\r\nql4_printk(KERN_INFO, ha,\r\n"scsi(%ld:%d:%d:%d): HOST RESET ISSUED.\n", ha->host_no,\r\ncmd->device->channel, cmd->device->id, cmd->device->lun);\r\nif (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld:%d: %s: Unable to reset host. Adapter "\r\n"DEAD.\n", ha->host_no, cmd->device->channel,\r\n__func__));\r\nreturn FAILED;\r\n}\r\nif (!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nif (is_qla8022(ha))\r\nset_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\nelse\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\nif (qla4xxx_recover_adapter(ha) == QLA_SUCCESS)\r\nreturn_status = SUCCESS;\r\nql4_printk(KERN_INFO, ha, "HOST RESET %s.\n",\r\nreturn_status == FAILED ? "FAILED" : "SUCCEEDED");\r\nreturn return_status;\r\n}\r\nstatic pci_ers_result_t\r\nqla4xxx_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\r\n{\r\nstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: error detected:state %x\n",\r\nha->host_no, __func__, state);\r\nif (!is_aer_supported(ha))\r\nreturn PCI_ERS_RESULT_NONE;\r\nswitch (state) {\r\ncase pci_channel_io_normal:\r\nclear_bit(AF_EEH_BUSY, &ha->flags);\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\ncase pci_channel_io_frozen:\r\nset_bit(AF_EEH_BUSY, &ha->flags);\r\nqla4xxx_mailbox_premature_completion(ha);\r\nqla4xxx_free_irqs(ha);\r\npci_disable_device(pdev);\r\nqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\ncase pci_channel_io_perm_failure:\r\nset_bit(AF_EEH_BUSY, &ha->flags);\r\nset_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags);\r\nqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t\r\nqla4xxx_pci_mmio_enabled(struct pci_dev *pdev)\r\n{\r\nstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\r\nif (!is_aer_supported(ha))\r\nreturn PCI_ERS_RESULT_NONE;\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic uint32_t qla4_8xxx_error_recovery(struct scsi_qla_host *ha)\r\n{\r\nuint32_t rval = QLA_ERROR;\r\nuint32_t ret = 0;\r\nint fn;\r\nstruct pci_dev *other_pdev = NULL;\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: In %s\n", ha->host_no, __func__);\r\nset_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\r\nif (test_bit(AF_ONLINE, &ha->flags)) {\r\nclear_bit(AF_ONLINE, &ha->flags);\r\nqla4xxx_mark_all_devices_missing(ha);\r\nqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\r\n}\r\nfn = PCI_FUNC(ha->pdev->devfn);\r\nwhile (fn > 0) {\r\nfn--;\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: Finding PCI device at "\r\n"func %x\n", ha->host_no, __func__, fn);\r\nother_pdev =\r\npci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),\r\nha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),\r\nfn));\r\nif (!other_pdev)\r\ncontinue;\r\nif (atomic_read(&other_pdev->enable_cnt)) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: Found PCI "\r\n"func in enabled state%x\n", ha->host_no,\r\n__func__, fn);\r\npci_dev_put(other_pdev);\r\nbreak;\r\n}\r\npci_dev_put(other_pdev);\r\n}\r\nif (!fn) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: devfn being reset "\r\n"0x%x is the owner\n", ha->host_no, __func__,\r\nha->pdev->devfn);\r\nqla4_8xxx_idc_lock(ha);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_COLD);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_IDC_VERSION,\r\nQLA82XX_IDC_VERSION);\r\nqla4_8xxx_idc_unlock(ha);\r\nclear_bit(AF_FW_RECOVERY, &ha->flags);\r\nrval = qla4xxx_initialize_adapter(ha, PRESERVE_DDB_LIST);\r\nqla4_8xxx_idc_lock(ha);\r\nif (rval != QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: HW State: "\r\n"FAILED\n", ha->host_no, __func__);\r\nqla4_8xxx_clear_drv_active(ha);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_FAILED);\r\n} else {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: HW State: "\r\n"READY\n", ha->host_no, __func__);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_READY);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, 0);\r\nqla4_8xxx_set_drv_active(ha);\r\nret = qla4xxx_request_irqs(ha);\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha, "Failed to "\r\n"reserve interrupt %d already in use.\n",\r\nha->pdev->irq);\r\nrval = QLA_ERROR;\r\n} else {\r\nha->isp_ops->enable_intrs(ha);\r\nrval = QLA_SUCCESS;\r\n}\r\n}\r\nqla4_8xxx_idc_unlock(ha);\r\n} else {\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: devfn 0x%x is not "\r\n"the reset owner\n", ha->host_no, __func__,\r\nha->pdev->devfn);\r\nif ((qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE) ==\r\nQLA82XX_DEV_READY)) {\r\nclear_bit(AF_FW_RECOVERY, &ha->flags);\r\nrval = qla4xxx_initialize_adapter(ha,\r\nPRESERVE_DDB_LIST);\r\nif (rval == QLA_SUCCESS) {\r\nret = qla4xxx_request_irqs(ha);\r\nif (ret) {\r\nql4_printk(KERN_WARNING, ha, "Failed to"\r\n" reserve interrupt %d already in"\r\n" use.\n", ha->pdev->irq);\r\nrval = QLA_ERROR;\r\n} else {\r\nha->isp_ops->enable_intrs(ha);\r\nrval = QLA_SUCCESS;\r\n}\r\n}\r\nqla4_8xxx_idc_lock(ha);\r\nqla4_8xxx_set_drv_active(ha);\r\nqla4_8xxx_idc_unlock(ha);\r\n}\r\n}\r\nclear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\r\nreturn rval;\r\n}\r\nstatic pci_ers_result_t\r\nqla4xxx_pci_slot_reset(struct pci_dev *pdev)\r\n{\r\npci_ers_result_t ret = PCI_ERS_RESULT_DISCONNECT;\r\nstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\r\nint rc;\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: slot_reset\n",\r\nha->host_no, __func__);\r\nif (!is_aer_supported(ha))\r\nreturn PCI_ERS_RESULT_NONE;\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: Can't re-enable "\r\n"device after reset\n", ha->host_no, __func__);\r\ngoto exit_slot_reset;\r\n}\r\nha->isp_ops->disable_intrs(ha);\r\nif (is_qla8022(ha)) {\r\nif (qla4_8xxx_error_recovery(ha) == QLA_SUCCESS) {\r\nret = PCI_ERS_RESULT_RECOVERED;\r\ngoto exit_slot_reset;\r\n} else\r\ngoto exit_slot_reset;\r\n}\r\nexit_slot_reset:\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: Return=%x\n"\r\n"device after reset\n", ha->host_no, __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void\r\nqla4xxx_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\r\nint ret;\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: pci_resume\n",\r\nha->host_no, __func__);\r\nret = qla4xxx_wait_for_hba_online(ha);\r\nif (ret != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "scsi%ld: %s: the device failed to "\r\n"resume I/O from slot/link_reset\n", ha->host_no,\r\n__func__);\r\n}\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\nclear_bit(AF_EEH_BUSY, &ha->flags);\r\n}\r\nstatic int __init qla4xxx_module_init(void)\r\n{\r\nint ret;\r\nsrb_cachep = kmem_cache_create("qla4xxx_srbs", sizeof(struct srb), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (srb_cachep == NULL) {\r\nprintk(KERN_ERR\r\n"%s: Unable to allocate SRB cache..."\r\n"Failing load!\n", DRIVER_NAME);\r\nret = -ENOMEM;\r\ngoto no_srp_cache;\r\n}\r\nstrcpy(qla4xxx_version_str, QLA4XXX_DRIVER_VERSION);\r\nif (ql4xextended_error_logging)\r\nstrcat(qla4xxx_version_str, "-debug");\r\nqla4xxx_scsi_transport =\r\niscsi_register_transport(&qla4xxx_iscsi_transport);\r\nif (!qla4xxx_scsi_transport){\r\nret = -ENODEV;\r\ngoto release_srb_cache;\r\n}\r\nret = pci_register_driver(&qla4xxx_pci_driver);\r\nif (ret)\r\ngoto unregister_transport;\r\nprintk(KERN_INFO "QLogic iSCSI HBA Driver\n");\r\nreturn 0;\r\nunregister_transport:\r\niscsi_unregister_transport(&qla4xxx_iscsi_transport);\r\nrelease_srb_cache:\r\nkmem_cache_destroy(srb_cachep);\r\nno_srp_cache:\r\nreturn ret;\r\n}\r\nstatic void __exit qla4xxx_module_exit(void)\r\n{\r\npci_unregister_driver(&qla4xxx_pci_driver);\r\niscsi_unregister_transport(&qla4xxx_iscsi_transport);\r\nkmem_cache_destroy(srb_cachep);\r\n}
