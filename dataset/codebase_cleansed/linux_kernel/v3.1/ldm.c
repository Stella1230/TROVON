static void _ldm_printk (const char *level, const char *function,\r\nconst char *fmt, ...)\r\n{\r\nstatic char buf[128];\r\nva_list args;\r\nva_start (args, fmt);\r\nvsnprintf (buf, sizeof (buf), fmt, args);\r\nva_end (args);\r\nprintk ("%s%s(): %s\n", level, function, buf);\r\n}\r\nstatic int ldm_parse_hexbyte (const u8 *src)\r\n{\r\nunsigned int x;\r\nint h;\r\nx = h = hex_to_bin(src[0]);\r\nif (h < 0)\r\nreturn -1;\r\nh = hex_to_bin(src[1]);\r\nif (h < 0)\r\nreturn -1;\r\nreturn (x << 4) + h;\r\n}\r\nstatic bool ldm_parse_guid (const u8 *src, u8 *dest)\r\n{\r\nstatic const int size[] = { 4, 2, 2, 2, 6 };\r\nint i, j, v;\r\nif (src[8] != '-' || src[13] != '-' ||\r\nsrc[18] != '-' || src[23] != '-')\r\nreturn false;\r\nfor (j = 0; j < 5; j++, src++)\r\nfor (i = 0; i < size[j]; i++, src+=2, *dest++ = v)\r\nif ((v = ldm_parse_hexbyte (src)) < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_privhead(const u8 *data, struct privhead *ph)\r\n{\r\nbool is_vista = false;\r\nBUG_ON(!data || !ph);\r\nif (MAGIC_PRIVHEAD != get_unaligned_be64(data)) {\r\nldm_error("Cannot find PRIVHEAD structure. LDM database is"\r\n" corrupt. Aborting.");\r\nreturn false;\r\n}\r\nph->ver_major = get_unaligned_be16(data + 0x000C);\r\nph->ver_minor = get_unaligned_be16(data + 0x000E);\r\nph->logical_disk_start = get_unaligned_be64(data + 0x011B);\r\nph->logical_disk_size = get_unaligned_be64(data + 0x0123);\r\nph->config_start = get_unaligned_be64(data + 0x012B);\r\nph->config_size = get_unaligned_be64(data + 0x0133);\r\nif (ph->ver_major == 2 && ph->ver_minor == 12)\r\nis_vista = true;\r\nif (!is_vista && (ph->ver_major != 2 || ph->ver_minor != 11)) {\r\nldm_error("Expected PRIVHEAD version 2.11 or 2.12, got %d.%d."\r\n" Aborting.", ph->ver_major, ph->ver_minor);\r\nreturn false;\r\n}\r\nldm_debug("PRIVHEAD version %d.%d (Windows %s).", ph->ver_major,\r\nph->ver_minor, is_vista ? "Vista" : "2000/XP");\r\nif (ph->config_size != LDM_DB_SIZE) {\r\nldm_info("Database is normally %u bytes, it claims to "\r\n"be %llu bytes.", LDM_DB_SIZE,\r\n(unsigned long long)ph->config_size);\r\n}\r\nif ((ph->logical_disk_size == 0) || (ph->logical_disk_start +\r\nph->logical_disk_size > ph->config_start)) {\r\nldm_error("PRIVHEAD disk size doesn't match real disk size");\r\nreturn false;\r\n}\r\nif (!ldm_parse_guid(data + 0x0030, ph->disk_id)) {\r\nldm_error("PRIVHEAD contains an invalid GUID.");\r\nreturn false;\r\n}\r\nldm_debug("Parsed PRIVHEAD successfully.");\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_tocblock (const u8 *data, struct tocblock *toc)\r\n{\r\nBUG_ON (!data || !toc);\r\nif (MAGIC_TOCBLOCK != get_unaligned_be64(data)) {\r\nldm_crit ("Cannot find TOCBLOCK, database may be corrupt.");\r\nreturn false;\r\n}\r\nstrncpy (toc->bitmap1_name, data + 0x24, sizeof (toc->bitmap1_name));\r\ntoc->bitmap1_name[sizeof (toc->bitmap1_name) - 1] = 0;\r\ntoc->bitmap1_start = get_unaligned_be64(data + 0x2E);\r\ntoc->bitmap1_size = get_unaligned_be64(data + 0x36);\r\nif (strncmp (toc->bitmap1_name, TOC_BITMAP1,\r\nsizeof (toc->bitmap1_name)) != 0) {\r\nldm_crit ("TOCBLOCK's first bitmap is '%s', should be '%s'.",\r\nTOC_BITMAP1, toc->bitmap1_name);\r\nreturn false;\r\n}\r\nstrncpy (toc->bitmap2_name, data + 0x46, sizeof (toc->bitmap2_name));\r\ntoc->bitmap2_name[sizeof (toc->bitmap2_name) - 1] = 0;\r\ntoc->bitmap2_start = get_unaligned_be64(data + 0x50);\r\ntoc->bitmap2_size = get_unaligned_be64(data + 0x58);\r\nif (strncmp (toc->bitmap2_name, TOC_BITMAP2,\r\nsizeof (toc->bitmap2_name)) != 0) {\r\nldm_crit ("TOCBLOCK's second bitmap is '%s', should be '%s'.",\r\nTOC_BITMAP2, toc->bitmap2_name);\r\nreturn false;\r\n}\r\nldm_debug ("Parsed TOCBLOCK successfully.");\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_vmdb (const u8 *data, struct vmdb *vm)\r\n{\r\nBUG_ON (!data || !vm);\r\nif (MAGIC_VMDB != get_unaligned_be32(data)) {\r\nldm_crit ("Cannot find the VMDB, database may be corrupt.");\r\nreturn false;\r\n}\r\nvm->ver_major = get_unaligned_be16(data + 0x12);\r\nvm->ver_minor = get_unaligned_be16(data + 0x14);\r\nif ((vm->ver_major != 4) || (vm->ver_minor != 10)) {\r\nldm_error ("Expected VMDB version %d.%d, got %d.%d. "\r\n"Aborting.", 4, 10, vm->ver_major, vm->ver_minor);\r\nreturn false;\r\n}\r\nvm->vblk_size = get_unaligned_be32(data + 0x08);\r\nif (vm->vblk_size == 0) {\r\nldm_error ("Illegal VBLK size");\r\nreturn false;\r\n}\r\nvm->vblk_offset = get_unaligned_be32(data + 0x0C);\r\nvm->last_vblk_seq = get_unaligned_be32(data + 0x04);\r\nldm_debug ("Parsed VMDB successfully.");\r\nreturn true;\r\n}\r\nstatic bool ldm_compare_privheads (const struct privhead *ph1,\r\nconst struct privhead *ph2)\r\n{\r\nBUG_ON (!ph1 || !ph2);\r\nreturn ((ph1->ver_major == ph2->ver_major) &&\r\n(ph1->ver_minor == ph2->ver_minor) &&\r\n(ph1->logical_disk_start == ph2->logical_disk_start) &&\r\n(ph1->logical_disk_size == ph2->logical_disk_size) &&\r\n(ph1->config_start == ph2->config_start) &&\r\n(ph1->config_size == ph2->config_size) &&\r\n!memcmp (ph1->disk_id, ph2->disk_id, GUID_SIZE));\r\n}\r\nstatic bool ldm_compare_tocblocks (const struct tocblock *toc1,\r\nconst struct tocblock *toc2)\r\n{\r\nBUG_ON (!toc1 || !toc2);\r\nreturn ((toc1->bitmap1_start == toc2->bitmap1_start) &&\r\n(toc1->bitmap1_size == toc2->bitmap1_size) &&\r\n(toc1->bitmap2_start == toc2->bitmap2_start) &&\r\n(toc1->bitmap2_size == toc2->bitmap2_size) &&\r\n!strncmp (toc1->bitmap1_name, toc2->bitmap1_name,\r\nsizeof (toc1->bitmap1_name)) &&\r\n!strncmp (toc1->bitmap2_name, toc2->bitmap2_name,\r\nsizeof (toc1->bitmap2_name)));\r\n}\r\nstatic bool ldm_validate_privheads(struct parsed_partitions *state,\r\nstruct privhead *ph1)\r\n{\r\nstatic const int off[3] = { OFF_PRIV1, OFF_PRIV2, OFF_PRIV3 };\r\nstruct privhead *ph[3] = { ph1 };\r\nSector sect;\r\nu8 *data;\r\nbool result = false;\r\nlong num_sects;\r\nint i;\r\nBUG_ON (!state || !ph1);\r\nph[1] = kmalloc (sizeof (*ph[1]), GFP_KERNEL);\r\nph[2] = kmalloc (sizeof (*ph[2]), GFP_KERNEL);\r\nif (!ph[1] || !ph[2]) {\r\nldm_crit ("Out of memory.");\r\ngoto out;\r\n}\r\nph[0]->config_start = 0;\r\nfor (i = 0; i < 3; i++) {\r\ndata = read_part_sector(state, ph[0]->config_start + off[i],\r\n&sect);\r\nif (!data) {\r\nldm_crit ("Disk read failed.");\r\ngoto out;\r\n}\r\nresult = ldm_parse_privhead (data, ph[i]);\r\nput_dev_sector (sect);\r\nif (!result) {\r\nldm_error ("Cannot find PRIVHEAD %d.", i+1);\r\nif (i < 2)\r\ngoto out;\r\nelse\r\nbreak;\r\n}\r\n}\r\nnum_sects = state->bdev->bd_inode->i_size >> 9;\r\nif ((ph[0]->config_start > num_sects) ||\r\n((ph[0]->config_start + ph[0]->config_size) > num_sects)) {\r\nldm_crit ("Database extends beyond the end of the disk.");\r\ngoto out;\r\n}\r\nif ((ph[0]->logical_disk_start > ph[0]->config_start) ||\r\n((ph[0]->logical_disk_start + ph[0]->logical_disk_size)\r\n> ph[0]->config_start)) {\r\nldm_crit ("Disk and database overlap.");\r\ngoto out;\r\n}\r\nif (!ldm_compare_privheads (ph[0], ph[1])) {\r\nldm_crit ("Primary and backup PRIVHEADs don't match.");\r\ngoto out;\r\n}\r\nldm_debug ("Validated PRIVHEADs successfully.");\r\nresult = true;\r\nout:\r\nkfree (ph[1]);\r\nkfree (ph[2]);\r\nreturn result;\r\n}\r\nstatic bool ldm_validate_tocblocks(struct parsed_partitions *state,\r\nunsigned long base, struct ldmdb *ldb)\r\n{\r\nstatic const int off[4] = { OFF_TOCB1, OFF_TOCB2, OFF_TOCB3, OFF_TOCB4};\r\nstruct tocblock *tb[4];\r\nstruct privhead *ph;\r\nSector sect;\r\nu8 *data;\r\nint i, nr_tbs;\r\nbool result = false;\r\nBUG_ON(!state || !ldb);\r\nph = &ldb->ph;\r\ntb[0] = &ldb->toc;\r\ntb[1] = kmalloc(sizeof(*tb[1]) * 3, GFP_KERNEL);\r\nif (!tb[1]) {\r\nldm_crit("Out of memory.");\r\ngoto err;\r\n}\r\ntb[2] = (struct tocblock*)((u8*)tb[1] + sizeof(*tb[1]));\r\ntb[3] = (struct tocblock*)((u8*)tb[2] + sizeof(*tb[2]));\r\nfor (nr_tbs = i = 0; i < 4; i++) {\r\ndata = read_part_sector(state, base + off[i], &sect);\r\nif (!data) {\r\nldm_error("Disk read failed for TOCBLOCK %d.", i);\r\ncontinue;\r\n}\r\nif (ldm_parse_tocblock(data, tb[nr_tbs]))\r\nnr_tbs++;\r\nput_dev_sector(sect);\r\n}\r\nif (!nr_tbs) {\r\nldm_crit("Failed to find a valid TOCBLOCK.");\r\ngoto err;\r\n}\r\nif (((tb[0]->bitmap1_start + tb[0]->bitmap1_size) > ph->config_size) ||\r\n((tb[0]->bitmap2_start + tb[0]->bitmap2_size) >\r\nph->config_size)) {\r\nldm_crit("The bitmaps are out of range. Giving up.");\r\ngoto err;\r\n}\r\nfor (i = 1; i < nr_tbs; i++) {\r\nif (!ldm_compare_tocblocks(tb[0], tb[i])) {\r\nldm_crit("TOCBLOCKs 0 and %d do not match.", i);\r\ngoto err;\r\n}\r\n}\r\nldm_debug("Validated %d TOCBLOCKs successfully.", nr_tbs);\r\nresult = true;\r\nerr:\r\nkfree(tb[1]);\r\nreturn result;\r\n}\r\nstatic bool ldm_validate_vmdb(struct parsed_partitions *state,\r\nunsigned long base, struct ldmdb *ldb)\r\n{\r\nSector sect;\r\nu8 *data;\r\nbool result = false;\r\nstruct vmdb *vm;\r\nstruct tocblock *toc;\r\nBUG_ON (!state || !ldb);\r\nvm = &ldb->vm;\r\ntoc = &ldb->toc;\r\ndata = read_part_sector(state, base + OFF_VMDB, &sect);\r\nif (!data) {\r\nldm_crit ("Disk read failed.");\r\nreturn false;\r\n}\r\nif (!ldm_parse_vmdb (data, vm))\r\ngoto out;\r\nif (get_unaligned_be16(data + 0x10) != 0x01) {\r\nldm_crit ("Database is not in a consistent state. Aborting.");\r\ngoto out;\r\n}\r\nif (vm->vblk_offset != 512)\r\nldm_info ("VBLKs start at offset 0x%04x.", vm->vblk_offset);\r\nif ((vm->vblk_size * vm->last_vblk_seq) > (toc->bitmap1_size << 9)) {\r\nldm_crit ("VMDB exceeds allowed size specified by TOCBLOCK. "\r\n"Database is corrupt. Aborting.");\r\ngoto out;\r\n}\r\nresult = true;\r\nout:\r\nput_dev_sector (sect);\r\nreturn result;\r\n}\r\nstatic bool ldm_validate_partition_table(struct parsed_partitions *state)\r\n{\r\nSector sect;\r\nu8 *data;\r\nstruct partition *p;\r\nint i;\r\nbool result = false;\r\nBUG_ON(!state);\r\ndata = read_part_sector(state, 0, &sect);\r\nif (!data) {\r\nldm_info ("Disk read failed.");\r\nreturn false;\r\n}\r\nif (*(__le16*) (data + 0x01FE) != cpu_to_le16 (MSDOS_LABEL_MAGIC))\r\ngoto out;\r\np = (struct partition*)(data + 0x01BE);\r\nfor (i = 0; i < 4; i++, p++)\r\nif (SYS_IND (p) == LDM_PARTITION) {\r\nresult = true;\r\nbreak;\r\n}\r\nif (result)\r\nldm_debug ("Found W2K dynamic disk partition type.");\r\nout:\r\nput_dev_sector (sect);\r\nreturn result;\r\n}\r\nstatic struct vblk * ldm_get_disk_objid (const struct ldmdb *ldb)\r\n{\r\nstruct list_head *item;\r\nBUG_ON (!ldb);\r\nlist_for_each (item, &ldb->v_disk) {\r\nstruct vblk *v = list_entry (item, struct vblk, list);\r\nif (!memcmp (v->vblk.disk.disk_id, ldb->ph.disk_id, GUID_SIZE))\r\nreturn v;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool ldm_create_data_partitions (struct parsed_partitions *pp,\r\nconst struct ldmdb *ldb)\r\n{\r\nstruct list_head *item;\r\nstruct vblk *vb;\r\nstruct vblk *disk;\r\nstruct vblk_part *part;\r\nint part_num = 1;\r\nBUG_ON (!pp || !ldb);\r\ndisk = ldm_get_disk_objid (ldb);\r\nif (!disk) {\r\nldm_crit ("Can't find the ID of this disk in the database.");\r\nreturn false;\r\n}\r\nstrlcat(pp->pp_buf, " [LDM]", PAGE_SIZE);\r\nlist_for_each (item, &ldb->v_part) {\r\nvb = list_entry (item, struct vblk, list);\r\npart = &vb->vblk.part;\r\nif (part->disk_id != disk->obj_id)\r\ncontinue;\r\nput_partition (pp, part_num, ldb->ph.logical_disk_start +\r\npart->start, part->size);\r\npart_num++;\r\n}\r\nstrlcat(pp->pp_buf, "\n", PAGE_SIZE);\r\nreturn true;\r\n}\r\nstatic int ldm_relative(const u8 *buffer, int buflen, int base, int offset)\r\n{\r\nbase += offset;\r\nif (!buffer || offset < 0 || base > buflen) {\r\nif (!buffer)\r\nldm_error("!buffer");\r\nif (offset < 0)\r\nldm_error("offset (%d) < 0", offset);\r\nif (base > buflen)\r\nldm_error("base (%d) > buflen (%d)", base, buflen);\r\nreturn -1;\r\n}\r\nif (base + buffer[base] >= buflen) {\r\nldm_error("base (%d) + buffer[base] (%d) >= buflen (%d)", base,\r\nbuffer[base], buflen);\r\nreturn -1;\r\n}\r\nreturn buffer[base] + offset + 1;\r\n}\r\nstatic u64 ldm_get_vnum (const u8 *block)\r\n{\r\nu64 tmp = 0;\r\nu8 length;\r\nBUG_ON (!block);\r\nlength = *block++;\r\nif (length && length <= 8)\r\nwhile (length--)\r\ntmp = (tmp << 8) | *block++;\r\nelse\r\nldm_error ("Illegal length %d.", length);\r\nreturn tmp;\r\n}\r\nstatic int ldm_get_vstr (const u8 *block, u8 *buffer, int buflen)\r\n{\r\nint length;\r\nBUG_ON (!block || !buffer);\r\nlength = block[0];\r\nif (length >= buflen) {\r\nldm_error ("Truncating string %d -> %d.", length, buflen);\r\nlength = buflen - 1;\r\n}\r\nmemcpy (buffer, block + 1, length);\r\nbuffer[length] = 0;\r\nreturn length;\r\n}\r\nstatic bool ldm_parse_cmp3 (const u8 *buffer, int buflen, struct vblk *vb)\r\n{\r\nint r_objid, r_name, r_vstate, r_child, r_parent, r_stripe, r_cols, len;\r\nstruct vblk_comp *comp;\r\nBUG_ON (!buffer || !vb);\r\nr_objid = ldm_relative (buffer, buflen, 0x18, 0);\r\nr_name = ldm_relative (buffer, buflen, 0x18, r_objid);\r\nr_vstate = ldm_relative (buffer, buflen, 0x18, r_name);\r\nr_child = ldm_relative (buffer, buflen, 0x1D, r_vstate);\r\nr_parent = ldm_relative (buffer, buflen, 0x2D, r_child);\r\nif (buffer[0x12] & VBLK_FLAG_COMP_STRIPE) {\r\nr_stripe = ldm_relative (buffer, buflen, 0x2E, r_parent);\r\nr_cols = ldm_relative (buffer, buflen, 0x2E, r_stripe);\r\nlen = r_cols;\r\n} else {\r\nr_stripe = 0;\r\nr_cols = 0;\r\nlen = r_parent;\r\n}\r\nif (len < 0)\r\nreturn false;\r\nlen += VBLK_SIZE_CMP3;\r\nif (len != get_unaligned_be32(buffer + 0x14))\r\nreturn false;\r\ncomp = &vb->vblk.comp;\r\nldm_get_vstr (buffer + 0x18 + r_name, comp->state,\r\nsizeof (comp->state));\r\ncomp->type = buffer[0x18 + r_vstate];\r\ncomp->children = ldm_get_vnum (buffer + 0x1D + r_vstate);\r\ncomp->parent_id = ldm_get_vnum (buffer + 0x2D + r_child);\r\ncomp->chunksize = r_stripe ? ldm_get_vnum (buffer+r_parent+0x2E) : 0;\r\nreturn true;\r\n}\r\nstatic int ldm_parse_dgr3 (const u8 *buffer, int buflen, struct vblk *vb)\r\n{\r\nint r_objid, r_name, r_diskid, r_id1, r_id2, len;\r\nstruct vblk_dgrp *dgrp;\r\nBUG_ON (!buffer || !vb);\r\nr_objid = ldm_relative (buffer, buflen, 0x18, 0);\r\nr_name = ldm_relative (buffer, buflen, 0x18, r_objid);\r\nr_diskid = ldm_relative (buffer, buflen, 0x18, r_name);\r\nif (buffer[0x12] & VBLK_FLAG_DGR3_IDS) {\r\nr_id1 = ldm_relative (buffer, buflen, 0x24, r_diskid);\r\nr_id2 = ldm_relative (buffer, buflen, 0x24, r_id1);\r\nlen = r_id2;\r\n} else {\r\nr_id1 = 0;\r\nr_id2 = 0;\r\nlen = r_diskid;\r\n}\r\nif (len < 0)\r\nreturn false;\r\nlen += VBLK_SIZE_DGR3;\r\nif (len != get_unaligned_be32(buffer + 0x14))\r\nreturn false;\r\ndgrp = &vb->vblk.dgrp;\r\nldm_get_vstr (buffer + 0x18 + r_name, dgrp->disk_id,\r\nsizeof (dgrp->disk_id));\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_dgr4 (const u8 *buffer, int buflen, struct vblk *vb)\r\n{\r\nchar buf[64];\r\nint r_objid, r_name, r_id1, r_id2, len;\r\nstruct vblk_dgrp *dgrp;\r\nBUG_ON (!buffer || !vb);\r\nr_objid = ldm_relative (buffer, buflen, 0x18, 0);\r\nr_name = ldm_relative (buffer, buflen, 0x18, r_objid);\r\nif (buffer[0x12] & VBLK_FLAG_DGR4_IDS) {\r\nr_id1 = ldm_relative (buffer, buflen, 0x44, r_name);\r\nr_id2 = ldm_relative (buffer, buflen, 0x44, r_id1);\r\nlen = r_id2;\r\n} else {\r\nr_id1 = 0;\r\nr_id2 = 0;\r\nlen = r_name;\r\n}\r\nif (len < 0)\r\nreturn false;\r\nlen += VBLK_SIZE_DGR4;\r\nif (len != get_unaligned_be32(buffer + 0x14))\r\nreturn false;\r\ndgrp = &vb->vblk.dgrp;\r\nldm_get_vstr (buffer + 0x18 + r_objid, buf, sizeof (buf));\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_dsk3 (const u8 *buffer, int buflen, struct vblk *vb)\r\n{\r\nint r_objid, r_name, r_diskid, r_altname, len;\r\nstruct vblk_disk *disk;\r\nBUG_ON (!buffer || !vb);\r\nr_objid = ldm_relative (buffer, buflen, 0x18, 0);\r\nr_name = ldm_relative (buffer, buflen, 0x18, r_objid);\r\nr_diskid = ldm_relative (buffer, buflen, 0x18, r_name);\r\nr_altname = ldm_relative (buffer, buflen, 0x18, r_diskid);\r\nlen = r_altname;\r\nif (len < 0)\r\nreturn false;\r\nlen += VBLK_SIZE_DSK3;\r\nif (len != get_unaligned_be32(buffer + 0x14))\r\nreturn false;\r\ndisk = &vb->vblk.disk;\r\nldm_get_vstr (buffer + 0x18 + r_diskid, disk->alt_name,\r\nsizeof (disk->alt_name));\r\nif (!ldm_parse_guid (buffer + 0x19 + r_name, disk->disk_id))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_dsk4 (const u8 *buffer, int buflen, struct vblk *vb)\r\n{\r\nint r_objid, r_name, len;\r\nstruct vblk_disk *disk;\r\nBUG_ON (!buffer || !vb);\r\nr_objid = ldm_relative (buffer, buflen, 0x18, 0);\r\nr_name = ldm_relative (buffer, buflen, 0x18, r_objid);\r\nlen = r_name;\r\nif (len < 0)\r\nreturn false;\r\nlen += VBLK_SIZE_DSK4;\r\nif (len != get_unaligned_be32(buffer + 0x14))\r\nreturn false;\r\ndisk = &vb->vblk.disk;\r\nmemcpy (disk->disk_id, buffer + 0x18 + r_name, GUID_SIZE);\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_prt3(const u8 *buffer, int buflen, struct vblk *vb)\r\n{\r\nint r_objid, r_name, r_size, r_parent, r_diskid, r_index, len;\r\nstruct vblk_part *part;\r\nBUG_ON(!buffer || !vb);\r\nr_objid = ldm_relative(buffer, buflen, 0x18, 0);\r\nif (r_objid < 0) {\r\nldm_error("r_objid %d < 0", r_objid);\r\nreturn false;\r\n}\r\nr_name = ldm_relative(buffer, buflen, 0x18, r_objid);\r\nif (r_name < 0) {\r\nldm_error("r_name %d < 0", r_name);\r\nreturn false;\r\n}\r\nr_size = ldm_relative(buffer, buflen, 0x34, r_name);\r\nif (r_size < 0) {\r\nldm_error("r_size %d < 0", r_size);\r\nreturn false;\r\n}\r\nr_parent = ldm_relative(buffer, buflen, 0x34, r_size);\r\nif (r_parent < 0) {\r\nldm_error("r_parent %d < 0", r_parent);\r\nreturn false;\r\n}\r\nr_diskid = ldm_relative(buffer, buflen, 0x34, r_parent);\r\nif (r_diskid < 0) {\r\nldm_error("r_diskid %d < 0", r_diskid);\r\nreturn false;\r\n}\r\nif (buffer[0x12] & VBLK_FLAG_PART_INDEX) {\r\nr_index = ldm_relative(buffer, buflen, 0x34, r_diskid);\r\nif (r_index < 0) {\r\nldm_error("r_index %d < 0", r_index);\r\nreturn false;\r\n}\r\nlen = r_index;\r\n} else {\r\nr_index = 0;\r\nlen = r_diskid;\r\n}\r\nif (len < 0) {\r\nldm_error("len %d < 0", len);\r\nreturn false;\r\n}\r\nlen += VBLK_SIZE_PRT3;\r\nif (len > get_unaligned_be32(buffer + 0x14)) {\r\nldm_error("len %d > BE32(buffer + 0x14) %d", len,\r\nget_unaligned_be32(buffer + 0x14));\r\nreturn false;\r\n}\r\npart = &vb->vblk.part;\r\npart->start = get_unaligned_be64(buffer + 0x24 + r_name);\r\npart->volume_offset = get_unaligned_be64(buffer + 0x2C + r_name);\r\npart->size = ldm_get_vnum(buffer + 0x34 + r_name);\r\npart->parent_id = ldm_get_vnum(buffer + 0x34 + r_size);\r\npart->disk_id = ldm_get_vnum(buffer + 0x34 + r_parent);\r\nif (vb->flags & VBLK_FLAG_PART_INDEX)\r\npart->partnum = buffer[0x35 + r_diskid];\r\nelse\r\npart->partnum = 0;\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_vol5(const u8 *buffer, int buflen, struct vblk *vb)\r\n{\r\nint r_objid, r_name, r_vtype, r_disable_drive_letter, r_child, r_size;\r\nint r_id1, r_id2, r_size2, r_drive, len;\r\nstruct vblk_volu *volu;\r\nBUG_ON(!buffer || !vb);\r\nr_objid = ldm_relative(buffer, buflen, 0x18, 0);\r\nif (r_objid < 0) {\r\nldm_error("r_objid %d < 0", r_objid);\r\nreturn false;\r\n}\r\nr_name = ldm_relative(buffer, buflen, 0x18, r_objid);\r\nif (r_name < 0) {\r\nldm_error("r_name %d < 0", r_name);\r\nreturn false;\r\n}\r\nr_vtype = ldm_relative(buffer, buflen, 0x18, r_name);\r\nif (r_vtype < 0) {\r\nldm_error("r_vtype %d < 0", r_vtype);\r\nreturn false;\r\n}\r\nr_disable_drive_letter = ldm_relative(buffer, buflen, 0x18, r_vtype);\r\nif (r_disable_drive_letter < 0) {\r\nldm_error("r_disable_drive_letter %d < 0",\r\nr_disable_drive_letter);\r\nreturn false;\r\n}\r\nr_child = ldm_relative(buffer, buflen, 0x2D, r_disable_drive_letter);\r\nif (r_child < 0) {\r\nldm_error("r_child %d < 0", r_child);\r\nreturn false;\r\n}\r\nr_size = ldm_relative(buffer, buflen, 0x3D, r_child);\r\nif (r_size < 0) {\r\nldm_error("r_size %d < 0", r_size);\r\nreturn false;\r\n}\r\nif (buffer[0x12] & VBLK_FLAG_VOLU_ID1) {\r\nr_id1 = ldm_relative(buffer, buflen, 0x52, r_size);\r\nif (r_id1 < 0) {\r\nldm_error("r_id1 %d < 0", r_id1);\r\nreturn false;\r\n}\r\n} else\r\nr_id1 = r_size;\r\nif (buffer[0x12] & VBLK_FLAG_VOLU_ID2) {\r\nr_id2 = ldm_relative(buffer, buflen, 0x52, r_id1);\r\nif (r_id2 < 0) {\r\nldm_error("r_id2 %d < 0", r_id2);\r\nreturn false;\r\n}\r\n} else\r\nr_id2 = r_id1;\r\nif (buffer[0x12] & VBLK_FLAG_VOLU_SIZE) {\r\nr_size2 = ldm_relative(buffer, buflen, 0x52, r_id2);\r\nif (r_size2 < 0) {\r\nldm_error("r_size2 %d < 0", r_size2);\r\nreturn false;\r\n}\r\n} else\r\nr_size2 = r_id2;\r\nif (buffer[0x12] & VBLK_FLAG_VOLU_DRIVE) {\r\nr_drive = ldm_relative(buffer, buflen, 0x52, r_size2);\r\nif (r_drive < 0) {\r\nldm_error("r_drive %d < 0", r_drive);\r\nreturn false;\r\n}\r\n} else\r\nr_drive = r_size2;\r\nlen = r_drive;\r\nif (len < 0) {\r\nldm_error("len %d < 0", len);\r\nreturn false;\r\n}\r\nlen += VBLK_SIZE_VOL5;\r\nif (len > get_unaligned_be32(buffer + 0x14)) {\r\nldm_error("len %d > BE32(buffer + 0x14) %d", len,\r\nget_unaligned_be32(buffer + 0x14));\r\nreturn false;\r\n}\r\nvolu = &vb->vblk.volu;\r\nldm_get_vstr(buffer + 0x18 + r_name, volu->volume_type,\r\nsizeof(volu->volume_type));\r\nmemcpy(volu->volume_state, buffer + 0x18 + r_disable_drive_letter,\r\nsizeof(volu->volume_state));\r\nvolu->size = ldm_get_vnum(buffer + 0x3D + r_child);\r\nvolu->partition_type = buffer[0x41 + r_size];\r\nmemcpy(volu->guid, buffer + 0x42 + r_size, sizeof(volu->guid));\r\nif (buffer[0x12] & VBLK_FLAG_VOLU_DRIVE) {\r\nldm_get_vstr(buffer + 0x52 + r_size, volu->drive_hint,\r\nsizeof(volu->drive_hint));\r\n}\r\nreturn true;\r\n}\r\nstatic bool ldm_parse_vblk (const u8 *buf, int len, struct vblk *vb)\r\n{\r\nbool result = false;\r\nint r_objid;\r\nBUG_ON (!buf || !vb);\r\nr_objid = ldm_relative (buf, len, 0x18, 0);\r\nif (r_objid < 0) {\r\nldm_error ("VBLK header is corrupt.");\r\nreturn false;\r\n}\r\nvb->flags = buf[0x12];\r\nvb->type = buf[0x13];\r\nvb->obj_id = ldm_get_vnum (buf + 0x18);\r\nldm_get_vstr (buf+0x18+r_objid, vb->name, sizeof (vb->name));\r\nswitch (vb->type) {\r\ncase VBLK_CMP3: result = ldm_parse_cmp3 (buf, len, vb); break;\r\ncase VBLK_DSK3: result = ldm_parse_dsk3 (buf, len, vb); break;\r\ncase VBLK_DSK4: result = ldm_parse_dsk4 (buf, len, vb); break;\r\ncase VBLK_DGR3: result = ldm_parse_dgr3 (buf, len, vb); break;\r\ncase VBLK_DGR4: result = ldm_parse_dgr4 (buf, len, vb); break;\r\ncase VBLK_PRT3: result = ldm_parse_prt3 (buf, len, vb); break;\r\ncase VBLK_VOL5: result = ldm_parse_vol5 (buf, len, vb); break;\r\n}\r\nif (result)\r\nldm_debug ("Parsed VBLK 0x%llx (type: 0x%02x) ok.",\r\n(unsigned long long) vb->obj_id, vb->type);\r\nelse\r\nldm_error ("Failed to parse VBLK 0x%llx (type: 0x%02x).",\r\n(unsigned long long) vb->obj_id, vb->type);\r\nreturn result;\r\n}\r\nstatic bool ldm_ldmdb_add (u8 *data, int len, struct ldmdb *ldb)\r\n{\r\nstruct vblk *vb;\r\nstruct list_head *item;\r\nBUG_ON (!data || !ldb);\r\nvb = kmalloc (sizeof (*vb), GFP_KERNEL);\r\nif (!vb) {\r\nldm_crit ("Out of memory.");\r\nreturn false;\r\n}\r\nif (!ldm_parse_vblk (data, len, vb)) {\r\nkfree(vb);\r\nreturn false;\r\n}\r\nswitch (vb->type) {\r\ncase VBLK_DGR3:\r\ncase VBLK_DGR4:\r\nlist_add (&vb->list, &ldb->v_dgrp);\r\nbreak;\r\ncase VBLK_DSK3:\r\ncase VBLK_DSK4:\r\nlist_add (&vb->list, &ldb->v_disk);\r\nbreak;\r\ncase VBLK_VOL5:\r\nlist_add (&vb->list, &ldb->v_volu);\r\nbreak;\r\ncase VBLK_CMP3:\r\nlist_add (&vb->list, &ldb->v_comp);\r\nbreak;\r\ncase VBLK_PRT3:\r\nlist_for_each (item, &ldb->v_part) {\r\nstruct vblk *v = list_entry (item, struct vblk, list);\r\nif ((v->vblk.part.disk_id == vb->vblk.part.disk_id) &&\r\n(v->vblk.part.start > vb->vblk.part.start)) {\r\nlist_add_tail (&vb->list, &v->list);\r\nreturn true;\r\n}\r\n}\r\nlist_add_tail (&vb->list, &ldb->v_part);\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nstatic bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\r\n{\r\nstruct frag *f;\r\nstruct list_head *item;\r\nint rec, num, group;\r\nBUG_ON (!data || !frags);\r\nif (size < 2 * VBLK_SIZE_HEAD) {\r\nldm_error("Value of size is to small.");\r\nreturn false;\r\n}\r\ngroup = get_unaligned_be32(data + 0x08);\r\nrec = get_unaligned_be16(data + 0x0C);\r\nnum = get_unaligned_be16(data + 0x0E);\r\nif ((num < 1) || (num > 4)) {\r\nldm_error ("A VBLK claims to have %d parts.", num);\r\nreturn false;\r\n}\r\nif (rec >= num) {\r\nldm_error("REC value (%d) exceeds NUM value (%d)", rec, num);\r\nreturn false;\r\n}\r\nlist_for_each (item, frags) {\r\nf = list_entry (item, struct frag, list);\r\nif (f->group == group)\r\ngoto found;\r\n}\r\nf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\r\nif (!f) {\r\nldm_crit ("Out of memory.");\r\nreturn false;\r\n}\r\nf->group = group;\r\nf->num = num;\r\nf->rec = rec;\r\nf->map = 0xFF << num;\r\nlist_add_tail (&f->list, frags);\r\nfound:\r\nif (rec >= f->num) {\r\nldm_error("REC value (%d) exceeds NUM value (%d)", rec, f->num);\r\nreturn false;\r\n}\r\nif (f->map & (1 << rec)) {\r\nldm_error ("Duplicate VBLK, part %d.", rec);\r\nf->map &= 0x7F;\r\nreturn false;\r\n}\r\nf->map |= (1 << rec);\r\ndata += VBLK_SIZE_HEAD;\r\nsize -= VBLK_SIZE_HEAD;\r\nmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\r\nreturn true;\r\n}\r\nstatic void ldm_frag_free (struct list_head *list)\r\n{\r\nstruct list_head *item, *tmp;\r\nBUG_ON (!list);\r\nlist_for_each_safe (item, tmp, list)\r\nkfree (list_entry (item, struct frag, list));\r\n}\r\nstatic bool ldm_frag_commit (struct list_head *frags, struct ldmdb *ldb)\r\n{\r\nstruct frag *f;\r\nstruct list_head *item;\r\nBUG_ON (!frags || !ldb);\r\nlist_for_each (item, frags) {\r\nf = list_entry (item, struct frag, list);\r\nif (f->map != 0xFF) {\r\nldm_error ("VBLK group %d is incomplete (0x%02x).",\r\nf->group, f->map);\r\nreturn false;\r\n}\r\nif (!ldm_ldmdb_add (f->data, f->num*ldb->vm.vblk_size, ldb))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool ldm_get_vblks(struct parsed_partitions *state, unsigned long base,\r\nstruct ldmdb *ldb)\r\n{\r\nint size, perbuf, skip, finish, s, v, recs;\r\nu8 *data = NULL;\r\nSector sect;\r\nbool result = false;\r\nLIST_HEAD (frags);\r\nBUG_ON(!state || !ldb);\r\nsize = ldb->vm.vblk_size;\r\nperbuf = 512 / size;\r\nskip = ldb->vm.vblk_offset >> 9;\r\nfinish = (size * ldb->vm.last_vblk_seq) >> 9;\r\nfor (s = skip; s < finish; s++) {\r\ndata = read_part_sector(state, base + OFF_VMDB + s, &sect);\r\nif (!data) {\r\nldm_crit ("Disk read failed.");\r\ngoto out;\r\n}\r\nfor (v = 0; v < perbuf; v++, data+=size) {\r\nif (MAGIC_VBLK != get_unaligned_be32(data)) {\r\nldm_error ("Expected to find a VBLK.");\r\ngoto out;\r\n}\r\nrecs = get_unaligned_be16(data + 0x0E);\r\nif (recs == 1) {\r\nif (!ldm_ldmdb_add (data, size, ldb))\r\ngoto out;\r\n} else if (recs > 1) {\r\nif (!ldm_frag_add (data, size, &frags))\r\ngoto out;\r\n}\r\n}\r\nput_dev_sector (sect);\r\ndata = NULL;\r\n}\r\nresult = ldm_frag_commit (&frags, ldb);\r\nout:\r\nif (data)\r\nput_dev_sector (sect);\r\nldm_frag_free (&frags);\r\nreturn result;\r\n}\r\nstatic void ldm_free_vblks (struct list_head *lh)\r\n{\r\nstruct list_head *item, *tmp;\r\nBUG_ON (!lh);\r\nlist_for_each_safe (item, tmp, lh)\r\nkfree (list_entry (item, struct vblk, list));\r\n}\r\nint ldm_partition(struct parsed_partitions *state)\r\n{\r\nstruct ldmdb *ldb;\r\nunsigned long base;\r\nint result = -1;\r\nBUG_ON(!state);\r\nif (!ldm_validate_partition_table(state))\r\nreturn 0;\r\nldb = kmalloc (sizeof (*ldb), GFP_KERNEL);\r\nif (!ldb) {\r\nldm_crit ("Out of memory.");\r\ngoto out;\r\n}\r\nif (!ldm_validate_privheads(state, &ldb->ph))\r\ngoto out;\r\nbase = ldb->ph.config_start;\r\nif (!ldm_validate_tocblocks(state, base, ldb) ||\r\n!ldm_validate_vmdb(state, base, ldb))\r\ngoto out;\r\nINIT_LIST_HEAD (&ldb->v_dgrp);\r\nINIT_LIST_HEAD (&ldb->v_disk);\r\nINIT_LIST_HEAD (&ldb->v_volu);\r\nINIT_LIST_HEAD (&ldb->v_comp);\r\nINIT_LIST_HEAD (&ldb->v_part);\r\nif (!ldm_get_vblks(state, base, ldb)) {\r\nldm_crit ("Failed to read the VBLKs from the database.");\r\ngoto cleanup;\r\n}\r\nif (ldm_create_data_partitions(state, ldb)) {\r\nldm_debug ("Parsed LDM database successfully.");\r\nresult = 1;\r\n}\r\ncleanup:\r\nldm_free_vblks (&ldb->v_dgrp);\r\nldm_free_vblks (&ldb->v_disk);\r\nldm_free_vblks (&ldb->v_volu);\r\nldm_free_vblks (&ldb->v_comp);\r\nldm_free_vblks (&ldb->v_part);\r\nout:\r\nkfree (ldb);\r\nreturn result;\r\n}
