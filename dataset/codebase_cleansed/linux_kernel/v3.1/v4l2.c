static void erase_on(struct solo_dev *solo_dev)\r\n{\r\nsolo_reg_write(solo_dev, SOLO_VO_DISP_ERASE, SOLO_VO_DISP_ERASE_ON);\r\nsolo_dev->erasing = 1;\r\nsolo_dev->frame_blank = 0;\r\n}\r\nstatic int erase_off(struct solo_dev *solo_dev)\r\n{\r\nif (!solo_dev->erasing)\r\nreturn 0;\r\nif (!solo_dev->frame_blank)\r\nsolo_reg_write(solo_dev, SOLO_VO_DISP_ERASE, 0);\r\nif (solo_dev->frame_blank++ >= 8)\r\nsolo_dev->erasing = 0;\r\nreturn 1;\r\n}\r\nvoid solo_video_in_isr(struct solo_dev *solo_dev)\r\n{\r\nsolo_reg_write(solo_dev, SOLO_IRQ_STAT, SOLO_IRQ_VIDEO_IN);\r\nwake_up_interruptible(&solo_dev->disp_thread_wait);\r\n}\r\nstatic void solo_win_setup(struct solo_dev *solo_dev, u8 ch,\r\nint sx, int sy, int ex, int ey, int scale)\r\n{\r\nif (ch >= solo_dev->nr_chans)\r\nreturn;\r\nsolo_reg_write(solo_dev, SOLO_VI_WIN_CTRL0(ch),\r\nSOLO_VI_WIN_CHANNEL(ch) |\r\nSOLO_VI_WIN_SX(sx) |\r\nSOLO_VI_WIN_EX(ex) |\r\nSOLO_VI_WIN_SCALE(scale));\r\nsolo_reg_write(solo_dev, SOLO_VI_WIN_CTRL1(ch),\r\nSOLO_VI_WIN_SY(sy) |\r\nSOLO_VI_WIN_EY(ey));\r\n}\r\nstatic int solo_v4l2_ch_ext_4up(struct solo_dev *solo_dev, u8 idx, int on)\r\n{\r\nu8 ch = idx * 4;\r\nif (ch >= solo_dev->nr_chans)\r\nreturn -EINVAL;\r\nif (!on) {\r\nu8 i;\r\nfor (i = ch; i < ch + 4; i++)\r\nsolo_win_setup(solo_dev, i, solo_dev->video_hsize,\r\nsolo_vlines(solo_dev),\r\nsolo_dev->video_hsize,\r\nsolo_vlines(solo_dev), 0);\r\nreturn 0;\r\n}\r\nsolo_win_setup(solo_dev, ch, 0, 0, solo_dev->video_hsize / 2,\r\nsolo_vlines(solo_dev) / 2, 3);\r\nsolo_win_setup(solo_dev, ch + 1, solo_dev->video_hsize / 2, 0,\r\nsolo_dev->video_hsize, solo_vlines(solo_dev) / 2, 3);\r\nsolo_win_setup(solo_dev, ch + 2, 0, solo_vlines(solo_dev) / 2,\r\nsolo_dev->video_hsize / 2, solo_vlines(solo_dev), 3);\r\nsolo_win_setup(solo_dev, ch + 3, solo_dev->video_hsize / 2,\r\nsolo_vlines(solo_dev) / 2, solo_dev->video_hsize,\r\nsolo_vlines(solo_dev), 3);\r\nreturn 0;\r\n}\r\nstatic int solo_v4l2_ch_ext_16up(struct solo_dev *solo_dev, int on)\r\n{\r\nint sy, ysize, hsize, i;\r\nif (!on) {\r\nfor (i = 0; i < 16; i++)\r\nsolo_win_setup(solo_dev, i, solo_dev->video_hsize,\r\nsolo_vlines(solo_dev),\r\nsolo_dev->video_hsize,\r\nsolo_vlines(solo_dev), 0);\r\nreturn 0;\r\n}\r\nysize = solo_vlines(solo_dev) / 4;\r\nhsize = solo_dev->video_hsize / 4;\r\nfor (sy = 0, i = 0; i < 4; i++, sy += ysize) {\r\nsolo_win_setup(solo_dev, i * 4, 0, sy, hsize,\r\nsy + ysize, 5);\r\nsolo_win_setup(solo_dev, (i * 4) + 1, hsize, sy,\r\nhsize * 2, sy + ysize, 5);\r\nsolo_win_setup(solo_dev, (i * 4) + 2, hsize * 2, sy,\r\nhsize * 3, sy + ysize, 5);\r\nsolo_win_setup(solo_dev, (i * 4) + 3, hsize * 3, sy,\r\nsolo_dev->video_hsize, sy + ysize, 5);\r\n}\r\nreturn 0;\r\n}\r\nstatic int solo_v4l2_ch(struct solo_dev *solo_dev, u8 ch, int on)\r\n{\r\nu8 ext_ch;\r\nif (ch < solo_dev->nr_chans) {\r\nsolo_win_setup(solo_dev, ch, on ? 0 : solo_dev->video_hsize,\r\non ? 0 : solo_vlines(solo_dev),\r\nsolo_dev->video_hsize, solo_vlines(solo_dev),\r\non ? 1 : 0);\r\nreturn 0;\r\n}\r\nif (ch >= solo_dev->nr_chans + solo_dev->nr_ext)\r\nreturn -EINVAL;\r\next_ch = ch - solo_dev->nr_chans;\r\nif (ext_ch < 4)\r\nreturn solo_v4l2_ch_ext_4up(solo_dev, ext_ch, on);\r\nreturn solo_v4l2_ch_ext_16up(solo_dev, on);\r\n}\r\nstatic int solo_v4l2_set_ch(struct solo_dev *solo_dev, u8 ch)\r\n{\r\nif (ch >= solo_dev->nr_chans + solo_dev->nr_ext)\r\nreturn -EINVAL;\r\nerase_on(solo_dev);\r\nsolo_v4l2_ch(solo_dev, solo_dev->cur_disp_ch, 0);\r\nsolo_v4l2_ch(solo_dev, ch, 1);\r\nsolo_dev->cur_disp_ch = ch;\r\nreturn 0;\r\n}\r\nstatic void disp_reset_desc(struct solo_filehandle *fh)\r\n{\r\nmemset(fh->desc, 0, sizeof(*fh->desc));\r\nfh->desc_idx = 1;\r\n}\r\nstatic int disp_flush_descs(struct solo_filehandle *fh)\r\n{\r\nint ret;\r\nif (!fh->desc_idx)\r\nreturn 0;\r\nret = solo_p2m_dma_desc(fh->solo_dev, SOLO_P2M_DMA_ID_DISP,\r\nfh->desc, fh->desc_idx);\r\ndisp_reset_desc(fh);\r\nreturn ret;\r\n}\r\nstatic int disp_push_desc(struct solo_filehandle *fh, dma_addr_t dma_addr,\r\nu32 ext_addr, int size, int repeat, int ext_size)\r\n{\r\nif (fh->desc_idx >= SOLO_NR_P2M_DESC) {\r\nint ret = disp_flush_descs(fh);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsolo_p2m_push_desc(&fh->desc[fh->desc_idx], 0, dma_addr, ext_addr,\r\nsize, repeat, ext_size);\r\nfh->desc_idx++;\r\nreturn 0;\r\n}\r\nstatic void solo_fillbuf(struct solo_filehandle *fh,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nstruct videobuf_dmabuf *vbuf;\r\nunsigned int fdma_addr;\r\nint error = 1;\r\nint i;\r\nstruct scatterlist *sg;\r\ndma_addr_t sg_dma;\r\nint sg_size_left;\r\nvbuf = videobuf_to_dma(vb);\r\nif (!vbuf)\r\ngoto finish_buf;\r\nif (erase_off(solo_dev)) {\r\nint i;\r\nfor_each_sg(vbuf->sglist, sg, vbuf->sglen, i) {\r\nvoid *p = sg_virt(sg);\r\nsize_t len = sg_dma_len(sg);\r\nfor (i = 0; i < len; i += 2) {\r\n((u8 *)p)[i] = 0x80;\r\n((u8 *)p)[i + 1] = 0x00;\r\n}\r\n}\r\nerror = 0;\r\ngoto finish_buf;\r\n}\r\ndisp_reset_desc(fh);\r\nsg = vbuf->sglist;\r\nsg_dma = sg_dma_address(sg);\r\nsg_size_left = sg_dma_len(sg);\r\nfdma_addr = SOLO_DISP_EXT_ADDR + (fh->old_write *\r\n(SOLO_HW_BPL * solo_vlines(solo_dev)));\r\nfor (i = 0; i < solo_vlines(solo_dev); i++) {\r\nint line_len = solo_bytesperline(solo_dev);\r\nint lines;\r\nif (!sg_size_left) {\r\nsg = sg_next(sg);\r\nif (sg == NULL)\r\ngoto finish_buf;\r\nsg_dma = sg_dma_address(sg);\r\nsg_size_left = sg_dma_len(sg);\r\n}\r\nif (sg_size_left < line_len) {\r\nint this_addr = fdma_addr;\r\nwhile (line_len > 0) {\r\nint this_write;\r\nif (!sg_size_left) {\r\nsg = sg_next(sg);\r\nif (sg == NULL)\r\ngoto finish_buf;\r\nsg_dma = sg_dma_address(sg);\r\nsg_size_left = sg_dma_len(sg);\r\n}\r\nthis_write = min(sg_size_left, line_len);\r\nif (disp_push_desc(fh, sg_dma, this_addr,\r\nthis_write, 0, 0))\r\ngoto finish_buf;\r\nline_len -= this_write;\r\nsg_size_left -= this_write;\r\nsg_dma += this_write;\r\nthis_addr += this_write;\r\n}\r\nfdma_addr += SOLO_HW_BPL;\r\ncontinue;\r\n}\r\nlines = min(sg_size_left / line_len,\r\nsolo_vlines(solo_dev) - i);\r\nif (disp_push_desc(fh, sg_dma, fdma_addr, line_len,\r\nlines - 1, SOLO_HW_BPL))\r\ngoto finish_buf;\r\ni += lines - 1;\r\nfdma_addr += SOLO_HW_BPL * lines;\r\nsg_dma += lines * line_len;\r\nsg_size_left -= lines * line_len;\r\n}\r\nerror = disp_flush_descs(fh);\r\nfinish_buf:\r\nif (error) {\r\nvb->state = VIDEOBUF_ERROR;\r\n} else {\r\nvb->size = solo_vlines(solo_dev) * solo_bytesperline(solo_dev);\r\nvb->state = VIDEOBUF_DONE;\r\nvb->field_count++;\r\ndo_gettimeofday(&vb->ts);\r\n}\r\nwake_up(&vb->done);\r\nreturn;\r\n}\r\nstatic void solo_thread_try(struct solo_filehandle *fh)\r\n{\r\nstruct videobuf_buffer *vb;\r\nunsigned int cur_write;\r\nfor (;;) {\r\nspin_lock(&fh->slock);\r\nif (list_empty(&fh->vidq_active))\r\nbreak;\r\nvb = list_first_entry(&fh->vidq_active, struct videobuf_buffer,\r\nqueue);\r\nif (!waitqueue_active(&vb->done))\r\nbreak;\r\ncur_write = SOLO_VI_STATUS0_PAGE(solo_reg_read(fh->solo_dev,\r\nSOLO_VI_STATUS0));\r\nif (cur_write == fh->old_write)\r\nbreak;\r\nfh->old_write = cur_write;\r\nlist_del(&vb->queue);\r\nspin_unlock(&fh->slock);\r\nsolo_fillbuf(fh, vb);\r\n}\r\nassert_spin_locked(&fh->slock);\r\nspin_unlock(&fh->slock);\r\n}\r\nstatic int solo_thread(void *data)\r\n{\r\nstruct solo_filehandle *fh = data;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_freezable();\r\nadd_wait_queue(&solo_dev->disp_thread_wait, &wait);\r\nfor (;;) {\r\nlong timeout = schedule_timeout_interruptible(HZ);\r\nif (timeout == -ERESTARTSYS || kthread_should_stop())\r\nbreak;\r\nsolo_thread_try(fh);\r\ntry_to_freeze();\r\n}\r\nremove_wait_queue(&solo_dev->disp_thread_wait, &wait);\r\nreturn 0;\r\n}\r\nstatic int solo_start_thread(struct solo_filehandle *fh)\r\n{\r\nfh->kthread = kthread_run(solo_thread, fh, SOLO6X10_NAME "_disp");\r\nif (IS_ERR(fh->kthread))\r\nreturn PTR_ERR(fh->kthread);\r\nreturn 0;\r\n}\r\nstatic void solo_stop_thread(struct solo_filehandle *fh)\r\n{\r\nif (fh->kthread) {\r\nkthread_stop(fh->kthread);\r\nfh->kthread = NULL;\r\n}\r\n}\r\nstatic int solo_buf_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct solo_filehandle *fh = vq->priv_data;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\n*size = solo_image_size(solo_dev);\r\nif (*count < MIN_VID_BUFFERS)\r\n*count = MIN_VID_BUFFERS;\r\nreturn 0;\r\n}\r\nstatic int solo_buf_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct solo_filehandle *fh = vq->priv_data;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nvb->size = solo_image_size(solo_dev);\r\nif (vb->baddr != 0 && vb->bsize < vb->size)\r\nreturn -EINVAL;\r\nvb->width = solo_dev->video_hsize;\r\nvb->height = solo_vlines(solo_dev);\r\nvb->bytesperline = solo_bytesperline(solo_dev);\r\nvb->field = field;\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nint rc = videobuf_iolock(vq, vb, NULL);\r\nif (rc < 0) {\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nvideobuf_dma_unmap(vq->dev, dma);\r\nvideobuf_dma_free(dma);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\nreturn rc;\r\n}\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\n}\r\nstatic void solo_buf_queue(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct solo_filehandle *fh = vq->priv_data;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nvb->state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&vb->queue, &fh->vidq_active);\r\nwake_up_interruptible(&solo_dev->disp_thread_wait);\r\n}\r\nstatic void solo_buf_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nvideobuf_dma_unmap(vq->dev, dma);\r\nvideobuf_dma_free(dma);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic unsigned int solo_v4l2_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct solo_filehandle *fh = file->private_data;\r\nreturn videobuf_poll_stream(file, &fh->vidq, wait);\r\n}\r\nstatic int solo_v4l2_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct solo_filehandle *fh = file->private_data;\r\nreturn videobuf_mmap_mapper(&fh->vidq, vma);\r\n}\r\nstatic int solo_v4l2_open(struct file *file)\r\n{\r\nstruct solo_dev *solo_dev = video_drvdata(file);\r\nstruct solo_filehandle *fh;\r\nint ret;\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (fh == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&fh->slock);\r\nINIT_LIST_HEAD(&fh->vidq_active);\r\nfh->solo_dev = solo_dev;\r\nfile->private_data = fh;\r\nret = solo_start_thread(fh);\r\nif (ret) {\r\nkfree(fh);\r\nreturn ret;\r\n}\r\nvideobuf_queue_sg_init(&fh->vidq, &solo_video_qops,\r\n&solo_dev->pdev->dev, &fh->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nSOLO_DISP_PIX_FIELD,\r\nsizeof(struct videobuf_buffer), fh, NULL);\r\nreturn 0;\r\n}\r\nstatic ssize_t solo_v4l2_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct solo_filehandle *fh = file->private_data;\r\nreturn videobuf_read_stream(&fh->vidq, data, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int solo_v4l2_release(struct file *file)\r\n{\r\nstruct solo_filehandle *fh = file->private_data;\r\nvideobuf_stop(&fh->vidq);\r\nvideobuf_mmap_free(&fh->vidq);\r\nsolo_stop_thread(fh);\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int solo_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nstrcpy(cap->driver, SOLO6X10_NAME);\r\nstrcpy(cap->card, "Softlogic 6x10");\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "PCI %s",\r\npci_name(solo_dev->pdev));\r\ncap->version = SOLO6X10_VER_NUM;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int solo_enum_ext_input(struct solo_dev *solo_dev,\r\nstruct v4l2_input *input)\r\n{\r\nstatic const char *dispnames_1[] = { "4UP" };\r\nstatic const char *dispnames_2[] = { "4UP-1", "4UP-2" };\r\nstatic const char *dispnames_5[] = {\r\n"4UP-1", "4UP-2", "4UP-3", "4UP-4", "16UP"\r\n};\r\nconst char **dispnames;\r\nif (input->index >= (solo_dev->nr_chans + solo_dev->nr_ext))\r\nreturn -EINVAL;\r\nif (solo_dev->nr_ext == 5)\r\ndispnames = dispnames_5;\r\nelse if (solo_dev->nr_ext == 2)\r\ndispnames = dispnames_2;\r\nelse\r\ndispnames = dispnames_1;\r\nsnprintf(input->name, sizeof(input->name), "Multi %s",\r\ndispnames[input->index - solo_dev->nr_chans]);\r\nreturn 0;\r\n}\r\nstatic int solo_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nif (input->index >= solo_dev->nr_chans) {\r\nint ret = solo_enum_ext_input(solo_dev, input);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nsnprintf(input->name, sizeof(input->name), "Camera %d",\r\ninput->index + 1);\r\nif (!tw28_get_video_status(solo_dev, input->index))\r\ninput->status = V4L2_IN_ST_NO_SIGNAL;\r\n}\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\nif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC)\r\ninput->std = V4L2_STD_NTSC_M;\r\nelse\r\ninput->std = V4L2_STD_PAL_B;\r\nreturn 0;\r\n}\r\nstatic int solo_set_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nreturn solo_v4l2_set_ch(fh->solo_dev, index);\r\n}\r\nstatic int solo_get_input(struct file *file, void *priv, unsigned int *index)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\n*index = fh->solo_dev->cur_disp_ch;\r\nreturn 0;\r\n}\r\nstatic int solo_enum_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index)\r\nreturn -EINVAL;\r\nf->pixelformat = V4L2_PIX_FMT_UYVY;\r\nstrlcpy(f->description, "UYUV 4:2:2 Packed", sizeof(f->description));\r\nreturn 0;\r\n}\r\nstatic int solo_try_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nint image_size = solo_image_size(solo_dev);\r\nif (pix->width != solo_dev->video_hsize)\r\npix->width = solo_dev->video_hsize;\r\nif (pix->height != solo_vlines(solo_dev))\r\npix->height = solo_vlines(solo_dev);\r\nif (pix->sizeimage != image_size)\r\npix->sizeimage = image_size;\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = SOLO_DISP_PIX_FIELD;\r\nif (pix->pixelformat != V4L2_PIX_FMT_UYVY ||\r\npix->field != SOLO_DISP_PIX_FIELD ||\r\npix->colorspace != V4L2_COLORSPACE_SMPTE170M)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int solo_set_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nif (videobuf_queue_is_busy(&fh->vidq))\r\nreturn -EBUSY;\r\nreturn solo_try_fmt_cap(file, priv, f);\r\n}\r\nstatic int solo_get_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\npix->width = solo_dev->video_hsize;\r\npix->height = solo_vlines(solo_dev);\r\npix->pixelformat = V4L2_PIX_FMT_UYVY;\r\npix->field = SOLO_DISP_PIX_FIELD;\r\npix->sizeimage = solo_image_size(solo_dev);\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\npix->bytesperline = solo_bytesperline(solo_dev);\r\nreturn 0;\r\n}\r\nstatic int solo_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nreturn videobuf_reqbufs(&fh->vidq, req);\r\n}\r\nstatic int solo_querybuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nreturn videobuf_querybuf(&fh->vidq, buf);\r\n}\r\nstatic int solo_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nreturn videobuf_qbuf(&fh->vidq, buf);\r\n}\r\nstatic int solo_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nreturn videobuf_dqbuf(&fh->vidq, buf, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int solo_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nif (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn videobuf_streamon(&fh->vidq);\r\n}\r\nstatic int solo_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nif (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn videobuf_streamoff(&fh->vidq);\r\n}\r\nstatic int solo_s_std(struct file *file, void *priv, v4l2_std_id *i)\r\n{\r\nreturn 0;\r\n}\r\nstatic int solo_disp_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nqc->id = v4l2_ctrl_next(solo_ctrl_classes, qc->id);\r\nif (!qc->id)\r\nreturn -EINVAL;\r\nswitch (qc->id) {\r\n#ifdef PRIVATE_CIDS\r\ncase V4L2_CID_MOTION_TRACE:\r\nqc->type = V4L2_CTRL_TYPE_BOOLEAN;\r\nqc->minimum = 0;\r\nqc->maximum = qc->step = 1;\r\nqc->default_value = 0;\r\nstrlcpy(qc->name, "Motion Detection Trace", sizeof(qc->name));\r\nreturn 0;\r\n#else\r\ncase V4L2_CID_MOTION_TRACE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);\r\n#endif\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int solo_disp_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MOTION_TRACE:\r\nctrl->value = solo_reg_read(solo_dev, SOLO_VI_MOTION_BAR)\r\n? 1 : 0;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int solo_disp_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct solo_filehandle *fh = priv;\r\nstruct solo_dev *solo_dev = fh->solo_dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MOTION_TRACE:\r\nif (ctrl->value) {\r\nsolo_reg_write(solo_dev, SOLO_VI_MOTION_BORDER,\r\nSOLO_VI_MOTION_Y_ADD |\r\nSOLO_VI_MOTION_Y_VALUE(0x20) |\r\nSOLO_VI_MOTION_CB_VALUE(0x10) |\r\nSOLO_VI_MOTION_CR_VALUE(0x10));\r\nsolo_reg_write(solo_dev, SOLO_VI_MOTION_BAR,\r\nSOLO_VI_MOTION_CR_ADD |\r\nSOLO_VI_MOTION_Y_VALUE(0x10) |\r\nSOLO_VI_MOTION_CB_VALUE(0x80) |\r\nSOLO_VI_MOTION_CR_VALUE(0x10));\r\n} else {\r\nsolo_reg_write(solo_dev, SOLO_VI_MOTION_BORDER, 0);\r\nsolo_reg_write(solo_dev, SOLO_VI_MOTION_BAR, 0);\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint solo_v4l2_init(struct solo_dev *solo_dev)\r\n{\r\nint ret;\r\nint i;\r\ninit_waitqueue_head(&solo_dev->disp_thread_wait);\r\nsolo_dev->vfd = video_device_alloc();\r\nif (!solo_dev->vfd)\r\nreturn -ENOMEM;\r\n*solo_dev->vfd = solo_v4l2_template;\r\nsolo_dev->vfd->parent = &solo_dev->pdev->dev;\r\nret = video_register_device(solo_dev->vfd, VFL_TYPE_GRABBER, video_nr);\r\nif (ret < 0) {\r\nvideo_device_release(solo_dev->vfd);\r\nsolo_dev->vfd = NULL;\r\nreturn ret;\r\n}\r\nvideo_set_drvdata(solo_dev->vfd, solo_dev);\r\nsnprintf(solo_dev->vfd->name, sizeof(solo_dev->vfd->name), "%s (%i)",\r\nSOLO6X10_NAME, solo_dev->vfd->num);\r\nif (video_nr != -1)\r\nvideo_nr++;\r\ndev_info(&solo_dev->pdev->dev, "Display as /dev/video%d with "\r\n"%d inputs (%d extended)\n", solo_dev->vfd->num,\r\nsolo_dev->nr_chans, solo_dev->nr_ext);\r\nfor (i = 0; i < solo_dev->nr_chans; i++) {\r\nsolo_v4l2_set_ch(solo_dev, i);\r\nwhile (erase_off(solo_dev))\r\n;\r\n}\r\nsolo_v4l2_set_ch(solo_dev, 0);\r\nwhile (erase_off(solo_dev))\r\n;\r\nsolo_irq_on(solo_dev, SOLO_IRQ_VIDEO_IN);\r\nreturn 0;\r\n}\r\nvoid solo_v4l2_exit(struct solo_dev *solo_dev)\r\n{\r\nsolo_irq_off(solo_dev, SOLO_IRQ_VIDEO_IN);\r\nif (solo_dev->vfd) {\r\nvideo_unregister_device(solo_dev->vfd);\r\nsolo_dev->vfd = NULL;\r\n}\r\n}
