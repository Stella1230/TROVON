static int tpo_td043_write(struct spi_device *spi, u8 addr, u8 data)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer xfer;\r\nu16 w;\r\nint r;\r\nspi_message_init(&m);\r\nmemset(&xfer, 0, sizeof(xfer));\r\nw = ((u16)addr << 10) | (1 << 8) | data;\r\nxfer.tx_buf = &w;\r\nxfer.bits_per_word = 16;\r\nxfer.len = 2;\r\nspi_message_add_tail(&xfer, &m);\r\nr = spi_sync(spi, &m);\r\nif (r < 0)\r\ndev_warn(&spi->dev, "failed to write to LCD reg (%d)\n", r);\r\nreturn r;\r\n}\r\nstatic void tpo_td043_write_gamma(struct spi_device *spi, u16 gamma[12])\r\n{\r\nu8 i, val;\r\nfor (val = i = 0; i < 4; i++)\r\nval |= (gamma[i] & 0x300) >> ((i + 1) * 2);\r\ntpo_td043_write(spi, 0x11, val);\r\nfor (val = i = 0; i < 4; i++)\r\nval |= (gamma[i+4] & 0x300) >> ((i + 1) * 2);\r\ntpo_td043_write(spi, 0x12, val);\r\nfor (val = i = 0; i < 4; i++)\r\nval |= (gamma[i+8] & 0x300) >> ((i + 1) * 2);\r\ntpo_td043_write(spi, 0x13, val);\r\nfor (val = i = 0; i < 12; i++)\r\ntpo_td043_write(spi, 0x14 + i, gamma[i] & 0xff);\r\n}\r\nstatic int tpo_td043_write_mirror(struct spi_device *spi, bool h, bool v)\r\n{\r\nu8 reg4 = TPO_R04_NFLIP_H | TPO_R04_NFLIP_V | \\r\nTPO_R04_CP_CLK_FREQ_1H | TPO_R04_VGL_FREQ_1H;\r\nif (h)\r\nreg4 &= ~TPO_R04_NFLIP_H;\r\nif (v)\r\nreg4 &= ~TPO_R04_NFLIP_V;\r\nreturn tpo_td043_write(spi, 4, reg4);\r\n}\r\nstatic int tpo_td043_set_hmirror(struct omap_dss_device *dssdev, bool enable)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(&dssdev->dev);\r\ntpo_td043->hmirror = enable;\r\nreturn tpo_td043_write_mirror(tpo_td043->spi, tpo_td043->hmirror,\r\ntpo_td043->vmirror);\r\n}\r\nstatic bool tpo_td043_get_hmirror(struct omap_dss_device *dssdev)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(&dssdev->dev);\r\nreturn tpo_td043->hmirror;\r\n}\r\nstatic ssize_t tpo_td043_vmirror_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tpo_td043->vmirror);\r\n}\r\nstatic ssize_t tpo_td043_vmirror_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(dev);\r\nint val;\r\nint ret;\r\nret = kstrtoint(buf, 0, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = !!val;\r\nret = tpo_td043_write_mirror(tpo_td043->spi, tpo_td043->hmirror, val);\r\nif (ret < 0)\r\nreturn ret;\r\ntpo_td043->vmirror = val;\r\nreturn count;\r\n}\r\nstatic ssize_t tpo_td043_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tpo_td043->mode);\r\n}\r\nstatic ssize_t tpo_td043_mode_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(dev);\r\nlong val;\r\nint ret;\r\nret = kstrtol(buf, 0, &val);\r\nif (ret != 0 || val & ~7)\r\nreturn -EINVAL;\r\ntpo_td043->mode = val;\r\nval |= TPO_R02_NCLK_RISING;\r\ntpo_td043_write(tpo_td043->spi, 2, val);\r\nreturn count;\r\n}\r\nstatic ssize_t tpo_td043_gamma_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(dev);\r\nssize_t len = 0;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tpo_td043->gamma); i++) {\r\nret = snprintf(buf + len, PAGE_SIZE - len, "%u ",\r\ntpo_td043->gamma[i]);\r\nif (ret < 0)\r\nreturn ret;\r\nlen += ret;\r\n}\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t tpo_td043_gamma_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(dev);\r\nunsigned int g[12];\r\nint ret;\r\nint i;\r\nret = sscanf(buf, "%u %u %u %u %u %u %u %u %u %u %u %u",\r\n&g[0], &g[1], &g[2], &g[3], &g[4], &g[5],\r\n&g[6], &g[7], &g[8], &g[9], &g[10], &g[11]);\r\nif (ret != 12)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 12; i++)\r\ntpo_td043->gamma[i] = g[i];\r\ntpo_td043_write_gamma(tpo_td043->spi, tpo_td043->gamma);\r\nreturn count;\r\n}\r\nstatic int tpo_td043_power_on(struct omap_dss_device *dssdev)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(&dssdev->dev);\r\nint nreset_gpio = dssdev->reset_gpio;\r\nint r;\r\nif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)\r\nreturn 0;\r\nr = omapdss_dpi_display_enable(dssdev);\r\nif (r)\r\ngoto err0;\r\nif (dssdev->platform_enable) {\r\nr = dssdev->platform_enable(dssdev);\r\nif (r)\r\ngoto err1;\r\n}\r\nregulator_enable(tpo_td043->vcc_reg);\r\nmsleep(160);\r\nif (gpio_is_valid(nreset_gpio))\r\ngpio_set_value(nreset_gpio, 1);\r\ntpo_td043_write(tpo_td043->spi, 2,\r\nTPO_R02_MODE(tpo_td043->mode) | TPO_R02_NCLK_RISING);\r\ntpo_td043_write(tpo_td043->spi, 3, TPO_R03_VAL_NORMAL);\r\ntpo_td043_write(tpo_td043->spi, 0x20, 0xf0);\r\ntpo_td043_write(tpo_td043->spi, 0x21, 0xf0);\r\ntpo_td043_write_mirror(tpo_td043->spi, tpo_td043->hmirror,\r\ntpo_td043->vmirror);\r\ntpo_td043_write_gamma(tpo_td043->spi, tpo_td043->gamma);\r\nreturn 0;\r\nerr1:\r\nomapdss_dpi_display_disable(dssdev);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic void tpo_td043_power_off(struct omap_dss_device *dssdev)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(&dssdev->dev);\r\nint nreset_gpio = dssdev->reset_gpio;\r\nif (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)\r\nreturn;\r\ntpo_td043_write(tpo_td043->spi, 3,\r\nTPO_R03_VAL_STANDBY | TPO_R03_EN_PWM);\r\nif (gpio_is_valid(nreset_gpio))\r\ngpio_set_value(nreset_gpio, 0);\r\nmsleep(50);\r\ntpo_td043_write(tpo_td043->spi, 3, TPO_R03_VAL_STANDBY);\r\nregulator_disable(tpo_td043->vcc_reg);\r\nif (dssdev->platform_disable)\r\ndssdev->platform_disable(dssdev);\r\nomapdss_dpi_display_disable(dssdev);\r\n}\r\nstatic int tpo_td043_enable(struct omap_dss_device *dssdev)\r\n{\r\nint ret;\r\ndev_dbg(&dssdev->dev, "enable\n");\r\nret = tpo_td043_power_on(dssdev);\r\nif (ret)\r\nreturn ret;\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic void tpo_td043_disable(struct omap_dss_device *dssdev)\r\n{\r\ndev_dbg(&dssdev->dev, "disable\n");\r\ntpo_td043_power_off(dssdev);\r\ndssdev->state = OMAP_DSS_DISPLAY_DISABLED;\r\n}\r\nstatic int tpo_td043_suspend(struct omap_dss_device *dssdev)\r\n{\r\ntpo_td043_power_off(dssdev);\r\ndssdev->state = OMAP_DSS_DISPLAY_SUSPENDED;\r\nreturn 0;\r\n}\r\nstatic int tpo_td043_resume(struct omap_dss_device *dssdev)\r\n{\r\nint r = 0;\r\nr = tpo_td043_power_on(dssdev);\r\nif (r)\r\nreturn r;\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int tpo_td043_probe(struct omap_dss_device *dssdev)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(&dssdev->dev);\r\nint nreset_gpio = dssdev->reset_gpio;\r\nint ret = 0;\r\ndev_dbg(&dssdev->dev, "probe\n");\r\nif (tpo_td043 == NULL) {\r\ndev_err(&dssdev->dev, "missing tpo_td043_device\n");\r\nreturn -ENODEV;\r\n}\r\ndssdev->panel.config = OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IHS |\r\nOMAP_DSS_LCD_IVS | OMAP_DSS_LCD_IPC;\r\ndssdev->panel.timings = tpo_td043_timings;\r\ndssdev->ctrl.pixel_size = 24;\r\ntpo_td043->mode = TPO_R02_MODE_800x480;\r\nmemcpy(tpo_td043->gamma, tpo_td043_def_gamma, sizeof(tpo_td043->gamma));\r\ntpo_td043->vcc_reg = regulator_get(&dssdev->dev, "vcc");\r\nif (IS_ERR(tpo_td043->vcc_reg)) {\r\ndev_err(&dssdev->dev, "failed to get LCD VCC regulator\n");\r\nret = PTR_ERR(tpo_td043->vcc_reg);\r\ngoto fail_regulator;\r\n}\r\nif (gpio_is_valid(nreset_gpio)) {\r\nret = gpio_request(nreset_gpio, "lcd reset");\r\nif (ret < 0) {\r\ndev_err(&dssdev->dev, "couldn't request reset GPIO\n");\r\ngoto fail_gpio_req;\r\n}\r\nret = gpio_direction_output(nreset_gpio, 0);\r\nif (ret < 0) {\r\ndev_err(&dssdev->dev, "couldn't set GPIO direction\n");\r\ngoto fail_gpio_direction;\r\n}\r\n}\r\nret = sysfs_create_group(&dssdev->dev.kobj, &tpo_td043_attr_group);\r\nif (ret)\r\ndev_warn(&dssdev->dev, "failed to create sysfs files\n");\r\nreturn 0;\r\nfail_gpio_direction:\r\ngpio_free(nreset_gpio);\r\nfail_gpio_req:\r\nregulator_put(tpo_td043->vcc_reg);\r\nfail_regulator:\r\nkfree(tpo_td043);\r\nreturn ret;\r\n}\r\nstatic void tpo_td043_remove(struct omap_dss_device *dssdev)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(&dssdev->dev);\r\nint nreset_gpio = dssdev->reset_gpio;\r\ndev_dbg(&dssdev->dev, "remove\n");\r\nsysfs_remove_group(&dssdev->dev.kobj, &tpo_td043_attr_group);\r\nregulator_put(tpo_td043->vcc_reg);\r\nif (gpio_is_valid(nreset_gpio))\r\ngpio_free(nreset_gpio);\r\n}\r\nstatic int tpo_td043_spi_probe(struct spi_device *spi)\r\n{\r\nstruct omap_dss_device *dssdev = spi->dev.platform_data;\r\nstruct tpo_td043_device *tpo_td043;\r\nint ret;\r\nif (dssdev == NULL) {\r\ndev_err(&spi->dev, "missing dssdev\n");\r\nreturn -ENODEV;\r\n}\r\nspi->bits_per_word = 16;\r\nspi->mode = SPI_MODE_0;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "spi_setup failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ntpo_td043 = kzalloc(sizeof(*tpo_td043), GFP_KERNEL);\r\nif (tpo_td043 == NULL)\r\nreturn -ENOMEM;\r\ntpo_td043->spi = spi;\r\ndev_set_drvdata(&spi->dev, tpo_td043);\r\ndev_set_drvdata(&dssdev->dev, tpo_td043);\r\nomap_dss_register_driver(&tpo_td043_driver);\r\nreturn 0;\r\n}\r\nstatic int __devexit tpo_td043_spi_remove(struct spi_device *spi)\r\n{\r\nstruct tpo_td043_device *tpo_td043 = dev_get_drvdata(&spi->dev);\r\nomap_dss_unregister_driver(&tpo_td043_driver);\r\nkfree(tpo_td043);\r\nreturn 0;\r\n}\r\nstatic int __init tpo_td043_init(void)\r\n{\r\nreturn spi_register_driver(&tpo_td043_spi_driver);\r\n}\r\nstatic void __exit tpo_td043_exit(void)\r\n{\r\nspi_unregister_driver(&tpo_td043_spi_driver);\r\n}
