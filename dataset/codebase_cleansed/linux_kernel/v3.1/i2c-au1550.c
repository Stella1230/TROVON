static int\r\nwait_xfer_done(struct i2c_au1550_data *adap)\r\n{\r\nu32 stat;\r\nint i;\r\nvolatile psc_smb_t *sp;\r\nsp = (volatile psc_smb_t *)(adap->psc_base);\r\nfor (i = 0; i < adap->xfer_timeout; i++) {\r\nstat = sp->psc_smbstat;\r\nau_sync();\r\nif ((stat & PSC_SMBSTAT_TE) != 0)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\nwait_ack(struct i2c_au1550_data *adap)\r\n{\r\nu32 stat;\r\nvolatile psc_smb_t *sp;\r\nif (wait_xfer_done(adap))\r\nreturn -ETIMEDOUT;\r\nsp = (volatile psc_smb_t *)(adap->psc_base);\r\nstat = sp->psc_smbevnt;\r\nau_sync();\r\nif ((stat & (PSC_SMBEVNT_DN | PSC_SMBEVNT_AN | PSC_SMBEVNT_AL)) != 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int\r\nwait_master_done(struct i2c_au1550_data *adap)\r\n{\r\nu32 stat;\r\nint i;\r\nvolatile psc_smb_t *sp;\r\nsp = (volatile psc_smb_t *)(adap->psc_base);\r\nfor (i = 0; i < adap->xfer_timeout; i++) {\r\nstat = sp->psc_smbevnt;\r\nau_sync();\r\nif ((stat & PSC_SMBEVNT_MD) != 0)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\ndo_address(struct i2c_au1550_data *adap, unsigned int addr, int rd, int q)\r\n{\r\nvolatile psc_smb_t *sp;\r\nu32 stat;\r\nsp = (volatile psc_smb_t *)(adap->psc_base);\r\nstat = sp->psc_smbstat;\r\nsp->psc_smbevnt = PSC_SMBEVNT_ALLCLR;\r\nau_sync();\r\nif (!(stat & PSC_SMBSTAT_TE) || !(stat & PSC_SMBSTAT_RE)) {\r\nsp->psc_smbpcr = PSC_SMBPCR_DC;\r\nau_sync();\r\ndo {\r\nstat = sp->psc_smbpcr;\r\nau_sync();\r\n} while ((stat & PSC_SMBPCR_DC) != 0);\r\nudelay(50);\r\n}\r\naddr <<= 1;\r\nif (rd)\r\naddr |= 1;\r\nif (q)\r\naddr |= PSC_SMBTXRX_STP;\r\nsp->psc_smbtxrx = addr;\r\nau_sync();\r\nsp->psc_smbpcr = PSC_SMBPCR_MS;\r\nau_sync();\r\nif (wait_ack(adap))\r\nreturn -EIO;\r\nreturn (q) ? wait_master_done(adap) : 0;\r\n}\r\nstatic u32\r\nwait_for_rx_byte(struct i2c_au1550_data *adap, u32 *ret_data)\r\n{\r\nint j;\r\nu32 data, stat;\r\nvolatile psc_smb_t *sp;\r\nif (wait_xfer_done(adap))\r\nreturn -EIO;\r\nsp = (volatile psc_smb_t *)(adap->psc_base);\r\nj = adap->xfer_timeout * 100;\r\ndo {\r\nj--;\r\nif (j <= 0)\r\nreturn -EIO;\r\nstat = sp->psc_smbstat;\r\nau_sync();\r\nif ((stat & PSC_SMBSTAT_RE) == 0)\r\nj = 0;\r\nelse\r\nudelay(1);\r\n} while (j > 0);\r\ndata = sp->psc_smbtxrx;\r\nau_sync();\r\n*ret_data = data;\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_read(struct i2c_au1550_data *adap, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nint i;\r\nu32 data;\r\nvolatile psc_smb_t *sp;\r\nif (len == 0)\r\nreturn 0;\r\nsp = (volatile psc_smb_t *)(adap->psc_base);\r\ni = 0;\r\nwhile (i < (len-1)) {\r\nsp->psc_smbtxrx = 0;\r\nau_sync();\r\nif (wait_for_rx_byte(adap, &data))\r\nreturn -EIO;\r\nbuf[i] = data;\r\ni++;\r\n}\r\nsp->psc_smbtxrx = PSC_SMBTXRX_STP;\r\nau_sync();\r\nif (wait_master_done(adap))\r\nreturn -EIO;\r\ndata = sp->psc_smbtxrx;\r\nau_sync();\r\nbuf[i] = data;\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_write(struct i2c_au1550_data *adap, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nint i;\r\nu32 data;\r\nvolatile psc_smb_t *sp;\r\nif (len == 0)\r\nreturn 0;\r\nsp = (volatile psc_smb_t *)(adap->psc_base);\r\ni = 0;\r\nwhile (i < (len-1)) {\r\ndata = buf[i];\r\nsp->psc_smbtxrx = data;\r\nau_sync();\r\nif (wait_ack(adap))\r\nreturn -EIO;\r\ni++;\r\n}\r\ndata = buf[i];\r\ndata |= PSC_SMBTXRX_STP;\r\nsp->psc_smbtxrx = data;\r\nau_sync();\r\nif (wait_master_done(adap))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nau1550_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct i2c_au1550_data *adap = i2c_adap->algo_data;\r\nvolatile psc_smb_t *sp = (volatile psc_smb_t *)adap->psc_base;\r\nstruct i2c_msg *p;\r\nint i, err = 0;\r\nsp->psc_ctrl = PSC_CTRL_ENABLE;\r\nau_sync();\r\nfor (i = 0; !err && i < num; i++) {\r\np = &msgs[i];\r\nerr = do_address(adap, p->addr, p->flags & I2C_M_RD,\r\n(p->len == 0));\r\nif (err || !p->len)\r\ncontinue;\r\nif (p->flags & I2C_M_RD)\r\nerr = i2c_read(adap, p->buf, p->len);\r\nelse\r\nerr = i2c_write(adap, p->buf, p->len);\r\n}\r\nif (err == 0)\r\nerr = num;\r\nsp->psc_ctrl = PSC_CTRL_SUSPEND;\r\nau_sync();\r\nreturn err;\r\n}\r\nstatic u32\r\nau1550_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic void i2c_au1550_setup(struct i2c_au1550_data *priv)\r\n{\r\nvolatile psc_smb_t *sp = (volatile psc_smb_t *)priv->psc_base;\r\nu32 stat;\r\nsp->psc_ctrl = PSC_CTRL_DISABLE;\r\nau_sync();\r\nsp->psc_sel = PSC_SEL_PS_SMBUSMODE;\r\nsp->psc_smbcfg = 0;\r\nau_sync();\r\nsp->psc_ctrl = PSC_CTRL_ENABLE;\r\nau_sync();\r\ndo {\r\nstat = sp->psc_smbstat;\r\nau_sync();\r\n} while ((stat & PSC_SMBSTAT_SR) == 0);\r\nsp->psc_smbcfg = (PSC_SMBCFG_RT_FIFO8 | PSC_SMBCFG_TT_FIFO8 |\r\nPSC_SMBCFG_DD_DISABLE);\r\nsp->psc_smbcfg |= PSC_SMBCFG_SET_DIV(PSC_SMBCFG_DIV8);\r\nsp->psc_smbmsk = PSC_SMBMSK_ALLMASK;\r\nau_sync();\r\nsp->psc_smbtmr = PSC_SMBTMR_SET_TH(0) | PSC_SMBTMR_SET_PS(15) | \\r\nPSC_SMBTMR_SET_PU(15) | PSC_SMBTMR_SET_SH(15) | \\r\nPSC_SMBTMR_SET_SU(15) | PSC_SMBTMR_SET_CL(15) | \\r\nPSC_SMBTMR_SET_CH(15);\r\nau_sync();\r\nsp->psc_smbcfg |= PSC_SMBCFG_DE_ENABLE;\r\ndo {\r\nstat = sp->psc_smbstat;\r\nau_sync();\r\n} while ((stat & PSC_SMBSTAT_SR) == 0);\r\nsp->psc_ctrl = PSC_CTRL_SUSPEND;\r\nau_sync();\r\n}\r\nstatic void i2c_au1550_disable(struct i2c_au1550_data *priv)\r\n{\r\nvolatile psc_smb_t *sp = (volatile psc_smb_t *)priv->psc_base;\r\nsp->psc_smbcfg = 0;\r\nsp->psc_ctrl = PSC_CTRL_DISABLE;\r\nau_sync();\r\n}\r\nstatic int __devinit\r\ni2c_au1550_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_au1550_data *priv;\r\nstruct resource *r;\r\nint ret;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\npriv = kzalloc(sizeof(struct i2c_au1550_data), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npriv->ioarea = request_mem_region(r->start, resource_size(r),\r\npdev->name);\r\nif (!priv->ioarea) {\r\nret = -EBUSY;\r\ngoto out_mem;\r\n}\r\npriv->psc_base = CKSEG1ADDR(r->start);\r\npriv->xfer_timeout = 200;\r\npriv->ack_timeout = 200;\r\npriv->adap.nr = pdev->id;\r\npriv->adap.algo = &au1550_algo;\r\npriv->adap.algo_data = priv;\r\npriv->adap.dev.parent = &pdev->dev;\r\nstrlcpy(priv->adap.name, "Au1xxx PSC I2C", sizeof(priv->adap.name));\r\ni2c_au1550_setup(priv);\r\nret = i2c_add_numbered_adapter(&priv->adap);\r\nif (ret == 0) {\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\ni2c_au1550_disable(priv);\r\nrelease_resource(priv->ioarea);\r\nkfree(priv->ioarea);\r\nout_mem:\r\nkfree(priv);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __devexit\r\ni2c_au1550_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_au1550_data *priv = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\ni2c_del_adapter(&priv->adap);\r\ni2c_au1550_disable(priv);\r\nrelease_resource(priv->ioarea);\r\nkfree(priv->ioarea);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_au1550_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct i2c_au1550_data *priv = platform_get_drvdata(pdev);\r\ni2c_au1550_disable(priv);\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_au1550_resume(struct platform_device *pdev)\r\n{\r\nstruct i2c_au1550_data *priv = platform_get_drvdata(pdev);\r\ni2c_au1550_setup(priv);\r\nreturn 0;\r\n}\r\nstatic int __init\r\ni2c_au1550_init(void)\r\n{\r\nreturn platform_driver_register(&au1xpsc_smbus_driver);\r\n}\r\nstatic void __exit\r\ni2c_au1550_exit(void)\r\n{\r\nplatform_driver_unregister(&au1xpsc_smbus_driver);\r\n}
