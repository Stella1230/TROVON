static inline int jsm_get_mstat(struct jsm_channel *ch)\r\n{\r\nunsigned char mstat;\r\nunsigned result;\r\njsm_printk(IOCTL, INFO, &ch->ch_bd->pci_dev, "start\n");\r\nmstat = (ch->ch_mostat | ch->ch_mistat);\r\nresult = 0;\r\nif (mstat & UART_MCR_DTR)\r\nresult |= TIOCM_DTR;\r\nif (mstat & UART_MCR_RTS)\r\nresult |= TIOCM_RTS;\r\nif (mstat & UART_MSR_CTS)\r\nresult |= TIOCM_CTS;\r\nif (mstat & UART_MSR_DSR)\r\nresult |= TIOCM_DSR;\r\nif (mstat & UART_MSR_RI)\r\nresult |= TIOCM_RI;\r\nif (mstat & UART_MSR_DCD)\r\nresult |= TIOCM_CD;\r\njsm_printk(IOCTL, INFO, &ch->ch_bd->pci_dev, "finish\n");\r\nreturn result;\r\n}\r\nstatic unsigned int jsm_tty_tx_empty(struct uart_port *port)\r\n{\r\nreturn TIOCSER_TEMT;\r\n}\r\nstatic unsigned int jsm_tty_get_mctrl(struct uart_port *port)\r\n{\r\nint result;\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\njsm_printk(IOCTL, INFO, &channel->ch_bd->pci_dev, "start\n");\r\nresult = jsm_get_mstat(channel);\r\nif (result < 0)\r\nreturn -ENXIO;\r\njsm_printk(IOCTL, INFO, &channel->ch_bd->pci_dev, "finish\n");\r\nreturn result;\r\n}\r\nstatic void jsm_tty_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\njsm_printk(IOCTL, INFO, &channel->ch_bd->pci_dev, "start\n");\r\nif (mctrl & TIOCM_RTS)\r\nchannel->ch_mostat |= UART_MCR_RTS;\r\nelse\r\nchannel->ch_mostat &= ~UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nchannel->ch_mostat |= UART_MCR_DTR;\r\nelse\r\nchannel->ch_mostat &= ~UART_MCR_DTR;\r\nchannel->ch_bd->bd_ops->assert_modem_signals(channel);\r\njsm_printk(IOCTL, INFO, &channel->ch_bd->pci_dev, "finish\n");\r\nudelay(10);\r\n}\r\nstatic void jsm_tty_start_tx(struct uart_port *port)\r\n{\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\njsm_printk(IOCTL, INFO, &channel->ch_bd->pci_dev, "start\n");\r\nchannel->ch_flags &= ~(CH_STOP);\r\njsm_tty_write(port);\r\njsm_printk(IOCTL, INFO, &channel->ch_bd->pci_dev, "finish\n");\r\n}\r\nstatic void jsm_tty_stop_tx(struct uart_port *port)\r\n{\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\njsm_printk(IOCTL, INFO, &channel->ch_bd->pci_dev, "start\n");\r\nchannel->ch_flags |= (CH_STOP);\r\njsm_printk(IOCTL, INFO, &channel->ch_bd->pci_dev, "finish\n");\r\n}\r\nstatic void jsm_tty_send_xchar(struct uart_port *port, char ch)\r\n{\r\nunsigned long lock_flags;\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\nstruct ktermios *termios;\r\nspin_lock_irqsave(&port->lock, lock_flags);\r\ntermios = port->state->port.tty->termios;\r\nif (ch == termios->c_cc[VSTART])\r\nchannel->ch_bd->bd_ops->send_start_character(channel);\r\nif (ch == termios->c_cc[VSTOP])\r\nchannel->ch_bd->bd_ops->send_stop_character(channel);\r\nspin_unlock_irqrestore(&port->lock, lock_flags);\r\n}\r\nstatic void jsm_tty_stop_rx(struct uart_port *port)\r\n{\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\nchannel->ch_bd->bd_ops->disable_receiver(channel);\r\n}\r\nstatic void jsm_tty_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void jsm_tty_break(struct uart_port *port, int break_state)\r\n{\r\nunsigned long lock_flags;\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\nspin_lock_irqsave(&port->lock, lock_flags);\r\nif (break_state == -1)\r\nchannel->ch_bd->bd_ops->send_break(channel);\r\nelse\r\nchannel->ch_bd->bd_ops->clear_break(channel, 0);\r\nspin_unlock_irqrestore(&port->lock, lock_flags);\r\n}\r\nstatic int jsm_tty_open(struct uart_port *port)\r\n{\r\nstruct jsm_board *brd;\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\nstruct ktermios *termios;\r\nbrd = channel->ch_bd;\r\nchannel->ch_flags |= (CH_OPENING);\r\nif (!channel->ch_rqueue) {\r\nchannel->ch_rqueue = kzalloc(RQUEUESIZE, GFP_KERNEL);\r\nif (!channel->ch_rqueue) {\r\njsm_printk(INIT, ERR, &channel->ch_bd->pci_dev,\r\n"unable to allocate read queue buf");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (!channel->ch_equeue) {\r\nchannel->ch_equeue = kzalloc(EQUEUESIZE, GFP_KERNEL);\r\nif (!channel->ch_equeue) {\r\njsm_printk(INIT, ERR, &channel->ch_bd->pci_dev,\r\n"unable to allocate error queue buf");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (!channel->ch_wqueue) {\r\nchannel->ch_wqueue = kzalloc(WQUEUESIZE, GFP_KERNEL);\r\nif (!channel->ch_wqueue) {\r\njsm_printk(INIT, ERR, &channel->ch_bd->pci_dev,\r\n"unable to allocate write queue buf");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nchannel->ch_flags &= ~(CH_OPENING);\r\njsm_printk(OPEN, INFO, &channel->ch_bd->pci_dev,\r\n"jsm_open: initializing channel in open...\n");\r\nchannel->ch_r_head = channel->ch_r_tail = 0;\r\nchannel->ch_e_head = channel->ch_e_tail = 0;\r\nchannel->ch_w_head = channel->ch_w_tail = 0;\r\nbrd->bd_ops->flush_uart_write(channel);\r\nbrd->bd_ops->flush_uart_read(channel);\r\nchannel->ch_flags = 0;\r\nchannel->ch_cached_lsr = 0;\r\nchannel->ch_stops_sent = 0;\r\ntermios = port->state->port.tty->termios;\r\nchannel->ch_c_cflag = termios->c_cflag;\r\nchannel->ch_c_iflag = termios->c_iflag;\r\nchannel->ch_c_oflag = termios->c_oflag;\r\nchannel->ch_c_lflag = termios->c_lflag;\r\nchannel->ch_startc = termios->c_cc[VSTART];\r\nchannel->ch_stopc = termios->c_cc[VSTOP];\r\nbrd->bd_ops->uart_init(channel);\r\nbrd->bd_ops->param(channel);\r\njsm_carrier(channel);\r\nchannel->ch_open_count++;\r\njsm_printk(OPEN, INFO, &channel->ch_bd->pci_dev, "finish\n");\r\nreturn 0;\r\n}\r\nstatic void jsm_tty_close(struct uart_port *port)\r\n{\r\nstruct jsm_board *bd;\r\nstruct ktermios *ts;\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\njsm_printk(CLOSE, INFO, &channel->ch_bd->pci_dev, "start\n");\r\nbd = channel->ch_bd;\r\nts = port->state->port.tty->termios;\r\nchannel->ch_flags &= ~(CH_STOPI);\r\nchannel->ch_open_count--;\r\nif (channel->ch_c_cflag & HUPCL) {\r\njsm_printk(CLOSE, INFO, &channel->ch_bd->pci_dev,\r\n"Close. HUPCL set, dropping DTR/RTS\n");\r\nchannel->ch_mostat &= ~(UART_MCR_DTR | UART_MCR_RTS);\r\nbd->bd_ops->assert_modem_signals(channel);\r\n}\r\nchannel->ch_bd->bd_ops->uart_off(channel);\r\njsm_printk(CLOSE, INFO, &channel->ch_bd->pci_dev, "finish\n");\r\n}\r\nstatic void jsm_tty_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old_termios)\r\n{\r\nunsigned long lock_flags;\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\nspin_lock_irqsave(&port->lock, lock_flags);\r\nchannel->ch_c_cflag = termios->c_cflag;\r\nchannel->ch_c_iflag = termios->c_iflag;\r\nchannel->ch_c_oflag = termios->c_oflag;\r\nchannel->ch_c_lflag = termios->c_lflag;\r\nchannel->ch_startc = termios->c_cc[VSTART];\r\nchannel->ch_stopc = termios->c_cc[VSTOP];\r\nchannel->ch_bd->bd_ops->param(channel);\r\njsm_carrier(channel);\r\nspin_unlock_irqrestore(&port->lock, lock_flags);\r\n}\r\nstatic const char *jsm_tty_type(struct uart_port *port)\r\n{\r\nreturn "jsm";\r\n}\r\nstatic void jsm_tty_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int jsm_tty_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void jsm_config_port(struct uart_port *port, int flags)\r\n{\r\nport->type = PORT_JSM;\r\n}\r\nint __devinit jsm_tty_init(struct jsm_board *brd)\r\n{\r\nint i;\r\nvoid __iomem *vaddr;\r\nstruct jsm_channel *ch;\r\nif (!brd)\r\nreturn -ENXIO;\r\njsm_printk(INIT, INFO, &brd->pci_dev, "start\n");\r\nbrd->nasync = brd->maxports;\r\nfor (i = 0; i < brd->nasync; i++) {\r\nif (!brd->channels[i]) {\r\nbrd->channels[i] = kzalloc(sizeof(struct jsm_channel), GFP_KERNEL);\r\nif (!brd->channels[i]) {\r\njsm_printk(CORE, ERR, &brd->pci_dev,\r\n"%s:%d Unable to allocate memory for channel struct\n",\r\n__FILE__, __LINE__);\r\n}\r\n}\r\n}\r\nch = brd->channels[0];\r\nvaddr = brd->re_map_membase;\r\nfor (i = 0; i < brd->nasync; i++, ch = brd->channels[i]) {\r\nif (!brd->channels[i])\r\ncontinue;\r\nspin_lock_init(&ch->ch_lock);\r\nif (brd->bd_uart_offset == 0x200)\r\nch->ch_neo_uart = vaddr + (brd->bd_uart_offset * i);\r\nch->ch_bd = brd;\r\nch->ch_portnum = i;\r\nch->ch_close_delay = 250;\r\ninit_waitqueue_head(&ch->ch_flags_wait);\r\n}\r\njsm_printk(INIT, INFO, &brd->pci_dev, "finish\n");\r\nreturn 0;\r\n}\r\nint jsm_uart_port_init(struct jsm_board *brd)\r\n{\r\nint i, rc;\r\nunsigned int line;\r\nstruct jsm_channel *ch;\r\nif (!brd)\r\nreturn -ENXIO;\r\njsm_printk(INIT, INFO, &brd->pci_dev, "start\n");\r\nbrd->nasync = brd->maxports;\r\nfor (i = 0; i < brd->nasync; i++, ch = brd->channels[i]) {\r\nif (!brd->channels[i])\r\ncontinue;\r\nbrd->channels[i]->uart_port.irq = brd->irq;\r\nbrd->channels[i]->uart_port.uartclk = 14745600;\r\nbrd->channels[i]->uart_port.type = PORT_JSM;\r\nbrd->channels[i]->uart_port.iotype = UPIO_MEM;\r\nbrd->channels[i]->uart_port.membase = brd->re_map_membase;\r\nbrd->channels[i]->uart_port.fifosize = 16;\r\nbrd->channels[i]->uart_port.ops = &jsm_ops;\r\nline = find_first_zero_bit(linemap, MAXLINES);\r\nif (line >= MAXLINES) {\r\nprintk(KERN_INFO "jsm: linemap is full, added device failed\n");\r\ncontinue;\r\n} else\r\nset_bit(line, linemap);\r\nbrd->channels[i]->uart_port.line = line;\r\nrc = uart_add_one_port (&jsm_uart_driver, &brd->channels[i]->uart_port);\r\nif (rc){\r\nprintk(KERN_INFO "jsm: Port %d failed. Aborting...\n", i);\r\nreturn rc;\r\n}\r\nelse\r\nprintk(KERN_INFO "jsm: Port %d added\n", i);\r\n}\r\njsm_printk(INIT, INFO, &brd->pci_dev, "finish\n");\r\nreturn 0;\r\n}\r\nint jsm_remove_uart_port(struct jsm_board *brd)\r\n{\r\nint i;\r\nstruct jsm_channel *ch;\r\nif (!brd)\r\nreturn -ENXIO;\r\njsm_printk(INIT, INFO, &brd->pci_dev, "start\n");\r\nbrd->nasync = brd->maxports;\r\nfor (i = 0; i < brd->nasync; i++) {\r\nif (!brd->channels[i])\r\ncontinue;\r\nch = brd->channels[i];\r\nclear_bit(ch->uart_port.line, linemap);\r\nuart_remove_one_port(&jsm_uart_driver, &brd->channels[i]->uart_port);\r\n}\r\njsm_printk(INIT, INFO, &brd->pci_dev, "finish\n");\r\nreturn 0;\r\n}\r\nvoid jsm_input(struct jsm_channel *ch)\r\n{\r\nstruct jsm_board *bd;\r\nstruct tty_struct *tp;\r\nu32 rmask;\r\nu16 head;\r\nu16 tail;\r\nint data_len;\r\nunsigned long lock_flags;\r\nint len = 0;\r\nint n = 0;\r\nint s = 0;\r\nint i = 0;\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev, "start\n");\r\nif (!ch)\r\nreturn;\r\ntp = ch->uart_port.state->port.tty;\r\nbd = ch->ch_bd;\r\nif(!bd)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nrmask = RQUEUEMASK;\r\nhead = ch->ch_r_head & rmask;\r\ntail = ch->ch_r_tail & rmask;\r\ndata_len = (head - tail) & rmask;\r\nif (data_len == 0) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev, "start\n");\r\nif (!tp ||\r\n!(tp->termios->c_cflag & CREAD) ) {\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev,\r\n"input. dropping %d bytes on port %d...\n", data_len, ch->ch_portnum);\r\nch->ch_r_head = tail;\r\njsm_check_queue_flow_control(ch);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\nif (ch->ch_flags & CH_STOPI) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev,\r\n"Port %d throttled, not reading any data. head: %x tail: %x\n",\r\nch->ch_portnum, head, tail);\r\nreturn;\r\n}\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev, "start 2\n");\r\nif (data_len <= 0) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev, "jsm_input 1\n");\r\nreturn;\r\n}\r\nlen = tty_buffer_request_room(tp, data_len);\r\nn = len;\r\nwhile (n) {\r\ns = ((head >= tail) ? head : RQUEUESIZE) - tail;\r\ns = min(s, n);\r\nif (s <= 0)\r\nbreak;\r\nif (I_PARMRK(tp) || I_BRKINT(tp) || I_INPCK(tp)) {\r\nfor (i = 0; i < s; i++) {\r\nif (*(ch->ch_equeue +tail +i) & UART_LSR_BI)\r\ntty_insert_flip_char(tp, *(ch->ch_rqueue +tail +i), TTY_BREAK);\r\nelse if (*(ch->ch_equeue +tail +i) & UART_LSR_PE)\r\ntty_insert_flip_char(tp, *(ch->ch_rqueue +tail +i), TTY_PARITY);\r\nelse if (*(ch->ch_equeue +tail +i) & UART_LSR_FE)\r\ntty_insert_flip_char(tp, *(ch->ch_rqueue +tail +i), TTY_FRAME);\r\nelse\r\ntty_insert_flip_char(tp, *(ch->ch_rqueue +tail +i), TTY_NORMAL);\r\n}\r\n} else {\r\ntty_insert_flip_string(tp, ch->ch_rqueue + tail, s) ;\r\n}\r\ntail += s;\r\nn -= s;\r\ntail &= rmask;\r\n}\r\nch->ch_r_tail = tail & rmask;\r\nch->ch_e_tail = tail & rmask;\r\njsm_check_queue_flow_control(ch);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\ntty_flip_buffer_push(tp);\r\njsm_printk(IOCTL, INFO, &ch->ch_bd->pci_dev, "finish\n");\r\n}\r\nstatic void jsm_carrier(struct jsm_channel *ch)\r\n{\r\nstruct jsm_board *bd;\r\nint virt_carrier = 0;\r\nint phys_carrier = 0;\r\njsm_printk(CARR, INFO, &ch->ch_bd->pci_dev, "start\n");\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nif (ch->ch_mistat & UART_MSR_DCD) {\r\njsm_printk(CARR, INFO, &ch->ch_bd->pci_dev,\r\n"mistat: %x D_CD: %x\n", ch->ch_mistat, ch->ch_mistat & UART_MSR_DCD);\r\nphys_carrier = 1;\r\n}\r\nif (ch->ch_c_cflag & CLOCAL)\r\nvirt_carrier = 1;\r\njsm_printk(CARR, INFO, &ch->ch_bd->pci_dev,\r\n"DCD: physical: %d virt: %d\n", phys_carrier, virt_carrier);\r\nif (((ch->ch_flags & CH_FCAR) == 0) && (virt_carrier == 1)) {\r\njsm_printk(CARR, INFO, &ch->ch_bd->pci_dev,\r\n"carrier: virt DCD rose\n");\r\nif (waitqueue_active(&(ch->ch_flags_wait)))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\nif (((ch->ch_flags & CH_CD) == 0) && (phys_carrier == 1)) {\r\njsm_printk(CARR, INFO, &ch->ch_bd->pci_dev,\r\n"carrier: physical DCD rose\n");\r\nif (waitqueue_active(&(ch->ch_flags_wait)))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\nif ((virt_carrier == 0) && ((ch->ch_flags & CH_CD) != 0)\r\n&& (phys_carrier == 0)) {\r\nif (waitqueue_active(&(ch->ch_flags_wait)))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\nif (virt_carrier == 1)\r\nch->ch_flags |= CH_FCAR;\r\nelse\r\nch->ch_flags &= ~CH_FCAR;\r\nif (phys_carrier == 1)\r\nch->ch_flags |= CH_CD;\r\nelse\r\nch->ch_flags &= ~CH_CD;\r\n}\r\nvoid jsm_check_queue_flow_control(struct jsm_channel *ch)\r\n{\r\nstruct board_ops *bd_ops = ch->ch_bd->bd_ops;\r\nint qleft;\r\nif ((qleft = ch->ch_r_tail - ch->ch_r_head - 1) < 0)\r\nqleft += RQUEUEMASK + 1;\r\nif (qleft < 256) {\r\nif (ch->ch_c_cflag & CRTSCTS) {\r\nif(!(ch->ch_flags & CH_RECEIVER_OFF)) {\r\nbd_ops->disable_receiver(ch);\r\nch->ch_flags |= (CH_RECEIVER_OFF);\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev,\r\n"Internal queue hit hilevel mark (%d)! Turning off interrupts.\n",\r\nqleft);\r\n}\r\n}\r\nelse if (ch->ch_c_iflag & IXOFF) {\r\nif (ch->ch_stops_sent <= MAX_STOPS_SENT) {\r\nbd_ops->send_stop_character(ch);\r\nch->ch_stops_sent++;\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev,\r\n"Sending stop char! Times sent: %x\n", ch->ch_stops_sent);\r\n}\r\n}\r\n}\r\nif (qleft > (RQUEUESIZE / 2)) {\r\nif (ch->ch_c_cflag & CRTSCTS) {\r\nif (ch->ch_flags & CH_RECEIVER_OFF) {\r\nbd_ops->enable_receiver(ch);\r\nch->ch_flags &= ~(CH_RECEIVER_OFF);\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev,\r\n"Internal queue hit lowlevel mark (%d)! Turning on interrupts.\n",\r\nqleft);\r\n}\r\n}\r\nelse if (ch->ch_c_iflag & IXOFF && ch->ch_stops_sent) {\r\nch->ch_stops_sent = 0;\r\nbd_ops->send_start_character(ch);\r\njsm_printk(READ, INFO, &ch->ch_bd->pci_dev, "Sending start char!\n");\r\n}\r\n}\r\n}\r\nint jsm_tty_write(struct uart_port *port)\r\n{\r\nint bufcount;\r\nint data_count = 0,data_count1 =0;\r\nu16 head;\r\nu16 tail;\r\nu16 tmask;\r\nu32 remain;\r\nint temp_tail = port->state->xmit.tail;\r\nstruct jsm_channel *channel = (struct jsm_channel *)port;\r\ntmask = WQUEUEMASK;\r\nhead = (channel->ch_w_head) & tmask;\r\ntail = (channel->ch_w_tail) & tmask;\r\nif ((bufcount = tail - head - 1) < 0)\r\nbufcount += WQUEUESIZE;\r\nbufcount = min(bufcount, 56);\r\nremain = WQUEUESIZE - head;\r\ndata_count = 0;\r\nif (bufcount >= remain) {\r\nbufcount -= remain;\r\nwhile ((port->state->xmit.head != temp_tail) &&\r\n(data_count < remain)) {\r\nchannel->ch_wqueue[head++] =\r\nport->state->xmit.buf[temp_tail];\r\ntemp_tail++;\r\ntemp_tail &= (UART_XMIT_SIZE - 1);\r\ndata_count++;\r\n}\r\nif (data_count == remain) head = 0;\r\n}\r\ndata_count1 = 0;\r\nif (bufcount > 0) {\r\nremain = bufcount;\r\nwhile ((port->state->xmit.head != temp_tail) &&\r\n(data_count1 < remain)) {\r\nchannel->ch_wqueue[head++] =\r\nport->state->xmit.buf[temp_tail];\r\ntemp_tail++;\r\ntemp_tail &= (UART_XMIT_SIZE - 1);\r\ndata_count1++;\r\n}\r\n}\r\nport->state->xmit.tail = temp_tail;\r\ndata_count += data_count1;\r\nif (data_count) {\r\nhead &= tmask;\r\nchannel->ch_w_head = head;\r\n}\r\nif (data_count) {\r\nchannel->ch_bd->bd_ops->copy_data_from_queue_to_uart(channel);\r\n}\r\nreturn data_count;\r\n}
