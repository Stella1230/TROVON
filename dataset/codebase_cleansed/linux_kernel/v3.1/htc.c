void HTCFreeControlBuffer(struct htc_target *target, struct htc_packet *pPacket, struct htc_packet_queue *pList)\r\n{\r\nLOCK_HTC(target);\r\nHTC_PACKET_ENQUEUE(pList,pPacket);\r\nUNLOCK_HTC(target);\r\n}\r\nstruct htc_packet *HTCAllocControlBuffer(struct htc_target *target, struct htc_packet_queue *pList)\r\n{\r\nstruct htc_packet *pPacket;\r\nLOCK_HTC(target);\r\npPacket = HTC_PACKET_DEQUEUE(pList);\r\nUNLOCK_HTC(target);\r\nreturn pPacket;\r\n}\r\nstatic void HTCCleanup(struct htc_target *target)\r\n{\r\ns32 i;\r\nDevCleanup(&target->Device);\r\nfor (i = 0;i < NUM_CONTROL_BUFFERS;i++) {\r\nif (target->HTCControlBuffers[i].Buffer) {\r\nkfree(target->HTCControlBuffers[i].Buffer);\r\n}\r\n}\r\nif (A_IS_MUTEX_VALID(&target->HTCLock)) {\r\nA_MUTEX_DELETE(&target->HTCLock);\r\n}\r\nif (A_IS_MUTEX_VALID(&target->HTCRxLock)) {\r\nA_MUTEX_DELETE(&target->HTCRxLock);\r\n}\r\nif (A_IS_MUTEX_VALID(&target->HTCTxLock)) {\r\nA_MUTEX_DELETE(&target->HTCTxLock);\r\n}\r\nkfree(target);\r\n}\r\nHTC_HANDLE HTCCreate(void *hif_handle, struct htc_init_info *pInfo)\r\n{\r\nstruct htc_target *target = NULL;\r\nint status = 0;\r\nint i;\r\nu32 ctrl_bufsz;\r\nu32 blocksizes[HTC_MAILBOX_NUM_MAX];\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCCreate - Enter\n"));\r\nA_REGISTER_MODULE_DEBUG_INFO(htc);\r\ndo {\r\nif ((target = (struct htc_target *)A_MALLOC(sizeof(struct htc_target))) == NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to allocate memory\n"));\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\nA_MEMZERO(target, sizeof(struct htc_target));\r\nA_MUTEX_INIT(&target->HTCLock);\r\nA_MUTEX_INIT(&target->HTCRxLock);\r\nA_MUTEX_INIT(&target->HTCTxLock);\r\nINIT_HTC_PACKET_QUEUE(&target->ControlBufferTXFreeList);\r\nINIT_HTC_PACKET_QUEUE(&target->ControlBufferRXFreeList);\r\ntarget->Device.HIFDevice = hif_handle;\r\ntarget->Device.HTCContext = target;\r\ntarget->Device.TargetFailureCallback = HTCReportFailure;\r\ntarget->Device.MessagePendingCallback = HTCRecvMessagePendingHandler;\r\ntarget->EpWaitingForBuffers = ENDPOINT_MAX;\r\nmemcpy(&target->HTCInitInfo,pInfo,sizeof(struct htc_init_info));\r\nResetEndpointStates(target);\r\nstatus = DevSetup(&target->Device);\r\nif (status) {\r\nbreak;\r\n}\r\nstatus = HIFConfigureDevice(hif_handle, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,\r\nblocksizes, sizeof(blocksizes));\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to get block size info from HIF layer...\n"));\r\nbreak;\r\n}\r\nif (blocksizes[1] > HTC_MAX_CONTROL_MESSAGE_LENGTH) {\r\nctrl_bufsz = blocksizes[1] + HTC_HDR_LENGTH;\r\n} else {\r\nctrl_bufsz = HTC_MAX_CONTROL_MESSAGE_LENGTH + HTC_HDR_LENGTH;\r\n}\r\nfor (i = 0;i < NUM_CONTROL_BUFFERS;i++) {\r\ntarget->HTCControlBuffers[i].Buffer = A_MALLOC(ctrl_bufsz);\r\nif (target->HTCControlBuffers[i].Buffer == NULL) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to allocate memory\n"));\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\nfor (i = 0; i < NUM_CONTROL_RX_BUFFERS; i++) {\r\nstruct htc_packet *pControlPacket;\r\npControlPacket = &target->HTCControlBuffers[i].HtcPacket;\r\nSET_HTC_PACKET_INFO_RX_REFILL(pControlPacket,\r\ntarget,\r\ntarget->HTCControlBuffers[i].Buffer,\r\nctrl_bufsz,\r\nENDPOINT_0);\r\nHTC_FREE_CONTROL_RX(target,pControlPacket);\r\n}\r\nfor (;i < NUM_CONTROL_BUFFERS;i++) {\r\nstruct htc_packet *pControlPacket;\r\npControlPacket = &target->HTCControlBuffers[i].HtcPacket;\r\nINIT_HTC_PACKET_INFO(pControlPacket,\r\ntarget->HTCControlBuffers[i].Buffer,\r\nctrl_bufsz);\r\nHTC_FREE_CONTROL_TX(target,pControlPacket);\r\n}\r\n} while (false);\r\nif (status) {\r\nif (target != NULL) {\r\nHTCCleanup(target);\r\ntarget = NULL;\r\n}\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCCreate - Exit\n"));\r\nreturn target;\r\n}\r\nvoid HTCDestroy(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCDestroy .. Destroying :0x%lX \n",(unsigned long)target));\r\nHTCCleanup(target);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCDestroy \n"));\r\n}\r\nvoid *HTCGetHifDevice(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nreturn target->Device.HIFDevice;\r\n}\r\nint HTCWaitTarget(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nint status;\r\nstruct htc_packet *pPacket = NULL;\r\nHTC_READY_EX_MSG *pRdyMsg;\r\nstruct htc_service_connect_req connect;\r\nstruct htc_service_connect_resp resp;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCWaitTarget - Enter (target:0x%lX) \n", (unsigned long)target));\r\ndo {\r\n#ifdef MBOXHW_UNIT_TEST\r\nstatus = DoMboxHWTest(&target->Device);\r\nif (status) {\r\nbreak;\r\n}\r\n#endif\r\nstatus = HTCWaitforControlMessage(target, &pPacket);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" Target Not Available!!\n"));\r\nbreak;\r\n}\r\npRdyMsg = (HTC_READY_EX_MSG *)pPacket->pBuffer;\r\nif ((pRdyMsg->Version2_0_Info.MessageID != HTC_MSG_READY_ID) ||\r\n(pPacket->ActualLength < sizeof(HTC_READY_MSG))) {\r\nAR_DEBUG_ASSERT(false);\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\nif (pRdyMsg->Version2_0_Info.CreditCount == 0 || pRdyMsg->Version2_0_Info.CreditSize == 0) {\r\nAR_DEBUG_ASSERT(false);\r\nstatus = A_EPROTO;\r\nbreak;\r\n}\r\ntarget->TargetCredits = pRdyMsg->Version2_0_Info.CreditCount;\r\ntarget->TargetCreditSize = pRdyMsg->Version2_0_Info.CreditSize;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, (" Target Ready: credits: %d credit size: %d\n",\r\ntarget->TargetCredits, target->TargetCreditSize));\r\nif (pPacket->ActualLength >= sizeof(HTC_READY_EX_MSG)) {\r\ntarget->HTCTargetVersion = pRdyMsg->HTCVersion;\r\ntarget->MaxMsgPerBundle = pRdyMsg->MaxMsgsPerHTCBundle;\r\n} else {\r\ntarget->HTCTargetVersion = HTC_VERSION_2P0;\r\ntarget->MaxMsgPerBundle = 0;\r\n}\r\n#ifdef HTC_FORCE_LEGACY_2P0\r\ntarget->HTCTargetVersion = HTC_VERSION_2P0;\r\ntarget->MaxMsgPerBundle = 0;\r\n#endif\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,\r\n("Using HTC Protocol Version : %s (%d)\n ",\r\n(target->HTCTargetVersion == HTC_VERSION_2P0) ? "2.0" : ">= 2.1",\r\ntarget->HTCTargetVersion));\r\nif (target->MaxMsgPerBundle > 0) {\r\ntarget->MaxMsgPerBundle = min(HTC_HOST_MAX_MSG_PER_BUNDLE, target->MaxMsgPerBundle);\r\nif (DevSetupMsgBundling(&target->Device,target->MaxMsgPerBundle)) {\r\ntarget->MaxMsgPerBundle = 0;\r\n} else {\r\ntarget->MaxMsgPerBundle = min(DEV_GET_MAX_MSG_PER_BUNDLE(&target->Device),\r\ntarget->MaxMsgPerBundle);\r\n}\r\n}\r\nif (target->MaxMsgPerBundle > 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC,\r\n(" HTC bundling allowed. Max Msg Per HTC Bundle: %d\n", target->MaxMsgPerBundle));\r\nif (DEV_GET_MAX_BUNDLE_SEND_LENGTH(&target->Device) != 0) {\r\ntarget->SendBundlingEnabled = true;\r\n}\r\nif (DEV_GET_MAX_BUNDLE_RECV_LENGTH(&target->Device) != 0) {\r\ntarget->RecvBundlingEnabled = true;\r\n}\r\nif (!DEV_IS_LEN_BLOCK_ALIGNED(&target->Device,target->TargetCreditSize)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, ("*** Credit size: %d is not block aligned! Disabling send bundling \n",\r\ntarget->TargetCreditSize));\r\ntarget->SendBundlingEnabled = false;\r\n}\r\n}\r\nA_MEMZERO(&connect,sizeof(connect));\r\nA_MEMZERO(&resp,sizeof(resp));\r\nconnect.EpCallbacks.pContext = target;\r\nconnect.EpCallbacks.EpTxComplete = HTCControlTxComplete;\r\nconnect.EpCallbacks.EpRecv = HTCControlRecv;\r\nconnect.EpCallbacks.EpRecvRefill = NULL;\r\nconnect.EpCallbacks.EpSendFull = NULL;\r\nconnect.MaxSendQueueDepth = NUM_CONTROL_BUFFERS;\r\nconnect.ServiceID = HTC_CTRL_RSVD_SVC;\r\nstatus = HTCConnectService((HTC_HANDLE)target,\r\n&connect,\r\n&resp);\r\nif (!status) {\r\nbreak;\r\n}\r\n} while (false);\r\nif (pPacket != NULL) {\r\nHTC_FREE_CONTROL_RX(target,pPacket);\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCWaitTarget - Exit\n"));\r\nreturn status;\r\n}\r\nint HTCStart(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nstruct htc_packet *pPacket;\r\nint status;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCStart Enter\n"));\r\nDevDisableInterrupts(&target->Device);\r\ntarget->OpStateFlags = 0;\r\ntarget->RecvStateFlags = 0;\r\nwhile (1) {\r\npPacket = HTC_ALLOC_CONTROL_RX(target);\r\nif (NULL == pPacket) {\r\nbreak;\r\n}\r\nHTCAddReceivePkt((HTC_HANDLE)target,pPacket);\r\n}\r\ndo {\r\nAR_DEBUG_ASSERT(target->InitCredits != NULL);\r\nAR_DEBUG_ASSERT(target->EpCreditDistributionListHead != NULL);\r\nAR_DEBUG_ASSERT(target->EpCreditDistributionListHead->pNext != NULL);\r\ntarget->InitCredits(target->pCredDistContext,\r\ntarget->EpCreditDistributionListHead->pNext,\r\ntarget->TargetCredits);\r\n#ifdef ATH_DEBUG_MODULE\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_TRC)) {\r\nDumpCreditDistStates(target);\r\n}\r\n#endif\r\nstatus = HTCSendSetupComplete(target);\r\nif (status) {\r\nbreak;\r\n}\r\nstatus = DevUnmaskInterrupts(&target->Device);\r\nif (status) {\r\nHTCStop(target);\r\n}\r\n} while (false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCStart Exit\n"));\r\nreturn status;\r\n}\r\nstatic void ResetEndpointStates(struct htc_target *target)\r\n{\r\nstruct htc_endpoint *pEndpoint;\r\nint i;\r\nfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\r\npEndpoint = &target->EndPoint[i];\r\nA_MEMZERO(&pEndpoint->CreditDist, sizeof(pEndpoint->CreditDist));\r\npEndpoint->ServiceID = 0;\r\npEndpoint->MaxMsgLength = 0;\r\npEndpoint->MaxTxQueueDepth = 0;\r\nA_MEMZERO(&pEndpoint->EndPointStats,sizeof(pEndpoint->EndPointStats));\r\nINIT_HTC_PACKET_QUEUE(&pEndpoint->RxBuffers);\r\nINIT_HTC_PACKET_QUEUE(&pEndpoint->TxQueue);\r\nINIT_HTC_PACKET_QUEUE(&pEndpoint->RecvIndicationQueue);\r\npEndpoint->target = target;\r\n}\r\ntarget->EpCreditDistributionListHead = NULL;\r\n}\r\nvoid HTCStop(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCStop \n"));\r\nLOCK_HTC(target);\r\ntarget->OpStateFlags |= HTC_OP_STATE_STOPPING;\r\nUNLOCK_HTC(target);\r\nDevMaskInterrupts(&target->Device);\r\n#ifdef THREAD_X\r\nA_MDELAY(200);\r\n#endif\r\nHTCFlushSendPkts(target);\r\nHTCFlushRecvBuffers(target);\r\nDevCleanupMsgBundling(&target->Device);\r\nResetEndpointStates(target);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCStop \n"));\r\n}\r\nvoid HTCDumpCreditStates(HTC_HANDLE HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nLOCK_HTC_TX(target);\r\nDumpCreditDistStates(target);\r\nUNLOCK_HTC_TX(target);\r\nDumpAR6KDevState(&target->Device);\r\n}\r\nstatic void HTCReportFailure(void *Context)\r\n{\r\nstruct htc_target *target = (struct htc_target *)Context;\r\ntarget->TargetFailure = true;\r\nif (target->HTCInitInfo.TargetFailure != NULL) {\r\ntarget->HTCInitInfo.TargetFailure(target->HTCInitInfo.pContext, A_ERROR);\r\n}\r\n}\r\nbool HTCGetEndpointStatistics(HTC_HANDLE HTCHandle,\r\nHTC_ENDPOINT_ID Endpoint,\r\nHTC_ENDPOINT_STAT_ACTION Action,\r\nstruct htc_endpoint_stats *pStats)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nbool clearStats = false;\r\nbool sample = false;\r\nswitch (Action) {\r\ncase HTC_EP_STAT_SAMPLE :\r\nsample = true;\r\nbreak;\r\ncase HTC_EP_STAT_SAMPLE_AND_CLEAR :\r\nsample = true;\r\nclearStats = true;\r\nbreak;\r\ncase HTC_EP_STAT_CLEAR :\r\nclearStats = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nA_ASSERT(Endpoint < ENDPOINT_MAX);\r\nLOCK_HTC_TX(target);\r\nLOCK_HTC_RX(target);\r\nif (sample) {\r\nA_ASSERT(pStats != NULL);\r\nmemcpy(pStats, &target->EndPoint[Endpoint].EndPointStats, sizeof(struct htc_endpoint_stats));\r\n}\r\nif (clearStats) {\r\nA_MEMZERO(&target->EndPoint[Endpoint].EndPointStats, sizeof(struct htc_endpoint_stats));\r\n}\r\nUNLOCK_HTC_RX(target);\r\nUNLOCK_HTC_TX(target);\r\nreturn true;\r\n}\r\nstruct ar6k_device *HTCGetAR6KDevice(void *HTCHandle)\r\n{\r\nstruct htc_target *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);\r\nreturn &target->Device;\r\n}
