static inline int tps65010_set_gpio_out_value(unsigned gpio, unsigned value)\r\n{\r\nreturn 0;\r\n}\r\nstatic void omap_ohci_clock_power(int on)\r\n{\r\nif (on) {\r\nclk_enable(usb_dc_ck);\r\nclk_enable(usb_host_ck);\r\nudelay(100);\r\n} else {\r\nclk_disable(usb_host_ck);\r\nclk_disable(usb_dc_ck);\r\n}\r\n}\r\nstatic int omap_ohci_transceiver_power(int on)\r\n{\r\nif (on) {\r\nif (machine_is_omap_innovator() && cpu_is_omap1510())\r\nfpga_write(fpga_read(INNOVATOR_FPGA_CAM_USB_CONTROL)\r\n| ((1 << 5) | (1 << 3)),\r\nINNOVATOR_FPGA_CAM_USB_CONTROL);\r\nelse if (machine_is_omap_osk())\r\ntps65010_set_gpio_out_value(GPIO1, LOW);\r\n} else {\r\nif (machine_is_omap_innovator() && cpu_is_omap1510())\r\nfpga_write(fpga_read(INNOVATOR_FPGA_CAM_USB_CONTROL)\r\n& ~((1 << 5) | (1 << 3)),\r\nINNOVATOR_FPGA_CAM_USB_CONTROL);\r\nelse if (machine_is_omap_osk())\r\ntps65010_set_gpio_out_value(GPIO1, HIGH);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_1510_local_bus_power(int on)\r\n{\r\nif (on) {\r\nomap_writel((1 << 1) | (1 << 0), OMAP1510_LB_MMU_CTL);\r\nudelay(200);\r\n} else {\r\nomap_writel(0, OMAP1510_LB_MMU_CTL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_1510_local_bus_init(void)\r\n{\r\nunsigned int tlb;\r\nunsigned long lbaddr, physaddr;\r\nomap_writel((omap_readl(OMAP1510_LB_CLOCK_DIV) & 0xfffffff8) | 0x4,\r\nOMAP1510_LB_CLOCK_DIV);\r\nfor (tlb = 0; tlb < OMAP1510_LB_MEMSIZE; tlb++) {\r\nlbaddr = tlb * 0x00100000 + OMAP1510_LB_OFFSET;\r\nphysaddr = tlb * 0x00100000 + PHYS_OFFSET;\r\nomap_writel((lbaddr & 0x0fffffff) >> 22, OMAP1510_LB_MMU_CAM_H);\r\nomap_writel(((lbaddr & 0x003ffc00) >> 6) | 0xc,\r\nOMAP1510_LB_MMU_CAM_L);\r\nomap_writel(physaddr >> 16, OMAP1510_LB_MMU_RAM_H);\r\nomap_writel((physaddr & 0x0000fc00) | 0x300, OMAP1510_LB_MMU_RAM_L);\r\nomap_writel(tlb << 4, OMAP1510_LB_MMU_LCK);\r\nomap_writel(0x1, OMAP1510_LB_MMU_LD_TLB);\r\n}\r\nomap_writel(omap_readl(OMAP1510_LB_MMU_CTL) | (1 << 3), OMAP1510_LB_MMU_CTL);\r\nudelay(200);\r\nreturn 0;\r\n}\r\nstatic void start_hnp(struct ohci_hcd *ohci)\r\n{\r\nconst unsigned port = ohci_to_hcd(ohci)->self.otg_port - 1;\r\nunsigned long flags;\r\nu32 l;\r\notg_start_hnp(ohci->transceiver);\r\nlocal_irq_save(flags);\r\nohci->transceiver->state = OTG_STATE_A_SUSPEND;\r\nwritel (RH_PS_PSS, &ohci->regs->roothub.portstatus [port]);\r\nl = omap_readl(OTG_CTRL);\r\nl &= ~OTG_A_BUSREQ;\r\nomap_writel(l, OTG_CTRL);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int ohci_omap_init(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct omap_usb_config *config = hcd->self.controller->platform_data;\r\nint need_transceiver = (config->otg != 0);\r\nint ret;\r\ndev_dbg(hcd->self.controller, "starting USB Controller\n");\r\nif (config->otg) {\r\nohci_to_hcd(ohci)->self.otg_port = config->otg;\r\nohci_to_hcd(ohci)->power_budget = 8;\r\n}\r\nneed_transceiver = need_transceiver\r\n|| machine_is_omap_h2() || machine_is_omap_h3();\r\nif (cpu_is_omap16xx())\r\nocpi_enable();\r\n#ifdef CONFIG_USB_OTG\r\nif (need_transceiver) {\r\nohci->transceiver = otg_get_transceiver();\r\nif (ohci->transceiver) {\r\nint status = otg_set_host(ohci->transceiver,\r\n&ohci_to_hcd(ohci)->self);\r\ndev_dbg(hcd->self.controller, "init %s transceiver, status %d\n",\r\nohci->transceiver->label, status);\r\nif (status) {\r\nif (ohci->transceiver)\r\nput_device(ohci->transceiver->dev);\r\nreturn status;\r\n}\r\n} else {\r\ndev_err(hcd->self.controller, "can't find transceiver\n");\r\nreturn -ENODEV;\r\n}\r\nohci->start_hnp = start_hnp;\r\n}\r\n#endif\r\nomap_ohci_clock_power(1);\r\nif (cpu_is_omap15xx()) {\r\nomap_1510_local_bus_power(1);\r\nomap_1510_local_bus_init();\r\n}\r\nif ((ret = ohci_init(ohci)) < 0)\r\nreturn ret;\r\nif (machine_is_omap_osk() || machine_is_omap_innovator()) {\r\nu32 rh = roothub_a (ohci);\r\nrh &= ~RH_A_NPS;\r\nif (machine_is_omap_osk()) {\r\nohci_to_hcd(ohci)->power_budget = 250;\r\nrh &= ~RH_A_NOCP;\r\nomap_cfg_reg(W8_1610_GPIO9);\r\ngpio_request(9, "OHCI overcurrent");\r\ngpio_direction_input(9);\r\nomap_cfg_reg(W4_USB_HIGHZ);\r\n}\r\nohci_writel(ohci, rh, &ohci->regs->roothub.a);\r\nohci->flags &= ~OHCI_QUIRK_HUB_POWER;\r\n} else if (machine_is_nokia770()) {\r\nohci_to_hcd(ohci)->power_budget = 0;\r\n}\r\nomap_ohci_transceiver_power(1);\r\nreturn 0;\r\n}\r\nstatic void ohci_omap_stop(struct usb_hcd *hcd)\r\n{\r\ndev_dbg(hcd->self.controller, "stopping USB Controller\n");\r\nohci_stop(hcd);\r\nomap_ohci_clock_power(0);\r\n}\r\nstatic int usb_hcd_omap_probe (const struct hc_driver *driver,\r\nstruct platform_device *pdev)\r\n{\r\nint retval, irq;\r\nstruct usb_hcd *hcd = 0;\r\nstruct ohci_hcd *ohci;\r\nif (pdev->num_resources != 2) {\r\nprintk(KERN_ERR "hcd probe: invalid num_resources: %i\n",\r\npdev->num_resources);\r\nreturn -ENODEV;\r\n}\r\nif (pdev->resource[0].flags != IORESOURCE_MEM\r\n|| pdev->resource[1].flags != IORESOURCE_IRQ) {\r\nprintk(KERN_ERR "hcd probe: invalid resource type\n");\r\nreturn -ENODEV;\r\n}\r\nusb_host_ck = clk_get(&pdev->dev, "usb_hhc_ck");\r\nif (IS_ERR(usb_host_ck))\r\nreturn PTR_ERR(usb_host_ck);\r\nif (!cpu_is_omap15xx())\r\nusb_dc_ck = clk_get(&pdev->dev, "usb_dc_ck");\r\nelse\r\nusb_dc_ck = clk_get(&pdev->dev, "lb_ck");\r\nif (IS_ERR(usb_dc_ck)) {\r\nclk_put(usb_host_ck);\r\nreturn PTR_ERR(usb_dc_ck);\r\n}\r\nhcd = usb_create_hcd (driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto err0;\r\n}\r\nhcd->rsrc_start = pdev->resource[0].start;\r\nhcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\r\ndev_dbg(&pdev->dev, "request_mem_region failed\n");\r\nretval = -EBUSY;\r\ngoto err1;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\ndev_err(&pdev->dev, "can't ioremap OHCI HCD\n");\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\nohci = hcd_to_ohci(hcd);\r\nohci_hcd_init(ohci);\r\nhost_initialized = 0;\r\nhost_enabled = 1;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nretval = -ENXIO;\r\ngoto err3;\r\n}\r\nretval = usb_add_hcd(hcd, irq, IRQF_DISABLED);\r\nif (retval)\r\ngoto err3;\r\nhost_initialized = 1;\r\nif (!host_enabled)\r\nomap_ohci_clock_power(0);\r\nreturn 0;\r\nerr3:\r\niounmap(hcd->regs);\r\nerr2:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr1:\r\nusb_put_hcd(hcd);\r\nerr0:\r\nclk_put(usb_dc_ck);\r\nclk_put(usb_host_ck);\r\nreturn retval;\r\n}\r\nstatic inline void\r\nusb_hcd_omap_remove (struct usb_hcd *hcd, struct platform_device *pdev)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nusb_remove_hcd(hcd);\r\nif (ohci->transceiver) {\r\n(void) otg_set_host(ohci->transceiver, 0);\r\nput_device(ohci->transceiver->dev);\r\n}\r\nif (machine_is_omap_osk())\r\ngpio_free(9);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\nclk_put(usb_dc_ck);\r\nclk_put(usb_host_ck);\r\n}\r\nstatic int\r\nohci_omap_start (struct usb_hcd *hcd)\r\n{\r\nstruct omap_usb_config *config;\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint ret;\r\nif (!host_enabled)\r\nreturn 0;\r\nconfig = hcd->self.controller->platform_data;\r\nif (config->otg || config->rwc) {\r\nohci->hc_control = OHCI_CTRL_RWC;\r\nwritel(OHCI_CTRL_RWC, &ohci->regs->control);\r\n}\r\nif ((ret = ohci_run (ohci)) < 0) {\r\ndev_err(hcd->self.controller, "can't start\n");\r\nohci_stop (hcd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_omap_drv_probe(struct platform_device *dev)\r\n{\r\nreturn usb_hcd_omap_probe(&ohci_omap_hc_driver, dev);\r\n}\r\nstatic int ohci_hcd_omap_drv_remove(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nusb_hcd_omap_remove(hcd, dev);\r\nplatform_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int ohci_omap_suspend(struct platform_device *dev, pm_message_t message)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(platform_get_drvdata(dev));\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nomap_ohci_clock_power(0);\r\nohci_to_hcd(ohci)->state = HC_STATE_SUSPENDED;\r\nreturn 0;\r\n}\r\nstatic int ohci_omap_resume(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nomap_ohci_clock_power(1);\r\nohci_finish_controller_resume(hcd);\r\nreturn 0;\r\n}
