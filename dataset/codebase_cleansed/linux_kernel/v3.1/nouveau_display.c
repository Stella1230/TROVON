static void\r\nnouveau_user_framebuffer_destroy(struct drm_framebuffer *drm_fb)\r\n{\r\nstruct nouveau_framebuffer *fb = nouveau_framebuffer(drm_fb);\r\nif (fb->nvbo)\r\ndrm_gem_object_unreference_unlocked(fb->nvbo->gem);\r\ndrm_framebuffer_cleanup(drm_fb);\r\nkfree(fb);\r\n}\r\nstatic int\r\nnouveau_user_framebuffer_create_handle(struct drm_framebuffer *drm_fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nstruct nouveau_framebuffer *fb = nouveau_framebuffer(drm_fb);\r\nreturn drm_gem_handle_create(file_priv, fb->nvbo->gem, handle);\r\n}\r\nint\r\nnouveau_framebuffer_init(struct drm_device *dev,\r\nstruct nouveau_framebuffer *nv_fb,\r\nstruct drm_mode_fb_cmd *mode_cmd,\r\nstruct nouveau_bo *nvbo)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct drm_framebuffer *fb = &nv_fb->base;\r\nint ret;\r\nret = drm_framebuffer_init(dev, fb, &nouveau_framebuffer_funcs);\r\nif (ret) {\r\nreturn ret;\r\n}\r\ndrm_helper_mode_fill_fb_struct(fb, mode_cmd);\r\nnv_fb->nvbo = nvbo;\r\nif (dev_priv->card_type >= NV_50) {\r\nu32 tile_flags = nouveau_bo_tile_layout(nvbo);\r\nif (tile_flags == 0x7a00 ||\r\ntile_flags == 0xfe00)\r\nnv_fb->r_dma = NvEvoFB32;\r\nelse\r\nif (tile_flags == 0x7000)\r\nnv_fb->r_dma = NvEvoFB16;\r\nelse\r\nnv_fb->r_dma = NvEvoVRAM_LP;\r\nswitch (fb->depth) {\r\ncase 8: nv_fb->r_format = NV50_EVO_CRTC_FB_DEPTH_8; break;\r\ncase 15: nv_fb->r_format = NV50_EVO_CRTC_FB_DEPTH_15; break;\r\ncase 16: nv_fb->r_format = NV50_EVO_CRTC_FB_DEPTH_16; break;\r\ncase 24:\r\ncase 32: nv_fb->r_format = NV50_EVO_CRTC_FB_DEPTH_24; break;\r\ncase 30: nv_fb->r_format = NV50_EVO_CRTC_FB_DEPTH_30; break;\r\ndefault:\r\nNV_ERROR(dev, "unknown depth %d\n", fb->depth);\r\nreturn -EINVAL;\r\n}\r\nif (dev_priv->chipset == 0x50)\r\nnv_fb->r_format |= (tile_flags << 8);\r\nif (!tile_flags)\r\nnv_fb->r_pitch = 0x00100000 | fb->pitch;\r\nelse {\r\nu32 mode = nvbo->tile_mode;\r\nif (dev_priv->card_type >= NV_C0)\r\nmode >>= 4;\r\nnv_fb->r_pitch = ((fb->pitch / 4) << 4) | mode;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nnouveau_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_mode_fb_cmd *mode_cmd)\r\n{\r\nstruct nouveau_framebuffer *nouveau_fb;\r\nstruct drm_gem_object *gem;\r\nint ret;\r\ngem = drm_gem_object_lookup(dev, file_priv, mode_cmd->handle);\r\nif (!gem)\r\nreturn ERR_PTR(-ENOENT);\r\nnouveau_fb = kzalloc(sizeof(struct nouveau_framebuffer), GFP_KERNEL);\r\nif (!nouveau_fb)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = nouveau_framebuffer_init(dev, nouveau_fb, mode_cmd, nouveau_gem_object(gem));\r\nif (ret) {\r\ndrm_gem_object_unreference(gem);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &nouveau_fb->base;\r\n}\r\nint\r\nnouveau_vblank_enable(struct drm_device *dev, int crtc)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->card_type >= NV_50)\r\nnv_mask(dev, NV50_PDISPLAY_INTR_EN_1, 0,\r\nNV50_PDISPLAY_INTR_EN_1_VBLANK_CRTC_(crtc));\r\nelse\r\nNVWriteCRTC(dev, crtc, NV_PCRTC_INTR_EN_0,\r\nNV_PCRTC_INTR_0_VBLANK);\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_vblank_disable(struct drm_device *dev, int crtc)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->card_type >= NV_50)\r\nnv_mask(dev, NV50_PDISPLAY_INTR_EN_1,\r\nNV50_PDISPLAY_INTR_EN_1_VBLANK_CRTC_(crtc), 0);\r\nelse\r\nNVWriteCRTC(dev, crtc, NV_PCRTC_INTR_EN_0, 0);\r\n}\r\nstatic int\r\nnouveau_page_flip_reserve(struct nouveau_bo *old_bo,\r\nstruct nouveau_bo *new_bo)\r\n{\r\nint ret;\r\nret = nouveau_bo_pin(new_bo, TTM_PL_FLAG_VRAM);\r\nif (ret)\r\nreturn ret;\r\nret = ttm_bo_reserve(&new_bo->bo, false, false, false, 0);\r\nif (ret)\r\ngoto fail;\r\nret = ttm_bo_reserve(&old_bo->bo, false, false, false, 0);\r\nif (ret)\r\ngoto fail_unreserve;\r\nreturn 0;\r\nfail_unreserve:\r\nttm_bo_unreserve(&new_bo->bo);\r\nfail:\r\nnouveau_bo_unpin(new_bo);\r\nreturn ret;\r\n}\r\nstatic void\r\nnouveau_page_flip_unreserve(struct nouveau_bo *old_bo,\r\nstruct nouveau_bo *new_bo,\r\nstruct nouveau_fence *fence)\r\n{\r\nnouveau_bo_fence(new_bo, fence);\r\nttm_bo_unreserve(&new_bo->bo);\r\nnouveau_bo_fence(old_bo, fence);\r\nttm_bo_unreserve(&old_bo->bo);\r\nnouveau_bo_unpin(old_bo);\r\n}\r\nstatic int\r\nnouveau_page_flip_emit(struct nouveau_channel *chan,\r\nstruct nouveau_bo *old_bo,\r\nstruct nouveau_bo *new_bo,\r\nstruct nouveau_page_flip_state *s,\r\nstruct nouveau_fence **pfence)\r\n{\r\nstruct drm_nouveau_private *dev_priv = chan->dev->dev_private;\r\nstruct drm_device *dev = chan->dev;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_add_tail(&s->head, &chan->nvsw.flip);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nret = nouveau_fence_sync(old_bo->bo.sync_obj, chan);\r\nif (ret)\r\ngoto fail;\r\nret = RING_SPACE(chan, 2);\r\nif (ret)\r\ngoto fail;\r\nif (dev_priv->card_type < NV_C0)\r\nBEGIN_RING(chan, NvSubSw, NV_SW_PAGE_FLIP, 1);\r\nelse\r\nBEGIN_NVC0(chan, 2, NvSubM2MF, 0x0500, 1);\r\nOUT_RING (chan, 0);\r\nFIRE_RING (chan);\r\nret = nouveau_fence_new(chan, pfence, true);\r\nif (ret)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_del(&s->head);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn ret;\r\n}\r\nint\r\nnouveau_crtc_page_flip(struct drm_crtc *crtc, struct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_bo *old_bo = nouveau_framebuffer(crtc->fb)->nvbo;\r\nstruct nouveau_bo *new_bo = nouveau_framebuffer(fb)->nvbo;\r\nstruct nouveau_page_flip_state *s;\r\nstruct nouveau_channel *chan;\r\nstruct nouveau_fence *fence;\r\nint ret;\r\nif (!dev_priv->channel)\r\nreturn -ENODEV;\r\ns = kzalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\nret = nouveau_page_flip_reserve(old_bo, new_bo);\r\nif (ret)\r\ngoto fail_free;\r\n*s = (struct nouveau_page_flip_state)\r\n{ { }, event, nouveau_crtc(crtc)->index,\r\nfb->bits_per_pixel, fb->pitch, crtc->x, crtc->y,\r\nnew_bo->bo.offset };\r\nchan = nouveau_fence_channel(new_bo->bo.sync_obj);\r\nif (!chan)\r\nchan = nouveau_channel_get_unlocked(dev_priv->channel);\r\nmutex_lock(&chan->mutex);\r\nif (dev_priv->card_type >= NV_50) {\r\nret = nv50_display_flip_next(crtc, fb, chan);\r\nif (ret) {\r\nnouveau_channel_put(&chan);\r\ngoto fail_unreserve;\r\n}\r\n}\r\nret = nouveau_page_flip_emit(chan, old_bo, new_bo, s, &fence);\r\nnouveau_channel_put(&chan);\r\nif (ret)\r\ngoto fail_unreserve;\r\ncrtc->fb = fb;\r\nnouveau_page_flip_unreserve(old_bo, new_bo, fence);\r\nnouveau_fence_unref(&fence);\r\nreturn 0;\r\nfail_unreserve:\r\nnouveau_page_flip_unreserve(old_bo, new_bo, NULL);\r\nfail_free:\r\nkfree(s);\r\nreturn ret;\r\n}\r\nint\r\nnouveau_finish_page_flip(struct nouveau_channel *chan,\r\nstruct nouveau_page_flip_state *ps)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct nouveau_page_flip_state *s;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (list_empty(&chan->nvsw.flip)) {\r\nNV_ERROR(dev, "Unexpected pageflip in channel %d.\n", chan->id);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn -EINVAL;\r\n}\r\ns = list_first_entry(&chan->nvsw.flip,\r\nstruct nouveau_page_flip_state, head);\r\nif (s->event) {\r\nstruct drm_pending_vblank_event *e = s->event;\r\nstruct timeval now;\r\ndo_gettimeofday(&now);\r\ne->event.sequence = 0;\r\ne->event.tv_sec = now.tv_sec;\r\ne->event.tv_usec = now.tv_usec;\r\nlist_add_tail(&e->base.link, &e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\n}\r\nlist_del(&s->head);\r\nif (ps)\r\n*ps = *s;\r\nkfree(s);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn 0;\r\n}
