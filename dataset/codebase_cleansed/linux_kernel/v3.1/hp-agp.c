static int __init hp_zx1_ioc_shared(void)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nprintk(KERN_INFO PFX "HP ZX1 IOC: IOPDIR shared with sba_iommu\n");\r\nhp->io_tlb_ps = readq(hp->ioc_regs+HP_ZX1_TCNFG);\r\nswitch (hp->io_tlb_ps) {\r\ncase 0: hp->io_tlb_shift = 12; break;\r\ncase 1: hp->io_tlb_shift = 13; break;\r\ncase 2: hp->io_tlb_shift = 14; break;\r\ncase 3: hp->io_tlb_shift = 16; break;\r\ndefault:\r\nprintk(KERN_ERR PFX "Invalid IOTLB page size "\r\n"configuration 0x%x\n", hp->io_tlb_ps);\r\nhp->gatt = NULL;\r\nhp->gatt_entries = 0;\r\nreturn -ENODEV;\r\n}\r\nhp->io_page_size = 1 << hp->io_tlb_shift;\r\nhp->io_pages_per_kpage = PAGE_SIZE / hp->io_page_size;\r\nhp->iova_base = readq(hp->ioc_regs+HP_ZX1_IBASE) & ~0x1;\r\nhp->gart_base = hp->iova_base + HP_ZX1_IOVA_SIZE - HP_ZX1_GART_SIZE;\r\nhp->gart_size = HP_ZX1_GART_SIZE;\r\nhp->gatt_entries = hp->gart_size / hp->io_page_size;\r\nhp->io_pdir = phys_to_virt(readq(hp->ioc_regs+HP_ZX1_PDIR_BASE));\r\nhp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];\r\nif (hp->gatt[0] != HP_ZX1_SBA_IOMMU_COOKIE) {\r\nhp->gatt = NULL;\r\nhp->gatt_entries = 0;\r\nprintk(KERN_ERR PFX "No reserved IO PDIR entry found; "\r\n"GART disabled\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nhp_zx1_ioc_owner (void)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nprintk(KERN_INFO PFX "HP ZX1 IOC: IOPDIR dedicated to GART\n");\r\nif (PAGE_SIZE >= KB(64)) {\r\nhp->io_tlb_shift = 16;\r\nhp->io_tlb_ps = 3;\r\n} else if (PAGE_SIZE >= KB(16)) {\r\nhp->io_tlb_shift = 14;\r\nhp->io_tlb_ps = 2;\r\n} else if (PAGE_SIZE >= KB(8)) {\r\nhp->io_tlb_shift = 13;\r\nhp->io_tlb_ps = 1;\r\n} else {\r\nhp->io_tlb_shift = 12;\r\nhp->io_tlb_ps = 0;\r\n}\r\nhp->io_page_size = 1 << hp->io_tlb_shift;\r\nhp->io_pages_per_kpage = PAGE_SIZE / hp->io_page_size;\r\nhp->iova_base = HP_ZX1_IOVA_BASE;\r\nhp->gart_size = HP_ZX1_GART_SIZE;\r\nhp->gart_base = hp->iova_base + HP_ZX1_IOVA_SIZE - hp->gart_size;\r\nhp->gatt_entries = hp->gart_size / hp->io_page_size;\r\nhp->io_pdir_size = (HP_ZX1_IOVA_SIZE / hp->io_page_size) * sizeof(u64);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nhp_zx1_ioc_init (u64 hpa)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nhp->ioc_regs = ioremap(hpa, 1024);\r\nif (!hp->ioc_regs)\r\nreturn -ENOMEM;\r\nhp->io_pdir_owner = (readq(hp->ioc_regs+HP_ZX1_IBASE) & 0x1) == 0;\r\nif (hp->io_pdir_owner)\r\nreturn hp_zx1_ioc_owner();\r\nreturn hp_zx1_ioc_shared();\r\n}\r\nstatic int\r\nhp_zx1_lba_find_capability (volatile u8 __iomem *hpa, int cap)\r\n{\r\nu16 status;\r\nu8 pos, id;\r\nint ttl = 48;\r\nstatus = readw(hpa+PCI_STATUS);\r\nif (!(status & PCI_STATUS_CAP_LIST))\r\nreturn 0;\r\npos = readb(hpa+PCI_CAPABILITY_LIST);\r\nwhile (ttl-- && pos >= 0x40) {\r\npos &= ~3;\r\nid = readb(hpa+pos+PCI_CAP_LIST_ID);\r\nif (id == 0xff)\r\nbreak;\r\nif (id == cap)\r\nreturn pos;\r\npos = readb(hpa+pos+PCI_CAP_LIST_NEXT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nhp_zx1_lba_init (u64 hpa)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nint cap;\r\nhp->lba_regs = ioremap(hpa, 256);\r\nif (!hp->lba_regs)\r\nreturn -ENOMEM;\r\nhp->lba_cap_offset = hp_zx1_lba_find_capability(hp->lba_regs, PCI_CAP_ID_AGP);\r\ncap = readl(hp->lba_regs+hp->lba_cap_offset) & 0xff;\r\nif (cap != PCI_CAP_ID_AGP) {\r\nprintk(KERN_ERR PFX "Invalid capability ID 0x%02x at 0x%x\n",\r\ncap, hp->lba_cap_offset);\r\niounmap(hp->lba_regs);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nhp_zx1_fetch_size(void)\r\n{\r\nint size;\r\nsize = hp_private.gart_size / MB(1);\r\nhp_zx1_sizes[0].size = size;\r\nagp_bridge->current_size = (void *) &hp_zx1_sizes[0];\r\nreturn size;\r\n}\r\nstatic int\r\nhp_zx1_configure (void)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nagp_bridge->gart_bus_addr = hp->gart_base;\r\nagp_bridge->capndx = hp->lba_cap_offset;\r\nagp_bridge->mode = readl(hp->lba_regs+hp->lba_cap_offset+PCI_AGP_STATUS);\r\nif (hp->io_pdir_owner) {\r\nwritel(virt_to_phys(hp->io_pdir), hp->ioc_regs+HP_ZX1_PDIR_BASE);\r\nreadl(hp->ioc_regs+HP_ZX1_PDIR_BASE);\r\nwritel(hp->io_tlb_ps, hp->ioc_regs+HP_ZX1_TCNFG);\r\nreadl(hp->ioc_regs+HP_ZX1_TCNFG);\r\nwritel((unsigned int)(~(HP_ZX1_IOVA_SIZE-1)), hp->ioc_regs+HP_ZX1_IMASK);\r\nreadl(hp->ioc_regs+HP_ZX1_IMASK);\r\nwritel(hp->iova_base|1, hp->ioc_regs+HP_ZX1_IBASE);\r\nreadl(hp->ioc_regs+HP_ZX1_IBASE);\r\nwritel(hp->iova_base|ilog2(HP_ZX1_IOVA_SIZE), hp->ioc_regs+HP_ZX1_PCOM);\r\nreadl(hp->ioc_regs+HP_ZX1_PCOM);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nhp_zx1_cleanup (void)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nif (hp->ioc_regs) {\r\nif (hp->io_pdir_owner) {\r\nwriteq(0, hp->ioc_regs+HP_ZX1_IBASE);\r\nreadq(hp->ioc_regs+HP_ZX1_IBASE);\r\n}\r\niounmap(hp->ioc_regs);\r\n}\r\nif (hp->lba_regs)\r\niounmap(hp->lba_regs);\r\n}\r\nstatic void\r\nhp_zx1_tlbflush (struct agp_memory *mem)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nwriteq(hp->gart_base | ilog2(hp->gart_size), hp->ioc_regs+HP_ZX1_PCOM);\r\nreadq(hp->ioc_regs+HP_ZX1_PCOM);\r\n}\r\nstatic int\r\nhp_zx1_create_gatt_table (struct agp_bridge_data *bridge)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nint i;\r\nif (hp->io_pdir_owner) {\r\nhp->io_pdir = (u64 *) __get_free_pages(GFP_KERNEL,\r\nget_order(hp->io_pdir_size));\r\nif (!hp->io_pdir) {\r\nprintk(KERN_ERR PFX "Couldn't allocate contiguous "\r\n"memory for I/O PDIR\n");\r\nhp->gatt = NULL;\r\nhp->gatt_entries = 0;\r\nreturn -ENOMEM;\r\n}\r\nmemset(hp->io_pdir, 0, hp->io_pdir_size);\r\nhp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];\r\n}\r\nfor (i = 0; i < hp->gatt_entries; i++) {\r\nhp->gatt[i] = (unsigned long) agp_bridge->scratch_page;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nhp_zx1_free_gatt_table (struct agp_bridge_data *bridge)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nif (hp->io_pdir_owner)\r\nfree_pages((unsigned long) hp->io_pdir,\r\nget_order(hp->io_pdir_size));\r\nelse\r\nhp->gatt[0] = HP_ZX1_SBA_IOMMU_COOKIE;\r\nreturn 0;\r\n}\r\nstatic int\r\nhp_zx1_insert_memory (struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nint i, k;\r\noff_t j, io_pg_start;\r\nint io_pg_count;\r\nif (type != 0 || mem->type != 0) {\r\nreturn -EINVAL;\r\n}\r\nio_pg_start = hp->io_pages_per_kpage * pg_start;\r\nio_pg_count = hp->io_pages_per_kpage * mem->page_count;\r\nif ((io_pg_start + io_pg_count) > hp->gatt_entries) {\r\nreturn -EINVAL;\r\n}\r\nj = io_pg_start;\r\nwhile (j < (io_pg_start + io_pg_count)) {\r\nif (hp->gatt[j]) {\r\nreturn -EBUSY;\r\n}\r\nj++;\r\n}\r\nif (!mem->is_flushed) {\r\nglobal_cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nfor (i = 0, j = io_pg_start; i < mem->page_count; i++) {\r\nunsigned long paddr;\r\npaddr = page_to_phys(mem->pages[i]);\r\nfor (k = 0;\r\nk < hp->io_pages_per_kpage;\r\nk++, j++, paddr += hp->io_page_size) {\r\nhp->gatt[j] = HP_ZX1_PDIR_VALID_BIT | paddr;\r\n}\r\n}\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic int\r\nhp_zx1_remove_memory (struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nint i, io_pg_start, io_pg_count;\r\nif (type != 0 || mem->type != 0) {\r\nreturn -EINVAL;\r\n}\r\nio_pg_start = hp->io_pages_per_kpage * pg_start;\r\nio_pg_count = hp->io_pages_per_kpage * mem->page_count;\r\nfor (i = io_pg_start; i < io_pg_count + io_pg_start; i++) {\r\nhp->gatt[i] = agp_bridge->scratch_page;\r\n}\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nhp_zx1_mask_memory (struct agp_bridge_data *bridge, dma_addr_t addr, int type)\r\n{\r\nreturn HP_ZX1_PDIR_VALID_BIT | addr;\r\n}\r\nstatic void\r\nhp_zx1_enable (struct agp_bridge_data *bridge, u32 mode)\r\n{\r\nstruct _hp_private *hp = &hp_private;\r\nu32 command;\r\ncommand = readl(hp->lba_regs+hp->lba_cap_offset+PCI_AGP_STATUS);\r\ncommand = agp_collect_device_status(bridge, mode, command);\r\ncommand |= 0x00000100;\r\nwritel(command, hp->lba_regs+hp->lba_cap_offset+PCI_AGP_COMMAND);\r\nagp_device_command(command, (mode & AGP8X_MODE) != 0);\r\n}\r\nstatic int __init\r\nhp_zx1_setup (u64 ioc_hpa, u64 lba_hpa)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nint error = 0;\r\nerror = hp_zx1_ioc_init(ioc_hpa);\r\nif (error)\r\ngoto fail;\r\nerror = hp_zx1_lba_init(lba_hpa);\r\nif (error)\r\ngoto fail;\r\nbridge = agp_alloc_bridge();\r\nif (!bridge) {\r\nerror = -ENOMEM;\r\ngoto fail;\r\n}\r\nbridge->driver = &hp_zx1_driver;\r\nfake_bridge_dev.vendor = PCI_VENDOR_ID_HP;\r\nfake_bridge_dev.device = PCI_DEVICE_ID_HP_PCIX_LBA;\r\nbridge->dev = &fake_bridge_dev;\r\nerror = agp_add_bridge(bridge);\r\nfail:\r\nif (error)\r\nhp_zx1_cleanup();\r\nreturn error;\r\n}\r\nstatic acpi_status __init\r\nzx1_gart_probe (acpi_handle obj, u32 depth, void *context, void **ret)\r\n{\r\nacpi_handle handle, parent;\r\nacpi_status status;\r\nstruct acpi_device_info *info;\r\nu64 lba_hpa, sba_hpa, length;\r\nint match;\r\nstatus = hp_acpi_csr_space(obj, &lba_hpa, &length);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nhandle = obj;\r\ndo {\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (ACPI_SUCCESS(status) && (info->valid & ACPI_VALID_HID)) {\r\nmatch = (strcmp(info->hardware_id.string, "HWP0001") == 0);\r\nkfree(info);\r\nif (match) {\r\nstatus = hp_acpi_csr_space(handle, &sba_hpa, &length);\r\nif (ACPI_SUCCESS(status))\r\nbreak;\r\nelse {\r\nprintk(KERN_ERR PFX "Detected HP ZX1 "\r\n"AGP LBA but no IOC.\n");\r\nreturn AE_OK;\r\n}\r\n}\r\n}\r\nstatus = acpi_get_parent(handle, &parent);\r\nhandle = parent;\r\n} while (ACPI_SUCCESS(status));\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nif (hp_zx1_setup(sba_hpa + HP_ZX1_IOC_OFFSET, lba_hpa))\r\nreturn AE_OK;\r\nprintk(KERN_INFO PFX "Detected HP ZX1 %s AGP chipset "\r\n"(ioc=%llx, lba=%llx)\n", (char *)context,\r\nsba_hpa + HP_ZX1_IOC_OFFSET, lba_hpa);\r\nhp_zx1_gart_found = 1;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int __init\r\nagp_hp_init (void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nacpi_get_devices("HWP0003", zx1_gart_probe, "HWP0003", NULL);\r\nif (hp_zx1_gart_found)\r\nreturn 0;\r\nacpi_get_devices("HWP0007", zx1_gart_probe, "HWP0007", NULL);\r\nif (hp_zx1_gart_found)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit\r\nagp_hp_cleanup (void)\r\n{\r\n}
