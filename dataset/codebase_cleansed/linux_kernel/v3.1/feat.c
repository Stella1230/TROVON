static int dccp_hdlr_ccid(struct sock *sk, u64 ccid, bool rx)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct ccid *new_ccid = ccid_new(ccid, sk, rx);\r\nif (new_ccid == NULL)\r\nreturn -ENOMEM;\r\nif (rx) {\r\nccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\r\ndp->dccps_hc_rx_ccid = new_ccid;\r\n} else {\r\nccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\r\ndp->dccps_hc_tx_ccid = new_ccid;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dccp_hdlr_seq_win(struct sock *sk, u64 seq_win, bool rx)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nif (rx) {\r\ndp->dccps_r_seq_win = seq_win;\r\ndccp_update_gsr(sk, dp->dccps_gsr);\r\n} else {\r\ndp->dccps_l_seq_win = seq_win;\r\ndccp_update_gss(sk, dp->dccps_gss);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dccp_hdlr_ack_ratio(struct sock *sk, u64 ratio, bool rx)\r\n{\r\nif (rx)\r\ndccp_sk(sk)->dccps_r_ack_ratio = ratio;\r\nelse\r\ndccp_sk(sk)->dccps_l_ack_ratio = ratio;\r\nreturn 0;\r\n}\r\nstatic int dccp_hdlr_ackvec(struct sock *sk, u64 enable, bool rx)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nif (rx) {\r\nif (enable && dp->dccps_hc_rx_ackvec == NULL) {\r\ndp->dccps_hc_rx_ackvec = dccp_ackvec_alloc(gfp_any());\r\nif (dp->dccps_hc_rx_ackvec == NULL)\r\nreturn -ENOMEM;\r\n} else if (!enable) {\r\ndccp_ackvec_free(dp->dccps_hc_rx_ackvec);\r\ndp->dccps_hc_rx_ackvec = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dccp_hdlr_ndp(struct sock *sk, u64 enable, bool rx)\r\n{\r\nif (!rx)\r\ndccp_sk(sk)->dccps_send_ndp_count = (enable > 0);\r\nreturn 0;\r\n}\r\nstatic int dccp_hdlr_min_cscov(struct sock *sk, u64 cscov, bool rx)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nif (rx)\r\ndp->dccps_pcrlen = cscov;\r\nelse {\r\nif (dp->dccps_pcslen == 0)\r\ndp->dccps_pcslen = cscov;\r\nelse if (cscov > dp->dccps_pcslen)\r\nDCCP_WARN("CsCov %u too small, peer requires >= %u\n",\r\ndp->dccps_pcslen, (u8)cscov);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dccp_feat_index(u8 feat_num)\r\n{\r\nif (feat_num > DCCPF_RESERVED && feat_num <= DCCPF_DATA_CHECKSUM)\r\nreturn feat_num - 1;\r\nswitch (feat_num) {\r\ncase DCCPF_SEND_LEV_RATE:\r\nreturn DCCP_FEAT_SUPPORTED_MAX - 1;\r\n}\r\nreturn -1;\r\n}\r\nstatic u8 dccp_feat_type(u8 feat_num)\r\n{\r\nint idx = dccp_feat_index(feat_num);\r\nif (idx < 0)\r\nreturn FEAT_UNKNOWN;\r\nreturn dccp_feat_table[idx].reconciliation;\r\n}\r\nstatic int dccp_feat_default_value(u8 feat_num)\r\n{\r\nint idx = dccp_feat_index(feat_num);\r\nDCCP_BUG_ON(idx < 0);\r\nreturn idx < 0 ? 0 : dccp_feat_table[idx].default_value;\r\n}\r\nstatic const char *dccp_feat_fname(const u8 feat)\r\n{\r\nstatic const char *const feature_names[] = {\r\n[DCCPF_RESERVED] = "Reserved",\r\n[DCCPF_CCID] = "CCID",\r\n[DCCPF_SHORT_SEQNOS] = "Allow Short Seqnos",\r\n[DCCPF_SEQUENCE_WINDOW] = "Sequence Window",\r\n[DCCPF_ECN_INCAPABLE] = "ECN Incapable",\r\n[DCCPF_ACK_RATIO] = "Ack Ratio",\r\n[DCCPF_SEND_ACK_VECTOR] = "Send ACK Vector",\r\n[DCCPF_SEND_NDP_COUNT] = "Send NDP Count",\r\n[DCCPF_MIN_CSUM_COVER] = "Min. Csum Coverage",\r\n[DCCPF_DATA_CHECKSUM] = "Send Data Checksum",\r\n};\r\nif (feat > DCCPF_DATA_CHECKSUM && feat < DCCPF_MIN_CCID_SPECIFIC)\r\nreturn feature_names[DCCPF_RESERVED];\r\nif (feat == DCCPF_SEND_LEV_RATE)\r\nreturn "Send Loss Event Rate";\r\nif (feat >= DCCPF_MIN_CCID_SPECIFIC)\r\nreturn "CCID-specific";\r\nreturn feature_names[feat];\r\n}\r\nstatic const char *dccp_feat_oname(const u8 opt)\r\n{\r\nswitch (opt) {\r\ncase DCCPO_CHANGE_L: return "Change_L";\r\ncase DCCPO_CONFIRM_L: return "Confirm_L";\r\ncase DCCPO_CHANGE_R: return "Change_R";\r\ncase DCCPO_CONFIRM_R: return "Confirm_R";\r\n}\r\nreturn NULL;\r\n}\r\nstatic void dccp_feat_printval(u8 feat_num, dccp_feat_val const *val)\r\n{\r\nu8 i, type = dccp_feat_type(feat_num);\r\nif (val == NULL || (type == FEAT_SP && val->sp.vec == NULL))\r\ndccp_pr_debug_cat("(NULL)");\r\nelse if (type == FEAT_SP)\r\nfor (i = 0; i < val->sp.len; i++)\r\ndccp_pr_debug_cat("%s%u", i ? " " : "", val->sp.vec[i]);\r\nelse if (type == FEAT_NN)\r\ndccp_pr_debug_cat("%llu", (unsigned long long)val->nn);\r\nelse\r\ndccp_pr_debug_cat("unknown type %u", type);\r\n}\r\nstatic void dccp_feat_printvals(u8 feat_num, u8 *list, u8 len)\r\n{\r\nu8 type = dccp_feat_type(feat_num);\r\ndccp_feat_val fval = { .sp.vec = list, .sp.len = len };\r\nif (type == FEAT_NN)\r\nfval.nn = dccp_decode_value_var(list, len);\r\ndccp_feat_printval(feat_num, &fval);\r\n}\r\nstatic void dccp_feat_print_entry(struct dccp_feat_entry const *entry)\r\n{\r\ndccp_debug(" * %s %s = ", entry->is_local ? "local" : "remote",\r\ndccp_feat_fname(entry->feat_num));\r\ndccp_feat_printval(entry->feat_num, &entry->val);\r\ndccp_pr_debug_cat(", state=%s %s\n", dccp_feat_sname[entry->state],\r\nentry->needs_confirm ? "(Confirm pending)" : "");\r\n}\r\nstatic int __dccp_feat_activate(struct sock *sk, const int idx,\r\nconst bool is_local, dccp_feat_val const *fval)\r\n{\r\nbool rx;\r\nu64 val;\r\nif (idx < 0 || idx >= DCCP_FEAT_SUPPORTED_MAX)\r\nreturn -1;\r\nif (dccp_feat_table[idx].activation_hdlr == NULL)\r\nreturn 0;\r\nif (fval == NULL) {\r\nval = dccp_feat_table[idx].default_value;\r\n} else if (dccp_feat_table[idx].reconciliation == FEAT_SP) {\r\nif (fval->sp.vec == NULL) {\r\nDCCP_CRIT("Feature #%d undefined: using default", idx);\r\nval = dccp_feat_table[idx].default_value;\r\n} else {\r\nval = fval->sp.vec[0];\r\n}\r\n} else {\r\nval = fval->nn;\r\n}\r\nrx = (is_local == (dccp_feat_table[idx].rxtx == FEAT_AT_RX));\r\ndccp_debug(" -> activating %s %s, %sval=%llu\n", rx ? "RX" : "TX",\r\ndccp_feat_fname(dccp_feat_table[idx].feat_num),\r\nfval ? "" : "default ", (unsigned long long)val);\r\nreturn dccp_feat_table[idx].activation_hdlr(sk, val, rx);\r\n}\r\nstatic inline int dccp_feat_must_be_understood(u8 feat_num)\r\n{\r\nreturn feat_num == DCCPF_CCID || feat_num == DCCPF_SHORT_SEQNOS ||\r\nfeat_num == DCCPF_SEQUENCE_WINDOW;\r\n}\r\nstatic int dccp_feat_clone_sp_val(dccp_feat_val *fval, u8 const *val, u8 len)\r\n{\r\nfval->sp.len = len;\r\nif (fval->sp.len > 0) {\r\nfval->sp.vec = kmemdup(val, len, gfp_any());\r\nif (fval->sp.vec == NULL) {\r\nfval->sp.len = 0;\r\nreturn -ENOBUFS;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dccp_feat_val_destructor(u8 feat_num, dccp_feat_val *val)\r\n{\r\nif (unlikely(val == NULL))\r\nreturn;\r\nif (dccp_feat_type(feat_num) == FEAT_SP)\r\nkfree(val->sp.vec);\r\nmemset(val, 0, sizeof(*val));\r\n}\r\nstatic struct dccp_feat_entry *\r\ndccp_feat_clone_entry(struct dccp_feat_entry const *original)\r\n{\r\nstruct dccp_feat_entry *new;\r\nu8 type = dccp_feat_type(original->feat_num);\r\nif (type == FEAT_UNKNOWN)\r\nreturn NULL;\r\nnew = kmemdup(original, sizeof(struct dccp_feat_entry), gfp_any());\r\nif (new == NULL)\r\nreturn NULL;\r\nif (type == FEAT_SP && dccp_feat_clone_sp_val(&new->val,\r\noriginal->val.sp.vec,\r\noriginal->val.sp.len)) {\r\nkfree(new);\r\nreturn NULL;\r\n}\r\nreturn new;\r\n}\r\nstatic void dccp_feat_entry_destructor(struct dccp_feat_entry *entry)\r\n{\r\nif (entry != NULL) {\r\ndccp_feat_val_destructor(entry->feat_num, &entry->val);\r\nkfree(entry);\r\n}\r\n}\r\nstatic struct dccp_feat_entry *dccp_feat_list_lookup(struct list_head *fn_list,\r\nu8 feat_num, bool is_local)\r\n{\r\nstruct dccp_feat_entry *entry;\r\nlist_for_each_entry(entry, fn_list, node) {\r\nif (entry->feat_num == feat_num && entry->is_local == is_local)\r\nreturn entry;\r\nelse if (entry->feat_num > feat_num)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct dccp_feat_entry *\r\ndccp_feat_entry_new(struct list_head *head, u8 feat, bool local)\r\n{\r\nstruct dccp_feat_entry *entry;\r\nlist_for_each_entry(entry, head, node)\r\nif (entry->feat_num == feat && entry->is_local == local) {\r\ndccp_feat_val_destructor(entry->feat_num, &entry->val);\r\nreturn entry;\r\n} else if (entry->feat_num > feat) {\r\nhead = &entry->node;\r\nbreak;\r\n}\r\nentry = kmalloc(sizeof(*entry), gfp_any());\r\nif (entry != NULL) {\r\nentry->feat_num = feat;\r\nentry->is_local = local;\r\nlist_add_tail(&entry->node, head);\r\n}\r\nreturn entry;\r\n}\r\nstatic int dccp_feat_push_change(struct list_head *fn_list, u8 feat, u8 local,\r\nu8 mandatory, dccp_feat_val *fval)\r\n{\r\nstruct dccp_feat_entry *new = dccp_feat_entry_new(fn_list, feat, local);\r\nif (new == NULL)\r\nreturn -ENOMEM;\r\nnew->feat_num = feat;\r\nnew->is_local = local;\r\nnew->state = FEAT_INITIALISING;\r\nnew->needs_confirm = 0;\r\nnew->empty_confirm = 0;\r\nnew->val = *fval;\r\nnew->needs_mandatory = mandatory;\r\nreturn 0;\r\n}\r\nstatic int dccp_feat_push_confirm(struct list_head *fn_list, u8 feat, u8 local,\r\ndccp_feat_val *fval)\r\n{\r\nstruct dccp_feat_entry *new = dccp_feat_entry_new(fn_list, feat, local);\r\nif (new == NULL)\r\nreturn DCCP_RESET_CODE_TOO_BUSY;\r\nnew->feat_num = feat;\r\nnew->is_local = local;\r\nnew->state = FEAT_STABLE;\r\nnew->needs_confirm = 1;\r\nnew->empty_confirm = (fval == NULL);\r\nnew->val.nn = 0;\r\nif (!new->empty_confirm)\r\nnew->val = *fval;\r\nnew->needs_mandatory = 0;\r\nreturn 0;\r\n}\r\nstatic int dccp_push_empty_confirm(struct list_head *fn_list, u8 feat, u8 local)\r\n{\r\nreturn dccp_feat_push_confirm(fn_list, feat, local, NULL);\r\n}\r\nstatic inline void dccp_feat_list_pop(struct dccp_feat_entry *entry)\r\n{\r\nlist_del(&entry->node);\r\ndccp_feat_entry_destructor(entry);\r\n}\r\nvoid dccp_feat_list_purge(struct list_head *fn_list)\r\n{\r\nstruct dccp_feat_entry *entry, *next;\r\nlist_for_each_entry_safe(entry, next, fn_list, node)\r\ndccp_feat_entry_destructor(entry);\r\nINIT_LIST_HEAD(fn_list);\r\n}\r\nint dccp_feat_clone_list(struct list_head const *from, struct list_head *to)\r\n{\r\nstruct dccp_feat_entry *entry, *new;\r\nINIT_LIST_HEAD(to);\r\nlist_for_each_entry(entry, from, node) {\r\nnew = dccp_feat_clone_entry(entry);\r\nif (new == NULL)\r\ngoto cloning_failed;\r\nlist_add_tail(&new->node, to);\r\n}\r\nreturn 0;\r\ncloning_failed:\r\ndccp_feat_list_purge(to);\r\nreturn -ENOMEM;\r\n}\r\nstatic u8 dccp_feat_valid_nn_length(u8 feat_num)\r\n{\r\nif (feat_num == DCCPF_ACK_RATIO)\r\nreturn 2;\r\nif (feat_num == DCCPF_SEQUENCE_WINDOW)\r\nreturn 6;\r\nreturn 0;\r\n}\r\nstatic u8 dccp_feat_is_valid_nn_val(u8 feat_num, u64 val)\r\n{\r\nswitch (feat_num) {\r\ncase DCCPF_ACK_RATIO:\r\nreturn val <= DCCPF_ACK_RATIO_MAX;\r\ncase DCCPF_SEQUENCE_WINDOW:\r\nreturn val >= DCCPF_SEQ_WMIN && val <= DCCPF_SEQ_WMAX;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 dccp_feat_is_valid_sp_val(u8 feat_num, u8 val)\r\n{\r\nswitch (feat_num) {\r\ncase DCCPF_CCID:\r\nreturn val == DCCPC_CCID2 || val == DCCPC_CCID3;\r\ncase DCCPF_SHORT_SEQNOS:\r\ncase DCCPF_ECN_INCAPABLE:\r\ncase DCCPF_SEND_ACK_VECTOR:\r\ncase DCCPF_SEND_NDP_COUNT:\r\ncase DCCPF_DATA_CHECKSUM:\r\ncase DCCPF_SEND_LEV_RATE:\r\nreturn val < 2;\r\ncase DCCPF_MIN_CSUM_COVER:\r\nreturn val < 16;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 dccp_feat_sp_list_ok(u8 feat_num, u8 const *sp_list, u8 sp_len)\r\n{\r\nif (sp_list == NULL || sp_len < 1)\r\nreturn 0;\r\nwhile (sp_len--)\r\nif (!dccp_feat_is_valid_sp_val(feat_num, *sp_list++))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint dccp_feat_insert_opts(struct dccp_sock *dp, struct dccp_request_sock *dreq,\r\nstruct sk_buff *skb)\r\n{\r\nstruct list_head *fn = dreq ? &dreq->dreq_featneg : &dp->dccps_featneg;\r\nstruct dccp_feat_entry *pos, *next;\r\nu8 opt, type, len, *ptr, nn_in_nbo[DCCP_OPTVAL_MAXLEN];\r\nbool rpt;\r\nlist_for_each_entry_safe_reverse(pos, next, fn, node) {\r\nopt = dccp_feat_genopt(pos);\r\ntype = dccp_feat_type(pos->feat_num);\r\nrpt = false;\r\nif (pos->empty_confirm) {\r\nlen = 0;\r\nptr = NULL;\r\n} else {\r\nif (type == FEAT_SP) {\r\nlen = pos->val.sp.len;\r\nptr = pos->val.sp.vec;\r\nrpt = pos->needs_confirm;\r\n} else if (type == FEAT_NN) {\r\nlen = dccp_feat_valid_nn_length(pos->feat_num);\r\nptr = nn_in_nbo;\r\ndccp_encode_value_var(pos->val.nn, ptr, len);\r\n} else {\r\nDCCP_BUG("unknown feature %u", pos->feat_num);\r\nreturn -1;\r\n}\r\n}\r\ndccp_feat_print_opt(opt, pos->feat_num, ptr, len, 0);\r\nif (dccp_insert_fn_opt(skb, opt, pos->feat_num, ptr, len, rpt))\r\nreturn -1;\r\nif (pos->needs_mandatory && dccp_insert_option_mandatory(skb))\r\nreturn -1;\r\nif (pos->state == FEAT_INITIALISING)\r\npos->state = FEAT_CHANGING;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __feat_register_nn(struct list_head *fn, u8 feat,\r\nu8 mandatory, u64 nn_val)\r\n{\r\ndccp_feat_val fval = { .nn = nn_val };\r\nif (dccp_feat_type(feat) != FEAT_NN ||\r\n!dccp_feat_is_valid_nn_val(feat, nn_val))\r\nreturn -EINVAL;\r\nif (nn_val - (u64)dccp_feat_default_value(feat) == 0)\r\nreturn 0;\r\nreturn dccp_feat_push_change(fn, feat, 1, mandatory, &fval);\r\n}\r\nstatic int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\r\nu8 mandatory, u8 const *sp_val, u8 sp_len)\r\n{\r\ndccp_feat_val fval;\r\nif (dccp_feat_type(feat) != FEAT_SP ||\r\n!dccp_feat_sp_list_ok(feat, sp_val, sp_len))\r\nreturn -EINVAL;\r\nif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\r\nreturn -EOPNOTSUPP;\r\nif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\r\nreturn -ENOMEM;\r\nreturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\r\n}\r\nint dccp_feat_register_sp(struct sock *sk, u8 feat, u8 is_local,\r\nu8 const *list, u8 len)\r\n{\r\nif (sk->sk_state != DCCP_CLOSED)\r\nreturn -EISCONN;\r\nif (dccp_feat_type(feat) != FEAT_SP)\r\nreturn -EINVAL;\r\nreturn __feat_register_sp(&dccp_sk(sk)->dccps_featneg, feat, is_local,\r\n0, list, len);\r\n}\r\nstatic const struct ccid_dependency *dccp_feat_ccid_deps(u8 ccid, bool is_local)\r\n{\r\nstatic const struct ccid_dependency ccid2_dependencies[2][2] = {\r\n{\r\n{\r\n.dependent_feat = DCCPF_SEND_ACK_VECTOR,\r\n.is_local = true,\r\n.is_mandatory = true,\r\n.val = 1\r\n},\r\n{ 0, 0, 0, 0 }\r\n},\r\n{\r\n{\r\n.dependent_feat = DCCPF_SEND_ACK_VECTOR,\r\n.is_local = false,\r\n.is_mandatory = true,\r\n.val = 1\r\n},\r\n{ 0, 0, 0, 0 }\r\n}\r\n};\r\nstatic const struct ccid_dependency ccid3_dependencies[2][5] = {\r\n{\r\n{\r\n.dependent_feat = DCCPF_SEND_ACK_VECTOR,\r\n.is_local = true,\r\n.is_mandatory = false,\r\n.val = 0\r\n},\r\n{\r\n.dependent_feat = DCCPF_SEND_LEV_RATE,\r\n.is_local = true,\r\n.is_mandatory = true,\r\n.val = 1\r\n},\r\n{\r\n.dependent_feat = DCCPF_SEND_NDP_COUNT,\r\n.is_local = false,\r\n.is_mandatory = true,\r\n.val = 1\r\n},\r\n{ 0, 0, 0, 0 },\r\n},\r\n{\r\n{\r\n.dependent_feat = DCCPF_SEND_ACK_VECTOR,\r\n.is_local = false,\r\n.is_mandatory = false,\r\n.val = 0\r\n},\r\n{\r\n.dependent_feat = DCCPF_SEND_LEV_RATE,\r\n.is_local = false,\r\n.is_mandatory = true,\r\n.val = 1\r\n},\r\n{\r\n.dependent_feat = DCCPF_ACK_RATIO,\r\n.is_local = true,\r\n.is_mandatory = false,\r\n.val = 0\r\n},\r\n{\r\n.dependent_feat = DCCPF_SEND_NDP_COUNT,\r\n.is_local = true,\r\n.is_mandatory = false,\r\n.val = 1\r\n},\r\n{ 0, 0, 0, 0 }\r\n}\r\n};\r\nswitch (ccid) {\r\ncase DCCPC_CCID2:\r\nreturn ccid2_dependencies[is_local];\r\ncase DCCPC_CCID3:\r\nreturn ccid3_dependencies[is_local];\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int dccp_feat_propagate_ccid(struct list_head *fn, u8 id, bool is_local)\r\n{\r\nconst struct ccid_dependency *table = dccp_feat_ccid_deps(id, is_local);\r\nint i, rc = (table == NULL);\r\nfor (i = 0; rc == 0 && table[i].dependent_feat != DCCPF_RESERVED; i++)\r\nif (dccp_feat_type(table[i].dependent_feat) == FEAT_SP)\r\nrc = __feat_register_sp(fn, table[i].dependent_feat,\r\ntable[i].is_local,\r\ntable[i].is_mandatory,\r\n&table[i].val, 1);\r\nelse\r\nrc = __feat_register_nn(fn, table[i].dependent_feat,\r\ntable[i].is_mandatory,\r\ntable[i].val);\r\nreturn rc;\r\n}\r\nint dccp_feat_finalise_settings(struct dccp_sock *dp)\r\n{\r\nstruct list_head *fn = &dp->dccps_featneg;\r\nstruct dccp_feat_entry *entry;\r\nint i = 2, ccids[2] = { -1, -1 };\r\nlist_for_each_entry(entry, fn, node)\r\nif (entry->feat_num == DCCPF_CCID && entry->val.sp.len == 1)\r\nccids[entry->is_local] = entry->val.sp.vec[0];\r\nwhile (i--)\r\nif (ccids[i] > 0 && dccp_feat_propagate_ccid(fn, ccids[i], i))\r\nreturn -1;\r\ndccp_feat_print_fnlist(fn);\r\nreturn 0;\r\n}\r\nint dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq)\r\n{\r\nstruct list_head *fn = &dreq->dreq_featneg;\r\nstruct dccp_feat_entry *entry;\r\nu8 is_local, ccid;\r\nfor (is_local = 0; is_local <= 1; is_local++) {\r\nentry = dccp_feat_list_lookup(fn, DCCPF_CCID, is_local);\r\nif (entry != NULL && !entry->empty_confirm)\r\nccid = entry->val.sp.vec[0];\r\nelse\r\nccid = dccp_feat_default_value(DCCPF_CCID);\r\nif (dccp_feat_propagate_ccid(fn, ccid, is_local))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dccp_feat_preflist_match(u8 *servlist, u8 slen, u8 *clilist, u8 clen)\r\n{\r\nu8 c, s;\r\nfor (s = 0; s < slen; s++)\r\nfor (c = 0; c < clen; c++)\r\nif (servlist[s] == clilist[c])\r\nreturn servlist[s];\r\nreturn -1;\r\n}\r\nstatic u8 dccp_feat_prefer(u8 preferred_value, u8 *array, u8 array_len)\r\n{\r\nu8 i, does_occur = 0;\r\nif (array != NULL) {\r\nfor (i = 0; i < array_len; i++)\r\nif (array[i] == preferred_value) {\r\narray[i] = array[0];\r\ndoes_occur++;\r\n}\r\nif (does_occur)\r\narray[0] = preferred_value;\r\n}\r\nreturn does_occur;\r\n}\r\nstatic int dccp_feat_reconcile(dccp_feat_val *fv, u8 *arr, u8 len,\r\nbool is_server, bool reorder)\r\n{\r\nint rc;\r\nif (!fv->sp.vec || !arr) {\r\nDCCP_CRIT("NULL feature value or array");\r\nreturn 0;\r\n}\r\nif (is_server)\r\nrc = dccp_feat_preflist_match(fv->sp.vec, fv->sp.len, arr, len);\r\nelse\r\nrc = dccp_feat_preflist_match(arr, len, fv->sp.vec, fv->sp.len);\r\nif (!reorder)\r\nreturn rc;\r\nif (rc < 0)\r\nreturn 0;\r\nreturn dccp_feat_prefer(rc, fv->sp.vec, fv->sp.len);\r\n}\r\nstatic u8 dccp_feat_change_recv(struct list_head *fn, u8 is_mandatory, u8 opt,\r\nu8 feat, u8 *val, u8 len, const bool server)\r\n{\r\nu8 defval, type = dccp_feat_type(feat);\r\nconst bool local = (opt == DCCPO_CHANGE_R);\r\nstruct dccp_feat_entry *entry;\r\ndccp_feat_val fval;\r\nif (len == 0 || type == FEAT_UNKNOWN)\r\ngoto unknown_feature_or_value;\r\ndccp_feat_print_opt(opt, feat, val, len, is_mandatory);\r\nif (type == FEAT_NN) {\r\nif (local || len > sizeof(fval.nn))\r\ngoto unknown_feature_or_value;\r\nfval.nn = dccp_decode_value_var(val, len);\r\nif (!dccp_feat_is_valid_nn_val(feat, fval.nn))\r\ngoto unknown_feature_or_value;\r\nreturn dccp_feat_push_confirm(fn, feat, local, &fval);\r\n}\r\nentry = dccp_feat_list_lookup(fn, feat, local);\r\nif (entry == NULL) {\r\nif (dccp_feat_clone_sp_val(&fval, val, 1))\r\nreturn DCCP_RESET_CODE_TOO_BUSY;\r\nif (len > 1 && server) {\r\ndefval = dccp_feat_default_value(feat);\r\nif (dccp_feat_preflist_match(&defval, 1, val, len) > -1)\r\nfval.sp.vec[0] = defval;\r\n} else if (!dccp_feat_is_valid_sp_val(feat, fval.sp.vec[0])) {\r\nkfree(fval.sp.vec);\r\ngoto unknown_feature_or_value;\r\n}\r\nif (feat == DCCPF_CCID && !ccid_support_check(fval.sp.vec, 1)) {\r\nkfree(fval.sp.vec);\r\ngoto not_valid_or_not_known;\r\n}\r\nreturn dccp_feat_push_confirm(fn, feat, local, &fval);\r\n} else if (entry->state == FEAT_UNSTABLE) {\r\nreturn 0;\r\n}\r\nif (dccp_feat_reconcile(&entry->val, val, len, server, true)) {\r\nentry->empty_confirm = 0;\r\n} else if (is_mandatory) {\r\nreturn DCCP_RESET_CODE_MANDATORY_ERROR;\r\n} else if (entry->state == FEAT_INITIALISING) {\r\nWARN_ON(!server);\r\ndefval = dccp_feat_default_value(feat);\r\nif (!dccp_feat_reconcile(&entry->val, &defval, 1, server, true))\r\nreturn DCCP_RESET_CODE_OPTION_ERROR;\r\nentry->empty_confirm = 1;\r\n}\r\nentry->needs_confirm = 1;\r\nentry->needs_mandatory = 0;\r\nentry->state = FEAT_STABLE;\r\nreturn 0;\r\nunknown_feature_or_value:\r\nif (!is_mandatory)\r\nreturn dccp_push_empty_confirm(fn, feat, local);\r\nnot_valid_or_not_known:\r\nreturn is_mandatory ? DCCP_RESET_CODE_MANDATORY_ERROR\r\n: DCCP_RESET_CODE_OPTION_ERROR;\r\n}\r\nstatic u8 dccp_feat_confirm_recv(struct list_head *fn, u8 is_mandatory, u8 opt,\r\nu8 feat, u8 *val, u8 len, const bool server)\r\n{\r\nu8 *plist, plen, type = dccp_feat_type(feat);\r\nconst bool local = (opt == DCCPO_CONFIRM_R);\r\nstruct dccp_feat_entry *entry = dccp_feat_list_lookup(fn, feat, local);\r\ndccp_feat_print_opt(opt, feat, val, len, is_mandatory);\r\nif (entry == NULL) {\r\nif (is_mandatory && type == FEAT_UNKNOWN)\r\nreturn DCCP_RESET_CODE_MANDATORY_ERROR;\r\nif (!local && type == FEAT_NN)\r\ngoto confirmation_failed;\r\nreturn 0;\r\n}\r\nif (entry->state != FEAT_CHANGING)\r\nreturn 0;\r\nif (len == 0) {\r\nif (dccp_feat_must_be_understood(feat))\r\ngoto confirmation_failed;\r\ndccp_feat_list_pop(entry);\r\nreturn 0;\r\n}\r\nif (type == FEAT_NN) {\r\nif (len > sizeof(entry->val.nn))\r\ngoto confirmation_failed;\r\nif (entry->val.nn == dccp_decode_value_var(val, len))\r\ngoto confirmation_succeeded;\r\nDCCP_WARN("Bogus Confirm for non-existing value\n");\r\ngoto confirmation_failed;\r\n}\r\nif (!dccp_feat_is_valid_sp_val(feat, *val))\r\ngoto confirmation_failed;\r\nif (len == 1) {\r\nplist = val;\r\nplen = len;\r\n} else {\r\nplist = val + 1;\r\nplen = len - 1;\r\n}\r\nif (dccp_feat_reconcile(&entry->val, plist, plen, server, 0) != *val) {\r\nDCCP_WARN("Confirm selected the wrong value %u\n", *val);\r\nreturn DCCP_RESET_CODE_OPTION_ERROR;\r\n}\r\nentry->val.sp.vec[0] = *val;\r\nconfirmation_succeeded:\r\nentry->state = FEAT_STABLE;\r\nreturn 0;\r\nconfirmation_failed:\r\nDCCP_WARN("Confirmation failed\n");\r\nreturn is_mandatory ? DCCP_RESET_CODE_MANDATORY_ERROR\r\n: DCCP_RESET_CODE_OPTION_ERROR;\r\n}\r\nint dccp_feat_parse_options(struct sock *sk, struct dccp_request_sock *dreq,\r\nu8 mandatory, u8 opt, u8 feat, u8 *val, u8 len)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct list_head *fn = dreq ? &dreq->dreq_featneg : &dp->dccps_featneg;\r\nbool server = false;\r\nswitch (sk->sk_state) {\r\ncase DCCP_LISTEN:\r\nserver = true;\r\ncase DCCP_REQUESTING:\r\nswitch (opt) {\r\ncase DCCPO_CHANGE_L:\r\ncase DCCPO_CHANGE_R:\r\nreturn dccp_feat_change_recv(fn, mandatory, opt, feat,\r\nval, len, server);\r\ncase DCCPO_CONFIRM_R:\r\ncase DCCPO_CONFIRM_L:\r\nreturn dccp_feat_confirm_recv(fn, mandatory, opt, feat,\r\nval, len, server);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dccp_feat_init(struct sock *sk)\r\n{\r\nstruct list_head *fn = &dccp_sk(sk)->dccps_featneg;\r\nu8 on = 1, off = 0;\r\nint rc;\r\nstruct {\r\nu8 *val;\r\nu8 len;\r\n} tx, rx;\r\nrc = __feat_register_nn(fn, DCCPF_SEQUENCE_WINDOW, 0,\r\nsysctl_dccp_sequence_window);\r\nif (rc)\r\nreturn rc;\r\nrc = __feat_register_sp(fn, DCCPF_SHORT_SEQNOS, true, true, &off, 1);\r\nif (rc)\r\nreturn rc;\r\nrc = __feat_register_sp(fn, DCCPF_ECN_INCAPABLE, true, true, &on, 1);\r\nif (rc)\r\nreturn rc;\r\nif (ccid_get_builtin_ccids(&tx.val, &tx.len) ||\r\nccid_get_builtin_ccids(&rx.val, &rx.len))\r\nreturn -ENOBUFS;\r\nif (!dccp_feat_prefer(sysctl_dccp_tx_ccid, tx.val, tx.len) ||\r\n!dccp_feat_prefer(sysctl_dccp_rx_ccid, rx.val, rx.len))\r\ngoto free_ccid_lists;\r\nrc = __feat_register_sp(fn, DCCPF_CCID, true, false, tx.val, tx.len);\r\nif (rc)\r\ngoto free_ccid_lists;\r\nrc = __feat_register_sp(fn, DCCPF_CCID, false, false, rx.val, rx.len);\r\nfree_ccid_lists:\r\nkfree(tx.val);\r\nkfree(rx.val);\r\nreturn rc;\r\n}\r\nint dccp_feat_activate_values(struct sock *sk, struct list_head *fn_list)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct dccp_feat_entry *cur, *next;\r\nint idx;\r\ndccp_feat_val *fvals[DCCP_FEAT_SUPPORTED_MAX][2] = {\r\n[0 ... DCCP_FEAT_SUPPORTED_MAX-1] = { NULL, NULL }\r\n};\r\nlist_for_each_entry(cur, fn_list, node) {\r\nif (cur->empty_confirm)\r\ncontinue;\r\nidx = dccp_feat_index(cur->feat_num);\r\nif (idx < 0) {\r\nDCCP_BUG("Unknown feature %u", cur->feat_num);\r\ngoto activation_failed;\r\n}\r\nif (cur->state != FEAT_STABLE) {\r\nDCCP_CRIT("Negotiation of %s %s failed in state %s",\r\ncur->is_local ? "local" : "remote",\r\ndccp_feat_fname(cur->feat_num),\r\ndccp_feat_sname[cur->state]);\r\ngoto activation_failed;\r\n}\r\nfvals[idx][cur->is_local] = &cur->val;\r\n}\r\nfor (idx = DCCP_FEAT_SUPPORTED_MAX; --idx >= 0;)\r\nif (__dccp_feat_activate(sk, idx, 0, fvals[idx][0]) ||\r\n__dccp_feat_activate(sk, idx, 1, fvals[idx][1])) {\r\nDCCP_CRIT("Could not activate %d", idx);\r\ngoto activation_failed;\r\n}\r\nlist_for_each_entry_safe(cur, next, fn_list, node)\r\nif (!cur->needs_confirm)\r\ndccp_feat_list_pop(cur);\r\ndccp_pr_debug("Activation OK\n");\r\nreturn 0;\r\nactivation_failed:\r\nccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\r\nccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\r\ndp->dccps_hc_rx_ccid = dp->dccps_hc_tx_ccid = NULL;\r\ndccp_ackvec_free(dp->dccps_hc_rx_ackvec);\r\ndp->dccps_hc_rx_ackvec = NULL;\r\nreturn -1;\r\n}
