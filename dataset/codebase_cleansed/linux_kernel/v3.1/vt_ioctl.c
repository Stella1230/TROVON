void vt_event_post(unsigned int event, unsigned int old, unsigned int new)\r\n{\r\nstruct list_head *pos, *head;\r\nunsigned long flags;\r\nint wake = 0;\r\nspin_lock_irqsave(&vt_event_lock, flags);\r\nhead = &vt_events;\r\nlist_for_each(pos, head) {\r\nstruct vt_event_wait *ve = list_entry(pos,\r\nstruct vt_event_wait, list);\r\nif (!(ve->event.event & event))\r\ncontinue;\r\nve->event.event = event;\r\nve->event.oldev = old + 1;\r\nve->event.newev = new + 1;\r\nwake = 1;\r\nve->done = 1;\r\n}\r\nspin_unlock_irqrestore(&vt_event_lock, flags);\r\nif (wake)\r\nwake_up_interruptible(&vt_event_waitqueue);\r\n}\r\nstatic void vt_event_wait(struct vt_event_wait *vw)\r\n{\r\nunsigned long flags;\r\nINIT_LIST_HEAD(&vw->list);\r\nvw->done = 0;\r\nspin_lock_irqsave(&vt_event_lock, flags);\r\nlist_add(&vw->list, &vt_events);\r\nspin_unlock_irqrestore(&vt_event_lock, flags);\r\nwait_event_interruptible_tty(vt_event_waitqueue, vw->done);\r\nspin_lock_irqsave(&vt_event_lock, flags);\r\nlist_del(&vw->list);\r\nspin_unlock_irqrestore(&vt_event_lock, flags);\r\n}\r\nstatic int vt_event_wait_ioctl(struct vt_event __user *event)\r\n{\r\nstruct vt_event_wait vw;\r\nif (copy_from_user(&vw.event, event, sizeof(struct vt_event)))\r\nreturn -EFAULT;\r\nif (vw.event.event & ~VT_MAX_EVENT)\r\nreturn -EINVAL;\r\nvt_event_wait(&vw);\r\nif (vw.done) {\r\nif (copy_to_user(event, &vw.event, sizeof(struct vt_event)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINTR;\r\n}\r\nint vt_waitactive(int n)\r\n{\r\nstruct vt_event_wait vw;\r\ndo {\r\nif (n == fg_console + 1)\r\nbreak;\r\nvw.event.event = VT_EVENT_SWITCH;\r\nvt_event_wait(&vw);\r\nif (vw.done == 0)\r\nreturn -EINTR;\r\n} while (vw.event.newev != n);\r\nreturn 0;\r\n}\r\nstatic inline int\r\ndo_kdsk_ioctl(int cmd, struct kbentry __user *user_kbe, int perm, struct kbd_struct *kbd)\r\n{\r\nstruct kbentry tmp;\r\nushort *key_map, val, ov;\r\nif (copy_from_user(&tmp, user_kbe, sizeof(struct kbentry)))\r\nreturn -EFAULT;\r\nif (!capable(CAP_SYS_TTY_CONFIG))\r\nperm = 0;\r\nswitch (cmd) {\r\ncase KDGKBENT:\r\nkey_map = key_maps[s];\r\nif (key_map) {\r\nval = U(key_map[i]);\r\nif (kbd->kbdmode != VC_UNICODE && KTYP(val) >= NR_TYPES)\r\nval = K_HOLE;\r\n} else\r\nval = (i ? K_HOLE : K_NOSUCHMAP);\r\nreturn put_user(val, &user_kbe->kb_value);\r\ncase KDSKBENT:\r\nif (!perm)\r\nreturn -EPERM;\r\nif (!i && v == K_NOSUCHMAP) {\r\nkey_map = key_maps[s];\r\nif (s && key_map) {\r\nkey_maps[s] = NULL;\r\nif (key_map[0] == U(K_ALLOCATED)) {\r\nkfree(key_map);\r\nkeymap_count--;\r\n}\r\n}\r\nbreak;\r\n}\r\nif (KTYP(v) < NR_TYPES) {\r\nif (KVAL(v) > max_vals[KTYP(v)])\r\nreturn -EINVAL;\r\n} else\r\nif (kbd->kbdmode != VC_UNICODE)\r\nreturn -EINVAL;\r\n#if !defined(__mc68000__) && !defined(__powerpc__)\r\nif (!i)\r\nbreak;\r\n#endif\r\nif (!(key_map = key_maps[s])) {\r\nint j;\r\nif (keymap_count >= MAX_NR_OF_USER_KEYMAPS &&\r\n!capable(CAP_SYS_RESOURCE))\r\nreturn -EPERM;\r\nkey_map = kmalloc(sizeof(plain_map),\r\nGFP_KERNEL);\r\nif (!key_map)\r\nreturn -ENOMEM;\r\nkey_maps[s] = key_map;\r\nkey_map[0] = U(K_ALLOCATED);\r\nfor (j = 1; j < NR_KEYS; j++)\r\nkey_map[j] = U(K_HOLE);\r\nkeymap_count++;\r\n}\r\nov = U(key_map[i]);\r\nif (v == ov)\r\nbreak;\r\nif (((ov == K_SAK) || (v == K_SAK)) && !capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nkey_map[i] = U(v);\r\nif (!s && (KTYP(ov) == KT_SHIFT || KTYP(v) == KT_SHIFT))\r\ncompute_shiftstate();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\ndo_kbkeycode_ioctl(int cmd, struct kbkeycode __user *user_kbkc, int perm)\r\n{\r\nstruct kbkeycode tmp;\r\nint kc = 0;\r\nif (copy_from_user(&tmp, user_kbkc, sizeof(struct kbkeycode)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase KDGETKEYCODE:\r\nkc = getkeycode(tmp.scancode);\r\nif (kc >= 0)\r\nkc = put_user(kc, &user_kbkc->keycode);\r\nbreak;\r\ncase KDSETKEYCODE:\r\nif (!perm)\r\nreturn -EPERM;\r\nkc = setkeycode(tmp.scancode, tmp.keycode);\r\nbreak;\r\n}\r\nreturn kc;\r\n}\r\nstatic inline int\r\ndo_kdgkb_ioctl(int cmd, struct kbsentry __user *user_kdgkb, int perm)\r\n{\r\nstruct kbsentry *kbs;\r\nchar *p;\r\nu_char *q;\r\nu_char __user *up;\r\nint sz;\r\nint delta;\r\nchar *first_free, *fj, *fnw;\r\nint i, j, k;\r\nint ret;\r\nif (!capable(CAP_SYS_TTY_CONFIG))\r\nperm = 0;\r\nkbs = kmalloc(sizeof(*kbs), GFP_KERNEL);\r\nif (!kbs) {\r\nret = -ENOMEM;\r\ngoto reterr;\r\n}\r\nif (copy_from_user(kbs, user_kdgkb, sizeof(struct kbsentry))) {\r\nret = -EFAULT;\r\ngoto reterr;\r\n}\r\nkbs->kb_string[sizeof(kbs->kb_string)-1] = '\0';\r\ni = kbs->kb_func;\r\nswitch (cmd) {\r\ncase KDGKBSENT:\r\nsz = sizeof(kbs->kb_string) - 1;\r\nup = user_kdgkb->kb_string;\r\np = func_table[i];\r\nif(p)\r\nfor ( ; *p && sz; p++, sz--)\r\nif (put_user(*p, up++)) {\r\nret = -EFAULT;\r\ngoto reterr;\r\n}\r\nif (put_user('\0', up)) {\r\nret = -EFAULT;\r\ngoto reterr;\r\n}\r\nkfree(kbs);\r\nreturn ((p && *p) ? -EOVERFLOW : 0);\r\ncase KDSKBSENT:\r\nif (!perm) {\r\nret = -EPERM;\r\ngoto reterr;\r\n}\r\nq = func_table[i];\r\nfirst_free = funcbufptr + (funcbufsize - funcbufleft);\r\nfor (j = i+1; j < MAX_NR_FUNC && !func_table[j]; j++)\r\n;\r\nif (j < MAX_NR_FUNC)\r\nfj = func_table[j];\r\nelse\r\nfj = first_free;\r\ndelta = (q ? -strlen(q) : 1) + strlen(kbs->kb_string);\r\nif (delta <= funcbufleft) {\r\nif (j < MAX_NR_FUNC) {\r\nmemmove(fj + delta, fj, first_free - fj);\r\nfor (k = j; k < MAX_NR_FUNC; k++)\r\nif (func_table[k])\r\nfunc_table[k] += delta;\r\n}\r\nif (!q)\r\nfunc_table[i] = fj;\r\nfuncbufleft -= delta;\r\n} else {\r\nsz = 256;\r\nwhile (sz < funcbufsize - funcbufleft + delta)\r\nsz <<= 1;\r\nfnw = kmalloc(sz, GFP_KERNEL);\r\nif(!fnw) {\r\nret = -ENOMEM;\r\ngoto reterr;\r\n}\r\nif (!q)\r\nfunc_table[i] = fj;\r\nif (fj > funcbufptr)\r\nmemmove(fnw, funcbufptr, fj - funcbufptr);\r\nfor (k = 0; k < j; k++)\r\nif (func_table[k])\r\nfunc_table[k] = fnw + (func_table[k] - funcbufptr);\r\nif (first_free > fj) {\r\nmemmove(fnw + (fj - funcbufptr) + delta, fj, first_free - fj);\r\nfor (k = j; k < MAX_NR_FUNC; k++)\r\nif (func_table[k])\r\nfunc_table[k] = fnw + (func_table[k] - funcbufptr) + delta;\r\n}\r\nif (funcbufptr != func_buf)\r\nkfree(funcbufptr);\r\nfuncbufptr = fnw;\r\nfuncbufleft = funcbufleft - delta + sz - funcbufsize;\r\nfuncbufsize = sz;\r\n}\r\nstrcpy(func_table[i], kbs->kb_string);\r\nbreak;\r\n}\r\nret = 0;\r\nreterr:\r\nkfree(kbs);\r\nreturn ret;\r\n}\r\nstatic inline int\r\ndo_fontx_ioctl(int cmd, struct consolefontdesc __user *user_cfd, int perm, struct console_font_op *op)\r\n{\r\nstruct consolefontdesc cfdarg;\r\nint i;\r\nif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase PIO_FONTX:\r\nif (!perm)\r\nreturn -EPERM;\r\nop->op = KD_FONT_OP_SET;\r\nop->flags = KD_FONT_FLAG_OLD;\r\nop->width = 8;\r\nop->height = cfdarg.charheight;\r\nop->charcount = cfdarg.charcount;\r\nop->data = cfdarg.chardata;\r\nreturn con_font_op(vc_cons[fg_console].d, op);\r\ncase GIO_FONTX: {\r\nop->op = KD_FONT_OP_GET;\r\nop->flags = KD_FONT_FLAG_OLD;\r\nop->width = 8;\r\nop->height = cfdarg.charheight;\r\nop->charcount = cfdarg.charcount;\r\nop->data = cfdarg.chardata;\r\ni = con_font_op(vc_cons[fg_console].d, op);\r\nif (i)\r\nreturn i;\r\ncfdarg.charheight = op->height;\r\ncfdarg.charcount = op->charcount;\r\nif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline int\r\ndo_unimap_ioctl(int cmd, struct unimapdesc __user *user_ud, int perm, struct vc_data *vc)\r\n{\r\nstruct unimapdesc tmp;\r\nif (copy_from_user(&tmp, user_ud, sizeof tmp))\r\nreturn -EFAULT;\r\nif (tmp.entries)\r\nif (!access_ok(VERIFY_WRITE, tmp.entries,\r\ntmp.entry_ct*sizeof(struct unipair)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase PIO_UNIMAP:\r\nif (!perm)\r\nreturn -EPERM;\r\nreturn con_set_unimap(vc, tmp.entry_ct, tmp.entries);\r\ncase GIO_UNIMAP:\r\nif (!perm && fg_console != vc->vc_num)\r\nreturn -EPERM;\r\nreturn con_get_unimap(vc, tmp.entry_ct, &(user_ud->entry_ct), tmp.entries);\r\n}\r\nreturn 0;\r\n}\r\nint vt_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct vc_data *vc = tty->driver_data;\r\nstruct console_font_op op;\r\nstruct kbd_struct * kbd;\r\nunsigned int console;\r\nunsigned char ucval;\r\nunsigned int uival;\r\nvoid __user *up = (void __user *)arg;\r\nint i, perm;\r\nint ret = 0;\r\nconsole = vc->vc_num;\r\ntty_lock();\r\nif (!vc_cons_allocated(console)) {\r\nret = -ENOIOCTLCMD;\r\ngoto out;\r\n}\r\nperm = 0;\r\nif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\r\nperm = 1;\r\nkbd = kbd_table + console;\r\nswitch (cmd) {\r\ncase TIOCLINUX:\r\nret = tioclinux(tty, arg);\r\nbreak;\r\ncase KIOCSOUND:\r\nif (!perm)\r\ngoto eperm;\r\nif (arg)\r\narg = PIT_TICK_RATE / arg;\r\nkd_mksound(arg, 0);\r\nbreak;\r\ncase KDMKTONE:\r\nif (!perm)\r\ngoto eperm;\r\n{\r\nunsigned int ticks, count;\r\nticks = HZ * ((arg >> 16) & 0xffff) / 1000;\r\ncount = ticks ? (arg & 0xffff) : 0;\r\nif (count)\r\ncount = PIT_TICK_RATE / count;\r\nkd_mksound(count, ticks);\r\nbreak;\r\n}\r\ncase KDGKBTYPE:\r\nucval = KB_101;\r\ngoto setchar;\r\n#ifdef CONFIG_X86\r\ncase KDADDIO:\r\ncase KDDELIO:\r\nif (arg < GPFIRST || arg > GPLAST) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = sys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\r\nbreak;\r\ncase KDENABIO:\r\ncase KDDISABIO:\r\nret = sys_ioperm(GPFIRST, GPNUM,\r\n(cmd == KDENABIO)) ? -ENXIO : 0;\r\nbreak;\r\n#endif\r\ncase KDKBDREP:\r\n{\r\nstruct kbd_repeat kbrep;\r\nif (!capable(CAP_SYS_TTY_CONFIG))\r\ngoto eperm;\r\nif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = kbd_rate(&kbrep);\r\nif (ret)\r\nbreak;\r\nif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ncase KDSETMODE:\r\nif (!perm)\r\ngoto eperm;\r\nswitch (arg) {\r\ncase KD_GRAPHICS:\r\nbreak;\r\ncase KD_TEXT0:\r\ncase KD_TEXT1:\r\narg = KD_TEXT;\r\ncase KD_TEXT:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (vc->vc_mode == (unsigned char) arg)\r\nbreak;\r\nvc->vc_mode = (unsigned char) arg;\r\nif (console != fg_console)\r\nbreak;\r\nconsole_lock();\r\nif (arg == KD_TEXT)\r\ndo_unblank_screen(1);\r\nelse\r\ndo_blank_screen(1);\r\nconsole_unlock();\r\nbreak;\r\ncase KDGETMODE:\r\nuival = vc->vc_mode;\r\ngoto setint;\r\ncase KDMAPDISP:\r\ncase KDUNMAPDISP:\r\nret = -EINVAL;\r\nbreak;\r\ncase KDSKBMODE:\r\nif (!perm)\r\ngoto eperm;\r\nswitch(arg) {\r\ncase K_RAW:\r\nkbd->kbdmode = VC_RAW;\r\nbreak;\r\ncase K_MEDIUMRAW:\r\nkbd->kbdmode = VC_MEDIUMRAW;\r\nbreak;\r\ncase K_XLATE:\r\nkbd->kbdmode = VC_XLATE;\r\ncompute_shiftstate();\r\nbreak;\r\ncase K_UNICODE:\r\nkbd->kbdmode = VC_UNICODE;\r\ncompute_shiftstate();\r\nbreak;\r\ncase K_OFF:\r\nkbd->kbdmode = VC_OFF;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntty_ldisc_flush(tty);\r\nbreak;\r\ncase KDGKBMODE:\r\nswitch (kbd->kbdmode) {\r\ncase VC_RAW:\r\nuival = K_RAW;\r\nbreak;\r\ncase VC_MEDIUMRAW:\r\nuival = K_MEDIUMRAW;\r\nbreak;\r\ncase VC_UNICODE:\r\nuival = K_UNICODE;\r\nbreak;\r\ncase VC_OFF:\r\nuival = K_OFF;\r\nbreak;\r\ndefault:\r\nuival = K_XLATE;\r\nbreak;\r\n}\r\ngoto setint;\r\ncase KDSKBMETA:\r\nswitch(arg) {\r\ncase K_METABIT:\r\nclr_vc_kbd_mode(kbd, VC_META);\r\nbreak;\r\ncase K_ESCPREFIX:\r\nset_vc_kbd_mode(kbd, VC_META);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase KDGKBMETA:\r\nuival = (vc_kbd_mode(kbd, VC_META) ? K_ESCPREFIX : K_METABIT);\r\nsetint:\r\nret = put_user(uival, (int __user *)arg);\r\nbreak;\r\ncase KDGETKEYCODE:\r\ncase KDSETKEYCODE:\r\nif(!capable(CAP_SYS_TTY_CONFIG))\r\nperm = 0;\r\nret = do_kbkeycode_ioctl(cmd, up, perm);\r\nbreak;\r\ncase KDGKBENT:\r\ncase KDSKBENT:\r\nret = do_kdsk_ioctl(cmd, up, perm, kbd);\r\nbreak;\r\ncase KDGKBSENT:\r\ncase KDSKBSENT:\r\nret = do_kdgkb_ioctl(cmd, up, perm);\r\nbreak;\r\ncase KDGKBDIACR:\r\n{\r\nstruct kbdiacrs __user *a = up;\r\nstruct kbdiacr diacr;\r\nint i;\r\nif (put_user(accent_table_size, &a->kb_cnt)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nfor (i = 0; i < accent_table_size; i++) {\r\ndiacr.diacr = conv_uni_to_8bit(accent_table[i].diacr);\r\ndiacr.base = conv_uni_to_8bit(accent_table[i].base);\r\ndiacr.result = conv_uni_to_8bit(accent_table[i].result);\r\nif (copy_to_user(a->kbdiacr + i, &diacr, sizeof(struct kbdiacr))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase KDGKBDIACRUC:\r\n{\r\nstruct kbdiacrsuc __user *a = up;\r\nif (put_user(accent_table_size, &a->kb_cnt))\r\nret = -EFAULT;\r\nelse if (copy_to_user(a->kbdiacruc, accent_table,\r\naccent_table_size*sizeof(struct kbdiacruc)))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ncase KDSKBDIACR:\r\n{\r\nstruct kbdiacrs __user *a = up;\r\nstruct kbdiacr diacr;\r\nunsigned int ct;\r\nint i;\r\nif (!perm)\r\ngoto eperm;\r\nif (get_user(ct,&a->kb_cnt)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (ct >= MAX_DIACR) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\naccent_table_size = ct;\r\nfor (i = 0; i < ct; i++) {\r\nif (copy_from_user(&diacr, a->kbdiacr + i, sizeof(struct kbdiacr))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\naccent_table[i].diacr = conv_8bit_to_uni(diacr.diacr);\r\naccent_table[i].base = conv_8bit_to_uni(diacr.base);\r\naccent_table[i].result = conv_8bit_to_uni(diacr.result);\r\n}\r\nbreak;\r\n}\r\ncase KDSKBDIACRUC:\r\n{\r\nstruct kbdiacrsuc __user *a = up;\r\nunsigned int ct;\r\nif (!perm)\r\ngoto eperm;\r\nif (get_user(ct,&a->kb_cnt)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (ct >= MAX_DIACR) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\naccent_table_size = ct;\r\nif (copy_from_user(accent_table, a->kbdiacruc, ct*sizeof(struct kbdiacruc)))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ncase KDGKBLED:\r\nucval = kbd->ledflagstate | (kbd->default_ledflagstate << 4);\r\ngoto setchar;\r\ncase KDSKBLED:\r\nif (!perm)\r\ngoto eperm;\r\nif (arg & ~0x77) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nkbd->ledflagstate = (arg & 7);\r\nkbd->default_ledflagstate = ((arg >> 4) & 7);\r\nset_leds();\r\nbreak;\r\ncase KDGETLED:\r\nucval = getledstate();\r\nsetchar:\r\nret = put_user(ucval, (char __user *)arg);\r\nbreak;\r\ncase KDSETLED:\r\nif (!perm)\r\ngoto eperm;\r\nsetledstate(kbd, arg);\r\nbreak;\r\ncase KDSIGACCEPT:\r\n{\r\nif (!perm || !capable(CAP_KILL))\r\ngoto eperm;\r\nif (!valid_signal(arg) || arg < 1 || arg == SIGKILL)\r\nret = -EINVAL;\r\nelse {\r\nspin_lock_irq(&vt_spawn_con.lock);\r\nput_pid(vt_spawn_con.pid);\r\nvt_spawn_con.pid = get_pid(task_pid(current));\r\nvt_spawn_con.sig = arg;\r\nspin_unlock_irq(&vt_spawn_con.lock);\r\n}\r\nbreak;\r\n}\r\ncase VT_SETMODE:\r\n{\r\nstruct vt_mode tmp;\r\nif (!perm)\r\ngoto eperm;\r\nif (copy_from_user(&tmp, up, sizeof(struct vt_mode))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (tmp.mode != VT_AUTO && tmp.mode != VT_PROCESS) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nconsole_lock();\r\nvc->vt_mode = tmp;\r\nvc->vt_mode.frsig = 0;\r\nput_pid(vc->vt_pid);\r\nvc->vt_pid = get_pid(task_pid(current));\r\nvc->vt_newvt = -1;\r\nconsole_unlock();\r\nbreak;\r\n}\r\ncase VT_GETMODE:\r\n{\r\nstruct vt_mode tmp;\r\nint rc;\r\nconsole_lock();\r\nmemcpy(&tmp, &vc->vt_mode, sizeof(struct vt_mode));\r\nconsole_unlock();\r\nrc = copy_to_user(up, &tmp, sizeof(struct vt_mode));\r\nif (rc)\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ncase VT_GETSTATE:\r\n{\r\nstruct vt_stat __user *vtstat = up;\r\nunsigned short state, mask;\r\nif (put_user(fg_console + 1, &vtstat->v_active))\r\nret = -EFAULT;\r\nelse {\r\nstate = 1;\r\nfor (i = 0, mask = 2; i < MAX_NR_CONSOLES && mask;\r\n++i, mask <<= 1)\r\nif (VT_IS_IN_USE(i))\r\nstate |= mask;\r\nret = put_user(state, &vtstat->v_state);\r\n}\r\nbreak;\r\n}\r\ncase VT_OPENQRY:\r\nfor (i = 0; i < MAX_NR_CONSOLES; ++i)\r\nif (! VT_IS_IN_USE(i))\r\nbreak;\r\nuival = i < MAX_NR_CONSOLES ? (i+1) : -1;\r\ngoto setint;\r\ncase VT_ACTIVATE:\r\nif (!perm)\r\ngoto eperm;\r\nif (arg == 0 || arg > MAX_NR_CONSOLES)\r\nret = -ENXIO;\r\nelse {\r\narg--;\r\nconsole_lock();\r\nret = vc_allocate(arg);\r\nconsole_unlock();\r\nif (ret)\r\nbreak;\r\nset_console(arg);\r\n}\r\nbreak;\r\ncase VT_SETACTIVATE:\r\n{\r\nstruct vt_setactivate vsa;\r\nif (!perm)\r\ngoto eperm;\r\nif (copy_from_user(&vsa, (struct vt_setactivate __user *)arg,\r\nsizeof(struct vt_setactivate))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (vsa.console == 0 || vsa.console > MAX_NR_CONSOLES)\r\nret = -ENXIO;\r\nelse {\r\nvsa.console--;\r\nconsole_lock();\r\nret = vc_allocate(vsa.console);\r\nif (ret == 0) {\r\nstruct vc_data *nvc;\r\nnvc = vc_cons[vsa.console].d;\r\nnvc->vt_mode = vsa.mode;\r\nnvc->vt_mode.frsig = 0;\r\nput_pid(nvc->vt_pid);\r\nnvc->vt_pid = get_pid(task_pid(current));\r\n}\r\nconsole_unlock();\r\nif (ret)\r\nbreak;\r\nset_console(vsa.console);\r\n}\r\nbreak;\r\n}\r\ncase VT_WAITACTIVE:\r\nif (!perm)\r\ngoto eperm;\r\nif (arg == 0 || arg > MAX_NR_CONSOLES)\r\nret = -ENXIO;\r\nelse\r\nret = vt_waitactive(arg);\r\nbreak;\r\ncase VT_RELDISP:\r\nif (!perm)\r\ngoto eperm;\r\nif (vc->vt_mode.mode != VT_PROCESS) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nconsole_lock();\r\nif (vc->vt_newvt >= 0) {\r\nif (arg == 0)\r\nvc->vt_newvt = -1;\r\nelse {\r\nint newvt;\r\nnewvt = vc->vt_newvt;\r\nvc->vt_newvt = -1;\r\nret = vc_allocate(newvt);\r\nif (ret) {\r\nconsole_unlock();\r\nbreak;\r\n}\r\ncomplete_change_console(vc_cons[newvt].d);\r\n}\r\n} else {\r\nif (arg != VT_ACKACQ)\r\nret = -EINVAL;\r\n}\r\nconsole_unlock();\r\nbreak;\r\ncase VT_DISALLOCATE:\r\nif (arg > MAX_NR_CONSOLES) {\r\nret = -ENXIO;\r\nbreak;\r\n}\r\nif (arg == 0) {\r\nconsole_lock();\r\nfor (i=1; i<MAX_NR_CONSOLES; i++)\r\nif (! VT_BUSY(i))\r\nvc_deallocate(i);\r\nconsole_unlock();\r\n} else {\r\narg--;\r\nif (VT_BUSY(arg))\r\nret = -EBUSY;\r\nelse if (arg) {\r\nconsole_lock();\r\nvc_deallocate(arg);\r\nconsole_unlock();\r\n}\r\n}\r\nbreak;\r\ncase VT_RESIZE:\r\n{\r\nstruct vt_sizes __user *vtsizes = up;\r\nstruct vc_data *vc;\r\nushort ll,cc;\r\nif (!perm)\r\ngoto eperm;\r\nif (get_user(ll, &vtsizes->v_rows) ||\r\nget_user(cc, &vtsizes->v_cols))\r\nret = -EFAULT;\r\nelse {\r\nconsole_lock();\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nvc = vc_cons[i].d;\r\nif (vc) {\r\nvc->vc_resize_user = 1;\r\nvc_resize(vc_cons[i].d, cc, ll);\r\n}\r\n}\r\nconsole_unlock();\r\n}\r\nbreak;\r\n}\r\ncase VT_RESIZEX:\r\n{\r\nstruct vt_consize __user *vtconsize = up;\r\nushort ll,cc,vlin,clin,vcol,ccol;\r\nif (!perm)\r\ngoto eperm;\r\nif (!access_ok(VERIFY_READ, vtconsize,\r\nsizeof(struct vt_consize))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n__get_user(ll, &vtconsize->v_rows);\r\n__get_user(cc, &vtconsize->v_cols);\r\n__get_user(vlin, &vtconsize->v_vlin);\r\n__get_user(clin, &vtconsize->v_clin);\r\n__get_user(vcol, &vtconsize->v_vcol);\r\n__get_user(ccol, &vtconsize->v_ccol);\r\nvlin = vlin ? vlin : vc->vc_scan_lines;\r\nif (clin) {\r\nif (ll) {\r\nif (ll != vlin/clin) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n} else\r\nll = vlin/clin;\r\n}\r\nif (vcol && ccol) {\r\nif (cc) {\r\nif (cc != vcol/ccol) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n} else\r\ncc = vcol/ccol;\r\n}\r\nif (clin > 32) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nif (!vc_cons[i].d)\r\ncontinue;\r\nconsole_lock();\r\nif (vlin)\r\nvc_cons[i].d->vc_scan_lines = vlin;\r\nif (clin)\r\nvc_cons[i].d->vc_font.height = clin;\r\nvc_cons[i].d->vc_resize_user = 1;\r\nvc_resize(vc_cons[i].d, cc, ll);\r\nconsole_unlock();\r\n}\r\nbreak;\r\n}\r\ncase PIO_FONT: {\r\nif (!perm)\r\ngoto eperm;\r\nop.op = KD_FONT_OP_SET;\r\nop.flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC;\r\nop.width = 8;\r\nop.height = 0;\r\nop.charcount = 256;\r\nop.data = up;\r\nret = con_font_op(vc_cons[fg_console].d, &op);\r\nbreak;\r\n}\r\ncase GIO_FONT: {\r\nop.op = KD_FONT_OP_GET;\r\nop.flags = KD_FONT_FLAG_OLD;\r\nop.width = 8;\r\nop.height = 32;\r\nop.charcount = 256;\r\nop.data = up;\r\nret = con_font_op(vc_cons[fg_console].d, &op);\r\nbreak;\r\n}\r\ncase PIO_CMAP:\r\nif (!perm)\r\nret = -EPERM;\r\nelse\r\nret = con_set_cmap(up);\r\nbreak;\r\ncase GIO_CMAP:\r\nret = con_get_cmap(up);\r\nbreak;\r\ncase PIO_FONTX:\r\ncase GIO_FONTX:\r\nret = do_fontx_ioctl(cmd, up, perm, &op);\r\nbreak;\r\ncase PIO_FONTRESET:\r\n{\r\nif (!perm)\r\ngoto eperm;\r\n#ifdef BROKEN_GRAPHICS_PROGRAMS\r\nret = -ENOSYS;\r\nbreak;\r\n#else\r\n{\r\nop.op = KD_FONT_OP_SET_DEFAULT;\r\nop.data = NULL;\r\nret = con_font_op(vc_cons[fg_console].d, &op);\r\nif (ret)\r\nbreak;\r\ncon_set_default_unimap(vc_cons[fg_console].d);\r\nbreak;\r\n}\r\n#endif\r\n}\r\ncase KDFONTOP: {\r\nif (copy_from_user(&op, up, sizeof(op))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (!perm && op.op != KD_FONT_OP_GET)\r\ngoto eperm;\r\nret = con_font_op(vc, &op);\r\nif (ret)\r\nbreak;\r\nif (copy_to_user(up, &op, sizeof(op)))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ncase PIO_SCRNMAP:\r\nif (!perm)\r\nret = -EPERM;\r\nelse\r\nret = con_set_trans_old(up);\r\nbreak;\r\ncase GIO_SCRNMAP:\r\nret = con_get_trans_old(up);\r\nbreak;\r\ncase PIO_UNISCRNMAP:\r\nif (!perm)\r\nret = -EPERM;\r\nelse\r\nret = con_set_trans_new(up);\r\nbreak;\r\ncase GIO_UNISCRNMAP:\r\nret = con_get_trans_new(up);\r\nbreak;\r\ncase PIO_UNIMAPCLR:\r\n{ struct unimapinit ui;\r\nif (!perm)\r\ngoto eperm;\r\nret = copy_from_user(&ui, up, sizeof(struct unimapinit));\r\nif (ret)\r\nret = -EFAULT;\r\nelse\r\ncon_clear_unimap(vc, &ui);\r\nbreak;\r\n}\r\ncase PIO_UNIMAP:\r\ncase GIO_UNIMAP:\r\nret = do_unimap_ioctl(cmd, up, perm, vc);\r\nbreak;\r\ncase VT_LOCKSWITCH:\r\nif (!capable(CAP_SYS_TTY_CONFIG))\r\ngoto eperm;\r\nvt_dont_switch = 1;\r\nbreak;\r\ncase VT_UNLOCKSWITCH:\r\nif (!capable(CAP_SYS_TTY_CONFIG))\r\ngoto eperm;\r\nvt_dont_switch = 0;\r\nbreak;\r\ncase VT_GETHIFONTMASK:\r\nret = put_user(vc->vc_hi_font_mask,\r\n(unsigned short __user *)arg);\r\nbreak;\r\ncase VT_WAITEVENT:\r\nret = vt_event_wait_ioctl((struct vt_event __user *)arg);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nout:\r\ntty_unlock();\r\nreturn ret;\r\neperm:\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nvoid reset_vc(struct vc_data *vc)\r\n{\r\nvc->vc_mode = KD_TEXT;\r\nkbd_table[vc->vc_num].kbdmode = default_utf8 ? VC_UNICODE : VC_XLATE;\r\nvc->vt_mode.mode = VT_AUTO;\r\nvc->vt_mode.waitv = 0;\r\nvc->vt_mode.relsig = 0;\r\nvc->vt_mode.acqsig = 0;\r\nvc->vt_mode.frsig = 0;\r\nput_pid(vc->vt_pid);\r\nvc->vt_pid = NULL;\r\nvc->vt_newvt = -1;\r\nif (!in_interrupt())\r\nreset_palette(vc);\r\n}\r\nvoid vc_SAK(struct work_struct *work)\r\n{\r\nstruct vc *vc_con =\r\ncontainer_of(work, struct vc, SAK_work);\r\nstruct vc_data *vc;\r\nstruct tty_struct *tty;\r\nconsole_lock();\r\nvc = vc_con->d;\r\nif (vc) {\r\ntty = vc->port.tty;\r\nif (tty)\r\n__do_SAK(tty);\r\nreset_vc(vc);\r\n}\r\nconsole_unlock();\r\n}\r\nstatic inline int\r\ncompat_fontx_ioctl(int cmd, struct compat_consolefontdesc __user *user_cfd,\r\nint perm, struct console_font_op *op)\r\n{\r\nstruct compat_consolefontdesc cfdarg;\r\nint i;\r\nif (copy_from_user(&cfdarg, user_cfd, sizeof(struct compat_consolefontdesc)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase PIO_FONTX:\r\nif (!perm)\r\nreturn -EPERM;\r\nop->op = KD_FONT_OP_SET;\r\nop->flags = KD_FONT_FLAG_OLD;\r\nop->width = 8;\r\nop->height = cfdarg.charheight;\r\nop->charcount = cfdarg.charcount;\r\nop->data = compat_ptr(cfdarg.chardata);\r\nreturn con_font_op(vc_cons[fg_console].d, op);\r\ncase GIO_FONTX:\r\nop->op = KD_FONT_OP_GET;\r\nop->flags = KD_FONT_FLAG_OLD;\r\nop->width = 8;\r\nop->height = cfdarg.charheight;\r\nop->charcount = cfdarg.charcount;\r\nop->data = compat_ptr(cfdarg.chardata);\r\ni = con_font_op(vc_cons[fg_console].d, op);\r\nif (i)\r\nreturn i;\r\ncfdarg.charheight = op->height;\r\ncfdarg.charcount = op->charcount;\r\nif (copy_to_user(user_cfd, &cfdarg, sizeof(struct compat_consolefontdesc)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline int\r\ncompat_kdfontop_ioctl(struct compat_console_font_op __user *fontop,\r\nint perm, struct console_font_op *op, struct vc_data *vc)\r\n{\r\nint i;\r\nif (copy_from_user(op, fontop, sizeof(struct compat_console_font_op)))\r\nreturn -EFAULT;\r\nif (!perm && op->op != KD_FONT_OP_GET)\r\nreturn -EPERM;\r\nop->data = compat_ptr(((struct compat_console_font_op *)op)->data);\r\nop->flags |= KD_FONT_FLAG_OLD;\r\ni = con_font_op(vc, op);\r\nif (i)\r\nreturn i;\r\n((struct compat_console_font_op *)op)->data = (unsigned long)op->data;\r\nif (copy_to_user(fontop, op, sizeof(struct compat_console_font_op)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int\r\ncompat_unimap_ioctl(unsigned int cmd, struct compat_unimapdesc __user *user_ud,\r\nint perm, struct vc_data *vc)\r\n{\r\nstruct compat_unimapdesc tmp;\r\nstruct unipair __user *tmp_entries;\r\nif (copy_from_user(&tmp, user_ud, sizeof tmp))\r\nreturn -EFAULT;\r\ntmp_entries = compat_ptr(tmp.entries);\r\nif (tmp_entries)\r\nif (!access_ok(VERIFY_WRITE, tmp_entries,\r\ntmp.entry_ct*sizeof(struct unipair)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase PIO_UNIMAP:\r\nif (!perm)\r\nreturn -EPERM;\r\nreturn con_set_unimap(vc, tmp.entry_ct, tmp_entries);\r\ncase GIO_UNIMAP:\r\nif (!perm && fg_console != vc->vc_num)\r\nreturn -EPERM;\r\nreturn con_get_unimap(vc, tmp.entry_ct, &(user_ud->entry_ct), tmp_entries);\r\n}\r\nreturn 0;\r\n}\r\nlong vt_compat_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct vc_data *vc = tty->driver_data;\r\nstruct console_font_op op;\r\nunsigned int console;\r\nvoid __user *up = (void __user *)arg;\r\nint perm;\r\nint ret = 0;\r\nconsole = vc->vc_num;\r\ntty_lock();\r\nif (!vc_cons_allocated(console)) {\r\nret = -ENOIOCTLCMD;\r\ngoto out;\r\n}\r\nperm = 0;\r\nif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\r\nperm = 1;\r\nswitch (cmd) {\r\ncase PIO_FONTX:\r\ncase GIO_FONTX:\r\nret = compat_fontx_ioctl(cmd, up, perm, &op);\r\nbreak;\r\ncase KDFONTOP:\r\nret = compat_kdfontop_ioctl(up, perm, &op, vc);\r\nbreak;\r\ncase PIO_UNIMAP:\r\ncase GIO_UNIMAP:\r\nret = compat_unimap_ioctl(cmd, up, perm, vc);\r\nbreak;\r\ncase KIOCSOUND:\r\ncase KDMKTONE:\r\n#ifdef CONFIG_X86\r\ncase KDADDIO:\r\ncase KDDELIO:\r\n#endif\r\ncase KDSETMODE:\r\ncase KDMAPDISP:\r\ncase KDUNMAPDISP:\r\ncase KDSKBMODE:\r\ncase KDSKBMETA:\r\ncase KDSKBLED:\r\ncase KDSETLED:\r\ncase KDSIGACCEPT:\r\ncase VT_ACTIVATE:\r\ncase VT_WAITACTIVE:\r\ncase VT_RELDISP:\r\ncase VT_DISALLOCATE:\r\ncase VT_RESIZE:\r\ncase VT_RESIZEX:\r\ngoto fallback;\r\ndefault:\r\narg = (unsigned long)compat_ptr(arg);\r\ngoto fallback;\r\n}\r\nout:\r\ntty_unlock();\r\nreturn ret;\r\nfallback:\r\ntty_unlock();\r\nreturn vt_ioctl(tty, cmd, arg);\r\n}\r\nstatic void complete_change_console(struct vc_data *vc)\r\n{\r\nunsigned char old_vc_mode;\r\nint old = fg_console;\r\nlast_console = fg_console;\r\nold_vc_mode = vc_cons[fg_console].d->vc_mode;\r\nswitch_screen(vc);\r\nif (old_vc_mode != vc->vc_mode) {\r\nif (vc->vc_mode == KD_TEXT)\r\ndo_unblank_screen(1);\r\nelse\r\ndo_blank_screen(1);\r\n}\r\nif (vc->vt_mode.mode == VT_PROCESS) {\r\nif (kill_pid(vc->vt_pid, vc->vt_mode.acqsig, 1) != 0) {\r\nreset_vc(vc);\r\nif (old_vc_mode != vc->vc_mode) {\r\nif (vc->vc_mode == KD_TEXT)\r\ndo_unblank_screen(1);\r\nelse\r\ndo_blank_screen(1);\r\n}\r\n}\r\n}\r\nvt_event_post(VT_EVENT_SWITCH, old, vc->vc_num);\r\nreturn;\r\n}\r\nvoid change_console(struct vc_data *new_vc)\r\n{\r\nstruct vc_data *vc;\r\nif (!new_vc || new_vc->vc_num == fg_console || vt_dont_switch)\r\nreturn;\r\nvc = vc_cons[fg_console].d;\r\nif (vc->vt_mode.mode == VT_PROCESS) {\r\nvc->vt_newvt = new_vc->vc_num;\r\nif (kill_pid(vc->vt_pid, vc->vt_mode.relsig, 1) == 0) {\r\nreturn;\r\n}\r\nreset_vc(vc);\r\n}\r\nif (vc->vc_mode == KD_GRAPHICS)\r\nreturn;\r\ncomplete_change_console(new_vc);\r\n}\r\nint vt_move_to_console(unsigned int vt, int alloc)\r\n{\r\nint prev;\r\nconsole_lock();\r\nif (disable_vt_switch) {\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nprev = fg_console;\r\nif (alloc && vc_allocate(vt)) {\r\nconsole_unlock();\r\nreturn -ENOSPC;\r\n}\r\nif (set_console(vt)) {\r\nconsole_unlock();\r\nreturn -EIO;\r\n}\r\nconsole_unlock();\r\ntty_lock();\r\nif (vt_waitactive(vt + 1)) {\r\npr_debug("Suspend: Can't switch VCs.");\r\ntty_unlock();\r\nreturn -EINTR;\r\n}\r\ntty_unlock();\r\nreturn prev;\r\n}\r\nvoid pm_set_vt_switch(int do_switch)\r\n{\r\nconsole_lock();\r\ndisable_vt_switch = !do_switch;\r\nconsole_unlock();\r\n}
