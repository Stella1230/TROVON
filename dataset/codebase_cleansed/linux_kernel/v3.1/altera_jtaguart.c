static unsigned int altera_jtaguart_tx_empty(struct uart_port *port)\r\n{\r\nreturn (readl(port->membase + ALTERA_JTAGUART_CONTROL_REG) &\r\nALTERA_JTAGUART_CONTROL_WSPACE_MSK) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int altera_jtaguart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void altera_jtaguart_set_mctrl(struct uart_port *port, unsigned int sigs)\r\n{\r\n}\r\nstatic void altera_jtaguart_start_tx(struct uart_port *port)\r\n{\r\nstruct altera_jtaguart *pp =\r\ncontainer_of(port, struct altera_jtaguart, port);\r\npp->imr |= ALTERA_JTAGUART_CONTROL_WE_MSK;\r\nwritel(pp->imr, port->membase + ALTERA_JTAGUART_CONTROL_REG);\r\n}\r\nstatic void altera_jtaguart_stop_tx(struct uart_port *port)\r\n{\r\nstruct altera_jtaguart *pp =\r\ncontainer_of(port, struct altera_jtaguart, port);\r\npp->imr &= ~ALTERA_JTAGUART_CONTROL_WE_MSK;\r\nwritel(pp->imr, port->membase + ALTERA_JTAGUART_CONTROL_REG);\r\n}\r\nstatic void altera_jtaguart_stop_rx(struct uart_port *port)\r\n{\r\nstruct altera_jtaguart *pp =\r\ncontainer_of(port, struct altera_jtaguart, port);\r\npp->imr &= ~ALTERA_JTAGUART_CONTROL_RE_MSK;\r\nwritel(pp->imr, port->membase + ALTERA_JTAGUART_CONTROL_REG);\r\n}\r\nstatic void altera_jtaguart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic void altera_jtaguart_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void altera_jtaguart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nif (old)\r\ntty_termios_copy_hw(termios, old);\r\n}\r\nstatic void altera_jtaguart_rx_chars(struct altera_jtaguart *pp)\r\n{\r\nstruct uart_port *port = &pp->port;\r\nunsigned char ch, flag;\r\nunsigned long status;\r\nwhile ((status = readl(port->membase + ALTERA_JTAGUART_DATA_REG)) &\r\nALTERA_JTAGUART_DATA_RVALID_MSK) {\r\nch = status & ALTERA_JTAGUART_DATA_DATA_MSK;\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nuart_insert_char(port, 0, 0, ch, flag);\r\n}\r\ntty_flip_buffer_push(port->state->port.tty);\r\n}\r\nstatic void altera_jtaguart_tx_chars(struct altera_jtaguart *pp)\r\n{\r\nstruct uart_port *port = &pp->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int pending, count;\r\nif (port->x_char) {\r\nwritel(port->x_char, port->membase + ALTERA_JTAGUART_DATA_REG);\r\nport->x_char = 0;\r\nport->icount.tx++;\r\nreturn;\r\n}\r\npending = uart_circ_chars_pending(xmit);\r\nif (pending > 0) {\r\ncount = (readl(port->membase + ALTERA_JTAGUART_CONTROL_REG) &\r\nALTERA_JTAGUART_CONTROL_WSPACE_MSK) >>\r\nALTERA_JTAGUART_CONTROL_WSPACE_OFF;\r\nif (count > pending)\r\ncount = pending;\r\nif (count > 0) {\r\npending -= count;\r\nwhile (count--) {\r\nwritel(xmit->buf[xmit->tail],\r\nport->membase + ALTERA_JTAGUART_DATA_REG);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\nif (pending < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\n}\r\nif (pending == 0) {\r\npp->imr &= ~ALTERA_JTAGUART_CONTROL_WE_MSK;\r\nwritel(pp->imr, port->membase + ALTERA_JTAGUART_CONTROL_REG);\r\n}\r\n}\r\nstatic irqreturn_t altera_jtaguart_interrupt(int irq, void *data)\r\n{\r\nstruct uart_port *port = data;\r\nstruct altera_jtaguart *pp =\r\ncontainer_of(port, struct altera_jtaguart, port);\r\nunsigned int isr;\r\nisr = (readl(port->membase + ALTERA_JTAGUART_CONTROL_REG) >>\r\nALTERA_JTAGUART_CONTROL_RI_OFF) & pp->imr;\r\nspin_lock(&port->lock);\r\nif (isr & ALTERA_JTAGUART_CONTROL_RE_MSK)\r\naltera_jtaguart_rx_chars(pp);\r\nif (isr & ALTERA_JTAGUART_CONTROL_WE_MSK)\r\naltera_jtaguart_tx_chars(pp);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_RETVAL(isr);\r\n}\r\nstatic void altera_jtaguart_config_port(struct uart_port *port, int flags)\r\n{\r\nport->type = PORT_ALTERA_JTAGUART;\r\nwritel(0, port->membase + ALTERA_JTAGUART_CONTROL_REG);\r\n}\r\nstatic int altera_jtaguart_startup(struct uart_port *port)\r\n{\r\nstruct altera_jtaguart *pp =\r\ncontainer_of(port, struct altera_jtaguart, port);\r\nunsigned long flags;\r\nint ret;\r\nret = request_irq(port->irq, altera_jtaguart_interrupt, IRQF_DISABLED,\r\nDRV_NAME, port);\r\nif (ret) {\r\npr_err(DRV_NAME ": unable to attach Altera JTAG UART %d "\r\n"interrupt vector=%d\n", port->line, port->irq);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&port->lock, flags);\r\npp->imr = ALTERA_JTAGUART_CONTROL_RE_MSK;\r\nwritel(pp->imr, port->membase + ALTERA_JTAGUART_CONTROL_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void altera_jtaguart_shutdown(struct uart_port *port)\r\n{\r\nstruct altera_jtaguart *pp =\r\ncontainer_of(port, struct altera_jtaguart, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\npp->imr = 0;\r\nwritel(pp->imr, port->membase + ALTERA_JTAGUART_CONTROL_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic const char *altera_jtaguart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_ALTERA_JTAGUART) ? "Altera JTAG UART" : NULL;\r\n}\r\nstatic int altera_jtaguart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void altera_jtaguart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int altera_jtaguart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_ALTERA_JTAGUART)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void altera_jtaguart_console_putc(struct console *co, const char c)\r\n{\r\nstruct uart_port *port = &(altera_jtaguart_ports + co->index)->port;\r\nunsigned long status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (((status = readl(port->membase + ALTERA_JTAGUART_CONTROL_REG)) &\r\nALTERA_JTAGUART_CONTROL_WSPACE_MSK) == 0) {\r\nif ((status & ALTERA_JTAGUART_CONTROL_AC_MSK) == 0) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ncpu_relax();\r\nspin_lock_irqsave(&port->lock, flags);\r\n}\r\nwritel(c, port->membase + ALTERA_JTAGUART_DATA_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void altera_jtaguart_console_putc(struct console *co, const char c)\r\n{\r\nstruct uart_port *port = &(altera_jtaguart_ports + co->index)->port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile ((readl(port->membase + ALTERA_JTAGUART_CONTROL_REG) &\r\nALTERA_JTAGUART_CONTROL_WSPACE_MSK) == 0) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ncpu_relax();\r\nspin_lock_irqsave(&port->lock, flags);\r\n}\r\nwritel(c, port->membase + ALTERA_JTAGUART_DATA_REG);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void altera_jtaguart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nfor (; count; count--, s++) {\r\naltera_jtaguart_console_putc(co, *s);\r\nif (*s == '\n')\r\naltera_jtaguart_console_putc(co, '\r');\r\n}\r\n}\r\nstatic int __init altera_jtaguart_console_setup(struct console *co,\r\nchar *options)\r\n{\r\nstruct uart_port *port;\r\nif (co->index < 0 || co->index >= ALTERA_JTAGUART_MAXPORTS)\r\nreturn -EINVAL;\r\nport = &altera_jtaguart_ports[co->index].port;\r\nif (port->membase == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __init altera_jtaguart_console_init(void)\r\n{\r\nregister_console(&altera_jtaguart_console);\r\nreturn 0;\r\n}\r\nstatic int __devinit altera_jtaguart_probe(struct platform_device *pdev)\r\n{\r\nstruct altera_jtaguart_platform_uart *platp = pdev->dev.platform_data;\r\nstruct uart_port *port;\r\nstruct resource *res_irq, *res_mem;\r\nint i = pdev->id;\r\nif (i == -1)\r\ni = 0;\r\nif (i >= ALTERA_JTAGUART_MAXPORTS)\r\nreturn -EINVAL;\r\nport = &altera_jtaguart_ports[i].port;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res_mem)\r\nport->mapbase = res_mem->start;\r\nelse if (platp)\r\nport->mapbase = platp->mapbase;\r\nelse\r\nreturn -ENODEV;\r\nres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res_irq)\r\nport->irq = res_irq->start;\r\nelse if (platp)\r\nport->irq = platp->irq;\r\nelse\r\nreturn -ENODEV;\r\nport->membase = ioremap(port->mapbase, ALTERA_JTAGUART_SIZE);\r\nif (!port->membase)\r\nreturn -ENOMEM;\r\nport->line = i;\r\nport->type = PORT_ALTERA_JTAGUART;\r\nport->iotype = SERIAL_IO_MEM;\r\nport->ops = &altera_jtaguart_ops;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nuart_add_one_port(&altera_jtaguart_driver, port);\r\nreturn 0;\r\n}\r\nstatic int __devexit altera_jtaguart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port;\r\nint i = pdev->id;\r\nif (i == -1)\r\ni = 0;\r\nport = &altera_jtaguart_ports[i].port;\r\nuart_remove_one_port(&altera_jtaguart_driver, port);\r\nreturn 0;\r\n}\r\nstatic int __init altera_jtaguart_init(void)\r\n{\r\nint rc;\r\nrc = uart_register_driver(&altera_jtaguart_driver);\r\nif (rc)\r\nreturn rc;\r\nrc = platform_driver_register(&altera_jtaguart_platform_driver);\r\nif (rc) {\r\nuart_unregister_driver(&altera_jtaguart_driver);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit altera_jtaguart_exit(void)\r\n{\r\nplatform_driver_unregister(&altera_jtaguart_platform_driver);\r\nuart_unregister_driver(&altera_jtaguart_driver);\r\n}
