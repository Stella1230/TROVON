static void h2p2_dbg_leds_event(led_event_t evt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\nif (!(led_state & LED_STATE_ENABLED) && evt != led_start)\r\ngoto done;\r\nswitch (evt) {\r\ncase led_start:\r\nif (fpga)\r\nled_state |= LED_STATE_ENABLED;\r\nbreak;\r\ncase led_stop:\r\ncase led_halted:\r\nif (!(machine_is_omap_perseus2() || machine_is_omap_h4())) {\r\ngpio_set_value(GPIO_TIMER, 0);\r\ngpio_set_value(GPIO_IDLE, 0);\r\n}\r\n__raw_writew(~0, &fpga->leds);\r\nled_state &= ~LED_STATE_ENABLED;\r\ngoto done;\r\ncase led_claim:\r\nled_state |= LED_STATE_CLAIMED;\r\nhw_led_state = 0;\r\nbreak;\r\ncase led_release:\r\nled_state &= ~LED_STATE_CLAIMED;\r\nbreak;\r\n#ifdef CONFIG_LEDS_TIMER\r\ncase led_timer:\r\nled_state ^= LED_TIMER_ON;\r\nif (machine_is_omap_perseus2() || machine_is_omap_h4())\r\nhw_led_state ^= H2P2_DBG_FPGA_P2_LED_TIMER;\r\nelse {\r\ngpio_set_value(GPIO_TIMER,\r\nled_state & LED_TIMER_ON);\r\ngoto done;\r\n}\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_LEDS_CPU\r\ncase led_idle_start:\r\nif (machine_is_omap_perseus2() || machine_is_omap_h4())\r\nhw_led_state &= ~H2P2_DBG_FPGA_P2_LED_IDLE;\r\nelse {\r\ngpio_set_value(GPIO_IDLE, 1);\r\ngoto done;\r\n}\r\nbreak;\r\ncase led_idle_end:\r\nif (machine_is_omap_perseus2() || machine_is_omap_h4())\r\nhw_led_state |= H2P2_DBG_FPGA_P2_LED_IDLE;\r\nelse {\r\ngpio_set_value(GPIO_IDLE, 0);\r\ngoto done;\r\n}\r\nbreak;\r\n#endif\r\ncase led_green_on:\r\nhw_led_state |= H2P2_DBG_FPGA_LED_GREEN;\r\nbreak;\r\ncase led_green_off:\r\nhw_led_state &= ~H2P2_DBG_FPGA_LED_GREEN;\r\nbreak;\r\ncase led_amber_on:\r\nhw_led_state |= H2P2_DBG_FPGA_LED_AMBER;\r\nbreak;\r\ncase led_amber_off:\r\nhw_led_state &= ~H2P2_DBG_FPGA_LED_AMBER;\r\nbreak;\r\ncase led_red_on:\r\nhw_led_state |= H2P2_DBG_FPGA_LED_RED;\r\nbreak;\r\ncase led_red_off:\r\nhw_led_state &= ~H2P2_DBG_FPGA_LED_RED;\r\nbreak;\r\ncase led_blue_on:\r\nhw_led_state |= H2P2_DBG_FPGA_LED_BLUE;\r\nbreak;\r\ncase led_blue_off:\r\nhw_led_state &= ~H2P2_DBG_FPGA_LED_BLUE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (led_state & LED_STATE_ENABLED)\r\n__raw_writew(~hw_led_state, &fpga->leds);\r\ndone:\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\nstatic void\r\nfpga_led_set(struct led_classdev *cdev, enum led_brightness value)\r\n{\r\nstruct dbg_led *led = container_of(cdev, struct dbg_led, cdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\nif (value == LED_OFF)\r\nhw_led_state &= ~led->mask;\r\nelse\r\nhw_led_state |= led->mask;\r\n__raw_writew(~hw_led_state, &fpga->leds);\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\nstatic void __init newled_init(struct device *dev)\r\n{\r\nunsigned i;\r\nstruct dbg_led *led;\r\nint status;\r\nfor (i = 0, led = dbg_leds; i < ARRAY_SIZE(dbg_leds); i++, led++) {\r\nled->cdev.brightness_set = fpga_led_set;\r\nstatus = led_classdev_register(dev, &led->cdev);\r\nif (status < 0)\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int fpga_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *iomem;\r\nspin_lock_init(&lock);\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iomem)\r\nreturn -ENODEV;\r\nfpga = ioremap(iomem->start, H2P2_DBG_FPGA_SIZE);\r\n__raw_writew(~0, &fpga->leds);\r\n#ifdef CONFIG_LEDS\r\nleds_event = h2p2_dbg_leds_event;\r\nleds_event(led_start);\r\n#endif\r\nif (new_led_api()) {\r\nnewled_init(&pdev->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fpga_suspend_noirq(struct device *dev)\r\n{\r\n__raw_writew(~0, &fpga->leds);\r\nreturn 0;\r\n}\r\nstatic int fpga_resume_noirq(struct device *dev)\r\n{\r\n__raw_writew(~hw_led_state, &fpga->leds);\r\nreturn 0;\r\n}\r\nstatic int __init fpga_init(void)\r\n{\r\nif (machine_is_omap_h4()\r\n|| machine_is_omap_h3()\r\n|| machine_is_omap_h2()\r\n|| machine_is_omap_perseus2()\r\n)\r\nreturn platform_driver_register(&led_driver);\r\nreturn 0;\r\n}
