static int ssi_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\r\nif (ssi->inuse) {\r\npr_debug("ssi: already in use!\n");\r\nreturn -EBUSY;\r\n} else\r\nssi->inuse = 1;\r\nreturn 0;\r\n}\r\nstatic void ssi_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\r\nssi->inuse = 0;\r\n}\r\nstatic int ssi_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nSSIREG(SSICR) |= CR_DMAEN | CR_EN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nSSIREG(SSICR) &= ~(CR_DMAEN | CR_EN);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssi_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\r\nunsigned long ssicr = SSIREG(SSICR);\r\nunsigned int bits, channels, swl, recv, i;\r\nchannels = params_channels(params);\r\nbits = params->msbits;\r\nrecv = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? 0 : 1;\r\npr_debug("ssi_hw_params() enter\nssicr was %08lx\n", ssicr);\r\npr_debug("bits: %u channels: %u\n", bits, channels);\r\nssicr &= ~(CR_TRMD | CR_CHNL_MASK | CR_DWL_MASK | CR_PDTA |\r\nCR_SWL_MASK);\r\nif (!recv)\r\nssicr |= CR_TRMD;\r\nif ((channels < 2) || (channels > 8) || (channels & 1)) {\r\npr_debug("ssi: invalid number of channels\n");\r\nreturn -EINVAL;\r\n}\r\nssicr |= ((channels >> 1) - 1) << CR_CHNL_SHIFT;\r\ni = 0;\r\nswitch (bits) {\r\ncase 32: ++i;\r\ncase 24: ++i;\r\ncase 22: ++i;\r\ncase 20: ++i;\r\ncase 18: ++i;\r\ncase 16: ++i;\r\nssicr |= i << CR_DWL_SHIFT;\r\ncase 8: break;\r\ndefault:\r\npr_debug("ssi: invalid sample width\n");\r\nreturn -EINVAL;\r\n}\r\nif ((bits > 16) && (bits <= 24)) {\r\nbits = 24;\r\n}\r\ni = 0;\r\nswl = (bits * channels) / 2;\r\nswitch (swl) {\r\ncase 256: ++i;\r\ncase 128: ++i;\r\ncase 64: ++i;\r\ncase 48: ++i;\r\ncase 32: ++i;\r\ncase 16: ++i;\r\nssicr |= i << CR_SWL_SHIFT;\r\ncase 8: break;\r\ndefault:\r\npr_debug("ssi: invalid system word length computed\n");\r\nreturn -EINVAL;\r\n}\r\nSSIREG(SSICR) = ssicr;\r\npr_debug("ssi_hw_params() leave\nssicr is now %08lx\n", ssicr);\r\nreturn 0;\r\n}\r\nstatic int ssi_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct ssi_priv *ssi = &ssi_cpu_data[cpu_dai->id];\r\nssi->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int ssi_set_clkdiv(struct snd_soc_dai *dai, int did, int div)\r\n{\r\nstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\r\nunsigned long ssicr;\r\nint i;\r\ni = 0;\r\nssicr = SSIREG(SSICR) & ~CR_CKDIV_MASK;\r\nswitch (div) {\r\ncase 16: ++i;\r\ncase 8: ++i;\r\ncase 4: ++i;\r\ncase 2: ++i;\r\nSSIREG(SSICR) = ssicr | (i << CR_CKDIV_SHIFT);\r\ncase 1: break;\r\ndefault:\r\npr_debug("ssi: invalid sck divider %d\n", div);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssi_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct ssi_priv *ssi = &ssi_cpu_data[dai->id];\r\nunsigned long ssicr = SSIREG(SSICR);\r\npr_debug("ssi_set_fmt()\nssicr was 0x%08lx\n", ssicr);\r\nssicr &= ~(CR_DEL | CR_PDTA | CR_BREN | CR_SWSP | CR_SCKP |\r\nCR_SWS_MASTER | CR_SCK_MASTER);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nssicr |= CR_DEL | CR_PDTA;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nssicr |= CR_DEL;\r\nbreak;\r\ndefault:\r\npr_debug("ssi: unsupported format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {\r\ncase SND_SOC_DAIFMT_CONT:\r\nbreak;\r\ncase SND_SOC_DAIFMT_GATED:\r\nssicr |= CR_BREN;\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nssicr |= CR_SCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nssicr |= CR_SCKP | CR_SWSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nssicr |= CR_SWSP;\r\nbreak;\r\ndefault:\r\npr_debug("ssi: invalid inversion\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nssicr |= CR_SCK_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nssicr |= CR_SWS_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nssicr |= CR_SWS_MASTER | CR_SCK_MASTER;\r\nbreak;\r\ndefault:\r\npr_debug("ssi: invalid master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nSSIREG(SSICR) = ssicr;\r\npr_debug("ssi_set_fmt() leave\nssicr is now 0x%08lx\n", ssicr);\r\nreturn 0;\r\n}\r\nstatic int __devinit sh4_soc_dai_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_dais(&pdev->dev, sh4_ssi_dai,\r\nARRAY_SIZE(sh4_ssi_dai));\r\n}\r\nstatic int __devexit sh4_soc_dai_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_dais(&pdev->dev, ARRAY_SIZE(sh4_ssi_dai));\r\nreturn 0;\r\n}\r\nstatic int __init snd_sh4_ssi_init(void)\r\n{\r\nreturn platform_driver_register(&sh4_ssi_driver);\r\n}\r\nstatic void __exit snd_sh4_ssi_exit(void)\r\n{\r\nplatform_driver_unregister(&sh4_ssi_driver);\r\n}
