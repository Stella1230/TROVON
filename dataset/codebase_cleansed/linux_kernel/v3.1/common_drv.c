int ar6000_SetAddressWindowRegister(struct hif_device *hifDevice, u32 RegisterAddr, u32 Address)\r\n{\r\nint status;\r\nu8 addrValue[4];\r\ns32 i;\r\nfor (i = 1; i <= 3; i++) {\r\naddrValue[0] = ((u8 *)&Address)[i];\r\naddrValue[1] = addrValue[0];\r\naddrValue[2] = addrValue[0];\r\naddrValue[3] = addrValue[0];\r\nstatus = HIFReadWrite(hifDevice,\r\nRegisterAddr+i,\r\naddrValue,\r\n4,\r\nHIF_WR_SYNC_BYTE_FIX,\r\nNULL);\r\nif (status) {\r\nbreak;\r\n}\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write initial bytes of 0x%x to window reg: 0x%X \n",\r\nAddress, RegisterAddr));\r\nreturn status;\r\n}\r\nstatus = HIFReadWrite(hifDevice,\r\nRegisterAddr,\r\n(u8 *)(&Address),\r\n4,\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to window reg: 0x%X \n",\r\nAddress, RegisterAddr));\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nint ar6000_SetAddressWindowRegister(struct hif_device *hifDevice, u32 RegisterAddr, u32 Address)\r\n{\r\nint status;\r\nstatus = HIFReadWrite(hifDevice,\r\nRegisterAddr+1,\r\n((u8 *)(&Address))+1,\r\nsizeof(u32)-1,\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write initial bytes of 0x%x to window reg: 0x%X \n",\r\nRegisterAddr, Address));\r\nreturn status;\r\n}\r\nstatus = HIFReadWrite(hifDevice,\r\nRegisterAddr,\r\n(u8 *)(&Address),\r\nsizeof(u8),\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to window reg: 0x%X \n",\r\nRegisterAddr, Address));\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nar6000_ReadRegDiag(struct hif_device *hifDevice, u32 *address, u32 *data)\r\n{\r\nint status;\r\nstatus = ar6000_SetAddressWindowRegister(hifDevice,\r\nWINDOW_READ_ADDR_ADDRESS,\r\n*address);\r\nif (status) {\r\nreturn status;\r\n}\r\nstatus = HIFReadWrite(hifDevice,\r\nWINDOW_DATA_ADDRESS,\r\n(u8 *)data,\r\nsizeof(u32),\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot read from WINDOW_DATA_ADDRESS\n"));\r\nreturn status;\r\n}\r\nreturn status;\r\n}\r\nint\r\nar6000_WriteRegDiag(struct hif_device *hifDevice, u32 *address, u32 *data)\r\n{\r\nint status;\r\nstatus = HIFReadWrite(hifDevice,\r\nWINDOW_DATA_ADDRESS,\r\n(u8 *)data,\r\nsizeof(u32),\r\nHIF_WR_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to WINDOW_DATA_ADDRESS\n", *data));\r\nreturn status;\r\n}\r\nreturn ar6000_SetAddressWindowRegister(hifDevice,\r\nWINDOW_WRITE_ADDR_ADDRESS,\r\n*address);\r\n}\r\nint\r\nar6000_ReadDataDiag(struct hif_device *hifDevice, u32 address,\r\nu8 *data, u32 length)\r\n{\r\nu32 count;\r\nint status = 0;\r\nfor (count = 0; count < length; count += 4, address += 4) {\r\nif ((status = ar6000_ReadRegDiag(hifDevice, &address,\r\n(u32 *)&data[count])) != 0)\r\n{\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint\r\nar6000_WriteDataDiag(struct hif_device *hifDevice, u32 address,\r\nu8 *data, u32 length)\r\n{\r\nu32 count;\r\nint status = 0;\r\nfor (count = 0; count < length; count += 4, address += 4) {\r\nif ((status = ar6000_WriteRegDiag(hifDevice, &address,\r\n(u32 *)&data[count])) != 0)\r\n{\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint\r\nar6k_ReadTargetRegister(struct hif_device *hifDevice, int regsel, u32 *regval)\r\n{\r\nint status;\r\nu8 vals[4];\r\nu8 register_selection[4];\r\nregister_selection[0] = register_selection[1] = register_selection[2] = register_selection[3] = (regsel & 0xff);\r\nstatus = HIFReadWrite(hifDevice,\r\nCPU_DBG_SEL_ADDRESS,\r\nregister_selection,\r\n4,\r\nHIF_WR_SYNC_BYTE_FIX,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write CPU_DBG_SEL (%d)\n", regsel));\r\nreturn status;\r\n}\r\nstatus = HIFReadWrite(hifDevice,\r\nCPU_DBG_ADDRESS,\r\n(u8 *)vals,\r\nsizeof(vals),\r\nHIF_RD_SYNC_BYTE_INC,\r\nNULL);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot read from CPU_DBG_ADDRESS\n"));\r\nreturn status;\r\n}\r\n*regval = vals[0]<<0 | vals[1]<<8 | vals[2]<<16 | vals[3]<<24;\r\nreturn status;\r\n}\r\nvoid\r\nar6k_FetchTargetRegs(struct hif_device *hifDevice, u32 *targregs)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i=0; i<AR6003_FETCH_TARG_REGS_COUNT; i++) {\r\nval=0xffffffff;\r\n(void)ar6k_ReadTargetRegister(hifDevice, i, &val);\r\ntargregs[i] = val;\r\n}\r\n}\r\nint ar6000_reset_device(struct hif_device *hifDevice, u32 TargetType, bool waitForCompletion, bool coldReset)\r\n{\r\nint status = 0;\r\nu32 address;\r\nu32 data;\r\ndo {\r\nif (coldReset) {\r\ndata = RESET_CONTROL_COLD_RST_MASK;\r\n}\r\nelse {\r\ndata = RESET_CONTROL_MBOX_RST_MASK;\r\n}\r\nif (TargetType == TARGET_TYPE_AR6002) {\r\naddress = AR6002_RESET_CONTROL_ADDRESS;\r\n} else if (TargetType == TARGET_TYPE_AR6003) {\r\naddress = AR6003_RESET_CONTROL_ADDRESS;\r\n} else {\r\nA_ASSERT(0);\r\n}\r\nstatus = ar6000_WriteRegDiag(hifDevice, &address, &data);\r\nif (status) {\r\nbreak;\r\n}\r\nif (!waitForCompletion) {\r\nbreak;\r\n}\r\n#if 0\r\n(void)_delay_until_target_alive(hifDevice, 2000, TargetType);\r\nif (TargetType == TARGET_TYPE_AR6002) {\r\naddress = 0x000040C0;\r\n} else if (TargetType == TARGET_TYPE_AR6003) {\r\naddress = 0x000040C0;\r\n} else {\r\nA_ASSERT(0);\r\n}\r\ndata = 0;\r\nstatus = ar6000_ReadRegDiag(hifDevice, &address, &data);\r\nif (status) {\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Reset Cause readback: 0x%X \n",data));\r\ndata &= RESET_CAUSE_LAST_MASK;\r\nif (data != 2) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Unable to cold reset the target \n"));\r\n}\r\n#endif\r\n} while (false);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR, ("Failed to reset target \n"));\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nar6000_copy_cust_data_from_target(struct hif_device *hifDevice, u32 TargetType)\r\n{\r\nu32 eepHeaderAddr;\r\nu8 AR6003CustDataShadow[AR6003_CUST_DATA_SIZE+4];\r\ns32 i;\r\nif (BMIReadMemory(hifDevice,\r\nHOST_INTEREST_ITEM_ADDRESS(TargetType, hi_board_data),\r\n(u8 *)&eepHeaderAddr,\r\n4)!= 0)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("BMIReadMemory for reading board data address failed \n"));\r\nreturn;\r\n}\r\nif (TargetType == TARGET_TYPE_AR6003) {\r\neepHeaderAddr += 36;\r\nfor (i=0; i<AR6003_CUST_DATA_SIZE+4; i+=4){\r\nif (BMIReadSOCRegister(hifDevice, eepHeaderAddr, (u32 *)&AR6003CustDataShadow[i])!= 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("BMIReadSOCRegister () failed \n"));\r\nreturn ;\r\n}\r\neepHeaderAddr +=4;\r\n}\r\nmemcpy(custDataAR6003, AR6003CustDataShadow+1, AR6003_CUST_DATA_SIZE);\r\n}\r\nif (TargetType == TARGET_TYPE_AR6002) {\r\neepHeaderAddr += 64;\r\nfor (i=0; i<AR6002_CUST_DATA_SIZE; i+=4){\r\nif (BMIReadSOCRegister(hifDevice, eepHeaderAddr, (u32 *)&custDataAR6002[i])!= 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("BMIReadSOCRegister () failed \n"));\r\nreturn ;\r\n}\r\neepHeaderAddr +=4;\r\n}\r\n}\r\nreturn;\r\n}\r\nu8 *ar6000_get_cust_data_buffer(u32 TargetType)\r\n{\r\nif (TargetType == TARGET_TYPE_AR6003)\r\nreturn custDataAR6003;\r\nif (TargetType == TARGET_TYPE_AR6002)\r\nreturn custDataAR6002;\r\nreturn NULL;\r\n}\r\nvoid ar6000_dump_target_assert_info(struct hif_device *hifDevice, u32 TargetType)\r\n{\r\nu32 address;\r\nu32 regDumpArea = 0;\r\nint status;\r\nu32 regDumpValues[REGISTER_DUMP_LEN_MAX];\r\nu32 regDumpCount = 0;\r\nu32 i;\r\ndo {\r\naddress = HOST_INTEREST_ITEM_ADDRESS(TargetType, hi_failure_state);\r\naddress = TARG_VTOP(TargetType, address);\r\nif (TargetType == TARGET_TYPE_AR6002) {\r\nregDumpCount = REG_DUMP_COUNT_AR6002;\r\n} else if (TargetType == TARGET_TYPE_AR6003) {\r\nregDumpCount = REG_DUMP_COUNT_AR6003;\r\n} else {\r\nA_ASSERT(0);\r\n}\r\nstatus = ar6000_ReadRegDiag(hifDevice, &address, &regDumpArea);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Failed to get ptr to register dump area \n"));\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Location of register dump data: 0x%X \n",regDumpArea));\r\nif (regDumpArea == 0) {\r\nbreak;\r\n}\r\nregDumpArea = TARG_VTOP(TargetType, regDumpArea);\r\nstatus = ar6000_ReadDataDiag(hifDevice,\r\nregDumpArea,\r\n(u8 *)&regDumpValues[0],\r\nregDumpCount * (sizeof(u32)));\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Failed to get register dump \n"));\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Register Dump: \n"));\r\nfor (i = 0; i < regDumpCount; i++) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" %d : 0x%8.8X \n",i, regDumpValues[i]));\r\n#ifdef UNDER_CE\r\ntgtassertPrintf (ATH_DEBUG_TRC," %d: 0x%8.8X \n",i, regDumpValues[i]);\r\n#endif\r\n}\r\n} while (false);\r\n}\r\nint ar6000_set_htc_params(struct hif_device *hifDevice,\r\nu32 TargetType,\r\nu32 MboxIsrYieldValue,\r\nu8 HtcControlBuffers)\r\n{\r\nint status;\r\nu32 blocksizes[HTC_MAILBOX_NUM_MAX];\r\ndo {\r\nstatus = HIFConfigureDevice(hifDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,\r\nblocksizes, sizeof(blocksizes));\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR,("Failed to get block size info from HIF layer...\n"));\r\nbreak;\r\n}\r\nA_ASSERT((blocksizes[1] & (blocksizes[1] - 1)) == 0);\r\nif (HtcControlBuffers != 0) {\r\nblocksizes[1] |= ((u32)HtcControlBuffers) << 16;\r\n}\r\nstatus = BMIWriteMemory(hifDevice,\r\nHOST_INTEREST_ITEM_ADDRESS(TargetType, hi_mbox_io_block_sz),\r\n(u8 *)&blocksizes[1],\r\n4);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR,("BMIWriteMemory for IO block size failed \n"));\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_LOG_INF,("Block Size Set: %d (target address:0x%X)\n",\r\nblocksizes[1], HOST_INTEREST_ITEM_ADDRESS(TargetType, hi_mbox_io_block_sz)));\r\nif (MboxIsrYieldValue != 0) {\r\nstatus = BMIWriteMemory(hifDevice,\r\nHOST_INTEREST_ITEM_ADDRESS(TargetType, hi_mbox_isr_yield_limit),\r\n(u8 *)&MboxIsrYieldValue,\r\n4);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_LOG_ERR,("BMIWriteMemory for yield limit failed \n"));\r\nbreak;\r\n}\r\n}\r\n} while (false);\r\nreturn status;\r\n}\r\nvoid DebugDumpBytes(u8 *buffer, u16 length, char *pDescription)\r\n{\r\nchar stream[60];\r\nchar byteOffsetStr[10];\r\nu32 i;\r\nu16 offset, count, byteOffset;\r\nA_PRINTF("<---------Dumping %d Bytes : %s ------>\n", length, pDescription);\r\ncount = 0;\r\noffset = 0;\r\nbyteOffset = 0;\r\nfor(i = 0; i < length; i++) {\r\nA_SPRINTF(stream + offset, "%2.2X ", buffer[i]);\r\ncount ++;\r\noffset += 3;\r\nif(count == 16) {\r\ncount = 0;\r\noffset = 0;\r\nA_SPRINTF(byteOffsetStr,"%4.4X",byteOffset);\r\nA_PRINTF("[%s]: %s\n", byteOffsetStr, stream);\r\nA_MEMZERO(stream, 60);\r\nbyteOffset += 16;\r\n}\r\n}\r\nif(offset != 0) {\r\nA_SPRINTF(byteOffsetStr,"%4.4X",byteOffset);\r\nA_PRINTF("[%s]: %s\n", byteOffsetStr, stream);\r\n}\r\nA_PRINTF("<------------------------------------------------->\n");\r\n}\r\nvoid a_dump_module_debug_info(ATH_DEBUG_MODULE_DBG_INFO *pInfo)\r\n{\r\nint i;\r\nstruct ath_debug_mask_description *pDesc;\r\nif (pInfo == NULL) {\r\nreturn;\r\n}\r\npDesc = pInfo->pMaskDescriptions;\r\nA_PRINTF("========================================================\n\n");\r\nA_PRINTF("Module Debug Info => Name : %s \n", pInfo->ModuleName);\r\nA_PRINTF(" => Descr. : %s \n", pInfo->ModuleDescription);\r\nA_PRINTF("\n Current mask => 0x%8.8X \n", pInfo->CurrentMask);\r\nA_PRINTF("\n Avail. Debug Masks :\n\n");\r\nfor (i = 0; i < pInfo->MaxDescriptions; i++,pDesc++) {\r\nA_PRINTF(" => 0x%8.8X -- %s \n", pDesc->Mask, pDesc->Description);\r\n}\r\nif (0 == i) {\r\nA_PRINTF(" => * none defined * \n");\r\n}\r\nA_PRINTF("\n Standard Debug Masks :\n\n");\r\nA_PRINTF(" => 0x%8.8X -- Errors \n", ATH_DEBUG_ERR);\r\nA_PRINTF(" => 0x%8.8X -- Warnings \n", ATH_DEBUG_WARN);\r\nA_PRINTF(" => 0x%8.8X -- Informational \n", ATH_DEBUG_INFO);\r\nA_PRINTF(" => 0x%8.8X -- Tracing \n", ATH_DEBUG_TRC);\r\nA_PRINTF("\n========================================================\n");\r\n}\r\nstatic ATH_DEBUG_MODULE_DBG_INFO *FindModule(char *module_name)\r\n{\r\nATH_DEBUG_MODULE_DBG_INFO *pInfo = g_pModuleInfoHead;\r\nif (!g_ModuleDebugInit) {\r\nreturn NULL;\r\n}\r\nwhile (pInfo != NULL) {\r\nif (memcmp(pInfo->ModuleName,module_name,strlen(module_name)) == 0) {\r\nbreak;\r\n}\r\npInfo = pInfo->pNext;\r\n}\r\nreturn pInfo;\r\n}\r\nvoid a_register_module_debug_info(ATH_DEBUG_MODULE_DBG_INFO *pInfo)\r\n{\r\nif (!g_ModuleDebugInit) {\r\nreturn;\r\n}\r\nA_MUTEX_LOCK(&g_ModuleListLock);\r\nif (!(pInfo->Flags & ATH_DEBUG_INFO_FLAGS_REGISTERED)) {\r\nif (g_pModuleInfoHead == NULL) {\r\ng_pModuleInfoHead = pInfo;\r\n} else {\r\npInfo->pNext = g_pModuleInfoHead;\r\ng_pModuleInfoHead = pInfo;\r\n}\r\npInfo->Flags |= ATH_DEBUG_INFO_FLAGS_REGISTERED;\r\n}\r\nA_MUTEX_UNLOCK(&g_ModuleListLock);\r\n}\r\nvoid a_dump_module_debug_info_by_name(char *module_name)\r\n{\r\nATH_DEBUG_MODULE_DBG_INFO *pInfo = g_pModuleInfoHead;\r\nif (!g_ModuleDebugInit) {\r\nreturn;\r\n}\r\nif (memcmp(module_name,"all",3) == 0) {\r\nwhile (pInfo != NULL) {\r\na_dump_module_debug_info(pInfo);\r\npInfo = pInfo->pNext;\r\n}\r\nreturn;\r\n}\r\npInfo = FindModule(module_name);\r\nif (pInfo != NULL) {\r\na_dump_module_debug_info(pInfo);\r\n}\r\n}\r\nint a_get_module_mask(char *module_name, u32 *pMask)\r\n{\r\nATH_DEBUG_MODULE_DBG_INFO *pInfo = FindModule(module_name);\r\nif (NULL == pInfo) {\r\nreturn A_ERROR;\r\n}\r\n*pMask = pInfo->CurrentMask;\r\nreturn 0;\r\n}\r\nint a_set_module_mask(char *module_name, u32 Mask)\r\n{\r\nATH_DEBUG_MODULE_DBG_INFO *pInfo = FindModule(module_name);\r\nif (NULL == pInfo) {\r\nreturn A_ERROR;\r\n}\r\npInfo->CurrentMask = Mask;\r\nA_PRINTF("Module %s, new mask: 0x%8.8X \n",module_name,pInfo->CurrentMask);\r\nreturn 0;\r\n}\r\nvoid a_module_debug_support_init(void)\r\n{\r\nif (g_ModuleDebugInit) {\r\nreturn;\r\n}\r\nA_MUTEX_INIT(&g_ModuleListLock);\r\ng_pModuleInfoHead = NULL;\r\ng_ModuleDebugInit = true;\r\nA_REGISTER_MODULE_DEBUG_INFO(misc);\r\n}\r\nvoid a_module_debug_support_cleanup(void)\r\n{\r\nATH_DEBUG_MODULE_DBG_INFO *pInfo = g_pModuleInfoHead;\r\nATH_DEBUG_MODULE_DBG_INFO *pCur;\r\nif (!g_ModuleDebugInit) {\r\nreturn;\r\n}\r\ng_ModuleDebugInit = false;\r\nA_MUTEX_LOCK(&g_ModuleListLock);\r\nwhile (pInfo != NULL) {\r\npCur = pInfo;\r\npInfo = pInfo->pNext;\r\npCur->pNext = NULL;\r\npCur->Flags &= ~ATH_DEBUG_INFO_FLAGS_REGISTERED;\r\n}\r\nA_MUTEX_UNLOCK(&g_ModuleListLock);\r\nA_MUTEX_DELETE(&g_ModuleListLock);\r\ng_pModuleInfoHead = NULL;\r\n}\r\nint ar6000_set_hci_bridge_flags(struct hif_device *hifDevice,\r\nu32 TargetType,\r\nu32 Flags)\r\n{\r\nint status = 0;\r\ndo {\r\nif (TargetType != TARGET_TYPE_AR6003) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, ("Target Type:%d, does not support HCI bridging! \n",\r\nTargetType));\r\nbreak;\r\n}\r\nstatus = BMIWriteMemory(hifDevice,\r\nHOST_INTEREST_ITEM_ADDRESS(TargetType, hi_hci_bridge_flags),\r\n(u8 *)&Flags,\r\n4);\r\n} while (false);\r\nreturn status;\r\n}
