static inline u8\r\ns1d13xxxfb_readreg(struct s1d13xxxfb_par *par, u16 regno)\r\n{\r\n#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI3)\r\nregno=((regno & 1) ? (regno & ~1L) : (regno + 1));\r\n#endif\r\nreturn readb(par->regs + regno);\r\n}\r\nstatic inline void\r\ns1d13xxxfb_writereg(struct s1d13xxxfb_par *par, u16 regno, u8 value)\r\n{\r\n#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI3)\r\nregno=((regno & 1) ? (regno & ~1L) : (regno + 1));\r\n#endif\r\nwriteb(value, par->regs + regno);\r\n}\r\nstatic inline void\r\ns1d13xxxfb_runinit(struct s1d13xxxfb_par *par,\r\nconst struct s1d13xxxfb_regval *initregs,\r\nconst unsigned int size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nif ((initregs[i].addr == S1DREG_DELAYOFF) ||\r\n(initregs[i].addr == S1DREG_DELAYON))\r\nmdelay((int)initregs[i].value);\r\nelse {\r\ns1d13xxxfb_writereg(par, initregs[i].addr, initregs[i].value);\r\n}\r\n}\r\nmdelay(1);\r\n}\r\nstatic inline void\r\nlcd_enable(struct s1d13xxxfb_par *par, int enable)\r\n{\r\nu8 mode = s1d13xxxfb_readreg(par, S1DREG_COM_DISP_MODE);\r\nif (enable)\r\nmode |= 0x01;\r\nelse\r\nmode &= ~0x01;\r\ns1d13xxxfb_writereg(par, S1DREG_COM_DISP_MODE, mode);\r\n}\r\nstatic inline void\r\ncrt_enable(struct s1d13xxxfb_par *par, int enable)\r\n{\r\nu8 mode = s1d13xxxfb_readreg(par, S1DREG_COM_DISP_MODE);\r\nif (enable)\r\nmode |= 0x02;\r\nelse\r\nmode &= ~0x02;\r\ns1d13xxxfb_writereg(par, S1DREG_COM_DISP_MODE, mode);\r\n}\r\nstatic inline void\r\ns1d13xxxfb_setup_pseudocolour(struct fb_info *info)\r\n{\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->var.red.length = 4;\r\ninfo->var.green.length = 4;\r\ninfo->var.blue.length = 4;\r\n}\r\nstatic inline void\r\ns1d13xxxfb_setup_truecolour(struct fb_info *info)\r\n{\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->var.bits_per_pixel = 16;\r\ninfo->var.red.length = 5;\r\ninfo->var.red.offset = 11;\r\ninfo->var.green.length = 6;\r\ninfo->var.green.offset = 5;\r\ninfo->var.blue.length = 5;\r\ninfo->var.blue.offset = 0;\r\n}\r\nstatic int\r\ns1d13xxxfb_set_par(struct fb_info *info)\r\n{\r\nstruct s1d13xxxfb_par *s1dfb = info->par;\r\nunsigned int val;\r\ndbg("s1d13xxxfb_set_par: bpp=%d\n", info->var.bits_per_pixel);\r\nif ((s1dfb->display & 0x01))\r\nval = s1d13xxxfb_readreg(s1dfb, S1DREG_LCD_DISP_MODE);\r\nelse\r\nval = s1d13xxxfb_readreg(s1dfb, S1DREG_CRT_DISP_MODE);\r\nval &= ~0x07;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 4:\r\ndbg("pseudo colour 4\n");\r\ns1d13xxxfb_setup_pseudocolour(info);\r\nval |= 2;\r\nbreak;\r\ncase 8:\r\ndbg("pseudo colour 8\n");\r\ns1d13xxxfb_setup_pseudocolour(info);\r\nval |= 3;\r\nbreak;\r\ncase 16:\r\ndbg("true colour\n");\r\ns1d13xxxfb_setup_truecolour(info);\r\nval |= 5;\r\nbreak;\r\ndefault:\r\ndbg("bpp not supported!\n");\r\nreturn -EINVAL;\r\n}\r\ndbg("writing %02x to display mode register\n", val);\r\nif ((s1dfb->display & 0x01))\r\ns1d13xxxfb_writereg(s1dfb, S1DREG_LCD_DISP_MODE, val);\r\nelse\r\ns1d13xxxfb_writereg(s1dfb, S1DREG_CRT_DISP_MODE, val);\r\ninfo->fix.line_length = info->var.xres * info->var.bits_per_pixel;\r\ninfo->fix.line_length /= 8;\r\ndbg("setting line_length to %d\n", info->fix.line_length);\r\ndbg("done setup\n");\r\nreturn 0;\r\n}\r\nstatic int\r\ns1d13xxxfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct s1d13xxxfb_par *s1dfb = info->par;\r\nunsigned int pseudo_val;\r\nif (regno >= S1D_PALETTE_SIZE)\r\nreturn -EINVAL;\r\ndbg("s1d13xxxfb_setcolreg: %d: rgb=%d,%d,%d, tr=%d\n",\r\nregno, red, green, blue, transp);\r\nif (info->var.grayscale)\r\nred = green = blue = (19595*red + 38470*green + 7471*blue) >> 16;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\npseudo_val = (red >> 11) << info->var.red.offset;\r\npseudo_val |= (green >> 10) << info->var.green.offset;\r\npseudo_val |= (blue >> 11) << info->var.blue.offset;\r\ndbg("s1d13xxxfb_setcolreg: pseudo %d, val %08x\n",\r\nregno, pseudo_val);\r\n#if defined(CONFIG_PLAT_MAPPI)\r\n((u32 *)info->pseudo_palette)[regno] = cpu_to_le16(pseudo_val);\r\n#else\r\n((u32 *)info->pseudo_palette)[regno] = pseudo_val;\r\n#endif\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\ns1d13xxxfb_writereg(s1dfb, S1DREG_LKUP_ADDR, regno);\r\ns1d13xxxfb_writereg(s1dfb, S1DREG_LKUP_DATA, red);\r\ns1d13xxxfb_writereg(s1dfb, S1DREG_LKUP_DATA, green);\r\ns1d13xxxfb_writereg(s1dfb, S1DREG_LKUP_DATA, blue);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\ndbg("s1d13xxxfb_setcolreg: done\n");\r\nreturn 0;\r\n}\r\nstatic int\r\ns1d13xxxfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct s1d13xxxfb_par *par = info->par;\r\ndbg("s1d13xxxfb_blank: blank=%d, info=%p\n", blank_mode, info);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nif ((par->display & 0x01) != 0)\r\nlcd_enable(par, 1);\r\nif ((par->display & 0x02) != 0)\r\ncrt_enable(par, 1);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nlcd_enable(par, 0);\r\ncrt_enable(par, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ((blank_mode == FB_BLANK_NORMAL) ? 1 : 0);\r\n}\r\nstatic int\r\ns1d13xxxfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct s1d13xxxfb_par *par = info->par;\r\nu32 start;\r\nif (var->xoffset != 0)\r\nreturn -EINVAL;\r\nif (var->yoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\nstart = (info->fix.line_length >> 1) * var->yoffset;\r\nif ((par->display & 0x01)) {\r\ns1d13xxxfb_writereg(par, S1DREG_LCD_DISP_START0, (start & 0xff));\r\ns1d13xxxfb_writereg(par, S1DREG_LCD_DISP_START1, ((start >> 8) & 0xff));\r\ns1d13xxxfb_writereg(par, S1DREG_LCD_DISP_START2, ((start >> 16) & 0x0f));\r\n} else {\r\ns1d13xxxfb_writereg(par, S1DREG_CRT_DISP_START0, (start & 0xff));\r\ns1d13xxxfb_writereg(par, S1DREG_CRT_DISP_START1, ((start >> 8) & 0xff));\r\ns1d13xxxfb_writereg(par, S1DREG_CRT_DISP_START2, ((start >> 16) & 0x0f));\r\n}\r\nreturn 0;\r\n}\r\nstatic u8\r\nbltbit_wait_bitclear(struct fb_info *info, u8 bit, int timeout)\r\n{\r\nwhile (s1d13xxxfb_readreg(info->par, S1DREG_BBLT_CTL0) & bit) {\r\nudelay(10);\r\nif (!--timeout) {\r\ndbg_blit("wait_bitclear timeout\n");\r\nbreak;\r\n}\r\n}\r\nreturn timeout;\r\n}\r\nstatic void\r\ns1d13xxxfb_bitblt_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nu32 dst, src;\r\nu32 stride;\r\nu16 reverse = 0;\r\nu16 sx = area->sx, sy = area->sy;\r\nu16 dx = area->dx, dy = area->dy;\r\nu16 width = area->width, height = area->height;\r\nu16 bpp;\r\nspin_lock(&s1d13xxxfb_bitblt_lock);\r\nbpp = (info->var.bits_per_pixel >> 3);\r\nstride = bpp * info->var.xres;\r\nif ((dy > sy) || ((dy == sy) && (dx >= sx))) {\r\ndst = (((dy + height - 1) * stride) + (bpp * (dx + width - 1)));\r\nsrc = (((sy + height - 1) * stride) + (bpp * (sx + width - 1)));\r\nreverse = 1;\r\n} else {\r\ndst = (dy * stride) + (bpp * dx);\r\nsrc = (sy * stride) + (bpp * sx);\r\n}\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_SRC_START0, (src & 0xff));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_SRC_START1, (src >> 8) & 0x00ff);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_SRC_START2, (src >> 16) & 0x00ff);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START0, (dst & 0xff));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START1, (dst >> 8) & 0x00ff);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START2, (dst >> 16) & 0x00ff);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_WIDTH0, (width & 0xff) - 1);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_WIDTH1, (width >> 8));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_HEIGHT0, (height & 0xff) - 1);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_HEIGHT1, (height >> 8));\r\nif (reverse == 1) {\r\ndbg_blit("(copyarea) negative rop\n");\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_OP, 0x03);\r\n} else {\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_OP, 0x02);\r\ndbg_blit("(copyarea) positive rop\n");\r\n}\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL0, 0x0);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL1, (bpp >> 1));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_MEM_OFF0, (stride >> 1) & 0xff);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_MEM_OFF1, (stride >> 9));\r\ndbg_blit("(copyarea) dx=%d, dy=%d\n", dx, dy);\r\ndbg_blit("(copyarea) sx=%d, sy=%d\n", sx, sy);\r\ndbg_blit("(copyarea) width=%d, height=%d\n", width - 1, height - 1);\r\ndbg_blit("(copyarea) stride=%d\n", stride);\r\ndbg_blit("(copyarea) bpp=%d=0x0%d, mem_offset1=%d, mem_offset2=%d\n", bpp, (bpp >> 1),\r\n(stride >> 1) & 0xff, stride >> 9);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_CC_EXP, 0x0c);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL0, 0x80);\r\nbltbit_wait_bitclear(info, 0x80, 8000);\r\nspin_unlock(&s1d13xxxfb_bitblt_lock);\r\n}\r\nstatic void\r\ns1d13xxxfb_bitblt_solidfill(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nu32 screen_stride, dest;\r\nu32 fg;\r\nu16 bpp = (info->var.bits_per_pixel >> 3);\r\nspin_lock(&s1d13xxxfb_bitblt_lock);\r\nscreen_stride = (bpp * info->var.xres);\r\ndest = ((rect->dy * screen_stride) + (bpp * rect->dx));\r\ndbg_blit("(solidfill) dx=%d, dy=%d, stride=%d, dest=%d\n"\r\n"(solidfill) : rect_width=%d, rect_height=%d\n",\r\nrect->dx, rect->dy, screen_stride, dest,\r\nrect->width - 1, rect->height - 1);\r\ndbg_blit("(solidfill) : xres=%d, yres=%d, bpp=%d\n",\r\ninfo->var.xres, info->var.yres,\r\ninfo->var.bits_per_pixel);\r\ndbg_blit("(solidfill) : rop=%d\n", rect->rop);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START0, (dest & 0x00ff));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START1, ((dest >> 8) & 0x00ff));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_DST_START2, ((dest >> 16) & 0x00ff));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_WIDTH0, ((rect->width) & 0x00ff) - 1);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_WIDTH1, (rect->width >> 8));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_HEIGHT0, ((rect->height) & 0x00ff) - 1);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_HEIGHT1, (rect->height >> 8));\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nfg = ((u32 *)info->pseudo_palette)[rect->color];\r\ndbg_blit("(solidfill) truecolor/directcolor\n");\r\ndbg_blit("(solidfill) pseudo_palette[%d] = %d\n", rect->color, fg);\r\n} else {\r\nfg = rect->color;\r\ndbg_blit("(solidfill) color = %d\n", rect->color);\r\n}\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_FGC0, (fg & 0xff));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_FGC1, (fg >> 8) & 0xff);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL0, 0x0);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_OP, BBLT_SOLID_FILL);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL1, (info->var.bits_per_pixel >> 4));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_MEM_OFF0, (screen_stride >> 1) & 0x00ff);\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_MEM_OFF1, (screen_stride >> 9));\r\ns1d13xxxfb_writereg(info->par, S1DREG_BBLT_CTL0, 0x80);\r\nbltbit_wait_bitclear(info, 0x80, 8000);\r\nspin_unlock(&s1d13xxxfb_bitblt_lock);\r\n}\r\nstatic void __devinit\r\ns1d13xxxfb_fetch_hw_state(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nstruct s1d13xxxfb_par *par = info->par;\r\nu8 panel, display;\r\nu16 offset;\r\nu32 xres, yres;\r\nu32 xres_virtual, yres_virtual;\r\nint bpp, lcd_bpp;\r\nint is_color, is_dual, is_tft;\r\nint lcd_enabled, crt_enabled;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\npar->display = s1d13xxxfb_readreg(par, S1DREG_COM_DISP_MODE);\r\ncrt_enabled = (par->display & 0x02) != 0;\r\nlcd_enabled = (par->display & 0x01) != 0;\r\nif (lcd_enabled && crt_enabled)\r\nprintk(KERN_WARNING PFX "Warning: LCD and CRT detected, using LCD\n");\r\nif (lcd_enabled)\r\ndisplay = s1d13xxxfb_readreg(par, S1DREG_LCD_DISP_MODE);\r\nelse\r\ndisplay = s1d13xxxfb_readreg(par, S1DREG_CRT_DISP_MODE);\r\nbpp = display & 0x07;\r\nswitch (bpp) {\r\ncase 2:\r\ncase 3:\r\nvar->bits_per_pixel = 8;\r\nvar->red.offset = var->green.offset = var->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nbreak;\r\ncase 5:\r\ns1d13xxxfb_setup_truecolour(info);\r\nbreak;\r\ndefault:\r\ndbg("bpp: %i\n", bpp);\r\n}\r\nfb_alloc_cmap(&info->cmap, 256, 0);\r\npanel = s1d13xxxfb_readreg(par, S1DREG_PANEL_TYPE);\r\nis_color = (panel & 0x04) != 0;\r\nis_dual = (panel & 0x02) != 0;\r\nis_tft = (panel & 0x01) != 0;\r\nlcd_bpp = s1d13xxxfb_width_tab[is_tft][(panel >> 4) & 3];\r\nif (lcd_enabled) {\r\nxres = (s1d13xxxfb_readreg(par, S1DREG_LCD_DISP_HWIDTH) + 1) * 8;\r\nyres = (s1d13xxxfb_readreg(par, S1DREG_LCD_DISP_VHEIGHT0) +\r\n((s1d13xxxfb_readreg(par, S1DREG_LCD_DISP_VHEIGHT1) & 0x03) << 8) + 1);\r\noffset = (s1d13xxxfb_readreg(par, S1DREG_LCD_MEM_OFF0) +\r\n((s1d13xxxfb_readreg(par, S1DREG_LCD_MEM_OFF1) & 0x7) << 8));\r\n} else {\r\nxres = (s1d13xxxfb_readreg(par, S1DREG_CRT_DISP_HWIDTH) + 1) * 8;\r\nyres = (s1d13xxxfb_readreg(par, S1DREG_CRT_DISP_VHEIGHT0) +\r\n((s1d13xxxfb_readreg(par, S1DREG_CRT_DISP_VHEIGHT1) & 0x03) << 8) + 1);\r\noffset = (s1d13xxxfb_readreg(par, S1DREG_CRT_MEM_OFF0) +\r\n((s1d13xxxfb_readreg(par, S1DREG_CRT_MEM_OFF1) & 0x7) << 8));\r\n}\r\nxres_virtual = offset * 16 / var->bits_per_pixel;\r\nyres_virtual = fix->smem_len / (offset * 2);\r\nvar->xres = xres;\r\nvar->yres = yres;\r\nvar->xres_virtual = xres_virtual;\r\nvar->yres_virtual = yres_virtual;\r\nvar->xoffset = var->yoffset = 0;\r\nfix->line_length = offset * 2;\r\nvar->grayscale = !is_color;\r\nvar->activate = FB_ACTIVATE_NOW;\r\ndbg(PFX "bpp=%d, lcd_bpp=%d, "\r\n"crt_enabled=%d, lcd_enabled=%d\n",\r\nvar->bits_per_pixel, lcd_bpp, crt_enabled, lcd_enabled);\r\ndbg(PFX "xres=%d, yres=%d, vxres=%d, vyres=%d "\r\n"is_color=%d, is_dual=%d, is_tft=%d\n",\r\nxres, yres, xres_virtual, yres_virtual, is_color, is_dual, is_tft);\r\n}\r\nstatic int\r\ns1d13xxxfb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct s1d13xxxfb_par *par = NULL;\r\nif (info) {\r\npar = info->par;\r\nif (par && par->regs) {\r\ns1d13xxxfb_writereg(par, S1DREG_COM_DISP_MODE, 0x00);\r\ns1d13xxxfb_writereg(par, S1DREG_PS_CNF, 0x11);\r\niounmap(par->regs);\r\n}\r\nfb_dealloc_cmap(&info->cmap);\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nframebuffer_release(info);\r\n}\r\nrelease_mem_region(pdev->resource[0].start,\r\npdev->resource[0].end - pdev->resource[0].start +1);\r\nrelease_mem_region(pdev->resource[1].start,\r\npdev->resource[1].end - pdev->resource[1].start +1);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\ns1d13xxxfb_probe(struct platform_device *pdev)\r\n{\r\nstruct s1d13xxxfb_par *default_par;\r\nstruct fb_info *info;\r\nstruct s1d13xxxfb_pdata *pdata = NULL;\r\nint ret = 0;\r\nint i;\r\nu8 revision, prod_id;\r\ndbg("probe called: device is %p\n", pdev);\r\nprintk(KERN_INFO "Epson S1D13XXX FB Driver\n");\r\nif (pdev->dev.platform_data)\r\npdata = pdev->dev.platform_data;\r\nif (pdata && pdata->platform_init_video)\r\npdata->platform_init_video();\r\nif (pdev->num_resources != 2) {\r\ndev_err(&pdev->dev, "invalid num_resources: %i\n",\r\npdev->num_resources);\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nif (pdev->resource[0].flags != IORESOURCE_MEM\r\n|| pdev->resource[1].flags != IORESOURCE_MEM) {\r\ndev_err(&pdev->dev, "invalid resource type\n");\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nif (!request_mem_region(pdev->resource[0].start,\r\npdev->resource[0].end - pdev->resource[0].start +1, "s1d13xxxfb mem")) {\r\ndev_dbg(&pdev->dev, "request_mem_region failed\n");\r\nret = -EBUSY;\r\ngoto bail;\r\n}\r\nif (!request_mem_region(pdev->resource[1].start,\r\npdev->resource[1].end - pdev->resource[1].start +1, "s1d13xxxfb regs")) {\r\ndev_dbg(&pdev->dev, "request_mem_region failed\n");\r\nret = -EBUSY;\r\ngoto bail;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct s1d13xxxfb_par) + sizeof(u32) * 256, &pdev->dev);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\ndefault_par = info->par;\r\ndefault_par->regs = ioremap_nocache(pdev->resource[1].start,\r\npdev->resource[1].end - pdev->resource[1].start +1);\r\nif (!default_par->regs) {\r\nprintk(KERN_ERR PFX "unable to map registers\n");\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\ninfo->pseudo_palette = default_par->pseudo_palette;\r\ninfo->screen_base = ioremap_nocache(pdev->resource[0].start,\r\npdev->resource[0].end - pdev->resource[0].start +1);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR PFX "unable to map framebuffer\n");\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\nprod_id = s1d13xxxfb_readreg(default_par, S1DREG_REV_CODE) >> 2;\r\nrevision = s1d13xxxfb_readreg(default_par, S1DREG_REV_CODE) & 0x3;\r\nret = -ENODEV;\r\nfor (i = 0; i < ARRAY_SIZE(s1d13xxxfb_prod_ids); i++) {\r\nif (prod_id == s1d13xxxfb_prod_ids[i]) {\r\ndefault_par->prod_id = prod_id;\r\ndefault_par->revision = revision;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (!ret) {\r\nprintk(KERN_INFO PFX "chip production id %i = %s\n",\r\nprod_id, s1d13xxxfb_prod_names[i]);\r\nprintk(KERN_INFO PFX "chip revision %i\n", revision);\r\n} else {\r\nprintk(KERN_INFO PFX\r\n"unknown chip production id %i, revision %i\n",\r\nprod_id, revision);\r\nprintk(KERN_INFO PFX "please contant maintainer\n");\r\ngoto bail;\r\n}\r\ninfo->fix = s1d13xxxfb_fix;\r\ninfo->fix.mmio_start = pdev->resource[1].start;\r\ninfo->fix.mmio_len = pdev->resource[1].end - pdev->resource[1].start + 1;\r\ninfo->fix.smem_start = pdev->resource[0].start;\r\ninfo->fix.smem_len = pdev->resource[0].end - pdev->resource[0].start + 1;\r\nprintk(KERN_INFO PFX "regs mapped at 0x%p, fb %d KiB mapped at 0x%p\n",\r\ndefault_par->regs, info->fix.smem_len / 1024, info->screen_base);\r\ninfo->par = default_par;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\ninfo->fbops = &s1d13xxxfb_fbops;\r\nswitch(prod_id) {\r\ncase S1D13506_PROD_ID:\r\ns1d13xxxfb_fbops.fb_fillrect = s1d13xxxfb_bitblt_solidfill;\r\ns1d13xxxfb_fbops.fb_copyarea = s1d13xxxfb_bitblt_copyarea;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN |\r\nFBINFO_HWACCEL_FILLRECT | FBINFO_HWACCEL_COPYAREA;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (pdata && pdata->initregs)\r\ns1d13xxxfb_runinit(info->par, pdata->initregs, pdata->initregssize);\r\ns1d13xxxfb_fetch_hw_state(info);\r\nif (register_framebuffer(info) < 0) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\nreturn 0;\r\nbail:\r\ns1d13xxxfb_remove(pdev);\r\nreturn ret;\r\n}\r\nstatic int s1d13xxxfb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct s1d13xxxfb_par *s1dfb = info->par;\r\nstruct s1d13xxxfb_pdata *pdata = NULL;\r\nlcd_enable(s1dfb, 0);\r\ncrt_enable(s1dfb, 0);\r\nif (dev->dev.platform_data)\r\npdata = dev->dev.platform_data;\r\n#if 0\r\nif (!s1dfb->disp_save)\r\ns1dfb->disp_save = kmalloc(info->fix.smem_len, GFP_KERNEL);\r\nif (!s1dfb->disp_save) {\r\nprintk(KERN_ERR PFX "no memory to save screen");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy_fromio(s1dfb->disp_save, info->screen_base, info->fix.smem_len);\r\n#else\r\ns1dfb->disp_save = NULL;\r\n#endif\r\nif (!s1dfb->regs_save)\r\ns1dfb->regs_save = kmalloc(info->fix.mmio_len, GFP_KERNEL);\r\nif (!s1dfb->regs_save) {\r\nprintk(KERN_ERR PFX "no memory to save registers");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy_fromio(s1dfb->regs_save, s1dfb->regs, info->fix.mmio_len);\r\ns1d13xxxfb_writereg(s1dfb, S1DREG_PS_CNF, 0x11);\r\nif (pdata && pdata->platform_suspend_video)\r\nreturn pdata->platform_suspend_video();\r\nelse\r\nreturn 0;\r\n}\r\nstatic int s1d13xxxfb_resume(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct s1d13xxxfb_par *s1dfb = info->par;\r\nstruct s1d13xxxfb_pdata *pdata = NULL;\r\ns1d13xxxfb_writereg(s1dfb, S1DREG_PS_CNF, 0x10);\r\nwhile ((s1d13xxxfb_readreg(s1dfb, S1DREG_PS_STATUS) & 0x01))\r\nudelay(10);\r\nif (dev->dev.platform_data)\r\npdata = dev->dev.platform_data;\r\nif (s1dfb->regs_save) {\r\nmemcpy_toio(s1dfb->regs, s1dfb->regs_save, info->fix.mmio_len);\r\nkfree(s1dfb->regs_save);\r\n}\r\nif (s1dfb->disp_save) {\r\nmemcpy_toio(info->screen_base, s1dfb->disp_save,\r\ninfo->fix.smem_len);\r\nkfree(s1dfb->disp_save);\r\n}\r\nif ((s1dfb->display & 0x01) != 0)\r\nlcd_enable(s1dfb, 1);\r\nif ((s1dfb->display & 0x02) != 0)\r\ncrt_enable(s1dfb, 1);\r\nif (pdata && pdata->platform_resume_video)\r\nreturn pdata->platform_resume_video();\r\nelse\r\nreturn 0;\r\n}\r\nstatic int __init\r\ns1d13xxxfb_init(void)\r\n{\r\n#ifndef MODULE\r\nif (fb_get_options("s1d13xxxfb", NULL))\r\nreturn -ENODEV;\r\n#endif\r\nreturn platform_driver_register(&s1d13xxxfb_driver);\r\n}\r\nstatic void __exit\r\ns1d13xxxfb_exit(void)\r\n{\r\nplatform_driver_unregister(&s1d13xxxfb_driver);\r\n}
