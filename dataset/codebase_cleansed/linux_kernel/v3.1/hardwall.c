static int __init noudn(char *str)\r\n{\r\npr_info("User-space UDN access is disabled\n");\r\nudn_disabled = 1;\r\nreturn 0;\r\n}\r\nstatic int contains(struct hardwall_info *r, int x, int y)\r\n{\r\nreturn (x >= r->ulhc_x && x < r->ulhc_x + r->width) &&\r\n(y >= r->ulhc_y && y < r->ulhc_y + r->height);\r\n}\r\nstatic int setup_rectangle(struct hardwall_info *r, struct cpumask *mask)\r\n{\r\nint x, y, cpu, ulhc, lrhc;\r\nulhc = find_first_bit(cpumask_bits(mask), nr_cpumask_bits);\r\nlrhc = find_last_bit(cpumask_bits(mask), nr_cpumask_bits);\r\nr->ulhc_x = cpu_x(ulhc);\r\nr->ulhc_y = cpu_y(ulhc);\r\nr->width = cpu_x(lrhc) - r->ulhc_x + 1;\r\nr->height = cpu_y(lrhc) - r->ulhc_y + 1;\r\ncpumask_copy(&r->cpumask, mask);\r\nr->id = ulhc;\r\nif (r->width <= 0 || r->height <= 0)\r\nreturn -EINVAL;\r\nfor (y = 0, cpu = 0; y < smp_height; ++y)\r\nfor (x = 0; x < smp_width; ++x, ++cpu)\r\nif (cpumask_test_cpu(cpu, mask) != contains(r, x, y))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int overlaps(struct hardwall_info *a, struct hardwall_info *b)\r\n{\r\nreturn a->ulhc_x + a->width > b->ulhc_x &&\r\nb->ulhc_x + b->width > a->ulhc_x &&\r\na->ulhc_y + a->height > b->ulhc_y &&\r\nb->ulhc_y + b->height > a->ulhc_y;\r\n}\r\nstatic void enable_firewall_interrupts(void)\r\n{\r\narch_local_irq_unmask_now(INT_UDN_FIREWALL);\r\n}\r\nstatic void disable_firewall_interrupts(void)\r\n{\r\narch_local_irq_mask_now(INT_UDN_FIREWALL);\r\n}\r\nstatic void hardwall_setup_ipi_func(void *info)\r\n{\r\nstruct hardwall_info *r = info;\r\nint cpu = smp_processor_id();\r\nint x = cpu % smp_width;\r\nint y = cpu / smp_width;\r\nint bits = 0;\r\nif (x == r->ulhc_x)\r\nbits |= W_PROTECT;\r\nif (x == r->ulhc_x + r->width - 1)\r\nbits |= E_PROTECT;\r\nif (y == r->ulhc_y)\r\nbits |= N_PROTECT;\r\nif (y == r->ulhc_y + r->height - 1)\r\nbits |= S_PROTECT;\r\nBUG_ON(bits == 0);\r\n__insn_mtspr(SPR_UDN_DIRECTION_PROTECT, bits);\r\nenable_firewall_interrupts();\r\n}\r\nstatic void hardwall_setup(struct hardwall_info *r)\r\n{\r\nint x, y, cpu, delta;\r\nstruct cpumask rect_cpus;\r\ncpumask_clear(&rect_cpus);\r\ncpu = r->ulhc_y * smp_width + r->ulhc_x;\r\ndelta = (r->height - 1) * smp_width;\r\nfor (x = 0; x < r->width; ++x, ++cpu) {\r\ncpu_online_set(cpu, &rect_cpus);\r\ncpu_online_set(cpu + delta, &rect_cpus);\r\n}\r\ncpu -= r->width;\r\ndelta = r->width - 1;\r\nfor (y = 0; y < r->height; ++y, cpu += smp_width) {\r\ncpu_online_set(cpu, &rect_cpus);\r\ncpu_online_set(cpu + delta, &rect_cpus);\r\n}\r\non_each_cpu_mask(&rect_cpus, hardwall_setup_ipi_func, r, 1);\r\n}\r\nvoid __kprobes do_hardwall_trap(struct pt_regs* regs, int fault_num)\r\n{\r\nstruct hardwall_info *rect;\r\nstruct task_struct *p;\r\nstruct siginfo info;\r\nint x, y;\r\nint cpu = smp_processor_id();\r\nint found_processes;\r\nunsigned long flags;\r\nstruct pt_regs *old_regs = set_irq_regs(regs);\r\nirq_enter();\r\nx = cpu % smp_width;\r\ny = cpu / smp_width;\r\nspin_lock_irqsave(&hardwall_lock, flags);\r\nlist_for_each_entry(rect, &rectangles, list) {\r\nif (contains(rect, x, y))\r\nbreak;\r\n}\r\nBUG_ON(&rect->list == &rectangles);\r\nif (rect->teardown_in_progress) {\r\npr_notice("cpu %d: detected hardwall violation %#lx"\r\n" while teardown already in progress\n",\r\ncpu, (long) __insn_mfspr(SPR_UDN_DIRECTION_PROTECT));\r\ngoto done;\r\n}\r\nrect->teardown_in_progress = 1;\r\nwmb();\r\npr_notice("cpu %d: detected hardwall violation %#lx...\n",\r\ncpu, (long) __insn_mfspr(SPR_UDN_DIRECTION_PROTECT));\r\ninfo.si_signo = SIGILL;\r\ninfo.si_errno = 0;\r\ninfo.si_code = ILL_HARDWALL;\r\nfound_processes = 0;\r\nlist_for_each_entry(p, &rect->task_head, thread.hardwall_list) {\r\nBUG_ON(p->thread.hardwall != rect);\r\nif (!(p->flags & PF_EXITING)) {\r\nfound_processes = 1;\r\npr_notice("hardwall: killing %d\n", p->pid);\r\ndo_send_sig_info(info.si_signo, &info, p, false);\r\n}\r\n}\r\nif (!found_processes)\r\npr_notice("hardwall: no associated processes!\n");\r\ndone:\r\nspin_unlock_irqrestore(&hardwall_lock, flags);\r\ndisable_firewall_interrupts();\r\nirq_exit();\r\nset_irq_regs(old_regs);\r\n}\r\nvoid grant_network_mpls(void)\r\n{\r\n__insn_mtspr(SPR_MPL_UDN_ACCESS_SET_0, 1);\r\n__insn_mtspr(SPR_MPL_UDN_AVAIL_SET_0, 1);\r\n__insn_mtspr(SPR_MPL_UDN_COMPLETE_SET_0, 1);\r\n__insn_mtspr(SPR_MPL_UDN_TIMER_SET_0, 1);\r\n#if !CHIP_HAS_REV1_XDN()\r\n__insn_mtspr(SPR_MPL_UDN_REFILL_SET_0, 1);\r\n__insn_mtspr(SPR_MPL_UDN_CA_SET_0, 1);\r\n#endif\r\n}\r\nvoid restrict_network_mpls(void)\r\n{\r\n__insn_mtspr(SPR_MPL_UDN_ACCESS_SET_1, 1);\r\n__insn_mtspr(SPR_MPL_UDN_AVAIL_SET_1, 1);\r\n__insn_mtspr(SPR_MPL_UDN_COMPLETE_SET_1, 1);\r\n__insn_mtspr(SPR_MPL_UDN_TIMER_SET_1, 1);\r\n#if !CHIP_HAS_REV1_XDN()\r\n__insn_mtspr(SPR_MPL_UDN_REFILL_SET_1, 1);\r\n__insn_mtspr(SPR_MPL_UDN_CA_SET_1, 1);\r\n#endif\r\n}\r\nstatic struct hardwall_info *hardwall_create(\r\nsize_t size, const unsigned char __user *bits)\r\n{\r\nstruct hardwall_info *iter, *rect;\r\nstruct cpumask mask;\r\nunsigned long flags;\r\nint rc;\r\nif (size > PAGE_SIZE)\r\nreturn ERR_PTR(-EINVAL);\r\nif (copy_from_user(&mask, bits, min(sizeof(struct cpumask), size)))\r\nreturn ERR_PTR(-EFAULT);\r\nif (size < sizeof(struct cpumask)) {\r\nmemset((char *)&mask + size, 0, sizeof(struct cpumask) - size);\r\n} else if (size > sizeof(struct cpumask)) {\r\nsize_t i;\r\nfor (i = sizeof(struct cpumask); i < size; ++i) {\r\nchar c;\r\nif (get_user(c, &bits[i]))\r\nreturn ERR_PTR(-EFAULT);\r\nif (c)\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nrect = kmalloc(sizeof(struct hardwall_info),\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (rect == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&rect->task_head);\r\nrc = setup_rectangle(rect, &mask);\r\nif (rc != 0) {\r\nkfree(rect);\r\nreturn ERR_PTR(rc);\r\n}\r\nspin_lock_irqsave(&hardwall_lock, flags);\r\nlist_for_each_entry(iter, &rectangles, list) {\r\nif (overlaps(iter, rect)) {\r\nspin_unlock_irqrestore(&hardwall_lock, flags);\r\nkfree(rect);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\n}\r\nlist_add_tail(&rect->list, &rectangles);\r\nspin_unlock_irqrestore(&hardwall_lock, flags);\r\nhardwall_setup(rect);\r\nhardwall_add_proc(rect);\r\nreturn rect;\r\n}\r\nstatic int hardwall_activate(struct hardwall_info *rect)\r\n{\r\nint cpu, x, y;\r\nunsigned long flags;\r\nstruct task_struct *p = current;\r\nstruct thread_struct *ts = &p->thread;\r\nif (rect == NULL)\r\nreturn -ENODATA;\r\nif (rect->teardown_in_progress)\r\nreturn -EINVAL;\r\nif (cpumask_weight(&p->cpus_allowed) != 1)\r\nreturn -EPERM;\r\ncpu = smp_processor_id();\r\nBUG_ON(cpumask_first(&p->cpus_allowed) != cpu);\r\nx = cpu_x(cpu);\r\ny = cpu_y(cpu);\r\nif (!contains(rect, x, y))\r\nreturn -EINVAL;\r\nif (ts->hardwall) {\r\nBUG_ON(ts->hardwall != rect);\r\nreturn 0;\r\n}\r\nts->hardwall = rect;\r\nspin_lock_irqsave(&hardwall_lock, flags);\r\nlist_add(&ts->hardwall_list, &rect->task_head);\r\nspin_unlock_irqrestore(&hardwall_lock, flags);\r\ngrant_network_mpls();\r\nprintk(KERN_DEBUG "Pid %d (%s) activated for hardwall: cpu %d\n",\r\np->pid, p->comm, cpu);\r\nreturn 0;\r\n}\r\nstatic void _hardwall_deactivate(struct task_struct *task)\r\n{\r\nstruct thread_struct *ts = &task->thread;\r\nif (cpumask_weight(&task->cpus_allowed) != 1) {\r\npr_err("pid %d (%s) releasing networks with"\r\n" an affinity mask containing %d cpus!\n",\r\ntask->pid, task->comm,\r\ncpumask_weight(&task->cpus_allowed));\r\nBUG();\r\n}\r\nBUG_ON(ts->hardwall == NULL);\r\nts->hardwall = NULL;\r\nlist_del(&ts->hardwall_list);\r\nif (task == current)\r\nrestrict_network_mpls();\r\n}\r\nint hardwall_deactivate(struct task_struct *task)\r\n{\r\nunsigned long flags;\r\nint activated;\r\nspin_lock_irqsave(&hardwall_lock, flags);\r\nactivated = (task->thread.hardwall != NULL);\r\nif (activated)\r\n_hardwall_deactivate(task);\r\nspin_unlock_irqrestore(&hardwall_lock, flags);\r\nif (!activated)\r\nreturn -EINVAL;\r\nprintk(KERN_DEBUG "Pid %d (%s) deactivated for hardwall: cpu %d\n",\r\ntask->pid, task->comm, smp_processor_id());\r\nreturn 0;\r\n}\r\nstatic void stop_udn_switch(void *ignored)\r\n{\r\n#if !CHIP_HAS_REV1_XDN()\r\n__insn_mtspr(SPR_UDN_SP_FREEZE,\r\nSPR_UDN_SP_FREEZE__SP_FRZ_MASK |\r\nSPR_UDN_SP_FREEZE__DEMUX_FRZ_MASK |\r\nSPR_UDN_SP_FREEZE__NON_DEST_EXT_MASK);\r\n#endif\r\n}\r\nstatic void drain_udn_switch(void *ignored)\r\n{\r\n#if !CHIP_HAS_REV1_XDN()\r\nint i;\r\nint from_tile_words, ca_count;\r\nfor (i = 0; i < 5; i++) {\r\nint words, j;\r\n__insn_mtspr(SPR_UDN_SP_FIFO_SEL, i);\r\nwords = __insn_mfspr(SPR_UDN_SP_STATE) & 0xF;\r\nfor (j = 0; j < words; j++)\r\n(void) __insn_mfspr(SPR_UDN_SP_FIFO_DATA);\r\nBUG_ON((__insn_mfspr(SPR_UDN_SP_STATE) & 0xF) != 0);\r\n}\r\nfrom_tile_words = (__insn_mfspr(SPR_UDN_DEMUX_STATUS) >> 10) & 0x3;\r\nfor (i = 0; i < from_tile_words; i++)\r\n(void) __insn_mfspr(SPR_UDN_DEMUX_WRITE_FIFO);\r\nwhile (__insn_mfspr(SPR_UDN_DATA_AVAIL) & (1 << 0))\r\n(void) __tile_udn0_receive();\r\nwhile (__insn_mfspr(SPR_UDN_DATA_AVAIL) & (1 << 1))\r\n(void) __tile_udn1_receive();\r\nwhile (__insn_mfspr(SPR_UDN_DATA_AVAIL) & (1 << 2))\r\n(void) __tile_udn2_receive();\r\nwhile (__insn_mfspr(SPR_UDN_DATA_AVAIL) & (1 << 3))\r\n(void) __tile_udn3_receive();\r\nBUG_ON((__insn_mfspr(SPR_UDN_DATA_AVAIL) & 0xF) != 0);\r\nca_count = __insn_mfspr(SPR_UDN_DEMUX_CA_COUNT);\r\nfor (i = 0; i < ca_count; i++)\r\n(void) __insn_mfspr(SPR_UDN_CA_DATA);\r\nBUG_ON(__insn_mfspr(SPR_UDN_DEMUX_CA_COUNT) != 0);\r\n__insn_mtspr(SPR_UDN_DEMUX_CTL, 1);\r\nfor (i = 0; i < 5; i++) {\r\n__insn_mtspr(SPR_UDN_SP_FIFO_SEL, i);\r\n__insn_mtspr(SPR_UDN_SP_STATE, 0xc3000);\r\n}\r\n#endif\r\n}\r\nvoid reset_network_state(void)\r\n{\r\n#if !CHIP_HAS_REV1_XDN()\r\nunsigned int cpu = smp_processor_id();\r\nunsigned int x = cpu % smp_width;\r\nunsigned int y = cpu / smp_width;\r\n#endif\r\nif (udn_disabled)\r\nreturn;\r\n#if !CHIP_HAS_REV1_XDN()\r\n__insn_mtspr(SPR_UDN_TILE_COORD, (x << 18) | (y << 7));\r\n__insn_mtspr(SPR_UDN_TAG_VALID, 0xf);\r\n__insn_mtspr(SPR_UDN_TAG_0, (1 << 0));\r\n__insn_mtspr(SPR_UDN_TAG_1, (1 << 1));\r\n__insn_mtspr(SPR_UDN_TAG_2, (1 << 2));\r\n__insn_mtspr(SPR_UDN_TAG_3, (1 << 3));\r\n#endif\r\n__insn_mtspr(SPR_UDN_AVAIL_EN, 0);\r\n__insn_mtspr(SPR_UDN_DEADLOCK_TIMEOUT, 0);\r\n#if !CHIP_HAS_REV1_XDN()\r\n__insn_mtspr(SPR_UDN_REFILL_EN, 0);\r\n__insn_mtspr(SPR_UDN_DEMUX_QUEUE_SEL, 0);\r\n__insn_mtspr(SPR_UDN_SP_FIFO_SEL, 0);\r\n#endif\r\n#if !CHIP_HAS_REV1_XDN()\r\n__insn_mtspr(SPR_UDN_SP_FREEZE, 0);\r\n#endif\r\n}\r\nstatic void restart_udn_switch(void *ignored)\r\n{\r\nreset_network_state();\r\n__insn_mtspr(SPR_UDN_DIRECTION_PROTECT, 0);\r\ndisable_firewall_interrupts();\r\n}\r\nstatic void fill_mask(struct hardwall_info *r, struct cpumask *result)\r\n{\r\nint x, y, cpu;\r\ncpumask_clear(result);\r\ncpu = r->ulhc_y * smp_width + r->ulhc_x;\r\nfor (y = 0; y < r->height; ++y, cpu += smp_width - r->width) {\r\nfor (x = 0; x < r->width; ++x, ++cpu)\r\ncpu_online_set(cpu, result);\r\n}\r\n}\r\nstatic void hardwall_destroy(struct hardwall_info *rect)\r\n{\r\nstruct task_struct *task;\r\nunsigned long flags;\r\nstruct cpumask mask;\r\nif (rect == NULL)\r\nreturn;\r\nspin_lock_irqsave(&hardwall_lock, flags);\r\nlist_for_each_entry(task, &rect->task_head, thread.hardwall_list)\r\n_hardwall_deactivate(task);\r\nspin_unlock_irqrestore(&hardwall_lock, flags);\r\nprintk(KERN_DEBUG "Clearing hardwall rectangle %dx%d %d,%d\n",\r\nrect->width, rect->height, rect->ulhc_x, rect->ulhc_y);\r\nfill_mask(rect, &mask);\r\non_each_cpu_mask(&mask, stop_udn_switch, NULL, 1);\r\non_each_cpu_mask(&mask, drain_udn_switch, NULL, 1);\r\non_each_cpu_mask(&mask, restart_udn_switch, NULL, 1);\r\nhardwall_remove_proc(rect);\r\nspin_lock_irqsave(&hardwall_lock, flags);\r\nBUG_ON(!list_empty(&rect->task_head));\r\nlist_del(&rect->list);\r\nspin_unlock_irqrestore(&hardwall_lock, flags);\r\nkfree(rect);\r\n}\r\nstatic int hardwall_proc_show(struct seq_file *sf, void *v)\r\n{\r\nstruct hardwall_info *rect = sf->private;\r\nchar buf[256];\r\nint rc = cpulist_scnprintf(buf, sizeof(buf), &rect->cpumask);\r\nbuf[rc++] = '\n';\r\nseq_write(sf, buf, rc);\r\nreturn 0;\r\n}\r\nstatic int hardwall_proc_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, hardwall_proc_show, PDE(inode)->data);\r\n}\r\nstatic void hardwall_add_proc(struct hardwall_info *rect)\r\n{\r\nchar buf[64];\r\nsnprintf(buf, sizeof(buf), "%d", rect->id);\r\nproc_create_data(buf, 0444, hardwall_proc_dir,\r\n&hardwall_proc_fops, rect);\r\n}\r\nstatic void hardwall_remove_proc(struct hardwall_info *rect)\r\n{\r\nchar buf[64];\r\nsnprintf(buf, sizeof(buf), "%d", rect->id);\r\nremove_proc_entry(buf, hardwall_proc_dir);\r\n}\r\nint proc_pid_hardwall(struct task_struct *task, char *buffer)\r\n{\r\nstruct hardwall_info *rect = task->thread.hardwall;\r\nreturn rect ? sprintf(buffer, "%d\n", rect->id) : 0;\r\n}\r\nvoid proc_tile_hardwall_init(struct proc_dir_entry *root)\r\n{\r\nif (!udn_disabled)\r\nhardwall_proc_dir = proc_mkdir("hardwall", root);\r\n}\r\nstatic long hardwall_ioctl(struct file *file, unsigned int a, unsigned long b)\r\n{\r\nstruct hardwall_info *rect = file->private_data;\r\nif (_IOC_TYPE(a) != HARDWALL_IOCTL_BASE)\r\nreturn -EINVAL;\r\nswitch (_IOC_NR(a)) {\r\ncase _HARDWALL_CREATE:\r\nif (udn_disabled)\r\nreturn -ENOSYS;\r\nif (rect != NULL)\r\nreturn -EALREADY;\r\nrect = hardwall_create(_IOC_SIZE(a),\r\n(const unsigned char __user *)b);\r\nif (IS_ERR(rect))\r\nreturn PTR_ERR(rect);\r\nfile->private_data = rect;\r\nreturn 0;\r\ncase _HARDWALL_ACTIVATE:\r\nreturn hardwall_activate(rect);\r\ncase _HARDWALL_DEACTIVATE:\r\nif (current->thread.hardwall != rect)\r\nreturn -EINVAL;\r\nreturn hardwall_deactivate(current);\r\ncase _HARDWALL_GET_ID:\r\nreturn rect ? rect->id : -EINVAL;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic long hardwall_compat_ioctl(struct file *file,\r\nunsigned int a, unsigned long b)\r\n{\r\nreturn hardwall_ioctl(file, a, (unsigned long)compat_ptr(b));\r\n}\r\nstatic int hardwall_flush(struct file *file, fl_owner_t owner)\r\n{\r\nstruct hardwall_info *rect = file->private_data;\r\nstruct task_struct *task, *tmp;\r\nunsigned long flags;\r\nif (rect) {\r\nspin_lock_irqsave(&hardwall_lock, flags);\r\nlist_for_each_entry_safe(task, tmp, &rect->task_head,\r\nthread.hardwall_list) {\r\nif (task->files == owner || task->files == NULL)\r\n_hardwall_deactivate(task);\r\n}\r\nspin_unlock_irqrestore(&hardwall_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hardwall_release(struct inode *inode, struct file *file)\r\n{\r\nhardwall_destroy(file->private_data);\r\nreturn 0;\r\n}\r\nstatic int __init dev_hardwall_init(void)\r\n{\r\nint rc;\r\ndev_t dev;\r\nrc = alloc_chrdev_region(&dev, 0, 1, "hardwall");\r\nif (rc < 0)\r\nreturn rc;\r\ncdev_init(&hardwall_dev, &dev_hardwall_fops);\r\nrc = cdev_add(&hardwall_dev, dev, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}
