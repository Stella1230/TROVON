static unsigned short abyss_sifreadb(struct net_device *dev, unsigned short reg)\r\n{\r\nreturn inb(dev->base_addr + reg);\r\n}\r\nstatic unsigned short abyss_sifreadw(struct net_device *dev, unsigned short reg)\r\n{\r\nreturn inw(dev->base_addr + reg);\r\n}\r\nstatic void abyss_sifwriteb(struct net_device *dev, unsigned short val, unsigned short reg)\r\n{\r\noutb(val, dev->base_addr + reg);\r\n}\r\nstatic void abyss_sifwritew(struct net_device *dev, unsigned short val, unsigned short reg)\r\n{\r\noutw(val, dev->base_addr + reg);\r\n}\r\nstatic int __devinit abyss_attach(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstatic int versionprinted;\r\nstruct net_device *dev;\r\nstruct net_local *tp;\r\nint ret, pci_irq_line;\r\nunsigned long pci_ioaddr;\r\nif (versionprinted++ == 0)\r\nprintk("%s", version);\r\nif (pci_enable_device(pdev))\r\nreturn -EIO;\r\npci_irq_line = pdev->irq;\r\npci_ioaddr = pci_resource_start (pdev, 0);\r\ndev = alloc_trdev(sizeof(struct net_local));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nif (!request_region(pci_ioaddr, ABYSS_IO_EXTENT, dev->name)) {\r\nret = -EBUSY;\r\ngoto err_out_trdev;\r\n}\r\nret = request_irq(pdev->irq, tms380tr_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (ret)\r\ngoto err_out_region;\r\ndev->base_addr = pci_ioaddr;\r\ndev->irq = pci_irq_line;\r\nprintk("%s: Madge Smart 16/4 PCI Mk2 (Abyss)\n", dev->name);\r\nprintk("%s: IO: %#4lx IRQ: %d\n",\r\ndev->name, pci_ioaddr, dev->irq);\r\ndev->base_addr += 0x10;\r\nret = tmsdev_init(dev, &pdev->dev);\r\nif (ret) {\r\nprintk("%s: unable to get memory for dev->priv.\n",\r\ndev->name);\r\ngoto err_out_irq;\r\n}\r\nabyss_read_eeprom(dev);\r\nprintk("%s: Ring Station Address: %pM\n", dev->name, dev->dev_addr);\r\ntp = netdev_priv(dev);\r\ntp->setnselout = abyss_setnselout_pins;\r\ntp->sifreadb = abyss_sifreadb;\r\ntp->sifreadw = abyss_sifreadw;\r\ntp->sifwriteb = abyss_sifwriteb;\r\ntp->sifwritew = abyss_sifwritew;\r\nmemcpy(tp->ProductID, "Madge PCI 16/4 Mk2", PROD_ID_SIZE + 1);\r\ndev->netdev_ops = &abyss_netdev_ops;\r\npci_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto err_out_tmsdev;\r\nreturn 0;\r\nerr_out_tmsdev:\r\npci_set_drvdata(pdev, NULL);\r\ntmsdev_term(dev);\r\nerr_out_irq:\r\nfree_irq(pdev->irq, dev);\r\nerr_out_region:\r\nrelease_region(pci_ioaddr, ABYSS_IO_EXTENT);\r\nerr_out_trdev:\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nstatic unsigned short abyss_setnselout_pins(struct net_device *dev)\r\n{\r\nunsigned short val = 0;\r\nstruct net_local *tp = netdev_priv(dev);\r\nif(tp->DataRate == SPEED_4)\r\nval |= 0x01;\r\nelse\r\nval |= 0x00;\r\nreturn val;\r\n}\r\nstatic void at24_writedatabyte(unsigned long regaddr, unsigned char byte)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nat24_setlines(regaddr, 0, (byte >> (7-i))&0x01);\r\nat24_setlines(regaddr, 1, (byte >> (7-i))&0x01);\r\nat24_setlines(regaddr, 0, (byte >> (7-i))&0x01);\r\n}\r\n}\r\nstatic int at24_sendfullcmd(unsigned long regaddr, unsigned char cmd, unsigned char addr)\r\n{\r\nif (at24_sendcmd(regaddr, cmd)) {\r\nat24_writedatabyte(regaddr, addr);\r\nreturn at24_waitforack(regaddr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int at24_sendcmd(unsigned long regaddr, unsigned char cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nat24_start(regaddr);\r\nat24_writedatabyte(regaddr, cmd);\r\nif (at24_waitforack(regaddr))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char at24_readdatabit(unsigned long regaddr)\r\n{\r\nunsigned char val;\r\nat24_setlines(regaddr, 0, 1);\r\nat24_setlines(regaddr, 1, 1);\r\nval = (inb(regaddr) & AT24_DATA)?1:0;\r\nat24_setlines(regaddr, 1, 1);\r\nat24_setlines(regaddr, 0, 1);\r\nreturn val;\r\n}\r\nstatic unsigned char at24_readdatabyte(unsigned long regaddr)\r\n{\r\nunsigned char data = 0;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\ndata <<= 1;\r\ndata |= at24_readdatabit(regaddr);\r\n}\r\nreturn data;\r\n}\r\nstatic int at24_waitforack(unsigned long regaddr)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif ((at24_readdatabit(regaddr) & 0x01) == 0x00)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at24_waitfornack(unsigned long regaddr)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif ((at24_readdatabit(regaddr) & 0x01) == 0x01)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void at24_setlines(unsigned long regaddr, unsigned char clock, unsigned char data)\r\n{\r\nunsigned char val = AT24_ENABLE;\r\nif (clock)\r\nval |= AT24_CLOCK;\r\nif (data)\r\nval |= AT24_DATA;\r\noutb(val, regaddr);\r\ntms380tr_wait(20);\r\n}\r\nstatic void at24_start(unsigned long regaddr)\r\n{\r\nat24_setlines(regaddr, 0, 1);\r\nat24_setlines(regaddr, 1, 1);\r\nat24_setlines(regaddr, 1, 0);\r\nat24_setlines(regaddr, 0, 1);\r\n}\r\nstatic unsigned char at24_readb(unsigned long regaddr, unsigned char addr)\r\n{\r\nunsigned char data = 0xff;\r\nif (at24_sendfullcmd(regaddr, AT24_WRITE, addr)) {\r\nif (at24_sendcmd(regaddr, AT24_READ)) {\r\ndata = at24_readdatabyte(regaddr);\r\nif (!at24_waitfornack(regaddr))\r\ndata = 0xff;\r\n}\r\n}\r\nreturn data;\r\n}\r\nstatic void abyss_enable(struct net_device *dev)\r\n{\r\nunsigned char reset_reg;\r\nunsigned long ioaddr;\r\nioaddr = dev->base_addr;\r\nreset_reg = inb(ioaddr + PCIBM2_RESET_REG);\r\nreset_reg |= PCIBM2_RESET_REG_CHIP_NRES;\r\noutb(reset_reg, ioaddr + PCIBM2_RESET_REG);\r\ntms380tr_wait(100);\r\n}\r\nstatic int abyss_chipset_init(struct net_device *dev)\r\n{\r\nunsigned char reset_reg;\r\nunsigned long ioaddr;\r\nioaddr = dev->base_addr;\r\nreset_reg = inb(ioaddr + PCIBM2_RESET_REG);\r\nreset_reg |= PCIBM2_RESET_REG_CHIP_NRES;\r\noutb(reset_reg, ioaddr + PCIBM2_RESET_REG);\r\nreset_reg &= ~(PCIBM2_RESET_REG_CHIP_NRES |\r\nPCIBM2_RESET_REG_FIFO_NRES |\r\nPCIBM2_RESET_REG_SIF_NRES);\r\noutb(reset_reg, ioaddr + PCIBM2_RESET_REG);\r\ntms380tr_wait(100);\r\nreset_reg |= PCIBM2_RESET_REG_CHIP_NRES;\r\noutb(reset_reg, ioaddr + PCIBM2_RESET_REG);\r\nreset_reg |= PCIBM2_RESET_REG_SIF_NRES;\r\noutb(reset_reg, ioaddr + PCIBM2_RESET_REG);\r\nreset_reg |= PCIBM2_RESET_REG_FIFO_NRES;\r\noutb(reset_reg, ioaddr + PCIBM2_RESET_REG);\r\noutb(PCIBM2_INT_CONTROL_REG_SINTEN |\r\nPCIBM2_INT_CONTROL_REG_PCI_ERR_ENABLE,\r\nioaddr + PCIBM2_INT_CONTROL_REG);\r\noutb(30, ioaddr + PCIBM2_FIFO_THRESHOLD);\r\nreturn 0;\r\n}\r\nstatic inline void abyss_chipset_close(struct net_device *dev)\r\n{\r\nunsigned long ioaddr;\r\nioaddr = dev->base_addr;\r\noutb(0, ioaddr + PCIBM2_RESET_REG);\r\n}\r\nstatic void abyss_read_eeprom(struct net_device *dev)\r\n{\r\nstruct net_local *tp;\r\nunsigned long ioaddr;\r\nunsigned short val;\r\nint i;\r\ntp = netdev_priv(dev);\r\nioaddr = dev->base_addr;\r\nabyss_enable(dev);\r\nval = at24_readb(ioaddr + PCIBM2_SEEPROM_REG,\r\nPCIBM2_SEEPROM_RING_SPEED);\r\ntp->DataRate = val?SPEED_4:SPEED_16;\r\nprintk("%s: SEEPROM: ring speed: %dMb/sec\n", dev->name, tp->DataRate);\r\nval = at24_readb(ioaddr + PCIBM2_SEEPROM_REG,\r\nPCIBM2_SEEPROM_RAM_SIZE) * 128;\r\nprintk("%s: SEEPROM: adapter RAM: %dkb\n", dev->name, val);\r\ndev->addr_len = 6;\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = at24_readb(ioaddr + PCIBM2_SEEPROM_REG,\r\nPCIBM2_SEEPROM_BIA+i);\r\n}\r\nstatic int abyss_open(struct net_device *dev)\r\n{\r\nabyss_chipset_init(dev);\r\ntms380tr_open(dev);\r\nreturn 0;\r\n}\r\nstatic int abyss_close(struct net_device *dev)\r\n{\r\ntms380tr_close(dev);\r\nabyss_chipset_close(dev);\r\nreturn 0;\r\n}\r\nstatic void __devexit abyss_detach (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nBUG_ON(!dev);\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr-0x10, ABYSS_IO_EXTENT);\r\nfree_irq(dev->irq, dev);\r\ntmsdev_term(dev);\r\nfree_netdev(dev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int __init abyss_init (void)\r\n{\r\nabyss_netdev_ops = tms380tr_netdev_ops;\r\nabyss_netdev_ops.ndo_open = abyss_open;\r\nabyss_netdev_ops.ndo_stop = abyss_close;\r\nreturn pci_register_driver(&abyss_driver);\r\n}\r\nstatic void __exit abyss_rmmod (void)\r\n{\r\npci_unregister_driver (&abyss_driver);\r\n}
