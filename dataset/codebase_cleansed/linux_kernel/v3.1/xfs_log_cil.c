int\r\nxlog_cil_init(\r\nstruct log *log)\r\n{\r\nstruct xfs_cil *cil;\r\nstruct xfs_cil_ctx *ctx;\r\nlog->l_cilp = NULL;\r\nif (!(log->l_mp->m_flags & XFS_MOUNT_DELAYLOG))\r\nreturn 0;\r\ncil = kmem_zalloc(sizeof(*cil), KM_SLEEP|KM_MAYFAIL);\r\nif (!cil)\r\nreturn ENOMEM;\r\nctx = kmem_zalloc(sizeof(*ctx), KM_SLEEP|KM_MAYFAIL);\r\nif (!ctx) {\r\nkmem_free(cil);\r\nreturn ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&cil->xc_cil);\r\nINIT_LIST_HEAD(&cil->xc_committing);\r\nspin_lock_init(&cil->xc_cil_lock);\r\ninit_rwsem(&cil->xc_ctx_lock);\r\ninit_waitqueue_head(&cil->xc_commit_wait);\r\nINIT_LIST_HEAD(&ctx->committing);\r\nINIT_LIST_HEAD(&ctx->busy_extents);\r\nctx->sequence = 1;\r\nctx->cil = cil;\r\ncil->xc_ctx = ctx;\r\ncil->xc_current_sequence = ctx->sequence;\r\ncil->xc_log = log;\r\nlog->l_cilp = cil;\r\nreturn 0;\r\n}\r\nvoid\r\nxlog_cil_destroy(\r\nstruct log *log)\r\n{\r\nif (!log->l_cilp)\r\nreturn;\r\nif (log->l_cilp->xc_ctx) {\r\nif (log->l_cilp->xc_ctx->ticket)\r\nxfs_log_ticket_put(log->l_cilp->xc_ctx->ticket);\r\nkmem_free(log->l_cilp->xc_ctx);\r\n}\r\nASSERT(list_empty(&log->l_cilp->xc_cil));\r\nkmem_free(log->l_cilp);\r\n}\r\nstatic struct xlog_ticket *\r\nxlog_cil_ticket_alloc(\r\nstruct log *log)\r\n{\r\nstruct xlog_ticket *tic;\r\ntic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\r\nKM_SLEEP|KM_NOFS);\r\ntic->t_trans_type = XFS_TRANS_CHECKPOINT;\r\ntic->t_curr_res = 0;\r\nreturn tic;\r\n}\r\nvoid\r\nxlog_cil_init_post_recovery(\r\nstruct log *log)\r\n{\r\nif (!log->l_cilp)\r\nreturn;\r\nlog->l_cilp->xc_ctx->ticket = xlog_cil_ticket_alloc(log);\r\nlog->l_cilp->xc_ctx->sequence = 1;\r\nlog->l_cilp->xc_ctx->commit_lsn = xlog_assign_lsn(log->l_curr_cycle,\r\nlog->l_curr_block);\r\n}\r\nstatic void\r\nxlog_cil_format_items(\r\nstruct log *log,\r\nstruct xfs_log_vec *log_vector)\r\n{\r\nstruct xfs_log_vec *lv;\r\nASSERT(log_vector);\r\nfor (lv = log_vector; lv; lv = lv->lv_next) {\r\nvoid *ptr;\r\nint index;\r\nint len = 0;\r\nIOP_FORMAT(lv->lv_item, lv->lv_iovecp);\r\nfor (index = 0; index < lv->lv_niovecs; index++)\r\nlen += lv->lv_iovecp[index].i_len;\r\nlv->lv_buf_len = len;\r\nlv->lv_buf = kmem_alloc(lv->lv_buf_len, KM_SLEEP|KM_NOFS);\r\nptr = lv->lv_buf;\r\nfor (index = 0; index < lv->lv_niovecs; index++) {\r\nstruct xfs_log_iovec *vec = &lv->lv_iovecp[index];\r\nmemcpy(ptr, vec->i_addr, vec->i_len);\r\nvec->i_addr = ptr;\r\nptr += vec->i_len;\r\n}\r\nASSERT(ptr == lv->lv_buf + lv->lv_buf_len);\r\n}\r\n}\r\nSTATIC void\r\nxfs_cil_prepare_item(\r\nstruct log *log,\r\nstruct xfs_log_vec *lv,\r\nint *len,\r\nint *diff_iovecs)\r\n{\r\nstruct xfs_log_vec *old = lv->lv_item->li_lv;\r\nif (old) {\r\nASSERT(!list_empty(&lv->lv_item->li_cil));\r\nASSERT(old->lv_buf && old->lv_buf_len && old->lv_niovecs);\r\n*len += lv->lv_buf_len - old->lv_buf_len;\r\n*diff_iovecs += lv->lv_niovecs - old->lv_niovecs;\r\nkmem_free(old->lv_buf);\r\nkmem_free(old);\r\n} else {\r\nASSERT(!lv->lv_item->li_lv);\r\nASSERT(list_empty(&lv->lv_item->li_cil));\r\n*len += lv->lv_buf_len;\r\n*diff_iovecs += lv->lv_niovecs;\r\nIOP_PIN(lv->lv_item);\r\n}\r\nlv->lv_item->li_lv = lv;\r\nif (!lv->lv_item->li_seq)\r\nlv->lv_item->li_seq = log->l_cilp->xc_ctx->sequence;\r\n}\r\nstatic void\r\nxlog_cil_insert_items(\r\nstruct log *log,\r\nstruct xfs_log_vec *log_vector,\r\nstruct xlog_ticket *ticket)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nstruct xfs_cil_ctx *ctx = cil->xc_ctx;\r\nstruct xfs_log_vec *lv;\r\nint len = 0;\r\nint diff_iovecs = 0;\r\nint iclog_space;\r\nASSERT(log_vector);\r\nfor (lv = log_vector; lv; lv = lv->lv_next)\r\nxfs_cil_prepare_item(log, lv, &len, &diff_iovecs);\r\nlen += diff_iovecs * sizeof(xlog_op_header_t);\r\nspin_lock(&cil->xc_cil_lock);\r\nfor (lv = log_vector; lv; lv = lv->lv_next)\r\nlist_move_tail(&lv->lv_item->li_cil, &cil->xc_cil);\r\nctx->nvecs += diff_iovecs;\r\nif (ctx->ticket->t_curr_res == 0) {\r\nASSERT(ticket->t_curr_res >= ctx->ticket->t_unit_res + len);\r\nctx->ticket->t_curr_res = ctx->ticket->t_unit_res;\r\nticket->t_curr_res -= ctx->ticket->t_unit_res;\r\n}\r\niclog_space = log->l_iclog_size - log->l_iclog_hsize;\r\nif (len > 0 && (ctx->space_used / iclog_space !=\r\n(ctx->space_used + len) / iclog_space)) {\r\nint hdrs;\r\nhdrs = (len + iclog_space - 1) / iclog_space;\r\nhdrs *= log->l_iclog_hsize + sizeof(struct xlog_op_header);\r\nctx->ticket->t_unit_res += hdrs;\r\nctx->ticket->t_curr_res += hdrs;\r\nticket->t_curr_res -= hdrs;\r\nASSERT(ticket->t_curr_res >= len);\r\n}\r\nticket->t_curr_res -= len;\r\nctx->space_used += len;\r\nspin_unlock(&cil->xc_cil_lock);\r\n}\r\nstatic void\r\nxlog_cil_free_logvec(\r\nstruct xfs_log_vec *log_vector)\r\n{\r\nstruct xfs_log_vec *lv;\r\nfor (lv = log_vector; lv; ) {\r\nstruct xfs_log_vec *next = lv->lv_next;\r\nkmem_free(lv->lv_buf);\r\nkmem_free(lv);\r\nlv = next;\r\n}\r\n}\r\nstatic void\r\nxlog_cil_committed(\r\nvoid *args,\r\nint abort)\r\n{\r\nstruct xfs_cil_ctx *ctx = args;\r\nstruct xfs_mount *mp = ctx->cil->xc_log->l_mp;\r\nxfs_trans_committed_bulk(ctx->cil->xc_log->l_ailp, ctx->lv_chain,\r\nctx->start_lsn, abort);\r\nxfs_alloc_busy_sort(&ctx->busy_extents);\r\nxfs_alloc_busy_clear(mp, &ctx->busy_extents,\r\n(mp->m_flags & XFS_MOUNT_DISCARD) && !abort);\r\nspin_lock(&ctx->cil->xc_cil_lock);\r\nlist_del(&ctx->committing);\r\nspin_unlock(&ctx->cil->xc_cil_lock);\r\nxlog_cil_free_logvec(ctx->lv_chain);\r\nif (!list_empty(&ctx->busy_extents)) {\r\nASSERT(mp->m_flags & XFS_MOUNT_DISCARD);\r\nxfs_discard_extents(mp, &ctx->busy_extents);\r\nxfs_alloc_busy_clear(mp, &ctx->busy_extents, false);\r\n}\r\nkmem_free(ctx);\r\n}\r\nSTATIC int\r\nxlog_cil_push(\r\nstruct log *log,\r\nxfs_lsn_t push_seq)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nstruct xfs_log_vec *lv;\r\nstruct xfs_cil_ctx *ctx;\r\nstruct xfs_cil_ctx *new_ctx;\r\nstruct xlog_in_core *commit_iclog;\r\nstruct xlog_ticket *tic;\r\nint num_lv;\r\nint num_iovecs;\r\nint len;\r\nint error = 0;\r\nstruct xfs_trans_header thdr;\r\nstruct xfs_log_iovec lhdr;\r\nstruct xfs_log_vec lvhdr = { NULL };\r\nxfs_lsn_t commit_lsn;\r\nif (!cil)\r\nreturn 0;\r\nASSERT(!push_seq || push_seq <= cil->xc_ctx->sequence);\r\nnew_ctx = kmem_zalloc(sizeof(*new_ctx), KM_SLEEP|KM_NOFS);\r\nnew_ctx->ticket = xlog_cil_ticket_alloc(log);\r\nif (!down_write_trylock(&cil->xc_ctx_lock)) {\r\nif (!push_seq &&\r\ncil->xc_ctx->space_used < XLOG_CIL_HARD_SPACE_LIMIT(log))\r\ngoto out_free_ticket;\r\ndown_write(&cil->xc_ctx_lock);\r\n}\r\nctx = cil->xc_ctx;\r\nif (list_empty(&cil->xc_cil))\r\ngoto out_skip;\r\nif (!push_seq && cil->xc_ctx->space_used < XLOG_CIL_SPACE_LIMIT(log))\r\ngoto out_skip;\r\nif (push_seq && push_seq < cil->xc_ctx->sequence)\r\ngoto out_skip;\r\nlv = NULL;\r\nnum_lv = 0;\r\nnum_iovecs = 0;\r\nlen = 0;\r\nwhile (!list_empty(&cil->xc_cil)) {\r\nstruct xfs_log_item *item;\r\nint i;\r\nitem = list_first_entry(&cil->xc_cil,\r\nstruct xfs_log_item, li_cil);\r\nlist_del_init(&item->li_cil);\r\nif (!ctx->lv_chain)\r\nctx->lv_chain = item->li_lv;\r\nelse\r\nlv->lv_next = item->li_lv;\r\nlv = item->li_lv;\r\nitem->li_lv = NULL;\r\nnum_lv++;\r\nnum_iovecs += lv->lv_niovecs;\r\nfor (i = 0; i < lv->lv_niovecs; i++)\r\nlen += lv->lv_iovecp[i].i_len;\r\n}\r\nINIT_LIST_HEAD(&new_ctx->committing);\r\nINIT_LIST_HEAD(&new_ctx->busy_extents);\r\nnew_ctx->sequence = ctx->sequence + 1;\r\nnew_ctx->cil = cil;\r\ncil->xc_ctx = new_ctx;\r\ncil->xc_current_sequence = new_ctx->sequence;\r\nspin_lock(&cil->xc_cil_lock);\r\nlist_add(&ctx->committing, &cil->xc_committing);\r\nspin_unlock(&cil->xc_cil_lock);\r\nup_write(&cil->xc_ctx_lock);\r\ntic = ctx->ticket;\r\nthdr.th_magic = XFS_TRANS_HEADER_MAGIC;\r\nthdr.th_type = XFS_TRANS_CHECKPOINT;\r\nthdr.th_tid = tic->t_tid;\r\nthdr.th_num_items = num_iovecs;\r\nlhdr.i_addr = &thdr;\r\nlhdr.i_len = sizeof(xfs_trans_header_t);\r\nlhdr.i_type = XLOG_REG_TYPE_TRANSHDR;\r\ntic->t_curr_res -= lhdr.i_len + sizeof(xlog_op_header_t);\r\nlvhdr.lv_niovecs = 1;\r\nlvhdr.lv_iovecp = &lhdr;\r\nlvhdr.lv_next = ctx->lv_chain;\r\nerror = xlog_write(log, &lvhdr, tic, &ctx->start_lsn, NULL, 0);\r\nif (error)\r\ngoto out_abort_free_ticket;\r\nrestart:\r\nspin_lock(&cil->xc_cil_lock);\r\nlist_for_each_entry(new_ctx, &cil->xc_committing, committing) {\r\nif (new_ctx->sequence >= ctx->sequence)\r\ncontinue;\r\nif (!new_ctx->commit_lsn) {\r\nxlog_wait(&cil->xc_commit_wait, &cil->xc_cil_lock);\r\ngoto restart;\r\n}\r\n}\r\nspin_unlock(&cil->xc_cil_lock);\r\ncommit_lsn = xfs_log_done(log->l_mp, tic, &commit_iclog, 0);\r\nif (commit_lsn == -1)\r\ngoto out_abort;\r\nctx->log_cb.cb_func = xlog_cil_committed;\r\nctx->log_cb.cb_arg = ctx;\r\nerror = xfs_log_notify(log->l_mp, commit_iclog, &ctx->log_cb);\r\nif (error)\r\ngoto out_abort;\r\nspin_lock(&cil->xc_cil_lock);\r\nctx->commit_lsn = commit_lsn;\r\nwake_up_all(&cil->xc_commit_wait);\r\nspin_unlock(&cil->xc_cil_lock);\r\nreturn xfs_log_release_iclog(log->l_mp, commit_iclog);\r\nout_skip:\r\nup_write(&cil->xc_ctx_lock);\r\nout_free_ticket:\r\nxfs_log_ticket_put(new_ctx->ticket);\r\nkmem_free(new_ctx);\r\nreturn 0;\r\nout_abort_free_ticket:\r\nxfs_log_ticket_put(tic);\r\nout_abort:\r\nxlog_cil_committed(ctx, XFS_LI_ABORTED);\r\nreturn XFS_ERROR(EIO);\r\n}\r\nvoid\r\nxfs_log_commit_cil(\r\nstruct xfs_mount *mp,\r\nstruct xfs_trans *tp,\r\nstruct xfs_log_vec *log_vector,\r\nxfs_lsn_t *commit_lsn,\r\nint flags)\r\n{\r\nstruct log *log = mp->m_log;\r\nint log_flags = 0;\r\nint push = 0;\r\nif (flags & XFS_TRANS_RELEASE_LOG_RES)\r\nlog_flags = XFS_LOG_REL_PERM_RESERV;\r\nxlog_cil_format_items(log, log_vector);\r\ndown_read(&log->l_cilp->xc_ctx_lock);\r\nif (commit_lsn)\r\n*commit_lsn = log->l_cilp->xc_ctx->sequence;\r\nxlog_cil_insert_items(log, log_vector, tp->t_ticket);\r\nif (tp->t_ticket->t_curr_res < 0)\r\nxlog_print_tic_res(log->l_mp, tp->t_ticket);\r\nif (!list_empty(&tp->t_busy)) {\r\nspin_lock(&log->l_cilp->xc_cil_lock);\r\nlist_splice_init(&tp->t_busy,\r\n&log->l_cilp->xc_ctx->busy_extents);\r\nspin_unlock(&log->l_cilp->xc_cil_lock);\r\n}\r\ntp->t_commit_lsn = *commit_lsn;\r\nxfs_log_done(mp, tp->t_ticket, NULL, log_flags);\r\nxfs_trans_unreserve_and_mod_sb(tp);\r\nxfs_trans_free_items(tp, *commit_lsn, 0);\r\nif (log->l_cilp->xc_ctx->space_used > XLOG_CIL_SPACE_LIMIT(log))\r\npush = 1;\r\nup_read(&log->l_cilp->xc_ctx_lock);\r\nif (push)\r\nxlog_cil_push(log, 0);\r\n}\r\nxfs_lsn_t\r\nxlog_cil_force_lsn(\r\nstruct log *log,\r\nxfs_lsn_t sequence)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nstruct xfs_cil_ctx *ctx;\r\nxfs_lsn_t commit_lsn = NULLCOMMITLSN;\r\nASSERT(sequence <= cil->xc_current_sequence);\r\nif (sequence == cil->xc_current_sequence)\r\nxlog_cil_push(log, sequence);\r\nrestart:\r\nspin_lock(&cil->xc_cil_lock);\r\nlist_for_each_entry(ctx, &cil->xc_committing, committing) {\r\nif (ctx->sequence > sequence)\r\ncontinue;\r\nif (!ctx->commit_lsn) {\r\nxlog_wait(&cil->xc_commit_wait, &cil->xc_cil_lock);\r\ngoto restart;\r\n}\r\nif (ctx->sequence != sequence)\r\ncontinue;\r\ncommit_lsn = ctx->commit_lsn;\r\n}\r\nspin_unlock(&cil->xc_cil_lock);\r\nreturn commit_lsn;\r\n}\r\nbool\r\nxfs_log_item_in_current_chkpt(\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_cil_ctx *ctx;\r\nif (!(lip->li_mountp->m_flags & XFS_MOUNT_DELAYLOG))\r\nreturn false;\r\nif (list_empty(&lip->li_cil))\r\nreturn false;\r\nctx = lip->li_mountp->m_log->l_cilp->xc_ctx;\r\nif (XFS_LSN_CMP(lip->li_seq, ctx->sequence) != 0)\r\nreturn false;\r\nreturn true;\r\n}
