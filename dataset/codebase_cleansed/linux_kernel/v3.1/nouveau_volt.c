int\r\nnouveau_voltage_gpio_get(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *gpio = &dev_priv->engine.gpio;\r\nstruct nouveau_pm_voltage *volt = &dev_priv->engine.pm.voltage;\r\nu8 vid = 0;\r\nint i;\r\nfor (i = 0; i < nr_vidtag; i++) {\r\nif (!(volt->vid_mask & (1 << i)))\r\ncontinue;\r\nvid |= gpio->get(dev, vidtag[i]) << i;\r\n}\r\nreturn nouveau_volt_lvl_lookup(dev, vid);\r\n}\r\nint\r\nnouveau_voltage_gpio_set(struct drm_device *dev, int voltage)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *gpio = &dev_priv->engine.gpio;\r\nstruct nouveau_pm_voltage *volt = &dev_priv->engine.pm.voltage;\r\nint vid, i;\r\nvid = nouveau_volt_vid_lookup(dev, voltage);\r\nif (vid < 0)\r\nreturn vid;\r\nfor (i = 0; i < nr_vidtag; i++) {\r\nif (!(volt->vid_mask & (1 << i)))\r\ncontinue;\r\ngpio->set(dev, vidtag[i], !!(vid & (1 << i)));\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_volt_vid_lookup(struct drm_device *dev, int voltage)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_voltage *volt = &dev_priv->engine.pm.voltage;\r\nint i;\r\nfor (i = 0; i < volt->nr_level; i++) {\r\nif (volt->level[i].voltage == voltage)\r\nreturn volt->level[i].vid;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnouveau_volt_lvl_lookup(struct drm_device *dev, int vid)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_voltage *volt = &dev_priv->engine.pm.voltage;\r\nint i;\r\nfor (i = 0; i < volt->nr_level; i++) {\r\nif (volt->level[i].vid == vid)\r\nreturn volt->level[i].voltage;\r\n}\r\nreturn -ENOENT;\r\n}\r\nvoid\r\nnouveau_volt_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_voltage *voltage = &pm->voltage;\r\nstruct nvbios *bios = &dev_priv->vbios;\r\nstruct bit_entry P;\r\nu8 *volt = NULL, *entry;\r\nint i, headerlen, recordlen, entries, vidmask, vidshift;\r\nif (bios->type == NVBIOS_BIT) {\r\nif (bit_table(dev, 'P', &P))\r\nreturn;\r\nif (P.version == 1)\r\nvolt = ROMPTR(bios, P.data[16]);\r\nelse\r\nif (P.version == 2)\r\nvolt = ROMPTR(bios, P.data[12]);\r\nelse {\r\nNV_WARN(dev, "unknown volt for BIT P %d\n", P.version);\r\n}\r\n} else {\r\nif (bios->data[bios->offset + 6] < 0x27) {\r\nNV_DEBUG(dev, "BMP version too old for voltage\n");\r\nreturn;\r\n}\r\nvolt = ROMPTR(bios, bios->data[bios->offset + 0x98]);\r\n}\r\nif (!volt) {\r\nNV_DEBUG(dev, "voltage table pointer invalid\n");\r\nreturn;\r\n}\r\nswitch (volt[0]) {\r\ncase 0x10:\r\ncase 0x11:\r\ncase 0x12:\r\nheaderlen = 5;\r\nrecordlen = volt[1];\r\nentries = volt[2];\r\nvidshift = 0;\r\nvidmask = volt[4];\r\nbreak;\r\ncase 0x20:\r\nheaderlen = volt[1];\r\nrecordlen = volt[3];\r\nentries = volt[2];\r\nvidshift = 0;\r\nvidmask = volt[5];\r\nbreak;\r\ncase 0x30:\r\nheaderlen = volt[1];\r\nrecordlen = volt[2];\r\nentries = volt[3];\r\nvidmask = volt[4];\r\nvidshift = 2;\r\nbreak;\r\ndefault:\r\nNV_WARN(dev, "voltage table 0x%02x unknown\n", volt[0]);\r\nreturn;\r\n}\r\nvoltage->vid_mask = vidmask;\r\nif (!voltage->vid_mask)\r\nreturn;\r\ni = 0;\r\nwhile (vidmask) {\r\nif (i > nr_vidtag) {\r\nNV_DEBUG(dev, "vid bit %d unknown\n", i);\r\nreturn;\r\n}\r\nif (!nouveau_bios_gpio_entry(dev, vidtag[i])) {\r\nNV_DEBUG(dev, "vid bit %d has no gpio tag\n", i);\r\nreturn;\r\n}\r\nvidmask >>= 1;\r\ni++;\r\n}\r\nvoltage->level = kcalloc(entries, sizeof(*voltage->level), GFP_KERNEL);\r\nif (!voltage->level)\r\nreturn;\r\nentry = volt + headerlen;\r\nfor (i = 0; i < entries; i++, entry += recordlen) {\r\nvoltage->level[i].voltage = entry[0];\r\nvoltage->level[i].vid = entry[1] >> vidshift;\r\n}\r\nvoltage->nr_level = entries;\r\nvoltage->supported = true;\r\n}\r\nvoid\r\nnouveau_volt_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_voltage *volt = &dev_priv->engine.pm.voltage;\r\nkfree(volt->level);\r\n}
