static int s5h1432_writereg(struct s5h1432_state *state,\r\nu8 addr, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {.addr = addr, .flags = 0, .buf = buf, .len = 2 };\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk(KERN_ERR "%s: writereg error 0x%02x 0x%02x 0x%04x, "\r\n"ret == %i)\n", __func__, addr, reg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic u8 s5h1432_readreg(struct s5h1432_state *state, u8 addr, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{.addr = addr, .flags = 0, .buf = b0, .len = 1},\r\n{.addr = addr, .flags = I2C_M_RD, .buf = b1, .len = 1}\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\nprintk(KERN_ERR "%s: readreg error (ret == %i)\n",\r\n__func__, ret);\r\nreturn b1[0];\r\n}\r\nstatic int s5h1432_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5h1432_set_channel_bandwidth(struct dvb_frontend *fe,\r\nu32 bandwidth)\r\n{\r\nstruct s5h1432_state *state = fe->demodulator_priv;\r\nu8 reg = 0;\r\nreg = s5h1432_readreg(state, S5H1432_I2C_TOP_ADDR, 0x2E);\r\nreg &= ~(0x0C);\r\nswitch (bandwidth) {\r\ncase 6:\r\nreg |= 0x08;\r\nbreak;\r\ncase 7:\r\nreg |= 0x04;\r\nbreak;\r\ncase 8:\r\nreg |= 0x00;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x2E, reg);\r\nreturn 1;\r\n}\r\nstatic int s5h1432_set_IF(struct dvb_frontend *fe, u32 ifFreqHz)\r\n{\r\nstruct s5h1432_state *state = fe->demodulator_priv;\r\nswitch (ifFreqHz) {\r\ncase TAIWAN_HI_IF_FREQ_44_MHZ:\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x55);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x55);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0x15);\r\nbreak;\r\ncase EUROPE_HI_IF_FREQ_36_MHZ:\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x00);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x00);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0x40);\r\nbreak;\r\ncase IF_FREQ_6_MHZ:\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x00);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x00);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xe0);\r\nbreak;\r\ncase IF_FREQ_3point3_MHZ:\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x66);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x66);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xEE);\r\nbreak;\r\ncase IF_FREQ_3point5_MHZ:\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x55);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x55);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xED);\r\nbreak;\r\ncase IF_FREQ_4_MHZ:\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0xAA);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0xAA);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xEA);\r\nbreak;\r\ndefault:\r\n{\r\nu32 value = 0;\r\nvalue = (u32) (((48000 - (ifFreqHz / 1000)) * 512 *\r\n(u32) 32768) / (48 * 1000));\r\nprintk(KERN_INFO\r\n"Default IFFreq %d :reg value = 0x%x\n",\r\nifFreqHz, value);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4,\r\n(u8) value & 0xFF);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5,\r\n(u8) (value >> 8) & 0xFF);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7,\r\n(u8) (value >> 16) & 0xFF);\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int s5h1432_set_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nu32 dvb_bandwidth = 8;\r\nstruct s5h1432_state *state = fe->demodulator_priv;\r\nif (p->frequency == state->current_frequency) {\r\n} else {\r\nfe->ops.tuner_ops.set_params(fe, p);\r\nmsleep(300);\r\ns5h1432_set_channel_bandwidth(fe, dvb_bandwidth);\r\nswitch (p->u.ofdm.bandwidth) {\r\ncase BANDWIDTH_6_MHZ:\r\ndvb_bandwidth = 6;\r\ns5h1432_set_IF(fe, IF_FREQ_4_MHZ);\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\ndvb_bandwidth = 7;\r\ns5h1432_set_IF(fe, IF_FREQ_4_MHZ);\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\ndvb_bandwidth = 8;\r\ns5h1432_set_IF(fe, IF_FREQ_4_MHZ);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nmsleep(30);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1a);\r\nmsleep(30);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1b);\r\ns5h1432_set_channel_bandwidth(fe, dvb_bandwidth);\r\nswitch (p->u.ofdm.bandwidth) {\r\ncase BANDWIDTH_6_MHZ:\r\ndvb_bandwidth = 6;\r\ns5h1432_set_IF(fe, IF_FREQ_4_MHZ);\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\ndvb_bandwidth = 7;\r\ns5h1432_set_IF(fe, IF_FREQ_4_MHZ);\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\ndvb_bandwidth = 8;\r\ns5h1432_set_IF(fe, IF_FREQ_4_MHZ);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nmsleep(30);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1a);\r\nmsleep(30);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1b);\r\n}\r\nstate->current_frequency = p->frequency;\r\nreturn 0;\r\n}\r\nstatic int s5h1432_init(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1432_state *state = fe->demodulator_priv;\r\nu8 reg = 0;\r\nstate->current_frequency = 0;\r\nprintk(KERN_INFO " s5h1432_init().\n");\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x04, 0xa8);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x05, 0x01);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x07, 0x70);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x19, 0x80);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1b, 0x9D);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1c, 0x30);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1d, 0x20);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1e, 0x1B);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x2e, 0x40);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x42, 0x84);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x50, 0x5a);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x5a, 0xd3);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x68, 0x50);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xb8, 0x3c);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xc4, 0x10);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xcc, 0x9c);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xDA, 0x00);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe1, 0x94);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xf9, 0x00);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x66);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x66);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xEE);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1e, 0x31);\r\nreg = s5h1432_readreg(state, S5H1432_I2C_TOP_ADDR, 0x42);\r\nreg |= 0x80;\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x42, reg);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1a);\r\nmsleep(30);\r\ns5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1b);\r\nreturn 0;\r\n}\r\nstatic int s5h1432_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5h1432_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5h1432_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5h1432_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5h1432_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5h1432_get_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5h1432_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\nreturn 0;\r\n}\r\nstatic void s5h1432_release(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1432_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *s5h1432_attach(const struct s5h1432_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct s5h1432_state *state = NULL;\r\nprintk(KERN_INFO " Enter s5h1432_attach(). attach success!\n");\r\nstate = kmalloc(sizeof(struct s5h1432_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->current_modulation = QAM_16;\r\nstate->inversion = state->config->inversion;\r\nmemcpy(&state->frontend.ops, &s5h1432_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
