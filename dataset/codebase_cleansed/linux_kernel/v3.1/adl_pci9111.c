static int __devinit pci9111_driver_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, pci9111_driver.driver_name);\r\n}\r\nstatic void __devexit pci9111_driver_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init pci9111_driver_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&pci9111_driver);\r\nif (retval < 0)\r\nreturn retval;\r\npci9111_driver_pci_driver.name = (char *)pci9111_driver.driver_name;\r\nreturn pci_register_driver(&pci9111_driver_pci_driver);\r\n}\r\nstatic void __exit pci9111_driver_cleanup_module(void)\r\n{\r\npci_unregister_driver(&pci9111_driver_pci_driver);\r\ncomedi_driver_unregister(&pci9111_driver);\r\n}\r\nstatic void plx9050_interrupt_control(unsigned long io_base,\r\nbool LINTi1_enable,\r\nbool LINTi1_active_high,\r\nbool LINTi2_enable,\r\nbool LINTi2_active_high,\r\nbool interrupt_enable)\r\n{\r\nint flags = 0;\r\nif (LINTi1_enable)\r\nflags |= PLX9050_LINTI1_ENABLE;\r\nif (LINTi1_active_high)\r\nflags |= PLX9050_LINTI1_ACTIVE_HIGH;\r\nif (LINTi2_enable)\r\nflags |= PLX9050_LINTI2_ENABLE;\r\nif (LINTi2_active_high)\r\nflags |= PLX9050_LINTI2_ACTIVE_HIGH;\r\nif (interrupt_enable)\r\nflags |= PLX9050_PCI_INTERRUPT_ENABLE;\r\noutb(flags, io_base + PLX9050_REGISTER_INTERRUPT_CONTROL);\r\n}\r\nstatic void pci9111_timer_set(struct comedi_device *dev)\r\n{\r\npci9111_8254_control_set(PCI9111_8254_COUNTER_0 |\r\nPCI9111_8254_READ_LOAD_LSB_MSB |\r\nPCI9111_8254_MODE_0 |\r\nPCI9111_8254_BINARY_COUNTER);\r\npci9111_8254_control_set(PCI9111_8254_COUNTER_1 |\r\nPCI9111_8254_READ_LOAD_LSB_MSB |\r\nPCI9111_8254_MODE_2 |\r\nPCI9111_8254_BINARY_COUNTER);\r\npci9111_8254_control_set(PCI9111_8254_COUNTER_2 |\r\nPCI9111_8254_READ_LOAD_LSB_MSB |\r\nPCI9111_8254_MODE_2 |\r\nPCI9111_8254_BINARY_COUNTER);\r\nudelay(1);\r\npci9111_8254_counter_2_set(dev_private->timer_divisor_2);\r\npci9111_8254_counter_1_set(dev_private->timer_divisor_1);\r\n}\r\nstatic void pci9111_trigger_source_set(struct comedi_device *dev,\r\nenum pci9111_trigger_sources source)\r\n{\r\nint flags;\r\nflags = pci9111_trigger_and_autoscan_get() & 0x09;\r\nswitch (source) {\r\ncase software:\r\nflags |= PCI9111_EITS_INTERNAL | PCI9111_TPST_SOFTWARE_TRIGGER;\r\nbreak;\r\ncase timer_pacer:\r\nflags |= PCI9111_EITS_INTERNAL | PCI9111_TPST_TIMER_PACER;\r\nbreak;\r\ncase external:\r\nflags |= PCI9111_EITS_EXTERNAL;\r\nbreak;\r\n}\r\npci9111_trigger_and_autoscan_set(flags);\r\n}\r\nstatic void pci9111_pretrigger_set(struct comedi_device *dev, bool pretrigger)\r\n{\r\nint flags;\r\nflags = pci9111_trigger_and_autoscan_get() & 0x07;\r\nif (pretrigger)\r\nflags |= PCI9111_PTRG_ON;\r\npci9111_trigger_and_autoscan_set(flags);\r\n}\r\nstatic void pci9111_autoscan_set(struct comedi_device *dev, bool autoscan)\r\n{\r\nint flags;\r\nflags = pci9111_trigger_and_autoscan_get() & 0x0e;\r\nif (autoscan)\r\nflags |= PCI9111_ASCAN_ON;\r\npci9111_trigger_and_autoscan_set(flags);\r\n}\r\nstatic void pci9111_interrupt_source_set(struct comedi_device *dev,\r\nenum pci9111_ISC0_sources irq_0_source,\r\nenum pci9111_ISC1_sources irq_1_source)\r\n{\r\nint flags;\r\nflags = pci9111_interrupt_and_fifo_get() & 0x04;\r\nif (irq_0_source == irq_on_fifo_half_full)\r\nflags |= PCI9111_ISC0_SET_IRQ_ON_FIFO_HALF_FULL;\r\nif (irq_1_source == irq_on_external_trigger)\r\nflags |= PCI9111_ISC1_SET_IRQ_ON_EXT_TRG;\r\npci9111_interrupt_and_fifo_set(flags);\r\n}\r\nstatic int pci9111_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nplx9050_interrupt_control(dev_private->lcr_io_base, true, true, true,\r\ntrue, false);\r\npci9111_trigger_source_set(dev, software);\r\npci9111_autoscan_set(dev, false);\r\npci9111_fifo_reset();\r\n#ifdef AI_DO_CMD_DEBUG\r\nprintk(PCI9111_DRIVER_NAME ": ai_cancel\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\npci9111_ai_do_cmd_test(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint tmp;\r\nint error = 0;\r\nint range, reference;\r\nint i;\r\nstruct pci9111_board *board = (struct pci9111_board *)dev->board_ptr;\r\npci9111_check_trigger_src(cmd->start_src, TRIG_NOW);\r\npci9111_check_trigger_src(cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);\r\npci9111_check_trigger_src(cmd->convert_src, TRIG_TIMER | TRIG_EXT);\r\npci9111_check_trigger_src(cmd->scan_end_src, TRIG_COUNT);\r\npci9111_check_trigger_src(cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (error)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW)\r\nerror++;\r\nif ((cmd->scan_begin_src != TRIG_TIMER) &&\r\n(cmd->scan_begin_src != TRIG_FOLLOW) &&\r\n(cmd->scan_begin_src != TRIG_EXT))\r\nerror++;\r\nif ((cmd->convert_src != TRIG_TIMER) && (cmd->convert_src != TRIG_EXT))\r\nerror++;\r\nif ((cmd->convert_src == TRIG_TIMER) &&\r\n!((cmd->scan_begin_src == TRIG_TIMER) ||\r\n(cmd->scan_begin_src == TRIG_FOLLOW)))\r\nerror++;\r\nif ((cmd->convert_src == TRIG_EXT) &&\r\n!((cmd->scan_begin_src == TRIG_EXT) ||\r\n(cmd->scan_begin_src == TRIG_FOLLOW)))\r\nerror++;\r\nif (cmd->scan_end_src != TRIG_COUNT)\r\nerror++;\r\nif ((cmd->stop_src != TRIG_COUNT) && (cmd->stop_src != TRIG_NONE))\r\nerror++;\r\nif (error)\r\nreturn 2;\r\nif (cmd->chanlist_len < 1) {\r\ncmd->chanlist_len = 1;\r\nerror++;\r\n}\r\nif (cmd->chanlist_len > board->ai_channel_nbr) {\r\ncmd->chanlist_len = board->ai_channel_nbr;\r\nerror++;\r\n}\r\nif ((cmd->start_src == TRIG_NOW) && (cmd->start_arg != 0)) {\r\ncmd->start_arg = 0;\r\nerror++;\r\n}\r\nif ((cmd->convert_src == TRIG_TIMER) &&\r\n(cmd->convert_arg < board->ai_acquisition_period_min_ns)) {\r\ncmd->convert_arg = board->ai_acquisition_period_min_ns;\r\nerror++;\r\n}\r\nif ((cmd->convert_src == TRIG_EXT) && (cmd->convert_arg != 0)) {\r\ncmd->convert_arg = 0;\r\nerror++;\r\n}\r\nif ((cmd->scan_begin_src == TRIG_TIMER) &&\r\n(cmd->scan_begin_arg < board->ai_acquisition_period_min_ns)) {\r\ncmd->scan_begin_arg = board->ai_acquisition_period_min_ns;\r\nerror++;\r\n}\r\nif ((cmd->scan_begin_src == TRIG_FOLLOW)\r\n&& (cmd->scan_begin_arg != 0)) {\r\ncmd->scan_begin_arg = 0;\r\nerror++;\r\n}\r\nif ((cmd->scan_begin_src == TRIG_EXT) && (cmd->scan_begin_arg != 0)) {\r\ncmd->scan_begin_arg = 0;\r\nerror++;\r\n}\r\nif ((cmd->scan_end_src == TRIG_COUNT) &&\r\n(cmd->scan_end_arg != cmd->chanlist_len)) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerror++;\r\n}\r\nif ((cmd->stop_src == TRIG_COUNT) && (cmd->stop_arg < 1)) {\r\ncmd->stop_arg = 1;\r\nerror++;\r\n}\r\nif ((cmd->stop_src == TRIG_NONE) && (cmd->stop_arg != 0)) {\r\ncmd->stop_arg = 0;\r\nerror++;\r\n}\r\nif (error)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer_2div(PCI9111_8254_CLOCK_PERIOD_NS,\r\n&(dev_private->timer_divisor_1),\r\n&(dev_private->timer_divisor_2),\r\n&(cmd->convert_arg),\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerror++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int scan_begin_min;\r\nunsigned int scan_begin_arg;\r\nunsigned int scan_factor;\r\nscan_begin_min = cmd->chanlist_len * cmd->convert_arg;\r\nif (cmd->scan_begin_arg != scan_begin_min) {\r\nif (scan_begin_min < cmd->scan_begin_arg) {\r\nscan_factor =\r\ncmd->scan_begin_arg / scan_begin_min;\r\nscan_begin_arg = scan_factor * scan_begin_min;\r\nif (cmd->scan_begin_arg != scan_begin_arg) {\r\ncmd->scan_begin_arg = scan_begin_arg;\r\nerror++;\r\n}\r\n} else {\r\ncmd->scan_begin_arg = scan_begin_min;\r\nerror++;\r\n}\r\n}\r\n}\r\nif (error)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\nreference = CR_AREF(cmd->chanlist[0]);\r\nif (cmd->chanlist_len > 1) {\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) != i) {\r\ncomedi_error(dev,\r\n"entries in chanlist must be consecutive "\r\n"channels,counting upwards from 0\n");\r\nerror++;\r\n}\r\nif (CR_RANGE(cmd->chanlist[i]) != range) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all have the same gain\n");\r\nerror++;\r\n}\r\nif (CR_AREF(cmd->chanlist[i]) != reference) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all have the same reference\n");\r\nerror++;\r\n}\r\n}\r\n} else {\r\nif ((CR_CHAN(cmd->chanlist[0]) >\r\n(board->ai_channel_nbr - 1))\r\n|| (CR_CHAN(cmd->chanlist[0]) < 0)) {\r\ncomedi_error(dev,\r\n"channel number is out of limits\n");\r\nerror++;\r\n}\r\n}\r\n}\r\nif (error)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int pci9111_ai_do_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdevice)\r\n{\r\nstruct comedi_cmd *async_cmd = &subdevice->async->cmd;\r\nif (!dev->irq) {\r\ncomedi_error(dev,\r\n"no irq assigned for PCI9111, cannot do hardware conversion");\r\nreturn -1;\r\n}\r\nif (async_cmd->chanlist_len > 1) {\r\npci9111_ai_channel_set((async_cmd->chanlist_len) - 1);\r\npci9111_autoscan_set(dev, true);\r\n} else {\r\npci9111_ai_channel_set(CR_CHAN(async_cmd->chanlist[0]));\r\npci9111_autoscan_set(dev, false);\r\n}\r\npci9111_ai_range_set(CR_RANGE(async_cmd->chanlist[0]));\r\nswitch (async_cmd->stop_src) {\r\ncase TRIG_COUNT:\r\ndev_private->stop_counter =\r\nasync_cmd->stop_arg * async_cmd->chanlist_len;\r\ndev_private->stop_is_none = 0;\r\nbreak;\r\ncase TRIG_NONE:\r\ndev_private->stop_counter = 0;\r\ndev_private->stop_is_none = 1;\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "Invalid stop trigger");\r\nreturn -1;\r\n}\r\ndev_private->scan_delay = 0;\r\nswitch (async_cmd->convert_src) {\r\ncase TRIG_TIMER:\r\ni8253_cascade_ns_to_timer_2div(PCI9111_8254_CLOCK_PERIOD_NS,\r\n&(dev_private->timer_divisor_1),\r\n&(dev_private->timer_divisor_2),\r\n&(async_cmd->convert_arg),\r\nasync_cmd->\r\nflags & TRIG_ROUND_MASK);\r\n#ifdef AI_DO_CMD_DEBUG\r\nprintk(PCI9111_DRIVER_NAME ": divisors = %d, %d\n",\r\ndev_private->timer_divisor_1,\r\ndev_private->timer_divisor_2);\r\n#endif\r\npci9111_trigger_source_set(dev, software);\r\npci9111_timer_set(dev);\r\npci9111_fifo_reset();\r\npci9111_interrupt_source_set(dev, irq_on_fifo_half_full,\r\nirq_on_timer_tick);\r\npci9111_trigger_source_set(dev, timer_pacer);\r\nplx9050_interrupt_control(dev_private->lcr_io_base, true, true,\r\nfalse, true, true);\r\nif (async_cmd->scan_begin_src == TRIG_TIMER) {\r\ndev_private->scan_delay =\r\n(async_cmd->scan_begin_arg /\r\n(async_cmd->convert_arg *\r\nasync_cmd->chanlist_len)) - 1;\r\n}\r\nbreak;\r\ncase TRIG_EXT:\r\npci9111_trigger_source_set(dev, external);\r\npci9111_fifo_reset();\r\npci9111_interrupt_source_set(dev, irq_on_fifo_half_full,\r\nirq_on_timer_tick);\r\nplx9050_interrupt_control(dev_private->lcr_io_base, true, true,\r\nfalse, true, true);\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "Invalid convert trigger");\r\nreturn -1;\r\n}\r\ndev_private->stop_counter *= (1 + dev_private->scan_delay);\r\ndev_private->chanlist_len = async_cmd->chanlist_len;\r\ndev_private->chunk_counter = 0;\r\ndev_private->chunk_num_samples =\r\ndev_private->chanlist_len * (1 + dev_private->scan_delay);\r\n#ifdef AI_DO_CMD_DEBUG\r\nprintk(PCI9111_DRIVER_NAME ": start interruptions!\n");\r\nprintk(PCI9111_DRIVER_NAME ": trigger source = %2x\n",\r\npci9111_trigger_and_autoscan_get());\r\nprintk(PCI9111_DRIVER_NAME ": irq source = %2x\n",\r\npci9111_interrupt_and_fifo_get());\r\nprintk(PCI9111_DRIVER_NAME ": ai_do_cmd\n");\r\nprintk(PCI9111_DRIVER_NAME ": stop counter = %d\n",\r\ndev_private->stop_counter);\r\nprintk(PCI9111_DRIVER_NAME ": scan delay = %d\n",\r\ndev_private->scan_delay);\r\nprintk(PCI9111_DRIVER_NAME ": chanlist_len = %d\n",\r\ndev_private->chanlist_len);\r\nprintk(PCI9111_DRIVER_NAME ": chunk num samples = %d\n",\r\ndev_private->chunk_num_samples);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void pci9111_ai_munge(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, void *data,\r\nunsigned int num_bytes,\r\nunsigned int start_chan_index)\r\n{\r\nunsigned int i, num_samples = num_bytes / sizeof(short);\r\nshort *array = data;\r\nint resolution =\r\n((struct pci9111_board *)dev->board_ptr)->ai_resolution;\r\nfor (i = 0; i < num_samples; i++) {\r\nif (resolution == PCI9111_HR_AI_RESOLUTION)\r\narray[i] =\r\n(array[i] & PCI9111_HR_AI_RESOLUTION_MASK) ^\r\nPCI9111_HR_AI_RESOLUTION_2_CMP_BIT;\r\nelse\r\narray[i] =\r\n((array[i] >> 4) & PCI9111_AI_RESOLUTION_MASK) ^\r\nPCI9111_AI_RESOLUTION_2_CMP_BIT;\r\n}\r\n}\r\nstatic irqreturn_t pci9111_interrupt(int irq, void *p_device)\r\n{\r\nstruct comedi_device *dev = p_device;\r\nstruct comedi_subdevice *subdevice = dev->read_subdev;\r\nstruct comedi_async *async;\r\nunsigned long irq_flags;\r\nunsigned char intcsr;\r\nif (!dev->attached) {\r\nreturn IRQ_NONE;\r\n}\r\nasync = subdevice->async;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\nintcsr = inb(dev_private->lcr_io_base +\r\nPLX9050_REGISTER_INTERRUPT_CONTROL);\r\nif (!(((intcsr & PLX9050_PCI_INTERRUPT_ENABLE) != 0)\r\n&& (((intcsr & (PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS))\r\n== (PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS))\r\n|| ((intcsr & (PLX9050_LINTI2_ENABLE | PLX9050_LINTI2_STATUS))\r\n== (PLX9050_LINTI2_ENABLE | PLX9050_LINTI2_STATUS))))) {\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nreturn IRQ_NONE;\r\n}\r\nif ((intcsr & (PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS)) ==\r\n(PLX9050_LINTI1_ENABLE | PLX9050_LINTI1_STATUS)) {\r\nif (pci9111_is_fifo_full()) {\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\ncomedi_error(dev, PCI9111_DRIVER_NAME " fifo overflow");\r\npci9111_interrupt_clear();\r\npci9111_ai_cancel(dev, subdevice);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ncomedi_event(dev, subdevice);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (pci9111_is_fifo_half_full()) {\r\nunsigned int num_samples;\r\nunsigned int bytes_written = 0;\r\n#ifdef INTERRUPT_DEBUG\r\nprintk(PCI9111_DRIVER_NAME ": fifo is half full\n");\r\n#endif\r\nnum_samples =\r\nPCI9111_FIFO_HALF_SIZE >\r\ndev_private->stop_counter\r\n&& !dev_private->\r\nstop_is_none ? dev_private->stop_counter :\r\nPCI9111_FIFO_HALF_SIZE;\r\ninsw(PCI9111_IO_BASE + PCI9111_REGISTER_AD_FIFO_VALUE,\r\ndev_private->ai_bounce_buffer, num_samples);\r\nif (dev_private->scan_delay < 1) {\r\nbytes_written =\r\ncfc_write_array_to_buffer(subdevice,\r\ndev_private->\r\nai_bounce_buffer,\r\nnum_samples *\r\nsizeof(short));\r\n} else {\r\nint position = 0;\r\nint to_read;\r\nwhile (position < num_samples) {\r\nif (dev_private->chunk_counter <\r\ndev_private->chanlist_len) {\r\nto_read =\r\ndev_private->chanlist_len -\r\ndev_private->chunk_counter;\r\nif (to_read >\r\nnum_samples - position)\r\nto_read =\r\nnum_samples -\r\nposition;\r\nbytes_written +=\r\ncfc_write_array_to_buffer\r\n(subdevice,\r\ndev_private->ai_bounce_buffer\r\n+ position,\r\nto_read * sizeof(short));\r\n} else {\r\nto_read =\r\ndev_private->chunk_num_samples\r\n-\r\ndev_private->chunk_counter;\r\nif (to_read >\r\nnum_samples - position)\r\nto_read =\r\nnum_samples -\r\nposition;\r\nbytes_written +=\r\nsizeof(short) * to_read;\r\n}\r\nposition += to_read;\r\ndev_private->chunk_counter += to_read;\r\nif (dev_private->chunk_counter >=\r\ndev_private->chunk_num_samples)\r\ndev_private->chunk_counter = 0;\r\n}\r\n}\r\ndev_private->stop_counter -=\r\nbytes_written / sizeof(short);\r\n}\r\n}\r\nif ((dev_private->stop_counter == 0) && (!dev_private->stop_is_none)) {\r\nasync->events |= COMEDI_CB_EOA;\r\npci9111_ai_cancel(dev, subdevice);\r\n}\r\npci9111_interrupt_clear();\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\ncomedi_event(dev, subdevice);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pci9111_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdevice,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint resolution =\r\n((struct pci9111_board *)dev->board_ptr)->ai_resolution;\r\nint timeout, i;\r\n#ifdef AI_INSN_DEBUG\r\nprintk(PCI9111_DRIVER_NAME ": ai_insn set c/r/n = %2x/%2x/%2x\n",\r\nCR_CHAN((&insn->chanspec)[0]),\r\nCR_RANGE((&insn->chanspec)[0]), insn->n);\r\n#endif\r\npci9111_ai_channel_set(CR_CHAN((&insn->chanspec)[0]));\r\nif ((pci9111_ai_range_get()) != CR_RANGE((&insn->chanspec)[0]))\r\npci9111_ai_range_set(CR_RANGE((&insn->chanspec)[0]));\r\npci9111_fifo_reset();\r\nfor (i = 0; i < insn->n; i++) {\r\npci9111_software_trigger();\r\ntimeout = PCI9111_AI_INSTANT_READ_TIMEOUT;\r\nwhile (timeout--) {\r\nif (!pci9111_is_fifo_empty())\r\ngoto conversion_done;\r\n}\r\ncomedi_error(dev, "A/D read timeout");\r\ndata[i] = 0;\r\npci9111_fifo_reset();\r\nreturn -ETIME;\r\nconversion_done:\r\nif (resolution == PCI9111_HR_AI_RESOLUTION)\r\ndata[i] = pci9111_hr_ai_get_data();\r\nelse\r\ndata[i] = pci9111_ai_get_data();\r\n}\r\n#ifdef AI_INSN_DEBUG\r\nprintk(PCI9111_DRIVER_NAME ": ai_insn get c/r/t = %2x/%2x/%2x\n",\r\npci9111_ai_channel_get(),\r\npci9111_ai_range_get(), pci9111_trigger_and_autoscan_get());\r\n#endif\r\nreturn i;\r\n}\r\nstatic int\r\npci9111_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\npci9111_ao_set_data(data[i]);\r\ndev_private->ao_readback = data[i];\r\n}\r\nreturn i;\r\n}\r\nstatic int pci9111_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = dev_private->ao_readback & PCI9111_AO_RESOLUTION_MASK;\r\nreturn i;\r\n}\r\nstatic int pci9111_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdevice,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int bits;\r\nbits = pci9111_di_get_bits();\r\ndata[1] = bits;\r\nreturn 2;\r\n}\r\nstatic int pci9111_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdevice,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int bits;\r\ndata[0] &= PCI9111_DO_MASK;\r\nbits = subdevice->state;\r\nbits &= ~data[0];\r\nbits |= data[0] & data[1];\r\nsubdevice->state = bits;\r\npci9111_do_set_bits(bits);\r\ndata[1] = bits;\r\nreturn 2;\r\n}\r\nstatic int pci9111_reset(struct comedi_device *dev)\r\n{\r\nplx9050_interrupt_control(dev_private->lcr_io_base, true, true, true,\r\ntrue, false);\r\npci9111_trigger_source_set(dev, software);\r\npci9111_pretrigger_set(dev, false);\r\npci9111_autoscan_set(dev, false);\r\ndev_private->timer_divisor_1 = 0;\r\ndev_private->timer_divisor_2 = 0;\r\npci9111_timer_set(dev);\r\nreturn 0;\r\n}\r\nstatic int pci9111_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *subdevice;\r\nunsigned long io_base, io_range, lcr_io_base, lcr_io_range;\r\nstruct pci_dev *pci_device = NULL;\r\nint error, i;\r\nconst struct pci9111_board *board;\r\nif (alloc_private(dev, sizeof(struct pci9111_private_data)) < 0)\r\nreturn -ENOMEM;\r\nprintk(KERN_ERR "comedi%d: " PCI9111_DRIVER_NAME " driver\n",\r\ndev->minor);\r\nfor_each_pci_dev(pci_device) {\r\nif (pci_device->vendor == PCI_VENDOR_ID_ADLINK) {\r\nfor (i = 0; i < pci9111_board_nbr; i++) {\r\nif (pci9111_boards[i].device_id ==\r\npci_device->device) {\r\nif ((it->options[0] != 0)\r\n|| (it->options[1] != 0)) {\r\nif (pci_device->bus->number !=\r\nit->options[0]\r\n||\r\nPCI_SLOT(pci_device->devfn)\r\n!= it->options[1]) {\r\ncontinue;\r\n}\r\n}\r\ndev->board_ptr = pci9111_boards + i;\r\nboard =\r\n(struct pci9111_board *)\r\ndev->board_ptr;\r\ndev_private->pci_device = pci_device;\r\ngoto found;\r\n}\r\n}\r\n}\r\n}\r\nprintk(KERN_ERR\r\n"comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",\r\ndev->minor, it->options[0], it->options[1]);\r\nreturn -EIO;\r\nfound:\r\nprintk(KERN_ERR "comedi%d: found %s (b:s:f=%d:%d:%d) , irq=%d\n",\r\ndev->minor,\r\npci9111_boards[i].name,\r\npci_device->bus->number,\r\nPCI_SLOT(pci_device->devfn),\r\nPCI_FUNC(pci_device->devfn), pci_device->irq);\r\nlcr_io_base = pci_resource_start(pci_device, 1);\r\nlcr_io_range = pci_resource_len(pci_device, 1);\r\nprintk\r\n("comedi%d: local configuration registers at address 0x%4lx [0x%4lx]\n",\r\ndev->minor, lcr_io_base, lcr_io_range);\r\nif (comedi_pci_enable(pci_device, PCI9111_DRIVER_NAME) < 0) {\r\nprintk\r\n("comedi%d: Failed to enable PCI device and request regions\n",\r\ndev->minor);\r\nreturn -EIO;\r\n}\r\nio_base = pci_resource_start(pci_device, 2);\r\nio_range = pci_resource_len(pci_device, 2);\r\nprintk(KERN_ERR "comedi%d: 6503 registers at address 0x%4lx [0x%4lx]\n",\r\ndev->minor, io_base, io_range);\r\ndev->iobase = io_base;\r\ndev->board_name = board->name;\r\ndev_private->io_range = io_range;\r\ndev_private->is_valid = 0;\r\ndev_private->lcr_io_base = lcr_io_base;\r\ndev_private->lcr_io_range = lcr_io_range;\r\npci9111_reset(dev);\r\ndev->irq = 0;\r\nif (pci_device->irq > 0) {\r\nif (request_irq(pci_device->irq, pci9111_interrupt,\r\nIRQF_SHARED, PCI9111_DRIVER_NAME, dev) != 0) {\r\nprintk(KERN_ERR\r\n"comedi%d: unable to allocate irq %u\n",\r\ndev->minor, pci_device->irq);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev->irq = pci_device->irq;\r\nerror = alloc_subdevices(dev, 4);\r\nif (error < 0)\r\nreturn error;\r\nsubdevice = dev->subdevices + 0;\r\ndev->read_subdev = subdevice;\r\nsubdevice->type = COMEDI_SUBD_AI;\r\nsubdevice->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_CMD_READ;\r\nsubdevice->n_chan = board->ai_channel_nbr;\r\nsubdevice->maxdata = board->ai_resolution_mask;\r\nsubdevice->len_chanlist = board->ai_channel_nbr;\r\nsubdevice->range_table = board->ai_range_list;\r\nsubdevice->cancel = pci9111_ai_cancel;\r\nsubdevice->insn_read = pci9111_ai_insn_read;\r\nsubdevice->do_cmdtest = pci9111_ai_do_cmd_test;\r\nsubdevice->do_cmd = pci9111_ai_do_cmd;\r\nsubdevice->munge = pci9111_ai_munge;\r\nsubdevice = dev->subdevices + 1;\r\nsubdevice->type = COMEDI_SUBD_AO;\r\nsubdevice->subdev_flags = SDF_WRITABLE | SDF_COMMON;\r\nsubdevice->n_chan = board->ao_channel_nbr;\r\nsubdevice->maxdata = board->ao_resolution_mask;\r\nsubdevice->len_chanlist = board->ao_channel_nbr;\r\nsubdevice->range_table = board->ao_range_list;\r\nsubdevice->insn_write = pci9111_ao_insn_write;\r\nsubdevice->insn_read = pci9111_ao_insn_read;\r\nsubdevice = dev->subdevices + 2;\r\nsubdevice->type = COMEDI_SUBD_DI;\r\nsubdevice->subdev_flags = SDF_READABLE;\r\nsubdevice->n_chan = PCI9111_DI_CHANNEL_NBR;\r\nsubdevice->maxdata = 1;\r\nsubdevice->range_table = &range_digital;\r\nsubdevice->insn_bits = pci9111_di_insn_bits;\r\nsubdevice = dev->subdevices + 3;\r\nsubdevice->type = COMEDI_SUBD_DO;\r\nsubdevice->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\nsubdevice->n_chan = PCI9111_DO_CHANNEL_NBR;\r\nsubdevice->maxdata = 1;\r\nsubdevice->range_table = &range_digital;\r\nsubdevice->insn_bits = pci9111_do_insn_bits;\r\ndev_private->is_valid = 1;\r\nreturn 0;\r\n}\r\nstatic int pci9111_detach(struct comedi_device *dev)\r\n{\r\nif (dev->private != NULL) {\r\nif (dev_private->is_valid)\r\npci9111_reset(dev);\r\n}\r\nif (dev->irq != 0)\r\nfree_irq(dev->irq, dev);\r\nif (dev_private != NULL && dev_private->pci_device != NULL) {\r\nif (dev->iobase)\r\ncomedi_pci_disable(dev_private->pci_device);\r\npci_dev_put(dev_private->pci_device);\r\n}\r\nreturn 0;\r\n}
