static void sharpsl_nand_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nunsigned char bits = ctrl & 0x07;\r\nbits |= (ctrl & 0x01) << 4;\r\nbits ^= 0x11;\r\nwriteb((readb(sharpsl->io + FLASHCTL) & ~0x17) | bits, sharpsl->io + FLASHCTL);\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, chip->IO_ADDR_W);\r\n}\r\nstatic int sharpsl_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(mtd);\r\nreturn !((readb(sharpsl->io + FLASHCTL) & FLRYBY) == 0);\r\n}\r\nstatic void sharpsl_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(mtd);\r\nwriteb(0, sharpsl->io + ECCCLRR);\r\n}\r\nstatic int sharpsl_nand_calculate_ecc(struct mtd_info *mtd, const u_char * dat, u_char * ecc_code)\r\n{\r\nstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(mtd);\r\necc_code[0] = ~readb(sharpsl->io + ECCLPUB);\r\necc_code[1] = ~readb(sharpsl->io + ECCLPLB);\r\necc_code[2] = (~readb(sharpsl->io + ECCCP) << 2) | 0x03;\r\nreturn readb(sharpsl->io + ECCCNTR) != 0;\r\n}\r\nstatic int __devinit sharpsl_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct nand_chip *this;\r\nstruct mtd_partition *sharpsl_partition_info;\r\nint nr_partitions;\r\nstruct resource *r;\r\nint err = 0;\r\nstruct sharpsl_nand *sharpsl;\r\nstruct sharpsl_nand_platform_data *data = pdev->dev.platform_data;\r\nif (!data) {\r\ndev_err(&pdev->dev, "no platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nsharpsl = kzalloc(sizeof(struct sharpsl_nand), GFP_KERNEL);\r\nif (!sharpsl) {\r\nprintk("Unable to allocate SharpSL NAND MTD device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no io memory resource defined!\n");\r\nerr = -ENODEV;\r\ngoto err_get_res;\r\n}\r\nsharpsl->io = ioremap(r->start, resource_size(r));\r\nif (!sharpsl->io) {\r\nprintk("ioremap to access Sharp SL NAND chip failed\n");\r\nerr = -EIO;\r\ngoto err_ioremap;\r\n}\r\nthis = (struct nand_chip *)(&sharpsl->chip);\r\nsharpsl->mtd.priv = this;\r\nsharpsl->mtd.owner = THIS_MODULE;\r\nplatform_set_drvdata(pdev, sharpsl);\r\nwriteb(readb(sharpsl->io + FLASHCTL) | FLWP, sharpsl->io + FLASHCTL);\r\nthis->IO_ADDR_R = sharpsl->io + FLASHIO;\r\nthis->IO_ADDR_W = sharpsl->io + FLASHIO;\r\nthis->cmd_ctrl = sharpsl_nand_hwcontrol;\r\nthis->dev_ready = sharpsl_nand_dev_ready;\r\nthis->chip_delay = 15;\r\nthis->ecc.mode = NAND_ECC_HW;\r\nthis->ecc.size = 256;\r\nthis->ecc.bytes = 3;\r\nthis->badblock_pattern = data->badblock_pattern;\r\nthis->ecc.layout = data->ecc_layout;\r\nthis->ecc.hwctl = sharpsl_nand_enable_hwecc;\r\nthis->ecc.calculate = sharpsl_nand_calculate_ecc;\r\nthis->ecc.correct = nand_correct_data;\r\nerr = nand_scan(&sharpsl->mtd, 1);\r\nif (err)\r\ngoto err_scan;\r\nsharpsl->mtd.name = "sharpsl-nand";\r\nnr_partitions = parse_mtd_partitions(&sharpsl->mtd, part_probes, &sharpsl_partition_info, 0);\r\nif (nr_partitions <= 0) {\r\nnr_partitions = data->nr_partitions;\r\nsharpsl_partition_info = data->partitions;\r\n}\r\nerr = mtd_device_register(&sharpsl->mtd, sharpsl_partition_info,\r\nnr_partitions);\r\nif (err)\r\ngoto err_add;\r\nreturn 0;\r\nerr_add:\r\nnand_release(&sharpsl->mtd);\r\nerr_scan:\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(sharpsl->io);\r\nerr_ioremap:\r\nerr_get_res:\r\nkfree(sharpsl);\r\nreturn err;\r\n}\r\nstatic int __devexit sharpsl_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct sharpsl_nand *sharpsl = platform_get_drvdata(pdev);\r\nnand_release(&sharpsl->mtd);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(sharpsl->io);\r\nkfree(sharpsl);\r\nreturn 0;\r\n}\r\nstatic int __init sharpsl_nand_init(void)\r\n{\r\nreturn platform_driver_register(&sharpsl_nand_driver);\r\n}\r\nstatic void __exit sharpsl_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&sharpsl_nand_driver);\r\n}
