static void bttv_bit_setscl(void *data, int state)\r\n{\r\nstruct bttv *btv = (struct bttv*)data;\r\nif (state)\r\nbtv->i2c_state |= 0x02;\r\nelse\r\nbtv->i2c_state &= ~0x02;\r\nbtwrite(btv->i2c_state, BT848_I2C);\r\nbtread(BT848_I2C);\r\n}\r\nstatic void bttv_bit_setsda(void *data, int state)\r\n{\r\nstruct bttv *btv = (struct bttv*)data;\r\nif (state)\r\nbtv->i2c_state |= 0x01;\r\nelse\r\nbtv->i2c_state &= ~0x01;\r\nbtwrite(btv->i2c_state, BT848_I2C);\r\nbtread(BT848_I2C);\r\n}\r\nstatic int bttv_bit_getscl(void *data)\r\n{\r\nstruct bttv *btv = (struct bttv*)data;\r\nint state;\r\nstate = btread(BT848_I2C) & 0x02 ? 1 : 0;\r\nreturn state;\r\n}\r\nstatic int bttv_bit_getsda(void *data)\r\n{\r\nstruct bttv *btv = (struct bttv*)data;\r\nint state;\r\nstate = btread(BT848_I2C) & 0x01;\r\nreturn state;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int\r\nbttv_i2c_wait_done(struct bttv *btv)\r\n{\r\nint rc = 0;\r\nif (wait_event_interruptible_timeout(btv->i2c_queue,\r\nbtv->i2c_done, msecs_to_jiffies(85)) == -ERESTARTSYS)\r\nrc = -EIO;\r\nif (btv->i2c_done & BT848_INT_RACK)\r\nrc = 1;\r\nbtv->i2c_done = 0;\r\nreturn rc;\r\n}\r\nstatic int\r\nbttv_i2c_sendbytes(struct bttv *btv, const struct i2c_msg *msg, int last)\r\n{\r\nu32 xmit;\r\nint retval,cnt;\r\nif (0 == msg->len)\r\nreturn -EINVAL;\r\nxmit = (msg->addr << 25) | (msg->buf[0] << 16) | I2C_HW;\r\nif (msg->len > 1 || !last)\r\nxmit |= BT878_I2C_NOSTOP;\r\nbtwrite(xmit, BT848_I2C);\r\nretval = bttv_i2c_wait_done(btv);\r\nif (retval < 0)\r\ngoto err;\r\nif (retval == 0)\r\ngoto eio;\r\nif (i2c_debug) {\r\nprintk(" <W %02x %02x", msg->addr << 1, msg->buf[0]);\r\nif (!(xmit & BT878_I2C_NOSTOP))\r\nprintk(" >\n");\r\n}\r\nfor (cnt = 1; cnt < msg->len; cnt++ ) {\r\nxmit = (msg->buf[cnt] << 24) | I2C_HW | BT878_I2C_NOSTART;\r\nif (cnt < msg->len-1 || !last)\r\nxmit |= BT878_I2C_NOSTOP;\r\nbtwrite(xmit, BT848_I2C);\r\nretval = bttv_i2c_wait_done(btv);\r\nif (retval < 0)\r\ngoto err;\r\nif (retval == 0)\r\ngoto eio;\r\nif (i2c_debug) {\r\nprintk(" %02x", msg->buf[cnt]);\r\nif (!(xmit & BT878_I2C_NOSTOP))\r\nprintk(" >\n");\r\n}\r\n}\r\nreturn msg->len;\r\neio:\r\nretval = -EIO;\r\nerr:\r\nif (i2c_debug)\r\nprintk(" ERR: %d\n",retval);\r\nreturn retval;\r\n}\r\nstatic int\r\nbttv_i2c_readbytes(struct bttv *btv, const struct i2c_msg *msg, int last)\r\n{\r\nu32 xmit;\r\nu32 cnt;\r\nint retval;\r\nfor(cnt = 0; cnt < msg->len; cnt++) {\r\nxmit = (msg->addr << 25) | (1 << 24) | I2C_HW;\r\nif (cnt < msg->len-1)\r\nxmit |= BT848_I2C_W3B;\r\nif (cnt < msg->len-1 || !last)\r\nxmit |= BT878_I2C_NOSTOP;\r\nif (cnt)\r\nxmit |= BT878_I2C_NOSTART;\r\nbtwrite(xmit, BT848_I2C);\r\nretval = bttv_i2c_wait_done(btv);\r\nif (retval < 0)\r\ngoto err;\r\nif (retval == 0)\r\ngoto eio;\r\nmsg->buf[cnt] = ((u32)btread(BT848_I2C) >> 8) & 0xff;\r\nif (i2c_debug) {\r\nif (!(xmit & BT878_I2C_NOSTART))\r\nprintk(" <R %02x", (msg->addr << 1) +1);\r\nprintk(" =%02x", msg->buf[cnt]);\r\nif (!(xmit & BT878_I2C_NOSTOP))\r\nprintk(" >\n");\r\n}\r\n}\r\nreturn msg->len;\r\neio:\r\nretval = -EIO;\r\nerr:\r\nif (i2c_debug)\r\nprintk(" ERR: %d\n",retval);\r\nreturn retval;\r\n}\r\nstatic int bttv_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct v4l2_device *v4l2_dev = i2c_get_adapdata(i2c_adap);\r\nstruct bttv *btv = to_bttv(v4l2_dev);\r\nint retval = 0;\r\nint i;\r\nif (i2c_debug)\r\nprintk("bt-i2c:");\r\nbtwrite(BT848_INT_I2CDONE|BT848_INT_RACK, BT848_INT_STAT);\r\nfor (i = 0 ; i < num; i++) {\r\nif (msgs[i].flags & I2C_M_RD) {\r\nretval = bttv_i2c_readbytes(btv, &msgs[i], i+1 == num);\r\nif (retval < 0)\r\ngoto err;\r\n} else {\r\nretval = bttv_i2c_sendbytes(btv, &msgs[i], i+1 == num);\r\nif (retval < 0)\r\ngoto err;\r\n}\r\n}\r\nreturn num;\r\nerr:\r\nreturn retval;\r\n}\r\nint bttv_I2CRead(struct bttv *btv, unsigned char addr, char *probe_for)\r\n{\r\nunsigned char buffer = 0;\r\nif (0 != btv->i2c_rc)\r\nreturn -1;\r\nif (bttv_verbose && NULL != probe_for)\r\nprintk(KERN_INFO "bttv%d: i2c: checking for %s @ 0x%02x... ",\r\nbtv->c.nr,probe_for,addr);\r\nbtv->i2c_client.addr = addr >> 1;\r\nif (1 != i2c_master_recv(&btv->i2c_client, &buffer, 1)) {\r\nif (NULL != probe_for) {\r\nif (bttv_verbose)\r\nprintk("not found\n");\r\n} else\r\nprintk(KERN_WARNING "bttv%d: i2c read 0x%x: error\n",\r\nbtv->c.nr,addr);\r\nreturn -1;\r\n}\r\nif (bttv_verbose && NULL != probe_for)\r\nprintk("found\n");\r\nreturn buffer;\r\n}\r\nint bttv_I2CWrite(struct bttv *btv, unsigned char addr, unsigned char b1,\r\nunsigned char b2, int both)\r\n{\r\nunsigned char buffer[2];\r\nint bytes = both ? 2 : 1;\r\nif (0 != btv->i2c_rc)\r\nreturn -1;\r\nbtv->i2c_client.addr = addr >> 1;\r\nbuffer[0] = b1;\r\nbuffer[1] = b2;\r\nif (bytes != i2c_master_send(&btv->i2c_client, buffer, bytes))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid __devinit bttv_readee(struct bttv *btv, unsigned char *eedata, int addr)\r\n{\r\nmemset(eedata, 0, 256);\r\nif (0 != btv->i2c_rc)\r\nreturn;\r\nbtv->i2c_client.addr = addr >> 1;\r\ntveeprom_read(&btv->i2c_client, eedata, 256);\r\n}\r\nstatic void do_i2c_scan(char *name, struct i2c_client *c)\r\n{\r\nunsigned char buf;\r\nint i,rc;\r\nfor (i = 0; i < ARRAY_SIZE(i2c_devs); i++) {\r\nc->addr = i;\r\nrc = i2c_master_recv(c,&buf,0);\r\nif (rc < 0)\r\ncontinue;\r\nprintk("%s: i2c scan: found device @ 0x%x [%s]\n",\r\nname, i << 1, i2c_devs[i] ? i2c_devs[i] : "???");\r\n}\r\n}\r\nint __devinit init_bttv_i2c(struct bttv *btv)\r\n{\r\nstrlcpy(btv->i2c_client.name, "bttv internal", I2C_NAME_SIZE);\r\nif (i2c_hw)\r\nbtv->use_i2c_hw = 1;\r\nif (btv->use_i2c_hw) {\r\nstrlcpy(btv->c.i2c_adap.name, "bt878",\r\nsizeof(btv->c.i2c_adap.name));\r\nbtv->c.i2c_adap.algo = &bttv_algo;\r\n} else {\r\nif (i2c_udelay<5)\r\ni2c_udelay=5;\r\nstrlcpy(btv->c.i2c_adap.name, "bttv",\r\nsizeof(btv->c.i2c_adap.name));\r\nmemcpy(&btv->i2c_algo, &bttv_i2c_algo_bit_template,\r\nsizeof(bttv_i2c_algo_bit_template));\r\nbtv->i2c_algo.udelay = i2c_udelay;\r\nbtv->i2c_algo.data = btv;\r\nbtv->c.i2c_adap.algo_data = &btv->i2c_algo;\r\n}\r\nbtv->c.i2c_adap.owner = THIS_MODULE;\r\nbtv->c.i2c_adap.dev.parent = &btv->c.pci->dev;\r\nsnprintf(btv->c.i2c_adap.name, sizeof(btv->c.i2c_adap.name),\r\n"bt%d #%d [%s]", btv->id, btv->c.nr,\r\nbtv->use_i2c_hw ? "hw" : "sw");\r\ni2c_set_adapdata(&btv->c.i2c_adap, &btv->c.v4l2_dev);\r\nbtv->i2c_client.adapter = &btv->c.i2c_adap;\r\nif (btv->use_i2c_hw) {\r\nbtv->i2c_rc = i2c_add_adapter(&btv->c.i2c_adap);\r\n} else {\r\nbttv_bit_setscl(btv,1);\r\nbttv_bit_setsda(btv,1);\r\nbtv->i2c_rc = i2c_bit_add_bus(&btv->c.i2c_adap);\r\n}\r\nif (0 == btv->i2c_rc && i2c_scan)\r\ndo_i2c_scan(btv->c.v4l2_dev.name, &btv->i2c_client);\r\nreturn btv->i2c_rc;\r\n}
