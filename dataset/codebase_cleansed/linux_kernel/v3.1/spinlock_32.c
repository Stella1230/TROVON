void arch_spin_lock(arch_spinlock_t *lock)\r\n{\r\nint my_ticket;\r\nint iterations = 0;\r\nint delta;\r\nwhile ((my_ticket = __insn_tns((void *)&lock->next_ticket)) & 1)\r\ndelay_backoff(iterations++);\r\nlock->next_ticket = my_ticket + TICKET_QUANTUM;\r\nwhile ((delta = my_ticket - lock->current_ticket) != 0)\r\nrelax((128 / CYCLES_PER_RELAX_LOOP) * delta);\r\n}\r\nint arch_spin_trylock(arch_spinlock_t *lock)\r\n{\r\nint my_ticket = __insn_tns((void *)&lock->next_ticket);\r\nif (my_ticket == lock->current_ticket) {\r\nlock->next_ticket = my_ticket + TICKET_QUANTUM;\r\nreturn 1;\r\n}\r\nif (!(my_ticket & 1)) {\r\nlock->next_ticket = my_ticket;\r\n}\r\nreturn 0;\r\n}\r\nvoid arch_spin_unlock_wait(arch_spinlock_t *lock)\r\n{\r\nu32 iterations = 0;\r\nwhile (arch_spin_is_locked(lock))\r\ndelay_backoff(iterations++);\r\n}\r\ninline int arch_read_trylock(arch_rwlock_t *rwlock)\r\n{\r\nu32 val;\r\n__insn_mtspr(SPR_INTERRUPT_CRITICAL_SECTION, 1);\r\nval = __insn_tns((int *)&rwlock->lock);\r\nif (likely((val << _RD_COUNT_WIDTH) == 0)) {\r\nval += 1 << RD_COUNT_SHIFT;\r\nrwlock->lock = val;\r\n__insn_mtspr(SPR_INTERRUPT_CRITICAL_SECTION, 0);\r\nBUG_ON(val == 0);\r\nreturn 1;\r\n}\r\nif ((val & 1) == 0)\r\nrwlock->lock = val;\r\n__insn_mtspr(SPR_INTERRUPT_CRITICAL_SECTION, 0);\r\nreturn 0;\r\n}\r\nvoid arch_read_lock(arch_rwlock_t *rwlock)\r\n{\r\nu32 iterations = 0;\r\nwhile (unlikely(!arch_read_trylock(rwlock)))\r\ndelay_backoff(iterations++);\r\n}\r\nvoid arch_read_unlock(arch_rwlock_t *rwlock)\r\n{\r\nu32 val, iterations = 0;\r\nmb();\r\nfor (;;) {\r\n__insn_mtspr(SPR_INTERRUPT_CRITICAL_SECTION, 1);\r\nval = __insn_tns((int *)&rwlock->lock);\r\nif (likely(val & 1) == 0) {\r\nrwlock->lock = val - (1 << _RD_COUNT_SHIFT);\r\n__insn_mtspr(SPR_INTERRUPT_CRITICAL_SECTION, 0);\r\nbreak;\r\n}\r\n__insn_mtspr(SPR_INTERRUPT_CRITICAL_SECTION, 0);\r\ndelay_backoff(iterations++);\r\n}\r\n}\r\nvoid arch_write_lock(arch_rwlock_t *rwlock)\r\n{\r\nu32 my_ticket_;\r\nu32 iterations = 0;\r\nu32 val = __insn_tns((int *)&rwlock->lock);\r\nif (likely(val == 0)) {\r\nrwlock->lock = 1 << _WR_NEXT_SHIFT;\r\nreturn;\r\n}\r\nfor (;;) {\r\nif (!(val & 1)) {\r\nif ((val >> RD_COUNT_SHIFT) == 0)\r\nbreak;\r\nrwlock->lock = val;\r\n}\r\ndelay_backoff(iterations++);\r\nval = __insn_tns((int *)&rwlock->lock);\r\n}\r\nrwlock->lock = __insn_addb(val, 1 << WR_NEXT_SHIFT);\r\nmy_ticket_ = val >> WR_NEXT_SHIFT;\r\nfor (;;) {\r\nu32 curr_ = val >> WR_CURR_SHIFT;\r\nu32 delta = ((my_ticket_ - curr_) & WR_MASK);\r\nif (likely(delta == 0))\r\nbreak;\r\nrelax((256 / CYCLES_PER_RELAX_LOOP) * delta);\r\nwhile ((val = rwlock->lock) & 1)\r\nrelax(4);\r\n}\r\n}\r\nint arch_write_trylock(arch_rwlock_t *rwlock)\r\n{\r\nu32 val = __insn_tns((int *)&rwlock->lock);\r\nif (unlikely(val != 0)) {\r\nif (!(val & 1))\r\nrwlock->lock = val;\r\nreturn 0;\r\n}\r\nrwlock->lock = 1 << _WR_NEXT_SHIFT;\r\nreturn 1;\r\n}\r\nvoid arch_write_unlock(arch_rwlock_t *rwlock)\r\n{\r\nu32 val, eq, mask;\r\nmb();\r\nval = __insn_tns((int *)&rwlock->lock);\r\nif (likely(val == (1 << _WR_NEXT_SHIFT))) {\r\nrwlock->lock = 0;\r\nreturn;\r\n}\r\nwhile (unlikely(val & 1)) {\r\nrelax(4);\r\nval = __insn_tns((int *)&rwlock->lock);\r\n}\r\nmask = 1 << WR_CURR_SHIFT;\r\nval = __insn_addb(val, mask);\r\neq = __insn_seqb(val, val << (WR_CURR_SHIFT - WR_NEXT_SHIFT));\r\nval = __insn_mz(eq & mask, val);\r\nrwlock->lock = val;\r\n}
