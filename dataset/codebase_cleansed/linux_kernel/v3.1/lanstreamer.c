static int __devinit streamer_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct streamer_private *streamer_priv;\r\nunsigned long pio_start, pio_end, pio_flags, pio_len;\r\nunsigned long mmio_start, mmio_end, mmio_flags, mmio_len;\r\nint rc = 0;\r\nstatic int card_no=-1;\r\nu16 pcr;\r\n#if STREAMER_DEBUG\r\nprintk("lanstreamer::streamer_init_one, entry pdev %p\n",pdev);\r\n#endif\r\ncard_no++;\r\ndev = alloc_trdev(sizeof(*streamer_priv));\r\nif (dev==NULL) {\r\nprintk(KERN_ERR "lanstreamer: out of memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nstreamer_priv = netdev_priv(dev);\r\n#if STREAMER_NETWORK_MONITOR\r\n#ifdef CONFIG_PROC_FS\r\nif (!dev_streamer)\r\ncreate_proc_read_entry("streamer_tr", 0, init_net.proc_net,\r\nstreamer_proc_info, NULL);\r\nstreamer_priv->next = dev_streamer;\r\ndev_streamer = streamer_priv;\r\n#endif\r\n#endif\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\nprintk(KERN_ERR "%s: No suitable PCI mapping available.\n",\r\ndev->name);\r\nrc = -ENODEV;\r\ngoto err_out;\r\n}\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\nprintk(KERN_ERR "lanstreamer: unable to enable pci device\n");\r\nrc=-EIO;\r\ngoto err_out;\r\n}\r\npci_set_master(pdev);\r\nrc = pci_set_mwi(pdev);\r\nif (rc) {\r\nprintk(KERN_ERR "lanstreamer: unable to enable MWI on pci device\n");\r\ngoto err_out_disable;\r\n}\r\npio_start = pci_resource_start(pdev, 0);\r\npio_end = pci_resource_end(pdev, 0);\r\npio_flags = pci_resource_flags(pdev, 0);\r\npio_len = pci_resource_len(pdev, 0);\r\nmmio_start = pci_resource_start(pdev, 1);\r\nmmio_end = pci_resource_end(pdev, 1);\r\nmmio_flags = pci_resource_flags(pdev, 1);\r\nmmio_len = pci_resource_len(pdev, 1);\r\n#if STREAMER_DEBUG\r\nprintk("lanstreamer: pio_start %x pio_end %x pio_len %x pio_flags %x\n",\r\npio_start, pio_end, pio_len, pio_flags);\r\nprintk("lanstreamer: mmio_start %x mmio_end %x mmio_len %x mmio_flags %x\n",\r\nmmio_start, mmio_end, mmio_flags, mmio_len);\r\n#endif\r\nif (!request_region(pio_start, pio_len, "lanstreamer")) {\r\nprintk(KERN_ERR "lanstreamer: unable to get pci io addr %lx\n",\r\npio_start);\r\nrc= -EBUSY;\r\ngoto err_out_mwi;\r\n}\r\nif (!request_mem_region(mmio_start, mmio_len, "lanstreamer")) {\r\nprintk(KERN_ERR "lanstreamer: unable to get pci mmio addr %lx\n",\r\nmmio_start);\r\nrc= -EBUSY;\r\ngoto err_out_free_pio;\r\n}\r\nstreamer_priv->streamer_mmio=ioremap(mmio_start, mmio_len);\r\nif (streamer_priv->streamer_mmio == NULL) {\r\nprintk(KERN_ERR "lanstreamer: unable to remap MMIO %lx\n",\r\nmmio_start);\r\nrc= -EIO;\r\ngoto err_out_free_mmio;\r\n}\r\ninit_waitqueue_head(&streamer_priv->srb_wait);\r\ninit_waitqueue_head(&streamer_priv->trb_wait);\r\ndev->netdev_ops = &streamer_netdev_ops;\r\ndev->irq = pdev->irq;\r\ndev->base_addr=pio_start;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nstreamer_priv->streamer_card_name = (char *)pdev->resource[0].name;\r\nstreamer_priv->pci_dev = pdev;\r\nif ((pkt_buf_sz[card_no] < 100) || (pkt_buf_sz[card_no] > 18000))\r\nstreamer_priv->pkt_buf_sz = PKT_BUF_SZ;\r\nelse\r\nstreamer_priv->pkt_buf_sz = pkt_buf_sz[card_no];\r\nstreamer_priv->streamer_ring_speed = ringspeed[card_no];\r\nstreamer_priv->streamer_message_level = message_level[card_no];\r\npci_set_drvdata(pdev, dev);\r\nspin_lock_init(&streamer_priv->streamer_lock);\r\npci_read_config_word (pdev, PCI_COMMAND, &pcr);\r\npcr |= PCI_COMMAND_SERR;\r\npci_write_config_word (pdev, PCI_COMMAND, pcr);\r\nprintk("%s\n", version);\r\nprintk("%s: %s. I/O at %hx, MMIO at %p, using irq %d\n",dev->name,\r\nstreamer_priv->streamer_card_name,\r\n(unsigned int) dev->base_addr,\r\nstreamer_priv->streamer_mmio,\r\ndev->irq);\r\nif (streamer_reset(dev))\r\ngoto err_out_unmap;\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_out_unmap;\r\nreturn 0;\r\nerr_out_unmap:\r\niounmap(streamer_priv->streamer_mmio);\r\nerr_out_free_mmio:\r\nrelease_mem_region(mmio_start, mmio_len);\r\nerr_out_free_pio:\r\nrelease_region(pio_start, pio_len);\r\nerr_out_mwi:\r\npci_clear_mwi(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out:\r\nfree_netdev(dev);\r\n#if STREAMER_DEBUG\r\nprintk("lanstreamer: Exit error %x\n",rc);\r\n#endif\r\nreturn rc;\r\n}\r\nstatic void __devexit streamer_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev=pci_get_drvdata(pdev);\r\nstruct streamer_private *streamer_priv;\r\n#if STREAMER_DEBUG\r\nprintk("lanstreamer::streamer_remove_one entry pdev %p\n",pdev);\r\n#endif\r\nif (dev == NULL) {\r\nprintk(KERN_ERR "lanstreamer::streamer_remove_one, ERROR dev is NULL\n");\r\nreturn;\r\n}\r\nstreamer_priv=netdev_priv(dev);\r\nif (streamer_priv == NULL) {\r\nprintk(KERN_ERR "lanstreamer::streamer_remove_one, ERROR dev->priv is NULL\n");\r\nreturn;\r\n}\r\n#if STREAMER_NETWORK_MONITOR\r\n#ifdef CONFIG_PROC_FS\r\n{\r\nstruct streamer_private **p, **next;\r\nfor (p = &dev_streamer; *p; p = next) {\r\nnext = &(*p)->next;\r\nif (*p == streamer_priv) {\r\n*p = *next;\r\nbreak;\r\n}\r\n}\r\nif (!dev_streamer)\r\nremove_proc_entry("streamer_tr", init_net.proc_net);\r\n}\r\n#endif\r\n#endif\r\nunregister_netdev(dev);\r\niounmap(streamer_priv->streamer_mmio);\r\nrelease_mem_region(pci_resource_start(pdev, 1), pci_resource_len(pdev,1));\r\nrelease_region(pci_resource_start(pdev, 0), pci_resource_len(pdev,0));\r\npci_clear_mwi(pdev);\r\npci_disable_device(pdev);\r\nfree_netdev(dev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int streamer_reset(struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv;\r\n__u8 __iomem *streamer_mmio;\r\nunsigned long t;\r\nunsigned int uaa_addr;\r\nstruct sk_buff *skb = NULL;\r\n__u16 misr;\r\nstreamer_priv = netdev_priv(dev);\r\nstreamer_mmio = streamer_priv->streamer_mmio;\r\nwritew(readw(streamer_mmio + BCTL) | BCTL_SOFTRESET, streamer_mmio + BCTL);\r\nt = jiffies;\r\nssleep(1);\r\nwritew(readw(streamer_mmio + BCTL) & ~BCTL_SOFTRESET,\r\nstreamer_mmio + BCTL);\r\n#if STREAMER_DEBUG\r\nprintk("BCTL: %x\n", readw(streamer_mmio + BCTL));\r\nprintk("GPR: %x\n", readw(streamer_mmio + GPR));\r\nprintk("SISRMASK: %x\n", readw(streamer_mmio + SISR_MASK));\r\n#endif\r\nwritew(readw(streamer_mmio + BCTL) | (BCTL_RX_FIFO_8 | BCTL_TX_FIFO_8), streamer_mmio + BCTL );\r\nif (streamer_priv->streamer_ring_speed == 0) {\r\nwritew(readw(streamer_mmio + GPR) | GPR_AUTOSENSE,\r\nstreamer_mmio + GPR);\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Ringspeed autosense mode on\n",\r\ndev->name);\r\n} else if (streamer_priv->streamer_ring_speed == 16) {\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Trying to open at 16 Mbps as requested\n",\r\ndev->name);\r\nwritew(GPR_16MBPS, streamer_mmio + GPR);\r\n} else if (streamer_priv->streamer_ring_speed == 4) {\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Trying to open at 4 Mbps as requested\n",\r\ndev->name);\r\nwritew(0, streamer_mmio + GPR);\r\n}\r\nskb = dev_alloc_skb(streamer_priv->pkt_buf_sz);\r\nif (!skb) {\r\nprintk(KERN_INFO "%s: skb allocation for diagnostics failed...proceeding\n",\r\ndev->name);\r\n} else {\r\nstruct streamer_rx_desc *rx_ring;\r\nu8 *data;\r\nrx_ring=(struct streamer_rx_desc *)skb->data;\r\ndata=((u8 *)skb->data)+sizeof(struct streamer_rx_desc);\r\nrx_ring->forward=0;\r\nrx_ring->status=0;\r\nrx_ring->buffer=cpu_to_le32(pci_map_single(streamer_priv->pci_dev, data,\r\n512, PCI_DMA_FROMDEVICE));\r\nrx_ring->framelen_buflen=512;\r\nwritel(cpu_to_le32(pci_map_single(streamer_priv->pci_dev, rx_ring, 512, PCI_DMA_FROMDEVICE)),\r\nstreamer_mmio+RXBDA);\r\n}\r\n#if STREAMER_DEBUG\r\nprintk("GPR = %x\n", readw(streamer_mmio + GPR));\r\n#endif\r\nwritew(SISR_MI, streamer_mmio + SISR_MASK_SUM);\r\nwhile (!((readw(streamer_mmio + SISR)) & SISR_SRB_REPLY)) {\r\nmsleep_interruptible(100);\r\nif (time_after(jiffies, t + 40 * HZ)) {\r\nprintk(KERN_ERR\r\n"IBM PCI tokenring card not responding\n");\r\nrelease_region(dev->base_addr, STREAMER_IO_SPACE);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn -1;\r\n}\r\n}\r\nwritew(~SISR_SRB_REPLY, streamer_mmio + SISR_RUM);\r\nmisr = readw(streamer_mmio + MISR_RUM);\r\nwritew(~misr, streamer_mmio + MISR_RUM);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\n#if STREAMER_DEBUG\r\nprintk("LAPWWO: %x, LAPA: %x LAPE: %x\n",\r\nreadw(streamer_mmio + LAPWWO), readw(streamer_mmio + LAPA),\r\nreadw(streamer_mmio + LAPE));\r\n#endif\r\n#if STREAMER_DEBUG\r\n{\r\nint i;\r\nwritew(readw(streamer_mmio + LAPWWO),\r\nstreamer_mmio + LAPA);\r\nprintk("initialization response srb dump: ");\r\nfor (i = 0; i < 10; i++)\r\nprintk("%x:",\r\nntohs(readw(streamer_mmio + LAPDINC)));\r\nprintk("\n");\r\n}\r\n#endif\r\nwritew(readw(streamer_mmio + LAPWWO) + 6, streamer_mmio + LAPA);\r\nif (readw(streamer_mmio + LAPD)) {\r\nprintk(KERN_INFO "tokenring card initialization failed. errorcode : %x\n",\r\nntohs(readw(streamer_mmio + LAPD)));\r\nrelease_region(dev->base_addr, STREAMER_IO_SPACE);\r\nreturn -1;\r\n}\r\nwritew(readw(streamer_mmio + LAPWWO) + 8, streamer_mmio + LAPA);\r\nuaa_addr = ntohs(readw(streamer_mmio + LAPDINC));\r\nreadw(streamer_mmio + LAPDINC);\r\nstreamer_priv->streamer_addr_table_addr = ntohs(readw(streamer_mmio + LAPDINC));\r\nstreamer_priv->streamer_parms_addr = ntohs(readw(streamer_mmio + LAPDINC));\r\n#if STREAMER_DEBUG\r\nprintk("UAA resides at %x\n", uaa_addr);\r\n#endif\r\n{\r\nint i;\r\n__u16 addr;\r\nwritew(uaa_addr, streamer_mmio + LAPA);\r\nfor (i = 0; i < 6; i += 2) {\r\naddr=ntohs(readw(streamer_mmio+LAPDINC));\r\ndev->dev_addr[i]= (addr >> 8) & 0xff;\r\ndev->dev_addr[i+1]= addr & 0xff;\r\n}\r\n#if STREAMER_DEBUG\r\nprintk("Adapter address: %pM\n", dev->dev_addr);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int streamer_open(struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv = netdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\nunsigned long flags;\r\nchar open_error[255];\r\nint i, open_finished = 1;\r\n__u16 srb_word;\r\n__u16 srb_open;\r\nint rc;\r\nif (readw(streamer_mmio+BMCTL_SUM) & BMCTL_RX_ENABLED) {\r\nrc=streamer_reset(dev);\r\n}\r\nif (request_irq(dev->irq, streamer_interrupt, IRQF_SHARED, "lanstreamer", dev)) {\r\nreturn -EAGAIN;\r\n}\r\n#if STREAMER_DEBUG\r\nprintk("BMCTL: %x\n", readw(streamer_mmio + BMCTL_SUM));\r\nprintk("pending ints: %x\n", readw(streamer_mmio + SISR));\r\n#endif\r\nwritew(SISR_MI | SISR_SRB_REPLY, streamer_mmio + SISR_MASK);\r\nwritew(LISR_LIE, streamer_mmio + LISR);\r\nwritew(readw(streamer_mmio + LAPWWO), streamer_mmio + LAPA);\r\n#if STREAMER_DEBUG\r\nprintk("LAPWWO: %x, LAPA: %x\n", readw(streamer_mmio + LAPWWO),\r\nreadw(streamer_mmio + LAPA));\r\nprintk("LAPE: %x\n", readw(streamer_mmio + LAPE));\r\nprintk("SISR Mask = %04x\n", readw(streamer_mmio + SISR_MASK));\r\n#endif\r\ndo {\r\nfor (i = 0; i < SRB_COMMAND_SIZE; i += 2) {\r\nwritew(0, streamer_mmio + LAPDINC);\r\n}\r\nwritew(readw(streamer_mmio+LAPWWO),streamer_mmio+LAPA);\r\nwritew(htons(SRB_OPEN_ADAPTER<<8),streamer_mmio+LAPDINC) ;\r\nwritew(htons(STREAMER_CLEAR_RET_CODE<<8),streamer_mmio+LAPDINC);\r\nwritew(STREAMER_CLEAR_RET_CODE, streamer_mmio + LAPDINC);\r\nwritew(readw(streamer_mmio + LAPWWO) + 8, streamer_mmio + LAPA);\r\n#if STREAMER_NETWORK_MONITOR\r\nwritew(htons(OPEN_ADAPTER_ENABLE_FDX | OPEN_ADAPTER_PASS_ADC_MAC | OPEN_ADAPTER_PASS_ATT_MAC | OPEN_ADAPTER_PASS_BEACON), streamer_mmio + LAPDINC);\r\n#else\r\nwritew(htons(OPEN_ADAPTER_ENABLE_FDX), streamer_mmio + LAPDINC);\r\n#endif\r\nif (streamer_priv->streamer_laa[0]) {\r\nwritew(readw(streamer_mmio + LAPWWO) + 12, streamer_mmio + LAPA);\r\nwritew(htons((streamer_priv->streamer_laa[0] << 8) |\r\nstreamer_priv->streamer_laa[1]),streamer_mmio+LAPDINC);\r\nwritew(htons((streamer_priv->streamer_laa[2] << 8) |\r\nstreamer_priv->streamer_laa[3]),streamer_mmio+LAPDINC);\r\nwritew(htons((streamer_priv->streamer_laa[4] << 8) |\r\nstreamer_priv->streamer_laa[5]),streamer_mmio+LAPDINC);\r\nmemcpy(dev->dev_addr, streamer_priv->streamer_laa, dev->addr_len);\r\n}\r\nsrb_open = readw(streamer_mmio + LAPWWO);\r\n#if STREAMER_DEBUG\r\nwritew(readw(streamer_mmio + LAPWWO),\r\nstreamer_mmio + LAPA);\r\nprintk("srb open request:\n");\r\nfor (i = 0; i < 16; i++) {\r\nprintk("%x:", ntohs(readw(streamer_mmio + LAPDINC)));\r\n}\r\nprintk("\n");\r\n#endif\r\nspin_lock_irqsave(&streamer_priv->streamer_lock, flags);\r\nstreamer_priv->srb_queued = 1;\r\nwritew(LISR_SRB_CMD, streamer_mmio + LISR_SUM);\r\nspin_unlock_irqrestore(&streamer_priv->streamer_lock, flags);\r\nwhile (streamer_priv->srb_queued) {\r\ninterruptible_sleep_on_timeout(&streamer_priv->srb_wait, 5 * HZ);\r\nif (signal_pending(current)) {\r\nprintk(KERN_WARNING "%s: SRB timed out.\n", dev->name);\r\nprintk(KERN_WARNING "SISR=%x MISR=%x, LISR=%x\n",\r\nreadw(streamer_mmio + SISR),\r\nreadw(streamer_mmio + MISR_RUM),\r\nreadw(streamer_mmio + LISR));\r\nstreamer_priv->srb_queued = 0;\r\nbreak;\r\n}\r\n}\r\n#if STREAMER_DEBUG\r\nprintk("SISR_MASK: %x\n", readw(streamer_mmio + SISR_MASK));\r\nprintk("srb open response:\n");\r\nwritew(srb_open, streamer_mmio + LAPA);\r\nfor (i = 0; i < 10; i++) {\r\nprintk("%x:",\r\nntohs(readw(streamer_mmio + LAPDINC)));\r\n}\r\n#endif\r\nwritew(srb_open + 2, streamer_mmio + LAPA);\r\nsrb_word = ntohs(readw(streamer_mmio + LAPD)) >> 8;\r\nif (srb_word == STREAMER_CLEAR_RET_CODE) {\r\nprintk(KERN_WARNING "%s: Adapter Open time out or error.\n",\r\ndev->name);\r\nreturn -EIO;\r\n}\r\nif (srb_word != 0) {\r\nif (srb_word == 0x07) {\r\nif (!streamer_priv->streamer_ring_speed && open_finished) {\r\nprintk(KERN_WARNING "%s: Retrying at different ring speed\n",\r\ndev->name);\r\nopen_finished = 0;\r\n} else {\r\n__u16 error_code;\r\nwritew(srb_open + 6, streamer_mmio + LAPA);\r\nerror_code = ntohs(readw(streamer_mmio + LAPD));\r\nstrcpy(open_error, open_maj_error[(error_code & 0xf0) >> 4]);\r\nstrcat(open_error, " - ");\r\nstrcat(open_error, open_min_error[(error_code & 0x0f)]);\r\nif (!streamer_priv->streamer_ring_speed &&\r\n((error_code & 0x0f) == 0x0d))\r\n{\r\nprintk(KERN_WARNING "%s: Tried to autosense ring speed with no monitors present\n", dev->name);\r\nprintk(KERN_WARNING "%s: Please try again with a specified ring speed\n", dev->name);\r\nfree_irq(dev->irq, dev);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_WARNING "%s: %s\n",\r\ndev->name, open_error);\r\nfree_irq(dev->irq, dev);\r\nreturn -EIO;\r\n}\r\n} else {\r\nprintk(KERN_WARNING "%s: Bad OPEN response: %x\n",\r\ndev->name, srb_word);\r\nfree_irq(dev->irq, dev);\r\nreturn -EIO;\r\n}\r\n} else\r\nopen_finished = 1;\r\n} while (!(open_finished));\r\nwritew(srb_open + 18, streamer_mmio + LAPA);\r\nsrb_word=ntohs(readw(streamer_mmio+LAPD)) >> 8;\r\nif (srb_word & (1 << 3))\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Opened in FDX Mode\n", dev->name);\r\nif (srb_word & 1)\r\nstreamer_priv->streamer_ring_speed = 16;\r\nelse\r\nstreamer_priv->streamer_ring_speed = 4;\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Opened in %d Mbps mode\n",\r\ndev->name,\r\nstreamer_priv->streamer_ring_speed);\r\nwritew(srb_open + 8, streamer_mmio + LAPA);\r\nstreamer_priv->asb = ntohs(readw(streamer_mmio + LAPDINC));\r\nstreamer_priv->srb = ntohs(readw(streamer_mmio + LAPDINC));\r\nstreamer_priv->arb = ntohs(readw(streamer_mmio + LAPDINC));\r\nreadw(streamer_mmio + LAPDINC);\r\nstreamer_priv->trb = ntohs(readw(streamer_mmio + LAPDINC));\r\nstreamer_priv->streamer_receive_options = 0x00;\r\nstreamer_priv->streamer_copy_all_options = 0;\r\nwritew(~BMCTL_RX_DIS, streamer_mmio + BMCTL_RUM);\r\nstreamer_priv->streamer_rx_ring=\r\nkmalloc( sizeof(struct streamer_rx_desc)*\r\nSTREAMER_RX_RING_SIZE,GFP_KERNEL);\r\nif (!streamer_priv->streamer_rx_ring) {\r\nprintk(KERN_WARNING "%s ALLOC of streamer rx ring FAILED!!\n",dev->name);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < STREAMER_RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(streamer_priv->pkt_buf_sz);\r\nif (skb == NULL)\r\nbreak;\r\nskb->dev = dev;\r\nstreamer_priv->streamer_rx_ring[i].forward =\r\ncpu_to_le32(pci_map_single(streamer_priv->pci_dev, &streamer_priv->streamer_rx_ring[i + 1],\r\nsizeof(struct streamer_rx_desc), PCI_DMA_FROMDEVICE));\r\nstreamer_priv->streamer_rx_ring[i].status = 0;\r\nstreamer_priv->streamer_rx_ring[i].buffer =\r\ncpu_to_le32(pci_map_single(streamer_priv->pci_dev, skb->data,\r\nstreamer_priv->pkt_buf_sz, PCI_DMA_FROMDEVICE));\r\nstreamer_priv->streamer_rx_ring[i].framelen_buflen = streamer_priv->pkt_buf_sz;\r\nstreamer_priv->rx_ring_skb[i] = skb;\r\n}\r\nstreamer_priv->streamer_rx_ring[STREAMER_RX_RING_SIZE - 1].forward =\r\ncpu_to_le32(pci_map_single(streamer_priv->pci_dev, &streamer_priv->streamer_rx_ring[0],\r\nsizeof(struct streamer_rx_desc), PCI_DMA_FROMDEVICE));\r\nif (i == 0) {\r\nprintk(KERN_WARNING "%s: Not enough memory to allocate rx buffers. Adapter disabled\n", dev->name);\r\nfree_irq(dev->irq, dev);\r\nreturn -EIO;\r\n}\r\nstreamer_priv->rx_ring_last_received = STREAMER_RX_RING_SIZE - 1;\r\nwritel(cpu_to_le32(pci_map_single(streamer_priv->pci_dev, &streamer_priv->streamer_rx_ring[0],\r\nsizeof(struct streamer_rx_desc), PCI_DMA_TODEVICE)),\r\nstreamer_mmio + RXBDA);\r\nwritel(cpu_to_le32(pci_map_single(streamer_priv->pci_dev, &streamer_priv->streamer_rx_ring[STREAMER_RX_RING_SIZE - 1],\r\nsizeof(struct streamer_rx_desc), PCI_DMA_TODEVICE)),\r\nstreamer_mmio + RXLBDA);\r\nwritew(MISR_RX_NOBUF | MISR_RX_EOF, streamer_mmio + MISR_MASK);\r\nstreamer_priv->streamer_tx_ring=kmalloc(sizeof(struct streamer_tx_desc)*\r\nSTREAMER_TX_RING_SIZE,GFP_KERNEL);\r\nif (!streamer_priv->streamer_tx_ring) {\r\nprintk(KERN_WARNING "%s ALLOC of streamer_tx_ring FAILED\n",dev->name);\r\nreturn -EIO;\r\n}\r\nwritew(~BMCTL_TX2_DIS, streamer_mmio + BMCTL_RUM);\r\nfor (i = 0; i < STREAMER_TX_RING_SIZE; i++) {\r\nstreamer_priv->streamer_tx_ring[i].forward = cpu_to_le32(pci_map_single(streamer_priv->pci_dev,\r\n&streamer_priv->streamer_tx_ring[i + 1],\r\nsizeof(struct streamer_tx_desc),\r\nPCI_DMA_TODEVICE));\r\nstreamer_priv->streamer_tx_ring[i].status = 0;\r\nstreamer_priv->streamer_tx_ring[i].bufcnt_framelen = 0;\r\nstreamer_priv->streamer_tx_ring[i].buffer = 0;\r\nstreamer_priv->streamer_tx_ring[i].buflen = 0;\r\nstreamer_priv->streamer_tx_ring[i].rsvd1 = 0;\r\nstreamer_priv->streamer_tx_ring[i].rsvd2 = 0;\r\nstreamer_priv->streamer_tx_ring[i].rsvd3 = 0;\r\n}\r\nstreamer_priv->streamer_tx_ring[STREAMER_TX_RING_SIZE - 1].forward =\r\ncpu_to_le32(pci_map_single(streamer_priv->pci_dev, &streamer_priv->streamer_tx_ring[0],\r\nsizeof(struct streamer_tx_desc), PCI_DMA_TODEVICE));\r\nstreamer_priv->free_tx_ring_entries = STREAMER_TX_RING_SIZE;\r\nstreamer_priv->tx_ring_free = 0;\r\nstreamer_priv->tx_ring_last_status = STREAMER_TX_RING_SIZE - 1;\r\nwritew(MISR_TX2_EOF | MISR_RX_NOBUF | MISR_RX_EOF, streamer_mmio + MISR_MASK);\r\nwritew(SISR_ADAPTER_CHECK | SISR_ARB_CMD | SISR_TRB_REPLY | SISR_ASB_FREE, streamer_mmio + SISR_MASK_SUM);\r\n#if STREAMER_DEBUG\r\nprintk("BMCTL: %x\n", readw(streamer_mmio + BMCTL_SUM));\r\nprintk("SISR MASK: %x\n", readw(streamer_mmio + SISR_MASK));\r\n#endif\r\n#if STREAMER_NETWORK_MONITOR\r\nwritew(streamer_priv->streamer_addr_table_addr, streamer_mmio + LAPA);\r\nprintk("%s: Node Address: %04x:%04x:%04x\n", dev->name,\r\nntohs(readw(streamer_mmio + LAPDINC)),\r\nntohs(readw(streamer_mmio + LAPDINC)),\r\nntohs(readw(streamer_mmio + LAPDINC)));\r\nreadw(streamer_mmio + LAPDINC);\r\nreadw(streamer_mmio + LAPDINC);\r\nprintk("%s: Functional Address: %04x:%04x\n", dev->name,\r\nntohs(readw(streamer_mmio + LAPDINC)),\r\nntohs(readw(streamer_mmio + LAPDINC)));\r\nwritew(streamer_priv->streamer_parms_addr + 4,\r\nstreamer_mmio + LAPA);\r\nprintk("%s: NAUN Address: %04x:%04x:%04x\n", dev->name,\r\nntohs(readw(streamer_mmio + LAPDINC)),\r\nntohs(readw(streamer_mmio + LAPDINC)),\r\nntohs(readw(streamer_mmio + LAPDINC)));\r\n#endif\r\nnetif_start_queue(dev);\r\nnetif_carrier_on(dev);\r\nreturn 0;\r\n}\r\nstatic void streamer_rx(struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\nstruct streamer_rx_desc *rx_desc;\r\nint rx_ring_last_received, length, frame_length, buffer_cnt = 0;\r\nstruct sk_buff *skb, *skb2;\r\nrx_desc = &streamer_priv->streamer_rx_ring[(streamer_priv->rx_ring_last_received + 1) & (STREAMER_RX_RING_SIZE - 1)];\r\nrx_ring_last_received = streamer_priv->rx_ring_last_received;\r\nwhile (rx_desc->status & 0x01000000) {\r\nif (rx_ring_last_received != streamer_priv->rx_ring_last_received)\r\n{\r\nprintk(KERN_WARNING "RX Error 1 rx_ring_last_received not the same %x %x\n",\r\nrx_ring_last_received, streamer_priv->rx_ring_last_received);\r\n}\r\nstreamer_priv->rx_ring_last_received = (streamer_priv->rx_ring_last_received + 1) & (STREAMER_RX_RING_SIZE - 1);\r\nrx_ring_last_received = streamer_priv->rx_ring_last_received;\r\nlength = rx_desc->framelen_buflen & 0xffff;\r\nframe_length = (rx_desc->framelen_buflen >> 16) & 0xffff;\r\nif (rx_desc->status & 0x7E830000) {\r\nif (streamer_priv->streamer_message_level) {\r\nprintk(KERN_WARNING "%s: Rx Error %x\n",\r\ndev->name, rx_desc->status);\r\n}\r\n} else {\r\nif (rx_desc->status & 0x80000000) {\r\nbuffer_cnt = 1;\r\nskb = dev_alloc_skb(streamer_priv->pkt_buf_sz);\r\n} else {\r\nskb = dev_alloc_skb(frame_length);\r\n}\r\nif (skb == NULL)\r\n{\r\nprintk(KERN_WARNING "%s: Not enough memory to copy packet to upper layers.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\n} else {\r\nif (buffer_cnt == 1) {\r\npci_unmap_single(streamer_priv->pci_dev,\r\nle32_to_cpu(streamer_priv->streamer_rx_ring[rx_ring_last_received].buffer),\r\nstreamer_priv->pkt_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nskb2 = streamer_priv->rx_ring_skb[rx_ring_last_received];\r\n#if STREAMER_DEBUG_PACKETS\r\n{\r\nint i;\r\nprintk("streamer_rx packet print: skb->data2 %p skb->head %p\n", skb2->data, skb2->head);\r\nfor (i = 0; i < frame_length; i++)\r\n{\r\nprintk("%x:", skb2->data[i]);\r\nif (((i + 1) % 16) == 0)\r\nprintk("\n");\r\n}\r\nprintk("\n");\r\n}\r\n#endif\r\nskb_put(skb2, length);\r\nskb2->protocol = tr_type_trans(skb2, dev);\r\nstreamer_priv->streamer_rx_ring[rx_ring_last_received].status = 0;\r\nstreamer_priv->streamer_rx_ring[rx_ring_last_received].framelen_buflen = streamer_priv->pkt_buf_sz;\r\nstreamer_priv->streamer_rx_ring[rx_ring_last_received].buffer =\r\ncpu_to_le32(pci_map_single(streamer_priv->pci_dev, skb->data, streamer_priv->pkt_buf_sz,\r\nPCI_DMA_FROMDEVICE));\r\nstreamer_priv->rx_ring_skb[rx_ring_last_received] = skb;\r\nwritel(cpu_to_le32(pci_map_single(streamer_priv->pci_dev,\r\n&streamer_priv->streamer_rx_ring[rx_ring_last_received],\r\nsizeof(struct streamer_rx_desc), PCI_DMA_FROMDEVICE)),\r\nstreamer_mmio + RXLBDA);\r\nnetif_rx(skb2);\r\n} else {\r\ndo {\r\npci_unmap_single(streamer_priv->pci_dev, le32_to_cpu(rx_desc->buffer), length, PCI_DMA_FROMDEVICE),\r\nmemcpy(skb_put(skb, length), (void *)rx_desc->buffer, length);\r\nstreamer_priv->streamer_rx_ring[rx_ring_last_received].status = 0;\r\nstreamer_priv->streamer_rx_ring[rx_ring_last_received].framelen_buflen = streamer_priv->pkt_buf_sz;\r\nwritel(cpu_to_le32(pci_map_single(streamer_priv->pci_dev,\r\n&streamer_priv->streamer_rx_ring[rx_ring_last_received],\r\nlength, PCI_DMA_FROMDEVICE)),\r\nstreamer_mmio + RXLBDA);\r\nif (rx_desc->status & 0x80000000)\r\nbreak;\r\nif (rx_ring_last_received!= streamer_priv->rx_ring_last_received)\r\n{\r\nprintk("RX Error rx_ring_last_received not the same %x %x\n",\r\nrx_ring_last_received,\r\nstreamer_priv->rx_ring_last_received);\r\n}\r\nrx_desc = &streamer_priv->streamer_rx_ring[(streamer_priv->rx_ring_last_received+1) & (STREAMER_RX_RING_SIZE-1)];\r\nlength = rx_desc->framelen_buflen & 0xffff;\r\nstreamer_priv->rx_ring_last_received = (streamer_priv->rx_ring_last_received+1) & (STREAMER_RX_RING_SIZE - 1);\r\nrx_ring_last_received = streamer_priv->rx_ring_last_received;\r\n} while (1);\r\nskb->protocol = tr_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += length;\r\n}\r\n}\r\nrx_desc = &streamer_priv->streamer_rx_ring[(rx_ring_last_received + 1) & (STREAMER_RX_RING_SIZE - 1)];\r\n}\r\n}\r\nstatic irqreturn_t streamer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\n__u16 sisr;\r\n__u16 misr;\r\nu8 max_intr = MAX_INTR;\r\nspin_lock(&streamer_priv->streamer_lock);\r\nsisr = readw(streamer_mmio + SISR);\r\nwhile((sisr & (SISR_MI | SISR_SRB_REPLY | SISR_ADAPTER_CHECK | SISR_ASB_FREE |\r\nSISR_ARB_CMD | SISR_TRB_REPLY | SISR_PAR_ERR | SISR_SERR_ERR)) &&\r\n(max_intr > 0)) {\r\nif(sisr & SISR_PAR_ERR) {\r\nwritew(~SISR_PAR_ERR, streamer_mmio + SISR_RUM);\r\n(void)readw(streamer_mmio + SISR_RUM);\r\n}\r\nelse if(sisr & SISR_SERR_ERR) {\r\nwritew(~SISR_SERR_ERR, streamer_mmio + SISR_RUM);\r\n(void)readw(streamer_mmio + SISR_RUM);\r\n}\r\nelse if(sisr & SISR_MI) {\r\nmisr = readw(streamer_mmio + MISR_RUM);\r\nif (misr & MISR_TX2_EOF) {\r\nwhile(streamer_priv->streamer_tx_ring[(streamer_priv->tx_ring_last_status + 1) & (STREAMER_TX_RING_SIZE - 1)].status) {\r\nstreamer_priv->tx_ring_last_status = (streamer_priv->tx_ring_last_status + 1) & (STREAMER_TX_RING_SIZE - 1);\r\nstreamer_priv->free_tx_ring_entries++;\r\ndev->stats.tx_bytes += streamer_priv->tx_ring_skb[streamer_priv->tx_ring_last_status]->len;\r\ndev->stats.tx_packets++;\r\ndev_kfree_skb_irq(streamer_priv->tx_ring_skb[streamer_priv->tx_ring_last_status]);\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].buffer = 0xdeadbeef;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].status = 0;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].bufcnt_framelen = 0;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].buflen = 0;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd1 = 0;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd2 = 0;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd3 = 0;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nif (misr & MISR_RX_EOF) {\r\nstreamer_rx(dev);\r\n}\r\nif (misr & MISR_RX_NOBUF) {\r\n}\r\nwritew(~misr, streamer_mmio + MISR_RUM);\r\n(void)readw(streamer_mmio + MISR_RUM);\r\n}\r\nelse if (sisr & SISR_SRB_REPLY) {\r\nif (streamer_priv->srb_queued == 1) {\r\nwake_up_interruptible(&streamer_priv->srb_wait);\r\n} else if (streamer_priv->srb_queued == 2) {\r\nstreamer_srb_bh(dev);\r\n}\r\nstreamer_priv->srb_queued = 0;\r\nwritew(~SISR_SRB_REPLY, streamer_mmio + SISR_RUM);\r\n(void)readw(streamer_mmio + SISR_RUM);\r\n}\r\nelse if (sisr & SISR_ADAPTER_CHECK) {\r\nprintk(KERN_WARNING "%s: Adapter Check Interrupt Raised, 8 bytes of information follow:\n", dev->name);\r\nwritel(readl(streamer_mmio + LAPWWO), streamer_mmio + LAPA);\r\nprintk(KERN_WARNING "%s: Words %x:%x:%x:%x:\n",\r\ndev->name, readw(streamer_mmio + LAPDINC),\r\nntohs(readw(streamer_mmio + LAPDINC)),\r\nntohs(readw(streamer_mmio + LAPDINC)),\r\nntohs(readw(streamer_mmio + LAPDINC)));\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nprintk(KERN_WARNING "%s: Adapter must be manually reset.\n", dev->name);\r\n}\r\nelse if (sisr & SISR_ASB_FREE) {\r\nif (streamer_priv->asb_queued) {\r\nstreamer_asb_bh(dev);\r\n}\r\nwritew(~SISR_ASB_FREE, streamer_mmio + SISR_RUM);\r\n(void)readw(streamer_mmio + SISR_RUM);\r\n}\r\nelse if (sisr & SISR_ARB_CMD) {\r\nstreamer_arb_cmd(dev);\r\nwritew(~SISR_ARB_CMD, streamer_mmio + SISR_RUM);\r\n(void)readw(streamer_mmio + SISR_RUM);\r\n}\r\nelse if (sisr & SISR_TRB_REPLY) {\r\nif (streamer_priv->trb_queued) {\r\nwake_up_interruptible(&streamer_priv->\r\ntrb_wait);\r\n}\r\nstreamer_priv->trb_queued = 0;\r\nwritew(~SISR_TRB_REPLY, streamer_mmio + SISR_RUM);\r\n(void)readw(streamer_mmio + SISR_RUM);\r\n}\r\nsisr = readw(streamer_mmio + SISR);\r\nmax_intr--;\r\n}\r\nspin_unlock(&streamer_priv->streamer_lock) ;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic netdev_tx_t streamer_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\nunsigned long flags ;\r\nspin_lock_irqsave(&streamer_priv->streamer_lock, flags);\r\nif (streamer_priv->free_tx_ring_entries) {\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_free].status = 0;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_free].bufcnt_framelen = 0x00020000 | skb->len;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_free].buffer =\r\ncpu_to_le32(pci_map_single(streamer_priv->pci_dev, skb->data, skb->len, PCI_DMA_TODEVICE));\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_free].rsvd1 = skb->len;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_free].rsvd2 = 0;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_free].rsvd3 = 0;\r\nstreamer_priv->streamer_tx_ring[streamer_priv->tx_ring_free].buflen = skb->len;\r\nstreamer_priv->tx_ring_skb[streamer_priv->tx_ring_free] = skb;\r\nstreamer_priv->free_tx_ring_entries--;\r\n#if STREAMER_DEBUG_PACKETS\r\n{\r\nint i;\r\nprintk("streamer_xmit packet print:\n");\r\nfor (i = 0; i < skb->len; i++) {\r\nprintk("%x:", skb->data[i]);\r\nif (((i + 1) % 16) == 0)\r\nprintk("\n");\r\n}\r\nprintk("\n");\r\n}\r\n#endif\r\nwritel(cpu_to_le32(pci_map_single(streamer_priv->pci_dev,\r\n&streamer_priv->streamer_tx_ring[streamer_priv->tx_ring_free],\r\nsizeof(struct streamer_tx_desc), PCI_DMA_TODEVICE)),\r\nstreamer_mmio + TX2LFDA);\r\n(void)readl(streamer_mmio + TX2LFDA);\r\nstreamer_priv->tx_ring_free = (streamer_priv->tx_ring_free + 1) & (STREAMER_TX_RING_SIZE - 1);\r\nspin_unlock_irqrestore(&streamer_priv->streamer_lock,flags);\r\nreturn NETDEV_TX_OK;\r\n} else {\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&streamer_priv->streamer_lock,flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nstatic int streamer_close(struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\nunsigned long flags;\r\nint i;\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nwritew(streamer_priv->srb, streamer_mmio + LAPA);\r\nwritew(htons(SRB_CLOSE_ADAPTER << 8),streamer_mmio+LAPDINC);\r\nwritew(htons(STREAMER_CLEAR_RET_CODE << 8), streamer_mmio+LAPDINC);\r\nspin_lock_irqsave(&streamer_priv->streamer_lock, flags);\r\nstreamer_priv->srb_queued = 1;\r\nwritew(LISR_SRB_CMD, streamer_mmio + LISR_SUM);\r\nspin_unlock_irqrestore(&streamer_priv->streamer_lock, flags);\r\nwhile (streamer_priv->srb_queued)\r\n{\r\ninterruptible_sleep_on_timeout(&streamer_priv->srb_wait,\r\njiffies + 60 * HZ);\r\nif (signal_pending(current))\r\n{\r\nprintk(KERN_WARNING "%s: SRB timed out.\n", dev->name);\r\nprintk(KERN_WARNING "SISR=%x MISR=%x LISR=%x\n",\r\nreadw(streamer_mmio + SISR),\r\nreadw(streamer_mmio + MISR_RUM),\r\nreadw(streamer_mmio + LISR));\r\nstreamer_priv->srb_queued = 0;\r\nbreak;\r\n}\r\n}\r\nstreamer_priv->rx_ring_last_received = (streamer_priv->rx_ring_last_received + 1) & (STREAMER_RX_RING_SIZE - 1);\r\nfor (i = 0; i < STREAMER_RX_RING_SIZE; i++) {\r\nif (streamer_priv->rx_ring_skb[streamer_priv->rx_ring_last_received]) {\r\ndev_kfree_skb(streamer_priv->rx_ring_skb[streamer_priv->rx_ring_last_received]);\r\n}\r\nstreamer_priv->rx_ring_last_received = (streamer_priv->rx_ring_last_received + 1) & (STREAMER_RX_RING_SIZE - 1);\r\n}\r\n#if STREAMER_DEBUG\r\nwritew(streamer_priv->srb, streamer_mmio + LAPA);\r\nprintk("srb): ");\r\nfor (i = 0; i < 2; i++) {\r\nprintk("%x ", ntohs(readw(streamer_mmio + LAPDINC)));\r\n}\r\nprintk("\n");\r\n#endif\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void streamer_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\n__u8 options = 0;\r\nstruct netdev_hw_addr *ha;\r\nunsigned char dev_mc_address[5];\r\nwritel(streamer_priv->srb, streamer_mmio + LAPA);\r\noptions = streamer_priv->streamer_copy_all_options;\r\nif (dev->flags & IFF_PROMISC)\r\noptions |= (3 << 5);\r\nelse\r\noptions &= ~(3 << 5);\r\nif ((options ^ streamer_priv->streamer_copy_all_options))\r\n{\r\nwritew(htons(SRB_MODIFY_RECEIVE_OPTIONS << 8), streamer_mmio+LAPDINC);\r\nwritew(htons(STREAMER_CLEAR_RET_CODE << 8), streamer_mmio+LAPDINC);\r\nwritew(htons((streamer_priv->streamer_receive_options << 8) | options),streamer_mmio+LAPDINC);\r\nwritew(htons(0x4a41),streamer_mmio+LAPDINC);\r\nwritew(htons(0x4d45),streamer_mmio+LAPDINC);\r\nwritew(htons(0x5320),streamer_mmio+LAPDINC);\r\nwritew(0x2020, streamer_mmio + LAPDINC);\r\nstreamer_priv->srb_queued = 2;\r\nwritel(LISR_SRB_CMD, streamer_mmio + LISR_SUM);\r\nstreamer_priv->streamer_copy_all_options = options;\r\nreturn;\r\n}\r\nwritel(streamer_priv->srb,streamer_mmio+LAPA);\r\ndev_mc_address[0] = dev_mc_address[1] = dev_mc_address[2] = dev_mc_address[3] = 0 ;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ndev_mc_address[0] |= ha->addr[2];\r\ndev_mc_address[1] |= ha->addr[3];\r\ndev_mc_address[2] |= ha->addr[4];\r\ndev_mc_address[3] |= ha->addr[5];\r\n}\r\nwritew(htons(SRB_SET_FUNC_ADDRESS << 8),streamer_mmio+LAPDINC);\r\nwritew(htons(STREAMER_CLEAR_RET_CODE << 8), streamer_mmio+LAPDINC);\r\nwritew(0,streamer_mmio+LAPDINC);\r\nwritew(htons( (dev_mc_address[0] << 8) | dev_mc_address[1]),streamer_mmio+LAPDINC);\r\nwritew(htons( (dev_mc_address[2] << 8) | dev_mc_address[3]),streamer_mmio+LAPDINC);\r\nstreamer_priv->srb_queued = 2 ;\r\nwritel(LISR_SRB_CMD,streamer_mmio+LISR_SUM);\r\n}\r\nstatic void streamer_srb_bh(struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv = netdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\n__u16 srb_word;\r\nwritew(streamer_priv->srb, streamer_mmio + LAPA);\r\nsrb_word=ntohs(readw(streamer_mmio+LAPDINC)) >> 8;\r\nswitch (srb_word) {\r\ncase SRB_MODIFY_RECEIVE_OPTIONS:\r\nsrb_word=ntohs(readw(streamer_mmio+LAPDINC)) >> 8;\r\nswitch (srb_word) {\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n", dev->name);\r\nbreak;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n", dev->name);\r\nbreak;\r\ndefault:\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_WARNING "%s: Receive Options Modified to %x,%x\n",\r\ndev->name,\r\nstreamer_priv->streamer_copy_all_options,\r\nstreamer_priv->streamer_receive_options);\r\nbreak;\r\n}\r\nbreak;\r\ncase SRB_SET_GROUP_ADDRESS:\r\nsrb_word=ntohs(readw(streamer_mmio+LAPDINC)) >> 8;\r\nswitch (srb_word) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n",dev->name);\r\nbreak;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n", dev->name);\r\nbreak;\r\ncase 0x3c:\r\nprintk(KERN_WARNING "%s: Group/Functional address indicator bits not set correctly\n", dev->name);\r\nbreak;\r\ncase 0x3e:\r\nprintk(KERN_WARNING "%s: Group address registers full\n", dev->name);\r\nbreak;\r\ncase 0x55:\r\nprintk(KERN_INFO "%s: Group Address already set.\n", dev->name);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SRB_RESET_GROUP_ADDRESS:\r\nsrb_word=ntohs(readw(streamer_mmio+LAPDINC)) >> 8;\r\nswitch (srb_word) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n", dev->name);\r\nbreak;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n", dev->name);\r\nbreak;\r\ncase 0x39:\r\nprintk(KERN_INFO "%s: Group address not found\n", dev->name);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SRB_SET_FUNC_ADDRESS:\r\nsrb_word=ntohs(readw(streamer_mmio+LAPDINC)) >> 8;\r\nswitch (srb_word) {\r\ncase 0x00:\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Functional Address Mask Set\n", dev->name);\r\nbreak;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n", dev->name);\r\nbreak;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n", dev->name);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SRB_READ_LOG:\r\nsrb_word=ntohs(readw(streamer_mmio+LAPDINC)) >> 8;\r\nswitch (srb_word) {\r\ncase 0x00:\r\n{\r\nint i;\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Read Log command complete\n", dev->name);\r\nprintk("Read Log statistics: ");\r\nwritew(streamer_priv->srb + 6,\r\nstreamer_mmio + LAPA);\r\nfor (i = 0; i < 5; i++) {\r\nprintk("%x:", ntohs(readw(streamer_mmio + LAPDINC)));\r\n}\r\nprintk("\n");\r\n}\r\nbreak;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n", dev->name);\r\nbreak;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n", dev->name);\r\nbreak;\r\n}\r\nbreak;\r\ncase SRB_READ_SR_COUNTERS:\r\nsrb_word=ntohs(readw(streamer_mmio+LAPDINC)) >> 8;\r\nswitch (srb_word) {\r\ncase 0x00:\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Read Source Routing Counters issued\n", dev->name);\r\nbreak;\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized srb command\n", dev->name);\r\nbreak;\r\ncase 0x04:\r\nprintk(KERN_WARNING "%s: Adapter must be open for this operation, doh!!\n", dev->name);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: Unrecognized srb bh return value.\n", dev->name);\r\nbreak;\r\n}\r\n}\r\nstatic int streamer_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *saddr = addr;\r\nstruct streamer_private *streamer_priv = netdev_priv(dev);\r\nif (netif_running(dev))\r\n{\r\nprintk(KERN_WARNING "%s: Cannot set mac/laa address while card is open\n", dev->name);\r\nreturn -EIO;\r\n}\r\nmemcpy(streamer_priv->streamer_laa, saddr->sa_data, dev->addr_len);\r\nif (streamer_priv->streamer_message_level) {\r\nprintk(KERN_INFO "%s: MAC/LAA Set to = %x.%x.%x.%x.%x.%x\n",\r\ndev->name, streamer_priv->streamer_laa[0],\r\nstreamer_priv->streamer_laa[1],\r\nstreamer_priv->streamer_laa[2],\r\nstreamer_priv->streamer_laa[3],\r\nstreamer_priv->streamer_laa[4],\r\nstreamer_priv->streamer_laa[5]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void streamer_arb_cmd(struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\n__u8 header_len;\r\n__u16 frame_len, buffer_len;\r\nstruct sk_buff *mac_frame;\r\n__u8 frame_data[256];\r\n__u16 buff_off;\r\n__u16 lan_status = 0, lan_status_diff;\r\n__u8 fdx_prot_error;\r\n__u16 next_ptr;\r\n__u16 arb_word;\r\n#if STREAMER_NETWORK_MONITOR\r\nstruct trh_hdr *mac_hdr;\r\n#endif\r\nwritew(streamer_priv->arb, streamer_mmio + LAPA);\r\narb_word=ntohs(readw(streamer_mmio+LAPD)) >> 8;\r\nif (arb_word == ARB_RECEIVE_DATA) {\r\nwritew(streamer_priv->arb + 6, streamer_mmio + LAPA);\r\nstreamer_priv->mac_rx_buffer = buff_off = ntohs(readw(streamer_mmio + LAPDINC));\r\nheader_len=ntohs(readw(streamer_mmio+LAPDINC)) >> 8;\r\nframe_len = ntohs(readw(streamer_mmio + LAPDINC));\r\n#if STREAMER_DEBUG\r\n{\r\nint i;\r\n__u16 next;\r\n__u8 status;\r\n__u16 len;\r\nwritew(ntohs(buff_off), streamer_mmio + LAPA);\r\nnext = htons(readw(streamer_mmio + LAPDINC));\r\nstatus =\r\nntohs(readw(streamer_mmio + LAPDINC)) & 0xff;\r\nlen = ntohs(readw(streamer_mmio + LAPDINC));\r\nfor (i = 0; i < 7; i++) {\r\nprintk("Loc %d = %04x\n", i,\r\nntohs(readw\r\n(streamer_mmio + LAPDINC)));\r\n}\r\nprintk("next %04x, fs %02x, len %04x\n", next,\r\nstatus, len);\r\n}\r\n#endif\r\nif (!(mac_frame = dev_alloc_skb(frame_len))) {\r\nprintk(KERN_WARNING "%s: Memory squeeze, dropping frame.\n",\r\ndev->name);\r\ngoto drop_frame;\r\n}\r\ndo {\r\nint i;\r\n__u16 rx_word;\r\nwritew(htons(buff_off), streamer_mmio + LAPA);\r\nnext_ptr = ntohs(readw(streamer_mmio + LAPDINC));\r\nreadw(streamer_mmio + LAPDINC);\r\nbuffer_len = ntohs(readw(streamer_mmio + LAPDINC));\r\nif (buffer_len > 256)\r\nbreak;\r\ni = 0;\r\nwhile (i < buffer_len) {\r\nrx_word=ntohs(readw(streamer_mmio+LAPDINC));\r\nframe_data[i]=rx_word >> 8;\r\nframe_data[i+1]=rx_word & 0xff;\r\ni += 2;\r\n}\r\nmemcpy(skb_put(mac_frame, buffer_len),\r\nframe_data, buffer_len);\r\n} while (next_ptr && (buff_off = next_ptr));\r\nmac_frame->protocol = tr_type_trans(mac_frame, dev);\r\n#if STREAMER_NETWORK_MONITOR\r\nprintk(KERN_WARNING "%s: Received MAC Frame, details:\n",\r\ndev->name);\r\nmac_hdr = tr_hdr(mac_frame);\r\nprintk(KERN_WARNING\r\n"%s: MAC Frame Dest. Addr: %pM\n",\r\ndev->name, mac_hdr->daddr);\r\nprintk(KERN_WARNING\r\n"%s: MAC Frame Srce. Addr: %pM\n",\r\ndev->name, mac_hdr->saddr);\r\n#endif\r\nnetif_rx(mac_frame);\r\ndrop_frame:\r\nwritel(LISR_ARB_FREE, streamer_priv->streamer_mmio + LISR_SUM);\r\nif (!(readl(streamer_priv->streamer_mmio + SISR) & SISR_ASB_FREE))\r\n{\r\nstreamer_priv->asb_queued = 1;\r\nwritel(LISR_ASB_FREE_REQ, streamer_priv->streamer_mmio + LISR_SUM);\r\nreturn;\r\n}\r\nwritew(streamer_priv->asb, streamer_mmio + LAPA);\r\nwritew(htons(ASB_RECEIVE_DATA << 8), streamer_mmio+LAPDINC);\r\nwritew(htons(STREAMER_CLEAR_RET_CODE << 8), streamer_mmio+LAPDINC);\r\nwritew(0, streamer_mmio + LAPDINC);\r\nwritew(htons(streamer_priv->mac_rx_buffer), streamer_mmio + LAPD);\r\nwritel(LISR_ASB_REPLY | LISR_ASB_FREE_REQ, streamer_priv->streamer_mmio + LISR_SUM);\r\nstreamer_priv->asb_queued = 2;\r\nreturn;\r\n} else if (arb_word == ARB_LAN_CHANGE_STATUS) {\r\nwritew(streamer_priv->arb + 6, streamer_mmio + LAPA);\r\nlan_status = ntohs(readw(streamer_mmio + LAPDINC));\r\nfdx_prot_error = ntohs(readw(streamer_mmio+LAPD)) >> 8;\r\nwritew(LISR_ARB_FREE, streamer_priv->streamer_mmio + LISR_SUM);\r\nlan_status_diff = (streamer_priv->streamer_lan_status ^ lan_status) &\r\nlan_status;\r\nif (lan_status_diff & (LSC_LWF | LSC_ARW | LSC_FPE | LSC_RR))\r\n{\r\nif (lan_status_diff & LSC_LWF)\r\nprintk(KERN_WARNING "%s: Short circuit detected on the lobe\n", dev->name);\r\nif (lan_status_diff & LSC_ARW)\r\nprintk(KERN_WARNING "%s: Auto removal error\n", dev->name);\r\nif (lan_status_diff & LSC_FPE)\r\nprintk(KERN_WARNING "%s: FDX Protocol Error\n", dev->name);\r\nif (lan_status_diff & LSC_RR)\r\nprintk(KERN_WARNING "%s: Force remove MAC frame received\n", dev->name);\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nprintk(KERN_WARNING "%s: Adapter must be manually reset.\n", dev->name);\r\n}\r\nif (streamer_priv->streamer_message_level) {\r\nif (lan_status_diff & LSC_SIG_LOSS)\r\nprintk(KERN_WARNING "%s: No receive signal detected\n", dev->name);\r\nif (lan_status_diff & LSC_HARD_ERR)\r\nprintk(KERN_INFO "%s: Beaconing\n", dev->name);\r\nif (lan_status_diff & LSC_SOFT_ERR)\r\nprintk(KERN_WARNING "%s: Adapter transmitted Soft Error Report Mac Frame\n", dev->name);\r\nif (lan_status_diff & LSC_TRAN_BCN)\r\nprintk(KERN_INFO "%s: We are transmitting the beacon, aaah\n", dev->name);\r\nif (lan_status_diff & LSC_SS)\r\nprintk(KERN_INFO "%s: Single Station on the ring\n", dev->name);\r\nif (lan_status_diff & LSC_RING_REC)\r\nprintk(KERN_INFO "%s: Ring recovery ongoing\n", dev->name);\r\nif (lan_status_diff & LSC_FDX_MODE)\r\nprintk(KERN_INFO "%s: Operating in FDX mode\n", dev->name);\r\n}\r\nif (lan_status_diff & LSC_CO) {\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Counter Overflow\n", dev->name);\r\nwritew(streamer_priv->srb, streamer_mmio + LAPA);\r\nwritew(htons(SRB_READ_LOG << 8),streamer_mmio+LAPDINC);\r\nwritew(htons(STREAMER_CLEAR_RET_CODE << 8), streamer_mmio+LAPDINC);\r\nwritew(0, streamer_mmio + LAPDINC);\r\nstreamer_priv->srb_queued = 2;\r\nwritew(LISR_SRB_CMD, streamer_mmio + LISR_SUM);\r\n}\r\nif (lan_status_diff & LSC_SR_CO) {\r\nif (streamer_priv->streamer_message_level)\r\nprintk(KERN_INFO "%s: Source routing counters overflow\n", dev->name);\r\nwritew(streamer_priv->srb, streamer_mmio + LAPA);\r\nwritew(htons(SRB_READ_SR_COUNTERS << 8),\r\nstreamer_mmio+LAPDINC);\r\nwritew(htons(STREAMER_CLEAR_RET_CODE << 8),\r\nstreamer_mmio+LAPDINC);\r\nstreamer_priv->srb_queued = 2;\r\nwritew(LISR_SRB_CMD, streamer_mmio + LISR_SUM);\r\n}\r\nstreamer_priv->streamer_lan_status = lan_status;\r\n}\r\nelse\r\nprintk(KERN_WARNING "%s: Unknown arb command\n", dev->name);\r\n}\r\nstatic void streamer_asb_bh(struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\nif (streamer_priv->asb_queued == 1)\r\n{\r\nwritew(streamer_priv->asb, streamer_mmio + LAPA);\r\nwritew(htons(ASB_RECEIVE_DATA << 8),streamer_mmio+LAPDINC);\r\nwritew(htons(STREAMER_CLEAR_RET_CODE << 8), streamer_mmio+LAPDINC);\r\nwritew(0, streamer_mmio + LAPDINC);\r\nwritew(htons(streamer_priv->mac_rx_buffer), streamer_mmio + LAPD);\r\nwritel(LISR_ASB_REPLY | LISR_ASB_FREE_REQ, streamer_priv->streamer_mmio + LISR_SUM);\r\nstreamer_priv->asb_queued = 2;\r\nreturn;\r\n}\r\nif (streamer_priv->asb_queued == 2) {\r\n__u8 rc;\r\nwritew(streamer_priv->asb + 2, streamer_mmio + LAPA);\r\nrc=ntohs(readw(streamer_mmio+LAPD)) >> 8;\r\nswitch (rc) {\r\ncase 0x01:\r\nprintk(KERN_WARNING "%s: Unrecognized command code\n", dev->name);\r\nbreak;\r\ncase 0x26:\r\nprintk(KERN_WARNING "%s: Unrecognized buffer address\n", dev->name);\r\nbreak;\r\ncase 0xFF:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: Invalid return code in asb\n", dev->name);\r\nbreak;\r\n}\r\n}\r\nstreamer_priv->asb_queued = 0;\r\n}\r\nstatic int streamer_change_mtu(struct net_device *dev, int mtu)\r\n{\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u16 max_mtu;\r\nif (streamer_priv->streamer_ring_speed == 4)\r\nmax_mtu = 4500;\r\nelse\r\nmax_mtu = 18000;\r\nif (mtu > max_mtu)\r\nreturn -EINVAL;\r\nif (mtu < 100)\r\nreturn -EINVAL;\r\ndev->mtu = mtu;\r\nstreamer_priv->pkt_buf_sz = mtu + TR_HLEN;\r\nreturn 0;\r\n}\r\nstatic int streamer_proc_info(char *buffer, char **start, off_t offset,\r\nint length, int *eof, void *data)\r\n{\r\nstruct streamer_private *sdev=NULL;\r\nstruct pci_dev *pci_device = NULL;\r\nint len = 0;\r\noff_t begin = 0;\r\noff_t pos = 0;\r\nint size;\r\nstruct net_device *dev;\r\nsize = sprintf(buffer, "IBM LanStreamer/MPC Chipset Token Ring Adapters\n");\r\npos += size;\r\nlen += size;\r\nfor(sdev=dev_streamer; sdev; sdev=sdev->next) {\r\npci_device=sdev->pci_dev;\r\ndev=pci_get_drvdata(pci_device);\r\nsize = sprintf_info(buffer + len, dev);\r\nlen += size;\r\npos = begin + len;\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\nif (pos > offset + length)\r\nbreak;\r\n}\r\n*start = buffer + (offset - begin);\r\nlen -= (offset - begin);\r\nif (len > length)\r\nlen = length;\r\nreturn len;\r\n}\r\nstatic int sprintf_info(char *buffer, struct net_device *dev)\r\n{\r\nstruct streamer_private *streamer_priv =\r\nnetdev_priv(dev);\r\n__u8 __iomem *streamer_mmio = streamer_priv->streamer_mmio;\r\nstruct streamer_adapter_addr_table sat;\r\nstruct streamer_parameters_table spt;\r\nint size = 0;\r\nint i;\r\nwritew(streamer_priv->streamer_addr_table_addr, streamer_mmio + LAPA);\r\nfor (i = 0; i < 14; i += 2) {\r\n__u16 io_word;\r\n__u8 *datap = (__u8 *) & sat;\r\nio_word=ntohs(readw(streamer_mmio+LAPDINC));\r\ndatap[size]=io_word >> 8;\r\ndatap[size+1]=io_word & 0xff;\r\n}\r\nwritew(streamer_priv->streamer_parms_addr, streamer_mmio + LAPA);\r\nfor (i = 0; i < 68; i += 2) {\r\n__u16 io_word;\r\n__u8 *datap = (__u8 *) & spt;\r\nio_word=ntohs(readw(streamer_mmio+LAPDINC));\r\ndatap[size]=io_word >> 8;\r\ndatap[size+1]=io_word & 0xff;\r\n}\r\nsize = sprintf(buffer, "\n%6s: Adapter Address : Node Address : Functional Addr\n", dev->name);\r\nsize += sprintf(buffer + size,\r\n"%6s: %pM : %pM : %02x:%02x:%02x:%02x\n",\r\ndev->name, dev->dev_addr, sat.node_addr,\r\nsat.func_addr[0], sat.func_addr[1],\r\nsat.func_addr[2], sat.func_addr[3]);\r\nsize += sprintf(buffer + size, "\n%6s: Token Ring Parameters Table:\n", dev->name);\r\nsize += sprintf(buffer + size, "%6s: Physical Addr : Up Node Address : Poll Address : AccPri : Auth Src : Att Code :\n", dev->name);\r\nsize += sprintf(buffer + size,\r\n"%6s: %02x:%02x:%02x:%02x : %pM : %pM : %04x : %04x : %04x :\n",\r\ndev->name, spt.phys_addr[0], spt.phys_addr[1],\r\nspt.phys_addr[2], spt.phys_addr[3],\r\nspt.up_node_addr, spt.poll_addr,\r\nntohs(spt.acc_priority), ntohs(spt.auth_source_class),\r\nntohs(spt.att_code));\r\nsize += sprintf(buffer + size, "%6s: Source Address : Bcn T : Maj. V : Lan St : Lcl Rg : Mon Err : Frame Correl : \n", dev->name);\r\nsize += sprintf(buffer + size,\r\n"%6s: %pM : %04x : %04x : %04x : %04x : %04x : %04x : \n",\r\ndev->name, spt.source_addr,\r\nntohs(spt.beacon_type), ntohs(spt.major_vector),\r\nntohs(spt.lan_status), ntohs(spt.local_ring),\r\nntohs(spt.mon_error), ntohs(spt.frame_correl));\r\nsize += sprintf(buffer + size, "%6s: Beacon Details : Tx : Rx : NAUN Node Address : NAUN Node Phys : \n",\r\ndev->name);\r\nsize += sprintf(buffer + size,\r\n"%6s: : %02x : %02x : %pM : %02x:%02x:%02x:%02x : \n",\r\ndev->name, ntohs(spt.beacon_transmit),\r\nntohs(spt.beacon_receive),\r\nspt.beacon_naun,\r\nspt.beacon_phys[0], spt.beacon_phys[1],\r\nspt.beacon_phys[2], spt.beacon_phys[3]);\r\nreturn size;\r\n}\r\nstatic int __init streamer_init_module(void) {\r\nreturn pci_register_driver(&streamer_pci_driver);\r\n}\r\nstatic void __exit streamer_cleanup_module(void) {\r\npci_unregister_driver(&streamer_pci_driver);\r\n}
