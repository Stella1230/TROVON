static inline void FreeBtOsBuf(struct ar6k_hci_bridge_info *pHcidevInfo, void *osbuf)\r\n{\r\nif (pHcidevInfo->HciNormalMode) {\r\nbt_free_buffer(pHcidevInfo, (struct sk_buff *)osbuf);\r\n} else {\r\nA_NETBUF_FREE(osbuf);\r\n}\r\n}\r\nstatic void FreeHTCStruct(struct ar6k_hci_bridge_info *pHcidevInfo, struct htc_packet *pPacket)\r\n{\r\nLOCK_BRIDGE(pHcidevInfo);\r\nHTC_PACKET_ENQUEUE(&pHcidevInfo->HTCPacketStructHead,pPacket);\r\nUNLOCK_BRIDGE(pHcidevInfo);\r\n}\r\nstatic struct htc_packet * AllocHTCStruct(struct ar6k_hci_bridge_info *pHcidevInfo)\r\n{\r\nstruct htc_packet *pPacket = NULL;\r\nLOCK_BRIDGE(pHcidevInfo);\r\npPacket = HTC_PACKET_DEQUEUE(&pHcidevInfo->HTCPacketStructHead);\r\nUNLOCK_BRIDGE(pHcidevInfo);\r\nreturn pPacket;\r\n}\r\nstatic void RefillRecvBuffers(struct ar6k_hci_bridge_info *pHcidevInfo,\r\nHCI_TRANSPORT_PACKET_TYPE Type,\r\nint NumBuffers)\r\n{\r\nint length, i;\r\nvoid *osBuf = NULL;\r\nstruct htc_packet_queue queue;\r\nstruct htc_packet *pPacket;\r\nINIT_HTC_PACKET_QUEUE(&queue);\r\nif (Type == HCI_ACL_TYPE) {\r\nif (pHcidevInfo->HciNormalMode) {\r\nlength = HCI_MAX_FRAME_SIZE;\r\n} else {\r\nlength = MAX_ACL_RECV_LENGTH;\r\n}\r\n} else {\r\nlength = MAX_EVT_RECV_LENGTH;\r\n}\r\nlength += pHcidevInfo->HCIProps.HeadRoom + pHcidevInfo->HCIProps.TailRoom;\r\nlength = BLOCK_ROUND_UP_PWR2(length,pHcidevInfo->HCIProps.IOBlockPad);\r\nfor (i = 0; i < NumBuffers; i++) {\r\nif (pHcidevInfo->HciNormalMode) {\r\nosBuf = bt_alloc_buffer(pHcidevInfo,length);\r\n} else {\r\nosBuf = A_NETBUF_ALLOC(length);\r\n}\r\nif (NULL == osBuf) {\r\nbreak;\r\n}\r\npPacket = AllocHTCStruct(pHcidevInfo);\r\nif (NULL == pPacket) {\r\nFreeBtOsBuf(pHcidevInfo,osBuf);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to alloc HTC struct \n"));\r\nbreak;\r\n}\r\nSET_HTC_PACKET_INFO_RX_REFILL(pPacket,osBuf,A_NETBUF_DATA(osBuf),length,Type);\r\nHTC_PACKET_ENQUEUE(&queue,pPacket);\r\n}\r\nif (i > 0) {\r\nHCI_TransportAddReceivePkts(pHcidevInfo->pHCIDev, &queue);\r\n}\r\n}\r\nstatic int ar6000_hci_transport_ready(HCI_TRANSPORT_HANDLE HCIHandle,\r\nstruct hci_transport_properties *pProps,\r\nvoid *pContext)\r\n{\r\nstruct ar6k_hci_bridge_info *pHcidevInfo = (struct ar6k_hci_bridge_info *)pContext;\r\nint status;\r\nu32 address, hci_uart_pwr_mgmt_params;\r\npHcidevInfo->pHCIDev = HCIHandle;\r\nmemcpy(&pHcidevInfo->HCIProps,pProps,sizeof(*pProps));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_BRIDGE,("HCI ready (hci:0x%lX, headroom:%d, tailroom:%d blockpad:%d) \n",\r\n(unsigned long)HCIHandle,\r\npHcidevInfo->HCIProps.HeadRoom,\r\npHcidevInfo->HCIProps.TailRoom,\r\npHcidevInfo->HCIProps.IOBlockPad));\r\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\r\nA_ASSERT((pProps->HeadRoom + pProps->TailRoom) <= (struct net_device *)(pHcidevInfo->HCITransHdl.netDevice)->hard_header_len);\r\n#else\r\nA_ASSERT((pProps->HeadRoom + pProps->TailRoom) <= pHcidevInfo->ar->arNetDev->hard_header_len);\r\n#endif\r\nRefillRecvBuffers(pHcidevInfo, HCI_ACL_TYPE, MAX_ACL_RECV_BUFS);\r\nRefillRecvBuffers(pHcidevInfo, HCI_EVENT_TYPE, MAX_EVT_RECV_BUFS);\r\ndo {\r\nstatus = HCI_TransportStart(pHcidevInfo->pHCIDev);\r\nif (status) {\r\nbreak;\r\n}\r\nif (!pHcidevInfo->HciNormalMode) {\r\nbreak;\r\n}\r\nA_MDELAY(100);\r\nA_MEMZERO(&ar3kconfig,sizeof(ar3kconfig));\r\nar3kconfig.pHCIDev = pHcidevInfo->pHCIDev;\r\nar3kconfig.pHCIProps = &pHcidevInfo->HCIProps;\r\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\r\nar3kconfig.pHIFDevice = (struct hif_device *)(pHcidevInfo->HCITransHdl.hifDevice);\r\n#else\r\nar3kconfig.pHIFDevice = pHcidevInfo->ar->arHifDevice;\r\n#endif\r\nar3kconfig.pBtStackHCIDev = pHcidevInfo->pBtStackHCIDev;\r\nif (ar3khcibaud != 0) {\r\nar3kconfig.Flags |= AR3K_CONFIG_FLAG_SET_AR3K_BAUD;\r\nar3kconfig.Flags |= AR3K_CONFIG_FLAG_AR3K_BAUD_CHANGE_DELAY;\r\nar3kconfig.AR3KBaudRate = ar3khcibaud;\r\n}\r\nif ((hciuartscale != 0) || (hciuartstep != 0)) {\r\nar3kconfig.AR6KScale = (u16)hciuartscale;\r\nar3kconfig.AR6KStep = (u16)hciuartstep;\r\nar3kconfig.Flags |= AR3K_CONFIG_FLAG_SET_AR6K_SCALE_STEP;\r\n}\r\naddress = TARG_VTOP(pHcidevInfo->ar->arTargetType,\r\nHOST_INTEREST_ITEM_ADDRESS(pHcidevInfo->ar, hi_hci_uart_pwr_mgmt_params));\r\nstatus = ar6000_ReadRegDiag(pHcidevInfo->ar->arHifDevice, &address, &hci_uart_pwr_mgmt_params);\r\nif (0 == status) {\r\nar3kconfig.PwrMgmtEnabled = (hci_uart_pwr_mgmt_params & 0x1);\r\nar3kconfig.IdleTimeout = (hci_uart_pwr_mgmt_params & 0xFFFF0000) >> 16;\r\nar3kconfig.WakeupTimeout = (hci_uart_pwr_mgmt_params & 0xFF00) >> 8;\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HCI Bridge: failed to read hci_uart_pwr_mgmt_params! \n"));\r\n}\r\nmemcpy(ar3kconfig.bdaddr,pHcidevInfo->ar->bdaddr,6);\r\nstatus = AR3KConfigure(&ar3kconfig);\r\nif (status) {\r\nbreak;\r\n}\r\nif (ar3kconfig.PwrMgmtEnabled) {\r\nstatus = HCI_TransportEnablePowerMgmt(pHcidevInfo->pHCIDev, true);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HCI Bridge: failed to enable TLPM for AR6K! \n"));\r\n}\r\n}\r\nstatus = bt_register_hci(pHcidevInfo);\r\n} while (false);\r\nreturn status;\r\n}\r\nstatic void ar6000_hci_transport_failure(void *pContext, int Status)\r\n{\r\nstruct ar6k_hci_bridge_info *pHcidevInfo = (struct ar6k_hci_bridge_info *)pContext;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HCI Bridge: transport failure! \n"));\r\nif (pHcidevInfo->HciNormalMode) {\r\n}\r\n}\r\nstatic void ar6000_hci_transport_removed(void *pContext)\r\n{\r\nstruct ar6k_hci_bridge_info *pHcidevInfo = (struct ar6k_hci_bridge_info *)pContext;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_BRIDGE, ("HCI Bridge: transport removed. \n"));\r\nA_ASSERT(pHcidevInfo->pHCIDev != NULL);\r\nHCI_TransportDetach(pHcidevInfo->pHCIDev);\r\nbt_cleanup_hci(pHcidevInfo);\r\npHcidevInfo->pHCIDev = NULL;\r\n}\r\nstatic void ar6000_hci_send_complete(void *pContext, struct htc_packet *pPacket)\r\n{\r\nstruct ar6k_hci_bridge_info *pHcidevInfo = (struct ar6k_hci_bridge_info *)pContext;\r\nvoid *osbuf = pPacket->pPktContext;\r\nA_ASSERT(osbuf != NULL);\r\nA_ASSERT(pHcidevInfo != NULL);\r\nif (pPacket->Status) {\r\nif ((pPacket->Status != A_ECANCELED) && (pPacket->Status != A_NO_RESOURCE)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HCI Bridge: Send Packet Failed: %d \n",pPacket->Status));\r\n}\r\n}\r\nFreeHTCStruct(pHcidevInfo,pPacket);\r\nFreeBtOsBuf(pHcidevInfo,osbuf);\r\n}\r\nstatic void ar6000_hci_pkt_recv(void *pContext, struct htc_packet *pPacket)\r\n{\r\nstruct ar6k_hci_bridge_info *pHcidevInfo = (struct ar6k_hci_bridge_info *)pContext;\r\nstruct sk_buff *skb;\r\nA_ASSERT(pHcidevInfo != NULL);\r\nskb = (struct sk_buff *)pPacket->pPktContext;\r\nA_ASSERT(skb != NULL);\r\ndo {\r\nif (pPacket->Status) {\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_RECV,\r\n("HCI Bridge, packet received type : %d len:%d \n",\r\nHCI_GET_PACKET_TYPE(pPacket),pPacket->ActualLength));\r\nA_NETBUF_PUT(skb,pPacket->ActualLength + pHcidevInfo->HCIProps.HeadRoom);\r\nA_NETBUF_PULL(skb,pHcidevInfo->HCIProps.HeadRoom);\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_HCI_DUMP)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,("<<< Recv HCI %s packet len:%d \n",\r\n(HCI_GET_PACKET_TYPE(pPacket) == HCI_EVENT_TYPE) ? "EVENT" : "ACL",\r\nskb->len));\r\nAR_DEBUG_PRINTBUF(skb->data, skb->len,"BT HCI RECV Packet Dump");\r\n}\r\nif (pHcidevInfo->HciNormalMode) {\r\nif (bt_indicate_recv(pHcidevInfo,HCI_GET_PACKET_TYPE(pPacket),skb)) {\r\nskb = NULL;\r\n}\r\nbreak;\r\n}\r\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\r\nskb->dev = (struct net_device *)(pHcidevInfo->HCITransHdl.netDevice);\r\nif ((((struct net_device *)pHcidevInfo->HCITransHdl.netDevice)->flags & IFF_UP) == IFF_UP) {\r\nskb->protocol = eth_type_trans(skb, (struct net_device *)(pHcidevInfo->HCITransHdl.netDevice));\r\n#else\r\nskb->dev = pHcidevInfo->ar->arNetDev;\r\nif ((pHcidevInfo->ar->arNetDev->flags & IFF_UP) == IFF_UP) {\r\nskb->protocol = eth_type_trans(skb, pHcidevInfo->ar->arNetDev);\r\n#endif\r\nnetif_rx(skb);\r\nskb = NULL;\r\n}\r\n} while (false);\r\nFreeHTCStruct(pHcidevInfo,pPacket);\r\nif (skb != NULL) {\r\nFreeBtOsBuf(pHcidevInfo,skb);\r\n}\r\n}\r\nstatic void ar6000_hci_pkt_refill(void *pContext, HCI_TRANSPORT_PACKET_TYPE Type, int BuffersAvailable)\r\n{\r\nstruct ar6k_hci_bridge_info *pHcidevInfo = (struct ar6k_hci_bridge_info *)pContext;\r\nint refillCount;\r\nif (Type == HCI_ACL_TYPE) {\r\nrefillCount = MAX_ACL_RECV_BUFS - BuffersAvailable;\r\n} else {\r\nrefillCount = MAX_EVT_RECV_BUFS - BuffersAvailable;\r\n}\r\nif (refillCount > 0) {\r\nRefillRecvBuffers(pHcidevInfo,Type,refillCount);\r\n}\r\n}\r\nstatic HCI_SEND_FULL_ACTION ar6000_hci_pkt_send_full(void *pContext, struct htc_packet *pPacket\r\nvoid ar6000_set_default_ar3kconfig(struct ar6_softc *ar, void *ar3kconfig)\r\n{\r\nstruct ar6k_hci_bridge_info *pHcidevInfo = (struct ar6k_hci_bridge_info *)ar->hcidev_info;\r\nstruct ar3k_config_info *config = (struct ar3k_config_info *)ar3kconfig;\r\nconfig->pHCIDev = pHcidevInfo->pHCIDev;\r\nconfig->pHCIProps = &pHcidevInfo->HCIProps;\r\nconfig->pHIFDevice = ar->arHifDevice;\r\nconfig->pBtStackHCIDev = pHcidevInfo->pBtStackHCIDev;\r\nconfig->Flags |= AR3K_CONFIG_FLAG_SET_AR3K_BAUD;\r\nconfig->AR3KBaudRate = 115200;\r\n}\r\nstatic int bt_open(struct hci_dev *hdev)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HCI Bridge: bt_open - enter - x\n"));\r\nset_bit(HCI_RUNNING, &hdev->flags);\r\nset_bit(HCI_UP, &hdev->flags);\r\nset_bit(HCI_INIT, &hdev->flags);\r\nreturn 0;\r\n}\r\nstatic int bt_close(struct hci_dev *hdev)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HCI Bridge: bt_close - enter\n"));\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nreturn 0;\r\n}\r\nstatic int bt_send_frame(struct sk_buff *skb)\r\n{\r\nstruct hci_dev *hdev = (struct hci_dev *)skb->dev;\r\nHCI_TRANSPORT_PACKET_TYPE type;\r\nstruct ar6k_hci_bridge_info *pHcidevInfo;\r\nstruct htc_packet *pPacket;\r\nint status = 0;\r\nstruct sk_buff *txSkb = NULL;\r\nif (!hdev) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, ("HCI Bridge: bt_send_frame - no device\n"));\r\nreturn -ENODEV;\r\n}\r\nif (!test_bit(HCI_RUNNING, &hdev->flags)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HCI Bridge: bt_send_frame - not open\n"));\r\nreturn -EBUSY;\r\n}\r\npHcidevInfo = (struct ar6k_hci_bridge_info *)hdev->driver_data;\r\nA_ASSERT(pHcidevInfo != NULL);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_SEND, ("+bt_send_frame type: %d \n",bt_cb(skb)->pkt_type));\r\ntype = HCI_COMMAND_TYPE;\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\ntype = HCI_COMMAND_TYPE;\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\ntype = HCI_ACL_TYPE;\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nkfree_skb(skb);\r\nreturn 0;\r\ndefault:\r\nA_ASSERT(false);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_HCI_DUMP)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,(">>> Send HCI %s packet len: %d\n",\r\n(type == HCI_COMMAND_TYPE) ? "COMMAND" : "ACL",\r\nskb->len));\r\nif (type == HCI_COMMAND_TYPE) {\r\nu16 opcode = HCI_GET_OP_CODE(skb->data);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ANY,(" HCI Command: OGF:0x%X OCF:0x%X \r\n",\r\nopcode >> 10, opcode & 0x3FF));\r\n}\r\nAR_DEBUG_PRINTBUF(skb->data,skb->len,"BT HCI SEND Packet Dump");\r\n}\r\ndo {\r\ntxSkb = bt_skb_alloc(TX_PACKET_RSV_OFFSET + pHcidevInfo->HCIProps.HeadRoom +\r\npHcidevInfo->HCIProps.TailRoom + skb->len,\r\nGFP_ATOMIC);\r\nif (txSkb == NULL) {\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\nbt_cb(txSkb)->pkt_type = bt_cb(skb)->pkt_type;\r\ntxSkb->dev = (void *)pHcidevInfo->pBtStackHCIDev;\r\nskb_reserve(txSkb, TX_PACKET_RSV_OFFSET + pHcidevInfo->HCIProps.HeadRoom);\r\nmemcpy(txSkb->data, skb->data, skb->len);\r\nskb_put(txSkb,skb->len);\r\npPacket = AllocHTCStruct(pHcidevInfo);\r\nif (NULL == pPacket) {\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\nSET_HTC_PACKET_INFO_TX(pPacket,\r\ntxSkb,\r\ntxSkb->data,\r\ntxSkb->len,\r\ntype,\r\nAR6K_CONTROL_PKT_TAG);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_SEND, ("HCI Bridge: bt_send_frame skb:0x%lX \n",(unsigned long)txSkb));\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_SEND, ("HCI Bridge: type:%d, Total Length:%d Bytes \n",\r\ntype, txSkb->len));\r\nstatus = HCI_TransportSendPkt(pHcidevInfo->pHCIDev,pPacket,false);\r\npPacket = NULL;\r\ntxSkb = NULL;\r\n} while (false);\r\nif (txSkb != NULL) {\r\nkfree_skb(txSkb);\r\n}\r\nkfree_skb(skb);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_SEND, ("-bt_send_frame \n"));\r\nreturn 0;\r\n}\r\nstatic int bt_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HCI Bridge: bt_ioctl - enter\n"));\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int bt_flush(struct hci_dev *hdev)\r\n{\r\nstruct ar6k_hci_bridge_info *pHcidevInfo;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HCI Bridge: bt_flush - enter\n"));\r\npHcidevInfo = (struct ar6k_hci_bridge_info *)hdev->driver_data;\r\nreturn 0;\r\n}\r\nstatic void bt_destruct(struct hci_dev *hdev)\r\n{\r\nAR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HCI Bridge: bt_destruct - enter\n"));\r\n}\r\nstatic int bt_setup_hci(struct ar6k_hci_bridge_info *pHcidevInfo)\r\n{\r\nint status = 0;\r\nstruct hci_dev *pHciDev = NULL;\r\nstruct hif_device_os_device_info osDevInfo;\r\nif (!setupbtdev) {\r\nreturn 0;\r\n}\r\ndo {\r\nA_MEMZERO(&osDevInfo,sizeof(osDevInfo));\r\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\r\nstatus = ar6000_get_hif_dev((struct hif_device *)(pHcidevInfo->HCITransHdl.hifDevice),\r\n&osDevInfo);\r\n#else\r\nstatus = HIFConfigureDevice(pHcidevInfo->ar->arHifDevice,\r\nHIF_DEVICE_GET_OS_DEVICE,\r\n&osDevInfo,\r\nsizeof(osDevInfo));\r\n#endif\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to OS device info from HIF\n"));\r\nbreak;\r\n}\r\npHciDev = hci_alloc_dev();\r\nif (NULL == pHciDev) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HCI Bridge - failed to allocate bt struct \n"));\r\nstatus = A_NO_MEMORY;\r\nbreak;\r\n}\r\npHcidevInfo->pBtStackHCIDev = pHciDev;\r\nSET_HCIDEV_DEV(pHciDev,osDevInfo.pOSDevice);\r\nSET_HCI_BUS_TYPE(pHciDev, HCI_VIRTUAL, HCI_BREDR);\r\npHciDev->driver_data = pHcidevInfo;\r\npHciDev->open = bt_open;\r\npHciDev->close = bt_close;\r\npHciDev->send = bt_send_frame;\r\npHciDev->ioctl = bt_ioctl;\r\npHciDev->flush = bt_flush;\r\npHciDev->destruct = bt_destruct;\r\npHciDev->owner = THIS_MODULE;\r\npHcidevInfo->HciNormalMode = true;\r\n} while (false);\r\nif (status) {\r\nbt_cleanup_hci(pHcidevInfo);\r\n}\r\nreturn status;\r\n}\r\nstatic void bt_cleanup_hci(struct ar6k_hci_bridge_info *pHcidevInfo)\r\n{\r\nint err;\r\nif (pHcidevInfo->HciRegistered) {\r\npHcidevInfo->HciRegistered = false;\r\nclear_bit(HCI_RUNNING, &pHcidevInfo->pBtStackHCIDev->flags);\r\nclear_bit(HCI_UP, &pHcidevInfo->pBtStackHCIDev->flags);\r\nclear_bit(HCI_INIT, &pHcidevInfo->pBtStackHCIDev->flags);\r\nA_ASSERT(pHcidevInfo->pBtStackHCIDev != NULL);\r\nif ((err = hci_unregister_dev(pHcidevInfo->pBtStackHCIDev)) < 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HCI Bridge: failed to unregister with bluetooth %d\n",err));\r\n}\r\n}\r\nkfree(pHcidevInfo->pBtStackHCIDev);\r\npHcidevInfo->pBtStackHCIDev = NULL;\r\n}\r\nstatic int bt_register_hci(struct ar6k_hci_bridge_info *pHcidevInfo)\r\n{\r\nint err;\r\nint status = 0;\r\ndo {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_BRIDGE, ("HCI Bridge: registering HCI... \n"));\r\nA_ASSERT(pHcidevInfo->pBtStackHCIDev != NULL);\r\npHcidevInfo->HciRegistered = true;\r\nif ((err = hci_register_dev(pHcidevInfo->pBtStackHCIDev)) < 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HCI Bridge: failed to register with bluetooth %d\n",err));\r\npHcidevInfo->HciRegistered = false;\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_BRIDGE, ("HCI Bridge: HCI registered \n"));\r\n} while (false);\r\nreturn status;\r\n}\r\nstatic bool bt_indicate_recv(struct ar6k_hci_bridge_info *pHcidevInfo,\r\nHCI_TRANSPORT_PACKET_TYPE Type,\r\nstruct sk_buff *skb)\r\n{\r\nu8 btType;\r\nint len;\r\nbool success = false;\r\nBT_HCI_EVENT_HEADER *pEvent;\r\ndo {\r\nif (!test_bit(HCI_RUNNING, &pHcidevInfo->pBtStackHCIDev->flags)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_WARN, ("HCI Bridge: bt_indicate_recv - not running\n"));\r\nbreak;\r\n}\r\nswitch (Type) {\r\ncase HCI_ACL_TYPE:\r\nbtType = HCI_ACLDATA_PKT;\r\nbreak;\r\ncase HCI_EVENT_TYPE:\r\nbtType = HCI_EVENT_PKT;\r\nbreak;\r\ndefault:\r\nbtType = 0;\r\nA_ASSERT(false);\r\nbreak;\r\n}\r\nif (0 == btType) {\r\nbreak;\r\n}\r\nbt_cb(skb)->pkt_type = btType;\r\nskb->dev = (void *)pHcidevInfo->pBtStackHCIDev;\r\nlen = skb->len;\r\nif (AR_DEBUG_LVL_CHECK(ATH_DEBUG_HCI_RECV)) {\r\nif (bt_cb(skb)->pkt_type == HCI_EVENT_PKT) {\r\npEvent = (BT_HCI_EVENT_HEADER *)skb->data;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_RECV, ("BT HCI EventCode: %d, len:%d \n",\r\npEvent->EventCode, pEvent->ParamLength));\r\n}\r\n}\r\nif (hci_recv_frame(skb) != 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HCI Bridge: hci_recv_frame failed \n"));\r\nbreak;\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_HCI_RECV,\r\n("HCI Bridge: Indicated RCV of type:%d, Length:%d \n",btType,len));\r\n}\r\nsuccess = true;\r\n} while (false);\r\nreturn success;\r\n}\r\nstatic struct sk_buff* bt_alloc_buffer(struct ar6k_hci_bridge_info *pHcidevInfo, int Length)\r\n{\r\nstruct sk_buff *skb;\r\nskb = bt_skb_alloc(Length, GFP_ATOMIC);\r\nif (NULL == skb) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to alloc bt sk_buff \n"));\r\n}\r\nreturn skb;\r\n}\r\nstatic void bt_free_buffer(struct ar6k_hci_bridge_info *pHcidevInfo, struct sk_buff *skb)\r\n{\r\nkfree_skb(skb);\r\n}\r\nstatic int bt_setup_hci(struct ar6k_hci_bridge_info *pHcidevInfo)\r\n{\r\nreturn 0;\r\n}\r\nstatic void bt_cleanup_hci(struct ar6k_hci_bridge_info *pHcidevInfo)\r\n{\r\n}\r\nstatic int bt_register_hci(struct ar6k_hci_bridge_info *pHcidevInfo)\r\n{\r\nA_ASSERT(false);\r\nreturn A_ERROR;\r\n}\r\nstatic bool bt_indicate_recv(struct ar6k_hci_bridge_info *pHcidevInfo,\r\nHCI_TRANSPORT_PACKET_TYPE Type,\r\nstruct sk_buff *skb)\r\n{\r\nA_ASSERT(false);\r\nreturn false;\r\n}\r\nstatic struct sk_buff* bt_alloc_buffer(struct ar6k_hci_bridge_info *pHcidevInfo, int Length)\r\n{\r\nA_ASSERT(false);\r\nreturn NULL;\r\n}\r\nstatic void bt_free_buffer(struct ar6k_hci_bridge_info *pHcidevInfo, struct sk_buff *skb)\r\n{\r\nA_ASSERT(false);\r\n}\r\nvoid ar6000_set_default_ar3kconfig(struct ar6_softc *ar, void *ar3kconfig)\r\n{\r\nreturn;\r\n}\r\nstatic int __init\r\nhcibridge_init_module(void)\r\n{\r\nint status;\r\nstruct hci_transport_callbacks hciTransCallbacks;\r\nhciTransCallbacks.setupTransport = ar6000_setup_hci;\r\nhciTransCallbacks.cleanupTransport = ar6000_cleanup_hci;\r\nstatus = ar6000_register_hci_transport(&hciTransCallbacks);\r\nif (status)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nhcibridge_cleanup_module(void)\r\n{\r\n}
