static const struct clksel *_get_clksel_by_parent(struct clk *clk,\r\nstruct clk *src_clk)\r\n{\r\nconst struct clksel *clks;\r\nfor (clks = clk->clksel; clks->parent; clks++)\r\nif (clks->parent == src_clk)\r\nbreak;\r\nif (!clks->parent) {\r\nWARN(1, "clock: Could not find parent clock %s in clksel array "\r\n"of clock %s\n", src_clk->name, clk->name);\r\nreturn NULL;\r\n}\r\nreturn clks;\r\n}\r\nstatic u8 _get_div_and_fieldval(struct clk *src_clk, struct clk *clk,\r\nu32 *field_val)\r\n{\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr, *max_clkr = NULL;\r\nu8 max_div = 0;\r\nclks = _get_clksel_by_parent(clk, src_clk);\r\nif (!clks)\r\nreturn 0;\r\nfor (clkr = clks->rates; clkr->div; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->div > max_div) {\r\nmax_div = clkr->div;\r\nmax_clkr = clkr;\r\n}\r\n}\r\nif (max_div == 0) {\r\nWARN(1, "clock: Could not find divisor for clock %s parent %s"\r\n"\n", clk->name, src_clk->parent->name);\r\nreturn 0;\r\n}\r\n*field_val = max_clkr->val;\r\nreturn max_div;\r\n}\r\nstatic void _write_clksel_reg(struct clk *clk, u32 field_val)\r\n{\r\nu32 v;\r\nv = __raw_readl(clk->clksel_reg);\r\nv &= ~clk->clksel_mask;\r\nv |= field_val << __ffs(clk->clksel_mask);\r\n__raw_writel(v, clk->clksel_reg);\r\nv = __raw_readl(clk->clksel_reg);\r\n}\r\nstatic u32 _clksel_to_divisor(struct clk *clk, u32 field_val)\r\n{\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr;\r\nclks = _get_clksel_by_parent(clk, clk->parent);\r\nif (!clks)\r\nreturn 0;\r\nfor (clkr = clks->rates; clkr->div; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->val == field_val)\r\nbreak;\r\n}\r\nif (!clkr->div) {\r\nWARN(1, "clock: Could not find fieldval %d for clock %s parent "\r\n"%s\n", field_val, clk->name, clk->parent->name);\r\nreturn 0;\r\n}\r\nreturn clkr->div;\r\n}\r\nstatic u32 _divisor_to_clksel(struct clk *clk, u32 div)\r\n{\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr;\r\nWARN_ON(div == 0);\r\nclks = _get_clksel_by_parent(clk, clk->parent);\r\nif (!clks)\r\nreturn ~0;\r\nfor (clkr = clks->rates; clkr->div; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->div == div)\r\nbreak;\r\n}\r\nif (!clkr->div) {\r\npr_err("clock: Could not find divisor %d for clock %s parent "\r\n"%s\n", div, clk->name, clk->parent->name);\r\nreturn ~0;\r\n}\r\nreturn clkr->val;\r\n}\r\nstatic u32 _read_divisor(struct clk *clk)\r\n{\r\nu32 v;\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn 0;\r\nv = __raw_readl(clk->clksel_reg);\r\nv &= clk->clksel_mask;\r\nv >>= __ffs(clk->clksel_mask);\r\nreturn _clksel_to_divisor(clk, v);\r\n}\r\nu32 omap2_clksel_round_rate_div(struct clk *clk, unsigned long target_rate,\r\nu32 *new_div)\r\n{\r\nunsigned long test_rate;\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr;\r\nu32 last_div = 0;\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn ~0;\r\npr_debug("clock: clksel_round_rate_div: %s target_rate %ld\n",\r\nclk->name, target_rate);\r\n*new_div = 1;\r\nclks = _get_clksel_by_parent(clk, clk->parent);\r\nif (!clks)\r\nreturn ~0;\r\nfor (clkr = clks->rates; clkr->div; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->div <= last_div)\r\npr_err("clock: clksel_rate table not sorted "\r\n"for clock %s", clk->name);\r\nlast_div = clkr->div;\r\ntest_rate = clk->parent->rate / clkr->div;\r\nif (test_rate <= target_rate)\r\nbreak;\r\n}\r\nif (!clkr->div) {\r\npr_err("clock: Could not find divisor for target "\r\n"rate %ld for clock %s parent %s\n", target_rate,\r\nclk->name, clk->parent->name);\r\nreturn ~0;\r\n}\r\n*new_div = clkr->div;\r\npr_debug("clock: new_div = %d, new_rate = %ld\n", *new_div,\r\n(clk->parent->rate / clkr->div));\r\nreturn clk->parent->rate / clkr->div;\r\n}\r\nvoid omap2_init_clksel_parent(struct clk *clk)\r\n{\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr;\r\nu32 r, found = 0;\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn;\r\nr = __raw_readl(clk->clksel_reg) & clk->clksel_mask;\r\nr >>= __ffs(clk->clksel_mask);\r\nfor (clks = clk->clksel; clks->parent && !found; clks++) {\r\nfor (clkr = clks->rates; clkr->div && !found; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->val == r) {\r\nif (clk->parent != clks->parent) {\r\npr_debug("clock: inited %s parent "\r\n"to %s (was %s)\n",\r\nclk->name, clks->parent->name,\r\n((clk->parent) ?\r\nclk->parent->name : "NULL"));\r\nclk_reparent(clk, clks->parent);\r\n};\r\nfound = 1;\r\n}\r\n}\r\n}\r\nWARN(!found, "clock: %s: init parent: could not find regval %0x\n",\r\nclk->name, r);\r\nreturn;\r\n}\r\nunsigned long omap2_clksel_recalc(struct clk *clk)\r\n{\r\nunsigned long rate;\r\nu32 div = 0;\r\ndiv = _read_divisor(clk);\r\nif (div == 0)\r\nreturn clk->rate;\r\nrate = clk->parent->rate / div;\r\npr_debug("clock: %s: recalc'd rate is %ld (div %d)\n", clk->name,\r\nrate, div);\r\nreturn rate;\r\n}\r\nlong omap2_clksel_round_rate(struct clk *clk, unsigned long target_rate)\r\n{\r\nu32 new_div;\r\nreturn omap2_clksel_round_rate_div(clk, target_rate, &new_div);\r\n}\r\nint omap2_clksel_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 field_val, validrate, new_div = 0;\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn -EINVAL;\r\nvalidrate = omap2_clksel_round_rate_div(clk, rate, &new_div);\r\nif (validrate != rate)\r\nreturn -EINVAL;\r\nfield_val = _divisor_to_clksel(clk, new_div);\r\nif (field_val == ~0)\r\nreturn -EINVAL;\r\n_write_clksel_reg(clk, field_val);\r\nclk->rate = clk->parent->rate / new_div;\r\npr_debug("clock: %s: set rate to %ld\n", clk->name, clk->rate);\r\nreturn 0;\r\n}\r\nint omap2_clksel_set_parent(struct clk *clk, struct clk *new_parent)\r\n{\r\nu32 field_val = 0;\r\nu32 parent_div;\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn -EINVAL;\r\nparent_div = _get_div_and_fieldval(new_parent, clk, &field_val);\r\nif (!parent_div)\r\nreturn -EINVAL;\r\n_write_clksel_reg(clk, field_val);\r\nclk_reparent(clk, new_parent);\r\nclk->rate = new_parent->rate;\r\nif (parent_div > 0)\r\nclk->rate /= parent_div;\r\npr_debug("clock: %s: set parent to %s (new rate %ld)\n",\r\nclk->name, clk->parent->name, clk->rate);\r\nreturn 0;\r\n}
