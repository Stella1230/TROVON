static inline struct jz_nand *mtd_to_jz_nand(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd, struct jz_nand, mtd);\r\n}\r\nstatic void jz_nand_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned int ctrl)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nuint32_t reg;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nBUG_ON((ctrl & NAND_ALE) && (ctrl & NAND_CLE));\r\nif (ctrl & NAND_ALE)\r\nchip->IO_ADDR_W = nand->bank_base + JZ_NAND_MEM_ADDR_OFFSET;\r\nelse if (ctrl & NAND_CLE)\r\nchip->IO_ADDR_W = nand->bank_base + JZ_NAND_MEM_CMD_OFFSET;\r\nelse\r\nchip->IO_ADDR_W = nand->bank_base;\r\nreg = readl(nand->base + JZ_REG_NAND_CTRL);\r\nif (ctrl & NAND_NCE)\r\nreg |= JZ_NAND_CTRL_ASSERT_CHIP(0);\r\nelse\r\nreg &= ~JZ_NAND_CTRL_ASSERT_CHIP(0);\r\nwritel(reg, nand->base + JZ_REG_NAND_CTRL);\r\n}\r\nif (dat != NAND_CMD_NONE)\r\nwriteb(dat, chip->IO_ADDR_W);\r\n}\r\nstatic int jz_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nreturn gpio_get_value_cansleep(nand->pdata->busy_gpio);\r\n}\r\nstatic void jz_nand_hwctl(struct mtd_info *mtd, int mode)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nuint32_t reg;\r\nwritel(0, nand->base + JZ_REG_NAND_IRQ_STAT);\r\nreg = readl(nand->base + JZ_REG_NAND_ECC_CTRL);\r\nreg |= JZ_NAND_ECC_CTRL_RESET;\r\nreg |= JZ_NAND_ECC_CTRL_ENABLE;\r\nreg |= JZ_NAND_ECC_CTRL_RS;\r\nswitch (mode) {\r\ncase NAND_ECC_READ:\r\nreg &= ~JZ_NAND_ECC_CTRL_ENCODING;\r\nnand->is_reading = true;\r\nbreak;\r\ncase NAND_ECC_WRITE:\r\nreg |= JZ_NAND_ECC_CTRL_ENCODING;\r\nnand->is_reading = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(reg, nand->base + JZ_REG_NAND_ECC_CTRL);\r\n}\r\nstatic int jz_nand_calculate_ecc_rs(struct mtd_info *mtd, const uint8_t *dat,\r\nuint8_t *ecc_code)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nuint32_t reg, status;\r\nint i;\r\nunsigned int timeout = 1000;\r\nstatic uint8_t empty_block_ecc[] = {0xcd, 0x9d, 0x90, 0x58, 0xf4,\r\n0x8b, 0xff, 0xb7, 0x6f};\r\nif (nand->is_reading)\r\nreturn 0;\r\ndo {\r\nstatus = readl(nand->base + JZ_REG_NAND_IRQ_STAT);\r\n} while (!(status & JZ_NAND_STATUS_ENC_FINISH) && --timeout);\r\nif (timeout == 0)\r\nreturn -1;\r\nreg = readl(nand->base + JZ_REG_NAND_ECC_CTRL);\r\nreg &= ~JZ_NAND_ECC_CTRL_ENABLE;\r\nwritel(reg, nand->base + JZ_REG_NAND_ECC_CTRL);\r\nfor (i = 0; i < 9; ++i)\r\necc_code[i] = readb(nand->base + JZ_REG_NAND_PAR0 + i);\r\nif (memcmp(ecc_code, empty_block_ecc, 9) == 0)\r\nmemset(ecc_code, 0xff, 9);\r\nreturn 0;\r\n}\r\nstatic void jz_nand_correct_data(uint8_t *dat, int index, int mask)\r\n{\r\nint offset = index & 0x7;\r\nuint16_t data;\r\nindex += (index >> 3);\r\ndata = dat[index];\r\ndata |= dat[index+1] << 8;\r\nmask ^= (data >> offset) & 0x1ff;\r\ndata &= ~(0x1ff << offset);\r\ndata |= (mask << offset);\r\ndat[index] = data & 0xff;\r\ndat[index+1] = (data >> 8) & 0xff;\r\n}\r\nstatic int jz_nand_correct_ecc_rs(struct mtd_info *mtd, uint8_t *dat,\r\nuint8_t *read_ecc, uint8_t *calc_ecc)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nint i, error_count, index;\r\nuint32_t reg, status, error;\r\nuint32_t t;\r\nunsigned int timeout = 1000;\r\nt = read_ecc[0];\r\nif (t == 0xff) {\r\nfor (i = 1; i < 9; ++i)\r\nt &= read_ecc[i];\r\nt &= dat[0];\r\nt &= dat[nand->chip.ecc.size / 2];\r\nt &= dat[nand->chip.ecc.size - 1];\r\nif (t == 0xff) {\r\nfor (i = 1; i < nand->chip.ecc.size - 1; ++i)\r\nt &= dat[i];\r\nif (t == 0xff)\r\nreturn 0;\r\n}\r\n}\r\nfor (i = 0; i < 9; ++i)\r\nwriteb(read_ecc[i], nand->base + JZ_REG_NAND_PAR0 + i);\r\nreg = readl(nand->base + JZ_REG_NAND_ECC_CTRL);\r\nreg |= JZ_NAND_ECC_CTRL_PAR_READY;\r\nwritel(reg, nand->base + JZ_REG_NAND_ECC_CTRL);\r\ndo {\r\nstatus = readl(nand->base + JZ_REG_NAND_IRQ_STAT);\r\n} while (!(status & JZ_NAND_STATUS_DEC_FINISH) && --timeout);\r\nif (timeout == 0)\r\nreturn -1;\r\nreg = readl(nand->base + JZ_REG_NAND_ECC_CTRL);\r\nreg &= ~JZ_NAND_ECC_CTRL_ENABLE;\r\nwritel(reg, nand->base + JZ_REG_NAND_ECC_CTRL);\r\nif (status & JZ_NAND_STATUS_ERROR) {\r\nif (status & JZ_NAND_STATUS_UNCOR_ERROR)\r\nreturn -1;\r\nerror_count = (status & JZ_NAND_STATUS_ERR_COUNT) >> 29;\r\nfor (i = 0; i < error_count; ++i) {\r\nerror = readl(nand->base + JZ_REG_NAND_ERR(i));\r\nindex = ((error >> 16) & 0x1ff) - 1;\r\nif (index >= 0 && index < 512)\r\njz_nand_correct_data(dat, index, error & 0x1ff);\r\n}\r\nreturn error_count;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jz_nand_ioremap_resource(struct platform_device *pdev,\r\nconst char *name, struct resource **res, void __iomem **base)\r\n{\r\nint ret;\r\n*res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\r\nif (!*res) {\r\ndev_err(&pdev->dev, "Failed to get platform %s memory\n", name);\r\nret = -ENXIO;\r\ngoto err;\r\n}\r\n*res = request_mem_region((*res)->start, resource_size(*res),\r\npdev->name);\r\nif (!*res) {\r\ndev_err(&pdev->dev, "Failed to request %s memory region\n", name);\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\n*base = ioremap((*res)->start, resource_size(*res));\r\nif (!*base) {\r\ndev_err(&pdev->dev, "Failed to ioremap %s memory region\n", name);\r\nret = -EBUSY;\r\ngoto err_release_mem;\r\n}\r\nreturn 0;\r\nerr_release_mem:\r\nrelease_mem_region((*res)->start, resource_size(*res));\r\nerr:\r\n*res = NULL;\r\n*base = NULL;\r\nreturn ret;\r\n}\r\nstatic int __devinit jz_nand_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct jz_nand *nand;\r\nstruct nand_chip *chip;\r\nstruct mtd_info *mtd;\r\nstruct jz_nand_platform_data *pdata = pdev->dev.platform_data;\r\nstruct mtd_partition *partition_info;\r\nint num_partitions = 0;\r\nnand = kzalloc(sizeof(*nand), GFP_KERNEL);\r\nif (!nand) {\r\ndev_err(&pdev->dev, "Failed to allocate device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nret = jz_nand_ioremap_resource(pdev, "mmio", &nand->mem, &nand->base);\r\nif (ret)\r\ngoto err_free;\r\nret = jz_nand_ioremap_resource(pdev, "bank", &nand->bank_mem,\r\n&nand->bank_base);\r\nif (ret)\r\ngoto err_iounmap_mmio;\r\nif (pdata && gpio_is_valid(pdata->busy_gpio)) {\r\nret = gpio_request(pdata->busy_gpio, "NAND busy pin");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to request busy gpio %d: %d\n",\r\npdata->busy_gpio, ret);\r\ngoto err_iounmap_mem;\r\n}\r\n}\r\nmtd = &nand->mtd;\r\nchip = &nand->chip;\r\nmtd->priv = chip;\r\nmtd->owner = THIS_MODULE;\r\nmtd->name = "jz4740-nand";\r\nchip->ecc.hwctl = jz_nand_hwctl;\r\nchip->ecc.calculate = jz_nand_calculate_ecc_rs;\r\nchip->ecc.correct = jz_nand_correct_ecc_rs;\r\nchip->ecc.mode = NAND_ECC_HW_OOB_FIRST;\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 9;\r\nif (pdata)\r\nchip->ecc.layout = pdata->ecc_layout;\r\nchip->chip_delay = 50;\r\nchip->cmd_ctrl = jz_nand_cmd_ctrl;\r\nif (pdata && gpio_is_valid(pdata->busy_gpio))\r\nchip->dev_ready = jz_nand_dev_ready;\r\nchip->IO_ADDR_R = nand->bank_base;\r\nchip->IO_ADDR_W = nand->bank_base;\r\nnand->pdata = pdata;\r\nplatform_set_drvdata(pdev, nand);\r\nwritel(JZ_NAND_CTRL_ENABLE_CHIP(0), nand->base + JZ_REG_NAND_CTRL);\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to scan nand\n");\r\ngoto err_gpio_free;\r\n}\r\nif (pdata && pdata->ident_callback) {\r\npdata->ident_callback(pdev, chip, &pdata->partitions,\r\n&pdata->num_partitions);\r\n}\r\nret = nand_scan_tail(mtd);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to scan nand\n");\r\ngoto err_gpio_free;\r\n}\r\n#ifdef CONFIG_MTD_CMDLINE_PARTS\r\nnum_partitions = parse_mtd_partitions(mtd, part_probes,\r\n&partition_info, 0);\r\n#endif\r\nif (num_partitions <= 0 && pdata) {\r\nnum_partitions = pdata->num_partitions;\r\npartition_info = pdata->partitions;\r\n}\r\nret = mtd_device_register(mtd, partition_info, num_partitions);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to add mtd device\n");\r\ngoto err_nand_release;\r\n}\r\ndev_info(&pdev->dev, "Successfully registered JZ4740 NAND driver\n");\r\nreturn 0;\r\nerr_nand_release:\r\nnand_release(&nand->mtd);\r\nerr_gpio_free:\r\nplatform_set_drvdata(pdev, NULL);\r\ngpio_free(pdata->busy_gpio);\r\nerr_iounmap_mem:\r\niounmap(nand->bank_base);\r\nerr_iounmap_mmio:\r\niounmap(nand->base);\r\nerr_free:\r\nkfree(nand);\r\nreturn ret;\r\n}\r\nstatic int __devexit jz_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct jz_nand *nand = platform_get_drvdata(pdev);\r\nnand_release(&nand->mtd);\r\nwritel(0, nand->base + JZ_REG_NAND_CTRL);\r\niounmap(nand->bank_base);\r\nrelease_mem_region(nand->bank_mem->start, resource_size(nand->bank_mem));\r\niounmap(nand->base);\r\nrelease_mem_region(nand->mem->start, resource_size(nand->mem));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(nand);\r\nreturn 0;\r\n}\r\nstatic int __init jz_nand_init(void)\r\n{\r\nreturn platform_driver_register(&jz_nand_driver);\r\n}\r\nstatic void __exit jz_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&jz_nand_driver);\r\n}
