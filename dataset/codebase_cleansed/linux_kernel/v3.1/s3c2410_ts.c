static inline bool get_down(unsigned long data0, unsigned long data1)\r\n{\r\nreturn (!(data0 & S3C2410_ADCDAT0_UPDOWN) &&\r\n!(data1 & S3C2410_ADCDAT0_UPDOWN));\r\n}\r\nstatic void touch_timer_fire(unsigned long data)\r\n{\r\nunsigned long data0;\r\nunsigned long data1;\r\nbool down;\r\ndata0 = readl(ts.io + S3C2410_ADCDAT0);\r\ndata1 = readl(ts.io + S3C2410_ADCDAT1);\r\ndown = get_down(data0, data1);\r\nif (down) {\r\nif (ts.count == (1 << ts.shift)) {\r\nts.xp >>= ts.shift;\r\nts.yp >>= ts.shift;\r\ndev_dbg(ts.dev, "%s: X=%lu, Y=%lu, count=%d\n",\r\n__func__, ts.xp, ts.yp, ts.count);\r\ninput_report_abs(ts.input, ABS_X, ts.xp);\r\ninput_report_abs(ts.input, ABS_Y, ts.yp);\r\ninput_report_key(ts.input, BTN_TOUCH, 1);\r\ninput_sync(ts.input);\r\nts.xp = 0;\r\nts.yp = 0;\r\nts.count = 0;\r\n}\r\ns3c_adc_start(ts.client, 0, 1 << ts.shift);\r\n} else {\r\nts.xp = 0;\r\nts.yp = 0;\r\nts.count = 0;\r\ninput_report_key(ts.input, BTN_TOUCH, 0);\r\ninput_sync(ts.input);\r\nwritel(WAIT4INT | INT_DOWN, ts.io + S3C2410_ADCTSC);\r\n}\r\n}\r\nstatic irqreturn_t stylus_irq(int irq, void *dev_id)\r\n{\r\nunsigned long data0;\r\nunsigned long data1;\r\nbool down;\r\ndata0 = readl(ts.io + S3C2410_ADCDAT0);\r\ndata1 = readl(ts.io + S3C2410_ADCDAT1);\r\ndown = get_down(data0, data1);\r\nif (down)\r\ns3c_adc_start(ts.client, 0, 1 << ts.shift);\r\nelse\r\ndev_dbg(ts.dev, "%s: count=%d\n", __func__, ts.count);\r\nif (ts.features & FEAT_PEN_IRQ) {\r\nwritel(0x0, ts.io + S3C64XX_ADCCLRINTPNDNUP);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void s3c24xx_ts_conversion(struct s3c_adc_client *client,\r\nunsigned data0, unsigned data1,\r\nunsigned *left)\r\n{\r\ndev_dbg(ts.dev, "%s: %d,%d\n", __func__, data0, data1);\r\nts.xp += data0;\r\nts.yp += data1;\r\nts.count++;\r\n}\r\nstatic void s3c24xx_ts_select(struct s3c_adc_client *client, unsigned select)\r\n{\r\nif (select) {\r\nwritel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST,\r\nts.io + S3C2410_ADCTSC);\r\n} else {\r\nmod_timer(&touch_timer, jiffies+1);\r\nwritel(WAIT4INT | INT_UP, ts.io + S3C2410_ADCTSC);\r\n}\r\n}\r\nstatic int __devinit s3c2410ts_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c2410_ts_mach_info *info;\r\nstruct device *dev = &pdev->dev;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint ret = -EINVAL;\r\nmemset(&ts, 0, sizeof(struct s3c2410ts));\r\nts.dev = dev;\r\ninfo = pdev->dev.platform_data;\r\nif (!info) {\r\ndev_err(dev, "no platform data, cannot attach\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "initialising touchscreen\n");\r\nts.clock = clk_get(dev, "adc");\r\nif (IS_ERR(ts.clock)) {\r\ndev_err(dev, "cannot get adc clock source\n");\r\nreturn -ENOENT;\r\n}\r\nclk_enable(ts.clock);\r\ndev_dbg(dev, "got and enabled clocks\n");\r\nts.irq_tc = ret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "no resource for interrupt\n");\r\ngoto err_clk;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "no resource for registers\n");\r\nret = -ENOENT;\r\ngoto err_clk;\r\n}\r\nts.io = ioremap(res->start, resource_size(res));\r\nif (ts.io == NULL) {\r\ndev_err(dev, "cannot map registers\n");\r\nret = -ENOMEM;\r\ngoto err_clk;\r\n}\r\nif (info->cfg_gpio)\r\ninfo->cfg_gpio(to_platform_device(ts.dev));\r\nts.client = s3c_adc_register(pdev, s3c24xx_ts_select,\r\ns3c24xx_ts_conversion, 1);\r\nif (IS_ERR(ts.client)) {\r\ndev_err(dev, "failed to register adc client\n");\r\nret = PTR_ERR(ts.client);\r\ngoto err_iomap;\r\n}\r\nif ((info->delay & 0xffff) > 0)\r\nwritel(info->delay & 0xffff, ts.io + S3C2410_ADCDLY);\r\nwritel(WAIT4INT | INT_DOWN, ts.io + S3C2410_ADCTSC);\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\ndev_err(dev, "Unable to allocate the input device !!\n");\r\nret = -ENOMEM;\r\ngoto err_iomap;\r\n}\r\nts.input = input_dev;\r\nts.input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nts.input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(ts.input, ABS_X, 0, 0x3FF, 0, 0);\r\ninput_set_abs_params(ts.input, ABS_Y, 0, 0x3FF, 0, 0);\r\nts.input->name = "S3C24XX TouchScreen";\r\nts.input->id.bustype = BUS_HOST;\r\nts.input->id.vendor = 0xDEAD;\r\nts.input->id.product = 0xBEEF;\r\nts.input->id.version = 0x0102;\r\nts.shift = info->oversampling_shift;\r\nts.features = platform_get_device_id(pdev)->driver_data;\r\nret = request_irq(ts.irq_tc, stylus_irq, IRQF_DISABLED,\r\n"s3c2410_ts_pen", ts.input);\r\nif (ret) {\r\ndev_err(dev, "cannot get TC interrupt\n");\r\ngoto err_inputdev;\r\n}\r\ndev_info(dev, "driver attached, registering input device\n");\r\nret = input_register_device(ts.input);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register input device\n");\r\nret = -EIO;\r\ngoto err_tcirq;\r\n}\r\nreturn 0;\r\nerr_tcirq:\r\nfree_irq(ts.irq_tc, ts.input);\r\nerr_inputdev:\r\ninput_free_device(ts.input);\r\nerr_iomap:\r\niounmap(ts.io);\r\nerr_clk:\r\ndel_timer_sync(&touch_timer);\r\nclk_put(ts.clock);\r\nreturn ret;\r\n}\r\nstatic int __devexit s3c2410ts_remove(struct platform_device *pdev)\r\n{\r\nfree_irq(ts.irq_tc, ts.input);\r\ndel_timer_sync(&touch_timer);\r\nclk_disable(ts.clock);\r\nclk_put(ts.clock);\r\ninput_unregister_device(ts.input);\r\niounmap(ts.io);\r\nreturn 0;\r\n}\r\nstatic int s3c2410ts_suspend(struct device *dev)\r\n{\r\nwritel(TSC_SLEEP, ts.io + S3C2410_ADCTSC);\r\ndisable_irq(ts.irq_tc);\r\nclk_disable(ts.clock);\r\nreturn 0;\r\n}\r\nstatic int s3c2410ts_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s3c2410_ts_mach_info *info = pdev->dev.platform_data;\r\nclk_enable(ts.clock);\r\nenable_irq(ts.irq_tc);\r\nif ((info->delay & 0xffff) > 0)\r\nwritel(info->delay & 0xffff, ts.io + S3C2410_ADCDLY);\r\nwritel(WAIT4INT | INT_DOWN, ts.io + S3C2410_ADCTSC);\r\nreturn 0;\r\n}\r\nstatic int __init s3c2410ts_init(void)\r\n{\r\nreturn platform_driver_register(&s3c_ts_driver);\r\n}\r\nstatic void __exit s3c2410ts_exit(void)\r\n{\r\nplatform_driver_unregister(&s3c_ts_driver);\r\n}
