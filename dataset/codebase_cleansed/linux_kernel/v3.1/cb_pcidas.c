static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)\r\n{\r\nreturn (range & 0x3) << (8 + 2 * (channel & 0x1));\r\n}\r\nstatic inline unsigned int DAC_RANGE_MASK(unsigned int channel)\r\n{\r\nreturn 0x3 << (8 + 2 * (channel & 0x1));\r\n}\r\nstatic inline unsigned int DAC_CHAN_EN(unsigned int channel)\r\n{\r\nreturn 1 << (5 + (channel & 0x1));\r\n}\r\nstatic inline unsigned int DAC_DATA_REG(unsigned int channel)\r\n{\r\nreturn 2 * (channel & 0x1);\r\n}\r\nstatic inline unsigned int cal_enable_bits(struct comedi_device *dev)\r\n{\r\nreturn CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);\r\n}\r\nstatic int cb_pcidas_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nstruct pci_dev *pcidev = NULL;\r\nint index;\r\nint i;\r\nprintk("comedi%d: cb_pcidas: ", dev->minor);\r\nif (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)\r\nreturn -ENOMEM;\r\nprintk("\n");\r\nfor_each_pci_dev(pcidev) {\r\nif (pcidev->vendor != PCI_VENDOR_ID_CB)\r\ncontinue;\r\nfor (index = 0; index < ARRAY_SIZE(cb_pcidas_boards); index++) {\r\nif (cb_pcidas_boards[index].device_id != pcidev->device)\r\ncontinue;\r\nif (it->options[0] || it->options[1]) {\r\nif (pcidev->bus->number != it->options[0] ||\r\nPCI_SLOT(pcidev->devfn) != it->options[1]) {\r\ncontinue;\r\n}\r\n}\r\ndevpriv->pci_dev = pcidev;\r\ndev->board_ptr = cb_pcidas_boards + index;\r\ngoto found;\r\n}\r\n}\r\nprintk("No supported ComputerBoards/MeasurementComputing card found on "\r\n"requested position\n");\r\nreturn -EIO;\r\nfound:\r\nprintk("Found %s on bus %i, slot %i\n", cb_pcidas_boards[index].name,\r\npcidev->bus->number, PCI_SLOT(pcidev->devfn));\r\nif (comedi_pci_enable(pcidev, "cb_pcidas")) {\r\nprintk(" Failed to enable PCI device and request regions\n");\r\nreturn -EIO;\r\n}\r\ndevpriv->s5933_config =\r\npci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);\r\ndevpriv->control_status =\r\npci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);\r\ndevpriv->adc_fifo =\r\npci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);\r\ndevpriv->pacer_counter_dio =\r\npci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);\r\nif (thisboard->ao_nchan) {\r\ndevpriv->ao_registers =\r\npci_resource_start(devpriv->pci_dev, AO_BADRINDEX);\r\n}\r\noutl(INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\nif (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,\r\nIRQF_SHARED, "cb_pcidas", dev)) {\r\nprintk(" unable to allocate irq %d\n", devpriv->pci_dev->irq);\r\nreturn -EINVAL;\r\n}\r\ndev->irq = devpriv->pci_dev->irq;\r\ndev->board_name = thisboard->name;\r\nif (alloc_subdevices(dev, 7) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;\r\ns->n_chan = thisboard->ai_se_chans;\r\ns->len_chanlist = thisboard->ai_se_chans;\r\ns->maxdata = (1 << thisboard->ai_bits) - 1;\r\ns->range_table = thisboard->ranges;\r\ns->insn_read = cb_pcidas_ai_rinsn;\r\ns->insn_config = ai_config_insn;\r\ns->do_cmd = cb_pcidas_ai_cmd;\r\ns->do_cmdtest = cb_pcidas_ai_cmdtest;\r\ns->cancel = cb_pcidas_cancel;\r\ns = dev->subdevices + 1;\r\nif (thisboard->ao_nchan) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = thisboard->ao_nchan;\r\ns->maxdata = (1 << thisboard->ai_bits) - 1;\r\ns->range_table = &cb_pcidas_ao_ranges;\r\ns->insn_read = cb_pcidas_ao_readback_insn;\r\nif (thisboard->has_ao_fifo) {\r\ndev->write_subdev = s;\r\ns->subdev_flags |= SDF_CMD_WRITE;\r\ns->insn_write = cb_pcidas_ao_fifo_winsn;\r\ns->do_cmdtest = cb_pcidas_ao_cmdtest;\r\ns->do_cmd = cb_pcidas_ao_cmd;\r\ns->cancel = cb_pcidas_ao_cancel;\r\n} else {\r\ns->insn_write = cb_pcidas_ao_nofifo_winsn;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 2;\r\nsubdev_8255_init(dev, s, NULL, devpriv->pacer_counter_dio + DIO_8255);\r\ns = dev->subdevices + 3;\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_INTERNAL;\r\ns->n_chan = 256;\r\ns->maxdata = 0xff;\r\ns->insn_read = eeprom_read_insn;\r\ns = dev->subdevices + 4;\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = NUM_CHANNELS_8800;\r\ns->maxdata = 0xff;\r\ns->insn_read = caldac_read_insn;\r\ns->insn_write = caldac_write_insn;\r\nfor (i = 0; i < s->n_chan; i++)\r\ncaldac_8800_write(dev, i, s->maxdata / 2);\r\ns = dev->subdevices + 5;\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\nif (thisboard->trimpot == AD7376) {\r\ns->n_chan = NUM_CHANNELS_7376;\r\ns->maxdata = 0x7f;\r\n} else {\r\ns->n_chan = NUM_CHANNELS_8402;\r\ns->maxdata = 0xff;\r\n}\r\ns->insn_read = trimpot_read_insn;\r\ns->insn_write = trimpot_write_insn;\r\nfor (i = 0; i < s->n_chan; i++)\r\ncb_pcidas_trimpot_write(dev, i, s->maxdata / 2);\r\ns = dev->subdevices + 6;\r\nif (thisboard->has_dac08) {\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = NUM_CHANNELS_DAC08;\r\ns->insn_read = dac08_read_insn;\r\ns->insn_write = dac08_write_insn;\r\ns->maxdata = 0xff;\r\ndac08_write(dev, s->maxdata / 2);\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\ninl(devpriv->s5933_config + AMCC_OP_REG_IMB4);\r\ndevpriv->s5933_intcsr_bits =\r\nINTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |\r\nINTCSR_INBOX_FULL_INT;\r\noutl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\nreturn 1;\r\n}\r\nstatic int cb_pcidas_detach(struct comedi_device *dev)\r\n{\r\nprintk("comedi%d: cb_pcidas: remove\n", dev->minor);\r\nif (devpriv) {\r\nif (devpriv->s5933_config) {\r\noutl(INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\n#ifdef CB_PCIDAS_DEBUG\r\nprintk("detaching, incsr is 0x%x\n",\r\ninl(devpriv->s5933_config + AMCC_OP_REG_INTCSR));\r\n#endif\r\n}\r\n}\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->subdevices)\r\nsubdev_8255_cleanup(dev, dev->subdevices + 2);\r\nif (devpriv && devpriv->pci_dev) {\r\nif (devpriv->s5933_config)\r\ncomedi_pci_disable(devpriv->pci_dev);\r\npci_dev_put(devpriv->pci_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n, i;\r\nunsigned int bits;\r\nstatic const int timeout = 10000;\r\nint channel;\r\nif (insn->chanspec & CR_ALT_SOURCE) {\r\noutw(cal_enable_bits(dev),\r\ndevpriv->control_status + CALIBRATION_REG);\r\nchannel = 0;\r\n} else {\r\noutw(0, devpriv->control_status + CALIBRATION_REG);\r\nchannel = CR_CHAN(insn->chanspec);\r\n}\r\nbits = BEGIN_SCAN(channel) |\r\nEND_SCAN(channel) | GAIN_BITS(CR_RANGE(insn->chanspec));\r\nif (CR_RANGE(insn->chanspec) & IS_UNIPOLAR)\r\nbits |= UNIP;\r\nif (CR_AREF(insn->chanspec) != AREF_DIFF)\r\nbits |= SE;\r\noutw(bits, devpriv->control_status + ADCMUX_CONT);\r\noutw(0, devpriv->adc_fifo + ADCFIFOCLR);\r\nfor (n = 0; n < insn->n; n++) {\r\noutw(0, devpriv->adc_fifo + ADCDATA);\r\nfor (i = 0; i < timeout; i++) {\r\nif (inw(devpriv->control_status + ADCMUX_CONT) & EOC)\r\nbreak;\r\n}\r\nif (i == timeout)\r\nreturn -ETIMEDOUT;\r\ndata[n] = inw(devpriv->adc_fifo + ADCDATA);\r\n}\r\nreturn n;\r\n}\r\nstatic int ai_config_calibration_source(struct comedi_device *dev,\r\nunsigned int *data)\r\n{\r\nstatic const int num_calibration_sources = 8;\r\nunsigned int source = data[1];\r\nif (source >= num_calibration_sources) {\r\nprintk("invalid calibration source: %i\n", source);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->calibration_source = source;\r\nreturn 2;\r\n}\r\nstatic int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint id = data[0];\r\nswitch (id) {\r\ncase INSN_CONFIG_ALT_SOURCE:\r\nreturn ai_config_calibration_source(dev, data);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint channel;\r\nunsigned long flags;\r\nchannel = CR_CHAN(insn->chanspec);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ao_control_bits &=\r\n~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);\r\ndevpriv->ao_control_bits |=\r\nDACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->ao_value[channel] = data[0];\r\noutw(data[0], devpriv->ao_registers + DAC_DATA_REG(channel));\r\nreturn 1;\r\n}\r\nstatic int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint channel;\r\nunsigned long flags;\r\noutw(0, devpriv->ao_registers + DACFIFOCLR);\r\nchannel = CR_CHAN(insn->chanspec);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->ao_control_bits &=\r\n~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &\r\n~DAC_PACER_MASK;\r\ndevpriv->ao_control_bits |=\r\nDACEN | DAC_RANGE(channel,\r\nCR_RANGE(insn->\r\nchanspec)) | DAC_CHAN_EN(channel) |\r\nDAC_START;\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->ao_value[channel] = data[0];\r\noutw(data[0], devpriv->ao_registers + DACDATA);\r\nreturn 1;\r\n}\r\nstatic int cb_pcidas_ao_readback_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int eeprom_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nuint8_t nvram_data;\r\nint retval;\r\nretval = nvram_read(dev, CR_CHAN(insn->chanspec), &nvram_data);\r\nif (retval < 0)\r\nreturn retval;\r\ndata[0] = nvram_data;\r\nreturn 1;\r\n}\r\nstatic int caldac_write_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst unsigned int channel = CR_CHAN(insn->chanspec);\r\nreturn caldac_8800_write(dev, channel, data[0]);\r\n}\r\nstatic int caldac_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int dac08_write(struct comedi_device *dev, unsigned int value)\r\n{\r\nif (devpriv->dac08_value == value)\r\nreturn 1;\r\ndevpriv->dac08_value = value;\r\noutw(cal_enable_bits(dev) | (value & 0xff),\r\ndevpriv->control_status + CALIBRATION_REG);\r\nudelay(1);\r\noutw(cal_enable_bits(dev) | SELECT_DAC08_BIT | (value & 0xff),\r\ndevpriv->control_status + CALIBRATION_REG);\r\nudelay(1);\r\noutw(cal_enable_bits(dev) | (value & 0xff),\r\ndevpriv->control_status + CALIBRATION_REG);\r\nudelay(1);\r\nreturn 1;\r\n}\r\nstatic int dac08_write_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn dac08_write(dev, data[0]);\r\n}\r\nstatic int dac08_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[0] = devpriv->dac08_value;\r\nreturn 1;\r\n}\r\nstatic int cb_pcidas_trimpot_write(struct comedi_device *dev,\r\nunsigned int channel, unsigned int value)\r\n{\r\nif (devpriv->trimpot_value[channel] == value)\r\nreturn 1;\r\ndevpriv->trimpot_value[channel] = value;\r\nswitch (thisboard->trimpot) {\r\ncase AD7376:\r\ntrimpot_7376_write(dev, value);\r\nbreak;\r\ncase AD8402:\r\ntrimpot_8402_write(dev, channel, value);\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "driver bug?");\r\nreturn -1;\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int trimpot_write_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int channel = CR_CHAN(insn->chanspec);\r\nreturn cb_pcidas_trimpot_write(dev, channel, data[0]);\r\n}\r\nstatic int trimpot_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int channel = CR_CHAN(insn->chanspec);\r\ndata[0] = devpriv->trimpot_value[channel];\r\nreturn 1;\r\n}\r\nstatic int cb_pcidas_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nint i, gain, start_chan;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER | TRIG_NOW | TRIG_EXT;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER &&\r\ncmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)\r\nerr++;\r\nif (cmd->start_src == TRIG_EXT &&\r\n(cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT))\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_EXT:\r\nif ((cmd->start_arg\r\n& (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {\r\ncmd->start_arg &=\r\n~(CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));\r\nerr++;\r\n}\r\nif (!thisboard->has_ai_trig_invert &&\r\n(cmd->start_arg & CR_INVERT)) {\r\ncmd->start_arg &= (CR_FLAGS_MASK & ~CR_INVERT);\r\nerr++;\r\n}\r\nbreak;\r\ndefault:\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg <\r\nthisboard->ai_speed * cmd->chanlist_len) {\r\ncmd->scan_begin_arg =\r\nthisboard->ai_speed * cmd->chanlist_len;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < thisboard->ai_speed) {\r\ncmd->convert_arg = thisboard->ai_speed;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_NONE) {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE,\r\n&(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd->scan_begin_arg),\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE,\r\n&(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd->convert_arg),\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\ngain = CR_RANGE(cmd->chanlist[0]);\r\nstart_chan = CR_CHAN(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) !=\r\n(start_chan + i) % s->n_chan) {\r\ncomedi_error(dev,\r\n"entries in chanlist must be consecutive channels, counting upwards\n");\r\nerr++;\r\n}\r\nif (CR_RANGE(cmd->chanlist[i]) != gain) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all have the same gain\n");\r\nerr++;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int bits;\r\nunsigned long flags;\r\noutw(0, devpriv->control_status + CALIBRATION_REG);\r\noutw(0, devpriv->control_status + TRIG_CONTSTAT);\r\noutw(0, devpriv->adc_fifo + ADCFIFOCLR);\r\nbits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |\r\nEND_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |\r\nGAIN_BITS(CR_RANGE(cmd->chanlist[0]));\r\nif (CR_RANGE(cmd->chanlist[0]) & IS_UNIPOLAR)\r\nbits |= UNIP;\r\nif (CR_AREF(cmd->chanlist[0]) != AREF_DIFF)\r\nbits |= SE;\r\nif (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT)\r\nbits |= PACER_EXT_RISE;\r\nelse\r\nbits |= PACER_INT;\r\noutw(bits, devpriv->control_status + ADCMUX_CONT);\r\n#ifdef CB_PCIDAS_DEBUG\r\nprintk("comedi: sent 0x%x to adcmux control\n", bits);\r\n#endif\r\nif (cmd->convert_src == TRIG_TIMER)\r\ncb_pcidas_load_counters(dev, &cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nelse if (cmd->scan_begin_src == TRIG_TIMER)\r\ncb_pcidas_load_counters(dev, &cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->count = cmd->chanlist_len * cmd->stop_arg;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_fifo_bits |= INTE;\r\ndevpriv->adc_fifo_bits &= ~INT_MASK;\r\nif (cmd->flags & TRIG_WAKE_EOS) {\r\nif (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)\r\ndevpriv->adc_fifo_bits |= INT_EOS;\r\nelse\r\ndevpriv->adc_fifo_bits |= INT_FNE;\r\n} else {\r\ndevpriv->adc_fifo_bits |= INT_FHF;\r\n}\r\n#ifdef CB_PCIDAS_DEBUG\r\nprintk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);\r\n#endif\r\noutw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nbits = 0;\r\nif (cmd->start_src == TRIG_NOW)\r\nbits |= SW_TRIGGER;\r\nelse if (cmd->start_src == TRIG_EXT) {\r\nbits |= EXT_TRIGGER | TGEN | XTRCL;\r\nif (thisboard->has_ai_trig_invert\r\n&& (cmd->start_arg & CR_INVERT))\r\nbits |= TGPOL;\r\nif (thisboard->has_ai_trig_gated && (cmd->start_arg & CR_EDGE))\r\nbits |= TGSEL;\r\n} else {\r\ncomedi_error(dev, "bug!");\r\nreturn -1;\r\n}\r\nif (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)\r\nbits |= BURSTE;\r\noutw(bits, devpriv->control_status + TRIG_CONTSTAT);\r\n#ifdef CB_PCIDAS_DEBUG\r\nprintk("comedi: sent 0x%x to trig control\n", bits);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_INT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg < thisboard->ao_scan_speed) {\r\ncmd->scan_begin_arg = thisboard->ao_scan_speed;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_NONE) {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE,\r\n&(devpriv->ao_divisor1),\r\n&(devpriv->ao_divisor2),\r\n&(cmd->scan_begin_arg),\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 1) {\r\nif (CR_CHAN(cmd->chanlist[0]) != 0 ||\r\nCR_CHAN(cmd->chanlist[1]) != 1) {\r\ncomedi_error(dev,\r\n"channels must be ordered channel 0, channel 1 in chanlist\n");\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\ndevpriv->ao_control_bits |=\r\nDAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));\r\ndevpriv->ao_control_bits |= DAC_RANGE(CR_CHAN(cmd->chanlist[i]),\r\nCR_RANGE(cmd->\r\nchanlist[i]));\r\n}\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\noutw(0, devpriv->ao_registers + DACFIFOCLR);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE,\r\n&(devpriv->ao_divisor1),\r\n&(devpriv->ao_divisor2),\r\n&(cmd->scan_begin_arg),\r\ncmd->flags);\r\ni8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 1,\r\ndevpriv->ao_divisor1, 2);\r\ni8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 2,\r\ndevpriv->ao_divisor2, 2);\r\n}\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ndevpriv->ao_control_bits |= DAC_PACER_INT;\r\nbreak;\r\ncase TRIG_EXT:\r\ndevpriv->ao_control_bits |= DAC_PACER_EXT_RISE;\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ncomedi_error(dev, "error setting dac pacer source");\r\nreturn -1;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nasync->inttrig = cb_pcidas_ao_inttrig;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nunsigned int num_bytes, num_points = thisboard->fifo_size;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long flags;\r\nif (trig_num != 0)\r\nreturn -EINVAL;\r\nif (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < num_points)\r\nnum_points = devpriv->ao_count;\r\nnum_bytes = cfc_read_array_from_buffer(s, devpriv->ao_buffer,\r\nnum_points * sizeof(short));\r\nnum_points = num_bytes / sizeof(short);\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->ao_count -= num_points;\r\noutsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_fifo_bits |= DAEMIE | DAHFIE;\r\n#ifdef CB_PCIDAS_DEBUG\r\nprintk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);\r\n#endif\r\noutw(devpriv->adc_fifo_bits | DAEMI | DAHFI,\r\ndevpriv->control_status + INT_ADCFIFO);\r\ndevpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\n#ifdef CB_PCIDAS_DEBUG\r\nprintk("comedi: sent 0x%x to dac control\n", devpriv->ao_control_bits);\r\n#endif\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nasync->inttrig = NULL;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t cb_pcidas_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = (struct comedi_device *)d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async;\r\nint status, s5933_status;\r\nint half_fifo = thisboard->fifo_size / 2;\r\nunsigned int num_samples, i;\r\nstatic const int timeout = 10000;\r\nunsigned long flags;\r\nif (dev->attached == 0)\r\nreturn IRQ_NONE;\r\nasync = s->async;\r\nasync->events = 0;\r\ns5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\n#ifdef CB_PCIDAS_DEBUG\r\nprintk("intcsr 0x%x\n", s5933_status);\r\nprintk("mbef 0x%x\n", inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));\r\n#endif\r\nif ((INTCSR_INTR_ASSERTED & s5933_status) == 0)\r\nreturn IRQ_NONE;\r\ninl_p(devpriv->s5933_config + AMCC_OP_REG_IMB4);\r\noutl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,\r\ndevpriv->s5933_config + AMCC_OP_REG_INTCSR);\r\nstatus = inw(devpriv->control_status + INT_ADCFIFO);\r\n#ifdef CB_PCIDAS_DEBUG\r\nif ((status & (INT | EOAI | LADFUL | DAHFI | DAEMI)) == 0)\r\ncomedi_error(dev, "spurious interrupt");\r\n#endif\r\nif (status & (DAHFI | DAEMI))\r\nhandle_ao_interrupt(dev, status);\r\nif (status & ADHFI) {\r\nnum_samples = half_fifo;\r\nif (async->cmd.stop_src == TRIG_COUNT &&\r\nnum_samples > devpriv->count) {\r\nnum_samples = devpriv->count;\r\n}\r\ninsw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,\r\nnum_samples);\r\ncfc_write_array_to_buffer(s, devpriv->ai_buffer,\r\nnum_samples * sizeof(short));\r\ndevpriv->count -= num_samples;\r\nif (async->cmd.stop_src == TRIG_COUNT && devpriv->count == 0) {\r\nasync->events |= COMEDI_CB_EOA;\r\ncb_pcidas_cancel(dev, s);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | INT,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n} else if (status & (ADNEI | EOBI)) {\r\nfor (i = 0; i < timeout; i++) {\r\nif ((ADNE & inw(devpriv->control_status +\r\nINT_ADCFIFO)) == 0)\r\nbreak;\r\ncfc_write_to_buffer(s, inw(devpriv->adc_fifo));\r\nif (async->cmd.stop_src == TRIG_COUNT && --devpriv->count == 0) {\r\ncb_pcidas_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | INT,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n} else if (status & EOAI) {\r\ncomedi_error(dev,\r\n"bug! encountered end of acquisition interrupt?");\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | EOAI,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nif (status & LADFUL) {\r\ncomedi_error(dev, "fifo overflow");\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | LADFUL,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ncb_pcidas_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\n}\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)\r\n{\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int half_fifo = thisboard->fifo_size / 2;\r\nunsigned int num_points;\r\nunsigned long flags;\r\nasync->events = 0;\r\nif (status & DAEMI) {\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | DAEMI,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {\r\nif (cmd->stop_src == TRIG_NONE ||\r\n(cmd->stop_src == TRIG_COUNT\r\n&& devpriv->ao_count)) {\r\ncomedi_error(dev, "dac fifo underflow");\r\ncb_pcidas_ao_cancel(dev, s);\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n} else if (status & DAHFI) {\r\nunsigned int num_bytes;\r\nnum_points = half_fifo;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ndevpriv->ao_count < num_points)\r\nnum_points = devpriv->ao_count;\r\nnum_bytes =\r\ncfc_read_array_from_buffer(s, devpriv->ao_buffer,\r\nnum_points * sizeof(short));\r\nnum_points = num_bytes / sizeof(short);\r\nif (async->cmd.stop_src == TRIG_COUNT)\r\ndevpriv->ao_count -= num_points;\r\noutsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,\r\nnum_points);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutw(devpriv->adc_fifo_bits | DAHFI,\r\ndevpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\ncomedi_event(dev, s);\r\n}\r\nstatic int cb_pcidas_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_fifo_bits &= ~INTE & ~EOAIE;\r\noutw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\noutw(0, devpriv->control_status + TRIG_CONTSTAT);\r\noutw(0, devpriv->control_status + ADCMUX_CONT);\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;\r\noutw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);\r\ndevpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;\r\noutw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,\r\nint rounding_flags)\r\n{\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),\r\n&(devpriv->divisor2), ns,\r\nrounding_flags & TRIG_ROUND_MASK);\r\ni8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 1,\r\ndevpriv->divisor1, 2);\r\ni8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 2,\r\ndevpriv->divisor2, 2);\r\n}\r\nstatic void write_calibration_bitstream(struct comedi_device *dev,\r\nunsigned int register_bits,\r\nunsigned int bitstream,\r\nunsigned int bitstream_length)\r\n{\r\nstatic const int write_delay = 1;\r\nunsigned int bit;\r\nfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\r\nif (bitstream & bit)\r\nregister_bits |= SERIAL_DATA_IN_BIT;\r\nelse\r\nregister_bits &= ~SERIAL_DATA_IN_BIT;\r\nudelay(write_delay);\r\noutw(register_bits, devpriv->control_status + CALIBRATION_REG);\r\n}\r\n}\r\nstatic int caldac_8800_write(struct comedi_device *dev, unsigned int address,\r\nuint8_t value)\r\n{\r\nstatic const int num_caldac_channels = 8;\r\nstatic const int bitstream_length = 11;\r\nunsigned int bitstream = ((address & 0x7) << 8) | value;\r\nstatic const int caldac_8800_udelay = 1;\r\nif (address >= num_caldac_channels) {\r\ncomedi_error(dev, "illegal caldac channel");\r\nreturn -1;\r\n}\r\nif (value == devpriv->caldac_value[address])\r\nreturn 1;\r\ndevpriv->caldac_value[address] = value;\r\nwrite_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,\r\nbitstream_length);\r\nudelay(caldac_8800_udelay);\r\noutw(cal_enable_bits(dev) | SELECT_8800_BIT,\r\ndevpriv->control_status + CALIBRATION_REG);\r\nudelay(caldac_8800_udelay);\r\noutw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);\r\nreturn 1;\r\n}\r\nstatic int trimpot_7376_write(struct comedi_device *dev, uint8_t value)\r\n{\r\nstatic const int bitstream_length = 7;\r\nunsigned int bitstream = value & 0x7f;\r\nunsigned int register_bits;\r\nstatic const int ad7376_udelay = 1;\r\nregister_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;\r\nudelay(ad7376_udelay);\r\noutw(register_bits, devpriv->control_status + CALIBRATION_REG);\r\nwrite_calibration_bitstream(dev, register_bits, bitstream,\r\nbitstream_length);\r\nudelay(ad7376_udelay);\r\noutw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);\r\nreturn 0;\r\n}\r\nstatic int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,\r\nuint8_t value)\r\n{\r\nstatic const int bitstream_length = 10;\r\nunsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);\r\nunsigned int register_bits;\r\nstatic const int ad8402_udelay = 1;\r\nregister_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;\r\nudelay(ad8402_udelay);\r\noutw(register_bits, devpriv->control_status + CALIBRATION_REG);\r\nwrite_calibration_bitstream(dev, register_bits, bitstream,\r\nbitstream_length);\r\nudelay(ad8402_udelay);\r\noutw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);\r\nreturn 0;\r\n}\r\nstatic int wait_for_nvram_ready(unsigned long s5933_base_addr)\r\n{\r\nstatic const int timeout = 1000;\r\nunsigned int i;\r\nfor (i = 0; i < timeout; i++) {\r\nif ((inb(s5933_base_addr +\r\nAMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)\r\n== 0)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic int nvram_read(struct comedi_device *dev, unsigned int address,\r\nuint8_t *data)\r\n{\r\nunsigned long iobase = devpriv->s5933_config;\r\nif (wait_for_nvram_ready(iobase) < 0)\r\nreturn -ETIMEDOUT;\r\noutb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,\r\niobase + AMCC_OP_REG_MCSR_NVCMD);\r\noutb(address & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);\r\noutb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,\r\niobase + AMCC_OP_REG_MCSR_NVCMD);\r\noutb((address >> 8) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);\r\noutb(MCSR_NV_ENABLE | MCSR_NV_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);\r\nif (wait_for_nvram_ready(iobase) < 0)\r\nreturn -ETIMEDOUT;\r\n*data = inb(iobase + AMCC_OP_REG_MCSR_NVDATA);\r\nreturn 0;\r\n}\r\nstatic int __devinit driver_cb_pcidas_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_cb_pcidas.driver_name);\r\n}\r\nstatic void __devexit driver_cb_pcidas_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_cb_pcidas_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_cb_pcidas);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_cb_pcidas_pci_driver.name = (char *)driver_cb_pcidas.driver_name;\r\nreturn pci_register_driver(&driver_cb_pcidas_pci_driver);\r\n}\r\nstatic void __exit driver_cb_pcidas_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_cb_pcidas_pci_driver);\r\ncomedi_driver_unregister(&driver_cb_pcidas);\r\n}
