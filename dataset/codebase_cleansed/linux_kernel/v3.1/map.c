static inline int is_anon_memory(const char *filename)\r\n{\r\nreturn strcmp(filename, "//anon") == 0;\r\n}\r\nvoid map__init(struct map *self, enum map_type type,\r\nu64 start, u64 end, u64 pgoff, struct dso *dso)\r\n{\r\nself->type = type;\r\nself->start = start;\r\nself->end = end;\r\nself->pgoff = pgoff;\r\nself->dso = dso;\r\nself->map_ip = map__map_ip;\r\nself->unmap_ip = map__unmap_ip;\r\nRB_CLEAR_NODE(&self->rb_node);\r\nself->groups = NULL;\r\nself->referenced = false;\r\n}\r\nstruct map *map__new(struct list_head *dsos__list, u64 start, u64 len,\r\nu64 pgoff, u32 pid, char *filename,\r\nenum map_type type)\r\n{\r\nstruct map *self = malloc(sizeof(*self));\r\nif (self != NULL) {\r\nchar newfilename[PATH_MAX];\r\nstruct dso *dso;\r\nint anon;\r\nanon = is_anon_memory(filename);\r\nif (anon) {\r\nsnprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);\r\nfilename = newfilename;\r\n}\r\ndso = __dsos__findnew(dsos__list, filename);\r\nif (dso == NULL)\r\ngoto out_delete;\r\nmap__init(self, type, start, start + len, pgoff, dso);\r\nif (anon) {\r\nset_identity:\r\nself->map_ip = self->unmap_ip = identity__map_ip;\r\n} else if (strcmp(filename, "[vdso]") == 0) {\r\ndso__set_loaded(dso, self->type);\r\ngoto set_identity;\r\n}\r\n}\r\nreturn self;\r\nout_delete:\r\nfree(self);\r\nreturn NULL;\r\n}\r\nvoid map__delete(struct map *self)\r\n{\r\nfree(self);\r\n}\r\nvoid map__fixup_start(struct map *self)\r\n{\r\nstruct rb_root *symbols = &self->dso->symbols[self->type];\r\nstruct rb_node *nd = rb_first(symbols);\r\nif (nd != NULL) {\r\nstruct symbol *sym = rb_entry(nd, struct symbol, rb_node);\r\nself->start = sym->start;\r\n}\r\n}\r\nvoid map__fixup_end(struct map *self)\r\n{\r\nstruct rb_root *symbols = &self->dso->symbols[self->type];\r\nstruct rb_node *nd = rb_last(symbols);\r\nif (nd != NULL) {\r\nstruct symbol *sym = rb_entry(nd, struct symbol, rb_node);\r\nself->end = sym->end;\r\n}\r\n}\r\nint map__load(struct map *self, symbol_filter_t filter)\r\n{\r\nconst char *name = self->dso->long_name;\r\nint nr;\r\nif (dso__loaded(self->dso, self->type))\r\nreturn 0;\r\nnr = dso__load(self->dso, self, filter);\r\nif (nr < 0) {\r\nif (self->dso->has_build_id) {\r\nchar sbuild_id[BUILD_ID_SIZE * 2 + 1];\r\nbuild_id__sprintf(self->dso->build_id,\r\nsizeof(self->dso->build_id),\r\nsbuild_id);\r\npr_warning("%s with build id %s not found",\r\nname, sbuild_id);\r\n} else\r\npr_warning("Failed to open %s", name);\r\npr_warning(", continuing without symbols\n");\r\nreturn -1;\r\n} else if (nr == 0) {\r\nconst size_t len = strlen(name);\r\nconst size_t real_len = len - sizeof(DSO__DELETED);\r\nif (len > sizeof(DSO__DELETED) &&\r\nstrcmp(name + real_len + 1, DSO__DELETED) == 0) {\r\npr_warning("%.*s was updated, restart the long "\r\n"running apps that use it!\n",\r\n(int)real_len, name);\r\n} else {\r\npr_warning("no symbols found in %s, maybe install "\r\n"a debug package?\n", name);\r\n}\r\nreturn -1;\r\n}\r\nif (self->dso->kernel)\r\nmap__reloc_vmlinux(self);\r\nreturn 0;\r\n}\r\nstruct symbol *map__find_symbol(struct map *self, u64 addr,\r\nsymbol_filter_t filter)\r\n{\r\nif (map__load(self, filter) < 0)\r\nreturn NULL;\r\nreturn dso__find_symbol(self->dso, self->type, addr);\r\n}\r\nstruct symbol *map__find_symbol_by_name(struct map *self, const char *name,\r\nsymbol_filter_t filter)\r\n{\r\nif (map__load(self, filter) < 0)\r\nreturn NULL;\r\nif (!dso__sorted_by_name(self->dso, self->type))\r\ndso__sort_by_name(self->dso, self->type);\r\nreturn dso__find_symbol_by_name(self->dso, self->type, name);\r\n}\r\nstruct map *map__clone(struct map *self)\r\n{\r\nstruct map *map = malloc(sizeof(*self));\r\nif (!map)\r\nreturn NULL;\r\nmemcpy(map, self, sizeof(*self));\r\nreturn map;\r\n}\r\nint map__overlap(struct map *l, struct map *r)\r\n{\r\nif (l->start > r->start) {\r\nstruct map *t = l;\r\nl = r;\r\nr = t;\r\n}\r\nif (l->end > r->start)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nsize_t map__fprintf(struct map *self, FILE *fp)\r\n{\r\nreturn fprintf(fp, " %" PRIx64 "-%" PRIx64 " %" PRIx64 " %s\n",\r\nself->start, self->end, self->pgoff, self->dso->name);\r\n}\r\nu64 map__rip_2objdump(struct map *map, u64 rip)\r\n{\r\nu64 addr = map->dso->adjust_symbols ?\r\nmap->unmap_ip(map, rip) :\r\nrip;\r\nreturn addr;\r\n}\r\nu64 map__objdump_2ip(struct map *map, u64 addr)\r\n{\r\nu64 ip = map->dso->adjust_symbols ?\r\naddr :\r\nmap->unmap_ip(map, addr);\r\nreturn ip;\r\n}\r\nvoid map_groups__init(struct map_groups *self)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i) {\r\nself->maps[i] = RB_ROOT;\r\nINIT_LIST_HEAD(&self->removed_maps[i]);\r\n}\r\nself->machine = NULL;\r\n}\r\nstatic void maps__delete(struct rb_root *self)\r\n{\r\nstruct rb_node *next = rb_first(self);\r\nwhile (next) {\r\nstruct map *pos = rb_entry(next, struct map, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nrb_erase(&pos->rb_node, self);\r\nmap__delete(pos);\r\n}\r\n}\r\nstatic void maps__delete_removed(struct list_head *self)\r\n{\r\nstruct map *pos, *n;\r\nlist_for_each_entry_safe(pos, n, self, node) {\r\nlist_del(&pos->node);\r\nmap__delete(pos);\r\n}\r\n}\r\nvoid map_groups__exit(struct map_groups *self)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i) {\r\nmaps__delete(&self->maps[i]);\r\nmaps__delete_removed(&self->removed_maps[i]);\r\n}\r\n}\r\nvoid map_groups__flush(struct map_groups *self)\r\n{\r\nint type;\r\nfor (type = 0; type < MAP__NR_TYPES; type++) {\r\nstruct rb_root *root = &self->maps[type];\r\nstruct rb_node *next = rb_first(root);\r\nwhile (next) {\r\nstruct map *pos = rb_entry(next, struct map, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nrb_erase(&pos->rb_node, root);\r\nlist_add_tail(&pos->node, &self->removed_maps[pos->type]);\r\n}\r\n}\r\n}\r\nstruct symbol *map_groups__find_symbol(struct map_groups *self,\r\nenum map_type type, u64 addr,\r\nstruct map **mapp,\r\nsymbol_filter_t filter)\r\n{\r\nstruct map *map = map_groups__find(self, type, addr);\r\nif (map != NULL) {\r\nif (mapp != NULL)\r\n*mapp = map;\r\nreturn map__find_symbol(map, map->map_ip(map, addr), filter);\r\n}\r\nreturn NULL;\r\n}\r\nstruct symbol *map_groups__find_symbol_by_name(struct map_groups *self,\r\nenum map_type type,\r\nconst char *name,\r\nstruct map **mapp,\r\nsymbol_filter_t filter)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&self->maps[type]); nd; nd = rb_next(nd)) {\r\nstruct map *pos = rb_entry(nd, struct map, rb_node);\r\nstruct symbol *sym = map__find_symbol_by_name(pos, name, filter);\r\nif (sym == NULL)\r\ncontinue;\r\nif (mapp != NULL)\r\n*mapp = pos;\r\nreturn sym;\r\n}\r\nreturn NULL;\r\n}\r\nsize_t __map_groups__fprintf_maps(struct map_groups *self,\r\nenum map_type type, int verbose, FILE *fp)\r\n{\r\nsize_t printed = fprintf(fp, "%s:\n", map_type__name[type]);\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&self->maps[type]); nd; nd = rb_next(nd)) {\r\nstruct map *pos = rb_entry(nd, struct map, rb_node);\r\nprinted += fprintf(fp, "Map:");\r\nprinted += map__fprintf(pos, fp);\r\nif (verbose > 2) {\r\nprinted += dso__fprintf(pos->dso, type, fp);\r\nprinted += fprintf(fp, "--\n");\r\n}\r\n}\r\nreturn printed;\r\n}\r\nsize_t map_groups__fprintf_maps(struct map_groups *self, int verbose, FILE *fp)\r\n{\r\nsize_t printed = 0, i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nprinted += __map_groups__fprintf_maps(self, i, verbose, fp);\r\nreturn printed;\r\n}\r\nstatic size_t __map_groups__fprintf_removed_maps(struct map_groups *self,\r\nenum map_type type,\r\nint verbose, FILE *fp)\r\n{\r\nstruct map *pos;\r\nsize_t printed = 0;\r\nlist_for_each_entry(pos, &self->removed_maps[type], node) {\r\nprinted += fprintf(fp, "Map:");\r\nprinted += map__fprintf(pos, fp);\r\nif (verbose > 1) {\r\nprinted += dso__fprintf(pos->dso, type, fp);\r\nprinted += fprintf(fp, "--\n");\r\n}\r\n}\r\nreturn printed;\r\n}\r\nstatic size_t map_groups__fprintf_removed_maps(struct map_groups *self,\r\nint verbose, FILE *fp)\r\n{\r\nsize_t printed = 0, i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nprinted += __map_groups__fprintf_removed_maps(self, i, verbose, fp);\r\nreturn printed;\r\n}\r\nsize_t map_groups__fprintf(struct map_groups *self, int verbose, FILE *fp)\r\n{\r\nsize_t printed = map_groups__fprintf_maps(self, verbose, fp);\r\nprinted += fprintf(fp, "Removed maps:\n");\r\nreturn printed + map_groups__fprintf_removed_maps(self, verbose, fp);\r\n}\r\nint map_groups__fixup_overlappings(struct map_groups *self, struct map *map,\r\nint verbose, FILE *fp)\r\n{\r\nstruct rb_root *root = &self->maps[map->type];\r\nstruct rb_node *next = rb_first(root);\r\nint err = 0;\r\nwhile (next) {\r\nstruct map *pos = rb_entry(next, struct map, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nif (!map__overlap(pos, map))\r\ncontinue;\r\nif (verbose >= 2) {\r\nfputs("overlapping maps:\n", fp);\r\nmap__fprintf(map, fp);\r\nmap__fprintf(pos, fp);\r\n}\r\nrb_erase(&pos->rb_node, root);\r\nif (map->start > pos->start) {\r\nstruct map *before = map__clone(pos);\r\nif (before == NULL) {\r\nerr = -ENOMEM;\r\ngoto move_map;\r\n}\r\nbefore->end = map->start - 1;\r\nmap_groups__insert(self, before);\r\nif (verbose >= 2)\r\nmap__fprintf(before, fp);\r\n}\r\nif (map->end < pos->end) {\r\nstruct map *after = map__clone(pos);\r\nif (after == NULL) {\r\nerr = -ENOMEM;\r\ngoto move_map;\r\n}\r\nafter->start = map->end + 1;\r\nmap_groups__insert(self, after);\r\nif (verbose >= 2)\r\nmap__fprintf(after, fp);\r\n}\r\nmove_map:\r\nif (pos->referenced)\r\nlist_add_tail(&pos->node, &self->removed_maps[map->type]);\r\nelse\r\nmap__delete(pos);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint map_groups__clone(struct map_groups *self,\r\nstruct map_groups *parent, enum map_type type)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&parent->maps[type]); nd; nd = rb_next(nd)) {\r\nstruct map *map = rb_entry(nd, struct map, rb_node);\r\nstruct map *new = map__clone(map);\r\nif (new == NULL)\r\nreturn -ENOMEM;\r\nmap_groups__insert(self, new);\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 map__reloc_map_ip(struct map *map, u64 ip)\r\n{\r\nreturn ip + (s64)map->pgoff;\r\n}\r\nstatic u64 map__reloc_unmap_ip(struct map *map, u64 ip)\r\n{\r\nreturn ip - (s64)map->pgoff;\r\n}\r\nvoid map__reloc_vmlinux(struct map *self)\r\n{\r\nstruct kmap *kmap = map__kmap(self);\r\ns64 reloc;\r\nif (!kmap->ref_reloc_sym || !kmap->ref_reloc_sym->unrelocated_addr)\r\nreturn;\r\nreloc = (kmap->ref_reloc_sym->unrelocated_addr -\r\nkmap->ref_reloc_sym->addr);\r\nif (!reloc)\r\nreturn;\r\nself->map_ip = map__reloc_map_ip;\r\nself->unmap_ip = map__reloc_unmap_ip;\r\nself->pgoff = reloc;\r\n}\r\nvoid maps__insert(struct rb_root *maps, struct map *map)\r\n{\r\nstruct rb_node **p = &maps->rb_node;\r\nstruct rb_node *parent = NULL;\r\nconst u64 ip = map->start;\r\nstruct map *m;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nm = rb_entry(parent, struct map, rb_node);\r\nif (ip < m->start)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&map->rb_node, parent, p);\r\nrb_insert_color(&map->rb_node, maps);\r\n}\r\nvoid maps__remove(struct rb_root *self, struct map *map)\r\n{\r\nrb_erase(&map->rb_node, self);\r\n}\r\nstruct map *maps__find(struct rb_root *maps, u64 ip)\r\n{\r\nstruct rb_node **p = &maps->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct map *m;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nm = rb_entry(parent, struct map, rb_node);\r\nif (ip < m->start)\r\np = &(*p)->rb_left;\r\nelse if (ip > m->end)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nint machine__init(struct machine *self, const char *root_dir, pid_t pid)\r\n{\r\nmap_groups__init(&self->kmaps);\r\nRB_CLEAR_NODE(&self->rb_node);\r\nINIT_LIST_HEAD(&self->user_dsos);\r\nINIT_LIST_HEAD(&self->kernel_dsos);\r\nself->kmaps.machine = self;\r\nself->pid = pid;\r\nself->root_dir = strdup(root_dir);\r\nreturn self->root_dir == NULL ? -ENOMEM : 0;\r\n}\r\nstatic void dsos__delete(struct list_head *self)\r\n{\r\nstruct dso *pos, *n;\r\nlist_for_each_entry_safe(pos, n, self, node) {\r\nlist_del(&pos->node);\r\ndso__delete(pos);\r\n}\r\n}\r\nvoid machine__exit(struct machine *self)\r\n{\r\nmap_groups__exit(&self->kmaps);\r\ndsos__delete(&self->user_dsos);\r\ndsos__delete(&self->kernel_dsos);\r\nfree(self->root_dir);\r\nself->root_dir = NULL;\r\n}\r\nvoid machine__delete(struct machine *self)\r\n{\r\nmachine__exit(self);\r\nfree(self);\r\n}\r\nstruct machine *machines__add(struct rb_root *self, pid_t pid,\r\nconst char *root_dir)\r\n{\r\nstruct rb_node **p = &self->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct machine *pos, *machine = malloc(sizeof(*machine));\r\nif (!machine)\r\nreturn NULL;\r\nif (machine__init(machine, root_dir, pid) != 0) {\r\nfree(machine);\r\nreturn NULL;\r\n}\r\nwhile (*p != NULL) {\r\nparent = *p;\r\npos = rb_entry(parent, struct machine, rb_node);\r\nif (pid < pos->pid)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&machine->rb_node, parent, p);\r\nrb_insert_color(&machine->rb_node, self);\r\nreturn machine;\r\n}\r\nstruct machine *machines__find(struct rb_root *self, pid_t pid)\r\n{\r\nstruct rb_node **p = &self->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct machine *machine;\r\nstruct machine *default_machine = NULL;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nmachine = rb_entry(parent, struct machine, rb_node);\r\nif (pid < machine->pid)\r\np = &(*p)->rb_left;\r\nelse if (pid > machine->pid)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn machine;\r\nif (!machine->pid)\r\ndefault_machine = machine;\r\n}\r\nreturn default_machine;\r\n}\r\nstruct machine *machines__findnew(struct rb_root *self, pid_t pid)\r\n{\r\nchar path[PATH_MAX];\r\nconst char *root_dir;\r\nstruct machine *machine = machines__find(self, pid);\r\nif (!machine || machine->pid != pid) {\r\nif (pid == HOST_KERNEL_ID || pid == DEFAULT_GUEST_KERNEL_ID)\r\nroot_dir = "";\r\nelse {\r\nif (!symbol_conf.guestmount)\r\ngoto out;\r\nsprintf(path, "%s/%d", symbol_conf.guestmount, pid);\r\nif (access(path, R_OK)) {\r\npr_err("Can't access file %s\n", path);\r\ngoto out;\r\n}\r\nroot_dir = path;\r\n}\r\nmachine = machines__add(self, pid, root_dir);\r\n}\r\nout:\r\nreturn machine;\r\n}\r\nvoid machines__process(struct rb_root *self, machine__process_t process, void *data)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(self); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nprocess(pos, data);\r\n}\r\n}\r\nchar *machine__mmap_name(struct machine *self, char *bf, size_t size)\r\n{\r\nif (machine__is_host(self))\r\nsnprintf(bf, size, "[%s]", "kernel.kallsyms");\r\nelse if (machine__is_default_guest(self))\r\nsnprintf(bf, size, "[%s]", "guest.kernel.kallsyms");\r\nelse\r\nsnprintf(bf, size, "[%s.%d]", "guest.kernel.kallsyms", self->pid);\r\nreturn bf;\r\n}
