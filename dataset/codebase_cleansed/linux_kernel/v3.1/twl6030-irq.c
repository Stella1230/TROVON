static int twl6030_irq_thread(void *data)\r\n{\r\nlong irq = (long)data;\r\nstatic unsigned i2c_errors;\r\nstatic const unsigned max_i2c_errors = 100;\r\nint ret;\r\ncurrent->flags |= PF_NOFREEZE;\r\nwhile (!kthread_should_stop()) {\r\nint i;\r\nunion {\r\nu8 bytes[4];\r\nu32 int_sts;\r\n} sts;\r\nwait_for_completion_interruptible(&irq_event);\r\nret = twl_i2c_read(TWL_MODULE_PIH, sts.bytes,\r\nREG_INT_STS_A, 3);\r\nif (ret) {\r\npr_warning("twl6030: I2C error %d reading PIH ISR\n",\r\nret);\r\nif (++i2c_errors >= max_i2c_errors) {\r\nprintk(KERN_ERR "Maximum I2C error count"\r\n" exceeded. Terminating %s.\n",\r\n__func__);\r\nbreak;\r\n}\r\ncomplete(&irq_event);\r\ncontinue;\r\n}\r\nsts.bytes[3] = 0;\r\nif (sts.bytes[2] & 0x10)\r\nsts.bytes[2] |= 0x08;\r\nfor (i = 0; sts.int_sts; sts.int_sts >>= 1, i++) {\r\nlocal_irq_disable();\r\nif (sts.int_sts & 0x1) {\r\nint module_irq = twl6030_irq_base +\r\ntwl6030_interrupt_mapping[i];\r\ngeneric_handle_irq(module_irq);\r\n}\r\nlocal_irq_enable();\r\n}\r\nret = twl_i2c_write(TWL_MODULE_PIH, sts.bytes,\r\nREG_INT_STS_A, 3);\r\nif (ret)\r\npr_warning("twl6030: I2C error in clearing PIH ISR\n");\r\nenable_irq(irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t handle_twl6030_pih(int irq, void *devid)\r\n{\r\ndisable_irq_nosync(irq);\r\ncomplete(devid);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void activate_irq(int irq)\r\n{\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nint twl6030_interrupt_unmask(u8 bit_mask, u8 offset)\r\n{\r\nint ret;\r\nu8 unmask_value;\r\nret = twl_i2c_read_u8(TWL_MODULE_PIH, &unmask_value,\r\nREG_INT_STS_A + offset);\r\nunmask_value &= (~(bit_mask));\r\nret |= twl_i2c_write_u8(TWL_MODULE_PIH, unmask_value,\r\nREG_INT_STS_A + offset);\r\nreturn ret;\r\n}\r\nint twl6030_interrupt_mask(u8 bit_mask, u8 offset)\r\n{\r\nint ret;\r\nu8 mask_value;\r\nret = twl_i2c_read_u8(TWL_MODULE_PIH, &mask_value,\r\nREG_INT_STS_A + offset);\r\nmask_value |= (bit_mask);\r\nret |= twl_i2c_write_u8(TWL_MODULE_PIH, mask_value,\r\nREG_INT_STS_A + offset);\r\nreturn ret;\r\n}\r\nint twl6030_mmc_card_detect_config(void)\r\n{\r\nint ret;\r\nu8 reg_val = 0;\r\ntwl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,\r\nREG_INT_MSK_LINE_B);\r\ntwl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,\r\nREG_INT_MSK_STS_B);\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val, TWL6030_MMCCTRL);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to read MMCCTRL, error %d\n", ret);\r\nreturn ret;\r\n}\r\nreg_val &= ~VMMC_AUTO_OFF;\r\nreg_val |= SW_FC;\r\nret = twl_i2c_write_u8(TWL6030_MODULE_ID0, reg_val, TWL6030_MMCCTRL);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to write MMCCTRL, error %d\n", ret);\r\nreturn ret;\r\n}\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val,\r\nTWL6030_CFG_INPUT_PUPD3);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to read CFG_INPUT_PUPD3, error %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreg_val &= ~(MMC_PU | MMC_PD);\r\nret = twl_i2c_write_u8(TWL6030_MODULE_ID0, reg_val,\r\nTWL6030_CFG_INPUT_PUPD3);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to write CFG_INPUT_PUPD3, error %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint twl6030_mmc_card_detect(struct device *dev, int slot)\r\n{\r\nint ret = -EIO;\r\nu8 read_reg = 0;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (pdev->id) {\r\npr_err("Unknown MMC controller %d in %s\n", pdev->id, __func__);\r\nreturn ret;\r\n}\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &read_reg,\r\nTWL6030_MMCCTRL);\r\nif (ret >= 0)\r\nret = read_reg & STS_MMC;\r\nreturn ret;\r\n}\r\nint twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end)\r\n{\r\nint status = 0;\r\nint i;\r\nstruct task_struct *task;\r\nint ret;\r\nu8 mask[4];\r\nstatic struct irq_chip twl6030_irq_chip;\r\nmask[1] = 0xFF;\r\nmask[2] = 0xFF;\r\nmask[3] = 0xFF;\r\nret = twl_i2c_write(TWL_MODULE_PIH, &mask[0],\r\nREG_INT_MSK_LINE_A, 3);\r\nret = twl_i2c_write(TWL_MODULE_PIH, &mask[0],\r\nREG_INT_MSK_STS_A, 3);\r\nret = twl_i2c_write(TWL_MODULE_PIH, &mask[0],\r\nREG_INT_STS_A, 3);\r\ntwl6030_irq_base = irq_base;\r\ntwl6030_irq_chip = dummy_irq_chip;\r\ntwl6030_irq_chip.name = "twl6030";\r\ntwl6030_irq_chip.irq_set_type = NULL;\r\nfor (i = irq_base; i < irq_end; i++) {\r\nirq_set_chip_and_handler(i, &twl6030_irq_chip,\r\nhandle_simple_irq);\r\nactivate_irq(i);\r\n}\r\ntwl6030_irq_next = i;\r\npr_info("twl6030: %s (irq %d) chaining IRQs %d..%d\n", "PIH",\r\nirq_num, irq_base, twl6030_irq_next - 1);\r\ninit_completion(&irq_event);\r\ntask = kthread_run(twl6030_irq_thread, (void *)irq_num, "twl6030-irq");\r\nif (IS_ERR(task)) {\r\npr_err("twl6030: could not create irq %d thread!\n", irq_num);\r\nstatus = PTR_ERR(task);\r\ngoto fail_kthread;\r\n}\r\nstatus = request_irq(irq_num, handle_twl6030_pih, IRQF_DISABLED,\r\n"TWL6030-PIH", &irq_event);\r\nif (status < 0) {\r\npr_err("twl6030: could not claim irq%d: %d\n", irq_num, status);\r\ngoto fail_irq;\r\n}\r\nreturn status;\r\nfail_irq:\r\nfree_irq(irq_num, &irq_event);\r\nfail_kthread:\r\nfor (i = irq_base; i < irq_end; i++)\r\nirq_set_chip_and_handler(i, NULL, NULL);\r\nreturn status;\r\n}\r\nint twl6030_exit_irq(void)\r\n{\r\nif (twl6030_irq_base) {\r\npr_err("twl6030: can't yet clean up IRQs?\n");\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}
