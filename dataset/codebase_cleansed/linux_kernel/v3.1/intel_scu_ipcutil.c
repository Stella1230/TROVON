static int scu_reg_access(u32 cmd, struct scu_ipc_data *data)\r\n{\r\nint count = data->count;\r\nif (count == 0 || count == 3 || count > 4)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase INTE_SCU_IPC_REGISTER_READ:\r\nreturn intel_scu_ipc_readv(data->addr, data->data, count);\r\ncase INTE_SCU_IPC_REGISTER_WRITE:\r\nreturn intel_scu_ipc_writev(data->addr, data->data, count);\r\ncase INTE_SCU_IPC_REGISTER_UPDATE:\r\nreturn intel_scu_ipc_update_register(data->addr[0],\r\ndata->data[0], data->mask);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic long scu_ipc_ioctl(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nstruct scu_ipc_data data;\r\nvoid __user *argp = (void __user *)arg;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nif (cmd == INTE_SCU_IPC_FW_UPDATE) {\r\nu8 *fwbuf = kmalloc(MAX_FW_SIZE, GFP_KERNEL);\r\nif (fwbuf == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(fwbuf, (u8 *)arg, MAX_FW_SIZE)) {\r\nkfree(fwbuf);\r\nreturn -EFAULT;\r\n}\r\nret = intel_scu_ipc_fw_update(fwbuf, MAX_FW_SIZE);\r\nkfree(fwbuf);\r\nreturn ret;\r\n} else {\r\nif (copy_from_user(&data, argp, sizeof(struct scu_ipc_data)))\r\nreturn -EFAULT;\r\nret = scu_reg_access(cmd, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (copy_to_user(argp, &data, sizeof(struct scu_ipc_data)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nstatic int __init ipc_module_init(void)\r\n{\r\nreturn register_chrdev(0, "intel_mid_scu", &scu_ipc_fops);\r\n}\r\nstatic void __exit ipc_module_exit(void)\r\n{\r\nunregister_chrdev(major, "intel_mid_scu");\r\n}
