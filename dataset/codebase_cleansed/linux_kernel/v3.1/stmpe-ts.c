static int __stmpe_reset_fifo(struct stmpe *stmpe)\r\n{\r\nint ret;\r\nret = stmpe_set_bits(stmpe, STMPE_REG_FIFO_STA,\r\nSTMPE_FIFO_STA_RESET, STMPE_FIFO_STA_RESET);\r\nif (ret)\r\nreturn ret;\r\nreturn stmpe_set_bits(stmpe, STMPE_REG_FIFO_STA,\r\nSTMPE_FIFO_STA_RESET, 0);\r\n}\r\nstatic void stmpe_work(struct work_struct *work)\r\n{\r\nint int_sta;\r\nu32 timeout = 40;\r\nstruct stmpe_touch *ts =\r\ncontainer_of(work, struct stmpe_touch, work.work);\r\nint_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);\r\nwhile ((int_sta & (1 << STMPE_IRQ_TOUCH_DET)) && (timeout > 0)) {\r\ntimeout--;\r\nint_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);\r\nudelay(100);\r\n}\r\n__stmpe_reset_fifo(ts->stmpe);\r\ninput_report_abs(ts->idev, ABS_PRESSURE, 0);\r\ninput_sync(ts->idev);\r\n}\r\nstatic irqreturn_t stmpe_ts_handler(int irq, void *data)\r\n{\r\nu8 data_set[4];\r\nint x, y, z;\r\nstruct stmpe_touch *ts = data;\r\ncancel_delayed_work_sync(&ts->work);\r\nstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\r\nSTMPE_TSC_CTRL_TSC_EN, 0);\r\nstmpe_block_read(ts->stmpe, STMPE_REG_TSC_DATA_XYZ, 4, data_set);\r\nx = (data_set[0] << 4) | (data_set[1] >> 4);\r\ny = ((data_set[1] & 0xf) << 8) | data_set[2];\r\nz = data_set[3];\r\ninput_report_abs(ts->idev, ABS_X, x);\r\ninput_report_abs(ts->idev, ABS_Y, y);\r\ninput_report_abs(ts->idev, ABS_PRESSURE, z);\r\ninput_sync(ts->idev);\r\n__stmpe_reset_fifo(ts->stmpe);\r\nstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\r\nSTMPE_TSC_CTRL_TSC_EN, STMPE_TSC_CTRL_TSC_EN);\r\nschedule_delayed_work(&ts->work, HZ / 50);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit stmpe_init_hw(struct stmpe_touch *ts)\r\n{\r\nint ret;\r\nu8 adc_ctrl1, adc_ctrl1_mask, tsc_cfg, tsc_cfg_mask;\r\nstruct stmpe *stmpe = ts->stmpe;\r\nstruct device *dev = ts->dev;\r\nret = stmpe_enable(stmpe, STMPE_BLOCK_TOUCHSCREEN | STMPE_BLOCK_ADC);\r\nif (ret) {\r\ndev_err(dev, "Could not enable clock for ADC and TS\n");\r\nreturn ret;\r\n}\r\nadc_ctrl1 = SAMPLE_TIME(ts->sample_time) | MOD_12B(ts->mod_12b) |\r\nREF_SEL(ts->ref_sel);\r\nadc_ctrl1_mask = SAMPLE_TIME(0xff) | MOD_12B(0xff) | REF_SEL(0xff);\r\nret = stmpe_set_bits(stmpe, STMPE_REG_ADC_CTRL1,\r\nadc_ctrl1_mask, adc_ctrl1);\r\nif (ret) {\r\ndev_err(dev, "Could not setup ADC\n");\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_REG_ADC_CTRL2,\r\nADC_FREQ(0xff), ADC_FREQ(ts->adc_freq));\r\nif (ret) {\r\ndev_err(dev, "Could not setup ADC\n");\r\nreturn ret;\r\n}\r\ntsc_cfg = AVE_CTRL(ts->ave_ctrl) | DET_DELAY(ts->touch_det_delay) |\r\nSETTLING(ts->settling);\r\ntsc_cfg_mask = AVE_CTRL(0xff) | DET_DELAY(0xff) | SETTLING(0xff);\r\nret = stmpe_set_bits(stmpe, STMPE_REG_TSC_CFG, tsc_cfg_mask, tsc_cfg);\r\nif (ret) {\r\ndev_err(dev, "Could not config touch\n");\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_REG_TSC_FRACTION_Z,\r\nFRACTION_Z(0xff), FRACTION_Z(ts->fraction_z));\r\nif (ret) {\r\ndev_err(dev, "Could not config touch\n");\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_REG_TSC_I_DRIVE,\r\nI_DRIVE(0xff), I_DRIVE(ts->i_drive));\r\nif (ret) {\r\ndev_err(dev, "Could not config touch\n");\r\nreturn ret;\r\n}\r\nret = stmpe_reg_write(stmpe, STMPE_REG_FIFO_TH, 1);\r\nif (ret) {\r\ndev_err(dev, "Could not set FIFO\n");\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_REG_TSC_CTRL,\r\nOP_MODE(0xff), OP_MODE(OP_MOD_XYZ));\r\nif (ret) {\r\ndev_err(dev, "Could not set mode\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stmpe_ts_open(struct input_dev *dev)\r\n{\r\nstruct stmpe_touch *ts = input_get_drvdata(dev);\r\nint ret = 0;\r\nret = __stmpe_reset_fifo(ts->stmpe);\r\nif (ret)\r\nreturn ret;\r\nreturn stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\r\nSTMPE_TSC_CTRL_TSC_EN, STMPE_TSC_CTRL_TSC_EN);\r\n}\r\nstatic void stmpe_ts_close(struct input_dev *dev)\r\n{\r\nstruct stmpe_touch *ts = input_get_drvdata(dev);\r\ncancel_delayed_work_sync(&ts->work);\r\nstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\r\nSTMPE_TSC_CTRL_TSC_EN, 0);\r\n}\r\nstatic int __devinit stmpe_input_probe(struct platform_device *pdev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\r\nstruct stmpe_platform_data *pdata = stmpe->pdata;\r\nstruct stmpe_touch *ts;\r\nstruct input_dev *idev;\r\nstruct stmpe_ts_platform_data *ts_pdata = NULL;\r\nint ret;\r\nint ts_irq;\r\nts_irq = platform_get_irq_byname(pdev, "FIFO_TH");\r\nif (ts_irq < 0)\r\nreturn ts_irq;\r\nts = kzalloc(sizeof(*ts), GFP_KERNEL);\r\nif (!ts) {\r\nret = -ENOMEM;\r\ngoto err_out;\r\n}\r\nidev = input_allocate_device();\r\nif (!idev) {\r\nret = -ENOMEM;\r\ngoto err_free_ts;\r\n}\r\nplatform_set_drvdata(pdev, ts);\r\nts->stmpe = stmpe;\r\nts->idev = idev;\r\nts->dev = &pdev->dev;\r\nif (pdata)\r\nts_pdata = pdata->ts;\r\nif (ts_pdata) {\r\nts->sample_time = ts_pdata->sample_time;\r\nts->mod_12b = ts_pdata->mod_12b;\r\nts->ref_sel = ts_pdata->ref_sel;\r\nts->adc_freq = ts_pdata->adc_freq;\r\nts->ave_ctrl = ts_pdata->ave_ctrl;\r\nts->touch_det_delay = ts_pdata->touch_det_delay;\r\nts->settling = ts_pdata->settling;\r\nts->fraction_z = ts_pdata->fraction_z;\r\nts->i_drive = ts_pdata->i_drive;\r\n}\r\nINIT_DELAYED_WORK(&ts->work, stmpe_work);\r\nret = request_threaded_irq(ts_irq, NULL, stmpe_ts_handler,\r\nIRQF_ONESHOT, STMPE_TS_NAME, ts);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request IRQ %d\n", ts_irq);\r\ngoto err_free_input;\r\n}\r\nret = stmpe_init_hw(ts);\r\nif (ret)\r\ngoto err_free_irq;\r\nidev->name = STMPE_TS_NAME;\r\nidev->id.bustype = BUS_I2C;\r\nidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nidev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\nidev->open = stmpe_ts_open;\r\nidev->close = stmpe_ts_close;\r\ninput_set_drvdata(idev, ts);\r\ninput_set_abs_params(idev, ABS_X, 0, XY_MASK, 0, 0);\r\ninput_set_abs_params(idev, ABS_Y, 0, XY_MASK, 0, 0);\r\ninput_set_abs_params(idev, ABS_PRESSURE, 0x0, 0xff, 0, 0);\r\nret = input_register_device(idev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register input device\n");\r\ngoto err_free_irq;\r\n}\r\nreturn ret;\r\nerr_free_irq:\r\nfree_irq(ts_irq, ts);\r\nerr_free_input:\r\ninput_free_device(idev);\r\nplatform_set_drvdata(pdev, NULL);\r\nerr_free_ts:\r\nkfree(ts);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int __devexit stmpe_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct stmpe_touch *ts = platform_get_drvdata(pdev);\r\nunsigned int ts_irq = platform_get_irq_byname(pdev, "FIFO_TH");\r\nstmpe_disable(ts->stmpe, STMPE_BLOCK_TOUCHSCREEN);\r\nfree_irq(ts_irq, ts);\r\nplatform_set_drvdata(pdev, NULL);\r\ninput_unregister_device(ts->idev);\r\nkfree(ts);\r\nreturn 0;\r\n}\r\nstatic int __init stmpe_ts_init(void)\r\n{\r\nreturn platform_driver_register(&stmpe_ts_driver);\r\n}\r\nstatic void __exit stmpe_ts_exit(void)\r\n{\r\nplatform_driver_unregister(&stmpe_ts_driver);\r\n}
