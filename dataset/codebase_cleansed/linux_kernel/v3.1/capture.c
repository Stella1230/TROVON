static int submit_audio_in_urb(struct snd_line6_pcm *line6pcm)\r\n{\r\nint index;\r\nunsigned long flags;\r\nint i, urb_size;\r\nint ret;\r\nstruct urb *urb_in;\r\nspin_lock_irqsave(&line6pcm->lock_audio_in, flags);\r\nindex =\r\nfind_first_zero_bit(&line6pcm->active_urb_in, LINE6_ISO_BUFFERS);\r\nif (index < 0 || index >= LINE6_ISO_BUFFERS) {\r\nspin_unlock_irqrestore(&line6pcm->lock_audio_in, flags);\r\ndev_err(line6pcm->line6->ifcdev, "no free URB found\n");\r\nreturn -EINVAL;\r\n}\r\nurb_in = line6pcm->urb_audio_in[index];\r\nurb_size = 0;\r\nfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\r\nstruct usb_iso_packet_descriptor *fin =\r\n&urb_in->iso_frame_desc[i];\r\nfin->offset = urb_size;\r\nfin->length = line6pcm->max_packet_size;\r\nurb_size += line6pcm->max_packet_size;\r\n}\r\nurb_in->transfer_buffer =\r\nline6pcm->buffer_in +\r\nindex * LINE6_ISO_PACKETS * line6pcm->max_packet_size;\r\nurb_in->transfer_buffer_length = urb_size;\r\nurb_in->context = line6pcm;\r\nret = usb_submit_urb(urb_in, GFP_ATOMIC);\r\nif (ret == 0)\r\nset_bit(index, &line6pcm->active_urb_in);\r\nelse\r\ndev_err(line6pcm->line6->ifcdev,\r\n"URB in #%d submission failed (%d)\n", index, ret);\r\nspin_unlock_irqrestore(&line6pcm->lock_audio_in, flags);\r\nreturn 0;\r\n}\r\nint line6_submit_audio_in_all_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < LINE6_ISO_BUFFERS; ++i) {\r\nret = submit_audio_in_urb(line6pcm);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid line6_unlink_audio_in_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nunsigned int i;\r\nfor (i = LINE6_ISO_BUFFERS; i--;) {\r\nif (test_bit(i, &line6pcm->active_urb_in)) {\r\nif (!test_and_set_bit(i, &line6pcm->unlink_urb_in)) {\r\nstruct urb *u = line6pcm->urb_audio_in[i];\r\nusb_unlink_urb(u);\r\n}\r\n}\r\n}\r\n}\r\nstatic void wait_clear_audio_in_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nint timeout = HZ;\r\nunsigned int i;\r\nint alive;\r\ndo {\r\nalive = 0;\r\nfor (i = LINE6_ISO_BUFFERS; i--;) {\r\nif (test_bit(i, &line6pcm->active_urb_in))\r\nalive++;\r\n}\r\nif (!alive)\r\nbreak;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(1);\r\n} while (--timeout > 0);\r\nif (alive)\r\nsnd_printk(KERN_ERR "timeout: still %d active urbs..\n", alive);\r\n}\r\nvoid line6_unlink_wait_clear_audio_in_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nline6_unlink_audio_in_urbs(line6pcm);\r\nwait_clear_audio_in_urbs(line6pcm);\r\n}\r\nvoid line6_capture_copy(struct snd_line6_pcm *line6pcm, char *fbuf, int fsize)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nget_substream(line6pcm, SNDRV_PCM_STREAM_CAPTURE);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nconst int bytes_per_frame = line6pcm->properties->bytes_per_frame;\r\nint frames = fsize / bytes_per_frame;\r\nif (runtime == NULL)\r\nreturn;\r\nif (line6pcm->pos_in_done + frames > runtime->buffer_size) {\r\nint len;\r\nlen = runtime->buffer_size - line6pcm->pos_in_done;\r\nif (len > 0) {\r\nmemcpy(runtime->dma_area +\r\nline6pcm->pos_in_done * bytes_per_frame, fbuf,\r\nlen * bytes_per_frame);\r\nmemcpy(runtime->dma_area, fbuf + len * bytes_per_frame,\r\n(frames - len) * bytes_per_frame);\r\n} else {\r\ndev_err(line6pcm->line6->ifcdev,\r\n"driver bug: len = %d\n", len);\r\n}\r\n} else {\r\nmemcpy(runtime->dma_area +\r\nline6pcm->pos_in_done * bytes_per_frame, fbuf, fsize);\r\n}\r\nline6pcm->pos_in_done += frames;\r\nif (line6pcm->pos_in_done >= runtime->buffer_size)\r\nline6pcm->pos_in_done -= runtime->buffer_size;\r\n}\r\nvoid line6_capture_check_period(struct snd_line6_pcm *line6pcm, int length)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nget_substream(line6pcm, SNDRV_PCM_STREAM_CAPTURE);\r\nline6pcm->bytes_in += length;\r\nif (line6pcm->bytes_in >= line6pcm->period_in) {\r\nline6pcm->bytes_in %= line6pcm->period_in;\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\n}\r\nstatic void audio_in_callback(struct urb *urb)\r\n{\r\nint i, index, length = 0, shutdown = 0;\r\nunsigned long flags;\r\nstruct snd_line6_pcm *line6pcm = (struct snd_line6_pcm *)urb->context;\r\nline6pcm->last_frame_in = urb->start_frame;\r\nfor (index = 0; index < LINE6_ISO_BUFFERS; ++index)\r\nif (urb == line6pcm->urb_audio_in[index])\r\nbreak;\r\n#ifdef CONFIG_LINE6_USB_DUMP_PCM\r\nfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\r\nstruct usb_iso_packet_descriptor *fout =\r\n&urb->iso_frame_desc[i];\r\nline6_write_hexdump(line6pcm->line6, 'C',\r\nurb->transfer_buffer + fout->offset,\r\nfout->length);\r\n}\r\n#endif\r\nspin_lock_irqsave(&line6pcm->lock_audio_in, flags);\r\nfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\r\nchar *fbuf;\r\nint fsize;\r\nstruct usb_iso_packet_descriptor *fin = &urb->iso_frame_desc[i];\r\nif (fin->status == -EXDEV) {\r\nshutdown = 1;\r\nbreak;\r\n}\r\nfbuf = urb->transfer_buffer + fin->offset;\r\nfsize = fin->actual_length;\r\nif (fsize > line6pcm->max_packet_size) {\r\ndev_err(line6pcm->line6->ifcdev,\r\n"driver and/or device bug: packet too large (%d > %d)\n",\r\nfsize, line6pcm->max_packet_size);\r\n}\r\nlength += fsize;\r\n#if LINE6_BACKUP_MONITOR_SIGNAL\r\nmemcpy(line6pcm->prev_fbuf, fbuf, fsize);\r\n#else\r\nline6pcm->prev_fbuf = fbuf;\r\n#endif\r\nline6pcm->prev_fsize = fsize;\r\n#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE\r\nif (!(line6pcm->flags & MASK_PCM_IMPULSE))\r\n#endif\r\nif (test_bit(BIT_PCM_ALSA_CAPTURE, &line6pcm->flags)\r\n&& (fsize > 0))\r\nline6_capture_copy(line6pcm, fbuf, fsize);\r\n}\r\nclear_bit(index, &line6pcm->active_urb_in);\r\nif (test_and_clear_bit(index, &line6pcm->unlink_urb_in))\r\nshutdown = 1;\r\nspin_unlock_irqrestore(&line6pcm->lock_audio_in, flags);\r\nif (!shutdown) {\r\nsubmit_audio_in_urb(line6pcm);\r\n#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE\r\nif (!(line6pcm->flags & MASK_PCM_IMPULSE))\r\n#endif\r\nif (test_bit(BIT_PCM_ALSA_CAPTURE, &line6pcm->flags))\r\nline6_capture_check_period(line6pcm, length);\r\n}\r\n}\r\nstatic int snd_line6_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nerr = snd_pcm_hw_constraint_ratdens(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n(&line6pcm->\r\nproperties->snd_line6_rates));\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw = line6pcm->properties->snd_line6_capture_hw;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_line6_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint ret;\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nif (line6pcm == NULL) {\r\nif (substream->pcm == NULL)\r\nreturn -ENOMEM;\r\nif (substream->pcm->private_data == NULL)\r\nreturn -ENOMEM;\r\nsubstream->private_data = substream->pcm->private_data;\r\nline6pcm = snd_pcm_substream_chip(substream);\r\n}\r\nret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (ret < 0)\r\nreturn ret;\r\nline6pcm->period_in = params_period_bytes(hw_params);\r\nreturn 0;\r\n}\r\nstatic int snd_line6_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nint snd_line6_capture_trigger(struct snd_line6_pcm *line6pcm, int cmd)\r\n{\r\nint err;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\n#ifdef CONFIG_PM\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\n#endif\r\nerr = line6_pcm_start(line6pcm, MASK_PCM_ALSA_CAPTURE);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\n#ifdef CONFIG_PM\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\n#endif\r\nerr = line6_pcm_stop(line6pcm, MASK_PCM_ALSA_CAPTURE);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_line6_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nreturn line6pcm->pos_in_done;\r\n}\r\nint line6_create_audio_in_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nint i;\r\nfor (i = 0; i < LINE6_ISO_BUFFERS; ++i) {\r\nstruct urb *urb;\r\nurb = line6pcm->urb_audio_in[i] =\r\nusb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);\r\nif (urb == NULL) {\r\ndev_err(line6pcm->line6->ifcdev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nurb->dev = line6pcm->line6->usbdev;\r\nurb->pipe =\r\nusb_rcvisocpipe(line6pcm->line6->usbdev,\r\nline6pcm->ep_audio_read &\r\nUSB_ENDPOINT_NUMBER_MASK);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->start_frame = -1;\r\nurb->number_of_packets = LINE6_ISO_PACKETS;\r\nurb->interval = LINE6_ISO_INTERVAL;\r\nurb->error_count = 0;\r\nurb->complete = audio_in_callback;\r\n}\r\nreturn 0;\r\n}
