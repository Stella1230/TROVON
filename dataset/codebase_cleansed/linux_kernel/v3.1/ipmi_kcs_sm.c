static unsigned int init_kcs_data(struct si_sm_data *kcs,\r\nstruct si_sm_io *io)\r\n{\r\nkcs->state = KCS_IDLE;\r\nkcs->io = io;\r\nkcs->write_pos = 0;\r\nkcs->write_count = 0;\r\nkcs->orig_write_count = 0;\r\nkcs->read_pos = 0;\r\nkcs->error_retries = 0;\r\nkcs->truncated = 0;\r\nkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\r\nkcs->obf_timeout = OBF_RETRY_TIMEOUT;\r\nreturn 2;\r\n}\r\nstatic inline unsigned char read_status(struct si_sm_data *kcs)\r\n{\r\nreturn kcs->io->inputb(kcs->io, 1);\r\n}\r\nstatic inline unsigned char read_data(struct si_sm_data *kcs)\r\n{\r\nreturn kcs->io->inputb(kcs->io, 0);\r\n}\r\nstatic inline void write_cmd(struct si_sm_data *kcs, unsigned char data)\r\n{\r\nkcs->io->outputb(kcs->io, 1, data);\r\n}\r\nstatic inline void write_data(struct si_sm_data *kcs, unsigned char data)\r\n{\r\nkcs->io->outputb(kcs->io, 0, data);\r\n}\r\nstatic inline void write_next_byte(struct si_sm_data *kcs)\r\n{\r\nwrite_data(kcs, kcs->write_data[kcs->write_pos]);\r\n(kcs->write_pos)++;\r\n(kcs->write_count)--;\r\n}\r\nstatic inline void start_error_recovery(struct si_sm_data *kcs, char *reason)\r\n{\r\n(kcs->error_retries)++;\r\nif (kcs->error_retries > MAX_ERROR_RETRIES) {\r\nif (kcs_debug & KCS_DEBUG_ENABLE)\r\nprintk(KERN_DEBUG "ipmi_kcs_sm: kcs hosed: %s\n",\r\nreason);\r\nkcs->state = KCS_HOSED;\r\n} else {\r\nkcs->error0_timeout = jiffies + ERROR0_OBF_WAIT_JIFFIES;\r\nkcs->state = KCS_ERROR0;\r\n}\r\n}\r\nstatic inline void read_next_byte(struct si_sm_data *kcs)\r\n{\r\nif (kcs->read_pos >= MAX_KCS_READ_SIZE) {\r\nread_data(kcs);\r\nkcs->truncated = 1;\r\n} else {\r\nkcs->read_data[kcs->read_pos] = read_data(kcs);\r\n(kcs->read_pos)++;\r\n}\r\nwrite_data(kcs, KCS_READ_BYTE);\r\n}\r\nstatic inline int check_ibf(struct si_sm_data *kcs, unsigned char status,\r\nlong time)\r\n{\r\nif (GET_STATUS_IBF(status)) {\r\nkcs->ibf_timeout -= time;\r\nif (kcs->ibf_timeout < 0) {\r\nstart_error_recovery(kcs, "IBF not ready in time");\r\nkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\r\nreturn 1;\r\n}\r\nstatic inline int check_obf(struct si_sm_data *kcs, unsigned char status,\r\nlong time)\r\n{\r\nif (!GET_STATUS_OBF(status)) {\r\nkcs->obf_timeout -= time;\r\nif (kcs->obf_timeout < 0) {\r\nstart_error_recovery(kcs, "OBF not ready in time");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nkcs->obf_timeout = OBF_RETRY_TIMEOUT;\r\nreturn 1;\r\n}\r\nstatic void clear_obf(struct si_sm_data *kcs, unsigned char status)\r\n{\r\nif (GET_STATUS_OBF(status))\r\nread_data(kcs);\r\n}\r\nstatic void restart_kcs_transaction(struct si_sm_data *kcs)\r\n{\r\nkcs->write_count = kcs->orig_write_count;\r\nkcs->write_pos = 0;\r\nkcs->read_pos = 0;\r\nkcs->state = KCS_WAIT_WRITE_START;\r\nkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\r\nkcs->obf_timeout = OBF_RETRY_TIMEOUT;\r\nwrite_cmd(kcs, KCS_WRITE_START);\r\n}\r\nstatic int start_kcs_transaction(struct si_sm_data *kcs, unsigned char *data,\r\nunsigned int size)\r\n{\r\nunsigned int i;\r\nif (size < 2)\r\nreturn IPMI_REQ_LEN_INVALID_ERR;\r\nif (size > MAX_KCS_WRITE_SIZE)\r\nreturn IPMI_REQ_LEN_EXCEEDED_ERR;\r\nif ((kcs->state != KCS_IDLE) && (kcs->state != KCS_HOSED))\r\nreturn IPMI_NOT_IN_MY_STATE_ERR;\r\nif (kcs_debug & KCS_DEBUG_MSG) {\r\nprintk(KERN_DEBUG "start_kcs_transaction -");\r\nfor (i = 0; i < size; i++)\r\nprintk(" %02x", (unsigned char) (data [i]));\r\nprintk("\n");\r\n}\r\nkcs->error_retries = 0;\r\nmemcpy(kcs->write_data, data, size);\r\nkcs->write_count = size;\r\nkcs->orig_write_count = size;\r\nkcs->write_pos = 0;\r\nkcs->read_pos = 0;\r\nkcs->state = KCS_START_OP;\r\nkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\r\nkcs->obf_timeout = OBF_RETRY_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int get_kcs_result(struct si_sm_data *kcs, unsigned char *data,\r\nunsigned int length)\r\n{\r\nif (length < kcs->read_pos) {\r\nkcs->read_pos = length;\r\nkcs->truncated = 1;\r\n}\r\nmemcpy(data, kcs->read_data, kcs->read_pos);\r\nif ((length >= 3) && (kcs->read_pos < 3)) {\r\ndata[2] = IPMI_ERR_UNSPECIFIED;\r\nkcs->read_pos = 3;\r\n}\r\nif (kcs->truncated) {\r\ndata[2] = IPMI_ERR_MSG_TRUNCATED;\r\nkcs->truncated = 0;\r\n}\r\nreturn kcs->read_pos;\r\n}\r\nstatic enum si_sm_result kcs_event(struct si_sm_data *kcs, long time)\r\n{\r\nunsigned char status;\r\nunsigned char state;\r\nstatus = read_status(kcs);\r\nif (kcs_debug & KCS_DEBUG_STATES)\r\nprintk(KERN_DEBUG "KCS: State = %d, %x\n", kcs->state, status);\r\nif (!check_ibf(kcs, status, time))\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nstate = GET_STATUS_STATE(status);\r\nswitch (kcs->state) {\r\ncase KCS_IDLE:\r\nclear_obf(kcs, status);\r\nif (GET_STATUS_ATN(status))\r\nreturn SI_SM_ATTN;\r\nelse\r\nreturn SI_SM_IDLE;\r\ncase KCS_START_OP:\r\nif (state != KCS_IDLE_STATE) {\r\nstart_error_recovery(kcs,\r\n"State machine not idle at start");\r\nbreak;\r\n}\r\nclear_obf(kcs, status);\r\nwrite_cmd(kcs, KCS_WRITE_START);\r\nkcs->state = KCS_WAIT_WRITE_START;\r\nbreak;\r\ncase KCS_WAIT_WRITE_START:\r\nif (state != KCS_WRITE_STATE) {\r\nstart_error_recovery(\r\nkcs,\r\n"Not in write state at write start");\r\nbreak;\r\n}\r\nread_data(kcs);\r\nif (kcs->write_count == 1) {\r\nwrite_cmd(kcs, KCS_WRITE_END);\r\nkcs->state = KCS_WAIT_WRITE_END;\r\n} else {\r\nwrite_next_byte(kcs);\r\nkcs->state = KCS_WAIT_WRITE;\r\n}\r\nbreak;\r\ncase KCS_WAIT_WRITE:\r\nif (state != KCS_WRITE_STATE) {\r\nstart_error_recovery(kcs,\r\n"Not in write state for write");\r\nbreak;\r\n}\r\nclear_obf(kcs, status);\r\nif (kcs->write_count == 1) {\r\nwrite_cmd(kcs, KCS_WRITE_END);\r\nkcs->state = KCS_WAIT_WRITE_END;\r\n} else {\r\nwrite_next_byte(kcs);\r\n}\r\nbreak;\r\ncase KCS_WAIT_WRITE_END:\r\nif (state != KCS_WRITE_STATE) {\r\nstart_error_recovery(kcs,\r\n"Not in write state"\r\n" for write end");\r\nbreak;\r\n}\r\nclear_obf(kcs, status);\r\nwrite_next_byte(kcs);\r\nkcs->state = KCS_WAIT_READ;\r\nbreak;\r\ncase KCS_WAIT_READ:\r\nif ((state != KCS_READ_STATE) && (state != KCS_IDLE_STATE)) {\r\nstart_error_recovery(\r\nkcs,\r\n"Not in read or idle in read state");\r\nbreak;\r\n}\r\nif (state == KCS_READ_STATE) {\r\nif (!check_obf(kcs, status, time))\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nread_next_byte(kcs);\r\n} else {\r\nclear_obf(kcs, status);\r\nkcs->orig_write_count = 0;\r\nkcs->state = KCS_IDLE;\r\nreturn SI_SM_TRANSACTION_COMPLETE;\r\n}\r\nbreak;\r\ncase KCS_ERROR0:\r\nclear_obf(kcs, status);\r\nstatus = read_status(kcs);\r\nif (GET_STATUS_OBF(status))\r\nif (time_before(jiffies, kcs->error0_timeout))\r\nreturn SI_SM_CALL_WITH_TICK_DELAY;\r\nwrite_cmd(kcs, KCS_GET_STATUS_ABORT);\r\nkcs->state = KCS_ERROR1;\r\nbreak;\r\ncase KCS_ERROR1:\r\nclear_obf(kcs, status);\r\nwrite_data(kcs, 0);\r\nkcs->state = KCS_ERROR2;\r\nbreak;\r\ncase KCS_ERROR2:\r\nif (state != KCS_READ_STATE) {\r\nstart_error_recovery(kcs,\r\n"Not in read state for error2");\r\nbreak;\r\n}\r\nif (!check_obf(kcs, status, time))\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nclear_obf(kcs, status);\r\nwrite_data(kcs, KCS_READ_BYTE);\r\nkcs->state = KCS_ERROR3;\r\nbreak;\r\ncase KCS_ERROR3:\r\nif (state != KCS_IDLE_STATE) {\r\nstart_error_recovery(kcs,\r\n"Not in idle state for error3");\r\nbreak;\r\n}\r\nif (!check_obf(kcs, status, time))\r\nreturn SI_SM_CALL_WITH_DELAY;\r\nclear_obf(kcs, status);\r\nif (kcs->orig_write_count) {\r\nrestart_kcs_transaction(kcs);\r\n} else {\r\nkcs->state = KCS_IDLE;\r\nreturn SI_SM_TRANSACTION_COMPLETE;\r\n}\r\nbreak;\r\ncase KCS_HOSED:\r\nbreak;\r\n}\r\nif (kcs->state == KCS_HOSED) {\r\ninit_kcs_data(kcs, kcs->io);\r\nreturn SI_SM_HOSED;\r\n}\r\nreturn SI_SM_CALL_WITHOUT_DELAY;\r\n}\r\nstatic int kcs_size(void)\r\n{\r\nreturn sizeof(struct si_sm_data);\r\n}\r\nstatic int kcs_detect(struct si_sm_data *kcs)\r\n{\r\nif (read_status(kcs) == 0xff)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void kcs_cleanup(struct si_sm_data *kcs)\r\n{\r\n}
