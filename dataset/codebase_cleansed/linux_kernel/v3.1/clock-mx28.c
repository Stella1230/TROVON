static int _raw_clk_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nif (clk->enable_reg) {\r\nreg = __raw_readl(clk->enable_reg);\r\nreg &= ~(1 << clk->enable_shift);\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void _raw_clk_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nif (clk->enable_reg) {\r\nreg = __raw_readl(clk->enable_reg);\r\nreg |= 1 << clk->enable_shift;\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\n}\r\nstatic unsigned long ref_xtal_clk_get_rate(struct clk *clk)\r\n{\r\nreturn 24000000;\r\n}\r\nstatic unsigned long pll0_clk_get_rate(struct clk *clk)\r\n{\r\nreturn 480000000;\r\n}\r\nstatic unsigned long pll1_clk_get_rate(struct clk *clk)\r\n{\r\nreturn 480000000;\r\n}\r\nstatic unsigned long pll2_clk_get_rate(struct clk *clk)\r\n{\r\nreturn 50000000;\r\n}\r\nstatic unsigned long lradc_clk_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / 16;\r\n}\r\nstatic unsigned long rtc_clk_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / 768;\r\n}\r\nstatic unsigned long clk32k_clk_get_rate(struct clk *clk)\r\n{\r\nreturn clk->parent->get_rate(clk->parent) / 750;\r\n}\r\nstatic unsigned long spdif_clk_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / 4;\r\n}\r\nstatic int clk_misc_init(void)\r\n{\r\nu32 reg;\r\nint i;\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);\r\ncpu_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_CPU) ?\r\n&ref_xtal_clk : &ref_cpu_clk;\r\nemi_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_EMI) ?\r\n&ref_xtal_clk : &ref_emi_clk;\r\nssp0_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP0) ?\r\n&ref_xtal_clk : &ref_io0_clk;\r\nssp1_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP1) ?\r\n&ref_xtal_clk : &ref_io0_clk;\r\nssp2_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP2) ?\r\n&ref_xtal_clk : &ref_io1_clk;\r\nssp3_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP3) ?\r\n&ref_xtal_clk : &ref_io1_clk;\r\nlcdif_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF) ?\r\n&ref_xtal_clk : &ref_pix_clk;\r\ngpmi_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_GPMI) ?\r\n&ref_xtal_clk : &ref_gpmi_clk;\r\nsaif0_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SAIF0) ?\r\n&ref_xtal_clk : &pll0_clk;\r\nsaif1_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SAIF1) ?\r\n&ref_xtal_clk : &pll0_clk;\r\n__raw_writel(BM_CLKCTRL_CPU_DIV_XTAL_FRAC_EN,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_CLR);\r\n__raw_writel(BM_CLKCTRL_CPU_DIV_CPU_FRAC_EN,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_CLR);\r\n__raw_writel(BM_CLKCTRL_HBUS_DIV_FRAC_EN,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_CLR);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);\r\nreg &= ~BM_CLKCTRL_XBUS_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0);\r\nreg &= ~BM_CLKCTRL_SSP0_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1);\r\nreg &= ~BM_CLKCTRL_SSP1_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2);\r\nreg &= ~BM_CLKCTRL_SSP2_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3);\r\nreg &= ~BM_CLKCTRL_SSP3_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);\r\nreg &= ~BM_CLKCTRL_GPMI_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF);\r\nreg &= ~BM_CLKCTRL_DIS_LCDIF_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0);\r\nreg &= ~BM_CLKCTRL_SAIF0_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1);\r\nreg &= ~BM_CLKCTRL_SAIF1_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);\r\nreg &= BM_CLKCTRL_HBUS_DIV;\r\nreg |= 3 << BP_CLKCTRL_HBUS_DIV;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);\r\nfor (i = 10000; i; i--)\r\nif (!(__raw_readl(CLKCTRL_BASE_ADDR +\r\nHW_CLKCTRL_HBUS) & BM_CLKCTRL_HBUS_ASM_BUSY))\r\nbreak;\r\nif (!i) {\r\npr_err("%s: divider writing timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\n__raw_writel(BM_CLKCTRL_CPU_INTERRUPT_WAIT,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_SET);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET);\r\nreg &= ~BM_CLKCTRL_ENET_SLEEP;\r\nreg |= BM_CLKCTRL_ENET_CLK_OUT_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0);\r\nreg &= ~BM_CLKCTRL_FRAC0_IO0FRAC;\r\nreg |= 30 << BP_CLKCTRL_FRAC0_IO0FRAC;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0);\r\nreturn 0;\r\n}\r\nint __init mx28_clocks_init(void)\r\n{\r\nclk_misc_init();\r\nclk_set_parent(&ssp0_clk, &ref_io0_clk);\r\nclk_set_parent(&ssp1_clk, &ref_io0_clk);\r\nclk_enable(&cpu_clk);\r\nclk_enable(&hbus_clk);\r\nclk_enable(&xbus_clk);\r\nclk_enable(&emi_clk);\r\nclk_enable(&uart_clk);\r\nclk_set_parent(&lcdif_clk, &ref_pix_clk);\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nmxs_timer_init(&clk32k_clk, MX28_INT_TIMER0);\r\nreturn 0;\r\n}
