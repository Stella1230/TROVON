static int swsusp_extents_insert(unsigned long swap_offset)\r\n{\r\nstruct rb_node **new = &(swsusp_extents.rb_node);\r\nstruct rb_node *parent = NULL;\r\nstruct swsusp_extent *ext;\r\nwhile (*new) {\r\next = container_of(*new, struct swsusp_extent, node);\r\nparent = *new;\r\nif (swap_offset < ext->start) {\r\nif (swap_offset == ext->start - 1) {\r\next->start--;\r\nreturn 0;\r\n}\r\nnew = &((*new)->rb_left);\r\n} else if (swap_offset > ext->end) {\r\nif (swap_offset == ext->end + 1) {\r\next->end++;\r\nreturn 0;\r\n}\r\nnew = &((*new)->rb_right);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\next = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\r\nif (!ext)\r\nreturn -ENOMEM;\r\next->start = swap_offset;\r\next->end = swap_offset;\r\nrb_link_node(&ext->node, parent, new);\r\nrb_insert_color(&ext->node, &swsusp_extents);\r\nreturn 0;\r\n}\r\nsector_t alloc_swapdev_block(int swap)\r\n{\r\nunsigned long offset;\r\noffset = swp_offset(get_swap_page_of_type(swap));\r\nif (offset) {\r\nif (swsusp_extents_insert(offset))\r\nswap_free(swp_entry(swap, offset));\r\nelse\r\nreturn swapdev_block(swap, offset);\r\n}\r\nreturn 0;\r\n}\r\nvoid free_all_swap_pages(int swap)\r\n{\r\nstruct rb_node *node;\r\nwhile ((node = swsusp_extents.rb_node)) {\r\nstruct swsusp_extent *ext;\r\nunsigned long offset;\r\next = container_of(node, struct swsusp_extent, node);\r\nrb_erase(node, &swsusp_extents);\r\nfor (offset = ext->start; offset <= ext->end; offset++)\r\nswap_free(swp_entry(swap, offset));\r\nkfree(ext);\r\n}\r\n}\r\nint swsusp_swap_in_use(void)\r\n{\r\nreturn (swsusp_extents.rb_node != NULL);\r\n}\r\nstatic int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\r\n{\r\nint error;\r\nhib_bio_read_page(swsusp_resume_block, swsusp_header, NULL);\r\nif (!memcmp("SWAP-SPACE",swsusp_header->sig, 10) ||\r\n!memcmp("SWAPSPACE2",swsusp_header->sig, 10)) {\r\nmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\r\nmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\r\nswsusp_header->image = handle->first_sector;\r\nswsusp_header->flags = flags;\r\nerror = hib_bio_write_page(swsusp_resume_block,\r\nswsusp_header, NULL);\r\n} else {\r\nprintk(KERN_ERR "PM: Swap header not found!\n");\r\nerror = -ENODEV;\r\n}\r\nreturn error;\r\n}\r\nstatic int swsusp_swap_check(void)\r\n{\r\nint res;\r\nres = swap_type_of(swsusp_resume_device, swsusp_resume_block,\r\n&hib_resume_bdev);\r\nif (res < 0)\r\nreturn res;\r\nroot_swap = res;\r\nres = blkdev_get(hib_resume_bdev, FMODE_WRITE, NULL);\r\nif (res)\r\nreturn res;\r\nres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\r\nif (res < 0)\r\nblkdev_put(hib_resume_bdev, FMODE_WRITE);\r\nreturn res;\r\n}\r\nstatic int write_page(void *buf, sector_t offset, struct bio **bio_chain)\r\n{\r\nvoid *src;\r\nif (!offset)\r\nreturn -ENOSPC;\r\nif (bio_chain) {\r\nsrc = (void *)__get_free_page(__GFP_WAIT | __GFP_HIGH);\r\nif (src) {\r\ncopy_page(src, buf);\r\n} else {\r\nWARN_ON_ONCE(1);\r\nbio_chain = NULL;\r\nsrc = buf;\r\n}\r\n} else {\r\nsrc = buf;\r\n}\r\nreturn hib_bio_write_page(offset, src, bio_chain);\r\n}\r\nstatic void release_swap_writer(struct swap_map_handle *handle)\r\n{\r\nif (handle->cur)\r\nfree_page((unsigned long)handle->cur);\r\nhandle->cur = NULL;\r\n}\r\nstatic int get_swap_writer(struct swap_map_handle *handle)\r\n{\r\nint ret;\r\nret = swsusp_swap_check();\r\nif (ret) {\r\nif (ret != -ENOSPC)\r\nprintk(KERN_ERR "PM: Cannot find swap device, try "\r\n"swapon -a.\n");\r\nreturn ret;\r\n}\r\nhandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\r\nif (!handle->cur) {\r\nret = -ENOMEM;\r\ngoto err_close;\r\n}\r\nhandle->cur_swap = alloc_swapdev_block(root_swap);\r\nif (!handle->cur_swap) {\r\nret = -ENOSPC;\r\ngoto err_rel;\r\n}\r\nhandle->k = 0;\r\nhandle->first_sector = handle->cur_swap;\r\nreturn 0;\r\nerr_rel:\r\nrelease_swap_writer(handle);\r\nerr_close:\r\nswsusp_close(FMODE_WRITE);\r\nreturn ret;\r\n}\r\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\r\nstruct bio **bio_chain)\r\n{\r\nint error = 0;\r\nsector_t offset;\r\nif (!handle->cur)\r\nreturn -EINVAL;\r\noffset = alloc_swapdev_block(root_swap);\r\nerror = write_page(buf, offset, bio_chain);\r\nif (error)\r\nreturn error;\r\nhandle->cur->entries[handle->k++] = offset;\r\nif (handle->k >= MAP_PAGE_ENTRIES) {\r\nerror = hib_wait_on_bio_chain(bio_chain);\r\nif (error)\r\ngoto out;\r\noffset = alloc_swapdev_block(root_swap);\r\nif (!offset)\r\nreturn -ENOSPC;\r\nhandle->cur->next_swap = offset;\r\nerror = write_page(handle->cur, handle->cur_swap, NULL);\r\nif (error)\r\ngoto out;\r\nclear_page(handle->cur);\r\nhandle->cur_swap = offset;\r\nhandle->k = 0;\r\n}\r\nout:\r\nreturn error;\r\n}\r\nstatic int flush_swap_writer(struct swap_map_handle *handle)\r\n{\r\nif (handle->cur && handle->cur_swap)\r\nreturn write_page(handle->cur, handle->cur_swap, NULL);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int swap_writer_finish(struct swap_map_handle *handle,\r\nunsigned int flags, int error)\r\n{\r\nif (!error) {\r\nflush_swap_writer(handle);\r\nprintk(KERN_INFO "PM: S");\r\nerror = mark_swapfiles(handle, flags);\r\nprintk("|\n");\r\n}\r\nif (error)\r\nfree_all_swap_pages(root_swap);\r\nrelease_swap_writer(handle);\r\nswsusp_close(FMODE_WRITE);\r\nreturn error;\r\n}\r\nstatic int save_image(struct swap_map_handle *handle,\r\nstruct snapshot_handle *snapshot,\r\nunsigned int nr_to_write)\r\n{\r\nunsigned int m;\r\nint ret;\r\nint nr_pages;\r\nint err2;\r\nstruct bio *bio;\r\nstruct timeval start;\r\nstruct timeval stop;\r\nprintk(KERN_INFO "PM: Saving image data pages (%u pages) ... ",\r\nnr_to_write);\r\nm = nr_to_write / 100;\r\nif (!m)\r\nm = 1;\r\nnr_pages = 0;\r\nbio = NULL;\r\ndo_gettimeofday(&start);\r\nwhile (1) {\r\nret = snapshot_read_next(snapshot);\r\nif (ret <= 0)\r\nbreak;\r\nret = swap_write_page(handle, data_of(*snapshot), &bio);\r\nif (ret)\r\nbreak;\r\nif (!(nr_pages % m))\r\nprintk(KERN_CONT "\b\b\b\b%3d%%", nr_pages / m);\r\nnr_pages++;\r\n}\r\nerr2 = hib_wait_on_bio_chain(&bio);\r\ndo_gettimeofday(&stop);\r\nif (!ret)\r\nret = err2;\r\nif (!ret)\r\nprintk(KERN_CONT "\b\b\b\bdone\n");\r\nelse\r\nprintk(KERN_CONT "\n");\r\nswsusp_show_speed(&start, &stop, nr_to_write, "Wrote");\r\nreturn ret;\r\n}\r\nstatic int save_image_lzo(struct swap_map_handle *handle,\r\nstruct snapshot_handle *snapshot,\r\nunsigned int nr_to_write)\r\n{\r\nunsigned int m;\r\nint ret = 0;\r\nint nr_pages;\r\nint err2;\r\nstruct bio *bio;\r\nstruct timeval start;\r\nstruct timeval stop;\r\nsize_t off, unc_len, cmp_len;\r\nunsigned char *unc, *cmp, *wrk, *page;\r\npage = (void *)__get_free_page(__GFP_WAIT | __GFP_HIGH);\r\nif (!page) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO page\n");\r\nreturn -ENOMEM;\r\n}\r\nwrk = vmalloc(LZO1X_1_MEM_COMPRESS);\r\nif (!wrk) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO workspace\n");\r\nfree_page((unsigned long)page);\r\nreturn -ENOMEM;\r\n}\r\nunc = vmalloc(LZO_UNC_SIZE);\r\nif (!unc) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO uncompressed\n");\r\nvfree(wrk);\r\nfree_page((unsigned long)page);\r\nreturn -ENOMEM;\r\n}\r\ncmp = vmalloc(LZO_CMP_SIZE);\r\nif (!cmp) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO compressed\n");\r\nvfree(unc);\r\nvfree(wrk);\r\nfree_page((unsigned long)page);\r\nreturn -ENOMEM;\r\n}\r\nprintk(KERN_INFO\r\n"PM: Compressing and saving image data (%u pages) ... ",\r\nnr_to_write);\r\nm = nr_to_write / 100;\r\nif (!m)\r\nm = 1;\r\nnr_pages = 0;\r\nbio = NULL;\r\ndo_gettimeofday(&start);\r\nfor (;;) {\r\nfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\r\nret = snapshot_read_next(snapshot);\r\nif (ret < 0)\r\ngoto out_finish;\r\nif (!ret)\r\nbreak;\r\nmemcpy(unc + off, data_of(*snapshot), PAGE_SIZE);\r\nif (!(nr_pages % m))\r\nprintk(KERN_CONT "\b\b\b\b%3d%%", nr_pages / m);\r\nnr_pages++;\r\n}\r\nif (!off)\r\nbreak;\r\nunc_len = off;\r\nret = lzo1x_1_compress(unc, unc_len,\r\ncmp + LZO_HEADER, &cmp_len, wrk);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "PM: LZO compression failed\n");\r\nbreak;\r\n}\r\nif (unlikely(!cmp_len ||\r\ncmp_len > lzo1x_worst_compress(unc_len))) {\r\nprintk(KERN_ERR "PM: Invalid LZO compressed length\n");\r\nret = -1;\r\nbreak;\r\n}\r\n*(size_t *)cmp = cmp_len;\r\nfor (off = 0; off < LZO_HEADER + cmp_len; off += PAGE_SIZE) {\r\nmemcpy(page, cmp + off, PAGE_SIZE);\r\nret = swap_write_page(handle, page, &bio);\r\nif (ret)\r\ngoto out_finish;\r\n}\r\n}\r\nout_finish:\r\nerr2 = hib_wait_on_bio_chain(&bio);\r\ndo_gettimeofday(&stop);\r\nif (!ret)\r\nret = err2;\r\nif (!ret)\r\nprintk(KERN_CONT "\b\b\b\bdone\n");\r\nelse\r\nprintk(KERN_CONT "\n");\r\nswsusp_show_speed(&start, &stop, nr_to_write, "Wrote");\r\nvfree(cmp);\r\nvfree(unc);\r\nvfree(wrk);\r\nfree_page((unsigned long)page);\r\nreturn ret;\r\n}\r\nstatic int enough_swap(unsigned int nr_pages, unsigned int flags)\r\n{\r\nunsigned int free_swap = count_swap_pages(root_swap, 1);\r\nunsigned int required;\r\npr_debug("PM: Free swap pages: %u\n", free_swap);\r\nrequired = PAGES_FOR_IO + ((flags & SF_NOCOMPRESS_MODE) ?\r\nnr_pages : (nr_pages * LZO_CMP_PAGES) / LZO_UNC_PAGES + 1);\r\nreturn free_swap > required;\r\n}\r\nint swsusp_write(unsigned int flags)\r\n{\r\nstruct swap_map_handle handle;\r\nstruct snapshot_handle snapshot;\r\nstruct swsusp_info *header;\r\nunsigned long pages;\r\nint error;\r\npages = snapshot_get_image_size();\r\nerror = get_swap_writer(&handle);\r\nif (error) {\r\nprintk(KERN_ERR "PM: Cannot get swap writer\n");\r\nreturn error;\r\n}\r\nif (!enough_swap(pages, flags)) {\r\nprintk(KERN_ERR "PM: Not enough free swap\n");\r\nerror = -ENOSPC;\r\ngoto out_finish;\r\n}\r\nmemset(&snapshot, 0, sizeof(struct snapshot_handle));\r\nerror = snapshot_read_next(&snapshot);\r\nif (error < PAGE_SIZE) {\r\nif (error >= 0)\r\nerror = -EFAULT;\r\ngoto out_finish;\r\n}\r\nheader = (struct swsusp_info *)data_of(snapshot);\r\nerror = swap_write_page(&handle, header, NULL);\r\nif (!error) {\r\nerror = (flags & SF_NOCOMPRESS_MODE) ?\r\nsave_image(&handle, &snapshot, pages - 1) :\r\nsave_image_lzo(&handle, &snapshot, pages - 1);\r\n}\r\nout_finish:\r\nerror = swap_writer_finish(&handle, flags, error);\r\nreturn error;\r\n}\r\nstatic void release_swap_reader(struct swap_map_handle *handle)\r\n{\r\nif (handle->cur)\r\nfree_page((unsigned long)handle->cur);\r\nhandle->cur = NULL;\r\n}\r\nstatic int get_swap_reader(struct swap_map_handle *handle,\r\nunsigned int *flags_p)\r\n{\r\nint error;\r\n*flags_p = swsusp_header->flags;\r\nif (!swsusp_header->image)\r\nreturn -EINVAL;\r\nhandle->cur = (struct swap_map_page *)get_zeroed_page(__GFP_WAIT | __GFP_HIGH);\r\nif (!handle->cur)\r\nreturn -ENOMEM;\r\nerror = hib_bio_read_page(swsusp_header->image, handle->cur, NULL);\r\nif (error) {\r\nrelease_swap_reader(handle);\r\nreturn error;\r\n}\r\nhandle->k = 0;\r\nreturn 0;\r\n}\r\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\r\nstruct bio **bio_chain)\r\n{\r\nsector_t offset;\r\nint error;\r\nif (!handle->cur)\r\nreturn -EINVAL;\r\noffset = handle->cur->entries[handle->k];\r\nif (!offset)\r\nreturn -EFAULT;\r\nerror = hib_bio_read_page(offset, buf, bio_chain);\r\nif (error)\r\nreturn error;\r\nif (++handle->k >= MAP_PAGE_ENTRIES) {\r\nerror = hib_wait_on_bio_chain(bio_chain);\r\nhandle->k = 0;\r\noffset = handle->cur->next_swap;\r\nif (!offset)\r\nrelease_swap_reader(handle);\r\nelse if (!error)\r\nerror = hib_bio_read_page(offset, handle->cur, NULL);\r\n}\r\nreturn error;\r\n}\r\nstatic int swap_reader_finish(struct swap_map_handle *handle)\r\n{\r\nrelease_swap_reader(handle);\r\nreturn 0;\r\n}\r\nstatic int load_image(struct swap_map_handle *handle,\r\nstruct snapshot_handle *snapshot,\r\nunsigned int nr_to_read)\r\n{\r\nunsigned int m;\r\nint error = 0;\r\nstruct timeval start;\r\nstruct timeval stop;\r\nstruct bio *bio;\r\nint err2;\r\nunsigned nr_pages;\r\nprintk(KERN_INFO "PM: Loading image data pages (%u pages) ... ",\r\nnr_to_read);\r\nm = nr_to_read / 100;\r\nif (!m)\r\nm = 1;\r\nnr_pages = 0;\r\nbio = NULL;\r\ndo_gettimeofday(&start);\r\nfor ( ; ; ) {\r\nerror = snapshot_write_next(snapshot);\r\nif (error <= 0)\r\nbreak;\r\nerror = swap_read_page(handle, data_of(*snapshot), &bio);\r\nif (error)\r\nbreak;\r\nif (snapshot->sync_read)\r\nerror = hib_wait_on_bio_chain(&bio);\r\nif (error)\r\nbreak;\r\nif (!(nr_pages % m))\r\nprintk("\b\b\b\b%3d%%", nr_pages / m);\r\nnr_pages++;\r\n}\r\nerr2 = hib_wait_on_bio_chain(&bio);\r\ndo_gettimeofday(&stop);\r\nif (!error)\r\nerror = err2;\r\nif (!error) {\r\nprintk("\b\b\b\bdone\n");\r\nsnapshot_write_finalize(snapshot);\r\nif (!snapshot_image_loaded(snapshot))\r\nerror = -ENODATA;\r\n} else\r\nprintk("\n");\r\nswsusp_show_speed(&start, &stop, nr_to_read, "Read");\r\nreturn error;\r\n}\r\nstatic int load_image_lzo(struct swap_map_handle *handle,\r\nstruct snapshot_handle *snapshot,\r\nunsigned int nr_to_read)\r\n{\r\nunsigned int m;\r\nint error = 0;\r\nstruct bio *bio;\r\nstruct timeval start;\r\nstruct timeval stop;\r\nunsigned nr_pages;\r\nsize_t i, off, unc_len, cmp_len;\r\nunsigned char *unc, *cmp, *page[LZO_CMP_PAGES];\r\nfor (i = 0; i < LZO_CMP_PAGES; i++) {\r\npage[i] = (void *)__get_free_page(__GFP_WAIT | __GFP_HIGH);\r\nif (!page[i]) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO page\n");\r\nwhile (i)\r\nfree_page((unsigned long)page[--i]);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nunc = vmalloc(LZO_UNC_SIZE);\r\nif (!unc) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO uncompressed\n");\r\nfor (i = 0; i < LZO_CMP_PAGES; i++)\r\nfree_page((unsigned long)page[i]);\r\nreturn -ENOMEM;\r\n}\r\ncmp = vmalloc(LZO_CMP_SIZE);\r\nif (!cmp) {\r\nprintk(KERN_ERR "PM: Failed to allocate LZO compressed\n");\r\nvfree(unc);\r\nfor (i = 0; i < LZO_CMP_PAGES; i++)\r\nfree_page((unsigned long)page[i]);\r\nreturn -ENOMEM;\r\n}\r\nprintk(KERN_INFO\r\n"PM: Loading and decompressing image data (%u pages) ... ",\r\nnr_to_read);\r\nm = nr_to_read / 100;\r\nif (!m)\r\nm = 1;\r\nnr_pages = 0;\r\nbio = NULL;\r\ndo_gettimeofday(&start);\r\nerror = snapshot_write_next(snapshot);\r\nif (error <= 0)\r\ngoto out_finish;\r\nfor (;;) {\r\nerror = swap_read_page(handle, page[0], NULL);\r\nif (error)\r\nbreak;\r\ncmp_len = *(size_t *)page[0];\r\nif (unlikely(!cmp_len ||\r\ncmp_len > lzo1x_worst_compress(LZO_UNC_SIZE))) {\r\nprintk(KERN_ERR "PM: Invalid LZO compressed length\n");\r\nerror = -1;\r\nbreak;\r\n}\r\nfor (off = PAGE_SIZE, i = 1;\r\noff < LZO_HEADER + cmp_len; off += PAGE_SIZE, i++) {\r\nerror = swap_read_page(handle, page[i], &bio);\r\nif (error)\r\ngoto out_finish;\r\n}\r\nerror = hib_wait_on_bio_chain(&bio);\r\nif (error)\r\ngoto out_finish;\r\nfor (off = 0, i = 0;\r\noff < LZO_HEADER + cmp_len; off += PAGE_SIZE, i++) {\r\nmemcpy(cmp + off, page[i], PAGE_SIZE);\r\n}\r\nunc_len = LZO_UNC_SIZE;\r\nerror = lzo1x_decompress_safe(cmp + LZO_HEADER, cmp_len,\r\nunc, &unc_len);\r\nif (error < 0) {\r\nprintk(KERN_ERR "PM: LZO decompression failed\n");\r\nbreak;\r\n}\r\nif (unlikely(!unc_len ||\r\nunc_len > LZO_UNC_SIZE ||\r\nunc_len & (PAGE_SIZE - 1))) {\r\nprintk(KERN_ERR "PM: Invalid LZO uncompressed length\n");\r\nerror = -1;\r\nbreak;\r\n}\r\nfor (off = 0; off < unc_len; off += PAGE_SIZE) {\r\nmemcpy(data_of(*snapshot), unc + off, PAGE_SIZE);\r\nif (!(nr_pages % m))\r\nprintk("\b\b\b\b%3d%%", nr_pages / m);\r\nnr_pages++;\r\nerror = snapshot_write_next(snapshot);\r\nif (error <= 0)\r\ngoto out_finish;\r\n}\r\n}\r\nout_finish:\r\ndo_gettimeofday(&stop);\r\nif (!error) {\r\nprintk("\b\b\b\bdone\n");\r\nsnapshot_write_finalize(snapshot);\r\nif (!snapshot_image_loaded(snapshot))\r\nerror = -ENODATA;\r\n} else\r\nprintk("\n");\r\nswsusp_show_speed(&start, &stop, nr_to_read, "Read");\r\nvfree(cmp);\r\nvfree(unc);\r\nfor (i = 0; i < LZO_CMP_PAGES; i++)\r\nfree_page((unsigned long)page[i]);\r\nreturn error;\r\n}\r\nint swsusp_read(unsigned int *flags_p)\r\n{\r\nint error;\r\nstruct swap_map_handle handle;\r\nstruct snapshot_handle snapshot;\r\nstruct swsusp_info *header;\r\nmemset(&snapshot, 0, sizeof(struct snapshot_handle));\r\nerror = snapshot_write_next(&snapshot);\r\nif (error < PAGE_SIZE)\r\nreturn error < 0 ? error : -EFAULT;\r\nheader = (struct swsusp_info *)data_of(snapshot);\r\nerror = get_swap_reader(&handle, flags_p);\r\nif (error)\r\ngoto end;\r\nif (!error)\r\nerror = swap_read_page(&handle, header, NULL);\r\nif (!error) {\r\nerror = (*flags_p & SF_NOCOMPRESS_MODE) ?\r\nload_image(&handle, &snapshot, header->pages - 1) :\r\nload_image_lzo(&handle, &snapshot, header->pages - 1);\r\n}\r\nswap_reader_finish(&handle);\r\nend:\r\nif (!error)\r\npr_debug("PM: Image successfully loaded\n");\r\nelse\r\npr_debug("PM: Error %d resuming\n", error);\r\nreturn error;\r\n}\r\nint swsusp_check(void)\r\n{\r\nint error;\r\nhib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\r\nFMODE_READ, NULL);\r\nif (!IS_ERR(hib_resume_bdev)) {\r\nset_blocksize(hib_resume_bdev, PAGE_SIZE);\r\nclear_page(swsusp_header);\r\nerror = hib_bio_read_page(swsusp_resume_block,\r\nswsusp_header, NULL);\r\nif (error)\r\ngoto put;\r\nif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\r\nmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\r\nerror = hib_bio_write_page(swsusp_resume_block,\r\nswsusp_header, NULL);\r\n} else {\r\nerror = -EINVAL;\r\n}\r\nput:\r\nif (error)\r\nblkdev_put(hib_resume_bdev, FMODE_READ);\r\nelse\r\npr_debug("PM: Image signature found, resuming\n");\r\n} else {\r\nerror = PTR_ERR(hib_resume_bdev);\r\n}\r\nif (error)\r\npr_debug("PM: Image not found (code %d)\n", error);\r\nreturn error;\r\n}\r\nvoid swsusp_close(fmode_t mode)\r\n{\r\nif (IS_ERR(hib_resume_bdev)) {\r\npr_debug("PM: Image device not initialised\n");\r\nreturn;\r\n}\r\nblkdev_put(hib_resume_bdev, mode);\r\n}\r\nstatic int swsusp_header_init(void)\r\n{\r\nswsusp_header = (struct swsusp_header*) __get_free_page(GFP_KERNEL);\r\nif (!swsusp_header)\r\npanic("Could not allocate memory for swsusp_header\n");\r\nreturn 0;\r\n}
