static int wm8961_volatile_register(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8961_SOFTWARE_RESET:\r\ncase WM8961_WRITE_SEQUENCER_7:\r\ncase WM8961_DC_SERVO_1:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int wm8961_reset(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_write(codec, WM8961_SOFTWARE_RESET, 0);\r\n}\r\nstatic int wm8961_hp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nu16 hp_reg = snd_soc_read(codec, WM8961_ANALOGUE_HP_0);\r\nu16 cp_reg = snd_soc_read(codec, WM8961_CHARGE_PUMP_1);\r\nu16 pwr_reg = snd_soc_read(codec, WM8961_PWR_MGMT_2);\r\nu16 dcs_reg = snd_soc_read(codec, WM8961_DC_SERVO_1);\r\nint timeout = 500;\r\nif (event & SND_SOC_DAPM_POST_PMU) {\r\nhp_reg &= ~(WM8961_HPR_RMV_SHORT | WM8961_HPL_RMV_SHORT);\r\nsnd_soc_write(codec, WM8961_ANALOGUE_HP_0, hp_reg);\r\ncp_reg |= WM8961_CP_ENA;\r\nsnd_soc_write(codec, WM8961_CHARGE_PUMP_1, cp_reg);\r\nmdelay(5);\r\npwr_reg |= WM8961_LOUT1_PGA | WM8961_ROUT1_PGA;\r\nsnd_soc_write(codec, WM8961_PWR_MGMT_2, pwr_reg);\r\nhp_reg |= WM8961_HPR_ENA | WM8961_HPL_ENA;\r\nsnd_soc_write(codec, WM8961_ANALOGUE_HP_0, hp_reg);\r\nhp_reg |= WM8961_HPR_ENA_DLY | WM8961_HPL_ENA_DLY;\r\nsnd_soc_write(codec, WM8961_ANALOGUE_HP_0, hp_reg);\r\ndcs_reg |=\r\nWM8961_DCS_ENA_CHAN_HPR | WM8961_DCS_TRIG_STARTUP_HPR |\r\nWM8961_DCS_ENA_CHAN_HPL | WM8961_DCS_TRIG_STARTUP_HPL;\r\ndev_dbg(codec->dev, "Enabling DC servo\n");\r\nsnd_soc_write(codec, WM8961_DC_SERVO_1, dcs_reg);\r\ndo {\r\nmsleep(1);\r\ndcs_reg = snd_soc_read(codec, WM8961_DC_SERVO_1);\r\n} while (--timeout &&\r\ndcs_reg & (WM8961_DCS_TRIG_STARTUP_HPR |\r\nWM8961_DCS_TRIG_STARTUP_HPL));\r\nif (dcs_reg & (WM8961_DCS_TRIG_STARTUP_HPR |\r\nWM8961_DCS_TRIG_STARTUP_HPL))\r\ndev_err(codec->dev, "DC servo timed out\n");\r\nelse\r\ndev_dbg(codec->dev, "DC servo startup complete\n");\r\nhp_reg |= WM8961_HPR_ENA_OUTP | WM8961_HPL_ENA_OUTP;\r\nsnd_soc_write(codec, WM8961_ANALOGUE_HP_0, hp_reg);\r\nhp_reg |= WM8961_HPR_RMV_SHORT | WM8961_HPL_RMV_SHORT;\r\nsnd_soc_write(codec, WM8961_ANALOGUE_HP_0, hp_reg);\r\n}\r\nif (event & SND_SOC_DAPM_PRE_PMD) {\r\nhp_reg &= ~(WM8961_HPR_RMV_SHORT | WM8961_HPL_RMV_SHORT);\r\nsnd_soc_write(codec, WM8961_ANALOGUE_HP_0, hp_reg);\r\nhp_reg &= ~(WM8961_HPR_ENA_OUTP | WM8961_HPL_ENA_OUTP);\r\nsnd_soc_write(codec, WM8961_ANALOGUE_HP_0, hp_reg);\r\ndcs_reg &= ~(WM8961_DCS_ENA_CHAN_HPR |\r\nWM8961_DCS_ENA_CHAN_HPL);\r\nsnd_soc_write(codec, WM8961_DC_SERVO_1, dcs_reg);\r\nhp_reg &= ~(WM8961_HPR_ENA_DLY | WM8961_HPR_ENA |\r\nWM8961_HPL_ENA_DLY | WM8961_HPL_ENA);\r\nsnd_soc_write(codec, WM8961_ANALOGUE_HP_0, hp_reg);\r\npwr_reg &= ~(WM8961_LOUT1_PGA | WM8961_ROUT1_PGA);\r\nsnd_soc_write(codec, WM8961_PWR_MGMT_2, pwr_reg);\r\ndev_dbg(codec->dev, "Disabling charge pump\n");\r\nsnd_soc_write(codec, WM8961_CHARGE_PUMP_1,\r\ncp_reg & ~WM8961_CP_ENA);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8961_spk_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nu16 pwr_reg = snd_soc_read(codec, WM8961_PWR_MGMT_2);\r\nu16 spk_reg = snd_soc_read(codec, WM8961_CLASS_D_CONTROL_1);\r\nif (event & SND_SOC_DAPM_POST_PMU) {\r\npwr_reg |= WM8961_SPKL_PGA | WM8961_SPKR_PGA;\r\nsnd_soc_write(codec, WM8961_PWR_MGMT_2, pwr_reg);\r\nspk_reg |= WM8961_SPKL_ENA | WM8961_SPKR_ENA;\r\nsnd_soc_write(codec, WM8961_CLASS_D_CONTROL_1, spk_reg);\r\n}\r\nif (event & SND_SOC_DAPM_PRE_PMD) {\r\nspk_reg &= ~(WM8961_SPKL_ENA | WM8961_SPKR_ENA);\r\nsnd_soc_write(codec, WM8961_CLASS_D_CONTROL_1, spk_reg);\r\npwr_reg &= ~(WM8961_SPKL_PGA | WM8961_SPKR_PGA);\r\nsnd_soc_write(codec, WM8961_PWR_MGMT_2, pwr_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8961_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8961_priv *wm8961 = snd_soc_codec_get_drvdata(codec);\r\nint i, best, target, fs;\r\nu16 reg;\r\nfs = params_rate(params);\r\nif (!wm8961->sysclk) {\r\ndev_err(codec->dev, "MCLK has not been specified\n");\r\nreturn -EINVAL;\r\n}\r\nbest = 0;\r\nfor (i = 0; i < ARRAY_SIZE(wm8961_srate); i++) {\r\nif (abs(wm8961_srate[i].rate - fs) <\r\nabs(wm8961_srate[best].rate - fs))\r\nbest = i;\r\n}\r\nreg = snd_soc_read(codec, WM8961_ADDITIONAL_CONTROL_3);\r\nreg &= ~WM8961_SAMPLE_RATE_MASK;\r\nreg |= wm8961_srate[best].val;\r\nsnd_soc_write(codec, WM8961_ADDITIONAL_CONTROL_3, reg);\r\ndev_dbg(codec->dev, "Selected SRATE %dHz for %dHz\n",\r\nwm8961_srate[best].rate, fs);\r\ntarget = wm8961->sysclk / fs;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK && target < 64) {\r\ndev_err(codec->dev,\r\n"SYSCLK must be at least 64*fs for DAC\n");\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE && target < 256) {\r\ndev_err(codec->dev,\r\n"SYSCLK must be at least 256*fs for ADC\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm8961_clk_sys_ratio); i++) {\r\nif (wm8961_clk_sys_ratio[i].ratio >= target)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(wm8961_clk_sys_ratio)) {\r\ndev_err(codec->dev, "Unable to generate CLK_SYS_RATE\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "Selected CLK_SYS_RATE of %d for %d/%d=%d\n",\r\nwm8961_clk_sys_ratio[i].ratio, wm8961->sysclk, fs,\r\nwm8961->sysclk / fs);\r\nreg = snd_soc_read(codec, WM8961_CLOCKING_4);\r\nreg &= ~WM8961_CLK_SYS_RATE_MASK;\r\nreg |= wm8961_clk_sys_ratio[i].val << WM8961_CLK_SYS_RATE_SHIFT;\r\nsnd_soc_write(codec, WM8961_CLOCKING_4, reg);\r\nreg = snd_soc_read(codec, WM8961_AUDIO_INTERFACE_0);\r\nreg &= ~WM8961_WL_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nreg |= 1 << WM8961_WL_SHIFT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nreg |= 2 << WM8961_WL_SHIFT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nreg |= 3 << WM8961_WL_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8961_AUDIO_INTERFACE_0, reg);\r\nreg = snd_soc_read(codec, WM8961_ADC_DAC_CONTROL_2);\r\nif (fs <= 24000)\r\nreg |= WM8961_DACSLOPE;\r\nelse\r\nreg &= ~WM8961_DACSLOPE;\r\nsnd_soc_write(codec, WM8961_ADC_DAC_CONTROL_2, reg);\r\nreturn 0;\r\n}\r\nstatic int wm8961_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq,\r\nint dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8961_priv *wm8961 = snd_soc_codec_get_drvdata(codec);\r\nu16 reg = snd_soc_read(codec, WM8961_CLOCKING1);\r\nif (freq > 33000000) {\r\ndev_err(codec->dev, "MCLK must be <33MHz\n");\r\nreturn -EINVAL;\r\n}\r\nif (freq > 16500000) {\r\ndev_dbg(codec->dev, "Using MCLK/2 for %dHz MCLK\n", freq);\r\nreg |= WM8961_MCLKDIV;\r\nfreq /= 2;\r\n} else {\r\ndev_dbg(codec->dev, "Using MCLK/1 for %dHz MCLK\n", freq);\r\nreg &= ~WM8961_MCLKDIV;\r\n}\r\nsnd_soc_write(codec, WM8961_CLOCKING1, reg);\r\nwm8961->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int wm8961_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 aif = snd_soc_read(codec, WM8961_AUDIO_INTERFACE_0);\r\naif &= ~(WM8961_BCLKINV | WM8961_LRP |\r\nWM8961_MS | WM8961_FORMAT_MASK);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naif |= WM8961_MS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif |= 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif |= 2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif |= WM8961_LRP;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif |= 3;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif |= WM8961_LRP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif |= WM8961_BCLKINV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif |= WM8961_BCLKINV | WM8961_LRP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_write(codec, WM8961_AUDIO_INTERFACE_0, aif);\r\n}\r\nstatic int wm8961_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 reg = snd_soc_read(codec, WM8961_ADDITIONAL_CONTROL_2);\r\nif (tristate)\r\nreg |= WM8961_TRIS;\r\nelse\r\nreg &= ~WM8961_TRIS;\r\nreturn snd_soc_write(codec, WM8961_ADDITIONAL_CONTROL_2, reg);\r\n}\r\nstatic int wm8961_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 reg = snd_soc_read(codec, WM8961_ADC_DAC_CONTROL_1);\r\nif (mute)\r\nreg |= WM8961_DACMU;\r\nelse\r\nreg &= ~WM8961_DACMU;\r\nmsleep(17);\r\nreturn snd_soc_write(codec, WM8961_ADC_DAC_CONTROL_1, reg);\r\n}\r\nstatic int wm8961_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 reg;\r\nswitch (div_id) {\r\ncase WM8961_BCLK:\r\nreg = snd_soc_read(codec, WM8961_CLOCKING2);\r\nreg &= ~WM8961_BCLKDIV_MASK;\r\nreg |= div;\r\nsnd_soc_write(codec, WM8961_CLOCKING2, reg);\r\nbreak;\r\ncase WM8961_LRCLK:\r\nreg = snd_soc_read(codec, WM8961_AUDIO_INTERFACE_2);\r\nreg &= ~WM8961_LRCLK_RATE_MASK;\r\nreg |= div;\r\nsnd_soc_write(codec, WM8961_AUDIO_INTERFACE_2, reg);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8961_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 reg;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_STANDBY) {\r\nreg = snd_soc_read(codec, WM8961_ANTI_POP);\r\nreg |= WM8961_BUFIOEN | WM8961_BUFDCOPEN;\r\nsnd_soc_write(codec, WM8961_ANTI_POP, reg);\r\nreg = snd_soc_read(codec, WM8961_PWR_MGMT_1);\r\nreg &= ~WM8961_VMIDSEL_MASK;\r\nreg |= (1 << WM8961_VMIDSEL_SHIFT) | WM8961_VREF;\r\nsnd_soc_write(codec, WM8961_PWR_MGMT_1, reg);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_PREPARE) {\r\nreg = snd_soc_read(codec, WM8961_PWR_MGMT_1);\r\nreg &= ~WM8961_VREF;\r\nsnd_soc_write(codec, WM8961_PWR_MGMT_1, reg);\r\nreg = snd_soc_read(codec, WM8961_ANTI_POP);\r\nreg &= ~(WM8961_BUFIOEN | WM8961_BUFDCOPEN);\r\nsnd_soc_write(codec, WM8961_ANTI_POP, reg);\r\nreg = snd_soc_read(codec, WM8961_PWR_MGMT_1);\r\nreg &= ~WM8961_VMIDSEL_MASK;\r\nsnd_soc_write(codec, WM8961_PWR_MGMT_1, reg);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8961_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint ret = 0;\r\nu16 reg;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_I2C);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nreg = snd_soc_read(codec, WM8961_SOFTWARE_RESET);\r\nif (reg != 0x1801) {\r\ndev_err(codec->dev, "Device is not a WM8961: ID=0x%x\n", reg);\r\nreturn -EINVAL;\r\n}\r\nreg = codec->hw_read(codec, WM8961_RIGHT_INPUT_VOLUME);\r\ndev_info(codec->dev, "WM8961 family %d revision %c\n",\r\n(reg & WM8961_DEVICE_ID_MASK) >> WM8961_DEVICE_ID_SHIFT,\r\n((reg & WM8961_CHIP_REV_MASK) >> WM8961_CHIP_REV_SHIFT)\r\n+ 'A');\r\nret = wm8961_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset\n");\r\nreturn ret;\r\n}\r\nreg = snd_soc_read(codec, WM8961_CHARGE_PUMP_B);\r\nreg |= WM8961_CP_DYN_PWR_MASK;\r\nsnd_soc_write(codec, WM8961_CHARGE_PUMP_B, reg);\r\nreg = snd_soc_read(codec, WM8961_ROUT1_VOLUME);\r\nsnd_soc_write(codec, WM8961_ROUT1_VOLUME,\r\nreg | WM8961_LO1ZC | WM8961_OUT1VU);\r\nsnd_soc_write(codec, WM8961_LOUT1_VOLUME, reg | WM8961_LO1ZC);\r\nreg = snd_soc_read(codec, WM8961_ROUT2_VOLUME);\r\nsnd_soc_write(codec, WM8961_ROUT2_VOLUME,\r\nreg | WM8961_SPKRZC | WM8961_SPKVU);\r\nsnd_soc_write(codec, WM8961_LOUT2_VOLUME, reg | WM8961_SPKLZC);\r\nreg = snd_soc_read(codec, WM8961_RIGHT_ADC_VOLUME);\r\nsnd_soc_write(codec, WM8961_RIGHT_ADC_VOLUME, reg | WM8961_ADCVU);\r\nreg = snd_soc_read(codec, WM8961_RIGHT_INPUT_VOLUME);\r\nsnd_soc_write(codec, WM8961_RIGHT_INPUT_VOLUME, reg | WM8961_IPVU);\r\nreg = snd_soc_read(codec, WM8961_ADC_DAC_CONTROL_2);\r\nreg |= WM8961_DACSMM;\r\nsnd_soc_write(codec, WM8961_ADC_DAC_CONTROL_2, reg);\r\nreg = snd_soc_read(codec, WM8961_CLOCKING_3);\r\nreg &= ~WM8961_MANUAL_MODE;\r\nsnd_soc_write(codec, WM8961_CLOCKING_3, reg);\r\nwm8961_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_add_controls(codec, wm8961_snd_controls,\r\nARRAY_SIZE(wm8961_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, wm8961_dapm_widgets,\r\nARRAY_SIZE(wm8961_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, audio_paths, ARRAY_SIZE(audio_paths));\r\nreturn 0;\r\n}\r\nstatic int wm8961_remove(struct snd_soc_codec *codec)\r\n{\r\nwm8961_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8961_suspend(struct snd_soc_codec *codec, pm_message_t state)\r\n{\r\nwm8961_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8961_resume(struct snd_soc_codec *codec)\r\n{\r\nu16 *reg_cache = codec->reg_cache;\r\nint i;\r\nfor (i = 0; i < codec->driver->reg_cache_size; i++) {\r\nif (reg_cache[i] == wm8961_reg_defaults[i])\r\ncontinue;\r\nif (i == WM8961_SOFTWARE_RESET)\r\ncontinue;\r\nsnd_soc_write(codec, i, reg_cache[i]);\r\n}\r\nwm8961_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic __devinit int wm8961_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8961_priv *wm8961;\r\nint ret;\r\nwm8961 = kzalloc(sizeof(struct wm8961_priv), GFP_KERNEL);\r\nif (wm8961 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8961);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8961, &wm8961_dai, 1);\r\nif (ret < 0)\r\nkfree(wm8961);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm8961_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int __init wm8961_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&wm8961_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8961 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8961_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&wm8961_i2c_driver);\r\n#endif\r\n}
