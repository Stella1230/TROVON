static int nova_t_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nu8 key[5],cmd[2] = { DIBUSB_REQ_POLL_REMOTE, 0x35 }, data,toggle,custom;\r\nu16 raw;\r\nint i;\r\nstruct dibusb_device_state *st = d->priv;\r\ndvb_usb_generic_rw(d,cmd,2,key,5,0);\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nswitch (key[0]) {\r\ncase DIBUSB_RC_HAUPPAUGE_KEY_PRESSED:\r\nraw = ((key[1] << 8) | key[2]) >> 3;\r\ntoggle = !!(raw & 0x800);\r\ndata = raw & 0x3f;\r\ncustom = (raw >> 6) & 0x1f;\r\ndeb_rc("raw key code 0x%02x, 0x%02x, 0x%02x to c: %02x d: %02x toggle: %d\n",key[1],key[2],key[3],custom,data,toggle);\r\nfor (i = 0; i < ARRAY_SIZE(rc_map_haupp_table); i++) {\r\nif (rc5_data(&rc_map_haupp_table[i]) == data &&\r\nrc5_custom(&rc_map_haupp_table[i]) == custom) {\r\ndeb_rc("c: %x, d: %x\n", rc5_data(&rc_map_haupp_table[i]),\r\nrc5_custom(&rc_map_haupp_table[i]));\r\n*event = rc_map_haupp_table[i].keycode;\r\n*state = REMOTE_KEY_PRESSED;\r\nif (st->old_toggle == toggle) {\r\nif (st->last_repeat_count++ < 2)\r\n*state = REMOTE_NO_KEY_PRESSED;\r\n} else {\r\nst->last_repeat_count = 0;\r\nst->old_toggle = toggle;\r\n}\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase DIBUSB_RC_HAUPPAUGE_KEY_EMPTY:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nova_t_read_mac_address (struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nint i;\r\nu8 b;\r\nmac[0] = 0x00;\r\nmac[1] = 0x0d;\r\nmac[2] = 0xfe;\r\nfor (i = 136; i < 139; i++) {\r\ndibusb_read_eeprom_byte(d,i, &b);\r\nmac[5 - (i - 136)] = b;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nova_t_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn dvb_usb_device_init(intf, &nova_t_properties,\r\nTHIS_MODULE, NULL, adapter_nr);\r\n}\r\nstatic int __init nova_t_module_init(void)\r\n{\r\nint result;\r\nif ((result = usb_register(&nova_t_driver))) {\r\nerr("usb_register failed. Error number %d",result);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit nova_t_module_exit(void)\r\n{\r\nusb_deregister(&nova_t_driver);\r\n}
