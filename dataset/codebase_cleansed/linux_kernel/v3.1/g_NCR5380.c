static void __init internal_setup(int board, char *str, int *ints)\r\n{\r\nstatic int commandline_current = 0;\r\nswitch (board) {\r\ncase BOARD_NCR5380:\r\nif (ints[0] != 2 && ints[0] != 3) {\r\nprintk(KERN_ERR "generic_NCR5380_setup : usage ncr5380=" STRVAL(NCR5380_map_name) ",irq,dma\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase BOARD_NCR53C400:\r\nif (ints[0] != 2) {\r\nprintk(KERN_ERR "generic_NCR53C400_setup : usage ncr53c400=" STRVAL(NCR5380_map_name) ",irq\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase BOARD_NCR53C400A:\r\nif (ints[0] != 2) {\r\nprintk(KERN_ERR "generic_NCR53C400A_setup : usage ncr53c400a=" STRVAL(NCR5380_map_name) ",irq\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase BOARD_DTC3181E:\r\nif (ints[0] != 2) {\r\nprintk("generic_DTC3181E_setup : usage dtc3181e=" STRVAL(NCR5380_map_name) ",irq\n");\r\nreturn;\r\n}\r\nbreak;\r\n}\r\nif (commandline_current < NO_OVERRIDES) {\r\noverrides[commandline_current].NCR5380_map_name = (NCR5380_map_type) ints[1];\r\noverrides[commandline_current].irq = ints[2];\r\nif (ints[0] == 3)\r\noverrides[commandline_current].dma = ints[3];\r\nelse\r\noverrides[commandline_current].dma = DMA_NONE;\r\noverrides[commandline_current].board = board;\r\n++commandline_current;\r\n}\r\n}\r\nstatic int __init do_NCR5380_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\ninternal_setup(BOARD_NCR5380, str, ints);\r\nreturn 1;\r\n}\r\nstatic int __init do_NCR53C400_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\ninternal_setup(BOARD_NCR53C400, str, ints);\r\nreturn 1;\r\n}\r\nstatic int __init do_NCR53C400A_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\ninternal_setup(BOARD_NCR53C400A, str, ints);\r\nreturn 1;\r\n}\r\nstatic int __init do_DTC3181E_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\ninternal_setup(BOARD_DTC3181E, str, ints);\r\nreturn 1;\r\n}\r\nint __init generic_NCR5380_detect(struct scsi_host_template * tpnt)\r\n{\r\nstatic int current_override = 0;\r\nint count;\r\nunsigned int *ports;\r\n#ifndef SCSI_G_NCR5380_MEM\r\nint i;\r\nunsigned long region_size = 16;\r\n#endif\r\nstatic unsigned int __initdata ncr_53c400a_ports[] = {\r\n0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0\r\n};\r\nstatic unsigned int __initdata dtc_3181e_ports[] = {\r\n0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0\r\n};\r\nint flags = 0;\r\nstruct Scsi_Host *instance;\r\n#ifdef SCSI_G_NCR5380_MEM\r\nunsigned long base;\r\nvoid __iomem *iomem;\r\n#endif\r\nif (ncr_irq != NCR_NOT_SET)\r\noverrides[0].irq = ncr_irq;\r\nif (ncr_dma != NCR_NOT_SET)\r\noverrides[0].dma = ncr_dma;\r\nif (ncr_addr != NCR_NOT_SET)\r\noverrides[0].NCR5380_map_name = (NCR5380_map_type) ncr_addr;\r\nif (ncr_5380 != NCR_NOT_SET)\r\noverrides[0].board = BOARD_NCR5380;\r\nelse if (ncr_53c400 != NCR_NOT_SET)\r\noverrides[0].board = BOARD_NCR53C400;\r\nelse if (ncr_53c400a != NCR_NOT_SET)\r\noverrides[0].board = BOARD_NCR53C400A;\r\nelse if (dtc_3181e != NCR_NOT_SET)\r\noverrides[0].board = BOARD_DTC3181E;\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (!current_override && isapnp_present()) {\r\nstruct pnp_dev *dev = NULL;\r\ncount = 0;\r\nwhile ((dev = pnp_find_dev(NULL, ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e), dev))) {\r\nif (count >= NO_OVERRIDES)\r\nbreak;\r\nif (pnp_device_attach(dev) < 0)\r\ncontinue;\r\nif (pnp_activate_dev(dev) < 0) {\r\nprintk(KERN_ERR "dtc436e probe: activate failed\n");\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nif (!pnp_port_valid(dev, 0)) {\r\nprintk(KERN_ERR "dtc436e probe: no valid port\n");\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nif (pnp_irq_valid(dev, 0))\r\noverrides[count].irq = pnp_irq(dev, 0);\r\nelse\r\noverrides[count].irq = SCSI_IRQ_NONE;\r\nif (pnp_dma_valid(dev, 0))\r\noverrides[count].dma = pnp_dma(dev, 0);\r\nelse\r\noverrides[count].dma = DMA_NONE;\r\noverrides[count].NCR5380_map_name = (NCR5380_map_type) pnp_port_start(dev, 0);\r\noverrides[count].board = BOARD_DTC3181E;\r\ncount++;\r\n}\r\n}\r\n#endif\r\ntpnt->proc_name = "g_NCR5380";\r\nfor (count = 0; current_override < NO_OVERRIDES; ++current_override) {\r\nif (!(overrides[current_override].NCR5380_map_name))\r\ncontinue;\r\nports = NULL;\r\nswitch (overrides[current_override].board) {\r\ncase BOARD_NCR5380:\r\nflags = FLAG_NO_PSEUDO_DMA;\r\nbreak;\r\ncase BOARD_NCR53C400:\r\nflags = FLAG_NCR53C400;\r\nbreak;\r\ncase BOARD_NCR53C400A:\r\nflags = FLAG_NO_PSEUDO_DMA;\r\nports = ncr_53c400a_ports;\r\nbreak;\r\ncase BOARD_DTC3181E:\r\nflags = FLAG_NO_PSEUDO_DMA | FLAG_DTC3181E;\r\nports = dtc_3181e_ports;\r\nbreak;\r\n}\r\n#ifndef SCSI_G_NCR5380_MEM\r\nif (ports) {\r\noutb(0x59, 0x779);\r\noutb(0xb9, 0x379);\r\noutb(0xc5, 0x379);\r\noutb(0xae, 0x379);\r\noutb(0xa6, 0x379);\r\noutb(0x00, 0x379);\r\nif (overrides[current_override].NCR5380_map_name != PORT_AUTO)\r\nfor (i = 0; ports[i]; i++) {\r\nif (!request_region(ports[i], 16, "ncr53c80"))\r\ncontinue;\r\nif (overrides[current_override].NCR5380_map_name == ports[i])\r\nbreak;\r\nrelease_region(ports[i], 16);\r\n} else\r\nfor (i = 0; ports[i]; i++) {\r\nif (!request_region(ports[i], 16, "ncr53c80"))\r\ncontinue;\r\nif (inb(ports[i]) == 0xff)\r\nbreak;\r\nrelease_region(ports[i], 16);\r\n}\r\nif (ports[i]) {\r\noutb(0x59, 0x779);\r\noutb(0xb9, 0x379);\r\noutb(0xc5, 0x379);\r\noutb(0xae, 0x379);\r\noutb(0xa6, 0x379);\r\noutb(0x80 | i, 0x379);\r\noutb(0xc0, ports[i] + 9);\r\nif (inb(ports[i] + 9) != 0x80)\r\ncontinue;\r\nelse\r\noverrides[current_override].NCR5380_map_name = ports[i];\r\n} else\r\ncontinue;\r\n}\r\nelse\r\n{\r\nif(!(request_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size, "ncr5380")))\r\ncontinue;\r\nregion_size = NCR5380_region_size;\r\n}\r\n#else\r\nbase = overrides[current_override].NCR5380_map_name;\r\nif (!request_mem_region(base, NCR5380_region_size, "ncr5380"))\r\ncontinue;\r\niomem = ioremap(base, NCR5380_region_size);\r\nif (!iomem) {\r\nrelease_mem_region(base, NCR5380_region_size);\r\ncontinue;\r\n}\r\n#endif\r\ninstance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));\r\nif (instance == NULL) {\r\n#ifndef SCSI_G_NCR5380_MEM\r\nrelease_region(overrides[current_override].NCR5380_map_name, region_size);\r\n#else\r\niounmap(iomem);\r\nrelease_mem_region(base, NCR5380_region_size);\r\n#endif\r\ncontinue;\r\n}\r\ninstance->NCR5380_instance_name = overrides[current_override].NCR5380_map_name;\r\n#ifndef SCSI_G_NCR5380_MEM\r\ninstance->n_io_port = region_size;\r\n#else\r\n((struct NCR5380_hostdata *)instance->hostdata)->iomem = iomem;\r\n#endif\r\nNCR5380_init(instance, flags);\r\nif (overrides[current_override].irq != IRQ_AUTO)\r\ninstance->irq = overrides[current_override].irq;\r\nelse\r\ninstance->irq = NCR5380_probe_irq(instance, 0xffff);\r\nif (instance->irq != SCSI_IRQ_NONE)\r\nif (request_irq(instance->irq, generic_NCR5380_intr,\r\nIRQF_DISABLED, "NCR5380", instance)) {\r\nprintk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);\r\ninstance->irq = SCSI_IRQ_NONE;\r\n}\r\nif (instance->irq == SCSI_IRQ_NONE) {\r\nprintk(KERN_INFO "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);\r\nprintk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);\r\n}\r\nprintk(KERN_INFO "scsi%d : at " STRVAL(NCR5380_map_name) " 0x%x", instance->host_no, (unsigned int) instance->NCR5380_instance_name);\r\nif (instance->irq == SCSI_IRQ_NONE)\r\nprintk(" interrupts disabled");\r\nelse\r\nprintk(" irq %d", instance->irq);\r\nprintk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d", CAN_QUEUE, CMD_PER_LUN, GENERIC_NCR5380_PUBLIC_RELEASE);\r\nNCR5380_print_options(instance);\r\nprintk("\n");\r\n++current_override;\r\n++count;\r\n}\r\nreturn count;\r\n}\r\nconst char *generic_NCR5380_info(struct Scsi_Host *host)\r\n{\r\nstatic const char string[] = "Generic NCR5380/53C400 Driver";\r\nreturn string;\r\n}\r\nint generic_NCR5380_release_resources(struct Scsi_Host *instance)\r\n{\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\nif (instance->irq != SCSI_IRQ_NONE)\r\nfree_irq(instance->irq, instance);\r\nNCR5380_exit(instance);\r\n#ifndef SCSI_G_NCR5380_MEM\r\nrelease_region(instance->NCR5380_instance_name, instance->n_io_port);\r\n#else\r\niounmap(((struct NCR5380_hostdata *)instance->hostdata)->iomem);\r\nrelease_mem_region(instance->NCR5380_instance_name, NCR5380_region_size);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\ngeneric_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int *ip)\r\n{\r\nip[0] = 64;\r\nip[1] = 32;\r\nip[2] = capacity >> 11;\r\nreturn 0;\r\n}\r\nstatic inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst, int len)\r\n{\r\nint blocks = len / 128;\r\nint start = 0;\r\nint bl;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\nNCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE | CSR_TRANS_DIR);\r\nNCR5380_write(C400_BLOCK_COUNTER_REG, blocks);\r\nwhile (1) {\r\nif ((bl = NCR5380_read(C400_BLOCK_COUNTER_REG)) == 0) {\r\nbreak;\r\n}\r\nif (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ) {\r\nprintk(KERN_ERR "53C400r: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);\r\nreturn -1;\r\n}\r\nwhile (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY);\r\n#ifndef SCSI_G_NCR5380_MEM\r\n{\r\nint i;\r\nfor (i = 0; i < 128; i++)\r\ndst[start + i] = NCR5380_read(C400_HOST_BUFFER);\r\n}\r\n#else\r\nmemcpy_fromio(dst + start, iomem + NCR53C400_host_buffer, 128);\r\n#endif\r\nstart += 128;\r\nblocks--;\r\n}\r\nif (blocks) {\r\nwhile (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)\r\n{\r\n}\r\n#ifndef SCSI_G_NCR5380_MEM\r\n{\r\nint i;\r\nfor (i = 0; i < 128; i++)\r\ndst[start + i] = NCR5380_read(C400_HOST_BUFFER);\r\n}\r\n#else\r\nmemcpy_fromio(dst + start, iomem + NCR53C400_host_buffer, 128);\r\n#endif\r\nstart += 128;\r\nblocks--;\r\n}\r\nif (!(NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ))\r\nprintk("53C400r: no 53C80 gated irq after transfer");\r\n#if 0\r\nprintk("53C400r: Waiting for 53C80 registers\n");\r\nwhile (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_53C80_REG)\r\n;\r\n#endif\r\nif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER))\r\nprintk(KERN_ERR "53C400r: no end dma signal\n");\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nreturn 0;\r\n}\r\nstatic inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src, int len)\r\n{\r\nint blocks = len / 128;\r\nint start = 0;\r\nint bl;\r\nint i;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\nNCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);\r\nNCR5380_write(C400_BLOCK_COUNTER_REG, blocks);\r\nwhile (1) {\r\nif (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ) {\r\nprintk(KERN_ERR "53C400w: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);\r\nreturn -1;\r\n}\r\nif ((bl = NCR5380_read(C400_BLOCK_COUNTER_REG)) == 0) {\r\nbreak;\r\n}\r\nwhile (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)\r\n;\r\n#ifndef SCSI_G_NCR5380_MEM\r\n{\r\nfor (i = 0; i < 128; i++)\r\nNCR5380_write(C400_HOST_BUFFER, src[start + i]);\r\n}\r\n#else\r\nmemcpy_toio(iomem + NCR53C400_host_buffer, src + start, 128);\r\n#endif\r\nstart += 128;\r\nblocks--;\r\n}\r\nif (blocks) {\r\nwhile (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)\r\n;\r\n#ifndef SCSI_G_NCR5380_MEM\r\n{\r\nfor (i = 0; i < 128; i++)\r\nNCR5380_write(C400_HOST_BUFFER, src[start + i]);\r\n}\r\n#else\r\nmemcpy_toio(iomem + NCR53C400_host_buffer, src + start, 128);\r\n#endif\r\nstart += 128;\r\nblocks--;\r\n}\r\n#if 0\r\nprintk("53C400w: waiting for registers to be available\n");\r\nTHEY NEVER DO ! while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_53C80_REG);\r\nprintk("53C400w: Got em\n");\r\n#endif\r\nwhile (!(i = NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ))\r\n;\r\nif (i) {\r\nif (!((i = NCR5380_read(BUS_AND_STATUS_REG)) & BASR_END_DMA_TRANSFER))\r\nprintk(KERN_ERR "53C400w: No END OF DMA bit - WHOOPS! BASR=%0x\n", i);\r\n} else\r\nprintk(KERN_ERR "53C400w: no 53C80 gated irq after transfer (last block)\n");\r\n#if 0\r\nif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER)) {\r\nprintk(KERN_ERR "53C400w: no end dma signal\n");\r\n}\r\n#endif\r\nwhile (!(NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT))\r\n;\r\nreturn 0;\r\n}\r\nstatic int sprint_opcode(char *buffer, int len, int opcode)\r\n{\r\nint start = len;\r\nPRINTP("0x%02x " ANDP opcode);\r\nreturn len - start;\r\n}\r\nstatic int sprint_command(char *buffer, int len, unsigned char *command)\r\n{\r\nint i, s, start = len;\r\nlen += sprint_opcode(buffer, len, command[0]);\r\nfor (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)\r\nPRINTP("%02x " ANDP command[i]);\r\nPRINTP("\n");\r\nreturn len - start;\r\n}\r\nstatic int sprint_Scsi_Cmnd(char *buffer, int len, Scsi_Cmnd * cmd)\r\n{\r\nint start = len;\r\nPRINTP("host number %d destination target %d, lun %d\n" ANDP cmd->device->host->host_no ANDP cmd->device->id ANDP cmd->device->lun);\r\nPRINTP(" command = ");\r\nlen += sprint_command(buffer, len, cmd->cmnd);\r\nreturn len - start;\r\n}\r\nstatic int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, char **start, off_t offset, int length, int inout)\r\n{\r\nint len = 0;\r\nNCR5380_local_declare();\r\nunsigned long flags;\r\nunsigned char status;\r\nint i;\r\nScsi_Cmnd *ptr;\r\nstruct NCR5380_hostdata *hostdata;\r\n#ifdef NCR5380_STATS\r\nstruct scsi_device *dev;\r\n#endif\r\nNCR5380_setup(scsi_ptr);\r\nhostdata = (struct NCR5380_hostdata *) scsi_ptr->hostdata;\r\nspin_lock_irqsave(scsi_ptr->host_lock, flags);\r\nPRINTP("SCSI host number %d : %s\n" ANDP scsi_ptr->host_no ANDP scsi_ptr->hostt->name);\r\nPRINTP("Generic NCR5380 driver version %d\n" ANDP GENERIC_NCR5380_PUBLIC_RELEASE);\r\nPRINTP("NCR5380 core version %d\n" ANDP NCR5380_PUBLIC_RELEASE);\r\n#ifdef NCR53C400\r\nPRINTP("NCR53C400 extension version %d\n" ANDP NCR53C400_PUBLIC_RELEASE);\r\nPRINTP("NCR53C400 card%s detected\n" ANDP(((struct NCR5380_hostdata *) scsi_ptr->hostdata)->flags & FLAG_NCR53C400) ? "" : " not");\r\n# if NCR53C400_PSEUDO_DMA\r\nPRINTP("NCR53C400 pseudo DMA used\n");\r\n# endif\r\n#else\r\nPRINTP("NO NCR53C400 driver extensions\n");\r\n#endif\r\nPRINTP("Using %s mapping at %s 0x%lx, " ANDP STRVAL(NCR5380_map_config) ANDP STRVAL(NCR5380_map_name) ANDP scsi_ptr->NCR5380_instance_name);\r\nif (scsi_ptr->irq == SCSI_IRQ_NONE)\r\nPRINTP("no interrupt\n");\r\nelse\r\nPRINTP("on interrupt %d\n" ANDP scsi_ptr->irq);\r\n#ifdef NCR5380_STATS\r\nif (hostdata->connected || hostdata->issue_queue || hostdata->disconnected_queue)\r\nPRINTP("There are commands pending, transfer rates may be crud\n");\r\nif (hostdata->pendingr)\r\nPRINTP(" %d pending reads" ANDP hostdata->pendingr);\r\nif (hostdata->pendingw)\r\nPRINTP(" %d pending writes" ANDP hostdata->pendingw);\r\nif (hostdata->pendingr || hostdata->pendingw)\r\nPRINTP("\n");\r\nshost_for_each_device(dev, scsi_ptr) {\r\nunsigned long br = hostdata->bytes_read[dev->id];\r\nunsigned long bw = hostdata->bytes_write[dev->id];\r\nlong tr = hostdata->time_read[dev->id] / HZ;\r\nlong tw = hostdata->time_write[dev->id] / HZ;\r\nPRINTP(" T:%d %s " ANDP dev->id ANDP scsi_device_type(dev->type));\r\nfor (i = 0; i < 8; i++)\r\nif (dev->vendor[i] >= 0x20)\r\n*(buffer + (len++)) = dev->vendor[i];\r\n*(buffer + (len++)) = ' ';\r\nfor (i = 0; i < 16; i++)\r\nif (dev->model[i] >= 0x20)\r\n*(buffer + (len++)) = dev->model[i];\r\n*(buffer + (len++)) = ' ';\r\nfor (i = 0; i < 4; i++)\r\nif (dev->rev[i] >= 0x20)\r\n*(buffer + (len++)) = dev->rev[i];\r\n*(buffer + (len++)) = ' ';\r\nPRINTP("\n%10ld kb read in %5ld secs" ANDP br / 1024 ANDP tr);\r\nif (tr)\r\nPRINTP(" @ %5ld bps" ANDP br / tr);\r\nPRINTP("\n%10ld kb written in %5ld secs" ANDP bw / 1024 ANDP tw);\r\nif (tw)\r\nPRINTP(" @ %5ld bps" ANDP bw / tw);\r\nPRINTP("\n");\r\n}\r\n#endif\r\nstatus = NCR5380_read(STATUS_REG);\r\nif (!(status & SR_REQ))\r\nPRINTP("REQ not asserted, phase unknown.\n");\r\nelse {\r\nfor (i = 0; (phases[i].value != PHASE_UNKNOWN) && (phases[i].value != (status & PHASE_MASK)); ++i);\r\nPRINTP("Phase %s\n" ANDP phases[i].name);\r\n}\r\nif (!hostdata->connected) {\r\nPRINTP("No currently connected command\n");\r\n} else {\r\nlen += sprint_Scsi_Cmnd(buffer, len, (Scsi_Cmnd *) hostdata->connected);\r\n}\r\nPRINTP("issue_queue\n");\r\nfor (ptr = (Scsi_Cmnd *) hostdata->issue_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)\r\nlen += sprint_Scsi_Cmnd(buffer, len, ptr);\r\nPRINTP("disconnected_queue\n");\r\nfor (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)\r\nlen += sprint_Scsi_Cmnd(buffer, len, ptr);\r\n*start = buffer + offset;\r\nlen -= offset;\r\nif (len > length)\r\nlen = length;\r\nspin_unlock_irqrestore(scsi_ptr->host_lock, flags);\r\nreturn len;\r\n}
