static int af9005_write_word_agc(struct dvb_usb_device *d, u16 reghi,\r\nu16 reglo, u8 pos, u8 len, u16 value)\r\n{\r\nint ret;\r\nu8 temp;\r\nif ((ret = af9005_write_ofdm_register(d, reglo, (u8) (value & 0xff))))\r\nreturn ret;\r\ntemp = (u8) ((value & 0x0300) >> 8);\r\nreturn af9005_write_register_bits(d, reghi, pos, len,\r\n(u8) ((value & 0x300) >> 8));\r\n}\r\nstatic int af9005_read_word_agc(struct dvb_usb_device *d, u16 reghi,\r\nu16 reglo, u8 pos, u8 len, u16 * value)\r\n{\r\nint ret;\r\nu8 temp0, temp1;\r\nif ((ret = af9005_read_ofdm_register(d, reglo, &temp0)))\r\nreturn ret;\r\nif ((ret = af9005_read_ofdm_register(d, reghi, &temp1)))\r\nreturn ret;\r\nswitch (pos) {\r\ncase 0:\r\n*value = ((u16) (temp1 & 0x03) << 8) + (u16) temp0;\r\nbreak;\r\ncase 2:\r\n*value = ((u16) (temp1 & 0x0C) << 6) + (u16) temp0;\r\nbreak;\r\ncase 4:\r\n*value = ((u16) (temp1 & 0x30) << 4) + (u16) temp0;\r\nbreak;\r\ncase 6:\r\n*value = ((u16) (temp1 & 0xC0) << 2) + (u16) temp0;\r\nbreak;\r\ndefault:\r\nerr("invalid pos in read word agc");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_is_fecmon_available(struct dvb_frontend *fe, int *available)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 temp;\r\n*available = false;\r\nret = af9005_read_register_bits(state->d, xd_p_fec_vtb_rsd_mon_en,\r\nfec_vtb_rsd_mon_en_pos,\r\nfec_vtb_rsd_mon_en_len, &temp);\r\nif (ret)\r\nreturn ret;\r\nif (temp & 1) {\r\nret =\r\naf9005_read_register_bits(state->d,\r\nxd_p_reg_ofsm_read_rbc_en,\r\nreg_ofsm_read_rbc_en_pos,\r\nreg_ofsm_read_rbc_en_len, &temp);\r\nif (ret)\r\nreturn ret;\r\nif ((temp & 1) == 0)\r\n*available = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_get_post_vit_err_cw_count(struct dvb_frontend *fe,\r\nu32 * post_err_count,\r\nu32 * post_cw_count,\r\nu16 * abort_count)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nu32 err_count;\r\nu32 cw_count;\r\nu8 temp, temp0, temp1, temp2;\r\nu16 loc_abort_count;\r\n*post_err_count = 0;\r\n*post_cw_count = 0;\r\nret =\r\naf9005_read_register_bits(state->d, xd_r_fec_rsd_ber_rdy,\r\nfec_rsd_ber_rdy_pos, fec_rsd_ber_rdy_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\nif (!temp) {\r\ndeb_info("rsd counter not ready\n");\r\nreturn 100;\r\n}\r\nret =\r\naf9005_read_ofdm_register(state->d,\r\nxd_r_fec_rsd_abort_packet_cnt_7_0,\r\n&temp0);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_ofdm_register(state->d,\r\nxd_r_fec_rsd_abort_packet_cnt_15_8,\r\n&temp1);\r\nif (ret)\r\nreturn ret;\r\nloc_abort_count = ((u16) temp1 << 8) + temp0;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_7_0,\r\n&temp0);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_15_8,\r\n&temp1);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_23_16,\r\n&temp2);\r\nif (ret)\r\nreturn ret;\r\nerr_count = ((u32) temp2 << 16) + ((u32) temp1 << 8) + temp0;\r\n*post_err_count = err_count - (u32) loc_abort_count *8 * 8;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_7_0,\r\n&temp0);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_15_8,\r\n&temp1);\r\nif (ret)\r\nreturn ret;\r\ncw_count = ((u32) temp1 << 8) + temp0;\r\nif (cw_count == 0) {\r\nerr("wrong RSD packet count");\r\nreturn -EIO;\r\n}\r\ndeb_info("POST abort count %d err count %d rsd packets %d\n",\r\nloc_abort_count, err_count, cw_count);\r\n*post_cw_count = cw_count - (u32) loc_abort_count;\r\n*abort_count = loc_abort_count;\r\nreturn 0;\r\n}\r\nstatic int af9005_get_post_vit_ber(struct dvb_frontend *fe,\r\nu32 * post_err_count, u32 * post_cw_count,\r\nu16 * abort_count)\r\n{\r\nu32 loc_cw_count = 0, loc_err_count;\r\nu16 loc_abort_count = 0;\r\nint ret;\r\nret =\r\naf9005_get_post_vit_err_cw_count(fe, &loc_err_count, &loc_cw_count,\r\n&loc_abort_count);\r\nif (ret)\r\nreturn ret;\r\n*post_err_count = loc_err_count;\r\n*post_cw_count = loc_cw_count * 204 * 8;\r\n*abort_count = loc_abort_count;\r\nreturn 0;\r\n}\r\nstatic int af9005_get_pre_vit_err_bit_count(struct dvb_frontend *fe,\r\nu32 * pre_err_count,\r\nu32 * pre_bit_count)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nu8 temp, temp0, temp1, temp2;\r\nu32 super_frame_count, x, bits;\r\nint ret;\r\nret =\r\naf9005_read_register_bits(state->d, xd_r_fec_vtb_ber_rdy,\r\nfec_vtb_ber_rdy_pos, fec_vtb_ber_rdy_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\nif (!temp) {\r\ndeb_info("viterbi counter not ready\n");\r\nreturn 101;\r\n}\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_7_0,\r\n&temp0);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_15_8,\r\n&temp1);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_23_16,\r\n&temp2);\r\nif (ret)\r\nreturn ret;\r\n*pre_err_count = ((u32) temp2 << 16) + ((u32) temp1 << 8) + temp0;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_p_fec_super_frm_unit_7_0,\r\n&temp0);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_p_fec_super_frm_unit_15_8,\r\n&temp1);\r\nif (ret)\r\nreturn ret;\r\nsuper_frame_count = ((u32) temp1 << 8) + temp0;\r\nif (super_frame_count == 0) {\r\ndeb_info("super frame count 0\n");\r\nreturn 102;\r\n}\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_tpsd_txmod,\r\nreg_tpsd_txmod_pos, reg_tpsd_txmod_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\nif (temp == 0) {\r\nx = 1512;\r\n} else if (temp == 1) {\r\nx = 6048;\r\n} else {\r\nerr("Invalid fft mode");\r\nreturn -EINVAL;\r\n}\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_tpsd_const,\r\nreg_tpsd_const_pos, reg_tpsd_const_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\nswitch (temp) {\r\ncase 0:\r\nbits = 2;\r\nbreak;\r\ncase 1:\r\nbits = 4;\r\nbreak;\r\ncase 2:\r\nbits = 6;\r\nbreak;\r\ndefault:\r\nerr("invalid constellation mode");\r\nreturn -EINVAL;\r\n}\r\n*pre_bit_count = super_frame_count * 68 * 4 * x * bits;\r\ndeb_info("PRE err count %d frame count %d bit count %d\n",\r\n*pre_err_count, super_frame_count, *pre_bit_count);\r\nreturn 0;\r\n}\r\nstatic int af9005_reset_pre_viterbi(struct dvb_frontend *fe)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nret =\r\naf9005_write_ofdm_register(state->d, xd_p_fec_super_frm_unit_7_0,\r\n1 & 0xff);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, xd_p_fec_super_frm_unit_15_8,\r\n1 >> 8);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_register_bits(state->d, xd_p_fec_vtb_ber_rst,\r\nfec_vtb_ber_rst_pos, fec_vtb_ber_rst_len,\r\n1);\r\nreturn ret;\r\n}\r\nstatic int af9005_reset_post_viterbi(struct dvb_frontend *fe)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nret =\r\naf9005_write_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_7_0,\r\n10000 & 0xff);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_15_8,\r\n10000 >> 8);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_register_bits(state->d, xd_p_fec_rsd_ber_rst,\r\nfec_rsd_ber_rst_pos, fec_rsd_ber_rst_len,\r\n1);\r\nreturn ret;\r\n}\r\nstatic int af9005_get_statistic(struct dvb_frontend *fe)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nint ret, fecavailable;\r\nu64 numerator, denominator;\r\ndeb_info("GET STATISTIC\n");\r\nret = af9005_is_fecmon_available(fe, &fecavailable);\r\nif (ret)\r\nreturn ret;\r\nif (!fecavailable) {\r\ndeb_info("fecmon not available\n");\r\nreturn 0;\r\n}\r\nret = af9005_get_pre_vit_err_bit_count(fe, &state->pre_vit_error_count,\r\n&state->pre_vit_bit_count);\r\nif (ret == 0) {\r\naf9005_reset_pre_viterbi(fe);\r\nif (state->pre_vit_bit_count > 0) {\r\nnumerator =\r\n(u64) state->pre_vit_error_count * (u64) 1000000000;\r\ndenominator = (u64) state->pre_vit_bit_count;\r\nstate->ber = do_div(numerator, denominator);\r\n} else {\r\nstate->ber = 0xffffffff;\r\n}\r\n}\r\nret = af9005_get_post_vit_ber(fe, &state->post_vit_error_count,\r\n&state->post_vit_bit_count,\r\n&state->abort_count);\r\nif (ret == 0) {\r\nret = af9005_reset_post_viterbi(fe);\r\nstate->unc += state->abort_count;\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_refresh_state(struct dvb_frontend *fe)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nif (time_after(jiffies, state->next_status_check)) {\r\ndeb_info("REFRESH STATE\n");\r\nif (af9005_get_statistic(fe))\r\nerr("get_statistic_failed");\r\nstate->next_status_check = jiffies + 250 * HZ / 1000;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_read_status(struct dvb_frontend *fe, fe_status_t * stat)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nu8 temp;\r\nint ret;\r\nif (fe->ops.tuner_ops.release == NULL)\r\nreturn -ENODEV;\r\n*stat = 0;\r\nret = af9005_read_register_bits(state->d, xd_p_agc_lock,\r\nagc_lock_pos, agc_lock_len, &temp);\r\nif (ret)\r\nreturn ret;\r\nif (temp)\r\n*stat |= FE_HAS_SIGNAL;\r\nret = af9005_read_register_bits(state->d, xd_p_fd_tpsd_lock,\r\nfd_tpsd_lock_pos, fd_tpsd_lock_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\nif (temp)\r\n*stat |= FE_HAS_CARRIER;\r\nret = af9005_read_register_bits(state->d,\r\nxd_r_mp2if_sync_byte_locked,\r\nmp2if_sync_byte_locked_pos,\r\nmp2if_sync_byte_locked_pos, &temp);\r\nif (ret)\r\nreturn ret;\r\nif (temp)\r\n*stat |= FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_LOCK;\r\nif (state->opened)\r\naf9005_led_control(state->d, *stat & FE_HAS_LOCK);\r\nret =\r\naf9005_read_register_bits(state->d, xd_p_reg_strong_sginal_detected,\r\nreg_strong_sginal_detected_pos,\r\nreg_strong_sginal_detected_len, &temp);\r\nif (ret)\r\nreturn ret;\r\nif (temp != state->strong) {\r\ndeb_info("adjust for strong signal %d\n", temp);\r\nstate->strong = temp;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_read_ber(struct dvb_frontend *fe, u32 * ber)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nif (fe->ops.tuner_ops.release == NULL)\r\nreturn -ENODEV;\r\naf9005_fe_refresh_state(fe);\r\n*ber = state->ber;\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nif (fe->ops.tuner_ops.release == NULL)\r\nreturn -ENODEV;\r\naf9005_fe_refresh_state(fe);\r\n*unc = state->unc;\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_read_signal_strength(struct dvb_frontend *fe,\r\nu16 * strength)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 if_gain, rf_gain;\r\nif (fe->ops.tuner_ops.release == NULL)\r\nreturn -ENODEV;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_r_reg_aagc_rf_gain,\r\n&rf_gain);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_ofdm_register(state->d, xd_r_reg_aagc_if_gain,\r\n&if_gain);\r\nif (ret)\r\nreturn ret;\r\n*strength = (512 - rf_gain - if_gain) << 7;\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_read_snr(struct dvb_frontend *fe, u16 * snr)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int af9005_fe_program_cfoe(struct dvb_usb_device *d, fe_bandwidth_t bw)\r\n{\r\nu8 temp0, temp1, temp2, temp3, buf[4];\r\nint ret;\r\nu32 NS_coeff1_2048Nu;\r\nu32 NS_coeff1_8191Nu;\r\nu32 NS_coeff1_8192Nu;\r\nu32 NS_coeff1_8193Nu;\r\nu32 NS_coeff2_2k;\r\nu32 NS_coeff2_8k;\r\nswitch (bw) {\r\ncase BANDWIDTH_6_MHZ:\r\nNS_coeff1_2048Nu = 0x2ADB6DC;\r\nNS_coeff1_8191Nu = 0xAB7313;\r\nNS_coeff1_8192Nu = 0xAB6DB7;\r\nNS_coeff1_8193Nu = 0xAB685C;\r\nNS_coeff2_2k = 0x156DB6E;\r\nNS_coeff2_8k = 0x55B6DC;\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\nNS_coeff1_2048Nu = 0x3200001;\r\nNS_coeff1_8191Nu = 0xC80640;\r\nNS_coeff1_8192Nu = 0xC80000;\r\nNS_coeff1_8193Nu = 0xC7F9C0;\r\nNS_coeff2_2k = 0x1900000;\r\nNS_coeff2_8k = 0x640000;\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\nNS_coeff1_2048Nu = 0x3924926;\r\nNS_coeff1_8191Nu = 0xE4996E;\r\nNS_coeff1_8192Nu = 0xE49249;\r\nNS_coeff1_8193Nu = 0xE48B25;\r\nNS_coeff2_2k = 0x1C92493;\r\nNS_coeff2_8k = 0x724925;\r\nbreak;\r\ndefault:\r\nerr("Invalid bandwidth %d.", bw);\r\nreturn -EINVAL;\r\n}\r\ntemp0 = (u8) (NS_coeff1_2048Nu & 0x000000FF);\r\ntemp1 = (u8) ((NS_coeff1_2048Nu & 0x0000FF00) >> 8);\r\ntemp2 = (u8) ((NS_coeff1_2048Nu & 0x00FF0000) >> 16);\r\ntemp3 = (u8) ((NS_coeff1_2048Nu & 0x03000000) >> 24);\r\nbuf[0] = temp3;\r\nbuf[1] = temp2;\r\nbuf[2] = temp1;\r\nbuf[3] = temp0;\r\nret = af9005_write_ofdm_register(d, 0xAE00, buf[0]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE01, buf[1]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE02, buf[2]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE03, buf[3]);\r\nif (ret)\r\nreturn ret;\r\ntemp0 = (u8) ((NS_coeff2_2k & 0x0000003F));\r\ntemp1 = (u8) ((NS_coeff2_2k & 0x00003FC0) >> 6);\r\ntemp2 = (u8) ((NS_coeff2_2k & 0x003FC000) >> 14);\r\ntemp3 = (u8) ((NS_coeff2_2k & 0x01C00000) >> 22);\r\nbuf[0] = temp3;\r\nbuf[1] = temp2;\r\nbuf[2] = temp1;\r\nbuf[3] = temp0;\r\nret = af9005_write_ofdm_register(d, 0xAE04, buf[0]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE05, buf[1]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE06, buf[2]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE07, buf[3]);\r\nif (ret)\r\nreturn ret;\r\ntemp0 = (u8) ((NS_coeff1_8191Nu & 0x000000FF));\r\ntemp1 = (u8) ((NS_coeff1_8191Nu & 0x0000FF00) >> 8);\r\ntemp2 = (u8) ((NS_coeff1_8191Nu & 0x00FFC000) >> 16);\r\ntemp3 = (u8) ((NS_coeff1_8191Nu & 0x03000000) >> 24);\r\nbuf[0] = temp3;\r\nbuf[1] = temp2;\r\nbuf[2] = temp1;\r\nbuf[3] = temp0;\r\nret = af9005_write_ofdm_register(d, 0xAE08, buf[0]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE09, buf[1]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE0A, buf[2]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE0B, buf[3]);\r\nif (ret)\r\nreturn ret;\r\ntemp0 = (u8) (NS_coeff1_8192Nu & 0x000000FF);\r\ntemp1 = (u8) ((NS_coeff1_8192Nu & 0x0000FF00) >> 8);\r\ntemp2 = (u8) ((NS_coeff1_8192Nu & 0x00FFC000) >> 16);\r\ntemp3 = (u8) ((NS_coeff1_8192Nu & 0x03000000) >> 24);\r\nbuf[0] = temp3;\r\nbuf[1] = temp2;\r\nbuf[2] = temp1;\r\nbuf[3] = temp0;\r\nret = af9005_write_ofdm_register(d, 0xAE0C, buf[0]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE0D, buf[1]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE0E, buf[2]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE0F, buf[3]);\r\nif (ret)\r\nreturn ret;\r\ntemp0 = (u8) ((NS_coeff1_8193Nu & 0x000000FF));\r\ntemp1 = (u8) ((NS_coeff1_8193Nu & 0x0000FF00) >> 8);\r\ntemp2 = (u8) ((NS_coeff1_8193Nu & 0x00FFC000) >> 16);\r\ntemp3 = (u8) ((NS_coeff1_8193Nu & 0x03000000) >> 24);\r\nbuf[0] = temp3;\r\nbuf[1] = temp2;\r\nbuf[2] = temp1;\r\nbuf[3] = temp0;\r\nret = af9005_write_ofdm_register(d, 0xAE10, buf[0]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE11, buf[1]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE12, buf[2]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE13, buf[3]);\r\nif (ret)\r\nreturn ret;\r\ntemp0 = (u8) ((NS_coeff2_8k & 0x0000003F));\r\ntemp1 = (u8) ((NS_coeff2_8k & 0x00003FC0) >> 6);\r\ntemp2 = (u8) ((NS_coeff2_8k & 0x003FC000) >> 14);\r\ntemp3 = (u8) ((NS_coeff2_8k & 0x01C00000) >> 22);\r\nbuf[0] = temp3;\r\nbuf[1] = temp2;\r\nbuf[2] = temp1;\r\nbuf[3] = temp0;\r\nret = af9005_write_ofdm_register(d, 0xAE14, buf[0]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE15, buf[1]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE16, buf[2]);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(d, 0xAE17, buf[3]);\r\nreturn ret;\r\n}\r\nstatic int af9005_fe_select_bw(struct dvb_usb_device *d, fe_bandwidth_t bw)\r\n{\r\nu8 temp;\r\nswitch (bw) {\r\ncase BANDWIDTH_6_MHZ:\r\ntemp = 0;\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\ntemp = 1;\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\ntemp = 2;\r\nbreak;\r\ndefault:\r\nerr("Invalid bandwidth %d.", bw);\r\nreturn -EINVAL;\r\n}\r\nreturn af9005_write_register_bits(d, xd_g_reg_bw, reg_bw_pos,\r\nreg_bw_len, temp);\r\n}\r\nstatic int af9005_fe_power(struct dvb_frontend *fe, int on)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nu8 temp = on;\r\nint ret;\r\ndeb_info("power %s tuner\n", on ? "on" : "off");\r\nret = af9005_send_command(state->d, 0x03, &temp, 1, NULL, 0);\r\nreturn ret;\r\n}\r\nstatic int af9005_fe_init(struct dvb_frontend *fe)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nint ret, i, scriptlen;\r\nu8 temp, temp0 = 0, temp1 = 0, temp2 = 0;\r\nu8 buf[2];\r\nu16 if1;\r\ndeb_info("in af9005_fe_init\n");\r\ndeb_info("reset\n");\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst_en,\r\n4, 1, 0x01)))\r\nreturn ret;\r\nif ((ret = af9005_write_ofdm_register(state->d, APO_REG_RESET, 0)))\r\nreturn ret;\r\ndeb_info("clear ofdm reset\n");\r\nfor (i = 0; i < 150; i++) {\r\nif ((ret =\r\naf9005_read_ofdm_register(state->d,\r\nxd_I2C_reg_ofdm_rst, &temp)))\r\nreturn ret;\r\nif (temp & (regmask[reg_ofdm_rst_len - 1] << reg_ofdm_rst_pos))\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (i == 150)\r\nreturn -ETIMEDOUT;\r\nret = af9005_write_ofdm_register(state->d, 0xb200, 0xa9);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, xd_g_reg_ofsm_clk, 0x07);\r\nif (ret)\r\nreturn ret;\r\ntemp = 0x01;\r\nret = af9005_send_command(state->d, 0x03, &temp, 1, NULL, 0);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, xd_g_reg_ofsm_clk, 0x00);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, 0xb200, 0xa1);\r\nif (ret)\r\nreturn ret;\r\ntemp = regmask[reg_ofdm_rst_len - 1] << reg_ofdm_rst_pos;\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst,\r\nreg_ofdm_rst_pos, reg_ofdm_rst_len, 1)))\r\nreturn ret;\r\nret = af9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst,\r\nreg_ofdm_rst_pos, reg_ofdm_rst_len, 0);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, 0xaefc, 0);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("set stand alone chip\n");\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_p_reg_dca_stand_alone,\r\nreg_dca_stand_alone_pos,\r\nreg_dca_stand_alone_len, 1)))\r\nreturn ret;\r\ndeb_info("set dca upper & lower chip\n");\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_p_reg_dca_upper_chip,\r\nreg_dca_upper_chip_pos,\r\nreg_dca_upper_chip_len, 0)))\r\nreturn ret;\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_p_reg_dca_lower_chip,\r\nreg_dca_lower_chip_pos,\r\nreg_dca_lower_chip_len, 0)))\r\nreturn ret;\r\ndeb_info("set 2wire master clock to 0x14 (for 60KHz)\n");\r\nif ((ret =\r\naf9005_write_ofdm_register(state->d, xd_I2C_i2c_m_period, 0x14)))\r\nreturn ret;\r\ndeb_info("clear dca enable chip\n");\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_p_reg_dca_en,\r\nreg_dca_en_pos, reg_dca_en_len, 0)))\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, 0xa16c, 1);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, 0xa3c1, 0);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("program cfoe\n");\r\nif ((ret = af9005_fe_program_cfoe(state->d, BANDWIDTH_6_MHZ)))\r\nreturn ret;\r\ndeb_info("set read-update bit for constellation\n");\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_p_reg_feq_read_update,\r\nreg_feq_read_update_pos,\r\nreg_feq_read_update_len, 1)))\r\nreturn ret;\r\ndeb_info("set read-update bit 1 for DCA constellation\n");\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_p_reg_dca_read_update,\r\nreg_dca_read_update_pos,\r\nreg_dca_read_update_len, 1)))\r\nreturn ret;\r\ndeb_info("enable fec monitor\n");\r\nif ((ret =\r\naf9005_write_register_bits(state->d, xd_p_fec_vtb_rsd_mon_en,\r\nfec_vtb_rsd_mon_en_pos,\r\nfec_vtb_rsd_mon_en_len, 1)))\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, 0xa601, 0);\r\ndeb_info("set api_retrain_never_freeze\n");\r\nif ((ret = af9005_write_ofdm_register(state->d, 0xaefb, 0x01)))\r\nreturn ret;\r\ndeb_info("load init script\n");\r\nscriptlen = sizeof(script) / sizeof(RegDesc);\r\nfor (i = 0; i < scriptlen; i++) {\r\nif ((ret =\r\naf9005_write_register_bits(state->d, script[i].reg,\r\nscript[i].pos,\r\nscript[i].len, script[i].val)))\r\nreturn ret;\r\nif (script[i].reg == 0xae18)\r\ntemp2 = script[i].val;\r\nif (script[i].reg == 0xae19)\r\ntemp1 = script[i].val;\r\nif (script[i].reg == 0xae1a)\r\ntemp0 = script[i].val;\r\nif (script[i].reg == xd_p_reg_unplug_th)\r\nstate->original_if_unplug_th = script[i].val;\r\nif (script[i].reg == xd_p_reg_unplug_rf_gain_th)\r\nstate->original_rf_unplug_th = script[i].val;\r\nif (script[i].reg == xd_p_reg_unplug_dtop_if_gain_th)\r\nstate->original_dtop_if_unplug_th = script[i].val;\r\nif (script[i].reg == xd_p_reg_unplug_dtop_rf_gain_th)\r\nstate->original_dtop_rf_unplug_th = script[i].val;\r\n}\r\nstate->original_fcw =\r\n((u32) temp2 << 16) + ((u32) temp1 << 8) + (u32) temp0;\r\ndeb_info("save original TOPs\n");\r\nret =\r\naf9005_read_word_agc(state->d,\r\nxd_p_reg_aagc_rf_top_numerator_9_8,\r\nxd_p_reg_aagc_rf_top_numerator_7_0, 0, 2,\r\n&state->original_rf_top);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_word_agc(state->d,\r\nxd_p_reg_aagc_if_top_numerator_9_8,\r\nxd_p_reg_aagc_if_top_numerator_7_0, 0, 2,\r\n&state->original_if_top);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_word_agc(state->d, 0xA60E, 0xA60A, 4, 2,\r\n&state->original_aci0_if_top);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_read_word_agc(state->d, 0xA60E, 0xA60B, 6, 2,\r\n&state->original_aci1_if_top);\r\nif (ret)\r\nreturn ret;\r\nif (fe->ops.tuner_ops.release == NULL) {\r\nret = af9005_read_eeprom(adap->dev, 0xc6, buf, 2);\r\nif (ret) {\r\nerr("Impossible to read EEPROM\n");\r\nreturn ret;\r\n}\r\ndeb_info("Tuner id %d, board id %d\n", buf[0], buf[1]);\r\nswitch (buf[0]) {\r\ncase 2:\r\nret = af9005_read_eeprom(adap->dev, 0xc8, buf, 2);\r\nif (ret) {\r\nerr("Impossible to read EEPROM\n");\r\nreturn ret;\r\n}\r\nif1 = (u16) (buf[0] << 8) + buf[1];\r\nif (dvb_attach(mt2060_attach, fe, &adap->dev->i2c_adap,\r\n&af9005_mt2060_config, if1) == NULL) {\r\ndeb_info("MT2060 attach failed\n");\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\ncase 3:\r\ncase 9:\r\nif (dvb_attach(qt1010_attach, fe, &adap->dev->i2c_adap,\r\n&af9005_qt1010_config) ==NULL) {\r\ndeb_info("QT1010 attach failed\n");\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\ndefault:\r\nerr("Unsupported tuner type %d", buf[0]);\r\nreturn -ENODEV;\r\n}\r\nret = fe->ops.tuner_ops.init(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndeb_info("profit!\n");\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn af9005_fe_power(fe, 0);\r\n}\r\nstatic int af9005_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nif (acquire) {\r\nstate->opened++;\r\n} else {\r\nstate->opened--;\r\nif (!state->opened)\r\naf9005_led_control(state->d, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_set_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *fep)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 temp, temp0, temp1, temp2;\r\ndeb_info("af9005_fe_set_frontend freq %d bw %d\n", fep->frequency,\r\nfep->u.ofdm.bandwidth);\r\nif (fe->ops.tuner_ops.release == NULL) {\r\nerr("Tuner not attached");\r\nreturn -ENODEV;\r\n}\r\ndeb_info("turn off led\n");\r\nret = af9005_led_control(state->d, 0);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_register_bits(state->d, XD_MP2IF_MISC, 2, 1, 0);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("set FCW to default value\n");\r\ntemp0 = (u8) (state->original_fcw & 0x000000ff);\r\ntemp1 = (u8) ((state->original_fcw & 0x0000ff00) >> 8);\r\ntemp2 = (u8) ((state->original_fcw & 0x00ff0000) >> 16);\r\nret = af9005_write_ofdm_register(state->d, 0xae1a, temp0);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, 0xae19, temp1);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_write_ofdm_register(state->d, 0xae18, temp2);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("restore original TOPs\n");\r\nret =\r\naf9005_write_word_agc(state->d,\r\nxd_p_reg_aagc_rf_top_numerator_9_8,\r\nxd_p_reg_aagc_rf_top_numerator_7_0, 0, 2,\r\nstate->original_rf_top);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_word_agc(state->d,\r\nxd_p_reg_aagc_if_top_numerator_9_8,\r\nxd_p_reg_aagc_if_top_numerator_7_0, 0, 2,\r\nstate->original_if_top);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_word_agc(state->d, 0xA60E, 0xA60A, 4, 2,\r\nstate->original_aci0_if_top);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_word_agc(state->d, 0xA60E, 0xA60B, 6, 2,\r\nstate->original_aci1_if_top);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("select bandwidth");\r\nret = af9005_fe_select_bw(state->d, fep->u.ofdm.bandwidth);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_fe_program_cfoe(state->d, fep->u.ofdm.bandwidth);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("clear easy mode flag\n");\r\nret = af9005_write_ofdm_register(state->d, 0xaefd, 0);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("set unplug threshold to original value\n");\r\nret =\r\naf9005_write_ofdm_register(state->d, xd_p_reg_unplug_th,\r\nstate->original_if_unplug_th);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("set tuner\n");\r\nret = fe->ops.tuner_ops.set_params(fe, fep);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("trigger ofsm\n");\r\ntemp = 0;\r\nret = af9005_write_tuner_registers(state->d, 0xffff, &temp, 1);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("clear retrain and freeze flag\n");\r\nret =\r\naf9005_write_register_bits(state->d,\r\nxd_p_reg_api_retrain_request,\r\nreg_api_retrain_request_pos, 2, 0);\r\nif (ret)\r\nreturn ret;\r\naf9005_reset_pre_viterbi(fe);\r\naf9005_reset_post_viterbi(fe);\r\nstate->pre_vit_error_count = 0;\r\nstate->pre_vit_bit_count = 0;\r\nstate->ber = 0;\r\nstate->post_vit_error_count = 0;\r\nstate->abort_count = 0;\r\nstate->next_status_check = jiffies;\r\nstate->strong = -1;\r\nreturn 0;\r\n}\r\nstatic int af9005_fe_get_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *fep)\r\n{\r\nstruct af9005_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 temp;\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_tpsd_const,\r\nreg_tpsd_const_pos, reg_tpsd_const_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("===== fe_get_frontend ==============\n");\r\ndeb_info("CONSTELLATION ");\r\nswitch (temp) {\r\ncase 0:\r\nfep->u.ofdm.constellation = QPSK;\r\ndeb_info("QPSK\n");\r\nbreak;\r\ncase 1:\r\nfep->u.ofdm.constellation = QAM_16;\r\ndeb_info("QAM_16\n");\r\nbreak;\r\ncase 2:\r\nfep->u.ofdm.constellation = QAM_64;\r\ndeb_info("QAM_64\n");\r\nbreak;\r\n}\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_tpsd_hier,\r\nreg_tpsd_hier_pos, reg_tpsd_hier_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("HIERARCHY ");\r\nswitch (temp) {\r\ncase 0:\r\nfep->u.ofdm.hierarchy_information = HIERARCHY_NONE;\r\ndeb_info("NONE\n");\r\nbreak;\r\ncase 1:\r\nfep->u.ofdm.hierarchy_information = HIERARCHY_1;\r\ndeb_info("1\n");\r\nbreak;\r\ncase 2:\r\nfep->u.ofdm.hierarchy_information = HIERARCHY_2;\r\ndeb_info("2\n");\r\nbreak;\r\ncase 3:\r\nfep->u.ofdm.hierarchy_information = HIERARCHY_4;\r\ndeb_info("4\n");\r\nbreak;\r\n}\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_dec_pri,\r\nreg_dec_pri_pos, reg_dec_pri_len, &temp);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("PRIORITY %s\n", temp ? "high" : "low");\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_tpsd_hpcr,\r\nreg_tpsd_hpcr_pos, reg_tpsd_hpcr_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("CODERATE HP ");\r\nswitch (temp) {\r\ncase 0:\r\nfep->u.ofdm.code_rate_HP = FEC_1_2;\r\ndeb_info("FEC_1_2\n");\r\nbreak;\r\ncase 1:\r\nfep->u.ofdm.code_rate_HP = FEC_2_3;\r\ndeb_info("FEC_2_3\n");\r\nbreak;\r\ncase 2:\r\nfep->u.ofdm.code_rate_HP = FEC_3_4;\r\ndeb_info("FEC_3_4\n");\r\nbreak;\r\ncase 3:\r\nfep->u.ofdm.code_rate_HP = FEC_5_6;\r\ndeb_info("FEC_5_6\n");\r\nbreak;\r\ncase 4:\r\nfep->u.ofdm.code_rate_HP = FEC_7_8;\r\ndeb_info("FEC_7_8\n");\r\nbreak;\r\n}\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_tpsd_lpcr,\r\nreg_tpsd_lpcr_pos, reg_tpsd_lpcr_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("CODERATE LP ");\r\nswitch (temp) {\r\ncase 0:\r\nfep->u.ofdm.code_rate_LP = FEC_1_2;\r\ndeb_info("FEC_1_2\n");\r\nbreak;\r\ncase 1:\r\nfep->u.ofdm.code_rate_LP = FEC_2_3;\r\ndeb_info("FEC_2_3\n");\r\nbreak;\r\ncase 2:\r\nfep->u.ofdm.code_rate_LP = FEC_3_4;\r\ndeb_info("FEC_3_4\n");\r\nbreak;\r\ncase 3:\r\nfep->u.ofdm.code_rate_LP = FEC_5_6;\r\ndeb_info("FEC_5_6\n");\r\nbreak;\r\ncase 4:\r\nfep->u.ofdm.code_rate_LP = FEC_7_8;\r\ndeb_info("FEC_7_8\n");\r\nbreak;\r\n}\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_tpsd_gi,\r\nreg_tpsd_gi_pos, reg_tpsd_gi_len, &temp);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("GUARD INTERVAL ");\r\nswitch (temp) {\r\ncase 0:\r\nfep->u.ofdm.guard_interval = GUARD_INTERVAL_1_32;\r\ndeb_info("1_32\n");\r\nbreak;\r\ncase 1:\r\nfep->u.ofdm.guard_interval = GUARD_INTERVAL_1_16;\r\ndeb_info("1_16\n");\r\nbreak;\r\ncase 2:\r\nfep->u.ofdm.guard_interval = GUARD_INTERVAL_1_8;\r\ndeb_info("1_8\n");\r\nbreak;\r\ncase 3:\r\nfep->u.ofdm.guard_interval = GUARD_INTERVAL_1_4;\r\ndeb_info("1_4\n");\r\nbreak;\r\n}\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_tpsd_txmod,\r\nreg_tpsd_txmod_pos, reg_tpsd_txmod_len,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("TRANSMISSION MODE ");\r\nswitch (temp) {\r\ncase 0:\r\nfep->u.ofdm.transmission_mode = TRANSMISSION_MODE_2K;\r\ndeb_info("2K\n");\r\nbreak;\r\ncase 1:\r\nfep->u.ofdm.transmission_mode = TRANSMISSION_MODE_8K;\r\ndeb_info("8K\n");\r\nbreak;\r\n}\r\nret =\r\naf9005_read_register_bits(state->d, xd_g_reg_bw, reg_bw_pos,\r\nreg_bw_len, &temp);\r\ndeb_info("BANDWIDTH ");\r\nswitch (temp) {\r\ncase 0:\r\nfep->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;\r\ndeb_info("6\n");\r\nbreak;\r\ncase 1:\r\nfep->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;\r\ndeb_info("7\n");\r\nbreak;\r\ncase 2:\r\nfep->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;\r\ndeb_info("8\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void af9005_fe_release(struct dvb_frontend *fe)\r\n{\r\nstruct af9005_fe_state *state =\r\n(struct af9005_fe_state *)fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *af9005_fe_attach(struct dvb_usb_device *d)\r\n{\r\nstruct af9005_fe_state *state = NULL;\r\nstate = kzalloc(sizeof(struct af9005_fe_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\ndeb_info("attaching frontend af9005\n");\r\nstate->d = d;\r\nstate->opened = 0;\r\nmemcpy(&state->frontend.ops, &af9005_fe_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nreturn NULL;\r\n}
