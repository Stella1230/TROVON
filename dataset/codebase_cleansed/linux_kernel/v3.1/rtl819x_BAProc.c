void ActivateBAEntry(struct ieee80211_device* ieee, PBA_RECORD pBA, u16 Time)\r\n{\r\npBA->bValid = true;\r\nif(Time != 0)\r\nmod_timer(&pBA->Timer, jiffies + MSECS(Time));\r\n}\r\nvoid DeActivateBAEntry( struct ieee80211_device* ieee, PBA_RECORD pBA)\r\n{\r\npBA->bValid = false;\r\ndel_timer_sync(&pBA->Timer);\r\n}\r\nu8 TxTsDeleteBA( struct ieee80211_device* ieee, PTX_TS_RECORD pTxTs)\r\n{\r\nPBA_RECORD pAdmittedBa = &pTxTs->TxAdmittedBARecord;\r\nPBA_RECORD pPendingBa = &pTxTs->TxPendingBARecord;\r\nu8 bSendDELBA = false;\r\nif(pPendingBa->bValid)\r\n{\r\nDeActivateBAEntry(ieee, pPendingBa);\r\nbSendDELBA = true;\r\n}\r\nif(pAdmittedBa->bValid)\r\n{\r\nDeActivateBAEntry(ieee, pAdmittedBa);\r\nbSendDELBA = true;\r\n}\r\nreturn bSendDELBA;\r\n}\r\nu8 RxTsDeleteBA( struct ieee80211_device* ieee, PRX_TS_RECORD pRxTs)\r\n{\r\nPBA_RECORD pBa = &pRxTs->RxAdmittedBARecord;\r\nu8 bSendDELBA = false;\r\nif(pBa->bValid)\r\n{\r\nDeActivateBAEntry(ieee, pBa);\r\nbSendDELBA = true;\r\n}\r\nreturn bSendDELBA;\r\n}\r\nvoid ResetBaEntry( PBA_RECORD pBA)\r\n{\r\npBA->bValid = false;\r\npBA->BaParamSet.shortData = 0;\r\npBA->BaTimeoutValue = 0;\r\npBA->DialogToken = 0;\r\npBA->BaStartSeqCtrl.ShortData = 0;\r\n}\r\nstatic struct sk_buff* ieee80211_ADDBA(struct ieee80211_device* ieee, u8* Dst, PBA_RECORD pBA, u16 StatusCode, u8 type)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct ieee80211_hdr_3addr* BAReq = NULL;\r\nu8* tag = NULL;\r\nu16 tmp = 0;\r\nu16 len = ieee->tx_headroom + 9;\r\nIEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), frame(%d) sentd to:%pM, ieee->dev:%p\n", __FUNCTION__, type, Dst, ieee->dev);\r\nif (pBA == NULL||ieee == NULL)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "pBA(%p) is NULL or ieee(%p) is NULL\n", pBA, ieee);\r\nreturn NULL;\r\n}\r\nskb = dev_alloc_skb(len + sizeof( struct ieee80211_hdr_3addr));\r\nif (skb == NULL)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't alloc skb for ADDBA_REQ\n");\r\nreturn NULL;\r\n}\r\nmemset(skb->data, 0, sizeof( struct ieee80211_hdr_3addr));\r\nskb_reserve(skb, ieee->tx_headroom);\r\nBAReq = ( struct ieee80211_hdr_3addr *) skb_put(skb,sizeof( struct ieee80211_hdr_3addr));\r\nmemcpy(BAReq->addr1, Dst, ETH_ALEN);\r\nmemcpy(BAReq->addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(BAReq->addr3, ieee->current_network.bssid, ETH_ALEN);\r\nBAReq->frame_ctl = cpu_to_le16(IEEE80211_STYPE_MANAGE_ACT);\r\ntag = (u8*)skb_put(skb, 9);\r\n*tag ++= ACT_CAT_BA;\r\n*tag ++= type;\r\n*tag ++= pBA->DialogToken;\r\nif (ACT_ADDBARSP == type)\r\n{\r\nprintk("=====>to send ADDBARSP\n");\r\ntmp = cpu_to_le16(StatusCode);\r\nmemcpy(tag, (u8*)&tmp, 2);\r\ntag += 2;\r\n}\r\ntmp = cpu_to_le16(pBA->BaParamSet.shortData);\r\nmemcpy(tag, (u8*)&tmp, 2);\r\ntag += 2;\r\ntmp = cpu_to_le16(pBA->BaTimeoutValue);\r\nmemcpy(tag, (u8*)&tmp, 2);\r\ntag += 2;\r\nif (ACT_ADDBAREQ == type)\r\n{\r\nmemcpy(tag,(u8*)&(pBA->BaStartSeqCtrl), 2);\r\ntag += 2;\r\n}\r\nIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_BA, skb->data, skb->len);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff* ieee80211_DELBA(\r\nstruct ieee80211_device* ieee,\r\nu8* dst,\r\nPBA_RECORD pBA,\r\nTR_SELECT TxRxSelect,\r\nu16 ReasonCode\r\n)\r\n{\r\nDELBA_PARAM_SET DelbaParamSet;\r\nstruct sk_buff *skb = NULL;\r\nstruct ieee80211_hdr_3addr* Delba = NULL;\r\nu8* tag = NULL;\r\nu16 tmp = 0;\r\nu16 len = 6 + ieee->tx_headroom;\r\nif (net_ratelimit())\r\nIEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), ReasonCode(%d) sentd to:%pM\n", __FUNCTION__, ReasonCode, dst);\r\nmemset(&DelbaParamSet, 0, 2);\r\nDelbaParamSet.field.Initiator = (TxRxSelect==TX_DIR)?1:0;\r\nDelbaParamSet.field.TID = pBA->BaParamSet.field.TID;\r\nskb = dev_alloc_skb(len + sizeof( struct ieee80211_hdr_3addr));\r\nif (skb == NULL)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't alloc skb for ADDBA_REQ\n");\r\nreturn NULL;\r\n}\r\nskb_reserve(skb, ieee->tx_headroom);\r\nDelba = ( struct ieee80211_hdr_3addr *) skb_put(skb,sizeof( struct ieee80211_hdr_3addr));\r\nmemcpy(Delba->addr1, dst, ETH_ALEN);\r\nmemcpy(Delba->addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(Delba->addr3, ieee->current_network.bssid, ETH_ALEN);\r\nDelba->frame_ctl = cpu_to_le16(IEEE80211_STYPE_MANAGE_ACT);\r\ntag = (u8*)skb_put(skb, 6);\r\n*tag ++= ACT_CAT_BA;\r\n*tag ++= ACT_DELBA;\r\ntmp = cpu_to_le16(DelbaParamSet.shortData);\r\nmemcpy(tag, (u8*)&tmp, 2);\r\ntag += 2;\r\ntmp = cpu_to_le16(ReasonCode);\r\nmemcpy(tag, (u8*)&tmp, 2);\r\ntag += 2;\r\nIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_BA, skb->data, skb->len);\r\nif (net_ratelimit())\r\nIEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "<=====%s()\n", __FUNCTION__);\r\nreturn skb;\r\n}\r\nvoid ieee80211_send_ADDBAReq(struct ieee80211_device* ieee, u8* dst, PBA_RECORD pBA)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nskb = ieee80211_ADDBA(ieee, dst, pBA, 0, ACT_ADDBAREQ);\r\nif (skb)\r\n{\r\nsoftmac_mgmt_xmit(skb, ieee);\r\n}\r\nelse\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);\r\n}\r\n}\r\nvoid ieee80211_send_ADDBARsp(struct ieee80211_device* ieee, u8* dst, PBA_RECORD pBA, u16 StatusCode)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nskb = ieee80211_ADDBA(ieee, dst, pBA, StatusCode, ACT_ADDBARSP);\r\nif (skb)\r\n{\r\nsoftmac_mgmt_xmit(skb, ieee);\r\n}\r\nelse\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);\r\n}\r\n}\r\nvoid ieee80211_send_DELBA(struct ieee80211_device* ieee, u8* dst, PBA_RECORD pBA, TR_SELECT TxRxSelect, u16 ReasonCode)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nskb = ieee80211_DELBA(ieee, dst, pBA, TxRxSelect, ReasonCode);\r\nif (skb)\r\n{\r\nsoftmac_mgmt_xmit(skb, ieee);\r\n}\r\nelse\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);\r\n}\r\nreturn ;\r\n}\r\nint ieee80211_rx_ADDBAReq( struct ieee80211_device* ieee, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr_3addr* req = NULL;\r\nu16 rc = 0;\r\nu8 * dst = NULL, *pDialogToken = NULL, *tag = NULL;\r\nPBA_RECORD pBA = NULL;\r\nPBA_PARAM_SET pBaParamSet = NULL;\r\nu16* pBaTimeoutVal = NULL;\r\nPSEQUENCE_CONTROL pBaStartSeqCtrl = NULL;\r\nPRX_TS_RECORD pTS = NULL;\r\nif (skb->len < sizeof( struct ieee80211_hdr_3addr) + 9)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, " Invalid skb len in BAREQ(%d / %zu)\n", skb->len, (sizeof( struct ieee80211_hdr_3addr) + 9));\r\nreturn -1;\r\n}\r\nIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_BA, skb->data, skb->len);\r\nreq = ( struct ieee80211_hdr_3addr*) skb->data;\r\ntag = (u8*)req;\r\ndst = (u8*)(&req->addr2[0]);\r\ntag += sizeof( struct ieee80211_hdr_3addr);\r\npDialogToken = tag + 2;\r\npBaParamSet = (PBA_PARAM_SET)(tag + 3);\r\npBaTimeoutVal = (u16*)(tag + 5);\r\npBaStartSeqCtrl = (PSEQUENCE_CONTROL)(req + 7);\r\nprintk("====================>rx ADDBAREQ from :%pM\n", dst);\r\nif( (ieee->current_network.qos_data.active == 0) ||\r\n(ieee->pHTInfo->bCurrentHTSupport == false))\r\n{\r\nrc = ADDBA_STATUS_REFUSED;\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "Failed to reply on ADDBA_REQ as some capability is not ready(%d, %d)\n", ieee->current_network.qos_data.active, ieee->pHTInfo->bCurrentHTSupport);\r\ngoto OnADDBAReq_Fail;\r\n}\r\nif( !GetTs(\r\nieee,\r\n(PTS_COMMON_INFO*)(&pTS),\r\ndst,\r\n(u8)(pBaParamSet->field.TID),\r\nRX_DIR,\r\ntrue) )\r\n{\r\nrc = ADDBA_STATUS_REFUSED;\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __FUNCTION__);\r\ngoto OnADDBAReq_Fail;\r\n}\r\npBA = &pTS->RxAdmittedBARecord;\r\nif(pBaParamSet->field.BAPolicy == BA_POLICY_DELAYED)\r\n{\r\nrc = ADDBA_STATUS_INVALID_PARAM;\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "BA Policy is not correct in %s()\n", __FUNCTION__);\r\ngoto OnADDBAReq_Fail;\r\n}\r\nDeActivateBAEntry(ieee, pBA);\r\npBA->DialogToken = *pDialogToken;\r\npBA->BaParamSet = *pBaParamSet;\r\npBA->BaTimeoutValue = *pBaTimeoutVal;\r\npBA->BaStartSeqCtrl = *pBaStartSeqCtrl;\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee))\r\npBA->BaParamSet.field.BufferSize = 1;\r\nelse\r\npBA->BaParamSet.field.BufferSize = 32;\r\nActivateBAEntry(ieee, pBA, pBA->BaTimeoutValue);\r\nieee80211_send_ADDBARsp(ieee, dst, pBA, ADDBA_STATUS_SUCCESS);\r\nreturn 0;\r\nOnADDBAReq_Fail:\r\n{\r\nBA_RECORD BA;\r\nBA.BaParamSet = *pBaParamSet;\r\nBA.BaTimeoutValue = *pBaTimeoutVal;\r\nBA.DialogToken = *pDialogToken;\r\nBA.BaParamSet.field.BAPolicy = BA_POLICY_IMMEDIATE;\r\nieee80211_send_ADDBARsp(ieee, dst, &BA, rc);\r\nreturn 0;\r\n}\r\n}\r\nint ieee80211_rx_ADDBARsp( struct ieee80211_device* ieee, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr_3addr* rsp = NULL;\r\nPBA_RECORD pPendingBA, pAdmittedBA;\r\nPTX_TS_RECORD pTS = NULL;\r\nu8* dst = NULL, *pDialogToken = NULL, *tag = NULL;\r\nu16* pStatusCode = NULL, *pBaTimeoutVal = NULL;\r\nPBA_PARAM_SET pBaParamSet = NULL;\r\nu16 ReasonCode;\r\nif (skb->len < sizeof( struct ieee80211_hdr_3addr) + 9)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, " Invalid skb len in BARSP(%d / %zu)\n", skb->len, (sizeof( struct ieee80211_hdr_3addr) + 9));\r\nreturn -1;\r\n}\r\nrsp = ( struct ieee80211_hdr_3addr*)skb->data;\r\ntag = (u8*)rsp;\r\ndst = (u8*)(&rsp->addr2[0]);\r\ntag += sizeof( struct ieee80211_hdr_3addr);\r\npDialogToken = tag + 2;\r\npStatusCode = (u16*)(tag + 3);\r\npBaParamSet = (PBA_PARAM_SET)(tag + 5);\r\npBaTimeoutVal = (u16*)(tag + 7);\r\nif( ieee->current_network.qos_data.active == 0 ||\r\nieee->pHTInfo->bCurrentHTSupport == false ||\r\nieee->pHTInfo->bCurrentAMPDUEnable == false )\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "reject to ADDBA_RSP as some capability is not ready(%d, %d, %d)\n",ieee->current_network.qos_data.active, ieee->pHTInfo->bCurrentHTSupport, ieee->pHTInfo->bCurrentAMPDUEnable);\r\nReasonCode = DELBA_REASON_UNKNOWN_BA;\r\ngoto OnADDBARsp_Reject;\r\n}\r\nif (!GetTs(\r\nieee,\r\n(PTS_COMMON_INFO*)(&pTS),\r\ndst,\r\n(u8)(pBaParamSet->field.TID),\r\nTX_DIR,\r\nfalse) )\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __FUNCTION__);\r\nReasonCode = DELBA_REASON_UNKNOWN_BA;\r\ngoto OnADDBARsp_Reject;\r\n}\r\npTS->bAddBaReqInProgress = false;\r\npPendingBA = &pTS->TxPendingBARecord;\r\npAdmittedBA = &pTS->TxAdmittedBARecord;\r\nif((pAdmittedBA->bValid==true))\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_BA, "OnADDBARsp(): Recv ADDBA Rsp. Drop because already admit it! \n");\r\nreturn -1;\r\n}\r\nelse if((pPendingBA->bValid == false) ||(*pDialogToken != pPendingBA->DialogToken))\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "OnADDBARsp(): Recv ADDBA Rsp. BA invalid, DELBA! \n");\r\nReasonCode = DELBA_REASON_UNKNOWN_BA;\r\ngoto OnADDBARsp_Reject;\r\n}\r\nelse\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_BA, "OnADDBARsp(): Recv ADDBA Rsp. BA is admitted! Status code:%X\n", *pStatusCode);\r\nDeActivateBAEntry(ieee, pPendingBA);\r\n}\r\nif(*pStatusCode == ADDBA_STATUS_SUCCESS)\r\n{\r\nif(pBaParamSet->field.BAPolicy == BA_POLICY_DELAYED)\r\n{\r\npTS->bAddBaReqDelayed = true;\r\nDeActivateBAEntry(ieee, pAdmittedBA);\r\nReasonCode = DELBA_REASON_END_BA;\r\ngoto OnADDBARsp_Reject;\r\n}\r\npAdmittedBA->DialogToken = *pDialogToken;\r\npAdmittedBA->BaTimeoutValue = *pBaTimeoutVal;\r\npAdmittedBA->BaStartSeqCtrl = pPendingBA->BaStartSeqCtrl;\r\npAdmittedBA->BaParamSet = *pBaParamSet;\r\nDeActivateBAEntry(ieee, pAdmittedBA);\r\nActivateBAEntry(ieee, pAdmittedBA, *pBaTimeoutVal);\r\n}\r\nelse\r\n{\r\npTS->bAddBaReqDelayed = true;\r\n}\r\nreturn 0;\r\nOnADDBARsp_Reject:\r\n{\r\nBA_RECORD BA;\r\nBA.BaParamSet = *pBaParamSet;\r\nieee80211_send_DELBA(ieee, dst, &BA, TX_DIR, ReasonCode);\r\nreturn 0;\r\n}\r\n}\r\nint ieee80211_rx_DELBA(struct ieee80211_device* ieee,struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr_3addr* delba = NULL;\r\nPDELBA_PARAM_SET pDelBaParamSet = NULL;\r\nu16* pReasonCode = NULL;\r\nu8* dst = NULL;\r\nif (skb->len < sizeof( struct ieee80211_hdr_3addr) + 6)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, " Invalid skb len in DELBA(%d / %zu)\n", skb->len, (sizeof( struct ieee80211_hdr_3addr) + 6));\r\nreturn -1;\r\n}\r\nif(ieee->current_network.qos_data.active == 0 ||\r\nieee->pHTInfo->bCurrentHTSupport == false )\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "received DELBA while QOS or HT is not supported(%d, %d)\n",ieee->current_network.qos_data.active, ieee->pHTInfo->bCurrentHTSupport);\r\nreturn -1;\r\n}\r\nIEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_BA, skb->data, skb->len);\r\ndelba = ( struct ieee80211_hdr_3addr*)skb->data;\r\ndst = (u8*)(&delba->addr2[0]);\r\ndelba += sizeof( struct ieee80211_hdr_3addr);\r\npDelBaParamSet = (PDELBA_PARAM_SET)(delba+2);\r\npReasonCode = (u16*)(delba+4);\r\nif(pDelBaParamSet->field.Initiator == 1)\r\n{\r\nPRX_TS_RECORD pRxTs;\r\nif( !GetTs(\r\nieee,\r\n(PTS_COMMON_INFO*)&pRxTs,\r\ndst,\r\n(u8)pDelBaParamSet->field.TID,\r\nRX_DIR,\r\nfalse) )\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS for RXTS in %s()\n", __FUNCTION__);\r\nreturn -1;\r\n}\r\nRxTsDeleteBA(ieee, pRxTs);\r\n}\r\nelse\r\n{\r\nPTX_TS_RECORD pTxTs;\r\nif(!GetTs(\r\nieee,\r\n(PTS_COMMON_INFO*)&pTxTs,\r\ndst,\r\n(u8)pDelBaParamSet->field.TID,\r\nTX_DIR,\r\nfalse) )\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS for TXTS in %s()\n", __FUNCTION__);\r\nreturn -1;\r\n}\r\npTxTs->bUsingBa = false;\r\npTxTs->bAddBaReqInProgress = false;\r\npTxTs->bAddBaReqDelayed = false;\r\ndel_timer_sync(&pTxTs->TsAddBaTimer);\r\nTxTsDeleteBA(ieee, pTxTs);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nTsInitAddBA(\r\nstruct ieee80211_device* ieee,\r\nPTX_TS_RECORD pTS,\r\nu8 Policy,\r\nu8 bOverwritePending\r\n)\r\n{\r\nPBA_RECORD pBA = &pTS->TxPendingBARecord;\r\nif(pBA->bValid==true && bOverwritePending==false)\r\nreturn;\r\nDeActivateBAEntry(ieee, pBA);\r\npBA->DialogToken++;\r\npBA->BaParamSet.field.AMSDU_Support = 0;\r\npBA->BaParamSet.field.BAPolicy = Policy;\r\npBA->BaParamSet.field.TID = pTS->TsCommonInfo.TSpec.f.TSInfo.field.ucTSID;\r\npBA->BaParamSet.field.BufferSize = 32;\r\npBA->BaTimeoutValue = 0;\r\npBA->BaStartSeqCtrl.field.SeqNum = (pTS->TxCurSeq + 3) % 4096;\r\nActivateBAEntry(ieee, pBA, BA_SETUP_TIMEOUT);\r\nieee80211_send_ADDBAReq(ieee, pTS->TsCommonInfo.Addr, pBA);\r\n}\r\nvoid\r\nTsInitDelBA( struct ieee80211_device* ieee, PTS_COMMON_INFO pTsCommonInfo, TR_SELECT TxRxSelect)\r\n{\r\nif(TxRxSelect == TX_DIR)\r\n{\r\nPTX_TS_RECORD pTxTs = (PTX_TS_RECORD)pTsCommonInfo;\r\nif(TxTsDeleteBA(ieee, pTxTs))\r\nieee80211_send_DELBA(\r\nieee,\r\npTsCommonInfo->Addr,\r\n(pTxTs->TxAdmittedBARecord.bValid)?(&pTxTs->TxAdmittedBARecord):(&pTxTs->TxPendingBARecord),\r\nTxRxSelect,\r\nDELBA_REASON_END_BA);\r\n}\r\nelse if(TxRxSelect == RX_DIR)\r\n{\r\nPRX_TS_RECORD pRxTs = (PRX_TS_RECORD)pTsCommonInfo;\r\nif(RxTsDeleteBA(ieee, pRxTs))\r\nieee80211_send_DELBA(\r\nieee,\r\npTsCommonInfo->Addr,\r\n&pRxTs->RxAdmittedBARecord,\r\nTxRxSelect,\r\nDELBA_REASON_END_BA );\r\n}\r\n}\r\nvoid BaSetupTimeOut(unsigned long data)\r\n{\r\nPTX_TS_RECORD pTxTs = (PTX_TS_RECORD)data;\r\npTxTs->bAddBaReqInProgress = false;\r\npTxTs->bAddBaReqDelayed = true;\r\npTxTs->TxPendingBARecord.bValid = false;\r\n}\r\nvoid TxBaInactTimeout(unsigned long data)\r\n{\r\nPTX_TS_RECORD pTxTs = (PTX_TS_RECORD)data;\r\nstruct ieee80211_device *ieee = container_of(pTxTs, struct ieee80211_device, TxTsRecord[pTxTs->num]);\r\nTxTsDeleteBA(ieee, pTxTs);\r\nieee80211_send_DELBA(\r\nieee,\r\npTxTs->TsCommonInfo.Addr,\r\n&pTxTs->TxAdmittedBARecord,\r\nTX_DIR,\r\nDELBA_REASON_TIMEOUT);\r\n}\r\nvoid RxBaInactTimeout(unsigned long data)\r\n{\r\nPRX_TS_RECORD pRxTs = (PRX_TS_RECORD)data;\r\nstruct ieee80211_device *ieee = container_of(pRxTs, struct ieee80211_device, RxTsRecord[pRxTs->num]);\r\nRxTsDeleteBA(ieee, pRxTs);\r\nieee80211_send_DELBA(\r\nieee,\r\npRxTs->TsCommonInfo.Addr,\r\n&pRxTs->RxAdmittedBARecord,\r\nRX_DIR,\r\nDELBA_REASON_TIMEOUT);\r\n}
