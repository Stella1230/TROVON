static int af9013_write_regs(struct af9013_state *state, u8 mbox, u16 reg,\r\nu8 *val, u8 len)\r\n{\r\nu8 buf[3+len];\r\nstruct i2c_msg msg = {\r\n.addr = state->config.demod_address,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf };\r\nbuf[0] = reg >> 8;\r\nbuf[1] = reg & 0xff;\r\nbuf[2] = mbox;\r\nmemcpy(&buf[3], val, len);\r\nif (i2c_transfer(state->i2c, &msg, 1) != 1) {\r\nwarn("I2C write failed reg:%04x len:%d", reg, len);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9013_write_ofdm_regs(struct af9013_state *state, u16 reg, u8 *val,\r\nu8 len)\r\n{\r\nu8 mbox = (1 << 0)|(1 << 1)|((len - 1) << 2)|(0 << 6)|(0 << 7);\r\nreturn af9013_write_regs(state, mbox, reg, val, len);\r\n}\r\nstatic int af9013_write_ofsm_regs(struct af9013_state *state, u16 reg, u8 *val,\r\nu8 len)\r\n{\r\nu8 mbox = (1 << 0)|(1 << 1)|((len - 1) << 2)|(1 << 6)|(1 << 7);\r\nreturn af9013_write_regs(state, mbox, reg, val, len);\r\n}\r\nstatic int af9013_write_reg(struct af9013_state *state, u16 reg, u8 val)\r\n{\r\nreturn af9013_write_ofdm_regs(state, reg, &val, 1);\r\n}\r\nstatic int af9013_read_reg(struct af9013_state *state, u16 reg, u8 *val)\r\n{\r\nu8 obuf[3] = { reg >> 8, reg & 0xff, 0 };\r\nu8 ibuf[1];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = state->config.demod_address,\r\n.flags = 0,\r\n.len = sizeof(obuf),\r\n.buf = obuf\r\n}, {\r\n.addr = state->config.demod_address,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(ibuf),\r\n.buf = ibuf\r\n}\r\n};\r\nif (i2c_transfer(state->i2c, msg, 2) != 2) {\r\nwarn("I2C read failed reg:%04x", reg);\r\nreturn -EREMOTEIO;\r\n}\r\n*val = ibuf[0];\r\nreturn 0;\r\n}\r\nstatic int af9013_write_reg_bits(struct af9013_state *state, u16 reg, u8 pos,\r\nu8 len, u8 val)\r\n{\r\nint ret;\r\nu8 tmp, mask;\r\nret = af9013_read_reg(state, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\nmask = regmask[len - 1] << pos;\r\ntmp = (tmp & ~mask) | ((val << pos) & mask);\r\nreturn af9013_write_reg(state, reg, tmp);\r\n}\r\nstatic int af9013_read_reg_bits(struct af9013_state *state, u16 reg, u8 pos,\r\nu8 len, u8 *val)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = af9013_read_reg(state, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\n*val = (tmp >> pos) & regmask[len - 1];\r\nreturn 0;\r\n}\r\nstatic int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)\r\n{\r\nint ret;\r\nu8 pos;\r\nu16 addr;\r\ndeb_info("%s: gpio:%d gpioval:%02x\n", __func__, gpio, gpioval);\r\nswitch (gpio) {\r\ncase 0:\r\ncase 1:\r\naddr = 0xd735;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\naddr = 0xd736;\r\nbreak;\r\ndefault:\r\nerr("invalid gpio:%d\n", gpio);\r\nret = -EINVAL;\r\ngoto error;\r\n};\r\nswitch (gpio) {\r\ncase 0:\r\ncase 2:\r\npos = 0;\r\nbreak;\r\ncase 1:\r\ncase 3:\r\ndefault:\r\npos = 4;\r\nbreak;\r\n};\r\nret = af9013_write_reg_bits(state, addr, pos, 4, gpioval);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic u32 af913_div(u32 a, u32 b, u32 x)\r\n{\r\nu32 r = 0, c = 0, i;\r\ndeb_info("%s: a:%d b:%d x:%d\n", __func__, a, b, x);\r\nif (a > b) {\r\nc = a / b;\r\na = a - c * b;\r\n}\r\nfor (i = 0; i < x; i++) {\r\nif (a >= b) {\r\nr += 1;\r\na -= b;\r\n}\r\na <<= 1;\r\nr <<= 1;\r\n}\r\nr = (c << (u32)x) + r;\r\ndeb_info("%s: a:%d b:%d x:%d r:%d r:%x\n", __func__, a, b, x, r, r);\r\nreturn r;\r\n}\r\nstatic int af9013_set_coeff(struct af9013_state *state, fe_bandwidth_t bw)\r\n{\r\nint ret, i, j, found;\r\ndeb_info("%s: adc_clock:%d bw:%d\n", __func__,\r\nstate->config.adc_clock, bw);\r\nfor (i = 0, found = 0; i < ARRAY_SIZE(coeff_table); i++) {\r\nif (coeff_table[i].adc_clock == state->config.adc_clock &&\r\ncoeff_table[i].bw == bw) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nerr("invalid bw or clock");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ndeb_info("%s: coeff: ", __func__);\r\ndebug_dump(coeff_table[i].val, sizeof(coeff_table[i].val), deb_info);\r\nfor (j = 0; j < sizeof(coeff_table[i].val); j++) {\r\nret = af9013_write_reg(state, 0xae00 + j,\r\ncoeff_table[i].val[j]);\r\nif (ret)\r\nbreak;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_set_adc_ctrl(struct af9013_state *state)\r\n{\r\nint ret;\r\nu8 buf[3], tmp, i;\r\nu32 adc_cw;\r\ndeb_info("%s: adc_clock:%d\n", __func__, state->config.adc_clock);\r\nswitch (state->config.adc_clock) {\r\ncase 28800:\r\ntmp = 0;\r\nbreak;\r\ncase 20480:\r\ntmp = 1;\r\nbreak;\r\ncase 28000:\r\ntmp = 2;\r\nbreak;\r\ncase 25000:\r\ntmp = 3;\r\nbreak;\r\ndefault:\r\nerr("invalid xtal");\r\nreturn -EINVAL;\r\n}\r\nadc_cw = af913_div(state->config.adc_clock*1000, 1000000ul, 19ul);\r\nbuf[0] = (u8) ((adc_cw & 0x000000ff));\r\nbuf[1] = (u8) ((adc_cw & 0x0000ff00) >> 8);\r\nbuf[2] = (u8) ((adc_cw & 0x00ff0000) >> 16);\r\ndeb_info("%s: adc_cw:", __func__);\r\ndebug_dump(buf, sizeof(buf), deb_info);\r\nfor (i = 0; i < sizeof(buf); i++) {\r\nret = af9013_write_reg(state, 0xd180 + i, buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\nret = af9013_write_reg_bits(state, 0x9bd2, 0, 4, tmp);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_set_freq_ctrl(struct af9013_state *state, fe_bandwidth_t bw)\r\n{\r\nint ret;\r\nu16 addr;\r\nu8 buf[3], i, j;\r\nu32 adc_freq, freq_cw;\r\ns8 bfs_spec_inv;\r\nint if_sample_freq;\r\nfor (j = 0; j < 3; j++) {\r\nif (j == 0) {\r\naddr = 0xd140;\r\nbfs_spec_inv = state->config.rf_spec_inv ? -1 : 1;\r\n} else if (j == 1) {\r\naddr = 0x9be7;\r\nbfs_spec_inv = state->config.rf_spec_inv ? -1 : 1;\r\n} else {\r\naddr = 0x9bea;\r\nbfs_spec_inv = state->config.rf_spec_inv ? 1 : -1;\r\n}\r\nadc_freq = state->config.adc_clock * 1000;\r\nif_sample_freq = state->config.tuner_if * 1000;\r\nif (state->config.tuner == AF9013_TUNER_TDA18271) {\r\nswitch (bw) {\r\ncase BANDWIDTH_6_MHZ:\r\nif_sample_freq = 3300000;\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\nif_sample_freq = 3500000;\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\ndefault:\r\nif_sample_freq = 4000000;\r\nbreak;\r\n}\r\n} else if (state->config.tuner == AF9013_TUNER_TDA18218) {\r\nswitch (bw) {\r\ncase BANDWIDTH_6_MHZ:\r\nif_sample_freq = 3000000;\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\nif_sample_freq = 3500000;\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\ndefault:\r\nif_sample_freq = 4000000;\r\nbreak;\r\n}\r\n}\r\nwhile (if_sample_freq > (adc_freq / 2))\r\nif_sample_freq = if_sample_freq - adc_freq;\r\nif (if_sample_freq >= 0)\r\nbfs_spec_inv = bfs_spec_inv * (-1);\r\nelse\r\nif_sample_freq = if_sample_freq * (-1);\r\nfreq_cw = af913_div(if_sample_freq, adc_freq, 23ul);\r\nif (bfs_spec_inv == -1)\r\nfreq_cw = 0x00800000 - freq_cw;\r\nbuf[0] = (u8) ((freq_cw & 0x000000ff));\r\nbuf[1] = (u8) ((freq_cw & 0x0000ff00) >> 8);\r\nbuf[2] = (u8) ((freq_cw & 0x007f0000) >> 16);\r\ndeb_info("%s: freq_cw:", __func__);\r\ndebug_dump(buf, sizeof(buf), deb_info);\r\nfor (i = 0; i < sizeof(buf); i++) {\r\nret = af9013_write_reg(state, addr++, buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_set_ofdm_params(struct af9013_state *state,\r\nstruct dvb_ofdm_parameters *params, u8 *auto_mode)\r\n{\r\nint ret;\r\nu8 i, buf[3] = {0, 0, 0};\r\n*auto_mode = 0;\r\nswitch (params->transmission_mode) {\r\ncase TRANSMISSION_MODE_AUTO:\r\n*auto_mode = 1;\r\ncase TRANSMISSION_MODE_2K:\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\nbuf[0] |= (1 << 0);\r\nbreak;\r\ndefault:\r\ndeb_info("%s: invalid transmission_mode\n", __func__);\r\n*auto_mode = 1;\r\n}\r\nswitch (params->guard_interval) {\r\ncase GUARD_INTERVAL_AUTO:\r\n*auto_mode = 1;\r\ncase GUARD_INTERVAL_1_32:\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nbuf[0] |= (1 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nbuf[0] |= (2 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\nbuf[0] |= (3 << 2);\r\nbreak;\r\ndefault:\r\ndeb_info("%s: invalid guard_interval\n", __func__);\r\n*auto_mode = 1;\r\n}\r\nswitch (params->hierarchy_information) {\r\ncase HIERARCHY_AUTO:\r\n*auto_mode = 1;\r\ncase HIERARCHY_NONE:\r\nbreak;\r\ncase HIERARCHY_1:\r\nbuf[0] |= (1 << 4);\r\nbreak;\r\ncase HIERARCHY_2:\r\nbuf[0] |= (2 << 4);\r\nbreak;\r\ncase HIERARCHY_4:\r\nbuf[0] |= (3 << 4);\r\nbreak;\r\ndefault:\r\ndeb_info("%s: invalid hierarchy_information\n", __func__);\r\n*auto_mode = 1;\r\n};\r\nswitch (params->constellation) {\r\ncase QAM_AUTO:\r\n*auto_mode = 1;\r\ncase QPSK:\r\nbreak;\r\ncase QAM_16:\r\nbuf[1] |= (1 << 6);\r\nbreak;\r\ncase QAM_64:\r\nbuf[1] |= (2 << 6);\r\nbreak;\r\ndefault:\r\ndeb_info("%s: invalid constellation\n", __func__);\r\n*auto_mode = 1;\r\n}\r\nbuf[1] |= (1 << 4);\r\nswitch (params->code_rate_HP) {\r\ncase FEC_AUTO:\r\n*auto_mode = 1;\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\nbuf[2] |= (1 << 0);\r\nbreak;\r\ncase FEC_3_4:\r\nbuf[2] |= (2 << 0);\r\nbreak;\r\ncase FEC_5_6:\r\nbuf[2] |= (3 << 0);\r\nbreak;\r\ncase FEC_7_8:\r\nbuf[2] |= (4 << 0);\r\nbreak;\r\ndefault:\r\ndeb_info("%s: invalid code_rate_HP\n", __func__);\r\n*auto_mode = 1;\r\n}\r\nswitch (params->code_rate_LP) {\r\ncase FEC_AUTO:\r\nif (params->hierarchy_information != HIERARCHY_NONE)\r\n*auto_mode = 1;\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\nbuf[2] |= (1 << 3);\r\nbreak;\r\ncase FEC_3_4:\r\nbuf[2] |= (2 << 3);\r\nbreak;\r\ncase FEC_5_6:\r\nbuf[2] |= (3 << 3);\r\nbreak;\r\ncase FEC_7_8:\r\nbuf[2] |= (4 << 3);\r\nbreak;\r\ncase FEC_NONE:\r\nif (params->hierarchy_information == HIERARCHY_AUTO)\r\nbreak;\r\ndefault:\r\ndeb_info("%s: invalid code_rate_LP\n", __func__);\r\n*auto_mode = 1;\r\n}\r\nswitch (params->bandwidth) {\r\ncase BANDWIDTH_6_MHZ:\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\nbuf[1] |= (1 << 2);\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\nbuf[1] |= (2 << 2);\r\nbreak;\r\ndefault:\r\ndeb_info("%s: invalid bandwidth\n", __func__);\r\nbuf[1] |= (2 << 2);\r\n}\r\nfor (i = 0; i < sizeof(buf); i++) {\r\nret = af9013_write_reg(state, 0xd3c0 + i, buf[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9013_reset(struct af9013_state *state, u8 sleep)\r\n{\r\nint ret;\r\nu8 tmp, i;\r\ndeb_info("%s\n", __func__);\r\nret = af9013_write_reg_bits(state, 0xd417, 4, 1, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg(state, 0xaeff, 1);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < 150; i++) {\r\nret = af9013_read_reg_bits(state, 0xd417, 1, 1, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp)\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (!tmp)\r\nreturn -ETIMEDOUT;\r\nif (!sleep) {\r\nret = af9013_write_reg_bits(state, 0xd417, 1, 1, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd417, 4, 1, 0);\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_power_ctrl(struct af9013_state *state, u8 onoff)\r\n{\r\nint ret;\r\ndeb_info("%s: onoff:%d\n", __func__, onoff);\r\nif (onoff) {\r\nret = af9013_write_reg_bits(state, 0xd73a, 3, 1, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd417, 1, 1, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd417, 4, 1, 0);\r\n} else {\r\nret = af9013_reset(state, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd73a, 3, 1, 1);\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_lock_led(struct af9013_state *state, u8 onoff)\r\n{\r\ndeb_info("%s: onoff:%d\n", __func__, onoff);\r\nreturn af9013_write_reg_bits(state, 0xd730, 0, 1, onoff);\r\n}\r\nstatic int af9013_set_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *params)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 auto_mode;\r\ndeb_info("%s: freq:%d bw:%d\n", __func__, params->frequency,\r\nparams->u.ofdm.bandwidth);\r\nstate->frequency = params->frequency;\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe, params);\r\nret = af9013_set_coeff(state, params->u.ofdm.bandwidth);\r\nif (ret)\r\ngoto error;\r\nret = af9013_set_freq_ctrl(state, params->u.ofdm.bandwidth);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd330, 3, 1, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd507, 6, 1, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0x9bfe, 0, 1, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0x9bc2, 0, 1, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_set_ofdm_params(state, &params->u.ofdm, &auto_mode);\r\nif (ret)\r\ngoto error;\r\nif (auto_mode) {\r\nret = af9013_write_reg(state, 0xaefd, 0);\r\ndeb_info("%s: auto TPS\n", __func__);\r\n} else {\r\nret = af9013_write_reg(state, 0xaefd, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg(state, 0xaefe, 0);\r\ndeb_info("%s: manual TPS\n", __func__);\r\n}\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg(state, 0xffff, 0);\r\nif (ret)\r\ngoto error;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_get_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 i, buf[3];\r\ndeb_info("%s\n", __func__);\r\nfor (i = 0; i < 3; i++) {\r\nret = af9013_read_reg(state, 0xd3c0 + i, &buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\nswitch ((buf[1] >> 6) & 3) {\r\ncase 0:\r\np->u.ofdm.constellation = QPSK;\r\nbreak;\r\ncase 1:\r\np->u.ofdm.constellation = QAM_16;\r\nbreak;\r\ncase 2:\r\np->u.ofdm.constellation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 0) & 3) {\r\ncase 0:\r\np->u.ofdm.transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\np->u.ofdm.transmission_mode = TRANSMISSION_MODE_8K;\r\n}\r\nswitch ((buf[0] >> 2) & 3) {\r\ncase 0:\r\np->u.ofdm.guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\np->u.ofdm.guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\np->u.ofdm.guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\np->u.ofdm.guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 4) & 7) {\r\ncase 0:\r\np->u.ofdm.hierarchy_information = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\np->u.ofdm.hierarchy_information = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\np->u.ofdm.hierarchy_information = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\np->u.ofdm.hierarchy_information = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 0) & 7) {\r\ncase 0:\r\np->u.ofdm.code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\np->u.ofdm.code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\np->u.ofdm.code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\np->u.ofdm.code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\np->u.ofdm.code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 3) & 7) {\r\ncase 0:\r\np->u.ofdm.code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\np->u.ofdm.code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\np->u.ofdm.code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\np->u.ofdm.code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\np->u.ofdm.code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 2) & 3) {\r\ncase 0:\r\np->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;\r\nbreak;\r\ncase 1:\r\np->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;\r\nbreak;\r\ncase 2:\r\np->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;\r\nbreak;\r\n}\r\np->inversion = INVERSION_AUTO;\r\np->frequency = state->frequency;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_update_ber_unc(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[3], i;\r\nu32 error_bit_count = 0;\r\nu32 total_bit_count = 0;\r\nu32 abort_packet_count = 0;\r\nstate->ber = 0;\r\nret = af9013_read_reg_bits(state, 0xd391, 4, 1, &buf[0]);\r\nif (ret)\r\ngoto error;\r\nif (!buf[0])\r\ngoto exit;\r\nfor (i = 0; i < 2; i++) {\r\nret = af9013_read_reg(state, 0xd38a + i, &buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\nabort_packet_count = (buf[1] << 8) + buf[0];\r\nfor (i = 0; i < 3; i++) {\r\nret = af9013_read_reg(state, 0xd387 + i, &buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\nerror_bit_count = (buf[2] << 16) + (buf[1] << 8) + buf[0];\r\nerror_bit_count = error_bit_count - abort_packet_count * 8 * 8;\r\nfor (i = 0; i < 2; i++) {\r\nret = af9013_read_reg(state, 0xd385 + i, &buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\ntotal_bit_count = (buf[1] << 8) + buf[0];\r\ntotal_bit_count = total_bit_count - abort_packet_count;\r\ntotal_bit_count = total_bit_count * 204 * 8;\r\nif (total_bit_count)\r\nstate->ber = error_bit_count * 1000000000 / total_bit_count;\r\nstate->ucblocks += abort_packet_count;\r\ndeb_info("%s: err bits:%d total bits:%d abort count:%d\n", __func__,\r\nerror_bit_count, total_bit_count, abort_packet_count);\r\nret = af9013_write_reg(state, 0xd385, 10000 & 0xff);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg(state, 0xd386, 10000 >> 8);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd391, 4, 1, 1);\r\nif (ret)\r\ngoto error;\r\nexit:\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_update_snr(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[3], i, len;\r\nu32 quant = 0;\r\nstruct snr_table *uninitialized_var(snr_table);\r\nret = af9013_read_reg_bits(state, 0xd2e1, 3, 1, &buf[0]);\r\nif (ret)\r\ngoto error;\r\nif (buf[0]) {\r\nfor (i = 0; i < 3; i++) {\r\nret = af9013_read_reg(state, 0xd2e3 + i, &buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\nquant = (buf[2] << 16) + (buf[1] << 8) + buf[0];\r\nret = af9013_read_reg(state, 0xd3c1, &buf[0]);\r\nif (ret)\r\ngoto error;\r\nswitch ((buf[0] >> 6) & 3) {\r\ncase 0:\r\nlen = ARRAY_SIZE(qpsk_snr_table);\r\nsnr_table = qpsk_snr_table;\r\nbreak;\r\ncase 1:\r\nlen = ARRAY_SIZE(qam16_snr_table);\r\nsnr_table = qam16_snr_table;\r\nbreak;\r\ncase 2:\r\nlen = ARRAY_SIZE(qam64_snr_table);\r\nsnr_table = qam64_snr_table;\r\nbreak;\r\ndefault:\r\nlen = 0;\r\nbreak;\r\n}\r\nif (len) {\r\nfor (i = 0; i < len; i++) {\r\nif (quant < snr_table[i].val) {\r\nstate->snr = snr_table[i].snr * 10;\r\nbreak;\r\n}\r\n}\r\n}\r\nret = af9013_write_reg(state, 0xd2e2, 1);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(10);\r\nret = af9013_read_reg_bits(state, 0xd2e6, 0, 1,\r\n&buf[0]);\r\nif (ret)\r\ngoto error;\r\nif (!buf[0])\r\nbreak;\r\n}\r\nret = af9013_write_reg_bits(state, 0xd2e1, 3, 1, 1);\r\nif (ret)\r\ngoto error;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_update_signal_strength(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\nu8 rf_gain, if_gain;\r\nint signal_strength;\r\ndeb_info("%s\n", __func__);\r\nif (state->signal_strength_en) {\r\nret = af9013_read_reg(state, 0xd07c, &rf_gain);\r\nif (ret)\r\ngoto error;\r\nret = af9013_read_reg(state, 0xd07d, &if_gain);\r\nif (ret)\r\ngoto error;\r\nsignal_strength = (0xffff / \\r\n(9 * (state->rf_50 + state->if_50) - \\r\n11 * (state->rf_80 + state->if_80))) * \\r\n(10 * (rf_gain + if_gain) - \\r\n11 * (state->rf_80 + state->if_80));\r\nif (signal_strength < 0)\r\nsignal_strength = 0;\r\nelse if (signal_strength > 0xffff)\r\nsignal_strength = 0xffff;\r\nstate->signal_strength = signal_strength;\r\n} else {\r\nstate->signal_strength = 0;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_update_statistics(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nif (time_before(jiffies, state->next_statistics_check))\r\nreturn 0;\r\nstate->next_statistics_check = jiffies + msecs_to_jiffies(1200);\r\nret = af9013_update_signal_strength(fe);\r\nif (ret)\r\ngoto error;\r\nret = af9013_update_snr(fe);\r\nif (ret)\r\ngoto error;\r\nret = af9013_update_ber_unc(fe);\r\nif (ret)\r\ngoto error;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 800;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int af9013_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\nu8 tmp;\r\n*status = 0;\r\nret = af9013_read_reg_bits(state, 0xd507, 6, 1, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\nif (!*status) {\r\nret = af9013_read_reg_bits(state, 0xd330, 3, 1, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\n}\r\nif (!*status) {\r\nret = af9013_read_reg_bits(state, 0xd333, 7, 1, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\n}\r\nif (!*status) {\r\nret = af9013_read_reg_bits(state, 0xd334, 6, 1, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\n}\r\nif (!*status) {\r\nret = af9013_read_reg_bits(state, 0xd1a0, 6, 1, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL;\r\n}\r\nret = af9013_update_statistics(fe);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = af9013_update_statistics(fe);\r\n*ber = state->ber;\r\nreturn ret;\r\n}\r\nstatic int af9013_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = af9013_update_statistics(fe);\r\n*strength = state->signal_strength;\r\nreturn ret;\r\n}\r\nstatic int af9013_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = af9013_update_statistics(fe);\r\n*snr = state->snr;\r\nreturn ret;\r\n}\r\nstatic int af9013_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = af9013_update_statistics(fe);\r\n*ucblocks = state->ucblocks;\r\nreturn ret;\r\n}\r\nstatic int af9013_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret;\r\ndeb_info("%s\n", __func__);\r\nret = af9013_lock_led(state, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_power_ctrl(state, 0);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_init(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nint ret, i, len;\r\nu8 tmp0, tmp1;\r\nstruct regdesc *init;\r\ndeb_info("%s\n", __func__);\r\nret = af9013_reset(state, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_power_ctrl(state, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg(state, 0xd73a, 0xa4);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < sizeof(state->config.api_version); i++) {\r\nret = af9013_write_reg(state, 0x9bf2 + i,\r\nstate->config.api_version[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\nret = af9013_set_adc_ctrl(state);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg(state, 0xd416, 0x14);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd700, 1, 1, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd700, 2, 1, 0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd371, 1, 1, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd392, 1, 1, 1);\r\nif (ret)\r\ngoto error;\r\ndeb_info("%s: load ofsm settings\n", __func__);\r\nlen = ARRAY_SIZE(ofsm_init);\r\ninit = ofsm_init;\r\nfor (i = 0; i < len; i++) {\r\nret = af9013_write_reg_bits(state, init[i].addr, init[i].pos,\r\ninit[i].len, init[i].val);\r\nif (ret)\r\ngoto error;\r\n}\r\ndeb_info("%s: load tuner specific settings\n", __func__);\r\nswitch (state->config.tuner) {\r\ncase AF9013_TUNER_MXL5003D:\r\nlen = ARRAY_SIZE(tuner_init_mxl5003d);\r\ninit = tuner_init_mxl5003d;\r\nbreak;\r\ncase AF9013_TUNER_MXL5005D:\r\ncase AF9013_TUNER_MXL5005R:\r\ncase AF9013_TUNER_MXL5007T:\r\nlen = ARRAY_SIZE(tuner_init_mxl5005);\r\ninit = tuner_init_mxl5005;\r\nbreak;\r\ncase AF9013_TUNER_ENV77H11D5:\r\nlen = ARRAY_SIZE(tuner_init_env77h11d5);\r\ninit = tuner_init_env77h11d5;\r\nbreak;\r\ncase AF9013_TUNER_MT2060:\r\nlen = ARRAY_SIZE(tuner_init_mt2060);\r\ninit = tuner_init_mt2060;\r\nbreak;\r\ncase AF9013_TUNER_MC44S803:\r\nlen = ARRAY_SIZE(tuner_init_mc44s803);\r\ninit = tuner_init_mc44s803;\r\nbreak;\r\ncase AF9013_TUNER_QT1010:\r\ncase AF9013_TUNER_QT1010A:\r\nlen = ARRAY_SIZE(tuner_init_qt1010);\r\ninit = tuner_init_qt1010;\r\nbreak;\r\ncase AF9013_TUNER_MT2060_2:\r\nlen = ARRAY_SIZE(tuner_init_mt2060_2);\r\ninit = tuner_init_mt2060_2;\r\nbreak;\r\ncase AF9013_TUNER_TDA18271:\r\ncase AF9013_TUNER_TDA18218:\r\nlen = ARRAY_SIZE(tuner_init_tda18271);\r\ninit = tuner_init_tda18271;\r\nbreak;\r\ncase AF9013_TUNER_UNKNOWN:\r\ndefault:\r\nlen = ARRAY_SIZE(tuner_init_unknown);\r\ninit = tuner_init_unknown;\r\nbreak;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nret = af9013_write_reg_bits(state, init[i].addr, init[i].pos,\r\ninit[i].len, init[i].val);\r\nif (ret)\r\ngoto error;\r\n}\r\ndeb_info("%s: setting ts mode\n", __func__);\r\ntmp0 = 0;\r\ntmp1 = 0;\r\nswitch (state->config.output_mode) {\r\ncase AF9013_OUTPUT_MODE_PARALLEL:\r\ntmp0 = 1;\r\nbreak;\r\ncase AF9013_OUTPUT_MODE_SERIAL:\r\ntmp1 = 1;\r\nbreak;\r\ncase AF9013_OUTPUT_MODE_USB:\r\ndefault:\r\nbreak;\r\n}\r\nret = af9013_write_reg_bits(state, 0xd500, 1, 1, tmp0);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd500, 2, 1, tmp1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_lock_led(state, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_read_reg_bits(state, 0x9bee, 0, 1,\r\n&state->signal_strength_en);\r\nif (ret)\r\ngoto error;\r\nif (state->signal_strength_en) {\r\nret = af9013_read_reg(state, 0x9bbd, &state->rf_50);\r\nif (ret)\r\ngoto error;\r\nret = af9013_read_reg(state, 0x9bd0, &state->rf_80);\r\nif (ret)\r\ngoto error;\r\nret = af9013_read_reg(state, 0x9be2, &state->if_50);\r\nif (ret)\r\ngoto error;\r\nret = af9013_read_reg(state, 0x9be4, &state->if_80);\r\nif (ret)\r\ngoto error;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9013_download_firmware(struct af9013_state *state)\r\n{\r\nint i, len, remaining, ret;\r\nconst struct firmware *fw;\r\nu16 checksum = 0;\r\nu8 val;\r\nu8 fw_params[4];\r\nu8 *fw_file = AF9013_DEFAULT_FIRMWARE;\r\nmsleep(100);\r\nret = af9013_read_reg(state, 0x98be, &val);\r\nif (ret)\r\ngoto error;\r\nelse\r\ndeb_info("%s: firmware status:%02x\n", __func__, val);\r\nif (val == 0x0c)\r\ngoto exit;\r\ninfo("found a '%s' in cold state, will try to load a firmware",\r\naf9013_ops.info.name);\r\nret = request_firmware(&fw, fw_file, state->i2c->dev.parent);\r\nif (ret) {\r\nerr("did not find the firmware file. (%s) "\r\n"Please see linux/Documentation/dvb/ for more details" \\r\n" on firmware-problems. (%d)",\r\nfw_file, ret);\r\ngoto error;\r\n}\r\ninfo("downloading firmware from file '%s'", fw_file);\r\nfor (i = 0; i < fw->size; i++)\r\nchecksum += fw->data[i];\r\nfw_params[0] = checksum >> 8;\r\nfw_params[1] = checksum & 0xff;\r\nfw_params[2] = fw->size >> 8;\r\nfw_params[3] = fw->size & 0xff;\r\nret = af9013_write_ofsm_regs(state, 0x50fc,\r\nfw_params, sizeof(fw_params));\r\nif (ret)\r\ngoto error_release;\r\n#define FW_ADDR 0x5100\r\n#define LEN_MAX 16\r\nfor (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {\r\nlen = remaining;\r\nif (len > LEN_MAX)\r\nlen = LEN_MAX;\r\nret = af9013_write_ofsm_regs(state,\r\nFW_ADDR + fw->size - remaining,\r\n(u8 *) &fw->data[fw->size - remaining], len);\r\nif (ret) {\r\nerr("firmware download failed:%d", ret);\r\ngoto error_release;\r\n}\r\n}\r\nret = af9013_write_reg(state, 0xe205, 1);\r\nif (ret)\r\ngoto error_release;\r\nfor (i = 0; i < 15; i++) {\r\nmsleep(100);\r\nret = af9013_read_reg(state, 0x98be, &val);\r\nif (ret)\r\ngoto error_release;\r\ndeb_info("%s: firmware status:%02x\n", __func__, val);\r\nif (val == 0x0c || val == 0x04)\r\nbreak;\r\n}\r\nif (val == 0x04) {\r\nerr("firmware did not run");\r\nret = -1;\r\n} else if (val != 0x0c) {\r\nerr("firmware boot timeout");\r\nret = -1;\r\n}\r\nerror_release:\r\nrelease_firmware(fw);\r\nerror:\r\nexit:\r\nif (!ret)\r\ninfo("found a '%s' in warm state.", af9013_ops.info.name);\r\nreturn ret;\r\n}\r\nstatic int af9013_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nint ret;\r\nstruct af9013_state *state = fe->demodulator_priv;\r\ndeb_info("%s: enable:%d\n", __func__, enable);\r\nif (state->config.output_mode == AF9013_OUTPUT_MODE_USB)\r\nret = af9013_write_reg_bits(state, 0xd417, 3, 1, enable);\r\nelse\r\nret = af9013_write_reg_bits(state, 0xd607, 2, 1, enable);\r\nreturn ret;\r\n}\r\nstatic void af9013_release(struct dvb_frontend *fe)\r\n{\r\nstruct af9013_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *af9013_attach(const struct af9013_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nint ret;\r\nstruct af9013_state *state = NULL;\r\nu8 buf[4], i;\r\nstate = kzalloc(sizeof(struct af9013_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->i2c = i2c;\r\nmemcpy(&state->config, config, sizeof(struct af9013_config));\r\nif (state->config.output_mode != AF9013_OUTPUT_MODE_USB) {\r\nret = af9013_download_firmware(state);\r\nif (ret)\r\ngoto error;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nret = af9013_read_reg(state, 0x5103 + i, &buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\ninfo("firmware version:%d.%d.%d.%d", buf[0], buf[1], buf[2], buf[3]);\r\nret = af9013_read_reg_bits(state, 0xd733, 4, 4, &buf[2]);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < 2; i++) {\r\nret = af9013_read_reg(state, 0x116b + i, &buf[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\ndeb_info("%s: chip version:%d ROM version:%d.%d\n", __func__,\r\nbuf[2], buf[0], buf[1]);\r\nif (state->config.output_mode == AF9013_OUTPUT_MODE_USB) {\r\nret = af9013_write_reg_bits(state, 0xd50b, 2, 1, 1);\r\n} else {\r\nret = af9013_write_reg_bits(state, 0xd500, 3, 1, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd502, 4, 1, 1);\r\n}\r\nif (ret)\r\ngoto error;\r\nret = af9013_write_reg_bits(state, 0xd520, 4, 1, 1);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < sizeof(state->config.gpio); i++) {\r\nret = af9013_set_gpio(state, i, state->config.gpio[i]);\r\nif (ret)\r\ngoto error;\r\n}\r\nmemcpy(&state->frontend.ops, &af9013_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
