int ima_store_template(struct ima_template_entry *entry,\r\nint violation, struct inode *inode)\r\n{\r\nconst char *op = "add_template_measure";\r\nconst char *audit_cause = "hashing_error";\r\nint result;\r\nmemset(entry->digest, 0, sizeof(entry->digest));\r\nentry->template_name = IMA_TEMPLATE_NAME;\r\nentry->template_len = sizeof(entry->template);\r\nif (!violation) {\r\nresult = ima_calc_template_hash(entry->template_len,\r\n&entry->template,\r\nentry->digest);\r\nif (result < 0) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\r\nentry->template_name, op,\r\naudit_cause, result, 0);\r\nreturn result;\r\n}\r\n}\r\nresult = ima_add_template_entry(entry, violation, op, inode);\r\nreturn result;\r\n}\r\nvoid ima_add_violation(struct inode *inode, const unsigned char *filename,\r\nconst char *op, const char *cause)\r\n{\r\nstruct ima_template_entry *entry;\r\nint violation = 1;\r\nint result;\r\natomic_long_inc(&ima_htable.violations);\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nresult = -ENOMEM;\r\ngoto err_out;\r\n}\r\nmemset(&entry->template, 0, sizeof(entry->template));\r\nstrncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);\r\nresult = ima_store_template(entry, violation, inode);\r\nif (result < 0)\r\nkfree(entry);\r\nerr_out:\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\r\nop, cause, result, 0);\r\n}\r\nint ima_must_measure(struct inode *inode, int mask, int function)\r\n{\r\nint must_measure;\r\nmust_measure = ima_match_policy(inode, function, mask);\r\nreturn must_measure ? 0 : -EACCES;\r\n}\r\nint ima_collect_measurement(struct ima_iint_cache *iint, struct file *file)\r\n{\r\nint result = -EEXIST;\r\nif (!(iint->flags & IMA_MEASURED)) {\r\nu64 i_version = file->f_dentry->d_inode->i_version;\r\nmemset(iint->digest, 0, IMA_DIGEST_SIZE);\r\nresult = ima_calc_hash(file, iint->digest);\r\nif (!result)\r\niint->version = i_version;\r\n}\r\nreturn result;\r\n}\r\nvoid ima_store_measurement(struct ima_iint_cache *iint, struct file *file,\r\nconst unsigned char *filename)\r\n{\r\nconst char *op = "add_template_measure";\r\nconst char *audit_cause = "ENOMEM";\r\nint result = -ENOMEM;\r\nstruct inode *inode = file->f_dentry->d_inode;\r\nstruct ima_template_entry *entry;\r\nint violation = 0;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\r\nop, audit_cause, result, 0);\r\nreturn;\r\n}\r\nmemset(&entry->template, 0, sizeof(entry->template));\r\nmemcpy(entry->template.digest, iint->digest, IMA_DIGEST_SIZE);\r\nstrncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);\r\nresult = ima_store_template(entry, violation, inode);\r\nif (!result)\r\niint->flags |= IMA_MEASURED;\r\nelse\r\nkfree(entry);\r\n}
