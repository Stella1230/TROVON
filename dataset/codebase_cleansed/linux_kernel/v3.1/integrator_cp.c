static void __init intcp_map_io(void)\r\n{\r\niotable_init(intcp_io_desc, ARRAY_SIZE(intcp_io_desc));\r\n}\r\nstatic void __init intcp_init_irq(void)\r\n{\r\nu32 pic_mask, sic_mask;\r\npic_mask = ~((~0u) << (11 - IRQ_PIC_START));\r\npic_mask |= (~((~0u) << (29 - 22))) << 22;\r\nsic_mask = ~((~0u) << (1 + IRQ_SIC_END - IRQ_SIC_START));\r\nwritel(0xffffffff, INTCP_VA_PIC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(0xffffffff, INTCP_VA_PIC_BASE + FIQ_ENABLE_CLEAR);\r\nwritel(0xffffffff, INTCP_VA_CIC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(0xffffffff, INTCP_VA_CIC_BASE + FIQ_ENABLE_CLEAR);\r\nwritel(sic_mask, INTCP_VA_SIC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(sic_mask, INTCP_VA_SIC_BASE + FIQ_ENABLE_CLEAR);\r\nfpga_irq_init(-1, pic_mask, &pic_irq_data);\r\nfpga_irq_init(-1, ~((~0u) << (1 + IRQ_CIC_END - IRQ_CIC_START)),\r\n&cic_irq_data);\r\nfpga_irq_init(IRQ_CP_CPPLDINT, sic_mask, &sic_irq_data);\r\n}\r\nstatic void cp_auxvco_set(struct clk *clk, struct icst_vco vco)\r\n{\r\nu32 val;\r\nval = readl(clk->vcoreg) & ~0x7ffff;\r\nval |= vco.v | (vco.r << 9) | (vco.s << 16);\r\nwritel(0xa05f, CM_LOCK);\r\nwritel(val, clk->vcoreg);\r\nwritel(0, CM_LOCK);\r\n}\r\nstatic int intcp_flash_init(struct platform_device *dev)\r\n{\r\nu32 val;\r\nval = readl(INTCP_VA_CTRL_BASE + INTCP_FLASHPROG);\r\nval |= CINTEGRATOR_FLASHPROG_FLWREN;\r\nwritel(val, INTCP_VA_CTRL_BASE + INTCP_FLASHPROG);\r\nreturn 0;\r\n}\r\nstatic void intcp_flash_exit(struct platform_device *dev)\r\n{\r\nu32 val;\r\nval = readl(INTCP_VA_CTRL_BASE + INTCP_FLASHPROG);\r\nval &= ~(CINTEGRATOR_FLASHPROG_FLVPPEN|CINTEGRATOR_FLASHPROG_FLWREN);\r\nwritel(val, INTCP_VA_CTRL_BASE + INTCP_FLASHPROG);\r\n}\r\nstatic void intcp_flash_set_vpp(struct platform_device *pdev, int on)\r\n{\r\nu32 val;\r\nval = readl(INTCP_VA_CTRL_BASE + INTCP_FLASHPROG);\r\nif (on)\r\nval |= CINTEGRATOR_FLASHPROG_FLVPPEN;\r\nelse\r\nval &= ~CINTEGRATOR_FLASHPROG_FLVPPEN;\r\nwritel(val, INTCP_VA_CTRL_BASE + INTCP_FLASHPROG);\r\n}\r\nstatic unsigned int mmc_status(struct device *dev)\r\n{\r\nunsigned int status = readl(IO_ADDRESS(0xca000000 + 4));\r\nwritel(8, IO_ADDRESS(INTEGRATOR_CP_CTL_BASE + 8));\r\nreturn status & 8;\r\n}\r\nstatic void cp_clcd_enable(struct clcd_fb *fb)\r\n{\r\nstruct fb_var_screeninfo *var = &fb->fb.var;\r\nu32 val = CM_CTRL_STATIC1 | CM_CTRL_STATIC2;\r\nif (var->bits_per_pixel <= 8 ||\r\n(var->bits_per_pixel == 16 && var->green.length == 5))\r\nval |= CM_CTRL_LCDMUXSEL_VGA555_TFT555;\r\nelse if (fb->fb.var.bits_per_pixel <= 16)\r\nval |= CM_CTRL_LCDMUXSEL_VGA565_TFT555;\r\nelse\r\nval = 0;\r\ncm_control(CM_CTRL_LCDMUXSEL_MASK|\r\nCM_CTRL_LCDEN0|\r\nCM_CTRL_LCDEN1|\r\nCM_CTRL_STATIC1|\r\nCM_CTRL_STATIC2|\r\nCM_CTRL_STATIC|\r\nCM_CTRL_n24BITEN, val);\r\n}\r\nstatic int cp_clcd_setup(struct clcd_fb *fb)\r\n{\r\nfb->panel = versatile_clcd_get_panel("VGA");\r\nif (!fb->panel)\r\nreturn -EINVAL;\r\nreturn versatile_clcd_setup_dma(fb, SZ_1M);\r\n}\r\nstatic void __init intcp_init_early(void)\r\n{\r\nclkdev_add_table(cp_lookups, ARRAY_SIZE(cp_lookups));\r\nintegrator_init_early();\r\n#ifdef CONFIG_PLAT_VERSATILE_SCHED_CLOCK\r\nversatile_sched_clock_init(REFCOUNTER, 24000000);\r\n#endif\r\n}\r\nstatic void __init intcp_init(void)\r\n{\r\nint i;\r\nplatform_add_devices(intcp_devs, ARRAY_SIZE(intcp_devs));\r\nfor (i = 0; i < ARRAY_SIZE(amba_devs); i++) {\r\nstruct amba_device *d = amba_devs[i];\r\namba_device_register(d, &iomem_resource);\r\n}\r\n}\r\nstatic void __init intcp_timer_init(void)\r\n{\r\nwritel(0, TIMER0_VA_BASE + TIMER_CTRL);\r\nwritel(0, TIMER1_VA_BASE + TIMER_CTRL);\r\nwritel(0, TIMER2_VA_BASE + TIMER_CTRL);\r\nsp804_clocksource_init(TIMER2_VA_BASE, "timer2");\r\nsp804_clockevents_init(TIMER1_VA_BASE, IRQ_TIMERINT1, "timer1");\r\n}
