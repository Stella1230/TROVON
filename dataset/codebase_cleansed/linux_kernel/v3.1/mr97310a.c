static int mr_write(struct gspca_dev *gspca_dev, int len)\r\n{\r\nint rc;\r\nrc = usb_bulk_msg(gspca_dev->dev,\r\nusb_sndbulkpipe(gspca_dev->dev, 4),\r\ngspca_dev->usb_buf, len, NULL, 500);\r\nif (rc < 0)\r\nerr("reg write [%02x] error %d",\r\ngspca_dev->usb_buf[0], rc);\r\nreturn rc;\r\n}\r\nstatic int mr_read(struct gspca_dev *gspca_dev, int len)\r\n{\r\nint rc;\r\nrc = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 3),\r\ngspca_dev->usb_buf, len, NULL, 500);\r\nif (rc < 0)\r\nerr("reg read [%02x] error %d",\r\ngspca_dev->usb_buf[0], rc);\r\nreturn rc;\r\n}\r\nstatic int sensor_write_reg(struct gspca_dev *gspca_dev, u8 reg, u8 flags,\r\nconst u8 *data, int len)\r\n{\r\ngspca_dev->usb_buf[0] = 0x1f;\r\ngspca_dev->usb_buf[1] = flags;\r\ngspca_dev->usb_buf[2] = reg;\r\nmemcpy(gspca_dev->usb_buf + 3, data, len);\r\nreturn mr_write(gspca_dev, len + 3);\r\n}\r\nstatic int sensor_write_regs(struct gspca_dev *gspca_dev,\r\nconst struct sensor_w_data *data, int len)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < len; i++) {\r\nrc = sensor_write_reg(gspca_dev, data[i].reg, data[i].flags,\r\ndata[i].data, data[i].len);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sensor_write1(struct gspca_dev *gspca_dev, u8 reg, u8 data)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 buf, confirm_reg;\r\nint rc;\r\nbuf = data;\r\nif (sd->cam_type == CAM_TYPE_CIF) {\r\nrc = sensor_write_reg(gspca_dev, reg, 0x01, &buf, 1);\r\nconfirm_reg = sd->sensor_type ? 0x13 : 0x11;\r\n} else {\r\nrc = sensor_write_reg(gspca_dev, reg, 0x00, &buf, 1);\r\nconfirm_reg = 0x11;\r\n}\r\nif (rc < 0)\r\nreturn rc;\r\nbuf = 0x01;\r\nrc = sensor_write_reg(gspca_dev, confirm_reg, 0x00, &buf, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int cam_get_response16(struct gspca_dev *gspca_dev, u8 reg, int verbose)\r\n{\r\nint err_code;\r\ngspca_dev->usb_buf[0] = reg;\r\nerr_code = mr_write(gspca_dev, 1);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = mr_read(gspca_dev, 16);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (verbose)\r\nPDEBUG(D_PROBE, "Register: %02x reads %02x%02x%02x", reg,\r\ngspca_dev->usb_buf[0],\r\ngspca_dev->usb_buf[1],\r\ngspca_dev->usb_buf[2]);\r\nreturn 0;\r\n}\r\nstatic int zero_the_pointer(struct gspca_dev *gspca_dev)\r\n{\r\n__u8 *data = gspca_dev->usb_buf;\r\nint err_code;\r\nu8 status = 0;\r\nint tries = 0;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nif (err_code < 0)\r\nreturn err_code;\r\ndata[0] = 0x19;\r\ndata[1] = 0x51;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nif (err_code < 0)\r\nreturn err_code;\r\ndata[0] = 0x19;\r\ndata[1] = 0xba;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nif (err_code < 0)\r\nreturn err_code;\r\ndata[0] = 0x19;\r\ndata[1] = 0x00;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nif (err_code < 0)\r\nreturn err_code;\r\ndata[0] = 0x19;\r\ndata[1] = 0x00;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nwhile (status != 0x0a && tries < 256) {\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nstatus = data[0];\r\ntries++;\r\nif (err_code < 0)\r\nreturn err_code;\r\n}\r\nif (status != 0x0a)\r\nPDEBUG(D_ERR, "status is %02x", status);\r\ntries = 0;\r\nwhile (tries < 4) {\r\ndata[0] = 0x19;\r\ndata[1] = 0x00;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nstatus = data[0];\r\ntries++;\r\nif (err_code < 0)\r\nreturn err_code;\r\n}\r\ndata[0] = 0x19;\r\nerr_code = mr_write(gspca_dev, 1);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = mr_read(gspca_dev, 16);\r\nif (err_code < 0)\r\nreturn err_code;\r\nreturn 0;\r\n}\r\nstatic int stream_start(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->usb_buf[0] = 0x01;\r\ngspca_dev->usb_buf[1] = 0x01;\r\nreturn mr_write(gspca_dev, 2);\r\n}\r\nstatic void stream_stop(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->usb_buf[0] = 0x01;\r\ngspca_dev->usb_buf[1] = 0x00;\r\nif (mr_write(gspca_dev, 2) < 0)\r\nPDEBUG(D_ERR, "Stream Stop failed");\r\n}\r\nstatic void lcd_stop(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->usb_buf[0] = 0x19;\r\ngspca_dev->usb_buf[1] = 0x54;\r\nif (mr_write(gspca_dev, 2) < 0)\r\nPDEBUG(D_ERR, "LCD Stop failed");\r\n}\r\nstatic int isoc_enable(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->usb_buf[0] = 0x00;\r\ngspca_dev->usb_buf[1] = 0x4d;\r\nreturn mr_write(gspca_dev, 2);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nint gain_default = MR97310A_GAIN_DEFAULT;\r\nint err_code;\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nsd->do_lcd_stop = 0;\r\nerr_code = zero_the_pointer(gspca_dev);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = stream_start(gspca_dev);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x07, 1);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (id->idProduct == 0x0110 || id->idProduct == 0x010e) {\r\nsd->cam_type = CAM_TYPE_CIF;\r\ncam->nmodes--;\r\nswitch (gspca_dev->usb_buf[0]) {\r\ncase 2:\r\nsd->sensor_type = 0;\r\nbreak;\r\ncase 3:\r\nsd->sensor_type = 1;\r\nbreak;\r\ndefault:\r\nerr("Unknown CIF Sensor id : %02x",\r\ngspca_dev->usb_buf[1]);\r\nreturn -ENODEV;\r\n}\r\nPDEBUG(D_PROBE, "MR97310A CIF camera detected, sensor: %d",\r\nsd->sensor_type);\r\n} else {\r\nsd->cam_type = CAM_TYPE_VGA;\r\nsd->sensor_type = 1;\r\nsd->do_lcd_stop = 0;\r\nsd->adj_colors = 0;\r\nif (gspca_dev->usb_buf[0] == 0x01) {\r\nsd->sensor_type = 2;\r\n} else if ((gspca_dev->usb_buf[0] != 0x03) &&\r\n(gspca_dev->usb_buf[0] != 0x04)) {\r\nerr("Unknown VGA Sensor id Byte 0: %02x",\r\ngspca_dev->usb_buf[0]);\r\nerr("Defaults assumed, may not work");\r\nerr("Please report this");\r\n}\r\nif ((gspca_dev->usb_buf[0] == 0x03) &&\r\n(gspca_dev->usb_buf[1] == 0x50))\r\nsd->adj_colors = 1;\r\nif (gspca_dev->usb_buf[0] == 0x04) {\r\nsd->do_lcd_stop = 1;\r\nswitch (gspca_dev->usb_buf[1]) {\r\ncase 0x50:\r\nsd->sensor_type = 0;\r\nPDEBUG(D_PROBE, "sensor_type corrected to 0");\r\nbreak;\r\ncase 0x20:\r\nbreak;\r\ndefault:\r\nerr("Unknown VGA Sensor id Byte 1: %02x",\r\ngspca_dev->usb_buf[1]);\r\nerr("Defaults assumed, may not work");\r\nerr("Please report this");\r\n}\r\n}\r\nPDEBUG(D_PROBE, "MR97310A VGA camera detected, sensor: %d",\r\nsd->sensor_type);\r\n}\r\nsd_stopN(gspca_dev);\r\nif (force_sensor_type != -1) {\r\nsd->sensor_type = !!force_sensor_type;\r\nPDEBUG(D_PROBE, "Forcing sensor type to: %d",\r\nsd->sensor_type);\r\n}\r\nif (sd->cam_type == CAM_TYPE_CIF) {\r\nif (sd->sensor_type == 0)\r\ngspca_dev->ctrl_dis = (1 << NORM_BRIGHTNESS_IDX) |\r\n(1 << ARGUS_QC_BRIGHTNESS_IDX) |\r\n(1 << CONTRAST_IDX) |\r\n(1 << SAKAR_CS_GAIN_IDX);\r\nelse\r\ngspca_dev->ctrl_dis = (1 << ARGUS_QC_BRIGHTNESS_IDX) |\r\n(1 << CONTRAST_IDX) |\r\n(1 << SAKAR_CS_GAIN_IDX) |\r\n(1 << MIN_CLOCKDIV_IDX);\r\n} else {\r\nif (sd->sensor_type == 0)\r\ngspca_dev->ctrl_dis = (1 << NORM_BRIGHTNESS_IDX) |\r\n(1 << ARGUS_QC_BRIGHTNESS_IDX) |\r\n(1 << EXPOSURE_IDX) |\r\n(1 << GAIN_IDX) |\r\n(1 << CONTRAST_IDX) |\r\n(1 << SAKAR_CS_GAIN_IDX) |\r\n(1 << MIN_CLOCKDIV_IDX);\r\nelse if (sd->sensor_type == 2) {\r\ngspca_dev->ctrl_dis = (1 << NORM_BRIGHTNESS_IDX) |\r\n(1 << ARGUS_QC_BRIGHTNESS_IDX) |\r\n(1 << GAIN_IDX) |\r\n(1 << MIN_CLOCKDIV_IDX);\r\ngain_default = MR97310A_CS_GAIN_DEFAULT;\r\n} else if (sd->do_lcd_stop)\r\ngspca_dev->ctrl_dis = (1 << NORM_BRIGHTNESS_IDX) |\r\n(1 << CONTRAST_IDX) |\r\n(1 << SAKAR_CS_GAIN_IDX);\r\nelse\r\ngspca_dev->ctrl_dis = (1 << ARGUS_QC_BRIGHTNESS_IDX) |\r\n(1 << CONTRAST_IDX) |\r\n(1 << SAKAR_CS_GAIN_IDX);\r\n}\r\nsd->brightness = MR97310A_BRIGHTNESS_DEFAULT;\r\nsd->exposure = MR97310A_EXPOSURE_DEFAULT;\r\nsd->gain = gain_default;\r\nsd->contrast = MR97310A_CONTRAST_DEFAULT;\r\nsd->min_clockdiv = MR97310A_MIN_CLOCKDIV_DEFAULT;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int start_cif_cam(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 *data = gspca_dev->usb_buf;\r\nint err_code;\r\nstatic const __u8 startup_string[] = {\r\n0x00,\r\n0x0d,\r\n0x01,\r\n0x00,\r\n0x00,\r\n0x13,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x50,\r\n0xc0\r\n};\r\nmemcpy(data, startup_string, 11);\r\nif (sd->sensor_type)\r\ndata[5] = 0xbb;\r\nswitch (gspca_dev->width) {\r\ncase 160:\r\ndata[9] |= 0x04;\r\ncase 320:\r\ndefault:\r\ndata[3] = 0x28;\r\ndata[4] = 0x3c;\r\ndata[6] = 0x14;\r\ndata[8] = 0x1a + sd->sensor_type;\r\nbreak;\r\ncase 176:\r\ndata[9] |= 0x04;\r\ncase 352:\r\ndata[3] = 0x2c;\r\ndata[4] = 0x48;\r\ndata[6] = 0x06;\r\ndata[8] = 0x06 - sd->sensor_type;\r\nbreak;\r\n}\r\nerr_code = mr_write(gspca_dev, 11);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (!sd->sensor_type) {\r\nstatic const struct sensor_w_data cif_sensor0_init_data[] = {\r\n{0x02, 0x00, {0x03, 0x5a, 0xb5, 0x01,\r\n0x0f, 0x14, 0x0f, 0x10}, 8},\r\n{0x0c, 0x00, {0x04, 0x01, 0x01, 0x00, 0x1f}, 5},\r\n{0x12, 0x00, {0x07}, 1},\r\n{0x1f, 0x00, {0x06}, 1},\r\n{0x27, 0x00, {0x04}, 1},\r\n{0x29, 0x00, {0x0c}, 1},\r\n{0x40, 0x00, {0x40, 0x00, 0x04}, 3},\r\n{0x50, 0x00, {0x60}, 1},\r\n{0x60, 0x00, {0x06}, 1},\r\n{0x6b, 0x00, {0x85, 0x85, 0xc8, 0xc8, 0xc8, 0xc8}, 6},\r\n{0x72, 0x00, {0x1e, 0x56}, 2},\r\n{0x75, 0x00, {0x58, 0x40, 0xa2, 0x02, 0x31, 0x02,\r\n0x31, 0x80, 0x00}, 9},\r\n{0x11, 0x00, {0x01}, 1},\r\n{0, 0, {0}, 0}\r\n};\r\nerr_code = sensor_write_regs(gspca_dev, cif_sensor0_init_data,\r\nARRAY_SIZE(cif_sensor0_init_data));\r\n} else {\r\nstatic const struct sensor_w_data cif_sensor1_init_data[] = {\r\n{0x02, 0x00, {0x10}, 1},\r\n{0x05, 0x01, {0x22}, 1},\r\n{0x06, 0x01, {0x00}, 1},\r\n{0x09, 0x02, {0x0e}, 1},\r\n{0x0a, 0x02, {0x05}, 1},\r\n{0x0b, 0x02, {0x05}, 1},\r\n{0x0c, 0x02, {0x0f}, 1},\r\n{0x0d, 0x02, {0x07}, 1},\r\n{0x0e, 0x02, {0x0c}, 1},\r\n{0x0f, 0x00, {0x00}, 1},\r\n{0x10, 0x00, {0x06}, 1},\r\n{0x11, 0x00, {0x07}, 1},\r\n{0x12, 0x00, {0x00}, 1},\r\n{0x13, 0x00, {0x01}, 1},\r\n{0, 0, {0}, 0}\r\n};\r\ngspca_dev->usb_buf[0] = 0x0a;\r\ngspca_dev->usb_buf[1] = 0x00;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = sensor_write_regs(gspca_dev, cif_sensor1_init_data,\r\nARRAY_SIZE(cif_sensor1_init_data));\r\n}\r\nreturn err_code;\r\n}\r\nstatic int start_vga_cam(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 *data = gspca_dev->usb_buf;\r\nint err_code;\r\nstatic const __u8 startup_string[] =\r\n{0x00, 0x0d, 0x01, 0x00, 0x00, 0x2b, 0x00, 0x00,\r\n0x00, 0x50, 0xc0};\r\nmemcpy(data, startup_string, 11);\r\nif (!sd->sensor_type) {\r\ndata[5] = 0x00;\r\ndata[10] = 0x91;\r\n}\r\nif (sd->sensor_type == 2) {\r\ndata[5] = 0x00;\r\ndata[10] = 0x18;\r\n}\r\nswitch (gspca_dev->width) {\r\ncase 160:\r\ndata[9] |= 0x0c;\r\ncase 320:\r\ndata[9] |= 0x04;\r\ncase 640:\r\ndefault:\r\ndata[3] = 0x50;\r\ndata[4] = 0x78;\r\ndata[6] = 0x04;\r\ndata[8] = 0x03;\r\nif (sd->sensor_type == 2) {\r\ndata[6] = 2;\r\ndata[8] = 1;\r\n}\r\nif (sd->do_lcd_stop)\r\ndata[8] = 0x04;\r\nbreak;\r\ncase 176:\r\ndata[9] |= 0x04;\r\ncase 352:\r\ndata[3] = 0x2c;\r\ndata[4] = 0x48;\r\ndata[6] = 0x94;\r\ndata[8] = 0x63;\r\nif (sd->do_lcd_stop)\r\ndata[8] = 0x64;\r\nbreak;\r\n}\r\nerr_code = mr_write(gspca_dev, 11);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (!sd->sensor_type) {\r\nstatic const struct sensor_w_data vga_sensor0_init_data[] = {\r\n{0x01, 0x00, {0x0c, 0x00, 0x04}, 3},\r\n{0x14, 0x00, {0x01, 0xe4, 0x02, 0x84}, 4},\r\n{0x20, 0x00, {0x00, 0x80, 0x00, 0x08}, 4},\r\n{0x25, 0x00, {0x03, 0xa9, 0x80}, 3},\r\n{0x30, 0x00, {0x30, 0x18, 0x10, 0x18}, 4},\r\n{0, 0, {0}, 0}\r\n};\r\nerr_code = sensor_write_regs(gspca_dev, vga_sensor0_init_data,\r\nARRAY_SIZE(vga_sensor0_init_data));\r\n} else if (sd->sensor_type == 1) {\r\nstatic const struct sensor_w_data color_adj[] = {\r\n{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,\r\n0x05, 0x01, 0x04}, 8}\r\n};\r\nstatic const struct sensor_w_data color_no_adj[] = {\r\n{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,\r\n0x07, 0x00, 0x01}, 8}\r\n};\r\nstatic const struct sensor_w_data vga_sensor1_init_data[] = {\r\n{0x11, 0x04, {0x01}, 1},\r\n{0x0a, 0x00, {0x00, 0x01, 0x00, 0x00, 0x01,\r\n0x00, 0x0a}, 7},\r\n{0x11, 0x04, {0x01}, 1},\r\n{0x12, 0x00, {0x00, 0x63, 0x00, 0x70, 0x00, 0x00}, 6},\r\n{0x11, 0x04, {0x01}, 1},\r\n{0, 0, {0}, 0}\r\n};\r\nif (sd->adj_colors)\r\nerr_code = sensor_write_regs(gspca_dev, color_adj,\r\nARRAY_SIZE(color_adj));\r\nelse\r\nerr_code = sensor_write_regs(gspca_dev, color_no_adj,\r\nARRAY_SIZE(color_no_adj));\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = sensor_write_regs(gspca_dev, vga_sensor1_init_data,\r\nARRAY_SIZE(vga_sensor1_init_data));\r\n} else {\r\nstatic const struct sensor_w_data vga_sensor2_init_data[] = {\r\n{0x01, 0x00, {0x48}, 1},\r\n{0x02, 0x00, {0x22}, 1},\r\n{0x05, 0x00, {0x10}, 1},\r\n{0x06, 0x00, {0x00}, 1},\r\n{0x07, 0x00, {0x00}, 1},\r\n{0x08, 0x00, {0x00}, 1},\r\n{0x09, 0x00, {0x00}, 1},\r\n{0x12, 0x00, {0x00}, 1},\r\n{0x13, 0x00, {0x04}, 1},\r\n{0x14, 0x00, {0x00}, 1},\r\n{0x15, 0x00, {0x06}, 1},\r\n{0x16, 0x00, {0x01}, 1},\r\n{0x17, 0x00, {0xe2}, 1},\r\n{0x18, 0x00, {0x02}, 1},\r\n{0x19, 0x00, {0x82}, 1},\r\n{0x1a, 0x00, {0x00}, 1},\r\n{0x1b, 0x00, {0x20}, 1},\r\n{0x1d, 0x00, {0x80}, 1},\r\n{0x1e, 0x00, {0x08}, 1},\r\n{0x1f, 0x00, {0x0c}, 1},\r\n{0x20, 0x00, {0x00}, 1},\r\n{0, 0, {0}, 0}\r\n};\r\nerr_code = sensor_write_regs(gspca_dev, vga_sensor2_init_data,\r\nARRAY_SIZE(vga_sensor2_init_data));\r\n}\r\nreturn err_code;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint err_code;\r\nsd->sof_read = 0;\r\nerr_code = zero_the_pointer(gspca_dev);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = stream_start(gspca_dev);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (sd->cam_type == CAM_TYPE_CIF) {\r\nerr_code = start_cif_cam(gspca_dev);\r\n} else {\r\nerr_code = start_vga_cam(gspca_dev);\r\n}\r\nif (err_code < 0)\r\nreturn err_code;\r\nsetbrightness(gspca_dev);\r\nsetcontrast(gspca_dev);\r\nsetexposure(gspca_dev);\r\nsetgain(gspca_dev);\r\nreturn isoc_enable(gspca_dev);\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstream_stop(gspca_dev);\r\nzero_the_pointer(gspca_dev);\r\nif (sd->do_lcd_stop)\r\nlcd_stop(gspca_dev);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 val;\r\nu8 sign_reg = 7;\r\nu8 value_reg = 8;\r\nstatic const u8 quick_clix_table[] =\r\n{ 0, 4, 8, 12, 1, 2, 3, 5, 6, 9, 7, 10, 13, 11, 14, 15};\r\nif ((gspca_dev->ctrl_dis & (1 << NORM_BRIGHTNESS_IDX)) &&\r\n(gspca_dev->ctrl_dis & (1 << ARGUS_QC_BRIGHTNESS_IDX)))\r\nreturn;\r\nif (sd->cam_type == CAM_TYPE_VGA) {\r\nsign_reg += 4;\r\nvalue_reg += 4;\r\n}\r\nif (sd->brightness > 0) {\r\nsensor_write1(gspca_dev, sign_reg, 0x00);\r\nval = sd->brightness;\r\n} else {\r\nsensor_write1(gspca_dev, sign_reg, 0x01);\r\nval = (257 - sd->brightness);\r\n}\r\nif (sd->do_lcd_stop)\r\nval = quick_clix_table[val];\r\nsensor_write1(gspca_dev, value_reg, val);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint exposure = MR97310A_EXPOSURE_DEFAULT;\r\nu8 buf[2];\r\nif (gspca_dev->ctrl_dis & (1 << EXPOSURE_IDX))\r\nreturn;\r\nif (sd->cam_type == CAM_TYPE_CIF && sd->sensor_type == 1) {\r\nexposure = (sd->exposure * 9267) / 10000 + 300;\r\nsensor_write1(gspca_dev, 3, exposure >> 4);\r\nsensor_write1(gspca_dev, 4, exposure & 0x0f);\r\n} else if (sd->sensor_type == 2) {\r\nexposure = sd->exposure;\r\nexposure >>= 3;\r\nsensor_write1(gspca_dev, 3, exposure >> 8);\r\nsensor_write1(gspca_dev, 4, exposure & 0xff);\r\n} else {\r\nu8 clockdiv = (60 * sd->exposure + 7999) / 8000;\r\nif (clockdiv < sd->min_clockdiv && gspca_dev->width >= 320)\r\nclockdiv = sd->min_clockdiv;\r\nelse if (clockdiv < 2)\r\nclockdiv = 2;\r\nif (sd->cam_type == CAM_TYPE_VGA && clockdiv < 4)\r\nclockdiv = 4;\r\nexposure = (60 * 511 * sd->exposure) / (8000 * clockdiv);\r\nif (exposure > 511)\r\nexposure = 511;\r\nexposure = 511 - exposure;\r\nbuf[0] = exposure & 0xff;\r\nbuf[1] = exposure >> 8;\r\nsensor_write_reg(gspca_dev, 0x0e, 0, buf, 2);\r\nsensor_write1(gspca_dev, 0x02, clockdiv);\r\n}\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 gainreg;\r\nif ((gspca_dev->ctrl_dis & (1 << GAIN_IDX)) &&\r\n(gspca_dev->ctrl_dis & (1 << SAKAR_CS_GAIN_IDX)))\r\nreturn;\r\nif (sd->cam_type == CAM_TYPE_CIF && sd->sensor_type == 1)\r\nsensor_write1(gspca_dev, 0x0e, sd->gain);\r\nelse if (sd->cam_type == CAM_TYPE_VGA && sd->sensor_type == 2)\r\nfor (gainreg = 0x0a; gainreg < 0x11; gainreg += 2) {\r\nsensor_write1(gspca_dev, gainreg, sd->gain >> 8);\r\nsensor_write1(gspca_dev, gainreg + 1, sd->gain & 0xff);\r\n}\r\nelse\r\nsensor_write1(gspca_dev, 0x10, sd->gain);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (gspca_dev->ctrl_dis & (1 << CONTRAST_IDX))\r\nreturn;\r\nsensor_write1(gspca_dev, 0x1c, sd->contrast);\r\n}\r\nstatic int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->brightness = val;\r\nif (gspca_dev->streaming)\r\nsetbrightness(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getbrightness(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->brightness;\r\nreturn 0;\r\n}\r\nstatic int sd_setexposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->exposure = val;\r\nif (gspca_dev->streaming)\r\nsetexposure(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getexposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->exposure;\r\nreturn 0;\r\n}\r\nstatic int sd_setgain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->gain = val;\r\nif (gspca_dev->streaming)\r\nsetgain(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getgain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->gain;\r\nreturn 0;\r\n}\r\nstatic int sd_setcontrast(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->contrast = val;\r\nif (gspca_dev->streaming)\r\nsetcontrast(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getcontrast(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->contrast;\r\nreturn 0;\r\n}\r\nstatic int sd_setmin_clockdiv(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->min_clockdiv = val;\r\nif (gspca_dev->streaming)\r\nsetexposure(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getmin_clockdiv(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->min_clockdiv;\r\nreturn 0;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nunsigned char *sof;\r\nsof = pac_find_sof(&sd->sof_read, data, len);\r\nif (sof) {\r\nint n;\r\nn = sof - data;\r\nif (n > sizeof pac_sof_marker)\r\nn -= sizeof pac_sof_marker;\r\nelse\r\nn = 0;\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata, n);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\npac_sof_marker, sizeof pac_sof_marker);\r\nlen -= sof - data;\r\ndata = sof;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int __init sd_mod_init(void)\r\n{\r\nreturn usb_register(&sd_driver);\r\n}\r\nstatic void __exit sd_mod_exit(void)\r\n{\r\nusb_deregister(&sd_driver);\r\n}
