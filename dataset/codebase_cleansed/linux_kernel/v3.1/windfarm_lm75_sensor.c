static int wf_lm75_get(struct wf_sensor *sr, s32 *value)\r\n{\r\nstruct wf_lm75_sensor *lm = wf_to_lm75(sr);\r\ns32 data;\r\nif (lm->i2c == NULL)\r\nreturn -ENODEV;\r\nif (!lm->inited) {\r\nu8 cfg_new, cfg = (u8)i2c_smbus_read_byte_data(lm->i2c, 1);\r\nDBG("wf_lm75: Initializing %s, cfg was: %02x\n",\r\nsr->name, cfg);\r\ncfg_new = cfg & ~0x01;\r\ni2c_smbus_write_byte_data(lm->i2c, 1, cfg_new);\r\nlm->inited = 1;\r\nmsleep(200);\r\n}\r\ndata = (s32)le16_to_cpu(i2c_smbus_read_word_data(lm->i2c, 0));\r\ndata <<= 8;\r\n*value = data;\r\nreturn 0;\r\n}\r\nstatic void wf_lm75_release(struct wf_sensor *sr)\r\n{\r\nstruct wf_lm75_sensor *lm = wf_to_lm75(sr);\r\nkfree(lm);\r\n}\r\nstatic int wf_lm75_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wf_lm75_sensor *lm;\r\nint rc;\r\nlm = kzalloc(sizeof(struct wf_lm75_sensor), GFP_KERNEL);\r\nif (lm == NULL)\r\nreturn -ENODEV;\r\nlm->inited = 0;\r\nlm->ds1775 = id->driver_data;\r\nlm->i2c = client;\r\nlm->sens.name = client->dev.platform_data;\r\nlm->sens.ops = &wf_lm75_ops;\r\ni2c_set_clientdata(client, lm);\r\nrc = wf_register_sensor(&lm->sens);\r\nif (rc)\r\nkfree(lm);\r\nreturn rc;\r\n}\r\nstatic struct i2c_client *wf_lm75_create(struct i2c_adapter *adapter,\r\nu8 addr, int ds1775,\r\nconst char *loc)\r\n{\r\nstruct i2c_board_info info;\r\nstruct i2c_client *client;\r\nchar *name;\r\nDBG("wf_lm75: creating %s device at address 0x%02x\n",\r\nds1775 ? "ds1775" : "lm75", addr);\r\nif (!strcmp(loc, "Hard drive") || !strcmp(loc, "DRIVE BAY"))\r\nname = "hd-temp";\r\nelse if (!strcmp(loc, "Incoming Air Temp"))\r\nname = "incoming-air-temp";\r\nelse if (!strcmp(loc, "ODD Temp"))\r\nname = "optical-drive-temp";\r\nelse if (!strcmp(loc, "HD Temp"))\r\nname = "hard-drive-temp";\r\nelse\r\ngoto fail;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = (addr >> 1) & 0x7f;\r\ninfo.platform_data = name;\r\nstrlcpy(info.type, ds1775 ? "wf_ds1775" : "wf_lm75", I2C_NAME_SIZE);\r\nclient = i2c_new_device(adapter, &info);\r\nif (client == NULL) {\r\nprintk(KERN_ERR "windfarm: failed to attach %s %s to i2c\n",\r\nds1775 ? "ds1775" : "lm75", name);\r\ngoto fail;\r\n}\r\nlist_add_tail(&client->detected, &wf_lm75_driver.clients);\r\nreturn client;\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic int wf_lm75_attach(struct i2c_adapter *adapter)\r\n{\r\nstruct device_node *busnode, *dev;\r\nstruct pmac_i2c_bus *bus;\r\nDBG("wf_lm75: adapter %s detected\n", adapter->name);\r\nbus = pmac_i2c_adapter_to_bus(adapter);\r\nif (bus == NULL)\r\nreturn -ENODEV;\r\nbusnode = pmac_i2c_get_bus_node(bus);\r\nDBG("wf_lm75: bus found, looking for device...\n");\r\nfor (dev = NULL;\r\n(dev = of_get_next_child(busnode, dev)) != NULL;) {\r\nconst char *loc =\r\nof_get_property(dev, "hwsensor-location", NULL);\r\nu8 addr;\r\nif (!pmac_i2c_match_adapter(dev, adapter))\r\ncontinue;\r\naddr = pmac_i2c_get_dev_addr(dev);\r\nif (loc == NULL || addr == 0)\r\ncontinue;\r\nif (of_device_is_compatible(dev, "lm75"))\r\nwf_lm75_create(adapter, addr, 0, loc);\r\nelse if (of_device_is_compatible(dev, "ds1775"))\r\nwf_lm75_create(adapter, addr, 1, loc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wf_lm75_remove(struct i2c_client *client)\r\n{\r\nstruct wf_lm75_sensor *lm = i2c_get_clientdata(client);\r\nDBG("wf_lm75: i2c detatch called for %s\n", lm->sens.name);\r\nlm->i2c = NULL;\r\nwf_unregister_sensor(&lm->sens);\r\nreturn 0;\r\n}\r\nstatic int __init wf_lm75_sensor_init(void)\r\n{\r\nif (of_machine_is_compatible("PowerMac7,2") ||\r\nof_machine_is_compatible("PowerMac7,3") ||\r\nof_machine_is_compatible("RackMac3,1"))\r\nreturn -ENODEV;\r\nreturn i2c_add_driver(&wf_lm75_driver);\r\n}\r\nstatic void __exit wf_lm75_sensor_exit(void)\r\n{\r\ni2c_del_driver(&wf_lm75_driver);\r\n}
