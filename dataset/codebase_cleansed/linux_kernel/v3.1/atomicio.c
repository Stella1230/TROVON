static struct acpi_iomap *__acpi_find_iomap(phys_addr_t paddr,\r\nunsigned long size)\r\n{\r\nstruct acpi_iomap *map;\r\nlist_for_each_entry_rcu(map, &acpi_iomaps, list) {\r\nif (map->paddr + map->size >= paddr + size &&\r\nmap->paddr <= paddr)\r\nreturn map;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __iomem *__acpi_ioremap_fast(phys_addr_t paddr,\r\nunsigned long size)\r\n{\r\nstruct acpi_iomap *map;\r\nmap = __acpi_find_iomap(paddr, size);\r\nif (map)\r\nreturn map->vaddr + (paddr - map->paddr);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void __iomem *__acpi_try_ioremap(phys_addr_t paddr,\r\nunsigned long size)\r\n{\r\nstruct acpi_iomap *map;\r\nmap = __acpi_find_iomap(paddr, size);\r\nif (map) {\r\nkref_get(&map->ref);\r\nreturn map->vaddr + (paddr - map->paddr);\r\n} else\r\nreturn NULL;\r\n}\r\nstatic void __iomem *acpi_pre_map(phys_addr_t paddr,\r\nunsigned long size)\r\n{\r\nvoid __iomem *vaddr;\r\nstruct acpi_iomap *map;\r\nunsigned long pg_sz, flags;\r\nphys_addr_t pg_off;\r\nspin_lock_irqsave(&acpi_iomaps_lock, flags);\r\nvaddr = __acpi_try_ioremap(paddr, size);\r\nspin_unlock_irqrestore(&acpi_iomaps_lock, flags);\r\nif (vaddr)\r\nreturn vaddr;\r\npg_off = paddr & PAGE_MASK;\r\npg_sz = ((paddr + size + PAGE_SIZE - 1) & PAGE_MASK) - pg_off;\r\nvaddr = ioremap(pg_off, pg_sz);\r\nif (!vaddr)\r\nreturn NULL;\r\nmap = kmalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\ngoto err_unmap;\r\nINIT_LIST_HEAD(&map->list);\r\nmap->paddr = pg_off;\r\nmap->size = pg_sz;\r\nmap->vaddr = vaddr;\r\nkref_init(&map->ref);\r\nspin_lock_irqsave(&acpi_iomaps_lock, flags);\r\nvaddr = __acpi_try_ioremap(paddr, size);\r\nif (vaddr) {\r\nspin_unlock_irqrestore(&acpi_iomaps_lock, flags);\r\niounmap(map->vaddr);\r\nkfree(map);\r\nreturn vaddr;\r\n}\r\nlist_add_tail_rcu(&map->list, &acpi_iomaps);\r\nspin_unlock_irqrestore(&acpi_iomaps_lock, flags);\r\nreturn map->vaddr + (paddr - map->paddr);\r\nerr_unmap:\r\niounmap(vaddr);\r\nreturn NULL;\r\n}\r\nstatic void __acpi_kref_del_iomap(struct kref *ref)\r\n{\r\nstruct acpi_iomap *map;\r\nmap = container_of(ref, struct acpi_iomap, ref);\r\nlist_del_rcu(&map->list);\r\n}\r\nstatic void acpi_post_unmap(phys_addr_t paddr, unsigned long size)\r\n{\r\nstruct acpi_iomap *map;\r\nunsigned long flags;\r\nint del;\r\nspin_lock_irqsave(&acpi_iomaps_lock, flags);\r\nmap = __acpi_find_iomap(paddr, size);\r\nBUG_ON(!map);\r\ndel = kref_put(&map->ref, __acpi_kref_del_iomap);\r\nspin_unlock_irqrestore(&acpi_iomaps_lock, flags);\r\nif (!del)\r\nreturn;\r\nsynchronize_rcu();\r\niounmap(map->vaddr);\r\nkfree(map);\r\n}\r\nstatic int acpi_check_gar(struct acpi_generic_address *reg,\r\nu64 *paddr, int silent)\r\n{\r\nu32 width, space_id;\r\nwidth = reg->bit_width;\r\nspace_id = reg->space_id;\r\nmemcpy(paddr, &reg->address, sizeof(*paddr));\r\nif (!*paddr) {\r\nif (!silent)\r\npr_warning(FW_BUG ACPI_PFX\r\n"Invalid physical address in GAR [0x%llx/%u/%u]\n",\r\n*paddr, width, space_id);\r\nreturn -EINVAL;\r\n}\r\nif ((width != 8) && (width != 16) && (width != 32) && (width != 64)) {\r\nif (!silent)\r\npr_warning(FW_BUG ACPI_PFX\r\n"Invalid bit width in GAR [0x%llx/%u/%u]\n",\r\n*paddr, width, space_id);\r\nreturn -EINVAL;\r\n}\r\nif (space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY &&\r\nspace_id != ACPI_ADR_SPACE_SYSTEM_IO) {\r\nif (!silent)\r\npr_warning(FW_BUG ACPI_PFX\r\n"Invalid address space type in GAR [0x%llx/%u/%u]\n",\r\n*paddr, width, space_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint acpi_pre_map_gar(struct acpi_generic_address *reg)\r\n{\r\nu64 paddr;\r\nvoid __iomem *vaddr;\r\nint rc;\r\nif (reg->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)\r\nreturn 0;\r\nrc = acpi_check_gar(reg, &paddr, 0);\r\nif (rc)\r\nreturn rc;\r\nvaddr = acpi_pre_map(paddr, reg->bit_width / 8);\r\nif (!vaddr)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint acpi_post_unmap_gar(struct acpi_generic_address *reg)\r\n{\r\nu64 paddr;\r\nint rc;\r\nif (reg->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)\r\nreturn 0;\r\nrc = acpi_check_gar(reg, &paddr, 0);\r\nif (rc)\r\nreturn rc;\r\nacpi_post_unmap(paddr, reg->bit_width / 8);\r\nreturn 0;\r\n}\r\nstatic int acpi_atomic_read_mem(u64 paddr, u64 *val, u32 width)\r\n{\r\nvoid __iomem *addr;\r\nrcu_read_lock();\r\naddr = __acpi_ioremap_fast(paddr, width);\r\nswitch (width) {\r\ncase 8:\r\n*val = readb(addr);\r\nbreak;\r\ncase 16:\r\n*val = readw(addr);\r\nbreak;\r\ncase 32:\r\n*val = readl(addr);\r\nbreak;\r\n#ifdef readq\r\ncase 64:\r\n*val = readq(addr);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int acpi_atomic_write_mem(u64 paddr, u64 val, u32 width)\r\n{\r\nvoid __iomem *addr;\r\nrcu_read_lock();\r\naddr = __acpi_ioremap_fast(paddr, width);\r\nswitch (width) {\r\ncase 8:\r\nwriteb(val, addr);\r\nbreak;\r\ncase 16:\r\nwritew(val, addr);\r\nbreak;\r\ncase 32:\r\nwritel(val, addr);\r\nbreak;\r\n#ifdef writeq\r\ncase 64:\r\nwriteq(val, addr);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint acpi_atomic_read(u64 *val, struct acpi_generic_address *reg)\r\n{\r\nu64 paddr;\r\nint rc;\r\nrc = acpi_check_gar(reg, &paddr, 1);\r\nif (rc)\r\nreturn rc;\r\n*val = 0;\r\nswitch (reg->space_id) {\r\ncase ACPI_ADR_SPACE_SYSTEM_MEMORY:\r\nreturn acpi_atomic_read_mem(paddr, val, reg->bit_width);\r\ncase ACPI_ADR_SPACE_SYSTEM_IO:\r\nreturn acpi_os_read_port(paddr, (u32 *)val, reg->bit_width);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint acpi_atomic_write(u64 val, struct acpi_generic_address *reg)\r\n{\r\nu64 paddr;\r\nint rc;\r\nrc = acpi_check_gar(reg, &paddr, 1);\r\nif (rc)\r\nreturn rc;\r\nswitch (reg->space_id) {\r\ncase ACPI_ADR_SPACE_SYSTEM_MEMORY:\r\nreturn acpi_atomic_write_mem(paddr, val, reg->bit_width);\r\ncase ACPI_ADR_SPACE_SYSTEM_IO:\r\nreturn acpi_os_write_port(paddr, val, reg->bit_width);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}
