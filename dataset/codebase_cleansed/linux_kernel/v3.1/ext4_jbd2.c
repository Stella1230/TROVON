int __ext4_journal_get_write_access(const char *where, unsigned int line,\r\nhandle_t *handle, struct buffer_head *bh)\r\n{\r\nint err = 0;\r\nif (ext4_handle_valid(handle)) {\r\nerr = jbd2_journal_get_write_access(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__, bh,\r\nhandle, err);\r\n}\r\nreturn err;\r\n}\r\nint __ext4_forget(const char *where, unsigned int line, handle_t *handle,\r\nint is_metadata, struct inode *inode,\r\nstruct buffer_head *bh, ext4_fsblk_t blocknr)\r\n{\r\nint err;\r\nmight_sleep();\r\ntrace_ext4_forget(inode, is_metadata, blocknr);\r\nBUFFER_TRACE(bh, "enter");\r\njbd_debug(4, "forgetting bh %p: is_metadata = %d, mode %o, "\r\n"data mode %x\n",\r\nbh, is_metadata, inode->i_mode,\r\ntest_opt(inode->i_sb, DATA_FLAGS));\r\nif (!ext4_handle_valid(handle)) {\r\nbforget(bh);\r\nreturn 0;\r\n}\r\nif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\r\n(!is_metadata && !ext4_should_journal_data(inode))) {\r\nif (bh) {\r\nBUFFER_TRACE(bh, "call jbd2_journal_forget");\r\nerr = jbd2_journal_forget(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nBUFFER_TRACE(bh, "call jbd2_journal_revoke");\r\nerr = jbd2_journal_revoke(handle, blocknr, bh);\r\nif (err) {\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\n__ext4_abort(inode->i_sb, where, line,\r\n"error %d when attempting revoke", err);\r\n}\r\nBUFFER_TRACE(bh, "exit");\r\nreturn err;\r\n}\r\nint __ext4_journal_get_create_access(const char *where, unsigned int line,\r\nhandle_t *handle, struct buffer_head *bh)\r\n{\r\nint err = 0;\r\nif (ext4_handle_valid(handle)) {\r\nerr = jbd2_journal_get_create_access(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\n}\r\nreturn err;\r\n}\r\nint __ext4_handle_dirty_metadata(const char *where, unsigned int line,\r\nhandle_t *handle, struct inode *inode,\r\nstruct buffer_head *bh)\r\n{\r\nint err = 0;\r\nif (ext4_handle_valid(handle)) {\r\nerr = jbd2_journal_dirty_metadata(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\n} else {\r\nif (inode)\r\nmark_buffer_dirty_inode(bh, inode);\r\nelse\r\nmark_buffer_dirty(bh);\r\nif (inode && inode_needs_sync(inode)) {\r\nsync_dirty_buffer(bh);\r\nif (buffer_req(bh) && !buffer_uptodate(bh)) {\r\nstruct ext4_super_block *es;\r\nes = EXT4_SB(inode->i_sb)->s_es;\r\nes->s_last_error_block =\r\ncpu_to_le64(bh->b_blocknr);\r\next4_error_inode(inode, where, line,\r\nbh->b_blocknr,\r\n"IO error syncing itable block");\r\nerr = -EIO;\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nint __ext4_handle_dirty_super(const char *where, unsigned int line,\r\nhandle_t *handle, struct super_block *sb)\r\n{\r\nstruct buffer_head *bh = EXT4_SB(sb)->s_sbh;\r\nint err = 0;\r\nif (ext4_handle_valid(handle)) {\r\nerr = jbd2_journal_dirty_metadata(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\n} else\r\nsb->s_dirt = 1;\r\nreturn err;\r\n}
