static void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nint buf_num;\r\nelbc_fcm_ctrl->page = page_addr;\r\nout_be32(&lbc->fbar,\r\npage_addr >> (chip->phys_erase_shift - chip->page_shift));\r\nif (priv->page_size) {\r\nout_be32(&lbc->fpar,\r\n((page_addr << FPAR_LP_PI_SHIFT) & FPAR_LP_PI) |\r\n(oob ? FPAR_LP_MS : 0) | column);\r\nbuf_num = (page_addr & 1) << 2;\r\n} else {\r\nout_be32(&lbc->fpar,\r\n((page_addr << FPAR_SP_PI_SHIFT) & FPAR_SP_PI) |\r\n(oob ? FPAR_SP_MS : 0) | column);\r\nbuf_num = page_addr & 7;\r\n}\r\nelbc_fcm_ctrl->addr = priv->vbase + buf_num * 1024;\r\nelbc_fcm_ctrl->index = column;\r\nif (oob)\r\nelbc_fcm_ctrl->index += priv->page_size ? 2048 : 512;\r\ndev_vdbg(priv->dev, "set_addr: bank=%d, "\r\n"elbc_fcm_ctrl->addr=0x%p (0x%p), "\r\n"index %x, pes %d ps %d\n",\r\nbuf_num, elbc_fcm_ctrl->addr, priv->vbase,\r\nelbc_fcm_ctrl->index,\r\nchip->phys_erase_shift, chip->page_shift);\r\n}\r\nstatic int fsl_elbc_run_command(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nout_be32(&lbc->fmr, priv->fmr | 3);\r\nif (elbc_fcm_ctrl->use_mdr)\r\nout_be32(&lbc->mdr, elbc_fcm_ctrl->mdr);\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_run_command: fmr=%08x fir=%08x fcr=%08x\n",\r\nin_be32(&lbc->fmr), in_be32(&lbc->fir), in_be32(&lbc->fcr));\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_run_command: fbar=%08x fpar=%08x "\r\n"fbcr=%08x bank=%d\n",\r\nin_be32(&lbc->fbar), in_be32(&lbc->fpar),\r\nin_be32(&lbc->fbcr), priv->bank);\r\nctrl->irq_status = 0;\r\nout_be32(&lbc->lsor, priv->bank);\r\nwait_event_timeout(ctrl->irq_wait, ctrl->irq_status,\r\nFCM_TIMEOUT_MSECS * HZ/1000);\r\nelbc_fcm_ctrl->status = ctrl->irq_status;\r\nif (elbc_fcm_ctrl->use_mdr)\r\nelbc_fcm_ctrl->mdr = in_be32(&lbc->mdr);\r\nelbc_fcm_ctrl->use_mdr = 0;\r\nif (elbc_fcm_ctrl->status != LTESR_CC) {\r\ndev_info(priv->dev,\r\n"command failed: fir %x fcr %x status %x mdr %x\n",\r\nin_be32(&lbc->fir), in_be32(&lbc->fcr),\r\nelbc_fcm_ctrl->status, elbc_fcm_ctrl->mdr);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_elbc_do_read(struct nand_chip *chip, int oob)\r\n{\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nif (priv->page_size) {\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_CA << FIR_OP1_SHIFT) |\r\n(FIR_OP_PA << FIR_OP2_SHIFT) |\r\n(FIR_OP_CM1 << FIR_OP3_SHIFT) |\r\n(FIR_OP_RBW << FIR_OP4_SHIFT));\r\nout_be32(&lbc->fcr, (NAND_CMD_READ0 << FCR_CMD0_SHIFT) |\r\n(NAND_CMD_READSTART << FCR_CMD1_SHIFT));\r\n} else {\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_CA << FIR_OP1_SHIFT) |\r\n(FIR_OP_PA << FIR_OP2_SHIFT) |\r\n(FIR_OP_RBW << FIR_OP3_SHIFT));\r\nif (oob)\r\nout_be32(&lbc->fcr, NAND_CMD_READOOB << FCR_CMD0_SHIFT);\r\nelse\r\nout_be32(&lbc->fcr, NAND_CMD_READ0 << FCR_CMD0_SHIFT);\r\n}\r\n}\r\nstatic void fsl_elbc_cmdfunc(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nelbc_fcm_ctrl->use_mdr = 0;\r\nelbc_fcm_ctrl->read_bytes = 0;\r\nif (command != NAND_CMD_PAGEPROG)\r\nelbc_fcm_ctrl->index = 0;\r\nswitch (command) {\r\ncase NAND_CMD_READ1:\r\ncolumn += 256;\r\ncase NAND_CMD_READ0:\r\ndev_dbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_READ0, page_addr:"\r\n" 0x%x, column: 0x%x.\n", page_addr, column);\r\nout_be32(&lbc->fbcr, 0);\r\nset_addr(mtd, 0, page_addr, 0);\r\nelbc_fcm_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\r\nelbc_fcm_ctrl->index += column;\r\nfsl_elbc_do_read(chip, 0);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_READOOB:\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_READOOB, page_addr:"\r\n" 0x%x, column: 0x%x.\n", page_addr, column);\r\nout_be32(&lbc->fbcr, mtd->oobsize - column);\r\nset_addr(mtd, column, page_addr, 1);\r\nelbc_fcm_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\r\nfsl_elbc_do_read(chip, 1);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_READID:\r\ndev_vdbg(priv->dev, "fsl_elbc_cmdfunc: NAND_CMD_READID.\n");\r\nout_be32(&lbc->fir, (FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_UA << FIR_OP1_SHIFT) |\r\n(FIR_OP_RBW << FIR_OP2_SHIFT));\r\nout_be32(&lbc->fcr, NAND_CMD_READID << FCR_CMD0_SHIFT);\r\nout_be32(&lbc->fbcr, 8);\r\nelbc_fcm_ctrl->read_bytes = 8;\r\nelbc_fcm_ctrl->use_mdr = 1;\r\nelbc_fcm_ctrl->mdr = 0;\r\nset_addr(mtd, 0, 0, 0);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_ERASE1:\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_ERASE1, "\r\n"page_addr: 0x%x.\n", page_addr);\r\nset_addr(mtd, 0, page_addr, 0);\r\nreturn;\r\ncase NAND_CMD_ERASE2:\r\ndev_vdbg(priv->dev, "fsl_elbc_cmdfunc: NAND_CMD_ERASE2.\n");\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_PA << FIR_OP1_SHIFT) |\r\n(FIR_OP_CM2 << FIR_OP2_SHIFT) |\r\n(FIR_OP_CW1 << FIR_OP3_SHIFT) |\r\n(FIR_OP_RS << FIR_OP4_SHIFT));\r\nout_be32(&lbc->fcr,\r\n(NAND_CMD_ERASE1 << FCR_CMD0_SHIFT) |\r\n(NAND_CMD_STATUS << FCR_CMD1_SHIFT) |\r\n(NAND_CMD_ERASE2 << FCR_CMD2_SHIFT));\r\nout_be32(&lbc->fbcr, 0);\r\nelbc_fcm_ctrl->read_bytes = 0;\r\nelbc_fcm_ctrl->use_mdr = 1;\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ncase NAND_CMD_SEQIN: {\r\n__be32 fcr;\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_SEQIN/PAGE_PROG, "\r\n"page_addr: 0x%x, column: 0x%x.\n",\r\npage_addr, column);\r\nelbc_fcm_ctrl->column = column;\r\nelbc_fcm_ctrl->oob = 0;\r\nelbc_fcm_ctrl->use_mdr = 1;\r\nfcr = (NAND_CMD_STATUS << FCR_CMD1_SHIFT) |\r\n(NAND_CMD_SEQIN << FCR_CMD2_SHIFT) |\r\n(NAND_CMD_PAGEPROG << FCR_CMD3_SHIFT);\r\nif (priv->page_size) {\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM2 << FIR_OP0_SHIFT) |\r\n(FIR_OP_CA << FIR_OP1_SHIFT) |\r\n(FIR_OP_PA << FIR_OP2_SHIFT) |\r\n(FIR_OP_WB << FIR_OP3_SHIFT) |\r\n(FIR_OP_CM3 << FIR_OP4_SHIFT) |\r\n(FIR_OP_CW1 << FIR_OP5_SHIFT) |\r\n(FIR_OP_RS << FIR_OP6_SHIFT));\r\n} else {\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_CM2 << FIR_OP1_SHIFT) |\r\n(FIR_OP_CA << FIR_OP2_SHIFT) |\r\n(FIR_OP_PA << FIR_OP3_SHIFT) |\r\n(FIR_OP_WB << FIR_OP4_SHIFT) |\r\n(FIR_OP_CM3 << FIR_OP5_SHIFT) |\r\n(FIR_OP_CW1 << FIR_OP6_SHIFT) |\r\n(FIR_OP_RS << FIR_OP7_SHIFT));\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nfcr |= NAND_CMD_READOOB << FCR_CMD0_SHIFT;\r\nelbc_fcm_ctrl->oob = 1;\r\n} else {\r\nWARN_ON(column != 0);\r\nfcr |= NAND_CMD_READ0 << FCR_CMD0_SHIFT;\r\n}\r\n}\r\nout_be32(&lbc->fcr, fcr);\r\nset_addr(mtd, column, page_addr, elbc_fcm_ctrl->oob);\r\nreturn;\r\n}\r\ncase NAND_CMD_PAGEPROG: {\r\nint full_page;\r\ndev_vdbg(priv->dev,\r\n"fsl_elbc_cmdfunc: NAND_CMD_PAGEPROG "\r\n"writing %d bytes.\n", elbc_fcm_ctrl->index);\r\nif (elbc_fcm_ctrl->oob || elbc_fcm_ctrl->column != 0 ||\r\nelbc_fcm_ctrl->index != mtd->writesize + mtd->oobsize) {\r\nout_be32(&lbc->fbcr, elbc_fcm_ctrl->index);\r\nfull_page = 0;\r\n} else {\r\nout_be32(&lbc->fbcr, 0);\r\nfull_page = 1;\r\n}\r\nfsl_elbc_run_command(mtd);\r\nif (full_page && elbc_fcm_ctrl->oob_poi) {\r\nout_be32(&lbc->fbcr, 3);\r\nset_addr(mtd, 6, page_addr, 1);\r\nelbc_fcm_ctrl->read_bytes = mtd->writesize + 9;\r\nfsl_elbc_do_read(chip, 1);\r\nfsl_elbc_run_command(mtd);\r\nmemcpy_fromio(elbc_fcm_ctrl->oob_poi + 6,\r\n&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index], 3);\r\nelbc_fcm_ctrl->index += 3;\r\n}\r\nelbc_fcm_ctrl->oob_poi = NULL;\r\nreturn;\r\n}\r\ncase NAND_CMD_STATUS:\r\nout_be32(&lbc->fir,\r\n(FIR_OP_CM0 << FIR_OP0_SHIFT) |\r\n(FIR_OP_RBW << FIR_OP1_SHIFT));\r\nout_be32(&lbc->fcr, NAND_CMD_STATUS << FCR_CMD0_SHIFT);\r\nout_be32(&lbc->fbcr, 1);\r\nset_addr(mtd, 0, 0, 0);\r\nelbc_fcm_ctrl->read_bytes = 1;\r\nfsl_elbc_run_command(mtd);\r\nsetbits8(elbc_fcm_ctrl->addr, NAND_STATUS_WP);\r\nreturn;\r\ncase NAND_CMD_RESET:\r\ndev_dbg(priv->dev, "fsl_elbc_cmdfunc: NAND_CMD_RESET.\n");\r\nout_be32(&lbc->fir, FIR_OP_CM0 << FIR_OP0_SHIFT);\r\nout_be32(&lbc->fcr, NAND_CMD_RESET << FCR_CMD0_SHIFT);\r\nfsl_elbc_run_command(mtd);\r\nreturn;\r\ndefault:\r\ndev_err(priv->dev,\r\n"fsl_elbc_cmdfunc: error, unsupported command 0x%x.\n",\r\ncommand);\r\n}\r\n}\r\nstatic void fsl_elbc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\n}\r\nstatic void fsl_elbc_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nunsigned int bufsize = mtd->writesize + mtd->oobsize;\r\nif (len <= 0) {\r\ndev_err(priv->dev, "write_buf of %d bytes", len);\r\nelbc_fcm_ctrl->status = 0;\r\nreturn;\r\n}\r\nif ((unsigned int)len > bufsize - elbc_fcm_ctrl->index) {\r\ndev_err(priv->dev,\r\n"write_buf beyond end of buffer "\r\n"(%d requested, %u available)\n",\r\nlen, bufsize - elbc_fcm_ctrl->index);\r\nlen = bufsize - elbc_fcm_ctrl->index;\r\n}\r\nmemcpy_toio(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index], buf, len);\r\nin_8(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index] + len - 1);\r\nelbc_fcm_ctrl->index += len;\r\n}\r\nstatic u8 fsl_elbc_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nif (elbc_fcm_ctrl->index < elbc_fcm_ctrl->read_bytes)\r\nreturn in_8(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index++]);\r\ndev_err(priv->dev, "read_byte beyond end of buffer\n");\r\nreturn ERR_BYTE;\r\n}\r\nstatic void fsl_elbc_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nint avail;\r\nif (len < 0)\r\nreturn;\r\navail = min((unsigned int)len,\r\nelbc_fcm_ctrl->read_bytes - elbc_fcm_ctrl->index);\r\nmemcpy_fromio(buf, &elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index], avail);\r\nelbc_fcm_ctrl->index += avail;\r\nif (len > avail)\r\ndev_err(priv->dev,\r\n"read_buf beyond end of buffer "\r\n"(%d requested, %d available)\n",\r\nlen, avail);\r\n}\r\nstatic int fsl_elbc_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nint i;\r\nif (len < 0) {\r\ndev_err(priv->dev, "write_buf of %d bytes", len);\r\nreturn -EINVAL;\r\n}\r\nif ((unsigned int)len >\r\nelbc_fcm_ctrl->read_bytes - elbc_fcm_ctrl->index) {\r\ndev_err(priv->dev,\r\n"verify_buf beyond end of buffer "\r\n"(%d requested, %u available)\n",\r\nlen, elbc_fcm_ctrl->read_bytes - elbc_fcm_ctrl->index);\r\nelbc_fcm_ctrl->index = elbc_fcm_ctrl->read_bytes;\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < len; i++)\r\nif (in_8(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index + i])\r\n!= buf[i])\r\nbreak;\r\nelbc_fcm_ctrl->index += len;\r\nreturn i == len && elbc_fcm_ctrl->status == LTESR_CC ? 0 : -EIO;\r\n}\r\nstatic int fsl_elbc_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nif (elbc_fcm_ctrl->status != LTESR_CC)\r\nreturn NAND_STATUS_FAIL;\r\nreturn (elbc_fcm_ctrl->mdr & 0xff) | NAND_STATUS_WP;\r\n}\r\nstatic int fsl_elbc_chip_init_tail(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nunsigned int al;\r\nal = 0;\r\nif (chip->pagemask & 0xffff0000)\r\nal++;\r\nif (chip->pagemask & 0xff000000)\r\nal++;\r\npriv->fmr |= (12 << FMR_CWTO_SHIFT) |\r\n(al << FMR_AL_SHIFT);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->numchips = %d\n",\r\nchip->numchips);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->chipsize = %lld\n",\r\nchip->chipsize);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->pagemask = %8x\n",\r\nchip->pagemask);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->chip_delay = %d\n",\r\nchip->chip_delay);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->badblockpos = %d\n",\r\nchip->badblockpos);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->chip_shift = %d\n",\r\nchip->chip_shift);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->page_shift = %d\n",\r\nchip->page_shift);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->phys_erase_shift = %d\n",\r\nchip->phys_erase_shift);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecclayout = %p\n",\r\nchip->ecclayout);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.mode = %d\n",\r\nchip->ecc.mode);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.steps = %d\n",\r\nchip->ecc.steps);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.bytes = %d\n",\r\nchip->ecc.bytes);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.total = %d\n",\r\nchip->ecc.total);\r\ndev_dbg(priv->dev, "fsl_elbc_init: nand->ecc.layout = %p\n",\r\nchip->ecc.layout);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->flags = %08x\n", mtd->flags);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->size = %lld\n", mtd->size);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->erasesize = %d\n",\r\nmtd->erasesize);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->writesize = %d\n",\r\nmtd->writesize);\r\ndev_dbg(priv->dev, "fsl_elbc_init: mtd->oobsize = %d\n",\r\nmtd->oobsize);\r\nif (mtd->writesize == 512) {\r\npriv->page_size = 0;\r\nclrbits32(&lbc->bank[priv->bank].or, OR_FCM_PGS);\r\n} else if (mtd->writesize == 2048) {\r\npriv->page_size = 1;\r\nsetbits32(&lbc->bank[priv->bank].or, OR_FCM_PGS);\r\nif ((in_be32(&lbc->bank[priv->bank].br) & BR_DECC) ==\r\nBR_DECC_CHK_GEN) {\r\nchip->ecc.size = 512;\r\nchip->ecc.layout = (priv->fmr & FMR_ECCM) ?\r\n&fsl_elbc_oob_lp_eccm1 :\r\n&fsl_elbc_oob_lp_eccm0;\r\nchip->badblock_pattern = &largepage_memorybased;\r\n}\r\n} else {\r\ndev_err(priv->dev,\r\n"fsl_elbc_init: page size %d is not supported\n",\r\nmtd->writesize);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_elbc_read_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nuint8_t *buf,\r\nint page)\r\n{\r\nfsl_elbc_read_buf(mtd, buf, mtd->writesize);\r\nfsl_elbc_read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (fsl_elbc_wait(mtd, chip) & NAND_STATUS_FAIL)\r\nmtd->ecc_stats.failed++;\r\nreturn 0;\r\n}\r\nstatic void fsl_elbc_write_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf)\r\n{\r\nstruct fsl_elbc_mtd *priv = chip->priv;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nfsl_elbc_write_buf(mtd, buf, mtd->writesize);\r\nfsl_elbc_write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nelbc_fcm_ctrl->oob_poi = chip->oob_poi;\r\n}\r\nstatic int fsl_elbc_chip_init(struct fsl_elbc_mtd *priv)\r\n{\r\nstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\r\nstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\r\nstruct nand_chip *chip = &priv->chip;\r\ndev_dbg(priv->dev, "eLBC Set Information for bank %d\n", priv->bank);\r\npriv->mtd.priv = chip;\r\npriv->mtd.owner = THIS_MODULE;\r\npriv->fmr = in_be32(&lbc->fmr) & FMR_ECCM;\r\nchip->read_byte = fsl_elbc_read_byte;\r\nchip->write_buf = fsl_elbc_write_buf;\r\nchip->read_buf = fsl_elbc_read_buf;\r\nchip->verify_buf = fsl_elbc_verify_buf;\r\nchip->select_chip = fsl_elbc_select_chip;\r\nchip->cmdfunc = fsl_elbc_cmdfunc;\r\nchip->waitfunc = fsl_elbc_wait;\r\nchip->bbt_td = &bbt_main_descr;\r\nchip->bbt_md = &bbt_mirror_descr;\r\nchip->options = NAND_NO_READRDY | NAND_NO_AUTOINCR |\r\nNAND_USE_FLASH_BBT;\r\nchip->controller = &elbc_fcm_ctrl->controller;\r\nchip->priv = priv;\r\nchip->ecc.read_page = fsl_elbc_read_page;\r\nchip->ecc.write_page = fsl_elbc_write_page;\r\nif ((in_be32(&lbc->bank[priv->bank].br) & BR_DECC) ==\r\nBR_DECC_CHK_GEN) {\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.layout = (priv->fmr & FMR_ECCM) ?\r\n&fsl_elbc_oob_sp_eccm1 : &fsl_elbc_oob_sp_eccm0;\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 3;\r\n} else {\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_elbc_chip_remove(struct fsl_elbc_mtd *priv)\r\n{\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\r\nnand_release(&priv->mtd);\r\nkfree(priv->mtd.name);\r\nif (priv->vbase)\r\niounmap(priv->vbase);\r\nelbc_fcm_ctrl->chips[priv->bank] = NULL;\r\nkfree(priv);\r\nkfree(elbc_fcm_ctrl);\r\nreturn 0;\r\n}\r\nstatic int __devinit fsl_elbc_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_lbc_regs __iomem *lbc;\r\nstruct fsl_elbc_mtd *priv;\r\nstruct resource res;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl;\r\nstatic const char *part_probe_types[]\r\n= { "cmdlinepart", "RedBoot", NULL };\r\nstruct mtd_partition *parts;\r\nint ret;\r\nint bank;\r\nstruct device *dev;\r\nstruct device_node *node = pdev->dev.of_node;\r\nif (!fsl_lbc_ctrl_dev || !fsl_lbc_ctrl_dev->regs)\r\nreturn -ENODEV;\r\nlbc = fsl_lbc_ctrl_dev->regs;\r\ndev = fsl_lbc_ctrl_dev->dev;\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret) {\r\ndev_err(dev, "failed to get resource\n");\r\nreturn ret;\r\n}\r\nfor (bank = 0; bank < MAX_BANKS; bank++)\r\nif ((in_be32(&lbc->bank[bank].br) & BR_V) &&\r\n(in_be32(&lbc->bank[bank].br) & BR_MSEL) == BR_MS_FCM &&\r\n(in_be32(&lbc->bank[bank].br) &\r\nin_be32(&lbc->bank[bank].or) & BR_BA)\r\n== fsl_lbc_addr(res.start))\r\nbreak;\r\nif (bank >= MAX_BANKS) {\r\ndev_err(dev, "address did not match any chip selects\n");\r\nreturn -ENODEV;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_lock(&fsl_elbc_nand_mutex);\r\nif (!fsl_lbc_ctrl_dev->nand) {\r\nelbc_fcm_ctrl = kzalloc(sizeof(*elbc_fcm_ctrl), GFP_KERNEL);\r\nif (!elbc_fcm_ctrl) {\r\ndev_err(dev, "failed to allocate memory\n");\r\nmutex_unlock(&fsl_elbc_nand_mutex);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nelbc_fcm_ctrl->counter++;\r\nspin_lock_init(&elbc_fcm_ctrl->controller.lock);\r\ninit_waitqueue_head(&elbc_fcm_ctrl->controller.wq);\r\nfsl_lbc_ctrl_dev->nand = elbc_fcm_ctrl;\r\n} else {\r\nelbc_fcm_ctrl = fsl_lbc_ctrl_dev->nand;\r\n}\r\nmutex_unlock(&fsl_elbc_nand_mutex);\r\nelbc_fcm_ctrl->chips[bank] = priv;\r\npriv->bank = bank;\r\npriv->ctrl = fsl_lbc_ctrl_dev;\r\npriv->dev = dev;\r\npriv->vbase = ioremap(res.start, resource_size(&res));\r\nif (!priv->vbase) {\r\ndev_err(dev, "failed to map chip region\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\npriv->mtd.name = kasprintf(GFP_KERNEL, "%x.flash", (unsigned)res.start);\r\nif (!priv->mtd.name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = fsl_elbc_chip_init(priv);\r\nif (ret)\r\ngoto err;\r\nret = nand_scan_ident(&priv->mtd, 1, NULL);\r\nif (ret)\r\ngoto err;\r\nret = fsl_elbc_chip_init_tail(&priv->mtd);\r\nif (ret)\r\ngoto err;\r\nret = nand_scan_tail(&priv->mtd);\r\nif (ret)\r\ngoto err;\r\nret = parse_mtd_partitions(&priv->mtd, part_probe_types, &parts, 0);\r\nif (ret < 0)\r\ngoto err;\r\nif (ret == 0) {\r\nret = of_mtd_parse_partitions(priv->dev, node, &parts);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nmtd_device_register(&priv->mtd, parts, ret);\r\nprintk(KERN_INFO "eLBC NAND device at 0x%llx, bank %d\n",\r\n(unsigned long long)res.start, priv->bank);\r\nreturn 0;\r\nerr:\r\nfsl_elbc_chip_remove(priv);\r\nreturn ret;\r\n}\r\nstatic int fsl_elbc_nand_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = fsl_lbc_ctrl_dev->nand;\r\nfor (i = 0; i < MAX_BANKS; i++)\r\nif (elbc_fcm_ctrl->chips[i])\r\nfsl_elbc_chip_remove(elbc_fcm_ctrl->chips[i]);\r\nmutex_lock(&fsl_elbc_nand_mutex);\r\nelbc_fcm_ctrl->counter--;\r\nif (!elbc_fcm_ctrl->counter) {\r\nfsl_lbc_ctrl_dev->nand = NULL;\r\nkfree(elbc_fcm_ctrl);\r\n}\r\nmutex_unlock(&fsl_elbc_nand_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init fsl_elbc_nand_init(void)\r\n{\r\nreturn platform_driver_register(&fsl_elbc_nand_driver);\r\n}\r\nstatic void __exit fsl_elbc_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&fsl_elbc_nand_driver);\r\n}
