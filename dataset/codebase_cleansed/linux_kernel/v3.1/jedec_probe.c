static inline u32 jedec_read_mfr(struct map_info *map, uint32_t base,\r\nstruct cfi_private *cfi)\r\n{\r\nmap_word result;\r\nunsigned long mask;\r\nint bank = 0;\r\ndo {\r\nuint32_t ofs = cfi_build_cmd_addr(0 + (bank << 8), map, cfi);\r\nmask = (1 << (cfi->device_type * 8)) - 1;\r\nresult = map_read(map, base + ofs);\r\nbank++;\r\n} while ((result.x[0] & mask) == CFI_MFR_CONTINUATION);\r\nreturn result.x[0] & mask;\r\n}\r\nstatic inline u32 jedec_read_id(struct map_info *map, uint32_t base,\r\nstruct cfi_private *cfi)\r\n{\r\nmap_word result;\r\nunsigned long mask;\r\nu32 ofs = cfi_build_cmd_addr(1, map, cfi);\r\nmask = (1 << (cfi->device_type * 8)) -1;\r\nresult = map_read(map, base + ofs);\r\nreturn result.x[0] & mask;\r\n}\r\nstatic void jedec_reset(u32 base, struct map_info *map, struct cfi_private *cfi)\r\n{\r\nif (cfi->addr_unlock1) {\r\nDEBUG( MTD_DEBUG_LEVEL3,\r\n"reset unlock called %x %x \n",\r\ncfi->addr_unlock1,cfi->addr_unlock2);\r\ncfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, cfi->device_type, NULL);\r\n}\r\ncfi_send_gen_cmd(0xF0, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);\r\n}\r\nstatic int cfi_jedec_setup(struct map_info *map, struct cfi_private *cfi, int index)\r\n{\r\nint i,num_erase_regions;\r\nuint8_t uaddr;\r\nif (!(jedec_table[index].devtypes & cfi->device_type)) {\r\nDEBUG(MTD_DEBUG_LEVEL1, "Rejecting potential %s with incompatible %d-bit device type\n",\r\njedec_table[index].name, 4 * (1<<cfi->device_type));\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "Found: %s\n",jedec_table[index].name);\r\nnum_erase_regions = jedec_table[index].nr_regions;\r\ncfi->cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);\r\nif (!cfi->cfiq) {\r\nreturn 0;\r\n}\r\nmemset(cfi->cfiq, 0, sizeof(struct cfi_ident));\r\ncfi->cfiq->P_ID = jedec_table[index].cmd_set;\r\ncfi->cfiq->NumEraseRegions = jedec_table[index].nr_regions;\r\ncfi->cfiq->DevSize = jedec_table[index].dev_size;\r\ncfi->cfi_mode = CFI_MODE_JEDEC;\r\ncfi->sector_erase_cmd = CMD(0x30);\r\nfor (i=0; i<num_erase_regions; i++){\r\ncfi->cfiq->EraseRegionInfo[i] = jedec_table[index].regions[i];\r\n}\r\ncfi->cmdset_priv = NULL;\r\ncfi->mfr = jedec_table[index].mfr_id;\r\ncfi->id = jedec_table[index].dev_id;\r\nuaddr = jedec_table[index].uaddr;\r\ncfi->addr_unlock1 = unlock_addrs[uaddr].addr1 / cfi->device_type;\r\ncfi->addr_unlock2 = unlock_addrs[uaddr].addr2 / cfi->device_type;\r\nreturn 1;\r\n}\r\nstatic inline int jedec_match( uint32_t base,\r\nstruct map_info *map,\r\nstruct cfi_private *cfi,\r\nconst struct amd_flash_info *finfo )\r\n{\r\nint rc = 0;\r\nu32 mfr, id;\r\nuint8_t uaddr;\r\nswitch (cfi->device_type) {\r\ncase CFI_DEVICETYPE_X8:\r\nmfr = (uint8_t)finfo->mfr_id;\r\nid = (uint8_t)finfo->dev_id;\r\nif (finfo->dev_id > 0xff) {\r\nDEBUG( MTD_DEBUG_LEVEL3, "%s(): ID is not 8bit\n",\r\n__func__);\r\ngoto match_done;\r\n}\r\nbreak;\r\ncase CFI_DEVICETYPE_X16:\r\nmfr = (uint16_t)finfo->mfr_id;\r\nid = (uint16_t)finfo->dev_id;\r\nbreak;\r\ncase CFI_DEVICETYPE_X32:\r\nmfr = (uint16_t)finfo->mfr_id;\r\nid = (uint32_t)finfo->dev_id;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"MTD %s(): Unsupported device type %d\n",\r\n__func__, cfi->device_type);\r\ngoto match_done;\r\n}\r\nif ( cfi->mfr != mfr || cfi->id != id ) {\r\ngoto match_done;\r\n}\r\nDEBUG( MTD_DEBUG_LEVEL3,\r\n"MTD %s(): Check fit 0x%.8x + 0x%.8x = 0x%.8x\n",\r\n__func__, base, 1 << finfo->dev_size, base + (1 << finfo->dev_size) );\r\nif ( base + cfi_interleave(cfi) * ( 1 << finfo->dev_size ) > map->size ) {\r\nDEBUG( MTD_DEBUG_LEVEL3,\r\n"MTD %s(): 0x%.4x 0x%.4x %dKiB doesn't fit\n",\r\n__func__, finfo->mfr_id, finfo->dev_id,\r\n1 << finfo->dev_size );\r\ngoto match_done;\r\n}\r\nif (! (finfo->devtypes & cfi->device_type))\r\ngoto match_done;\r\nuaddr = finfo->uaddr;\r\nDEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): check unlock addrs 0x%.4x 0x%.4x\n",\r\n__func__, cfi->addr_unlock1, cfi->addr_unlock2 );\r\nif ( MTD_UADDR_UNNECESSARY != uaddr && MTD_UADDR_DONT_CARE != uaddr\r\n&& ( unlock_addrs[uaddr].addr1 / cfi->device_type != cfi->addr_unlock1 ||\r\nunlock_addrs[uaddr].addr2 / cfi->device_type != cfi->addr_unlock2 ) ) {\r\nDEBUG( MTD_DEBUG_LEVEL3,\r\n"MTD %s(): 0x%.4x 0x%.4x did not match\n",\r\n__func__,\r\nunlock_addrs[uaddr].addr1,\r\nunlock_addrs[uaddr].addr2);\r\ngoto match_done;\r\n}\r\nDEBUG( MTD_DEBUG_LEVEL3,\r\n"MTD %s(): check ID's disappear when not in ID mode\n",\r\n__func__ );\r\njedec_reset( base, map, cfi );\r\nmfr = jedec_read_mfr( map, base, cfi );\r\nid = jedec_read_id( map, base, cfi );\r\nif ( mfr == cfi->mfr && id == cfi->id ) {\r\nDEBUG( MTD_DEBUG_LEVEL3,\r\n"MTD %s(): ID 0x%.2x:0x%.2x did not change after reset:\n"\r\n"You might need to manually specify JEDEC parameters.\n",\r\n__func__, cfi->mfr, cfi->id );\r\ngoto match_done;\r\n}\r\nrc = 1;\r\nDEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): return to ID mode\n", __func__ );\r\nif (cfi->addr_unlock1) {\r\ncfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, cfi->device_type, NULL);\r\n}\r\ncfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);\r\nmatch_done:\r\nreturn rc;\r\n}\r\nstatic int jedec_probe_chip(struct map_info *map, __u32 base,\r\nunsigned long *chip_map, struct cfi_private *cfi)\r\n{\r\nint i;\r\nenum uaddr uaddr_idx = MTD_UADDR_NOT_SUPPORTED;\r\nu32 probe_offset1, probe_offset2;\r\nretry:\r\nif (!cfi->numchips) {\r\nuaddr_idx++;\r\nif (MTD_UADDR_UNNECESSARY == uaddr_idx)\r\nreturn 0;\r\ncfi->addr_unlock1 = unlock_addrs[uaddr_idx].addr1 / cfi->device_type;\r\ncfi->addr_unlock2 = unlock_addrs[uaddr_idx].addr2 / cfi->device_type;\r\n}\r\nif (base >= map->size) {\r\nprintk(KERN_NOTICE\r\n"Probe at base(0x%08x) past the end of the map(0x%08lx)\n",\r\nbase, map->size -1);\r\nreturn 0;\r\n}\r\nprobe_offset1 = cfi_build_cmd_addr(cfi->addr_unlock1, map, cfi);\r\nprobe_offset2 = cfi_build_cmd_addr(cfi->addr_unlock2, map, cfi);\r\nif ( ((base + probe_offset1 + map_bankwidth(map)) >= map->size) ||\r\n((base + probe_offset2 + map_bankwidth(map)) >= map->size))\r\ngoto retry;\r\njedec_reset(base, map, cfi);\r\nif(cfi->addr_unlock1) {\r\ncfi_send_gen_cmd(0xaa, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, cfi->device_type, NULL);\r\n}\r\ncfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);\r\nif (!cfi->numchips) {\r\ncfi->mfr = jedec_read_mfr(map, base, cfi);\r\ncfi->id = jedec_read_id(map, base, cfi);\r\nDEBUG(MTD_DEBUG_LEVEL3,\r\n"Search for id:(%02x %02x) interleave(%d) type(%d)\n",\r\ncfi->mfr, cfi->id, cfi_interleave(cfi), cfi->device_type);\r\nfor (i = 0; i < ARRAY_SIZE(jedec_table); i++) {\r\nif ( jedec_match( base, map, cfi, &jedec_table[i] ) ) {\r\nDEBUG( MTD_DEBUG_LEVEL3,\r\n"MTD %s(): matched device 0x%x,0x%x unlock_addrs: 0x%.4x 0x%.4x\n",\r\n__func__, cfi->mfr, cfi->id,\r\ncfi->addr_unlock1, cfi->addr_unlock2 );\r\nif (!cfi_jedec_setup(map, cfi, i))\r\nreturn 0;\r\ngoto ok_out;\r\n}\r\n}\r\ngoto retry;\r\n} else {\r\nuint16_t mfr;\r\nuint16_t id;\r\nmfr = jedec_read_mfr(map, base, cfi);\r\nid = jedec_read_id(map, base, cfi);\r\nif ((mfr != cfi->mfr) || (id != cfi->id)) {\r\nprintk(KERN_DEBUG "%s: Found different chip or no chip at all (mfr 0x%x, id 0x%x) at 0x%x\n",\r\nmap->name, mfr, id, base);\r\njedec_reset(base, map, cfi);\r\nreturn 0;\r\n}\r\n}\r\nfor (i=0; i < (base >> cfi->chipshift); i++) {\r\nunsigned long start;\r\nif(!test_bit(i, chip_map)) {\r\ncontinue;\r\n}\r\nstart = i << cfi->chipshift;\r\nif (jedec_read_mfr(map, start, cfi) == cfi->mfr &&\r\njedec_read_id(map, start, cfi) == cfi->id) {\r\njedec_reset(start, map, cfi);\r\nif (jedec_read_mfr(map, base, cfi) != cfi->mfr ||\r\njedec_read_id(map, base, cfi) != cfi->id) {\r\nprintk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",\r\nmap->name, base, start);\r\nreturn 0;\r\n}\r\njedec_reset(base, map, cfi);\r\nif (jedec_read_mfr(map, base, cfi) == cfi->mfr &&\r\njedec_read_id(map, base, cfi) == cfi->id) {\r\nprintk(KERN_DEBUG "%s: Found an alias at 0x%x for the chip at 0x%lx\n",\r\nmap->name, base, start);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nset_bit((base >> cfi->chipshift), chip_map);\r\ncfi->numchips++;\r\nok_out:\r\njedec_reset(base, map, cfi);\r\nprintk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank\n",\r\nmap->name, cfi_interleave(cfi), cfi->device_type*8, base,\r\nmap->bankwidth*8);\r\nreturn 1;\r\n}\r\nstatic struct mtd_info *jedec_probe(struct map_info *map)\r\n{\r\nreturn mtd_do_chip_probe(map, &jedec_chip_probe);\r\n}\r\nstatic int __init jedec_probe_init(void)\r\n{\r\nregister_mtd_chip_driver(&jedec_chipdrv);\r\nreturn 0;\r\n}\r\nstatic void __exit jedec_probe_exit(void)\r\n{\r\nunregister_mtd_chip_driver(&jedec_chipdrv);\r\n}
