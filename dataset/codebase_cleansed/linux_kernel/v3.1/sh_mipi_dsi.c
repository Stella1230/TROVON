static struct sh_mipi *sh_mipi_by_handle(int handle)\r\n{\r\nif (handle >= ARRAY_SIZE(mipi_dsi) || handle < 0)\r\nreturn NULL;\r\nreturn mipi_dsi[handle];\r\n}\r\nstatic int sh_mipi_send_short(struct sh_mipi *mipi, u8 dsi_cmd,\r\nu8 cmd, u8 param)\r\n{\r\nu32 data = (dsi_cmd << 24) | (cmd << 16) | (param << 8);\r\nint cnt = 100;\r\niowrite32(1 | data, mipi->linkbase + CMTSRTCTR);\r\niowrite32(1, mipi->linkbase + CMTSRTREQ);\r\nwhile ((ioread32(mipi->linkbase + CMTSRTREQ) & 1) && --cnt)\r\nudelay(1);\r\nreturn cnt ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int sh_mipi_dcs(int handle, u8 cmd)\r\n{\r\nstruct sh_mipi *mipi = sh_mipi_by_handle(LCD_CHAN2MIPI(handle));\r\nif (!mipi)\r\nreturn -ENODEV;\r\nreturn sh_mipi_send_short(mipi, MIPI_DSI_DCS_SHORT_WRITE, cmd, 0);\r\n}\r\nstatic int sh_mipi_dcs_param(int handle, u8 cmd, u8 param)\r\n{\r\nstruct sh_mipi *mipi = sh_mipi_by_handle(LCD_CHAN2MIPI(handle));\r\nif (!mipi)\r\nreturn -ENODEV;\r\nreturn sh_mipi_send_short(mipi, MIPI_DSI_DCS_SHORT_WRITE_PARAM, cmd,\r\nparam);\r\n}\r\nstatic void sh_mipi_dsi_enable(struct sh_mipi *mipi, bool enable)\r\n{\r\niowrite32(0x00000002 | enable, mipi->linkbase + DTCTR);\r\n}\r\nstatic void sh_mipi_shutdown(struct platform_device *pdev)\r\n{\r\nstruct sh_mipi *mipi = platform_get_drvdata(pdev);\r\nsh_mipi_dsi_enable(mipi, false);\r\n}\r\nstatic void mipi_display_on(void *arg, struct fb_info *info)\r\n{\r\nstruct sh_mipi *mipi = arg;\r\npm_runtime_get_sync(mipi->dev);\r\nsh_mipi_dsi_enable(mipi, true);\r\nif (mipi->next_display_on)\r\nmipi->next_display_on(mipi->next_board_data, info);\r\n}\r\nstatic void mipi_display_off(void *arg)\r\n{\r\nstruct sh_mipi *mipi = arg;\r\nif (mipi->next_display_off)\r\nmipi->next_display_off(mipi->next_board_data);\r\nsh_mipi_dsi_enable(mipi, false);\r\npm_runtime_put(mipi->dev);\r\n}\r\nstatic int __init sh_mipi_setup(struct sh_mipi *mipi,\r\nstruct sh_mipi_dsi_info *pdata)\r\n{\r\nvoid __iomem *base = mipi->base;\r\nstruct sh_mobile_lcdc_chan_cfg *ch = pdata->lcd_chan;\r\nu32 pctype, datatype, pixfmt, linelength, vmctr2 = 0x00e00000;\r\nbool yuv;\r\nswitch (pdata->data_format) {\r\ncase MIPI_RGB888:\r\npctype = 0;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_24;\r\npixfmt = MIPI_DCS_PIXEL_FMT_24BIT;\r\nlinelength = ch->lcd_cfg[0].xres * 3;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_RGB565:\r\npctype = 1;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_16;\r\npixfmt = MIPI_DCS_PIXEL_FMT_16BIT;\r\nlinelength = ch->lcd_cfg[0].xres * 2;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_RGB666_LP:\r\npctype = 2;\r\ndatatype = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\r\npixfmt = MIPI_DCS_PIXEL_FMT_24BIT;\r\nlinelength = ch->lcd_cfg[0].xres * 3;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_RGB666:\r\npctype = 3;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_18;\r\npixfmt = MIPI_DCS_PIXEL_FMT_18BIT;\r\nlinelength = (ch->lcd_cfg[0].xres * 18 + 7) / 8;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_BGR888:\r\npctype = 8;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_24;\r\npixfmt = MIPI_DCS_PIXEL_FMT_24BIT;\r\nlinelength = ch->lcd_cfg[0].xres * 3;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_BGR565:\r\npctype = 9;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_16;\r\npixfmt = MIPI_DCS_PIXEL_FMT_16BIT;\r\nlinelength = ch->lcd_cfg[0].xres * 2;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_BGR666_LP:\r\npctype = 0xa;\r\ndatatype = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\r\npixfmt = MIPI_DCS_PIXEL_FMT_24BIT;\r\nlinelength = ch->lcd_cfg[0].xres * 3;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_BGR666:\r\npctype = 0xb;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_18;\r\npixfmt = MIPI_DCS_PIXEL_FMT_18BIT;\r\nlinelength = (ch->lcd_cfg[0].xres * 18 + 7) / 8;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_YUYV:\r\npctype = 4;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16;\r\npixfmt = MIPI_DCS_PIXEL_FMT_16BIT;\r\nlinelength = ch->lcd_cfg[0].xres * 2;\r\nyuv = true;\r\nbreak;\r\ncase MIPI_UYVY:\r\npctype = 5;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16;\r\npixfmt = MIPI_DCS_PIXEL_FMT_16BIT;\r\nlinelength = ch->lcd_cfg[0].xres * 2;\r\nyuv = true;\r\nbreak;\r\ncase MIPI_YUV420_L:\r\npctype = 6;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12;\r\npixfmt = MIPI_DCS_PIXEL_FMT_12BIT;\r\nlinelength = (ch->lcd_cfg[0].xres * 12 + 7) / 8;\r\nyuv = true;\r\nbreak;\r\ncase MIPI_YUV420:\r\npctype = 7;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12;\r\npixfmt = MIPI_DCS_PIXEL_FMT_12BIT;\r\nlinelength = (ch->lcd_cfg[0].xres + 1) / 2;\r\nyuv = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((yuv && ch->interface_type != YUV422) ||\r\n(!yuv && ch->interface_type != RGB24))\r\nreturn -EINVAL;\r\niowrite32(0x00000001, base + SYSCTRL);\r\nudelay(50);\r\niowrite32(0x00000000, base + SYSCTRL);\r\niowrite32(0x00003703, base + SYSCONF);\r\niowrite32(0x70003332, base + TIMSET);\r\niowrite32(0x00000000, base + RESREQSET0);\r\niowrite32(0x00000100, base + RESREQSET1);\r\niowrite32(0x0fffffff, base + HSTTOVSET);\r\niowrite32(0x0fffffff, base + LPRTOVSET);\r\niowrite32(0x0fffffff, base + TATOVSET);\r\niowrite32(0x0fffffff, base + PRTOVSET);\r\niowrite32(0x00000f00, base + DSICTRL);\r\niowrite32(0, base + DSIINTE);\r\niowrite32(0x00000001, base + PHYCTRL);\r\nudelay(200);\r\niowrite32(0x03070b01, base + PHYCTRL);\r\niowrite32(0x00000006, mipi->linkbase + DTCTR);\r\niowrite32((ch->lcd_cfg[0].vsync_len << pdata->vsynw_offset) |\r\n(pdata->clksrc << 16) | (pctype << 12) | datatype,\r\nmipi->linkbase + VMCTR1);\r\nif (pdata->flags & SH_MIPI_DSI_HSABM)\r\nvmctr2 |= 0x20;\r\nif (pdata->flags & SH_MIPI_DSI_HSPBM)\r\nvmctr2 |= 0x10;\r\niowrite32(vmctr2, mipi->linkbase + VMCTR2);\r\niowrite32(1 | (linelength << 16), mipi->linkbase + VMLEN1);\r\nmsleep(5);\r\nsh_mipi_dcs(ch->chan, MIPI_DCS_EXIT_SLEEP_MODE);\r\nmsleep(120);\r\nsh_mipi_dcs_param(ch->chan, MIPI_DCS_SET_ADDRESS_MODE, 0x00);\r\nsh_mipi_dcs_param(ch->chan, MIPI_DCS_SET_PIXEL_FORMAT,\r\npixfmt << 4);\r\nsh_mipi_dcs(ch->chan, MIPI_DCS_SET_DISPLAY_ON);\r\nreturn 0;\r\n}\r\nstatic int __init sh_mipi_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mipi *mipi;\r\nstruct sh_mipi_dsi_info *pdata = pdev->dev.platform_data;\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *res2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nunsigned long rate, f_current;\r\nint idx = pdev->id, ret;\r\nchar dsip_clk[] = "dsi.p_clk";\r\nif (!res || !res2 || idx >= ARRAY_SIZE(mipi_dsi) || !pdata)\r\nreturn -ENODEV;\r\nmutex_lock(&array_lock);\r\nif (idx < 0)\r\nfor (idx = 0; idx < ARRAY_SIZE(mipi_dsi) && mipi_dsi[idx]; idx++)\r\n;\r\nif (idx == ARRAY_SIZE(mipi_dsi)) {\r\nret = -EBUSY;\r\ngoto efindslot;\r\n}\r\nmipi = kzalloc(sizeof(*mipi), GFP_KERNEL);\r\nif (!mipi) {\r\nret = -ENOMEM;\r\ngoto ealloc;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\ndev_err(&pdev->dev, "MIPI register region already claimed\n");\r\nret = -EBUSY;\r\ngoto ereqreg;\r\n}\r\nmipi->base = ioremap(res->start, resource_size(res));\r\nif (!mipi->base) {\r\nret = -ENOMEM;\r\ngoto emap;\r\n}\r\nif (!request_mem_region(res2->start, resource_size(res2), pdev->name)) {\r\ndev_err(&pdev->dev, "MIPI register region 2 already claimed\n");\r\nret = -EBUSY;\r\ngoto ereqreg2;\r\n}\r\nmipi->linkbase = ioremap(res2->start, resource_size(res2));\r\nif (!mipi->linkbase) {\r\nret = -ENOMEM;\r\ngoto emap2;\r\n}\r\nmipi->dev = &pdev->dev;\r\nmipi->dsit_clk = clk_get(&pdev->dev, "dsit_clk");\r\nif (IS_ERR(mipi->dsit_clk)) {\r\nret = PTR_ERR(mipi->dsit_clk);\r\ngoto eclktget;\r\n}\r\nf_current = clk_get_rate(mipi->dsit_clk);\r\nrate = clk_round_rate(mipi->dsit_clk, 80000000);\r\nif (rate > 0 && rate != f_current)\r\nret = clk_set_rate(mipi->dsit_clk, rate);\r\nelse\r\nret = rate;\r\nif (ret < 0)\r\ngoto esettrate;\r\ndev_dbg(&pdev->dev, "DSI-T clk %lu -> %lu\n", f_current, rate);\r\nsprintf(dsip_clk, "dsi%1.1dp_clk", idx);\r\nmipi->dsip_clk = clk_get(&pdev->dev, dsip_clk);\r\nif (IS_ERR(mipi->dsip_clk)) {\r\nret = PTR_ERR(mipi->dsip_clk);\r\ngoto eclkpget;\r\n}\r\nf_current = clk_get_rate(mipi->dsip_clk);\r\nrate = clk_round_rate(mipi->dsip_clk, 24000000);\r\nif (rate > 0 && rate != f_current)\r\nret = clk_set_rate(mipi->dsip_clk, rate);\r\nelse\r\nret = rate;\r\nif (ret < 0)\r\ngoto esetprate;\r\ndev_dbg(&pdev->dev, "DSI-P clk %lu -> %lu\n", f_current, rate);\r\nmsleep(10);\r\nret = clk_enable(mipi->dsit_clk);\r\nif (ret < 0)\r\ngoto eclkton;\r\nret = clk_enable(mipi->dsip_clk);\r\nif (ret < 0)\r\ngoto eclkpon;\r\nmipi_dsi[idx] = mipi;\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_resume(&pdev->dev);\r\nret = sh_mipi_setup(mipi, pdata);\r\nif (ret < 0)\r\ngoto emipisetup;\r\nmutex_unlock(&array_lock);\r\nplatform_set_drvdata(pdev, mipi);\r\nmipi->next_board_data = pdata->lcd_chan->board_cfg.board_data;\r\nmipi->next_display_on = pdata->lcd_chan->board_cfg.display_on;\r\nmipi->next_display_off = pdata->lcd_chan->board_cfg.display_off;\r\npdata->lcd_chan->board_cfg.board_data = mipi;\r\npdata->lcd_chan->board_cfg.display_on = mipi_display_on;\r\npdata->lcd_chan->board_cfg.display_off = mipi_display_off;\r\npdata->lcd_chan->board_cfg.owner = THIS_MODULE;\r\nreturn 0;\r\nemipisetup:\r\nmipi_dsi[idx] = NULL;\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable(mipi->dsip_clk);\r\neclkpon:\r\nclk_disable(mipi->dsit_clk);\r\neclkton:\r\nesetprate:\r\nclk_put(mipi->dsip_clk);\r\neclkpget:\r\nesettrate:\r\nclk_put(mipi->dsit_clk);\r\neclktget:\r\niounmap(mipi->linkbase);\r\nemap2:\r\nrelease_mem_region(res2->start, resource_size(res2));\r\nereqreg2:\r\niounmap(mipi->base);\r\nemap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nereqreg:\r\nkfree(mipi);\r\nealloc:\r\nefindslot:\r\nmutex_unlock(&array_lock);\r\nreturn ret;\r\n}\r\nstatic int __exit sh_mipi_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_mipi_dsi_info *pdata = pdev->dev.platform_data;\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *res2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nstruct sh_mipi *mipi = platform_get_drvdata(pdev);\r\nint i, ret;\r\nmutex_lock(&array_lock);\r\nfor (i = 0; i < ARRAY_SIZE(mipi_dsi) && mipi_dsi[i] != mipi; i++)\r\n;\r\nif (i == ARRAY_SIZE(mipi_dsi)) {\r\nret = -EINVAL;\r\n} else {\r\nret = 0;\r\nmipi_dsi[i] = NULL;\r\n}\r\nmutex_unlock(&array_lock);\r\nif (ret < 0)\r\nreturn ret;\r\npdata->lcd_chan->board_cfg.owner = NULL;\r\npdata->lcd_chan->board_cfg.display_on = NULL;\r\npdata->lcd_chan->board_cfg.display_off = NULL;\r\npdata->lcd_chan->board_cfg.board_data = NULL;\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable(mipi->dsip_clk);\r\nclk_disable(mipi->dsit_clk);\r\nclk_put(mipi->dsit_clk);\r\nclk_put(mipi->dsip_clk);\r\niounmap(mipi->linkbase);\r\nif (res2)\r\nrelease_mem_region(res2->start, resource_size(res2));\r\niounmap(mipi->base);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(mipi);\r\nreturn 0;\r\n}\r\nstatic int __init sh_mipi_init(void)\r\n{\r\nreturn platform_driver_probe(&sh_mipi_driver, sh_mipi_probe);\r\n}\r\nstatic void __exit sh_mipi_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_mipi_driver);\r\n}
