static int pci_dio_insn_bits_di_b(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nint i;\r\ndata[1] = 0;\r\nfor (i = 0; i < d->regs; i++)\r\ndata[1] |= inb(dev->iobase + d->addr + i) << (8 * i);\r\nreturn 2;\r\n}\r\nstatic int pci_dio_insn_bits_di_w(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nint i;\r\ndata[1] = 0;\r\nfor (i = 0; i < d->regs; i++)\r\ndata[1] |= inw(dev->iobase + d->addr + 2 * i) << (16 * i);\r\nreturn 2;\r\n}\r\nstatic int pci_dio_insn_bits_do_b(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nint i;\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nfor (i = 0; i < d->regs; i++)\r\noutb((s->state >> (8 * i)) & 0xff,\r\ndev->iobase + d->addr + i);\r\n}\r\ndata[1] = s->state;\r\nreturn 2;\r\n}\r\nstatic int pci_dio_insn_bits_do_w(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nint i;\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nfor (i = 0; i < d->regs; i++)\r\noutw((s->state >> (16 * i)) & 0xffff,\r\ndev->iobase + d->addr + 2 * i);\r\n}\r\ndata[1] = s->state;\r\nreturn 2;\r\n}\r\nstatic int pci_8254_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nunsigned int chan, chip, chipchan;\r\nunsigned long flags;\r\nchan = CR_CHAN(insn->chanspec);\r\nchip = chan / 3;\r\nchipchan = chan - (3 * chip);\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\ndata[0] = i8254_read(dev->iobase + d->addr + (SIZE_8254 * chip),\r\n0, chipchan);\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\nreturn 1;\r\n}\r\nstatic int pci_8254_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nunsigned int chan, chip, chipchan;\r\nunsigned long flags;\r\nchan = CR_CHAN(insn->chanspec);\r\nchip = chan / 3;\r\nchipchan = chan - (3 * chip);\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\ni8254_write(dev->iobase + d->addr + (SIZE_8254 * chip),\r\n0, chipchan, data[0]);\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\nreturn 1;\r\n}\r\nstatic int pci_8254_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct diosubd_data *d = (const struct diosubd_data *)s->private;\r\nunsigned int chan, chip, chipchan;\r\nunsigned long iobase;\r\nint ret = 0;\r\nunsigned long flags;\r\nchan = CR_CHAN(insn->chanspec);\r\nchip = chan / 3;\r\nchipchan = chan - (3 * chip);\r\niobase = dev->iobase + d->addr + (SIZE_8254 * chip);\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SET_COUNTER_MODE:\r\nret = i8254_set_mode(iobase, 0, chipchan, data[1]);\r\nif (ret < 0)\r\nret = -EINVAL;\r\nbreak;\r\ncase INSN_CONFIG_8254_READ_STATUS:\r\ndata[1] = i8254_status(iobase, 0, chipchan);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\nreturn ret < 0 ? ret : insn->n;\r\n}\r\nstatic int pci1760_unchecked_mbxrequest(struct comedi_device *dev,\r\nunsigned char *omb, unsigned char *imb,\r\nint repeats)\r\n{\r\nint cnt, tout, ok = 0;\r\nfor (cnt = 0; cnt < repeats; cnt++) {\r\noutb(omb[0], dev->iobase + OMB0);\r\noutb(omb[1], dev->iobase + OMB1);\r\noutb(omb[2], dev->iobase + OMB2);\r\noutb(omb[3], dev->iobase + OMB3);\r\nfor (tout = 0; tout < 251; tout++) {\r\nimb[2] = inb(dev->iobase + IMB2);\r\nif (imb[2] == omb[2]) {\r\nimb[0] = inb(dev->iobase + IMB0);\r\nimb[1] = inb(dev->iobase + IMB1);\r\nimb[3] = inb(dev->iobase + IMB3);\r\nok = 1;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (ok)\r\nreturn 0;\r\n}\r\ncomedi_error(dev, "PCI-1760 mailbox request timeout!");\r\nreturn -ETIME;\r\n}\r\nstatic int pci1760_clear_imb2(struct comedi_device *dev)\r\n{\r\nunsigned char omb[4] = { 0x0, 0x0, CMD_ClearIMB2, 0x0 };\r\nunsigned char imb[4];\r\nif (inb(dev->iobase + IMB2) == CMD_ClearIMB2)\r\nreturn 0;\r\nreturn pci1760_unchecked_mbxrequest(dev, omb, imb, OMBCMD_RETRY);\r\n}\r\nstatic int pci1760_mbxrequest(struct comedi_device *dev,\r\nunsigned char *omb, unsigned char *imb)\r\n{\r\nif (omb[2] == CMD_ClearIMB2) {\r\ncomedi_error(dev,\r\n"bug! this function should not be used for CMD_ClearIMB2 command");\r\nreturn -EINVAL;\r\n}\r\nif (inb(dev->iobase + IMB2) == omb[2]) {\r\nint retval;\r\nretval = pci1760_clear_imb2(dev);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn pci1760_unchecked_mbxrequest(dev, omb, imb, OMBCMD_RETRY);\r\n}\r\nstatic int pci1760_insn_bits_di(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + IMB3);\r\nreturn 2;\r\n}\r\nstatic int pci1760_insn_bits_do(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint ret;\r\nunsigned char omb[4] = {\r\n0x00,\r\n0x00,\r\nCMD_SetRelaysOutput,\r\n0x00\r\n};\r\nunsigned char imb[4];\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nomb[0] = s->state;\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\n}\r\ndata[1] = s->state;\r\nreturn 2;\r\n}\r\nstatic int pci1760_insn_cnt_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint ret, n;\r\nunsigned char omb[4] = {\r\nCR_CHAN(insn->chanspec) & 0x07,\r\n0x00,\r\nCMD_GetIDICntCurValue,\r\n0x00\r\n};\r\nunsigned char imb[4];\r\nfor (n = 0; n < insn->n; n++) {\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\ndata[n] = (imb[1] << 8) + imb[0];\r\n}\r\nreturn n;\r\n}\r\nstatic int pci1760_insn_cnt_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint ret;\r\nunsigned char chan = CR_CHAN(insn->chanspec) & 0x07;\r\nunsigned char bitmask = 1 << chan;\r\nunsigned char omb[4] = {\r\ndata[0] & 0xff,\r\n(data[0] >> 8) & 0xff,\r\nCMD_SetIDI0CntResetValue + chan,\r\n0x00\r\n};\r\nunsigned char imb[4];\r\nif (devpriv->CntResValue[chan] != (data[0] & 0xffff)) {\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\ndevpriv->CntResValue[chan] = data[0] & 0xffff;\r\n}\r\nomb[0] = bitmask;\r\nomb[2] = CMD_ResetIDICounters;\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\nif (!(bitmask & devpriv->IDICntEnable)) {\r\nomb[0] = bitmask;\r\nomb[2] = CMD_EnableIDICounters;\r\nret = pci1760_mbxrequest(dev, omb, imb);\r\nif (!ret)\r\nreturn ret;\r\ndevpriv->IDICntEnable |= bitmask;\r\n}\r\nreturn 1;\r\n}\r\nstatic int pci1760_reset(struct comedi_device *dev)\r\n{\r\nint i;\r\nunsigned char omb[4] = { 0x00, 0x00, 0x00, 0x00 };\r\nunsigned char imb[4];\r\noutb(0, dev->iobase + INTCSR0);\r\noutb(0, dev->iobase + INTCSR1);\r\noutb(0, dev->iobase + INTCSR2);\r\noutb(0, dev->iobase + INTCSR3);\r\ndevpriv->GlobalIrqEnabled = 0;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_SetRelaysOutput;\r\npci1760_mbxrequest(dev, omb, imb);\r\nomb[0] = 0x00;\r\nomb[2] = CMD_EnableIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDICntEnable = 0;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_OverflowIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDICntOverEnable = 0;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_MatchIntIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDICntMatchEnable = 0;\r\nomb[0] = 0x00;\r\nomb[1] = 0x80;\r\nfor (i = 0; i < 8; i++) {\r\nomb[2] = CMD_SetIDI0CntMatchValue + i;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->CntMatchValue[i] = 0x8000;\r\n}\r\nomb[0] = 0x00;\r\nomb[1] = 0x00;\r\nfor (i = 0; i < 8; i++) {\r\nomb[2] = CMD_SetIDI0CntResetValue + i;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->CntResValue[i] = 0x0000;\r\n}\r\nomb[0] = 0xff;\r\nomb[2] = CMD_ResetIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\nomb[0] = 0x00;\r\nomb[2] = CMD_EdgeIDICounters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDICntEdge = 0x00;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_EnableIDIFilters;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDIFiltersEn = 0x00;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_EnableIDIPatternMatch;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDIPatMatchEn = 0x00;\r\nomb[0] = 0x00;\r\nomb[2] = CMD_SetIDIPatternMatch;\r\npci1760_mbxrequest(dev, omb, imb);\r\ndevpriv->IDIPatMatchValue = 0x00;\r\nreturn 0;\r\n}\r\nstatic int pci_dio_reset(struct comedi_device *dev)\r\n{\r\nDPRINTK("adv_pci_dio EDBG: BGN: pci171x_reset(...)\n");\r\nswitch (this_board->cardtype) {\r\ncase TYPE_PCI1730:\r\noutb(0, dev->iobase + PCI1730_DO);\r\noutb(0, dev->iobase + PCI1730_DO + 1);\r\noutb(0, dev->iobase + PCI1730_IDO);\r\noutb(0, dev->iobase + PCI1730_IDO + 1);\r\ncase TYPE_PCI1733:\r\noutb(0, dev->iobase + PCI1730_3_INT_EN);\r\noutb(0x0f, dev->iobase + PCI1730_3_INT_CLR);\r\noutb(0, dev->iobase + PCI1730_3_INT_RF);\r\nbreak;\r\ncase TYPE_PCI1734:\r\noutb(0, dev->iobase + PCI1734_IDO);\r\noutb(0, dev->iobase + PCI1734_IDO + 1);\r\noutb(0, dev->iobase + PCI1734_IDO + 2);\r\noutb(0, dev->iobase + PCI1734_IDO + 3);\r\nbreak;\r\ncase TYPE_PCI1735:\r\noutb(0, dev->iobase + PCI1735_DO);\r\noutb(0, dev->iobase + PCI1735_DO + 1);\r\noutb(0, dev->iobase + PCI1735_DO + 2);\r\noutb(0, dev->iobase + PCI1735_DO + 3);\r\ni8254_set_mode(dev->iobase + PCI1735_C8254, 0, 0, I8254_MODE0);\r\ni8254_set_mode(dev->iobase + PCI1735_C8254, 0, 1, I8254_MODE0);\r\ni8254_set_mode(dev->iobase + PCI1735_C8254, 0, 2, I8254_MODE0);\r\nbreak;\r\ncase TYPE_PCI1736:\r\noutb(0, dev->iobase + PCI1736_IDO);\r\noutb(0, dev->iobase + PCI1736_IDO + 1);\r\noutb(0, dev->iobase + PCI1736_3_INT_EN);\r\noutb(0x0f, dev->iobase + PCI1736_3_INT_CLR);\r\noutb(0, dev->iobase + PCI1736_3_INT_RF);\r\nbreak;\r\ncase TYPE_PCI1750:\r\ncase TYPE_PCI1751:\r\noutb(0x88, dev->iobase + PCI1750_ICR);\r\nbreak;\r\ncase TYPE_PCI1752:\r\noutw(0, dev->iobase + PCI1752_6_CFC);\r\noutw(0, dev->iobase + PCI1752_IDO);\r\noutw(0, dev->iobase + PCI1752_IDO + 2);\r\noutw(0, dev->iobase + PCI1752_IDO2);\r\noutw(0, dev->iobase + PCI1752_IDO2 + 2);\r\nbreak;\r\ncase TYPE_PCI1753E:\r\noutb(0x88, dev->iobase + PCI1753E_ICR0);\r\noutb(0x80, dev->iobase + PCI1753E_ICR1);\r\noutb(0x80, dev->iobase + PCI1753E_ICR2);\r\noutb(0x80, dev->iobase + PCI1753E_ICR3);\r\ncase TYPE_PCI1753:\r\noutb(0x88, dev->iobase + PCI1753_ICR0);\r\noutb(0x80, dev->iobase + PCI1753_ICR1);\r\noutb(0x80, dev->iobase + PCI1753_ICR2);\r\noutb(0x80, dev->iobase + PCI1753_ICR3);\r\nbreak;\r\ncase TYPE_PCI1754:\r\noutw(0x08, dev->iobase + PCI1754_6_ICR0);\r\noutw(0x08, dev->iobase + PCI1754_6_ICR1);\r\noutw(0x08, dev->iobase + PCI1754_ICR2);\r\noutw(0x08, dev->iobase + PCI1754_ICR3);\r\nbreak;\r\ncase TYPE_PCI1756:\r\noutw(0, dev->iobase + PCI1752_6_CFC);\r\noutw(0x08, dev->iobase + PCI1754_6_ICR0);\r\noutw(0x08, dev->iobase + PCI1754_6_ICR1);\r\noutw(0, dev->iobase + PCI1756_IDO);\r\noutw(0, dev->iobase + PCI1756_IDO + 2);\r\nbreak;\r\ncase TYPE_PCI1760:\r\npci1760_reset(dev);\r\nbreak;\r\ncase TYPE_PCI1762:\r\noutw(0x0101, dev->iobase + PCI1762_ICR);\r\nbreak;\r\n}\r\nDPRINTK("adv_pci_dio EDBG: END: pci171x_reset(...)\n");\r\nreturn 0;\r\n}\r\nstatic int pci1760_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint subdev = 0;\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->len_chanlist = 8;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pci1760_insn_bits_di;\r\nsubdev++;\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->len_chanlist = 8;\r\ns->range_table = &range_digital;\r\ns->state = 0;\r\ns->insn_bits = pci1760_insn_bits_do;\r\nsubdev++;\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_TIMER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_LSAMPL;\r\ns->n_chan = 2;\r\ns->maxdata = 0xffffffff;\r\ns->len_chanlist = 2;\r\nsubdev++;\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 0xffff;\r\ns->len_chanlist = 8;\r\ns->insn_read = pci1760_insn_cnt_read;\r\ns->insn_write = pci1760_insn_cnt_write;\r\nsubdev++;\r\nreturn 0;\r\n}\r\nstatic int pci_dio_add_di(struct comedi_device *dev, struct comedi_subdevice *s,\r\nconst struct diosubd_data *d, int subdev)\r\n{\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON | d->specflags;\r\nif (d->chans > 16)\r\ns->subdev_flags |= SDF_LSAMPL;\r\ns->n_chan = d->chans;\r\ns->maxdata = 1;\r\ns->len_chanlist = d->chans;\r\ns->range_table = &range_digital;\r\nswitch (this_board->io_access) {\r\ncase IO_8b:\r\ns->insn_bits = pci_dio_insn_bits_di_b;\r\nbreak;\r\ncase IO_16b:\r\ns->insn_bits = pci_dio_insn_bits_di_w;\r\nbreak;\r\n}\r\ns->private = (void *)d;\r\nreturn 0;\r\n}\r\nstatic int pci_dio_add_do(struct comedi_device *dev, struct comedi_subdevice *s,\r\nconst struct diosubd_data *d, int subdev)\r\n{\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\nif (d->chans > 16)\r\ns->subdev_flags |= SDF_LSAMPL;\r\ns->n_chan = d->chans;\r\ns->maxdata = 1;\r\ns->len_chanlist = d->chans;\r\ns->range_table = &range_digital;\r\ns->state = 0;\r\nswitch (this_board->io_access) {\r\ncase IO_8b:\r\ns->insn_bits = pci_dio_insn_bits_do_b;\r\nbreak;\r\ncase IO_16b:\r\ns->insn_bits = pci_dio_insn_bits_do_w;\r\nbreak;\r\n}\r\ns->private = (void *)d;\r\nreturn 0;\r\n}\r\nstatic int pci_dio_add_8254(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nconst struct diosubd_data *d, int subdev)\r\n{\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = d->chans;\r\ns->maxdata = 65535;\r\ns->len_chanlist = d->chans;\r\ns->insn_read = pci_8254_insn_read;\r\ns->insn_write = pci_8254_insn_write;\r\ns->insn_config = pci_8254_insn_config;\r\ns->private = (void *)d;\r\nreturn 0;\r\n}\r\nstatic int CheckAndAllocCard(struct comedi_device *dev,\r\nstruct comedi_devconfig *it,\r\nstruct pci_dev *pcidev)\r\n{\r\nstruct pci_dio_private *pr, *prev;\r\nfor (pr = pci_priv, prev = NULL; pr != NULL; prev = pr, pr = pr->next) {\r\nif (pr->pcidev == pcidev)\r\nreturn 0;\r\n}\r\nif (prev) {\r\ndevpriv->prev = prev;\r\nprev->next = devpriv;\r\n} else {\r\npci_priv = devpriv;\r\n}\r\ndevpriv->pcidev = pcidev;\r\nreturn 1;\r\n}\r\nstatic int pci_dio_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret, subdev, n_subdevices, i, j;\r\nunsigned long iobase;\r\nstruct pci_dev *pcidev = NULL;\r\nprintk("comedi%d: adv_pci_dio: ", dev->minor);\r\nret = alloc_private(dev, sizeof(struct pci_dio_private));\r\nif (ret < 0) {\r\nprintk(", Error: Cann't allocate private memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_pci_dev(pcidev) {\r\nfor (i = 0; i < n_boardtypes; ++i) {\r\nif (boardtypes[i].vendor_id != pcidev->vendor)\r\ncontinue;\r\nif (boardtypes[i].device_id != pcidev->device)\r\ncontinue;\r\nif (it->options[0] || it->options[1]) {\r\nif (pcidev->bus->number != it->options[0] ||\r\nPCI_SLOT(pcidev->devfn) != it->options[1]) {\r\ncontinue;\r\n}\r\n}\r\nret = CheckAndAllocCard(dev, it, pcidev);\r\nif (ret != 1)\r\ncontinue;\r\ndev->board_ptr = boardtypes + i;\r\nbreak;\r\n}\r\nif (dev->board_ptr)\r\nbreak;\r\n}\r\nif (!dev->board_ptr) {\r\nprintk(", Error: Requested type of the card was not found!\n");\r\nreturn -EIO;\r\n}\r\nif (comedi_pci_enable(pcidev, driver_pci_dio.driver_name)) {\r\nprintk\r\n(", Error: Can't enable PCI device and request regions!\n");\r\nreturn -EIO;\r\n}\r\niobase = pci_resource_start(pcidev, this_board->main_pci_region);\r\nprintk(", b:s:f=%d:%d:%d, io=0x%4lx",\r\npcidev->bus->number, PCI_SLOT(pcidev->devfn),\r\nPCI_FUNC(pcidev->devfn), iobase);\r\ndev->iobase = iobase;\r\ndev->board_name = this_board->name;\r\nif (this_board->cardtype == TYPE_PCI1760) {\r\nn_subdevices = 4;\r\n} else {\r\nn_subdevices = 0;\r\nfor (i = 0; i < MAX_DI_SUBDEVS; i++)\r\nif (this_board->sdi[i].chans)\r\nn_subdevices++;\r\nfor (i = 0; i < MAX_DO_SUBDEVS; i++)\r\nif (this_board->sdo[i].chans)\r\nn_subdevices++;\r\nfor (i = 0; i < MAX_DIO_SUBDEVG; i++)\r\nn_subdevices += this_board->sdio[i].regs;\r\nif (this_board->boardid.chans)\r\nn_subdevices++;\r\nfor (i = 0; i < MAX_8254_SUBDEVS; i++)\r\nif (this_board->s8254[i].chans)\r\nn_subdevices++;\r\n}\r\nret = alloc_subdevices(dev, n_subdevices);\r\nif (ret < 0) {\r\nprintk(", Error: Cann't allocate subdevice memory!\n");\r\nreturn ret;\r\n}\r\nprintk(".\n");\r\nsubdev = 0;\r\nfor (i = 0; i < MAX_DI_SUBDEVS; i++)\r\nif (this_board->sdi[i].chans) {\r\ns = dev->subdevices + subdev;\r\npci_dio_add_di(dev, s, &this_board->sdi[i], subdev);\r\nsubdev++;\r\n}\r\nfor (i = 0; i < MAX_DO_SUBDEVS; i++)\r\nif (this_board->sdo[i].chans) {\r\ns = dev->subdevices + subdev;\r\npci_dio_add_do(dev, s, &this_board->sdo[i], subdev);\r\nsubdev++;\r\n}\r\nfor (i = 0; i < MAX_DIO_SUBDEVG; i++)\r\nfor (j = 0; j < this_board->sdio[i].regs; j++) {\r\ns = dev->subdevices + subdev;\r\nsubdev_8255_init(dev, s, NULL,\r\ndev->iobase +\r\nthis_board->sdio[i].addr +\r\nSIZE_8255 * j);\r\nsubdev++;\r\n}\r\nif (this_board->boardid.chans) {\r\ns = dev->subdevices + subdev;\r\ns->type = COMEDI_SUBD_DI;\r\npci_dio_add_di(dev, s, &this_board->boardid, subdev);\r\nsubdev++;\r\n}\r\nfor (i = 0; i < MAX_8254_SUBDEVS; i++)\r\nif (this_board->s8254[i].chans) {\r\ns = dev->subdevices + subdev;\r\npci_dio_add_8254(dev, s, &this_board->s8254[i], subdev);\r\nsubdev++;\r\n}\r\nif (this_board->cardtype == TYPE_PCI1760)\r\npci1760_attach(dev, it);\r\ndevpriv->valid = 1;\r\npci_dio_reset(dev);\r\nreturn 0;\r\n}\r\nstatic int pci_dio_detach(struct comedi_device *dev)\r\n{\r\nint i, j;\r\nstruct comedi_subdevice *s;\r\nint subdev;\r\nif (dev->private) {\r\nif (devpriv->valid)\r\npci_dio_reset(dev);\r\nsubdev = 0;\r\nfor (i = 0; i < MAX_DI_SUBDEVS; i++) {\r\nif (this_board->sdi[i].chans)\r\nsubdev++;\r\n}\r\nfor (i = 0; i < MAX_DO_SUBDEVS; i++) {\r\nif (this_board->sdo[i].chans)\r\nsubdev++;\r\n}\r\nfor (i = 0; i < MAX_DIO_SUBDEVG; i++) {\r\nfor (j = 0; j < this_board->sdio[i].regs; j++) {\r\ns = dev->subdevices + subdev;\r\nsubdev_8255_cleanup(dev, s);\r\nsubdev++;\r\n}\r\n}\r\nif (this_board->boardid.chans)\r\nsubdev++;\r\nfor (i = 0; i < MAX_8254_SUBDEVS; i++)\r\nif (this_board->s8254[i].chans)\r\nsubdev++;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = dev->subdevices + i;\r\ns->private = NULL;\r\n}\r\nif (devpriv->pcidev) {\r\nif (dev->iobase)\r\ncomedi_pci_disable(devpriv->pcidev);\r\npci_dev_put(devpriv->pcidev);\r\n}\r\nif (devpriv->prev)\r\ndevpriv->prev->next = devpriv->next;\r\nelse\r\npci_priv = devpriv->next;\r\nif (devpriv->next)\r\ndevpriv->next->prev = devpriv->prev;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit driver_pci_dio_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_pci_dio.driver_name);\r\n}\r\nstatic void __devexit driver_pci_dio_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_pci_dio_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_pci_dio);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_pci_dio_pci_driver.name = (char *)driver_pci_dio.driver_name;\r\nreturn pci_register_driver(&driver_pci_dio_pci_driver);\r\n}\r\nstatic void __exit driver_pci_dio_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_pci_dio_pci_driver);\r\ncomedi_driver_unregister(&driver_pci_dio);\r\n}
