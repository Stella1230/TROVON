const char *mtrr_attrib_to_str(int x)\r\n{\r\nreturn (x <= 6) ? mtrr_strings[x] : "?";\r\n}\r\nstatic int\r\nmtrr_file_add(unsigned long base, unsigned long size,\r\nunsigned int type, bool increment, struct file *file, int page)\r\n{\r\nunsigned int *fcount = FILE_FCOUNT(file);\r\nint reg, max;\r\nmax = num_var_ranges;\r\nif (fcount == NULL) {\r\nfcount = kzalloc(max * sizeof *fcount, GFP_KERNEL);\r\nif (!fcount)\r\nreturn -ENOMEM;\r\nFILE_FCOUNT(file) = fcount;\r\n}\r\nif (!page) {\r\nif ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1)))\r\nreturn -EINVAL;\r\nbase >>= PAGE_SHIFT;\r\nsize >>= PAGE_SHIFT;\r\n}\r\nreg = mtrr_add_page(base, size, type, true);\r\nif (reg >= 0)\r\n++fcount[reg];\r\nreturn reg;\r\n}\r\nstatic int\r\nmtrr_file_del(unsigned long base, unsigned long size,\r\nstruct file *file, int page)\r\n{\r\nunsigned int *fcount = FILE_FCOUNT(file);\r\nint reg;\r\nif (!page) {\r\nif ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1)))\r\nreturn -EINVAL;\r\nbase >>= PAGE_SHIFT;\r\nsize >>= PAGE_SHIFT;\r\n}\r\nreg = mtrr_del_page(-1, base, size);\r\nif (reg < 0)\r\nreturn reg;\r\nif (fcount == NULL)\r\nreturn reg;\r\nif (fcount[reg] < 1)\r\nreturn -EINVAL;\r\n--fcount[reg];\r\nreturn reg;\r\n}\r\nstatic ssize_t\r\nmtrr_write(struct file *file, const char __user *buf, size_t len, loff_t * ppos)\r\n{\r\nint i, err;\r\nunsigned long reg;\r\nunsigned long long base, size;\r\nchar *ptr;\r\nchar line[LINE_SIZE];\r\nint length;\r\nsize_t linelen;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nmemset(line, 0, LINE_SIZE);\r\nlength = len;\r\nlength--;\r\nif (length > LINE_SIZE - 1)\r\nlength = LINE_SIZE - 1;\r\nif (length < 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(line, buf, length))\r\nreturn -EFAULT;\r\nlinelen = strlen(line);\r\nptr = line + linelen - 1;\r\nif (linelen && *ptr == '\n')\r\n*ptr = '\0';\r\nif (!strncmp(line, "disable=", 8)) {\r\nreg = simple_strtoul(line + 8, &ptr, 0);\r\nerr = mtrr_del_page(reg, 0, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn len;\r\n}\r\nif (strncmp(line, "base=", 5))\r\nreturn -EINVAL;\r\nbase = simple_strtoull(line + 5, &ptr, 0);\r\nptr = skip_spaces(ptr);\r\nif (strncmp(ptr, "size=", 5))\r\nreturn -EINVAL;\r\nsize = simple_strtoull(ptr + 5, &ptr, 0);\r\nif ((base & 0xfff) || (size & 0xfff))\r\nreturn -EINVAL;\r\nptr = skip_spaces(ptr);\r\nif (strncmp(ptr, "type=", 5))\r\nreturn -EINVAL;\r\nptr = skip_spaces(ptr + 5);\r\nfor (i = 0; i < MTRR_NUM_TYPES; ++i) {\r\nif (strcmp(ptr, mtrr_strings[i]))\r\ncontinue;\r\nbase >>= PAGE_SHIFT;\r\nsize >>= PAGE_SHIFT;\r\nerr = mtrr_add_page((unsigned long)base, (unsigned long)size, i, true);\r\nif (err < 0)\r\nreturn err;\r\nreturn len;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long\r\nmtrr_ioctl(struct file *file, unsigned int cmd, unsigned long __arg)\r\n{\r\nint err = 0;\r\nmtrr_type type;\r\nunsigned long size;\r\nstruct mtrr_sentry sentry;\r\nstruct mtrr_gentry gentry;\r\nvoid __user *arg = (void __user *) __arg;\r\nswitch (cmd) {\r\ncase MTRRIOC_ADD_ENTRY:\r\ncase MTRRIOC_SET_ENTRY:\r\ncase MTRRIOC_DEL_ENTRY:\r\ncase MTRRIOC_KILL_ENTRY:\r\ncase MTRRIOC_ADD_PAGE_ENTRY:\r\ncase MTRRIOC_SET_PAGE_ENTRY:\r\ncase MTRRIOC_DEL_PAGE_ENTRY:\r\ncase MTRRIOC_KILL_PAGE_ENTRY:\r\nif (copy_from_user(&sentry, arg, sizeof sentry))\r\nreturn -EFAULT;\r\nbreak;\r\ncase MTRRIOC_GET_ENTRY:\r\ncase MTRRIOC_GET_PAGE_ENTRY:\r\nif (copy_from_user(&gentry, arg, sizeof gentry))\r\nreturn -EFAULT;\r\nbreak;\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_ADD_ENTRY:\r\ncase MTRRIOC32_SET_ENTRY:\r\ncase MTRRIOC32_DEL_ENTRY:\r\ncase MTRRIOC32_KILL_ENTRY:\r\ncase MTRRIOC32_ADD_PAGE_ENTRY:\r\ncase MTRRIOC32_SET_PAGE_ENTRY:\r\ncase MTRRIOC32_DEL_PAGE_ENTRY:\r\ncase MTRRIOC32_KILL_PAGE_ENTRY: {\r\nstruct mtrr_sentry32 __user *s32;\r\ns32 = (struct mtrr_sentry32 __user *)__arg;\r\nerr = get_user(sentry.base, &s32->base);\r\nerr |= get_user(sentry.size, &s32->size);\r\nerr |= get_user(sentry.type, &s32->type);\r\nif (err)\r\nreturn err;\r\nbreak;\r\n}\r\ncase MTRRIOC32_GET_ENTRY:\r\ncase MTRRIOC32_GET_PAGE_ENTRY: {\r\nstruct mtrr_gentry32 __user *g32;\r\ng32 = (struct mtrr_gentry32 __user *)__arg;\r\nerr = get_user(gentry.regnum, &g32->regnum);\r\nerr |= get_user(gentry.base, &g32->base);\r\nerr |= get_user(gentry.size, &g32->size);\r\nerr |= get_user(gentry.type, &g32->type);\r\nif (err)\r\nreturn err;\r\nbreak;\r\n}\r\n#endif\r\n}\r\nswitch (cmd) {\r\ndefault:\r\nreturn -ENOTTY;\r\ncase MTRRIOC_ADD_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_ADD_ENTRY:\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr =\r\nmtrr_file_add(sentry.base, sentry.size, sentry.type, true,\r\nfile, 0);\r\nbreak;\r\ncase MTRRIOC_SET_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_SET_ENTRY:\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = mtrr_add(sentry.base, sentry.size, sentry.type, false);\r\nbreak;\r\ncase MTRRIOC_DEL_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_DEL_ENTRY:\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = mtrr_file_del(sentry.base, sentry.size, file, 0);\r\nbreak;\r\ncase MTRRIOC_KILL_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_KILL_ENTRY:\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = mtrr_del(-1, sentry.base, sentry.size);\r\nbreak;\r\ncase MTRRIOC_GET_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_GET_ENTRY:\r\n#endif\r\nif (gentry.regnum >= num_var_ranges)\r\nreturn -EINVAL;\r\nmtrr_if->get(gentry.regnum, &gentry.base, &size, &type);\r\nif (gentry.base + size - 1 >= (1UL << (8 * sizeof(gentry.size) - PAGE_SHIFT))\r\n|| size >= (1UL << (8 * sizeof(gentry.size) - PAGE_SHIFT)))\r\ngentry.base = gentry.size = gentry.type = 0;\r\nelse {\r\ngentry.base <<= PAGE_SHIFT;\r\ngentry.size = size << PAGE_SHIFT;\r\ngentry.type = type;\r\n}\r\nbreak;\r\ncase MTRRIOC_ADD_PAGE_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_ADD_PAGE_ENTRY:\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr =\r\nmtrr_file_add(sentry.base, sentry.size, sentry.type, true,\r\nfile, 1);\r\nbreak;\r\ncase MTRRIOC_SET_PAGE_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_SET_PAGE_ENTRY:\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr =\r\nmtrr_add_page(sentry.base, sentry.size, sentry.type, false);\r\nbreak;\r\ncase MTRRIOC_DEL_PAGE_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_DEL_PAGE_ENTRY:\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = mtrr_file_del(sentry.base, sentry.size, file, 1);\r\nbreak;\r\ncase MTRRIOC_KILL_PAGE_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_KILL_PAGE_ENTRY:\r\n#endif\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = mtrr_del_page(-1, sentry.base, sentry.size);\r\nbreak;\r\ncase MTRRIOC_GET_PAGE_ENTRY:\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_GET_PAGE_ENTRY:\r\n#endif\r\nif (gentry.regnum >= num_var_ranges)\r\nreturn -EINVAL;\r\nmtrr_if->get(gentry.regnum, &gentry.base, &size, &type);\r\nif (size != (__typeof__(gentry.size))size)\r\ngentry.base = gentry.size = gentry.type = 0;\r\nelse {\r\ngentry.size = size;\r\ngentry.type = type;\r\n}\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\nswitch (cmd) {\r\ncase MTRRIOC_GET_ENTRY:\r\ncase MTRRIOC_GET_PAGE_ENTRY:\r\nif (copy_to_user(arg, &gentry, sizeof gentry))\r\nerr = -EFAULT;\r\nbreak;\r\n#ifdef CONFIG_COMPAT\r\ncase MTRRIOC32_GET_ENTRY:\r\ncase MTRRIOC32_GET_PAGE_ENTRY: {\r\nstruct mtrr_gentry32 __user *g32;\r\ng32 = (struct mtrr_gentry32 __user *)__arg;\r\nerr = put_user(gentry.base, &g32->base);\r\nerr |= put_user(gentry.size, &g32->size);\r\nerr |= put_user(gentry.regnum, &g32->regnum);\r\nerr |= put_user(gentry.type, &g32->type);\r\nbreak;\r\n}\r\n#endif\r\n}\r\nreturn err;\r\n}\r\nstatic int mtrr_close(struct inode *ino, struct file *file)\r\n{\r\nunsigned int *fcount = FILE_FCOUNT(file);\r\nint i, max;\r\nif (fcount != NULL) {\r\nmax = num_var_ranges;\r\nfor (i = 0; i < max; ++i) {\r\nwhile (fcount[i] > 0) {\r\nmtrr_del(i, 0, 0);\r\n--fcount[i];\r\n}\r\n}\r\nkfree(fcount);\r\nFILE_FCOUNT(file) = NULL;\r\n}\r\nreturn single_release(ino, file);\r\n}\r\nstatic int mtrr_open(struct inode *inode, struct file *file)\r\n{\r\nif (!mtrr_if)\r\nreturn -EIO;\r\nif (!mtrr_if->get)\r\nreturn -ENXIO;\r\nreturn single_open(file, mtrr_seq_show, NULL);\r\n}\r\nstatic int mtrr_seq_show(struct seq_file *seq, void *offset)\r\n{\r\nchar factor;\r\nint i, max, len;\r\nmtrr_type type;\r\nunsigned long base, size;\r\nlen = 0;\r\nmax = num_var_ranges;\r\nfor (i = 0; i < max; i++) {\r\nmtrr_if->get(i, &base, &size, &type);\r\nif (size == 0) {\r\nmtrr_usage_table[i] = 0;\r\ncontinue;\r\n}\r\nif (size < (0x100000 >> PAGE_SHIFT)) {\r\nfactor = 'K';\r\nsize <<= PAGE_SHIFT - 10;\r\n} else {\r\nfactor = 'M';\r\nsize >>= 20 - PAGE_SHIFT;\r\n}\r\nlen += seq_printf(seq, "reg%02i: base=0x%06lx000 "\r\n"(%5luMB), size=%5lu%cB, count=%d: %s\n",\r\ni, base, base >> (20 - PAGE_SHIFT), size,\r\nfactor, mtrr_usage_table[i],\r\nmtrr_attrib_to_str(type));\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mtrr_if_init(void)\r\n{\r\nstruct cpuinfo_x86 *c = &boot_cpu_data;\r\nif ((!cpu_has(c, X86_FEATURE_MTRR)) &&\r\n(!cpu_has(c, X86_FEATURE_K6_MTRR)) &&\r\n(!cpu_has(c, X86_FEATURE_CYRIX_ARR)) &&\r\n(!cpu_has(c, X86_FEATURE_CENTAUR_MCR)))\r\nreturn -ENODEV;\r\nproc_create("mtrr", S_IWUSR | S_IRUGO, NULL, &mtrr_fops);\r\nreturn 0;\r\n}
