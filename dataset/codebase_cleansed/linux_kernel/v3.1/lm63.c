static ssize_t show_fan(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[attr->index]));\r\n}\r\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *dummy,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->fan[1] = FAN_TO_REG(val);\r\ni2c_smbus_write_byte_data(client, LM63_REG_TACH_LIMIT_LSB,\r\ndata->fan[1] & 0xFF);\r\ni2c_smbus_write_byte_data(client, LM63_REG_TACH_LIMIT_MSB,\r\ndata->fan[1] >> 8);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm1(struct device *dev, struct device_attribute *dummy,\r\nchar *buf)\r\n{\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm1_value >= 2 * data->pwm1_freq ?\r\n255 : (data->pwm1_value * 255 + data->pwm1_freq) /\r\n(2 * data->pwm1_freq));\r\n}\r\nstatic ssize_t set_pwm1(struct device *dev, struct device_attribute *dummy,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nif (!(data->config_fan & 0x20))\r\nreturn -EPERM;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm1_value = val <= 0 ? 0 :\r\nval >= 255 ? 2 * data->pwm1_freq :\r\n(val * data->pwm1_freq * 2 + 127) / 255;\r\ni2c_smbus_write_byte_data(client, LM63_REG_PWM_VALUE, data->pwm1_value);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm1_enable(struct device *dev, struct device_attribute *dummy,\r\nchar *buf)\r\n{\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->config_fan & 0x20 ? 1 : 2);\r\n}\r\nstatic ssize_t show_local_temp8(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP8_FROM_REG(data->temp8[attr->index]));\r\n}\r\nstatic ssize_t show_remote_temp8(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP8_FROM_REG(data->temp8[attr->index])\r\n+ data->temp2_offset);\r\n}\r\nstatic ssize_t set_local_temp8(struct device *dev,\r\nstruct device_attribute *dummy,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nlong val = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->temp8[1] = TEMP8_TO_REG(val);\r\ni2c_smbus_write_byte_data(client, LM63_REG_LOCAL_HIGH, data->temp8[1]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp11(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP11_FROM_REG(data->temp11[attr->index])\r\n+ data->temp2_offset);\r\n}\r\nstatic ssize_t set_temp11(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstatic const u8 reg[4] = {\r\nLM63_REG_REMOTE_LOW_MSB,\r\nLM63_REG_REMOTE_LOW_LSB,\r\nLM63_REG_REMOTE_HIGH_MSB,\r\nLM63_REG_REMOTE_HIGH_LSB,\r\n};\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nlong val = simple_strtol(buf, NULL, 10);\r\nint nr = attr->index;\r\nmutex_lock(&data->update_lock);\r\ndata->temp11[nr] = TEMP11_TO_REG(val - data->temp2_offset);\r\ni2c_smbus_write_byte_data(client, reg[(nr - 1) * 2],\r\ndata->temp11[nr] >> 8);\r\ni2c_smbus_write_byte_data(client, reg[(nr - 1) * 2 + 1],\r\ndata->temp11[nr] & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp2_crit_hyst(struct device *dev, struct device_attribute *dummy,\r\nchar *buf)\r\n{\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP8_FROM_REG(data->temp8[2])\r\n+ data->temp2_offset\r\n- TEMP8_FROM_REG(data->temp2_crit_hyst));\r\n}\r\nstatic ssize_t set_temp2_crit_hyst(struct device *dev, struct device_attribute *dummy,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nlong val = simple_strtol(buf, NULL, 10);\r\nlong hyst;\r\nmutex_lock(&data->update_lock);\r\nhyst = TEMP8_FROM_REG(data->temp8[2]) + data->temp2_offset - val;\r\ni2c_smbus_write_byte_data(client, LM63_REG_REMOTE_TCRIT_HYST,\r\nHYST_TO_REG(hyst));\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarms(struct device *dev, struct device_attribute *dummy,\r\nchar *buf)\r\n{\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nint bitnr = attr->index;\r\nreturn sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic int lm63_detect(struct i2c_client *new_client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nu8 man_id, chip_id, reg_config1, reg_config2;\r\nu8 reg_alert_status, reg_alert_mask;\r\nint address = new_client->addr;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nman_id = i2c_smbus_read_byte_data(new_client, LM63_REG_MAN_ID);\r\nchip_id = i2c_smbus_read_byte_data(new_client, LM63_REG_CHIP_ID);\r\nreg_config1 = i2c_smbus_read_byte_data(new_client,\r\nLM63_REG_CONFIG1);\r\nreg_config2 = i2c_smbus_read_byte_data(new_client,\r\nLM63_REG_CONFIG2);\r\nreg_alert_status = i2c_smbus_read_byte_data(new_client,\r\nLM63_REG_ALERT_STATUS);\r\nreg_alert_mask = i2c_smbus_read_byte_data(new_client,\r\nLM63_REG_ALERT_MASK);\r\nif (man_id != 0x01\r\n|| (reg_config1 & 0x18) != 0x00\r\n|| (reg_config2 & 0xF8) != 0x00\r\n|| (reg_alert_status & 0x20) != 0x00\r\n|| (reg_alert_mask & 0xA4) != 0xA4) {\r\ndev_dbg(&adapter->dev,\r\n"Unsupported chip (man_id=0x%02X, chip_id=0x%02X)\n",\r\nman_id, chip_id);\r\nreturn -ENODEV;\r\n}\r\nif (chip_id == 0x41 && address == 0x4c)\r\nstrlcpy(info->type, "lm63", I2C_NAME_SIZE);\r\nelse if (chip_id == 0x51 && (address == 0x18 || address == 0x4e))\r\nstrlcpy(info->type, "lm64", I2C_NAME_SIZE);\r\nelse\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int lm63_probe(struct i2c_client *new_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm63_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(struct lm63_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ni2c_set_clientdata(new_client, data);\r\ndata->valid = 0;\r\nmutex_init(&data->update_lock);\r\ndata->kind = id->driver_data;\r\nif (data->kind == lm64)\r\ndata->temp2_offset = 16000;\r\nlm63_init_client(new_client);\r\nif ((err = sysfs_create_group(&new_client->dev.kobj,\r\n&lm63_group)))\r\ngoto exit_free;\r\nif (data->config & 0x04) {\r\nif ((err = sysfs_create_group(&new_client->dev.kobj,\r\n&lm63_group_fan1)))\r\ngoto exit_remove_files;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&new_client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&new_client->dev.kobj, &lm63_group);\r\nsysfs_remove_group(&new_client->dev.kobj, &lm63_group_fan1);\r\nexit_free:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void lm63_init_client(struct i2c_client *client)\r\n{\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\ndata->config = i2c_smbus_read_byte_data(client, LM63_REG_CONFIG1);\r\ndata->config_fan = i2c_smbus_read_byte_data(client,\r\nLM63_REG_CONFIG_FAN);\r\nif (data->config & 0x40) {\r\ndev_dbg(&client->dev, "Switching to operational mode\n");\r\ndata->config &= 0xA7;\r\ni2c_smbus_write_byte_data(client, LM63_REG_CONFIG1,\r\ndata->config);\r\n}\r\ndata->pwm1_freq = i2c_smbus_read_byte_data(client, LM63_REG_PWM_FREQ);\r\nif (data->pwm1_freq == 0)\r\ndata->pwm1_freq = 1;\r\ndev_dbg(&client->dev, "Alert/tach pin configured for %s\n",\r\n(data->config & 0x04) ? "tachometer input" :\r\n"alert output");\r\ndev_dbg(&client->dev, "PWM clock %s kHz, output frequency %u Hz\n",\r\n(data->config_fan & 0x08) ? "1.4" : "360",\r\n((data->config_fan & 0x08) ? 700 : 180000) / data->pwm1_freq);\r\ndev_dbg(&client->dev, "PWM output active %s, %s mode\n",\r\n(data->config_fan & 0x10) ? "low" : "high",\r\n(data->config_fan & 0x20) ? "manual" : "auto");\r\n}\r\nstatic int lm63_remove(struct i2c_client *client)\r\n{\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &lm63_group);\r\nsysfs_remove_group(&client->dev.kobj, &lm63_group_fan1);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic struct lm63_data *lm63_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nif (data->config & 0x04) {\r\ndata->fan[0] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_TACH_COUNT_LSB) & 0xFC;\r\ndata->fan[0] |= i2c_smbus_read_byte_data(client,\r\nLM63_REG_TACH_COUNT_MSB) << 8;\r\ndata->fan[1] = (i2c_smbus_read_byte_data(client,\r\nLM63_REG_TACH_LIMIT_LSB) & 0xFC)\r\n| (i2c_smbus_read_byte_data(client,\r\nLM63_REG_TACH_LIMIT_MSB) << 8);\r\n}\r\ndata->pwm1_freq = i2c_smbus_read_byte_data(client,\r\nLM63_REG_PWM_FREQ);\r\nif (data->pwm1_freq == 0)\r\ndata->pwm1_freq = 1;\r\ndata->pwm1_value = i2c_smbus_read_byte_data(client,\r\nLM63_REG_PWM_VALUE);\r\ndata->temp8[0] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_LOCAL_TEMP);\r\ndata->temp8[1] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_LOCAL_HIGH);\r\ndata->temp11[0] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_TEMP_MSB) << 8;\r\ndata->temp11[0] |= i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_TEMP_LSB);\r\ndata->temp11[1] = (i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_LOW_MSB) << 8)\r\n| i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_LOW_LSB);\r\ndata->temp11[2] = (i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_HIGH_MSB) << 8)\r\n| i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_HIGH_LSB);\r\ndata->temp8[2] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_TCRIT);\r\ndata->temp2_crit_hyst = i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_TCRIT_HYST);\r\ndata->alarms = i2c_smbus_read_byte_data(client,\r\nLM63_REG_ALERT_STATUS) & 0x7F;\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic int __init sensors_lm63_init(void)\r\n{\r\nreturn i2c_add_driver(&lm63_driver);\r\n}\r\nstatic void __exit sensors_lm63_exit(void)\r\n{\r\ni2c_del_driver(&lm63_driver);\r\n}
