struct mtd_info *__mtd_next_device(int i)\r\n{\r\nreturn idr_get_next(&mtd_idr, &i);\r\n}\r\nstatic void mtd_release(struct device *dev)\r\n{\r\ndev_t index = MTD_DEVT(dev_to_mtd(dev)->index);\r\nif (index)\r\ndevice_destroy(&mtd_class, index + 1);\r\n}\r\nstatic int mtd_cls_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nif (mtd && mtd->suspend)\r\nreturn mtd->suspend(mtd);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int mtd_cls_resume(struct device *dev)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nif (mtd && mtd->resume)\r\nmtd->resume(mtd);\r\nreturn 0;\r\n}\r\nstatic ssize_t mtd_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nchar *type;\r\nswitch (mtd->type) {\r\ncase MTD_ABSENT:\r\ntype = "absent";\r\nbreak;\r\ncase MTD_RAM:\r\ntype = "ram";\r\nbreak;\r\ncase MTD_ROM:\r\ntype = "rom";\r\nbreak;\r\ncase MTD_NORFLASH:\r\ntype = "nor";\r\nbreak;\r\ncase MTD_NANDFLASH:\r\ntype = "nand";\r\nbreak;\r\ncase MTD_DATAFLASH:\r\ntype = "dataflash";\r\nbreak;\r\ncase MTD_UBIVOLUME:\r\ntype = "ubi";\r\nbreak;\r\ndefault:\r\ntype = "unknown";\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", type);\r\n}\r\nstatic ssize_t mtd_flags_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%lx\n", (unsigned long)mtd->flags);\r\n}\r\nstatic ssize_t mtd_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%llu\n",\r\n(unsigned long long)mtd->size);\r\n}\r\nstatic ssize_t mtd_erasesize_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->erasesize);\r\n}\r\nstatic ssize_t mtd_writesize_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->writesize);\r\n}\r\nstatic ssize_t mtd_subpagesize_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nunsigned int subpagesize = mtd->writesize >> mtd->subpage_sft;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", subpagesize);\r\n}\r\nstatic ssize_t mtd_oobsize_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->oobsize);\r\n}\r\nstatic ssize_t mtd_numeraseregions_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mtd->numeraseregions);\r\n}\r\nstatic ssize_t mtd_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mtd_info *mtd = dev_to_mtd(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", mtd->name);\r\n}\r\nint add_mtd_device(struct mtd_info *mtd)\r\n{\r\nstruct mtd_notifier *not;\r\nint i, error;\r\nif (!mtd->backing_dev_info) {\r\nswitch (mtd->type) {\r\ncase MTD_RAM:\r\nmtd->backing_dev_info = &mtd_bdi_rw_mappable;\r\nbreak;\r\ncase MTD_ROM:\r\nmtd->backing_dev_info = &mtd_bdi_ro_mappable;\r\nbreak;\r\ndefault:\r\nmtd->backing_dev_info = &mtd_bdi_unmappable;\r\nbreak;\r\n}\r\n}\r\nBUG_ON(mtd->writesize == 0);\r\nmutex_lock(&mtd_table_mutex);\r\ndo {\r\nif (!idr_pre_get(&mtd_idr, GFP_KERNEL))\r\ngoto fail_locked;\r\nerror = idr_get_new(&mtd_idr, mtd, &i);\r\n} while (error == -EAGAIN);\r\nif (error)\r\ngoto fail_locked;\r\nmtd->index = i;\r\nmtd->usecount = 0;\r\nif (is_power_of_2(mtd->erasesize))\r\nmtd->erasesize_shift = ffs(mtd->erasesize) - 1;\r\nelse\r\nmtd->erasesize_shift = 0;\r\nif (is_power_of_2(mtd->writesize))\r\nmtd->writesize_shift = ffs(mtd->writesize) - 1;\r\nelse\r\nmtd->writesize_shift = 0;\r\nmtd->erasesize_mask = (1 << mtd->erasesize_shift) - 1;\r\nmtd->writesize_mask = (1 << mtd->writesize_shift) - 1;\r\nif ((mtd->flags & MTD_WRITEABLE)\r\n&& (mtd->flags & MTD_POWERUP_LOCK) && mtd->unlock) {\r\nif (mtd->unlock(mtd, 0, mtd->size))\r\nprintk(KERN_WARNING\r\n"%s: unlock failed, writes may not work\n",\r\nmtd->name);\r\n}\r\nmtd->dev.type = &mtd_devtype;\r\nmtd->dev.class = &mtd_class;\r\nmtd->dev.devt = MTD_DEVT(i);\r\ndev_set_name(&mtd->dev, "mtd%d", i);\r\ndev_set_drvdata(&mtd->dev, mtd);\r\nif (device_register(&mtd->dev) != 0)\r\ngoto fail_added;\r\nif (MTD_DEVT(i))\r\ndevice_create(&mtd_class, mtd->dev.parent,\r\nMTD_DEVT(i) + 1,\r\nNULL, "mtd%dro", i);\r\nDEBUG(0, "mtd: Giving out device %d to %s\n", i, mtd->name);\r\nlist_for_each_entry(not, &mtd_notifiers, list)\r\nnot->add(mtd);\r\nmutex_unlock(&mtd_table_mutex);\r\n__module_get(THIS_MODULE);\r\nreturn 0;\r\nfail_added:\r\nidr_remove(&mtd_idr, i);\r\nfail_locked:\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn 1;\r\n}\r\nint del_mtd_device(struct mtd_info *mtd)\r\n{\r\nint ret;\r\nstruct mtd_notifier *not;\r\nmutex_lock(&mtd_table_mutex);\r\nif (idr_find(&mtd_idr, mtd->index) != mtd) {\r\nret = -ENODEV;\r\ngoto out_error;\r\n}\r\nlist_for_each_entry(not, &mtd_notifiers, list)\r\nnot->remove(mtd);\r\nif (mtd->usecount) {\r\nprintk(KERN_NOTICE "Removing MTD device #%d (%s) with use count %d\n",\r\nmtd->index, mtd->name, mtd->usecount);\r\nret = -EBUSY;\r\n} else {\r\ndevice_unregister(&mtd->dev);\r\nidr_remove(&mtd_idr, mtd->index);\r\nmodule_put(THIS_MODULE);\r\nret = 0;\r\n}\r\nout_error:\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn ret;\r\n}\r\nint mtd_device_register(struct mtd_info *master,\r\nconst struct mtd_partition *parts,\r\nint nr_parts)\r\n{\r\nreturn parts ? add_mtd_partitions(master, parts, nr_parts) :\r\nadd_mtd_device(master);\r\n}\r\nint mtd_device_unregister(struct mtd_info *master)\r\n{\r\nint err;\r\nerr = del_mtd_partitions(master);\r\nif (err)\r\nreturn err;\r\nif (!device_is_registered(&master->dev))\r\nreturn 0;\r\nreturn del_mtd_device(master);\r\n}\r\nvoid register_mtd_user (struct mtd_notifier *new)\r\n{\r\nstruct mtd_info *mtd;\r\nmutex_lock(&mtd_table_mutex);\r\nlist_add(&new->list, &mtd_notifiers);\r\n__module_get(THIS_MODULE);\r\nmtd_for_each_device(mtd)\r\nnew->add(mtd);\r\nmutex_unlock(&mtd_table_mutex);\r\n}\r\nint unregister_mtd_user (struct mtd_notifier *old)\r\n{\r\nstruct mtd_info *mtd;\r\nmutex_lock(&mtd_table_mutex);\r\nmodule_put(THIS_MODULE);\r\nmtd_for_each_device(mtd)\r\nold->remove(mtd);\r\nlist_del(&old->list);\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn 0;\r\n}\r\nstruct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)\r\n{\r\nstruct mtd_info *ret = NULL, *other;\r\nint err = -ENODEV;\r\nmutex_lock(&mtd_table_mutex);\r\nif (num == -1) {\r\nmtd_for_each_device(other) {\r\nif (other == mtd) {\r\nret = mtd;\r\nbreak;\r\n}\r\n}\r\n} else if (num >= 0) {\r\nret = idr_find(&mtd_idr, num);\r\nif (mtd && mtd != ret)\r\nret = NULL;\r\n}\r\nif (!ret) {\r\nret = ERR_PTR(err);\r\ngoto out;\r\n}\r\nerr = __get_mtd_device(ret);\r\nif (err)\r\nret = ERR_PTR(err);\r\nout:\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn ret;\r\n}\r\nint __get_mtd_device(struct mtd_info *mtd)\r\n{\r\nint err;\r\nif (!try_module_get(mtd->owner))\r\nreturn -ENODEV;\r\nif (mtd->get_device) {\r\nerr = mtd->get_device(mtd);\r\nif (err) {\r\nmodule_put(mtd->owner);\r\nreturn err;\r\n}\r\n}\r\nmtd->usecount++;\r\nreturn 0;\r\n}\r\nstruct mtd_info *get_mtd_device_nm(const char *name)\r\n{\r\nint err = -ENODEV;\r\nstruct mtd_info *mtd = NULL, *other;\r\nmutex_lock(&mtd_table_mutex);\r\nmtd_for_each_device(other) {\r\nif (!strcmp(name, other->name)) {\r\nmtd = other;\r\nbreak;\r\n}\r\n}\r\nif (!mtd)\r\ngoto out_unlock;\r\nerr = __get_mtd_device(mtd);\r\nif (err)\r\ngoto out_unlock;\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn mtd;\r\nout_unlock:\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid put_mtd_device(struct mtd_info *mtd)\r\n{\r\nmutex_lock(&mtd_table_mutex);\r\n__put_mtd_device(mtd);\r\nmutex_unlock(&mtd_table_mutex);\r\n}\r\nvoid __put_mtd_device(struct mtd_info *mtd)\r\n{\r\n--mtd->usecount;\r\nBUG_ON(mtd->usecount < 0);\r\nif (mtd->put_device)\r\nmtd->put_device(mtd);\r\nmodule_put(mtd->owner);\r\n}\r\nint default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,\r\nunsigned long count, loff_t to, size_t *retlen)\r\n{\r\nunsigned long i;\r\nsize_t totlen = 0, thislen;\r\nint ret = 0;\r\nif(!mtd->write) {\r\nret = -EROFS;\r\n} else {\r\nfor (i=0; i<count; i++) {\r\nif (!vecs[i].iov_len)\r\ncontinue;\r\nret = mtd->write(mtd, to, vecs[i].iov_len, &thislen, vecs[i].iov_base);\r\ntotlen += thislen;\r\nif (ret || thislen != vecs[i].iov_len)\r\nbreak;\r\nto += vecs[i].iov_len;\r\n}\r\n}\r\nif (retlen)\r\n*retlen = totlen;\r\nreturn ret;\r\n}\r\nvoid *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)\r\n{\r\ngfp_t flags = __GFP_NOWARN | __GFP_WAIT |\r\n__GFP_NORETRY | __GFP_NO_KSWAPD;\r\nsize_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);\r\nvoid *kbuf;\r\n*size = min_t(size_t, *size, KMALLOC_MAX_SIZE);\r\nwhile (*size > min_alloc) {\r\nkbuf = kmalloc(*size, flags);\r\nif (kbuf)\r\nreturn kbuf;\r\n*size >>= 1;\r\n*size = ALIGN(*size, mtd->writesize);\r\n}\r\nreturn kmalloc(*size, GFP_KERNEL);\r\n}\r\nstatic int mtd_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct mtd_info *mtd;\r\nseq_puts(m, "dev: size erasesize name\n");\r\nmutex_lock(&mtd_table_mutex);\r\nmtd_for_each_device(mtd) {\r\nseq_printf(m, "mtd%d: %8.8llx %8.8x \"%s\"\n",\r\nmtd->index, (unsigned long long)mtd->size,\r\nmtd->erasesize, mtd->name);\r\n}\r\nmutex_unlock(&mtd_table_mutex);\r\nreturn 0;\r\n}\r\nstatic int mtd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mtd_proc_show, NULL);\r\n}\r\nstatic int __init mtd_bdi_init(struct backing_dev_info *bdi, const char *name)\r\n{\r\nint ret;\r\nret = bdi_init(bdi);\r\nif (!ret)\r\nret = bdi_register(bdi, NULL, name);\r\nif (ret)\r\nbdi_destroy(bdi);\r\nreturn ret;\r\n}\r\nstatic int __init init_mtd(void)\r\n{\r\nint ret;\r\nret = class_register(&mtd_class);\r\nif (ret)\r\ngoto err_reg;\r\nret = mtd_bdi_init(&mtd_bdi_unmappable, "mtd-unmap");\r\nif (ret)\r\ngoto err_bdi1;\r\nret = mtd_bdi_init(&mtd_bdi_ro_mappable, "mtd-romap");\r\nif (ret)\r\ngoto err_bdi2;\r\nret = mtd_bdi_init(&mtd_bdi_rw_mappable, "mtd-rwmap");\r\nif (ret)\r\ngoto err_bdi3;\r\n#ifdef CONFIG_PROC_FS\r\nproc_mtd = proc_create("mtd", 0, NULL, &mtd_proc_ops);\r\n#endif\r\nreturn 0;\r\nerr_bdi3:\r\nbdi_destroy(&mtd_bdi_ro_mappable);\r\nerr_bdi2:\r\nbdi_destroy(&mtd_bdi_unmappable);\r\nerr_bdi1:\r\nclass_unregister(&mtd_class);\r\nerr_reg:\r\npr_err("Error registering mtd class or bdi: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_mtd(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nif (proc_mtd)\r\nremove_proc_entry( "mtd", NULL);\r\n#endif\r\nclass_unregister(&mtd_class);\r\nbdi_destroy(&mtd_bdi_unmappable);\r\nbdi_destroy(&mtd_bdi_ro_mappable);\r\nbdi_destroy(&mtd_bdi_rw_mappable);\r\n}
