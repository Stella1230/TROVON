void beat_restart(char *cmd)\r\n{\r\nbeat_shutdown_logical_partition(!beat_pm_poweroff_flag);\r\n}\r\nvoid beat_power_off(void)\r\n{\r\nbeat_shutdown_logical_partition(0);\r\n}\r\nvoid beat_halt(void)\r\n{\r\nbeat_shutdown_logical_partition(beat_halt_code);\r\n}\r\nint beat_set_rtc_time(struct rtc_time *rtc_time)\r\n{\r\nu64 tim;\r\ntim = mktime(rtc_time->tm_year+1900,\r\nrtc_time->tm_mon+1, rtc_time->tm_mday,\r\nrtc_time->tm_hour, rtc_time->tm_min, rtc_time->tm_sec);\r\nif (beat_rtc_write(tim))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid beat_get_rtc_time(struct rtc_time *rtc_time)\r\n{\r\nu64 tim;\r\nif (beat_rtc_read(&tim))\r\ntim = 0;\r\nto_tm(tim, rtc_time);\r\nrtc_time->tm_year -= 1900;\r\nrtc_time->tm_mon -= 1;\r\n}\r\nssize_t beat_nvram_read(char *buf, size_t count, loff_t *index)\r\n{\r\nunsigned int i;\r\nunsigned long len;\r\nchar *p = buf;\r\nif (*index >= BEAT_NVRAM_SIZE)\r\nreturn -ENODEV;\r\ni = *index;\r\nif (i + count > BEAT_NVRAM_SIZE)\r\ncount = BEAT_NVRAM_SIZE - i;\r\nfor (; count != 0; count -= len) {\r\nlen = count;\r\nif (len > BEAT_NVRW_CNT)\r\nlen = BEAT_NVRW_CNT;\r\nif (beat_eeprom_read(i, len, p))\r\nreturn -EIO;\r\np += len;\r\ni += len;\r\n}\r\n*index = i;\r\nreturn p - buf;\r\n}\r\nssize_t beat_nvram_write(char *buf, size_t count, loff_t *index)\r\n{\r\nunsigned int i;\r\nunsigned long len;\r\nchar *p = buf;\r\nif (*index >= BEAT_NVRAM_SIZE)\r\nreturn -ENODEV;\r\ni = *index;\r\nif (i + count > BEAT_NVRAM_SIZE)\r\ncount = BEAT_NVRAM_SIZE - i;\r\nfor (; count != 0; count -= len) {\r\nlen = count;\r\nif (len > BEAT_NVRW_CNT)\r\nlen = BEAT_NVRW_CNT;\r\nif (beat_eeprom_write(i, len, p))\r\nreturn -EIO;\r\np += len;\r\ni += len;\r\n}\r\n*index = i;\r\nreturn p - buf;\r\n}\r\nssize_t beat_nvram_get_size(void)\r\n{\r\nreturn BEAT_NVRAM_SIZE;\r\n}\r\nint beat_set_xdabr(unsigned long dabr)\r\n{\r\nif (beat_set_dabr(dabr, DABRX_KERNEL | DABRX_USER))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint64_t beat_get_term_char(u64 vterm, u64 *len, u64 *t1, u64 *t2)\r\n{\r\nu64 db[2];\r\ns64 ret;\r\nret = beat_get_characters_from_console(vterm, len, (u8 *)db);\r\nif (ret == 0) {\r\n*t1 = db[0];\r\n*t2 = db[1];\r\n}\r\nreturn ret;\r\n}\r\nint64_t beat_put_term_char(u64 vterm, u64 len, u64 t1, u64 t2)\r\n{\r\nu64 db[2];\r\ndb[0] = t1;\r\ndb[1] = t2;\r\nreturn beat_put_characters_to_console(vterm, len, (u8 *)db);\r\n}\r\nvoid beat_power_save(void)\r\n{\r\nbeat_pause(0);\r\n}\r\nvoid beat_kexec_cpu_down(int crash, int secondary)\r\n{\r\nbeatic_deinit_IRQ();\r\n}\r\nstatic irqreturn_t beat_power_event(int virq, void *arg)\r\n{\r\nprintk(KERN_DEBUG "Beat: power button pressed\n");\r\nbeat_pm_poweroff_flag = 1;\r\nctrl_alt_del();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t beat_reset_event(int virq, void *arg)\r\n{\r\nprintk(KERN_DEBUG "Beat: reset button pressed\n");\r\nbeat_pm_poweroff_flag = 0;\r\nctrl_alt_del();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init beat_register_event(void)\r\n{\r\nu64 path[4], data[2];\r\nint rc, i;\r\nunsigned int virq;\r\nfor (i = 0; i < ARRAY_SIZE(beat_event_list); i++) {\r\nstruct beat_event_list *ev = &beat_event_list[i];\r\nif (beat_construct_event_receive_port(data) != 0) {\r\nprintk(KERN_ERR "Beat: "\r\n"cannot construct event receive port for %s\n",\r\nev->typecode);\r\nreturn -EINVAL;\r\n}\r\nvirq = irq_create_mapping(NULL, data[0]);\r\nif (virq == NO_IRQ) {\r\nprintk(KERN_ERR "Beat: failed to get virtual IRQ"\r\n" for event receive port for %s\n",\r\nev->typecode);\r\nbeat_destruct_event_receive_port(data[0]);\r\nreturn -EIO;\r\n}\r\nev->virq = virq;\r\nrc = request_irq(virq, ev->handler, IRQF_DISABLED,\r\nev->typecode, NULL);\r\nif (rc != 0) {\r\nprintk(KERN_ERR "Beat: failed to request virtual IRQ"\r\n" for event receive port for %s\n",\r\nev->typecode);\r\nbeat_destruct_event_receive_port(data[0]);\r\nreturn rc;\r\n}\r\npath[0] = 0x1000000065780000ul;\r\npath[1] = 0x627574746f6e0000ul;\r\npath[2] = 0;\r\nstrncpy((char *)&path[2], ev->typecode, 8);\r\npath[3] = 0;\r\ndata[1] = 0;\r\nbeat_create_repository_node(path, data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init beat_event_init(void)\r\n{\r\nif (!firmware_has_feature(FW_FEATURE_BEAT))\r\nreturn -EINVAL;\r\nbeat_pm_poweroff_flag = 0;\r\nreturn beat_register_event();\r\n}
