static int intel_idle(struct cpuidle_device *dev, struct cpuidle_state *state)\r\n{\r\nunsigned long ecx = 1;\r\nunsigned long eax = (unsigned long)cpuidle_get_statedata(state);\r\nunsigned int cstate;\r\nktime_t kt_before, kt_after;\r\ns64 usec_delta;\r\nint cpu = smp_processor_id();\r\ncstate = (((eax) >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) + 1;\r\nlocal_irq_disable();\r\nif (state->flags & CPUIDLE_FLAG_TLB_FLUSHED)\r\nleave_mm(cpu);\r\nif (!(lapic_timer_reliable_states & (1 << (cstate))))\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);\r\nkt_before = ktime_get_real();\r\nstop_critical_timings();\r\nif (!need_resched()) {\r\n__monitor((void *)&current_thread_info()->flags, 0, 0);\r\nsmp_mb();\r\nif (!need_resched())\r\n__mwait(eax, ecx);\r\n}\r\nstart_critical_timings();\r\nkt_after = ktime_get_real();\r\nusec_delta = ktime_to_us(ktime_sub(kt_after, kt_before));\r\nlocal_irq_enable();\r\nif (!(lapic_timer_reliable_states & (1 << (cstate))))\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);\r\nreturn usec_delta;\r\n}\r\nstatic void __setup_broadcast_timer(void *arg)\r\n{\r\nunsigned long reason = (unsigned long)arg;\r\nint cpu = smp_processor_id();\r\nreason = reason ?\r\nCLOCK_EVT_NOTIFY_BROADCAST_ON : CLOCK_EVT_NOTIFY_BROADCAST_OFF;\r\nclockevents_notify(reason, &cpu);\r\n}\r\nstatic int setup_broadcast_cpuhp_notify(struct notifier_block *n,\r\nunsigned long action, void *hcpu)\r\n{\r\nint hotcpu = (unsigned long)hcpu;\r\nswitch (action & 0xf) {\r\ncase CPU_ONLINE:\r\nsmp_call_function_single(hotcpu, __setup_broadcast_timer,\r\n(void *)true, 1);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void auto_demotion_disable(void *dummy)\r\n{\r\nunsigned long long msr_bits;\r\nrdmsrl(MSR_NHM_SNB_PKG_CST_CFG_CTL, msr_bits);\r\nmsr_bits &= ~auto_demotion_disable_flags;\r\nwrmsrl(MSR_NHM_SNB_PKG_CST_CFG_CTL, msr_bits);\r\n}\r\nstatic int intel_idle_probe(void)\r\n{\r\nunsigned int eax, ebx, ecx;\r\nif (max_cstate == 0) {\r\npr_debug(PREFIX "disabled\n");\r\nreturn -EPERM;\r\n}\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\r\nreturn -ENODEV;\r\nif (!boot_cpu_has(X86_FEATURE_MWAIT))\r\nreturn -ENODEV;\r\nif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\r\nreturn -ENODEV;\r\ncpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &mwait_substates);\r\nif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\r\n!(ecx & CPUID5_ECX_INTERRUPT_BREAK))\r\nreturn -ENODEV;\r\npr_debug(PREFIX "MWAIT substates: 0x%x\n", mwait_substates);\r\nif (boot_cpu_data.x86 != 6)\r\nreturn -ENODEV;\r\nswitch (boot_cpu_data.x86_model) {\r\ncase 0x1A:\r\ncase 0x1E:\r\ncase 0x1F:\r\ncase 0x2E:\r\ncase 0x2F:\r\ncase 0x25:\r\ncase 0x2C:\r\ncpuidle_state_table = nehalem_cstates;\r\nauto_demotion_disable_flags =\r\n(NHM_C1_AUTO_DEMOTE | NHM_C3_AUTO_DEMOTE);\r\nbreak;\r\ncase 0x1C:\r\ncpuidle_state_table = atom_cstates;\r\nbreak;\r\ncase 0x26:\r\ncpuidle_state_table = atom_cstates;\r\nauto_demotion_disable_flags = ATM_LNC_C6_AUTO_DEMOTE;\r\nbreak;\r\ncase 0x2A:\r\ncase 0x2D:\r\ncpuidle_state_table = snb_cstates;\r\nbreak;\r\ndefault:\r\npr_debug(PREFIX "does not run on family %d model %d\n",\r\nboot_cpu_data.x86, boot_cpu_data.x86_model);\r\nreturn -ENODEV;\r\n}\r\nif (boot_cpu_has(X86_FEATURE_ARAT))\r\nlapic_timer_reliable_states = LAPIC_TIMER_ALWAYS_RELIABLE;\r\nelse {\r\nsmp_call_function(__setup_broadcast_timer, (void *)true, 1);\r\nregister_cpu_notifier(&setup_broadcast_notifier);\r\n}\r\npr_debug(PREFIX "v" INTEL_IDLE_VERSION\r\n" model 0x%X\n", boot_cpu_data.x86_model);\r\npr_debug(PREFIX "lapic_timer_reliable_states 0x%x\n",\r\nlapic_timer_reliable_states);\r\nreturn 0;\r\n}\r\nstatic void intel_idle_cpuidle_devices_uninit(void)\r\n{\r\nint i;\r\nstruct cpuidle_device *dev;\r\nfor_each_online_cpu(i) {\r\ndev = per_cpu_ptr(intel_idle_cpuidle_devices, i);\r\ncpuidle_unregister_device(dev);\r\n}\r\nfree_percpu(intel_idle_cpuidle_devices);\r\nreturn;\r\n}\r\nstatic int intel_idle_cpuidle_devices_init(void)\r\n{\r\nint i, cstate;\r\nstruct cpuidle_device *dev;\r\nintel_idle_cpuidle_devices = alloc_percpu(struct cpuidle_device);\r\nif (intel_idle_cpuidle_devices == NULL)\r\nreturn -ENOMEM;\r\nfor_each_online_cpu(i) {\r\ndev = per_cpu_ptr(intel_idle_cpuidle_devices, i);\r\ndev->state_count = 1;\r\nfor (cstate = 1; cstate < MWAIT_MAX_NUM_CSTATES; ++cstate) {\r\nint num_substates;\r\nif (cstate > max_cstate) {\r\nprintk(PREFIX "max_cstate %d reached\n",\r\nmax_cstate);\r\nbreak;\r\n}\r\nnum_substates = (mwait_substates >> ((cstate) * 4))\r\n& MWAIT_SUBSTATE_MASK;\r\nif (num_substates == 0)\r\ncontinue;\r\nif (cpuidle_state_table[cstate].enter == NULL) {\r\nif (*cpuidle_state_table[cstate].name == '\0')\r\npr_debug(PREFIX "unaware of model 0x%x"\r\n" MWAIT %d please"\r\n" contact lenb@kernel.org",\r\nboot_cpu_data.x86_model, cstate);\r\ncontinue;\r\n}\r\nif ((cstate > 2) &&\r\n!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))\r\nmark_tsc_unstable("TSC halts in idle"\r\n" states deeper than C2");\r\ndev->states[dev->state_count] =\r\ncpuidle_state_table[cstate];\r\ndev->state_count += 1;\r\n}\r\ndev->cpu = i;\r\nif (cpuidle_register_device(dev)) {\r\npr_debug(PREFIX "cpuidle_register_device %d failed!\n",\r\ni);\r\nintel_idle_cpuidle_devices_uninit();\r\nreturn -EIO;\r\n}\r\n}\r\nif (auto_demotion_disable_flags)\r\nsmp_call_function(auto_demotion_disable, NULL, 1);\r\nreturn 0;\r\n}\r\nstatic int __init intel_idle_init(void)\r\n{\r\nint retval;\r\nif (boot_option_idle_override != IDLE_NO_OVERRIDE)\r\nreturn -ENODEV;\r\nretval = intel_idle_probe();\r\nif (retval)\r\nreturn retval;\r\nretval = cpuidle_register_driver(&intel_idle_driver);\r\nif (retval) {\r\nprintk(KERN_DEBUG PREFIX "intel_idle yielding to %s",\r\ncpuidle_get_driver()->name);\r\nreturn retval;\r\n}\r\nretval = intel_idle_cpuidle_devices_init();\r\nif (retval) {\r\ncpuidle_unregister_driver(&intel_idle_driver);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit intel_idle_exit(void)\r\n{\r\nintel_idle_cpuidle_devices_uninit();\r\ncpuidle_unregister_driver(&intel_idle_driver);\r\nif (lapic_timer_reliable_states != LAPIC_TIMER_ALWAYS_RELIABLE) {\r\nsmp_call_function(__setup_broadcast_timer, (void *)false, 1);\r\nunregister_cpu_notifier(&setup_broadcast_notifier);\r\n}\r\nreturn;\r\n}
