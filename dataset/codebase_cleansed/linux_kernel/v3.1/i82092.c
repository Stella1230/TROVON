static int __devinit i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nunsigned char configbyte;\r\nint i, ret;\r\nenter("i82092aa_pci_probe");\r\nif ((ret = pci_enable_device(dev)))\r\nreturn ret;\r\npci_read_config_byte(dev, 0x40, &configbyte);\r\nswitch(configbyte&6) {\r\ncase 0:\r\nsocket_count = 2;\r\nbreak;\r\ncase 2:\r\nsocket_count = 1;\r\nbreak;\r\ncase 4:\r\ncase 6:\r\nsocket_count = 4;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "i82092aa: Oops, you did something we didn't think of.\n");\r\nret = -EIO;\r\ngoto err_out_disable;\r\n}\r\nprintk(KERN_INFO "i82092aa: configured as a %d socket device.\n", socket_count);\r\nif (!request_region(pci_resource_start(dev, 0), 2, "i82092aa")) {\r\nret = -EBUSY;\r\ngoto err_out_disable;\r\n}\r\nfor (i = 0;i<socket_count;i++) {\r\nsockets[i].card_state = 1;\r\nsockets[i].io_base = pci_resource_start(dev, 0);\r\nsockets[i].socket.features |= SS_CAP_PCCARD;\r\nsockets[i].socket.map_size = 0x1000;\r\nsockets[i].socket.irq_mask = 0;\r\nsockets[i].socket.pci_irq = dev->irq;\r\nsockets[i].socket.cb_dev = dev;\r\nsockets[i].socket.owner = THIS_MODULE;\r\nsockets[i].number = i;\r\nif (card_present(i)) {\r\nsockets[i].card_state = 3;\r\ndprintk(KERN_DEBUG "i82092aa: slot %i is occupied\n",i);\r\n} else {\r\ndprintk(KERN_DEBUG "i82092aa: slot %i is vacant\n",i);\r\n}\r\n}\r\nconfigbyte = 0xFF;\r\npci_write_config_byte(dev, 0x50, configbyte);\r\ndprintk(KERN_DEBUG "Requesting interrupt %i \n",dev->irq);\r\nif ((ret = request_irq(dev->irq, i82092aa_interrupt, IRQF_SHARED, "i82092aa", i82092aa_interrupt))) {\r\nprintk(KERN_ERR "i82092aa: Failed to register IRQ %d, aborting\n", dev->irq);\r\ngoto err_out_free_res;\r\n}\r\npci_set_drvdata(dev, &sockets[i].socket);\r\nfor (i = 0; i<socket_count; i++) {\r\nsockets[i].socket.dev.parent = &dev->dev;\r\nsockets[i].socket.ops = &i82092aa_operations;\r\nsockets[i].socket.resource_ops = &pccard_nonstatic_ops;\r\nret = pcmcia_register_socket(&sockets[i].socket);\r\nif (ret) {\r\ngoto err_out_free_sockets;\r\n}\r\n}\r\nleave("i82092aa_pci_probe");\r\nreturn 0;\r\nerr_out_free_sockets:\r\nif (i) {\r\nfor (i--;i>=0;i--) {\r\npcmcia_unregister_socket(&sockets[i].socket);\r\n}\r\n}\r\nfree_irq(dev->irq, i82092aa_interrupt);\r\nerr_out_free_res:\r\nrelease_region(pci_resource_start(dev, 0), 2);\r\nerr_out_disable:\r\npci_disable_device(dev);\r\nreturn ret;\r\n}\r\nstatic void __devexit i82092aa_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct pcmcia_socket *socket = pci_get_drvdata(dev);\r\nenter("i82092aa_pci_remove");\r\nfree_irq(dev->irq, i82092aa_interrupt);\r\nif (socket)\r\npcmcia_unregister_socket(socket);\r\nleave("i82092aa_pci_remove");\r\n}\r\nstatic unsigned char indirect_read(int socket, unsigned short reg)\r\n{\r\nunsigned short int port;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock,flags);\r\nreg += socket * 0x40;\r\nport = sockets[socket].io_base;\r\noutb(reg,port);\r\nval = inb(port+1);\r\nspin_unlock_irqrestore(&port_lock,flags);\r\nreturn val;\r\n}\r\nstatic void indirect_write(int socket, unsigned short reg, unsigned char value)\r\n{\r\nunsigned short int port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock,flags);\r\nreg = reg + socket * 0x40;\r\nport = sockets[socket].io_base;\r\noutb(reg,port);\r\noutb(value,port+1);\r\nspin_unlock_irqrestore(&port_lock,flags);\r\n}\r\nstatic void indirect_setbit(int socket, unsigned short reg, unsigned char mask)\r\n{\r\nunsigned short int port;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock,flags);\r\nreg = reg + socket * 0x40;\r\nport = sockets[socket].io_base;\r\noutb(reg,port);\r\nval = inb(port+1);\r\nval |= mask;\r\noutb(reg,port);\r\noutb(val,port+1);\r\nspin_unlock_irqrestore(&port_lock,flags);\r\n}\r\nstatic void indirect_resetbit(int socket, unsigned short reg, unsigned char mask)\r\n{\r\nunsigned short int port;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock,flags);\r\nreg = reg + socket * 0x40;\r\nport = sockets[socket].io_base;\r\noutb(reg,port);\r\nval = inb(port+1);\r\nval &= ~mask;\r\noutb(reg,port);\r\noutb(val,port+1);\r\nspin_unlock_irqrestore(&port_lock,flags);\r\n}\r\nstatic void indirect_write16(int socket, unsigned short reg, unsigned short value)\r\n{\r\nunsigned short int port;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock,flags);\r\nreg = reg + socket * 0x40;\r\nport = sockets[socket].io_base;\r\noutb(reg,port);\r\nval = value & 255;\r\noutb(val,port+1);\r\nreg++;\r\noutb(reg,port);\r\nval = value>>8;\r\noutb(val,port+1);\r\nspin_unlock_irqrestore(&port_lock,flags);\r\n}\r\nstatic int to_cycles(int ns)\r\n{\r\nif (cycle_time!=0)\r\nreturn ns/cycle_time;\r\nelse\r\nreturn 0;\r\n}\r\nstatic irqreturn_t i82092aa_interrupt(int irq, void *dev)\r\n{\r\nint i;\r\nint loopcount = 0;\r\nint handled = 0;\r\nunsigned int events, active=0;\r\nwhile (1) {\r\nloopcount++;\r\nif (loopcount>20) {\r\nprintk(KERN_ERR "i82092aa: infinite eventloop in interrupt \n");\r\nbreak;\r\n}\r\nactive = 0;\r\nfor (i=0;i<socket_count;i++) {\r\nint csc;\r\nif (sockets[i].card_state==0)\r\ncontinue;\r\ncsc = indirect_read(i,I365_CSC);\r\nif (csc==0)\r\ncontinue;\r\nhandled = 1;\r\nevents = 0;\r\nif (csc & I365_CSC_DETECT) {\r\nevents |= SS_DETECT;\r\nprintk("Card detected in socket %i!\n",i);\r\n}\r\nif (indirect_read(i,I365_INTCTL) & I365_PC_IOCARD) {\r\nevents |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0;\r\n} else {\r\nevents |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;\r\nevents |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;\r\nevents |= (csc & I365_CSC_READY) ? SS_READY : 0;\r\n}\r\nif (events) {\r\npcmcia_parse_events(&sockets[i].socket, events);\r\n}\r\nactive |= events;\r\n}\r\nif (active==0)\r\nbreak;\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int card_present(int socketno)\r\n{\r\nunsigned int val;\r\nenter("card_present");\r\nif ((socketno<0) || (socketno >= MAX_SOCKETS))\r\nreturn 0;\r\nif (sockets[socketno].io_base == 0)\r\nreturn 0;\r\nval = indirect_read(socketno, 1);\r\nif ((val&12)==12) {\r\nleave("card_present 1");\r\nreturn 1;\r\n}\r\nleave("card_present 0");\r\nreturn 0;\r\n}\r\nstatic void set_bridge_state(int sock)\r\n{\r\nenter("set_bridge_state");\r\nindirect_write(sock, I365_GBLCTL,0x00);\r\nindirect_write(sock, I365_GENCTL,0x00);\r\nindirect_setbit(sock, I365_INTCTL,0x08);\r\nleave("set_bridge_state");\r\n}\r\nstatic int i82092aa_init(struct pcmcia_socket *sock)\r\n{\r\nint i;\r\nstruct resource res = { .start = 0, .end = 0x0fff };\r\npccard_io_map io = { 0, 0, 0, 0, 1 };\r\npccard_mem_map mem = { .res = &res, };\r\nenter("i82092aa_init");\r\nfor (i = 0; i < 2; i++) {\r\nio.map = i;\r\ni82092aa_set_io_map(sock, &io);\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nmem.map = i;\r\ni82092aa_set_mem_map(sock, &mem);\r\n}\r\nleave("i82092aa_init");\r\nreturn 0;\r\n}\r\nstatic int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)\r\n{\r\nunsigned int sock = container_of(socket, struct socket_info, socket)->number;\r\nunsigned int status;\r\nenter("i82092aa_get_status");\r\nstatus = indirect_read(sock,I365_STATUS);\r\n*value = 0;\r\nif ((status & I365_CS_DETECT) == I365_CS_DETECT) {\r\n*value |= SS_DETECT;\r\n}\r\nif (indirect_read(sock, I365_INTCTL) & I365_PC_IOCARD) {\r\nif (!(status & I365_CS_STSCHG))\r\n*value |= SS_STSCHG;\r\n} else {\r\nif (!(status & I365_CS_BVD1))\r\n*value |= SS_BATDEAD;\r\nif (!(status & I365_CS_BVD2))\r\n*value |= SS_BATWARN;\r\n}\r\nif (status & I365_CS_WRPROT)\r\n(*value) |= SS_WRPROT;\r\nif (status & I365_CS_READY)\r\n(*value) |= SS_READY;\r\nif (status & I365_CS_POWERON)\r\n(*value) |= SS_POWERON;\r\nleave("i82092aa_get_status");\r\nreturn 0;\r\n}\r\nstatic int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *state)\r\n{\r\nunsigned int sock = container_of(socket, struct socket_info, socket)->number;\r\nunsigned char reg;\r\nenter("i82092aa_set_socket");\r\nset_bridge_state(sock);\r\nreg = 0;\r\nif (!(state->flags & SS_RESET))\r\nreg = reg | I365_PC_RESET;\r\nif (state->flags & SS_IOCARD)\r\nreg = reg | I365_PC_IOCARD;\r\nindirect_write(sock,I365_INTCTL,reg);\r\nreg = I365_PWR_NORESET;\r\nif (state->flags & SS_PWR_AUTO) {\r\nprintk("Auto power\n");\r\nreg |= I365_PWR_AUTO;\r\n}\r\nif (state->flags & SS_OUTPUT_ENA) {\r\nprintk("Power Enabled \n");\r\nreg |= I365_PWR_OUT;\r\n}\r\nswitch (state->Vcc) {\r\ncase 0:\r\nbreak;\r\ncase 50:\r\nprintk("setting voltage to Vcc to 5V on socket %i\n",sock);\r\nreg |= I365_VCC_5V;\r\nbreak;\r\ndefault:\r\nprintk("i82092aa: i82092aa_set_socket called with invalid VCC power value: %i ", state->Vcc);\r\nleave("i82092aa_set_socket");\r\nreturn -EINVAL;\r\n}\r\nswitch (state->Vpp) {\r\ncase 0:\r\nprintk("not setting Vpp on socket %i\n",sock);\r\nbreak;\r\ncase 50:\r\nprintk("setting Vpp to 5.0 for socket %i\n",sock);\r\nreg |= I365_VPP1_5V | I365_VPP2_5V;\r\nbreak;\r\ncase 120:\r\nprintk("setting Vpp to 12.0\n");\r\nreg |= I365_VPP1_12V | I365_VPP2_12V;\r\nbreak;\r\ndefault:\r\nprintk("i82092aa: i82092aa_set_socket called with invalid VPP power value: %i ", state->Vcc);\r\nleave("i82092aa_set_socket");\r\nreturn -EINVAL;\r\n}\r\nif (reg != indirect_read(sock,I365_POWER))\r\nindirect_write(sock,I365_POWER,reg);\r\nreg = 0x00;\r\nif (state->csc_mask & SS_DETECT) {\r\nreg |= I365_CSC_DETECT;\r\n}\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG)\r\nreg |= I365_CSC_STSCHG;\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD)\r\nreg |= I365_CSC_BVD1;\r\nif (state->csc_mask & SS_BATWARN)\r\nreg |= I365_CSC_BVD2;\r\nif (state->csc_mask & SS_READY)\r\nreg |= I365_CSC_READY;\r\n}\r\nindirect_write(sock,I365_CSCINT,reg);\r\n(void)indirect_read(sock,I365_CSC);\r\nleave("i82092aa_set_socket");\r\nreturn 0;\r\n}\r\nstatic int i82092aa_set_io_map(struct pcmcia_socket *socket, struct pccard_io_map *io)\r\n{\r\nunsigned int sock = container_of(socket, struct socket_info, socket)->number;\r\nunsigned char map, ioctl;\r\nenter("i82092aa_set_io_map");\r\nmap = io->map;\r\nif (map > 1) {\r\nleave("i82092aa_set_io_map with invalid map");\r\nreturn -EINVAL;\r\n}\r\nif ((io->start > 0xffff) || (io->stop > 0xffff) || (io->stop < io->start)){\r\nleave("i82092aa_set_io_map with invalid io");\r\nreturn -EINVAL;\r\n}\r\nif (indirect_read(sock, I365_ADDRWIN) & I365_ENA_IO(map))\r\nindirect_resetbit(sock, I365_ADDRWIN, I365_ENA_IO(map));\r\nindirect_write16(sock,I365_IO(map)+I365_W_START,io->start);\r\nindirect_write16(sock,I365_IO(map)+I365_W_STOP,io->stop);\r\nioctl = indirect_read(sock,I365_IOCTL) & ~I365_IOCTL_MASK(map);\r\nif (io->flags & (MAP_16BIT|MAP_AUTOSZ))\r\nioctl |= I365_IOCTL_16BIT(map);\r\nindirect_write(sock,I365_IOCTL,ioctl);\r\nif (io->flags & MAP_ACTIVE)\r\nindirect_setbit(sock,I365_ADDRWIN,I365_ENA_IO(map));\r\nleave("i82092aa_set_io_map");\r\nreturn 0;\r\n}\r\nstatic int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_map *mem)\r\n{\r\nstruct socket_info *sock_info = container_of(socket, struct socket_info, socket);\r\nunsigned int sock = sock_info->number;\r\nstruct pci_bus_region region;\r\nunsigned short base, i;\r\nunsigned char map;\r\nenter("i82092aa_set_mem_map");\r\npcibios_resource_to_bus(sock_info->dev, &region, mem->res);\r\nmap = mem->map;\r\nif (map > 4) {\r\nleave("i82092aa_set_mem_map: invalid map");\r\nreturn -EINVAL;\r\n}\r\nif ( (mem->card_start > 0x3ffffff) || (region.start > region.end) ||\r\n(mem->speed > 1000) ) {\r\nleave("i82092aa_set_mem_map: invalid address / speed");\r\nprintk("invalid mem map for socket %i: %llx to %llx with a "\r\n"start of %x\n",\r\nsock,\r\n(unsigned long long)region.start,\r\n(unsigned long long)region.end,\r\nmem->card_start);\r\nreturn -EINVAL;\r\n}\r\nif (indirect_read(sock, I365_ADDRWIN) & I365_ENA_MEM(map))\r\nindirect_resetbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));\r\nbase = I365_MEM(map);\r\ni = (region.start >> 12) & 0x0fff;\r\nif (mem->flags & MAP_16BIT)\r\ni |= I365_MEM_16BIT;\r\nif (mem->flags & MAP_0WS)\r\ni |= I365_MEM_0WS;\r\nindirect_write16(sock,base+I365_W_START,i);\r\ni= (region.end >> 12) & 0x0fff;\r\nswitch (to_cycles(mem->speed)) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ni |= I365_MEM_WS0;\r\nbreak;\r\ncase 2:\r\ni |= I365_MEM_WS1;\r\nbreak;\r\ndefault:\r\ni |= I365_MEM_WS1 | I365_MEM_WS0;\r\nbreak;\r\n}\r\nindirect_write16(sock,base+I365_W_STOP,i);\r\ni = ((mem->card_start - region.start) >> 12) & 0x3fff;\r\nif (mem->flags & MAP_WRPROT)\r\ni |= I365_MEM_WRPROT;\r\nif (mem->flags & MAP_ATTRIB) {\r\ni |= I365_MEM_REG;\r\n} else {\r\n}\r\nindirect_write16(sock,base+I365_W_OFF,i);\r\nif (mem->flags & MAP_ACTIVE)\r\nindirect_setbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));\r\nleave("i82092aa_set_mem_map");\r\nreturn 0;\r\n}\r\nstatic int i82092aa_module_init(void)\r\n{\r\nreturn pci_register_driver(&i82092aa_pci_driver);\r\n}\r\nstatic void i82092aa_module_exit(void)\r\n{\r\nenter("i82092aa_module_exit");\r\npci_unregister_driver(&i82092aa_pci_driver);\r\nif (sockets[0].io_base>0)\r\nrelease_region(sockets[0].io_base, 2);\r\nleave("i82092aa_module_exit");\r\n}
