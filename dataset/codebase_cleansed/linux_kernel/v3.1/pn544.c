static ssize_t pn544_test(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct pn544_info *info = dev_get_drvdata(dev);\r\nstruct i2c_client *client = info->i2c_dev;\r\nstruct pn544_nfc_platform_data *pdata = client->dev.platform_data;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", pdata->test());\r\n}\r\nstatic int pn544_enable(struct pn544_info *info, int mode)\r\n{\r\nstruct pn544_nfc_platform_data *pdata;\r\nstruct i2c_client *client = info->i2c_dev;\r\nint r;\r\nr = regulator_bulk_enable(ARRAY_SIZE(info->regs), info->regs);\r\nif (r < 0)\r\nreturn r;\r\npdata = client->dev.platform_data;\r\ninfo->read_irq = PN544_NONE;\r\nif (pdata->enable)\r\npdata->enable(mode);\r\nif (mode) {\r\ninfo->state = PN544_ST_FW_READY;\r\ndev_dbg(&client->dev, "now in FW-mode\n");\r\n} else {\r\ninfo->state = PN544_ST_READY;\r\ndev_dbg(&client->dev, "now in HCI-mode\n");\r\n}\r\nusleep_range(10000, 15000);\r\nreturn 0;\r\n}\r\nstatic void pn544_disable(struct pn544_info *info)\r\n{\r\nstruct pn544_nfc_platform_data *pdata;\r\nstruct i2c_client *client = info->i2c_dev;\r\npdata = client->dev.platform_data;\r\nif (pdata->disable)\r\npdata->disable();\r\ninfo->state = PN544_ST_COLD;\r\ndev_dbg(&client->dev, "Now in OFF-mode\n");\r\nmsleep(PN544_RESETVEN_TIME);\r\ninfo->read_irq = PN544_NONE;\r\nregulator_bulk_disable(ARRAY_SIZE(info->regs), info->regs);\r\n}\r\nstatic int check_crc(u8 *buf, int buflen)\r\n{\r\nu8 len;\r\nu16 crc;\r\nlen = buf[0] + 1;\r\nif (len < 4 || len != buflen || len > PN544_MSG_MAX_SIZE) {\r\npr_err(PN544_DRIVER_NAME\r\n": CRC; corrupt packet len %u (%d)\n", len, buflen);\r\nprint_hex_dump(KERN_DEBUG, "crc: ", DUMP_PREFIX_NONE,\r\n16, 2, buf, buflen, false);\r\nreturn -EPERM;\r\n}\r\ncrc = crc_ccitt(0xffff, buf, len - 2);\r\ncrc = ~crc;\r\nif (buf[len-2] != (crc & 0xff) || buf[len-1] != (crc >> 8)) {\r\npr_err(PN544_DRIVER_NAME ": CRC error 0x%x != 0x%x 0x%x\n",\r\ncrc, buf[len-1], buf[len-2]);\r\nprint_hex_dump(KERN_DEBUG, "crc: ", DUMP_PREFIX_NONE,\r\n16, 2, buf, buflen, false);\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pn544_i2c_write(struct i2c_client *client, u8 *buf, int len)\r\n{\r\nint r;\r\nif (len < 4 || len != (buf[0] + 1)) {\r\ndev_err(&client->dev, "%s: Illegal message length: %d\n",\r\n__func__, len);\r\nreturn -EINVAL;\r\n}\r\nif (check_crc(buf, len))\r\nreturn -EINVAL;\r\nusleep_range(3000, 6000);\r\nr = i2c_master_send(client, buf, len);\r\ndev_dbg(&client->dev, "send: %d\n", r);\r\nif (r == -EREMOTEIO) {\r\nusleep_range(6000, 10000);\r\nr = i2c_master_send(client, buf, len);\r\ndev_dbg(&client->dev, "send2: %d\n", r);\r\n}\r\nif (r != len)\r\nreturn -EREMOTEIO;\r\nreturn r;\r\n}\r\nstatic int pn544_i2c_read(struct i2c_client *client, u8 *buf, int buflen)\r\n{\r\nint r;\r\nu8 len;\r\nr = i2c_master_recv(client, &len, 1);\r\ndev_dbg(&client->dev, "recv1: %d\n", r);\r\nif (r != 1)\r\nreturn -EREMOTEIO;\r\nif (len < PN544_LLC_HCI_OVERHEAD)\r\nlen = PN544_LLC_HCI_OVERHEAD;\r\nelse if (len > (PN544_MSG_MAX_SIZE - 1))\r\nlen = PN544_MSG_MAX_SIZE - 1;\r\nif (1 + len > buflen)\r\nreturn -EMSGSIZE;\r\nbuf[0] = len;\r\nr = i2c_master_recv(client, buf + 1, len);\r\ndev_dbg(&client->dev, "recv2: %d\n", r);\r\nif (r != len)\r\nreturn -EREMOTEIO;\r\nusleep_range(3000, 6000);\r\nreturn r + 1;\r\n}\r\nstatic int pn544_fw_write(struct i2c_client *client, u8 *buf, int len)\r\n{\r\nint r;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nif (len < PN544_FW_HEADER_SIZE ||\r\n(PN544_FW_HEADER_SIZE + (buf[1] << 8) + buf[2]) != len)\r\nreturn -EINVAL;\r\nr = i2c_master_send(client, buf, len);\r\ndev_dbg(&client->dev, "fw send: %d\n", r);\r\nif (r == -EREMOTEIO) {\r\nusleep_range(6000, 10000);\r\nr = i2c_master_send(client, buf, len);\r\ndev_dbg(&client->dev, "fw send2: %d\n", r);\r\n}\r\nif (r != len)\r\nreturn -EREMOTEIO;\r\nreturn r;\r\n}\r\nstatic int pn544_fw_read(struct i2c_client *client, u8 *buf, int buflen)\r\n{\r\nint r, len;\r\nif (buflen < PN544_FW_HEADER_SIZE)\r\nreturn -EINVAL;\r\nr = i2c_master_recv(client, buf, PN544_FW_HEADER_SIZE);\r\ndev_dbg(&client->dev, "FW recv1: %d\n", r);\r\nif (r < 0)\r\nreturn r;\r\nif (r < PN544_FW_HEADER_SIZE)\r\nreturn -EINVAL;\r\nlen = (buf[1] << 8) + buf[2];\r\nif (len == 0)\r\nreturn r;\r\nif (len > buflen - PN544_FW_HEADER_SIZE)\r\nreturn -EMSGSIZE;\r\nr = i2c_master_recv(client, buf + PN544_FW_HEADER_SIZE, len);\r\ndev_dbg(&client->dev, "fw recv2: %d\n", r);\r\nif (r != len)\r\nreturn -EINVAL;\r\nreturn r + PN544_FW_HEADER_SIZE;\r\n}\r\nstatic irqreturn_t pn544_irq_thread_fn(int irq, void *dev_id)\r\n{\r\nstruct pn544_info *info = dev_id;\r\nstruct i2c_client *client = info->i2c_dev;\r\nBUG_ON(!info);\r\nBUG_ON(irq != info->i2c_dev->irq);\r\ndev_dbg(&client->dev, "IRQ\n");\r\nmutex_lock(&info->read_mutex);\r\ninfo->read_irq = PN544_INT;\r\nmutex_unlock(&info->read_mutex);\r\nwake_up_interruptible(&info->read_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic enum pn544_irq pn544_irq_state(struct pn544_info *info)\r\n{\r\nenum pn544_irq irq;\r\nmutex_lock(&info->read_mutex);\r\nirq = info->read_irq;\r\nmutex_unlock(&info->read_mutex);\r\nreturn irq;\r\n}\r\nstatic ssize_t pn544_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct pn544_info *info = container_of(file->private_data,\r\nstruct pn544_info, miscdev);\r\nstruct i2c_client *client = info->i2c_dev;\r\nenum pn544_irq irq;\r\nsize_t len;\r\nint r = 0;\r\ndev_dbg(&client->dev, "%s: info: %p, count: %zu\n", __func__,\r\ninfo, count);\r\nmutex_lock(&info->mutex);\r\nif (info->state == PN544_ST_COLD) {\r\nr = -ENODEV;\r\ngoto out;\r\n}\r\nirq = pn544_irq_state(info);\r\nif (irq == PN544_NONE) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nr = -EAGAIN;\r\ngoto out;\r\n}\r\nif (wait_event_interruptible(info->read_wait,\r\n(info->read_irq == PN544_INT))) {\r\nr = -ERESTARTSYS;\r\ngoto out;\r\n}\r\n}\r\nif (info->state == PN544_ST_FW_READY) {\r\nlen = min(count, info->buflen);\r\nmutex_lock(&info->read_mutex);\r\nr = pn544_fw_read(info->i2c_dev, info->buf, len);\r\ninfo->read_irq = PN544_NONE;\r\nmutex_unlock(&info->read_mutex);\r\nif (r < 0) {\r\ndev_err(&info->i2c_dev->dev, "FW read failed: %d\n", r);\r\ngoto out;\r\n}\r\nprint_hex_dump(KERN_DEBUG, "FW read: ", DUMP_PREFIX_NONE,\r\n16, 2, info->buf, r, false);\r\n*offset += r;\r\nif (copy_to_user(buf, info->buf, r)) {\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\n} else {\r\nlen = min(count, info->buflen);\r\nmutex_lock(&info->read_mutex);\r\nr = pn544_i2c_read(info->i2c_dev, info->buf, len);\r\ninfo->read_irq = PN544_NONE;\r\nmutex_unlock(&info->read_mutex);\r\nif (r < 0) {\r\ndev_err(&info->i2c_dev->dev, "read failed (%d)\n", r);\r\ngoto out;\r\n}\r\nprint_hex_dump(KERN_DEBUG, "read: ", DUMP_PREFIX_NONE,\r\n16, 2, info->buf, r, false);\r\n*offset += r;\r\nif (copy_to_user(buf, info->buf, r)) {\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&info->mutex);\r\nreturn r;\r\n}\r\nstatic unsigned int pn544_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct pn544_info *info = container_of(file->private_data,\r\nstruct pn544_info, miscdev);\r\nstruct i2c_client *client = info->i2c_dev;\r\nint r = 0;\r\ndev_dbg(&client->dev, "%s: info: %p\n", __func__, info);\r\nmutex_lock(&info->mutex);\r\nif (info->state == PN544_ST_COLD) {\r\nr = -ENODEV;\r\ngoto out;\r\n}\r\npoll_wait(file, &info->read_wait, wait);\r\nif (pn544_irq_state(info) == PN544_INT) {\r\nr = POLLIN | POLLRDNORM;\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&info->mutex);\r\nreturn r;\r\n}\r\nstatic ssize_t pn544_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct pn544_info *info = container_of(file->private_data,\r\nstruct pn544_info, miscdev);\r\nstruct i2c_client *client = info->i2c_dev;\r\nssize_t len;\r\nint r;\r\ndev_dbg(&client->dev, "%s: info: %p, count %zu\n", __func__,\r\ninfo, count);\r\nmutex_lock(&info->mutex);\r\nif (info->state == PN544_ST_COLD) {\r\nr = -ENODEV;\r\ngoto out;\r\n}\r\nif (info->state == PN544_ST_FW_READY) {\r\nsize_t fw_len;\r\nif (count < PN544_FW_HEADER_SIZE) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nlen = min(count, info->buflen);\r\nif (copy_from_user(info->buf, buf, len)) {\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nprint_hex_dump(KERN_DEBUG, "FW write: ", DUMP_PREFIX_NONE,\r\n16, 2, info->buf, len, false);\r\nfw_len = PN544_FW_HEADER_SIZE + (info->buf[1] << 8) +\r\ninfo->buf[2];\r\nif (len > fw_len)\r\nlen = fw_len;\r\nr = pn544_fw_write(info->i2c_dev, info->buf, len);\r\n} else {\r\nif (count < PN544_LLC_MIN_SIZE) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nlen = min(count, info->buflen);\r\nif (copy_from_user(info->buf, buf, len)) {\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nprint_hex_dump(KERN_DEBUG, "write: ", DUMP_PREFIX_NONE,\r\n16, 2, info->buf, len, false);\r\nif (len > (info->buf[0] + 1))\r\nlen = info->buf[0] + 1;\r\nr = pn544_i2c_write(info->i2c_dev, info->buf, len);\r\n}\r\nout:\r\nmutex_unlock(&info->mutex);\r\nreturn r;\r\n}\r\nstatic long pn544_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct pn544_info *info = container_of(file->private_data,\r\nstruct pn544_info, miscdev);\r\nstruct i2c_client *client = info->i2c_dev;\r\nstruct pn544_nfc_platform_data *pdata;\r\nunsigned int val;\r\nint r = 0;\r\ndev_dbg(&client->dev, "%s: info: %p, cmd: 0x%x\n", __func__, info, cmd);\r\nmutex_lock(&info->mutex);\r\nif (info->state == PN544_ST_COLD) {\r\nr = -ENODEV;\r\ngoto out;\r\n}\r\npdata = info->i2c_dev->dev.platform_data;\r\nswitch (cmd) {\r\ncase PN544_GET_FW_MODE:\r\ndev_dbg(&client->dev, "%s: PN544_GET_FW_MODE\n", __func__);\r\nval = (info->state == PN544_ST_FW_READY);\r\nif (copy_to_user((void __user *)arg, &val, sizeof(val))) {\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nbreak;\r\ncase PN544_SET_FW_MODE:\r\ndev_dbg(&client->dev, "%s: PN544_SET_FW_MODE\n", __func__);\r\nif (copy_from_user(&val, (void __user *)arg, sizeof(val))) {\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nif (val) {\r\nif (info->state == PN544_ST_FW_READY)\r\nbreak;\r\npn544_disable(info);\r\nr = pn544_enable(info, FW_MODE);\r\nif (r < 0)\r\ngoto out;\r\n} else {\r\nif (info->state == PN544_ST_READY)\r\nbreak;\r\npn544_disable(info);\r\nr = pn544_enable(info, HCI_MODE);\r\nif (r < 0)\r\ngoto out;\r\n}\r\nfile->f_pos = info->read_offset;\r\nbreak;\r\ncase TCGETS:\r\ndev_dbg(&client->dev, "%s: TCGETS\n", __func__);\r\nr = -ENOIOCTLCMD;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Unknown ioctl 0x%x\n", cmd);\r\nr = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&info->mutex);\r\nreturn r;\r\n}\r\nstatic int pn544_open(struct inode *inode, struct file *file)\r\n{\r\nstruct pn544_info *info = container_of(file->private_data,\r\nstruct pn544_info, miscdev);\r\nstruct i2c_client *client = info->i2c_dev;\r\nint r = 0;\r\ndev_dbg(&client->dev, "%s: info: %p, client %p\n", __func__,\r\ninfo, info->i2c_dev);\r\nmutex_lock(&info->mutex);\r\nif (info->state != PN544_ST_COLD) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nfile->f_pos = info->read_offset;\r\nr = pn544_enable(info, HCI_MODE);\r\nout:\r\nmutex_unlock(&info->mutex);\r\nreturn r;\r\n}\r\nstatic int pn544_close(struct inode *inode, struct file *file)\r\n{\r\nstruct pn544_info *info = container_of(file->private_data,\r\nstruct pn544_info, miscdev);\r\nstruct i2c_client *client = info->i2c_dev;\r\ndev_dbg(&client->dev, "%s: info: %p, client %p\n",\r\n__func__, info, info->i2c_dev);\r\nmutex_lock(&info->mutex);\r\npn544_disable(info);\r\nmutex_unlock(&info->mutex);\r\nreturn 0;\r\n}\r\nstatic int pn544_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pn544_info *info;\r\nint r = 0;\r\ndev_info(&client->dev, "***\n%s: client %p\n***\n", __func__, client);\r\ninfo = i2c_get_clientdata(client);\r\ndev_info(&client->dev, "%s: info: %p, client %p\n", __func__,\r\ninfo, client);\r\nmutex_lock(&info->mutex);\r\nswitch (info->state) {\r\ncase PN544_ST_FW_READY:\r\nr = -EPERM;\r\nbreak;\r\ncase PN544_ST_READY:\r\nbreak;\r\ncase PN544_ST_COLD:\r\nbreak;\r\n};\r\nmutex_unlock(&info->mutex);\r\nreturn r;\r\n}\r\nstatic int pn544_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pn544_info *info = i2c_get_clientdata(client);\r\nint r = 0;\r\ndev_dbg(&client->dev, "%s: info: %p, client %p\n", __func__,\r\ninfo, client);\r\nmutex_lock(&info->mutex);\r\nswitch (info->state) {\r\ncase PN544_ST_READY:\r\nbreak;\r\ncase PN544_ST_COLD:\r\nbreak;\r\ncase PN544_ST_FW_READY:\r\nbreak;\r\n};\r\nmutex_unlock(&info->mutex);\r\nreturn r;\r\n}\r\nstatic int __devinit pn544_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pn544_info *info;\r\nstruct pn544_nfc_platform_data *pdata;\r\nint r = 0;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\ndev_dbg(&client->dev, "IRQ: %d\n", client->irq);\r\ninfo = kzalloc(sizeof(struct pn544_info), GFP_KERNEL);\r\nif (!info) {\r\ndev_err(&client->dev,\r\n"Cannot allocate memory for pn544_info.\n");\r\nr = -ENOMEM;\r\ngoto err_info_alloc;\r\n}\r\ninfo->buflen = max(PN544_MSG_MAX_SIZE, PN544_MAX_I2C_TRANSFER);\r\ninfo->buf = kzalloc(info->buflen, GFP_KERNEL);\r\nif (!info->buf) {\r\ndev_err(&client->dev,\r\n"Cannot allocate memory for pn544_info->buf.\n");\r\nr = -ENOMEM;\r\ngoto err_buf_alloc;\r\n}\r\ninfo->regs[0].supply = reg_vdd_io;\r\ninfo->regs[1].supply = reg_vbat;\r\ninfo->regs[2].supply = reg_vsim;\r\nr = regulator_bulk_get(&client->dev, ARRAY_SIZE(info->regs),\r\ninfo->regs);\r\nif (r < 0)\r\ngoto err_kmalloc;\r\ninfo->i2c_dev = client;\r\ninfo->state = PN544_ST_COLD;\r\ninfo->read_irq = PN544_NONE;\r\nmutex_init(&info->read_mutex);\r\nmutex_init(&info->mutex);\r\ninit_waitqueue_head(&info->read_wait);\r\ni2c_set_clientdata(client, info);\r\npdata = client->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&client->dev, "No platform data\n");\r\nr = -EINVAL;\r\ngoto err_reg;\r\n}\r\nif (!pdata->request_resources) {\r\ndev_err(&client->dev, "request_resources() missing\n");\r\nr = -EINVAL;\r\ngoto err_reg;\r\n}\r\nr = pdata->request_resources(client);\r\nif (r) {\r\ndev_err(&client->dev, "Cannot get platform resources\n");\r\ngoto err_reg;\r\n}\r\nr = request_threaded_irq(client->irq, NULL, pn544_irq_thread_fn,\r\nIRQF_TRIGGER_RISING, PN544_DRIVER_NAME,\r\ninfo);\r\nif (r < 0) {\r\ndev_err(&client->dev, "Unable to register IRQ handler\n");\r\ngoto err_res;\r\n}\r\nif (pdata->test) {\r\nr = device_create_file(&client->dev, &pn544_attr);\r\nif (r) {\r\ndev_err(&client->dev,\r\n"sysfs registration failed, error %d\n", r);\r\ngoto err_irq;\r\n}\r\n}\r\ninfo->miscdev.minor = MISC_DYNAMIC_MINOR;\r\ninfo->miscdev.name = PN544_DRIVER_NAME;\r\ninfo->miscdev.fops = &pn544_fops;\r\ninfo->miscdev.parent = &client->dev;\r\nr = misc_register(&info->miscdev);\r\nif (r < 0) {\r\ndev_err(&client->dev, "Device registration failed\n");\r\ngoto err_sysfs;\r\n}\r\ndev_dbg(&client->dev, "%s: info: %p, pdata %p, client %p\n",\r\n__func__, info, pdata, client);\r\nreturn 0;\r\nerr_sysfs:\r\nif (pdata->test)\r\ndevice_remove_file(&client->dev, &pn544_attr);\r\nerr_irq:\r\nfree_irq(client->irq, info);\r\nerr_res:\r\nif (pdata->free_resources)\r\npdata->free_resources();\r\nerr_reg:\r\nregulator_bulk_free(ARRAY_SIZE(info->regs), info->regs);\r\nerr_kmalloc:\r\nkfree(info->buf);\r\nerr_buf_alloc:\r\nkfree(info);\r\nerr_info_alloc:\r\nreturn r;\r\n}\r\nstatic __devexit int pn544_remove(struct i2c_client *client)\r\n{\r\nstruct pn544_info *info = i2c_get_clientdata(client);\r\nstruct pn544_nfc_platform_data *pdata = client->dev.platform_data;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nmisc_deregister(&info->miscdev);\r\nif (pdata->test)\r\ndevice_remove_file(&client->dev, &pn544_attr);\r\nif (info->state != PN544_ST_COLD) {\r\nif (pdata->disable)\r\npdata->disable();\r\ninfo->read_irq = PN544_NONE;\r\n}\r\nfree_irq(client->irq, info);\r\nif (pdata->free_resources)\r\npdata->free_resources();\r\nregulator_bulk_free(ARRAY_SIZE(info->regs), info->regs);\r\nkfree(info->buf);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int __init pn544_init(void)\r\n{\r\nint r;\r\npr_debug(DRIVER_DESC ": %s\n", __func__);\r\nr = i2c_add_driver(&pn544_driver);\r\nif (r) {\r\npr_err(PN544_DRIVER_NAME ": driver registration failed\n");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit pn544_exit(void)\r\n{\r\ni2c_del_driver(&pn544_driver);\r\npr_info(DRIVER_DESC ", Exiting.\n");\r\n}
