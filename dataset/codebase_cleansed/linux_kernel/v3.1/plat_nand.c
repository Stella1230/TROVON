static int __devinit plat_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct platform_nand_data *pdata = pdev->dev.platform_data;\r\nstruct plat_nand_data *data;\r\nstruct resource *res;\r\nint err = 0;\r\nif (pdata->chip.nr_chips < 1) {\r\ndev_err(&pdev->dev, "invalid number of chips specified\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\ndata = kzalloc(sizeof(struct plat_nand_data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&pdev->dev, "failed to allocate device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res),\r\ndev_name(&pdev->dev))) {\r\ndev_err(&pdev->dev, "request_mem_region failed\n");\r\nerr = -EBUSY;\r\ngoto out_free;\r\n}\r\ndata->io_base = ioremap(res->start, resource_size(res));\r\nif (data->io_base == NULL) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nerr = -EIO;\r\ngoto out_release_io;\r\n}\r\ndata->chip.priv = &data;\r\ndata->mtd.priv = &data->chip;\r\ndata->mtd.owner = THIS_MODULE;\r\ndata->mtd.name = dev_name(&pdev->dev);\r\ndata->chip.IO_ADDR_R = data->io_base;\r\ndata->chip.IO_ADDR_W = data->io_base;\r\ndata->chip.cmd_ctrl = pdata->ctrl.cmd_ctrl;\r\ndata->chip.dev_ready = pdata->ctrl.dev_ready;\r\ndata->chip.select_chip = pdata->ctrl.select_chip;\r\ndata->chip.write_buf = pdata->ctrl.write_buf;\r\ndata->chip.read_buf = pdata->ctrl.read_buf;\r\ndata->chip.chip_delay = pdata->chip.chip_delay;\r\ndata->chip.options |= pdata->chip.options;\r\ndata->chip.ecc.hwctl = pdata->ctrl.hwcontrol;\r\ndata->chip.ecc.layout = pdata->chip.ecclayout;\r\ndata->chip.ecc.mode = NAND_ECC_SOFT;\r\nplatform_set_drvdata(pdev, data);\r\nif (pdata->ctrl.probe) {\r\nerr = pdata->ctrl.probe(pdev);\r\nif (err)\r\ngoto out;\r\n}\r\nif (nand_scan(&data->mtd, pdata->chip.nr_chips)) {\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nif (pdata->chip.part_probe_types) {\r\nerr = parse_mtd_partitions(&data->mtd,\r\npdata->chip.part_probe_types,\r\n&data->parts, 0);\r\nif (err > 0) {\r\nmtd_device_register(&data->mtd, data->parts, err);\r\nreturn 0;\r\n}\r\n}\r\nif (pdata->chip.set_parts)\r\npdata->chip.set_parts(data->mtd.size, &pdata->chip);\r\nif (pdata->chip.partitions) {\r\ndata->parts = pdata->chip.partitions;\r\nerr = mtd_device_register(&data->mtd, data->parts,\r\npdata->chip.nr_partitions);\r\n} else\r\nerr = mtd_device_register(&data->mtd, NULL, 0);\r\nif (!err)\r\nreturn err;\r\nnand_release(&data->mtd);\r\nout:\r\nif (pdata->ctrl.remove)\r\npdata->ctrl.remove(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(data->io_base);\r\nout_release_io:\r\nrelease_mem_region(res->start, resource_size(res));\r\nout_free:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int __devexit plat_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct plat_nand_data *data = platform_get_drvdata(pdev);\r\nstruct platform_nand_data *pdata = pdev->dev.platform_data;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnand_release(&data->mtd);\r\nif (data->parts && data->parts != pdata->chip.partitions)\r\nkfree(data->parts);\r\nif (pdata->ctrl.remove)\r\npdata->ctrl.remove(pdev);\r\niounmap(data->io_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init plat_nand_init(void)\r\n{\r\nreturn platform_driver_register(&plat_nand_driver);\r\n}\r\nstatic void __exit plat_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&plat_nand_driver);\r\n}
