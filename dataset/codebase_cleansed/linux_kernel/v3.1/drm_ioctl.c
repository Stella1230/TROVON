int drm_getunique(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_unique *u = data;\r\nstruct drm_master *master = file_priv->master;\r\nif (u->unique_len >= master->unique_len) {\r\nif (copy_to_user(u->unique, master->unique, master->unique_len))\r\nreturn -EFAULT;\r\n}\r\nu->unique_len = master->unique_len;\r\nreturn 0;\r\n}\r\nstatic void\r\ndrm_unset_busid(struct drm_device *dev,\r\nstruct drm_master *master)\r\n{\r\nkfree(dev->devname);\r\ndev->devname = NULL;\r\nkfree(master->unique);\r\nmaster->unique = NULL;\r\nmaster->unique_len = 0;\r\nmaster->unique_size = 0;\r\n}\r\nint drm_setunique(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_unique *u = data;\r\nstruct drm_master *master = file_priv->master;\r\nint ret;\r\nif (master->unique_len || master->unique)\r\nreturn -EBUSY;\r\nif (!u->unique_len || u->unique_len > 1024)\r\nreturn -EINVAL;\r\nif (!dev->driver->bus->set_unique)\r\nreturn -EINVAL;\r\nret = dev->driver->bus->set_unique(dev, master, u);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndrm_unset_busid(dev, master);\r\nreturn ret;\r\n}\r\nstatic int drm_set_busid(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nstruct drm_master *master = file_priv->master;\r\nint ret;\r\nif (master->unique != NULL)\r\ndrm_unset_busid(dev, master);\r\nret = dev->driver->bus->set_busid(dev, master);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndrm_unset_busid(dev, master);\r\nreturn ret;\r\n}\r\nint drm_getmap(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_map *map = data;\r\nstruct drm_map_list *r_list = NULL;\r\nstruct list_head *list;\r\nint idx;\r\nint i;\r\nidx = map->offset;\r\nmutex_lock(&dev->struct_mutex);\r\nif (idx < 0) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\ni = 0;\r\nlist_for_each(list, &dev->maplist) {\r\nif (i == idx) {\r\nr_list = list_entry(list, struct drm_map_list, head);\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (!r_list || !r_list->map) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nmap->offset = r_list->map->offset;\r\nmap->size = r_list->map->size;\r\nmap->type = r_list->map->type;\r\nmap->flags = r_list->map->flags;\r\nmap->handle = (void *)(unsigned long) r_list->user_token;\r\nmap->mtrr = r_list->map->mtrr;\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_getclient(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_client *client = data;\r\nstruct drm_file *pt;\r\nint idx;\r\nint i;\r\nidx = client->idx;\r\nmutex_lock(&dev->struct_mutex);\r\ni = 0;\r\nlist_for_each_entry(pt, &dev->filelist, lhead) {\r\nif (i++ >= idx) {\r\nclient->auth = pt->authenticated;\r\nclient->pid = pt->pid;\r\nclient->uid = pt->uid;\r\nclient->magic = pt->magic;\r\nclient->iocs = pt->ioctl_count;\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nint drm_getstats(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_stats *stats = data;\r\nint i;\r\nmemset(stats, 0, sizeof(*stats));\r\nmutex_lock(&dev->struct_mutex);\r\nfor (i = 0; i < dev->counters; i++) {\r\nif (dev->types[i] == _DRM_STAT_LOCK)\r\nstats->data[i].value =\r\n(file_priv->master->lock.hw_lock ? file_priv->master->lock.hw_lock->lock : 0);\r\nelse\r\nstats->data[i].value = atomic_read(&dev->counts[i]);\r\nstats->data[i].type = dev->types[i];\r\n}\r\nstats->count = dev->counters;\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_getcap(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_get_cap *req = data;\r\nreq->value = 0;\r\nswitch (req->capability) {\r\ncase DRM_CAP_DUMB_BUFFER:\r\nif (dev->driver->dumb_create)\r\nreq->value = 1;\r\nbreak;\r\ncase DRM_CAP_VBLANK_HIGH_CRTC:\r\nreq->value = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint drm_setversion(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_set_version *sv = data;\r\nint if_version, retcode = 0;\r\nif (sv->drm_di_major != -1) {\r\nif (sv->drm_di_major != DRM_IF_MAJOR ||\r\nsv->drm_di_minor < 0 || sv->drm_di_minor > DRM_IF_MINOR) {\r\nretcode = -EINVAL;\r\ngoto done;\r\n}\r\nif_version = DRM_IF_VERSION(sv->drm_di_major,\r\nsv->drm_di_minor);\r\ndev->if_version = max(if_version, dev->if_version);\r\nif (sv->drm_di_minor >= 1) {\r\nretcode = drm_set_busid(dev, file_priv);\r\nif (retcode)\r\ngoto done;\r\n}\r\n}\r\nif (sv->drm_dd_major != -1) {\r\nif (sv->drm_dd_major != dev->driver->major ||\r\nsv->drm_dd_minor < 0 || sv->drm_dd_minor >\r\ndev->driver->minor) {\r\nretcode = -EINVAL;\r\ngoto done;\r\n}\r\nif (dev->driver->set_version)\r\ndev->driver->set_version(dev, sv);\r\n}\r\ndone:\r\nsv->drm_di_major = DRM_IF_MAJOR;\r\nsv->drm_di_minor = DRM_IF_MINOR;\r\nsv->drm_dd_major = dev->driver->major;\r\nsv->drm_dd_minor = dev->driver->minor;\r\nreturn retcode;\r\n}\r\nint drm_noop(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nDRM_DEBUG("\n");\r\nreturn 0;\r\n}
