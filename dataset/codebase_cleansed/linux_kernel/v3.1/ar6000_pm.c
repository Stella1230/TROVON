static void ar6k_send_asleep_event_to_app(struct ar6_softc *ar, bool asleep)\r\n{\r\nchar buf[128];\r\nunion iwreq_data wrqu;\r\nsnprintf(buf, sizeof(buf), "HOST_ASLEEP=%s", asleep ? "asleep" : "awake");\r\nA_MEMZERO(&wrqu, sizeof(wrqu));\r\nwrqu.data.length = strlen(buf);\r\nwireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\r\n}\r\nstatic void ar6000_wow_resume(struct ar6_softc *ar)\r\n{\r\nif (ar->arWowState!= WLAN_WOW_STATE_NONE) {\r\nu16 fg_start_period = (ar->scParams.fg_start_period==0) ? 1 : ar->scParams.fg_start_period;\r\nu16 bg_period = (ar->scParams.bg_period==0) ? 60 : ar->scParams.bg_period;\r\nWMI_SET_HOST_SLEEP_MODE_CMD hostSleepMode = {true, false};\r\nar->arWowState = WLAN_WOW_STATE_NONE;\r\nif (wmi_set_host_sleep_mode_cmd(ar->arWmi, &hostSleepMode)!= 0) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Fail to setup restore host awake\n"));\r\n}\r\n#if WOW_SET_SCAN_PARAMS\r\nwmi_scanparams_cmd(ar->arWmi, fg_start_period,\r\nar->scParams.fg_end_period,\r\nbg_period,\r\nar->scParams.minact_chdwell_time,\r\nar->scParams.maxact_chdwell_time,\r\nar->scParams.pas_chdwell_time,\r\nar->scParams.shortScanRatio,\r\nar->scParams.scanCtrlFlags,\r\nar->scParams.max_dfsch_act_time,\r\nar->scParams.maxact_scan_per_ssid);\r\n#else\r\n(void)fg_start_period;\r\n(void)bg_period;\r\n#endif\r\n#if WOW_ENABLE_MAX_INTERVAL\r\nif (wmi_listeninterval_cmd(ar->arWmi, ar->arListenIntervalT, ar->arListenIntervalB) == 0) {\r\n}\r\n#endif\r\nar6k_send_asleep_event_to_app(ar, false);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("Resume WoW successfully\n"));\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("WoW does not invoked. skip resume"));\r\n}\r\nar->arWlanPowerState = WLAN_POWER_STATE_ON;\r\n}\r\nstatic void ar6000_wow_suspend(struct ar6_softc *ar)\r\n{\r\n#define WOW_LIST_ID 1\r\nif (ar->arNetworkType != AP_NETWORK) {\r\nstruct in_ifaddr **ifap = NULL;\r\nstruct in_ifaddr *ifa = NULL;\r\nstruct in_device *in_dev;\r\nu8 macMask[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\r\nint status;\r\nWMI_ADD_WOW_PATTERN_CMD addWowCmd = { .filter = { 0 } };\r\nWMI_DEL_WOW_PATTERN_CMD delWowCmd;\r\nWMI_SET_HOST_SLEEP_MODE_CMD hostSleepMode = {false, true};\r\nWMI_SET_WOW_MODE_CMD wowMode = { .enable_wow = true,\r\n.hostReqDelay = 500 };\r\nif (ar->arWowState!= WLAN_WOW_STATE_NONE) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("System already go into wow mode!\n"));\r\nreturn;\r\n}\r\nar6000_TxDataCleanup(ar);\r\n#if WOW_ENABLE_MAX_INTERVAL\r\nif (wmi_listeninterval_cmd(ar->arWmi, A_MAX_WOW_LISTEN_INTERVAL, 0) == 0) {\r\n}\r\n#endif\r\n#if WOW_SET_SCAN_PARAMS\r\nstatus = wmi_scanparams_cmd(ar->arWmi, 0xFFFF, 0, 0xFFFF, 0, 0, 0, 0, 0, 0, 0);\r\n#endif\r\ndelWowCmd.filter_list_id = WOW_LIST_ID;\r\ndelWowCmd.filter_id = 0;\r\nwmi_del_wow_pattern_cmd(ar->arWmi, &delWowCmd);\r\nif (ar->arNetDev->dev_addr[1]) {\r\naddWowCmd.filter_list_id = WOW_LIST_ID;\r\naddWowCmd.filter_size = 6;\r\naddWowCmd.filter_offset = 0;\r\nstatus = wmi_add_wow_pattern_cmd(ar->arWmi, &addWowCmd, ar->arNetDev->dev_addr, macMask, addWowCmd.filter_size);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Fail to add WoW pattern\n"));\r\n}\r\n}\r\nif ((in_dev = __in_dev_get_rtnl(ar->arNetDev)) != NULL) {\r\nfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL; ifap = &ifa->ifa_next) {\r\nif (!strcmp(ar->arNetDev->name, ifa->ifa_label)) {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (ifa && ifa->ifa_local) {\r\nWMI_SET_IP_CMD ipCmd;\r\nmemset(&ipCmd, 0, sizeof(ipCmd));\r\nipCmd.ips[0] = ifa->ifa_local;\r\nstatus = wmi_set_ip_cmd(ar->arWmi, &ipCmd);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Fail to setup IP for ARP agent\n"));\r\n}\r\n}\r\n#ifndef ATH6K_CONFIG_OTA_MODE\r\nwmi_powermode_cmd(ar->arWmi, REC_POWER);\r\n#endif\r\nstatus = wmi_set_wow_mode_cmd(ar->arWmi, &wowMode);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Fail to enable wow mode\n"));\r\n}\r\nar6k_send_asleep_event_to_app(ar, true);\r\nstatus = wmi_set_host_sleep_mode_cmd(ar->arWmi, &hostSleepMode);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Fail to set host asleep\n"));\r\n}\r\nar->arWowState = WLAN_WOW_STATE_SUSPENDING;\r\nif (ar->arTxPending[ar->arControlEp]) {\r\nu32 timeleft = wait_event_interruptible_timeout(arEvent,\r\nar->arTxPending[ar->arControlEp] == 0, wmitimeout * HZ);\r\nif (!timeleft || signal_pending(current)) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Fail to setup WoW. Pending wmi control data %d\n", ar->arTxPending[ar->arControlEp]));\r\n}\r\n}\r\nstatus = hifWaitForPendingRecv(ar->arHifDevice);\r\nar->arWowState = WLAN_WOW_STATE_SUSPENDED;\r\nar->arWlanPowerState = WLAN_POWER_STATE_WOW;\r\n} else {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Not allowed to go to WOW at this moment.\n"));\r\n}\r\n}\r\nint ar6000_suspend_ev(void *context)\r\n{\r\nint status = 0;\r\nstruct ar6_softc *ar = (struct ar6_softc *)context;\r\ns16 pmmode = ar->arSuspendConfig;\r\nwow_not_connected:\r\nswitch (pmmode) {\r\ncase WLAN_SUSPEND_WOW:\r\nif (ar->arWmiReady && ar->arWlanState==WLAN_ENABLED && ar->arConnected) {\r\nar6000_wow_suspend(ar);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM,("%s:Suspend for wow mode %d\n", __func__, ar->arWlanPowerState));\r\n} else {\r\npmmode = ar->arWow2Config;\r\ngoto wow_not_connected;\r\n}\r\nbreak;\r\ncase WLAN_SUSPEND_CUT_PWR:\r\ncase WLAN_SUSPEND_CUT_PWR_IF_BT_OFF:\r\ncase WLAN_SUSPEND_DEEP_SLEEP:\r\ndefault:\r\nstatus = ar6000_update_wlan_pwr_state(ar, WLAN_DISABLED, true);\r\nif (ar->arWlanPowerState==WLAN_POWER_STATE_ON ||\r\nar->arWlanPowerState==WLAN_POWER_STATE_WOW) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("Strange suspend state for not wow mode %d", ar->arWlanPowerState));\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM,("%s:Suspend for %d mode pwr %d status %d\n", __func__, pmmode, ar->arWlanPowerState, status));\r\nstatus = (ar->arWlanPowerState == WLAN_POWER_STATE_CUT_PWR) ? 0 : A_EBUSY;\r\nbreak;\r\n}\r\nar->scan_triggered = 0;\r\nreturn status;\r\n}\r\nint ar6000_resume_ev(void *context)\r\n{\r\nstruct ar6_softc *ar = (struct ar6_softc *)context;\r\nu16 powerState = ar->arWlanPowerState;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("%s: enter previous state %d wowState %d\n", __func__, powerState, ar->arWowState));\r\nswitch (powerState) {\r\ncase WLAN_POWER_STATE_WOW:\r\nar6000_wow_resume(ar);\r\nbreak;\r\ncase WLAN_POWER_STATE_CUT_PWR:\r\ncase WLAN_POWER_STATE_DEEP_SLEEP:\r\nar6000_update_wlan_pwr_state(ar, WLAN_ENABLED, true);\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM,("%s:Resume for %d mode pwr %d\n", __func__, powerState, ar->arWlanPowerState));\r\nbreak;\r\ncase WLAN_POWER_STATE_ON:\r\nbreak;\r\ndefault:\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Strange SDIO bus power mode!!\n"));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid ar6000_check_wow_status(struct ar6_softc *ar, struct sk_buff *skb, bool isEvent)\r\n{\r\nif (ar->arWowState!=WLAN_WOW_STATE_NONE) {\r\nif (ar->arWowState==WLAN_WOW_STATE_SUSPENDING) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM,("\n%s: Received IRQ while we are wow suspending!!!\n\n", __func__));\r\nreturn;\r\n}\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("%s: WoW resume from irq thread status %d\n", __func__, ar->arWlanPowerState));\r\nar6000_wow_resume(ar);\r\n}\r\n}\r\nint ar6000_power_change_ev(void *context, u32 config)\r\n{\r\nstruct ar6_softc *ar = (struct ar6_softc *)context;\r\nint status = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("%s: power change event callback %d \n", __func__, config));\r\nswitch (config) {\r\ncase HIF_DEVICE_POWER_UP:\r\nar6000_restart_endpoint(ar->arNetDev);\r\nstatus = 0;\r\nbreak;\r\ncase HIF_DEVICE_POWER_DOWN:\r\ncase HIF_DEVICE_POWER_CUT:\r\nstatus = 0;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nint\r\nar6000_setup_cut_power_state(struct ar6_softc *ar, AR6000_WLAN_STATE state)\r\n{\r\nint status = 0;\r\nHIF_DEVICE_POWER_CHANGE_TYPE config;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("%s: Cut power %d %d \n", __func__,state, ar->arWlanPowerState));\r\n#ifdef CONFIG_PM\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("Wlan OFF %d BT OFf %d \n", ar->arWlanOff, ar->arBTOff));\r\n#endif\r\ndo {\r\nif (state == WLAN_ENABLED) {\r\nif (ar->arWlanPowerState != WLAN_POWER_STATE_CUT_PWR) {\r\nbreak;\r\n}\r\nar->arWlanPowerState = WLAN_POWER_STATE_ON;\r\nconfig = HIF_DEVICE_POWER_UP;\r\nstatus = HIFConfigureDevice(ar->arHifDevice,\r\nHIF_DEVICE_POWER_STATE_CHANGE,\r\n&config,\r\nsizeof(HIF_DEVICE_POWER_CHANGE_TYPE));\r\nif (status == A_PENDING) {\r\n} else if (status == 0) {\r\nar6000_restart_endpoint(ar->arNetDev);\r\nstatus = 0;\r\n}\r\n} else if (state == WLAN_DISABLED) {\r\nif (ar->arWlanPowerState == WLAN_POWER_STATE_CUT_PWR) {\r\nbreak;\r\n}\r\nar6000_stop_endpoint(ar->arNetDev, true, false);\r\nconfig = HIF_DEVICE_POWER_CUT;\r\nstatus = HIFConfigureDevice(ar->arHifDevice,\r\nHIF_DEVICE_POWER_STATE_CHANGE,\r\n&config,\r\nsizeof(HIF_DEVICE_POWER_CHANGE_TYPE));\r\nar->arWlanPowerState = WLAN_POWER_STATE_CUT_PWR;\r\n}\r\n} while (0);\r\nreturn status;\r\n}\r\nint\r\nar6000_setup_deep_sleep_state(struct ar6_softc *ar, AR6000_WLAN_STATE state)\r\n{\r\nint status = 0;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("%s: Deep sleep %d %d \n", __func__,state, ar->arWlanPowerState));\r\n#ifdef CONFIG_PM\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("Wlan OFF %d BT OFf %d \n", ar->arWlanOff, ar->arBTOff));\r\n#endif\r\ndo {\r\nWMI_SET_HOST_SLEEP_MODE_CMD hostSleepMode;\r\nif (state == WLAN_ENABLED) {\r\nu16 fg_start_period;\r\nif (ar->arWlanPowerState != WLAN_POWER_STATE_DEEP_SLEEP) {\r\nif (ar->arWlanPowerState != WLAN_POWER_STATE_ON) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Strange state when we resume from deep sleep %d\n", ar->arWlanPowerState));\r\n}\r\nbreak;\r\n}\r\nfg_start_period = (ar->scParams.fg_start_period==0) ? 1 : ar->scParams.fg_start_period;\r\nhostSleepMode.awake = true;\r\nhostSleepMode.asleep = false;\r\nif ((status=wmi_set_host_sleep_mode_cmd(ar->arWmi, &hostSleepMode)) != 0) {\r\nbreak;\r\n}\r\nar->arWlanPowerState = WLAN_POWER_STATE_ON;\r\nif ((status=wmi_scanparams_cmd(ar->arWmi, fg_start_period,\r\nar->scParams.fg_end_period,\r\nar->scParams.bg_period,\r\nar->scParams.minact_chdwell_time,\r\nar->scParams.maxact_chdwell_time,\r\nar->scParams.pas_chdwell_time,\r\nar->scParams.shortScanRatio,\r\nar->scParams.scanCtrlFlags,\r\nar->scParams.max_dfsch_act_time,\r\nar->scParams.maxact_scan_per_ssid)) != 0)\r\n{\r\nbreak;\r\n}\r\nif (ar->arNetworkType != AP_NETWORK)\r\n{\r\nif (ar->arSsidLen) {\r\nif (ar6000_connect_to_ap(ar) != 0) {\r\nbreak;\r\n}\r\n}\r\n}\r\n} else if (state == WLAN_DISABLED){\r\nWMI_SET_WOW_MODE_CMD wowMode = { .enable_wow = false };\r\nif (ar->arWlanPowerState != WLAN_POWER_STATE_ON) {\r\nif (ar->arWlanPowerState != WLAN_POWER_STATE_DEEP_SLEEP) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Strange state when we suspend for deep sleep %d\n", ar->arWlanPowerState));\r\n}\r\nbreak;\r\n}\r\nif (ar->arNetworkType != AP_NETWORK)\r\n{\r\nAR6000_SPIN_LOCK(&ar->arLock, 0);\r\nif (ar->arConnected == true || ar->arConnectPending == true) {\r\nAR6000_SPIN_UNLOCK(&ar->arLock, 0);\r\nwmi_disconnect_cmd(ar->arWmi);\r\n} else {\r\nAR6000_SPIN_UNLOCK(&ar->arLock, 0);\r\n}\r\n}\r\nar->scan_triggered = 0;\r\nif ((status=wmi_scanparams_cmd(ar->arWmi, 0xFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0)) != 0) {\r\nbreak;\r\n}\r\nif ((status=wmi_set_wow_mode_cmd(ar->arWmi, &wowMode))!= 0)\r\n{\r\nbreak;\r\n}\r\nar6000_TxDataCleanup(ar);\r\n#ifndef ATH6K_CONFIG_OTA_MODE\r\nwmi_powermode_cmd(ar->arWmi, REC_POWER);\r\n#endif\r\nhostSleepMode.awake = false;\r\nhostSleepMode.asleep = true;\r\nif ((status=wmi_set_host_sleep_mode_cmd(ar->arWmi, &hostSleepMode))!= 0) {\r\nbreak;\r\n}\r\nif (ar->arTxPending[ar->arControlEp]) {\r\nu32 timeleft = wait_event_interruptible_timeout(arEvent,\r\nar->arTxPending[ar->arControlEp] == 0, wmitimeout * HZ);\r\nif (!timeleft || signal_pending(current)) {\r\nstatus = A_ERROR;\r\nbreak;\r\n}\r\n}\r\nstatus = hifWaitForPendingRecv(ar->arHifDevice);\r\nar->arWlanPowerState = WLAN_POWER_STATE_DEEP_SLEEP;\r\n}\r\n} while (0);\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Fail to enter/exit deep sleep %d\n", state));\r\n}\r\nreturn status;\r\n}\r\nint\r\nar6000_update_wlan_pwr_state(struct ar6_softc *ar, AR6000_WLAN_STATE state, bool pmEvent)\r\n{\r\nint status = 0;\r\nu16 powerState, oldPowerState;\r\nAR6000_WLAN_STATE oldstate = ar->arWlanState;\r\nbool wlanOff = ar->arWlanOff;\r\n#ifdef CONFIG_PM\r\nbool btOff = ar->arBTOff;\r\n#endif\r\nif ((state!=WLAN_DISABLED && state!=WLAN_ENABLED)) {\r\nreturn A_ERROR;\r\n}\r\nif (ar->bIsDestroyProgress) {\r\nreturn A_EBUSY;\r\n}\r\nif (down_interruptible(&ar->arSem)) {\r\nreturn A_ERROR;\r\n}\r\nif (ar->bIsDestroyProgress) {\r\nup(&ar->arSem);\r\nreturn A_EBUSY;\r\n}\r\nar->arWlanState = wlanOff ? WLAN_DISABLED : state;\r\noldPowerState = ar->arWlanPowerState;\r\nif (state == WLAN_ENABLED) {\r\npowerState = ar->arWlanPowerState;\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("WLAN PWR set to ENABLE^^\n"));\r\nif (!wlanOff) {\r\nif (powerState == WLAN_POWER_STATE_DEEP_SLEEP) {\r\nstatus = ar6000_setup_deep_sleep_state(ar, WLAN_ENABLED);\r\n} else if (powerState == WLAN_POWER_STATE_CUT_PWR) {\r\nstatus = ar6000_setup_cut_power_state(ar, WLAN_ENABLED);\r\n}\r\n}\r\n#ifdef CONFIG_PM\r\nelse if (pmEvent && wlanOff) {\r\nbool allowCutPwr = ((!ar->arBTSharing) || btOff);\r\nif ((powerState==WLAN_POWER_STATE_CUT_PWR) && (!allowCutPwr)) {\r\nar6000_setup_cut_power_state(ar, WLAN_ENABLED);\r\nstatus = ar6000_setup_deep_sleep_state(ar, WLAN_DISABLED);\r\n}\r\n}\r\n#endif\r\n} else if (state == WLAN_DISABLED) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("WLAN PWR set to DISABLED~\n"));\r\npowerState = WLAN_POWER_STATE_DEEP_SLEEP;\r\n#ifdef CONFIG_PM\r\nif (pmEvent) {\r\nbool suspendCutPwr = (ar->arSuspendConfig == WLAN_SUSPEND_CUT_PWR ||\r\n(ar->arSuspendConfig == WLAN_SUSPEND_WOW &&\r\nar->arWow2Config==WLAN_SUSPEND_CUT_PWR));\r\nbool suspendCutIfBtOff = ((ar->arSuspendConfig ==\r\nWLAN_SUSPEND_CUT_PWR_IF_BT_OFF ||\r\n(ar->arSuspendConfig == WLAN_SUSPEND_WOW &&\r\nar->arWow2Config==WLAN_SUSPEND_CUT_PWR_IF_BT_OFF)) &&\r\n(!ar->arBTSharing || btOff));\r\nif ((suspendCutPwr) ||\r\n(suspendCutIfBtOff) ||\r\n(ar->arWlanState==WLAN_POWER_STATE_CUT_PWR))\r\n{\r\npowerState = WLAN_POWER_STATE_CUT_PWR;\r\n}\r\n} else {\r\nif ((wlanOff) &&\r\n(ar->arWlanOffConfig == WLAN_OFF_CUT_PWR) &&\r\n(!ar->arBTSharing || btOff))\r\n{\r\npowerState = WLAN_POWER_STATE_CUT_PWR;\r\n}\r\n}\r\n#endif\r\nif (powerState == WLAN_POWER_STATE_DEEP_SLEEP) {\r\nif (ar->arWlanPowerState == WLAN_POWER_STATE_CUT_PWR) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("Load firmware before set to deep sleep\n"));\r\nar6000_setup_cut_power_state(ar, WLAN_ENABLED);\r\n}\r\nstatus = ar6000_setup_deep_sleep_state(ar, WLAN_DISABLED);\r\n} else if (powerState == WLAN_POWER_STATE_CUT_PWR) {\r\nstatus = ar6000_setup_cut_power_state(ar, WLAN_DISABLED);\r\n}\r\n}\r\nif (status) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Fail to setup WLAN state %d\n", ar->arWlanState));\r\nar->arWlanState = oldstate;\r\n} else if (status == 0) {\r\nWMI_REPORT_SLEEP_STATE_EVENT wmiSleepEvent, *pSleepEvent = NULL;\r\nif ((ar->arWlanPowerState == WLAN_POWER_STATE_ON) && (oldPowerState != WLAN_POWER_STATE_ON)) {\r\nwmiSleepEvent.sleepState = WMI_REPORT_SLEEP_STATUS_IS_AWAKE;\r\npSleepEvent = &wmiSleepEvent;\r\n} else if ((ar->arWlanPowerState != WLAN_POWER_STATE_ON) && (oldPowerState == WLAN_POWER_STATE_ON)) {\r\nwmiSleepEvent.sleepState = WMI_REPORT_SLEEP_STATUS_IS_DEEP_SLEEP;\r\npSleepEvent = &wmiSleepEvent;\r\n}\r\nif (pSleepEvent) {\r\nAR_DEBUG_PRINTF(ATH_DEBUG_PM, ("SENT WLAN Sleep Event %d\n", wmiSleepEvent.sleepState));\r\n}\r\n}\r\nup(&ar->arSem);\r\nreturn status;\r\n}\r\nint\r\nar6000_set_bt_hw_state(struct ar6_softc *ar, u32 enable)\r\n{\r\n#ifdef CONFIG_PM\r\nbool off = (enable == 0);\r\nint status;\r\nif (ar->arBTOff == off) {\r\nreturn 0;\r\n}\r\nar->arBTOff = off;\r\nstatus = ar6000_update_wlan_pwr_state(ar, ar->arWlanOff ? WLAN_DISABLED : WLAN_ENABLED, false);\r\nreturn status;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nint\r\nar6000_set_wlan_state(struct ar6_softc *ar, AR6000_WLAN_STATE state)\r\n{\r\nint status;\r\nbool off = (state == WLAN_DISABLED);\r\nif (ar->arWlanOff == off) {\r\nreturn 0;\r\n}\r\nar->arWlanOff = off;\r\nstatus = ar6000_update_wlan_pwr_state(ar, state, false);\r\nreturn status;\r\n}
