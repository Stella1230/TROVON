static void sa1100_set_vpp(struct map_info *map, int on)\r\n{\r\nstruct sa_subdev_info *subdev = container_of(map, struct sa_subdev_info, map);\r\nsubdev->plat->set_vpp(on);\r\n}\r\nstatic void sa1100_destroy_subdev(struct sa_subdev_info *subdev)\r\n{\r\nif (subdev->mtd)\r\nmap_destroy(subdev->mtd);\r\nif (subdev->map.virt)\r\niounmap(subdev->map.virt);\r\nrelease_mem_region(subdev->map.phys, subdev->map.size);\r\n}\r\nstatic int sa1100_probe_subdev(struct sa_subdev_info *subdev, struct resource *res)\r\n{\r\nunsigned long phys;\r\nunsigned int size;\r\nint ret;\r\nphys = res->start;\r\nsize = res->end - phys + 1;\r\nswitch (phys) {\r\ndefault:\r\nprintk(KERN_WARNING "SA1100 flash: unknown base address "\r\n"0x%08lx, assuming CS0\n", phys);\r\ncase SA1100_CS0_PHYS:\r\nsubdev->map.bankwidth = (MSC0 & MSC_RBW) ? 2 : 4;\r\nbreak;\r\ncase SA1100_CS1_PHYS:\r\nsubdev->map.bankwidth = ((MSC0 >> 16) & MSC_RBW) ? 2 : 4;\r\nbreak;\r\n}\r\nif (!request_mem_region(phys, size, subdev->name)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (subdev->plat->set_vpp)\r\nsubdev->map.set_vpp = sa1100_set_vpp;\r\nsubdev->map.phys = phys;\r\nsubdev->map.size = size;\r\nsubdev->map.virt = ioremap(phys, size);\r\nif (!subdev->map.virt) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsimple_map_init(&subdev->map);\r\nsubdev->mtd = do_map_probe(subdev->plat->map_name, &subdev->map);\r\nif (subdev->mtd == NULL) {\r\nret = -ENXIO;\r\ngoto err;\r\n}\r\nsubdev->mtd->owner = THIS_MODULE;\r\nprintk(KERN_INFO "SA1100 flash: CFI device at 0x%08lx, %uMiB, %d-bit\n",\r\nphys, (unsigned)(subdev->mtd->size >> 20),\r\nsubdev->map.bankwidth * 8);\r\nreturn 0;\r\nerr:\r\nsa1100_destroy_subdev(subdev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void sa1100_destroy(struct sa_info *info, struct flash_platform_data *plat)\r\n{\r\nint i;\r\nif (info->mtd) {\r\nmtd_device_unregister(info->mtd);\r\nif (info->mtd != info->subdev[0].mtd)\r\nmtd_concat_destroy(info->mtd);\r\n}\r\nkfree(info->parts);\r\nfor (i = info->num_subdev - 1; i >= 0; i--)\r\nsa1100_destroy_subdev(&info->subdev[i]);\r\nkfree(info);\r\nif (plat->exit)\r\nplat->exit();\r\n}\r\nstatic struct sa_info *__devinit\r\nsa1100_setup_mtd(struct platform_device *pdev, struct flash_platform_data *plat)\r\n{\r\nstruct sa_info *info;\r\nint nr, size, i, ret = 0;\r\nfor (nr = 0; ; nr++)\r\nif (!platform_get_resource(pdev, IORESOURCE_MEM, nr))\r\nbreak;\r\nif (nr == 0) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsize = sizeof(struct sa_info) + sizeof(struct sa_subdev_info) * nr;\r\ninfo = kzalloc(size, GFP_KERNEL);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (plat->init) {\r\nret = plat->init();\r\nif (ret)\r\ngoto err;\r\n}\r\nfor (i = 0; i < nr; i++) {\r\nstruct sa_subdev_info *subdev = &info->subdev[i];\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res)\r\nbreak;\r\nsubdev->map.name = subdev->name;\r\nsprintf(subdev->name, "%s-%d", plat->name, i);\r\nsubdev->plat = plat;\r\nret = sa1100_probe_subdev(subdev, res);\r\nif (ret)\r\nbreak;\r\n}\r\ninfo->num_subdev = i;\r\nif (ret != 0 && !(ret == -ENXIO && info->num_subdev > 0))\r\ngoto err;\r\nif (info->num_subdev == 1) {\r\nstrcpy(info->subdev[0].name, plat->name);\r\ninfo->mtd = info->subdev[0].mtd;\r\nret = 0;\r\n} else if (info->num_subdev > 1) {\r\nstruct mtd_info *cdev[nr];\r\nfor (i = 0; i < info->num_subdev; i++)\r\ncdev[i] = info->subdev[i].mtd;\r\ninfo->mtd = mtd_concat_create(cdev, info->num_subdev,\r\nplat->name);\r\nif (info->mtd == NULL)\r\nret = -ENXIO;\r\n}\r\nif (ret == 0)\r\nreturn info;\r\nerr:\r\nsa1100_destroy(info, plat);\r\nout:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int __devinit sa1100_mtd_probe(struct platform_device *pdev)\r\n{\r\nstruct flash_platform_data *plat = pdev->dev.platform_data;\r\nstruct mtd_partition *parts;\r\nconst char *part_type = NULL;\r\nstruct sa_info *info;\r\nint err, nr_parts = 0;\r\nif (!plat)\r\nreturn -ENODEV;\r\ninfo = sa1100_setup_mtd(pdev, plat);\r\nif (IS_ERR(info)) {\r\nerr = PTR_ERR(info);\r\ngoto out;\r\n}\r\nnr_parts = parse_mtd_partitions(info->mtd, part_probes, &parts, 0);\r\nif (nr_parts > 0) {\r\ninfo->parts = parts;\r\npart_type = "dynamic";\r\n} else {\r\nparts = plat->parts;\r\nnr_parts = plat->nr_parts;\r\npart_type = "static";\r\n}\r\nif (nr_parts == 0)\r\nprintk(KERN_NOTICE "SA1100 flash: no partition info "\r\n"available, registering whole flash\n");\r\nelse\r\nprintk(KERN_NOTICE "SA1100 flash: using %s partition "\r\n"definition\n", part_type);\r\nmtd_device_register(info->mtd, parts, nr_parts);\r\ninfo->nr_parts = nr_parts;\r\nplatform_set_drvdata(pdev, info);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int __exit sa1100_mtd_remove(struct platform_device *pdev)\r\n{\r\nstruct sa_info *info = platform_get_drvdata(pdev);\r\nstruct flash_platform_data *plat = pdev->dev.platform_data;\r\nplatform_set_drvdata(pdev, NULL);\r\nsa1100_destroy(info, plat);\r\nreturn 0;\r\n}\r\nstatic void sa1100_mtd_shutdown(struct platform_device *dev)\r\n{\r\nstruct sa_info *info = platform_get_drvdata(dev);\r\nif (info && info->mtd->suspend(info->mtd) == 0)\r\ninfo->mtd->resume(info->mtd);\r\n}\r\nstatic int __init sa1100_mtd_init(void)\r\n{\r\nreturn platform_driver_register(&sa1100_mtd_driver);\r\n}\r\nstatic void __exit sa1100_mtd_exit(void)\r\n{\r\nplatform_driver_unregister(&sa1100_mtd_driver);\r\n}
