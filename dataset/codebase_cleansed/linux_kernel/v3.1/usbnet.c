int usbnet_get_endpoints(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint tmp;\r\nstruct usb_host_interface *alt = NULL;\r\nstruct usb_host_endpoint *in = NULL, *out = NULL;\r\nstruct usb_host_endpoint *status = NULL;\r\nfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\r\nunsigned ep;\r\nin = out = status = NULL;\r\nalt = intf->altsetting + tmp;\r\nfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\r\nstruct usb_host_endpoint *e;\r\nint intr = 0;\r\ne = alt->endpoint + ep;\r\nswitch (e->desc.bmAttributes) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (!usb_endpoint_dir_in(&e->desc))\r\ncontinue;\r\nintr = 1;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (usb_endpoint_dir_in(&e->desc)) {\r\nif (!intr && !in)\r\nin = e;\r\nelse if (intr && !status)\r\nstatus = e;\r\n} else {\r\nif (!out)\r\nout = e;\r\n}\r\n}\r\nif (in && out)\r\nbreak;\r\n}\r\nif (!alt || !in || !out)\r\nreturn -EINVAL;\r\nif (alt->desc.bAlternateSetting != 0 ||\r\n!(dev->driver_info->flags & FLAG_NO_SETINT)) {\r\ntmp = usb_set_interface (dev->udev, alt->desc.bInterfaceNumber,\r\nalt->desc.bAlternateSetting);\r\nif (tmp < 0)\r\nreturn tmp;\r\n}\r\ndev->in = usb_rcvbulkpipe (dev->udev,\r\nin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\ndev->out = usb_sndbulkpipe (dev->udev,\r\nout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\ndev->status = status;\r\nreturn 0;\r\n}\r\nint usbnet_get_ethernet_addr(struct usbnet *dev, int iMACAddress)\r\n{\r\nint tmp, i;\r\nunsigned char buf [13];\r\ntmp = usb_string(dev->udev, iMACAddress, buf, sizeof buf);\r\nif (tmp != 12) {\r\ndev_dbg(&dev->udev->dev,\r\n"bad MAC string %d fetch, %d\n", iMACAddress, tmp);\r\nif (tmp >= 0)\r\ntmp = -EINVAL;\r\nreturn tmp;\r\n}\r\nfor (i = tmp = 0; i < 6; i++, tmp += 2)\r\ndev->net->dev_addr [i] =\r\n(hex_to_bin(buf[tmp]) << 4) + hex_to_bin(buf[tmp + 1]);\r\nreturn 0;\r\n}\r\nstatic int init_status (struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nchar *buf = NULL;\r\nunsigned pipe = 0;\r\nunsigned maxp;\r\nunsigned period;\r\nif (!dev->driver_info->status)\r\nreturn 0;\r\npipe = usb_rcvintpipe (dev->udev,\r\ndev->status->desc.bEndpointAddress\r\n& USB_ENDPOINT_NUMBER_MASK);\r\nmaxp = usb_maxpacket (dev->udev, pipe, 0);\r\nperiod = max ((int) dev->status->desc.bInterval,\r\n(dev->udev->speed == USB_SPEED_HIGH) ? 7 : 3);\r\nbuf = kmalloc (maxp, GFP_KERNEL);\r\nif (buf) {\r\ndev->interrupt = usb_alloc_urb (0, GFP_KERNEL);\r\nif (!dev->interrupt) {\r\nkfree (buf);\r\nreturn -ENOMEM;\r\n} else {\r\nusb_fill_int_urb(dev->interrupt, dev->udev, pipe,\r\nbuf, maxp, intr_complete, dev, period);\r\ndev_dbg(&intf->dev,\r\n"status ep%din, %d bytes period %d\n",\r\nusb_pipeendpoint(pipe), maxp, period);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid usbnet_skb_return (struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nint status;\r\nif (test_bit(EVENT_RX_PAUSED, &dev->flags)) {\r\nskb_queue_tail(&dev->rxq_pause, skb);\r\nreturn;\r\n}\r\nskb->protocol = eth_type_trans (skb, dev->net);\r\ndev->net->stats.rx_packets++;\r\ndev->net->stats.rx_bytes += skb->len;\r\nnetif_dbg(dev, rx_status, dev->net, "< rx, len %zu, type 0x%x\n",\r\nskb->len + sizeof (struct ethhdr), skb->protocol);\r\nmemset (skb->cb, 0, sizeof (struct skb_data));\r\nstatus = netif_rx (skb);\r\nif (status != NET_RX_SUCCESS)\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"netif_rx status %d\n", status);\r\n}\r\nint usbnet_change_mtu (struct net_device *net, int new_mtu)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint ll_mtu = new_mtu + net->hard_header_len;\r\nint old_hard_mtu = dev->hard_mtu;\r\nint old_rx_urb_size = dev->rx_urb_size;\r\nif (new_mtu <= 0)\r\nreturn -EINVAL;\r\nif ((ll_mtu % dev->maxpacket) == 0)\r\nreturn -EDOM;\r\nnet->mtu = new_mtu;\r\ndev->hard_mtu = net->mtu + net->hard_header_len;\r\nif (dev->rx_urb_size == old_hard_mtu) {\r\ndev->rx_urb_size = dev->hard_mtu;\r\nif (dev->rx_urb_size > old_rx_urb_size)\r\nusbnet_unlink_rx_urbs(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void defer_bh(struct usbnet *dev, struct sk_buff *skb, struct sk_buff_head *list)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&list->lock, flags);\r\n__skb_unlink(skb, list);\r\nspin_unlock(&list->lock);\r\nspin_lock(&dev->done.lock);\r\n__skb_queue_tail(&dev->done, skb);\r\nif (dev->done.qlen == 1)\r\ntasklet_schedule(&dev->bh);\r\nspin_unlock_irqrestore(&dev->done.lock, flags);\r\n}\r\nvoid usbnet_defer_kevent (struct usbnet *dev, int work)\r\n{\r\nset_bit (work, &dev->flags);\r\nif (!schedule_work (&dev->kevent))\r\nnetdev_err(dev->net, "kevent %d may have been dropped\n", work);\r\nelse\r\nnetdev_dbg(dev->net, "kevent %d scheduled\n", work);\r\n}\r\nstatic int rx_submit (struct usbnet *dev, struct urb *urb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb;\r\nstruct skb_data *entry;\r\nint retval = 0;\r\nunsigned long lockflags;\r\nsize_t size = dev->rx_urb_size;\r\nif ((skb = alloc_skb (size + NET_IP_ALIGN, flags)) == NULL) {\r\nnetif_dbg(dev, rx_err, dev->net, "no rx skb\n");\r\nusbnet_defer_kevent (dev, EVENT_RX_MEMORY);\r\nusb_free_urb (urb);\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve (skb, NET_IP_ALIGN);\r\nentry = (struct skb_data *) skb->cb;\r\nentry->urb = urb;\r\nentry->dev = dev;\r\nentry->state = rx_start;\r\nentry->length = 0;\r\nusb_fill_bulk_urb (urb, dev->udev, dev->in,\r\nskb->data, size, rx_complete, skb);\r\nspin_lock_irqsave (&dev->rxq.lock, lockflags);\r\nif (netif_running (dev->net) &&\r\nnetif_device_present (dev->net) &&\r\n!test_bit (EVENT_RX_HALT, &dev->flags) &&\r\n!test_bit (EVENT_DEV_ASLEEP, &dev->flags)) {\r\nswitch (retval = usb_submit_urb (urb, GFP_ATOMIC)) {\r\ncase -EPIPE:\r\nusbnet_defer_kevent (dev, EVENT_RX_HALT);\r\nbreak;\r\ncase -ENOMEM:\r\nusbnet_defer_kevent (dev, EVENT_RX_MEMORY);\r\nbreak;\r\ncase -ENODEV:\r\nnetif_dbg(dev, ifdown, dev->net, "device gone\n");\r\nnetif_device_detach (dev->net);\r\nbreak;\r\ncase -EHOSTUNREACH:\r\nretval = -ENOLINK;\r\nbreak;\r\ndefault:\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"rx submit, %d\n", retval);\r\ntasklet_schedule (&dev->bh);\r\nbreak;\r\ncase 0:\r\n__skb_queue_tail (&dev->rxq, skb);\r\n}\r\n} else {\r\nnetif_dbg(dev, ifdown, dev->net, "rx: stopped\n");\r\nretval = -ENOLINK;\r\n}\r\nspin_unlock_irqrestore (&dev->rxq.lock, lockflags);\r\nif (retval) {\r\ndev_kfree_skb_any (skb);\r\nusb_free_urb (urb);\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void rx_process (struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nif (dev->driver_info->rx_fixup &&\r\n!dev->driver_info->rx_fixup (dev, skb)) {\r\nif (!(dev->driver_info->flags & FLAG_RX_ASSEMBLE))\r\ndev->net->stats.rx_errors++;\r\ngoto done;\r\n}\r\nif (skb->len) {\r\nif (dev->driver_info->flags & FLAG_MULTI_PACKET)\r\ndev_kfree_skb_any(skb);\r\nelse\r\nusbnet_skb_return(dev, skb);\r\nreturn;\r\n}\r\nnetif_dbg(dev, rx_err, dev->net, "drop\n");\r\ndev->net->stats.rx_errors++;\r\ndone:\r\nskb_queue_tail(&dev->done, skb);\r\n}\r\nstatic void rx_complete (struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct skb_data *entry = (struct skb_data *) skb->cb;\r\nstruct usbnet *dev = entry->dev;\r\nint urb_status = urb->status;\r\nskb_put (skb, urb->actual_length);\r\nentry->state = rx_done;\r\nentry->urb = NULL;\r\nswitch (urb_status) {\r\ncase 0:\r\nif (skb->len < dev->net->hard_header_len) {\r\nentry->state = rx_cleanup;\r\ndev->net->stats.rx_errors++;\r\ndev->net->stats.rx_length_errors++;\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"rx length %d\n", skb->len);\r\n}\r\nbreak;\r\ncase -EPIPE:\r\ndev->net->stats.rx_errors++;\r\nusbnet_defer_kevent (dev, EVENT_RX_HALT);\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nnetif_dbg(dev, ifdown, dev->net,\r\n"rx shutdown, code %d\n", urb_status);\r\ngoto block;\r\ncase -EPROTO:\r\ncase -ETIME:\r\ncase -EILSEQ:\r\ndev->net->stats.rx_errors++;\r\nif (!timer_pending (&dev->delay)) {\r\nmod_timer (&dev->delay, jiffies + THROTTLE_JIFFIES);\r\nnetif_dbg(dev, link, dev->net,\r\n"rx throttle %d\n", urb_status);\r\n}\r\nblock:\r\nentry->state = rx_cleanup;\r\nentry->urb = urb;\r\nurb = NULL;\r\nbreak;\r\ncase -EOVERFLOW:\r\ndev->net->stats.rx_over_errors++;\r\ndefault:\r\nentry->state = rx_cleanup;\r\ndev->net->stats.rx_errors++;\r\nnetif_dbg(dev, rx_err, dev->net, "rx status %d\n", urb_status);\r\nbreak;\r\n}\r\ndefer_bh(dev, skb, &dev->rxq);\r\nif (urb) {\r\nif (netif_running (dev->net) &&\r\n!test_bit (EVENT_RX_HALT, &dev->flags)) {\r\nrx_submit (dev, urb, GFP_ATOMIC);\r\nreturn;\r\n}\r\nusb_free_urb (urb);\r\n}\r\nnetif_dbg(dev, rx_err, dev->net, "no read resubmitted\n");\r\n}\r\nstatic void intr_complete (struct urb *urb)\r\n{\r\nstruct usbnet *dev = urb->context;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\ndev->driver_info->status(dev, urb);\r\nbreak;\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nnetif_dbg(dev, ifdown, dev->net,\r\n"intr shutdown, code %d\n", status);\r\nreturn;\r\ndefault:\r\nnetdev_dbg(dev->net, "intr status %d\n", status);\r\nbreak;\r\n}\r\nif (!netif_running (dev->net))\r\nreturn;\r\nmemset(urb->transfer_buffer, 0, urb->transfer_buffer_length);\r\nstatus = usb_submit_urb (urb, GFP_ATOMIC);\r\nif (status != 0)\r\nnetif_err(dev, timer, dev->net,\r\n"intr resubmit --> %d\n", status);\r\n}\r\nvoid usbnet_pause_rx(struct usbnet *dev)\r\n{\r\nset_bit(EVENT_RX_PAUSED, &dev->flags);\r\nnetif_dbg(dev, rx_status, dev->net, "paused rx queue enabled\n");\r\n}\r\nvoid usbnet_resume_rx(struct usbnet *dev)\r\n{\r\nstruct sk_buff *skb;\r\nint num = 0;\r\nclear_bit(EVENT_RX_PAUSED, &dev->flags);\r\nwhile ((skb = skb_dequeue(&dev->rxq_pause)) != NULL) {\r\nusbnet_skb_return(dev, skb);\r\nnum++;\r\n}\r\ntasklet_schedule(&dev->bh);\r\nnetif_dbg(dev, rx_status, dev->net,\r\n"paused rx queue disabled, %d skbs requeued\n", num);\r\n}\r\nvoid usbnet_purge_paused_rxq(struct usbnet *dev)\r\n{\r\nskb_queue_purge(&dev->rxq_pause);\r\n}\r\nstatic int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb, *skbnext;\r\nint count = 0;\r\nspin_lock_irqsave (&q->lock, flags);\r\nskb_queue_walk_safe(q, skb, skbnext) {\r\nstruct skb_data *entry;\r\nstruct urb *urb;\r\nint retval;\r\nentry = (struct skb_data *) skb->cb;\r\nurb = entry->urb;\r\nretval = usb_unlink_urb (urb);\r\nif (retval != -EINPROGRESS && retval != 0)\r\nnetdev_dbg(dev->net, "unlink urb err, %d\n", retval);\r\nelse\r\ncount++;\r\n}\r\nspin_unlock_irqrestore (&q->lock, flags);\r\nreturn count;\r\n}\r\nvoid usbnet_unlink_rx_urbs(struct usbnet *dev)\r\n{\r\nif (netif_running(dev->net)) {\r\n(void) unlink_urbs (dev, &dev->rxq);\r\ntasklet_schedule(&dev->bh);\r\n}\r\n}\r\nstatic void usbnet_terminate_urbs(struct usbnet *dev)\r\n{\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(unlink_wakeup);\r\nDECLARE_WAITQUEUE(wait, current);\r\nint temp;\r\nadd_wait_queue(&unlink_wakeup, &wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\ndev->wait = &unlink_wakeup;\r\ntemp = unlink_urbs(dev, &dev->txq) +\r\nunlink_urbs(dev, &dev->rxq);\r\nwhile (!skb_queue_empty(&dev->rxq)\r\n&& !skb_queue_empty(&dev->txq)\r\n&& !skb_queue_empty(&dev->done)) {\r\nschedule_timeout(msecs_to_jiffies(UNLINK_TIMEOUT_MS));\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nnetif_dbg(dev, ifdown, dev->net,\r\n"waited for %d urb completions\n", temp);\r\n}\r\nset_current_state(TASK_RUNNING);\r\ndev->wait = NULL;\r\nremove_wait_queue(&unlink_wakeup, &wait);\r\n}\r\nint usbnet_stop (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct driver_info *info = dev->driver_info;\r\nint retval;\r\nclear_bit(EVENT_DEV_OPEN, &dev->flags);\r\nnetif_stop_queue (net);\r\nnetif_info(dev, ifdown, dev->net,\r\n"stop stats: rx/tx %lu/%lu, errs %lu/%lu\n",\r\nnet->stats.rx_packets, net->stats.tx_packets,\r\nnet->stats.rx_errors, net->stats.tx_errors);\r\nif (info->stop) {\r\nretval = info->stop(dev);\r\nif (retval < 0)\r\nnetif_info(dev, ifdown, dev->net,\r\n"stop fail (%d) usbnet usb-%s-%s, %s\n",\r\nretval,\r\ndev->udev->bus->bus_name, dev->udev->devpath,\r\ninfo->description);\r\n}\r\nif (!(info->flags & FLAG_AVOID_UNLINK_URBS))\r\nusbnet_terminate_urbs(dev);\r\nusb_kill_urb(dev->interrupt);\r\nusbnet_purge_paused_rxq(dev);\r\ndev->flags = 0;\r\ndel_timer_sync (&dev->delay);\r\ntasklet_kill (&dev->bh);\r\nif (info->manage_power)\r\ninfo->manage_power(dev, 0);\r\nelse\r\nusb_autopm_put_interface(dev->intf);\r\nreturn 0;\r\n}\r\nint usbnet_open (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint retval;\r\nstruct driver_info *info = dev->driver_info;\r\nif ((retval = usb_autopm_get_interface(dev->intf)) < 0) {\r\nnetif_info(dev, ifup, dev->net,\r\n"resumption fail (%d) usbnet usb-%s-%s, %s\n",\r\nretval,\r\ndev->udev->bus->bus_name,\r\ndev->udev->devpath,\r\ninfo->description);\r\ngoto done_nopm;\r\n}\r\nif (info->reset && (retval = info->reset (dev)) < 0) {\r\nnetif_info(dev, ifup, dev->net,\r\n"open reset fail (%d) usbnet usb-%s-%s, %s\n",\r\nretval,\r\ndev->udev->bus->bus_name,\r\ndev->udev->devpath,\r\ninfo->description);\r\ngoto done;\r\n}\r\nif (info->check_connect && (retval = info->check_connect (dev)) < 0) {\r\nnetif_dbg(dev, ifup, dev->net, "can't open; %d\n", retval);\r\ngoto done;\r\n}\r\nif (dev->interrupt) {\r\nretval = usb_submit_urb (dev->interrupt, GFP_KERNEL);\r\nif (retval < 0) {\r\nnetif_err(dev, ifup, dev->net,\r\n"intr submit %d\n", retval);\r\ngoto done;\r\n}\r\n}\r\nset_bit(EVENT_DEV_OPEN, &dev->flags);\r\nnetif_start_queue (net);\r\nnetif_info(dev, ifup, dev->net,\r\n"open: enable queueing (rx %d, tx %d) mtu %d %s framing\n",\r\n(int)RX_QLEN(dev), (int)TX_QLEN(dev),\r\ndev->net->mtu,\r\n(dev->driver_info->flags & FLAG_FRAMING_NC) ? "NetChip" :\r\n(dev->driver_info->flags & FLAG_FRAMING_GL) ? "GeneSys" :\r\n(dev->driver_info->flags & FLAG_FRAMING_Z) ? "Zaurus" :\r\n(dev->driver_info->flags & FLAG_FRAMING_RN) ? "RNDIS" :\r\n(dev->driver_info->flags & FLAG_FRAMING_AX) ? "ASIX" :\r\n"simple");\r\ntasklet_schedule (&dev->bh);\r\nif (info->manage_power) {\r\nretval = info->manage_power(dev, 1);\r\nif (retval < 0)\r\ngoto done;\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\nreturn retval;\r\ndone:\r\nusb_autopm_put_interface(dev->intf);\r\ndone_nopm:\r\nreturn retval;\r\n}\r\nint usbnet_get_settings (struct net_device *net, struct ethtool_cmd *cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nif (!dev->mii.mdio_read)\r\nreturn -EOPNOTSUPP;\r\nreturn mii_ethtool_gset(&dev->mii, cmd);\r\n}\r\nint usbnet_set_settings (struct net_device *net, struct ethtool_cmd *cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint retval;\r\nif (!dev->mii.mdio_write)\r\nreturn -EOPNOTSUPP;\r\nretval = mii_ethtool_sset(&dev->mii, cmd);\r\nif (dev->driver_info->link_reset)\r\ndev->driver_info->link_reset(dev);\r\nreturn retval;\r\n}\r\nu32 usbnet_get_link (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nif (dev->driver_info->check_connect)\r\nreturn dev->driver_info->check_connect (dev) == 0;\r\nif (dev->mii.mdio_read)\r\nreturn mii_link_ok(&dev->mii);\r\nreturn ethtool_op_get_link(net);\r\n}\r\nint usbnet_nway_reset(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nif (!dev->mii.mdio_write)\r\nreturn -EOPNOTSUPP;\r\nreturn mii_nway_restart(&dev->mii);\r\n}\r\nvoid usbnet_get_drvinfo (struct net_device *net, struct ethtool_drvinfo *info)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstrncpy (info->driver, dev->driver_name, sizeof info->driver);\r\nstrncpy (info->version, DRIVER_VERSION, sizeof info->version);\r\nstrncpy (info->fw_version, dev->driver_info->description,\r\nsizeof info->fw_version);\r\nusb_make_path (dev->udev, info->bus_info, sizeof info->bus_info);\r\n}\r\nu32 usbnet_get_msglevel (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn dev->msg_enable;\r\n}\r\nvoid usbnet_set_msglevel (struct net_device *net, u32 level)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\ndev->msg_enable = level;\r\n}\r\nstatic void\r\nkevent (struct work_struct *work)\r\n{\r\nstruct usbnet *dev =\r\ncontainer_of(work, struct usbnet, kevent);\r\nint status;\r\nif (test_bit (EVENT_TX_HALT, &dev->flags)) {\r\nunlink_urbs (dev, &dev->txq);\r\nstatus = usb_autopm_get_interface(dev->intf);\r\nif (status < 0)\r\ngoto fail_pipe;\r\nstatus = usb_clear_halt (dev->udev, dev->out);\r\nusb_autopm_put_interface(dev->intf);\r\nif (status < 0 &&\r\nstatus != -EPIPE &&\r\nstatus != -ESHUTDOWN) {\r\nif (netif_msg_tx_err (dev))\r\nfail_pipe:\r\nnetdev_err(dev->net, "can't clear tx halt, status %d\n",\r\nstatus);\r\n} else {\r\nclear_bit (EVENT_TX_HALT, &dev->flags);\r\nif (status != -ESHUTDOWN)\r\nnetif_wake_queue (dev->net);\r\n}\r\n}\r\nif (test_bit (EVENT_RX_HALT, &dev->flags)) {\r\nunlink_urbs (dev, &dev->rxq);\r\nstatus = usb_autopm_get_interface(dev->intf);\r\nif (status < 0)\r\ngoto fail_halt;\r\nstatus = usb_clear_halt (dev->udev, dev->in);\r\nusb_autopm_put_interface(dev->intf);\r\nif (status < 0 &&\r\nstatus != -EPIPE &&\r\nstatus != -ESHUTDOWN) {\r\nif (netif_msg_rx_err (dev))\r\nfail_halt:\r\nnetdev_err(dev->net, "can't clear rx halt, status %d\n",\r\nstatus);\r\n} else {\r\nclear_bit (EVENT_RX_HALT, &dev->flags);\r\ntasklet_schedule (&dev->bh);\r\n}\r\n}\r\nif (test_bit (EVENT_RX_MEMORY, &dev->flags)) {\r\nstruct urb *urb = NULL;\r\nint resched = 1;\r\nif (netif_running (dev->net))\r\nurb = usb_alloc_urb (0, GFP_KERNEL);\r\nelse\r\nclear_bit (EVENT_RX_MEMORY, &dev->flags);\r\nif (urb != NULL) {\r\nclear_bit (EVENT_RX_MEMORY, &dev->flags);\r\nstatus = usb_autopm_get_interface(dev->intf);\r\nif (status < 0) {\r\nusb_free_urb(urb);\r\ngoto fail_lowmem;\r\n}\r\nif (rx_submit (dev, urb, GFP_KERNEL) == -ENOLINK)\r\nresched = 0;\r\nusb_autopm_put_interface(dev->intf);\r\nfail_lowmem:\r\nif (resched)\r\ntasklet_schedule (&dev->bh);\r\n}\r\n}\r\nif (test_bit (EVENT_LINK_RESET, &dev->flags)) {\r\nstruct driver_info *info = dev->driver_info;\r\nint retval = 0;\r\nclear_bit (EVENT_LINK_RESET, &dev->flags);\r\nstatus = usb_autopm_get_interface(dev->intf);\r\nif (status < 0)\r\ngoto skip_reset;\r\nif(info->link_reset && (retval = info->link_reset(dev)) < 0) {\r\nusb_autopm_put_interface(dev->intf);\r\nskip_reset:\r\nnetdev_info(dev->net, "link reset failed (%d) usbnet usb-%s-%s, %s\n",\r\nretval,\r\ndev->udev->bus->bus_name,\r\ndev->udev->devpath,\r\ninfo->description);\r\n} else {\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\n}\r\nif (dev->flags)\r\nnetdev_dbg(dev->net, "kevent done, flags = 0x%lx\n", dev->flags);\r\n}\r\nstatic void tx_complete (struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct skb_data *entry = (struct skb_data *) skb->cb;\r\nstruct usbnet *dev = entry->dev;\r\nif (urb->status == 0) {\r\nif (!(dev->driver_info->flags & FLAG_MULTI_PACKET))\r\ndev->net->stats.tx_packets++;\r\ndev->net->stats.tx_bytes += entry->length;\r\n} else {\r\ndev->net->stats.tx_errors++;\r\nswitch (urb->status) {\r\ncase -EPIPE:\r\nusbnet_defer_kevent (dev, EVENT_TX_HALT);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ncase -EPROTO:\r\ncase -ETIME:\r\ncase -EILSEQ:\r\nusb_mark_last_busy(dev->udev);\r\nif (!timer_pending (&dev->delay)) {\r\nmod_timer (&dev->delay,\r\njiffies + THROTTLE_JIFFIES);\r\nnetif_dbg(dev, link, dev->net,\r\n"tx throttle %d\n", urb->status);\r\n}\r\nnetif_stop_queue (dev->net);\r\nbreak;\r\ndefault:\r\nnetif_dbg(dev, tx_err, dev->net,\r\n"tx err %d\n", entry->urb->status);\r\nbreak;\r\n}\r\n}\r\nusb_autopm_put_interface_async(dev->intf);\r\nurb->dev = NULL;\r\nentry->state = tx_done;\r\ndefer_bh(dev, skb, &dev->txq);\r\n}\r\nvoid usbnet_tx_timeout (struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nunlink_urbs (dev, &dev->txq);\r\ntasklet_schedule (&dev->bh);\r\n}\r\nnetdev_tx_t usbnet_start_xmit (struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint length;\r\nstruct urb *urb = NULL;\r\nstruct skb_data *entry;\r\nstruct driver_info *info = dev->driver_info;\r\nunsigned long flags;\r\nint retval;\r\nif (info->tx_fixup) {\r\nskb = info->tx_fixup (dev, skb, GFP_ATOMIC);\r\nif (!skb) {\r\nif (netif_msg_tx_err(dev)) {\r\nnetif_dbg(dev, tx_err, dev->net, "can't tx_fixup skb\n");\r\ngoto drop;\r\n} else {\r\ngoto not_drop;\r\n}\r\n}\r\n}\r\nlength = skb->len;\r\nif (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {\r\nnetif_dbg(dev, tx_err, dev->net, "no urb\n");\r\ngoto drop;\r\n}\r\nentry = (struct skb_data *) skb->cb;\r\nentry->urb = urb;\r\nentry->dev = dev;\r\nentry->state = tx_start;\r\nentry->length = length;\r\nusb_fill_bulk_urb (urb, dev->udev, dev->out,\r\nskb->data, skb->len, tx_complete, skb);\r\nif (length % dev->maxpacket == 0) {\r\nif (!(info->flags & FLAG_SEND_ZLP)) {\r\nif (!(info->flags & FLAG_MULTI_PACKET)) {\r\nurb->transfer_buffer_length++;\r\nif (skb_tailroom(skb)) {\r\nskb->data[skb->len] = 0;\r\n__skb_put(skb, 1);\r\n}\r\n}\r\n} else\r\nurb->transfer_flags |= URB_ZERO_PACKET;\r\n}\r\nspin_lock_irqsave(&dev->txq.lock, flags);\r\nretval = usb_autopm_get_interface_async(dev->intf);\r\nif (retval < 0) {\r\nspin_unlock_irqrestore(&dev->txq.lock, flags);\r\ngoto drop;\r\n}\r\n#ifdef CONFIG_PM\r\nif (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) {\r\nusb_anchor_urb(urb, &dev->deferred);\r\nnetif_stop_queue(net);\r\nspin_unlock_irqrestore(&dev->txq.lock, flags);\r\nnetdev_dbg(dev->net, "Delaying transmission for resumption\n");\r\ngoto deferred;\r\n}\r\n#endif\r\nswitch ((retval = usb_submit_urb (urb, GFP_ATOMIC))) {\r\ncase -EPIPE:\r\nnetif_stop_queue (net);\r\nusbnet_defer_kevent (dev, EVENT_TX_HALT);\r\nusb_autopm_put_interface_async(dev->intf);\r\nbreak;\r\ndefault:\r\nusb_autopm_put_interface_async(dev->intf);\r\nnetif_dbg(dev, tx_err, dev->net,\r\n"tx: submit urb err %d\n", retval);\r\nbreak;\r\ncase 0:\r\nnet->trans_start = jiffies;\r\n__skb_queue_tail (&dev->txq, skb);\r\nif (dev->txq.qlen >= TX_QLEN (dev))\r\nnetif_stop_queue (net);\r\n}\r\nspin_unlock_irqrestore (&dev->txq.lock, flags);\r\nif (retval) {\r\nnetif_dbg(dev, tx_err, dev->net, "drop, code %d\n", retval);\r\ndrop:\r\ndev->net->stats.tx_dropped++;\r\nnot_drop:\r\nif (skb)\r\ndev_kfree_skb_any (skb);\r\nusb_free_urb (urb);\r\n} else\r\nnetif_dbg(dev, tx_queued, dev->net,\r\n"> tx, len %d, type 0x%x\n", length, skb->protocol);\r\n#ifdef CONFIG_PM\r\ndeferred:\r\n#endif\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void usbnet_bh (unsigned long param)\r\n{\r\nstruct usbnet *dev = (struct usbnet *) param;\r\nstruct sk_buff *skb;\r\nstruct skb_data *entry;\r\nwhile ((skb = skb_dequeue (&dev->done))) {\r\nentry = (struct skb_data *) skb->cb;\r\nswitch (entry->state) {\r\ncase rx_done:\r\nentry->state = rx_cleanup;\r\nrx_process (dev, skb);\r\ncontinue;\r\ncase tx_done:\r\ncase rx_cleanup:\r\nusb_free_urb (entry->urb);\r\ndev_kfree_skb (skb);\r\ncontinue;\r\ndefault:\r\nnetdev_dbg(dev->net, "bogus skb state %d\n", entry->state);\r\n}\r\n}\r\nif (dev->wait) {\r\nif ((dev->txq.qlen + dev->rxq.qlen + dev->done.qlen) == 0) {\r\nwake_up (dev->wait);\r\n}\r\n} else if (netif_running (dev->net) &&\r\nnetif_device_present (dev->net) &&\r\n!timer_pending (&dev->delay) &&\r\n!test_bit (EVENT_RX_HALT, &dev->flags)) {\r\nint temp = dev->rxq.qlen;\r\nint qlen = RX_QLEN (dev);\r\nif (temp < qlen) {\r\nstruct urb *urb;\r\nint i;\r\nfor (i = 0; i < 10 && dev->rxq.qlen < qlen; i++) {\r\nurb = usb_alloc_urb (0, GFP_ATOMIC);\r\nif (urb != NULL) {\r\nif (rx_submit (dev, urb, GFP_ATOMIC) ==\r\n-ENOLINK)\r\nreturn;\r\n}\r\n}\r\nif (temp != dev->rxq.qlen)\r\nnetif_dbg(dev, link, dev->net,\r\n"rxqlen %d --> %d\n",\r\ntemp, dev->rxq.qlen);\r\nif (dev->rxq.qlen < qlen)\r\ntasklet_schedule (&dev->bh);\r\n}\r\nif (dev->txq.qlen < TX_QLEN (dev))\r\nnetif_wake_queue (dev->net);\r\n}\r\n}\r\nvoid usbnet_disconnect (struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev;\r\nstruct usb_device *xdev;\r\nstruct net_device *net;\r\ndev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (!dev)\r\nreturn;\r\nxdev = interface_to_usbdev (intf);\r\nnetif_info(dev, probe, dev->net, "unregister '%s' usb-%s-%s, %s\n",\r\nintf->dev.driver->name,\r\nxdev->bus->bus_name, xdev->devpath,\r\ndev->driver_info->description);\r\nnet = dev->net;\r\nunregister_netdev (net);\r\ncancel_work_sync(&dev->kevent);\r\nif (dev->driver_info->unbind)\r\ndev->driver_info->unbind (dev, intf);\r\nusb_kill_urb(dev->interrupt);\r\nusb_free_urb(dev->interrupt);\r\nfree_netdev(net);\r\nusb_put_dev (xdev);\r\n}\r\nint\r\nusbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)\r\n{\r\nstruct usbnet *dev;\r\nstruct net_device *net;\r\nstruct usb_host_interface *interface;\r\nstruct driver_info *info;\r\nstruct usb_device *xdev;\r\nint status;\r\nconst char *name;\r\nstruct usb_driver *driver = to_usb_driver(udev->dev.driver);\r\nif (!driver->supports_autosuspend) {\r\ndriver->supports_autosuspend = 1;\r\npm_runtime_enable(&udev->dev);\r\n}\r\nname = udev->dev.driver->name;\r\ninfo = (struct driver_info *) prod->driver_info;\r\nif (!info) {\r\ndev_dbg (&udev->dev, "blacklisted by %s\n", name);\r\nreturn -ENODEV;\r\n}\r\nxdev = interface_to_usbdev (udev);\r\ninterface = udev->cur_altsetting;\r\nusb_get_dev (xdev);\r\nstatus = -ENOMEM;\r\nnet = alloc_etherdev(sizeof(*dev));\r\nif (!net) {\r\ndbg ("can't kmalloc dev");\r\ngoto out;\r\n}\r\nSET_NETDEV_DEV(net, &udev->dev);\r\ndev = netdev_priv(net);\r\ndev->udev = xdev;\r\ndev->intf = udev;\r\ndev->driver_info = info;\r\ndev->driver_name = name;\r\ndev->msg_enable = netif_msg_init (msg_level, NETIF_MSG_DRV\r\n| NETIF_MSG_PROBE | NETIF_MSG_LINK);\r\nskb_queue_head_init (&dev->rxq);\r\nskb_queue_head_init (&dev->txq);\r\nskb_queue_head_init (&dev->done);\r\nskb_queue_head_init(&dev->rxq_pause);\r\ndev->bh.func = usbnet_bh;\r\ndev->bh.data = (unsigned long) dev;\r\nINIT_WORK (&dev->kevent, kevent);\r\ninit_usb_anchor(&dev->deferred);\r\ndev->delay.function = usbnet_bh;\r\ndev->delay.data = (unsigned long) dev;\r\ninit_timer (&dev->delay);\r\nmutex_init (&dev->phy_mutex);\r\ndev->net = net;\r\nstrcpy (net->name, "usb%d");\r\nmemcpy (net->dev_addr, node_id, sizeof node_id);\r\ndev->hard_mtu = net->mtu + net->hard_header_len;\r\n#if 0\r\nif (dma_supported (&udev->dev, DMA_BIT_MASK(64)))\r\nnet->features |= NETIF_F_HIGHDMA;\r\n#endif\r\nnet->netdev_ops = &usbnet_netdev_ops;\r\nnet->watchdog_timeo = TX_TIMEOUT_JIFFIES;\r\nnet->ethtool_ops = &usbnet_ethtool_ops;\r\nif (info->bind) {\r\nstatus = info->bind (dev, udev);\r\nif (status < 0)\r\ngoto out1;\r\nif ((dev->driver_info->flags & FLAG_ETHER) != 0 &&\r\n((dev->driver_info->flags & FLAG_POINTTOPOINT) == 0 ||\r\n(net->dev_addr [0] & 0x02) == 0))\r\nstrcpy (net->name, "eth%d");\r\nif ((dev->driver_info->flags & FLAG_WLAN) != 0)\r\nstrcpy(net->name, "wlan%d");\r\nif ((dev->driver_info->flags & FLAG_WWAN) != 0)\r\nstrcpy(net->name, "wwan%d");\r\nif (net->mtu > (dev->hard_mtu - net->hard_header_len))\r\nnet->mtu = dev->hard_mtu - net->hard_header_len;\r\n} else if (!info->in || !info->out)\r\nstatus = usbnet_get_endpoints (dev, udev);\r\nelse {\r\ndev->in = usb_rcvbulkpipe (xdev, info->in);\r\ndev->out = usb_sndbulkpipe (xdev, info->out);\r\nif (!(info->flags & FLAG_NO_SETINT))\r\nstatus = usb_set_interface (xdev,\r\ninterface->desc.bInterfaceNumber,\r\ninterface->desc.bAlternateSetting);\r\nelse\r\nstatus = 0;\r\n}\r\nif (status >= 0 && dev->status)\r\nstatus = init_status (dev, udev);\r\nif (status < 0)\r\ngoto out3;\r\nif (!dev->rx_urb_size)\r\ndev->rx_urb_size = dev->hard_mtu;\r\ndev->maxpacket = usb_maxpacket (dev->udev, dev->out, 1);\r\nif ((dev->driver_info->flags & FLAG_WLAN) != 0)\r\nSET_NETDEV_DEVTYPE(net, &wlan_type);\r\nif ((dev->driver_info->flags & FLAG_WWAN) != 0)\r\nSET_NETDEV_DEVTYPE(net, &wwan_type);\r\nstatus = register_netdev (net);\r\nif (status)\r\ngoto out3;\r\nnetif_info(dev, probe, dev->net,\r\n"register '%s' at usb-%s-%s, %s, %pM\n",\r\nudev->dev.driver->name,\r\nxdev->bus->bus_name, xdev->devpath,\r\ndev->driver_info->description,\r\nnet->dev_addr);\r\nusb_set_intfdata (udev, dev);\r\nnetif_device_attach (net);\r\nif (dev->driver_info->flags & FLAG_LINK_INTR)\r\nnetif_carrier_off(net);\r\nreturn 0;\r\nout3:\r\nif (info->unbind)\r\ninfo->unbind (dev, udev);\r\nout1:\r\nfree_netdev(net);\r\nout:\r\nusb_put_dev(xdev);\r\nreturn status;\r\n}\r\nint usbnet_suspend (struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nif (!dev->suspend_count++) {\r\nspin_lock_irq(&dev->txq.lock);\r\nif (dev->txq.qlen && (message.event & PM_EVENT_AUTO)) {\r\nspin_unlock_irq(&dev->txq.lock);\r\nreturn -EBUSY;\r\n} else {\r\nset_bit(EVENT_DEV_ASLEEP, &dev->flags);\r\nspin_unlock_irq(&dev->txq.lock);\r\n}\r\nnetif_device_detach (dev->net);\r\nusbnet_terminate_urbs(dev);\r\nusb_kill_urb(dev->interrupt);\r\nnetif_device_attach (dev->net);\r\n}\r\nreturn 0;\r\n}\r\nint usbnet_resume (struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct sk_buff *skb;\r\nstruct urb *res;\r\nint retval;\r\nif (!--dev->suspend_count) {\r\nif (dev->interrupt && test_bit(EVENT_DEV_OPEN, &dev->flags))\r\nusb_submit_urb(dev->interrupt, GFP_NOIO);\r\nspin_lock_irq(&dev->txq.lock);\r\nwhile ((res = usb_get_from_anchor(&dev->deferred))) {\r\nskb = (struct sk_buff *)res->context;\r\nretval = usb_submit_urb(res, GFP_ATOMIC);\r\nif (retval < 0) {\r\ndev_kfree_skb_any(skb);\r\nusb_free_urb(res);\r\nusb_autopm_put_interface_async(dev->intf);\r\n} else {\r\ndev->net->trans_start = jiffies;\r\n__skb_queue_tail(&dev->txq, skb);\r\n}\r\n}\r\nsmp_mb();\r\nclear_bit(EVENT_DEV_ASLEEP, &dev->flags);\r\nspin_unlock_irq(&dev->txq.lock);\r\nif (test_bit(EVENT_DEV_OPEN, &dev->flags)) {\r\nif (!(dev->txq.qlen >= TX_QLEN(dev)))\r\nnetif_start_queue(dev->net);\r\ntasklet_schedule (&dev->bh);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init usbnet_init(void)\r\n{\r\nBUILD_BUG_ON(\r\nFIELD_SIZEOF(struct sk_buff, cb) < sizeof(struct skb_data));\r\nrandom_ether_addr(node_id);\r\nreturn 0;\r\n}\r\nstatic void __exit usbnet_exit(void)\r\n{\r\n}
