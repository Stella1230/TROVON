static int write_acpi_int(acpi_handle handle, const char *method, int val,\r\nstruct acpi_buffer *output)\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nacpi_status status;\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = val;\r\nstatus = acpi_evaluate_object(handle, (char *)method, &params, output);\r\nreturn (status == AE_OK);\r\n}\r\nstatic int read_acpi_int(acpi_handle handle, const char *method, int *val)\r\n{\r\nstruct acpi_buffer output;\r\nunion acpi_object out_obj;\r\nacpi_status status;\r\noutput.length = sizeof(out_obj);\r\noutput.pointer = &out_obj;\r\nstatus = acpi_evaluate_object(handle, (char *)method, NULL, &output);\r\n*val = out_obj.integer.value;\r\nreturn (status == AE_OK) && (out_obj.type == ACPI_TYPE_INTEGER);\r\n}\r\nstatic int asus_info_proc_show(struct seq_file *m, void *v)\r\n{\r\nint temp;\r\nseq_printf(m, ACPI_HOTK_NAME " " ASUS_ACPI_VERSION "\n");\r\nseq_printf(m, "Model reference : %s\n", hotk->methods->name);\r\nif (read_acpi_int(hotk->handle, "SFUN", &temp))\r\nseq_printf(m, "SFUN value : 0x%04x\n", temp);\r\nif (read_acpi_int(hotk->handle, "ASYM", &temp))\r\nseq_printf(m, "ASYM value : 0x%04x\n", temp);\r\nif (asus_info) {\r\nseq_printf(m, "DSDT length : %d\n", asus_info->length);\r\nseq_printf(m, "DSDT checksum : %d\n", asus_info->checksum);\r\nseq_printf(m, "DSDT revision : %d\n", asus_info->revision);\r\nseq_printf(m, "OEM id : %.*s\n", ACPI_OEM_ID_SIZE, asus_info->oem_id);\r\nseq_printf(m, "OEM table id : %.*s\n", ACPI_OEM_TABLE_ID_SIZE, asus_info->oem_table_id);\r\nseq_printf(m, "OEM revision : 0x%x\n", asus_info->oem_revision);\r\nseq_printf(m, "ASL comp vendor id : %.*s\n", ACPI_NAME_SIZE, asus_info->asl_compiler_id);\r\nseq_printf(m, "ASL comp revision : 0x%x\n", asus_info->asl_compiler_revision);\r\n}\r\nreturn 0;\r\n}\r\nstatic int asus_info_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, asus_info_proc_show, NULL);\r\n}\r\nstatic int read_led(const char *ledname, int ledmask)\r\n{\r\nif (ledname) {\r\nint led_status;\r\nif (read_acpi_int(NULL, ledname, &led_status))\r\nreturn led_status;\r\nelse\r\npr_warn("Error reading LED status\n");\r\n}\r\nreturn (hotk->status & ledmask) ? 1 : 0;\r\n}\r\nstatic int parse_arg(const char __user *buf, unsigned long count, int *val)\r\n{\r\nchar s[32];\r\nif (!count)\r\nreturn 0;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (copy_from_user(s, buf, count))\r\nreturn -EFAULT;\r\ns[count] = 0;\r\nif (sscanf(s, "%i", val) != 1)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int\r\nwrite_led(const char __user *buffer, unsigned long count,\r\nchar *ledname, int ledmask, int invert)\r\n{\r\nint rv, value;\r\nint led_out = 0;\r\nrv = parse_arg(buffer, count, &value);\r\nif (rv > 0)\r\nled_out = value ? 1 : 0;\r\nhotk->status =\r\n(led_out) ? (hotk->status | ledmask) : (hotk->status & ~ledmask);\r\nif (invert)\r\nled_out = !led_out;\r\nif (!write_acpi_int(hotk->handle, ledname, led_out, NULL))\r\npr_warn("LED (%s) write failed\n", ledname);\r\nreturn rv;\r\n}\r\nstatic int mled_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", read_led(hotk->methods->mled_status, MLED_ON));\r\nreturn 0;\r\n}\r\nstatic int mled_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mled_proc_show, NULL);\r\n}\r\nstatic ssize_t mled_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nreturn write_led(buffer, count, hotk->methods->mt_mled, MLED_ON, 1);\r\n}\r\nstatic int ledd_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "0x%08x\n", hotk->ledd_status);\r\nreturn 0;\r\n}\r\nstatic int ledd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ledd_proc_show, NULL);\r\n}\r\nstatic ssize_t ledd_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nint rv, value;\r\nrv = parse_arg(buffer, count, &value);\r\nif (rv > 0) {\r\nif (!write_acpi_int\r\n(hotk->handle, hotk->methods->mt_ledd, value, NULL))\r\npr_warn("LED display write failed\n");\r\nelse\r\nhotk->ledd_status = (u32) value;\r\n}\r\nreturn rv;\r\n}\r\nstatic int wled_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", read_led(hotk->methods->wled_status, WLED_ON));\r\nreturn 0;\r\n}\r\nstatic int wled_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, wled_proc_show, NULL);\r\n}\r\nstatic ssize_t wled_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nreturn write_led(buffer, count, hotk->methods->mt_wled, WLED_ON, 0);\r\n}\r\nstatic int bluetooth_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", read_led(hotk->methods->bt_status, BT_ON));\r\nreturn 0;\r\n}\r\nstatic int bluetooth_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, bluetooth_proc_show, NULL);\r\n}\r\nstatic ssize_t bluetooth_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nreturn write_led(buffer, count, hotk->methods->mt_bt_switch, BT_ON, 0);\r\n}\r\nstatic int tled_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", read_led(hotk->methods->tled_status, TLED_ON));\r\nreturn 0;\r\n}\r\nstatic int tled_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, tled_proc_show, NULL);\r\n}\r\nstatic ssize_t tled_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nreturn write_led(buffer, count, hotk->methods->mt_tled, TLED_ON, 0);\r\n}\r\nstatic int get_lcd_state(void)\r\n{\r\nint lcd = 0;\r\nif (hotk->model == L3H) {\r\nacpi_status status = 0;\r\nstruct acpi_object_list input;\r\nunion acpi_object mt_params[2];\r\nstruct acpi_buffer output;\r\nunion acpi_object out_obj;\r\ninput.count = 2;\r\ninput.pointer = mt_params;\r\nmt_params[0].type = ACPI_TYPE_INTEGER;\r\nmt_params[0].integer.value = 0x02;\r\nmt_params[1].type = ACPI_TYPE_INTEGER;\r\nmt_params[1].integer.value = 0x02;\r\noutput.length = sizeof(out_obj);\r\noutput.pointer = &out_obj;\r\nstatus =\r\nacpi_evaluate_object(NULL, hotk->methods->lcd_status,\r\n&input, &output);\r\nif (status != AE_OK)\r\nreturn -1;\r\nif (out_obj.type == ACPI_TYPE_INTEGER)\r\nlcd = out_obj.integer.value >> 8;\r\n} else if (hotk->model == F3Sa) {\r\nunsigned long long tmp;\r\nunion acpi_object param;\r\nstruct acpi_object_list input;\r\nacpi_status status;\r\nparam.type = ACPI_TYPE_INTEGER;\r\nparam.integer.value = 0x11;\r\ninput.count = 1;\r\ninput.pointer = &param;\r\nstatus = acpi_evaluate_integer(NULL, hotk->methods->lcd_status,\r\n&input, &tmp);\r\nif (status != AE_OK)\r\nreturn -1;\r\nlcd = tmp;\r\n} else {\r\nif (!read_acpi_int(NULL, hotk->methods->lcd_status, &lcd))\r\npr_warn("Error reading LCD status\n");\r\nif (hotk->model == L2D)\r\nlcd = ~lcd;\r\n}\r\nreturn (lcd & 1);\r\n}\r\nstatic int set_lcd_state(int value)\r\n{\r\nint lcd = 0;\r\nacpi_status status = 0;\r\nlcd = value ? 1 : 0;\r\nif (lcd != get_lcd_state()) {\r\nif (hotk->model != L3H) {\r\nstatus =\r\nacpi_evaluate_object(NULL,\r\nhotk->methods->mt_lcd_switch,\r\nNULL, NULL);\r\n} else {\r\nif (!write_acpi_int\r\n(hotk->handle, hotk->methods->mt_lcd_switch, 0x07,\r\nNULL))\r\nstatus = AE_ERROR;\r\n}\r\nif (ACPI_FAILURE(status))\r\npr_warn("Error switching LCD\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int lcd_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", get_lcd_state());\r\nreturn 0;\r\n}\r\nstatic int lcd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, lcd_proc_show, NULL);\r\n}\r\nstatic ssize_t lcd_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nint rv, value;\r\nrv = parse_arg(buffer, count, &value);\r\nif (rv > 0)\r\nset_lcd_state(value);\r\nreturn rv;\r\n}\r\nstatic int read_brightness(struct backlight_device *bd)\r\n{\r\nint value;\r\nif (hotk->methods->brightness_get) {\r\nif (!read_acpi_int(hotk->handle, hotk->methods->brightness_get,\r\n&value))\r\npr_warn("Error reading brightness\n");\r\n} else if (hotk->methods->brightness_status) {\r\nif (!read_acpi_int(NULL, hotk->methods->brightness_status,\r\n&value))\r\npr_warn("Error reading brightness\n");\r\n} else\r\nvalue = hotk->brightness;\r\nreturn value;\r\n}\r\nstatic int set_brightness(int value)\r\n{\r\nacpi_status status = 0;\r\nint ret = 0;\r\nif (hotk->methods->brightness_set) {\r\nif (!write_acpi_int(hotk->handle, hotk->methods->brightness_set,\r\nvalue, NULL)) {\r\npr_warn("Error changing brightness\n");\r\nret = -EIO;\r\n}\r\ngoto out;\r\n}\r\nvalue -= read_brightness(NULL);\r\nwhile (value != 0) {\r\nstatus = acpi_evaluate_object(NULL, (value > 0) ?\r\nhotk->methods->brightness_up :\r\nhotk->methods->brightness_down,\r\nNULL, NULL);\r\n(value > 0) ? value-- : value++;\r\nif (ACPI_FAILURE(status)) {\r\npr_warn("Error changing brightness\n");\r\nret = -EIO;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int set_brightness_status(struct backlight_device *bd)\r\n{\r\nreturn set_brightness(bd->props.brightness);\r\n}\r\nstatic int brn_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", read_brightness(NULL));\r\nreturn 0;\r\n}\r\nstatic int brn_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, brn_proc_show, NULL);\r\n}\r\nstatic ssize_t brn_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nint rv, value;\r\nrv = parse_arg(buffer, count, &value);\r\nif (rv > 0) {\r\nvalue = (0 < value) ? ((15 < value) ? 15 : value) : 0;\r\nset_brightness(value);\r\n}\r\nreturn rv;\r\n}\r\nstatic void set_display(int value)\r\n{\r\nif (!write_acpi_int(hotk->handle, hotk->methods->display_set,\r\nvalue, NULL))\r\npr_warn("Error setting display\n");\r\nreturn;\r\n}\r\nstatic int disp_proc_show(struct seq_file *m, void *v)\r\n{\r\nint value = 0;\r\nif (!read_acpi_int(hotk->handle, hotk->methods->display_get, &value))\r\npr_warn("Error reading display status\n");\r\nvalue &= 0x07;\r\nseq_printf(m, "%d\n", value);\r\nreturn 0;\r\n}\r\nstatic int disp_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, disp_proc_show, NULL);\r\n}\r\nstatic ssize_t disp_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nint rv, value;\r\nrv = parse_arg(buffer, count, &value);\r\nif (rv > 0)\r\nset_display(value);\r\nreturn rv;\r\n}\r\nstatic int\r\nasus_proc_add(char *name, const struct file_operations *proc_fops, mode_t mode,\r\nstruct acpi_device *device)\r\n{\r\nstruct proc_dir_entry *proc;\r\nproc = proc_create_data(name, mode, acpi_device_dir(device),\r\nproc_fops, acpi_driver_data(device));\r\nif (!proc) {\r\npr_warn(" Unable to create %s fs entry\n", name);\r\nreturn -1;\r\n}\r\nproc->uid = asus_uid;\r\nproc->gid = asus_gid;\r\nreturn 0;\r\n}\r\nstatic int asus_hotk_add_fs(struct acpi_device *device)\r\n{\r\nstruct proc_dir_entry *proc;\r\nmode_t mode;\r\nif ((asus_uid == 0) && (asus_gid == 0)) {\r\nmode = S_IFREG | S_IRUGO | S_IWUSR | S_IWGRP;\r\n} else {\r\nmode = S_IFREG | S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP;\r\npr_warn(" asus_uid and asus_gid parameters are "\r\n"deprecated, use chown and chmod instead!\n");\r\n}\r\nacpi_device_dir(device) = asus_proc_dir;\r\nif (!acpi_device_dir(device))\r\nreturn -ENODEV;\r\nproc = proc_create(PROC_INFO, mode, acpi_device_dir(device),\r\n&asus_info_proc_fops);\r\nif (proc) {\r\nproc->uid = asus_uid;\r\nproc->gid = asus_gid;\r\n} else {\r\npr_warn(" Unable to create " PROC_INFO " fs entry\n");\r\n}\r\nif (hotk->methods->mt_wled) {\r\nasus_proc_add(PROC_WLED, &wled_proc_fops, mode, device);\r\n}\r\nif (hotk->methods->mt_ledd) {\r\nasus_proc_add(PROC_LEDD, &ledd_proc_fops, mode, device);\r\n}\r\nif (hotk->methods->mt_mled) {\r\nasus_proc_add(PROC_MLED, &mled_proc_fops, mode, device);\r\n}\r\nif (hotk->methods->mt_tled) {\r\nasus_proc_add(PROC_TLED, &tled_proc_fops, mode, device);\r\n}\r\nif (hotk->methods->mt_bt_switch) {\r\nasus_proc_add(PROC_BT, &bluetooth_proc_fops, mode, device);\r\n}\r\nif (hotk->methods->mt_lcd_switch && hotk->methods->lcd_status) {\r\nasus_proc_add(PROC_LCD, &lcd_proc_fops, mode, device);\r\n}\r\nif ((hotk->methods->brightness_up && hotk->methods->brightness_down) ||\r\n(hotk->methods->brightness_get && hotk->methods->brightness_set)) {\r\nasus_proc_add(PROC_BRN, &brn_proc_fops, mode, device);\r\n}\r\nif (hotk->methods->display_set) {\r\nasus_proc_add(PROC_DISP, &disp_proc_fops, mode, device);\r\n}\r\nreturn 0;\r\n}\r\nstatic int asus_hotk_remove_fs(struct acpi_device *device)\r\n{\r\nif (acpi_device_dir(device)) {\r\nremove_proc_entry(PROC_INFO, acpi_device_dir(device));\r\nif (hotk->methods->mt_wled)\r\nremove_proc_entry(PROC_WLED, acpi_device_dir(device));\r\nif (hotk->methods->mt_mled)\r\nremove_proc_entry(PROC_MLED, acpi_device_dir(device));\r\nif (hotk->methods->mt_tled)\r\nremove_proc_entry(PROC_TLED, acpi_device_dir(device));\r\nif (hotk->methods->mt_ledd)\r\nremove_proc_entry(PROC_LEDD, acpi_device_dir(device));\r\nif (hotk->methods->mt_bt_switch)\r\nremove_proc_entry(PROC_BT, acpi_device_dir(device));\r\nif (hotk->methods->mt_lcd_switch && hotk->methods->lcd_status)\r\nremove_proc_entry(PROC_LCD, acpi_device_dir(device));\r\nif ((hotk->methods->brightness_up\r\n&& hotk->methods->brightness_down)\r\n|| (hotk->methods->brightness_get\r\n&& hotk->methods->brightness_set))\r\nremove_proc_entry(PROC_BRN, acpi_device_dir(device));\r\nif (hotk->methods->display_set)\r\nremove_proc_entry(PROC_DISP, acpi_device_dir(device));\r\n}\r\nreturn 0;\r\n}\r\nstatic void asus_hotk_notify(struct acpi_device *device, u32 event)\r\n{\r\nif (!hotk)\r\nreturn;\r\nif (event > ACPI_MAX_SYS_NOTIFY)\r\nreturn;\r\nif ((event & ~((u32) BR_UP)) < 16)\r\nhotk->brightness = (event & ~((u32) BR_UP));\r\nelse if ((event & ~((u32) BR_DOWN)) < 16)\r\nhotk->brightness = (event & ~((u32) BR_DOWN));\r\nacpi_bus_generate_proc_event(hotk->device, event,\r\nhotk->event_count[event % 128]++);\r\nreturn;\r\n}\r\nstatic int asus_model_match(char *model)\r\n{\r\nif (model == NULL)\r\nreturn END_MODEL;\r\nif (strncmp(model, "L3D", 3) == 0)\r\nreturn L3D;\r\nelse if (strncmp(model, "L2E", 3) == 0 ||\r\nstrncmp(model, "L3H", 3) == 0 || strncmp(model, "L5D", 3) == 0)\r\nreturn L3H;\r\nelse if (strncmp(model, "L3", 2) == 0 || strncmp(model, "L2B", 3) == 0)\r\nreturn L3C;\r\nelse if (strncmp(model, "L8L", 3) == 0)\r\nreturn L8L;\r\nelse if (strncmp(model, "L4R", 3) == 0)\r\nreturn L4R;\r\nelse if (strncmp(model, "M6N", 3) == 0 || strncmp(model, "W3N", 3) == 0)\r\nreturn M6N;\r\nelse if (strncmp(model, "M6R", 3) == 0 || strncmp(model, "A3G", 3) == 0)\r\nreturn M6R;\r\nelse if (strncmp(model, "M2N", 3) == 0 ||\r\nstrncmp(model, "M3N", 3) == 0 ||\r\nstrncmp(model, "M5N", 3) == 0 ||\r\nstrncmp(model, "S1N", 3) == 0 ||\r\nstrncmp(model, "S5N", 3) == 0)\r\nreturn xxN;\r\nelse if (strncmp(model, "M1", 2) == 0)\r\nreturn M1A;\r\nelse if (strncmp(model, "M2", 2) == 0 || strncmp(model, "L4E", 3) == 0)\r\nreturn M2E;\r\nelse if (strncmp(model, "L2", 2) == 0)\r\nreturn L2D;\r\nelse if (strncmp(model, "L8", 2) == 0)\r\nreturn S1x;\r\nelse if (strncmp(model, "D1", 2) == 0)\r\nreturn D1x;\r\nelse if (strncmp(model, "A1", 2) == 0)\r\nreturn A1x;\r\nelse if (strncmp(model, "A2", 2) == 0)\r\nreturn A2x;\r\nelse if (strncmp(model, "J1", 2) == 0)\r\nreturn S2x;\r\nelse if (strncmp(model, "L5", 2) == 0)\r\nreturn L5x;\r\nelse if (strncmp(model, "A4G", 3) == 0)\r\nreturn A4G;\r\nelse if (strncmp(model, "W1N", 3) == 0)\r\nreturn W1N;\r\nelse if (strncmp(model, "W3V", 3) == 0)\r\nreturn W3V;\r\nelse if (strncmp(model, "W5A", 3) == 0)\r\nreturn W5A;\r\nelse if (strncmp(model, "R1F", 3) == 0)\r\nreturn R1F;\r\nelse if (strncmp(model, "A4S", 3) == 0)\r\nreturn A4S;\r\nelse if (strncmp(model, "F3Sa", 4) == 0)\r\nreturn F3Sa;\r\nelse\r\nreturn END_MODEL;\r\n}\r\nstatic int asus_hotk_get_info(void)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *model = NULL;\r\nint bsts_result;\r\nchar *string = NULL;\r\nacpi_status status;\r\nstatus = acpi_get_table(ACPI_SIG_DSDT, 1, &asus_info);\r\nif (ACPI_FAILURE(status))\r\npr_warn(" Couldn't get the DSDT table header\n");\r\nif (!write_acpi_int(hotk->handle, "INIT", 0, &buffer)) {\r\npr_err(" Hotkey initialization failed\n");\r\nreturn -ENODEV;\r\n}\r\nif (!read_acpi_int(hotk->handle, "BSTS", &bsts_result))\r\npr_warn(" Error calling BSTS\n");\r\nelse if (bsts_result)\r\npr_notice(" BSTS called, 0x%02x returned\n", bsts_result);\r\nif (buffer.pointer) {\r\nmodel = buffer.pointer;\r\nswitch (model->type) {\r\ncase ACPI_TYPE_STRING:\r\nstring = model->string.pointer;\r\nbreak;\r\ncase ACPI_TYPE_BUFFER:\r\nstring = model->buffer.pointer;\r\nbreak;\r\ndefault:\r\nkfree(model);\r\nmodel = NULL;\r\nbreak;\r\n}\r\n}\r\nhotk->model = asus_model_match(string);\r\nif (hotk->model == END_MODEL) {\r\nif (asus_info &&\r\nstrncmp(asus_info->oem_table_id, "ODEM", 4) == 0) {\r\nhotk->model = P30;\r\npr_notice(" Samsung P30 detected, supported\n");\r\nhotk->methods = &model_conf[hotk->model];\r\nkfree(model);\r\nreturn 0;\r\n} else {\r\nhotk->model = M2E;\r\npr_notice(" unsupported model %s, trying default values\n",\r\nstring);\r\npr_notice(" send /proc/acpi/dsdt to the developers\n");\r\nkfree(model);\r\nreturn -ENODEV;\r\n}\r\n}\r\nhotk->methods = &model_conf[hotk->model];\r\npr_notice(" %s model detected, supported\n", string);\r\nif (strncmp(string, "L2B", 3) == 0)\r\nhotk->methods->lcd_status = NULL;\r\nelse if (strncmp(string, "A3G", 3) == 0)\r\nhotk->methods->lcd_status = "\\BLFG";\r\nelse if (strncmp(string, "S5N", 3) == 0 ||\r\nstrncmp(string, "M5N", 3) == 0 ||\r\nstrncmp(string, "W3N", 3) == 0)\r\nhotk->methods->mt_mled = NULL;\r\nelse if (strncmp(string, "L5D", 3) == 0)\r\nhotk->methods->mt_wled = NULL;\r\nelse if (strncmp(string, "M2N", 3) == 0 ||\r\nstrncmp(string, "W3V", 3) == 0 ||\r\nstrncmp(string, "S1N", 3) == 0)\r\nhotk->methods->mt_wled = "WLED";\r\nelse if (asus_info) {\r\nif (strncmp(asus_info->oem_table_id, "L1", 2) == 0)\r\nhotk->methods->mled_status = NULL;\r\n}\r\nkfree(model);\r\nreturn 0;\r\n}\r\nstatic int asus_hotk_check(void)\r\n{\r\nint result = 0;\r\nresult = acpi_bus_get_status(hotk->device);\r\nif (result)\r\nreturn result;\r\nif (hotk->device->status.present) {\r\nresult = asus_hotk_get_info();\r\n} else {\r\npr_err(" Hotkey device not present, aborting\n");\r\nreturn -EINVAL;\r\n}\r\nreturn result;\r\n}\r\nstatic int asus_hotk_add(struct acpi_device *device)\r\n{\r\nacpi_status status = AE_OK;\r\nint result;\r\npr_notice("Asus Laptop ACPI Extras version %s\n", ASUS_ACPI_VERSION);\r\nhotk = kzalloc(sizeof(struct asus_hotk), GFP_KERNEL);\r\nif (!hotk)\r\nreturn -ENOMEM;\r\nhotk->handle = device->handle;\r\nstrcpy(acpi_device_name(device), ACPI_HOTK_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_HOTK_CLASS);\r\ndevice->driver_data = hotk;\r\nhotk->device = device;\r\nresult = asus_hotk_check();\r\nif (result)\r\ngoto end;\r\nresult = asus_hotk_add_fs(device);\r\nif (result)\r\ngoto end;\r\nif ((!hotk->methods->brightness_get)\r\n&& (!hotk->methods->brightness_status)\r\n&& (hotk->methods->brightness_up && hotk->methods->brightness_down)) {\r\nstatus =\r\nacpi_evaluate_object(NULL, hotk->methods->brightness_down,\r\nNULL, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_warn(" Error changing brightness\n");\r\nelse {\r\nstatus =\r\nacpi_evaluate_object(NULL,\r\nhotk->methods->brightness_up,\r\nNULL, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_warn(" Strange, error changing brightness\n");\r\n}\r\n}\r\nasus_hotk_found = 1;\r\nhotk->ledd_status = 0xFFF;\r\nend:\r\nif (result)\r\nkfree(hotk);\r\nreturn result;\r\n}\r\nstatic int asus_hotk_remove(struct acpi_device *device, int type)\r\n{\r\nasus_hotk_remove_fs(device);\r\nkfree(hotk);\r\nreturn 0;\r\n}\r\nstatic void asus_acpi_exit(void)\r\n{\r\nif (asus_backlight_device)\r\nbacklight_device_unregister(asus_backlight_device);\r\nacpi_bus_unregister_driver(&asus_hotk_driver);\r\nremove_proc_entry(PROC_ASUS, acpi_root_dir);\r\nreturn;\r\n}\r\nstatic int __init asus_acpi_init(void)\r\n{\r\nstruct backlight_properties props;\r\nint result;\r\nresult = acpi_bus_register_driver(&asus_hotk_driver);\r\nif (result < 0)\r\nreturn result;\r\nasus_proc_dir = proc_mkdir(PROC_ASUS, acpi_root_dir);\r\nif (!asus_proc_dir) {\r\npr_err("Unable to create /proc entry\n");\r\nacpi_bus_unregister_driver(&asus_hotk_driver);\r\nreturn -ENODEV;\r\n}\r\nif (!asus_hotk_found) {\r\nacpi_bus_unregister_driver(&asus_hotk_driver);\r\nremove_proc_entry(PROC_ASUS, acpi_root_dir);\r\nreturn -ENODEV;\r\n}\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = 15;\r\nasus_backlight_device = backlight_device_register("asus", NULL, NULL,\r\n&asus_backlight_data,\r\n&props);\r\nif (IS_ERR(asus_backlight_device)) {\r\npr_err("Could not register asus backlight device\n");\r\nasus_backlight_device = NULL;\r\nasus_acpi_exit();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}
