static int jack_detect_kctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = kcontrol->private_value;\r\nreturn 0;\r\n}\r\nstatic int get_available_index(struct snd_card *card, const char *name)\r\n{\r\nstruct snd_ctl_elem_id sid;\r\nmemset(&sid, 0, sizeof(sid));\r\nsid.index = 0;\r\nsid.iface = SNDRV_CTL_ELEM_IFACE_CARD;\r\nstrlcpy(sid.name, name, sizeof(sid.name));\r\nwhile (snd_ctl_find_id(card, &sid)) {\r\nsid.index++;\r\nsid.numid = 0;\r\n}\r\nreturn sid.index;\r\n}\r\nstatic void jack_kctl_name_gen(char *name, const char *src_name, int size)\r\n{\r\nsize_t count = strlen(src_name);\r\nbool need_cat = true;\r\nif (count >= 5)\r\nneed_cat = strncmp(&src_name[count - 5], " Jack", 5) ? true : false;\r\nsnprintf(name, size, need_cat ? "%s Jack" : "%s", src_name);\r\n}\r\nstruct snd_kcontrol *\r\nsnd_kctl_jack_new(const char *name, struct snd_card *card)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(&jack_detect_kctl, NULL);\r\nif (!kctl)\r\nreturn NULL;\r\njack_kctl_name_gen(kctl->id.name, name, sizeof(kctl->id.name));\r\nkctl->id.index = get_available_index(card, kctl->id.name);\r\nkctl->private_value = 0;\r\nreturn kctl;\r\n}\r\nvoid snd_kctl_jack_report(struct snd_card *card,\r\nstruct snd_kcontrol *kctl, bool status)\r\n{\r\nif (kctl->private_value == status)\r\nreturn;\r\nkctl->private_value = status;\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\r\n}
