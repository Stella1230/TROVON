static void check_hw_pbc(struct _adapter *padapter)\r\n{\r\nu8 tmp1byte;\r\nr8712_write8(padapter, MAC_PINMUX_CTRL, (GPIOMUX_EN | GPIOSEL_GPIO));\r\ntmp1byte = r8712_read8(padapter, GPIO_IO_SEL);\r\ntmp1byte &= ~(HAL_8192S_HW_GPIO_WPS_BIT);\r\nr8712_write8(padapter, GPIO_IO_SEL, tmp1byte);\r\ntmp1byte = r8712_read8(padapter, GPIO_CTRL);\r\nif (tmp1byte == 0xff)\r\nreturn;\r\nif (tmp1byte & HAL_8192S_HW_GPIO_WPS_BIT) {\r\nDBG_8712("CheckPbcGPIO - PBC is pressed !!!!\n");\r\nif (padapter->pid == 0)\r\nreturn;\r\nkill_pid(find_vpid(padapter->pid), SIGUSR1, 1);\r\n}\r\n}\r\nstatic void query_fw_rx_phy_status(struct _adapter *padapter)\r\n{\r\nu32 val32 = 0;\r\nint pollingcnts = 50;\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\r\nr8712_write32(padapter, IOCMD_CTRL_REG, 0xf4000001);\r\nmsleep(100);\r\nwhile ((r8712_read32(padapter, IOCMD_CTRL_REG)) &&\r\n(pollingcnts > 0)) {\r\npollingcnts--;\r\nmsleep(20);\r\n}\r\nif (pollingcnts != 0)\r\nval32 = r8712_read32(padapter, IOCMD_DATA_REG);\r\nelse\r\nval32 = 0;\r\nval32 >>= 4;\r\npadapter->recvpriv.fw_rssi =\r\n(u8)r8712_signal_scale_mapping(val32);\r\n}\r\n}\r\nstatic void StatusWatchdogCallback(struct _adapter *padapter)\r\n{\r\ncheck_hw_pbc(padapter);\r\nquery_fw_rx_phy_status(padapter);\r\n}\r\nstatic void r871x_internal_cmd_hdl(struct _adapter *padapter, u8 *pbuf)\r\n{\r\nstruct drvint_cmd_parm *pdrvcmd;\r\nif (!pbuf)\r\nreturn;\r\npdrvcmd = (struct drvint_cmd_parm *)pbuf;\r\nswitch (pdrvcmd->i_cid) {\r\ncase WDG_WK_CID:\r\nStatusWatchdogCallback(padapter);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkfree(pdrvcmd->pbuf);\r\n}\r\nstatic u8 read_macreg_hdl(struct _adapter *padapter, u8 *pbuf)\r\n{\r\nvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\r\nstruct cmd_obj *pcmd = (struct cmd_obj *)pbuf;\r\npcmd_callback = cmd_callback[pcmd->cmdcode].callback;\r\nif (!pcmd_callback)\r\nr8712_free_cmd_obj(pcmd);\r\nelse\r\npcmd_callback(padapter, pcmd);\r\nreturn H2C_SUCCESS;\r\n}\r\nstatic u8 write_macreg_hdl(struct _adapter *padapter, u8 *pbuf)\r\n{\r\nvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\r\nstruct cmd_obj *pcmd = (struct cmd_obj *)pbuf;\r\npcmd_callback = cmd_callback[pcmd->cmdcode].callback;\r\nif (!pcmd_callback)\r\nr8712_free_cmd_obj(pcmd);\r\nelse\r\npcmd_callback(padapter, pcmd);\r\nreturn H2C_SUCCESS;\r\n}\r\nstatic u8 read_bbreg_hdl(struct _adapter *padapter, u8 *pbuf)\r\n{\r\nu32 val;\r\nvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\r\nstruct cmd_obj *pcmd = (struct cmd_obj *)pbuf;\r\nif (pcmd->rsp && pcmd->rspsz > 0)\r\nmemcpy(pcmd->rsp, (u8 *)&val, pcmd->rspsz);\r\npcmd_callback = cmd_callback[pcmd->cmdcode].callback;\r\nif (!pcmd_callback)\r\nr8712_free_cmd_obj(pcmd);\r\nelse\r\npcmd_callback(padapter, pcmd);\r\nreturn H2C_SUCCESS;\r\n}\r\nstatic u8 write_bbreg_hdl(struct _adapter *padapter, u8 *pbuf)\r\n{\r\nvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\r\nstruct cmd_obj *pcmd = (struct cmd_obj *)pbuf;\r\npcmd_callback = cmd_callback[pcmd->cmdcode].callback;\r\nif (!pcmd_callback)\r\nr8712_free_cmd_obj(pcmd);\r\nelse\r\npcmd_callback(padapter, pcmd);\r\nreturn H2C_SUCCESS;\r\n}\r\nstatic u8 read_rfreg_hdl(struct _adapter *padapter, u8 *pbuf)\r\n{\r\nu32 val;\r\nvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\r\nstruct cmd_obj *pcmd = (struct cmd_obj *)pbuf;\r\nif (pcmd->rsp && pcmd->rspsz > 0)\r\nmemcpy(pcmd->rsp, (u8 *)&val, pcmd->rspsz);\r\npcmd_callback = cmd_callback[pcmd->cmdcode].callback;\r\nif (!pcmd_callback)\r\nr8712_free_cmd_obj(pcmd);\r\nelse\r\npcmd_callback(padapter, pcmd);\r\nreturn H2C_SUCCESS;\r\n}\r\nstatic u8 write_rfreg_hdl(struct _adapter *padapter, u8 *pbuf)\r\n{\r\nvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\r\nstruct cmd_obj *pcmd = (struct cmd_obj *)pbuf;\r\npcmd_callback = cmd_callback[pcmd->cmdcode].callback;\r\nif (!pcmd_callback)\r\nr8712_free_cmd_obj(pcmd);\r\nelse\r\npcmd_callback(padapter, pcmd);\r\nreturn H2C_SUCCESS;\r\n}\r\nstatic u8 sys_suspend_hdl(struct _adapter *padapter, u8 *pbuf)\r\n{\r\nstruct cmd_obj *pcmd = (struct cmd_obj *)pbuf;\r\nr8712_free_cmd_obj(pcmd);\r\nreturn H2C_SUCCESS;\r\n}\r\nstatic struct cmd_obj *cmd_hdl_filter(struct _adapter *padapter,\r\nstruct cmd_obj *pcmd)\r\n{\r\nstruct cmd_obj *pcmd_r;\r\nif (!pcmd)\r\nreturn pcmd;\r\npcmd_r = NULL;\r\nswitch (pcmd->cmdcode) {\r\ncase GEN_CMD_CODE(_Read_MACREG):\r\nread_macreg_hdl(padapter, (u8 *)pcmd);\r\npcmd_r = pcmd;\r\nbreak;\r\ncase GEN_CMD_CODE(_Write_MACREG):\r\nwrite_macreg_hdl(padapter, (u8 *)pcmd);\r\npcmd_r = pcmd;\r\nbreak;\r\ncase GEN_CMD_CODE(_Read_BBREG):\r\nread_bbreg_hdl(padapter, (u8 *)pcmd);\r\nbreak;\r\ncase GEN_CMD_CODE(_Write_BBREG):\r\nwrite_bbreg_hdl(padapter, (u8 *)pcmd);\r\nbreak;\r\ncase GEN_CMD_CODE(_Read_RFREG):\r\nread_rfreg_hdl(padapter, (u8 *)pcmd);\r\nbreak;\r\ncase GEN_CMD_CODE(_Write_RFREG):\r\nwrite_rfreg_hdl(padapter, (u8 *)pcmd);\r\nbreak;\r\ncase GEN_CMD_CODE(_SetUsbSuspend):\r\nsys_suspend_hdl(padapter, (u8 *)pcmd);\r\nbreak;\r\ncase GEN_CMD_CODE(_JoinBss):\r\nr8712_joinbss_reset(padapter);\r\nif (padapter->pwrctrlpriv.pwr_mode > PS_MODE_ACTIVE) {\r\npadapter->pwrctrlpriv.pwr_mode = PS_MODE_ACTIVE;\r\n_enter_pwrlock(&(padapter->pwrctrlpriv.lock));\r\nr8712_set_rpwm(padapter, PS_STATE_S4);\r\nup(&(padapter->pwrctrlpriv.lock));\r\n}\r\npcmd_r = pcmd;\r\nbreak;\r\ncase _DRV_INT_CMD_:\r\nr871x_internal_cmd_hdl(padapter, pcmd->parmbuf);\r\nr8712_free_cmd_obj(pcmd);\r\npcmd_r = NULL;\r\nbreak;\r\ndefault:\r\npcmd_r = pcmd;\r\nbreak;\r\n}\r\nreturn pcmd_r;\r\n}\r\nstatic u8 check_cmd_fifo(struct _adapter *padapter, uint sz)\r\n{\r\nreturn _SUCCESS;\r\n}\r\nu8 r8712_fw_cmd(struct _adapter *pAdapter, u32 cmd)\r\n{\r\nint pollingcnts = 50;\r\nr8712_write32(pAdapter, IOCMD_CTRL_REG, cmd);\r\nmsleep(100);\r\nwhile ((r8712_read32(pAdapter, IOCMD_CTRL_REG != 0)) &&\r\n(pollingcnts > 0)) {\r\npollingcnts--;\r\nmsleep(20);\r\n}\r\nif (pollingcnts == 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid r8712_fw_cmd_data(struct _adapter *pAdapter, u32 *value, u8 flag)\r\n{\r\nif (flag == 0)\r\nr8712_write32(pAdapter, IOCMD_DATA_REG, *value);\r\nelse\r\n*value = r8712_read32(pAdapter, IOCMD_DATA_REG);\r\n}\r\nint r8712_cmd_thread(void *context)\r\n{\r\nstruct cmd_obj *pcmd;\r\nunsigned int cmdsz, wr_sz, *pcmdbuf;\r\nstruct tx_desc *pdesc;\r\nvoid (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);\r\nstruct _adapter *padapter = context;\r\nstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\r\nallow_signal(SIGTERM);\r\nwhile (1) {\r\nif ((_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)\r\nbreak;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\r\nbreak;\r\nif (r8712_register_cmd_alive(padapter) != _SUCCESS)\r\ncontinue;\r\n_next:\r\npcmd = r8712_dequeue_cmd(&(pcmdpriv->cmd_queue));\r\nif (!(pcmd)) {\r\nr8712_unregister_cmd_alive(padapter);\r\ncontinue;\r\n}\r\npcmdbuf = (unsigned int *)pcmdpriv->cmd_buf;\r\npdesc = (struct tx_desc *)pcmdbuf;\r\nmemset(pdesc, 0, TXDESC_SIZE);\r\npcmd = cmd_hdl_filter(padapter, pcmd);\r\nif (pcmd) {\r\nstruct dvobj_priv *pdvobj = &padapter->dvobjpriv;\r\nu8 blnPending = 0;\r\npcmdpriv->cmd_issued_cnt++;\r\ncmdsz = round_up(pcmd->cmdsz, 8);\r\nwr_sz = TXDESC_SIZE + 8 + cmdsz;\r\npdesc->txdw0 |= cpu_to_le32((wr_sz - TXDESC_SIZE) &\r\n0x0000ffff);\r\nif (pdvobj->ishighspeed) {\r\nif ((wr_sz % 512) == 0)\r\nblnPending = 1;\r\n} else {\r\nif ((wr_sz % 64) == 0)\r\nblnPending = 1;\r\n}\r\nif (blnPending)\r\npdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE +\r\nOFFSET_SZ + 8) << OFFSET_SHT) &\r\n0x00ff0000);\r\nelse {\r\npdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE +\r\nOFFSET_SZ) <<\r\nOFFSET_SHT) &\r\n0x00ff0000);\r\n}\r\npdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\r\npdesc->txdw1 |= cpu_to_le32((0x13 << QSEL_SHT) &\r\n0x00001f00);\r\npcmdbuf += (TXDESC_SIZE >> 2);\r\n*pcmdbuf = cpu_to_le32((cmdsz & 0x0000ffff) |\r\n(pcmd->cmdcode << 16) |\r\n(pcmdpriv->cmd_seq << 24));\r\npcmdbuf += 2;\r\nmemcpy((u8 *)pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);\r\nwhile (check_cmd_fifo(padapter, wr_sz) == _FAIL) {\r\nif (padapter->bDriverStopped ||\r\npadapter->bSurpriseRemoved)\r\nbreak;\r\nmsleep(100);\r\ncontinue;\r\n}\r\nif (blnPending)\r\nwr_sz += 8;\r\nr8712_write_mem(padapter, RTL8712_DMA_H2CCMD, wr_sz,\r\n(u8 *)pdesc);\r\npcmdpriv->cmd_seq++;\r\nif (pcmd->cmdcode == GEN_CMD_CODE(_CreateBss)) {\r\npcmd->res = H2C_SUCCESS;\r\npcmd_callback = cmd_callback[pcmd->\r\ncmdcode].callback;\r\nif (pcmd_callback)\r\npcmd_callback(padapter, pcmd);\r\ncontinue;\r\n}\r\nif (pcmd->cmdcode == GEN_CMD_CODE(_SetPwrMode)) {\r\nif (padapter->pwrctrlpriv.bSleep) {\r\n_enter_pwrlock(&(padapter->\r\npwrctrlpriv.lock));\r\nr8712_set_rpwm(padapter, PS_STATE_S2);\r\nup(&padapter->pwrctrlpriv.lock);\r\n}\r\n}\r\nr8712_free_cmd_obj(pcmd);\r\nif (list_empty(&pcmdpriv->cmd_queue.queue)) {\r\nr8712_unregister_cmd_alive(padapter);\r\ncontinue;\r\n} else {\r\ngoto _next;\r\n}\r\n} else {\r\ngoto _next;\r\n}\r\nflush_signals_thread();\r\n}\r\ndo {\r\npcmd = r8712_dequeue_cmd(&(pcmdpriv->cmd_queue));\r\nif (!pcmd)\r\nbreak;\r\nr8712_free_cmd_obj(pcmd);\r\n} while (1);\r\nup(&pcmdpriv->terminate_cmdthread_sema);\r\nthread_exit();\r\n}\r\nvoid r8712_event_handle(struct _adapter *padapter, uint *peventbuf)\r\n{\r\nu8 evt_code, evt_seq;\r\nu16 evt_sz;\r\nvoid (*event_callback)(struct _adapter *dev, u8 *pbuf);\r\nstruct evt_priv *pevt_priv = &(padapter->evtpriv);\r\nif (!peventbuf)\r\ngoto _abort_event_;\r\nevt_sz = (u16)(le32_to_cpu(*peventbuf) & 0xffff);\r\nevt_seq = (u8)((le32_to_cpu(*peventbuf) >> 24) & 0x7f);\r\nevt_code = (u8)((le32_to_cpu(*peventbuf) >> 16) & 0xff);\r\nif ((evt_seq & 0x7f) != pevt_priv->event_seq) {\r\npevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\r\ngoto _abort_event_;\r\n}\r\nif (evt_code >= MAX_C2HEVT) {\r\npevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\r\ngoto _abort_event_;\r\n} else if ((evt_code == GEN_EVT_CODE(_Survey)) &&\r\n(evt_sz > sizeof(struct wlan_bssid_ex))) {\r\npevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\r\ngoto _abort_event_;\r\n}\r\nif ((wlanevents[evt_code].parmsize) &&\r\n(wlanevents[evt_code].parmsize != evt_sz)) {\r\npevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\r\ngoto _abort_event_;\r\n} else if ((evt_sz == 0) && (evt_code != GEN_EVT_CODE(_WPS_PBC))) {\r\npevt_priv->event_seq = ((evt_seq + 1) & 0x7f);\r\ngoto _abort_event_;\r\n}\r\npevt_priv->event_seq++;\r\nif (pevt_priv->event_seq > 127)\r\npevt_priv->event_seq = 0;\r\npeventbuf = peventbuf + 2;\r\nevent_callback = wlanevents[evt_code].event_callback;\r\nif (event_callback)\r\nevent_callback(padapter, (u8 *)peventbuf);\r\npevt_priv->evt_done_cnt++;\r\n_abort_event_:\r\nreturn;\r\n}
