static int __init ircomm_init(void)\r\n{\r\nircomm = hashbin_new(HB_LOCK);\r\nif (ircomm == NULL) {\r\nnet_err_ratelimited("%s(), can't allocate hashbin!\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\n#ifdef CONFIG_PROC_FS\r\n{ struct proc_dir_entry *ent;\r\nent = proc_create("ircomm", 0, proc_irda, &ircomm_proc_fops);\r\nif (!ent) {\r\nprintk(KERN_ERR "ircomm_init: can't create /proc entry!\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\n#endif\r\nnet_info_ratelimited("IrCOMM protocol (Dag Brattli)\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ircomm_cleanup(void)\r\n{\r\nhashbin_delete(ircomm, (FREE_FUNC) __ircomm_close);\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("ircomm", proc_irda);\r\n#endif\r\n}\r\nstruct ircomm_cb *ircomm_open(notify_t *notify, __u8 service_type, int line)\r\n{\r\nstruct ircomm_cb *self = NULL;\r\nint ret;\r\npr_debug("%s(), service_type=0x%02x\n", __func__ ,\r\nservice_type);\r\nIRDA_ASSERT(ircomm != NULL, return NULL;);\r\nself = kzalloc(sizeof(struct ircomm_cb), GFP_KERNEL);\r\nif (self == NULL)\r\nreturn NULL;\r\nself->notify = *notify;\r\nself->magic = IRCOMM_MAGIC;\r\nif (service_type & IRCOMM_3_WIRE_RAW) {\r\nself->flow_status = FLOW_START;\r\nret = ircomm_open_lsap(self);\r\n} else\r\nret = ircomm_open_tsap(self);\r\nif (ret < 0) {\r\nkfree(self);\r\nreturn NULL;\r\n}\r\nself->service_type = service_type;\r\nself->line = line;\r\nhashbin_insert(ircomm, (irda_queue_t *) self, line, NULL);\r\nircomm_next_state(self, IRCOMM_IDLE);\r\nreturn self;\r\n}\r\nstatic int __ircomm_close(struct ircomm_cb *self)\r\n{\r\nircomm_do_event(self, IRCOMM_DISCONNECT_REQUEST, NULL, NULL);\r\nif (self->tsap) {\r\nirttp_close_tsap(self->tsap);\r\nself->tsap = NULL;\r\n}\r\nif (self->lsap) {\r\nirlmp_close_lsap(self->lsap);\r\nself->lsap = NULL;\r\n}\r\nself->magic = 0;\r\nkfree(self);\r\nreturn 0;\r\n}\r\nint ircomm_close(struct ircomm_cb *self)\r\n{\r\nstruct ircomm_cb *entry;\r\nIRDA_ASSERT(self != NULL, return -EIO;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -EIO;);\r\nentry = hashbin_remove(ircomm, self->line, NULL);\r\nIRDA_ASSERT(entry == self, return -1;);\r\nreturn __ircomm_close(self);\r\n}\r\nint ircomm_connect_request(struct ircomm_cb *self, __u8 dlsap_sel,\r\n__u32 saddr, __u32 daddr, struct sk_buff *skb,\r\n__u8 service_type)\r\n{\r\nstruct ircomm_info info;\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -1;);\r\nself->service_type= service_type;\r\ninfo.dlsap_sel = dlsap_sel;\r\ninfo.saddr = saddr;\r\ninfo.daddr = daddr;\r\nret = ircomm_do_event(self, IRCOMM_CONNECT_REQUEST, skb, &info);\r\nreturn ret;\r\n}\r\nvoid ircomm_connect_indication(struct ircomm_cb *self, struct sk_buff *skb,\r\nstruct ircomm_info *info)\r\n{\r\nif (self->notify.connect_indication)\r\nself->notify.connect_indication(self->notify.instance, self,\r\ninfo->qos, info->max_data_size,\r\ninfo->max_header_size, skb);\r\nelse {\r\npr_debug("%s(), missing handler\n", __func__);\r\n}\r\n}\r\nint ircomm_connect_response(struct ircomm_cb *self, struct sk_buff *userdata)\r\n{\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -1;);\r\nret = ircomm_do_event(self, IRCOMM_CONNECT_RESPONSE, userdata, NULL);\r\nreturn ret;\r\n}\r\nvoid ircomm_connect_confirm(struct ircomm_cb *self, struct sk_buff *skb,\r\nstruct ircomm_info *info)\r\n{\r\nif (self->notify.connect_confirm )\r\nself->notify.connect_confirm(self->notify.instance,\r\nself, info->qos,\r\ninfo->max_data_size,\r\ninfo->max_header_size, skb);\r\nelse {\r\npr_debug("%s(), missing handler\n", __func__);\r\n}\r\n}\r\nint ircomm_data_request(struct ircomm_cb *self, struct sk_buff *skb)\r\n{\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -EFAULT;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -EFAULT;);\r\nIRDA_ASSERT(skb != NULL, return -EFAULT;);\r\nret = ircomm_do_event(self, IRCOMM_DATA_REQUEST, skb, NULL);\r\nreturn ret;\r\n}\r\nvoid ircomm_data_indication(struct ircomm_cb *self, struct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(skb->len > 0, return;);\r\nif (self->notify.data_indication)\r\nself->notify.data_indication(self->notify.instance, self, skb);\r\nelse {\r\npr_debug("%s(), missing handler\n", __func__);\r\n}\r\n}\r\nvoid ircomm_process_data(struct ircomm_cb *self, struct sk_buff *skb)\r\n{\r\nint clen;\r\nIRDA_ASSERT(skb->len > 0, return;);\r\nclen = skb->data[0];\r\nif (unlikely(skb->len < (clen + 1))) {\r\npr_debug("%s() throwing away illegal frame\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (clen > 0)\r\nircomm_control_indication(self, skb, clen);\r\nskb_pull(skb, clen+1);\r\nif (skb->len)\r\nircomm_data_indication(self, skb);\r\nelse {\r\npr_debug("%s(), data was control info only!\n",\r\n__func__);\r\n}\r\n}\r\nint ircomm_control_request(struct ircomm_cb *self, struct sk_buff *skb)\r\n{\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -EFAULT;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -EFAULT;);\r\nIRDA_ASSERT(skb != NULL, return -EFAULT;);\r\nret = ircomm_do_event(self, IRCOMM_CONTROL_REQUEST, skb, NULL);\r\nreturn ret;\r\n}\r\nstatic void ircomm_control_indication(struct ircomm_cb *self,\r\nstruct sk_buff *skb, int clen)\r\n{\r\nif (self->notify.udata_indication) {\r\nstruct sk_buff *ctrl_skb;\r\nctrl_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (!ctrl_skb)\r\nreturn;\r\nskb_trim(ctrl_skb, clen+1);\r\nself->notify.udata_indication(self->notify.instance, self,\r\nctrl_skb);\r\ndev_kfree_skb(ctrl_skb);\r\n} else {\r\npr_debug("%s(), missing handler\n", __func__);\r\n}\r\n}\r\nint ircomm_disconnect_request(struct ircomm_cb *self, struct sk_buff *userdata)\r\n{\r\nstruct ircomm_info info;\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -1;);\r\nret = ircomm_do_event(self, IRCOMM_DISCONNECT_REQUEST, userdata,\r\n&info);\r\nreturn ret;\r\n}\r\nvoid ircomm_disconnect_indication(struct ircomm_cb *self, struct sk_buff *skb,\r\nstruct ircomm_info *info)\r\n{\r\nIRDA_ASSERT(info != NULL, return;);\r\nif (self->notify.disconnect_indication) {\r\nself->notify.disconnect_indication(self->notify.instance, self,\r\ninfo->reason, skb);\r\n} else {\r\npr_debug("%s(), missing handler\n", __func__);\r\n}\r\n}\r\nvoid ircomm_flow_request(struct ircomm_cb *self, LOCAL_FLOW flow)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\nif (self->service_type == IRCOMM_3_WIRE_RAW)\r\nreturn;\r\nirttp_flow_request(self->tsap, flow);\r\n}\r\nstatic void *ircomm_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct ircomm_cb *self;\r\nloff_t off = 0;\r\nspin_lock_irq(&ircomm->hb_spinlock);\r\nfor (self = (struct ircomm_cb *) hashbin_get_first(ircomm);\r\nself != NULL;\r\nself = (struct ircomm_cb *) hashbin_get_next(ircomm)) {\r\nif (off++ == *pos)\r\nbreak;\r\n}\r\nreturn self;\r\n}\r\nstatic void *ircomm_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn (void *) hashbin_get_next(ircomm);\r\n}\r\nstatic void ircomm_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nspin_unlock_irq(&ircomm->hb_spinlock);\r\n}\r\nstatic int ircomm_seq_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct ircomm_cb *self = v;\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -EINVAL; );\r\nif(self->line < 0x10)\r\nseq_printf(seq, "ircomm%d", self->line);\r\nelse\r\nseq_printf(seq, "irlpt%d", self->line - 0x10);\r\nseq_printf(seq,\r\n" state: %s, slsap_sel: %#02x, dlsap_sel: %#02x, mode:",\r\nircomm_state[ self->state],\r\nself->slsap_sel, self->dlsap_sel);\r\nif(self->service_type & IRCOMM_3_WIRE_RAW)\r\nseq_printf(seq, " 3-wire-raw");\r\nif(self->service_type & IRCOMM_3_WIRE)\r\nseq_printf(seq, " 3-wire");\r\nif(self->service_type & IRCOMM_9_WIRE)\r\nseq_printf(seq, " 9-wire");\r\nif(self->service_type & IRCOMM_CENTRONICS)\r\nseq_printf(seq, " Centronics");\r\nseq_putc(seq, '\n');\r\nreturn 0;\r\n}\r\nstatic int ircomm_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ircomm_seq_ops);\r\n}
