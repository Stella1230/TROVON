static int swap_cgroup_prepare(int type)\r\n{\r\nstruct page *page;\r\nstruct swap_cgroup_ctrl *ctrl;\r\nunsigned long idx, max;\r\nctrl = &swap_cgroup_ctrl[type];\r\nfor (idx = 0; idx < ctrl->length; idx++) {\r\npage = alloc_page(GFP_KERNEL | __GFP_ZERO);\r\nif (!page)\r\ngoto not_enough_page;\r\nctrl->map[idx] = page;\r\n}\r\nreturn 0;\r\nnot_enough_page:\r\nmax = idx;\r\nfor (idx = 0; idx < max; idx++)\r\n__free_page(ctrl->map[idx]);\r\nreturn -ENOMEM;\r\n}\r\nstatic struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\r\nstruct swap_cgroup_ctrl **ctrlp)\r\n{\r\npgoff_t offset = swp_offset(ent);\r\nstruct swap_cgroup_ctrl *ctrl;\r\nstruct page *mappage;\r\nstruct swap_cgroup *sc;\r\nctrl = &swap_cgroup_ctrl[swp_type(ent)];\r\nif (ctrlp)\r\n*ctrlp = ctrl;\r\nmappage = ctrl->map[offset / SC_PER_PAGE];\r\nsc = page_address(mappage);\r\nreturn sc + offset % SC_PER_PAGE;\r\n}\r\nunsigned short swap_cgroup_cmpxchg(swp_entry_t ent,\r\nunsigned short old, unsigned short new)\r\n{\r\nstruct swap_cgroup_ctrl *ctrl;\r\nstruct swap_cgroup *sc;\r\nunsigned long flags;\r\nunsigned short retval;\r\nsc = lookup_swap_cgroup(ent, &ctrl);\r\nspin_lock_irqsave(&ctrl->lock, flags);\r\nretval = sc->id;\r\nif (retval == old)\r\nsc->id = new;\r\nelse\r\nretval = 0;\r\nspin_unlock_irqrestore(&ctrl->lock, flags);\r\nreturn retval;\r\n}\r\nunsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id)\r\n{\r\nstruct swap_cgroup_ctrl *ctrl;\r\nstruct swap_cgroup *sc;\r\nunsigned short old;\r\nunsigned long flags;\r\nsc = lookup_swap_cgroup(ent, &ctrl);\r\nspin_lock_irqsave(&ctrl->lock, flags);\r\nold = sc->id;\r\nsc->id = id;\r\nspin_unlock_irqrestore(&ctrl->lock, flags);\r\nreturn old;\r\n}\r\nunsigned short lookup_swap_cgroup_id(swp_entry_t ent)\r\n{\r\nreturn lookup_swap_cgroup(ent, NULL)->id;\r\n}\r\nint swap_cgroup_swapon(int type, unsigned long max_pages)\r\n{\r\nvoid *array;\r\nunsigned long array_size;\r\nunsigned long length;\r\nstruct swap_cgroup_ctrl *ctrl;\r\nif (!do_swap_account)\r\nreturn 0;\r\nlength = DIV_ROUND_UP(max_pages, SC_PER_PAGE);\r\narray_size = length * sizeof(void *);\r\narray = vzalloc(array_size);\r\nif (!array)\r\ngoto nomem;\r\nctrl = &swap_cgroup_ctrl[type];\r\nmutex_lock(&swap_cgroup_mutex);\r\nctrl->length = length;\r\nctrl->map = array;\r\nspin_lock_init(&ctrl->lock);\r\nif (swap_cgroup_prepare(type)) {\r\nctrl->map = NULL;\r\nctrl->length = 0;\r\nmutex_unlock(&swap_cgroup_mutex);\r\nvfree(array);\r\ngoto nomem;\r\n}\r\nmutex_unlock(&swap_cgroup_mutex);\r\nreturn 0;\r\nnomem:\r\npr_info("couldn't allocate enough memory for swap_cgroup\n");\r\npr_info("swap_cgroup can be disabled by swapaccount=0 boot option\n");\r\nreturn -ENOMEM;\r\n}\r\nvoid swap_cgroup_swapoff(int type)\r\n{\r\nstruct page **map;\r\nunsigned long i, length;\r\nstruct swap_cgroup_ctrl *ctrl;\r\nif (!do_swap_account)\r\nreturn;\r\nmutex_lock(&swap_cgroup_mutex);\r\nctrl = &swap_cgroup_ctrl[type];\r\nmap = ctrl->map;\r\nlength = ctrl->length;\r\nctrl->map = NULL;\r\nctrl->length = 0;\r\nmutex_unlock(&swap_cgroup_mutex);\r\nif (map) {\r\nfor (i = 0; i < length; i++) {\r\nstruct page *page = map[i];\r\nif (page)\r\n__free_page(page);\r\n}\r\nvfree(map);\r\n}\r\n}
