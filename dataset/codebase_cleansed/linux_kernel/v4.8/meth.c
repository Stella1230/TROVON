static inline void load_eaddr(struct net_device *dev)\r\n{\r\nint i;\r\nu64 macaddr;\r\nDPRINTK("Loading MAC Address: %pM\n", dev->dev_addr);\r\nmacaddr = 0;\r\nfor (i = 0; i < 6; i++)\r\nmacaddr |= (u64)dev->dev_addr[i] << ((5 - i) * 8);\r\nmace->eth.mac_addr = macaddr;\r\n}\r\nstatic unsigned long mdio_read(struct meth_private *priv, unsigned long phyreg)\r\n{\r\nunsigned long rval;\r\nWAIT_FOR_PHY(rval);\r\nmace->eth.phy_regs = (priv->phy_addr << 5) | (phyreg & 0x1f);\r\nudelay(25);\r\nmace->eth.phy_trans_go = 1;\r\nudelay(25);\r\nWAIT_FOR_PHY(rval);\r\nreturn rval & MDIO_DATA_MASK;\r\n}\r\nstatic int mdio_probe(struct meth_private *priv)\r\n{\r\nint i;\r\nunsigned long p2, p3, flags;\r\nif(priv->phy_addr>=0&&priv->phy_addr<32)\r\nreturn 0;\r\nspin_lock_irqsave(&priv->meth_lock, flags);\r\nfor (i=0;i<32;++i){\r\npriv->phy_addr=i;\r\np2=mdio_read(priv,2);\r\np3=mdio_read(priv,3);\r\n#if MFE_DEBUG>=2\r\nswitch ((p2<<12)|(p3>>4)){\r\ncase PHY_QS6612X:\r\nDPRINTK("PHY is QS6612X\n");\r\nbreak;\r\ncase PHY_ICS1889:\r\nDPRINTK("PHY is ICS1889\n");\r\nbreak;\r\ncase PHY_ICS1890:\r\nDPRINTK("PHY is ICS1890\n");\r\nbreak;\r\ncase PHY_DP83840:\r\nDPRINTK("PHY is DP83840\n");\r\nbreak;\r\n}\r\n#endif\r\nif(p2!=0xffff&&p2!=0x0000){\r\nDPRINTK("PHY code: %x\n",(p2<<12)|(p3>>4));\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->meth_lock, flags);\r\nif(priv->phy_addr<32) {\r\nreturn 0;\r\n}\r\nDPRINTK("Oopsie! PHY is not known!\n");\r\npriv->phy_addr=-1;\r\nreturn -ENODEV;\r\n}\r\nstatic void meth_check_link(struct net_device *dev)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nunsigned long mii_advertising = mdio_read(priv, 4);\r\nunsigned long mii_partner = mdio_read(priv, 5);\r\nunsigned long negotiated = mii_advertising & mii_partner;\r\nunsigned long duplex, speed;\r\nif (mii_partner == 0xffff)\r\nreturn;\r\nspeed = (negotiated & 0x0380) ? METH_100MBIT : 0;\r\nduplex = ((negotiated & 0x0100) || (negotiated & 0x01C0) == 0x0040) ?\r\nMETH_PHY_FDX : 0;\r\nif ((priv->mac_ctrl & METH_PHY_FDX) ^ duplex) {\r\nDPRINTK("Setting %s-duplex\n", duplex ? "full" : "half");\r\nif (duplex)\r\npriv->mac_ctrl |= METH_PHY_FDX;\r\nelse\r\npriv->mac_ctrl &= ~METH_PHY_FDX;\r\nmace->eth.mac_ctrl = priv->mac_ctrl;\r\n}\r\nif ((priv->mac_ctrl & METH_100MBIT) ^ speed) {\r\nDPRINTK("Setting %dMbs mode\n", speed ? 100 : 10);\r\nif (duplex)\r\npriv->mac_ctrl |= METH_100MBIT;\r\nelse\r\npriv->mac_ctrl &= ~METH_100MBIT;\r\nmace->eth.mac_ctrl = priv->mac_ctrl;\r\n}\r\n}\r\nstatic int meth_init_tx_ring(struct meth_private *priv)\r\n{\r\npriv->tx_ring = dma_zalloc_coherent(NULL, TX_RING_BUFFER_SIZE,\r\n&priv->tx_ring_dma, GFP_ATOMIC);\r\nif (!priv->tx_ring)\r\nreturn -ENOMEM;\r\npriv->tx_count = priv->tx_read = priv->tx_write = 0;\r\nmace->eth.tx_ring_base = priv->tx_ring_dma;\r\nmemset(priv->tx_skbs, 0, sizeof(priv->tx_skbs));\r\nmemset(priv->tx_skb_dmas, 0, sizeof(priv->tx_skb_dmas));\r\nreturn 0;\r\n}\r\nstatic int meth_init_rx_ring(struct meth_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_RING_ENTRIES; i++) {\r\npriv->rx_skbs[i] = alloc_skb(METH_RX_BUFF_SIZE, 0);\r\nskb_reserve(priv->rx_skbs[i],METH_RX_HEAD);\r\npriv->rx_ring[i]=(rx_packet*)(priv->rx_skbs[i]->head);\r\npriv->rx_ring_dmas[i] =\r\ndma_map_single(NULL, priv->rx_ring[i],\r\nMETH_RX_BUFF_SIZE, DMA_FROM_DEVICE);\r\nmace->eth.rx_fifo = priv->rx_ring_dmas[i];\r\n}\r\npriv->rx_write = 0;\r\nreturn 0;\r\n}\r\nstatic void meth_free_tx_ring(struct meth_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < TX_RING_ENTRIES; i++) {\r\nif (priv->tx_skbs[i])\r\ndev_kfree_skb(priv->tx_skbs[i]);\r\npriv->tx_skbs[i] = NULL;\r\n}\r\ndma_free_coherent(NULL, TX_RING_BUFFER_SIZE, priv->tx_ring,\r\npriv->tx_ring_dma);\r\n}\r\nstatic void meth_free_rx_ring(struct meth_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_RING_ENTRIES; i++) {\r\ndma_unmap_single(NULL, priv->rx_ring_dmas[i],\r\nMETH_RX_BUFF_SIZE, DMA_FROM_DEVICE);\r\npriv->rx_ring[i] = 0;\r\npriv->rx_ring_dmas[i] = 0;\r\nkfree_skb(priv->rx_skbs[i]);\r\n}\r\n}\r\nint meth_reset(struct net_device *dev)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nmace->eth.mac_ctrl = SGI_MAC_RESET;\r\nudelay(1);\r\nmace->eth.mac_ctrl = 0;\r\nudelay(25);\r\nload_eaddr(dev);\r\nif (mdio_probe(priv) < 0) {\r\nDPRINTK("Unable to find PHY\n");\r\nreturn -ENODEV;\r\n}\r\npriv->mac_ctrl = METH_ACCEPT_MCAST | METH_DEFAULT_IPG;\r\nif (dev->flags & IFF_PROMISC)\r\npriv->mac_ctrl |= METH_PROMISC;\r\nmace->eth.mac_ctrl = priv->mac_ctrl;\r\nmeth_check_link(dev);\r\npriv->dma_ctrl = (4 << METH_RX_OFFSET_SHIFT) |\r\n(RX_RING_ENTRIES << METH_RX_DEPTH_SHIFT);\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nreturn 0;\r\n}\r\nstatic int meth_open(struct net_device *dev)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nint ret;\r\npriv->phy_addr = -1;\r\nret = meth_reset(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = meth_init_tx_ring(priv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = meth_init_rx_ring(priv);\r\nif (ret < 0)\r\ngoto out_free_tx_ring;\r\nret = request_irq(dev->irq, meth_interrupt, 0, meth_str, dev);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Can't get irq %d\n", dev->name, dev->irq);\r\ngoto out_free_rx_ring;\r\n}\r\npriv->dma_ctrl |= METH_DMA_TX_EN |\r\nMETH_DMA_RX_EN | METH_DMA_RX_INT_EN;\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nDPRINTK("About to start queue\n");\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_free_rx_ring:\r\nmeth_free_rx_ring(priv);\r\nout_free_tx_ring:\r\nmeth_free_tx_ring(priv);\r\nreturn ret;\r\n}\r\nstatic int meth_release(struct net_device *dev)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nDPRINTK("Stopping queue\n");\r\nnetif_stop_queue(dev);\r\npriv->dma_ctrl &= ~(METH_DMA_TX_EN | METH_DMA_TX_INT_EN |\r\nMETH_DMA_RX_EN | METH_DMA_RX_INT_EN);\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nfree_irq(dev->irq, dev);\r\nmeth_free_tx_ring(priv);\r\nmeth_free_rx_ring(priv);\r\nreturn 0;\r\n}\r\nstatic void meth_rx(struct net_device* dev, unsigned long int_status)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long status, flags;\r\nstruct meth_private *priv = netdev_priv(dev);\r\nunsigned long fifo_rptr = (int_status & METH_INT_RX_RPTR_MASK) >> 8;\r\nspin_lock_irqsave(&priv->meth_lock, flags);\r\npriv->dma_ctrl &= ~METH_DMA_RX_INT_EN;\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nspin_unlock_irqrestore(&priv->meth_lock, flags);\r\nif (int_status & METH_INT_RX_UNDERFLOW) {\r\nfifo_rptr = (fifo_rptr - 1) & 0x0f;\r\n}\r\nwhile (priv->rx_write != fifo_rptr) {\r\ndma_unmap_single(NULL, priv->rx_ring_dmas[priv->rx_write],\r\nMETH_RX_BUFF_SIZE, DMA_FROM_DEVICE);\r\nstatus = priv->rx_ring[priv->rx_write]->status.raw;\r\n#if MFE_DEBUG\r\nif (!(status & METH_RX_ST_VALID)) {\r\nDPRINTK("Not received? status=%016lx\n",status);\r\n}\r\n#endif\r\nif ((!(status & METH_RX_STATUS_ERRORS)) && (status & METH_RX_ST_VALID)) {\r\nint len = (status & 0xffff) - 4;\r\nif (len < 60 || len > 1518) {\r\nprintk(KERN_DEBUG "%s: bogus packet size: %ld, status=%#2Lx.\n",\r\ndev->name, priv->rx_write,\r\npriv->rx_ring[priv->rx_write]->status.raw);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\nskb = priv->rx_skbs[priv->rx_write];\r\n} else {\r\nskb = alloc_skb(METH_RX_BUFF_SIZE, GFP_ATOMIC);\r\nif (!skb) {\r\nDPRINTK("No mem: dropping packet\n");\r\ndev->stats.rx_dropped++;\r\nskb = priv->rx_skbs[priv->rx_write];\r\n} else {\r\nstruct sk_buff *skb_c = priv->rx_skbs[priv->rx_write];\r\nskb_reserve(skb, METH_RX_HEAD);\r\nskb_put(skb_c, len);\r\npriv->rx_skbs[priv->rx_write] = skb;\r\nskb_c->protocol = eth_type_trans(skb_c, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nnetif_rx(skb_c);\r\n}\r\n}\r\n} else {\r\ndev->stats.rx_errors++;\r\nskb=priv->rx_skbs[priv->rx_write];\r\n#if MFE_DEBUG>0\r\nprintk(KERN_WARNING "meth: RX error: status=0x%016lx\n",status);\r\nif(status&METH_RX_ST_RCV_CODE_VIOLATION)\r\nprintk(KERN_WARNING "Receive Code Violation\n");\r\nif(status&METH_RX_ST_CRC_ERR)\r\nprintk(KERN_WARNING "CRC error\n");\r\nif(status&METH_RX_ST_INV_PREAMBLE_CTX)\r\nprintk(KERN_WARNING "Invalid Preamble Context\n");\r\nif(status&METH_RX_ST_LONG_EVT_SEEN)\r\nprintk(KERN_WARNING "Long Event Seen...\n");\r\nif(status&METH_RX_ST_BAD_PACKET)\r\nprintk(KERN_WARNING "Bad Packet\n");\r\nif(status&METH_RX_ST_CARRIER_EVT_SEEN)\r\nprintk(KERN_WARNING "Carrier Event Seen\n");\r\n#endif\r\n}\r\npriv->rx_ring[priv->rx_write] = (rx_packet*)skb->head;\r\npriv->rx_ring[priv->rx_write]->status.raw = 0;\r\npriv->rx_ring_dmas[priv->rx_write] =\r\ndma_map_single(NULL, priv->rx_ring[priv->rx_write],\r\nMETH_RX_BUFF_SIZE, DMA_FROM_DEVICE);\r\nmace->eth.rx_fifo = priv->rx_ring_dmas[priv->rx_write];\r\nADVANCE_RX_PTR(priv->rx_write);\r\n}\r\nspin_lock_irqsave(&priv->meth_lock, flags);\r\npriv->dma_ctrl |= METH_DMA_RX_INT_EN | METH_DMA_RX_EN;\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nmace->eth.int_stat = METH_INT_RX_THRESHOLD;\r\nspin_unlock_irqrestore(&priv->meth_lock, flags);\r\n}\r\nstatic int meth_tx_full(struct net_device *dev)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nreturn priv->tx_count >= TX_RING_ENTRIES - 1;\r\n}\r\nstatic void meth_tx_cleanup(struct net_device* dev, unsigned long int_status)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nunsigned long status, flags;\r\nstruct sk_buff *skb;\r\nunsigned long rptr = (int_status&TX_INFO_RPTR) >> 16;\r\nspin_lock_irqsave(&priv->meth_lock, flags);\r\npriv->dma_ctrl &= ~(METH_DMA_TX_INT_EN);\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nwhile (priv->tx_read != rptr) {\r\nskb = priv->tx_skbs[priv->tx_read];\r\nstatus = priv->tx_ring[priv->tx_read].header.raw;\r\n#if MFE_DEBUG>=1\r\nif (priv->tx_read == priv->tx_write)\r\nDPRINTK("Auchi! tx_read=%d,tx_write=%d,rptr=%d?\n", priv->tx_read, priv->tx_write,rptr);\r\n#endif\r\nif (status & METH_TX_ST_DONE) {\r\nif (status & METH_TX_ST_SUCCESS){\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\n} else {\r\ndev->stats.tx_errors++;\r\n#if MFE_DEBUG>=1\r\nDPRINTK("TX error: status=%016lx <",status);\r\nif(status & METH_TX_ST_SUCCESS)\r\nprintk(" SUCCESS");\r\nif(status & METH_TX_ST_TOOLONG)\r\nprintk(" TOOLONG");\r\nif(status & METH_TX_ST_UNDERRUN)\r\nprintk(" UNDERRUN");\r\nif(status & METH_TX_ST_EXCCOLL)\r\nprintk(" EXCCOLL");\r\nif(status & METH_TX_ST_DEFER)\r\nprintk(" DEFER");\r\nif(status & METH_TX_ST_LATECOLL)\r\nprintk(" LATECOLL");\r\nprintk(" >\n");\r\n#endif\r\n}\r\n} else {\r\nDPRINTK("RPTR points us here, but packet not done?\n");\r\nbreak;\r\n}\r\ndev_kfree_skb_irq(skb);\r\npriv->tx_skbs[priv->tx_read] = NULL;\r\npriv->tx_ring[priv->tx_read].header.raw = 0;\r\npriv->tx_read = (priv->tx_read+1)&(TX_RING_ENTRIES-1);\r\npriv->tx_count--;\r\n}\r\nif (netif_queue_stopped(dev) && !meth_tx_full(dev)) {\r\nnetif_wake_queue(dev);\r\n}\r\nmace->eth.int_stat = METH_INT_TX_EMPTY | METH_INT_TX_PKT;\r\nspin_unlock_irqrestore(&priv->meth_lock, flags);\r\n}\r\nstatic void meth_error(struct net_device* dev, unsigned status)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nprintk(KERN_WARNING "meth: error status: 0x%08x\n",status);\r\nif (status & (METH_INT_TX_LINK_FAIL))\r\nprintk(KERN_WARNING "meth: link failure\n");\r\nif (status & (METH_INT_MEM_ERROR))\r\nprintk(KERN_WARNING "meth: memory error\n");\r\nif (status & (METH_INT_TX_ABORT))\r\nprintk(KERN_WARNING "meth: aborted\n");\r\nif (status & (METH_INT_RX_OVERFLOW))\r\nprintk(KERN_WARNING "meth: Rx overflow\n");\r\nif (status & (METH_INT_RX_UNDERFLOW)) {\r\nprintk(KERN_WARNING "meth: Rx underflow\n");\r\nspin_lock_irqsave(&priv->meth_lock, flags);\r\nmace->eth.int_stat = METH_INT_RX_UNDERFLOW;\r\npriv->dma_ctrl &= ~METH_DMA_RX_EN;\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nDPRINTK("Disabled meth Rx DMA temporarily\n");\r\nspin_unlock_irqrestore(&priv->meth_lock, flags);\r\n}\r\nmace->eth.int_stat = METH_INT_ERROR;\r\n}\r\nstatic irqreturn_t meth_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct meth_private *priv = netdev_priv(dev);\r\nunsigned long status;\r\nstatus = mace->eth.int_stat;\r\nwhile (status & 0xff) {\r\nif (status & METH_INT_ERROR) {\r\nmeth_error(dev, status);\r\n}\r\nif (status & (METH_INT_TX_EMPTY | METH_INT_TX_PKT)) {\r\nmeth_tx_cleanup(dev, status);\r\n}\r\nif (status & METH_INT_RX_THRESHOLD) {\r\nif (!(priv->dma_ctrl & METH_DMA_RX_INT_EN))\r\nbreak;\r\nmeth_rx(dev, status);\r\n}\r\nstatus = mace->eth.int_stat;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void meth_tx_short_prepare(struct meth_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\ntx_packet *desc = &priv->tx_ring[priv->tx_write];\r\nint len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;\r\ndesc->header.raw = METH_TX_CMD_INT_EN | (len-1) | ((128-len) << 16);\r\nskb_copy_from_linear_data(skb, desc->data.dt + (120 - len), skb->len);\r\nif (skb->len < len)\r\nmemset(desc->data.dt + 120 - len + skb->len, 0, len-skb->len);\r\n}\r\nstatic void meth_tx_1page_prepare(struct meth_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\ntx_packet *desc = &priv->tx_ring[priv->tx_write];\r\nvoid *buffer_data = (void *)(((unsigned long)skb->data + 7) & ~7);\r\nint unaligned_len = (int)((unsigned long)buffer_data - (unsigned long)skb->data);\r\nint buffer_len = skb->len - unaligned_len;\r\ndma_addr_t catbuf;\r\ndesc->header.raw = METH_TX_CMD_INT_EN | TX_CATBUF1 | (skb->len - 1);\r\nif (unaligned_len) {\r\nskb_copy_from_linear_data(skb, desc->data.dt + (120 - unaligned_len),\r\nunaligned_len);\r\ndesc->header.raw |= (128 - unaligned_len) << 16;\r\n}\r\ncatbuf = dma_map_single(NULL, buffer_data, buffer_len,\r\nDMA_TO_DEVICE);\r\ndesc->data.cat_buf[0].form.start_addr = catbuf >> 3;\r\ndesc->data.cat_buf[0].form.len = buffer_len - 1;\r\n}\r\nstatic void meth_tx_2page_prepare(struct meth_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\ntx_packet *desc = &priv->tx_ring[priv->tx_write];\r\nvoid *buffer1_data = (void *)(((unsigned long)skb->data + 7) & ~7);\r\nvoid *buffer2_data = (void *)PAGE_ALIGN((unsigned long)skb->data);\r\nint unaligned_len = (int)((unsigned long)buffer1_data - (unsigned long)skb->data);\r\nint buffer1_len = (int)((unsigned long)buffer2_data - (unsigned long)buffer1_data);\r\nint buffer2_len = skb->len - buffer1_len - unaligned_len;\r\ndma_addr_t catbuf1, catbuf2;\r\ndesc->header.raw = METH_TX_CMD_INT_EN | TX_CATBUF1 | TX_CATBUF2| (skb->len - 1);\r\nif (unaligned_len){\r\nskb_copy_from_linear_data(skb, desc->data.dt + (120 - unaligned_len),\r\nunaligned_len);\r\ndesc->header.raw |= (128 - unaligned_len) << 16;\r\n}\r\ncatbuf1 = dma_map_single(NULL, buffer1_data, buffer1_len,\r\nDMA_TO_DEVICE);\r\ndesc->data.cat_buf[0].form.start_addr = catbuf1 >> 3;\r\ndesc->data.cat_buf[0].form.len = buffer1_len - 1;\r\ncatbuf2 = dma_map_single(NULL, buffer2_data, buffer2_len,\r\nDMA_TO_DEVICE);\r\ndesc->data.cat_buf[1].form.start_addr = catbuf2 >> 3;\r\ndesc->data.cat_buf[1].form.len = buffer2_len - 1;\r\n}\r\nstatic void meth_add_to_tx_ring(struct meth_private *priv, struct sk_buff *skb)\r\n{\r\npriv->tx_skbs[priv->tx_write] = skb;\r\nif (skb->len <= 120) {\r\nmeth_tx_short_prepare(priv, skb);\r\n} else if (PAGE_ALIGN((unsigned long)skb->data) !=\r\nPAGE_ALIGN((unsigned long)skb->data + skb->len - 1)) {\r\nmeth_tx_2page_prepare(priv, skb);\r\n} else {\r\nmeth_tx_1page_prepare(priv, skb);\r\n}\r\npriv->tx_write = (priv->tx_write + 1) & (TX_RING_ENTRIES - 1);\r\nmace->eth.tx_info = priv->tx_write;\r\npriv->tx_count++;\r\n}\r\nstatic int meth_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->meth_lock, flags);\r\npriv->dma_ctrl &= ~(METH_DMA_TX_INT_EN);\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nmeth_add_to_tx_ring(priv, skb);\r\nnetif_trans_update(dev);\r\nif (meth_tx_full(dev)) {\r\nprintk(KERN_DEBUG "TX full: stopping\n");\r\nnetif_stop_queue(dev);\r\n}\r\npriv->dma_ctrl |= METH_DMA_TX_INT_EN;\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nspin_unlock_irqrestore(&priv->meth_lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void meth_tx_timeout(struct net_device *dev)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nprintk(KERN_WARNING "%s: transmit timed out\n", dev->name);\r\nspin_lock_irqsave(&priv->meth_lock,flags);\r\nmeth_reset(dev);\r\ndev->stats.tx_errors++;\r\nmeth_free_tx_ring(priv);\r\nmeth_free_rx_ring(priv);\r\nmeth_init_tx_ring(priv);\r\nmeth_init_rx_ring(priv);\r\npriv->dma_ctrl |= METH_DMA_TX_EN | METH_DMA_RX_EN | METH_DMA_RX_INT_EN;\r\nmace->eth.dma_ctrl = priv->dma_ctrl;\r\nspin_unlock_irqrestore(&priv->meth_lock, flags);\r\nnetif_trans_update(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int meth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nswitch(cmd) {\r\ncase SIOCGMIIPHY:\r\ncase SIOCGMIIREG:\r\ncase SIOCSMIIREG:\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void meth_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct meth_private *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&priv->meth_lock, flags);\r\npriv->mac_ctrl &= ~METH_PROMISC;\r\nif (dev->flags & IFF_PROMISC) {\r\npriv->mac_ctrl |= METH_PROMISC;\r\npriv->mcast_filter = 0xffffffffffffffffUL;\r\n} else if ((netdev_mc_count(dev) > METH_MCF_LIMIT) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\npriv->mac_ctrl |= METH_ACCEPT_AMCAST;\r\npriv->mcast_filter = 0xffffffffffffffffUL;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\npriv->mac_ctrl |= METH_ACCEPT_MCAST;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nset_bit((ether_crc(ETH_ALEN, ha->addr) >> 26),\r\n(volatile unsigned long *)&priv->mcast_filter);\r\n}\r\nmace->eth.mac_ctrl = priv->mac_ctrl;\r\nmace->eth.mcast_filter = priv->mcast_filter;\r\nspin_unlock_irqrestore(&priv->meth_lock, flags);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int meth_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct meth_private *priv;\r\nint err;\r\ndev = alloc_etherdev(sizeof(struct meth_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->netdev_ops = &meth_netdev_ops;\r\ndev->watchdog_timeo = timeout;\r\ndev->irq = MACE_ETHERNET_IRQ;\r\ndev->base_addr = (unsigned long)&mace->eth;\r\nmemcpy(dev->dev_addr, o2meth_eaddr, ETH_ALEN);\r\npriv = netdev_priv(dev);\r\nspin_lock_init(&priv->meth_lock);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "%s: SGI MACE Ethernet rev. %d\n",\r\ndev->name, (unsigned int)(mace->eth.mac_ctrl >> 29));\r\nreturn 0;\r\n}\r\nstatic int __exit meth_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}
