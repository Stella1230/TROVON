static void i40e_adminq_init_regs(struct i40e_hw *hw)\r\n{\r\nif (i40e_is_vf(hw)) {\r\nhw->aq.asq.tail = I40E_VF_ATQT1;\r\nhw->aq.asq.head = I40E_VF_ATQH1;\r\nhw->aq.asq.len = I40E_VF_ATQLEN1;\r\nhw->aq.asq.bal = I40E_VF_ATQBAL1;\r\nhw->aq.asq.bah = I40E_VF_ATQBAH1;\r\nhw->aq.arq.tail = I40E_VF_ARQT1;\r\nhw->aq.arq.head = I40E_VF_ARQH1;\r\nhw->aq.arq.len = I40E_VF_ARQLEN1;\r\nhw->aq.arq.bal = I40E_VF_ARQBAL1;\r\nhw->aq.arq.bah = I40E_VF_ARQBAH1;\r\n} else {\r\nhw->aq.asq.tail = I40E_PF_ATQT;\r\nhw->aq.asq.head = I40E_PF_ATQH;\r\nhw->aq.asq.len = I40E_PF_ATQLEN;\r\nhw->aq.asq.bal = I40E_PF_ATQBAL;\r\nhw->aq.asq.bah = I40E_PF_ATQBAH;\r\nhw->aq.arq.tail = I40E_PF_ARQT;\r\nhw->aq.arq.head = I40E_PF_ARQH;\r\nhw->aq.arq.len = I40E_PF_ARQLEN;\r\nhw->aq.arq.bal = I40E_PF_ARQBAL;\r\nhw->aq.arq.bah = I40E_PF_ARQBAH;\r\n}\r\n}\r\nstatic i40e_status i40e_alloc_adminq_asq_ring(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code;\r\nret_code = i40e_allocate_dma_mem(hw, &hw->aq.asq.desc_buf,\r\ni40e_mem_atq_ring,\r\n(hw->aq.num_asq_entries *\r\nsizeof(struct i40e_aq_desc)),\r\nI40E_ADMINQ_DESC_ALIGNMENT);\r\nif (ret_code)\r\nreturn ret_code;\r\nret_code = i40e_allocate_virt_mem(hw, &hw->aq.asq.cmd_buf,\r\n(hw->aq.num_asq_entries *\r\nsizeof(struct i40e_asq_cmd_details)));\r\nif (ret_code) {\r\ni40e_free_dma_mem(hw, &hw->aq.asq.desc_buf);\r\nreturn ret_code;\r\n}\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_alloc_adminq_arq_ring(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code;\r\nret_code = i40e_allocate_dma_mem(hw, &hw->aq.arq.desc_buf,\r\ni40e_mem_arq_ring,\r\n(hw->aq.num_arq_entries *\r\nsizeof(struct i40e_aq_desc)),\r\nI40E_ADMINQ_DESC_ALIGNMENT);\r\nreturn ret_code;\r\n}\r\nstatic void i40e_free_adminq_asq(struct i40e_hw *hw)\r\n{\r\ni40e_free_dma_mem(hw, &hw->aq.asq.desc_buf);\r\n}\r\nstatic void i40e_free_adminq_arq(struct i40e_hw *hw)\r\n{\r\ni40e_free_dma_mem(hw, &hw->aq.arq.desc_buf);\r\n}\r\nstatic i40e_status i40e_alloc_arq_bufs(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code;\r\nstruct i40e_aq_desc *desc;\r\nstruct i40e_dma_mem *bi;\r\nint i;\r\nret_code = i40e_allocate_virt_mem(hw, &hw->aq.arq.dma_head,\r\n(hw->aq.num_arq_entries * sizeof(struct i40e_dma_mem)));\r\nif (ret_code)\r\ngoto alloc_arq_bufs;\r\nhw->aq.arq.r.arq_bi = (struct i40e_dma_mem *)hw->aq.arq.dma_head.va;\r\nfor (i = 0; i < hw->aq.num_arq_entries; i++) {\r\nbi = &hw->aq.arq.r.arq_bi[i];\r\nret_code = i40e_allocate_dma_mem(hw, bi,\r\ni40e_mem_arq_buf,\r\nhw->aq.arq_buf_size,\r\nI40E_ADMINQ_DESC_ALIGNMENT);\r\nif (ret_code)\r\ngoto unwind_alloc_arq_bufs;\r\ndesc = I40E_ADMINQ_DESC(hw->aq.arq, i);\r\ndesc->flags = cpu_to_le16(I40E_AQ_FLAG_BUF);\r\nif (hw->aq.arq_buf_size > I40E_AQ_LARGE_BUF)\r\ndesc->flags |= cpu_to_le16(I40E_AQ_FLAG_LB);\r\ndesc->opcode = 0;\r\ndesc->datalen = cpu_to_le16((u16)bi->size);\r\ndesc->retval = 0;\r\ndesc->cookie_high = 0;\r\ndesc->cookie_low = 0;\r\ndesc->params.external.addr_high =\r\ncpu_to_le32(upper_32_bits(bi->pa));\r\ndesc->params.external.addr_low =\r\ncpu_to_le32(lower_32_bits(bi->pa));\r\ndesc->params.external.param0 = 0;\r\ndesc->params.external.param1 = 0;\r\n}\r\nalloc_arq_bufs:\r\nreturn ret_code;\r\nunwind_alloc_arq_bufs:\r\ni--;\r\nfor (; i >= 0; i--)\r\ni40e_free_dma_mem(hw, &hw->aq.arq.r.arq_bi[i]);\r\ni40e_free_virt_mem(hw, &hw->aq.arq.dma_head);\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_alloc_asq_bufs(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code;\r\nstruct i40e_dma_mem *bi;\r\nint i;\r\nret_code = i40e_allocate_virt_mem(hw, &hw->aq.asq.dma_head,\r\n(hw->aq.num_asq_entries * sizeof(struct i40e_dma_mem)));\r\nif (ret_code)\r\ngoto alloc_asq_bufs;\r\nhw->aq.asq.r.asq_bi = (struct i40e_dma_mem *)hw->aq.asq.dma_head.va;\r\nfor (i = 0; i < hw->aq.num_asq_entries; i++) {\r\nbi = &hw->aq.asq.r.asq_bi[i];\r\nret_code = i40e_allocate_dma_mem(hw, bi,\r\ni40e_mem_asq_buf,\r\nhw->aq.asq_buf_size,\r\nI40E_ADMINQ_DESC_ALIGNMENT);\r\nif (ret_code)\r\ngoto unwind_alloc_asq_bufs;\r\n}\r\nalloc_asq_bufs:\r\nreturn ret_code;\r\nunwind_alloc_asq_bufs:\r\ni--;\r\nfor (; i >= 0; i--)\r\ni40e_free_dma_mem(hw, &hw->aq.asq.r.asq_bi[i]);\r\ni40e_free_virt_mem(hw, &hw->aq.asq.dma_head);\r\nreturn ret_code;\r\n}\r\nstatic void i40e_free_arq_bufs(struct i40e_hw *hw)\r\n{\r\nint i;\r\nfor (i = 0; i < hw->aq.num_arq_entries; i++)\r\ni40e_free_dma_mem(hw, &hw->aq.arq.r.arq_bi[i]);\r\ni40e_free_dma_mem(hw, &hw->aq.arq.desc_buf);\r\ni40e_free_virt_mem(hw, &hw->aq.arq.dma_head);\r\n}\r\nstatic void i40e_free_asq_bufs(struct i40e_hw *hw)\r\n{\r\nint i;\r\nfor (i = 0; i < hw->aq.num_asq_entries; i++)\r\nif (hw->aq.asq.r.asq_bi[i].pa)\r\ni40e_free_dma_mem(hw, &hw->aq.asq.r.asq_bi[i]);\r\ni40e_free_virt_mem(hw, &hw->aq.asq.cmd_buf);\r\ni40e_free_dma_mem(hw, &hw->aq.asq.desc_buf);\r\ni40e_free_virt_mem(hw, &hw->aq.asq.dma_head);\r\n}\r\nstatic i40e_status i40e_config_asq_regs(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = 0;\r\nu32 reg = 0;\r\nwr32(hw, hw->aq.asq.head, 0);\r\nwr32(hw, hw->aq.asq.tail, 0);\r\nwr32(hw, hw->aq.asq.len, (hw->aq.num_asq_entries |\r\nI40E_PF_ATQLEN_ATQENABLE_MASK));\r\nwr32(hw, hw->aq.asq.bal, lower_32_bits(hw->aq.asq.desc_buf.pa));\r\nwr32(hw, hw->aq.asq.bah, upper_32_bits(hw->aq.asq.desc_buf.pa));\r\nreg = rd32(hw, hw->aq.asq.bal);\r\nif (reg != lower_32_bits(hw->aq.asq.desc_buf.pa))\r\nret_code = I40E_ERR_ADMIN_QUEUE_ERROR;\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_config_arq_regs(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = 0;\r\nu32 reg = 0;\r\nwr32(hw, hw->aq.arq.head, 0);\r\nwr32(hw, hw->aq.arq.tail, 0);\r\nwr32(hw, hw->aq.arq.len, (hw->aq.num_arq_entries |\r\nI40E_PF_ARQLEN_ARQENABLE_MASK));\r\nwr32(hw, hw->aq.arq.bal, lower_32_bits(hw->aq.arq.desc_buf.pa));\r\nwr32(hw, hw->aq.arq.bah, upper_32_bits(hw->aq.arq.desc_buf.pa));\r\nwr32(hw, hw->aq.arq.tail, hw->aq.num_arq_entries - 1);\r\nreg = rd32(hw, hw->aq.arq.bal);\r\nif (reg != lower_32_bits(hw->aq.arq.desc_buf.pa))\r\nret_code = I40E_ERR_ADMIN_QUEUE_ERROR;\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_init_asq(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = 0;\r\nif (hw->aq.asq.count > 0) {\r\nret_code = I40E_ERR_NOT_READY;\r\ngoto init_adminq_exit;\r\n}\r\nif ((hw->aq.num_asq_entries == 0) ||\r\n(hw->aq.asq_buf_size == 0)) {\r\nret_code = I40E_ERR_CONFIG;\r\ngoto init_adminq_exit;\r\n}\r\nhw->aq.asq.next_to_use = 0;\r\nhw->aq.asq.next_to_clean = 0;\r\nret_code = i40e_alloc_adminq_asq_ring(hw);\r\nif (ret_code)\r\ngoto init_adminq_exit;\r\nret_code = i40e_alloc_asq_bufs(hw);\r\nif (ret_code)\r\ngoto init_adminq_free_rings;\r\nret_code = i40e_config_asq_regs(hw);\r\nif (ret_code)\r\ngoto init_adminq_free_rings;\r\nhw->aq.asq.count = hw->aq.num_asq_entries;\r\ngoto init_adminq_exit;\r\ninit_adminq_free_rings:\r\ni40e_free_adminq_asq(hw);\r\ninit_adminq_exit:\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_init_arq(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = 0;\r\nif (hw->aq.arq.count > 0) {\r\nret_code = I40E_ERR_NOT_READY;\r\ngoto init_adminq_exit;\r\n}\r\nif ((hw->aq.num_arq_entries == 0) ||\r\n(hw->aq.arq_buf_size == 0)) {\r\nret_code = I40E_ERR_CONFIG;\r\ngoto init_adminq_exit;\r\n}\r\nhw->aq.arq.next_to_use = 0;\r\nhw->aq.arq.next_to_clean = 0;\r\nret_code = i40e_alloc_adminq_arq_ring(hw);\r\nif (ret_code)\r\ngoto init_adminq_exit;\r\nret_code = i40e_alloc_arq_bufs(hw);\r\nif (ret_code)\r\ngoto init_adminq_free_rings;\r\nret_code = i40e_config_arq_regs(hw);\r\nif (ret_code)\r\ngoto init_adminq_free_rings;\r\nhw->aq.arq.count = hw->aq.num_arq_entries;\r\ngoto init_adminq_exit;\r\ninit_adminq_free_rings:\r\ni40e_free_adminq_arq(hw);\r\ninit_adminq_exit:\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_shutdown_asq(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = 0;\r\nmutex_lock(&hw->aq.asq_mutex);\r\nif (hw->aq.asq.count == 0) {\r\nret_code = I40E_ERR_NOT_READY;\r\ngoto shutdown_asq_out;\r\n}\r\nwr32(hw, hw->aq.asq.head, 0);\r\nwr32(hw, hw->aq.asq.tail, 0);\r\nwr32(hw, hw->aq.asq.len, 0);\r\nwr32(hw, hw->aq.asq.bal, 0);\r\nwr32(hw, hw->aq.asq.bah, 0);\r\nhw->aq.asq.count = 0;\r\ni40e_free_asq_bufs(hw);\r\nshutdown_asq_out:\r\nmutex_unlock(&hw->aq.asq_mutex);\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_shutdown_arq(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = 0;\r\nmutex_lock(&hw->aq.arq_mutex);\r\nif (hw->aq.arq.count == 0) {\r\nret_code = I40E_ERR_NOT_READY;\r\ngoto shutdown_arq_out;\r\n}\r\nwr32(hw, hw->aq.arq.head, 0);\r\nwr32(hw, hw->aq.arq.tail, 0);\r\nwr32(hw, hw->aq.arq.len, 0);\r\nwr32(hw, hw->aq.arq.bal, 0);\r\nwr32(hw, hw->aq.arq.bah, 0);\r\nhw->aq.arq.count = 0;\r\ni40e_free_arq_bufs(hw);\r\nshutdown_arq_out:\r\nmutex_unlock(&hw->aq.arq_mutex);\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_init_adminq(struct i40e_hw *hw)\r\n{\r\nu16 cfg_ptr, oem_hi, oem_lo;\r\nu16 eetrack_lo, eetrack_hi;\r\ni40e_status ret_code;\r\nint retry = 0;\r\nif ((hw->aq.num_arq_entries == 0) ||\r\n(hw->aq.num_asq_entries == 0) ||\r\n(hw->aq.arq_buf_size == 0) ||\r\n(hw->aq.asq_buf_size == 0)) {\r\nret_code = I40E_ERR_CONFIG;\r\ngoto init_adminq_exit;\r\n}\r\ni40e_adminq_init_regs(hw);\r\nhw->aq.asq_cmd_timeout = I40E_ASQ_CMD_TIMEOUT;\r\nret_code = i40e_init_asq(hw);\r\nif (ret_code)\r\ngoto init_adminq_destroy_locks;\r\nret_code = i40e_init_arq(hw);\r\nif (ret_code)\r\ngoto init_adminq_free_asq;\r\ndo {\r\nret_code = i40e_aq_get_firmware_version(hw,\r\n&hw->aq.fw_maj_ver,\r\n&hw->aq.fw_min_ver,\r\n&hw->aq.fw_build,\r\n&hw->aq.api_maj_ver,\r\n&hw->aq.api_min_ver,\r\nNULL);\r\nif (ret_code != I40E_ERR_ADMIN_QUEUE_TIMEOUT)\r\nbreak;\r\nretry++;\r\nmsleep(100);\r\ni40e_resume_aq(hw);\r\n} while (retry < 10);\r\nif (ret_code != I40E_SUCCESS)\r\ngoto init_adminq_free_arq;\r\ni40e_read_nvm_word(hw, I40E_SR_NVM_DEV_STARTER_VERSION,\r\n&hw->nvm.version);\r\ni40e_read_nvm_word(hw, I40E_SR_NVM_EETRACK_LO, &eetrack_lo);\r\ni40e_read_nvm_word(hw, I40E_SR_NVM_EETRACK_HI, &eetrack_hi);\r\nhw->nvm.eetrack = (eetrack_hi << 16) | eetrack_lo;\r\ni40e_read_nvm_word(hw, I40E_SR_BOOT_CONFIG_PTR, &cfg_ptr);\r\ni40e_read_nvm_word(hw, (cfg_ptr + I40E_NVM_OEM_VER_OFF),\r\n&oem_hi);\r\ni40e_read_nvm_word(hw, (cfg_ptr + (I40E_NVM_OEM_VER_OFF + 1)),\r\n&oem_lo);\r\nhw->nvm.oem_ver = ((u32)oem_hi << 16) | oem_lo;\r\nif (hw->aq.api_maj_ver > I40E_FW_API_VERSION_MAJOR) {\r\nret_code = I40E_ERR_FIRMWARE_API_VERSION;\r\ngoto init_adminq_free_arq;\r\n}\r\ni40e_aq_release_resource(hw, I40E_NVM_RESOURCE_ID, 0, NULL);\r\nhw->nvm_release_on_done = false;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\nret_code = 0;\r\ngoto init_adminq_exit;\r\ninit_adminq_free_arq:\r\ni40e_shutdown_arq(hw);\r\ninit_adminq_free_asq:\r\ni40e_shutdown_asq(hw);\r\ninit_adminq_destroy_locks:\r\ninit_adminq_exit:\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_shutdown_adminq(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = 0;\r\nif (i40e_check_asq_alive(hw))\r\ni40e_aq_queue_shutdown(hw, true);\r\ni40e_shutdown_asq(hw);\r\ni40e_shutdown_arq(hw);\r\nif (hw->nvm_buff.va)\r\ni40e_free_virt_mem(hw, &hw->nvm_buff);\r\nreturn ret_code;\r\n}\r\nstatic u16 i40e_clean_asq(struct i40e_hw *hw)\r\n{\r\nstruct i40e_adminq_ring *asq = &(hw->aq.asq);\r\nstruct i40e_asq_cmd_details *details;\r\nu16 ntc = asq->next_to_clean;\r\nstruct i40e_aq_desc desc_cb;\r\nstruct i40e_aq_desc *desc;\r\ndesc = I40E_ADMINQ_DESC(*asq, ntc);\r\ndetails = I40E_ADMINQ_DETAILS(*asq, ntc);\r\nwhile (rd32(hw, hw->aq.asq.head) != ntc) {\r\ni40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\r\n"ntc %d head %d.\n", ntc, rd32(hw, hw->aq.asq.head));\r\nif (details->callback) {\r\nI40E_ADMINQ_CALLBACK cb_func =\r\n(I40E_ADMINQ_CALLBACK)details->callback;\r\ndesc_cb = *desc;\r\ncb_func(hw, &desc_cb);\r\n}\r\nmemset(desc, 0, sizeof(*desc));\r\nmemset(details, 0, sizeof(*details));\r\nntc++;\r\nif (ntc == asq->count)\r\nntc = 0;\r\ndesc = I40E_ADMINQ_DESC(*asq, ntc);\r\ndetails = I40E_ADMINQ_DETAILS(*asq, ntc);\r\n}\r\nasq->next_to_clean = ntc;\r\nreturn I40E_DESC_UNUSED(asq);\r\n}\r\nstatic bool i40e_asq_done(struct i40e_hw *hw)\r\n{\r\nreturn rd32(hw, hw->aq.asq.head) == hw->aq.asq.next_to_use;\r\n}\r\ni40e_status i40e_asq_send_command(struct i40e_hw *hw,\r\nstruct i40e_aq_desc *desc,\r\nvoid *buff,\r\nu16 buff_size,\r\nstruct i40e_asq_cmd_details *cmd_details)\r\n{\r\ni40e_status status = 0;\r\nstruct i40e_dma_mem *dma_buff = NULL;\r\nstruct i40e_asq_cmd_details *details;\r\nstruct i40e_aq_desc *desc_on_ring;\r\nbool cmd_completed = false;\r\nu16 retval = 0;\r\nu32 val = 0;\r\nmutex_lock(&hw->aq.asq_mutex);\r\nif (hw->aq.asq.count == 0) {\r\ni40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\r\n"AQTX: Admin queue not initialized.\n");\r\nstatus = I40E_ERR_QUEUE_EMPTY;\r\ngoto asq_send_command_error;\r\n}\r\nhw->aq.asq_last_status = I40E_AQ_RC_OK;\r\nval = rd32(hw, hw->aq.asq.head);\r\nif (val >= hw->aq.num_asq_entries) {\r\ni40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\r\n"AQTX: head overrun at %d\n", val);\r\nstatus = I40E_ERR_QUEUE_EMPTY;\r\ngoto asq_send_command_error;\r\n}\r\ndetails = I40E_ADMINQ_DETAILS(hw->aq.asq, hw->aq.asq.next_to_use);\r\nif (cmd_details) {\r\n*details = *cmd_details;\r\nif (details->cookie) {\r\ndesc->cookie_high =\r\ncpu_to_le32(upper_32_bits(details->cookie));\r\ndesc->cookie_low =\r\ncpu_to_le32(lower_32_bits(details->cookie));\r\n}\r\n} else {\r\nmemset(details, 0, sizeof(struct i40e_asq_cmd_details));\r\n}\r\ndesc->flags &= ~cpu_to_le16(details->flags_dis);\r\ndesc->flags |= cpu_to_le16(details->flags_ena);\r\nif (buff_size > hw->aq.asq_buf_size) {\r\ni40e_debug(hw,\r\nI40E_DEBUG_AQ_MESSAGE,\r\n"AQTX: Invalid buffer size: %d.\n",\r\nbuff_size);\r\nstatus = I40E_ERR_INVALID_SIZE;\r\ngoto asq_send_command_error;\r\n}\r\nif (details->postpone && !details->async) {\r\ni40e_debug(hw,\r\nI40E_DEBUG_AQ_MESSAGE,\r\n"AQTX: Async flag not set along with postpone flag");\r\nstatus = I40E_ERR_PARAM;\r\ngoto asq_send_command_error;\r\n}\r\nif (i40e_clean_asq(hw) == 0) {\r\ni40e_debug(hw,\r\nI40E_DEBUG_AQ_MESSAGE,\r\n"AQTX: Error queue is full.\n");\r\nstatus = I40E_ERR_ADMIN_QUEUE_FULL;\r\ngoto asq_send_command_error;\r\n}\r\ndesc_on_ring = I40E_ADMINQ_DESC(hw->aq.asq, hw->aq.asq.next_to_use);\r\n*desc_on_ring = *desc;\r\nif (buff != NULL) {\r\ndma_buff = &(hw->aq.asq.r.asq_bi[hw->aq.asq.next_to_use]);\r\nmemcpy(dma_buff->va, buff, buff_size);\r\ndesc_on_ring->datalen = cpu_to_le16(buff_size);\r\ndesc_on_ring->params.external.addr_high =\r\ncpu_to_le32(upper_32_bits(dma_buff->pa));\r\ndesc_on_ring->params.external.addr_low =\r\ncpu_to_le32(lower_32_bits(dma_buff->pa));\r\n}\r\ni40e_debug(hw, I40E_DEBUG_AQ_MESSAGE, "AQTX: desc and buffer:\n");\r\ni40e_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc_on_ring,\r\nbuff, buff_size);\r\n(hw->aq.asq.next_to_use)++;\r\nif (hw->aq.asq.next_to_use == hw->aq.asq.count)\r\nhw->aq.asq.next_to_use = 0;\r\nif (!details->postpone)\r\nwr32(hw, hw->aq.asq.tail, hw->aq.asq.next_to_use);\r\nif (!details->async && !details->postpone) {\r\nu32 total_delay = 0;\r\ndo {\r\nif (i40e_asq_done(hw))\r\nbreak;\r\nusleep_range(1000, 2000);\r\ntotal_delay++;\r\n} while (total_delay < hw->aq.asq_cmd_timeout);\r\n}\r\nif (i40e_asq_done(hw)) {\r\n*desc = *desc_on_ring;\r\nif (buff != NULL)\r\nmemcpy(buff, dma_buff->va, buff_size);\r\nretval = le16_to_cpu(desc->retval);\r\nif (retval != 0) {\r\ni40e_debug(hw,\r\nI40E_DEBUG_AQ_MESSAGE,\r\n"AQTX: Command completed with error 0x%X.\n",\r\nretval);\r\nretval &= 0xff;\r\n}\r\ncmd_completed = true;\r\nif ((enum i40e_admin_queue_err)retval == I40E_AQ_RC_OK)\r\nstatus = 0;\r\nelse\r\nstatus = I40E_ERR_ADMIN_QUEUE_ERROR;\r\nhw->aq.asq_last_status = (enum i40e_admin_queue_err)retval;\r\n}\r\ni40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\r\n"AQTX: desc and buffer writeback:\n");\r\ni40e_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc, buff, buff_size);\r\nif (details->wb_desc)\r\n*details->wb_desc = *desc_on_ring;\r\nif ((!cmd_completed) &&\r\n(!details->async && !details->postpone)) {\r\ni40e_debug(hw,\r\nI40E_DEBUG_AQ_MESSAGE,\r\n"AQTX: Writeback timeout.\n");\r\nstatus = I40E_ERR_ADMIN_QUEUE_TIMEOUT;\r\n}\r\nasq_send_command_error:\r\nmutex_unlock(&hw->aq.asq_mutex);\r\nreturn status;\r\n}\r\nvoid i40e_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc,\r\nu16 opcode)\r\n{\r\nmemset((void *)desc, 0, sizeof(struct i40e_aq_desc));\r\ndesc->opcode = cpu_to_le16(opcode);\r\ndesc->flags = cpu_to_le16(I40E_AQ_FLAG_SI);\r\n}\r\ni40e_status i40e_clean_arq_element(struct i40e_hw *hw,\r\nstruct i40e_arq_event_info *e,\r\nu16 *pending)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 ntc = hw->aq.arq.next_to_clean;\r\nstruct i40e_aq_desc *desc;\r\nstruct i40e_dma_mem *bi;\r\nu16 desc_idx;\r\nu16 datalen;\r\nu16 flags;\r\nu16 ntu;\r\nmemset(&e->desc, 0, sizeof(e->desc));\r\nmutex_lock(&hw->aq.arq_mutex);\r\nif (hw->aq.arq.count == 0) {\r\ni40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,\r\n"AQRX: Admin queue not initialized.\n");\r\nret_code = I40E_ERR_QUEUE_EMPTY;\r\ngoto clean_arq_element_err;\r\n}\r\nntu = (rd32(hw, hw->aq.arq.head) & I40E_PF_ARQH_ARQH_MASK);\r\nif (ntu == ntc) {\r\nret_code = I40E_ERR_ADMIN_QUEUE_NO_WORK;\r\ngoto clean_arq_element_out;\r\n}\r\ndesc = I40E_ADMINQ_DESC(hw->aq.arq, ntc);\r\ndesc_idx = ntc;\r\nflags = le16_to_cpu(desc->flags);\r\nif (flags & I40E_AQ_FLAG_ERR) {\r\nret_code = I40E_ERR_ADMIN_QUEUE_ERROR;\r\nhw->aq.arq_last_status =\r\n(enum i40e_admin_queue_err)le16_to_cpu(desc->retval);\r\ni40e_debug(hw,\r\nI40E_DEBUG_AQ_MESSAGE,\r\n"AQRX: Event received with error 0x%X.\n",\r\nhw->aq.arq_last_status);\r\n}\r\ne->desc = *desc;\r\ndatalen = le16_to_cpu(desc->datalen);\r\ne->msg_len = min(datalen, e->buf_len);\r\nif (e->msg_buf != NULL && (e->msg_len != 0))\r\nmemcpy(e->msg_buf, hw->aq.arq.r.arq_bi[desc_idx].va,\r\ne->msg_len);\r\ni40e_debug(hw, I40E_DEBUG_AQ_MESSAGE, "AQRX: desc and buffer:\n");\r\ni40e_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc, e->msg_buf,\r\nhw->aq.arq_buf_size);\r\nbi = &hw->aq.arq.r.arq_bi[ntc];\r\nmemset((void *)desc, 0, sizeof(struct i40e_aq_desc));\r\ndesc->flags = cpu_to_le16(I40E_AQ_FLAG_BUF);\r\nif (hw->aq.arq_buf_size > I40E_AQ_LARGE_BUF)\r\ndesc->flags |= cpu_to_le16(I40E_AQ_FLAG_LB);\r\ndesc->datalen = cpu_to_le16((u16)bi->size);\r\ndesc->params.external.addr_high = cpu_to_le32(upper_32_bits(bi->pa));\r\ndesc->params.external.addr_low = cpu_to_le32(lower_32_bits(bi->pa));\r\nwr32(hw, hw->aq.arq.tail, ntc);\r\nntc++;\r\nif (ntc == hw->aq.num_arq_entries)\r\nntc = 0;\r\nhw->aq.arq.next_to_clean = ntc;\r\nhw->aq.arq.next_to_use = ntu;\r\ni40e_nvmupd_check_wait_event(hw, le16_to_cpu(e->desc.opcode));\r\nclean_arq_element_out:\r\nif (pending)\r\n*pending = (ntc > ntu ? hw->aq.arq.count : 0) + (ntu - ntc);\r\nclean_arq_element_err:\r\nmutex_unlock(&hw->aq.arq_mutex);\r\nreturn ret_code;\r\n}\r\nstatic void i40e_resume_aq(struct i40e_hw *hw)\r\n{\r\nhw->aq.asq.next_to_use = 0;\r\nhw->aq.asq.next_to_clean = 0;\r\ni40e_config_asq_regs(hw);\r\nhw->aq.arq.next_to_use = 0;\r\nhw->aq.arq.next_to_clean = 0;\r\ni40e_config_arq_regs(hw);\r\n}
