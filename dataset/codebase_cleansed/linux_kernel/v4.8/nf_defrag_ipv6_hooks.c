static enum ip6_defrag_users nf_ct6_defrag_user(unsigned int hooknum,\r\nstruct sk_buff *skb)\r\n{\r\nu16 zone_id = NF_CT_DEFAULT_ZONE_ID;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (skb->nfct) {\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nzone_id = nf_ct_zone_id(nf_ct_zone(ct), CTINFO2DIR(ctinfo));\r\n}\r\n#endif\r\nif (nf_bridge_in_prerouting(skb))\r\nreturn IP6_DEFRAG_CONNTRACK_BRIDGE_IN + zone_id;\r\nif (hooknum == NF_INET_PRE_ROUTING)\r\nreturn IP6_DEFRAG_CONNTRACK_IN + zone_id;\r\nelse\r\nreturn IP6_DEFRAG_CONNTRACK_OUT + zone_id;\r\n}\r\nstatic unsigned int ipv6_defrag(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nint err;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\r\nreturn NF_ACCEPT;\r\n#endif\r\nerr = nf_ct_frag6_gather(state->net, skb,\r\nnf_ct6_defrag_user(state->hook, skb));\r\nif (err == -EINPROGRESS)\r\nreturn NF_STOLEN;\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int __init nf_defrag_init(void)\r\n{\r\nint ret = 0;\r\nret = nf_ct_frag6_init();\r\nif (ret < 0) {\r\npr_err("nf_defrag_ipv6: can't initialize frag6.\n");\r\nreturn ret;\r\n}\r\nret = nf_register_hooks(ipv6_defrag_ops, ARRAY_SIZE(ipv6_defrag_ops));\r\nif (ret < 0) {\r\npr_err("nf_defrag_ipv6: can't register hooks\n");\r\ngoto cleanup_frag6;\r\n}\r\nreturn ret;\r\ncleanup_frag6:\r\nnf_ct_frag6_cleanup();\r\nreturn ret;\r\n}\r\nstatic void __exit nf_defrag_fini(void)\r\n{\r\nnf_unregister_hooks(ipv6_defrag_ops, ARRAY_SIZE(ipv6_defrag_ops));\r\nnf_ct_frag6_cleanup();\r\n}\r\nvoid nf_defrag_ipv6_enable(void)\r\n{\r\n}
