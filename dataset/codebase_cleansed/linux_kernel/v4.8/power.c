static void iwl_static_sleep_cmd(struct iwl_priv *priv,\r\nstruct iwl_powertable_cmd *cmd,\r\nenum iwl_power_level lvl, int period)\r\n{\r\nconst struct iwl_power_vec_entry *table;\r\nint max_sleep[IWL_POWER_VEC_SIZE] = { 0 };\r\nint i;\r\nu8 skip;\r\nu32 slp_itrvl;\r\nif (priv->lib->adv_pm) {\r\ntable = apm_range_2;\r\nif (period <= IWL_DTIM_RANGE_1_MAX)\r\ntable = apm_range_1;\r\nif (period <= IWL_DTIM_RANGE_0_MAX)\r\ntable = apm_range_0;\r\n} else {\r\ntable = range_2;\r\nif (period <= IWL_DTIM_RANGE_1_MAX)\r\ntable = range_1;\r\nif (period <= IWL_DTIM_RANGE_0_MAX)\r\ntable = range_0;\r\n}\r\nif (WARN_ON(lvl < 0 || lvl >= IWL_POWER_NUM))\r\nmemset(cmd, 0, sizeof(*cmd));\r\nelse\r\n*cmd = table[lvl].cmd;\r\nif (period == 0) {\r\nskip = 0;\r\nperiod = 1;\r\nfor (i = 0; i < IWL_POWER_VEC_SIZE; i++)\r\nmax_sleep[i] = 1;\r\n} else {\r\nskip = table[lvl].no_dtim;\r\nfor (i = 0; i < IWL_POWER_VEC_SIZE; i++)\r\nmax_sleep[i] = le32_to_cpu(cmd->sleep_interval[i]);\r\nmax_sleep[IWL_POWER_VEC_SIZE - 1] = skip + 1;\r\n}\r\nslp_itrvl = le32_to_cpu(cmd->sleep_interval[IWL_POWER_VEC_SIZE - 1]);\r\nif (slp_itrvl == 0xFF)\r\ncmd->sleep_interval[IWL_POWER_VEC_SIZE - 1] =\r\ncpu_to_le32(period * (skip + 1));\r\nslp_itrvl = le32_to_cpu(cmd->sleep_interval[IWL_POWER_VEC_SIZE - 1]);\r\nif (slp_itrvl > period)\r\ncmd->sleep_interval[IWL_POWER_VEC_SIZE - 1] =\r\ncpu_to_le32((slp_itrvl / period) * period);\r\nif (skip)\r\ncmd->flags |= IWL_POWER_SLEEP_OVER_DTIM_MSK;\r\nelse\r\ncmd->flags &= ~IWL_POWER_SLEEP_OVER_DTIM_MSK;\r\nif (priv->cfg->base_params->shadow_reg_enable)\r\ncmd->flags |= IWL_POWER_SHADOW_REG_ENA;\r\nelse\r\ncmd->flags &= ~IWL_POWER_SHADOW_REG_ENA;\r\nif (iwl_advanced_bt_coexist(priv)) {\r\nif (!priv->lib->bt_params->bt_sco_disable)\r\ncmd->flags |= IWL_POWER_BT_SCO_ENA;\r\nelse\r\ncmd->flags &= ~IWL_POWER_BT_SCO_ENA;\r\n}\r\nslp_itrvl = le32_to_cpu(cmd->sleep_interval[IWL_POWER_VEC_SIZE - 1]);\r\nif (slp_itrvl > IWL_CONN_MAX_LISTEN_INTERVAL)\r\ncmd->sleep_interval[IWL_POWER_VEC_SIZE - 1] =\r\ncpu_to_le32(IWL_CONN_MAX_LISTEN_INTERVAL);\r\nfor (i = IWL_POWER_VEC_SIZE - 1; i >= 0 ; i--) {\r\nif (le32_to_cpu(cmd->sleep_interval[i]) >\r\n(max_sleep[i] * period))\r\ncmd->sleep_interval[i] =\r\ncpu_to_le32(max_sleep[i] * period);\r\nif (i != (IWL_POWER_VEC_SIZE - 1)) {\r\nif (le32_to_cpu(cmd->sleep_interval[i]) >\r\nle32_to_cpu(cmd->sleep_interval[i+1]))\r\ncmd->sleep_interval[i] =\r\ncmd->sleep_interval[i+1];\r\n}\r\n}\r\nif (priv->power_data.bus_pm)\r\ncmd->flags |= IWL_POWER_PCI_PM_MSK;\r\nelse\r\ncmd->flags &= ~IWL_POWER_PCI_PM_MSK;\r\nIWL_DEBUG_POWER(priv, "numSkipDtim = %u, dtimPeriod = %d\n",\r\nskip, period);\r\nIWL_DEBUG_POWER(priv, "Sleep command for index %d\n", lvl + 1);\r\n}\r\nstatic void iwl_power_sleep_cam_cmd(struct iwl_priv *priv,\r\nstruct iwl_powertable_cmd *cmd)\r\n{\r\nmemset(cmd, 0, sizeof(*cmd));\r\nif (priv->power_data.bus_pm)\r\ncmd->flags |= IWL_POWER_PCI_PM_MSK;\r\nIWL_DEBUG_POWER(priv, "Sleep command for CAM\n");\r\n}\r\nstatic int iwl_set_power(struct iwl_priv *priv, struct iwl_powertable_cmd *cmd)\r\n{\r\nIWL_DEBUG_POWER(priv, "Sending power/sleep command\n");\r\nIWL_DEBUG_POWER(priv, "Flags value = 0x%08X\n", cmd->flags);\r\nIWL_DEBUG_POWER(priv, "Tx timeout = %u\n", le32_to_cpu(cmd->tx_data_timeout));\r\nIWL_DEBUG_POWER(priv, "Rx timeout = %u\n", le32_to_cpu(cmd->rx_data_timeout));\r\nIWL_DEBUG_POWER(priv, "Sleep interval vector = { %d , %d , %d , %d , %d }\n",\r\nle32_to_cpu(cmd->sleep_interval[0]),\r\nle32_to_cpu(cmd->sleep_interval[1]),\r\nle32_to_cpu(cmd->sleep_interval[2]),\r\nle32_to_cpu(cmd->sleep_interval[3]),\r\nle32_to_cpu(cmd->sleep_interval[4]));\r\nreturn iwl_dvm_send_cmd_pdu(priv, POWER_TABLE_CMD, 0,\r\nsizeof(struct iwl_powertable_cmd), cmd);\r\n}\r\nstatic void iwl_power_build_cmd(struct iwl_priv *priv,\r\nstruct iwl_powertable_cmd *cmd)\r\n{\r\nbool enabled = priv->hw->conf.flags & IEEE80211_CONF_PS;\r\nint dtimper;\r\nif (force_cam) {\r\niwl_power_sleep_cam_cmd(priv, cmd);\r\nreturn;\r\n}\r\ndtimper = priv->hw->conf.ps_dtim_period ?: 1;\r\nif (priv->wowlan)\r\niwl_static_sleep_cmd(priv, cmd, IWL_POWER_INDEX_5, dtimper);\r\nelse if (!priv->lib->no_idle_support &&\r\npriv->hw->conf.flags & IEEE80211_CONF_IDLE)\r\niwl_static_sleep_cmd(priv, cmd, IWL_POWER_INDEX_5, 20);\r\nelse if (iwl_tt_is_low_power_state(priv)) {\r\niwl_static_sleep_cmd(priv, cmd,\r\niwl_tt_current_power_mode(priv), dtimper);\r\n} else if (!enabled)\r\niwl_power_sleep_cam_cmd(priv, cmd);\r\nelse if (priv->power_data.debug_sleep_level_override >= 0)\r\niwl_static_sleep_cmd(priv, cmd,\r\npriv->power_data.debug_sleep_level_override,\r\ndtimper);\r\nelse {\r\nif (iwlwifi_mod_params.power_level > IWL_POWER_INDEX_1 &&\r\niwlwifi_mod_params.power_level <= IWL_POWER_NUM)\r\niwl_static_sleep_cmd(priv, cmd,\r\niwlwifi_mod_params.power_level - 1, dtimper);\r\nelse\r\niwl_static_sleep_cmd(priv, cmd,\r\nIWL_POWER_INDEX_1, dtimper);\r\n}\r\n}\r\nint iwl_power_set_mode(struct iwl_priv *priv, struct iwl_powertable_cmd *cmd,\r\nbool force)\r\n{\r\nint ret;\r\nbool update_chains;\r\nlockdep_assert_held(&priv->mutex);\r\nupdate_chains = priv->chain_noise_data.state == IWL_CHAIN_NOISE_DONE ||\r\npriv->chain_noise_data.state == IWL_CHAIN_NOISE_ALIVE;\r\nif (!memcmp(&priv->power_data.sleep_cmd, cmd, sizeof(*cmd)) && !force)\r\nreturn 0;\r\nif (!iwl_is_ready_rf(priv))\r\nreturn -EIO;\r\nmemcpy(&priv->power_data.sleep_cmd_next, cmd, sizeof(*cmd));\r\nif (test_bit(STATUS_SCANNING, &priv->status) && !force) {\r\nIWL_DEBUG_INFO(priv, "Defer power set mode while scanning\n");\r\nreturn 0;\r\n}\r\nif (cmd->flags & IWL_POWER_DRIVER_ALLOW_SLEEP_MSK)\r\niwl_dvm_set_pmi(priv, true);\r\nret = iwl_set_power(priv, cmd);\r\nif (!ret) {\r\nif (!(cmd->flags & IWL_POWER_DRIVER_ALLOW_SLEEP_MSK))\r\niwl_dvm_set_pmi(priv, false);\r\nif (update_chains)\r\niwl_update_chain_flags(priv);\r\nelse\r\nIWL_DEBUG_POWER(priv,\r\n"Cannot update the power, chain noise "\r\n"calibration running: %d\n",\r\npriv->chain_noise_data.state);\r\nmemcpy(&priv->power_data.sleep_cmd, cmd, sizeof(*cmd));\r\n} else\r\nIWL_ERR(priv, "set power fail, ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nint iwl_power_update_mode(struct iwl_priv *priv, bool force)\r\n{\r\nstruct iwl_powertable_cmd cmd;\r\niwl_power_build_cmd(priv, &cmd);\r\nreturn iwl_power_set_mode(priv, &cmd, force);\r\n}\r\nvoid iwl_power_initialize(struct iwl_priv *priv)\r\n{\r\npriv->power_data.bus_pm = priv->trans->pm_support;\r\npriv->power_data.debug_sleep_level_override = -1;\r\nmemset(&priv->power_data.sleep_cmd, 0,\r\nsizeof(priv->power_data.sleep_cmd));\r\n}
