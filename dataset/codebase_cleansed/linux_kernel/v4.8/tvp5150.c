static inline struct tvp5150 *to_tvp5150(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct tvp5150, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct tvp5150, hdl)->sd;\r\n}\r\nstatic int tvp5150_read(struct v4l2_subdev *sd, unsigned char addr)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nint rc;\r\nrc = i2c_smbus_read_byte_data(c, addr);\r\nif (rc < 0) {\r\nv4l2_err(sd, "i2c i/o error: rc == %d\n", rc);\r\nreturn rc;\r\n}\r\nv4l2_dbg(2, debug, sd, "tvp5150: read 0x%02x = 0x%02x\n", addr, rc);\r\nreturn rc;\r\n}\r\nstatic int tvp5150_write(struct v4l2_subdev *sd, unsigned char addr,\r\nunsigned char value)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nint rc;\r\nv4l2_dbg(2, debug, sd, "tvp5150: writing 0x%02x 0x%02x\n", addr, value);\r\nrc = i2c_smbus_write_byte_data(c, addr, value);\r\nif (rc < 0)\r\nv4l2_err(sd, "i2c i/o error: rc == %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic void dump_reg_range(struct v4l2_subdev *sd, char *s, u8 init,\r\nconst u8 end, int max_line)\r\n{\r\nint i = 0;\r\nwhile (init != (u8)(end + 1)) {\r\nif ((i % max_line) == 0) {\r\nif (i > 0)\r\nprintk("\n");\r\nprintk("tvp5150: %s reg 0x%02x = ", s, init);\r\n}\r\nprintk("%02x ", tvp5150_read(sd, init));\r\ninit++;\r\ni++;\r\n}\r\nprintk("\n");\r\n}\r\nstatic int tvp5150_log_status(struct v4l2_subdev *sd)\r\n{\r\nprintk("tvp5150: Video input source selection #1 = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_VD_IN_SRC_SEL_1));\r\nprintk("tvp5150: Analog channel controls = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_ANAL_CHL_CTL));\r\nprintk("tvp5150: Operation mode controls = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_OP_MODE_CTL));\r\nprintk("tvp5150: Miscellaneous controls = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_MISC_CTL));\r\nprintk("tvp5150: Autoswitch mask= 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_AUTOSW_MSK));\r\nprintk("tvp5150: Color killer threshold control = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_COLOR_KIL_THSH_CTL));\r\nprintk("tvp5150: Luminance processing controls #1 #2 and #3 = %02x %02x %02x\n",\r\ntvp5150_read(sd, TVP5150_LUMA_PROC_CTL_1),\r\ntvp5150_read(sd, TVP5150_LUMA_PROC_CTL_2),\r\ntvp5150_read(sd, TVP5150_LUMA_PROC_CTL_3));\r\nprintk("tvp5150: Brightness control = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_BRIGHT_CTL));\r\nprintk("tvp5150: Color saturation control = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_SATURATION_CTL));\r\nprintk("tvp5150: Hue control = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_HUE_CTL));\r\nprintk("tvp5150: Contrast control = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_CONTRAST_CTL));\r\nprintk("tvp5150: Outputs and data rates select = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_DATA_RATE_SEL));\r\nprintk("tvp5150: Configuration shared pins = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_CONF_SHARED_PIN));\r\nprintk("tvp5150: Active video cropping start = 0x%02x%02x\n",\r\ntvp5150_read(sd, TVP5150_ACT_VD_CROP_ST_MSB),\r\ntvp5150_read(sd, TVP5150_ACT_VD_CROP_ST_LSB));\r\nprintk("tvp5150: Active video cropping stop = 0x%02x%02x\n",\r\ntvp5150_read(sd, TVP5150_ACT_VD_CROP_STP_MSB),\r\ntvp5150_read(sd, TVP5150_ACT_VD_CROP_STP_LSB));\r\nprintk("tvp5150: Genlock/RTC = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_GENLOCK));\r\nprintk("tvp5150: Horizontal sync start = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_HORIZ_SYNC_START));\r\nprintk("tvp5150: Vertical blanking start = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_VERT_BLANKING_START));\r\nprintk("tvp5150: Vertical blanking stop = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_VERT_BLANKING_STOP));\r\nprintk("tvp5150: Chrominance processing control #1 and #2 = %02x %02x\n",\r\ntvp5150_read(sd, TVP5150_CHROMA_PROC_CTL_1),\r\ntvp5150_read(sd, TVP5150_CHROMA_PROC_CTL_2));\r\nprintk("tvp5150: Interrupt reset register B = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_INT_RESET_REG_B));\r\nprintk("tvp5150: Interrupt enable register B = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_INT_ENABLE_REG_B));\r\nprintk("tvp5150: Interrupt configuration register B = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_INTT_CONFIG_REG_B));\r\nprintk("tvp5150: Video standard = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_VIDEO_STD));\r\nprintk("tvp5150: Chroma gain factor: Cb=0x%02x Cr=0x%02x\n",\r\ntvp5150_read(sd, TVP5150_CB_GAIN_FACT),\r\ntvp5150_read(sd, TVP5150_CR_GAIN_FACTOR));\r\nprintk("tvp5150: Macrovision on counter = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_MACROVISION_ON_CTR));\r\nprintk("tvp5150: Macrovision off counter = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_MACROVISION_OFF_CTR));\r\nprintk("tvp5150: ITU-R BT.656.%d timing(TVP5150AM1 only)\n",\r\n(tvp5150_read(sd, TVP5150_REV_SELECT) & 1) ? 3 : 4);\r\nprintk("tvp5150: Device ID = %02x%02x\n",\r\ntvp5150_read(sd, TVP5150_MSB_DEV_ID),\r\ntvp5150_read(sd, TVP5150_LSB_DEV_ID));\r\nprintk("tvp5150: ROM version = (hex) %02x.%02x\n",\r\ntvp5150_read(sd, TVP5150_ROM_MAJOR_VER),\r\ntvp5150_read(sd, TVP5150_ROM_MINOR_VER));\r\nprintk("tvp5150: Vertical line count = 0x%02x%02x\n",\r\ntvp5150_read(sd, TVP5150_VERT_LN_COUNT_MSB),\r\ntvp5150_read(sd, TVP5150_VERT_LN_COUNT_LSB));\r\nprintk("tvp5150: Interrupt status register B = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_INT_STATUS_REG_B));\r\nprintk("tvp5150: Interrupt active register B = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_INT_ACTIVE_REG_B));\r\nprintk("tvp5150: Status regs #1 to #5 = %02x %02x %02x %02x %02x\n",\r\ntvp5150_read(sd, TVP5150_STATUS_REG_1),\r\ntvp5150_read(sd, TVP5150_STATUS_REG_2),\r\ntvp5150_read(sd, TVP5150_STATUS_REG_3),\r\ntvp5150_read(sd, TVP5150_STATUS_REG_4),\r\ntvp5150_read(sd, TVP5150_STATUS_REG_5));\r\ndump_reg_range(sd, "Teletext filter 1", TVP5150_TELETEXT_FIL1_INI,\r\nTVP5150_TELETEXT_FIL1_END, 8);\r\ndump_reg_range(sd, "Teletext filter 2", TVP5150_TELETEXT_FIL2_INI,\r\nTVP5150_TELETEXT_FIL2_END, 8);\r\nprintk("tvp5150: Teletext filter enable = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_TELETEXT_FIL_ENA));\r\nprintk("tvp5150: Interrupt status register A = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_INT_STATUS_REG_A));\r\nprintk("tvp5150: Interrupt enable register A = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_INT_ENABLE_REG_A));\r\nprintk("tvp5150: Interrupt configuration = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_INT_CONF));\r\nprintk("tvp5150: VDP status register = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_VDP_STATUS_REG));\r\nprintk("tvp5150: FIFO word count = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_FIFO_WORD_COUNT));\r\nprintk("tvp5150: FIFO interrupt threshold = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_FIFO_INT_THRESHOLD));\r\nprintk("tvp5150: FIFO reset = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_FIFO_RESET));\r\nprintk("tvp5150: Line number interrupt = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_LINE_NUMBER_INT));\r\nprintk("tvp5150: Pixel alignment register = 0x%02x%02x\n",\r\ntvp5150_read(sd, TVP5150_PIX_ALIGN_REG_HIGH),\r\ntvp5150_read(sd, TVP5150_PIX_ALIGN_REG_LOW));\r\nprintk("tvp5150: FIFO output control = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_FIFO_OUT_CTRL));\r\nprintk("tvp5150: Full field enable = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_FULL_FIELD_ENA));\r\nprintk("tvp5150: Full field mode register = 0x%02x\n",\r\ntvp5150_read(sd, TVP5150_FULL_FIELD_MODE_REG));\r\ndump_reg_range(sd, "CC data", TVP5150_CC_DATA_INI,\r\nTVP5150_CC_DATA_END, 8);\r\ndump_reg_range(sd, "WSS data", TVP5150_WSS_DATA_INI,\r\nTVP5150_WSS_DATA_END, 8);\r\ndump_reg_range(sd, "VPS data", TVP5150_VPS_DATA_INI,\r\nTVP5150_VPS_DATA_END, 8);\r\ndump_reg_range(sd, "VITC data", TVP5150_VITC_DATA_INI,\r\nTVP5150_VITC_DATA_END, 10);\r\ndump_reg_range(sd, "Line mode", TVP5150_LINE_MODE_INI,\r\nTVP5150_LINE_MODE_END, 8);\r\nreturn 0;\r\n}\r\nstatic inline void tvp5150_selmux(struct v4l2_subdev *sd)\r\n{\r\nint opmode = 0;\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nint input = 0;\r\nint val;\r\nif ((decoder->dev_id == 0x5150 && decoder->rom_ver == 0x0400) ||\r\n(decoder->dev_id == 0x5151 && decoder->rom_ver == 0x0100)) {\r\nif (!decoder->enable)\r\ninput = 8;\r\n}\r\nswitch (decoder->input) {\r\ncase TVP5150_COMPOSITE1:\r\ninput |= 2;\r\ncase TVP5150_COMPOSITE0:\r\nbreak;\r\ncase TVP5150_SVIDEO:\r\ndefault:\r\ninput |= 1;\r\nbreak;\r\n}\r\nv4l2_dbg(1, debug, sd, "Selecting video route: route input=%i, output=%i "\r\n"=> tvp5150 input=%i, opmode=%i\n",\r\ndecoder->input, decoder->output,\r\ninput, opmode);\r\ntvp5150_write(sd, TVP5150_OP_MODE_CTL, opmode);\r\ntvp5150_write(sd, TVP5150_VD_IN_SRC_SEL_1, input);\r\nval = tvp5150_read(sd, TVP5150_MISC_CTL);\r\nif (val < 0) {\r\nv4l2_err(sd, "%s: failed with error = %d\n", __func__, val);\r\nreturn;\r\n}\r\nif (decoder->input == TVP5150_SVIDEO)\r\nval = (val & ~0x40) | 0x10;\r\nelse\r\nval = (val & ~0x10) | 0x40;\r\ntvp5150_write(sd, TVP5150_MISC_CTL, val);\r\n}\r\nstatic int tvp5150_write_inittab(struct v4l2_subdev *sd,\r\nconst struct i2c_reg_value *regs)\r\n{\r\nwhile (regs->reg != 0xff) {\r\ntvp5150_write(sd, regs->reg, regs->value);\r\nregs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvp5150_vdp_init(struct v4l2_subdev *sd,\r\nconst struct i2c_vbi_ram_value *regs)\r\n{\r\nunsigned int i;\r\ntvp5150_write(sd, TVP5150_FULL_FIELD_ENA, 0);\r\nfor (i = TVP5150_LINE_MODE_INI; i <= TVP5150_LINE_MODE_END; i++)\r\ntvp5150_write(sd, i, 0xff);\r\nwhile (regs->reg != (u16)-1) {\r\ntvp5150_write(sd, TVP5150_CONF_RAM_ADDR_HIGH, regs->reg >> 8);\r\ntvp5150_write(sd, TVP5150_CONF_RAM_ADDR_LOW, regs->reg);\r\nfor (i = 0; i < 16; i++)\r\ntvp5150_write(sd, TVP5150_VDP_CONF_RAM_DATA, regs->values[i]);\r\nregs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvp5150_g_sliced_vbi_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_sliced_vbi_cap *cap)\r\n{\r\nconst struct i2c_vbi_ram_value *regs = vbi_ram_default;\r\nint line;\r\nv4l2_dbg(1, debug, sd, "g_sliced_vbi_cap\n");\r\nmemset(cap, 0, sizeof *cap);\r\nwhile (regs->reg != (u16)-1 ) {\r\nfor (line=regs->type.ini_line;line<=regs->type.end_line;line++) {\r\ncap->service_lines[0][line] |= regs->type.vbi_type;\r\n}\r\ncap->service_set |= regs->type.vbi_type;\r\nregs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvp5150_set_vbi(struct v4l2_subdev *sd,\r\nconst struct i2c_vbi_ram_value *regs,\r\nunsigned int type,u8 flags, int line,\r\nconst int fields)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nv4l2_std_id std = decoder->norm;\r\nu8 reg;\r\nint pos=0;\r\nif (std == V4L2_STD_ALL) {\r\nv4l2_err(sd, "VBI can't be configured without knowing number of lines\n");\r\nreturn 0;\r\n} else if (std & V4L2_STD_625_50) {\r\nline += 3;\r\n}\r\nif (line<6||line>27)\r\nreturn 0;\r\nwhile (regs->reg != (u16)-1 ) {\r\nif ((type & regs->type.vbi_type) &&\r\n(line>=regs->type.ini_line) &&\r\n(line<=regs->type.end_line)) {\r\ntype=regs->type.vbi_type;\r\nbreak;\r\n}\r\nregs++;\r\npos++;\r\n}\r\nif (regs->reg == (u16)-1)\r\nreturn 0;\r\ntype=pos | (flags & 0xf0);\r\nreg=((line-6)<<1)+TVP5150_LINE_MODE_INI;\r\nif (fields&1) {\r\ntvp5150_write(sd, reg, type);\r\n}\r\nif (fields&2) {\r\ntvp5150_write(sd, reg+1, type);\r\n}\r\nreturn type;\r\n}\r\nstatic int tvp5150_get_vbi(struct v4l2_subdev *sd,\r\nconst struct i2c_vbi_ram_value *regs, int line)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nv4l2_std_id std = decoder->norm;\r\nu8 reg;\r\nint pos, type = 0;\r\nint i, ret = 0;\r\nif (std == V4L2_STD_ALL) {\r\nv4l2_err(sd, "VBI can't be configured without knowing number of lines\n");\r\nreturn 0;\r\n} else if (std & V4L2_STD_625_50) {\r\nline += 3;\r\n}\r\nif (line < 6 || line > 27)\r\nreturn 0;\r\nreg = ((line - 6) << 1) + TVP5150_LINE_MODE_INI;\r\nfor (i = 0; i <= 1; i++) {\r\nret = tvp5150_read(sd, reg + i);\r\nif (ret < 0) {\r\nv4l2_err(sd, "%s: failed with error = %d\n",\r\n__func__, ret);\r\nreturn 0;\r\n}\r\npos = ret & 0x0f;\r\nif (pos < 0x0f)\r\ntype |= regs[pos].type.vbi_type;\r\n}\r\nreturn type;\r\n}\r\nstatic int tvp5150_set_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nint fmt = 0;\r\ndecoder->norm = std;\r\nif (std == V4L2_STD_NTSC_443) {\r\nfmt = VIDEO_STD_NTSC_4_43_BIT;\r\n} else if (std == V4L2_STD_PAL_M) {\r\nfmt = VIDEO_STD_PAL_M_BIT;\r\n} else if (std == V4L2_STD_PAL_N || std == V4L2_STD_PAL_Nc) {\r\nfmt = VIDEO_STD_PAL_COMBINATION_N_BIT;\r\n} else {\r\nif (std & V4L2_STD_NTSC)\r\nfmt = VIDEO_STD_NTSC_MJ_BIT;\r\nelse if (std & V4L2_STD_PAL)\r\nfmt = VIDEO_STD_PAL_BDGHIN_BIT;\r\nelse if (std & V4L2_STD_SECAM)\r\nfmt = VIDEO_STD_SECAM_BIT;\r\n}\r\nv4l2_dbg(1, debug, sd, "Set video std register to %d.\n", fmt);\r\ntvp5150_write(sd, TVP5150_VIDEO_STD, fmt);\r\nreturn 0;\r\n}\r\nstatic int tvp5150_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nif (decoder->norm == std)\r\nreturn 0;\r\nif (std & V4L2_STD_525_60)\r\ndecoder->rect.height = TVP5150_V_MAX_525_60;\r\nelse\r\ndecoder->rect.height = TVP5150_V_MAX_OTHERS;\r\nreturn tvp5150_set_std(sd, std);\r\n}\r\nstatic int tvp5150_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\ntvp5150_write_inittab(sd, tvp5150_init_default);\r\ntvp5150_vdp_init(sd, vbi_ram_default);\r\ntvp5150_selmux(sd);\r\ntvp5150_write_inittab(sd, tvp5150_init_enable);\r\nv4l2_ctrl_handler_setup(&decoder->hdl);\r\ntvp5150_set_std(sd, decoder->norm);\r\nif (decoder->mbus_type == V4L2_MBUS_PARALLEL)\r\ntvp5150_write(sd, TVP5150_DATA_RATE_SEL, 0x40);\r\nreturn 0;\r\n}\r\nstatic int tvp5150_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ntvp5150_write(sd, TVP5150_BRIGHT_CTL, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_CONTRAST:\r\ntvp5150_write(sd, TVP5150_CONTRAST_CTL, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\ntvp5150_write(sd, TVP5150_SATURATION_CTL, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\ntvp5150_write(sd, TVP5150_HUE_CTL, ctrl->val);\r\ncase V4L2_CID_TEST_PATTERN:\r\ndecoder->enable = ctrl->val ? false : true;\r\ntvp5150_selmux(sd);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic v4l2_std_id tvp5150_read_std(struct v4l2_subdev *sd)\r\n{\r\nint val = tvp5150_read(sd, TVP5150_STATUS_REG_5);\r\nswitch (val & 0x0F) {\r\ncase 0x01:\r\nreturn V4L2_STD_NTSC;\r\ncase 0x03:\r\nreturn V4L2_STD_PAL;\r\ncase 0x05:\r\nreturn V4L2_STD_PAL_M;\r\ncase 0x07:\r\nreturn V4L2_STD_PAL_N | V4L2_STD_PAL_Nc;\r\ncase 0x09:\r\nreturn V4L2_STD_NTSC_443;\r\ncase 0xb:\r\nreturn V4L2_STD_SECAM;\r\ndefault:\r\nreturn V4L2_STD_UNKNOWN;\r\n}\r\n}\r\nstatic int tvp5150_fill_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *f;\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nif (!format || format->pad)\r\nreturn -EINVAL;\r\nf = &format->format;\r\ntvp5150_reset(sd, 0);\r\nf->width = decoder->rect.width;\r\nf->height = decoder->rect.height / 2;\r\nf->code = MEDIA_BUS_FMT_UYVY8_2X8;\r\nf->field = V4L2_FIELD_ALTERNATE;\r\nf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nv4l2_dbg(1, debug, sd, "width = %d, height = %d\n", f->width,\r\nf->height);\r\nreturn 0;\r\n}\r\nstatic int tvp5150_s_crop(struct v4l2_subdev *sd, const struct v4l2_crop *a)\r\n{\r\nstruct v4l2_rect rect = a->c;\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nv4l2_std_id std;\r\nunsigned int hmax;\r\nv4l2_dbg(1, debug, sd, "%s left=%d, top=%d, width=%d, height=%d\n",\r\n__func__, rect.left, rect.top, rect.width, rect.height);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nrect.left = clamp(rect.left, 0, TVP5150_MAX_CROP_LEFT);\r\nrect.width = clamp_t(unsigned int, rect.width,\r\nTVP5150_H_MAX - TVP5150_MAX_CROP_LEFT - rect.left,\r\nTVP5150_H_MAX - rect.left);\r\nrect.top = clamp(rect.top, 0, TVP5150_MAX_CROP_TOP);\r\nif (decoder->norm == V4L2_STD_ALL)\r\nstd = tvp5150_read_std(sd);\r\nelse\r\nstd = decoder->norm;\r\nif (std & V4L2_STD_525_60)\r\nhmax = TVP5150_V_MAX_525_60;\r\nelse\r\nhmax = TVP5150_V_MAX_OTHERS;\r\nrect.height = clamp_t(unsigned int, rect.height,\r\nhmax - TVP5150_MAX_CROP_TOP - rect.top,\r\nhmax - rect.top);\r\ntvp5150_write(sd, TVP5150_VERT_BLANKING_START, rect.top);\r\ntvp5150_write(sd, TVP5150_VERT_BLANKING_STOP,\r\nrect.top + rect.height - hmax);\r\ntvp5150_write(sd, TVP5150_ACT_VD_CROP_ST_MSB,\r\nrect.left >> TVP5150_CROP_SHIFT);\r\ntvp5150_write(sd, TVP5150_ACT_VD_CROP_ST_LSB,\r\nrect.left | (1 << TVP5150_CROP_SHIFT));\r\ntvp5150_write(sd, TVP5150_ACT_VD_CROP_STP_MSB,\r\n(rect.left + rect.width - TVP5150_MAX_CROP_LEFT) >>\r\nTVP5150_CROP_SHIFT);\r\ntvp5150_write(sd, TVP5150_ACT_VD_CROP_STP_LSB,\r\nrect.left + rect.width - TVP5150_MAX_CROP_LEFT);\r\ndecoder->rect = rect;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\na->c = decoder->rect;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nv4l2_std_id std;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = TVP5150_H_MAX;\r\nif (decoder->norm == V4L2_STD_ALL)\r\nstd = tvp5150_read_std(sd);\r\nelse\r\nstd = decoder->norm;\r\nif (std & V4L2_STD_525_60)\r\na->bounds.height = TVP5150_V_MAX_525_60;\r\nelse\r\na->bounds.height = TVP5150_V_MAX_OTHERS;\r\na->defrect = a->bounds;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\ncfg->type = decoder->mbus_type;\r\ncfg->flags = V4L2_MBUS_MASTER | V4L2_MBUS_PCLK_SAMPLE_RISING\r\n| V4L2_MBUS_FIELD_EVEN_LOW | V4L2_MBUS_DATA_ACTIVE_HIGH;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad || code->index)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_UYVY8_2X8;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nif (fse->index >= 8 || fse->code != MEDIA_BUS_FMT_UYVY8_2X8)\r\nreturn -EINVAL;\r\nfse->code = MEDIA_BUS_FMT_UYVY8_2X8;\r\nfse->min_width = decoder->rect.width;\r\nfse->max_width = decoder->rect.width;\r\nfse->min_height = decoder->rect.height / 2;\r\nfse->max_height = decoder->rect.height / 2;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nint i;\r\nfor (i = 0; i < TVP5150_INPUT_NUM; i++) {\r\nif (remote->entity == &decoder->input_ent[i])\r\nbreak;\r\n}\r\nif (i == TVP5150_INPUT_NUM)\r\nreturn 0;\r\ndecoder->input = i;\r\ntvp5150_selmux(sd);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int tvp5150_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nint val = 0x09;\r\nif (decoder->mbus_type == V4L2_MBUS_PARALLEL)\r\nval = 0x0d;\r\ntvp5150_write(sd, TVP5150_CONF_SHARED_PIN, 0x00);\r\nif (enable)\r\ntvp5150_write(sd, TVP5150_MISC_CTL, val);\r\nelse\r\ntvp5150_write(sd, TVP5150_MISC_CTL, 0x00);\r\nreturn 0;\r\n}\r\nstatic int tvp5150_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\ndecoder->input = input;\r\ndecoder->output = output;\r\nif (output == TVP5150_BLACK_SCREEN)\r\ndecoder->enable = false;\r\nelse\r\ndecoder->enable = true;\r\ntvp5150_selmux(sd);\r\nreturn 0;\r\n}\r\nstatic int tvp5150_s_raw_fmt(struct v4l2_subdev *sd, struct v4l2_vbi_format *fmt)\r\n{\r\nif (fmt->sample_format == V4L2_PIX_FMT_GREY)\r\ntvp5150_write(sd, TVP5150_LUMA_PROC_CTL_1, 0x70);\r\nif (fmt->count[0] == 18 && fmt->count[1] == 18) {\r\ntvp5150_write(sd, TVP5150_VERT_BLANKING_START, 0x00);\r\ntvp5150_write(sd, TVP5150_VERT_BLANKING_STOP, 0x01);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvp5150_s_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *svbi)\r\n{\r\nint i;\r\nif (svbi->service_set != 0) {\r\nfor (i = 0; i <= 23; i++) {\r\nsvbi->service_lines[1][i] = 0;\r\nsvbi->service_lines[0][i] =\r\ntvp5150_set_vbi(sd, vbi_ram_default,\r\nsvbi->service_lines[0][i], 0xf0, i, 3);\r\n}\r\ntvp5150_write(sd, TVP5150_FIFO_OUT_CTRL, 1);\r\n} else {\r\ntvp5150_write(sd, TVP5150_FIFO_OUT_CTRL, 0);\r\ntvp5150_write(sd, TVP5150_FULL_FIELD_ENA, 0);\r\nfor (i = TVP5150_LINE_MODE_INI; i <= TVP5150_LINE_MODE_END; i++)\r\ntvp5150_write(sd, i, 0xff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvp5150_g_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *svbi)\r\n{\r\nint i, mask = 0;\r\nmemset(svbi->service_lines, 0, sizeof(svbi->service_lines));\r\nfor (i = 0; i <= 23; i++) {\r\nsvbi->service_lines[0][i] =\r\ntvp5150_get_vbi(sd, vbi_ram_default, i);\r\nmask |= svbi->service_lines[0][i];\r\n}\r\nsvbi->service_set = mask;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nint res;\r\nres = tvp5150_read(sd, reg->reg & 0xff);\r\nif (res < 0) {\r\nv4l2_err(sd, "%s: failed with error = %d\n", __func__, res);\r\nreturn res;\r\n}\r\nreg->val = res;\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\r\n{\r\nreturn tvp5150_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\n}\r\nstatic int tvp5150_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nint status = tvp5150_read(sd, 0x88);\r\nvt->signal = ((status & 0x04) && (status & 0x02)) ? 0xffff : 0x0;\r\nreturn 0;\r\n}\r\nstatic int tvp5150_registered_async(struct v4l2_subdev *sd)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < TVP5150_INPUT_NUM; i++) {\r\nstruct media_entity *input = &decoder->input_ent[i];\r\nstruct media_pad *pad = &decoder->input_pad[i];\r\nif (!input->name)\r\ncontinue;\r\ndecoder->input_pad[i].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(input, 1, pad);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_device_register_entity(sd->v4l2_dev->mdev, input);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_create_pad_link(input, 0, &sd->entity,\r\nDEMOD_PAD_IF_INPUT, 0);\r\nif (ret < 0) {\r\nmedia_device_unregister_entity(input);\r\nreturn ret;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int tvp5150_detect_version(struct tvp5150 *core)\r\n{\r\nstruct v4l2_subdev *sd = &core->sd;\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nunsigned int i;\r\nu8 regs[4];\r\nint res;\r\nfor (i = 0; i < 4; i++) {\r\nres = tvp5150_read(sd, TVP5150_MSB_DEV_ID + i);\r\nif (res < 0)\r\nreturn res;\r\nregs[i] = res;\r\n}\r\ncore->dev_id = (regs[0] << 8) | regs[1];\r\ncore->rom_ver = (regs[2] << 8) | regs[3];\r\nv4l2_info(sd, "tvp%04x (%u.%u) chip found @ 0x%02x (%s)\n",\r\ncore->dev_id, regs[2], regs[3], c->addr << 1,\r\nc->adapter->name);\r\nif (core->dev_id == 0x5150 && core->rom_ver == 0x0321) {\r\nv4l2_info(sd, "tvp5150a detected.\n");\r\n} else if (core->dev_id == 0x5150 && core->rom_ver == 0x0400) {\r\nv4l2_info(sd, "tvp5150am1 detected.\n");\r\ntvp5150_write(sd, TVP5150_REV_SELECT, 0);\r\n} else if (core->dev_id == 0x5151 && core->rom_ver == 0x0100) {\r\nv4l2_info(sd, "tvp5151 detected.\n");\r\n} else {\r\nv4l2_info(sd, "*** unknown tvp%04x chip detected.\n",\r\ncore->dev_id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvp5150_init(struct i2c_client *c)\r\n{\r\nstruct gpio_desc *pdn_gpio;\r\nstruct gpio_desc *reset_gpio;\r\npdn_gpio = devm_gpiod_get_optional(&c->dev, "pdn", GPIOD_OUT_HIGH);\r\nif (IS_ERR(pdn_gpio))\r\nreturn PTR_ERR(pdn_gpio);\r\nif (pdn_gpio) {\r\ngpiod_set_value_cansleep(pdn_gpio, 0);\r\nmsleep(20);\r\n}\r\nreset_gpio = devm_gpiod_get_optional(&c->dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(reset_gpio))\r\nreturn PTR_ERR(reset_gpio);\r\nif (reset_gpio) {\r\nndelay(500);\r\ngpiod_set_value_cansleep(reset_gpio, 0);\r\nusleep_range(200, 250);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvp5150_parse_dt(struct tvp5150 *decoder, struct device_node *np)\r\n{\r\nstruct v4l2_of_endpoint bus_cfg;\r\nstruct device_node *ep;\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nstruct device_node *connectors, *child;\r\nstruct media_entity *input;\r\nconst char *name;\r\nu32 input_type;\r\n#endif\r\nunsigned int flags;\r\nint ret = 0;\r\nep = of_graph_get_next_endpoint(np, NULL);\r\nif (!ep)\r\nreturn -EINVAL;\r\nret = v4l2_of_parse_endpoint(ep, &bus_cfg);\r\nif (ret)\r\ngoto err;\r\nflags = bus_cfg.bus.parallel.flags;\r\nif (bus_cfg.bus_type == V4L2_MBUS_PARALLEL &&\r\n!(flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH &&\r\nflags & V4L2_MBUS_VSYNC_ACTIVE_HIGH &&\r\nflags & V4L2_MBUS_FIELD_EVEN_LOW)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndecoder->mbus_type = bus_cfg.bus_type;\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nconnectors = of_get_child_by_name(np, "connectors");\r\nif (!connectors)\r\ngoto err;\r\nfor_each_available_child_of_node(connectors, child) {\r\nret = of_property_read_u32(child, "input", &input_type);\r\nif (ret) {\r\nv4l2_err(&decoder->sd,\r\n"missing type property in node %s\n",\r\nchild->name);\r\ngoto err_connector;\r\n}\r\nif (input_type >= TVP5150_INPUT_NUM) {\r\nret = -EINVAL;\r\ngoto err_connector;\r\n}\r\ninput = &decoder->input_ent[input_type];\r\nif (input->name) {\r\nv4l2_err(&decoder->sd,\r\n"input %s with same type already exists\n",\r\ninput->name);\r\nret = -EINVAL;\r\ngoto err_connector;\r\n}\r\nswitch (input_type) {\r\ncase TVP5150_COMPOSITE0:\r\ncase TVP5150_COMPOSITE1:\r\ninput->function = MEDIA_ENT_F_CONN_COMPOSITE;\r\nbreak;\r\ncase TVP5150_SVIDEO:\r\ninput->function = MEDIA_ENT_F_CONN_SVIDEO;\r\nbreak;\r\n}\r\ninput->flags = MEDIA_ENT_FL_CONNECTOR;\r\nret = of_property_read_string(child, "label", &name);\r\nif (ret < 0) {\r\nv4l2_err(&decoder->sd,\r\n"missing label property in node %s\n",\r\nchild->name);\r\ngoto err_connector;\r\n}\r\ninput->name = name;\r\n}\r\nerr_connector:\r\nof_node_put(connectors);\r\n#endif\r\nerr:\r\nof_node_put(ep);\r\nreturn ret;\r\n}\r\nstatic int tvp5150_probe(struct i2c_client *c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tvp5150 *core;\r\nstruct v4l2_subdev *sd;\r\nstruct device_node *np = c->dev.of_node;\r\nint res;\r\nif (!i2c_check_functionality(c->adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -EIO;\r\nres = tvp5150_init(c);\r\nif (res)\r\nreturn res;\r\ncore = devm_kzalloc(&c->dev, sizeof(*core), GFP_KERNEL);\r\nif (!core)\r\nreturn -ENOMEM;\r\nsd = &core->sd;\r\nif (IS_ENABLED(CONFIG_OF) && np) {\r\nres = tvp5150_parse_dt(core, np);\r\nif (res) {\r\nv4l2_err(sd, "DT parsing error: %d\n", res);\r\nreturn res;\r\n}\r\n} else {\r\ncore->mbus_type = V4L2_MBUS_BT656;\r\n}\r\nv4l2_i2c_subdev_init(sd, c, &tvp5150_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\ncore->pads[DEMOD_PAD_IF_INPUT].flags = MEDIA_PAD_FL_SINK;\r\ncore->pads[DEMOD_PAD_VID_OUT].flags = MEDIA_PAD_FL_SOURCE;\r\ncore->pads[DEMOD_PAD_VBI_OUT].flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.function = MEDIA_ENT_F_ATV_DECODER;\r\nres = media_entity_pads_init(&sd->entity, DEMOD_NUM_PADS, core->pads);\r\nif (res < 0)\r\nreturn res;\r\nsd->entity.ops = &tvp5150_sd_media_ops;\r\n#endif\r\nres = tvp5150_detect_version(core);\r\nif (res < 0)\r\nreturn res;\r\ncore->norm = V4L2_STD_ALL;\r\ncore->input = TVP5150_COMPOSITE1;\r\ncore->enable = true;\r\nv4l2_ctrl_handler_init(&core->hdl, 5);\r\nv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, 27000000,\r\n27000000, 1, 27000000);\r\nv4l2_ctrl_new_std_menu_items(&core->hdl, &tvp5150_ctrl_ops,\r\nV4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(tvp5150_test_patterns),\r\n0, 0, tvp5150_test_patterns);\r\nsd->ctrl_handler = &core->hdl;\r\nif (core->hdl.error) {\r\nres = core->hdl.error;\r\ngoto err;\r\n}\r\nv4l2_ctrl_handler_setup(&core->hdl);\r\ncore->rect.top = 0;\r\nif (tvp5150_read_std(sd) & V4L2_STD_525_60)\r\ncore->rect.height = TVP5150_V_MAX_525_60;\r\nelse\r\ncore->rect.height = TVP5150_V_MAX_OTHERS;\r\ncore->rect.left = 0;\r\ncore->rect.width = TVP5150_H_MAX;\r\nres = v4l2_async_register_subdev(sd);\r\nif (res < 0)\r\ngoto err;\r\nif (debug > 1)\r\ntvp5150_log_status(sd);\r\nreturn 0;\r\nerr:\r\nv4l2_ctrl_handler_free(&core->hdl);\r\nreturn res;\r\n}\r\nstatic int tvp5150_remove(struct i2c_client *c)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(c);\r\nstruct tvp5150 *decoder = to_tvp5150(sd);\r\nv4l2_dbg(1, debug, sd,\r\n"tvp5150.c: removing tvp5150 adapter on address 0x%x\n",\r\nc->addr << 1);\r\nv4l2_async_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nreturn 0;\r\n}
