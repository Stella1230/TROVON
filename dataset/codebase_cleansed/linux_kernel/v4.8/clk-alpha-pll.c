static int wait_for_pll(struct clk_alpha_pll *pll)\r\n{\r\nu32 val, mask, off;\r\nint count;\r\nint ret;\r\nconst char *name = clk_hw_get_name(&pll->clkr.hw);\r\noff = pll->offset;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val & PLL_VOTE_FSM_ENA)\r\nmask = PLL_ACTIVE_FLAG;\r\nelse\r\nmask = PLL_LOCK_DET;\r\nfor (count = 100; count > 0; count--) {\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nif ((val & mask) == mask)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nWARN(1, "%s didn't enable after voting for it!\n", name);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int clk_alpha_pll_enable(struct clk_hw *hw)\r\n{\r\nint ret;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nu32 val, mask, off;\r\noff = pll->offset;\r\nmask = PLL_OUTCTRL | PLL_RESET_N | PLL_BYPASSNL;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val & PLL_VOTE_FSM_ENA) {\r\nret = clk_enable_regmap(hw);\r\nif (ret)\r\nreturn ret;\r\nreturn wait_for_pll(pll);\r\n}\r\nif ((val & mask) == mask)\r\nreturn 0;\r\nret = regmap_update_bits(pll->clkr.regmap, off + PLL_MODE,\r\nPLL_BYPASSNL, PLL_BYPASSNL);\r\nif (ret)\r\nreturn ret;\r\nmb();\r\nudelay(5);\r\nret = regmap_update_bits(pll->clkr.regmap, off + PLL_MODE,\r\nPLL_RESET_N, PLL_RESET_N);\r\nif (ret)\r\nreturn ret;\r\nret = wait_for_pll(pll);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(pll->clkr.regmap, off + PLL_MODE,\r\nPLL_OUTCTRL, PLL_OUTCTRL);\r\nmb();\r\nreturn ret;\r\n}\r\nstatic void clk_alpha_pll_disable(struct clk_hw *hw)\r\n{\r\nint ret;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nu32 val, mask, off;\r\noff = pll->offset;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn;\r\nif (val & PLL_VOTE_FSM_ENA) {\r\nclk_disable_regmap(hw);\r\nreturn;\r\n}\r\nmask = PLL_OUTCTRL;\r\nregmap_update_bits(pll->clkr.regmap, off + PLL_MODE, mask, 0);\r\nmb();\r\nudelay(1);\r\nmask = PLL_RESET_N | PLL_BYPASSNL;\r\nregmap_update_bits(pll->clkr.regmap, off + PLL_MODE, mask, 0);\r\n}\r\nstatic unsigned long alpha_pll_calc_rate(u64 prate, u32 l, u32 a)\r\n{\r\nreturn (prate * l) + ((prate * a) >> ALPHA_BITWIDTH);\r\n}\r\nstatic unsigned long\r\nalpha_pll_round_rate(unsigned long rate, unsigned long prate, u32 *l, u64 *a)\r\n{\r\nu64 remainder;\r\nu64 quotient;\r\nquotient = rate;\r\nremainder = do_div(quotient, prate);\r\n*l = quotient;\r\nif (!remainder) {\r\n*a = 0;\r\nreturn rate;\r\n}\r\nquotient = remainder << ALPHA_BITWIDTH;\r\nremainder = do_div(quotient, prate);\r\nif (remainder)\r\nquotient++;\r\n*a = quotient;\r\nreturn alpha_pll_calc_rate(prate, *l, *a);\r\n}\r\nstatic const struct pll_vco *\r\nalpha_pll_find_vco(const struct clk_alpha_pll *pll, unsigned long rate)\r\n{\r\nconst struct pll_vco *v = pll->vco_table;\r\nconst struct pll_vco *end = v + pll->num_vco;\r\nfor (; v < end; v++)\r\nif (rate >= v->min_freq && rate <= v->max_freq)\r\nreturn v;\r\nreturn NULL;\r\n}\r\nstatic unsigned long\r\nclk_alpha_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nu32 l, low, high, ctl;\r\nu64 a = 0, prate = parent_rate;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nu32 off = pll->offset;\r\nregmap_read(pll->clkr.regmap, off + PLL_L_VAL, &l);\r\nregmap_read(pll->clkr.regmap, off + PLL_USER_CTL, &ctl);\r\nif (ctl & PLL_ALPHA_EN) {\r\nregmap_read(pll->clkr.regmap, off + PLL_ALPHA_VAL, &low);\r\nregmap_read(pll->clkr.regmap, off + PLL_ALPHA_VAL_U, &high);\r\na = (u64)high << 32 | low;\r\na >>= ALPHA_REG_BITWIDTH - ALPHA_BITWIDTH;\r\n}\r\nreturn alpha_pll_calc_rate(prate, l, a);\r\n}\r\nstatic int clk_alpha_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long prate)\r\n{\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nconst struct pll_vco *vco;\r\nu32 l, off = pll->offset;\r\nu64 a;\r\nrate = alpha_pll_round_rate(rate, prate, &l, &a);\r\nvco = alpha_pll_find_vco(pll, rate);\r\nif (!vco) {\r\npr_err("alpha pll not in a valid vco range\n");\r\nreturn -EINVAL;\r\n}\r\na <<= (ALPHA_REG_BITWIDTH - ALPHA_BITWIDTH);\r\nregmap_write(pll->clkr.regmap, off + PLL_L_VAL, l);\r\nregmap_write(pll->clkr.regmap, off + PLL_ALPHA_VAL, a);\r\nregmap_write(pll->clkr.regmap, off + PLL_ALPHA_VAL_U, a >> 32);\r\nregmap_update_bits(pll->clkr.regmap, off + PLL_USER_CTL,\r\nPLL_VCO_MASK << PLL_VCO_SHIFT,\r\nvco->val << PLL_VCO_SHIFT);\r\nregmap_update_bits(pll->clkr.regmap, off + PLL_USER_CTL, PLL_ALPHA_EN,\r\nPLL_ALPHA_EN);\r\nreturn 0;\r\n}\r\nstatic long clk_alpha_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nu32 l;\r\nu64 a;\r\nunsigned long min_freq, max_freq;\r\nrate = alpha_pll_round_rate(rate, *prate, &l, &a);\r\nif (alpha_pll_find_vco(pll, rate))\r\nreturn rate;\r\nmin_freq = pll->vco_table[0].min_freq;\r\nmax_freq = pll->vco_table[pll->num_vco - 1].max_freq;\r\nreturn clamp(rate, min_freq, max_freq);\r\n}\r\nstatic unsigned long\r\nclk_alpha_pll_postdiv_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\r\nu32 ctl;\r\nregmap_read(pll->clkr.regmap, pll->offset + PLL_USER_CTL, &ctl);\r\nctl >>= PLL_POST_DIV_SHIFT;\r\nctl &= PLL_POST_DIV_MASK;\r\nreturn parent_rate >> fls(ctl);\r\n}\r\nstatic long\r\nclk_alpha_pll_postdiv_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\r\nreturn divider_round_rate(hw, rate, prate, clk_alpha_div_table,\r\npll->width, CLK_DIVIDER_POWER_OF_TWO);\r\n}\r\nstatic int clk_alpha_pll_postdiv_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\r\nint div;\r\ndiv = DIV_ROUND_UP_ULL((u64)parent_rate, rate) - 1;\r\nreturn regmap_update_bits(pll->clkr.regmap, pll->offset + PLL_USER_CTL,\r\nPLL_POST_DIV_MASK << PLL_POST_DIV_SHIFT,\r\ndiv << PLL_POST_DIV_SHIFT);\r\n}
