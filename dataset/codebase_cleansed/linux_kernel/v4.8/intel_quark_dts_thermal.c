static int soc_dts_enable(struct thermal_zone_device *tzd)\r\n{\r\nu32 out;\r\nstruct soc_sensor_entry *aux_entry = tzd->devdata;\r\nint ret;\r\nret = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\r\nQRK_DTS_REG_OFFSET_ENABLE, &out);\r\nif (ret)\r\nreturn ret;\r\nif (out & QRK_DTS_ENABLE_BIT) {\r\naux_entry->mode = THERMAL_DEVICE_ENABLED;\r\nreturn 0;\r\n}\r\nif (!aux_entry->locked) {\r\nout |= QRK_DTS_ENABLE_BIT;\r\nret = iosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\r\nQRK_DTS_REG_OFFSET_ENABLE, out);\r\nif (ret)\r\nreturn ret;\r\naux_entry->mode = THERMAL_DEVICE_ENABLED;\r\n} else {\r\naux_entry->mode = THERMAL_DEVICE_DISABLED;\r\npr_info("DTS is locked. Cannot enable DTS\n");\r\nret = -EPERM;\r\n}\r\nreturn ret;\r\n}\r\nstatic int soc_dts_disable(struct thermal_zone_device *tzd)\r\n{\r\nu32 out;\r\nstruct soc_sensor_entry *aux_entry = tzd->devdata;\r\nint ret;\r\nret = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\r\nQRK_DTS_REG_OFFSET_ENABLE, &out);\r\nif (ret)\r\nreturn ret;\r\nif (!(out & QRK_DTS_ENABLE_BIT)) {\r\naux_entry->mode = THERMAL_DEVICE_DISABLED;\r\nreturn 0;\r\n}\r\nif (!aux_entry->locked) {\r\nout &= ~QRK_DTS_ENABLE_BIT;\r\nret = iosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\r\nQRK_DTS_REG_OFFSET_ENABLE, out);\r\nif (ret)\r\nreturn ret;\r\naux_entry->mode = THERMAL_DEVICE_DISABLED;\r\n} else {\r\naux_entry->mode = THERMAL_DEVICE_ENABLED;\r\npr_info("DTS is locked. Cannot disable DTS\n");\r\nret = -EPERM;\r\n}\r\nreturn ret;\r\n}\r\nstatic int _get_trip_temp(int trip, int *temp)\r\n{\r\nint status;\r\nu32 out;\r\nmutex_lock(&dts_update_mutex);\r\nstatus = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\r\nQRK_DTS_REG_OFFSET_PTPS, &out);\r\nmutex_unlock(&dts_update_mutex);\r\nif (status)\r\nreturn status;\r\n*temp = (out >> (trip * QRK_DTS_SHIFT_TP)) & QRK_DTS_MASK_TP_THRES;\r\n*temp -= QRK_DTS_TEMP_BASE;\r\nreturn 0;\r\n}\r\nstatic inline int sys_get_trip_temp(struct thermal_zone_device *tzd,\r\nint trip, int *temp)\r\n{\r\nreturn _get_trip_temp(trip, temp);\r\n}\r\nstatic inline int sys_get_crit_temp(struct thermal_zone_device *tzd, int *temp)\r\n{\r\nreturn _get_trip_temp(QRK_DTS_ID_TP_CRITICAL, temp);\r\n}\r\nstatic int update_trip_temp(struct soc_sensor_entry *aux_entry,\r\nint trip, int temp)\r\n{\r\nu32 out;\r\nu32 temp_out;\r\nu32 store_ptps;\r\nint ret;\r\nmutex_lock(&dts_update_mutex);\r\nif (aux_entry->locked) {\r\nret = -EPERM;\r\ngoto failed;\r\n}\r\nret = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\r\nQRK_DTS_REG_OFFSET_PTPS, &store_ptps);\r\nif (ret)\r\ngoto failed;\r\nif (temp > QRK_DTS_SAFE_TP_THRES)\r\ntemp = QRK_DTS_SAFE_TP_THRES;\r\ntemp_out = temp + QRK_DTS_TEMP_BASE;\r\nout = (store_ptps & ~(QRK_DTS_MASK_TP_THRES <<\r\n(trip * QRK_DTS_SHIFT_TP)));\r\nout |= (temp_out & QRK_DTS_MASK_TP_THRES) <<\r\n(trip * QRK_DTS_SHIFT_TP);\r\nret = iosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\r\nQRK_DTS_REG_OFFSET_PTPS, out);\r\nfailed:\r\nmutex_unlock(&dts_update_mutex);\r\nreturn ret;\r\n}\r\nstatic inline int sys_set_trip_temp(struct thermal_zone_device *tzd, int trip,\r\nint temp)\r\n{\r\nreturn update_trip_temp(tzd->devdata, trip, temp);\r\n}\r\nstatic int sys_get_trip_type(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\nif (trip)\r\n*type = THERMAL_TRIP_HOT;\r\nelse\r\n*type = THERMAL_TRIP_CRITICAL;\r\nreturn 0;\r\n}\r\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd,\r\nint *temp)\r\n{\r\nu32 out;\r\nint ret;\r\nmutex_lock(&dts_update_mutex);\r\nret = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\r\nQRK_DTS_REG_OFFSET_TEMP, &out);\r\nmutex_unlock(&dts_update_mutex);\r\nif (ret)\r\nreturn ret;\r\nout = (out >> QRK_DTS_OFFSET_TEMP) & QRK_DTS_MASK_TEMP;\r\n*temp = out - QRK_DTS_TEMP_BASE;\r\nreturn 0;\r\n}\r\nstatic int sys_get_mode(struct thermal_zone_device *tzd,\r\nenum thermal_device_mode *mode)\r\n{\r\nstruct soc_sensor_entry *aux_entry = tzd->devdata;\r\n*mode = aux_entry->mode;\r\nreturn 0;\r\n}\r\nstatic int sys_set_mode(struct thermal_zone_device *tzd,\r\nenum thermal_device_mode mode)\r\n{\r\nint ret;\r\nmutex_lock(&dts_update_mutex);\r\nif (mode == THERMAL_DEVICE_ENABLED)\r\nret = soc_dts_enable(tzd);\r\nelse\r\nret = soc_dts_disable(tzd);\r\nmutex_unlock(&dts_update_mutex);\r\nreturn ret;\r\n}\r\nstatic void free_soc_dts(struct soc_sensor_entry *aux_entry)\r\n{\r\nif (aux_entry) {\r\nif (!aux_entry->locked) {\r\nmutex_lock(&dts_update_mutex);\r\niosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\r\nQRK_DTS_REG_OFFSET_ENABLE,\r\naux_entry->store_dts_enable);\r\niosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\r\nQRK_DTS_REG_OFFSET_PTPS,\r\naux_entry->store_ptps);\r\nmutex_unlock(&dts_update_mutex);\r\n}\r\nthermal_zone_device_unregister(aux_entry->tzone);\r\nkfree(aux_entry);\r\n}\r\n}\r\nstatic struct soc_sensor_entry *alloc_soc_dts(void)\r\n{\r\nstruct soc_sensor_entry *aux_entry;\r\nint err;\r\nu32 out;\r\nint wr_mask;\r\naux_entry = kzalloc(sizeof(*aux_entry), GFP_KERNEL);\r\nif (!aux_entry) {\r\nerr = -ENOMEM;\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nerr = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\r\nQRK_DTS_REG_OFFSET_LOCK, &out);\r\nif (err)\r\ngoto err_ret;\r\nif (out & QRK_DTS_LOCK_BIT) {\r\naux_entry->locked = true;\r\nwr_mask = QRK_DTS_WR_MASK_CLR;\r\n} else {\r\naux_entry->locked = false;\r\nwr_mask = QRK_DTS_WR_MASK_SET;\r\n}\r\nif (!aux_entry->locked) {\r\nerr = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\r\nQRK_DTS_REG_OFFSET_ENABLE,\r\n&aux_entry->store_dts_enable);\r\nif (err)\r\ngoto err_ret;\r\nerr = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\r\nQRK_DTS_REG_OFFSET_PTPS,\r\n&aux_entry->store_ptps);\r\nif (err)\r\ngoto err_ret;\r\n}\r\naux_entry->tzone = thermal_zone_device_register("quark_dts",\r\nQRK_MAX_DTS_TRIPS,\r\nwr_mask,\r\naux_entry, &tzone_ops, NULL, 0, polling_delay);\r\nif (IS_ERR(aux_entry->tzone)) {\r\nerr = PTR_ERR(aux_entry->tzone);\r\ngoto err_ret;\r\n}\r\nmutex_lock(&dts_update_mutex);\r\nerr = soc_dts_enable(aux_entry->tzone);\r\nmutex_unlock(&dts_update_mutex);\r\nif (err)\r\ngoto err_aux_status;\r\nreturn aux_entry;\r\nerr_aux_status:\r\nthermal_zone_device_unregister(aux_entry->tzone);\r\nerr_ret:\r\nkfree(aux_entry);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init intel_quark_thermal_init(void)\r\n{\r\nint err = 0;\r\nif (!x86_match_cpu(qrk_thermal_ids) || !iosf_mbi_available())\r\nreturn -ENODEV;\r\nsoc_dts = alloc_soc_dts();\r\nif (IS_ERR(soc_dts)) {\r\nerr = PTR_ERR(soc_dts);\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nfree_soc_dts(soc_dts);\r\nreturn err;\r\n}\r\nstatic void __exit intel_quark_thermal_exit(void)\r\n{\r\nfree_soc_dts(soc_dts);\r\n}
