int x509_get_sig_params(struct x509_certificate *cert)\r\n{\r\nstruct public_key_signature *sig = cert->sig;\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nsize_t desc_size;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nif (!cert->pub->pkey_algo)\r\ncert->unsupported_key = true;\r\nif (!sig->pkey_algo)\r\ncert->unsupported_sig = true;\r\nif (!sig->hash_algo) {\r\ncert->unsupported_sig = true;\r\nreturn 0;\r\n}\r\nsig->s = kmemdup(cert->raw_sig, cert->raw_sig_size, GFP_KERNEL);\r\nif (!sig->s)\r\nreturn -ENOMEM;\r\nsig->s_size = cert->raw_sig_size;\r\ntfm = crypto_alloc_shash(sig->hash_algo, 0, 0);\r\nif (IS_ERR(tfm)) {\r\nif (PTR_ERR(tfm) == -ENOENT) {\r\ncert->unsupported_sig = true;\r\nreturn 0;\r\n}\r\nreturn PTR_ERR(tfm);\r\n}\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\nsig->digest_size = crypto_shash_digestsize(tfm);\r\nret = -ENOMEM;\r\nsig->digest = kmalloc(sig->digest_size, GFP_KERNEL);\r\nif (!sig->digest)\r\ngoto error;\r\ndesc = kzalloc(desc_size, GFP_KERNEL);\r\nif (!desc)\r\ngoto error;\r\ndesc->tfm = tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error_2;\r\nmight_sleep();\r\nret = crypto_shash_finup(desc, cert->tbs, cert->tbs_size, sig->digest);\r\nerror_2:\r\nkfree(desc);\r\nerror:\r\ncrypto_free_shash(tfm);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint x509_check_for_self_signed(struct x509_certificate *cert)\r\n{\r\nint ret = 0;\r\npr_devel("==>%s()\n", __func__);\r\nif (cert->raw_subject_size != cert->raw_issuer_size ||\r\nmemcmp(cert->raw_subject, cert->raw_issuer,\r\ncert->raw_issuer_size) != 0)\r\ngoto not_self_signed;\r\nif (cert->sig->auth_ids[0] || cert->sig->auth_ids[1]) {\r\nbool a = asymmetric_key_id_same(cert->skid, cert->sig->auth_ids[1]);\r\nbool b = asymmetric_key_id_same(cert->id, cert->sig->auth_ids[0]);\r\nif (!a && !b)\r\ngoto not_self_signed;\r\nret = -EKEYREJECTED;\r\nif (((a && !b) || (b && !a)) &&\r\ncert->sig->auth_ids[0] && cert->sig->auth_ids[1])\r\ngoto out;\r\n}\r\nret = -EKEYREJECTED;\r\nif (cert->pub->pkey_algo != cert->sig->pkey_algo)\r\ngoto out;\r\nret = public_key_verify_signature(cert->pub, cert->sig);\r\nif (ret < 0) {\r\nif (ret == -ENOPKG) {\r\ncert->unsupported_sig = true;\r\nret = 0;\r\n}\r\ngoto out;\r\n}\r\npr_devel("Cert Self-signature verified");\r\ncert->self_signed = true;\r\nout:\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\nnot_self_signed:\r\npr_devel("<==%s() = 0 [not]\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int x509_key_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct asymmetric_key_ids *kids;\r\nstruct x509_certificate *cert;\r\nconst char *q;\r\nsize_t srlen, sulen;\r\nchar *desc = NULL, *p;\r\nint ret;\r\ncert = x509_cert_parse(prep->data, prep->datalen);\r\nif (IS_ERR(cert))\r\nreturn PTR_ERR(cert);\r\npr_devel("Cert Issuer: %s\n", cert->issuer);\r\npr_devel("Cert Subject: %s\n", cert->subject);\r\nif (cert->unsupported_key) {\r\nret = -ENOPKG;\r\ngoto error_free_cert;\r\n}\r\npr_devel("Cert Key Algo: %s\n", cert->pub->pkey_algo);\r\npr_devel("Cert Valid period: %lld-%lld\n", cert->valid_from, cert->valid_to);\r\ncert->pub->id_type = "X509";\r\nif (cert->unsupported_sig) {\r\npublic_key_signature_free(cert->sig);\r\ncert->sig = NULL;\r\n} else {\r\npr_devel("Cert Signature: %s + %s\n",\r\ncert->sig->pkey_algo, cert->sig->hash_algo);\r\n}\r\nsulen = strlen(cert->subject);\r\nif (cert->raw_skid) {\r\nsrlen = cert->raw_skid_size;\r\nq = cert->raw_skid;\r\n} else {\r\nsrlen = cert->raw_serial_size;\r\nq = cert->raw_serial;\r\n}\r\nret = -ENOMEM;\r\ndesc = kmalloc(sulen + 2 + srlen * 2 + 1, GFP_KERNEL);\r\nif (!desc)\r\ngoto error_free_cert;\r\np = memcpy(desc, cert->subject, sulen);\r\np += sulen;\r\n*p++ = ':';\r\n*p++ = ' ';\r\np = bin2hex(p, q, srlen);\r\n*p = 0;\r\nkids = kmalloc(sizeof(struct asymmetric_key_ids), GFP_KERNEL);\r\nif (!kids)\r\ngoto error_free_desc;\r\nkids->id[0] = cert->id;\r\nkids->id[1] = cert->skid;\r\n__module_get(public_key_subtype.owner);\r\nprep->payload.data[asym_subtype] = &public_key_subtype;\r\nprep->payload.data[asym_key_ids] = kids;\r\nprep->payload.data[asym_crypto] = cert->pub;\r\nprep->payload.data[asym_auth] = cert->sig;\r\nprep->description = desc;\r\nprep->quotalen = 100;\r\ncert->pub = NULL;\r\ncert->id = NULL;\r\ncert->skid = NULL;\r\ncert->sig = NULL;\r\ndesc = NULL;\r\nret = 0;\r\nerror_free_desc:\r\nkfree(desc);\r\nerror_free_cert:\r\nx509_free_certificate(cert);\r\nreturn ret;\r\n}\r\nstatic int __init x509_key_init(void)\r\n{\r\nreturn register_asymmetric_key_parser(&x509_key_parser);\r\n}\r\nstatic void __exit x509_key_exit(void)\r\n{\r\nunregister_asymmetric_key_parser(&x509_key_parser);\r\n}
