static inline void spm_register_write(struct spm_driver_data *drv,\r\nenum spm_reg reg, u32 val)\r\n{\r\nif (drv->reg_data->reg_offset[reg])\r\nwritel_relaxed(val, drv->reg_base +\r\ndrv->reg_data->reg_offset[reg]);\r\n}\r\nstatic inline void spm_register_write_sync(struct spm_driver_data *drv,\r\nenum spm_reg reg, u32 val)\r\n{\r\nu32 ret;\r\nif (!drv->reg_data->reg_offset[reg])\r\nreturn;\r\ndo {\r\nwritel_relaxed(val, drv->reg_base +\r\ndrv->reg_data->reg_offset[reg]);\r\nret = readl_relaxed(drv->reg_base +\r\ndrv->reg_data->reg_offset[reg]);\r\nif (ret == val)\r\nbreak;\r\ncpu_relax();\r\n} while (1);\r\n}\r\nstatic inline u32 spm_register_read(struct spm_driver_data *drv,\r\nenum spm_reg reg)\r\n{\r\nreturn readl_relaxed(drv->reg_base + drv->reg_data->reg_offset[reg]);\r\n}\r\nstatic void spm_set_low_power_mode(struct spm_driver_data *drv,\r\nenum pm_sleep_mode mode)\r\n{\r\nu32 start_index;\r\nu32 ctl_val;\r\nstart_index = drv->reg_data->start_index[mode];\r\nctl_val = spm_register_read(drv, SPM_REG_SPM_CTL);\r\nctl_val &= ~(SPM_CTL_INDEX << SPM_CTL_INDEX_SHIFT);\r\nctl_val |= start_index << SPM_CTL_INDEX_SHIFT;\r\nctl_val |= SPM_CTL_EN;\r\nspm_register_write_sync(drv, SPM_REG_SPM_CTL, ctl_val);\r\n}\r\nstatic int qcom_pm_collapse(unsigned long int unused)\r\n{\r\nqcom_scm_cpu_power_down(QCOM_SCM_CPU_PWR_DOWN_L2_ON);\r\nreturn -1;\r\n}\r\nstatic int qcom_cpu_spc(void)\r\n{\r\nint ret;\r\nstruct spm_driver_data *drv = __this_cpu_read(cpu_spm_drv);\r\nspm_set_low_power_mode(drv, PM_SLEEP_MODE_SPC);\r\nret = cpu_suspend(0, qcom_pm_collapse);\r\nspm_set_low_power_mode(drv, PM_SLEEP_MODE_STBY);\r\nreturn ret;\r\n}\r\nstatic int qcom_idle_enter(unsigned long index)\r\n{\r\nreturn __this_cpu_read(qcom_idle_ops)[index]();\r\n}\r\nstatic int __init qcom_cpuidle_init(struct device_node *cpu_node, int cpu)\r\n{\r\nconst struct of_device_id *match_id;\r\nstruct device_node *state_node;\r\nint i;\r\nint state_count = 1;\r\nidle_fn idle_fns[CPUIDLE_STATE_MAX];\r\nidle_fn *fns;\r\ncpumask_t mask;\r\nbool use_scm_power_down = false;\r\nfor (i = 0; ; i++) {\r\nstate_node = of_parse_phandle(cpu_node, "cpu-idle-states", i);\r\nif (!state_node)\r\nbreak;\r\nif (!of_device_is_available(state_node))\r\ncontinue;\r\nif (i == CPUIDLE_STATE_MAX) {\r\npr_warn("%s: cpuidle states reached max possible\n",\r\n__func__);\r\nbreak;\r\n}\r\nmatch_id = of_match_node(qcom_idle_state_match, state_node);\r\nif (!match_id)\r\nreturn -ENODEV;\r\nidle_fns[state_count] = match_id->data;\r\nif (match_id->data == qcom_cpu_spc)\r\nuse_scm_power_down = true;\r\nstate_count++;\r\n}\r\nif (state_count == 1)\r\ngoto check_spm;\r\nfns = devm_kcalloc(get_cpu_device(cpu), state_count, sizeof(*fns),\r\nGFP_KERNEL);\r\nif (!fns)\r\nreturn -ENOMEM;\r\nfor (i = 1; i < state_count; i++)\r\nfns[i] = idle_fns[i];\r\nif (use_scm_power_down) {\r\ncpumask_clear(&mask);\r\ncpumask_set_cpu(cpu, &mask);\r\nqcom_scm_set_warm_boot_addr(cpu_resume_arm, &mask);\r\n}\r\nper_cpu(qcom_idle_ops, cpu) = fns;\r\ncheck_spm:\r\nreturn per_cpu(cpu_spm_drv, cpu) ? 0 : -ENXIO;\r\n}\r\nstatic struct spm_driver_data *spm_get_drv(struct platform_device *pdev,\r\nint *spm_cpu)\r\n{\r\nstruct spm_driver_data *drv = NULL;\r\nstruct device_node *cpu_node, *saw_node;\r\nint cpu;\r\nbool found = 0;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_node = of_cpu_device_node_get(cpu);\r\nif (!cpu_node)\r\ncontinue;\r\nsaw_node = of_parse_phandle(cpu_node, "qcom,saw", 0);\r\nfound = (saw_node == pdev->dev.of_node);\r\nof_node_put(saw_node);\r\nof_node_put(cpu_node);\r\nif (found)\r\nbreak;\r\n}\r\nif (found) {\r\ndrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);\r\nif (drv)\r\n*spm_cpu = cpu;\r\n}\r\nreturn drv;\r\n}\r\nstatic int spm_dev_probe(struct platform_device *pdev)\r\n{\r\nstruct spm_driver_data *drv;\r\nstruct resource *res;\r\nconst struct of_device_id *match_id;\r\nvoid __iomem *addr;\r\nint cpu;\r\ndrv = spm_get_drv(pdev, &cpu);\r\nif (!drv)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndrv->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(drv->reg_base))\r\nreturn PTR_ERR(drv->reg_base);\r\nmatch_id = of_match_node(spm_match_table, pdev->dev.of_node);\r\nif (!match_id)\r\nreturn -ENODEV;\r\ndrv->reg_data = match_id->data;\r\naddr = drv->reg_base + drv->reg_data->reg_offset[SPM_REG_SEQ_ENTRY];\r\n__iowrite32_copy(addr, drv->reg_data->seq,\r\nARRAY_SIZE(drv->reg_data->seq) / 4);\r\nspm_register_write(drv, SPM_REG_CFG, drv->reg_data->spm_cfg);\r\nspm_register_write(drv, SPM_REG_DLY, drv->reg_data->spm_dly);\r\nspm_register_write(drv, SPM_REG_PMIC_DLY, drv->reg_data->pmic_dly);\r\nspm_register_write(drv, SPM_REG_PMIC_DATA_0,\r\ndrv->reg_data->pmic_data[0]);\r\nspm_register_write(drv, SPM_REG_PMIC_DATA_1,\r\ndrv->reg_data->pmic_data[1]);\r\nspm_set_low_power_mode(drv, PM_SLEEP_MODE_STBY);\r\nper_cpu(cpu_spm_drv, cpu) = drv;\r\nreturn 0;\r\n}
