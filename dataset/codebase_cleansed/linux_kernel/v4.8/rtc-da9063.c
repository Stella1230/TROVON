static void da9063_data_to_tm(u8 *data, struct rtc_time *tm,\r\nstruct da9063_compatible_rtc *rtc)\r\n{\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\ntm->tm_sec = data[RTC_SEC] & config->rtc_count_sec_mask;\r\ntm->tm_min = data[RTC_MIN] & config->rtc_count_min_mask;\r\ntm->tm_hour = data[RTC_HOUR] & config->rtc_count_hour_mask;\r\ntm->tm_mday = data[RTC_DAY] & config->rtc_count_day_mask;\r\ntm->tm_mon = MONTHS_FROM_DA9063(data[RTC_MONTH] &\r\nconfig->rtc_count_month_mask);\r\ntm->tm_year = YEARS_FROM_DA9063(data[RTC_YEAR] &\r\nconfig->rtc_count_year_mask);\r\n}\r\nstatic void da9063_tm_to_data(struct rtc_time *tm, u8 *data,\r\nstruct da9063_compatible_rtc *rtc)\r\n{\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\ndata[RTC_SEC] = tm->tm_sec & config->rtc_count_sec_mask;\r\ndata[RTC_MIN] = tm->tm_min & config->rtc_count_min_mask;\r\ndata[RTC_HOUR] = tm->tm_hour & config->rtc_count_hour_mask;\r\ndata[RTC_DAY] = tm->tm_mday & config->rtc_count_day_mask;\r\ndata[RTC_MONTH] = MONTHS_TO_DA9063(tm->tm_mon) &\r\nconfig->rtc_count_month_mask;\r\ndata[RTC_YEAR] = YEARS_TO_DA9063(tm->tm_year) &\r\nconfig->rtc_count_year_mask;\r\n}\r\nstatic int da9063_rtc_stop_alarm(struct device *dev)\r\n{\r\nstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\nreturn regmap_update_bits(rtc->regmap,\r\nconfig->rtc_alarm_year_reg,\r\nconfig->rtc_alarm_on_mask,\r\n0);\r\n}\r\nstatic int da9063_rtc_start_alarm(struct device *dev)\r\n{\r\nstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\nreturn regmap_update_bits(rtc->regmap,\r\nconfig->rtc_alarm_year_reg,\r\nconfig->rtc_alarm_on_mask,\r\nconfig->rtc_alarm_on_mask);\r\n}\r\nstatic int da9063_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\nunsigned long tm_secs;\r\nunsigned long al_secs;\r\nu8 data[RTC_DATA_LEN];\r\nint ret;\r\nret = regmap_bulk_read(rtc->regmap,\r\nconfig->rtc_count_secs_reg,\r\ndata, RTC_DATA_LEN);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read RTC time data: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!(data[RTC_SEC] & config->rtc_ready_to_read_mask)) {\r\ndev_dbg(dev, "RTC not yet ready to be read by the host\n");\r\nreturn -EINVAL;\r\n}\r\nda9063_data_to_tm(data, tm, rtc);\r\nrtc_tm_to_time(tm, &tm_secs);\r\nrtc_tm_to_time(&rtc->alarm_time, &al_secs);\r\nif (rtc->rtc_sync == true && al_secs - tm_secs == 1)\r\nmemcpy(tm, &rtc->alarm_time, sizeof(struct rtc_time));\r\nelse\r\nrtc->rtc_sync = false;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int da9063_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\nu8 data[RTC_DATA_LEN];\r\nint ret;\r\nda9063_tm_to_data(tm, data, rtc);\r\nret = regmap_bulk_write(rtc->regmap,\r\nconfig->rtc_count_secs_reg,\r\ndata, RTC_DATA_LEN);\r\nif (ret < 0)\r\ndev_err(dev, "Failed to set RTC time data: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int da9063_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\nu8 data[RTC_DATA_LEN];\r\nint ret;\r\nunsigned int val;\r\ndata[RTC_SEC] = 0;\r\nret = regmap_bulk_read(rtc->regmap,\r\nconfig->rtc_alarm_secs_reg,\r\n&data[config->rtc_data_start],\r\nconfig->rtc_alarm_len);\r\nif (ret < 0)\r\nreturn ret;\r\nda9063_data_to_tm(data, &alrm->time, rtc);\r\nalrm->enabled = !!(data[RTC_YEAR] & config->rtc_alarm_on_mask);\r\nret = regmap_read(rtc->regmap,\r\nconfig->rtc_event_reg,\r\n&val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val & config->rtc_event_alarm_mask)\r\nalrm->pending = 1;\r\nelse\r\nalrm->pending = 0;\r\nreturn 0;\r\n}\r\nstatic int da9063_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct da9063_compatible_rtc *rtc = dev_get_drvdata(dev);\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\nu8 data[RTC_DATA_LEN];\r\nint ret;\r\nda9063_tm_to_data(&alrm->time, data, rtc);\r\nret = da9063_rtc_stop_alarm(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to stop alarm: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_bulk_write(rtc->regmap,\r\nconfig->rtc_alarm_secs_reg,\r\n&data[config->rtc_data_start],\r\nconfig->rtc_alarm_len);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to write alarm: %d\n", ret);\r\nreturn ret;\r\n}\r\nda9063_data_to_tm(data, &rtc->alarm_time, rtc);\r\nif (alrm->enabled) {\r\nret = da9063_rtc_start_alarm(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to start alarm: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int da9063_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nif (enabled)\r\nreturn da9063_rtc_start_alarm(dev);\r\nelse\r\nreturn da9063_rtc_stop_alarm(dev);\r\n}\r\nstatic irqreturn_t da9063_alarm_event(int irq, void *data)\r\n{\r\nstruct da9063_compatible_rtc *rtc = data;\r\nconst struct da9063_compatible_rtc_regmap *config = rtc->config;\r\nregmap_update_bits(rtc->regmap,\r\nconfig->rtc_alarm_year_reg,\r\nconfig->rtc_alarm_on_mask,\r\n0);\r\nrtc->rtc_sync = true;\r\nrtc_update_irq(rtc->rtc_dev, 1, RTC_IRQF | RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int da9063_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct da9063_compatible_rtc *rtc;\r\nconst struct da9063_compatible_rtc_regmap *config;\r\nconst struct of_device_id *match;\r\nint irq_alarm;\r\nu8 data[RTC_DATA_LEN];\r\nint ret;\r\nif (!pdev->dev.of_node)\r\nreturn -ENXIO;\r\nmatch = of_match_node(da9063_compatible_reg_id_table,\r\npdev->dev.of_node);\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nrtc->config = match->data;\r\nif (of_device_is_compatible(pdev->dev.of_node, "dlg,da9063-rtc")) {\r\nstruct da9063 *chip = dev_get_drvdata(pdev->dev.parent);\r\nif (chip->variant_code == PMIC_DA9063_AD)\r\nrtc->config = &da9063_ad_regs;\r\n}\r\nrtc->regmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!rtc->regmap) {\r\ndev_warn(&pdev->dev, "Parent regmap unavailable.\n");\r\nreturn -ENXIO;\r\n}\r\nconfig = rtc->config;\r\nret = regmap_update_bits(rtc->regmap,\r\nconfig->rtc_enable_reg,\r\nconfig->rtc_enable_mask,\r\nconfig->rtc_enable_mask);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to enable RTC\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(rtc->regmap,\r\nconfig->rtc_enable_32k_crystal_reg,\r\nconfig->rtc_crystal_mask,\r\nconfig->rtc_crystal_mask);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to run 32kHz oscillator\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(rtc->regmap,\r\nconfig->rtc_alarm_secs_reg,\r\nconfig->rtc_alarm_status_mask,\r\n0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to access RTC alarm register\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(rtc->regmap,\r\nconfig->rtc_alarm_secs_reg,\r\nDA9063_ALARM_STATUS_ALARM,\r\nDA9063_ALARM_STATUS_ALARM);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to access RTC alarm register\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(rtc->regmap,\r\nconfig->rtc_alarm_year_reg,\r\nconfig->rtc_tick_on_mask,\r\n0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to disable TICKs\n");\r\nreturn ret;\r\n}\r\ndata[RTC_SEC] = 0;\r\nret = regmap_bulk_read(rtc->regmap,\r\nconfig->rtc_alarm_secs_reg,\r\n&data[config->rtc_data_start],\r\nconfig->rtc_alarm_len);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to read initial alarm data: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nrtc->rtc_dev = devm_rtc_device_register(&pdev->dev, DA9063_DRVNAME_RTC,\r\n&da9063_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc_dev))\r\nreturn PTR_ERR(rtc->rtc_dev);\r\nda9063_data_to_tm(data, &rtc->alarm_time, rtc);\r\nrtc->rtc_sync = false;\r\nirq_alarm = platform_get_irq_byname(pdev, "ALARM");\r\nret = devm_request_threaded_irq(&pdev->dev, irq_alarm, NULL,\r\nda9063_alarm_event,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"ALARM", rtc);\r\nif (ret)\r\ndev_err(&pdev->dev, "Failed to request ALARM IRQ %d: %d\n",\r\nirq_alarm, ret);\r\nreturn ret;\r\n}
