static int alloc_urb_from_cmd(struct urb **urbp,\r\nstruct usbip_header *pdu, u8 type)\r\n{\r\nstruct urb *urb;\r\nif (type == USB_ENDPOINT_XFER_ISOC)\r\nurb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets,\r\nGFP_KERNEL);\r\nelse\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\ngoto err;\r\nusbip_pack_pdu(pdu, urb, USBIP_CMD_SUBMIT, 0);\r\nif (urb->transfer_buffer_length > 0) {\r\nurb->transfer_buffer = kzalloc(urb->transfer_buffer_length,\r\nGFP_KERNEL);\r\nif (!urb->transfer_buffer)\r\ngoto free_urb;\r\n}\r\nurb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8,\r\nGFP_KERNEL);\r\nif (!urb->setup_packet)\r\ngoto free_buffer;\r\nurb->pipe |= pdu->base.direction == USBIP_DIR_IN ?\r\nUSB_DIR_IN : USB_DIR_OUT;\r\n*urbp = urb;\r\nreturn 0;\r\nfree_buffer:\r\nkfree(urb->transfer_buffer);\r\nurb->transfer_buffer = NULL;\r\nfree_urb:\r\nusb_free_urb(urb);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic int v_recv_cmd_unlink(struct vudc *udc,\r\nstruct usbip_header *pdu)\r\n{\r\nunsigned long flags;\r\nstruct urbp *urb_p;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nlist_for_each_entry(urb_p, &udc->urb_queue, urb_entry) {\r\nif (urb_p->seqnum != pdu->u.cmd_unlink.seqnum)\r\ncontinue;\r\nurb_p->urb->unlinked = -ECONNRESET;\r\nurb_p->seqnum = pdu->base.seqnum;\r\nv_kick_timer(udc, jiffies);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nspin_lock(&udc->lock_tx);\r\nv_enqueue_ret_unlink(udc, pdu->base.seqnum, 0);\r\nwake_up(&udc->tx_waitq);\r\nspin_unlock(&udc->lock_tx);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int v_recv_cmd_submit(struct vudc *udc,\r\nstruct usbip_header *pdu)\r\n{\r\nint ret = 0;\r\nstruct urbp *urb_p;\r\nu8 address;\r\nunsigned long flags;\r\nurb_p = alloc_urbp();\r\nif (!urb_p) {\r\nusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_MALLOC);\r\nreturn -ENOMEM;\r\n}\r\naddress = pdu->base.ep;\r\nif (pdu->base.direction == USBIP_DIR_IN)\r\naddress |= USB_DIR_IN;\r\nspin_lock_irq(&udc->lock);\r\nurb_p->ep = vudc_find_endpoint(udc, address);\r\nif (!urb_p->ep) {\r\ndev_err(&udc->pdev->dev, "request to nonexistent endpoint");\r\nspin_unlock_irq(&udc->lock);\r\nusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_TCP);\r\nret = -EPIPE;\r\ngoto free_urbp;\r\n}\r\nurb_p->type = urb_p->ep->type;\r\nspin_unlock_irq(&udc->lock);\r\nurb_p->new = 1;\r\nurb_p->seqnum = pdu->base.seqnum;\r\nret = alloc_urb_from_cmd(&urb_p->urb, pdu, urb_p->ep->type);\r\nif (ret) {\r\nusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_MALLOC);\r\nret = -ENOMEM;\r\ngoto free_urbp;\r\n}\r\nurb_p->urb->status = -EINPROGRESS;\r\nurb_p->urb->pipe &= ~(11 << 30);\r\nswitch (urb_p->ep->type) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nurb_p->urb->pipe |= (PIPE_BULK << 30);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nurb_p->urb->pipe |= (PIPE_INTERRUPT << 30);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nurb_p->urb->pipe |= (PIPE_CONTROL << 30);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nurb_p->urb->pipe |= (PIPE_ISOCHRONOUS << 30);\r\nbreak;\r\n}\r\nret = usbip_recv_xbuff(&udc->ud, urb_p->urb);\r\nif (ret < 0)\r\ngoto free_urbp;\r\nret = usbip_recv_iso(&udc->ud, urb_p->urb);\r\nif (ret < 0)\r\ngoto free_urbp;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nv_kick_timer(udc, jiffies);\r\nlist_add_tail(&urb_p->urb_entry, &udc->urb_queue);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\nfree_urbp:\r\nfree_urbp_and_urb(urb_p);\r\nreturn ret;\r\n}\r\nstatic int v_rx_pdu(struct usbip_device *ud)\r\n{\r\nint ret;\r\nstruct usbip_header pdu;\r\nstruct vudc *udc = container_of(ud, struct vudc, ud);\r\nmemset(&pdu, 0, sizeof(pdu));\r\nret = usbip_recv(ud->tcp_socket, &pdu, sizeof(pdu));\r\nif (ret != sizeof(pdu)) {\r\nusbip_event_add(ud, VUDC_EVENT_ERROR_TCP);\r\nif (ret >= 0)\r\nreturn -EPIPE;\r\nreturn ret;\r\n}\r\nusbip_header_correct_endian(&pdu, 0);\r\nspin_lock_irq(&ud->lock);\r\nret = (ud->status == SDEV_ST_USED);\r\nspin_unlock_irq(&ud->lock);\r\nif (!ret) {\r\nusbip_event_add(ud, VUDC_EVENT_ERROR_TCP);\r\nreturn -EBUSY;\r\n}\r\nswitch (pdu.base.command) {\r\ncase USBIP_CMD_UNLINK:\r\nret = v_recv_cmd_unlink(udc, &pdu);\r\nbreak;\r\ncase USBIP_CMD_SUBMIT:\r\nret = v_recv_cmd_submit(udc, &pdu);\r\nbreak;\r\ndefault:\r\nret = -EPIPE;\r\npr_err("rx: unknown command");\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint v_rx_loop(void *data)\r\n{\r\nstruct usbip_device *ud = data;\r\nint ret = 0;\r\nwhile (!kthread_should_stop()) {\r\nif (usbip_event_happened(ud))\r\nbreak;\r\nret = v_rx_pdu(ud);\r\nif (ret < 0) {\r\npr_warn("v_rx exit with error %d", ret);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}
