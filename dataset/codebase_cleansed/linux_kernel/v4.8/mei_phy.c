static int mei_nfc_if_version(struct nfc_mei_phy *phy)\r\n{\r\nstruct mei_nfc_cmd cmd;\r\nstruct mei_nfc_reply *reply = NULL;\r\nstruct mei_nfc_if_version *version;\r\nsize_t if_version_length;\r\nint bytes_recv, r;\r\npr_info("%s\n", __func__);\r\nmemset(&cmd, 0, sizeof(struct mei_nfc_cmd));\r\ncmd.hdr.cmd = MEI_NFC_CMD_MAINTENANCE;\r\ncmd.hdr.data_size = 1;\r\ncmd.sub_command = MEI_NFC_SUBCMD_IF_VERSION;\r\nMEI_DUMP_NFC_HDR("version", &cmd.hdr);\r\nr = mei_cldev_send(phy->cldev, (u8 *)&cmd, sizeof(struct mei_nfc_cmd));\r\nif (r < 0) {\r\npr_err("Could not send IF version cmd\n");\r\nreturn r;\r\n}\r\nif_version_length = sizeof(struct mei_nfc_reply) +\r\nsizeof(struct mei_nfc_if_version);\r\nreply = kzalloc(if_version_length, GFP_KERNEL);\r\nif (!reply)\r\nreturn -ENOMEM;\r\nbytes_recv = mei_cldev_recv(phy->cldev, (u8 *)reply, if_version_length);\r\nif (bytes_recv < 0 || bytes_recv < sizeof(struct mei_nfc_reply)) {\r\npr_err("Could not read IF version\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\nversion = (struct mei_nfc_if_version *)reply->data;\r\nphy->fw_ivn = version->fw_ivn;\r\nphy->vendor_id = version->vendor_id;\r\nphy->radio_type = version->radio_type;\r\nerr:\r\nkfree(reply);\r\nreturn r;\r\n}\r\nstatic int mei_nfc_connect(struct nfc_mei_phy *phy)\r\n{\r\nstruct mei_nfc_cmd *cmd, *reply;\r\nstruct mei_nfc_connect *connect;\r\nstruct mei_nfc_connect_resp *connect_resp;\r\nsize_t connect_length, connect_resp_length;\r\nint bytes_recv, r;\r\npr_info("%s\n", __func__);\r\nconnect_length = sizeof(struct mei_nfc_cmd) +\r\nsizeof(struct mei_nfc_connect);\r\nconnect_resp_length = sizeof(struct mei_nfc_cmd) +\r\nsizeof(struct mei_nfc_connect_resp);\r\ncmd = kzalloc(connect_length, GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nconnect = (struct mei_nfc_connect *)cmd->data;\r\nreply = kzalloc(connect_resp_length, GFP_KERNEL);\r\nif (!reply) {\r\nkfree(cmd);\r\nreturn -ENOMEM;\r\n}\r\nconnect_resp = (struct mei_nfc_connect_resp *)reply->data;\r\ncmd->hdr.cmd = MEI_NFC_CMD_MAINTENANCE;\r\ncmd->hdr.data_size = 3;\r\ncmd->sub_command = MEI_NFC_SUBCMD_CONNECT;\r\nconnect->fw_ivn = phy->fw_ivn;\r\nconnect->vendor_id = phy->vendor_id;\r\nMEI_DUMP_NFC_HDR("connect request", &cmd->hdr);\r\nr = mei_cldev_send(phy->cldev, (u8 *)cmd, connect_length);\r\nif (r < 0) {\r\npr_err("Could not send connect cmd %d\n", r);\r\ngoto err;\r\n}\r\nbytes_recv = mei_cldev_recv(phy->cldev, (u8 *)reply,\r\nconnect_resp_length);\r\nif (bytes_recv < 0) {\r\nr = bytes_recv;\r\npr_err("Could not read connect response %d\n", r);\r\ngoto err;\r\n}\r\nMEI_DUMP_NFC_HDR("connect reply", &reply->hdr);\r\npr_info("IVN 0x%x Vendor ID 0x%x\n",\r\nconnect_resp->fw_ivn, connect_resp->vendor_id);\r\npr_info("ME FW %d.%d.%d.%d\n",\r\nconnect_resp->me_major, connect_resp->me_minor,\r\nconnect_resp->me_hotfix, connect_resp->me_build);\r\nr = 0;\r\nerr:\r\nkfree(reply);\r\nkfree(cmd);\r\nreturn r;\r\n}\r\nstatic int mei_nfc_send(struct nfc_mei_phy *phy, u8 *buf, size_t length)\r\n{\r\nstruct mei_nfc_hdr *hdr;\r\nu8 *mei_buf;\r\nint err;\r\nerr = -ENOMEM;\r\nmei_buf = kzalloc(length + MEI_NFC_HEADER_SIZE, GFP_KERNEL);\r\nif (!mei_buf)\r\ngoto out;\r\nhdr = (struct mei_nfc_hdr *)mei_buf;\r\nhdr->cmd = MEI_NFC_CMD_HCI_SEND;\r\nhdr->status = 0;\r\nhdr->req_id = phy->req_id;\r\nhdr->reserved = 0;\r\nhdr->data_size = length;\r\nMEI_DUMP_NFC_HDR("send", hdr);\r\nmemcpy(mei_buf + MEI_NFC_HEADER_SIZE, buf, length);\r\nerr = mei_cldev_send(phy->cldev, mei_buf, length + MEI_NFC_HEADER_SIZE);\r\nif (err < 0)\r\ngoto out;\r\nif (!wait_event_interruptible_timeout(phy->send_wq,\r\nphy->recv_req_id == phy->req_id, HZ)) {\r\npr_err("NFC MEI command timeout\n");\r\nerr = -ETIME;\r\n} else {\r\nphy->req_id++;\r\n}\r\nout:\r\nkfree(mei_buf);\r\nreturn err;\r\n}\r\nstatic int nfc_mei_phy_write(void *phy_id, struct sk_buff *skb)\r\n{\r\nstruct nfc_mei_phy *phy = phy_id;\r\nint r;\r\nMEI_DUMP_SKB_OUT("mei frame sent", skb);\r\nr = mei_nfc_send(phy, skb->data, skb->len);\r\nif (r > 0)\r\nr = 0;\r\nreturn r;\r\n}\r\nstatic int mei_nfc_recv(struct nfc_mei_phy *phy, u8 *buf, size_t length)\r\n{\r\nstruct mei_nfc_hdr *hdr;\r\nint received_length;\r\nreceived_length = mei_cldev_recv(phy->cldev, buf, length);\r\nif (received_length < 0)\r\nreturn received_length;\r\nhdr = (struct mei_nfc_hdr *) buf;\r\nMEI_DUMP_NFC_HDR("receive", hdr);\r\nif (hdr->cmd == MEI_NFC_CMD_HCI_SEND) {\r\nphy->recv_req_id = hdr->req_id;\r\nwake_up(&phy->send_wq);\r\nreturn 0;\r\n}\r\nreturn received_length;\r\n}\r\nstatic void nfc_mei_event_cb(struct mei_cl_device *cldev, u32 events,\r\nvoid *context)\r\n{\r\nstruct nfc_mei_phy *phy = context;\r\nif (phy->hard_fault != 0)\r\nreturn;\r\nif (events & BIT(MEI_CL_EVENT_RX)) {\r\nstruct sk_buff *skb;\r\nint reply_size;\r\nskb = alloc_skb(MEI_NFC_MAX_READ, GFP_KERNEL);\r\nif (!skb)\r\nreturn;\r\nreply_size = mei_nfc_recv(phy, skb->data, MEI_NFC_MAX_READ);\r\nif (reply_size < MEI_NFC_HEADER_SIZE) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nskb_put(skb, reply_size);\r\nskb_pull(skb, MEI_NFC_HEADER_SIZE);\r\nMEI_DUMP_SKB_IN("mei frame read", skb);\r\nnfc_hci_recv_frame(phy->hdev, skb);\r\n}\r\n}\r\nstatic int nfc_mei_phy_enable(void *phy_id)\r\n{\r\nint r;\r\nstruct nfc_mei_phy *phy = phy_id;\r\npr_info("%s\n", __func__);\r\nif (phy->powered == 1)\r\nreturn 0;\r\nr = mei_cldev_enable(phy->cldev);\r\nif (r < 0) {\r\npr_err("Could not enable device %d\n", r);\r\nreturn r;\r\n}\r\nr = mei_nfc_if_version(phy);\r\nif (r < 0) {\r\npr_err("Could not enable device %d\n", r);\r\ngoto err;\r\n}\r\nr = mei_nfc_connect(phy);\r\nif (r < 0) {\r\npr_err("Could not connect to device %d\n", r);\r\ngoto err;\r\n}\r\nr = mei_cldev_register_event_cb(phy->cldev, BIT(MEI_CL_EVENT_RX),\r\nnfc_mei_event_cb, phy);\r\nif (r) {\r\npr_err("Event cb registration failed %d\n", r);\r\ngoto err;\r\n}\r\nphy->powered = 1;\r\nreturn 0;\r\nerr:\r\nphy->powered = 0;\r\nmei_cldev_disable(phy->cldev);\r\nreturn r;\r\n}\r\nstatic void nfc_mei_phy_disable(void *phy_id)\r\n{\r\nstruct nfc_mei_phy *phy = phy_id;\r\npr_info("%s\n", __func__);\r\nmei_cldev_disable(phy->cldev);\r\nphy->powered = 0;\r\n}\r\nstruct nfc_mei_phy *nfc_mei_phy_alloc(struct mei_cl_device *cldev)\r\n{\r\nstruct nfc_mei_phy *phy;\r\nphy = kzalloc(sizeof(struct nfc_mei_phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn NULL;\r\nphy->cldev = cldev;\r\ninit_waitqueue_head(&phy->send_wq);\r\nmei_cldev_set_drvdata(cldev, phy);\r\nreturn phy;\r\n}\r\nvoid nfc_mei_phy_free(struct nfc_mei_phy *phy)\r\n{\r\nmei_cldev_disable(phy->cldev);\r\nkfree(phy);\r\n}
